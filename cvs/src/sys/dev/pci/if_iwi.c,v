head	1.136;
access;
symbols
	OPENBSD_6_1_BASE:1.136
	OPENBSD_6_0:1.132.0.4
	OPENBSD_6_0_BASE:1.132
	OPENBSD_5_9:1.131.0.2
	OPENBSD_5_9_BASE:1.131
	OPENBSD_5_8:1.125.0.4
	OPENBSD_5_8_BASE:1.125
	OPENBSD_5_7:1.123.0.4
	OPENBSD_5_7_BASE:1.123
	OPENBSD_5_6:1.118.0.4
	OPENBSD_5_6_BASE:1.118
	OPENBSD_5_5:1.116.0.4
	OPENBSD_5_5_BASE:1.116
	OPENBSD_5_4:1.111.0.12
	OPENBSD_5_4_BASE:1.111
	OPENBSD_5_3:1.111.0.10
	OPENBSD_5_3_BASE:1.111
	OPENBSD_5_2:1.111.0.8
	OPENBSD_5_2_BASE:1.111
	OPENBSD_5_1_BASE:1.111
	OPENBSD_5_1:1.111.0.6
	OPENBSD_5_0:1.111.0.4
	OPENBSD_5_0_BASE:1.111
	OPENBSD_4_9:1.111.0.2
	OPENBSD_4_9_BASE:1.111
	OPENBSD_4_8:1.105.0.2
	OPENBSD_4_8_BASE:1.105
	OPENBSD_4_7:1.101.0.2
	OPENBSD_4_7_BASE:1.101
	OPENBSD_4_6:1.101.0.4
	OPENBSD_4_6_BASE:1.101
	OPENBSD_4_5:1.99.0.2
	OPENBSD_4_5_BASE:1.99
	OPENBSD_4_4:1.87.0.2
	OPENBSD_4_4_BASE:1.87
	OPENBSD_4_3:1.86.0.2
	OPENBSD_4_3_BASE:1.86
	OPENBSD_4_2:1.83.0.2
	OPENBSD_4_2_BASE:1.83
	OPENBSD_4_1:1.79.0.2
	OPENBSD_4_1_BASE:1.79
	OPENBSD_4_0:1.73.0.2
	OPENBSD_4_0_BASE:1.73
	OPENBSD_3_9:1.60.0.2
	OPENBSD_3_9_BASE:1.60
	OPENBSD_3_8:1.48.0.2
	OPENBSD_3_8_BASE:1.48
	OPENBSD_3_7:1.31.0.2
	OPENBSD_3_7_BASE:1.31;
locks; strict;
comment	@ * @;


1.136
date	2017.03.29.16.42.25;	author stsp;	state Exp;
branches;
next	1.135;
commitid	o6oFOFA96aVlPOHi;

1.135
date	2017.03.08.12.02.41;	author mpi;	state Exp;
branches;
next	1.134;
commitid	okVP7pbbXG8IxGgU;

1.134
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.133;
commitid	VyLWTsbepAOk7VQM;

1.133
date	2016.09.05.08.17.48;	author tedu;	state Exp;
branches;
next	1.132;
commitid	a7moayKlo9ztd3AK;

1.132
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.131;
commitid	8YSL8ByWzGeIGBiJ;

1.131
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.130;
commitid	B0kwmVGiD5DVx4kv;

1.130
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.129;
commitid	FuSD2mFDJWATHIDx;

1.129
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.128;
commitid	5DvsamK0GblTp8ww;

1.128
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.127;
commitid	eYnPulzvLjDImPCa;

1.127
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.126;
commitid	hPF95ClMUQfeqQDX;

1.126
date	2015.09.01.07.09.55;	author deraadt;	state Exp;
branches;
next	1.125;
commitid	VvLv8PeakqoJLqr3;

1.125
date	2015.05.27.22.10.52;	author kettenis;	state Exp;
branches;
next	1.124;
commitid	lWmV3RdleHaEaZ4U;

1.124
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.123;
commitid	p4LJxGKbi0BU2cG6;

1.123
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.122;
commitid	Hly9lJn6CNMylcFu;

1.122
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.121;
commitid	MyKPm9Q3dQu92BiX;

1.121
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.120;
commitid	yM2VFFhpDTeFQlve;

1.120
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.119;
commitid	LS2TNeCue5R9L67C;

1.119
date	2014.11.18.02.37.30;	author tedu;	state Exp;
branches;
next	1.118;
commitid	Z1vcFtHO8wRH0yRt;

1.118
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.117;
commitid	TGHgrLxu6sxZoiFt;

1.117
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.116;
commitid	OBNa5kfxQ2UXoiIw;

1.116
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.115;

1.115
date	2013.12.03.22.37.24;	author kettenis;	state Exp;
branches;
next	1.114;

1.114
date	2013.11.14.12.39.14;	author dlg;	state Exp;
branches;
next	1.113;

1.113
date	2013.10.01.20.06.00;	author sf;	state Exp;
branches;
next	1.112;

1.112
date	2013.08.07.01.06.35;	author bluhm;	state Exp;
branches;
next	1.111;

1.111
date	2010.11.15.19.11.57;	author damien;	state Exp;
branches;
next	1.110;

1.110
date	2010.09.07.16.21.45;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2010.08.27.20.09.01;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.107;

1.107
date	2010.08.12.16.59.29;	author damien;	state Exp;
branches;
next	1.106;

1.106
date	2010.08.12.15.03.59;	author oga;	state Exp;
branches;
next	1.105;

1.105
date	2010.08.03.18.26.25;	author kettenis;	state Exp;
branches;
next	1.104;

1.104
date	2010.07.28.21.21.38;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.102;

1.102
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.101;

1.101
date	2009.05.11.19.24.57;	author damien;	state Exp;
branches;
next	1.100;

1.100
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.99;

1.99
date	2009.01.26.19.09.41;	author damien;	state Exp;
branches;
next	1.98;

1.98
date	2008.12.22.18.20.47;	author damien;	state Exp;
branches;
next	1.97;

1.97
date	2008.12.21.18.19.58;	author damien;	state Exp;
branches;
next	1.96;

1.96
date	2008.11.25.22.20.11;	author damien;	state Exp;
branches;
next	1.95;

1.95
date	2008.11.25.21.43.57;	author damien;	state Exp;
branches;
next	1.94;

1.94
date	2008.09.04.15.59.52;	author damien;	state Exp;
branches;
next	1.93;

1.93
date	2008.09.03.19.47.58;	author damien;	state Exp;
branches;
next	1.92;

1.92
date	2008.09.03.19.43.59;	author damien;	state Exp;
branches;
next	1.91;

1.91
date	2008.08.28.15.55.37;	author damien;	state Exp;
branches;
next	1.90;

1.90
date	2008.08.28.15.52.20;	author damien;	state Exp;
branches;
next	1.89;

1.89
date	2008.08.27.09.28.38;	author damien;	state Exp;
branches;
next	1.88;

1.88
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.87;

1.87
date	2008.07.21.18.43.18;	author damien;	state Exp;
branches;
next	1.86;

1.86
date	2007.11.17.19.09.16;	author damien;	state Exp;
branches;
next	1.85;

1.85
date	2007.09.07.19.05.05;	author damien;	state Exp;
branches;
next	1.84;

1.84
date	2007.08.28.18.34.38;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2007.07.18.18.10.31;	author damien;	state Exp;
branches;
next	1.82;

1.82
date	2007.07.06.18.03.42;	author damien;	state Exp;
branches;
next	1.81;

1.81
date	2007.07.05.21.38.19;	author damien;	state Exp;
branches;
next	1.80;

1.80
date	2007.07.05.20.31.38;	author damien;	state Exp;
branches;
next	1.79;

1.79
date	2007.01.03.18.19.06;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2006.11.26.11.14.22;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2006.10.23.18.19.26;	author damien;	state Exp;
branches;
next	1.76;

1.76
date	2006.10.22.08.25.43;	author damien;	state Exp;
branches;
next	1.75;

1.75
date	2006.09.29.05.34.25;	author brad;	state Exp;
branches;
next	1.74;

1.74
date	2006.09.18.16.20.20;	author damien;	state Exp;
branches;
next	1.73;

1.73
date	2006.08.19.14.57.37;	author damien;	state Exp;
branches;
next	1.72;

1.72
date	2006.08.19.12.03.05;	author damien;	state Exp;
branches;
next	1.71;

1.71
date	2006.08.19.11.07.44;	author damien;	state Exp;
branches;
next	1.70;

1.70
date	2006.08.18.16.04.56;	author damien;	state Exp;
branches;
next	1.69;

1.69
date	2006.06.14.18.40.23;	author brad;	state Exp;
branches;
next	1.68;

1.68
date	2006.05.17.19.54.10;	author damien;	state Exp;
branches;
next	1.67;

1.67
date	2006.05.01.08.39.17;	author damien;	state Exp;
branches;
next	1.66;

1.66
date	2006.04.02.20.30.19;	author dim;	state Exp;
branches;
next	1.65;

1.65
date	2006.04.01.15.36.01;	author mickey;	state Exp;
branches;
next	1.64;

1.64
date	2006.04.01.01.04.40;	author pedro;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.31.17.18.36;	author pedro;	state Exp;
branches;
next	1.62;

1.62
date	2006.03.27.20.46.35;	author damien;	state Exp;
branches;
next	1.61;

1.61
date	2006.03.25.22.41.45;	author djm;	state Exp;
branches;
next	1.60;

1.60
date	2006.02.26.19.14.40;	author damien;	state Exp;
branches;
next	1.59;

1.59
date	2006.02.04.11.36.32;	author damien;	state Exp;
branches;
next	1.58;

1.58
date	2006.01.29.15.44.16;	author damien;	state Exp;
branches;
next	1.57;

1.57
date	2006.01.18.20.25.22;	author damien;	state Exp;
branches;
next	1.56;

1.56
date	2006.01.04.06.04.41;	author canacar;	state Exp;
branches;
next	1.55;

1.55
date	2005.11.23.21.29.05;	author damien;	state Exp;
branches;
next	1.54;

1.54
date	2005.11.23.21.08.46;	author damien;	state Exp;
branches;
next	1.53;

1.53
date	2005.11.23.21.04.40;	author damien;	state Exp;
branches;
next	1.52;

1.52
date	2005.11.23.20.57.09;	author damien;	state Exp;
branches;
next	1.51;

1.51
date	2005.10.07.06.33.11;	author damien;	state Exp;
branches;
next	1.50;

1.50
date	2005.10.06.20.33.39;	author damien;	state Exp;
branches;
next	1.49;

1.49
date	2005.09.19.20.01.11;	author damien;	state Exp;
branches;
next	1.48;

1.48
date	2005.08.09.04.10.12;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	2005.07.12.18.18.13;	author damien;	state Exp;
branches;
next	1.46;

1.46
date	2005.07.02.23.10.11;	author brad;	state Exp;
branches;
next	1.45;

1.45
date	2005.06.20.18.25.14;	author damien;	state Exp;
branches;
next	1.44;

1.44
date	2005.05.22.16.30.30;	author damien;	state Exp;
branches;
next	1.43;

1.43
date	2005.05.22.16.28.00;	author damien;	state Exp;
branches;
next	1.42;

1.42
date	2005.05.22.16.05.47;	author damien;	state Exp;
branches;
next	1.41;

1.41
date	2005.05.22.15.28.45;	author damien;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.22.15.14.10;	author damien;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.14.13.32.38;	author damien;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.13.20.52.51;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.13.20.24.59;	author damien;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.17.13.49.09;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2005.04.17.13.41.46;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2005.04.04.16.37.07;	author damien;	state Exp;
branches;
next	1.33;

1.33
date	2005.04.04.16.31.52;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.23.14.14.30;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.17.20.08.13;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.14.13.21.42;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.12.13.37.49;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.12.13.25.45;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2005.02.21.13.33.29;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.19.13.38.01;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.17.18.28.05;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2005.01.09.16.47.50;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2005.01.05.09.07.15;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.21.17.29.53;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.10.21.25.53;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.06.20.27.15;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.06.19.58.44;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.06.19.54.05;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.04.19.40.37;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.04.19.19.24;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.04.19.01.46;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.04.17.24.06;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.24.21.17.26;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.24.21.00.50;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.24.20.57.25;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.24.20.50.55;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.24.20.44.10;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.23.21.28.22;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.22.21.34.35;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.22.19.52.59;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.28.23.06.10;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2004.10.28.22.12.00;	author jcs;	state Exp;
branches;
next	1.3;

1.3
date	2004.10.27.21.33.52;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2004.10.20.22.26.42;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.10.20.12.50.48;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.136
log
@Fix iwi(4) regressions. WPA was broken since 6.0 errata 018.
Also, the firmware was rejecting RTS frames so iwi(4) didn't work against
an OpenBSD athn(4) hostap anymore; fix the config sent to firmware.
Prompted by report from bg2200 at jamesjerkinscomputer on misc@@
ok deraadt@@
@
text
@/*	$OpenBSD: if_iwi.c,v 1.135 2017/03/08 12:02:41 mpi Exp $	*/

/*-
 * Copyright (c) 2004-2008
 *      Damien Bergamini <damien.bergamini@@free.fr>. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Driver for Intel PRO/Wireless 2200BG/2915ABG 802.11 network adapters.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/rwlock.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/task.h>
#include <sys/endian.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/pci/if_iwireg.h>
#include <dev/pci/if_iwivar.h>

const struct pci_matchid iwi_devices[] = {
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_WL_2200BG },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_WL_2225BG },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_WL_2915ABG_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_WL_2915ABG_2 }
};

int		iwi_match(struct device *, void *, void *);
void		iwi_attach(struct device *, struct device *, void *);
int		iwi_activate(struct device *, int);
void		iwi_wakeup(struct iwi_softc *);
void		iwi_init_task(void *);
int		iwi_alloc_cmd_ring(struct iwi_softc *, struct iwi_cmd_ring *);
void		iwi_reset_cmd_ring(struct iwi_softc *, struct iwi_cmd_ring *);
void		iwi_free_cmd_ring(struct iwi_softc *, struct iwi_cmd_ring *);
int		iwi_alloc_tx_ring(struct iwi_softc *, struct iwi_tx_ring *,
		    int);
void		iwi_reset_tx_ring(struct iwi_softc *, struct iwi_tx_ring *);
void		iwi_free_tx_ring(struct iwi_softc *, struct iwi_tx_ring *);
int		iwi_alloc_rx_ring(struct iwi_softc *, struct iwi_rx_ring *);
void		iwi_reset_rx_ring(struct iwi_softc *, struct iwi_rx_ring *);
void		iwi_free_rx_ring(struct iwi_softc *, struct iwi_rx_ring *);
int		iwi_media_change(struct ifnet *);
void		iwi_media_status(struct ifnet *, struct ifmediareq *);
uint16_t	iwi_read_prom_word(struct iwi_softc *, uint8_t);
int		iwi_find_txnode(struct iwi_softc *, const uint8_t *);
int		iwi_newstate(struct ieee80211com *, enum ieee80211_state, int);
uint8_t		iwi_rate(int);
void		iwi_frame_intr(struct iwi_softc *, struct iwi_rx_data *,
		    struct iwi_frame *);
void		iwi_notification_intr(struct iwi_softc *, struct iwi_rx_data *,
		    struct iwi_notif *);
void		iwi_rx_intr(struct iwi_softc *);
void		iwi_tx_intr(struct iwi_softc *, struct iwi_tx_ring *);
int		iwi_intr(void *);
int		iwi_cmd(struct iwi_softc *, uint8_t, void *, uint8_t, int);
int		iwi_send_mgmt(struct ieee80211com *, struct ieee80211_node *,
		    int, int, int);
int		iwi_tx_start(struct ifnet *, struct mbuf *,
		    struct ieee80211_node *);
void		iwi_start(struct ifnet *);
void		iwi_watchdog(struct ifnet *);
int		iwi_ioctl(struct ifnet *, u_long, caddr_t);
void		iwi_stop_master(struct iwi_softc *);
int		iwi_reset(struct iwi_softc *);
int		iwi_load_ucode(struct iwi_softc *, const char *, int);
int		iwi_load_firmware(struct iwi_softc *, const char *, int);
int		iwi_config(struct iwi_softc *);
void		iwi_update_edca(struct ieee80211com *);
int		iwi_set_chan(struct iwi_softc *, struct ieee80211_channel *);
int		iwi_scan(struct iwi_softc *);
int		iwi_auth_and_assoc(struct iwi_softc *);
int		iwi_init(struct ifnet *);
void		iwi_stop(struct ifnet *, int);

static __inline uint8_t
MEM_READ_1(struct iwi_softc *sc, uint32_t addr)
{
	CSR_WRITE_4(sc, IWI_CSR_INDIRECT_ADDR, addr);
	return CSR_READ_1(sc, IWI_CSR_INDIRECT_DATA);
}

static __inline uint32_t
MEM_READ_4(struct iwi_softc *sc, uint32_t addr)
{
	CSR_WRITE_4(sc, IWI_CSR_INDIRECT_ADDR, addr);
	return CSR_READ_4(sc, IWI_CSR_INDIRECT_DATA);
}

#ifdef IWI_DEBUG
#define DPRINTF(x)	do { if (iwi_debug > 0) printf x; } while (0)
#define DPRINTFN(n, x)	do { if (iwi_debug >= (n)) printf x; } while (0)
int iwi_debug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n, x)
#endif

struct cfattach iwi_ca = {
	sizeof (struct iwi_softc), iwi_match, iwi_attach, NULL,
	iwi_activate
};

int
iwi_match(struct device *parent, void *match, void *aux)
{
	return pci_matchbyid((struct pci_attach_args *)aux, iwi_devices,
	    nitems(iwi_devices));
}

/* Base Address Register */
#define IWI_PCI_BAR0	0x10

void
iwi_attach(struct device *parent, struct device *self, void *aux)
{
	struct iwi_softc *sc = (struct iwi_softc *)self;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct pci_attach_args *pa = aux;
	const char *intrstr;
	bus_space_tag_t memt;
	bus_space_handle_t memh;
	pci_intr_handle_t ih;
	pcireg_t data;
	uint16_t val;
	int error, ac, i;

	sc->sc_pct = pa->pa_pc;
	sc->sc_pcitag = pa->pa_tag;

	/* clear device specific PCI configuration register 0x41 */
	data = pci_conf_read(sc->sc_pct, sc->sc_pcitag, 0x40);
	data &= ~0x0000ff00;
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0x40, data);

	/* map the register window */
	error = pci_mapreg_map(pa, IWI_PCI_BAR0, PCI_MAPREG_TYPE_MEM |
	    PCI_MAPREG_MEM_TYPE_32BIT, 0, &memt, &memh, NULL, &sc->sc_sz, 0);
	if (error != 0) {
		printf(": can't map mem space\n");
		return;
	}

	sc->sc_st = memt;
	sc->sc_sh = memh;
	sc->sc_dmat = pa->pa_dmat;

	if (pci_intr_map(pa, &ih) != 0) {
		printf(": can't map interrupt\n");
		return;
	}

	intrstr = pci_intr_string(sc->sc_pct, ih);
	sc->sc_ih = pci_intr_establish(sc->sc_pct, ih, IPL_NET, iwi_intr, sc,
	    sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": can't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s", intrstr);

	if (iwi_reset(sc) != 0) {
		printf(": could not reset adapter\n");
		return;
	}

	/*
	 * Allocate rings.
	 */
	if (iwi_alloc_cmd_ring(sc, &sc->cmdq) != 0) {
		printf(": could not allocate Cmd ring\n");
		return;
	}
	for (ac = 0; ac < EDCA_NUM_AC; ac++) {
		if (iwi_alloc_tx_ring(sc, &sc->txq[ac], ac) != 0) {
			printf(": could not allocate Tx ring %d\n", ac);
			goto fail;
		}
	}
	if (iwi_alloc_rx_ring(sc, &sc->rxq) != 0) {
		printf(": could not allocate Rx ring\n");
		goto fail;
	}

	ic->ic_phytype = IEEE80211_T_OFDM;	/* not only, but not used */
	ic->ic_opmode = IEEE80211_M_STA;	/* default to BSS mode */
	ic->ic_state = IEEE80211_S_INIT;

	/* set device capabilities */
	ic->ic_caps =
#ifndef IEEE80211_STA_ONLY
	    IEEE80211_C_IBSS |		/* IBSS mode supported */
#endif
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
	    IEEE80211_C_TXPMGT |	/* tx power management */
	    IEEE80211_C_SHPREAMBLE |	/* short preamble supported */
	    IEEE80211_C_SHSLOT |	/* short slot time supported */
	    IEEE80211_C_WEP |		/* s/w WEP */
	    IEEE80211_C_RSN |		/* WPA/RSN supported */
	    IEEE80211_C_SCANALL;	/* h/w scanning */

	/* read MAC address from EEPROM */
	val = iwi_read_prom_word(sc, IWI_EEPROM_MAC + 0);
	ic->ic_myaddr[0] = val & 0xff;
	ic->ic_myaddr[1] = val >> 8;
	val = iwi_read_prom_word(sc, IWI_EEPROM_MAC + 1);
	ic->ic_myaddr[2] = val & 0xff;
	ic->ic_myaddr[3] = val >> 8;
	val = iwi_read_prom_word(sc, IWI_EEPROM_MAC + 2);
	ic->ic_myaddr[4] = val & 0xff;
	ic->ic_myaddr[5] = val >> 8;

	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));

	if (PCI_PRODUCT(pa->pa_id) >= PCI_PRODUCT_INTEL_PRO_WL_2915ABG_1) {
		/* set supported .11a rates */
		ic->ic_sup_rates[IEEE80211_MODE_11A] =
		    ieee80211_std_rateset_11a;

		/* set supported .11a channels */
		for (i = 36; i <= 64; i += 4) {
			ic->ic_channels[i].ic_freq =
			    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
		}
		for (i = 149; i <= 165; i += 4) {
			ic->ic_channels[i].ic_freq =
			    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
		}
	}

	/* set supported .11b and .11g rates */
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ieee80211_std_rateset_11g;

	/* set supported .11b and .11g channels (1 through 14) */
	for (i = 1; i <= 14; i++) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
		ic->ic_channels[i].ic_flags =
		    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
		    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
	}

	/* IBSS channel undefined for now */
	ic->ic_ibss_chan = &ic->ic_channels[0];

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = iwi_ioctl;
	ifp->if_start = iwi_start;
	ifp->if_watchdog = iwi_watchdog;
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);

	if_attach(ifp);
	ieee80211_ifattach(ifp);
	/* override state transition machine */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = iwi_newstate;
	ic->ic_send_mgmt = iwi_send_mgmt;
	ieee80211_media_init(ifp, iwi_media_change, iwi_media_status);

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof (struct ieee80211_frame) + IEEE80211_RADIOTAP_HDRLEN);

	sc->sc_rxtap_len = sizeof sc->sc_rxtapu;
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(IWI_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof sc->sc_txtapu;
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(IWI_TX_RADIOTAP_PRESENT);
#endif

	rw_init(&sc->sc_rwlock, "iwilock");
	task_set(&sc->init_task, iwi_init_task, sc);
	return;

fail:	while (--ac >= 0)
		iwi_free_tx_ring(sc, &sc->txq[ac]);
	iwi_free_cmd_ring(sc, &sc->cmdq);
}

int
iwi_activate(struct device *self, int act)
{
	struct iwi_softc *sc = (struct iwi_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			iwi_stop(ifp, 0);
		break;
	case DVACT_WAKEUP:
		iwi_wakeup(sc);
		break;
	}

	return 0;
}

void
iwi_wakeup(struct iwi_softc *sc)
{
	pcireg_t data;

	/* clear device specific PCI configuration register 0x41 */
	data = pci_conf_read(sc->sc_pct, sc->sc_pcitag, 0x40);
	data &= ~0x0000ff00;
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0x40, data);

	iwi_init_task(sc);
}

void
iwi_init_task(void *arg1)
{
	struct iwi_softc *sc = arg1;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int s;

	rw_enter_write(&sc->sc_rwlock);
	s = splnet();

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == IFF_UP)
		iwi_init(ifp);

	splx(s);
	rw_exit_write(&sc->sc_rwlock);
}

int
iwi_alloc_cmd_ring(struct iwi_softc *sc, struct iwi_cmd_ring *ring)
{
	int nsegs, error;

	ring->queued = 0;
	ring->cur = ring->next = 0;

	error = bus_dmamap_create(sc->sc_dmat,
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_COUNT, 1,
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_COUNT, 0,
	    BUS_DMA_NOWAIT, &ring->map);
	if (error != 0) {
		printf("%s: could not create cmd ring DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat,
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_COUNT, PAGE_SIZE, 0,
	    &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error != 0) {
		printf("%s: could not allocate cmd ring DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &ring->seg, nsegs,
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_COUNT,
	    (caddr_t *)&ring->desc, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map cmd ring DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, ring->map, ring->desc,
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_COUNT, NULL,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load cmd ring DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	return 0;

fail:	iwi_free_cmd_ring(sc, ring);
	return error;
}

void
iwi_reset_cmd_ring(struct iwi_softc *sc, struct iwi_cmd_ring *ring)
{
	ring->queued = 0;
	ring->cur = ring->next = 0;
}

void
iwi_free_cmd_ring(struct iwi_softc *sc, struct iwi_cmd_ring *ring)
{
	if (ring->map != NULL) {
		if (ring->desc != NULL) {
			bus_dmamap_unload(sc->sc_dmat, ring->map);
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)ring->desc,
			    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_COUNT);
			bus_dmamem_free(sc->sc_dmat, &ring->seg, 1);
		}
		bus_dmamap_destroy(sc->sc_dmat, ring->map);
	}
}

int
iwi_alloc_tx_ring(struct iwi_softc *sc, struct iwi_tx_ring *ring, int ac)
{
	struct iwi_tx_data *data;
	int i, nsegs, error;

	ring->queued = 0;
	ring->cur = ring->next = 0;
	ring->csr_ridx = IWI_CSR_TX_RIDX(ac);
	ring->csr_widx = IWI_CSR_TX_WIDX(ac);

	error = bus_dmamap_create(sc->sc_dmat,
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_COUNT, 1,
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_COUNT, 0, BUS_DMA_NOWAIT,
	    &ring->map);
	if (error != 0) {
		printf("%s: could not create tx ring DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat,
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_COUNT, PAGE_SIZE, 0,
	    &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error != 0) {
		printf("%s: could not allocate tx ring DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &ring->seg, nsegs,
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_COUNT,
	    (caddr_t *)&ring->desc, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map tx ring DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, ring->map, ring->desc,
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_COUNT, NULL,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load tx ring DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	for (i = 0; i < IWI_TX_RING_COUNT; i++) {
		data = &ring->data[i];

		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    IWI_MAX_SCATTER, MCLBYTES, 0, BUS_DMA_NOWAIT, &data->map);
		if (error != 0) {
			printf("%s: could not create tx buf DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
	}

	return 0;

fail:	iwi_free_tx_ring(sc, ring);
	return error;
}

void
iwi_reset_tx_ring(struct iwi_softc *sc, struct iwi_tx_ring *ring)
{
	struct iwi_tx_data *data;
	int i;

	for (i = 0; i < IWI_TX_RING_COUNT; i++) {
		data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
			data->m = NULL;
		}
	}

	ring->queued = 0;
	ring->cur = ring->next = 0;
}

void
iwi_free_tx_ring(struct iwi_softc *sc, struct iwi_tx_ring *ring)
{
	struct iwi_tx_data *data;
	int i;

	if (ring->map != NULL) {
		if (ring->desc != NULL) {
			bus_dmamap_unload(sc->sc_dmat, ring->map);
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)ring->desc,
			    sizeof (struct iwi_tx_desc) * IWI_TX_RING_COUNT);
			bus_dmamem_free(sc->sc_dmat, &ring->seg, 1);
		}
		bus_dmamap_destroy(sc->sc_dmat, ring->map);
	}

	for (i = 0; i < IWI_TX_RING_COUNT; i++) {
		data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
		}
		bus_dmamap_destroy(sc->sc_dmat, data->map);
	}
}

int
iwi_alloc_rx_ring(struct iwi_softc *sc, struct iwi_rx_ring *ring)
{
	struct iwi_rx_data *data;
	int i, error;

	ring->cur = 0;

	for (i = 0; i < IWI_RX_RING_COUNT; i++) {
		data = &sc->rxq.data[i];

		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT, &data->map);
		if (error != 0) {
			printf("%s: could not create rx buf DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		MGETHDR(data->m, M_DONTWAIT, MT_DATA);
		if (data->m == NULL) {
			printf("%s: could not allocate rx mbuf\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		MCLGET(data->m, M_DONTWAIT);
		if (!(data->m->m_flags & M_EXT)) {
			m_freem(data->m);
			data->m = NULL;
			printf("%s: could not allocate rx mbuf cluster\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(data->m, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
		if (error != 0) {
			printf("%s: could not load rx buf DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		data->reg = IWI_CSR_RX_BASE + i * 4;
	}

	return 0;

fail:	iwi_free_rx_ring(sc, ring);
	return error;
}

void
iwi_reset_rx_ring(struct iwi_softc *sc, struct iwi_rx_ring *ring)
{
	ring->cur = 0;
}

void
iwi_free_rx_ring(struct iwi_softc *sc, struct iwi_rx_ring *ring)
{
	struct iwi_rx_data *data;
	int i;

	for (i = 0; i < IWI_RX_RING_COUNT; i++) {
		data = &sc->rxq.data[i];

		if (data->m != NULL) {
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
		}
		bus_dmamap_destroy(sc->sc_dmat, data->map);
	}
}

int
iwi_media_change(struct ifnet *ifp)
{
	int error;

	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return error;

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING))
		iwi_init(ifp);

	return 0;
}

void
iwi_media_status(struct ifnet *ifp, struct ifmediareq *imr)
{
	struct iwi_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t val;
	int rate;

	imr->ifm_status = IFM_AVALID;
	imr->ifm_active = IFM_IEEE80211;
	if (ic->ic_state == IEEE80211_S_RUN)
		imr->ifm_status |= IFM_ACTIVE;

	/* read current transmission rate from adapter */
	val = CSR_READ_4(sc, IWI_CSR_CURRENT_TX_RATE);
	/* convert PLCP signal to 802.11 rate */
	rate = iwi_rate(val);

	imr->ifm_active |= ieee80211_rate2media(ic, rate, ic->ic_curmode);
	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_IBSS:
		imr->ifm_active |= IFM_IEEE80211_ADHOC;
		break;
#endif
	case IEEE80211_M_MONITOR:
		imr->ifm_active |= IFM_IEEE80211_MONITOR;
		break;
	default:
		/* should not get there */
		break;
	}
}

#ifndef IEEE80211_STA_ONLY
/*
 * This is only used for IBSS mode where the firmware expect an index to an
 * internal node table instead of a destination address.
 */
int
iwi_find_txnode(struct iwi_softc *sc, const uint8_t *macaddr)
{
	struct iwi_node node;
	int i;

	for (i = 0; i < sc->nsta; i++)
		if (IEEE80211_ADDR_EQ(sc->sta[i], macaddr))
			return i;	/* already existing node */

	if (i == IWI_MAX_NODE)
		return -1;	/* no place left in neighbor table */

	/* save this new node in our softc table */
	IEEE80211_ADDR_COPY(sc->sta[i], macaddr);
	sc->nsta = i;

	/* write node information into NIC memory */
	bzero(&node, sizeof node);
	IEEE80211_ADDR_COPY(node.bssid, macaddr);

	CSR_WRITE_REGION_1(sc, IWI_CSR_NODE_BASE + i * sizeof node,
	    (uint8_t *)&node, sizeof node);

	return i;
}
#endif

int
iwi_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct iwi_softc *sc = ic->ic_softc;
	enum ieee80211_state ostate;
	uint32_t tmp;

	ostate = ic->ic_state;

	switch (nstate) {
	case IEEE80211_S_SCAN:
		iwi_scan(sc);
		break;

	case IEEE80211_S_AUTH:
		iwi_auth_and_assoc(sc);
		break;

	case IEEE80211_S_RUN:
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode == IEEE80211_M_IBSS) {
			sc->nsta = 0;	/* flush IBSS nodes */
			ieee80211_new_state(ic, IEEE80211_S_AUTH, -1);
		} else
#endif
		if (ic->ic_opmode == IEEE80211_M_MONITOR)
			iwi_set_chan(sc, ic->ic_ibss_chan);

		/* assoc led on */
		tmp = MEM_READ_4(sc, IWI_MEM_EVENT_CTL) & IWI_LED_MASK;
		MEM_WRITE_4(sc, IWI_MEM_EVENT_CTL, tmp | IWI_LED_ASSOC);
		break;

	case IEEE80211_S_INIT:
		if (ostate != IEEE80211_S_RUN)
			break;

		/* assoc led off */
		tmp = MEM_READ_4(sc, IWI_MEM_EVENT_CTL) & IWI_LED_MASK;
		MEM_WRITE_4(sc, IWI_MEM_EVENT_CTL, tmp & ~IWI_LED_ASSOC);
		break;

	case IEEE80211_S_ASSOC:
		break;
	}

	ic->ic_state = nstate;
	return 0;
}

/*
 * Read 16 bits at address 'addr' from the serial EEPROM.
 * DON'T PLAY WITH THIS CODE UNLESS YOU KNOW *EXACTLY* WHAT YOU'RE DOING!
 */
uint16_t
iwi_read_prom_word(struct iwi_softc *sc, uint8_t addr)
{
	uint32_t tmp;
	uint16_t val;
	int n;

	/* clock C once before the first command */
	IWI_EEPROM_CTL(sc, 0);
	IWI_EEPROM_CTL(sc, IWI_EEPROM_S);
	IWI_EEPROM_CTL(sc, IWI_EEPROM_S | IWI_EEPROM_C);
	IWI_EEPROM_CTL(sc, IWI_EEPROM_S);

	/* write start bit (1) */
	IWI_EEPROM_CTL(sc, IWI_EEPROM_S | IWI_EEPROM_D);
	IWI_EEPROM_CTL(sc, IWI_EEPROM_S | IWI_EEPROM_D | IWI_EEPROM_C);

	/* write READ opcode (10) */
	IWI_EEPROM_CTL(sc, IWI_EEPROM_S | IWI_EEPROM_D);
	IWI_EEPROM_CTL(sc, IWI_EEPROM_S | IWI_EEPROM_D | IWI_EEPROM_C);
	IWI_EEPROM_CTL(sc, IWI_EEPROM_S);
	IWI_EEPROM_CTL(sc, IWI_EEPROM_S | IWI_EEPROM_C);

	/* write address A7-A0 */
	for (n = 7; n >= 0; n--) {
		IWI_EEPROM_CTL(sc, IWI_EEPROM_S |
		    (((addr >> n) & 1) << IWI_EEPROM_SHIFT_D));
		IWI_EEPROM_CTL(sc, IWI_EEPROM_S |
		    (((addr >> n) & 1) << IWI_EEPROM_SHIFT_D) | IWI_EEPROM_C);
	}

	IWI_EEPROM_CTL(sc, IWI_EEPROM_S);

	/* read data Q15-Q0 */
	val = 0;
	for (n = 15; n >= 0; n--) {
		IWI_EEPROM_CTL(sc, IWI_EEPROM_S | IWI_EEPROM_C);
		IWI_EEPROM_CTL(sc, IWI_EEPROM_S);
		tmp = MEM_READ_4(sc, IWI_MEM_EEPROM_CTL);
		val |= ((tmp & IWI_EEPROM_Q) >> IWI_EEPROM_SHIFT_Q) << n;
	}

	IWI_EEPROM_CTL(sc, 0);

	/* clear Chip Select and clock C */
	IWI_EEPROM_CTL(sc, IWI_EEPROM_S);
	IWI_EEPROM_CTL(sc, 0);
	IWI_EEPROM_CTL(sc, IWI_EEPROM_C);

	return val;
}

uint8_t
iwi_rate(int plcp)
{
	switch (plcp) {
	/* CCK rates (values are device-dependent) */
	case  10:	return 2;
	case  20:	return 4;
	case  55:	return 11;
	case 110:	return 22;

	/* OFDM rates (cf IEEE Std 802.11a-1999, pp. 14 Table 80) */
	case 0xd:	return 12;
	case 0xf:	return 18;
	case 0x5:	return 24;
	case 0x7:	return 36;
	case 0x9:	return 48;
	case 0xb:	return 72;
	case 0x1:	return 96;
	case 0x3:	return 108;

	/* unknown rate: should not happen */
	default:	return 0;
	}
}

void
iwi_frame_intr(struct iwi_softc *sc, struct iwi_rx_data *data,
    struct iwi_frame *frame)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct mbuf *mnew, *m;
	struct ieee80211_frame *wh;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	int error;

	DPRINTFN(5, ("received frame len=%u chan=%u rssi=%u\n",
	    letoh16(frame->len), frame->chan, frame->rssi_dbm));

	if (letoh16(frame->len) < sizeof (struct ieee80211_frame_min) ||
	    letoh16(frame->len) > MCLBYTES) {
		DPRINTF(("%s: bad frame length\n", sc->sc_dev.dv_xname));
		ifp->if_ierrors++;
		return;
	}

	/*
	 * Try to allocate a new mbuf for this ring element and load it before
	 * processing the current mbuf.  If the ring element cannot be loaded,
	 * drop the received packet and reuse the old mbuf.  In the unlikely
	 * case that the old mbuf can't be reloaded either, explicitly panic.
	 */
	MGETHDR(mnew, M_DONTWAIT, MT_DATA);
	if (mnew == NULL) {
		ifp->if_ierrors++;
		return;
	}
	MCLGET(mnew, M_DONTWAIT);
	if (!(mnew->m_flags & M_EXT)) {
		m_freem(mnew);
		ifp->if_ierrors++;
		return;
	}

	bus_dmamap_unload(sc->sc_dmat, data->map);

	error = bus_dmamap_load(sc->sc_dmat, data->map, mtod(mnew, void *),
	    MCLBYTES, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		m_freem(mnew);

		/* try to reload the old mbuf */
		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(data->m, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
		if (error != 0) {
			/* very unlikely that it will fail... */
			panic("%s: could not load old rx mbuf",
			    sc->sc_dev.dv_xname);
		}
		CSR_WRITE_4(sc, data->reg, data->map->dm_segs[0].ds_addr);
		ifp->if_ierrors++;
		return;
	}

	m = data->m;
	data->m = mnew;
	CSR_WRITE_4(sc, data->reg, data->map->dm_segs[0].ds_addr);

	/* finalize mbuf */
	m->m_pkthdr.len = m->m_len = sizeof (struct iwi_hdr) +
	    sizeof (struct iwi_frame) + letoh16(frame->len);
	m_adj(m, sizeof (struct iwi_hdr) + sizeof (struct iwi_frame));

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct iwi_rx_radiotap_header *tap = &sc->sc_rxtap;

		tap->wr_flags = 0;
		tap->wr_rate = iwi_rate(frame->rate);
		tap->wr_chan_freq =
		    htole16(ic->ic_channels[frame->chan].ic_freq);
		tap->wr_chan_flags =
		    htole16(ic->ic_channels[frame->chan].ic_flags);
		tap->wr_antsignal = frame->signal;
		tap->wr_antenna = frame->antenna & 0x3;
		if (frame->antenna & 0x40)
			tap->wr_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_rxtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
	}
#endif

	wh = mtod(m, struct ieee80211_frame *);
	ni = ieee80211_find_rxnode(ic, wh);

	/* send the frame to the upper layer */
	rxi.rxi_flags = 0;
	rxi.rxi_rssi = frame->rssi_dbm;
	rxi.rxi_tstamp = 0;	/* unused */
	ieee80211_input(ifp, m, ni, &rxi);

	/* node is no longer needed */
	ieee80211_release_node(ic, ni);
}

void
iwi_notification_intr(struct iwi_softc *sc, struct iwi_rx_data *data,
    struct iwi_notif *notif)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni = ic->ic_bss;
	struct ifnet *ifp = &ic->ic_if;

	switch (notif->type) {
	case IWI_NOTIF_TYPE_SCAN_CHANNEL:
	{
#ifdef IWI_DEBUG
		struct iwi_notif_scan_channel *chan =
		    (struct iwi_notif_scan_channel *)(notif + 1);
#endif
		DPRINTFN(2, ("Scanning channel (%u)\n", chan->nchan));
		break;
	}
	case IWI_NOTIF_TYPE_SCAN_COMPLETE:
	{
#ifdef IWI_DEBUG
		struct iwi_notif_scan_complete *scan =
		    (struct iwi_notif_scan_complete *)(notif + 1);
#endif
		DPRINTFN(2, ("Scan completed (%u, %u)\n", scan->nchan,
		    scan->status));

		/* monitor mode uses scan to set the channel ... */
		if (ic->ic_opmode != IEEE80211_M_MONITOR)
			ieee80211_end_scan(ifp);
		else
			iwi_set_chan(sc, ic->ic_ibss_chan);
		break;
	}
	case IWI_NOTIF_TYPE_AUTHENTICATION:
	{
		struct iwi_notif_authentication *auth =
		    (struct iwi_notif_authentication *)(notif + 1);

		DPRINTFN(2, ("Authentication (%u)\n", auth->state));

		switch (auth->state) {
		case IWI_AUTHENTICATED:
			ieee80211_new_state(ic, IEEE80211_S_ASSOC, -1);
			break;

		case IWI_DEAUTHENTICATED:
			break;

		default:
			printf("%s: unknown authentication state %u\n",
			    sc->sc_dev.dv_xname, auth->state);
		}
		break;
	}
	case IWI_NOTIF_TYPE_ASSOCIATION:
	{
		struct iwi_notif_association *assoc =
		    (struct iwi_notif_association *)(notif + 1);

		DPRINTFN(2, ("Association (%u, %u)\n", assoc->state,
		    assoc->status));

		switch (assoc->state) {
		case IWI_AUTHENTICATED:
			/* re-association, do nothing */
			break;

		case IWI_ASSOCIATED:
			if (ic->ic_flags & IEEE80211_F_RSNON)
				ni->ni_rsn_supp_state = RSNA_SUPP_PTKSTART;
			ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
			break;

		case IWI_DEASSOCIATED:
			ieee80211_begin_scan(ifp);
			break;

		default:
			printf("%s: unknown association state %u\n",
			    sc->sc_dev.dv_xname, assoc->state);
		}
		break;
	}
	case IWI_NOTIF_TYPE_BEACON:	
	{
		struct iwi_notif_beacon *beacon =
		    (struct iwi_notif_beacon *)(notif + 1);

		if (letoh32(beacon->status) == IWI_BEACON_MISSED) {
			/* XXX should roam when too many beacons missed */
			DPRINTFN(2, ("%s: %u beacon(s) missed\n",
			    sc->sc_dev.dv_xname, letoh32(beacon->count)));
		}
		break;
	}
	case IWI_NOTIF_TYPE_BAD_LINK:
		DPRINTFN(2, ("link deterioration detected\n"));
		break;

	case IWI_NOTIF_TYPE_NOISE:
		DPRINTFN(5, ("Measured noise %u\n",
		    letoh32(*(uint32_t *)(notif + 1)) & 0xff));
		break;

	default:
		DPRINTFN(5, ("Notification (%u)\n", notif->type));
	}
}

void
iwi_rx_intr(struct iwi_softc *sc)
{
	struct iwi_rx_data *data;
	struct iwi_hdr *hdr;
	uint32_t hw;

	hw = CSR_READ_4(sc, IWI_CSR_RX_RIDX);

	for (; sc->rxq.cur != hw;) {
		data = &sc->rxq.data[sc->rxq.cur];

		bus_dmamap_sync(sc->sc_dmat, data->map, 0, MCLBYTES,
		    BUS_DMASYNC_POSTREAD);

		hdr = mtod(data->m, struct iwi_hdr *);

		switch (hdr->type) {
		case IWI_HDR_TYPE_FRAME:
			iwi_frame_intr(sc, data,
			    (struct iwi_frame *)(hdr + 1));
			break;

		case IWI_HDR_TYPE_NOTIF:
			iwi_notification_intr(sc, data,
			    (struct iwi_notif *)(hdr + 1));
			break;

		default:
			printf("%s: unknown hdr type %u\n",
			    sc->sc_dev.dv_xname, hdr->type);
		}

		sc->rxq.cur = (sc->rxq.cur + 1) % IWI_RX_RING_COUNT;
	}

	/* tell the firmware what we have processed */
	hw = (hw == 0) ? IWI_RX_RING_COUNT - 1 : hw - 1;
	CSR_WRITE_4(sc, IWI_CSR_RX_WIDX, hw);
}

void
iwi_tx_intr(struct iwi_softc *sc, struct iwi_tx_ring *txq)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct iwi_tx_data *data;
	uint32_t hw;

	hw = CSR_READ_4(sc, txq->csr_ridx);

	for (; txq->next != hw;) {
		data = &txq->data[txq->next];

		bus_dmamap_unload(sc->sc_dmat, data->map);
		m_freem(data->m);
		data->m = NULL;
		ieee80211_release_node(ic, data->ni);
		data->ni = NULL;

		txq->queued--;
		txq->next = (txq->next + 1) % IWI_TX_RING_COUNT;
	}

	sc->sc_tx_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);
	(*ifp->if_start)(ifp);
}

int
iwi_intr(void *arg)
{
	struct iwi_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	uint32_t r;

	if ((r = CSR_READ_4(sc, IWI_CSR_INTR)) == 0 || r == 0xffffffff)
		return 0;

	/* disable interrupts */
	CSR_WRITE_4(sc, IWI_CSR_INTR_MASK, 0);

	/* acknowledge interrupts */
	CSR_WRITE_4(sc, IWI_CSR_INTR, r);

	if (r & IWI_INTR_FATAL_ERROR) {
		printf("%s: fatal firmware error\n", sc->sc_dev.dv_xname);
		iwi_stop(ifp, 1);
		task_add(systq, &sc->init_task);
		return 1;
	}

	if (r & IWI_INTR_FW_INITED)
		wakeup(sc);

	if (r & IWI_INTR_RADIO_OFF) {
		DPRINTF(("radio transmitter off\n"));
		iwi_stop(ifp, 1);
		return 1;
	}

	if (r & IWI_INTR_CMD_DONE) {
		/* kick next pending command if any */
		sc->cmdq.next = (sc->cmdq.next + 1) % IWI_CMD_RING_COUNT;
		if (--sc->cmdq.queued > 0)
			CSR_WRITE_4(sc, IWI_CSR_CMD_WIDX, sc->cmdq.next);

		wakeup(sc);
	}

	if (r & IWI_INTR_TX1_DONE)
		iwi_tx_intr(sc, &sc->txq[0]);

	if (r & IWI_INTR_TX2_DONE)
		iwi_tx_intr(sc, &sc->txq[1]);

	if (r & IWI_INTR_TX3_DONE)
		iwi_tx_intr(sc, &sc->txq[2]);

	if (r & IWI_INTR_TX4_DONE)
		iwi_tx_intr(sc, &sc->txq[3]);

	if (r & IWI_INTR_RX_DONE)
		iwi_rx_intr(sc);

	/* re-enable interrupts */
	CSR_WRITE_4(sc, IWI_CSR_INTR_MASK, IWI_INTR_MASK);

	return 1;
}

int
iwi_cmd(struct iwi_softc *sc, uint8_t type, void *data, uint8_t len, int async)
{
	struct iwi_cmd_desc *desc;

	desc = &sc->cmdq.desc[sc->cmdq.cur];
	desc->hdr.type = IWI_HDR_TYPE_COMMAND;
	desc->hdr.flags = IWI_HDR_FLAG_IRQ;
	desc->type = type;
	desc->len = len;
	bcopy(data, desc->data, len);

	bus_dmamap_sync(sc->sc_dmat, sc->cmdq.map,
	    sc->cmdq.cur * sizeof (struct iwi_cmd_desc),
	    sizeof (struct iwi_cmd_desc), BUS_DMASYNC_PREWRITE);

	DPRINTFN(2, ("sending command idx=%u type=%u len=%u\n", sc->cmdq.cur,
	    type, len));

	sc->cmdq.cur = (sc->cmdq.cur + 1) % IWI_CMD_RING_COUNT;

	/* don't kick cmd immediately if another async command is pending */
	if (++sc->cmdq.queued == 1) {
		sc->cmdq.next = sc->cmdq.cur;
		CSR_WRITE_4(sc, IWI_CSR_CMD_WIDX, sc->cmdq.next);
	}

	return async ? 0 : tsleep(sc, PCATCH, "iwicmd", hz);
}

/* ARGSUSED */
int
iwi_send_mgmt(struct ieee80211com *ic, struct ieee80211_node *ni, int type,
    int arg1, int arg2)
{
	return EOPNOTSUPP;
}

int
iwi_tx_start(struct ifnet *ifp, struct mbuf *m0, struct ieee80211_node *ni)
{
	struct iwi_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k;
	struct iwi_tx_data *data;
	struct iwi_tx_desc *desc;
	struct iwi_tx_ring *txq = &sc->txq[0];
	int hdrlen, error, i, station = 0;

	wh = mtod(m0, struct ieee80211_frame *);

	if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
		k = ieee80211_get_txkey(ic, wh, ni);

		if ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)
			return ENOBUFS;

		/* packet header may have moved, reset our local pointer */
		wh = mtod(m0, struct ieee80211_frame *);
	}

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct iwi_tx_radiotap_header *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m0;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	data = &txq->data[txq->cur];
	desc = &txq->desc[txq->cur];

	/* copy and trim IEEE802.11 header */
	hdrlen = ieee80211_get_hdrlen(wh);
	bcopy(wh, &desc->wh, hdrlen);
	m_adj(m0, hdrlen);

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_IBSS) {
		station = iwi_find_txnode(sc, desc->wh.i_addr1);
		if (station == -1) {
			m_freem(m0);
			ieee80211_release_node(ic, ni);
			ifp->if_oerrors++;
			return 0;
		}
	}
#endif

	error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
	    BUS_DMA_NOWAIT);
	if (error != 0 && error != EFBIG) {
		printf("%s: can't map mbuf (error %d)\n",
		    sc->sc_dev.dv_xname, error);
		m_freem(m0);
		return error;
	}
	if (error != 0) {
		/* too many fragments, linearize */
		if (m_defrag(m0, M_DONTWAIT)) {
			m_freem(m0);
			return ENOBUFS;
		}
		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
		    BUS_DMA_NOWAIT);
		if (error != 0) {
			printf("%s: can't map mbuf (error %d)\n",
			    sc->sc_dev.dv_xname, error);
			m_freem(m0);
			return error;
		}
	}

	data->m = m0;
	data->ni = ni;

	desc->hdr.type = IWI_HDR_TYPE_DATA;
	desc->hdr.flags = IWI_HDR_FLAG_IRQ;
	desc->cmd = IWI_DATA_CMD_TX;
	desc->len = htole16(m0->m_pkthdr.len);
	desc->station = station;
	desc->flags = IWI_DATA_FLAG_NO_WEP;
	desc->xflags = 0;

	if (!IEEE80211_IS_MULTICAST(desc->wh.i_addr1))
		desc->flags |= IWI_DATA_FLAG_NEED_ACK;

	if (ic->ic_flags & IEEE80211_F_SHPREAMBLE)
		desc->flags |= IWI_DATA_FLAG_SHPREAMBLE;

	if ((desc->wh.i_fc[0] &
	    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_QOS)) ==
	    (IEEE80211_FC0_TYPE_DATA | IEEE80211_FC0_SUBTYPE_QOS))
		desc->xflags |= IWI_DATA_XFLAG_QOS;

	if (ic->ic_curmode == IEEE80211_MODE_11B)
		desc->xflags |= IWI_DATA_XFLAG_CCK;

	desc->nseg = htole32(data->map->dm_nsegs);
	for (i = 0; i < data->map->dm_nsegs; i++) {
		desc->seg_addr[i] = htole32(data->map->dm_segs[i].ds_addr);
		desc->seg_len[i]  = htole16(data->map->dm_segs[i].ds_len);
	}

	bus_dmamap_sync(sc->sc_dmat, data->map, 0, data->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, txq->map,
	    txq->cur * sizeof (struct iwi_tx_desc),
	    sizeof (struct iwi_tx_desc), BUS_DMASYNC_PREWRITE);

	DPRINTFN(5, ("sending data frame idx=%u len=%u nseg=%u\n", txq->cur,
	    letoh16(desc->len), data->map->dm_nsegs));

	txq->queued++;
	txq->cur = (txq->cur + 1) % IWI_TX_RING_COUNT;
	CSR_WRITE_4(sc, txq->csr_widx, txq->cur);

	return 0;
}

void
iwi_start(struct ifnet *ifp)
{
	struct iwi_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct mbuf *m0;
	struct ieee80211_node *ni;

	if (ic->ic_state != IEEE80211_S_RUN)
		return;

	for (;;) {
		if (sc->txq[0].queued + IWI_MAX_NSEG + 2 >= IWI_TX_RING_COUNT) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		IFQ_DEQUEUE(&ifp->if_snd, m0);
		if (m0 == NULL)
			break;

#if NBPFILTER > 0
		if (ifp->if_bpf != NULL)
			bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif

		m0 = ieee80211_encap(ifp, m0, &ni);
		if (m0 == NULL)
			continue;

#if NBPFILTER > 0
		if (ic->ic_rawbpf != NULL)
			bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
#endif

		if (iwi_tx_start(ifp, m0, ni) != 0) {
			if (ni != NULL)
				ieee80211_release_node(ic, ni);
			ifp->if_oerrors++;
			break;
		}

		/* start watchdog timer */
		sc->sc_tx_timer = 5;
		ifp->if_timer = 1;
	}
}

void
iwi_watchdog(struct ifnet *ifp)
{
	struct iwi_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;

	if (sc->sc_tx_timer > 0) {
		if (--sc->sc_tx_timer == 0) {
			printf("%s: device timeout\n", sc->sc_dev.dv_xname);
			iwi_stop(ifp, 1);
			ifp->if_oerrors++;
			return;
		}
		ifp->if_timer = 1;
	}

	ieee80211_watchdog(ifp);
}

int
iwi_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct iwi_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;

	error = rw_enter(&sc->sc_rwlock, RW_WRITE | RW_INTR);
	if (error)
		return error;
	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (!(ifp->if_flags & IFF_RUNNING))
				iwi_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				iwi_stop(ifp, 1);
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);

		if (error == ENETRESET)
			error = 0;
		break;

	case SIOCG80211TXPOWER:
		/*
		 * If the hardware radio transmitter switch is off, report a
		 * tx power of IEEE80211_TXPOWER_MIN to indicate that radio
		 * transmitter is killed.
		 */
		((struct ieee80211_txpower *)data)->i_val =
		    (CSR_READ_4(sc, IWI_CSR_IO) & IWI_IO_RADIO_ENABLED) ?
		    sc->sc_ic.ic_txpower : IEEE80211_TXPOWER_MIN;
		break;

	default:
		error = ieee80211_ioctl(ifp, cmd, data);
	}

	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
		    (IFF_UP | IFF_RUNNING))
			iwi_init(ifp);
		error = 0;
	}

	splx(s);
	rw_exit_write(&sc->sc_rwlock);
	return error;
}

void
iwi_stop_master(struct iwi_softc *sc)
{
	uint32_t tmp;
	int ntries;

	/* disable interrupts */
	CSR_WRITE_4(sc, IWI_CSR_INTR_MASK, 0);

	CSR_WRITE_4(sc, IWI_CSR_RST, IWI_RST_STOP_MASTER);
	for (ntries = 0; ntries < 5; ntries++) {
		if (CSR_READ_4(sc, IWI_CSR_RST) & IWI_RST_MASTER_DISABLED)
			break;
		DELAY(10);
	}
	if (ntries == 5) {
		printf("%s: timeout waiting for master\n",
		    sc->sc_dev.dv_xname);
	}

	tmp = CSR_READ_4(sc, IWI_CSR_RST);
	CSR_WRITE_4(sc, IWI_CSR_RST, tmp | IWI_RST_PRINCETON_RESET);
}

int
iwi_reset(struct iwi_softc *sc)
{
	uint32_t tmp;
	int i, ntries;

	iwi_stop_master(sc);

	/* move adapter to D0 state */
	tmp = CSR_READ_4(sc, IWI_CSR_CTL);
	CSR_WRITE_4(sc, IWI_CSR_CTL, tmp | IWI_CTL_INIT);

	CSR_WRITE_4(sc, IWI_CSR_READ_INT, IWI_READ_INT_INIT_HOST);

	/* wait for clock stabilization */
	for (ntries = 0; ntries < 1000; ntries++) {
		if (CSR_READ_4(sc, IWI_CSR_CTL) & IWI_CTL_CLOCK_READY)
			break;
		DELAY(200);
	}
	if (ntries == 1000) {
		printf("%s: timeout waiting for clock stabilization\n",
		    sc->sc_dev.dv_xname);
		return ETIMEDOUT;
	}

	tmp = CSR_READ_4(sc, IWI_CSR_RST);
	CSR_WRITE_4(sc, IWI_CSR_RST, tmp | IWI_RST_SW_RESET);

	DELAY(10);

	tmp = CSR_READ_4(sc, IWI_CSR_CTL);
	CSR_WRITE_4(sc, IWI_CSR_CTL, tmp | IWI_CTL_INIT);

	/* clear NIC memory */
	CSR_WRITE_4(sc, IWI_CSR_AUTOINC_ADDR, 0);
	for (i = 0; i < 0xc000; i++)
		CSR_WRITE_4(sc, IWI_CSR_AUTOINC_DATA, 0);

	return 0;
}

int
iwi_load_ucode(struct iwi_softc *sc, const char *data, int size)
{
	const uint16_t *w;
	uint32_t tmp;
	int ntries, i;

	tmp = CSR_READ_4(sc, IWI_CSR_RST);
	CSR_WRITE_4(sc, IWI_CSR_RST, tmp | IWI_RST_STOP_MASTER);
	for (ntries = 0; ntries < 5; ntries++) {
		if (CSR_READ_4(sc, IWI_CSR_RST) & IWI_RST_MASTER_DISABLED)
			break;
		DELAY(10);
	}
	if (ntries == 5) {
		printf("%s: timeout waiting for master\n",
		    sc->sc_dev.dv_xname);
		return ETIMEDOUT;
	}

	MEM_WRITE_4(sc, 0x3000e0, 0x80000000);
	DELAY(5000);

	tmp = CSR_READ_4(sc, IWI_CSR_RST);
	CSR_WRITE_4(sc, IWI_CSR_RST, tmp & ~IWI_RST_PRINCETON_RESET);

	DELAY(5000);
	MEM_WRITE_4(sc, 0x3000e0, 0);
	DELAY(1000);
	MEM_WRITE_4(sc, IWI_MEM_EVENT_CTL, 1);
	DELAY(1000);
	MEM_WRITE_4(sc, IWI_MEM_EVENT_CTL, 0);
	DELAY(1000);
	MEM_WRITE_1(sc, 0x200000, 0x00);
	MEM_WRITE_1(sc, 0x200000, 0x40);
	DELAY(1000);

	/* adapter is buggy, we must set the address for each word */
	for (w = (const uint16_t *)data; size > 0; w++, size -= 2)
		MEM_WRITE_2(sc, 0x200010, htole16(*w));

	MEM_WRITE_1(sc, 0x200000, 0x00);
	MEM_WRITE_1(sc, 0x200000, 0x80);

	/* wait until we get an answer */
	for (ntries = 0; ntries < 100; ntries++) {
		if (MEM_READ_1(sc, 0x200000) & 1)
			break;
		DELAY(100);
	}
	if (ntries == 100) {
		printf("%s: timeout waiting for ucode to initialize\n",
		    sc->sc_dev.dv_xname);
		return ETIMEDOUT;
	}

	/* read the answer or the firmware will not initialize properly */
	for (i = 0; i < 7; i++)
		MEM_READ_4(sc, 0x200004);

	MEM_WRITE_1(sc, 0x200000, 0x00);

	return 0;
}

/* macro to handle unaligned little endian data in firmware image */
#define GETLE32(p) ((p)[0] | (p)[1] << 8 | (p)[2] << 16 | (p)[3] << 24)

int
iwi_load_firmware(struct iwi_softc *sc, const char *data, int size)
{
	bus_dmamap_t map;
	bus_dma_segment_t seg;
	caddr_t virtaddr;
	u_char *p, *end;
	uint32_t sentinel, tmp, ctl, src, dst, sum, len, mlen;
	int ntries, nsegs, error;

	/* allocate DMA memory to store firmware image */
	error = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT, &map);
	if (error != 0) {
		printf("%s: could not create firmware DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail1;
	}

	error = bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE, 0, &seg, 1,
	    &nsegs, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not allocate firmware DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail2;
	}

	error = bus_dmamem_map(sc->sc_dmat, &seg, nsegs, size, &virtaddr,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map firmware DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail3;
	}

	error = bus_dmamap_load(sc->sc_dmat, map, virtaddr, size, NULL,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load firmware DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail4;
	}

	/* copy firmware image to DMA memory */
	bcopy(data, virtaddr, size);

	/* make sure the adapter will get up-to-date values */
	bus_dmamap_sync(sc->sc_dmat, map, 0, size, BUS_DMASYNC_PREWRITE);

	/* tell the adapter where the command blocks are stored */
	MEM_WRITE_4(sc, 0x3000a0, 0x27000);

	/*
	 * Store command blocks into adapter's internal memory using register
	 * indirections. The adapter will read the firmware image through DMA
	 * using information stored in command blocks.
	 */
	src = map->dm_segs[0].ds_addr;
	p = virtaddr;
	end = p + size;
	CSR_WRITE_4(sc, IWI_CSR_AUTOINC_ADDR, 0x27000);

	while (p < end) {
		dst = GETLE32(p); p += 4; src += 4;
		len = GETLE32(p); p += 4; src += 4;
		p += len;

		while (len > 0) {
			mlen = min(len, IWI_CB_MAXDATALEN);

			ctl = IWI_CB_DEFAULT_CTL | mlen;
			sum = ctl ^ src ^ dst;

			/* write a command block */
			CSR_WRITE_4(sc, IWI_CSR_AUTOINC_DATA, ctl);
			CSR_WRITE_4(sc, IWI_CSR_AUTOINC_DATA, src);
			CSR_WRITE_4(sc, IWI_CSR_AUTOINC_DATA, dst);
			CSR_WRITE_4(sc, IWI_CSR_AUTOINC_DATA, sum);

			src += mlen;
			dst += mlen;
			len -= mlen;
		}
	}

	/* write a fictive final command block (sentinel) */
	sentinel = CSR_READ_4(sc, IWI_CSR_AUTOINC_ADDR);
	CSR_WRITE_4(sc, IWI_CSR_AUTOINC_DATA, 0);

	tmp = CSR_READ_4(sc, IWI_CSR_RST);
	tmp &= ~(IWI_RST_MASTER_DISABLED | IWI_RST_STOP_MASTER);
	CSR_WRITE_4(sc, IWI_CSR_RST, tmp);

	/* tell the adapter to start processing command blocks */
	MEM_WRITE_4(sc, 0x3000a4, 0x540100);

	/* wait until the adapter has processed all command blocks */
	for (ntries = 0; ntries < 400; ntries++) {
		if (MEM_READ_4(sc, 0x3000d0) >= sentinel)
			break;
		DELAY(100);
	}
	if (ntries == 400) {
		printf("%s: timeout processing cb\n", sc->sc_dev.dv_xname);
		error = ETIMEDOUT;
		goto fail5;
	}

	/* we're done with command blocks processing */
	MEM_WRITE_4(sc, 0x3000a4, 0x540c00);

	/* allow interrupts so we know when the firmware is inited */
	CSR_WRITE_4(sc, IWI_CSR_INTR_MASK, IWI_INTR_MASK);

	/* tell the adapter to initialize the firmware */
	CSR_WRITE_4(sc, IWI_CSR_RST, 0);

	tmp = CSR_READ_4(sc, IWI_CSR_CTL);
	CSR_WRITE_4(sc, IWI_CSR_CTL, tmp | IWI_CTL_ALLOW_STANDBY);

	/* wait at most one second for firmware initialization to complete */
	if ((error = tsleep(sc, PCATCH, "iwiinit", hz)) != 0) {
		printf("%s: timeout waiting for firmware initialization to "
		    "complete\n", sc->sc_dev.dv_xname);
		goto fail5;
	}

fail5:	bus_dmamap_sync(sc->sc_dmat, map, 0, size, BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(sc->sc_dmat, map);
fail4:	bus_dmamem_unmap(sc->sc_dmat, virtaddr, size);
fail3:	bus_dmamem_free(sc->sc_dmat, &seg, 1);
fail2:	bus_dmamap_destroy(sc->sc_dmat, map);
fail1:	return error;
}

int
iwi_config(struct iwi_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct iwi_configuration config;
	struct iwi_rateset rs;
	struct iwi_txpower power;
	uint32_t data;
	int error, nchan, i;

	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	DPRINTF(("Setting MAC address to %s\n", ether_sprintf(ic->ic_myaddr)));
	error = iwi_cmd(sc, IWI_CMD_SET_MAC_ADDRESS, ic->ic_myaddr,
	    IEEE80211_ADDR_LEN, 0);
	if (error != 0)
		return error;

	bzero(&config, sizeof config);
	config.multicast_enabled = 1;
	config.silence_threshold = 30;
	config.report_noise = 1;
	config.answer_pbreq =
#ifndef IEEE80211_STA_ONLY
	    (ic->ic_opmode == IEEE80211_M_IBSS) ? 1 :
#endif
	    0;
	DPRINTF(("Configuring adapter\n"));
	error = iwi_cmd(sc, IWI_CMD_SET_CONFIG, &config, sizeof config, 0);
	if (error != 0)
		return error;

	data = htole32(IWI_POWER_MODE_CAM);
	DPRINTF(("Setting power mode to %u\n", letoh32(data)));
	error = iwi_cmd(sc, IWI_CMD_SET_POWER_MODE, &data, sizeof data, 0);
	if (error != 0)
		return error;

	data = htole32(ic->ic_rtsthreshold);
	DPRINTF(("Setting RTS threshold to %u\n", letoh32(data)));
	error = iwi_cmd(sc, IWI_CMD_SET_RTS_THRESHOLD, &data, sizeof data, 0);
	if (error != 0)
		return error;

	data = htole32(ic->ic_fragthreshold);
	DPRINTF(("Setting fragmentation threshold to %u\n", letoh32(data)));
	error = iwi_cmd(sc, IWI_CMD_SET_FRAG_THRESHOLD, &data, sizeof data, 0);
	if (error != 0)
		return error;

	/*
	 * Set default Tx power for 802.11b/g and 802.11a channels.
	 */
	nchan = 0;
	for (i = 0; i <= IEEE80211_CHAN_MAX; i++) {
		if (!IEEE80211_IS_CHAN_2GHZ(&ic->ic_channels[i]))
			continue;
		power.chan[nchan].chan = i;
		power.chan[nchan].power = IWI_TXPOWER_MAX;
		nchan++;
	}
	power.nchan = nchan;

	power.mode = IWI_MODE_11G;
	DPRINTF(("Setting .11g channels tx power\n"));
	error = iwi_cmd(sc, IWI_CMD_SET_TX_POWER, &power, sizeof power, 0);
	if (error != 0)
		return error;

	power.mode = IWI_MODE_11B;
	DPRINTF(("Setting .11b channels tx power\n"));
	error = iwi_cmd(sc, IWI_CMD_SET_TX_POWER, &power, sizeof power, 0);
	if (error != 0)
		return error;

	nchan = 0;
	for (i = 0; i <= IEEE80211_CHAN_MAX; i++) {
		if (!IEEE80211_IS_CHAN_5GHZ(&ic->ic_channels[i]))
			continue;
		power.chan[nchan].chan = i;
		power.chan[nchan].power = IWI_TXPOWER_MAX;
		nchan++;
	}
	power.nchan = nchan;

	if (nchan > 0) {	/* 2915ABG only */
		power.mode = IWI_MODE_11A;
		DPRINTF(("Setting .11a channels tx power\n"));
		error = iwi_cmd(sc, IWI_CMD_SET_TX_POWER, &power, sizeof power,
		    0);
		if (error != 0)
			return error;
	}

	rs.mode = IWI_MODE_11G;
	rs.type = IWI_RATESET_TYPE_SUPPORTED;
	rs.nrates = ic->ic_sup_rates[IEEE80211_MODE_11G].rs_nrates;
	bcopy(ic->ic_sup_rates[IEEE80211_MODE_11G].rs_rates, rs.rates,
	    rs.nrates);
	DPRINTF(("Setting .11bg supported rates (%u)\n", rs.nrates));
	error = iwi_cmd(sc, IWI_CMD_SET_RATES, &rs, sizeof rs, 0);
	if (error != 0)
		return error;

	rs.mode = IWI_MODE_11A;
	rs.type = IWI_RATESET_TYPE_SUPPORTED;
	rs.nrates = ic->ic_sup_rates[IEEE80211_MODE_11A].rs_nrates;
	bcopy(ic->ic_sup_rates[IEEE80211_MODE_11A].rs_rates, rs.rates,
	    rs.nrates);
	DPRINTF(("Setting .11a supported rates (%u)\n", rs.nrates));
	error = iwi_cmd(sc, IWI_CMD_SET_RATES, &rs, sizeof rs, 0);
	if (error != 0)
		return error;

	/* if we have a desired ESSID, set it now */
	if (ic->ic_des_esslen != 0) {
#ifdef IWI_DEBUG
		if (iwi_debug > 0) {
			printf("Setting desired ESSID to ");
			ieee80211_print_essid(ic->ic_des_essid,
			    ic->ic_des_esslen);
			printf("\n");
		}
#endif
		error = iwi_cmd(sc, IWI_CMD_SET_ESSID, ic->ic_des_essid,
		    ic->ic_des_esslen, 0);
		if (error != 0)
			return error;
	}

	arc4random_buf(&data, sizeof data);
	DPRINTF(("Setting random seed to %u\n", data));
	error = iwi_cmd(sc, IWI_CMD_SET_RANDOM_SEED, &data, sizeof data, 0);
	if (error != 0)
		return error;

	/* enable adapter */
	DPRINTF(("Enabling adapter\n"));
	return iwi_cmd(sc, IWI_CMD_ENABLE, NULL, 0, 0);
}

void
iwi_update_edca(struct ieee80211com *ic)
{
#define IWI_EXP2(v)	htole16((1 << (v)) - 1)
#define IWI_TXOP(v)	IEEE80211_TXOP_TO_US(v)
	struct iwi_softc *sc = ic->ic_softc;
	struct iwi_qos_cmd cmd;
	struct iwi_qos_params *qos;
	struct ieee80211_edca_ac_params *edca = ic->ic_edca_ac;
	int aci;

	/* set default QoS parameters for CCK */
	qos = &cmd.cck;
	for (aci = 0; aci < EDCA_NUM_AC; aci++) {
		qos->cwmin[aci] = IWI_EXP2(iwi_cck[aci].ac_ecwmin);
		qos->cwmax[aci] = IWI_EXP2(iwi_cck[aci].ac_ecwmax);
		qos->txop [aci] = IWI_TXOP(iwi_cck[aci].ac_txoplimit);
		qos->aifsn[aci] = iwi_cck[aci].ac_aifsn;
		qos->acm  [aci] = 0;
	}
	/* set default QoS parameters for OFDM */
	qos = &cmd.ofdm;
	for (aci = 0; aci < EDCA_NUM_AC; aci++) {
		qos->cwmin[aci] = IWI_EXP2(iwi_ofdm[aci].ac_ecwmin);
		qos->cwmax[aci] = IWI_EXP2(iwi_ofdm[aci].ac_ecwmax);
		qos->txop [aci] = IWI_TXOP(iwi_ofdm[aci].ac_txoplimit);
		qos->aifsn[aci] = iwi_ofdm[aci].ac_aifsn;
		qos->acm  [aci] = 0;
	}
	/* set current QoS parameters */
	qos = &cmd.current;
	for (aci = 0; aci < EDCA_NUM_AC; aci++) {
		qos->cwmin[aci] = IWI_EXP2(edca[aci].ac_ecwmin);
		qos->cwmax[aci] = IWI_EXP2(edca[aci].ac_ecwmax);
		qos->txop [aci] = IWI_TXOP(edca[aci].ac_txoplimit);
		qos->aifsn[aci] = edca[aci].ac_aifsn;
		qos->acm  [aci] = 0;
	}

	DPRINTF(("Setting QoS parameters\n"));
	(void)iwi_cmd(sc, IWI_CMD_SET_QOS_PARAMS, &cmd, sizeof cmd, 1);
#undef IWI_EXP2
#undef IWI_TXOP
}

int
iwi_set_chan(struct iwi_softc *sc, struct ieee80211_channel *chan)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwi_scan scan;

	bzero(&scan, sizeof scan);
	memset(scan.type, IWI_SCAN_TYPE_PASSIVE, sizeof scan.type);
	scan.passive = htole16(2000);
	scan.channels[0] = 1 |
	    (IEEE80211_IS_CHAN_5GHZ(chan) ? IWI_CHAN_5GHZ : IWI_CHAN_2GHZ);
	scan.channels[1] = ieee80211_chan2ieee(ic, chan);

	DPRINTF(("Setting channel to %u\n", ieee80211_chan2ieee(ic, chan)));
	return iwi_cmd(sc, IWI_CMD_SCAN, &scan, sizeof scan, 1);
}

int
iwi_scan(struct iwi_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwi_scan scan;
	uint8_t *p;
	int i, count;

	bzero(&scan, sizeof scan);

	if (ic->ic_des_esslen != 0) {
		scan.bdirected = htole16(40);
		memset(scan.type, IWI_SCAN_TYPE_BDIRECTED, sizeof scan.type);
	} else {
		scan.broadcast = htole16(40);
		memset(scan.type, IWI_SCAN_TYPE_BROADCAST, sizeof scan.type);
	}

	p = scan.channels;
	count = 0;
	for (i = 0; i <= IEEE80211_CHAN_MAX; i++) {
		if (IEEE80211_IS_CHAN_5GHZ(&ic->ic_channels[i])) {
			*++p = i;
			count++;
		}
	}
	*(p - count) = IWI_CHAN_5GHZ | count;

	p = (count > 0) ? p + 1 : scan.channels;
	count = 0;
	for (i = 0; i <= IEEE80211_CHAN_MAX; i++) {
		if (IEEE80211_IS_CHAN_2GHZ(&ic->ic_channels[i])) {
			*++p = i;
			count++;
		}
	}
	*(p - count) = IWI_CHAN_2GHZ | count;

	DPRINTF(("Start scanning\n"));
	return iwi_cmd(sc, IWI_CMD_SCAN, &scan, sizeof scan, 1);
}

int
iwi_auth_and_assoc(struct iwi_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni = ic->ic_bss;
	struct iwi_configuration config;
	struct iwi_associate assoc;
	struct iwi_rateset rs;
	uint8_t *frm;
	uint32_t data;
	uint16_t capinfo;
	uint8_t buf[64];	/* XXX max WPA/RSN/WMM IE length */
	int error;

	/* update adapter configuration */
	bzero(&config, sizeof config);
	config.multicast_enabled = 1;
	config.disable_unicast_decryption = 1;
	config.disable_multicast_decryption = 1;
	config.silence_threshold = 30;
	config.report_noise = 1;
	config.allow_mgt = 1;
	config.answer_pbreq =
#ifndef IEEE80211_STA_ONLY
	    (ic->ic_opmode == IEEE80211_M_IBSS) ? 1 :
#endif
	    0;
	if (ic->ic_curmode == IEEE80211_MODE_11G)
		config.bg_autodetection = 1;
	DPRINTF(("Configuring adapter\n"));
	error = iwi_cmd(sc, IWI_CMD_SET_CONFIG, &config, sizeof config, 1);
	if (error != 0)
		return error;

#ifdef IWI_DEBUG
	if (iwi_debug > 0) {
		printf("Setting ESSID to ");
		ieee80211_print_essid(ni->ni_essid, ni->ni_esslen);
		printf("\n");
	}
#endif
	error = iwi_cmd(sc, IWI_CMD_SET_ESSID, ni->ni_essid, ni->ni_esslen, 1);
	if (error != 0)
		return error;

	/* the rate set has already been "negotiated" */
	rs.mode = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? IWI_MODE_11A :
	    IWI_MODE_11G;
	rs.type = IWI_RATESET_TYPE_NEGOTIATED;
	rs.nrates = ni->ni_rates.rs_nrates;
	if (rs.nrates > sizeof rs.rates) {
#ifdef DIAGNOSTIC
		/* should not happen since the rates are negotiated */
		printf("%s: XXX too many rates (count=%d, last=%d)\n",
		    sc->sc_dev.dv_xname, ni->ni_rates.rs_nrates,
		    ni->ni_rates.rs_rates[ni->ni_rates.rs_nrates - 1] &
		    IEEE80211_RATE_VAL);
#endif
		rs.nrates = sizeof rs.rates;
	}
	bcopy(ni->ni_rates.rs_rates, rs.rates, rs.nrates);
	DPRINTF(("Setting negotiated rates (%u)\n", rs.nrates));
	error = iwi_cmd(sc, IWI_CMD_SET_RATES, &rs, sizeof rs, 1);
	if (error != 0)
		return error;

	data = htole32(ni->ni_rssi);
	DPRINTF(("Setting sensitivity to %d\n", (int8_t)ni->ni_rssi));
	error = iwi_cmd(sc, IWI_CMD_SET_SENSITIVITY, &data, sizeof data, 1);
	if (error != 0)
		return error;

	if (ic->ic_flags & IEEE80211_F_QOS) {
		iwi_update_edca(ic);

		frm = ieee80211_add_qos_capability(buf, ic);
		DPRINTF(("Setting QoS Capability IE length %d\n", frm - buf));
		error = iwi_cmd(sc, IWI_CMD_SET_QOS_CAP, buf, frm - buf, 1);
		if (error != 0)
			return error;
	}
	if (ic->ic_flags & IEEE80211_F_RSNON) {
		/* tell firmware to add WPA/RSN IE to (re)assoc request */
		if (ni->ni_rsnprotos == IEEE80211_PROTO_RSN)
			frm = ieee80211_add_rsn(buf, ic, ni);
		else
			frm = ieee80211_add_wpa(buf, ic, ni);
		DPRINTF(("Setting RSN IE length %d\n", frm - buf));
		error = iwi_cmd(sc, IWI_CMD_SET_OPTIE, buf, frm - buf, 1);
		if (error != 0)
			return error;
	}

	bzero(&assoc, sizeof assoc);
#ifndef IEEE80211_STA_ONLY
	if (ic->ic_flags & IEEE80211_F_SIBSS)
		assoc.type = IWI_ASSOC_SIBSS;
	else
#endif
		assoc.type = IWI_ASSOC_ASSOCIATE;
	assoc.policy = 0;
	if (ic->ic_flags & IEEE80211_F_RSNON)
		assoc.policy |= htole16(IWI_ASSOC_POLICY_RSN);
	if (ic->ic_flags & IEEE80211_F_QOS)
		assoc.policy |= htole16(IWI_ASSOC_POLICY_QOS);
	if (ic->ic_curmode == IEEE80211_MODE_11A)
		assoc.mode = IWI_MODE_11A;
	else if (ic->ic_curmode == IEEE80211_MODE_11B)
		assoc.mode = IWI_MODE_11B;
	else	/* assume 802.11b/g */
		assoc.mode = IWI_MODE_11G;
	assoc.chan = ieee80211_chan2ieee(ic, ni->ni_chan);
	if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) &&
	    IEEE80211_IS_CHAN_2GHZ(ni->ni_chan))
		assoc.plen = IWI_ASSOC_SHPREAMBLE;
	bcopy(ni->ni_tstamp, assoc.tstamp, 8);
	capinfo = IEEE80211_CAPINFO_ESS;
	if (ic->ic_flags & IEEE80211_F_WEPON)
		capinfo |= IEEE80211_CAPINFO_PRIVACY;
	if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) &&
	    IEEE80211_IS_CHAN_2GHZ(ni->ni_chan))
		capinfo |= IEEE80211_CAPINFO_SHORT_PREAMBLE;
	if (ic->ic_caps & IEEE80211_C_SHSLOT)
		capinfo |= IEEE80211_CAPINFO_SHORT_SLOTTIME;
	assoc.capinfo = htole16(capinfo);

	assoc.lintval = htole16(ic->ic_lintval);
	assoc.intval = htole16(ni->ni_intval);
	IEEE80211_ADDR_COPY(assoc.bssid, ni->ni_bssid);
#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_IBSS)
		IEEE80211_ADDR_COPY(assoc.dst, etherbroadcastaddr);
	else
#endif
		IEEE80211_ADDR_COPY(assoc.dst, ni->ni_bssid);

	DPRINTF(("Trying to associate to %s channel %u auth %u\n",
	    ether_sprintf(assoc.bssid), assoc.chan, assoc.auth));
	return iwi_cmd(sc, IWI_CMD_ASSOCIATE, &assoc, sizeof assoc, 1);
}

int
iwi_init(struct ifnet *ifp)
{
	struct iwi_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct iwi_firmware_hdr *hdr;
	const char *name, *fw;
	u_char *data;
	size_t size;
	int i, ac, error;

	iwi_stop(ifp, 0);

	if ((error = iwi_reset(sc)) != 0) {
		printf("%s: could not reset adapter\n", sc->sc_dev.dv_xname);
		goto fail1;
	}

	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		name = "iwi-bss";
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_IBSS:
	case IEEE80211_M_AHDEMO:
		name = "iwi-ibss";
		break;
#endif
	case IEEE80211_M_MONITOR:
		name = "iwi-monitor";
		break;
	default:
		/* should not get there */
		error = EINVAL;
		goto fail1;
	}

	if ((error = loadfirmware(name, &data, &size)) != 0) {
		printf("%s: error %d, could not read firmware %s\n",
		    sc->sc_dev.dv_xname, error, name);
		goto fail1;
	}
	if (size < sizeof (struct iwi_firmware_hdr)) {
		printf("%s: firmware image too short: %zu bytes\n",
		    sc->sc_dev.dv_xname, size);
		error = EINVAL;
		goto fail2;
	}
	hdr = (struct iwi_firmware_hdr *)data;

	if (hdr->vermaj < 3 || hdr->bootsz == 0 || hdr->ucodesz == 0 ||
	    hdr->mainsz == 0) {
		printf("%s: firmware image too old (need at least 3.0)\n",
		    sc->sc_dev.dv_xname);
		error = EINVAL;
		goto fail2;
	}

	if (size < sizeof (struct iwi_firmware_hdr) + letoh32(hdr->bootsz) +
	    letoh32(hdr->ucodesz) + letoh32(hdr->mainsz)) {
		printf("%s: firmware image too short: %zu bytes\n",
		    sc->sc_dev.dv_xname, size);
		error = EINVAL;
		goto fail2;
	}

	fw = (const char *)data + sizeof (struct iwi_firmware_hdr);
	if ((error = iwi_load_firmware(sc, fw, letoh32(hdr->bootsz))) != 0) {
		printf("%s: could not load boot firmware\n",
		    sc->sc_dev.dv_xname);
		goto fail2;
	}

	fw = (const char *)data + sizeof (struct iwi_firmware_hdr) +
	    letoh32(hdr->bootsz);
	if ((error = iwi_load_ucode(sc, fw, letoh32(hdr->ucodesz))) != 0) {
		printf("%s: could not load microcode\n", sc->sc_dev.dv_xname);
		goto fail2;
	}

	iwi_stop_master(sc);

	CSR_WRITE_4(sc, IWI_CSR_CMD_BASE, sc->cmdq.map->dm_segs[0].ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_CMD_SIZE, IWI_CMD_RING_COUNT);
	CSR_WRITE_4(sc, IWI_CSR_CMD_WIDX, sc->cmdq.cur);

	for (ac = 0; ac < EDCA_NUM_AC; ac++) {
		CSR_WRITE_4(sc, IWI_CSR_TX_BASE(ac),
		    sc->txq[ac].map->dm_segs[0].ds_addr);
		CSR_WRITE_4(sc, IWI_CSR_TX_SIZE(ac), IWI_TX_RING_COUNT);
		CSR_WRITE_4(sc, IWI_CSR_TX_WIDX(ac), sc->txq[ac].cur);
	}

	for (i = 0; i < IWI_RX_RING_COUNT; i++) {
		struct iwi_rx_data *data = &sc->rxq.data[i];
		CSR_WRITE_4(sc, data->reg, data->map->dm_segs[0].ds_addr);
	}

	CSR_WRITE_4(sc, IWI_CSR_RX_WIDX, IWI_RX_RING_COUNT - 1);

	fw = (const char *)data + sizeof (struct iwi_firmware_hdr) +
	    letoh32(hdr->bootsz) + letoh32(hdr->ucodesz);
	if ((error = iwi_load_firmware(sc, fw, letoh32(hdr->mainsz))) != 0) {
		printf("%s: could not load main firmware\n",
		    sc->sc_dev.dv_xname);
		goto fail2;
	}

	free(data, M_DEVBUF, size);

	if ((error = iwi_config(sc)) != 0) {
		printf("%s: device configuration failed\n",
		    sc->sc_dev.dv_xname);
		goto fail1;
	}

	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_flags |= IFF_RUNNING;

	if (ic->ic_opmode != IEEE80211_M_MONITOR)
		ieee80211_begin_scan(ifp);
	else
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);

	return 0;

fail2:	free(data, M_DEVBUF, size);
fail1:	iwi_stop(ifp, 0);
	return error;
}

void
iwi_stop(struct ifnet *ifp, int disable)
{
	struct iwi_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	int ac;

	sc->sc_tx_timer = 0;
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/* in case we were scanning, release the scan "lock" */
	ic->ic_scan_lock = IEEE80211_SCAN_UNLOCKED;

	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);

	iwi_stop_master(sc);

	CSR_WRITE_4(sc, IWI_CSR_RST, IWI_RST_SW_RESET);

	/* reset rings */
	iwi_reset_cmd_ring(sc, &sc->cmdq);
	for (ac = 0; ac < EDCA_NUM_AC; ac++)
		iwi_reset_tx_ring(sc, &sc->txq[ac]);
	iwi_reset_rx_ring(sc, &sc->rxq);
}

struct cfdriver iwi_cd = {
	NULL, "iwi", DV_IFNET
};
@


1.135
log
@Do not clear IFF_UP, even in the error path, clearing IFF_RUNNING
is enough.

This flag should only be set by the stack, drivers shouldn't mess
with it.

Discussed with dlg@@ and mikeb@@, ok mikeb@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.134 2017/01/22 10:17:38 dlg Exp $	*/
d968 1
d1032 2
d2044 1
@


1.134
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.133 2016/09/05 08:17:48 tedu Exp $	*/
a1166 1
		ifp->if_flags &= ~IFF_UP;
a1430 1
			ifp->if_flags &= ~IFF_UP;
@


1.133
log
@convert busy flag and tsleep to rwlock as in iwm
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.132 2016/04/13 10:34:32 mpi Exp $	*/
a1128 2

		ifp->if_opackets++;
@


1.132
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.131 2015/11/25 03:09:59 dlg Exp $	*/
d30 1
d321 1
d369 1
a370 3
	while (sc->sc_flags & IWI_FLAG_BUSY)
		tsleep(&sc->sc_flags, 0, "iwipwr", 0);
	sc->sc_flags |= IWI_FLAG_BUSY;
a374 2
	sc->sc_flags &= ~IWI_FLAG_BUSY;
	wakeup(&sc->sc_flags);
d376 1
d1453 3
a1456 11
	/*
	 * Prevent processes from entering this function while another
	 * process is tsleep'ing in it.
	 */
	while ((sc->sc_flags & IWI_FLAG_BUSY) && error == 0)
		error = tsleep(&sc->sc_flags, PCATCH, "iwiioc", 0);
	if (error != 0) {
		splx(s);
		return error;
	}
	sc->sc_flags |= IWI_FLAG_BUSY;
a1504 2
	sc->sc_flags &= ~IWI_FLAG_BUSY;
	wakeup(&sc->sc_flags);
d1506 1
a1531 2

	sc->sc_flags &= ~IWI_FLAG_FW_INITED;
a2272 1
	sc->sc_flags |= IWI_FLAG_FW_INITED;
@


1.131
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.130 2015/11/24 13:45:06 mpi Exp $	*/
a296 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.130
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.129 2015/11/24 13:33:17 mpi Exp $	*/
d1139 1
a1139 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1391 1
a1391 1
			ifp->if_flags |= IFF_OACTIVE;
d2294 1
a2294 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2318 2
a2319 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.129
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.128 2015/11/20 03:35:23 dlg Exp $	*/
a47 1
#include <net/if_arp.h>
@


1.128
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.127 2015/10/25 13:04:28 mpi Exp $	*/
a50 1
#include <net/if_types.h>
@


1.127
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.126 2015/09/01 07:09:55 deraadt Exp $	*/
d1392 1
a1392 5
		IFQ_POLL(&ifp->if_snd, m0);
		if (m0 == NULL)
			break;

		if (sc->txq[0].queued >= IWI_TX_RING_COUNT - 8) {
d1396 1
d1398 3
@


1.126
log
@sizes for free(), mostly related to firmwares.
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.125 2015/05/27 22:10:52 kettenis Exp $	*/
a1453 1
	struct ifaddr *ifa;
a1471 1
		ifa = (struct ifaddr *)data;
a1472 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.125
log
@Use m_defrag(9) instead of rolling our own inlined version.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.124 2015/03/14 03:38:48 jsg Exp $	*/
d2291 1
a2291 1
	free(data, M_DEVBUF, 0);
d2310 1
a2310 1
fail2:	free(data, M_DEVBUF, 0);
@


1.124
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.123 2015/02/10 23:25:46 mpi Exp $	*/
a1252 1
	struct mbuf *m1;
d1319 1
a1319 2
		MGETHDR(m1, M_DONTWAIT, MT_DATA);
		if (m1 == NULL) {
a1322 13
		if (m0->m_pkthdr.len > MHLEN) {
			MCLGET(m1, M_DONTWAIT);
			if (!(m1->m_flags & M_EXT)) {
				m_freem(m0);
				m_freem(m1);
				return ENOBUFS;
			}
		}
		m_copydata(m0, 0, m0->m_pkthdr.len, mtod(m1, caddr_t));
		m1->m_pkthdr.len = m1->m_len = m0->m_pkthdr.len;
		m_freem(m0);
		m0 = m1;

@


1.123
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.122 2015/01/27 03:17:36 dlg Exp $	*/
a57 2

#include <crypto/arc4.h>
@


1.122
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.121 2014/12/22 02:28:52 tedu Exp $	*/
a925 1
	m->m_pkthdr.rcvif = ifp;
@


1.121
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.120 2014/12/19 22:44:58 guenther Exp $	*/
d75 1
a75 1
void		iwi_init_task(void *, void *);
d325 1
a325 1
	task_set(&sc->init_task, iwi_init_task, sc, NULL);
d362 1
a362 1
	iwi_init_task(sc, NULL);
d366 1
a366 1
iwi_init_task(void *arg1, void *arg2)
@


1.120
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.119 2014/11/18 02:37:30 tedu Exp $	*/
a1492 1
#ifdef INET
a1494 1
#endif
@


1.119
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.118 2014/07/22 13:12:11 mpi Exp $	*/
d35 1
a37 1
#include <machine/endian.h>
@


1.118
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.117 2014/07/12 18:48:51 tedu Exp $	*/
a58 1
#include <dev/rndvar.h>
@


1.117
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.116 2013/12/06 21:03:04 deraadt Exp $	*/
a53 1
#include <netinet/in_systm.h>
a54 1
#include <netinet/ip.h>
@


1.116
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.115 2013/12/03 22:37:24 kettenis Exp $	*/
d2314 1
a2314 1
	free(data, M_DEVBUF);
d2333 1
a2333 1
fail2:	free(data, M_DEVBUF);
@


1.115
log
@Seems we simply have to live with fatal firmware errors.  Even Linux, with its
driver written by Intel engineers occasionally gets them.  So when we get one,
simply reset the chip, reload the firware and bring the interface up again.

Tested by naddy@@, who unfortunately is experiencing the quantum zeno effect
making his iwi(4) not crap out.
ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.114 2013/11/14 12:39:14 dlg Exp $	*/
d77 1
a77 1
void		iwi_resume(struct iwi_softc *);
d347 2
a348 2
	case DVACT_RESUME:
		iwi_resume(sc);
d356 1
a356 1
iwi_resume(struct iwi_softc *sc)
d365 1
a365 1
	task_add(systq, &sc->init_task);
@


1.114
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.113 2013/10/01 20:06:00 sf Exp $	*/
d77 2
a78 1
void		iwi_resume(void *, void *);
a177 2
	task_set(&sc->sc_resume_t, iwi_resume, sc, NULL);

d328 1
d348 1
a348 1
		task_add(systq, &sc->sc_resume_t);
d356 1
a356 1
iwi_resume(void *arg1, void *arg2)
a357 2
	struct iwi_softc *sc = arg1;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
a358 1
	int s;
d365 10
d380 1
a380 1
	if (ifp->if_flags & IFF_UP)
a1168 1
		ifp->if_flags &= ~IFF_UP;
d1170 1
@


1.113
log
@Use %z* for size_t

while there, fix a few %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.112 2013/08/07 01:06:35 bluhm Exp $	*/
d34 1
a34 1
#include <sys/workq.h>
d177 2
d348 1
a348 2
		workq_queue_task(NULL, &sc->sc_resume_wqt, 0,
		    iwi_resume, sc, NULL);
@


1.112
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.111 2010/11/15 19:11:57 damien Exp $	*/
d2241 1
a2241 1
		printf("%s: firmware image too short: %u bytes\n",
d2258 1
a2258 1
		printf("%s: firmware image too short: %u bytes\n",
@


1.111
log
@Reset ic_scan_lock in {ipw,iwi}_stop similarly to {wpi,iwn}_stop.

From Jeremy Chase.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.110 2010/09/07 16:21:45 deraadt Exp $	*/
a54 1
#include <netinet/in_var.h>
@


1.110
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.109 2010/08/27 20:09:01 deraadt Exp $	*/
d2341 3
@


1.109
log
@Move the guts of the powerhook function into the activate function and make
it stop calling the powerhook function; then make the powerhook function
call activate.  This basically inverts the whole goop.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.108 2010/08/27 17:08:00 jsg Exp $	*/
a78 1
void		iwi_powerhook(int, void *);
a314 2
	sc->powerhook = powerhook_establish(iwi_powerhook, sc);

a378 6
}

void
iwi_powerhook(int why, void *arg)
{
	iwi_activate(arg, why);
@


1.108
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.107 2010/08/12 16:59:29 damien Exp $	*/
d79 1
a79 1
void		iwi_power(int, void *);
d316 1
a316 1
	sc->powerhook = powerhook_establish(iwi_power, sc);
d361 1
a361 7
	iwi_power(PWR_RESUME, arg1);
}

void
iwi_power(int why, void *arg)
{
	struct iwi_softc *sc = arg;
a365 5
	if (why != PWR_RESUME) {
		iwi_stop(ifp, 0);
		return;
	}

d382 6
@


1.107
log
@homogeneous style.

no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.106 2010/08/12 15:03:59 oga Exp $	*/
a301 1
	ifp->if_init = iwi_init;
@


1.106
log
@Instead of returning EBUSY when the busy flag is set in the ioctl, sleep
until whoever has it is done with it.

This is kept as flag/sleep condvars instead of a rwlock because later we
may want to quiesce the handler before suspend to make sure nothing is
sleeping on a chip that is about to be whacked (doing so will change the
proc so rwlocks won't work).

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.105 2010/08/03 18:26:25 kettenis Exp $	*/
d356 1
a356 1
	return (0);
d1492 1
a1492 1
	while (sc->sc_flags & IWI_FLAG_BUSY && error == 0)
d1494 1
a1494 1
	if (error) {
@


1.105
log
@Bring the suspend/resume code of all the Intel wireless drivers in line with
iwn(4) again.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.104 2010/07/28 21:21:38 deraadt Exp $	*/
d384 2
d392 1
d1492 3
a1494 1
	if (sc->sc_flags & IWI_FLAG_BUSY) {
d1496 1
a1496 1
		return EBUSY;
d1553 1
@


1.104
log
@Make legacy xxpower() functions call xxstop() on suspend, and simplify their
resume paths.  For new-style suspend/resume, add a ca_activate function where
it is missing, and use a workq to resume because these drivers like to sleep.
ok damien
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.103 2010/05/19 15:27:35 oga Exp $	*/
d384 2
d388 2
d1485 9
d1547 1
d1575 1
a1575 1
	sc->flags &= ~IWI_FLAG_FW_INITED;
d2317 1
a2317 1
	sc->flags |= IWI_FLAG_FW_INITED;
@


1.103
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.102 2010/04/20 22:05:43 tedu Exp $	*/
d34 1
d77 2
d147 2
a148 1
	sizeof (struct iwi_softc), iwi_match, iwi_attach
d339 26
d369 1
a369 1
	struct ifnet *ifp;
d373 2
a374 1
	if (why != PWR_RESUME)
d376 1
d384 2
a385 6
	ifp = &sc->sc_ic.ic_if;
	if (ifp->if_flags & IFF_UP) {
		ifp->if_init(ifp);
		if (ifp->if_flags & IFF_RUNNING)
			ifp->if_start(ifp);
	}
@


1.102
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.101 2009/05/11 19:24:57 damien Exp $	*/
d381 1
a381 1
	    &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT);
a405 1
	bzero(ring->desc, sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_COUNT);
d456 1
a456 1
	    &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT);
a479 2

	bzero(ring->desc, sizeof (struct iwi_tx_desc) * IWI_TX_RING_COUNT);
@


1.101
log
@sync setting of the capinfo field of assoc req frames w/ net80211.
fixes association with APs that refuse non short slot time capable STAs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.100 2009/03/29 21:53:52 sthen Exp $	*/
a27 1
#include <sys/sysctl.h>
@


1.100
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.99 2009/01/26 19:09:41 damien Exp $	*/
d2151 1
a2151 1
	if (ic->ic_flags & IEEE80211_F_SHSLOT)
@


1.99
log
@Add some initial HT bits (not enabled yet) based on 802.11n Draft 7.01:
- implement A-MPDU frames buffering and reordering
- implement A-MSDU decapsulation
- process/send ADDBA Request, ADDBA Response and DELBA action frames
- process Block Ack Request control frames (including MTBAR)
- implement PBAC support (Protected Block Ack)
- add some incomplete HT Capabilities and HT Operation IEs parsing

Add more Management Frame Protection bits based on 802.11w Draft 7.0:
- implement SA Query procedure (both AP and STA)
- cleanup BIP

Fix some bugs:
- fix check for WEP key length that otherwise caused a stack smash in
  ieee80211_wep_encrypt (pointed out by Xavier Santolaria on macppc)
- properly stop EAPOL timeout: fixes a panic that occured in HostAP mode
  when turning the interface down while a 4-way handshake is in progress
  (pointed out by Doughertys)

Did some code cleanup too.

The HT bits are currently not compiled in (IEEE80211_NO_HT is defined)
because they won't be ready until after the next release and I didn't
want to grow the kernel or to inadvertently introduce new bugs.
They are here such that other people can look at the code.
Notice that I had to add an extra parameter to ic_send_mgmt() for
action frames, that is why there are small changes in drivers defining
their own ic_send_mgmt() handler.

Sorry for the not very incremental diff but this has been sitting in
my tree for too long now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.98 2008/12/22 18:20:47 damien Exp $	*/
d185 1
a185 1
		printf(": could not map memory space\n");
d194 1
a194 1
		printf(": could not map interrupt\n");
d202 1
a202 1
		printf(": could not establish interrupt");
d393 1
a393 1
		printf("%s: could not map cmd ring DMA memory\n",
d469 1
a469 1
		printf("%s: could not map tx ring DMA memory\n",
d1296 1
a1296 1
		printf("%s: could not map mbuf (error %d)\n",
d1324 1
a1324 1
			printf("%s: could not map mbuf (error %d)\n",
d1680 1
a1680 1
		printf("%s: could not map firmware DMA memory\n",
@


1.98
log
@I swapped MGETHDR arguments in my m_defrag removal commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.97 2008/12/21 18:19:58 damien Exp $	*/
d103 1
a103 1
		    int, int);
d1224 1
a1224 1
    int arg)
@


1.97
log
@Undo m_defrag().

m_defrag() does not work.  It seems to assume that if the length of
the mbuf passed as parameter is less than MHLEN, then it is an mbuf
header and not a cluster (or something like that.)
It thus fails miserably in the bcopy path.
I don't have the time to investigate further into this.

Thanks to Okan Demirmen for reporting the issue on a ral(4) RT2560.
The RT2560 chipset does not support TX scatter and thus m_defrag()
was called much more often than in other drivers using m_defrag()
where it was less noticeable.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.96 2008/11/25 22:20:11 damien Exp $	*/
d1303 1
a1303 1
		MGETHDR(m1, MT_DATA, M_DONTWAIT);
@


1.96
log
@more sizeof->nitems
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.95 2008/11/25 21:43:57 damien Exp $	*/
d1236 1
d1303 2
a1304 1
		if (m_defrag(m0, M_DONTWAIT) != 0) {
d1306 9
a1314 1
			return ENOMEM;
d1316 5
@


1.95
log
@use shiny new m_defrag() and nitems() instead of rolling our own.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.94 2008/09/04 15:59:52 damien Exp $	*/
d152 1
a152 1
	    sizeof (iwi_devices) / sizeof (iwi_devices[0]));
@


1.94
log
@mostly cosmetic.
also, do not set the privacy bit in the capinfo field of (re)assoc
requests, even for RSNA.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.93 2008/09/03 19:47:58 damien Exp $	*/
a1238 1
	struct mbuf *mnew;
d1302 1
a1302 3

		MGETHDR(mnew, M_DONTWAIT, MT_DATA);
		if (mnew == NULL) {
a1305 15
		M_DUP_PKTHDR(mnew, m0);
		if (m0->m_pkthdr.len > MHLEN) {
			MCLGET(mnew, M_DONTWAIT);
			if (!(mnew->m_flags & M_EXT)) {
				m_freem(m0);
				m_freem(mnew);
				return ENOMEM;
			}
		}

		m_copydata(m0, 0, m0->m_pkthdr.len, mtod(mnew, caddr_t));
		m_freem(m0);
		mnew->m_len = mnew->m_pkthdr.len;
		m0 = mnew;

@


1.93
log
@(Re)Association requests should contain a QoS Capability element,
not an EDCA Parameter Set element (spotted by IEEE80211_STA_ONLY).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.92 2008/09/03 19:43:59 damien Exp $	*/
d82 1
a82 1
		    bus_size_t, bus_size_t);
d171 1
a171 1
	int error, i;
d218 1
a218 2
	error = iwi_alloc_cmd_ring(sc, &sc->cmdq);
	if (error != 0) {
d222 5
a226 6

	error = iwi_alloc_tx_ring(sc, &sc->txq[0], IWI_CSR_TX1_RIDX,
	    IWI_CSR_TX1_WIDX);
	if (error != 0) {
		printf(": could not allocate Tx ring 1\n");
		goto fail1;
d228 1
a228 24

	error = iwi_alloc_tx_ring(sc, &sc->txq[1], IWI_CSR_TX2_RIDX,
	    IWI_CSR_TX2_WIDX);
	if (error != 0) {
		printf(": could not allocate Tx ring 2\n");
		goto fail2;
	}

	error = iwi_alloc_tx_ring(sc, &sc->txq[2], IWI_CSR_TX3_RIDX,
	    IWI_CSR_TX3_WIDX);
	if (error != 0) {
		printf(": could not allocate Tx ring 3\n");
		goto fail3;
	}

	error = iwi_alloc_tx_ring(sc, &sc->txq[3], IWI_CSR_TX4_RIDX,
	    IWI_CSR_TX4_WIDX);
	if (error != 0) {
		printf(": could not allocate Tx ring 4\n");
		goto fail4;
	}

	error = iwi_alloc_rx_ring(sc, &sc->rxq);
	if (error != 0) {
d230 1
a230 1
		goto fail5;
d331 3
a333 5
fail5:	iwi_free_tx_ring(sc, &sc->txq[3]);
fail4:	iwi_free_tx_ring(sc, &sc->txq[2]);
fail3:	iwi_free_tx_ring(sc, &sc->txq[1]);
fail2:	iwi_free_tx_ring(sc, &sc->txq[0]);
fail1:	iwi_free_cmd_ring(sc, &sc->cmdq);
d342 1
d352 1
d359 1
d436 1
a436 2
iwi_alloc_tx_ring(struct iwi_softc *sc, struct iwi_tx_ring *ring,
    bus_size_t csr_ridx, bus_size_t csr_widx)
d443 2
a444 2
	ring->csr_ridx = csr_ridx;
	ring->csr_widx = csr_widx;
d1218 1
a1218 1
	return async ? 0 : tsleep(sc, 0, "iwicmd", hz);
d1520 1
d1537 2
a1538 2
	CSR_WRITE_4(sc, IWI_CSR_RST, CSR_READ_4(sc, IWI_CSR_RST) |
	    IWI_RST_PRINCETON_RESET);
d1546 1
d1552 2
a1553 2
	CSR_WRITE_4(sc, IWI_CSR_CTL, CSR_READ_4(sc, IWI_CSR_CTL) |
	    IWI_CTL_INIT);
d1569 2
a1570 2
	CSR_WRITE_4(sc, IWI_CSR_RST, CSR_READ_4(sc, IWI_CSR_RST) |
	    IWI_RST_SW_RESET);
d1574 2
a1575 2
	CSR_WRITE_4(sc, IWI_CSR_CTL, CSR_READ_4(sc, IWI_CSR_CTL) |
	    IWI_CTL_INIT);
d1589 1
d1592 2
a1593 2
	CSR_WRITE_4(sc, IWI_CSR_RST, CSR_READ_4(sc, IWI_CSR_RST) |
	    IWI_RST_STOP_MASTER);
d1608 2
a1609 2
	CSR_WRITE_4(sc, IWI_CSR_RST, CSR_READ_4(sc, IWI_CSR_RST) &
	    ~IWI_RST_PRINCETON_RESET);
d1660 1
a1660 1
	uint32_t sentinel, ctl, src, dst, sum, len, mlen;
d1742 3
a1744 2
	CSR_WRITE_4(sc, IWI_CSR_RST, CSR_READ_4(sc, IWI_CSR_RST) &
	    ~(IWI_RST_MASTER_DISABLED | IWI_RST_STOP_MASTER));
d1770 2
a1771 2
	CSR_WRITE_4(sc, IWI_CSR_CTL, CSR_READ_4(sc, IWI_CSR_CTL) |
	    IWI_CTL_ALLOW_STANDBY);
d1774 1
a1774 1
	if ((error = tsleep(sc, 0, "iwiinit", hz)) != 0) {
d1918 1
a1918 1
	data = arc4random();
d2149 1
a2149 1
	if (ic->ic_flags & (IEEE80211_F_WEPON | IEEE80211_F_RSNON))
d2182 1
a2182 1
	int i, error;
d2191 1
a2191 1
	switch (sc->sc_ic.ic_opmode) {
a2214 1

a2220 1

d2259 6
a2264 15
	CSR_WRITE_4(sc, IWI_CSR_TX1_BASE, sc->txq[0].map->dm_segs[0].ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_TX1_SIZE, IWI_TX_RING_COUNT);
	CSR_WRITE_4(sc, IWI_CSR_TX1_WIDX, sc->txq[0].cur);

	CSR_WRITE_4(sc, IWI_CSR_TX2_BASE, sc->txq[1].map->dm_segs[0].ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_TX2_SIZE, IWI_TX_RING_COUNT);
	CSR_WRITE_4(sc, IWI_CSR_TX2_WIDX, sc->txq[1].cur);

	CSR_WRITE_4(sc, IWI_CSR_TX3_BASE, sc->txq[2].map->dm_segs[0].ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_TX3_SIZE, IWI_TX_RING_COUNT);
	CSR_WRITE_4(sc, IWI_CSR_TX3_WIDX, sc->txq[2].cur);

	CSR_WRITE_4(sc, IWI_CSR_TX4_BASE, sc->txq[3].map->dm_segs[0].ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_TX4_SIZE, IWI_TX_RING_COUNT);
	CSR_WRITE_4(sc, IWI_CSR_TX4_WIDX, sc->txq[3].cur);
d2310 1
a2310 1
	int i;
d2324 2
a2325 2
	for (i = 0; i < 4; i++)
		iwi_reset_tx_ring(sc, &sc->txq[i]);
@


1.92
log
@redefine ic_send_mgmt() as a no-op instead of calling IF_PURGE in
{ipw,iwi}_start which is wrong (node reference is not released).
from pgt(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.91 2008/08/28 15:55:37 damien Exp $	*/
d2128 3
a2130 3
		frm = ieee80211_add_edca_params(buf, ic);
		DPRINTF(("Setting EDCA IE length %d\n", frm - buf));
		error = iwi_cmd(sc, IWI_CMD_SET_EDCAIE, buf, frm - buf, 1);
@


1.91
log
@80 cols.

no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.90 2008/08/28 15:52:20 damien Exp $	*/
d102 2
d336 1
a898 1

d1246 8
d1414 3
a1417 4
		IF_PURGE(&ic->ic_mgtq);

		if (ic->ic_state != IEEE80211_S_RUN)
			return;
@


1.90
log
@WPA support for iwi(4).
some initial WMM bits too.
use license.template while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.89 2008/08/27 09:28:38 damien Exp $	*/
d288 2
a289 1
		ic->ic_sup_rates[IEEE80211_MODE_11A] = ieee80211_std_rateset_11a;
@


1.89
log
@the firmware is responsible for sending management frames, but
since we pass received management frames to net80211, net80211
may send replies (like deauth/disassoc), so we just call
IF_PURGE(&ic->ic_mgtq) in {ipw,iwi}_start just to be on the
safe side of things (so we don't leak mbufs).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.88 2008/08/27 09:05:03 damien Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004-2006
d7 3
a9 9
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice unmodified, this list of conditions, and the following
 *    disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d11 7
a17 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d112 1
d269 2
a270 1
	    IEEE80211_C_WEP |		/* h/w WEP supported */
a596 1

a932 19
	wh = mtod(m, struct ieee80211_frame *);

	rxi.rxi_flags = 0;
	if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
		/*
		 * Hardware decrypts the frame itself but leaves the WEP bit
		 * set in the 802.11 header and doesn't remove the IV and CRC
		 * fields.
		 */
		wh->i_fc[1] &= ~IEEE80211_FC1_WEP;
		ovbcopy(wh, (char *)wh + IEEE80211_WEP_IVLEN +
		    IEEE80211_WEP_KIDLEN, sizeof (struct ieee80211_frame));
		m_adj(m, IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN);
		m_adj(m, -IEEE80211_WEP_CRCLEN);
		wh = mtod(m, struct ieee80211_frame *);

		rxi.rxi_flags |= IEEE80211_RXI_HWDEC;
	}

d959 1
d963 1
d1248 2
d1254 13
a1266 1
	int error, i, station = 0;
d1290 4
a1293 3
	/* save and trim IEEE802.11 header */
	m_copydata(m0, 0, sizeof (struct ieee80211_frame), (caddr_t)&desc->wh);
	m_adj(m0, sizeof (struct ieee80211_frame));
a1322 1

d1356 1
a1356 1
	desc->flags = 0;
a1361 9
	if (desc->wh.i_fc[1] & IEEE80211_FC1_WEP) {
		desc->wep_txkey = ic->ic_wep_txkey |
		    ((ic->ic_nw_keys[ic->ic_wep_txkey].k_cipher ==
			IEEE80211_CIPHER_WEP40) ? IWI_DATA_KEY_WEP40 :
		    IWI_DATA_KEY_WEP104);
	} else {
		desc->flags |= IWI_DATA_FLAG_NO_WEP;
		desc->wep_txkey = 0;
	}
d1365 5
a1806 2
	struct ieee80211_key *k;
	struct iwi_wep_key wepkey;
d1929 3
a1931 3
	data = htole32(arc4random());
	DPRINTF(("Setting initialization vector to %u\n", letoh32(data)));
	error = iwi_cmd(sc, IWI_CMD_SET_IV, &data, sizeof data, 0);
a1934 17
	if (ic->ic_flags & IEEE80211_F_WEPON) {
		k = ic->ic_nw_keys;
		for (i = 0; i < IEEE80211_WEP_NKID; i++, k++) {
			wepkey.cmd = IWI_WEP_KEY_CMD_SETKEY;
			wepkey.idx = i;
			wepkey.len = k->k_len;
			bzero(wepkey.key, sizeof wepkey.key);
			bcopy(k->k_key, wepkey.key, k->k_len);
			DPRINTF(("Setting wep key index %u len %u\n",
			    wepkey.idx, wepkey.len));
			error = iwi_cmd(sc, IWI_CMD_SET_WEP_KEY, &wepkey,
			    sizeof wepkey, 0);
			if (error != 0)
				return error;
		}
	}

d1940 45
d2052 2
d2055 1
a2055 1
	uint32_t data;
d2061 2
d2115 21
d2143 5
d2155 2
a2156 5
#if 0
	if (ni->ni_challenge != NULL)	/* XXX */
		assoc.auth = (ic->ic_wep_txkey << 4) | IWI_AUTH_SHARED;
#endif
	if (ic->ic_flags & IEEE80211_F_SHPREAMBLE)
d2160 1
a2160 1
	if (ic->ic_flags & IEEE80211_F_WEPON)
@


1.88
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.87 2008/07/21 18:43:18 damien Exp $	*/
d1419 2
a1420 2
	if (ic->ic_state != IEEE80211_S_RUN)
		return;
d1422 2
a1423 1
	for (;;) {
@


1.87
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.86 2007/11/17 19:09:16 damien Exp $	*/
d271 1
d273 1
d693 1
d697 1
d701 1
a701 2
	case IEEE80211_M_AHDEMO:
	case IEEE80211_M_HOSTAP:
d707 1
d738 1
d759 1
d763 3
a765 1
		} else if (ic->ic_opmode == IEEE80211_M_MONITOR)
d945 1
a945 2
	if ((wh->i_fc[1] & IEEE80211_FC1_WEP) &&
	    ic->ic_opmode != IEEE80211_M_MONITOR) {
d1306 1
d1316 1
d1838 5
a1842 1
	config.answer_pbreq = (ic->ic_opmode == IEEE80211_M_IBSS) ? 1 : 0;
d2050 5
a2054 1
	config.answer_pbreq = (ic->ic_opmode == IEEE80211_M_IBSS) ? 1 : 0;
d2101 1
d2105 1
d2134 1
d2138 1
a2165 1
	case IEEE80211_M_HOSTAP:
d2168 1
d2173 1
d2178 3
a2180 1
		name = NULL;	/* should not get there */
@


1.86
log
@update the physical address of the RX buffer after bus_dmamap_load()
in the case where the old buffer is remapped.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.85 2007/09/07 19:05:05 damien Exp $	*/
d871 1
d936 1
d950 2
d983 3
a985 1
	ieee80211_input(ifp, m, ni, frame->rssi_dbm, 0);
@


1.85
log
@use new malloc M_ZERO flag to shrink kernel.
remove <malloc.h> from files where malloc is not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.84 2007/08/28 18:34:38 deraadt Exp $	*/
d918 1
@


1.84
log
@unify firmware load failure messages; ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.83 2007/07/18 18:10:31 damien Exp $	*/
a42 1
#include <sys/malloc.h>
@


1.83
log
@replace the ieee80211_wepkey structure with a more generic ieee80211_key
one that can be used with other ciphers than WEP.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.82 2007/07/06 18:03:42 damien Exp $	*/
d2154 2
a2155 2
		printf("%s: could not read firmware %s\n",
		    sc->sc_dev.dv_xname, name);
@


1.82
log
@typo in an error message.
reported a while back by Laurence Tratt, reminded more recently by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.81 2007/07/05 21:38:19 damien Exp $	*/
d1361 3
a1363 2
		    (ic->ic_nw_keys[ic->ic_wep_txkey].wk_len <= 5) ?
			IWI_DATA_KEY_WEP40 : IWI_DATA_KEY_WEP104;
d1807 1
a1807 1
	struct ieee80211_wepkey *k;
d1938 1
a1938 1
			wepkey.len = k->wk_len;
d1940 1
a1940 1
			bcopy(k->wk_key, wepkey.key, k->wk_len);
@


1.81
log
@fixes my previous commit.
the ESS bit must be set in (re)assocation requests.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.80 2007/07/05 20:31:38 damien Exp $	*/
d1686 1
a1686 1
		printf("%s: could allocate firmware DMA memory\n",
@


1.80
log
@don't set IEEE80211_CAPINFO_ESS bit since we're not operating as an AP.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.79 2007/01/03 18:19:06 claudio Exp $	*/
d2095 1
a2095 4
	if (ic->ic_opmode == IEEE80211_M_IBSS)
		capinfo = IEEE80211_CAPINFO_IBSS;
	else
		capinfo = 0;
@


1.79
log
@M_DUP_PKTHDR() cleanup. On static mbufs M_DUP_PKTHDR() will leak mbuf tags.
See similar commit to dev/usb/if_rum.c for more info. With this commit
all drivers have been switched away from the incorrect M_DUP_PKTHDR() usage.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.78 2006/11/26 11:14:22 deraadt Exp $	*/
d2098 1
a2098 1
		capinfo = IEEE80211_CAPINFO_ESS;
@


1.78
log
@do not have each net80211 driver define its own rates structures.  if they use
the standard rates, use some defined by net80211 itself.  kernel shrinks a bit
ok jsg mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.77 2006/10/23 18:19:26 damien Exp $	*/
a965 1
		M_DUP_PKTHDR(&mb, m);
d969 3
a971 1
		mb.m_pkthdr.len += mb.m_len;
a1275 1
		M_DUP_PKTHDR(&mb, m0);
d1279 3
a1281 1
		mb.m_pkthdr.len += mb.m_len;
@


1.77
log
@remove detach() function. this is not hotplug and this is dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.76 2006/10/22 08:25:43 damien Exp $	*/
a85 9
static const struct ieee80211_rateset iwi_rateset_11a =
	{ 8, { 12, 18, 24, 36, 48, 72, 96, 108 } };

static const struct ieee80211_rateset iwi_rateset_11b =
	{ 4, { 2, 4, 11, 22 } };

static const struct ieee80211_rateset iwi_rateset_11g =
	{ 12, { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 } };

d295 1
a295 1
		ic->ic_sup_rates[IEEE80211_MODE_11A] = iwi_rateset_11a;
d311 2
a312 2
	ic->ic_sup_rates[IEEE80211_MODE_11B] = iwi_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = iwi_rateset_11g;
@


1.76
log
@Check that ni->ni_rates.rs_nrates is not greater than sizeof rs.rates in
iwi_auth_and_assoc() before copying the rate set.
The firmware command allows a maximum of 12 rates to be defined while the
ieee80211_rateset structure can contain up to 15 rates.
Notice that this should not happen since the rate set is supposed to be
negotiated at that time but Jeremie Le Hen sees some evidence of this
happening in FreeBSD.
In case it happens, print a diagnostic message and truncate the rate set.

Pointed out by Jeremie Le Hen.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.75 2006/09/29 05:34:25 brad Exp $	*/
a96 1
int		iwi_detach(struct device *, int);
d162 1
a162 1
	sizeof (struct iwi_softc), iwi_match, iwi_attach, iwi_detach
a372 27
}

int
iwi_detach(struct device *self, int flags)
{
	struct iwi_softc *sc = (struct iwi_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int i;

	iwi_stop(ifp, 1);

	ieee80211_ifdetach(ifp);
	if_detach(ifp);

	iwi_free_cmd_ring(sc, &sc->cmdq);
	for (i = 0; i < 4; i++)
		iwi_free_tx_ring(sc, &sc->txq[i]);
	iwi_free_rx_ring(sc, &sc->rxq);

	if (sc->sc_ih != NULL) {
		pci_intr_disestablish(sc->sc_pct, sc->sc_ih);
		sc->sc_ih = NULL;
	}

	bus_space_unmap(sc->sc_st, sc->sc_sh, sc->sc_sz);

	return 0;
@


1.75
log
@add a missing format string to the beacon miss debug message.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.74 2006/09/18 16:20:20 damien Exp $	*/
d2089 10
@


1.74
log
@don't use IF_PREPEND() on altq's.
use IFQ_POLL()/IFQ_DEQUEUE() logic instead as described in altq(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.73 2006/08/19 14:57:37 damien Exp $	*/
d1109 1
a1109 1
			DPRINTFN(2, ("%u beacon(s) missed\n",
@


1.73
log
@tweak dma sync ops
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.72 2006/08/19 12:03:05 damien Exp $	*/
d976 1
a976 1
		 * set in the 802.11 header and don't remove the IV and CRC
d1442 1
a1442 1
		IF_DEQUEUE(&ifp->if_snd, m0);
a1446 1
			IF_PREPEND(&ifp->if_snd, m0);
d1450 1
a1450 1

d1709 1
a1709 1
	/* allocate DMA memory for storing firmware image */
@


1.72
log
@get rid of shared auth mode.
the ioctl is not supported by ifconfig and it has never worked anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.71 2006/08/19 11:07:44 damien Exp $	*/
d1414 2
a1419 3
	bus_dmamap_sync(sc->sc_dmat, data->map, 0, MCLBYTES,
	    BUS_DMASYNC_PREWRITE);

a2113 1

@


1.71
log
@o Improve 802.11 radiotap support (correct Rx antenna and Rx rate,
  add short preamble flag)
o Add short slot time support
o Ignore parity errors interrupts (as per Linux driver)
o Fix DMA sync ops
o Improve async commands processing
o Fix hardware WEP encryption (40/104bit keys)
o Set Tx power to the maximum value for 802.11a channels too
o Disable bluetooth coexistence and hardware antenna diversity as
  it seems to panic the firmware on some adapters
o Handle beacon miss and link degradation notifications (but don't
  automatically roam yet)
o Remove unused prototypes
o Cosmetic tweaks as always
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.70 2006/08/18 16:04:56 damien Exp $	*/
a332 3
	/* default to authmode OPEN */
	sc->authmode = IEEE80211_AUTH_OPEN;

a1552 12
	case SIOCG80211AUTH:
		((struct ieee80211_auth *)data)->i_authtype = sc->authmode;
		break;

	case SIOCS80211AUTH:
		/* only super-user can do that! */
		if ((error = suser(curproc, 0)) != 0)
			break;

		sc->authmode = ((struct ieee80211_auth *)data)->i_authtype;
		break;

d2115 3
a2117 1
	if (sc->authmode == IEEE80211_AUTH_SHARED)
d2119 1
@


1.70
log
@set of unrelated cosmetic tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.69 2006/06/14 18:40:23 brad Exp $	*/
d31 1
a31 1
 * Driver for Intel(R) PRO/Wireless 2200BG/2915ABG 802.11 network adapters.
d114 1
a126 2
int		iwi_get_table0(struct iwi_softc *, uint32_t *);
int		iwi_get_radio(struct iwi_softc *, int *);
d286 1
d359 1
a359 1
	    sizeof (struct ieee80211_frame) + 64);
d384 1
d392 2
a393 4
	iwi_free_tx_ring(sc, &sc->txq[0]);
	iwi_free_tx_ring(sc, &sc->txq[1]);
	iwi_free_tx_ring(sc, &sc->txq[2]);
	iwi_free_tx_ring(sc, &sc->txq[3]);
a712 1
#define N(a)	(sizeof (a) / sizeof (a[0]))
a714 17
	static const struct {
		uint32_t	val;
		int		rate;
	} rates[] = {
		{ IWI_RATE_DS1,      2 },
		{ IWI_RATE_DS2,      4 },
		{ IWI_RATE_DS5,     11 },
		{ IWI_RATE_DS11,    22 },
		{ IWI_RATE_OFDM6,   12 },
		{ IWI_RATE_OFDM9,   18 },
		{ IWI_RATE_OFDM12,  24 },
		{ IWI_RATE_OFDM18,  36 },
		{ IWI_RATE_OFDM24,  48 },
		{ IWI_RATE_OFDM36,  72 },
		{ IWI_RATE_OFDM48,  96 },
		{ IWI_RATE_OFDM54, 108 },
	};
d716 1
a716 1
	int rate, i;
d725 2
a726 4

	/* convert rate to 802.11 rate */
	for (i = 0; i < N(rates) && rates[i].val != val; i++);
	rate = (i < N(rates)) ? rates[i].rate : 0;
a731 1

a734 1

a737 1

a742 1
#undef N
d879 25
a917 4
	bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (struct iwi_hdr),
	    sizeof (struct iwi_frame) + letoh16(frame->len),
	    BUS_DMASYNC_POSTREAD);

a970 1

d974 1
d983 1
a983 1
		bcopy(wh, (char *)wh + IEEE80211_WEP_IVLEN +
d996 1
a996 1
		tap->wr_rate = frame->rate;
d1002 3
a1004 1
		tap->wr_antenna = frame->antenna;
a1029 8
	struct iwi_notif_scan_channel *chan;
	struct iwi_notif_scan_complete *scan;
	struct iwi_notif_authentication *auth;
	struct iwi_notif_association *assoc;

	bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (struct iwi_hdr),
	    sizeof (struct iwi_notif) + letoh16(notif->len),
	    BUS_DMASYNC_POSTREAD);
d1033 5
a1037 2
		chan = (struct iwi_notif_scan_channel *)(notif + 1);

d1040 1
a1040 1

d1042 5
a1046 2
		scan = (struct iwi_notif_scan_complete *)(notif + 1);

d1056 1
a1056 1

d1058 3
a1060 1
		auth = (struct iwi_notif_authentication *)(notif + 1);
d1077 1
a1077 1

d1079 3
a1081 1
		assoc = (struct iwi_notif_association *)(notif + 1);
d1104 21
d1143 2
a1144 2
		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    sizeof (struct iwi_hdr), BUS_DMASYNC_POSTREAD);
d1218 1
a1218 1
	if (r & (IWI_INTR_FATAL_ERROR | IWI_INTR_PARITY_ERROR)) {
d1221 1
a1221 1
		iwi_stop(&sc->sc_ic.ic_if, 1);
d1225 2
a1226 4
	if (r & IWI_INTR_FW_INITED) {
		if (!(r & (IWI_INTR_FATAL_ERROR | IWI_INTR_PARITY_ERROR)))
			wakeup(sc);
	}
d1231 2
a1232 2
		iwi_stop(&sc->sc_ic.ic_if, 1);
		r = 0;	/* don't process more interrupts */
d1235 6
a1240 1
	if (r & IWI_INTR_CMD_DONE)
d1242 1
d1285 6
a1290 1
	CSR_WRITE_4(sc, IWI_CSR_CMD_WIDX, sc->cmdq.cur);
d1392 1
d1397 5
a1401 3
	if (desc->wh.i_fc[1] & IEEE80211_FC1_WEP)
		desc->wep_txkey = ic->ic_wep_txkey;
	else
d1403 2
a1404 1

d1408 3
d1630 1
a1630 1
		return EIO;
d1665 1
a1665 1
		return EIO;
d1701 1
a1701 1
		return EIO;
d1819 1
a1819 1
		error = EIO;
d1861 1
a1861 1
	int error, i;
a1870 2
	config.bluetooth_coexistence = 1;
	config.antenna = 2;	/* antenna diversity */
d1872 2
d1898 24
a1921 12
	if (ic->ic_opmode == IEEE80211_M_IBSS) {
		power.mode = IWI_MODE_11B;
		power.nchan = 11;
		for (i = 0; i < 11; i++) {
			power.chan[i].chan = i + 1;
			power.chan[i].power = IWI_TXPOWER_MAX;
		}
		DPRINTF(("Setting .11b channels tx power\n"));
		error = iwi_cmd(sc, IWI_CMD_SET_TX_POWER, &power, sizeof power,
		    0);
		if (error != 0)
			return error;
d1923 13
a1935 2
		power.mode = IWI_MODE_11G;
		DPRINTF(("Setting .11g channels tx power\n"));
d2044 1
a2044 2
		if (IEEE80211_IS_CHAN_5GHZ(&ic->ic_channels[i]) &&
		    isset(ic->ic_chan_active, i)) {
d2054 1
a2054 2
		if (IEEE80211_IS_CHAN_2GHZ(&ic->ic_channels[i]) &&
		    isset(ic->ic_chan_active, i)) {
d2077 7
a2083 6
	if (IEEE80211_IS_CHAN_2GHZ(ni->ni_chan)) {
		/* enable b/g autodection */
		bzero(&config, sizeof config);
		config.bluetooth_coexistence = 1;
		config.antenna = 2;	/* antenna diversity */
		config.multicast_enabled = 1;
d2085 4
a2088 8
		config.answer_pbreq =
		    (ic->ic_opmode == IEEE80211_M_IBSS) ? 1 : 0;
		DPRINTF(("Configuring adapter\n"));
		error = iwi_cmd(sc, IWI_CMD_SET_CONFIG, &config, sizeof config,
		    1);
		if (error != 0)
			return error;
	}
d2107 1
a2107 1
	DPRINTF(("Setting negociated rates (%u)\n", rs.nrates));
d2119 10
a2128 2
	assoc.mode = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? IWI_MODE_11A :
	    IWI_MODE_11G;
d2132 2
a2134 1

d2143 3
a2145 1
	capinfo |= IEEE80211_CAPINFO_SHORT_PREAMBLE;
d2306 1
d2320 2
a2321 4
	iwi_reset_tx_ring(sc, &sc->txq[0]);
	iwi_reset_tx_ring(sc, &sc->txq[1]);
	iwi_reset_tx_ring(sc, &sc->txq[2]);
	iwi_reset_tx_ring(sc, &sc->txq[3]);
@


1.69
log
@clear the IFF_UP interface flag before shutting down the interface.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.68 2006/05/17 19:54:10 damien Exp $	*/
d30 2
a31 3
/*-
 * Intel(R) PRO/Wireless 2200BG/2225BG/2915ABG driver
 * http://www.intel.com/network/connectivity/products/wireless/prowireless_mobile.htm
a284 1
	    IEEE80211_C_WEP |		/* h/w WEP supported */
d287 1
d1366 1
a1366 2
	if (ic->ic_flags & IEEE80211_F_WEPON) {
		desc->wh.i_fc[1] |= IEEE80211_FC1_WEP;
d1368 1
a1368 1
	} else
d2261 1
a2261 1
	0, "iwi", DV_IFNET
@


1.68
log
@sync handling of fatal firmware errors w/ wpi(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.67 2006/05/01 08:39:17 damien Exp $	*/
d381 1
a381 1
iwi_detach(struct device* self, int flags)
d1186 1
d1200 1
d1212 1
d1458 1
@


1.67
log
@call iwi_stop() at beginning of iwi_init() so that all rings are properly
reset when iwi_init() is called from iwi_ioctl() on ENETRESET.
this fixes a firmware panic when setting a WEP key multiple times for
instance.  fix some printf while i'm here.

pointed out by Kurt Miller (kurt@@).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.66 2006/04/02 20:30:19 dim Exp $	*/
d1198 1
a1198 1
		printf("%s: fatal error\n", sc->sc_dev.dv_xname);
d1200 1
a1200 1
		r = 0;	/* don't process more interrupts */
@


1.66
log
@Prevent panic when loading pre-3.0 iwi firmware, and give a helpful
error message instead. Also return EINVAL for some other error paths.

ok damien, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.65 2006/04/01 15:36:01 mickey Exp $	*/
d2104 2
d2134 1
a2134 1
		printf("%s: firmware image too short: %zu bytes\n",
d2152 1
a2152 1
		printf("%s: firmware image too short: %zu bytes\n",
d2218 3
a2224 3

	ifp->if_flags &= ~IFF_OACTIVE;
	ifp->if_flags |= IFF_RUNNING;
@


1.65
log
@use proper types and not fetch iobase that is not used later; damien ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.64 2006/04/01 01:04:40 pedro Exp $	*/
d2134 1
d2140 8
d2152 1
@


1.64
log
@Put Damien's latest changes back in, okay deraadt@@.
Please note that the driver now requires new firmware (version 3.0).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.62 2006/03/27 20:46:35 damien Exp $	*/
d104 1
a104 1
		    bus_addr_t, bus_addr_t);
a187 1
	bus_addr_t base;
d203 1
a203 1
	    PCI_MAPREG_MEM_TYPE_32BIT, 0, &memt, &memh, &base, &sc->sc_sz, 0);
d506 1
a506 1
    bus_addr_t csr_ridx, bus_addr_t csr_widx)
@


1.63
log
@Backout, causes panics
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.61 2006/03/25 22:41:45 djm Exp $	*/
d100 10
a109 2
int		iwi_dma_alloc(struct iwi_softc *);
void		iwi_release(struct iwi_softc *);
d115 1
a115 1
void		iwi_frame_intr(struct iwi_softc *, struct iwi_rx_buf *, int,
d117 1
a117 1
void		iwi_notification_intr(struct iwi_softc *, struct iwi_rx_buf *,
d120 1
a120 1
void		iwi_tx_intr(struct iwi_softc *);
d132 2
a133 2
int		iwi_load_ucode(struct iwi_softc *, const char *);
int		iwi_load_firmware(struct iwi_softc *, const char *);
a213 3
	/* disable interrupts */
	CSR_WRITE_4(sc, IWI_CSR_INTR_MASK, 0);

d236 6
a241 2
	if (iwi_dma_alloc(sc) != 0) {
		printf(": could not allocate DMA resources\n");
d245 36
a280 2
	ic->ic_phytype = IEEE80211_T_OFDM;
	ic->ic_opmode = IEEE80211_M_STA;
d284 7
a290 3
	ic->ic_caps = IEEE80211_C_IBSS | IEEE80211_C_PMGT | IEEE80211_C_WEP |
	    IEEE80211_C_TXPMGT | IEEE80211_C_SHPREAMBLE | IEEE80211_C_MONITOR |
	    IEEE80211_C_SCANALL;
d371 8
d392 6
a397 1
	iwi_release(sc);
d433 1
a433 1
iwi_dma_alloc(struct iwi_softc *sc)
d435 4
a438 1
	int i, nsegs, error;
a439 3
	/*
	 * Allocate and map Tx ring.
	 */
d441 3
a443 3
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_SIZE, 1,
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_SIZE, 0, BUS_DMA_NOWAIT,
	    &sc->tx_ring_map);
d445 1
a445 1
		printf("%s: could not create tx ring DMA map\n",
d451 2
a452 2
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_SIZE, PAGE_SIZE, 0,
	    &sc->tx_ring_seg, 1, &nsegs, BUS_DMA_NOWAIT);
d454 1
a454 1
		printf("%s: could not allocate tx ring DMA memory\n",
d459 3
a461 3
	error = bus_dmamem_map(sc->sc_dmat, &sc->tx_ring_seg, nsegs,
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_SIZE,
	    (caddr_t *)&sc->tx_desc, BUS_DMA_NOWAIT);
d463 1
a463 1
		printf("%s: could not map tx ring DMA memory\n",
d468 2
a469 2
	error = bus_dmamap_load(sc->sc_dmat, sc->tx_ring_map, sc->tx_desc,
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_SIZE, NULL,
d472 1
a472 1
		printf("%s: could not load tx ring DMA map\n",
d477 39
a515 1
	bzero(sc->tx_desc, sizeof (struct iwi_tx_desc) * IWI_TX_RING_SIZE);
a516 3
	/*
	 * Allocate and map command ring.
	 */
d518 3
a520 3
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_SIZE, 1,
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_SIZE, 0,
	    BUS_DMA_NOWAIT, &sc->cmd_ring_map);
d522 1
a522 1
		printf("%s: could not create command ring DMA map\n",
d528 2
a529 2
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_SIZE, PAGE_SIZE, 0,
	    &sc->cmd_ring_seg, 1, &nsegs, BUS_DMA_NOWAIT);
d531 1
a531 1
		printf("%s: could not allocate command ring DMA memory\n",
d536 3
a538 3
	error = bus_dmamem_map(sc->sc_dmat, &sc->cmd_ring_seg, nsegs,
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_SIZE,
	    (caddr_t *)&sc->cmd_desc, BUS_DMA_NOWAIT);
d540 1
a540 1
		printf("%s: could not map command ring DMA memory\n",
d545 2
a546 2
	error = bus_dmamap_load(sc->sc_dmat, sc->cmd_ring_map, sc->cmd_desc,
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_SIZE, NULL,
d549 1
a549 1
		printf("%s: could not load command ring DMA map\n",
d554 4
a557 1
	bzero(sc->cmd_desc, sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_SIZE);
a558 4
	/*
	 * Allocate Tx buffers DMA maps.
	 */
	for (i = 0; i < IWI_TX_RING_SIZE; i++) {
d560 1
a560 2
		    IWI_MAX_NSEG - 2, MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &sc->tx_buf[i].map);
d562 1
a562 1
			printf("%s: could not create tx buf DMA map",
d568 63
a630 4
	/*
	 * Allocate and map Rx buffers.
	 */
	for (i = 0; i < IWI_RX_RING_SIZE; i++) {
d633 1
a633 1
		    0, BUS_DMA_NOWAIT, &sc->rx_buf[i].map);
d635 1
a635 1
			printf("%s: could not create rx buf DMA map",
d640 2
a641 2
		MGETHDR(sc->rx_buf[i].m, M_DONTWAIT, MT_DATA);
		if (sc->rx_buf[i].m == NULL) {
d648 4
a651 3
		MCLGET(sc->rx_buf[i].m, M_DONTWAIT);
		if (!(sc->rx_buf[i].m->m_flags & M_EXT)) {
			m_freem(sc->rx_buf[i].m);
d658 2
a659 3
		error = bus_dmamap_load(sc->sc_dmat, sc->rx_buf[i].map,
		    mtod(sc->rx_buf[i].m, void *), MCLBYTES, NULL,
		    BUS_DMA_NOWAIT);
d665 2
d671 1
a671 1
fail:	iwi_release(sc);
d676 1
a676 1
iwi_release(struct iwi_softc *sc)
d678 7
d687 2
a688 27
	if (sc->tx_ring_map != NULL) {
		if (sc->tx_desc != NULL) {
			bus_dmamap_unload(sc->sc_dmat, sc->tx_ring_map);
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->tx_desc,
			    sizeof (struct iwi_tx_desc) * IWI_TX_RING_SIZE);
			bus_dmamem_free(sc->sc_dmat, &sc->tx_ring_seg, 1);
		}
		bus_dmamap_destroy(sc->sc_dmat, sc->tx_ring_map);
	}

	if (sc->cmd_ring_map != NULL) {
		if (sc->cmd_desc != NULL) {
			bus_dmamap_unload(sc->sc_dmat, sc->cmd_ring_map);
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->cmd_desc,
			    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_SIZE);
			bus_dmamem_free(sc->sc_dmat, &sc->cmd_ring_seg, 1);
		}
		bus_dmamap_destroy(sc->sc_dmat, sc->cmd_ring_map);
	}

	for (i = 0; i < IWI_TX_RING_SIZE; i++) {
		if (sc->tx_buf[i].m != NULL) {
			bus_dmamap_unload(sc->sc_dmat, sc->tx_buf[i].map);
			m_freem(sc->tx_buf[i].m);
		}
		bus_dmamap_destroy(sc->sc_dmat, sc->tx_buf[i].map);
	}
d690 3
a692 4
	for (i = 0; i < IWI_RX_RING_SIZE; i++) {
		if (sc->rx_buf[i].m != NULL) {
			bus_dmamap_unload(sc->sc_dmat, sc->rx_buf[i].map);
			m_freem(sc->rx_buf[i].m);
d694 1
a694 1
		bus_dmamap_destroy(sc->sc_dmat, sc->rx_buf[i].map);
d907 1
a907 1
iwi_frame_intr(struct iwi_softc *sc, struct iwi_rx_buf *buf, int i,
d917 2
a918 2
	DPRINTFN(5, ("RX!DATA!%u!%u!%u\n", letoh16(frame->len), frame->chan,
	    frame->rssi_dbm));
d920 1
a920 1
	bus_dmamap_sync(sc->sc_dmat, buf->map, sizeof (struct iwi_hdr),
d950 1
a950 1
	bus_dmamap_unload(sc->sc_dmat, buf->map);
d952 1
a952 1
	error = bus_dmamap_load(sc->sc_dmat, buf->map, mtod(mnew, void *),
d958 2
a959 2
		error = bus_dmamap_load(sc->sc_dmat, buf->map,
		    mtod(buf->m, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
d969 3
a971 3
	m = buf->m;
	buf->m = mnew;
	CSR_WRITE_4(sc, IWI_CSR_RX_BASE + i * 4, buf->map->dm_segs->ds_addr);
d1024 1
d1029 1
a1029 1
iwi_notification_intr(struct iwi_softc *sc, struct iwi_rx_buf *buf,
d1039 1
a1039 1
	bus_dmamap_sync(sc->sc_dmat, buf->map, sizeof (struct iwi_hdr),
d1047 1
a1047 1
		DPRINTFN(2, ("Scan channel (%u)\n", chan->nchan));
d1115 1
a1115 1
	struct iwi_rx_buf *buf;
d1117 1
a1117 1
	uint32_t r, i;
d1119 1
a1119 1
	r = CSR_READ_4(sc, IWI_CSR_RX_READ_INDEX);
d1121 2
a1122 2
	for (i = (sc->rx_cur + 1) % IWI_RX_RING_SIZE; i != r;
	     i = (i + 1) % IWI_RX_RING_SIZE) {
d1124 1
a1124 3
		buf = &sc->rx_buf[i];

		bus_dmamap_sync(sc->sc_dmat, buf->map, 0,
d1127 1
a1127 1
		hdr = mtod(buf->m, struct iwi_hdr *);
d1131 1
a1131 1
			iwi_frame_intr(sc, buf, i,
d1136 1
a1136 1
			iwi_notification_intr(sc, buf,
d1144 2
d1149 2
a1150 2
	sc->rx_cur = (r == 0) ? IWI_RX_RING_SIZE - 1 : r - 1;
	CSR_WRITE_4(sc, IWI_CSR_RX_WRITE_INDEX, sc->rx_cur);
d1154 1
a1154 1
iwi_tx_intr(struct iwi_softc *sc)
d1158 2
a1159 2
	struct iwi_tx_buf *buf;
	uint32_t r, i;
d1161 1
a1161 1
	r = CSR_READ_4(sc, IWI_CSR_TX1_READ_INDEX);
d1163 2
a1164 2
	for (i = (sc->tx_old + 1) % IWI_TX_RING_SIZE; i != r;
	     i = (i + 1) % IWI_TX_RING_SIZE) {
d1166 5
a1170 7
		buf = &sc->tx_buf[i];

		bus_dmamap_unload(sc->sc_dmat, buf->map);
		m_freem(buf->m);
		buf->m = NULL;
		ieee80211_release_node(ic, buf->ni);
		buf->ni = NULL;
a1172 1
		sc->tx_queued--;
d1174 2
a1175 2
		/* kill watchdog timer */
		sc->sc_tx_timer = 0;
d1178 1
a1178 4
	/* remember what the firmware has processed */
	sc->tx_old = (r == 0) ? IWI_TX_RING_SIZE - 1 : r - 1;

	/* call start() since some buffer descriptors have been released */
d1195 2
a1196 1
	DPRINTFN(8, ("INTR!0x%08x\n", r));
d1201 1
d1212 1
d1215 8
a1222 2
	if (r & IWI_INTR_RX_TRANSFER)
		iwi_rx_intr(sc);
d1224 2
a1225 2
	if (r & IWI_INTR_CMD_TRANSFER)
		wakeup(sc);
d1227 2
a1228 2
	if (r & IWI_INTR_TX1_TRANSFER)
		iwi_tx_intr(sc);
d1230 2
a1231 2
	/* acknowledge interrupts */
	CSR_WRITE_4(sc, IWI_CSR_INTR, r);
d1244 1
a1244 3
	DPRINTFN(2, ("TX!CMD!%u!%u\n", type, len));

	desc = &sc->cmd_desc[sc->cmd_cur];
d1251 2
a1252 2
	bus_dmamap_sync(sc->sc_dmat, sc->cmd_ring_map,
	    sc->cmd_cur * sizeof (struct iwi_cmd_desc),
d1255 5
a1259 2
	sc->cmd_cur = (sc->cmd_cur + 1) % IWI_CMD_RING_SIZE;
	CSR_WRITE_4(sc, IWI_CSR_CMD_WRITE_INDEX, sc->cmd_cur);
d1269 1
a1269 1
	struct iwi_tx_buf *buf;
d1271 1
d1293 2
a1294 2
	buf = &sc->tx_buf[sc->tx_cur];
	desc = &sc->tx_desc[sc->tx_cur];
d1310 2
a1311 1
	error = bus_dmamap_load_mbuf(sc->sc_dmat, buf->map, m0, BUS_DMA_NOWAIT);
d1342 1
a1342 1
		error = bus_dmamap_load_mbuf(sc->sc_dmat, buf->map, m0,
d1352 2
a1353 2
	buf->m = m0;
	buf->ni = ni;
d1374 4
a1377 4
	desc->nseg = htole32(buf->map->dm_nsegs);
	for (i = 0; i < buf->map->dm_nsegs; i++) {
		desc->seg_addr[i] = htole32(buf->map->dm_segs[i].ds_addr);
		desc->seg_len[i]  = htole16(buf->map->dm_segs[i].ds_len);
d1380 2
a1381 2
	bus_dmamap_sync(sc->sc_dmat, sc->tx_ring_map,
	    sc->tx_cur * sizeof (struct iwi_tx_desc),
d1384 1
a1384 1
	bus_dmamap_sync(sc->sc_dmat, buf->map, 0, MCLBYTES,
d1387 2
a1388 1
	DPRINTFN(5, ("TX!DATA!%u!%u\n", letoh16(desc->len), desc->nseg));
d1390 3
a1392 4
	/* inform firmware about this new packet */
	sc->tx_queued++;
	sc->tx_cur = (sc->tx_cur + 1) % IWI_TX_RING_SIZE;
	CSR_WRITE_4(sc, IWI_CSR_TX1_WRITE_INDEX, sc->tx_cur);
d1413 1
a1413 1
		if (sc->tx_queued >= IWI_TX_RING_SIZE - 8) {
d1559 4
a1562 2
	if (ntries == 5)
		printf("%s: timeout waiting for master\n", sc->sc_dev.dv_xname);
a1580 1
	/* initialize phase-locked level (PLL) */
d1589 3
a1591 1
	if (ntries == 1000)
d1593 1
d1612 1
a1612 1
iwi_load_ucode(struct iwi_softc *sc, const char *name)
d1614 2
a1615 19
	u_char *uc, *data;
	size_t size;
	uint16_t *w;
	int error, ntries, i;

	if ((error = loadfirmware(name, &data, &size)) != 0) {
		printf("%s: could not read ucode %s, error %d\n",
		    sc->sc_dev.dv_xname, name, error);
		goto fail1;
	}

	if (size < sizeof (struct iwi_firmware_hdr)) {
		error = EINVAL;
		goto fail2;
	}

	uc = data;
	uc += sizeof (struct iwi_firmware_hdr);
	size -= sizeof (struct iwi_firmware_hdr);
d1625 3
a1627 3
		printf("%s: timeout waiting for master\n", sc->sc_dev.dv_xname);
		error = EIO;
		goto fail2;
d1632 1
d1635 1
d1645 1
d1648 1
a1648 1
	for (w = (uint16_t *)uc; size > 0; w++, size -= 2)
d1654 1
a1654 1
	/* wait until we get a response in the uc queue */
d1663 1
a1663 2
		error = EIO;
		goto fail2;
d1666 1
a1666 1
	/* empty the uc queue or the firmware will not initialize properly */
d1672 1
a1672 2
fail2:	free(data, M_DEVBUF);
fail1:	return error;
d1677 1
d1679 1
a1679 1
iwi_load_firmware(struct iwi_softc *sc, const char *name)
a1680 2
	u_char *fw, *data;
	size_t size;
a1687 15
	if ((error = loadfirmware(name, &data, &size)) != 0) {
		printf("%s: could not read firmware %s, error %d\n",
		    sc->sc_dev.dv_xname, name, error);
		goto fail1;
	}

	if (size < sizeof (struct iwi_firmware_hdr)) {
		error = EINVAL;
		goto fail2;
	}

	fw = data;
	fw += sizeof (struct iwi_firmware_hdr);
	size -= sizeof (struct iwi_firmware_hdr);

d1694 1
a1694 1
		goto fail2;
a1696 4
	/*
	 * We cannot map fw directly because of some hardware constraints on
	 * the mapping address.
	 */
d1702 1
a1702 1
		goto fail3;
d1710 1
a1710 1
		goto fail4;
d1718 1
a1718 1
		goto fail5;
d1722 1
a1722 1
	bcopy(fw, virtaddr, size);
d1735 1
a1735 1
	src = map->dm_segs->ds_addr;
d1782 1
a1782 1
		goto fail6;
d1793 1
d1801 1
a1801 1
		goto fail6;
d1804 1
a1804 1
fail6:	bus_dmamap_sync(sc->sc_dmat, map, 0, size, BUS_DMASYNC_POSTWRITE);
d1806 3
a1808 5
fail5:	bus_dmamem_unmap(sc->sc_dmat, virtaddr, size);
fail4:	bus_dmamem_free(sc->sc_dmat, &seg, 1);
fail3:	bus_dmamap_destroy(sc->sc_dmat, map);
fail2:	free(data, M_DEVBUF);

d1834 1
d1838 1
a1838 2
	error = iwi_cmd(sc, IWI_CMD_SET_CONFIGURATION, &config, sizeof config,
	    0);
d2022 1
d2028 2
a2029 2
		error = iwi_cmd(sc, IWI_CMD_SET_CONFIGURATION, &config,
		    sizeof config, 1);
d2099 4
a2102 1
	const char *ucode, *main;
d2107 1
a2107 7
		goto fail;
	}

	if ((error = iwi_load_firmware(sc, "iwi-boot")) != 0) {
		printf("%s: could not load boot firmware\n",
		    sc->sc_dev.dv_xname);
		goto fail;
d2113 1
a2113 2
		ucode = "iwi-ucode-bss";
		main = "iwi-bss";
a2114 1

d2117 1
a2117 2
		ucode = "iwi-ucode-ibss";
		main = "iwi-ibss";
a2118 1

d2120 1
a2120 2
		ucode = "iwi-ucode-monitor";
		main = "iwi-monitor";
d2122 30
d2154 3
a2156 1
	if ((error = iwi_load_ucode(sc, ucode)) != 0) {
d2158 1
a2158 1
		goto fail;
d2163 11
a2173 29
	sc->tx_cur = 0;
	sc->tx_queued = 0;
	sc->tx_old = IWI_TX_RING_SIZE - 1;
	sc->cmd_cur = 0;
	sc->rx_cur = IWI_RX_RING_SIZE - 1;

	CSR_WRITE_4(sc, IWI_CSR_CMD_BASE, sc->cmd_ring_map->dm_segs->ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_CMD_SIZE, IWI_CMD_RING_SIZE);
	CSR_WRITE_4(sc, IWI_CSR_CMD_WRITE_INDEX, sc->cmd_cur);

	CSR_WRITE_4(sc, IWI_CSR_TX1_BASE, sc->tx_ring_map->dm_segs->ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_TX1_SIZE, IWI_TX_RING_SIZE);
	CSR_WRITE_4(sc, IWI_CSR_TX1_WRITE_INDEX, sc->tx_cur);

	CSR_WRITE_4(sc, IWI_CSR_TX2_BASE, sc->tx_ring_map->dm_segs->ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_TX2_SIZE, IWI_TX_RING_SIZE);
	CSR_WRITE_4(sc, IWI_CSR_TX2_WRITE_INDEX, sc->tx_cur);

	CSR_WRITE_4(sc, IWI_CSR_TX3_BASE, sc->tx_ring_map->dm_segs->ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_TX3_SIZE, IWI_TX_RING_SIZE);
	CSR_WRITE_4(sc, IWI_CSR_TX3_WRITE_INDEX, sc->tx_cur);

	CSR_WRITE_4(sc, IWI_CSR_TX4_BASE, sc->tx_ring_map->dm_segs->ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_TX4_SIZE, IWI_TX_RING_SIZE);
	CSR_WRITE_4(sc, IWI_CSR_TX4_WRITE_INDEX, sc->tx_cur);

	for (i = 0; i < IWI_RX_RING_SIZE; i++)
		CSR_WRITE_4(sc, IWI_CSR_RX_BASE + i * 4,
		    sc->rx_buf[i].map->dm_segs->ds_addr);
d2175 12
a2186 1
	CSR_WRITE_4(sc, IWI_CSR_RX_WRITE_INDEX, sc->rx_cur);
d2188 5
a2192 1
	if ((error = iwi_load_firmware(sc, main)) != 0) {
d2195 1
a2195 1
		goto fail;
d2198 1
d2204 1
a2204 1
		goto fail;
d2217 2
a2218 2
fail:	iwi_stop(ifp, 0);

a2226 2
	struct iwi_tx_buf *buf;
	int i;
d2235 1
d2238 7
a2244 13
	/*
	 * Release Tx buffers.
	 */
	for (i = 0; i < IWI_TX_RING_SIZE; i++) {
		buf = &sc->tx_buf[i];

		if (buf->m != NULL) {
			bus_dmamap_unload(sc->sc_dmat, buf->map);
			m_freem(buf->m);
			buf->m = NULL;
		}
		buf->ni = NULL;
	}
@


1.62
log
@- complete rework of rings allocation (do things more like ral(4))
- upgrade to firmware v3.0 layout
- enable s/w antenna diversity
- many code cleanup
@
text
@d100 2
a101 10
int		iwi_alloc_cmd_ring(struct iwi_softc *, struct iwi_cmd_ring *);
void		iwi_reset_cmd_ring(struct iwi_softc *, struct iwi_cmd_ring *);
void		iwi_free_cmd_ring(struct iwi_softc *, struct iwi_cmd_ring *);
int		iwi_alloc_tx_ring(struct iwi_softc *, struct iwi_tx_ring *,
		    bus_addr_t, bus_addr_t);
void		iwi_reset_tx_ring(struct iwi_softc *, struct iwi_tx_ring *);
void		iwi_free_tx_ring(struct iwi_softc *, struct iwi_tx_ring *);
int		iwi_alloc_rx_ring(struct iwi_softc *, struct iwi_rx_ring *);
void		iwi_reset_rx_ring(struct iwi_softc *, struct iwi_rx_ring *);
void		iwi_free_rx_ring(struct iwi_softc *, struct iwi_rx_ring *);
d107 1
a107 1
void		iwi_frame_intr(struct iwi_softc *, struct iwi_rx_data *,
d109 1
a109 1
void		iwi_notification_intr(struct iwi_softc *, struct iwi_rx_data *,
d112 1
a112 1
void		iwi_tx_intr(struct iwi_softc *, struct iwi_tx_ring *);
d124 2
a125 2
int		iwi_load_ucode(struct iwi_softc *, const char *, int);
int		iwi_load_firmware(struct iwi_softc *, const char *, int);
d206 3
d231 2
a232 6
	/*
	 * Allocate rings.
	 */
	error = iwi_alloc_cmd_ring(sc, &sc->cmdq);
	if (error != 0) {
		printf(": could not allocate Cmd ring\n");
d236 2
a237 36
	error = iwi_alloc_tx_ring(sc, &sc->txq[0], IWI_CSR_TX1_RIDX,
	    IWI_CSR_TX1_WIDX);
	if (error != 0) {
		printf(": could not allocate Tx ring 1\n");
		goto fail1;
	}

	error = iwi_alloc_tx_ring(sc, &sc->txq[1], IWI_CSR_TX2_RIDX,
	    IWI_CSR_TX2_WIDX);
	if (error != 0) {
		printf(": could not allocate Tx ring 2\n");
		goto fail2;
	}

	error = iwi_alloc_tx_ring(sc, &sc->txq[2], IWI_CSR_TX3_RIDX,
	    IWI_CSR_TX3_WIDX);
	if (error != 0) {
		printf(": could not allocate Tx ring 3\n");
		goto fail3;
	}

	error = iwi_alloc_tx_ring(sc, &sc->txq[3], IWI_CSR_TX4_RIDX,
	    IWI_CSR_TX4_WIDX);
	if (error != 0) {
		printf(": could not allocate Tx ring 4\n");
		goto fail4;
	}

	error = iwi_alloc_rx_ring(sc, &sc->rxq);
	if (error != 0) {
		printf(": could not allocate Rx ring\n");
		goto fail5;
	}

	ic->ic_phytype = IEEE80211_T_OFDM;	/* not only, but not used */
	ic->ic_opmode = IEEE80211_M_STA;	/* default to BSS mode */
d241 3
a243 7
	ic->ic_caps =
	    IEEE80211_C_IBSS |		/* IBSS mode supported */
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
	    IEEE80211_C_WEP |		/* h/w WEP supported */
	    IEEE80211_C_TXPMGT |	/* tx power management */
	    IEEE80211_C_SHPREAMBLE |	/* short preamble supported */
	    IEEE80211_C_SCANALL;	/* h/w scanning */
a323 8

	return;

fail5:	iwi_free_tx_ring(sc, &sc->txq[3]);
fail4:	iwi_free_tx_ring(sc, &sc->txq[2]);
fail3:	iwi_free_tx_ring(sc, &sc->txq[1]);
fail2:	iwi_free_tx_ring(sc, &sc->txq[0]);
fail1:	iwi_free_cmd_ring(sc, &sc->cmdq);
d337 1
a337 6
	iwi_free_cmd_ring(sc, &sc->cmdq);
	iwi_free_tx_ring(sc, &sc->txq[0]);
	iwi_free_tx_ring(sc, &sc->txq[1]);
	iwi_free_tx_ring(sc, &sc->txq[2]);
	iwi_free_tx_ring(sc, &sc->txq[3]);
	iwi_free_rx_ring(sc, &sc->rxq);
d373 1
a373 1
iwi_alloc_cmd_ring(struct iwi_softc *sc, struct iwi_cmd_ring *ring)
d375 1
a375 4
	int nsegs, error;

	ring->queued = 0;
	ring->cur = ring->next = 0;
d377 3
d381 3
a383 3
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_COUNT, 1,
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_COUNT, 0,
	    BUS_DMA_NOWAIT, &ring->map);
d385 1
a385 1
		printf("%s: could not create cmd ring DMA map\n",
d391 2
a392 2
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_COUNT, PAGE_SIZE, 0,
	    &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT);
d394 1
a394 1
		printf("%s: could not allocate cmd ring DMA memory\n",
d399 3
a401 3
	error = bus_dmamem_map(sc->sc_dmat, &ring->seg, nsegs,
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_COUNT,
	    (caddr_t *)&ring->desc, BUS_DMA_NOWAIT);
d403 1
a403 1
		printf("%s: could not map cmd ring DMA memory\n",
d408 2
a409 2
	error = bus_dmamap_load(sc->sc_dmat, ring->map, ring->desc,
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_COUNT, NULL,
d412 1
a412 1
		printf("%s: could not load cmd ring DMA map\n",
d417 1
a417 39
	bzero(ring->desc, sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_COUNT);
	return 0;

fail:	iwi_free_cmd_ring(sc, ring);
	return error;
}

void
iwi_reset_cmd_ring(struct iwi_softc *sc, struct iwi_cmd_ring *ring)
{
	ring->queued = 0;
	ring->cur = ring->next = 0;
}

void
iwi_free_cmd_ring(struct iwi_softc *sc, struct iwi_cmd_ring *ring)
{
	if (ring->map != NULL) {
		if (ring->desc != NULL) {
			bus_dmamap_unload(sc->sc_dmat, ring->map);
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)ring->desc,
			    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_COUNT);
			bus_dmamem_free(sc->sc_dmat, &ring->seg, 1);
		}
		bus_dmamap_destroy(sc->sc_dmat, ring->map);
	}
}

int
iwi_alloc_tx_ring(struct iwi_softc *sc, struct iwi_tx_ring *ring,
    bus_addr_t csr_ridx, bus_addr_t csr_widx)
{
	struct iwi_tx_data *data;
	int i, nsegs, error;

	ring->queued = 0;
	ring->cur = ring->next = 0;
	ring->csr_ridx = csr_ridx;
	ring->csr_widx = csr_widx;
d419 3
d423 3
a425 3
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_COUNT, 1,
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_COUNT, 0, BUS_DMA_NOWAIT,
	    &ring->map);
d427 1
a427 1
		printf("%s: could not create tx ring DMA map\n",
d433 2
a434 2
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_COUNT, PAGE_SIZE, 0,
	    &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT);
d436 1
a436 1
		printf("%s: could not allocate tx ring DMA memory\n",
d441 3
a443 3
	error = bus_dmamem_map(sc->sc_dmat, &ring->seg, nsegs,
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_COUNT,
	    (caddr_t *)&ring->desc, BUS_DMA_NOWAIT);
d445 1
a445 1
		printf("%s: could not map tx ring DMA memory\n",
d450 2
a451 2
	error = bus_dmamap_load(sc->sc_dmat, ring->map, ring->desc,
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_COUNT, NULL,
d454 1
a454 1
		printf("%s: could not load tx ring DMA map\n",
d459 1
a459 4
	bzero(ring->desc, sizeof (struct iwi_tx_desc) * IWI_TX_RING_COUNT);

	for (i = 0; i < IWI_TX_RING_COUNT; i++) {
		data = &ring->data[i];
d461 4
d466 2
a467 1
		    IWI_MAX_SCATTER, MCLBYTES, 0, BUS_DMA_NOWAIT, &data->map);
d469 1
a469 1
			printf("%s: could not create tx buf DMA map\n",
d475 4
a478 63
	return 0;

fail:	iwi_free_tx_ring(sc, ring);
	return error;
}

void
iwi_reset_tx_ring(struct iwi_softc *sc, struct iwi_tx_ring *ring)
{
	struct iwi_tx_data *data;
	int i;

	for (i = 0; i < IWI_TX_RING_COUNT; i++) {
		data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
			data->m = NULL;
		}
	}

	ring->queued = 0;
	ring->cur = ring->next = 0;
}

void
iwi_free_tx_ring(struct iwi_softc *sc, struct iwi_tx_ring *ring)
{
	struct iwi_tx_data *data;
	int i;

	if (ring->map != NULL) {
		if (ring->desc != NULL) {
			bus_dmamap_unload(sc->sc_dmat, ring->map);
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)ring->desc,
			    sizeof (struct iwi_tx_desc) * IWI_TX_RING_COUNT);
			bus_dmamem_free(sc->sc_dmat, &ring->seg, 1);
		}
		bus_dmamap_destroy(sc->sc_dmat, ring->map);
	}

	for (i = 0; i < IWI_TX_RING_COUNT; i++) {
		data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
		}
		bus_dmamap_destroy(sc->sc_dmat, data->map);
	}
}

int
iwi_alloc_rx_ring(struct iwi_softc *sc, struct iwi_rx_ring *ring)
{
	struct iwi_rx_data *data;
	int i, error;

	ring->cur = 0;

	for (i = 0; i < IWI_RX_RING_COUNT; i++) {
		data = &sc->rxq.data[i];
d481 1
a481 1
		    0, BUS_DMA_NOWAIT, &data->map);
d483 1
a483 1
			printf("%s: could not create rx buf DMA map\n",
d488 2
a489 2
		MGETHDR(data->m, M_DONTWAIT, MT_DATA);
		if (data->m == NULL) {
d496 3
a498 4
		MCLGET(data->m, M_DONTWAIT);
		if (!(data->m->m_flags & M_EXT)) {
			m_freem(data->m);
			data->m = NULL;
d505 3
a507 2
		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(data->m, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
a512 2

		data->reg = IWI_CSR_RX_BASE + i * 4;
d517 1
a517 1
fail:	iwi_free_rx_ring(sc, ring);
d522 1
a522 1
iwi_reset_rx_ring(struct iwi_softc *sc, struct iwi_rx_ring *ring)
d524 11
a534 2
	ring->cur = 0;
}
d536 9
a544 5
void
iwi_free_rx_ring(struct iwi_softc *sc, struct iwi_rx_ring *ring)
{
	struct iwi_rx_data *data;
	int i;
d546 7
a552 2
	for (i = 0; i < IWI_RX_RING_COUNT; i++) {
		data = &sc->rxq.data[i];
d554 4
a557 3
		if (data->m != NULL) {
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
d559 1
a559 1
		bus_dmamap_destroy(sc->sc_dmat, data->map);
d772 1
a772 1
iwi_frame_intr(struct iwi_softc *sc, struct iwi_rx_data *data,
d782 2
a783 2
	DPRINTFN(5, ("received frame len=%u chan=%u rssi=%u\n",
	    letoh16(frame->len), frame->chan, frame->rssi_dbm));
d785 1
a785 1
	bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (struct iwi_hdr),
d815 1
a815 1
	bus_dmamap_unload(sc->sc_dmat, data->map);
d817 1
a817 1
	error = bus_dmamap_load(sc->sc_dmat, data->map, mtod(mnew, void *),
d823 2
a824 2
		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(data->m, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
d834 3
a836 3
	m = data->m;
	data->m = mnew;
	CSR_WRITE_4(sc, data->reg, data->map->dm_segs[0].ds_addr);
a888 1
	/* node is no longer needed */
d893 1
a893 1
iwi_notification_intr(struct iwi_softc *sc, struct iwi_rx_data *data,
d903 1
a903 1
	bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (struct iwi_hdr),
d911 1
a911 1
		DPRINTFN(2, ("Scanning channel (%u)\n", chan->nchan));
d979 1
a979 1
	struct iwi_rx_data *data;
d981 1
a981 1
	uint32_t hw;
d983 1
a983 1
	hw = CSR_READ_4(sc, IWI_CSR_RX_RIDX);
d985 2
a986 2
	for (; sc->rxq.cur != hw;) {
		data = &sc->rxq.data[sc->rxq.cur];
d988 3
a990 1
		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
d993 1
a993 1
		hdr = mtod(data->m, struct iwi_hdr *);
d997 1
a997 1
			iwi_frame_intr(sc, data,
d1002 1
a1002 1
			iwi_notification_intr(sc, data,
a1009 2

		sc->rxq.cur = (sc->rxq.cur + 1) % IWI_RX_RING_COUNT;
d1013 2
a1014 2
	hw = (hw == 0) ? IWI_RX_RING_COUNT - 1 : hw - 1;
	CSR_WRITE_4(sc, IWI_CSR_RX_WIDX, hw);
d1018 1
a1018 1
iwi_tx_intr(struct iwi_softc *sc, struct iwi_tx_ring *txq)
d1022 2
a1023 2
	struct iwi_tx_data *data;
	uint32_t hw;
d1025 1
a1025 1
	hw = CSR_READ_4(sc, txq->csr_ridx);
d1027 2
a1028 2
	for (; txq->next != hw;) {
		data = &txq->data[txq->next];
d1030 7
a1036 5
		bus_dmamap_unload(sc->sc_dmat, data->map);
		m_freem(data->m);
		data->m = NULL;
		ieee80211_release_node(ic, data->ni);
		data->ni = NULL;
d1039 1
d1041 2
a1042 2
		txq->queued--;
		txq->next = (txq->next + 1) % IWI_TX_RING_COUNT;
d1045 4
a1048 1
	sc->sc_tx_timer = 0;
d1065 1
a1065 2
	/* acknowledge interrupts */
	CSR_WRITE_4(sc, IWI_CSR_INTR, r);
a1069 1
		r = 0;	/* don't process more interrupts */
a1079 1
		r = 0;	/* don't process more interrupts */
d1082 4
a1085 1
	if (r & IWI_INTR_CMD_DONE)
d1088 2
a1089 2
	if (r & IWI_INTR_TX1_DONE)
		iwi_tx_intr(sc, &sc->txq[0]);
d1091 2
a1092 11
	if (r & IWI_INTR_TX2_DONE)
		iwi_tx_intr(sc, &sc->txq[1]);

	if (r & IWI_INTR_TX3_DONE)
		iwi_tx_intr(sc, &sc->txq[2]);

	if (r & IWI_INTR_TX4_DONE)
		iwi_tx_intr(sc, &sc->txq[3]);

	if (r & IWI_INTR_RX_DONE)
		iwi_rx_intr(sc);
d1105 3
a1107 1
	desc = &sc->cmdq.desc[sc->cmdq.cur];
d1114 2
a1115 2
	bus_dmamap_sync(sc->sc_dmat, sc->cmdq.map,
	    sc->cmdq.cur * sizeof (struct iwi_cmd_desc),
d1118 2
a1119 5
	DPRINTFN(2, ("sending command idx=%u type=%u len=%u\n", sc->cmdq.cur,
	    type, len));

	sc->cmdq.cur = (sc->cmdq.cur + 1) % IWI_CMD_RING_COUNT;
	CSR_WRITE_4(sc, IWI_CSR_CMD_WIDX, sc->cmdq.cur);
d1129 1
a1129 1
	struct iwi_tx_data *data;
a1130 1
	struct iwi_tx_ring *txq = &sc->txq[0];
d1152 2
a1153 2
	data = &txq->data[txq->cur];
	desc = &txq->desc[txq->cur];
d1169 1
a1169 2
	error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
	    BUS_DMA_NOWAIT);
d1200 1
a1200 1
		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
d1210 2
a1211 2
	data->m = m0;
	data->ni = ni;
d1232 4
a1235 4
	desc->nseg = htole32(data->map->dm_nsegs);
	for (i = 0; i < data->map->dm_nsegs; i++) {
		desc->seg_addr[i] = htole32(data->map->dm_segs[i].ds_addr);
		desc->seg_len[i]  = htole16(data->map->dm_segs[i].ds_len);
d1238 2
a1239 2
	bus_dmamap_sync(sc->sc_dmat, txq->map,
	    txq->cur * sizeof (struct iwi_tx_desc),
d1242 1
a1242 1
	bus_dmamap_sync(sc->sc_dmat, data->map, 0, MCLBYTES,
d1245 1
a1245 2
	DPRINTFN(5, ("sending data frame idx=%u len=%u nseg=%u\n", txq->cur,
	    letoh16(desc->len), data->map->dm_nsegs));
d1247 4
a1250 3
	txq->queued++;
	txq->cur = (txq->cur + 1) % IWI_TX_RING_COUNT;
	CSR_WRITE_4(sc, txq->csr_widx, txq->cur);
d1271 1
a1271 1
		if (sc->txq[0].queued >= IWI_TX_RING_COUNT - 8) {
d1417 2
a1418 4
	if (ntries == 5) {
		printf("%s: timeout waiting for master\n",
		    sc->sc_dev.dv_xname);
	}
d1437 1
d1446 1
a1446 3
	if (ntries == 1000) {
		printf("%s: timeout waiting for clock stabilization\n",
		    sc->sc_dev.dv_xname);
a1447 1
	}
d1466 1
a1466 1
iwi_load_ucode(struct iwi_softc *sc, const char *data, int size)
d1468 19
a1486 2
	const uint16_t *w;
	int ntries, i;
d1496 3
a1498 3
		printf("%s: timeout waiting for master\n",
		    sc->sc_dev.dv_xname);
		return EIO;
a1502 1

a1504 1

a1513 1
	DELAY(1000);
d1516 1
a1516 1
	for (w = (const uint16_t *)data; size > 0; w++, size -= 2)
d1522 1
a1522 1
	/* wait until we get an answer */
d1531 2
a1532 1
		return EIO;
d1535 1
a1535 1
	/* read the answer or the firmware will not initialize properly */
d1541 2
a1542 1
	return 0;
a1546 1

d1548 1
a1548 1
iwi_load_firmware(struct iwi_softc *sc, const char *data, int size)
d1550 2
d1559 15
d1580 1
a1580 1
		goto fail1;
d1583 4
d1592 1
a1592 1
		goto fail2;
d1600 1
a1600 1
		goto fail3;
d1608 1
a1608 1
		goto fail4;
d1612 1
a1612 1
	bcopy(data, virtaddr, size);
d1625 1
a1625 1
	src = map->dm_segs[0].ds_addr;
d1672 1
a1672 1
		goto fail5;
a1682 1

d1690 1
a1690 1
		goto fail5;
d1693 1
a1693 1
fail5:	bus_dmamap_sync(sc->sc_dmat, map, 0, size, BUS_DMASYNC_POSTWRITE);
d1695 5
a1699 3
fail4:	bus_dmamem_unmap(sc->sc_dmat, virtaddr, size);
fail3:	bus_dmamem_free(sc->sc_dmat, &seg, 1);
fail2:	bus_dmamap_destroy(sc->sc_dmat, map);
a1724 1
	config.antenna = 2;	/* antenna diversity */
d1728 2
a1729 1
	error = iwi_cmd(sc, IWI_CMD_SET_CONFIG, &config, sizeof config, 0);
a1912 1
		config.antenna = 2;	/* antenna diversity */
d1918 2
a1919 2
		error = iwi_cmd(sc, IWI_CMD_SET_CONFIG, &config, sizeof config,
		    1);
d1989 1
a1989 4
	struct iwi_firmware_hdr *hdr;
	const char *name, *fw;
	u_char *data;
	size_t size;
d1994 7
a2000 1
		goto fail1;
d2006 2
a2007 1
		name = "iwi-bss";
d2009 1
d2012 2
a2013 1
		name = "iwi-ibss";
d2015 1
d2017 2
a2018 1
		name = "iwi-monitor";
a2019 30
	default:
		name = NULL;	/* should not get there */
	}

	if ((error = loadfirmware(name, &data, &size)) != 0) {
		printf("%s: could not read firmware %s\n",
		    sc->sc_dev.dv_xname, name);
		goto fail1;
	}

	if (size < sizeof (struct iwi_firmware_hdr)) {
		printf("%s: firmware image too short: %zu bytes\n",
		    sc->sc_dev.dv_xname, size);
		goto fail2;
	}

	hdr = (struct iwi_firmware_hdr *)data;

	if (size < sizeof (struct iwi_firmware_hdr) + letoh32(hdr->bootsz) +
	    letoh32(hdr->ucodesz) + letoh32(hdr->mainsz)) {
		printf("%s: firmware image too short: %zu bytes\n",
		    sc->sc_dev.dv_xname, size);
		goto fail2;
	}

	fw = (const char *)data + sizeof (struct iwi_firmware_hdr);
	if ((error = iwi_load_firmware(sc, fw, letoh32(hdr->bootsz))) != 0) {
		printf("%s: could not load boot firmware\n",
		    sc->sc_dev.dv_xname);
		goto fail2;
d2022 1
a2022 3
	fw = (const char *)data + sizeof (struct iwi_firmware_hdr) +
	    letoh32(hdr->bootsz);
	if ((error = iwi_load_ucode(sc, fw, letoh32(hdr->ucodesz))) != 0) {
d2024 1
a2024 1
		goto fail2;
d2029 29
a2057 11
	CSR_WRITE_4(sc, IWI_CSR_CMD_BASE, sc->cmdq.map->dm_segs[0].ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_CMD_SIZE, IWI_CMD_RING_COUNT);
	CSR_WRITE_4(sc, IWI_CSR_CMD_WIDX, sc->cmdq.cur);

	CSR_WRITE_4(sc, IWI_CSR_TX1_BASE, sc->txq[0].map->dm_segs[0].ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_TX1_SIZE, IWI_TX_RING_COUNT);
	CSR_WRITE_4(sc, IWI_CSR_TX1_WIDX, sc->txq[0].cur);

	CSR_WRITE_4(sc, IWI_CSR_TX2_BASE, sc->txq[1].map->dm_segs[0].ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_TX2_SIZE, IWI_TX_RING_COUNT);
	CSR_WRITE_4(sc, IWI_CSR_TX2_WIDX, sc->txq[1].cur);
d2059 1
a2059 12
	CSR_WRITE_4(sc, IWI_CSR_TX3_BASE, sc->txq[2].map->dm_segs[0].ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_TX3_SIZE, IWI_TX_RING_COUNT);
	CSR_WRITE_4(sc, IWI_CSR_TX3_WIDX, sc->txq[2].cur);

	CSR_WRITE_4(sc, IWI_CSR_TX4_BASE, sc->txq[3].map->dm_segs[0].ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_TX4_SIZE, IWI_TX_RING_COUNT);
	CSR_WRITE_4(sc, IWI_CSR_TX4_WIDX, sc->txq[3].cur);

	for (i = 0; i < IWI_RX_RING_COUNT; i++) {
		struct iwi_rx_data *data = &sc->rxq.data[i];
		CSR_WRITE_4(sc, data->reg, data->map->dm_segs[0].ds_addr);
	}
d2061 1
a2061 5
	CSR_WRITE_4(sc, IWI_CSR_RX_WIDX, IWI_RX_RING_COUNT - 1);

	fw = (const char *)data + sizeof (struct iwi_firmware_hdr) +
	    letoh32(hdr->bootsz) + letoh32(hdr->ucodesz);
	if ((error = iwi_load_firmware(sc, fw, letoh32(hdr->mainsz))) != 0) {
d2064 1
a2064 1
		goto fail2;
a2066 1
	free(data, M_DEVBUF);
d2072 1
a2072 1
		goto fail1;
d2085 2
a2086 2
fail2:	free(data, M_DEVBUF);
fail1:	iwi_stop(ifp, 0);
d2095 2
d2105 1
d2107 5
a2111 1
	CSR_WRITE_4(sc, IWI_CSR_RST, IWI_RST_SW_RESET);
d2113 7
a2119 7
	/* reset rings */
	iwi_reset_cmd_ring(sc, &sc->cmdq);
	iwi_reset_tx_ring(sc, &sc->txq[0]);
	iwi_reset_tx_ring(sc, &sc->txq[1]);
	iwi_reset_tx_ring(sc, &sc->txq[2]);
	iwi_reset_tx_ring(sc, &sc->txq[3]);
	iwi_reset_rx_ring(sc, &sc->rxq);
@


1.61
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.60 2006/02/26 19:14:40 damien Exp $	*/
d100 10
a109 2
int		iwi_dma_alloc(struct iwi_softc *);
void		iwi_release(struct iwi_softc *);
d115 1
a115 1
void		iwi_frame_intr(struct iwi_softc *, struct iwi_rx_buf *, int,
d117 1
a117 1
void		iwi_notification_intr(struct iwi_softc *, struct iwi_rx_buf *,
d120 1
a120 1
void		iwi_tx_intr(struct iwi_softc *);
d132 2
a133 2
int		iwi_load_ucode(struct iwi_softc *, const char *);
int		iwi_load_firmware(struct iwi_softc *, const char *);
a213 3
	/* disable interrupts */
	CSR_WRITE_4(sc, IWI_CSR_INTR_MASK, 0);

d236 6
a241 2
	if (iwi_dma_alloc(sc) != 0) {
		printf(": could not allocate DMA resources\n");
d245 36
a280 2
	ic->ic_phytype = IEEE80211_T_OFDM;
	ic->ic_opmode = IEEE80211_M_STA;
d284 7
a290 3
	ic->ic_caps = IEEE80211_C_IBSS | IEEE80211_C_PMGT | IEEE80211_C_WEP |
	    IEEE80211_C_TXPMGT | IEEE80211_C_SHPREAMBLE | IEEE80211_C_MONITOR |
	    IEEE80211_C_SCANALL;
d371 8
d392 6
a397 1
	iwi_release(sc);
d433 1
a433 1
iwi_dma_alloc(struct iwi_softc *sc)
d435 4
a438 1
	int i, nsegs, error;
a439 3
	/*
	 * Allocate and map Tx ring.
	 */
d441 3
a443 3
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_SIZE, 1,
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_SIZE, 0, BUS_DMA_NOWAIT,
	    &sc->tx_ring_map);
d445 1
a445 1
		printf("%s: could not create tx ring DMA map\n",
d451 2
a452 2
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_SIZE, PAGE_SIZE, 0,
	    &sc->tx_ring_seg, 1, &nsegs, BUS_DMA_NOWAIT);
d454 1
a454 1
		printf("%s: could not allocate tx ring DMA memory\n",
d459 3
a461 3
	error = bus_dmamem_map(sc->sc_dmat, &sc->tx_ring_seg, nsegs,
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_SIZE,
	    (caddr_t *)&sc->tx_desc, BUS_DMA_NOWAIT);
d463 1
a463 1
		printf("%s: could not map tx ring DMA memory\n",
d468 2
a469 2
	error = bus_dmamap_load(sc->sc_dmat, sc->tx_ring_map, sc->tx_desc,
	    sizeof (struct iwi_tx_desc) * IWI_TX_RING_SIZE, NULL,
d472 1
a472 1
		printf("%s: could not load tx ring DMA map\n",
d477 39
a515 1
	bzero(sc->tx_desc, sizeof (struct iwi_tx_desc) * IWI_TX_RING_SIZE);
a516 3
	/*
	 * Allocate and map command ring.
	 */
d518 3
a520 3
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_SIZE, 1,
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_SIZE, 0,
	    BUS_DMA_NOWAIT, &sc->cmd_ring_map);
d522 1
a522 1
		printf("%s: could not create command ring DMA map\n",
d528 2
a529 2
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_SIZE, PAGE_SIZE, 0,
	    &sc->cmd_ring_seg, 1, &nsegs, BUS_DMA_NOWAIT);
d531 1
a531 1
		printf("%s: could not allocate command ring DMA memory\n",
d536 3
a538 3
	error = bus_dmamem_map(sc->sc_dmat, &sc->cmd_ring_seg, nsegs,
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_SIZE,
	    (caddr_t *)&sc->cmd_desc, BUS_DMA_NOWAIT);
d540 1
a540 1
		printf("%s: could not map command ring DMA memory\n",
d545 2
a546 2
	error = bus_dmamap_load(sc->sc_dmat, sc->cmd_ring_map, sc->cmd_desc,
	    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_SIZE, NULL,
d549 1
a549 1
		printf("%s: could not load command ring DMA map\n",
d554 4
a557 1
	bzero(sc->cmd_desc, sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_SIZE);
a558 4
	/*
	 * Allocate Tx buffers DMA maps.
	 */
	for (i = 0; i < IWI_TX_RING_SIZE; i++) {
d560 1
a560 2
		    IWI_MAX_NSEG - 2, MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &sc->tx_buf[i].map);
d562 1
a562 1
			printf("%s: could not create tx buf DMA map",
d568 63
a630 4
	/*
	 * Allocate and map Rx buffers.
	 */
	for (i = 0; i < IWI_RX_RING_SIZE; i++) {
d633 1
a633 1
		    0, BUS_DMA_NOWAIT, &sc->rx_buf[i].map);
d635 1
a635 1
			printf("%s: could not create rx buf DMA map",
d640 2
a641 2
		MGETHDR(sc->rx_buf[i].m, M_DONTWAIT, MT_DATA);
		if (sc->rx_buf[i].m == NULL) {
d648 4
a651 3
		MCLGET(sc->rx_buf[i].m, M_DONTWAIT);
		if (!(sc->rx_buf[i].m->m_flags & M_EXT)) {
			m_freem(sc->rx_buf[i].m);
d658 2
a659 3
		error = bus_dmamap_load(sc->sc_dmat, sc->rx_buf[i].map,
		    mtod(sc->rx_buf[i].m, void *), MCLBYTES, NULL,
		    BUS_DMA_NOWAIT);
d665 2
d671 1
a671 1
fail:	iwi_release(sc);
d676 1
a676 1
iwi_release(struct iwi_softc *sc)
d678 7
d687 2
a688 27
	if (sc->tx_ring_map != NULL) {
		if (sc->tx_desc != NULL) {
			bus_dmamap_unload(sc->sc_dmat, sc->tx_ring_map);
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->tx_desc,
			    sizeof (struct iwi_tx_desc) * IWI_TX_RING_SIZE);
			bus_dmamem_free(sc->sc_dmat, &sc->tx_ring_seg, 1);
		}
		bus_dmamap_destroy(sc->sc_dmat, sc->tx_ring_map);
	}

	if (sc->cmd_ring_map != NULL) {
		if (sc->cmd_desc != NULL) {
			bus_dmamap_unload(sc->sc_dmat, sc->cmd_ring_map);
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->cmd_desc,
			    sizeof (struct iwi_cmd_desc) * IWI_CMD_RING_SIZE);
			bus_dmamem_free(sc->sc_dmat, &sc->cmd_ring_seg, 1);
		}
		bus_dmamap_destroy(sc->sc_dmat, sc->cmd_ring_map);
	}

	for (i = 0; i < IWI_TX_RING_SIZE; i++) {
		if (sc->tx_buf[i].m != NULL) {
			bus_dmamap_unload(sc->sc_dmat, sc->tx_buf[i].map);
			m_freem(sc->tx_buf[i].m);
		}
		bus_dmamap_destroy(sc->sc_dmat, sc->tx_buf[i].map);
	}
d690 3
a692 4
	for (i = 0; i < IWI_RX_RING_SIZE; i++) {
		if (sc->rx_buf[i].m != NULL) {
			bus_dmamap_unload(sc->sc_dmat, sc->rx_buf[i].map);
			m_freem(sc->rx_buf[i].m);
d694 1
a694 1
		bus_dmamap_destroy(sc->sc_dmat, sc->rx_buf[i].map);
d907 1
a907 1
iwi_frame_intr(struct iwi_softc *sc, struct iwi_rx_buf *buf, int i,
d917 2
a918 2
	DPRINTFN(5, ("RX!DATA!%u!%u!%u\n", letoh16(frame->len), frame->chan,
	    frame->rssi_dbm));
d920 1
a920 1
	bus_dmamap_sync(sc->sc_dmat, buf->map, sizeof (struct iwi_hdr),
d950 1
a950 1
	bus_dmamap_unload(sc->sc_dmat, buf->map);
d952 1
a952 1
	error = bus_dmamap_load(sc->sc_dmat, buf->map, mtod(mnew, void *),
d958 2
a959 2
		error = bus_dmamap_load(sc->sc_dmat, buf->map,
		    mtod(buf->m, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
d969 3
a971 3
	m = buf->m;
	buf->m = mnew;
	CSR_WRITE_4(sc, IWI_CSR_RX_BASE + i * 4, buf->map->dm_segs->ds_addr);
d1024 1
d1029 1
a1029 1
iwi_notification_intr(struct iwi_softc *sc, struct iwi_rx_buf *buf,
d1039 1
a1039 1
	bus_dmamap_sync(sc->sc_dmat, buf->map, sizeof (struct iwi_hdr),
d1047 1
a1047 1
		DPRINTFN(2, ("Scan channel (%u)\n", chan->nchan));
d1115 1
a1115 1
	struct iwi_rx_buf *buf;
d1117 1
a1117 1
	uint32_t r, i;
d1119 1
a1119 1
	r = CSR_READ_4(sc, IWI_CSR_RX_READ_INDEX);
d1121 2
a1122 2
	for (i = (sc->rx_cur + 1) % IWI_RX_RING_SIZE; i != r;
	     i = (i + 1) % IWI_RX_RING_SIZE) {
d1124 1
a1124 3
		buf = &sc->rx_buf[i];

		bus_dmamap_sync(sc->sc_dmat, buf->map, 0,
d1127 1
a1127 1
		hdr = mtod(buf->m, struct iwi_hdr *);
d1131 1
a1131 1
			iwi_frame_intr(sc, buf, i,
d1136 1
a1136 1
			iwi_notification_intr(sc, buf,
d1144 2
d1149 2
a1150 2
	sc->rx_cur = (r == 0) ? IWI_RX_RING_SIZE - 1 : r - 1;
	CSR_WRITE_4(sc, IWI_CSR_RX_WRITE_INDEX, sc->rx_cur);
d1154 1
a1154 1
iwi_tx_intr(struct iwi_softc *sc)
d1158 2
a1159 2
	struct iwi_tx_buf *buf;
	uint32_t r, i;
d1161 1
a1161 1
	r = CSR_READ_4(sc, IWI_CSR_TX1_READ_INDEX);
d1163 2
a1164 2
	for (i = (sc->tx_old + 1) % IWI_TX_RING_SIZE; i != r;
	     i = (i + 1) % IWI_TX_RING_SIZE) {
d1166 5
a1170 7
		buf = &sc->tx_buf[i];

		bus_dmamap_unload(sc->sc_dmat, buf->map);
		m_freem(buf->m);
		buf->m = NULL;
		ieee80211_release_node(ic, buf->ni);
		buf->ni = NULL;
a1172 1
		sc->tx_queued--;
d1174 2
a1175 2
		/* kill watchdog timer */
		sc->sc_tx_timer = 0;
d1178 1
a1178 4
	/* remember what the firmware has processed */
	sc->tx_old = (r == 0) ? IWI_TX_RING_SIZE - 1 : r - 1;

	/* call start() since some buffer descriptors have been released */
d1195 2
a1196 1
	DPRINTFN(8, ("INTR!0x%08x\n", r));
d1201 1
d1212 1
d1215 8
a1222 2
	if (r & IWI_INTR_RX_TRANSFER)
		iwi_rx_intr(sc);
d1224 2
a1225 2
	if (r & IWI_INTR_CMD_TRANSFER)
		wakeup(sc);
d1227 2
a1228 2
	if (r & IWI_INTR_TX1_TRANSFER)
		iwi_tx_intr(sc);
d1230 2
a1231 2
	/* acknowledge interrupts */
	CSR_WRITE_4(sc, IWI_CSR_INTR, r);
d1244 1
a1244 3
	DPRINTFN(2, ("TX!CMD!%u!%u\n", type, len));

	desc = &sc->cmd_desc[sc->cmd_cur];
d1251 2
a1252 2
	bus_dmamap_sync(sc->sc_dmat, sc->cmd_ring_map,
	    sc->cmd_cur * sizeof (struct iwi_cmd_desc),
d1255 5
a1259 2
	sc->cmd_cur = (sc->cmd_cur + 1) % IWI_CMD_RING_SIZE;
	CSR_WRITE_4(sc, IWI_CSR_CMD_WRITE_INDEX, sc->cmd_cur);
d1269 1
a1269 1
	struct iwi_tx_buf *buf;
d1271 1
d1293 2
a1294 2
	buf = &sc->tx_buf[sc->tx_cur];
	desc = &sc->tx_desc[sc->tx_cur];
d1310 2
a1311 1
	error = bus_dmamap_load_mbuf(sc->sc_dmat, buf->map, m0, BUS_DMA_NOWAIT);
d1342 1
a1342 1
		error = bus_dmamap_load_mbuf(sc->sc_dmat, buf->map, m0,
d1352 2
a1353 2
	buf->m = m0;
	buf->ni = ni;
d1374 4
a1377 4
	desc->nseg = htole32(buf->map->dm_nsegs);
	for (i = 0; i < buf->map->dm_nsegs; i++) {
		desc->seg_addr[i] = htole32(buf->map->dm_segs[i].ds_addr);
		desc->seg_len[i]  = htole16(buf->map->dm_segs[i].ds_len);
d1380 2
a1381 2
	bus_dmamap_sync(sc->sc_dmat, sc->tx_ring_map,
	    sc->tx_cur * sizeof (struct iwi_tx_desc),
d1384 1
a1384 1
	bus_dmamap_sync(sc->sc_dmat, buf->map, 0, MCLBYTES,
d1387 2
a1388 1
	DPRINTFN(5, ("TX!DATA!%u!%u\n", letoh16(desc->len), desc->nseg));
d1390 3
a1392 4
	/* inform firmware about this new packet */
	sc->tx_queued++;
	sc->tx_cur = (sc->tx_cur + 1) % IWI_TX_RING_SIZE;
	CSR_WRITE_4(sc, IWI_CSR_TX1_WRITE_INDEX, sc->tx_cur);
d1413 1
a1413 1
		if (sc->tx_queued >= IWI_TX_RING_SIZE - 8) {
d1559 4
a1562 2
	if (ntries == 5)
		printf("%s: timeout waiting for master\n", sc->sc_dev.dv_xname);
a1580 1
	/* initialize phase-locked level (PLL) */
d1589 3
a1591 1
	if (ntries == 1000)
d1593 1
d1612 1
a1612 1
iwi_load_ucode(struct iwi_softc *sc, const char *name)
d1614 2
a1615 19
	u_char *uc, *data;
	size_t size;
	uint16_t *w;
	int error, ntries, i;

	if ((error = loadfirmware(name, &data, &size)) != 0) {
		printf("%s: could not read ucode %s, error %d\n",
		    sc->sc_dev.dv_xname, name, error);
		goto fail1;
	}

	if (size < sizeof (struct iwi_firmware_hdr)) {
		error = EINVAL;
		goto fail2;
	}

	uc = data;
	uc += sizeof (struct iwi_firmware_hdr);
	size -= sizeof (struct iwi_firmware_hdr);
d1625 3
a1627 3
		printf("%s: timeout waiting for master\n", sc->sc_dev.dv_xname);
		error = EIO;
		goto fail2;
d1632 1
d1635 1
d1645 1
d1648 1
a1648 1
	for (w = (uint16_t *)uc; size > 0; w++, size -= 2)
d1654 1
a1654 1
	/* wait until we get a response in the uc queue */
d1663 1
a1663 2
		error = EIO;
		goto fail2;
d1666 1
a1666 1
	/* empty the uc queue or the firmware will not initialize properly */
d1672 1
a1672 2
fail2:	free(data, M_DEVBUF);
fail1:	return error;
d1677 1
d1679 1
a1679 1
iwi_load_firmware(struct iwi_softc *sc, const char *name)
a1680 2
	u_char *fw, *data;
	size_t size;
a1687 15
	if ((error = loadfirmware(name, &data, &size)) != 0) {
		printf("%s: could not read firmware %s, error %d\n",
		    sc->sc_dev.dv_xname, name, error);
		goto fail1;
	}

	if (size < sizeof (struct iwi_firmware_hdr)) {
		error = EINVAL;
		goto fail2;
	}

	fw = data;
	fw += sizeof (struct iwi_firmware_hdr);
	size -= sizeof (struct iwi_firmware_hdr);

d1694 1
a1694 1
		goto fail2;
a1696 4
	/*
	 * We cannot map fw directly because of some hardware constraints on
	 * the mapping address.
	 */
d1702 1
a1702 1
		goto fail3;
d1710 1
a1710 1
		goto fail4;
d1718 1
a1718 1
		goto fail5;
d1722 1
a1722 1
	bcopy(fw, virtaddr, size);
d1735 1
a1735 1
	src = map->dm_segs->ds_addr;
d1782 1
a1782 1
		goto fail6;
d1793 1
d1801 1
a1801 1
		goto fail6;
d1804 1
a1804 1
fail6:	bus_dmamap_sync(sc->sc_dmat, map, 0, size, BUS_DMASYNC_POSTWRITE);
d1806 3
a1808 5
fail5:	bus_dmamem_unmap(sc->sc_dmat, virtaddr, size);
fail4:	bus_dmamem_free(sc->sc_dmat, &seg, 1);
fail3:	bus_dmamap_destroy(sc->sc_dmat, map);
fail2:	free(data, M_DEVBUF);

d1834 1
d1838 1
a1838 2
	error = iwi_cmd(sc, IWI_CMD_SET_CONFIGURATION, &config, sizeof config,
	    0);
d2022 1
d2028 2
a2029 2
		error = iwi_cmd(sc, IWI_CMD_SET_CONFIGURATION, &config,
		    sizeof config, 1);
d2099 4
a2102 1
	const char *ucode, *main;
d2107 1
a2107 7
		goto fail;
	}

	if ((error = iwi_load_firmware(sc, "iwi-boot")) != 0) {
		printf("%s: could not load boot firmware\n",
		    sc->sc_dev.dv_xname);
		goto fail;
d2113 1
a2113 2
		ucode = "iwi-ucode-bss";
		main = "iwi-bss";
a2114 1

d2117 1
a2117 2
		ucode = "iwi-ucode-ibss";
		main = "iwi-ibss";
a2118 1

d2120 1
a2120 2
		ucode = "iwi-ucode-monitor";
		main = "iwi-monitor";
d2122 30
d2154 3
a2156 1
	if ((error = iwi_load_ucode(sc, ucode)) != 0) {
d2158 1
a2158 1
		goto fail;
d2163 11
a2173 29
	sc->tx_cur = 0;
	sc->tx_queued = 0;
	sc->tx_old = IWI_TX_RING_SIZE - 1;
	sc->cmd_cur = 0;
	sc->rx_cur = IWI_RX_RING_SIZE - 1;

	CSR_WRITE_4(sc, IWI_CSR_CMD_BASE, sc->cmd_ring_map->dm_segs->ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_CMD_SIZE, IWI_CMD_RING_SIZE);
	CSR_WRITE_4(sc, IWI_CSR_CMD_WRITE_INDEX, sc->cmd_cur);

	CSR_WRITE_4(sc, IWI_CSR_TX1_BASE, sc->tx_ring_map->dm_segs->ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_TX1_SIZE, IWI_TX_RING_SIZE);
	CSR_WRITE_4(sc, IWI_CSR_TX1_WRITE_INDEX, sc->tx_cur);

	CSR_WRITE_4(sc, IWI_CSR_TX2_BASE, sc->tx_ring_map->dm_segs->ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_TX2_SIZE, IWI_TX_RING_SIZE);
	CSR_WRITE_4(sc, IWI_CSR_TX2_WRITE_INDEX, sc->tx_cur);

	CSR_WRITE_4(sc, IWI_CSR_TX3_BASE, sc->tx_ring_map->dm_segs->ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_TX3_SIZE, IWI_TX_RING_SIZE);
	CSR_WRITE_4(sc, IWI_CSR_TX3_WRITE_INDEX, sc->tx_cur);

	CSR_WRITE_4(sc, IWI_CSR_TX4_BASE, sc->tx_ring_map->dm_segs->ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_TX4_SIZE, IWI_TX_RING_SIZE);
	CSR_WRITE_4(sc, IWI_CSR_TX4_WRITE_INDEX, sc->tx_cur);

	for (i = 0; i < IWI_RX_RING_SIZE; i++)
		CSR_WRITE_4(sc, IWI_CSR_RX_BASE + i * 4,
		    sc->rx_buf[i].map->dm_segs->ds_addr);
d2175 12
a2186 1
	CSR_WRITE_4(sc, IWI_CSR_RX_WRITE_INDEX, sc->rx_cur);
d2188 5
a2192 1
	if ((error = iwi_load_firmware(sc, main)) != 0) {
d2195 1
a2195 1
		goto fail;
d2198 1
d2204 1
a2204 1
		goto fail;
d2217 2
a2218 2
fail:	iwi_stop(ifp, 0);

a2226 2
	struct iwi_tx_buf *buf;
	int i;
d2235 1
d2238 7
a2244 13
	/*
	 * Release Tx buffers.
	 */
	for (i = 0; i < IWI_TX_RING_SIZE; i++) {
		buf = &sc->tx_buf[i];

		if (buf->m != NULL) {
			bus_dmamap_unload(sc->sc_dmat, buf->map);
			m_freem(buf->m);
			buf->m = NULL;
		}
		buf->ni = NULL;
	}
@


1.60
log
@prettify + u_int{8,16,32}_t -> uint{8,16,32}_t
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.59 2006/02/04 11:36:32 damien Exp $	*/
d880 1
a880 1
		bpf_mtap(sc->sc_drvbpf, &mb);
d1148 1
a1148 1
		bpf_mtap(sc->sc_drvbpf, &mb);
d1279 1
a1279 1
			bpf_mtap(ifp->if_bpf, m0);
d1288 1
a1288 1
			bpf_mtap(ic->ic_rawbpf, m0);
@


1.59
log
@silently discard f/w notifications that are unknown (fixes spurious
"unknown notification 15" in logs with latest firmware)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.58 2006/01/29 15:44:16 damien Exp $	*/
d96 36
a131 35
int iwi_match(struct device *, void *, void *);
void iwi_attach(struct device *, struct device *, void *);
int iwi_detach(struct device *, int);
void iwi_power(int, void *);
int iwi_dma_alloc(struct iwi_softc *);
void iwi_release(struct iwi_softc *);
int iwi_media_change(struct ifnet *);
void iwi_media_status(struct ifnet *, struct ifmediareq *);
u_int16_t iwi_read_prom_word(struct iwi_softc *, u_int8_t);
int iwi_find_txnode(struct iwi_softc *, const u_int8_t *);
int iwi_newstate(struct ieee80211com *, enum ieee80211_state, int);
void iwi_frame_intr(struct iwi_softc *, struct iwi_rx_buf *, int,
    struct iwi_frame *);
void iwi_notification_intr(struct iwi_softc *, struct iwi_rx_buf *,
    struct iwi_notif *);
void iwi_rx_intr(struct iwi_softc *);
void iwi_tx_intr(struct iwi_softc *);
int iwi_intr(void *);
int iwi_cmd(struct iwi_softc *, u_int8_t, void *, u_int8_t, int);
int iwi_tx_start(struct ifnet *, struct mbuf *, struct ieee80211_node *);
void iwi_start(struct ifnet *);
void iwi_watchdog(struct ifnet *);
int iwi_get_table0(struct iwi_softc *, u_int32_t *);
int iwi_get_radio(struct iwi_softc *, int *);
int iwi_ioctl(struct ifnet *, u_long, caddr_t);
void iwi_stop_master(struct iwi_softc *);
int iwi_reset(struct iwi_softc *);
int iwi_load_ucode(struct iwi_softc *, const char *);
int iwi_load_firmware(struct iwi_softc *, const char *);
int iwi_config(struct iwi_softc *);
int iwi_set_chan(struct iwi_softc *, struct ieee80211_channel *);
int iwi_scan(struct iwi_softc *);
int iwi_auth_and_assoc(struct iwi_softc *);
int iwi_init(struct ifnet *);
void iwi_stop(struct ifnet *, int);
d133 2
a134 1
static __inline u_int8_t MEM_READ_1(struct iwi_softc *sc, u_int32_t addr)
d140 2
a141 1
static __inline u_int32_t MEM_READ_4(struct iwi_softc *sc, u_int32_t addr)
d148 2
a149 2
#define DPRINTF(x)	if (iwi_debug > 0) printf x
#define DPRINTFN(n, x)	if (iwi_debug >= (n)) printf x
d183 1
a183 1
	u_int16_t val;
d378 1
a378 1
	 * Allocate and map Tx ring
d420 1
a420 1
	 * Allocate and map command ring
d462 1
a462 1
	 * Allocate Tx buffers DMA maps
d476 1
a476 1
	 * Allocate and map Rx buffers
d581 1
a583 1
#define N(a)	(sizeof (a) / sizeof (a[0]))
d585 1
a585 1
		u_int32_t	val;
d601 1
a601 1
	u_int32_t val;
d642 1
a642 1
iwi_find_txnode(struct iwi_softc *sc, const u_int8_t *macaddr)
d663 1
a663 1
	    (u_int8_t *)&node, sizeof node);
d673 1
a673 1
	u_int32_t tmp;
d719 2
a720 2
u_int16_t
iwi_read_prom_word(struct iwi_softc *sc, u_int8_t addr)
d722 2
a723 2
	u_int32_t tmp;
	u_int16_t val;
d726 1
a726 1
	/* Clock C once before the first command */
d732 1
a732 1
	/* Write start bit (1) */
d736 1
a736 1
	/* Write READ opcode (10) */
d742 1
a742 1
	/* Write address A7-A0 */
d752 1
a752 1
	/* Read data Q15-Q0 */
d763 1
a763 1
	/* Clear Chip Select and clock C */
d838 1
a838 1
	/* Finalize mbuf */
d850 2
a851 2
		 * set in the 802.11 header and don't remove the iv and crc
		 * fields
d886 1
a886 1
	/* Send the frame to the upper layer */
d981 1
a981 1
	u_int32_t r, i;
d1012 1
a1012 1
	/* Tell the firmware what we have processed */
d1023 1
a1023 1
	u_int32_t r, i;
d1045 1
a1045 1
	/* Remember what the firmware has processed */
d1048 1
a1048 1
	/* Call start() since some buffer descriptors have been released */
d1057 1
a1057 1
	u_int32_t r;
d1062 1
a1062 1
	/* Disable interrupts */
d1091 1
a1091 1
	/* Acknowledge interrupts */
d1094 1
a1094 1
	/* Re-enable interrupts */
d1101 1
a1101 2
iwi_cmd(struct iwi_softc *sc, u_int8_t type, void *data, u_int8_t len,
    int async)
d1247 1
a1247 1
	/* Inform firmware about this new packet */
d1408 1
a1408 1
	/* Disable interrupts */
d1433 1
a1433 1
	/* Move adapter to D0 state */
d1437 1
a1437 1
	/* Initialize Phase-Locked Level  (PLL) */
d1440 1
a1440 1
	/* Wait for clock stabilization */
d1457 1
a1457 1
	/* Clear NIC memory */
d1470 1
a1470 1
	u_int16_t *w;
d1515 2
a1516 2
	/* Adapter is buggy, we must set the address for each word */
	for (w = (u_int16_t *)uc; size > 0; w++, size -= 2)
d1522 1
a1522 1
	/* Wait until we get a response in the uc queue */
d1535 1
a1535 1
	/* Empty the uc queue or the firmware will not initialize properly */
d1556 1
a1556 1
	u_int32_t sentinel, ctl, src, dst, sum, len, mlen;
d1574 1
a1574 1
	/* Allocate DMA memory for storing firmware image */
d1611 1
a1611 1
	/* Copy firmware image to DMA memory */
d1614 1
a1614 1
	/* Make sure the adapter will get up-to-date values */
d1617 1
a1617 1
	/* Tell the adapter where the command blocks are stored */
d1641 1
a1641 1
			/* Write a command block */
d1653 1
a1653 1
	/* Write a fictive final command block (sentinel) */
d1660 1
a1660 1
	/* Tell the adapter to start processing command blocks */
d1663 1
a1663 1
	/* Wait until the adapter has processed all command blocks */
d1675 1
a1675 1
	/* We're done with command blocks processing */
d1678 1
a1678 1
	/* Allow interrupts so we know when the firmware is inited */
d1681 1
a1681 1
	/* Tell the adapter to initialize the firmware */
d1686 1
a1686 1
	/* Wait at most one second for firmware initialization to complete */
d1713 1
a1713 1
	u_int32_t data;
d1831 1
a1831 1
	/* Enable adapter */
d1858 1
a1858 1
	u_int8_t *p;
d1905 2
a1906 2
	u_int16_t capinfo;
	u_int32_t data;
a2097 2
	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);

d2102 2
d2108 1
a2108 1
	 * Release Tx buffers
a2116 5

			if (buf->ni != NULL) {
				ieee80211_release_node(ic, buf->ni);
				buf->ni = NULL;
			}
d2118 1
@


1.58
log
@re-enable scatter and fix scanning of 802.11a channels.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.57 2006/01/18 20:25:22 damien Exp $	*/
d968 1
a968 3
	case IWI_NOTIF_TYPE_CALIBRATION:
	case IWI_NOTIF_TYPE_BEACON:
	case IWI_NOTIF_TYPE_NOISE:
a969 5
		break;

	default:
		printf("%s: unknown notification type %u\n",
		    sc->sc_dev.dv_xname, notif->type);
@


1.57
log
@add some bits to control assoc led.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.56 2006/01/04 06:04:41 canacar Exp $	*/
d462 3
a464 2
		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT, &sc->tx_buf[i].map);
d1887 1
@


1.56
log
@Remove redundant calls to bpfdetach.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.55 2005/11/23 21:29:05 damien Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004, 2005
d668 4
d688 13
a703 1
	case IEEE80211_S_INIT:
d1512 1
a1512 1
	MEM_WRITE_4(sc, 0x300004, 1);
d1514 1
a1514 1
	MEM_WRITE_4(sc, 0x300004, 0);
d2101 1
a2101 2
	iwi_stop_master(sc);
	CSR_WRITE_4(sc, IWI_CSR_RST, IWI_RST_SW_RESET);
d2103 1
d2107 3
a2126 2

	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);
@


1.55
log
@When defragmenting a mbuf chain before transmitting it, don't allocate a mbuf
cluster if the payload fits in the header.

From NetBSD (scw@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.54 2005/11/23 21:08:46 damien Exp $	*/
a330 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
@


1.54
log
@fix my previous commit.  don't leak an mbuf.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.53 2005/11/23 21:04:40 damien Exp $	*/
d1177 7
a1183 5
		MCLGET(mnew, M_DONTWAIT);
		if (!(mnew->m_flags & M_EXT)) {
			m_freem(m0);
			m_freem(mnew);
			return ENOMEM;
@


1.53
log
@Be more robust when handling Rx interrupts.  If we can't allocate and DMA map
a new mbuf, just discard the received frame and reuse the old mbuf.

From NetBSD (joerg@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.52 2005/11/23 20:57:09 damien Exp $	*/
d793 1
@


1.52
log
@Fix endianness issues.  iwi should now work on big endian architectures.

From NetBSD (scw@@).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.51 2005/10/07 06:33:11 damien Exp $	*/
d760 1
a760 1
	struct mbuf *m;
d779 18
d799 21
a820 1
	m = buf->m;
a871 28

	MGETHDR(buf->m, M_DONTWAIT, MT_DATA);
	if (buf->m == NULL) {
		printf("%s: could not allocate rx mbuf\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	MCLGET(buf->m, M_DONTWAIT);
	if (!(buf->m->m_flags & M_EXT)) {
		printf("%s: could not allocate rx mbuf cluster\n",
		    sc->sc_dev.dv_xname);
		m_freem(buf->m);
		buf->m = NULL;
		return;
	}

	error = bus_dmamap_load(sc->sc_dmat, buf->map, mtod(buf->m, void *),
	    MCLBYTES, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load rx buf DMA map\n",
		    sc->sc_dev.dv_xname);
		m_freem(buf->m);
		buf->m = NULL;
		return;
	}

	CSR_WRITE_4(sc, IWI_CSR_RX_BASE + i * 4, buf->map->dm_segs->ds_addr);
@


1.51
log
@fixes rev 1.50.  got a stack smashed.
looks like i committed the wrong version.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.50 2005/10/06 20:33:39 damien Exp $	*/
d244 2
a245 2
	ic->ic_myaddr[0] = val >> 8;
	ic->ic_myaddr[1] = val & 0xff;
d247 2
a248 2
	ic->ic_myaddr[2] = val >> 8;
	ic->ic_myaddr[3] = val & 0xff;
d250 2
a251 2
	ic->ic_myaddr[4] = val >> 8;
	ic->ic_myaddr[5] = val & 0xff;
d751 1
a751 1
	return betoh16(val);
d1213 1
a1213 1
		desc->seg_len[i]  = htole32(buf->map->dm_segs[i].ds_len);
d1223 1
a1223 1
	DPRINTFN(5, ("TX!DATA!%u!%u\n", desc->len, desc->nseg));
d1495 1
a1495 1
		MEM_WRITE_2(sc, 0x200010, *w);
@


1.50
log
@o Use firmware extended scan command; this one doesn't crash when scanning
  the 5GHz band.
o Enable 802.11a channels scanning for 2915ABG adapters.
o Fix a typo (negociated->negotiated).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.49 2005/09/19 20:01:11 damien Exp $	*/
d1821 1
a1821 1
	memset(scan.type, 26, IWI_SCAN_TYPE_PASSIVE);
d1843 1
a1843 1
		memset(scan.type, 26, IWI_SCAN_TYPE_BDIRECTED);
d1846 1
a1846 1
		memset(scan.type, 26, IWI_SCAN_TYPE_BROADCAST);
@


1.49
log
@o Add initial bits for IBSS support.
o Fix association with APs not broadcasting their SSIDs.
o Don't send anything if there is less than eight free slots in Tx ring.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.48 2005/08/09 04:10:12 mickey Exp $	*/
a254 1
#if 0
a270 1
#endif
d1821 4
a1824 4
	scan.type = IWI_SCAN_TYPE_PASSIVE;
	scan.intval = htole16(2000);
	scan.channels[0] = 1 | (IEEE80211_IS_CHAN_5GHZ(chan) ? IWI_CHAN_5GHZ :
	    IWI_CHAN_2GHZ);
d1840 8
a1847 3
	scan.type = (ic->ic_des_esslen != 0) ? IWI_SCAN_TYPE_BDIRECTED :
	    IWI_SCAN_TYPE_BROADCAST;
	scan.intval = htole16(40);
d1912 1
a1912 1
	/* the rate set has already been "negociated" */
d1915 1
a1915 1
	rs.type = IWI_RATESET_TYPE_NEGOCIATED;
@


1.48
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.47 2005/07/12 18:18:13 damien Exp $	*/
d105 1
d238 3
a240 2
	ic->ic_caps = IEEE80211_C_PMGT | IEEE80211_C_WEP | IEEE80211_C_TXPMGT |
	    IEEE80211_C_SHPREAMBLE | IEEE80211_C_MONITOR | IEEE80211_C_SCANALL;
d638 31
d684 2
a685 1
		if (ic->ic_opmode == IEEE80211_M_IBSS)
d687 1
a687 1
		else if (ic->ic_opmode == IEEE80211_M_MONITOR)
d1114 1
a1114 1
	int error, i;
d1141 10
d1197 1
d1251 1
a1251 1
		if (sc->tx_queued >= IWI_TX_RING_SIZE - 4) {
d1772 16
d1842 2
a1843 1
	scan.type = IWI_SCAN_TYPE_BROADCAST;
@


1.47
log
@h/w doesn't decrypt rx frames in monitor mode so don't try to remove the
iv and crc fields or to clear the wep bit from the 802.11 header.

fix by Pedro la Peu.  closes kern/4284.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.46 2005/07/02 23:10:11 brad Exp $	*/
a188 5

	/* enable bus-mastering */
	data = pci_conf_read(sc->sc_pct, sc->sc_pcitag, PCI_COMMAND_STATUS_REG);
	data |= PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, PCI_COMMAND_STATUS_REG, data);
@


1.46
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.45 2005/06/20 18:25:14 damien Exp $	*/
d763 2
a764 1
	if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
@


1.45
log
@fix a couple of 'use after free' bugs on mbuf chains in the tx path.
originally pointed out by Mike Silbersack on the fbsd version of the iwi
driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.44 2005/05/22 16:30:30 damien Exp $	*/
d2017 3
a2036 3

	ifp->if_timer = 0;
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.44
log
@fix setting of the "need ack" flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.40 2005/05/22 15:14:10 damien Exp $	*/
a1080 1
	struct ieee80211_frame *wh;
d1107 2
a1108 3
	wh = mtod(m0, struct ieee80211_frame *);

	/* trim IEEE802.11 header */
d1159 1
a1159 1
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1))
d1163 1
a1163 1
		wh->i_fc[1] |= IEEE80211_FC1_WEP;
a1170 1
	bcopy(wh, &desc->wh, sizeof (struct ieee80211_frame));
@


1.43
log
@cosmetic.  no need to initialize the read index.
@
text
@d1160 2
a1161 4
	if (ic->ic_opmode == IEEE80211_M_IBSS) {
		if (!IEEE80211_IS_MULTICAST(wh->i_addr1))
			desc->flags |= IWI_DATA_FLAG_NEED_ACK;
	} else if (!IEEE80211_IS_MULTICAST(wh->i_addr3))
@


1.42
log
@set fragmentation threshold in iwi_config().
@
text
@d833 1
a833 1
	CSR_WRITE_4(sc, IWI_CSR_RX_BASE + i * 4, buf->map->dm_segs[0].ds_addr);
d1569 1
a1569 1
	src = map->dm_segs[0].ds_addr;
d1956 1
a1956 1
	CSR_WRITE_4(sc, IWI_CSR_CMD_BASE, sc->cmd_ring_map->dm_segs[0].ds_addr);
a1957 1
	CSR_WRITE_4(sc, IWI_CSR_CMD_READ_INDEX, 0);
d1960 1
a1960 1
	CSR_WRITE_4(sc, IWI_CSR_TX1_BASE, sc->tx_ring_map->dm_segs[0].ds_addr);
a1961 1
	CSR_WRITE_4(sc, IWI_CSR_TX1_READ_INDEX, 0);
d1964 1
a1964 1
	CSR_WRITE_4(sc, IWI_CSR_TX2_BASE, sc->tx_ring_map->dm_segs[0].ds_addr);
d1966 1
a1966 2
	CSR_WRITE_4(sc, IWI_CSR_TX2_READ_INDEX, 0);
	CSR_WRITE_4(sc, IWI_CSR_TX2_WRITE_INDEX, 0);
d1968 1
a1968 1
	CSR_WRITE_4(sc, IWI_CSR_TX3_BASE, sc->tx_ring_map->dm_segs[0].ds_addr);
d1970 1
a1970 2
	CSR_WRITE_4(sc, IWI_CSR_TX3_READ_INDEX, 0);
	CSR_WRITE_4(sc, IWI_CSR_TX3_WRITE_INDEX, 0);
d1972 1
a1972 1
	CSR_WRITE_4(sc, IWI_CSR_TX4_BASE, sc->tx_ring_map->dm_segs[0].ds_addr);
d1974 1
a1974 2
	CSR_WRITE_4(sc, IWI_CSR_TX4_READ_INDEX, 0);
	CSR_WRITE_4(sc, IWI_CSR_TX4_WRITE_INDEX, 0);
d1978 1
a1978 1
		    sc->rx_buf[i].map->dm_segs[0].ds_addr);
a1979 3
	/*
	 * Kick Rx
	 */
a1980 1
	CSR_WRITE_4(sc, IWI_CSR_RX_READ_INDEX, 0);
@


1.41
log
@some changes for IBSS mode support (not yet working).
@
text
@d1689 6
@


1.40
log
@add monitor mode support.  fast channel hop is not yet implemented though.
requires a firmware upgrade to version 1.0.4.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.39 2005/05/14 13:32:38 damien Exp $	*/
d1670 1
d1830 2
d1889 4
a1892 1
	IEEE80211_ADDR_COPY(assoc.dst, ni->ni_bssid);
@


1.39
log
@don't copy the capinfo field from the ap.  forge our own based on what
ieee80211_output.c does.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.38 2005/05/13 20:52:51 damien Exp $	*/
d125 1
d243 1
a243 1
	    IEEE80211_C_SHPREAMBLE | IEEE80211_C_SCANALL;
d658 2
d747 1
a747 1
		printf("%s: bad frame length\n", sc->sc_dev.dv_xname);
d864 5
a868 1
		ieee80211_end_scan(ifp);
d1758 17
d1897 1
d1993 4
a1996 1
	ieee80211_begin_scan(ifp);
@


1.38
log
@should support channel 165 too in 802.11a mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.37 2005/05/13 20:24:59 damien Exp $	*/
d1795 1
d1847 12
a1858 1
	assoc.capinfo = htole16(ni->ni_capinfo);
@


1.37
log
@fix sensitivity setting.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.36 2005/04/17 13:49:09 damien Exp $	*/
d268 1
a268 1
		for (i = 149; i <= 161; i += 4) {
@


1.36
log
@temporarly remove 802.11a channels from the set of supported channels until
i figure out why the firmware crashes when scanning in the 5.2GHz spectrum.
this makes 2915ABG adapters work (b/g only).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.35 2005/04/17 13:41:46 damien Exp $	*/
d800 1
a800 1
	ieee80211_input(ifp, m, ni, IWI_RSSIDBM2RAW(frame->rssi_dbm), 0);
@


1.35
log
@don't disassociate on SIOCSIFADDR if the interface is already up and running.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.34 2005/04/04 16:37:07 damien Exp $	*/
d257 1
d274 1
@


1.34
log
@remove noise statistics. this was generating tons of useless interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.33 2005/04/04 16:31:52 damien Exp $	*/
d1272 1
a1272 1
		ifa = (struct ifaddr *) data;
a1273 1
		switch (ifa->ifa_addr->sa_family) {
d1275 1
a1275 1
		case AF_INET:
a1276 2
			iwi_init(ifp);
			break;
d1278 1
a1278 5
		default:
			iwi_init(ifp);
		}
		break;

@


1.33
log
@new id for PRO/Wireless 2915ABG. fix desc for PRO/Wireless adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.32 2005/03/23 14:14:30 damien Exp $	*/
a783 1
		tap->wr_antnoise = frame->noise;
a1667 1
	config.noise_reported = 1;
a1808 1
		config.noise_reported = 1;
@


1.32
log
@do packet accounting (opackets/oerrors/ierrors).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.31 2005/03/17 20:08:13 damien Exp $	*/
d31 1
a31 1
 * Intel(R) PRO/Wireless 2200BG/2915ABG driver
d81 4
a84 3
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_2200BG_3B },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_2225BG },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_2915ABG_3B },
d257 1
a257 1
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_PRO_2915ABG_3B) {
@


1.31
log
@support for ipv6.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.30 2005/03/14 13:21:42 damien Exp $	*/
d742 1
d980 1
d1229 1
d1250 1
@


1.30
log
@don't display an error message when re-associating.
this prevents annoying 'unknown association state 9' from happening.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.29 2005/03/12 13:37:49 damien Exp $	*/
d1259 1
d1261 1
d1273 2
a1274 3
			if (!(ifp->if_flags & IFF_UP))
				iwi_init(ifp);
			arp_ifinit(&sc->sc_ic.ic_ac, ifa);
d1292 11
d1330 1
a1330 1
	if (error == ENETRESET && cmd != SIOCADDMULTI) {
@


1.29
log
@prevent fragmentation from happening.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.27 2005/02/21 13:33:29 damien Exp $	*/
d887 4
@


1.28
log
@IBSS is not yet supported, remove it from the capabilities flags.
@
text
@d466 2
a467 2
		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, IWI_MAX_NSEG,
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &sc->tx_buf[i].map);
@


1.27
log
@ipwcontrol and iwicontrol removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.26 2005/02/19 13:38:01 damien Exp $	*/
d240 2
a241 2
	ic->ic_caps = IEEE80211_C_IBSS | IEEE80211_C_PMGT | IEEE80211_C_WEP |
	    IEEE80211_C_TXPMGT | IEEE80211_C_SHPREAMBLE | IEEE80211_C_SCANALL;
@


1.26
log
@Added support for Intel PRO/Wireless 2225BG PCI adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.25 2005/02/17 18:28:05 reyk Exp $	*/
a1251 25
iwi_get_table0(struct iwi_softc *sc, u_int32_t *tbl)
{
	u_int32_t size, buf[128];

	if (!(sc->flags & IWI_FLAG_FW_INITED)) {
		bzero(buf, sizeof buf);
		return copyout(buf, tbl, sizeof buf);
	}

	size = min(CSR_READ_4(sc, IWI_CSR_TABLE0_SIZE), 128 - 1);
	CSR_READ_REGION_4(sc, IWI_CSR_TABLE0_BASE, &buf[1], size);

	return copyout(buf, tbl, sizeof buf);
}

int
iwi_get_radio(struct iwi_softc *sc, int *ret)
{
	int val;

	val = (CSR_READ_4(sc, IWI_CSR_IO) & IWI_IO_RADIO_ENABLED) ? 1 : 0;
	return copyout(&val, ret, sizeof val);
}

int
a1254 1
	struct ifreq *ifr;
d1287 9
a1295 8
	case SIOCGTABLE0:
		ifr = (struct ifreq *)data;
		error = iwi_get_table0(sc, (u_int32_t *)ifr->ifr_data);
		break;

	case SIOCGRADIO:
		ifr = (struct ifreq *)data;
		error = iwi_get_radio(sc, (int *)ifr->ifr_data);
@


1.25
log
@derived from NetBSD:

---
Make the node table into an LRU cache: least-recently used nodes
are at the end of the node queue.  Change the reference-counting
discipline: ni->ni_refcnt indicates how many times net80211 has
granted ni to the driver.  Every node in the table with ni_refcnt=0
is eligible to be garbage-collected.  The mere presence of a node
in the table does not any longer indicate its auth/assoc state;
nodes have a ni_state variable, now.

While I am here, patch ieee80211_find_node_for_beacon to do a "best
match" by bssid/ssid/channel, not a "perfect match."  This keeps
net80211 from caching duplicate nodes in the table.
---

ok deraadt@@ dlg@@, looks good jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.24 2005/01/09 16:47:50 damien Exp $	*/
d82 1
d256 1
a256 1
	if (PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_INTEL_PRO_2200BG_3B) {
@


1.24
log
@- add support for 2.2 firmware
- fix rssi decoding
- implement basics for IBSS support
- decrease channel scan time from 100ms to 40ms
- cosmetic changes while i'm here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwi.c,v 1.23 2005/01/05 09:07:15 jsg Exp $	*/
d798 1
a798 4
	if (ni == ic->ic_bss)
		ieee80211_unref_node(&ni);
	else
		ieee80211_free_node(ic, ni);
d971 1
a971 2
		if (buf->ni != ic->ic_bss)
			ieee80211_free_node(ic, buf->ni);
d1220 2
a1221 2
			if (ni != NULL && ni != ic->ic_bss)
				ieee80211_free_node(ic, ni);
d2002 1
a2002 2
				if (buf->ni != ic->ic_bss)
					ieee80211_free_node(ic, buf->ni);
@


1.23
log
@Use $OpenBSD$ instead of $Id$. ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 2004
d180 1
a180 1
	sc->sc_pcitag = pa->pa_tag,
d508 1
a508 1
			printf("%s: could not load rx buffer DMA map\n",
a649 1
	case IEEE80211_S_INIT:
d651 4
d656 1
d665 1
a665 1
 * Read 16 bits at address 'addr' from the Microwire EEPROM.
d732 1
a732 1
	    IWI_RSSI2DBM(frame->rssi, frame->agc)));
d738 6
d795 2
a796 2
	/* Send it up to the upper layer */
	ieee80211_input(ifp, m, ni, IWI_RSSI2DBM(frame->rssi, frame->agc), 0);
d803 2
a804 2
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL) {
d810 2
a811 3
	MCLGET(m, M_DONTWAIT);
	if (!(m->m_flags & M_EXT)) {
		m_freem(m);
d814 2
d819 1
a819 1
	error = bus_dmamap_load(sc->sc_dmat, buf->map, mtod(m, void *),
d822 1
a822 1
		printf("%s: could not map buffer dma memory\n",
d824 2
a825 1
		m_freem(m);
a828 1
	buf->m = m;
d838 1
a842 3
	DPRINTFN(2, ("RX!NOTIFICATION!%u!%u\n", notif->type,
	    letoh16(notif->len)));

d849 3
a873 1
			/*ieee80211_begin_scan(ifp);*/
d905 2
d974 3
d978 1
a978 5
		if (buf->ni != NULL) {
			if (buf->ni != ic->ic_bss)
				ieee80211_free_node(ic, buf->ni);
			buf->ni = NULL;
		}
a981 2

		sc->tx_free++;
d1016 5
d1065 1
a1065 1
iwi_tx_start(struct ifnet *ifp, struct mbuf *m, struct ieee80211_node *ni)
d1084 1
a1084 1
		M_DUP_PKTHDR(&mb, m);
d1087 1
a1087 1
		mb.m_next = m;
d1093 4
a1096 1
	wh = mtod(m, struct ieee80211_frame *);
d1099 1
a1099 4
	m_adj(m, sizeof (struct ieee80211_frame));

	buf = &sc->tx_buf[sc->tx_cur];
	desc = &sc->tx_desc[sc->tx_cur];
d1101 1
a1101 1
	error = bus_dmamap_load_mbuf(sc->sc_dmat, buf->map, m, BUS_DMA_NOWAIT);
d1105 1
a1105 1
		m_freem(m);
d1113 1
a1113 1
			m_freem(m);
d1117 1
a1117 1
		M_DUP_PKTHDR(mnew, m);
d1120 1
a1120 1
			m_freem(m);
d1125 2
a1126 2
		m_copydata(m, 0, m->m_pkthdr.len, mtod(mnew, caddr_t));
		m_freem(m);
d1128 1
a1128 1
		m = mnew;
d1130 1
a1130 1
		error = bus_dmamap_load_mbuf(sc->sc_dmat, buf->map, m,
d1135 1
a1135 1
			m_freem(m);
d1140 1
a1140 1
	buf->m = m;
d1146 7
a1152 3
	desc->len = htole16(m->m_pkthdr.len);
	desc->flags = IEEE80211_IS_MULTICAST(wh->i_addr1) ? 0 :
	    IWI_DATA_FLAG_NEED_ACK;
d1180 1
a1183 2
	sc->tx_free--;

d1192 1
a1192 1
	struct mbuf *m;
d1199 2
a1200 2
		IF_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
d1203 2
a1204 2
		if (sc->tx_free <= 2) {
			IF_PREPEND(&ifp->if_snd, m);
d1211 1
a1211 1
			bpf_mtap(ifp->if_bpf, m);
d1214 2
a1215 2
		m = ieee80211_encap(ifp, m, &ni);
		if (m == NULL)
d1220 1
a1220 1
			bpf_mtap(ic->ic_rawbpf, m);
d1223 1
a1223 1
		if (iwi_tx_start(ifp, m, ni) != 0) {
d1407 1
a1407 1
	/* clear NIC memory */
d1476 1
a1476 1
		DELAY(1000);
d1528 1
a1528 1
		printf("%s: could not create fw dma map\n",
d1540 1
a1540 1
		printf("%s: could allocate fw dma memory\n",
d1548 1
a1548 1
		printf("%s: could not map fw dma memory\n",
d1556 2
a1557 1
		printf("%s: could not load fw dma map\n", sc->sc_dev.dv_xname);
d1643 2
a1644 1
fail6:	bus_dmamap_unload(sc->sc_dmat, map);
d1666 1
a1667 2
	IEEE80211_ADDR_COPY(((struct arpcom *)ifp)->ac_enaddr, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(LLADDR(ifp->if_sadl), ic->ic_myaddr);
d1675 2
a1676 2
	config.enable_multicast = 1;
	config.pass_noise = 1;
d1774 1
a1774 1
	scan.intval = htole16(100);
d1816 3
a1818 3
		config.enable_multicast = 1;
		config.bg_autodetect = 1;
		config.pass_noise = 1;
d1828 1
a1828 1
		printf("Setting adapter ESSID to ");
d1848 2
a1849 2
	data = htole32(0);
	DPRINTF(("Setting sensitivity to %d\n", letoh32(data)));
d1866 1
d1876 1
a1876 1
	const char *name;
d1890 20
a1909 1
	if ((error = iwi_load_ucode(sc, "iwi-ucode")) != 0) {
d1917 1
a1918 1
	sc->tx_free = IWI_TX_RING_SIZE;
d1957 1
a1957 17
	switch (sc->sc_ic.ic_opmode) {
	case IEEE80211_M_STA:
	case IEEE80211_M_HOSTAP:
		name = "iwi-bss";
		break;

	case IEEE80211_M_IBSS:
	case IEEE80211_M_AHDEMO:
		name = "iwi-ibss";
		break;

	case IEEE80211_M_MONITOR:
		name = "iwi-monitor";
		break;
	}

	if ((error = iwi_load_firmware(sc, name)) != 0) {
@


1.22
log
@add powerhooks
OK claudio@@ kevlo@@ deraadt@@
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.21 2004/12/10 21:25:53 damien Exp $  */
@


1.21
log
@fix mbuf defragmentation
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.20 2004/12/06 20:27:15 damien Exp $  */
d97 1
d180 1
d182 2
a183 1
	data = pci_conf_read(sc->sc_pct, pa->pa_tag, 0x40);
d185 1
a185 1
	pci_conf_write(sc->sc_pct, pa->pa_tag, 0x40, data);
d188 1
a188 1
	data = pci_conf_read(sc->sc_pct, pa->pa_tag, PCI_COMMAND_STATUS_REG);
d190 1
a190 1
	pci_conf_write(sc->sc_pct, pa->pa_tag, PCI_COMMAND_STATUS_REG, data);
d307 2
d347 23
@


1.20
log
@add mbuf linearization code when the number of fragments exceeds what is
supported by the hardware
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.19 2004/12/06 19:58:44 damien Exp $  */
d1084 1
a1084 1
		m->m_len = m->m_pkthdr.len;
@


1.19
log
@remove iwi_fix_channel() by setting IEEE80211_C_SCANALL capability flag
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.18 2004/12/06 19:54:05 damien Exp $  */
d1029 1
d1059 1
a1059 1
	if (error != 0) {
d1064 31
@


1.18
log
@indent
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.17 2004/12/04 19:40:37 damien Exp $  */
a102 1
void iwi_fix_channel(struct ieee80211com *, struct mbuf *);
d236 2
a237 2
	ic->ic_caps = IEEE80211_C_IBSS | IEEE80211_C_PMGT |
	    IEEE80211_C_TXPMGT | IEEE80211_C_WEP | IEEE80211_C_SHPREAMBLE;
a687 34
/* XXX Horrible hack to fix channel number of beacons and probe responses */
void
iwi_fix_channel(struct ieee80211com *ic, struct mbuf *m)
{
	struct ieee80211_frame *wh;
	u_int8_t subtype;
	u_int8_t *frm, *efrm;

	wh = mtod(m, struct ieee80211_frame *);

	if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_MGT)
		return;

	subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;

	if (subtype != IEEE80211_FC0_SUBTYPE_BEACON &&
	    subtype != IEEE80211_FC0_SUBTYPE_PROBE_RESP)
		return;

	frm = (u_int8_t *)(wh + 1);
	efrm = mtod(m, u_int8_t *) + m->m_len;

	frm += 12;	/* skip tstamp, bintval and capinfo */
	while (frm < efrm) {
		if (*frm == IEEE80211_ELEMID_DSPARMS)
#if IEEE80211_CHAN_MAX < 255
		if (frm[2] <= IEEE80211_CHAN_MAX)
#endif
			ic->ic_bss->ni_chan = &ic->ic_channels[frm[2]];

		frm += frm[1] + 2;
	}
}

a753 8

	/*
	 * Management frames (beacons or probe responses) received during
	 * scanning have an invalid channel field. Thus these frames are
	 * rejected by the 802.11 layer which breaks AP detection.
	 */
	if (ic->ic_state == IEEE80211_S_SCAN)
		iwi_fix_channel(ic, m);
@


1.17
log
@- reorder interrupt handlers
- don't request ack's for multicast frames
- fix short preamble support
- clear nic memory on reset
- fix ioctl SIOCGTABLE0
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.16 2004/12/04 19:19:24 damien Exp $  */
d799 1
a799 1
	
d1525 2
a1526 2
        /* Copy firmware image to DMA memory */
        bcopy(fw, virtaddr, size);
@


1.16
log
@minor cleaning
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.15 2004/12/04 19:01:46 damien Exp $  */
d1011 10
a1029 10
	if (r & IWI_INTR_FW_INITED) {
		if (!(r & (IWI_INTR_FATAL_ERROR | IWI_INTR_PARITY_ERROR)))
			wakeup(sc);
	}

	if (r & (IWI_INTR_FATAL_ERROR | IWI_INTR_PARITY_ERROR)) {
		printf("%s: fatal error\n", sc->sc_dev.dv_xname);
		iwi_stop(&sc->sc_ic.ic_if, 1);
	}

d1115 2
a1116 1
	desc->flags = IWI_DATA_FLAG_NEED_ACK;
d1123 1
a1123 1
#if 0
d1126 1
a1126 1
#endif
d1224 4
a1227 2
	if (!(sc->flags & IWI_FLAG_FW_INITED))
		return ENOTTY;
d1229 1
a1229 1
	size = CSR_READ_4(sc, IWI_CSR_TABLE0_SIZE);
d1232 1
a1232 1
	return copyout(buf, tbl, size * sizeof (u_int32_t));
d1241 1
a1241 1
	return copyout(&val, ret, sizeof (int));
d1344 1
a1344 1
	int ntries;
d1371 5
@


1.15
log
@fix shared authentication
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.14 2004/12/04 17:24:06 damien Exp $  */
d232 1
a232 1
	ic->ic_phytype = IEEE80211_T_DS;
d283 1
a283 1
	/* Default to authmode OPEN */
d1324 1
a1324 1
	for (ntries = 0; ntries < 50; ntries++) {
d1329 1
a1329 1
	if (ntries == 50)
d1592 1
a1592 1
	/* Wait at most 1 s for firmware initialization to complete */
d1621 1
a1621 1
	DPRINTF(("Setting adapter MAC to %s\n", ether_sprintf(ic->ic_myaddr)));
d1640 1
a1640 1
	DPRINTF(("Setting adapter power mode to %u\n", data));
d1646 1
a1646 1
	DPRINTF(("Setting adapter RTS threshold to %u\n", letoh32(data)));
d1693 1
a1693 1
	DPRINTF(("Setting initialization vector to %u\n", data));
d1706 1
a1706 1
			DPRINTF(("Setting wep key index %d len %d\n",
@


1.14
log
@Clean DMA allocation of Tx and Rx rings
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.13 2004/11/24 21:17:26 damien Exp $  */
d1815 1
a1815 1
		assoc.auth = IWI_AUTH_SHARED | ic->ic_wep_txkey;
@


1.13
log
@- add short preamble capability
- only set channels power in ibss mode
- use default sensitivity
- copy capinfo from beacon or probe resp
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.12 2004/11/24 21:00:50 damien Exp $  */
d97 2
d104 1
a104 1
void iwi_frame_intr(struct iwi_softc *, struct iwi_rx_slot *, struct iwi_buf *,
d106 1
a106 1
void iwi_notification_intr(struct iwi_softc *, struct iwi_buf *,
d109 1
a109 1
void iwi_tx_intr(struct iwi_softc *, int);
a117 8
int iwi_init_buffers(struct iwi_softc *, int);
void iwi_free_buffers(struct iwi_softc *);
int iwi_init_tx_queue(struct iwi_softc *, int, int);
void iwi_free_tx_queue(struct iwi_softc *, int);
int iwi_init_rx_queue(struct iwi_softc *);
void iwi_free_rx_queue(struct iwi_softc *);
int iwi_init_queues(struct iwi_softc *);
void iwi_free_queues(struct iwi_softc *);
d227 5
d333 2
d346 190
d724 2
a725 2
iwi_frame_intr(struct iwi_softc *sc, struct iwi_rx_slot *slot,
    struct iwi_buf *buf, struct iwi_frame *frame)
d814 1
d833 1
a833 1
	CSR_WRITE_4(sc, slot->csr, buf->map->dm_segs[0].ds_addr);
d837 1
a837 1
iwi_notification_intr(struct iwi_softc *sc, struct iwi_buf *buf,
d920 1
a920 3
	struct iwi_rx_queue *q = &sc->rxqueue;
	struct iwi_rx_slot *slot;
	struct iwi_buf *buf;
d926 4
a929 3
	for (i = (q->cur + 1) % q->size; i != r; i = (i + 1) % q->size) {
		slot = &q->slots[i];
		buf = slot->buf;
d938 1
a938 1
			iwi_frame_intr(sc, slot, buf,
d954 2
a955 2
	q->cur = (r == 0) ? q->size - 1 : r - 1;
	CSR_WRITE_4(sc, IWI_CSR_RX_WRITE_INDEX, q->cur);
d959 1
a959 1
iwi_tx_intr(struct iwi_softc *sc, int index)
d963 1
a963 2
	struct iwi_tx_queue *q = &sc->txqueue[index];
	struct iwi_buf *buf;
d966 4
a969 1
	r = CSR_READ_4(sc, q->csr_read);
d971 1
a971 2
	for (i = (q->old + 1) % q->size; i != r; i = (i + 1) % q->size) {
		buf = q->slots[i].buf;
d986 1
a986 1
		TAILQ_INSERT_TAIL(&sc->sc_free_buf, buf, next);
d990 1
a990 1
	q->old = (r == 0) ? q->size - 1 : r - 1;
d1014 1
a1014 1
	if (r & IWI_INTR_TX0_TRANSFER)
d1018 1
a1018 10
		iwi_tx_intr(sc, 1);

	if (r & IWI_INTR_TX2_TRANSFER)
		iwi_tx_intr(sc, 2);

	if (r & IWI_INTR_TX3_TRANSFER)
		iwi_tx_intr(sc, 3);

	if (r & IWI_INTR_TX4_TRANSFER)
		iwi_tx_intr(sc, 4);
d1041 1
a1041 1
    int flags)
d1043 1
a1043 4
	struct iwi_tx_queue *q = &sc->txqueue[0];
	struct iwi_tx_slot *slot;
	struct iwi_hdr *hdr;
	struct iwi_cmd *cmd;
d1047 10
a1056 10
	slot = &q->slots[q->cur];

	hdr = (struct iwi_hdr *)slot->virtaddr;
	hdr->type = IWI_HDR_TYPE_COMMAND;
	hdr->flags = IWI_HDR_FLAG_IRQ;

	cmd = (struct iwi_cmd *)(hdr + 1);
	cmd->type = type;
	cmd->len = len;
	bcopy(data, cmd->data, len);
d1058 2
a1059 9
	bus_dmamap_sync(sc->sc_dmat, q->map, q->cur * IWI_TX_SLOT_SIZE,
	    sizeof (struct iwi_hdr) + sizeof (struct iwi_cmd),
	    BUS_DMASYNC_PREWRITE);

	q->cur = (q->cur + 1) % q->size;
	CSR_WRITE_4(sc, q->csr_write, q->cur);

	if (flags & IWI_ASYNC_CMD)
		return 0;
d1061 1
a1061 1
	return tsleep(sc, 0, "iwicmd", hz);
a1068 1
	struct iwi_tx_queue *q = &sc->txqueue[1];
d1070 2
a1071 4
	struct iwi_tx_slot *slot;
	struct iwi_buf *buf;
	struct iwi_hdr *hdr;
	struct iwi_data *data;
d1097 2
a1098 1
	buf = TAILQ_FIRST(&sc->sc_free_buf);
a1107 2
	TAILQ_REMOVE(&sc->sc_free_buf, buf, next);

d1111 5
a1115 11
	slot = &q->slots[q->cur];
	slot->buf = buf;

	hdr = (struct iwi_hdr *)slot->virtaddr;
	hdr->type = IWI_HDR_TYPE_DATA;
	hdr->flags = IWI_HDR_FLAG_IRQ;

	data = (struct iwi_data *)(hdr + 1);
	data->cmd = IWI_DATA_CMD_TX;
	data->len = htole16(m->m_pkthdr.len);
	data->flags = IWI_DATA_FLAG_NEED_ACK;
d1119 1
a1119 1
		data->wep_txkey = ic->ic_wep_txkey;
d1121 1
a1121 1
		data->flags |= IWI_DATA_FLAG_NO_WEP;
d1124 1
a1124 1
		data->flags |= IWI_DATA_FLAG_SHPREAMBLE;
d1126 2
a1127 2
	bcopy(wh, &data->wh, sizeof (struct ieee80211_frame));
	data->nseg = htole32(buf->map->dm_nsegs);
d1129 2
a1130 2
		data->seg_addr[i] = htole32(buf->map->dm_segs[i].ds_addr);
		data->seg_len[i]  = htole32(buf->map->dm_segs[i].ds_len);
d1133 3
a1135 3
	bus_dmamap_sync(sc->sc_dmat, q->map, q->cur * IWI_TX_SLOT_SIZE,
	    sizeof (struct iwi_hdr) + sizeof (struct iwi_data),
	    BUS_DMASYNC_PREWRITE);
d1140 1
a1140 1
	DPRINTFN(5, ("TX!DATA!%u!%u\n", data->len, data->nseg));
d1143 4
a1146 2
	q->cur = (q->cur + 1) % q->size;
	CSR_WRITE_4(sc, q->csr_write, q->cur);
d1167 1
a1167 1
		if (TAILQ_EMPTY(&sc->sc_free_buf)) {
a1314 263
int
iwi_init_buffers(struct iwi_softc *sc, int nbuf)
{
	struct iwi_buf *buf;
	int error, i;

	sc->nbuf = nbuf;
	sc->buf_list = malloc(nbuf * sizeof (struct iwi_buf), M_DEVBUF,
	    M_NOWAIT);
	if (sc->buf_list == NULL) {
		printf("%s: could not allocate buffers\n",
		    sc->sc_dev.dv_xname);
		error = ENOMEM;
		goto fail;
	}
	bzero(sc->buf_list, nbuf * sizeof (struct iwi_buf));

	TAILQ_INIT(&sc->sc_free_buf);
	for (i = 0, buf = sc->buf_list; i < nbuf; i++, buf++) {
		error = bus_dmamap_create(sc->sc_dmat, nbuf * MCLBYTES, nbuf,
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &buf->map);
		if (error != 0) {
			printf("%s: could not create buffer dma map",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
		TAILQ_INSERT_TAIL(&sc->sc_free_buf, buf, next);
	}

	return 0;

fail:	iwi_free_buffers(sc);
	return error;
}

void
iwi_free_buffers(struct iwi_softc *sc)
{
	struct iwi_buf *buf;
	int i;

	if (sc->buf_list != NULL) {
		for (i = 0, buf = sc->buf_list; i < sc->nbuf; i++, buf++) {
			if (buf->m != NULL) {
				m_freem(buf->m);
				bus_dmamap_unload(sc->sc_dmat, buf->map);
			}
			bus_dmamap_destroy(sc->sc_dmat, buf->map);
		}

		free(sc->buf_list, M_DEVBUF);
		sc->buf_list = NULL;
	}
}

int
iwi_init_tx_queue(struct iwi_softc *sc, int index, int size)
{
	struct iwi_tx_queue *q = &sc->txqueue[index];
	struct iwi_tx_slot *slot;
	int i, nsegs, error;

	/* Allocate DMA memory for transmission slots */
	error = bus_dmamap_create(sc->sc_dmat, size * IWI_TX_SLOT_SIZE, 1,
	    size * IWI_TX_SLOT_SIZE, 0, BUS_DMA_NOWAIT, &q->map);
	if (error != 0) {
		printf("%s: could not create dma map\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat, size * IWI_TX_SLOT_SIZE,
	    PAGE_SIZE, 0, &q->seg, 1, &nsegs, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not allocate dma memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &q->seg, nsegs,
	    size * IWI_TX_SLOT_SIZE, &q->virtaddr, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not map dma memory\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, q->map, q->virtaddr,
	    size * IWI_TX_SLOT_SIZE, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load dma memory\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	bzero(q->virtaddr, size * IWI_TX_SLOT_SIZE);

	q->slots = malloc(size * sizeof (struct iwi_tx_slot), M_DEVBUF,
	    M_NOWAIT);
	if (q->slots == NULL) {
		printf("%s: could not allocate tx slots\n",
		    sc->sc_dev.dv_xname);
		error = ENOMEM;
		goto fail;
	}
	bzero(q->slots, size * sizeof (struct iwi_tx_slot));
	for (i = 0, slot = q->slots; i < size; i++, slot++)
		slot->virtaddr = (u_char *)q->virtaddr + i * IWI_TX_SLOT_SIZE;

	q->size = size;
	q->old = q->size - 1;
	q->cur = 0;
	q->csr_read = IWI_CSR_TX_READ_INDEX + index * 4;
	q->csr_write = IWI_CSR_TX_WRITE_INDEX + index * 4;

	CSR_WRITE_4(sc, IWI_CSR_TX_BASE + index * 8,
	    q->map->dm_segs[0].ds_addr);
	CSR_WRITE_4(sc, IWI_CSR_TX_SIZE + index * 8, q->size);
	CSR_WRITE_4(sc, q->csr_read, 0);
	CSR_WRITE_4(sc, q->csr_write, q->cur);

	return 0;

fail:	iwi_free_tx_queue(sc, index);
	return error;
}

void
iwi_free_tx_queue(struct iwi_softc *sc, int index)
{
	struct iwi_tx_queue *q = &sc->txqueue[index];

	if (q->slots != NULL) {
		free(q->slots, M_DEVBUF);
		q->slots = NULL;
	}

	if (q->virtaddr != NULL) {
		bus_dmamap_unload(sc->sc_dmat, q->map);
		bus_dmamem_unmap(sc->sc_dmat, q->virtaddr,
		    q->size * IWI_TX_SLOT_SIZE);
		bus_dmamem_free(sc->sc_dmat, &q->seg, 1);
		q->virtaddr = NULL;
		bus_dmamap_destroy(sc->sc_dmat, q->map);
		q->map = NULL;
	}
}

int
iwi_init_rx_queue(struct iwi_softc *sc)
{
	struct iwi_rx_queue *q = &sc->rxqueue;
	struct iwi_rx_slot *slot;
	struct iwi_buf *buf;
	int error, i;

	q->slots = malloc(IWI_RX_NSLOTS * sizeof (struct iwi_rx_slot),
	    M_DEVBUF, M_NOWAIT);
	if (q->slots == NULL) {
		printf("%s: could not allocate rx slots\n",
		    sc->sc_dev.dv_xname);
		error = ENOMEM;
		goto fail;
	}
	bzero(q->slots, IWI_RX_NSLOTS * sizeof (struct iwi_rx_slot));
	for (i = 0, slot = q->slots; i < IWI_RX_NSLOTS; i++, slot++) {
		slot->csr = IWI_CSR_RX_SLOT_BASE + i * 4;

		buf = slot->buf = TAILQ_FIRST(&sc->sc_free_buf);
		TAILQ_REMOVE(&sc->sc_free_buf, buf, next);

		MGETHDR(buf->m, M_DONTWAIT, MT_DATA);
		if (buf->m == NULL) {
			printf("%s: could not allocate rx mbuf\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		MCLGET(buf->m, M_DONTWAIT);
		if (!(buf->m->m_flags & M_EXT)) {
			m_freem(buf->m);
			printf("%s: could not allocate rx mbuf cluster\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		
		error = bus_dmamap_load(sc->sc_dmat, buf->map,
		    mtod(buf->m, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
		if (error != 0) {
			printf("%s: could not map rxbuf dma memory\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		CSR_WRITE_4(sc, slot->csr, buf->map->dm_segs[0].ds_addr);
	}

	q->size = IWI_RX_NSLOTS;
	q->cur = q->size - 1;

	CSR_WRITE_4(sc, IWI_CSR_RX_READ_INDEX, 0);
	CSR_WRITE_4(sc, IWI_CSR_RX_WRITE_INDEX, q->cur);

	return 0;

fail:	iwi_free_rx_queue(sc);
	return error;
}

void
iwi_free_rx_queue(struct iwi_softc *sc)
{
	struct iwi_rx_queue *q = &sc->rxqueue;

	if (q->slots != NULL) {
		free(q->slots, M_DEVBUF);
		q->slots = NULL;
	}
}

int
iwi_init_queues(struct iwi_softc *sc)
{
	int i, error;

	if ((error = iwi_init_buffers(sc, 64 + IWI_RX_NSLOTS - 2)) != 0)
		goto fail;

	/*
	 * There are 5 different transmission queues. Queue 0 is used for
	 * transmitting host commands while queues 1 through 4 are used for
	 * transmitting data at different QoS levels. Only queues 0 and 1 are
	 * used at this time but firmware requires all queues to be correctly
	 * initialized.
	 */
	for (i = 0; i < 5; i++) {
		error = iwi_init_tx_queue(sc, i, (i != 0) ? 64 : 16);
		if (error != 0) {
			printf("%s: could not initialize tx queue %d\n",
			    sc->sc_dev.dv_xname, i);
			goto fail;
		}
	}

	if ((error = iwi_init_rx_queue(sc)) != 0)
		goto fail;

	return 0;

fail:	iwi_free_queues(sc);
	return error;
}

void
iwi_free_queues(struct iwi_softc *sc)
{
	int i;

	iwi_free_buffers(sc);
	iwi_free_rx_queue(sc);

	for (i = 0; i < 5; i++)
		iwi_free_tx_queue(sc, i);
}

d1754 1
a1754 1
	return iwi_cmd(sc, IWI_CMD_SCAN, &scan, sizeof scan, IWI_ASYNC_CMD);
d1777 1
a1777 1
		    sizeof config, IWI_ASYNC_CMD);
d1789 1
a1789 2
	error = iwi_cmd(sc, IWI_CMD_SET_ESSID, ni->ni_essid, ni->ni_esslen,
	    IWI_ASYNC_CMD);
d1800 1
a1800 1
	error = iwi_cmd(sc, IWI_CMD_SET_RATES, &rs, sizeof rs, IWI_ASYNC_CMD);
d1806 1
a1806 2
	error = iwi_cmd(sc, IWI_CMD_SET_SENSITIVITY, &data, sizeof data,
	    IWI_ASYNC_CMD);
d1824 1
a1824 2
	return iwi_cmd(sc, IWI_CMD_ASSOCIATE, &assoc, sizeof assoc,
	    IWI_ASYNC_CMD);
d1832 1
a1832 1
	int error;
d1852 40
a1891 5
	if ((error = iwi_init_queues(sc)) != 0) {
		printf("%s: could not initialize queues\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
d1940 2
d1946 18
a1963 1
	iwi_free_queues(sc);
a1973 1

@


1.12
log
@extend scan delay from 20ms to 100ms for each channel + minor consistency tweak
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.11 2004/11/24 20:57:25 damien Exp $  */
d238 2
a239 2
	ic->ic_caps =  IEEE80211_C_IBSS | IEEE80211_C_PMGT |
	    IEEE80211_C_TXPMGT | IEEE80211_C_WEP;
d1749 19
a1767 5
	power.mode = IWI_MODE_11B;
	power.nchan = 11;
	for (i = 0; i < 11; i++) {
		power.chan[i].chan = i + 1;
		power.chan[i].power = ic->ic_txpower / IWI_TXPOWER_RATIO;
a1768 10
	DPRINTF(("Setting .11b channels tx power\n"));
	error = iwi_cmd(sc, IWI_CMD_SET_TX_POWER, &power, sizeof power, 0);
	if (error != 0)
		return error;

	power.mode = IWI_MODE_11G;
	DPRINTF(("Setting .11g channels tx power\n"));
	error = iwi_cmd(sc, IWI_CMD_SET_TX_POWER, &power, sizeof power, 0);
	if (error != 0)
		return error;
a1863 1
	u_int16_t capinfo;
d1903 1
a1903 1
	data = htole32(IWI_RSSI2SENS(ni->ni_rssi));
d1917 1
a1917 15

	capinfo = 0;
	if (ic->ic_opmode == IEEE80211_M_IBSS)
		capinfo |= IEEE80211_CAPINFO_IBSS;
	else	/* IEEE80211_M_STA */
		capinfo |= IEEE80211_CAPINFO_ESS;
	if (ic->ic_flags & IEEE80211_F_WEPON)
		capinfo |= IEEE80211_CAPINFO_PRIVACY;
	if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) &&
	    IEEE80211_IS_CHAN_2GHZ(ni->ni_chan))
		capinfo |= IEEE80211_CAPINFO_SHORT_PREAMBLE;
	if (ic->ic_flags & IEEE80211_F_SHSLOT)
		capinfo |= IEEE80211_CAPINFO_SHORT_SLOTTIME;

	assoc.capinfo = htole16(capinfo);
@


1.11
log
@reset adapter in iwi_stop()
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.10 2004/11/24 20:50:55 damien Exp $  */
d1822 1
a1822 1
	memset(&scan, 0, sizeof scan);
d1824 1
a1824 1
	scan.intval = htole16(20);
@


1.10
log
@clear register 0x41, not 0x43 (endianness)
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.9 2004/11/24 20:44:10 damien Exp $  */
d2019 2
@


1.9
log
@fix interrupt handler
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.8 2004/11/23 21:28:22 damien Exp $  */
d188 1
a188 1
	data &= ~0x00ff0000;
@


1.8
log
@add support for 2915ABG adapters
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.7 2004/11/22 21:34:35 damien Exp $  */
d811 1
a811 1
	if ((r = CSR_READ_4(sc, IWI_CSR_INTR)) == 0)
d853 1
a853 1
	return 0;
@


1.7
log
@use the filesystem based firmware loader; ok deraadt@@
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.6 2004/11/22 19:52:59 damien Exp $  */
d80 8
d162 2
a163 7
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR (pa->pa_id) == PCI_VENDOR_INTEL &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_PRO_2200BG_3B)
		return 1;

	return 0;
d254 18
a271 1
	/* set supported .11b rates */
a272 2

	/* set supported .11g rates */
a1729 1
	config.bg_autodetect = 1;
d1771 11
a1781 1
	DPRINTF(("Setting supported rates\n"));
a1817 1
	struct ieee80211_channel *chan;
d1819 2
a1820 1
	int count;
d1826 1
d1828 6
a1833 6
	for (chan = ic->ic_channels;
	     chan <= &ic->ic_channels[IEEE80211_CHAN_MAX];
	     chan++) {
		if (IEEE80211_IS_CHAN_2GHZ(chan) &&
		    isset(ic->ic_chan_active, ieee80211_chan2ieee(ic, chan)))
			scan.channels[++count] = ieee80211_chan2ieee(ic, chan);
d1835 11
a1845 1
	scan.channels[0] = IWI_CHAN_2GHZ | count;
d1856 1
d1863 14
d1890 2
a1891 1
	rs.mode = IWI_MODE_11G;
d1908 2
a1909 1
	assoc.mode = IWI_MODE_11G;
@


1.6
log
@don't enable debugging by default
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.5 2004/10/28 23:06:10 brad Exp $  */
d46 1
d118 2
a119 4
int iwi_load_ucode(struct iwi_softc *, void *, int);
int iwi_load_firmware(struct iwi_softc *, void *, int);
int iwi_cache_firmware(struct iwi_softc *, void *);
void iwi_free_firmware(struct iwi_softc *);
a309 3
	if (sc->flags & IWI_FLAG_FW_CACHED)
		iwi_free_firmware(sc);

a1104 18
	case SIOCSLOADFW:
		/* only super-user can do that! */
		if ((error = suser(curproc, 0)) != 0)
			break;

		ifr = (struct ifreq *)data;
		error = iwi_cache_firmware(sc, ifr->ifr_data);
		break;

	case SIOCSKILLFW:
		/* only super-user can do that! */
		if ((error = suser(curproc, 0)) != 0)
			break;

		iwi_stop(ifp, 1);
		iwi_free_firmware(sc);
		break;

d1453 1
a1453 1
iwi_load_ucode(struct iwi_softc *sc, void *uc, int size)
d1455 2
d1458 16
a1473 1
	int ntries, i;
d1484 2
a1485 1
		return EIO;
d1503 1
a1503 1
	for (w = uc; size > 0; w++, size -= 2)
d1518 2
a1519 1
		return EIO;
d1528 2
a1529 1
	return 0;
d1535 1
a1535 1
iwi_load_firmware(struct iwi_softc *sc, void *fw, int size)
d1537 2
d1544 16
a1559 1
	int ntries, nsegs, error = 0;
d1567 1
a1567 1
		goto fail1;
d1579 1
a1579 1
		goto fail2;
d1587 1
a1587 1
		goto fail3;
d1594 1
a1594 1
		goto fail4;
d1658 1
a1658 1
		goto fail5;
d1676 1
a1676 1
		goto fail5;
d1679 6
a1684 5
fail5:	bus_dmamap_unload(sc->sc_dmat, map);
fail4:	bus_dmamem_unmap(sc->sc_dmat, virtaddr, size);
fail3:	bus_dmamem_free(sc->sc_dmat, &seg, 1);
fail2:	bus_dmamap_destroy(sc->sc_dmat, map);
	
a1687 72
/*
 * Store firmware into kernel memory so we can download it when we need to,
 * e.g when the adapter wakes up from suspend mode.
 */
int
iwi_cache_firmware(struct iwi_softc *sc, void *data)
{
	struct iwi_firmware *kfw = &sc->fw;
	struct iwi_firmware ufw;
	int error;

	if (sc->flags & IWI_FLAG_FW_CACHED)
		iwi_free_firmware(sc);

	if ((error = copyin(data, &ufw, sizeof ufw)) != 0)
		goto fail1;

	kfw->boot_size  = ufw.boot_size;
	kfw->ucode_size = ufw.ucode_size;
	kfw->main_size  = ufw.main_size;

	kfw->boot = malloc(kfw->boot_size, M_DEVBUF, M_NOWAIT);
	if (kfw->boot == NULL) {
		error = ENOMEM;
		goto fail1;
	}

	kfw->ucode = malloc(kfw->ucode_size, M_DEVBUF, M_NOWAIT);
	if (kfw->ucode == NULL) {
		error = ENOMEM;
		goto fail2;
	}

	kfw->main = malloc(kfw->main_size, M_DEVBUF, M_NOWAIT);
	if (kfw->main == NULL) {
		error = ENOMEM;
		goto fail3;
	}

	if ((error = copyin(ufw.boot, kfw->boot, kfw->boot_size)) != 0)
		goto fail4;

	if ((error = copyin(ufw.ucode, kfw->ucode, kfw->ucode_size)) != 0)
		goto fail4;

	if ((error = copyin(ufw.main, kfw->main, kfw->main_size)) != 0)
		goto fail4;

	DPRINTF(("Firmware cached: boot %u, ucode %u, main %u\n",
	    kfw->boot_size, kfw->ucode_size, kfw->main_size));

	sc->flags |= IWI_FLAG_FW_CACHED;

	return 0;

fail4:	free(kfw->boot, M_DEVBUF);
fail3:	free(kfw->ucode, M_DEVBUF);
fail2:	free(kfw->main, M_DEVBUF);
fail1:
	return error;
}

void
iwi_free_firmware(struct iwi_softc *sc)
{
	free(sc->fw.boot, M_DEVBUF);
	free(sc->fw.ucode, M_DEVBUF);
	free(sc->fw.main, M_DEVBUF);

	sc->flags &= ~IWI_FLAG_FW_CACHED;
}

d1888 1
a1888 1
	struct iwi_firmware *fw = &sc->fw;
a1890 6
	/* exit immediately if firmware has not been ioctl'd */
	if (!(sc->flags & IWI_FLAG_FW_CACHED)) {
		ifp->if_flags &= ~IFF_UP;
		return EIO;
	}

d1896 1
a1896 1
	if ((error = iwi_load_firmware(sc, fw->boot, fw->boot_size)) != 0) {
d1902 1
a1902 1
	if ((error = iwi_load_ucode(sc, fw->ucode, fw->ucode_size)) != 0) {
d1915 17
a1931 1
	if ((error = iwi_load_firmware(sc, fw->main, fw->main_size)) != 0) {
@


1.5
log
@the URL in if_iwi is no longer valid.

ok damien@@
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.4 2004/10/28 22:12:00 jcs Exp $  */
a138 2
#define IWI_DEBUG

d142 1
a142 1
int iwi_debug = 2;
@


1.4
log
@print our ether address when attaching like other drivers
same code as for ipw
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.3 2004/10/27 21:33:52 damien Exp $  */
d32 1
a32 1
 * http://www.intel.com/products/mobiletechnology/prowireless.htm
@


1.3
log
@Remove static for all non-inline functions.
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.2 2004/10/20 22:26:42 deraadt Exp $  */
d226 1
a226 1
	printf(": %s\n", intrstr);
d251 2
@


1.2
log
@defined in pcidevs now
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.1 2004/10/20 12:50:48 deraadt Exp $  */
d85 11
a95 11
static int iwi_match(struct device *, void *, void *);
static void iwi_attach(struct device *, struct device *, void *);
static int iwi_detach(struct device *, int);
static int iwi_media_change(struct ifnet *);
static void iwi_media_status(struct ifnet *, struct ifmediareq *);
static u_int16_t iwi_read_prom_word(struct iwi_softc *, u_int8_t);
static int iwi_newstate(struct ieee80211com *, enum ieee80211_state, int);
static void iwi_fix_channel(struct ieee80211com *, struct mbuf *);
static void iwi_frame_intr(struct iwi_softc *, struct iwi_rx_slot *,
    struct iwi_buf *, struct iwi_frame *);
static void iwi_notification_intr(struct iwi_softc *, struct iwi_buf *,
d97 29
a125 29
static void iwi_rx_intr(struct iwi_softc *);
static void iwi_tx_intr(struct iwi_softc *, int);
static int iwi_intr(void *);
static int iwi_cmd(struct iwi_softc *, u_int8_t, void *, u_int8_t, int);
static int iwi_tx_start(struct ifnet *, struct mbuf *, struct ieee80211_node *);
static void iwi_start(struct ifnet *);
static void iwi_watchdog(struct ifnet *);
static int iwi_get_table0(struct iwi_softc *, u_int32_t *);
static int iwi_get_radio(struct iwi_softc *, int *);
static int iwi_ioctl(struct ifnet *, u_long, caddr_t);
static int iwi_init_buffers(struct iwi_softc *, int);
static void iwi_free_buffers(struct iwi_softc *);
static int iwi_init_tx_queue(struct iwi_softc *, int, int);
static void iwi_free_tx_queue(struct iwi_softc *, int);
static int iwi_init_rx_queue(struct iwi_softc *);
static void iwi_free_rx_queue(struct iwi_softc *);
static int iwi_init_queues(struct iwi_softc *);
static void iwi_free_queues(struct iwi_softc *);
static void iwi_stop_master(struct iwi_softc *);
static int iwi_reset(struct iwi_softc *);
static int iwi_load_ucode(struct iwi_softc *, void *, int);
static int iwi_load_firmware(struct iwi_softc *, void *, int);
static int iwi_cache_firmware(struct iwi_softc *, void *);
static void iwi_free_firmware(struct iwi_softc *);
static int iwi_config(struct iwi_softc *);
static int iwi_scan(struct iwi_softc *);
static int iwi_auth_and_assoc(struct iwi_softc *);
static int iwi_init(struct ifnet *);
static void iwi_stop(struct ifnet *, int);
d154 1
a154 1
static int
d169 1
a169 1
static void
d303 1
a303 1
static int
d330 1
a330 1
static int
d345 1
a345 1
static void
d404 1
a404 1
static int
d432 1
a432 1
static u_int16_t
d485 1
a485 1
static void
d518 1
a518 1
static void
d630 1
a630 1
static void
d711 1
a711 1
static void
d753 1
a753 1
static void
d791 1
a791 1
static int
d842 1
a842 1
static int
d877 1
a877 1
static int
d972 1
a972 1
static void
d1020 1
a1020 1
static void
d1039 1
a1039 1
static int
d1053 1
a1053 1
static int
d1062 1
a1062 1
static int
d1154 1
a1154 1
static int
d1189 1
a1189 1
static void
d1209 1
a1209 1
static int
d1278 1
a1278 1
static void
d1299 1
a1299 1
static int
d1361 1
a1361 1
static void
d1372 1
a1372 1
static int
d1405 1
a1405 1
static void
d1417 1
a1417 1
static void
d1440 1
a1440 1
static int
d1474 1
a1474 1
static int
d1536 1
a1536 1
static int
d1676 1
a1676 1
static int
d1734 1
a1734 1
static void
d1744 1
a1744 1
static int
d1843 1
a1843 1
static int
d1869 1
a1869 1
static int
d1940 1
a1940 1
static int
d2003 1
a2003 1
static void
@


1.1
log
@support for Intel 2100/2200BG/2915ABG wireless devices written by
damien.bergamini@@free.fr. This gets imported even though there is no
firmware in the tree.  This is a ridiculous situation: everything is
free, everything works, except Intel will not let us put a little
dinky firmware flat file into OpenBSD.  So OpenBSD is ready for Intel
whenever they are.

Are you a consumer?  Do you want to see this changed -- contact
jketreno@@linux.intel.com and tell him how you feel about this.  He is
likely someone who cannot do anything about it, though.  If anyone can
work up or down the chain around his department and get me contact
information for various people, I will compile and later publish such
a list.  Go do it people -- this is how things will change.  Get me
email addresses and phone numbers.
@
text
@d1 1
a1 1
/*	$Id: if_iwi.c,v 1.1 2004/10/17 21:55:23 damien Exp $  */
a152 2

#define PCI_PRODUCT_INTEL_PRO_2200BG_3B	0x4220
@

