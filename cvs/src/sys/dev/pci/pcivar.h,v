head	1.69;
access;
symbols
	OPENBSD_6_1:1.69.0.12
	OPENBSD_6_1_BASE:1.69
	OPENBSD_6_0:1.69.0.14
	OPENBSD_6_0_BASE:1.69
	OPENBSD_5_9:1.69.0.2
	OPENBSD_5_9_BASE:1.69
	OPENBSD_5_8:1.69.0.10
	OPENBSD_5_8_BASE:1.69
	OPENBSD_5_7:1.69.0.8
	OPENBSD_5_7_BASE:1.69
	OPENBSD_5_6:1.69.0.6
	OPENBSD_5_6_BASE:1.69
	OPENBSD_5_5:1.69.0.4
	OPENBSD_5_5_BASE:1.69
	OPENBSD_5_4:1.67.0.4
	OPENBSD_5_4_BASE:1.67
	OPENBSD_5_3:1.67.0.2
	OPENBSD_5_3_BASE:1.67
	OPENBSD_5_2:1.66.0.6
	OPENBSD_5_2_BASE:1.66
	OPENBSD_5_1_BASE:1.66
	OPENBSD_5_1:1.66.0.4
	OPENBSD_5_0:1.66.0.2
	OPENBSD_5_0_BASE:1.66
	OPENBSD_4_9:1.63.0.2
	OPENBSD_4_9_BASE:1.63
	OPENBSD_4_8:1.59.0.6
	OPENBSD_4_8_BASE:1.59
	OPENBSD_4_7:1.59.0.2
	OPENBSD_4_7_BASE:1.59
	OPENBSD_4_6:1.59.0.4
	OPENBSD_4_6_BASE:1.59
	OPENBSD_4_5:1.57.0.6
	OPENBSD_4_5_BASE:1.57
	OPENBSD_4_4:1.57.0.4
	OPENBSD_4_4_BASE:1.57
	OPENBSD_4_3:1.57.0.2
	OPENBSD_4_3_BASE:1.57
	OPENBSD_4_2:1.54.0.2
	OPENBSD_4_2_BASE:1.54
	OPENBSD_4_1:1.52.0.2
	OPENBSD_4_1_BASE:1.52
	OPENBSD_4_0:1.48.0.2
	OPENBSD_4_0_BASE:1.48
	OPENBSD_3_9:1.42.0.4
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.42.0.2
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.38.0.2
	OPENBSD_3_6_BASE:1.38
	SMP_SYNC_A:1.35
	SMP_SYNC_B:1.35
	OPENBSD_3_5:1.35.0.2
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	UBC_SYNC_A:1.30
	OPENBSD_3_3:1.29.0.2
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	UBC_SYNC_B:1.25
	UBC:1.21.0.4
	UBC_BASE:1.21
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.4
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.17.0.2
	OPENBSD_2_7_BASE:1.17
	SMP:1.16.0.4
	SMP_BASE:1.16
	kame_19991208:1.16
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.13.0.4
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.69
date	2013.08.08.17.54.11;	author kettenis;	state Exp;
branches;
next	1.68;

1.68
date	2013.08.07.07.29.19;	author mpi;	state Exp;
branches;
next	1.67;

1.67
date	2012.09.19.23.01.21;	author kettenis;	state Exp;
branches;
next	1.66;

1.66
date	2011.05.30.19.09.46;	author kettenis;	state Exp;
branches;
next	1.65;

1.65
date	2011.05.21.10.34.53;	author kettenis;	state Exp;
branches;
next	1.64;

1.64
date	2011.05.14.13.23.38;	author kettenis;	state Exp;
branches;
next	1.63;

1.63
date	2010.09.07.16.21.45;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2010.09.05.18.14.33;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2010.08.27.20.31.55;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2010.08.17.19.14.52;	author kettenis;	state Exp;
branches;
next	1.59;

1.59
date	2009.05.05.14.16.17;	author kettenis;	state Exp;
branches;
next	1.58;

1.58
date	2009.04.06.20.51.48;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2007.12.31.19.13.36;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2007.11.26.13.20.28;	author jsg;	state Exp;
branches;
next	1.55;

1.55
date	2007.10.22.03.08.53;	author fgsch;	state Exp;
branches;
next	1.54;

1.54
date	2007.08.01.21.43.03;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2007.05.21.22.10.45;	author kettenis;	state Exp;
branches;
next	1.52;

1.52
date	2007.02.23.21.34.32;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2007.01.02.19.22.38;	author mbalmer;	state Exp;
branches;
next	1.50;

1.50
date	2006.12.14.17.36.12;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2006.12.11.19.47.37;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2006.04.07.01.04.49;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2006.03.22.00.36.03;	author jsg;	state Exp;
branches;
next	1.46;

1.46
date	2006.03.19.21.25.04;	author brad;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.19.02.43.38;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.13.20.10.49;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.11.22.08.07;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2005.06.29.03.53.28;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2005.06.02.21.55.33;	author mickey;	state Exp;
branches;
next	1.40;

1.40
date	2004.12.07.02.11.24;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2004.11.30.22.30.47;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2004.08.09.22.26.24;	author pefo;	state Exp;
branches;
next	1.37;

1.37
date	2004.08.06.21.54.09;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2004.06.25.08.57.10;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.31.15.22.26;	author drahn;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.28.01.39.40;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.12.22.56.46;	author hshoexer;	state Exp;
branches;
next	1.32;

1.32
date	2003.10.06.16.07.45;	author fgsch;	state Exp;
branches;
next	1.31;

1.31
date	2003.09.29.18.53.58;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2003.04.27.11.22.54;	author ho;	state Exp;
branches;
next	1.29;

1.29
date	2003.02.28.15.36.39;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2003.02.28.15.26.23;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.28.15.14.08;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.12.20.17.03;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.03.20.52.24;	author nate;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.19.05.17.37;	author art;	state Exp;
branches
	1.21.4.1;
next	1.20;

1.20
date	2001.07.20.05.56.25;	author csapuntz;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.12.15.40.33;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.09.16.09.09;	author chris;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.26.22.38.22;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	99.07.18.03.20.18;	author csapuntz;	state Exp;
branches
	1.16.4.1;
next	1.15;

1.15
date	99.06.16.14.38.36;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	99.02.01.16.35.49;	author pefo;	state Exp;
branches;
next	1.13;

1.13
date	98.01.20.18.40.36;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.10.11.11.14.16;	author pefo;	state Exp;
branches;
next	1.11;

1.11
date	97.03.12.19.52.56;	author pefo;	state Exp;
branches;
next	1.10;

1.10
date	97.01.24.19.34.16;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	96.11.28.23.28.14;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.11.12.20.30.59;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.25.51;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.18.23.48.08;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.03.22.18.27.25;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.03.19.21.10.39;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.20.04.36.19;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.06.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.40;	author deraadt;	state Exp;
branches;
next	;

1.16.4.1
date	2001.05.14.22.25.56;	author niklas;	state Exp;
branches;
next	1.16.4.2;

1.16.4.2
date	2001.07.04.10.43.00;	author niklas;	state Exp;
branches;
next	1.16.4.3;

1.16.4.3
date	2001.10.31.03.22.47;	author nate;	state Exp;
branches;
next	1.16.4.4;

1.16.4.4
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.16.4.5;

1.16.4.5
date	2002.03.28.15.35.59;	author niklas;	state Exp;
branches;
next	1.16.4.6;

1.16.4.6
date	2003.03.28.00.38.25;	author niklas;	state Exp;
branches;
next	1.16.4.7;

1.16.4.7
date	2003.05.13.19.35.09;	author ho;	state Exp;
branches;
next	1.16.4.8;

1.16.4.8
date	2004.02.19.10.56.29;	author niklas;	state Exp;
branches;
next	;

1.21.4.1
date	2002.01.31.22.55.36;	author niklas;	state Exp;
branches;
next	1.21.4.2;

1.21.4.2
date	2002.06.11.03.42.27;	author art;	state Exp;
branches;
next	1.21.4.3;

1.21.4.3
date	2002.10.29.00.33.29;	author art;	state Exp;
branches;
next	1.21.4.4;

1.21.4.4
date	2003.05.19.22.19.08;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.69
log
@Make it possible for graphics drivers to opt-out of VGA arbitration.

The idea is that as soon the kernel driver switches out of vga text
mode, it can disable decoding of legacy vga io and mmio and call
pci_disable_legacy_vga() to take itself out of arbitration.  The
PCIGETVGA ioctl is extended such that it returns the legacy decoding
state of a device.  The X server can then query this state for all
graphics devices in the system (through libpciaccess) and decide
whether it needs to do arbitration.

ok jsg@@
@
text
@/*	$OpenBSD: pcivar.h,v 1.68 2013/08/07 07:29:19 mpi Exp $	*/
/*	$NetBSD: pcivar.h,v 1.23 1997/06/06 23:48:05 thorpej Exp $	*/

/*
 * Copyright (c) 1996 Christopher G. Demetriou.  All rights reserved.
 * Copyright (c) 1994 Charles Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _DEV_PCI_PCIVAR_H_
#define	_DEV_PCI_PCIVAR_H_

/*
 * Definitions for PCI autoconfiguration.
 *
 * This file describes types and functions which are used for PCI
 * configuration.  Some of this information is machine-specific, and is
 * provided by pci_machdep.h.
 */

#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/extent.h>
#include <machine/bus.h>
#include <dev/pci/pcireg.h>

/*
 * Structures and definitions needed by the machine-dependent header.
 */
typedef u_int32_t pcireg_t;		/* configuration space register XXX */

/*
 * Power Management (PCI 2.2)
 */
#define PCI_PWR_D0	0
#define PCI_PWR_D1	1
#define PCI_PWR_D2	2
#define PCI_PWR_D3	3

#ifdef _KERNEL

struct pcibus_attach_args;
struct pci_softc;

/*
 * Machine-dependent definitions.
 */
#if defined(__alpha__)
#include <alpha/pci/pci_machdep.h>
#elif defined(__i386__)
#include <i386/pci/pci_machdep.h>
#elif defined(__sgi__)
#include <sgi/pci/pci_machdep.h>
#else
#include <machine/pci_machdep.h>
#endif

/*
 * PCI bus attach arguments.
 */
struct pcibus_attach_args {
	char	*pba_busname;		/* XXX should be common */
	bus_space_tag_t pba_iot;	/* pci i/o space tag */
	bus_space_tag_t pba_memt;	/* pci mem space tag */
	bus_dma_tag_t pba_dmat;		/* DMA tag */
	pci_chipset_tag_t pba_pc;
	int		pba_flags;	/* flags; see below */

	struct extent	*pba_ioex;
	struct extent	*pba_memex;
	struct extent	*pba_pmemex;
	struct extent	*pba_busex;

	int		pba_domain;	/* PCI domain */
	int		pba_bus;	/* PCI bus number */

	/*
	 * Pointer to the pcitag of our parent bridge.  If there is no
	 * parent bridge, then we assume we are a root bus.
	 */
	pcitag_t	*pba_bridgetag;
	pci_intr_handle_t *pba_bridgeih;

	/*
	 * Interrupt swizzling information.  These fields
	 * are only used by secondary busses.
	 */
	u_int		pba_intrswiz;	/* how to swizzle pins */
	pcitag_t	pba_intrtag;	/* intr. appears to come from here */
};

/*
 * PCI device attach arguments.
 */
struct pci_attach_args {
	bus_space_tag_t pa_iot;		/* pci i/o space tag */
	bus_space_tag_t pa_memt;	/* pci mem space tag */
	bus_dma_tag_t pa_dmat;		/* DMA tag */
	pci_chipset_tag_t pa_pc;
	int		pa_flags;	/* flags; see below */

	struct extent	*pa_ioex;
	struct extent	*pa_memex;
	struct extent	*pa_pmemex;
	struct extent	*pa_busex;

	u_int           pa_domain;
	u_int           pa_bus;
	u_int		pa_device;
	u_int		pa_function;
	pcitag_t	pa_tag;
	pcireg_t	pa_id, pa_class;

	pcitag_t	*pa_bridgetag;
	pci_intr_handle_t *pa_bridgeih;

	/*
	 * Interrupt information.
	 *
	 * "Intrline" is used on systems whose firmware puts
	 * the right routing data into the line register in
	 * configuration space.  The rest are used on systems
	 * that do not.
	 */
	u_int		pa_intrswiz;	/* how to swizzle pins if ppb */
	pcitag_t	pa_intrtag;	/* intr. appears to come from here */
	pci_intr_pin_t	pa_intrpin;	/* intr. appears on this pin */
	pci_intr_line_t	pa_intrline;	/* intr. routing information */
	pci_intr_pin_t	pa_rawintrpin;	/* unswizzled pin */
};

/*
 * Flags given in the bus and device attachment args.
 *
 * OpenBSD doesn't actually use them yet -- csapuntz@@cvs.openbsd.org
 */
#define	PCI_FLAGS_IO_ENABLED	0x01		/* I/O space is enabled */
#define	PCI_FLAGS_MEM_ENABLED	0x02		/* memory space is enabled */
#define	PCI_FLAGS_MRL_OKAY	0x04		/* Memory Read Line okay */
#define	PCI_FLAGS_MRM_OKAY	0x08		/* Memory Read Multiple okay */
#define	PCI_FLAGS_MWI_OKAY	0x10		/* Memory Write and Invalidate
						   okay */
#define	PCI_FLAGS_MSI_ENABLED	0x20		/* Message Signaled Interrupt
						   enabled */

/*
 *
 */
struct pci_quirkdata {
	pci_vendor_id_t		vendor;		/* Vendor ID */
	pci_product_id_t	product;	/* Product ID */
	int			quirks;		/* quirks; see below */
};
#define	PCI_QUIRK_MULTIFUNCTION		1
#define	PCI_QUIRK_MONOFUNCTION		2

struct pci_softc {
	struct device sc_dev;
	bus_space_tag_t sc_iot, sc_memt;
	bus_dma_tag_t sc_dmat;
	pci_chipset_tag_t sc_pc;
	int sc_flags;
	struct extent *sc_ioex;
	struct extent *sc_memex;
	struct extent *sc_pmemex;
	struct extent *sc_busex;
	LIST_HEAD(, pci_dev) sc_devs;
	int sc_domain, sc_bus, sc_maxndevs;
	pcitag_t *sc_bridgetag;
	pci_intr_handle_t *sc_bridgeih;
	u_int sc_intrswiz;
	pcitag_t sc_intrtag;
};

extern int pci_ndomains;
extern int pci_dopm;

/*
 * Locators devices that attach to 'pcibus', as specified to config.
 */
#define	pcibuscf_bus		cf_loc[0]
#define	PCIBUS_UNK_BUS		-1		/* wildcarded 'bus' */

/*
 * Locators for PCI devices, as specified to config.
 */
#define	pcicf_dev		cf_loc[0]
#define	PCI_UNK_DEV		-1		/* wildcarded 'dev' */

#define	pcicf_function		cf_loc[1]
#define	PCI_UNK_FUNCTION	-1		/* wildcarded 'function' */

/*
 * Configuration space access and utility functions.  (Note that most,
 * e.g. make_tag, conf_read, conf_write are declared by pci_machdep.h.)
 */
int	pci_mapreg_probe(pci_chipset_tag_t, pcitag_t, int, pcireg_t *);
pcireg_t pci_mapreg_type(pci_chipset_tag_t, pcitag_t, int);
int	pci_mapreg_info(pci_chipset_tag_t, pcitag_t, int, pcireg_t,
	    bus_addr_t *, bus_size_t *, int *);
int	pci_mapreg_map(struct pci_attach_args *, int, pcireg_t, int,
	    bus_space_tag_t *, bus_space_handle_t *, bus_addr_t *,
	    bus_size_t *, bus_size_t);


int	pci_io_find(pci_chipset_tag_t, pcitag_t, int, bus_addr_t *,
	    bus_size_t *);
int	pci_mem_find(pci_chipset_tag_t, pcitag_t, int, bus_addr_t *,
	    bus_size_t *, int *);

int	pci_get_capability(pci_chipset_tag_t, pcitag_t, int,
	    int *, pcireg_t *);
int	pci_get_ht_capability(pci_chipset_tag_t, pcitag_t, int,
	    int *, pcireg_t *);

struct pci_matchid {
	pci_vendor_id_t		pm_vid;
	pci_product_id_t	pm_pid;
};

int pci_matchbyid(struct pci_attach_args *, const struct pci_matchid *, int);
int pci_get_powerstate(pci_chipset_tag_t, pcitag_t);
int pci_set_powerstate(pci_chipset_tag_t, pcitag_t, int);
void pci_disable_legacy_vga(struct device *);

/*
 * Vital Product Data (PCI 2.2)
 */
int pci_vpd_read(pci_chipset_tag_t, pcitag_t, int, int, pcireg_t *);
int pci_vpd_write(pci_chipset_tag_t, pcitag_t, int, int, pcireg_t *);

/*
 * Helper functions for autoconfiguration.
 */
const char *pci_findvendor(pcireg_t);
const char *pci_findproduct(pcireg_t);
int	pci_find_device(struct pci_attach_args *pa,
	    int (*match)(struct pci_attach_args *));
int	pci_probe_device(struct pci_softc *, pcitag_t tag,
	    int (*)(struct pci_attach_args *), struct pci_attach_args *);
int	pci_detach_devices(struct pci_softc *, int);
void	pci_devinfo(pcireg_t, pcireg_t, int, char *, size_t);
const struct pci_quirkdata *
	pci_lookup_quirkdata(pci_vendor_id_t, pci_product_id_t);
void	pciagp_set_pchb(struct pci_attach_args *);

#endif /* _KERNEL */
#endif /* _DEV_PCI_PCIVAR_H_ */
@


1.68
log
@Mimic what's done on sparc64 and parse the OpenFirmware device tree to
enumerate the pci devices.  This allow us to not store the interrupt
vector in the interrupt line register and to not try to attach pci
devices disabled by firmware.

With inputs from and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.67 2012/09/19 23:01:21 kettenis Exp $	*/
d248 1
@


1.67
log
@Add resource tracking for PCI bus numbers.  This will allow us to prevent
attaching the same PCI bus twice and in the long run this will allown us
to hot plug PCI busses and support CardBus on machines where the firmware
doesn't assign a bus number to CardBus devices.

While there, print a bit more information for memory and io conflicts.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.66 2011/05/30 19:09:46 kettenis Exp $	*/
a75 2
#elif defined(__powerpc__)
#include <powerpc/pci/pci_machdep.h>
@


1.66
log
@Enable MSI for HyperTransport devices that have MSI remapping enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.65 2011/05/21 10:34:53 kettenis Exp $	*/
d98 1
d131 1
d192 1
@


1.65
log
@Introduce a flag to indicate that it is ok to use MSI on a certain PCI bus
and/or device.  Discussed with miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.64 2011/05/14 13:23:38 kettenis Exp $	*/
d234 4
a237 2
int pci_get_capability(pci_chipset_tag_t, pcitag_t, int,
			    int *, pcireg_t *);
@


1.64
log
@Pass flags down the PCI bus hierarchy.  Soon to be used to selectively enable
Message Signalled Interrupts.

ok krw@@ with a fix pointed out by many
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.63 2010/09/07 16:21:45 deraadt Exp $	*/
d167 2
@


1.63
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.62 2010/09/05 18:14:33 kettenis Exp $	*/
d93 1
d184 1
@


1.62
log
@Add an ioctl to figure out the non-sticky bits in PCI BARs used for determining
the size of those BARs.  Make pcidump use this new ioctl to print the size
of PCI BARs.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.61 2010/08/27 20:31:55 kettenis Exp $	*/
a185 1
	void *sc_powerhook;
@


1.61
log
@Make PCI Power Management optional, and only enable it when acpi(4) attaches.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.60 2010/08/17 19:14:52 kettenis Exp $	*/
d255 1
a255 1
			int (*match)(struct pci_attach_args *));
@


1.60
log
@Power management for PCI devices.  For now just put everything in the D3
(deepest sleep) state upon suspend, and restore power upon resume.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.59 2009/05/05 14:16:17 kettenis Exp $	*/
d196 1
@


1.59
log
@Add extents for prefetchable memory mapped I/O.  Should remove conflict
messages for devices using prefetchable memory sitting behind bridges.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.58 2009/04/06 20:51:48 kettenis Exp $	*/
d239 1
@


1.58
log
@Set a first step on the road towards proper accounting of PCI resources by
keeping a per-bus extent containing the address space available to the bus.
Address space assigned to devices will be removed from these extents when
we attach a bus.  And when we try to map a PCI BAR that hasn't had address
space assigned to it, we will allocate free space from this extent.

This won't do anything until the parent devices actually allocate and
initialize the extents.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.57 2007/12/31 19:13:36 kettenis Exp $	*/
d96 1
d128 1
d185 1
@


1.57
log
@On some machines we get hotplug interrupts when they're resumed, so don't
rescan the pci bus if it already has devices attached to it.  Make sure we
clear the list of attached devices when we receive a surprise removal
interrupt.  Fixes kurt@@'s T43.

ok miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.56 2007/11/26 13:20:28 jsg Exp $	*/
d46 2
d94 3
d125 3
d181 2
@


1.56
log
@Add PCI VPD read/write functions from NetBSD required for some things
dlg is playing with.

'put it in' dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.55 2007/10/22 03:08:53 fgsch Exp $	*/
d243 1
@


1.55
log
@Add pci_set_powerstate() to change the pm state for a given device.
ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.54 2007/08/01 21:43:03 deraadt Exp $	*/
d227 6
@


1.54
log
@cats went away
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.53 2007/05/21 22:10:45 kettenis Exp $	*/
d226 1
@


1.53
log
@Implement deep interrupt swizzling by mapping all four PCI interrupt pins
for PCI-PCI bridges and passing the mapping to the attached bus device.
MD code can use these when mapping PCI device interrupts.  This diff adds
such code for amd64 and i386.  This fixes interrupt mapping for devices that
sit behind two PCI-PCI bridges where the firmware only provides a mapping
for the first PCI-PCI bridge.

tested by sturm@@, krw@@, and a few others, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.52 2007/02/23 21:34:32 deraadt Exp $	*/
a73 2
#elif defined(__cats__)
#include <cats/pci/pci_machdep.h>
@


1.52
log
@hide all the things userland should not see, so that this file can be
pulled into get at pcireg_t.  otherwise it would hit nasty _KERNEL stuff;
discussed with miod and dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.51 2007/01/02 19:22:38 mbalmer Exp $	*/
d102 1
d130 1
d179 1
@


1.51
log
@Provide a new function, pci_findproduct(), which is analog to pci_findvendor().
Use these two functions in pci_devinfo() to remove some duplicated code and
make it easier to read.  Remove two now unused variables.  This shrinks the
size of the resulting object code.

Drivers (or other kernel code) can now get at the PCI vendor and/or product
strings using pci_findvendor() and pci_findproduct().

ok claudio, deraadt, mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.50 2006/12/14 17:36:12 kettenis Exp $	*/
d53 11
d240 1
a240 8
/*
 * Power Management (PCI 2.2)
 */
#define PCI_PWR_D0	0
#define PCI_PWR_D1	1
#define PCI_PWR_D2	2
#define PCI_PWR_D3	3

@


1.50
log
@Make pci subsystem aware of domains.  Each host bridge gets assigned a unique
domain number such that we can distinguish between busses with the same bus
number that are behind different host bridges.  Domains can be accessed by
using different device nodes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.49 2006/12/11 19:47:37 kettenis Exp $	*/
d219 1
@


1.49
log
@On i386, swizzle interrupts for devices for which we don't have explicit
inetrrupt routing information.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.48 2006/04/07 01:04:49 brad Exp $	*/
d83 1
d110 2
a112 1
	u_int           pa_bus;
d164 1
a164 1
	int sc_bus, sc_maxndevs;
d169 2
@


1.48
log
@implement a check whether a BAR is present at all at a given
configuration space address, pci_mapreg_probe().

From NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.47 2006/03/22 00:36:03 jsg Exp $	*/
d114 2
@


1.47
log
@Add pci_find_device() a helper function for enumerating the
PCI bus, from NetBSD.  This is useful for things like finding
another device in a driver ie ISA bridge in pciide.

ok brad@@ grange@@, looks ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.46 2006/03/19 21:25:04 brad Exp $	*/
d185 1
@


1.46
log
@- check HDRTYPE early, and ignore if it is not supported (n > 2).
- defer access to interrupt configuration register, as its existence depends on
  HDRTYPE.

From itojun NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.45 2006/03/19 02:43:38 brad Exp $	*/
d212 2
@


1.45
log
@rev 1.86

make the "generic" PCI bus enumeration code the standard case which
gets used if nothing else is defined in MD headers,
introduce a "PCI_MACHDEP_ENUMERATE_BUS" CPP definition which can
be used by MD headers (just 1 port atm) to plug in special code

rev 1.62

* Implement a machine-dependent pci_enumerate_bus() for sparc64 which
  uses OFW device nodes to enumerate the bus.  When a PCI bus that is
  behind a bridge is attached, pci_attach_hook() allocates a new PCI
  chipset tag for the new bus and sets it's "curnode" to the OFW node
  of the bridge.  This is used as a starting point when enumerating
  that bus.  Root busses get the OFW node of the host bridge (psycho).

rev 1.59

Split the code that enumerates the PCI bus and that actually probes
for a device into two functions:

* pci_probe_device() actually probes/attaches the device specified
  by the provide pcitag_t.

* pci_enumerate_bus() enumerates the bus, and calls pci_probe_device()
  for each device on the bus.  A pci_enumerate_bus_generic() is provided
  which implements the old method of doing this: If something found at
  dev0/func0, determine number of functions and probe each one.

From NetBSD

ok kettenis@@

Tested on a good number of amd64/i386/macppc/sparc64 systems
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.44 2006/03/13 20:10:49 brad Exp $	*/
d150 2
a151 1
#define	PCI_QUIRK_MULTIFUNCTION		0x00000001
@


1.44
log
@* Add "pcitag_t *pba_bridgetag" to pci_attach_args.  This is set to
  NULL for root PCI busses.  For busses behind a bridge, it points to
  a persistent copy of the bridge's pcitag_t.  This can be very useful
  for machine-dependent PCI bus enumeration code.

From NetBSD

ok grange@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.43 2006/03/11 22:08:07 brad Exp $	*/
d154 2
d159 1
a159 1
	int sc_bus;
d161 2
d211 2
@


1.43
log
@move PCI softc struct from pci.c to pcivar.h

ok krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.42 2005/06/29 03:53:28 brad Exp $	*/
d86 6
d158 1
@


1.42
log
@add some Power Management constants

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.41 2005/06/02 21:55:33 mickey Exp $	*/
d45 1
d54 1
d145 8
@


1.41
log
@use much simpler switch for pci_machdep.h; ok drahn@@ whatever tdr (;
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.40 2004/12/07 02:11:24 brad Exp $	*/
d194 8
@


1.40
log
@Remove the PCI-ISA bridge callback mechanism; it's no longer needed.

From NetBSD

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.39 2004/11/30 22:30:47 mickey Exp $	*/
d57 1
a57 4
#if (__alpha__ + __atari__ + __i386__ + __cats__ + __powerpc__ + __sparc64__ + __hppa__ +__amd64__ + __sgi__ != 1)
#error COMPILING FOR UNSUPPORTED MACHINE, OR MORE THAN ONE.
#endif
#if __alpha__
d59 1
a59 5
#endif
#if __atari__
#include <atari/pci/pci_machdep.h>
#endif
#if __i386__
d61 1
a61 2
#endif
#if __cats__
d63 1
a63 2
#endif
#if __powerpc__
d65 1
a65 14
#endif
#if __sparc64__
#include <sparc64/include/pci_machdep.h>
#endif
#if __hppa64__
#include <hppa64/include/pci_machdep.h>
#endif
#if __hppa__
#include <hppa/include/pci_machdep.h>
#endif
#if __amd64__
#include <amd64/include/pci_machdep.h>
#endif
#if __sgi__
d67 2
@


1.39
log
@add hppa64 hook
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.38 2004/08/09 22:26:24 pefo Exp $	*/
a210 1
void	set_pci_isa_bridge_callback(void (*)(void *), void *);
@


1.38
log
@remove some old stuff and clean up. arc and galileo is gone.
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.37 2004/08/06 21:54:09 mickey Exp $	*/
d77 3
@


1.37
log
@sgi support; from pefo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.36 2004/06/25 08:57:10 art Exp $	*/
d57 1
a57 1
#if (__alpha__ + __atari__ + __i386__ + __cats__ + __powerpc__ + __galileo__ + __sparc64__ + __hppa__ +__amd64__ + __sgi__ != 1)
a68 3
#if __arc__
#include <arc/pci/pci_machdep.h>
#endif
d75 2
a76 5
#if __galileo__
#include <galileo/pci/pci_machdep.h>
#endif
#if __sgi__
#include <sgi/pci/pci_machdep.h>
a80 3
#if __sparc64__
#include <sparc64/include/pci_machdep.h>
#endif
d83 3
@


1.36
log
@Provide information about the raw (unswizzled) intrrupt pin in
pci_attach_args.
drahn@@ deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.35 2004/01/31 15:22:26 drahn Exp $	*/
d57 1
a57 1
#if (__alpha__ + __atari__ + __i386__ + __cats__ + __powerpc__ + __galileo__ + __sparc64__ + __hppa__ +__amd64__ != 1)
d80 3
@


1.35
log
@Add pci_machdep hook for cats. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.34 2004/01/28 01:39:40 mickey Exp $	*/
d139 1
@


1.34
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.33 2003/12/12 22:56:46 hshoexer Exp $	*/
d57 1
a57 1
#if (__alpha__ + __atari__ + __i386__ + __arc__ + __powerpc__ + __galileo__ + __sparc64__ + __hppa__ +__amd64__ != 1)
d71 3
@


1.33
log
@another small compiler warning cleanup (#error instead of bailing out)

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.32 2003/10/06 16:07:45 fgsch Exp $	*/
d57 1
a57 1
#if (__alpha__ + __atari__ + __i386__ + __arc__ + __powerpc__ + __galileo__ + __sparc64__ + __hppa__ != 1)
d83 3
@


1.32
log
@more pci_flags, unused for now; from netbsd.
ok deraadt@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.30 2003/04/27 11:22:54 ho Exp $	*/
d58 1
a58 1
ERROR: COMPILING FOR UNSUPPORTED MACHINE, OR MORE THAN ONE.
@


1.31
log
@pci support for hppa
@
text
@d142 4
@


1.30
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.29 2003/02/28 15:36:39 mickey Exp $	*/
d57 1
a57 1
#if (__alpha__ + __atari__ + __i386__ + __arc__ + __powerpc__ + __galileo__ + __sparc64__ != 1)
d77 3
@


1.29
log
@take too. patch ahs to screw up once in a while
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.26 2002/11/19 18:40:17 jason Exp $	*/
d196 1
a196 1
void	pci_devinfo(pcireg_t, pcireg_t, int, char *);
@


1.28
log
@remove non-typo changes. sorry folks
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.27 2003/02/28 15:14:08 mickey Exp $	*/
d57 1
a57 1
#if (__alpha__ + __atari__ + __i386__ + __arc__ + __powerpc__ + __galileo__ + __sparc64__ + __hppa__!= 1)
a76 208
#endif
#if __hppa__
#include <hppa/include/pci_machdep.h>
#endif
#if __sparc64__
#include <sparc64/include/pci_machdep.h>
#endif

/*
 * PCI bus attach arguments.
 */
struct pcibus_attach_args {
	char	*pba_busname;		/* XXX should be common */
	bus_space_tag_t pba_iot;	/* pci i/o space tag */
	bus_space_tag_t pba_memt;	/* pci mem space tag */
	bus_dma_tag_t pba_dmat;		/* DMA tag */
	pci_chipset_tag_t pba_pc;

	int		pba_bus;	/* PCI bus number */

	/*
	 * Interrupt swizzling information.  These fields
	 * are only used by secondary busses.
	 */
	u_int		pba_intrswiz;	/* how to swizzle pins */
	pcitag_t	pba_intrtag;	/* intr. appears to come from here */
};

/*
 * PCI device attach arguments.
 */
struct pci_attach_args {
	bus_space_tag_t pa_iot;		/* pci i/o space tag */
	bus_space_tag_t pa_memt;	/* pci mem space tag */
	bus_dma_tag_t pa_dmat;		/* DMA tag */
	pci_chipset_tag_t pa_pc;
	int		pa_flags;	/* flags; see below */

	u_int		pa_device;
	u_int           pa_bus;
	u_int		pa_function;
	pcitag_t	pa_tag;
	pcireg_t	pa_id, pa_class;

	/*
	 * Interrupt information.
	 *
	 * "Intrline" is used on systems whose firmware puts
	 * the right routing data into the line register in
	 * configuration space.  The rest are used on systems
	 * that do not.
	 */
	u_int		pa_intrswiz;	/* how to swizzle pins if ppb */
	pcitag_t	pa_intrtag;	/* intr. appears to come from here */
	pci_intr_pin_t	pa_intrpin;	/* intr. appears on this pin */
	pci_intr_line_t	pa_intrline;	/* intr. routing information */
};

/*
 * Flags given in the bus and device attachment args.
 *
 * OpenBSD doesn't actually use them yet -- csapuntz@@cvs.openbsd.org
 */
#define	PCI_FLAGS_IO_ENABLED	0x01		/* I/O space is enabled */
#define	PCI_FLAGS_MEM_ENABLED	0x02		/* memory space is enabled */

/*
 *
 */
struct pci_quirkdata {
	pci_vendor_id_t		vendor;		/* Vendor ID */
	pci_product_id_t	product;	/* Product ID */
	int			quirks;		/* quirks; see below */
};
#define	PCI_QUIRK_MULTIFUNCTION		0x00000001

/*
 * Locators devices that attach to 'pcibus', as specified to config.
 */
#define	pcibuscf_bus		cf_loc[0]
#define	PCIBUS_UNK_BUS		-1		/* wildcarded 'bus' */

/*
 * Locators for PCI devices, as specified to config.
 */
#define	pcicf_dev		cf_loc[0]
#define	PCI_UNK_DEV		-1		/* wildcarded 'dev' */

#define	pcicf_function		cf_loc[1]
#define	PCI_UNK_FUNCTION	-1		/* wildcarded 'function' */

/*
 * Configuration space access and utility functions.  (Note that most,
 * e.g. make_tag, conf_read, conf_write are declared by pci_machdep.h.)
 */
pcireg_t pci_mapreg_type(pci_chipset_tag_t, pcitag_t, int);
int	pci_mapreg_info(pci_chipset_tag_t, pcitag_t, int, pcireg_t,
	    bus_addr_t *, bus_size_t *, int *);
int	pci_mapreg_map(struct pci_attach_args *, int, pcireg_t, int,
	    bus_space_tag_t *, bus_space_handle_t *, bus_addr_t *,
	    bus_size_t *, bus_size_t);


int	pci_io_find(pci_chipset_tag_t, pcitag_t, int, bus_addr_t *,
	    bus_size_t *);
int	pci_mem_find(pci_chipset_tag_t, pcitag_t, int, bus_addr_t *,
	    bus_size_t *, int *);

int pci_get_capability(pci_chipset_tag_t, pcitag_t, int,
			    int *, pcireg_t *);

struct pci_matchid {
	pci_vendor_id_t		pm_vid;
	pci_product_id_t	pm_pid;
};

int pci_matchbyid(struct pci_attach_args *, const struct pci_matchid *, int);

/*
 * Helper functions for autoconfiguration.
 */
const char *pci_findvendor(pcireg_t);
void	pci_devinfo(pcireg_t, pcireg_t, int, char *);
void	set_pci_isa_bridge_callback(void (*)(void *), void *);
const struct pci_quirkdata *
	pci_lookup_quirkdata(pci_vendor_id_t, pci_product_id_t);
void	pciagp_set_pchb(struct pci_attach_args *);

#endif /* _DEV_PCI_PCIVAR_H_ */
/*	$OpenBSD: pcivar.h,v 1.27 2003/02/28 15:14:08 mickey Exp $	*/
/*	$NetBSD: pcivar.h,v 1.23 1997/06/06 23:48:05 thorpej Exp $	*/

/*
 * Copyright (c) 1996 Christopher G. Demetriou.  All rights reserved.
 * Copyright (c) 1994 Charles Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _DEV_PCI_PCIVAR_H_
#define	_DEV_PCI_PCIVAR_H_

/*
 * Definitions for PCI autoconfiguration.
 *
 * This file describes types and functions which are used for PCI
 * configuration.  Some of this information is machine-specific, and is
 * provided by pci_machdep.h.
 */

#include <machine/bus.h>
#include <dev/pci/pcireg.h>

/*
 * Structures and definitions needed by the machine-dependent header.
 */
typedef u_int32_t pcireg_t;		/* configuration space register XXX */
struct pcibus_attach_args;

/*
 * Machine-dependent definitions.
 */
#if (__alpha__ + __atari__ + __i386__ + __arc__ + __powerpc__ + __galileo__ + __sparc64__ + __hppa__!= 1)
ERROR: COMPILING FOR UNSUPPORTED MACHINE, OR MORE THAN ONE.
#endif
#if __alpha__
#include <alpha/pci/pci_machdep.h>
#endif
#if __atari__
#include <atari/pci/pci_machdep.h>
#endif
#if __i386__
#include <i386/pci/pci_machdep.h>
#endif
#if __arc__
#include <arc/pci/pci_machdep.h>
#endif
#if __powerpc__
#include <powerpc/pci/pci_machdep.h>
#endif
#if __galileo__
#include <galileo/pci/pci_machdep.h>
#endif
#if __hppa__
#include <hppa/include/pci_machdep.h>
@


1.27
log
@typo; from weissmanndude
@
text
@d1 206
a206 1
/*	$OpenBSD: pcivar.h,v 1.26 2002/11/19 18:40:17 jason Exp $	*/
@


1.26
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.25 2002/07/12 20:17:03 mickey Exp $	*/
d57 1
a57 1
#if (__alpha__ + __atari__ + __i386__ + __arc__ + __powerpc__ + __galileo__ + __sparc64__ != 1)
d77 3
@


1.25
log
@support for the agp gart on various agp chipsets.
only i810 driver was tested though.
based on the netbsd's lkm, initially ported
by hunter@@dg.net.ua and later made into shape by mickey.
testing by art@@ and millert@@ .
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.24 2002/03/14 03:16:06 millert Exp $	*/
d184 7
@


1.24
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.23 2002/03/14 01:26:59 millert Exp $	*/
d188 1
d191 3
a193 7
const struct pci_quirkdata *pci_lookup_quirkdata(pci_vendor_id_t,
	    pci_product_id_t);

/*
 * Misc.
 */
const char   *pci_findvendor(pcireg_t);
@


1.23
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.22 2002/01/03 20:52:24 nate Exp $	*/
d189 3
a191 3
void	set_pci_isa_bridge_callback __P((void (*)(void *), void *));
const struct pci_quirkdata *
	pci_lookup_quirkdata(pci_vendor_id_t, pci_product_id_t);
@


1.22
log
@Add the pci_findvendor function
If compiled with PCI_VERBOSE, this function looks up a vendor string based
on a vendor id.  Otherwise, it returns NULL.
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.21 2001/08/19 05:17:37 art Exp $	*/
d169 4
a172 4
pcireg_t pci_mapreg_type __P((pci_chipset_tag_t, pcitag_t, int));
int	pci_mapreg_info __P((pci_chipset_tag_t, pcitag_t, int, pcireg_t,
	    bus_addr_t *, bus_size_t *, int *));
int	pci_mapreg_map __P((struct pci_attach_args *, int, pcireg_t, int,
d174 1
a174 1
	    bus_size_t *, bus_size_t));
d177 4
a180 4
int	pci_io_find __P((pci_chipset_tag_t, pcitag_t, int, bus_addr_t *,
	    bus_size_t *));
int	pci_mem_find __P((pci_chipset_tag_t, pcitag_t, int, bus_addr_t *,
	    bus_size_t *, int *));
d182 2
a183 2
int pci_get_capability __P((pci_chipset_tag_t, pcitag_t, int,
			    int *, pcireg_t *));
d188 1
a188 1
void	pci_devinfo __P((pcireg_t, pcireg_t, int, char *));
d191 1
a191 1
	pci_lookup_quirkdata __P((pci_vendor_id_t, pci_product_id_t));
d196 1
a196 1
const char   *pci_findvendor __P((pcireg_t));
@


1.21
log
@sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.20 2001/07/20 05:56:25 csapuntz Exp $	*/
d192 6
@


1.21.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.22 2002/01/03 20:52:24 nate Exp $	*/
a191 6

/*
 * Misc.
 */
const char   *pci_findvendor __P((pcireg_t));

@


1.21.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.21.4.1 2002/01/31 22:55:36 niklas Exp $	*/
d169 4
a172 4
pcireg_t pci_mapreg_type(pci_chipset_tag_t, pcitag_t, int);
int	pci_mapreg_info(pci_chipset_tag_t, pcitag_t, int, pcireg_t,
	    bus_addr_t *, bus_size_t *, int *);
int	pci_mapreg_map(struct pci_attach_args *, int, pcireg_t, int,
d174 1
a174 1
	    bus_size_t *, bus_size_t);
d177 4
a180 4
int	pci_io_find(pci_chipset_tag_t, pcitag_t, int, bus_addr_t *,
	    bus_size_t *);
int	pci_mem_find(pci_chipset_tag_t, pcitag_t, int, bus_addr_t *,
	    bus_size_t *, int *);
d182 2
a183 2
int pci_get_capability(pci_chipset_tag_t, pcitag_t, int,
			    int *, pcireg_t *);
d188 4
a191 4
void	pci_devinfo(pcireg_t, pcireg_t, int, char *);
void	set_pci_isa_bridge_callback(void (*)(void *), void *);
const struct pci_quirkdata *pci_lookup_quirkdata(pci_vendor_id_t,
	    pci_product_id_t);
d196 1
a196 1
const char   *pci_findvendor(pcireg_t);
@


1.21.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.21.4.2 2002/06/11 03:42:27 art Exp $	*/
a187 1
const char *pci_findvendor(pcireg_t);
d190 7
a196 3
const struct pci_quirkdata *
	pci_lookup_quirkdata(pci_vendor_id_t, pci_product_id_t);
void	pciagp_set_pchb(struct pci_attach_args *);
@


1.21.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a184 7
struct pci_matchid {
	pci_vendor_id_t		pm_vid;
	pci_product_id_t	pm_pid;
};

int pci_matchbyid(struct pci_attach_args *, const struct pci_matchid *, int);

d189 1
a189 1
void	pci_devinfo(pcireg_t, pcireg_t, int, char *, size_t);
@


1.20
log
@

Add pa_bus to pci_attach_args

Better VIA IDE chipset handling. From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.19 2001/06/12 15:40:33 niklas Exp $	*/
d57 1
a57 1
#if (__alpha__ + __atari__ + __i386__ + __arc__ + __powerpc__ + __galileo__ != 1)
d77 3
@


1.19
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.18 2000/06/09 16:09:09 chris Exp $	*/
d110 1
@


1.18
log
@Import pci_mapreg_type from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.17 2000/03/26 22:38:22 mickey Exp $	*/
d170 1
a170 1
	    bus_size_t *));
@


1.17
log
@from netbsd: pci interrupt routing code.
also, change a few pcidevs names to match netbsd (and more descriptive).
tested on a bunch of laptops, helps resolving 'pin X unmapped'
problems for (usually) usb and cardbus cntrollers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.16 1999/07/18 03:20:18 csapuntz Exp $	*/
d165 1
a165 4
/*
 * Configuration space access and utility functions.  (Note that most,
 * e.g. make_tag, conf_read, conf_write are declared by pci_machdep.h.)
 */
@


1.16
log
@

Added pci_mapreg* interface from NetBSD.
Added PCI 2.2 stuff from NetBSD
Modified if_de to use mapreg interface
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.15 1999/06/16 14:38:36 espie Exp $	*/
d137 10
d189 2
a190 1

@


1.16.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.18 2000/06/09 16:09:09 chris Exp $	*/
a136 10
 *
 */
struct pci_quirkdata {
	pci_vendor_id_t		vendor;		/* Vendor ID */
	pci_product_id_t	product;	/* Product ID */
	int			quirks;		/* quirks; see below */
};
#define	PCI_QUIRK_MULTIFUNCTION		0x00000001

/*
d155 4
a158 1
pcireg_t pci_mapreg_type __P((pci_chipset_tag_t, pcitag_t, int));
d179 1
a179 2
const struct pci_quirkdata *
	pci_lookup_quirkdata __P((pci_vendor_id_t, pci_product_id_t));
@


1.16.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.16.4.1 2001/05/14 22:25:56 niklas Exp $	*/
d170 1
a170 1
	    bus_size_t *, bus_size_t));
@


1.16.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.16.4.2 2001/07/04 10:43:00 niklas Exp $	*/
d57 1
a57 1
#if (__alpha__ + __atari__ + __i386__ + __arc__ + __powerpc__ + __galileo__ + __sparc64__ != 1)
a77 3
#if __sparc64__
#include <sparc64/include/pci_machdep.h>
#endif
a109 1
	u_int           pa_bus;
@


1.16.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a191 6

/*
 * Misc.
 */
const char   *pci_findvendor __P((pcireg_t));

@


1.16.4.5
log
@Merge in -current from roughly a week ago
@
text
@d169 4
a172 4
pcireg_t pci_mapreg_type(pci_chipset_tag_t, pcitag_t, int);
int	pci_mapreg_info(pci_chipset_tag_t, pcitag_t, int, pcireg_t,
	    bus_addr_t *, bus_size_t *, int *);
int	pci_mapreg_map(struct pci_attach_args *, int, pcireg_t, int,
d174 1
a174 1
	    bus_size_t *, bus_size_t);
d177 4
a180 4
int	pci_io_find(pci_chipset_tag_t, pcitag_t, int, bus_addr_t *,
	    bus_size_t *);
int	pci_mem_find(pci_chipset_tag_t, pcitag_t, int, bus_addr_t *,
	    bus_size_t *, int *);
d182 2
a183 2
int pci_get_capability(pci_chipset_tag_t, pcitag_t, int,
			    int *, pcireg_t *);
d188 4
a191 4
void	pci_devinfo(pcireg_t, pcireg_t, int, char *);
void	set_pci_isa_bridge_callback(void (*)(void *), void *);
const struct pci_quirkdata *pci_lookup_quirkdata(pci_vendor_id_t,
	    pci_product_id_t);
d196 1
a196 1
const char   *pci_findvendor(pcireg_t);
@


1.16.4.6
log
@Sync the SMP branch with 3.3
@
text
@a184 7
struct pci_matchid {
	pci_vendor_id_t		pm_vid;
	pci_product_id_t	pm_pid;
};

int pci_matchbyid(struct pci_attach_args *, const struct pci_matchid *, int);

a187 1
const char *pci_findvendor(pcireg_t);
d190 7
a196 3
const struct pci_quirkdata *
	pci_lookup_quirkdata(pci_vendor_id_t, pci_product_id_t);
void	pciagp_set_pchb(struct pci_attach_args *);
@


1.16.4.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.16.4.6 2003/03/28 00:38:25 niklas Exp $	*/
d196 1
a196 1
void	pci_devinfo(pcireg_t, pcireg_t, int, char *, size_t);
@


1.16.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 2
a58 2
#if (__alpha__ + __atari__ + __i386__ + __cats__ + __powerpc__ + __galileo__ + __sparc64__ + __hppa__ +__amd64__ != 1)
#error COMPILING FOR UNSUPPORTED MACHINE, OR MORE THAN ONE.
a71 3
#if __cats__
#include <cats/pci/pci_machdep.h>
#endif
a77 3
#if __hppa__
#include <hppa/include/pci_machdep.h>
#endif
a80 3
#if __amd64__
#include <amd64/include/pci_machdep.h>
#endif
a138 4
#define	PCI_FLAGS_MRL_OKAY	0x04		/* Memory Read Line okay */
#define	PCI_FLAGS_MRM_OKAY	0x08		/* Memory Read Multiple okay */
#define	PCI_FLAGS_MWI_OKAY	0x10		/* Memory Write and Invalidate
						   okay */
@


1.15
log
@On the off chance that something that is NOT the kernel includes those
files...
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.14 1999/02/01 16:35:49 pefo Exp $	*/
d107 1
d129 8
d155 11
d170 3
@


1.14
log
@New PCI arch, Galileo
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.13 1998/01/20 18:40:36 niklas Exp $	*/
d57 1
a57 1
#if (alpha + atari + i386 + arc + powerpc + galileo != 1)
d60 1
a60 1
#if alpha
d63 1
a63 1
#if atari
d66 1
a66 1
#if i386
d69 1
a69 1
#if arc
d72 1
a72 1
#if powerpc
d75 1
a75 1
#if galileo
@


1.13
log
@Merge bus_dma support from NetBSD, mostly by Jason Thorpe.  Only i386 uses it
 so far, the other archs gets placeholders for now.  I wrote a compatibility
layer for OpenBSD's old isadma code so we can still use our old
driver sources.  They will however get changed to native bus_dma use,
on a case by case basis.   Oh yes, I almost forgot, I kept our notion
of isadma being a device so DMA-less ISA-busses still work
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.12 1997/10/11 11:14:16 pefo Exp $	*/
d57 1
a57 1
#if (alpha + atari + i386 + arc + powerpc != 1)
d74 3
@


1.12
log
@Add 'powerpc'
@
text
@d1 2
a2 2
/*	$OpenBSD: pcivar.h,v 1.11 1997/03/12 19:52:56 pefo Exp $	*/
/*	$NetBSD: pcivar.h,v 1.18 1996/12/01 21:02:18 leo Exp $	*/
d83 1
d102 1
@


1.11
log
@Mips ARC systems (hmmm..) can also have PCI buses...
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.10 1997/01/24 19:34:16 niklas Exp $	*/
d57 1
a57 1
#if (alpha + atari + i386 + arc != 1)
d71 3
@


1.10
log
@Sync with NetBSD 960123
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.9 1996/11/28 23:28:14 niklas Exp $	*/
d57 1
a57 1
#if (alpha + atari + i386 != 1)
d68 3
@


1.9
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: pcivar.h,v 1.8 1996/11/12 20:30:59 niklas Exp $	*/
/*	$NetBSD: pcivar.h,v 1.16 1996/10/21 22:56:57 thorpej Exp $	*/
d57 1
a57 1
#if (alpha + i386 != 1)
d63 3
d144 1
@


1.8
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 2
a2 2
/*	$OpenBSD: pcivar.h,v 1.7 1996/04/21 22:25:51 deraadt Exp $	*/
/*	$NetBSD: pcivar.h,v 1.15 1996/03/28 02:16:23 cgd Exp $	*/
d45 1
a45 1
#include <machine/bus.old.h>
d71 3
a73 2
	char		*pba_busname;	/* XXX should be common */
	bus_chipset_tag_t pba_bc;	/* XXX should be common */
d90 2
a91 1
	bus_chipset_tag_t pa_bc;
d132 4
a135 4
int	pci_io_find __P((pci_chipset_tag_t, pcitag_t, int, bus_io_addr_t *,
	    bus_io_size_t *));
int	pci_mem_find __P((pci_chipset_tag_t, pcitag_t, int, bus_mem_addr_t *,
	    bus_mem_size_t *, int *));
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: pcivar.h,v 1.6 1996/04/18 23:48:08 niklas Exp $	*/
d45 1
a45 1
#include <machine/bus.h>
@


1.6
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: pcivar.h,v 1.8 1995/06/18 01:26:50 cgd Exp $	*/
d5 1
d42 1
a42 1
 * separated into pci_machdep.h.
d46 1
d48 9
a59 1

a62 1

a67 9
 * The maximum number of devices on a PCI bus is 32.  However, some
 * PCI chipsets (e.g. chipsets that implement 'Configuration Mechanism #2'
 * on the i386) can't deal with that many, so let pci_machdep.h override it.
 */
#ifndef PCI_MAX_DEVICE_NUMBER
#define	PCI_MAX_DEVICE_NUMBER	32
#endif

/*
d73 1
d76 7
d89 2
a90 1
	bus_chipset_tag_t pa_bc;	/* bus chipset tag */
d92 2
a93 2
	int		pa_device;
	int		pa_function;
d96 13
d126 13
a138 6
pcireg_t pci_conf_read __P((pcitag_t, int));
void	 pci_conf_write __P((pcitag_t, int, pcireg_t));
void	 pci_devinfo __P((pcireg_t, pcireg_t, int, char *));
pcitag_t pci_make_tag __P((int, int, int));
void	*pci_map_int __P((pcitag_t, int, int (*)(void *), void *, char *));
int	 pci_map_mem __P((pcitag_t, int, vm_offset_t *, vm_offset_t *));
@


1.5
log
@Fix previous changes; we actually take a device name too so as to avoid
having just non-descript "pci" devices show up in interrupt stats
@
text
@d1 1
d33 3
d44 2
d58 22
d81 6
a86 4
	int pa_bus;
	int pa_device;
	pcitag_t pa_tag;
	pcireg_t pa_id, pa_class;
d89 15
d106 1
a106 1
void	 pci_devinfo __P((pcireg_t, pcireg_t, char *, int *));
d111 1
a111 1
int	 pci_attach_subdev __P((struct device *, int, int));
@


1.4
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d63 1
a63 1
void	*pci_map_int __P((pcitag_t, int, int (*)(void *), void *));
@


1.3
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d63 1
a63 1
void	*pci_map_int __P((pcitag_t, int, int (*)(void *), void *, char *));
@


1.2
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d63 1
a63 1
void	*pci_map_int __P((pcitag_t, int, int (*)(void *), void *));
@


1.1
log
@Initial revision
@
text
@a51 9
/* PCI interrupt levels; system interrupt levels for PCI bus use */
typedef enum {
	PCI_IPL_NONE,		/* block only the interrupt's IRQ*/
	PCI_IPL_BIO,		/* block I/O interrupts */
	PCI_IPL_NET,		/* network */
	PCI_IPL_TTY,		/* terminal */
	PCI_IPL_CLOCK,		/* clock */
} pci_intrlevel;

d63 1
a63 1
void	*pci_map_int __P((pcitag_t, pci_intrlevel, int (*)(void *), void *));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
