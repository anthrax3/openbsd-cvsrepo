head	1.38;
access;
symbols
	OPENBSD_6_0:1.38.0.14
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.38.0.10
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.8
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.38.0.6
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.36.0.10
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.36.0.8
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.6
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.4
	OPENBSD_5_0:1.36.0.2
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.35.0.2
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.31.0.4
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.30.0.6
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.4
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.29.0.4
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.26.0.4
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.24.0.4
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.23.0.4
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.18
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	SMP:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.38
date	2013.10.21.10.36.23;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2013.10.20.20.07.30;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2010.12.26.15.41.00;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2010.05.23.15.30.25;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2009.07.26.18.48.55;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.01.15.34.48;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2006.12.17.22.18.16;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2006.11.29.19.08.22;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2006.11.29.12.13.55;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2006.02.16.23.05.46;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.26.19.15.43;	author martin;	state Exp;
branches;
next	1.24;

1.24
date	2005.01.05.23.04.25;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.21.19.38.19;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.09.21.32.24;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.31.17.09.12;	author matthieu;	state Exp;
branches;
next	1.20;

1.20
date	2003.04.29.21.58.35;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2002.11.09.22.51.48;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.04.00.34.28;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.02.19.21.48;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.26.20.04.50;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.01.11.26.32;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.01.11.17.47;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.27.00;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.09.16.00.42.44;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.25.10.13.30;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.16.19.33.33;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.19.00.18.05;	author aaron;	state Exp;
branches
	1.6.2.1
	1.6.4.1;
next	1.5;

1.5
date	2001.03.18.04.37.21;	author nate;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.01.18.06.35;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.14.18.04.07;	author aaron;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.08.04.16.00.55;	author ericj;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.03.19.30.23;	author mickey;	state Exp;
branches;
next	;

1.3.2.1
date	2001.09.16.15.22.03;	author miod;	state Exp;
branches;
next	;

1.6.2.1
date	2001.10.14.20.44.49;	author jason;	state Exp;
branches;
next	;

1.6.4.1
date	2001.05.14.22.25.57;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.07.04.10.43.04;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2001.11.13.21.10.03;	author niklas;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2002.03.28.15.35.59;	author niklas;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2003.03.28.00.38.25;	author niklas;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2003.05.13.19.35.09;	author ho;	state Exp;
branches;
next	1.6.4.8;

1.6.4.8
date	2004.02.19.10.56.30;	author niklas;	state Exp;
branches;
next	1.6.4.9;

1.6.4.9
date	2004.06.05.23.12.54;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2002.06.11.03.42.27;	author art;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2003.05.19.22.19.08;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Add load_font and list_font accessops to all rasops-based wsdisplay drivers.
Trivial except for tga(4) and gpx(4/vax) which need a bit more care setting
up a new font.
@
text
@/* $OpenBSD: tga.c,v 1.37 2013/10/20 20:07:30 miod Exp $ */
/* $NetBSD: tga.c,v 1.40 2002/03/13 15:05:18 ad Exp $ */

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/ioctl.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/tgareg.h>
#include <dev/pci/tgavar.h>
#include <dev/ic/bt485reg.h>
#include <dev/ic/bt485var.h>
#include <dev/ic/bt463reg.h>
#include <dev/ic/bt463var.h>
#include <dev/ic/ibm561var.h>

#include <dev/wscons/wsconsio.h>
#include <dev/rasops/rasops.h>
#include <dev/wsfont/wsfont.h>

#if defined(__alpha__) || defined(__mips__)
#include <uvm/uvm_extern.h>
#endif

#ifdef __alpha__
#include <machine/pte.h>
#endif
#ifdef __mips__
#include <mips/pte.h>
#endif

int	tgamatch(struct device *, struct cfdata *, void *);
void	tgaattach(struct device *, struct device *, void *);
int	tgaprint(void *, const char *);

struct cfdriver tga_cd = {
	NULL, "tga", DV_DULL
};

struct cfattach tga_ca = {
	sizeof(struct tga_softc), (cfmatch_t)tgamatch, tgaattach,
};

int	tga_identify(struct tga_devconfig *);
const struct tga_conf *tga_getconf(int);
void	tga_getdevconfig(bus_space_tag_t memt, pci_chipset_tag_t pc,
	    pcitag_t tag, struct tga_devconfig *dc);
unsigned tga_getdotclock(struct tga_devconfig *dc);

struct tga_devconfig tga_console_dc;

int	tga_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	tga_mmap(void *, off_t, int);
int	tga_alloc_screen(void *, const struct wsscreen_descr *,
	    void **, int *, int *, long *);
void	tga_free_screen(void *, void *);
int	tga_show_screen(void *, void *, int,
			   void (*) (void *, int, int), void *);
int	tga_load_font(void *, void *, struct wsdisplay_font *);
int	tga_list_font(void *, struct wsdisplay_font *);
void	tga_burner(void *, u_int, u_int);

int	tga_copyrows(void *, int, int, int);
int	tga_copycols(void *, int, int, int, int);
int	tga_eraserows(void *, int, int, long);
int	tga_erasecols(void *, int, int, int, long);
int	tga_putchar(void *c, int row, int col, u_int uc, long attr);

int	tga_rop(struct rasops_info *, int, int, int, int,
	struct rasops_info *, int, int);
int	tga_rop_vtov(struct rasops_info *, int, int, int,
	int, struct rasops_info *, int, int );
void	tga2_init(struct tga_devconfig *);

void	tga_config_interrupts(struct device *);

/* RAMDAC interface functions */
int	 tga_sched_update(void *, void (*)(void *));
void	 tga_ramdac_wr(void *, u_int, u_int8_t);
u_int8_t tga_ramdac_rd(void *, u_int);
void	 tga_bt463_wr(void *, u_int, u_int8_t);
u_int8_t tga_bt463_rd(void *, u_int);
void	 tga2_ramdac_wr(void *, u_int, u_int8_t);
u_int8_t tga2_ramdac_rd(void *, u_int);

/* Interrupt handler */
int	tga_intr(void *);

/* The NULL entries will get filled in by rasops_init().
 * XXX and the non-NULL ones will be overwritten; reset after calling it.
 */
struct wsdisplay_emulops tga_emulops = {
	NULL,
	NULL,
	tga_putchar,
	tga_copycols,
	tga_erasecols,
	tga_copyrows,
	tga_eraserows,
	NULL,
	NULL
};

struct wsscreen_descr tga_stdscreen = {
	"std",
	0, 0,	/* will be filled in -- XXX shouldn't, it's global */
	&tga_emulops,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	    WSSCREEN_WSCOLORS | WSSCREEN_REVERSE
};

const struct wsscreen_descr *_tga_scrlist[] = {
	&tga_stdscreen,
	/* XXX other formats, graphics screen? */
};

struct wsscreen_list tga_screenlist = {
	sizeof(_tga_scrlist) / sizeof(struct wsscreen_descr *), _tga_scrlist
};

struct wsdisplay_accessops tga_accessops = {
	.ioctl = tga_ioctl,
	.mmap = tga_mmap,
	.alloc_screen = tga_alloc_screen,
	.free_screen = tga_free_screen,
	.show_screen = tga_show_screen,
	.load_font = tga_load_font,
	.list_font = tga_list_font,
	.burn_screen = tga_burner
};

void	tga_blank(struct tga_devconfig *);
void	tga_unblank(struct tga_devconfig *);

#ifdef TGA_DEBUG
#define DPRINTF(...)      printf (__VA_ARGS__)
#define DPRINTFN(n, ...)   if (tgadebug > (n)) printf (__VA_ARGS__)
int tgadebug = 0;
#else
#define DPRINTF(...)
#define DPRINTFN(n,...)
#endif

const struct pci_matchid tga_devices[] = {
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_21030 },
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_PBXGB },
};

int
tgamatch(parent, match, aux)
	struct device *parent;
	struct cfdata *match;
	void *aux;
{
	if (pci_matchbyid((struct pci_attach_args *)aux, tga_devices,
	    sizeof(tga_devices) / sizeof(tga_devices[0])))
		return (10);	/* need to return more than vga_pci here! */

	return (0);
}

void
tga_getdevconfig(memt, pc, tag, dc)
	bus_space_tag_t memt;
	pci_chipset_tag_t pc;
	pcitag_t tag;
	struct tga_devconfig *dc;
{
	const struct tga_conf *tgac;
	struct rasops_info *rip;
	int cookie;
	bus_size_t pcisize;
	int i;

	dc->dc_memt = memt;

	dc->dc_pcitag = tag;

	DPRINTF("tga_getdevconfig: Getting map info\n");
	/* XXX magic number */
	if (pci_mapreg_info(pc, tag, 0x10,
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT,
	    &dc->dc_pcipaddr, &pcisize, NULL))
		return;

	DPRINTF("tga_getdevconfig: preparing to map\n");
	if (bus_space_map(memt, dc->dc_pcipaddr, pcisize,
	    BUS_SPACE_MAP_PREFETCHABLE | BUS_SPACE_MAP_LINEAR, &dc->dc_memh))
		return;
#ifdef __OpenBSD__
	dc->dc_vaddr = dc->dc_memh;
#else
	dc->dc_vaddr = (vaddr_t) bus_space_vaddr(memt, dc->dc_memh);
#endif
	DPRINTF("tga_getdevconfig: mapped\n");

#ifdef __alpha__
	dc->dc_paddr = ALPHA_K0SEG_TO_PHYS(dc->dc_vaddr);	/* XXX */
#endif
	DPRINTF("tga_getdevconfig: allocating subregion\n");
	bus_space_subregion(dc->dc_memt, dc->dc_memh, 
			    TGA_MEM_CREGS, TGA_CREGS_SIZE,
			    &dc->dc_regs);

	DPRINTF("tga_getdevconfig: going to identify\n");
	dc->dc_tga_type = tga_identify(dc);

	DPRINTF("tga_getdevconfig: preparing to get config\n");
	tgac = dc->dc_tgaconf = tga_getconf(dc->dc_tga_type);
	if (tgac == NULL)
		return;

#if 0
	/* XXX on the Alpha, pcisize = 4 * cspace_size. */
	if (tgac->tgac_cspace_size != pcisize)			/* sanity */
		panic("tga_getdevconfig: memory size mismatch?");
#endif

	DPRINTF("tga_getdevconfig: get revno\n");
	switch (TGARREG(dc, TGA_REG_GREV) & 0xff) {
	case 0x01:
	case 0x02:
	case 0x03:
	case 0x04:
		dc->dc_tga2 = 0;
		break;
	case 0x20:
	case 0x21:
	case 0x22:
		dc->dc_tga2 = 1;
		break;
	default:
		panic("tga_getdevconfig: TGA Revision not recognized");
	}

	if (dc->dc_tga2) {
		tga2_init(dc);
	}
	
	i = TGARREG(dc, TGA_REG_VHCR) & 0x1ff;
	DPRINTF("tga_getdevconfig: TGA_REG_VHCR & 0x1ff = %d\n", i);
	switch (i) {		/* XXX */
	case 0:
		dc->dc_wid = 8192;
		break;

	case 1:
		dc->dc_wid = 8196;
		break;

	default:
		dc->dc_wid = (TGARREG(dc, TGA_REG_VHCR) & 0x1ff) * 4; /* XXX */
		break;
	}

	DPRINTF("tga_getdevconfig: dc->dc_wid = %d\n", dc->dc_wid);
	/*
	 * XXX XXX Turning off "odd" shouldn't be necessary,
	 * XXX XXX but I can't make X work with the weird size.
	 */
	DPRINTF("tga_getdevconfig: beginning magic incantation\n");
	if ((TGARREG(dc, TGA_REG_VHCR) & 0x00000001) != 0 &&	/* XXX */
	    (TGARREG(dc, TGA_REG_VHCR) & 0x80000000) != 0) {	/* XXX */
		TGAWREG(dc, TGA_REG_VHCR,
		    (TGARREG(dc, TGA_REG_VHCR) & ~0x80000001));
		dc->dc_wid -= 4;
	}

	dc->dc_rowbytes = dc->dc_wid * (dc->dc_tgaconf->tgac_phys_depth / 8);
	dc->dc_ht = (TGARREG(dc, TGA_REG_VVCR) & 0x7ff);	/* XXX */
	DPRINTF("tga_getdevconfig: rowbytes = %d, tgac_phys_depth = %d\n"
		"                  dc_wid = %d, dc_ht = %d\n",
		dc->dc_rowbytes, dc->dc_tgaconf->tgac_phys_depth,
		dc->dc_wid, dc->dc_ht);

	/* XXX this seems to be what DEC does */
	DPRINTF("tga_getdevconfig: more magic\n");
	TGAWREG(dc, TGA_REG_CCBR, 0);
	TGAWREG(dc, TGA_REG_VVBR, 1);
	dc->dc_videobase = dc->dc_vaddr + tgac->tgac_dbuf[0] +
	    1 * tgac->tgac_vvbr_units;
	dc->dc_blanked = 1;
	tga_unblank(dc);
	
	DPRINTF("tga_getdevconfig: dc_videobase = 0x%016llx\n"
		"                  dc_vaddr = 0x%016llx\n"
		"                  tgac_dbuf[0] = %d\n"
		"                  tgac_vvbr_units = %d\n",
		dc->dc_videobase, dc->dc_vaddr, tgac->tgac_dbuf[0],
		tgac->tgac_vvbr_units);
	       
	/*
	 * Set all bits in the pixel mask, to enable writes to all pixels.
	 * It seems that the console firmware clears some of them
	 * under some circumstances, which causes cute vertical stripes.
	 */
	DPRINTF("tga_getdevconfig: set pixel mask\n");
	TGAWREG(dc, TGA_REG_GPXR_P, 0xffffffff);

	/* clear the screen */
	DPRINTF("tga_getdevconfig: clear screen\n");
	for (i = 0; i < dc->dc_ht * dc->dc_rowbytes; i += sizeof(u_int32_t))
		*(u_int32_t *)(dc->dc_videobase + i) = 0;

	DPRINTF("tga_getdevconfig: raster ops\n");
	/* Initialize rasops descriptor */
	rip = &dc->dc_rinfo;
	rip->ri_flg = RI_CENTER;
	rip->ri_depth = tgac->tgac_phys_depth;
	rip->ri_bits = (void *)dc->dc_videobase;
	rip->ri_width = dc->dc_wid;
	rip->ri_height = dc->dc_ht;
	rip->ri_stride = dc->dc_rowbytes;
	rip->ri_hw = dc;

	if (tgac->tgac_phys_depth == 32) {
		rip->ri_rnum = 8;
		rip->ri_gnum = 8;
		rip->ri_bnum = 8;
		rip->ri_rpos = 16;
		rip->ri_gpos = 8;
		rip->ri_bpos = 0;
	}

	DPRINTF("tga_getdevconfig: wsfont_init\n");
	wsfont_init();
	if (rip->ri_width > 80*12) 
		/* High res screen, choose a big font */
		cookie = wsfont_find(NULL, 12, 0, 0);
	else 
		/*  lower res, choose a 8 pixel wide font */
		cookie = wsfont_find(NULL, 8, 0, 0);
	if (cookie <= 0)
		cookie = wsfont_find(NULL, 0, 0, 0);
	if (cookie <= 0) {
		printf("tga: no appropriate fonts.\n");
		return;
	}

	/* the accelerated tga_putchar() needs LSbit left */
	if (wsfont_lock(cookie, &rip->ri_font,
	    WSDISPLAY_FONTORDER_R2L, WSDISPLAY_FONTORDER_L2R) <= 0) {
		printf("tga: couldn't lock font\n");
		return;
	}
	rip->ri_wsfcookie = cookie;
	/* fill screen size */
	rasops_init(rip, rip->ri_height / rip->ri_font->fontheight,
	    rip->ri_width / rip->ri_font->fontwidth); 
	
	/* add our accelerated functions */
	/* XXX shouldn't have to do this; rasops should leave non-NULL 
	 * XXX entries alone.
	 */
	rip->ri_ops.copyrows = tga_copyrows;
	rip->ri_ops.eraserows = tga_eraserows;
	rip->ri_ops.erasecols = tga_erasecols;
	rip->ri_ops.copycols = tga_copycols;
	rip->ri_ops.putchar = tga_putchar;	

	tga_stdscreen.nrows = rip->ri_rows;
	tga_stdscreen.ncols = rip->ri_cols;
	tga_stdscreen.textops = &rip->ri_ops;
	tga_stdscreen.capabilities = rip->ri_caps;

	dc->dc_intrenabled = 0;
}

void
tgaattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pci_attach_args *pa = aux;
	struct tga_softc *sc = (struct tga_softc *)self;
	struct wsemuldisplaydev_attach_args aa;
	pci_intr_handle_t intrh;
	const char *intrstr;
	u_int8_t rev;
	int console;

#if defined(__alpha__)
	console = (pa->pa_tag == tga_console_dc.dc_pcitag);
#else
	console = 0;
#endif
	if (console) {
		sc->sc_dc = &tga_console_dc;
		sc->nscreens = 1;
	} else {
		sc->sc_dc = malloc(sizeof(struct tga_devconfig), M_DEVBUF,
		    M_NOWAIT | M_ZERO);
		if (sc->sc_dc == NULL)
			return;
		tga_getdevconfig(pa->pa_memt, pa->pa_pc, pa->pa_tag,
		    sc->sc_dc);
	}
	if (sc->sc_dc->dc_vaddr == 0) {
		printf(": can't map mem space\n");
		return;
	}

	/* XXX say what's going on. */
	intrstr = NULL;
	if (pci_intr_map(pa, &intrh)) {
		printf(": can't map interrupt");
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, intrh);
	sc->sc_intr = pci_intr_establish(pa->pa_pc, intrh, IPL_TTY, tga_intr,
	    sc->sc_dc, sc->sc_dev.dv_xname);
	if (sc->sc_intr == NULL) {
		printf(": can't establish interrupt");
		if (intrstr != NULL)
			printf("at %s", intrstr);
		printf("\n");
		return;
	}

	rev = PCI_REVISION(pa->pa_class);
	switch (rev) {
	case 0x1:
	case 0x2:
	case 0x3:
		printf(": DC21030 step %c", 'A' + rev - 1);
		break;
	case 0x20:
		printf(": TGA2 abstract software model");
		break;
	case 0x21:
	case 0x22:
		printf(": TGA2 pass %d", rev - 0x20);
		break;

	default:
		printf("unknown stepping (0x%x)", rev);
		break;
	}
	printf(", ");

	/*
	 * Get RAMDAC function vectors and call the RAMDAC functions
	 * to allocate its private storage and pass that back to us.
	 */

	DPRINTF("tgaattach: Get RAMDAC functions\n");
	sc->sc_dc->dc_ramdac_funcs = sc->sc_dc->dc_tgaconf->ramdac_funcs();
	if (!sc->sc_dc->dc_tga2) {
	    DPRINTF("tgaattach: !sc->sc_dc->dc_tga2\n");
	    DPRINTF("tgaattach: sc->sc_dc->dc_tgaconf->ramdac_funcs %s "
		    "bt485_funcs\n",
		    (sc->sc_dc->dc_tgaconf->ramdac_funcs == bt485_funcs)
		    ? "==" : "!=");
	    if (sc->sc_dc->dc_tgaconf->ramdac_funcs == bt485_funcs) 
		  sc->sc_dc->dc_ramdac_cookie = 
			sc->sc_dc->dc_ramdac_funcs->ramdac_register(sc->sc_dc,
		    tga_sched_update, tga_ramdac_wr, tga_ramdac_rd);
		else
		  sc->sc_dc->dc_ramdac_cookie = 
			sc->sc_dc->dc_ramdac_funcs->ramdac_register(sc->sc_dc,
		    tga_sched_update, tga_bt463_wr, tga_bt463_rd);
	} else {
	        DPRINTF("tgaattach: sc->sc_dc->dc_tga2\n");
		sc->sc_dc->dc_ramdac_cookie = 
			sc->sc_dc->dc_ramdac_funcs->ramdac_register(sc->sc_dc, 
			tga_sched_update, tga2_ramdac_wr, tga2_ramdac_rd);

		/* XXX this is a bit of a hack, setting the dotclock here */
		if (sc->sc_dc->dc_tgaconf->ramdac_funcs != bt485_funcs)
			(*sc->sc_dc->dc_ramdac_funcs->ramdac_set_dotclock)
				(sc->sc_dc->dc_ramdac_cookie,
				 tga_getdotclock(sc->sc_dc));
	}
	DPRINTF("tgaattach: sc->sc_dc->dc_ramdac_cookie = 0x%016llx\n",
		sc->sc_dc->dc_ramdac_cookie);
	/*
	 * Initialize the RAMDAC.  Initialization includes disabling
	 * cursor, setting a sane colormap, etc.
	 */
	DPRINTF("tgaattach: Initializing RAMDAC.\n");
	(*sc->sc_dc->dc_ramdac_funcs->ramdac_init)(sc->sc_dc->dc_ramdac_cookie);
	TGAWREG(sc->sc_dc, TGA_REG_SISR, 0x00000001); /* XXX */

	if (sc->sc_dc->dc_tgaconf == NULL) {
		printf("unknown board configuration\n");
		return;
	}
	printf("board type %s\n", sc->sc_dc->dc_tgaconf->tgac_name);
	printf("%s: %d x %d, %dbpp, %s RAMDAC\n", sc->sc_dev.dv_xname,
	    sc->sc_dc->dc_wid, sc->sc_dc->dc_ht,
	    sc->sc_dc->dc_tgaconf->tgac_phys_depth,
	    sc->sc_dc->dc_ramdac_funcs->ramdac_name);

	if (intrstr != NULL)
		printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname,
		    intrstr);

	aa.console = console;
	aa.scrdata = &tga_screenlist;
	aa.accessops = &tga_accessops;
	aa.accesscookie = sc;
	aa.defaultscreens = 0;

	config_found(self, &aa, wsemuldisplaydevprint);

#ifdef __NetBSD__
	config_interrupts(self, tga_config_interrupts);
#else
	tga_config_interrupts(self);
#endif
}

void 
tga_config_interrupts (d)
	struct device *d;
{
	struct tga_softc *sc = (struct tga_softc *)d;
	sc->sc_dc->dc_intrenabled = 1;
}
	

int
tga_ioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct tga_softc *sc = v;
	struct tga_devconfig *dc = sc->sc_dc;
	struct ramdac_funcs *dcrf = dc->dc_ramdac_funcs;
	struct ramdac_cookie *dcrc = dc->dc_ramdac_cookie;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_TGA;
		break;

	case WSDISPLAYIO_SMODE:
		sc->sc_mode = *(u_int *)data;
		switch (sc->sc_mode) {
		case WSDISPLAYIO_MODE_DUMBFB:
			/* in dump fb mode start the framebuffer at 0 */
			TGAWREG(dc, TGA_REG_VVBR, 0);
			break;
		default:
			/* XXX it this useful, except for not breaking Xtga? */
			TGAWREG(dc, TGA_REG_VVBR, 1);
			break;			
		}
		break;

	case WSDISPLAYIO_GINFO:
#define	wsd_fbip ((struct wsdisplay_fbinfo *)data)
		wsd_fbip->height = sc->sc_dc->dc_ht;
		wsd_fbip->width = sc->sc_dc->dc_wid;
		wsd_fbip->depth = sc->sc_dc->dc_tgaconf->tgac_phys_depth;
		wsd_fbip->cmsize = 1024;		/* XXX ??? */
#undef wsd_fbip
		break;

	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_dc->dc_rowbytes;
		break;

	case WSDISPLAYIO_GETCMAP:
		return (*dcrf->ramdac_get_cmap)(dcrc,
		    (struct wsdisplay_cmap *)data);
	case WSDISPLAYIO_PUTCMAP:
		return (*dcrf->ramdac_set_cmap)(dcrc,
		    (struct wsdisplay_cmap *)data);

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	case WSDISPLAYIO_GCURPOS:
		return (*dcrf->ramdac_get_curpos)(dcrc,
		    (struct wsdisplay_curpos *)data);

	case WSDISPLAYIO_SCURPOS:
		return (*dcrf->ramdac_set_curpos)(dcrc,
		    (struct wsdisplay_curpos *)data);

	case WSDISPLAYIO_GCURMAX:
		return (*dcrf->ramdac_get_curmax)(dcrc,
		    (struct wsdisplay_curpos *)data);

	case WSDISPLAYIO_GCURSOR:
		return (*dcrf->ramdac_get_cursor)(dcrc,
		    (struct wsdisplay_cursor *)data);

	case WSDISPLAYIO_SCURSOR:
		return (*dcrf->ramdac_set_cursor)(dcrc,
		    (struct wsdisplay_cursor *)data);

	default:
		return (-1);
	}

	return (0);
}

int
tga_sched_update(v, f)
	void	*v;
	void	(*f)(void *);
{
	struct tga_devconfig *dc = v;

	if (dc->dc_intrenabled) {
		/* Arrange for f to be called at the next end-of-frame interrupt */
		dc->dc_ramdac_intr = f;
		TGAWREG(dc, TGA_REG_SISR, 0x00010000);
	} else {
		/* Spin until the end-of-frame, then call f */
		TGAWREG(dc, TGA_REG_SISR, 0x00010001);
		TGAREGWB(dc, TGA_REG_SISR, 1);
		while ((TGARREG(dc, TGA_REG_SISR) & 0x00000001) == 0)
			;
		f(dc->dc_ramdac_cookie);
		TGAWREG(dc, TGA_REG_SISR, 0x00000001);
		TGAREGWB(dc, TGA_REG_SISR, 1);
	}
		
	return 0;
}

int
tga_intr(v)
	void *v;
{
	struct tga_devconfig *dc = v;
	struct ramdac_cookie *dcrc= dc->dc_ramdac_cookie;

	u_int32_t reg;

	reg = TGARREG(dc, TGA_REG_SISR);
	if (( reg & 0x00010001) != 0x00010001) {
		/* Odd. We never set any of the other interrupt enables. */
		if ((reg & 0x1f) != 0) {
			/* Clear the mysterious pending interrupts. */
			TGAWREG(dc, TGA_REG_SISR, (reg & 0x1f));
			TGAREGWB(dc, TGA_REG_SISR, 1);
			/* This was our interrupt, even if we're puzzled as to why
			 * we got it.  Don't make the interrupt handler think it
			 * was a stray.  
			 */
			return -1;
		} else {
			return 0;
		}
	}
	/* if we have something to do, do it */
	if (dc->dc_ramdac_intr) {
		dc->dc_ramdac_intr(dcrc);
		dc->dc_ramdac_intr = NULL;
	}
	TGAWREG(dc, TGA_REG_SISR, 0x00000001);
	TGAREGWB(dc, TGA_REG_SISR, 1);
	return (1);
}

paddr_t
tga_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
{
	struct tga_softc *sc = v;
	struct tga_devconfig *dc = sc->sc_dc;

	if (offset >= dc->dc_tgaconf->tgac_cspace_size || offset < 0)
		return -1;

	if (sc->sc_mode == WSDISPLAYIO_MODE_DUMBFB) {
		/* 
		 * The framebuffer starts at the upper half of tga mem
		 */
		offset += dc->dc_tgaconf->tgac_cspace_size / 2;
	}
#if defined(__alpha__) || defined(__mips__)
	return (sc->sc_dc->dc_paddr + offset);
#else
	return (-1);
#endif
}

int
tga_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
{
	struct tga_softc *sc = v;
	long defattr;

	if (sc->nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_dc->dc_rinfo; /* one and only for now */
	*curxp = 0;
	*curyp = 0;
	sc->sc_dc->dc_rinfo.ri_ops.alloc_attr(&sc->sc_dc->dc_rinfo, 
		0, 0, 0, &defattr);
	*attrp = defattr;
	sc->nscreens++;
	return (0);
}

void
tga_free_screen(v, cookie)
	void *v;
	void *cookie;
{
	struct tga_softc *sc = v;

	if (sc->sc_dc == &tga_console_dc)
		panic("tga_free_screen: console");

	sc->nscreens--;
}

int
tga_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
{

	return (0);
}

int
tga_load_font(void *v, void *emulcookie, struct wsdisplay_font *font)
{
	struct tga_softc *sc = v;
	struct tga_devconfig *dc = sc->sc_dc;
	struct rasops_info *ri = &dc->dc_rinfo;
	int wsfcookie;
	struct wsdisplay_font *wsf;
	const char *name;

	/*
	 * We can't use rasops_load_font() directly, as we need to make
	 * sure that, when switching fonts, the font bits are set up in
	 * the correct bit order.
	 */

	if (font->data != NULL)
		return rasops_load_font(ri, emulcookie, font);

	/* allow an empty font name to revert to the initial font choice */
	name = font->name;
	if (*name == '\0')
		name = NULL;

	wsfcookie = wsfont_find(name, ri->ri_font->fontwidth,
	    ri->ri_font->fontheight, 0);
	if (wsfcookie < 0) {
		wsfcookie = wsfont_find(name, 0, 0, 0);
		if (wsfcookie < 0)
			return ENOENT;
		else
			return EINVAL;
	}
	if (wsfont_lock(wsfcookie, &wsf,
	    WSDISPLAY_FONTORDER_R2L, WSDISPLAY_FONTORDER_L2R) <= 0)
		return EINVAL;

	/* if (ri->ri_wsfcookie >= 0) */
		wsfont_unlock(ri->ri_wsfcookie);
	ri->ri_wsfcookie = wsfcookie;
	ri->ri_font = wsf;
	ri->ri_fontscale = ri->ri_font->fontheight * ri->ri_font->stride;

	return 0;
}

int
tga_list_font(void *v, struct wsdisplay_font *font)
{
	struct tga_softc *sc = v;
	struct tga_devconfig *dc = sc->sc_dc;
	struct rasops_info *ri = &dc->dc_rinfo;

	return rasops_list_font(ri, font);
}

int
tga_cnattach(iot, memt, pc, bus, device, function)
	bus_space_tag_t iot, memt;
	pci_chipset_tag_t pc;
	int bus, device, function;
{
	struct tga_devconfig *dcp = &tga_console_dc;
	long defattr;

	tga_getdevconfig(memt, pc,
	    pci_make_tag(pc, bus, device, function), dcp);

	/* sanity checks */
	if (dcp->dc_vaddr == 0)
		panic("tga_console(%d, %d): can't map mem space",
		    device, function);
	if (dcp->dc_tgaconf == NULL)
		panic("tga_console(%d, %d): unknown board configuration",
		    device, function);

	/*
	 * Initialize the RAMDAC but DO NOT allocate any private storage.
	 * Initialization includes disabling cursor, setting a sane
	 * colormap, etc.  It will be reinitialized in tgaattach().
	 */
	if (dcp->dc_tga2) {
		if (dcp->dc_tgaconf->ramdac_funcs == bt485_funcs)
			bt485_cninit(dcp, tga_sched_update, tga2_ramdac_wr,
				     tga2_ramdac_rd);
		else
			ibm561_cninit(dcp, tga_sched_update, tga2_ramdac_wr,
				      tga2_ramdac_rd, tga_getdotclock(dcp));
	} else {
		if (dcp->dc_tgaconf->ramdac_funcs == bt485_funcs)
			bt485_cninit(dcp, tga_sched_update, tga_ramdac_wr,
				tga_ramdac_rd);
		else {
			bt463_cninit(dcp, tga_sched_update, tga_bt463_wr,
				tga_bt463_rd);
		}
	}
	dcp->dc_rinfo.ri_ops.alloc_attr(&dcp->dc_rinfo, 0, 0, 0, &defattr);
	wsdisplay_cnattach(&tga_stdscreen, &dcp->dc_rinfo, 0, 0, defattr);
	
	return(0);
}

/*
 * Functions to blank and unblank the display.
 */
void
tga_burner(v, on, flags)
	void *v;
	u_int on, flags;
{
	struct tga_softc *sc = v;

	if (on) {
		tga_unblank(sc->sc_dc);
	} else {
		tga_blank(sc->sc_dc);
	}
}

void
tga_blank(dc)
	struct tga_devconfig *dc;
{

	if (!dc->dc_blanked) {
		dc->dc_blanked = 1;
		/* XXX */
		TGAWREG(dc, TGA_REG_VVVR, TGARREG(dc, TGA_REG_VVVR) | VVR_BLANK);
	}
}

void
tga_unblank(dc)
	struct tga_devconfig *dc;
{

	if (dc->dc_blanked) {
		dc->dc_blanked = 0;
		/* XXX */
		TGAWREG(dc, TGA_REG_VVVR, TGARREG(dc, TGA_REG_VVVR) & ~VVR_BLANK);
	}
}

/*
 * Functions to manipulate the built-in cursor handing hardware.
 */
int
tga_builtin_set_cursor(dc, cursorp)
	struct tga_devconfig *dc;
	struct wsdisplay_cursor *cursorp;
{
	struct ramdac_funcs *dcrf = dc->dc_ramdac_funcs;
	struct ramdac_cookie *dcrc = dc->dc_ramdac_cookie;
	u_int count, v;
	int error;

	v = cursorp->which;
	if (v & WSDISPLAY_CURSOR_DOCMAP) {
		error = dcrf->ramdac_check_curcmap(dcrc, cursorp);
		if (error)
			return (error);
	}
	if (v & WSDISPLAY_CURSOR_DOSHAPE) {
		if ((u_int)cursorp->size.x != 64 ||
		    (u_int)cursorp->size.y > 64)
			return (EINVAL);
	}
	if (v & WSDISPLAY_CURSOR_DOHOT)		/* not supported */
		return EINVAL;

	/* parameters are OK; do it */
	if (v & WSDISPLAY_CURSOR_DOCUR) {
		if (cursorp->enable)
			/* XXX */
			TGAWREG(dc, TGA_REG_VVVR, TGARREG(dc, TGA_REG_VVVR) | 0x04);
		else
			/* XXX */
			TGAWREG(dc, TGA_REG_VVVR, TGARREG(dc, TGA_REG_VVVR) & ~0x04);
	}
	if (v & WSDISPLAY_CURSOR_DOPOS) {
		TGAWREG(dc, TGA_REG_CXYR, 
		    ((cursorp->pos.y & 0xfff) << 12) | (cursorp->pos.x & 0xfff));
	}
	if (v & WSDISPLAY_CURSOR_DOCMAP) {
		/* can't fail. */
		dcrf->ramdac_set_curcmap(dcrc, cursorp);
	}
	if (v & WSDISPLAY_CURSOR_DOSHAPE) {
		/* The cursor is 2 bits deep, and there is no mask */
		count = (cursorp->size.y * 64 * 2) / NBBY;
		TGAWREG(dc, TGA_REG_CCBR,
		    (TGARREG(dc, TGA_REG_CCBR) & ~0xfc00) | (cursorp->size.y << 10));
		if ((error = copyin(cursorp->image,(char *)(dc->dc_vaddr +
		    (TGARREG(dc, TGA_REG_CCBR) & 0x3ff)), count)) != 0)
			return (error);
	}
	return (0);
}

int
tga_builtin_get_cursor(dc, cursorp)
	struct tga_devconfig *dc;
	struct wsdisplay_cursor *cursorp;
{
	struct ramdac_funcs *dcrf = dc->dc_ramdac_funcs;
	struct ramdac_cookie *dcrc = dc->dc_ramdac_cookie;
	int error;
	u_int count;

	cursorp->which = WSDISPLAY_CURSOR_DOALL &
	    ~(WSDISPLAY_CURSOR_DOHOT | WSDISPLAY_CURSOR_DOCMAP);
	cursorp->enable = (TGARREG(dc, TGA_REG_VVVR) & 0x04) != 0;
	cursorp->pos.x = TGARREG(dc, TGA_REG_CXYR) & 0xfff;
	cursorp->pos.y = (TGARREG(dc, TGA_REG_CXYR) >> 12) & 0xfff;
	cursorp->size.x = 64;
	cursorp->size.y = (TGARREG(dc, TGA_REG_CCBR) >> 10) & 0x3f;

	if (cursorp->image != NULL) {
		count = (cursorp->size.y * 64 * 2) / NBBY;
		error = copyout((char *)(dc->dc_vaddr +
		      (TGARREG(dc, TGA_REG_CCBR) & 0x3ff)),
		    cursorp->image, count);
		if (error)
			return (error);
		/* No mask */
	}
	error = dcrf->ramdac_get_curcmap(dcrc, cursorp);
	return (error);
}

int
tga_builtin_set_curpos(dc, curposp)
	struct tga_devconfig *dc;
	struct wsdisplay_curpos *curposp;
{

	TGAWREG(dc, TGA_REG_CXYR,
	    ((curposp->y & 0xfff) << 12) | (curposp->x & 0xfff));
	return (0);
}

int
tga_builtin_get_curpos(dc, curposp)
	struct tga_devconfig *dc;
	struct wsdisplay_curpos *curposp;
{

	curposp->x = TGARREG(dc, TGA_REG_CXYR) & 0xfff;
	curposp->y = (TGARREG(dc, TGA_REG_CXYR) >> 12) & 0xfff;
	return (0);
}

int
tga_builtin_get_curmax(dc, curposp)
	struct tga_devconfig *dc;
	struct wsdisplay_curpos *curposp;
{

	curposp->x = curposp->y = 64;
	return (0);
}

/*
 * Copy columns (characters) in a row (line).
 */
int
tga_copycols(id, row, srccol, dstcol, ncols)
	void *id;
	int row, srccol, dstcol, ncols;
{
	struct rasops_info *ri = id;
	int y, srcx, dstx, nx;

	y = ri->ri_font->fontheight * row;
	srcx = ri->ri_font->fontwidth * srccol;
	dstx = ri->ri_font->fontwidth * dstcol;
	nx = ri->ri_font->fontwidth * ncols;

	tga_rop(ri, dstx, y, nx, ri->ri_font->fontheight, ri, srcx, y);

	return 0;
}

/*
 * Copy rows (lines).
 */
int
tga_copyrows(id, srcrow, dstrow, nrows)
	void *id;
	int srcrow, dstrow, nrows;
{
	struct rasops_info *ri = id;
	int srcy, dsty, ny;

	srcy = ri->ri_font->fontheight * srcrow;
	dsty = ri->ri_font->fontheight * dstrow;
	ny = ri->ri_font->fontheight * nrows;

	tga_rop(ri, 0, dsty, ri->ri_emuwidth, ny, ri, 0, srcy);

	return 0;
}

/*
 *  Generic TGA raster op.
 *   This covers all possible raster ops, and
 *   clips the sizes and all of that.
 */
int
tga_rop(dst, dx, dy, w, h, src, sx, sy)
	struct rasops_info *dst;
	int dx, dy, w, h;
	struct rasops_info *src;
	int sx, sy;
{
	if (dst == NULL || src == NULL)
		return -1;

	/* Clip against src */
	if (sx < 0) {
		w += sx;
		sx = 0;
	}
	if (sy < 0) {
		h += sy;
		sy = 0;
	}
	if (sx + w > src->ri_emuwidth)
		w = src->ri_emuwidth - sx;
	if (sy + h > src->ri_emuheight)
		h = src->ri_emuheight - sy;

	/* Clip against dst.  We modify src regardless of using it,
	 * since it really doesn't matter.
	 */
	if (dx < 0) {
		w += dx;
		sx -= dx;
		dx = 0;
	}
	if (dy < 0) {
		h += dy;
		sy -= dy;
		dy = 0;
	}
	if (dx + w > dst->ri_emuwidth)
		w = dst->ri_emuwidth - dx;
	if (dy + h > dst->ri_emuheight)
		h = dst->ri_emuheight - dy;
	if (w <= 0 || h <= 0)
		return 0;	/* Vacuously true; */

	return tga_rop_vtov(dst, dx, dy, w, h, src, sx, sy);
}



/*
 * Video to Video raster ops.
 * This function deals with all raster ops that have a src and dst
 * that are on the card.
 */
int
tga_rop_vtov(dst, dx, dy, w, h, src, sx, sy)
	struct rasops_info *dst;
	int dx, dy, w, h;
	struct rasops_info *src;
	int sx, sy;
{
	struct tga_devconfig *dc = (struct tga_devconfig *)dst->ri_hw;
	int srcb, dstb, tga_srcb, tga_dstb;
	int x, y, wb;
	int xstart, xend, xdir;
	int ystart, yend, ydir, yinc;
	int xleft, lastx, lastleft;
	int offset = 1 * dc->dc_tgaconf->tgac_vvbr_units;

	/*
	 * I don't yet want to deal with unaligned guys, really.  And we don't
	 * deal with copies from one card to another.
	 */
	if (dx % 8 != 0 || sx % 8 != 0 || src != dst) {
		/* XXX Punt! */
		/* XXX should never happen, since it's only being used to
		 * XXX copy 8-pixel-wide characters.
		 */
		return -1;
	}

        wb = w * (dst->ri_depth / 8);
	if (sy >= dy) {
		ystart = 0;
		yend = h;
		ydir = 1;
	} else {
		ystart = h;
		yend = 0;
		ydir = -1;
	}
	if (sx >= dx) {      /* moving to the left */
		xstart = 0;
		xend = w * (dst->ri_depth / 8) - 4;
		xdir = 1;
	} else {             /* moving to the right */
		xstart = wb - ( wb >= 4*64 ? 4*64 : wb >= 64 ? 64 : 4 );
		xend = 0;
		xdir = -1;
	}
#define XINC4   4
#define XINC64  64
#define XINC256 (64*4)
	yinc = ydir * dst->ri_stride;
	ystart *= dst->ri_stride;
	yend *= dst->ri_stride;

	srcb = sy * src->ri_stride + sx * (src->ri_depth/8);
	dstb = dy * dst->ri_stride + dx * (dst->ri_depth/8);
	tga_srcb = offset + (sy + src->ri_yorigin) * src->ri_stride + 
		(sx + src->ri_xorigin) * (src->ri_depth/8);
	tga_dstb = offset + (dy + dst->ri_yorigin) * dst->ri_stride + 
		(dx + dst->ri_xorigin) * (dst->ri_depth/8);

	TGAWALREG(dc, TGA_REG_GMOR, 3, 0x0007); /* Copy mode */
	TGAWALREG(dc, TGA_REG_GOPR, 3, 0x0003); /* SRC */

	/*
	 * we have 3 sizes of pixels to move in X direction:
	 * 4 * 64   (unrolled TGA ops)
	 *     64   (single TGA op)
	 *      4   (CPU, using long word)
	 */

	if (xdir == 1) {   /* move to the left */

		for (y = ystart; (ydir * y) <= (ydir * yend); y += yinc) {

			/* 4*64 byte chunks */
			for (xleft = wb, x = xstart;
			     x <= xend && xleft >= 4*64;
			     x += XINC256, xleft -= XINC256) {

				/* XXX XXX Eight writes to different addresses should fill 
				 * XXX XXX up the write buffers on 21064 and 21164 chips,
				 * XXX XXX but later CPUs might have larger write buffers which
				 * XXX XXX require further unrolling of this loop, or the
				 * XXX XXX insertion of memory barriers.
				 */
				TGAWALREG(dc, TGA_REG_GCSR, 0, tga_srcb + y + x + 0 * 64);
				TGAWALREG(dc, TGA_REG_GCDR, 0, tga_dstb + y + x + 0 * 64);
				TGAWALREG(dc, TGA_REG_GCSR, 1, tga_srcb + y + x + 1 * 64);
				TGAWALREG(dc, TGA_REG_GCDR, 1, tga_dstb + y + x + 1 * 64);
				TGAWALREG(dc, TGA_REG_GCSR, 2, tga_srcb + y + x + 2 * 64);
				TGAWALREG(dc, TGA_REG_GCDR, 2, tga_dstb + y + x + 2 * 64);
				TGAWALREG(dc, TGA_REG_GCSR, 3, tga_srcb + y + x + 3 * 64);
				TGAWALREG(dc, TGA_REG_GCDR, 3, tga_dstb + y + x + 3 * 64);
			}

			/* 64 byte chunks */
			for ( ; x <= xend && xleft >= 64;
			      x += XINC64, xleft -= XINC64) {
				TGAWALREG(dc, TGA_REG_GCSR, 0, tga_srcb + y + x + 0 * 64);
				TGAWALREG(dc, TGA_REG_GCDR, 0, tga_dstb + y + x + 0 * 64);
			}
			lastx = x; lastleft = xleft;  /* remember for CPU loop */

		}
		TGAWALREG(dc, TGA_REG_GOPR, 0, 0x0003); /* op -> dst = src */
		TGAWALREG(dc, TGA_REG_GMOR, 0, 0x0000); /* Simple mode */

		for (y = ystart; (ydir * y) <= (ydir * yend); y += yinc) {
			/* 4 byte granularity */
			for (x = lastx, xleft = lastleft;
			     x <= xend && xleft >= 4;
			     x += XINC4, xleft -= XINC4) {
				*(uint32_t *)(dst->ri_bits + dstb + y + x) =
					*(uint32_t *)(dst->ri_bits + srcb + y + x);
			}
		}
	}
	else {    /* above move to the left, below move to the right */

		for (y = ystart; (ydir * y) <= (ydir * yend); y += yinc) {

			/* 4*64 byte chunks */
			for (xleft = wb, x = xstart;
			     x >= xend && xleft >= 4*64;
			     x -= XINC256, xleft -= XINC256) {

				/* XXX XXX Eight writes to different addresses should fill 
				 * XXX XXX up the write buffers on 21064 and 21164 chips,
				 * XXX XXX but later CPUs might have larger write buffers which
				 * XXX XXX require further unrolling of this loop, or the
				 * XXX XXX insertion of memory barriers.
				 */
				TGAWALREG(dc, TGA_REG_GCSR, 0, tga_srcb + y + x + 3 * 64);
				TGAWALREG(dc, TGA_REG_GCDR, 0, tga_dstb + y + x + 3 * 64);
				TGAWALREG(dc, TGA_REG_GCSR, 1, tga_srcb + y + x + 2 * 64);
				TGAWALREG(dc, TGA_REG_GCDR, 1, tga_dstb + y + x + 2 * 64);
				TGAWALREG(dc, TGA_REG_GCSR, 2, tga_srcb + y + x + 1 * 64);
				TGAWALREG(dc, TGA_REG_GCDR, 2, tga_dstb + y + x + 1 * 64);
				TGAWALREG(dc, TGA_REG_GCSR, 3, tga_srcb + y + x + 0 * 64);
				TGAWALREG(dc, TGA_REG_GCDR, 3, tga_dstb + y + x + 0 * 64);
			}

			if (xleft) x += XINC256 - XINC64;

			/* 64 byte chunks */
			for ( ; x >= xend && xleft >= 64;
			      x -= XINC64, xleft -= XINC64) {
				TGAWALREG(dc, TGA_REG_GCSR, 0, tga_srcb + y + x + 0 * 64);
				TGAWALREG(dc, TGA_REG_GCDR, 0, tga_dstb + y + x + 0 * 64);
			}
			if (xleft) x += XINC64 - XINC4;
			lastx = x; lastleft = xleft;  /* remember for CPU loop */
		}
		TGAWALREG(dc, TGA_REG_GOPR, 0, 0x0003); /* op -> dst = src */
		TGAWALREG(dc, TGA_REG_GMOR, 0, 0x0000); /* Simple mode */

		for (y = ystart; (ydir * y) <= (ydir * yend); y += yinc) {
			/* 4 byte granularity */
			for (x = lastx, xleft = lastleft;
			     x >= xend && xleft >= 4;
			     x -= XINC4, xleft -= XINC4) {
				*(uint32_t *)(dst->ri_bits + dstb + y + x) =
					*(uint32_t *)(dst->ri_bits + srcb + y + x);
			}
		}
	}
	return 0;
}


int
tga_putchar(c, row, col, uc, attr)
	void *c;
	int row, col;
	u_int uc;
	long attr;
{
	struct rasops_info *ri = c;
	struct tga_devconfig *dc = ri->ri_hw;
	int fs, height, width;
	int fg, bg, ul;
	u_char *fr;
	int32_t *rp;

	rp = (int32_t *)(ri->ri_bits + row*ri->ri_yscale + col*ri->ri_xscale);

	height = ri->ri_font->fontheight;
	width = ri->ri_font->fontwidth;

	uc -= ri->ri_font->firstchar;
	fr = (u_char *)ri->ri_font->data + uc * ri->ri_fontscale;
	fs = ri->ri_font->stride;

	/* Set foreground and background color. XXX memoize this somehow?
	 * The rasops code has already expanded the color entry to 32 bits
	 * for us, even for 8-bit displays, so we don't have to do anything.
	 */
	ri->ri_ops.unpack_attr(c, attr, &fg, &bg, &ul);
	TGAWREG(dc, TGA_REG_GFGR, ri->ri_devcmap[fg]);
	TGAWREG(dc, TGA_REG_GBGR, ri->ri_devcmap[bg]);
	
	/* Set raster operation to "copy"... */
	if (ri->ri_depth == 8)
		TGAWREG(dc, TGA_REG_GOPR, 0x3);
	else /* ... and in 24-bit mode, set the destination bitmap to 24-bit. */
		TGAWREG(dc, TGA_REG_GOPR, 0x3 | (0x3 << 8));

	/* Set which pixels we're drawing (of a possible 32). */
	TGAWREG(dc, TGA_REG_GPXR_P, (1 << width) - 1);

	/* Set drawing mode to opaque stipple. */
	TGAWREG(dc, TGA_REG_GMOR, 0x1);
	
	/* Insert write barrier before actually sending data */
	/* XXX Abuses the fact that there is only one write barrier on Alphas */
	TGAREGWB(dc, TGA_REG_GMOR, 1);

	while (height--) {
		/* The actual stipple write */
		*rp = fr[0] | (fr[1] << 8) | (fr[2] << 16) | (fr[3] << 24); 
						  
		fr += fs;
		rp = (int32_t *)((caddr_t)rp + ri->ri_stride);
	}

	/* Do underline */
	if (ul) {
		rp = (int32_t *)((caddr_t)rp - (ri->ri_stride << 1));
		*rp = 0xffffffff;
	}

	/* Set grapics mode back to normal. */
	TGAWREG(dc, TGA_REG_GMOR, 0);
	TGAWREG(dc, TGA_REG_GPXR_P, 0xffffffff);

	return 0;
}

int
tga_eraserows(c, row, num, attr)
	void *c;
	int row, num;
	long attr;
{
	struct rasops_info *ri = c;
	struct tga_devconfig *dc = ri->ri_hw;
	int32_t color, lines, pixels;
	int fg, bg;
	int32_t *rp;

	ri->ri_ops.unpack_attr(c, attr, &fg, &bg, NULL);
	color = ri->ri_devcmap[bg];
	rp = (int32_t *)(ri->ri_bits + row*ri->ri_yscale);
	lines = num * ri->ri_font->fontheight;
	pixels = ri->ri_emuwidth - 1;

	/* Set fill color in block-color registers */
	TGAWREG(dc, TGA_REG_GBCR0, color);
	TGAWREG(dc, TGA_REG_GBCR1, color);
	if (ri->ri_depth != 8) {
		TGAWREG(dc, TGA_REG_GBCR2, color);
		TGAWREG(dc, TGA_REG_GBCR3, color);
		TGAWREG(dc, TGA_REG_GBCR4, color);
		TGAWREG(dc, TGA_REG_GBCR5, color);
		TGAWREG(dc, TGA_REG_GBCR6, color);
		TGAWREG(dc, TGA_REG_GBCR7, color);
	}

	/* Set raster operation to "copy"... */
	if (ri->ri_depth == 8)
		TGAWREG(dc, TGA_REG_GOPR, 0x3);
	else /* ... and in 24-bit mode, set the destination bitmap to 24-bit. */
		TGAWREG(dc, TGA_REG_GOPR, 0x3 | (0x3 << 8));

	/* Set which pixels we're drawing (of a possible 32). */
	TGAWREG(dc, TGA_REG_GDAR, 0xffffffff);

	/* Set drawing mode to block fill. */
	TGAWREG(dc, TGA_REG_GMOR, 0x2d);
	
	/* Insert write barrier before actually sending data */
	/* XXX Abuses the fact that there is only one write barrier on Alphas */
	TGAREGWB(dc, TGA_REG_GMOR, 1);

	while (lines--) {
		*rp = pixels;
		rp = (int32_t *)((caddr_t)rp + ri->ri_stride);
	}

	/* Set grapics mode back to normal. */
	TGAWREG(dc, TGA_REG_GMOR, 0);
	
	return 0;
}

int
tga_erasecols (c, row, col, num, attr)
	void *c;
	int row, col, num;
	long attr;
{
	struct rasops_info *ri = c;
	struct tga_devconfig *dc = ri->ri_hw;
	int32_t color, lines, pixels;
	int fg, bg;
	int32_t *rp;

	ri->ri_ops.unpack_attr(c, attr, &fg, &bg, NULL);
	color = ri->ri_devcmap[bg];
	rp = (int32_t *)(ri->ri_bits + row*ri->ri_yscale + col*ri->ri_xscale);
	lines = ri->ri_font->fontheight;
	pixels = (num * ri->ri_font->fontwidth) - 1;

	/* Set fill color in block-color registers */
	TGAWREG(dc, TGA_REG_GBCR0, color);
	TGAWREG(dc, TGA_REG_GBCR1, color);
	if (ri->ri_depth != 8) {
		TGAWREG(dc, TGA_REG_GBCR2, color);
		TGAWREG(dc, TGA_REG_GBCR3, color);
		TGAWREG(dc, TGA_REG_GBCR4, color);
		TGAWREG(dc, TGA_REG_GBCR5, color);
		TGAWREG(dc, TGA_REG_GBCR6, color);
		TGAWREG(dc, TGA_REG_GBCR7, color);
	}

	/* Set raster operation to "copy"... */
	if (ri->ri_depth == 8)
		TGAWREG(dc, TGA_REG_GOPR, 0x3);
	else /* ... and in 24-bit mode, set the destination bitmap to 24-bit. */
		TGAWREG(dc, TGA_REG_GOPR, 0x3 | (0x3 << 8));

	/* Set which pixels we're drawing (of a possible 32). */
	TGAWREG(dc, TGA_REG_GDAR, 0xffffffff);

	/* Set drawing mode to block fill. */
	TGAWREG(dc, TGA_REG_GMOR, 0x2d);
	
	/* Insert write barrier before actually sending data */
	/* XXX Abuses the fact that there is only one write barrier on Alphas */
	TGAREGWB(dc, TGA_REG_GMOR, 1);

	while (lines--) {
		*rp = pixels;
		rp = (int32_t *)((caddr_t)rp + ri->ri_stride);
	}

	/* Set grapics mode back to normal. */
	TGAWREG(dc, TGA_REG_GMOR, 0);

	return 0;
}


void
tga_ramdac_wr(v, btreg, val)
	void *v;
	u_int btreg;
	u_int8_t val;
{
	struct tga_devconfig *dc = v;

	if (btreg > BT485_REG_MAX)
		panic("tga_ramdac_wr: reg %d out of range", btreg);

	TGAWREG(dc, TGA_REG_EPDR, (btreg << 9) | (0 << 8 ) | val); /* XXX */
	TGAREGWB(dc, TGA_REG_EPDR, 1);
}

void
tga2_ramdac_wr(v, btreg, val)
	void *v;
	u_int btreg;
	u_int8_t val;
{
	struct tga_devconfig *dc = v;
	bus_space_handle_t ramdac;

	if (btreg > BT485_REG_MAX)
		panic("tga_ramdac_wr: reg %d out of range", btreg);

	bus_space_subregion(dc->dc_memt, dc->dc_memh, TGA2_MEM_RAMDAC + 
		(0xe << 12) + (btreg << 8), 4, &ramdac);
	bus_space_write_4(dc->dc_memt, ramdac, 0, val & 0xff);
	bus_space_barrier(dc->dc_memt, ramdac, 0, 4, BUS_SPACE_BARRIER_WRITE);
}

u_int8_t
tga_bt463_rd(v, btreg)
	void *v;
	u_int btreg;
{
	struct tga_devconfig *dc = v;
	tga_reg_t rdval;

	/* 
	 * Strobe CE# (high->low->high) since status and data are latched on 
	 * the falling and rising edges (repsectively) of this active-low signal.
	 */
	
	TGAREGWB(dc, TGA_REG_EPSR, 1);
	TGAWREG(dc, TGA_REG_EPSR, (btreg << 2) | 2 | 1);
	TGAREGWB(dc, TGA_REG_EPSR, 1);
	TGAWREG(dc, TGA_REG_EPSR, (btreg << 2) | 2 | 0);

	TGAREGRB(dc, TGA_REG_EPSR, 1);

	rdval = TGARREG(dc, TGA_REG_EPDR);
	TGAREGWB(dc, TGA_REG_EPSR, 1);
	TGAWREG(dc, TGA_REG_EPSR, (btreg << 2) | 2 | 1);

	return (rdval >> 16) & 0xff;
}

void
tga_bt463_wr(v, btreg, val)
	void *v;
	u_int btreg;
	u_int8_t val;
{
	struct tga_devconfig *dc = v;

	/* 
	 * In spite of the 21030 documentation, to set the MPU bus bits for
	 * a write, you set them in the upper bits of EPDR, not EPSR.
	 */
	
	/* 
	 * Strobe CE# (high->low->high) since status and data are latched on
	 * the falling and rising edges of this active-low signal.
	 */

	TGAREGWB(dc, TGA_REG_EPDR, 1);
	TGAWREG(dc, TGA_REG_EPDR, (btreg << 10) | 0x100 | val);
	TGAREGWB(dc, TGA_REG_EPDR, 1);
	TGAWREG(dc, TGA_REG_EPDR, (btreg << 10) | 0x000 | val);
	TGAREGWB(dc, TGA_REG_EPDR, 1);
	TGAWREG(dc, TGA_REG_EPDR, (btreg << 10) | 0x100 | val);

}

u_int8_t
tga_ramdac_rd(v, btreg)
	void *v;
	u_int btreg;
{
	struct tga_devconfig *dc = v;
	tga_reg_t rdval;

	if (btreg > BT485_REG_MAX)
		panic("tga_ramdac_rd: reg %d out of range", btreg);

	TGAWREG(dc, TGA_REG_EPSR, (btreg << 1) | 0x1); /* XXX */
	TGAREGWB(dc, TGA_REG_EPSR, 1);

	rdval = TGARREG(dc, TGA_REG_EPDR);
	return (rdval >> 16) & 0xff;				/* XXX */
}

u_int8_t
tga2_ramdac_rd(v, btreg)
	void *v;
	u_int btreg;
{
	struct tga_devconfig *dc = v;
	bus_space_handle_t ramdac;
	u_int8_t retval;

	if (btreg > BT485_REG_MAX)
		panic("tga_ramdac_rd: reg %d out of range", btreg);

	bus_space_subregion(dc->dc_memt, dc->dc_memh, TGA2_MEM_RAMDAC + 
		(0xe << 12) + (btreg << 8), 4, &ramdac);
	retval = bus_space_read_4(dc->dc_memt, ramdac, 0) & 0xff;
	bus_space_barrier(dc->dc_memt, ramdac, 0, 4, BUS_SPACE_BARRIER_READ);
	return retval;
}

#include <dev/ic/decmonitors.c>
void tga2_ics9110_wr(
	struct tga_devconfig *dc,
	int dotclock
);

struct monitor *tga_getmonitor(struct tga_devconfig *dc);

void
tga2_init(dc)
	struct tga_devconfig *dc;
{
	struct	monitor *m = tga_getmonitor(dc);


	/* Deal with the dot clocks.
	 */
	if (dc->dc_tga_type == TGA_TYPE_POWERSTORM_4D20) {
		/* Set this up as a reference clock for the
		 * ibm561's PLL.
		 */
		tga2_ics9110_wr(dc, 14300000);
		/* XXX Can't set up the dotclock properly, until such time
		 * as the RAMDAC is configured.
		 */
	} else {
		/* otherwise the ics9110 is our clock. */
		tga2_ics9110_wr(dc, m->dotclock);
	}
#if 0
	TGAWREG(dc, TGA_REG_VHCR, 
	     ((m->hbp / 4) << 21) |
	     ((m->hsync / 4) << 14) |
	    (((m->hfp - 4) / 4) << 9) |
	     ((m->cols + 4) / 4));
#else
	TGAWREG(dc, TGA_REG_VHCR, 
	     ((m->hbp / 4) << 21) |
	     ((m->hsync / 4) << 14) |
	    (((m->hfp) / 4) << 9) |
	     ((m->cols) / 4));
#endif
	TGAWREG(dc, TGA_REG_VVCR, 
	    (m->vbp << 22) |
	    (m->vsync << 16) |
	    (m->vfp << 11) |
	    (m->rows));
	TGAWREG(dc, TGA_REG_VVBR, 1);
	TGAREGRWB(dc, TGA_REG_VHCR, 3);
	TGAWREG(dc, TGA_REG_VVVR, TGARREG(dc, TGA_REG_VVVR) | 1);
	TGAREGRWB(dc, TGA_REG_VVVR, 1);
	TGAWREG(dc, TGA_REG_GPMR, 0xffffffff);
	TGAREGRWB(dc, TGA_REG_GPMR, 1);
}

void
tga2_ics9110_wr(dc, dotclock)
	struct tga_devconfig *dc;
	int dotclock;
{
	bus_space_handle_t clock;
	u_int32_t valU;
	int N, M, R, V, X;
	int i;

	switch (dotclock) {
	case 130808000:
		N = 0x40; M = 0x7; V = 0x0; X = 0x1; R = 0x1; break;
	case 119840000:
		N = 0x2d; M = 0x2b; V = 0x1; X = 0x1; R = 0x1; break;
	case 108180000:
		N = 0x11; M = 0x9; V = 0x1; X = 0x1; R = 0x2; break;
	case 103994000:
		N = 0x6d; M = 0xf; V = 0x0; X = 0x1; R = 0x1; break;
	case 175000000:
		N = 0x5F; M = 0x3E; V = 0x1; X = 0x1; R = 0x1; break;
	case  75000000:
		N = 0x6e; M = 0x15; V = 0x0; X = 0x1; R = 0x1; break;
	case  74000000:
		N = 0x2a; M = 0x41; V = 0x1; X = 0x1; R = 0x1; break;
	case  69000000:
		N = 0x35; M = 0xb; V = 0x0; X = 0x1; R = 0x1; break;
	case  65000000:
		N = 0x6d; M = 0x0c; V = 0x0; X = 0x1; R = 0x2; break;
	case  50000000:
		N = 0x37; M = 0x3f; V = 0x1; X = 0x1; R = 0x2; break;
	case  40000000:
		N = 0x5f; M = 0x11; V = 0x0; X = 0x1; R = 0x2; break;
	case  31500000:
		N = 0x16; M = 0x05; V = 0x0; X = 0x1; R = 0x2; break;
	case  25175000:
		N = 0x66; M = 0x1d; V = 0x0; X = 0x1; R = 0x2; break;
	case 135000000:
		N = 0x42; M = 0x07; V = 0x0; X = 0x1; R = 0x1; break;
	case 110000000:
		N = 0x60; M = 0x32; V = 0x1; X = 0x1; R = 0x2; break;
	case 202500000:
		N = 0x60; M = 0x32; V = 0x1; X = 0x1; R = 0x2; break;
       case  14300000:         /* this one is just a ref clock */
               N = 0x03; M = 0x03; V = 0x1; X = 0x1; R = 0x3; break;
	default:
		panic("unrecognized clock rate %d", dotclock);
	}

	/* XXX -- hard coded, bad */
	valU  = N | ( M << 7 ) | (V << 14);
	valU |= (X << 15) | (R << 17);
	valU |= 0x17 << 19;

	bus_space_subregion(dc->dc_memt, dc->dc_memh, TGA2_MEM_EXTDEV +
	    TGA2_MEM_CLOCK + (0xe << 12), 4, &clock); /* XXX */

	for (i = 24; i > 0; i--) {
		u_int32_t writeval;
                
		writeval = valU & 0x1;
		if (i == 1)  
			writeval |= 0x2; 
		valU >>= 1;
		bus_space_write_4(dc->dc_memt, clock, 0, writeval);
		bus_space_barrier(dc->dc_memt, clock, 0, 4, BUS_SPACE_BARRIER_WRITE);
        }       
	bus_space_subregion(dc->dc_memt, dc->dc_memh, TGA2_MEM_EXTDEV +
	    TGA2_MEM_CLOCK + (0xe << 12) + (0x1 << 11) + (0x1 << 11), 4,
		&clock); /* XXX */
	bus_space_write_4(dc->dc_memt, clock, 0, 0x0);
	bus_space_barrier(dc->dc_memt, clock, 0, 0, BUS_SPACE_BARRIER_WRITE);
}

struct monitor *
tga_getmonitor(dc)
       struct tga_devconfig *dc;
{
       return &decmonitors[(~TGARREG(dc, TGA_REG_GREV) >> 16) & 0x0f];
}

unsigned
tga_getdotclock(dc)
       struct tga_devconfig *dc;
{
       return tga_getmonitor(dc)->dotclock;
}
@


1.37
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.36 2011/04/07 15:30:16 miod Exp $ */
a90 2
int	tga_copyrows(void *, int, int, int);
int	tga_copycols(void *, int, int, int, int);
d96 2
d99 7
a109 3
int	tga_putchar(void *c, int row, int col, u_int uc, long attr);
int	tga_eraserows(void *, int, int, long);
int	tga_erasecols(void *, int, int, int, long);
d165 2
d775 56
@


1.36
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.35 2010/12/26 15:41:00 miod Exp $ */
d156 6
a161 9
	tga_ioctl,
	tga_mmap,
	tga_alloc_screen,
	tga_free_screen,
	tga_show_screen,
	NULL,			/* load_font */
	NULL,			/* scrollback */
	NULL,			/* getchar */
	tga_burner,
@


1.35
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.34 2010/05/23 15:30:25 deraadt Exp $ */
d433 1
a433 1
	if (sc->sc_dc->dc_vaddr == NULL) {
d787 1
a787 1
	if (dcp->dc_vaddr == NULL)
@


1.34
log
@remove another piece of ancient #ifdef arc code
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.33 2009/09/05 14:09:35 miod Exp $ */
d719 1
a719 1
	return atop(sc->sc_dc->dc_paddr + offset);
@


1.33
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.32 2009/07/26 18:48:55 miod Exp $ */
a234 3
#ifdef arc
	bus_space_paddr(memt, dc->dc_memh, &dc->dc_paddr);
#endif
d417 1
a417 1
#if defined(__alpha__) || defined(arc)
@


1.32
log
@Make sure all platforms understand the flags argument of bus_space_map() and
bus_space_alloc() as a bitmask of flags, and not a boolean controlling
cacheability; and make sure the three MI BUS_SPACE_MAP_xxx values documented
in the manual page are defined on all platforms as well.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.31 2009/03/29 21:53:52 sthen Exp $ */
d91 2
a92 2
void	tga_copyrows(void *, int, int, int);
void	tga_copycols(void *, int, int, int, int);
d103 3
a105 3
void	tga_putchar(void *c, int row, int col, u_int uc, long attr);
void	tga_eraserows(void *, int, int, long);
void	tga_erasecols(void *, int, int, int, long);
d987 1
a987 1
void
d1001 2
d1008 1
a1008 1
void
d1021 2
d1254 1
a1254 1
void
d1318 2
d1322 1
a1322 1
void
d1376 1
d1379 1
a1379 1
void
d1432 2
@


1.31
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.30 2007/10/01 15:34:48 krw Exp $ */
d222 3
a225 2
	if (bus_space_map(memt, dc->dc_pcipaddr, pcisize, 1, &dc->dc_memh))
		return;
a227 3
	if (bus_space_map(memt, dc->dc_pcipaddr, pcisize,
	    BUS_SPACE_MAP_PREFETCHABLE | BUS_SPACE_MAP_LINEAR, &dc->dc_memh))
		return;
@


1.30
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...' where
obvious.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.29 2006/12/17 22:18:16 miod Exp $ */
d439 1
a439 1
		printf(": couldn't map memory space; punt!\n");
d446 1
a446 1
		printf(": couldn't map interrupt");
d453 1
a453 1
		printf(": couldn't establish interrupt");
d793 1
a793 1
		panic("tga_console(%d, %d): couldn't map memory space",
@


1.29
log
@Remove unnecessary <dev/wscons/wscons_raster.h> inclusion.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.28 2006/11/29 19:08:22 miod Exp $ */
d431 2
a432 2
		sc->sc_dc = (struct tga_devconfig *)
		    malloc(sizeof(struct tga_devconfig), M_DEVBUF, M_NOWAIT);
a434 1
		bzero(sc->sc_dc, sizeof(struct tga_devconfig));
@


1.28
log
@Add an unpack_attr function to struct wsdisplay_emulops, to match the
existing alloc_attr function. This allows rasops_unpack_attr to be kept
private to rasops, yet available to the screen drivers.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.27 2006/11/29 12:13:55 miod Exp $ */
a54 1
#include <dev/wscons/wscons_raster.h>
@


1.27
log
@Add a new member to struct wsemuldisplaydev_attach_args, for a frame buffer
driver to be able to tell how many wscons screens to attach to it,
instead of WSDISPLAY_DEFAULTSCREENS which is a global setting.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.26 2006/02/16 23:05:46 miod Exp $ */
d135 1
d1281 1
a1281 1
	rasops_unpack_attr(attr, &fg, &bg, &ul);
d1332 1
a1332 1
	rasops_unpack_attr(attr, &fg, &bg, NULL);
d1388 1
a1388 1
	rasops_unpack_attr(attr, &fg, &bg, NULL);
@


1.26
log
@Use rasops_unpack_attr() to decompose attributes instead of doing it by hand,
as we are not supposed to know how rasops encodes attributes here.
Tested matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.25 2005/10/26 19:15:43 martin Exp $ */
d543 1
@


1.25
log
@use the MI atop() macro for alpha and mips
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.24 2005/01/05 23:04:25 miod Exp $ */
d142 2
a143 1
	WSSCREEN_REVERSE
d1252 2
a1253 1
void tga_putchar (c, row, col, uc, attr)
d1262 1
d1279 3
a1281 2
	TGAWREG(dc, TGA_REG_GFGR, ri->ri_devcmap[(attr >> 24) & 15]);
	TGAWREG(dc, TGA_REG_GBGR, ri->ri_devcmap[(attr >> 16) & 15]);
d1308 1
a1308 1
	if ((attr & 1) != 0) {
a1315 1

d1327 1
d1330 2
a1331 1
	color = ri->ri_devcmap[(attr >> 16) & 15];
d1383 1
d1386 2
a1387 1
	color = ri->ri_devcmap[(attr >> 16) & 15];
@


1.24
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.23 2004/02/21 19:38:19 miod Exp $ */
d59 4
d722 2
a723 4
#if defined(__alpha__)
	return alpha_btop(sc->sc_dc->dc_paddr + offset);
#elif defined(__mips__)
	return mips_btop(sc->sc_dc->dc_paddr + offset);
@


1.23
log
@Remove left-over dependencies on the old rcons code.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.22 2004/01/09 21:32:24 brad Exp $ */
d573 1
a573 1
		return (0);
d587 1
a587 1
		return (0);
d596 1
a596 1
		return (0);
d600 2
a601 1
		return 0;
a604 1

a609 6
		if (*(u_int *)data == WSDISPLAYIO_VIDEO_OFF)
			tga_blank(sc->sc_dc);
		else
			tga_unblank(sc->sc_dc);
		return (0);

d611 1
a611 3
		*(u_int *)data = dc->dc_blanked ?
		    WSDISPLAYIO_VIDEO_OFF : WSDISPLAYIO_VIDEO_ON;
		return (0);
d632 3
d636 2
a637 1
	return (-1);
@


1.22
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.21 2003/08/31 17:09:12 matthieu Exp $ */
d96 1
a96 1
int	tga_rop(struct rasops_info *, int, int, int, int, int,
d98 1
a98 1
int	tga_rop_vtov(struct rasops_info *, int, int, int, int,
d1003 1
a1003 3
	tga_rop(ri, dstx, y,
	    nx, ri->ri_font->fontheight, RAS_SRC,
	    ri, srcx, y);
d1021 1
a1021 3
	tga_rop(ri, 0, dsty,
	    ri->ri_emuwidth, ny, RAS_SRC,
	    ri, 0, srcy);
a1023 8
/* Do we need the src? */
int needsrc[16] = { 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0 };

/* A mapping between our API and the TGA card */
int map_rop[16] = { 0x0, 0x8, 0x4, 0xc, 0x2, 0xa, 0x6,
	0xe, 0x1, 0x9, 0x5, 0xd, 0x3, 0xb, 0x7, 0xf
};

d1030 1
a1030 1
tga_rop(dst, dx, dy, w, h, rop, src, sx, sy)
d1032 1
a1032 1
	int dx, dy, w, h, rop;
d1036 1
a1036 1
	if (!dst)
d1038 15
a1052 20
	if (needsrc[RAS_GETOP(rop)]) {
		if (src == NULL)
			return -1;	/* We want a src */
		/* Clip against src */
		if (sx < 0) {
			w += sx;
			sx = 0;
		}
		if (sy < 0) {
			h += sy;
			sy = 0;
		}
		if (sx + w > src->ri_emuwidth)
			w = src->ri_emuwidth - sx;
		if (sy + h > src->ri_emuheight)
			h = src->ri_emuheight - sy;
	} else {
		if (src != NULL)
			return -1;	/* We need no src */
	}
d1072 2
a1073 5
	if (!src) {
		/* XXX Punt! */
		return -1;
	}
	return tga_rop_vtov(dst, dx, dy, w, h, rop, src, sx, sy);
d1084 1
a1084 1
tga_rop_vtov(dst, dx, dy, w, h, rop, src, sx, sy)
d1086 1
a1086 1
	int dx, dy, w, h, rop;
d1144 1
a1144 1
	TGAWALREG(dc, TGA_REG_GOPR, 3, map_rop[rop]);   /* Set up the op */
@


1.21
log
@remove bogus cache test. Suggested by drahn@@, ok mickey@@, miod@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.20 2003/04/29 21:58:35 miod Exp $ */
a57 2

#include <uvm/uvm_extern.h>
@


1.20
log
@Use pci_matchbyid(). Tested by matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.19 2002/11/09 22:51:48 miod Exp $ */
d205 1
a205 1
	int i, cacheable;
d215 1
a215 1
	    &dc->dc_pcipaddr, &pcisize, &cacheable))
a216 2
	if (!cacheable)
		panic("tga memory not cacheable");
@


1.19
log
@Instead of relying on uvm_useracc(), get a false sense of security, and
do not check copyin() result, take care and properly handle copyin() failure.

This was not harmful, but a bit more correctness never harms.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.18 2002/10/12 01:09:44 krw Exp $ */
d176 5
d187 3
a189 4
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_DEC)
		return (0);
a190 7
	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_DEC_21030:
	case PCI_PRODUCT_DEC_PBXGB:
		return 10;
	default:
		return 0;
	}
@


1.18
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.17 2002/07/04 00:34:28 miod Exp $ */
a897 4
		/* The cursor is 2 bits deep, and there is no mask */
		count = (cursorp->size.y * 64 * 2) / NBBY;
		if (!uvm_useracc(cursorp->image, count, B_READ))
			return (EFAULT);
d920 2
a921 1
		count = ((64 * 2) / NBBY) * cursorp->size.y;
d924 3
a926 3
		copyin(cursorp->image, (char *)(dc->dc_vaddr +
		    (TGARREG(dc, TGA_REG_CCBR) & 0x3ff)),
		    count);				/* can't fail. */
@


1.17
log
@Various tga hacks:
- some KNF touches
- use simpler constructs
- do not forget to make use of the tga interrupt when it is enabled (speeds
  up X11 startup and shutdown, hi matthieu!)
- implement the wscons screen burner facility
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.16 2002/05/02 19:21:48 matthieu Exp $ */
d1464 1
a1464 1
		panic("tga_ramdac_wr: reg %d out of range\n", btreg);
d1480 1
a1480 1
		panic("tga_ramdac_wr: reg %d out of range\n", btreg);
d1551 1
a1551 1
		panic("tga_ramdac_rd: reg %d out of range\n", btreg);
d1570 1
a1570 1
		panic("tga_ramdac_rd: reg %d out of range\n", btreg);
d1680 1
a1680 1
		panic("unrecognized clock rate %d\n", dotclock);
@


1.16
log
@use the gallant 12x22 font by default on screens that are more
than 960 pixels wide if !SMALL_KERNEL, like rcons does.
Ok drahn@@, mickey@@, miod@@.x
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.15 2002/04/26 20:04:50 matthieu Exp $ */
d88 8
a95 8
int tga_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t tga_mmap(void *, off_t, int);
static void tga_copyrows(void *, int, int, int);
static void tga_copycols(void *, int, int, int, int);
static int tga_alloc_screen(void *, const struct wsscreen_descr *,
				      void **, int *, int *, long *);
static void tga_free_screen(void *, void *);
static int tga_show_screen(void *, void *, int,
d97 2
a98 1
static int tga_rop(struct rasops_info *, int, int, int, int, int,
d100 1
a100 1
static int tga_rop_vtov(struct rasops_info *, int, int, int, int,
d102 4
a105 5
static void tga_putchar(void *c, int row, int col,
				u_int uc, long attr);
static void tga_eraserows(void *, int, int, long);
static void	tga_erasecols(void *, int, int, int, long);
void tga2_init(struct tga_devconfig *);
d107 1
a107 1
void tga_config_interrupts(struct device *);
d110 7
a116 7
int		tga_sched_update(void *, void (*)(void *));
void		tga_ramdac_wr(void *, u_int, u_int8_t);
u_int8_t	tga_ramdac_rd(void *, u_int);
void		tga_bt463_wr(void *, u_int, u_int8_t);
u_int8_t	tga_bt463_rd(void *, u_int);
void		tga2_ramdac_wr(void *, u_int, u_int8_t);
u_int8_t	tga2_ramdac_rd(void *, u_int);
d159 3
a161 1
	NULL			/* scrollback */
d383 1
a383 1
	if (wsfont_lock(cookie, &dc->dc_rinfo.ri_font,
d388 1
a388 1
	dc->dc_rinfo.ri_wsfcookie = cookie;
d390 2
a391 2
	rasops_init(rip, dc->dc_ht / rip->ri_font->fontheight,
		     dc->dc_wid / rip->ri_font->fontwidth); 
d397 10
a406 11
	dc->dc_rinfo.ri_ops.copyrows = tga_copyrows;
	dc->dc_rinfo.ri_ops.eraserows = tga_eraserows;
	dc->dc_rinfo.ri_ops.erasecols = tga_erasecols;
	dc->dc_rinfo.ri_ops.copycols = tga_copycols;
	dc->dc_rinfo.ri_ops.putchar = tga_putchar;	

	tga_stdscreen.nrows = dc->dc_rinfo.ri_rows;
	tga_stdscreen.ncols = dc->dc_rinfo.ri_cols;
	tga_stdscreen.textops = &dc->dc_rinfo.ri_ops;
	tga_stdscreen.capabilities = dc->dc_rinfo.ri_caps;

d550 2
d727 1
a727 1
		offset += dc->dc_tgaconf->tgac_cspace_size/2;
d838 14
d917 1
a917 1
				((cursorp->pos.y & 0xfff) << 12) | (cursorp->pos.x & 0xfff));
d1327 1
a1327 1
	while(height--) {
d1403 3
a1405 3
void *c;
int row, col, num;
long attr;
d1691 2
a1692 2
	for (i=24; i>0; i--) {
		u_int32_t       writeval;
@


1.15
log
@Add support for the WSDISPLAYIO_LINEBYTES ioctl and the
WSDISPLAYIO_MODE_DUMBFB  mode (mode where mmapping /dev/ttyC0 maps
the framebuffer only)
This makes the XF4 wsfb driver work on the TGA cards.
Ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.14 2002/04/01 11:26:32 matthieu Exp $ */
d367 7
a373 2
	/* prefer 8 pixel wide font */
	if ((cookie = wsfont_find(NULL, 8, 0, 0)) <= 0)
d389 1
a389 2
			dc->dc_wid / rip->ri_font->fontwidth);
	/* rasops_init(rip, 34, 80); */
@


1.14
log
@Add support for PowerStorm 4D20 TGA boqrds with IBM 561 ramdac (aka
32bit TGA) From NetBSD, ok deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.13 2002/04/01 11:17:47 matthieu Exp $ */
d575 14
d598 3
d710 2
d713 2
a714 1
	/* XXX NEW MAPPING CODE... */
d716 6
a722 4
	struct tga_softc *sc = v;

	if (offset >= sc->sc_dc->dc_tgaconf->tgac_cspace_size || offset < 0)
		return -1;
a724 4
	struct tga_softc *sc = v;

	if (offset >= sc->sc_dc->dc_tgaconf->tgac_cspace_size || offset < 0)
		return -1;
@


1.13
log
@Only call dc_ramdac_intr if initialized(). Fixes a panic when
starting Xtga. From NetBSD. ok deraadt@@
@
text
@d1 2
a2 2
/* $OpenBSD: tga.c,v 1.12 2002/03/14 03:16:06 millert Exp $ */
/* $NetBSD: tga.c,v 1.31 2001/02/11 19:34:58 nathanw Exp $ */
d52 1
d84 1
d105 1
a105 1
void tga2_init(struct tga_devconfig *, int);
d277 1
a277 5
		int	monitor;

		monitor = (~TGARREG(dc, TGA_REG_GREV) >> 16) & 0x0f;
		DPRINTF("tga_getdevconfig: tga2_init\n");
		tga2_init(dc, monitor);
d382 4
a385 1
	rasops_init(rip, 34, 80);
d505 6
a511 1

d580 1
a580 1
		wsd_fbip->cmsize = 256;		/* XXX ??? */
d787 8
a794 4
	if (dcp->dc_tga2)
		bt485_cninit(dcp, tga_sched_update, tga2_ramdac_wr,
		    tga2_ramdac_rd);
	else {
d1546 2
d1549 1
a1549 1
tga2_init(dc, m)
a1550 1
	int m;
d1552 2
d1555 14
a1568 1
	tga2_ics9110_wr(dc, decmonitors[m].dotclock);
d1571 4
a1574 4
	     ((decmonitors[m].hbp / 4) << 21) |
	     ((decmonitors[m].hsync / 4) << 14) |
	    (((decmonitors[m].hfp - 4) / 4) << 9) |
	     ((decmonitors[m].cols + 4) / 4));
d1577 4
a1580 4
	     ((decmonitors[m].hbp / 4) << 21) |
	     ((decmonitors[m].hsync / 4) << 14) |
	    (((decmonitors[m].hfp) / 4) << 9) |
	     ((decmonitors[m].cols) / 4));
d1583 4
a1586 4
	    (decmonitors[m].vbp << 22) |
	    (decmonitors[m].vsync << 16) |
	    (decmonitors[m].vfp << 11) |
	    (decmonitors[m].rows));
d1638 2
d1667 14
@


1.12
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.11 2002/03/14 01:27:00 millert Exp $ */
d671 5
a675 2
	dc->dc_ramdac_intr(dcrc);
	dc->dc_ramdac_intr = NULL;
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.10 2001/11/06 19:53:19 miod Exp $ */
d93 2
a94 2
static int tga_show_screen __P((void *, void *, int,
				void (*) (void *, int, int), void *));
d108 1
a108 1
int		tga_sched_update __P((void *, void (*)(void *)));
@


1.10
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.9 2001/09/16 00:42:44 millert Exp $ */
d67 3
a69 3
int	tgamatch __P((struct device *, struct cfdata *, void *));
void	tgaattach __P((struct device *, struct device *, void *));
int	tgaprint __P((void *, const char *));
d79 4
a82 4
int	tga_identify __P((struct tga_devconfig *));
const struct tga_conf *tga_getconf __P((int));
void	tga_getdevconfig __P((bus_space_tag_t memt, pci_chipset_tag_t pc,
	    pcitag_t tag, struct tga_devconfig *dc));
d86 7
a92 7
int tga_ioctl __P((void *, u_long, caddr_t, int, struct proc *));
paddr_t tga_mmap __P((void *, off_t, int));
static void tga_copyrows __P((void *, int, int, int));
static void tga_copycols __P((void *, int, int, int, int));
static int tga_alloc_screen __P((void *, const struct wsscreen_descr *,
				      void **, int *, int *, long *));
static void tga_free_screen __P((void *, void *));
d95 9
a103 9
static int tga_rop __P((struct rasops_info *, int, int, int, int, int,
	struct rasops_info *, int, int));
static int tga_rop_vtov __P((struct rasops_info *, int, int, int, int,
	int, struct rasops_info *, int, int ));
static void tga_putchar __P((void *c, int row, int col,
				u_int uc, long attr));
static void tga_eraserows __P((void *, int, int, long));
static void	tga_erasecols __P((void *, int, int, int, long));
void tga2_init __P((struct tga_devconfig *, int));
d105 1
a105 1
void tga_config_interrupts __P((struct device *));
d109 6
a114 6
void		tga_ramdac_wr __P((void *, u_int, u_int8_t));
u_int8_t	tga_ramdac_rd __P((void *, u_int));
void		tga_bt463_wr __P((void *, u_int, u_int8_t));
u_int8_t	tga_bt463_rd __P((void *, u_int));
void		tga2_ramdac_wr __P((void *, u_int, u_int8_t));
u_int8_t	tga2_ramdac_rd __P((void *, u_int));
d117 1
a117 1
int	tga_intr __P((void *));
d160 2
a161 2
void	tga_blank __P((struct tga_devconfig *));
void	tga_unblank __P((struct tga_devconfig *));
d624 1
a624 1
	void	(*f) __P((void *));
d746 1
a746 1
	void (*cb) __P((void *, int, int));
d1528 1
a1528 1
void tga2_ics9110_wr __P((
d1531 1
a1531 1
));
@


1.10.2.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $NetBSD: tga.c,v 1.40 2002/03/13 15:05:18 ad Exp $ */
a51 1
#include <dev/ic/ibm561var.h>
d67 3
a69 3
int	tgamatch(struct device *, struct cfdata *, void *);
void	tgaattach(struct device *, struct device *, void *);
int	tgaprint(void *, const char *);
d79 4
a82 5
int	tga_identify(struct tga_devconfig *);
const struct tga_conf *tga_getconf(int);
void	tga_getdevconfig(bus_space_tag_t memt, pci_chipset_tag_t pc,
	    pcitag_t tag, struct tga_devconfig *dc);
unsigned tga_getdotclock(struct tga_devconfig *dc);
d86 18
a103 18
int tga_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t tga_mmap(void *, off_t, int);
static void tga_copyrows(void *, int, int, int);
static void tga_copycols(void *, int, int, int, int);
static int tga_alloc_screen(void *, const struct wsscreen_descr *,
				      void **, int *, int *, long *);
static void tga_free_screen(void *, void *);
static int tga_show_screen(void *, void *, int,
			   void (*) (void *, int, int), void *);
static int tga_rop(struct rasops_info *, int, int, int, int, int,
	struct rasops_info *, int, int);
static int tga_rop_vtov(struct rasops_info *, int, int, int, int,
	int, struct rasops_info *, int, int );
static void tga_putchar(void *c, int row, int col,
				u_int uc, long attr);
static void tga_eraserows(void *, int, int, long);
static void	tga_erasecols(void *, int, int, int, long);
void tga2_init(struct tga_devconfig *);
d105 1
a105 1
void tga_config_interrupts(struct device *);
d108 7
a114 7
int		tga_sched_update(void *, void (*)(void *));
void		tga_ramdac_wr(void *, u_int, u_int8_t);
u_int8_t	tga_ramdac_rd(void *, u_int);
void		tga_bt463_wr(void *, u_int, u_int8_t);
u_int8_t	tga_bt463_rd(void *, u_int);
void		tga2_ramdac_wr(void *, u_int, u_int8_t);
u_int8_t	tga2_ramdac_rd(void *, u_int);
d117 1
a117 1
int	tga_intr(void *);
d160 2
a161 2
void	tga_blank(struct tga_devconfig *);
void	tga_unblank(struct tga_devconfig *);
d275 5
a279 1
		tga2_init(dc);
d369 2
a370 7
	if (rip->ri_width > 80*12) 
		/* High res screen, choose a big font */
		cookie = wsfont_find(NULL, 12, 0, 0);
	else 
		/*  lower res, choose a 8 pixel wide font */
		cookie = wsfont_find(NULL, 8, 0, 0);
	if (cookie <= 0)
d384 1
a384 3
	/* fill screen size */
	rasops_init(rip, dc->dc_ht / rip->ri_font->fontheight,
		     dc->dc_wid / rip->ri_font->fontwidth); 
d504 1
a505 6
		/* XXX this is a bit of a hack, setting the dotclock here */
		if (sc->sc_dc->dc_tgaconf->ramdac_funcs != bt485_funcs)
			(*sc->sc_dc->dc_ramdac_funcs->ramdac_set_dotclock)
				(sc->sc_dc->dc_ramdac_cookie,
				 tga_getdotclock(sc->sc_dc));
	}
a568 14
	case WSDISPLAYIO_SMODE:
		sc->sc_mode = *(u_int *)data;
		switch (sc->sc_mode) {
		case WSDISPLAYIO_MODE_DUMBFB:
			/* in dump fb mode start the framebuffer at 0 */
			TGAWREG(dc, TGA_REG_VVBR, 0);
			break;
		default:
			/* XXX it this useful, except for not breaking Xtga? */
			TGAWREG(dc, TGA_REG_VVBR, 1);
			break;			
		}
		return (0);

d574 1
a574 1
		wsd_fbip->cmsize = 1024;		/* XXX ??? */
a577 3
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_dc->dc_rowbytes;
		return 0;
d624 1
a624 1
	void	(*f)(void *);
d671 2
a672 5
	/* if we have something to do, do it */
	if (dc->dc_ramdac_intr) {
		dc->dc_ramdac_intr(dcrc);
		dc->dc_ramdac_intr = NULL;
	}
d684 4
a688 1
	struct tga_devconfig *dc = sc->sc_dc;
d690 1
a690 1
	if (offset >= dc->dc_tgaconf->tgac_cspace_size || offset < 0)
a691 8

	if (sc->sc_mode == WSDISPLAYIO_MODE_DUMBFB) {
		/* 
		 * The framebuffer starts at the upper half of tga mem
		 */
		offset += dc->dc_tgaconf->tgac_cspace_size/2;
	}
#if defined(__alpha__)
d694 4
d746 1
a746 1
	void (*cb)(void *, int, int);
d778 4
a781 8
	if (dcp->dc_tga2) {
		if (dcp->dc_tgaconf->ramdac_funcs == bt485_funcs)
			bt485_cninit(dcp, tga_sched_update, tga2_ramdac_wr,
				     tga2_ramdac_rd);
		else
			ibm561_cninit(dcp, tga_sched_update, tga2_ramdac_wr,
				      tga2_ramdac_rd, tga_getdotclock(dcp));
	} else {
d1528 1
a1528 1
void tga2_ics9110_wr(
d1531 1
a1531 3
);

struct monitor *tga_getmonitor(struct tga_devconfig *dc);
d1534 1
a1534 1
tga2_init(dc)
d1536 1
a1537 1
	struct	monitor *m = tga_getmonitor(dc);
d1539 1
a1539 15

	/* Deal with the dot clocks.
	 */
	if (dc->dc_tga_type == TGA_TYPE_POWERSTORM_4D20) {
		/* Set this up as a reference clock for the
		 * ibm561's PLL.
		 */
		tga2_ics9110_wr(dc, 14300000);
		/* XXX Can't set up the dotclock properly, until such time
		 * as the RAMDAC is configured.
		 */
	} else {
		/* otherwise the ics9110 is our clock. */
		tga2_ics9110_wr(dc, m->dotclock);
	}
d1542 4
a1545 4
	     ((m->hbp / 4) << 21) |
	     ((m->hsync / 4) << 14) |
	    (((m->hfp - 4) / 4) << 9) |
	     ((m->cols + 4) / 4));
d1548 4
a1551 4
	     ((m->hbp / 4) << 21) |
	     ((m->hsync / 4) << 14) |
	    (((m->hfp) / 4) << 9) |
	     ((m->cols) / 4));
d1554 4
a1557 4
	    (m->vbp << 22) |
	    (m->vsync << 16) |
	    (m->vfp << 11) |
	    (m->rows));
a1608 2
       case  14300000:         /* this one is just a ref clock */
               N = 0x03; M = 0x03; V = 0x1; X = 0x1; R = 0x3; break;
a1635 14
}

struct monitor *
tga_getmonitor(dc)
       struct tga_devconfig *dc;
{
       return &decmonitors[(~TGARREG(dc, TGA_REG_GREV) >> 16) & 0x0f];
}

unsigned
tga_getdotclock(dc)
       struct tga_devconfig *dc;
{
       return tga_getmonitor(dc)->dotclock;
@


1.10.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.10.2.1 2002/06/11 03:42:27 art Exp $ */
d88 8
a95 8
int	tga_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	tga_mmap(void *, off_t, int);
void	tga_copyrows(void *, int, int, int);
void	tga_copycols(void *, int, int, int, int);
int	tga_alloc_screen(void *, const struct wsscreen_descr *,
	    void **, int *, int *, long *);
void	tga_free_screen(void *, void *);
int	tga_show_screen(void *, void *, int,
d97 1
a97 2
void	tga_burner(void *, u_int, u_int);
int	tga_rop(struct rasops_info *, int, int, int, int, int,
d99 1
a99 1
int	tga_rop_vtov(struct rasops_info *, int, int, int, int,
d101 5
a105 4
void	tga_putchar(void *c, int row, int col, u_int uc, long attr);
void	tga_eraserows(void *, int, int, long);
void	tga_erasecols(void *, int, int, int, long);
void	tga2_init(struct tga_devconfig *);
d107 1
a107 1
void	tga_config_interrupts(struct device *);
d110 7
a116 7
int	 tga_sched_update(void *, void (*)(void *));
void	 tga_ramdac_wr(void *, u_int, u_int8_t);
u_int8_t tga_ramdac_rd(void *, u_int);
void	 tga_bt463_wr(void *, u_int, u_int8_t);
u_int8_t tga_bt463_rd(void *, u_int);
void	 tga2_ramdac_wr(void *, u_int, u_int8_t);
u_int8_t tga2_ramdac_rd(void *, u_int);
d159 1
a159 3
	NULL,			/* scrollback */
	NULL,			/* getchar */
	tga_burner,
d381 1
a381 1
	if (wsfont_lock(cookie, &rip->ri_font,
d386 1
a386 1
	rip->ri_wsfcookie = cookie;
d388 2
a389 2
	rasops_init(rip, rip->ri_height / rip->ri_font->fontheight,
	    rip->ri_width / rip->ri_font->fontwidth); 
d395 11
a405 10
	rip->ri_ops.copyrows = tga_copyrows;
	rip->ri_ops.eraserows = tga_eraserows;
	rip->ri_ops.erasecols = tga_erasecols;
	rip->ri_ops.copycols = tga_copycols;
	rip->ri_ops.putchar = tga_putchar;	

	tga_stdscreen.nrows = rip->ri_rows;
	tga_stdscreen.ncols = rip->ri_cols;
	tga_stdscreen.textops = &rip->ri_ops;
	tga_stdscreen.capabilities = rip->ri_caps;
a548 2
#else
	tga_config_interrupts(self);
d724 1
a724 1
		offset += dc->dc_tgaconf->tgac_cspace_size / 2;
a834 14
tga_burner(v, on, flags)
	void *v;
	u_int on, flags;
{
	struct tga_softc *sc = v;

	if (on) {
		tga_unblank(sc->sc_dc);
	} else {
		tga_blank(sc->sc_dc);
	}
}

void
d900 1
a900 1
		    ((cursorp->pos.y & 0xfff) << 12) | (cursorp->pos.x & 0xfff));
d1310 1
a1310 1
	while (height--) {
d1386 3
a1388 3
	void *c;
	int row, col, num;
	long attr;
d1447 1
a1447 1
		panic("tga_ramdac_wr: reg %d out of range", btreg);
d1463 1
a1463 1
		panic("tga_ramdac_wr: reg %d out of range", btreg);
d1534 1
a1534 1
		panic("tga_ramdac_rd: reg %d out of range", btreg);
d1553 1
a1553 1
		panic("tga_ramdac_rd: reg %d out of range", btreg);
d1663 1
a1663 1
		panic("unrecognized clock rate %d", dotclock);
d1674 2
a1675 2
	for (i = 24; i > 0; i--) {
		u_int32_t writeval;
@


1.10.2.3
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a175 5
const struct pci_matchid tga_devices[] = {
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_21030 },
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_PBXGB },
};

d182 1
a182 3
	if (pci_matchbyid((struct pci_attach_args *)aux, tga_devices,
	    sizeof(tga_devices) / sizeof(tga_devices[0])))
		return (10);	/* need to return more than vga_pci here! */
d184 10
d898 4
d924 1
a924 2
		/* The cursor is 2 bits deep, and there is no mask */
		count = (cursorp->size.y * 64 * 2) / NBBY;
d927 3
a929 3
		if ((error = copyin(cursorp->image,(char *)(dc->dc_vaddr +
		    (TGARREG(dc, TGA_REG_CCBR) & 0x3ff)), count)) != 0)
			return (error);
@


1.9
log
@Add some missing lengths checks when passing data from userland to
kernel.  From based on NetBSD patches.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.8 2001/08/25 10:13:30 art Exp $ */
a57 1
#include <vm/vm.h>
@


1.8
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.7 2001/05/16 19:33:33 mickey Exp $ */
d834 2
a835 1
	int count, error, v;
d890 2
a891 1
	int count, error;
@


1.7
log
@malloc memory w/ NOWAIT during autoconf time, and check for NULL
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.6 2001/03/19 00:18:05 aaron Exp $ */
d443 1
a443 2
	if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
			 pa->pa_intrline, &intrh)) {
@


1.6
log
@Placeholder for a tga_scrollback function, although this will probably
never exist (at some point we'll want a more device-independent way to do
scrollback, possibly even with the already-existing msgbuf facilities?)
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.5 2001/03/18 04:37:21 nate Exp $ */
d429 3
a431 1
		    malloc(sizeof(struct tga_devconfig), M_DEVBUF, M_WAITOK);
@


1.6.2.1
log
@MFS (from millert):
Add some missing lengths checks when passing data from userland to
kernel.  From based on NetBSD patches.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.6 2001/03/19 00:18:05 aaron Exp $ */
d833 1
a833 2
	u_int count, v;
	int error;
d888 1
a888 2
	int error;
	u_int count;
@


1.6.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.6 2001/03/19 00:18:05 aaron Exp $ */
@


1.6.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.6.4.1 2001/05/14 22:25:57 niklas Exp $ */
d429 1
a429 3
		    malloc(sizeof(struct tga_devconfig), M_DEVBUF, M_NOWAIT);
		if (sc->sc_dc == NULL)
			return;
@


1.6.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.6.4.2 2001/07/04 10:43:04 niklas Exp $ */
d443 2
a444 1
	if (pci_intr_map(pa, &intrh)) {
d835 1
a835 2
	u_int count, v;
	int error;
d890 1
a890 2
	int error;
	u_int count;
@


1.6.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d58 1
@


1.6.4.5
log
@Merge in -current from roughly a week ago
@
text
@d67 3
a69 3
int	tgamatch(struct device *, struct cfdata *, void *);
void	tgaattach(struct device *, struct device *, void *);
int	tgaprint(void *, const char *);
d79 4
a82 4
int	tga_identify(struct tga_devconfig *);
const struct tga_conf *tga_getconf(int);
void	tga_getdevconfig(bus_space_tag_t memt, pci_chipset_tag_t pc,
	    pcitag_t tag, struct tga_devconfig *dc);
d86 18
a103 18
int tga_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t tga_mmap(void *, off_t, int);
static void tga_copyrows(void *, int, int, int);
static void tga_copycols(void *, int, int, int, int);
static int tga_alloc_screen(void *, const struct wsscreen_descr *,
				      void **, int *, int *, long *);
static void tga_free_screen(void *, void *);
static int tga_show_screen(void *, void *, int,
			   void (*) (void *, int, int), void *);
static int tga_rop(struct rasops_info *, int, int, int, int, int,
	struct rasops_info *, int, int);
static int tga_rop_vtov(struct rasops_info *, int, int, int, int,
	int, struct rasops_info *, int, int );
static void tga_putchar(void *c, int row, int col,
				u_int uc, long attr);
static void tga_eraserows(void *, int, int, long);
static void	tga_erasecols(void *, int, int, int, long);
void tga2_init(struct tga_devconfig *, int);
d105 1
a105 1
void tga_config_interrupts(struct device *);
d108 7
a114 7
int		tga_sched_update(void *, void (*)(void *));
void		tga_ramdac_wr(void *, u_int, u_int8_t);
u_int8_t	tga_ramdac_rd(void *, u_int);
void		tga_bt463_wr(void *, u_int, u_int8_t);
u_int8_t	tga_bt463_rd(void *, u_int);
void		tga2_ramdac_wr(void *, u_int, u_int8_t);
u_int8_t	tga2_ramdac_rd(void *, u_int);
d117 1
a117 1
int	tga_intr(void *);
d160 2
a161 2
void	tga_blank(struct tga_devconfig *);
void	tga_unblank(struct tga_devconfig *);
d624 1
a624 1
	void	(*f)(void *);
d746 1
a746 1
	void (*cb)(void *, int, int);
d1528 1
a1528 1
void tga2_ics9110_wr(
d1531 1
a1531 1
);
@


1.6.4.6
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/* $NetBSD: tga.c,v 1.40 2002/03/13 15:05:18 ad Exp $ */
a51 1
#include <dev/ic/ibm561var.h>
a82 1
unsigned tga_getdotclock(struct tga_devconfig *dc);
d86 8
a93 8
int	tga_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	tga_mmap(void *, off_t, int);
void	tga_copyrows(void *, int, int, int);
void	tga_copycols(void *, int, int, int, int);
int	tga_alloc_screen(void *, const struct wsscreen_descr *,
	    void **, int *, int *, long *);
void	tga_free_screen(void *, void *);
int	tga_show_screen(void *, void *, int,
d95 1
a95 2
void	tga_burner(void *, u_int, u_int);
int	tga_rop(struct rasops_info *, int, int, int, int, int,
d97 1
a97 1
int	tga_rop_vtov(struct rasops_info *, int, int, int, int,
d99 5
a103 4
void	tga_putchar(void *c, int row, int col, u_int uc, long attr);
void	tga_eraserows(void *, int, int, long);
void	tga_erasecols(void *, int, int, int, long);
void	tga2_init(struct tga_devconfig *);
d105 1
a105 1
void	tga_config_interrupts(struct device *);
d108 7
a114 7
int	 tga_sched_update(void *, void (*)(void *));
void	 tga_ramdac_wr(void *, u_int, u_int8_t);
u_int8_t tga_ramdac_rd(void *, u_int);
void	 tga_bt463_wr(void *, u_int, u_int8_t);
u_int8_t tga_bt463_rd(void *, u_int);
void	 tga2_ramdac_wr(void *, u_int, u_int8_t);
u_int8_t tga2_ramdac_rd(void *, u_int);
d157 1
a157 3
	NULL,			/* scrollback */
	NULL,			/* getchar */
	tga_burner,
d275 5
a279 1
		tga2_init(dc);
d369 2
a370 7
	if (rip->ri_width > 80*12) 
		/* High res screen, choose a big font */
		cookie = wsfont_find(NULL, 12, 0, 0);
	else 
		/*  lower res, choose a 8 pixel wide font */
		cookie = wsfont_find(NULL, 8, 0, 0);
	if (cookie <= 0)
d378 1
a378 1
	if (wsfont_lock(cookie, &rip->ri_font,
d383 2
a384 4
	rip->ri_wsfcookie = cookie;
	/* fill screen size */
	rasops_init(rip, rip->ri_height / rip->ri_font->fontheight,
	    rip->ri_width / rip->ri_font->fontwidth); 
d390 11
a400 10
	rip->ri_ops.copyrows = tga_copyrows;
	rip->ri_ops.eraserows = tga_eraserows;
	rip->ri_ops.erasecols = tga_erasecols;
	rip->ri_ops.copycols = tga_copycols;
	rip->ri_ops.putchar = tga_putchar;	

	tga_stdscreen.nrows = rip->ri_rows;
	tga_stdscreen.ncols = rip->ri_cols;
	tga_stdscreen.textops = &rip->ri_ops;
	tga_stdscreen.capabilities = rip->ri_caps;
d504 1
a505 6
		/* XXX this is a bit of a hack, setting the dotclock here */
		if (sc->sc_dc->dc_tgaconf->ramdac_funcs != bt485_funcs)
			(*sc->sc_dc->dc_ramdac_funcs->ramdac_set_dotclock)
				(sc->sc_dc->dc_ramdac_cookie,
				 tga_getdotclock(sc->sc_dc));
	}
a538 2
#else
	tga_config_interrupts(self);
a568 14
	case WSDISPLAYIO_SMODE:
		sc->sc_mode = *(u_int *)data;
		switch (sc->sc_mode) {
		case WSDISPLAYIO_MODE_DUMBFB:
			/* in dump fb mode start the framebuffer at 0 */
			TGAWREG(dc, TGA_REG_VVBR, 0);
			break;
		default:
			/* XXX it this useful, except for not breaking Xtga? */
			TGAWREG(dc, TGA_REG_VVBR, 1);
			break;			
		}
		return (0);

d574 1
a574 1
		wsd_fbip->cmsize = 1024;		/* XXX ??? */
a577 3
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_dc->dc_rowbytes;
		return 0;
d671 2
a672 5
	/* if we have something to do, do it */
	if (dc->dc_ramdac_intr) {
		dc->dc_ramdac_intr(dcrc);
		dc->dc_ramdac_intr = NULL;
	}
d684 4
a688 1
	struct tga_devconfig *dc = sc->sc_dc;
d690 1
a690 1
	if (offset >= dc->dc_tgaconf->tgac_cspace_size || offset < 0)
a691 8

	if (sc->sc_mode == WSDISPLAYIO_MODE_DUMBFB) {
		/* 
		 * The framebuffer starts at the upper half of tga mem
		 */
		offset += dc->dc_tgaconf->tgac_cspace_size / 2;
	}
#if defined(__alpha__)
d694 4
d778 4
a781 8
	if (dcp->dc_tga2) {
		if (dcp->dc_tgaconf->ramdac_funcs == bt485_funcs)
			bt485_cninit(dcp, tga_sched_update, tga2_ramdac_wr,
				     tga2_ramdac_rd);
		else
			ibm561_cninit(dcp, tga_sched_update, tga2_ramdac_wr,
				      tga2_ramdac_rd, tga_getdotclock(dcp));
	} else {
a799 14
tga_burner(v, on, flags)
	void *v;
	u_int on, flags;
{
	struct tga_softc *sc = v;

	if (on) {
		tga_unblank(sc->sc_dc);
	} else {
		tga_blank(sc->sc_dc);
	}
}

void
d846 4
d865 1
a865 1
		    ((cursorp->pos.y & 0xfff) << 12) | (cursorp->pos.x & 0xfff));
d872 1
a872 2
		/* The cursor is 2 bits deep, and there is no mask */
		count = (cursorp->size.y * 64 * 2) / NBBY;
d875 3
a877 3
		if ((error = copyin(cursorp->image,(char *)(dc->dc_vaddr +
		    (TGARREG(dc, TGA_REG_CCBR) & 0x3ff)), count)) != 0)
			return (error);
d1275 1
a1275 1
	while (height--) {
d1351 3
a1353 3
	void *c;
	int row, col, num;
	long attr;
d1412 1
a1412 1
		panic("tga_ramdac_wr: reg %d out of range", btreg);
d1428 1
a1428 1
		panic("tga_ramdac_wr: reg %d out of range", btreg);
d1499 1
a1499 1
		panic("tga_ramdac_rd: reg %d out of range", btreg);
d1518 1
a1518 1
		panic("tga_ramdac_rd: reg %d out of range", btreg);
a1532 2
struct monitor *tga_getmonitor(struct tga_devconfig *dc);

d1534 1
a1534 1
tga2_init(dc)
d1536 1
a1537 2
	struct	monitor *m = tga_getmonitor(dc);

d1539 1
a1539 14
	/* Deal with the dot clocks.
	 */
	if (dc->dc_tga_type == TGA_TYPE_POWERSTORM_4D20) {
		/* Set this up as a reference clock for the
		 * ibm561's PLL.
		 */
		tga2_ics9110_wr(dc, 14300000);
		/* XXX Can't set up the dotclock properly, until such time
		 * as the RAMDAC is configured.
		 */
	} else {
		/* otherwise the ics9110 is our clock. */
		tga2_ics9110_wr(dc, m->dotclock);
	}
d1542 4
a1545 4
	     ((m->hbp / 4) << 21) |
	     ((m->hsync / 4) << 14) |
	    (((m->hfp - 4) / 4) << 9) |
	     ((m->cols + 4) / 4));
d1548 4
a1551 4
	     ((m->hbp / 4) << 21) |
	     ((m->hsync / 4) << 14) |
	    (((m->hfp) / 4) << 9) |
	     ((m->cols) / 4));
d1554 4
a1557 4
	    (m->vbp << 22) |
	    (m->vsync << 16) |
	    (m->vfp << 11) |
	    (m->rows));
a1608 2
       case  14300000:         /* this one is just a ref clock */
               N = 0x03; M = 0x03; V = 0x1; X = 0x1; R = 0x3; break;
d1610 1
a1610 1
		panic("unrecognized clock rate %d", dotclock);
d1621 2
a1622 2
	for (i = 24; i > 0; i--) {
		u_int32_t writeval;
a1635 14
}

struct monitor *
tga_getmonitor(dc)
       struct tga_devconfig *dc;
{
       return &decmonitors[(~TGARREG(dc, TGA_REG_GREV) >> 16) & 0x0f];
}

unsigned
tga_getdotclock(dc)
       struct tga_devconfig *dc;
{
       return tga_getmonitor(dc)->dotclock;
@


1.6.4.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.6.4.6 2003/03/28 00:38:25 niklas Exp $ */
a175 5
const struct pci_matchid tga_devices[] = {
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_21030 },
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_PBXGB },
};

d182 4
a185 3
	if (pci_matchbyid((struct pci_attach_args *)aux, tga_devices,
	    sizeof(tga_devices) / sizeof(tga_devices[0])))
		return (10);	/* need to return more than vga_pci here! */
d187 7
@


1.6.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d59 2
d205 1
a205 1
	int i;
d215 1
a215 1
	    &dc->dc_pcipaddr, &pcisize, NULL))
d217 2
@


1.6.4.9
log
@Merge with the trunk
@
text
@d96 1
a96 1
int	tga_rop(struct rasops_info *, int, int, int, int,
d98 1
a98 1
int	tga_rop_vtov(struct rasops_info *, int, int, int,
d1003 3
a1005 1
	tga_rop(ri, dstx, y, nx, ri->ri_font->fontheight, ri, srcx, y);
d1023 3
a1025 1
	tga_rop(ri, 0, dsty, ri->ri_emuwidth, ny, ri, 0, srcy);
d1028 8
d1042 1
a1042 1
tga_rop(dst, dx, dy, w, h, src, sx, sy)
d1044 1
a1044 1
	int dx, dy, w, h;
d1048 1
a1048 1
	if (dst == NULL || src == NULL)
d1050 20
a1069 15

	/* Clip against src */
	if (sx < 0) {
		w += sx;
		sx = 0;
	}
	if (sy < 0) {
		h += sy;
		sy = 0;
	}
	if (sx + w > src->ri_emuwidth)
		w = src->ri_emuwidth - sx;
	if (sy + h > src->ri_emuheight)
		h = src->ri_emuheight - sy;

d1089 5
a1093 2

	return tga_rop_vtov(dst, dx, dy, w, h, src, sx, sy);
d1104 1
a1104 1
tga_rop_vtov(dst, dx, dy, w, h, src, sx, sy)
d1106 1
a1106 1
	int dx, dy, w, h;
d1164 1
a1164 1
	TGAWALREG(dc, TGA_REG_GOPR, 3, 0x0003); /* SRC */
@


1.5
log
@New TGA driver for alpha.  Takes advantage of rasops code.
This now gives a working console on alpha when using TGA.
Code from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.4 2001/02/01 18:06:35 art Exp $ */
d157 2
a158 1
	0 /* load_font */
@


1.4
log
@adapt to wscons type changes.
@
text
@d1 2
a2 2
/* $OpenBSD: tga.c,v 1.3 2000/10/14 18:04:07 aaron Exp $ */
/* $NetBSD: tga.c,v 1.15 1999/12/06 19:25:59 drochner Exp $ */
a39 2
#include <vm/vm.h>

d50 2
a52 1
#include <dev/rcons/raster.h>
d55 12
a66 1
#include <dev/wscons/wsdisplayvar.h>
d80 1
a80 1
int	tga_identify __P((tga_reg_t *));
d82 2
a83 2
void    tga_getdevconfig __P((bus_space_tag_t memt, pci_chipset_tag_t pc,
            pcitag_t tag, struct tga_devconfig *dc));
d96 9
a104 7
static int tga_rop __P((struct raster *, int, int, int, int, int,
	struct raster *, int, int));
static int tga_rop_nosrc __P((struct raster *, int, int, int, int, int));
static int tga_rop_htov __P((struct raster *, int, int, int, int,
	int, struct raster *, int, int ));
static int tga_rop_vtov __P((struct raster *, int, int, int, int,
	int, struct raster *, int, int ));
d106 1
a106 1
void tga2_init __P((struct tga_devconfig *, int));
d109 7
a115 5
int             tga_sched_update __P((void *, void (*)(void *)));
void            tga_ramdac_wr __P((void *, u_int, u_int8_t));
u_int8_t        tga_ramdac_rd __P((void *, u_int));
void            tga2_ramdac_wr __P((void *, u_int, u_int8_t));
u_int8_t        tga2_ramdac_rd __P((void *, u_int));
d118 1
a118 1
int     tga_intr __P((void *));
d120 3
d124 3
a126 3
	rcons_cursor,			/* could use hardware cursor; punt */
	rcons_mapchar,
	rcons_putchar,
d128 1
a128 1
	rcons_erasecols,
d130 2
a131 2
	rcons_eraserows,
	rcons_alloc_attr
d163 9
d181 1
a181 1
                return (0);
d183 8
a190 8
        switch (PCI_PRODUCT(pa->pa_id)) {
        case PCI_PRODUCT_DEC_21030:
        case PCI_PRODUCT_DEC_PBXGB:
                return 10;
        default:
                return 0;
        }
        return (0);
d201 2
a202 2
	struct raster *rap;
	struct rcons *rcp;
a206 1
	dc->dc_pc = pc;
d210 1
d212 4
a215 1
	pci_mem_find(pc, tag, 0x10, &dc->dc_pcipaddr, &pcisize, &cacheable);
d219 3
a221 4
	/* XXX XXX XXX */
	if ((i = bus_space_map(memt, dc->dc_pcipaddr, pcisize, 1, &dc->dc_vaddr))) {
printf("bus_space_map(%x, %x, %x, 0, %p): %d\n", memt, dc->dc_pcipaddr, pcisize, &dc->dc_vaddr, i);
		DELAY(90000000);
d223 9
a231 1
	}
a233 2
#else
#error "find a way to deal w/ paddr here"
d235 7
d243 2
a244 2
	dc->dc_regs = (tga_reg_t *)(dc->dc_vaddr + TGA_MEM_CREGS);
	dc->dc_tga_type = tga_identify(dc->dc_regs);
d246 1
d248 1
a248 2
	if (tgac == NULL) {
printf("tgac==0\n");
a249 1
	}
d257 2
a258 1
	switch (dc->dc_regs[TGA_REG_GREV] & 0xff) {
d275 1
a275 1
		int        monitor;
d277 2
a278 1
		monitor = (~dc->dc_regs[TGA_REG_GREV] >> 16) & 0x0f;
d281 4
a284 2

	switch (dc->dc_regs[TGA_REG_VHCR] & 0x1ff) {		/* XXX */
d294 1
a294 1
		dc->dc_wid = (dc->dc_regs[TGA_REG_VHCR] & 0x1ff) * 4; /* XXX */
d298 10
a307 4
	dc->dc_rowbytes = dc->dc_wid * (dc->dc_tgaconf->tgac_phys_depth / 8);

	if ((dc->dc_regs[TGA_REG_VHCR] & 0x00000001) != 0 &&	/* XXX */
	    (dc->dc_regs[TGA_REG_VHCR] & 0x80000000) != 0) {	/* XXX */
a308 7
		/*
		 * XXX XXX turning off 'odd' shouldn't be necesssary,
		 * XXX XXX but i can't make X work with the weird size.
		 */
		dc->dc_regs[TGA_REG_VHCR] &= ~0x80000001;
		dc->dc_rowbytes =
		    dc->dc_wid * (dc->dc_tgaconf->tgac_phys_depth / 8);
d311 6
a316 1
	dc->dc_ht = (dc->dc_regs[TGA_REG_VVCR] & 0x7ff);	/* XXX */
d319 3
a321 2
	dc->dc_regs[TGA_REG_CCBR] = 0;
	dc->dc_regs[TGA_REG_VVBR] = 1;
d327 7
d339 2
a340 1
	dc->dc_regs[TGA_REG_GPXR_P] = 0xffffffff;
d343 1
d347 53
a399 16
	/* initialize the raster */
	rap = &dc->dc_raster;
	rap->width = dc->dc_wid;
	rap->height = dc->dc_ht;
	rap->depth = tgac->tgac_phys_depth;
	rap->linelongs = dc->dc_rowbytes / sizeof(u_int32_t);
	rap->pixels = (u_int32_t *)dc->dc_videobase;
	rap->data = (caddr_t)dc;

	/* initialize the raster console blitter */
	rcp = &dc->dc_rcons;
	rcp->rc_sp = rap;
	rcp->rc_crow = rcp->rc_ccol = -1;
	rcp->rc_crowp = &rcp->rc_crow;
	rcp->rc_ccolp = &rcp->rc_ccol;
	rcons_init(rcp, 34, 80);
d401 2
a402 2
	tga_stdscreen.nrows = dc->dc_rcons.rc_maxrow;
	tga_stdscreen.ncols = dc->dc_rcons.rc_maxcol;
d418 1
a418 1
#ifdef __alpha__
d430 2
a431 2
		tga_getdevconfig(pa->pa_memt, pa->pa_pc, pa->pa_tag, 
			sc->sc_dc);
d438 29
a466 29
        /* XXX say what's going on. */
        intrstr = NULL;
        if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
            pa->pa_intrline, &intrh)) {
                printf(": couldn't map interrupt");
                return;
        }
        intrstr = pci_intr_string(pa->pa_pc, intrh);
        sc->sc_intr = pci_intr_establish(pa->pa_pc, intrh, IPL_TTY, tga_intr,
            sc->sc_dc, sc->sc_dev.dv_xname);
        if (sc->sc_intr == NULL) {
                printf(": couldn't establish interrupt");
                if (intrstr != NULL)
                        printf("at %s", intrstr);
                printf("\n");
                return;
        }

        rev = PCI_REVISION(pa->pa_class);
        switch (rev) {
        case 0x1:
        case 0x2:
        case 0x3:
                printf(": DC21030 step %c", 'A' + rev - 1);
                break;
        case 0x20:
                printf(": TGA2 abstract software model");
                break;
        case 0x21: 
d468 2
a469 2
                printf(": TGA2 pass %d", rev - 0x20);
                break;
d471 33
a503 46
        default:
                printf("unknown stepping (0x%x)", rev);
                break;
        }
        printf(", ");

        /*
         * Get RAMDAC function vectors and call the RAMDAC functions
         * to allocate its private storage and pass that back to us.
         */
        sc->sc_dc->dc_ramdac_funcs = bt485_funcs();
        if (!sc->sc_dc->dc_tga2) {
                sc->sc_dc->dc_ramdac_cookie = bt485_register(
                    sc->sc_dc, tga_sched_update, tga_ramdac_wr,
                    tga_ramdac_rd);
        } else {
                sc->sc_dc->dc_ramdac_cookie = bt485_register(
                    sc->sc_dc, tga_sched_update, tga2_ramdac_wr,
                    tga2_ramdac_rd);
        }

        /*
         * Initialize the RAMDAC.  Initialization includes disabling
         * cursor, setting a sane colormap, etc.
         */
        (*sc->sc_dc->dc_ramdac_funcs->ramdac_init)(sc->sc_dc->dc_ramdac_cookie);
        sc->sc_dc->dc_regs[TGA_REG_SISR] = 0x00000001;                 /* XXX */

        if (sc->sc_dc->dc_tgaconf == NULL) {
                printf("unknown board configuration\n");
                return;
        }
        printf("board type %s\n", sc->sc_dc->dc_tgaconf->tgac_name);
        printf("%s: %d x %d, %dbpp, %s RAMDAC\n", sc->sc_dev.dv_xname,
            sc->sc_dc->dc_wid, sc->sc_dc->dc_ht,
            sc->sc_dc->dc_tgaconf->tgac_phys_depth,
            sc->sc_dc->dc_ramdac_funcs->ramdac_name);

        if (intrstr != NULL)
                printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname,
                    intrstr);

        aa.console = console;
        aa.scrdata = &tga_screenlist;
        aa.accessops = &tga_accessops;
        aa.accesscookie = sc;
d505 34
a538 1
        config_found(self, &aa, wsemuldisplaydevprint);
d541 9
d560 2
a561 2
        struct ramdac_funcs *dcrf = dc->dc_ramdac_funcs;
        struct ramdac_cookie *dcrc = dc->dc_ramdac_cookie;
d563 11
a573 11
        switch (cmd) {
        case WSDISPLAYIO_GTYPE:
                *(u_int *)data = WSDISPLAY_TYPE_TGA;
                return (0);

        case WSDISPLAYIO_GINFO:
#define wsd_fbip ((struct wsdisplay_fbinfo *)data)
                wsd_fbip->height = sc->sc_dc->dc_ht;
                wsd_fbip->width = sc->sc_dc->dc_wid;
                wsd_fbip->depth = sc->sc_dc->dc_tgaconf->tgac_phys_depth;
                wsd_fbip->cmsize = 256;                /* XXX ??? */
d575 1
a575 1
                return (0);
d577 41
a617 41
        case WSDISPLAYIO_GETCMAP:
                return (*dcrf->ramdac_get_cmap)(dcrc,
                    (struct wsdisplay_cmap *)data);

        case WSDISPLAYIO_PUTCMAP:
                return (*dcrf->ramdac_set_cmap)(dcrc,
                    (struct wsdisplay_cmap *)data);

        case WSDISPLAYIO_SVIDEO:
                if (*(u_int *)data == WSDISPLAYIO_VIDEO_OFF)
                        tga_blank(sc->sc_dc);
                else
                        tga_unblank(sc->sc_dc);
                return (0);

        case WSDISPLAYIO_GVIDEO:
                *(u_int *)data = dc->dc_blanked ?
                    WSDISPLAYIO_VIDEO_OFF : WSDISPLAYIO_VIDEO_ON;
                return (0);

        case WSDISPLAYIO_GCURPOS:
                return (*dcrf->ramdac_get_curpos)(dcrc,
                    (struct wsdisplay_curpos *)data);

        case WSDISPLAYIO_SCURPOS:
                return (*dcrf->ramdac_set_curpos)(dcrc,
                    (struct wsdisplay_curpos *)data);

        case WSDISPLAYIO_GCURMAX:
                return (*dcrf->ramdac_get_curmax)(dcrc,
                    (struct wsdisplay_curpos *)data);

        case WSDISPLAYIO_GCURSOR:
                return (*dcrf->ramdac_get_cursor)(dcrc,
                    (struct wsdisplay_cursor *)data);

        case WSDISPLAYIO_SCURSOR:
                return (*dcrf->ramdac_set_cursor)(dcrc,
                    (struct wsdisplay_cursor *)data);
        }
        return (-1);
d622 2
a623 2
        void        *v;
        void        (*f) __P((void *));
d625 1
a625 1
        struct tga_devconfig *dc = v;
d627 16
a642 3
        dc->dc_regs[TGA_REG_SISR] = 0x00010000;
        dc->dc_ramdac_intr = f;
        return 0;
d647 1
a647 1
        void *v;
d649 2
a650 2
        struct tga_devconfig *dc = v;
        struct ramdac_cookie *dcrc= dc->dc_ramdac_cookie;
d652 23
a674 6
        if ((dc->dc_regs[TGA_REG_SISR] & 0x00010001) != 0x00010001)
                return 0;
        dc->dc_ramdac_intr(dcrc);
        dc->dc_ramdac_intr = NULL;
        dc->dc_regs[TGA_REG_SISR] = 0x00000001;
        return (1);
d686 1
a686 1
#ifdef __alpha__
d692 6
d717 1
a717 1
	*cookiep = &sc->sc_dc->dc_rcons; /* one and only for now */
d720 2
a721 1
	rcons_alloc_attr(&sc->sc_dc->dc_rcons, 0, 0, 0, &defattr);
d761 2
a762 3
        /* XXX -- we know this isn't a TGA2 for now.  rcd */
        tga_getdevconfig(memt, pc,
            pci_make_tag(pc, bus, device, function), dcp);
d777 1
a777 5

        /* XXX -- this only works for bt485, but then we only support that,
         *  currently. 
         */
	if (dcp->dc_tga2) 
d779 13
a791 10
			tga2_ramdac_rd);
	else
		bt485_cninit(dcp, tga_sched_update, tga_ramdac_wr,
			tga_ramdac_rd);

	rcons_alloc_attr(&dcp->dc_rcons, 0, 0, 0, &defattr);

	wsdisplay_cnattach(&tga_stdscreen, &dcp->dc_rcons,
			   0, 0, defattr);

d805 2
a806 1
		dc->dc_regs[TGA_REG_VVVR] |= VVR_BLANK;		/* XXX */
d817 2
a818 1
		dc->dc_regs[TGA_REG_VVVR] &= ~VVR_BLANK;	/* XXX */
d830 2
a831 2
        struct ramdac_funcs *dcrf = dc->dc_ramdac_funcs;
        struct ramdac_cookie *dcrc = dc->dc_ramdac_cookie;
a845 1
#if defined(UVM)
a847 4
#else
		if (!useracc(cursorp->image, count, B_READ))
			return (EFAULT);
#endif
d855 2
a856 1
			dc->dc_regs[TGA_REG_VVVR] |= 0x04;	/* XXX */
d858 2
a859 1
			dc->dc_regs[TGA_REG_VVVR] &= ~0x04;	/* XXX */
d862 2
a863 2
		dc->dc_regs[TGA_REG_CXYR] = ((cursorp->pos.y & 0xfff) << 12) |
		    (cursorp->pos.x & 0xfff);
d871 2
a872 3
		dc->dc_regs[TGA_REG_CCBR] =
		    (dc->dc_regs[TGA_REG_CCBR] & ~0xfc00) |
		    (cursorp->size.y << 10);
d874 1
a874 1
		    (dc->dc_regs[TGA_REG_CCBR] & 0x3ff)),
d885 23
a907 23
        struct ramdac_funcs *dcrf = dc->dc_ramdac_funcs;
        struct ramdac_cookie *dcrc = dc->dc_ramdac_cookie;
        int count, error;

        cursorp->which = WSDISPLAY_CURSOR_DOALL &
            ~(WSDISPLAY_CURSOR_DOHOT | WSDISPLAY_CURSOR_DOCMAP);
        cursorp->enable = (dc->dc_regs[TGA_REG_VVVR] & 0x04) != 0;
        cursorp->pos.x = dc->dc_regs[TGA_REG_CXYR] & 0xfff;
        cursorp->pos.y = (dc->dc_regs[TGA_REG_CXYR] >> 12) & 0xfff;
        cursorp->size.x = 64;
        cursorp->size.y = (dc->dc_regs[TGA_REG_CCBR] >> 10) & 0x3f;

        if (cursorp->image != NULL) {
                count = (cursorp->size.y * 64 * 2) / NBBY;
                error = copyout((char *)(dc->dc_vaddr +
                      (dc->dc_regs[TGA_REG_CCBR] & 0x3ff)),
                    cursorp->image, count);
                if (error)
                        return (error);
                /* No mask */
        }
        error = dcrf->ramdac_get_curcmap(dcrc, cursorp);
        return (error);
d916 2
a917 2
	dc->dc_regs[TGA_REG_CXYR] =
	    ((curposp->y & 0xfff) << 12) | (curposp->x & 0xfff);
d927 2
a928 2
	curposp->x = dc->dc_regs[TGA_REG_CXYR] & 0xfff;
	curposp->y = (dc->dc_regs[TGA_REG_CXYR] >> 12) & 0xfff;
d950 1
a950 1
	struct rcons *rc = id;
d953 8
a960 8
	y = rc->rc_yorigin + rc->rc_font->height * row;
	srcx = rc->rc_xorigin + rc->rc_font->width * srccol;
	dstx = rc->rc_xorigin + rc->rc_font->width * dstcol;
	nx = rc->rc_font->width * ncols;

	tga_rop(rc->rc_sp, dstx, y,
	    nx, rc->rc_font->height, RAS_SRC,
	    rc->rc_sp, srcx, y);
d971 1
a971 1
	struct rcons *rc = id;
d974 7
a980 7
	srcy = rc->rc_yorigin + rc->rc_font->height * srcrow;
	dsty = rc->rc_yorigin + rc->rc_font->height * dstrow;
	ny = rc->rc_font->height * nrows;

	tga_rop(rc->rc_sp, rc->rc_xorigin, dsty,
	    rc->rc_raswidth, ny, RAS_SRC,
	    rc->rc_sp, rc->rc_xorigin, srcy);
d984 1
a984 1
static int needsrc[16] = { 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0 };
d987 1
a987 1
static int map_rop[16] = { 0x0, 0x8, 0x4, 0xc, 0x2, 0xa, 0x6,
d996 1
a996 1
static int
d998 1
a998 1
	struct raster *dst;
d1000 1
a1000 1
	struct raster *src;
a1004 2
	if (dst->data == NULL)
		return -1;	/* we should be writing to a screen */
d1006 1
a1006 1
		if (src == (struct raster *) 0)
d1017 4
a1020 4
		if (sx + w > src->width)
			w = src->width - sx;
		if (sy + h > src->height)
			h = src->height - sy;
d1022 1
a1022 1
		if (src != (struct raster *) 0)
d1038 4
a1041 4
	if (dx + w > dst->width)
		w = dst->width - dx;
	if (dy + h > dst->height)
		h = dst->height - dy;
d1044 5
a1048 6
	if (!src)
		return tga_rop_nosrc(dst, dx, dy, w, h, rop);
	if (src->data == NULL)
		return tga_rop_htov(dst, dx, dy, w, h, rop, src, sx, sy);
	else
		return tga_rop_vtov(dst, dx, dy, w, h, rop, src, sx, sy);
a1050 11
/*
 * No source raster ops.
 * This function deals with all raster ops that don't require a src.
 */
static int
tga_rop_nosrc(dst, dx, dy, w, h, rop)
	struct raster *dst;
	int dx, dy, w, h, rop;
{
	return raster_op(dst, dx, dy, w, h, rop, NULL, 0, 0);
}
a1051 13
/*
 * Host to Video raster ops.
 * This function deals with all raster ops that have a src that is host memory.
 */
static int
tga_rop_htov(dst, dx, dy, w, h, rop, src, sx, sy)
	struct raster *dst;
	int dx, dy, w, h, rop;
	struct raster *src;
	int sx, sy;
{
	return raster_op(dst, dx, dy, w, h, rop, src, sx, sy);
}
d1058 1
a1058 1
static int
d1060 1
a1060 1
	struct raster *dst;
d1062 1
a1062 1
	struct raster *src;
d1065 4
a1068 8
	struct tga_devconfig *dc = (struct tga_devconfig *)dst->data;
	tga_reg_t *regs0 = dc->dc_regs;
	tga_reg_t *regs1 = regs0 + 16 * 1024;	/* register alias 1 */
	tga_reg_t *regs2 = regs1 + 16 * 1024;	/* register alias 2 */
	tga_reg_t *regs3 = regs2 + 16 * 1024;	/* register alias 3 */
	int srcb, dstb;
	int x, y;
	int xstart, xend, xdir, xinc;
d1070 1
d1077 7
a1083 2
	if (dx % 8 != 0 || sx % 8 != 0 || src != dst)
		return raster_op(dst, dx, dy, w, h, rop, src, sx, sy);
d1085 1
d1095 1
a1095 1
	if (sx >= dx) {
d1097 1
a1097 1
		xend = w * (dst->depth / 8);
d1099 2
a1100 2
	} else {
		xstart = w * (dst->depth / 8);
d1104 118
a1221 18
	xinc = xdir * 4 * 64;
	yinc = ydir * dst->linelongs * 4;
	ystart *= dst->linelongs * 4;
	yend *= dst->linelongs * 4;
	srcb = offset + sy  * src->linelongs * 4 + sx;
	dstb = offset + dy  * dst->linelongs * 4 + dx;
	regs3[TGA_REG_GMOR] = 0x0007;		/* Copy mode */
	regs3[TGA_REG_GOPR] = map_rop[rop];	/* Set up the op */
	for (y = ystart; (ydir * y) < (ydir * yend); y += yinc) {
		for (x = xstart; (xdir * x) < (xdir * xend); x += xinc) {
			regs0[TGA_REG_GCSR] = srcb + y + x + 3 * 64;
			regs0[TGA_REG_GCDR] = dstb + y + x + 3 * 64;
			regs1[TGA_REG_GCSR] = srcb + y + x + 2 * 64;
			regs1[TGA_REG_GCDR] = dstb + y + x + 2 * 64;
			regs2[TGA_REG_GCSR] = srcb + y + x + 1 * 64;
			regs2[TGA_REG_GCDR] = dstb + y + x + 1 * 64;
			regs3[TGA_REG_GCSR] = srcb + y + x + 0 * 64;
			regs3[TGA_REG_GCDR] = dstb + y + x + 0 * 64;
a1223 2
	regs0[TGA_REG_GOPR] = 0x0003;		/* op -> dst = src */
	regs0[TGA_REG_GMOR] = 0x0000;		/* Simple mode */
d1227 173
d1402 3
a1404 3
        void *v;
        u_int btreg;
        u_int8_t val;
d1406 1
a1406 2
        struct tga_devconfig *dc = v;
        volatile tga_reg_t *tgaregs = dc->dc_regs;
d1408 2
a1409 2
        if (btreg > BT485_REG_MAX)
                panic("tga_ramdac_wr: reg %d out of range\n", btreg);
d1411 2
a1412 4
        tgaregs[TGA_REG_EPDR] = (btreg << 9) | (0 << 8 ) | val; /* XXX */
#ifdef __alpha__
        alpha_mb();
#endif
d1417 68
a1484 16
        void *v;
        u_int btreg;
        u_int8_t val;
{
        struct tga_devconfig *dc = v;
        volatile tga_reg_t *ramdac;

        if (btreg > BT485_REG_MAX)
                panic("tga_ramdac_wr: reg %d out of range\n", btreg);

        ramdac = (tga_reg_t *)(dc->dc_vaddr + TGA2_MEM_RAMDAC +
            (0xe << 12) + (btreg << 8));
        *ramdac = val & 0xff;
#ifdef __alpha__
        alpha_mb();
#endif
d1489 2
a1490 2
        void *v;
        u_int btreg;
d1492 2
a1493 3
        struct tga_devconfig *dc = v;
        volatile tga_reg_t *tgaregs = dc->dc_regs;
        tga_reg_t rdval;
d1495 2
a1496 2
        if (btreg > BT485_REG_MAX)
                panic("tga_ramdac_rd: reg %d out of range\n", btreg);
d1498 2
a1499 4
        tgaregs[TGA_REG_EPSR] = (btreg << 1) | 0x1;                /* XXX */
#ifdef __alpha__
        alpha_mb();
#endif
d1501 2
a1502 2
        rdval = tgaregs[TGA_REG_EPDR];
        return (rdval >> 16) & 0xff;                                /* XXX */
d1507 2
a1508 2
        void *v;
        u_int btreg;
d1510 12
a1521 14
        struct tga_devconfig *dc = v;
        volatile tga_reg_t *ramdac;
        u_int8_t retval;

        if (btreg > BT485_REG_MAX)
                panic("tga_ramdac_rd: reg %d out of range\n", btreg);

        ramdac = (tga_reg_t *)(dc->dc_vaddr + TGA2_MEM_RAMDAC +
            (0xe << 12) + (btreg << 8));
        retval = (u_int8_t)(*ramdac & 0xff);
#ifdef __alpha__
        alpha_mb();
#endif
        return retval;
d1526 2
a1527 2
        struct tga_devconfig *dc,
        int dotclock
d1532 2
a1533 2
        struct tga_devconfig *dc;
        int m;
d1536 1
a1536 4
        tga2_ics9110_wr(dc, decmonitors[m].dotclock);
        dc->dc_regs[TGA_REG_VHCR] =
             ((decmonitors[m].hbp / 4) << 21) |
             ((decmonitors[m].hsync / 4) << 14) |
d1538 5
a1542 2
            (((decmonitors[m].hfp - 4) / 4) << 9) |
             ((decmonitors[m].cols + 4) / 4);
d1544 5
a1548 2
            (((decmonitors[m].hfp) / 4) << 9) |
             ((decmonitors[m].cols) / 4);
d1550 11
a1560 8
        dc->dc_regs[TGA_REG_VVCR] =
            (decmonitors[m].vbp << 22) |
            (decmonitors[m].vsync << 16) |
            (decmonitors[m].vfp << 11) |
            (decmonitors[m].rows);
        dc->dc_regs[TGA_REG_VVBR] = 1;          alpha_mb();
        dc->dc_regs[TGA_REG_VVVR] |= 1;                alpha_mb();
        dc->dc_regs[TGA_REG_GPMR] = 0xffffffff;        alpha_mb();
d1565 2
a1566 2
        struct tga_devconfig *dc;
        int dotclock;
d1568 41
a1608 46
        volatile tga_reg_t *clock;
        u_int32_t valU;
        int N, M, R, V, X;
        int i;

        switch (dotclock) {
        case 130808000:
                N = 0x40; M = 0x7; V = 0x0; X = 0x1; R = 0x1; break;
        case 119840000:
                N = 0x2d; M = 0x2b; V = 0x1; X = 0x1; R = 0x1; break;
        case 108180000:
                N = 0x11; M = 0x9; V = 0x1; X = 0x1; R = 0x2; break;
        case 103994000:
                N = 0x6d; M = 0xf; V = 0x0; X = 0x1; R = 0x1; break;
        case 175000000:
                N = 0x5F; M = 0x3E; V = 0x1; X = 0x1; R = 0x1; break;
        case  75000000:
                N = 0x6e; M = 0x15; V = 0x0; X = 0x1; R = 0x1; break;
        case  74000000:
                N = 0x2a; M = 0x41; V = 0x1; X = 0x1; R = 0x1; break;
        case  69000000:
                N = 0x35; M = 0xb; V = 0x0; X = 0x1; R = 0x1; break;
        case  65000000:
                N = 0x6d; M = 0x0c; V = 0x0; X = 0x1; R = 0x2; break;
        case  50000000:
                N = 0x37; M = 0x3f; V = 0x1; X = 0x1; R = 0x2; break;
        case  40000000:
                N = 0x5f; M = 0x11; V = 0x0; X = 0x1; R = 0x2; break;
        case  31500000:
                N = 0x16; M = 0x05; V = 0x0; X = 0x1; R = 0x2; break;
        case  25175000:
                N = 0x66; M = 0x1d; V = 0x0; X = 0x1; R = 0x2; break;
        case 135000000:
                N = 0x42; M = 0x07; V = 0x0; X = 0x1; R = 0x1; break;
        case 110000000:
                N = 0x60; M = 0x32; V = 0x1; X = 0x1; R = 0x2; break;
        case 202500000:
                N = 0x60; M = 0x32; V = 0x1; X = 0x1; R = 0x2; break;
        default:
                panic("unrecognized clock rate %d\n", dotclock);
        }

        /* XXX -- hard coded, bad */
        valU  = N | ( M << 7 ) | (V << 14);
        valU |= (X << 15) | (R << 17);
        valU |= 0x17 << 19;
d1610 4
d1615 2
a1616 2
        clock = (tga_reg_t *)(dc->dc_vaddr + TGA2_MEM_EXTDEV +
            TGA2_MEM_CLOCK + (0xe << 12)); /* XXX */
d1618 2
a1619 2
        for (i=24; i>0; i--) {
                u_int32_t       writeval;
d1621 6
a1626 8
                writeval = valU & 0x1;
                if (i == 1)  
                        writeval |= 0x2; 
                valU >>= 1;
                *clock = writeval;
#ifdef __alpha__
                alpha_mb();
#endif
d1628 5
a1632 7
        clock = (tga_reg_t *)(dc->dc_vaddr + TGA2_MEM_EXTDEV +
            TGA2_MEM_CLOCK + (0xe << 12) + (0x1 << 11)); /* XXX */
        clock += 0x1 << 9;
        *clock = 0x0;
#ifdef __alpha__
                alpha_mb();
#endif
@


1.3
log
@Add $OpenBSD$ tags.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d78 1
a78 1
int tga_mmap __P((void *, off_t, int));
d523 1
a523 1
int
@


1.3.2.1
log
@MFC:
Add some missing lengths checks when passing data from userland to the
kernel. From NetBSD via millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: tga.c,v 1.9 2001/09/16 00:42:44 millert Exp $ */
d671 1
a671 2
	u_int count, v;
	int error;
d730 1
a730 2
        int error;
        u_int count;
@


1.2
log
@
add support for tga2; from NetBSD
@
text
@d1 1
@


1.1
log
@closer approximation to an alpha using new wscons.
tga moved to dev/pci.
by request from alpha people.
@
text
@d50 1
d71 2
a72 2
void	tga_getdevconfig __P((bus_space_tag_t memt, pci_chipset_tag_t pc,
	    pcitag_t tag, struct tga_devconfig *dc));
d93 12
d153 2
a154 3
	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_DEC ||
	    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_DEC_21030)
		return (0);
d156 8
a163 1
	return (10);
a173 1
	const struct tga_ramdac_conf *tgar;
d203 1
d216 22
a237 1
	tgar = tgac->tgac_ramdac;
d334 2
a335 1
		tga_getdevconfig(pa->pa_memt, pa->pa_pc, pa->pa_tag, sc->sc_dc);
d342 79
a420 59
	/* XXX say what's going on. */
	intrstr = NULL;
	if (sc->sc_dc->dc_tgaconf->tgac_ramdac->tgar_intr != NULL) {
		if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
		    pa->pa_intrline, &intrh)) {
			printf(": couldn't map interrupt");
			return;
		}
		intrstr = pci_intr_string(pa->pa_pc, intrh);
		sc->sc_intr = pci_intr_establish(pa->pa_pc, intrh, IPL_TTY,
		    sc->sc_dc->dc_tgaconf->tgac_ramdac->tgar_intr, sc->sc_dc,
		    sc->sc_dev.dv_xname);
		if (sc->sc_intr == NULL) {
			printf(": couldn't establish interrupt");
			if (intrstr != NULL)
				printf("at %s", intrstr);
			printf("\n");
			return;
		}
	}

	/*
	 * Initialize the RAMDAC and allocate any private storage it needs.
	 * Initialization includes disabling cursor, setting a sane
	 * colormap, etc.
	 */
	(*sc->sc_dc->dc_tgaconf->tgac_ramdac->tgar_init)(sc->sc_dc, 1);

	printf(": DC21030 ");
	rev = PCI_REVISION(pa->pa_class);
	switch (rev) {
	case 1: case 2: case 3:
		printf("step %c", 'A' + rev - 1);
		break;

	default:
		printf("unknown stepping (0x%x)", rev);
		break;
	}
	printf(", ");

	if (sc->sc_dc->dc_tgaconf == NULL) {
		printf("unknown board configuration\n");
		return;
	}
	printf("board type %s\n", sc->sc_dc->dc_tgaconf->tgac_name);
	printf("%s: %d x %d, %dbpp, %s RAMDAC\n", sc->sc_dev.dv_xname,
	    sc->sc_dc->dc_wid, sc->sc_dc->dc_ht,
	    sc->sc_dc->dc_tgaconf->tgac_phys_depth,
	    sc->sc_dc->dc_tgaconf->tgac_ramdac->tgar_name);

	if (intrstr != NULL)
		printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname,
		    intrstr);

	aa.console = console;
	aa.scrdata = &tga_screenlist;
	aa.accessops = &tga_accessops;
	aa.accesscookie = sc;
d422 1
a422 1
	config_found(self, &aa, wsemuldisplaydevprint);
d435 2
a436 1
	const struct tga_ramdac_conf *tgar = dc->dc_tgaconf->tgac_ramdac;
d438 11
a448 11
	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_TGA;
		return (0);

	case WSDISPLAYIO_GINFO:
#define	wsd_fbip ((struct wsdisplay_fbinfo *)data)
		wsd_fbip->height = sc->sc_dc->dc_ht;
		wsd_fbip->width = sc->sc_dc->dc_wid;
		wsd_fbip->depth = sc->sc_dc->dc_tgaconf->tgac_phys_depth;
		wsd_fbip->cmsize = 256;		/* XXX ??? */
d450 1
a450 1
		return (0);
d452 61
a512 14
	case WSDISPLAYIO_GETCMAP:
		return (*tgar->tgar_get_cmap)(dc,
		    (struct wsdisplay_cmap *)data);

	case WSDISPLAYIO_PUTCMAP:
		return (*tgar->tgar_set_cmap)(dc,
		    (struct wsdisplay_cmap *)data);

	case WSDISPLAYIO_SVIDEO:
		if (*(u_int *)data == WSDISPLAYIO_VIDEO_OFF)
			tga_blank(sc->sc_dc);
		else
			tga_unblank(sc->sc_dc);
		return (0);
d514 6
a519 26
	case WSDISPLAYIO_GVIDEO:
		*(u_int *)data = dc->dc_blanked ?
		    WSDISPLAYIO_VIDEO_OFF : WSDISPLAYIO_VIDEO_ON;
		return (0);

	case WSDISPLAYIO_GCURPOS:
		return (*tgar->tgar_get_curpos)(dc,
		    (struct wsdisplay_curpos *)data);

	case WSDISPLAYIO_SCURPOS:
		return (*tgar->tgar_set_curpos)(dc,
		    (struct wsdisplay_curpos *)data);

	case WSDISPLAYIO_GCURMAX:
		return (*tgar->tgar_get_curmax)(dc,
		    (struct wsdisplay_curpos *)data);

	case WSDISPLAYIO_GCURSOR:
		return (*tgar->tgar_get_cursor)(dc,
		    (struct wsdisplay_cursor *)data);

	case WSDISPLAYIO_SCURSOR:
		return (*tgar->tgar_set_cursor)(dc,
		    (struct wsdisplay_cursor *)data);
	}
	return (-1);
d599 3
a601 2
	tga_getdevconfig(memt, pc,
	    pci_make_tag(pc, bus, device, function), dcp);
d616 10
a625 1
	(*dcp->dc_tgaconf->tgac_ramdac->tgar_init)(dcp, 0);
d668 2
d674 1
a674 2
		error = (*dc->dc_tgaconf->tgac_ramdac->tgar_check_curcmap)(dc,
		    cursorp);
d708 1
a708 1
		(*dc->dc_tgaconf->tgac_ramdac->tgar_set_curcmap)(dc, cursorp);
d727 23
a749 21
	int count, error;

	cursorp->which = WSDISPLAY_CURSOR_DOALL &
	    ~(WSDISPLAY_CURSOR_DOHOT | WSDISPLAY_CURSOR_DOCMAP);
	cursorp->enable = (dc->dc_regs[TGA_REG_VVVR] & 0x04) != 0;
	cursorp->pos.x = dc->dc_regs[TGA_REG_CXYR] & 0xfff;
	cursorp->pos.y = (dc->dc_regs[TGA_REG_CXYR] >> 12) & 0xfff;
	cursorp->size.x = 64;
	cursorp->size.y = (dc->dc_regs[TGA_REG_CCBR] >> 10) & 0x3f;

	if (cursorp->image != NULL) {
		count = (cursorp->size.y * 64 * 2) / NBBY;
		error = copyout((char *)(dc->dc_vaddr +
		      (dc->dc_regs[TGA_REG_CCBR] & 0x3ff)),
		    cursorp->image, count);
		if (error)
			return (error);
		/* No mask */
	}
	error = (*dc->dc_tgaconf->tgac_ramdac->tgar_get_curcmap)(dc, cursorp);
	return (error);
d993 190
@

