head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.8
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.10
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.4
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.24.0.16
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.14
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.10
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.8
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.6
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.23.0.10
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.8
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.4
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.6
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12;
locks; strict;
comment	@ * @;


1.25
date	2014.09.15.12.00.04;	author dlg;	state Exp;
branches;
next	1.24;
commitid	mAlNepn7ILap73ON;

1.24
date	2011.06.09.04.55.44;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2008.11.23.12.45.11;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2008.10.28.13.44.33;	author marco;	state Exp;
branches;
next	1.21;

1.21
date	2008.10.28.11.00.40;	author marco;	state Exp;
branches;
next	1.20;

1.20
date	2008.05.27.21.52.28;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.26.12.48.28;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.25.23.45.53;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2008.01.26.08.13.09;	author dlg;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.03.05.29.35;	author mbalmer;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.03.01.51.35;	author marco;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.17.10.25.39;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2006.10.08.04.54.36;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2006.08.10.00.48.47;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2006.07.04.18.17.22;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.29.22.55.26;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.29.22.18.14;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.16.05.36.46;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.14.08.26.31;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.14.01.51.41;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.31.05.48.36;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.31.03.38.32;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.31.03.16.16;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.29.21.16.06;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.27.19.03.55;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.25
log
@mark the interrupt handler mpsafe, and drop the kernel lock in the scs_cmd
paths. take it again when going back to other parts of the kernel.

tested by and ok kettenis@@
@
text
@/*	$OpenBSD: mpi_pci.c,v 1.24 2011/06/09 04:55:44 deraadt Exp $ */

/*
 * Copyright (c) 2005 David Gwynne <dlg@@openbsd.org>
 * Copyright (c) 2005 Marco Peereboom <marco@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bio.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/sensors.h>
#include <sys/rwlock.h>

#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#ifdef __sparc64__
#include <dev/ofw/openfirm.h>
#endif

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/ic/mpireg.h>
#include <dev/ic/mpivar.h>

int	mpi_pci_match(struct device *, void *, void *);
void	mpi_pci_attach(struct device *, struct device *, void *);
int	mpi_pci_detach(struct device *, int);

struct mpi_pci_softc {
	struct mpi_softc	psc_mpi;

	pci_chipset_tag_t	psc_pc;
	pcitag_t		psc_tag;

	void			*psc_ih;
};

struct cfattach mpi_pci_ca = {
	sizeof(struct mpi_pci_softc), mpi_pci_match, mpi_pci_attach,
	mpi_pci_detach
};

#define PREAD(s, r)	pci_conf_read((s)->psc_pc, (s)->psc_tag, (r))
#define PWRITE(s, r, v)	pci_conf_write((s)->psc_pc, (s)->psc_tag, (r), (v))

static const struct pci_matchid mpi_devices[] = {
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_1030 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_FC909 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_FC909A },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_FC919 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_FC919_1 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_FC919X },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_FC929 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_FC929_1 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_FC929X },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_FC939X },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_FC949E },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_FC949X },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1064 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1064A },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1064E_2 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1064E },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1066 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1066E },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1068 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1068_2 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1068E },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1068E_2 }
};

int
mpi_pci_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid(aux, mpi_devices, nitems(mpi_devices)));
}

void
mpi_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct mpi_pci_softc		*psc = (void *)self;
	struct mpi_softc		*sc = &psc->psc_mpi;
	struct pci_attach_args		*pa = aux;
	pcireg_t			memtype;
	int				r;
	pci_intr_handle_t		ih;
	const char			*intrstr;
#ifdef __sparc64__
	int node;
#endif

	psc->psc_pc = pa->pa_pc;
	psc->psc_tag = pa->pa_tag;
	psc->psc_ih = NULL;
	sc->sc_dmat = pa->pa_dmat;
	sc->sc_ios = 0;
	sc->sc_target = -1;

	/* find the appropriate memory base */
	for (r = PCI_MAPREG_START; r < PCI_MAPREG_END; r += sizeof(memtype)) {
		memtype = pci_mapreg_type(psc->psc_pc, psc->psc_tag, r);
		if ((memtype & PCI_MAPREG_TYPE_MASK) == PCI_MAPREG_TYPE_MEM)
			break;
	}
	if (r >= PCI_MAPREG_END) {
		printf(": unable to locate system interface registers\n");
		return;
	}

	if (pci_mapreg_map(pa, r, memtype, 0, &sc->sc_iot, &sc->sc_ioh,
	    NULL, &sc->sc_ios, 0) != 0) {
		printf(": unable to map system interface registers\n");
		return;
	}

	/* disable the expansion rom */
	PWRITE(psc, PCI_ROM_REG, PREAD(psc, PCI_ROM_REG) & ~PCI_ROM_ENABLE);

	/* hook up the interrupt */
	if (pci_intr_map_msi(pa, &ih) != 0 && pci_intr_map(pa, &ih) != 0) {
		printf(": unable to map interrupt\n");
		goto unmap;
	}
	intrstr = pci_intr_string(psc->psc_pc, ih);
	psc->psc_ih = pci_intr_establish(psc->psc_pc, ih, IPL_BIO | IPL_MPSAFE,
	    mpi_intr, sc, sc->sc_dev.dv_xname);
	if (psc->psc_ih == NULL) {
		printf(": unable to map interrupt%s%s\n",
		    intrstr == NULL ? "" : " at ",
		    intrstr == NULL ? "" : intrstr);
		goto unmap;
	}
	printf(": %s", intrstr);

	if (pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_ID_REG) ==
	    PCI_ID_CODE(PCI_VENDOR_SYMBIOS, PCI_PRODUCT_SYMBIOS_1030)) {
		sc->sc_flags |= MPI_F_SPI;
#ifdef __sparc64__
		/*
		 * Walk up the Open Firmware device tree until we find a
		 * "scsi-initiator-id" property.
		 */
		node = PCITAG_NODE(pa->pa_tag);
		while (node) {
			if (OF_getprop(node, "scsi-initiator-id",
			    &sc->sc_target, sizeof(sc->sc_target)) ==
			    sizeof(sc->sc_target))
				break;
			node = OF_parent(node);
		}
#endif
	}

	if (mpi_attach(sc) != 0) {
		/* error printed by mpi_attach */
		goto deintr;
	}

	return;

deintr:
	pci_intr_disestablish(psc->psc_pc, psc->psc_ih);
	psc->psc_ih = NULL;
unmap:
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
	sc->sc_ios = 0;
}

int
mpi_pci_detach(struct device *self, int flags)
{
	struct mpi_pci_softc		*psc = (struct mpi_pci_softc *)self;
	struct mpi_softc		*sc = &psc->psc_mpi;

	mpi_detach(sc);

	if (psc->psc_ih != NULL) {
		pci_intr_disestablish(psc->psc_pc, psc->psc_ih);
		psc->psc_ih = NULL;
	}
	if (sc->sc_ios != 0) {
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
		sc->sc_ios = 0;
	}

	return (0);
}
@


1.24
log
@MSI interrupts work here, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.24 2011/06/09 04:50:00 deraadt Exp $ */
d145 1
a145 1
	psc->psc_ih = pci_intr_establish(psc->psc_pc, ih, IPL_BIO,
@


1.23
log
@sizeofa is now nitems in param.h, so dont declare my own in mpi.c it was
unused there anyway. use nitems in mpi_pci_match.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.22 2008/10/28 13:44:33 marco Exp $ */
d140 1
a140 1
	if (pci_intr_map(pa, &ih)) {
@


1.22
log
@#include sensors
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.21 2008/10/28 11:00:40 marco Exp $ */
d95 1
a95 2
	return (pci_matchbyid((struct pci_attach_args *)aux, mpi_devices,
	    sizeof(mpi_devices) / sizeof(mpi_devices[0])));
@


1.21
log
@Add beginings of bio.  Disabled for now.

dlg "go go go"
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.20 2008/05/27 21:52:28 dlg Exp $ */
d27 1
@


1.20
log
@only look up the initiator-id for SPI (aka "real scsi") controllers on
sparc64.

this prevents us from setting the initiator id on sas and fc hbas. the
scsi midlayer doesnt probe for targets at the initiator id address, so if
we set this on fc and sas hbas (which dont really have a real scsi address
on the bus), then we're preventing them from finding potential targets at
that address.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.19 2008/05/26 12:48:28 kettenis Exp $ */
d20 2
d27 1
@


1.19
log
@On sparc64, fetch "scsi-initiator-id" property from the firmware, and use
it to tweak to SPI port configuration.  Makes the PRIMEPOWER 250 happy when
netbooting.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.18 2008/05/25 23:45:53 dlg Exp $ */
a115 15
#ifdef __sparc64__
	/*
	 * Walk up the Open Firmware device tree until we find a
	 * "scsi-initiator-id" property.
	 */
	node = PCITAG_NODE(pa->pa_tag);
	while (node) {
		if (OF_getprop(node, "scsi-initiator-id",  &sc->sc_target,
		    sizeof(sc->sc_target)) == sizeof(sc->sc_target))
			break;

		node = OF_parent(node);
	}
#endif

d153 1
a153 1
	    PCI_ID_CODE(PCI_VENDOR_SYMBIOS, PCI_PRODUCT_SYMBIOS_1030))
d155 15
@


1.18
log
@tweak the SPI port configuration if we figure out that it is not quite
right, in particular the adapters scsi id on the bus.

requested by kettenis@@ who is having trouble with the scsi controller on
the primepower 250.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.17 2008/01/26 08:13:09 dlg Exp $ */
d32 4
d105 3
d115 15
@


1.17
log
@SAS1078 is a megaraid, not a fusion-mpt, so dont attach to it
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.15 2007/09/03 01:51:35 marco Exp $ */
d107 1
@


1.16
log
@unbreak.
@
text
@a79 1
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1078 },
@


1.15
log
@Add more PCI ids; taken from the linux driver.  Pointed out by Stephan
Eisvogel <eisvogel at embinet dot de>
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.14 2007/03/17 10:25:39 dlg Exp $ */
d81 1
a81 1
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1068E }
@


1.14
log
@replace the VMWARE quirk that restricts the bus width to 16 targets with
one for all SPI controllers. krw has a sun machine with a 1030 that gets
the bus width wrong too, so since vmware emulates that type of hardware
too, we can just limit the lot of them and forget about it.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.13 2006/10/08 04:54:36 brad Exp $ */
d74 1
d79 1
d82 1
@


1.13
log
@Also attach to boards with the PCI Express Fibre Channel FC949E chipset.

"go go go" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.12 2006/08/10 00:48:47 dlg Exp $ */
d142 3
a144 3
	/* vmware doesn't fill in the pci subsystem register */
	if (pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG) == 0x0)
		sc->sc_flags |= MPI_F_VMWARE;
@


1.12
log
@fix an obvious typo. found by Quentin Garnier.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.11 2006/07/04 18:17:22 marco Exp $ */
d70 1
@


1.11
log
@Add some more pci ids that I forgot to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.10 2006/06/29 22:55:26 brad Exp $ */
d123 1
a123 1
	PWRITE(psc, PCI_ROM_REG, PREAD(psc, PCI_ROM_REG & ~PCI_ROM_ENABLE));
@


1.10
log
@simplify the PCI match routine a bit.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.9 2006/06/29 22:18:14 dlg Exp $ */
d65 1
d68 3
@


1.9
log
@we dont have to beat mpt to attach to this hardware anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.8 2006/06/16 05:36:46 dlg Exp $ */
d80 1
a80 3
	struct pci_attach_args		*pa = aux;

	return (pci_matchbyid(pa, mpi_devices,
@


1.8
log
@vmware emulates mpi, but it does a half arsed job of it. half the fields
we read off the hardware and use to configure the driver with are set to
zero, so things dont really work like we want them to.

one of these fields is the pci subsystem id which is something we can fetch
really early in the attach process. so if the subsys is 0 then we go on and
fix up some of the values we get off the "hardware". now we can attach
disks on vmware.

"sneaky" and ok marco@@ tested by and ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.7 2006/06/14 08:26:31 dlg Exp $ */
d83 1
a83 1
	    sizeof(mpi_devices) / sizeof(mpi_devices[0])) * 3);
@


1.7
log
@oops, i forgot that you need to return a high number from match to win.
remove a useless define while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.6 2006/06/14 01:51:41 dlg Exp $ */
d138 4
@


1.6
log
@allow mpi to attach to parallel scsi controllers instead of mpt.

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.5 2006/05/31 05:48:36 dlg Exp $ */
a58 2
#define MPP_DUAL	0x01	/* Dual port adapter */

d83 1
a83 1
	    sizeof(mpi_devices) / sizeof(mpi_devices[0])));
@


1.5
log
@we should support all these sas controllers
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.4 2006/05/31 03:38:32 dlg Exp $ */
a83 4
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SYMBIOS &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SYMBIOS_1030)
		return (1);

d85 1
a85 1
	    sizeof(mpi_devices) / sizeof(mpi_devices[0])) * 3);
@


1.4
log
@allow mpi to attach to the scsi controllers again. however, mpt will attach
to them by default, so disable mpt to get mpi to attach.

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.3 2006/05/31 03:16:16 dlg Exp $ */
d70 7
a76 1
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1068 }
@


1.3
log
@we dont do domain validation on real scsi controllers (as opposed to sas
and fc controllers), so mpi will be slower than mpt for io on those hbas.

for now.

ifdef the scsi stuff out till we make it go fast, and so we can enable mpi
everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.2 2006/05/29 21:16:06 dlg Exp $ */
a61 1
#ifdef notyet
a62 1
#endif
d78 4
d83 1
a83 1
	    sizeof(mpi_devices) / sizeof(mpi_devices[0])) * 2);
@


1.2
log
@add the sas1064 as a supported device
@
text
@d1 1
a1 1
/*	$OpenBSD: mpi_pci.c,v 1.1 2006/05/27 19:03:55 dlg Exp $ */
d62 1
d64 1
a72 1

@


1.1
log
@add mpi(4), an alternative (replacement) driver for lsi logic fusion mpt
controllers currently supported by mpt(4).

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d69 1
@

