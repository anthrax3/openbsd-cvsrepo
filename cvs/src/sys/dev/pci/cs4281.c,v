head	1.36;
access;
symbols
	OPENBSD_6_1:1.36.0.2
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.34.0.8
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.34.0.4
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.31.0.6
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.27.0.8
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.6
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.4
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.22.0.4
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.8
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.6
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.4
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.6
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	SMP:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2;
locks; strict;
comment	@ * @;


1.36
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.35;
commitid	qGgYgJTgEFuAoGj4;

1.35
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.34;
commitid	pi1a9KN0itEngOc4;

1.34
date	2015.08.04.14.53.08;	author stsp;	state Exp;
branches;
next	1.33;
commitid	99Gn41G79hV6c6yU;

1.33
date	2015.08.03.09.20.44;	author stsp;	state Exp;
branches;
next	1.32;
commitid	N8vBIPBNGdckEOI2;

1.32
date	2015.05.11.06.46.22;	author ratchov;	state Exp;
branches;
next	1.31;
commitid	RaOGL5SyOGOZylwx;

1.31
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.30;
commitid	OBNa5kfxQ2UXoiIw;

1.30
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.28;

1.28
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.26;

1.26
date	2010.09.22.22.22.47;	author jakemsr;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.07.16.21.44;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2010.08.27.18.50.57;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.22;

1.22
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.21.00.32.43;	author jakemsr;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.22.03.16.35;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.29.05.42.17;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.21.21.52.47;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.09.04.10.10;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.07.14.11.04;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.21.04.57.40;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.21.04.52.52;	author kevlo;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.31.11.00.24;	author art;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.10.03.00.59.27;	author kevlo;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.20.17.02.31;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.27.17.02.49;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.27.15.29.54;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.12.15.40.30;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.09.21.15.22;	author aaron;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2001.01.13.19.53.50;	author aaron;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.14.22.25.38;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.07.04.10.41.59;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.2.4.6;

1.2.4.6
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.2.4.7;

1.2.4.7
date	2003.05.13.19.35.05;	author ho;	state Exp;
branches;
next	1.2.4.8;

1.2.4.8
date	2004.02.19.10.56.25;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.01.31.22.55.34;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Remove unused getdev() audio driver functions.
@
text
@/*	$OpenBSD: cs4281.c,v 1.35 2016/09/14 06:12:19 ratchov Exp $ */
/*	$Tera: cs4281.c,v 1.18 2000/12/27 14:24:45 tacha Exp $	*/

/*
 * Copyright (c) 2000 Tatoku Ogaito.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Tatoku Ogaito
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Cirrus Logic CS4281 driver.
 * Data sheets can be found
 * http://www.cirrus.com/pubs/4281.pdf?DocumentID=30
 * ftp://ftp.alsa-project.org/pub/manuals/cirrus/cs4281tm.pdf
 *
 * TODO:
 *   1: midi and FM support
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/fcntl.h>
#include <sys/device.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/cs4281reg.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>
#include <dev/midi_if.h>

#include <dev/ic/ac97.h>

#include <machine/bus.h>

#define CSCC_PCI_BA0 0x10
#define CSCC_PCI_BA1 0x14

struct cs4281_dma {
	bus_dmamap_t map;
	caddr_t addr;		/* real dma buffer */
	bus_dma_segment_t segs[1];
	int nsegs;
	size_t size;
	struct cs4281_dma *next;
};
#define DMAADDR(p) ((p)->map->dm_segs[0].ds_addr)
#define KERNADDR(p) ((void *)((p)->addr))

/*
 * Software state
 */
struct cs4281_softc {
	struct device		sc_dev;

	pci_intr_handle_t	*sc_ih;

        /* I/O (BA0) */
	bus_space_tag_t		ba0t;
	bus_space_handle_t	ba0h;

	/* BA1 */
	bus_space_tag_t		ba1t;
	bus_space_handle_t	ba1h;

	/* DMA */
	bus_dma_tag_t		sc_dmatag;
	struct cs4281_dma	*sc_dmas;

        /* playback */
	void	(*sc_pintr)(void *);	/* dma completion intr handler */
	void	*sc_parg;		/* arg for sc_intr() */
	int	(*halt_output)(void *);
#ifdef DIAGNOSTIC
        char	sc_prun;
#endif

	/* capturing */
	void	(*sc_rintr)(void *);	/* dma completion intr handler */
	void	*sc_rarg;		/* arg for sc_intr() */
	int	sc_rparam;		/* record format */
	int	(*halt_input)(void *);
#ifdef DIAGNOSTIC
        char	sc_rrun;
#endif

#if NMIDI > 0
        void	(*sc_iintr)(void *, int);	/* midi input ready handler */
        void	(*sc_ointr)(void *);		/* midi output ready handler */
        void	*sc_arg;
#endif

	/* AC97 CODEC */
	struct ac97_codec_if *codec_if;
	struct ac97_host_if host_if;

        /* Power Management */
	u_int16_t ac97_reg[CS4281_SAVE_REG_MAX + 1];   /* Save ac97 registers */
};

#define BA0READ4(sc, r) bus_space_read_4((sc)->ba0t, (sc)->ba0h, (r))
#define BA0WRITE4(sc, r, x) bus_space_write_4((sc)->ba0t, (sc)->ba0h, (r), (x))

#if defined(ENABLE_SECONDARY_CODEC)
#define MAX_CHANNELS  (4)
#define MAX_FIFO_SIZE 32 /* 128/4 channels */
#else
#define MAX_CHANNELS  (2)
#define MAX_FIFO_SIZE 64 /* 128/2 channels */
#endif

/* 
 * Hardware imposes the buffer size to be twice the block size, this
 * is OK, except that round_blocksize() is the only mean to expose
 * this hardware constraint but it doesn't know the buffer size.
 * 
 * So we've no other choice than hardcoding a buffer size
 */
#define DMA_SIZE	(1024 * 4 * 2)
#define DMA_ALIGN	0x10

int cs4281_match(struct device *, void *, void *);
void cs4281_attach(struct device *, struct device *, void *);
int cs4281_activate(struct device *, int);
int cs4281_intr(void *);
int cs4281_set_params(void *, int, int, struct audio_params *,
				     struct audio_params *);
int cs4281_halt_output(void *);
int cs4281_halt_input(void *);
int cs4281_trigger_output(void *, void *, void *, int, void (*)(void *),
			  void *, struct audio_params *);
int cs4281_trigger_input(void *, void *, void *, int, void (*)(void *),
			 void *, struct audio_params *);
u_int8_t cs4281_sr2regval(int);
void cs4281_set_dac_rate(struct cs4281_softc *, int);
void cs4281_set_adc_rate(struct cs4281_softc *, int);
int cs4281_init(struct cs4281_softc *);

int cs4281_open(void *, int);
void cs4281_close(void *);
int cs4281_round_blocksize(void *, int);
int cs4281_get_props(void *);
int cs4281_attach_codec(void *, struct ac97_codec_if *);
int cs4281_read_codec(void *, u_int8_t , u_int16_t *);
int cs4281_write_codec(void *, u_int8_t, u_int16_t);
void cs4281_reset_codec(void *);

int cs4281_mixer_set_port(void *, mixer_ctrl_t *);
int cs4281_mixer_get_port(void *, mixer_ctrl_t *);
int cs4281_query_devinfo(void *, mixer_devinfo_t *);
void *cs4281_malloc(void *, int, size_t, int, int);
size_t cs4281_round_buffersize(void *, int, size_t);
void cs4281_free(void *, void *, int);

int cs4281_allocmem(struct cs4281_softc *, size_t, int, int,
				     struct cs4281_dma *);
int cs4281_src_wait(struct cs4281_softc *);

#if defined(CS4281_DEBUG)
#undef DPRINTF
#undef DPRINTFN
#define DPRINTF(x)	    if (cs4281_debug) printf x
#define DPRINTFN(n,x)	    if (cs4281_debug>(n)) printf x
int cs4281_debug = 5;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

struct audio_hw_if cs4281_hw_if = {
	cs4281_open,
	cs4281_close,
	cs4281_set_params,
	cs4281_round_blocksize,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	cs4281_halt_output,
	cs4281_halt_input,
	NULL,
	NULL,
	cs4281_mixer_set_port,
	cs4281_mixer_get_port,
	cs4281_query_devinfo,
	cs4281_malloc,
	cs4281_free,
	cs4281_round_buffersize,
	cs4281_get_props,
	cs4281_trigger_output,
	cs4281_trigger_input
};

#if NMIDI > 0
/* Midi Interface */
void cs4281_midi_close(void *);
void cs4281_midi_getinfo(void *, struct midi_info *);
int cs4281_midi_open(void *, int, void (*)(void *, int),
		     void (*)(void *), void *);
int cs4281_midi_output(void *, int);

struct midi_hw_if cs4281_midi_hw_if = {
	cs4281_midi_open,
	cs4281_midi_close,
	cs4281_midi_output,
	cs4281_midi_getinfo,
	0,
};
#endif

struct cfattach clct_ca = {
	sizeof(struct cs4281_softc), cs4281_match, cs4281_attach, NULL,
	cs4281_activate
};

struct cfdriver clct_cd = {
	NULL, "clct", DV_DULL
};

int
cs4281_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	
	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_CIRRUS ||
	    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_CIRRUS_CS4281)
		return (0);

	return (1);
}

void
cs4281_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct cs4281_softc *sc = (struct cs4281_softc *)self;
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	char const *intrstr;
	pci_intr_handle_t ih;

	/* Map I/O register */
	if (pci_mapreg_map(pa, CSCC_PCI_BA0,
	    PCI_MAPREG_TYPE_MEM|PCI_MAPREG_MEM_TYPE_32BIT, 0, &sc->ba0t,
	    &sc->ba0h, NULL, NULL, 0)) {
		printf("%s: can't map BA0 space\n", sc->sc_dev.dv_xname);
		return;
	}
	if (pci_mapreg_map(pa, CSCC_PCI_BA1,
	    PCI_MAPREG_TYPE_MEM|PCI_MAPREG_MEM_TYPE_32BIT, 0, &sc->ba1t,
	    &sc->ba1h, NULL, NULL, 0)) {
		printf("%s: can't map BA1 space\n", sc->sc_dev.dv_xname);
		return;
	}

	sc->sc_dmatag = pa->pa_dmat;

	/*
	 * Set Power State D0.
	 * Without doing this, 0xffffffff is read from all registers after
	 * using Windows and rebooting into OpenBSD.
	 * On my IBM ThinkPad X20, it is set to D3 after using Windows2000.
	 */
	pci_set_powerstate(pc, pa->pa_tag, PCI_PMCSR_STATE_D0);

	/* Map and establish the interrupt. */
	if (pci_intr_map(pa, &ih)) {
		printf("%s: couldn't map interrupt\n", sc->sc_dev.dv_xname);
		return;
	}
	intrstr = pci_intr_string(pc, ih);

	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO | IPL_MPSAFE,
	    cs4281_intr, sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf("%s: couldn't establish interrupt",sc->sc_dev.dv_xname);
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s\n", intrstr);

	/*
	 * Sound System start-up
	 */
	if (cs4281_init(sc) != 0)
		return;

	sc->halt_input  = cs4281_halt_input;
	sc->halt_output = cs4281_halt_output;

	/* AC 97 attachment */
	sc->host_if.arg = sc;
	sc->host_if.attach = cs4281_attach_codec;
	sc->host_if.read   = cs4281_read_codec;
	sc->host_if.write  = cs4281_write_codec;
	sc->host_if.reset  = cs4281_reset_codec;
	if (ac97_attach(&sc->host_if) != 0) {
		printf("%s: ac97_attach failed\n", sc->sc_dev.dv_xname);
		return;
	}
	audio_attach_mi(&cs4281_hw_if, sc, &sc->sc_dev);

#if NMIDI > 0
	midi_attach_mi(&cs4281_midi_hw_if, sc, &sc->sc_dev);
#endif
}


int
cs4281_intr(p)
	void *p;
{
	struct cs4281_softc *sc = p;
	u_int32_t intr, val;
	
	mtx_enter(&audio_lock);
	intr = BA0READ4(sc, CS4281_HISR);
	if (!(intr & (HISR_DMA0 | HISR_DMA1 | HISR_MIDI))) {
		BA0WRITE4(sc, CS4281_HICR, HICR_IEV | HICR_CHGM);
		mtx_leave(&audio_lock);
		return (-1);
	}
	DPRINTF(("cs4281_intr:"));

	if (intr & HISR_DMA0)
		val = BA0READ4(sc, CS4281_HDSR0); /* clear intr condition */
	if (intr & HISR_DMA1)
		val = BA0READ4(sc, CS4281_HDSR1); /* clear intr condition */
	BA0WRITE4(sc, CS4281_HICR, HICR_IEV | HICR_CHGM);

	/* Playback Interrupt */
	if (intr & HISR_DMA0) {
		DPRINTF((" PB DMA 0x%x(%d)", (int)BA0READ4(sc, CS4281_DCA0),
			 (int)BA0READ4(sc, CS4281_DCC0)));
		if (sc->sc_pintr) {
			sc->sc_pintr(sc->sc_parg);
		} else {
#ifdef DIAGNOSTIC
			printf("%s: unexpected play intr\n",
			    sc->sc_dev.dv_xname);
#endif
		}
	}
	if (intr & HISR_DMA1) {
		val = BA0READ4(sc, CS4281_HDSR1);
		/* copy from dma */
		DPRINTF((" CP DMA 0x%x(%d)", (int)BA0READ4(sc, CS4281_DCA1),
			 (int)BA0READ4(sc, CS4281_DCC1)));
		if (sc->sc_rintr) {
			sc->sc_rintr(sc->sc_rarg);
		} else {
#ifdef DIAGNOSTIC
			printf("%s: unexpected record intr\n",
			    sc->sc_dev.dv_xname);
#endif
		}
	}
	DPRINTF(("\n"));
	mtx_leave(&audio_lock);
	return (1);
}

int
cs4281_set_params(addr, setmode, usemode, play, rec)
	void *addr;
	int setmode, usemode;
	struct audio_params *play, *rec;
{
	struct cs4281_softc *sc = addr;
	struct audio_params *p;
	int mode;

	for (mode = AUMODE_RECORD; mode != -1;
	    mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
		if ((setmode & mode) == 0)
			continue;
		
		p = mode == AUMODE_PLAY ? play : rec;
		
		if (p == play) {
			DPRINTFN(5,("play: samp=%ld precision=%d channels=%d\n",
				p->sample_rate, p->precision, p->channels));
		} else {
			DPRINTFN(5,("rec: samp=%ld precision=%d channels=%d\n",
				p->sample_rate, p->precision, p->channels));
		}
		if (p->sample_rate < 6023)
			p->sample_rate = 6023;
		if (p->sample_rate > 48000)
			p->sample_rate = 48000;
		if (p->precision > 16)
			p->precision = 16;
		if (p->channels > 2)
			p->channels = 2;

		switch (p->encoding) {
		case AUDIO_ENCODING_SLINEAR_BE:
			break;
		case AUDIO_ENCODING_SLINEAR_LE:
			break;
		case AUDIO_ENCODING_ULINEAR_BE:
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			break;
		default:
			return (EINVAL);
		}
		p->bps = AUDIO_BPS(p->precision);
		p->msb = 1;
	}

	/* set sample rate */
	cs4281_set_dac_rate(sc, play->sample_rate);
	cs4281_set_adc_rate(sc, rec->sample_rate);
	return (0);
}

int
cs4281_halt_output(addr)
	void *addr;
{
	struct cs4281_softc *sc = addr;
	
	BA0WRITE4(sc, CS4281_DCR0, BA0READ4(sc, CS4281_DCR0) | DCRn_MSK);
#ifdef DIAGNOSTIC
	sc->sc_prun = 0;
#endif
	return (0);
}

int
cs4281_halt_input(addr)
	void *addr;
{
	struct cs4281_softc *sc = addr;

	BA0WRITE4(sc, CS4281_DCR1, BA0READ4(sc, CS4281_DCR1) | DCRn_MSK);
#ifdef DIAGNOSTIC
	sc->sc_rrun = 0;
#endif
	return (0);
}

int
cs4281_trigger_output(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
{
	struct cs4281_softc *sc = addr;
	u_int32_t fmt = 0;
	struct cs4281_dma *p;
	int dma_count;

#ifdef DIAGNOSTIC
	if (sc->sc_prun)
		printf("cs4281_trigger_output: already running\n");
	sc->sc_prun = 1;
#endif

	if ((char *)end - (char *)start != 2 * blksize) {
#ifdef DIAGNOSTIC
		printf("%s: play block size must be half the buffer size\n",
		    sc->sc_dev.dv_xname);
#endif
		return EIO;
	}

	DPRINTF(("cs4281_trigger_output: sc=%p start=%p end=%p "
		 "blksize=%d intr=%p(%p)\n", addr, start, end, blksize, intr, arg));
	sc->sc_pintr = intr;
	sc->sc_parg  = arg;

	/* stop playback DMA */
	BA0WRITE4(sc, CS4281_DCR0, BA0READ4(sc, CS4281_DCR0) | DCRn_MSK);

	DPRINTF(("param: precision=%d channels=%d encoding=%d\n",
	       param->precision, param->channels,
	       param->encoding));
	for (p = sc->sc_dmas; p != NULL && KERNADDR(p) != start; p = p->next)
		;
	if (p == NULL) {
		printf("cs4281_trigger_output: bad addr %p\n", start);
		mtx_leave(&audio_lock);
		return (EINVAL);
	}

	dma_count = (char *)end - (char *)start;
	if (param->precision != 8)
		dma_count /= 2;   /* 16 bit */
	if (param->channels > 1)
		dma_count /= 2;   /* Stereo */

	DPRINTF(("cs4281_trigger_output: DMAADDR(p)=0x%x count=%d\n",
		 (int)DMAADDR(p), dma_count));
	BA0WRITE4(sc, CS4281_DBA0, DMAADDR(p));
	BA0WRITE4(sc, CS4281_DBC0, dma_count - 1);

	/* set playback format */
	fmt = BA0READ4(sc, CS4281_DMR0) & ~DMRn_FMTMSK;
	if (param->precision == 8)
		fmt |= DMRn_SIZE8;
	if (param->channels == 1)
		fmt |= DMRn_MONO;
	if (param->encoding == AUDIO_ENCODING_ULINEAR_BE ||
	    param->encoding == AUDIO_ENCODING_SLINEAR_BE)
		fmt |= DMRn_BEND;
	if (param->encoding == AUDIO_ENCODING_ULINEAR_BE ||
	    param->encoding == AUDIO_ENCODING_ULINEAR_LE)
		fmt |= DMRn_USIGN;
	BA0WRITE4(sc, CS4281_DMR0, fmt);

	/* set sample rate */
	cs4281_set_dac_rate(sc, param->sample_rate);

	/* start DMA */
	mtx_enter(&audio_lock);
	BA0WRITE4(sc, CS4281_DCR0, BA0READ4(sc, CS4281_DCR0) & ~DCRn_MSK);
	/* Enable interrupts */
	BA0WRITE4(sc, CS4281_HICR, HICR_IEV | HICR_CHGM);

	BA0WRITE4(sc, CS4281_PPRVC, 7);
	BA0WRITE4(sc, CS4281_PPLVC, 7);

	DPRINTF(("HICR =0x%08x(expected 0x00000001)\n", BA0READ4(sc, CS4281_HICR)));
	DPRINTF(("HIMR =0x%08x(expected 0x00f0fc3f)\n", BA0READ4(sc, CS4281_HIMR)));
	DPRINTF(("DMR0 =0x%08x(expected 0x2???0018)\n", BA0READ4(sc, CS4281_DMR0)));
	DPRINTF(("DCR0 =0x%08x(expected 0x00030000)\n", BA0READ4(sc, CS4281_DCR0)));
	DPRINTF(("FCR0 =0x%08x(expected 0x81000f00)\n", BA0READ4(sc, CS4281_FCR0)));
	DPRINTF(("DACSR=0x%08x(expected 1 for 44kHz 5 for 8kHz)\n",
		 BA0READ4(sc, CS4281_DACSR)));
	DPRINTF(("SRCSA=0x%08x(expected 0x0b0a0100)\n", BA0READ4(sc, CS4281_SRCSA)));
	DPRINTF(("SSPM&SSPM_PSRCEN =0x%08x(expected 0x00000010)\n",
		 BA0READ4(sc, CS4281_SSPM) & SSPM_PSRCEN));
	mtx_leave(&audio_lock);
	return (0);
}

int
cs4281_trigger_input(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
{
	struct cs4281_softc *sc = addr;
	struct cs4281_dma *p;
	u_int32_t fmt = 0;
	int dma_count;

	if ((char *)end - (char *)start != 2 * blksize) {
#ifdef DIAGNOSTIC
		printf("%s: rec block size must be half the buffer size\n",
		    sc->sc_dev.dv_xname);
#endif
		return EIO;
	}

#ifdef DIAGNOSTIC
	if (sc->sc_rrun)
		printf("cs4281_trigger_input: already running\n");
	sc->sc_rrun = 1;
#endif
	DPRINTF(("cs4281_trigger_input: sc=%p start=%p end=%p "
	    "blksize=%d intr=%p(%p)\n", addr, start, end, blksize, intr, arg));
	sc->sc_rintr = intr;
	sc->sc_rarg  = arg;

	/* stop recording DMA */
	BA0WRITE4(sc, CS4281_DCR1, BA0READ4(sc, CS4281_DCR1) | DCRn_MSK);

	for (p = sc->sc_dmas; p && KERNADDR(p) != start; p = p->next)
		;
	if (!p) {
		printf("cs4281_trigger_input: bad addr %p\n", start);
		return (EINVAL);
	}

	dma_count = (char *)end - (char *)start;
	if (param->precision != 8)
		dma_count /= 2;
	if (param->channels > 1)
		dma_count /= 2;

	DPRINTF(("cs4281_trigger_input: DMAADDR(p)=0x%x count=%d\n",
		 (int)DMAADDR(p), dma_count));
	BA0WRITE4(sc, CS4281_DBA1, DMAADDR(p));
	BA0WRITE4(sc, CS4281_DBC1, dma_count-1);

	/* set recording format */
	fmt = BA0READ4(sc, CS4281_DMR1) & ~DMRn_FMTMSK;
	if (param->precision == 8)
		fmt |= DMRn_SIZE8;
	if (param->channels == 1)
		fmt |= DMRn_MONO;
	if (param->encoding == AUDIO_ENCODING_ULINEAR_BE ||
	    param->encoding == AUDIO_ENCODING_SLINEAR_BE)
		fmt |= DMRn_BEND;
	if (param->encoding == AUDIO_ENCODING_ULINEAR_BE ||
	    param->encoding == AUDIO_ENCODING_ULINEAR_LE)
		fmt |= DMRn_USIGN;
	BA0WRITE4(sc, CS4281_DMR1, fmt);

	/* set sample rate */
	cs4281_set_adc_rate(sc, param->sample_rate);

	/* Start DMA */
	mtx_enter(&audio_lock);
	BA0WRITE4(sc, CS4281_DCR1, BA0READ4(sc, CS4281_DCR1) & ~DCRn_MSK);
	/* Enable interrupts */
	BA0WRITE4(sc, CS4281_HICR, HICR_IEV | HICR_CHGM);

	DPRINTF(("HICR=0x%08x\n", BA0READ4(sc, CS4281_HICR)));
	DPRINTF(("HIMR=0x%08x\n", BA0READ4(sc, CS4281_HIMR)));
	DPRINTF(("DMR1=0x%08x\n", BA0READ4(sc, CS4281_DMR1)));
	DPRINTF(("DCR1=0x%08x\n", BA0READ4(sc, CS4281_DCR1)));
	mtx_leave(&audio_lock);
	return (0);
}

/* convert sample rate to register value */
u_int8_t
cs4281_sr2regval(rate)
     int rate;
{
	u_int8_t retval;

	/* We don't have to change here. but anyway ... */
	if (rate > 48000)
		rate = 48000;
	if (rate < 6023)
		rate = 6023;

	switch (rate) {
	case 8000:
		retval = 5;
		break;
	case 11025:
		retval = 4;
		break;
	case 16000:
		retval = 3;
		break;
	case 22050:
		retval = 2;
		break;
	case 44100:
		retval = 1;
		break;
	case 48000:
		retval = 0;
		break;
	default:
		retval = 1536000/rate; /* == 24576000/(rate*16) */
	}
	return (retval);
}

	
void
cs4281_set_dac_rate(sc, rate)
	struct cs4281_softc *sc;
	int rate;
{
	BA0WRITE4(sc, CS4281_DACSR, cs4281_sr2regval(rate));
}

void
cs4281_set_adc_rate(sc, rate)
	struct cs4281_softc *sc;
	int rate;
{
	BA0WRITE4(sc, CS4281_ADCSR, cs4281_sr2regval(rate));
}

int
cs4281_init(sc)
     struct cs4281_softc *sc;
{
	int n;
	u_int16_t data;
	u_int32_t dat32;

	/* set "Configuration Write Protect" register to
	 * 0x4281 to allow to write */
	BA0WRITE4(sc, CS4281_CWPR, 0x4281);

	/*
	 * Unset "Full Power-Down bit of Extended PCI Power Management
	 * Control" register to release the reset state.
	 */
	dat32 = BA0READ4(sc, CS4281_EPPMC);
	if (dat32 & EPPMC_FPDN)
		BA0WRITE4(sc, CS4281_EPPMC, dat32 & ~EPPMC_FPDN);

	/* Start PLL out in known state */
	BA0WRITE4(sc, CS4281_CLKCR1, 0);
	/* Start serial ports out in known state */
	BA0WRITE4(sc, CS4281_SERMC, 0);
	
	/* Reset codec */
	BA0WRITE4(sc, CS4281_ACCTL, 0);
	delay(50);	/* delay 50us */

	BA0WRITE4(sc, CS4281_SPMC, 0);
	delay(100);	/* delay 100us */
	BA0WRITE4(sc, CS4281_SPMC, SPMC_RSTN);
#if defined(ENABLE_SECONDARY_CODEC)
	BA0WRITE4(sc, CS4281_SPMC, SPMC_RSTN | SPCM_ASDIN2E);
	BA0WRITE4(sc, CS4281_SERMC, SERMC_TCID);
#endif
	delay(50000);   /* XXX: delay 50ms */

	/* Turn on Sound System clocks based on ABITCLK */
	BA0WRITE4(sc, CS4281_CLKCR1, CLKCR1_DLLP);
	delay(50000);   /* XXX: delay 50ms */
	BA0WRITE4(sc, CS4281_CLKCR1, CLKCR1_SWCE | CLKCR1_DLLP);

	/* Set enables for sections that are needed in the SSPM registers */
	BA0WRITE4(sc, CS4281_SSPM,
		  SSPM_MIXEN |		/* Mixer */
		  SSPM_CSRCEN |		/* Capture SRC */
		  SSPM_PSRCEN |		/* Playback SRC */
		  SSPM_JSEN |		/* Joystick */
		  SSPM_ACLEN |		/* AC LINK */
		  SSPM_FMEN		/* FM */
		  );

	/* Wait for clock stabilization */
	n = 0;
	while ((BA0READ4(sc, CS4281_CLKCR1)& (CLKCR1_DLLRDY | CLKCR1_CLKON))
	    != (CLKCR1_DLLRDY | CLKCR1_CLKON)) {
		delay(100);
		if (++n > 1000)
			return (-1);
	}

	/* Enable ASYNC generation */
	BA0WRITE4(sc, CS4281_ACCTL, ACCTL_ESYN);

	/* Wait for Codec ready. Linux driver wait 50ms here */
	n = 0;
	while((BA0READ4(sc, CS4281_ACSTS) & ACSTS_CRDY) == 0) {
		delay(100);
		if (++n > 1000)
			return (-1);
	}

#if defined(ENABLE_SECONDARY_CODEC)
	/* secondary codec ready*/
	n = 0;
	while((BA0READ4(sc, CS4281_ACSTS2) & ACSTS2_CRDY2) == 0) {
		delay(100);
		if (++n > 1000)
			return (-1);
	}
#endif

	/* Set the serial timing configuration */
	/* XXX: undocumented but the Linux driver do this */
	BA0WRITE4(sc, CS4281_SERMC, SERMC_PTCAC97);
	
	/* Wait for Codec ready signal */
	n = 0;
	do {
		delay(1000);
		if (++n > 1000) {
			printf("%s: Timeout waiting for Codec ready\n",
			       sc->sc_dev.dv_xname);
			return -1;
		}
		dat32 = BA0READ4(sc, CS4281_ACSTS) & ACSTS_CRDY;
	} while (dat32 == 0);

	/* Enable Valid Frame output on ASDOUT */
	BA0WRITE4(sc, CS4281_ACCTL, ACCTL_ESYN | ACCTL_VFRM);
	
	/* Wait until Codec Calibration is finished. Codec register 26h */
	n = 0;
	do {
		delay(1);
		if (++n > 1000) {
			printf("%s: Timeout waiting for Codec calibration\n",
			       sc->sc_dev.dv_xname);
			return -1;
		}
		cs4281_read_codec(sc, AC97_REG_POWER, &data);
	} while ((data & 0x0f) != 0x0f);

	/* Set the serial timing configuration again */
	/* XXX: undocumented but the Linux driver do this */
	BA0WRITE4(sc, CS4281_SERMC, SERMC_PTCAC97);

	/* Wait until we've sampled input slots 3 & 4 as valid */
	n = 0;
	do {
		delay(1000);
		if (++n > 1000) {
			printf("%s: Timeout waiting for sampled input slots as valid\n",
			       sc->sc_dev.dv_xname);
			return -1;
		}
		dat32 = BA0READ4(sc, CS4281_ACISV) & (ACISV_ISV3 | ACISV_ISV4);
	} while (dat32 != (ACISV_ISV3 | ACISV_ISV4));
	
	/* Start digital data transfer of audio data to the codec */
	BA0WRITE4(sc, CS4281_ACOSV, (ACOSV_SLV3 | ACOSV_SLV4));
	
	cs4281_write_codec(sc, AC97_REG_HEADPHONE_VOLUME, 0);
	cs4281_write_codec(sc, AC97_REG_MASTER_VOLUME, 0);
	
	/* Power on the DAC */
	cs4281_read_codec(sc, AC97_REG_POWER, &data);
	cs4281_write_codec(sc, AC97_REG_POWER, data &= 0xfdff);

	/* Wait until we sample a DAC ready state.
	 * Not documented, but Linux driver does.
	 */
	for (n = 0; n < 32; ++n) {
		delay(1000);
		cs4281_read_codec(sc, AC97_REG_POWER, &data);
		if (data & 0x02)
			break;
	}
	
	/* Power on the ADC */
	cs4281_read_codec(sc, AC97_REG_POWER, &data);
	cs4281_write_codec(sc, AC97_REG_POWER, data &= 0xfeff);

	/* Wait until we sample ADC ready state.
	 * Not documented, but Linux driver does.
	 */
	for (n = 0; n < 32; ++n) {
		delay(1000);
		cs4281_read_codec(sc, AC97_REG_POWER, &data);
		if (data & 0x01)
			break;
	}
	
#if 0
	/* Initialize SSCR register features */
	/* XXX: hardware volume setting */
	BA0WRITE4(sc, CS4281_SSCR, ~SSCR_HVC); /* disable HW volume setting */
#endif

	/* disable Sound Blaster Pro emulation */
	/* XXX:
	 * Cannot set since the documents does not describe which bit is
	 * correspond to SSCR_SB. Since the reset value of SSCR is 0,
	 * we can ignore it.*/
#if 0
	BA0WRITE4(sc, CS4281_SSCR, SSCR_SB);
#endif

	/* map AC97 PCM playback to DMA Channel 0 */
	/* Reset FEN bit to setup first */
	BA0WRITE4(sc, CS4281_FCR0, (BA0READ4(sc,CS4281_FCR0) & ~FCRn_FEN));
	/*
	 *| RS[4:0]/|        |
	 *| LS[4:0] |  AC97  | Slot Function
	 *|---------+--------+--------------------
	 *|     0   |    3   | Left PCM Playback
	 *|     1   |    4   | Right PCM Playback
	 *|     2   |    5   | Phone Line 1 DAC
	 *|     3   |    6   | Center PCM Playback
	 *....
	 *  quoted from Table 29(p109)
	 */
	dat32 = 0x01 << 24 |   /* RS[4:0] =  1 see above */
		0x00 << 16 |   /* LS[4:0] =  0 see above */
		0x0f <<  8 |   /* SZ[6:0] = 15 size of buffer */
		0x00 <<  0 ;   /* OF[6:0] =  0 offset */
	BA0WRITE4(sc, CS4281_FCR0, dat32);
	BA0WRITE4(sc, CS4281_FCR0, dat32 | FCRn_FEN);

	/* map AC97 PCM record to DMA Channel 1 */
	/* Reset FEN bit to setup first */
	BA0WRITE4(sc, CS4281_FCR1, (BA0READ4(sc,CS4281_FCR1) & ~FCRn_FEN));
	/*
	 *| RS[4:0]/|
	 *| LS[4:0] | AC97 | Slot Function
	 *|---------+------+-------------------
	 *|   10    |   3  | Left PCM Record
	 *|   11    |   4  | Right PCM Record
	 *|   12    |   5  | Phone Line 1 ADC
	 *|   13    |   6  | Mic ADC
	 *....
	 * quoted from Table 30(p109)
	 */
	dat32 = 0x0b << 24 |    /* RS[4:0] = 11 See above */
		0x0a << 16 |    /* LS[4:0] = 10 See above */
		0x0f <<  8 |    /* SZ[6:0] = 15 Size of buffer */
		0x10 <<  0 ;    /* OF[6:0] = 16 offset */

	/* XXX: I cannot understand why FCRn_PSH is needed here. */
	BA0WRITE4(sc, CS4281_FCR1, dat32 | FCRn_PSH);
	BA0WRITE4(sc, CS4281_FCR1, dat32 | FCRn_FEN);

#if 0
	/* Disable DMA Channel 2, 3 */
	BA0WRITE4(sc, CS4281_FCR2, (BA0READ4(sc,CS4281_FCR2) & ~FCRn_FEN));
	BA0WRITE4(sc, CS4281_FCR3, (BA0READ4(sc,CS4281_FCR3) & ~FCRn_FEN));
#endif

	/* Set the SRC Slot Assignment accordingly */
	/*| PLSS[4:0]/
	 *| PRSS[4:0] | AC97 | Slot Function
	 *|-----------+------+----------------
	 *|     0     |  3   | Left PCM Playback
	 *|     1     |  4   | Right PCM Playback
	 *|     2     |  5   | phone line 1 DAC
	 *|     3     |  6   | Center PCM Playback
	 *|     4     |  7   | Left Surround PCM Playback
	 *|     5     |  8   | Right Surround PCM Playback
	 *......
	 *
	 *| CLSS[4:0]/
	 *| CRSS[4:0] | AC97 | Codec |Slot Function
	 *|-----------+------+-------+-----------------
	 *|    10     |   3  |Primary| Left PCM Record
	 *|    11     |   4  |Primary| Right PCM Record
	 *|    12     |   5  |Primary| Phone Line 1 ADC
	 *|    13     |   6  |Primary| Mic ADC
	 *|.....
	 *|    20     |   3  |  Sec. | Left PCM Record
	 *|    21     |   4  |  Sec. | Right PCM Record
	 *|    22     |   5  |  Sec. | Phone Line 1 ADC
	 *|    23     |   6  |  Sec. | Mic ADC
	 */
	dat32 = 0x0b << 24 |   /* CRSS[4:0] Right PCM Record(primary) */
		0x0a << 16 |   /* CLSS[4:0] Left  PCM Record(primary) */
		0x01 <<  8 |   /* PRSS[4:0] Right PCM Playback */
		0x00 <<  0;    /* PLSS[4:0] Left  PCM Playback */
	BA0WRITE4(sc, CS4281_SRCSA, dat32);
	
	/* Set interrupt to occurred at Half and Full terminal
	 * count interrupt enable for DMA channel 0 and 1.
	 * To keep DMA stop, set MSK.
	 */
	dat32 = DCRn_HTCIE | DCRn_TCIE | DCRn_MSK;
	BA0WRITE4(sc, CS4281_DCR0, dat32);
	BA0WRITE4(sc, CS4281_DCR1, dat32);
	
	/* Set Auto-Initialize Control enable */
	BA0WRITE4(sc, CS4281_DMR0,
		  DMRn_DMA | DMRn_AUTO | DMRn_TR_READ);
	BA0WRITE4(sc, CS4281_DMR1,
		  DMRn_DMA | DMRn_AUTO | DMRn_TR_WRITE);

	/* Clear DMA Mask in HIMR */
	dat32 = BA0READ4(sc, CS4281_HIMR) & 0xfffbfcff;
	BA0WRITE4(sc, CS4281_HIMR, dat32);
	return (0);
}

int
cs4281_activate(struct device *self, int act)
{
	struct cs4281_softc *sc = (struct cs4281_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		/* should I powerdown here ? */
		cs4281_write_codec(sc, AC97_REG_POWER, CS4281_POWER_DOWN_ALL);
		break;
	case DVACT_RESUME:
		cs4281_init(sc);
		ac97_resume(&sc->host_if, sc->codec_if);
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

void
cs4281_reset_codec(void *addr)
{
	struct cs4281_softc *sc;
	u_int16_t data;
	u_int32_t dat32;
	int n;

	sc = addr;

	DPRINTFN(3,("cs4281_reset_codec\n"));

	/* Reset codec */
	BA0WRITE4(sc, CS4281_ACCTL, 0);
	delay(50);    /* delay 50us */

	BA0WRITE4(sc, CS4281_SPMC, 0);
	delay(100);	/* delay 100us */
	BA0WRITE4(sc, CS4281_SPMC, SPMC_RSTN);
#if defined(ENABLE_SECONDARY_CODEC)
	BA0WRITE4(sc, CS4281_SPMC, SPMC_RSTN | SPCM_ASDIN2E);
	BA0WRITE4(sc, CS4281_SERMC, SERMC_TCID);
#endif
	delay(50000);   /* XXX: delay 50ms */

	/* Enable ASYNC generation */
	BA0WRITE4(sc, CS4281_ACCTL, ACCTL_ESYN);

	/* Wait for Codec ready. Linux driver wait 50ms here */
	n = 0;
	while((BA0READ4(sc, CS4281_ACSTS) & ACSTS_CRDY) == 0) {
		delay(100);
		if (++n > 1000) {
			printf("%s: AC97 codec ready timeout\n",
			    sc->sc_dev.dv_xname);
			return;
		}
	}
#if defined(ENABLE_SECONDARY_CODEC)
	/* secondary codec ready*/
	n = 0;
	while((BA0READ4(sc, CS4281_ACSTS2) & ACSTS2_CRDY2) == 0) {
		delay(100);
		if (++n > 1000)
			return;
	}
#endif
	/* Set the serial timing configuration */
	/* XXX: undocumented but the Linux driver do this */
	BA0WRITE4(sc, CS4281_SERMC, SERMC_PTCAC97);
	
	/* Wait for Codec ready signal */
	n = 0;
	do {
		delay(1000);
		if (++n > 1000) {
			printf("%s: Timeout waiting for Codec ready\n",
			       sc->sc_dev.dv_xname);
			return;
		}
		dat32 = BA0READ4(sc, CS4281_ACSTS) & ACSTS_CRDY;
	} while (dat32 == 0);

	/* Enable Valid Frame output on ASDOUT */
	BA0WRITE4(sc, CS4281_ACCTL, ACCTL_ESYN | ACCTL_VFRM);
	
	/* Wait until Codec Calibration is finished. Codec register 26h */
	n = 0;
	do {
		delay(1);
		if (++n > 1000) {
			printf("%s: Timeout waiting for Codec calibration\n",
			       sc->sc_dev.dv_xname);
			return ;
		}
		cs4281_read_codec(sc, AC97_REG_POWER, &data);
	} while ((data & 0x0f) != 0x0f);

	/* Set the serial timing configuration again */
	/* XXX: undocumented but the Linux driver do this */
	BA0WRITE4(sc, CS4281_SERMC, SERMC_PTCAC97);

	/* Wait until we've sampled input slots 3 & 4 as valid */
	n = 0;
	do {
		delay(1000);
		if (++n > 1000) {
			printf("%s: Timeout waiting for sampled input slots as valid\n",
			       sc->sc_dev.dv_xname);
			return;
		}
		dat32 = BA0READ4(sc, CS4281_ACISV) & (ACISV_ISV3 | ACISV_ISV4) ;
	} while (dat32 != (ACISV_ISV3 | ACISV_ISV4));
	
	/* Start digital data transfer of audio data to the codec */
	BA0WRITE4(sc, CS4281_ACOSV, (ACOSV_SLV3 | ACOSV_SLV4));
}

int
cs4281_open(void *addr, int flags)
{
	return (0);
}

void
cs4281_close(void *addr)
{
	struct cs4281_softc *sc;

	sc = addr;

	(*sc->halt_output)(sc);
	(*sc->halt_input)(sc);
	
	sc->sc_pintr = 0;
	sc->sc_rintr = 0;
}

int
cs4281_round_blocksize(void *addr, int blk)
{
	return DMA_SIZE / 2;
}

int
cs4281_mixer_set_port(void *addr, mixer_ctrl_t *cp)
{
	struct cs4281_softc *sc;
	int val;

	sc = addr;
	val = sc->codec_if->vtbl->mixer_set_port(sc->codec_if, cp);
	DPRINTFN(3,("mixer_set_port: val=%d\n", val));
	return (val);
}

int
cs4281_mixer_get_port(void *addr, mixer_ctrl_t *cp)
{
	struct cs4281_softc *sc;

	sc = addr;
	return (sc->codec_if->vtbl->mixer_get_port(sc->codec_if, cp));
}


int
cs4281_query_devinfo(void *addr, mixer_devinfo_t *dip)
{
	struct cs4281_softc *sc;

	sc = addr;
	return (sc->codec_if->vtbl->query_devinfo(sc->codec_if, dip));
}

void *
cs4281_malloc(void *addr, int direction, size_t size, int pool, int flags)
{
	struct cs4281_softc *sc;
	struct cs4281_dma   *p;
	int error;

	sc = addr;

	p = malloc(sizeof(*p), pool, flags);
	if (!p)
		return (0);

	error = cs4281_allocmem(sc, size, pool, flags, p);

	if (error) {
		free(p, pool, 0);
		return (0);
	}

	p->next = sc->sc_dmas;
	sc->sc_dmas = p;
	return (KERNADDR(p));
}



void
cs4281_free(void *addr, void *ptr, int pool)
{
	struct cs4281_softc *sc;
	struct cs4281_dma **pp, *p;

	sc = addr;
	for (pp = &sc->sc_dmas; (p = *pp) != NULL; pp = &p->next) {
		if (KERNADDR(p) == ptr) {
			bus_dmamap_unload(sc->sc_dmatag, p->map);
			bus_dmamap_destroy(sc->sc_dmatag, p->map);
			bus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);
			bus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);
			*pp = p->next;
			free(p, pool, 0);
			return;
		}
	}
}

size_t
cs4281_round_buffersize(void *addr, int direction, size_t size)
{
	return (DMA_SIZE);
}

int
cs4281_get_props(void *addr)
{
	int retval;

	retval = AUDIO_PROP_INDEPENDENT | AUDIO_PROP_FULLDUPLEX;
#ifdef MMAP_READY
	retval |= AUDIO_PROP_MMAP;
#endif
	return (retval);
}

/* AC97 */
int
cs4281_attach_codec(void *addr, struct ac97_codec_if *codec_if)
{
	struct cs4281_softc *sc;

	DPRINTF(("cs4281_attach_codec:\n"));
	sc = addr;
	sc->codec_if = codec_if;
	return (0);
}


int
cs4281_read_codec(void *addr, u_int8_t ac97_addr, u_int16_t *ac97_data)
{
	struct cs4281_softc *sc;
	u_int32_t acctl;
	int n;

	sc = addr;

	DPRINTFN(5,("read_codec: add=0x%02x ", ac97_addr));
	/*
	 * Make sure that there is not data sitting around from a preivous
	 * uncompleted access.
	 */
	BA0READ4(sc, CS4281_ACSDA);

	/* Set up AC97 control registers. */
	BA0WRITE4(sc, CS4281_ACCAD, ac97_addr);
	BA0WRITE4(sc, CS4281_ACCDA, 0);

	acctl = ACCTL_ESYN | ACCTL_VFRM | ACCTL_CRW  | ACCTL_DCV;
	BA0WRITE4(sc, CS4281_ACCTL, acctl);

	if (cs4281_src_wait(sc) < 0) {
		printf("%s: AC97 read prob. (DCV!=0) for add=0x%0x\n",
		       sc->sc_dev.dv_xname, ac97_addr);
		return 1;
	}

	/* wait for valid status bit is active */
	n = 0;
	while ((BA0READ4(sc, CS4281_ACSTS) & ACSTS_VSTS) == 0) {
		delay(1);
		while (++n > 1000) {
			printf("%s: AC97 read fail (VSTS==0) for add=0x%0x\n",
			       sc->sc_dev.dv_xname, ac97_addr);
			return 1;
		}
	}
	*ac97_data = BA0READ4(sc, CS4281_ACSDA);
	DPRINTFN(5,("data=0x%04x\n", *ac97_data));
	return (0);
}

int
cs4281_write_codec(void *addr, u_int8_t ac97_addr, u_int16_t ac97_data)
{
	struct cs4281_softc *sc;
	u_int32_t acctl;

	sc = addr;

	DPRINTFN(5,("write_codec: add=0x%02x  data=0x%04x\n", ac97_addr, ac97_data));
	BA0WRITE4(sc, CS4281_ACCAD, ac97_addr);
	BA0WRITE4(sc, CS4281_ACCDA, ac97_data);

	acctl = ACCTL_ESYN | ACCTL_VFRM | ACCTL_DCV;
	BA0WRITE4(sc, CS4281_ACCTL, acctl);

	if (cs4281_src_wait(sc) < 0) {
		printf("%s: AC97 write fail (DCV!=0) for add=0x%02x data="
		       "0x%04x\n", sc->sc_dev.dv_xname, ac97_addr, ac97_data);
		return (1);
	}
	return (0);
}

int
cs4281_allocmem(struct cs4281_softc *sc, size_t size, int pool, int flags,
		struct cs4281_dma *p)
{
	int error;
	
	if (size != DMA_SIZE) {
		printf("%s: dma size is %zd should be %d\n",
		    sc->sc_dev.dv_xname, size, DMA_SIZE);
		return ENOMEM;

	}
	p->size = size;	

	/* allocate memory for upper audio driver */
	error = bus_dmamem_alloc(sc->sc_dmatag, p->size, DMA_ALIGN, 0,
				 p->segs, nitems(p->segs),
				 &p->nsegs, BUS_DMA_NOWAIT);
	if (error) {
		printf("%s: unable to allocate dma. error=%d\n",
		       sc->sc_dev.dv_xname, error);
		return (error);
	}

	error = bus_dmamem_map(sc->sc_dmatag, p->segs, p->nsegs, p->size,
			       &p->addr, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);
	if (error) {
		printf("%s: unable to map dma, error=%d\n",
		       sc->sc_dev.dv_xname, error);
		goto free;
	}

	error = bus_dmamap_create(sc->sc_dmatag, p->size, 1, p->size,
				  0, BUS_DMA_NOWAIT, &p->map);
	if (error) {
		printf("%s: unable to create dma map, error=%d\n",
		       sc->sc_dev.dv_xname, error);
		goto unmap;
	}

	error = bus_dmamap_load(sc->sc_dmatag, p->map, p->addr, p->size, NULL,
				BUS_DMA_NOWAIT);
	if (error) {
		printf("%s: unable to load dma map, error=%d\n",
		       sc->sc_dev.dv_xname, error);
		goto destroy;
	}
	return (0);

destroy:
	bus_dmamap_destroy(sc->sc_dmatag, p->map);
unmap:
	bus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);
free:
	bus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);
	return (error);
}


int
cs4281_src_wait(sc)
	struct cs4281_softc *sc;
{
	int n;

	n = 0;
	while ((BA0READ4(sc, CS4281_ACCTL) & ACCTL_DCV)) {
		delay(1000);
		if (++n > 1000)
			return (-1);
	}
	return (0);
}
@


1.35
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.33 2015/08/03 09:20:44 stsp Exp $ */
a156 1
int cs4281_getdev(void *, struct audio_device *);
a209 1
	cs4281_getdev,
a247 7
struct audio_device cs4281_device = {
	"CS4281",
	"",
	"cs4281"
};


a477 11

/* trivial */
int
cs4281_getdev(addr, retp)
     void *addr;
     struct audio_device *retp;
{
	*retp = cs4281_device;
	return (0);
}

@


1.34
log
@Fix clct(4) audio driver which was stuttering to the point of being useless.
Tested on Thinkpad X21 by me. All the hard work was done by ratchov@@.
I just made some cosmetic fixes while here.
ok ratchov@@ deraadt@@
@
text
@a152 1
int cs4281_query_encoding(void *, struct audio_encoding *);
a181 1
paddr_t cs4281_mappage(void *, void *, off_t, int);
a200 2
	NULL,
	cs4281_query_encoding,
a218 1
	NULL, /* cs4281_mappage, */
d221 1
a221 2
	cs4281_trigger_input,
	NULL
a407 51
cs4281_query_encoding(addr, fp)
	void *addr;
	struct audio_encoding *fp;
{
	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 1:
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 2:
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	case 3:
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	case 4:
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	case 5:
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	default:
		return EINVAL;
	}
	fp->bps = AUDIO_BPS(fp->precision);
	fp->msb = 1;

	return (0);
}

int
a1245 23

paddr_t
cs4281_mappage(void *addr, void *mem, off_t off, int prot)
{
	struct cs4281_softc *sc;
	struct cs4281_dma *p;
	
	sc = addr;
	if (off < 0)
		return -1;

	for (p = sc->sc_dmas; p && KERNADDR(p) != mem; p = p->next)
		;

	if (!p) {
		DPRINTF(("cs4281_mappage: bad buffer address\n"));
		return (-1);
	}

	return (bus_dmamem_mmap(sc->sc_dmatag, p->segs, p->nsegs, off, prot,
	    BUS_DMA_WAITOK));
}

@


1.33
log
@Remove a debug printf that should have been removed years ago. ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.32 2015/05/11 06:46:22 ratchov Exp $ */
a68 1
	caddr_t dum;		/* dummy buffer for audio driver */
a74 1
#define BUFADDR(p)  ((void *)((p)->dum))
a95 4
	size_t dma_size;
	size_t dma_align;

	int	hw_blocksize;
a99 5
	char	*sc_ps, *sc_pe, *sc_pn;
	int	sc_pcount;
	int	sc_pi;
	struct cs4281_dma *sc_pdma;
	char	*sc_pbuf;
a107 5
	char	*sc_rs, *sc_re, *sc_rn;
	int	sc_rcount;
	int	sc_ri;
	struct	cs4281_dma *sc_rdma;
	char	*sc_rbuf;
d139 10
d330 1
a330 1
	printf(" %s\n", intrstr);
a340 4
	sc->dma_size     = CS4281_BUFFER_SIZE / MAX_CHANNELS;
	sc->dma_align    = 0x10;
	sc->hw_blocksize = sc->dma_size / 2;
	
a364 1
	char *empty_dma;
d371 1
a371 1
		return (0);
d386 1
a386 2
			if ((sc->sc_pi%sc->sc_pcount) == 0)
				sc->sc_pintr(sc->sc_parg);
d388 4
a391 1
			printf("unexpected play intr\n");
a392 9
		/* copy buffer */
		++sc->sc_pi;
		empty_dma = sc->sc_pdma->addr;
		if (sc->sc_pi&1)
			empty_dma += sc->hw_blocksize;
		memcpy(empty_dma, sc->sc_pn, sc->hw_blocksize);
		sc->sc_pn += sc->hw_blocksize;
		if (sc->sc_pn >= sc->sc_pe)
			sc->sc_pn = sc->sc_ps;
a398 7
		++sc->sc_ri;
		empty_dma = sc->sc_rdma->addr;
		if ((sc->sc_ri & 1) == 0)
			empty_dma += sc->hw_blocksize;
		memcpy(sc->sc_rn, empty_dma, sc->hw_blocksize);
		if (sc->sc_rn >= sc->sc_re)
			sc->sc_rn = sc->sc_rs;
d400 1
a400 2
			if ((sc->sc_ri % sc->sc_rcount) == 0)
				sc->sc_rintr(sc->sc_rarg);
d402 4
a405 1
			printf("unexpected record intr\n");
d566 1
a566 1
	u_int32_t fmt=0;
d576 8
d595 1
a595 1
	for (p = sc->sc_dmas; p != NULL && BUFADDR(p) != start; p = p->next)
d603 1
a603 17
	sc->sc_pcount = blksize / sc->hw_blocksize;
	sc->sc_ps = (char *)start;
	sc->sc_pe = (char *)end;
	sc->sc_pdma = p;
	sc->sc_pbuf = KERNADDR(p);
	sc->sc_pi = 0;
	sc->sc_pn = sc->sc_ps;
	if (blksize >= sc->dma_size) {
		sc->sc_pn = sc->sc_ps + sc->dma_size;
		memcpy(sc->sc_pbuf, start, sc->dma_size);
		++sc->sc_pi;
	} else {
		sc->sc_pn = sc->sc_ps + sc->hw_blocksize;
		memcpy(sc->sc_pbuf, start, sc->hw_blocksize);
	}

	dma_count = sc->dma_size;
d612 1
a612 1
	BA0WRITE4(sc, CS4281_DBC0, dma_count-1);
d665 1
a665 1
	u_int32_t fmt=0;
d668 8
d689 1
a689 1
	for (p = sc->sc_dmas; p && BUFADDR(p) != start; p = p->next)
d696 2
a697 10
	sc->sc_rcount = blksize / sc->hw_blocksize;
	sc->sc_rs = (char *)start;
	sc->sc_re = (char *)end;
	sc->sc_rdma = p;
	sc->sc_rbuf = KERNADDR(p);
	sc->sc_ri = 0;
	sc->sc_rn = sc->sc_rs;

	dma_count = sc->dma_size;
	if (param->precision == 8)
d1129 2
a1130 1
			printf("reset_codec: AC97 codec ready timeout\n");
d1217 1
a1217 14
	struct cs4281_softc *sc;
	int retval;
	
	DPRINTFN(5,("cs4281_round_blocksize blk=%d -> ", blk));
	
	sc=addr;
	if (blk < sc->hw_blocksize)
		retval = sc->hw_blocksize;
	else
		retval = blk & -(sc->hw_blocksize);

	DPRINTFN(5,("%d\n", retval));

	return (retval);
d1273 1
a1273 1
	return (BUFADDR(p));
d1286 1
a1286 1
		if (BUFADDR(p) == ptr) {
a1290 1
			free(p->dum, pool, 0);
d1301 1
a1301 7
	/* The real dma buffersize are 4KB for CS4280
	 * and 64kB/MAX_CHANNELS for CS4281.
	 * But they are too small for high quality audio,
	 * let the upper layer(audio) use a larger buffer.
	 * (originally suggested by Lennart Augustsson.)
	 */
	return (size);
d1314 1
a1314 1
	for (p = sc->sc_dmas; p && BUFADDR(p) != mem; p = p->next)
a1423 1
	size_t align;
d1425 8
a1432 2
	align   = sc->dma_align;
	p->size = sc->dma_size;
d1434 1
a1434 4
	p->dum  = malloc(size, pool, flags);
	if (!p->dum)
		return (1);
	error = bus_dmamem_alloc(sc->sc_dmatag, p->size, align, 0,
@


1.32
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.31 2014/07/12 18:48:51 tedu Exp $ */
a698 1
	printf("cs4281_trigger_input: not implemented yet\n");
@


1.31
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.30 2013/12/06 21:03:03 deraadt Exp $ */
a57 2
#include <dev/mulaw.h>
#include <dev/auconv.h>
a448 12
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 2:
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 3:
d454 1
a454 1
	case 4:
d460 1
a460 1
	case 5:
d466 1
a466 1
	case 6:
d472 1
a472 1
	case 7:
a518 2
		p->factor = 1;
		p->sw_code = 0;
a528 14
		case AUDIO_ENCODING_ULAW:
			if (mode == AUMODE_PLAY) {
				p->sw_code = mulaw_to_slinear8;
			} else {
				p->sw_code = slinear8_to_mulaw;
			}
			break;
		case AUDIO_ENCODING_ALAW:
			if (mode == AUMODE_PLAY) {
				p->sw_code = alaw_to_slinear8;
			} else {
				p->sw_code = slinear8_to_alaw;
			}
			break;
d607 2
a608 2
	DPRINTF(("param: precision=%d  factor=%d channels=%d encoding=%d\n",
	       param->precision, param->factor, param->channels,
d635 1
a635 1
	if (param->precision * param->factor != 8)
d647 1
a647 1
	if (param->precision * param->factor == 8)
d729 1
a729 1
	if (param->precision * param->factor == 8)
d741 1
a741 1
	if (param->precision * param->factor == 8)
@


1.30
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.29 2013/05/24 07:58:46 ratchov Exp $ */
d1341 1
a1341 1
		free(p, pool);
d1365 1
a1365 1
			free(p->dum, pool);
d1367 1
a1367 1
			free(p, pool);
@


1.29
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.28 2013/05/15 08:29:24 ratchov Exp $ */
a1141 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
d1149 3
@


1.28
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.27 2011/04/03 15:36:02 jasper Exp $ */
d329 2
a330 2
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO, cs4281_intr, sc,
	    sc->sc_dev.dv_xname);
@


1.27
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.26 2010/09/22 22:22:47 jakemsr Exp $ */
d379 1
d383 1
d434 1
d644 1
d693 1
d711 1
a711 1

d787 1
d796 1
a796 1

@


1.26
log
@use audio(4)'s quiesce/resume for data i/o, and ac97_resume() for mixer
suspend/resume support
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.25 2010/09/07 16:21:44 deraadt Exp $ */
d1508 1
a1508 1
				 p->segs, sizeof(p->segs)/sizeof(p->segs[0]),
@


1.25
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.24 2010/08/27 18:50:57 deraadt Exp $ */
d1133 1
a1133 1
	int i;
d1136 3
a1139 8
		cs4281_halt_output(sc);
		cs4281_halt_input(sc);
		/* Save AC97 registers */
		for (i = 1; i <= CS4281_SAVE_REG_MAX; i++) {
			if (i == 0x04)	/* AC97_REG_MASTER_TONE */
				continue;
			cs4281_read_codec(sc, 2*i, &sc->ac97_reg[i>>1]);
		}
d1145 2
a1146 8
		cs4281_reset_codec(sc);

		/* restore ac97 registers */
		for (i = 1; i <= CS4281_SAVE_REG_MAX; i++) {
			if (i == 0x04)	/* AC97_REG_MASTER_TONE */
				continue;
			cs4281_write_codec(sc, 2*i, sc->ac97_reg[i>>1]);
		}
d1149 1
a1149 1
	return 0;
@


1.24
log
@Since the changes in neo(4) work, it is very likely that the exact same
mechnical changes work in these drivers too.  Testing can occur after
this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.23 2010/07/15 03:43:11 jakemsr Exp $ */
a142 1
        void	*sc_powerhook;		/* Power hook */
a184 2
void cs4281_powerhook(int, void *);

a367 2

	sc->sc_powerhook = powerhook_establish(cs4281_powerhook, sc);
a1160 6
}

void
cs4281_powerhook(int why, void *v)
{
	cs4281_activate(v, why);
@


1.23
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.22 2008/10/25 22:30:43 jakemsr Exp $ */
a142 1
        char	sc_suspend;
d160 1
d186 1
a186 1
void cs4281_power(int, void *);
d259 2
a260 1
	sizeof(struct cs4281_softc), cs4281_match, cs4281_attach
d372 1
a372 2
	sc->sc_suspend = PWR_RESUME;
	sc->sc_powerhook = powerhook_establish(cs4281_power, sc);
d1134 2
a1135 4
void
cs4281_power(why, v)
	int why;
	void *v;
d1137 1
a1137 1
	struct cs4281_softc *sc = (struct cs4281_softc *)v;
d1140 2
a1141 4
	DPRINTF(("%s: cs4281_power why=%d\n", sc->sc_dev.dv_xname, why));
	if (why != PWR_RESUME) {
		sc->sc_suspend = why;

d1152 2
a1153 7
	} else {
		if (sc->sc_suspend == PWR_RESUME) {
			printf("cs4281_power: odd, resume without suspend.\n");
			sc->sc_suspend = why;
			return;
		}
		sc->sc_suspend = why;
d1163 1
d1165 7
@


1.22
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.21 2008/04/21 00:32:43 jakemsr Exp $ */
d497 3
d564 2
@


1.21
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.20 2007/10/22 03:16:35 fgsch Exp $ */
a519 5
			if (p->sample_rate < 6023 || p->sample_rate > 48000 ||
			    (p->precision != 8 && p->precision != 16) ||
			    (p->channels != 1  && p->channels != 2)) {
				return (EINVAL);
			}
a522 5
			if (p->sample_rate < 6023 || p->sample_rate > 48000 ||
			    (p->precision != 8 && p->precision != 16) ||
			    (p->channels != 1 && p->channels != 2)) {
				return (EINVAL);
			}
d524 8
@


1.20
log
@Use pci_set_powerstate(), shrinking the code and unifying the different
versions. ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.19 2005/11/29 05:42:17 tedu Exp $ */
d238 1
@


1.19
log
@from the diffs so old they're growing mold dept:
while () return; is pretty dumb, change to ifs as intended
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.18 2005/11/21 21:52:47 miod Exp $ */
a297 1
	int pci_pwrmgmt_cap_reg, pci_pwrmgmt_csr_reg;
d321 1
a321 12
	if (pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_PWRMGMT,
	    &pci_pwrmgmt_cap_reg, 0)) {
		pcireg_t reg;

		pci_pwrmgmt_csr_reg = pci_pwrmgmt_cap_reg + PCI_PMCSR;
		reg = pci_conf_read(pa->pa_pc, pa->pa_tag, pci_pwrmgmt_csr_reg);
		if ((reg & PCI_PMCSR_STATE_MASK) != PCI_PMCSR_STATE_D0) {
			pci_conf_write(pc, pa->pa_tag, pci_pwrmgmt_csr_reg,
			    (reg & ~PCI_PMCSR_STATE_MASK) |
			    PCI_PMCSR_STATE_D0);
		}
	}
@


1.18
log
@contorl -> control
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.17 2005/08/09 04:10:10 mickey Exp $ */
d1591 1
a1591 1
		while (++n > 1000)
@


1.17
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.16 2003/10/07 14:11:04 fgsch Exp $ */
d1130 1
a1130 1
	/* Set Auto-Initialize Contorl enable */
@


1.16
log
@use PCI_PMCSR instead of some magic value.
ok krw@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.14 2003/08/21 04:52:52 kevlo Exp $ */
a297 1
	pcireg_t csr;
a333 5

	/* Enable the device (set bus master flag) */
	csr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    csr | PCI_COMMAND_MASTER_ENABLE);
@


1.15
log
@sys/types.h is not really needed w/ sys/param.h
@
text
@d327 1
a327 1
		pci_pwrmgmt_csr_reg = pci_pwrmgmt_cap_reg + 4;
@


1.14
log
@remove extra header file <sys/systm.h>. ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.13 2003/04/27 11:22:53 ho Exp $ */
a43 1
#include <sys/types.h>
@


1.13
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.12 2002/03/14 03:16:06 millert Exp $ */
d44 1
a50 2
#include <sys/types.h>
#include <sys/systm.h>
@


1.12
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.11 2002/03/14 01:26:58 millert Exp $ */
d466 1
a466 1
		strcpy(fp->name, AudioEulinear);
d472 1
a472 1
		strcpy(fp->name, AudioEmulaw);
d478 1
a478 1
		strcpy(fp->name, AudioEalaw);
d484 1
a484 1
		strcpy(fp->name, AudioEslinear);
d490 1
a490 1
		strcpy(fp->name, AudioEslinear_le);
d496 1
a496 1
		strcpy(fp->name, AudioEulinear_le);
d502 1
a502 1
		strcpy(fp->name, AudioEslinear_be);
d508 1
a508 1
		strcpy(fp->name, AudioEulinear_be);
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.10 2002/01/20 19:56:53 ericj Exp $ */
d170 4
a173 7
int cs4281_trigger_output	__P((void *, void *, void *, int,
				     void (*)(void *), void *,
				     struct audio_params *));
int cs4281_trigger_input	__P((void *, void *, void *, int,
				     void (*)(void *), void *,
				     struct audio_params *));

d246 2
a247 2
int cs4281_midi_open		__P((void *, int, void (*)(void *, int),
				     void (*)(void *), void *));
@


1.10
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.9 2001/10/31 11:00:24 art Exp $ */
d115 1
a115 1
	int	(*halt_output)__P((void *));
d129 1
a129 1
	int	(*halt_input)__P((void *));
d161 9
a169 9
int cs4281_match		__P((struct device *, void *, void *));
void cs4281_attach		__P((struct device *, struct device *, void *));
int cs4281_intr			__P((void *));
int cs4281_query_encoding	__P((void *, struct audio_encoding *));
int cs4281_set_params		__P((void *, int, int, struct audio_params *,
				     struct audio_params *));
int cs4281_halt_output		__P((void *));
int cs4281_halt_input		__P((void *));
int cs4281_getdev		__P((void *, struct audio_device *));
d177 27
a203 27
u_int8_t cs4281_sr2regval	__P((int));
void cs4281_set_dac_rate	__P((struct cs4281_softc *, int));
void cs4281_set_adc_rate	__P((struct cs4281_softc *, int));
int cs4281_init			__P((struct cs4281_softc *));

int cs4281_open			__P((void *, int));
void cs4281_close		__P((void *));
int cs4281_round_blocksize	__P((void *, int));
int cs4281_get_props		__P((void *));
int cs4281_attach_codec		__P((void *, struct ac97_codec_if *));
int cs4281_read_codec		__P((void *, u_int8_t , u_int16_t *));
int cs4281_write_codec		__P((void *, u_int8_t, u_int16_t));
void cs4281_reset_codec		__P((void *));

void cs4281_power		__P((int, void *));

int cs4281_mixer_set_port	__P((void *, mixer_ctrl_t *));
int cs4281_mixer_get_port	__P((void *, mixer_ctrl_t *));
int cs4281_query_devinfo	__P((void *, mixer_devinfo_t *));
void *cs4281_malloc		__P((void *, int, size_t, int, int));
size_t cs4281_round_buffersize	__P((void *, int, size_t));
void cs4281_free		__P((void *, void *, int));
paddr_t cs4281_mappage		__P((void *, void *, off_t, int));

int cs4281_allocmem		__P((struct cs4281_softc *, size_t, int, int,
				     struct cs4281_dma *));
int cs4281_src_wait		__P((struct cs4281_softc *));
d247 2
a248 2
void cs4281_midi_close		__P((void *));
void cs4281_midi_getinfo	__P((void *, struct midi_info *));
d251 1
a251 1
int cs4281_midi_output		__P((void *, int));
d635 1
a635 1
	void (*intr) __P((void *));
d739 1
a739 1
	void (*intr) __P((void *));
@


1.9
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.8 2001/10/03 00:59:27 kevlo Exp $ */
d196 2
a197 2
void *cs4281_malloc		__P((void *, u_long, int, int));
u_long cs4281_round_buffersize	__P((void *, u_long));
d1362 1
a1362 1
cs4281_malloc(void *addr, u_long size, int pool, int flags)
d1409 2
a1410 2
u_long
cs4281_round_buffersize(void *addr, u_long size)
@


1.9.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.10 2002/01/20 19:56:53 ericj Exp $ */
d196 2
a197 2
void *cs4281_malloc		__P((void *, int, size_t, int, int));
size_t cs4281_round_buffersize	__P((void *, int, size_t));
d1362 1
a1362 1
cs4281_malloc(void *addr, int direction, size_t size, int pool, int flags)
d1409 2
a1410 2
size_t
cs4281_round_buffersize(void *addr, int direction, size_t size)
@


1.9.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.9.2.1 2002/01/31 22:55:34 niklas Exp $ */
d115 1
a115 1
	int	(*halt_output)(void *);
d129 1
a129 1
	int	(*halt_input)(void *);
d161 43
a203 40
int cs4281_match(struct device *, void *, void *);
void cs4281_attach(struct device *, struct device *, void *);
int cs4281_intr(void *);
int cs4281_query_encoding(void *, struct audio_encoding *);
int cs4281_set_params(void *, int, int, struct audio_params *,
				     struct audio_params *);
int cs4281_halt_output(void *);
int cs4281_halt_input(void *);
int cs4281_getdev(void *, struct audio_device *);
int cs4281_trigger_output(void *, void *, void *, int, void (*)(void *),
			  void *, struct audio_params *);
int cs4281_trigger_input(void *, void *, void *, int, void (*)(void *),
			 void *, struct audio_params *);
u_int8_t cs4281_sr2regval(int);
void cs4281_set_dac_rate(struct cs4281_softc *, int);
void cs4281_set_adc_rate(struct cs4281_softc *, int);
int cs4281_init(struct cs4281_softc *);

int cs4281_open(void *, int);
void cs4281_close(void *);
int cs4281_round_blocksize(void *, int);
int cs4281_get_props(void *);
int cs4281_attach_codec(void *, struct ac97_codec_if *);
int cs4281_read_codec(void *, u_int8_t , u_int16_t *);
int cs4281_write_codec(void *, u_int8_t, u_int16_t);
void cs4281_reset_codec(void *);

void cs4281_power(int, void *);

int cs4281_mixer_set_port(void *, mixer_ctrl_t *);
int cs4281_mixer_get_port(void *, mixer_ctrl_t *);
int cs4281_query_devinfo(void *, mixer_devinfo_t *);
void *cs4281_malloc(void *, int, size_t, int, int);
size_t cs4281_round_buffersize(void *, int, size_t);
void cs4281_free(void *, void *, int);
paddr_t cs4281_mappage(void *, void *, off_t, int);

int cs4281_allocmem(struct cs4281_softc *, size_t, int, int,
				     struct cs4281_dma *);
int cs4281_src_wait(struct cs4281_softc *);
d247 5
a251 5
void cs4281_midi_close(void *);
void cs4281_midi_getinfo(void *, struct midi_info *);
int cs4281_midi_open(void *, int, void (*)(void *, int),
		     void (*)(void *), void *);
int cs4281_midi_output(void *, int);
d635 1
a635 1
	void (*intr)(void *);
d739 1
a739 1
	void (*intr)(void *);
@


1.9.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d466 1
a466 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d472 1
a472 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d478 1
a478 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d484 1
a484 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d490 1
a490 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d496 1
a496 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d502 1
a502 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d508 1
a508 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
@


1.8
log
@fix data sheet link. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.7 2001/09/20 17:02:31 mpech Exp $ */
d199 1
a199 1
int cs4281_mappage		__P((void *, void *, int, int));
d1421 2
a1422 2
int
cs4281_mappage(void *addr, void *mem, int off, int prot)
@


1.7
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.6 2001/08/25 10:13:29 art Exp $ */
d37 1
a37 1
 * http://www.cirrus.com/ftp/pub/4281.pdf
@


1.6
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.5 2001/07/27 17:02:49 art Exp $ */
d1133 1
a1133 1
	/* Set interrupt to occured at Half and Full terminal
@


1.5
log
@Back out. This is more complicated than I thought.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.3 2001/06/12 15:40:30 niklas Exp $ */
d347 1
a347 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin, pa->pa_intrline,
	    &ih)) {
@


1.4
log
@Allow mmap. Not really working correctly yet, but almost.
@
text
@d239 1
a239 1
	cs4281_mappage,
d1451 1
d1453 1
@


1.3
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.2 2001/02/09 21:15:22 aaron Exp $ */
d239 1
a239 1
	NULL, /* cs4281_mappage, */
a1450 1
#ifdef MMAP_READY
a1451 1
#endif
@


1.2
log
@Tickle D0 power state so the cs4281 works after reboots from Windows 2000.
From NetBSD, tested on a dual-boot IBM ThinkPad X20.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.1 2001/01/13 19:53:50 aaron Exp $ */
d309 1
a309 1
	    &sc->ba0h, NULL, NULL)) {
d315 1
a315 1
	    &sc->ba1h, NULL, NULL)) {
@


1.2.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.2 2001/02/09 21:15:22 aaron Exp $ */
@


1.2.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.2.4.1 2001/05/14 22:25:38 niklas Exp $ */
d309 1
a309 1
	    &sc->ba0h, NULL, NULL, 0)) {
d315 1
a315 1
	    &sc->ba1h, NULL, NULL, 0)) {
@


1.2.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.2.4.2 2001/07/04 10:41:59 niklas Exp $ */
d37 1
a37 1
 * http://www.cirrus.com/pubs/4281.pdf?DocumentID=30
d347 2
a348 1
	if (pci_intr_map(pa, &ih)) {
d1134 1
a1134 1
	/* Set interrupt to occurred at Half and Full terminal
@


1.2.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d199 1
a199 1
paddr_t cs4281_mappage		__P((void *, void *, off_t, int));
d1421 2
a1422 2
paddr_t
cs4281_mappage(void *addr, void *mem, off_t off, int prot)
@


1.2.4.5
log
@Merge in trunk
@
text
@d196 2
a197 2
void *cs4281_malloc		__P((void *, int, size_t, int, int));
size_t cs4281_round_buffersize	__P((void *, int, size_t));
d1362 1
a1362 1
cs4281_malloc(void *addr, int direction, size_t size, int pool, int flags)
d1409 2
a1410 2
size_t
cs4281_round_buffersize(void *addr, int direction, size_t size)
@


1.2.4.6
log
@Merge in -current from roughly a week ago
@
text
@d115 1
a115 1
	int	(*halt_output)(void *);
d129 1
a129 1
	int	(*halt_input)(void *);
d161 43
a203 40
int cs4281_match(struct device *, void *, void *);
void cs4281_attach(struct device *, struct device *, void *);
int cs4281_intr(void *);
int cs4281_query_encoding(void *, struct audio_encoding *);
int cs4281_set_params(void *, int, int, struct audio_params *,
				     struct audio_params *);
int cs4281_halt_output(void *);
int cs4281_halt_input(void *);
int cs4281_getdev(void *, struct audio_device *);
int cs4281_trigger_output(void *, void *, void *, int, void (*)(void *),
			  void *, struct audio_params *);
int cs4281_trigger_input(void *, void *, void *, int, void (*)(void *),
			 void *, struct audio_params *);
u_int8_t cs4281_sr2regval(int);
void cs4281_set_dac_rate(struct cs4281_softc *, int);
void cs4281_set_adc_rate(struct cs4281_softc *, int);
int cs4281_init(struct cs4281_softc *);

int cs4281_open(void *, int);
void cs4281_close(void *);
int cs4281_round_blocksize(void *, int);
int cs4281_get_props(void *);
int cs4281_attach_codec(void *, struct ac97_codec_if *);
int cs4281_read_codec(void *, u_int8_t , u_int16_t *);
int cs4281_write_codec(void *, u_int8_t, u_int16_t);
void cs4281_reset_codec(void *);

void cs4281_power(int, void *);

int cs4281_mixer_set_port(void *, mixer_ctrl_t *);
int cs4281_mixer_get_port(void *, mixer_ctrl_t *);
int cs4281_query_devinfo(void *, mixer_devinfo_t *);
void *cs4281_malloc(void *, int, size_t, int, int);
size_t cs4281_round_buffersize(void *, int, size_t);
void cs4281_free(void *, void *, int);
paddr_t cs4281_mappage(void *, void *, off_t, int);

int cs4281_allocmem(struct cs4281_softc *, size_t, int, int,
				     struct cs4281_dma *);
int cs4281_src_wait(struct cs4281_softc *);
d247 5
a251 5
void cs4281_midi_close(void *);
void cs4281_midi_getinfo(void *, struct midi_info *);
int cs4281_midi_open(void *, int, void (*)(void *, int),
		     void (*)(void *), void *);
int cs4281_midi_output(void *, int);
d635 1
a635 1
	void (*intr)(void *);
d739 1
a739 1
	void (*intr)(void *);
@


1.2.4.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4281.c,v 1.2.4.6 2002/03/28 15:35:57 niklas Exp $ */
d466 1
a466 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d472 1
a472 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d478 1
a478 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d484 1
a484 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d490 1
a490 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d496 1
a496 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d502 1
a502 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d508 1
a508 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
@


1.2.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d50 2
d329 1
a329 1
		pci_pwrmgmt_csr_reg = pci_pwrmgmt_cap_reg + PCI_PMCSR;
@


1.1
log
@Driver for Cirrus Logic CS4281 sound chips. Originally written for NetBSD by
Tatoku Ogaito, banged into shape for OpenBSD by me. Recording has not been
tested yet, but mpg123 works fine. Sound still works after suspend/resume.

XXX: On the IBM ThinkPad X20, must disable pcibios else the cs4281 won't
generate interrupts. Cause yet unknown but probably not the driver's fault.
YMMV on other laptops with this chip.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d304 1
d322 19
d885 8
@

