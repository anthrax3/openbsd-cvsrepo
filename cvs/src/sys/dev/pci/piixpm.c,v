head	1.39;
access;
symbols
	OPENBSD_6_2:1.39.0.18
	OPENBSD_6_2_BASE:1.39
	OPENBSD_6_1:1.39.0.16
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.14
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.39.0.10
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.39.0.8
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.39.0.6
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.38.0.4
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.2
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.37.0.2
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.4
	OPENBSD_5_0:1.36.0.2
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.34.0.4
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.30.0.2
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.28.0.2
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.2.0.4
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.2
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.39
date	2013.10.01.20.06.02;	author sf;	state Exp;
branches;
next	1.38;

1.38
date	2012.10.05.10.51.28;	author haesbaert;	state Exp;
branches;
next	1.37;

1.37
date	2012.03.07.21.41.53;	author brynet;	state Exp;
branches;
next	1.36;

1.36
date	2011.05.28.14.56.32;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2011.04.09.04.33.40;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2009.11.05.09.37.05;	author sthen;	state Exp;
branches;
next	1.32;

1.32
date	2009.06.24.13.49.48;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.30;

1.30
date	2008.09.17.06.14.09;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2008.05.24.06.23.40;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.13.16.56.09;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.03.09.36.26;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.29.05.51.51;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2006.12.11.18.16.37;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2006.09.28.18.19.14;	author grange;	state Exp;
branches;
next	1.23;

1.23
date	2006.07.07.03.23.42;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2006.06.26.15.52.59;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.26.13.56.29;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2006.02.27.08.25.02;	author grange;	state Exp;
branches;
next	1.19;

1.19
date	2006.02.11.05.26.32;	author grange;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.18.02.57.27;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.15.10.28.17;	author grange;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.15.10.04.39;	author grange;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.12.00.21.59;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.05.10.43.15;	author grange;	state Exp;
branches;
next	1.13;

1.13
date	2006.01.05.08.28.30;	author grange;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.05.08.16.22;	author grange;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.03.23.24.06;	author grange;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.03.22.39.03;	author grange;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.01.20.52.27;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.28.20.10.44;	author grange;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.25.18.46.24;	author grange;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.25.15.46.14;	author grange;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.25.15.04.48;	author grange;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.25.09.44.54;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.24.21.04.20;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.17.10.18.01;	author grange;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.28.17.15.12;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Use %z* for size_t

while there, fix a few %d into %u
@
text
@/*	$OpenBSD: piixpm.c,v 1.38 2012/10/05 10:51:28 haesbaert Exp $	*/

/*
 * Copyright (c) 2005, 2006 Alexander Yurchenko <grange@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Intel PIIX and compatible Power Management controller driver.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/rwlock.h>

#include <machine/bus.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

#include <dev/pci/piixreg.h>

#include <dev/i2c/i2cvar.h>

#ifdef PIIXPM_DEBUG
#define DPRINTF(x) printf x
#else
#define DPRINTF(x)
#endif

#define PIIXPM_DELAY	200
#define PIIXPM_TIMEOUT	1

struct piixpm_softc {
	struct device		sc_dev;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	void *			sc_ih;
	int			sc_poll;

	struct i2c_controller	sc_i2c_tag;
	struct rwlock		sc_i2c_lock;
	struct {
		i2c_op_t     op;
		void *       buf;
		size_t       len;
		int          flags;
		volatile int error;
	}			sc_i2c_xfer;
};

int	piixpm_match(struct device *, void *, void *);
void	piixpm_attach(struct device *, struct device *, void *);

int	piixpm_i2c_acquire_bus(void *, int);
void	piixpm_i2c_release_bus(void *, int);
int	piixpm_i2c_exec(void *, i2c_op_t, i2c_addr_t, const void *, size_t,
	    void *, size_t, int);

int	piixpm_intr(void *);

struct cfattach piixpm_ca = {
	sizeof(struct piixpm_softc),
	piixpm_match,
	piixpm_attach
};

struct cfdriver piixpm_cd = {
	NULL, "piixpm", DV_DULL
};

const struct pci_matchid piixpm_ids[] = {
	{ PCI_VENDOR_AMD, PCI_PRODUCT_AMD_HUDSON2_SMB },

	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_SB200_SMB },
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_SB300_SMB },
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_SB400_SMB },
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_SBX00_SMB },

	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82371AB_PM },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82440MX_PM },

	{ PCI_VENDOR_RCC, PCI_PRODUCT_RCC_CSB5 },
	{ PCI_VENDOR_RCC, PCI_PRODUCT_RCC_CSB6 },
	{ PCI_VENDOR_RCC, PCI_PRODUCT_RCC_HT_1000 },
	{ PCI_VENDOR_RCC, PCI_PRODUCT_RCC_HT_1100 },
	{ PCI_VENDOR_RCC, PCI_PRODUCT_RCC_OSB4 },

	{ PCI_VENDOR_SMSC, PCI_PRODUCT_SMSC_VICTORY66_PM }
};

int
piixpm_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid(aux, piixpm_ids,
	    sizeof(piixpm_ids) / sizeof(piixpm_ids[0])));
}

void
piixpm_attach(struct device *parent, struct device *self, void *aux)
{
	struct piixpm_softc *sc = (struct piixpm_softc *)self;
	struct pci_attach_args *pa = aux;
	bus_space_handle_t ioh;
	u_int16_t smb0en;
	bus_addr_t base;
	pcireg_t conf;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
	struct i2cbus_attach_args iba;

	sc->sc_iot = pa->pa_iot;

	if ((PCI_VENDOR(pa->pa_id) == PCI_VENDOR_AMD &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AMD_HUDSON2_SMB) ||
	    (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ATI &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ATI_SBX00_SMB &&
	    PCI_REVISION(pa->pa_class) >= 0x40)) {
		/* 
		 * On the AMD SB800+, the SMBus I/O registers are well
		 * hidden.  We need to look at the "SMBus0En" Power
		 * Management register to find out where they live.
		 * We use indirect IO access through the index/data
		 * pair at 0xcd6/0xcd7 to access "SMBus0En".  Since
		 * the index/data pair may be needed by other drivers,
		 * we only map them for the duration that we actually
		 * need them.
		 */
		if (bus_space_map(sc->sc_iot, SB800_PMREG_BASE,
		    SB800_PMREG_SIZE, 0, &ioh) != 0) {
			printf(": can't map i/o space\n");
			return;
		}

		/* Read "SmBus0En" */
		bus_space_write_1(sc->sc_iot, ioh, 0, SB800_PMREG_SMB0EN);
		smb0en = bus_space_read_1(sc->sc_iot, ioh, 1);
		bus_space_write_1(sc->sc_iot, ioh, 0, SB800_PMREG_SMB0EN + 1);
		smb0en |= (bus_space_read_1(sc->sc_iot, ioh, 1) << 8);

		bus_space_unmap(sc->sc_iot, ioh, SB800_PMREG_SIZE);

		if ((smb0en & SB800_SMB0EN_EN) == 0) {
			printf(": SMBus disabled\n");
			return;
		}

		/* Map I/O space */
		base = smb0en & SB800_SMB0EN_BASE_MASK;
		if (base == 0 || bus_space_map(sc->sc_iot, base,
		    SB800_SMB_SIZE, 0, &sc->sc_ioh)) {
			printf(": can't map i/o space");
			return;
		}

		/* Read configuration */
		conf = bus_space_read_1(sc->sc_iot, sc->sc_ioh, SB800_SMB_HOSTC);
		if (conf & SB800_SMB_HOSTC_SMI)
			conf = PIIX_SMB_HOSTC_SMI;
		else
			conf = PIIX_SMB_HOSTC_IRQ;
	} else {
		/* Read configuration */
		conf = pci_conf_read(pa->pa_pc, pa->pa_tag, PIIX_SMB_HOSTC);
		DPRINTF((": conf 0x%08x", conf));

		if ((conf & PIIX_SMB_HOSTC_HSTEN) == 0) {
			printf(": SMBus disabled\n");
			return;
		}

		/* Map I/O space */
		base = pci_conf_read(pa->pa_pc, pa->pa_tag, PIIX_SMB_BASE) &
		    PIIX_SMB_BASE_MASK;
		if (base == 0 || bus_space_map(sc->sc_iot, base,
		    PIIX_SMB_SIZE, 0, &sc->sc_ioh)) {
			printf(": can't map i/o space\n");
			return;
		}
	}

	sc->sc_poll = 1;
	if ((conf & PIIX_SMB_HOSTC_INTMASK) == PIIX_SMB_HOSTC_SMI) {
		/* No PCI IRQ */
		printf(": SMI");
	} else {
		if ((conf & PIIX_SMB_HOSTC_INTMASK) == PIIX_SMB_HOSTC_IRQ) {
			/* Install interrupt handler */
			if (pci_intr_map(pa, &ih) == 0) {
				intrstr = pci_intr_string(pa->pa_pc, ih);
				sc->sc_ih = pci_intr_establish(pa->pa_pc,
				    ih, IPL_BIO, piixpm_intr, sc,
				    sc->sc_dev.dv_xname);
				if (sc->sc_ih != NULL) {
					printf(": %s", intrstr);
					sc->sc_poll = 0;
				}
			}
		}
		if (sc->sc_poll)
			printf(": polling");
	}

	printf("\n");

	/* Attach I2C bus */
	rw_init(&sc->sc_i2c_lock, "iiclk");
	sc->sc_i2c_tag.ic_cookie = sc;
	sc->sc_i2c_tag.ic_acquire_bus = piixpm_i2c_acquire_bus;
	sc->sc_i2c_tag.ic_release_bus = piixpm_i2c_release_bus;
	sc->sc_i2c_tag.ic_exec = piixpm_i2c_exec;

	bzero(&iba, sizeof(iba));
	iba.iba_name = "iic";
	iba.iba_tag = &sc->sc_i2c_tag;
	config_found(self, &iba, iicbus_print);

	return;
}

int
piixpm_i2c_acquire_bus(void *cookie, int flags)
{
	struct piixpm_softc *sc = cookie;

	if (cold || sc->sc_poll || (flags & I2C_F_POLL))
		return (0);

	return (rw_enter(&sc->sc_i2c_lock, RW_WRITE | RW_INTR));
}

void
piixpm_i2c_release_bus(void *cookie, int flags)
{
	struct piixpm_softc *sc = cookie;

	if (cold || sc->sc_poll || (flags & I2C_F_POLL))
		return;

	rw_exit(&sc->sc_i2c_lock);
}

int
piixpm_i2c_exec(void *cookie, i2c_op_t op, i2c_addr_t addr,
    const void *cmdbuf, size_t cmdlen, void *buf, size_t len, int flags)
{
	struct piixpm_softc *sc = cookie;
	u_int8_t *b;
	u_int8_t ctl, st;
	int retries;

	DPRINTF(("%s: exec: op %d, addr 0x%02x, cmdlen %d, len %d, "
	    "flags 0x%02x\n", sc->sc_dev.dv_xname, op, addr, cmdlen,
	    len, flags));

	/* Wait for bus to be idle */
	for (retries = 100; retries > 0; retries--) {
		st = bus_space_read_1(sc->sc_iot, sc->sc_ioh, PIIX_SMB_HS);
		if (!(st & PIIX_SMB_HS_BUSY))
			break;
		DELAY(PIIXPM_DELAY);
	}
	DPRINTF(("%s: exec: st 0x%b\n", sc->sc_dev.dv_xname, st,
	    PIIX_SMB_HS_BITS));
	if (st & PIIX_SMB_HS_BUSY)
		return (1);

	if (cold || sc->sc_poll)
		flags |= I2C_F_POLL;

	if (!I2C_OP_STOP_P(op) || cmdlen > 1 || len > 2)
		return (1);

	/* Setup transfer */
	sc->sc_i2c_xfer.op = op;
	sc->sc_i2c_xfer.buf = buf;
	sc->sc_i2c_xfer.len = len;
	sc->sc_i2c_xfer.flags = flags;
	sc->sc_i2c_xfer.error = 0;

	/* Set slave address and transfer direction */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, PIIX_SMB_TXSLVA,
	    PIIX_SMB_TXSLVA_ADDR(addr) |
	    (I2C_OP_READ_P(op) ? PIIX_SMB_TXSLVA_READ : 0));

	b = (void *)cmdbuf;
	if (cmdlen > 0)
		/* Set command byte */
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, PIIX_SMB_HCMD, b[0]);

	if (I2C_OP_WRITE_P(op)) {
		/* Write data */
		b = buf;
		if (len > 0)
			bus_space_write_1(sc->sc_iot, sc->sc_ioh,
			    PIIX_SMB_HD0, b[0]);
		if (len > 1)
			bus_space_write_1(sc->sc_iot, sc->sc_ioh,
			    PIIX_SMB_HD1, b[1]);
	}

	/* Set SMBus command */
	if (len == 0)
		ctl = PIIX_SMB_HC_CMD_BYTE;
	else if (len == 1)
		ctl = PIIX_SMB_HC_CMD_BDATA;
	else if (len == 2)
		ctl = PIIX_SMB_HC_CMD_WDATA;
	else
		panic("%s: unexpected len %zd", __func__, len);

	if ((flags & I2C_F_POLL) == 0)
		ctl |= PIIX_SMB_HC_INTREN;

	/* Start transaction */
	ctl |= PIIX_SMB_HC_START;
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, PIIX_SMB_HC, ctl);

	if (flags & I2C_F_POLL) {
		/* Poll for completion */
		DELAY(PIIXPM_DELAY);
		for (retries = 1000; retries > 0; retries--) {
			st = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
			    PIIX_SMB_HS);
			if ((st & PIIX_SMB_HS_BUSY) == 0)
				break;
			DELAY(PIIXPM_DELAY);
		}
		if (st & PIIX_SMB_HS_BUSY)
			goto timeout;
		piixpm_intr(sc);
	} else {
		/* Wait for interrupt */
		if (tsleep(sc, PRIBIO, "piixpm", PIIXPM_TIMEOUT * hz))
			goto timeout;
	}

	if (sc->sc_i2c_xfer.error)
		return (1);

	return (0);

timeout:
	/*
	 * Transfer timeout. Kill the transaction and clear status bits.
	 */
	printf("%s: exec: op %d, addr 0x%02x, cmdlen %zu, len %zu, "
	    "flags 0x%02x: timeout, status 0x%b\n",
	    sc->sc_dev.dv_xname, op, addr, cmdlen, len, flags,
	    st, PIIX_SMB_HS_BITS);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, PIIX_SMB_HC,
	    PIIX_SMB_HC_KILL);
	DELAY(PIIXPM_DELAY);
	st = bus_space_read_1(sc->sc_iot, sc->sc_ioh, PIIX_SMB_HS);
	if ((st & PIIX_SMB_HS_FAILED) == 0)
		printf("%s: abort failed, status 0x%b\n",
		    sc->sc_dev.dv_xname, st, PIIX_SMB_HS_BITS);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, PIIX_SMB_HS, st);
	return (1);
}

int
piixpm_intr(void *arg)
{
	struct piixpm_softc *sc = arg;
	u_int8_t st;
	u_int8_t *b;
	size_t len;

	/* Read status */
	st = bus_space_read_1(sc->sc_iot, sc->sc_ioh, PIIX_SMB_HS);
	if ((st & PIIX_SMB_HS_BUSY) != 0 || (st & (PIIX_SMB_HS_INTR |
	    PIIX_SMB_HS_DEVERR | PIIX_SMB_HS_BUSERR |
	    PIIX_SMB_HS_FAILED)) == 0)
		/* Interrupt was not for us */
		return (0);

	DPRINTF(("%s: intr st 0x%b\n", sc->sc_dev.dv_xname, st,
	    PIIX_SMB_HS_BITS));

	/* Clear status bits */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, PIIX_SMB_HS, st);

	/* Check for errors */
	if (st & (PIIX_SMB_HS_DEVERR | PIIX_SMB_HS_BUSERR |
	    PIIX_SMB_HS_FAILED)) {
		sc->sc_i2c_xfer.error = 1;
		goto done;
	}

	if (st & PIIX_SMB_HS_INTR) {
		if (I2C_OP_WRITE_P(sc->sc_i2c_xfer.op))
			goto done;

		/* Read data */
		b = sc->sc_i2c_xfer.buf;
		len = sc->sc_i2c_xfer.len;
		if (len > 0)
			b[0] = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
			    PIIX_SMB_HD0);
		if (len > 1)
			b[1] = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
			    PIIX_SMB_HD1);
	}

done:
	if ((sc->sc_i2c_xfer.flags & I2C_F_POLL) == 0)
		wakeup(sc);
	return (1);
}
@


1.38
log
@Avoid uninitiliazed use of ctl and corresponding warnings.
Part of the work to remove -Wno-uninitialized.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.37 2012/03/07 21:41:53 brynet Exp $	*/
d362 1
a362 1
	printf("%s: exec: op %d, addr 0x%02x, cmdlen %d, len %d, "
@


1.37
log
@Add AMD Hudson-2 support, thanks to Jorg Willekens for testing.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.36 2011/05/28 14:56:32 kettenis Exp $	*/
d324 2
@


1.36
log
@Add support for AMD SB800, where the SMBus control registers have been hidden
away.  Based on a diff from Bryan Steele.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.35 2011/04/09 04:33:40 deraadt Exp $	*/
d88 2
d129 3
a131 1
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ATI &&
d133 1
a133 1
	    PCI_REVISION(pa->pa_class) >= 0x40) {
d135 1
a135 1
		 * On the AMD SB800, the SMBus I/O registers are well
@


1.35
log
@use unique wait channels
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.34 2010/04/08 00:23:53 tedu Exp $	*/
d117 4
a120 2
	struct i2cbus_attach_args iba;
	pcireg_t base, conf;
d123 1
d125 1
a125 8
	/* Read configuration */
	conf = pci_conf_read(pa->pa_pc, pa->pa_tag, PIIX_SMB_HOSTC);
	DPRINTF((": conf 0x%08x", conf));

	if ((conf & PIIX_SMB_HOSTC_HSTEN) == 0) {
		printf(": SMBus disabled\n");
		return;
	}
d127 64
a190 8
	/* Map I/O space */
	sc->sc_iot = pa->pa_iot;
	base = pci_conf_read(pa->pa_pc, pa->pa_tag, PIIX_SMB_BASE) & 0xffff;
	if (PCI_MAPREG_IO_ADDR(base) == 0 ||
	    bus_space_map(sc->sc_iot, PCI_MAPREG_IO_ADDR(base),
	    PIIX_SMB_SIZE, 0, &sc->sc_ioh)) {
		printf(": can't map i/o space\n");
		return;
@


1.34
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.33 2009/11/05 09:37:05 sthen Exp $	*/
d291 1
a291 1
		if (tsleep(sc, PRIBIO, "iicexec", PIIXPM_TIMEOUT * hz))
@


1.33
log
@sort pci_matchid's, from Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.32 2009/06/24 13:49:48 deraadt Exp $	*/
a27 1
#include <sys/proc.h>
@


1.32
log
@Add support for the SMBus controller for the Broadcom HT-1100 chipset
to piixpm(4).
from brad
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.31 2009/03/29 21:53:52 sthen Exp $	*/
d89 5
d96 1
a96 1
	{ PCI_VENDOR_RCC, PCI_PRODUCT_RCC_OSB4 },
d101 3
a103 5
	{ PCI_VENDOR_SMSC, PCI_PRODUCT_SMSC_VICTORY66_PM },
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_SB200_SMB },
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_SB300_SMB },
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_SB400_SMB },
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_SBX00_SMB }
@


1.31
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.30 2008/09/17 06:14:09 brad Exp $	*/
d95 1
@


1.30
log
@Update for renamed ATI PCI ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.29 2008/05/24 06:23:40 brad Exp $	*/
d134 1
a134 1
		printf(": can't map I/O space\n");
@


1.29
log
@Sync the ATI IXP200 PCI id.
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.28 2007/09/13 16:56:09 brad Exp $	*/
d96 4
a99 4
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_IXP_SMB_200 },
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_IXP_SMB_300 },
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_IXP_SMB_400 },
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_IXP_SMB_X00 }
@


1.28
log
@sync AMD SB600 PCI id with the new name.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.27 2007/05/03 09:36:26 dlg Exp $	*/
d96 1
a96 1
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_SB200_SMB },
@


1.27
log
@convert lockmgr style locks to rwlocks.

input from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.26 2007/04/29 05:51:51 jsg Exp $	*/
d99 1
a99 1
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_IXP_SMB_600 }
@


1.26
log
@Match on ATI IXP/SB600 as well.
Seen in a dmesg from alemao <skanabiz@@gmail.com>

ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.25 2006/12/11 18:16:37 deraadt Exp $	*/
d27 1
a27 1
#include <sys/lock.h>
d58 1
a58 1
	struct lock		sc_i2c_lock;
d163 1
a163 1
	lockinit(&sc->sc_i2c_lock, PRIBIO | PCATCH, "iiclk", 0, 0);
d185 1
a185 1
	return (lockmgr(&sc->sc_i2c_lock, LK_EXCLUSIVE, NULL));
d196 1
a196 1
	lockmgr(&sc->sc_i2c_lock, LK_RELEASE, NULL);
@


1.25
log
@do not bus_space_map devices which are at address 0; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.24 2006/09/28 18:19:14 grange Exp $	*/
d98 2
a99 1
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_IXP_SMB_400 }
@


1.24
log
@Provide more info in error messages so we can see what's going
on. And some cosmetics in debug messages while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.23 2006/07/07 03:23:42 brad Exp $	*/
d130 2
a131 1
	if (bus_space_map(sc->sc_iot, PCI_MAPREG_IO_ADDR(base),
@


1.23
log
@use nested if-else to eliminate the need for a second polling printf,
suggested by grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.22 2006/06/26 15:52:59 brad Exp $	*/
d120 1
a120 1
	DPRINTF((": conf 0x%x", conf));
d206 3
a208 2
	DPRINTF(("%s: exec: op %d, addr 0x%x, cmdlen %d, len %d, flags 0x%x\n",
	    sc->sc_dev.dv_xname, op, addr, cmdlen, len, flags));
d299 4
a302 2
	printf("%s: timeout, status 0x%b\n", sc->sc_dev.dv_xname, st,
	    PIIX_SMB_HS_BITS);
d308 1
a308 1
		printf("%s: transaction abort failed, status 0x%b\n",
@


1.22
log
@if piixpm does not try to attach an interrupt then indicate that the chip
is in polling mode.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.21 2006/06/26 13:56:29 brad Exp $	*/
d140 12
a151 9
	} else if ((conf & PIIX_SMB_HOSTC_INTMASK) == PIIX_SMB_HOSTC_IRQ) {
		/* Install interrupt handler */
		if (pci_intr_map(pa, &ih) == 0) {
			intrstr = pci_intr_string(pa->pa_pc, ih);
			sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO,
			    piixpm_intr, sc, sc->sc_dev.dv_xname);
			if (sc->sc_ih != NULL) {
				printf(": %s", intrstr);
				sc->sc_poll = 0;
d156 1
a156 2
	} else
		printf(": polling");
@


1.21
log
@add the PCI id for the ServerWorks HT-1000 SMbus controller.

From the Linux i2c-piix4 driver via gwk@@

piixpm0 at pci0 dev 2 function 0 "ServerWorks HT-1000" rev 0x00
iic0 at piixpm0
admcts0 at iic0 addr 0x2c
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.20 2006/02/27 08:25:02 grange Exp $	*/
d153 2
a154 1
	}
@


1.20
log
@Increase delay value, fixes pr5018.
With a help from kettenis@@, ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.19 2006/02/11 05:26:32 grange Exp $	*/
d94 1
@


1.19
log
@Mask off the highest 16 bit of the io space address.
Problem reported by kocka@@hysteria.hu.
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.18 2006/01/18 02:57:27 brad Exp $	*/
d46 1
a46 1
#define PIIXPM_DELAY	100
@


1.18
log
@add some PIIX compatible SMBus controllers from SMSC and ATI.

Thanks to ian@@ and msf@@ for testing with an ATI IXP400 controller.
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.17 2006/01/15 10:28:17 grange Exp $	*/
d128 1
a128 1
	base = pci_conf_read(pa->pa_pc, pa->pa_tag, PIIX_SMB_BASE);
@


1.17
log
@In iic_exec don't fail immediately if bus is already busy. It might be
running a BIOS' transfer so wait a bit and try again.
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.16 2006/01/15 10:04:39 grange Exp $	*/
d93 5
a97 1
	{ PCI_VENDOR_RCC, PCI_PRODUCT_RCC_CSB6 }
@


1.16
log
@Simplify interrupt handler installing code.
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.15 2006/01/12 00:21:59 deraadt Exp $	*/
d201 7
a207 2
	/* Check if there's a transfer already running */
	st = bus_space_read_1(sc->sc_iot, sc->sc_ioh, PIIX_SMB_HS);
@


1.15
log
@if we cannot map the interrupt, try to do iic in polling mode anyways.
this lets iic work on at least a few other machines, we hope without
any downside.  at least we know from the previous check that it is not
wired to SMI, right?; ok grange
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.14 2006/01/05 10:43:15 grange Exp $	*/
d20 1
a20 1
 * Intel PIIX and compatible SMBus controller driver.
d131 1
d133 1
a134 1
		sc->sc_poll = 1;
d137 8
a144 3
		if (pci_intr_map(pa, &ih)) {
			printf(": can't map interrupt");
			goto ok;
d146 2
a147 14
		intrstr = pci_intr_string(pa->pa_pc, ih);
		sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO,
		    piixpm_intr, sc, sc->sc_dev.dv_xname);
		if (sc->sc_ih == NULL) {
			printf(": can't establish interrupt");
			if (intrstr != NULL)
				printf(" at %s", intrstr);
			printf("\n");
			goto fail;
		}
		printf(": %s", intrstr);
	} else {
ok:
		sc->sc_poll = 1;
a164 3

fail:
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, PIIX_SMB_SIZE);
@


1.14
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.13 2006/01/05 08:28:30 grange Exp $	*/
d137 2
a138 2
			printf(": can't map interrupt\n");
			goto fail;
d152 1
@


1.13
log
@Happy New Year!
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.12 2006/01/05 08:16:22 grange Exp $	*/
d164 1
a164 1
	bzero(&iba, sizeof iba);
@


1.12
log
@Reliability fixes:

- don't force enabling host controller
- don't start new transfer if bus is busy
- kill transfer on timeout

Some ideas from kettenis@@; ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.11 2006/01/03 23:24:06 grange Exp $	*/
d4 1
a4 1
 * Copyright (c) 2005 Alexander Yurchenko <grange@@openbsd.org>
@


1.11
log
@Revert part of the previous committed by mistake.
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.10 2006/01/03 22:39:03 grange Exp $	*/
d113 9
a130 4
	/* Read configuration */
	conf = pci_conf_read(pa->pa_pc, pa->pa_tag, PIIX_SMB_HOSTC);
	DPRINTF((": conf 0x%x", conf));

a154 4
	/* Enable controller */
	pci_conf_write(pa->pa_pc, pa->pa_tag, PIIX_SMB_HOSTC,
	    conf | PIIX_SMB_HOSTC_HSTEN);

d206 9
a214 4
	DPRINTF(("%s: exec op %d, addr 0x%x, cmdlen %d, len %d, "
	    "flags 0x%x, status 0x%b\n", sc->sc_dev.dv_xname, op, addr,
	    cmdlen, len, flags, bus_space_read_1(sc->sc_iot, sc->sc_ioh,
	    PIIX_SMB_HS), PIIX_SMB_HS_BITS));
d275 2
a276 5
		if (st & PIIX_SMB_HS_BUSY) {
			printf("%s: timeout, status 0x%b\n",
			    sc->sc_dev.dv_xname, st, PIIX_SMB_HS_BITS);
			return (1);
		}
d281 2
a282 2
			return (1);
	}	
d288 16
@


1.10
log
@Correct interrupt type check. Pointed out by kettenis@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.9 2006/01/01 20:52:27 deraadt Exp $	*/
d202 2
a203 2
	u_int8_t ctl, st, sctl;
	int retries, error = 0;
a222 5
	/* Make sure SMBALERT# assertion disabled */
	sctl = bus_space_read_1(sc->sc_iot, sc->sc_ioh, PIIX_SMB_SC);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, PIIX_SMB_SC,
	    sctl & ~PIIX_SMB_SC_ALERTEN);

d272 1
a272 3
			error = 1;
		} else {
			piixpm_intr(sc);
d274 1
d278 1
a278 1
			error = 1;
d281 1
a281 4
	/* Restore SMBALERT# assertion */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, PIIX_SMB_SC, sctl);

	if (error || sc->sc_i2c_xfer.error)
@


1.9
log
@switch from macppc-specific maciic(4) driver to the generic iic(4),
after teaching it to use a function pointer to get back to the OFW
scan.. this will also help the sparc64 later; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.8 2005/12/28 20:10:44 grange Exp $	*/
d126 1
a126 1
	if ((conf & PIIX_SMB_HOSTC_SMI) == PIIX_SMB_HOSTC_SMI) {
d129 1
a129 1
	} else if ((conf & PIIX_SMB_HOSTC_IRQ) == PIIX_SMB_HOSTC_IRQ) {
d202 2
a203 2
	u_int8_t ctl, st;
	int retries;
d223 5
d277 3
a279 1
			return (1);
a280 1
		piixpm_intr(sc);
d284 1
a284 1
			return (1);
d287 4
a290 1
	if (sc->sc_i2c_xfer.error)
@


1.8
log
@Use corrent size for io mapping. Problem reported by
steve.shockley@@shockley.net.
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.7 2005/12/25 18:46:24 grange Exp $	*/
d162 2
a165 1
	iba.iba_scan = 1;
@


1.7
log
@Don't allow slave devices to do polling during autoconf.
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.6 2005/12/25 15:46:14 grange Exp $	*/
a109 1
	bus_size_t iosize;
d114 1
a115 2
	iosize = PCI_MAPREG_IO_SIZE(base);
	sc->sc_iot = pa->pa_iot;
d117 1
a117 1
	    iosize, 0, &sc->sc_ioh)) {
d170 1
a170 1
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
@


1.6
log
@Force polling if interrupts not available.
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.5 2005/12/25 15:04:48 grange Exp $	*/
d180 1
a180 1
	if (sc->sc_poll || flags & I2C_F_POLL)
d191 1
a191 1
	if (sc->sc_poll || flags & I2C_F_POLL)
d211 1
a211 1
	if (sc->sc_poll)
@


1.5
log
@Move all PIIX register definitions to a separate file.
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.4 2005/12/25 09:44:54 grange Exp $	*/
d20 1
a20 1
 * Intel PIIX and compatible power management and SMBus controller driver.
d55 1
d128 5
a132 2
	/* Install interrupt handler if IRQ enabled */
	if ((conf & PIIX_SMB_HOSTC_IRQ) == PIIX_SMB_HOSTC_IRQ) {
d148 2
d180 1
a180 1
	if (flags & I2C_F_POLL)
d191 1
a191 1
	if (flags & I2C_F_POLL)
d210 3
@


1.4
log
@Consistent device ids for piix pm controllers.
@
text
@d1 1
a1 1
/*	$OpenBSD: piixpm.c,v 1.3 2005/12/24 21:04:20 grange Exp $	*/
d36 2
a47 31

/* Register definitions */
#define PIIX_SMB_BASE	0x90		/* SMBus base address */
#define PIIX_SMB_HOSTC	0xd0		/* host configuration */
#define PIIX_SMB_HOSTC_HSTEN	(1 << 16)	/* enable host controller */
#define PIIX_SMB_HOSTC_SMI	(0 << 17)	/* SMI */
#define PIIX_SMB_HOSTC_IRQ	(4 << 17)	/* IRQ */

#define PIIX_SMB_HS	0x00		/* host status */
#define PIIX_SMB_HS_BUSY	(1 << 0)	/* running a command */
#define PIIX_SMB_HS_INTR	(1 << 1)	/* command completed */
#define PIIX_SMB_HS_DEVERR	(1 << 2)	/* command error */
#define PIIX_SMB_HS_BUSERR	(1 << 3)	/* transaction collision */
#define PIIX_SMB_HS_FAILED	(1 << 4)	/* failed bus transaction */
#define PIIX_SMB_HS_BITS	"\020\001BUSY\002INTR\003DEVERR\004BUSERR\005FAILED"
#define PIIX_SMB_HC	0x02		/* host control */
#define PIIX_SMB_HC_INTREN	(1 << 0)	/* enable interrupts */
#define PIIX_SMB_HC_KILL	(1 << 1)	/* kill current transaction */
#define PIIX_SMB_HC_CMD_QUICK	(0 << 2)	/* QUICK command */
#define PIIX_SMB_HC_CMD_BYTE	(1 << 2)	/* BYTE command */
#define PIIX_SMB_HC_CMD_BDATA	(2 << 2)	/* BYTE DATA command */
#define PIIX_SMB_HC_CMD_WDATA	(3 << 2)	/* WORD DATA command */
#define PIIX_SMB_HC_CMD_BLOCK	(5 << 2)	/* BLOCK command */
#define PIIX_SMB_HC_START	(1 << 6)	/* start transaction */
#define PIIX_SMB_HCMD	0x03		/* host command */
#define PIIX_SMB_TXSLVA	0x04		/* transmit slave address */
#define PIIX_SMB_TXSLVA_READ	(1 << 0)	/* read direction */
#define PIIX_SMB_TXSLVA_ADDR(x)	(((x) & 0x7f) << 1) /* 7-bit address */
#define PIIX_SMB_HD0	0x05		/* host data 0 */
#define PIIX_SMB_HD1	0x06		/* host data 1 */
#define PIIX_SMB_HBDB	0x07		/* host block data byte */
@


1.3
log
@Rewrite piixpm(4) driver. It doesn't support acpi timer anymore, if we
want it for timecounters we better use real chipset-independent
acpi timer driver (that's already in the tree, btw).
Instead it supports Intel PIIX (and compatible, like ServerWorks)
SMBus controller to be used with our fancy i2c stuff.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d117 1
a117 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82371AB_PMC },
@


1.2
log
@Some cleanup:
- don't mix unsigned and u_int across the code
- un'static some funcs

ok art@@
@
text
@d1 8
a8 7
/*-
 * ----------------------------------------------------------------------------
 * "THE BEER-WARE LICENSE" (Revision 42):
 * <phk@@FreeBSD.ORG> wrote this file.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp
 * ----------------------------------------------------------------------------
d10 7
a16 2
 *	$OpenBSD: piixpm.c,v 1.1 2004/07/28 17:15:12 tholo Exp $
 *	$FreeBSD: /repoman/r/ncvs/src/sys/i386/i386/mp_clock.c,v 1.19 2004/05/30 20:34:57 phk Exp $
d19 2
a20 23
/*-
 * Just when we thought life were beautiful, reality pops its grim face over
 * the edge again:
 *
 * ] 20. ACPI Timer Errata
 * ]
 * ]   Problem: The power management timer may return improper result when
 * ]   read. Although the timer value settles properly after incrementing,
 * ]   while incrementing there is a 3nS window every 69.8nS where the
 * ]   timer value is indeterminate (a 4.2% chance that the data will be
 * ]   incorrect when read). As a result, the ACPI free running count up
 * ]   timer specification is violated due to erroneous reads.  Implication:
 * ]   System hangs due to the "inaccuracy" of the timer when used by
 * ]   software for time critical events and delays.
 * ] 
 * ] Workaround: Read the register twice and compare.
 * ] Status: This will not be fixed in the PIIX4 or PIIX4E.
 *
 * The counter is in other words not latched to the PCI bus clock when
 * read.  Notice the workaround isn't:  We need to read until we have
 * three monotonic samples and then use the middle one, otherwise we are
 * not protected against the fact that the bits can be wrong in two
 * directions.  If we only cared about monosity two reads would be enough.
d27 2
a28 4
#include <sys/sysctl.h>
#ifdef __HAVE_TIMECOUNTER
#include <sys/timetc.h>
#endif
d32 2
a34 2
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>
d36 10
a45 1
#define PIIX_PMPTR	0x40		/* PIIX PM address ptr */
d47 30
a76 2
#define	PIIX_PMBASE(x)	((x) & 0xffc0)	/* PIIX PM base address */
#define	PIIX_PMSIZE	56		/* PIIX PM space size */
d80 1
d83 11
d96 2
a97 2
int piixpm_probe(struct device *, void *, void *);
void piixpm_attach(struct device *, struct device *, void *);
d99 4
a102 2
#ifdef __HAVE_TIMECOUNTER
u_int piix_get_timecount(struct timecounter *tc);
d104 1
a104 11
static u_int piix_freq = 14318182/4;

static struct timecounter piix_timecounter = {
	piix_get_timecount,	/* get_timecount */
	0,			/* no poll_pps */
	0xffffff,		/* counter_mask */
	0,			/* frequency */
	"PIIX",			/* name */
	1000			/* quality */
};
#endif
d107 3
a109 1
	sizeof(struct piixpm_softc), piixpm_probe, piixpm_attach
d116 8
a123 1
#if 0
d125 8
a132 1
sysctl_machdep_piix_freq(SYSCTL_HANDLER_ARGS)
d134 17
a150 2
	int error;
	u_int freq;
d152 21
a172 7
	if (piix_timecounter.tc_frequency == 0)
		return (EOPNOTSUPP);
	freq = piix_freq;
	error = sysctl_handle_int(oidp, &freq, sizeof(freq), req);
	if (error == 0 && req->newptr != NULL) {
		piix_freq = freq;
		piix_timecounter.tc_frequency = piix_freq;
a173 2
	return (error);
}
d175 18
a192 3
SYSCTL_PROC(_machdep, OID_AUTO, piix_freq, CTLTYPE_INT | CTLFLAG_RW,
    0, sizeof(u_int), sysctl_machdep_piix_freq, "I", "");
#endif
d194 2
a195 15
#ifdef __HAVE_TIMECOUNTER
u_int
piix_get_timecount(struct timecounter *tc)
{
	struct piixpm_softc *sc = (struct piixpm_softc *) tc->tc_priv;
	u_int u1, u2, u3;

	u2 = bus_space_read_4(sc->sc_iot, sc->sc_ioh, 8);
	u3 = bus_space_read_4(sc->sc_iot, sc->sc_ioh, 8);
	do {
		u1 = u2;
		u2 = u3;
		u3 = bus_space_read_4(sc->sc_iot, sc->sc_ioh, 8);
	} while (u1 > u2 || u2 > u3);
	return (u2);
a196 1
#endif
a197 3
/*
 * XXX - this has to be redone if we ever do real ACPI
 */
d199 1
a199 1
piixpm_probe(struct device *parent, void *match, void *aux)
d201 1
a201 2
	struct pci_attach_args *pa = (struct pci_attach_args *) aux;
	pcireg_t reg;
d203 1
a203 2
	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_INTEL ||
	    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_INTEL_82371AB_PMC)
d206 1
a206 4
	reg = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	if ((reg & PCI_COMMAND_IO_ENABLE) == 0)
		return (0);
	return (1);
d210 100
a309 1
piixpm_attach(struct device *parent, struct device *self, void *aux)
d311 25
a335 4
	struct piixpm_softc *sc = (struct piixpm_softc *) self;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pcireg_t reg;
d337 14
a350 6
        reg = pci_conf_read(pc, pa->pa_tag, PIIX_PMPTR);
        if (bus_space_map(pa->pa_iot, PIIX_PMBASE(reg), PIIX_PMSIZE,
            0, &sc->sc_ioh)) {
                printf(": can't map i/o space\n");
                return;
        }
d352 4
a355 7
	sc->sc_iot = pa->pa_iot;
	printf("\n");
#ifdef __HAVE_TIMECOUNTER
	piix_timecounter.tc_frequency = piix_freq;
	piix_timecounter.tc_priv = sc;
	tc_init(&piix_timecounter);
#endif
@


1.1
log
@This touches only MI code, and adds new time keeping code.  The
code is all conditionalized on __HAVE_TIMECOUNTER, and not
enabled on any platforms.

adjtime(2) support exists, courtesy of nordin@@, sysctl(2) support
and a concept of quality for each time source attached exists.

High quality time sources exists for PIIX4 ACPI timer as well as
some AMD power management chips.  This will have to be redone
once we actually add ACPI support (at that time we need to use
the ACPI interfaces to get at these clocks).

ok art@@ ken@@ miod@@ jmc@@ and many more
@
text
@d9 1
a9 1
 *	$OpenBSD$
d68 1
a68 1
unsigned piix_get_timecount(struct timecounter *tc);
d113 1
a113 1
unsigned
d117 1
a117 1
	unsigned u1, u2, u3;
@

