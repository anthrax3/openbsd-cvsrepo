head	1.69;
access;
symbols
	OPENBSD_6_1:1.68.0.4
	OPENBSD_6_1_BASE:1.68
	OPENBSD_6_0:1.67.0.4
	OPENBSD_6_0_BASE:1.67
	OPENBSD_5_9:1.66.0.2
	OPENBSD_5_9_BASE:1.66
	OPENBSD_5_8:1.61.0.4
	OPENBSD_5_8_BASE:1.61
	OPENBSD_5_7:1.58.0.4
	OPENBSD_5_7_BASE:1.58
	OPENBSD_5_6:1.56.0.4
	OPENBSD_5_6_BASE:1.56
	OPENBSD_5_5:1.55.0.4
	OPENBSD_5_5_BASE:1.55
	OPENBSD_5_4:1.51.0.4
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.51.0.2
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.48.0.6
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.4
	OPENBSD_5_0:1.48.0.2
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.46.0.4
	OPENBSD_4_9_BASE:1.46
	OPENBSD_4_8:1.46.0.2
	OPENBSD_4_8_BASE:1.46
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.43.0.6
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.38.0.6
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.38.0.4
	OPENBSD_4_3_BASE:1.38
	OPENBSD_4_2:1.38.0.2
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.27.0.2
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.18
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.69
date	2017.07.13.17.45.00;	author naddy;	state Exp;
branches;
next	1.68;
commitid	H1dcpsj5TAOQZCrP;

1.68
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.67;
commitid	VyLWTsbepAOk7VQM;

1.67
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.66;
commitid	8YSL8ByWzGeIGBiJ;

1.66
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.65;
commitid	B0kwmVGiD5DVx4kv;

1.65
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.64;
commitid	5gdEnqVoJuTuwdTu;

1.64
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.63;
commitid	5DvsamK0GblTp8ww;

1.63
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.62;
commitid	hPF95ClMUQfeqQDX;

1.62
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.61;
commitid	6vhYvh5CxZAHMnsN;

1.61
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.60;
commitid	MVWrtktB46JRxFWT;

1.60
date	2015.04.13.08.45.48;	author mpi;	state Exp;
branches;
next	1.59;
commitid	aiRvgNOa4qke9vft;

1.59
date	2015.04.08.10.07.47;	author mpi;	state Exp;
branches;
next	1.58;
commitid	hnmA6leYzflFI0c3;

1.58
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.57;
commitid	yM2VFFhpDTeFQlve;

1.57
date	2014.12.03.09.10.17;	author brad;	state Exp;
branches;
next	1.56;
commitid	YqqEN5eB7aUBC0yj;

1.56
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.55;
commitid	TGHgrLxu6sxZoiFt;

1.55
date	2013.11.26.09.50.33;	author mpi;	state Exp;
branches;
next	1.54;

1.54
date	2013.10.01.20.06.02;	author sf;	state Exp;
branches;
next	1.53;

1.53
date	2013.08.21.05.21.45;	author dlg;	state Exp;
branches;
next	1.52;

1.52
date	2013.08.07.01.06.39;	author bluhm;	state Exp;
branches;
next	1.51;

1.51
date	2012.11.29.21.10.32;	author brad;	state Exp;
branches;
next	1.50;

1.50
date	2012.11.23.18.40.30;	author gsoares;	state Exp;
branches;
next	1.49;

1.49
date	2012.10.18.21.44.21;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2011.06.22.16.44.29;	author tedu;	state Exp;
branches;
next	1.47;

1.47
date	2011.04.03.15.36.03;	author jasper;	state Exp;
branches;
next	1.46;

1.46
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.45;

1.45
date	2009.08.13.14.24.47;	author jasper;	state Exp;
branches;
next	1.44;

1.44
date	2009.08.10.19.41.05;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2008.11.25.11.01.35;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2008.10.14.18.01.53;	author naddy;	state Exp;
branches;
next	1.40;

1.40
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.26.00.36.03;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.25.21.27.15;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2006.10.25.02.37.50;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.28.00.04.24;	author jason;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.25.22.41.46;	author djm;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.20.16.15.03;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2005.11.23.11.30.14;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.07.02.57.46;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.11.18.17.08;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2005.08.09.04.10.12;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2005.07.02.23.10.11;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.11.02.06.47;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2004.09.28.04.37.33;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.06.17.56.37;	author mcbride;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.19.14.01.35;	author mpech;	state Exp;
branches;
next	1.21;

1.21
date	2003.04.26.08.01.42;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.15.06.31.24;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.05.13.48.11;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.15.20.45.31;	author nordin;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.12.20.03.49;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.27.06.34.50;	author kjc;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.24.20.27.02;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.17.18.41.46;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.20.19.39.44;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.03.05.37.18;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.16.17.08.08;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.15.02.28.15;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	99.11.19.02.29.27;	author jason;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.09.27.18.17.01;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	99.09.03.01.48.38;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	99.03.11.18.20.13;	author jason;	state Exp;
branches;
next	;

1.4.2.1
date	2000.02.20.11.57.08;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.05.14.22.25.48;	author niklas;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2001.07.04.10.42.30;	author niklas;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2002.03.06.02.11.46;	author niklas;	state Exp;
branches;
next	1.4.2.7;

1.4.2.7
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.4.2.8;

1.4.2.8
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.4.2.9;

1.4.2.9
date	2003.05.13.19.35.06;	author ho;	state Exp;
branches;
next	1.4.2.10;

1.4.2.10
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	1.4.2.11;

1.4.2.11
date	2004.06.07.20.41.26;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.42.26;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2003.05.19.22.18.01;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.69
log
@kill a prototype for a nonexisting function; ok mpi@@
@
text
@/*	$OpenBSD: if_wb.c,v 1.68 2017/01/22 10:17:38 dlg Exp $	*/

/*
 * Copyright (c) 1997, 1998
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/pci/if_wb.c,v 1.26 1999/09/25 17:29:02 wpaul Exp $
 */

/*
 * Winbond fast ethernet PCI NIC driver
 *
 * Supports various cheap network adapters based on the Winbond W89C840F
 * fast ethernet controller chip. This includes adapters manufactured by
 * Winbond itself and some made by Linksys.
 *
 * Written by Bill Paul <wpaul@@ctr.columbia.edu>
 * Electrical Engineering Department
 * Columbia University, New York City
 */

/*
 * The Winbond W89C840F chip is a bus master; in some ways it resembles
 * a DEC 'tulip' chip, only not as complicated. Unfortunately, it has
 * one major difference which is that while the registers do many of
 * the same things as a tulip adapter, the offsets are different: where
 * tulip registers are typically spaced 8 bytes apart, the Winbond
 * registers are spaced 4 bytes apart. The receiver filter is also
 * programmed differently.
 * 
 * Like the tulip, the Winbond chip uses small descriptors containing
 * a status word, a control word and 32-bit areas that can either be used
 * to point to two external data blocks, or to point to a single block
 * and another descriptor in a linked list. Descriptors can be grouped
 * together in blocks to form fixed length rings or can be chained
 * together in linked lists. A single packet may be spread out over
 * several descriptors if necessary.
 *
 * For the receive ring, this driver uses a linked list of descriptors,
 * each pointing to a single mbuf cluster buffer, which us large enough
 * to hold an entire packet. The link list is looped back to created a
 * closed ring.
 *
 * For transmission, the driver creates a linked list of 'super descriptors'
 * which each contain several individual descriptors linked together.
 * Each 'super descriptor' contains WB_MAXFRAGS descriptors, which we
 * abuse as fragment pointers. This allows us to use a buffer management
 * scheme very similar to that used in the ThunderLAN and Etherlink XL
 * drivers.
 *
 * Autonegotiation is performed using the external PHY via the MII bus.
 * The sample boards I have all use a Davicom PHY.
 *
 * Note: the author of the Linux driver for the Winbond chip alludes
 * to some sort of flaw in the chip's design that seems to mandate some
 * drastic workaround which significantly impairs transmit performance.
 * I have no idea what he's on about: transmit performance with all
 * three of my test boards seems fine.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/queue.h>
#include <sys/timeout.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <uvm/uvm_extern.h>		/* for vtophys */
#define	VTOPHYS(v)	vtophys((vaddr_t)(v))

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#define WB_USEIOSPACE

/* #define WB_BACKGROUND_AUTONEG */

#include <dev/pci/if_wbreg.h>

int wb_probe(struct device *, void *, void *);
void wb_attach(struct device *, struct device *, void *);

void wb_bfree(caddr_t, u_int, void *);
void wb_newbuf(struct wb_softc *, struct wb_chain_onefrag *);
int wb_encap(struct wb_softc *, struct wb_chain *, struct mbuf *);

void wb_rxeof(struct wb_softc *);
void wb_rxeoc(struct wb_softc *);
void wb_txeof(struct wb_softc *);
void wb_txeoc(struct wb_softc *);
int wb_intr(void *);
void wb_tick(void *);
void wb_start(struct ifnet *);
int wb_ioctl(struct ifnet *, u_long, caddr_t);
void wb_init(void *);
void wb_stop(struct wb_softc *);
void wb_watchdog(struct ifnet *);
int wb_ifmedia_upd(struct ifnet *);
void wb_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void wb_eeprom_putbyte(struct wb_softc *, int);
void wb_eeprom_getword(struct wb_softc *, int, u_int16_t *);
void wb_read_eeprom(struct wb_softc *, caddr_t, int, int, int);
void wb_mii_sync(struct wb_softc *);
void wb_mii_send(struct wb_softc *, u_int32_t, int);
int wb_mii_readreg(struct wb_softc *, struct wb_mii_frame *);
int wb_mii_writereg(struct wb_softc *, struct wb_mii_frame *);

void wb_setcfg(struct wb_softc *, uint64_t);
void wb_setmulti(struct wb_softc *);
void wb_reset(struct wb_softc *);
void wb_fixmedia(struct wb_softc *);
int wb_list_rx_init(struct wb_softc *);
int wb_list_tx_init(struct wb_softc *);

int wb_miibus_readreg(struct device *, int, int);
void wb_miibus_writereg(struct device *, int, int, int);
void wb_miibus_statchg(struct device *);

#define WB_SETBIT(sc, reg, x)				\
	CSR_WRITE_4(sc, reg,				\
		CSR_READ_4(sc, reg) | x)

#define WB_CLRBIT(sc, reg, x)				\
	CSR_WRITE_4(sc, reg,				\
		CSR_READ_4(sc, reg) & ~x)

#define SIO_SET(x)					\
	CSR_WRITE_4(sc, WB_SIO,				\
		CSR_READ_4(sc, WB_SIO) | x)

#define SIO_CLR(x)					\
	CSR_WRITE_4(sc, WB_SIO,				\
		CSR_READ_4(sc, WB_SIO) & ~x)

/*
 * Send a read command and address to the EEPROM, check for ACK.
 */
void wb_eeprom_putbyte(sc, addr)
	struct wb_softc		*sc;
	int			addr;
{
	int			d, i;

	d = addr | WB_EECMD_READ;

	/*
	 * Feed in each bit and strobe the clock.
	 */
	for (i = 0x400; i; i >>= 1) {
		if (d & i) {
			SIO_SET(WB_SIO_EE_DATAIN);
		} else {
			SIO_CLR(WB_SIO_EE_DATAIN);
		}
		DELAY(100);
		SIO_SET(WB_SIO_EE_CLK);
		DELAY(150);
		SIO_CLR(WB_SIO_EE_CLK);
		DELAY(100);
	}

	return;
}

/*
 * Read a word of data stored in the EEPROM at address 'addr.'
 */
void wb_eeprom_getword(sc, addr, dest)
	struct wb_softc		*sc;
	int			addr;
	u_int16_t		*dest;
{
	int			i;
	u_int16_t		word = 0;

	/* Enter EEPROM access mode. */
	CSR_WRITE_4(sc, WB_SIO, WB_SIO_EESEL|WB_SIO_EE_CS);

	/*
	 * Send address of word we want to read.
	 */
	wb_eeprom_putbyte(sc, addr);

	CSR_WRITE_4(sc, WB_SIO, WB_SIO_EESEL|WB_SIO_EE_CS);

	/*
	 * Start reading bits from EEPROM.
	 */
	for (i = 0x8000; i; i >>= 1) {
		SIO_SET(WB_SIO_EE_CLK);
		DELAY(100);
		if (CSR_READ_4(sc, WB_SIO) & WB_SIO_EE_DATAOUT)
			word |= i;
		SIO_CLR(WB_SIO_EE_CLK);
		DELAY(100);
	}

	/* Turn off EEPROM access mode. */
	CSR_WRITE_4(sc, WB_SIO, 0);

	*dest = word;

	return;
}

/*
 * Read a sequence of words from the EEPROM.
 */
void wb_read_eeprom(sc, dest, off, cnt, swap)
	struct wb_softc		*sc;
	caddr_t			dest;
	int			off;
	int			cnt;
	int			swap;
{
	int			i;
	u_int16_t		word = 0, *ptr;

	for (i = 0; i < cnt; i++) {
		wb_eeprom_getword(sc, off + i, &word);
		ptr = (u_int16_t *)(dest + (i * 2));
		if (swap)
			*ptr = ntohs(word);
		else
			*ptr = word;
	}

	return;
}

/*
 * Sync the PHYs by setting data bit and strobing the clock 32 times.
 */
void wb_mii_sync(sc)
	struct wb_softc		*sc;
{
	int			i;

	SIO_SET(WB_SIO_MII_DIR|WB_SIO_MII_DATAIN);

	for (i = 0; i < 32; i++) {
		SIO_SET(WB_SIO_MII_CLK);
		DELAY(1);
		SIO_CLR(WB_SIO_MII_CLK);
		DELAY(1);
	}

	return;
}

/*
 * Clock a series of bits through the MII.
 */
void wb_mii_send(sc, bits, cnt)
	struct wb_softc		*sc;
	u_int32_t		bits;
	int			cnt;
{
	int			i;

	SIO_CLR(WB_SIO_MII_CLK);

	for (i = (0x1 << (cnt - 1)); i; i >>= 1) {
                if (bits & i) {
			SIO_SET(WB_SIO_MII_DATAIN);
                } else {
			SIO_CLR(WB_SIO_MII_DATAIN);
                }
		DELAY(1);
		SIO_CLR(WB_SIO_MII_CLK);
		DELAY(1);
		SIO_SET(WB_SIO_MII_CLK);
	}
}

/*
 * Read an PHY register through the MII.
 */
int wb_mii_readreg(sc, frame)
	struct wb_softc		*sc;
	struct wb_mii_frame	*frame;
	
{
	int			i, ack, s;

	s = splnet();

	/*
	 * Set up frame for RX.
	 */
	frame->mii_stdelim = WB_MII_STARTDELIM;
	frame->mii_opcode = WB_MII_READOP;
	frame->mii_turnaround = 0;
	frame->mii_data = 0;
	
	CSR_WRITE_4(sc, WB_SIO, 0);

	/*
 	 * Turn on data xmit.
	 */
	SIO_SET(WB_SIO_MII_DIR);

	wb_mii_sync(sc);

	/*
	 * Send command/address info.
	 */
	wb_mii_send(sc, frame->mii_stdelim, 2);
	wb_mii_send(sc, frame->mii_opcode, 2);
	wb_mii_send(sc, frame->mii_phyaddr, 5);
	wb_mii_send(sc, frame->mii_regaddr, 5);

	/* Idle bit */
	SIO_CLR((WB_SIO_MII_CLK|WB_SIO_MII_DATAIN));
	DELAY(1);
	SIO_SET(WB_SIO_MII_CLK);
	DELAY(1);

	/* Turn off xmit. */
	SIO_CLR(WB_SIO_MII_DIR);
	/* Check for ack */
	SIO_CLR(WB_SIO_MII_CLK);
	DELAY(1);
	ack = CSR_READ_4(sc, WB_SIO) & WB_SIO_MII_DATAOUT;
	SIO_SET(WB_SIO_MII_CLK);
	DELAY(1);
	SIO_CLR(WB_SIO_MII_CLK);
	DELAY(1);
	SIO_SET(WB_SIO_MII_CLK);
	DELAY(1);

	/*
	 * Now try reading data bits. If the ack failed, we still
	 * need to clock through 16 cycles to keep the PHY(s) in sync.
	 */
	if (ack) {
		for(i = 0; i < 16; i++) {
			SIO_CLR(WB_SIO_MII_CLK);
			DELAY(1);
			SIO_SET(WB_SIO_MII_CLK);
			DELAY(1);
		}
		goto fail;
	}

	for (i = 0x8000; i; i >>= 1) {
		SIO_CLR(WB_SIO_MII_CLK);
		DELAY(1);
		if (!ack) {
			if (CSR_READ_4(sc, WB_SIO) & WB_SIO_MII_DATAOUT)
				frame->mii_data |= i;
			DELAY(1);
		}
		SIO_SET(WB_SIO_MII_CLK);
		DELAY(1);
	}

fail:

	SIO_CLR(WB_SIO_MII_CLK);
	DELAY(1);
	SIO_SET(WB_SIO_MII_CLK);
	DELAY(1);

	splx(s);

	if (ack)
		return(1);
	return(0);
}

/*
 * Write to a PHY register through the MII.
 */
int wb_mii_writereg(sc, frame)
	struct wb_softc		*sc;
	struct wb_mii_frame	*frame;
	
{
	int			s;

	s = splnet();
	/*
	 * Set up frame for TX.
	 */

	frame->mii_stdelim = WB_MII_STARTDELIM;
	frame->mii_opcode = WB_MII_WRITEOP;
	frame->mii_turnaround = WB_MII_TURNAROUND;
	
	/*
 	 * Turn on data output.
	 */
	SIO_SET(WB_SIO_MII_DIR);

	wb_mii_sync(sc);

	wb_mii_send(sc, frame->mii_stdelim, 2);
	wb_mii_send(sc, frame->mii_opcode, 2);
	wb_mii_send(sc, frame->mii_phyaddr, 5);
	wb_mii_send(sc, frame->mii_regaddr, 5);
	wb_mii_send(sc, frame->mii_turnaround, 2);
	wb_mii_send(sc, frame->mii_data, 16);

	/* Idle bit. */
	SIO_SET(WB_SIO_MII_CLK);
	DELAY(1);
	SIO_CLR(WB_SIO_MII_CLK);
	DELAY(1);

	/*
	 * Turn off xmit.
	 */
	SIO_CLR(WB_SIO_MII_DIR);

	splx(s);

	return(0);
}

int
wb_miibus_readreg(dev, phy, reg)
	struct device *dev;
	int phy, reg;
{
	struct wb_softc *sc = (struct wb_softc *)dev;
	struct wb_mii_frame frame;

	bzero(&frame, sizeof(frame));

	frame.mii_phyaddr = phy;
	frame.mii_regaddr = reg;
	wb_mii_readreg(sc, &frame);

	return(frame.mii_data);
}

void
wb_miibus_writereg(dev, phy, reg, data)
	struct device *dev;
	int phy, reg, data;
{
	struct wb_softc *sc = (struct wb_softc *)dev;
	struct wb_mii_frame frame;

	bzero(&frame, sizeof(frame));

	frame.mii_phyaddr = phy;
	frame.mii_regaddr = reg;
	frame.mii_data = data;

	wb_mii_writereg(sc, &frame);

	return;
}

void
wb_miibus_statchg(dev)
	struct device *dev;
{
	struct wb_softc *sc = (struct wb_softc *)dev;

	wb_setcfg(sc, sc->sc_mii.mii_media_active);
}

/*
 * Program the 64-bit multicast hash filter.
 */
void wb_setmulti(sc)
	struct wb_softc		*sc;
{
	struct ifnet		*ifp;
	int			h = 0;
	u_int32_t		hashes[2] = { 0, 0 };
	struct arpcom		*ac = &sc->arpcom;
	struct ether_multi	*enm;
	struct ether_multistep	step;
	u_int32_t		rxfilt;
	int			mcnt = 0;

	ifp = &sc->arpcom.ac_if;

	rxfilt = CSR_READ_4(sc, WB_NETCFG);

	if (ac->ac_multirangecnt > 0)
		ifp->if_flags |= IFF_ALLMULTI;

	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
		rxfilt |= WB_NETCFG_RX_MULTI;
		CSR_WRITE_4(sc, WB_NETCFG, rxfilt);
		CSR_WRITE_4(sc, WB_MAR0, 0xFFFFFFFF);
		CSR_WRITE_4(sc, WB_MAR1, 0xFFFFFFFF);
		return;
	}

	/* first, zot all the existing hash bits */
	CSR_WRITE_4(sc, WB_MAR0, 0);
	CSR_WRITE_4(sc, WB_MAR1, 0);

	/* now program new ones */
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		h = ~(ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26);
		if (h < 32)
			hashes[0] |= (1 << h);
		else
			hashes[1] |= (1 << (h - 32));
		mcnt++;
		ETHER_NEXT_MULTI(step, enm);
	}

	if (mcnt)
		rxfilt |= WB_NETCFG_RX_MULTI;
	else
		rxfilt &= ~WB_NETCFG_RX_MULTI;

	CSR_WRITE_4(sc, WB_MAR0, hashes[0]);
	CSR_WRITE_4(sc, WB_MAR1, hashes[1]);
	CSR_WRITE_4(sc, WB_NETCFG, rxfilt);

	return;
}

/*
 * The Winbond manual states that in order to fiddle with the
 * 'full-duplex' and '100Mbps' bits in the netconfig register, we
 * first have to put the transmit and/or receive logic in the idle state.
 */
void
wb_setcfg(sc, media)
	struct wb_softc *sc;
	uint64_t media;
{
	int			i, restart = 0;

	if (CSR_READ_4(sc, WB_NETCFG) & (WB_NETCFG_TX_ON|WB_NETCFG_RX_ON)) {
		restart = 1;
		WB_CLRBIT(sc, WB_NETCFG, (WB_NETCFG_TX_ON|WB_NETCFG_RX_ON));

		for (i = 0; i < WB_TIMEOUT; i++) {
			DELAY(10);
			if ((CSR_READ_4(sc, WB_ISR) & WB_ISR_TX_IDLE) &&
				(CSR_READ_4(sc, WB_ISR) & WB_ISR_RX_IDLE))
				break;
		}

		if (i == WB_TIMEOUT)
			printf("%s: failed to force tx and "
				"rx to idle state\n", sc->sc_dev.dv_xname);
	}

	if (IFM_SUBTYPE(media) == IFM_10_T)
		WB_CLRBIT(sc, WB_NETCFG, WB_NETCFG_100MBPS);
	else
		WB_SETBIT(sc, WB_NETCFG, WB_NETCFG_100MBPS);

	if ((media & IFM_GMASK) == IFM_FDX)
		WB_SETBIT(sc, WB_NETCFG, WB_NETCFG_FULLDUPLEX);
	else
		WB_CLRBIT(sc, WB_NETCFG, WB_NETCFG_FULLDUPLEX);

	if (restart)
		WB_SETBIT(sc, WB_NETCFG, WB_NETCFG_TX_ON|WB_NETCFG_RX_ON);

	return;
}

void
wb_reset(sc)
	struct wb_softc *sc;
{
	int i;
	struct mii_data *mii = &sc->sc_mii;

	CSR_WRITE_4(sc, WB_NETCFG, 0);
	CSR_WRITE_4(sc, WB_BUSCTL, 0);
	CSR_WRITE_4(sc, WB_TXADDR, 0);
	CSR_WRITE_4(sc, WB_RXADDR, 0);

	WB_SETBIT(sc, WB_BUSCTL, WB_BUSCTL_RESET);
	WB_SETBIT(sc, WB_BUSCTL, WB_BUSCTL_RESET);

	for (i = 0; i < WB_TIMEOUT; i++) {
		DELAY(10);
		if (!(CSR_READ_4(sc, WB_BUSCTL) & WB_BUSCTL_RESET))
			break;
	}
	if (i == WB_TIMEOUT)
		printf("%s: reset never completed!\n", sc->sc_dev.dv_xname);

	/* Wait a little while for the chip to get its brains in order. */
	DELAY(1000);

	if (mii->mii_instance) {
		struct mii_softc *miisc;
		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
			mii_phy_reset(miisc);
	}
}

void
wb_fixmedia(sc)
	struct wb_softc *sc;
{
	struct mii_data *mii = &sc->sc_mii;
	uint64_t media;

	if (LIST_FIRST(&mii->mii_phys) == NULL)
		return;

	mii_pollstat(mii);
	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_10_T) {
		media = mii->mii_media_active & ~IFM_10_T;
		media |= IFM_100_TX;
	} if (IFM_SUBTYPE(mii->mii_media_active) == IFM_100_TX) {
		media = mii->mii_media_active & ~IFM_100_TX;
		media |= IFM_10_T;
	} else
		return;

	ifmedia_set(&mii->mii_media, media);
}

const struct pci_matchid wb_devices[] = {
	{ PCI_VENDOR_WINBOND, PCI_PRODUCT_WINBOND_W89C840F },
	{ PCI_VENDOR_COMPEX, PCI_PRODUCT_COMPEX_RL100ATX },
};

/*
 * Probe for a Winbond chip. Check the PCI vendor and device
 * IDs against our list and return a device name if we find a match.
 */
int
wb_probe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	return (pci_matchbyid((struct pci_attach_args *)aux, wb_devices,
	    nitems(wb_devices)));
}

/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
void
wb_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct wb_softc *sc = (struct wb_softc *)self;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	bus_size_t size;
	int rseg;
	bus_dma_segment_t seg;
	bus_dmamap_t dmamap;
	caddr_t kva;

	pci_set_powerstate(pa->pa_pc, pa->pa_tag, PCI_PMCSR_STATE_D0);

	/*
	 * Map control/status registers.
	 */

#ifdef WB_USEIOSPACE
	if (pci_mapreg_map(pa, WB_PCI_LOIO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->wb_btag, &sc->wb_bhandle, NULL, &size, 0)) {
		printf(": can't map i/o space\n");
		return;
	}
#else
	if (pci_mapreg_map(pa, WB_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->wb_btag, &sc->wb_bhandle, NULL, &size, 0)){
		printf(": can't map mem space\n");
		return;
	}
#endif

	/* Allocate interrupt */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		goto fail_1;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, wb_intr, sc,
	    self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail_1;
	}
	printf(": %s", intrstr);

	sc->wb_cachesize = pci_conf_read(pc, pa->pa_tag, WB_PCI_CACHELEN)&0xff;

	/* Reset the adapter. */
	wb_reset(sc);

	/*
	 * Get station address from the EEPROM.
	 */
	wb_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0, 3, 0);
	printf(", address %s\n", ether_sprintf(sc->arpcom.ac_enaddr));

	if (bus_dmamem_alloc(pa->pa_dmat, sizeof(struct wb_list_data),
	    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT | BUS_DMA_ZERO)) {
		printf(": can't alloc list data\n");
		goto fail_2;
	}
	if (bus_dmamem_map(pa->pa_dmat, &seg, rseg,
	    sizeof(struct wb_list_data), &kva, BUS_DMA_NOWAIT)) {
		printf(": can't map list data, size %zd\n",
		    sizeof(struct wb_list_data));
		goto fail_3;
	}
	if (bus_dmamap_create(pa->pa_dmat, sizeof(struct wb_list_data), 1,
	    sizeof(struct wb_list_data), 0, BUS_DMA_NOWAIT, &dmamap)) {
		printf(": can't create dma map\n");
		goto fail_4;
	}
	if (bus_dmamap_load(pa->pa_dmat, dmamap, kva,
	    sizeof(struct wb_list_data), NULL, BUS_DMA_NOWAIT)) {
		printf(": can't load dma map\n");
		goto fail_5;
	}
	sc->wb_ldata = (struct wb_list_data *)kva;

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = wb_ioctl;
	ifp->if_start = wb_start;
	ifp->if_watchdog = wb_watchdog;
	IFQ_SET_MAXLEN(&ifp->if_snd, WB_TX_LIST_CNT - 1);

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);

	/*
	 * Do ifmedia setup.
	 */
	wb_stop(sc);

	ifmedia_init(&sc->sc_mii.mii_media, 0, wb_ifmedia_upd, wb_ifmedia_sts);
	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = wb_miibus_readreg;
	sc->sc_mii.mii_writereg = wb_miibus_writereg;
	sc->sc_mii.mii_statchg = wb_miibus_statchg;
	mii_attach(self, &sc->sc_mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY,
	    0);
	if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE,0,NULL);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);
	} else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);
	return;

fail_5:
	bus_dmamap_destroy(pa->pa_dmat, dmamap);

fail_4:
	bus_dmamem_unmap(pa->pa_dmat, kva,
	    sizeof(struct wb_list_data));

fail_3:
	bus_dmamem_free(pa->pa_dmat, &seg, rseg);

fail_2:
	pci_intr_disestablish(pc, sc->sc_ih);

fail_1:
	bus_space_unmap(sc->wb_btag, sc->wb_bhandle, size);
}

/*
 * Initialize the transmit descriptors.
 */
int wb_list_tx_init(sc)
	struct wb_softc		*sc;
{
	struct wb_chain_data	*cd;
	struct wb_list_data	*ld;
	int			i;

	cd = &sc->wb_cdata;
	ld = sc->wb_ldata;

	for (i = 0; i < WB_TX_LIST_CNT; i++) {
		cd->wb_tx_chain[i].wb_ptr = &ld->wb_tx_list[i];
		if (i == (WB_TX_LIST_CNT - 1)) {
			cd->wb_tx_chain[i].wb_nextdesc =
				&cd->wb_tx_chain[0];
		} else {
			cd->wb_tx_chain[i].wb_nextdesc =
				&cd->wb_tx_chain[i + 1];
		}
	}

	cd->wb_tx_free = &cd->wb_tx_chain[0];
	cd->wb_tx_tail = cd->wb_tx_head = NULL;

	return(0);
}


/*
 * Initialize the RX descriptors and allocate mbufs for them. Note that
 * we arrange the descriptors in a closed ring, so that the last descriptor
 * points back to the first.
 */
int wb_list_rx_init(sc)
	struct wb_softc		*sc;
{
	struct wb_chain_data	*cd;
	struct wb_list_data	*ld;
	int			i;

	cd = &sc->wb_cdata;
	ld = sc->wb_ldata;

	for (i = 0; i < WB_RX_LIST_CNT; i++) {
		cd->wb_rx_chain[i].wb_ptr =
			(struct wb_desc *)&ld->wb_rx_list[i];
		cd->wb_rx_chain[i].wb_buf = (void *)&ld->wb_rxbufs[i];
		wb_newbuf(sc, &cd->wb_rx_chain[i]);
		if (i == (WB_RX_LIST_CNT - 1)) {
			cd->wb_rx_chain[i].wb_nextdesc = &cd->wb_rx_chain[0];
			ld->wb_rx_list[i].wb_next = 
					VTOPHYS(&ld->wb_rx_list[0]);
		} else {
			cd->wb_rx_chain[i].wb_nextdesc =
					&cd->wb_rx_chain[i + 1];
			ld->wb_rx_list[i].wb_next =
					VTOPHYS(&ld->wb_rx_list[i + 1]);
		}
	}

	cd->wb_rx_head = &cd->wb_rx_chain[0];

	return(0);
}

/*
 * Initialize an RX descriptor and attach an MBUF cluster.
 */
void
wb_newbuf(sc, c)
	struct wb_softc *sc;
	struct wb_chain_onefrag *c;
{
	c->wb_ptr->wb_data = VTOPHYS(c->wb_buf + sizeof(u_int64_t));
	c->wb_ptr->wb_ctl = WB_RXCTL_RLINK | ETHER_MAX_DIX_LEN;
	c->wb_ptr->wb_status = WB_RXSTAT;
}

/*
 * A frame has been uploaded: pass the resulting mbuf chain up to
 * the higher level protocols.
 */
void wb_rxeof(sc)
	struct wb_softc		*sc;
{
	struct mbuf_list	ml = MBUF_LIST_INITIALIZER();
        struct ifnet		*ifp;
	struct wb_chain_onefrag	*cur_rx;
	int			total_len = 0;
	u_int32_t		rxstat;

	ifp = &sc->arpcom.ac_if;

	while(!((rxstat = sc->wb_cdata.wb_rx_head->wb_ptr->wb_status) &
							WB_RXSTAT_OWN)) {
		struct mbuf *m;

		cur_rx = sc->wb_cdata.wb_rx_head;
		sc->wb_cdata.wb_rx_head = cur_rx->wb_nextdesc;

		if ((rxstat & WB_RXSTAT_MIIERR) ||
		    (WB_RXBYTES(cur_rx->wb_ptr->wb_status) < WB_MIN_FRAMELEN) ||
		    (WB_RXBYTES(cur_rx->wb_ptr->wb_status) > ETHER_MAX_DIX_LEN) ||
		    !(rxstat & WB_RXSTAT_LASTFRAG) ||
		    !(rxstat & WB_RXSTAT_RXCMP)) {
			ifp->if_ierrors++;
			wb_newbuf(sc, cur_rx);
			printf("%s: receiver babbling: possible chip "
				"bug, forcing reset\n", sc->sc_dev.dv_xname);
			wb_fixmedia(sc);
			wb_init(sc);
			break;
		}

		if (rxstat & WB_RXSTAT_RXERR) {
			ifp->if_ierrors++;
			wb_newbuf(sc, cur_rx);
			break;
		}

		/* No errors; receive the packet. */	
		total_len = WB_RXBYTES(cur_rx->wb_ptr->wb_status);

		/*
		 * XXX The Winbond chip includes the CRC with every
		 * received frame, and there's no way to turn this
		 * behavior off (at least, I can't find anything in
	 	 * the manual that explains how to do it) so we have
		 * to trim off the CRC manually.
		 */
		total_len -= ETHER_CRC_LEN;

		m = m_devget(cur_rx->wb_buf + sizeof(u_int64_t), total_len,
		    ETHER_ALIGN);
		wb_newbuf(sc, cur_rx);
		if (m == NULL) {
			ifp->if_ierrors++;
			break;
		}

		ml_enqueue(&ml, m);
	}

	if_input(ifp, &ml);
}

void wb_rxeoc(sc)
	struct wb_softc		*sc;
{
	wb_rxeof(sc);

	WB_CLRBIT(sc, WB_NETCFG, WB_NETCFG_RX_ON);
	CSR_WRITE_4(sc, WB_RXADDR, VTOPHYS(&sc->wb_ldata->wb_rx_list[0]));
	WB_SETBIT(sc, WB_NETCFG, WB_NETCFG_RX_ON);
	if (CSR_READ_4(sc, WB_ISR) & WB_RXSTATE_SUSPEND)
		CSR_WRITE_4(sc, WB_RXSTART, 0xFFFFFFFF);

	return;
}

/*
 * A frame was downloaded to the chip. It's safe for us to clean up
 * the list buffers.
 */
void wb_txeof(sc)
	struct wb_softc		*sc;
{
	struct wb_chain		*cur_tx;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	/* Clear the timeout timer. */
	ifp->if_timer = 0;

	if (sc->wb_cdata.wb_tx_head == NULL)
		return;

	/*
	 * Go through our tx list and free mbufs for those
	 * frames that have been transmitted.
	 */
	while(sc->wb_cdata.wb_tx_head->wb_mbuf != NULL) {
		u_int32_t		txstat;

		cur_tx = sc->wb_cdata.wb_tx_head;
		txstat = WB_TXSTATUS(cur_tx);

		if ((txstat & WB_TXSTAT_OWN) || txstat == WB_UNSENT)
			break;

		if (txstat & WB_TXSTAT_TXERR) {
			ifp->if_oerrors++;
			if (txstat & WB_TXSTAT_ABORT)
				ifp->if_collisions++;
			if (txstat & WB_TXSTAT_LATECOLL)
				ifp->if_collisions++;
		}

		ifp->if_collisions += (txstat & WB_TXSTAT_COLLCNT) >> 3;

		m_freem(cur_tx->wb_mbuf);
		cur_tx->wb_mbuf = NULL;

		if (sc->wb_cdata.wb_tx_head == sc->wb_cdata.wb_tx_tail) {
			sc->wb_cdata.wb_tx_head = NULL;
			sc->wb_cdata.wb_tx_tail = NULL;
			break;
		}

		sc->wb_cdata.wb_tx_head = cur_tx->wb_nextdesc;
	}

	return;
}

/*
 * TX 'end of channel' interrupt handler.
 */
void wb_txeoc(sc)
	struct wb_softc		*sc;
{
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	ifp->if_timer = 0;

	if (sc->wb_cdata.wb_tx_head == NULL) {
		ifq_clr_oactive(&ifp->if_snd);
		sc->wb_cdata.wb_tx_tail = NULL;
	} else {
		if (WB_TXOWN(sc->wb_cdata.wb_tx_head) == WB_UNSENT) {
			WB_TXOWN(sc->wb_cdata.wb_tx_head) = WB_TXSTAT_OWN;
			ifp->if_timer = 5;
			CSR_WRITE_4(sc, WB_TXSTART, 0xFFFFFFFF);
		}
	}

	return;
}

int wb_intr(arg)
	void			*arg;
{
	struct wb_softc		*sc;
	struct ifnet		*ifp;
	u_int32_t		status;
	int			r = 0;

	sc = arg;
	ifp = &sc->arpcom.ac_if;

	if (!(ifp->if_flags & IFF_UP))
		return (r);

	/* Disable interrupts. */
	CSR_WRITE_4(sc, WB_IMR, 0x00000000);

	for (;;) {

		status = CSR_READ_4(sc, WB_ISR);
		if (status)
			CSR_WRITE_4(sc, WB_ISR, status);

		if ((status & WB_INTRS) == 0)
			break;

		r = 1;

		if ((status & WB_ISR_RX_NOBUF) || (status & WB_ISR_RX_ERR)) {
			ifp->if_ierrors++;
			wb_reset(sc);
			if (status & WB_ISR_RX_ERR)
				wb_fixmedia(sc);
			wb_init(sc);
			continue;
		}

		if (status & WB_ISR_RX_OK)
			wb_rxeof(sc);

		if (status & WB_ISR_RX_IDLE)
			wb_rxeoc(sc);

		if (status & WB_ISR_TX_OK)
			wb_txeof(sc);

		if (status & WB_ISR_TX_NOBUF)
			wb_txeoc(sc);

		if (status & WB_ISR_TX_IDLE) {
			wb_txeof(sc);
			if (sc->wb_cdata.wb_tx_head != NULL) {
				WB_SETBIT(sc, WB_NETCFG, WB_NETCFG_TX_ON);
				CSR_WRITE_4(sc, WB_TXSTART, 0xFFFFFFFF);
			}
		}

		if (status & WB_ISR_TX_UNDERRUN) {
			ifp->if_oerrors++;
			wb_txeof(sc);
			WB_CLRBIT(sc, WB_NETCFG, WB_NETCFG_TX_ON);
			/* Jack up TX threshold */
			sc->wb_txthresh += WB_TXTHRESH_CHUNK;
			WB_CLRBIT(sc, WB_NETCFG, WB_NETCFG_TX_THRESH);
			WB_SETBIT(sc, WB_NETCFG, WB_TXTHRESH(sc->wb_txthresh));
			WB_SETBIT(sc, WB_NETCFG, WB_NETCFG_TX_ON);
		}

		if (status & WB_ISR_BUS_ERR)
			wb_init(sc);
	}

	/* Re-enable interrupts. */
	CSR_WRITE_4(sc, WB_IMR, WB_INTRS);

	if (!IFQ_IS_EMPTY(&ifp->if_snd)) {
		wb_start(ifp);
	}

	return (r);
}

void
wb_tick(xsc)
	void *xsc;
{
	struct wb_softc *sc = xsc;
	int s;

	s = splnet();
	mii_tick(&sc->sc_mii);
	splx(s);
	timeout_add_sec(&sc->wb_tick_tmo, 1);
}

/*
 * Encapsulate an mbuf chain in a descriptor by coupling the mbuf data
 * pointers to the fragment pointers.
 */
int wb_encap(sc, c, m_head)
	struct wb_softc		*sc;
	struct wb_chain		*c;
	struct mbuf		*m_head;
{
	int			frag = 0;
	struct wb_desc		*f = NULL;
	int			total_len;
	struct mbuf		*m;

	/*
 	 * Start packing the mbufs in this chain into
	 * the fragment pointers. Stop when we run out
 	 * of fragments or hit the end of the mbuf chain.
	 */
	m = m_head;
	total_len = 0;

	for (m = m_head, frag = 0; m != NULL; m = m->m_next) {
		if (m->m_len != 0) {
			if (frag == WB_MAXFRAGS)
				break;
			total_len += m->m_len;
			f = &c->wb_ptr->wb_frag[frag];
			f->wb_ctl = WB_TXCTL_TLINK | m->m_len;
			if (frag == 0) {
				f->wb_ctl |= WB_TXCTL_FIRSTFRAG;
				f->wb_status = 0;
			} else
				f->wb_status = WB_TXSTAT_OWN;
			f->wb_next = VTOPHYS(&c->wb_ptr->wb_frag[frag + 1]);
			f->wb_data = VTOPHYS(mtod(m, vaddr_t));
			frag++;
		}
	}

	/*
	 * Handle special case: we used up all 16 fragments,
	 * but we have more mbufs left in the chain. Copy the
	 * data into an mbuf cluster. Note that we don't
	 * bother clearing the values in the other fragment
	 * pointers/counters; it wouldn't gain us anything,
	 * and would waste cycles.
	 */
	if (m != NULL) {
		struct mbuf		*m_new = NULL;

		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return(1);
		if (m_head->m_pkthdr.len > MHLEN) {
			MCLGET(m_new, M_DONTWAIT);
			if (!(m_new->m_flags & M_EXT)) {
				m_freem(m_new);
				return(1);
			}
		}
		m_copydata(m_head, 0, m_head->m_pkthdr.len,	
					mtod(m_new, caddr_t));
		m_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;
		m_freem(m_head);
		m_head = m_new;
		f = &c->wb_ptr->wb_frag[0];
		f->wb_status = 0;
		f->wb_data = VTOPHYS(mtod(m_new, caddr_t));
		f->wb_ctl = total_len = m_new->m_len;
		f->wb_ctl |= WB_TXCTL_TLINK|WB_TXCTL_FIRSTFRAG;
		frag = 1;
	}

	if (total_len < WB_MIN_FRAMELEN) {
		f = &c->wb_ptr->wb_frag[frag];
		f->wb_ctl = WB_MIN_FRAMELEN - total_len;
		f->wb_data = VTOPHYS(&sc->wb_cdata.wb_pad);
		f->wb_ctl |= WB_TXCTL_TLINK;
		f->wb_status = WB_TXSTAT_OWN;
		frag++;
	}

	c->wb_mbuf = m_head;
	c->wb_lastdesc = frag - 1;
	WB_TXCTL(c) |= WB_TXCTL_LASTFRAG;
	WB_TXNEXT(c) = VTOPHYS(&c->wb_nextdesc->wb_ptr->wb_frag[0]);

	return(0);
}

/*
 * Main transmit routine. To avoid having to do mbuf copies, we put pointers
 * to the mbuf data regions directly in the transmit lists. We also save a
 * copy of the pointers since the transmit list fragment pointers are
 * physical addresses.
 */

void wb_start(ifp)
	struct ifnet		*ifp;
{
	struct wb_softc		*sc;
	struct mbuf		*m_head = NULL;
	struct wb_chain		*cur_tx = NULL, *start_tx;

	sc = ifp->if_softc;

	/*
	 * Check for an available queue slot. If there are none,
	 * punt.
	 */
	if (sc->wb_cdata.wb_tx_free->wb_mbuf != NULL) {
		ifq_set_oactive(&ifp->if_snd);
		return;
	}

	start_tx = sc->wb_cdata.wb_tx_free;

	while(sc->wb_cdata.wb_tx_free->wb_mbuf == NULL) {
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
		if (m_head == NULL)
			break;

		/* Pick a descriptor off the free list. */
		cur_tx = sc->wb_cdata.wb_tx_free;
		sc->wb_cdata.wb_tx_free = cur_tx->wb_nextdesc;

		/* Pack the data into the descriptor. */
		wb_encap(sc, cur_tx, m_head);

		if (cur_tx != start_tx)
			WB_TXOWN(cur_tx) = WB_TXSTAT_OWN;

#if NBPFILTER > 0
		/*
		 * If there's a BPF listener, bounce a copy of this frame
		 * to him.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, cur_tx->wb_mbuf,
			    BPF_DIRECTION_OUT);
#endif
	}

	/*
	 * If there are no packets queued, bail.
	 */
	if (cur_tx == NULL)
		return;

	/*
	 * Place the request for the upload interrupt
	 * in the last descriptor in the chain. This way, if
	 * we're chaining several packets at once, we'll only
	 * get an interrupt once for the whole chain rather than
	 * once for each packet.
	 */
	WB_TXCTL(cur_tx) |= WB_TXCTL_FINT;
	cur_tx->wb_ptr->wb_frag[0].wb_ctl |= WB_TXCTL_FINT;
	sc->wb_cdata.wb_tx_tail = cur_tx;

	if (sc->wb_cdata.wb_tx_head == NULL) {
		sc->wb_cdata.wb_tx_head = start_tx;
		WB_TXOWN(start_tx) = WB_TXSTAT_OWN;
		CSR_WRITE_4(sc, WB_TXSTART, 0xFFFFFFFF);
	} else {
		/*
		 * We need to distinguish between the case where
		 * the own bit is clear because the chip cleared it
		 * and where the own bit is clear because we haven't
		 * set it yet. The magic value WB_UNSET is just some
		 * ramdomly chosen number which doesn't have the own
	 	 * bit set. When we actually transmit the frame, the
		 * status word will have _only_ the own bit set, so
		 * the txeoc handler will be able to tell if it needs
		 * to initiate another transmission to flush out pending
		 * frames.
		 */
		WB_TXOWN(start_tx) = WB_UNSENT;
	}

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;

	return;
}

void wb_init(xsc)
	void			*xsc;
{
	struct wb_softc *sc = xsc;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	int s, i;

	s = splnet();

	/*
	 * Cancel pending I/O and free all RX/TX buffers.
	 */
	wb_stop(sc);
	wb_reset(sc);

	sc->wb_txthresh = WB_TXTHRESH_INIT;

	/*
	 * Set cache alignment and burst length.
	 */
#ifdef foo
	CSR_WRITE_4(sc, WB_BUSCTL, WB_BUSCTL_CONFIG);
	WB_CLRBIT(sc, WB_NETCFG, WB_NETCFG_TX_THRESH);
	WB_SETBIT(sc, WB_NETCFG, WB_TXTHRESH(sc->wb_txthresh));
#endif

	CSR_WRITE_4(sc, WB_BUSCTL, WB_BUSCTL_MUSTBEONE|WB_BUSCTL_ARBITRATION);
	WB_SETBIT(sc, WB_BUSCTL, WB_BURSTLEN_16LONG);
	switch(sc->wb_cachesize) {
	case 32:
		WB_SETBIT(sc, WB_BUSCTL, WB_CACHEALIGN_32LONG);
		break;
	case 16:
		WB_SETBIT(sc, WB_BUSCTL, WB_CACHEALIGN_16LONG);
		break;
	case 8:
		WB_SETBIT(sc, WB_BUSCTL, WB_CACHEALIGN_8LONG);
		break;
	case 0:
	default:
		WB_SETBIT(sc, WB_BUSCTL, WB_CACHEALIGN_NONE);
		break;
	}

	/* This doesn't tend to work too well at 100Mbps. */
	WB_CLRBIT(sc, WB_NETCFG, WB_NETCFG_TX_EARLY_ON);

	/* Init our MAC address */
	for (i = 0; i < ETHER_ADDR_LEN; i++) {
		CSR_WRITE_1(sc, WB_NODE0 + i, sc->arpcom.ac_enaddr[i]);
	}

	/* Init circular RX list. */
	if (wb_list_rx_init(sc) == ENOBUFS) {
		printf("%s: initialization failed: no "
			"memory for rx buffers\n", sc->sc_dev.dv_xname);
		wb_stop(sc);
		splx(s);
		return;
	}

	/* Init TX descriptors. */
	wb_list_tx_init(sc);

	/* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC) {
		WB_SETBIT(sc, WB_NETCFG, WB_NETCFG_RX_ALLPHYS);
	} else {
		WB_CLRBIT(sc, WB_NETCFG, WB_NETCFG_RX_ALLPHYS);
	}

	/*
	 * Set capture broadcast bit to capture broadcast frames.
	 */
	if (ifp->if_flags & IFF_BROADCAST) {
		WB_SETBIT(sc, WB_NETCFG, WB_NETCFG_RX_BROAD);
	} else {
		WB_CLRBIT(sc, WB_NETCFG, WB_NETCFG_RX_BROAD);
	}

	/*
	 * Program the multicast filter, if necessary.
	 */
	wb_setmulti(sc);

	/*
	 * Load the address of the RX list.
	 */
	WB_CLRBIT(sc, WB_NETCFG, WB_NETCFG_RX_ON);
	CSR_WRITE_4(sc, WB_RXADDR, VTOPHYS(&sc->wb_ldata->wb_rx_list[0]));

	/*
	 * Enable interrupts.
	 */
	CSR_WRITE_4(sc, WB_IMR, WB_INTRS);
	CSR_WRITE_4(sc, WB_ISR, 0xFFFFFFFF);

	/* Enable receiver and transmitter. */
	WB_SETBIT(sc, WB_NETCFG, WB_NETCFG_RX_ON);
	CSR_WRITE_4(sc, WB_RXSTART, 0xFFFFFFFF);

	WB_CLRBIT(sc, WB_NETCFG, WB_NETCFG_TX_ON);
	CSR_WRITE_4(sc, WB_TXADDR, VTOPHYS(&sc->wb_ldata->wb_tx_list[0]));
	WB_SETBIT(sc, WB_NETCFG, WB_NETCFG_TX_ON);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);

	timeout_set(&sc->wb_tick_tmo, wb_tick, sc);
	timeout_add_sec(&sc->wb_tick_tmo, 1);

	return;
}

/*
 * Set media options.
 */
int
wb_ifmedia_upd(ifp)
	struct ifnet *ifp;
{
	struct wb_softc *sc = ifp->if_softc;

	if (ifp->if_flags & IFF_UP)
		wb_init(sc);

	return(0);
}

/*
 * Report current media status.
 */
void
wb_ifmedia_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
{
	struct wb_softc *sc = ifp->if_softc;
	struct mii_data *mii = &sc->sc_mii;

	mii_pollstat(mii);
	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;
}

int wb_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
{
	struct wb_softc		*sc = ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *) data;
	int			s, error = 0;

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		wb_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			wb_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				wb_stop(sc);
		}
		error = 0;
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, command);
		break;

	default:
		error = ether_ioctl(ifp, &sc->arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			wb_setmulti(sc);
		error = 0;
	}

	splx(s);
	return(error);
}

void wb_watchdog(ifp)
	struct ifnet		*ifp;
{
	struct wb_softc		*sc;

	sc = ifp->if_softc;

	ifp->if_oerrors++;
	printf("%s: watchdog timeout\n", sc->sc_dev.dv_xname);

#ifdef foo
	if (!(wb_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_LINKSTAT))
		printf("%s: no carrier - transceiver cable problem?\n",
		    sc->sc_dev.dv_xname);
#endif
	wb_init(sc);

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		wb_start(ifp);

	return;
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void wb_stop(sc)
	struct wb_softc		*sc;
{
	int			i;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;
	ifp->if_timer = 0;

	timeout_del(&sc->wb_tick_tmo);

	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	WB_CLRBIT(sc, WB_NETCFG, (WB_NETCFG_RX_ON|WB_NETCFG_TX_ON));
	CSR_WRITE_4(sc, WB_IMR, 0x00000000);
	CSR_WRITE_4(sc, WB_TXADDR, 0x00000000);
	CSR_WRITE_4(sc, WB_RXADDR, 0x00000000);

	/*
	 * Free data in the RX lists.
	 */
	bzero(&sc->wb_ldata->wb_rx_list, sizeof(sc->wb_ldata->wb_rx_list));

	/*
	 * Free the TX list buffers.
	 */
	for (i = 0; i < WB_TX_LIST_CNT; i++) {
		if (sc->wb_cdata.wb_tx_chain[i].wb_mbuf != NULL) {
			m_freem(sc->wb_cdata.wb_tx_chain[i].wb_mbuf);
			sc->wb_cdata.wb_tx_chain[i].wb_mbuf = NULL;
		}
	}

	bzero(&sc->wb_ldata->wb_tx_list, sizeof(sc->wb_ldata->wb_tx_list));
}

struct cfattach wb_ca = {
	sizeof(struct wb_softc), wb_probe, wb_attach
};

struct cfdriver wb_cd = {
	NULL, "wb", DV_IFNET
};
@


1.68
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.67 2016/04/13 10:34:32 mpi Exp $	*/
a156 1
u_int8_t wb_calchash(caddr_t);
@


1.67
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.66 2015/11/25 03:09:59 dlg Exp $	*/
a1037 1
		ifp->if_opackets++;
@


1.66
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.65 2015/11/24 17:11:39 mpi Exp $	*/
a788 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.65
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.64 2015/11/24 13:33:17 mpi Exp $	*/
d1068 1
a1068 1
		ifp->if_flags &= ~IFF_OACTIVE;
d1288 1
a1288 1
		ifp->if_flags |= IFF_OACTIVE;
d1471 1
a1471 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1596 2
a1597 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.64
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.63 2015/10/25 13:04:28 mpi Exp $	*/
a101 1
#include <net/if_dl.h>
@


1.63
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.62 2015/09/11 13:02:28 stsp Exp $	*/
a102 1
#include <net/if_types.h>
@


1.62
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.61 2015/06/24 09:40:54 mpi Exp $	*/
a1519 1
	struct ifaddr		*ifa = (struct ifaddr *) data;
d1528 1
a1528 8
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			wb_init(sc);
			arp_ifinit(&sc->arpcom, ifa);
			break;
		default:
			wb_init(sc);
		}
@


1.61
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.60 2015/04/13 08:45:48 mpi Exp $	*/
d158 1
a158 1
void wb_setcfg(struct wb_softc *, u_int32_t);
d583 1
a583 1
	u_int32_t media;
d657 1
a657 1
	u_int32_t media;
@


1.60
log
@Now that if_input() set the receiving interface pointer on mbufs for us
there's no need to do it in m_devget(9).

Stop passing an ``ifp'' will help for upcoming interface pointer -> index
conversion.

While here remove unused ``ifp'' argument from m_clget(9) and kill two
birds^W layer violations in one commit.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.59 2015/04/08 10:07:47 mpi Exp $	*/
a978 2

		ifp->if_ipackets++;
@


1.59
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.58 2014/12/22 02:28:52 tedu Exp $	*/
d973 1
a973 1
		    ETHER_ALIGN, ifp);
@


1.58
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.57 2014/12/03 09:10:17 brad Exp $	*/
d925 1
d951 1
a951 1
			return;
d982 1
a982 9
#if NBPFILTER > 0
		/*
		 * Handle BPF listeners. Let the BPF user see the packet.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
		/* pass it on. */
		ether_input_mbuf(ifp, m);
d985 1
a985 1
	return;
@


1.57
log
@wb_init() calls wb_stop() and wb_reset() so remove some redundant calls
to those functions before wb_init() within wb_watchdog() / wb_intr() and
wb_rxeof().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.56 2014/07/22 13:12:11 mpi Exp $	*/
a104 1
#ifdef INET
a106 1
#endif
a1538 1
#ifdef INET
a1542 1
#endif /* INET */
@


1.56
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.55 2013/11/26 09:50:33 mpi Exp $	*/
a950 1
			wb_reset(sc);
d1162 1
a1162 2
		if (status & WB_ISR_BUS_ERR) {
			wb_reset(sc);
a1163 2
		}

a1595 2
	wb_stop(sc);
	wb_reset(sc);
@


1.55
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.54 2013/10/01 20:06:02 sf Exp $	*/
a106 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.54
log
@Use %z* for size_t

while there, fix a few %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.53 2013/08/21 05:21:45 dlg Exp $	*/
d540 3
a542 1
allmulti:
a557 4
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}
@


1.53
log
@get rid of the copy argument in m_devget that let you provide an
alternative to bcopy since noone uses it.

while there use memcpy instead of bcopy because we know the memory cannot
overlap.

ok henning@@ matthew@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.52 2013/08/07 01:06:39 bluhm Exp $	*/
d775 1
a775 1
		printf(": can't map list data, size %d\n",
@


1.52
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.51 2012/11/29 21:10:32 brad Exp $	*/
d979 1
a979 1
		    ETHER_ALIGN, ifp, NULL);
@


1.51
log
@Remove setting an initial assumed baudrate upon driver attach which is not
necessarily correct, there might not even be a link when attaching.

ok mikeb@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.50 2012/11/23 18:40:30 gsoares Exp $	*/
a107 1
#include <netinet/in_var.h>
@


1.50
log
@set ifp->if_baudrate with IF_Gbps() / IF_Mbps().

OK reyk@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.49 2012/10/18 21:44:21 deraadt Exp $	*/
a796 1
	ifp->if_baudrate = IF_Mbps(10);
@


1.49
log
@Convert a number of old private copies of code which predates
pci_set_powerstate() to using it instead.  Many of these chunks of code had
bugs in them, especially missing delay() calls.  Some of them were doing
things our PCI subsystem is now responsible for handling.  If you have
any of the affected devices, please keep an eye out for regressions.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.48 2011/06/22 16:44:29 tedu Exp $	*/
d797 1
a797 1
	ifp->if_baudrate = 10000000;
@


1.48
log
@kill a few more casts that aren't helpful.  ok krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.47 2011/04/03 15:36:03 jasper Exp $	*/
a716 1
	pcireg_t command;
d721 1
a721 30
	/*
	 * Handle power management nonsense.
	 */

	command = pci_conf_read(pc, pa->pa_tag, WB_PCI_CAPID) & 0x000000FF;
	if (command == 0x01) {

		command = pci_conf_read(pc, pa->pa_tag, WB_PCI_PWRMGMTCTRL);
		if (command & WB_PSTATE_MASK) {
			u_int32_t		io, mem, irq;

			/* Save important PCI config data. */
			io = pci_conf_read(pc, pa->pa_tag, WB_PCI_LOIO);
			mem = pci_conf_read(pc, pa->pa_tag, WB_PCI_LOMEM);
			irq = pci_conf_read(pc, pa->pa_tag, WB_PCI_INTLINE);

			/* Reset the power state. */
			printf("%s: chip is in D%d power mode "
			    "-- setting to D0\n", sc->sc_dev.dv_xname,
			    command & WB_PSTATE_MASK);
			command &= 0xFFFFFFFC;
			pci_conf_write(pc, pa->pa_tag, WB_PCI_PWRMGMTCTRL,
			    command);

			/* Restore PCI config data. */
			pci_conf_write(pc, pa->pa_tag, WB_PCI_LOIO, io);
			pci_conf_write(pc, pa->pa_tag, WB_PCI_LOMEM, mem);
			pci_conf_write(pc, pa->pa_tag, WB_PCI_INTLINE, irq);
		}
	}
@


1.47
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.46 2010/05/19 15:27:35 oga Exp $	*/
d485 1
a485 1
	bzero((char *)&frame, sizeof(frame));
d502 1
a502 1
	bzero((char *)&frame, sizeof(frame));
d1671 1
a1671 2
	bzero((char *)&sc->wb_ldata->wb_rx_list,
		sizeof(sc->wb_ldata->wb_rx_list));
d1683 1
a1683 2
	bzero((char *)&sc->wb_ldata->wb_tx_list,
		sizeof(sc->wb_ldata->wb_tx_list));
@


1.46
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.45 2009/08/13 14:24:47 jasper Exp $	*/
d697 1
a697 1
	    sizeof(wb_devices)/sizeof(wb_devices[0])));
@


1.45
log
@- consistify cfdriver for the ethernet drivers (0 -> NULL)

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.44 2009/08/10 19:41:05 deraadt Exp $	*/
d800 1
a800 1
	    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
a820 1
	bzero(sc->wb_ldata, sizeof(struct wb_list_data));
@


1.44
log
@A few more simple cases of shutdown hooks which only call xxstop, when
we now know the interface has already been stopped
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.43 2008/11/28 02:44:18 brad Exp $	*/
d1694 1
a1694 1
	0, "wb", DV_IFNET
@


1.43
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.42 2008/11/25 11:01:35 claudio Exp $	*/
a151 1
void wb_shutdown(void *);
a856 2

	shutdownhook_establish(wb_shutdown, sc);
a1686 14
}

/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
void wb_shutdown(arg)
	void			*arg;
{
	struct wb_softc		*sc = (struct wb_softc *)arg;

	wb_stop(sc);

	return;
@


1.42
log
@Switch wb(4) from the insane ext buffer usage to a very simple m_devget()
call to copy the packet from the RX DMA ring to build a mbuf (it almost
already did that but way more complex).
OK brad@@ dlg@@ thib@@
Tested by Tero Koskinen tero.koskinen (at) iki (dot) fi on a wb(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.41 2008/10/14 18:01:53 naddy Exp $	*/
d1575 1
a1576 1
	struct ifaddr		*ifa = (struct ifaddr *)data;
d1595 1
d1605 1
a1605 16
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				wb_setmulti(sc);
			error = 0;
		}
		break;
d1610 1
d1613 6
@


1.41
log
@Change m_devget()'s outdated and unused "offset" argument:  It is
now the offset into the first mbuf of the target chain before copying
the source data over.  From FreeBSD.

Convert drivers' use of m_devget().  Mostly from thib@@.

Update mbuf(9) man page.

ok claudio@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.40 2008/10/02 20:21:14 brad Exp $	*/
d138 2
a139 4
int wb_newbuf(struct wb_softc *, struct wb_chain_onefrag *,
    struct mbuf *);
int wb_encap(struct wb_softc *, struct wb_chain *,
    struct mbuf *);
d929 1
a929 2
		if (wb_newbuf(sc, &cd->wb_rx_chain[i], NULL) == ENOBUFS)
			return(ENOBUFS);
a946 8
void
wb_bfree(buf, size, arg)
	caddr_t			buf;
	u_int			size;
	void *arg;
{
}

d950 2
a951 2
int
wb_newbuf(sc, c, m)
a953 1
	struct mbuf *m;
d955 1
a955 23
	struct mbuf		*m_new = NULL;

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return(ENOBUFS);
		m_new->m_data = m_new->m_ext.ext_buf = c->wb_buf;
		m_new->m_flags |= M_EXT;
		m_new->m_ext.ext_size = m_new->m_pkthdr.len =
		    m_new->m_len = WB_BUFBYTES;
		m_new->m_ext.ext_free = wb_bfree;
		m_new->m_ext.ext_arg = NULL;
		MCLINITREFERENCE(m_new);
	} else {
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = WB_BUFBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
	}

	m_adj(m_new, sizeof(u_int64_t));

	c->wb_mbuf = m_new;
	c->wb_ptr->wb_data = VTOPHYS(mtod(m_new, caddr_t));
a957 2

	return(0);
a966 1
        struct mbuf		*m = NULL;
d976 1
a976 1
		struct mbuf *m0 = NULL;
a980 2
		m = cur_rx->wb_mbuf;

d987 1
a987 1
			wb_newbuf(sc, cur_rx, m);
d998 1
a998 1
			wb_newbuf(sc, cur_rx, m);
d1014 4
a1017 4
		m0 = m_devget(mtod(m, char *), total_len, ETHER_ALIGN,
		    ifp, NULL);
		wb_newbuf(sc, cur_rx, m);
		if (m0 == NULL) {
a1020 1
		m = m0;
a1681 6
	for (i = 0; i < WB_RX_LIST_CNT; i++) {
		if (sc->wb_cdata.wb_rx_chain[i].wb_mbuf != NULL) {
			m_freem(sc->wb_cdata.wb_rx_chain[i].wb_mbuf);
			sc->wb_cdata.wb_rx_chain[i].wb_mbuf = NULL;
		}
	}
@


1.40
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.39 2008/09/10 14:01:23 blambert Exp $	*/
d1053 2
a1054 2
		m0 = m_devget(mtod(m, char *) - ETHER_ALIGN,
		    total_len + ETHER_ALIGN, 0, ifp, NULL);
a1059 1
		m_adj(m0, ETHER_ALIGN);
@


1.39
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.38 2007/05/26 00:36:03 krw Exp $	*/
a1621 5
	if ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {
		splx(s);
		return (error);
	}

d1666 1
a1666 2
		error = ENOTTY;
		break;
a1669 1

@


1.38
log
@More comment typos from Diego Casati. Including winners like funtion, allmost,
oustside, seqencer, toghether, nessissary, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.37 2007/05/25 21:27:15 krw Exp $	*/
d1271 1
a1271 1
	timeout_add(&sc->wb_tick_tmo, hz);
d1574 1
a1574 1
	timeout_add(&sc->wb_tick_tmo, hz);
@


1.37
log
@"interupt" -> "interrupt" in various comments. Mostly from Diego Casati.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.36 2006/10/25 02:37:50 brad Exp $	*/
d72 1
a72 1
 * which each contain several individual descriptors linked toghether.
d83 1
a83 1
 * drastic workaround which signigicantly impairs transmit performance.
@


1.36
log
@replace a few more instances of hand rolled code with the
LIST_FOREACH macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.35 2006/05/28 00:04:24 jason Exp $	*/
d1428 1
a1428 1
	 * get an interupt once for the whole chain rather than
@


1.35
log
@unknown ioctl is ENOTTY not EINVAL
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.34 2006/03/25 22:41:46 djm Exp $	*/
d657 1
a657 2
		for (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;
		    miisc = LIST_NEXT(miisc, mii_list))
@


1.34
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.33 2006/03/20 16:15:03 brad Exp $	*/
d1672 1
a1672 1
		error = EINVAL;
@


1.33
log
@de-register.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.32 2005/11/23 11:30:14 mickey Exp $	*/
d1071 1
a1071 1
			bpf_mtap(ifp->if_bpf, m);
d1414 2
a1415 1
			bpf_mtap(ifp->if_bpf, cur_tx->wb_mbuf);
@


1.32
log
@assume vtophys(vaddr_t) just what all the other archs expect; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.31 2005/11/07 02:57:46 brad Exp $	*/
d201 1
a201 1
	register int		d, i;
d232 1
a232 1
	register int		i;
d296 1
a296 1
	register int		i;
d633 1
a633 1
	register int i;
d1712 1
a1712 1
	register int		i;
@


1.31
log
@- splimp -> splnet
- remove spl's from attach
- removing redundant checks before pci_mapreg_map()
- fix dmesg printing
- de-allocate resources on failure to attach
- remove unused VLAN input code from vge(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.30 2005/09/11 18:17:08 mickey Exp $	*/
d120 1
d937 1
a937 1
					vtophys(&ld->wb_rx_list[0]);
d942 1
a942 1
					vtophys(&ld->wb_rx_list[i + 1]);
d990 1
a990 1
	c->wb_ptr->wb_data = vtophys(mtod(m_new, caddr_t));
d1086 1
a1086 1
	CSR_WRITE_4(sc, WB_RXADDR, vtophys(&sc->wb_ldata->wb_rx_list[0]));
d1309 2
a1310 2
			f->wb_next = vtophys(&c->wb_ptr->wb_frag[frag + 1]);
			f->wb_data = vtophys(mtod(m, vaddr_t));
d1343 1
a1343 1
		f->wb_data = vtophys(mtod(m_new, caddr_t));
d1352 1
a1352 1
		f->wb_data = vtophys(&sc->wb_cdata.wb_pad);
d1361 1
a1361 1
	WB_TXNEXT(c) = vtophys(&c->wb_nextdesc->wb_ptr->wb_frag[0]);
d1552 1
a1552 1
	CSR_WRITE_4(sc, WB_RXADDR, vtophys(&sc->wb_ldata->wb_rx_list[0]));
d1565 1
a1565 1
	CSR_WRITE_4(sc, WB_TXADDR, vtophys(&sc->wb_ldata->wb_tx_list[0]));
@


1.30
log
@do not inline pci_mapreg_map() anymore as it is olrite now; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.29 2005/08/09 04:10:12 mickey Exp $	*/
d344 1
a344 1
	s = splimp();
d440 1
a440 1
	s = splimp();
d718 2
a719 2
	bus_size_t iosize;
	int s, rseg;
a724 2
	s = splimp();

a758 1
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
a760 4
	if (!(command & PCI_COMMAND_IO_ENABLE)) {
		printf(": failed to enable I/O ports!\n");
		goto fail;
	}
d762 1
a762 1
	    &sc->wb_btag, &sc->wb_bhandle, NULL, &iosize, 0)) {
d764 1
a764 1
		goto fail;
a766 4
	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf(": failed to enable memory mapping!\n");
		goto fail;
	}
d768 1
a768 1
	    &sc->wb_btag, &sc->wb_bhandle, NULL, &iosize, 0)){
d770 1
a770 1
		goto fail;
d800 1
a800 1
	printf(" address %s\n", ether_sprintf(sc->arpcom.ac_enaddr));
d804 2
a805 2
		printf("%s: can't alloc list data\n", sc->sc_dev.dv_xname);
		goto fail_1;
d809 3
a811 4
		printf("%s: can't map list data, size %d\n",
		    sc->sc_dev.dv_xname, sizeof(struct wb_list_data));
		bus_dmamem_free(pa->pa_dmat, &seg, rseg);
		goto fail_1;
d815 2
a816 5
		printf("%s: can't create dma map\n", sc->sc_dev.dv_xname);
		bus_dmamem_unmap(pa->pa_dmat, kva,
		    sizeof(struct wb_list_data));
		bus_dmamem_free(pa->pa_dmat, &seg, rseg);
		goto fail_1;
d820 2
a821 6
		printf("%s: can't load dma map\n", sc->sc_dev.dv_xname);
		bus_dmamap_destroy(pa->pa_dmat, dmamap);
		bus_dmamem_unmap(pa->pa_dmat, kva,
		    sizeof(struct wb_list_data));
		bus_dmamem_free(pa->pa_dmat, &seg, rseg);
		goto fail_1;
d862 14
d878 1
a878 4
	bus_space_unmap(sc->wb_btag, sc->wb_bhandle, iosize);
fail:
	splx(s);
	return;
d1268 1
a1268 1
	s = splimp();
d1469 1
a1469 1
	s = splimp();
d1619 1
a1619 1
	s = splimp();
@


1.29
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.28 2005/07/02 23:10:11 brad Exp $	*/
a717 1
	bus_addr_t iobase;
d768 2
a769 5
	if (pci_io_find(pc, pa->pa_tag, WB_PCI_LOIO, &iobase, &iosize)) {
		printf(": can't find i/o space\n");
		goto fail;
	}
	if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->wb_bhandle)) {
a772 1
	sc->wb_btag = pa->pa_iot;
d778 2
a779 5
	if (pci_mem_find(pc, pa->pa_tag, WB_PCI_LOMEM, &iobase, &iosize, NULL)){
		printf(": can't find mem space\n");
		goto fail;
	}
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->wb_bhandle)) {
a782 1
	sc->wb_btag = pa->pa_memt;
d788 1
a788 1
		goto fail;
d798 1
a798 1
		goto fail;
d816 1
a816 1
		goto fail;
d823 1
a823 1
		goto fail;
d831 1
a831 1
		goto fail;
d840 1
a840 1
		goto fail;
d882 2
@


1.28
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.27 2005/01/15 05:24:11 brad Exp $	*/
d721 1
a721 1
	u_int32_t command;
a761 4
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	    PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
@


1.27
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.26 2004/12/11 02:06:47 brad Exp $	*/
d1738 2
a1768 4

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);

	return;
@


1.26
log
@rev 1.51

When reading PHY regs over the i2c bus, the turnaround ACK bit
is read one clock edge too late. This bit is driven low by
slave (as any other input data bits from slave) when the clock
is LOW. The current code did read the bit after the clock was
driven high again.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.25 2004/09/28 04:37:33 brad Exp $	*/
d1679 2
a1680 1
			wb_setmulti(sc);
@


1.25
log
@Use ETHER_MAX_DIX_LEN/ETHER_MIN_LEN
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.24 2004/09/23 17:45:16 brad Exp $	*/
d382 1
a384 1
	ack = CSR_READ_4(sc, WB_SIO) & WB_SIO_MII_DATAOUT;
@


1.24
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.23 2004/06/06 17:56:37 mcbride Exp $	*/
d1009 1
a1009 1
	c->wb_ptr->wb_ctl = WB_RXCTL_RLINK | 1536;
d1041 1
a1041 1
		    (WB_RXBYTES(cur_rx->wb_ptr->wb_status) > 1536) ||
@


1.23
log
@Multicast cleanups
- make multicast ranges work
- replace handrolled crc code with ether_crc32_{be,le}()
- add missing calls to ether_{add,del}multi()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.22 2003/08/19 14:01:35 mpech Exp $	*/
a858 1
	ifp->if_mtu = ETHERMTU;
a860 1
	ifp->if_output = ether_output;
@


1.22
log
@missing break.

jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.21 2003/04/26 08:01:42 jmc Exp $	*/
a523 31
u_int8_t wb_calchash(addr)
	caddr_t			addr;
{
	u_int32_t		crc, carry;
	int			i, j;
	u_int8_t		c;

	/* Compute CRC for the address value. */
	crc = 0xFFFFFFFF; /* initial value */

	for (i = 0; i < 6; i++) {
		c = *(addr + i);
		for (j = 0; j < 8; j++) {
			carry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);
			crc <<= 1;
			c >>= 1;
			if (carry)
				crc = (crc ^ 0x04c11db6) | carry;
		}
	}

	/*
	 * return the filter bit position
	 * Note: I arrived at the following nonsense
	 * through experimentation. It's not the usual way to
	 * generate the bit position but it's the only thing
	 * I could come up with that works.
	 */
	return(~(crc >> 26) & 0x0000003F);
}

d543 1
d559 5
a563 1
		h = wb_calchash(enm->enm_addrlo);
@


1.21
log
@managment -> management;

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.20 2003/01/15 06:31:24 art Exp $	*/
d1686 1
@


1.20
log
@Get rid of the remaining vm_offset_t in pci drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.19 2002/11/19 18:40:17 jason Exp $	*/
d74 1
a74 1
 * abuse as fragment pointers. This allows us to use a buffer managment
@


1.19
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.18 2002/07/05 13:48:11 aaron Exp $	*/
d1356 1
a1356 1
			f->wb_data = vtophys(mtod(m, vm_offset_t));
@


1.18
log
@Typo; stobe -> strobe
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.17 2002/03/14 01:26:59 millert Exp $	*/
d711 5
d725 2
a726 17
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_WINBOND) {
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_WINBOND_W89C840F:
			return (1);
		}
	}

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_COMPEX) {
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_COMPEX_RL100ATX:
			return (1);
		}
	}

	return (0);
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.16 2002/02/15 20:45:31 nordin Exp $	*/
d205 1
a205 1
	 * Feed in each bit and stobe the clock.
@


1.16
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.15 2001/11/06 19:53:19 miod Exp $	*/
d133 2
a134 2
int wb_probe		__P((struct device *, void *, void *));
void wb_attach		__P((struct device *, struct device *, void *));
d136 40
a175 40
void wb_bfree		__P((caddr_t, u_int, void *));
int wb_newbuf		__P((struct wb_softc *, struct wb_chain_onefrag *,
    struct mbuf *));
int wb_encap		__P((struct wb_softc *, struct wb_chain *,
    struct mbuf *));

void wb_rxeof		__P((struct wb_softc *));
void wb_rxeoc		__P((struct wb_softc *));
void wb_txeof		__P((struct wb_softc *));
void wb_txeoc		__P((struct wb_softc *));
int wb_intr		__P((void *));
void wb_tick		__P((void *));
void wb_start		__P((struct ifnet *));
int wb_ioctl		__P((struct ifnet *, u_long, caddr_t));
void wb_init		__P((void *));
void wb_stop		__P((struct wb_softc *));
void wb_watchdog	__P((struct ifnet *));
void wb_shutdown	__P((void *));
int wb_ifmedia_upd	__P((struct ifnet *));
void wb_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));

void wb_eeprom_putbyte	__P((struct wb_softc *, int));
void wb_eeprom_getword	__P((struct wb_softc *, int, u_int16_t *));
void wb_read_eeprom	__P((struct wb_softc *, caddr_t, int, int, int));
void wb_mii_sync	__P((struct wb_softc *));
void wb_mii_send	__P((struct wb_softc *, u_int32_t, int));
int wb_mii_readreg	__P((struct wb_softc *, struct wb_mii_frame *));
int wb_mii_writereg	__P((struct wb_softc *, struct wb_mii_frame *));

void wb_setcfg		__P((struct wb_softc *, u_int32_t));
u_int8_t wb_calchash	__P((caddr_t));
void wb_setmulti	__P((struct wb_softc *));
void wb_reset		__P((struct wb_softc *));
void wb_fixmedia	__P((struct wb_softc *));
int wb_list_rx_init	__P((struct wb_softc *));
int wb_list_tx_init	__P((struct wb_softc *));

int wb_miibus_readreg	__P((struct device *, int, int));
void wb_miibus_writereg	__P((struct device *, int, int, int));
void wb_miibus_statchg	__P((struct device *));
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.14 2001/09/11 20:05:25 miod Exp $	*/
d1576 1
a1576 1
		(void)splx(s);
d1627 1
a1627 1
	(void)splx(s);
d1729 1
a1729 1
	(void)splx(s);
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.15 2001/11/06 19:53:19 miod Exp $	*/
d133 2
a134 2
int wb_probe(struct device *, void *, void *);
void wb_attach(struct device *, struct device *, void *);
d136 40
a175 40
void wb_bfree(caddr_t, u_int, void *);
int wb_newbuf(struct wb_softc *, struct wb_chain_onefrag *,
    struct mbuf *);
int wb_encap(struct wb_softc *, struct wb_chain *,
    struct mbuf *);

void wb_rxeof(struct wb_softc *);
void wb_rxeoc(struct wb_softc *);
void wb_txeof(struct wb_softc *);
void wb_txeoc(struct wb_softc *);
int wb_intr(void *);
void wb_tick(void *);
void wb_start(struct ifnet *);
int wb_ioctl(struct ifnet *, u_long, caddr_t);
void wb_init(void *);
void wb_stop(struct wb_softc *);
void wb_watchdog(struct ifnet *);
void wb_shutdown(void *);
int wb_ifmedia_upd(struct ifnet *);
void wb_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void wb_eeprom_putbyte(struct wb_softc *, int);
void wb_eeprom_getword(struct wb_softc *, int, u_int16_t *);
void wb_read_eeprom(struct wb_softc *, caddr_t, int, int, int);
void wb_mii_sync(struct wb_softc *);
void wb_mii_send(struct wb_softc *, u_int32_t, int);
int wb_mii_readreg(struct wb_softc *, struct wb_mii_frame *);
int wb_mii_writereg(struct wb_softc *, struct wb_mii_frame *);

void wb_setcfg(struct wb_softc *, u_int32_t);
u_int8_t wb_calchash(caddr_t);
void wb_setmulti(struct wb_softc *);
void wb_reset(struct wb_softc *);
void wb_fixmedia(struct wb_softc *);
int wb_list_rx_init(struct wb_softc *);
int wb_list_tx_init(struct wb_softc *);

int wb_miibus_readreg(struct device *, int, int);
void wb_miibus_writereg(struct device *, int, int, int);
void wb_miibus_statchg(struct device *);
d1576 1
a1576 1
		splx(s);
d1627 1
a1627 1
	splx(s);
d1729 1
a1729 1
	splx(s);
@


1.15.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.15.2.1 2002/06/11 03:42:26 art Exp $	*/
d205 1
a205 1
	 * Feed in each bit and strobe the clock.
@


1.15.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 1
a74 1
 * abuse as fragment pointers. This allows us to use a buffer management
a710 5
const struct pci_matchid wb_devices[] = {
	{ PCI_VENDOR_WINBOND, PCI_PRODUCT_WINBOND_W89C840F },
	{ PCI_VENDOR_COMPEX, PCI_PRODUCT_COMPEX_RL100ATX },
};

d720 17
a736 2
	return (pci_matchbyid((struct pci_attach_args *)aux, wb_devices,
	    sizeof(wb_devices)/sizeof(wb_devices[0])));
d1366 1
a1366 1
			f->wb_data = vtophys(mtod(m, vaddr_t));
@


1.14
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.13 2001/08/25 10:13:29 art Exp $	*/
d119 1
a119 1
#include <vm/vm.h>		/* for vtophys */
@


1.13
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.12 2001/08/12 20:03:49 mickey Exp $	*/
a119 1
#include <vm/vm_kern.h>
@


1.12
log
@remove redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.11 2001/06/27 06:34:50 kjc Exp $	*/
d836 1
a836 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.11
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.10 2001/06/24 20:27:02 fgsch Exp $	*/
a119 1
#include <vm/pmap.h>		/* for vtophys */
a120 1
#include <vm/vm_extern.h>
@


1.10
log
@more ether_input_mbuf() conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.9 2001/05/17 18:41:46 provos Exp $	*/
d906 3
a908 1
	ifp->if_snd.ifq_maxlen = WB_TX_LIST_CNT - 1;
d1315 1
a1315 1
	if (ifp->if_snd.ifq_head != NULL) {
d1454 1
a1454 1
		IF_DEQUEUE(&ifp->if_snd, m_head);
d1757 1
a1757 1
	if (ifp->if_snd.ifq_head != NULL)
@


1.9
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.8 2001/02/20 19:39:44 mickey Exp $	*/
a1061 1
        struct ether_header	*eh;
a1122 1
		eh = mtod(m, struct ether_header *);
d1131 2
a1132 3
		/* Remove header from mbuf and pass it on. */
		m_adj(m, sizeof(struct ether_header));
		ether_input(ifp, eh, m);
@


1.8
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.7 2001/02/03 05:37:18 mickey Exp $	*/
d139 1
a139 1
void wb_bfree		__P((struct mbuf *));
d1010 4
a1013 2
wb_bfree(m)
	struct mbuf *m;
d1037 2
a1038 1
		m_new->m_ext.ext_ref = wb_bfree;
@


1.7
log
@new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.6 2000/10/16 17:08:08 aaron Exp $	*/
a932 4
#if NBPFILTER > 0
	bpfattach(&sc->arpcom.ac_if.if_bpf, ifp,
	    DLT_EN10MB, sizeof(struct ether_header));
#endif
@


1.6
log
@Use mii_attach() directly instead of mii_phy_probe().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.5 2000/02/15 02:28:15 jason Exp $	*/
d99 1
a1332 1
	timeout(wb_tick, sc, hz);
d1334 1
d1635 2
a1636 1
	timeout(wb_tick, sc, hz);
d1778 1
a1778 1
	untimeout(wb_tick, sc);
@


1.5
log
@make sure to call ether_{add,del}multi() as appropriate in xxx_ioctl()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.4 1999/11/19 02:29:27 jason Exp $	*/
d918 2
a919 1
	mii_phy_probe(self, &sc->sc_mii, 0xffffffff);
@


1.4
log
@use bus_dma*
merge with freebsd:
use dev/mii layer
do a more full reset in wb_reset()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.3 1999/09/27 18:17:01 jason Exp $	*/
d1710 12
a1721 2
		wb_setmulti(sc);
		error = 0;
@


1.4.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.5 2000/02/15 02:28:15 jason Exp $	*/
d1710 2
a1711 12
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			wb_setmulti(sc);
			error = 0;
		}
@


1.4.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.8 2001/02/20 19:39:44 mickey Exp $	*/
a98 1
#include <sys/timeout.h>
d918 1
a918 2
	mii_attach(self, &sc->sc_mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY,
	    0);
d931 4
d1331 1
a1332 1
	timeout_add(&sc->wb_tick_tmo, hz);
d1633 1
a1633 2
	timeout_set(&sc->wb_tick_tmo, wb_tick, sc);
	timeout_add(&sc->wb_tick_tmo, hz);
d1775 1
a1775 1
	timeout_del(&sc->wb_tick_tmo);
@


1.4.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.4.2.2 2001/05/14 22:25:48 niklas Exp $	*/
d139 1
a139 1
void wb_bfree		__P((caddr_t, u_int, void *));
d906 1
a906 3
	IFQ_SET_MAXLEN(&ifp->if_snd, WB_TX_LIST_CNT - 1);
	IFQ_SET_READY(&ifp->if_snd);

d1010 2
a1011 4
wb_bfree(buf, size, arg)
	caddr_t			buf;
	u_int			size;
	void *arg;
d1035 1
a1035 2
		m_new->m_ext.ext_arg = NULL;
		MCLINITREFERENCE(m_new);
d1059 1
d1121 1
d1130 3
a1132 2
		/* pass it on. */
		ether_input_mbuf(ifp, m);
d1313 1
a1313 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd)) {
d1452 1
a1452 1
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
d1755 1
a1755 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd))
@


1.4.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.4.2.3 2001/07/04 10:42:30 niklas Exp $	*/
d120 3
d838 2
a839 1
	if (pci_intr_map(pa, &ih)) {
@


1.4.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d119 1
a119 1
#include <uvm/uvm_extern.h>		/* for vtophys */
@


1.4.2.6
log
@Merge in trunk
@
text
@d1576 1
a1576 1
		splx(s);
d1627 1
a1627 1
	splx(s);
d1729 1
a1729 1
	splx(s);
@


1.4.2.7
log
@Merge in -current from roughly a week ago
@
text
@d133 2
a134 2
int wb_probe(struct device *, void *, void *);
void wb_attach(struct device *, struct device *, void *);
d136 5
a140 5
void wb_bfree(caddr_t, u_int, void *);
int wb_newbuf(struct wb_softc *, struct wb_chain_onefrag *,
    struct mbuf *);
int wb_encap(struct wb_softc *, struct wb_chain *,
    struct mbuf *);
d142 14
a155 14
void wb_rxeof(struct wb_softc *);
void wb_rxeoc(struct wb_softc *);
void wb_txeof(struct wb_softc *);
void wb_txeoc(struct wb_softc *);
int wb_intr(void *);
void wb_tick(void *);
void wb_start(struct ifnet *);
int wb_ioctl(struct ifnet *, u_long, caddr_t);
void wb_init(void *);
void wb_stop(struct wb_softc *);
void wb_watchdog(struct ifnet *);
void wb_shutdown(void *);
int wb_ifmedia_upd(struct ifnet *);
void wb_ifmedia_sts(struct ifnet *, struct ifmediareq *);
d157 7
a163 7
void wb_eeprom_putbyte(struct wb_softc *, int);
void wb_eeprom_getword(struct wb_softc *, int, u_int16_t *);
void wb_read_eeprom(struct wb_softc *, caddr_t, int, int, int);
void wb_mii_sync(struct wb_softc *);
void wb_mii_send(struct wb_softc *, u_int32_t, int);
int wb_mii_readreg(struct wb_softc *, struct wb_mii_frame *);
int wb_mii_writereg(struct wb_softc *, struct wb_mii_frame *);
d165 7
a171 7
void wb_setcfg(struct wb_softc *, u_int32_t);
u_int8_t wb_calchash(caddr_t);
void wb_setmulti(struct wb_softc *);
void wb_reset(struct wb_softc *);
void wb_fixmedia(struct wb_softc *);
int wb_list_rx_init(struct wb_softc *);
int wb_list_tx_init(struct wb_softc *);
d173 3
a175 3
int wb_miibus_readreg(struct device *, int, int);
void wb_miibus_writereg(struct device *, int, int, int);
void wb_miibus_statchg(struct device *);
@


1.4.2.8
log
@Sync the SMP branch with 3.3
@
text
@d205 1
a205 1
	 * Feed in each bit and strobe the clock.
a710 5
const struct pci_matchid wb_devices[] = {
	{ PCI_VENDOR_WINBOND, PCI_PRODUCT_WINBOND_W89C840F },
	{ PCI_VENDOR_COMPEX, PCI_PRODUCT_COMPEX_RL100ATX },
};

d720 17
a736 2
	return (pci_matchbyid((struct pci_attach_args *)aux, wb_devices,
	    sizeof(wb_devices)/sizeof(wb_devices[0])));
d1366 1
a1366 1
			f->wb_data = vtophys(mtod(m, vaddr_t));
@


1.4.2.9
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.4.2.8 2003/03/28 00:38:22 niklas Exp $	*/
d74 1
a74 1
 * abuse as fragment pointers. This allows us to use a buffer management
@


1.4.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a1685 1
		break;
@


1.4.2.11
log
@sync to head
@
text
@d524 31
a573 1
allmulti:
d589 1
a589 5
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}
		h = ~(ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26);
@


1.3
log
@reindent after removing statics
remove %d/wb_unit in favor of %s/sc_dev.dv_xname
From aaron@@:
uncomment and use splimp() (and fix case where splx would be missed)
correct check for mem mapped mode
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.2 1999/09/03 01:48:38 jason Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_wb.c,v 1.13 1999/07/11 00:56:07 wpaul Exp $
d98 1
d123 2
a134 16
/*
 * Various supported PHY vendors/types and their names. Note that
 * this driver will work with pretty much any MII-compliant PHY,
 * so failure to positively identify the chip is not a fatal error.
 */

struct wb_type wb_phys[] = {
	{ TI_PHY_VENDORID, TI_PHY_10BT, "<TI ThunderLAN 10BT (internal)>" },
	{ TI_PHY_VENDORID, TI_PHY_100VGPMI, "<TI TNETE211 100VG Any-LAN>" },
	{ NS_PHY_VENDORID, NS_PHY_83840A, "<National Semiconductor DP83840A>"},
	{ LEVEL1_PHY_VENDORID, LEVEL1_PHY_LXT970, "<Level 1 LXT970>" }, 
	{ INTEL_PHY_VENDORID, INTEL_PHY_82555, "<Intel 82555>" },
	{ SEEQ_PHY_VENDORID, SEEQ_PHY_80220, "<SEEQ 80220>" },
	{ 0, 0, "<MII-compliant physical interface>" }
};

d138 1
d149 1
a165 2
void wb_phy_writereg	__P((struct wb_softc *, int, int));
u_int16_t wb_phy_readreg	__P((struct wb_softc *, int));
d167 1
a167 5
void wb_autoneg_xmit	__P((struct wb_softc *));
void wb_autoneg_mii	__P((struct wb_softc *, int, int));
void wb_setmode_mii	__P((struct wb_softc *, int));
void wb_getmode_mii	__P((struct wb_softc *));
void wb_setcfg		__P((struct wb_softc *, int));
d171 1
d175 4
d481 4
a484 3
u_int16_t wb_phy_readreg(sc, reg)
	struct wb_softc		*sc;
	int			reg;
d486 2
a487 1
	struct wb_mii_frame	frame;
d491 1
a491 1
	frame.mii_phyaddr = sc->wb_phy_addr;
d498 4
a501 4
void wb_phy_writereg(sc, reg, data)
	struct wb_softc		*sc;
	int			reg;
	int			data;
d503 2
a504 1
	struct wb_mii_frame	frame;
d508 1
a508 1
	frame.mii_phyaddr = sc->wb_phy_addr;
d517 9
a612 289
 * Initiate an autonegotiation session.
 */
void wb_autoneg_xmit(sc)
	struct wb_softc		*sc;
{
	u_int16_t		phy_sts;

	wb_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);
	DELAY(500);
	while(wb_phy_readreg(sc, PHY_BMCR)
			& PHY_BMCR_RESET);

	phy_sts = wb_phy_readreg(sc, PHY_BMCR);
	phy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;
	wb_phy_writereg(sc, PHY_BMCR, phy_sts);

	return;
}

/*
 * Invoke autonegotiation on a PHY.
 */
void wb_autoneg_mii(sc, flag, verbose)
	struct wb_softc		*sc;
	int			flag;
	int			verbose;
{
	u_int16_t		phy_sts = 0, media, advert, ability;
	struct ifnet		*ifp;
	struct ifmedia		*ifm;

	ifm = &sc->ifmedia;
	ifp = &sc->arpcom.ac_if;

	ifm->ifm_media = IFM_ETHER | IFM_AUTO;

	/*
	 * The 100baseT4 PHY on the 3c905-T4 has the 'autoneg supported'
	 * bit cleared in the status register, but has the 'autoneg enabled'
	 * bit set in the control register. This is a contradiction, and
	 * I'm not sure how to handle it. If you want to force an attempt
	 * to autoneg for 100baseT4 PHYs, #define FORCE_AUTONEG_TFOUR
	 * and see what happens.
	 */
#ifndef FORCE_AUTONEG_TFOUR
	/*
	 * First, see if autoneg is supported. If not, there's
	 * no point in continuing.
	 */
	phy_sts = wb_phy_readreg(sc, PHY_BMSR);
	if (!(phy_sts & PHY_BMSR_CANAUTONEG)) {
		if (verbose)
			printf("%s: autonegotiation not supported\n",
			    sc->sc_dev.dv_xname);
		ifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;	
		return;
	}
#endif

	switch (flag) {
	case WB_FLAG_FORCEDELAY:
		/*
	 	 * XXX Never use this option anywhere but in the probe
	 	 * routine: making the kernel stop dead in its tracks
 		 * for three whole seconds after we've gone multi-user
		 * is really bad manners.
	 	 */
		wb_autoneg_xmit(sc);
		DELAY(5000000);
		break;
	case WB_FLAG_SCHEDDELAY:
		/*
		 * Wait for the transmitter to go idle before starting
		 * an autoneg session, otherwise wb_start() may clobber
	 	 * our timeout, and we don't want to allow transmission
		 * during an autoneg session since that can screw it up.
	 	 */
		if (sc->wb_cdata.wb_tx_head != NULL) {
			sc->wb_want_auto = 1;
			return;
		}
		wb_autoneg_xmit(sc);
		ifp->if_timer = 5;
		sc->wb_autoneg = 1;
		sc->wb_want_auto = 0;
		return;
		break;
	case WB_FLAG_DELAYTIMEO:
		ifp->if_timer = 0;
		sc->wb_autoneg = 0;
		break;
	default:
		printf("%s: invalid autoneg flag: %d\n",
		    sc->sc_dev.dv_xname, flag);
		return;
	}

	if (wb_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_AUTONEGCOMP) {
		if (verbose)
			printf("%s: autoneg complete, ", sc->sc_dev.dv_xname);
		phy_sts = wb_phy_readreg(sc, PHY_BMSR);
	} else {
		if (verbose)
			printf("%s: autoneg not complete, ",
			    sc->sc_dev.dv_xname);
	}

	media = wb_phy_readreg(sc, PHY_BMCR);

	/* Link is good. Report modes and set duplex mode. */
	if (wb_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_LINKSTAT) {
		if (verbose)
			printf("link status good ");
		advert = wb_phy_readreg(sc, PHY_ANAR);
		ability = wb_phy_readreg(sc, PHY_LPAR);

		if (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {
			ifm->ifm_media = IFM_ETHER|IFM_100_T4;
			media |= PHY_BMCR_SPEEDSEL;
			media &= ~PHY_BMCR_DUPLEX;
			printf("(100baseT4)\n");
		} else if (advert & PHY_ANAR_100BTXFULL &&
			ability & PHY_ANAR_100BTXFULL) {
			ifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;
			media |= PHY_BMCR_SPEEDSEL;
			media |= PHY_BMCR_DUPLEX;
			printf("(full-duplex, 100Mbps)\n");
		} else if (advert & PHY_ANAR_100BTXHALF &&
			ability & PHY_ANAR_100BTXHALF) {
			ifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;
			media |= PHY_BMCR_SPEEDSEL;
			media &= ~PHY_BMCR_DUPLEX;
			printf("(half-duplex, 100Mbps)\n");
		} else if (advert & PHY_ANAR_10BTFULL &&
			ability & PHY_ANAR_10BTFULL) {
			ifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;
			media &= ~PHY_BMCR_SPEEDSEL;
			media |= PHY_BMCR_DUPLEX;
			printf("(full-duplex, 10Mbps)\n");
		} else /* if (advert & PHY_ANAR_10BTHALF &&
			ability & PHY_ANAR_10BTHALF) */ {
			ifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;
			media &= ~PHY_BMCR_SPEEDSEL;
			media &= ~PHY_BMCR_DUPLEX;
			printf("(half-duplex, 10Mbps)\n");
		}

		media &= ~PHY_BMCR_AUTONEGENBL;

		/* Set ASIC's duplex mode to match the PHY. */
		wb_setcfg(sc, media);
		wb_phy_writereg(sc, PHY_BMCR, media);
	} else {
		if (verbose)
			printf("no carrier\n");
	}

	if (flag != WB_FLAG_FORCEDELAY)
		wb_init(sc);

	if (sc->wb_tx_pend) {
		sc->wb_autoneg = 0;
		sc->wb_tx_pend = 0;
		wb_start(ifp);
	}

	return;
}

void wb_getmode_mii(sc)
	struct wb_softc		*sc;
{
	u_int16_t		bmsr;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	bmsr = wb_phy_readreg(sc, PHY_BMSR);

	/* fallback */
	sc->ifmedia.ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;

	if (bmsr & PHY_BMSR_10BTHALF) {
		ifmedia_add(&sc->ifmedia,
			IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);
	}

	if (bmsr & PHY_BMSR_10BTFULL) {
		ifmedia_add(&sc->ifmedia,
			IFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);
		sc->ifmedia.ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;
	}

	if (bmsr & PHY_BMSR_100BTXHALF) {
		ifp->if_baudrate = 100000000;
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_TX, 0, NULL);
		ifmedia_add(&sc->ifmedia,
			IFM_ETHER|IFM_100_TX|IFM_HDX, 0, NULL);
		sc->ifmedia.ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;
	}

	if (bmsr & PHY_BMSR_100BTXFULL) {
		ifp->if_baudrate = 100000000;
		ifmedia_add(&sc->ifmedia,
			IFM_ETHER|IFM_100_TX|IFM_FDX, 0, NULL);
		sc->ifmedia.ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;
	}

	/* Some also support 100BaseT4. */
	if (bmsr & PHY_BMSR_100BT4) {
		ifp->if_baudrate = 100000000;
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_T4, 0, NULL);
		sc->ifmedia.ifm_media = IFM_ETHER|IFM_100_T4;
#ifdef FORCE_AUTONEG_TFOUR
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0 NULL):
		sc->ifmedia.ifm_media = IFM_ETHER|IFM_AUTO;
#endif
	}

	if (bmsr & PHY_BMSR_CANAUTONEG) {
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);
		sc->ifmedia.ifm_media = IFM_ETHER|IFM_AUTO;
	}

	return;
}

/*
 * Set speed and duplex mode.
 */
void wb_setmode_mii(sc, media)
	struct wb_softc		*sc;
	int			media;
{
	u_int16_t		bmcr;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	/*
	 * If an autoneg session is in progress, stop it.
	 */
	if (sc->wb_autoneg) {
		printf("%s: canceling autoneg session\n", sc->sc_dev.dv_xname);
		ifp->if_timer = sc->wb_autoneg = sc->wb_want_auto = 0;
		bmcr = wb_phy_readreg(sc, PHY_BMCR);
		bmcr &= ~PHY_BMCR_AUTONEGENBL;
		wb_phy_writereg(sc, PHY_BMCR, bmcr);
	}

	printf("%s: selecting MII, ", sc->sc_dev.dv_xname);

	bmcr = wb_phy_readreg(sc, PHY_BMCR);

	bmcr &= ~(PHY_BMCR_AUTONEGENBL|PHY_BMCR_SPEEDSEL|
			PHY_BMCR_DUPLEX|PHY_BMCR_LOOPBK);

	if (IFM_SUBTYPE(media) == IFM_100_T4) {
		printf("100Mbps/T4, half-duplex\n");
		bmcr |= PHY_BMCR_SPEEDSEL;
		bmcr &= ~PHY_BMCR_DUPLEX;
	}

	if (IFM_SUBTYPE(media) == IFM_100_TX) {
		printf("100Mbps, ");
		bmcr |= PHY_BMCR_SPEEDSEL;
	}

	if (IFM_SUBTYPE(media) == IFM_10_T) {
		printf("10Mbps, ");
		bmcr &= ~PHY_BMCR_SPEEDSEL;
	}

	if ((media & IFM_GMASK) == IFM_FDX) {
		printf("full duplex\n");
		bmcr |= PHY_BMCR_DUPLEX;
	} else {
		printf("half duplex\n");
		bmcr &= ~PHY_BMCR_DUPLEX;
	}

	wb_setcfg(sc, bmcr);
	wb_phy_writereg(sc, PHY_BMCR, bmcr);

	return;
}

/*
d617 4
a620 3
void wb_setcfg(sc, bmcr)
	struct wb_softc		*sc;
	int			bmcr;
d640 3
a642 1
	if (bmcr & PHY_BMCR_SPEEDSEL)
a643 2
	else
		WB_CLRBIT(sc, WB_NETCFG, WB_NETCFG_100MBPS);
d645 1
a645 1
	if (bmcr & PHY_BMCR_DUPLEX)
d656 3
a658 2
void wb_reset(sc)
	struct wb_softc		*sc;
d660 7
a666 1
	register int		i;
d669 1
d682 14
a695 3
	/* Reset the damn PHY too. */
	if (sc->wb_pinfo != NULL)
		wb_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);
d697 14
a710 1
        return;
d758 1
a758 5
	int i, media = IFM_ETHER|IFM_100_TX|IFM_FDX, s;
	u_int round;
	caddr_t roundptr;
	u_int16_t phy_vid, phy_did, phy_sts;
	struct wb_type		*p;
d760 3
d854 2
d865 18
a882 4
	sc->wb_ldata_ptr = malloc(sizeof(struct wb_list_data) + 8,
				M_DEVBUF, M_NOWAIT);
	if (sc->wb_ldata_ptr == NULL) {
		printf("%s: no memory for list buffers!\n",sc->sc_dev.dv_xname);
d885 8
a892 15

	sc->wb_ldata = (struct wb_list_data *)sc->wb_ldata_ptr;
#ifdef __alpha__
	round = (u_int64_t)sc->wb_ldata_ptr & 0xF;
#endif
#ifdef __i386__
	round = (u_int32_t)sc->wb_ldata_ptr & 0xF;
#endif
	roundptr = sc->wb_ldata_ptr;
	for (i = 0; i < 8; i++) {
		if (round % 8) {
			round++;
			roundptr++;
		} else
			break;
d894 1
a894 1
	sc->wb_ldata = (struct wb_list_data *)roundptr;
a907 28
	for (i = WB_PHYADDR_MIN; i < WB_PHYADDR_MAX + 1; i++) {
		sc->wb_phy_addr = i;
		wb_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);
		DELAY(500);
		while(wb_phy_readreg(sc, PHY_BMCR)
				& PHY_BMCR_RESET);
		if ((phy_sts = wb_phy_readreg(sc, PHY_BMSR)))
			break;
	}
	if (phy_sts) {
		phy_vid = wb_phy_readreg(sc, PHY_VENID);
		phy_did = wb_phy_readreg(sc, PHY_DEVID);
		p = wb_phys;
		while(p->wb_vid) {
			if (phy_vid == p->wb_vid &&
				(phy_did | 0x000F) == p->wb_did) {
				sc->wb_pinfo = p;
				break;
			}
			p++;
		}
		if (sc->wb_pinfo == NULL)
			sc->wb_pinfo = &wb_phys[PHY_UNKNOWN];
	} else {
		printf("%s: MII without any phy!\n", sc->sc_dev.dv_xname);
		goto fail;
	}

a910 5
	ifmedia_init(&sc->ifmedia, 0, wb_ifmedia_upd, wb_ifmedia_sts);

	wb_getmode_mii(sc);
	wb_autoneg_mii(sc, WB_FLAG_FORCEDELAY, 1);
	media = sc->ifmedia.ifm_media;
d913 11
a923 1
	ifmedia_set(&sc->ifmedia, media);
d991 1
d1011 6
d1032 6
a1037 7

		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			m_freem(m_new);
			return(ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
d1040 1
a1040 1
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
d1048 1
a1048 1
	c->wb_ptr->wb_ctl = WB_RXCTL_RLINK | (MCLBYTES - 1);
d1062 1
a1062 1
        struct mbuf		*m;
d1076 1
d1079 5
a1083 2
		if ((rxstat & WB_RXSTAT_MIIERR)
			 || WB_RXBYTES(cur_rx->wb_ptr->wb_status) == 0) {
d1085 1
a1085 1
			wb_reset(sc);
d1088 3
a1090 2
			ifp->if_flags |= IFF_OACTIVE;
			ifp->if_timer = 2;
d1097 1
a1097 1
			continue;
d1117 1
a1117 1
			continue;
a1225 2
		if (sc->wb_want_auto)
			wb_autoneg_mii(sc, WB_FLAG_SCHEDDELAY, 1);
d1265 9
a1279 9
		if ((status & WB_ISR_RX_NOBUF) || (status & WB_ISR_RX_ERR)) {
			ifp->if_ierrors++;
#ifdef foo
			wb_stop(sc);
			wb_reset(sc);
			wb_init(sc);
#endif
		}

d1322 13
a1441 5
	if (sc->wb_autoneg) {
		sc->wb_tx_pend = 1;
		return;
	}

d1526 3
a1528 7
	struct wb_softc		*sc = xsc;
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	int			s, i;
	u_int16_t		phy_bmcr = 0;

	if (sc->wb_autoneg)
		return;
a1531 3
	if (sc->wb_pinfo != NULL)
		phy_bmcr = wb_phy_readreg(sc, PHY_BMCR);

d1543 1
d1547 19
a1569 2
	wb_setcfg(sc, phy_bmcr);

a1627 4
	/* Restore state of BMCR */
	if (sc->wb_pinfo != NULL)
		wb_phy_writereg(sc, PHY_BMCR, phy_bmcr);

d1633 2
d1641 3
a1643 2
int wb_ifmedia_upd(ifp)
	struct ifnet		*ifp;
d1645 1
a1645 2
	struct wb_softc		*sc;
	struct ifmedia		*ifm;
d1647 2
a1648 10
	sc = ifp->if_softc;
	ifm = &sc->ifmedia;

	if (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)
		return(EINVAL);

	if (IFM_SUBTYPE(ifm->ifm_media) == IFM_AUTO)
		wb_autoneg_mii(sc, WB_FLAG_SCHEDDELAY, 1);
	else
		wb_setmode_mii(sc, ifm->ifm_media);
d1656 2
a1657 1
void wb_ifmedia_sts(ifp, ifmr)
d1661 2
a1662 2
	struct wb_softc		*sc;
	u_int16_t		advert = 0, ability = 0;
d1664 3
a1666 36
	sc = ifp->if_softc;

	ifmr->ifm_active = IFM_ETHER;

	if (!(wb_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_AUTONEGENBL)) {
		if (wb_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_SPEEDSEL)
			ifmr->ifm_active = IFM_ETHER|IFM_100_TX;
		else
			ifmr->ifm_active = IFM_ETHER|IFM_10_T;
		if (wb_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_DUPLEX)
			ifmr->ifm_active |= IFM_FDX;
		else
			ifmr->ifm_active |= IFM_HDX;
		return;
	}

	ability = wb_phy_readreg(sc, PHY_LPAR);
	advert = wb_phy_readreg(sc, PHY_ANAR);
	if (advert & PHY_ANAR_100BT4 &&
		ability & PHY_ANAR_100BT4) {
		ifmr->ifm_active = IFM_ETHER|IFM_100_T4;
	} else if (advert & PHY_ANAR_100BTXFULL &&
		ability & PHY_ANAR_100BTXFULL) {
		ifmr->ifm_active = IFM_ETHER|IFM_100_TX|IFM_FDX;
	} else if (advert & PHY_ANAR_100BTXHALF &&
		ability & PHY_ANAR_100BTXHALF) {
		ifmr->ifm_active = IFM_ETHER|IFM_100_TX|IFM_HDX;
	} else if (advert & PHY_ANAR_10BTFULL &&
		ability & PHY_ANAR_10BTFULL) {
		ifmr->ifm_active = IFM_ETHER|IFM_10_T|IFM_FDX;
	} else if (advert & PHY_ANAR_10BTHALF &&
		ability & PHY_ANAR_10BTHALF) {
		ifmr->ifm_active = IFM_ETHER|IFM_10_T|IFM_HDX;
	}

	return;
d1715 1
a1715 1
		error = ifmedia_ioctl(ifp, ifr, &sc->ifmedia, command);
a1733 5
	if (sc->wb_autoneg) {
		wb_autoneg_mii(sc, WB_FLAG_DELAYTIMEO, 1);
		return;
	}

d1737 1
d1741 1
a1741 1

d1764 2
@


1.2
log
@o make this look more like an OpenBSD driver (removed static's)
o partial merge with freebsd, alpha support (currently untested)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wb.c,v 1.1 1999/03/11 18:20:13 jason Exp $	*/
d148 2
a149 2
int wb_probe	__P((struct device *, void *, void *));
void wb_attach	__P((struct device *, struct device *, void *));
d165 2
a166 2
void wb_watchdog		__P((struct ifnet *));
void wb_shutdown		__P((void *));
d172 3
a174 4
void wb_read_eeprom	__P((struct wb_softc *, caddr_t, int,
							int, int));
void wb_mii_sync		__P((struct wb_softc *));
void wb_mii_send		__P((struct wb_softc *, u_int32_t, int));
d177 1
a178 1
void wb_phy_writereg	__P((struct wb_softc *, int, int));
d186 1
a186 1
void wb_setmulti		__P((struct wb_softc *));
d665 2
a666 2
			printf("wb%d: autonegotiation not supported\n",
							sc->wb_unit);
d705 2
a706 1
		printf("wb%d: invalid autoneg flag: %d\n", sc->wb_unit, flag);
d712 1
a712 1
			printf("wb%d: autoneg complete, ", sc->wb_unit);
d716 2
a717 1
			printf("wb%d: autoneg not complete, ", sc->wb_unit);
d857 1
a857 1
		printf("wb%d: canceling autoneg session\n", sc->wb_unit);
d864 1
a864 1
	printf("wb%d: selecting MII, ", sc->wb_unit);
d924 2
a925 2
			printf("wb%d: failed to force tx and "
				"rx to idle state\n", sc->wb_unit);
d957 1
a957 1
		printf("wb%d: reset never completed!\n", sc->wb_unit);
d1014 1
a1014 1
	int i, media = IFM_ETHER|IFM_100_TX|IFM_FDX;
a1020 1
#if 0
a1021 3
#endif

	sc->wb_unit = sc->sc_dev.dv_unit;
d1078 1
a1078 1
	if (!(command & PCI_COMMAND_IO_ENABLE)) {
d1124 1
a1124 1
		return;
d1180 1
a1180 1
		printf("wb%d: MII without any phy!\n", sc->wb_unit);
a1208 1
#if 0
a1209 1
#endif
d1347 2
a1348 2
			printf("wb%x: receiver babbling: possible chip "
				"bug, forcing reset\n", sc->wb_unit);
d1820 2
a1821 2
		printf("wb%d: initialization failed: no "
			"memory for rx buffers\n", sc->wb_unit);
d2025 1
a2025 1
	printf("wb%d: watchdog timeout\n", sc->wb_unit);
d2028 2
a2029 2
		printf("wb%d: no carrier - transceiver cable problem?\n",
								sc->wb_unit);
@


1.1
log
@Winbond W89C840F ethernet driver
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
 *	$FreeBSD: if_wb.c,v 1.7 1999/02/01 21:25:52 wpaul Exp $
d138 1
a138 1
static struct wb_type wb_phys[] = {
d148 2
a149 2
static int wb_probe	__P((struct device *, void *, void *));
static void wb_attach	__P((struct device *, struct device *, void *));
d151 22
a172 22
static int wb_newbuf		__P((struct wb_softc *,
						struct wb_chain_onefrag *));
static int wb_encap		__P((struct wb_softc *, struct wb_chain *,
						struct mbuf *));

static void wb_rxeof		__P((struct wb_softc *));
static void wb_rxeoc		__P((struct wb_softc *));
static void wb_txeof		__P((struct wb_softc *));
static void wb_txeoc		__P((struct wb_softc *));
static int wb_intr		__P((void *));
static void wb_start		__P((struct ifnet *));
static int wb_ioctl		__P((struct ifnet *, u_long, caddr_t));
static void wb_init		__P((void *));
static void wb_stop		__P((struct wb_softc *));
static void wb_watchdog		__P((struct ifnet *));
static void wb_shutdown		__P((void *));
static int wb_ifmedia_upd	__P((struct ifnet *));
static void wb_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));

static void wb_eeprom_putbyte	__P((struct wb_softc *, int));
static void wb_eeprom_getword	__P((struct wb_softc *, int, u_int16_t *));
static void wb_read_eeprom	__P((struct wb_softc *, caddr_t, int,
d174 17
a190 17
static void wb_mii_sync		__P((struct wb_softc *));
static void wb_mii_send		__P((struct wb_softc *, u_int32_t, int));
static int wb_mii_readreg	__P((struct wb_softc *, struct wb_mii_frame *));
static int wb_mii_writereg	__P((struct wb_softc *, struct wb_mii_frame *));
static u_int16_t wb_phy_readreg	__P((struct wb_softc *, int));
static void wb_phy_writereg	__P((struct wb_softc *, int, int));

static void wb_autoneg_xmit	__P((struct wb_softc *));
static void wb_autoneg_mii	__P((struct wb_softc *, int, int));
static void wb_setmode_mii	__P((struct wb_softc *, int));
static void wb_getmode_mii	__P((struct wb_softc *));
static void wb_setcfg		__P((struct wb_softc *, int));
static u_int8_t wb_calchash	__P((caddr_t));
static void wb_setmulti		__P((struct wb_softc *));
static void wb_reset		__P((struct wb_softc *));
static int wb_list_rx_init	__P((struct wb_softc *));
static int wb_list_tx_init	__P((struct wb_softc *));
d211 1
a211 1
static void wb_eeprom_putbyte(sc, addr)
d241 1
a241 1
static void wb_eeprom_getword(sc, addr, dest)
d282 1
a282 1
static void wb_read_eeprom(sc, dest, off, cnt, swap)
d307 1
a307 1
static void wb_mii_sync(sc)
d327 1
a327 1
static void wb_mii_send(sc, bits, cnt)
d352 1
a352 1
static int wb_mii_readreg(sc, frame)
d448 1
a448 1
static int wb_mii_writereg(sc, frame)
d494 1
a494 1
static u_int16_t wb_phy_readreg(sc, reg)
d509 1
a509 1
static void wb_phy_writereg(sc, reg, data)
d527 1
a527 1
static u_int8_t wb_calchash(addr)
d561 1
a561 1
static void wb_setmulti(sc)
d616 1
a616 1
static void wb_autoneg_xmit(sc)
d636 1
a636 1
static void wb_autoneg_mii(sc, flag, verbose)
d781 1
a781 1
static void wb_getmode_mii(sc)
d843 1
a843 1
static void wb_setmode_mii(sc, media)
d905 1
a905 1
static void wb_setcfg(sc, bmcr)
d943 1
a943 1
static void wb_reset(sc)
d972 1
a972 1
static int
d1000 1
a1000 1
static void
d1014 1
a1014 1
	unsigned int round;
d1131 6
a1136 1
	round = (unsigned int)sc->wb_ldata_ptr & 0xF;
d1221 1
a1221 1
static int wb_list_tx_init(sc)
d1254 1
a1254 1
static int wb_list_rx_init(sc)
d1267 1
a1267 1
		if (wb_newbuf(sc, &cd->wb_rx_chain[i]) == ENOBUFS)
d1289 5
a1293 3
static int wb_newbuf(sc, c)
	struct wb_softc		*sc;
	struct wb_chain_onefrag	*c;
d1297 15
a1311 8
	MGETHDR(m_new, M_DONTWAIT, MT_DATA);
	if (m_new == NULL)
		return(ENOBUFS);

	MCLGET(m_new, M_DONTWAIT);
	if (!(m_new->m_flags & M_EXT)) {
		m_freem(m_new);
		return(ENOBUFS);
d1314 2
d1328 1
a1328 1
static void wb_rxeof(sc)
d1342 2
d1346 1
d1361 1
a1361 3
			cur_rx->wb_ptr->wb_ctl =
				WB_RXCTL_RLINK | (MCLBYTES - 1);
			cur_rx->wb_ptr->wb_status = WB_RXSTAT;
d1377 6
a1382 28
		if (total_len < MINCLSIZE) {
			m = m_devget(mtod(cur_rx->wb_mbuf, char *),
				total_len, 0, ifp, NULL);
			cur_rx->wb_ptr->wb_ctl =
				WB_RXCTL_RLINK | (MCLBYTES - 1);
			cur_rx->wb_ptr->wb_status = WB_RXSTAT;
			if (m == NULL) {
				ifp->if_ierrors++;
				continue;
			}
		} else {
			m = cur_rx->wb_mbuf;
		/*
		 * Try to conjure up a new mbuf cluster. If that
		 * fails, it means we have an out of memory condition and
		 * should leave the buffer in place and continue. This will
		 * result in a lost packet, but there's little else we
		 * can do in this situation.
		 */
			if (wb_newbuf(sc, cur_rx) == ENOBUFS) {
				ifp->if_ierrors++;
				cur_rx->wb_ptr->wb_ctl =
					WB_RXCTL_RLINK | (MCLBYTES - 1);
				cur_rx->wb_ptr->wb_status = WB_RXSTAT;
				continue;
			}
			m->m_pkthdr.rcvif = ifp;
			m->m_pkthdr.len = m->m_len = total_len;
d1384 2
d1423 1
a1423 1
static void wb_txeof(sc)
d1479 1
a1479 1
static void wb_txeoc(sc)
d1504 1
a1504 1
static int wb_intr(arg)
d1593 1
a1593 1
static int wb_encap(sc, c, m_head)
d1687 1
a1687 1
static void wb_start(ifp)
d1782 1
a1782 1
static void wb_init(xsc)
d1891 1
a1891 1
static int wb_ifmedia_upd(ifp)
d1914 1
a1914 1
static void wb_ifmedia_sts(ifp, ifmr)
d1959 1
a1959 1
static int wb_ioctl(ifp, command, data)
d2017 1
a2017 1
static void wb_watchdog(ifp)
d2050 1
a2050 1
static void wb_stop(sc)
d2098 1
a2098 1
static void wb_shutdown(arg)
@

