head	1.51;
access;
symbols
	OPENBSD_6_2_BASE:1.51
	OPENBSD_6_1:1.51.0.4
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.48.0.6
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.47.0.4
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.45.0.6
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.44.0.4
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.43.0.2
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.41.0.6
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.4
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.2
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.38.0.2
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.33.0.4
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.6
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.25.0.4
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.20.0.4
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.15
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	SMP:1.8.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5;
locks; strict;
comment	@ * @;


1.51
date	2016.12.26.17.38.14;	author jca;	state Exp;
branches;
next	1.50;
commitid	7dXGn3bjEh7gjeKW;

1.50
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.49;
commitid	qGgYgJTgEFuAoGj4;

1.49
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.48;
commitid	pi1a9KN0itEngOc4;

1.48
date	2015.12.11.16.07.01;	author mpi;	state Exp;
branches;
next	1.47;
commitid	fbhqfhfdKxBcsetK;

1.47
date	2015.05.11.06.46.22;	author ratchov;	state Exp;
branches;
next	1.46;
commitid	RaOGL5SyOGOZylwx;

1.46
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.45;
commitid	p4LJxGKbi0BU2cG6;

1.45
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.44;
commitid	OBNa5kfxQ2UXoiIw;

1.44
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.42;

1.42
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.41;

1.41
date	2012.01.11.16.22.33;	author dhill;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.38;

1.38
date	2010.09.12.03.17.34;	author jakemsr;	state Exp;
branches;
next	1.37;

1.37
date	2010.09.12.02.05.41;	author jakemsr;	state Exp;
branches;
next	1.36;

1.36
date	2010.09.07.16.21.44;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2010.08.27.18.50.57;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.33;

1.33
date	2009.01.20.20.00.06;	author grange;	state Exp;
branches;
next	1.32;

1.32
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.31;

1.31
date	2008.05.29.02.10.01;	author jakemsr;	state Exp;
branches;
next	1.30;

1.30
date	2008.04.21.00.32.43;	author jakemsr;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.05.00.17.28;	author jakemsr;	state Exp;
branches;
next	1.28;

1.28
date	2007.10.22.03.16.35;	author fgsch;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.21.12.43.25;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2007.08.01.21.37.21;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2006.04.07.22.41.33;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.29.05.42.17;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.09.04.10.10;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.19.16.10.46;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.19.16.06.22;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.08.22.38.20;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.21.04.57.40;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2003.08.21.04.52.51;	author kevlo;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.01.19.15.13;	author deraadt;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.18.19.27.17;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.12.15.40.30;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.02.21.13.37;	author marc;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.03.14.12.15.11;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.26.22.37.48;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.17.20.31.20;	author marc;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.19.16.06.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.12.22.10.33;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.12.18.45.17;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.30.03.28.07;	author art;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.14.22.25.36;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.07.04.10.41.56;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2001.12.05.00.43.29;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.8.2.7;

1.8.2.7
date	2003.03.28.00.38.20;	author niklas;	state Exp;
branches;
next	1.8.2.8;

1.8.2.8
date	2003.05.13.19.35.05;	author ho;	state Exp;
branches;
next	1.8.2.9;

1.8.2.9
date	2004.02.19.10.56.25;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.01.31.22.55.34;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.51
log
@Fix typo, happend -> happened
@
text
@/*	$OpenBSD: cs4280.c,v 1.50 2016/09/19 06:46:44 ratchov Exp $	*/
/*	$NetBSD: cs4280.c,v 1.5 2000/06/26 04:56:23 simonb Exp $	*/

/*
 * Copyright (c) 1999, 2000 Tatoku Ogaito.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Tatoku Ogaito
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Cirrus Logic CS4280 (and maybe CS461x) driver.
 * Data sheets can be found
 * http://www.cirrus.com/ftp/pubs/4280.pdf
 * http://www.cirrus.com/ftp/pubs/4297.pdf
 * ftp://ftp.alsa-project.org/pub/manuals/cirrus/embedded_audio_spec.pdf
 * ftp://ftp.alsa-project.org/pub/manuals/cirrus/embedded_audio_spec.doc
 */

/*
 * TODO
 * Implement MIDI
 * Joystick support
 */

#ifdef CS4280_DEBUG
#ifndef MIDI_READY
#define MIDI_READY
#endif /* ! MIDI_READY */
#endif

#ifdef MIDI_READY
#include "midi.h"
#endif

#if defined(CS4280_DEBUG)
#define DPRINTF(x)	    if (cs4280debug) printf x
#define DPRINTFN(n,x)	    if (cs4280debug>(n)) printf x
int cs4280debug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/fcntl.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/cs4280reg.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>

#include <dev/ic/ac97.h>

#include <machine/bus.h>

#define CSCC_PCI_BA0 0x10
#define CSCC_PCI_BA1 0x14

struct cs4280_dma {
	bus_dmamap_t map;
	caddr_t addr;		/* real dma buffer */
	caddr_t dum;		/* dummy buffer for audio driver */
	bus_dma_segment_t segs[1];
	int nsegs;
	size_t size;
	struct cs4280_dma *next;
};
#define DMAADDR(p) ((p)->map->dm_segs[0].ds_addr)
#define BUFADDR(p)  ((void *)((p)->dum))
#define KERNADDR(p) ((void *)((p)->addr))

/*
 * Software state
 */
struct cs4280_softc {
	struct device	      sc_dev;

	pci_intr_handle_t *   sc_ih;

	/* I/O (BA0) */
	bus_space_tag_t	      ba0t;
	bus_space_handle_t    ba0h;
	
	/* BA1 */
	bus_space_tag_t	      ba1t;
	bus_space_handle_t    ba1h;
	
	/* DMA */
	bus_dma_tag_t	 sc_dmatag;
	struct cs4280_dma *sc_dmas;

	void	(*sc_pintr)(void *);	/* dma completion intr handler */
	void	*sc_parg;		/* arg for sc_intr() */
	char	*sc_ps, *sc_pe, *sc_pn;
	int	sc_pcount;
	int	sc_pi;
	struct	cs4280_dma *sc_pdma;
	char	*sc_pbuf;
#ifdef DIAGNOSTIC
	char	sc_prun;
#endif

	void	(*sc_rintr)(void *);	/* dma completion intr handler */
	void	*sc_rarg;		/* arg for sc_intr() */
	char	*sc_rs, *sc_re, *sc_rn;
	int	sc_rcount;
	int	sc_ri;
	struct	cs4280_dma *sc_rdma;
	char	*sc_rbuf;
	int	sc_rparam;		/* record format */
#ifdef DIAGNOSTIC
	char	sc_rrun;
#endif

#if NMIDI > 0
	void	(*sc_iintr)(void *, int); /* midi input ready handler */
	void	(*sc_ointr)(void *);	  /* midi output ready handler */
	void	*sc_arg;
#endif

	u_int32_t pctl;
	u_int32_t cctl;

	struct ac97_codec_if *codec_if;
	struct ac97_host_if host_if;	

	u_int16_t  ac97_reg[CS4280_SAVE_REG_MAX + 1];	/* Save ac97 registers */
};

#define BA0READ4(sc, r) bus_space_read_4((sc)->ba0t, (sc)->ba0h, (r))
#define BA0WRITE4(sc, r, x) bus_space_write_4((sc)->ba0t, (sc)->ba0h, (r), (x))
#define BA1READ4(sc, r) bus_space_read_4((sc)->ba1t, (sc)->ba1h, (r))
#define BA1WRITE4(sc, r, x) bus_space_write_4((sc)->ba1t, (sc)->ba1h, (r), (x))

int	cs4280_match(struct device *, void *, void *);
void	cs4280_attach(struct device *, struct device *, void *);
int	cs4280_activate(struct device *, int);
void	cs4280_attachhook(struct device *);
int	cs4280_intr(void *);
void	cs4280_reset(void *);
int	cs4280_download_image(struct cs4280_softc *);

int cs4280_download(struct cs4280_softc *, const u_int32_t *, u_int32_t, u_int32_t);
int cs4280_allocmem(struct cs4280_softc *, size_t, size_t,
			 struct cs4280_dma *);
int cs4280_freemem(struct cs4280_softc *, struct cs4280_dma *);

#ifdef CS4280_DEBUG
int	cs4280_check_images(struct cs4280_softc *);
int	cs4280_checkimage(struct cs4280_softc *, u_int32_t *, u_int32_t,
			  u_int32_t);
#endif

struct	cfdriver clcs_cd = {
	NULL, "clcs", DV_DULL
};

struct cfattach clcs_ca = {
	sizeof(struct cs4280_softc), cs4280_match, cs4280_attach, NULL,
	cs4280_activate
};

int	cs4280_init(struct cs4280_softc *, int);
int	cs4280_init2(struct cs4280_softc *, int);
int	cs4280_open(void *, int);
void	cs4280_close(void *);

int	cs4280_set_params(void *, int, int, struct audio_params *, struct audio_params *);
int	cs4280_round_blocksize(void *, int);

int	cs4280_halt_output(void *);
int	cs4280_halt_input(void *);

int	cs4280_mixer_set_port(void *, mixer_ctrl_t *);
int	cs4280_mixer_get_port(void *, mixer_ctrl_t *);
int	cs4280_query_devinfo(void *addr, mixer_devinfo_t *dip);
void   *cs4280_malloc(void *, int, size_t, int, int);
void	cs4280_free(void *, void *, int);
size_t	cs4280_round_buffersize(void *, int, size_t);
int	cs4280_get_props(void *);
int	cs4280_trigger_output(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	cs4280_trigger_input(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);


void	cs4280_set_dac_rate(struct cs4280_softc *, int );
void	cs4280_set_adc_rate(struct cs4280_softc *, int );
int	cs4280_get_portnum_by_name(struct cs4280_softc *, char *, char *,
					 char *);
int	cs4280_src_wait(struct cs4280_softc *);
int	cs4280_attach_codec(void *sc, struct ac97_codec_if *);
int	cs4280_read_codec(void *sc, u_int8_t a, u_int16_t *d);
int	cs4280_write_codec(void *sc, u_int8_t a, u_int16_t d);
void	cs4280_reset_codec(void *sc);

void	cs4280_clear_fifos(struct cs4280_softc *);

#if NMIDI > 0
void	cs4280_midi_close(void *);
void	cs4280_midi_getinfo(void *, struct midi_info *);
int	cs4280_midi_open(void *, int, void (*)(void *, int),
	    void (*)(void *), void *);
int	cs4280_midi_output(void *, int);
#endif

struct audio_hw_if cs4280_hw_if = {
	cs4280_open,
	cs4280_close,
	cs4280_set_params,
	cs4280_round_blocksize,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	cs4280_halt_output,
	cs4280_halt_input,
	NULL,
	NULL,
	cs4280_mixer_set_port,
	cs4280_mixer_get_port,
	cs4280_query_devinfo,
	cs4280_malloc,
	cs4280_free,
	cs4280_round_buffersize,
	cs4280_get_props,
	cs4280_trigger_output,
	cs4280_trigger_input
};

#if NMIDI > 0
struct midi_hw_if cs4280_midi_hw_if = {
	cs4280_midi_open,
	cs4280_midi_close,
	cs4280_midi_output,
	0,			/* flush */
	cs4280_midi_getinfo,
	0,			/* ioctl */
};
#endif

	
const struct pci_matchid cs4280_devices[] = {
	{ PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CS4280 },
	{ PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CS4610 },
	{ PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CS4615 },
};

int
cs4280_match(struct device *parent, void *ma, void *aux) 
{
	return (pci_matchbyid((struct pci_attach_args *)aux, cs4280_devices,
	    nitems(cs4280_devices)));
}

int
cs4280_read_codec(void *sc_, u_int8_t add, u_int16_t *data)
{
	struct cs4280_softc *sc = sc_;
	int n;
	
	DPRINTFN(5,("read_codec: add=0x%02x ", add));
	/* 
	 * Make sure that there is not data sitting around from a preivous
	 * uncompleted access.
	 */
	BA0READ4(sc, CS4280_ACSDA);

	/* Set up AC97 control registers. */
	BA0WRITE4(sc, CS4280_ACCAD, add);
	BA0WRITE4(sc, CS4280_ACCDA, 0);
	BA0WRITE4(sc, CS4280_ACCTL, 
	    ACCTL_RSTN | ACCTL_ESYN | ACCTL_VFRM | ACCTL_CRW  | ACCTL_DCV );

	if (cs4280_src_wait(sc) < 0) {
		printf("%s: AC97 read prob. (DCV!=0) for add=0x%02x\n",
		       sc->sc_dev.dv_xname, add);
		return (1);
	}

	/* wait for valid status bit is active */
	n = 0;
	while (!(BA0READ4(sc, CS4280_ACSTS) & ACSTS_VSTS)) {
		delay(1);
		while (++n > 1000) {
			printf("%s: AC97 read fail (VSTS==0) for add=0x%02x\n", 
			       sc->sc_dev.dv_xname, add);
			return (1);
		}
	}
	*data = BA0READ4(sc, CS4280_ACSDA);
	DPRINTFN(5,("data=0x%04x\n", *data));
	return (0);
}

int
cs4280_write_codec(void *sc_, u_int8_t add, u_int16_t data)
{
	struct cs4280_softc *sc = sc_;

	DPRINTFN(5,("write_codec: add=0x%02x  data=0x%04x\n", add, data));
	BA0WRITE4(sc, CS4280_ACCAD, add);
	BA0WRITE4(sc, CS4280_ACCDA, data);
	BA0WRITE4(sc, CS4280_ACCTL, 
	    ACCTL_RSTN | ACCTL_ESYN | ACCTL_VFRM | ACCTL_DCV );

	if (cs4280_src_wait(sc) < 0) {
		printf("%s: AC97 write fail (DCV!=0) for add=0x%02x data="
		       "0x%04x\n", sc->sc_dev.dv_xname, add, data);
		return (1);
	}
	return (0);
}

int
cs4280_src_wait(struct cs4280_softc *sc)
{
	int n;

	n = 0;
	while ((BA0READ4(sc, CS4280_ACCTL) & ACCTL_DCV)) {
		delay(1000);
		if (++n > 1000)
			return (-1);
	}
	return (0);
}


void
cs4280_set_adc_rate(struct cs4280_softc *sc, int rate)
{
	/* calculate capture rate:
	 *
	 * capture_coefficient_increment = -round(rate*128*65536/48000;
	 * capture_phase_increment	 = floor(48000*65536*1024/rate);
	 * cx = round(48000*65536*1024 - capture_phase_increment*rate);
	 * cy = floor(cx/200);
	 * capture_sample_rate_correction = cx - 200*cy;
	 * capture_delay = ceil(24*48000/rate);
	 * capture_num_triplets = floor(65536*rate/24000);
	 * capture_group_length = 24000/GCD(rate, 24000);
	 * where GCD means "Greatest Common Divisor".
	 *
	 * capture_coefficient_increment, capture_phase_increment and
	 * capture_num_triplets are 32-bit signed quantities.
	 * capture_sample_rate_correction and capture_group_length are
	 * 16-bit signed quantities.
	 * capture_delay is a 14-bit unsigned quantity.
	 */
	u_int32_t cci,cpi,cnt,cx,cy,  tmp1;
	u_int16_t csrc, cgl, cdlay;
	
	/* XXX
	 * Even though, embedded_audio_spec says capture rate range 11025 to
	 * 48000, dhwiface.cpp says,
	 *
	 * "We can only decimate by up to a factor of 1/9th the hardware rate.
	 *  Return an error if an attempt is made to stray outside that limit."
	 *
	 * so assume range as 48000/9 to 48000
	 */ 

	if (rate < 8000)
		rate = 8000;
	if (rate > 48000)
		rate = 48000;

	cx = rate << 16;
	cci = cx / 48000;
	cx -= cci * 48000;
	cx <<= 7;
	cci <<= 7;
	cci += cx / 48000;
	cci = - cci;

	cx = 48000 << 16;
	cpi = cx / rate;
	cx -= cpi * rate;
	cx <<= 10;
	cpi <<= 10;
	cy = cx / rate;
	cpi += cy;
	cx -= cy * rate;

	cy   = cx / 200;
	csrc = cx - 200*cy;

	cdlay = ((48000 * 24) + rate - 1) / rate;
#if 0
	cdlay &= 0x3fff; /* make sure cdlay is 14-bit */
#endif

	cnt  = rate << 16;
	cnt  /= 24000;

	cgl = 1;
	for (tmp1 = 2; tmp1 <= 64; tmp1 *= 2) {
		if (((rate / tmp1) * tmp1) != rate)
			cgl *= 2;
	}
	if (((rate / 3) * 3) != rate)
		cgl *= 3;
	for (tmp1 = 5; tmp1 <= 125; tmp1 *= 5) {
		if (((rate / tmp1) * tmp1) != rate) 
			cgl *= 5;
	}
#if 0
	/* XXX what manual says */
	tmp1 = BA1READ4(sc, CS4280_CSRC) & ~CSRC_MASK;
	tmp1 |= csrc<<16;
	BA1WRITE4(sc, CS4280_CSRC, tmp1);
#else
	/* suggested by cs461x.c (ALSA driver) */
	BA1WRITE4(sc, CS4280_CSRC, CS4280_MK_CSRC(csrc, cy));
#endif

#if 0
	/* I am confused.  The sample rate calculation section says
	 * cci *is* 32-bit signed quantity but in the parameter description
	 * section, CCI only assigned 16bit.
	 * I believe size of the variable.
	 */
	tmp1 = BA1READ4(sc, CS4280_CCI) & ~CCI_MASK;
	tmp1 |= cci<<16;
	BA1WRITE4(sc, CS4280_CCI, tmp1);
#else
	BA1WRITE4(sc, CS4280_CCI, cci);
#endif

	tmp1 = BA1READ4(sc, CS4280_CD) & ~CD_MASK;
	tmp1 |= cdlay <<18;
	BA1WRITE4(sc, CS4280_CD, tmp1);
	
	BA1WRITE4(sc, CS4280_CPI, cpi);
	
	tmp1 = BA1READ4(sc, CS4280_CGL) & ~CGL_MASK;
	tmp1 |= cgl;
	BA1WRITE4(sc, CS4280_CGL, tmp1);

	BA1WRITE4(sc, CS4280_CNT, cnt);
	
	tmp1 = BA1READ4(sc, CS4280_CGC) & ~CGC_MASK;
	tmp1 |= cgl;
	BA1WRITE4(sc, CS4280_CGC, tmp1);
}

void
cs4280_set_dac_rate(struct cs4280_softc *sc, int rate)
{
	/*
	 * playback rate may range from 8000Hz to 48000Hz
	 *
	 * play_phase_increment = floor(rate*65536*1024/48000)
	 * px = round(rate*65536*1024 - play_phase_incremnt*48000)
	 * py=floor(px/200)
	 * play_sample_rate_correction = px - 200*py
	 *
	 * play_phase_increment is a 32bit signed quantity.
	 * play_sample_rate_correction is a 16bit signed quantity.
	 */
	int32_t ppi;
	int16_t psrc;
	u_int32_t px, py;
	
	if (rate < 8000)
		rate = 8000;
	if (rate > 48000)
		rate = 48000;
	px = rate << 16;
	ppi = px/48000;
	px -= ppi*48000;
	ppi <<= 10;
	px  <<= 10;
	py  = px / 48000;
	ppi += py;
	px -= py*48000;
	py  = px/200;
	px -= py*200;
	psrc = px;
#if 0
	/* what manual says */
	px = BA1READ4(sc, CS4280_PSRC) & ~PSRC_MASK;
	BA1WRITE4(sc, CS4280_PSRC,
			  ( ((psrc<<16) & PSRC_MASK) | px ));
#else	
	/* suggested by cs461x.c (ALSA driver) */
	BA1WRITE4(sc, CS4280_PSRC, CS4280_MK_PSRC(psrc,py));
#endif
	BA1WRITE4(sc, CS4280_PPI, ppi);
}

void
cs4280_attachhook(struct device *self)
{
	struct cs4280_softc *sc = (struct cs4280_softc *)self;
	mixer_ctrl_t ctl;

	/* Initialization */
	if (cs4280_init2(sc, 1) != 0)
		return;

	printf("%s: firmware loaded\n", sc->sc_dev.dv_xname);

	/* Turn mute off of DAC, CD and master volumes by default */
	ctl.type = AUDIO_MIXER_ENUM;
	ctl.un.ord = 0;	 /* off */

	ctl.dev = cs4280_get_portnum_by_name(sc, AudioCoutputs,
					     AudioNmaster, AudioNmute);
	cs4280_mixer_set_port(sc, &ctl);

	ctl.dev = cs4280_get_portnum_by_name(sc, AudioCinputs,
					     AudioNdac, AudioNmute);
	cs4280_mixer_set_port(sc, &ctl);

	ctl.dev = cs4280_get_portnum_by_name(sc, AudioCinputs,
					     AudioNcd, AudioNmute);
	cs4280_mixer_set_port(sc, &ctl);

	audio_attach_mi(&cs4280_hw_if, sc, &sc->sc_dev);

#if NMIDI > 0
	midi_attach_mi(&cs4280_midi_hw_if, sc, &sc->sc_dev);
#endif
}

void
cs4280_attach(struct device *parent, struct device *self, void *aux)
{
	struct cs4280_softc *sc = (struct cs4280_softc *) self;
	struct pci_attach_args *pa = (struct pci_attach_args *) aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	char const *intrstr;
	pci_intr_handle_t ih;
	u_int32_t mem;
    
	/* Map I/O register */
	if (pci_mapreg_map(pa, CSCC_PCI_BA0, 
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,
	    &sc->ba0t, &sc->ba0h, NULL, NULL, 0)) {
		printf(": can't map BA0 space\n");
		return;
	}
	if (pci_mapreg_map(pa, CSCC_PCI_BA1,
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,
	    &sc->ba1t, &sc->ba1h, NULL, NULL, 0)) {
		printf(": can't map BA1 space\n");
		return;
	}

	sc->sc_dmatag = pa->pa_dmat;

	/* Get out of power save mode if needed. */
	pci_set_powerstate(pc, pa->pa_tag, PCI_PMCSR_STATE_D0);

	/* LATENCY_TIMER setting */
	mem = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);
	if ( PCI_LATTIMER(mem) < 32 ) {
		mem &= 0xffff00ff;
		mem |= 0x00002000;
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG, mem);
	}
	
	/* Map and establish the interrupt. */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		return;
	}
	intrstr = pci_intr_string(pc, ih);

	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO | IPL_MPSAFE,
	    cs4280_intr, sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s\n", intrstr);

	/* Initialization */
	if (cs4280_init(sc, 1) != 0)
		return;

	config_mountroot(self, cs4280_attachhook);

	/* AC 97 attachement */
	sc->host_if.arg = sc;
	sc->host_if.attach = cs4280_attach_codec;
	sc->host_if.read   = cs4280_read_codec;
	sc->host_if.write  = cs4280_write_codec;
	sc->host_if.reset  = cs4280_reset_codec;

	if (ac97_attach(&sc->host_if) != 0) {
		printf("%s: ac97_attach failed\n", sc->sc_dev.dv_xname);
		return;
	}
}

int
cs4280_intr(void *p)
{
	/*
	 * XXX
	 *
	 * Since CS4280 has only 4kB dma buffer and
	 * interrupt occurs every 2kB block, I create dummy buffer
	 * which returns to audio driver and actual dma buffer
	 * using in DMA transfer.
	 *
	 *
	 *  ring buffer in audio.c is pointed by BUFADDR
	 *	 <------ ring buffer size == 64kB ------>
	 *	 <-----> blksize == 2048*(sc->sc_[pr]count) kB 
	 *	|= = = =|= = = =|= = = =|= = = =|= = = =|
	 *	|	|	|	|	|	| <- call audio_intp every
	 *						     sc->sc_[pr]_count time.
	 *
	 *  actual dma buffer is pointed by KERNADDR
	 *	 <-> dma buffer size = 4kB
	 *	|= =|
	 *
	 *
	 */
	struct cs4280_softc *sc = p;
	u_int32_t intr, mem;
	char * empty_dma;
	int handled = 0;

	mtx_enter(&audio_lock);
	/* grab interrupt register then clear it */
	intr = BA0READ4(sc, CS4280_HISR);
	BA0WRITE4(sc, CS4280_HICR, HICR_CHGM | HICR_IEV);

	/* Playback Interrupt */
	if (intr & HISR_PINT) {
		handled = 1;
		mem = BA1READ4(sc, CS4280_PFIE);
		BA1WRITE4(sc, CS4280_PFIE, (mem & ~PFIE_PI_MASK) | PFIE_PI_DISABLE);
		if (sc->sc_pintr) {
			if ((sc->sc_pi%sc->sc_pcount) == 0)
				sc->sc_pintr(sc->sc_parg);
		} else {
			printf("unexpected play intr\n");
		}
		/* copy buffer */
		++sc->sc_pi;
		empty_dma = sc->sc_pdma->addr;
		if (sc->sc_pi&1)
			empty_dma += CS4280_ICHUNK;
		memcpy(empty_dma, sc->sc_pn, CS4280_ICHUNK);
		sc->sc_pn += CS4280_ICHUNK;
		if (sc->sc_pn >= sc->sc_pe)
			sc->sc_pn = sc->sc_ps;
		BA1WRITE4(sc, CS4280_PFIE, mem);
	}
	/* Capture Interrupt */
	if (intr & HISR_CINT) {
		int  i;
		int16_t rdata;

		handled = 1;
		mem = BA1READ4(sc, CS4280_CIE);
		BA1WRITE4(sc, CS4280_CIE, (mem & ~CIE_CI_MASK) | CIE_CI_DISABLE);
		++sc->sc_ri;
		empty_dma = sc->sc_rdma->addr;
		if ((sc->sc_ri&1) == 0)
			empty_dma += CS4280_ICHUNK;

		/*
		 * XXX
		 * I think this audio data conversion should be
		 * happened in upper layer, but I put this here
		 * since there is no conversion function available.
		 */
		switch(sc->sc_rparam) {
		case CF_16BIT_STEREO:
			/* just copy it */
			memcpy(sc->sc_rn, empty_dma, CS4280_ICHUNK);
			sc->sc_rn += CS4280_ICHUNK;
			break;
		case CF_16BIT_MONO:
			for (i = 0; i < 512; i++) {
				rdata  = *((int16_t *)empty_dma)>>1;
				empty_dma += 2;
				rdata += *((int16_t *)empty_dma)>>1;
				empty_dma += 2;
				*((int16_t *)sc->sc_rn) = rdata;
				sc->sc_rn += 2;
			}
			break;
		case CF_8BIT_STEREO:
			for (i = 0; i < 512; i++) {
				rdata = *((int16_t*)empty_dma);
				empty_dma += 2;
				*sc->sc_rn++ = rdata >> 8;
				rdata = *((int16_t*)empty_dma);
				empty_dma += 2;
				*sc->sc_rn++ = rdata >> 8;
			}
			break;
		case CF_8BIT_MONO:
			for (i = 0; i < 512; i++) {
				rdata =	 *((int16_t*)empty_dma) >>1;
				empty_dma += 2;
				rdata += *((int16_t*)empty_dma) >>1;
				empty_dma += 2;
				*sc->sc_rn++ = rdata >>8;
			}
			break;
		default:
			/* Should not reach here */
			printf("unknown sc->sc_rparam: %d\n", sc->sc_rparam);
		}
		if (sc->sc_rn >= sc->sc_re)
			sc->sc_rn = sc->sc_rs;
		BA1WRITE4(sc, CS4280_CIE, mem);
		if (sc->sc_rintr) {
			if ((sc->sc_ri%(sc->sc_rcount)) == 0)
				sc->sc_rintr(sc->sc_rarg);
		} else {
			printf("unexpected record intr\n");
		}
	}

#if NMIDI > 0
	/* Midi port Interrupt */
	if (intr & HISR_MIDI) {
		int data;

		handled = 1;
		DPRINTF(("i: %d: ", 
			 BA0READ4(sc, CS4280_MIDSR)));
		/* Read the received data */
		while ((sc->sc_iintr != NULL) &&
		       ((BA0READ4(sc, CS4280_MIDSR) & MIDSR_RBE) == 0)) {
			data = BA0READ4(sc, CS4280_MIDRP) & MIDRP_MASK;
			DPRINTF(("r:%x\n",data));
			sc->sc_iintr(sc->sc_arg, data);
		}
		
		/* Write the data */
#if 1
		/* XXX:
		 * It seems "Transmit Buffer Full" never activate until EOI
		 * is delivered.  Shall I throw EOI top of this routine ?
		 */
		if ((BA0READ4(sc, CS4280_MIDSR) & MIDSR_TBF) == 0) {
			DPRINTF(("w: "));
			if (sc->sc_ointr != NULL)
				sc->sc_ointr(sc->sc_arg);
		}
#else
		while ((sc->sc_ointr != NULL) && 
		       ((BA0READ4(sc, CS4280_MIDSR) & MIDSR_TBF) == 0)) {
			DPRINTF(("w: "));
			sc->sc_ointr(sc->sc_arg);
		}
#endif
		DPRINTF(("\n"));
	}
#endif
	mtx_leave(&audio_lock);
	return handled;
}


/* Download Proceessor Code and Data image */

int
cs4280_download(struct cs4280_softc *sc, const u_int32_t *src, u_int32_t offset,
    u_int32_t len)
{
	u_int32_t ctr;

#ifdef CS4280_DEBUG
	u_int32_t con, data;
	u_int8_t c0,c1,c2,c3;
#endif
	if ((offset&3) || (len&3))
		return (-1);

	len /= sizeof(u_int32_t);
	for (ctr = 0; ctr < len; ctr++) {
		/* XXX:
		 * I cannot confirm this is the right thing or not
		 * on BIG-ENDIAN machines.
		 */
		BA1WRITE4(sc, offset+ctr*4, htole32(*(src+ctr)));
#ifdef CS4280_DEBUG
		data = htole32(*(src+ctr));
		c0 = bus_space_read_1(sc->ba1t, sc->ba1h, offset+ctr*4+0);
		c1 = bus_space_read_1(sc->ba1t, sc->ba1h, offset+ctr*4+1);
		c2 = bus_space_read_1(sc->ba1t, sc->ba1h, offset+ctr*4+2);
		c3 = bus_space_read_1(sc->ba1t, sc->ba1h, offset+ctr*4+3);
		con = ( (c3<<24) | (c2<<16) | (c1<<8) | c0 );
		if (data != con ) {
			printf("0x%06x: write=0x%08x read=0x%08x\n",
			       offset+ctr*4, data, con);
			return (-1);
		}
#endif
	}
	return (0);
}

struct BA1struct *BA1Struct;

int
cs4280_download_image(struct cs4280_softc *sc)
{
	int idx, err = 0;
	u_int32_t offset = 0;
	static u_char *cs4280_firmware;
	static size_t cs4280_firmwarelen;

	if (cs4280_firmware == NULL) {
		err = loadfirmware("cs4280", &cs4280_firmware,
		    &cs4280_firmwarelen);
		if (err)
			return (err);
	}

	BA1Struct = (struct BA1struct *)cs4280_firmware;

	for (idx = 0; idx < BA1_MEMORY_COUNT; ++idx) {
		err = cs4280_download(sc, &BA1Struct->map[offset],
		    BA1Struct->memory[idx].offset, BA1Struct->memory[idx].size);
		if (err != 0) {
			printf("%s: load_image failed at %d\n",
			       sc->sc_dev.dv_xname, idx);
			return (-1);
		}
		offset += BA1Struct->memory[idx].size / sizeof(u_int32_t);
	}
	return (err);
}

#ifdef CS4280_DEBUG
int
cs4280_checkimage(struct cs4280_softc *sc, u_int32_t *src, u_int32_t offset,
    u_int32_t len)
{
	u_int32_t ctr, data;
	int err = 0;

	if ((offset&3) || (len&3))
		return -1;

	len /= sizeof(u_int32_t);
	for (ctr = 0; ctr < len; ctr++) {
		/* I cannot confirm this is the right thing
		 * on BIG-ENDIAN machines
		 */
		data = BA1READ4(sc, offset+ctr*4);
		if (data != htole32(*(src+ctr))) {
			printf("0x%06x: 0x%08x(0x%08x)\n",
			       offset+ctr*4, data, *(src+ctr));
			*(src+ctr) = data;
			++err;
		}
	}
	return (err);
}

int
cs4280_check_images(struct cs4280_softc *sc)
{
	int idx, err;
	u_int32_t offset = 0;

	err = 0;
	/*for (idx=0; idx < BA1_MEMORY_COUNT; ++idx) { */
	for (idx = 0; idx < 1; ++idx) {
		err = cs4280_checkimage(sc, &BA1Struct->map[offset],
		    BA1Struct->memory[idx].offset,
		    BA1Struct->memory[idx].size);
		if (err != 0) {
			printf("%s: check_image failed at %d\n",
			       sc->sc_dev.dv_xname, idx);
		}
		offset += BA1Struct->memory[idx].size / sizeof(u_int32_t);
	}
	return (err);
}

#endif

int
cs4280_attach_codec(void *sc_, struct ac97_codec_if *codec_if)
{
	struct cs4280_softc *sc = sc_;

	sc->codec_if = codec_if;
	return (0);
}

void
cs4280_reset_codec(void *sc_)
{
	struct cs4280_softc *sc = sc_;
	int n;

	/* Reset codec */
	BA0WRITE4(sc, CS4280_ACCTL, 0);
	delay(100);    /* delay 100us */
	BA0WRITE4(sc, CS4280_ACCTL, ACCTL_RSTN);

	/* 
	 * It looks like we do the following procedure, too
	 */

	/* Enable AC-link sync generation */
	BA0WRITE4(sc, CS4280_ACCTL, ACCTL_ESYN | ACCTL_RSTN);
	delay(50*1000); /* XXX delay 50ms */
	
	/* Assert valid frame signal */
	BA0WRITE4(sc, CS4280_ACCTL, ACCTL_VFRM | ACCTL_ESYN | ACCTL_RSTN);

	/* Wait for valid AC97 input slot */
	n = 0;
	while (BA0READ4(sc, CS4280_ACISV) != (ACISV_ISV3 | ACISV_ISV4)) {
		delay(1000);
		if (++n > 1000) {
			printf("reset_codec: AC97 inputs slot ready timeout\n");
			return;
		}
	}
}


/* Processor Soft Reset */
void
cs4280_reset(void *sc_)
{
	struct cs4280_softc *sc = sc_;

	/* Set RSTSP bit in SPCR (also clear RUN, RUNFR, and DRQEN) */
	BA1WRITE4(sc, CS4280_SPCR, SPCR_RSTSP);
	delay(100);
	/* Clear RSTSP bit in SPCR */
	BA1WRITE4(sc, CS4280_SPCR, 0);
	/* enable DMA reqest */
	BA1WRITE4(sc, CS4280_SPCR, SPCR_DRQEN);
}

int
cs4280_open(void *addr, int flags)
{
	return (0);
}

void
cs4280_close(void *addr)
{
	struct cs4280_softc *sc = addr;
	
	/* XXX: already called in audio_close() */
	cs4280_halt_output(sc);
	cs4280_halt_input(sc);
	
	sc->sc_pintr = 0;
	sc->sc_rintr = 0;
}

int
cs4280_set_params(void *addr, int setmode, int usemode,
    struct audio_params *play, struct audio_params *rec)
{
	struct cs4280_softc *sc = addr;
	struct audio_params *p;
	int mode;

	for (mode = AUMODE_RECORD; mode != -1;
	    mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1 ) {
		if ((setmode & mode) == 0)
			continue;
		
		p = mode == AUMODE_PLAY ? play : rec;		
		if (p == play) {
			DPRINTFN(5,("play: sample=%ld precision=%d channels=%d\n",
				p->sample_rate, p->precision, p->channels));
		} else {
			DPRINTFN(5,("rec: sample=%ld precision=%d channels=%d\n",
				p->sample_rate, p->precision, p->channels));
		}
		/* play back data format may be 8- or 16-bit and
		 * either stereo or mono.
		 * playback rate may range from 8000Hz to 48000Hz 
		 *
	         * capture data format must be 16bit stereo
		 * and sample rate range from 11025Hz to 48000Hz.
		 *
		 * XXX: it looks like to work with 8000Hz,
		 *	although data sheets say lower limit is
		 *	11025 Hz.
		 */
		if (p->sample_rate < 8000)
			p->sample_rate = 8000;
		if (p->sample_rate > 48000)
			p->sample_rate = 48000;
		if (p->precision > 16)
			p->precision = 16;
		if (p->channels > 2)
			p->channels = 2;

		/* capturing data is slinear */
		switch (p->encoding) {
		case AUDIO_ENCODING_SLINEAR_LE:
			break;
		default:
			return (EINVAL);
		}
		p->bps = AUDIO_BPS(p->precision);
		p->msb = 1;
	}

	/* set sample rate */
	cs4280_set_dac_rate(sc, play->sample_rate);
	cs4280_set_adc_rate(sc, rec->sample_rate);
	return (0);
}

int
cs4280_round_blocksize(void *hdl, int blk)
{
	return (blk < CS4280_ICHUNK ? CS4280_ICHUNK : blk & -CS4280_ICHUNK);
}

size_t
cs4280_round_buffersize(void *addr, int direction, size_t size)
{
	/* although real dma buffer size is 4KB, 
	 * let the audio.c driver use a larger buffer.
	 * ( suggested by Lennart Augustsson. )
	 */
	return (size);
}

int
cs4280_get_props(void *hdl)
{
	return (AUDIO_PROP_INDEPENDENT | AUDIO_PROP_FULLDUPLEX); 
#ifdef notyet
	/* XXX 
	 * How can I mmap ?
	 */
		AUDIO_PROP_MMAP 
#endif
	    
}

int
cs4280_mixer_get_port(void *addr, mixer_ctrl_t *cp)
{
	struct cs4280_softc *sc = addr;

	return (sc->codec_if->vtbl->mixer_get_port(sc->codec_if, cp));
}

int
cs4280_query_devinfo(void *addr, mixer_devinfo_t *dip)
{
	struct cs4280_softc *sc = addr;

	return (sc->codec_if->vtbl->query_devinfo(sc->codec_if, dip));
}

int
cs4280_get_portnum_by_name(struct cs4280_softc *sc, char *class, char *device,
    char *qualifier)
{
	return (sc->codec_if->vtbl->get_portnum_by_name(sc->codec_if, class,
	     device, qualifier));
}

int
cs4280_halt_output(void *addr)
{
	struct cs4280_softc *sc = addr;
	u_int32_t mem;
	
	mtx_enter(&audio_lock);
	mem = BA1READ4(sc, CS4280_PCTL);
	BA1WRITE4(sc, CS4280_PCTL, mem & ~PCTL_MASK);
#ifdef DIAGNOSTIC
	sc->sc_prun = 0;
#endif
	mtx_leave(&audio_lock);
	return (0);
}

int
cs4280_halt_input(void *addr)
{
	struct cs4280_softc *sc = addr;
	u_int32_t mem;

	mtx_enter(&audio_lock);
	mem = BA1READ4(sc, CS4280_CCTL);
	BA1WRITE4(sc, CS4280_CCTL, mem & ~CCTL_MASK);
#ifdef DIAGNOSTIC
	sc->sc_rrun = 0;
#endif
	mtx_leave(&audio_lock);
	return (0);
}

int
cs4280_mixer_set_port(void *addr, mixer_ctrl_t *cp)
{
	struct cs4280_softc *sc = addr;
	int val;

	val = sc->codec_if->vtbl->mixer_set_port(sc->codec_if, cp);
	DPRINTFN(3,("mixer_set_port: val=%d\n", val));
	return (val);
}


int
cs4280_freemem(struct cs4280_softc *sc, struct cs4280_dma *p)
{
	bus_dmamap_unload(sc->sc_dmatag, p->map);
	bus_dmamap_destroy(sc->sc_dmatag, p->map);
	bus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);
	bus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);
	return (0);
}

int
cs4280_allocmem(struct cs4280_softc *sc, size_t size, size_t align,
    struct cs4280_dma *p)
{
	int error;

	/* XXX */
	p->size = size;
	error = bus_dmamem_alloc(sc->sc_dmatag, p->size, align, 0,
				 p->segs, sizeof(p->segs)/sizeof(p->segs[0]),
				 &p->nsegs, BUS_DMA_NOWAIT);
	if (error) {
		printf("%s: unable to allocate dma, error=%d\n",
		       sc->sc_dev.dv_xname, error);
		return (error);
	}
	
	error = bus_dmamem_map(sc->sc_dmatag, p->segs, p->nsegs, p->size, 
			       &p->addr, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);
	if (error) {
		printf("%s: unable to map dma, error=%d\n",
		       sc->sc_dev.dv_xname, error);
		goto free;
	}

	error = bus_dmamap_create(sc->sc_dmatag, p->size, 1, p->size,
				  0, BUS_DMA_NOWAIT, &p->map);
	if (error) {
		printf("%s: unable to create dma map, error=%d\n",
		       sc->sc_dev.dv_xname, error);
		goto unmap;
	}

	error = bus_dmamap_load(sc->sc_dmatag, p->map, p->addr, p->size, NULL, 
				BUS_DMA_NOWAIT);
	if (error) {
		printf("%s: unable to load dma map, error=%d\n",
		       sc->sc_dev.dv_xname, error);
		goto destroy;
	}
	return (0);

destroy:
	bus_dmamap_destroy(sc->sc_dmatag, p->map);
unmap:
	bus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);
free:
	bus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);
	return (error);
}


void *
cs4280_malloc(void *addr, int direction, size_t size, int pool, int flags)
{
	struct cs4280_softc *sc = addr;
	struct cs4280_dma *p;
	caddr_t q;
	int error;
	
	DPRINTFN(5,("cs4280_malloc: size=%d pool=%d flags=%d\n", size, pool, flags));
	q = malloc(size, pool, flags);
	if (!q) 
		return (0);
	p = malloc(sizeof(*p), pool, flags);
	if (!p) {
		free(q,pool, 0);
		return (0);
	}
	/* 
	 * cs4280 has fixed 4kB buffer
	 */
	error = cs4280_allocmem(sc, CS4280_DCHUNK, CS4280_DALIGN, p);

	if (error) {
		free(q, pool, 0);
		free(p, pool, 0);
		return (0);
	}

	p->next = sc->sc_dmas;
	sc->sc_dmas = p;
	p->dum = q; /* return to audio driver */

	return (p->dum);
}

void
cs4280_free(void *addr, void *ptr, int pool)
{
	struct cs4280_softc *sc = addr;
	struct cs4280_dma **pp, *p;
	
	for (pp = &sc->sc_dmas; (p = *pp) != NULL; pp = &p->next) {
		if (BUFADDR(p) == ptr) {
			cs4280_freemem(sc, p);
			*pp = p->next;
			free(p->dum, pool, 0);
			free(p, pool, 0);
			return;
		}
	}
}

int
cs4280_trigger_output(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct cs4280_softc *sc = addr;
	u_int32_t pfie, pctl, mem, pdtc;
	struct cs4280_dma *p;
	
#ifdef DIAGNOSTIC
	if (sc->sc_prun)
		printf("cs4280_trigger_output: already running\n");
	sc->sc_prun = 1;
#endif
	DPRINTF(("cs4280_trigger_output: sc=%p start=%p end=%p "
	    "blksize=%d intr=%p(%p)\n", addr, start, end, blksize, intr, arg));
	sc->sc_pintr = intr;
	sc->sc_parg  = arg;

	/* stop playback DMA */
	mem = BA1READ4(sc, CS4280_PCTL);
	BA1WRITE4(sc, CS4280_PCTL, mem & ~PCTL_MASK);

	/* setup PDTC */
	pdtc = BA1READ4(sc, CS4280_PDTC);
	pdtc &= ~PDTC_MASK;
	pdtc |= CS4280_MK_PDTC(param->precision * param->channels);
	BA1WRITE4(sc, CS4280_PDTC, pdtc);
	
	DPRINTF(("param: precision=%d  channels=%d encoding=%d\n",
	       param->precision, param->channels,
	       param->encoding));
	for (p = sc->sc_dmas; p != NULL && BUFADDR(p) != start; p = p->next)
		;
	if (p == NULL) {
		printf("cs4280_trigger_output: bad addr %p\n", start);
		return (EINVAL);
	}
	if (DMAADDR(p) % CS4280_DALIGN != 0 ) {
		printf("cs4280_trigger_output: DMAADDR(p)=0x%lx does not start"
		       "4kB align\n", DMAADDR(p));
		return (EINVAL);
	}

	sc->sc_pcount = blksize / CS4280_ICHUNK; /* CS4280_ICHUNK is fixed hardware blksize*/
	sc->sc_ps = (char *)start;
	sc->sc_pe = (char *)end;
	sc->sc_pdma = p;
	sc->sc_pbuf = KERNADDR(p);
	sc->sc_pi = 0;
	sc->sc_pn = sc->sc_ps;
	if (blksize >= CS4280_DCHUNK) {
		sc->sc_pn = sc->sc_ps + CS4280_DCHUNK;
		memcpy(sc->sc_pbuf, start, CS4280_DCHUNK);
		++sc->sc_pi;
	} else {
		sc->sc_pn = sc->sc_ps + CS4280_ICHUNK;
		memcpy(sc->sc_pbuf, start, CS4280_ICHUNK);
	}

	/* initiate playback dma */
	mtx_enter(&audio_lock);
	BA1WRITE4(sc, CS4280_PBA, DMAADDR(p));

	/* set PFIE */
	pfie = BA1READ4(sc, CS4280_PFIE) & ~PFIE_MASK;

	if (param->precision == 8)
		pfie |= PFIE_8BIT;
	if (param->channels == 1)
		pfie |= PFIE_MONO;

	if (param->encoding == AUDIO_ENCODING_ULINEAR_BE ||
	    param->encoding == AUDIO_ENCODING_SLINEAR_BE)
		pfie |= PFIE_SWAPPED;
	if (param->encoding == AUDIO_ENCODING_ULINEAR_BE ||
	    param->encoding == AUDIO_ENCODING_ULINEAR_LE)
		pfie |= PFIE_UNSIGNED;

	BA1WRITE4(sc, CS4280_PFIE, pfie | PFIE_PI_ENABLE);

	cs4280_set_dac_rate(sc, param->sample_rate);

	pctl = BA1READ4(sc, CS4280_PCTL) & ~PCTL_MASK;
	pctl |= sc->pctl;
	BA1WRITE4(sc, CS4280_PCTL, pctl);
	mtx_leave(&audio_lock);
	return (0);
}

int
cs4280_trigger_input(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct cs4280_softc *sc = addr;
	u_int32_t cctl, cie;
	struct cs4280_dma *p;
	
#ifdef DIAGNOSTIC
	if (sc->sc_rrun)
		printf("cs4280_trigger_input: already running\n");
	sc->sc_rrun = 1;
#endif
	DPRINTF(("cs4280_trigger_input: sc=%p start=%p end=%p "
	    "blksize=%d intr=%p(%p)\n", addr, start, end, blksize, intr, arg));
	sc->sc_rintr = intr;
	sc->sc_rarg  = arg;

	sc->sc_ri = 0;
	sc->sc_rcount = blksize / CS4280_ICHUNK; /* CS4280_ICHUNK is fixed hardware blksize*/
	sc->sc_rs = (char *)start;
	sc->sc_re = (char *)end;
	sc->sc_rn = sc->sc_rs;

	/* setup format information for internal converter */
	sc->sc_rparam = 0;
	if (param->precision == 8) {
		sc->sc_rparam += CF_8BIT;
		sc->sc_rcount <<= 1;
	}
	if (param->channels  == 1) {
		sc->sc_rparam += CF_MONO;
		sc->sc_rcount <<= 1;
	}

	/* stop capture DMA */
	cctl = BA1READ4(sc, CS4280_CCTL) & ~CCTL_MASK;
	BA1WRITE4(sc, CS4280_CCTL, cctl);
	
	for (p = sc->sc_dmas; p && BUFADDR(p) != start; p = p->next)
		;
	if (!p) {
		printf("cs4280_trigger_input: bad addr %p\n", start);
		return (EINVAL);
	}
	if (DMAADDR(p) % CS4280_DALIGN != 0) {
		printf("cs4280_trigger_input: DMAADDR(p)=0x%lx does not start"
		       "4kB align\n", DMAADDR(p));
		return (EINVAL);
	}
	sc->sc_rdma = p;
	sc->sc_rbuf = KERNADDR(p);
	
	/* initiate capture dma */
	mtx_enter(&audio_lock);
	BA1WRITE4(sc, CS4280_CBA, DMAADDR(p));

	/* set CIE */
	cie = BA1READ4(sc, CS4280_CIE) & ~CIE_CI_MASK;
	BA1WRITE4(sc, CS4280_CIE, cie | CIE_CI_ENABLE);

	cs4280_set_adc_rate(sc, param->sample_rate);

	cctl = BA1READ4(sc, CS4280_CCTL) & ~CCTL_MASK;
	cctl |= sc->cctl;
	BA1WRITE4(sc, CS4280_CCTL, cctl);
	mtx_leave(&audio_lock);
	return (0);
}


int
cs4280_init(struct cs4280_softc *sc, int init)
{
	int n;
	u_int32_t mem;

	/* Start PLL out in known state */
	BA0WRITE4(sc, CS4280_CLKCR1, 0);
	/* Start serial ports out in known state */
	BA0WRITE4(sc, CS4280_SERMC1, 0);

	/* Specify type of CODEC */
/* XXX should no be here */
#define SERACC_CODEC_TYPE_1_03
#ifdef	SERACC_CODEC_TYPE_1_03
	BA0WRITE4(sc, CS4280_SERACC, SERACC_HSP | SERACC_CTYPE_1_03); /* AC 97 1.03 */
#else
	BA0WRITE4(sc, CS4280_SERACC, SERACC_HSP | SERACC_CTYPE_2_0);  /* AC 97 2.0 */
#endif

	/* Reset codec */
	BA0WRITE4(sc, CS4280_ACCTL, 0);
	delay(100);    /* delay 100us */
	BA0WRITE4(sc, CS4280_ACCTL, ACCTL_RSTN);
	
	/* Enable AC-link sync generation */
	BA0WRITE4(sc, CS4280_ACCTL, ACCTL_ESYN | ACCTL_RSTN);
	delay(50*1000); /* delay 50ms */

	/* Set the serial port timing configuration */
	BA0WRITE4(sc, CS4280_SERMC1, SERMC1_PTC_AC97);
	
	/* Setup clock control */
	BA0WRITE4(sc, CS4280_PLLCC, PLLCC_CDR_STATE|PLLCC_LPF_STATE);
	BA0WRITE4(sc, CS4280_PLLM, PLLM_STATE);
	BA0WRITE4(sc, CS4280_CLKCR2, CLKCR2_PDIVS_8);
	
	/* Power up the PLL */
	BA0WRITE4(sc, CS4280_CLKCR1, CLKCR1_PLLP);
	delay(50*1000); /* delay 50ms */
	
	/* Turn on clock */
	mem = BA0READ4(sc, CS4280_CLKCR1) | CLKCR1_SWCE;
	BA0WRITE4(sc, CS4280_CLKCR1, mem);
	
	/* Set the serial port FIFO pointer to the
	 * first sample in FIFO. (not documented) */
	cs4280_clear_fifos(sc);

#if 0
	/* Set the serial port FIFO pointer to the first sample in the FIFO */
	BA0WRITE4(sc, CS4280_SERBSP, 0);
#endif
	
	/* Configure the serial port */
	BA0WRITE4(sc, CS4280_SERC1,  SERC1_SO1EN | SERC1_SO1F_AC97);
	BA0WRITE4(sc, CS4280_SERC2,  SERC2_SI1EN | SERC2_SI1F_AC97);
	BA0WRITE4(sc, CS4280_SERMC1, SERMC1_MSPE | SERMC1_PTC_AC97);
	
	/* Wait for CODEC ready */
	n = 0;
	while ((BA0READ4(sc, CS4280_ACSTS) & ACSTS_CRDY) == 0) {
		delay(125);
		if (++n > 1000) {
			printf("%s: codec ready timeout\n",
			       sc->sc_dev.dv_xname);
			return(1);
		}
	}

	/* Assert valid frame signal */
	BA0WRITE4(sc, CS4280_ACCTL, ACCTL_VFRM | ACCTL_ESYN | ACCTL_RSTN);

	/* Wait for valid AC97 input slot */
	n = 0;
	while ((BA0READ4(sc, CS4280_ACISV) & (ACISV_ISV3 | ACISV_ISV4)) !=
	       (ACISV_ISV3 | ACISV_ISV4)) {
		delay(1000);
		if (++n > 1000) {
			printf("AC97 inputs slot ready timeout\n");
			return(1);
		}
	}
	
	/* Set AC97 output slot valid signals */
	BA0WRITE4(sc, CS4280_ACOSV, ACOSV_SLV3 | ACOSV_SLV4);

	/* reset the processor */
	cs4280_reset(sc);
	return (0);
}

int
cs4280_init2(struct cs4280_softc *sc, int init)
{
	int n;
	u_int32_t mem;

	/* Download the image to the processor */
	if (cs4280_download_image(sc) != 0) {
		printf("%s: image download error\n", sc->sc_dev.dv_xname);
		return(1);
	}

	/* Save playback parameter and then write zero.
	 * this ensures that DMA doesn't immediately occur upon
	 * starting the processor core 
	 */
	mem = BA1READ4(sc, CS4280_PCTL);
	sc->pctl = mem & PCTL_MASK; /* save startup value */
	cs4280_halt_output(sc);
	
	/* Save capture parameter and then write zero.
	 * this ensures that DMA doesn't immediately occur upon
	 * starting the processor core 
	 */
	mem = BA1READ4(sc, CS4280_CCTL);
	sc->cctl = mem & CCTL_MASK; /* save startup value */
	cs4280_halt_input(sc);

	/* MSH: need to power up ADC and DAC? */

	/* Processor Startup Procedure */
	BA1WRITE4(sc, CS4280_FRMT, FRMT_FTV);
	BA1WRITE4(sc, CS4280_SPCR, SPCR_RUN | SPCR_RUNFR | SPCR_DRQEN);

	/* Monitor RUNFR bit in SPCR for 1 to 0 transition */
	n = 0;
	while (BA1READ4(sc, CS4280_SPCR) & SPCR_RUNFR) {
		delay(10);
		if (++n > 1000) {
			printf("SPCR 1->0 transition timeout\n");
			return(1);
		}
	}
	
	n = 0;
	while (!(BA1READ4(sc, CS4280_SPCS) & SPCS_SPRUN)) {
		delay(10);
		if (++n > 1000) {
			printf("SPCS 0->1 transition timeout\n");
			return(1);
		}
	}
	/* Processor is now running !!! */

	/* Setup  volume */
	BA1WRITE4(sc, CS4280_PVOL, 0x80008000);
	BA1WRITE4(sc, CS4280_CVOL, 0x80008000);

	/* Interrupt enable */
	BA0WRITE4(sc, CS4280_HICR, HICR_IEV|HICR_CHGM);

	/* playback interrupt enable */
	mem = BA1READ4(sc, CS4280_PFIE) & ~PFIE_PI_MASK;
	mem |= PFIE_PI_ENABLE;
	BA1WRITE4(sc, CS4280_PFIE, mem);
	/* capture interrupt enable */
	mem = BA1READ4(sc, CS4280_CIE) & ~CIE_CI_MASK;
	mem |= CIE_CI_ENABLE;
	BA1WRITE4(sc, CS4280_CIE, mem);

#if NMIDI > 0
	/* Reset midi port */
	mem = BA0READ4(sc, CS4280_MIDCR) & ~MIDCR_MASK;
	BA0WRITE4(sc, CS4280_MIDCR, mem | MIDCR_MRST);
	DPRINTF(("midi reset: 0x%x\n", BA0READ4(sc, CS4280_MIDCR)));
	/* midi interrupt enable */
	mem |= MIDCR_TXE | MIDCR_RXE | MIDCR_RIE | MIDCR_TIE;
	BA0WRITE4(sc, CS4280_MIDCR, mem);
#endif
	return(0);
}

int
cs4280_activate(struct device *self, int act)
{
	struct cs4280_softc *sc = (struct cs4280_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		/* should I powerdown here ? */
		cs4280_write_codec(sc, AC97_REG_POWER, CS4280_POWER_DOWN_ALL);
		break;
	case DVACT_RESUME:
		cs4280_close(sc);
		cs4280_init(sc, 0);
		cs4280_init2(sc, 0);
		ac97_resume(&sc->host_if, sc->codec_if);
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

void
cs4280_clear_fifos(struct cs4280_softc *sc)
{
	int pd = 0, cnt, n;
	u_int32_t mem;
	
	/* 
	 * If device power down, power up the device and keep power down
	 * state.
	 */
	mem = BA0READ4(sc, CS4280_CLKCR1);
	if (!(mem & CLKCR1_SWCE)) {
		printf("cs4280_clear_fifo: power down found.\n");
		BA0WRITE4(sc, CS4280_CLKCR1, mem | CLKCR1_SWCE);
		pd = 1;
	}
	BA0WRITE4(sc, CS4280_SERBWP, 0);
	for (cnt = 0; cnt < 256; cnt++) {
		n = 0;
		while (BA0READ4(sc, CS4280_SERBST) & SERBST_WBSY) {
			delay(1000);
			if (++n > 1000) {
				printf("clear_fifo: fist timeout cnt=%d\n", cnt);
				break;
			}
		}
		BA0WRITE4(sc, CS4280_SERBAD, cnt);
		BA0WRITE4(sc, CS4280_SERBCM, SERBCM_WRC);
	}
	if (pd)
		BA0WRITE4(sc, CS4280_CLKCR1, mem);
}

#if NMIDI > 0
int
cs4280_midi_open(void *addr, int flags, void (*iintr)(void, int),
    void (*ointr)(void *), void *arg)
{
	struct cs4280_softc *sc = addr;
	u_int32_t mem;

	DPRINTF(("midi_open\n"));
	sc->sc_iintr = iintr;
	sc->sc_ointr = ointr;
	sc->sc_arg = arg;

	/* midi interrupt enable */
	mem = BA0READ4(sc, CS4280_MIDCR) & ~MIDCR_MASK;
	mem |= MIDCR_TXE | MIDCR_RXE | MIDCR_RIE | MIDCR_TIE | MIDCR_MLB;
	BA0WRITE4(sc, CS4280_MIDCR, mem);
#ifdef CS4280_DEBUG
	if (mem != BA0READ4(sc, CS4280_MIDCR)) {
		DPRINTF(("midi_open: MIDCR=%d\n", BA0READ4(sc, CS4280_MIDCR)));
		return(EINVAL);
	}
	DPRINTF(("MIDCR=0x%x\n", BA0READ4(sc, CS4280_MIDCR)));
#endif
	return (0);
}

void
cs4280_midi_close(void *addr)
{
	struct cs4280_softc *sc = addr;
	u_int32_t mem;
	
	DPRINTF(("midi_close\n"));
	mem = BA0READ4(sc, CS4280_MIDCR);
	mem &= ~MIDCR_MASK;
	BA0WRITE4(sc, CS4280_MIDCR, mem);

	sc->sc_iintr = 0;
	sc->sc_ointr = 0;
}

int
cs4280_midi_output(void *addr, int d)
{
	struct cs4280_softc *sc = addr;
	u_int32_t mem;
	int x;

	for (x = 0; x != MIDI_BUSY_WAIT; x++) {
		if ((BA0READ4(sc, CS4280_MIDSR) & MIDSR_TBF) == 0) {
			mem = BA0READ4(sc, CS4280_MIDWP) & ~MIDWP_MASK;
			mem |= d & MIDWP_MASK;
			DPRINTFN(5,("midi_output d=0x%08x",d));
			BA0WRITE4(sc, CS4280_MIDWP, mem);
			if (mem != BA0READ4(sc, CS4280_MIDWP)) {
				DPRINTF(("Bad write data: %d %d",
					 mem, BA0READ4(sc, CS4280_MIDWP)));
				return(EIO);
			}
			return (0);
		}
		delay(MIDI_BUSY_DELAY);
	}
	return (EIO);
}

void
cs4280_midi_getinfo(void *addr, struct midi_info *mi)
{
	mi->name = "CS4280 MIDI UART";
	mi->props = MIDI_PROP_CAN_INPUT | MIDI_PROP_OUT_INTR;
}

#endif
@


1.50
log
@Remove unused getdev() audio driver functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.49 2016/09/14 06:12:19 ratchov Exp $	*/
d706 1
a706 1
		 * happend in upper layer, but I put this here
@


1.49
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.47 2015/05/11 06:46:22 ratchov Exp $	*/
a203 2
int	cs4280_getdev(void *, struct audio_device *);

a249 1
	cs4280_getdev,
a273 7

struct audio_device cs4280_device = {
	"CS4280",
	"",
	"cs4280"
};

a1138 7
	return (0);
}

int
cs4280_getdev(void *addr, struct audio_device *retp)
{
	*retp = cs4280_device;
@


1.48
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@a197 1
int	cs4280_query_encoding(void *, struct audio_encoding *);
a199 1
void	cs4280_get_default_params(void *, int, struct audio_params *);
a211 1
paddr_t	cs4280_mappage(void *, void *, off_t, int);
a241 2
	NULL,
	cs4280_query_encoding,
a259 1
	0, /* cs4280_mappage, */
d262 1
a262 2
	cs4280_trigger_input,
	cs4280_get_default_params
a1009 19
cs4280_query_encoding(void *addr, struct audio_encoding *fp)
{
	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	default:
		return (EINVAL);
	}
	fp->bps = AUDIO_BPS(fp->precision);
	fp->msb = 1;

	return (0);
}

int
a1082 6
void
cs4280_get_default_params(void *addr, int mode, struct audio_params *params)
{
	ac97_get_default_params(params);
}

a1102 19

paddr_t
cs4280_mappage(void *addr, void *mem, off_t off, int prot)
{
	struct cs4280_softc *sc = addr;
	struct cs4280_dma *p;

	if (off < 0)
		return (-1);
	for (p = sc->sc_dmas; p && BUFADDR(p) != mem; p = p->next)
		;
	if (!p) {
		DPRINTF(("cs4280_mappage: bad buffer address\n"));
		return (-1);
	}
	return (bus_dmamem_mmap(sc->sc_dmatag, p->segs, p->nsegs, 
				off, prot, BUS_DMA_WAITOK));
}

@


1.47
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.46 2015/03/14 03:38:48 jsg Exp $	*/
d168 1
a168 1
void	cs4280_attachhook(void *xsc);
d542 1
a542 1
cs4280_attachhook(void *xsc)
d544 1
a544 1
	struct cs4280_softc *sc = xsc;
d568 1
a568 1
	
d635 1
a635 1
	mountroothook_establish(cs4280_attachhook, sc);
@


1.46
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.45 2014/07/12 18:48:51 tedu Exp $	*/
a80 2
#include <dev/mulaw.h>
#include <dev/auconv.h>
a1020 24
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 1:
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 2:
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 3:
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 4:
a1025 18
	case 5:
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	case 6:
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	case 7:
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = 0;
		break;
a1074 2
		p->factor  = 1;
		p->sw_code = 0;
a1077 6
		case AUDIO_ENCODING_SLINEAR_BE:
			if (mode == AUMODE_RECORD) {
				if (p->precision == 16)
					p->sw_code = swap_bytes;
			}
			break;
a1079 32
		case AUDIO_ENCODING_ULINEAR_BE:
			if (mode == AUMODE_RECORD) {
				if (p->precision == 16)
					p->sw_code = change_sign16_swap_bytes_le;
				else
					p->sw_code = change_sign8;
			}
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			if (mode == AUMODE_RECORD) {
				if (p->precision == 16)
					p->sw_code = change_sign16_le;
				else
					p->sw_code = change_sign8;
			}
			break;
		case AUDIO_ENCODING_ULAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = mulaw_to_slinear16_le;
			} else {
				p->sw_code = slinear8_to_mulaw;
			}
			break;
		case AUDIO_ENCODING_ALAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = alaw_to_slinear16_le;
			} else {
				p->sw_code = slinear8_to_alaw;
			}
			break;
d1364 2
a1365 2
	DPRINTF(("param: precision=%d  factor=%d channels=%d encoding=%d\n",
	       param->precision, param->factor, param->channels,
d1402 1
a1402 1
	if (param->precision * param->factor == 8)
@


1.45
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.44 2013/12/06 21:03:03 deraadt Exp $	*/
a80 1
#include <dev/midi_if.h>
@


1.44
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.43 2013/05/24 07:58:46 ratchov Exp $	*/
d1383 1
a1383 1
		free(q,pool);
d1392 2
a1393 2
		free(q, pool);
		free(p, pool);
d1414 2
a1415 2
			free(p->dum, pool);
			free(p, pool);
@


1.43
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.42 2013/05/15 08:29:24 ratchov Exp $	*/
a1761 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
d1773 2
a1774 1
 	case DVACT_DEACTIVATE:
@


1.42
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.41 2012/01/11 16:22:33 dhill Exp $	*/
d623 2
a624 2
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO, cs4280_intr, sc,
				       sc->sc_dev.dv_xname);
@


1.41
log
@ansify and de'register some prototypes

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.40 2011/07/03 15:47:17 matthew Exp $	*/
d683 1
d816 1
a816 1

d1011 1
d1262 1
d1268 1
d1278 1
d1284 1
a1433 1

d1481 1
d1506 1
d1564 1
d1576 1
@


1.40
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.39 2011/04/03 15:36:02 jasper Exp $	*/
d301 1
a301 4
cs4280_match(parent, ma, aux) 
	struct device *parent;
	void *ma;
	void *aux;
d308 1
a308 4
cs4280_read_codec(sc_, add, data)
	void *sc_;
	u_int8_t add;
	u_int16_t *data;
d348 1
a348 4
cs4280_write_codec(sc_, add, data)
	void *sc_;
	u_int8_t add;
	u_int16_t data;
d367 1
a367 2
cs4280_src_wait(sc)
	struct cs4280_softc *sc;
d382 1
a382 3
cs4280_set_adc_rate(sc, rate)
	struct cs4280_softc *sc;
	int rate;
d500 1
a500 3
cs4280_set_dac_rate(sc, rate)
	struct cs4280_softc *sc;
	int rate;
d580 1
a580 4
cs4280_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d654 1
a654 2
cs4280_intr(p)
	void *p;
d823 2
a824 4
cs4280_download(sc, src, offset, len)
	struct cs4280_softc *sc;
	const u_int32_t *src;
	u_int32_t offset, len;
d862 1
a862 2
cs4280_download_image(sc)
	struct cs4280_softc *sc;
d893 2
a894 4
cs4280_checkimage(sc, src, offset, len)
	struct cs4280_softc *sc;
	u_int32_t *src;
	u_int32_t offset, len;
d919 1
a919 2
cs4280_check_images(sc)
	struct cs4280_softc *sc;
d942 1
a942 3
cs4280_attach_codec(sc_, codec_if)
	void *sc_;
	struct ac97_codec_if *codec_if;
d951 1
a951 2
cs4280_reset_codec(sc_)
	void *sc_;
d986 1
a986 2
cs4280_reset(sc_)
	void *sc_;
d1000 1
a1000 3
cs4280_open(addr, flags)
	void *addr;
	int flags;
d1006 1
a1006 2
cs4280_close(addr)
	void *addr;
d1018 1
a1018 3
cs4280_query_encoding(addr, fp)
	void *addr;
	struct audio_encoding *fp;
d1079 2
a1080 4
cs4280_set_params(addr, setmode, usemode, play, rec)
	void *addr;
	int setmode, usemode;
	struct audio_params *play, *rec;
d1177 1
a1177 3
cs4280_round_blocksize(hdl, blk)
	void *hdl;
	int blk;
d1183 1
a1183 4
cs4280_round_buffersize(addr, direction, size)
	void *addr;
	int direction;
	size_t size;
d1199 1
a1199 2
cs4280_get_props(hdl)
	void *hdl;
d1212 1
a1212 3
cs4280_mixer_get_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d1220 1
a1220 5
cs4280_mappage(addr, mem, off, prot)
	void *addr;
	void *mem;
	off_t off;
	int prot;
d1239 1
a1239 3
cs4280_query_devinfo(addr, dip)
	void *addr;
	mixer_devinfo_t *dip;
d1247 2
a1248 3
cs4280_get_portnum_by_name(sc, class, device, qualifier)
	struct cs4280_softc *sc;
	char *class, *device, *qualifier;
d1255 1
a1255 2
cs4280_halt_output(addr)
	void *addr;
d1269 1
a1269 2
cs4280_halt_input(addr)
	void *addr;
d1283 1
a1283 3
cs4280_getdev(addr, retp)
	void *addr;
	struct audio_device *retp;
d1290 1
a1290 3
cs4280_mixer_set_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d1302 1
a1302 3
cs4280_freemem(sc, p)
	struct cs4280_softc *sc;
	struct cs4280_dma *p;
d1312 2
a1313 5
cs4280_allocmem(sc, size, align, p)
	struct cs4280_softc *sc;
	size_t size;
	size_t align;
	struct cs4280_dma *p;
d1364 1
a1364 5
cs4280_malloc(addr, direction, size, pool, flags)
	void *addr;
	int direction;
	size_t size;
	int pool, flags;
d1399 1
a1399 4
cs4280_free(addr, ptr, pool)
	void *addr;
	void *ptr;
	int pool;
d1416 2
a1417 7
cs4280_trigger_output(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
d1504 2
a1505 7
cs4280_trigger_input(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
d1573 1
a1573 3
cs4280_init(sc, init)
	struct cs4280_softc *sc;
	int init;
d1665 1
a1665 3
cs4280_init2(sc, init)
	struct cs4280_softc *sc;
	int init;
d1774 1
a1774 2
cs4280_clear_fifos(sc)
	struct cs4280_softc *sc;
d1808 2
a1809 6
cs4280_midi_open(addr, flags, iintr, ointr, arg)
	void *addr;
	int flags;
	void (*iintr)(void *, int);
	void (*ointr)(void *);
	void *arg;
d1834 1
a1834 2
cs4280_midi_close(addr)
	void *addr;
d1849 1
a1849 3
cs4280_midi_output(addr, d)
	void *addr;
	int d;
d1874 1
a1874 3
cs4280_midi_getinfo(addr, mi)
	void *addr;
	struct midi_info *mi;
@


1.39
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.38 2010/09/12 03:17:34 jakemsr Exp $	*/
a1834 2
 	case DVACT_ACTIVATE:
		break;
@


1.38
log
@silly me.  use the switch() variable, not the case value.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.37 2010/09/12 02:05:41 jakemsr Exp $	*/
d307 1
a307 1
	    sizeof(cs4280_devices)/sizeof(cs4280_devices[0])));
@


1.37
log
@use audio(4) DVACT_{QUIESCE,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.36 2010/09/07 16:21:44 deraadt Exp $	*/
d1838 1
a1838 1
		rv = config_activate_children(self, DVACT_QUIESCE);
d1849 1
a1849 1
		rv = config_activate_children(self, DVACT_RESUME);
@


1.36
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.35 2010/08/27 18:50:57 deraadt Exp $	*/
d1832 1
a1832 1
	int i;
d1835 5
a1840 8
		cs4280_halt_output(sc);
		cs4280_halt_input(sc);
		/* Save AC97 registers */
		for(i = 1; i <= CS4280_SAVE_REG_MAX; i++) {
			if(i == 0x04) /* AC97_REG_MASTER_TONE */
				continue;
			cs4280_read_codec(sc, 2*i, &sc->ac97_reg[i]);
		}
d1845 1
d1848 4
a1851 8
		cs4280_reset_codec(sc);

		/* restore ac97 registers */
		for(i = 1; i <= CS4280_SAVE_REG_MAX; i++) {
			if(i == 0x04) /* AC97_REG_MASTER_TONE */
				continue;
			cs4280_write_codec(sc, 2*i, sc->ac97_reg[i]);
		}
d1854 1
a1854 1
	return 0;
@


1.35
log
@Since the changes in neo(4) work, it is very likely that the exact same
mechnical changes work in these drivers too.  Testing can occur after
this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.34 2010/07/15 03:43:11 jakemsr Exp $	*/
a159 1
	void   *sc_powerhook;		/* Power Hook */
a234 2
void	cs4280_powerhook(int, void *);

a590 1
	sc->sc_powerhook = powerhook_establish(cs4280_powerhook, sc);
a1860 6
}

void
cs4280_powerhook(int why, void *v)
{
	cs4280_activate(v, why);
@


1.34
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.33 2009/01/20 20:00:06 grange Exp $	*/
a159 1
	char	sc_suspend;
d171 1
d193 2
a194 1
	sizeof(struct cs4280_softc), cs4280_match, cs4280_attach
d236 1
a236 1
void	cs4280_power(int, void *);
d594 1
a594 2
	sc->sc_suspend = PWR_RESUME;
	sc->sc_powerhook = powerhook_establish(cs4280_power, sc);
d1832 2
a1833 4
void
cs4280_power(why, v)
	int why;
	void *v;
d1835 1
a1835 1
	struct cs4280_softc *sc = (struct cs4280_softc *)v;
d1838 2
a1839 5
	DPRINTF(("%s: cs4280_power why=%d\n",
	       sc->sc_dev.dv_xname, why));
	if (why != PWR_RESUME) {
		sc->sc_suspend = why;

d1850 2
a1851 7
	} else {
		if (sc->sc_suspend == PWR_RESUME) {
			printf("cs4280_power: odd, resume without suspend.\n");
			sc->sc_suspend = why;
			return;
		}
		sc->sc_suspend = why;
d1862 1
d1864 7
@


1.33
log
@Don't use (type *)var as an lvalue, it's incorrect. No functional changes.

ok jakemsr@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.32 2008/10/25 22:30:43 jakemsr Exp $	*/
d1109 3
d1205 2
@


1.32
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.31 2008/05/29 02:10:01 jakemsr Exp $	*/
d758 6
a763 3
				rdata  = *((int16_t *)empty_dma)++>>1;
				rdata += *((int16_t *)empty_dma)++>>1;
				*((int16_t *)sc->sc_rn)++ = rdata;
d768 2
a769 1
				rdata = *((int16_t*)empty_dma)++;
d771 2
a772 1
				rdata = *((int16_t*)empty_dma)++;
d778 4
a781 2
				rdata =	 *((int16_t*)empty_dma)++ >>1;
				rdata += *((int16_t*)empty_dma)++ >>1;
@


1.31
log
@use ac97 default parameters for these ac97 based drivers.

this makes the emulation expansion factor 1 by default since there's no
emulation.  previously the factor was 2 because these drivers emulate
8-bit ulaw playback with 16-bit linear encodings.  having a factor
other than 1 by default creates block size and hiwat/lowat issues
with applications that set the block size and hiwat before other
parameters.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.30 2008/04/21 00:32:43 jakemsr Exp $	*/
d1120 1
a1120 2
		p = mode == AUMODE_PLAY ? play : rec;
		
a1123 9
			/* play back data format may be 8- or 16-bit and
			 * either stereo or mono.
			 * playback rate may range from 8000Hz to 48000Hz 
			 */
			if (p->sample_rate < 8000 || p->sample_rate > 48000 ||
			    (p->precision != 8 && p->precision != 16) ||
			    (p->channels != 1  && p->channels != 2) ) {
				return (EINVAL);
			}
a1126 13
			/* capture data format must be 16bit stereo
			 * and sample rate range from 11025Hz to 48000Hz.
			 *
			 * XXX: it looks like to work with 8000Hz,
			 *	although data sheets say lower limit is
			 *	11025 Hz.
			 */

			if (p->sample_rate < 8000 || p->sample_rate > 48000 ||
			    (p->precision != 8 && p->precision != 16) ||
			    (p->channels  != 1 && p->channels  != 2) ) {
				return (EINVAL);
			}
d1128 19
@


1.30
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.29 2007/11/05 00:17:28 jakemsr Exp $	*/
d204 1
d274 1
a274 1
	NULL
d1226 6
@


1.29
log
@audio encoding conversion cleanup

- the endianness of the conversions don't depend on the endianness
  of machine the conversions are built on, but the endianness of the
  audio data itself.  choose encoding conversions explicitly, instead
  of relying on #defines based on the endianness of the machine.
- replace home-grown conversions with comparable conversions in
  auconv.c and mulaw.c
- use the proper conversion for ulinear_be:16 -> slinear_le:16 in
  auixp(4)

thanks ajacoutot@@ and sthen@@ for !x86 testing
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.28 2007/10/22 03:16:35 fgsch Exp $	*/
d273 1
@


1.28
log
@Use pci_set_powerstate(), shrinking the code and unifying the different
versions. ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.27 2007/10/21 12:43:25 fgsch Exp $	*/
d1165 1
a1165 1
					p->sw_code = change_sign16_swap_bytes;
d1173 1
a1173 1
					p->sw_code = change_sign16;
d1181 1
a1181 1
				p->sw_code = mulaw_to_slinear16;
d1189 1
a1189 1
				p->sw_code = alaw_to_slinear16;
@


1.27
log
@bring device back from power save mode if needed. fixes a problem reported
by Rodolfo Gouveia <rgouveia at cosmico dot net> on bugs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.26 2007/08/01 21:37:21 miod Exp $	*/
a606 2
	pcireg_t pmode;                                                         
	int pmreg;
d625 1
a625 8
	if (pci_get_capability(pc, pa->pa_tag, PCI_CAP_PWRMGMT, &pmreg, 0)) {
		pmode = pci_conf_read(pc, pa->pa_tag, pmreg + PCI_PMCSR);
		if ((pmode & PCI_PMCSR_STATE_MASK) != PCI_PMCSR_STATE_D0) {
			pci_conf_write(pc, pa->pa_tag, pmreg + PCI_PMCSR,
			    (pmode & ~PCI_PMCSR_STATE_MASK) |
			    PCI_PMCSR_STATE_D0);
		}
	}
@


1.26
log
@deliverd -> delivered.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.25 2006/04/07 22:41:33 jsg Exp $	*/
d607 2
d625 10
@


1.25
log
@Add optional flush method to MIDI hardware interface.
Allow umidi(4) to send multiple events in a single USB transfer.
This greatly improves the number of interrupts umidi is able to generate.

From Alexandre Ratchov.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.24 2005/11/29 05:42:17 tedu Exp $	*/
d808 1
a808 1
		 * is deliverd.  Shall I throw EOI top of this routine ?
@


1.24
log
@from the diffs so old they're growing mold dept:
while () return; is pretty dumb, change to ifs as intended
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.23 2005/08/09 04:10:10 mickey Exp $	*/
d280 1
d282 1
a282 1
	0,
@


1.23
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.22 2004/12/19 16:10:46 deraadt Exp $	*/
d379 1
d383 1
a383 1
		while (++n > 1000)
@


1.22
log
@shorten code
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.21 2004/12/19 16:06:22 deraadt Exp $	*/
a620 5

	/* Enable the device (set bus master flag) */
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	   pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG) |
	   PCI_COMMAND_MASTER_ENABLE);
@


1.21
log
@filesystem firmware loading written over the pacific 2 weeks ago, tested
by mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.20 2004/01/08 22:38:20 deraadt Exp $	*/
d880 1
a880 1
	int idx, err;
a883 2

	err = 0;
@


1.20
log
@tom broke the kernel, and is being scolded
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.19 2003/08/21 04:57:40 mickey Exp $	*/
a77 1
#include <dev/microcode/cirruslogic/cs4280_image.h>
d172 1
d197 1
d557 37
a603 1
	mixer_ctrl_t ctl;
d654 1
a654 1
	if(cs4280_init(sc, 1) != 0)
d657 2
a669 24

	/* Turn mute off of DAC, CD and master volumes by default */
	ctl.type = AUDIO_MIXER_ENUM;
	ctl.un.ord = 0;	 /* off */

	ctl.dev = cs4280_get_portnum_by_name(sc, AudioCoutputs,
					     AudioNmaster, AudioNmute);
	cs4280_mixer_set_port(sc, &ctl);

	ctl.dev = cs4280_get_portnum_by_name(sc, AudioCinputs,
					     AudioNdac, AudioNmute);
	cs4280_mixer_set_port(sc, &ctl);

	ctl.dev = cs4280_get_portnum_by_name(sc, AudioCinputs,
					     AudioNcd, AudioNmute);
	cs4280_mixer_set_port(sc, &ctl);
	
	audio_attach_mi(&cs4280_hw_if, sc, &sc->sc_dev);

#if NMIDI > 0
	midi_attach_mi(&cs4280_midi_hw_if, sc, &sc->sc_dev);
#endif
	sc->sc_suspend = PWR_RESUME;
	sc->sc_powerhook = powerhook_establish(cs4280_power, sc);
d874 2
d882 2
d887 9
d897 2
a898 3
		err = cs4280_download(sc, &BA1Struct.map[offset],
				  BA1Struct.memory[idx].offset,
				  BA1Struct.memory[idx].size);
d904 1
a904 1
		offset += BA1Struct.memory[idx].size / sizeof(u_int32_t);
d948 3
a950 3
		err = cs4280_checkimage(sc, &BA1Struct.map[offset],
				      BA1Struct.memory[idx].offset,
				      BA1Struct.memory[idx].size);
d955 1
a955 1
		offset += BA1Struct.memory[idx].size / sizeof(u_int32_t);
d1731 10
d1849 1
@


1.19
log
@sys/types.h is not really needed w/ sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.18 2003/08/21 04:52:51 kevlo Exp $	*/
a294 1
	{ PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CS4614 },
@


1.18
log
@remove extra header file <sys/systm.h>. ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.17 2003/04/27 11:22:53 ho Exp $	*/
a67 1
#include <sys/types.h>
@


1.17
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.16 2002/11/19 18:40:17 jason Exp $	*/
d68 1
a74 2
#include <sys/types.h>
#include <sys/systm.h>
@


1.16
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.15 2002/03/14 03:16:06 millert Exp $	*/
d1028 1
a1028 1
		strcpy(fp->name, AudioEulinear);
d1034 1
a1034 1
		strcpy(fp->name, AudioEmulaw);
d1040 1
a1040 1
		strcpy(fp->name, AudioEalaw);
d1046 1
a1046 1
		strcpy(fp->name, AudioEslinear);
d1052 1
a1052 1
		strcpy(fp->name, AudioEslinear_le);
d1058 1
a1058 1
		strcpy(fp->name, AudioEulinear_le);
d1064 1
a1064 1
		strcpy(fp->name, AudioEslinear_be);
d1070 1
a1070 1
		strcpy(fp->name, AudioEulinear_be);
@


1.15
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.14 2002/03/14 01:26:58 millert Exp $	*/
d294 6
d307 2
a308 11
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_CIRRUS)
		return (0);
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CIRRUS_CS4280 ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CIRRUS_CS4610 ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CIRRUS_CS4614 ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CIRRUS_CS4615) {
		return (1);
	}
	return (0);
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.13 2002/01/20 19:56:53 ericj Exp $	*/
d219 4
a222 4
int	cs4280_trigger_output __P((void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *));
int	cs4280_trigger_input __P((void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *));
d240 1
a240 1
void	cs4280_midi_close(void*);
d242 2
a243 2
int	cs4280_midi_open __P((void *, int, void (*)(void *, int),
			      void (*)(void *), void *));
@


1.13
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.12 2001/12/01 19:15:13 deraadt Exp $	*/
d173 5
a177 5
int	cs4280_match  __P((struct device *, void *, void *));
void	cs4280_attach __P((struct device *, struct device *, void *));
int	cs4280_intr __P((void *));
void	cs4280_reset __P((void *));
int	cs4280_download_image __P((struct cs4280_softc *));
d180 3
a182 3
int cs4280_allocmem __P((struct cs4280_softc *, size_t, size_t,
			 struct cs4280_dma *));
int cs4280_freemem __P((struct cs4280_softc *, struct cs4280_dma *));
d185 1
a185 1
int	cs4280_check_images   __P((struct cs4280_softc *));
d198 21
a218 21
int	cs4280_init __P((struct cs4280_softc *, int));
int	cs4280_open __P((void *, int));
void	cs4280_close __P((void *));

int	cs4280_query_encoding __P((void *, struct audio_encoding *));
int	cs4280_set_params __P((void *, int, int, struct audio_params *, struct audio_params *));
int	cs4280_round_blocksize __P((void *, int));

int	cs4280_halt_output __P((void *));
int	cs4280_halt_input __P((void *));

int	cs4280_getdev __P((void *, struct audio_device *));

int	cs4280_mixer_set_port __P((void *, mixer_ctrl_t *));
int	cs4280_mixer_get_port __P((void *, mixer_ctrl_t *));
int	cs4280_query_devinfo __P((void *addr, mixer_devinfo_t *dip));
void   *cs4280_malloc __P((void *, int, size_t, int, int));
void	cs4280_free __P((void *, void *, int));
size_t	cs4280_round_buffersize __P((void *, int, size_t));
paddr_t	cs4280_mappage __P((void *, void *, off_t, int));
int	cs4280_get_props __P((void *));
d225 9
a233 9
void	cs4280_set_dac_rate  __P((struct cs4280_softc *, int ));
void	cs4280_set_adc_rate  __P((struct cs4280_softc *, int ));
int	cs4280_get_portnum_by_name __P((struct cs4280_softc *, char *, char *,
					 char *));
int	cs4280_src_wait	 __P((struct cs4280_softc *));
int	cs4280_attach_codec __P((void *sc, struct ac97_codec_if *));
int	cs4280_read_codec __P((void *sc, u_int8_t a, u_int16_t *d));
int	cs4280_write_codec __P((void *sc, u_int8_t a, u_int16_t d));
void	cs4280_reset_codec __P((void *sc));
d235 1
a235 1
void	cs4280_power __P((int, void *));
d237 1
a237 1
void	cs4280_clear_fifos __P((struct cs4280_softc *));
d240 2
a241 2
void	cs4280_midi_close __P((void*));
void	cs4280_midi_getinfo __P((void *, struct midi_info *));
d244 1
a244 1
int	cs4280_midi_output __P((void *, int));
d1457 1
a1457 1
	void (*intr) __P((void *));
d1550 1
a1550 1
	void (*intr) __P((void *));
d1868 2
a1869 2
	void (*iintr)__P((void *, int));
	void (*ointr)__P((void *));
@


1.12
log
@correct irq message
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.11 2001/08/25 10:13:29 art Exp $	*/
d214 1
a214 1
void   *cs4280_malloc __P((void *, u_long, int, int));
d216 1
a216 1
u_long	cs4280_round_buffersize __P((void *, u_long));
d1194 2
a1195 2
u_long
cs4280_round_buffersize(addr, size)
d1197 2
a1198 1
	u_long size;
d1394 1
a1394 1
cs4280_malloc(addr, size, pool, flags)
d1396 2
a1397 1
	u_long size;
@


1.12.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.13 2002/01/20 19:56:53 ericj Exp $	*/
d214 1
a214 1
void   *cs4280_malloc __P((void *, int, size_t, int, int));
d216 1
a216 1
size_t	cs4280_round_buffersize __P((void *, int, size_t));
d1194 2
a1195 2
size_t
cs4280_round_buffersize(addr, direction, size)
d1197 1
a1197 2
	int direction;
	size_t size;
d1393 1
a1393 1
cs4280_malloc(addr, direction, size, pool, flags)
d1395 1
a1395 2
	int direction;
	size_t size;
@


1.12.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.12.2.1 2002/01/31 22:55:34 niklas Exp $	*/
d173 5
a177 5
int	cs4280_match(struct device *, void *, void *);
void	cs4280_attach(struct device *, struct device *, void *);
int	cs4280_intr(void *);
void	cs4280_reset(void *);
int	cs4280_download_image(struct cs4280_softc *);
d180 3
a182 3
int cs4280_allocmem(struct cs4280_softc *, size_t, size_t,
			 struct cs4280_dma *);
int cs4280_freemem(struct cs4280_softc *, struct cs4280_dma *);
d185 1
a185 1
int	cs4280_check_images(struct cs4280_softc *);
d198 36
a233 36
int	cs4280_init(struct cs4280_softc *, int);
int	cs4280_open(void *, int);
void	cs4280_close(void *);

int	cs4280_query_encoding(void *, struct audio_encoding *);
int	cs4280_set_params(void *, int, int, struct audio_params *, struct audio_params *);
int	cs4280_round_blocksize(void *, int);

int	cs4280_halt_output(void *);
int	cs4280_halt_input(void *);

int	cs4280_getdev(void *, struct audio_device *);

int	cs4280_mixer_set_port(void *, mixer_ctrl_t *);
int	cs4280_mixer_get_port(void *, mixer_ctrl_t *);
int	cs4280_query_devinfo(void *addr, mixer_devinfo_t *dip);
void   *cs4280_malloc(void *, int, size_t, int, int);
void	cs4280_free(void *, void *, int);
size_t	cs4280_round_buffersize(void *, int, size_t);
paddr_t	cs4280_mappage(void *, void *, off_t, int);
int	cs4280_get_props(void *);
int	cs4280_trigger_output(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	cs4280_trigger_input(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);


void	cs4280_set_dac_rate(struct cs4280_softc *, int );
void	cs4280_set_adc_rate(struct cs4280_softc *, int );
int	cs4280_get_portnum_by_name(struct cs4280_softc *, char *, char *,
					 char *);
int	cs4280_src_wait(struct cs4280_softc *);
int	cs4280_attach_codec(void *sc, struct ac97_codec_if *);
int	cs4280_read_codec(void *sc, u_int8_t a, u_int16_t *d);
int	cs4280_write_codec(void *sc, u_int8_t a, u_int16_t d);
void	cs4280_reset_codec(void *sc);
d235 1
a235 1
void	cs4280_power(int, void *);
d237 1
a237 1
void	cs4280_clear_fifos(struct cs4280_softc *);
d240 5
a244 5
void	cs4280_midi_close(void *);
void	cs4280_midi_getinfo(void *, struct midi_info *);
int	cs4280_midi_open(void *, int, void (*)(void *, int),
	    void (*)(void *), void *);
int	cs4280_midi_output(void *, int);
d1457 1
a1457 1
	void (*intr)(void *);
d1550 1
a1550 1
	void (*intr)(void *);
d1868 2
a1869 2
	void (*iintr)(void *, int);
	void (*ointr)(void *);
@


1.12.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a293 6
const struct pci_matchid cs4280_devices[] = {
	{ PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CS4280 },
	{ PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CS4610 },
	{ PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CS4614 },
	{ PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CS4615 },
};
d301 11
a311 2
	return (pci_matchbyid((struct pci_attach_args *)aux, cs4280_devices,
	    sizeof(cs4280_devices)/sizeof(cs4280_devices[0])));
d1031 1
a1031 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d1037 1
a1037 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d1043 1
a1043 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d1049 1
a1049 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d1055 1
a1055 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d1061 1
a1061 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d1067 1
a1067 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d1073 1
a1073 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
@


1.11
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.10 2001/06/18 19:27:17 deraadt Exp $	*/
d620 1
a620 1
	printf(" %s\n", intrstr);
@


1.10
log
@more more microcode (so it does not end up installed in includes, for one)
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.9 2001/06/12 15:40:30 niklas Exp $	*/
d605 1
a605 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.9
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.8 2001/05/02 21:13:37 marc Exp $	*/
d80 1
a80 1
#include <dev/pci/cs4280_image.h>
@


1.8
log
@
register save/restore fix from art via Chuck Cranor
OK deraadt@@ and art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.7 2001/03/14 12:15:11 mickey Exp $	*/
d578 1
a578 1
	    &sc->ba0t, &sc->ba0h, NULL, NULL)) {
d584 1
a584 1
	    &sc->ba1t, &sc->ba1h, NULL, NULL)) {
@


1.8.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1805 1
a1805 1
			cs4280_read_codec(sc, 2*i, &sc->ac97_reg[i>>1]);
d1823 1
a1823 1
			cs4280_write_codec(sc, 2*i, sc->ac97_reg[i>>1]);
@


1.8.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.8.2.1 2001/05/14 22:25:36 niklas Exp $	*/
d80 1
a80 1
#include <dev/microcode/cirruslogic/cs4280_image.h>
d578 1
a578 1
	    &sc->ba0t, &sc->ba0h, NULL, NULL, 0)) {
d584 1
a584 1
	    &sc->ba1t, &sc->ba1h, NULL, NULL, 0)) {
d1805 1
a1805 1
			cs4280_read_codec(sc, 2*i, &sc->ac97_reg[i]);
d1823 1
a1823 1
			cs4280_write_codec(sc, 2*i, sc->ac97_reg[i]);
@


1.8.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.8.2.2 2001/07/04 10:41:56 niklas Exp $	*/
d605 2
a606 1
	if (pci_intr_map(pa, &ih)) {
@


1.8.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.8.2.3 2001/10/31 03:22:45 nate Exp $	*/
d620 1
a620 1
	printf(": %s\n", intrstr);
@


1.8.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d214 1
a214 1
void   *cs4280_malloc __P((void *, int, size_t, int, int));
d216 1
a216 1
size_t	cs4280_round_buffersize __P((void *, int, size_t));
d1194 2
a1195 2
size_t
cs4280_round_buffersize(addr, direction, size)
d1197 1
a1197 2
	int direction;
	size_t size;
d1393 1
a1393 1
cs4280_malloc(addr, direction, size, pool, flags)
d1395 1
a1395 2
	int direction;
	size_t size;
@


1.8.2.6
log
@Merge in -current from roughly a week ago
@
text
@d173 5
a177 5
int	cs4280_match(struct device *, void *, void *);
void	cs4280_attach(struct device *, struct device *, void *);
int	cs4280_intr(void *);
void	cs4280_reset(void *);
int	cs4280_download_image(struct cs4280_softc *);
d180 3
a182 3
int cs4280_allocmem(struct cs4280_softc *, size_t, size_t,
			 struct cs4280_dma *);
int cs4280_freemem(struct cs4280_softc *, struct cs4280_dma *);
d185 1
a185 1
int	cs4280_check_images(struct cs4280_softc *);
d198 36
a233 36
int	cs4280_init(struct cs4280_softc *, int);
int	cs4280_open(void *, int);
void	cs4280_close(void *);

int	cs4280_query_encoding(void *, struct audio_encoding *);
int	cs4280_set_params(void *, int, int, struct audio_params *, struct audio_params *);
int	cs4280_round_blocksize(void *, int);

int	cs4280_halt_output(void *);
int	cs4280_halt_input(void *);

int	cs4280_getdev(void *, struct audio_device *);

int	cs4280_mixer_set_port(void *, mixer_ctrl_t *);
int	cs4280_mixer_get_port(void *, mixer_ctrl_t *);
int	cs4280_query_devinfo(void *addr, mixer_devinfo_t *dip);
void   *cs4280_malloc(void *, int, size_t, int, int);
void	cs4280_free(void *, void *, int);
size_t	cs4280_round_buffersize(void *, int, size_t);
paddr_t	cs4280_mappage(void *, void *, off_t, int);
int	cs4280_get_props(void *);
int	cs4280_trigger_output(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	cs4280_trigger_input(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);


void	cs4280_set_dac_rate(struct cs4280_softc *, int );
void	cs4280_set_adc_rate(struct cs4280_softc *, int );
int	cs4280_get_portnum_by_name(struct cs4280_softc *, char *, char *,
					 char *);
int	cs4280_src_wait(struct cs4280_softc *);
int	cs4280_attach_codec(void *sc, struct ac97_codec_if *);
int	cs4280_read_codec(void *sc, u_int8_t a, u_int16_t *d);
int	cs4280_write_codec(void *sc, u_int8_t a, u_int16_t d);
void	cs4280_reset_codec(void *sc);
d235 1
a235 1
void	cs4280_power(int, void *);
d237 1
a237 1
void	cs4280_clear_fifos(struct cs4280_softc *);
d240 5
a244 5
void	cs4280_midi_close(void *);
void	cs4280_midi_getinfo(void *, struct midi_info *);
int	cs4280_midi_open(void *, int, void (*)(void *, int),
	    void (*)(void *), void *);
int	cs4280_midi_output(void *, int);
d1457 1
a1457 1
	void (*intr)(void *);
d1550 1
a1550 1
	void (*intr)(void *);
d1868 2
a1869 2
	void (*iintr)(void *, int);
	void (*ointr)(void *);
@


1.8.2.7
log
@Sync the SMP branch with 3.3
@
text
@a293 6
const struct pci_matchid cs4280_devices[] = {
	{ PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CS4280 },
	{ PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CS4610 },
	{ PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CS4614 },
	{ PCI_VENDOR_CIRRUS, PCI_PRODUCT_CIRRUS_CS4615 },
};
d301 11
a311 2
	return (pci_matchbyid((struct pci_attach_args *)aux, cs4280_devices,
	    sizeof(cs4280_devices)/sizeof(cs4280_devices[0])));
@


1.8.2.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.8.2.7 2003/03/28 00:38:20 niklas Exp $	*/
d1028 1
a1028 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d1034 1
a1034 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d1040 1
a1040 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d1046 1
a1046 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d1052 1
a1052 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d1058 1
a1058 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d1064 1
a1064 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d1070 1
a1070 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
@


1.8.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 2
d297 1
@


1.7
log
@match formats in read_codec w/ write_codec
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.6 2001/01/26 22:37:48 mickey Exp $	*/
d1805 1
a1805 1
			cs4280_read_codec(sc, 2*i, &sc->ac97_reg[i>>1]);
d1823 1
a1823 1
			cs4280_write_codec(sc, 2*i, sc->ac97_reg[i>>1]);
@


1.6
log
@constify BA1
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.5 2000/09/17 20:31:20 marc Exp $	*/
d337 1
a337 1
		printf("%s: AC97 read prob. (DCV!=0) for add=0x%0x\n",
d347 1
a347 1
			printf("%s: AC97 read fail (VSTS==0) for add=0x%0x\n", 
@


1.5
log
@
Only check defined bits when waiting for valid AC97 input slot
Don't clobber existing bits when turning on clock
Save interrupt status and issue EOI before processing status bits
checked by me and angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.4 2000/07/19 16:06:12 deraadt Exp $	*/
d179 1
a179 1
int cs4280_download(struct cs4280_softc *, u_int32_t *, u_int32_t, u_int32_t);
d830 1
a830 1
	u_int32_t *src;
@


1.4
log
@let us assume for now this workse with the other 3 chip models
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.3 2000/07/12 22:10:33 fgsch Exp $	*/
d695 1
d697 1
a698 5
	if ((intr & HISR_INTENA) == 0) {
		BA0WRITE4(sc, CS4280_HICR, HICR_CHGM | HICR_IEV);
		return (0);
	}
	
d820 1
a820 2
	/* Throw EOI */
	BA0WRITE4(sc, CS4280_HICR, HICR_CHGM | HICR_IEV);
d1617 1
d1662 2
a1663 1
	BA0WRITE4(sc, CS4280_CLKCR1, CLKCR1_PLLP | CLKCR1_SWCE);
d1695 2
a1696 1
	while (BA0READ4(sc, CS4280_ACISV) != (ACISV_ISV3 | ACISV_ISV4)) {
d1731 2
@


1.3
log
@Change to match OpenBSD output format.
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.2 2000/07/12 18:45:17 art Exp $	*/
d305 4
a308 6
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CIRRUS_CS4280
#if 0  /* I can't confirm */
	    || PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CIRRUS_CS4610
#endif
	   
	   ) {
@


1.2
log
@Fix two bugs.
The return value from the interrupt handling was bogus. Now we return 1
if we have handled the interrupt.

When resuming from suspend wrong values were restored to the mixer
which sometimes caused a high-pitched sound to be emitted. (how fast
can you type "mixerctl -w outputs.master.mute=on"?)
@
text
@d1 1
a1 1
/*	$OpenBSD: cs4280.c,v 1.1 2000/06/30 03:28:07 art Exp $	*/
d569 2
a570 2
	struct cs4280_softc *sc = (struct cs4280_softc *)self;
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
a573 2
	pcireg_t csr;
	char devinfo[256];
a576 3
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
	printf(": %s (rev. 0x%02x)\n", devinfo, PCI_REVISION(pa->pa_class));

d579 3
a581 3
			  PCI_MAPREG_TYPE_MEM|PCI_MAPREG_MEM_TYPE_32BIT, 0,
			  &sc->ba0t, &sc->ba0h, NULL, NULL)) {
		printf("%s: can't map BA0 space\n", sc->sc_dev.dv_xname);
d585 3
a587 3
			  PCI_MAPREG_TYPE_MEM|PCI_MAPREG_MEM_TYPE_32BIT, 0,
			  &sc->ba1t, &sc->ba1h, NULL, NULL)) {
		printf("%s: can't map BA1 space\n", sc->sc_dev.dv_xname);
a593 1
	csr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
d595 2
a596 1
		       csr | PCI_COMMAND_MASTER_ENABLE);
d608 2
a609 2
			 pa->pa_intrline, &ih)) {
		printf("%s: couldn't map interrupt\n", sc->sc_dev.dv_xname);
d617 1
a617 1
		printf("%s: couldn't establish interrupt",sc->sc_dev.dv_xname);
d623 1
a623 1
	printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname, intrstr);
@


1.1
log
@Driver for the cs4280 Crystal Clear audio found on some laptops.
At last my Thinkpad plays german music.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d700 1
d711 1
d735 2
a736 1
		
d798 1
d832 1
a832 1
	return (0);
d1829 1
a1829 1
			cs4280_write_codec(sc, 2*i, sc->ac97_reg[i]);
@

