head	1.113;
access;
symbols
	OPENBSD_6_1:1.113.0.2
	OPENBSD_6_1_BASE:1.113
	OPENBSD_6_0:1.112.0.6
	OPENBSD_6_0_BASE:1.112
	OPENBSD_5_9:1.112.0.2
	OPENBSD_5_9_BASE:1.112
	OPENBSD_5_8:1.111.0.4
	OPENBSD_5_8_BASE:1.111
	OPENBSD_5_7:1.110.0.6
	OPENBSD_5_7_BASE:1.110
	OPENBSD_5_6:1.110.0.4
	OPENBSD_5_6_BASE:1.110
	OPENBSD_5_5:1.108.0.14
	OPENBSD_5_5_BASE:1.108
	OPENBSD_5_4:1.108.0.10
	OPENBSD_5_4_BASE:1.108
	OPENBSD_5_3:1.108.0.8
	OPENBSD_5_3_BASE:1.108
	OPENBSD_5_2:1.108.0.6
	OPENBSD_5_2_BASE:1.108
	OPENBSD_5_1_BASE:1.108
	OPENBSD_5_1:1.108.0.4
	OPENBSD_5_0:1.108.0.2
	OPENBSD_5_0_BASE:1.108
	OPENBSD_4_9:1.104.0.2
	OPENBSD_4_9_BASE:1.104
	OPENBSD_4_8:1.102.0.2
	OPENBSD_4_8_BASE:1.102
	OPENBSD_4_7:1.94.0.2
	OPENBSD_4_7_BASE:1.94
	OPENBSD_4_6:1.93.0.4
	OPENBSD_4_6_BASE:1.93
	OPENBSD_4_5:1.48.0.2
	OPENBSD_4_5_BASE:1.48
	OPENBSD_4_4:1.30.0.4
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16;
locks; strict;
comment	@ * @;


1.113
date	2016.08.14.04.08.03;	author dlg;	state Exp;
branches;
next	1.112;
commitid	7Sh26Zh99sH8viYr;

1.112
date	2015.09.10.18.10.34;	author deraadt;	state Exp;
branches;
next	1.111;
commitid	pbNNrPaFfPV40pxN;

1.111
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.110;
commitid	p4LJxGKbi0BU2cG6;

1.110
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.109;
commitid	JtO5uXxVcnZfhUkR;

1.109
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.108;
commitid	OBNa5kfxQ2UXoiIw;

1.108
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.107;

1.107
date	2011.07.08.22.09.27;	author matthew;	state Exp;
branches;
next	1.106;

1.106
date	2011.07.05.22.40.57;	author matthew;	state Exp;
branches;
next	1.105;

1.105
date	2011.04.06.15.33.15;	author dlg;	state Exp;
branches;
next	1.104;

1.104
date	2010.10.12.00.53.32;	author krw;	state Exp;
branches;
next	1.103;

1.103
date	2010.09.20.06.17.49;	author krw;	state Exp;
branches;
next	1.102;

1.102
date	2010.07.01.16.30.57;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2010.07.01.03.20.38;	author matthew;	state Exp;
branches;
next	1.100;

1.100
date	2010.06.30.19.08.59;	author mk;	state Exp;
branches;
next	1.99;

1.99
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.98;

1.98
date	2010.06.15.04.11.34;	author dlg;	state Exp;
branches;
next	1.97;

1.97
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.96;

1.96
date	2010.04.06.22.28.07;	author tedu;	state Exp;
branches;
next	1.95;

1.95
date	2010.03.23.01.57.20;	author krw;	state Exp;
branches;
next	1.94;

1.94
date	2010.01.09.23.15.07;	author krw;	state Exp;
branches;
next	1.93;

1.93
date	2009.03.23.17.40.56;	author grange;	state Exp;
branches;
next	1.92;

1.92
date	2009.03.22.20.57.28;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2009.03.22.18.41.34;	author grange;	state Exp;
branches;
next	1.90;

1.90
date	2009.03.22.18.27.41;	author grange;	state Exp;
branches;
next	1.89;

1.89
date	2009.03.22.07.02.32;	author grange;	state Exp;
branches;
next	1.88;

1.88
date	2009.03.21.17.49.32;	author grange;	state Exp;
branches;
next	1.87;

1.87
date	2009.03.21.17.44.43;	author grange;	state Exp;
branches;
next	1.86;

1.86
date	2009.03.21.12.44.44;	author grange;	state Exp;
branches;
next	1.85;

1.85
date	2009.03.21.12.34.41;	author grange;	state Exp;
branches;
next	1.84;

1.84
date	2009.03.21.09.57.10;	author grange;	state Exp;
branches;
next	1.83;

1.83
date	2009.03.20.20.16.56;	author grange;	state Exp;
branches;
next	1.82;

1.82
date	2009.03.20.20.11.07;	author grange;	state Exp;
branches;
next	1.81;

1.81
date	2009.03.20.19.48.41;	author grange;	state Exp;
branches;
next	1.80;

1.80
date	2009.03.20.19.44.45;	author grange;	state Exp;
branches;
next	1.79;

1.79
date	2009.03.20.07.24.41;	author grange;	state Exp;
branches;
next	1.78;

1.78
date	2009.03.19.21.52.43;	author grange;	state Exp;
branches;
next	1.77;

1.77
date	2009.03.19.16.19.51;	author grange;	state Exp;
branches;
next	1.76;

1.76
date	2009.03.19.16.07.14;	author grange;	state Exp;
branches;
next	1.75;

1.75
date	2009.03.19.13.25.18;	author grange;	state Exp;
branches;
next	1.74;

1.74
date	2009.03.19.10.04.47;	author grange;	state Exp;
branches;
next	1.73;

1.73
date	2009.03.18.20.35.41;	author grange;	state Exp;
branches;
next	1.72;

1.72
date	2009.03.17.08.17.48;	author grange;	state Exp;
branches;
next	1.71;

1.71
date	2009.03.17.07.48.59;	author grange;	state Exp;
branches;
next	1.70;

1.70
date	2009.03.16.21.46.00;	author grange;	state Exp;
branches;
next	1.69;

1.69
date	2009.03.16.15.08.46;	author grange;	state Exp;
branches;
next	1.68;

1.68
date	2009.03.16.14.04.04;	author grange;	state Exp;
branches;
next	1.67;

1.67
date	2009.03.16.08.09.05;	author grange;	state Exp;
branches;
next	1.66;

1.66
date	2009.03.16.07.21.57;	author grange;	state Exp;
branches;
next	1.65;

1.65
date	2009.03.15.17.35.42;	author grange;	state Exp;
branches;
next	1.64;

1.64
date	2009.03.13.20.03.21;	author grange;	state Exp;
branches;
next	1.63;

1.63
date	2009.03.13.08.48.12;	author grange;	state Exp;
branches;
next	1.62;

1.62
date	2009.03.13.07.49.28;	author grange;	state Exp;
branches;
next	1.61;

1.61
date	2009.03.12.21.20.05;	author grange;	state Exp;
branches;
next	1.60;

1.60
date	2009.03.12.21.00.41;	author grange;	state Exp;
branches;
next	1.59;

1.59
date	2009.03.12.11.12.41;	author grange;	state Exp;
branches;
next	1.58;

1.58
date	2009.03.11.20.06.00;	author grange;	state Exp;
branches;
next	1.57;

1.57
date	2009.03.10.15.31.04;	author grange;	state Exp;
branches;
next	1.56;

1.56
date	2009.03.10.14.18.28;	author grange;	state Exp;
branches;
next	1.55;

1.55
date	2009.03.10.14.07.44;	author grange;	state Exp;
branches;
next	1.54;

1.54
date	2009.03.10.09.16.40;	author grange;	state Exp;
branches;
next	1.53;

1.53
date	2009.03.10.08.27.08;	author grange;	state Exp;
branches;
next	1.52;

1.52
date	2009.03.09.20.21.50;	author grange;	state Exp;
branches;
next	1.51;

1.51
date	2009.03.01.19.54.23;	author grange;	state Exp;
branches;
next	1.50;

1.50
date	2009.03.01.19.45.36;	author grange;	state Exp;
branches;
next	1.49;

1.49
date	2009.03.01.15.35.10;	author grange;	state Exp;
branches;
next	1.48;

1.48
date	2009.02.19.16.06.56;	author grange;	state Exp;
branches;
next	1.47;

1.47
date	2009.02.17.20.22.07;	author grange;	state Exp;
branches;
next	1.46;

1.46
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2009.02.13.19.26.41;	author grange;	state Exp;
branches;
next	1.44;

1.44
date	2009.02.11.11.42.17;	author grange;	state Exp;
branches;
next	1.43;

1.43
date	2009.02.11.08.41.36;	author grange;	state Exp;
branches;
next	1.42;

1.42
date	2009.02.10.12.43.03;	author grange;	state Exp;
branches;
next	1.41;

1.41
date	2009.02.10.09.09.56;	author grange;	state Exp;
branches;
next	1.40;

1.40
date	2009.02.09.22.05.15;	author grange;	state Exp;
branches;
next	1.39;

1.39
date	2009.02.09.20.20.15;	author grange;	state Exp;
branches;
next	1.38;

1.38
date	2009.02.09.20.17.43;	author grange;	state Exp;
branches;
next	1.37;

1.37
date	2009.02.08.12.00.19;	author grange;	state Exp;
branches;
next	1.36;

1.36
date	2009.02.08.11.42.43;	author grange;	state Exp;
branches;
next	1.35;

1.35
date	2009.02.08.10.47.31;	author grange;	state Exp;
branches;
next	1.34;

1.34
date	2009.02.08.10.46.09;	author grange;	state Exp;
branches;
next	1.33;

1.33
date	2009.02.08.09.07.36;	author grange;	state Exp;
branches;
next	1.32;

1.32
date	2009.02.08.08.54.10;	author grange;	state Exp;
branches;
next	1.31;

1.31
date	2009.01.09.21.47.08;	author grange;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.06.20.51.13;	author grange;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.29.16.56.01;	author grange;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.28.17.44.54;	author grange;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.28.17.18.35;	author grange;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.28.16.35.41;	author grange;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.28.14.05.16;	author grange;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.28.13.07.49;	author grange;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.28.05.10.12;	author grange;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.28.03.57.43;	author grange;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.28.03.01.10;	author grange;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.27.20.57.58;	author grange;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.27.20.06.40;	author grange;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.27.19.21.09;	author grange;	state Exp;
branches;
next	1.16;

1.16
date	2006.11.29.18.18.39;	author grange;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.29.14.52.19;	author grange;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.29.14.41.09;	author grange;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.29.14.38.17;	author grange;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.29.00.08.00;	author grange;	state Exp;
branches;
next	1.11;

1.11
date	2006.11.29.00.04.39;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.28.23.49.50;	author grange;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.28.19.59.14;	author grange;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.28.18.27.53;	author grange;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.28.16.17.29;	author grange;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.28.16.15.47;	author grange;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.28.14.28.39;	author grange;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.28.00.11.44;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.27.23.56.38;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.27.17.31.36;	author grange;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.27.16.47.05;	author grange;	state Exp;
branches;
next	;


desc
@@


1.113
log
@change some types in bio from u_quad_t to uint64_t, and fix casts in
drivers that fill that field in too.

quad types are going away.
@
text
@/*	$OpenBSD: ips.c,v 1.112 2015/09/10 18:10:34 deraadt Exp $	*/

/*
 * Copyright (c) 2006, 2007, 2009 Alexander Yurchenko <grange@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * IBM (Adaptec) ServeRAID controllers driver.
 */

#include "bio.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/sensors.h>
#include <sys/timeout.h>
#include <sys/queue.h>

#include <machine/bus.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>

#include <dev/biovar.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

/* Debug levels */
#define IPS_D_ERR	0x0001	/* errors */
#define IPS_D_INFO	0x0002	/* information */
#define IPS_D_XFER	0x0004	/* transfers */

#ifdef IPS_DEBUG
#define DPRINTF(a, b)	do { if (ips_debug & (a)) printf b; } while (0)
int ips_debug = IPS_D_ERR;
#else
#define DPRINTF(a, b)
#endif

#define IPS_MAXDRIVES		8
#define IPS_MAXCHANS		4
#define IPS_MAXTARGETS		16
#define IPS_MAXCHUNKS		16
#define IPS_MAXCMDS		128

#define IPS_MAXFER		(64 * 1024)
#define IPS_MAXSGS		16
#define IPS_MAXCDB		12

#define IPS_SECSZ		512
#define IPS_NVRAMPGSZ		128
#define IPS_SQSZ		(IPS_MAXCMDS * sizeof(u_int32_t))

#define	IPS_TIMEOUT		60000	/* ms */

/* Command codes */
#define IPS_CMD_READ		0x02
#define IPS_CMD_WRITE		0x03
#define IPS_CMD_DCDB		0x04
#define IPS_CMD_GETADAPTERINFO	0x05
#define IPS_CMD_FLUSH		0x0a
#define IPS_CMD_REBUILDSTATUS	0x0c
#define IPS_CMD_SETSTATE	0x10
#define IPS_CMD_REBUILD		0x16
#define IPS_CMD_ERRORTABLE	0x17
#define IPS_CMD_GETDRIVEINFO	0x19
#define IPS_CMD_RESETCHAN	0x1a
#define IPS_CMD_DOWNLOAD	0x20
#define IPS_CMD_RWBIOSFW	0x22
#define IPS_CMD_READCONF	0x38
#define IPS_CMD_GETSUBSYS	0x40
#define IPS_CMD_CONFIGSYNC	0x58
#define IPS_CMD_READ_SG		0x82
#define IPS_CMD_WRITE_SG	0x83
#define IPS_CMD_DCDB_SG		0x84
#define IPS_CMD_EDCDB		0x95
#define IPS_CMD_EDCDB_SG	0x96
#define IPS_CMD_RWNVRAMPAGE	0xbc
#define IPS_CMD_GETVERINFO	0xc6
#define IPS_CMD_FFDC		0xd7
#define IPS_CMD_SG		0x80
#define IPS_CMD_RWNVRAM		0xbc

/* DCDB attributes */
#define IPS_DCDB_DATAIN		0x01	/* data input */
#define IPS_DCDB_DATAOUT	0x02	/* data output */
#define IPS_DCDB_XFER64K	0x08	/* 64K transfer */
#define IPS_DCDB_TIMO10		0x10	/* 10 secs timeout */
#define IPS_DCDB_TIMO60		0x20	/* 60 secs timeout */
#define IPS_DCDB_TIMO20M	0x30	/* 20 mins timeout */
#define IPS_DCDB_NOAUTOREQSEN	0x40	/* no auto request sense */
#define IPS_DCDB_DISCON		0x80	/* disconnect allowed */

/* Register definitions */
#define IPS_REG_HIS		0x08	/* host interrupt status */
#define IPS_REG_HIS_SCE			0x01	/* status channel enqueue */
#define IPS_REG_HIS_EN			0x80	/* enable interrupts */
#define IPS_REG_CCSA		0x10	/* command channel system address */
#define IPS_REG_CCC		0x14	/* command channel control */
#define IPS_REG_CCC_SEM			0x0008	/* semaphore */
#define IPS_REG_CCC_START		0x101a	/* start command */
#define IPS_REG_SQH		0x20	/* status queue head */
#define IPS_REG_SQT		0x24	/* status queue tail */
#define IPS_REG_SQE		0x28	/* status queue end */
#define IPS_REG_SQS		0x2c	/* status queue start */

#define IPS_REG_OIS		0x30	/* outbound interrupt status */
#define IPS_REG_OIS_PEND		0x0008	/* interrupt is pending */
#define IPS_REG_OIM		0x34	/* outbound interrupt mask */
#define IPS_REG_OIM_DS			0x0008	/* disable interrupts */
#define IPS_REG_IQP		0x40	/* inbound queue port */
#define IPS_REG_OQP		0x44	/* outbound queue port */

/* Status word fields */
#define IPS_STAT_ID(x)		(((x) >> 8) & 0xff)	/* command id */
#define IPS_STAT_BASIC(x)	(((x) >> 16) & 0xff)	/* basic status */
#define IPS_STAT_EXT(x)		(((x) >> 24) & 0xff)	/* ext status */
#define IPS_STAT_GSC(x)		((x) & 0x0f)

/* Basic status codes */
#define IPS_STAT_OK		0x00	/* success */
#define IPS_STAT_RECOV		0x01	/* recovered error */
#define IPS_STAT_INVOP		0x03	/* invalid opcode */
#define IPS_STAT_INVCMD		0x04	/* invalid command block */
#define IPS_STAT_INVPARM	0x05	/* invalid parameters block */
#define IPS_STAT_BUSY		0x08	/* busy */
#define IPS_STAT_CMPLERR	0x0c	/* completed with error */
#define IPS_STAT_LDERR		0x0d	/* logical drive error */
#define IPS_STAT_TIMO		0x0e	/* timeout */
#define IPS_STAT_PDRVERR	0x0f	/* physical drive error */

/* Extended status codes */
#define IPS_ESTAT_SELTIMO	0xf0	/* select timeout */
#define IPS_ESTAT_OURUN		0xf2	/* over/underrun */
#define IPS_ESTAT_HOSTRST	0xf7	/* host reset */
#define IPS_ESTAT_DEVRST	0xf8	/* device reset */
#define IPS_ESTAT_RECOV		0xfc	/* recovered error */
#define IPS_ESTAT_CKCOND	0xff	/* check condition */

#define IPS_IOSIZE		128	/* max space size to map */

/* Command frame */
struct ips_cmd {
	u_int8_t	code;
	u_int8_t	id;
	u_int8_t	drive;
	u_int8_t	sgcnt;
	u_int32_t	lba;
	u_int32_t	sgaddr;
	u_int16_t	seccnt;
	u_int8_t	seg4g;
	u_int8_t	esg;
	u_int32_t	ccsar;
	u_int32_t	cccr;
};

/* Direct CDB (SCSI pass-through) frame */
struct ips_dcdb {
	u_int8_t	device;
	u_int8_t	attr;
	u_int16_t	datalen;
	u_int32_t	sgaddr;
	u_int8_t	cdblen;
	u_int8_t	senselen;
	u_int8_t	sgcnt;
	u_int8_t	__reserved1;
	u_int8_t	cdb[IPS_MAXCDB];
	u_int8_t	sense[64];
	u_int8_t	status;
	u_int8_t	__reserved2[3];
};

/* Scatter-gather array element */
struct ips_sg {
	u_int32_t	addr;
	u_int32_t	size;
};

/* Command block */
struct ips_cmdb {
	struct ips_cmd	cmd;
	struct ips_dcdb	dcdb;
	struct ips_sg	sg[IPS_MAXSGS];
};

/* Data frames */
struct ips_adapterinfo {
	u_int8_t	drivecnt;
	u_int8_t	miscflag;
	u_int8_t	sltflag;
	u_int8_t	bstflag;
	u_int8_t	pwrchgcnt;
	u_int8_t	wrongaddrcnt;
	u_int8_t	unidentcnt;
	u_int8_t	nvramdevchgcnt;
	u_int8_t	firmware[8];
	u_int8_t	bios[8];
	u_int32_t	drivesize[IPS_MAXDRIVES];
	u_int8_t	cmdcnt;
	u_int8_t	maxphysdevs;
	u_int16_t	flashrepgmcnt;
	u_int8_t	defunctdiskcnt;
	u_int8_t	rebuildflag;
	u_int8_t	offdrivecnt;
	u_int8_t	critdrivecnt;
	u_int16_t	confupdcnt;
	u_int8_t	blkflag;
	u_int8_t	__reserved;
	u_int16_t	deaddisk[IPS_MAXCHANS][IPS_MAXTARGETS];
};

struct ips_driveinfo {
	u_int8_t	drivecnt;
	u_int8_t	__reserved[3];
	struct ips_drive {
		u_int8_t	id;
		u_int8_t	__reserved;
		u_int8_t	raid;
		u_int8_t	state;
#define IPS_DS_FREE	0x00
#define IPS_DS_OFFLINE	0x02
#define IPS_DS_ONLINE	0x03
#define IPS_DS_DEGRADED	0x04
#define IPS_DS_SYS	0x06
#define IPS_DS_CRS	0x24

		u_int32_t	seccnt;
	}		drive[IPS_MAXDRIVES];
};

struct ips_conf {
	u_int8_t	ldcnt;
	u_int8_t	day;
	u_int8_t	month;
	u_int8_t	year;
	u_int8_t	initid[4];
	u_int8_t	hostid[12];
	u_int8_t	time[8];
	u_int32_t	useropt;
	u_int16_t	userfield;
	u_int8_t	rebuildrate;
	u_int8_t	__reserved1;

	struct ips_hw {
		u_int8_t	board[8];
		u_int8_t	cpu[8];
		u_int8_t	nchantype;
		u_int8_t	nhostinttype;
		u_int8_t	compression;
		u_int8_t	nvramtype;
		u_int32_t	nvramsize;
	}		hw;

	struct ips_ld {
		u_int16_t	userfield;
		u_int8_t	state;
		u_int8_t	raidcacheparam;
		u_int8_t	chunkcnt;
		u_int8_t	stripesize;
		u_int8_t	params;
		u_int8_t	__reserved;
		u_int32_t	size;

		struct ips_chunk {
			u_int8_t	channel;
			u_int8_t	target;
			u_int16_t	__reserved;
			u_int32_t	startsec;
			u_int32_t	seccnt;
		}		chunk[IPS_MAXCHUNKS];
	}		ld[IPS_MAXDRIVES];

	struct ips_dev {
		u_int8_t	initiator;
		u_int8_t	params;
		u_int8_t	miscflag;
		u_int8_t	state;
#define IPS_DVS_STANDBY	0x01
#define IPS_DVS_REBUILD	0x02
#define IPS_DVS_SPARE	0x04
#define IPS_DVS_MEMBER	0x08
#define IPS_DVS_ONLINE	0x80
#define IPS_DVS_READY	(IPS_DVS_STANDBY | IPS_DVS_ONLINE)

		u_int32_t	seccnt;
		u_int8_t	devid[28];
	}		dev[IPS_MAXCHANS][IPS_MAXTARGETS];

	u_int8_t	reserved[512];
};

struct ips_rblstat {
	u_int8_t	__unknown[20];
	struct {
		u_int8_t	__unknown[4];
		u_int32_t	total;
		u_int32_t	remain;
	}		ld[IPS_MAXDRIVES];
};

struct ips_pg5 {
	u_int32_t	signature;
	u_int8_t	__reserved1;
	u_int8_t	slot;
	u_int16_t	type;
	u_int8_t	bioshi[4];
	u_int8_t	bioslo[4];
	u_int16_t	__reserved2;
	u_int8_t	__reserved3;
	u_int8_t	os;
	u_int8_t	driverhi[4];
	u_int8_t	driverlo[4];
	u_int8_t	__reserved4[100];
};

struct ips_info {
	struct ips_adapterinfo	adapter;
	struct ips_driveinfo	drive;
	struct ips_conf		conf;
	struct ips_rblstat	rblstat;
	struct ips_pg5		pg5;
};

/* Command control block */
struct ips_softc;
struct ips_ccb {
	struct ips_softc *	c_sc;		/* driver softc */
	int			c_id;		/* command id */
	int			c_flags;	/* SCSI_* flags */
	enum {
		IPS_CCB_FREE,
		IPS_CCB_QUEUED,
		IPS_CCB_DONE
	}			c_state;	/* command state */

	void *			c_cmdbva;	/* command block virt addr */
	paddr_t			c_cmdbpa;	/* command block phys addr */
	bus_dmamap_t		c_dmam;		/* data buffer DMA map */

	struct scsi_xfer *	c_xfer;		/* corresponding SCSI xfer */

	u_int8_t		c_stat;		/* status byte copy */
	u_int8_t		c_estat;	/* ext status byte copy */
	int			c_error;	/* completion error */

	void			(*c_done)(struct ips_softc *,	/* cmd done */
				    struct ips_ccb *);		/* callback */

	SLIST_ENTRY(ips_ccb)	c_link;		/* queue link */
};

/* CCB queue */
SLIST_HEAD(ips_ccbq, ips_ccb);

/* DMA-able chunk of memory */
struct dmamem {
	bus_dma_tag_t		dm_tag;
	bus_dmamap_t		dm_map;
	bus_dma_segment_t	dm_seg;
	bus_size_t		dm_size;
	void *			dm_vaddr;
#define dm_paddr dm_seg.ds_addr
};

struct ips_softc {
	struct device		sc_dev;

	struct scsi_link	sc_scsi_link;
	struct scsibus_softc *	sc_scsibus;

	struct ips_pt {
		struct ips_softc *	pt_sc;
		int			pt_chan;

		struct scsi_link	pt_link;

		int			pt_proctgt;
		char			pt_procdev[16];
	}			sc_pt[IPS_MAXCHANS];

	struct ksensordev	sc_sensordev;
	struct ksensor *	sc_sensors;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_dma_tag_t		sc_dmat;

	const struct ips_chipset *sc_chip;

	struct ips_info *	sc_info;
	struct dmamem		sc_infom;

	int			sc_nunits;

	struct dmamem		sc_cmdbm;

	struct ips_ccb *	sc_ccb;
	int			sc_nccbs;
	struct ips_ccbq		sc_ccbq_free;
	struct mutex		sc_ccb_mtx;
	struct scsi_iopool	sc_iopool;

	struct dmamem		sc_sqm;
	paddr_t			sc_sqtail;
	u_int32_t *		sc_sqbuf;
	int			sc_sqidx;
};

int	ips_match(struct device *, void *, void *);
void	ips_attach(struct device *, struct device *, void *);

void	ips_scsi_cmd(struct scsi_xfer *);
void	ips_scsi_pt_cmd(struct scsi_xfer *);
int	ips_scsi_ioctl(struct scsi_link *, u_long, caddr_t, int);

#if NBIO > 0
int	ips_ioctl(struct device *, u_long, caddr_t);
int	ips_ioctl_inq(struct ips_softc *, struct bioc_inq *);
int	ips_ioctl_vol(struct ips_softc *, struct bioc_vol *);
int	ips_ioctl_disk(struct ips_softc *, struct bioc_disk *);
int	ips_ioctl_setstate(struct ips_softc *, struct bioc_setstate *);
#endif

#ifndef SMALL_KERNEL
void	ips_sensors(void *);
#endif

int	ips_load_xs(struct ips_softc *, struct ips_ccb *, struct scsi_xfer *);
void	ips_start_xs(struct ips_softc *, struct ips_ccb *, struct scsi_xfer *);

int	ips_cmd(struct ips_softc *, struct ips_ccb *);
int	ips_poll(struct ips_softc *, struct ips_ccb *);
void	ips_done(struct ips_softc *, struct ips_ccb *);
void	ips_done_xs(struct ips_softc *, struct ips_ccb *);
void	ips_done_pt(struct ips_softc *, struct ips_ccb *);
void	ips_done_mgmt(struct ips_softc *, struct ips_ccb *);
int	ips_error(struct ips_softc *, struct ips_ccb *);
int	ips_error_xs(struct ips_softc *, struct ips_ccb *);
int	ips_intr(void *);
void	ips_timeout(void *);

int	ips_getadapterinfo(struct ips_softc *, int);
int	ips_getdriveinfo(struct ips_softc *, int);
int	ips_getconf(struct ips_softc *, int);
int	ips_getpg5(struct ips_softc *, int);

#if NBIO > 0
int	ips_getrblstat(struct ips_softc *, int);
int	ips_setstate(struct ips_softc *, int, int, int, int);
int	ips_rebuild(struct ips_softc *, int, int, int, int, int);
#endif

void	ips_copperhead_exec(struct ips_softc *, struct ips_ccb *);
void	ips_copperhead_intren(struct ips_softc *);
int	ips_copperhead_isintr(struct ips_softc *);
u_int32_t ips_copperhead_status(struct ips_softc *);

void	ips_morpheus_exec(struct ips_softc *, struct ips_ccb *);
void	ips_morpheus_intren(struct ips_softc *);
int	ips_morpheus_isintr(struct ips_softc *);
u_int32_t ips_morpheus_status(struct ips_softc *);

struct ips_ccb *ips_ccb_alloc(struct ips_softc *, int);
void	ips_ccb_free(struct ips_softc *, struct ips_ccb *, int);
void	*ips_ccb_get(void *);
void	ips_ccb_put(void *, void *);

int	ips_dmamem_alloc(struct dmamem *, bus_dma_tag_t, bus_size_t);
void	ips_dmamem_free(struct dmamem *);

struct cfattach ips_ca = {
	sizeof(struct ips_softc),
	ips_match,
	ips_attach
};

struct cfdriver ips_cd = {
	NULL, "ips", DV_DULL
};

static struct scsi_adapter ips_scsi_adapter = {
	ips_scsi_cmd,
	scsi_minphys,
	NULL,
	NULL,
	ips_scsi_ioctl
};

static struct scsi_adapter ips_scsi_pt_adapter = {
	ips_scsi_pt_cmd,
	scsi_minphys,
	NULL,
	NULL,
	NULL
};

static const struct pci_matchid ips_ids[] = {
	{ PCI_VENDOR_IBM,	PCI_PRODUCT_IBM_SERVERAID },
	{ PCI_VENDOR_IBM,	PCI_PRODUCT_IBM_SERVERAID2 },
	{ PCI_VENDOR_ADP2,	PCI_PRODUCT_ADP2_SERVERAID }
};

static const struct ips_chipset {
	enum {
		IPS_CHIP_COPPERHEAD = 0,
		IPS_CHIP_MORPHEUS
	}		ic_id;

	int		ic_bar;

	void		(*ic_exec)(struct ips_softc *, struct ips_ccb *);
	void		(*ic_intren)(struct ips_softc *);
	int		(*ic_isintr)(struct ips_softc *);
	u_int32_t	(*ic_status)(struct ips_softc *);
} ips_chips[] = {
	{
		IPS_CHIP_COPPERHEAD,
		0x14,
		ips_copperhead_exec,
		ips_copperhead_intren,
		ips_copperhead_isintr,
		ips_copperhead_status
	},
	{
		IPS_CHIP_MORPHEUS,
		0x10,
		ips_morpheus_exec,
		ips_morpheus_intren,
		ips_morpheus_isintr,
		ips_morpheus_status
	}
};

#define ips_exec(s, c)	(s)->sc_chip->ic_exec((s), (c))
#define ips_intren(s)	(s)->sc_chip->ic_intren((s))
#define ips_isintr(s)	(s)->sc_chip->ic_isintr((s))
#define ips_status(s)	(s)->sc_chip->ic_status((s))

static const char *ips_names[] = {
	NULL,
	NULL,
	"II",
	"onboard",
	"onboard",
	"3H",
	"3L",
	"4H",
	"4M",
	"4L",
	"4Mx",
	"4Lx",
	"5i",
	"5i",
	"6M",
	"6i",
	"7t",
	"7k",
	"7M"
};

int
ips_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid(aux, ips_ids,
	    sizeof(ips_ids) / sizeof(ips_ids[0])));
}

void
ips_attach(struct device *parent, struct device *self, void *aux)
{
	struct ips_softc *sc = (struct ips_softc *)self;
	struct pci_attach_args *pa = aux;
	struct ips_ccb ccb0;
	struct scsibus_attach_args saa;
	struct ips_adapterinfo *ai;
	struct ips_driveinfo *di;
	struct ips_pg5 *pg5;
	pcireg_t maptype;
	bus_size_t iosize;
	pci_intr_handle_t ih;
	const char *intrstr;
	int type, i;

	sc->sc_dmat = pa->pa_dmat;

	/* Identify chipset */
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_IBM_SERVERAID)
		sc->sc_chip = &ips_chips[IPS_CHIP_COPPERHEAD];
	else
		sc->sc_chip = &ips_chips[IPS_CHIP_MORPHEUS];

	/* Map registers */
	maptype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, sc->sc_chip->ic_bar);
	if (pci_mapreg_map(pa, sc->sc_chip->ic_bar, maptype, 0, &sc->sc_iot,
	    &sc->sc_ioh, NULL, &iosize, IPS_IOSIZE)) {
		printf(": can't map regs\n");
		return;
	}

	/* Allocate command buffer */
	if (ips_dmamem_alloc(&sc->sc_cmdbm, sc->sc_dmat,
	    IPS_MAXCMDS * sizeof(struct ips_cmdb))) {
		printf(": can't alloc cmd buffer\n");
		goto fail1;
	}

	/* Allocate info buffer */
	if (ips_dmamem_alloc(&sc->sc_infom, sc->sc_dmat,
	    sizeof(struct ips_info))) {
		printf(": can't alloc info buffer\n");
		goto fail2;
	}
	sc->sc_info = sc->sc_infom.dm_vaddr;
	ai = &sc->sc_info->adapter;
	di = &sc->sc_info->drive;
	pg5 = &sc->sc_info->pg5;

	/* Allocate status queue for the Copperhead chipset */
	if (sc->sc_chip->ic_id == IPS_CHIP_COPPERHEAD) {
		if (ips_dmamem_alloc(&sc->sc_sqm, sc->sc_dmat, IPS_SQSZ)) {
			printf(": can't alloc status queue\n");
			goto fail3;
		}
		sc->sc_sqtail = sc->sc_sqm.dm_paddr;
		sc->sc_sqbuf = sc->sc_sqm.dm_vaddr;
		sc->sc_sqidx = 0;
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, IPS_REG_SQS,
		    sc->sc_sqm.dm_paddr);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, IPS_REG_SQE,
		    sc->sc_sqm.dm_paddr + IPS_SQSZ);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, IPS_REG_SQH,
		    sc->sc_sqm.dm_paddr + sizeof(u_int32_t));
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, IPS_REG_SQT,
		    sc->sc_sqm.dm_paddr);
	}

	/* Bootstrap CCB queue */
	sc->sc_nccbs = 1;
	sc->sc_ccb = &ccb0;
	bzero(&ccb0, sizeof(ccb0));
	ccb0.c_cmdbva = sc->sc_cmdbm.dm_vaddr;
	ccb0.c_cmdbpa = sc->sc_cmdbm.dm_paddr;
	SLIST_INIT(&sc->sc_ccbq_free);
	SLIST_INSERT_HEAD(&sc->sc_ccbq_free, &ccb0, c_link);
	mtx_init(&sc->sc_ccb_mtx, IPL_BIO);
	scsi_iopool_init(&sc->sc_iopool, sc, ips_ccb_get, ips_ccb_put);

	/* Get adapter info */
	if (ips_getadapterinfo(sc, SCSI_NOSLEEP)) {
		printf(": can't get adapter info\n");
		goto fail4;
	}

	/* Get logical drives info */
	if (ips_getdriveinfo(sc, SCSI_NOSLEEP)) {
		printf(": can't get ld info\n");
		goto fail4;
	}
	sc->sc_nunits = di->drivecnt;

	/* Get configuration */
	if (ips_getconf(sc, SCSI_NOSLEEP)) {
		printf(": can't get config\n");
		goto fail4;
	}

	/* Read NVRAM page 5 for additional info */
	(void)ips_getpg5(sc, SCSI_NOSLEEP);

	/* Initialize CCB queue */
	sc->sc_nccbs = ai->cmdcnt;
	if ((sc->sc_ccb = ips_ccb_alloc(sc, sc->sc_nccbs)) == NULL) {
		printf(": can't alloc ccb queue\n");
		goto fail4;
	}
	SLIST_INIT(&sc->sc_ccbq_free);
	for (i = 0; i < sc->sc_nccbs; i++)
		SLIST_INSERT_HEAD(&sc->sc_ccbq_free,
		    &sc->sc_ccb[i], c_link);

	/* Install interrupt handler */
	if (pci_intr_map(pa, &ih)) {
		printf(": can't map interrupt\n");
		goto fail5;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	if (pci_intr_establish(pa->pa_pc, ih, IPL_BIO, ips_intr, sc,
	    sc->sc_dev.dv_xname) == NULL) {
		printf(": can't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail5;
	}
	printf(": %s\n", intrstr);

	/* Display adapter info */
	printf("%s: ServeRAID", sc->sc_dev.dv_xname);
	type = letoh16(pg5->type);
	if (type < sizeof(ips_names) / sizeof(ips_names[0]) && ips_names[type])
		printf(" %s", ips_names[type]);
	printf(", FW %c%c%c%c%c%c%c", ai->firmware[0], ai->firmware[1],
	    ai->firmware[2], ai->firmware[3], ai->firmware[4], ai->firmware[5],
	    ai->firmware[6]);
	printf(", BIOS %c%c%c%c%c%c%c", ai->bios[0], ai->bios[1], ai->bios[2],
	    ai->bios[3], ai->bios[4], ai->bios[5], ai->bios[6]);
	printf(", %d cmds, %d LD%s", sc->sc_nccbs, sc->sc_nunits,
	    (sc->sc_nunits == 1 ? "" : "s"));
	printf("\n");

	/* Attach SCSI bus */
	if (sc->sc_nunits > 0)
		sc->sc_scsi_link.openings = sc->sc_nccbs / sc->sc_nunits;
	sc->sc_scsi_link.adapter_target = sc->sc_nunits;
	sc->sc_scsi_link.adapter_buswidth = sc->sc_nunits;
	sc->sc_scsi_link.adapter = &ips_scsi_adapter;
	sc->sc_scsi_link.adapter_softc = sc;
	sc->sc_scsi_link.pool = &sc->sc_iopool;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_scsi_link;
	sc->sc_scsibus = (struct scsibus_softc *)config_found(self, &saa,
	    scsiprint);

	/* For each channel attach SCSI pass-through bus */
	bzero(&saa, sizeof(saa));
	for (i = 0; i < IPS_MAXCHANS; i++) {
		struct ips_pt *pt;
		struct scsi_link *link;
		int target, lastarget;

		pt = &sc->sc_pt[i];
		pt->pt_sc = sc;
		pt->pt_chan = i;
		pt->pt_proctgt = -1;

		/* Check if channel has any devices besides disks */
		for (target = 0, lastarget = -1; target < IPS_MAXTARGETS;
		    target++) {
			struct ips_dev *idev;
			int type;

			idev = &sc->sc_info->conf.dev[i][target];
			type = idev->params & SID_TYPE;
			if (idev->state && type != T_DIRECT) {
				lastarget = target;
				if (type == T_PROCESSOR ||
				    type == T_ENCLOSURE)
					/* remember enclosure address */
					pt->pt_proctgt = target;
			}
		}
		if (lastarget == -1)
			continue;

		link = &pt->pt_link;
		link->openings = 1;
		link->adapter_target = IPS_MAXTARGETS;
		link->adapter_buswidth = lastarget + 1;
		link->adapter = &ips_scsi_pt_adapter;
		link->adapter_softc = pt;
		link->pool = &sc->sc_iopool;

		saa.saa_sc_link = link;
		config_found(self, &saa, scsiprint);
	}

	/* Enable interrupts */
	ips_intren(sc);

#if NBIO > 0
	/* Install ioctl handler */
	if (bio_register(&sc->sc_dev, ips_ioctl))
		printf("%s: no ioctl support\n", sc->sc_dev.dv_xname);
#endif

#ifndef SMALL_KERNEL
	/* Add sensors */
	if ((sc->sc_sensors = mallocarray(sc->sc_nunits, sizeof(struct ksensor),
	    M_DEVBUF, M_NOWAIT | M_ZERO)) == NULL) {
		printf(": can't alloc sensors\n");
		return;
	}
	strlcpy(sc->sc_sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));
	for (i = 0; i < sc->sc_nunits; i++) {
		struct device *dev;

		sc->sc_sensors[i].type = SENSOR_DRIVE;
		sc->sc_sensors[i].status = SENSOR_S_UNKNOWN;
		dev = scsi_get_link(sc->sc_scsibus, i, 0)->device_softc;
		strlcpy(sc->sc_sensors[i].desc, dev->dv_xname,
		    sizeof(sc->sc_sensors[i].desc));
		sensor_attach(&sc->sc_sensordev, &sc->sc_sensors[i]);
	}
	if (sensor_task_register(sc, ips_sensors, 10) == NULL) {
		printf(": no sensors support\n");
		free(sc->sc_sensors, M_DEVBUF,
		    sc->sc_nunits * sizeof(struct ksensor));
		return;
	}
	sensordev_install(&sc->sc_sensordev);
#endif	/* !SMALL_KERNEL */

	return;
fail5:
	ips_ccb_free(sc, sc->sc_ccb, sc->sc_nccbs);
fail4:
	if (sc->sc_chip->ic_id == IPS_CHIP_COPPERHEAD)
		ips_dmamem_free(&sc->sc_sqm);
fail3:
	ips_dmamem_free(&sc->sc_infom);
fail2:
	ips_dmamem_free(&sc->sc_cmdbm);
fail1:
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
}

void
ips_scsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct ips_softc *sc = link->adapter_softc;
	struct ips_driveinfo *di = &sc->sc_info->drive;
	struct ips_drive *drive;
	struct scsi_inquiry_data inq;
	struct scsi_read_cap_data rcd;
	struct scsi_sense_data sd;
	struct scsi_rw *rw;
	struct scsi_rw_big *rwb;
	struct ips_ccb *ccb = xs->io;
	struct ips_cmd *cmd;
	int target = link->target;
	u_int32_t blkno, blkcnt;
	int code;

	DPRINTF(IPS_D_XFER, ("%s: ips_scsi_cmd: xs %p, target %d, "
	    "opcode 0x%02x, flags 0x%x\n", sc->sc_dev.dv_xname, xs, target,
	    xs->cmd->opcode, xs->flags));

	if (target >= sc->sc_nunits || link->lun != 0) {
		DPRINTF(IPS_D_INFO, ("%s: ips_scsi_cmd: invalid params "
		    "target %d, lun %d\n", sc->sc_dev.dv_xname,
		    target, link->lun));
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	drive = &di->drive[target];
	xs->error = XS_NOERROR;

	/* Fake SCSI commands */
	switch (xs->cmd->opcode) {
	case READ_BIG:
	case READ_COMMAND:
	case WRITE_BIG:
	case WRITE_COMMAND:
		if (xs->cmdlen == sizeof(struct scsi_rw)) {
			rw = (void *)xs->cmd;
			blkno = _3btol(rw->addr) &
			    (SRW_TOPADDR << 16 | 0xffff);
			blkcnt = rw->length ? rw->length : 0x100;
		} else {
			rwb = (void *)xs->cmd;
			blkno = _4btol(rwb->addr);
			blkcnt = _2btol(rwb->length);
		}

		if (blkno >= letoh32(drive->seccnt) || blkno + blkcnt >
		    letoh32(drive->seccnt)) {
			DPRINTF(IPS_D_ERR, ("%s: ips_scsi_cmd: invalid params "
			    "blkno %u, blkcnt %u\n", sc->sc_dev.dv_xname,
			    blkno, blkcnt));
			xs->error = XS_DRIVER_STUFFUP;
			break;
		}

		if (xs->flags & SCSI_DATA_IN)
			code = IPS_CMD_READ;
		else
			code = IPS_CMD_WRITE;

		ccb = xs->io;

		cmd = ccb->c_cmdbva;
		cmd->code = code;
		cmd->drive = target;
		cmd->lba = htole32(blkno);
		cmd->seccnt = htole16(blkcnt);

		if (ips_load_xs(sc, ccb, xs)) {
			DPRINTF(IPS_D_ERR, ("%s: ips_scsi_cmd: ips_load_xs "
			    "failed\n", sc->sc_dev.dv_xname));
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return;
		}

		if (cmd->sgcnt > 0)
			cmd->code |= IPS_CMD_SG;

		ccb->c_done = ips_done_xs;
		ips_start_xs(sc, ccb, xs);
		return;
	case INQUIRY:
		bzero(&inq, sizeof(inq));
		inq.device = T_DIRECT;
		inq.version = 2;
		inq.response_format = 2;
		inq.additional_length = 32;
		inq.flags |= SID_CmdQue;
		strlcpy(inq.vendor, "IBM", sizeof(inq.vendor));
		snprintf(inq.product, sizeof(inq.product),
		    "LD%d RAID%d", target, drive->raid);
		strlcpy(inq.revision, "1.0", sizeof(inq.revision));
		memcpy(xs->data, &inq, MIN(xs->datalen, sizeof(inq)));
		break;
	case READ_CAPACITY:
		bzero(&rcd, sizeof(rcd));
		_lto4b(letoh32(drive->seccnt) - 1, rcd.addr);
		_lto4b(IPS_SECSZ, rcd.length);
		memcpy(xs->data, &rcd, MIN(xs->datalen, sizeof(rcd)));
		break;
	case REQUEST_SENSE:
		bzero(&sd, sizeof(sd));
		sd.error_code = SSD_ERRCODE_CURRENT;
		sd.flags = SKEY_NO_SENSE;
		memcpy(xs->data, &sd, MIN(xs->datalen, sizeof(sd)));
		break;
	case SYNCHRONIZE_CACHE:
		cmd = ccb->c_cmdbva;
		cmd->code = IPS_CMD_FLUSH;

		ccb->c_done = ips_done_xs;
		ips_start_xs(sc, ccb, xs);
		return;
	case PREVENT_ALLOW:
	case START_STOP:
	case TEST_UNIT_READY:
		break;
	default:
		DPRINTF(IPS_D_INFO, ("%s: unsupported scsi command 0x%02x\n",
		    sc->sc_dev.dv_xname, xs->cmd->opcode));
		xs->error = XS_DRIVER_STUFFUP;
	}

	scsi_done(xs);
}

void
ips_scsi_pt_cmd(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct ips_pt *pt = link->adapter_softc;
	struct ips_softc *sc = pt->pt_sc;
	struct device *dev = link->device_softc;
	struct ips_ccb *ccb = xs->io;
	struct ips_cmdb *cmdb;
	struct ips_cmd *cmd;
	struct ips_dcdb *dcdb;
	int chan = pt->pt_chan, target = link->target;

	DPRINTF(IPS_D_XFER, ("%s: ips_scsi_pt_cmd: xs %p, chan %d, target %d, "
	    "opcode 0x%02x, flags 0x%x\n", sc->sc_dev.dv_xname, xs, chan,
	    target, xs->cmd->opcode, xs->flags));

	if (pt->pt_procdev[0] == '\0' && target == pt->pt_proctgt && dev)
		strlcpy(pt->pt_procdev, dev->dv_xname, sizeof(pt->pt_procdev));

	if (xs->cmdlen > IPS_MAXCDB) {
		DPRINTF(IPS_D_ERR, ("%s: cmdlen %d too big\n",
		    sc->sc_dev.dv_xname, xs->cmdlen));

		bzero(&xs->sense, sizeof(xs->sense));
		xs->sense.error_code = SSD_ERRCODE_VALID | SSD_ERRCODE_CURRENT;
		xs->sense.flags = SKEY_ILLEGAL_REQUEST;
		xs->sense.add_sense_code = 0x20; /* illcmd, 0x24 illfield */
		xs->error = XS_SENSE;
		scsi_done(xs);
		return;
	}

	xs->error = XS_NOERROR;

	cmdb = ccb->c_cmdbva;
	cmd = &cmdb->cmd;
	dcdb = &cmdb->dcdb;

	cmd->code = IPS_CMD_DCDB;

	dcdb->device = (chan << 4) | target;
	if (xs->flags & SCSI_DATA_IN)
		dcdb->attr |= IPS_DCDB_DATAIN;
	if (xs->flags & SCSI_DATA_OUT)
		dcdb->attr |= IPS_DCDB_DATAOUT;

	/*
	 * Adjust timeout value to what controller supports. Make sure our
	 * timeout will be fired after controller gives up.
	 */
	if (xs->timeout <= 10000) {
		dcdb->attr |= IPS_DCDB_TIMO10;
		xs->timeout = 11000;
	} else if (xs->timeout <= 60000) {
		dcdb->attr |= IPS_DCDB_TIMO60;
		xs->timeout = 61000;
	} else {
		dcdb->attr |= IPS_DCDB_TIMO20M;
		xs->timeout = 20 * 60000 + 1000;
	}

	dcdb->attr |= IPS_DCDB_DISCON;
	dcdb->datalen = htole16(xs->datalen);
	dcdb->cdblen = xs->cmdlen;
	dcdb->senselen = MIN(sizeof(xs->sense), sizeof(dcdb->sense));
	memcpy(dcdb->cdb, xs->cmd, xs->cmdlen);

	if (ips_load_xs(sc, ccb, xs)) {
		DPRINTF(IPS_D_ERR, ("%s: ips_scsi_pt_cmd: ips_load_xs "
		    "failed\n", sc->sc_dev.dv_xname));
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}
	if (cmd->sgcnt > 0)
		cmd->code |= IPS_CMD_SG;
	dcdb->sgaddr = cmd->sgaddr;
	dcdb->sgcnt = cmd->sgcnt;
	cmd->sgaddr = htole32(ccb->c_cmdbpa + offsetof(struct ips_cmdb, dcdb));
	cmd->sgcnt = 0;

	ccb->c_done = ips_done_pt;
	ips_start_xs(sc, ccb, xs);
}

int
ips_scsi_ioctl(struct scsi_link *link, u_long cmd, caddr_t addr, int flag)
{
#if NBIO > 0
	return (ips_ioctl(link->adapter_softc, cmd, addr));
#else
	return (ENOTTY);
#endif
}

#if NBIO > 0
int
ips_ioctl(struct device *dev, u_long cmd, caddr_t addr)
{
	struct ips_softc *sc = (struct ips_softc *)dev;

	DPRINTF(IPS_D_INFO, ("%s: ips_ioctl: cmd %lu\n",
	    sc->sc_dev.dv_xname, cmd));

	switch (cmd) {
	case BIOCINQ:
		return (ips_ioctl_inq(sc, (struct bioc_inq *)addr));
	case BIOCVOL:
		return (ips_ioctl_vol(sc, (struct bioc_vol *)addr));
	case BIOCDISK:
		return (ips_ioctl_disk(sc, (struct bioc_disk *)addr));
	case BIOCSETSTATE:
		return (ips_ioctl_setstate(sc, (struct bioc_setstate *)addr));
	default:
		return (ENOTTY);
	}
}

int
ips_ioctl_inq(struct ips_softc *sc, struct bioc_inq *bi)
{
	struct ips_conf *conf = &sc->sc_info->conf;
	int i;

	strlcpy(bi->bi_dev, sc->sc_dev.dv_xname, sizeof(bi->bi_dev));
	bi->bi_novol = sc->sc_nunits;
	for (i = 0, bi->bi_nodisk = 0; i < sc->sc_nunits; i++)
		bi->bi_nodisk += conf->ld[i].chunkcnt;

	DPRINTF(IPS_D_INFO, ("%s: ips_ioctl_inq: novol %d, nodisk %d\n",
	    bi->bi_dev, bi->bi_novol, bi->bi_nodisk));

	return (0);
}

int
ips_ioctl_vol(struct ips_softc *sc, struct bioc_vol *bv)
{
	struct ips_driveinfo *di = &sc->sc_info->drive;
	struct ips_conf *conf = &sc->sc_info->conf;
	struct ips_rblstat *rblstat = &sc->sc_info->rblstat;
	struct ips_ld *ld;
	int vid = bv->bv_volid;
	struct device *dv;
	int error, rebuild = 0;
	u_int32_t total = 0, done = 0;

	if (vid >= sc->sc_nunits)
		return (EINVAL);
	if ((error = ips_getconf(sc, 0)))
		return (error);
	ld = &conf->ld[vid];

	switch (ld->state) {
	case IPS_DS_ONLINE:
		bv->bv_status = BIOC_SVONLINE;
		break;
	case IPS_DS_DEGRADED:
		bv->bv_status = BIOC_SVDEGRADED;
		rebuild++;
		break;
	case IPS_DS_OFFLINE:
		bv->bv_status = BIOC_SVOFFLINE;
		break;
	default:
		bv->bv_status = BIOC_SVINVALID;
	}

	if (rebuild && ips_getrblstat(sc, 0) == 0) {
		total = letoh32(rblstat->ld[vid].total);
		done = total - letoh32(rblstat->ld[vid].remain);
		if (total && total > done) {
			bv->bv_status = BIOC_SVREBUILD;
			bv->bv_percent = 100 * done / total;
		}
	}

	bv->bv_size = (uint64_t)letoh32(ld->size) * IPS_SECSZ;
	bv->bv_level = di->drive[vid].raid;
	bv->bv_nodisk = ld->chunkcnt;

	/* Associate all unused and spare drives with first volume */
	if (vid == 0) {
		struct ips_dev *dev;
		int chan, target;

		for (chan = 0; chan < IPS_MAXCHANS; chan++)
			for (target = 0; target < IPS_MAXTARGETS; target++) {
				dev = &conf->dev[chan][target];
				if (dev->state && !(dev->state &
				    IPS_DVS_MEMBER) &&
				    (dev->params & SID_TYPE) == T_DIRECT)
					bv->bv_nodisk++;
			}
	}

	dv = scsi_get_link(sc->sc_scsibus, vid, 0)->device_softc;
	strlcpy(bv->bv_dev, dv->dv_xname, sizeof(bv->bv_dev));
	strlcpy(bv->bv_vendor, "IBM", sizeof(bv->bv_vendor));

	DPRINTF(IPS_D_INFO, ("%s: ips_ioctl_vol: vid %d, state 0x%02x, "
	    "total %u, done %u, size %llu, level %d, nodisk %d, dev %s\n",
	    sc->sc_dev.dv_xname, vid, ld->state, total, done, bv->bv_size,
	    bv->bv_level, bv->bv_nodisk, bv->bv_dev));

	return (0);
}

int
ips_ioctl_disk(struct ips_softc *sc, struct bioc_disk *bd)
{
	struct ips_conf *conf = &sc->sc_info->conf;
	struct ips_ld *ld;
	struct ips_chunk *chunk;
	struct ips_dev *dev;
	int vid = bd->bd_volid, did = bd->bd_diskid;
	int chan, target, error, i;

	if (vid >= sc->sc_nunits)
		return (EINVAL);
	if ((error = ips_getconf(sc, 0)))
		return (error);
	ld = &conf->ld[vid];

	if (did >= ld->chunkcnt) {
		/* Probably unused or spare drives */
		if (vid != 0)
			return (EINVAL);

		i = ld->chunkcnt;
		for (chan = 0; chan < IPS_MAXCHANS; chan++)
			for (target = 0; target < IPS_MAXTARGETS; target++) {
				dev = &conf->dev[chan][target];
				if (dev->state && !(dev->state &
				    IPS_DVS_MEMBER) &&
				    (dev->params & SID_TYPE) == T_DIRECT)
					if (i++ == did)
						goto out;
			}
	} else {
		chunk = &ld->chunk[did];
		chan = chunk->channel;
		target = chunk->target;
	}

out:
	if (chan >= IPS_MAXCHANS || target >= IPS_MAXTARGETS)
		return (EINVAL);
	dev = &conf->dev[chan][target];

	bd->bd_channel = chan;
	bd->bd_target = target;
	bd->bd_lun = 0;
	bd->bd_size = (uint64_t)letoh32(dev->seccnt) * IPS_SECSZ;

	bzero(bd->bd_vendor, sizeof(bd->bd_vendor));
	memcpy(bd->bd_vendor, dev->devid, MIN(sizeof(bd->bd_vendor),
	    sizeof(dev->devid)));
	strlcpy(bd->bd_procdev, sc->sc_pt[chan].pt_procdev,
	    sizeof(bd->bd_procdev));

	if (dev->state & IPS_DVS_READY) {
		bd->bd_status = BIOC_SDUNUSED;
		if (dev->state & IPS_DVS_MEMBER)
			bd->bd_status = BIOC_SDONLINE;
		if (dev->state & IPS_DVS_SPARE)
			bd->bd_status = BIOC_SDHOTSPARE;
		if (dev->state & IPS_DVS_REBUILD)
			bd->bd_status = BIOC_SDREBUILD;
	} else {
		bd->bd_status = BIOC_SDOFFLINE;
	}

	DPRINTF(IPS_D_INFO, ("%s: ips_ioctl_disk: vid %d, did %d, channel %d, "
	    "target %d, size %llu, state 0x%02x\n", sc->sc_dev.dv_xname,
	    vid, did, bd->bd_channel, bd->bd_target, bd->bd_size, dev->state));

	return (0);
}

int
ips_ioctl_setstate(struct ips_softc *sc, struct bioc_setstate *bs)
{
	struct ips_conf *conf = &sc->sc_info->conf;
	struct ips_dev *dev;
	int state, error;

	if (bs->bs_channel >= IPS_MAXCHANS || bs->bs_target >= IPS_MAXTARGETS)
		return (EINVAL);
	if ((error = ips_getconf(sc, 0)))
		return (error);
	dev = &conf->dev[bs->bs_channel][bs->bs_target];
	state = dev->state;

	switch (bs->bs_status) {
	case BIOC_SSONLINE:
		state |= IPS_DVS_READY;
		break;
	case BIOC_SSOFFLINE:
		state &= ~IPS_DVS_READY;
		break;
	case BIOC_SSHOTSPARE:
		state |= IPS_DVS_SPARE;
		break;
	case BIOC_SSREBUILD:
		return (ips_rebuild(sc, bs->bs_channel, bs->bs_target,
		    bs->bs_channel, bs->bs_target, 0));
	default:
		return (EINVAL);
	}

	return (ips_setstate(sc, bs->bs_channel, bs->bs_target, state, 0));
}
#endif	/* NBIO > 0 */

#ifndef SMALL_KERNEL
void
ips_sensors(void *arg)
{
	struct ips_softc *sc = arg;
	struct ips_conf *conf = &sc->sc_info->conf;
	struct ips_ld *ld;
	int i;

	/* ips_sensors() runs from work queue thus allowed to sleep */
	if (ips_getconf(sc, 0)) {
		DPRINTF(IPS_D_ERR, ("%s: ips_sensors: ips_getconf failed\n",
		    sc->sc_dev.dv_xname));

		for (i = 0; i < sc->sc_nunits; i++) {
			sc->sc_sensors[i].value = 0;
			sc->sc_sensors[i].status = SENSOR_S_UNKNOWN;
		}
		return;
	}

	DPRINTF(IPS_D_INFO, ("%s: ips_sensors:", sc->sc_dev.dv_xname));
	for (i = 0; i < sc->sc_nunits; i++) {
		ld = &conf->ld[i];
		DPRINTF(IPS_D_INFO, (" ld%d.state 0x%02x", i, ld->state));
		switch (ld->state) {
		case IPS_DS_ONLINE:
			sc->sc_sensors[i].value = SENSOR_DRIVE_ONLINE;
			sc->sc_sensors[i].status = SENSOR_S_OK;
			break;
		case IPS_DS_DEGRADED:
			sc->sc_sensors[i].value = SENSOR_DRIVE_PFAIL;
			sc->sc_sensors[i].status = SENSOR_S_WARN;
			break;
		case IPS_DS_OFFLINE:
			sc->sc_sensors[i].value = SENSOR_DRIVE_FAIL;
			sc->sc_sensors[i].status = SENSOR_S_CRIT;
			break;
		default:
			sc->sc_sensors[i].value = 0;
			sc->sc_sensors[i].status = SENSOR_S_UNKNOWN;
		}
	}
	DPRINTF(IPS_D_INFO, ("\n"));
}
#endif	/* !SMALL_KERNEL */

int
ips_load_xs(struct ips_softc *sc, struct ips_ccb *ccb, struct scsi_xfer *xs)
{
	struct ips_cmdb *cmdb = ccb->c_cmdbva;
	struct ips_cmd *cmd = &cmdb->cmd;
	struct ips_sg *sg = cmdb->sg;
	int nsegs, i;

	if (xs->datalen == 0)
		return (0);

	/* Map data buffer into DMA segments */
	if (bus_dmamap_load(sc->sc_dmat, ccb->c_dmam, xs->data, xs->datalen,
	    NULL, (xs->flags & SCSI_NOSLEEP ? BUS_DMA_NOWAIT : 0)))
		return (1);
	bus_dmamap_sync(sc->sc_dmat, ccb->c_dmam, 0,ccb->c_dmam->dm_mapsize,
	    xs->flags & SCSI_DATA_IN ? BUS_DMASYNC_PREREAD :
	    BUS_DMASYNC_PREWRITE);

	if ((nsegs = ccb->c_dmam->dm_nsegs) > IPS_MAXSGS)
		return (1);

	if (nsegs > 1) {
		cmd->sgcnt = nsegs;
		cmd->sgaddr = htole32(ccb->c_cmdbpa + offsetof(struct ips_cmdb,
		    sg));

		/* Fill in scatter-gather array */
		for (i = 0; i < nsegs; i++) {
			sg[i].addr = htole32(ccb->c_dmam->dm_segs[i].ds_addr);
			sg[i].size = htole32(ccb->c_dmam->dm_segs[i].ds_len);
		}
	} else {
		cmd->sgcnt = 0;
		cmd->sgaddr = htole32(ccb->c_dmam->dm_segs[0].ds_addr);
	}

	return (0);
}

void
ips_start_xs(struct ips_softc *sc, struct ips_ccb *ccb, struct scsi_xfer *xs)
{
	ccb->c_flags = xs->flags;
	ccb->c_xfer = xs;
	int ispoll = xs->flags & SCSI_POLL;

	if (!ispoll) {
		timeout_set(&xs->stimeout, ips_timeout, ccb);
		timeout_add_msec(&xs->stimeout, xs->timeout);
	}

	/*
	 * Return value not used here because ips_cmd() must complete
	 * scsi_xfer on any failure and SCSI layer will handle possible
	 * errors.
	 */
	ips_cmd(sc, ccb);
}

int
ips_cmd(struct ips_softc *sc, struct ips_ccb *ccb)
{
	struct ips_cmd *cmd = ccb->c_cmdbva;
	int s, error = 0;

	DPRINTF(IPS_D_XFER, ("%s: ips_cmd: id 0x%02x, flags 0x%x, xs %p, "
	    "code 0x%02x, drive %d, sgcnt %d, lba %d, sgaddr 0x%08x, "
	    "seccnt %d\n", sc->sc_dev.dv_xname, ccb->c_id, ccb->c_flags,
	    ccb->c_xfer, cmd->code, cmd->drive, cmd->sgcnt, letoh32(cmd->lba),
	    letoh32(cmd->sgaddr), letoh16(cmd->seccnt)));

	cmd->id = ccb->c_id;

	/* Post command to controller and optionally wait for completion */
	s = splbio();
	ips_exec(sc, ccb);
	ccb->c_state = IPS_CCB_QUEUED;
	if (ccb->c_flags & SCSI_POLL)
		error = ips_poll(sc, ccb);
	splx(s);

	return (error);
}

int
ips_poll(struct ips_softc *sc, struct ips_ccb *ccb)
{
	struct timeval tv;
	int error, timo;

	splassert(IPL_BIO);

	if (ccb->c_flags & SCSI_NOSLEEP) {
		/* busy-wait */
		DPRINTF(IPS_D_XFER, ("%s: ips_poll: busy-wait\n",
		    sc->sc_dev.dv_xname));

		for (timo = 10000; timo > 0; timo--) {
			delay(100);
			ips_intr(sc);
			if (ccb->c_state == IPS_CCB_DONE)
				break;
		}
	} else {
		/* sleep */
		timo = ccb->c_xfer ? ccb->c_xfer->timeout : IPS_TIMEOUT;
		tv.tv_sec = timo / 1000;
		tv.tv_usec = (timo % 1000) * 1000;
		timo = tvtohz(&tv);

		DPRINTF(IPS_D_XFER, ("%s: ips_poll: sleep %d hz\n",
		    sc->sc_dev.dv_xname, timo));
		tsleep(ccb, PRIBIO + 1, "ipscmd", timo);
	}
	DPRINTF(IPS_D_XFER, ("%s: ips_poll: state %d\n", sc->sc_dev.dv_xname,
	    ccb->c_state));

	if (ccb->c_state != IPS_CCB_DONE)
		/*
		 * Command never completed. Fake hardware status byte
		 * to indicate timeout.
		 */
		ccb->c_stat = IPS_STAT_TIMO;

	ips_done(sc, ccb);
	error = ccb->c_error;

	return (error);
}

void
ips_done(struct ips_softc *sc, struct ips_ccb *ccb)
{
	splassert(IPL_BIO);

	DPRINTF(IPS_D_XFER, ("%s: ips_done: id 0x%02x, flags 0x%x, xs %p\n",
	    sc->sc_dev.dv_xname, ccb->c_id, ccb->c_flags, ccb->c_xfer));

	ccb->c_error = ips_error(sc, ccb);
	ccb->c_done(sc, ccb);
}

void
ips_done_xs(struct ips_softc *sc, struct ips_ccb *ccb)
{
	struct scsi_xfer *xs = ccb->c_xfer;

	if (!(xs->flags & SCSI_POLL))
		timeout_del(&xs->stimeout);

	if (xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
		bus_dmamap_sync(sc->sc_dmat, ccb->c_dmam, 0,
		    ccb->c_dmam->dm_mapsize, xs->flags & SCSI_DATA_IN ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ccb->c_dmam);
	}

	xs->resid = 0;
	xs->error = ips_error_xs(sc, ccb);
	scsi_done(xs);
}

void
ips_done_pt(struct ips_softc *sc, struct ips_ccb *ccb)
{
	struct scsi_xfer *xs = ccb->c_xfer;
	struct ips_cmdb *cmdb = ccb->c_cmdbva;
	struct ips_dcdb *dcdb = &cmdb->dcdb;
	int done = letoh16(dcdb->datalen);

	if (!(xs->flags & SCSI_POLL))
		timeout_del(&xs->stimeout);

	if (xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
		bus_dmamap_sync(sc->sc_dmat, ccb->c_dmam, 0,
		    ccb->c_dmam->dm_mapsize, xs->flags & SCSI_DATA_IN ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ccb->c_dmam);
	}

	if (done && done < xs->datalen)
		xs->resid = xs->datalen - done;
	else
		xs->resid = 0;
	xs->error = ips_error_xs(sc, ccb);
	xs->status = dcdb->status;

	if (xs->error == XS_SENSE)
		memcpy(&xs->sense, dcdb->sense, MIN(sizeof(xs->sense),
		    sizeof(dcdb->sense)));

	if (xs->cmd->opcode == INQUIRY && xs->error == XS_NOERROR) {
		int type = ((struct scsi_inquiry_data *)xs->data)->device &
		    SID_TYPE;

		if (type == T_DIRECT)
			/* mask physical drives */
			xs->error = XS_DRIVER_STUFFUP;
	}

	scsi_done(xs);
}

void
ips_done_mgmt(struct ips_softc *sc, struct ips_ccb *ccb)
{
	if (ccb->c_flags & (SCSI_DATA_IN | SCSI_DATA_OUT))
		bus_dmamap_sync(sc->sc_dmat, sc->sc_infom.dm_map, 0,
		    sc->sc_infom.dm_map->dm_mapsize,
		    ccb->c_flags & SCSI_DATA_IN ? BUS_DMASYNC_POSTREAD :
		    BUS_DMASYNC_POSTWRITE);
	scsi_io_put(&sc->sc_iopool, ccb);
}

int
ips_error(struct ips_softc *sc, struct ips_ccb *ccb)
{
	struct ips_cmdb *cmdb = ccb->c_cmdbva;
	struct ips_cmd *cmd = &cmdb->cmd;
	struct ips_dcdb *dcdb = &cmdb->dcdb;
	struct scsi_xfer *xs = ccb->c_xfer;
	u_int8_t gsc = IPS_STAT_GSC(ccb->c_stat);

	if (gsc == IPS_STAT_OK)
		return (0);

	DPRINTF(IPS_D_ERR, ("%s: ips_error: stat 0x%02x, estat 0x%02x, "
	    "cmd code 0x%02x, drive %d, sgcnt %d, lba %u, seccnt %d",
	    sc->sc_dev.dv_xname, ccb->c_stat, ccb->c_estat, cmd->code,
	    cmd->drive, cmd->sgcnt, letoh32(cmd->lba), letoh16(cmd->seccnt)));
	if (cmd->code == IPS_CMD_DCDB || cmd->code == IPS_CMD_DCDB_SG) {
		int i;

		DPRINTF(IPS_D_ERR, (", dcdb device 0x%02x, attr 0x%02x, "
		    "datalen %d, sgcnt %d, status 0x%02x",
		    dcdb->device, dcdb->attr, letoh16(dcdb->datalen),
		    dcdb->sgcnt, dcdb->status));

		DPRINTF(IPS_D_ERR, (", cdb"));
		for (i = 0; i < dcdb->cdblen; i++)
			DPRINTF(IPS_D_ERR, (" %x", dcdb->cdb[i]));
		if (ccb->c_estat == IPS_ESTAT_CKCOND) {
			DPRINTF(IPS_D_ERR, (", sense"));
			for (i = 0; i < dcdb->senselen; i++)
				DPRINTF(IPS_D_ERR, (" %x", dcdb->sense[i]));
		}
	}		
	DPRINTF(IPS_D_ERR, ("\n"));

	switch (gsc) {
	case IPS_STAT_RECOV:
		return (0);
	case IPS_STAT_INVOP:
	case IPS_STAT_INVCMD:
	case IPS_STAT_INVPARM:
		return (EINVAL);
	case IPS_STAT_BUSY:
		return (EBUSY);
	case IPS_STAT_TIMO:
		return (ETIMEDOUT);
	case IPS_STAT_PDRVERR:
		switch (ccb->c_estat) {
		case IPS_ESTAT_SELTIMO:
			return (ENODEV);
		case IPS_ESTAT_OURUN:
			if (xs && letoh16(dcdb->datalen) < xs->datalen)
				/* underrun */
				return (0);
			break;
		case IPS_ESTAT_RECOV:
			return (0);
		}
		break;
	}

	return (EIO);
}

int
ips_error_xs(struct ips_softc *sc, struct ips_ccb *ccb)
{
	struct ips_cmdb *cmdb = ccb->c_cmdbva;
	struct ips_dcdb *dcdb = &cmdb->dcdb;
	struct scsi_xfer *xs = ccb->c_xfer;
	u_int8_t gsc = IPS_STAT_GSC(ccb->c_stat);

	/* Map hardware error codes to SCSI ones */
	switch (gsc) {
	case IPS_STAT_OK:
	case IPS_STAT_RECOV:
		return (XS_NOERROR);
	case IPS_STAT_BUSY:
		return (XS_BUSY);
	case IPS_STAT_TIMO:
		return (XS_TIMEOUT);
	case IPS_STAT_PDRVERR:
		switch (ccb->c_estat) {
		case IPS_ESTAT_SELTIMO:
			return (XS_SELTIMEOUT);
		case IPS_ESTAT_OURUN:
			if (xs && letoh16(dcdb->datalen) < xs->datalen)
				/* underrun */
				return (XS_NOERROR);
			break;
		case IPS_ESTAT_HOSTRST:
		case IPS_ESTAT_DEVRST:
			return (XS_RESET);
		case IPS_ESTAT_RECOV:
			return (XS_NOERROR);
		case IPS_ESTAT_CKCOND:
			return (XS_SENSE);
		}
		break;
	}

	return (XS_DRIVER_STUFFUP);
}

int
ips_intr(void *arg)
{
	struct ips_softc *sc = arg;
	struct ips_ccb *ccb;
	u_int32_t status;
	int id;

	DPRINTF(IPS_D_XFER, ("%s: ips_intr", sc->sc_dev.dv_xname));
	if (!ips_isintr(sc)) {
		DPRINTF(IPS_D_XFER, (": not ours\n"));
		return (0);
	}
	DPRINTF(IPS_D_XFER, ("\n"));

	/* Process completed commands */
	while ((status = ips_status(sc)) != 0xffffffff) {
		DPRINTF(IPS_D_XFER, ("%s: ips_intr: status 0x%08x\n",
		    sc->sc_dev.dv_xname, status));

		id = IPS_STAT_ID(status);
		if (id >= sc->sc_nccbs) {
			DPRINTF(IPS_D_ERR, ("%s: ips_intr: invalid id %d\n",
			    sc->sc_dev.dv_xname, id));
			continue;
		}

		ccb = &sc->sc_ccb[id];
		if (ccb->c_state != IPS_CCB_QUEUED) {
			DPRINTF(IPS_D_ERR, ("%s: ips_intr: cmd 0x%02x not "
			    "queued, state %d, status 0x%08x\n",
			    sc->sc_dev.dv_xname, ccb->c_id, ccb->c_state,
			    status));
			continue;
		}

		ccb->c_state = IPS_CCB_DONE;
		ccb->c_stat = IPS_STAT_BASIC(status);
		ccb->c_estat = IPS_STAT_EXT(status);

		if (ccb->c_flags & SCSI_POLL) {
			wakeup(ccb);
		} else {
			ips_done(sc, ccb);
		}
	}

	return (1);
}

void
ips_timeout(void *arg)
{
	struct ips_ccb *ccb = arg;
	struct ips_softc *sc = ccb->c_sc;
	struct scsi_xfer *xs = ccb->c_xfer;
	int s;

	s = splbio();
	if (xs)
		sc_print_addr(xs->sc_link);
	else
		printf("%s: ", sc->sc_dev.dv_xname);
	printf("timeout\n");

	/*
	 * Command never completed. Fake hardware status byte
	 * to indicate timeout.
	 * XXX: need to remove command from controller.
	 */
	ccb->c_stat = IPS_STAT_TIMO;
	ips_done(sc, ccb);
	splx(s);
}

int
ips_getadapterinfo(struct ips_softc *sc, int flags)
{
	struct ips_ccb *ccb;
	struct ips_cmd *cmd;

	ccb = scsi_io_get(&sc->sc_iopool, 0);
	if (ccb == NULL)
		return (1);

	ccb->c_flags = SCSI_DATA_IN | SCSI_POLL | flags;
	ccb->c_done = ips_done_mgmt;

	cmd = ccb->c_cmdbva;
	cmd->code = IPS_CMD_GETADAPTERINFO;
	cmd->sgaddr = htole32(sc->sc_infom.dm_paddr + offsetof(struct ips_info,
	    adapter));

	return (ips_cmd(sc, ccb));
}

int
ips_getdriveinfo(struct ips_softc *sc, int flags)
{
	struct ips_ccb *ccb;
	struct ips_cmd *cmd;

	ccb = scsi_io_get(&sc->sc_iopool, 0);
	if (ccb == NULL)
		return (1);

	ccb->c_flags = SCSI_DATA_IN | SCSI_POLL | flags;
	ccb->c_done = ips_done_mgmt;

	cmd = ccb->c_cmdbva;
	cmd->code = IPS_CMD_GETDRIVEINFO;
	cmd->sgaddr = htole32(sc->sc_infom.dm_paddr + offsetof(struct ips_info,
	    drive));

	return (ips_cmd(sc, ccb));
}

int
ips_getconf(struct ips_softc *sc, int flags)
{
	struct ips_ccb *ccb;
	struct ips_cmd *cmd;

	ccb = scsi_io_get(&sc->sc_iopool, 0);
	if (ccb == NULL)
		return (1);

	ccb->c_flags = SCSI_DATA_IN | SCSI_POLL | flags;
	ccb->c_done = ips_done_mgmt;

	cmd = ccb->c_cmdbva;
	cmd->code = IPS_CMD_READCONF;
	cmd->sgaddr = htole32(sc->sc_infom.dm_paddr + offsetof(struct ips_info,
	    conf));

	return (ips_cmd(sc, ccb));
}

int
ips_getpg5(struct ips_softc *sc, int flags)
{
	struct ips_ccb *ccb;
	struct ips_cmd *cmd;

	ccb = scsi_io_get(&sc->sc_iopool, 0);
	if (ccb == NULL)
		return (1);

	ccb->c_flags = SCSI_DATA_IN | SCSI_POLL | flags;
	ccb->c_done = ips_done_mgmt;

	cmd = ccb->c_cmdbva;
	cmd->code = IPS_CMD_RWNVRAM;
	cmd->drive = 5;
	cmd->sgaddr = htole32(sc->sc_infom.dm_paddr + offsetof(struct ips_info,
	    pg5));

	return (ips_cmd(sc, ccb));
}

#if NBIO > 0
int
ips_getrblstat(struct ips_softc *sc, int flags)
{
	struct ips_ccb *ccb;
	struct ips_cmd *cmd;

	ccb = scsi_io_get(&sc->sc_iopool, 0);
	if (ccb == NULL)
		return (1);

	ccb->c_flags = SCSI_DATA_IN | SCSI_POLL | flags;
	ccb->c_done = ips_done_mgmt;

	cmd = ccb->c_cmdbva;
	cmd->code = IPS_CMD_REBUILDSTATUS;
	cmd->sgaddr = htole32(sc->sc_infom.dm_paddr + offsetof(struct ips_info,
	    rblstat));

	return (ips_cmd(sc, ccb));
}

int
ips_setstate(struct ips_softc *sc, int chan, int target, int state, int flags)
{
	struct ips_ccb *ccb;
	struct ips_cmd *cmd;

	ccb = scsi_io_get(&sc->sc_iopool, 0);
	if (ccb == NULL)
		return (1);

	ccb->c_flags = SCSI_POLL | flags;
	ccb->c_done = ips_done_mgmt;

	cmd = ccb->c_cmdbva;
	cmd->code = IPS_CMD_SETSTATE;
	cmd->drive = chan;
	cmd->sgcnt = target;
	cmd->seg4g = state;

	return (ips_cmd(sc, ccb));
}

int
ips_rebuild(struct ips_softc *sc, int chan, int target, int nchan,
    int ntarget, int flags)
{
	struct ips_ccb *ccb;
	struct ips_cmd *cmd;

	ccb = scsi_io_get(&sc->sc_iopool, 0);
	if (ccb == NULL)
		return (1);

	ccb->c_flags = SCSI_POLL | flags;
	ccb->c_done = ips_done_mgmt;

	cmd = ccb->c_cmdbva;
	cmd->code = IPS_CMD_REBUILD;
	cmd->drive = chan;
	cmd->sgcnt = target;
	cmd->seccnt = htole16(ntarget << 8 | nchan);

	return (ips_cmd(sc, ccb));
}
#endif	/* NBIO > 0 */

void
ips_copperhead_exec(struct ips_softc *sc, struct ips_ccb *ccb)
{
	u_int32_t reg;
	int timeout;

	for (timeout = 100; timeout-- > 0; delay(100)) {
		reg = bus_space_read_4(sc->sc_iot, sc->sc_ioh, IPS_REG_CCC);
		if ((reg & IPS_REG_CCC_SEM) == 0)
			break;
	}
	if (timeout < 0) {
		printf("%s: semaphore timeout\n", sc->sc_dev.dv_xname);
		return;
	}

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, IPS_REG_CCSA, ccb->c_cmdbpa);
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, IPS_REG_CCC,
	    IPS_REG_CCC_START);
}

void
ips_copperhead_intren(struct ips_softc *sc)
{
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, IPS_REG_HIS, IPS_REG_HIS_EN);
}

int
ips_copperhead_isintr(struct ips_softc *sc)
{
	u_int8_t reg;

	reg = bus_space_read_1(sc->sc_iot, sc->sc_ioh, IPS_REG_HIS);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, IPS_REG_HIS, reg);
	if (reg != 0xff && (reg & IPS_REG_HIS_SCE))
		return (1);

	return (0);
}

u_int32_t
ips_copperhead_status(struct ips_softc *sc)
{
	u_int32_t sqhead, sqtail, status;

	sqhead = bus_space_read_4(sc->sc_iot, sc->sc_ioh, IPS_REG_SQH);
	DPRINTF(IPS_D_XFER, ("%s: sqhead 0x%08x, sqtail 0x%08x\n",
	    sc->sc_dev.dv_xname, sqhead, sc->sc_sqtail));

	sqtail = sc->sc_sqtail + sizeof(u_int32_t);
	if (sqtail == sc->sc_sqm.dm_paddr + IPS_SQSZ)
		sqtail = sc->sc_sqm.dm_paddr;
	if (sqtail == sqhead)
		return (0xffffffff);

	sc->sc_sqtail = sqtail;
	if (++sc->sc_sqidx == IPS_MAXCMDS)
		sc->sc_sqidx = 0;
	status = letoh32(sc->sc_sqbuf[sc->sc_sqidx]);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, IPS_REG_SQT, sqtail);

	return (status);
}

void
ips_morpheus_exec(struct ips_softc *sc, struct ips_ccb *ccb)
{
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, IPS_REG_IQP, ccb->c_cmdbpa);
}

void
ips_morpheus_intren(struct ips_softc *sc)
{
	u_int32_t reg;

	reg = bus_space_read_4(sc->sc_iot, sc->sc_ioh, IPS_REG_OIM);
	reg &= ~IPS_REG_OIM_DS;
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, IPS_REG_OIM, reg);
}

int
ips_morpheus_isintr(struct ips_softc *sc)
{
	return (bus_space_read_4(sc->sc_iot, sc->sc_ioh, IPS_REG_OIS) &
	    IPS_REG_OIS_PEND);
}

u_int32_t
ips_morpheus_status(struct ips_softc *sc)
{
	u_int32_t reg;

	reg = bus_space_read_4(sc->sc_iot, sc->sc_ioh, IPS_REG_OQP);
	DPRINTF(IPS_D_XFER, ("%s: status 0x%08x\n", sc->sc_dev.dv_xname, reg));

	return (reg);
}

struct ips_ccb *
ips_ccb_alloc(struct ips_softc *sc, int n)
{
	struct ips_ccb *ccb;
	int i;

	if ((ccb = mallocarray(n, sizeof(*ccb), M_DEVBUF,
	    M_NOWAIT | M_ZERO)) == NULL)
		return (NULL);

	for (i = 0; i < n; i++) {
		ccb[i].c_sc = sc;
		ccb[i].c_id = i;
		ccb[i].c_cmdbva = (char *)sc->sc_cmdbm.dm_vaddr +
		    i * sizeof(struct ips_cmdb);
		ccb[i].c_cmdbpa = sc->sc_cmdbm.dm_paddr +
		    i * sizeof(struct ips_cmdb);
		if (bus_dmamap_create(sc->sc_dmat, IPS_MAXFER, IPS_MAXSGS,
		    IPS_MAXFER, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
		    &ccb[i].c_dmam))
			goto fail;
	}

	return (ccb);
fail:
	for (; i > 0; i--)
		bus_dmamap_destroy(sc->sc_dmat, ccb[i - 1].c_dmam);
	free(ccb, M_DEVBUF, n * sizeof(*ccb));
	return (NULL);
}

void
ips_ccb_free(struct ips_softc *sc, struct ips_ccb *ccb, int n)
{
	int i;

	for (i = 0; i < n; i++)
		bus_dmamap_destroy(sc->sc_dmat, ccb[i - 1].c_dmam);
	free(ccb, M_DEVBUF, n * sizeof(*ccb));
}

void *
ips_ccb_get(void *xsc)
{
	struct ips_softc *sc = xsc;
	struct ips_ccb *ccb;

	mtx_enter(&sc->sc_ccb_mtx);
	if ((ccb = SLIST_FIRST(&sc->sc_ccbq_free)) != NULL) {
		SLIST_REMOVE_HEAD(&sc->sc_ccbq_free, c_link);
		ccb->c_flags = 0;
		ccb->c_xfer = NULL;
		bzero(ccb->c_cmdbva, sizeof(struct ips_cmdb));
	}
	mtx_leave(&sc->sc_ccb_mtx);

	return (ccb);
}

void
ips_ccb_put(void *xsc, void *xccb)
{
	struct ips_softc *sc = xsc;
	struct ips_ccb *ccb = xccb;

	ccb->c_state = IPS_CCB_FREE;
	mtx_enter(&sc->sc_ccb_mtx);
	SLIST_INSERT_HEAD(&sc->sc_ccbq_free, ccb, c_link);
	mtx_leave(&sc->sc_ccb_mtx);
}

int
ips_dmamem_alloc(struct dmamem *dm, bus_dma_tag_t tag, bus_size_t size)
{
	int nsegs;

	dm->dm_tag = tag;
	dm->dm_size = size;

	if (bus_dmamap_create(tag, size, 1, size, 0,
	    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &dm->dm_map))
		return (1);
	if (bus_dmamem_alloc(tag, size, 0, 0, &dm->dm_seg, 1, &nsegs,
	    BUS_DMA_NOWAIT))
		goto fail1;
	if (bus_dmamem_map(tag, &dm->dm_seg, 1, size, (caddr_t *)&dm->dm_vaddr,
	    BUS_DMA_NOWAIT))
		goto fail2;
	if (bus_dmamap_load(tag, dm->dm_map, dm->dm_vaddr, size, NULL,
	    BUS_DMA_NOWAIT))
		goto fail3;

	return (0);

fail3:
	bus_dmamem_unmap(tag, dm->dm_vaddr, size);
fail2:
	bus_dmamem_free(tag, &dm->dm_seg, 1);
fail1:
	bus_dmamap_destroy(tag, dm->dm_map);
	return (1);
}

void
ips_dmamem_free(struct dmamem *dm)
{
	bus_dmamap_unload(dm->dm_tag, dm->dm_map);
	bus_dmamem_unmap(dm->dm_tag, dm->dm_vaddr, dm->dm_size);
	bus_dmamem_free(dm->dm_tag, &dm->dm_seg, 1);
	bus_dmamap_destroy(dm->dm_tag, dm->dm_map);
}
@


1.112
log
@sizes for free(); ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.111 2015/03/14 03:38:48 jsg Exp $	*/
d1148 1
a1148 1
	bv->bv_size = (u_quad_t)letoh32(ld->size) * IPS_SECSZ;
d1224 1
a1224 1
	bd->bd_size = (u_quad_t)letoh32(dev->seccnt) * IPS_SECSZ;
@


1.111
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.110 2014/07/13 23:10:23 deraadt Exp $	*/
d817 2
a818 1
		free(sc->sc_sensors, M_DEVBUF, 0);
d2005 1
a2005 1
	free(ccb, M_DEVBUF, 0);
d2016 1
a2016 1
	free(ccb, M_DEVBUF, 0);
@


1.110
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.109 2014/07/12 18:48:52 tedu Exp $	*/
a26 1
#include <sys/buf.h>
@


1.109
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.108 2011/07/17 22:46:48 matthew Exp $	*/
d799 1
a799 1
	if ((sc->sc_sensors = malloc(sizeof(struct ksensor) * sc->sc_nunits,
d1984 1
a1984 1
	if ((ccb = malloc(n * sizeof(*ccb), M_DEVBUF,
@


1.108
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.107 2011/07/08 22:09:27 matthew Exp $	*/
d818 1
a818 1
		free(sc->sc_sensors, M_DEVBUF);
d2005 1
a2005 1
	free(ccb, M_DEVBUF);
d2016 1
a2016 1
	free(ccb, M_DEVBUF);
@


1.107
log
@First batch of converting SCSI HBAs from setting saa_targets and
saa_luns instead of adapter_buswidth and luns in the prototype link.

ok dlg@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.106 2011/07/05 22:40:57 matthew Exp $	*/
d735 1
a741 1
	saa.saa_targets = sc->sc_nunits;
d746 1
a783 1
		bzero(&saa, sizeof(saa));
@


1.106
log
@Call bzero(&saa, sizeof(saa)) each time we use saa to attach
something.  Doesn't matter right now because scsibus_attach_args only
has one field and it's mandatory, but I'm planning to move some more
fields from scsi_link to scsibus_attach_args+scsibus_softc.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.105 2011/04/06 15:33:15 dlg Exp $	*/
a734 1
	sc->sc_scsi_link.adapter_buswidth = sc->sc_nunits;
d741 1
@


1.105
log
@move ips to iopools. its the usual drill, io between volumes is now
scheduled better, ioctl paths are more reliable, and it removes NO_CCB.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.104 2010/10/12 00:53:32 krw Exp $	*/
a745 1
	bzero(&saa, sizeof(saa));
d783 1
@


1.104
log
@Force openings to 1 for devices that can't do tagged i/o, i.e. more
than 1 i/o active at once.  This reduces the chances that concurrent
i/o's for such devices will confuse the device or the adapter code.
It also eliminates a reason for adapter code to maintain its own
queues.

Tweak all drivers that fake INQUIRY results to set the SID_CmdQue
flag, thus continuing to claim to be able to do tagged i/o.

Positive feedback from matthew@@ and marco@@ for an earlier version.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.103 2010/09/20 06:17:49 krw Exp $	*/
d420 2
d485 2
a486 2
struct ips_ccb *ips_ccb_get(struct ips_softc *);
void	ips_ccb_put(struct ips_softc *, struct ips_ccb *);
d665 2
d738 1
d782 1
d850 1
a850 1
	struct ips_ccb *ccb;
d854 1
a854 1
	int code, s;
d903 1
a903 10
		s = splbio();
		ccb = ips_ccb_get(sc);
		splx(s);
		if (ccb == NULL) {
			DPRINTF(IPS_D_ERR, ("%s: ips_scsi_cmd: no ccb\n",
			    sc->sc_dev.dv_xname));
			xs->error = XS_NO_CCB;
			scsi_done(xs);
			return;
		}
a913 4

			s = splbio();
			ips_ccb_put(sc, ccb);
			splx(s);
d915 2
a916 1
			break;
a950 11
		s = splbio();
		ccb = ips_ccb_get(sc);
		splx(s);
		if (ccb == NULL) {
			DPRINTF(IPS_D_ERR, ("%s: ips_scsi_cmd: no ccb\n",
			    sc->sc_dev.dv_xname));
			xs->error = XS_NO_CCB;
			scsi_done(xs);
			return;
		}

d977 1
a977 1
	struct ips_ccb *ccb;
a981 1
	int s;
a1004 11
	s = splbio();
	ccb = ips_ccb_get(sc);
	splx(s);
	if (ccb == NULL) {
		DPRINTF(IPS_D_ERR, ("%s: ips_scsi_pt_cmd: no ccb\n",
		    sc->sc_dev.dv_xname));
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		return;
	}

a1040 4

		s = splbio();
		ips_ccb_put(sc, ccb);
		splx(s);
a1459 1
	ips_ccb_put(sc, ccb);
d1545 1
a1695 1
			ips_ccb_put(sc, ccb);
a1723 1
	ips_ccb_put(sc, ccb);
a1731 1
	int s;
d1733 1
a1733 3
	s = splbio();
	ccb = ips_ccb_get(sc);
	splx(s);
a1752 1
	int s;
d1754 1
a1754 3
	s = splbio();
	ccb = ips_ccb_get(sc);
	splx(s);
a1773 1
	int s;
d1775 1
a1775 3
	s = splbio();
	ccb = ips_ccb_get(sc);
	splx(s);
a1794 1
	int s;
d1796 1
a1796 3
	s = splbio();
	ccb = ips_ccb_get(sc);
	splx(s);
a1817 1
	int s;
d1819 1
a1819 3
	s = splbio();
	ccb = ips_ccb_get(sc);
	splx(s);
a1838 1
	int s;
d1840 1
a1840 3
	s = splbio();
	ccb = ips_ccb_get(sc);
	splx(s);
a1861 1
	int s;
d1863 1
a1863 3
	s = splbio();
	ccb = ips_ccb_get(sc);
	splx(s);
d2019 2
a2020 2
struct ips_ccb *
ips_ccb_get(struct ips_softc *sc)
d2022 1
d2025 1
a2025 2
	splassert(IPL_BIO);

d2032 1
d2038 1
a2038 1
ips_ccb_put(struct ips_softc *sc, struct ips_ccb *ccb)
d2040 2
a2041 1
	splassert(IPL_BIO);
d2044 1
d2046 1
@


1.103
log
@Use SSD_ERRCODE_CURRENT instead of magic 0x70.

ok dlg@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.102 2010/07/01 16:30:57 deraadt Exp $	*/
d937 1
@


1.102
log
@make this compile with SMALL_KERNEL
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.101 2010/07/01 03:20:38 matthew Exp $	*/
d1012 1
a1012 1
		xs->sense.error_code = SSD_ERRCODE_VALID | 0x70;
@


1.101
log
@Change scsibus(4)'s scsi_link array to an SLIST to save memory on
sparsely populated buses.

ok dlg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.100 2010/06/30 19:08:59 mk Exp $	*/
a595 1
	struct device *dev;
d755 1
a755 1
			struct ips_dev *dev;
d758 3
a760 3
			dev = &sc->sc_info->conf.dev[i][target];
			type = dev->params & SID_TYPE;
			if (dev->state && type != T_DIRECT) {
d801 2
@


1.100
log
@Use a SLIST for the ccb free list.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.99 2010/06/28 18:31:02 krw Exp $	*/
d596 1
d804 2
a805 2
		strlcpy(sc->sc_sensors[i].desc, ((struct device *)
		    sc->sc_scsibus->sc_link[i][0]->device_softc)->dv_xname,
d1198 1
a1198 1
	dv = sc->sc_scsibus->sc_link[vid][0]->device_softc;
@


1.99
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.98 2010/06/15 04:11:34 dlg Exp $	*/
d369 1
a369 1
	TAILQ_ENTRY(ips_ccb)	c_link;		/* queue link */
d373 1
a373 1
TAILQ_HEAD(ips_ccbq, ips_ccb);
d661 2
a662 2
	TAILQ_INIT(&sc->sc_ccbq_free);
	TAILQ_INSERT_TAIL(&sc->sc_ccbq_free, &ccb0, c_link);
d692 1
a692 1
	TAILQ_INIT(&sc->sc_ccbq_free);
d694 1
a694 1
		TAILQ_INSERT_TAIL(&sc->sc_ccbq_free,
d2079 2
a2080 2
	if ((ccb = TAILQ_FIRST(&sc->sc_ccbq_free)) != NULL) {
		TAILQ_REMOVE(&sc->sc_ccbq_free, ccb, c_link);
d2095 1
a2095 1
	TAILQ_INSERT_TAIL(&sc->sc_ccbq_free, ccb, c_link);
@


1.98
log
@dont pass the dev_t from the scsi device drivers into the midlayer for
ioctl requests, and dont pass the proc pointers around for any ioctl
requests in scsi land at all. neither were used, so trim the fat.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.97 2010/05/20 00:55:17 krw Exp $	*/
a506 7
static struct scsi_device ips_scsi_device = {
	NULL,
	NULL,
	NULL,
	NULL
};

a514 7
static struct scsi_device ips_scsi_pt_device = {
	NULL,
	NULL,
	NULL,
	NULL
};

a731 1
	sc->sc_scsi_link.device = &ips_scsi_device;
a774 1
		link->device = &ips_scsi_pt_device;
@


1.97
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.96 2010/04/06 22:28:07 tedu Exp $	*/
d432 1
a432 2
int	ips_scsi_ioctl(struct scsi_link *, u_long, caddr_t, int,
	    struct proc *);
d1103 1
a1103 2
ips_scsi_ioctl(struct scsi_link *link, u_long cmd, caddr_t addr, int flag,
    struct proc *p)
@


1.96
log
@update a random sampling of drivers after the proc.h -> systm.h move
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.95 2010/03/23 01:57:20 krw Exp $	*/
a873 1
		s = splbio();
a874 1
		splx(s);
a918 1
			s = splbio();
a919 1
			splx(s);
a977 1
			s = splbio();
a978 1
			splx(s);
a997 1
	s = splbio();
a998 1
	splx(s);
a1030 1
		s = splbio();
a1031 1
		splx(s);
a1043 1
		s = splbio();
a1044 1
		splx(s);
a1088 1
		s = splbio();
a1089 1
		splx(s);
@


1.95
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.94 2010/01/09 23:15:07 krw Exp $	*/
a31 1
#include <sys/proc.h>
@


1.94
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.93 2009/03/23 17:40:56 grange Exp $	*/
d431 2
a432 2
int	ips_scsi_cmd(struct scsi_xfer *);
int	ips_scsi_pt_cmd(struct scsi_xfer *);
d449 1
a449 1
int	ips_start_xs(struct ips_softc *, struct ips_ccb *, struct scsi_xfer *);
d848 1
a848 1
int
d878 1
a878 1
		return (COMPLETE);
d921 5
a925 1
			return (NO_CCB);
d949 2
a950 1
		return (ips_start_xs(sc, ccb, xs));
d982 5
a986 1
			return (NO_CCB);
d993 2
a994 1
		return (ips_start_xs(sc, ccb, xs));
a1007 2

	return (COMPLETE);
d1010 1
a1010 1
int
d1043 1
a1043 1
		return (COMPLETE);
d1054 5
a1058 1
		return (NO_CCB);
d1105 1
a1105 1
		return (COMPLETE);
d1115 1
a1115 1
	return (ips_start_xs(sc, ccb, xs));
d1436 1
a1436 1
int
d1453 1
a1453 6
	(void)ips_cmd(sc, ccb);

	if (ispoll)
		return (COMPLETE);
	else
		return (SUCCESSFULLY_QUEUED);
@


1.93
log
@Reorganize NBIO and SMALL_KERNEL handling again but this time without
ramdisk breakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.92 2009/03/22 20:57:28 deraadt Exp $	*/
a1549 1
	xs->flags |= ITSDONE;
a1590 1
	xs->flags |= ITSDONE;
@


1.92
log
@unbreak ramdisk builds in a way i guess might work
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.91 2009/03/22 18:41:34 grange Exp $	*/
d436 1
d442 1
d444 1
d446 1
d465 3
a468 1
int	ips_getpg5(struct ips_softc *, int);
d471 1
d1344 1
a1344 1
	int i, rebuild = 0;
a1369 1
			rebuild++;
a1380 3

	if (rebuild)
		(void)ips_getrblstat(sc, 0);
d1860 1
a1860 1
ips_getrblstat(struct ips_softc *sc, int flags)
d1876 2
a1877 1
	cmd->code = IPS_CMD_REBUILDSTATUS;
d1879 1
a1879 1
	    rblstat));
d1884 1
d1886 1
a1886 1
ips_getpg5(struct ips_softc *sc, int flags)
d1902 1
a1902 2
	cmd->code = IPS_CMD_RWNVRAM;
	cmd->drive = 5;
d1904 1
a1904 1
	    pg5));
a1908 1
#if NBIO > 0
@


1.91
log
@Update volume info on every bio call instead of waiting for the
sensors task to do it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.90 2009/03/22 18:27:41 grange Exp $	*/
a1855 1
#ifndef SMALL_KERNEL
a1878 1
#endif	/* !SMALL_KERNEL */
@


1.90
log
@Don't show rebuild status for offline volumes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.89 2009/03/22 07:02:32 grange Exp $	*/
d1159 1
a1159 1
	int rebuild = 0;
d1164 2
d1183 1
a1183 1
	if (rebuild) {
d1231 1
a1231 1
	int chan, target, i;
d1235 2
d1300 1
a1300 1
	int state;
d1304 2
@


1.89
log
@Put recently added bio and sensors stuff under #if NBIO > 0 and
#ifndef SMALL_KERNEL respectively.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.88 2009/03/21 17:49:32 grange Exp $	*/
a1175 1
		rebuild++;
a1361 1
			rebuild++;
@


1.88
log
@If rebuild is active set volume state to ``rebuild''.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.87 2009/03/21 17:44:43 grange Exp $	*/
d1375 1
a1375 1
#endif
d1852 1
d1876 1
d1903 1
d1954 1
@


1.87
log
@Report rebuild progress only if rebuild is active.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.86 2009/03/21 12:44:44 grange Exp $	*/
d1185 2
a1186 1
		if (total && total > done)
d1188 1
@


1.86
log
@IPS_MAXTARGETS should be 16, not 15.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.85 2009/03/21 12:34:41 grange Exp $	*/
d1185 1
a1185 1
		if (total)
@


1.85
log
@Be smart when attaching pass-through scsibuses. Use configuration
data to check if channel has any devices besides disks and set the
actual bus width. This will speedup booting. Also remember enclosure
address here instead of messing with inquiry data.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.84 2009/03/21 09:57:10 grange Exp $	*/
d63 1
a63 1
#define IPS_MAXTARGETS		15
d230 1
a230 1
	u_int16_t	deaddisk[IPS_MAXCHANS * (IPS_MAXTARGETS + 1)];
d308 1
a308 1
	}		dev[IPS_MAXCHANS][IPS_MAXTARGETS + 1];
d783 1
a783 1
		link->adapter_target = IPS_MAXTARGETS + 1;
@


1.84
log
@Looks like the ``params'' field in the physical device description
contains SID_TYPE. Use to to filter out non disks from the bioctl
output.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.83 2009/03/20 20:16:56 grange Exp $	*/
d755 1
d762 19
d784 1
a784 1
		link->adapter_buswidth = IPS_MAXTARGETS;
a1548 2
	struct scsi_link *link = xs->sc_link;
	struct ips_pt *pt = link->adapter_softc;
d1551 1
a1551 1
	int target = link->target, done = letoh16(dcdb->datalen);
d1578 1
a1578 2
		switch (type) {
		case T_DIRECT:
a1580 7
			break;
		case T_ENCLOSURE:
		case T_PROCESSOR:
			/* remember enclosure address */
			pt->pt_proctgt = target;
			break;
		}
@


1.83
log
@When calculating physical disk size use its number of sectors
rather than chunk's.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.82 2009/03/20 20:11:07 grange Exp $	*/
d1182 2
a1183 1
				    IPS_DVS_MEMBER))
d1224 2
a1225 1
				    IPS_DVS_MEMBER))
@


1.82
log
@Detect unused and hot-spare drives.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.81 2009/03/20 19:48:41 grange Exp $	*/
d1241 1
a1241 1
	bd->bd_size = (u_quad_t)letoh32(chunk->seccnt) * IPS_SECSZ;
@


1.81
log
@Support bio ``unused'' drives.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.80 2009/03/20 19:44:45 grange Exp $	*/
d1138 1
a1138 1
	struct device *dev;
d1173 16
a1188 2
	dev = sc->sc_scsibus->sc_link[vid][0]->device_softc;
	strlcpy(bv->bv_dev, dev->dv_xname, sizeof(bv->bv_dev));
d1207 1
d1213 19
a1231 3
	if (did >= ld->chunkcnt)
		return (EINVAL);
	chunk = &ld->chunk[did];
d1233 2
a1234 1
	if (chunk->channel >= IPS_MAXCHANS || chunk->target >= IPS_MAXTARGETS)
d1236 1
a1236 1
	dev = &conf->dev[chunk->channel][chunk->target];
d1238 2
a1239 2
	bd->bd_channel = chunk->channel;
	bd->bd_target = chunk->target;
d1246 1
a1246 1
	strlcpy(bd->bd_procdev, sc->sc_pt[chunk->channel].pt_procdev,
@


1.80
log
@Cleanup physical drive states handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.79 2009/03/20 07:24:41 grange Exp $	*/
d1218 1
@


1.79
log
@Fetch rebuild status only for degraded or offline volumes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.78 2009/03/19 21:52:43 grange Exp $	*/
a104 6
/* SETSTATE states */
#define IPS_SS_ONLINE		0x89
#define IPS_SS_OFFLINE		0x08
#define IPS_SS_HOTSPARE		0x85
#define IPS_SS_REBUILD		0x8b

d299 1
a299 1
#define IPS_DVS_PRESENT	0x81
d303 2
d1217 1
a1217 1
	if (dev->state & IPS_DVS_PRESENT) {
d1238 2
d1242 5
d1249 1
a1249 1
		state = IPS_SS_ONLINE;
d1252 1
a1252 1
		state = IPS_SS_OFFLINE;
d1255 1
a1255 1
		state = IPS_SS_HOTSPARE;
@


1.78
log
@For rebuilds use a special REBUILD command instead of a generic
SETSTATE, for some reason it works better on lpinto's machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.77 2009/03/19 16:19:51 grange Exp $	*/
d1143 1
d1156 1
d1160 1
d1166 6
a1171 4
	total = letoh32(rblstat->ld[vid].total);
	done = total - letoh32(rblstat->ld[vid].remain);
	if (total)
		bv->bv_percent = 100 * done / total;
d1272 1
a1272 1
	int i;
a1284 1
	(void)ips_getrblstat(sc, 0);
d1298 1
d1303 1
d1311 3
@


1.77
log
@For pass-through commands adjust timeout value to what controller
supports. Make sure our timeout will be fired after controller
gives up.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.76 2009/03/19 16:07:14 grange Exp $	*/
d85 1
d468 1
d1250 2
a1251 2
		state = IPS_SS_REBUILD;
		break;
d1863 26
@


1.76
log
@Unify command id printing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.75 2009/03/19 13:25:18 grange Exp $	*/
d1035 6
a1040 1
	if (xs->timeout <= 10000)
d1042 2
a1043 1
	else if (xs->timeout <= 60000)
d1045 2
a1046 1
	else
d1048 3
@


1.75
log
@Make ips_timeout to be usable not only with scsi xfers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.74 2009/03/19 10:04:47 grange Exp $	*/
d1661 4
a1664 3
			DPRINTF(IPS_D_ERR, ("%s: ips_intr: cmd %d not queued, "
			    "state %d, status 0x%08x\n", sc->sc_dev.dv_xname,
			    ccb->c_id, ccb->c_state, status));
@


1.74
log
@Remove unused code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.73 2009/03/18 20:35:41 grange Exp $	*/
d1690 7
d1698 3
a1700 1
	 * Command never completed. Cleanup and recover.
d1702 2
a1703 6
	s = splbio();
	sc_print_addr(xs->sc_link);
	printf("timeout");
	DPRINTF(IPS_D_ERR, (", command %d", ccb->c_id));
	printf("\n");

a1704 5

	xs->error = XS_TIMEOUT;
	xs->flags |= ITSDONE;
	scsi_done(xs);

@


1.73
log
@Keep softc pointer in ccb because it requires some work to correctly
extract it from scsi_xfer in ips_timeout since link->adapter_softc
may point to a per-channel structure in pass-through path.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.72 2009/03/17 08:17:48 grange Exp $	*/
a468 1
void	ips_copperhead_init(struct ips_softc *);
a469 1
void	ips_copperhead_intrds(struct ips_softc *);
a470 1
int	ips_copperhead_reset(struct ips_softc *);
a473 1
void	ips_morpheus_init(struct ips_softc *);
a474 1
void	ips_morpheus_intrds(struct ips_softc *);
a475 1
int	ips_morpheus_reset(struct ips_softc *);
a540 1
	void		(*ic_init)(struct ips_softc *);
a541 1
	void		(*ic_intrds)(struct ips_softc *);
a542 1
	int		(*ic_reset)(struct ips_softc *);
a548 1
		ips_copperhead_init,
a549 1
		ips_copperhead_intrds,
a550 1
		ips_copperhead_reset,
a556 1
		ips_morpheus_init,
a557 1
		ips_morpheus_intrds,
a558 1
		ips_morpheus_reset,
a563 1
#define ips_init(s)	(s)->sc_chip->ic_init((s))
a564 1
#define ips_intrds(s)	(s)->sc_chip->ic_intrds((s))
a565 1
#define ips_reset(s)	(s)->sc_chip->ic_reset((s))
a628 3
	/* Initialize hardware */
	ips_init(sc);

a1704 1
	ips_reset(sc);
a1875 6
ips_copperhead_init(struct ips_softc *sc)
{
	/* XXX: not implemented */
}

void
a1880 6
void
ips_copperhead_intrds(struct ips_softc *sc)
{
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, IPS_REG_HIS, 0);
}

a1893 7
int
ips_copperhead_reset(struct ips_softc *sc)
{
	/* XXX: not implemented */
	return (0);
}

a1924 6
ips_morpheus_init(struct ips_softc *sc)
{
	/* XXX: not implemented */
}

void
a1933 10
void
ips_morpheus_intrds(struct ips_softc *sc)
{
	u_int32_t reg;

	reg = bus_space_read_4(sc->sc_iot, sc->sc_ioh, IPS_REG_OIM);
	reg |= IPS_REG_OIM_DS;
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, IPS_REG_OIM, reg);
}

a1938 7
}

int
ips_morpheus_reset(struct ips_softc *sc)
{
	/* XXX: not implemented */
	return (0);
@


1.72
log
@Provide both errno.h codes for the userspace tools like bioctl
and XS_* codes for the scsi layer.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.71 2009/03/17 07:48:59 grange Exp $	*/
d351 1
d1707 1
a1708 1
	struct ips_softc *sc = xs->sc_link->adapter_softc;
d2027 1
@


1.71
log
@Fix compilation without bio(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.70 2009/03/16 21:46:00 grange Exp $	*/
d456 1
d1481 1
a1481 1
	xs->error = ccb->c_error;
d1510 1
a1510 1
	xs->error = ccb->c_error;
a1555 1
	int error = XS_DRIVER_STUFFUP;
d1558 1
a1558 1
		return (XS_NOERROR);
d1583 37
d1622 1
d1624 1
a1624 2
		error = XS_NOERROR;
		break;
d1626 1
a1626 2
		error = XS_BUSY;
		break;
d1628 1
a1628 2
		error = XS_TIMEOUT;
		break;
d1632 1
a1632 2
			error = XS_SELTIMEOUT;
			break;
d1636 1
a1636 1
				error = XS_NOERROR;
d1640 1
a1640 2
			error = XS_RESET;
			break;
d1642 1
a1642 2
			error = XS_NOERROR;
			break;
d1644 1
a1644 2
			error = XS_SENSE;
			break;
d1649 1
a1649 1
	return (error);
@


1.70
log
@Implement bioctl volume management: rebuild and hotspare.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.69 2009/03/16 15:08:46 grange Exp $	*/
d1094 1
d1096 3
@


1.69
log
@When doing pass-through calculate right xs->resid value based on
the info hardware returnes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.68 2009/03/16 14:04:04 grange Exp $	*/
d75 1
a75 1
#define	IPS_TIMEOUT		10000	/* ms */
d84 1
d104 6
d316 9
d344 1
d442 1
d462 1
d464 1
d1113 2
d1142 1
d1146 1
d1166 5
d1180 3
a1182 3
	    "size %llu, level %d, nodisk %d, dev %s\n", sc->sc_dev.dv_xname,
	    vid, ld->state, bv->bv_size, bv->bv_level, bv->bv_nodisk,
	    bv->bv_dev));
d1236 25
d1283 1
d1767 24
d1811 25
@


1.68
log
@Don't set error on data underrun. This tiny change allowed scsi tape
on the pass-through bus on lpinto's machine to work.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.67 2009/03/16 08:09:05 grange Exp $	*/
d1278 1
a1278 1
	if (nsegs > 1) { 
d1434 1
a1434 1
	int target = link->target;
d1446 4
a1449 1
	xs->resid = 0;
@


1.67
log
@Remove redundant DPRINTF from ips_morpheus_isintr.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.66 2009/03/16 07:21:57 grange Exp $	*/
d1491 1
d1536 5
@


1.66
log
@IPS_SCSI_PT flag not used any more.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.65 2009/03/15 17:35:42 grange Exp $	*/
d1845 2
a1846 6
	u_int32_t reg;

	reg = bus_space_read_4(sc->sc_iot, sc->sc_ioh, IPS_REG_OIS);
	DPRINTF(IPS_D_XFER, ("%s: isintr 0x%08x\n", sc->sc_dev.dv_xname, reg));

	return (reg & IPS_REG_OIS_PEND);
@


1.65
log
@Cleanup error processing:

- in ips_start_xs don't do scsi_done twice on error;
- make ips_error return scsi XS_* codes rather than errno.h E* codes;
- move all error reporting under debug, let upper layers to spam user.

And fix a few missing byte conversions while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.64 2009/03/13 20:03:21 grange Exp $	*/
a335 1
#define IPS_SCSI_PT 0x10000			/* SCSI pass-through */
a1012 1
	xs->flags |= IPS_SCSI_PT;
@


1.64
log
@Add SCSI pass-through and enclosure support. Tested on lpinto's
machine which has safte(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.63 2009/03/13 08:48:12 grange Exp $	*/
d152 1
a152 1
#define IPS_ESTAT_SEL		0xf0	/* select device */
d1043 1
a1043 1
	dcdb->datalen = xs->datalen;
d1065 1
a1065 1
	cmd->sgaddr = ccb->c_cmdbpa + offsetof(struct ips_cmdb, dcdb);
a1300 2
	int error, s;

d1303 1
d1305 1
a1305 1
	if (!(xs->flags & SCSI_POLL)) {
d1310 6
a1315 8
	if ((error = ips_cmd(sc, ccb))) {
		DPRINTF(IPS_D_ERR, ("%s: ips_start_xs: ips_cmd "
		    "failed, error %d\n", sc->sc_dev.dv_xname, error));

		if (error == ETIMEDOUT)
			xs->error = XS_TIMEOUT;
		else
			xs->error = XS_DRIVER_STUFFUP;
d1317 1
a1317 7
		s = splbio();
		scsi_done(xs);
		splx(s);
		return (COMPLETE);
	}

	if (xs->flags & SCSI_POLL)
d1332 2
a1333 2
	    ccb->c_xfer, cmd->code, cmd->drive, cmd->sgcnt, cmd->lba,
	    cmd->sgaddr, cmd->seccnt));
d1382 5
a1386 1
		return (ETIMEDOUT);
d1422 2
a1423 10
	switch (ccb->c_error) {
	case 0:
		xs->resid = 0;
		break;
	case ETIMEDOUT:
		xs->error = XS_TIMEOUT;
		break;
	default:
		xs->error = XS_DRIVER_STUFFUP;
	}
d1436 1
a1436 1
	int target = link->target, type;
d1448 2
d1452 18
a1469 26
	if (ccb->c_error) {
		if (ccb->c_estat == IPS_ESTAT_CKCOND) {
			xs->error = XS_SENSE;
			memcpy(&xs->sense, dcdb->sense, MIN(sizeof(xs->sense),
			    sizeof(dcdb->sense)));
		} else {
			if (ccb->c_error == ETIMEDOUT)
				xs->error = XS_TIMEOUT;
			else
				xs->error = XS_DRIVER_STUFFUP;
		}
	} else {
		if (xs->cmd->opcode == INQUIRY) {
			type = ((struct scsi_inquiry_data *)xs->data)->device &
			    SID_TYPE;

			switch (type) {
			case T_DIRECT:
				/* skip physical drive */
				xs->error = XS_DRIVER_STUFFUP;
				break;
			case T_ENCLOSURE:
			case T_PROCESSOR:
				/* remember our enclosure */
				pt->pt_proctgt = target;
			}
a1470 1
		xs->resid = 0;
d1472 1
d1490 3
a1492 2
	struct ips_cmd *cmd = ccb->c_cmdbva;
	struct scsi_xfer *xs = ccb->c_xfer;
d1494 1
d1497 1
a1497 13
		return (0);
	if (gsc == IPS_STAT_LDERR) {
		DPRINTF(IPS_D_ERR, ("%s: ld%d error, stat 0x%02x, "
		    "estat 0x%02x\n", sc->sc_dev.dv_xname, cmd->drive,
		    ccb->c_stat, ccb->c_estat));
		return (EIO);
	}
	if (xs && xs->flags & IPS_SCSI_PT && gsc == IPS_STAT_PDRVERR) {
		DPRINTF(IPS_D_ERR, ("%s: phys drive error, stat 0x%02x, "
		    "estat 0x%02x\n", sc->sc_dev.dv_xname, ccb->c_stat,
		    ccb->c_estat));
		return (EIO);
	}
d1499 22
a1520 17
	if (xs)
		sc_print_addr(xs->sc_link);
	else
		printf("%s: ", sc->sc_dev.dv_xname);

	if (xs && (xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)))
		printf("%s blocks %u-%u", (xs->flags & SCSI_DATA_IN ?
		    "read" : "write"), letoh32(cmd->lba),
		    letoh32(cmd->lba) + letoh16(cmd->seccnt) - 1);
	else
		printf("command");

	if (gsc == IPS_STAT_RECOV || (gsc == IPS_STAT_PDRVERR &&
	    ccb->c_estat == IPS_ESTAT_RECOV))
		printf(" recovered");
	printf(" error, opcode 0x%02x, stat 0x%02x, estat 0x%02x\n",
	    cmd->code, ccb->c_stat, ccb->c_estat);
d1522 1
d1525 2
a1526 1
		return (0);
d1528 2
a1529 1
		return (EBUSY);
d1531 2
a1532 1
		return (ETIMEDOUT);
d1534 16
a1549 2
		if (ccb->c_estat == IPS_ESTAT_RECOV)
			return (0);
d1552 1
a1552 1
	return (EIO);
@


1.63
log
@Some preparation steps for SCSI pass-through support:

- stack command and DCDB frames along with scatter-gather list into
one command block;
- use structure field pointers and offsetof() instead of evil pointer
arithmetics;
- add DCDB definitions.

No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.62 2009/03/13 07:49:28 grange Exp $	*/
d69 1
d186 1
a186 1
	u_int8_t	cdb[12];
d336 1
d378 10
d418 1
d436 1
d496 15
d752 23
d919 1
d958 1
d978 95
d1189 2
a1304 1
	ccb->c_done = ips_done_xs;
d1442 55
d1519 6
@


1.62
log
@Process command completion errors while polling, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.61 2009/03/12 21:20:05 grange Exp $	*/
a68 1
#define IPS_MAXCMDSZ		(IPS_CMDSZ + IPS_MAXSGS * IPS_SGSZ)
a69 2
#define IPS_CMDSZ		sizeof(struct ips_cmd)
#define IPS_SGSZ		sizeof(struct ips_sg)
d94 2
a95 2
#define IPS_CMD_EXT_DCDB	0x95
#define IPS_CMD_EXT_DCDB_SG	0x96
d102 10
d175 16
d197 7
d341 2
a342 2
	void *			c_cmdva;	/* command frame virt addr */
	paddr_t			c_cmdpa;	/* command frame phys addr */
d390 1
a390 1
	struct dmamem		sc_cmdm;
d601 2
a602 2
	if (ips_dmamem_alloc(&sc->sc_cmdm, sc->sc_dmat,
	    IPS_MAXCMDS * IPS_MAXCMDSZ)) {
d641 2
a642 2
	ccb0.c_cmdva = sc->sc_cmdm.dm_vaddr;
	ccb0.c_cmdpa = sc->sc_cmdm.dm_paddr;
d766 1
a766 1
	ips_dmamem_free(&sc->sc_cmdm);
d847 1
a847 1
		cmd = ccb->c_cmdva;
d902 1
a902 1
		cmd = ccb->c_cmdva;
d1110 3
a1112 2
	struct ips_cmd *cmd = ccb->c_cmdva;
	struct ips_sg *sg;
d1131 2
a1132 1
		cmd->sgaddr = htole32(ccb->c_cmdpa + IPS_CMDSZ);
a1134 1
		sg = (void *)(cmd + 1);
d1185 1
a1185 1
	struct ips_cmd *cmd = ccb->c_cmdva;
d1304 1
a1304 1
	struct ips_cmd *cmd = ccb->c_cmdva;
d1443 1
a1443 1
	cmd = ccb->c_cmdva;
d1467 1
a1467 1
	cmd = ccb->c_cmdva;
d1491 1
a1491 1
	cmd = ccb->c_cmdva;
d1515 1
a1515 1
	cmd = ccb->c_cmdva;
d1540 1
a1540 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, IPS_REG_CCSA, ccb->c_cmdpa);
d1610 1
a1610 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, IPS_REG_IQP, ccb->c_cmdpa);
d1680 4
a1683 3
		ccb[i].c_cmdva = (char *)sc->sc_cmdm.dm_vaddr +
		    i * IPS_MAXCMDSZ;
		ccb[i].c_cmdpa = sc->sc_cmdm.dm_paddr + i * IPS_MAXCMDSZ;
d1719 1
a1719 1
		bzero(ccb->c_cmdva, sizeof(struct ips_cmd));
@


1.61
log
@In the most common case -- array failure -- move error message under
debug not to spam dmesg, bioctl and sysctl hw.sensors will tell you
enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.60 2009/03/12 21:00:41 grange Exp $	*/
d319 1
d1180 1
a1180 1
	int timo;
d1211 1
d1213 2
d1216 1
a1216 1
	return (0);
d1227 1
a1228 3

	ccb->c_state = IPS_CCB_FREE;
	ips_ccb_put(sc, ccb);
a1234 1
	int error;
d1246 2
a1247 6
	if ((error = ips_error(sc, ccb))) {
		if (error == ETIMEDOUT)
			xs->error = XS_TIMEOUT;
		else
			xs->error = XS_DRIVER_STUFFUP;
	} else {
d1249 6
a1267 3

	/* XXX: error checking */
	(void)ips_error(sc, ccb);
d1358 1
a1358 1
		if (ccb->c_flags & SCSI_POLL)
d1360 1
a1360 1
		else
d1362 2
d1697 2
@


1.60
log
@Advanced error checking.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.59 2009/03/12 11:12:41 grange Exp $	*/
d1279 6
@


1.59
log
@For SYNCHRONIZE_CACHE command use the same code path as for READ/WRITE.
This required to factor out some common scsi code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.58 2009/03/11 20:06:00 grange Exp $	*/
d125 25
a149 4
#define IPS_REG_STAT_ID(x)	(((x) >> 8) & 0xff)
#define IPS_REG_STAT_BASIC(x)	(((x) >> 16) & 0xff)
#define IPS_REG_STAT_GSC(x)	(((x) >> 16) & 0x0f)
#define IPS_REG_STAT_EXT(x)	(((x) >> 24) & 0xff)
d310 1
d314 1
d316 3
a318 2
	int			c_stat;		/* status word copy */
	int			c_estat;	/* ext status word copy */
d393 1
a393 1
void	ips_error(struct ips_softc *, struct ips_ccb *);
a1223 2
	if (ccb->c_stat)
		ips_error(sc, ccb);
d1233 1
d1245 6
a1250 3
	if (ccb->c_stat > 1)
		xs->error = XS_DRIVER_STUFFUP;
	else
d1252 1
d1265 3
d1270 1
a1270 1
void
d1273 1
d1275 4
d1284 24
a1307 4
	if (ccb->c_stat == 1) {
		printf("recovered error\n");
	} else {
		printf("error\n");
d1309 2
d1333 1
a1333 1
		id = IPS_REG_STAT_ID(status);
d1349 2
a1350 2
		ccb->c_stat = IPS_REG_STAT_GSC(status);
		ccb->c_estat = IPS_REG_STAT_EXT(status);
@


1.58
log
@Rework command polling to be able to sleep if no SCSI_NOSLEEP flag
passed. Sleep while waiting for sensors update because that's what
sensors work queue for.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.57 2009/03/10 15:31:04 grange Exp $	*/
d361 3
a363 1
int	ips_load(struct ips_softc *, struct ips_ccb *, struct scsi_xfer *);
a376 1
int	ips_flush(struct ips_softc *, int);
d732 1
a732 1
	int code, error, s;
a774 3
			s = splbio();
			scsi_done(xs);
			splx(s);
a791 4
		ccb->c_flags = xs->flags;
		ccb->c_xfer = xs;
		ccb->c_done = ips_done_xs;

d798 2
a799 2
		if (ips_load(sc, ccb, xs)) {
			DPRINTF(IPS_D_ERR, ("%s: ips_scsi_cmd: ips_load "
d804 1
d806 1
a806 3
			scsi_done(xs);
			splx(s);
			return (COMPLETE);
d812 1
a812 22
		timeout_set(&xs->stimeout, ips_timeout, ccb);
		timeout_add_msec(&xs->stimeout, xs->timeout);

		if ((error = ips_cmd(sc, ccb))) {
			DPRINTF(IPS_D_ERR, ("%s: ips_scsi_cmd: ips_cmd "
			    "failed, error %d\n", sc->sc_dev.dv_xname, error));

			if (error == ETIMEDOUT)
				xs->error = XS_TIMEOUT;
			else
				xs->error = XS_DRIVER_STUFFUP;

			s = splbio();
			scsi_done(xs);
			splx(s);
			return (COMPLETE);
		}

		if (xs->flags & SCSI_POLL)
			return (COMPLETE);
		else
			return (SUCCESSFULLY_QUEUED);
d838 13
a850 3
		if (ips_flush(sc, xs->flags))
			xs->error = XS_DRIVER_STUFFUP;
		break;
d1053 1
a1053 1
ips_load(struct ips_softc *sc, struct ips_ccb *ccb, struct scsi_xfer *xs)
d1092 35
d1212 2
a1213 1
	timeout_del(&xs->stimeout);
a1423 22

	return (ips_cmd(sc, ccb));
}

int
ips_flush(struct ips_softc *sc, int flags)
{
	struct ips_ccb *ccb;
	struct ips_cmd *cmd;
	int s;

	s = splbio();
	ccb = ips_ccb_get(sc);
	splx(s);
	if (ccb == NULL)
		return (1);

	ccb->c_flags = SCSI_POLL | flags;
	ccb->c_done = ips_done_mgmt;

	cmd = ccb->c_cmdva;
	cmd->code = IPS_CMD_FLUSH;
@


1.57
log
@Print scsi xfer flags in debug output.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.56 2009/03/10 14:18:28 grange Exp $	*/
d32 1
d77 1
a77 1
#define	IPS_TIMEOUT		5	/* seconds */
d283 6
a288 6
	int			c_flags;	/* flags */
#define IPS_CCB_READ	0x0001
#define IPS_CCB_WRITE	0x0002
#define IPS_CCB_POLL	0x0004
#define IPS_CCB_RUN	0x0008

d364 1
d367 1
d371 5
a375 5
int	ips_getadapterinfo(struct ips_softc *);
int	ips_getdriveinfo(struct ips_softc *);
int	ips_getconf(struct ips_softc *);
int	ips_getpg5(struct ips_softc *);
int	ips_flush(struct ips_softc *);
d591 1
a591 1
	if (ips_getadapterinfo(sc)) {
d597 1
a597 1
	if (ips_getdriveinfo(sc)) {
d604 1
a604 1
	if (ips_getconf(sc)) {
d610 1
a610 1
	(void)ips_getpg5(sc);
d731 1
a731 1
	int code, error, flags, s;
d738 1
a738 1
		DPRINTF(IPS_D_INFO, ("%s: invalid scsi command, "
d770 1
a770 1
			DPRINTF(IPS_D_ERR, ("%s: invalid scsi command, "
d780 1
a780 1
		if (xs->flags & SCSI_DATA_IN) {
d782 1
a782 2
			flags = IPS_CCB_READ;
		} else {
a783 4
			flags = IPS_CCB_WRITE;
		}
		if (xs->flags & SCSI_POLL)
			flags |= IPS_CCB_POLL;
d788 3
a790 1
		if (ccb == NULL)
d792 1
d794 1
a794 1
		ccb->c_flags = flags;
d805 3
d820 1
a820 1
		timeout_add_sec(&xs->stimeout, IPS_TIMEOUT);
d823 3
d837 1
a837 1
		if (flags & IPS_CCB_POLL)
d866 1
a866 1
		if (ips_flush(sc))
d1032 2
a1033 1
	if (ips_getconf(sc)) {
d1115 5
a1119 4
	DPRINTF(IPS_D_XFER, ("%s: cmd id %d, flags 0x%02x, code 0x%02x, "
	    "drive %d, sgcnt %d, lba %d, sgaddr 0x%08x, seccnt %d\n",
	    sc->sc_dev.dv_xname, ccb->c_id, ccb->c_flags, cmd->code,
	    cmd->drive, cmd->sgcnt, cmd->lba, cmd->sgaddr, cmd->seccnt));
a1120 1
	/* Pass command to hardware */
d1122 2
a1123 1
	ccb->c_flags |= IPS_CCB_RUN;
d1126 3
a1130 7
	if (ccb->c_flags & IPS_CCB_POLL) {
		/* Wait for command to complete */
		s = splbio();
		error = ips_poll(sc, ccb);
		splx(s);
	}

d1135 1
a1135 1
ips_poll(struct ips_softc *sc, struct ips_ccb *c)
d1137 9
a1145 3
	struct ips_ccb *ccb = NULL;
	u_int32_t status;
	int id, timeout;
d1147 5
a1151 11
	while (ccb != c) {
		for (timeout = 100; timeout-- > 0; delay(100)) {
			if ((status = ips_status(sc)) == 0xffffffff)
				continue;
			id = IPS_REG_STAT_ID(status);
			if (id >= sc->sc_nccbs) {
				DPRINTF(IPS_D_ERR, ("%s: invalid command "
				    "0x%02x\n", sc->sc_dev.dv_xname, id));
				continue;
			}
			break;
d1153 17
a1169 9
		if (timeout < 0) {
			printf("%s: poll timeout\n", sc->sc_dev.dv_xname);
			return (ETIMEDOUT);
		}
		ccb = &sc->sc_ccb[id];
		ccb->c_stat = IPS_REG_STAT_GSC(status);
		ccb->c_estat = IPS_REG_STAT_EXT(status);
		ccb->c_done(sc, ccb);
	}
d1175 16
a1193 8
	int flags = ccb->c_flags;
	int error = 0;

	if ((flags & IPS_CCB_RUN) == 0) {
		printf("%s: cmd 0x%02x not run\n", sc->sc_dev.dv_xname,
		    ccb->c_id);
		return;
	}
d1197 1
a1197 1
	if (flags & (IPS_CCB_READ | IPS_CCB_WRITE)) {
d1199 1
a1199 1
		    ccb->c_dmam->dm_mapsize, flags & IPS_CCB_READ ?
d1204 1
a1204 14
	if (ccb->c_stat) {
		sc_print_addr(xs->sc_link);
		if (ccb->c_stat == 1) {
			printf("recovered error\n");
		} else {
			printf("error\n");
			error = 1;
		}
	}

	/* Release CCB */
	ips_ccb_put(sc, ccb);

	if (error)
d1215 6
a1220 2
	int flags = ccb->c_flags;
	int error = 0;
d1222 4
a1225 5
	if ((flags & IPS_CCB_RUN) == 0) {
		printf("%s: cmd 0x%02x not run\n", sc->sc_dev.dv_xname,
		    ccb->c_id);
		return;
	}
d1227 3
a1229 6
	if (flags & (IPS_CCB_READ | IPS_CCB_WRITE))
		bus_dmamap_sync(sc->sc_dmat, sc->sc_infom.dm_map, 0,
		    sc->sc_infom.dm_map->dm_mapsize, flags & IPS_CCB_READ ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);

	if (ccb->c_stat) {
d1231 4
a1234 6
		if (ccb->c_stat == 1) {
			printf("recovered error\n");
		} else {
			printf("error\n");
			error = 1;
		}
a1235 3

	/* Release CCB */
	ips_ccb_put(sc, ccb);
d1246 3
a1248 1
	if (!ips_isintr(sc))
d1250 2
d1255 1
a1255 1
		DPRINTF(IPS_D_XFER, ("%s: intr status 0x%08x\n",
d1260 1
a1260 1
			DPRINTF(IPS_D_ERR, ("%s: invalid command %d\n",
d1264 1
d1266 8
d1276 5
a1280 1
		ccb->c_done(sc, ccb);
d1300 1
a1300 1
	DPRINTF(IPS_D_ERR, (", command 0x%02x", ccb->c_id));
d1314 1
a1314 1
ips_getadapterinfo(struct ips_softc *sc)
d1326 1
a1326 1
	ccb->c_flags = IPS_CCB_READ | IPS_CCB_POLL;
d1338 1
a1338 1
ips_getdriveinfo(struct ips_softc *sc)
d1350 1
a1350 1
	ccb->c_flags = IPS_CCB_READ | IPS_CCB_POLL;
d1362 1
a1362 1
ips_getconf(struct ips_softc *sc)
d1374 1
a1374 1
	ccb->c_flags = IPS_CCB_READ | IPS_CCB_POLL;
d1386 1
a1386 1
ips_getpg5(struct ips_softc *sc)
d1398 1
a1398 1
	ccb->c_flags = IPS_CCB_READ | IPS_CCB_POLL;
d1411 1
a1411 1
ips_flush(struct ips_softc *sc)
d1423 1
a1423 1
	ccb->c_flags = IPS_CCB_POLL;
d1582 2
a1583 1
	if ((ccb = malloc(n * sizeof(*ccb), M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
d1620 2
d1635 1
a1635 2
	ccb->c_flags = 0;
	ccb->c_xfer = NULL;
@


1.56
log
@Rearrange physical drive state bits checking so that bioctl gets
a correct state value.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.55 2009/03/10 14:07:44 grange Exp $	*/
d731 2
a732 2
	    "opcode 0x%02x\n", sc->sc_dev.dv_xname, xs, target,
	    xs->cmd->opcode));
@


1.55
log
@Add some more debug.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.54 2009/03/10 09:16:40 grange Exp $	*/
d998 4
a1003 4
		if (dev->state & IPS_DVS_SPARE)
			bd->bd_status = BIOC_SDHOTSPARE;
		if (dev->state & IPS_DVS_MEMBER)
			bd->bd_status = BIOC_SDONLINE;
@


1.54
log
@Add ips_intrds() function to be able to disable interrupts on hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.53 2009/03/10 08:27:08 grange Exp $	*/
d730 4
d892 2
a893 1
	DPRINTF(IPS_D_INFO, ("%s: ioctl %lu\n", sc->sc_dev.dv_xname, cmd));
d918 3
d959 5
d1008 4
d1026 3
d1036 1
d1039 1
d1058 1
@


1.53
log
@Limit registers space size to some reasonable value.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.52 2009/03/09 20:21:50 grange Exp $	*/
d377 1
d385 1
d440 1
d451 1
d462 1
d472 1
d1422 6
d1491 10
@


1.52
log
@Completely rework command processing:

- use separate callbacks to finish scsi and raid management commands;
- for raid management commands use dedicated dma-safe buffer;
- remove unused run queue;

The main goal of these changes is to fix a bug showing up on the lpinto's
machine where READCONF command fails because it needs more than 1-page
buffer and the buffer was not contiguos and controller doesn't support
scatter-gather for raid management commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.51 2009/03/01 19:54:23 grange Exp $	*/
d129 2
d527 1
a527 1
	    &sc->sc_ioh, NULL, &iosize, 0)) {
@


1.51
log
@Time to turn off debug by default. It shrinks ramdisk as a bonus.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.50 2009/03/01 19:45:36 grange Exp $	*/
d20 1
a20 1
 * IBM (Adaptec) ServeRAID controller driver.
a194 15
struct ips_pg5 {
	u_int32_t	signature;
	u_int8_t	__reserved1;
	u_int8_t	slot;
	u_int16_t	type;
	u_int8_t	bioshi[4];
	u_int8_t	bioslo[4];
	u_int16_t	__reserved2;
	u_int8_t	__reserved3;
	u_int8_t	os;
	u_int8_t	driverhi[4];
	u_int8_t	driverlo[4];
	u_int8_t	__reserved4[100];
};

d254 22
d277 1
d293 3
d327 3
a329 2
	struct ips_conf		sc_conf;
	struct ips_driveinfo	sc_di;
a336 1
	struct ips_ccbq		sc_ccbq_run;
d358 2
a359 2
int	ips_cmd(struct ips_softc *, int, int, u_int32_t, void *, size_t, int,
	    struct scsi_xfer *);
d361 2
a362 1
void	ips_done(struct ips_softc *, struct ips_ccb *);
d366 4
a369 3
int	ips_getadapterinfo(struct ips_softc *, struct ips_adapterinfo *);
int	ips_getconf(struct ips_softc *, struct ips_conf *);
int	ips_getdriveinfo(struct ips_softc *, struct ips_driveinfo *);
a370 1
int	ips_readnvram(struct ips_softc *, void *, int);
d505 3
a507 2
	struct ips_adapterinfo ai;
	struct ips_pg5 pg5;
d540 11
d555 1
a555 1
			goto fail2;
a575 6
	if (bus_dmamap_create(sc->sc_dmat, IPS_MAXFER, IPS_MAXSGS,
	    IPS_MAXFER, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
	    &ccb0.c_dmam)) {
		printf(": can't bootstrap ccb queue\n");
		goto fail3;
	}
a576 1
	TAILQ_INIT(&sc->sc_ccbq_run);
d580 1
a580 1
	if (ips_getadapterinfo(sc, &ai)) {
d582 7
a588 2
		bus_dmamap_destroy(sc->sc_dmat, ccb0.c_dmam);
		goto fail3;
d590 1
d593 1
a593 1
	if (ips_getconf(sc, &sc->sc_conf)) {
d595 1
a595 9
		bus_dmamap_destroy(sc->sc_dmat, ccb0.c_dmam);
		goto fail3;
	}

	/* Get logical drives info */
	if (ips_getdriveinfo(sc, &sc->sc_di)) {
		printf(": can't get ld info\n");
		bus_dmamap_destroy(sc->sc_dmat, ccb0.c_dmam);
		goto fail3;
a596 1
	sc->sc_nunits = sc->sc_di.drivecnt;
d599 1
a599 4
	bzero(&pg5, sizeof(pg5));
	ips_readnvram(sc, &pg5, 5);

	bus_dmamap_destroy(sc->sc_dmat, ccb0.c_dmam);
d602 1
a602 1
	sc->sc_nccbs = ai.cmdcnt;
d605 1
a605 1
		goto fail3;
a607 1
	TAILQ_INIT(&sc->sc_ccbq_run);
d615 1
a615 1
		goto fail4;
d624 1
a624 1
		goto fail4;
d630 1
a630 1
	type = letoh16(pg5.type);
d633 5
a637 5
	printf(", FW %c%c%c%c%c%c%c", ai.firmware[0], ai.firmware[1],
	    ai.firmware[2], ai.firmware[3], ai.firmware[4], ai.firmware[5],
	    ai.firmware[6]);
	printf(", BIOS %c%c%c%c%c%c%c", ai.bios[0], ai.bios[1], ai.bios[2],
	    ai.bios[3], ai.bios[4], ai.bios[5], ai.bios[6]);
d691 2
a693 2
	ips_ccb_free(sc, sc->sc_ccb, sc->sc_nccbs);
fail3:
d696 2
d709 1
d716 2
d720 1
a720 1
	int cmd, error, flags, s;
d733 1
a733 2
	s = splbio();
	drive = &sc->sc_di.drive[target];
d759 1
d761 1
d766 1
a766 1
			cmd = IPS_CMD_READ;
d769 1
a769 1
			cmd = IPS_CMD_WRITE;
d775 35
a809 9
		if ((error = ips_cmd(sc, cmd, target, blkno, xs->data,
		    blkcnt * IPS_SECSZ, flags, xs))) {
			if (error == ENOMEM) {
				splx(s);
				return (NO_CCB);
			} else if (flags & IPS_CCB_POLL) {
				splx(s);
				return (TRY_AGAIN_LATER);
			} else {
d811 5
a815 3
				scsi_done(xs);
				break;
			}
a817 1
		splx(s);
d859 2
d897 2
a898 4
	struct ips_adapterinfo ai;

	if (ips_getadapterinfo(sc, &ai))
		return (ENOTTY);
d902 2
a903 1
	bi->bi_nodisk = ai.drivecnt;
d911 3
a913 2
	struct ips_driveinfo di;
	struct ips_drive *drive;
d919 1
d921 1
a921 5
	if (ips_getdriveinfo(sc, &di))
		return (ENOTTY);
	drive = &di.drive[vid];

	switch (drive->state) {
d935 3
a937 3
	bv->bv_size = (u_quad_t)letoh32(drive->seccnt) * IPS_SECSZ;
	bv->bv_level = drive->raid;
	bv->bv_nodisk = sc->sc_conf.ld[vid].chunkcnt;
d949 1
a949 1
	int vid = bd->bd_volid, did = bd->bd_diskid;
d953 1
d957 1
a957 1
	ld = &sc->sc_conf.ld[vid];
d964 2
a965 5
		return (ENOTTY);
	dev = &sc->sc_conf.dev[chunk->channel][chunk->target];

	if (ips_getconf(sc, &sc->sc_conf))
		return (ENOTTY);
d996 2
a997 1
	struct ips_drive *drive;
d1000 1
a1000 1
	if (ips_getdriveinfo(sc, &sc->sc_di)) {
d1009 2
a1010 2
		drive = &sc->sc_di.drive[i];
		switch (drive->state) {
d1032 1
a1032 2
ips_cmd(struct ips_softc *sc, int code, int drive, u_int32_t lba, void *data,
    size_t size, int flags, struct scsi_xfer *xs)
d1034 1
a1034 1
	struct ips_cmd *cmd;
d1036 1
a1036 2
	struct ips_ccb *ccb;
	int nsegs, i, s, error = 0;
d1038 2
a1039 3
	DPRINTF(IPS_D_XFER, ("%s: cmd code 0x%02x, drive %d, lba %u, "
	    "size %lu, flags 0x%02x\n", sc->sc_dev.dv_xname, code, drive, lba,
	    (u_long)size, flags));
d1041 7
a1047 5
	/* Grab free CCB */
	if ((ccb = ips_ccb_get(sc)) == NULL) {
		DPRINTF(IPS_D_ERR, ("%s: no free CCB\n", sc->sc_dev.dv_xname));
		return (ENOMEM);
	}
d1049 2
a1050 2
	ccb->c_flags = flags;
	ccb->c_xfer = xs;
d1052 9
a1060 26
	/* Fill in command frame */
	cmd = ccb->c_cmdva;
	bzero(cmd, sizeof(*cmd));
	cmd->code = code;
	cmd->id = ccb->c_id;
	cmd->drive = drive;
	cmd->lba = htole32(lba);
	cmd->seccnt = htole16(howmany(size, IPS_SECSZ));

	if (size > 0) {
		/* Map data buffer into DMA segments */
		if (bus_dmamap_load(sc->sc_dmat, ccb->c_dmam, data, size,
		    NULL, BUS_DMA_NOWAIT)) {
			printf("%s: can't load dma map\n",
			    sc->sc_dev.dv_xname);
			return (1);	/* XXX: return code */
		}
		bus_dmamap_sync(sc->sc_dmat, ccb->c_dmam, 0,
		    ccb->c_dmam->dm_mapsize,
		    flags & IPS_CCB_READ ? BUS_DMASYNC_PREREAD :
		    BUS_DMASYNC_PREWRITE);

		if ((nsegs = ccb->c_dmam->dm_nsegs) > IPS_MAXSGS) {
			printf("%s: too many dma segs\n",
			    sc->sc_dev.dv_xname);
			return (1);	/* XXX: return code */
d1062 7
d1070 5
a1074 4
		if (nsegs > 1) {
			cmd->code |= IPS_CMD_SG;
			cmd->sgcnt = nsegs;
			cmd->sgaddr = htole32(ccb->c_cmdpa + IPS_CMDSZ);
d1076 4
a1079 13
			/* Fill in scatter-gather array */
			sg = (void *)(cmd + 1);
			for (i = 0; i < nsegs; i++) {
				sg[i].addr =
				    htole32(ccb->c_dmam->dm_segs[i].ds_addr);
				sg[i].size =
				    htole32(ccb->c_dmam->dm_segs[i].ds_len);
			}
		} else {
			cmd->sgcnt = 0;
			cmd->sgaddr = htole32(ccb->c_dmam->dm_segs[0].ds_addr);
		}
	}
d1082 1
a1082 2
	DPRINTF(IPS_D_XFER, ("%s: run command 0x%02x\n", sc->sc_dev.dv_xname,
	    ccb->c_id));
d1084 1
a1084 1
	TAILQ_INSERT_TAIL(&sc->sc_ccbq_run, ccb, c_link);
d1086 1
d1088 1
a1088 1
	if (flags & IPS_CCB_POLL) {
a1092 6
	} else {
		/* Set watchdog timer */
		if (xs != NULL) {
			timeout_set(&xs->stimeout, ips_timeout, ccb);
			timeout_add_sec(&xs->stimeout, IPS_TIMEOUT);
		}
d1119 1
a1119 1
			return (EBUSY);
d1124 1
a1124 1
		ips_done(sc, ccb);
d1131 1
a1131 1
ips_done(struct ips_softc *sc, struct ips_ccb *ccb)
a1139 4
		if (xs != NULL) {
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
		}
d1143 1
a1143 2
	if (xs != NULL)
		timeout_del(&xs->stimeout);
d1153 1
a1153 4
		if (xs != NULL)
			sc_print_addr(xs->sc_link);
		else
			printf("%s: ", sc->sc_dev.dv_xname);
a1162 1
	TAILQ_REMOVE(&sc->sc_ccbq_run, ccb, c_link);
d1165 33
a1197 7
	if (xs != NULL) {
		if (error)
			xs->error = XS_DRIVER_STUFFUP;
		else
			xs->resid = 0;
		xs->flags |= ITSDONE;
		scsi_done(xs);
d1199 3
d1229 1
a1229 1
		ips_done(sc, ccb);
a1251 1
	TAILQ_REMOVE(&sc->sc_ccbq_run, ccb, c_link);
d1263 1
a1263 1
ips_getadapterinfo(struct ips_softc *sc, struct ips_adapterinfo *ai)
d1265 19
a1283 2
	return (ips_cmd(sc, IPS_CMD_GETADAPTERINFO, 0, 0, ai, sizeof(*ai),
	    IPS_CCB_READ | IPS_CCB_POLL, NULL));
d1287 1
a1287 1
ips_getconf(struct ips_softc *sc, struct ips_conf *conf)
d1289 19
a1307 2
	return (ips_cmd(sc, IPS_CMD_READCONF, 0, 0, conf, sizeof(*conf),
	    IPS_CCB_READ | IPS_CCB_POLL, NULL));
d1311 1
a1311 1
ips_getdriveinfo(struct ips_softc *sc, struct ips_driveinfo *di)
d1313 19
a1331 2
	return (ips_cmd(sc, IPS_CMD_GETDRIVEINFO, 0, 0, di, sizeof(*di),
	    IPS_CCB_READ | IPS_CCB_POLL, NULL));
d1335 1
a1335 1
ips_flush(struct ips_softc *sc)
d1337 20
a1356 1
	return (ips_cmd(sc, IPS_CMD_FLUSH, 0, 0, NULL, 0, IPS_CCB_POLL, NULL));
d1360 1
a1360 1
ips_readnvram(struct ips_softc *sc, void *buf, int page)
d1362 17
a1378 2
	return (ips_cmd(sc, IPS_CMD_RWNVRAM, page, 0, buf, IPS_NVRAMPGSZ,
	    IPS_CCB_READ | IPS_CCB_POLL, NULL));
d1552 1
a1552 1
	if ((ccb = TAILQ_FIRST(&sc->sc_ccbq_free)) != NULL)
d1554 4
@


1.50
log
@Add sensors support.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.49 2009/03/01 15:35:10 grange Exp $	*/
a46 2

#define IPS_DEBUG	/* XXX: remove when driver becomes stable */
@


1.49
log
@- add missing letoh32
- tweak product string
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.48 2009/02/19 16:06:56 grange Exp $	*/
d32 1
d309 3
d347 2
d657 25
d952 39
@


1.48
log
@Don't use scsi_xfer if we don't run a command came from the scsi layer.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.47 2009/02/17 20:22:07 grange Exp $	*/
d758 1
a758 1
		    "RAID%d #%02d", drive->raid, target);
d1264 1
a1264 1
	status = sc->sc_sqbuf[sc->sc_sqidx];
@


1.47
log
@- add more bioctl support, now physical drives info available
- shrink dmesg strings
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.46 2009/02/16 21:19:07 miod Exp $	*/
d1005 4
a1008 2
		timeout_set(&xs->stimeout, ips_timeout, ccb);
		timeout_add_sec(&xs->stimeout, IPS_TIMEOUT);
d1074 4
a1077 1
		sc_print_addr(xs->sc_link);
@


1.46
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.45 2009/02/13 19:26:41 grange Exp $	*/
d64 1
d85 1
d211 59
d314 1
d335 2
d341 1
d351 1
d393 1
a393 1
	NULL
d454 2
d500 1
a500 2
	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_IBM_SERVERAID:
d502 1
a502 3
		break;
	case PCI_PRODUCT_IBM_SERVERAID2:
	case PCI_PRODUCT_ADP2_SERVERAID:
a503 5
		break;
	default:
		printf(": unsupported chipset\n");
		return;
	}
d509 1
a509 1
		printf(": can't map registers\n");
d519 1
a519 1
		printf(": can't allocate command buffer\n");
d526 1
a526 1
			printf(": can't allocate status queue\n");
d551 1
a551 1
		printf(": can't bootstrap CCB queue\n");
d565 7
d574 1
a574 1
		printf(": can't get logical drives info\n");
d589 1
a589 1
		printf(": can't allocate CCB queue\n");
d617 4
a620 5
	if (type > 1 && type - 2 < sizeof(ips_names) / sizeof(ips_names[0]))
		printf(" %s", ips_names[type - 2]);
	printf(", firmware %c%c%c%c%c%c%c",
	    ai.firmware[0], ai.firmware[1], ai.firmware[2],
	    ai.firmware[3], ai.firmware[4], ai.firmware[5],
d622 4
a625 4
	printf(", bios %c%c%c%c%c%c%c",
	    ai.bios[0], ai.bios[1], ai.bios[2], ai.bios[3], ai.bios[4],
	    ai.bios[5], ai.bios[6]);
	printf(", %d CCBs, %d units", sc->sc_nccbs, sc->sc_nunits);
d793 7
d813 2
d826 1
a826 1
		return (EIO);
d840 1
a841 2
	struct scsi_link *link;
	int id = bv->bv_volid, vol, i;
d843 1
a843 1
	if (id >= sc->sc_nunits)
d847 2
a848 2
		return (EIO);
	drive = &di.drive[id];
d866 20
a885 1
	bv->bv_nodisk = 0; /* XXX */
d887 7
a893 4
	for (i = 0, vol = -1; i < sc->sc_nunits; i++) {
		link = sc->sc_scsibus->sc_link[i][0];
		if (link == NULL)
			continue;
d895 2
a896 3
		/* skip if not a virtual disk */
		if (!(link->flags & SDEV_VIRTUAL))
			continue;
d898 18
a915 10
		vol++;
		/* are we it? */
		if (vol == id) {
			dev = link->device_softc;
			memcpy(bv->bv_vendor, link->inqdata.vendor,
			    sizeof bv->bv_vendor);
			bv->bv_vendor[sizeof(bv->bv_vendor) - 1] = '\0';
			strlcpy(bv->bv_dev, dev->dv_xname, sizeof(bv->bv_dev));
			break;
		}
d957 1
a957 1
			printf("%s: can't load DMA map\n",
d967 1
a967 1
			printf("%s: too many DMA segments\n",
d1052 1
a1052 1
		printf("%s: command 0x%02x not run\n", sc->sc_dev.dv_xname,
d1158 7
@


1.45
log
@When faking scsi commands never copy more than xs->datalen bytes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.44 2009/02/11 11:42:17 grange Exp $	*/
d324 1
a324 1
	minphys,
@


1.44
log
@Prettier fake scsi inquiry ascii strings.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.43 2009/02/11 08:41:36 grange Exp $	*/
d603 3
a605 3
	struct scsi_inquiry_data *id;
	struct scsi_read_cap_data *rcd;
	struct scsi_sense_data *sd;
d685 7
a691 8
		id = (void *)xs->data;
		bzero(id, sizeof(*id));
		id->device = T_DIRECT;
		id->version = 2;
		id->response_format = 2;
		id->additional_length = 32;
		strlcpy(id->vendor, "IBM", sizeof(id->vendor));
		snprintf(id->product, sizeof(id->product),
d693 2
a694 1
		strlcpy(id->revision, "1.0", sizeof(id->revision));
d697 4
a700 4
		rcd = (void *)xs->data;
		bzero(rcd, sizeof(*rcd));
		_lto4b(letoh32(drive->seccnt) - 1, rcd->addr);
		_lto4b(IPS_SECSZ, rcd->length);
d703 4
a706 4
		sd = (void *)xs->data;
		bzero(sd, sizeof(*sd));
		sd->error_code = SSD_ERRCODE_CURRENT;
		sd->flags = SKEY_NO_SENSE;
@


1.43
log
@Add a few missing byteorder conversion calls, tho I don't really
hope ips is usable on anything beside amd64 or i386 because of
its x86 BIOS.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.42 2009/02/10 12:43:03 grange Exp $	*/
d691 1
a691 1
		strlcpy(id->vendor, "IBM     ", sizeof(id->vendor));
d693 2
a694 2
		    "ServeRAID RAID%d #%02d", drive->raid, target);
		strlcpy(id->revision, "   ", sizeof(id->revision));
@


1.42
log
@Add missing copperhead chipset support bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.41 2009/02/10 09:09:56 grange Exp $	*/
d427 1
a427 1
	int i;
d549 3
a551 3
	if (pg5.type > 1 && pg5.type - 2 < sizeof(ips_names) /
	    sizeof(ips_names[0]))
		printf(" %s", ips_names[pg5.type - 2]);
d790 1
a790 1
	bv->bv_size = (u_quad_t)drive->seccnt * IPS_SECSZ;
@


1.41
log
@Update copyright year.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.40 2009/02/09 22:05:15 grange Exp $	*/
d74 1
d111 5
d262 5
d344 5
d359 1
d369 1
a379 5
enum {
	IPS_CHIP_COPPERHEAD = 0,
	IPS_CHIP_MORPHEUS
};

d463 19
d492 1
a492 1
		goto fail2;
d502 1
a502 1
		goto fail2;
d509 1
a509 1
		goto fail2;
d523 1
a523 1
		goto fail2;
d534 1
a534 1
		goto fail3;
d543 1
a543 1
		goto fail3;
d586 2
d589 2
a590 1
	ips_ccb_free(sc, sc->sc_ccb, sc->sc_nccbs);
d1134 19
a1152 2
	/* XXX: not implemented */
	return (0);
@


1.40
log
@Improve adapter type displaying.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.39 2009/02/09 20:20:15 grange Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006, 2007 Alexander Yurchenko <grange@@openbsd.org>
@


1.39
log
@Start on bioctl support for ips. Only adapter and volume info for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.37 2009/02/08 12:00:19 grange Exp $	*/
d73 1
d100 1
d153 2
a154 2
	u_int8_t	codeblkver[8];
	u_int8_t	bootblkver[8];
d188 15
d277 1
a332 1
	const char *	ic_name;
a342 1
		"Copperhead",
a351 1
		"Morpheus",
d374 20
d409 1
d481 4
d516 4
a519 2
	printf("%s", sc->sc_dev.dv_xname);
	printf(": %s", sc->sc_chip->ic_name);
d521 6
a526 7
	    ai.codeblkver[0], ai.codeblkver[1], ai.codeblkver[2],
	    ai.codeblkver[3], ai.codeblkver[4], ai.codeblkver[5],
	    ai.codeblkver[6]);
	printf(", bootblock %c%c%c%c%c%c%c",
	    ai.bootblkver[0], ai.bootblkver[1], ai.bootblkver[2],
	    ai.bootblkver[3], ai.bootblkver[4], ai.bootblkver[5],
	    ai.bootblkver[6]);
d1034 7
@


1.38
log
@Protect ips_poll call with splbio.
@
text
@d23 2
d29 1
d41 2
d222 1
d246 4
d500 2
a501 1
	config_found(self, &saa, scsiprint);
d506 6
d650 92
@


1.37
log
@Lower debug level back, looks like i've found that data corruption bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.36 2009/02/08 11:42:43 grange Exp $	*/
d641 1
a641 1
	int nsegs, i, error = 0;
d712 1
d714 1
@


1.36
log
@Put back bzero'ing cmd structure before filling it in which was lost
during driver rewritting at h2k7.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.35 2009/02/08 10:47:31 grange Exp $	*/
d51 1
a51 1
int ips_debug = 0xff;
@


1.35
log
@Temporary enable full debug to make it easier to commit diffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.34 2009/02/08 10:46:09 grange Exp $	*/
d658 1
@


1.34
log
@ips is not a real scsi controller and not supposed to talk directly to
various flacky scsi hardware (at least until passthrough implemented).
So reduce huge default scsibus timeout values to somewhat reasonable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.33 2009/02/08 09:07:36 grange Exp $	*/
d51 1
a51 1
int ips_debug = IPS_D_ERR;
@


1.33
log
@Use sc_print_addr() to report drive errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.32 2009/02/08 08:54:10 grange Exp $	*/
d69 2
d715 1
a715 1
		timeout_add_msec(&xs->stimeout, xs->timeout);
@


1.32
log
@Add drive state definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.31 2009/01/09 21:47:08 grange Exp $	*/
d779 1
a779 1
		printf("%s: ", sc->sc_dev.dv_xname);
@


1.31
log
@Implement command timeouts. With some helpful tips from miod@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.30 2007/09/17 01:33:33 krw Exp $	*/
d168 7
@


1.30
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.29 2007/06/06 20:51:13 grange Exp $	*/
d236 1
d700 1
a700 1
	if (flags & IPS_CCB_POLL)
d703 5
d761 3
d824 28
@


1.29
log
@Remove IPS_D_INTR debug level, IPS_D_XFER is good enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.28 2007/05/29 16:56:01 grange Exp $	*/
d954 1
a954 1
	if ((ccb = malloc(n * sizeof(*ccb), M_DEVBUF, M_NOWAIT)) == NULL)
a955 1
	bzero(ccb, n * sizeof(*ccb));
@


1.28
log
@Fix bus_dmamap_sync size argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.27 2007/05/28 17:44:54 grange Exp $	*/
a47 1
#define IPS_D_INTR	0x0008	/* interrupts */
d799 1
a799 1
		DPRINTF(IPS_D_INTR, ("%s: intr status 0x%08x\n",
d925 1
a925 1
	DPRINTF(IPS_D_INTR, ("%s: isintr 0x%08x\n", sc->sc_dev.dv_xname, reg));
d943 1
a943 1
	DPRINTF(IPS_D_INTR, ("%s: status 0x%08x\n", sc->sc_dev.dv_xname, reg));
@


1.27
log
@Bump timeout.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.26 2007/05/28 17:18:35 grange Exp $	*/
d663 2
a664 1
		bus_dmamap_sync(sc->sc_dmat, ccb->c_dmam, 0, size,
@


1.26
log
@Decrease max number of commands to 128.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.25 2007/05/28 16:35:41 grange Exp $	*/
d714 1
a714 1
		for (timeout = 10; timeout-- > 0; delay(100)) {
d843 1
a843 1
	for (timeout = 10; timeout-- > 0; delay(100)) {
@


1.25
log
@Start adding copperhead chipset support. Not tested at all.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.24 2007/05/28 14:05:16 grange Exp $	*/
d60 1
a60 1
#define IPS_MAXCMDS		256
@


1.24
log
@Fix timeout loop in ips_poll().
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.23 2007/05/28 13:07:49 grange Exp $	*/
d95 3
d840 16
a855 1
	/* XXX: not implemented */
d867 1
a867 1
	/* XXX: not implemented */
d873 7
a879 1
	/* XXX: not implemented */
@


1.23
log
@Better debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.22 2007/05/28 05:10:12 grange Exp $	*/
d722 1
a722 1
		if (timeout == 0) {
@


1.22
log
@Provide a separate DMA-able command frame buffer for each CCB to prevent
a race when the new command is posting while the target DMA engine is still
reading the previous command. Now I can finaly remove the openings=1 hack.
Many thanks to dlg@@ for analizing the problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.21 2007/05/28 03:57:43 grange Exp $	*/
d716 2
a717 2
				DPRINTF(IPS_D_ERR, ("%s: invalid command %d\n",
				    sc->sc_dev.dv_xname, id));
@


1.21
log
@Sprincle some more scsi_done().
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.20 2007/05/28 03:01:10 grange Exp $	*/
d60 1
d179 2
d239 1
a239 1
void	ips_copperhead_exec(struct ips_softc *);
d246 1
a246 1
void	ips_morpheus_exec(struct ips_softc *);
d253 2
a254 2
struct ips_ccb *ips_ccb_alloc(bus_dma_tag_t, int);
void	ips_ccb_free(struct ips_ccb *, bus_dma_tag_t, int);
d296 1
a296 1
	void		(*ic_exec)(struct ips_softc *);
d330 1
a330 1
#define ips_exec(s)	(s)->sc_chip->ic_exec((s))
d386 2
a387 1
	if (ips_dmamem_alloc(&sc->sc_cmdm, sc->sc_dmat, IPS_MAXCMDSZ)) {
d396 2
d427 1
a427 1
	if ((sc->sc_ccb = ips_ccb_alloc(sc->sc_dmat, sc->sc_nccbs)) == NULL) {
a469 1
	sc->sc_scsi_link.openings = 1; /* XXX */
d485 1
a485 1
	ips_ccb_free(sc->sc_ccb, sc->sc_dmat, sc->sc_nccbs);
d626 2
a627 2
	struct ips_cmd *cmd = sc->sc_cmdm.dm_vaddr;
	struct ips_sg *sg = (void *)(cmd + 1);
d645 1
d673 1
a673 1
			cmd->sgaddr = htole32(sc->sc_cmdm.dm_paddr + IPS_CMDSZ);
d676 1
d694 1
a694 1
	ips_exec(sc);
d835 1
a835 1
ips_copperhead_exec(struct ips_softc *sc)
d874 1
a874 1
ips_morpheus_exec(struct ips_softc *sc)
d876 1
a876 2
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, IPS_REG_IQP,
	    sc->sc_cmdm.dm_paddr);
d925 1
a925 1
ips_ccb_alloc(bus_dma_tag_t dmat, int n)
d936 4
a939 1
		if (bus_dmamap_create(dmat, IPS_MAXFER, IPS_MAXSGS,
d948 1
a948 1
		bus_dmamap_destroy(dmat, ccb[i - 1].c_dmam);
d954 1
a954 1
ips_ccb_free(struct ips_ccb *ccb, bus_dma_tag_t dmat, int n)
d959 1
a959 1
		bus_dmamap_destroy(dmat, ccb[i - 1].c_dmam);
@


1.20
log
@Release CCB before calling scsi_done(). Thanks dlg@@ for the tip.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.19 2007/05/27 20:57:58 grange Exp $	*/
d507 3
d611 1
@


1.19
log
@Add basic error detection.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.18 2007/05/27 20:06:40 grange Exp $	*/
d729 1
d750 1
a750 1
		if (ccb->c_stat == 1)
d752 1
a752 1
		else
d754 2
d758 4
d763 1
a763 1
		if (ccb->c_stat > 1)
a769 4

	/* Release CCB */
	TAILQ_REMOVE(&sc->sc_ccbq_run, ccb, c_link);
	ips_ccb_put(sc, ccb);
@


1.18
log
@Better debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.17 2007/05/27 19:21:09 grange Exp $	*/
d106 3
d180 2
d716 2
d747 8
d756 4
a759 1
		xs->resid = 0;
d792 2
@


1.17
log
@A completely rewritten ips driver. Still work in progress but already
better than before. I've started it right after h2k7 in the Lisbon
airport but could commit only at c2k7.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.16 2006/11/29 18:18:39 grange Exp $	*/
d674 2
d724 1
a724 1
		printf("%s: command %d not run\n", sc->sc_dev.dv_xname,
@


1.16
log
@Limit the number of openings to 1 for now, there're still bugs.
Thanks to miod for the hint.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.15 2006/11/29 14:52:19 grange Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Alexander Yurchenko <grange@@openbsd.org>
d20 1
a20 1
 * IBM ServeRAID controller driver.
a26 1
#include <sys/endian.h>
d42 1
a42 1
#define IPS_DEBUG	/* XXX: remove when the driver becomes stable */
d45 4
a48 4
#define IPS_D_ERR	0x0001
#define IPS_D_INFO	0x0002
#define IPS_D_XFER	0x0004
#define IPS_D_INTR	0x0008
d51 1
a51 1
#define DPRINTF(a, b)	if (ips_debug & (a)) printf b
a56 31
/*
 * Register definitions.
 */
#define IPS_BAR0		0x10	/* I/O space base address */
#define IPS_BAR1		0x14	/* I/O space base address */

#define IPS_MORPHEUS_OISR	0x0030	/* outbound IRQ status */
#define	IPS_MORPHEUS_OISR_CMD		(1 << 3)
#define IPS_MORPHEUS_OIMR	0x0034	/* outbound IRQ mask */
#define IPS_MORPHEUS_IQPR	0x0040	/* inbound queue port */
#define IPS_MORPHEUS_OQPR	0x0044	/* outbound queue port */
#define IPS_MORPHEUS_OQPR_ID(x)		(((x) >> 8) & 0xff)
#define IPS_MORPHEUS_OQPR_ST(x)		(((x) >> 16) & 0xff)
#define IPS_MORPHEUS_OQPR_GSC(x)	(((x) >> 16) & 0x0f)
#define IPS_MORPHEUS_OQPR_EST(x)	(((x) >> 24) & 0xff)
#define IPS_MORPHEUS_GSC_NOERR		0x0
#define IPS_MORPHEUS_GSC_RECOV		0x1

/* Commands */
#define IPS_CMD_READ		0x02
#define IPS_CMD_WRITE		0x03
#define IPS_CMD_ADAPTERINFO	0x05
#define IPS_CMD_FLUSHCACHE	0x0a
#define IPS_CMD_READ_SG		0x82
#define IPS_CMD_WRITE_SG	0x83
#define IPS_CMD_DRIVEINFO	0x19

#define IPS_MAXCMDSZ		256	/* XXX: for now */
#define IPS_MAXDATASZ		64 * 1024
#define IPS_MAXSEGS		32

a59 1
#define IPS_MAXCMDS		32
d62 2
a63 1
#define IPS_MAXSGS		32
d65 3
a67 10
/* Command frames */
struct ips_cmd_adapterinfo {
	u_int8_t	command;
	u_int8_t	id;
	u_int8_t	reserve1;
	u_int8_t	commandtype;
	u_int32_t	reserve2;
	u_int32_t	buffaddr;
	u_int32_t	reserve3;
} __packed;
d69 41
a109 12
struct ips_cmd_driveinfo {
	u_int8_t	command;
	u_int8_t	id;
	u_int8_t	drivenum;
	u_int8_t	reserve1;
	u_int32_t	reserve2;
	u_int32_t	buffaddr;
	u_int32_t	reserve3;
} __packed;

struct ips_cmd_generic {
	u_int8_t	command;
d111 2
a112 2
	u_int8_t	drivenum;
	u_int8_t	reserve2;
d114 7
a120 3
	u_int32_t	buffaddr;
	u_int32_t	reserve3;
} __packed;
d122 5
a126 10
struct ips_cmd_io {
	u_int8_t	command;
	u_int8_t	id;
	u_int8_t	drivenum;
	u_int8_t	segnum;
	u_int32_t	lba;
	u_int32_t	buffaddr;
	u_int16_t	length;
	u_int16_t	reserve1;
} __packed;
d130 23
a152 31
	u_int8_t	drivecount;
	u_int8_t	miscflags;
	u_int8_t	SLTflags;
	u_int8_t	BSTflags;
	u_int8_t	pwr_chg_count;
	u_int8_t	wrong_addr_count;
	u_int8_t	unident_count;
	u_int8_t	nvram_dev_chg_count;
	u_int8_t	codeblock_version[8];
	u_int8_t	bootblock_version[8];
	u_int32_t	drive_sector_count[IPS_MAXDRIVES];
	u_int8_t	max_concurrent_cmds;
	u_int8_t	max_phys_devices;
	u_int16_t	flash_prog_count;
	u_int8_t	defunct_disks;
	u_int8_t	rebuildflags;
	u_int8_t	offline_drivecount;
	u_int8_t	critical_drivecount;
	u_int16_t	config_update_count;
	u_int8_t	blockedflags;
	u_int8_t	psdn_error;
	u_int16_t	addr_dead_disk[IPS_MAXCHANS][IPS_MAXTARGETS];
} __packed;

struct ips_drive {
	u_int8_t	drivenum;
	u_int8_t	merge_id;
	u_int8_t	raid_lvl;
	u_int8_t	state;
	u_int32_t	sector_count;
} __packed;
d155 19
a173 16
	u_int8_t	drivecount;
	u_int8_t	reserve1;
	u_int16_t	reserve2;
	struct ips_drive drives[IPS_MAXDRIVES];
} __packed;

/* I/O access helper macros */
#define IPS_READ_4(s, r) \
	letoh32(bus_space_read_4((s)->sc_iot, (s)->sc_ioh, (r)))
#define IPS_WRITE_4(s, r, v) \
	bus_space_write_4((s)->sc_iot, (s)->sc_ioh, (r), htole32((v)))

struct ccb {
	int			c_id;
	int			c_flags;
#define CCB_F_RUN	0x0001
d175 2
a176 2
	bus_dmamap_t		c_dmam;
	struct scsi_xfer *	c_xfer;
d178 1
a178 1
	TAILQ_ENTRY(ccb)	c_link;
d181 2
a182 1
TAILQ_HEAD(ccbq, ccb);
d184 1
d190 2
a191 1
	void *			dm_kva;
a197 4
	struct scsibus_softc *	sc_scsi_bus;

	pci_chipset_tag_t	sc_pc;
	pcitag_t		sc_tag;
d203 1
a203 1
	struct dmamem *		sc_cmdm;
d205 2
a206 4
	struct ccb *		sc_ccb;
	struct ccbq		sc_ccbq;

	void *			sc_ih;
d208 1
a208 3
	void			(*sc_exec)(struct ips_softc *);
	void			(*sc_inten)(struct ips_softc *);
	int			(*sc_intr)(void *);
d210 4
a213 2
	struct ips_adapterinfo	sc_ai;
	struct ips_driveinfo	sc_di;
a219 4
int	ips_scsi_io(struct scsi_xfer *);
int	ips_scsi_ioctl(struct scsi_link *, u_long, caddr_t, int,
	    struct proc *);
void	ips_scsi_minphys(struct buf *);
d221 5
a225 1
void	ips_xfer_timeout(void *);
a226 1
void	ips_flushcache(struct ips_softc *);
d229 1
d232 5
a236 2
void	ips_copperhead_inten(struct ips_softc *);
int	ips_copperhead_intr(void *);
d239 10
a248 5
void	ips_morpheus_inten(struct ips_softc *);
int	ips_morpheus_intr(void *);

struct ccb *	ips_ccb_alloc(bus_dma_tag_t, int);
void		ips_ccb_free(struct ccb *, bus_dma_tag_t, int);
d250 2
a251 2
struct dmamem *	ips_dmamem_alloc(bus_dma_tag_t, bus_size_t);
void		ips_dmamem_free(struct dmamem *);
a262 6
static const struct pci_matchid ips_ids[] = {
	{ PCI_VENDOR_IBM,	PCI_PRODUCT_IBM_SERVERAID },
	{ PCI_VENDOR_IBM,	PCI_PRODUCT_IBM_SERVERAID2 },
	{ PCI_VENDOR_ADP2,	PCI_PRODUCT_ADP2_SERVERAID }
};

d265 1
a265 1
	ips_scsi_minphys,
d268 1
a268 1
	ips_scsi_ioctl
d278 51
d341 1
d343 1
a343 1
	int bar;
d348 1
a348 1
	int i, maxcmds;
a349 2
	sc->sc_pc = pa->pa_pc;
	sc->sc_tag = pa->pa_tag;
d352 1
a352 1
	/* Identify the chipset */
d355 1
a355 4
		printf(": Copperhead");
		sc->sc_exec = ips_copperhead_exec;
		sc->sc_inten = ips_copperhead_inten;
		sc->sc_intr = ips_copperhead_intr;
d359 1
a359 4
		printf(": Morpheus");
		sc->sc_exec = ips_morpheus_exec;
		sc->sc_inten = ips_morpheus_inten;
		sc->sc_intr = ips_morpheus_intr;
d361 3
d366 5
a370 9
	/* Map I/O space */
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_IBM_SERVERAID)
		bar = IPS_BAR1;
	else
		bar = IPS_BAR0;
	maptype = pci_mapreg_type(sc->sc_pc, sc->sc_tag, bar);
	if (pci_mapreg_map(pa, bar, maptype, 0, &sc->sc_iot, &sc->sc_ioh,
	    NULL, &iosize, 0)) {
		printf(": can't map I/O space\n");
d374 6
a379 4
	/* Allocate command DMA buffer */
	if ((sc->sc_cmdm = ips_dmamem_alloc(sc->sc_dmat,
	    IPS_MAXCMDSZ)) == NULL) {
		printf(": can't alloc command DMA buffer\n");
d383 14
d398 1
a398 1
	if (ips_getadapterinfo(sc, &sc->sc_ai)) {
d400 1
d406 2
a407 1
		printf(": can't get drives info\n");
d410 3
d414 4
a417 4
	/* Allocate command queue */
	maxcmds = sc->sc_ai.max_concurrent_cmds;
	if ((sc->sc_ccb = ips_ccb_alloc(sc->sc_dmat, maxcmds)) == NULL) {
		printf(": can't alloc command queue\n");
d420 5
a424 4

	TAILQ_INIT(&sc->sc_ccbq);
	for (i = 0; i < maxcmds; i++)
		TAILQ_INSERT_TAIL(&sc->sc_ccbq, &sc->sc_ccb[i], c_link);
d431 3
a433 3
	intrstr = pci_intr_string(sc->sc_pc, ih);
	if ((sc->sc_ih = pci_intr_establish(sc->sc_pc, ih, IPL_BIO,
	    sc->sc_intr, sc, sc->sc_dev.dv_xname)) == NULL) {
d440 1
a440 1
	printf(", %s\n", intrstr);
d442 13
a454 2
	/* Enable interrupts */
	(*sc->sc_inten)(sc);
d457 5
a461 3
	sc->sc_scsi_link.openings = 1; /* XXX: for now */
	sc->sc_scsi_link.adapter_target = IPS_MAXTARGETS;
	sc->sc_scsi_link.adapter_buswidth = IPS_MAXTARGETS;
d468 1
d470 2
a471 2
	sc->sc_scsi_bus = (struct scsibus_softc *)config_found(self, &saa,
	    scsiprint);
d475 1
a475 1
	ips_ccb_free(sc->sc_ccb, sc->sc_dmat, maxcmds);
d477 1
a477 1
	ips_dmamem_free(sc->sc_cmdm);
d487 6
a492 3
	struct scsi_inquiry_data *inq;
	struct scsi_read_cap_data *cap;
	struct scsi_sense_data *sns;
d494 10
a503 1
	int s;
d505 3
a507 2
	if (target >= sc->sc_di.drivecount || link->lun != 0)
		goto error;
d509 1
d515 51
a565 1
		return (ips_scsi_io(xs));
d567 11
a577 10
		inq = (void *)xs->data;
		bzero(inq, sizeof(*inq));
		inq->device = T_DIRECT;
		inq->version = 2;
		inq->response_format = 2;
		inq->additional_length = 32;
		strlcpy(inq->vendor, "IBM", sizeof(inq->vendor));
		snprintf(inq->product, sizeof(inq->product),
		    "ServeRAID LD %02d", target);
		goto done;
d579 5
a583 5
		cap = (void *)xs->data;
		bzero(cap, sizeof(*cap));
		_lto4b(sc->sc_di.drives[target].sector_count - 1, cap->addr);
		_lto4b(512, cap->length);
		goto done;
d585 5
a589 5
		sns = (void *)xs->data;
		bzero(sns, sizeof(*sns));
		sns->error_code = 0x70;
		sns->flags = SKEY_NO_SENSE;
		goto done;
d591 3
a593 2
		ips_flushcache(sc);
		goto done;
d597 5
a601 1
		return (COMPLETE);
d603 1
a604 6
error:
	xs->error = XS_DRIVER_STUFFUP;
done:
	s = splbio();
	scsi_done(xs);
	splx(s);
d609 2
a610 1
ips_scsi_io(struct scsi_xfer *xs)
d612 8
a619 8
	struct scsi_link *link = xs->sc_link;
	struct ips_softc *sc = link->adapter_softc;
	struct scsi_rw *rw;
	struct scsi_rw_big *rwb;
	struct ccb *ccb;
	struct ips_cmd_io *cmd;
	u_int32_t blkno, blkcnt;
	int i, s;
d621 4
a624 10
	/* Pick up the first free ccb */
	s = splbio();
	ccb = TAILQ_FIRST(&sc->sc_ccbq);
	if (ccb != NULL)
		TAILQ_REMOVE(&sc->sc_ccbq, ccb, c_link);
	splx(s);
	if (ccb == NULL) {
		DPRINTF(IPS_D_ERR, ("%s: scsi_io, no free ccb\n",
		    sc->sc_dev.dv_xname));
		return (TRY_AGAIN_LATER);
a625 2
	DPRINTF(IPS_D_XFER, ("%s: scsi_io, ccb id %d\n", sc->sc_dev.dv_xname,
	    ccb->c_id));
d627 1
a627 2
	bus_dmamap_load(sc->sc_dmat, ccb->c_dmam, xs->data, xs->datalen, NULL,
	    BUS_DMA_NOWAIT);
d630 24
a653 10
	if (xs->cmd->opcode == READ_COMMAND ||
	    xs->cmd->opcode == WRITE_COMMAND) {
		rw = (void *)xs->cmd;
		blkno = _3btol(rw->addr) & (SRW_TOPADDR << 16 | 0xffff);
		blkcnt = rw->length > 0 ? rw->length : 0x100;
	} else {
		rwb = (void *)xs->cmd;
		blkno = _4btol(rwb->addr);
		blkcnt = _2btol(rwb->length);
	}
d655 16
a670 22
	cmd = sc->sc_cmdm->dm_kva;
	bzero(cmd, sizeof(*cmd));
	cmd->command = (xs->flags & SCSI_DATA_IN) ? IPS_CMD_READ :
	    IPS_CMD_WRITE;
	cmd->id = ccb->c_id;
	cmd->drivenum = link->target;
	cmd->lba = blkno;
	cmd->length = blkcnt;
	if (ccb->c_dmam->dm_nsegs > 1) {
		cmd->command = (xs->flags & SCSI_DATA_IN) ? IPS_CMD_READ_SG :
		    IPS_CMD_WRITE_SG;
		cmd->segnum = ccb->c_dmam->dm_nsegs;

		for (i = 0; i < ccb->c_dmam->dm_nsegs; i++) {
			*(u_int32_t *)((u_int8_t *)sc->sc_cmdm->dm_kva + 24 +
			    i * 8) = ccb->c_dmam->dm_segs[i].ds_addr;
			*(u_int32_t *)((u_int8_t *)sc->sc_cmdm->dm_kva + 24 +
			    i * 8 + 4) = ccb->c_dmam->dm_segs[i].ds_len;
		}
		cmd->buffaddr = sc->sc_cmdm->dm_seg.ds_addr + 24;
	} else {
		cmd->buffaddr = ccb->c_dmam->dm_segs[0].ds_addr;
d673 8
a680 2
	timeout_set(&xs->stimeout, ips_xfer_timeout, ccb);
	timeout_add(&xs->stimeout, (xs->timeout * 1000) / hz);
d682 1
a682 6
	s = splbio();
	(*sc->sc_exec)(sc);
	ccb->c_flags |= CCB_F_RUN;
	splx(s);

	return (SUCCESSFULLY_QUEUED);
d686 1
a686 2
ips_scsi_ioctl(struct scsi_link *link, u_long cmd, caddr_t addr, int flags,
    struct proc *p)
d688 23
a710 2
	return (ENOTTY);
}
d712 1
a712 4
void
ips_scsi_minphys(struct buf *bp)
{
	minphys(bp);
d716 1
a716 1
ips_xfer_timeout(void *arg)
a717 1
	struct ccb *ccb = arg;
d719 11
a729 2
	struct ips_softc *sc = xs->sc_link->adapter_softc;
	int s;
d731 12
a742 2
	DPRINTF(IPS_D_ERR, ("%s: xfer timeout, ccb id %d\n",
	    sc->sc_dev.dv_xname, ccb->c_id));
d744 3
a746 7
	bus_dmamap_unload(sc->sc_dmat, ccb->c_dmam);
	xs->error = XS_TIMEOUT;
	s = splbio();
	scsi_done(xs);
	ccb->c_flags &= ~CCB_F_RUN;
	TAILQ_INSERT_TAIL(&sc->sc_ccbq, ccb, c_link);
	splx(s);
d749 2
a750 2
void
ips_flushcache(struct ips_softc *sc)
d752 4
a755 1
	struct ips_cmd_generic *cmd;
d757 2
a758 2
	cmd = sc->sc_cmdm->dm_kva;
	cmd->command = IPS_CMD_FLUSHCACHE;
d760 16
a775 2
	(*sc->sc_exec)(sc);
	DELAY(1000);
d781 2
a782 17
	struct dmamem *dm;
	struct ips_cmd_adapterinfo *cmd;

	if ((dm = ips_dmamem_alloc(sc->sc_dmat, sizeof(*ai))) == NULL)
		return (1);

	cmd = sc->sc_cmdm->dm_kva;
	bzero(cmd, sizeof(*cmd));
	cmd->command = IPS_CMD_ADAPTERINFO;
	cmd->buffaddr = dm->dm_seg.ds_addr;

	(*sc->sc_exec)(sc);
	DELAY(1000);
	bcopy(dm->dm_kva, ai, sizeof(*ai));
	ips_dmamem_free(dm);

	return (0);
d788 3
a790 2
	struct dmamem *dm;
	struct ips_cmd_driveinfo *cmd;
d792 5
a796 2
	if ((dm = ips_dmamem_alloc(sc->sc_dmat, sizeof(*di))) == NULL)
		return (1);
d798 5
a802 9
	cmd = sc->sc_cmdm->dm_kva;
	bzero(cmd, sizeof(*cmd));
	cmd->command = IPS_CMD_DRIVEINFO;
	cmd->buffaddr = dm->dm_seg.ds_addr;

	(*sc->sc_exec)(sc);
	DELAY(1000);
	bcopy(dm->dm_kva, di, sizeof(*di));
	ips_dmamem_free(dm);
d804 4
a807 1
	return (0);
d811 1
a811 1
ips_copperhead_exec(struct ips_softc *sc)
d813 1
d816 2
a817 2
void
ips_copperhead_inten(struct ips_softc *sc)
d819 2
d824 1
a824 1
ips_copperhead_intr(void *arg)
d826 8
d840 2
a841 1
	IPS_WRITE_4(sc, IPS_MORPHEUS_IQPR, sc->sc_cmdm->dm_seg.ds_addr);
d845 7
a851 1
ips_morpheus_inten(struct ips_softc *sc)
d855 3
a857 3
	reg = IPS_READ_4(sc, IPS_MORPHEUS_OIMR);
	reg &= ~0x08;
	IPS_WRITE_4(sc, IPS_MORPHEUS_OIMR, reg);
d861 1
a861 1
ips_morpheus_intr(void *arg)
d863 1
a863 9
	struct ips_softc *sc = arg;
	struct ccb *ccb;
	struct scsi_xfer *xs;
	u_int32_t oisr, oqpr;
	int gsc, id, s, rv = 0;

	oisr = IPS_READ_4(sc, IPS_MORPHEUS_OISR);
	DPRINTF(IPS_D_INTR, ("%s: intr, OISR 0x%08x\n",
	    sc->sc_dev.dv_xname, oisr));
d865 2
a866 2
	if (!(oisr & IPS_MORPHEUS_OISR_CMD))
		return (0);
d868 2
a869 2
	while ((oqpr = IPS_READ_4(sc, IPS_MORPHEUS_OQPR)) != 0xffffffff) {
		DPRINTF(IPS_D_INTR, ("OQPR 0x%08x\n", oqpr));
d871 6
a876 2
		gsc = IPS_MORPHEUS_OQPR_GSC(oqpr);
		id = IPS_MORPHEUS_OQPR_ID(oqpr);
d878 4
a881 7
		if (gsc != IPS_MORPHEUS_GSC_NOERR &&
		    gsc != IPS_MORPHEUS_GSC_RECOV) {
			DPRINTF(IPS_D_ERR, ("%s: intr, error 0x%x",
			    sc->sc_dev.dv_xname, gsc));
			DPRINTF(IPS_D_ERR, (", OISR 0x%08x, OQPR 0x%08x\n",
			    oisr, oqpr));
		}
d883 2
a884 29
		if (id >= sc->sc_ai.max_concurrent_cmds) {
			DPRINTF(IPS_D_ERR, ("%s: intr, bogus id %d",
			    sc->sc_dev.dv_xname, id));
			DPRINTF(IPS_D_ERR, (", OISR 0x%08x, OQPR 0x%08x\n",
			    oisr, oqpr));
			continue;
		}

		ccb = &sc->sc_ccb[id];
		if (!(ccb->c_flags & CCB_F_RUN)) {
			DPRINTF(IPS_D_ERR, ("%s: intr, ccb id %d not run",
			    sc->sc_dev.dv_xname, id));
			DPRINTF(IPS_D_ERR, (", OISR 0x%08x, OQPR 0x%08x\n",
			    oisr, oqpr));
			continue;
		}

		rv = 1;
		bus_dmamap_unload(sc->sc_dmat, ccb->c_dmam);
		xs = ccb->c_xfer;
		xs->resid = 0;
		xs->flags |= ITSDONE;
		timeout_del(&xs->stimeout);
		s = splbio();
		scsi_done(xs);
		ccb->c_flags &= ~CCB_F_RUN;
		TAILQ_INSERT_TAIL(&sc->sc_ccbq, ccb, c_link);
		splx(s);
	}
d886 1
a886 1
	return (rv);
d889 1
a889 1
struct ccb *
d892 1
a892 1
	struct ccb *ccb;
d916 1
a916 1
ips_ccb_free(struct ccb *ccb, bus_dma_tag_t dmat, int n)
d925 21
a945 2
struct dmamem *
ips_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size)
a946 1
	struct dmamem *dm;
a948 3
	if ((dm = malloc(sizeof(*dm), M_DEVBUF, M_NOWAIT)) == NULL)
		return (NULL);

d954 3
d958 1
a958 1
	if (bus_dmamem_alloc(tag, size, 0, 0, &dm->dm_seg, 1, &nsegs,
d961 1
a961 1
	if (bus_dmamem_map(tag, &dm->dm_seg, 1, size, (caddr_t *)&dm->dm_kva,
a963 4
	bzero(dm->dm_kva, size);
	if (bus_dmamap_load(tag, dm->dm_map, dm->dm_kva, size, NULL,
	    BUS_DMA_NOWAIT))
		goto fail4;
d965 1
a965 1
	return (dm);
a966 2
fail4:
	bus_dmamem_unmap(tag, dm->dm_kva, size);
d968 2
d971 1
a971 1
fail2:
d973 1
a973 3
fail1:
	free(dm, M_DEVBUF);
	return (NULL);
d980 1
a980 1
	bus_dmamem_unmap(dm->dm_tag, dm->dm_kva, dm->dm_size);
a982 1
	free(dm, M_DEVBUF);
@


1.15
log
@Report about command error
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.14 2006/11/29 14:41:09 grange Exp $	*/
d398 1
a398 1
	sc->sc_scsi_link.openings = IPS_MAXCMDS;	/* XXX: for now */
@


1.14
log
@ips firmware runs on a little-endian cpu so do endian conversion
in i/o access macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.13 2006/11/29 14:38:17 grange Exp $	*/
d685 1
a685 1
	int id, s, rv = 0;
d697 1
d699 9
@


1.13
log
@Add some constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.12 2006/11/29 00:08:00 grange Exp $	*/
d27 1
d182 1
a182 1
	bus_space_read_4((s)->sc_iot, (s)->sc_ioh, (r))
d184 1
a184 1
	bus_space_write_4((s)->sc_iot, (s)->sc_ioh, (r), (v))
@


1.12
log
@Oh, scsi layer already has timeout stuff for us.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.11 2006/11/29 00:04:39 dlg Exp $	*/
d68 6
d696 1
a696 1
		id = (oqpr >> 8) & 0xff;
@


1.11
log
@oops, i missed ips when giving scsibus an attach args for drivers to fill
in.

dedicated to grange, the most talented man at h2k6
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.10 2006/11/28 23:49:50 grange Exp $	*/
a185 1
	struct timeout		c_timo;
d539 2
a540 1
	timeout_add(&ccb->c_timo, hz);
a708 1
		timeout_del(&ccb->c_timo);
d713 1
a739 1
		timeout_set(&ccb[i].c_timo, ips_xfer_timeout, &ccb[i]);
@


1.10
log
@I just don't know why I decided to set block count to 512 unconditionaly
on every scatter-gather transfer.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.9 2006/11/28 19:59:14 grange Exp $	*/
d301 1
d399 5
a403 2
	sc->sc_scsi_bus = (struct scsibus_softc *)config_found(self,
	    &sc->sc_scsi_link, scsiprint);
@


1.9
log
@Better debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.8 2006/11/28 18:27:53 grange Exp $	*/
a531 1
		cmd->length = 512;
@


1.8
log
@Try to detect stalled xfers with timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.7 2006/11/28 16:17:29 grange Exp $	*/
d674 1
a674 1
	u_int32_t reg;
d677 5
a681 2
	reg = IPS_READ_4(sc, IPS_MORPHEUS_OISR);
	if (!(reg & IPS_MORPHEUS_OISR_CMD))
d684 4
a687 2
	while ((reg = IPS_READ_4(sc, IPS_MORPHEUS_OQPR)) != 0xffffffff) {
		id = (reg >> 8) & 0xff;
d689 1
a689 1
			DPRINTF(IPS_D_ERR, ("%s: intr, bogus id %d\n",
d691 2
a694 2
		DPRINTF(IPS_D_INTR, ("%s: intr, id %d\n",
		    sc->sc_dev.dv_xname, id));
d698 1
a698 1
			DPRINTF(IPS_D_ERR, ("%s: intr, ccb id %d not run\n",
d700 2
@


1.7
log
@The default debug level is ``error'' for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.6 2006/11/28 16:15:47 grange Exp $	*/
d27 1
d29 1
d186 1
d238 2
d537 2
d561 20
d699 1
d730 1
@


1.6
log
@Keep free ccbs in a queue.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.5 2006/11/28 14:28:39 grange Exp $	*/
d50 1
a50 1
int ips_debug = 0;
@


1.5
log
@Add some debug facility.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.4 2006/11/28 00:11:44 grange Exp $	*/
d28 1
d46 1
d178 4
a182 1
	int			c_run;
d184 2
d188 2
d212 1
d214 1
d301 1
a301 1
	int maxcmds;
d362 4
d473 1
d476 1
a476 2
	int i;
	struct ccb *ccb;
d478 10
a487 4
	for (i = 0; i < IPS_MAXCMDS; i++) {
		ccb = &sc->sc_ccb[i];
		if (!ccb->c_run)
			break;
d489 3
a491 1
	ccb->c_run = 1;
d511 1
a511 1
	cmd->id = i;
d532 1
d534 3
d645 2
d648 1
a648 4
	int id;
	struct scsi_xfer *xs;
	int s;
	struct ccb *ccb;
d656 8
d665 3
a667 1
		if (!ccb->c_run)
d669 3
d678 2
a680 1
		ccb->c_run = 0;
d683 1
a683 1
	return (1);
d697 1
@


1.4
log
@Pretend to implement SCSI SYNCHRONIZE_CACHE command.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.3 2006/11/27 23:56:38 grange Exp $	*/
d38 14
@


1.3
log
@Replace DMA operations with something less ugly. Still a lot of work remains.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.2 2006/11/27 17:31:36 grange Exp $	*/
d54 2
a57 1
#define IPS_CMD_ADAPTERINFO	0x05
d93 10
d210 1
d419 3
d510 12
@


1.2
log
@Properly enable enterrupts. Now I finally can newfs the whole drive.
@
text
@d1 1
a1 1
/*	$OpenBSD: ips.c,v 1.1 2006/11/27 16:47:05 grange Exp $	*/
d54 2
d68 3
d151 1
a152 1
	struct dmamem *		c_dm;
d178 1
a178 1
	struct ccb		sc_ccb[IPS_MAXCMDS];
d210 3
d264 1
a264 1
	int i;
a305 7
	for (i = 0; i < IPS_MAXCMDS; i++)
		if ((sc->sc_ccb[i].c_dm = ips_dmamem_alloc(sc->sc_dmat,
		    IPS_MAXDATASZ)) == NULL) {
			printf(": can't alloc ccb\n");
			goto fail2;
		}

d318 7
d328 1
a328 1
		goto fail2;
d337 1
a337 1
		goto fail2;
d356 2
d440 2
a441 2
	if (xs->flags & SCSI_DATA_OUT)
		memcpy(ccb->c_dm->dm_kva, xs->data, xs->datalen);
a460 1
	cmd->segnum = 0;
a461 1
	cmd->buffaddr = ccb->c_dm->dm_seg.ds_addr;
d463 16
a512 1
	(*sc->sc_intr)(sc);
a534 1
	(*sc->sc_intr)(sc);
d592 1
a593 2
		if (xs->flags & SCSI_DATA_IN)
			memcpy(xs->data, ccb->c_dm->dm_kva, xs->datalen);
d603 35
@


1.1
log
@IBM ServeRAID controllers driver.
Way far from complete but enough to fdisk and disklabel logical drives.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
d178 1
d198 1
d202 1
d267 1
d274 1
d333 3
d524 5
d539 10
@

