head	1.237;
access;
symbols
	OPENBSD_6_1:1.233.0.4
	OPENBSD_6_1_BASE:1.233
	OPENBSD_6_0:1.227.0.4
	OPENBSD_6_0_BASE:1.227
	OPENBSD_5_9:1.226.0.2
	OPENBSD_5_9_BASE:1.226
	OPENBSD_5_8:1.222.0.4
	OPENBSD_5_8_BASE:1.222
	OPENBSD_5_7:1.220.0.4
	OPENBSD_5_7_BASE:1.220
	OPENBSD_5_6:1.215.0.4
	OPENBSD_5_6_BASE:1.215
	OPENBSD_5_5:1.210.0.4
	OPENBSD_5_5_BASE:1.210
	OPENBSD_5_4:1.206.0.2
	OPENBSD_5_4_BASE:1.206
	OPENBSD_5_3:1.203.0.2
	OPENBSD_5_3_BASE:1.203
	OPENBSD_5_2:1.200.0.2
	OPENBSD_5_2_BASE:1.200
	OPENBSD_5_1_BASE:1.199
	OPENBSD_5_1:1.199.0.2
	OPENBSD_5_0:1.198.0.2
	OPENBSD_5_0_BASE:1.198
	OPENBSD_4_9:1.190.0.2
	OPENBSD_4_9_BASE:1.190
	OPENBSD_4_8:1.183.0.2
	OPENBSD_4_8_BASE:1.183
	OPENBSD_4_7:1.167.0.2
	OPENBSD_4_7_BASE:1.167
	OPENBSD_4_6:1.141.0.4
	OPENBSD_4_6_BASE:1.141
	OPENBSD_4_5:1.116.0.2
	OPENBSD_4_5_BASE:1.116
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_3:1.47.0.2
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_4:1.52.0.2
	OPENBSD_4_4_BASE:1.52;
locks; strict;
comment	@ * @;


1.237
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.236;
commitid	uRv5pa9QDlZaYgwD;

1.236
date	2017.08.10.15.25.52;	author tb;	state Exp;
branches;
next	1.235;
commitid	fG0akOsiW5DlqT17;

1.235
date	2017.04.11.14.43.49;	author dhill;	state Exp;
branches;
next	1.234;
commitid	zztPc3QpQPdWwQ6h;

1.234
date	2017.04.09.18.16.00;	author dhill;	state Exp;
branches;
next	1.233;
commitid	o5m0faA70n3VZuQ8;

1.233
date	2017.03.19.11.18.26;	author jsg;	state Exp;
branches;
next	1.232;
commitid	7VeKf0LhxRBue8ft;

1.232
date	2017.02.10.08.13.37;	author ratchov;	state Exp;
branches;
next	1.231;
commitid	hLv0QDRrFHRGUarq;

1.231
date	2017.01.10.00.36.25;	author jsg;	state Exp;
branches;
next	1.230;
commitid	Q8kSen7KNGrviFv9;

1.230
date	2016.12.08.17.23.33;	author ratchov;	state Exp;
branches;
next	1.229;
commitid	tfbLxmAUX5I27Hts;

1.229
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.228;
commitid	qGgYgJTgEFuAoGj4;

1.228
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.227;
commitid	pi1a9KN0itEngOc4;

1.227
date	2016.04.24.06.45.20;	author jsg;	state Exp;
branches;
next	1.226;
commitid	jhmqo9zpUSmMBMFQ;

1.226
date	2016.02.19.23.46.56;	author jsg;	state Exp;
branches;
next	1.225;
commitid	dMIPOWs0hbUXrfiS;

1.225
date	2015.12.17.15.07.57;	author ratchov;	state Exp;
branches;
next	1.224;
commitid	9PWix2SGzSItclnR;

1.224
date	2015.12.09.14.25.46;	author ratchov;	state Exp;
branches;
next	1.223;
commitid	8VeLIHtcTE9Wwc2x;

1.223
date	2015.12.07.03.04.45;	author jsg;	state Exp;
branches;
next	1.222;
commitid	LG8MTi9TY53pZwsi;

1.222
date	2015.07.29.08.06.29;	author ratchov;	state Exp;
branches;
next	1.221;
commitid	DRMZDGjr7hwhmxeW;

1.221
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.220;
commitid	RaOGL5SyOGOZylwx;

1.220
date	2015.02.10.06.19.44;	author dlg;	state Exp;
branches;
next	1.219;
commitid	HDjn5alZDsb5FRq5;

1.219
date	2015.01.20.09.46.31;	author ratchov;	state Exp;
branches;
next	1.218;
commitid	DYADDbUbZI9r60WX;

1.218
date	2015.01.13.01.54.19;	author jsg;	state Exp;
branches;
next	1.217;
commitid	9NP2Zvar6FuMYY2U;

1.217
date	2014.09.24.08.35.12;	author mpi;	state Exp;
branches;
next	1.216;
commitid	eVKYrJEBlSMUGiA3;

1.216
date	2014.08.13.07.45.37;	author jsg;	state Exp;
branches;
next	1.215;
commitid	YGAaJF68IQuYIJ8j;

1.215
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.214;
commitid	JtO5uXxVcnZfhUkR;

1.214
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.213;
commitid	OBNa5kfxQ2UXoiIw;

1.213
date	2014.07.10.14.21.20;	author deraadt;	state Exp;
branches;
next	1.212;
commitid	Jjzk0Y0KSLF2oro4;

1.212
date	2014.05.17.12.45.53;	author ratchov;	state Exp;
branches;
next	1.211;

1.211
date	2014.03.08.22.49.00;	author tedu;	state Exp;
branches;
next	1.210;

1.210
date	2014.02.25.18.40.37;	author kettenis;	state Exp;
branches;
next	1.209;

1.209
date	2013.12.30.10.53.30;	author jsg;	state Exp;
branches;
next	1.208;

1.208
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.207;

1.207
date	2013.11.09.05.51.11;	author jsg;	state Exp;
branches;
next	1.206;

1.206
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.205;

1.205
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.204;

1.204
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.203;

1.203
date	2013.02.09.21.02.17;	author miod;	state Exp;
branches;
next	1.202;

1.202
date	2012.10.19.15.20.42;	author deraadt;	state Exp;
branches;
next	1.201;

1.201
date	2012.08.12.19.32.22;	author kettenis;	state Exp;
branches;
next	1.200;

1.200
date	2012.05.10.22.46.48;	author ratchov;	state Exp;
branches;
next	1.199;

1.199
date	2011.09.19.07.36.59;	author kettenis;	state Exp;
branches;
next	1.198;

1.198
date	2011.07.03.15.47.16;	author matthew;	state Exp;
branches;
next	1.197;

1.197
date	2011.06.02.18.36.49;	author kettenis;	state Exp;
branches;
next	1.196;

1.196
date	2011.06.02.18.02.47;	author kettenis;	state Exp;
branches;
next	1.195;

1.195
date	2011.04.24.20.31.26;	author jakemsr;	state Exp;
branches;
next	1.194;

1.194
date	2011.04.10.17.10.08;	author jakemsr;	state Exp;
branches;
next	1.193;

1.193
date	2011.04.08.19.26.07;	author deraadt;	state Exp;
branches;
next	1.192;

1.192
date	2011.04.04.18.05.31;	author jakemsr;	state Exp;
branches;
next	1.191;

1.191
date	2011.03.04.22.04.21;	author jakemsr;	state Exp;
branches;
next	1.190;

1.190
date	2011.02.17.17.38.55;	author jakemsr;	state Exp;
branches;
next	1.189;

1.189
date	2011.02.17.16.02.22;	author jakemsr;	state Exp;
branches;
next	1.188;

1.188
date	2010.09.12.03.17.34;	author jakemsr;	state Exp;
branches;
next	1.187;

1.187
date	2010.09.12.02.35.10;	author jakemsr;	state Exp;
branches;
next	1.186;

1.186
date	2010.08.31.17.26.57;	author deraadt;	state Exp;
branches;
next	1.185;

1.185
date	2010.08.31.17.13.44;	author deraadt;	state Exp;
branches;
next	1.184;

1.184
date	2010.08.31.06.12.28;	author deraadt;	state Exp;
branches;
next	1.183;

1.183
date	2010.08.08.05.25.30;	author jakemsr;	state Exp;
branches;
next	1.182;

1.182
date	2010.08.08.04.10.25;	author deraadt;	state Exp;
branches;
next	1.181;

1.181
date	2010.08.07.20.52.36;	author jakemsr;	state Exp;
branches;
next	1.180;

1.180
date	2010.08.07.20.48.55;	author jakemsr;	state Exp;
branches;
next	1.179;

1.179
date	2010.08.06.05.57.48;	author jakemsr;	state Exp;
branches;
next	1.178;

1.178
date	2010.08.06.05.34.50;	author jakemsr;	state Exp;
branches;
next	1.177;

1.177
date	2010.08.06.04.43.20;	author jakemsr;	state Exp;
branches;
next	1.176;

1.176
date	2010.08.06.00.08.49;	author jakemsr;	state Exp;
branches;
next	1.175;

1.175
date	2010.07.29.01.39.03;	author jakemsr;	state Exp;
branches;
next	1.174;

1.174
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.173;

1.173
date	2010.06.27.21.47.07;	author jakemsr;	state Exp;
branches;
next	1.172;

1.172
date	2010.04.20.02.17.24;	author jakemsr;	state Exp;
branches;
next	1.171;

1.171
date	2010.04.04.20.07.45;	author kettenis;	state Exp;
branches;
next	1.170;

1.170
date	2010.04.03.14.40.09;	author kettenis;	state Exp;
branches;
next	1.169;

1.169
date	2010.03.25.03.40.47;	author jakemsr;	state Exp;
branches;
next	1.168;

1.168
date	2010.03.21.15.02.31;	author jakemsr;	state Exp;
branches;
next	1.167;

1.167
date	2010.03.16.08.28.22;	author jakemsr;	state Exp;
branches;
next	1.166;

1.166
date	2009.12.24.10.12.19;	author jakemsr;	state Exp;
branches;
next	1.165;

1.165
date	2009.12.22.08.48.14;	author jakemsr;	state Exp;
branches;
next	1.164;

1.164
date	2009.12.15.22.14.28;	author jakemsr;	state Exp;
branches;
next	1.163;

1.163
date	2009.12.15.21.22.04;	author jakemsr;	state Exp;
branches;
next	1.162;

1.162
date	2009.11.24.10.00.39;	author jakemsr;	state Exp;
branches;
next	1.161;

1.161
date	2009.11.23.22.33.21;	author pirofti;	state Exp;
branches;
next	1.160;

1.160
date	2009.11.11.23.12.39;	author jakemsr;	state Exp;
branches;
next	1.159;

1.159
date	2009.10.27.12.30.11;	author jakemsr;	state Exp;
branches;
next	1.158;

1.158
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.157;

1.157
date	2009.10.11.06.45.46;	author jakemsr;	state Exp;
branches;
next	1.156;

1.156
date	2009.10.11.00.59.37;	author jakemsr;	state Exp;
branches;
next	1.155;

1.155
date	2009.10.11.00.07.06;	author jakemsr;	state Exp;
branches;
next	1.154;

1.154
date	2009.10.08.01.57.44;	author jakemsr;	state Exp;
branches;
next	1.153;

1.153
date	2009.09.14.09.08.03;	author jakemsr;	state Exp;
branches;
next	1.152;

1.152
date	2009.09.12.09.21.28;	author jakemsr;	state Exp;
branches;
next	1.151;

1.151
date	2009.09.12.09.11.52;	author jakemsr;	state Exp;
branches;
next	1.150;

1.150
date	2009.09.10.22.59.46;	author jakemsr;	state Exp;
branches;
next	1.149;

1.149
date	2009.09.09.22.25.03;	author jakemsr;	state Exp;
branches;
next	1.148;

1.148
date	2009.09.09.07.16.50;	author jakemsr;	state Exp;
branches;
next	1.147;

1.147
date	2009.09.09.03.15.04;	author jakemsr;	state Exp;
branches;
next	1.146;

1.146
date	2009.09.09.02.13.35;	author jakemsr;	state Exp;
branches;
next	1.145;

1.145
date	2009.09.09.00.26.57;	author jakemsr;	state Exp;
branches;
next	1.144;

1.144
date	2009.09.08.23.30.17;	author jakemsr;	state Exp;
branches;
next	1.143;

1.143
date	2009.08.13.23.59.15;	author jakemsr;	state Exp;
branches;
next	1.142;

1.142
date	2009.08.12.09.59.35;	author martynas;	state Exp;
branches;
next	1.141;

1.141
date	2009.06.26.01.24.05;	author jakemsr;	state Exp;
branches;
next	1.140;

1.140
date	2009.06.18.08.19.03;	author jsg;	state Exp;
branches;
next	1.139;

1.139
date	2009.06.09.05.16.42;	author jakemsr;	state Exp;
branches;
next	1.138;

1.138
date	2009.06.09.05.05.48;	author jakemsr;	state Exp;
branches;
next	1.137;

1.137
date	2009.05.31.03.22.05;	author jakemsr;	state Exp;
branches;
next	1.136;

1.136
date	2009.05.31.02.57.51;	author jakemsr;	state Exp;
branches;
next	1.135;

1.135
date	2009.05.29.21.16.37;	author jakemsr;	state Exp;
branches;
next	1.134;

1.134
date	2009.05.29.17.54.08;	author jakemsr;	state Exp;
branches;
next	1.133;

1.133
date	2009.05.29.02.49.30;	author jakemsr;	state Exp;
branches;
next	1.132;

1.132
date	2009.05.29.02.38.01;	author jakemsr;	state Exp;
branches;
next	1.131;

1.131
date	2009.05.12.09.32.28;	author jakemsr;	state Exp;
branches;
next	1.130;

1.130
date	2009.05.01.04.00.40;	author jakemsr;	state Exp;
branches;
next	1.129;

1.129
date	2009.05.01.03.40.01;	author jakemsr;	state Exp;
branches;
next	1.128;

1.128
date	2009.05.01.02.45.30;	author jakemsr;	state Exp;
branches;
next	1.127;

1.127
date	2009.05.01.02.04.20;	author jakemsr;	state Exp;
branches;
next	1.126;

1.126
date	2009.04.27.23.49.04;	author jakemsr;	state Exp;
branches;
next	1.125;

1.125
date	2009.04.25.05.07.56;	author jakemsr;	state Exp;
branches;
next	1.124;

1.124
date	2009.04.25.05.02.40;	author jakemsr;	state Exp;
branches;
next	1.123;

1.123
date	2009.04.24.16.29.49;	author jakemsr;	state Exp;
branches;
next	1.122;

1.122
date	2009.04.24.16.27.38;	author jakemsr;	state Exp;
branches;
next	1.121;

1.121
date	2009.04.24.16.02.17;	author jakemsr;	state Exp;
branches;
next	1.120;

1.120
date	2009.04.24.15.37.12;	author jakemsr;	state Exp;
branches;
next	1.119;

1.119
date	2009.04.24.15.31.18;	author jakemsr;	state Exp;
branches;
next	1.118;

1.118
date	2009.04.24.15.07.57;	author jakemsr;	state Exp;
branches;
next	1.117;

1.117
date	2009.04.04.02.59.39;	author jakemsr;	state Exp;
branches;
next	1.116;

1.116
date	2009.02.05.01.25.21;	author oga;	state Exp;
branches;
next	1.115;

1.115
date	2009.01.16.23.12.28;	author jakemsr;	state Exp;
branches;
next	1.114;

1.114
date	2009.01.11.11.47.00;	author jakemsr;	state Exp;
branches;
next	1.113;

1.113
date	2009.01.11.11.32.48;	author jakemsr;	state Exp;
branches;
next	1.112;

1.112
date	2009.01.05.09.40.26;	author jakemsr;	state Exp;
branches;
next	1.111;

1.111
date	2009.01.05.08.50.06;	author jakemsr;	state Exp;
branches;
next	1.110;

1.110
date	2009.01.05.08.03.46;	author jakemsr;	state Exp;
branches;
next	1.109;

1.109
date	2009.01.04.23.42.39;	author jakemsr;	state Exp;
branches;
next	1.108;

1.108
date	2009.01.03.19.17.45;	author jakemsr;	state Exp;
branches;
next	1.107;

1.107
date	2009.01.02.22.32.25;	author jakemsr;	state Exp;
branches;
next	1.106;

1.106
date	2009.01.02.20.18.18;	author jakemsr;	state Exp;
branches;
next	1.105;

1.105
date	2009.01.02.00.25.33;	author jakemsr;	state Exp;
branches;
next	1.104;

1.104
date	2008.12.31.22.25.42;	author jakemsr;	state Exp;
branches;
next	1.103;

1.103
date	2008.12.31.12.54.43;	author jakemsr;	state Exp;
branches;
next	1.102;

1.102
date	2008.12.31.12.47.30;	author jakemsr;	state Exp;
branches;
next	1.101;

1.101
date	2008.12.31.11.54.55;	author jakemsr;	state Exp;
branches;
next	1.100;

1.100
date	2008.12.31.11.25.36;	author jakemsr;	state Exp;
branches;
next	1.99;

1.99
date	2008.12.31.11.23.55;	author jakemsr;	state Exp;
branches;
next	1.98;

1.98
date	2008.12.31.11.18.47;	author jakemsr;	state Exp;
branches;
next	1.97;

1.97
date	2008.12.30.08.57.26;	author jakemsr;	state Exp;
branches;
next	1.96;

1.96
date	2008.12.25.22.15.05;	author jakemsr;	state Exp;
branches;
next	1.95;

1.95
date	2008.12.25.00.58.15;	author jakemsr;	state Exp;
branches;
next	1.94;

1.94
date	2008.12.25.00.20.36;	author jakemsr;	state Exp;
branches;
next	1.93;

1.93
date	2008.12.23.09.33.49;	author jakemsr;	state Exp;
branches;
next	1.92;

1.92
date	2008.12.23.08.57.28;	author jakemsr;	state Exp;
branches;
next	1.91;

1.91
date	2008.12.23.04.12.19;	author jakemsr;	state Exp;
branches;
next	1.90;

1.90
date	2008.12.23.00.20.03;	author jakemsr;	state Exp;
branches;
next	1.89;

1.89
date	2008.12.23.00.03.16;	author jakemsr;	state Exp;
branches;
next	1.88;

1.88
date	2008.12.22.03.18.02;	author jakemsr;	state Exp;
branches;
next	1.87;

1.87
date	2008.12.22.03.00.17;	author jakemsr;	state Exp;
branches;
next	1.86;

1.86
date	2008.12.22.01.32.39;	author jakemsr;	state Exp;
branches;
next	1.85;

1.85
date	2008.12.22.00.03.08;	author jakemsr;	state Exp;
branches;
next	1.84;

1.84
date	2008.12.21.21.25.01;	author jakemsr;	state Exp;
branches;
next	1.83;

1.83
date	2008.12.21.20.47.55;	author jakemsr;	state Exp;
branches;
next	1.82;

1.82
date	2008.12.21.20.44.04;	author jakemsr;	state Exp;
branches;
next	1.81;

1.81
date	2008.12.21.20.32.46;	author jakemsr;	state Exp;
branches;
next	1.80;

1.80
date	2008.12.21.20.17.16;	author jakemsr;	state Exp;
branches;
next	1.79;

1.79
date	2008.11.30.20.06.41;	author jakemsr;	state Exp;
branches;
next	1.78;

1.78
date	2008.11.30.08.36.57;	author jakemsr;	state Exp;
branches;
next	1.77;

1.77
date	2008.11.30.03.50.29;	author jakemsr;	state Exp;
branches;
next	1.76;

1.76
date	2008.11.28.21.33.26;	author jakemsr;	state Exp;
branches;
next	1.75;

1.75
date	2008.11.27.23.30.58;	author jakemsr;	state Exp;
branches;
next	1.74;

1.74
date	2008.11.27.22.54.20;	author jakemsr;	state Exp;
branches;
next	1.73;

1.73
date	2008.11.19.03.44.14;	author jakemsr;	state Exp;
branches;
next	1.72;

1.72
date	2008.11.14.21.58.11;	author jakemsr;	state Exp;
branches;
next	1.71;

1.71
date	2008.11.05.04.08.24;	author brad;	state Exp;
branches;
next	1.70;

1.70
date	2008.11.05.03.20.34;	author jakemsr;	state Exp;
branches;
next	1.69;

1.69
date	2008.11.04.20.55.43;	author jakemsr;	state Exp;
branches;
next	1.68;

1.68
date	2008.11.04.20.48.14;	author jakemsr;	state Exp;
branches;
next	1.67;

1.67
date	2008.11.01.07.21.48;	author jakemsr;	state Exp;
branches;
next	1.66;

1.66
date	2008.10.31.21.39.50;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2008.10.31.06.52.15;	author jakemsr;	state Exp;
branches;
next	1.64;

1.64
date	2008.10.31.06.44.20;	author jakemsr;	state Exp;
branches;
next	1.63;

1.63
date	2008.10.31.06.40.12;	author jakemsr;	state Exp;
branches;
next	1.62;

1.62
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.61;

1.61
date	2008.10.23.02.06.53;	author jakemsr;	state Exp;
branches;
next	1.60;

1.60
date	2008.10.16.19.16.58;	author jakemsr;	state Exp;
branches;
next	1.59;

1.59
date	2008.10.12.10.42.38;	author jakemsr;	state Exp;
branches;
next	1.58;

1.58
date	2008.10.12.10.34.18;	author jakemsr;	state Exp;
branches;
next	1.57;

1.57
date	2008.10.10.22.40.22;	author brad;	state Exp;
branches;
next	1.56;

1.56
date	2008.10.10.14.00.46;	author jakemsr;	state Exp;
branches;
next	1.55;

1.55
date	2008.09.24.19.09.05;	author chl;	state Exp;
branches;
next	1.54;

1.54
date	2008.09.22.19.42.07;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2008.09.17.06.14.09;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.51;

1.51
date	2008.05.29.07.20.15;	author jakemsr;	state Exp;
branches;
next	1.50;

1.50
date	2008.05.13.02.24.08;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2008.04.28.08.57.08;	author brad;	state Exp;
branches;
next	1.48;

1.48
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.47;

1.47
date	2008.03.02.17.24.12;	author deanna;	state Exp;
branches;
next	1.46;

1.46
date	2007.12.16.18.46.43;	author deanna;	state Exp;
branches;
next	1.45;

1.45
date	2007.11.25.18.13.40;	author martynas;	state Exp;
branches;
next	1.44;

1.44
date	2007.11.23.18.34.00;	author deanna;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.16.20.36.25;	author deanna;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.14.22.51.37;	author deanna;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.14.05.39.41;	author deanna;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.03.19.52.56;	author deanna;	state Exp;
branches;
next	1.39;

1.39
date	2007.11.02.19.01.26;	author deanna;	state Exp;
branches;
next	1.38;

1.38
date	2007.10.28.21.32.51;	author deanna;	state Exp;
branches;
next	1.37;

1.37
date	2007.10.26.02.17.23;	author deanna;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.14.18.21.54;	author deanna;	state Exp;
branches;
next	1.35;

1.35
date	2007.10.10.03.39.21;	author deanna;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.10.22.37.08;	author deanna;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.10.22.11.17;	author deanna;	state Exp;
branches;
next	1.32;

1.32
date	2007.09.10.05.39.07;	author deanna;	state Exp;
branches;
next	1.31;

1.31
date	2007.09.10.05.30.14;	author deanna;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.06.22.47.46;	author deanna;	state Exp;
branches;
next	1.29;

1.29
date	2007.08.02.17.13.31;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.19.00.06.51;	author deanna;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.13.02.29.10;	author deanna;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.03.14.49.31;	author deanna;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.02.17.01.22;	author deanna;	state Exp;
branches;
next	1.24;

1.24
date	2006.09.21.09.52.45;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2006.07.21.20.41.51;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2006.07.20.02.06.17;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.30.17.15.04;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.30.16.51.50;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.28.08.23.06;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.25.00.45.00;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.21.05.17.48;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.17.18.33.27;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.16.08.03.42;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.16.06.00.46;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.14.20.24.12;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.14.19.34.52;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.07.18.19.20;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.06.22.15.53;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.11.23.34.35;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.08.20.36.59;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.08.04.18.43;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.08.04.11.31;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.08.03.59.09;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.08.03.52.37;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.08.03.28.46;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.26.15.53.08;	author jason;	state Exp;
branches;
next	;


desc
@@


1.237
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: azalia.c,v 1.236 2017/08/10 15:25:52 tb Exp $	*/
/*	$NetBSD: azalia.c,v 1.20 2006/05/07 08:31:44 kent Exp $	*/

/*-
 * Copyright (c) 2005 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by TAMURA Kent
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * High Definition Audio Specification
 *
 * http://www.intel.com/content/dam/www/public/us/en/documents/product-specifications/high-definition-audio-specification.pdf
 *
 *
 * TO DO:
 *  - multiple codecs (needed?)
 *  - multiple streams (needed?)
 */

#include <sys/param.h>
#include <sys/fcntl.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <dev/audio_if.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>

#include <dev/pci/azalia.h>

typedef struct audio_params audio_params_t;

struct audio_format {
	void *driver_data;
	int32_t mode;
	u_int encoding;
	u_int precision;
	u_int channels;

	/**
	 * 0: frequency[0] is lower limit, and frequency[1] is higher limit.
	 * 1-16: frequency[0] to frequency[frequency_type-1] are valid.
	 */
	u_int frequency_type;

#define	AUFMT_MAX_FREQUENCIES	16
	/**
	 * sampling rates
	 */
	u_int frequency[AUFMT_MAX_FREQUENCIES];
};


#ifdef AZALIA_DEBUG
# define DPRINTFN(n,x)	do { if (az_debug > (n)) printf x; } while (0/*CONSTCOND*/)
int az_debug = 0;
#else
# define DPRINTFN(n,x)	do {} while (0/*CONSTCOND*/)
#endif


/* ----------------------------------------------------------------
 * ICH6/ICH7 constant values
 * ---------------------------------------------------------------- */

/* PCI registers */
#define ICH_PCI_HDBARL	0x10
#define ICH_PCI_HDBARU	0x14
#define ICH_PCI_HDCTL	0x40
#define		ICH_PCI_HDCTL_CLKDETCLR		0x08
#define		ICH_PCI_HDCTL_CLKDETEN		0x04
#define		ICH_PCI_HDCTL_CLKDETINV		0x02
#define		ICH_PCI_HDCTL_SIGNALMODE	0x01
#define ICH_PCI_HDTCSEL	0x44
#define		ICH_PCI_HDTCSEL_MASK	0x7
#define ICH_PCI_MMC	0x62
#define		ICH_PCI_MMC_ME		0x1

/* internal types */

typedef struct {
	bus_dmamap_t map;
	caddr_t addr;		/* kernel virtual address */
	bus_dma_segment_t segments[1];
	size_t size;
} azalia_dma_t;
#define AZALIA_DMA_DMAADDR(p)	((p)->map->dm_segs[0].ds_addr)

typedef struct {
	struct azalia_t *az;
	int regbase;
	int number;
	int dir;		/* AUMODE_PLAY or AUMODE_RECORD */
	uint32_t intr_bit;
	azalia_dma_t bdlist;
	azalia_dma_t buffer;
	void (*intr)(void*);
	void *intr_arg;
	int bufsize;
	uint16_t fmt;
	int blk;
	unsigned int swpos;		/* position in the audio(4) layer */
} stream_t;
#define STR_READ_1(s, r)	\
	bus_space_read_1((s)->az->iot, (s)->az->ioh, (s)->regbase + HDA_SD_##r)
#define STR_READ_2(s, r)	\
	bus_space_read_2((s)->az->iot, (s)->az->ioh, (s)->regbase + HDA_SD_##r)
#define STR_READ_4(s, r)	\
	bus_space_read_4((s)->az->iot, (s)->az->ioh, (s)->regbase + HDA_SD_##r)
#define STR_WRITE_1(s, r, v)	\
	bus_space_write_1((s)->az->iot, (s)->az->ioh, (s)->regbase + HDA_SD_##r, v)
#define STR_WRITE_2(s, r, v)	\
	bus_space_write_2((s)->az->iot, (s)->az->ioh, (s)->regbase + HDA_SD_##r, v)
#define STR_WRITE_4(s, r, v)	\
	bus_space_write_4((s)->az->iot, (s)->az->ioh, (s)->regbase + HDA_SD_##r, v)

typedef struct azalia_t {
	struct device dev;

	pci_chipset_tag_t pc;
	pcitag_t tag;
	void *ih;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	bus_size_t map_size;
	bus_dma_tag_t dmat;
	pcireg_t pciid;
	uint32_t subid;

	codec_t *codecs;
	int ncodecs;		/* number of codecs */
	int codecno;		/* index of the using codec */
	int detached;		/* 1 if failed to initialize, 2 if
				 * azalia_pci_detach has run
				 */
	azalia_dma_t corb_dma;
	int corb_entries;
	uint8_t corbsize;
	azalia_dma_t rirb_dma;
	int rirb_entries;
	uint8_t rirbsize;
	int rirb_rp;
#define UNSOLQ_SIZE	256
	rirb_entry_t *unsolq;
	int unsolq_wp;
	int unsolq_rp;
	int unsolq_kick;
	struct timeout unsol_to;

	int ok64;
	int nistreams, nostreams, nbstreams;
	stream_t pstream;
	stream_t rstream;
} azalia_t;
#define XNAME(sc)		((sc)->dev.dv_xname)
#define AZ_READ_1(z, r)		bus_space_read_1((z)->iot, (z)->ioh, HDA_##r)
#define AZ_READ_2(z, r)		bus_space_read_2((z)->iot, (z)->ioh, HDA_##r)
#define AZ_READ_4(z, r)		bus_space_read_4((z)->iot, (z)->ioh, HDA_##r)
#define AZ_WRITE_1(z, r, v)	bus_space_write_1((z)->iot, (z)->ioh, HDA_##r, v)
#define AZ_WRITE_2(z, r, v)	bus_space_write_2((z)->iot, (z)->ioh, HDA_##r, v)
#define AZ_WRITE_4(z, r, v)	bus_space_write_4((z)->iot, (z)->ioh, HDA_##r, v)


/* prototypes */
uint8_t azalia_pci_read(pci_chipset_tag_t, pcitag_t, int);
void	azalia_pci_write(pci_chipset_tag_t, pcitag_t, int, uint8_t);
int	azalia_pci_match(struct device *, void *, void *);
void	azalia_pci_attach(struct device *, struct device *, void *);
int	azalia_pci_activate(struct device *, int);
int	azalia_pci_detach(struct device *, int);
void	azalia_configure_pci(azalia_t *);
int	azalia_intr(void *);
void	azalia_print_codec(codec_t *);
int	azalia_reset(azalia_t *);
int	azalia_get_ctrlr_caps(azalia_t *);
int	azalia_init(azalia_t *, int);
int	azalia_init_codecs(azalia_t *);
int	azalia_init_streams(azalia_t *);
void	azalia_shutdown(void *);
int	azalia_halt_corb(azalia_t *);
int	azalia_init_corb(azalia_t *, int);
int	azalia_halt_rirb(azalia_t *);
int	azalia_init_rirb(azalia_t *, int);
int	azalia_set_command(azalia_t *, nid_t, int, uint32_t, uint32_t);
int	azalia_get_response(azalia_t *, uint32_t *);
void	azalia_rirb_kick_unsol_events(void *);
void	azalia_rirb_intr(azalia_t *);
int	azalia_alloc_dmamem(azalia_t *, size_t, size_t, azalia_dma_t *);
int	azalia_free_dmamem(const azalia_t *, azalia_dma_t*);

int	azalia_codec_init(codec_t *);
int	azalia_codec_delete(codec_t *);
void	azalia_codec_add_bits(codec_t *, int, uint32_t, int);
void	azalia_codec_add_format(codec_t *, int, int, uint32_t, int32_t);
int	azalia_codec_connect_stream(stream_t *);
int	azalia_codec_disconnect_stream(stream_t *);
void	azalia_codec_print_audiofunc(const codec_t *);
void	azalia_codec_print_groups(const codec_t *);
int	azalia_codec_find_defdac(codec_t *, int, int);
int	azalia_codec_find_defadc(codec_t *, int, int);
int	azalia_codec_find_defadc_sub(codec_t *, nid_t, int, int);
int	azalia_codec_init_volgroups(codec_t *);
int	azalia_codec_sort_pins(codec_t *);
int	azalia_codec_select_micadc(codec_t *);
int	azalia_codec_select_dacs(codec_t *);
int	azalia_codec_select_spkrdac(codec_t *);
int	azalia_codec_find_inputmixer(codec_t *);

int	azalia_widget_init(widget_t *, const codec_t *, int);
int	azalia_widget_label_widgets(codec_t *);
int	azalia_widget_init_audio(widget_t *, const codec_t *);
int	azalia_widget_init_pin(widget_t *, const codec_t *);
int	azalia_widget_init_connection(widget_t *, const codec_t *);
int	azalia_widget_check_conn(codec_t *, int, int);
int	azalia_widget_sole_conn(codec_t *, nid_t);
void	azalia_widget_print_widget(const widget_t *, const codec_t *);
void	azalia_widget_print_audio(const widget_t *, const char *);
void	azalia_widget_print_pin(const widget_t *);

int	azalia_stream_init(stream_t *, azalia_t *, int, int, int);
int	azalia_stream_reset(stream_t *);
int	azalia_stream_start(stream_t *);
int	azalia_stream_halt(stream_t *);
int	azalia_stream_intr(stream_t *);

int	azalia_open(void *, int);
void	azalia_close(void *);
int	azalia_set_params(void *, int, int, audio_params_t *,
	audio_params_t *);
int	azalia_round_blocksize(void *, int);
int	azalia_halt_output(void *);
int	azalia_halt_input(void *);
int	azalia_set_port(void *, mixer_ctrl_t *);
int	azalia_get_port(void *, mixer_ctrl_t *);
int	azalia_query_devinfo(void *, mixer_devinfo_t *);
void	*azalia_allocm(void *, int, size_t, int, int);
void	azalia_freem(void *, void *, int);
size_t	azalia_round_buffersize(void *, int, size_t);
int	azalia_get_props(void *);
int	azalia_trigger_output(void *, void *, void *, int,
	void (*)(void *), void *, audio_params_t *);
int	azalia_trigger_input(void *, void *, void *, int,
	void (*)(void *), void *, audio_params_t *);

int	azalia_params2fmt(const audio_params_t *, uint16_t *);

int	azalia_match_format(codec_t *, int, audio_params_t *);
int	azalia_set_params_sub(codec_t *, int, audio_params_t *);

void	azalia_save_mixer(codec_t *);
void	azalia_restore_mixer(codec_t *);

int	azalia_suspend(azalia_t *);
int	azalia_resume(azalia_t *);
int	azalia_resume_codec(codec_t *);

/* variables */
struct cfattach azalia_ca = {
	sizeof(azalia_t), azalia_pci_match, azalia_pci_attach,
	azalia_pci_detach, azalia_pci_activate
};

struct cfdriver azalia_cd = {
	NULL, "azalia", DV_DULL
};

struct audio_hw_if azalia_hw_if = {
	azalia_open,
	azalia_close,
	azalia_set_params,
	azalia_round_blocksize,
	NULL,			/* commit_settings */
	NULL,			/* init_output */
	NULL,			/* init_input */
	NULL,			/* start_output */
	NULL,			/* start_input */
	azalia_halt_output,
	azalia_halt_input,
	NULL,			/* speaker_ctl */
	NULL,			/* setfd */
	azalia_set_port,
	azalia_get_port,
	azalia_query_devinfo,
	azalia_allocm,
	azalia_freem,
	azalia_round_buffersize,
	azalia_get_props,
	azalia_trigger_output,
	azalia_trigger_input
};

static const char *pin_devices[16] = {
	AudioNline, AudioNspeaker, AudioNheadphone, AudioNcd,
	"SPDIF", "digital-out", "modem-line", "modem-handset",
	"line-in", AudioNaux, AudioNmicrophone, "telephony",
	"SPDIF-in", "digital-in", "beep", "other"};
static const char *wtypes[16] = {
	"dac", "adc", "mix", "sel", "pin", "pow", "volume",
	"beep", "wid08", "wid09", "wid0a", "wid0b", "wid0c",
	"wid0d", "wid0e", "vendor"};
static const char *line_colors[16] = {
	"unk", "blk", "gry", "blu", "grn", "red", "org", "yel",
	"pur", "pnk", "0xa", "0xb", "0xc", "0xd", "wht", "oth"};

/* ================================================================
 * PCI functions
 * ================================================================ */

#define ATI_PCIE_SNOOP_REG		0x42
#define ATI_PCIE_SNOOP_MASK		0xf8
#define ATI_PCIE_SNOOP_ENABLE		0x02
#define NVIDIA_PCIE_SNOOP_REG		0x4e
#define NVIDIA_PCIE_SNOOP_MASK		0xf0
#define NVIDIA_PCIE_SNOOP_ENABLE	0x0f
#define NVIDIA_HDA_ISTR_COH_REG		0x4d
#define NVIDIA_HDA_OSTR_COH_REG		0x4c
#define NVIDIA_HDA_STR_COH_ENABLE	0x01
#define INTEL_PCIE_NOSNOOP_REG		0x79
#define INTEL_PCIE_NOSNOOP_MASK		0xf7
#define INTEL_PCIE_NOSNOOP_ENABLE	0x08

uint8_t
azalia_pci_read(pci_chipset_tag_t pc, pcitag_t pa, int reg)
{
	return (pci_conf_read(pc, pa, (reg & ~0x03)) >>
	    ((reg & 0x03) * 8) & 0xff);
}

void
azalia_pci_write(pci_chipset_tag_t pc, pcitag_t pa, int reg, uint8_t val)
{
	pcireg_t pcival;

	pcival = pci_conf_read(pc, pa, (reg & ~0x03));
	pcival &= ~(0xff << ((reg & 0x03) * 8));
	pcival |= (val << ((reg & 0x03) * 8));
	pci_conf_write(pc, pa, (reg & ~0x03), pcival);
}

void
azalia_configure_pci(azalia_t *az)
{
	pcireg_t v;
	uint8_t reg;

	/* enable back-to-back */
	v = pci_conf_read(az->pc, az->tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(az->pc, az->tag, PCI_COMMAND_STATUS_REG,
	    v | PCI_COMMAND_BACKTOBACK_ENABLE);

	/* traffic class select */
	v = pci_conf_read(az->pc, az->tag, ICH_PCI_HDTCSEL);
	pci_conf_write(az->pc, az->tag, ICH_PCI_HDTCSEL,
	    v & ~(ICH_PCI_HDTCSEL_MASK));

	/* enable PCIe snoop */
	switch (PCI_PRODUCT(az->pciid)) {
	case PCI_PRODUCT_ATI_SB450_HDA:
	case PCI_PRODUCT_ATI_SBX00_HDA:
	case PCI_PRODUCT_AMD_HUDSON2_HDA:
		reg = azalia_pci_read(az->pc, az->tag, ATI_PCIE_SNOOP_REG);
		reg &= ATI_PCIE_SNOOP_MASK;
		reg |= ATI_PCIE_SNOOP_ENABLE;
		azalia_pci_write(az->pc, az->tag, ATI_PCIE_SNOOP_REG, reg);
		break;
	case PCI_PRODUCT_NVIDIA_MCP51_HDA:
	case PCI_PRODUCT_NVIDIA_MCP55_HDA:
	case PCI_PRODUCT_NVIDIA_MCP61_HDA_1:
	case PCI_PRODUCT_NVIDIA_MCP61_HDA_2:
	case PCI_PRODUCT_NVIDIA_MCP65_HDA_1:
	case PCI_PRODUCT_NVIDIA_MCP65_HDA_2:
	case PCI_PRODUCT_NVIDIA_MCP67_HDA_1:
	case PCI_PRODUCT_NVIDIA_MCP67_HDA_2:
	case PCI_PRODUCT_NVIDIA_MCP73_HDA_1:
	case PCI_PRODUCT_NVIDIA_MCP73_HDA_2:
	case PCI_PRODUCT_NVIDIA_MCP77_HDA_1:
	case PCI_PRODUCT_NVIDIA_MCP77_HDA_2:
	case PCI_PRODUCT_NVIDIA_MCP77_HDA_3:
	case PCI_PRODUCT_NVIDIA_MCP77_HDA_4:
	case PCI_PRODUCT_NVIDIA_MCP79_HDA_1:
	case PCI_PRODUCT_NVIDIA_MCP79_HDA_2:
	case PCI_PRODUCT_NVIDIA_MCP79_HDA_3:
	case PCI_PRODUCT_NVIDIA_MCP79_HDA_4:
	case PCI_PRODUCT_NVIDIA_MCP89_HDA_1:
	case PCI_PRODUCT_NVIDIA_MCP89_HDA_2:
	case PCI_PRODUCT_NVIDIA_MCP89_HDA_3:
	case PCI_PRODUCT_NVIDIA_MCP89_HDA_4:
		reg = azalia_pci_read(az->pc, az->tag,
		    NVIDIA_HDA_OSTR_COH_REG);
		reg |= NVIDIA_HDA_STR_COH_ENABLE;
		azalia_pci_write(az->pc, az->tag,
		    NVIDIA_HDA_OSTR_COH_REG, reg);

		reg = azalia_pci_read(az->pc, az->tag,
		    NVIDIA_HDA_ISTR_COH_REG);
		reg |= NVIDIA_HDA_STR_COH_ENABLE;
		azalia_pci_write(az->pc, az->tag,
		    NVIDIA_HDA_ISTR_COH_REG, reg);

		reg = azalia_pci_read(az->pc, az->tag,
		    NVIDIA_PCIE_SNOOP_REG);
		reg &= NVIDIA_PCIE_SNOOP_MASK;
		reg |= NVIDIA_PCIE_SNOOP_ENABLE;
		azalia_pci_write(az->pc, az->tag,
		    NVIDIA_PCIE_SNOOP_REG, reg);

		reg = azalia_pci_read(az->pc, az->tag,
		    NVIDIA_PCIE_SNOOP_REG);
		if ((reg & NVIDIA_PCIE_SNOOP_ENABLE) !=
		    NVIDIA_PCIE_SNOOP_ENABLE) {
			printf(": could not enable PCIe cache snooping!\n");
		}
		break;
	case PCI_PRODUCT_INTEL_82801FB_HDA:
	case PCI_PRODUCT_INTEL_82801GB_HDA:
	case PCI_PRODUCT_INTEL_82801H_HDA:
	case PCI_PRODUCT_INTEL_82801I_HDA:
	case PCI_PRODUCT_INTEL_82801JI_HDA:
	case PCI_PRODUCT_INTEL_82801JD_HDA:
	case PCI_PRODUCT_INTEL_6321ESB_HDA:
	case PCI_PRODUCT_INTEL_3400_HDA:
	case PCI_PRODUCT_INTEL_QS57_HDA:
	case PCI_PRODUCT_INTEL_6SERIES_HDA:
	case PCI_PRODUCT_INTEL_7SERIES_HDA:
	case PCI_PRODUCT_INTEL_8SERIES_HDA:
	case PCI_PRODUCT_INTEL_8SERIES_LP_HDA:
	case PCI_PRODUCT_INTEL_9SERIES_HDA:
	case PCI_PRODUCT_INTEL_9SERIES_LP_HDA:
	case PCI_PRODUCT_INTEL_BAYTRAIL_HDA:
	case PCI_PRODUCT_INTEL_100SERIES_HDA:
	case PCI_PRODUCT_INTEL_100SERIES_LP_HDA:
	case PCI_PRODUCT_INTEL_200SERIES_U_HDA:
	case PCI_PRODUCT_INTEL_C600_HDA:
	case PCI_PRODUCT_INTEL_C610_HDA:
	case PCI_PRODUCT_INTEL_BSW_HDA:
		reg = azalia_pci_read(az->pc, az->tag,
		    INTEL_PCIE_NOSNOOP_REG);
		reg &= INTEL_PCIE_NOSNOOP_MASK;
		azalia_pci_write(az->pc, az->tag,
		    INTEL_PCIE_NOSNOOP_REG, reg);
		break;
	}
}

int
azalia_pci_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa;

	pa = aux;
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_MULTIMEDIA
	    && PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_MULTIMEDIA_HDAUDIO)
		return 1;
	return 0;
}

void
azalia_pci_attach(struct device *parent, struct device *self, void *aux)
{
	azalia_t *sc;
	struct pci_attach_args *pa;
	pcireg_t v;
	uint8_t reg;
	pci_intr_handle_t ih;
	const char *interrupt_str;

	sc = (azalia_t*)self;
	pa = aux;

	sc->dmat = pa->pa_dmat;

	pci_set_powerstate(pa->pa_pc, pa->pa_tag, PCI_PMCSR_STATE_D0);

	v = pci_conf_read(pa->pa_pc, pa->pa_tag, ICH_PCI_HDBARL);
	v &= PCI_MAPREG_TYPE_MASK | PCI_MAPREG_MEM_TYPE_MASK;
	if (pci_mapreg_map(pa, ICH_PCI_HDBARL, v, 0,
			   &sc->iot, &sc->ioh, NULL, &sc->map_size, 0)) {
		printf(": can't map device i/o space\n");
		return;
	}

	sc->pc = pa->pa_pc;
	sc->tag = pa->pa_tag;
	sc->pciid = pa->pa_id;
	sc->subid = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);

	azalia_configure_pci(sc);

	/* disable MSI, use INTx instead */
	if (PCI_VENDOR(sc->pciid) == PCI_VENDOR_INTEL) {
		reg = azalia_pci_read(sc->pc, sc->tag, ICH_PCI_MMC);
		reg &= ~(ICH_PCI_MMC_ME);
		azalia_pci_write(sc->pc, sc->tag, ICH_PCI_MMC, reg);
	}

	/* interrupt */
	if (pci_intr_map_msi(pa, &ih) && pci_intr_map(pa, &ih)) {
		printf(": can't map interrupt\n");
		return;
	}
	interrupt_str = pci_intr_string(pa->pa_pc, ih);
	sc->ih = pci_intr_establish(pa->pa_pc, ih, IPL_AUDIO | IPL_MPSAFE,
	    azalia_intr, sc, sc->dev.dv_xname);
	if (sc->ih == NULL) {
		printf(": can't establish interrupt");
		if (interrupt_str != NULL)
			printf(" at %s", interrupt_str);
		printf("\n");
		return;
	}
	printf(": %s\n", interrupt_str);

	if (azalia_init(sc, 0))
		goto err_exit;

	if (azalia_init_codecs(sc))
		goto err_exit;

	if (azalia_init_streams(sc))
		goto err_exit;

	audio_attach_mi(&azalia_hw_if, sc, &sc->dev);

	return;

err_exit:
	sc->detached = 1;
	azalia_pci_detach(self, 0);
}

int
azalia_pci_activate(struct device *self, int act)
{
	azalia_t *sc = (azalia_t*)self;
	int rv = 0; 

	switch (act) {
	case DVACT_SUSPEND:
		azalia_suspend(sc);
		break;
	case DVACT_POWERDOWN:
		azalia_shutdown(sc);
		break;
	case DVACT_RESUME:
		azalia_resume(sc);
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

int
azalia_pci_detach(struct device *self, int flags)
{
	azalia_t *az = (azalia_t*)self;
	uint32_t gctl;
	int i;

	DPRINTF(("%s\n", __func__));

	/*
	 * this function is called if the device could not be supported,
	 * in which case az->detached == 1.  check if this function has
	 * already cleaned up.
	 */
	if (az->detached > 1)
		return 0;

	config_detach_children(self, flags);

	/* disable unsolicited responses if soft detaching */
	if (az->detached == 1) {
		gctl = AZ_READ_4(az, GCTL);
		AZ_WRITE_4(az, GCTL, gctl &~(HDA_GCTL_UNSOL));
	}

	timeout_del(&az->unsol_to);

	DPRINTF(("%s: delete streams\n", __func__));
	if (az->rstream.bdlist.addr != NULL)
		azalia_free_dmamem(az, &az->rstream.bdlist);
	if (az->pstream.bdlist.addr != NULL)
		azalia_free_dmamem(az, &az->pstream.bdlist);

	DPRINTF(("%s: delete codecs\n", __func__));
	for (i = 0; i < az->ncodecs; i++) {
		azalia_codec_delete(&az->codecs[i]);
	}
	az->ncodecs = 0;
	if (az->codecs != NULL) {
		free(az->codecs, M_DEVBUF, 0);
		az->codecs = NULL;
	}

	DPRINTF(("%s: delete CORB and RIRB\n", __func__));
	if (az->corb_dma.addr != NULL)
		azalia_free_dmamem(az, &az->corb_dma);
	if (az->rirb_dma.addr != NULL)
		azalia_free_dmamem(az, &az->rirb_dma);
	if (az->unsolq != NULL) {
		free(az->unsolq, M_DEVBUF, 0);
		az->unsolq = NULL;
	}

	/* disable interrupts if soft detaching */
	if (az->detached == 1) {
		DPRINTF(("%s: disable interrupts\n", __func__));
		AZ_WRITE_4(az, INTCTL, 0);

		DPRINTF(("%s: clear interrupts\n", __func__));
		AZ_WRITE_4(az, INTSTS, HDA_INTSTS_CIS | HDA_INTSTS_GIS);
		AZ_WRITE_2(az, STATESTS, HDA_STATESTS_SDIWAKE);
		AZ_WRITE_1(az, RIRBSTS, HDA_RIRBSTS_RINTFL | HDA_RIRBSTS_RIRBOIS);
	}

	DPRINTF(("%s: delete PCI resources\n", __func__));
	if (az->ih != NULL) {
		pci_intr_disestablish(az->pc, az->ih);
		az->ih = NULL;
	}
	if (az->map_size != 0) {
		bus_space_unmap(az->iot, az->ioh, az->map_size);
		az->map_size = 0;
	}

	az->detached = 2;
	return 0;
}

int
azalia_intr(void *v)
{
	azalia_t *az = v;
	uint32_t intsts;
	int ret = 0;

	mtx_enter(&audio_lock);
	intsts = AZ_READ_4(az, INTSTS);
	if (intsts == 0 || intsts == 0xffffffff) {
		mtx_leave(&audio_lock);
		return (ret);
	}

	AZ_WRITE_4(az, INTSTS, intsts);

	if (intsts & az->pstream.intr_bit) {
		azalia_stream_intr(&az->pstream);
		ret = 1;
	}

	if (intsts & az->rstream.intr_bit) {
		azalia_stream_intr(&az->rstream);
		ret = 1;
	}

	if ((intsts & HDA_INTSTS_CIS) &&
	    (AZ_READ_1(az, RIRBCTL) & HDA_RIRBCTL_RINTCTL) &&
	    (AZ_READ_1(az, RIRBSTS) & HDA_RIRBSTS_RINTFL)) {
		azalia_rirb_intr(az);
		ret = 1;
	}
	mtx_leave(&audio_lock);
	return (ret);
}

void
azalia_shutdown(void *v)
{
	azalia_t *az = (azalia_t *)v;
	uint32_t gctl;
	codec_t *codec;
	int i;

	/* disable unsolicited response */
	gctl = AZ_READ_4(az, GCTL);
	AZ_WRITE_4(az, GCTL, gctl & ~(HDA_GCTL_UNSOL));

	timeout_del(&az->unsol_to);

	/* power off all codecs */
	for (i = 0; i < az->ncodecs; i++) {
		codec = &az->codecs[i];
		if (codec->audiofunc < 0)
			continue;
		azalia_comresp(codec, codec->audiofunc, CORB_SET_POWER_STATE,
		    CORB_PS_D3, NULL);
	}

	/* halt CORB/RIRB */
	azalia_halt_corb(az);
	azalia_halt_rirb(az);
}

/* ================================================================
 * HDA controller functions
 * ================================================================ */

void
azalia_print_codec(codec_t *codec)
{
	const char *vendor;

	if (codec->name == NULL) {
		vendor = pci_findvendor(codec->vid >> 16);
		if (vendor == NULL)
			printf("0x%04x/0x%04x",
			    codec->vid >> 16, codec->vid & 0xffff);
		else
			printf("%s/0x%04x", vendor, codec->vid & 0xffff);
	} else
		printf("%s", codec->name);
}

int
azalia_reset(azalia_t *az)
{
	uint32_t gctl;
	int i;

	/* 4.2.2 Starting the High Definition Audio Controller */
	DPRINTF(("%s: resetting\n", __func__));
	gctl = AZ_READ_4(az, GCTL);
	AZ_WRITE_4(az, GCTL, gctl & ~HDA_GCTL_CRST);
	for (i = 5000; i > 0; i--) {
		DELAY(10);
		if ((AZ_READ_4(az, GCTL) & HDA_GCTL_CRST) == 0)
			break;
	}
	DPRINTF(("%s: reset counter = %d\n", __func__, i));
	if (i == 0) {
		DPRINTF(("%s: reset failure\n", XNAME(az)));
		return(ETIMEDOUT);
	}
	DELAY(1000);
	gctl = AZ_READ_4(az, GCTL);
	AZ_WRITE_4(az, GCTL, gctl | HDA_GCTL_CRST);
	for (i = 5000; i > 0; i--) {
		DELAY(10);
		if (AZ_READ_4(az, GCTL) & HDA_GCTL_CRST)
			break;
	}
	DPRINTF(("%s: reset counter = %d\n", __func__, i));
	if (i == 0) {
		DPRINTF(("%s: reset-exit failure\n", XNAME(az)));
		return(ETIMEDOUT);
	}
	DELAY(1000);

	return(0);
}

int
azalia_get_ctrlr_caps(azalia_t *az)
{
	int i, n;
	uint16_t gcap;
	uint16_t statests;
	uint8_t cap;

	DPRINTF(("%s: host: High Definition Audio rev. %d.%d\n",
	    XNAME(az), AZ_READ_1(az, VMAJ), AZ_READ_1(az, VMIN)));
	gcap = AZ_READ_2(az, GCAP);
	az->nistreams = HDA_GCAP_ISS(gcap);
	az->nostreams = HDA_GCAP_OSS(gcap);
	az->nbstreams = HDA_GCAP_BSS(gcap);
	az->ok64 = (gcap & HDA_GCAP_64OK) != 0;
	DPRINTF(("%s: host: %d output, %d input, and %d bidi streams\n",
	    XNAME(az), az->nostreams, az->nistreams, az->nbstreams));

	/* 4.3 Codec discovery */
	statests = AZ_READ_2(az, STATESTS);
	for (i = 0, n = 0; i < HDA_MAX_CODECS; i++) {
		if ((statests >> i) & 1) {
			DPRINTF(("%s: found a codec at #%d\n", XNAME(az), i));
			n++;
		}
	}
	az->ncodecs = n;
	if (az->ncodecs < 1) {
		printf("%s: no HD-Audio codecs\n", XNAME(az));
		return -1;
	}
	az->codecs = mallocarray(az->ncodecs, sizeof(codec_t), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (az->codecs == NULL) {
		printf("%s: can't allocate memory for codecs\n", XNAME(az));
		return ENOMEM;
	}
	for (i = 0, n = 0; n < az->ncodecs; i++) {
		if ((statests >> i) & 1) {
			az->codecs[n].address = i;
			az->codecs[n++].az = az;
		}
	}

	/* determine CORB size */
	az->corbsize = AZ_READ_1(az, CORBSIZE);
	cap = az->corbsize & HDA_CORBSIZE_CORBSZCAP_MASK;
	az->corbsize  &= ~HDA_CORBSIZE_CORBSIZE_MASK;
	if (cap & HDA_CORBSIZE_CORBSZCAP_256) {
		az->corb_entries = 256;
		az->corbsize |= HDA_CORBSIZE_CORBSIZE_256;
	} else if (cap & HDA_CORBSIZE_CORBSZCAP_16) {
		az->corb_entries = 16;
		az->corbsize |= HDA_CORBSIZE_CORBSIZE_16;
	} else if (cap & HDA_CORBSIZE_CORBSZCAP_2) {
		az->corb_entries = 2;
		az->corbsize |= HDA_CORBSIZE_CORBSIZE_2;
	} else {
		printf("%s: invalid CORBSZCAP: 0x%2x\n", XNAME(az), cap);
		return(-1);
	}

	/* determine RIRB size */
	az->rirbsize = AZ_READ_1(az, RIRBSIZE);
	cap = az->rirbsize & HDA_RIRBSIZE_RIRBSZCAP_MASK;
	az->rirbsize &= ~HDA_RIRBSIZE_RIRBSIZE_MASK;
	if (cap & HDA_RIRBSIZE_RIRBSZCAP_256) {
		az->rirb_entries = 256;
		az->rirbsize |= HDA_RIRBSIZE_RIRBSIZE_256;
	} else if (cap & HDA_RIRBSIZE_RIRBSZCAP_16) {
		az->rirb_entries = 16;
		az->rirbsize |= HDA_RIRBSIZE_RIRBSIZE_16;
	} else if (cap & HDA_RIRBSIZE_RIRBSZCAP_2) {
		az->rirb_entries = 2;
		az->rirbsize |= HDA_RIRBSIZE_RIRBSIZE_2;
	} else {
		printf("%s: invalid RIRBSZCAP: 0x%2x\n", XNAME(az), cap);
		return(-1);
	}

	return(0);
}

int
azalia_init(azalia_t *az, int resuming)
{
	int err;

	err = azalia_reset(az);
	if (err)
		return(err);

	if (!resuming) {
		err = azalia_get_ctrlr_caps(az);
		if (err)
			return(err);
	}

	/* clear interrupt status */
	AZ_WRITE_2(az, STATESTS, HDA_STATESTS_SDIWAKE);
	AZ_WRITE_1(az, RIRBSTS, HDA_RIRBSTS_RINTFL | HDA_RIRBSTS_RIRBOIS);
	AZ_WRITE_4(az, INTSTS, HDA_INTSTS_CIS | HDA_INTSTS_GIS);
	AZ_WRITE_4(az, DPLBASE, 0);
	AZ_WRITE_4(az, DPUBASE, 0);

	/* 4.4.1 Command Outbound Ring Buffer */
	err = azalia_init_corb(az, resuming);
	if (err)
		return(err);

	/* 4.4.2 Response Inbound Ring Buffer */
	err = azalia_init_rirb(az, resuming);
	if (err)
		return(err);

	AZ_WRITE_4(az, INTCTL,
	    AZ_READ_4(az, INTCTL) | HDA_INTCTL_CIE | HDA_INTCTL_GIE);

	return(0);
}

int
azalia_init_codecs(azalia_t *az)
{
	codec_t *codec;
	int c, i;

	c = 0;
	for (i = 0; i < az->ncodecs; i++) {
		if (!azalia_codec_init(&az->codecs[i]))
			c++;
	}
	if (c == 0) {
		printf("%s: No codecs found\n", XNAME(az));
		return(1);
	}

	/* Use the first codec capable of analog I/O.  If there are none,
	 * use the first codec capable of digital I/O.  Skip HDMI codecs.
	 */
	c = -1;
	for (i = 0; i < az->ncodecs; i++) {
		codec = &az->codecs[i];
		if ((codec->audiofunc < 0) ||
		    (codec->codec_type == AZ_CODEC_TYPE_HDMI))
			continue;
		if (codec->codec_type == AZ_CODEC_TYPE_DIGITAL) {
			if (c < 0)
				c = i;
		} else {
			c = i;
			break;
		}
	}
	az->codecno = c;
	if (az->codecno < 0) {
		printf("%s: no supported codecs\n", XNAME(az));
		return(1);
	}

	printf("%s: codecs: ", XNAME(az));
	for (i = 0; i < az->ncodecs; i++) {
		azalia_print_codec(&az->codecs[i]);
		if (i < az->ncodecs - 1)
			printf(", ");
	}
	if (az->ncodecs > 1) {
		printf(", using ");
		azalia_print_codec(&az->codecs[az->codecno]);
	}
	printf("\n");

	/* All codecs with audio are enabled, but only one will be used. */
	for (i = 0; i < az->ncodecs; i++) {
		codec = &az->codecs[i];
		if (i != az->codecno) {
			if (codec->audiofunc < 0)
				continue;
			azalia_comresp(codec, codec->audiofunc,
			    CORB_SET_POWER_STATE, CORB_PS_D3, NULL);
			DELAY(100);
			azalia_codec_delete(codec);
		}
	}

	/* Enable unsolicited responses now that az->codecno is set. */
	AZ_WRITE_4(az, GCTL, AZ_READ_4(az, GCTL) | HDA_GCTL_UNSOL);

	return(0);
}

int
azalia_init_streams(azalia_t *az)
{
	int err;

	/* Use stream#1 and #2.  Don't use stream#0. */
	err = azalia_stream_init(&az->pstream, az, az->nistreams + 0,
	    1, AUMODE_PLAY);
	if (err)
		return(err);
	err = azalia_stream_init(&az->rstream, az, 0, 2, AUMODE_RECORD);
	if (err)
		return(err);

	return(0);
}

int
azalia_halt_corb(azalia_t *az)
{
	uint8_t corbctl;
	int i;

	corbctl = AZ_READ_1(az, CORBCTL);
	if (corbctl & HDA_CORBCTL_CORBRUN) { /* running? */
		AZ_WRITE_1(az, CORBCTL, corbctl & ~HDA_CORBCTL_CORBRUN);
		for (i = 5000; i > 0; i--) {
			DELAY(10);
			corbctl = AZ_READ_1(az, CORBCTL);
			if ((corbctl & HDA_CORBCTL_CORBRUN) == 0)
				break;
		}
		if (i == 0) {
			DPRINTF(("%s: CORB is running\n", XNAME(az)));
			return EBUSY;
		}
	}
	return(0);
}

int
azalia_init_corb(azalia_t *az, int resuming)
{
	int err, i;
	uint16_t corbrp, corbwp;
	uint8_t corbctl;

	err = azalia_halt_corb(az);
	if (err)
		return(err);

	if (!resuming) {
		err = azalia_alloc_dmamem(az,
		    az->corb_entries * sizeof(corb_entry_t), 128,
		    &az->corb_dma);
		if (err) {
			printf("%s: can't allocate CORB buffer\n", XNAME(az));
			return(err);
		}
		DPRINTF(("%s: CORB allocation succeeded.\n", __func__));
	}
	timeout_set(&az->unsol_to, azalia_rirb_kick_unsol_events, az);

	AZ_WRITE_4(az, CORBLBASE, (uint32_t)AZALIA_DMA_DMAADDR(&az->corb_dma));
	AZ_WRITE_4(az, CORBUBASE, PTR_UPPER32(AZALIA_DMA_DMAADDR(&az->corb_dma)));
	AZ_WRITE_1(az, CORBSIZE, az->corbsize);
 
	/* reset CORBRP */
	corbrp = AZ_READ_2(az, CORBRP);
	AZ_WRITE_2(az, CORBRP, corbrp | HDA_CORBRP_CORBRPRST);
	AZ_WRITE_2(az, CORBRP, corbrp & ~HDA_CORBRP_CORBRPRST);
	for (i = 5000; i > 0; i--) {
		DELAY(10);
		corbrp = AZ_READ_2(az, CORBRP);
		if ((corbrp & HDA_CORBRP_CORBRPRST) == 0)
			break;
	}
	if (i == 0) {
		DPRINTF(("%s: CORBRP reset failure\n", XNAME(az)));
		return -1;
	}
	DPRINTF(("%s: CORBWP=%d; size=%d\n", __func__,
		 AZ_READ_2(az, CORBRP) & HDA_CORBRP_CORBRP, az->corb_entries));

	/* clear CORBWP */
	corbwp = AZ_READ_2(az, CORBWP);
	AZ_WRITE_2(az, CORBWP, corbwp & ~HDA_CORBWP_CORBWP);

	/* Run! */
	corbctl = AZ_READ_1(az, CORBCTL);
	AZ_WRITE_1(az, CORBCTL, corbctl | HDA_CORBCTL_CORBRUN);
	return 0;
}

int
azalia_halt_rirb(azalia_t *az)
{
	int i;
	uint8_t rirbctl;

	rirbctl = AZ_READ_1(az, RIRBCTL);
	if (rirbctl & HDA_RIRBCTL_RIRBDMAEN) { /* running? */
		AZ_WRITE_1(az, RIRBCTL, rirbctl & ~HDA_RIRBCTL_RIRBDMAEN);
		for (i = 5000; i > 0; i--) {
			DELAY(10);
			rirbctl = AZ_READ_1(az, RIRBCTL);
			if ((rirbctl & HDA_RIRBCTL_RIRBDMAEN) == 0)
				break;
		}
		if (i == 0) {
			DPRINTF(("%s: RIRB is running\n", XNAME(az)));
			return(EBUSY);
		}
	}
	return(0);
}

int
azalia_init_rirb(azalia_t *az, int resuming)
{
	int err, i;
	uint16_t rirbwp;
	uint8_t rirbctl;

	err = azalia_halt_rirb(az);
	if (err)
		return(err);

	if (!resuming) {
		err = azalia_alloc_dmamem(az,
		    az->rirb_entries * sizeof(rirb_entry_t), 128,
		    &az->rirb_dma);
		if (err) {
			printf("%s: can't allocate RIRB buffer\n", XNAME(az));
			return err;
		}
		DPRINTF(("%s: RIRB allocation succeeded.\n", __func__));

		/* setup the unsolicited response queue */
		az->unsolq = malloc(sizeof(rirb_entry_t) * UNSOLQ_SIZE,
		    M_DEVBUF, M_NOWAIT | M_ZERO);
		if (az->unsolq == NULL) {
			DPRINTF(("%s: can't allocate unsolicited response queue.\n",
			    XNAME(az)));
			azalia_free_dmamem(az, &az->rirb_dma);
			return ENOMEM;
		}
	}
	AZ_WRITE_4(az, RIRBLBASE, (uint32_t)AZALIA_DMA_DMAADDR(&az->rirb_dma));
	AZ_WRITE_4(az, RIRBUBASE, PTR_UPPER32(AZALIA_DMA_DMAADDR(&az->rirb_dma)));
	AZ_WRITE_1(az, RIRBSIZE, az->rirbsize);

	/* reset the write pointer */
	rirbwp = AZ_READ_2(az, RIRBWP);
	AZ_WRITE_2(az, RIRBWP, rirbwp | HDA_RIRBWP_RIRBWPRST);

	/* clear the read pointer */
	az->rirb_rp = AZ_READ_2(az, RIRBWP) & HDA_RIRBWP_RIRBWP;
	DPRINTF(("%s: RIRBRP=%d, size=%d\n", __func__, az->rirb_rp,
	    az->rirb_entries));

	az->unsolq_rp = 0;
	az->unsolq_wp = 0;
	az->unsolq_kick = 0;

	AZ_WRITE_2(az, RINTCNT, 1);

	/* Run! */
	rirbctl = AZ_READ_1(az, RIRBCTL);
	AZ_WRITE_1(az, RIRBCTL, rirbctl |
	    HDA_RIRBCTL_RIRBDMAEN | HDA_RIRBCTL_RINTCTL);
	for (i = 5000; i > 0; i--) {
		DELAY(10);
		rirbctl = AZ_READ_1(az, RIRBCTL);
		if (rirbctl & HDA_RIRBCTL_RIRBDMAEN)
			break;
	}
	if (i == 0) {
		DPRINTF(("%s: RIRB is not running\n", XNAME(az)));
		return(EBUSY);
	}

	return (0);
}

int
azalia_comresp(const codec_t *codec, nid_t nid, uint32_t control,
    uint32_t param, uint32_t* result)
{
	int err;

	mtx_enter(&audio_lock);
	err = azalia_set_command(codec->az, codec->address, nid, control,
	    param);
	if (err)
		goto exit;
	err = azalia_get_response(codec->az, result);
exit:
	mtx_leave(&audio_lock);
	return(err);
}

int
azalia_set_command(azalia_t *az, int caddr, nid_t nid, uint32_t control,
    uint32_t param)
{
	corb_entry_t *corb;
	int  wp;
	uint32_t verb;
	uint16_t corbwp;

	if ((AZ_READ_1(az, CORBCTL) & HDA_CORBCTL_CORBRUN) == 0) {
		printf("%s: CORB is not running.\n", XNAME(az));
		return(-1);
	}
	verb = (caddr << 28) | (nid << 20) | (control << 8) | param;
	corbwp = AZ_READ_2(az, CORBWP);
	wp = corbwp & HDA_CORBWP_CORBWP;
	corb = (corb_entry_t*)az->corb_dma.addr;
	if (++wp >= az->corb_entries)
		wp = 0;
	corb[wp] = verb;

	AZ_WRITE_2(az, CORBWP, (corbwp & ~HDA_CORBWP_CORBWP) | wp);

	return(0);
}

int
azalia_get_response(azalia_t *az, uint32_t *result)
{
	const rirb_entry_t *rirb;
	int i;
	uint16_t wp;

	if ((AZ_READ_1(az, RIRBCTL) & HDA_RIRBCTL_RIRBDMAEN) == 0) {
		printf("%s: RIRB is not running.\n", XNAME(az));
		return(-1);
	}

	rirb = (rirb_entry_t*)az->rirb_dma.addr;
	i = 5000;
	for (;;) {
		while (i > 0) {
			wp = AZ_READ_2(az, RIRBWP) & HDA_RIRBWP_RIRBWP;
			if (az->rirb_rp != wp)
				break;
			DELAY(10);
			i--;
		}
		if (i == 0) {
			DPRINTF(("%s: RIRB time out\n", XNAME(az)));
			return(ETIMEDOUT);
		}
		if (++az->rirb_rp >= az->rirb_entries)
			az->rirb_rp = 0;
		if (rirb[az->rirb_rp].resp_ex & RIRB_RESP_UNSOL) {
			az->unsolq[az->unsolq_wp].resp = rirb[az->rirb_rp].resp;
			az->unsolq[az->unsolq_wp++].resp_ex = rirb[az->rirb_rp].resp_ex;
			az->unsolq_wp %= UNSOLQ_SIZE;
		} else
			break;
	}
	if (result != NULL)
		*result = rirb[az->rirb_rp].resp;

	return(0);
}

void
azalia_rirb_kick_unsol_events(void *v)
{
	azalia_t *az = v;
	int addr, tag;

	if (az->unsolq_kick)
		return;
	az->unsolq_kick = 1;
	while (az->unsolq_rp != az->unsolq_wp) {
		addr = RIRB_RESP_CODEC(az->unsolq[az->unsolq_rp].resp_ex);
		tag = RIRB_UNSOL_TAG(az->unsolq[az->unsolq_rp].resp);
		DPRINTF(("%s: codec address=%d tag=%d\n", __func__, addr, tag));

		az->unsolq_rp++;
		az->unsolq_rp %= UNSOLQ_SIZE;

		/* We only care about events on the using codec. */
		if (az->codecs[az->codecno].address == addr)
			azalia_unsol_event(&az->codecs[az->codecno], tag);
	}
	az->unsolq_kick = 0;
}

void
azalia_rirb_intr(azalia_t *az)
{
	const rirb_entry_t *rirb;
	uint16_t wp;
	uint8_t rirbsts;

	rirbsts = AZ_READ_1(az, RIRBSTS);

	wp = AZ_READ_2(az, RIRBWP) & HDA_RIRBWP_RIRBWP;
	rirb = (rirb_entry_t*)az->rirb_dma.addr;
	while (az->rirb_rp != wp) {
		if (++az->rirb_rp >= az->rirb_entries)
			az->rirb_rp = 0;
		if (rirb[az->rirb_rp].resp_ex & RIRB_RESP_UNSOL) {
			az->unsolq[az->unsolq_wp].resp = rirb[az->rirb_rp].resp;
			az->unsolq[az->unsolq_wp++].resp_ex = rirb[az->rirb_rp].resp_ex;
			az->unsolq_wp %= UNSOLQ_SIZE;
		} else {
			DPRINTF(("%s: dropped solicited response\n", __func__));
		}
	}
	timeout_add_msec(&az->unsol_to, 1);

	AZ_WRITE_1(az, RIRBSTS,
	    rirbsts | HDA_RIRBSTS_RIRBOIS | HDA_RIRBSTS_RINTFL);
}

int
azalia_alloc_dmamem(azalia_t *az, size_t size, size_t align, azalia_dma_t *d)
{
	int err;
	int nsegs;

	d->size = size;
	err = bus_dmamem_alloc(az->dmat, size, align, 0, d->segments, 1,
	    &nsegs, BUS_DMA_NOWAIT);
	if (err)
		return err;
	if (nsegs != 1)
		goto free;
	err = bus_dmamem_map(az->dmat, d->segments, 1, size,
	    &d->addr, BUS_DMA_NOWAIT | BUS_DMA_COHERENT);
	if (err)
		goto free;
	err = bus_dmamap_create(az->dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT, &d->map);
	if (err)
		goto unmap;
	err = bus_dmamap_load(az->dmat, d->map, d->addr, size,
	    NULL, BUS_DMA_NOWAIT);
	if (err)
		goto destroy;

	if (!az->ok64 && PTR_UPPER32(AZALIA_DMA_DMAADDR(d)) != 0) {
		azalia_free_dmamem(az, d);
		return -1;
	}
	return 0;

destroy:
	bus_dmamap_destroy(az->dmat, d->map);
unmap:
	bus_dmamem_unmap(az->dmat, d->addr, size);
free:
	bus_dmamem_free(az->dmat, d->segments, 1);
	d->addr = NULL;
	return err;
}

int
azalia_free_dmamem(const azalia_t *az, azalia_dma_t* d)
{
	if (d->addr == NULL)
		return 0;
	bus_dmamap_unload(az->dmat, d->map);
	bus_dmamap_destroy(az->dmat, d->map);
	bus_dmamem_unmap(az->dmat, d->addr, d->size);
	bus_dmamem_free(az->dmat, d->segments, 1);
	d->addr = NULL;
	return 0;
}

int
azalia_suspend(azalia_t *az)
{
	int err;

	if (az->detached)
		return 0;

	/* disable unsolicited responses */
	AZ_WRITE_4(az, GCTL, AZ_READ_4(az, GCTL) & ~HDA_GCTL_UNSOL);

	timeout_del(&az->unsol_to);

	azalia_save_mixer(&az->codecs[az->codecno]);
	/* azalia_halt_{corb,rirb}() only fail if the {CORB,RIRB} can't
	 * be stopped and azalia_init_{corb,rirb}(), which starts the
	 * {CORB,RIRB}, first calls azalia_halt_{corb,rirb}().  If halt
	 * fails, don't try to restart.
	 */
	err = azalia_halt_corb(az);
	if (err)
		goto corb_fail;

	err = azalia_halt_rirb(az);
	if (err)
		goto rirb_fail;

	/* stop interrupts and clear status registers */
	AZ_WRITE_4(az, INTCTL, 0);
	AZ_WRITE_4(az, INTSTS, HDA_INTSTS_CIS | HDA_INTSTS_GIS);
	AZ_WRITE_2(az, STATESTS, HDA_STATESTS_SDIWAKE);
	AZ_WRITE_1(az, RIRBSTS, HDA_RIRBSTS_RINTFL | HDA_RIRBSTS_RIRBOIS);

	return 0;

rirb_fail:
	azalia_init_corb(az, 1);
corb_fail:
	AZ_WRITE_4(az, GCTL, AZ_READ_4(az, GCTL) | HDA_GCTL_UNSOL);

	return err;
}

int
azalia_resume_codec(codec_t *this)
{
	widget_t *w;
	uint32_t result;
	int i, err;

	err = azalia_comresp(this, this->audiofunc, CORB_SET_POWER_STATE,
 	    CORB_PS_D0, &result);
	if (err) {
		DPRINTF(("%s: power audio func error: result=0x%8.8x\n",
		    __func__, result));
	}
	DELAY(100);

	FOR_EACH_WIDGET(this, i) {
		w = &this->w[i];
		if (w->widgetcap & COP_AWCAP_POWER) {
			azalia_comresp(this, w->nid, CORB_SET_POWER_STATE,
			    CORB_PS_D0, &result);
			DELAY(100);
		}
		if (w->type == COP_AWTYPE_PIN_COMPLEX)
			azalia_widget_init_pin(w, this);
		if (this->qrks & AZ_QRK_WID_MASK)
			azalia_codec_widget_quirks(this, w->nid);
	}

	if (this->qrks & AZ_QRK_GPIO_MASK) {
		err = azalia_codec_gpio_quirks(this);
		if (err)
			return err;
	}

	azalia_restore_mixer(this);

	return(0);
}

int
azalia_resume(azalia_t *az)
{
	int err;

	if (az->detached)
		return 0;

	azalia_configure_pci(az);

	/* is this necessary? */
	pci_conf_write(az->pc, az->tag, PCI_SUBSYS_ID_REG, az->subid);

	err = azalia_init(az, 1);
	if (err)
		return err;

	/* enable unsolicited responses on the controller */
	AZ_WRITE_4(az, GCTL, AZ_READ_4(az, GCTL) | HDA_GCTL_UNSOL);

	err = azalia_resume_codec(&az->codecs[az->codecno]);
	if (err)
		return err;

	err = azalia_codec_enable_unsol(&az->codecs[az->codecno]);
	if (err)
		return err;

	return 0;
}

void
azalia_save_mixer(codec_t *this)
{
	mixer_item_t *m;
	mixer_ctrl_t mc;
	int i;

	for (i = 0; i < this->nmixers; i++) {
		m = &this->mixers[i];
		if (m->nid == this->playvols.master)
			continue;
		mc.dev = i;
		mc.type = m->devinfo.type;
		azalia_mixer_get(this, m->nid, m->target, &mc);
		switch (mc.type) {
		case AUDIO_MIXER_ENUM:
			m->saved.ord = mc.un.ord;
			break;
		case AUDIO_MIXER_SET:
			m->saved.mask = mc.un.mask;
			break;
		case AUDIO_MIXER_VALUE:
			m->saved.value = mc.un.value;
			break;
		case AUDIO_MIXER_CLASS:
			break;
		default:
			DPRINTF(("%s: invalid mixer type in mixer %d\n",
			    __func__, mc.dev));
			break;
		}
	}
}

void
azalia_restore_mixer(codec_t *this)
{
	mixer_item_t *m;
	mixer_ctrl_t mc;
	int i;

	for (i = 0; i < this->nmixers; i++) {
		m = &this->mixers[i];
		if (m->nid == this->playvols.master)
			continue;
		mc.dev = i;
		mc.type = m->devinfo.type;
		switch (mc.type) {
		case AUDIO_MIXER_ENUM:
			mc.un.ord = m->saved.ord;
			break;
		case AUDIO_MIXER_SET:
			mc.un.mask = m->saved.mask; 
			break;
		case AUDIO_MIXER_VALUE:
			mc.un.value = m->saved.value;
			break;
		case AUDIO_MIXER_CLASS:
			break;
		default:
			DPRINTF(("%s: invalid mixer type in mixer %d\n",
			    __func__, mc.dev));
			continue;
		}
		azalia_mixer_set(this, m->nid, m->target, &mc);
	}
}

/* ================================================================
 * HDA codec functions
 * ================================================================ */

int
azalia_codec_init(codec_t *this)
{
	widget_t *w;
	uint32_t rev, id, result;
	int err, addr, n, i, nspdif, nhdmi;

	addr = this->address;
	/* codec vendor/device/revision */
	err = azalia_comresp(this, CORB_NID_ROOT, CORB_GET_PARAMETER,
	    COP_REVISION_ID, &rev);
	if (err)
		return err;
	err = azalia_comresp(this, CORB_NID_ROOT, CORB_GET_PARAMETER,
	    COP_VENDOR_ID, &id);
	if (err)
		return err;
	this->vid = id;
	this->subid = this->az->subid;
	azalia_codec_init_vtbl(this);
	DPRINTF(("%s: codec[%d] vid 0x%8.8x, subid 0x%8.8x, rev. %u.%u,",
	    XNAME(this->az), addr, this->vid, this->subid,
	    COP_RID_REVISION(rev), COP_RID_STEPPING(rev)));
	DPRINTF((" HDA version %u.%u\n",
	    COP_RID_MAJ(rev), COP_RID_MIN(rev)));

	/* identify function nodes */
	err = azalia_comresp(this, CORB_NID_ROOT, CORB_GET_PARAMETER,
	    COP_SUBORDINATE_NODE_COUNT, &result);
	if (err)
		return err;
	this->nfunctions = COP_NSUBNODES(result);
	if (COP_NSUBNODES(result) <= 0) {
		DPRINTF(("%s: codec[%d]: No function groups\n",
		    XNAME(this->az), addr));
		return -1;
	}
	/* iterate function nodes and find an audio function */
	n = COP_START_NID(result);
	DPRINTF(("%s: nidstart=%d #functions=%d\n",
	    XNAME(this->az), n, this->nfunctions));
	this->audiofunc = -1;
	for (i = 0; i < this->nfunctions; i++) {
		err = azalia_comresp(this, n + i, CORB_GET_PARAMETER,
		    COP_FUNCTION_GROUP_TYPE, &result);
		if (err)
			continue;
		DPRINTF(("%s: FTYPE result = 0x%8.8x\n", __func__, result));
		if (COP_FTYPE(result) == COP_FTYPE_AUDIO) {
			this->audiofunc = n + i;
			break;	/* XXX multiple audio functions? */
		}
	}
	if (this->audiofunc < 0) {
		DPRINTF(("%s: codec[%d]: No audio function groups\n",
		    XNAME(this->az), addr));
		return -1;
	}

	/* power the audio function */
	azalia_comresp(this, this->audiofunc, CORB_SET_POWER_STATE,
	    CORB_PS_D0, &result);
	DELAY(100);

	/* check widgets in the audio function */
	err = azalia_comresp(this, this->audiofunc, CORB_GET_PARAMETER,
	    COP_SUBORDINATE_NODE_COUNT, &result);
	if (err)
		return err;
	DPRINTF(("%s: There are %d widgets in the audio function.\n",
	   __func__, COP_NSUBNODES(result)));
	this->wstart = COP_START_NID(result);
	if (this->wstart < 2) {
		printf("%s: invalid node structure\n", XNAME(this->az));
		return -1;
	}
	this->wend = this->wstart + COP_NSUBNODES(result);
	this->w = mallocarray(this->wend, sizeof(widget_t), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (this->w == NULL) {
		printf("%s: out of memory\n", XNAME(this->az));
		return ENOMEM;
	}

	/* query the base parameters */
	azalia_comresp(this, this->audiofunc, CORB_GET_PARAMETER,
	    COP_STREAM_FORMATS, &result);
	this->w[this->audiofunc].d.audio.encodings = result;
	azalia_comresp(this, this->audiofunc, CORB_GET_PARAMETER,
	    COP_PCM, &result);
	this->w[this->audiofunc].d.audio.bits_rates = result;
	azalia_comresp(this, this->audiofunc, CORB_GET_PARAMETER,
	    COP_INPUT_AMPCAP, &result);
	this->w[this->audiofunc].inamp_cap = result;
	azalia_comresp(this, this->audiofunc, CORB_GET_PARAMETER,
	    COP_OUTPUT_AMPCAP, &result);
	this->w[this->audiofunc].outamp_cap = result;

	azalia_codec_print_audiofunc(this);

	strlcpy(this->w[CORB_NID_ROOT].name, "root",
	    sizeof(this->w[CORB_NID_ROOT].name));
	strlcpy(this->w[this->audiofunc].name, "hdaudio",
	    sizeof(this->w[this->audiofunc].name));
	this->w[this->audiofunc].enable = 1;

	FOR_EACH_WIDGET(this, i) {
		w = &this->w[i];
		err = azalia_widget_init(w, this, i);
		if (err)
			return err;
		err = azalia_widget_init_connection(w, this);
		if (err)
			return err;

		azalia_widget_print_widget(w, this);

		if (this->qrks & AZ_QRK_WID_MASK) {
			azalia_codec_widget_quirks(this, i);
		}
	}

	this->na_dacs = this->na_dacs_d = 0;
	this->na_adcs = this->na_adcs_d = 0;
	this->speaker = this->speaker2 = this->spkr_dac =
	    this->fhp = this->fhp_dac =
	    this->mic = this->mic_adc = -1;
	this->nsense_pins = 0;
	this->nout_jacks = 0;
	nspdif = nhdmi = 0;
	FOR_EACH_WIDGET(this, i) {
		w = &this->w[i];

		if (!w->enable)
			continue;

		switch (w->type) {

		case COP_AWTYPE_AUDIO_MIXER:
		case COP_AWTYPE_AUDIO_SELECTOR:
			if (!azalia_widget_check_conn(this, i, 0))
				w->enable = 0;
			break;

		case COP_AWTYPE_AUDIO_OUTPUT:
			if ((w->widgetcap & COP_AWCAP_DIGITAL) == 0) {
				if (this->na_dacs < HDA_MAX_CHANNELS)
					this->a_dacs[this->na_dacs++] = i;
			} else {
				if (this->na_dacs_d < HDA_MAX_CHANNELS)
					this->a_dacs_d[this->na_dacs_d++] = i;
			}
			break;

		case COP_AWTYPE_AUDIO_INPUT:
			if ((w->widgetcap & COP_AWCAP_DIGITAL) == 0) {
				if (this->na_adcs < HDA_MAX_CHANNELS)
					this->a_adcs[this->na_adcs++] = i;
			} else {
				if (this->na_adcs_d < HDA_MAX_CHANNELS)
					this->a_adcs_d[this->na_adcs_d++] = i;
			}
			break;

		case COP_AWTYPE_PIN_COMPLEX:
			switch (CORB_CD_PORT(w->d.pin.config)) {
			case CORB_CD_FIXED:
				switch (w->d.pin.device) {
				case CORB_CD_SPEAKER:
					if (this->speaker == -1) {
						this->speaker = i;
					} else if (w->d.pin.association <
					    this->w[this->speaker].d.pin.association ||
					    (w->d.pin.association ==
					    this->w[this->speaker].d.pin.association &&
					    w->d.pin.sequence <
					    this->w[this->speaker].d.pin.sequence)) {
						this->speaker2 = this->speaker;
						this->speaker = i;
					} else {
						this->speaker2 = i;
					}
					if (this->speaker == i)
						this->spkr_dac =
						    azalia_codec_find_defdac(this, i, 0);
					break;
				case CORB_CD_MICIN:
					this->mic = i;
					this->mic_adc =
					    azalia_codec_find_defadc(this, i, 0);
					break;
				}
				break;
			case CORB_CD_JACK:
				if (w->d.pin.device == CORB_CD_LINEOUT)
					this->nout_jacks++;
				else if (w->d.pin.device == CORB_CD_HEADPHONE &&
				    CORB_CD_LOC_GEO(w->d.pin.config) ==
				    CORB_CD_FRONT) {
					this->fhp = i;
					this->fhp_dac =
					    azalia_codec_find_defdac(this, i, 0);
				}
				if (this->nsense_pins >= HDA_MAX_SENSE_PINS ||
				    !(w->d.pin.cap & COP_PINCAP_PRESENCE))
					break;
				/* check override bit */
				err = azalia_comresp(this, i,
				    CORB_GET_CONFIGURATION_DEFAULT, 0, &result);
				if (err)
					break;
				if (!(CORB_CD_MISC(result) & CORB_CD_PRESENCEOV)) {
					this->sense_pins[this->nsense_pins++] = i;
				}
				break;
			}
			if ((w->d.pin.device == CORB_CD_DIGITALOUT) &&
			    (w->d.pin.cap & COP_PINCAP_HDMI))
				nhdmi++;
			else if (w->d.pin.device == CORB_CD_SPDIFOUT ||
			    w->d.pin.device == CORB_CD_SPDIFIN)
				nspdif++;
			break;
		}
	}
	this->codec_type = AZ_CODEC_TYPE_ANALOG;
	if ((this->na_dacs == 0) && (this->na_adcs == 0)) {
		this->codec_type = AZ_CODEC_TYPE_DIGITAL;
		if (nspdif == 0 && nhdmi > 0)
			this->codec_type = AZ_CODEC_TYPE_HDMI;
	}

	/* make sure built-in mic is connected to an adc */
	if (this->mic != -1 && this->mic_adc == -1) {
		if (azalia_codec_select_micadc(this)) {
			DPRINTF(("%s: cound not select mic adc\n", __func__));
		}
	}

	err = azalia_codec_sort_pins(this);
	if (err)
		return err;

	err = azalia_codec_find_inputmixer(this);
	if (err)
		return err;

	/* If the codec can do multichannel, select different DACs for
	 * the multichannel jack group.  Also be sure to keep track of
	 * which DAC the front headphone is connected to.
	 */
	if (this->na_dacs >= 3 && this->nopins >= 3) {
		err = azalia_codec_select_dacs(this);
		if (err)
			return err;
	}

	err = azalia_codec_select_spkrdac(this);
	if (err)
		return err;

	err = azalia_init_dacgroup(this);
	if (err)
		return err;

	azalia_codec_print_groups(this);

	err = azalia_widget_label_widgets(this);
	if (err)
		return err;

	err = azalia_codec_construct_format(this, 0, 0);
	if (err)
		return err;

	err = azalia_codec_init_volgroups(this);
	if (err)
		return err;

	if (this->qrks & AZ_QRK_GPIO_MASK) {
		err = azalia_codec_gpio_quirks(this);
		if (err)
			return err;
	}

	err = azalia_mixer_init(this);
	if (err)
		return err;

	return 0;
}

int
azalia_codec_find_inputmixer(codec_t *this)
{
	widget_t *w;
	int i, j;

	this->input_mixer = -1;

	FOR_EACH_WIDGET(this, i) {
		w = &this->w[i];
		if (w->type != COP_AWTYPE_AUDIO_MIXER)
			continue;

		/* can input from a pin */
		for (j = 0; j < this->nipins; j++) {
			if (azalia_codec_fnode(this, this->ipins[j].nid,
			    w->nid, 0) != -1)
				break;
		}
		if (j == this->nipins)
			continue;

		/* can output to a pin */
		for (j = 0; j < this->nopins; j++) {
			if (azalia_codec_fnode(this, w->nid,
			    this->opins[j].nid, 0) != -1)
				break;
		}
		if (j == this->nopins)
			continue;

		/* can output to an ADC */
		for (j = 0; j < this->na_adcs; j++) {
			if (azalia_codec_fnode(this, w->nid,
			    this->a_adcs[j], 0) != -1)
				break;
		}
		if (j == this->na_adcs)
			continue;

		this->input_mixer = i;
		break;
	}
	return(0);
}

int
azalia_codec_select_micadc(codec_t *this)
{
	widget_t *w;
	int i, j, conv, err;

	for (i = 0; i < this->na_adcs; i++) {
		if (azalia_codec_fnode(this, this->mic,
		    this->a_adcs[i], 0) >= 0)
			break;
	}
	if (i >= this->na_adcs)
		return(-1);
	conv = this->a_adcs[i];

	w = &this->w[conv];
	for (j = 0; j < 10; j++) {
		for (i = 0; i < w->nconnections; i++) {
			if (!azalia_widget_enabled(this, w->connections[i]))
				continue;
			if (azalia_codec_fnode(this, this->mic,
			    w->connections[i], j + 1) >= 0) {
				break;
			}
		}
		if (i >= w->nconnections)
			return(-1);
		err = azalia_comresp(this, w->nid,
		    CORB_SET_CONNECTION_SELECT_CONTROL, i, 0);
		if (err)
			return(err);
		w->selected = i;
		if (w->connections[i] == this->mic) {
			this->mic_adc = conv;
			return(0);
		}
		w = &this->w[w->connections[i]];
	}
	return(-1);
}

int
azalia_codec_sort_pins(codec_t *this)
{
#define MAX_PINS	16
	const widget_t *w;
	struct io_pin opins[MAX_PINS], opins_d[MAX_PINS];
	struct io_pin ipins[MAX_PINS], ipins_d[MAX_PINS];
	int nopins, nopins_d, nipins, nipins_d;
	int prio, loc, add, nd, conv;
	int i, j, k;

	nopins = nopins_d = nipins = nipins_d = 0;

	FOR_EACH_WIDGET(this, i) {
		w = &this->w[i];
		if (!w->enable || w->type != COP_AWTYPE_PIN_COMPLEX)
			continue;

		loc = 0;
		if (this->na_dacs >= 3 && this->nout_jacks < 3)
			loc = CORB_CD_LOC_GEO(w->d.pin.config);

		prio = w->d.pin.association << 4 | w->d.pin.sequence;
		conv = -1;

		/* analog out */
		if ((w->d.pin.cap & COP_PINCAP_OUTPUT) && 
		    !(w->widgetcap & COP_AWCAP_DIGITAL)) {
			add = nd = 0;
			conv = azalia_codec_find_defdac(this, w->nid, 0);
			switch(w->d.pin.device) {
			/* primary - output by default */
			case CORB_CD_SPEAKER:
				if (w->nid == this->speaker ||
				    w->nid == this->speaker2)
					break;
				/* FALLTHROUGH */
			case CORB_CD_HEADPHONE:
			case CORB_CD_LINEOUT:
				add = 1;
				break;
			/* secondary - input by default */
			case CORB_CD_MICIN:
				if (w->nid == this->mic)
					break;
				/* FALLTHROUGH */
			case CORB_CD_LINEIN:
				add = nd = 1;
				break;
			}
			if (add && nopins < MAX_PINS) {
				opins[nopins].nid = w->nid;
				opins[nopins].conv = conv;
				prio |= (nd << 8) | (loc << 9);
				opins[nopins].prio = prio;
				nopins++;
			}
		}
		/* digital out */
		if ((w->d.pin.cap & COP_PINCAP_OUTPUT) && 
		    (w->widgetcap & COP_AWCAP_DIGITAL)) {
			conv = azalia_codec_find_defdac(this, w->nid, 0);
			switch(w->d.pin.device) {
			case CORB_CD_SPDIFOUT:
			case CORB_CD_DIGITALOUT:
				if (nopins_d < MAX_PINS) {
					opins_d[nopins_d].nid = w->nid;
					opins_d[nopins_d].conv = conv;
					opins_d[nopins_d].prio = prio;
					nopins_d++;
				}
				break;
			}
		}
		/* analog in */
		if ((w->d.pin.cap & COP_PINCAP_INPUT) &&
		    !(w->widgetcap & COP_AWCAP_DIGITAL)) {
			add = nd = 0;
			conv = azalia_codec_find_defadc(this, w->nid, 0);
			switch(w->d.pin.device) {
			/* primary - input by default */
			case CORB_CD_MICIN:
			case CORB_CD_LINEIN:
				add = 1;
				break;
			/* secondary - output by default */
			case CORB_CD_SPEAKER:
				if (w->nid == this->speaker ||
				    w->nid == this->speaker2)
					break;
				/* FALLTHROUGH */
			case CORB_CD_HEADPHONE:
			case CORB_CD_LINEOUT:
				add = nd = 1;
				break;
			}
			if (add && nipins < MAX_PINS) {
				ipins[nipins].nid = w->nid;
				ipins[nipins].prio = prio | (nd << 8);
				ipins[nipins].conv = conv;
				nipins++;
			}
		}
		/* digital in */
		if ((w->d.pin.cap & COP_PINCAP_INPUT) && 
		    (w->widgetcap & COP_AWCAP_DIGITAL)) {
			conv = azalia_codec_find_defadc(this, w->nid, 0);
			switch(w->d.pin.device) {
			case CORB_CD_SPDIFIN:
			case CORB_CD_DIGITALIN:
			case CORB_CD_MICIN:
				if (nipins_d < MAX_PINS) {
					ipins_d[nipins_d].nid = w->nid;
					ipins_d[nipins_d].prio = prio;
					ipins_d[nipins_d].conv = conv;
					nipins_d++;
				}
				break;
			}
		}
	}

	this->opins = mallocarray(nopins, sizeof(struct io_pin), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (this->opins == NULL)
		return(ENOMEM);
	this->nopins = 0;
	for (i = 0; i < nopins; i++) {
		for (j = 0; j < this->nopins; j++)
			if (this->opins[j].prio > opins[i].prio)
				break;
		for (k = this->nopins; k > j; k--)
			this->opins[k] = this->opins[k - 1];
		if (j < nopins)
			this->opins[j] = opins[i];
		this->nopins++;
		if (this->nopins == nopins)
			break;
	}

	this->opins_d = mallocarray(nopins_d, sizeof(struct io_pin), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (this->opins_d == NULL)
		return(ENOMEM);
	this->nopins_d = 0;
	for (i = 0; i < nopins_d; i++) {
		for (j = 0; j < this->nopins_d; j++)
			if (this->opins_d[j].prio > opins_d[i].prio)
				break;
		for (k = this->nopins_d; k > j; k--)
			this->opins_d[k] = this->opins_d[k - 1];
		if (j < nopins_d)
			this->opins_d[j] = opins_d[i];
		this->nopins_d++;
		if (this->nopins_d == nopins_d)
			break;
	}

	this->ipins = mallocarray(nipins, sizeof(struct io_pin), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (this->ipins == NULL)
		return(ENOMEM);
	this->nipins = 0;
	for (i = 0; i < nipins; i++) {
		for (j = 0; j < this->nipins; j++)
			if (this->ipins[j].prio > ipins[i].prio)
				break;
		for (k = this->nipins; k > j; k--)
			this->ipins[k] = this->ipins[k - 1];
		if (j < nipins)
			this->ipins[j] = ipins[i];
		this->nipins++;
		if (this->nipins == nipins)
			break;
	}

	this->ipins_d = mallocarray(nipins_d, sizeof(struct io_pin), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (this->ipins_d == NULL)
		return(ENOMEM);
	this->nipins_d = 0;
	for (i = 0; i < nipins_d; i++) {
		for (j = 0; j < this->nipins_d; j++)
			if (this->ipins_d[j].prio > ipins_d[i].prio)
				break;
		for (k = this->nipins_d; k > j; k--)
			this->ipins_d[k] = this->ipins_d[k - 1];
		if (j < nipins_d)
			this->ipins_d[j] = ipins_d[i];
		this->nipins_d++;
		if (this->nipins_d == nipins_d)
			break;
	}

#ifdef AZALIA_DEBUG
	printf("%s: analog out pins:", __func__);
	for (i = 0; i < this->nopins; i++)
		printf(" 0x%2.2x->0x%2.2x", this->opins[i].nid,
		    this->opins[i].conv);
	printf("\n");
	printf("%s: digital out pins:", __func__);
	for (i = 0; i < this->nopins_d; i++)
		printf(" 0x%2.2x->0x%2.2x", this->opins_d[i].nid,
		    this->opins_d[i].conv);
	printf("\n");
	printf("%s: analog in pins:", __func__);
	for (i = 0; i < this->nipins; i++)
		printf(" 0x%2.2x->0x%2.2x", this->ipins[i].nid,
		    this->ipins[i].conv);
	printf("\n");
	printf("%s: digital in pins:", __func__);
	for (i = 0; i < this->nipins_d; i++)
		printf(" 0x%2.2x->0x%2.2x", this->ipins_d[i].nid,
		    this->ipins_d[i].conv);
	printf("\n");
#endif

	return 0;
#undef MAX_PINS
}

int
azalia_codec_select_dacs(codec_t *this)
{
	widget_t *w;
	nid_t *convs;
	int nconv, conv;
	int i, j, k, err;

	convs = mallocarray(this->na_dacs, sizeof(nid_t), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (convs == NULL)
		return(ENOMEM);

	err = 0;
	nconv = 0;
	for (i = 0; i < this->nopins; i++) {
		w = &this->w[this->opins[i].nid];

		conv = this->opins[i].conv;
		for (j = 0; j < nconv; j++) {
			if (conv == convs[j])
				break;
		}
		if (j == nconv) {
			convs[nconv++] = conv;
			if (w->nid == this->fhp)
				this->fhp_dac = conv;
			if (nconv >= this->na_dacs) {
				break;
			}
		} else {
			/* find a different dac */
			conv = -1;
			for (j = 0; j < w->nconnections; j++) {
				if (!azalia_widget_enabled(this,
				    w->connections[j]))
					continue;
				conv = azalia_codec_find_defdac(this,
				    w->connections[j], 1);
				if (conv == -1)
					continue;
				for (k = 0; k < nconv; k++) {
					if (conv == convs[k])
						break;
				}
				if (k == nconv)
					break;
			}
			if (j < w->nconnections && conv != -1) {
				err = azalia_comresp(this, w->nid,
				    CORB_SET_CONNECTION_SELECT_CONTROL, j, 0);
				if (err)
					break;
				w->selected = j;
				this->opins[i].conv = conv;
				if (w->nid == this->fhp)
					this->fhp_dac = conv;
				convs[nconv++] = conv;
				if (nconv >= this->na_dacs)
					break;
			}
		}
	}

	free(convs, M_DEVBUF, 0);
	return(err);
}

/* Connect the speaker to a DAC that no other output pin is connected
 * to by default.  If that is not possible, connect to a DAC other
 * than the one the first output pin is connected to. 
 */
int
azalia_codec_select_spkrdac(codec_t *this)
{
	widget_t *w;
	nid_t convs[HDA_MAX_CHANNELS];
	int nconv, conv;
	int i, j, err, fspkr, conn;

	nconv = fspkr = 0;
	for (i = 0; i < this->nopins; i++) {
		conv = this->opins[i].conv;
		for (j = 0; j < nconv; j++) {
			if (conv == convs[j])
				break;
		}
		if (j == nconv) {
			if (conv == this->spkr_dac)
				fspkr = 1;
			convs[nconv++] = conv;
			if (nconv == this->na_dacs)
				break;
		}
	}

	if (fspkr) {
		conn = conv = -1;
		w = &this->w[this->speaker];
		for (i = 0; i < w->nconnections; i++) {
			conv = azalia_codec_find_defdac(this,
			    w->connections[i], 1);
			for (j = 0; j < nconv; j++)
				if (conv == convs[j])
					break;
			if (j == nconv)
				break;
		}
		if (i < w->nconnections) {
			conn = i;
		} else {
			/* Couldn't get a unique DAC.  Try to get a diferent
			 * DAC than the first pin's DAC.
			 */
			if (this->spkr_dac == this->opins[0].conv) {
				/* If the speaker connection can't be changed,
				 * change the first pin's connection.
				 */
				if (w->nconnections == 1)
					w = &this->w[this->opins[0].nid];
				for (j = 0; j < w->nconnections; j++) {
					conv = azalia_codec_find_defdac(this,
					    w->connections[j], 1);
					if (conv != this->opins[0].conv) {
						conn = j;
						break;
					}
				}
			}
		}
		if (conn != -1 && conv != -1) {
			err = azalia_comresp(this, w->nid,
			    CORB_SET_CONNECTION_SELECT_CONTROL, conn, 0);
			if (err)
				return(err);
			w->selected = conn;
			if (w->nid == this->speaker)
				this->spkr_dac = conv;
			else
				this->opins[0].conv = conv;
		}
	}

	/* If there is a speaker2, try to connect it to spkr_dac. */
	if (this->speaker2 != -1) {
		conn = conv = -1;
		w = &this->w[this->speaker2];
		for (i = 0; i < w->nconnections; i++) {
			conv = azalia_codec_find_defdac(this,
			    w->connections[i], 1);
			if (conv == this->spkr_dac) {
				conn = i;
				break;
			}
		}
		if (conn != -1) {
			err = azalia_comresp(this, w->nid,
			    CORB_SET_CONNECTION_SELECT_CONTROL, conn, 0);
			if (err)
				return(err);
			w->selected = conn;
		}
	}

	return(0);
}

int
azalia_codec_find_defdac(codec_t *this, int index, int depth)
{
	const widget_t *w;
	int i, ret;

	w = &this->w[index];
	if (w->enable == 0)
		return -1;

	if (w->type == COP_AWTYPE_AUDIO_OUTPUT)
		return index;

	if (depth > 0 &&
	    (w->type == COP_AWTYPE_PIN_COMPLEX ||
	    w->type == COP_AWTYPE_BEEP_GENERATOR ||
	    w->type == COP_AWTYPE_AUDIO_INPUT))
		return -1;
	if (++depth >= 10)
		return -1;

	if (w->nconnections > 0) {
		/* by default, all mixer connections are active */
		if (w->type == COP_AWTYPE_AUDIO_MIXER) {
			for (i = 0; i < w->nconnections; i++) {
				index = w->connections[i];
				if (!azalia_widget_enabled(this, index))
					continue;
				ret = azalia_codec_find_defdac(this, index,
				    depth);
				if (ret >= 0)
					return ret;
			}
		/* 7.3.3.2 Connection Select Control
		 * If an attempt is made to Set an index value greater than
		 * the number of list entries (index is equal to or greater
		 * than the Connection List Length property for the widget)
		 * the behavior is not predictable.
		 */

		/* negative index values are wrong too */
		} else if (w->selected >= 0 &&
			w->selected < sizeof(w->connections)) {
				index = w->connections[w->selected];
				if (VALID_WIDGET_NID(index, this)) {
					ret = azalia_codec_find_defdac(this,
						index, depth);
					if (ret >= 0)
						return ret;
				}
		}
	}

	return -1;
}

int
azalia_codec_find_defadc_sub(codec_t *this, nid_t node, int index, int depth)
{
	const widget_t *w;
	int i, ret;

	w = &this->w[index];
	if (w->nid == node) {
		return index;
	}
	/* back at the beginning or a bad end */
	if (depth > 0 &&
	    (w->type == COP_AWTYPE_PIN_COMPLEX ||
	    w->type == COP_AWTYPE_BEEP_GENERATOR ||
	    w->type == COP_AWTYPE_AUDIO_OUTPUT ||
	    w->type == COP_AWTYPE_AUDIO_INPUT))
		return -1;
	if (++depth >= 10)
		return -1;

	if (w->nconnections > 0) {
		/* by default, all mixer connections are active */
		if (w->type == COP_AWTYPE_AUDIO_MIXER) {
			for (i = 0; i < w->nconnections; i++) {
				if (!azalia_widget_enabled(this, w->connections[i]))
					continue;
				ret = azalia_codec_find_defadc_sub(this, node,
				    w->connections[i], depth);
				if (ret >= 0)
					return ret;
			}
		/* 7.3.3.2 Connection Select Control
		 * If an attempt is made to Set an index value greater than
		 * the number of list entries (index is equal to or greater
		 * than the Connection List Length property for the widget)
		 * the behavior is not predictable.
		 */

		/* negative index values are wrong too */
		} else if (w->selected >= 0 &&
			w->selected < sizeof(w->connections)) {
				index = w->connections[w->selected];
				if (VALID_WIDGET_NID(index, this)) {
					ret = azalia_codec_find_defadc_sub(this,
						node, index, depth);
					if (ret >= 0)
						return ret;
				}
		}
	}
	return -1;
}

int
azalia_codec_find_defadc(codec_t *this, int index, int depth)
{
	int i, j, conv;

	conv = -1;
	for (i = 0; i < this->na_adcs; i++) {
		j = azalia_codec_find_defadc_sub(this, index,
		    this->a_adcs[i], 0);
		if (j >= 0) {
			conv = this->a_adcs[i];
			break;
		}
	}
	return(conv);
}

int
azalia_codec_init_volgroups(codec_t *this)
{
	const widget_t *w;
	uint32_t cap, result;
	int i, j, dac, err;

	j = 0;
	this->playvols.mask = 0;
	FOR_EACH_WIDGET(this, i) {
		w = &this->w[i];
		if (w->enable == 0)
			continue;
		if (w->mixer_class == AZ_CLASS_RECORD)
			continue;
		if (!(w->widgetcap & COP_AWCAP_OUTAMP))
			continue;
		if ((COP_AMPCAP_NUMSTEPS(w->outamp_cap) == 0) &&
		    !(w->outamp_cap & COP_AMPCAP_MUTE))
			continue;
		this->playvols.mask |= (1 << j);
		this->playvols.slaves[j++] = w->nid;
		if (j >= AZ_MAX_VOL_SLAVES)
			break;
	}
	this->playvols.nslaves = j;

	this->playvols.cur = 0;
	for (i = 0; i < this->playvols.nslaves; i++) {
		w = &this->w[this->playvols.slaves[i]];
		if (w->nid == this->input_mixer ||
		    w->parent == this->input_mixer ||
		    WIDGET_CHANNELS(w) < 2)
			continue;
		j = 0;
		/* azalia_codec_find_defdac only goes 10 connections deep.
		 * Start the connection depth at 7 so it doesn't go more
		 * than 3 connections deep.
		 */
		if (w->type == COP_AWTYPE_AUDIO_MIXER ||
		    w->type == COP_AWTYPE_AUDIO_SELECTOR)
			j = 7;
		dac = azalia_codec_find_defdac(this, w->nid, j);
		if (dac == -1)
			continue;
		if (dac != this->dacs.groups[this->dacs.cur].conv[0] &&
		    dac != this->spkr_dac && dac != this->fhp_dac)
			continue;
		cap = w->outamp_cap;
		if ((cap & COP_AMPCAP_MUTE) && COP_AMPCAP_NUMSTEPS(cap)) {
			if (w->type == COP_AWTYPE_BEEP_GENERATOR) {
				continue;
			} else if (w->type == COP_AWTYPE_PIN_COMPLEX) {
				err = azalia_comresp(this, w->nid,
				    CORB_GET_PIN_WIDGET_CONTROL, 0, &result);
				if (!err && (result & CORB_PWC_OUTPUT))
					this->playvols.cur |= (1 << i);
			} else
				this->playvols.cur |= (1 << i);
		}
	}
	if (this->playvols.cur == 0) {
		for (i = 0; i < this->playvols.nslaves; i++) {
			w = &this->w[this->playvols.slaves[i]];
			j = 0;
			if (w->type == COP_AWTYPE_AUDIO_MIXER ||
			    w->type == COP_AWTYPE_AUDIO_SELECTOR)
				j = 7;
			dac = azalia_codec_find_defdac(this, w->nid, j);
			if (dac == -1)
				continue;
			if (dac != this->dacs.groups[this->dacs.cur].conv[0] &&
			    dac != this->spkr_dac && dac != this->fhp_dac)
				continue;
			if (w->type == COP_AWTYPE_BEEP_GENERATOR)
				continue;
			if (w->type == COP_AWTYPE_PIN_COMPLEX) {
				err = azalia_comresp(this, w->nid,
				    CORB_GET_PIN_WIDGET_CONTROL, 0, &result);
				if (!err && (result & CORB_PWC_OUTPUT))
					this->playvols.cur |= (1 << i);
			} else {
				this->playvols.cur |= (1 << i);
			}
		}
	}

	this->playvols.master = this->audiofunc;
	if (this->playvols.nslaves > 0) {
		FOR_EACH_WIDGET(this, i) {
			w = &this->w[i];
			if (w->type != COP_AWTYPE_VOLUME_KNOB)
				continue;
			if (!COP_VKCAP_NUMSTEPS(w->d.volume.cap))
				continue;
			this->playvols.master = w->nid;
			break;
		}
	}

	j = 0;
	this->recvols.mask = 0;
	FOR_EACH_WIDGET(this, i) {
		w = &this->w[i];
		if (w->enable == 0)
			continue;
		if (w->type == COP_AWTYPE_AUDIO_INPUT ||
		    w->type == COP_AWTYPE_PIN_COMPLEX) {
			if (!(w->widgetcap & COP_AWCAP_INAMP))
				continue;
			if ((COP_AMPCAP_NUMSTEPS(w->inamp_cap) == 0) &&
			    !(w->inamp_cap & COP_AMPCAP_MUTE))
				continue;
		} else if (w->type == COP_AWTYPE_AUDIO_MIXER ||
		    w->type == COP_AWTYPE_AUDIO_SELECTOR) {
			if (w->mixer_class != AZ_CLASS_RECORD)
				continue;
			if (!(w->widgetcap & COP_AWCAP_OUTAMP))
				continue;
			if ((COP_AMPCAP_NUMSTEPS(w->outamp_cap) == 0) &&
			    !(w->outamp_cap & COP_AMPCAP_MUTE))
				continue;
		} else {
			continue;
		}
		this->recvols.mask |= (1 << j);
		this->recvols.slaves[j++] = w->nid;
		if (j >= AZ_MAX_VOL_SLAVES)
			break;
	}
	this->recvols.nslaves = j;

	this->recvols.cur = 0;
	for (i = 0; i < this->recvols.nslaves; i++) {
		w = &this->w[this->recvols.slaves[i]];
		cap = w->outamp_cap;
		if (w->type == COP_AWTYPE_AUDIO_INPUT ||
		    w->type != COP_AWTYPE_PIN_COMPLEX)
			cap = w->inamp_cap;
		 else
			if (w->mixer_class != AZ_CLASS_RECORD)
				continue;
		if ((cap & COP_AMPCAP_MUTE) && COP_AMPCAP_NUMSTEPS(cap)) {
			if (w->type == COP_AWTYPE_PIN_COMPLEX) {
				err = azalia_comresp(this, w->nid,
				    CORB_GET_PIN_WIDGET_CONTROL, 0, &result);
				if (!err && !(result & CORB_PWC_OUTPUT))
					this->recvols.cur |= (1 << i);
			} else
				this->recvols.cur |= (1 << i);
		}
	}
	if (this->recvols.cur == 0) {
		for (i = 0; i < this->recvols.nslaves; i++) {
			w = &this->w[this->recvols.slaves[i]];
			cap = w->outamp_cap;
			if (w->type == COP_AWTYPE_AUDIO_INPUT ||
			    w->type != COP_AWTYPE_PIN_COMPLEX)
				cap = w->inamp_cap;
			 else
				if (w->mixer_class != AZ_CLASS_RECORD)
					continue;
			if (w->type == COP_AWTYPE_PIN_COMPLEX) {
				err = azalia_comresp(this, w->nid,
				    CORB_GET_PIN_WIDGET_CONTROL, 0, &result);
				if (!err && !(result & CORB_PWC_OUTPUT))
					this->recvols.cur |= (1 << i);
			} else {
				this->recvols.cur |= (1 << i);
			}
		}
	}

	this->recvols.master = this->audiofunc;

	return 0;
}

int
azalia_codec_delete(codec_t *this)
{
	azalia_mixer_delete(this);

	if (this->formats != NULL) {
		free(this->formats, M_DEVBUF, 0);
		this->formats = NULL;
	}
	this->nformats = 0;

	if (this->opins != NULL) {
		free(this->opins, M_DEVBUF, 0);
		this->opins = NULL;
	}
	this->nopins = 0;

	if (this->opins_d != NULL) {
		free(this->opins_d, M_DEVBUF, 0);
		this->opins_d = NULL;
	}
	this->nopins_d = 0;

	if (this->ipins != NULL) {
		free(this->ipins, M_DEVBUF, 0);
		this->ipins = NULL;
	}
	this->nipins = 0;

	if (this->ipins_d != NULL) {
		free(this->ipins_d, M_DEVBUF, 0);
		this->ipins_d = NULL;
	}
	this->nipins_d = 0;

	if (this->w != NULL) {
		free(this->w, M_DEVBUF, 0);
		this->w = NULL;
	}

	return 0;
}

int
azalia_codec_construct_format(codec_t *this, int newdac, int newadc)
{
	const convgroup_t *group;
	uint32_t bits_rates;
	int variation;
	int nbits, c, chan, i;
	nid_t nid;

	variation = 0;

	if (this->dacs.ngroups > 0 && newdac < this->dacs.ngroups &&
	    newdac >= 0) {
		this->dacs.cur = newdac;
		group = &this->dacs.groups[this->dacs.cur];
		bits_rates = this->w[group->conv[0]].d.audio.bits_rates;
		nbits = 0;
		if (bits_rates & COP_PCM_B8)
			nbits++;
		if (bits_rates & COP_PCM_B16)
			nbits++;
		if (bits_rates & COP_PCM_B20)
			nbits++;
		if (bits_rates & COP_PCM_B24)
			nbits++;
		if ((bits_rates & COP_PCM_B32) &&
		    !(this->w[group->conv[0]].widgetcap & COP_AWCAP_DIGITAL))
			nbits++;
		if (nbits == 0) {
			printf("%s: invalid DAC PCM format: 0x%8.8x\n",
			    XNAME(this->az), bits_rates);
			return -1;
		}
		variation += group->nconv * nbits;
	}

	if (this->adcs.ngroups > 0 && newadc < this->adcs.ngroups &&
	    newadc >= 0) {
		this->adcs.cur = newadc;
		group = &this->adcs.groups[this->adcs.cur];
		bits_rates = this->w[group->conv[0]].d.audio.bits_rates;
		nbits = 0;
		if (bits_rates & COP_PCM_B8)
			nbits++;
		if (bits_rates & COP_PCM_B16)
			nbits++;
		if (bits_rates & COP_PCM_B20)
			nbits++;
		if (bits_rates & COP_PCM_B24)
			nbits++;
		if ((bits_rates & COP_PCM_B32) &&
		    !(this->w[group->conv[0]].widgetcap & COP_AWCAP_DIGITAL))
			nbits++;
		if (nbits == 0) {
			printf("%s: invalid ADC PCM format: 0x%8.8x\n",
			    XNAME(this->az), bits_rates);
			return -1;
		}
		variation += group->nconv * nbits;
	}

	if (variation == 0) {
		DPRINTF(("%s: no converter groups\n", XNAME(this->az)));
		return -1;
	}

	if (this->formats != NULL)
		free(this->formats, M_DEVBUF, 0);
	this->nformats = 0;
	this->formats = mallocarray(variation, sizeof(struct audio_format),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (this->formats == NULL) {
		printf("%s: out of memory in %s\n",
		    XNAME(this->az), __func__);
		return ENOMEM;
	}

	/* register formats for playback */
	if (this->dacs.ngroups > 0) {
		group = &this->dacs.groups[this->dacs.cur];
		for (c = 0; c < group->nconv; c++) {
			chan = 0;
			bits_rates = ~0;
			if (this->w[group->conv[0]].widgetcap &
			    COP_AWCAP_DIGITAL)
				bits_rates &= ~(COP_PCM_B32);
			for (i = 0; i <= c; i++) {
				nid = group->conv[i];
				chan += WIDGET_CHANNELS(&this->w[nid]);
				bits_rates &= this->w[nid].d.audio.bits_rates;
			}
			azalia_codec_add_bits(this, chan, bits_rates,
			    AUMODE_PLAY);
		}
	}

	/* register formats for recording */
	if (this->adcs.ngroups > 0) {
		group = &this->adcs.groups[this->adcs.cur];
		for (c = 0; c < group->nconv; c++) {
			chan = 0;
			bits_rates = ~0;
			if (this->w[group->conv[0]].widgetcap &
			    COP_AWCAP_DIGITAL)
				bits_rates &= ~(COP_PCM_B32);
			for (i = 0; i <= c; i++) {
				nid = group->conv[i];
				chan += WIDGET_CHANNELS(&this->w[nid]);
				bits_rates &= this->w[nid].d.audio.bits_rates;
			}
			azalia_codec_add_bits(this, chan, bits_rates,
			    AUMODE_RECORD);
		}
	}

	return 0;
}

void
azalia_codec_add_bits(codec_t *this, int chan, uint32_t bits_rates, int mode)
{
	if (bits_rates & COP_PCM_B8)
		azalia_codec_add_format(this, chan, 8, bits_rates, mode);
	if (bits_rates & COP_PCM_B16)
		azalia_codec_add_format(this, chan, 16, bits_rates, mode);
	if (bits_rates & COP_PCM_B20)
		azalia_codec_add_format(this, chan, 20, bits_rates, mode);
	if (bits_rates & COP_PCM_B24)
		azalia_codec_add_format(this, chan, 24, bits_rates, mode);
	if (bits_rates & COP_PCM_B32)
		azalia_codec_add_format(this, chan, 32, bits_rates, mode);
}

void
azalia_codec_add_format(codec_t *this, int chan, int prec, uint32_t rates,
    int32_t mode)
{
	struct audio_format *f;

	f = &this->formats[this->nformats++];
	f->mode = mode;
	f->encoding = AUDIO_ENCODING_SLINEAR_LE;
	if (prec == 8)
		f->encoding = AUDIO_ENCODING_ULINEAR_LE;
	f->precision = prec;
	f->channels = chan;
	f->frequency_type = 0;
	if (rates & COP_PCM_R80)
		f->frequency[f->frequency_type++] = 8000;
	if (rates & COP_PCM_R110)
		f->frequency[f->frequency_type++] = 11025;
	if (rates & COP_PCM_R160)
		f->frequency[f->frequency_type++] = 16000;
	if (rates & COP_PCM_R220)
		f->frequency[f->frequency_type++] = 22050;
	if (rates & COP_PCM_R320)
		f->frequency[f->frequency_type++] = 32000;
	if (rates & COP_PCM_R441)
		f->frequency[f->frequency_type++] = 44100;
	if (rates & COP_PCM_R480)
		f->frequency[f->frequency_type++] = 48000;
	if (rates & COP_PCM_R882)
		f->frequency[f->frequency_type++] = 88200;
	if (rates & COP_PCM_R960)
		f->frequency[f->frequency_type++] = 96000;
	if (rates & COP_PCM_R1764)
		f->frequency[f->frequency_type++] = 176400;
	if (rates & COP_PCM_R1920)
		f->frequency[f->frequency_type++] = 192000;
	if (rates & COP_PCM_R3840)
		f->frequency[f->frequency_type++] = 384000;
}

int
azalia_codec_connect_stream(stream_t *this)
{
	const codec_t *codec = &this->az->codecs[this->az->codecno];
	const convgroup_t *group;
	widget_t *w;
	uint32_t digital, stream_chan;
	int i, err, curchan, nchan, widchan;

	err = 0;
	nchan = (this->fmt & HDA_SD_FMT_CHAN) + 1;

	if (this->dir == AUMODE_RECORD)
		group = &codec->adcs.groups[codec->adcs.cur];
	else
		group = &codec->dacs.groups[codec->dacs.cur];

	curchan = 0;
	for (i = 0; i < group->nconv; i++) {
		w = &codec->w[group->conv[i]];
		widchan = WIDGET_CHANNELS(w);

		stream_chan = (this->number << 4);
		if (curchan < nchan) {
			stream_chan |= curchan;
		} else if (w->nid == codec->spkr_dac ||
		    w->nid == codec->fhp_dac) {
			stream_chan |= 0;	/* first channel(s) */
		} else
			stream_chan = 0;	/* idle stream */

		if (stream_chan == 0) {
			DPRINTFN(0, ("%s: %2.2x is idle\n", __func__, w->nid));
		} else {
			DPRINTFN(0, ("%s: %2.2x on stream chan %d\n", __func__,
			    w->nid, stream_chan & ~(this->number << 4)));
		}

		err = azalia_comresp(codec, w->nid, CORB_SET_CONVERTER_FORMAT,
		    this->fmt, NULL);
		if (err) {
			DPRINTF(("%s: nid %2.2x fmt %2.2x: %d\n",
			    __func__, w->nid, this->fmt, err));
			break;
		}
		err = azalia_comresp(codec, w->nid,
		    CORB_SET_CONVERTER_STREAM_CHANNEL, stream_chan, NULL);
		if (err) {
			DPRINTF(("%s: nid %2.2x chan %d: %d\n",
			    __func__, w->nid, stream_chan, err));
			break;
		}

		if (w->widgetcap & COP_AWCAP_DIGITAL) {
			err = azalia_comresp(codec, w->nid,
			    CORB_GET_DIGITAL_CONTROL, 0, &digital);
			if (err) {
				DPRINTF(("%s: nid %2.2x get digital: %d\n",
				    __func__, w->nid, err));
				break;
			}
			digital = (digital & 0xff) | CORB_DCC_DIGEN;
			err = azalia_comresp(codec, w->nid,
			    CORB_SET_DIGITAL_CONTROL_L, digital, NULL);
			if (err) {
				DPRINTF(("%s: nid %2.2x set digital: %d\n",
				    __func__, w->nid, err));
				break;
			}
		}
		curchan += widchan;
	}

	return err;
}

int
azalia_codec_disconnect_stream(stream_t *this)
{
	const codec_t *codec = &this->az->codecs[this->az->codecno];
	const convgroup_t *group;
	uint32_t v;
	int i;
	nid_t nid;

	if (this->dir == AUMODE_RECORD)
		group = &codec->adcs.groups[codec->adcs.cur];
	else
		group = &codec->dacs.groups[codec->dacs.cur];
	for (i = 0; i < group->nconv; i++) {
		nid = group->conv[i];
		azalia_comresp(codec, nid, CORB_SET_CONVERTER_STREAM_CHANNEL,
		    0, NULL);	/* stream#0 */
		if (codec->w[nid].widgetcap & COP_AWCAP_DIGITAL) {
			/* disable S/PDIF */
			azalia_comresp(codec, nid, CORB_GET_DIGITAL_CONTROL,
			    0, &v);
			v = (v & ~CORB_DCC_DIGEN) & 0xff;
			azalia_comresp(codec, nid, CORB_SET_DIGITAL_CONTROL_L,
			    v, NULL);
		}
	}
	return 0;
}

/* ================================================================
 * HDA widget functions
 * ================================================================ */

int
azalia_widget_init(widget_t *this, const codec_t *codec, nid_t nid)
{
	uint32_t result;
	int err;

	err = azalia_comresp(codec, nid, CORB_GET_PARAMETER,
	    COP_AUDIO_WIDGET_CAP, &result);
	if (err)
		return err;
	this->nid = nid;
	this->widgetcap = result;
	this->type = COP_AWCAP_TYPE(result);
	if (this->widgetcap & COP_AWCAP_POWER) {
		azalia_comresp(codec, nid, CORB_SET_POWER_STATE, CORB_PS_D0,
		    &result);
		DELAY(100);
	}

	this->enable = 1;
	this->mixer_class = -1;
	this->parent = codec->audiofunc;

	switch (this->type) {
	case COP_AWTYPE_AUDIO_OUTPUT:
		/* FALLTHROUGH */
	case COP_AWTYPE_AUDIO_INPUT:
		azalia_widget_init_audio(this, codec);
		break;
	case COP_AWTYPE_PIN_COMPLEX:
		azalia_widget_init_pin(this, codec);
		break;
	case COP_AWTYPE_VOLUME_KNOB:
		err = azalia_comresp(codec, this->nid, CORB_GET_PARAMETER,
		    COP_VOLUME_KNOB_CAPABILITIES, &result);
		if (err)
			return err;
		this->d.volume.cap = result;
		break;
	case COP_AWTYPE_POWER:
		/* FALLTHROUGH */
	case COP_AWTYPE_VENDOR_DEFINED:
		this->enable = 0;
		break;
	}

	/* amplifier information */
	/* XXX (ab)use bits 24-30 to store the "control offset", which is
	 * the number of steps, starting at 0, that have no effect.  these
	 * bits are reserved in HDA 1.0.
	 */
	if (this->widgetcap & COP_AWCAP_INAMP) {
		if (this->widgetcap & COP_AWCAP_AMPOV)
			azalia_comresp(codec, nid, CORB_GET_PARAMETER,
			    COP_INPUT_AMPCAP, &this->inamp_cap);
		else
			this->inamp_cap = codec->w[codec->audiofunc].inamp_cap;
		this->inamp_cap &= ~(0x7f << 24);
	}
	if (this->widgetcap & COP_AWCAP_OUTAMP) {
		if (this->widgetcap & COP_AWCAP_AMPOV)
			azalia_comresp(codec, nid, CORB_GET_PARAMETER,
			    COP_OUTPUT_AMPCAP, &this->outamp_cap);
		else
			this->outamp_cap = codec->w[codec->audiofunc].outamp_cap;
		this->outamp_cap &= ~(0x7f << 24);
	}
	return 0;
}

int
azalia_widget_sole_conn(codec_t *this, nid_t nid)
{
	int i, j, target, nconn, has_target;

	/* connected to ADC */
	for (i = 0; i < this->adcs.ngroups; i++) {
		for (j = 0; j < this->adcs.groups[i].nconv; j++) {
			target = this->adcs.groups[i].conv[j];
			if (this->w[target].nconnections == 1 &&
			    this->w[target].connections[0] == nid) {
				return target;
			}
		}
	}
	/* connected to DAC */
	for (i = 0; i < this->dacs.ngroups; i++) {
		for (j = 0; j < this->dacs.groups[i].nconv; j++) {
			target = this->dacs.groups[i].conv[j];
			if (this->w[target].nconnections == 1 &&
			    this->w[target].connections[0] == nid) {
				return target;
			}
		}
	}
	/* connected to pin complex */
	target = -1;
	FOR_EACH_WIDGET(this, i) {
		if (this->w[i].type != COP_AWTYPE_PIN_COMPLEX)
			continue;
		if (this->w[i].nconnections == 1 &&
		    this->w[i].connections[0] == nid) {
			if (target != -1)
				return -1;
			target = i;
		} else {
			nconn = 0;
			has_target = 0;
			for (j = 0; j < this->w[i].nconnections; j++) {
				if (!this->w[this->w[i].connections[j]].enable)
					continue;
				nconn++;
				if (this->w[i].connections[j] == nid)
					has_target = 1;
			}
			if (has_target == 1) {
				if (nconn == 1) {
					if (target != -1)
						return -1;
					target = i;
				} else {
					/* not sole connection at least once */
					return -1;
				}
			}
		}
	}
	if (target != -1)
		return target;

	return -1;
}

int
azalia_widget_label_widgets(codec_t *codec)
{
	widget_t *w;
	convgroup_t *group;
	int types[16];
	int pins[16];
	int colors_used, use_colors, schan;
	int i, j;

	bzero(&pins, sizeof(pins));
	bzero(&types, sizeof(types));

	/* If codec has more than one line-out jack, check if the jacks
	 * have unique colors.  If so, use the colors in the mixer names.
	 */
	use_colors = 1;
	colors_used = 0;
	if (codec->nout_jacks < 2)
		use_colors = 0;
	for (i = 0; use_colors && i < codec->nopins; i++) {
		w = &codec->w[codec->opins[i].nid];
		if (w->d.pin.device != CORB_CD_LINEOUT)
			continue;
		if (colors_used & (1 << w->d.pin.color))
			use_colors = 0;
		else
			colors_used |= (1 << w->d.pin.color);
	}

	FOR_EACH_WIDGET(codec, i) {
		w = &codec->w[i];
		/* default for disabled/unused widgets */
		snprintf(w->name, sizeof(w->name), "u-wid%2.2x", w->nid);
		if (w->enable == 0)
			continue;
		switch (w->type) {
		case COP_AWTYPE_PIN_COMPLEX:
			pins[w->d.pin.device]++;
			if (use_colors && w->d.pin.device == CORB_CD_LINEOUT) {
				snprintf(w->name, sizeof(w->name), "%s-%s",
				    pin_devices[w->d.pin.device],
				    line_colors[w->d.pin.color]);
			} else if (pins[w->d.pin.device] > 1) {
				snprintf(w->name, sizeof(w->name), "%s%d",
				    pin_devices[w->d.pin.device],
				    pins[w->d.pin.device]);
			} else {
				snprintf(w->name, sizeof(w->name), "%s",
				    pin_devices[w->d.pin.device]);
			}
			break;
		case COP_AWTYPE_AUDIO_OUTPUT:
			if (codec->dacs.ngroups < 1)
				break;
			group = &codec->dacs.groups[0];
			schan = 0;
			for (j = 0; j < group->nconv; j++) {
				if (w->nid == group->conv[j]) {
					snprintf(w->name, sizeof(w->name),
					    "%s-%d:%d", wtypes[w->type], schan,
					    schan + WIDGET_CHANNELS(w) - 1);
				}
				schan += WIDGET_CHANNELS(w);
			}
			if (codec->dacs.ngroups < 2)
				break;
			group = &codec->dacs.groups[1];
			schan = 0;
			for (j = 0; j < group->nconv; j++) {
				if (w->nid == group->conv[j]) {
					snprintf(w->name, sizeof(w->name),
					    "dig-%s-%d:%d", wtypes[w->type],
					    schan,
					    schan + WIDGET_CHANNELS(w) - 1);
				}
				schan += WIDGET_CHANNELS(w);
			}
			break;
		case COP_AWTYPE_AUDIO_INPUT:
			w->mixer_class = AZ_CLASS_RECORD;
			if (codec->adcs.ngroups < 1)
				break;
			group = &codec->adcs.groups[0];
			schan = 0;
			for (j = 0; j < group->nconv; j++) {
				if (w->nid == group->conv[j]) {
					snprintf(w->name, sizeof(w->name),
					    "%s-%d:%d", wtypes[w->type], schan,
					    schan + WIDGET_CHANNELS(w) - 1);
				}
				schan += WIDGET_CHANNELS(w);
			}
			if (codec->adcs.ngroups < 2)
				break;
			group = &codec->adcs.groups[1];
			schan = 0;
			for (j = 0; j < group->nconv; j++) {
				if (w->nid == group->conv[j]) {
					snprintf(w->name, sizeof(w->name),
					    "dig-%s-%d:%d", wtypes[w->type],
					    schan,
					    schan + WIDGET_CHANNELS(w) - 1);
				}
				schan += WIDGET_CHANNELS(w);
			}
			break;
		default:
			types[w->type]++;
			if (types[w->type] > 1)
				snprintf(w->name, sizeof(w->name), "%s%d",
				    wtypes[w->type], types[w->type]);
			else
				snprintf(w->name, sizeof(w->name), "%s",
				    wtypes[w->type]);
			break;
		}
	}

	/* Mixers and selectors that connect to only one other widget are
	 * functionally part of the widget they are connected to.  Show that
	 * relationship in the name.
	 */
	FOR_EACH_WIDGET(codec, i) {
		if (codec->w[i].type != COP_AWTYPE_AUDIO_MIXER &&
		    codec->w[i].type != COP_AWTYPE_AUDIO_SELECTOR)
			continue;
		if (codec->w[i].enable == 0)
			continue;
		j = azalia_widget_sole_conn(codec, i);
		if (j == -1) {
			/* Special case.  A selector with outamp capabilities
			 * and is connected to a single widget that has either
			 * no input or no output capabilities.  This widget
			 * serves as the input or output amp for the widget
			 * it is connected to.
			 */
			if (codec->w[i].type == COP_AWTYPE_AUDIO_SELECTOR &&
			    (codec->w[i].widgetcap & COP_AWCAP_OUTAMP) &&
			    codec->w[i].nconnections == 1) {
				j = codec->w[i].connections[0];
				if (!azalia_widget_enabled(codec, j))
					continue;
				if (!(codec->w[j].widgetcap & COP_AWCAP_INAMP))
					codec->w[i].mixer_class =
					    AZ_CLASS_INPUT;
				else if (!(codec->w[j].widgetcap & COP_AWCAP_OUTAMP))
					codec->w[i].mixer_class =
					    AZ_CLASS_OUTPUT;
				else
					continue;
			}
		}
		if (j >= 0) {
			/* As part of a disabled widget, this widget
			 * should be disabled as well.
			 */
			if (codec->w[j].enable == 0) {
				codec->w[i].enable = 0;
				snprintf(codec->w[i].name,
				    sizeof(codec->w[i].name),
				    "u-wid%2.2x", i);
				continue;
			}
			snprintf(codec->w[i].name, sizeof(codec->w[i].name),
			    "%s", codec->w[j].name);
			if (codec->w[j].mixer_class == AZ_CLASS_RECORD)
				codec->w[i].mixer_class = AZ_CLASS_RECORD;
			codec->w[i].parent = j;
		}
	}

	return 0;
}

int
azalia_widget_init_audio(widget_t *this, const codec_t *codec)
{
	uint32_t result;
	int err;

	/* check audio format */
	if (this->widgetcap & COP_AWCAP_FORMATOV) {
		err = azalia_comresp(codec, this->nid, CORB_GET_PARAMETER,
		    COP_STREAM_FORMATS, &result);
		if (err)
			return err;
		this->d.audio.encodings = result;
		if (result == 0) { /* quirk for CMI9880.
				    * This must not occur usually... */
			this->d.audio.encodings =
			    codec->w[codec->audiofunc].d.audio.encodings;
			this->d.audio.bits_rates =
			    codec->w[codec->audiofunc].d.audio.bits_rates;
		} else {
			if ((result & COP_STREAM_FORMAT_PCM) == 0) {
				printf("%s: %s: No PCM support: %x\n",
				    XNAME(codec->az), this->name, result);
				return -1;
			}
			err = azalia_comresp(codec, this->nid,
			    CORB_GET_PARAMETER, COP_PCM, &result);
			if (err)
				return err;
			this->d.audio.bits_rates = result;
		}
	} else {
		this->d.audio.encodings =
		    codec->w[codec->audiofunc].d.audio.encodings;
		this->d.audio.bits_rates =
		    codec->w[codec->audiofunc].d.audio.bits_rates;
	}
	return 0;
}

int
azalia_widget_init_pin(widget_t *this, const codec_t *codec)
{
	uint32_t result, dir;
	int err;

	err = azalia_comresp(codec, this->nid, CORB_GET_CONFIGURATION_DEFAULT,
	    0, &result);
	if (err)
		return err;
	this->d.pin.config = result;
	this->d.pin.sequence = CORB_CD_SEQUENCE(result);
	this->d.pin.association = CORB_CD_ASSOCIATION(result);
	this->d.pin.color = CORB_CD_COLOR(result);
	this->d.pin.device = CORB_CD_DEVICE(result);

	err = azalia_comresp(codec, this->nid, CORB_GET_PARAMETER,
	    COP_PINCAP, &result);
	if (err)
		return err;
	this->d.pin.cap = result;

	dir = CORB_PWC_INPUT;
	switch (this->d.pin.device) {
	case CORB_CD_LINEOUT:
	case CORB_CD_SPEAKER:
	case CORB_CD_HEADPHONE:
	case CORB_CD_SPDIFOUT:
	case CORB_CD_DIGITALOUT:
		dir = CORB_PWC_OUTPUT;
		break;
	}

	if (dir == CORB_PWC_INPUT && !(this->d.pin.cap & COP_PINCAP_INPUT))
		dir = CORB_PWC_OUTPUT;
	if (dir == CORB_PWC_OUTPUT && !(this->d.pin.cap & COP_PINCAP_OUTPUT))
		dir = CORB_PWC_INPUT;

	if (dir == CORB_PWC_INPUT && this->d.pin.device == CORB_CD_MICIN) {
		if (COP_PINCAP_VREF(this->d.pin.cap) & (1 << CORB_PWC_VREF_80))
			dir |= CORB_PWC_VREF_80;
		else if (COP_PINCAP_VREF(this->d.pin.cap) &
		    (1 << CORB_PWC_VREF_50))
			dir |= CORB_PWC_VREF_50;
	}

	if ((codec->qrks & AZ_QRK_WID_OVREF50) && (dir == CORB_PWC_OUTPUT))
		dir |= CORB_PWC_VREF_50;

	azalia_comresp(codec, this->nid, CORB_SET_PIN_WIDGET_CONTROL,
	    dir, NULL);

	if (this->d.pin.cap & COP_PINCAP_EAPD) {
		err = azalia_comresp(codec, this->nid,
		    CORB_GET_EAPD_BTL_ENABLE, 0, &result);
		if (err)
			return err;
		result &= 0xff;
		result |= CORB_EAPD_EAPD;
		err = azalia_comresp(codec, this->nid,
		    CORB_SET_EAPD_BTL_ENABLE, result, &result);
		if (err)
			return err;
	}

	/* Disable unconnected pins */
	if (CORB_CD_PORT(this->d.pin.config) == CORB_CD_NONE)
		this->enable = 0;

	return 0;
}

int
azalia_widget_init_connection(widget_t *this, const codec_t *codec)
{
	uint32_t result;
	int err;
	int i, j, k;
	int length, nconn, bits, conn, last;

	this->selected = -1;
	if ((this->widgetcap & COP_AWCAP_CONNLIST) == 0)
		return 0;

	err = azalia_comresp(codec, this->nid, CORB_GET_PARAMETER,
	    COP_CONNECTION_LIST_LENGTH, &result);
	if (err)
		return err;

	bits = 8;
	if (result & COP_CLL_LONG)
		bits = 16;

	length = COP_CLL_LENGTH(result);
	if (length == 0)
		return 0;

	/*
	 * 'length' is the number of entries, not the number of
	 * connections.  Find the number of connections, 'nconn', so
	 * enough space can be allocated for the list of connected
	 * nids.
	 */
	nconn = last = 0;
	for (i = 0; i < length;) {
		err = azalia_comresp(codec, this->nid,
		    CORB_GET_CONNECTION_LIST_ENTRY, i, &result);
		if (err)
			return err;
		for (k = 0; i < length && (k < 32 / bits); k++) {
			conn = (result >> (k * bits)) & ((1 << bits) - 1);
			/* If high bit is set, this is the end of a continuous
			 * list that started with the last connection.
			 */
			if ((nconn > 0) && (conn & (1 << (bits - 1))))
				nconn += (conn & ~(1 << (bits - 1))) - last;
			else
				nconn++;
			last = conn;
			i++;
		}
	}

	this->connections = mallocarray(nconn, sizeof(nid_t), M_DEVBUF, M_NOWAIT);
	if (this->connections == NULL) {
		printf("%s: out of memory\n", XNAME(codec->az));
		return ENOMEM;
	}
	for (i = 0; i < nconn;) {
		err = azalia_comresp(codec, this->nid,
		    CORB_GET_CONNECTION_LIST_ENTRY, i, &result);
		if (err)
			return err;
		for (k = 0; i < nconn && (k < 32 / bits); k++) {
			conn = (result >> (k * bits)) & ((1 << bits) - 1);
			/* If high bit is set, this is the end of a continuous
			 * list that started with the last connection.
			 */
			if ((i > 0) && (conn & (1 << (bits - 1)))) {
				for (j = 1; i < nconn && j <= conn - last; j++)
					this->connections[i++] = last + j;
			} else {
				this->connections[i++] = conn;
			}
			last = conn;
		}
	}
	this->nconnections = nconn;

	if (nconn > 0) {
		err = azalia_comresp(codec, this->nid,
		    CORB_GET_CONNECTION_SELECT_CONTROL, 0, &result);
		if (err)
			return err;
		this->selected = CORB_CSC_INDEX(result);
	}
	return 0;
}

int
azalia_widget_check_conn(codec_t *codec, int index, int depth)
{
	const widget_t *w;
	int i;

	w = &codec->w[index];

	if (w->type == COP_AWTYPE_BEEP_GENERATOR)
		return 0;

	if (depth > 0 &&
	    (w->type == COP_AWTYPE_PIN_COMPLEX ||
	    w->type == COP_AWTYPE_AUDIO_OUTPUT ||
	    w->type == COP_AWTYPE_AUDIO_INPUT)) {
		if (w->enable)
			return 1;
		else
			return 0;
	}
	if (++depth >= 10)
		return 0;
	for (i = 0; i < w->nconnections; i++) {
		if (!azalia_widget_enabled(codec, w->connections[i]))
			continue;
		if (azalia_widget_check_conn(codec, w->connections[i], depth))
			return 1;
	}
	return 0;
}

#ifdef AZALIA_DEBUG

#define	WIDGETCAP_BITS							\
    "\20\014LRSWAP\013POWER\012DIGITAL"					\
    "\011CONNLIST\010UNSOL\07PROC\06STRIPE\05FORMATOV\04AMPOV\03OUTAMP"	\
    "\02INAMP\01STEREO"

#define	PINCAP_BITS	"\20\021EAPD\16VREF100\15VREF80" \
    "\13VREFGND\12VREF50\11VREFHIZ\07BALANCE\06INPUT" \
    "\05OUTPUT\04HEADPHONE\03PRESENCE\02TRIGGER\01IMPEDANCE"

#define	ENCODING_BITS	"\20\3AC3\2FLOAT32\1PCM"

#define	BITSRATES_BITS	"\20\x15""32bit\x14""24bit\x13""20bit"		\
    "\x12""16bit\x11""8bit""\x0c""384kHz\x0b""192kHz\x0a""176.4kHz"	\
    "\x09""96kHz\x08""88.2kHz\x07""48kHz\x06""44.1kHz\x05""32kHz\x04"	\
    "22.05kHz\x03""16kHz\x02""11.025kHz\x01""8kHz"

static const char *pin_colors[16] = {
	"unknown", "black", "gray", "blue",
	"green", "red", "orange", "yellow",
	"purple", "pink", "col0a", "col0b",
	"col0c", "col0d", "white", "other"};
static const char *pin_conn[4] = {
	"jack", "none", "fixed", "combined"};
static const char *pin_conntype[16] = {
	"unknown", "1/8", "1/4", "atapi", "rca", "optical",
	"digital", "analog", "din", "xlr", "rj-11", "combination",
	"con0c", "con0d", "con0e", "other"};
static const char *pin_geo[15] = {
	"n/a", "rear", "front", "left",
	"right", "top", "bottom", "spec0", "spec1", "spec2",
	"loc0a", "loc0b", "loc0c", "loc0d", "loc0f"};
static const char *pin_chass[4] = {
	"external", "internal", "separate", "other"};

void
azalia_codec_print_audiofunc(const codec_t *this)
{
	uint32_t result;

	azalia_widget_print_audio(&this->w[this->audiofunc], "\t");

	result = this->w[this->audiofunc].inamp_cap;
	DPRINTF(("\tinamp: mute=%u size=%u steps=%u offset=%u\n",
	    (result & COP_AMPCAP_MUTE) != 0, COP_AMPCAP_STEPSIZE(result),
	    COP_AMPCAP_NUMSTEPS(result), COP_AMPCAP_OFFSET(result)));
	result = this->w[this->audiofunc].outamp_cap;
	DPRINTF(("\toutamp: mute=%u size=%u steps=%u offset=%u\n",
	    (result & COP_AMPCAP_MUTE) != 0, COP_AMPCAP_STEPSIZE(result),
	    COP_AMPCAP_NUMSTEPS(result), COP_AMPCAP_OFFSET(result)));
	azalia_comresp(this, this->audiofunc, CORB_GET_PARAMETER,
	    COP_GPIO_COUNT, &result);
	DPRINTF(("\tgpio: wake=%u unsol=%u gpis=%u gpos=%u gpios=%u\n",
	    (result & COP_GPIO_WAKE) != 0, (result & COP_GPIO_UNSOL) != 0,
	    COP_GPIO_GPIS(result), COP_GPIO_GPOS(result),
	    COP_GPIO_GPIOS(result)));
}

void
azalia_codec_print_groups(const codec_t *this)
{
	int i, n;

	for (i = 0; i < this->dacs.ngroups; i++) {
		printf("%s: dacgroup[%d]:", XNAME(this->az), i);
		for (n = 0; n < this->dacs.groups[i].nconv; n++) {
			printf(" %2.2x", this->dacs.groups[i].conv[n]);
		}
		printf("\n");
	}
	for (i = 0; i < this->adcs.ngroups; i++) {
		printf("%s: adcgroup[%d]:", XNAME(this->az), i);
		for (n = 0; n < this->adcs.groups[i].nconv; n++) {
			printf(" %2.2x", this->adcs.groups[i].conv[n]);
		}
		printf("\n");
	}
}

void
azalia_widget_print_audio(const widget_t *this, const char *lead)
{
	printf("%sencodings=%b\n", lead, this->d.audio.encodings,
	    ENCODING_BITS);
	printf("%sPCM formats=%b\n", lead, this->d.audio.bits_rates,
	    BITSRATES_BITS);
}

void
azalia_widget_print_widget(const widget_t *w, const codec_t *codec)
{
	int i;

	printf("%s: ", XNAME(codec->az));
	printf("%s%2.2x wcap=%b\n", w->type == COP_AWTYPE_PIN_COMPLEX ?
	    pin_colors[w->d.pin.color] : wtypes[w->type],
	    w->nid, w->widgetcap, WIDGETCAP_BITS);
	if (w->widgetcap & COP_AWCAP_FORMATOV)
		azalia_widget_print_audio(w, "\t");
	if (w->type == COP_AWTYPE_PIN_COMPLEX)
		azalia_widget_print_pin(w);

	if (w->type == COP_AWTYPE_VOLUME_KNOB)
		printf("\tdelta=%d steps=%d\n",
		    !!(w->d.volume.cap & COP_VKCAP_DELTA),
		    COP_VKCAP_NUMSTEPS(w->d.volume.cap));

	if ((w->widgetcap & COP_AWCAP_INAMP) &&
	    (w->widgetcap & COP_AWCAP_AMPOV))
		printf("\tinamp: mute=%u size=%u steps=%u offset=%u\n",
		    (w->inamp_cap & COP_AMPCAP_MUTE) != 0,
		    COP_AMPCAP_STEPSIZE(w->inamp_cap),
		    COP_AMPCAP_NUMSTEPS(w->inamp_cap),
		    COP_AMPCAP_OFFSET(w->inamp_cap));

	if ((w->widgetcap & COP_AWCAP_OUTAMP) &&
	    (w->widgetcap & COP_AWCAP_AMPOV))
		printf("\toutamp: mute=%u size=%u steps=%u offset=%u\n",
		    (w->outamp_cap & COP_AMPCAP_MUTE) != 0,
		    COP_AMPCAP_STEPSIZE(w->outamp_cap),
		    COP_AMPCAP_NUMSTEPS(w->outamp_cap),
		    COP_AMPCAP_OFFSET(w->outamp_cap));

	if (w->nconnections > 0) {
		printf("\tconnections=0x%x", w->connections[0]);
		for (i = 1; i < w->nconnections; i++)
			printf(",0x%x", w->connections[i]);
		printf("; selected=0x%x\n", w->connections[w->selected]);
	}
}

void
azalia_widget_print_pin(const widget_t *this)
{
	printf("\tcap=%b\n", this->d.pin.cap, PINCAP_BITS);
	printf("\t[%2.2d/%2.2d] ", CORB_CD_ASSOCIATION(this->d.pin.config),
	    CORB_CD_SEQUENCE(this->d.pin.config));
	printf("color=%s ", pin_colors[CORB_CD_COLOR(this->d.pin.config)]);
	printf("device=%s ", pin_devices[CORB_CD_DEVICE(this->d.pin.config)]);
	printf("conn=%s ", pin_conn[CORB_CD_PORT(this->d.pin.config)]);
	printf("conntype=%s\n", pin_conntype[CORB_CD_CONNECTION(this->d.pin.config)]);
	printf("\tlocation=%s ", pin_geo[CORB_CD_LOC_GEO(this->d.pin.config)]);
	printf("chassis=%s ", pin_chass[CORB_CD_LOC_CHASS(this->d.pin.config)]);
	printf("special=");
	if (CORB_CD_LOC_GEO(this->d.pin.config) == CORB_CD_LOC_SPEC0) {
		if (CORB_CD_LOC_CHASS(this->d.pin.config) == CORB_CD_EXTERNAL)
			printf("rear-panel");
		else if (CORB_CD_LOC_CHASS(this->d.pin.config) == CORB_CD_INTERNAL)
			printf("riser");
		else if (CORB_CD_LOC_CHASS(this->d.pin.config) == CORB_CD_LOC_OTHER)
			printf("mobile-lid-internal");
	} else if (CORB_CD_LOC_GEO(this->d.pin.config) == CORB_CD_LOC_SPEC1) {
		if (CORB_CD_LOC_CHASS(this->d.pin.config) == CORB_CD_EXTERNAL)
			printf("drive-bay");
		else if (CORB_CD_LOC_CHASS(this->d.pin.config) == CORB_CD_INTERNAL)
			printf("hdmi");
		else if (CORB_CD_LOC_CHASS(this->d.pin.config) == CORB_CD_LOC_OTHER)
			printf("mobile-lid-external");
	} else if (CORB_CD_LOC_GEO(this->d.pin.config) == CORB_CD_LOC_SPEC2) {
		if (CORB_CD_LOC_CHASS(this->d.pin.config) == CORB_CD_INTERNAL)
			printf("atapi");
	} else
		printf("none");
	printf("\n");
}

#else	/* AZALIA_DEBUG */

void
azalia_codec_print_audiofunc(const codec_t *this) {}

void
azalia_codec_print_groups(const codec_t *this) {}

void
azalia_widget_print_audio(const widget_t *this, const char *lead) {}

void
azalia_widget_print_widget(const widget_t *w, const codec_t *codec) {}

void
azalia_widget_print_pin(const widget_t *this) {}

#endif	/* AZALIA_DEBUG */

/* ================================================================
 * Stream functions
 * ================================================================ */

int
azalia_stream_init(stream_t *this, azalia_t *az, int regindex, int strnum,
    int dir)
{
	int err;

	this->az = az;
	this->regbase = HDA_SD_BASE + regindex * HDA_SD_SIZE;
	this->intr_bit = 1 << regindex;
	this->number = strnum;
	this->dir = dir;

	/* setup BDL buffers */
	err = azalia_alloc_dmamem(az, sizeof(bdlist_entry_t) * HDA_BDL_MAX,
				  128, &this->bdlist);
	if (err) {
		printf("%s: can't allocate a BDL buffer\n", XNAME(az));
		return err;
	}
	return 0;
}

int
azalia_stream_reset(stream_t *this)
{
	int i;
	uint16_t ctl;
	uint8_t sts;

	/* Make sure RUN bit is zero before resetting */
	ctl = STR_READ_2(this, CTL);
	ctl &= ~HDA_SD_CTL_RUN;
	STR_WRITE_2(this, CTL, ctl);
	DELAY(40);

	/* Start reset and wait for chip to enter. */
	ctl = STR_READ_2(this, CTL);
	STR_WRITE_2(this, CTL, ctl | HDA_SD_CTL_SRST);
	for (i = 5000; i > 0; i--) {
		DELAY(10);
		ctl = STR_READ_2(this, CTL);
		if (ctl & HDA_SD_CTL_SRST)
			break;
	}
	if (i == 0) {
		DPRINTF(("%s: stream reset failure 1\n", XNAME(this->az)));
		return -1;
	}

	/* Clear reset and wait for chip to finish */
	STR_WRITE_2(this, CTL, ctl & ~HDA_SD_CTL_SRST);
	for (i = 5000; i > 0; i--) {
		DELAY(10);
		ctl = STR_READ_2(this, CTL);
		if ((ctl & HDA_SD_CTL_SRST) == 0)
			break;
	}
	if (i == 0) {
		DPRINTF(("%s: stream reset failure 2\n", XNAME(this->az)));
		return -1;
	}

	sts = STR_READ_1(this, STS);
	sts |= HDA_SD_STS_DESE | HDA_SD_STS_FIFOE | HDA_SD_STS_BCIS;
	STR_WRITE_1(this, STS, sts);

	return (0);
}

int
azalia_stream_start(stream_t *this)
{
	bdlist_entry_t *bdlist;
	bus_addr_t dmaaddr, dmaend;
	int err, index;
	uint32_t intctl;
	uint8_t ctl2;

	err = azalia_stream_reset(this);
	if (err) {
		DPRINTF(("%s: stream reset failed\n", "azalia"));
		return err;
	}

	STR_WRITE_4(this, BDPL, 0);
	STR_WRITE_4(this, BDPU, 0);

	/* setup BDL */
	dmaaddr = AZALIA_DMA_DMAADDR(&this->buffer);
	dmaend = dmaaddr + this->bufsize;
	bdlist = (bdlist_entry_t*)this->bdlist.addr;
	for (index = 0; index < HDA_BDL_MAX; index++) {
		bdlist[index].low = htole32(dmaaddr);
		bdlist[index].high = htole32(PTR_UPPER32(dmaaddr));
		bdlist[index].length = htole32(this->blk);
		bdlist[index].flags = htole32(BDLIST_ENTRY_IOC);
		dmaaddr += this->blk;
		if (dmaaddr >= dmaend) {
			index++;
			break;
		}
	}

	DPRINTFN(1, ("%s: size=%d fmt=0x%4.4x index=%d\n",
	    __func__, this->bufsize, this->fmt, index));

	dmaaddr = AZALIA_DMA_DMAADDR(&this->bdlist);
	STR_WRITE_4(this, BDPL, dmaaddr);
	STR_WRITE_4(this, BDPU, PTR_UPPER32(dmaaddr));
	STR_WRITE_2(this, LVI, (index - 1) & HDA_SD_LVI_LVI);
	ctl2 = STR_READ_1(this, CTL2);
	STR_WRITE_1(this, CTL2,
	    (ctl2 & ~HDA_SD_CTL2_STRM) | (this->number << HDA_SD_CTL2_STRM_SHIFT));
	STR_WRITE_4(this, CBL, this->bufsize);
	STR_WRITE_2(this, FMT, this->fmt);

	err = azalia_codec_connect_stream(this);
	if (err)
		return EINVAL;

	intctl = AZ_READ_4(this->az, INTCTL);
	intctl |= this->intr_bit;
	AZ_WRITE_4(this->az, INTCTL, intctl);

	STR_WRITE_1(this, CTL, STR_READ_1(this, CTL) |
	    HDA_SD_CTL_DEIE | HDA_SD_CTL_FEIE | HDA_SD_CTL_IOCE |
	    HDA_SD_CTL_RUN);
	return (0);
}

int
azalia_stream_halt(stream_t *this)
{
	uint16_t ctl;

	ctl = STR_READ_2(this, CTL);
	ctl &= ~(HDA_SD_CTL_DEIE | HDA_SD_CTL_FEIE | HDA_SD_CTL_IOCE | HDA_SD_CTL_RUN);
	STR_WRITE_2(this, CTL, ctl);
	AZ_WRITE_4(this->az, INTCTL,
	    AZ_READ_4(this->az, INTCTL) & ~this->intr_bit);
	azalia_codec_disconnect_stream(this);

	return (0);
}

#define	HDA_SD_STS_BITS	"\20\3BCIS\4FIFOE\5DESE\6FIFORDY"

int
azalia_stream_intr(stream_t *this)
{
	unsigned int lpib, fifos, hwpos, cnt;
	u_int8_t sts;

	sts = STR_READ_1(this, STS);
	STR_WRITE_1(this, STS, sts |
	    HDA_SD_STS_DESE | HDA_SD_STS_FIFOE | HDA_SD_STS_BCIS);

	if (sts & (HDA_SD_STS_DESE | HDA_SD_STS_FIFOE))
		DPRINTF(("%s: stream %d: sts=%b\n", XNAME(this->az),
		    this->number, sts, HDA_SD_STS_BITS));

	if (sts & HDA_SD_STS_BCIS) {
		lpib = STR_READ_4(this, LPIB);
		fifos = STR_READ_2(this, FIFOS);
		if (fifos & 1)
			fifos++;
		hwpos = lpib;
		if (this->dir == AUMODE_PLAY)
			hwpos += fifos + 1;
		if (hwpos >= this->bufsize)
			hwpos -= this->bufsize;
		DPRINTFN(2, ("%s: stream %d, pos = %d -> %d, "
		    "lpib = %u, fifos = %u\n", __func__,
		    this->number, this->swpos, hwpos, lpib, fifos));
		cnt = 0;
		while (hwpos - this->swpos >= this->blk) {
			this->intr(this->intr_arg);
			this->swpos += this->blk;
			if (this->swpos == this->bufsize)
				this->swpos = 0;
			cnt++;
		}
		if (cnt != 1) {
			DPRINTF(("%s: stream %d: hwpos %u, %u intrs\n",
			    __func__, this->number, this->swpos, cnt));
		}
	}
	return (1);
}

/* ================================================================
 * MI audio entries
 * ================================================================ */

int
azalia_open(void *v, int flags)
{
	azalia_t *az;
	codec_t *codec;

	DPRINTFN(1, ("%s: flags=0x%x\n", __func__, flags));
	az = v;
	codec = &az->codecs[az->codecno];
	if ((flags & FWRITE) && codec->dacs.ngroups == 0)
		return ENODEV;
	if ((flags & FREAD) && codec->adcs.ngroups == 0)
		return ENODEV;
	codec->running++;
	return 0;
}

void
azalia_close(void *v)
{
	azalia_t *az;
	codec_t *codec;

	DPRINTFN(1, ("%s\n", __func__));
	az = v;
	codec = &az->codecs[az->codecno];
	codec->running--;
}

int
azalia_match_format(codec_t *codec, int mode, audio_params_t *par)
{
	int i;

	DPRINTFN(1, ("%s: mode=%d, want: enc=%d, prec=%d, chans=%d\n", __func__,
	    mode, par->encoding, par->precision, par->channels));

	for (i = 0; i < codec->nformats; i++) {
		if (mode != codec->formats[i].mode)
			continue;
		if (par->encoding != codec->formats[i].encoding)
			continue;
		if (par->precision != codec->formats[i].precision)
			continue;
		if (par->channels != codec->formats[i].channels)
			continue;
		break;
	}

	DPRINTFN(1, ("%s: return: enc=%d, prec=%d, chans=%d\n", __func__,
	    codec->formats[i].encoding, codec->formats[i].precision,
	    codec->formats[i].channels));

	return (i);
}

int
azalia_set_params_sub(codec_t *codec, int mode, audio_params_t *par)
{
	char *cmode;
	int i, j;
	uint ochan, oenc, opre;

	if (mode == AUMODE_PLAY)
		cmode = "play";
	else
		cmode = "record";

	ochan = par->channels;
	oenc = par->encoding;
	opre = par->precision;

	if ((mode == AUMODE_PLAY && codec->dacs.ngroups == 0) ||
	    (mode == AUMODE_RECORD && codec->adcs.ngroups == 0))
		return 0;

	i = azalia_match_format(codec, mode, par);
	if (i == codec->nformats && (par->precision != 16 || par->encoding !=
	    AUDIO_ENCODING_SLINEAR_LE)) {
		/* try with default encoding/precision */
		par->encoding = AUDIO_ENCODING_SLINEAR_LE;
		par->precision = 16;
		i = azalia_match_format(codec, mode, par);
	}
	if (i == codec->nformats && par->channels != 2) {
		/* try with default channels */
		par->encoding = oenc;
		par->precision = opre;
		par->channels = 2;
		i = azalia_match_format(codec, mode, par);
	}
	/* try with default everything */
	if (i == codec->nformats) {
		par->encoding = AUDIO_ENCODING_SLINEAR_LE;
		par->precision = 16;
		par->channels = 2;
		i = azalia_match_format(codec, mode, par);
		if (i == codec->nformats) {
			DPRINTF(("%s: can't find %s format %u/%u/%u\n",
			    __func__, cmode, par->encoding,
			    par->precision, par->channels));
			return EINVAL;
		}
	}
	if (codec->formats[i].frequency_type == 0) {
		DPRINTF(("%s: matched %s format %d has 0 frequencies\n",
		    __func__, cmode, i));
		return EINVAL;
	}

	for (j = 0; j < codec->formats[i].frequency_type; j++) {
		if (par->sample_rate != codec->formats[i].frequency[j])
			continue;
		break;
	}
	if (j == codec->formats[i].frequency_type) {
		/* try again with default */
		par->sample_rate = 48000;
		for (j = 0; j < codec->formats[i].frequency_type; j++) {
			if (par->sample_rate != codec->formats[i].frequency[j])
				continue;
			break;
		}
		if (j == codec->formats[i].frequency_type) {
			DPRINTF(("%s: can't find %s rate %lu\n",
			    __func__, cmode, par->sample_rate));
			return EINVAL;
		}
	}
	par->bps = AUDIO_BPS(par->precision);
	par->msb = 1;

	return (0);
}

int
azalia_set_params(void *v, int smode, int umode, audio_params_t *p,
    audio_params_t *r)
{
	azalia_t *az;
	codec_t *codec;
	int ret;

	az = v;
	codec = &az->codecs[az->codecno];
	if (codec->nformats == 0) {
		DPRINTF(("%s: codec has no formats\n", __func__));
		return EINVAL;
	}

	if (smode & AUMODE_RECORD && r != NULL) {
		ret = azalia_set_params_sub(codec, AUMODE_RECORD, r);
		if (ret)
			return (ret);
	}

	if (smode & AUMODE_PLAY && p != NULL) {
		ret = azalia_set_params_sub(codec, AUMODE_PLAY, p);
		if (ret)
			return (ret);
	}

	return (0);
}

int
azalia_round_blocksize(void *v, int blk)
{
	azalia_t *az;
	size_t size;

	blk &= ~0x7f;		/* must be multiple of 128 */
	if (blk <= 0)
		blk = 128;
	/* number of blocks must be <= HDA_BDL_MAX */
	az = v;
	size = az->pstream.buffer.size;
	if (size > HDA_BDL_MAX * blk) {
		blk = size / HDA_BDL_MAX;
		if (blk & 0x7f)
			blk = (blk + 0x7f) & ~0x7f;
	}
	DPRINTFN(1,("%s: resultant block size = %d\n", __func__, blk));
	return blk;
}

int
azalia_halt_output(void *v)
{
	azalia_t *az;

	DPRINTFN(1, ("%s\n", __func__));
	az = v;
	return azalia_stream_halt(&az->pstream);
}

int
azalia_halt_input(void *v)
{
	azalia_t *az;

	DPRINTFN(1, ("%s\n", __func__));
	az = v;
	return azalia_stream_halt(&az->rstream);
}

int
azalia_set_port(void *v, mixer_ctrl_t *mc)
{
	azalia_t *az;
	codec_t *co;
	const mixer_item_t *m;

	az = v;
	co = &az->codecs[az->codecno];
	if (mc->dev < 0 || mc->dev >= co->nmixers)
		return EINVAL;

	m = &co->mixers[mc->dev];
	if (mc->type != m->devinfo.type)
		return EINVAL;

	return azalia_mixer_set(co, m->nid, m->target, mc);
}

int
azalia_get_port(void *v, mixer_ctrl_t *mc)
{
	azalia_t *az;
	codec_t *co;
	const mixer_item_t *m;

	az = v;
	co = &az->codecs[az->codecno];
	if (mc->dev < 0 || mc->dev >= co->nmixers)
		return EINVAL;

	m = &co->mixers[mc->dev];
	mc->type = m->devinfo.type;

	return azalia_mixer_get(co, m->nid, m->target, mc);
}

int
azalia_query_devinfo(void *v, mixer_devinfo_t *mdev)
{
	azalia_t *az;
	const codec_t *co;

	az = v;
	co = &az->codecs[az->codecno];
	if (mdev->index < 0 || mdev->index >= co->nmixers)
		return ENXIO;
	*mdev = co->mixers[mdev->index].devinfo;
	return 0;
}

void *
azalia_allocm(void *v, int dir, size_t size, int pool, int flags)
{
	azalia_t *az;
	stream_t *stream;
	int err;

	az = v;
	stream = dir == AUMODE_PLAY ? &az->pstream : &az->rstream;
	err = azalia_alloc_dmamem(az, size, 128, &stream->buffer);
	if (err) {
		printf("%s: allocm failed\n", az->dev.dv_xname);
		return NULL;
	}
	return stream->buffer.addr;
}

void
azalia_freem(void *v, void *addr, int pool)
{
	azalia_t *az;
	stream_t *stream;

	az = v;
	if (addr == az->pstream.buffer.addr) {
		stream = &az->pstream;
	} else if (addr == az->rstream.buffer.addr) {
		stream = &az->rstream;
	} else {
		return;
	}
	azalia_free_dmamem(az, &stream->buffer);
}

size_t
azalia_round_buffersize(void *v, int dir, size_t size)
{
	size &= ~0x7f;		/* must be multiple of 128 */
	if (size <= 0)
		size = 128;
	return size;
}

int
azalia_get_props(void *v)
{
	return AUDIO_PROP_INDEPENDENT | AUDIO_PROP_FULLDUPLEX;
}

int
azalia_trigger_output(void *v, void *start, void *end, int blk,
    void (*intr)(void *), void *arg, audio_params_t *param)
{
	azalia_t *az;
	int err;
	uint16_t fmt;

	az = v;

	if (az->codecs[az->codecno].dacs.ngroups == 0) {
		DPRINTF(("%s: can't play without a DAC\n", __func__));
		return ENXIO;
	}

	err = azalia_params2fmt(param, &fmt);
	if (err)
		return(EINVAL);

	az->pstream.bufsize = (caddr_t)end - (caddr_t)start;
	az->pstream.blk = blk;
	az->pstream.fmt = fmt;
	az->pstream.intr = intr;
	az->pstream.intr_arg = arg;
	az->pstream.swpos = 0;

	return azalia_stream_start(&az->pstream);
}

int
azalia_trigger_input(void *v, void *start, void *end, int blk,
    void (*intr)(void *), void *arg, audio_params_t *param)
{
	azalia_t *az;
	int err;
	uint16_t fmt;

	DPRINTFN(1, ("%s: this=%p start=%p end=%p blk=%d {enc=%u %uch %ubit %luHz}\n",
	    __func__, v, start, end, blk, param->encoding, param->channels,
	    param->precision, param->sample_rate));

	az = v;

	if (az->codecs[az->codecno].adcs.ngroups == 0) {
		DPRINTF(("%s: can't record without an ADC\n", __func__));
		return ENXIO;
	}

	err = azalia_params2fmt(param, &fmt);
	if (err)
		return(EINVAL);

	az->rstream.bufsize = (caddr_t)end - (caddr_t)start;
	az->rstream.blk = blk;
	az->rstream.fmt = fmt;
	az->rstream.intr = intr;
	az->rstream.intr_arg = arg;
	az->rstream.swpos = 0;

	return azalia_stream_start(&az->rstream);
}

/* --------------------------------
 * helpers for MI audio functions
 * -------------------------------- */
int
azalia_params2fmt(const audio_params_t *param, uint16_t *fmt)
{
	uint16_t ret;

	ret = 0;
	if (param->channels > HDA_MAX_CHANNELS) {
		printf("%s: too many channels: %u\n", __func__,
		    param->channels);
		return EINVAL;
	}

	DPRINTFN(1, ("%s: prec=%d, chan=%d, rate=%ld\n", __func__,
	    param->precision, param->channels, param->sample_rate));

	/* XXX: can channels be >2 ? */
	ret |= param->channels - 1;

	switch (param->precision) {
	case 8:
		ret |= HDA_SD_FMT_BITS_8_16;
		break;
	case 16:
		ret |= HDA_SD_FMT_BITS_16_16;
		break;
	case 20:
		ret |= HDA_SD_FMT_BITS_20_32;
		break;
	case 24:
		ret |= HDA_SD_FMT_BITS_24_32;
		break;
	case 32:
		ret |= HDA_SD_FMT_BITS_32_32;
		break;
	}

	switch (param->sample_rate) {
	default:
	case 384000:
		printf("%s: invalid sample_rate: %lu\n", __func__,
		    param->sample_rate);
		return EINVAL;
	case 192000:
		ret |= HDA_SD_FMT_BASE_48 | HDA_SD_FMT_MULT_X4 | HDA_SD_FMT_DIV_BY1;
		break;
	case 176400:
		ret |= HDA_SD_FMT_BASE_44 | HDA_SD_FMT_MULT_X4 | HDA_SD_FMT_DIV_BY1;
		break;
	case 96000:
		ret |= HDA_SD_FMT_BASE_48 | HDA_SD_FMT_MULT_X2 | HDA_SD_FMT_DIV_BY1;
		break;
	case 88200:
		ret |= HDA_SD_FMT_BASE_44 | HDA_SD_FMT_MULT_X2 | HDA_SD_FMT_DIV_BY1;
		break;
	case 48000:
		ret |= HDA_SD_FMT_BASE_48 | HDA_SD_FMT_MULT_X1 | HDA_SD_FMT_DIV_BY1;
		break;
	case 44100:
		ret |= HDA_SD_FMT_BASE_44 | HDA_SD_FMT_MULT_X1 | HDA_SD_FMT_DIV_BY1;
		break;
	case 32000:
		ret |= HDA_SD_FMT_BASE_48 | HDA_SD_FMT_MULT_X2 | HDA_SD_FMT_DIV_BY3;
		break;
	case 22050:
		ret |= HDA_SD_FMT_BASE_44 | HDA_SD_FMT_MULT_X1 | HDA_SD_FMT_DIV_BY2;
		break;
	case 16000:
		ret |= HDA_SD_FMT_BASE_48 | HDA_SD_FMT_MULT_X1 | HDA_SD_FMT_DIV_BY3;
		break;
	case 11025:
		ret |= HDA_SD_FMT_BASE_44 | HDA_SD_FMT_MULT_X1 | HDA_SD_FMT_DIV_BY4;
		break;
	case 8000:
		ret |= HDA_SD_FMT_BASE_48 | HDA_SD_FMT_MULT_X1 | HDA_SD_FMT_DIV_BY6;
		break;
	}
	*fmt = ret;
	return 0;
}
@


1.236
log
@Power off all codecs on shutdown to eliminate static noise in speakers
or headphones on reboot.

From Manuel Giraud <manuel () ledu-giraud ! fr>
Tweaks & ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.235 2017/04/11 14:43:49 dhill Exp $	*/
a48 1
#include <sys/types.h>
@


1.235
log
@Partially revert previous mallocarray conversions that contain
constants.

The consensus is that if both operands are constant, we don't need
mallocarray.  Reminded by tedu@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.234 2017/04/09 18:16:00 dhill Exp $	*/
d700 2
d708 9
@


1.234
log
@Convert some malloc(9) to mallocarray(9)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.233 2017/03/19 11:18:26 jsg Exp $	*/
d1100 1
a1100 1
		az->unsolq = mallocarray(UNSOLQ_SIZE, sizeof(rirb_entry_t),
@


1.233
log
@Enable snooping on Kaby Lake U/Y PCH HDA to avoid audio glitches as we
do on all the other recent Intel platforms.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.232 2017/02/10 08:13:37 ratchov Exp $	*/
d1100 1
a1100 1
		az->unsolq = malloc(sizeof(rirb_entry_t) * UNSOLQ_SIZE,
@


1.232
log
@Update link to intel HDA spec. From
Alexey Suslikov <alexey.suslikov at gmail.com>.
Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.231 2017/01/10 00:36:25 jsg Exp $	*/
d458 1
@


1.231
log
@Enable snooping on Braswell.  Fixes audio distortion on Acer TravelMate
B117-M.  From Martin Ziemer.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.230 2016/12/08 17:23:33 ratchov Exp $	*/
d35 2
a36 1
 *	ftp://download.intel.com/standards/hdaudio/pdf/HDAudio_03.pdf
@


1.230
log
@Return ENODEV if playback is requested on devices with no DACs or
recording is requested on devices with no ADCs. Many thanks to
Bryan Vyhmeister <bryan at bsdjournal.net> for testing & debugging this.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.229 2016/09/19 06:46:44 ratchov Exp $	*/
d459 1
@


1.229
log
@Remove unused getdev() audio driver functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.228 2016/09/14 06:12:19 ratchov Exp $	*/
d44 1
d3846 4
@


1.228
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.226 2016/02/19 23:46:56 jsg Exp $	*/
a256 1
int	azalia_getdev(void *, struct audio_device *);
a303 1
	azalia_getdev,
a4035 13
}

int
azalia_getdev(void *v, struct audio_device *dev)
{
	azalia_t *az;

	az = v;
	strlcpy(dev->name, "HD-Audio", MAX_AUDIO_DEV_LEN);
	snprintf(dev->version, MAX_AUDIO_DEV_LEN,
	    "%d.%d", AZ_READ_1(az, VMAJ), AZ_READ_1(az, VMIN));
	strlcpy(dev->config, XNAME(az), MAX_AUDIO_DEV_LEN);
	return 0;
@


1.227
log
@enable snooping on Intel 100 Series LP HDA
@
text
@a251 1
int	azalia_query_encoding(void *, audio_encoding_t *);
a253 1
void	azalia_get_default_params(void *, int, struct audio_params*);
a270 1
int	azalia_create_encodings(codec_t *);
a294 2
	NULL,			/* drain */
	azalia_query_encoding,
a312 1
	NULL,			/* mappage */
d315 1
a315 2
	azalia_trigger_input,
	azalia_get_default_params
a2601 6
	if (this->encs != NULL) {
		free(this->encs, M_DEVBUF, 0);
		this->encs = NULL;
	}
	this->nencs = 0;

d2640 1
a2640 1
	int nbits, c, chan, i, err;
a2748 3
	err = azalia_create_encodings(this);
	if (err)
		return err;
a3863 28
azalia_query_encoding(void *v, audio_encoding_t *enc)
{
	azalia_t *az;
	codec_t *codec;

	az = v;
	codec = &az->codecs[az->codecno];

	if (enc->index < 0 || enc->index >= codec->nencs)
		return (EINVAL);

	*enc = codec->encs[enc->index];

	return (0);
}

void
azalia_get_default_params(void *addr, int mode, struct audio_params *params)
{
	params->sample_rate = 48000;
	params->encoding = AUDIO_ENCODING_SLINEAR_LE;
	params->precision = 16;
	params->bps = 2;
	params->msb = 1;
	params->channels = 2;
}

int
d3907 1
a3907 2
	    (mode == AUMODE_RECORD && codec->adcs.ngroups == 0)) {
		azalia_get_default_params(NULL, mode, par);
a3908 1
	}
a4295 63
}

int
azalia_create_encodings(codec_t *this)
{
	struct audio_format f;
	int encs[16];
	int enc, nencs;
	int i, j;

	nencs = 0;
	for (i = 0; i < this->nformats && nencs < 16; i++) {
		f = this->formats[i];
		enc = f.precision << 8 | f.encoding;
		for (j = 0; j < nencs; j++) {
			if (encs[j] == enc)
				break;
		}
		if (j < nencs)
			continue;
		encs[j] = enc;
		nencs++;
	}

	if (this->encs != NULL)
		free(this->encs, M_DEVBUF, 0);
	this->nencs = 0;
	this->encs = mallocarray(nencs, sizeof(struct audio_encoding),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (this->encs == NULL) {
		printf("%s: out of memory in %s\n",
		    XNAME(this->az), __func__);
		return ENOMEM;
	}

	this->nencs = nencs;
	for (i = 0; i < this->nencs; i++) {
		this->encs[i].index = i;
		this->encs[i].encoding = encs[i] & 0xff;
		this->encs[i].precision = encs[i] >> 8;
		this->encs[i].bps = AUDIO_BPS(encs[i] >> 8);
		this->encs[i].msb = 1;
		this->encs[i].flags = 0;
		switch (this->encs[i].encoding) {
		case AUDIO_ENCODING_SLINEAR_LE:
			strlcpy(this->encs[i].name,
			    this->encs[i].precision == 8 ?
			    AudioEslinear : AudioEslinear_le,
			    sizeof this->encs[i].name);
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			strlcpy(this->encs[i].name,
			    this->encs[i].precision == 8 ?
			    AudioEulinear : AudioEulinear_le,
			    sizeof this->encs[i].name);
			break;
		default:
			DPRINTF(("%s: unknown format\n", __func__));
			break;
		}
	}

	return (0);
@


1.226
log
@enable snooping on Intel C610
from Alexandre H
add C600 as well while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.225 2015/12/17 15:07:57 ratchov Exp $	*/
d464 1
@


1.225
log
@If CORB/RIRB are not running, log error message unconditonnaly
and return error. From Alexey Suslikov <alexey.suslikov at gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.224 2015/12/09 14:25:46 ratchov Exp $	*/
d464 2
@


1.224
log
@No need to check if size = az->pstream.buffer.size is zero, as
this is handled in audio(4) layer. From
Alexey Suslikov <alexey.suslikov at gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.223 2015/12/07 03:04:45 jsg Exp $	*/
a1173 1
#ifdef DIAGNOSTIC
d1175 1
a1175 1
		DPRINTF(("%s: CORB is not running.\n", XNAME(az)));
a1177 1
#endif
a1197 1
#ifdef DIAGNOSTIC
d1199 1
a1199 1
		DPRINTF(("%s: RIRB is not running.\n", XNAME(az)));
a1201 1
#endif
@


1.223
log
@enable snooping on Intel 100 Series HDA
from and tested by daniel@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.222 2015/07/29 08:06:29 ratchov Exp $	*/
a4057 6
#ifdef DIAGNOSTIC
	if (size <= 0) {
		printf("%s: size is 0", __func__);
		return 256;
	}
#endif
@


1.222
log
@Rework buffer position reporting code.

- use simpler data structures (makes the code shorter).

- if multiple interrupts are missed, call audio(4) as many times as we
  missed interrupts (unless the pointer wrapped, which this is
  undetectable, but upper layer handles it)

- fetch the link fifos size in the interrupt handler, as, according to
  the spec it may change dynamically.

- certain devices expose the last offset of the link fifo size instead
  of the fifo size itself; workaround this by incrementing the
  reported link fifo size if it's odd. Fixes recovery after missed
  interrupts on asus eeepcs, maybe others.

ok deraadt, help from armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.221 2015/05/11 06:46:21 ratchov Exp $	*/
d463 1
@


1.221
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.220 2015/02/10 06:19:44 dlg Exp $	*/
d126 1
a126 5
	int nblks;			/* # of blocks in the buffer */
	u_long swpos;			/* position in the audio(4) layer */
	u_int last_hwpos;		/* last known lpib */
	u_long hw_base;			/* this + lpib = overall position */
	u_int pos_offs;			/* hardware fifo space */
a3670 1
	this->pos_offs = STR_READ_2(this, FIFOS) & 0xff;
a3761 1
	this->nblks = index;
d3810 1
a3810 1
	u_long hwpos, swpos;
d3822 14
a3835 16
		hwpos = STR_READ_4(this, LPIB) + this->pos_offs;
		if (hwpos < this->last_hwpos)
			this->hw_base += this->blk * this->nblks;
		this->last_hwpos = hwpos;
		hwpos += this->hw_base;

		/*
		 * We got the interrupt, so we should advance our count.
		 * But we might *not* advance the count if software is
		 * ahead.
		 */
		swpos = this->swpos + this->blk;

		if (hwpos >= swpos + this->blk) {
			DPRINTF(("%s: stream %d: swpos %lu hwpos %lu, adding intr\n",
			    __func__, this->number, swpos, hwpos));
d3838 7
a3844 4
		} else if (swpos >= hwpos + this->blk) {
			DPRINTF(("%s: stream %d: swpos %lu hwpos %lu, ignoring intr\n",
			    __func__, this->number, swpos, hwpos));
			return (1);
a3845 2
		this->intr(this->intr_arg);
		this->swpos += this->blk;
a4228 1

a4229 2
	az->pstream.last_hwpos = 0;
	az->pstream.hw_base = 0;
a4261 1

a4262 2
	az->rstream.last_hwpos = 0;
	az->rstream.hw_base = 0;
@


1.220
log
@remove some very MD debug code that was reaching into x86 mplocks
to try and figure things out.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.219 2015/01/20 09:46:31 ratchov Exp $	*/
a49 1
#include <dev/auconv.h>
a3911 2
	params->sw_code = NULL;
	params->factor = 1;
a3943 1
	void (*swcode)(void *, u_char *, int) = NULL;
a3963 14
	if (i == codec->nformats && par->channels == 1) {
		/* find a 2 channel format and emulate mono */
		par->channels = 2;
		i = azalia_match_format(codec, mode, par);
		if (i != codec->nformats) {
			par->factor = 2;
			if (mode == AUMODE_RECORD)
				swcode = linear16_decimator;
			else
				swcode = noswap_bytes_mts;
			par->channels = 1;
		}
	}
	par->channels = ochan;
a3970 14
	if (i == codec->nformats && par->channels == 1) {
		/* find a 2 channel format and emulate mono */
		par->channels = 2;
		i = azalia_match_format(codec, mode, par);
		if (i != codec->nformats) {
			par->factor = 2;
			if (mode == AUMODE_RECORD)
				swcode = linear16_decimator;
			else
				swcode = noswap_bytes_mts;
			par->channels = 1;
		}
	}
	par->channels = ochan;
a4015 1
	par->sw_code = swcode;
d4298 2
a4299 5
	/* Only mono is emulated, and it is emulated from stereo. */
	if (param->sw_code != NULL)
		ret |= 1;
	else
		ret |= param->channels - 1;
@


1.219
log
@Check for out-of-range indices when searching the default dac and adc.
Fix from Alexey Suslikov <alexey.suslikov at gmail.com>. Thanks!

tested by many, ok armani
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.218 2015/01/13 01:54:19 jsg Exp $	*/
a664 8
/*
#define AZALIA_LOG_MP
*/
#ifdef AZALIA_LOG_MP
#include <machine/lock.h>
#include <machine/cpufunc.h>
#endif

a667 3
#ifdef AZALIA_LOG_MP
	volatile struct cpu_info *ci;
#endif
a671 9
#ifdef AZALIA_LOG_MP
	ci = kernel_lock.mpl_cpu;
	if (ci == NULL)
		printf("azalia_intr: mp not held\n");
	else {
		printf("azalia_intr: lock held by %p, id = %u\n",
		    ci, ci->ci_cpuid);
	}
#endif
@


1.218
log
@Enable snooping on Bay Trail HD Audio.
Fixes audio problems on an Asus J1800I-C
reported by Jan Stary.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.217 2014/09/24 08:35:12 mpi Exp $	*/
d2352 17
a2368 8
		} else {
			index = w->connections[w->selected];
			if (VALID_WIDGET_NID(index, this)) {
				ret = azalia_codec_find_defdac(this, index,
				    depth);
				if (ret >= 0)
					return ret;
			}
d2406 17
a2422 8
		} else {
			index = w->connections[w->selected];
			if (VALID_WIDGET_NID(index, this)) {
				ret = azalia_codec_find_defadc_sub(this, node,
				    index, depth);
				if (ret >= 0)
					return ret;
			}
@


1.217
log
@Kill two generic DVACT_DEACTIVATE handlers since this event is now
autoconf(9)ally passed to the children of a device.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.216 2014/08/13 07:45:37 jsg Exp $	*/
d467 1
@


1.216
log
@match on Intel 9 series and 9 series LP PCH, and add 8 series KT to puc
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.215 2014/07/13 23:10:23 deraadt Exp $	*/
a147 1
	struct device *audiodev;
d553 1
a553 1
	sc->audiodev = audio_attach_mi(&azalia_hw_if, sc, &sc->dev);
a578 4
	case DVACT_DEACTIVATE:
		if (sc->audiodev != NULL)
			rv = config_deactivate(sc->audiodev);
		break;
d603 1
a603 4
	if (az->audiodev != NULL) {
		config_detach(az->audiodev, flags);
		az->audiodev = NULL;
	}
@


1.215
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.214 2014/07/12 18:48:51 tedu Exp $	*/
d466 2
@


1.214
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.213 2014/07/10 14:21:20 deraadt Exp $	*/
d832 1
a832 1
	az->codecs = malloc(sizeof(codec_t) * az->ncodecs, M_DEVBUF,
d1634 2
a1635 1
	this->w = malloc(sizeof(widget_t) * this->wend, M_DEVBUF, M_NOWAIT | M_ZERO);
d2058 1
a2058 1
	this->opins = malloc(nopins * sizeof(struct io_pin), M_DEVBUF,
d2076 1
a2076 1
	this->opins_d = malloc(nopins_d * sizeof(struct io_pin), M_DEVBUF,
d2094 1
a2094 1
	this->ipins = malloc(nipins * sizeof(struct io_pin), M_DEVBUF,
d2112 1
a2112 1
	this->ipins_d = malloc(nipins_d * sizeof(struct io_pin), M_DEVBUF,
d2165 1
a2165 1
	convs = malloc(this->na_dacs * sizeof(nid_t), M_DEVBUF,
d2728 1
a2728 1
	this->formats = malloc(sizeof(struct audio_format) * variation,
d3415 1
a3415 1
	this->connections = malloc(sizeof(nid_t) * nconn, M_DEVBUF, M_NOWAIT);
d4431 1
a4431 1
	this->encs = malloc(sizeof(struct audio_encoding) * nencs,
@


1.213
log
@remove most of the boolean_t infection outside uvm/ddb/pmap; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.212 2014/05/17 12:45:53 ratchov Exp $	*/
d631 1
a631 1
		free(az->codecs, M_DEVBUF);
d641 1
a641 1
		free(az->unsolq, M_DEVBUF);
d2220 1
a2220 1
	free(convs, M_DEVBUF);
d2615 1
a2615 1
		free(this->formats, M_DEVBUF);
d2621 1
a2621 1
		free(this->encs, M_DEVBUF);
d2627 1
a2627 1
		free(this->opins, M_DEVBUF);
d2633 1
a2633 1
		free(this->opins_d, M_DEVBUF);
d2639 1
a2639 1
		free(this->ipins, M_DEVBUF);
d2645 1
a2645 1
		free(this->ipins_d, M_DEVBUF);
d2651 1
a2651 1
		free(this->w, M_DEVBUF);
d2725 1
a2725 1
		free(this->formats, M_DEVBUF);
d4428 1
a4428 1
		free(this->encs, M_DEVBUF);
@


1.212
log
@fix format mistakes visible if AZALIA_DEBUG is defined
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.211 2014/03/08 22:49:00 tedu Exp $	*/
a48 1
#include <uvm/uvm_param.h>
d177 1
a177 1
	boolean_t unsolq_kick;
d180 1
a180 1
	boolean_t ok64;
d1155 1
a1155 1
	az->unsolq_kick = FALSE;
d1273 1
a1273 1
	az->unsolq_kick = TRUE;
d1286 1
a1286 1
	az->unsolq_kick = FALSE;
@


1.211
log
@better loop conditions. ok kettenis ratchov sasano
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.210 2014/02/25 18:40:37 kettenis Exp $	*/
d4050 1
a4050 1
			DPRINTF(("%s: can't find %s rate %u\n",
d4292 1
a4292 1
	DPRINTFN(1, ("%s: this=%p start=%p end=%p blk=%d {enc=%u %uch %ubit %uHz}\n",
d4335 1
a4335 1
	DPRINTFN(1, ("%s: prec=%d, chan=%d, rate=%d\n", __func__,
@


1.210
log
@Wait for the RIRB DMA engine to come ready.  Needed on the audio device
integrated in the Vortex86EX SoC.  Based on a diff by sasano@@.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.209 2013/12/30 10:53:30 jsg Exp $	*/
d774 1
a774 1
	for (i = 5000; i >= 0; i--) {
d780 1
a780 1
	if (i <= 0) {
d787 1
a787 1
	for (i = 5000; i >= 0; i--) {
d793 1
a793 1
	if (i <= 0) {
d1019 1
a1019 1
		for (i = 5000; i >= 0; i--) {
d1025 1
a1025 1
		if (i <= 0) {
d1064 1
a1064 1
	for (i = 5000; i >= 0; i--) {
d1070 1
a1070 1
	if (i <= 0) {
d1096 1
a1096 1
		for (i = 5000; i >= 0; i--) {
d1102 1
a1102 1
		if (i <= 0) {
d1164 1
a1164 1
	for (i = 5000; i >= 0; i--) {
d1170 1
a1170 1
	if (i <= 0) {
d1247 1
a1247 1
		if (i <= 0) {
d3711 1
a3711 1
	for (i = 5000; i >= 0; i--) {
d3717 1
a3717 1
	if (i <= 0) {
d3724 1
a3724 1
	for (i = 5000; i >= 0; i--) {
d3730 1
a3730 1
	if (i <= 0) {
@


1.209
log
@Enable snooping on Lynx Point-LP HD Audio.
Fixes audio problems on an Acer Aspire E1 572G
reported by Mark Rowland.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.208 2013/12/06 21:03:03 deraadt Exp $	*/
d1113 1
a1113 1
	int err;
d1164 10
@


1.208
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.207 2013/11/09 05:51:11 jsg Exp $	*/
d466 1
@


1.207
log
@enable snooping on Intel 8 Series HD Audio
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.206 2013/05/30 16:15:02 deraadt Exp $	*/
a567 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
d581 3
@


1.206
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.205 2013/05/24 07:58:46 ratchov Exp $	*/
d465 1
@


1.205
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.204 2013/05/15 08:29:24 ratchov Exp $	*/
a552 2
	shutdownhook_establish(azalia_shutdown, sc);

d572 3
@


1.204
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.203 2013/02/09 21:02:17 miod Exp $	*/
d531 2
a532 2
	sc->ih = pci_intr_establish(pa->pa_pc, ih, IPL_AUDIO, azalia_intr,
	    sc, sc->dev.dv_xname);
@


1.203
log
@Replace a bunch of if () else if () else if () else if () ... with that
modern brand new construct known as `switch'.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.202 2012/10/19 15:20:42 deraadt Exp $	*/
d668 8
d679 3
d686 10
d697 2
a698 1
	if (intsts == 0 || intsts == 0xffffffff)
d700 1
d720 1
a720 1

d1169 1
a1169 1
	int err, s;
d1171 1
a1171 1
	s = splaudio();
d1178 1
a1178 2
	splx(s);

a3787 1

@


1.202
log
@andre.s@@list.ru has a laptop which does not bring the azalia out of
D3 state, so the attach funciton must do this.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.201 2012/08/12 19:32:22 kettenis Exp $	*/
d4328 4
a4331 2
	if (param->sample_rate == 384000) {
		printf("%s: invalid sample_rate: %u\n", __func__,
d4334 1
a4334 1
	} else if (param->sample_rate == 192000) {
d4336 2
a4337 1
	} else if (param->sample_rate == 176400) {
d4339 2
a4340 1
	} else if (param->sample_rate == 96000) {
d4342 2
a4343 1
	} else if (param->sample_rate == 88200) {
d4345 2
a4346 1
	} else if (param->sample_rate == 48000) {
d4348 2
a4349 1
	} else if (param->sample_rate == 44100) {
d4351 2
a4352 1
	} else if (param->sample_rate == 32000) {
d4354 2
a4355 1
	} else if (param->sample_rate == 22050) {
d4357 2
a4358 1
	} else if (param->sample_rate == 16000) {
d4360 2
a4361 1
	} else if (param->sample_rate == 11025) {
d4363 2
a4364 1
	} else if (param->sample_rate == 8000) {
d4366 1
a4366 4
	} else {
		printf("%s: invalid sample_rate: %u\n", __func__,
		    param->sample_rate);
		return EINVAL;
@


1.201
log
@Make sure snooping is enabled on Intel 7 Series HD Audio.

Tested by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.200 2012/05/10 22:46:48 ratchov Exp $	*/
d500 2
@


1.200
log
@Enable PCI snoop on the AMD Hudson 2. With help from Juan Francisco
Cantero Hurtado <iam at juanfra.info>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.199 2011/09/19 07:36:59 kettenis Exp $	*/
d464 1
@


1.199
log
@Make sure snooping is enabled on Intel HDA variants.  Fixes audio on my
x220.  Suggested before by jakemsr.

ok deraadt@@, ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.198 2011/07/03 15:47:16 matthew Exp $	*/
d400 1
@


1.198
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.197 2011/06/02 18:36:49 kettenis Exp $	*/
d358 3
d452 16
a467 1

@


1.197
log
@Enable MSI.

"i think more pci_intr_map_msi should go in"
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.196 2011/06/02 18:02:47 kettenis Exp $	*/
a546 2
	case DVACT_ACTIVATE:
		break;
@


1.196
log
@Move the code that disables MSI out of azalia_configure_pci(), such that we
don't run it upon resume.  We now save and restore the MSI registers in the
generic PCI code, so it is no longer necessary and will hurt us when we
actually start using MSI.

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.195 2011/04/24 20:31:26 jakemsr Exp $	*/
d504 1
a504 1
	if (pci_intr_map(pa, &ih)) {
@


1.195
log
@in azalia_intr():
* deal with the possibility of the hardware being detached, as could
happen with expresscard.  from deraadt@@
* only return 1 if an interrupt was actually serviced.  fixes "constant
interrupts when the device isn't being used" issue reported by oga@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.194 2011/04/10 17:10:08 jakemsr Exp $	*/
a392 7
	/* disable MSI, use INTx instead */
	if (PCI_VENDOR(az->pciid) == PCI_VENDOR_INTEL) {
		reg = azalia_pci_read(az->pc, az->tag, ICH_PCI_MMC);
		reg &= ~(ICH_PCI_MMC_ME);
		azalia_pci_write(az->pc, az->tag, ICH_PCI_MMC, reg);
	}

d472 1
d495 7
@


1.194
log
@bring back changes in r 1.192:

detach happens after the hardware is gone, so don't try to touch
the hardware in the detach path

but azalia_pci_detach is called if the device coiuld not be initialized.
in that case, shut the hardware down.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.193 2011/04/08 19:26:07 deraadt Exp $	*/
d652 1
d655 2
a656 2
	if (intsts == 0)
		return (0);
d660 1
a660 1
	if (intsts & az->pstream.intr_bit)
d662 2
d665 1
a665 1
	if (intsts & az->rstream.intr_bit)
d667 2
d672 1
a672 1
	    (AZ_READ_1(az, RIRBSTS) & HDA_RIRBSTS_RINTFL))
d674 2
d677 1
a677 1
	return (1);
@


1.193
log
@backout previous (which has some interrupt spin problem, sort of diagnosed
by claudio to be related to this commit) until jakemsr has time to fix it
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.192 2011/04/04 18:05:31 jakemsr Exp $	*/
d164 3
a166 2
	int detached;		/* nonzero if audio(4) is not attached */

a212 1
int	azalia_delete_corb(azalia_t *);
a214 1
int	azalia_delete_rirb(azalia_t *);
a251 1
int	azalia_stream_delete(stream_t *, azalia_t *);
d535 1
a535 1
	printf("%s: initialization failure, detaching\n", XNAME(sc));
a536 1
	sc->detached = 1;
d569 1
a569 1
	azalia_t *az;
d574 9
a582 1
	az = (azalia_t*)self;
d588 5
a592 3
	/* disable unsolicited response */
	gctl = AZ_READ_4(az, GCTL);
	AZ_WRITE_4(az, GCTL, gctl & ~(HDA_GCTL_UNSOL));
d597 4
a600 2
	azalia_stream_delete(&az->rstream, az);
	azalia_stream_delete(&az->pstream, az);
d613 8
a620 2
	azalia_delete_corb(az);
	azalia_delete_rirb(az);
d622 10
a631 7
	DPRINTF(("%s: disable interrupts\n", __func__));
	AZ_WRITE_4(az, INTCTL, 0);

	DPRINTF(("%s: clear interrupts\n", __func__));
	AZ_WRITE_4(az, INTSTS, HDA_INTSTS_CIS | HDA_INTSTS_GIS);
	AZ_WRITE_2(az, STATESTS, HDA_STATESTS_SDIWAKE);
	AZ_WRITE_1(az, RIRBSTS, HDA_RIRBSTS_RINTFL | HDA_RIRBSTS_RIRBOIS);
d642 2
a1033 21
azalia_delete_corb(azalia_t *az)
{
	int i;
	uint8_t corbctl;

	if (az->corb_dma.addr == NULL)
		return 0;
	/* stop the CORB */
	corbctl = AZ_READ_1(az, CORBCTL);
	AZ_WRITE_1(az, CORBCTL, corbctl & ~HDA_CORBCTL_CORBRUN);
	for (i = 5000; i >= 0; i--) {
		DELAY(10);
		corbctl = AZ_READ_1(az, CORBCTL);
		if ((corbctl & HDA_CORBCTL_CORBRUN) == 0)
			break;
	}
	azalia_free_dmamem(az, &az->corb_dma);
	return 0;
}

int
a1114 25
azalia_delete_rirb(azalia_t *az)
{
	int i;
	uint8_t rirbctl;

	if (az->unsolq != NULL) {
		free(az->unsolq, M_DEVBUF);
		az->unsolq = NULL;
	}
	if (az->rirb_dma.addr == NULL)
		return 0;
	/* stop the RIRB */
	rirbctl = AZ_READ_1(az, RIRBCTL);
	AZ_WRITE_1(az, RIRBCTL, rirbctl & ~HDA_RIRBCTL_RIRBDMAEN);
	for (i = 5000; i >= 0; i--) {
		DELAY(10);
		rirbctl = AZ_READ_1(az, RIRBCTL);
		if ((rirbctl & HDA_RIRBCTL_RIRBDMAEN) == 0)
			break;
	}
	azalia_free_dmamem(az, &az->rirb_dma);
	return 0;
}

int
a3628 14
	return 0;
}

int
azalia_stream_delete(stream_t *this, azalia_t *az)
{
	if (this->bdlist.addr == NULL)
		return 0;

	/* disable stream interrupts */
	STR_WRITE_1(this, CTL, STR_READ_1(this, CTL) |
	    ~(HDA_SD_CTL_DEIE | HDA_SD_CTL_FEIE | HDA_SD_CTL_IOCE));

	azalia_free_dmamem(az, &this->bdlist);
@


1.192
log
@detach happens after the hardware is gone, so don't try to touch
the hardware in the detach path
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.191 2011/03/04 22:04:21 jakemsr Exp $	*/
d212 1
d215 1
d253 1
d573 1
d583 4
d590 2
a591 4
	if (az->rstream.bdlist.addr != NULL)
		azalia_free_dmamem(az, &az->rstream.bdlist);
	if (az->pstream.bdlist.addr != NULL)
		azalia_free_dmamem(az, &az->pstream.bdlist);
d604 10
a613 8
	if (az->corb_dma.addr != NULL)
		azalia_free_dmamem(az, &az->corb_dma);
	if (az->rirb_dma.addr != NULL)
		azalia_free_dmamem(az, &az->rirb_dma);
	if (az->unsolq != NULL) {
		free(az->unsolq, M_DEVBUF);
		az->unsolq = NULL;
	}
d1014 21
d1116 25
d3655 14
@


1.191
log
@gather most pci conf register manipulation into a new function,
azalia_configure_pci().  use that function in azalia_attach() and
azalia_resume().  fixes post-resume "static" during playback for
some machines with ATI chipsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.190 2011/02/17 17:38:55 jakemsr Exp $	*/
a211 1
int	azalia_delete_corb(azalia_t *);
a213 1
int	azalia_delete_rirb(azalia_t *);
a250 1
int	azalia_stream_delete(stream_t *, azalia_t *);
a569 1
	uint32_t gctl;
a578 4
	/* disable unsolicited response */
	gctl = AZ_READ_4(az, GCTL);
	AZ_WRITE_4(az, GCTL, gctl & ~(HDA_GCTL_UNSOL));

d582 4
a585 2
	azalia_stream_delete(&az->rstream, az);
	azalia_stream_delete(&az->pstream, az);
d598 8
a605 10
	azalia_delete_corb(az);
	azalia_delete_rirb(az);

	DPRINTF(("%s: disable interrupts\n", __func__));
	AZ_WRITE_4(az, INTCTL, 0);

	DPRINTF(("%s: clear interrupts\n", __func__));
	AZ_WRITE_4(az, INTSTS, HDA_INTSTS_CIS | HDA_INTSTS_GIS);
	AZ_WRITE_2(az, STATESTS, HDA_STATESTS_SDIWAKE);
	AZ_WRITE_1(az, RIRBSTS, HDA_RIRBSTS_RINTFL | HDA_RIRBSTS_RIRBOIS);
a1005 21
azalia_delete_corb(azalia_t *az)
{
	int i;
	uint8_t corbctl;

	if (az->corb_dma.addr == NULL)
		return 0;
	/* stop the CORB */
	corbctl = AZ_READ_1(az, CORBCTL);
	AZ_WRITE_1(az, CORBCTL, corbctl & ~HDA_CORBCTL_CORBRUN);
	for (i = 5000; i >= 0; i--) {
		DELAY(10);
		corbctl = AZ_READ_1(az, CORBCTL);
		if ((corbctl & HDA_CORBCTL_CORBRUN) == 0)
			break;
	}
	azalia_free_dmamem(az, &az->corb_dma);
	return 0;
}

int
a1086 25
azalia_delete_rirb(azalia_t *az)
{
	int i;
	uint8_t rirbctl;

	if (az->unsolq != NULL) {
		free(az->unsolq, M_DEVBUF);
		az->unsolq = NULL;
	}
	if (az->rirb_dma.addr == NULL)
		return 0;
	/* stop the RIRB */
	rirbctl = AZ_READ_1(az, RIRBCTL);
	AZ_WRITE_1(az, RIRBCTL, rirbctl & ~HDA_RIRBCTL_RIRBDMAEN);
	for (i = 5000; i >= 0; i--) {
		DELAY(10);
		rirbctl = AZ_READ_1(az, RIRBCTL);
		if ((rirbctl & HDA_RIRBCTL_RIRBDMAEN) == 0)
			break;
	}
	azalia_free_dmamem(az, &az->rirb_dma);
	return 0;
}

int
a3600 14
	return 0;
}

int
azalia_stream_delete(stream_t *this, azalia_t *az)
{
	if (this->bdlist.addr == NULL)
		return 0;

	/* disable stream interrupts */
	STR_WRITE_1(this, CTL, STR_READ_1(this, CTL) |
	    ~(HDA_SD_CTL_DEIE | HDA_SD_CTL_FEIE | HDA_SD_CTL_IOCE));

	azalia_free_dmamem(az, &this->bdlist);
@


1.190
log
@if changing the default speaker connection, be sure it's both a
valid connection and a valid converter.  fixes speaker auto-mute
for some IDT codecs.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.189 2011/02/17 16:02:22 jakemsr Exp $	*/
d201 1
a378 12
int
azalia_pci_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa;

	pa = aux;
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_MULTIMEDIA
	    && PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_MULTIMEDIA_HDAUDIO)
		return 1;
	return 0;
}

d380 1
a380 1
azalia_pci_attach(struct device *parent, struct device *self, void *aux)
a381 2
	azalia_t *sc;
	struct pci_attach_args *pa;
a382 2
	pci_intr_handle_t ih;
	const char *interrupt_str;
a384 13
	sc = (azalia_t*)self;
	pa = aux;

	sc->dmat = pa->pa_dmat;

	v = pci_conf_read(pa->pa_pc, pa->pa_tag, ICH_PCI_HDBARL);
	v &= PCI_MAPREG_TYPE_MASK | PCI_MAPREG_MEM_TYPE_MASK;
	if (pci_mapreg_map(pa, ICH_PCI_HDBARL, v, 0,
			   &sc->iot, &sc->ioh, NULL, &sc->map_size, 0)) {
		printf(": can't map device i/o space\n");
		return;
	}

d386 2
a387 2
	v = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
d391 2
a392 2
	v = pci_conf_read(pa->pa_pc, pa->pa_tag, ICH_PCI_HDTCSEL);
	pci_conf_write(pa->pa_pc, pa->pa_tag, ICH_PCI_HDTCSEL,
d396 2
a397 2
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL) {
		reg = azalia_pci_read(pa->pa_pc, pa->pa_tag, ICH_PCI_MMC);
d399 1
a399 1
		azalia_pci_write(pa->pa_pc, pa->pa_tag, ICH_PCI_MMC, reg);
d403 1
a403 1
	switch (PCI_PRODUCT(pa->pa_id)) {
d406 1
a406 1
		reg = azalia_pci_read(pa->pa_pc, pa->pa_tag, ATI_PCIE_SNOOP_REG);
d409 1
a409 1
		azalia_pci_write(pa->pa_pc, pa->pa_tag, ATI_PCIE_SNOOP_REG, reg);
d433 1
a433 1
		reg = azalia_pci_read(pa->pa_pc, pa->pa_tag,
d436 1
a436 1
		azalia_pci_write(pa->pa_pc, pa->pa_tag,
d439 1
a439 1
		reg = azalia_pci_read(pa->pa_pc, pa->pa_tag,
d442 1
a442 1
		azalia_pci_write(pa->pa_pc, pa->pa_tag,
d445 1
a445 1
		reg = azalia_pci_read(pa->pa_pc, pa->pa_tag,
d449 1
a449 1
		azalia_pci_write(pa->pa_pc, pa->pa_tag,
d452 1
a452 1
		reg = azalia_pci_read(pa->pa_pc, pa->pa_tag,
d461 42
a508 2
	sc->pc = pa->pa_pc;
	sc->tag = pa->pa_tag;
a520 3
	sc->pciid = pa->pa_id;
	sc->subid = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);

a1420 1
	pcireg_t v;
d1426 1
a1426 9
	/* enable back-to-back */
	v = pci_conf_read(az->pc, az->tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(az->pc, az->tag, PCI_COMMAND_STATUS_REG,
	    v | PCI_COMMAND_BACKTOBACK_ENABLE);

	/* traffic class select */
	v = pci_conf_read(az->pc, az->tag, ICH_PCI_HDTCSEL);
	pci_conf_write(az->pc, az->tag, ICH_PCI_HDTCSEL,
	    v & ~(ICH_PCI_HDTCSEL_MASK));
@


1.189
log
@the number of widget connections isn't necessarily the same as the
number of widget connection list entries.  if the high bit is set in
a connection list entry, all widgets between the previous and current
entry are connected.  go through the connection list entry once to
figure out how many connections there are, then go through it again
to build the connection list.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.188 2010/09/12 03:17:34 jakemsr Exp $	*/
d2250 1
a2250 1
		if (conn != -1) {
@


1.188
log
@silly me.  use the switch() variable, not the case value.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.187 2010/09/12 02:35:10 jakemsr Exp $	*/
d3333 1
a3333 1
	int length, bits, conn, last;
d3352 27
a3378 2
	this->nconnections = length;
	this->connections = malloc(sizeof(nid_t) * length, M_DEVBUF, M_NOWAIT);
d3383 1
a3383 1
	for (i = 0; i < length;) {
d3388 1
a3388 1
		for (k = 0; i < length && (k < 32 / bits); k++) {
d3394 1
a3394 2
				last = this->connections[i - 1];
				for (j = 1; i < length && j <= conn - last; j++)
d3399 1
d3402 3
a3404 1
	if (length > 0) {
@


1.187
log
@use audio(4) DVACT_{QUIESCE,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.186 2010/08/31 17:26:57 deraadt Exp $	*/
d543 1
a543 1
		rv = config_activate_children(self, DVACT_QUIESCE);
d550 1
a550 1
		rv = config_activate_children(self, DVACT_RESUME);
@


1.186
log
@remove a comment suggesting that azalia needs a powerhook
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.185 2010/08/31 17:13:44 deraadt Exp $	*/
a124 1
	int active;
a131 1
	u_int lpib;			/* link position in buffer */
d543 1
a543 1
		/* XXX to be filled by jakemsr */
d550 1
a1340 14

	/* azalia_stream_halt() always returns 0.
	 * Set 'active' field back to 1 after halting, so azalia_resume()
	 * knows to start it back up.
	 */
	if (az->rstream.active) {
		azalia_stream_halt(&az->rstream);
		az->rstream.active = 1;
	}
	if (az->pstream.active) {
		azalia_stream_halt(&az->pstream);
		az->pstream.active = 1;
	}

a1364 5
	if (az->pstream.active)
		azalia_stream_start(&az->pstream);
	if (az->rstream.active)
		azalia_stream_start(&az->rstream);

a1445 11
	if (az->pstream.active) {
		err = azalia_stream_start(&az->pstream);
		if (err)
			return err;
	}
	if (az->rstream.active) {
		err = azalia_stream_start(&az->rstream);
		if (err)
			return err;
	}

a3618 1
	this->active = 0;
d3648 1
a3648 1
	int i, skip;
a3688 19
	/* The hardware position pointer has been reset to the start
	 * of the buffer.  Call our interrupt handler enough times
	 * to advance the software position pointer to wrap to the
	 * start of the buffer.
	 */
	if (this->active) {
		skip = (this->bufsize - this->lpib) / this->blk + 1;
		DPRINTF(("%s: dir=%d bufsize=%d blk=%d lpib=%d skip=%d\n",
		    __func__, this->dir, this->bufsize, this->blk, this->lpib,
		    skip));
		for (i = 0; i < skip; i++)
			this->intr(this->intr_arg);
		this->swpos = 0;
		this->last_hwpos = 0;
		this->hw_base = 0;
	}
	this->active = 0;
	this->lpib = 0;

a3751 2
	this->active = 1;

d3766 1
a3766 2
	this->lpib = STR_READ_4(this, LPIB);
	this->active = 0;
@


1.185
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.184 2010/08/31 06:12:28 deraadt Exp $	*/
a38 1
 *  - power hook
@


1.184
log
@do not return EOPNOTSUPP for unknown activate actions
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.183 2010/08/08 05:25:30 jakemsr Exp $	*/
d544 3
@


1.183
log
@convert printf()s that can happen in the resume path to DPRINTF()s.
silencing requested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.182 2010/08/08 04:10:25 deraadt Exp $	*/
d539 2
a540 2
	azalia_t *sc;
	int ret;
a541 2
	sc = (azalia_t*)self;
	ret = 0;
d544 1
a544 5
		return ret;
	case DVACT_DEACTIVATE:
		if (sc->audiodev != NULL)
			ret = config_deactivate(sc->audiodev);
		return ret;
d547 1
a547 1
		return ret;
d550 5
a554 1
		return ret;
d556 1
a556 1
	return EOPNOTSUPP;
@


1.182
log
@highly recommend that DVACT_{SUSPEND,RESUME} return 0 unless you want to trigger a broken code path
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.181 2010/08/07 20:52:36 jakemsr Exp $	*/
d699 1
a699 1
		printf("%s: reset failure\n", XNAME(az));
d712 1
a712 1
		printf("%s: reset-exit failure\n", XNAME(az));
d944 1
a944 1
			printf("%s: CORB is running\n", XNAME(az));
d989 1
a989 1
		printf("%s: CORBRP reset failure\n", XNAME(az));
d1042 1
a1042 1
			printf("%s: RIRB is running\n", XNAME(az));
d1161 1
a1161 1
		printf("%s: CORB is not running.\n", XNAME(az));
d1187 1
a1187 1
		printf("%s: RIRB is not running.\n", XNAME(az));
d1203 1
a1203 1
			printf("%s: RIRB time out\n", XNAME(az));
d1400 2
a1401 2
		printf("%s: power audio func error: result=0x%8.8x\n",
		    __func__, result);
d1507 2
a1508 2
			printf("%s: invalid mixer type in mixer %d\n",
			    __func__, mc.dev);
d1540 2
a1541 2
			printf("%s: invalid mixer type in mixer %d\n",
			    __func__, mc.dev);
d3700 1
a3700 1
		printf("%s: stream reset failure 1\n", XNAME(this->az));
d3713 1
a3713 1
		printf("%s: stream reset failure 2\n", XNAME(this->az));
d3754 1
a3754 1
		printf("%s: stream reset failed\n", "azalia");
d3837 2
a3838 2
		printf("%s: stream %d: sts=%b\n", XNAME(this->az),
		    this->number, sts, HDA_SD_STS_BITS);
@


1.181
log
@quiet "missed interrupt" messages.  requested by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.180 2010/08/07 20:48:55 jakemsr Exp $	*/
d552 1
a552 1
		ret = azalia_suspend(sc);
d555 1
a555 1
		ret = azalia_resume(sc);
@


1.180
log
@restore unsolicited responses from volume knob widgets
tested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.179 2010/08/06 05:57:48 jakemsr Exp $	*/
d3855 2
a3856 2
			printf("stream %d: swpos %lu hwpos %lu, adding intr\n",
			    this->number, swpos, hwpos);
d3860 2
a3861 2
			printf("stream %d: swpos %lu hwpos %lu, ignoring intr\n",
			    this->number, swpos, hwpos);
@


1.179
log
@reenabling unsolicited responses in the resume path was lost in
rev 1.172.  restore it so headphone/speaker switching can work
after resume.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.178 2010/08/06 05:34:50 jakemsr Exp $	*/
d1462 1
a1462 1
	err = azalia_codec_enable_unsol(&az->codecs[az->codecno], 1);
@


1.178
log
@no need to save/restore the state of the master volume
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.177 2010/08/06 04:43:20 jakemsr Exp $	*/
d1454 3
@


1.177
log
@since r1.171 pin widgets get fully reinitialized on resume, which
means they lose their quirk fixups.  check for widget quirks and
apply as necessary.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.176 2010/08/06 00:08:49 jakemsr Exp $	*/
d1486 2
d1520 2
@


1.176
log
@attempt to deal with situations where the hardware has processed more
than one block of data since the interrupt handler was last run.

when azalia detects these situations, it will print a line to the
dmesg buffer like:

stream 1: swpos XXXX hwpos XXXX, adding intr

getting these messages in itself is not bad, but if audio breaks, I
need to see these messages.  this will be changed to a DPRINTF once
I get more feedback.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.175 2010/07/29 01:39:03 jakemsr Exp $	*/
d1414 2
@


1.175
log
@flag if an error during attach caused us to detach our resources, and
if so, don't do anything on suspend/resume.  should fix crash reported
by mlarkin.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.174 2010/07/15 03:43:11 jakemsr Exp $	*/
d130 6
a135 1
	int lpib;
d259 1
a259 1
int	azalia_stream_intr(stream_t *, uint32_t);
a622 1
	int ret = 0;
a623 1
	uint8_t rirbsts, rirbctl;
d631 2
a632 2
	ret += azalia_stream_intr(&az->pstream, intsts);
	ret += azalia_stream_intr(&az->rstream, intsts);
d634 2
a635 2
	rirbctl = AZ_READ_1(az, RIRBCTL);
	rirbsts = AZ_READ_1(az, RIRBSTS);
d637 4
a640 6
	if (intsts & HDA_INTSTS_CIS) {
		if (rirbctl & HDA_RIRBCTL_RINTCTL) {
			if (rirbsts & HDA_RIRBSTS_RINTFL)
				azalia_rirb_intr(az);
		}
	}
d3631 2
a3632 1
azalia_stream_init(stream_t *this, azalia_t *az, int regindex, int strnum, int dir)
d3642 1
d3724 3
d3767 1
d3818 1
a3818 1
azalia_stream_intr(stream_t *this, uint32_t intsts)
d3820 1
a3822 3
	if ((intsts & this->intr_bit) == 0)
		return (0);

d3830 25
a3854 1
	if (sts & HDA_SD_STS_BCIS)
d3856 2
d4273 4
d4308 4
@


1.174
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.173 2010/06/27 21:47:07 jakemsr Exp $	*/
d162 1
d528 1
d1332 3
d1431 3
@


1.173
log
@don't probe "volume knobs" on resume.  probably not needed and
is currently breaking resume.
ok pirofti
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.172 2010/04/20 02:17:24 jakemsr Exp $	*/
d3874 2
d4013 2
d4384 2
@


1.172
log
@- an unsolicited response contains the codec address, not the codec
index
- we only care about unsolicited responses from the codec we're using
- no need to enable unsolicited responses until we know which codec
we're using

fixes crash reported by jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.171 2010/04/04 20:07:45 kettenis Exp $	*/
a1417 4
	err = azalia_codec_enable_unsol(this);
	if (err)
		return err;

d1445 4
@


1.171
log
@Reinitialize pins upon resume.  Makes audio work after resume on machines
with codecs like the ALC269 that have pins that need to be configured but
don't have an associated mixer item.

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.170 2010/04/03 14:40:09 kettenis Exp $	*/
a803 1
	uint32_t gctl;
a834 4
	/* enable unsolicited response */
	gctl = AZ_READ_4(az, GCTL);
	AZ_WRITE_4(az, GCTL, gctl | HDA_GCTL_UNSOL);

d902 3
d1222 1
d1228 1
a1228 4
		int i;
		int tag;
		codec_t *codec;
		i = RIRB_RESP_CODEC(az->unsolq[az->unsolq_rp].resp_ex);
d1230 2
a1231 2
		codec = &az->codecs[i];
		DPRINTF(("%s: codec#=%d tag=%d\n", __func__, i, tag));
d1234 4
a1237 1
		azalia_unsol_event(codec, tag);
@


1.170
log
@You cannot save a pointer to your attach arguments and expect it to point
somewhere meaningful later on.  Save the PCI device tag instead and use it
instead.

ok miod@@, jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.169 2010/03/25 03:40:47 jakemsr Exp $	*/
d1407 2
a1408 13
		if ((w->type == COP_AWTYPE_PIN_COMPLEX) &&
		    (w->d.pin.cap & COP_PINCAP_EAPD)) {
			err = azalia_comresp(this, w->nid,
			    CORB_GET_EAPD_BTL_ENABLE, 0, &result);
			if (err)
				return err;
			result &= 0xff;
			result |= CORB_EAPD_EAPD;
			err = azalia_comresp(this, w->nid,
			    CORB_SET_EAPD_BTL_ENABLE, result, &result);
			if (err)
				return err;
		}
@


1.169
log
@disable MSI on Intel devices
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.168 2010/03/21 15:02:31 jakemsr Exp $	*/
d150 1
a180 1
	struct pci_attach_args *saved_pa;
a398 1
	sc->saved_pa = pa;
d493 1
a1439 1
	struct pci_attach_args *pa;
a1442 2
	pa = az->saved_pa;

d1444 2
a1445 2
	v = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
d1449 2
a1450 2
	v = pci_conf_read(pa->pa_pc, pa->pa_tag, ICH_PCI_HDTCSEL);
	pci_conf_write(pa->pa_pc, pa->pa_tag, ICH_PCI_HDTCSEL,
d1454 1
a1454 1
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG, az->subid);
@


1.168
log
@deal with the possibility of two internal speaker pins, like on
macbooks that have a "normal" pair of stereo speakers as well
as subwoofer(s).  problem reported and fix tested by Ted Roby.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.167 2010/03/16 08:28:22 jakemsr Exp $	*/
d103 2
d420 8
a427 1
 
@


1.167
log
@eek! negative array offsets are bad.  don't allow them.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.166 2009/12/24 10:12:19 jakemsr Exp $	*/
d1663 2
a1664 1
	this->speaker = this->spkr_dac = this->fhp = this->fhp_dac =
d1708 1
a1708 3
					if ((this->speaker == -1) ||
					    (w->d.pin.association <
					    this->w[this->speaker].d.pin.association)) {
d1710 12
a1723 1
					}
d1951 2
a1952 1
				if (w->nid == this->speaker)
d2005 2
a2006 1
				if (w->nid == this->speaker)
d2279 21
@


1.166
log
@do not run the unsolicited event queue from the interrupt handler.
instead, install a timeout(9) to run the queue.  fixes a panic
reported by wilfried@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.165 2009/12/22 08:48:14 jakemsr Exp $	*/
d3833 1
a3833 1
	if (enc->index >= codec->nencs)
@


1.165
log
@treat the front headphone jack more like a built-in speaker.  make it's
default DAC receive the first playback stereo channel pair if the DAC
wouldn't otherwise be used and allow the jack's output volume to be
controlled by outputs.master by default.  this was already mostly
implemented for codecs with 3 or more dacs, but front headphone jacks
are also common on 2 dac codecs as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.164 2009/12/15 22:14:28 jakemsr Exp $	*/
d48 2
d172 1
d212 1
a212 1
void	azalia_rirb_kick_unsol_events(azalia_t *);
d549 1
d559 6
d643 2
d962 1
d1212 1
a1212 1
azalia_rirb_kick_unsol_events(azalia_t *az)
d1214 2
d1256 1
a1256 1
	azalia_rirb_kick_unsol_events(az);
d1324 2
@


1.164
log
@don't make mixer items for vendor widgets.  we don't know what they do.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.163 2009/12/15 21:22:04 jakemsr Exp $	*/
d1646 2
a1647 1
	this->speaker = this->spkr_dac = this->mic = this->mic_adc = -1;
d1708 7
d1760 2
a1761 2
	 * the multichannel jack group.  Also select a unique DAC for
	 * the front headphone jack, if one exists.
a1762 1
	this->fhp_dac = -1;
d2116 1
a2116 1
	int i, j, k, err, isfhp;
a2125 1
		isfhp = 0;
a2127 5
		if (w->d.pin.device == CORB_CD_HEADPHONE &&
		    CORB_CD_LOC_GEO(w->d.pin.config) == CORB_CD_FRONT) {
			isfhp = 1;
		}

d2135 1
a2135 1
			if (isfhp)
d2165 1
a2165 1
				if (isfhp)
d2410 1
a2410 1
		    dac != this->spkr_dac)
d2436 1
a2436 1
			    dac != this->spkr_dac)
@


1.163
log
@mono ouputs shouldn't be candidates for exclusive inclusion in the
outputs.master.slaves group.  lets outputs.master by default control
more than just the internal speaker on some Dell desktops.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.162 2009/11/24 10:00:39 jakemsr Exp $	*/
d2915 2
@


1.162
log
@implement suspend and resume
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.161 2009/11/23 22:33:21 pirofti Exp $	*/
d2394 2
a2395 1
		    w->parent == this->input_mixer)
@


1.161
log
@Add azalia(4) suspend/resume stabs, now some laptops can go all the way.

Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.160 2009/11/11 23:12:39 jakemsr Exp $	*/
d122 2
a123 1
	void *start, *end;
d126 1
d175 1
d197 1
a197 1
int	azalia_init(azalia_t *);
d202 1
a202 1
int	azalia_init_corb(azalia_t *);
d205 1
a205 1
int	azalia_init_rirb(azalia_t *);
d278 6
d394 1
d497 1
a497 1
	if (azalia_init(sc))
d533 1
a533 1
		/* XXX should power down azalia */
d536 1
a536 1
		/* XXX should power up azalia */
d780 1
a780 1
azalia_init(azalia_t *az)
d789 5
a793 3
	err = azalia_get_ctrlr_caps(az);
	if (err)
		return(err);
d803 1
a803 1
	err = azalia_init_corb(az);
d808 1
a808 1
	err = azalia_init_rirb(az);
d930 1
a930 1
azalia_init_corb(azalia_t *az)
d940 9
a948 6
	err = azalia_alloc_dmamem(az,
	    az->corb_entries * sizeof(corb_entry_t), 128,
	    &az->corb_dma);
	if (err) {
		printf("%s: can't allocate CORB buffer\n", XNAME(az));
		return err;
d950 1
a954 2
	DPRINTF(("%s: CORB allocation succeeded.\n", __func__));

d1027 1
a1027 1
azalia_init_rirb(azalia_t *az)
d1037 19
a1055 6
	err = azalia_alloc_dmamem(az,
	    az->rirb_entries * sizeof(rirb_entry_t), 128,
	    &az->rirb_dma);
	if (err) {
		printf("%s: can't allocate RIRB buffer\n", XNAME(az));
		return err;
a1060 15
	DPRINTF(("%s: RIRB allocation succeeded.\n", __func__));

	/* setup the unsolicited response queue */
	az->unsolq_rp = 0;
	az->unsolq_wp = 0;
	az->unsolq_kick = FALSE;
	az->unsolq = malloc(sizeof(rirb_entry_t) * UNSOLQ_SIZE,
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (az->unsolq == NULL) {
		DPRINTF(("%s: can't allocate unsolicited response queue.\n",
		    XNAME(az)));
		azalia_free_dmamem(az, &az->rirb_dma);
		return ENOMEM;
	}

d1070 4
d1302 217
d3583 1
d3612 1
a3612 1
	int i;
d3653 16
d3692 1
a3692 1
	dmaend = dmaaddr + ((caddr_t)this->end - (caddr_t)this->start);
d3706 2
a3707 2
	DPRINTFN(1, ("%s: start=%p end=%p fmt=0x%4.4x index=%d\n",
	    __func__, this->start, this->end, this->fmt, index));
d3716 1
a3716 1
	STR_WRITE_4(this, CBL, ((caddr_t)this->end - (caddr_t)this->start));
d3731 2
d3747 2
d4176 1
a4176 2
	az->pstream.start = start;
	az->pstream.end = end;
d4208 1
a4208 2
	az->rstream.start = start;
	az->rstream.end = end;
@


1.160
log
@fix memory leak found by parfait
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.159 2009/10/27 12:30:11 jakemsr Exp $	*/
d521 6
@


1.159
log
@encode the channels a converter will convert into the converter's
mixer name.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.158 2009/10/13 19:33:16 pirofti Exp $	*/
d1877 1
d1898 1
a1898 1
				return(0);
d1922 1
a1922 1
					return(err);
d1929 1
a1929 1
					return(0);
d1935 1
a1935 2

	return(0);
@


1.158
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.157 2009/10/11 06:45:46 jakemsr Exp $	*/
d2770 1
d2773 1
a2773 1
	int colors_used, use_colors;
d2821 7
a2827 11
			for (j = 0; j < codec->dacs.groups[0].nconv; j++) {
				if (w->nid == codec->dacs.groups[0].conv[j]) {
					if (j > 0)
						snprintf(w->name,
						    sizeof(w->name), "%s%d",
						    wtypes[w->type], j + 1);
					else
						snprintf(w->name,
						    sizeof(w->name), "%s",
						    wtypes[w->type]);
					break;
d2829 1
d2833 8
a2840 10
			for (j = 0; j < codec->dacs.groups[1].nconv; j++) {
				if (w->nid == codec->dacs.groups[1].conv[j]) {
					if (j > 0)
						snprintf(w->name,
						    sizeof(w->name), "dig-%s%d",
						    wtypes[w->type], j + 1);
					else
						snprintf(w->name,
						    sizeof(w->name), "dig-%s",
						    wtypes[w->type]);
d2842 1
d2846 1
d2849 7
a2855 11
			w->mixer_class = AZ_CLASS_RECORD;
			for (j = 0; j < codec->adcs.groups[0].nconv; j++) {
				if (w->nid == codec->adcs.groups[0].conv[j]) {
					if (j > 0)
						snprintf(w->name,
						    sizeof(w->name), "%s%d",
						    wtypes[w->type], j + 1);
					else
						snprintf(w->name,
						    sizeof(w->name), "%s",
						    wtypes[w->type]);
d2857 1
d2861 8
a2868 10
			for (j = 0; j < codec->adcs.groups[1].nconv; j++) {
				if (w->nid == codec->adcs.groups[1].conv[j]) {
					if (j > 0)
						snprintf(w->name,
						    sizeof(w->name), "dig-%s%d",
						    wtypes[w->type], j + 1);
					else
						snprintf(w->name,
						    sizeof(w->name), "dig-%s",
						    wtypes[w->type]);
d2870 1
@


1.157
log
@* define a constant for the specification defined maximum number of
codecs a controller can support
* dynamically allocate memory for the array of codec structures
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.156 2009/10/11 00:59:37 jakemsr Exp $	*/
d188 1
a188 1
int	azalia_pci_activate(struct device *, enum devact);
d508 1
a508 1
azalia_pci_activate(struct device *self, enum devact act)
@


1.156
log
@* start all "initialization failure" messages with lowercase letter.
* instead of printing "initialization failure", print "initialization
failure, detaching".  perhaps instills more confidence that the
failure was handled in an orderly manner.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.155 2009/10/11 00:07:06 jakemsr Exp $	*/
d152 1
a152 1
	codec_t codecs[15];
d548 4
d700 1
a700 1
	for (i = 0, n = 0; i < 15; i++) {
d703 1
a703 2
			az->codecs[n].address = i;
			az->codecs[n++].az = az;
d710 12
@


1.155
log
@this driver doesn't yet support HDMI codecs enough for them to be
usable.  detach the driver if the device is only capable of HDMI.
this keeps an unusable device from being /dev/audio0 (thus
/dev/audio by default), while /dev/audio1 is fully functional.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.154 2009/10/08 01:57:44 jakemsr Exp $	*/
d503 1
a503 1
	printf("%s: initialization failure\n", XNAME(sc));
d705 1
a705 1
		printf("%s: No HD-Audio codecs\n", XNAME(az));
d723 1
a723 1
		printf("%s: Invalid CORBSZCAP: 0x%2x\n", XNAME(az), cap);
d741 1
a741 1
		printf("%s: Invalid RIRBSZCAP: 0x%2x\n", XNAME(az), cap);
@


1.154
log
@set a couple bits in the pci configuration space for nvidia hda
controllers.  according to ALSA and OSS, these enable input and
output stream DMA coherency.
fixes broken playback problem reported by Laurence Tratt (laurie at
tratt dot net), who graciously tested a number of previous attempts
to solve this problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.153 2009/09/14 09:08:03 jakemsr Exp $	*/
d793 1
a793 1
	int c, i, j;
d806 1
a806 1
	 * use the first codec capable of digital I/O.
d810 3
a812 1
		if (az->codecs[i].audiofunc < 0)
d814 6
a819 12
		codec = &az->codecs[i];
		FOR_EACH_WIDGET(codec, j) {
			if (codec->w[j].type == COP_AWTYPE_AUDIO_OUTPUT ||
			    codec->w[j].type == COP_AWTYPE_AUDIO_INPUT) {
				if (codec->w[j].widgetcap & COP_AWCAP_DIGITAL) {
					if (c < 0)
						c = i;
				} else {
					c = i;
					break;
				}
			}
d824 1
a824 1
		DPRINTF(("%s: chosen codec has no converters.\n", XNAME(az)));
d1272 1
d1274 1
a1274 1
	int err, addr, n, i;
d1375 2
a1376 1
		err = azalia_widget_init(&this->w[i], this, i);
d1379 1
a1379 1
		err = azalia_widget_init_connection(&this->w[i], this);
d1383 1
a1383 1
		azalia_widget_print_widget(&this->w[i], this);
d1395 1
d1397 3
a1399 1
		if (!this->w[i].enable)
d1402 1
a1402 1
		switch (this->w[i].type) {
d1407 1
a1407 1
				this->w[i].enable = 0;
d1411 1
a1411 1
			if ((this->w[i].widgetcap & COP_AWCAP_DIGITAL) == 0) {
d1421 1
a1421 1
			if ((this->w[i].widgetcap & COP_AWCAP_DIGITAL) == 0) {
d1431 1
a1431 1
			switch (CORB_CD_PORT(this->w[i].d.pin.config)) {
d1433 1
a1433 1
				switch (this->w[i].d.pin.device) {
d1436 1
a1436 1
					    (this->w[i].d.pin.association <
d1451 1
a1451 1
				if (this->w[i].d.pin.device == CORB_CD_LINEOUT)
d1454 1
a1454 1
				    !(this->w[i].d.pin.cap & COP_PINCAP_PRESENCE))
d1466 6
d1474 6
@


1.153
log
@don't try to manipulate an invalid node.  fixes codec detection
problem reported by martynas@@.  this bug has been there a long
time (r1.61), but sloppy RIRB handling was hiding it ...
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.152 2009/09/12 09:21:28 jakemsr Exp $	*/
d339 3
d437 14
a450 1
		reg = azalia_pci_read(pa->pa_pc, pa->pa_tag, NVIDIA_PCIE_SNOOP_REG);
d453 10
a462 1
		azalia_pci_write(pa->pa_pc, pa->pa_tag, NVIDIA_PCIE_SNOOP_REG, reg);
@


1.152
log
@there are machines that have more than one fixed speaker.  use
the one with the lowest association.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.151 2009/09/12 09:11:52 jakemsr Exp $	*/
a1302 3
		azalia_comresp(this, this->audiofunc, CORB_SET_POWER_STATE,
		    CORB_PS_D3, &result);
		DELAY(100);
@


1.151
log
@move code for getting controller capabilities out of azalia_init()
and into it's own function, azalia_get_ctrlr_caps()
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.150 2009/09/10 22:59:46 jakemsr Exp $	*/
d1412 7
a1418 3
					this->speaker = i;
					this->spkr_dac =
					    azalia_codec_find_defdac(this, i, 0);
@


1.150
log
@better to wait for codecs to finish resetting in azalia_reset()
rather than in it's user(s)
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.149 2009/09/09 22:25:03 jakemsr Exp $	*/
d157 2
a158 1
	int corb_size;
d160 2
a161 1
	int rirb_size;
d193 1
d652 1
a652 1
azalia_init(azalia_t *az)
d654 1
a654 2
	int i, n, err;
	uint32_t gctl;
d657 1
a668 4
	err = azalia_reset(az);
	if (err)
		return(err);

d684 53
d878 1
a878 1
	int entries, err, i;
d880 1
a880 1
	uint8_t corbsize, cap, corbctl;
d886 3
a888 20
	/* determine CORB size */
	corbsize = AZ_READ_1(az, CORBSIZE);
	cap = corbsize & HDA_CORBSIZE_CORBSZCAP_MASK;
	corbsize &= ~HDA_CORBSIZE_CORBSIZE_MASK;
	if (cap & HDA_CORBSIZE_CORBSZCAP_256) {
		entries = 256;
		corbsize |= HDA_CORBSIZE_CORBSIZE_256;
	} else if (cap & HDA_CORBSIZE_CORBSZCAP_16) {
		entries = 16;
		corbsize |= HDA_CORBSIZE_CORBSIZE_16;
	} else if (cap & HDA_CORBSIZE_CORBSZCAP_2) {
		entries = 2;
		corbsize |= HDA_CORBSIZE_CORBSIZE_2;
	} else {
		printf("%s: Invalid CORBSZCAP: 0x%2x\n", XNAME(az), cap);
		return -1;
	}

	err = azalia_alloc_dmamem(az, entries * sizeof(corb_entry_t),
	    128, &az->corb_dma);
d895 2
a896 3
	AZ_WRITE_1(az, CORBSIZE, corbsize);
	az->corb_size = entries;

d914 1
a914 1
		 AZ_READ_2(az, CORBRP) & HDA_CORBRP_CORBRP, az->corb_size));
d973 1
a973 1
	int entries, err;
d975 1
a975 1
	uint8_t rirbsize, cap, rirbctl;
d981 3
a983 20
	/* determine RIRB size */
	rirbsize = AZ_READ_1(az, RIRBSIZE);
	cap = rirbsize & HDA_RIRBSIZE_RIRBSZCAP_MASK;
	rirbsize &= ~HDA_RIRBSIZE_RIRBSIZE_MASK;
	if (cap & HDA_RIRBSIZE_RIRBSZCAP_256) {
		entries = 256;
		rirbsize |= HDA_RIRBSIZE_RIRBSIZE_256;
	} else if (cap & HDA_RIRBSIZE_RIRBSZCAP_16) {
		entries = 16;
		rirbsize |= HDA_RIRBSIZE_RIRBSIZE_16;
	} else if (cap & HDA_RIRBSIZE_RIRBSZCAP_2) {
		entries = 2;
		rirbsize |= HDA_RIRBSIZE_RIRBSIZE_2;
	} else {
		printf("%s: Invalid RIRBSZCAP: 0x%2x\n", XNAME(az), cap);
		return -1;
	}

	err = azalia_alloc_dmamem(az, entries * sizeof(rirb_entry_t),
	    128, &az->rirb_dma);
d990 1
a990 2
	AZ_WRITE_1(az, RIRBSIZE, rirbsize);
	az->rirb_size = entries;
d1013 2
a1014 1
	DPRINTF(("%s: RIRBRP=%d, size=%d\n", __func__, az->rirb_rp, az->rirb_size));
d1088 1
a1088 1
	if (++wp >= az->corb_size)
d1125 1
a1125 1
		if (++az->rirb_rp >= az->rirb_size)
d1173 1
a1173 1
		if (++az->rirb_rp >= az->rirb_size)
@


1.149
log
@reorganize attach/initialization into more task specific functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.148 2009/09/09 07:16:50 jakemsr Exp $	*/
d643 1
a670 1
	DELAY(1000);
@


1.148
log
@move code to reset the controller from the attach function to it's
own function
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.147 2009/09/09 03:15:04 jakemsr Exp $	*/
d191 3
a193 2
int	azalia_attach(azalia_t *);
void	azalia_attach_intr(struct device *);
d457 7
d465 4
a468 6
	if (azalia_attach(sc)) {
		printf("%s: initialization failure\n", XNAME(sc));
		azalia_pci_detach(self, 0);
		return;
	}
	sc->subid = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);
d472 5
a476 1
	azalia_attach_intr(self);
d648 1
a648 1
azalia_attach(azalia_t *az)
a668 4
	/* enable unsolicited response */
	gctl = AZ_READ_4(az, GCTL);
	AZ_WRITE_4(az, GCTL, gctl | HDA_GCTL_UNSOL);

a683 11
	return 0;
}

void
azalia_attach_intr(struct device *self)
{
	azalia_t *az;
	codec_t *codec;
	int err, i, j, c;

	az = (azalia_t*)self;
d685 1
d693 4
a696 2
	if (azalia_init_corb(az))
		goto err_exit;
d698 3
a700 2
	if (azalia_init_rirb(az))
		goto err_exit;
d705 13
d720 1
a720 2
		err = azalia_codec_init(&az->codecs[i]);
		if (!err)
d725 1
a725 1
		goto err_exit;
d752 1
a752 1
		goto err_exit;
d780 8
d789 7
a795 5
	if (azalia_stream_init(&az->pstream, az, az->nistreams + 0,
	    1, AUMODE_PLAY))
		goto err_exit;
	if (azalia_stream_init(&az->rstream, az, 0, 2, AUMODE_RECORD))
		goto err_exit;
d797 1
a797 6
	az->audiodev = audio_attach_mi(&azalia_hw_if, az, &az->dev);

	return;
err_exit:
	azalia_pci_detach(self, 0);
	return;
@


1.147
log
@add a few more members to stream_t and use it as a coherent source
of information about a stream
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.146 2009/09/09 02:13:35 jakemsr Exp $	*/
d190 1
d601 1
a601 1
azalia_attach(azalia_t *az)
a602 1
	int i, n;
d604 1
a604 12
	uint16_t gcap;
	uint16_t statests;

	DPRINTF(("%s: host: High Definition Audio rev. %d.%d\n",
	    XNAME(az), AZ_READ_1(az, VMAJ), AZ_READ_1(az, VMIN)));
	gcap = AZ_READ_2(az, GCAP);
	az->nistreams = HDA_GCAP_ISS(gcap);
	az->nostreams = HDA_GCAP_OSS(gcap);
	az->nbstreams = HDA_GCAP_BSS(gcap);
	az->ok64 = (gcap & HDA_GCAP_64OK) != 0;
	DPRINTF(("%s: host: %d output, %d input, and %d bidi streams\n",
	    XNAME(az), az->nostreams, az->nistreams, az->nbstreams));
d618 1
a618 1
		return ETIMEDOUT;
d631 1
a631 1
		return ETIMEDOUT;
d633 25
@


1.146
log
@handle mixer get/set requests for class type mixer items in the underlying
mixer get/set routines instead of in the MI audio routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.145 2009/09/09 00:26:57 jakemsr Exp $	*/
d122 3
d210 2
a211 2
int	azalia_codec_connect_stream(codec_t *, int, uint16_t, int);
int	azalia_codec_disconnect_stream(codec_t *, int);
d238 1
a238 2
int	azalia_stream_start(stream_t *, void *, void *, int,
	void (*)(void *), void *, uint16_t);
d2426 1
a2426 1
azalia_codec_connect_stream(codec_t *this, int dir, uint16_t fmt, int number)
d2428 1
d2435 1
a2435 1
	nchan = (fmt & HDA_SD_FMT_CHAN) + 1;
d2437 2
a2438 2
	if (dir == AUMODE_RECORD)
		group = &this->adcs.groups[this->adcs.cur];
d2440 1
a2440 1
		group = &this->dacs.groups[this->dacs.cur];
d2444 1
a2444 1
		w = &this->w[group->conv[i]];
d2447 1
a2447 1
		stream_chan = (number << 4);
d2450 2
a2451 2
		} else if (w->nid == this->spkr_dac ||
		    w->nid == this->fhp_dac) {
d2460 1
a2460 1
			    w->nid, stream_chan & ~(number << 4)));
d2463 2
a2464 2
		err = azalia_comresp(this, w->nid, CORB_SET_CONVERTER_FORMAT,
		    fmt, NULL);
d2467 1
a2467 1
			    __func__, w->nid, fmt, err));
d2470 1
a2470 1
		err = azalia_comresp(this, w->nid,
d2479 1
a2479 1
			err = azalia_comresp(this, w->nid,
d2487 1
a2487 1
			err = azalia_comresp(this, w->nid,
d2502 1
a2502 1
azalia_codec_disconnect_stream(codec_t *this, int dir)
d2504 1
d2510 2
a2511 2
	if (dir == AUMODE_RECORD)
		group = &this->adcs.groups[this->adcs.cur];
d2513 1
a2513 1
		group = &this->dacs.groups[this->dacs.cur];
d2516 1
a2516 1
		azalia_comresp(this, nid, CORB_SET_CONVERTER_STREAM_CHANNEL,
d2518 1
a2518 1
		if (this->w[nid].widgetcap & COP_AWCAP_DIGITAL) {
d2520 1
a2520 1
			azalia_comresp(this, nid, CORB_GET_DIGITAL_CONTROL,
d2523 1
a2523 1
			azalia_comresp(this, nid, CORB_SET_DIGITAL_CONTROL_L,
d3322 1
a3322 2
azalia_stream_start(stream_t *this, void *start, void *end, int blk,
    void (*intr)(void *), void *arg, uint16_t fmt)
a3329 3
	this->intr = intr;
	this->intr_arg = arg;

d3341 1
a3341 1
	dmaend = dmaaddr + ((caddr_t)end - (caddr_t)start);
d3346 1
a3346 1
		bdlist[index].length = htole32(blk);
d3348 1
a3348 1
		dmaaddr += blk;
d3355 3
d3365 2
a3366 2
	STR_WRITE_4(this, CBL, ((caddr_t)end - (caddr_t)start));
	STR_WRITE_2(this, FMT, fmt);
d3368 1
a3368 2
	err = azalia_codec_connect_stream(&this->az->codecs[this->az->codecno],
	    this->dir, fmt, this->number);
d3393 1
a3393 2
	azalia_codec_disconnect_stream
	    (&this->az->codecs[this->az->codecno], this->dir);
d3819 8
a3826 1
		return EINVAL;
d3828 1
a3828 2
	return azalia_stream_start(&az->pstream, start, end, blk, intr,
	    arg, fmt);
d3852 8
a3859 1
		return EINVAL;
d3861 1
a3861 2
	return azalia_stream_start(&az->rstream, start, end, blk, intr,
	    arg, fmt);
@


1.145
log
@azalia.h:
* remove irrelevant comment
* this driver uses at most 2 converter groups per group set, don't
allocate more than needed
* remove unused members from codec_t
azalia.c:
* macros for register values
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.144 2009/09/08 23:30:17 jakemsr Exp $	*/
a3707 3
	if (mc->type == AUDIO_MIXER_CLASS)
		return 0;	/* nothing to do */

a3725 3

	if (mc->type == AUDIO_MIXER_CLASS)
		return 0;	/* nothing to do */
@


1.144
log
@cleanup/fix RIRB processing:
* move the code for azalia_comresp() to be nearer the functions it
  uses (azalia_set_command() and azalia_get_response()) for easier
  comprehension.
* don't turn off RIRB interrupts in azalia_set_command(), then reenable
  them in azalia_get_response().  it's ugly, problematic, and the code
  is already at SPL_AUDIO.
* in azalia_get_response(), wait for a solicited response (the response
  from azalia_set_command()) instead of "waiting" for just any response
  as there may already be an unsolicited response in the RIRB.
* no need to run the unsolicited response handler in azalia_get_response().
  since RIRB interrupts aren't being disables, the unsolicited response
  handler will be run by the RIRB interrupt handler.
* in azalia_rirb_intr(), when a solicited response is found in the RIRB,
  instead of stopping and losing the response, print a debug message
  and keep going.  there should never be a solicited response in the
  RIRB at this point.
* remove some now useless #if 0'd debug cruft.
* minor KNF while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.143 2009/08/13 23:59:15 jakemsr Exp $	*/
d99 2
d391 4
a394 2
	v = pci_conf_read(pa->pa_pc, pa->pa_tag, 0x44);
	pci_conf_write(pa->pa_pc, pa->pa_tag, 0x44, v & (~0x7));
@


1.143
log
@add a shutdown hook to stop unsolicited responses and the CORB and
RIRB DMA engines
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.142 2009/08/12 09:59:35 martynas Exp $	*/
d194 1
a194 2
int	azalia_set_command(azalia_t *, nid_t, int, uint32_t,
	uint32_t);
d999 18
d1018 1
a1018 1
		   uint32_t param)
a1023 1
	uint8_t rirbctl;
d1028 1
a1028 1
		return -1;
d1039 1
a1039 6
	/* disable RIRB interrupts */
	rirbctl = AZ_READ_1(az, RIRBCTL);
	if (rirbctl & HDA_RIRBCTL_RINTCTL) {
		AZ_WRITE_1(az, RIRBCTL, rirbctl & ~HDA_RIRBCTL_RINTCTL);
		azalia_rirb_intr(az);
	}
d1041 1
a1041 6
	AZ_WRITE_2(az, CORBWP, (corbwp & ~HDA_CORBWP_CORBWP) | wp);
#if 0
	DPRINTF(("%s: caddr=%d nid=%d control=0x%x param=0x%x verb=0x%8.8x wp=%d\n",
		 __func__, caddr, nid, control, param, verb, wp));
#endif
	return 0;
a1049 1
	uint8_t rirbctl;
d1054 1
a1054 1
		return -1;
d1057 1
a1057 10
	for (i = 5000; i >= 0; i--) {
		wp = AZ_READ_2(az, RIRBWP) & HDA_RIRBWP_RIRBWP;
		if (az->rirb_rp != wp)
			break;
		DELAY(10);
	}
	if (i <= 0) {
		printf("%s: RIRB time out\n", XNAME(az));
		return ETIMEDOUT;
	}
d1059 1
d1061 11
d1084 1
a1084 14
	azalia_rirb_kick_unsol_events(az);
#if 0
	for (i = 0; i < 16 /*az->rirb_size*/; i++) {
		DPRINTF(("rirb[%d] 0x%8.8x:0x%8.8x ", i, rirb[i].resp, rirb[i].resp_ex));
		if ((i % 2) == 1)
			DPRINTF(("\n"));
	}
#endif

	/* re-enable RIRB interrupts */
	rirbctl = AZ_READ_1(az, RIRBCTL);
	AZ_WRITE_1(az, RIRBCTL, rirbctl | HDA_RIRBCTL_RINTCTL);

	return 0;
d1127 1
a1127 1
			break;
a1129 1

a2416 16
}

int
azalia_comresp(const codec_t *codec, nid_t nid, uint32_t control,
		     uint32_t param, uint32_t* result)
{
	int err, s;

	s = splaudio();
	err = azalia_set_command(codec->az, codec->address, nid, control, param);
	if (err)
		goto exit;
	err = azalia_get_response(codec->az, result);
exit:
	splx(s);
	return err;
@


1.142
log
@fix unused widgets to contain the actual ids;  ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.141 2009/06/26 01:24:05 jakemsr Exp $	*/
d187 2
d191 1
d458 2
d559 15
a764 1

d766 1
a766 1
azalia_init_corb(azalia_t *az)
d768 2
a769 3
	int entries, err, i;
	uint16_t corbrp, corbwp;
	uint8_t corbsize, cap, corbctl;
a770 1
	/* stop the CORB */
d785 13
d879 1
a879 1
azalia_init_rirb(azalia_t *az)
d881 2
a882 3
	int entries, err, i;
	uint16_t rirbwp;
	uint8_t rirbsize, cap, rirbctl;
a883 1
	/* stop the RIRB */
d895 1
a895 1
			return EBUSY;
d898 13
@


1.141
log
@if a codec has multiple line out jacks, and the codec says all
the line out jack have different colors, use the colors in the
line out mixer item names.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.140 2009/06/18 08:19:03 jsg Exp $	*/
d2804 1
a2804 1
				    sizeof(codec->w[i].name), "%s",
@


1.140
log
@Remove support for cancelled NVIDIA MCP7B and add initial support for
MCP89.

From Brad based on information from Peer Chen @@ NVIDIA via Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.139 2009/06/09 05:16:42 jakemsr Exp $	*/
d314 3
d1325 2
a1326 1
					this->spkr_dac = azalia_codec_find_defdac(this, i, 0);
d1330 2
a1331 1
					this->mic_adc = azalia_codec_find_defadc(this, i, 0);
d2644 1
d2650 17
d2676 5
a2680 1
			if (pins[w->d.pin.device] > 1)
d2684 1
a2684 1
			else
d2687 1
@


1.139
log
@AD1981HD output amps are weird.  they report 63 volume steps but the
first 30 do nothing.  perhaps there are other codecs with such
amps?  (ab)use some reserved bits in the amplifier capabilities
parameter to store the first volume step that actually changes the
volume.  problem reported and patch tested by LEVAI Daniel.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.138 2009/06/09 05:05:48 jakemsr Exp $	*/
d414 4
a417 4
	case PCI_PRODUCT_NVIDIA_MCP7B_HDA_1:
	case PCI_PRODUCT_NVIDIA_MCP7B_HDA_2:
	case PCI_PRODUCT_NVIDIA_MCP7B_HDA_3:
	case PCI_PRODUCT_NVIDIA_MCP7B_HDA_4:
@


1.138
log
@quirks for MacBookPro3,1 inspired by FreeBSD's snd_hda.  problem
reported and patch tested by Bryan Chapman.  according to FreeBSD,
this might be needed for other MacBookPro models but no one else has
told me their MacBookPro doesn't work.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.137 2009/05/31 03:22:05 jakemsr Exp $	*/
d2547 4
d2557 1
d2565 1
@


1.137
log
@zap _generic from the names of several functions.  there are no
more non-generic versions, and there never will be again.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.136 2009/05/31 02:57:51 jakemsr Exp $	*/
d2870 3
@


1.136
log
@- all codecs now use the same functions, always.  call the functions
directly instead of through pointers in the codec_t.
- fold azalia_generic_{g,s}et_port into azalia_{g,s}et_port since both
are small and partly duplicated eachother.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.135 2009/05/29 21:16:37 jakemsr Exp $	*/
d3660 1
a3660 1
	return azalia_generic_mixer_set(co, m->nid, m->target, mc);
d3681 1
a3681 1
	return azalia_generic_mixer_get(co, m->nid, m->target, mc);
@


1.135
log
@register all GPIO and widget "quirks" in a bitmask instead of using
macros and codec->init_widget.  now there is only only place to look
to see what special handling a specific codec will get.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.134 2009/05/29 17:54:08 jakemsr Exp $	*/
a202 2
int	azalia_codec_comresp(const codec_t *, nid_t, uint32_t,
	uint32_t, uint32_t *);
d720 1
a720 1
			codec->comresp(codec, codec->audiofunc,
d1064 1
a1064 2
		if (codec->unsol_event != NULL)
			codec->unsol_event(codec, tag);
a1162 1
	this->comresp = azalia_codec_comresp;
d1165 1
a1165 1
	err = this->comresp(this, CORB_NID_ROOT, CORB_GET_PARAMETER,
d1169 1
a1169 1
	err = this->comresp(this, CORB_NID_ROOT, CORB_GET_PARAMETER,
d1183 1
a1183 1
	err = this->comresp(this, CORB_NID_ROOT, CORB_GET_PARAMETER,
d1199 1
a1199 1
		err = this->comresp(this, n + i, CORB_GET_PARAMETER,
d1212 1
a1212 1
		this->comresp(this, this->audiofunc, CORB_SET_POWER_STATE,
d1219 1
a1219 1
	this->comresp(this, this->audiofunc, CORB_SET_POWER_STATE,
d1224 2
a1225 2
	err = this->comresp(this, this->audiofunc,
	    CORB_GET_PARAMETER, COP_SUBORDINATE_NODE_COUNT, &result);
d1243 1
a1243 1
	this->comresp(this, this->audiofunc, CORB_GET_PARAMETER,
d1246 1
a1246 1
	this->comresp(this, this->audiofunc, CORB_GET_PARAMETER,
d1249 1
a1249 1
	this->comresp(this, this->audiofunc, CORB_GET_PARAMETER,
d1252 1
a1252 1
	this->comresp(this, this->audiofunc, CORB_GET_PARAMETER,
d1337 1
a1337 1
				err = this->comresp(this, i,
d1380 1
a1380 1
	err = this->init_dacgroup(this);
d1404 1
a1404 1
	err = this->mixer_init(this);
d1484 1
a1484 1
		err = this->comresp(this, w->nid,
d1771 1
a1771 1
				err = this->comresp(this, w->nid,
d1854 1
a1854 1
			err = this->comresp(this, w->nid,
d2029 1
a2029 1
				err = this->comresp(this, w->nid,
d2053 1
a2053 1
				err = this->comresp(this, w->nid,
d2120 1
a2120 1
				err = this->comresp(this, w->nid,
d2139 1
a2139 1
				err = this->comresp(this, w->nid,
d2157 1
a2157 2
	if (this->mixer_delete != NULL)
		this->mixer_delete(this);
d2380 1
a2380 1
azalia_codec_comresp(const codec_t *codec, nid_t nid, uint32_t control,
d2432 2
a2433 2
		err = this->comresp(this, w->nid,
		    CORB_SET_CONVERTER_FORMAT, fmt, NULL);
d2439 1
a2439 1
		err = this->comresp(this, w->nid,
d2448 1
a2448 1
			err = this->comresp(this, w->nid,
d2456 1
a2456 1
			err = this->comresp(this, w->nid,
d2484 1
a2484 1
		this->comresp(this, nid, CORB_SET_CONVERTER_STREAM_CHANNEL,
d2488 2
a2489 1
			this->comresp(this, nid, CORB_GET_DIGITAL_CONTROL, 0, &v);
d2491 2
a2492 1
			this->comresp(this, nid, CORB_SET_DIGITAL_CONTROL_L, v, NULL);
d2508 1
a2508 1
	err = codec->comresp(codec, nid, CORB_GET_PARAMETER,
d2516 2
a2517 2
		codec->comresp(codec, nid, CORB_SET_POWER_STATE,
		    CORB_PS_D0, &result);
d2535 1
a2535 1
		err = codec->comresp(codec, this->nid, CORB_GET_PARAMETER,
d2549 1
a2549 1
			codec->comresp(codec, nid, CORB_GET_PARAMETER,
d2556 1
a2556 1
			codec->comresp(codec, nid, CORB_GET_PARAMETER,
d2793 2
a2794 2
		err = codec->comresp(codec, this->nid,
		    CORB_GET_PARAMETER, COP_STREAM_FORMATS, &result);
d2810 2
a2811 2
			err = codec->comresp(codec, this->nid, CORB_GET_PARAMETER,
			    COP_PCM, &result);
d2831 1
a2831 1
	err = codec->comresp(codec, this->nid, CORB_GET_CONFIGURATION_DEFAULT,
d2841 1
a2841 1
	err = codec->comresp(codec, this->nid, CORB_GET_PARAMETER,
d2871 1
a2871 1
	codec->comresp(codec, this->nid, CORB_SET_PIN_WIDGET_CONTROL,
d2875 2
a2876 2
		err = codec->comresp(codec, this->nid, CORB_GET_EAPD_BTL_ENABLE,
		    0, &result);
d2881 2
a2882 2
		err = codec->comresp(codec, this->nid, CORB_SET_EAPD_BTL_ENABLE,
		    result, &result);
d2906 1
a2906 1
	err = codec->comresp(codec, this->nid, CORB_GET_PARAMETER,
d2926 1
a2926 1
		err = codec->comresp(codec, this->nid,
d2945 1
a2945 1
		err = codec->comresp(codec, this->nid,
d3036 1
a3036 1
	this->comresp(this, this->audiofunc, CORB_GET_PARAMETER,
d3646 4
d3655 6
a3660 1
	return co->set_port(co, mc);
d3668 4
d3677 5
a3681 1
	return co->get_port(co, mc);
@


1.134
log
@- if a codec is capable of multichannel playback, try to connect
the output jacks to different DACs.
- multichannel codecs often have a front headphone jack that is
intended to be used separately from the multichannel jacks.  if a front
headphone jack exists, try to connect it to a DAC not used by the
multichannel jacks.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.133 2009/05/29 02:49:30 jakemsr Exp $	*/
d1278 3
a1280 2
		if (this->init_widget != NULL)
			this->init_widget(this, &this->w[i], this->w[i].nid);
d1402 5
a1406 3
	err = azalia_codec_gpio_quirks(this);
	if (err)
		return err;
@


1.133
log
@- try to not choose only input mixers for outputs.master.slaves
- another case where a selector can be considered part of another
widget

factors out a mixer control and lets the volume buttons work on
ajacoutot@@'s x300
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.132 2009/05/29 02:38:01 jakemsr Exp $	*/
d215 1
d1286 1
d1334 2
d1368 11
d1507 1
a1507 1
	int prio, add, nd, conv;
d1517 4
d1551 2
a1552 1
				opins[nopins].prio = prio | (nd << 8);
d1718 74
d2421 2
a2422 1
		} else if (w->nid == this->spkr_dac) {
@


1.132
log
@- when a widget will be considered part of a different widget, record
the node id of the "parent" widget
- initialize widgets' mixer_class ealier
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.131 2009/05/12 09:32:28 jakemsr Exp $	*/
d1914 3
a1916 1
		cap = w->outamp_cap;
d1931 1
d2647 4
a2650 3
			 * and is connected to a single widget that has no
			 * inamp capabilities.  This widget serves only to act
			 * as the input amp for the widget it is connected to.
d2661 3
@


1.131
log
@- try to identify a "main input mixer"
- don't unmute input from a built-in mic on the main input mixer
intended to stop possible feedback loops between buit-in speakers
and built-in mics.  built-in mics also tend to capture machine
noise, especially fans.  actual recording should not be affected.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.130 2009/05/01 04:00:40 jakemsr Exp $	*/
d2424 3
a2541 1
		w->mixer_class = -1;
d2676 1
@


1.130
log
@initialize the mic ADC index before possibly setting it.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.129 2009/05/01 03:40:01 jakemsr Exp $	*/
d216 1
d1360 4
d1395 46
@


1.129
log
@make mic ADC selection a little more like speaker DAC selection
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.128 2009/05/01 02:45:30 jakemsr Exp $	*/
d1282 1
a1282 1
	this->speaker = this->spkr_dac = this->mic = -1;
a1346 2

	this->mic_adc = -1;
@


1.128
log
@try to get built-in speakers connected to a DAC no other output pin
connects to be default.  if that's not possible, try to make it so
that the speaker and the first output pin do not connect to the same
DAC by default.  allows more configuration freedom.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.127 2009/05/01 02:04:20 jakemsr Exp $	*/
d1398 1
a1398 1
	int i, j, err;
d1407 3
a1409 1
	w = &this->w[this->a_adcs[i]];
d1412 2
d1426 2
a1427 1
		if (w->connections[i] == this->mic)
d1429 1
@


1.127
log
@fix a couple bugs when finding sole connections
- if any pin can select both the target and other nids, it is not
  a sole connection
- if there is more than a single selection but the other selections are
  disabled, that's a sole connection as well
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.126 2009/04/27 23:49:04 jakemsr Exp $	*/
d215 1
d1361 4
d1641 78
@


1.126
log
@it's easier to have the speaker dac in the converter group than
to special case the speaker dac ...
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.125 2009/04/25 05:07:56 jakemsr Exp $	*/
d2328 1
a2328 1
	int i, j, target;
d2351 1
a2351 1
	j = -1;
d2353 3
a2355 2
		if (this->w[i].type == COP_AWTYPE_PIN_COMPLEX &&
		    this->w[i].nconnections == 1 &&
d2357 1
a2357 1
			if (j != -1)
d2359 21
a2379 1
			j = i;
d2382 2
a2383 2
	if (j != -1)
		return j;
@


1.125
log
@explicitely enable the "audio function" widget.  it can be a valid
source or endpoint.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.124 2009/04/25 05:02:40 jakemsr Exp $	*/
a2410 5
			}
			if (j == codec->dacs.groups[0].nconv &&
			    w->nid == codec->spkr_dac) {
				snprintf(w->name, sizeof(w->name), "%s%d",
				    wtypes[w->type], j + 1);
@


1.124
log
@beep generators are input endpoints.  but ther are not supposed
to be listed in other widgets' connection lists.  if a beep
generator is found in another widget's connection list, treat it
as a dead end.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.123 2009/04/24 16:29:49 jakemsr Exp $	*/
d1263 1
@


1.123
log
@make sure the internal/fixed mic is connected to an adc by default
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.122 2009/04/24 16:27:38 jakemsr Exp $	*/
d1652 1
d1697 1
d2701 3
@


1.122
log
@the internal/fixed speaker is special.  the dac it connects to
by default might not be in a converter group.  make sure such a
dac is not disabled and gets a meaningful name.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.121 2009/04/24 16:02:17 jakemsr Exp $	*/
d214 1
d1346 9
d1386 35
@


1.121
log
@create lists of analog and digital input and output pins.  store
the pin nids, the default converter the pin connects to and the
pin's priority.  priority is based on the pin's default direction
and the association and sequence numbers from the vendor.  according
to the hda spec, lower association/priority means higher priority.
sort the list in order of highest to lowest priority.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.120 2009/04/24 15:37:12 jakemsr Exp $	*/
d2363 5
@


1.120
log
@- a function to check if a node is connected to a particular adc by
  default
- a function to find the first adc in the adc list that a node is
  connected to
- use these functions to find which adc the internal mic is connected
  to by default
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.119 2009/04/24 15:31:18 jakemsr Exp $	*/
d213 1
d1345 4
d1379 214
d1889 24
@


1.119
log
@after all widgets have been initialized, loop through all widgets
and do some further initialization and information gathering:
- disable mixer and selector widgets that don't have any enabled
  connections
- create lists of analog and digital input and output converters
- find the internal/fixed connection microphone and speaker, and
  which converters they are connected to by default
- create a list of jack sensing capable pins

some of this was already being done in other places, but moved here
for simplification/better organization
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.118 2009/04/24 15:07:57 jakemsr Exp $	*/
d210 2
d1322 1
a1322 1
					this->mic_adc = -1;	/* XXX */
d1417 60
@


1.118
log
@"selected" connections don't mean much for mixer widgets.  all
connections to a mixer widget are enabled and unmuted by default.
when finding a default connection through a mixer, check all
connections, not just the "selected" connection.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.117 2009/04/04 02:59:39 jakemsr Exp $	*/
a208 1
int	azalia_codec_init_hp_spkr(codec_t *);
a1259 3
	this->speaker = -1;
	this->mic = -1;
	this->nsense_pins = 0;
d1273 5
a1277 4
	/* Find widgets without any enabled inputs and disable them.
	 * Must be done after all widgets are initialized and
	 * their connections created.
	 */
d1279 7
a1285 2
		if (this->w[i].type == COP_AWTYPE_AUDIO_MIXER ||
		    this->w[i].type == COP_AWTYPE_AUDIO_SELECTOR) {
d1288 51
d1341 1
a1355 4
	err = azalia_codec_init_hp_spkr(this);
	if (err)
		return err;

a1371 31
azalia_codec_init_hp_spkr(codec_t *this)
{
	int i;

	this->hp_dac = -1;
	this->spkr_dac = -1;

	if (this->speaker != -1)
		this->spkr_dac = azalia_codec_find_defdac(this,
		    this->speaker, 0);

	if (this->headphones == -1) {
		FOR_EACH_WIDGET(this, i) {
			if (this->w[i].type != COP_AWTYPE_PIN_COMPLEX)
				continue;
			if (this->w[i].d.pin.device == CORB_CD_LINEOUT &&
			    (this->w[i].d.pin.cap & COP_PINCAP_HEADPHONE)) {
				this->headphones = i;
				break;
			}
		}
	}

	if (this->headphones != -1)
		this->hp_dac = azalia_codec_find_defdac(this,
		    this->headphones, 0);

	return 0;
}

int
d1460 1
a1460 1
		    dac != this->hp_dac && dac != this->spkr_dac)
d1485 1
a1485 1
			    dac != this->hp_dac && dac != this->spkr_dac)
d1833 1
a1833 2
		} else if (w->nid == this->spkr_dac ||
		    w->nid == this->hp_dac) {
a2210 1
	codec_t *wcodec;
d2271 1
a2271 1
	if (CORB_CD_PORT(this->d.pin.config) == CORB_CD_NONE) {
a2272 48
		return 0;
	}

	/* need a non const codec pointer */
	wcodec = &codec->az->codecs[codec->az->codecno];

	if (codec->nsense_pins < HDA_MAX_SENSE_PINS &&
	    this->d.pin.cap & COP_PINCAP_PRESENCE &&
	    CORB_CD_PORT(this->d.pin.config) == CORB_CD_JACK) {
		/* check override bit */
		err = codec->comresp(codec, this->nid,
		    CORB_GET_CONFIGURATION_DEFAULT, 0, &result);
		if (err)
			return err;
		if (!(CORB_CD_MISC(result) & CORB_CD_PRESENCEOV)) {
			wcodec->sense_pins[wcodec->nsense_pins++] = this->nid;
		}
	}

	if (this->d.pin.device == CORB_CD_HEADPHONE &&
	    (this->d.pin.cap & COP_PINCAP_OUTPUT) &&
	    (CORB_CD_PORT(this->d.pin.config) == CORB_CD_JACK ||
	    CORB_CD_PORT(this->d.pin.config) == CORB_CD_BOTH)) {
		if (codec->headphones == -1 ||
		    (this->d.pin.association <
		    codec->w[codec->headphones].d.pin.association))
			wcodec->headphones = this->nid;
	}

	if (this->d.pin.device == CORB_CD_SPEAKER &&
	    (this->d.pin.cap & COP_PINCAP_OUTPUT) &&
	    (CORB_CD_PORT(this->d.pin.config) == CORB_CD_FIXED ||
	    CORB_CD_PORT(this->d.pin.config) == CORB_CD_BOTH)) {
		if (codec->speaker == -1 ||
		    (this->d.pin.association <
		    codec->w[codec->speaker].d.pin.association))
			wcodec->speaker = this->nid;
	}

	if (this->d.pin.device == CORB_CD_MICIN &&
	    (this->d.pin.cap & COP_PINCAP_INPUT) &&
	    (CORB_CD_PORT(this->d.pin.config) == CORB_CD_FIXED ||
	    CORB_CD_PORT(this->d.pin.config) == CORB_CD_BOTH)) {
		if (codec->mic == -1 ||
		    (this->d.pin.association <
		    codec->w[codec->mic].d.pin.association))
			wcodec->mic = this->nid;
	}
@


1.117
log
@- make sure codec->nsense_pins is initilized to 0
- don't mix use of const and non-const pointers

problem noted by Jordi Beltran Creix on tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.116 2009/02/05 01:25:21 oga Exp $	*/
d1356 1
a1356 1
	int ret;
d1373 19
a1391 5
		index = w->connections[w->selected];
		if (VALID_WIDGET_NID(index, this)) {
			ret = azalia_codec_find_defdac(this, index, depth);
			if (ret >= 0)
				return ret;
@


1.116
log
@Remove the BUS_DMA_NOCACHE flag from all azalia dma mappings.

The fact that this has only just been implemented, and that this
hardware is only found on x86 shows that this flag should not be needed
for operation of this hardware. It's been here since the initial netbsd
commit the code came from.

"sounds good to me" jakemsr@@, ok kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.115 2009/01/16 23:12:28 jakemsr Exp $	*/
d1263 1
d2257 1
a2257 2
			wcodec->sense_pins[codec->nsense_pins] = this->nid;
			wcodec->nsense_pins++;
@


1.115
log
@support 20 and 24-bit sample formats.  remove the unneeded "validbits"
handling.

ok ratchov; tested by naddy, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.114 2009/01/11 11:47:00 jakemsr Exp $	*/
a56 3
#ifndef BUS_DMA_NOCACHE
#define	BUS_DMA_NOCACHE 0
#endif
d1109 1
a1109 1
	    &d->addr, BUS_DMA_NOWAIT | BUS_DMA_COHERENT | BUS_DMA_NOCACHE);
@


1.114
log
@allow one more level of connections (3 instead of 2) away from DACs
for mixers and selectors when choosing the defaults for
outputs.master.slaves.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.113 2009/01/11 11:32:48 jakemsr Exp $	*/
a64 1
	u_int validbits;
d205 1
a205 2
void	azalia_codec_add_format(codec_t *, int, int, int, uint32_t,
	int32_t);
d1611 2
a1612 1
		if (bits_rates & COP_PCM_B32)
d1636 2
a1637 1
		if (bits_rates & COP_PCM_B32)
d1711 1
a1711 1
		azalia_codec_add_format(this, chan, 8, 16, bits_rates, mode);
d1713 1
a1713 1
		azalia_codec_add_format(this, chan, 16, 16, bits_rates, mode);
d1715 1
a1715 1
		azalia_codec_add_format(this, chan, 20, 32, bits_rates, mode);
d1717 1
a1717 1
		azalia_codec_add_format(this, chan, 24, 32, bits_rates, mode);
d1719 1
a1719 1
		azalia_codec_add_format(this, chan, 32, 32, bits_rates, mode);
d1723 2
a1724 2
azalia_codec_add_format(codec_t *this, int chan, int valid, int prec,
    uint32_t rates, int32_t mode)
d1731 1
a1731 1
	if (valid == 8 && prec == 8)
a1732 1
	f->validbits = valid;
d2820 3
d2835 4
d3195 3
a3210 13
	case 32:
		ret |= HDA_SD_FMT_BITS_32_32;
		break;
	}

#if 0
	switch (param->validbits) {
	case 8:
		ret |= HDA_SD_FMT_BITS_8_16;
		break;
	case 16:
		ret |= HDA_SD_FMT_BITS_16_16;
		break;
a3219 3
	default:
		printf("%s: invalid validbits: %u\n", __func__,
		    param->validbits);
a3220 1
#endif
a3267 2
		if (f.validbits != f.precision)
			continue;
@


1.113
log
@32-bit mode for s/pdif transmitters/receivers does not really
allow transmission/reception of 32-bit audio, so don't allow it.
pointed out by naddy@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.112 2009/01/05 09:40:26 jakemsr Exp $	*/
d1421 2
a1422 2
		 * Start the connection depth at 8 so it doesn't go more
		 * than 2 connections deep.
d1426 1
a1426 1
			j = 8;
d1451 1
a1451 1
				j = 8;
@


1.112
log
@- a little simplification
- don't set vref bits on mic pins unless the pin says it supports it
- fall back on 50% vref if 80% vref isn't supported
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.111 2009/01/05 08:50:06 jakemsr Exp $	*/
d1669 3
d1688 3
@


1.111
log
@explicitly check if azalia_codec_find_defdac didn't find a dac instead of
possibly matching a nonexistent hp or spkr dac.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.110 2009/01/05 08:03:46 jakemsr Exp $	*/
a2175 6
	typedef enum {
		PIN_DIR_IN,
		PIN_DIR_OUT,
		PIN_DIR_MIC
	} pintype_t;
	pintype_t pintype = PIN_DIR_IN;
d2177 1
a2177 1
	uint32_t result;
d2196 1
d2203 1
a2203 10
		pintype = PIN_DIR_OUT;
		break;
	case CORB_CD_CD:
	case CORB_CD_LINEIN:
	case CORB_CD_SPDIFIN:
	case CORB_CD_DIGITALIN:
		pintype = PIN_DIR_IN;
		break;
	case CORB_CD_MICIN:
		pintype = PIN_DIR_MIC;
d2207 11
a2217 18
	if (pintype == PIN_DIR_IN && !(this->d.pin.cap & COP_PINCAP_INPUT))
		pintype = PIN_DIR_OUT;
	if (pintype == PIN_DIR_OUT && !(this->d.pin.cap & COP_PINCAP_OUTPUT))
		pintype = PIN_DIR_IN;

	switch (pintype) {
	case PIN_DIR_IN:
		codec->comresp(codec, this->nid, CORB_SET_PIN_WIDGET_CONTROL,
		    CORB_PWC_INPUT, NULL);
		break;
	case PIN_DIR_OUT:
		codec->comresp(codec, this->nid, CORB_SET_PIN_WIDGET_CONTROL,
		    CORB_PWC_OUTPUT, NULL);
		break;
	case PIN_DIR_MIC:
		codec->comresp(codec, this->nid, CORB_SET_PIN_WIDGET_CONTROL,
		    CORB_PWC_INPUT|CORB_PWC_VREF_80, NULL);
		break;
d2219 3
@


1.110
log
@if the high bit is set in a connection list entry, it means the entry
is the end of a continuous list that started with the last entry.

while here, rewrite a bit so both long form and short form entries
are handled by the same code, and don't allocate more space than is
needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.109 2009/01/04 23:42:39 jakemsr Exp $	*/
d1428 2
d1453 2
@


1.109
log
@try to get better default outputs.master.slaves by not including
beep generators or mixers and selectors that are more than 2
connections away from a DAC.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.108 2009/01/03 19:17:45 jakemsr Exp $	*/
d2311 2
a2312 2
	boolean_t longform;
	int length, i;
d2322 5
a2326 1
	longform = (result & COP_CLL_LONG) != 0;
d2330 1
d2332 1
a2332 2
	this->connections = malloc(sizeof(nid_t) * (length + 3),
	    M_DEVBUF, M_NOWAIT);
d2337 17
a2353 19
	if (longform) {
		for (i = 0; i < length;) {
			err = codec->comresp(codec, this->nid,
			    CORB_GET_CONNECTION_LIST_ENTRY, i, &result);
			if (err)
				return err;
			this->connections[i++] = CORB_CLE_LONG_0(result);
			this->connections[i++] = CORB_CLE_LONG_1(result);
		}
	} else {
		for (i = 0; i < length;) {
			err = codec->comresp(codec, this->nid,
			    CORB_GET_CONNECTION_LIST_ENTRY, i, &result);
			if (err)
				return err;
			this->connections[i++] = CORB_CLE_SHORT_0(result);
			this->connections[i++] = CORB_CLE_SHORT_1(result);
			this->connections[i++] = CORB_CLE_SHORT_2(result);
			this->connections[i++] = CORB_CLE_SHORT_3(result);
@


1.108
log
@- configure volume knob widgets for indirect mode, which means they no
longer direcly affect other widgets
- if an unsolicited response is received from a volume knob widget,
adjust outputs.master according to the measured change in level of the
volume knob widget
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.107 2009/01/02 22:32:25 jakemsr Exp $	*/
d1419 9
a1427 1
		dac = azalia_codec_find_defdac(this, w->nid, 0);
d1432 3
a1434 1
			if (w->type == COP_AWTYPE_PIN_COMPLEX) {
d1446 5
a1450 1
			dac = azalia_codec_find_defdac(this, w->nid, 0);
d1453 2
@


1.107
log
@- get rid of the function that was mostly just a wrapper for the old
function for creating "master" volume control.
- apply gpio quirks separately from and prior to configuring the mixer.
gpio manipulation can cause noise on output channels.  configuring
gpio before amps are unmuted in the mixer configuration is a good
thing.

from Alexey Suslikov, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.106 2009/01/02 20:18:18 jakemsr Exp $	*/
d1452 10
a1461 8
	FOR_EACH_WIDGET(this, i) {
		w = &this->w[i];
		if (w->type != COP_AWTYPE_VOLUME_KNOB)
			continue;
		if (!(w->widgetcap & COP_AWCAP_UNSOL))
			continue;
		this->playvols.master = w->nid;
		break;
@


1.106
log
@this is what I really wanted with r1.100 of azalia.c - fixed mics
are not really useful as output devices and fixed speakers are not
really useful as input devices
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.105 2009/01/02 00:25:33 jakemsr Exp $	*/
d1311 4
@


1.105
log
@- store information about relevant volume controls along both
recording and playback paths.
- select a subset of controls that are relevant in a default
configuration for each path.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.104 2008/12/31 22:25:42 jakemsr Exp $	*/
d1267 1
a2175 8
	if (this->d.pin.device == CORB_CD_MICIN &&
	    CORB_CD_PORT(this->d.pin.config) == CORB_CD_FIXED)
		this->d.pin.cap &= ~(COP_PINCAP_OUTPUT);

	if (this->d.pin.device == CORB_CD_SPEAKER &&
	    CORB_CD_PORT(this->d.pin.config) == CORB_CD_FIXED)
		this->d.pin.cap &= ~(COP_PINCAP_INPUT);

d2269 10
@


1.104
log
@the channel_mask field of struct audio_format is unused, so removed
it and the associated macros.  this is part of NetBSD's "converter
pipeline", and it isn't really used there either.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.103 2008/12/31 12:54:43 jakemsr Exp $	*/
d216 1
d1305 5
a1309 1
	err = this->mixer_init(this);
d1313 1
a1313 1
	err = azalia_codec_init_hp_spkr(this);
d1381 152
@


1.103
log
@rewrite azalia_codec_connect_stream
- quit swapping channels 2:3 with 4:5 when processing 6 or more channels.
  hacks deep in drivers to "fix" wrongly encoded files is just wrong.
- try to be sure headphones AND speakers get DAC output by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.102 2008/12/31 12:47:30 jakemsr Exp $	*/
a67 27
	u_int channel_mask;
#define	AUFMT_UNKNOWN_POSITION		0U
#define	AUFMT_FRONT_LEFT		0x00001U /* USB audio compatible */
#define	AUFMT_FRONT_RIGHT		0x00002U /* USB audio compatible */
#define	AUFMT_FRONT_CENTER		0x00004U /* USB audio compatible */
#define	AUFMT_LOW_FREQUENCY		0x00008U /* USB audio compatible */
#define	AUFMT_BACK_LEFT			0x00010U /* USB audio compatible */
#define	AUFMT_BACK_RIGHT		0x00020U /* USB audio compatible */
#define	AUFMT_FRONT_LEFT_OF_CENTER	0x00040U /* USB audio compatible */
#define	AUFMT_FRONT_RIGHT_OF_CENTER	0x00080U /* USB audio compatible */
#define	AUFMT_BACK_CENTER		0x00100U /* USB audio compatible */
#define	AUFMT_SIDE_LEFT			0x00200U /* USB audio compatible */
#define	AUFMT_SIDE_RIGHT		0x00400U /* USB audio compatible */
#define	AUFMT_TOP_CENTER		0x00800U /* USB audio compatible */
#define	AUFMT_TOP_FRONT_LEFT		0x01000U
#define	AUFMT_TOP_FRONT_CENTER		0x02000U
#define	AUFMT_TOP_FRONT_RIGHT		0x04000U
#define	AUFMT_TOP_BACK_LEFT		0x08000U
#define	AUFMT_TOP_BACK_CENTER		0x10000U
#define	AUFMT_TOP_BACK_RIGHT		0x20000U

#define	AUFMT_MONAURAL		AUFMT_FRONT_CENTER
#define	AUFMT_STEREO		(AUFMT_FRONT_LEFT | AUFMT_FRONT_RIGHT)
#define	AUFMT_SURROUND4		(AUFMT_STEREO | AUFMT_BACK_LEFT \
				| AUFMT_BACK_RIGHT)
#define	AUFMT_DOLBY_5_1		(AUFMT_SURROUND4 | AUFMT_FRONT_CENTER \
				| AUFMT_LOW_FREQUENCY)
a1545 20
	switch (chan) {
	case 1:
		f->channel_mask = AUFMT_MONAURAL;
		break;
	case 2:
		f->channel_mask = AUFMT_STEREO;
		break;
	case 4:
		f->channel_mask = AUFMT_SURROUND4;
		break;
	case 6:
		f->channel_mask = AUFMT_DOLBY_5_1;
		break;
	case 8:
		f->channel_mask = AUFMT_DOLBY_5_1
		    | AUFMT_SIDE_LEFT | AUFMT_SIDE_RIGHT;
		break;
	default:
		f->channel_mask = 0;
	}
@


1.102
log
@actually find the speakers and headphones
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.101 2008/12/31 11:54:55 jakemsr Exp $	*/
d1640 3
a1642 4
	uint32_t v;
	int i, err, startchan, nchan;
	nid_t nid;
	boolean_t flag222;
a1643 1
	DPRINTFN(1, ("%s: fmt=0x%4.4x number=%d\n", __func__, fmt, number));
d1645 2
d1651 2
a1652 6
	flag222 = group->nconv >= 3 &&
	    (WIDGET_CHANNELS(&this->w[group->conv[0]]) == 2) &&
	    (WIDGET_CHANNELS(&this->w[group->conv[1]]) == 2) &&
	    (WIDGET_CHANNELS(&this->w[group->conv[2]]) == 2);
	nchan = (fmt & HDA_SD_FMT_CHAN) + 1;
	startchan = 0;
d1654 2
a1655 2
		uint32_t stream_chan;
		nid = group->conv[i];
d1657 14
a1670 5
		/* surround and c/lfe handling */
		if (nchan >= 6 && flag222 && i == 1) {
			nid = group->conv[2];
		} else if (nchan >= 6 && flag222 && i == 2) {
			nid = group->conv[1];
d1673 14
a1686 4
		if (startchan >= nchan)
			stream_chan = 0; /* stream#0 */
		else
			stream_chan = (number << 4) | startchan;
d1688 16
a1703 15
		err = this->comresp(this, nid, CORB_SET_CONVERTER_FORMAT,
				    fmt, NULL);
		if (err)
			goto exit;
		err = this->comresp(this, nid, CORB_SET_CONVERTER_STREAM_CHANNEL,
				    stream_chan, NULL);
		if (err)
			goto exit;
		if (this->w[nid].widgetcap & COP_AWCAP_DIGITAL) {
			/* enable S/PDIF */
			this->comresp(this, nid, CORB_GET_DIGITAL_CONTROL,
			    0, &v);
			v = (v & 0xff) | CORB_DCC_DIGEN;
			this->comresp(this, nid, CORB_SET_DIGITAL_CONTROL_L,
			    v, NULL);
d1705 1
a1705 1
		startchan += WIDGET_CHANNELS(&this->w[nid]);
a1707 2
exit:
	DPRINTFN(1, ("%s: leave with %d\n", __func__, err));
@


1.101
log
@builtin speakers and headphone jacks have an interesting relationship.
keep track of some information about them, such as the DAC they are
connected to by default.  this will be used soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.100 2008/12/31 11:25:36 jakemsr Exp $	*/
d2133 21
@


1.100
log
@a fixed mic isn't very useful as an output device, and a fixed
speaker isn't very useful as an input device
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.99 2008/12/31 11:23:55 jakemsr Exp $	*/
d241 2
d1291 2
d1320 3
d1327 7
a1333 1
	azalia_codec_print_groups(this);
d1335 1
a1335 1
	err = azalia_codec_construct_format(this, 0, 0);
d1339 64
a1402 1
	return this->mixer_init(this);
@


1.99
log
@- rearrange to be able to return earlier if nothing left to
- remove a couple pointless comments
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.98 2008/12/31 11:18:47 jakemsr Exp $	*/
d1974 8
@


1.98
log
@- always check that max channels isn't exceeded
- make the code readable and the comment understandable
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.97 2008/12/30 08:57:26 jakemsr Exp $	*/
a1998 4
	/* Disable unconnected pins */
	if (CORB_CD_PORT(this->d.pin.config) == CORB_CD_NONE)
		this->enable = 0;

a2013 1
	/* EAPD pin */
d2026 10
a2035 1
	/* sense pin */
a2044 1
			wcodec = &codec->az->codecs[codec->az->codecno];
@


1.97
log
@- if widget X will be named for widget Y and widget Y is disabled,
widget X should be disabled as well.
- change the comment about renaming widgets to better explain why
instead of how the renaming is done.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.96 2008/12/25 22:15:05 jakemsr Exp $	*/
a2931 1
#ifdef DIAGNOSTIC
a2936 4
#endif
	/* allow any number of channels in a native format */
	if (param->sw_code == NULL)
		ret |= param->channels - 1;
d2938 3
a2940 1
	/* emulated mono uses 2 channel formats */
d2942 1
a2942 1
		ret |= 1;
@


1.96
log
@currently azalia only supports one codec.  instead of using simply the
first codec with an audio function group, use the first codec with
an audio function group that can do analog I/O, if there is one.
codecs that just do digital I/O aren't quite as useful, yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.95 2008/12/25 00:58:15 jakemsr Exp $	*/
d1740 1
a1740 2
		    this->w[i].connections[0] == nid &&
		    azalia_widget_enabled(this, this->w[i].connections[0])) {
d1855 3
a1857 2
	/* Rename mixers and selectors that connect to only one other
	 * widget as the widget they are connected to.
d1886 10
@


1.95
log
@before naming a widget after a pin because the widget is the only thing
the pin is connected to, make sure the pin is the only device that is
connected to the widget.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.94 2008/12/25 00:20:36 jakemsr Exp $	*/
d668 2
a669 1
	int err, i, c;
d689 1
a689 1
	c = -1;
d692 2
a693 2
		if (!err && c < 0)
			c = i;
d695 1
a695 1
	if (c < 0) {
d699 22
a720 1
	/* Use the first audio codec */
d722 4
d739 13
d1340 1
d1346 5
@


1.94
log
@- one "default" direction is enough
- be careful not to set a direction that the pin doesn't support
- remove a workaround in the generic code which is more or less for a
specific device, there are better ways to deal with such situations now
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.93 2008/12/23 09:33:49 jakemsr Exp $	*/
d1691 1
d1697 3
a1699 1
			return i;
d1702 3
@


1.93
log
@gather up most of the code for printing debug info in dmesgs and
move it to one place, instead of scattered thoughout with #define
and DPRINTF.  my eyes are happier now.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.92 2008/12/23 08:57:28 jakemsr Exp $	*/
a1913 5
	if (!(this->d.pin.cap & COP_PINCAP_INPUT))
		pintype = PIN_DIR_OUT;
	if (!(this->d.pin.cap & COP_PINCAP_OUTPUT))
		pintype = PIN_DIR_IN;

d1933 5
a1940 6

	/* Workaround broken machines which have their actual
	   output on ports marked conn=none (e.g. MacBookPro1,2).
	   Should not harm correct codec configurations. */
	if (!this->enable)
		pintype = PIN_DIR_OUT;
@


1.92
log
@line-in is now "line-in", line-out is still "line".  S/PDIF-out is
now "SPDIF", S/PDIF-in is still "SPDIF-in".
line change because we need to differentiate.  S/PDIF change because
SPDIF-out is too long, and for consistency.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.91 2008/12/23 04:12:19 jakemsr Exp $	*/
d239 2
d249 3
a251 5
#ifdef AZALIA_DEBUG
int	azalia_widget_dump_info(const widget_t *, const codec_t *);
int	azalia_widget_print_audio(const widget_t *, const char *);
int	azalia_widget_print_pin(const widget_t *);
#endif
a338 19
#ifdef AZALIA_DEBUG
static const char *pin_colors[16] = {
	"unknown", "black", "gray", "blue",
	"green", "red", "orange", "yellow",
	"purple", "pink", "col0a", "col0b",
	"col0c", "col0d", "white", "other"};
static const char *pin_conn[4] = {
	"jack", "none", "fixed", "combined"};
static const char *pin_conntype[16] = {
	"unknown", "1/8", "1/4", "atapi", "rca", "optical",
	"digital", "analog", "din", "xlr", "rj-11", "combination",
	"con0c", "con0d", "con0e", "other"};
static const char *pin_geo[15] = {
	"n/a", "rear", "front", "left",
	"right", "top", "bottom", "spec0", "spec1", "spec2",
	"loc0a", "loc0b", "loc0c", "loc0d", "loc0f"};
static const char *pin_chass[4] = {
	"external", "internal", "separate", "other"};
#endif
d1184 1
a1184 1
	    __func__, n, this->nfunctions));
d1243 2
a1244 17
#ifdef AZALIA_DEBUG
	azalia_widget_print_audio(&this->w[this->audiofunc], "\t");
	result = this->w[this->audiofunc].inamp_cap;
	DPRINTF(("\tinamp: mute=%u size=%u steps=%u offset=%u\n",
	    (result & COP_AMPCAP_MUTE) != 0, COP_AMPCAP_STEPSIZE(result),
	    COP_AMPCAP_NUMSTEPS(result), COP_AMPCAP_OFFSET(result)));
	result = this->w[this->audiofunc].outamp_cap;
	DPRINTF(("\toutamp: mute=%u size=%u steps=%u offset=%u\n",
	    (result & COP_AMPCAP_MUTE) != 0, COP_AMPCAP_STEPSIZE(result),
	    COP_AMPCAP_NUMSTEPS(result), COP_AMPCAP_OFFSET(result)));
	this->comresp(this, this->audiofunc, CORB_GET_PARAMETER,
	    COP_GPIO_COUNT, &result);
	DPRINTF(("\tgpio: wake=%u unsol=%u gpis=%u gpos=%u gpios=%u\n",
	    (result & COP_GPIO_WAKE) != 0, (result & COP_GPIO_UNSOL) != 0,
	    COP_GPIO_GPIS(result), COP_GPIO_GPOS(result),
	    COP_GPIO_GPIOS(result)));
#endif
d1257 3
a1259 5
#ifdef AZALIA_DEBUG
		err = azalia_widget_dump_info(&this->w[i], this);
		if (err)
			return err;
#endif
d1280 3
a1282 16
#ifdef AZALIA_DEBUG
	for (i = 0; i < this->dacs.ngroups; i++) {
		DPRINTF(("%s: dacgroup[%d]:", __func__, i));
		for (n = 0; n < this->dacs.groups[i].nconv; n++) {
			DPRINTF((" %2.2x", this->dacs.groups[i].conv[n]));
		}
		DPRINTF(("\n"));
	}
	for (i = 0; i < this->adcs.ngroups; i++) {
		DPRINTF(("%s: adcgroup[%d]:", __func__, i));
		for (n = 0; n < this->adcs.groups[i].nconv; n++) {
			DPRINTF((" %2.2x", this->adcs.groups[i].conv[n]));
		}
		DPRINTF(("\n"));
	}
#endif
a1605 5
#define	WIDGETCAP_BITS							\
    "\20\014LRSWAP\013POWER\012DIGITAL"					\
    "\011CONNLIST\010UNSOL\07PROC\06STRIPE\05FORMATOV\04AMPOV\03OUTAMP"	\
    "\02INAMP\01STEREO"

a1884 18
#define	ENCODING_BITS	"\20\3AC3\2FLOAT32\1PCM"
#define	BITSRATES_BITS	"\20\x15""32bit\x14""24bit\x13""20bit"		\
    "\x12""16bit\x11""8bit""\x0c""384kHz\x0b""192kHz\x0a""176.4kHz"	\
    "\x09""96kHz\x08""88.2kHz\x07""48kHz\x06""44.1kHz\x05""32kHz\x04"	\
    "22.05kHz\x03""16kHz\x02""11.025kHz\x01""8kHz"

#ifdef AZALIA_DEBUG
int
azalia_widget_print_audio(const widget_t *this, const char *lead)
{
	printf("%sencodings=%b\n", lead, this->d.audio.encodings,
	    ENCODING_BITS);
	printf("%sPCM formats=%b\n", lead, this->d.audio.bits_rates,
	    BITSRATES_BITS);
	return 0;
}
#endif

a1993 88
#define	PINCAP_BITS	"\20\021EAPD\16VREF100\15VREF80" \
    "\13VREFGND\12VREF50\11VREFHIZ\07BALANCE\06INPUT" \
    "\05OUTPUT\04HEADPHONE\03PRESENCE\02TRIGGER\01IMPEDANCE"

#ifdef AZALIA_DEBUG
int
azalia_widget_dump_info(const widget_t *w, const codec_t *codec)
{
	int i;

	printf("%s: ", XNAME(codec->az));
	printf("%s%2.2x wcap=%b\n", w->type == COP_AWTYPE_PIN_COMPLEX ?
	    pin_colors[w->d.pin.color] : wtypes[w->type],
	    w->nid, w->widgetcap, WIDGETCAP_BITS);
	if (w->widgetcap & COP_AWCAP_FORMATOV)
		azalia_widget_print_audio(w, "\t");
	if (w->type == COP_AWTYPE_PIN_COMPLEX)
		azalia_widget_print_pin(w);

	if (w->type == COP_AWTYPE_VOLUME_KNOB)
		printf("\tdelta=%d steps=%d\n",
		    !!(w->d.volume.cap & COP_VKCAP_DELTA),
		    COP_VKCAP_NUMSTEPS(w->d.volume.cap));

	if ((w->widgetcap & COP_AWCAP_INAMP) &&
	    (w->widgetcap & COP_AWCAP_AMPOV))
		printf("\tinamp: mute=%u size=%u steps=%u offset=%u\n",
		    (w->inamp_cap & COP_AMPCAP_MUTE) != 0,
		    COP_AMPCAP_STEPSIZE(w->inamp_cap),
		    COP_AMPCAP_NUMSTEPS(w->inamp_cap),
		    COP_AMPCAP_OFFSET(w->inamp_cap));

	if ((w->widgetcap & COP_AWCAP_OUTAMP) &&
	    (w->widgetcap & COP_AWCAP_AMPOV))
		printf("\toutamp: mute=%u size=%u steps=%u offset=%u\n",
		    (w->outamp_cap & COP_AMPCAP_MUTE) != 0,
		    COP_AMPCAP_STEPSIZE(w->outamp_cap),
		    COP_AMPCAP_NUMSTEPS(w->outamp_cap),
		    COP_AMPCAP_OFFSET(w->outamp_cap));

	if (w->nconnections > 0) {
		printf("\tconnections=0x%x", w->connections[0]);
		for (i = 1; i < w->nconnections; i++)
			printf(",0x%x", w->connections[i]);
		printf("; selected=0x%x\n", w->connections[w->selected]);
	}

	return 0;
}

int
azalia_widget_print_pin(const widget_t *this)
{
	printf("\tcap=%b\n", this->d.pin.cap, PINCAP_BITS);
	printf("\t[%2.2d/%2.2d] ", CORB_CD_ASSOCIATION(this->d.pin.config),
	    CORB_CD_SEQUENCE(this->d.pin.config));
	printf("color=%s ", pin_colors[CORB_CD_COLOR(this->d.pin.config)]);
	printf("device=%s ", pin_devices[CORB_CD_DEVICE(this->d.pin.config)]);
	printf("conn=%s ", pin_conn[CORB_CD_PORT(this->d.pin.config)]);
	printf("conntype=%s\n", pin_conntype[CORB_CD_CONNECTION(this->d.pin.config)]);
	printf("\tlocation=%s ", pin_geo[CORB_CD_LOC_GEO(this->d.pin.config)]);
	printf("chassis=%s ", pin_chass[CORB_CD_LOC_CHASS(this->d.pin.config)]);
	printf("special=");
	if (CORB_CD_LOC_GEO(this->d.pin.config) == CORB_CD_LOC_SPEC0) {
		if (CORB_CD_LOC_CHASS(this->d.pin.config) == CORB_CD_EXTERNAL)
			printf("rear-panel");
		else if (CORB_CD_LOC_CHASS(this->d.pin.config) == CORB_CD_INTERNAL)
			printf("riser");
		else if (CORB_CD_LOC_CHASS(this->d.pin.config) == CORB_CD_LOC_OTHER)
			printf("mobile-lid-internal");
	} else if (CORB_CD_LOC_GEO(this->d.pin.config) == CORB_CD_LOC_SPEC1) {
		if (CORB_CD_LOC_CHASS(this->d.pin.config) == CORB_CD_EXTERNAL)
			printf("drive-bay");
		else if (CORB_CD_LOC_CHASS(this->d.pin.config) == CORB_CD_INTERNAL)
			printf("hdmi");
		else if (CORB_CD_LOC_CHASS(this->d.pin.config) == CORB_CD_LOC_OTHER)
			printf("mobile-lid-external");
	} else if (CORB_CD_LOC_GEO(this->d.pin.config) == CORB_CD_LOC_SPEC2) {
		if (CORB_CD_LOC_CHASS(this->d.pin.config) == CORB_CD_INTERNAL)
			printf("atapi");
	} else
		printf("none");
	printf("\n");

	return 0;
}
#endif

d2080 185
@


1.91
log
@a) a widget's nid is always it's index in the codec's widget list.
b) members of the widget connection list may be invalid.
so,
- change azalia_nid_to_index to azalia_widget_enabled, and have it only
check that the given nid is valid, and that the corresponding widget
is enabled.
- use azalia_widget_enabled every time members of the connection list
are used.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.90 2008/12/23 00:20:03 jakemsr Exp $	*/
d332 2
a333 2
	"SPDIF-out", "digital-out", "modem-line", "modem-handset",
	AudioNline, AudioNaux, AudioNmicrophone, "telephony",
d1777 7
a1783 18
			if (w->d.pin.device == CORB_CD_LINEIN) {
				pins[CORB_CD_LINEOUT]++;
				if (pins[CORB_CD_LINEOUT] > 1)
					snprintf(w->name, sizeof(w->name), "%s%d",
					    pin_devices[CORB_CD_LINEOUT],
					    pins[CORB_CD_LINEOUT]);
				else
					snprintf(w->name, sizeof(w->name), "%s",
					    pin_devices[CORB_CD_LINEOUT]);
			} else {
				if (pins[w->d.pin.device] > 1)
					snprintf(w->name, sizeof(w->name), "%s%d",
					    pin_devices[w->d.pin.device],
					    pins[w->d.pin.device]);
				else
					snprintf(w->name, sizeof(w->name), "%s",
					    pin_devices[w->d.pin.device]);
			}
@


1.90
log
@backout previous.  changing the index of valid nids breaks things.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.88 2008/12/22 03:18:02 jakemsr Exp $	*/
d1748 2
a1749 1
		    this->w[i].connections[0] == nid) {
d1890 2
d1896 1
a1896 1
					j = -1;
d2243 1
a2243 2
		if (!VALID_WIDGET_NID(w->connections[i], codec) ||
		    !codec->w[w->connections[i]].enable)
@


1.89
log
@don't add invalid widgets to connection lists.
@
text
@a2168 2
	nid_t *connections;
	int nconnections, nconn;
d2182 4
a2185 3
	nconnections = length;
	connections = malloc(sizeof(nid_t) * (length + 3), M_DEVBUF, M_NOWAIT);
	if (connections == NULL) {
d2195 2
a2196 2
			connections[i++] = CORB_CLE_LONG_0(result);
			connections[i++] = CORB_CLE_LONG_1(result);
d2204 4
a2207 4
			connections[i++] = CORB_CLE_SHORT_0(result);
			connections[i++] = CORB_CLE_SHORT_1(result);
			connections[i++] = CORB_CLE_SHORT_2(result);
			connections[i++] = CORB_CLE_SHORT_3(result);
a2209 24

	/* don't add invalid widgets to the connection list */
	nconn = 0;
	for (i = 0; i < nconnections; i++) {
		if (VALID_WIDGET_NID(connections[i], codec))
			nconn++;
		else
			DPRINTF(("%s: nid %2.2x invalid connection: %2.2x\n",
			    XNAME(codec->az), this->nid, connections[i]));
	}
	this->nconnections = nconn;
	this->connections = malloc(sizeof(nid_t) * this->nconnections,
	    M_DEVBUF, M_NOWAIT);
	if (this->connections == NULL) {
		printf("%s: out of memory\n", XNAME(codec->az));
		return ENOMEM;
	}
	nconn = 0;
	for (i = 0; i < nconnections && nconn < this->nconnections; i++) {
		if (VALID_WIDGET_NID(connections[i], codec))
			this->connections[nconn++] = connections[i];
	}
	free(connections, M_DEVBUF);

@


1.88
log
@hex for unused widget names
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.87 2008/12/22 03:00:17 jakemsr Exp $	*/
d2169 2
d2184 3
a2186 4
	this->nconnections = length;
	this->connections = malloc(sizeof(nid_t) * (length + 3),
	    M_DEVBUF, M_NOWAIT);
	if (this->connections == NULL) {
d2196 2
a2197 2
			this->connections[i++] = CORB_CLE_LONG_0(result);
			this->connections[i++] = CORB_CLE_LONG_1(result);
d2205 4
a2208 4
			this->connections[i++] = CORB_CLE_SHORT_0(result);
			this->connections[i++] = CORB_CLE_SHORT_1(result);
			this->connections[i++] = CORB_CLE_SHORT_2(result);
			this->connections[i++] = CORB_CLE_SHORT_3(result);
d2211 24
@


1.87
log
@set a default name for widgets (u-wid$NID) and don't try to give
disabled widgets any other name.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.86 2008/12/22 01:32:39 jakemsr Exp $	*/
d1770 1
a1770 1
		snprintf(w->name, sizeof(w->name), "u-wid%d", w->nid);
@


1.86
log
@special case after general case.  it's better to be named after
a converter than a selector.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.85 2008/12/22 00:03:08 jakemsr Exp $	*/
a1757 1
	int i, j, found;
a1758 1

d1761 1
d1769 4
d1796 3
a1798 9
			found = 0;
			if (codec->dacs.ngroups < 1) {
				found = 1;
				/* should not happen */
				snprintf(w->name, sizeof(w->name), "u-dac%2.2x",
				    w->nid);
			}
			for (j = 0; found == 0 &&
			    j < codec->dacs.groups[0].nconv; j++) {
a1799 1
					found = 1;
d1801 3
a1803 3
						snprintf(w->name, sizeof(w->name),
						    "%s%d", wtypes[w->type],
						    j + 1);
d1805 4
a1808 2
						snprintf(w->name, sizeof(w->name),
						    "%s", wtypes[w->type]);
d1811 3
a1813 8
			if (found == 0 && codec->dacs.ngroups < 2) {
				found = 1;
				/* should not happen */
				snprintf(w->name, sizeof(w->name), "u-dac%2.2x",
				    w->nid);
			}
			for (j = 0; found == 0 &&
			    j < codec->dacs.groups[1].nconv; j++) {
a1814 1
					found = 1;
d1816 3
a1818 3
						snprintf(w->name, sizeof(w->name),
						    "dig-%s%d", wtypes[w->type],
						    j + 1);
d1820 3
a1822 2
						snprintf(w->name, sizeof(w->name),
						    "dig-%s", wtypes[w->type]);
a1824 5
			if (found == 0) {
				/* should not happen */
				snprintf(w->name, sizeof(w->name), "u-dac%2.2x",
				    w->nid);
			}
d1827 2
d1830 1
a1830 9
			found = 0;
			if (codec->adcs.ngroups < 1) {
				found = 1;
				/* should not happen */
				snprintf(w->name, sizeof(w->name), "u-adc%2.2x",
				    w->nid);
			}
			for (j = 0; found == 0 &&
			    j < codec->adcs.groups[0].nconv; j++) {
a1831 1
					found = 1;
d1833 3
a1835 3
						snprintf(w->name, sizeof(w->name),
						    "%s%d", wtypes[w->type],
						    j + 1);
d1837 3
a1839 2
						snprintf(w->name, sizeof(w->name),
						    "%s", wtypes[w->type]);
d1842 3
a1844 8
			if (found == 0 && codec->adcs.ngroups < 2) {
				found = 1;
				/* should not happen */
				snprintf(w->name, sizeof(w->name), "u-adc%2.2x",
				    w->nid);
			}
			for (j = 0; found == 0 &&
			    j < codec->adcs.groups[1].nconv; j++) {
a1845 1
					found = 1;
d1847 3
a1849 3
						snprintf(w->name, sizeof(w->name),
						    "dig-%s%d", wtypes[w->type],
						    j + 1);
d1851 3
a1853 2
						snprintf(w->name, sizeof(w->name),
						    "dig-%s", wtypes[w->type]);
a1855 5
			if (found == 0) {
				/* should not happen */
				snprintf(w->name, sizeof(w->name), "u-adc%2.2x",
				    w->nid);
			}
d1875 2
@


1.85
log
@- expand/add macros for pin configuration manipulation
- use "beep" as pin device 0xe
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.84 2008/12/21 21:25:01 jakemsr Exp $	*/
d1904 17
a1920 14
		/* Special case.  A selector with outamp capabilities
		 * and is connected to a single widget that has no
		 * inamp capabilities.  This widget serves only to act
		 * as the input amp for the widget it is connected to.
		 */
		j = -1;
		if (codec->w[i].type == COP_AWTYPE_AUDIO_SELECTOR &&
		    (codec->w[i].widgetcap & COP_AWCAP_OUTAMP) &&
		    codec->w[i].nconnections == 1) {
			j = codec->w[i].connections[0];
			if (!(codec->w[j].widgetcap & COP_AWCAP_INAMP))
				codec->w[i].mixer_class = AZ_CLASS_INPUT;
			else
				j = -1;
a1921 2
		if (j == -1)
			j = azalia_widget_sole_conn(codec, i);
@


1.84
log
@move the codec specific widget initialization out of
azalia_widget_label_widgets to right after the generic widget
initialization.  nothing uses this yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.83 2008/12/21 20:47:55 jakemsr Exp $	*/
d334 1
a334 1
	"SPDIF-in", "digital-in", "dev0e", "other"};
@


1.83
log
@if a widget is the sole connection to another widget, name the
widget for the widget it's connected to.  but be a bit careful
to not end up with duplicate mixer item names.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.82 2008/12/21 20:44:04 jakemsr Exp $	*/
d1296 2
a1894 2
		if (codec->init_widget != NULL)
			codec->init_widget(codec, w, w->nid);
@


1.82
log
@label converter widgets for their place in the converter group.
e.g. the first DAC in the converter group is now dac, the second
is dac2, etc.

unused converters (not in a converter group) will have a "u-" prefix.
these will disappear completely in the near future, as they are useless.

if there is more than one converter group, converters in the second
group will have a "dig-" prefix, since they are digital converters.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.81 2008/12/21 20:32:46 jakemsr Exp $	*/
d1896 33
@


1.81
log
@a little rearranging:

- move the azalia_widget_init_connection call from
azalia_widget_label_widgets to just after azalia_widget_init
- move azalia_widget_label_widgets to after dacgroup initialization
- move the widget info printing from azalia_widget_init_connection
and azalia_widget_init to new function azalia_widget_dump_info
- call azalia_widget_dump_info right after azalia_widget_init_connection
- in functions that are ony used if AZALIA_DEBUG is defined, use printf
instead of DPRINTF()
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.80 2008/12/21 20:17:16 jakemsr Exp $	*/
d1756 1
a1756 1
	int i;
d1767 3
a1769 1
		if (w->type == COP_AWTYPE_PIN_COMPLEX) {
d1789 95
a1883 1
		} else {
d1891 1
a1891 1

@


1.80
log
@add function azalia_widget_sole_conn, which determines if the
given widget is the sole connection to an ADC, DAC or pin complex.
not used just yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.79 2008/11/30 20:06:41 jakemsr Exp $	*/
d248 1
d1288 8
a1296 3
	err = azalia_widget_label_widgets(this);
	if (err)
		return err;
d1311 3
a1329 1

a1765 1
		DPRINTF(("%s: ", XNAME(codec->az)));
a1798 29
#ifdef AZALIA_DEBUG
		DPRINTF(("%s%2.2x wcap=%b\n", w->type == COP_AWTYPE_PIN_COMPLEX ?
		    pin_colors[w->d.pin.color] : wtypes[w->type],
		    w->nid, w->widgetcap, WIDGETCAP_BITS));
		if (w->widgetcap & COP_AWCAP_FORMATOV)
			azalia_widget_print_audio(w, "\t");
		if (w->type == COP_AWTYPE_PIN_COMPLEX)
			azalia_widget_print_pin(w);

		if (w->type == COP_AWTYPE_VOLUME_KNOB)
                        DPRINTF(("\tdelta=%d steps=%d\n",
			    !!(w->d.volume.cap & COP_VKCAP_DELTA),
			    COP_VKCAP_NUMSTEPS(w->d.volume.cap)));

		if ((w->widgetcap & COP_AWCAP_INAMP) && (w->widgetcap & COP_AWCAP_AMPOV))
			DPRINTF(("\tinamp: mute=%u size=%u steps=%u offset=%u\n",
			    (w->inamp_cap & COP_AMPCAP_MUTE) != 0,
			    COP_AMPCAP_STEPSIZE(w->inamp_cap),
			    COP_AMPCAP_NUMSTEPS(w->inamp_cap),
			    COP_AMPCAP_OFFSET(w->inamp_cap)));

		if ((w->widgetcap & COP_AWCAP_OUTAMP) && (w->widgetcap & COP_AWCAP_AMPOV))
			DPRINTF(("\toutamp: mute=%u size=%u steps=%u offset=%u\n",
			    (w->outamp_cap & COP_AMPCAP_MUTE) != 0,
			    COP_AMPCAP_STEPSIZE(w->outamp_cap),
			    COP_AMPCAP_NUMSTEPS(w->outamp_cap),
			    COP_AMPCAP_OFFSET(w->outamp_cap)));
#endif
		azalia_widget_init_connection(w, codec);
d1976 45
d2023 10
a2032 10
	DPRINTF(("\tcap=%b\n", this->d.pin.cap, PINCAP_BITS));
	DPRINTF(("\t[%2.2d/%2.2d] ", CORB_CD_ASSOCIATION(this->d.pin.config),
	    CORB_CD_SEQUENCE(this->d.pin.config)));
	DPRINTF(("color=%s ", pin_colors[CORB_CD_COLOR(this->d.pin.config)]));
	DPRINTF(("device=%s ", pin_devices[CORB_CD_DEVICE(this->d.pin.config)]));
	DPRINTF(("conn=%s ", pin_conn[CORB_CD_PORT(this->d.pin.config)]));
	DPRINTF(("conntype=%s\n", pin_conntype[CORB_CD_CONNECTION(this->d.pin.config)]));
	DPRINTF(("\tlocation=%s ", pin_geo[CORB_CD_LOC_GEO(this->d.pin.config)]));
	DPRINTF(("chassis=%s ", pin_chass[CORB_CD_LOC_CHASS(this->d.pin.config)]));
	DPRINTF(("special="));
d2035 1
a2035 1
			DPRINTF(("rear-panel"));
d2037 1
a2037 1
			DPRINTF(("riser"));
d2039 1
a2039 1
			DPRINTF(("mobile-lid-internal"));
d2042 1
a2042 1
			DPRINTF(("drive-bay"));
d2044 1
a2044 1
			DPRINTF(("hdmi"));
d2046 1
a2046 1
			DPRINTF(("mobile-lid-external"));
d2049 1
a2049 1
			DPRINTF(("atapi"));
d2051 2
a2052 2
		DPRINTF(("none"));
	DPRINTF(("\n"));
a2106 5
		DPRINTF(("\tconnections=0x%x", this->connections[0]));
		for (i = 1; i < length; i++) {
			DPRINTF((",0x%x", this->connections[i]));
		}

a2111 1
		DPRINTF(("; selected=0x%x\n", this->connections[result]));
@


1.79
log
@if an input mixer or selector has no usable inputs, disable it, as
it is useless.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.78 2008/11/30 08:36:57 jakemsr Exp $	*/
d246 1
d1707 36
@


1.78
log
@- AZ_MAX_SENSE_PINS -> HDA_MAX_SENSE_PINS
- MI_TARGET_* are enumerated in hex

from Alexey Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.77 2008/11/30 03:50:29 jakemsr Exp $	*/
d245 1
d1290 11
d2061 30
@


1.77
log
@- don't access nonexistent converter goups
- don't try to create formats for converter groups that don't exist
- don't allow playback or recording if there is no corresponding
converter group
- don't try to set audio processing parameters on converter groups
that don't exist

allows playback (or record) only devices to work, such as the
azalias found on ATI graphics devices.

note, the ATI devices generally attach before the onboard devices
do.  that means they will be audio0 and onboard devices will be audio1.
don't forget to make sure the /dev/{audio[ctl],mixer,sound} links
point to the nodes of the device you want to be the default.

tested by naddy@@, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.76 2008/11/28 21:33:26 jakemsr Exp $	*/
d1926 1
a1926 1
	if (codec->nsense_pins < AZ_MAX_SENSE_PINS &&
@


1.76
log
@check the jack detect override bit before creating jack sense mixer
items.  BIOSes can set the jack detect override bit to tell us that
the jack detection circuirty isn't actually attached.

should remove the _sense controls that never change.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.75 2008/11/27 23:30:58 jakemsr Exp $	*/
a1308 3
	/* set invalid values for azalia_codec_construct_format() to work */
	this->dacs.cur = -1;
	this->adcs.cur = -1;
d1345 48
a1392 18
	this->dacs.cur = newdac;
	group = &this->dacs.groups[this->dacs.cur];
	bits_rates = this->w[group->conv[0]].d.audio.bits_rates;
	nbits = 0;
	if (bits_rates & COP_PCM_B8)
		nbits++;
	if (bits_rates & COP_PCM_B16)
		nbits++;
	if (bits_rates & COP_PCM_B20)
		nbits++;
	if (bits_rates & COP_PCM_B24)
		nbits++;
	if (bits_rates & COP_PCM_B32)
		nbits++;
	if (nbits == 0) {
		printf("%s: invalid DAC PCM format: 0x%8.8x\n",
		    XNAME(this->az), bits_rates);
		return -1;
a1393 1
	variation = group->nconv * nbits;
d1395 2
a1396 17
	this->adcs.cur = newadc;
	group = &this->adcs.groups[this->adcs.cur];
	bits_rates = this->w[group->conv[0]].d.audio.bits_rates;
	nbits = 0;
	if (bits_rates & COP_PCM_B8)
		nbits++;
	if (bits_rates & COP_PCM_B16)
		nbits++;
	if (bits_rates & COP_PCM_B20)
		nbits++;
	if (bits_rates & COP_PCM_B24)
		nbits++;
	if (bits_rates & COP_PCM_B32)
		nbits++;
	if (nbits == 0) {
		printf("%s: invalid ADC PCM format: 0x%8.8x\n",
		    XNAME(this->az), bits_rates);
a1398 1
	variation += group->nconv * nbits;
d1412 12
a1423 8
	group = &this->dacs.groups[this->dacs.cur];
	for (c = 0; c < group->nconv; c++) {
		chan = 0;
		bits_rates = ~0;
		for (i = 0; i <= c; i++) {
			nid = group->conv[i];
			chan += WIDGET_CHANNELS(&this->w[nid]);
			bits_rates &= this->w[nid].d.audio.bits_rates;
a1424 1
		azalia_codec_add_bits(this, chan, bits_rates, AUMODE_PLAY);
d1428 12
a1439 8
	group = &this->adcs.groups[this->adcs.cur];
	for (c = 0; c < group->nconv; c++) {
		chan = 0;
		bits_rates = ~0;
		for (i = 0; i <= c; i++) {
			nid = group->conv[i];
			chan += WIDGET_CHANNELS(&this->w[nid]);
			bits_rates &= this->w[nid].d.audio.bits_rates;
a1440 1
		azalia_codec_add_bits(this, chan, bits_rates, AUMODE_RECORD);
d2331 6
d2610 7
d2621 2
a2622 2
	az = v;
	return azalia_stream_start(&az->pstream, start, end, blk, intr, arg, fmt);
d2633 1
a2633 1
	DPRINTFN(1, ("%s: this=%p start=%p end=%p blk=%d {enc=%u %uch %u/%ubit %uHz}\n",
d2635 8
a2642 1
	    param->precision, param->precision, param->sample_rate));
d2648 2
a2649 2
	az = v;
	return azalia_stream_start(&az->rstream, start, end, blk, intr, arg, fmt);
@


1.75
log
@
widget initialization cleanup:
* configure widgets all in one place
* add a flag on the widget_t to let us know if the widget is not
connected; shaves a lot of connection checking code
* be sure not to add power widgets as connectable sources/sinks
* configure unconnected pins as output pins.  should help some
MacBooks and be benign to other devices.

the last change has been tested by several as a separate diff.  no
real functional changes otherwise.

from Alexey Suslikov.  thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.74 2008/11/27 22:54:20 jakemsr Exp $	*/
d1913 10
a1922 3
		wcodec = &codec->az->codecs[codec->az->codecno];
		wcodec->sense_pins[codec->nsense_pins] = this->nid;
		wcodec->nsense_pins++;
@


1.74
log
@intrdoduce DPRINTFN macro so debug messages can be selectively enabled.
use it to quiet some debug messages by default, so people don't get
scared when testing completely unrelated changes when AZALIA_DEBUG
is defined.

print out ADC groupings when AZALIA_DEBUG is defined like we do for
DAC groupings.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.73 2008/11/19 03:44:14 jakemsr Exp $	*/
d1287 2
a1288 2
		if (err)
			return err;
d1635 2
a1636 1
		codec->comresp(codec, nid, CORB_SET_POWER_STATE, CORB_PS_D0, &result);
d1639 6
a1644 2
	if ((this->type == COP_AWTYPE_AUDIO_OUTPUT) ||
	    (this->type == COP_AWTYPE_AUDIO_INPUT))
d1646 2
a1647 1
	if (this->type == COP_AWTYPE_PIN_COMPLEX)
d1649 3
a1651 3
	if (this->type == COP_AWTYPE_VOLUME_KNOB) {
		err = codec->comresp(codec, this->nid,
		    CORB_GET_PARAMETER,
d1653 7
a1659 2
		if (!err)
			this->d.volume.cap = result;
a1661 1

d1821 6
d1847 47
a1893 11
	/* input pin */
	if ((this->d.pin.cap & COP_PINCAP_INPUT) &&
	    (this->d.pin.cap & COP_PINCAP_OUTPUT) == 0) {
		err = codec->comresp(codec, this->nid,
		    CORB_GET_PIN_WIDGET_CONTROL, 0, &result);
		if (err == 0) {
			result &= ~CORB_PWC_OUTPUT;
			result |= CORB_PWC_INPUT;
			codec->comresp(codec, this->nid,
			    CORB_SET_PIN_WIDGET_CONTROL, result, NULL);
		}
d1895 13
a1907 10
	/* output pin, or bidirectional pin */
	if (this->d.pin.cap & COP_PINCAP_OUTPUT) {
		err = codec->comresp(codec, this->nid,
		    CORB_GET_PIN_WIDGET_CONTROL, 0, &result);
		if (err == 0) {
			result &= ~CORB_PWC_INPUT;
			result |= CORB_PWC_OUTPUT;
			codec->comresp(codec, this->nid,
			    CORB_SET_PIN_WIDGET_CONTROL, result, NULL);
		}
@


1.73
log
@
the jack sense automatic muting code has many problems, including
being the cause of PR5982.  unfortunately, there's no easy and clean
solution to automatic muting.  we can't always rely on the codec
giving us the right information.  people have different preferences
as to what should be muted and what shouldn't.  etc, etc.

so instead, just make the sense state of jacks that support sensing
available through the mixer interface.  this allows for any possible
user configuration and supports all pins that have sense capabilities,
not just headpones.  codecs that use the generic mixer configuration
(which is the plan for all codecs) and have sensing capable pins will
now get a few more read-only mixer items, such as:

outputs.hp_sense=plugged
outputs.mic_sense=unplugged
outputs.line_sense=unplugged

hopefully what they mean is self-explanatory.

based on much discussion with ratchov@@ and Alexey Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.72 2008/11/14 21:58:11 jakemsr Exp $	*/
d110 8
d1300 7
d1534 1
a1534 1
	DPRINTF(("%s: fmt=0x%4.4x number=%d\n", __func__, fmt, number));
d1582 1
a1582 1
	DPRINTF(("%s: leave with %d\n", __func__, err));
d2169 1
a2169 1
	DPRINTF(("%s: flags=0x%x\n", __func__, flags));
d2182 1
a2182 1
	DPRINTF(("%s\n", __func__));
d2392 1
a2392 1
	DPRINTF(("%s: resultant block size = %d\n", __func__, blk));
d2401 1
a2401 1
	DPRINTF(("%s\n", __func__));
d2411 1
a2411 1
	DPRINTF(("%s\n", __func__));
d2542 1
a2542 1
	DPRINTF(("%s: this=%p start=%p end=%p blk=%d {enc=%u %uch %u/%ubit %uHz}\n",
@


1.72
log
@* readability improvement in azalia_codec_connect_stream
* DEBUG cleanup

from Alexey Suslikov, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.71 2008/11/05 04:08:24 brad Exp $	*/
a45 1
#include <sys/timeout.h>
a172 1
	struct timeout timeo;
a223 2
void	azalia_codec_jack_intr(void *);
void	azalia_codec_jack_handler(codec_t *);
a729 6
	/* Setup jack_intr if only there is no unsol_event handler. */
	if (az->codecs[az->codecno].unsol_event == NULL) {
		timeout_set(&az->timeo, azalia_codec_jack_intr, az);
		timeout_add_sec(&az->timeo, 2);
	}

a735 94
void
azalia_codec_jack_intr(void *addr)
{
	struct azalia_t *az = (struct azalia_t *)addr;
	int s;

	s = splaudio();
	azalia_codec_jack_handler(&az->codecs[az->codecno]);
	timeout_add_sec(&az->timeo, 2);
	splx(s);
}

void
azalia_codec_jack_handler(codec_t *this)
{
	int i, j, err, dev;
	uint32_t sense, ctl, val, dir;

	FOR_EACH_WIDGET(this, i) {
		const widget_t *w;

		dev = 0;
		w = &this->w[i];

		/* Find pin with conn=jack and presence capability. */
		if (w == NULL || w->type != COP_AWTYPE_PIN_COMPLEX ||
		    (CORB_CD_PORT(w->d.pin.config)) != CORB_CD_JACK ||
		    (!(w->d.pin.cap & COP_PINCAP_PRESENCE)))
			continue;

		/* Headphones. */
		if (w->d.pin.device == CORB_CD_HEADPHONE &&
		    (w->d.pin.cap & COP_PINCAP_HEADPHONE)) {
			dev = CORB_CD_SPEAKER;	/* (un)mute speakers */
			dir = CORB_PWC_OUTPUT;
		}

		if (!dev)
			continue;

		err = this->comresp(this, w->nid, CORB_GET_PIN_SENSE,
		    0, &sense);
		if (err)
			break;

		err = this->comresp(this, w->nid, CORB_GET_PIN_WIDGET_CONTROL,
		    0, &ctl);
		if (err)
			break;

		if (sense & CORB_PS_PRESENCE)
			val = ctl | dir;
		else
			val = ctl & ~dir;

		if (val != ctl) {
			ctl = val;
			err = this->comresp(this, w->nid,
			    CORB_SET_PIN_WIDGET_CONTROL, ctl, NULL);
			if (err)
				break;
		}

		FOR_EACH_WIDGET(this, j) {
			const widget_t *w;

			w = &this->w[j];

			/* Find suitable and connected pin for (un)mute. */
			if (w == NULL || w->type != COP_AWTYPE_PIN_COMPLEX ||
			    (CORB_CD_PORT(w->d.pin.config)) == CORB_CD_NONE ||
			    j == i || w->d.pin.device != dev)
				continue;

			err = this->comresp(this, w->nid,
			    CORB_GET_PIN_WIDGET_CONTROL, 0, &ctl);
			if (err)
				break;

			if (sense & CORB_PS_PRESENCE)
				val = ctl & ~dir;
			else
				val = ctl | dir;

			if (val != ctl) {
				ctl = val;
				err = this->comresp(this, w->nid,
				    CORB_SET_PIN_WIDGET_CONTROL, ctl, NULL);
				if (err)
					break;
			}
		}
	}
}
d1796 1
d1838 8
@


1.71
log
@Remove some PCI macros no longer being used.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.70 2008/11/05 03:20:34 jakemsr Exp $	*/
d239 3
a242 1
int	azalia_widget_init_pin(widget_t *, const codec_t *);
d244 1
a244 1
int	azalia_widget_init_connection(widget_t *, const codec_t *);
d1646 7
a1652 1
		err = this->comresp(this, nid, CORB_SET_CONVERTER_FORMAT, fmt, NULL);
a1654 3
		stream_chan = (number << 4) | startchan;
		if (startchan >= nchan)
			stream_chan = 0; /* stream#0 */
d1885 1
d1895 1
d1949 1
d1986 1
@


1.70
log
@remove unused macros, partly from Alexey Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.69 2008/11/04 20:55:43 jakemsr Exp $	*/
a352 6

#define PCI_ID_CODE0(v, p)	PCI_ID_CODE(PCI_VENDOR_##v, PCI_PRODUCT_##v##_##p)
#define PCIID_NVIDIA_MCP51	PCI_ID_CODE0(NVIDIA, MCP51_HDA)
#define PCIID_NVIDIA_MCP55	PCI_ID_CODE0(NVIDIA, MCP55_HDA)
#define PCIID_ALI_M5461		PCI_ID_CODE0(ALI, M5461)
#define PCIID_VIATECH_HDA	PCI_ID_CODE0(VIATECH, HDA)
@


1.69
log
@implement azalia_create_encodings, which scans through the supported
formats and creates an array of unique encodings.  use the array in
azalia_query_encoding.

in other words, no more duplicate encodings in `audioctl encodings`.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.68 2008/11/04 20:48:14 jakemsr Exp $	*/
a109 3
#define	AUFMT_INVALIDATE(fmt)	(fmt)->mode |= 0x80000000
#define	AUFMT_VALIDATE(fmt)	(fmt)->mode &= 0x7fffffff
#define	AUFMT_IS_VALID(fmt)	(((fmt)->mode & 0x80000000) == 0)
@


1.68
log
@
need to take mode into account when verifying/setting parameters
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.67 2008/11/01 07:21:48 jakemsr Exp $	*/
a60 3
#define	auconv_delete_encodings(x...)
#define	auconv_query_encoding(x...)	(EINVAL)
#define	auconv_create_encodings(x...)	(0)
d278 1
a278 2
int azalia_create_encodings(struct audio_format *, int,
    struct audio_encoding_set **);
d1420 1
d1425 7
a1431 3
	DPRINTF(("delete_encodings...\n"));
	auconv_delete_encodings(this->encodings);
	this->encodings = NULL;
d1523 1
a1523 2
	err = azalia_create_encodings(this->formats, this->nformats,
	    &this->encodings);
a2272 1
	int i, j;
d2276 7
a2282 28
	for (j = 0, i = 0; j < codec->nformats; j++) {
		if (codec->formats[j].validbits !=
		    codec->formats[j].precision)
			continue;
		if (i == enc->index) {
			enc->encoding = codec->formats[j].encoding;
			enc->precision = codec->formats[j].precision;
			enc->flags = 0;
			switch (enc->encoding) {
			case AUDIO_ENCODING_SLINEAR_LE:
				strlcpy(enc->name, enc->precision == 8 ?
				    AudioEslinear : AudioEslinear_le,
				    sizeof enc->name);
				break;
			case AUDIO_ENCODING_ULINEAR_LE:
				strlcpy(enc->name, enc->precision == 8 ?
				    AudioEulinear : AudioEulinear_le,
				    sizeof enc->name);
				break;
			default:
				strlcpy(enc->name, "unknown", sizeof enc->name);
				break;
			}
			return (0);
		}
		i++;
	}
	return (EINVAL);
d2729 1
a2729 2
azalia_create_encodings(struct audio_format *formats, int nformats,
    struct audio_encoding_set **encodings)
d2731 31
a2761 3
#if 0
	int i;
	u_int j;
d2763 22
a2784 8
	for (i = 0; i < nformats; i++) {
		printf("format(%d): encoding %u vbits %u prec %u chans %u cmask 0x%x\n",
		    i, formats[i].encoding, formats[i].validbits,
		    formats[i].precision, formats[i].channels,
		    formats[i].channel_mask);
		printf("format(%d) rates:", i);
		for (j = 0; j < formats[i].frequency_type; j++) {
			printf(" %u", formats[i].frequency[j]);
a2785 1
		printf("\n");
d2787 1
a2787 1
#endif
@


1.67
log
@
set the appropriate value (0, not emulated) in the flags field of
struct audio_encoding in azalia_query_encodings.  otherwise it
will be some random value.

makes AUDIO_GETENC and thus sio_getcap(3) much more useful here.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.66 2008/10/31 21:39:50 deraadt Exp $	*/
d284 1
a284 1
int	azalia_match_format(codec_t *, audio_params_t *);
d2319 1
a2319 1
azalia_match_format(codec_t *codec, audio_params_t *par)
d2324 2
d2355 1
a2355 1
	i = azalia_match_format(codec, par);
d2359 1
a2359 1
		i = azalia_match_format(codec, par);
d2375 1
a2375 1
		i = azalia_match_format(codec, par);
d2380 1
a2380 1
		i = azalia_match_format(codec, par);
d2396 1
a2396 1
		i = azalia_match_format(codec, par);
d2403 1
a2403 1
		i = azalia_match_format(codec, par);
@


1.66
log
@clean up error messages as suggested by jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.65 2008/10/31 06:52:15 jakemsr Exp $	*/
d2284 1
@


1.65
log
@
Handle "jack sense" hp/speaker switching by polling for an interrupt
instead of using unsolicited events.

Already supported codecs with custom unsolicited event handlers
are not affected, yet.

from Alexey Suslikov, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.64 2008/10/31 06:44:20 jakemsr Exp $	*/
d724 1
a724 1
	printf("%s: codec[s]: ", XNAME(az));
d1458 2
a1459 2
		printf("%s: %s/%d invalid PCM format: 0x%8.8x\n",
		    XNAME(this->az), __FILE__, __LINE__, bits_rates);
d1479 2
a1480 2
		printf("%s: %s/%d invalid PCM format: 0x%8.8x\n",
		    XNAME(this->az), __FILE__, __LINE__, bits_rates);
@


1.64
log
@
Support for converter groups where members support non-identical sample
sizes and rates.

from NetBSD via brad@@

Also,

* use a single variable to hold the number of format variations (from NetBSD)
* initialize a variable (f->frequency_type) before use (from NetBSD)
* fix a typo

from Alexey Suslikov, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.63 2008/10/31 06:40:12 jakemsr Exp $	*/
d46 1
d180 1
d232 2
d744 7
d755 95
@


1.63
log
@some leftover bits from r1.32 that should have been removed in
r1.51

pointed out by Alexey Suslikov, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.62 2008/10/25 22:30:43 jakemsr Exp $	*/
d1333 1
a1333 1
	int pvariation, rvariation;
d1356 1
a1356 1
	pvariation = group->nconv * nbits;
d1377 1
a1377 1
	rvariation = group->nconv * nbits;
d1382 2
a1383 2
	this->formats = malloc(sizeof(struct audio_format) *
	    (pvariation + rvariation), M_DEVBUF, M_NOWAIT | M_ZERO);
a1391 3
	nid = group->conv[0];
	chan = 0;
	bits_rates = this->w[nid].d.audio.bits_rates;
d1393 7
a1399 2
		for (chan = 0, i = 0; i <= c; i++)
			chan += WIDGET_CHANNELS(&this->w[group->conv[c]]);
a1404 3
	nid = group->conv[0];
	chan = 0;
	bits_rates = this->w[nid].d.audio.bits_rates;
d1406 7
a1412 2
		for (chan = 0, i = 0; i <= c; i++)
			chan += WIDGET_CHANNELS(&this->w[group->conv[c]]);
d1472 1
d1751 1
a1751 1
				    * This must not occuur usually... */
@


1.62
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.61 2008/10/23 02:06:53 jakemsr Exp $	*/
a1378 9
	if (bits_rates & COP_PCM_R441)
		this->rate = 44100;
	else if (bits_rates & COP_PCM_R480)
		this->rate = 48000;
	else {
		printf("%s: %s/%d invalid PCM format: 0x%8.8x\n",
		    XNAME(this->az), __FILE__, __LINE__, bits_rates);
		return -1;
	}
@


1.61
log
@Sve power.  Power down codec if it has no audio function groups.

from Alexey Suslikov, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.60 2008/10/16 19:16:58 jakemsr Exp $	*/
d280 4
d2216 19
a2234 2
azalia_set_params(void *v, int smode, int umode, audio_params_t *p,
    audio_params_t *r)
d2236 2
a2237 4
	azalia_t *az;
	codec_t *codec;
	void (*pswcode)(void *, u_char *, int) = NULL;
	void (*rswcode)(void *, u_char *, int) = NULL;
d2239 10
d2250 12
a2261 11
	az = v;
	codec = &az->codecs[az->codecno];
	if (smode & AUMODE_RECORD && r != NULL) {
		for (i = 0; i < codec->nformats; i++) {
			if (r->encoding != codec->formats[i].encoding)
				continue;
			if (r->precision != codec->formats[i].precision)
				continue;
			if (r->channels != codec->formats[i].channels)
				continue;
			break;
d2263 10
d2274 9
a2282 12
		if (i == codec->nformats && r->channels == 1) {
			r->factor = 2;
			rswcode = linear16_decimator;
			for (i = 0; i < codec->nformats; i++) {
				if (r->encoding != codec->formats[i].encoding)
					continue;
				if (r->precision != codec->formats[i].precision)
					continue;
				if (codec->formats[i].channels != 2)
					continue;
				break;
			}
d2284 15
a2298 1

d2300 4
a2303 3
			DPRINTF(("%s: can't find record format %u/%u/%u\n",
			    __func__, r->encoding, r->precision, r->channels));
			return (EINVAL);
d2305 15
d2321 1
a2321 1
			if (r->sample_rate != codec->formats[i].frequency[j])
d2326 3
a2328 3
			DPRINTF(("%s: can't find record rate %u\n",
			    __func__, r->sample_rate));
			return (EINVAL);
a2329 1
		r->sw_code = rswcode;
d2331 26
d2358 3
a2360 39
		for (i = 0; i < codec->nformats; i++) {
			if (p->encoding != codec->formats[i].encoding)
				continue;
			if (p->precision != codec->formats[i].precision)
				continue;
			if (p->channels != codec->formats[i].channels)
				continue;
			break;
		}
		/* find a 2 channel format and emulate mono */
		if (i == codec->nformats && p->channels == 1) {
			p->factor = 2;
			pswcode = noswap_bytes_mts;
			for (i = 0; i < codec->nformats; i++) {
				if (p->encoding != codec->formats[i].encoding)
					continue;
				if (p->precision != codec->formats[i].precision)
					continue;
				if (codec->formats[i].channels != 2)
					continue;
				break;
			}
		}
		if (i == codec->nformats) {
			DPRINTF(("%s: can't find playback format %u/%u/%u\n",
			    __func__, p->encoding, p->precision, p->channels));
			return (EINVAL);
		}
		for (j = 0; j < codec->formats[i].frequency_type; j++) {
			if (p->sample_rate != codec->formats[i].frequency[j])
				continue;
			break;
		}
		if (j == codec->formats[i].frequency_type) {
			DPRINTF(("%s: can't find playback rate %u\n",
			    __func__, p->sample_rate));
			return (EINVAL);
		}
		p->sw_code = pswcode;
@


1.60
log
@
Add S/PDIF support. From NetBSD.

Clean up a little while here.

from Alexey Suslikov, thanks

tested by several as part of a larger diff, thanks also
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.59 2008/10/12 10:42:38 jakemsr Exp $	*/
d1213 3
d1220 2
a1221 1
	this->comresp(this, this->audiofunc, CORB_SET_POWER_STATE, CORB_PS_D0, &result);
@


1.59
log
@if converters in a group are not needed to satisfy the requirements
of a stream, direct the unneeded converters use HDA link stream #0

from NetBSD via Alexey Suslikov, thanks

tested by several, thanks also
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.58 2008/10/12 10:34:18 jakemsr Exp $	*/
a38 1
 *  - S/PDIF
d1515 1
d1553 8
d1573 1
d1585 6
@


1.58
log
@
add azalia_codec_disconnect_stream(), a function to direct all
converters in a group to use HDA link stream #0.  use it when
halting playback/recording.

from NetBSD via Alexey Suslikov, thanks

tested by several, thanks also
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.57 2008/10/10 22:40:22 brad Exp $	*/
d1533 1
d1546 3
d1550 1
a1550 1
				    (number << 4) | startchan, NULL);
d1553 1
a1553 2
		if (nchan > 2)
			startchan += WIDGET_CHANNELS(&this->w[nid]);
@


1.57
log
@Enable PCIe snooping on the remaining ATI/NVIDIA chipsets.
Fixes clicking and other noise related issues.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.56 2008/10/10 14:00:46 jakemsr Exp $	*/
d237 1
d729 1
d1558 19
d2084 2
@


1.56
log
@
missing spl() for codec command setting/retrieval

from NetBSD via Alexey Suslikov, thanks

"looks good" ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.55 2008/09/24 19:09:05 chl Exp $	*/
d429 1
d437 21
@


1.55
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.54 2008/09/22 19:42:07 miod Exp $	*/
d1476 1
a1476 1
	int err;
d1478 1
d1481 5
a1485 2
		return err;
	return azalia_get_response(codec->az, result);
@


1.54
log
@Do not use an uninitialized local for comparison in azalia_rirb_intr().
While there, fix a bounds checking error in azalia_[gs]et_port().

ok deanna@@ ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.53 2008/09/17 06:14:09 brad Exp $	*/
a1301 1
	int prev_dac, prev_adc;
a1305 1
	prev_dac = this->dacs.cur;
a1326 1
	prev_adc = this->adcs.cur;
@


1.53
log
@Update for renamed ATI PCI ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.52 2008/06/26 05:42:17 ray Exp $	*/
d559 1
a559 1
	if (intsts & HDA_INTCTL_CIE) {
d1050 1
a1050 1
	uint16_t wp, rp;
a1055 2
	if (rp == wp)
		return;		/* interrupted but no data in RIRB */
d2310 1
a2310 1
	if (mc->dev < 0 || mc->dev > co->nmixers)
d2323 1
a2323 1
	if (mc->dev < 0 || mc->dev > co->nmixers)
@


1.52
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.51 2008/05/29 07:20:15 jakemsr Exp $	*/
d429 1
a429 1
	case PCI_PRODUCT_ATI_IXP_HDA_X00:
@


1.51
log
@
specify alternate default audio parameters to make the default expansion
factor 1

also obsoletes a XXX workaround in azalia

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.50 2008/05/13 02:24:08 brad Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.50
log
@Remove commented out NetBSD __KERNEL_RCSID macro usage.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.49 2008/04/28 08:57:08 brad Exp $	*/
d266 1
d324 1
a324 1
	NULL
d2141 11
a2164 5
		if (r->encoding == AUDIO_ENCODING_ULAW) {	 /*XXX*/
			r->encoding = AUDIO_ENCODING_SLINEAR_LE;
			r->precision = 16;
			r->sample_rate = codec->rate;
		}
a2206 5
		if (p->encoding == AUDIO_ENCODING_ULAW) {	 /*XXX*/
			p->encoding = AUDIO_ENCODING_SLINEAR_LE;
			p->precision = 16;
			p->sample_rate = codec->rate;
		}
@


1.49
log
@Sync PCI ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.48 2008/04/21 00:32:42 jakemsr Exp $	*/
a50 5

#include <sys/cdefs.h>
#ifdef NETBSD_GOOP
__KERNEL_RCSID(0, "$NetBSD: azalia.c,v 1.15 2005/09/29 04:14:03 kent Exp $");
#endif
@


1.48
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.47 2008/03/02 17:24:12 deanna Exp $	*/
d440 1
a440 1
	case PCI_PRODUCT_ATI_IXP_HDA_600:
@


1.47
log
@Clear interrupts on detach.  Fixes interrupt storm on digital-only
controllers, like the HDMI found on Radeon cards.

Tested by claudio@@ and kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.46 2007/12/16 18:46:43 deanna Exp $	*/
d328 1
@


1.46
log
@Count line-in as line-out, and label both as AudioNline.  This is what
the mixer expects.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.45 2007/11/25 18:13:40 martynas Exp $	*/
d529 8
d1922 5
@


1.45
log
@typo;  ok jmc@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.44 2007/11/23 18:34:00 deanna Exp $	*/
d1612 18
a1629 7
			if (pins[w->d.pin.device] > 1)
				snprintf(w->name, sizeof(w->name), "%s%d",
				    pin_devices[w->d.pin.device],
				    pins[w->d.pin.device]);
			else
				snprintf(w->name, sizeof(w->name), "%s",
				    pin_devices[w->d.pin.device]);
@


1.44
log
@Check for invalid dev indices, which could get here through ioctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.43 2007/11/16 20:36:25 deanna Exp $	*/
d413 1
a413 1
	const char *intrrupt_str;
d459 1
a459 1
	intrrupt_str = pci_intr_string(pa->pa_pc, ih);
d464 2
a465 2
		if (intrrupt_str != NULL)
			printf(" at %s", intrrupt_str);
d469 1
a469 1
	printf(": %s\n", intrrupt_str);
@


1.43
log
@No need to mention which codec is being used if there's only one.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.42 2007/11/14 22:51:37 deanna Exp $	*/
d2297 2
d2310 2
d2323 1
a2323 1
	if (mdev->index >= co->nmixers)
@


1.42
log
@Unknown codecs don't have a name field, so print what we read from
pci_findvendor() or the vendor id instead.

From ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.41 2007/11/14 05:39:41 deanna Exp $	*/
d696 1
a696 1
	printf("%s: ", XNAME(az));
d702 4
a705 2
	printf(" codecs; using ");
	azalia_print_codec(&az->codecs[az->codecno]);
@


1.41
log
@less obnoxious dmesg

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.40 2007/11/03 19:52:56 deanna Exp $	*/
d226 1
d575 16
a663 1
	const char *vendor;
d696 1
a696 1
	printf("%s:", XNAME(az));
d698 1
a698 11
		if (az->codecs[i].name == NULL) {
			vendor = pci_findvendor(az->codecs[i].vid >> 16);
			if (vendor == NULL)
				printf(" 0x%04x/0x%04x",
				    az->codecs[i].vid >> 16,
				    az->codecs[i].vid & 0xffff);
			else
				printf(" %s/0x%04x", vendor,
				    az->codecs[i].vid & 0xffff);
		} else
			printf(" %s", az->codecs[i].name);
d700 1
a700 1
			printf(",");
d702 3
a704 1
	printf(" codecs; using %s\n", az->codecs[az->codecno].name);
@


1.40
log
@quiet a noisy printf, requested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.39 2007/11/02 19:01:26 deanna Exp $	*/
d582 2
a583 2
	printf("%s: host: High Definition Audio rev. %d.%d\n",
	    XNAME(az), AZ_READ_1(az, VMAJ), AZ_READ_1(az, VMIN));
d647 1
d673 2
a674 1
	if (c < 0)
d676 1
d679 18
a696 1
	DPRINTF(("%s: using the #%d codec\n", XNAME(az), az->codecno));
a1132 1
	const char *vendor;
a1135 2
	DPRINTF(("%s: information of codec[%d] follows:\n",
	    XNAME(this->az), addr));
d1148 5
a1152 13

	printf("%s: codec:", XNAME(this->az));
	if (this->name == NULL) {
		vendor = pci_findvendor(id >> 16);
		if (vendor == NULL)
			printf(" 0x%04x/0x%04x", id >> 16, id & 0xffff);
		else
			printf(" %s/0x%04x", vendor, id & 0xffff);
	} else
		printf(" %s", this->name);
	printf(" (rev. %u.%u), HDA version %u.%u\n",
	    COP_RID_REVISION(rev), COP_RID_STEPPING(rev),
	    COP_RID_MAJ(rev), COP_RID_MIN(rev));
d1161 2
a1162 1
		printf("%s: No function groups\n", XNAME(this->az));
a1178 3
		} else if (COP_FTYPE(result) == COP_FTYPE_MODEM) {
			printf("%s: codec[%d]: No support for modem function groups\n",
			    XNAME(this->az), addr);
d1182 2
a1183 2
		printf("%s: codec[%d]: No audio function groups\n",
		    XNAME(this->az), addr);
@


1.39
log
@Label widgets based on default device or type rather than color+node
id.  This lets the generic mixer init create more readable items.  You
may need to update your mixerctl.conf.

Tested jmc@@, ok ratchov@@, jakemsr@@ jdixon@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.38 2007/10/28 21:32:51 deanna Exp $	*/
d1278 1
a1278 1
	printf("delete_encodings...\n");
@


1.38
log
@Enable pcie snoop for SB600 and MCP51.  Fixes a variety of noise,
looping and distortion problems.  This is a temporary solution until
we get something like the BUS_DMA_NOCACHE flag to bus_dmamem_map(9),
which came with the driver when ported from NetBSD but means nothing
here.  It's likely that other NVIDIA and ATI chipsets will need this,
but I'd rather have some testers before adding them in.

From ariff@@freebsd, ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.37 2007/10/26 02:17:23 deanna Exp $	*/
d250 1
d329 10
a343 6
#ifdef AZALIA_DEBUG
static const char *pin_devices[16] = {
	"line-out", AudioNspeaker, AudioNheadphone, AudioNcd,
	"SPDIF-out", "digital-out", "modem-line", "modem-handset",
	"line-in", AudioNaux, AudioNmicrophone, "telephony",
	"SPDIF-in", "digital-in", "dev0e", "other"};
d1243 3
a1245 1

a1541 1
	DPRINTF(("%s: ", XNAME(codec->az)));
d1546 2
a1547 5
	switch (this->type) {
	case COP_AWTYPE_AUDIO_OUTPUT:
		snprintf(this->name, sizeof(this->name), "dac%2.2x", nid);
		DPRINTF(("%s wcap=%b\n", this->name,
		    this->widgetcap, WIDGETCAP_BITS));
d1549 1
a1549 18
		break;
	case COP_AWTYPE_AUDIO_INPUT:
		snprintf(this->name, sizeof(this->name), "adc%2.2x", nid);
		DPRINTF(("%s wcap=%b\n", this->name,
		    this->widgetcap, WIDGETCAP_BITS));
		azalia_widget_init_audio(this, codec);
		break;
	case COP_AWTYPE_AUDIO_MIXER:
		snprintf(this->name, sizeof(this->name), "mix%2.2x", nid);
		DPRINTF(("%s wcap=%b\n", this->name,
		    this->widgetcap, WIDGETCAP_BITS));
		break;
	case COP_AWTYPE_AUDIO_SELECTOR:
		snprintf(this->name, sizeof(this->name), "sel%2.2x", nid);
		DPRINTF(("%s wcap=%b\n", this->name,
		    this->widgetcap, WIDGETCAP_BITS));
		break;
	case COP_AWTYPE_PIN_COMPLEX:
d1551 3
a1553 16
		snprintf(this->name, sizeof(this->name), "%s%2.2x",
		    pin_colors[this->d.pin.color], nid);
		DPRINTF(("%s wcap=%b\n", this->name,
		    this->widgetcap, WIDGETCAP_BITS));
		azalia_widget_print_pin(this);
		break;
	case COP_AWTYPE_POWER:
		snprintf(this->name, sizeof(this->name), "pow%2.2x", nid);
		DPRINTF(("%s wcap=%b\n", this->name,
		    this->widgetcap, WIDGETCAP_BITS));
		break;
	case COP_AWTYPE_VOLUME_KNOB:
		snprintf(this->name, sizeof(this->name), "volume%2.2x", nid);
		DPRINTF(("%s wcap=%b\n", this->name,
		    this->widgetcap, WIDGETCAP_BITS));
		err = codec->comresp(codec, nid, CORB_GET_PARAMETER,
d1555 1
a1555 1
		if (!err) {
a1556 15
			DPRINTF(("\tdelta=%d steps=%d\n",
			    !!(result & COP_VKCAP_DELTA),
			    COP_VKCAP_NUMSTEPS(result)));
		}
		break;
	case COP_AWTYPE_BEEP_GENERATOR:
		snprintf(this->name, sizeof(this->name), "beep%2.2x", nid);
		DPRINTF(("%s wcap=%b\n", this->name,
		    this->widgetcap, WIDGETCAP_BITS));
		break;
	default:
		snprintf(this->name, sizeof(this->name), "widget%2.2x", nid);
		DPRINTF(("%s wcap=%b\n", this->name,
		    this->widgetcap, WIDGETCAP_BITS));
		break;
d1558 1
a1558 1
	azalia_widget_init_connection(this, codec);
a1566 7
		if ((this->widgetcap & COP_AWCAP_AMPOV) ||
		    (this->nid == codec->audiofunc))
			DPRINTF(("\tinamp: mute=%u size=%u steps=%u offset=%u\n",
			    (this->inamp_cap & COP_AMPCAP_MUTE) != 0,
			    COP_AMPCAP_STEPSIZE(this->inamp_cap),
			    COP_AMPCAP_NUMSTEPS(this->inamp_cap),
			    COP_AMPCAP_OFFSET(this->inamp_cap)));
d1574 62
a1635 2
		if ((this->widgetcap & COP_AWCAP_AMPOV) ||
		    (this->nid == codec->audiofunc))
d1637 6
a1642 4
			    (this->outamp_cap & COP_AMPCAP_MUTE) != 0,
			    COP_AMPCAP_STEPSIZE(this->outamp_cap),
			    COP_AMPCAP_NUMSTEPS(this->outamp_cap),
			    COP_AMPCAP_OFFSET(this->outamp_cap)));
a1643 2
	if (codec->init_widget != NULL)
		codec->init_widget(codec, this, nid);
a1683 4
#ifdef AZALIA_DEBUG
	if (this->widgetcap & COP_AWCAP_FORMATOV)
		azalia_widget_print_audio(this, "\t");
#endif
@


1.37
log
@Add emulated mono support.

Tested ajacoutot, ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.36 2007/10/14 18:21:54 deanna Exp $	*/
d219 2
d363 25
d408 1
d430 16
@


1.36
log
@The spec says to wait 40 microseconds for the run bit to clear before
performing a stream reset.  Fixes stream reset errors on ALC883,
reported by jmc.

Tested jmc, jakemsr, ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.35 2007/10/10 03:39:21 deanna Exp $	*/
a2067 1
			r->channels = 2;
d2079 15
a2114 1
			p->channels = 2;
d2126 14
d2358 7
a2364 1
	ret |= param->channels - 1;
@


1.35
log
@Rework the debug dmesg to perform a more complete codec dump.

Tested by jmc, ckuethe, kettenis and jakemsr.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.34 2007/09/10 22:37:08 deanna Exp $	*/
d1850 1
@


1.34
log
@Use M_ZERO.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.33 2007/09/10 22:11:17 deanna Exp $	*/
d337 12
d1177 6
d1565 7
a1571 5
		DPRINTF(("\tinamp: mute=%u size=%u steps=%u offset=%u\n",
		    (this->inamp_cap & COP_AMPCAP_MUTE) != 0,
		    COP_AMPCAP_STEPSIZE(this->inamp_cap),
		    COP_AMPCAP_NUMSTEPS(this->inamp_cap),
		    COP_AMPCAP_OFFSET(this->inamp_cap)));
d1579 7
a1585 5
		DPRINTF(("\toutamp: mute=%u size=%u steps=%u offset=%u\n",
		    (this->outamp_cap & COP_AMPCAP_MUTE) != 0,
		    COP_AMPCAP_STEPSIZE(this->outamp_cap),
		    COP_AMPCAP_NUMSTEPS(this->outamp_cap),
		    COP_AMPCAP_OFFSET(this->outamp_cap)));
d1630 2
a1631 1
	azalia_widget_print_audio(this, "\t");
d1700 2
a1701 1
#define	PINCAP_BITS	"\20\021EAPD\07BALANCE\06INPUT" \
d1707 31
a1737 4
	DPRINTF(("\tpin config; device=%s color=%s assoc=%d seq=%d",
	    pin_devices[this->d.pin.device], pin_colors[this->d.pin.color],
	    this->d.pin.association, this->d.pin.sequence));
	DPRINTF((" cap=%b\n", this->d.pin.cap, PINCAP_BITS));
@


1.33
log
@Fix a copy/pasto from last year.  CMI9880 should work now.

ok brad (copy/pasto-er)
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.32 2007/09/10 05:39:07 deanna Exp $	*/
d791 1
a791 1
	    M_DEVBUF, M_NOWAIT);
a797 1
	bzero(az->unsolq, sizeof(rirb_entry_t) * UNSOLQ_SIZE);
d1136 1
a1136 1
	this->w = malloc(sizeof(widget_t) * this->wend, M_DEVBUF, M_NOWAIT);
a1140 1
	bzero(this->w, sizeof(widget_t) * this->wend);
d1282 1
a1282 1
	    (pvariation + rvariation), M_DEVBUF, M_NOWAIT);
a1287 2
	bzero(this->formats, sizeof(struct audio_format) *
	    (pvariation + rvariation));
@


1.32
log
@If 44.1kHz sample rate isn't supported, use 48kHz instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.31 2007/09/10 05:30:14 deanna Exp $	*/
a1604 1
		this->d.audio.bits_rates = result;
@


1.31
log
@Some pin widgets default to off, so make sure they're all enabled, not
just the bidirectional ones.

This could fix some no-sound problems on codecs using the generic
functions.

Code from kent@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.30 2007/09/06 22:47:46 deanna Exp $	*/
d1271 9
d2022 1
a2022 1
			r->sample_rate = 44100;
d2055 1
a2055 1
			p->sample_rate = 44100;
@


1.30
log
@Clean up some debug messages and wrap them in DPRINTF.  From Alexey
Suslikov.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.29 2007/08/02 17:13:31 reyk Exp $	*/
d1646 24
@


1.29
log
@print the vendor id string for unknown azalia codecs if we find it in
the pcidevs database.

ok deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.28 2007/06/19 00:06:51 deanna Exp $	*/
d2001 2
a2002 2
			printf("didn't find Record format %u/%u/%u\n",
			    r->encoding, r->precision, r->channels);
d2011 2
a2012 2
			printf("didn't find Record rate %u\n",
			    r->sample_rate);
d2034 2
a2035 2
			printf("can't find playback format %u/%u/%u\n",
			    r->encoding, r->precision, r->channels);
d2044 2
a2045 2
			printf("can't find playback rate %u\n",
			    p->sample_rate);
@


1.28
log
@Handle interrupts for the record stream as well.  Recording now works.
Tested by ajacoutot@@, steven@@ and Will Backman.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.27 2007/06/13 02:29:10 deanna Exp $	*/
d1053 1
d1073 7
a1079 3
	if (this->name == NULL)
		printf(" 0x%04x/0x%04x", id >> 16, id & 0xffff);
	else
@


1.27
log
@Don't attempt multichannel playback.  This workaround allows a stream
to connect to multiple outputs, which is needed for some codecs like
the Sigmatel ones found in Macs and on my VAIO.  There is a bigger
problem with how DACs are grouped that should be solved when we get
around to supporting multichannel formats.

Tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.26 2007/05/03 14:49:31 deanna Exp $	*/
a493 1
#if 0
a494 1
#endif
@


1.26
log
@Fix a typo that was preventing the full device name from being printed.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.25 2007/05/02 17:01:22 deanna Exp $	*/
d1434 2
a1435 1
		startchan += WIDGET_CHANNELS(&this->w[nid]);
@


1.25
log
@- Add support for handling unsolicited events (based on NetBSD).

- The STAC9200 codec was mistakenly referred to as STAC9220.  Change
this to STAC9200 and add a link to the datasheet.

- Add a new target, MI_TARGET_PINCTRL, to azalia_generic_mixer_set()
that allows us to turn pins on and off.

- Add an unsolicited event handler for STAC9200 that will toggle the
headphone and speaker pins.  This means the speaker will now mute and
unmute based on headphone presence.

- Spelling: PRESENSE -> PRESENCE

Tested by ajacoutot@@, tedu@@ and krw@@, ok krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.24 2006/09/21 09:52:45 fgsch Exp $	*/
d1075 1
a1075 1
		printf(" 0x04x/0x%04x", id >> 16, id & 0xffff);
@


1.24
log
@missing args for printf; some from Aurelien <aurelien26 at free dot fr>.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.23 2006/07/21 20:41:51 brad Exp $	*/
d198 5
d230 1
a230 1
int	azalia_set_command(const azalia_t *, nid_t, int, uint32_t,
d233 2
d485 1
a485 1
	uint8_t rirbsts;
d498 3
d502 4
a505 3
		rirbsts = AZ_READ_1(az, RIRBSTS);
		AZ_WRITE_1(az, RIRBSTS, rirbsts |
		    HDA_RIRBSTS_RIRBOIS | HDA_RIRBSTS_RINTFL);
d561 4
d788 14
d826 4
d846 1
a846 1
azalia_set_command(const azalia_t *az, int caddr, nid_t nid, uint32_t control,
d853 1
d868 8
d890 1
d912 4
a915 2
		if (rirb[az->rirb_rp].resp_ex & RIRB_UNSOLICITED_RESPONSE) {
			DPRINTF(("%s: unsolicited response\n", __func__));
d922 1
d930 5
d936 53
@


1.23
log
@Do not check if CORBRPST is set for any chipsets.

From kent@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.22 2006/07/20 02:06:17 brad Exp $	*/
d1903 1
a1903 1
			printf("didn't find Record rate\n",
d1926 1
a1926 1
			printf("can't find playback format\n",
@


1.22
log
@Don't check the CORBRPRST flag for the NVidia MCP51/55 and ALI M5461.

Based on a diff from kent@@NetBSD though modified to also cover
the MCP51 and M5461.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.21 2006/06/30 17:15:04 deraadt Exp $	*/
d337 4
a340 3
#define PCIID_MCP51		PCI_ID_CODE0(NVIDIA, MCP51_HDA)
#define PCIID_MCP55		PCI_ID_CODE0(NVIDIA, MCP55_HDA)
#define PCIID_M5461		PCI_ID_CODE0(ALI, M5461)
a673 13
	for (i = 5000; i >= 0; i--) {
		DELAY(10);
		corbrp = AZ_READ_2(az, CORBRP);
		if (corbrp & HDA_CORBRP_CORBRPRST)
			break;
	}
	if (i <= 0 &&
	    az->pciid != PCIID_MCP51 &&
	    az->pciid != PCIID_MCP55 &&
	    az->pciid != PCIID_M5461) {
		printf("%s: CORBRP reset failure\n", XNAME(az));
		return -1;
	}
d682 1
a682 1
		printf("%s: CORBRP reset failure 2\n", XNAME(az));
@


1.21
log
@fix comment, pointed out by kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.20 2006/06/30 16:51:50 deraadt Exp $	*/
d186 1
d336 5
d401 2
d679 4
a682 1
	if (i <= 0) {
@


1.20
log
@do not master enable, already done elsewhere
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.19 2006/06/28 08:23:06 brad Exp $	*/
d369 1
a369 1
	/* enable bus mastering */
@


1.19
log
@* azalia_pci_detach()
 add some debug messages
* azalia_codec_delete()
 fix a possible NULL dereference

From kent NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.18 2006/06/25 00:45:00 brad Exp $	*/
d372 1
a372 1
	    v | PCI_COMMAND_MASTER_ENABLE | PCI_COMMAND_BACKTOBACK_ENABLE);
@


1.18
log
@If the encoding of an audio converter is 0, refer to
the audio function node.  CMI9880 0.2 has such ADCs.

From kent NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.17 2006/06/23 06:27:11 miod Exp $	*/
d430 1
d436 2
d440 2
d446 2
d450 2
d1099 2
a1100 1
	this->mixer_delete(this);
@


1.17
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.16 2006/06/21 05:17:48 brad Exp $	*/
d1461 17
a1477 4
		if ((result & COP_STREAM_FORMAT_PCM) == 0) {
			printf("%s: %s: No PCM support: %x\n",
			    XNAME(codec->az), this->name, result);
			return -1;
a1478 4
		err = codec->comresp(codec, this->nid, CORB_GET_PARAMETER,
		    COP_PCM, &result);
		if (err)
			return err;
@


1.16
log
@make sure to return and indicate an error when an invalid PCM format
is found.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.15 2006/06/17 18:33:27 brad Exp $	*/
d415 1
a415 1
		return EOPNOTSUPP;
@


1.15
log
@check return values of azalia_init_corb() and azalia_init_rirb().

From kent NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.14 2006/06/16 08:03:42 brad Exp $	*/
a1150 1
#if 0
a1151 1
#endif
@


1.14
log
@- generic_mixer_default()
 set the default pin direction depending on the pin's device, not color
- ALC882:
  - add usingdac and usingadc
  - remove alc882_init_widget() because it has no effect any more
- codec-specific mixer initialization for Realtek ALC882
- fix audio_format allocation for recording

From kent NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.13 2006/06/16 06:00:46 brad Exp $	*/
d565 2
a566 1
	azalia_init_corb(az);
d568 2
a569 1
	azalia_init_rirb(az);
@


1.13
log
@* support for multi-channel (>=3) recording with ALC880, ALC882, or STAC9221
* azalia_codec_init_vtbl()
  recognize the name of AD1983
* azalia_generic_codec_find_dac()
  check validity of a node in a connection list
* introduce MIXER_DELTA, and simplify the code with it
* codec-specific mixer initialization for STAC9220

From kent NetBSD

Tested by a few end-users.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.12 2006/06/14 20:24:12 brad Exp $	*/
d1106 1
a1106 1
	int nbits, dac, chan, i, err;
d1153 1
a1153 1
	rvariation = nbits;
d1173 3
a1175 3
	for (dac = 0; dac < group->nconv; dac++) {
		for (chan = 0, i = 0; i <= dac; i++)
			chan += WIDGET_CHANNELS(&this->w[group->conv[dac]]);
d1182 1
a1182 1
	chan = WIDGET_CHANNELS(&this->w[nid]);
d1184 5
a1188 1
	azalia_codec_add_bits(this, chan, bits_rates, AUMODE_RECORD);
@


1.12
log
@- If the codec has support for a modem then print that there is no
modem support.
- Print the name of the STAC9220 codec.

From kent NetBSD

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.11 2006/06/14 19:34:52 brad Exp $	*/
d1066 1
a1066 1
	for (i = 0; i < this->ndacgroups; i++) {
d1068 2
a1069 2
		for (n = 0; n < this->dacgroups[i].nconv; n++) {
			DPRINTF((" %2.2x", this->dacgroups[i].conv[n]));
a1073 2
	this->cur_dac = 0;
	this->cur_adc = 0;
d1075 4
a1078 1
	err = azalia_codec_construct_format(this);
d1100 1
a1100 1
azalia_codec_construct_format(codec_t *this)
d1104 1
d1109 3
a1111 1
	group = &this->dacgroups[this->cur_dac];
d1131 4
a1134 1
	bits_rates = this->w[this->adcs[this->cur_adc]].d.audio.bits_rates;
d1169 1
d1180 2
a1181 1
	nid = this->adcs[this->cur_adc];
d1290 4
a1293 11
	if (dir == AUMODE_RECORD) {
		nid = this->adcs[this->cur_adc];
		DPRINTF(("%s: record: nid=0x%.2x\n", __func__, nid));
		err = this->comresp(this, nid, CORB_SET_CONVERTER_FORMAT, fmt, NULL);
		if (err)
			goto exit;
		err = this->comresp(this, nid, CORB_SET_CONVERTER_STREAM_CHANNEL,
				    (number << 4) | 0, NULL);
		goto exit;
	}
	group = &this->dacgroups[this->cur_dac];
@


1.11
log
@* move mixer functions from azalia.c to azalia_codec.c, and
rename them like azalia_mixer_foo() to azalia_generic_mixer_foo()

* enable codec-specific code to hook any mixer operations such
as creating mixer items, or special handling for a specific
item.

* provide a custom mixer table specific to ALC260
* provide a custom mixer table specific to Fujitsu LOOX

From kent NetBSD

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.10 2006/06/07 18:19:20 jason Exp $	*/
d992 3
d998 1
a998 1
		printf("%s: codec[%d]: No audio functions\n",
@


1.10
log
@shut up and play the music.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.9 2006/06/06 22:15:53 jason Exp $	*/
d186 1
a201 2

	int running;
a231 1
int	azalia_codec_construct_format(codec_t *);
a238 12
int	azalia_mixer_init(codec_t *);
int	azalia_mixer_delete(codec_t *);
int	azalia_mixer_get(const codec_t *, mixer_ctrl_t *);
int	azalia_mixer_set(codec_t *, const mixer_ctrl_t *);
int	azalia_mixer_ensure_capacity(codec_t *, size_t);
u_char	azalia_mixer_from_device_value(const codec_t *,
	const mixer_item_t *, uint32_t );
uint32_t	azalia_mixer_to_device_value(const codec_t *,
	const mixer_item_t *, u_char);
boolean_t azalia_mixer_validate_value(const codec_t *,
	const mixer_item_t *, u_char);

d400 1
d939 1
a939 1
	uint32_t rev, result;
d952 1
a952 1
	    COP_VENDOR_ID, &result);
d955 3
a957 1
	azalia_codec_init_vtbl(this, result);
d961 1
a961 1
		printf(" 0x04x/0x%04x", result >> 16, result & 0xffff);
d1078 1
a1078 1
	return azalia_mixer_init(this);
d1084 1
a1084 1
	azalia_mixer_delete(this);
a1320 934
 * HDA mixer functions
 * ================================================================ */

int
azalia_mixer_init(codec_t *this)
{
	/*
	 * pin		"<color>%2.2x"
	 * audio output	"dac%2.2x"
	 * audio input	"adc%2.2x"
	 * mixer	"mixer%2.2x"
	 * selector	"sel%2.2x"
	 */
	mixer_item_t *m;
	int nadcs;
	int err, i, j, k;

	nadcs = 0;
	this->maxmixers = 10;
	this->nmixers = 0;
	this->mixers = malloc(sizeof(mixer_item_t) * this->maxmixers,
	    M_DEVBUF, M_NOWAIT);
	if (this->mixers == NULL) {
		printf("%s: out of memory in %s\n", XNAME(this->az),
		    __func__);
		return ENOMEM;
	}
	bzero(this->mixers, sizeof(mixer_item_t) * this->maxmixers);

	/* register classes */
	DPRINTF(("%s: register classes\n", __func__));
#define AZ_CLASS_INPUT	0
#define AZ_CLASS_OUTPUT	1
#define AZ_CLASS_RECORD	2
	m = &this->mixers[AZ_CLASS_INPUT];
	m->devinfo.index = AZ_CLASS_INPUT;
	strlcpy(m->devinfo.label.name, AudioCinputs,
	    sizeof(m->devinfo.label.name));
	m->devinfo.type = AUDIO_MIXER_CLASS;
	m->devinfo.mixer_class = AZ_CLASS_INPUT;
	m->devinfo.next = AUDIO_MIXER_LAST;
	m->devinfo.prev = AUDIO_MIXER_LAST;
	m->nid = 0;

	m = &this->mixers[AZ_CLASS_OUTPUT];
	m->devinfo.index = AZ_CLASS_OUTPUT;
	strlcpy(m->devinfo.label.name, AudioCoutputs,
	    sizeof(m->devinfo.label.name));
	m->devinfo.type = AUDIO_MIXER_CLASS;
	m->devinfo.mixer_class = AZ_CLASS_OUTPUT;
	m->devinfo.next = AUDIO_MIXER_LAST;
	m->devinfo.prev = AUDIO_MIXER_LAST;
	m->nid = 0;

	m = &this->mixers[AZ_CLASS_RECORD];
	m->devinfo.index = AZ_CLASS_RECORD;
	strlcpy(m->devinfo.label.name, AudioCrecord,
	    sizeof(m->devinfo.label.name));
	m->devinfo.type = AUDIO_MIXER_CLASS;
	m->devinfo.mixer_class = AZ_CLASS_RECORD;
	m->devinfo.next = AUDIO_MIXER_LAST;
	m->devinfo.prev = AUDIO_MIXER_LAST;
	m->nid = 0;

	this->nmixers = AZ_CLASS_RECORD + 1;

#define MIXER_REG_PROLOG	\
	mixer_devinfo_t *d; \
	err = azalia_mixer_ensure_capacity(this, this->nmixers + 1); \
	if (err) \
		return err; \
	m = &this->mixers[this->nmixers]; \
	d = &m->devinfo; \
	d->index = this->nmixers; \
	m->nid = i

	FOR_EACH_WIDGET(this, i) {
		const widget_t *w;

		w = &this->w[i];

		if (w->type == COP_AWTYPE_AUDIO_INPUT)
			nadcs++;

		/* selector */
		if (w->type != COP_AWTYPE_AUDIO_MIXER && w->nconnections >= 2) {
			MIXER_REG_PROLOG;
			DPRINTF(("%s: selector %s\n", __func__, w->name));
			snprintf(d->label.name, sizeof(d->label.name),
			    "%s.source", w->name);
			d->type = AUDIO_MIXER_ENUM;
			if (w->type == COP_AWTYPE_AUDIO_MIXER)
				d->mixer_class = AZ_CLASS_RECORD;
			else if (w->type == COP_AWTYPE_AUDIO_SELECTOR)
				d->mixer_class = AZ_CLASS_INPUT;
			else
				d->mixer_class = AZ_CLASS_OUTPUT;
			d->next = AUDIO_MIXER_LAST;
			d->prev = AUDIO_MIXER_LAST;
			m->target = MI_TARGET_CONNLIST;
			for (j = 0, k = 0; j < w->nconnections && k < 32; j++) {
				if (!VALID_WIDGET_NID(w->connections[j], this))
					continue;
				d->un.e.member[k].ord = k;
				DPRINTF(("%s: selector %d=%s\n", __func__, j,
				    this->w[w->connections[j]].name));
				strlcpy(d->un.e.member[k].label.name,
				    this->w[w->connections[j]].name,
				    MAX_AUDIO_DEV_LEN);
				k++;
			}
			d->un.e.num_mem = k;
			this->nmixers++;
		}

		/* output mute */
		if (w->widgetcap & COP_AWCAP_OUTAMP &&
		    w->outamp_cap & COP_AMPCAP_MUTE) {
			MIXER_REG_PROLOG;
			DPRINTF(("%s: output mute %s\n", __func__, w->name));
			snprintf(d->label.name, sizeof(d->label.name),
			    "%s.mute", w->name);
			d->type = AUDIO_MIXER_ENUM;
			if (w->type == COP_AWTYPE_AUDIO_MIXER)
				d->mixer_class = AZ_CLASS_OUTPUT;
			else if (w->type == COP_AWTYPE_AUDIO_SELECTOR)
				d->mixer_class = AZ_CLASS_OUTPUT;
			else if (w->type == COP_AWTYPE_PIN_COMPLEX)
				d->mixer_class = AZ_CLASS_OUTPUT;
			else
				d->mixer_class = AZ_CLASS_INPUT;
			d->next = AUDIO_MIXER_LAST;
			d->prev = AUDIO_MIXER_LAST;
			m->target = MI_TARGET_OUTAMP;
			d->un.e.num_mem = 2;
			d->un.e.member[0].ord = 0;
			strlcpy(d->un.e.member[0].label.name, AudioNoff,
			    MAX_AUDIO_DEV_LEN);
			d->un.e.member[1].ord = 1;
			strlcpy(d->un.e.member[1].label.name, AudioNon,
			    MAX_AUDIO_DEV_LEN);
			this->nmixers++;
		}

		/* output gain */
		if (w->widgetcap & COP_AWCAP_OUTAMP
		    && COP_AMPCAP_NUMSTEPS(w->outamp_cap)) {
			MIXER_REG_PROLOG;
			DPRINTF(("%s: output gain %s\n", __func__, w->name));
			snprintf(d->label.name, sizeof(d->label.name),
			    "%s", w->name);
			d->type = AUDIO_MIXER_VALUE;
			if (w->type == COP_AWTYPE_AUDIO_MIXER)
				d->mixer_class = AZ_CLASS_OUTPUT;
			else if (w->type == COP_AWTYPE_AUDIO_SELECTOR)
				d->mixer_class = AZ_CLASS_OUTPUT;
			else if (w->type == COP_AWTYPE_PIN_COMPLEX)
				d->mixer_class = AZ_CLASS_OUTPUT;
			else
				d->mixer_class = AZ_CLASS_INPUT;
			d->next = AUDIO_MIXER_LAST;
			d->prev = AUDIO_MIXER_LAST;
			m->target = MI_TARGET_OUTAMP;
			d->un.v.num_channels = WIDGET_CHANNELS(w);
#ifdef MAX_VOLUME_255
			d->un.v.units.name[0] = 0;
			d->un.v.delta = AUDIO_MAX_GAIN /
			    COP_AMPCAP_NUMSTEPS(w->outamp_cap);
#else
			snprintf(d->un.v.units.name, sizeof(d->un.v.units.name),
			    "0.25x%ddB", COP_AMPCAP_STEPSIZE(w->outamp_cap)+1);
			d->un.v.delta = 1;
#endif
			this->nmixers++;
		}

		/* input mute */
		if (w->widgetcap & COP_AWCAP_INAMP &&
		    w->inamp_cap & COP_AMPCAP_MUTE) {
			DPRINTF(("%s: input mute %s\n", __func__, w->name));
			for (j = 0; j < w->nconnections; j++) {
				MIXER_REG_PROLOG;
				if (!VALID_WIDGET_NID(w->connections[j], this))
					continue;
				DPRINTF(("%s: input mute %s.%s\n", __func__,
				    w->name, this->w[w->connections[j]].name));
				snprintf(d->label.name, sizeof(d->label.name),
				    "%s.%s.mute", w->name,
				    this->w[w->connections[j]].name);
				d->type = AUDIO_MIXER_ENUM;
				if (w->type == COP_AWTYPE_PIN_COMPLEX)
					d->mixer_class = AZ_CLASS_OUTPUT;
				else if (w->type == COP_AWTYPE_AUDIO_INPUT)
					d->mixer_class = AZ_CLASS_RECORD;
				else
					d->mixer_class = AZ_CLASS_INPUT;
				d->next = AUDIO_MIXER_LAST;
				d->prev = AUDIO_MIXER_LAST;
				m->target = j;
				d->un.e.num_mem = 2;
				d->un.e.member[0].ord = 0;
				strlcpy(d->un.e.member[0].label.name,
				    AudioNoff, MAX_AUDIO_DEV_LEN);
				d->un.e.member[1].ord = 1;
				strlcpy(d->un.e.member[1].label.name,
				    AudioNon, MAX_AUDIO_DEV_LEN);
				this->nmixers++;
			}
		}

		/* input gain */
		if (w->widgetcap & COP_AWCAP_INAMP
		    && COP_AMPCAP_NUMSTEPS(w->inamp_cap)) {
			DPRINTF(("%s: input gain %s\n", __func__, w->name));
			for (j = 0; j < w->nconnections; j++) {
				MIXER_REG_PROLOG;
				if (!VALID_WIDGET_NID(w->connections[j], this))
					continue;
				DPRINTF(("%s: input gain %s.%s\n", __func__,
				    w->name, this->w[w->connections[j]].name));
				snprintf(d->label.name, sizeof(d->label.name),
				    "%s.%s", w->name,
				    this->w[w->connections[j]].name);
				d->type = AUDIO_MIXER_VALUE;
				if (w->type == COP_AWTYPE_PIN_COMPLEX)
					d->mixer_class = AZ_CLASS_OUTPUT;
				else if (w->type == COP_AWTYPE_AUDIO_INPUT)
					d->mixer_class = AZ_CLASS_RECORD;
				else
					d->mixer_class = AZ_CLASS_INPUT;
				d->next = AUDIO_MIXER_LAST;
				d->prev = AUDIO_MIXER_LAST;
				m->target = j;
				d->un.v.num_channels = WIDGET_CHANNELS(w);
#ifdef MAX_VOLUME_255
				d->un.v.units.name[0] = 0;
				d->un.v.delta = AUDIO_MAX_GAIN /
				    COP_AMPCAP_NUMSTEPS(w->inamp_cap);
#else
				snprintf(d->un.v.units.name,
				    sizeof(d->un.v.units.name), "0.25x%ddB",
				    COP_AMPCAP_STEPSIZE(w->inamp_cap)+1);
				d->un.v.delta = 1;
#endif
				this->nmixers++;
			}
		}

		/* pin direction */
		if (w->type == COP_AWTYPE_PIN_COMPLEX &&
		    w->d.pin.cap & COP_PINCAP_OUTPUT &&
		    w->d.pin.cap & COP_PINCAP_INPUT) {
			MIXER_REG_PROLOG;
			DPRINTF(("%s: pin dir %s\n", __func__, w->name));
			snprintf(d->label.name, sizeof(d->label.name),
			    "%s.dir", w->name);
			d->type = AUDIO_MIXER_ENUM;
			d->mixer_class = AZ_CLASS_OUTPUT;
			d->next = AUDIO_MIXER_LAST;
			d->prev = AUDIO_MIXER_LAST;
			m->target = MI_TARGET_PINDIR;
			d->un.e.num_mem = 2;
			d->un.e.member[0].ord = 0;
			strlcpy(d->un.e.member[0].label.name, AudioNinput,
			    MAX_AUDIO_DEV_LEN);
			d->un.e.member[1].ord = 1;
			strlcpy(d->un.e.member[1].label.name, AudioNoutput,
			    MAX_AUDIO_DEV_LEN);
			this->nmixers++;
		}

		/* pin headphone-boost */
		if (w->type == COP_AWTYPE_PIN_COMPLEX &&
		    w->d.pin.cap & COP_PINCAP_HEADPHONE) {
			MIXER_REG_PROLOG;
			DPRINTF(("%s: hpboost %s\n", __func__, w->name));
			snprintf(d->label.name, sizeof(d->label.name),
			    "%s.boost", w->name);
			d->type = AUDIO_MIXER_ENUM;
			d->mixer_class = AZ_CLASS_OUTPUT;
			d->next = AUDIO_MIXER_LAST;
			d->prev = AUDIO_MIXER_LAST;
			m->target = MI_TARGET_PINBOOST;
			d->un.e.num_mem = 2;
			d->un.e.member[0].ord = 0;
			strlcpy(d->un.e.member[0].label.name, AudioNoff,
			    MAX_AUDIO_DEV_LEN);
			d->un.e.member[1].ord = 1;
			strlcpy(d->un.e.member[1].label.name, AudioNon,
			    MAX_AUDIO_DEV_LEN);
			this->nmixers++;
		}

		/* volume knob */
		if (w->type == COP_AWTYPE_VOLUME_KNOB &&
		    w->d.volume.cap & COP_VKCAP_DELTA) {
			MIXER_REG_PROLOG;
			DPRINTF(("%s: volume knob %s\n", __func__, w->name));
			strlcpy(d->label.name, w->name, sizeof(d->label.name));
			d->type = AUDIO_MIXER_VALUE;
			d->mixer_class = AZ_CLASS_OUTPUT;
			d->next = AUDIO_MIXER_LAST;
			d->prev = AUDIO_MIXER_LAST;
			m->target = MI_TARGET_VOLUME;
			d->un.v.num_channels = 1;
			d->un.v.units.name[0] = 0;
#ifdef MAX_VOLUME_255
			d->un.v.delta = AUDIO_MAX_GAIN /
			    COP_VKCAP_NUMSTEPS(w->d.volume.cap);
#else
			d->un.v.delta = 1;
#endif
			this->nmixers++;
		}
	}

	/* if the codec has multiple DAC groups, create "inputs.usingdac" */
	if (this->ndacgroups > 1) {
		MIXER_REG_PROLOG;
		DPRINTF(("%s: create inputs.usingdac\n", __func__));
		strlcpy(d->label.name, "usingdac", sizeof(d->label.name));
		d->type = AUDIO_MIXER_ENUM;
		d->mixer_class = AZ_CLASS_INPUT;
		d->next = AUDIO_MIXER_LAST;
		d->prev = AUDIO_MIXER_LAST;
		m->target = MI_TARGET_DAC;
		for (i = 0; i < this->ndacgroups && i < 32; i++) {
			d->un.e.member[i].ord = i;
			for (j = 0; j < this->dacgroups[i].nconv; j++) {
				if (j * 2 >= MAX_AUDIO_DEV_LEN)
					break;
				snprintf(d->un.e.member[i].label.name + j*2,
				    MAX_AUDIO_DEV_LEN - j*2, "%2.2x",
				    this->dacgroups[i].conv[j]);
			}
		}
		d->un.e.num_mem = i;
		this->nmixers++;
	}

	/* if the codec has multiple ADCs, create "record.usingadc" */
	if (this->nadcs > 1) {
		MIXER_REG_PROLOG;
		DPRINTF(("%s: create inputs.usingadc\n", __func__));
		strlcpy(d->label.name, "usingadc", sizeof(d->label.name));
		d->type = AUDIO_MIXER_ENUM;
		d->mixer_class = AZ_CLASS_RECORD;
		d->next = AUDIO_MIXER_LAST;
		d->prev = AUDIO_MIXER_LAST;
		m->target = MI_TARGET_ADC;
		for (i = 0; i < this->nadcs && i < 32; i++) {
			d->un.e.member[i].ord = i;
			strlcpy(d->un.e.member[i].label.name,
			    this->w[this->adcs[i]].name, MAX_AUDIO_DEV_LEN);
		}
		d->un.e.num_mem = i;
		this->nmixers++;
	}

	/* unmute all */
	DPRINTF(("%s: unmute\n", __func__));
	for (i = 0; i < this->nmixers; i++) {
		mixer_ctrl_t mc;

		if (!IS_MI_TARGET_INAMP(this->mixers[i].target) &&
		    this->mixers[i].target != MI_TARGET_OUTAMP)
			continue;
		if (this->mixers[i].devinfo.type != AUDIO_MIXER_ENUM)
			continue;
		mc.dev = i;
		mc.type = AUDIO_MIXER_ENUM;
		mc.un.ord = 0;
		azalia_mixer_set(this, &mc);
	}

	/*
	 * for bidirectional pins,
	 * green=front, orange=surround, gray=c/lfe, black=side --> output
	 * blue=line-in, pink=mic-in --> input
	 */
	DPRINTF(("%s: process bidirectional pins\n", __func__));
	for (i = 0; i < this->nmixers; i++) {
		mixer_ctrl_t mc;

		if (this->mixers[i].target != MI_TARGET_PINDIR)
			continue;
		mc.dev = i;
		mc.type = AUDIO_MIXER_ENUM;
		switch (this->w[this->mixers[i].nid].d.pin.color) {
		case CORB_CD_GREEN:
		case CORB_CD_ORANGE:
		case CORB_CD_GRAY:
		case CORB_CD_BLACK:
			mc.un.ord = 1;
			break;
		default:
			mc.un.ord = 0;
		}
		azalia_mixer_set(this, &mc);
	}

	/* set unextreme volume */
	DPRINTF(("%s: set volume\n", __func__));
	for (i = 0; i < this->nmixers; i++) {
		mixer_ctrl_t mc;

		if (!IS_MI_TARGET_INAMP(this->mixers[i].target) &&
		    this->mixers[i].target != MI_TARGET_OUTAMP &&
		    this->mixers[i].target != MI_TARGET_VOLUME)
			continue;
		if (this->mixers[i].devinfo.type != AUDIO_MIXER_VALUE)
			continue;
		mc.dev = i;
		mc.type = AUDIO_MIXER_VALUE;
		mc.un.value.num_channels = 1;
		mc.un.value.level[0] = AUDIO_MAX_GAIN / 2;
		if (this->mixers[i].target != MI_TARGET_VOLUME &&
		    WIDGET_CHANNELS(&this->w[this->mixers[i].nid]) == 2) {
			mc.un.value.num_channels = 2;
			mc.un.value.level[1] = AUDIO_MAX_GAIN / 2;
		}
		azalia_mixer_set(this, &mc);
	}

	return 0;
}

int
azalia_mixer_delete(codec_t *this)
{
	if (this->mixers == NULL)
		return 0;
	free(this->mixers, M_DEVBUF);
	this->mixers = NULL;
	return 0;
}

int
azalia_mixer_get(const codec_t *this, mixer_ctrl_t *mc)
{
	const mixer_item_t *m;
	uint32_t result;
	int err;

	if (mc->dev >= this->nmixers)
		return ENXIO;
	m = &this->mixers[mc->dev];
	mc->type = m->devinfo.type;
	if (mc->type == AUDIO_MIXER_CLASS)
		return 0;	/* nothing to do */

	/* inamp mute */
	if (IS_MI_TARGET_INAMP(m->target) && m->devinfo.type == AUDIO_MIXER_ENUM) {
		err = this->comresp(this, m->nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
		    CORB_GAGM_INPUT | CORB_GAGM_LEFT |
		    MI_TARGET_INAMP(m->target), &result);
		if (err)
			return err;
		mc->un.ord = result & CORB_GAGM_MUTE ? 1 : 0;
	}

	/* inamp gain */
	else if (IS_MI_TARGET_INAMP(m->target) && m->devinfo.type == AUDIO_MIXER_VALUE) {
		err = this->comresp(this, m->nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
		      CORB_GAGM_INPUT | CORB_GAGM_LEFT |
		      MI_TARGET_INAMP(m->target), &result);
		if (err)
			return err;
		mc->un.value.level[0] = azalia_mixer_from_device_value(this, m,
		    CORB_GAGM_GAIN(result));
		mc->un.value.num_channels = WIDGET_CHANNELS(&this->w[m->nid]);
		if (mc->un.value.num_channels == 2) {
			err = this->comresp(this, m->nid,
			    CORB_GET_AMPLIFIER_GAIN_MUTE, CORB_GAGM_INPUT |
			    CORB_GAGM_RIGHT | MI_TARGET_INAMP(m->target),
			    &result);
			if (err)
				return err;
			mc->un.value.level[1] = azalia_mixer_from_device_value
			    (this, m, CORB_GAGM_GAIN(result));
		}
	}

	/* outamp mute */
	else if (m->target == MI_TARGET_OUTAMP && m->devinfo.type == AUDIO_MIXER_ENUM) {
		err = this->comresp(this, m->nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
		    CORB_GAGM_OUTPUT | CORB_GAGM_LEFT | 0, &result);
		if (err)
			return err;
		mc->un.ord = result & CORB_GAGM_MUTE ? 1 : 0;
	}

	/* outamp gain */
	else if (m->target == MI_TARGET_OUTAMP && m->devinfo.type == AUDIO_MIXER_VALUE) {
		err = this->comresp(this, m->nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
		      CORB_GAGM_OUTPUT | CORB_GAGM_LEFT | 0, &result);
		if (err)
			return err;
		mc->un.value.level[0] = azalia_mixer_from_device_value(this, m,
		    CORB_GAGM_GAIN(result));
		mc->un.value.num_channels = WIDGET_CHANNELS(&this->w[m->nid]);
		if (mc->un.value.num_channels == 2) {
			err = this->comresp(this, m->nid,
			    CORB_GET_AMPLIFIER_GAIN_MUTE,
			    CORB_GAGM_OUTPUT | CORB_GAGM_RIGHT | 0, &result);
			if (err)
				return err;
			mc->un.value.level[1] = azalia_mixer_from_device_value
			    (this, m, CORB_GAGM_GAIN(result));
		}
	}

	/* selection */
	else if (m->target == MI_TARGET_CONNLIST) {
		int i;
		err = this->comresp(this, m->nid,
		    CORB_GET_CONNECTION_SELECT_CONTROL, 0, &result);
		if (err)
			return err;
		result = CORB_CSC_INDEX(result);
		mc->un.ord = -1;
		for (i = 0; i <= result; i++) {
			if (!VALID_WIDGET_NID(this->w[m->nid].connections[i], this))
				continue;
			mc->un.ord++;
		}
	}

	/* pin I/O */
	else if (m->target == MI_TARGET_PINDIR) {
		err = this->comresp(this, m->nid,
		    CORB_GET_PIN_WIDGET_CONTROL, 0, &result);
		if (err)
			return err;
		mc->un.ord = result & CORB_PWC_OUTPUT ? 1 : 0;
	}

	/* pin headphone-boost */
	else if (m->target == MI_TARGET_PINBOOST) {
		err = this->comresp(this, m->nid,
		    CORB_GET_PIN_WIDGET_CONTROL, 0, &result);
		if (err)
			return err;
		mc->un.ord = result & CORB_PWC_HEADPHONE ? 1 : 0;
	}

	/* DAC group selection */
	else if (m->target == MI_TARGET_DAC) {
		mc->un.ord = this->cur_dac;
	}

	/* ADC selection */
	else if (m->target == MI_TARGET_ADC) {
		mc->un.ord = this->cur_adc;
	}

	/* Volume knob */
	else if (m->target == MI_TARGET_VOLUME) {
		err = this->comresp(this, m->nid, CORB_GET_VOLUME_KNOB,
		    0, &result);
		if (err)
			return err;
		mc->un.value.level[0] = azalia_mixer_from_device_value(this, m,
		    CORB_VKNOB_VOLUME(result));
		mc->un.value.num_channels = 1;
	}

	else {
		printf("%s: internal error in %s: %x\n", XNAME(this->az),
		    __func__, m->target);
		return -1;
	}
	return 0;
}

int
azalia_mixer_set(codec_t *this, const mixer_ctrl_t *mc)
{
	const mixer_item_t *m;
	uint32_t result, value;
	int err;

	if (mc->dev >= this->nmixers)
		return ENXIO;
	m = &this->mixers[mc->dev];
	if (mc->type != m->devinfo.type)
		return EINVAL;
	if (mc->type == AUDIO_MIXER_CLASS)
		return 0;	/* nothing to do */

	/* inamp mute */
	if (IS_MI_TARGET_INAMP(m->target) && m->devinfo.type == AUDIO_MIXER_ENUM) {
		/* We have to set stereo mute separately to keep each gain value. */
		err = this->comresp(this, m->nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
		    CORB_GAGM_INPUT | CORB_GAGM_LEFT |
		    MI_TARGET_INAMP(m->target), &result);
		if (err)
			return err;
		value = CORB_AGM_INPUT | CORB_AGM_LEFT |
		    (m->target << CORB_AGM_INDEX_SHIFT) |
		    CORB_GAGM_GAIN(result);
		if (mc->un.ord)
			value |= CORB_AGM_MUTE;
		err = this->comresp(this, m->nid, CORB_SET_AMPLIFIER_GAIN_MUTE,
		    value, &result);
		if (err)
			return err;
		if (WIDGET_CHANNELS(&this->w[m->nid]) == 2) {
			err = this->comresp(this, m->nid,
			    CORB_GET_AMPLIFIER_GAIN_MUTE, CORB_GAGM_INPUT |
			    CORB_GAGM_RIGHT | MI_TARGET_INAMP(m->target),
			    &result);
			if (err)
				return err;
			value = CORB_AGM_INPUT | CORB_AGM_RIGHT |
			    (m->target << CORB_AGM_INDEX_SHIFT) |
			    CORB_GAGM_GAIN(result);
			if (mc->un.ord)
				value |= CORB_AGM_MUTE;
			err = this->comresp(this, m->nid,
			    CORB_SET_AMPLIFIER_GAIN_MUTE, value, &result);
			if (err)
				return err;
		}
	}

	/* inamp gain */
	else if (IS_MI_TARGET_INAMP(m->target) && m->devinfo.type == AUDIO_MIXER_VALUE) {
		if (mc->un.value.num_channels < 1)
			return EINVAL;
		if (!azalia_mixer_validate_value(this, m, mc->un.value.level[0]))
			return EINVAL;
		err = this->comresp(this, m->nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
		      CORB_GAGM_INPUT | CORB_GAGM_LEFT |
		      MI_TARGET_INAMP(m->target), &result);
		if (err)
			return err;
		value = azalia_mixer_to_device_value(this, m,
		    mc->un.value.level[0]);
		value = CORB_AGM_INPUT | CORB_AGM_LEFT |
		    (m->target << CORB_AGM_INDEX_SHIFT) |
		    (result & CORB_GAGM_MUTE ? CORB_AGM_MUTE : 0) |
		    (value & CORB_AGM_GAIN_MASK);
		err = this->comresp(this, m->nid, CORB_SET_AMPLIFIER_GAIN_MUTE,
		    value, &result);
		if (err)
			return err;
		if (mc->un.value.num_channels >= 2 &&
		    WIDGET_CHANNELS(&this->w[m->nid]) == 2) {
			if (!azalia_mixer_validate_value(this, m,
			    mc->un.value.level[1]))
				return EINVAL;
			err = this->comresp(this, m->nid,
			      CORB_GET_AMPLIFIER_GAIN_MUTE, CORB_GAGM_INPUT |
			      CORB_GAGM_RIGHT | MI_TARGET_INAMP(m->target),
			      &result);
			if (err)
				return err;
			value = azalia_mixer_to_device_value(this, m,
			    mc->un.value.level[1]);
			value = CORB_AGM_INPUT | CORB_AGM_RIGHT |
			    (m->target << CORB_AGM_INDEX_SHIFT) |
			    (result & CORB_GAGM_MUTE ? CORB_AGM_MUTE : 0) |
			    (value & CORB_AGM_GAIN_MASK);
			err = this->comresp(this, m->nid,
			    CORB_SET_AMPLIFIER_GAIN_MUTE, value, &result);
			if (err)
				return err;
		}
	}

	/* outamp mute */
	else if (m->target == MI_TARGET_OUTAMP && m->devinfo.type == AUDIO_MIXER_ENUM) {
		err = this->comresp(this, m->nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
		    CORB_GAGM_OUTPUT | CORB_GAGM_LEFT, &result);
		if (err)
			return err;
		value = CORB_AGM_OUTPUT | CORB_AGM_LEFT | CORB_GAGM_GAIN(result);
		if (mc->un.ord)
			value |= CORB_AGM_MUTE;
		err = this->comresp(this, m->nid, CORB_SET_AMPLIFIER_GAIN_MUTE,
		    value, &result);
		if (err)
			return err;
		if (WIDGET_CHANNELS(&this->w[m->nid]) == 2) {
			err = this->comresp(this, m->nid,
			    CORB_GET_AMPLIFIER_GAIN_MUTE,
			    CORB_GAGM_OUTPUT | CORB_GAGM_RIGHT, &result);
			if (err)
				return err;
			value = CORB_AGM_OUTPUT | CORB_AGM_RIGHT |
			    CORB_GAGM_GAIN(result);
			if (mc->un.ord)
				value |= CORB_AGM_MUTE;
			err = this->comresp(this, m->nid,
			    CORB_SET_AMPLIFIER_GAIN_MUTE, value, &result);
			if (err)
				return err;
		}
	}

	/* outamp gain */
	else if (m->target == MI_TARGET_OUTAMP && m->devinfo.type == AUDIO_MIXER_VALUE) {
		if (mc->un.value.num_channels < 1)
			return EINVAL;
		if (!azalia_mixer_validate_value(this, m, mc->un.value.level[0]))
			return EINVAL;
		err = this->comresp(this, m->nid, CORB_GET_AMPLIFIER_GAIN_MUTE,
		      CORB_GAGM_OUTPUT | CORB_GAGM_LEFT, &result);
		if (err)
			return err;
		value = azalia_mixer_to_device_value(this, m,
		    mc->un.value.level[0]);
		value = CORB_AGM_OUTPUT | CORB_AGM_LEFT |
		    (result & CORB_GAGM_MUTE ? CORB_AGM_MUTE : 0) |
		    (value & CORB_AGM_GAIN_MASK);
		err = this->comresp(this, m->nid, CORB_SET_AMPLIFIER_GAIN_MUTE,
		    value, &result);
		if (err)
			return err;
		if (mc->un.value.num_channels >= 2 &&
		    WIDGET_CHANNELS(&this->w[m->nid]) == 2) {
			if (!azalia_mixer_validate_value(this, m,
			    mc->un.value.level[1]))
				return EINVAL;
			err = this->comresp(this, m->nid,
			      CORB_GET_AMPLIFIER_GAIN_MUTE, CORB_GAGM_OUTPUT |
			      CORB_GAGM_RIGHT, &result);
			if (err)
				return err;
			value = azalia_mixer_to_device_value(this, m,
			    mc->un.value.level[1]);
			value = CORB_AGM_OUTPUT | CORB_AGM_RIGHT |
			    (result & CORB_GAGM_MUTE ? CORB_AGM_MUTE : 0) |
			    (value & CORB_AGM_GAIN_MASK);
			err = this->comresp(this, m->nid,
			    CORB_SET_AMPLIFIER_GAIN_MUTE, value, &result);
			if (err)
				return err;
		}
	}

	/* selection */
	else if (m->target == MI_TARGET_CONNLIST) {
		int i;
		for (i = 0, value = 0; i < this->w[m->nid].nconnections; i++) {
			if (!VALID_WIDGET_NID(this->w[m->nid].connections[i], this))
				continue;
			if (value == mc->un.ord)
				break;
			value++;
		}
		if (i >= this->w[m->nid].nconnections)
			return EINVAL;
		err = this->comresp(this, m->nid,
		    CORB_SET_CONNECTION_SELECT_CONTROL, i, &result);
		if (err)
			return err;
	}

	/* pin I/O */
	else if (m->target == MI_TARGET_PINDIR) {
		if (mc->un.ord >= 2)
			return EINVAL;
		err = this->comresp(this, m->nid,
		    CORB_GET_PIN_WIDGET_CONTROL, 0, &result);
		if (err)
			return err;
		if (mc->un.ord == 0) {
			result &= ~CORB_PWC_OUTPUT;
			result |= CORB_PWC_INPUT;
		} else {
			result &= ~CORB_PWC_INPUT;
			result |= CORB_PWC_OUTPUT;
		}
		err = this->comresp(this, m->nid,
		    CORB_SET_PIN_WIDGET_CONTROL, result, &result);
		if (err)
			return err;
	}

	/* pin headphone-boost */
	else if (m->target == MI_TARGET_PINBOOST) {
		if (mc->un.ord >= 2)
			return EINVAL;
		err = this->comresp(this, m->nid,
		    CORB_GET_PIN_WIDGET_CONTROL, 0, &result);
		if (err)
			return err;
		if (mc->un.ord == 0) {
			result &= ~CORB_PWC_HEADPHONE;
		} else {
			result |= CORB_PWC_HEADPHONE;
		}
		err = this->comresp(this, m->nid,
		    CORB_SET_PIN_WIDGET_CONTROL, result, &result);
		if (err)
			return err;
	}

	/* DAC group selection */
	else if (m->target == MI_TARGET_DAC) {
		if (this->az->running)
			return EBUSY;
		if (mc->un.ord >= this->ndacgroups)
			return EINVAL;
		this->cur_dac = mc->un.ord;
		return azalia_codec_construct_format(this);
	}

	/* ADC selection */
	else if (m->target == MI_TARGET_ADC) {
		if (this->az->running)
			return EBUSY;
		if (mc->un.ord >= this->nadcs)
			return EINVAL;
		this->cur_adc = mc->un.ord;
		/* use this->adcs[this->cur_adc] */
		return azalia_codec_construct_format(this);
	}

	/* Volume knob */
	else if (m->target == MI_TARGET_VOLUME) {
		if (mc->un.value.num_channels != 1)
			return EINVAL;
		if (!azalia_mixer_validate_value(this, m, mc->un.value.level[0]))
			return EINVAL;
		value = azalia_mixer_to_device_value(this, m,
		     mc->un.value.level[0]) | CORB_VKNOB_DIRECT;
		err = this->comresp(this, m->nid, CORB_SET_VOLUME_KNOB,
		   value, &result);
		if (err)
			return err;
	}

	else {
		printf("%s: internal error in %s: %x\n", XNAME(this->az),
		    __func__, m->target);
		return -1;
	}
	return 0;
}

int
azalia_mixer_ensure_capacity(codec_t *this, size_t newsize)
{
	size_t newmax;
	void *newbuf;

	if (this->maxmixers >= newsize)
		return 0;
	newmax = this->maxmixers + 10;
	if (newmax < newsize)
		newmax = newsize;
	newbuf = malloc(sizeof(mixer_item_t) * newmax, M_DEVBUF, M_NOWAIT);
	if (newbuf == NULL) {
		printf("%s: out of memory in %s\n", XNAME(this->az),
		    __func__);
		return ENOMEM;
	}
	bzero(newbuf, sizeof(mixer_item_t) * newmax);
	bcopy(this->mixers, newbuf, this->maxmixers * sizeof(mixer_item_t));
	free(this->mixers, M_DEVBUF);
	this->mixers = newbuf;
	this->maxmixers = newmax;
	return 0;
}

u_char
azalia_mixer_from_device_value(const codec_t *this, const mixer_item_t *m,
    uint32_t dv)
{
#ifdef MAX_VOLUME_255
	uint32_t dmax;

	if (IS_MI_TARGET_INAMP(m->target))
		dmax = COP_AMPCAP_NUMSTEPS(this->w[m->nid].inamp_cap);
	else if (m->target == MI_TARGET_OUTAMP)
		dmax = COP_AMPCAP_NUMSTEPS(this->w[m->nid].outamp_cap);
	else if (m->target == MI_TARGET_VOLUME)
		dmax = COP_VKCAP_NUMSTEPS(this->w[m->nid].d.volume.cap);
	else {
		printf("unknown target: %d\n", m->target);
		dmax = 255;
	}
	return dv * AUDIO_MAX_GAIN / dmax;
#else
	return dv;
#endif
}

uint32_t
azalia_mixer_to_device_value(const codec_t *this, const mixer_item_t *m,
    u_char uv)
{
#ifdef MAX_VOLUME_255
	uint32_t dmax;

	if (IS_MI_TARGET_INAMP(m->target))
		dmax = COP_AMPCAP_NUMSTEPS(this->w[m->nid].inamp_cap);
	else if (m->target == MI_TARGET_OUTAMP)
		dmax = COP_AMPCAP_NUMSTEPS(this->w[m->nid].outamp_cap);
	else if (m->target == MI_TARGET_VOLUME)
		dmax = COP_VKCAP_NUMSTEPS(this->w[m->nid].d.volume.cap);
	else {
		printf("unknown target: %d\n", m->target);
		dmax = 255;
	}
	return uv * dmax / AUDIO_MAX_GAIN;
#else
	return uv;
#endif
}

boolean_t
azalia_mixer_validate_value(const codec_t *this, const mixer_item_t *m,
    u_char uv)
{
#ifdef MAX_VOLUME_255
	return TRUE;
#else
	uint32_t dmax;

	if (IS_MI_TARGET_INAMP(m->target))
		dmax = COP_AMPCAP_NUMSTEPS(this->w[m->nid].inamp_cap);
	else if (m->target == MI_TARGET_OUTAMP)
		dmax = COP_AMPCAP_NUMSTEPS(this->w[m->nid].outamp_cap);
	else if (m->target == MI_TARGET_VOLUME)
		dmax = COP_VKCAP_NUMSTEPS(this->w[m->nid].d.volume.cap);
	return uv <= dmax;
#endif
}

/* ================================================================
a1546 1
	DPRINTF(("%s: CLE=0x%x\n", __func__, result));
a1559 1
			DPRINTF(("%s: long[%d]=0x%x\n", __func__, i, result));
a1568 1
			DPRINTF(("%s: short[%d]=0x%x\n", __func__, i, result));
d1778 1
d1782 2
a1783 1
	az->running++;
d1791 1
d1795 2
a1796 1
	az->running--;
d1987 1
a1987 1
	return azalia_mixer_set(co, mc);
d1998 1
a1998 1
	return azalia_mixer_get(co, mc);
d2005 1
a2005 1
	codec_t *co;
@


1.9
log
@- general cleaning, removing unneeded vars, spelling, etc
- set traffic class (in PCI config space) to 0
- clean up the interrupt handler
- always read/write the INTCTL register with 4 bytes
- before resetting, ensure RUN bit is zero
- zero the BDP regs during reset
- still has a bunch of hacks in it to get it working, but at least
it interrupts correctly on my workstation now.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.8 2006/05/11 23:34:35 brad Exp $	*/
a581 2
	printf("%s: attach_intr...\n", az->dev.dv_xname);

a880 5
	printf("%s: rirbwp=%d rp=%d resp1=0x%08x resp2=0x%08x\n",
	    __func__, wp, az->rirb_rp, rirb[az->rirb_rp].resp,
	    rirb[az->rirb_rp].resp_ex);
#endif
#if 0
d970 8
a977 11
	if (this->name == NULL) {
		printf("%s: codec: 0x%4.4x/0x%4.4x (rev. %u.%u)\n",
		    XNAME(this->az), result >> 16, result & 0xffff,
		    COP_RID_REVISION(rev), COP_RID_STEPPING(rev));
	} else {
		printf("%s: codec: %s (rev. %u.%u)\n",
		    XNAME(this->az), this->name,
		    COP_RID_REVISION(rev), COP_RID_STEPPING(rev));
	}
	printf("%s: codec: High Definition Audio rev. %u.%u\n",
	    XNAME(this->az), COP_RID_MAJ(rev), COP_RID_MIN(rev));
a1108 1
	char flagbuf[FLAGBUFLEN];
a1177 10
	/* print playback capability */
	snprintf(flagbuf, FLAGBUFLEN, "%s: playback: ", XNAME(this->az));
	azalia_widget_print_audio(&this->w[nid], flagbuf);
	if (this->w[group->conv[0]].widgetcap & COP_AWCAP_DIGITAL) {
		printf("%s: playback: max channels=%d, DIGITAL\n",
		    XNAME(this->az), chan);
	} else {
		printf("%s: playback: max channels=%d\n",
		    XNAME(this->az), chan);
	}
a1183 10
	/* print recording capability */
	snprintf(flagbuf, FLAGBUFLEN, "%s: recording: ", XNAME(this->az));
	azalia_widget_print_audio(&this->w[nid], flagbuf);
	if (this->w[nid].widgetcap & COP_AWCAP_DIGITAL) {
		printf("%s: recording: max channels=%d, DIGITAL\n",
		    XNAME(this->az), chan);
	} else {
		printf("%s: recording: max channels=%d\n",
		    XNAME(this->az), chan);
	}
a1184 1
	printf("create encodings...\n");
a2671 2
	DELAY(1000000);

a2972 2
	printf("allocm %p/%08x\n", stream->buffer.addr,
	    AZALIA_DMA_DMAADDR(&stream->buffer));
d3136 1
d3151 1
@


1.8
log
@use the PCI multimedia subclass type HD audio define from pcireg.h
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.7 2006/05/08 20:36:59 brad Exp $	*/
a161 1
	bus_addr_t dmaend, dmanext; /* XXX needed? */
a292 1

d314 1
a314 1
	NULL,			/* satart_inpu */
d388 3
d414 1
a414 2
	for (v = 0; v < 10; v++)
		DELAY(1000000);
d470 2
a471 2
	azalia_t *az;
	int ret;
a474 4
	az = v;
	ret = 0;
	//printf("[i]");

d477 3
a479 1
		return ret;
d486 4
a489 10
	rirbsts = AZ_READ_1(az, RIRBSTS);
	if (rirbsts & (HDA_RIRBSTS_RIRBOIS | HDA_RIRBSTS_RINTFL)) {
		if (rirbsts & HDA_RIRBSTS_RINTFL) {
			//printf("[R]");
		} else {
			//printf("[O]");
		}
		AZ_WRITE_1(az, RIRBSTS,
		    rirbsts | HDA_RIRBSTS_RIRBOIS | HDA_RIRBSTS_RINTFL);
		ret++;
d491 2
a492 1
	return ret;
d582 2
a777 3
	//rirbctl = AZ_READ_1(az, RIRBCTL);
	//AZ_WRITE_1(az, RIRBCTL, rirbctl & ~HDA_RIRBCTL_RINTCTL);

d790 4
a793 2
	AZ_WRITE_1(az, RIRBCTL, rirbctl | HDA_RIRBCTL_RIRBDMAEN | HDA_RIRBCTL_RINTCTL);
	return 0;
d881 1
d883 3
a885 3
	DPRINTF(("%s: rirbwp=%d rp=%d resp1=0x%8.8x resp2=0x%8.8x\n",
		 __func__, wp, az->rirb_rp, rirb[az->rirb_rp].resp,
		 rirb[az->rirb_rp].resp_ex));
d2610 1
d2612 6
d2630 2
d2643 6
a2648 1
	return 0;
d2656 1
a2656 1
	bus_addr_t dmaaddr;
d2658 2
a2659 2
	uint16_t ctl;
	uint8_t ctl2, intctl;
d2665 2
a2666 1
	if (err)
d2668 4
d2675 1
a2675 1
	this->dmaend = dmaaddr + ((caddr_t)end - (caddr_t)start);
d2678 4
a2681 7
		bdlist[index].low = dmaaddr;
		bdlist[index].high = PTR_UPPER32(dmaaddr);
		bdlist[index].length = blk;
		bdlist[index].flags = BDLIST_ENTRY_IOC;
		printf("bdlist[%d]: addr 0x%08x%08x len %x flags %x\n", index,
		    bdlist[index].high, bdlist[index].low,
		    bdlist[index].length, bdlist[index].flags);
d2683 1
a2683 1
		if (dmaaddr >= this->dmaend) {
a2687 2
	/* The BDL covers the whole of the buffer. */
	this->dmanext = AZALIA_DMA_DMAADDR(&this->buffer);
a2696 1

d2704 3
a2706 1
	intctl = AZ_READ_1(this->az, INTCTL);
d2708 1
a2708 1
	AZ_WRITE_1(this->az, INTCTL, intctl);
d2710 5
a2714 4
	ctl = STR_READ_2(this, CTL);
	ctl |= ctl | HDA_SD_CTL_DEIE | HDA_SD_CTL_FEIE | HDA_SD_CTL_IOCE | HDA_SD_CTL_RUN;
	STR_WRITE_2(this, CTL, ctl);
	return 0;
d2725 3
a2727 2
	AZ_WRITE_1(this->az, INTCTL, AZ_READ_1(this->az, INTCTL) & ~this->intr_bit);
	return 0;
d2730 2
d2735 2
d2738 12
a2749 5
		return 0;
	STR_WRITE_1(this, STS, HDA_SD_STS_DESE
	    | HDA_SD_STS_FIFOE | HDA_SD_STS_BCIS);
	this->intr(this->intr_arg);
	return 1;
d3003 2
a3004 1
	if (err)
d3006 3
a3050 4

	DPRINTF(("%s: this=%p start=%p end=%p blk=%d {enc=%u %uch %u/%ubit %uHz}\n",
	    __func__, v, start, end, blk, param->encoding, param->channels,
	    param->precision, param->precision, param->sample_rate));
@


1.7
log
@fix printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.6 2006/05/08 04:18:43 brad Exp $	*/
d358 1
a358 1
	    && PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_HDAUDIO)
@


1.6
log
@sync NetBSD RCS ids
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.5 2006/05/08 04:11:31 brad Exp $	*/
d514 1
a514 1
	printf("%s: High Definition Audio, rev. %d.%d\n",
@


1.5
log
@Don't crash when a connection list has invalid NIDs.

From NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: azalia.c,v 1.4 2006/05/08 03:59:09 brad Exp $	*/
/*	$NetBSD: azalia.c,v 1.15 2005/09/29 04:14:03 kent Exp $	*/
@


1.4
log
@add some trace messages in azalia_mixer_init().

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.3 2006/05/08 03:52:37 brad Exp $	*/
d1075 4
d1384 1
a1384 1
	int err, i, j;
a1447 1
		DPRINTF(("%s: process w[%d]\n", __func__, i));
d1469 4
a1472 2
			for (j = 0; j < w->nconnections && j < 32; j++) {
				d->un.e.member[j].ord = j;
d1475 1
a1475 1
				strlcpy(d->un.e.member[j].label.name,
d1478 1
d1480 1
a1480 1
			d->un.e.num_mem = j;
d1551 2
d1585 2
d1883 1
d1888 7
a1894 1
		mc->un.ord = CORB_CSC_INDEX(result);
d2113 9
a2121 1
		if (mc->un.ord >= this->w[m->nid].nconnections)
d2124 1
a2124 1
		    CORB_SET_CONNECTION_SELECT_CONTROL, mc->un.ord, &result);
d2529 1
d2531 2
a2532 1
	this->connections = malloc(sizeof(nid_t) * length, M_DEVBUF, M_NOWAIT);
d2538 1
a2538 1
		for (i = 0; i < length; i += 2) {
d2543 3
a2545 2
			this->connections[i] = CORB_CLE_LONG_0(result);
			this->connections[i+1] = CORB_CLE_LONG_1(result);
d2548 1
a2548 1
		for (i = 0; i < length; i += 4) {
d2553 5
a2557 4
			this->connections[i] = CORB_CLE_SHORT_0(result);
			this->connections[i+1] = CORB_CLE_SHORT_1(result);
			this->connections[i+2] = CORB_CLE_SHORT_2(result);
			this->connections[i+3] = CORB_CLE_SHORT_3(result);
a2571 1

@


1.3
log
@- make this compile with AZALIA_DEBUG
- introduce WIDGET_CHANNELS macro

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.2 2006/05/08 03:28:46 brad Exp $	*/
d1395 1
d1444 1
d1453 1
d1468 2
d1482 1
d1511 1
d1542 1
d1545 2
d1574 1
d1577 2
d1612 1
d1634 1
d1656 1
d1678 1
d1702 1
d1719 1
d1739 1
d1761 1
@


1.2
log
@- Don't assume the device always has PCI_MAPREG_MEM_TYPE_64BIT. [1]
- OpenBSD-ify dmesg entry and error path printf's.

[1] From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: azalia.c,v 1.1 2006/04/26 15:53:08 jason Exp $	*/
a39 1
#define AZALIA_DEBUG
d1084 1
a1084 1
#ifdef AZALIA_DEBUGGGG
d1087 2
a1088 2
		for (n = 0; n < this->dacgroups[group].nconv; n++) {
			DPRINTF((" %2.2x", this->dacgroups[group].conv[n]));
d1187 1
a1187 2
			chan += this->w[group->conv[dac]].widgetcap
			    & COP_AWCAP_STEREO ? 2 : 1;
d1203 1
a1203 1
	chan = this->w[nid].widgetcap & COP_AWCAP_STEREO ? 2 : 1;
d1334 3
a1336 3
	    (this->w[group->conv[0]].widgetcap & COP_AWCAP_STEREO) &&
	    (this->w[group->conv[1]].widgetcap & COP_AWCAP_STEREO) &&
	    (this->w[group->conv[2]].widgetcap & COP_AWCAP_STEREO);
d1356 1
a1356 1
		startchan += this->w[nid].widgetcap & COP_AWCAP_STEREO ? 2 : 1;
d1519 1
a1519 2
			d->un.v.num_channels = w->widgetcap & COP_AWCAP_STEREO
			    ? 2 : 1;
d1579 1
a1579 2
				d->un.v.num_channels =
				    w->widgetcap & COP_AWCAP_STEREO ? 2 : 1;
d1755 1
a1755 1
		    this->w[this->mixers[i].nid].widgetcap & COP_AWCAP_STEREO) {
d1808 2
a1809 1
		if (this->w[m->nid].widgetcap & COP_AWCAP_STEREO) {
a1817 3
			mc->un.value.num_channels = 2;
		} else {
			mc->un.value.num_channels = 1;
d1838 2
a1839 1
		if (this->w[m->nid].widgetcap & COP_AWCAP_STEREO) {
a1846 3
			mc->un.value.num_channels = 2;
		} else {
			mc->un.value.num_channels = 1;
d1938 1
a1938 1
		if (this->w[m->nid].widgetcap & COP_AWCAP_STEREO) {
d1979 1
a1979 1
		    this->w[m->nid].widgetcap & COP_AWCAP_STEREO) {
d2015 1
a2015 1
		if (this->w[m->nid].widgetcap & COP_AWCAP_STEREO) {
d2052 1
a2052 1
		    this->w[m->nid].widgetcap & COP_AWCAP_STEREO) {
@


1.1
log
@not quite working driver for azalia audio (this is essentially AC97 for > 2005)
Just as brain damaged and ill specified.  From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d378 3
a380 2
	printf(": Generic High Definition Audio Controller\n");
	if (pci_mapreg_map(pa, ICH_PCI_HDBARL, PCI_MAPREG_MEM_TYPE_64BIT, 0,
d382 1
a382 1
		printf("%s: can't map device i/o space\n", XNAME(sc));
d393 1
a393 1
		printf("%s: can't map interrupt\n", XNAME(sc));
d401 1
a401 1
		printf("%s: can't establish interrupt", XNAME(sc));
d407 1
a407 1
	printf("%s: interrupting at %s\n", XNAME(sc), intrrupt_str);
d515 1
a515 1
	printf("%s: host: High Definition Audio rev. %d.%d\n",
@
