head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.8
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.12
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.10
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.4
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.8
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.13.0.16
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.14
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.12
	OPENBSD_5_0:1.13.0.10
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.8
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.6
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.10
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.8
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.6
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.10
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.8
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.6
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.4
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SMP:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2;
locks; strict;
comment	@ * @;


1.15
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.14;
commitid	LS2TNeCue5R9L67C;

1.14
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2009.04.06.15.18.45;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.14.23.17.23;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.09.04.10.10;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.06.22.31.23;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.31.21.11.01;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.05.17.25.58;	author art;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.10.11.21.03.35;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.12.15.40.30;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.16.03.18.19;	author deraadt;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.02.07.04.47.26;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.17.21.35.02;	author mickey;	state Exp;
branches;
next	;

1.3.4.1
date	2001.05.14.22.25.35;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.07.04.10.41.55;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2003.03.28.00.38.20;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.01.31.22.55.34;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@/*	$OpenBSD: cac_pci.c,v 1.14 2013/05/30 16:15:02 deraadt Exp $	*/
/*	$NetBSD: cac_pci.c,v 1.10 2001/01/10 16:48:04 ad Exp $	*/

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Andrew Doran.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * PCI front-end for cac(4) driver.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/queue.h>
#include <sys/endian.h>

#include <machine/bus.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>

#include <dev/ic/cacreg.h>
#include <dev/ic/cacvar.h>

void	cac_pci_attach(struct device *, struct device *, void *);
const struct	cac_pci_type *cac_pci_findtype(struct pci_attach_args *);
int	cac_pci_match(struct device *, void *, void *);
int	cac_activate(struct device *, int);

struct	cac_ccb *cac_pci_l0_completed(struct cac_softc *);
int	cac_pci_l0_fifo_full(struct cac_softc *);
void	cac_pci_l0_intr_enable(struct cac_softc *, int);
int	cac_pci_l0_intr_pending(struct cac_softc *);
void	cac_pci_l0_submit(struct cac_softc *, struct cac_ccb *);

struct cfattach cac_pci_ca = {
	sizeof(struct cac_softc), cac_pci_match, cac_pci_attach
};

static const struct cac_linkage cac_pci_l0 = {
	cac_pci_l0_completed,
	cac_pci_l0_fifo_full,
	cac_pci_l0_intr_enable,
	cac_pci_l0_intr_pending,
	cac_pci_l0_submit
};

#define CT_STARTFW	0x01	/* Need to start controller firmware */

static const
struct cac_pci_type {
	int	ct_subsysid;
	int	ct_flags;
	const struct	cac_linkage *ct_linkage;
	char	*ct_typestr;
} cac_pci_type[] = {
	{ 0x40300e11,	0,		&cac_l0,	"SMART-2/P" },
	{ 0x40310e11,	0,		&cac_l0,	"SMART-2SL" },
	{ 0x40320e11,	0,		&cac_l0,	"Smart Array 3200" },
	{ 0x40330e11,	0,		&cac_l0,	"Smart Array 3100ES" },
	{ 0x40340e11,	0,		&cac_l0,	"Smart Array 221" },
	{ 0x40400e11,	CT_STARTFW,	&cac_pci_l0,	"Integrated Array" },
	{ 0x40480e11,	CT_STARTFW,	&cac_pci_l0,	"RAID LC2" },
	{ 0x40500e11,	0,		&cac_pci_l0,	"Smart Array 4200" },
	{ 0x40510e11,	0,		&cac_pci_l0,	"Smart Array 4200ES" },
	{ 0x40580e11,	0,		&cac_pci_l0,	"Smart Array 431" },
};

static const
struct cac_pci_product {
	u_short	cp_vendor;
	u_short	cp_product;
} cac_pci_product[] = {
	{ PCI_VENDOR_COMPAQ,	PCI_PRODUCT_COMPAQ_SMART2P },
	{ PCI_VENDOR_DEC,	PCI_PRODUCT_DEC_21554 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_1510 },
};

const struct cac_pci_type *
cac_pci_findtype(pa)
	struct pci_attach_args *pa;
{
	const struct cac_pci_type *ct;
	const struct cac_pci_product *cp;
	pcireg_t subsysid;
	int i;

	cp = cac_pci_product;
	i = 0;
	while (i < sizeof(cac_pci_product) / sizeof(cac_pci_product[0])) {
		if (PCI_VENDOR(pa->pa_id) == cp->cp_vendor &&
		    PCI_PRODUCT(pa->pa_id) == cp->cp_product)
			break;
		cp++;
		i++;
	}
	if (i == sizeof(cac_pci_product) / sizeof(cac_pci_product[0]))
		return (NULL);

	subsysid = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);
	ct = cac_pci_type;
	i = 0;
	while (i < sizeof(cac_pci_type) / sizeof(cac_pci_type[0])) {
		if (subsysid == ct->ct_subsysid)
			break;
		ct++;
		i++;
	}
	if (i == sizeof(cac_pci_type) / sizeof(cac_pci_type[0]))
		return (NULL);

	return (ct);
}

int
cac_pci_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{

	return (cac_pci_findtype(aux) != NULL);
}

void
cac_pci_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct pci_attach_args *pa;
	const struct cac_pci_type *ct;
	struct cac_softc *sc;
	pci_chipset_tag_t pc;
	pci_intr_handle_t ih;
	const char *intrstr;
	pcireg_t reg;
	bus_size_t size;
	int memr, ior, i;

	sc = (struct cac_softc *)self;
	pa = (struct pci_attach_args *)aux;
	pc = pa->pa_pc;
	ct = cac_pci_findtype(pa);

	/*
	 * Map the PCI register window.
	 */
	memr = -1;
	ior = -1;

	for (i = 0x10; i <= 0x14; i += 4) {
		reg = pci_conf_read(pa->pa_pc, pa->pa_tag, i);

		if (PCI_MAPREG_TYPE(reg) == PCI_MAPREG_TYPE_IO) {
			if (ior == -1 && PCI_MAPREG_IO_SIZE(reg) != 0)
				ior = i;
		} else {
			if (memr == -1 && PCI_MAPREG_MEM_SIZE(reg) != 0)
				memr = i;
		}
	}

	if (memr != -1) {
		if (pci_mapreg_map(pa, memr, PCI_MAPREG_TYPE_MEM, 0,
		    &sc->sc_iot, &sc->sc_ioh, NULL, &size, 0))
			memr = -1;
		else
			ior = -1;
	}
	if (ior != -1)
		if (pci_mapreg_map(pa, ior, PCI_MAPREG_TYPE_IO, 0,
		    &sc->sc_iot, &sc->sc_ioh, NULL, &size, 0))
			ior = -1;
	if (memr == -1 && ior == -1) {
		printf(": can't map i/o or memory space\n");
		return;
	}

	sc->sc_dmat = pa->pa_dmat;

	/* Map and establish the interrupt. */
	if (pci_intr_map(pa, &ih)) {
		printf(": can't map interrupt\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, size);
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_BIO, cac_intr,
	    sc, sc->sc_dv.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": can't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, size);
		return;
	}

	printf(": %s, %s\n", intrstr, ct->ct_typestr);

	/* Now attach to the bus-independent code. */
	sc->sc_cl = ct->ct_linkage;
	cac_init(sc, (ct->ct_flags & CT_STARTFW) != 0);
}

int
cac_activate(struct device *self, int act)
{
	struct cac_softc *sc = (struct cac_softc *)self;
	int ret = 0;

	ret = config_activate_children(self, act);

	switch (act) {
	case DVACT_POWERDOWN:
		cac_flush(sc);
		break;
	}

	return (ret);
}


void
cac_pci_l0_submit(struct cac_softc *sc, struct cac_ccb *ccb)
{

	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
	    sc->sc_dmamap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	cac_outl(sc, CAC_42REG_CMD_FIFO, ccb->ccb_paddr);
}

struct cac_ccb *
cac_pci_l0_completed(struct cac_softc *sc)
{
	struct cac_ccb *ccb;
	u_int32_t off;

	if ((off = cac_inl(sc, CAC_42REG_DONE_FIFO)) == 0xffffffffU)
		return (NULL);

	cac_outl(sc, CAC_42REG_DONE_FIFO, 0);
	off = (off & ~3) - sc->sc_ccbs_paddr;
	ccb = (struct cac_ccb *)(sc->sc_ccbs + off);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
	    sc->sc_dmamap->dm_mapsize,
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);

	return (ccb);
}

int
cac_pci_l0_intr_pending(struct cac_softc *sc)
{

	return ((cac_inl(sc, CAC_42REG_STATUS) & CAC_42_EXTINT) != 0);
}

void
cac_pci_l0_intr_enable(struct cac_softc *sc, int state)
{

	cac_outl(sc, CAC_42REG_INTR_MASK, (state ? 0 : 8));	/* XXX */
}

int
cac_pci_l0_fifo_full(struct cac_softc *sc)
{

	return (cac_inl(sc, CAC_42REG_CMD_FIFO) != 0);
}
@


1.14
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: cac_pci.c,v 1.13 2009/04/06 15:18:45 kettenis Exp $	*/
d42 1
a43 1
#include <machine/endian.h>
@


1.13
log
@Adjust for renaming the DEC 21554 in pcidevs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac_pci.c,v 1.12 2008/06/26 05:42:17 ray Exp $	*/
d59 1
d236 18
@


1.12
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac_pci.c,v 1.11 2007/09/14 23:17:23 brad Exp $	*/
d105 1
a105 1
	{ PCI_VENDOR_DEC,	PCI_PRODUCT_DEC_CPQ42XX },
@


1.11
log
@- correct error message if pci_mapreg_map() fails by not printing the
  device name in front.
- remove printing of the name Compaq in front of the adapter model
  name. this is cac(4) it is pretty obvious this is a Compaq adapter.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac_pci.c,v 1.10 2005/08/09 04:10:10 mickey Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.10
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cac_pci.c,v 1.9 2003/03/06 22:31:23 mickey Exp $	*/
d212 1
a212 1
		printf("%s: can't map i/o or memory space\n", self->dv_xname);
d236 1
a236 1
	printf(": %s Compaq %s\n", intrstr, ct->ct_typestr);
@


1.9
log
@this is a fix for kernel panics and craches along w/ other stability
improvements worked out over past few months w/ different people.
the main bug was fixes w/ help of harding@@motd.ca .
10x to all and enjoy the better driver (;
@
text
@d1 1
a1 1
/*	$OpenBSD: cac_pci.c,v 1.8 2001/12/31 21:11:01 mickey Exp $	*/
a216 5

	/* Enable the device. */
	reg = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
		       reg | PCI_COMMAND_MASTER_ENABLE);
@


1.8
log
@unmap io space on failures and happy new year in russian
@
text
@d1 1
a1 1
/*	$OpenBSD: cac_pci.c,v 1.7 2001/11/05 17:25:58 art Exp $	*/
d273 1
a273 1
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
@


1.7
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac_pci.c,v 1.6 2001/10/11 21:03:35 mickey Exp $	*/
d174 1
d202 1
a202 1
		    &sc->sc_iot, &sc->sc_ioh, NULL, NULL, 0))
d209 1
a209 1
		    &sc->sc_iot, &sc->sc_ioh, NULL, NULL, 0))
d226 1
d237 1
@


1.7.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: cac_pci.c,v 1.8 2001/12/31 21:11:01 mickey Exp $	*/
a173 1
	bus_size_t size;
d201 1
a201 1
		    &sc->sc_iot, &sc->sc_ioh, NULL, &size, 0))
d208 1
a208 1
		    &sc->sc_iot, &sc->sc_ioh, NULL, &size, 0))
a224 1
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, size);
a234 1
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, size);
@


1.7.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d273 1
a273 1
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
@


1.6
log
@fix the cmd execution problem from pr#2116; from pvk@@tsinet.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: cac_pci.c,v 1.5 2001/08/25 10:13:29 art Exp $	*/
d249 2
a250 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
d268 2
a269 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
@


1.5
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac_pci.c,v 1.4 2001/06/12 15:40:30 niklas Exp $	*/
d277 1
a277 1
	return (cac_inl(sc, CAC_42REG_STATUS) & CAC_42_EXTINT);
d291 1
a291 1
	return (~cac_inl(sc, CAC_42REG_CMD_FIFO));
@


1.4
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac_pci.c,v 1.3 2001/04/16 03:18:19 deraadt Exp $	*/
d223 1
a223 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.3
log
@dmesg cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: cac_pci.c,v 1.2 2001/02/07 04:47:26 mickey Exp $	*/
d201 1
a201 1
		    &sc->sc_iot, &sc->sc_ioh, NULL, NULL))
d208 1
a208 1
		    &sc->sc_iot, &sc->sc_ioh, NULL, NULL))
@


1.3.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: cac_pci.c,v 1.3 2001/04/16 03:18:19 deraadt Exp $	*/
@


1.3.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac_pci.c,v 1.3.4.1 2001/05/14 22:25:35 niklas Exp $	*/
d201 1
a201 1
		    &sc->sc_iot, &sc->sc_ioh, NULL, NULL, 0))
d208 1
a208 1
		    &sc->sc_iot, &sc->sc_ioh, NULL, NULL, 0))
@


1.3.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cac_pci.c,v 1.3.4.2 2001/07/04 10:41:55 niklas Exp $	*/
d223 2
a224 1
	if (pci_intr_map(pa, &ih)) {
d278 1
a278 1
	return ((cac_inl(sc, CAC_42REG_STATUS) & CAC_42_EXTINT) != 0);
d292 1
a292 1
	return (cac_inl(sc, CAC_42REG_CMD_FIFO) != 0);
@


1.3.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d249 1
a249 2
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
	    sc->sc_dmamap->dm_mapsize,
d267 1
a267 2
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
	    sc->sc_dmamap->dm_mapsize,
@


1.3.4.5
log
@Merge in trunk
@
text
@a173 1
	bus_size_t size;
d201 1
a201 1
		    &sc->sc_iot, &sc->sc_ioh, NULL, &size, 0))
d208 1
a208 1
		    &sc->sc_iot, &sc->sc_ioh, NULL, &size, 0))
a224 1
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, size);
a234 1
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, size);
@


1.3.4.6
log
@Sync the SMP branch with 3.3
@
text
@d273 1
a273 1
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
@


1.2
log
@ok, commit this since it most likely to work; i guess now it will get tested a little bit sooner than in a few months; 10x brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac_pci.c,v 1.1 2000/12/17 21:35:02 mickey Exp $	*/
d239 1
a239 1
	printf(" %s: Compaq %s\n", intrstr, ct->ct_typestr);
@


1.1
log
@Compaq SMART Array RAID controllers.
based on netbsd driver.
testing helps from brad@@
eisa untested, but should work (;
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: cac_pci.c,v 1.7 2000/10/19 15:31:20 ad Exp $	*/
a62 3
#define	PCI_CBIO	0x10	/* Configuration base I/O address */
#define	PCI_CBMA	0x14	/* Configuration base memory address */

d94 6
a99 6
	{ 0x40300e11,	0, 		&cac_l0,	"SMART-2/P" },
	{ 0x40310e11,	0, 		&cac_l0, 	"SMART-2SL" },
	{ 0x40320e11,	0, 		&cac_l0,	"Smart Array 3200" },
	{ 0x40330e11,	0, 		&cac_l0,	"Smart Array 3100ES" },
	{ 0x40340e11,	0, 		&cac_l0,	"Smart Array 221" },
	{ 0x40400e11,	CT_STARTFW, 	&cac_pci_l0,	"Integrated Array" },
d101 2
a102 2
	{ 0x40500e11,	0,	 	&cac_pci_l0,	"Smart Array 4200" },
	{ 0x40510e11,	0, 		&cac_pci_l0,	"Smart Array 4200ES" },
d128 1
a128 1
		if (PCI_VENDOR(pa->pa_id) == cp->cp_vendor && 
d130 1
a130 1
		    	break;
d173 2
a174 1
	pcireg_t csr;
d181 15
a195 6
	if (pci_mapreg_map(pa, PCI_CBMA, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->sc_iot, &sc->sc_ioh, NULL, NULL))
		if (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0,
		    &sc->sc_iot, &sc->sc_ioh, NULL, NULL)) {
			printf(": can't map memory or i/o space\n");
			return;
d197 17
d218 1
a218 1
	csr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
d220 1
a220 1
		       csr | PCI_COMMAND_MASTER_ENABLE);
d264 1
a264 1
	cac_outl(sc, CAC_42REG_DONE_FIFO, 0);	
d278 1
a278 2
	return (cac_inl(sc, CAC_42REG_INTR_PENDING) & 
	    cac_inl(sc, CAC_42REG_STATUS));
@

