head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.16
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.16.0.20
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.18
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.6
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.14
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.12
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.10
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.8
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.15.0.10
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.8
	OPENBSD_5_0:1.15.0.6
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.13.0.8
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.6
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.4
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8;
locks; strict;
comment	@ * @;


1.16
date	2012.10.05.10.51.28;	author haesbaert;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.03.12.19.01;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.03.09.36.26;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.11.18.16.37;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.09.18.49.56;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.04.19.33.21;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.26.20.39.16;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.09.12.16.25;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.04.18.32.15;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.02.01.58.53;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.01.20.52.26;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.27.20.42.38;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.26.19.52.58;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.24.23.36.36;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Avoid uninitiliazed use of ctl and corresponding warnings.
Part of the work to remove -Wno-uninitialized.

ok kettenis@@
@
text
@/*	$OpenBSD: alipm.c,v 1.15 2010/04/08 00:23:53 tedu Exp $	*/

/*
 * Copyright (c) 2005 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/rwlock.h>
#include <sys/systm.h>

#include <dev/i2c/i2cvar.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

#ifdef __sparc64__
#include <arch/sparc64/dev/ofwi2cvar.h>
#endif

/*
 * Acer Labs M7101 Power register definitions.
 */

/* PCI configuration registers. */
#define ALIPM_CONF	0xd0		/* general configuration */
#define ALIPM_CONF_SMBEN	0x0400		/* enable SMBus */
#define ALIPM_BASE	0xe0		/* ACPI and SMBus base address */
#define ALIPM_SMB_HOSTC	0xf0		/* host configuration */
#define ALIPM_SMB_HOSTC_HSTEN	0x00000001	/* enable host controller */
#define ALIPM_SMB_HOSTC_CLOCK	0x00e00000	/* clock speed */
#define ALIPM_SMB_HOSTC_149K	0x00000000	/* 149 KHz clock */
#define ALIPM_SMB_HOSTC_74K	0x00200000	/*  74 KHz clock */
#define ALIPM_SMB_HOSTC_37K	0x00400000	/*  37 KHz clock */
#define ALIPM_SMB_HOSTC_223K	0x00800000	/* 223 KHz clock */
#define ALIPM_SMB_HOSTC_111K	0x00a00000	/* 111 KHz clock */
#define ALIPM_SMB_HOSTC_55K	0x00c00000	/*  55 KHz clock */

#define ALIPM_SMB_SIZE		32	/* SMBus I/O space size */

/* SMBus I/O registers */
#define ALIPM_SMB_HS	0x00		/* host status */
#define ALIPM_SMB_HS_IDLE	0x04
#define ALIPM_SMB_HS_BUSY	0x08	/* running a command */
#define ALIPM_SMB_HS_DONE	0x10	/* command completed */
#define ALIPM_SMB_HS_DEVERR	0x20	/* command error */
#define ALIPM_SMB_HS_BUSERR	0x40	/* transaction collision */
#define ALIPM_SMB_HS_FAILED	0x80	/* failed bus transaction */
#define ALIPM_SMB_HS_BITS \
  "\020\003IDLE\004BUSY\005DONE\006DEVERR\007BUSERR\010FAILED"
#define ALIPM_SMB_HC	0x01		/* host control */
#define ALIPM_SMB_HC_KILL	0x04		/* kill command */
#define ALIPM_SMB_HC_RESET	0x08		/* reset bus */
#define ALIPM_SMB_HC_CMD_QUICK	0x00		/* QUICK command */
#define ALIPM_SMB_HC_CMD_BYTE	0x10		/* BYTE command */
#define ALIPM_SMB_HC_CMD_BDATA	0x20		/* BYTE DATA command */
#define ALIPM_SMB_HC_CMD_WDATA	0x30		/* WORD DATA command */
#define ALIPM_SMB_HC_CMD_BLOCK 0x40		/* BLOCK command */
#define ALIPM_SMB_START		0x02	/* start command */
#define ALIPM_SMB_TXSLVA	0x03	/* transmit slave address */
#define ALIPM_SMB_TXSLVA_READ	(1 << 0)	/* read direction */
#define ALIPM_SMB_TXSLVA_ADDR(x) (((x) & 0x7f) << 1) /* 7-bit address */
#define ALIPM_SMB_HD0		0x04	/* host data 0 */
#define ALIPM_SMB_HD1		0x05	/* host data 1 */
#define ALIPM_SMB_HBDB		0x06	/* host block data byte */
#define ALIPM_SMB_HCMD		0x07	/* host command */

/*
 * Newer chips have a more standard, but different PCI configuration
 * register layout.
 */

#define ALIPM_SMB_BASE	0x14		/* SMBus base address */
#define ALIPM_SMB_HOSTX	0xe0		/* host configuration */

#ifdef ALIPM_DEBUG
#define DPRINTF(x) printf x
#else
#define DPRINTF(x)
#endif

#define ALIPM_DELAY	100
#define ALIPM_TIMEOUT	1

struct alipm_softc {
	struct device sc_dev;

	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;

	struct i2c_controller sc_smb_tag;
	struct rwlock sc_smb_lock;
};

int	alipm_match(struct device *, void *, void *);
void	alipm_attach(struct device *, struct device *, void *);

int	alipm_smb_acquire_bus(void *, int);
void	alipm_smb_release_bus(void *, int);
int	alipm_smb_exec(void *, i2c_op_t, i2c_addr_t, const void *,
	    size_t, void *, size_t, int);

struct cfattach alipm_ca = {
	sizeof(struct alipm_softc),
	alipm_match,
	alipm_attach
};

struct cfdriver alipm_cd = {
	NULL, "alipm", DV_DULL
};

int
alipm_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ALI &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALI_M7101))
		return (1);
	return (0);
}

void
alipm_attach(struct device *parent, struct device *self, void *aux)
{
	struct alipm_softc *sc = (struct alipm_softc *) self;
	struct pci_attach_args *pa = aux;
	struct i2cbus_attach_args iba;
	pcireg_t iobase, reg;
	bus_size_t iosize = ALIPM_SMB_SIZE;

	/* Old chips don't have the PCI 2.2 Capabilities List. */
	reg = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	if ((reg & PCI_STATUS_CAPLIST_SUPPORT) == 0) {
		/* Map I/O space */
		iobase = pci_conf_read(pa->pa_pc, pa->pa_tag, ALIPM_BASE);
		sc->sc_iot = pa->pa_iot;
		if (iobase == 0 ||
		    bus_space_map(sc->sc_iot, iobase >> 16,
		    iosize, 0, &sc->sc_ioh)) {
			printf(": can't map i/o space\n");
			return;
		}

		reg = pci_conf_read(pa->pa_pc, pa->pa_tag, ALIPM_CONF);
		if ((reg & ALIPM_CONF_SMBEN) == 0) {
			printf(": SMBus disabled\n");
			goto fail;
		}

		reg = pci_conf_read(pa->pa_pc, pa->pa_tag, ALIPM_SMB_HOSTC);
		if ((reg & ALIPM_SMB_HOSTC_HSTEN) == 0) {
			printf(": SMBus host disabled\n");
			goto fail;
		}
	} else {
		/* Map I/O space */
		if (pci_mapreg_map(pa, ALIPM_SMB_BASE, PCI_MAPREG_TYPE_IO, 0,
		    &sc->sc_iot, &sc->sc_ioh, NULL, &iosize, ALIPM_SMB_SIZE)) {
			printf(": can't map i/o space\n");
			return;
		}

		reg = pci_conf_read(pa->pa_pc, pa->pa_tag, ALIPM_SMB_HOSTX);
		if ((reg & ALIPM_SMB_HOSTC_HSTEN) == 0) {
			printf(": SMBus host disabled\n");
			goto fail;
		}
	}

	switch (reg & ALIPM_SMB_HOSTC_CLOCK) {
	case ALIPM_SMB_HOSTC_149K:
		printf(": 149KHz clock");
		break;
	case ALIPM_SMB_HOSTC_74K:
		printf(": 74KHz clock");
		break;
	case ALIPM_SMB_HOSTC_37K:
		printf(": 37KHz clock");
		break;
	case ALIPM_SMB_HOSTC_223K:
		printf(": 223KHz clock");
		break;
	case ALIPM_SMB_HOSTC_111K:
		printf(": 111KHz clock");
		break;
	case ALIPM_SMB_HOSTC_55K:
		printf(": 55KHz clock");
		break;
	default:
		printf(" unknown clock speed");
		break;
	}

	printf("\n");

	/* Attach I2C bus */
	rw_init(&sc->sc_smb_lock, "alipm");
	sc->sc_smb_tag.ic_cookie = sc;
	sc->sc_smb_tag.ic_acquire_bus = alipm_smb_acquire_bus;
	sc->sc_smb_tag.ic_release_bus = alipm_smb_release_bus;
	sc->sc_smb_tag.ic_exec = alipm_smb_exec;

	bzero(&iba, sizeof iba);
	iba.iba_name = "iic";
	iba.iba_tag = &sc->sc_smb_tag;
#ifdef __sparc64__
	iba.iba_bus_scan = ofwiic_pci_scan;
	iba.iba_bus_scan_arg = pa;
#endif
	config_found(&sc->sc_dev, &iba, iicbus_print);

	return;

fail:
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
}

int
alipm_smb_acquire_bus(void *cookie, int flags)
{
	struct alipm_softc *sc = cookie;

	if (flags & I2C_F_POLL)
		return (0);

	return (rw_enter(&sc->sc_smb_lock, RW_WRITE | RW_INTR));
}

void
alipm_smb_release_bus(void *cookie, int flags)
{
	struct alipm_softc *sc = cookie;

	if (flags & I2C_F_POLL)
		return;

	rw_exit(&sc->sc_smb_lock);
}

int
alipm_smb_exec(void *cookie, i2c_op_t op, i2c_addr_t addr,
    const void *cmdbuf, size_t cmdlen, void *buf, size_t len, int flags)
{
	struct alipm_softc *sc = cookie;
	u_int8_t *b;
	u_int8_t ctl, st;
	int retries, error = 0;

	DPRINTF(("%s: exec op %d, addr 0x%x, cmdlen %d, len %d, "
	    "flags 0x%x\n", sc->sc_dev.dv_xname, op, addr, cmdlen,
	    len, flags));

	if (!I2C_OP_STOP_P(op) || cmdlen > 1 || len > 2)
		return (EOPNOTSUPP);

	/* Clear status bits */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ALIPM_SMB_HS,
	    ALIPM_SMB_HS_DONE | ALIPM_SMB_HS_FAILED |
	    ALIPM_SMB_HS_BUSERR | ALIPM_SMB_HS_DEVERR);
	bus_space_barrier(sc->sc_iot, sc->sc_ioh, ALIPM_SMB_HS, 1,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);

	/* Wait until bus is idle */
	for (retries = 1000; retries > 0; retries--) {
		st = bus_space_read_1(sc->sc_iot, sc->sc_ioh, ALIPM_SMB_HS);
		bus_space_barrier(sc->sc_iot, sc->sc_ioh, ALIPM_SMB_HS, 1,
		    BUS_SPACE_BARRIER_READ);
		if (st & (ALIPM_SMB_HS_IDLE | ALIPM_SMB_HS_FAILED |
		    ALIPM_SMB_HS_BUSERR | ALIPM_SMB_HS_DEVERR))
			break;
		DELAY(ALIPM_DELAY);
	}
	if (retries == 0) {
		printf("%s: timeout st 0x%b\n", sc->sc_dev.dv_xname,
		    st, ALIPM_SMB_HS_BITS);
		return (ETIMEDOUT);
	}
	if (st & (ALIPM_SMB_HS_FAILED |
	    ALIPM_SMB_HS_BUSERR | ALIPM_SMB_HS_DEVERR)) {
		printf("%s: error st 0x%b\n", sc->sc_dev.dv_xname,
		    st, ALIPM_SMB_HS_BITS);
		return (EIO);
	}

	/* Set slave address and transfer direction. */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ALIPM_SMB_TXSLVA,
	    ALIPM_SMB_TXSLVA_ADDR(addr) |
	    (I2C_OP_READ_P(op) ? ALIPM_SMB_TXSLVA_READ : 0));

	b = (void *)cmdbuf;
	if (cmdlen > 0)
		/* Set command byte */
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		     ALIPM_SMB_HCMD, b[0]);

	if (I2C_OP_WRITE_P(op)) {
		/* Write data. */
		b = buf;
		if (len > 0)
			bus_space_write_1(sc->sc_iot, sc->sc_ioh,
			    ALIPM_SMB_HD0, b[0]);
		if (len > 1)
			bus_space_write_1(sc->sc_iot, sc->sc_ioh,
			    ALIPM_SMB_HD1, b[1]);
	}

	/* Set SMBus command */
	if (len == 0)
		ctl = ALIPM_SMB_HC_CMD_BYTE;
	else if (len == 1)
		ctl = ALIPM_SMB_HC_CMD_BDATA;
	else if (len == 2)
		ctl = ALIPM_SMB_HC_CMD_WDATA;
	else
		panic("%s: unexpected len %zd", __func__, len);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ALIPM_SMB_HC, ctl);

	/* Start transaction */
	bus_space_barrier(sc->sc_iot, sc->sc_ioh, 0, ALIPM_SMB_SIZE,
	    BUS_SPACE_BARRIER_WRITE);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ALIPM_SMB_START, 0xff);
	bus_space_barrier(sc->sc_iot, sc->sc_ioh, 0, ALIPM_SMB_SIZE,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);

	/* Poll for completion */
	DELAY(ALIPM_DELAY);
	for (retries = 1000; retries > 0; retries--) {
		st = bus_space_read_1(sc->sc_iot, sc->sc_ioh, ALIPM_SMB_HS);
		bus_space_barrier(sc->sc_iot, sc->sc_ioh, ALIPM_SMB_HS, 1,
		    BUS_SPACE_BARRIER_READ);
		if (st & (ALIPM_SMB_HS_IDLE | ALIPM_SMB_HS_FAILED |
		    ALIPM_SMB_HS_BUSERR | ALIPM_SMB_HS_DEVERR))
			break;
		DELAY(ALIPM_DELAY);
	}
	if (retries == 0) {
		printf("%s: timeout st 0x%b, resetting\n",
		    sc->sc_dev.dv_xname, st, ALIPM_SMB_HS_BITS);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, ALIPM_SMB_HC,
		    ALIPM_SMB_HC_RESET);
		bus_space_barrier(sc->sc_iot, sc->sc_ioh, 0, ALIPM_SMB_SIZE,
		     BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
		st = bus_space_read_1(sc->sc_iot, sc->sc_ioh, ALIPM_SMB_HS);
		bus_space_barrier(sc->sc_iot, sc->sc_ioh, ALIPM_SMB_HS, 1,
		    BUS_SPACE_BARRIER_READ);
		error = ETIMEDOUT;
		goto done;
	}

	if ((st & ALIPM_SMB_HS_DONE) == 0) {
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, ALIPM_SMB_HC,
		     ALIPM_SMB_HC_KILL);
		bus_space_barrier(sc->sc_iot, sc->sc_ioh, 0, ALIPM_SMB_SIZE,
		     BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
		st = bus_space_read_1(sc->sc_iot, sc->sc_ioh, ALIPM_SMB_HS);
		bus_space_barrier(sc->sc_iot, sc->sc_ioh, ALIPM_SMB_HS, 1,
		    BUS_SPACE_BARRIER_READ);
		if ((st & ALIPM_SMB_HS_FAILED) == 0)
			printf("%s: error st 0x%b\n", sc->sc_dev.dv_xname,
			    st, ALIPM_SMB_HS_BITS);
	}

	/* Check for errors */
	if (st & (ALIPM_SMB_HS_FAILED |
	    ALIPM_SMB_HS_BUSERR | ALIPM_SMB_HS_DEVERR)) {
		error = EIO;
		goto done;
	}

	if (I2C_OP_READ_P(op)) {
		/* Read data */
		b = buf;
		if (len > 0) {
			b[0] = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
			    ALIPM_SMB_HD0);
			bus_space_barrier(sc->sc_iot, sc->sc_ioh,
			    ALIPM_SMB_HD0, 1, BUS_SPACE_BARRIER_READ);
		}
		if (len > 1) {
			b[1] = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
			    ALIPM_SMB_HD1);
			bus_space_barrier(sc->sc_iot, sc->sc_ioh,
			    ALIPM_SMB_HD1, 1, BUS_SPACE_BARRIER_READ);
		}
	}

done:
	/* Clear status bits */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ALIPM_SMB_HS, st);

	return (error);
}
@


1.15
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: alipm.c,v 1.14 2009/03/29 21:53:52 sthen Exp $	*/
d330 2
@


1.14
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: alipm.c,v 1.13 2007/05/03 12:19:01 dlg Exp $	*/
a22 1
#include <sys/proc.h>
@


1.13
log
@missed an struct lock to struct rwlock in the softc.

found by and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: alipm.c,v 1.12 2007/05/03 09:36:26 dlg Exp $	*/
d157 1
a157 1
			printf(": can't map I/O space\n");
d176 1
a176 1
			printf(": can't map I/O space\n");
@


1.12
log
@convert lockmgr style locks to rwlocks.

input from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: alipm.c,v 1.11 2006/12/11 18:16:37 deraadt Exp $	*/
d107 1
a107 1
	struct lock sc_smb_lock;
@


1.11
log
@do not bus_space_map devices which are at address 0; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: alipm.c,v 1.10 2006/05/09 18:49:56 kettenis Exp $	*/
d22 1
a22 1
#include <sys/lock.h>
d214 1
a214 1
	lockinit(&sc->sc_smb_lock, PRIBIO | PCATCH, "alipm", 0, 0);
d243 1
a243 1
	return (lockmgr(&sc->sc_smb_lock, LK_EXCLUSIVE, NULL));
d254 1
a254 1
	lockmgr(&sc->sc_smb_lock, LK_RELEASE, NULL);
@


1.10
log
@Sprinkle a few bus_space_barrier() calls.  Some of these may not be strictly
necessary, but they will help debugging of alipm(4) still messes up the bus
on sparc64.  Always enable on sparc64 again.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: alipm.c,v 1.9 2006/03/04 19:33:21 miod Exp $	*/
d154 2
a155 1
		if (bus_space_map(sc->sc_iot, iobase >> 16,
@


1.9
log
@Typos grab bag of the month, eyeballed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: alipm.c,v 1.8 2006/02/26 20:39:16 kettenis Exp $	*/
a209 13
#ifdef __sparc64__
	/*
	 * XXX We get data_access_error exceptions on Blade 100 and
	 * Blade 150 machines with 233KHz clock.  We should
	 * investigate wether changing the clock speed to 74KHz fixes
	 * the problem.
	 */
	if ((reg & ALIPM_SMB_HOSTC_CLOCK) != ALIPM_SMB_HOSTC_74K) {
		printf(", disabling to avoid hardware failure\n");
		return;
	}
#endif

d276 2
d282 2
d333 2
d336 2
d343 2
d355 2
d358 2
d367 2
d370 2
d387 1
a387 1
		if (len > 0)
d390 4
a393 1
		if (len > 1)
d396 3
@


1.8
log
@Disable alipm(4) on sparc64 if not running at the recommended 74KHz clock, to
avoid data_access_error exceptions.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: alipm.c,v 1.7 2006/02/09 12:16:25 dlg Exp $	*/
d42 1
a42 1
#define ALIPM_CONF_SMBEN	0x0400		/* emanble SMBus */
@


1.7
log
@split the ofw scan up into two parts: one to find the i2c bus on a pci
device, and one to find i2c devices on the i2c bus.

tweaks and ok kettenis@@ ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: alipm.c,v 1.6 2006/01/04 18:32:15 kettenis Exp $	*/
d209 13
@


1.6
log
@Make sure we unmap io space if we fail to attach.
"makes sense" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: alipm.c,v 1.5 2006/01/02 01:58:53 deraadt Exp $	*/
d223 1
a223 1
	iba.iba_bus_scan = ofwiic_scan;
@


1.5
log
@do i2c initialization using ofw data instead of scanning; ok kettenis
this may require some changes for non-pmu controllers later, which may
do the ofw tables slightly differently
@
text
@d1 1
a1 1
/*	$OpenBSD: alipm.c,v 1.4 2006/01/01 20:52:26 deraadt Exp $	*/
d145 2
a146 2
	pcireg_t iobase;
	pcireg_t reg;
d155 1
a155 1
		    ALIPM_SMB_SIZE, 0, &sc->sc_ioh)) {
d163 1
a163 1
			return;
d169 1
a169 1
			return;
d174 1
a174 1
		    &sc->sc_iot, &sc->sc_ioh, NULL, NULL, ALIPM_SMB_SIZE)) {
d182 1
a182 1
			return;
d227 5
@


1.4
log
@switch from macppc-specific maciic(4) driver to the generic iic(4),
after teaching it to use a function pointer to get back to the OFW
scan.. this will also help the sparc64 later; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: alipm.c,v 1.3 2005/12/27 20:42:38 kettenis Exp $	*/
d32 4
d222 4
@


1.3
log
@Add support for newer M7101 chips with different PCI config registers layout.
tested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: alipm.c,v 1.2 2005/12/26 19:52:58 kettenis Exp $	*/
d214 2
a217 1
	iba.iba_scan = 1;
@


1.2
log
@Reset i2c bus if operation times out.
@
text
@d1 1
a1 1
/*	$OpenBSD: alipm.c,v 1.1 2005/12/24 23:36:36 kettenis Exp $	*/
d79 8
d144 36
a179 19
	/* Map I/O space */
	iobase = pci_conf_read(pa->pa_pc, pa->pa_tag, ALIPM_BASE) >> 16;
	sc->sc_iot = pa->pa_iot;
	if (bus_space_map(sc->sc_iot, iobase,
	    ALIPM_SMB_SIZE, 0, &sc->sc_ioh)) {
		printf(": can't map I/O space\n");
		return;
	}

	reg = pci_conf_read(pa->pa_pc, pa->pa_tag, ALIPM_CONF);
	if ((reg & ALIPM_CONF_SMBEN) == 0) {
		printf(": SMBus disabled\n");
		return;
	}

	reg = pci_conf_read(pa->pa_pc, pa->pa_tag, ALIPM_SMB_HOSTC);
	if ((reg & ALIPM_SMB_HOSTC_HSTEN) == 0) {
		printf(": SMBus host disabled\n");
		return;
d340 3
@


1.1
log
@Driver for Acer Labs M7101 power management controller
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d247 2
a248 2
		printf("%s: timeout waiting until bus is idle\n",
		    sc->sc_dev.dv_xname);
d253 1
a253 1
		printf("%s: bus error 0x%b\n", sc->sc_dev.dv_xname,
d302 5
a306 1
		printf("%s: timeout\n", sc->sc_dev.dv_xname);
@

