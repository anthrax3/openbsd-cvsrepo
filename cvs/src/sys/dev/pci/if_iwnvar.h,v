head	1.32;
access;
symbols
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.30.0.6
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.4
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.6
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.24.0.4
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.32
date	2016.12.07.15.48.44;	author stsp;	state Exp;
branches;
next	1.31;
commitid	1fHfCmgslQH9ejDE;

1.31
date	2016.09.05.08.18.18;	author tedu;	state Exp;
branches;
next	1.30;
commitid	mIu2ZXphx8O1xOdL;

1.30
date	2016.01.05.18.41.15;	author stsp;	state Exp;
branches;
next	1.29;
commitid	2QagMjdMhQhIaQgu;

1.29
date	2016.01.04.13.54.19;	author stsp;	state Exp;
branches;
next	1.28;
commitid	ry4GqFXRBXnQ5vkR;

1.28
date	2014.09.09.18.55.08;	author sthen;	state Exp;
branches;
next	1.27;
commitid	8pWlzts5FN03iazF;

1.27
date	2014.02.10.19.08.58;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2013.11.30.19.41.21;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2013.11.14.12.40.00;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2012.11.17.14.02.51;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2012.11.12.00.20.41;	author jcs;	state Exp;
branches;
next	1.22;

1.22
date	2011.01.09.15.45.37;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2010.09.07.16.21.45;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2010.07.23.06.43.00;	author phessler;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.05.19.47.43;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.30.16.06.46;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2010.02.17.18.23.00;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.04.17.46.52;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.28.18.42.47;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.26.17.55.29;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.24.18.14.57;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2009.05.29.08.25.45;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2009.05.20.16.31.50;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2009.05.12.19.10.57;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2009.02.15.08.58.22;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.03.17.17.08;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2008.12.02.17.17.50;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.19.18.52.53;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.09.10.00.17;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2008.10.22.06.25.07;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2008.10.13.16.37.10;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2007.11.19.19.34.25;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2007.09.06.16.37.03;	author damien;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Add mira support to iwn(4).
Please let me know about any regressions.

Tested by myself, tb@@, okan@@, jca@@, naddy@@, mlarkin@@
ok tb@@ jca@@
@
text
@/*	$OpenBSD: if_iwnvar.h,v 1.31 2016/09/05 08:18:18 tedu Exp $	*/

/*-
 * Copyright (c) 2007, 2008
 *	Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

struct iwn_rx_radiotap_header {
	struct ieee80211_radiotap_header wr_ihdr;
	uint64_t	wr_tsft;
	uint8_t		wr_flags;
	uint8_t		wr_rate;
	uint16_t	wr_chan_freq;
	uint16_t	wr_chan_flags;
	int8_t		wr_dbm_antsignal;
	int8_t		wr_dbm_antnoise;
} __packed;

#define IWN_RX_RADIOTAP_PRESENT						\
	((1 << IEEE80211_RADIOTAP_TSFT) |				\
	 (1 << IEEE80211_RADIOTAP_FLAGS) |				\
	 (1 << IEEE80211_RADIOTAP_RATE) |				\
	 (1 << IEEE80211_RADIOTAP_CHANNEL) |				\
	 (1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL) |			\
	 (1 << IEEE80211_RADIOTAP_DBM_ANTNOISE))

struct iwn_tx_radiotap_header {
	struct ieee80211_radiotap_header wt_ihdr;
	uint8_t		wt_flags;
	uint8_t		wt_rate;
	uint16_t	wt_chan_freq;
	uint16_t	wt_chan_flags;
	uint8_t		wt_hwqueue;
} __packed;

#define IWN_TX_RADIOTAP_PRESENT						\
	((1 << IEEE80211_RADIOTAP_FLAGS) |				\
	 (1 << IEEE80211_RADIOTAP_RATE) |				\
	 (1 << IEEE80211_RADIOTAP_CHANNEL) |				\
	 (1 << IEEE80211_RADIOTAP_HWQUEUE))

struct iwn_dma_info {
	bus_dma_tag_t		tag;
	bus_dmamap_t		map;
	bus_dma_segment_t	seg;
	bus_addr_t		paddr;
	caddr_t			vaddr;
	bus_size_t		size;
};

struct iwn_tx_data {
	bus_dmamap_t		map;
	bus_addr_t		cmd_paddr;
	bus_addr_t		scratch_paddr;
	struct mbuf		*m;
	struct ieee80211_node	*ni;
	int totlen;
};

struct iwn_tx_ring {
	struct iwn_dma_info	desc_dma;
	struct iwn_dma_info	cmd_dma;
	struct iwn_tx_desc	*desc;
	struct iwn_tx_cmd	*cmd;
	struct iwn_tx_data	data[IWN_TX_RING_COUNT];
	int			qid;
	int			queued;
	int			cur;
};

struct iwn_softc;

struct iwn_rx_data {
	struct mbuf	*m;
	bus_dmamap_t	map;
};

struct iwn_rx_ring {
	struct iwn_dma_info	desc_dma;
	struct iwn_dma_info	stat_dma;
	uint32_t		*desc;
	struct iwn_rx_status	*stat;
	struct iwn_rx_data	data[IWN_RX_RING_COUNT];
	int			cur;
};

struct iwn_node {
	struct	ieee80211_node		ni;	/* must be the first */
	struct	ieee80211_amrr_node	amn;
	struct	ieee80211_mira_node	mn;
	uint16_t			disable_tid;
	uint8_t				id;
	uint8_t				ridx[IEEE80211_RATE_MAXSIZE];
};

struct iwn_calib_state {
	uint8_t		state;
#define IWN_CALIB_STATE_INIT	0
#define IWN_CALIB_STATE_ASSOC	1
#define IWN_CALIB_STATE_RUN	2

	u_int		nbeacons;
	uint32_t	noise[3];
	uint32_t	rssi[3];
	uint32_t	ofdm_x1;
	uint32_t	ofdm_mrc_x1;
	uint32_t	ofdm_x4;
	uint32_t	ofdm_mrc_x4;
	uint32_t	cck_x4;
	uint32_t	cck_mrc_x4;
	uint32_t	bad_plcp_ofdm;
	uint32_t	fa_ofdm;
	uint32_t	bad_plcp_cck;
	uint32_t	fa_cck;
	uint32_t	low_fa;
	uint8_t		cck_state;
#define IWN_CCK_STATE_INIT	0
#define IWN_CCK_STATE_LOFA	1
#define IWN_CCK_STATE_HIFA	2

	uint8_t		noise_samples[20];
	u_int		cur_noise_sample;
	uint8_t		noise_ref;
	uint32_t	energy_samples[10];
	u_int		cur_energy_sample;
	uint32_t	energy_cck;
};

struct iwn_calib_info {
	uint8_t		*buf;
	u_int		len;
};

struct iwn_fw_part {
	const uint8_t	*text;
	uint32_t	textsz;
	const uint8_t	*data;
	uint32_t	datasz;
};

struct iwn_fw_info {
	u_char			*data;
	size_t			size;
	struct iwn_fw_part	init;
	struct iwn_fw_part	main;
	struct iwn_fw_part	boot;
};

struct iwn_ops {
	int		(*load_firmware)(struct iwn_softc *);
	void		(*read_eeprom)(struct iwn_softc *);
	int		(*post_alive)(struct iwn_softc *);
	int		(*nic_config)(struct iwn_softc *);
	void		(*update_sched)(struct iwn_softc *, int, int, uint8_t,
			    uint16_t);
	int		(*get_temperature)(struct iwn_softc *);
	int		(*get_rssi)(const struct iwn_rx_stat *);
	int		(*set_txpower)(struct iwn_softc *, int);
	int		(*init_gains)(struct iwn_softc *);
	int		(*set_gains)(struct iwn_softc *);
	int		(*add_node)(struct iwn_softc *, struct iwn_node_info *,
			    int);
	void		(*tx_done)(struct iwn_softc *, struct iwn_rx_desc *,
			    struct iwn_rx_data *);
	void		(*ampdu_tx_start)(struct iwn_softc *,
			    struct ieee80211_node *, uint8_t, uint16_t);
	void		(*ampdu_tx_stop)(struct iwn_softc *, uint8_t,
			    uint16_t);
};

struct iwn_softc {
	struct device		sc_dev;

	struct ieee80211com	sc_ic;
	int			(*sc_newstate)(struct ieee80211com *,
				    enum ieee80211_state, int);

	struct ieee80211_amrr	amrr;
	uint8_t			fixed_ridx;

	bus_dma_tag_t		sc_dmat;

	struct rwlock		sc_rwlock;
	u_int			sc_flags;
#define IWN_FLAG_HAS_5GHZ	(1 << 0)
#define IWN_FLAG_HAS_OTPROM	(1 << 1)
#define IWN_FLAG_CALIB_DONE	(1 << 2)
#define IWN_FLAG_USE_ICT	(1 << 3)
#define IWN_FLAG_INTERNAL_PA	(1 << 4)
#define IWN_FLAG_HAS_11N	(1 << 6)
#define IWN_FLAG_ENH_SENS	(1 << 7)
#define IWN_FLAG_ADV_BT_COEX	(1 << 8)

	uint8_t 		hw_type;

	struct iwn_ops		ops;
	const char		*fwname;
	const struct iwn_sensitivity_limits
				*limits;
	int			ntxqs;
	int			ndmachnls;
	uint8_t			broadcast_id;
	int			rxonsz;
	int			schedsz;
	uint32_t		fw_text_maxsz;
	uint32_t		fw_data_maxsz;
	uint32_t		fwsz;
	bus_size_t		sched_txfact_addr;

	/* TX scheduler rings. */
	struct iwn_dma_info	sched_dma;
	uint16_t		*sched;
	uint32_t		sched_base;

	/* "Keep Warm" page. */
	struct iwn_dma_info	kw_dma;

	/* Firmware DMA transfer. */
	struct iwn_dma_info	fw_dma;

	/* ICT table. */
	struct iwn_dma_info	ict_dma;
	uint32_t		*ict;
	int			ict_cur;

	/* TX/RX rings. */
	struct iwn_tx_ring	txq[IWN5000_NTXQUEUES];
	struct iwn_rx_ring	rxq;

	bus_space_tag_t		sc_st;
	bus_space_handle_t	sc_sh;
	void 			*sc_ih;
	pci_chipset_tag_t	sc_pct;
	pcitag_t		sc_pcitag;
	bus_size_t		sc_sz;
	int			sc_cap_off;	/* PCIe Capabilities. */

	struct timeout		calib_to;
	int			calib_cnt;
	struct iwn_calib_state	calib;

	struct task		init_task;

	struct iwn_fw_info	fw;
	struct iwn_calib_info	calibcmd[5];
	uint32_t		errptr;

	struct iwn_rx_stat	last_rx_stat;
	int			last_rx_valid;
#define IWN_LAST_RX_VALID	0x01
#define IWN_LAST_RX_AMPDU	0x02
	struct iwn_ucode_info	ucode_info;
	struct iwn_rxon		rxon;
	uint32_t		rawtemp;
	int			temp;
	int			noise;
	uint32_t		qfullmsk;

	uint32_t		prom_base;
	struct iwn4965_eeprom_band
				bands[IWN_NBANDS];
	uint16_t		rfcfg;
	uint8_t			calib_ver;
	char			eeprom_domain[4];
	uint32_t		eeprom_crystal;
	int16_t			eeprom_temp;
	int16_t			eeprom_voltage;
	int16_t			eeprom_rawtemp;
	int8_t			maxpwr2GHz;
	int8_t			maxpwr5GHz;
	int8_t			maxpwr[IEEE80211_CHAN_MAX];
	int8_t			enh_maxpwr[35];

	uint8_t			reset_noise_gain;
	uint8_t			noise_gain;

	uint32_t		tlv_feature_flags;

	int32_t			temp_off;
	uint32_t		int_mask;
	uint8_t			ntxchains;
	uint8_t			nrxchains;
	uint8_t			txchainmask;
	uint8_t			rxchainmask;
	uint8_t			chainmask;

	int			sc_tx_timer;

#if NBPFILTER > 0
	caddr_t			sc_drvbpf;

	union {
		struct iwn_rx_radiotap_header th;
		uint8_t	pad[IEEE80211_RADIOTAP_HDRLEN];
	} sc_rxtapu;
#define sc_rxtap	sc_rxtapu.th
	int			sc_rxtap_len;

	union {
		struct iwn_tx_radiotap_header th;
		uint8_t	pad[IEEE80211_RADIOTAP_HDRLEN];
	} sc_txtapu;
#define sc_txtap	sc_txtapu.th
	int			sc_txtap_len;
#endif
};
@


1.31
log
@convert busy flag and tsleep to rwlock as in iwm
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.30 2016/01/05 18:41:15 stsp Exp $	*/
d69 1
d102 1
@


1.30
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.29 2016/01/04 13:54:19 stsp Exp $	*/
d193 1
a199 1
#define IWN_FLAG_BUSY		(1 << 5)
@


1.29
log
@Add initial support for 11n mode to the iwn(4) driver.
Only MCS 0 to 7 are supported for now.

Tested by many. There might still be outstanding issues but they now appear
to be rare. I'm putting this in so that additional fixes can be developed
and tested more easily if required. This diff is already quite large for
one commit.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.28 2014/09/09 18:55:08 sthen Exp $	*/
a174 1
#ifndef IEEE80211_NO_HT
a178 1
#endif
@


1.28
log
@Backport https://svnweb.freebsd.org/base?view=revision&revision=258829 to fix
scans with various iwn(4) devices. From Fabian Raetz, testing by Fabian,
Marcin Piotr Pawlowski, Mike Burns, kettenis@@ and myself. ok kettenis@@ with
minor tweaks for whitespace in #define lines which I've done; also I have
done s/IWL/IWN/ in comments as noticed by dcoppa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.27 2014/02/10 19:08:58 kettenis Exp $	*/
d262 2
@


1.27
log
@Intel Centrino Wireless-N 2230 support.  From Fabian Raetz, with a little bit
of polishing from yours truly.  Tested by Fabian and Benoit Lecocq.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.26 2013/11/30 19:41:21 kettenis Exp $	*/
d286 2
@


1.26
log
@Seems we simply have to live with fatal firmware errors.  Even Linux, with its
driver written by Intel engineers occasionally gets them.  So when we get one,
simply reset the chip, reload the firware and bring the interface up again.

tested by stsp@@, pascal@@
ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.25 2013/11/14 12:40:00 dlg Exp $	*/
d278 1
d283 3
@


1.25
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.24 2012/11/17 14:02:51 kettenis Exp $	*/
d254 2
a291 1
	struct task		sc_resume_t;
@


1.24
log
@Newer chips feature "advanced" bluetooth coexistence, which is why sending
them the "normal" command to configure bluetooth coexistence fails and
makes the firmware crash.  Rename the IWN_FLAG_NO_BT_COEX flag and adjust some
comments to reflect this knowledge.

ok jcs@@, mikeb@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.23 2012/11/12 00:20:41 jcs Exp $	*/
d290 1
a290 1
	struct workq_task	sc_resume_wqt;
@


1.23
log
@add IWN_FLAG_NO_BT_COEX define for previous 6235 support in if_iwn
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.22 2011/01/09 15:45:37 damien Exp $	*/
d204 1
a204 1
#define IWN_FLAG_NO_BT_COEX	(1 << 8)
@


1.22
log
@cleanup; change the way opns are attached.
include a fix for Intel Centrino Advanced-N 6250 devices
by Antonio R Nicolosi.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.21 2010/09/07 16:21:45 deraadt Exp $	*/
d204 1
@


1.21
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.20 2010/07/23 06:43:00 phessler Exp $	*/
d159 1
a159 1
struct iwn_hal {
a180 9
	int		ntxqs;
	int		ndmachnls;
	uint8_t		broadcast_id;
	int		rxonsz;
	int		schedsz;
	uint32_t	fw_text_maxsz;
	uint32_t	fw_data_maxsz;
	uint32_t	fwsz;
	bus_size_t	sched_txfact_addr;
d202 2
d206 2
a207 1
	const struct iwn_hal	*sc_hal;
d211 9
a248 2
	struct ksensordev	sensordev;
	struct ksensor		sensor;
d273 1
@


1.20
log
@Add suspend/resume logic.

based heavily on the wpi change by kettenis@@

OK deraadt@@, kettenis@@, damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.19 2010/05/05 19:47:43 damien Exp $	*/
a286 1
	void			*powerhook;
@


1.19
log
@Prevent a process from entering iwn_ioctl while another process is
tsleep'ing (for example waiting for the firmware to become alive)
in iwn_init.

I believe this might fix a crash reported by dhill@@
This is a temporary fix until I find something better that I will
apply to my other drivers that can tsleep in if_init (wpi, run etc...)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.18 2010/04/30 16:06:46 damien Exp $	*/
d288 1
@


1.18
log
@add support for firmware images in "type-length-value" format.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.17 2010/02/17 18:23:00 damien Exp $	*/
d210 1
@


1.17
log
@read calibration version from ROM and set IWN_GP_DRIVER_CALIB_VER6
bit on 6x50 if version>=6.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.16 2009/11/04 17:46:52 damien Exp $	*/
d153 1
@


1.16
log
@the hybrid 6000 series (using both internal and external power amplifiers)
never made it into production, so remove some dead code and pci ids.

inspired by a similar change to iwlwifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.15 2009/10/28 18:42:47 damien Exp $	*/
d267 1
@


1.15
log
@- use bus_space_write_1 to write to IWN_INT_PERIODIC (0x5), even though
  bus_space_write_4 worked
- store enhanced power info in softc for 6000 Series
- fix a comment, remove an unused field in softc and reorder pci ids a bit
  while i'm here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.14 2009/10/26 17:55:29 damien Exp $	*/
d208 1
a208 2
#define IWN_FLAG_HYBRID		(1 << 4)
#define IWN_FLAG_INTERNAL_PA	(1 << 5)
@


1.14
log
@update WiFi Link 6000 product ids.
fix sensitivity settings for 4965.
use different sensitivity limits for 5150 (workaround for HW bug) and 6000.
set valid Tx and Rx chains based on PCI product ids for 6000 series.
cleanup setting of critical temperature.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.13 2009/10/24 18:14:57 damien Exp $	*/
a201 1
	pcireg_t		sc_id;
d274 1
@


1.13
log
@huge diff introducing many of the recent changes made by intel to iwlwifi:
- ICT interrupts for >=5000 series (avoids reading IWN_INT which is slow)
- support v2 firmware header (including build number)
- switch to v2 firmware api (requires a firmware package upgrade)
- initial support for 1000 series and initial bits for upcoming 6000
  series (untested as hardware is not available to the general public)
- many bug fixes, including workarounds for hardware bugs

make sure to update your iwn-firmware package to iwn-firmware-5.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.12 2009/05/29 08:25:45 damien Exp $	*/
a179 1
	const struct	iwn_sensitivity_limits *limits;
d209 2
d215 2
a275 1
	uint32_t		critical_temp;
@


1.12
log
@fix confusion between number of DMA channels and number of Tx queues.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.11 2009/05/20 16:31:50 damien Exp $	*/
a161 1
	int		(*apm_init)(struct iwn_softc *);
d203 1
d208 2
a209 1
#define IWN_FLAG_FIRST_BOOT	(1 << 2)
d226 5
d262 1
d274 2
d278 3
a280 3
	uint8_t			txantmsk;
	uint8_t			rxantmsk;
	uint8_t			antmsk;
@


1.11
log
@add code to read from OTPROM (1000 and 6000 series only).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.10 2009/05/12 19:10:57 damien Exp $	*/
d183 1
@


1.10
log
@switch wpi(4) and iwn(4) over to MCLGETI.
notice that i'm not using the per-ifp mbuf accounting/mitigation yet.
for iwn(4), this means we wont' be able to support full 8KB AMSDU on
machines without an IOMMU since >4KB clusters are not guaranteed to
be physcontig.  fortunately, we can program the hardware to do 4KB
AMSDUs only.
simplify {pwi,iwn}_dma_contig_alloc while i'm here: use BUS_DMA_ZERO
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.9 2009/02/15 08:58:22 damien Exp $	*/
d206 2
a207 1
#define IWN_FLAG_FIRST_BOOT	(1 << 1)
@


1.9
log
@attach the Intel WiFi Link 100 and 6000 Series (though no firmware
is available yet.)
branch the ampdu_{tx,rx}_{start,stop} callbacks too.
remove code that is only needed for evaluation/test boards.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.8 2008/12/03 17:17:08 damien Exp $	*/
a81 2
#define IWN_RBUF_COUNT	(IWN_RX_RING_COUNT + 32)

a83 7
struct iwn_rbuf {
	struct iwn_softc	*sc;
	caddr_t			vaddr;
	bus_addr_t		paddr;
	SLIST_ENTRY(iwn_rbuf)	next;
};

d86 1
a91 1
	struct iwn_dma_info	buf_dma;
a94 2
	struct iwn_rbuf		rbuf[IWN_RBUF_COUNT];
	SLIST_HEAD(, iwn_rbuf)	freelist;
d173 2
a174 1
	void		(*tx_done)(struct iwn_softc *, struct iwn_rx_desc *);
@


1.8
log
@allow users to select a fixed rate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.7 2008/12/02 17:17:50 damien Exp $	*/
d185 1
d190 1
@


1.7
log
@Add code for 5150 support (not tested since I don't have the hardware and
because it requires a specific firmware that Intel has not released yet.)
Fix crystal calibration for 5000 Series.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.6 2008/11/19 18:52:53 damien Exp $	*/
d208 1
@


1.6
log
@For 5000 Series, store baseband calibration results sent by the
initialization firmware and send them to the runtime firmware.
This has no effect on my 5300 since the initialization firmware
does not send baseband results. This may be important for other
chips though or for future firmware revisions.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.5 2008/11/09 10:00:17 damien Exp $	*/
a188 1
	const char	*fwname;
d217 1
d249 1
a249 1
	struct iwn_calib_info	calibcmd[4];
@


1.5
log
@rework the rate coding code to get rid of the ugly {wpi,iwn}_plcp_signal()
function.  will be required for future MCS support in iwn.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.4 2008/10/22 06:25:07 damien Exp $	*/
d249 1
a249 1
	struct iwn_calib_info	calibcmd[3];
@


1.4
log
@lot of cleanup, small fixes.
prepare for future enhancements.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.3 2008/10/13 16:37:10 damien Exp $	*/
d114 1
@


1.3
log
@Almost complete rewrite of iwn(4).
Add support for Intel WiFi Link 5000 Series adapters (5100/5150/5300/5350).

Quite frankly, Intel made things unnecessarily difficult by gratuitously
changing firmware commands (adding new fields in the middle of a struct)
and some register offsets for the 5000 Series and by defining yet another
way of loading a firmware.
I had to write a hardware abstraction layer to manage those differences.

Committed over a 5300 adapter (3T3R).
Require an upgrade of the iwn-firmware package, even for 4965AGN users.
Not tested on 5100, 5150 and 5350 (test reports are more than welcomed.)
There should be no regression on the 4965AGN.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.2 2007/11/19 19:34:25 damien Exp $	*/
d184 4
d249 1
a257 1
	uint8_t			antmsk;
d273 3
@


1.2
log
@all TX rings have the same fixed size (256 entries) and this is not
configurable so simplify rings allocation a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwnvar.h,v 1.1 2007/09/06 16:37:03 damien Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007
d65 2
d99 1
d102 1
d112 2
d125 6
a130 6
	uint32_t	corr_ofdm_x1;
	uint32_t	corr_ofdm_mrc_x1;
	uint32_t	corr_ofdm_x4;
	uint32_t	corr_ofdm_mrc_x4;
	uint32_t	corr_cck_x4;
	uint32_t	corr_cck_mrc_x4;
d149 47
d207 11
a217 3
	/* shared area */
	struct iwn_dma_info	shared_dma;
	struct iwn_shared	*shared;
d219 1
a219 1
	/* "keep warm" page */
d222 1
a222 1
	/* firmware DMA transfer */
d225 2
a226 2
	/* rings */
	struct iwn_tx_ring	txq[IWN_NTXQUEUES];
d235 1
d243 3
d249 1
a249 1
	struct iwn_config	config;
d254 1
d256 5
a260 1
	struct iwn_eeprom_band	bands[IWN_NBANDS];
d265 4
@


1.1
log
@new iwn(4) driver for Intel Wireless WiFi Link 4965AGN.
no support for 802.11n functions yet (need work in net80211(9) first).
committed over my 4965AGN, with only 2 of 3 antennas plugged :-)

needs a firmware that is not freely redistributable (see man page).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 1
a74 1
	struct iwn_tx_data	*data;
a75 1
	int			count;
@

