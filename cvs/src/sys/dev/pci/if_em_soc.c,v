head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.10
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.8
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.6
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.3.0.4
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.2.0.18
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.16
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.14
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.10
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.8
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.6
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.4
	OPENBSD_5_0:1.2.0.2
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.1.0.6
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2016.01.07.04.37.53;	author dlg;	state Exp;
branches;
next	1.4;
commitid	tzVWqIOXQjQlBfSc;

1.4
date	2016.01.07.04.21.36;	author dlg;	state Exp;
branches;
next	1.3;
commitid	37DaaqmjJ4UFqRg1;

1.3
date	2015.03.18.12.04.26;	author dlg;	state Exp;
branches;
next	1.2;
commitid	Ma3Q2U1VyhQ5Z9vs;

1.2
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2009.11.25.13.28.13;	author dms;	state Exp;
branches;
next	;


desc
@@


1.5
log
@sprinkle DEVNAME
@
text
@/*	$OpenBSD: if_em_soc.c,v 1.4 2016/01/07 04:21:36 dlg Exp $	*/

/*
 * Copyright (c) 2009 Dariusz Swiderski <sfires@@sfires.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <dev/pci/if_em.h>
#include <dev/pci/if_em_hw.h>
#include <dev/pci/if_em_soc.h>
#include <dev/pci/gcu_var.h>
#include <dev/pci/gcu_reg.h>

#include "gcu.h"

void em_media_status(struct ifnet *, struct ifmediareq *);
int em_media_change(struct ifnet *);

void *
em_lookup_gcu(struct device *self)
{
#if NGCU > 0
	extern struct cfdriver gcu_cd;

	return (device_lookup(&gcu_cd, 0));
#else
	return (NULL);
#endif
}

int
em_attach_miibus(struct device *self)
{
	return 0;
}

int
gcu_miibus_readreg(struct em_hw *hw, int phy, int reg)
{
	struct em_softc *sc = (struct em_softc *)
	    ((struct em_osdep *)hw->back)->dev;
	struct gcu_softc *gcu = hw->gcu;
	uint32_t data = 0;
	uint32_t done = 0;
	int i = 0;

	if (gcu == 0)
		return 0;

	/* format the data to be written to MDIO_COMMAND_REG */
	data |= (reg << MDIO_COMMAND_PHY_REG_OFFSET);
	data |= (phy << MDIO_COMMAND_PHY_ADDR_OFFSET);
	data |= MDIO_COMMAND_GO_MASK;

	mtx_enter(&gcu->mdio_mtx);
	bus_space_write_4(gcu->tag, gcu->handle, MDIO_COMMAND_REG, data);

	while (!done && (i++ < GCU_MAX_ATTEMPTS)) {
		DELAY(GCU_CMD_DELAY);
		data = bus_space_read_4(gcu->tag, gcu->handle, 
		    MDIO_COMMAND_REG);
		done = !((data & MDIO_COMMAND_GO_MASK) >> 
		    MDIO_COMMAND_GO_OFFSET);
	}
	mtx_leave(&gcu->mdio_mtx);

	if (i >= GCU_MAX_ATTEMPTS) {
		printf("%s: phy read timeout: phy %d, reg %d\n",
		    DEVNAME(sc), phy, reg);
		return (0);
	}

	mtx_enter(&gcu->mdio_mtx);
	data = bus_space_read_4(gcu->tag, gcu->handle, MDIO_STATUS_REG);
	mtx_leave(&gcu->mdio_mtx);

	if((data & MDIO_STATUS_STATUS_MASK) != 0) {
		printf("%s: unable to read phy %d reg %d\n",
		    DEVNAME(sc), phy, reg);
		return (0);
	}
	return (uint16_t) (data & MDIO_STATUS_READ_DATA_MASK);
}

void
gcu_miibus_writereg(struct em_hw *hw, int phy, int reg, int val)
{
	struct em_softc *sc = (struct em_softc *)
	    ((struct em_osdep *)hw->back)->dev;
	struct gcu_softc *gcu = hw->gcu;
	uint32_t data, done = 0;
	int i = 0;

	if (gcu == 0)
		return;

	/* format the data to be written to the MDIO_COMMAND_REG */
	data = val;
	data |= (reg << MDIO_COMMAND_PHY_REG_OFFSET);
	data |= (phy << MDIO_COMMAND_PHY_ADDR_OFFSET);
	data |= MDIO_COMMAND_OPER_MASK | MDIO_COMMAND_GO_MASK;

	mtx_enter(&gcu->mdio_mtx);
	bus_space_write_4(gcu->tag, gcu->handle, MDIO_COMMAND_REG, data);

	while (!done && (i++ < GCU_MAX_ATTEMPTS)) {
		DELAY(GCU_CMD_DELAY);
		data = bus_space_read_4(gcu->tag, gcu->handle, 
		    MDIO_COMMAND_REG);
		done = !((data & MDIO_COMMAND_GO_MASK) >> 
		    MDIO_COMMAND_GO_OFFSET);
	}
	mtx_leave(&gcu->mdio_mtx);

	if (i >= GCU_MAX_ATTEMPTS) {
		printf("%s: phy read timeout: phy %d, reg %d\n",
		    DEVNAME(sc), phy, reg);
		return;
	}
}

void
gcu_miibus_statchg(struct device *dev)
{
}
@


1.4
log
@rename em_softc sc_dv to sc_dev. like ALL OUR OTHER DRIVERS.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_em_soc.c,v 1.3 2015/03/18 12:04:26 dlg Exp $	*/
d80 1
a80 1
		    sc->sc_dev.dv_xname, phy, reg);
d90 1
a90 1
		    sc->sc_dev.dv_xname, phy, reg);
d128 1
a128 1
		    sc->sc_dev.dv_xname, phy, reg);
@


1.3
log
@use device_lookup to find gcu0 rather than iterating over alldevs.

written at s2k15, but considered too risky before release.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_em_soc.c,v 1.2 2011/04/07 15:30:16 miod Exp $	*/
d80 1
a80 1
		    sc->sc_dv.dv_xname, phy, reg);
d90 1
a90 1
		    sc->sc_dv.dv_xname, phy, reg);
d128 1
a128 1
		    sc->sc_dv.dv_xname, phy, reg);
@


1.2
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_em_soc.c,v 1.1 2009/11/25 13:28:13 dms Exp $	*/
d22 1
a22 1
#include <dev/pci/gcu.h>
d25 2
d33 2
a34 1
	struct device *dev;
d36 4
a39 7
	INIT_DEBUGOUT("em_lookup_gcu");
	TAILQ_FOREACH(dev, &alldevs, dv_list) {
		if (strcmp(dev->dv_xname, "gcu0") == 0) {
			return dev;
		}
	}
	return 0;
@


1.1
log
@Add support for em(4) interfaces found on intel EP80579 SoC. The MAC part is
basicly 82545, but the PHY's are separated form the chip and they are accessed
through a special PCI device called GCU which has the MDIO interface. Since
there is no direct relationship between MAC and PHY, so for the moment they
are assigned to each other the way its done on Axiomtek NA-200, that was
danted to us by them.

This also adds a device driver for the GCU.

tested by me on Axiomtek board
reviewed by claudio@@, kettenis@@, deraadt@@
'commit that as is' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d35 1
a35 1
		if (strcmp(dev->dv_xname, "gcu0") == NULL) {
@

