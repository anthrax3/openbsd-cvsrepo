head	1.32;
access;
symbols
	OPENBSD_6_1:1.32.0.4
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.31.0.6
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.27.0.6
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.4
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.4
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.3.0.4
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.32
date	2016.11.21.17.21.33;	author mikeb;	state Exp;
branches;
next	1.31;
commitid	1ZsCHVQzk7OidRw1;

1.31
date	2015.12.31.19.07.37;	author kettenis;	state Exp;
branches;
next	1.30;
commitid	pcDqoxBN9zeO7DHP;

1.30
date	2015.12.18.19.08.36;	author kettenis;	state Exp;
branches;
next	1.29;
commitid	hYZ6jAF8H818qYE8;

1.29
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.28;
commitid	6vhYvh5CxZAHMnsN;

1.28
date	2015.09.11.12.09.10;	author claudio;	state Exp;
branches;
next	1.27;
commitid	CCeURkmrLTdsL7lJ;

1.27
date	2014.11.12.16.06.47;	author mikeb;	state Exp;
branches;
next	1.26;
commitid	iwiZZRLVhfz0hPwH;

1.26
date	2014.11.10.15.58.32;	author mikeb;	state Exp;
branches;
next	1.25;
commitid	fEGe9isBECvsktRN;

1.25
date	2014.07.08.05.35.18;	author dlg;	state Exp;
branches;
next	1.24;
commitid	0QJleeeWqZmC5anF;

1.24
date	2013.08.05.19.58.05;	author mikeb;	state Exp;
branches;
next	1.23;

1.23
date	2012.12.17.14.23.48;	author mikeb;	state Exp;
branches;
next	1.22;

1.22
date	2012.12.17.13.46.23;	author mikeb;	state Exp;
branches;
next	1.21;

1.21
date	2012.12.17.12.03.16;	author mikeb;	state Exp;
branches;
next	1.20;

1.20
date	2012.11.29.13.23.00;	author mikeb;	state Exp;
branches;
next	1.19;

1.19
date	2012.10.30.14.00.02;	author mikeb;	state Exp;
branches;
next	1.18;

1.18
date	2012.10.30.09.26.44;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2012.08.08.14.44.13;	author mikeb;	state Exp;
branches;
next	1.16;

1.16
date	2012.07.29.13.49.03;	author mikeb;	state Exp;
branches;
next	1.15;

1.15
date	2012.07.05.14.36.22;	author mikeb;	state Exp;
branches;
next	1.14;

1.14
date	2012.02.26.16.22.37;	author mikeb;	state Exp;
branches;
next	1.13;

1.13
date	2011.06.15.00.03.00;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2011.06.10.12.46.35;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2010.08.27.08.24.53;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2010.03.22.17.09.27;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2010.02.23.18.43.15;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.10.19.41.05;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.28.22.20.20;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.25.17.01.32;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.04.22.27.31;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2009.04.24.12.54.15;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.08.21.15.34;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.08.20.33.51;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.08.20.01.02;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Add ability to change media type

Tested with a X540 interconnected with a X550 via a CAT6 twisted
pair cable, but is expected to work on multi-speed fiber modules
as well to select between 10GbaseLR and 1000baseLX or 10GbaseSR
and 1000baseSX, etc.

This is largely required because X550 doesn't provide support for
auto-negotiation and requires manual configuration.

Obtained from FreeBSD.
@
text
@/*	$OpenBSD: if_ix.h,v 1.31 2015/12/31 19:07:37 kettenis Exp $	*/

/******************************************************************************

  Copyright (c) 2001-2012, Intel Corporation
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

   3. Neither the name of the Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

******************************************************************************/
/*$FreeBSD: src/sys/dev/ixgbe/ixgbe.h,v 1.38 2012/12/20 22:29:29 svnexp Exp $*/

#ifndef _IX_H_
#define _IX_H_

#include <dev/pci/ixgbe.h>

/* Tunables */

/*
 * TxDescriptors Valid Range: 64-4096 Default Value: 256 This value is the
 * number of transmit descriptors allocated by the driver. Increasing this
 * value allows the driver to queue more transmits. Each descriptor is 16
 * bytes. Performance tests have show the 2K value to be optimal for top
 * performance.
 */
#define DEFAULT_TXD	256
#define PERFORM_TXD	2048
#define MAX_TXD		4096
#define MIN_TXD		64

/*
 * RxDescriptors Valid Range: 64-4096 Default Value: 256 This value is the
 * number of receive descriptors allocated for each RX queue. Increasing this
 * value allows the driver to buffer more incoming packets. Each descriptor
 * is 16 bytes.  A receive buffer is also allocated for each descriptor.
 *
 * Note: with 8 rings and a dual port card, it is possible to bump up
 *	against the system mbuf pool limit, you can tune nmbclusters
 *	to adjust for this.
 */
#define DEFAULT_RXD	256
#define PERFORM_RXD	2048
#define MAX_RXD		4096
#define MIN_RXD		64

/* Alignment for rings */
#define DBA_ALIGN	128

/*
 * This parameter controls the duration of transmit watchdog timer.
 */
#define IXGBE_TX_TIMEOUT                   5	/* set to 5 seconds */

/*
 * Thise parameter controls the minimum number of available transmit
 * descriptors needed before we attempt transmission of a packet.
 */
#define IXGBE_TX_OP_THRESHOLD	(sc->num_segs + 2)

#define IXGBE_MAX_FRAME_SIZE	9216

/* Flow control constants */
#define IXGBE_FC_PAUSE		0xFFFF
#define IXGBE_FC_HI		0x20000
#define IXGBE_FC_LO		0x10000

/* Defines for printing debug information */
#define DEBUG_INIT  0
#define DEBUG_IOCTL 0
#define DEBUG_HW    0

#define INIT_DEBUGOUT(S)            if (DEBUG_INIT)  printf(S "\n")
#define INIT_DEBUGOUT1(S, A)        if (DEBUG_INIT)  printf(S "\n", A)
#define INIT_DEBUGOUT2(S, A, B)     if (DEBUG_INIT)  printf(S "\n", A, B)
#define IOCTL_DEBUGOUT(S)           if (DEBUG_IOCTL) printf(S "\n")
#define IOCTL_DEBUGOUT1(S, A)       if (DEBUG_IOCTL) printf(S "\n", A)
#define IOCTL_DEBUGOUT2(S, A, B)    if (DEBUG_IOCTL) printf(S "\n", A, B)
#define HW_DEBUGOUT(S)              if (DEBUG_HW) printf(S "\n")
#define HW_DEBUGOUT1(S, A)          if (DEBUG_HW) printf(S "\n", A)
#define HW_DEBUGOUT2(S, A, B)       if (DEBUG_HW) printf(S "\n", A, B)

#define MAX_NUM_MULTICAST_ADDRESSES     128
#define IXGBE_82598_SCATTER		100
#define IXGBE_82599_SCATTER		32
#define MSIX_82598_BAR			3
#define MSIX_82599_BAR			4
#define IXGBE_TSO_SIZE			262140
#define IXGBE_TX_BUFFER_SIZE		((uint32_t) 1514)
#define IXGBE_RX_HDR			128
#define IXGBE_VFTA_SIZE			128
#define IXGBE_BR_SIZE			4096
#define IXGBE_QUEUE_MIN_FREE		32

/*
 * Interrupt Moderation parameters
 */
#define IXGBE_INTS_PER_SEC		8000

struct ixgbe_tx_buf {
	uint32_t		eop_index;
	struct mbuf		*m_head;
	bus_dmamap_t		map;
};

struct ixgbe_rx_buf {
	struct mbuf		*buf;
	struct mbuf		*fmp;
	bus_dmamap_t		map;
};

/*
 * Bus dma allocation structure used by ixgbe_dma_malloc and ixgbe_dma_free.
 */
struct ixgbe_dma_alloc {
	caddr_t			dma_vaddr;
	bus_dma_tag_t		dma_tag;
	bus_dmamap_t		dma_map;
	bus_dma_segment_t	dma_seg;
	bus_size_t		dma_size;
	int			dma_nseg;
};

/*
 * Driver queue struct: this is the interrupt container
 *  for the associated tx and rx ring.
 */
struct ix_queue {
	struct ix_softc         *sc;
	uint32_t		msix;           /* This queue's MSIX vector */
	uint32_t		eims;           /* This queue's EIMS bit */
	uint32_t		eitr_setting;
	void			*tag;
	struct tx_ring		*txr;
	struct rx_ring		*rxr;
};

/*
 * The transmit ring, one per tx queue
 */
struct tx_ring {
	struct ix_softc		*sc;
	uint32_t		me;
	uint32_t		watchdog_timer;
	union ixgbe_adv_tx_desc	*tx_base;
	struct ixgbe_tx_buf	*tx_buffers;
	struct ixgbe_dma_alloc	txdma;
	volatile uint32_t	tx_avail;
	uint32_t		next_avail_desc;
	uint32_t		next_to_clean;
	enum {
	    IXGBE_QUEUE_IDLE,
	    IXGBE_QUEUE_WORKING,
	    IXGBE_QUEUE_HUNG,
	}			queue_status;
	uint32_t		txd_cmd;
	bus_dma_tag_t		txtag;
	uint32_t		bytes; /* Used for AIM calc */
	uint32_t		packets;
	/* Soft Stats */
	uint64_t		tx_packets;
};


/*
 * The Receive ring, one per rx queue
 */
struct rx_ring {
	struct ix_softc		*sc;
	uint32_t		me;
	union ixgbe_adv_rx_desc	*rx_base;
	struct ixgbe_dma_alloc	rxdma;
#if 0
	struct lro_ctrl		lro;
#endif
	bool			lro_enabled;
	bool			hw_rsc;
	bool			discard;
	uint			next_to_refresh;
	uint			next_to_check;
	uint			last_desc_filled;
	struct if_rxring	rx_ring;
	struct ixgbe_rx_buf	*rx_buffers;

	uint32_t		bytes; /* Used for AIM calc */
	uint32_t		packets;

	/* Soft stats */
	uint64_t		rx_irq;
	uint64_t		rx_packets;
	uint64_t		rx_bytes;
	uint64_t		rx_discarded;
	uint64_t		rsc_num;
};

/* Our adapter structure */
struct ix_softc {
	struct device		dev;
	struct arpcom		arpcom;

	struct ixgbe_hw		hw;
	struct ixgbe_osdep	osdep;

	void			*tag;

	struct ifmedia		media;
	struct timeout		timer;
	struct timeout		rx_refill;
	int			msix;
	int			if_flags;

	uint16_t		num_vlans;
	uint16_t		num_queues;

	/*
	 * Shadow VFTA table, this is needed because
	 * the real vlan filter table gets cleared during
	 * a soft reset and the driver needs to be able
	 * to repopulate it.
	 */
	uint32_t		shadow_vfta[IXGBE_VFTA_SIZE];

	/* Info about the interface */
	uint64_t		optics;
	uint32_t		fc; /* local flow ctrl setting */
	uint16_t		max_frame_size;
	uint16_t		num_segs;
	uint32_t		link_speed;
	bool			link_up;
	uint32_t		linkvec;

	/* Mbuf cluster size */
	uint32_t		rx_mbuf_sz;

	/*
	 * Queues:
	 *   This is the irq holder, it has
	 *   and RX/TX pair or rings associated
	 *   with it.
	 */
	struct ix_queue		*queues;

	/*
	 * Transmit rings:
	 *	Allocated at run time, an array of rings.
	 */
	struct tx_ring		*tx_rings;
	int			num_tx_desc;

	/*
	 * Receive rings:
	 *	Allocated at run time, an array of rings.
	 */
	struct rx_ring		*rx_rings;
	uint64_t		que_mask;
	int			num_rx_desc;

	/* Multicast array memory */
	uint8_t			*mta;

	/* Misc stats maintained by the driver */
	unsigned long		dropped_pkts;
	unsigned long		no_tx_map_avail;
	unsigned long		no_tx_dma_setup;
	unsigned long		watchdog_events;
	unsigned long		tso_tx;
	unsigned long		link_irq;

	struct ixgbe_hw_stats 	stats;
};

#endif /* _IX_H_ */
@


1.31
log
@Make ixgbe_start() mpsafe.  This means the driver will no longer grab the
kernel lock in the rx and tx path anymore.

While there seems to be a small decrease in forwarding performance with our
default network stack settings, Performance whiel receiving manymore packets
than we can handle is better.  And this change opens the road for future
improvements in the network stack.

ok dlg@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.30 2015/12/18 19:08:36 kettenis Exp $	*/
a249 1
	int			advertise;  /* link speeds */
@


1.30
log
@Make ix(4) mpsafer.  Take advantage of intr_barrier() to eliminate the mutex
introduced in the previous step, and use atomic instructions to make the
tx completion path mpsafe as well.

ok claudio@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.29 2015/09/11 13:02:28 stsp Exp $	*/
d83 1
a83 1
#define IXGBE_TX_OP_THRESHOLD		(sc->num_tx_desc / 32)
@


1.29
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.28 2015/09/11 12:09:10 claudio Exp $	*/
d80 2
a81 2
 * This parameters control when the driver calls the routine to reclaim
 * transmit descriptors.
a82 1
#define IXGBE_TX_CLEANUP_THRESHOLD	(sc->num_tx_desc / 16)
d172 1
a172 1
	volatile uint16_t	tx_avail;
a278 1
	struct mutex		rx_mtx;
@


1.28
log
@First step at making ix(4) MPSAVE. This is largely based on the em(4)
changes done by kettenis@@. Tested by Hrvoje Popovski and chris@@
dlg@@, mpi@@ and kettenis@@ agree on developping this further in tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.26 2014/11/10 15:58:32 mikeb Exp $	*/
d249 1
a249 1
	uint			optics;
@


1.27
log
@Remove SIOCSIFMTU handling and misuse of if_mtu values for MRU

Since there's now no way to select maximum receive unit size the
hardware is programmed to accept frame sizes up to 9216 which is
now the maximum (down from 15.5K since this is supposed to work
in all advanced configurations and gives slightly better flow
control watermark ranges) and split all frames larger 2K into
multiple fragments (code was already there but wasn't enabled).

Tested on 82599 (SFP+) and X540 (10GBaseT).
With input from dlg@@.
@
text
@d280 1
@


1.26
log
@remove ixgbe_sfp_probe since it's not called anyways
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.25 2014/07/08 05:35:18 dlg Exp $	*/
d86 1
a86 1
#define IXGBE_MAX_FRAME_SIZE	0x3F00
@


1.25
log
@cut things that relied on mclgeti for rx ring accounting/restriction over
to using if_rxr.

cut the reporting systat did over to the rxr ioctl.

tested as much as i can on alpha, amd64, and sparc64.
mpi@@ has run it on macppc.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.24 2013/08/05 19:58:05 mikeb Exp $	*/
a259 3

	/* Support for pluggable optics */
	bool			sfp_probe;
@


1.24
log
@First stab at updating this monster to the Intel/FreeBSD current version.
This syncs PHY and chip dependent parts as well as brings support for the
flow control and additional (untested) bits for 1G fiber versions.

Tested by Hrvoje Popovski <hrvoje at srce ! hr> on 82599/SFP+DA, florian@@
and benno@@ on 82599/SFP+SR and on 82598/CX4-BP, 82599/SFP+DA and X540/RJ45
by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.23 2012/12/17 14:23:48 mikeb Exp $	*/
d207 1
a207 1
	int			rx_ndescs;
@


1.23
log
@Catch up with upstream, where rxbuf->m_pack was renamed to rxbuf->buf
and rxbuf->pmap to rxbuf->map.  Tested on 82599 and X540.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.22 2012/12/17 13:46:23 mikeb Exp $	*/
d5 1
a5 1
  Copyright (c) 2001-2008, Intel Corporation
d35 1
a35 1
/*$FreeBSD: src/sys/dev/ixgbe/ixgbe.h,v 1.4 2008/05/16 18:46:30 jfv Exp $*/
d111 3
a113 2
#define IXGBE_MSIX_BAR			3
#define IXGBE_TSO_SIZE			65535
d115 4
a118 6
#define IXGBE_RX_HDR                    128
#define IXGBE_VFTA_SIZE                 128
#define IXGBE_BR_SIZE                   4096
#define IXGBE_QUEUE_IDLE                0
#define IXGBE_QUEUE_WORKING             1
#define IXGBE_QUEUE_HUNG                2
a124 3
/* Used for auto RX queue configuration */
extern int mp_ncpus;

d126 3
a128 3
	uint32_t	eop_index;
	struct mbuf	*m_head;
	bus_dmamap_t	map;
d132 3
a134 3
	struct mbuf	*buf;
	struct mbuf	*fmp;
	bus_dmamap_t	map;
a157 1
	/* struct resource	*res; */
a167 1
	struct mutex		tx_mtx;
a168 1
	int			queue_status;
d171 1
d173 1
d176 5
a180 2
	struct ixgbe_tx_buf	*tx_buffers;
	volatile uint16_t	tx_avail;
a194 1
	struct mutex		rx_mtx;
d201 6
a206 6
	int			lro_enabled;
	int			hw_rsc;
	int			discard;
	unsigned int		next_to_refresh;
	unsigned int		next_to_check;
	unsigned int		last_desc_filled;
d226 1
a226 1
	struct ixgbe_hw	hw;
a228 3
	/* struct resource	*pci_mem; */
	/* struct resource	*msix_mem; */

a229 1
	/* struct resource 	*res; */
a236 2
	struct mutex		core_mtx;

d250 1
d255 1
a255 1
	int			link_up;
d262 1
a262 4
	int			sfp_probe;
	workq_fn		link_task;	/* Link tasklet */
	workq_fn		mod_task;	/* SFP tasklet */
	workq_fn		msf_task;	/* Multispeed Fiber */
d276 2
a277 2
	struct tx_ring	*tx_rings;
	int		num_tx_desc;
d283 3
a285 3
	struct rx_ring	*rx_rings;
	uint64_t	que_mask;
	int		num_rx_desc;
d288 1
a288 1
	uint8_t		*mta;
d291 6
a296 6
	unsigned long   dropped_pkts;
	unsigned long   no_tx_map_avail;
	unsigned long   no_tx_dma_setup;
	unsigned long   watchdog_events;
	unsigned long   tso_tx;
	unsigned long	link_irq;
d298 1
a298 1
	struct ixgbe_hw_stats stats;
@


1.22
log
@Get rid of the split header code as it was never used in
OpenBSD and now is finally removed from the upstream.
No real functional change (we've lost some weight though).
Tested on 82599.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.21 2012/12/17 12:03:16 mikeb Exp $	*/
d136 1
a136 1
	struct mbuf	*m_pack;
d138 1
a138 1
	bus_dmamap_t	pmap;
a217 1
	uint64_t		rx_split_packets;
@


1.21
log
@Fix a link autonegotiation bug on 10GbaseT controllers and improve
link information reporting in general.  Obtained for the most part
from FreeBSD, tested by mxb at alumni ! chalmers ! se on X540 and
me on 82598 (XAUI, KR4), 82599 (SFP+) and X540 (baseT); ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.20 2012/11/29 13:23:00 mikeb Exp $	*/
a135 1
	struct mbuf	*m_head;
a137 1
	bus_dmamap_t	hmap;
a204 1
	int			hdr_split;
@


1.20
log
@make ix complile with IX_DEBUG defined, based on the patch from
mxb at alumni ! chalmers ! se.  thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.19 2012/10/30 14:00:02 mikeb Exp $	*/
a263 1
	int			link_active;
@


1.19
log
@backout previous over the m_freem contention concerns
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.17 2012/08/08 14:44:13 mikeb Exp $	*/
a307 3
	unsigned long   mbuf_defrag_failed;
	unsigned long   mbuf_header_failed;
	unsigned long   mbuf_packet_failed;
@


1.18
log
@Bump the default number of descriptors.

ok mikeb@@
@
text
@d45 1
a45 1
 * TxDescriptors Valid Range: 64-4096 Default Value: 512 This value is the
d51 1
a51 1
#define DEFAULT_TXD	512
d57 1
a57 1
 * RxDescriptors Valid Range: 64-4096 Default Value: 512 This value is the
d66 1
a66 1
#define DEFAULT_RXD	512
@


1.17
log
@We're not going to loop in the rxeof refilling our ring as it would
work against the mclgeti algorithm and besides it doesn't make any
difference if [repaired and] enabled since interrupt mitigation was
fixed some time ago.  So remove the leftovers altogether so that
nobody would be tempted to use them.

ok claudio, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.16 2012/07/29 13:49:03 mikeb Exp $	*/
d45 1
a45 1
 * TxDescriptors Valid Range: 64-4096 Default Value: 256 This value is the
d51 1
a51 1
#define DEFAULT_TXD	256
d57 1
a57 1
 * RxDescriptors Valid Range: 64-4096 Default Value: 256 This value is the
d66 1
a66 1
#define DEFAULT_RXD	256
@


1.16
log
@whitespace cleanup, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.15 2012/07/05 14:36:22 mikeb Exp $	*/
a167 1
	uint64_t		irqs;
a301 1
	uint32_t	rx_process_limit;
@


1.15
log
@enable the code that forces a cleanup if number of tx descriptors
is below the threshold.  noticed by brad.  tweak threshold values
to get a bit of a performance increase.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.14 2012/02/26 16:22:37 mikeb Exp $	*/
d5 1
a5 1
  Copyright (c) 2001-2008, Intel Corporation 
d7 2
a8 2
  
  Redistribution and use in source and binary forms, with or without 
d10 2
a11 2
  
   1. Redistributions of source code must retain the above copyright notice, 
d13 3
a15 3
  
   2. Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
d17 3
a19 3
  
   3. Neither the name of the Intel Corporation nor the names of its 
      contributors may be used to endorse or promote products derived from 
d21 1
a21 1
  
d23 8
a30 8
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
d60 3
a62 3
 * is 16 bytes.  A receive buffer is also allocated for each descriptor. 
 * 
 * Note: with 8 rings and a dual port card, it is possible to bump up 
d175 1
a175 1
        struct ix_softc		*sc;
d199 1
a199 1
        struct ix_softc		*sc;
d211 2
a212 2
        unsigned int		next_to_refresh;
        unsigned int		next_to_check;
@


1.14
log
@rather than driving the card with 16k intr/s of low latency interrupts,
rely on regular rx/tx queue interrupts moderated to 8k intr/s achieving
best performance/latency ratio.  this effectively doubles performance
on 82599.  tested on 82598 as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.13 2011/06/15 00:03:00 dlg Exp $	*/
d83 1
a83 1
#define IXGBE_TX_CLEANUP_THRESHOLD	(sc->num_tx_desc / 8)
a190 1
	uint64_t		no_desc_avail;
@


1.13
log
@if the system runs out of mbufs and cannot provide any when filling
the rx ring, schedule a timeout to keep trying until it gets some.

a timeout is used here cos the chip doesnt have a way of reporting
if its out of descriptors or when there's a ring overflow. we have
to manage that ourselves in software.

mikeb reported this issue on an ipsec gateway. ipsec would consume
all the mbufs while they were stuck in crypto waiting for the cpu
to catch up, by which time it was too late to give more to the
hardware. without any rx descriptors the chip would never interrupt
and we'd never try to fill the ring again.

the fix was tested by and is ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.12 2011/06/10 12:46:35 claudio Exp $	*/
d122 1
a122 1
 * Interrupt Moderation parameters 
d124 1
a124 4
#define IXGBE_LOW_LATENCY       128
#define IXGBE_AVE_LATENCY       400
#define IXGBE_BULK_LATENCY      1200
#define IXGBE_LINK_ITR          2000
@


1.12
log
@Monster update of ix(4). This brings ix(4) close to what is currently
in FreeBSD. This seems to fix a lot of problems on 82599 based cards
including the VLAN problems and the corrupted receives.
Putting this in now to work on it in tree since a few additional things
need to be merged. Tested by myself, deraadt@@ and jsg@@ on both 98er and
99er cards.
OK jsg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.11 2010/08/27 08:24:53 deraadt Exp $	*/
d249 1
@


1.11
log
@These do not need powerhook functions.
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.10 2010/03/22 17:09:27 jsg Exp $	*/
a41 4
#if 0
#include "tcp_lro.h"
#endif

a74 6
 * This parameter controls the maximum no of times the driver will loop in
 * the isr. Minimum Value = 1
 */
#define MAX_INTR	10

/*
d89 1
a89 1
#define IXGBE_FC_PAUSE		0x680
a111 1
#if 0
a112 3
#else
#define IXGBE_TSO_SIZE			IXGBE_MAX_FRAME_SIZE
#endif
d114 6
a119 14
#define IXGBE_RX_HDR_SIZE		((uint32_t) 256)
#define CSUM_OFFLOAD			7	/* Bits in csum flags */

/* The number of MSIX messages the 82598 supports */
#define IXGBE_MSGS			18

/* For 6.X code compatibility */
#if __FreeBSD_version < 700000
#define ETHER_BPF_MTAP		BPF_MTAP
#define CSUM_TSO		0
#define IFCAP_TSO4		0
#define FILTER_STRAY
#define FILTER_HANDLED
#endif
a122 2
 * 	for now we hardcode, later
 *	it would be nice to do dynamic
d124 4
a127 3
#define MAX_IRQ_SEC	8000
#define DEFAULT_ITR	1000000000/(MAX_IRQ_SEC * 256)
#define LINK_ITR	1000000000/(1950 * 256)
d133 1
d140 4
a143 1
	bus_dmamap_t	 map;
d159 16
d181 1
a181 2
	uint32_t		msix;
	uint32_t		eims;
a183 1
	uint32_t		*tx_hwb;
d185 2
a186 3
	struct ixgbe_dma_alloc	txwbdma;
	uint32_t		next_avail_tx_desc;
	uint32_t		next_tx_to_clean;
d191 2
d194 1
a194 3
	uint32_t		no_tx_desc_avail;
	uint32_t		no_tx_desc_late;
	uint64_t		tx_irq;
a205 3
	uint32_t		msix;
	uint32_t		eims;
	uint32_t		payload;
d211 5
a215 1
        unsigned int		last_rx_desc_filled;
d217 1
d220 4
a223 3
	bus_dma_tag_t		rxtag;
	struct mbuf		*fmp;
	struct mbuf		*lmp;
d226 5
a230 2
	uint64_t		packet_count;
	uint64_t 		byte_count;
d235 2
a236 2
	struct device		 dev;
	struct arpcom		 arpcom;
d239 7
a245 1
	struct ixgbe_osdep	 osdep;
d247 9
a255 2
	struct resource	*pci_mem;
	struct resource	*msix_mem;
d258 4
a261 3
	 * Interrupt resources:
	 *  Oplin has 20 MSIX messages
	 *  so allocate that for now.
d263 20
a282 25
	void		*tag[IXGBE_MSGS];
	struct resource *res[IXGBE_MSGS];
	int		rid[IXGBE_MSGS];
	uint32_t	eims_mask;

	struct ifmedia	media;
	struct timeout	timer;
	int		msix;
	int		if_flags;

	struct mutex	core_mtx;

	/* Legacy Fast Intr handling */
	int		sfp_probe;
	workq_fn	link_task;

	/* Info about the board itself */
	uint32_t	part_num;
	int		link_active;
	uint16_t	max_frame_size;
	uint32_t	link_speed;
	uint32_t	tx_int_delay;
	uint32_t	tx_abs_int_delay;
	uint32_t	rx_int_delay;
	uint32_t	rx_abs_int_delay;
d284 7
a290 2
	/* Indicates the cluster size to use */
	int		bigbufs;
a297 1
	int		num_tx_queues;
d304 1
a305 1
	int		num_rx_queues;
d307 3
a309 1
	uint		optics;
d313 3
a315 2
	unsigned long   mbuf_alloc_failed;
	unsigned long   mbuf_cluster_failed;
a319 1
	unsigned long	linkvec;
@


1.10
log
@Use the correct number of max scatter gather segments for 82599,
adapted from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.9 2010/02/23 18:43:15 jsg Exp $	*/
a239 1
	void			*powerhook;
@


1.9
log
@Add support for 82599 devices based on changes to the FreeBSD driver.

Tested by deraadt on a HotLava card and myself with an Intel X520
and a CX4 82598.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.8 2009/08/10 19:41:05 deraadt Exp $	*/
d119 2
a120 1
#define IXGBE_MAX_SCATTER		100
@


1.8
log
@A few more simple cases of shutdown hooks which only call xxstop, when
we now know the interface has already been stopped
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.7 2009/06/28 22:20:20 jsg Exp $	*/
d262 1
@


1.7
log
@Now the tx dma mapping problem it was exposing is fixed
bring back rev 1.16, em style MCLGETI based on a diff from reyk with
critical fixes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.6 2009/06/25 17:01:32 deraadt Exp $	*/
a239 1
	void			*shutdownhook;
@


1.6
log
@Back out if_ix.c 1.16, 1.17 and 1.18 (and corresponding changes to to
if_ix.h) since it corrupts packets or the checksum flags or something
upwards and breaks nfs.  The 1.16 MCLGETI change does not cause this
but has a double free on reboot, and the 1.18 fixes that double free
but introduces the packet corruption.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.3 2008/06/08 21:15:34 reyk Exp $	*/
d161 1
a161 3
	int		 bigbuf;
	/* one small and one large map */
	bus_dmamap_t	 map[2];
d219 1
a219 1
        unsigned int		last_cleaned;
d221 1
d223 1
a223 2
	bus_dma_tag_t		rxtag[2];
	bus_dmamap_t		spare_map[2];
@


1.5
log
@switch to a bnx style dynamic pool backed tx so we don't
have to allocate everything up front.

Requested by reyk@@, 'I'm fine with it' dlg@@, 'commit it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.4 2009/04/24 12:54:15 jsg Exp $	*/
d154 5
d161 3
a163 1
	bus_dmamap_t	 map;
a177 9
struct ix_pkt {
	TAILQ_ENTRY(ix_pkt)	 pkt_entry;
	bus_dmamap_t		 pkt_dmamap;
	struct mbuf		*pkt_mbuf;
	u_int16_t		 pkt_start_desc;
};

TAILQ_HEAD(ix_pkt_list, ix_pkt);

d194 1
a194 4
	struct mutex		tx_pkt_mtx;
	u_int			tx_pkt_count;
	struct ix_pkt_list	tx_free_pkts;
	struct ix_pkt_list	tx_used_pkts;
d221 1
a221 1
        unsigned int		last_rx_desc_filled;
a222 1
	int			rx_ndescs;
d224 2
a225 1
	bus_dma_tag_t		rxtag;
a242 4

	/* general flags */
	int			 ix_flags;
#define IX_ALLOC_PKTS_FLAG		0x01
@


1.4
log
@Switch ix over to em flavoured MCLGETI.
Initial diff from reyk with a bunch of critical fixes from me.
ok reyk@@, 'put it in when you're confident with it' dlg@@ on an earlier rev.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.3 2008/06/08 21:15:34 reyk Exp $	*/
a153 5
struct ixgbe_tx_buf {
	struct mbuf	*m_head;
	bus_dmamap_t	map;
};

d171 9
d196 4
a199 1
	struct ixgbe_tx_buf	*tx_buffers;
d248 4
@


1.3
log
@more cleanup, removed unused code. we don't do LRO/RSS yet, code can
be added later if we ever support it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.2 2008/06/08 20:33:51 reyk Exp $	*/
d161 1
a161 3
	int		 bigbuf;
	/* one small and one large map */
	bus_dmamap_t	 map[2];
d219 1
a219 1
        unsigned int		last_cleaned;
d221 1
d223 1
a223 2
	bus_dma_tag_t		rxtag[2];
	bus_dmamap_t		spare_map[2];
@


1.2
log
@replace strange Linux-style u8/u16/u32/u64/s32 integer types with the
standard C99 uint*_t/int*_t types (i don't get why these drivers
always use their own types when there is a well-defined standard).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ix.h,v 1.1 2008/06/08 20:01:02 reyk Exp $	*/
d37 2
a38 2
#ifndef _IXGBE_H_
#define _IXGBE_H_
d312 1
a312 1
#endif /* _IXGBE_H_ */
@


1.1
log
@Import ix, a driver for the Intel 82598 PCI-Express 10 Gig Ethernet Adapter,
based on Intel's ixgbe driver.

Done on borrowed hardware since Intel was too poor to give us a card.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d126 2
a127 2
#define IXGBE_TX_BUFFER_SIZE		((u32) 1514)
#define IXGBE_RX_HDR_SIZE		((u32) 256)
d161 1
a161 1
	boolean_t	bigbuf;
d163 1
a163 1
	bus_dmamap_t	map[2];
d184 4
a187 4
	u32			me;
	u32			msix;
	u32			eims;
	u32			watchdog_timer;
d189 1
a189 1
	u_int32_t		*tx_hwb;
d192 2
a193 2
	u32			next_avail_tx_desc;
	u32			next_tx_to_clean;
d195 2
a196 2
	volatile u16		tx_avail;
	u32			txd_cmd;
d199 4
a202 4
	u32			no_tx_desc_avail;
	u32			no_tx_desc_late;
	u64			tx_irq;
	u64			tx_packets;
d212 4
a215 4
	u32			me;
	u32			msix;
	u32			eims;
	u32			payload;
d229 3
a231 3
	u64			rx_irq;
	u64			packet_count;
	u64 			byte_count;
d255 1
a255 1
	u32		eims_mask;
d268 8
a275 8
	u32		part_num;
	bool		link_active;
	u16		max_frame_size;
	u32		link_speed;
	u32		tx_int_delay;
	u32		tx_abs_int_delay;
	u32		rx_int_delay;
	u32		rx_abs_int_delay;
d278 1
a278 1
	bool		bigbufs;
d295 2
a296 2
	u32		rx_process_limit;
	u_int		optics;
@

