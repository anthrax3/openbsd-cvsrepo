head	1.39;
access;
symbols
	OPENBSD_6_1:1.39.0.8
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.6
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.37.0.4
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.36.0.4
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.34.0.10
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.8
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.4
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.2
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.32.0.6
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.31.0.6
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.4
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.29.0.4
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.28.0.8
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.6
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.4
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.5.0.2
	UBC_BASE:1.5
	SMP:1.2.0.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.39
date	2015.11.28.09.42.10;	author jmatthew;	state Exp;
branches;
next	1.38;
commitid	H1hUCw2u7OaGgYvP;

1.38
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.37;
commitid	5gdEnqVoJuTuwdTu;

1.37
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.36;
commitid	p4LJxGKbi0BU2cG6;

1.36
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.35;
commitid	yM2VFFhpDTeFQlve;

1.35
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.34;
commitid	LS2TNeCue5R9L67C;

1.34
date	2012.10.16.10.58.04;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2012.09.30.02.16.17;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.15.17.54.56;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2009.07.23.19.30.42;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.19.19.00.01;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.21.22.13.36;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2006.11.25.17.47.40;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2006.11.25.02.12.04;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2006.10.15.17.20.55;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2006.10.15.14.45.03;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.10.07.17.57;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.02.02.07.11;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.17.03.03.24;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.01.19.08.57;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2005.09.30.18.59.13;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2005.09.29.20.31.38;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.01.05.45.03;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.22.03.00.39;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.20.20.50.41;	author pvalchev;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.29.23.06.55;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.20.00.31.03;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.26.20.36.41;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.15.21.35.28;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.22.20.15.28;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.28.01.04.02;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.14.02.43.56;	author drahn;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.12.13.03.51.10;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.29.06.35.59;	author art;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2001.09.21.00.01.20;	author art;	state Exp;
branches;
next	;

1.2.4.1
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.2.4.6;

1.2.4.6
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2002.01.31.22.55.35;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Rework gem_start to check that there's enough space in the ring before
dequeueing a packet, then drop the packet if it can't be sent, rather than
using two phase dequeue then commit.

Adjust sc_tx_cnt using atomic operations, take the kernel lock before
calling gem_start or gem_init from the interrupt handler, and use an
interrupt barrier when taking the interface down.

With all this done, we can mark the interrupt handler for pci (but not sbus)
attached gem(4) as mpsafe.

mpi@@ wrote this initially, I fixed bugs to keep sparc64 happy and kept it up
to date with ifq changes.

ok mpi@@ dlg@@
@
text
@/*	$OpenBSD: if_gem_pci.c,v 1.38 2015/11/24 17:11:39 mpi Exp $	*/
/*	$NetBSD: if_gem_pci.c,v 1.1 2001/09/16 00:11:42 eeh Exp $ */

/*
 *
 * Copyright (C) 2001 Eduardo Horvath.
 * All rights reserved.
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR  ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR  BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * PCI bindings for Sun GEM ethernet controllers.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/bus.h>
#include <machine/intr.h>

#ifdef __sparc64__
#include <dev/ofw/openfirm.h>
#endif

#include <dev/mii/miivar.h>
#include <dev/mii/mii_bitbang.h>

#include <dev/ic/gemreg.h>
#include <dev/ic/gemvar.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

struct gem_pci_softc {
	struct	gem_softc	gsc_gem;	/* GEM device */
	bus_space_tag_t		gsc_memt;
	bus_space_handle_t	gsc_memh;
	bus_size_t		gsc_memsize;
	pci_chipset_tag_t	gsc_pc;
};

int	gem_match_pci(struct device *, void *, void *);
void	gem_attach_pci(struct device *, struct device *, void *);
int	gem_detach_pci(struct device *, int);
int	gem_pci_enaddr(struct gem_softc *, struct pci_attach_args *);

struct cfattach gem_pci_ca = {
	sizeof(struct gem_pci_softc), gem_match_pci, gem_attach_pci,
	gem_detach_pci
};

/*
 * Attach routines need to be split out to different bus-specific files.
 */

const struct pci_matchid gem_pci_devices[] = {
	{ PCI_VENDOR_SUN, PCI_PRODUCT_SUN_ERINETWORK },
	{ PCI_VENDOR_SUN, PCI_PRODUCT_SUN_GEMNETWORK },
	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_INTREPID2_GMAC },
	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_K2_GMAC },
	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_PANGEA_GMAC },
	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_SHASTA_GMAC },
	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_UNINORTHGMAC },
	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_UNINORTH2GMAC },
};

int
gem_match_pci(struct device *parent, void *cf, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, gem_pci_devices,
	    nitems(gem_pci_devices)));
}

#define	PROMHDR_PTR_DATA	0x18
#define	PROMDATA_PTR_VPD	0x08
#define	PROMDATA_DATA2		0x0a

static const u_int8_t gem_promhdr[] = { 0x55, 0xaa };
static const u_int8_t gem_promdat[] = {
	'P', 'C', 'I', 'R',
	PCI_VENDOR_SUN & 0xff, PCI_VENDOR_SUN >> 8,
	PCI_PRODUCT_SUN_GEMNETWORK & 0xff, PCI_PRODUCT_SUN_GEMNETWORK >> 8
};

static const u_int8_t gem_promdat2[] = {
	0x18, 0x00,			/* structure length */
	0x00,				/* structure revision */
	0x00,				/* interface revision */
	PCI_SUBCLASS_NETWORK_ETHERNET,	/* subclass code */
	PCI_CLASS_NETWORK		/* class code */
};

int
gem_pci_enaddr(struct gem_softc *sc, struct pci_attach_args *pa)
{
	struct pci_vpd *vpd;
	bus_space_handle_t romh;
	bus_space_tag_t romt;
	bus_size_t romsize = 0;
	u_int8_t buf[32];
	pcireg_t address;
	int dataoff, vpdoff;
	int rv = -1;

	if (pci_mapreg_map(pa, PCI_ROM_REG, PCI_MAPREG_TYPE_MEM, 0,
	    &romt, &romh, 0, &romsize, 0))
		return (-1);

	address = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_ROM_REG);
	address |= PCI_ROM_ENABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROM_REG, address);

	bus_space_read_region_1(romt, romh, 0, buf, sizeof(buf));
	if (bcmp(buf, gem_promhdr, sizeof(gem_promhdr)))
		goto fail;

	dataoff = buf[PROMHDR_PTR_DATA] | (buf[PROMHDR_PTR_DATA + 1] << 8);
	if (dataoff < 0x1c)
		goto fail;

	bus_space_read_region_1(romt, romh, dataoff, buf, sizeof(buf));
	if (bcmp(buf, gem_promdat, sizeof(gem_promdat)) ||
	    bcmp(buf + PROMDATA_DATA2, gem_promdat2, sizeof(gem_promdat2)))
		goto fail;

	vpdoff = buf[PROMDATA_PTR_VPD] | (buf[PROMDATA_PTR_VPD + 1] << 8);
	if (vpdoff < 0x1c)
		goto fail;

	bus_space_read_region_1(romt, romh, vpdoff, buf, sizeof(buf));

	/*
	 * The VPD of gem is not in PCI 2.2 standard format.  The length
	 * in the resource header is in big endian.
	 */
	vpd = (struct pci_vpd *)(buf + 3);
	if (!PCI_VPDRES_ISLARGE(buf[0]) ||
	    PCI_VPDRES_LARGE_NAME(buf[0]) != PCI_VPDRES_TYPE_VPD)
		goto fail;
	if (vpd->vpd_key0 != 'N' || vpd->vpd_key1 != 'A')
		goto fail;

	bcopy(buf + 6, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
	rv = 0;

 fail:
	if (romsize != 0)
		bus_space_unmap(romt, romh, romsize);

	address = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_ROM_REG);
	address &= ~PCI_ROM_ENABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROM_REG, address);

	return (rv);
}

void
gem_attach_pci(struct device *parent, struct device *self, void *aux)
{
	struct pci_attach_args *pa = aux;
	struct gem_pci_softc *gsc = (void *)self;
	struct gem_softc *sc = &gsc->gsc_gem;
	pci_intr_handle_t ih;
#ifdef __sparc64__
	/* XXX the following declarations should be elsewhere */
	extern void myetheraddr(u_char *);
#endif
	const char *intrstr = NULL;
	int type, gotenaddr = 0;

	gsc->gsc_pc = pa->pa_pc;

	if (pa->pa_memt) {
		type = PCI_MAPREG_TYPE_MEM;
		sc->sc_bustag = pa->pa_memt;
	} else {
		type = PCI_MAPREG_TYPE_IO;
		sc->sc_bustag = pa->pa_iot;
	}

	sc->sc_dmatag = pa->pa_dmat;

	sc->sc_pci = 1; /* XXXXX should all be done in bus_dma. */

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_SUN_GEMNETWORK:
		sc->sc_variant = GEM_SUN_GEM;
		break;
	case PCI_PRODUCT_SUN_ERINETWORK:
		sc->sc_variant = GEM_SUN_ERI;
		break;
	case PCI_PRODUCT_APPLE_K2_GMAC:
		sc->sc_variant = GEM_APPLE_K2_GMAC;
		break;
	default:
		sc->sc_variant = GEM_APPLE_GMAC;
	}

#define PCI_GEM_BASEADDR	0x10
	if (pci_mapreg_map(pa, PCI_GEM_BASEADDR, type, 0,
	    &gsc->gsc_memt, &gsc->gsc_memh, NULL, &gsc->gsc_memsize, 0) != 0) {
		printf(": can't map registers\n");
		return;
	}

	sc->sc_bustag = gsc->gsc_memt;
	sc->sc_h1 = gsc->gsc_memh;

	if (bus_space_subregion(sc->sc_bustag, sc->sc_h1,
	    GEM_PCI_BANK2_OFFSET, GEM_PCI_BANK2_SIZE, &sc->sc_h2)) {
		printf(": unable to create bank 2 subregion\n");
		bus_space_unmap(gsc->gsc_memt, gsc->gsc_memh, gsc->gsc_memsize);
		return;
	}

	if (gem_pci_enaddr(sc, pa) == 0)
		gotenaddr = 1;

#ifdef __sparc64__
	if (!gotenaddr) {
		if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
		    sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN) <= 0)
			myetheraddr(sc->sc_arpcom.ac_enaddr);
		gotenaddr = 1;
	}
#endif
#ifdef __powerpc__
	if (!gotenaddr) {
		pci_ether_hw_addr(pa->pa_pc, sc->sc_arpcom.ac_enaddr);
		gotenaddr = 1;
	}
#endif

	sc->sc_burst = 16;	/* XXX */

	if (pci_intr_map(pa, &ih) != 0) {
		printf(": couldn't map interrupt\n");
		bus_space_unmap(gsc->gsc_memt, gsc->gsc_memh, gsc->gsc_memsize);
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	sc->sc_ih = pci_intr_establish(pa->pa_pc,
	    ih, IPL_NET | IPL_MPSAFE, gem_intr, sc, self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(gsc->gsc_memt, gsc->gsc_memh, gsc->gsc_memsize);
		return;
	}

	printf(": %s", intrstr);

	/*
	 * call the main configure
	 */
	gem_config(sc);
}

int
gem_detach_pci(struct device *self, int flags)
{
	struct gem_pci_softc *gsc = (void *)self;
	struct gem_softc *sc = &gsc->gsc_gem;

	timeout_del(&sc->sc_tick_ch);
	timeout_del(&sc->sc_rx_watchdog);

	gem_unconfig(sc);
	pci_intr_disestablish(gsc->gsc_pc, sc->sc_ih);
	bus_space_unmap(gsc->gsc_memt, gsc->gsc_memh, gsc->gsc_memsize);

	return (0);
}
@


1.38
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.37 2015/03/14 03:38:48 jsg Exp $	*/
a73 1
	void			*gsc_ih;
d277 3
a279 3
	gsc->gsc_ih = pci_intr_establish(pa->pa_pc,
	    ih, IPL_NET, gem_intr, sc, self->dv_xname);
	if (gsc->gsc_ih == NULL) {
d306 1
a306 1
	pci_intr_disestablish(gsc->gsc_pc, gsc->gsc_ih);
@


1.37
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.36 2014/12/22 02:28:52 tedu Exp $	*/
a46 1
#include <net/if_dl.h>
@


1.36
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.35 2014/12/19 22:44:58 guenther Exp $	*/
a59 1
#include <dev/mii/mii.h>
@


1.35
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.34 2012/10/16 10:58:04 jsg Exp $	*/
a49 1
#ifdef INET
a51 1
#endif
@


1.34
log
@Remove uneeded <net/bpf.h> include which was never used as it
was protected by #if NBPFILTER > 0 and "bpfilter.h" wasn't included.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.33 2012/09/30 02:16:17 brad Exp $	*/
d44 1
a44 2

#include <machine/endian.h>
@


1.33
log
@Simplify the gem(4) variant detection code a bit.

ok haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.32 2011/04/03 15:36:02 jasper Exp $	*/
a53 4
#endif

#if NBPFILTER > 0
#include <net/bpf.h>
@


1.32
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.31 2009/10/15 17:54:56 deraadt Exp $	*/
d230 2
a231 1
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SUN_GEMNETWORK)
d233 2
a234 1
	else if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SUN_ERINETWORK)
d236 5
a240 1
	else if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_APPLE_INTREPID2_GMAC)
d242 1
a242 10
	else if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_APPLE_PANGEA_GMAC)
		sc->sc_variant = GEM_APPLE_GMAC;
	else if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_APPLE_SHASTA_GMAC)
		sc->sc_variant = GEM_APPLE_GMAC;
	else if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_APPLE_UNINORTHGMAC)
		sc->sc_variant = GEM_APPLE_GMAC;
	else if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_APPLE_UNINORTH2GMAC)
		sc->sc_variant = GEM_APPLE_GMAC;
	else if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_APPLE_K2_GMAC)
		sc->sc_variant = GEM_APPLE_K2_GMAC;
@


1.31
log
@Add detach support to a few more drivers, and in others do the neccessary
operations in the detach function in the right order.  Also ensure that the
interrupt handlers not trust registers that go away.
read over very carefully by dms, tested by me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.30 2009/07/23 19:30:42 kettenis Exp $	*/
d116 1
a116 1
	    sizeof(gem_pci_devices)/sizeof(gem_pci_devices[0])));
@


1.30
log
@Use pci_mapreg_map() to map ROM.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.29 2009/03/29 21:53:52 sthen Exp $	*/
d82 1
d84 1
d89 1
d93 2
a94 1
	sizeof(struct gem_pci_softc), gem_match_pci, gem_attach_pci
a213 1
	bus_size_t size;
d216 2
d249 1
a249 1
	    &gsc->gsc_memt, &gsc->gsc_memh, NULL, &size, 0) != 0) {
d260 1
a260 1
		bus_space_unmap(gsc->gsc_memt, gsc->gsc_memh, size);
d286 1
a286 1
		bus_space_unmap(gsc->gsc_memt, gsc->gsc_memh, size);
d297 1
a297 1
		bus_space_unmap(gsc->gsc_memt, gsc->gsc_memh, size);
d307 16
@


1.29
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.28 2007/04/19 19:00:01 kettenis Exp $	*/
d140 1
a140 1
	bus_size_t romsize;
d142 1
a142 1
	pcireg_t address, mask;
d146 4
a150 2
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROM_REG, 0xfffffffe);
	mask = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_ROM_REG);
a152 7

	romt = pa->pa_memt;
	romsize = PCI_ROM_SIZE(mask);
	if (bus_space_map(romt, PCI_ROM_ADDR(address), romsize, 0, &romh)) {
		romsize = 0;
		goto fail;
	}
@


1.28
log
@Cleanup phy selection code, simplifying the code considerably.  Attach only
one phy on Sun ERI; gets rid of the duplicate phy on the blade1k.

tested by many, ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.27 2006/12/21 22:13:36 jason Exp $	*/
d250 1
a250 1
		printf(": could not map registers\n");
@


1.27
log
@betetr yet, just nuke sc_enaddr all together, just fill in arpcom and
everybody is happy
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.26 2006/11/25 17:47:40 brad Exp $	*/
d235 1
a235 3
		sc->sc_variant = GEM_APPLE_INTREPID2_GMAC;
	else if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_APPLE_K2_GMAC)
		sc->sc_variant = GEM_APPLE_K2_GMAC;
d237 1
a237 1
		sc->sc_variant = GEM_APPLE_PANGEA_GMAC;
d239 1
a239 1
		sc->sc_variant = GEM_APPLE_SHASTA_GMAC;
d241 1
a241 1
		sc->sc_variant = GEM_APPLE_UNINORTHGMAC;
d243 3
a245 1
		sc->sc_variant = GEM_APPLE_UNINORTH2GMAC;
@


1.26
log
@ANSI
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.25 2006/11/25 02:12:04 brad Exp $	*/
d189 1
a189 1
	bcopy(buf + 6, sc->sc_enaddr, ETHER_ADDR_LEN);
d270 2
a271 2
		    sc->sc_enaddr, ETHER_ADDR_LEN) <= 0)
			myetheraddr(sc->sc_enaddr);
d277 1
a277 1
		pci_ether_hw_addr(pa->pa_pc, sc->sc_enaddr);
@


1.25
log
@Split the GEM registers into two halfs and provide a bus_space_handle_t
for each. While there, fix a typo in gem_bitwait().

From martin@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.24 2006/10/15 17:20:55 kettenis Exp $	*/
d109 1
a109 4
gem_match_pci(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
d204 1
a204 3
gem_attach_pci(parent, self, aux)
	struct device *parent, *self;
	void *aux;
@


1.24
log
@Fix last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.23 2006/10/15 14:45:03 kettenis Exp $	*/
d255 1
a255 1
		printf(": could not map gem registers\n");
d260 8
a267 1
	sc->sc_h = gsc->gsc_memh;
@


1.23
log
@Get MAC address from VPD, just like we already do for hme(4).

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.22 2006/04/10 07:17:57 brad Exp $	*/
d270 2
a271 1
		gotenaddr
@


1.22
log
@recognize the Intrepid 2 GMAC
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.21 2005/11/02 02:07:11 brad Exp $	*/
d87 1
d118 88
d221 1
a221 1
	int type;
d262 3
d266 5
a270 3
	if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
	    sc->sc_enaddr, ETHER_ADDR_LEN) <= 0)
		myetheraddr(sc->sc_enaddr);
d272 5
a276 2
#ifdef __powerpc__ 
        pci_ether_hw_addr(pa->pa_pc, sc->sc_enaddr);
@


1.21
log
@- unmap resources allocated by pci_mapreg_map() on failure to attach
- fixup PCI interrupt string printing and surrounding code to be more
  consistent with other drivers
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.20 2005/10/17 03:03:24 brad Exp $	*/
d99 1
d150 2
@


1.20
log
@Start using the unused sc_variant to identify the GMAC vendor and chipset
model to the MI part of the driver. On Apple systems only attach the PHY to
location 0, unless using a K2 GMAC, then use location 1.

Tested by drahn@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.19 2005/10/01 19:08:57 brad Exp $	*/
d124 1
a124 1
	pci_intr_handle_t intrhandle;
d129 2
a130 1
	const char *intrstr;
d162 1
a162 2
	    &gsc->gsc_memt, &gsc->gsc_memh, NULL, NULL, 0) != 0)
	{
d181 1
a181 1
	if (pci_intr_map(pa, &intrhandle) != 0) {
d183 2
a184 1
		return;	/* bus_unmap ? */
d186 1
a186 1
	intrstr = pci_intr_string(pa->pa_pc, intrhandle);
d188 2
a189 4
	    intrhandle, IPL_NET, gem_intr, sc, self->dv_xname);
	if (gsc->gsc_ih != NULL) {
		printf(": %s", intrstr ? intrstr : "unknown interrupt");
	} else {
d194 2
a195 1
		return;	/* bus_unmap ? */
d197 2
@


1.19
log
@update names.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.18 2005/09/30 18:59:13 kettenis Exp $	*/
d143 15
@


1.18
log
@Add support for K2 GMAC.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.17 2005/09/29 20:31:38 kettenis Exp $	*/
a98 3
	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_GMAC },
	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_GMAC2 },
	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_GMAC3 },
d100 4
a103 1
	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_SHASTA_GMAC }
@


1.17
log
@Add support for Shasta GMAC.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.16 2005/08/01 05:45:03 brad Exp $	*/
d102 1
@


1.16
log
@remove whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.15 2005/04/22 03:00:39 brad Exp $	*/
d102 1
@


1.15
log
@sparc -> sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.14 2004/06/20 20:50:41 pvalchev Exp $	*/
d5 1
a5 1
 * 
d18 1
a18 1
 *  
d38 1
a38 1
#include <sys/systm.h> 
d56 1
a56 1
#if NBPFILTER > 0 
d58 1
a58 1
#endif 
d167 1
a167 1
	}	
@


1.14
log
@take 2 times less room in dmesg, prettier too
allocate interrupts early on (before PHY attachment, etc) just like all
other drivers do to allow the above; ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.13 2003/12/29 23:06:55 brad Exp $	*/
d123 1
a123 1
#ifdef __sparc__
d153 1
a153 1
#ifdef __sparc__
@


1.13
log
@no vtophys(), don't need uvm_extern.h anymore.

tested on alpha, i386, macppc and sparc64.

ok millert@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.12 2002/11/20 00:31:03 jason Exp $	*/
a163 6
	printf("\n");
	/*
	 * call the main configure
	 */
	gem_config(sc);

d165 1
a165 2
		printf("%s: couldn't map interrupt\n",
		    sc->sc_dev.dv_xname);
d172 1
a172 3
		printf("%s: using %s for interrupt\n",
		    sc->sc_dev.dv_xname,
		    intrstr ? intrstr : "unknown interrupt");
d174 1
a174 2
		printf("%s: couldn't establish interrupt",
		    sc->sc_dev.dv_xname);
d180 5
@


1.12
log
@Grrr, missed this in the pci id match
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.11 2002/11/19 18:40:17 jason Exp $	*/
a46 2
#include <uvm/uvm_extern.h>
 
@


1.11
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.10 2002/07/26 20:36:41 drahn Exp $	*/
d104 1
@


1.10
log
@Recognize additional gem pci id, from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.9 2002/03/15 21:35:28 jason Exp $	*/
d98 7
d111 2
a112 14
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SUN && 
	       (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SUN_ERINETWORK ||
		PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SUN_GEMNETWORK))
		return (1);

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_APPLE && 
	       (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_APPLE_GMAC ||
		PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_APPLE_GMAC2 ||
		PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_APPLE_GMAC3))
		return (1);

	return (0);
@


1.9
log
@Try 'local-mac-address' before myetheraddr().  This allows us to correctly
get the mac address on the second ethernet of a Netra T1 AC200; tested by
Joey Coleman <joeycoleman@@acm.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.8 2002/03/14 01:26:58 millert Exp $	*/
d113 2
a114 1
		PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_APPLE_GMAC2))
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.7 2002/02/22 20:15:28 jason Exp $	*/
d65 4
a157 8
#if 0
/* SBUS compatible stuff? */
	sc->sc_seb = gsc->gsc_memh;
	sc->sc_etx = gsc->gsc_memh + 0x2000;
	sc->sc_erx = gsc->gsc_memh + 0x4000;
	sc->sc_mac = gsc->gsc_memh + 0x6000;
	sc->sc_mif = gsc->gsc_memh + 0x7000;
#endif
d159 3
a161 1
	myetheraddr(sc->sc_enaddr);
@


1.7
log
@Revert to previous (non hacked =) version now that the iommu is handled
correctly and it doesn't crash
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.5 2001/12/14 02:43:56 drahn Exp $	*/
d83 2
a84 2
int	gem_match_pci __P((struct device *, void *, void *));
void	gem_attach_pci __P((struct device *, struct device *, void *));
d126 1
a126 1
	extern void myetheraddr __P((u_char *));
@


1.6
log
@Re-port the NetBSD driver, but rewrite tx logic to use static buffers (and
copies).  This makes the Blade100 gem stable for me.
@
text
@a129 1
	char enaddr[ETHER_ADDR_LEN];
d154 8
d163 1
a163 1
	myetheraddr(enaddr);
d166 1
a166 1
        pci_ether_hw_addr(pa->pa_pc, enaddr);
d169 2
d175 1
a175 1
	gem_attach(sc, enaddr);
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d130 1
a154 8
#if 0
/* SBUS compatible stuff? */
	sc->sc_seb = gsc->gsc_memh;
	sc->sc_etx = gsc->gsc_memh + 0x2000;
	sc->sc_erx = gsc->gsc_memh + 0x4000;
	sc->sc_mac = gsc->gsc_memh + 0x6000;
	sc->sc_mif = gsc->gsc_memh + 0x7000;
#endif
d156 1
a156 1
	myetheraddr(sc->sc_enaddr);
d159 1
a159 1
        pci_ether_hw_addr(pa->pa_pc, sc->sc_enaddr);
a161 2
	sc->sc_burst = 16;	/* XXX */

d166 1
a166 1
	gem_config(sc);
@


1.5.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.6 2002/01/28 01:04:02 jason Exp $	*/
a129 1
	char enaddr[ETHER_ADDR_LEN];
d154 8
d163 1
a163 1
	myetheraddr(enaddr);
d166 1
a166 1
        pci_ether_hw_addr(pa->pa_pc, enaddr);
d169 2
d175 1
a175 1
	gem_attach(sc, enaddr);
@


1.5.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.5.2.1 2002/01/31 22:55:35 niklas Exp $	*/
a64 4
#ifdef __sparc64__
#include <dev/ofw/openfirm.h>
#endif

d83 2
a84 2
int	gem_match_pci(struct device *, void *, void *);
void	gem_attach_pci(struct device *, struct device *, void *);
d126 1
a126 1
	extern void myetheraddr(u_char *);
d130 1
d156 1
a156 3
	if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
	    sc->sc_enaddr, ETHER_ADDR_LEN) <= 0)
		myetheraddr(sc->sc_enaddr);
d159 1
a159 1
        pci_ether_hw_addr(pa->pa_pc, sc->sc_enaddr);
a161 2
	sc->sc_burst = 16;	/* XXX */

d166 1
a166 1
	gem_config(sc);
@


1.5.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_gem_pci.c,v 1.5.2.2 2002/06/11 03:42:25 art Exp $	*/
d113 1
a113 2
		PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_APPLE_GMAC2 ||
		PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_APPLE_GMAC3))
@


1.5.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a97 8
const struct pci_matchid gem_pci_devices[] = {
	{ PCI_VENDOR_SUN, PCI_PRODUCT_SUN_ERINETWORK },
	{ PCI_VENDOR_SUN, PCI_PRODUCT_SUN_GEMNETWORK },
	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_GMAC },
	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_GMAC2 },
	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_GMAC3 },
};

d104 14
a117 2
	return (pci_matchbyid((struct pci_attach_args *)aux, gem_pci_devices,
	    sizeof(gem_pci_devices)/sizeof(gem_pci_devices[0])));
@


1.4
log
@changes to work with 32bit platforms and get ethernet address on powerpc.
Inspired by NetBSD.
@
text
@d1 1
@


1.3
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d164 3
@


1.2
log
@Pretty the printout (don't know if it's right, but it does the job).
@
text
@a45 1
#include <vm/vm.h>
@


1.2.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.2.4.2
log
@Merge in -current
@
text
@d46 1
@


1.2.4.3
log
@Merge in trunk
@
text
@a0 1
/*	$OpenBSD$	*/
a162 3
#endif
#ifdef __powerpc__ 
        pci_ether_hw_addr(pa->pa_pc, sc->sc_enaddr);
@


1.2.4.4
log
@Merge in -current from roughly a week ago
@
text
@a64 4
#ifdef __sparc64__
#include <dev/ofw/openfirm.h>
#endif

d83 2
a84 2
int	gem_match_pci(struct device *, void *, void *);
void	gem_attach_pci(struct device *, struct device *, void *);
d126 1
a126 1
	extern void myetheraddr(u_char *);
d154 8
d163 1
a163 3
	if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
	    sc->sc_enaddr, ETHER_ADDR_LEN) <= 0)
		myetheraddr(sc->sc_enaddr);
@


1.2.4.5
log
@Sync the SMP branch with 3.3
@
text
@a97 8
const struct pci_matchid gem_pci_devices[] = {
	{ PCI_VENDOR_SUN, PCI_PRODUCT_SUN_ERINETWORK },
	{ PCI_VENDOR_SUN, PCI_PRODUCT_SUN_GEMNETWORK },
	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_GMAC },
	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_GMAC2 },
	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_GMAC3 },
};

d104 13
a116 2
	return (pci_matchbyid((struct pci_attach_args *)aux, gem_pci_devices,
	    sizeof(gem_pci_devices)/sizeof(gem_pci_devices[0])));
@


1.2.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d47 2
@


1.1
log
@Driver for Sun GEM ethernet. Not ready yet.
From NetBSD
@
text
@d168 1
@

