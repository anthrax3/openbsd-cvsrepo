head	1.38;
access;
symbols
	OPENBSD_6_1:1.38.0.34
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.38.0.32
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.20
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.38.0.28
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.26
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.38.0.24
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.22
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.38.0.18
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.16
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.14
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.12
	OPENBSD_5_0:1.38.0.10
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.8
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.6
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.38.0.4
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.37.0.18
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.37.0.16
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.37.0.14
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.37.0.12
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.37.0.10
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.37.0.8
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.37.0.6
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.37.0.4
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.37.0.2
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.36.0.2
	OPENBSD_3_6_BASE:1.36
	SMP_SYNC_A:1.36
	SMP_SYNC_B:1.36
	OPENBSD_3_5:1.35.0.4
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.35.0.2
	OPENBSD_3_4_BASE:1.35
	UBC_SYNC_A:1.34
	OPENBSD_3_3:1.34.0.8
	OPENBSD_3_3_BASE:1.34
	OPENBSD_3_2:1.34.0.6
	OPENBSD_3_2_BASE:1.34
	OPENBSD_3_1:1.34.0.4
	OPENBSD_3_1_BASE:1.34
	UBC_SYNC_B:1.34
	UBC:1.34.0.2
	UBC_BASE:1.34
	OPENBSD_3_0:1.31.0.2
	OPENBSD_3_0_BASE:1.31
	SMP:1.22.0.2
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2;
locks; strict;
comment	@ * @;


1.38
date	2009.03.24.11.12.10;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2004.11.16.23.39.56;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.31.19.25.00;	author mcbride;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.04.19.36.33;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2001.11.02.19.31.00;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	2001.10.29.22.32.56;	author jason;	state Exp;
branches;
next	1.31;

1.31
date	2001.08.24.21.11.14;	author jason;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.23.04.18.02;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.22.20.51.04;	author jason;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.30.14.41.59;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.30.04.49.33;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.30.04.26.55;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.16.14.34.30;	author fgsch;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.15.14.57.28;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.15.05.18.13;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.09.02.25.09;	author jason;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.05.08.03.52.43;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.03.05.22.51;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.02.15.00.34;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.30.05.04.08;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.15.21.03.22;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.13.17.50.30;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.12.22.40.12;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.12.15.01.19;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.11.16.22.38;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.10.22.10.09;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.10.19.52.38;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.09.22.05.00;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.09.05.36.17;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.09.04.09.18;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.09.03.15.47;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.08.21.47.45;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.08.19.25.29;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.08.19.16.50;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.08.18.26.38;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.08.05.28.50;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.08.02.16.52;	author jason;	state Exp;
branches;
next	;

1.22.2.1
date	2001.05.14.22.25.48;	author niklas;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2001.07.04.10.42.27;	author niklas;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.22.2.5;

1.22.2.5
date	2003.06.07.11.02.30;	author ho;	state Exp;
branches;
next	1.22.2.6;

1.22.2.6
date	2004.06.05.23.12.51;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Upgrade to newer firmware needed by some txp(4) variants.  Fixes PR 6085.
From FreeBSD.

ok deraadt@@
@
text
@/*	$OpenBSD: if_txpreg.h,v 1.37 2004/11/16 23:39:56 jason Exp $ */

/*
 * Copyright (c) 2001 Aaron Campbell <aaron@@monkey.org>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#define	TXP_PCI_LOMEM			0x14	/* pci conf, memory map BAR */
#define	TXP_PCI_LOIO			0x10	/* pci conf, IO map BAR */

/*
 * Typhoon registers.
 */
#define	TXP_SRR				0x00	/* soft reset register */
#define	TXP_ISR				0x04	/* interrupt status register */
#define	TXP_IER				0x08	/* interrupt enable register */
#define	TXP_IMR				0x0c	/* interrupt mask register */
#define	TXP_SIR				0x10	/* self interrupt register */
#define	TXP_H2A_7			0x14	/* host->arm comm 7 */
#define	TXP_H2A_6			0x18	/* host->arm comm 6 */
#define	TXP_H2A_5			0x1c	/* host->arm comm 5 */
#define	TXP_H2A_4			0x20	/* host->arm comm 4 */
#define	TXP_H2A_3			0x24	/* host->arm comm 3 */
#define	TXP_H2A_2			0x28	/* host->arm comm 2 */
#define	TXP_H2A_1			0x2c	/* host->arm comm 1 */
#define	TXP_H2A_0			0x30	/* host->arm comm 0 */
#define	TXP_A2H_3			0x34	/* arm->host comm 3 */
#define	TXP_A2H_2			0x38	/* arm->host comm 2 */
#define	TXP_A2H_1			0x3c	/* arm->host comm 1 */
#define	TXP_A2H_0			0x40	/* arm->host comm 0 */

/*
 * interrupt bits (IMR, ISR, IER)
 */
#define	TXP_INT_RESERVED	0xffff0000
#define	TXP_INT_A2H_7		0x00008000	/* arm->host comm 7 */
#define	TXP_INT_A2H_6		0x00004000	/* arm->host comm 6 */
#define	TXP_INT_A2H_5		0x00002000	/* arm->host comm 5 */
#define	TXP_INT_A2H_4		0x00001000	/* arm->host comm 4 */
#define	TXP_INT_SELF		0x00000800	/* self interrupt */
#define	TXP_INT_PCI_TABORT	0x00000400	/* pci target abort */
#define	TXP_INT_PCI_MABORT	0x00000200	/* pci master abort */
#define	TXP_INT_DMA3		0x00000100	/* dma3 done */
#define	TXP_INT_DMA2		0x00000080	/* dma2 done */
#define	TXP_INT_DMA1		0x00000040	/* dma1 done */
#define	TXP_INT_DMA0		0x00000020	/* dma0 done */
#define	TXP_INT_A2H_3		0x00000010	/* arm->host comm 3 */
#define	TXP_INT_A2H_2		0x00000008	/* arm->host comm 2 */
#define	TXP_INT_A2H_1		0x00000004	/* arm->host comm 1 */
#define	TXP_INT_A2H_0		0x00000002	/* arm->host comm 0 */
#define	TXP_INT_LATCH		0x00000001	/* interrupt latch */

/*
 * soft reset register (SRR)
 */
#define	TXP_SRR_ALL		0x0000007f	/* full reset */

/*
 * Typhoon boot commands.
 */
#define	TXP_BOOTCMD_NULL			0x00
#define	TXP_BOOTCMD_DOWNLOAD_COMPLETE		0xfb
#define	TXP_BOOTCMD_SEGMENT_AVAILABLE		0xfc
#define	TXP_BOOTCMD_RUNTIME_IMAGE		0xfd
#define	TXP_BOOTCMD_REGISTER_BOOT_RECORD	0xff

/*
 * Typhoon runtime commands.
 */
#define	TXP_CMD_GLOBAL_RESET			0x00
#define	TXP_CMD_TX_ENABLE			0x01
#define	TXP_CMD_TX_DISABLE			0x02
#define	TXP_CMD_RX_ENABLE			0x03
#define	TXP_CMD_RX_DISABLE			0x04
#define	TXP_CMD_RX_FILTER_WRITE			0x05
#define	TXP_CMD_RX_FILTER_READ			0x06
#define	TXP_CMD_READ_STATISTICS			0x07
#define	TXP_CMD_CYCLE_STATISTICS		0x08
#define	TXP_CMD_CLEAR_STATISTICS		0x09
#define	TXP_CMD_MEMORY_READ			0x0a
#define	TXP_CMD_MEMORY_WRITE_SINGLE		0x0b
#define	TXP_CMD_VARIABLE_SECTION_READ		0x0c
#define	TXP_CMD_VARIABLE_SECTION_WRITE		0x0d
#define	TXP_CMD_STATIC_SECTION_READ		0x0e
#define	TXP_CMD_STATIC_SECTION_WRITE		0x0f
#define	TXP_CMD_IMAGE_SECTION_PROGRAM		0x10
#define	TXP_CMD_NVRAM_PAGE_READ			0x11
#define	TXP_CMD_NVRAM_PAGE_WRITE		0x12
#define	TXP_CMD_XCVR_SELECT			0x13
#define	TXP_CMD_TEST_MUX			0x14
#define	TXP_CMD_PHYLOOPBACK_ENABLE		0x15
#define	TXP_CMD_PHYLOOPBACK_DISABLE		0x16
#define	TXP_CMD_MAC_CONTROL_READ		0x17
#define	TXP_CMD_MAC_CONTROL_WRITE		0x18
#define	TXP_CMD_MAX_PKT_SIZE_READ		0x19
#define	TXP_CMD_MAX_PKT_SIZE_WRITE		0x1a
#define	TXP_CMD_MEDIA_STATUS_READ		0x1b
#define	TXP_CMD_MEDIA_STATUS_WRITE		0x1c
#define	TXP_CMD_NETWORK_DIAGS_READ		0x1d
#define	TXP_CMD_NETWORK_DIAGS_WRITE		0x1e
#define	TXP_CMD_PHY_MGMT_READ			0x1f
#define	TXP_CMD_PHY_MGMT_WRITE			0x20
#define	TXP_CMD_VARIABLE_PARAMETER_READ		0x21
#define	TXP_CMD_VARIABLE_PARAMETER_WRITE	0x22
#define	TXP_CMD_GOTO_SLEEP			0x23
#define	TXP_CMD_FIREWALL_CONTROL		0x24
#define	TXP_CMD_MCAST_HASH_MASK_WRITE		0x25
#define	TXP_CMD_STATION_ADDRESS_WRITE		0x26
#define	TXP_CMD_STATION_ADDRESS_READ		0x27
#define	TXP_CMD_STATION_MASK_WRITE		0x28
#define	TXP_CMD_STATION_MASK_READ		0x29
#define	TXP_CMD_VLAN_ETHER_TYPE_READ		0x2a
#define	TXP_CMD_VLAN_ETHER_TYPE_WRITE		0x2b
#define	TXP_CMD_VLAN_MASK_READ			0x2c
#define	TXP_CMD_VLAN_MASK_WRITE			0x2d
#define	TXP_CMD_BCAST_THROTTLE_WRITE		0x2e
#define	TXP_CMD_BCAST_THROTTLE_READ		0x2f
#define	TXP_CMD_DHCP_PREVENT_WRITE		0x30
#define	TXP_CMD_DHCP_PREVENT_READ		0x31
#define	TXP_CMD_RECV_BUFFER_CONTROL		0x32
#define	TXP_CMD_SOFTWARE_RESET			0x33
#define	TXP_CMD_CREATE_SA			0x34
#define	TXP_CMD_DELETE_SA			0x35
#define	TXP_CMD_ENABLE_RX_IP_OPTION		0x36
#define	TXP_CMD_RANDOM_NUMBER_CONTROL		0x37
#define	TXP_CMD_RANDOM_NUMBER_READ		0x38
#define	TXP_CMD_MATRIX_TABLE_MODE_WRITE		0x39
#define	TXP_CMD_MATRIX_DETAIL_READ		0x3a
#define	TXP_CMD_FILTER_ARRAY_READ		0x3b
#define	TXP_CMD_FILTER_DETAIL_READ		0x3c
#define	TXP_CMD_FILTER_TABLE_MODE_WRITE		0x3d
#define	TXP_CMD_FILTER_TCL_WRITE		0x3e
#define	TXP_CMD_FILTER_TBL_READ			0x3f
#define	TXP_CMD_VERSIONS_READ			0x43
#define	TXP_CMD_FILTER_DEFINE			0x45
#define	TXP_CMD_ADD_WAKEUP_PKT			0x46
#define	TXP_CMD_ADD_SLEEP_PKT			0x47
#define	TXP_CMD_ENABLE_SLEEP_EVENTS		0x48
#define	TXP_CMD_ENABLE_WAKEUP_EVENTS		0x49
#define	TXP_CMD_GET_IP_ADDRESS			0x4a
#define	TXP_CMD_READ_PCI_REG			0x4c
#define	TXP_CMD_WRITE_PCI_REG			0x4d
#define	TXP_CMD_OFFLOAD_READ			0x4e
#define	TXP_CMD_OFFLOAD_WRITE			0x4f
#define	TXP_CMD_HELLO_RESPONSE			0x57
#define	TXP_CMD_ENABLE_RX_FILTER		0x58
#define	TXP_CMD_RX_FILTER_CAPABILITY		0x59
#define	TXP_CMD_HALT				0x5d
#define	TXP_CMD_READ_IPSEC_INFO			0x54
#define	TXP_CMD_GET_IPSEC_ENABLE		0x67
#define	TXP_CMD_INVALID				0xffff

#define	TXP_FRAGMENT		0x0000
#define	TXP_TXFRAME		0x0001
#define	TXP_COMMAND		0x0002
#define	TXP_OPTION		0x0003
#define	TXP_RECEIVE		0x0004
#define	TXP_RESPONSE		0x0005

#define	TXP_TYPE_IPSEC		0x0000
#define	TXP_TYPE_TCPSEGMENT	0x0001

#define	TXP_PFLAG_NOCRC		0x0001
#define	TXP_PFLAG_IPCKSUM	0x0002
#define	TXP_PFLAG_TCPCKSUM	0x0004
#define	TXP_PFLAG_TCPSEGMENT	0x0008
#define	TXP_PFLAG_INSERTVLAN	0x0010
#define	TXP_PFLAG_IPSEC		0x0020
#define	TXP_PFLAG_PRIORITY	0x0040
#define	TXP_PFLAG_UDPCKSUM	0x0080
#define	TXP_PFLAG_PADFRAME	0x0100

#define	TXP_MISC_FIRSTDESC	0x0000
#define	TXP_MISC_LASTDESC	0x0001

#define	TXP_ERR_INTERNAL	0x0000
#define	TXP_ERR_FIFOUNDERRUN	0x0001
#define	TXP_ERR_BADSSD		0x0002
#define	TXP_ERR_RUNT		0x0003
#define	TXP_ERR_CRC		0x0004
#define	TXP_ERR_OVERSIZE	0x0005
#define	TXP_ERR_ALIGNMENT	0x0006
#define	TXP_ERR_DRIBBLEBIT	0x0007

#define	TXP_PROTO_UNKNOWN	0x0000
#define	TXP_PROTO_IP		0x0001
#define	TXP_PROTO_IPX		0x0002
#define	TXP_PROTO_RESERVED	0x0003

#define	TXP_STAT_PROTO		0x0001
#define	TXP_STAT_VLAN		0x0002
#define	TXP_STAT_IPFRAGMENT	0x0004
#define	TXP_STAT_IPSEC		0x0008
#define	TXP_STAT_IPCKSUMBAD	0x0010
#define	TXP_STAT_TCPCKSUMBAD	0x0020
#define	TXP_STAT_UDPCKSUMBAD	0x0040
#define	TXP_STAT_IPCKSUMGOOD	0x0080
#define	TXP_STAT_TCPCKSUMGOOD	0x0100
#define	TXP_STAT_UDPCKSUMGOOD	0x0200

struct txp_tx_desc {
	volatile u_int8_t	tx_flags;	/* type/descriptor flags */
	volatile u_int8_t	tx_numdesc;	/* number of descriptors */
	volatile u_int16_t	tx_totlen;	/* total packet length */
	volatile u_int32_t	tx_addrlo;	/* virt addr low word */
	volatile u_int32_t	tx_addrhi;	/* virt addr high word */
	volatile u_int32_t	tx_pflags;	/* processing flags */
};
#define	TX_FLAGS_TYPE_M		0x07		/* type mask */
#define	TX_FLAGS_TYPE_FRAG	0x00		/* type: fragment */
#define	TX_FLAGS_TYPE_DATA	0x01		/* type: data frame */
#define	TX_FLAGS_TYPE_CMD	0x02		/* type: command frame */
#define	TX_FLAGS_TYPE_OPT	0x03		/* type: options */
#define	TX_FLAGS_TYPE_RX	0x04		/* type: command */
#define	TX_FLAGS_TYPE_RESP	0x05		/* type: response */
#define	TX_FLAGS_RESP		0x40		/* response requested */
#define	TX_FLAGS_VALID		0x80		/* valid descriptor */

#define	TX_PFLAGS_DNAC		0x00000001	/* do not add crc */
#define	TX_PFLAGS_IPCKSUM	0x00000002	/* ip checksum */
#define	TX_PFLAGS_TCPCKSUM	0x00000004	/* tcp checksum */
#define	TX_PFLAGS_TCPSEG	0x00000008	/* tcp segmentation */
#define	TX_PFLAGS_VLAN		0x00000010	/* insert vlan */
#define	TX_PFLAGS_IPSEC		0x00000020	/* perform ipsec */
#define	TX_PFLAGS_PRIO		0x00000040	/* priority field valid */
#define	TX_PFLAGS_UDPCKSUM	0x00000080	/* udp checksum */
#define	TX_PFLAGS_PADFRAME	0x00000100	/* pad frame */
#define	TX_PFLAGS_VLANTAG_M	0x0ffff000	/* vlan tag mask */
#define	TX_PFLAGS_VLANPRI_M	0x00700000	/* vlan priority mask */
#define	TX_PFLAGS_VLANTAG_S	12		/* amount to shift tag */

struct txp_rx_desc {
	volatile u_int8_t	rx_flags;	/* type/descriptor flags */
	volatile u_int8_t	rx_numdesc;	/* number of descriptors */
	volatile u_int16_t	rx_len;		/* frame length */
	volatile u_int32_t	rx_vaddrlo;	/* virtual address, lo word */
	volatile u_int32_t	rx_vaddrhi;	/* virtual address, hi word */
	volatile u_int32_t	rx_stat;	/* status */
	volatile u_int16_t	rx_filter;	/* filter status */
	volatile u_int16_t	rx_hash;	/* hash status */
	volatile u_int32_t	rx_vlan;	/* vlan tag/priority */
};

/* txp_rx_desc.rx_flags */
#define	RX_FLAGS_TYPE_M		0x07		/* type mask */
#define	RX_FLAGS_TYPE_FRAG	0x00		/* type: fragment */
#define	RX_FLAGS_TYPE_DATA	0x01		/* type: data frame */
#define	RX_FLAGS_TYPE_CMD	0x02		/* type: command frame */
#define	RX_FLAGS_TYPE_OPT	0x03		/* type: options */
#define	RX_FLAGS_TYPE_RX	0x04		/* type: command */
#define	RX_FLAGS_TYPE_RESP	0x05		/* type: response */
#define	RX_FLAGS_RCV_TYPE_M	0x18		/* rcvtype mask */
#define	RX_FLAGS_RCV_TYPE_RX	0x00		/* rcvtype: receive */
#define	RX_FLAGS_RCV_TYPE_RSP	0x08		/* rcvtype: response */
#define	RX_FLAGS_ERROR		0x40		/* error in packet */

/* txp_rx_desc.rx_stat (if rx_flags & RX_FLAGS_ERROR bit set) */
#define	RX_ERROR_ADAPTER	0x00000000	/* adapter internal error */
#define	RX_ERROR_FIFO		0x00000001	/* fifo underrun */
#define	RX_ERROR_BADSSD		0x00000002	/* bad ssd */
#define	RX_ERROR_RUNT		0x00000003	/* runt packet */
#define	RX_ERROR_CRC		0x00000004	/* bad crc */
#define	RX_ERROR_OVERSIZE	0x00000005	/* oversized packet */
#define	RX_ERROR_ALIGN		0x00000006	/* alignment error */
#define	RX_ERROR_DRIBBLE	0x00000007	/* dribble bit */

/* txp_rx_desc.rx_stat (if rx_flags & RX_FLAGS_ERROR not bit set) */
#define	RX_STAT_PROTO_M		0x00000003	/* protocol mask */
#define	RX_STAT_PROTO_UK	0x00000000	/* unknown protocol */
#define	RX_STAT_PROTO_IPX	0x00000001	/* IPX */
#define	RX_STAT_PROTO_IP	0x00000002	/* IP */
#define	RX_STAT_PROTO_RSV	0x00000003	/* reserved */
#define	RX_STAT_VLAN		0x00000004	/* vlan tag (in rxd) */
#define	RX_STAT_IPFRAG		0x00000008	/* fragment, ipsec not done */
#define	RX_STAT_IPSEC		0x00000010	/* ipsec decoded packet */
#define	RX_STAT_IPCKSUMBAD	0x00000020	/* ip checksum failed */
#define	RX_STAT_UDPCKSUMBAD	0x00000040	/* udp checksum failed */
#define	RX_STAT_TCPCKSUMBAD	0x00000080	/* tcp checksum failed */
#define	RX_STAT_IPCKSUMGOOD	0x00000100	/* ip checksum succeeded */
#define	RX_STAT_UDPCKSUMGOOD	0x00000200	/* udp checksum succeeded */
#define	RX_STAT_TCPCKSUMGOOD	0x00000400	/* tcp checksum succeeded */


struct txp_rxbuf_desc {
	volatile u_int32_t	rb_paddrlo;
	volatile u_int32_t	rb_paddrhi;
	volatile u_int32_t	rb_vaddrlo;
	volatile u_int32_t	rb_vaddrhi;
};

/* Extension descriptor */
struct txp_ext_desc {
	volatile u_int32_t	ext_1;
	volatile u_int32_t	ext_2;
	volatile u_int32_t	ext_3;
	volatile u_int32_t	ext_4;
};

struct txp_cmd_desc {
	volatile u_int8_t	cmd_flags;
	volatile u_int8_t	cmd_numdesc;
	volatile u_int16_t	cmd_id;
	volatile u_int16_t	cmd_seq;
	volatile u_int16_t	cmd_par1;
	volatile u_int32_t	cmd_par2;
	volatile u_int32_t	cmd_par3;
};
#define	CMD_FLAGS_TYPE_M	0x07		/* type mask */
#define	CMD_FLAGS_TYPE_FRAG	0x00		/* type: fragment */
#define	CMD_FLAGS_TYPE_DATA	0x01		/* type: data frame */
#define	CMD_FLAGS_TYPE_CMD	0x02		/* type: command frame */
#define	CMD_FLAGS_TYPE_OPT	0x03		/* type: options */
#define	CMD_FLAGS_TYPE_RX	0x04		/* type: command */
#define	CMD_FLAGS_TYPE_RESP	0x05		/* type: response */
#define	CMD_FLAGS_RESP		0x40		/* response requested */
#define	CMD_FLAGS_VALID		0x80		/* valid descriptor */

struct txp_rsp_desc {
	volatile u_int8_t	rsp_flags;
	volatile u_int8_t	rsp_numdesc;
	volatile u_int16_t	rsp_id;
	volatile u_int16_t	rsp_seq;
	volatile u_int16_t	rsp_par1;
	volatile u_int32_t	rsp_par2;
	volatile u_int32_t	rsp_par3;
};
#define	RSP_FLAGS_TYPE_M	0x07		/* type mask */
#define	RSP_FLAGS_TYPE_FRAG	0x00		/* type: fragment */
#define	RSP_FLAGS_TYPE_DATA	0x01		/* type: data frame */
#define	RSP_FLAGS_TYPE_CMD	0x02		/* type: command frame */
#define	RSP_FLAGS_TYPE_OPT	0x03		/* type: options */
#define	RSP_FLAGS_TYPE_RX	0x04		/* type: command */
#define	RSP_FLAGS_TYPE_RESP	0x05		/* type: response */
#define	RSP_FLAGS_ERROR		0x40		/* response error */

struct txp_frag_desc {
	volatile u_int8_t	frag_flags;	/* type/descriptor flags */
	volatile u_int8_t	frag_rsvd1;
	volatile u_int16_t	frag_len;	/* bytes in this fragment */
	volatile u_int32_t	frag_addrlo;	/* phys addr low word */
	volatile u_int32_t	frag_addrhi;	/* phys addr high word */
	volatile u_int32_t	frag_rsvd2;
};
#define	FRAG_FLAGS_TYPE_M	0x07		/* type mask */
#define	FRAG_FLAGS_TYPE_FRAG	0x00		/* type: fragment */
#define	FRAG_FLAGS_TYPE_DATA	0x01		/* type: data frame */
#define	FRAG_FLAGS_TYPE_CMD	0x02		/* type: command frame */
#define	FRAG_FLAGS_TYPE_OPT	0x03		/* type: options */
#define	FRAG_FLAGS_TYPE_RX	0x04		/* type: command */
#define	FRAG_FLAGS_TYPE_RESP	0x05		/* type: response */
#define	FRAG_FLAGS_VALID	0x80		/* valid descriptor */

struct txp_opt_desc {
	u_int8_t		opt_desctype:3,
				opt_rsvd:1,
				opt_type:4;

	u_int8_t		opt_num;
	u_int16_t		opt_dep1;
	u_int32_t		opt_dep2;
	u_int32_t		opt_dep3;
	u_int32_t		opt_dep4;
};

struct txp_ipsec_desc {
	u_int8_t		ipsec_desctpe:3,
				ipsec_rsvd:1,
				ipsec_type:4;

	u_int8_t		ipsec_num;
	u_int16_t		ipsec_flags;
	u_int16_t		ipsec_ah1;
	u_int16_t		ipsec_esp1;
	u_int16_t		ipsec_ah2;
	u_int16_t		ipsec_esp2;
	u_int32_t		ipsec_rsvd1;
};

struct txp_tcpseg_desc {
	u_int8_t		tcpseg_desctype:3,
				tcpseg_rsvd:1,
				tcpseg_type:4;

	u_int8_t		tcpseg_num;

	u_int16_t		tcpseg_mss:12,
				tcpseg_misc:4;

	u_int32_t		tcpseg_respaddr;
	u_int32_t		tcpseg_txbytes;
	u_int32_t		tcpseg_lss;
};

/*
 * Transceiver types
 */
#define	TXP_XCVR_10_HDX		0
#define	TXP_XCVR_10_FDX		1
#define	TXP_XCVR_100_HDX	2
#define	TXP_XCVR_100_FDX	3
#define	TXP_XCVR_AUTO		4

#define TXP_MEDIA_CRC		0x0004	/* crc strip disable */
#define	TXP_MEDIA_CD		0x0010	/* collision detection */
#define	TXP_MEDIA_CS		0x0020	/* carrier sense */
#define	TXP_MEDIA_POL		0x0400	/* polarity reversed */
#define	TXP_MEDIA_NOLINK	0x0800	/* 0 = link, 1 = no link */

/*
 * receive filter bits (par1 to TXP_CMD_RX_FILTER_{READ|WRITE}
 */
#define	TXP_RXFILT_DIRECT	0x0001	/* directed packets */
#define	TXP_RXFILT_ALLMULTI	0x0002	/* all multicast packets */
#define	TXP_RXFILT_BROADCAST	0x0004	/* broadcast packets */
#define	TXP_RXFILT_PROMISC	0x0008	/* promiscuous mode */
#define	TXP_RXFILT_HASHMULTI	0x0010	/* use multicast filter */

/*
 * boot record (pointers to rings)
 */
struct txp_boot_record {
	volatile u_int32_t	br_hostvar_lo;		/* host ring pointer */
	volatile u_int32_t	br_hostvar_hi;
	volatile u_int32_t	br_txlopri_lo;		/* tx low pri ring */
	volatile u_int32_t	br_txlopri_hi;
	volatile u_int32_t	br_txlopri_siz;
	volatile u_int32_t	br_txhipri_lo;		/* tx high pri ring */
	volatile u_int32_t	br_txhipri_hi;
	volatile u_int32_t	br_txhipri_siz;
	volatile u_int32_t	br_rxlopri_lo;		/* rx low pri ring */
	volatile u_int32_t	br_rxlopri_hi;
	volatile u_int32_t	br_rxlopri_siz;
	volatile u_int32_t	br_rxbuf_lo;		/* rx buffer ring */
	volatile u_int32_t	br_rxbuf_hi;
	volatile u_int32_t	br_rxbuf_siz;
	volatile u_int32_t	br_cmd_lo;		/* command ring */
	volatile u_int32_t	br_cmd_hi;
	volatile u_int32_t	br_cmd_siz;
	volatile u_int32_t	br_resp_lo;		/* response ring */
	volatile u_int32_t	br_resp_hi;
	volatile u_int32_t	br_resp_siz;
	volatile u_int32_t	br_zero_lo;		/* zero word */
	volatile u_int32_t	br_zero_hi;
	volatile u_int32_t	br_rxhipri_lo;		/* rx high pri ring */
	volatile u_int32_t	br_rxhipri_hi;
	volatile u_int32_t	br_rxhipri_siz;
};

/*
 * hostvar structure (shared with typhoon)
 */
struct txp_hostvar {
	volatile u_int32_t	hv_rx_hi_read_idx;	/* host->arm */
	volatile u_int32_t	hv_rx_lo_read_idx;	/* host->arm */
	volatile u_int32_t	hv_rx_buf_write_idx;	/* host->arm */
	volatile u_int32_t	hv_resp_read_idx;	/* host->arm */
	volatile u_int32_t	hv_tx_lo_desc_read_idx;	/* arm->host */
	volatile u_int32_t	hv_tx_hi_desc_read_idx;	/* arm->host */
	volatile u_int32_t	hv_rx_lo_write_idx;	/* arm->host */
	volatile u_int32_t	hv_rx_buf_read_idx;	/* arm->host */
	volatile u_int32_t	hv_cmd_read_idx;	/* arm->host */
	volatile u_int32_t	hv_resp_write_idx;	/* arm->host */
	volatile u_int32_t	hv_rx_hi_write_idx;	/* arm->host */
};

/*
 * TYPHOON status register state (in TXP_A2H_0)
 */
#define	STAT_ROM_CODE			0x00000001
#define	STAT_ROM_EEPROM_LOAD		0x00000002
#define	STAT_WAITING_FOR_BOOT		0x00000007
#define	STAT_RUNNING			0x00000009
#define	STAT_WAITING_FOR_HOST_REQUEST	0x0000000d
#define	STAT_WAITING_FOR_SEGMENT	0x00000010
#define	STAT_SLEEPING			0x00000011
#define	STAT_HALTED			0x00000014

#define	TX_ENTRIES			256
#define	RX_ENTRIES			128
#define	RXBUF_ENTRIES			256
#define	CMD_ENTRIES			32
#define	RSP_ENTRIES			32

#define	OFFLOAD_TCPCKSUM		0x00000002	/* tcp checksum */
#define	OFFLOAD_UDPCKSUM		0x00000004	/* udp checksum */
#define	OFFLOAD_IPCKSUM			0x00000008	/* ip checksum */
#define	OFFLOAD_IPSEC			0x00000010	/* ipsec enable */
#define	OFFLOAD_BCAST			0x00000020	/* broadcast throttle */
#define	OFFLOAD_DHCP			0x00000040	/* dhcp prevention */
#define	OFFLOAD_VLAN			0x00000080	/* vlan enable */
#define	OFFLOAD_FILTER			0x00000100	/* filter enable */
#define	OFFLOAD_TCPSEG			0x00000200	/* tcp segmentation */
#define	OFFLOAD_MASK			0xfffffffe	/* mask off low bit */

/*
 * Macros for converting array indices to offsets within the descriptor
 * arrays.  The chip operates on offsets, but it's much easier for us
 * to operate on indices.  Assumes descriptor entries are 16 bytes.
 */
#define	TXP_IDX2OFFSET(idx)	((idx) << 4)
#define	TXP_OFFSET2IDX(off)	((off) >> 4)

struct txp_dma_alloc {
	u_int64_t		dma_paddr;
	caddr_t			dma_vaddr;
	bus_dmamap_t		dma_map;
	bus_dma_segment_t	dma_seg;
	int			dma_nseg;
};

struct txp_cmd_ring {
	struct txp_cmd_desc	*base;
	u_int32_t		lastwrite;
	u_int32_t		size;
};

struct txp_rsp_ring {
	struct txp_rsp_desc	*base;
	u_int32_t		lastwrite;
	u_int32_t		size;
};

struct txp_tx_ring {
	struct txp_tx_desc	*r_desc;	/* base address of descs */
	u_int32_t		r_reg;		/* register to activate */
	u_int32_t		r_prod;		/* producer */
	u_int32_t		r_cons;		/* consumer */
	u_int32_t		r_cnt;		/* # descs in use */
	volatile u_int32_t	*r_off;		/* hostvar index pointer */
};

struct txp_swdesc {
	struct mbuf *		sd_mbuf;
	bus_dmamap_t		sd_map;
};

struct txp_rx_ring {
	struct txp_rx_desc	*r_desc;	/* base address of descs */
	volatile u_int32_t	*r_roff;	/* hv read offset ptr */
	volatile u_int32_t	*r_woff;	/* hv write offset ptr */
};

struct txp_softc {
	struct device		sc_dev;		/* base device */
	struct arpcom		sc_arpcom;	/* ethernet common */
	struct txp_hostvar	*sc_hostvar;
	struct txp_boot_record	*sc_boot;
	bus_space_handle_t	sc_bh;		/* bus handle (regs) */
	bus_space_tag_t		sc_bt;		/* bus tag (regs) */
	bus_dma_tag_t		sc_dmat;	/* dma tag */
	struct txp_cmd_ring	sc_cmdring;
	struct txp_rsp_ring	sc_rspring;
	struct txp_swdesc	sc_txd[TX_ENTRIES];
	void *			sc_ih;
	struct timeout		sc_tick;
	struct ifmedia		sc_ifmedia;
	struct txp_tx_ring	sc_txhir, sc_txlor;
	struct txp_rxbuf_desc	*sc_rxbufs;
	struct txp_rx_ring	sc_rxhir, sc_rxlor;
	u_int16_t		sc_xcvr;
	u_int16_t		sc_seq;
	struct txp_dma_alloc	sc_boot_dma, sc_host_dma, sc_zero_dma;
	struct txp_dma_alloc	sc_rxhiring_dma, sc_rxloring_dma;
	struct txp_dma_alloc	sc_txhiring_dma, sc_txloring_dma;
	struct txp_dma_alloc	sc_cmdring_dma, sc_rspring_dma;
	struct txp_dma_alloc	sc_rxbufring_dma;
	int			sc_cold;
	u_int32_t		sc_rx_capability, sc_tx_capability;
};

#define	TXP_DEVNAME(sc)		((sc)->sc_cold ? "" : (sc)->sc_dev.dv_xname)

struct txp_fw_file_header {
	u_int8_t	magicid[8];	/* TYPHOON\0 */
	u_int32_t	version;
	u_int32_t	nsections;
	u_int32_t	addr;
	u_int32_t	hmac[5];
};

struct txp_fw_section_header {
	u_int32_t	nbytes;
	u_int16_t	cksum;
	u_int16_t	reserved;
	u_int32_t	addr;
};

#define	TXP_MAX_SEGLEN	0xffff
#define	TXP_MAX_PKTLEN	0x0800

#define	WRITE_REG(sc,reg,val) \
    bus_space_write_4((sc)->sc_bt, (sc)->sc_bh, reg, val)
#define	READ_REG(sc,reg) \
    bus_space_read_4((sc)->sc_bt, (sc)->sc_bh, reg)

@


1.37
log
@fix bit defns for PFLAGs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.36 2004/05/31 19:25:00 mcbride Exp $ */
d599 1
@


1.36
log
@Replace local crc32 with ether_crc32_be.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.35 2003/06/04 19:36:33 deraadt Exp $ */
d184 9
a192 9
#define	TXP_PFLAG_NOCRC		0x0000
#define	TXP_PFLAG_IPCKSUM	0x0001
#define	TXP_PFLAG_TCPCKSUM	0x0002
#define	TXP_PFLAG_TCPSEGMENT	0x0004
#define	TXP_PFLAG_INSERTVLAN	0x0008
#define	TXP_PFLAG_IPSEC		0x0010
#define	TXP_PFLAG_PRIORITY	0x0020
#define	TXP_PFLAG_UDPCKSUM	0x0040
#define	TXP_PFLAG_PADFRAME	0x0080
@


1.35
log
@3/4 cleanup for aaron
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.34 2001/11/05 17:25:58 art Exp $ */
a437 3

/* multicast polynomial */
#define	TXP_POLYNOMIAL		0x04c11db7
@


1.34
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.33 2001/11/02 19:31:00 jason Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Aaron Campbell.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.33
log
@- Set valid bit in transmit descriptors and tx fragment descriptors (previous
firmware versions didn't use it, but newer ones might... play it safe).
- add a bit of debugging code to tx so I can get dumps easier to send to 3com.
(ifdef'd out).
- ifdef both places that require modification to enable TX cksums to avoid
errors like halfway enabling them (which caused me a bit of pain the
other day).
- TX UDP/TCP cksums still hang the firmware
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.32 2001/10/29 22:32:56 jason Exp $ */
a623 7
#ifdef __HAS_NEW_BUS_DMAMAP_SYNC
#define	txp_bus_dmamap_sync(tag, map, off, len, op)	\
    bus_dmamap_sync((tag), (map), (off), (len), (op))
#else
#define	txp_bus_dmamap_sync(tag, map, off, len, op)	\
    bus_dmamap_sync((tag), (map), (op))
#endif
@


1.32
log
@defn for "versions read" command (not that the results match the docs mind you).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.31 2001/08/24 21:11:14 jason Exp $ */
d377 1
@


1.31
log
@missing bus_dmamap_sync() calls on descriptors... also deal with 5 argument form of bus_dmamap_sync()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.30 2001/06/23 04:18:02 jason Exp $ */
d160 1
@


1.30
log
@UDP and TCP bits are reversed with respect to documentation
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.29 2001/06/22 20:51:04 jason Exp $ */
d621 8
@


1.29
log
@add more ipsec commands
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.28 2001/05/30 14:41:59 jason Exp $ */
d302 2
a303 2
#define	RX_STAT_TCPCKSUMBAD	0x00000040	/* tcp checksum failed */
#define	RX_STAT_UDPCKSUMBAD	0x00000080	/* udp checksum failed */
d305 2
a306 2
#define	RX_STAT_TCPCKSUMGOOD	0x00000200	/* tcp checksum succeeded */
#define	RX_STAT_UDPCKSUMGOOD	0x00000400	/* udp checksum succeeded */
@


1.28
log
@- gather statistics (ipackets, ierrors, collisions, etc) from txp itself
- better spl handling
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.27 2001/05/30 04:49:33 jason Exp $ */
d174 2
@


1.27
log
@expand txp_command2 to handle extension desciptors for long commands
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.26 2001/05/30 04:26:55 jason Exp $ */
d105 1
a105 1
#define	TXP_CMD_ERROR_READ			0x09
@


1.26
log
@- better handling for capabilities: check the card to make sure it supports
IPsec offloading before claiming to have that capability.
- also add cksum offload capabilities (commented out for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.25 2001/05/16 14:34:30 fgsch Exp $ */
d518 1
@


1.25
log
@Use dm_mapsize instead of homegrown one; jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.24 2001/05/15 14:57:28 jason Exp $ */
d592 1
@


1.24
log
@- correct some bus_dmamap_sync() usage
- redo dma_alloc(), dma_free() a bit (I had them right to begin with)
- add an alignment shim on rx buffers on strict alignment arch's (this is
hideous, but hopefully temporary)
Upshot: works on alpha now
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.23 2001/05/15 05:18:13 jason Exp $ */
a532 1
	bus_size_t		dma_size;
@


1.23
log
@- bus-dmaify txp
- use symbolic name instead of value for maximum packet length
- make this compile on alpha (be careful with pointers stored in device descriptors)
- fix a mbuf leak in the tx full case
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.22 2001/05/09 02:25:09 jason Exp $ */
d531 3
@


1.22
log
@revert reverted patch now that bus_dma has been updated on i386
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.21 2001/05/08 03:52:43 jason Exp $ */
d554 5
d575 1
d607 3
@


1.22.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.17 2001/04/15 21:03:22 jason Exp $ */
d168 1
d251 3
a253 2
#define	TX_PFLAGS_VLANTAG_M	0x000ff000	/* vlan tag mask */
#define	TX_PFLAGS_VLANPRI_M	0x00300000	/* vlan priority mask */
d314 8
d498 1
a498 1
#define	STAT_WAITING_FOR_HOST_REQUEST	0x0000000D
d509 10
d528 1
a529 2
	u_int64_t		dma_paddr;
	bus_size_t		dma_siz;
a530 2
	bus_dma_segment_t	dma_seg;
	int			dma_nseg;
a557 5
};

/* Software transmit list */
struct txp_swtx {
	struct mbuf		*tx_mbuf;
@


1.22.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.22.2.1 2001/05/14 22:25:48 niklas Exp $ */
d105 1
a105 1
#define	TXP_CMD_CLEAR_STATISTICS		0x09
a167 1
#define	TXP_CMD_OFFLOAD_READ			0x4e
a172 2
#define	TXP_CMD_READ_IPSEC_INFO			0x54
#define	TXP_CMD_GET_IPSEC_ENABLE		0x67
d250 2
a251 3
#define	TX_PFLAGS_VLANTAG_M	0x0ffff000	/* vlan tag mask */
#define	TX_PFLAGS_VLANPRI_M	0x00700000	/* vlan priority mask */
#define	TX_PFLAGS_VLANTAG_S	12		/* amount to shift tag */
d298 2
a299 2
#define	RX_STAT_UDPCKSUMBAD	0x00000040	/* udp checksum failed */
#define	RX_STAT_TCPCKSUMBAD	0x00000080	/* tcp checksum failed */
d301 2
a302 2
#define	RX_STAT_UDPCKSUMGOOD	0x00000200	/* udp checksum succeeded */
#define	RX_STAT_TCPCKSUMGOOD	0x00000400	/* tcp checksum succeeded */
a311 8
/* Extension descriptor */
struct txp_ext_desc {
	volatile u_int32_t	ext_1;
	volatile u_int32_t	ext_2;
	volatile u_int32_t	ext_3;
	volatile u_int32_t	ext_4;
};

d488 1
a488 1
#define	STAT_WAITING_FOR_HOST_REQUEST	0x0000000d
a498 11
#define	OFFLOAD_TCPCKSUM		0x00000002	/* tcp checksum */
#define	OFFLOAD_UDPCKSUM		0x00000004	/* udp checksum */
#define	OFFLOAD_IPCKSUM			0x00000008	/* ip checksum */
#define	OFFLOAD_IPSEC			0x00000010	/* ipsec enable */
#define	OFFLOAD_BCAST			0x00000020	/* broadcast throttle */
#define	OFFLOAD_DHCP			0x00000040	/* dhcp prevention */
#define	OFFLOAD_VLAN			0x00000080	/* vlan enable */
#define	OFFLOAD_FILTER			0x00000100	/* filter enable */
#define	OFFLOAD_TCPSEG			0x00000200	/* tcp segmentation */
#define	OFFLOAD_MASK			0xfffffffe	/* mask off low bit */

d508 1
d510 1
a510 1
	caddr_t			dma_vaddr;
a536 5
struct txp_swdesc {
	struct mbuf *		sd_mbuf;
	bus_dmamap_t		sd_map;
};

d543 5
a557 1
	struct txp_swdesc	sc_txd[TX_ENTRIES];
a571 1
	u_int32_t		sc_rx_capability, sc_tx_capability;
a588 3

#define	TXP_MAX_SEGLEN	0xffff
#define	TXP_MAX_PKTLEN	0x0800
@


1.22.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.22.2.2 2001/07/04 10:42:27 niklas Exp $ */
a620 8

#ifdef __HAS_NEW_BUS_DMAMAP_SYNC
#define	txp_bus_dmamap_sync(tag, map, off, len, op)	\
    bus_dmamap_sync((tag), (map), (off), (len), (op))
#else
#define	txp_bus_dmamap_sync(tag, map, off, len, op)	\
    bus_dmamap_sync((tag), (map), (op))
#endif
@


1.22.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a159 1
#define	TXP_CMD_VERSIONS_READ			0x43
a375 1
#define	FRAG_FLAGS_VALID	0x80		/* valid descriptor */
d622 7
@


1.22.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.22.2.4 2001/11/13 21:10:02 niklas Exp $ */
d15 5
@


1.22.2.6
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d438 3
@


1.21
log
@- add support for hardware vlan tag insertion and removal
- add necessary definitions for extension descriptors, missing commands,
and offload capabilities
- rework command/response (again) to allow for long responses (still need
support for long commands, though).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.20 2001/05/03 05:22:51 jason Exp $ */
a530 1
	bus_size_t		dma_size;	/* XXX should use dm_mapsize */
@


1.20
log
@grr... part of the bus_dma change depended on local stuff: revert that part
for now until folks comment on the dependent patch; pointed out by fgsch.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.19 2001/05/02 15:00:34 jason Exp $ */
d168 1
d251 1
a251 1
#define	TX_PFLAGS_VLANTAG_M	0x000ff000	/* vlan tag mask */
d253 1
a253 1
#define	TX_PFLAGS_VLANTAG_S	16		/* amount to shift tag */
d314 8
d508 10
@


1.19
log
@- somewhat better use of bus_dma interface
- use constants for bzero'n allocated memory instead of retrieving mapped size
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.18 2001/04/30 05:04:08 jason Exp $ */
d512 1
@


1.18
log
@cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.17 2001/04/15 21:03:22 jason Exp $ */
d509 1
a510 2
	u_int64_t		dma_paddr;
	bus_size_t		dma_siz;
a511 2
	bus_dma_segment_t	dma_seg;
	int			dma_nseg;
@


1.17
log
@- setup a timeout that will try to refill the rxbuffer ring (this makes
out of resource handling a bit better).
- in txp_stop(), disable the rx process, too
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.16 2001/04/13 17:50:30 jason Exp $ */
d251 2
a252 1
#define	TX_PFLAGS_VLANPRI_M	0x00300000	/* vlan priority mask */
d489 1
a489 1
#define	STAT_WAITING_FOR_HOST_REQUEST	0x0000000D
a541 5
};

/* Software transmit list */
struct txp_swtx {
	struct mbuf		*tx_mbuf;
@


1.16
log
@- rx buffer ring management (working)
- simplify/encapsulate fully transmit ring handling
- initialize sc_xcvr to be auto
- initial rx descriptor ring handling (doesn't work yet)
status: firmware, boot, media, tx, and rx buffer management work
(actual received frames don't... yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.15 2001/04/12 22:40:12 jason Exp $ */
a33 2
#define	TXP_INTR	TXP_INT_STATUS_REGISTER

d227 2
a228 2
/*XXX*/	u_int32_t		tx_addrlo;	/* virt addr low word */
/*XXX*/	u_int32_t		tx_addrhi;	/* virt addr high word */
d559 1
a559 1
	struct timeout		sc_tick_tmo;
@


1.15
log
@- initial rx buffer ring management routines and allocation
- go ahead and initialized the rx filter (but don't enable RX just yet)
- correct descriptor definition for txp_rx_desc (not the same size as any
other descriptor)
- definition of txp_rxbuf_desc
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.14 2001/04/12 15:01:19 jason Exp $ */
d290 1
a290 1
/* txp_rx_desc.rx_stat (if rx_flags & RX_FLAGS_ERROR bit set) */
d536 7
d565 1
@


1.14
log
@- sort of working transmit routines and tx interrupt handling, definately
more to do here
- be sure to set maximum packet size early
- remove old debugging code and add new
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.13 2001/04/11 16:22:38 jason Exp $ */
d256 56
a311 14
	u_int8_t		rx_desctype:3,
				rx_rcvtype:2,
				rx_rsvdA:1,
				rx_error:1,
				rx_rsvdB:1;

	u_int8_t		rx_num;
	u_int16_t		rx_len;
	u_int32_t		rx_addrlo;
	u_int32_t		rx_addrhi;
	u_int32_t		rx_stat;
	u_int16_t		rx_filter;
	u_int16_t		rx_ipsechash;
	u_int32_t		rx_vlan;
d496 2
a497 1
#define	RX_ENTRIES			256
d557 1
d564 1
@


1.13
log
@correct descriptor definitions for tx and frag
(also fix CMD/RSP type fields)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.12 2001/04/10 22:10:09 jason Exp $ */
d229 2
a230 2
	volatile u_int32_t	tx_addrlo;	/* phys addr low word */
	volatile u_int32_t	tx_addrhi;	/* phys addr high word */
d458 8
d487 13
d513 1
d520 1
d522 2
@


1.12
log
@add shutdown hook to stop the adapter completely
put txp_set_filter() in the right places
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.11 2001/04/10 19:52:38 jason Exp $ */
d226 6
a231 12
	u_int8_t		tx_desctype:3,
				tx_rsvd:5;

	u_int8_t		tx_num;
	u_int16_t		tx_rsvd1;
	u_int32_t		tx_addrlo;
	u_int32_t		tx_addrhi;

	u_int32_t		tx_proc_flags:9,
				tx_proc_rsvd1:3,
				tx_proc_vlanpri:16,
				tx_proc_rsvd2:4;
d233 21
d282 6
a287 6
#define	CMD_FLAGS_TYPE_FRAG	0x01		/* type: fragment */
#define	CMD_FLAGS_TYPE_DATA	0x02		/* type: data frame */
#define	CMD_FLAGS_TYPE_CMD	0x03		/* type: command frame */
#define	CMD_FLAGS_TYPE_OPT	0x04		/* type: options */
#define	CMD_FLAGS_TYPE_RX	0x05		/* type: command */
#define	CMD_FLAGS_TYPE_RESP	0x06		/* type: response */
d301 6
a306 6
#define	RSP_FLAGS_TYPE_FRAG	0x01		/* type: fragment */
#define	RSP_FLAGS_TYPE_DATA	0x02		/* type: data frame */
#define	RSP_FLAGS_TYPE_CMD	0x03		/* type: command frame */
#define	RSP_FLAGS_TYPE_OPT	0x04		/* type: options */
#define	RSP_FLAGS_TYPE_RX	0x05		/* type: command */
#define	RSP_FLAGS_TYPE_RESP	0x06		/* type: response */
d310 6
a315 8
	u_int8_t		frag_desctype:3,
				frag_rsvd:5;

	u_int8_t		frag_rsvd1;
	u_int16_t		frag_num;
	u_int32_t		frag_addrlo;
	u_int32_t		frag_addrhi;
	u_int32_t		frag_rsvd2;
d317 7
@


1.11
log
@receive filter programming
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.10 2001/04/09 22:05:00 jason Exp $ */
d433 2
a434 2
#define	TX_ENTRIES			128
#define	RX_ENTRIES			128
@


1.10
log
@- full media support (and remove all of the mii stuff... the firmware wants
to maintain write control over the phy... fine... but we query it to get
current status).
- fix several bugs in cmd/rsp handling: match responses to commands via id/seq,
and add a routine to fixup the queue if it gets mangled).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.9 2001/04/09 05:36:17 jason Exp $ */
d360 12
@


1.9
log
@partial mii support (commented out because the response queue freaks out)
get link status via media status query (unclear how to get speed/duplex this way)
fix media command definitions to match documentation
update the hostvar index for response queue on successful query
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.8 2001/04/09 04:09:18 jason Exp $ */
a459 1
	mii_data_t		sc_mii;		/* mii bus */
d461 1
@


1.8
log
@basic media handling/switching
XXX: Status routine needs to really query device to get duplex/speed/link
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.7 2001/04/09 03:15:47 jason Exp $ */
d129 2
a130 2
#define	TXP_CMD_POWER_MGMT_EVENT_READ		0x1f
#define	TXP_CMD_POWER_MGMT_EVENT_WRITE		0x20
d355 6
d448 2
a449 2
	struct device		sc_dev;
	struct arpcom		sc_arpcom;
d452 3
a454 3
	bus_space_handle_t	sc_bh;
	bus_space_tag_t		sc_bt;
	bus_dma_tag_t		sc_dmat;
d460 1
@


1.7
log
@- implement command and response ring management
- rewrite definitions for command/response rings (bad aaron, shared memory structures are volatile and should not use nonportable bit slices, ':')
Status: loads firmware, boots, gets mac address
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.6 2001/04/08 21:47:45 jason Exp $ */
d347 9
d453 2
@


1.6
log
@- bring over some bus_dma allocation code (from failed attempt to bus_dma-ify ubsec)
- allocate rings and boot the card
Status: firmware loads, card appears to boot correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.5 2001/04/08 19:25:29 jason Exp $ */
d258 35
a292 12
	u_int8_t		cmd_desctype:3,
				cmd_rsvd:3,
				cmd_respond:1,
				cmd_rsvd1:1;

	u_int8_t		cmd_num;
	u_int16_t		cmd_id;
	u_int16_t		cmd_seq;
	u_int16_t		cmd_par1;
	u_int32_t		cmd_par2;
	u_int32_t		cmd_par3;
};
a345 14
struct txp_resp_desc {
	u_int8_t		resp_desctype:3,
				resp_rsvd1:3,
				resp_error:1,
				resp_resv2:1;

	u_int8_t		resp_num;
	u_int16_t		resp_cmd;
	u_int16_t		resp_seq;
	u_int16_t		resp_par1;
	u_int32_t		resp_par2;
	u_int32_t		resp_par3;
};

d350 2
a351 2
	volatile u_int32_t	br_hostring_lo;		/* host ring pointer */
	volatile u_int32_t	br_hostring_hi;
d378 1
a378 1
 * host ring structure (shared with typhoon)
d380 12
a391 12
struct txp_hostring {
	volatile u_int32_t	hr_rx_hi_read_idx;	/* host->arm */
	volatile u_int32_t	hr_rx_lo_read_idx;	/* host->arm */
	volatile u_int32_t	hr_rx_buf_write_idx;	/* host->arm */
	volatile u_int32_t	hr_resp_read_idx;	/* host->arm */
	volatile u_int32_t	hr_tx_lo_desc_read_idx;	/* arm->host */
	volatile u_int32_t	hr_tx_hi_desc_read_idx;	/* arm->host */
	volatile u_int32_t	hr_rx_lo_write_idx;	/* arm->host */
	volatile u_int32_t	hr_rx_buf_read_idx;	/* arm->host */
	volatile u_int32_t	hr_cmd_read_idx;	/* arm->host */
	volatile u_int32_t	hr_resp_write_idx;	/* arm->host */
	volatile u_int32_t	hr_rx_hi_write_idx;	/* arm->host */
d409 1
a409 1
#define	RESP_ENTRIES			32
d420 12
d434 3
a436 1
	void *			sc_ih;
d440 3
a442 1
	struct arpcom		sc_arpcom;
d447 1
a447 1
	struct txp_dma_alloc	sc_cmdring_dma, sc_respring_dma;
@


1.5
log
@and host ring definition
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.4 2001/04/08 19:16:50 jason Exp $ */
d355 3
a357 3
	volatile u_int32_t	br_ctrl_lo;		/* command ring */
	volatile u_int32_t	br_ctrl_hi;
	volatile u_int32_t	br_ctrl_siz;
d397 14
d419 4
@


1.4
log
@define boot record
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.3 2001/04/08 18:26:38 jason Exp $ */
d366 17
@


1.3
log
@- load microcode from better directory (still not in tree)
- reg "definition" for soft reset register
- make sure fileheader and section number are initialized before use
- verify section checksum before use
- add a skeleton txp_start()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.2 2001/04/08 05:28:50 jason Exp $ */
d337 30
@


1.2
log
@cleanup, more register definitions
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txpreg.h,v 1.1 2001/04/08 02:16:52 jason Exp $ */
d80 5
@


1.1
log
@Skeleton driver for 3c990 (mainly so aaron/theo/myself can coordinate)
- the firmware image is still under a restrictive license, so it will
not be in the tree yet
- driver only knows how to (correctly) upload firmware
- register definitions and such are incomplete
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d34 4
a37 1
#define TXP_INTR	TXP_INT_STATUS_REGISTER
d42 38
a79 17
#define TXP_SOFT_RESET_REGISTER		0x00
#define TXP_INT_STATUS_REGISTER		0x04
#define TXP_INT_ENABLE_REGISTER		0x08
#define TXP_INT_MASK_REGISTER		0x0C
#define TXP_SELF_INT_REGISTER		0x10
#define TXP_HOST2ARM_COMM_7_REGISTER	0x14
#define TXP_HOST2ARM_COMM_6_REGISTER	0x18
#define TXP_HOST2ARM_COMM_5_REGISTER	0x1C
#define TXP_HOST2ARM_COMM_4_REGISTER	0x20
#define TXP_HOST2ARM_COMM_3_REGISTER	0x24
#define TXP_HOST2ARM_COMM_2_REGISTER	0x28
#define TXP_HOST2ARM_COMM_1_REGISTER	0x2C
#define TXP_HOST2ARM_COMM_0_REGISTER	0x30
#define TXP_ARM2HOST_COMM_3_REGISTER	0x34
#define TXP_ARM2HOST_COMM_2_REGISTER	0x38
#define TXP_ARM2HOST_COMM_1_REGISTER	0x3C
#define TXP_ARM2HOST_COMM_0_REGISTER	0x40
d82 1
a82 1
 * Typhoon commands.
d84 135
a218 126
#define TXP_CMD_GLOBAL_RESET			0x00
#define TXP_CMD_TX_ENABLE			0x01
#define TXP_CMD_TX_DISABLE			0x02
#define TXP_CMD_RX_ENABLE			0x03
#define TXP_CMD_RX_DISABLE			0x04
#define TXP_CMD_RX_FILTER_WRITE			0x05
#define TXP_CMD_RX_FILTER_READ			0x06
#define TXP_CMD_READ_STATISTICS			0x07
#define TXP_CMD_CYCLE_STATISTICS		0x08
#define TXP_CMD_ERROR_READ			0x09
#define TXP_CMD_MEMORY_READ			0x0a
#define TXP_CMD_MEMORY_WRITE_SINGLE		0x0b
#define TXP_CMD_VARIABLE_SECTION_READ		0x0c
#define TXP_CMD_VARIABLE_SECTION_WRITE		0x0d
#define TXP_CMD_STATIC_SECTION_READ		0x0e
#define TXP_CMD_STATIC_SECTION_WRITE		0x0f
#define TXP_CMD_IMAGE_SECTION_PROGRAM		0x10
#define TXP_CMD_NVRAM_PAGE_READ			0x11
#define TXP_CMD_NVRAM_PAGE_WRITE		0x12
#define TXP_CMD_XCVR_SELECT			0x13
#define TXP_CMD_TEST_MUX			0x14
#define TXP_CMD_PHYLOOPBACK_ENABLE		0x15
#define TXP_CMD_PHYLOOPBACK_DISABLE		0x16
#define TXP_CMD_MAC_CONTROL_READ		0x17
#define TXP_CMD_MAC_CONTROL_WRITE		0x18
#define TXP_CMD_MAX_PKT_SIZE_READ		0x19
#define TXP_CMD_MAX_PKT_SIZE_WRITE		0x1a
#define TXP_CMD_MEDIA_STATUS_READ		0x1b
#define TXP_CMD_MEDIA_STATUS_WRITE		0x1c
#define TXP_CMD_NETWORK_DIAGS_READ		0x1d
#define TXP_CMD_NETWORK_DIAGS_WRITE		0x1e
#define TXP_CMD_POWER_MGMT_EVENT_READ		0x1f
#define TXP_CMD_POWER_MGMT_EVENT_WRITE		0x20
#define TXP_CMD_VARIABLE_PARAMETER_READ		0x21
#define TXP_CMD_VARIABLE_PARAMETER_WRITE	0x22
#define TXP_CMD_GOTO_SLEEP			0x23
#define TXP_CMD_FIREWALL_CONTROL		0x24
#define TXP_CMD_MCAST_HASH_MASK_WRITE		0x25
#define TXP_CMD_STATION_ADDRESS_WRITE		0x26
#define TXP_CMD_STATION_ADDRESS_READ		0x27
#define TXP_CMD_STATION_MASK_WRITE		0x28
#define TXP_CMD_STATION_MASK_READ		0x29
#define TXP_CMD_VLAN_ETHER_TYPE_READ		0x2a
#define TXP_CMD_VLAN_ETHER_TYPE_WRITE		0x2b
#define TXP_CMD_VLAN_MASK_READ			0x2c
#define TXP_CMD_VLAN_MASK_WRITE			0x2d
#define TXP_CMD_BCAST_THROTTLE_WRITE		0x2e
#define TXP_CMD_BCAST_THROTTLE_READ		0x2f
#define TXP_CMD_DHCP_PREVENT_WRITE		0x30
#define TXP_CMD_DHCP_PREVENT_READ		0x31
#define TXP_CMD_RECV_BUFFER_CONTROL		0x32
#define TXP_CMD_SOFTWARE_RESET			0x33
#define TXP_CMD_CREATE_SA			0x34
#define TXP_CMD_DELETE_SA			0x35
#define TXP_CMD_ENABLE_RX_IP_OPTION		0x36
#define TXP_CMD_RANDOM_NUMBER_CONTROL		0x37
#define TXP_CMD_RANDOM_NUMBER_READ		0x38
#define TXP_CMD_MATRIX_TABLE_MODE_WRITE		0x39
#define TXP_CMD_MATRIX_DETAIL_READ		0x3a
#define TXP_CMD_FILTER_ARRAY_READ		0x3b
#define TXP_CMD_FILTER_DETAIL_READ		0x3c
#define TXP_CMD_FILTER_TABLE_MODE_WRITE		0x3d
#define TXP_CMD_FILTER_TCL_WRITE		0x3e
#define TXP_CMD_FILTER_TBL_READ			0x3f
#define TXP_CMD_FILTER_DEFINE			0x45
#define TXP_CMD_ADD_WAKEUP_PKT			0x46
#define TXP_CMD_ADD_SLEEP_PKT			0x47
#define TXP_CMD_ENABLE_SLEEP_EVENTS		0x48
#define TXP_CMD_ENABLE_WAKEUP_EVENTS		0x49
#define TXP_CMD_GET_IP_ADDRESS			0x4a
#define TXP_CMD_READ_PCI_REG			0x4c
#define TXP_CMD_WRITE_PCI_REG			0x4d
#define TXP_CMD_OFFLOAD_WRITE			0x4f
#define TXP_CMD_HELLO_RESPONSE			0x57
#define TXP_CMD_ENABLE_RX_FILTER		0x58
#define TXP_CMD_RX_FILTER_CAPABILITY		0x59
#define TXP_CMD_HALT				0x5d
#define TXP_CMD_INVALID				0xffff

#define TXP_FRAGMENT		0x0000
#define TXP_TXFRAME		0x0001
#define TXP_COMMAND		0x0002
#define TXP_OPTION		0x0003
#define TXP_RECEIVE		0x0004
#define TXP_RESPONSE		0x0005

#define TXP_TYPE_IPSEC		0x0000
#define TXP_TYPE_TCPSEGMENT	0x0001

#define TXP_PFLAG_NOCRC		0x0000
#define TXP_PFLAG_IPCKSUM	0x0001
#define TXP_PFLAG_TCPCKSUM	0x0002
#define TXP_PFLAG_TCPSEGMENT	0x0004
#define TXP_PFLAG_INSERTVLAN	0x0008
#define TXP_PFLAG_IPSEC		0x0010
#define TXP_PFLAG_PRIORITY	0x0020
#define TXP_PFLAG_UDPCKSUM	0x0040
#define TXP_PFLAG_PADFRAME	0x0080

#define TXP_MISC_FIRSTDESC	0x0000
#define TXP_MISC_LASTDESC	0x0001

#define TXP_ERR_INTERNAL	0x0000
#define TXP_ERR_FIFOUNDERRUN	0x0001
#define TXP_ERR_BADSSD		0x0002
#define TXP_ERR_RUNT		0x0003
#define TXP_ERR_CRC		0x0004
#define TXP_ERR_OVERSIZE	0x0005
#define TXP_ERR_ALIGNMENT	0x0006
#define TXP_ERR_DRIBBLEBIT	0x0007

#define TXP_PROTO_UNKNOWN	0x0000
#define TXP_PROTO_IP		0x0001
#define TXP_PROTO_IPX		0x0002
#define TXP_PROTO_RESERVED	0x0003

#define TXP_STAT_PROTO		0x0001
#define TXP_STAT_VLAN		0x0002
#define TXP_STAT_IPFRAGMENT	0x0004
#define TXP_STAT_IPSEC		0x0008
#define TXP_STAT_IPCKSUMBAD	0x0010
#define TXP_STAT_TCPCKSUMBAD	0x0020
#define TXP_STAT_UDPCKSUMBAD	0x0040
#define TXP_STAT_IPCKSUMGOOD	0x0080
#define TXP_STAT_TCPCKSUMGOOD	0x0100
#define TXP_STAT_UDPCKSUMGOOD	0x0200
d334 1
a334 1
 * TYPHOON status register state
d336 18
a353 6
#define	TYPHOON_WAITING_FOR_BOOT		0x00000007
#define	TYPHOON_RUNNING				0x00000009
#define	TYPHOON_WAITING_FOR_HOST_REQUEST	0x0000000D
#define	TYPHOON_WAITING_FOR_SEGMENT		0x00000010
#define	TYPHOON_SLEEPING			0x00000011
#define	TYPHOON_HALTED				0x00000014
d355 13
d369 4
a372 5
/* Random stuff... */
#define TYPHOON_INT_ARM2HOST_COMM_0     0x00000002
#define TYPHOON_BOOTCOMMAND_RUNTIME_IMAGE              0xFD
#define TYPHOON_BOOTCOMMAND_DOWNLOAD_COMPLETE          0xFB
#define TYPHOON_BOOTCOMMAND_SEGMENT_AVAILABLE          0xFC
@

