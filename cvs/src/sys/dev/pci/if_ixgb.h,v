head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.4
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.8
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.6
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.4
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.12
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.14
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.10
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.8
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.6
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.4
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.3.0.2
	OPENBSD_3_9_BASE:1.3;
locks; strict;
comment	@ * @;


1.19
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.18;
commitid	5gdEnqVoJuTuwdTu;

1.18
date	2015.11.14.17.54.57;	author mpi;	state Exp;
branches;
next	1.17;
commitid	Waft2RDjXAxr4qZ9;

1.17
date	2014.12.26.05.46.32;	author tedu;	state Exp;
branches;
next	1.16;
commitid	BEFV1zuqezFBud1r;

1.16
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.15;
commitid	TGHgrLxu6sxZoiFt;

1.15
date	2014.07.10.14.21.20;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	Jjzk0Y0KSLF2oro4;

1.14
date	2013.08.07.01.06.35;	author bluhm;	state Exp;
branches;
next	1.13;

1.13
date	2010.08.27.08.24.53;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.10.19.41.05;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.28.04.45.08;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.18.18.46.20;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.04.14.25.24;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2006.07.21.01.49.15;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.14.22.24.23;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.01.21.01.11;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.27.17.07.10;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.26.01.27.16;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.10.19.19.40;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.14.23.25.43;	author brad;	state Exp;
branches;
next	;


desc
@@


1.19
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/**************************************************************************

Copyright (c) 2001-2005, Intel Corporation
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

 3. Neither the name of the Intel Corporation nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

***************************************************************************/

/* $OpenBSD: if_ixgb.h,v 1.18 2015/11/14 17:54:57 mpi Exp $ */

#ifndef _IXGB_H_DEFINED_
#define _IXGB_H_DEFINED_

#include "bpfilter.h"
#include "vlan.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/socket.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

typedef int	boolean_t;
#define TRUE	1
#define FALSE	0

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/pci/ixgb_hw.h>
#include <dev/pci/ixgb_ee.h>
#include <dev/pci/ixgb_ids.h>

/* Tunables */

/*
 * TxDescriptors Valid Range: 64-4096 Default Value: 2048 This value is the
 * number of transmit descriptors allocated by the driver. Increasing this
 * value allows the driver to queue more transmits. Each descriptor is 16
 * bytes.
 */
#define IXGB_MAX_TXD			2048

/*
 * RxDescriptors Valid Range: 64-4096 Default Value: 1024 This value is the
 * number of receive descriptors allocated by the driver. Increasing this
 * value allows the driver to buffer more incoming packets. Each descriptor
 * is 16 bytes.  A receive buffer is also allocated for each descriptor. The
 * maximum MTU size is 16110.
 */
#define IXGB_MAX_RXD			1024

/*
 * TxIntDelay Valid Range: 0-65535 (0=off) Default Value: 32 This value
 * delays the generation of transmit interrupts in units of 1.024
 * microseconds. Transmit interrupt reduction can improve CPU efficiency if
 * properly tuned for specific network traffic. If the system is reporting
 * dropped transmits, this value may be set too high causing the driver to
 * run out of available transmit descriptors.
 */
#define TIDV				32

/*
 * RxIntDelay Valid Range: 0-65535 (0=off) Default Value: 72 This value
 * delays the generation of receive interrupts in units of 1.024
 * microseconds.  Receive interrupt reduction can improve CPU efficiency if
 * properly tuned for specific network traffic. Increasing this value adds
 * extra latency to frame reception and can end up decreasing the throughput
 * of TCP traffic. If the system is reporting dropped receives, this value
 * may be set too high, causing the driver to run out of available receive
 * descriptors.
 */
#define RDTR				72

/*
 * This parameter controls the duration of transmit watchdog timer.
 */
#define IXGB_TX_TIMEOUT			5	/* set to 5 seconds */

/*
 * This parameter controls when the driver calls the routine to reclaim
 * transmit descriptors.
 */
#define IXGB_TX_CLEANUP_THRESHOLD	(sc->num_tx_desc / 8)

/* 
 * Flow Control Types. 
 * 1. ixgb_fc_none - Flow Control Disabled 
 * 2. ixgb_fc_rx_pause - Flow Control Receive Only
 * 3. ixgb_fc_tx_pause - Flow Control Transmit Only
 * 4. ixgb_fc_full - Flow Control Enabled
 */
#define FLOW_CONTROL_NONE	ixgb_fc_none 
#define FLOW_CONTROL_RX_PAUSE	ixgb_fc_rx_pause
#define FLOW_CONTROL_TX_PAUSE	ixgb_fc_tx_pause
#define FLOW_CONTROL_FULL	ixgb_fc_full

/*
 * Set the flow control type. Assign one of the above flow control types to be enabled.
 * Default Value: FLOW_CONTROL_FULL   
 */    
#define FLOW_CONTROL		FLOW_CONTROL_FULL

/*
 * Receive Flow control low threshold (when we send a resume frame) (FCRTL)
 * Valid Range: 64 - 262,136 (0x40 - 0x3FFF8, 8 byte granularity) must be
 * less than high threshold by at least 8 bytes Default Value:  163,840
 * (0x28000)
 */
#define FCRTL			0x28000

/*
 * Receive Flow control high threshold (when we send a pause frame) (FCRTH)
 * Valid Range: 1,536 - 262,136 (0x600 - 0x3FFF8, 8 byte granularity) Default
 * Value: 196,608 (0x30000)
 */
#define FCRTH			0x30000

/*
 * Flow control request timeout (how long to pause the link partner's tx)
 * (PAP 15:0) Valid Range: 1 - 65535 Default Value:  256 (0x100)
 */
#define FCPAUSE			0x100

/* Tunables -- End */

#define IXGB_MMBA		0x0010	/* Mem base address */
#define IXGB_ROUNDUP(size, unit) (((size) + (unit) - 1) & ~((unit) - 1))

#define MAX_NUM_MULTICAST_ADDRESSES	128

/* Defines for printing debug information */
#define DEBUG_INIT	0
#define DEBUG_IOCTL	0
#define DEBUG_HW	0

#define INIT_DEBUGOUT(S)		if (DEBUG_INIT)  printf(S "\n")
#define INIT_DEBUGOUT1(S, A)		if (DEBUG_INIT)  printf(S "\n", A)
#define INIT_DEBUGOUT2(S, A, B)		if (DEBUG_INIT)  printf(S "\n", A, B)
#define IOCTL_DEBUGOUT(S)		if (DEBUG_IOCTL) printf(S "\n")
#define IOCTL_DEBUGOUT1(S, A)		if (DEBUG_IOCTL) printf(S "\n", A)
#define IOCTL_DEBUGOUT2(S, A, B)	if (DEBUG_IOCTL) printf(S "\n", A, B)
#define HW_DEBUGOUT(S)			if (DEBUG_HW) printf(S "\n")
#define HW_DEBUGOUT1(S, A)		if (DEBUG_HW) printf(S "\n", A)
#define HW_DEBUGOUT2(S, A, B)		if (DEBUG_HW) printf(S "\n", A, B)

/* Supported RX Buffer Sizes */
#define IXGB_RXBUFFER_2048	2048
#define IXGB_RXBUFFER_4096	4096
#define IXGB_RXBUFFER_8192	8192
#define IXGB_RXBUFFER_16384	16384

#define IXGB_MAX_SCATTER	100

struct ixgb_buffer {
	struct mbuf    *m_head;
	bus_dmamap_t    map;	/* bus_dma map for packet */
};

/*
 * Bus dma allocation structure used by
 * ixgb_dma_malloc and ixgb_dma_free.
 */
struct ixgb_dma_alloc {
	bus_addr_t		dma_paddr;
	caddr_t			dma_vaddr;
	bus_dma_tag_t		dma_tag;
	bus_dmamap_t		dma_map;
	bus_dma_segment_t	dma_seg;
	bus_size_t		dma_size;
	int			dma_nseg;
};

typedef enum _XSUM_CONTEXT_T {
	OFFLOAD_NONE,
	OFFLOAD_TCP_IP,
	OFFLOAD_UDP_IP
} XSUM_CONTEXT_T;

/* Our adapter structure */
struct ixgb_softc {
	struct device	sc_dv;
	struct arpcom	interface_data;
	struct ixgb_hw	hw;

	/* OpenBSD operating-system-specific structures */
	struct ixgb_osdep osdep;
	struct ifmedia	media;
	int		io_rid;

	void		*sc_intrhand;
	struct timeout	ixgb_intr_enable;
	struct timeout	timer_handle;
	int		if_flags;

	/* Info about the board itself */
	u_int32_t	part_num;
	u_int8_t	link_active;
	u_int16_t	link_speed;
	u_int16_t	link_duplex;
	u_int32_t	tx_int_delay;
	u_int32_t	tx_abs_int_delay;
	u_int32_t	rx_int_delay;
	u_int32_t	rx_abs_int_delay;

	int		raidc;

	XSUM_CONTEXT_T	active_checksum_context;

	/*
	 * Transmit definitions
	 * 
	 * We have an array of num_tx_desc descriptors (handled by the
	 * controller) paired with an array of tx_buffers (at
	 * tx_buffer_area). The index of the next available descriptor is
	 * next_avail_tx_desc. The number of remaining tx_desc is
	 * num_tx_desc_avail.
	 */
	struct ixgb_dma_alloc	txdma;		/* bus_dma glue for tx desc */
	struct ixgb_tx_desc	*tx_desc_base;
	u_int32_t		next_avail_tx_desc;
	u_int32_t		oldest_used_tx_desc;
	volatile u_int16_t	num_tx_desc_avail;
	u_int16_t		num_tx_desc;
	u_int32_t		txd_cmd;
	struct ixgb_buffer	*tx_buffer_area;
	bus_dma_tag_t		txtag;		/* dma tag for tx */

	/*
	 * Receive definitions
	 * 
	 * we have an array of num_rx_desc rx_desc (handled by the controller),
	 * and paired with an array of rx_buffers (at rx_buffer_area). The
	 * next pair to check on receive is at offset next_rx_desc_to_check
	 */
	struct ixgb_dma_alloc	rxdma;		/* bus_dma glue for rx desc */
	struct ixgb_rx_desc	*rx_desc_base;
	u_int32_t		next_rx_desc_to_check;
	u_int16_t		num_rx_desc;
	u_int32_t		rx_buffer_len;
	struct ixgb_buffer	*rx_buffer_area;
	bus_dma_tag_t		rxtag;		/* dma tag for Rx */
	u_int32_t		next_rx_desc_to_use;

	/*
	 * First/last mbuf pointers, for
	 * collecting multisegment RX packets.
	 */
	struct mbuf		*fmp;
	struct mbuf		*lmp;

	/* Misc stats maintained by the driver */
	unsigned long		dropped_pkts;
	unsigned long		mbuf_alloc_failed;
	unsigned long		mbuf_cluster_failed;
	unsigned long		no_tx_desc_avail1;
	unsigned long		no_tx_desc_avail2;
	unsigned long		no_tx_map_avail;
	unsigned long		no_tx_dma_setup;
	unsigned long		watchdog_events;

	struct ixgb_hw_stats	stats;
};

#endif /* _IXGB_H_DEFINED_ */
@


1.18
log
@Do not include <net/if_vlan_var.h> when it's not necessary.

Because of the VLAN hacks in mpw(4) this file still contains the definition
of "struct ifvlan" which depends on <sys/refcnt.h> which in turns pull
<sys/atomic.h>...
@
text
@d34 1
a34 1
/* $OpenBSD: if_ixgb.h,v 1.17 2014/12/26 05:46:32 tedu Exp $ */
a52 1
#include <net/if_dl.h>
@


1.17
log
@unifdef INET. missed a few headers in previous rounds
@
text
@d34 1
a34 1
/* $OpenBSD: if_ixgb.h,v 1.16 2014/07/22 13:12:11 mpi Exp $ */
a60 5

#if NVLAN > 0
#include <net/if_types.h>
#include <net/if_vlan_var.h>
#endif
@


1.16
log
@Fewer <netinet/in_systm.h>
@
text
@d34 1
a34 1
/* $OpenBSD: if_ixgb.h,v 1.15 2014/07/10 14:21:20 deraadt Exp $ */
a55 1
#ifdef INET
a60 1
#endif
@


1.15
log
@remove most of the boolean_t infection outside uvm/ddb/pmap; ok jsg
@
text
@d34 1
a34 1
/* $OpenBSD: if_ixgb.h,v 1.14 2013/08/07 01:06:35 bluhm Exp $ */
a57 1
#include <netinet/in_systm.h>
@


1.14
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d34 1
a34 1
/* $OpenBSD: if_ixgb.h,v 1.13 2010/08/27 08:24:53 deraadt Exp $ */
d74 3
a76 1
#include <uvm/uvm_extern.h>
@


1.13
log
@These do not need powerhook functions.
ok jsg
@
text
@d34 1
a34 1
/* $OpenBSD: if_ixgb.h,v 1.12 2010/04/20 22:05:43 tedu Exp $ */
a58 1
#include <netinet/in_var.h>
@


1.12
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d34 1
a34 1
/* $OpenBSD: if_ixgb.h,v 1.11 2009/08/10 19:41:05 deraadt Exp $ */
a245 1
	void		*sc_powerhook;
@


1.11
log
@A few more simple cases of shutdown hooks which only call xxstop, when
we now know the interface has already been stopped
@
text
@d34 1
a34 1
/* $OpenBSD: if_ixgb.h,v 1.10 2006/11/28 04:45:08 brad Exp $ */
d50 1
@


1.10
log
@Pre-allocate the TX DMA maps intead of creating and destroying a DMA map
per packet sent.
@
text
@d34 1
a34 1
/* $OpenBSD: if_ixgb.h,v 1.9 2006/11/18 18:46:20 brad Exp $ */
a245 1
	void		*sc_shutdownhook;
@


1.9
log
@add a few comments
@
text
@d34 1
a34 1
/* $OpenBSD: if_ixgb.h,v 1.8 2006/08/04 14:25:24 brad Exp $ */
a206 4
	bus_dmamap_t    map;	/* bus_dma map for packet */
};

struct ixgb_q {
@


1.8
log
@- merge em/ixgb_disable_promisc() into em/ixgb_set_promisc().
- rearrange interface flags ioctl handler.
@
text
@d34 1
a34 1
/* $OpenBSD: if_ixgb.h,v 1.7 2006/07/21 01:49:15 brad Exp $ */
d301 4
a304 1
	/* Jumbo frame */
@


1.7
log
@Revert the last commit. The TX descriptor count does not really need
to be set that high and it can cause problems with multiple adapters
in the same system.
@
text
@d34 1
a34 1
/* $OpenBSD: if_ixgb.h,v 1.6 2006/05/14 22:24:23 brad Exp $ */
d248 1
@


1.6
log
@up the TX descriptors to the max.
@
text
@d34 1
a34 1
/* $OpenBSD: if_ixgb.h,v 1.5 2006/05/01 21:01:11 brad Exp $ */
d87 1
a87 1
 * TxDescriptors Valid Range: 64-4096 Default Value: 4096 This value is the
d92 1
a92 1
#define IXGB_MAX_TXD			4096
@


1.5
log
@sprinkle some tabs.
@
text
@d34 1
a34 1
/* $OpenBSD: if_ixgb.h,v 1.4 2006/03/27 17:07:10 brad Exp $ */
d87 1
a87 1
 * TxDescriptors Valid Range: 64-4096 Default Value: 2048 This value is the
d92 1
a92 1
#define IXGB_MAX_TXD			2048
@


1.4
log
@Sync up to Intel's latest FreeBSD ixgb driver (5.0.1).

From: Intel's web-site
@
text
@d34 1
a34 1
/* $OpenBSD: if_ixgb.h,v 1.3 2006/02/26 01:27:16 brad Exp $ */
d87 1
a87 1
 * TxDescriptors Valid Range: 64-4096 Default Value: 1024 This value is the
d92 1
a92 1
#define IXGB_MAX_TXD                      1024
d101 1
a101 1
#define IXGB_MAX_RXD                     1024
d111 1
a111 1
#define TIDV 32
d123 1
a123 1
#define RDTR 72
d128 1
a128 1
#define IXGB_TX_TIMEOUT                   5	/* set to 5 seconds */
d134 1
a134 1
#define IXGB_TX_CLEANUP_THRESHOLD         IXGB_MAX_TXD / 8
d143 4
a146 4
#define FLOW_CONTROL_NONE    	ixgb_fc_none 
#define FLOW_CONTROL_RX_PAUSE   ixgb_fc_rx_pause
#define FLOW_CONTROL_TX_PAUSE   ixgb_fc_tx_pause
#define FLOW_CONTROL_FULL       ixgb_fc_full
d152 1
a152 1
#define FLOW_CONTROL	        FLOW_CONTROL_FULL
d160 1
a160 1
#define FCRTL                   0x28000
d167 1
a167 1
#define FCRTH                   0x30000
d173 1
a173 1
#define FCPAUSE		     0x100
d177 1
a177 3

#define IXGB_VENDOR_ID                    0x8086
#define IXGB_MMBA                         0x0010	/* Mem base address */
d180 1
a180 3
#define IOCTL_CMD_TYPE                  u_long
#define MAX_NUM_MULTICAST_ADDRESSES     128
#define PCI_ANY_ID                      (~0U)
d183 13
a195 14
#define DEBUG_INIT  0
#define DEBUG_IOCTL 0
#define DEBUG_HW    0

#define INIT_DEBUGOUT(S)            if (DEBUG_INIT)  printf(S "\n")
#define INIT_DEBUGOUT1(S, A)        if (DEBUG_INIT)  printf(S "\n", A)
#define INIT_DEBUGOUT2(S, A, B)     if (DEBUG_INIT)  printf(S "\n", A, B)
#define IOCTL_DEBUGOUT(S)           if (DEBUG_IOCTL) printf(S "\n")
#define IOCTL_DEBUGOUT1(S, A)       if (DEBUG_IOCTL) printf(S "\n", A)
#define IOCTL_DEBUGOUT2(S, A, B)    if (DEBUG_IOCTL) printf(S "\n", A, B)
#define HW_DEBUGOUT(S)              if (DEBUG_HW) printf(S "\n")
#define HW_DEBUGOUT1(S, A)          if (DEBUG_HW) printf(S "\n", A)
#define HW_DEBUGOUT2(S, A, B)       if (DEBUG_HW) printf(S "\n", A, B)

d198 4
a201 4
#define IXGB_RXBUFFER_2048        2048
#define IXGB_RXBUFFER_4096        4096
#define IXGB_RXBUFFER_8192        8192
#define IXGB_RXBUFFER_16384      16384
d203 1
a203 1
#define IXGB_MAX_SCATTER           100
d215 2
a216 1
 * Bus dma allocation structure used by ixgb_dma_malloc and ixgb_dma_free.
d219 7
a225 7
	bus_addr_t      dma_paddr;
	caddr_t         dma_vaddr;
	bus_dma_tag_t   dma_tag;
	bus_dmamap_t    dma_map;
	bus_dma_segment_t dma_seg;
	bus_size_t      dma_size;
	int             dma_nseg;
d232 1
a232 1
}               XSUM_CONTEXT_T;
d237 2
a238 2
	struct arpcom   interface_data;
	struct ixgb_hw  hw;
d242 2
a243 2
	struct ifmedia  media;
	int             io_rid;
d245 1
a245 1
	void            *sc_intrhand;
d252 8
a259 8
	u_int32_t       part_num;
	u_int8_t        link_active;
	u_int16_t       link_speed;
	u_int16_t       link_duplex;
	u_int32_t       tx_int_delay;
	u_int32_t       tx_abs_int_delay;
	u_int32_t       rx_int_delay;
	u_int32_t       rx_abs_int_delay;
d261 1
a261 1
	int             raidc;
d263 1
a263 1
	XSUM_CONTEXT_T  active_checksum_context;
d274 9
a282 9
	struct ixgb_dma_alloc txdma;	/* bus_dma glue for tx desc */
	struct ixgb_tx_desc *tx_desc_base;
	u_int32_t       next_avail_tx_desc;
	u_int32_t       oldest_used_tx_desc;
	                volatile u_int16_t num_tx_desc_avail;
	u_int16_t       num_tx_desc;
	u_int32_t       txd_cmd;
	struct ixgb_buffer *tx_buffer_area;
	bus_dma_tag_t   txtag;	/* dma tag for tx */
d291 8
a298 8
	struct ixgb_dma_alloc rxdma;	/* bus_dma glue for rx desc */
	struct ixgb_rx_desc *rx_desc_base;
	u_int32_t       next_rx_desc_to_check;
	u_int16_t       num_rx_desc;
	u_int32_t       rx_buffer_len;
	struct ixgb_buffer *rx_buffer_area;
	bus_dma_tag_t   rxtag;	/* dma tag for Rx */
	u_int32_t       next_rx_desc_to_use;
d301 2
a302 2
	struct mbuf    *fmp;
	struct mbuf    *lmp;
d305 8
a312 8
	unsigned long   dropped_pkts;
	unsigned long   mbuf_alloc_failed;
	unsigned long   mbuf_cluster_failed;
	unsigned long   no_tx_desc_avail1;
	unsigned long   no_tx_desc_avail2;
	unsigned long   no_tx_map_avail;
	unsigned long   no_tx_dma_setup;
	unsigned long	watchdog_events;
d314 1
a314 1
	struct ixgb_hw_stats stats;
d317 1
a317 1
#endif				/* _IXGB_H_DEFINED_ */
@


1.3
log
@- set baud rate in ixgb_update_link_status().
- remove some FreeBSD code.
- set IFM_NONE if no link.
@
text
@d34 1
a34 1
/* $OpenBSD: if_ixgb.h,v 1.2 2005/12/10 19:19:40 brad Exp $ */
d87 1
a87 1
 * TxDescriptors Valid Range: 64-4096 Default Value: 256 This value is the
d95 1
a95 1
 * RxDescriptors Valid Range: 64-512 Default Value: 512 This value is the
a99 2
 * Note: Maximum number of receive descriptors is limited to 512 to avoid a
 * hardware descriptor cache issue under heavy receive traffic. 
d101 1
a101 1
#define IXGB_MAX_RXD                     512
a121 1
 * 
@


1.2
log
@add a shutdown function and register it with shutdownhook_establish().
@
text
@d34 1
a34 1
/* $OpenBSD: if_ixgb.h,v 1.1 2005/11/14 23:25:43 brad Exp $ */
d92 1
a92 1
#define IXGB_MAX_TXD                      256
a128 6
 * This parameter controls the maximum no of times the driver will loop in
 * the isr. Minimum Value = 1
 */
#define IXGB_MAX_INTR                     3

/*
a187 1
#define ETHER_ALIGN                     2
a319 2

	boolean_t       in_detach;
@


1.1
log
@add Intel 10Gb Ethernet driver with support for LR/SR and CX4 cards.

From: Intel's web-site

ok deraadt@@
@
text
@d34 1
a34 1
/* $OpenBSD$ */
d263 1
@

