head	1.87;
access;
symbols
	OPENBSD_6_2:1.87.0.10
	OPENBSD_6_2_BASE:1.87
	OPENBSD_6_1:1.87.0.8
	OPENBSD_6_1_BASE:1.87
	OPENBSD_6_0:1.87.0.6
	OPENBSD_6_0_BASE:1.87
	OPENBSD_5_9:1.87.0.2
	OPENBSD_5_9_BASE:1.87
	OPENBSD_5_8:1.85.0.4
	OPENBSD_5_8_BASE:1.85
	OPENBSD_5_7:1.82.0.4
	OPENBSD_5_7_BASE:1.82
	OPENBSD_5_6:1.81.0.4
	OPENBSD_5_6_BASE:1.81
	OPENBSD_5_5:1.74.0.4
	OPENBSD_5_5_BASE:1.74
	OPENBSD_5_4:1.72.0.2
	OPENBSD_5_4_BASE:1.72
	OPENBSD_5_3:1.69.0.2
	OPENBSD_5_3_BASE:1.69
	OPENBSD_5_2:1.67.0.6
	OPENBSD_5_2_BASE:1.67
	OPENBSD_5_1_BASE:1.67
	OPENBSD_5_1:1.67.0.4
	OPENBSD_5_0:1.67.0.2
	OPENBSD_5_0_BASE:1.67
	OPENBSD_4_9:1.65.0.2
	OPENBSD_4_9_BASE:1.65
	OPENBSD_4_8:1.63.0.2
	OPENBSD_4_8_BASE:1.63
	OPENBSD_4_7:1.46.0.2
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.44.0.4
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.39.0.2
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.26.0.4
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.14.0.6
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.14
	UBC:1.10.0.4
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.7.0.14
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.12
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.10
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.8
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7;
locks; strict;
comment	@ * @;


1.87
date	2015.10.29.07.47.03;	author kettenis;	state Exp;
branches;
next	1.86;
commitid	QDyL8dFxcUx9R2yh;

1.86
date	2015.08.20.04.41.46;	author mlarkin;	state Exp;
branches;
next	1.85;
commitid	eoSwLmCZ9T7CGJzs;

1.85
date	2015.07.18.00.48.05;	author miod;	state Exp;
branches;
next	1.84;
commitid	zOVsbR9piOCLHrSg;

1.84
date	2015.03.29.18.45.22;	author miod;	state Exp;
branches;
next	1.83;
commitid	Zn8MYTvkjKcNFl7W;

1.83
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.82;
commitid	p4LJxGKbi0BU2cG6;

1.82
date	2014.12.06.03.01.42;	author jsg;	state Exp;
branches;
next	1.81;
commitid	sOSlmPmZC9IeVUvr;

1.81
date	2014.07.28.15.00.27;	author jsg;	state Exp;
branches;
next	1.80;
commitid	UC1Kg7uZbOmNOW0L;

1.80
date	2014.07.22.04.42.51;	author jsg;	state Exp;
branches;
next	1.79;
commitid	EtAKn2rlAqe8IYXn;

1.79
date	2014.07.12.23.16.23;	author jsg;	state Exp;
branches;
next	1.78;
commitid	O24jDaMgu2Gu8oh0;

1.78
date	2014.06.01.00.37.37;	author mlarkin;	state Exp;
branches;
next	1.77;
commitid	upjmIeN2TuoFwYNx;

1.77
date	2014.03.28.17.57.11;	author mpi;	state Exp;
branches;
next	1.76;

1.76
date	2014.03.26.14.41.41;	author mpi;	state Exp;
branches;
next	1.75;

1.75
date	2014.03.17.22.01.56;	author kettenis;	state Exp;
branches;
next	1.74;

1.74
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2013.08.12.04.11.52;	author jsg;	state Exp;
branches;
next	1.72;

1.72
date	2013.03.26.18.45.02;	author kettenis;	state Exp;
branches;
next	1.71;

1.71
date	2013.03.18.10.12.40;	author kettenis;	state Exp;
branches;
next	1.70;

1.70
date	2013.03.04.21.52.36;	author kettenis;	state Exp;
branches;
next	1.69;

1.69
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2012.08.22.20.58.30;	author mpi;	state Exp;
branches;
next	1.67;

1.67
date	2011.04.14.21.04.29;	author oga;	state Exp;
branches;
next	1.66;

1.66
date	2011.04.14.21.02.20;	author oga;	state Exp;
branches;
next	1.65;

1.65
date	2010.12.26.15.41.00;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2010.08.31.17.13.44;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2010.08.08.19.33.35;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2010.08.08.17.21.07;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2010.08.06.18.32.38;	author marco;	state Exp;
branches;
next	1.60;

1.60
date	2010.08.04.23.23.36;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2010.08.04.18.29.43;	author matthew;	state Exp;
branches;
next	1.58;

1.58
date	2010.08.04.17.50.38;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2010.07.27.07.42.34;	author mlarkin;	state Exp;
branches;
next	1.56;

1.56
date	2010.07.21.07.50.20;	author mlarkin;	state Exp;
branches;
next	1.55;

1.55
date	2010.07.20.05.18.22;	author mlarkin;	state Exp;
branches;
next	1.54;

1.54
date	2010.07.14.11.21.53;	author matthieu;	state Exp;
branches;
next	1.53;

1.53
date	2010.07.02.00.23.42;	author pirofti;	state Exp;
branches;
next	1.52;

1.52
date	2010.07.02.00.09.37;	author pirofti;	state Exp;
branches;
next	1.51;

1.51
date	2010.07.01.23.38.29;	author mlarkin;	state Exp;
branches;
next	1.50;

1.50
date	2010.07.01.22.51.23;	author pirofti;	state Exp;
branches;
next	1.49;

1.49
date	2010.07.01.17.05.06;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2010.07.01.16.31.36;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2010.07.01.01.02.31;	author pirofti;	state Exp;
branches;
next	1.46;

1.46
date	2009.11.28.22.43.22;	author kettenis;	state Exp;
branches;
next	1.45;

1.45
date	2009.11.28.22.15.59;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2009.06.06.04.38.18;	author pirofti;	state Exp;
branches;
next	1.43;

1.43
date	2009.06.06.00.35.00;	author pirofti;	state Exp;
branches;
next	1.42;

1.42
date	2009.06.03.23.33.01;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2009.06.03.00.36.59;	author pirofti;	state Exp;
branches;
next	1.40;

1.40
date	2009.06.02.11.22.45;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2008.11.22.21.26.48;	author oga;	state Exp;
branches;
next	1.38;

1.38
date	2008.11.09.15.11.19;	author oga;	state Exp;
branches;
next	1.37;

1.37
date	2008.08.12.23.10.41;	author oga;	state Exp;
branches;
next	1.36;

1.36
date	2008.08.10.00.18.35;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2008.08.02.15.50.34;	author oga;	state Exp;
branches;
next	1.34;

1.34
date	2008.07.12.17.31.06;	author oga;	state Exp;
branches;
next	1.33;

1.33
date	2008.06.12.00.58.47;	author oga;	state Exp;
branches;
next	1.32;

1.32
date	2008.06.03.17.14.21;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2008.05.06.19.19.02;	author oga;	state Exp;
branches;
next	1.30;

1.30
date	2008.03.16.19.00.28;	author oga;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.28.23.37.34;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2007.11.25.17.11.12;	author oga;	state Exp;
branches;
next	1.27;

1.27
date	2007.11.03.10.09.03;	author martin;	state Exp;
branches;
next	1.26;

1.26
date	2007.01.28.20.28.50;	author gwk;	state Exp;
branches;
next	1.25;

1.25
date	2006.11.27.18.04.28;	author gwk;	state Exp;
branches;
next	1.24;

1.24
date	2006.07.20.20.54.51;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.16.21.32.34;	author matthieu;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.15.21.46.32;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.15.20.46.15;	author matthieu;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.19.02.18.00;	author pedro;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2005.11.10.22.57.37;	author martin;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.11.00.48.06;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.03.15.18.21;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2004.02.04.20.03.28;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.31.04.10.05;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.15.13.23.48;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.13.20.33.47;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.12.20.17.03;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.27.00;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.08.16.16.11;	author mickey;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	2000.11.19.03.28.53;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.15.20.17.38;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	98.01.05.13.35.27;	author deraadt;	state Exp;
branches
	1.7.10.1;
next	1.6;

1.6
date	97.11.06.12.26.56;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.11.06.02.53.43;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.09.30.19.21.36;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.08.22.22.26.01;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.07.09.02.58.40;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	97.01.24.19.58.02;	author niklas;	state Exp;
branches;
next	;

1.7.10.1
date	2001.05.14.22.26.01;	author niklas;	state Exp;
branches;
next	1.7.10.2;

1.7.10.2
date	2001.07.04.10.43.15;	author niklas;	state Exp;
branches;
next	1.7.10.3;

1.7.10.3
date	2002.03.28.15.35.59;	author niklas;	state Exp;
branches;
next	1.7.10.4;

1.7.10.4
date	2003.03.28.00.38.25;	author niklas;	state Exp;
branches;
next	1.7.10.5;

1.7.10.5
date	2004.02.19.10.56.30;	author niklas;	state Exp;
branches;
next	1.7.10.6;

1.7.10.6
date	2004.06.05.23.12.54;	author niklas;	state Exp;
branches;
next	;

1.10.4.1
date	2002.06.11.03.42.27;	author art;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	;

1.20.2.1
date	2007.01.03.21.11.10;	author miod;	state Exp;
branches;
next	;


desc
@@


1.87
log
@Make inteldrm(4) attach to pci(4) instead of vga(4) just like radeondrm(4).
This is needed for machines where Intel graphics isn't the primary graphics
device and on systems with UEFI firmware that put the device in non-VGA mode.

ok jsg@@
@
text
@/* $OpenBSD: vga_pci.c,v 1.86 2015/08/20 04:41:46 mlarkin Exp $ */
/* $NetBSD: vga_pci.c,v 1.3 1998/06/08 06:55:58 thorpej Exp $ */

/*
 * Copyright (c) 2001 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Frank van der Linden for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project by
 *	Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include "vga.h"
#if defined(__i386__) || defined(__amd64__)
#include "acpi.h"
#endif

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/rwlock.h>

#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/ic/mc6845reg.h>
#include <dev/ic/pcdisplayvar.h>
#include <dev/ic/vgareg.h>
#include <dev/pci/vga_pcivar.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/ic/vgavar.h>

#ifdef X86EMU
#include <machine/vga_post.h>
#endif

int	vga_pci_match(struct device *, void *, void *);
void	vga_pci_attach(struct device *, struct device *, void *);
int	vga_pci_activate(struct device *, int);
paddr_t	vga_pci_mmap(void* v, off_t off, int prot);

#if !defined(SMALL_KERNEL) && NACPI > 0
void	vga_save_state(struct vga_pci_softc *);
void	vga_restore_state(struct vga_pci_softc *);
#endif

/*
 * Function pointers for wsconsctl parameter handling.
 * XXX These should be per-softc, but right now we only attach
 * XXX a single vga@@pci instance, so this will do.
 */
int	(*ws_get_param)(struct wsdisplay_param *);
int	(*ws_set_param)(struct wsdisplay_param *);


struct cfattach vga_pci_ca = {
	sizeof(struct vga_pci_softc), vga_pci_match, vga_pci_attach,
	NULL, vga_pci_activate
};

#if !defined(SMALL_KERNEL) && NACPI > 0
int vga_pci_do_post;

struct vga_device_description {
	u_int16_t	rval[4];
	u_int16_t	rmask[4];
	char		vga_pci_post;
};

static const struct vga_device_description vga_devs[] = {
	/*
	 * Header description:
	 *
	 * First entry is a list of the pci video information in the following
	 * order: VENDOR, PRODUCT, SUBVENDOR, SUBPRODUCT
	 *
	 * The next entry is a list of corresponding masks.
	 *
	 * Finally the last value indicates if we should repost via 
	 * vga_pci (i.e. the x86emulator) * bios.
	 */
	{	/* All machines with GMA500/Poulsbo */
	    {	PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_US15W_IGD,
	    	0x0000, 0x0000 },
	    {	0xffff, 0xffff, 0x0000, 0x0000 }, 1
	},
	{	/* All machines with GMA500/Poulsbo */
	    {	PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_US15L_IGD,
	    	0x0000, 0x0000 },
	    {	0xffff, 0xffff, 0x0000, 0x0000 }, 1
	},
	{	/* All machines with GMA600/Oaktrail, 0x4100:4107 */
	    {	PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_GMA600_0,
	    	0x0000, 0x0000 },
	    {	0xffff, 0xfff8, 0x0000, 0x0000 }, 1
	},
	{	/* All machines with GMA600/Oaktrail, 0x4108 */
	    {	PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_GMA600_8,
	    	0x0000, 0x0000 },
	    {	0xffff, 0xffff, 0x0000, 0x0000 }, 1
	},
	{	/* All machines with Medfield, 0x0130:0x0137 */
	    {	PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_MDFLD_IGD_0,
	    	0x0000, 0x0000 },
	    {	0xffff, 0xfff8, 0x0000, 0x0000 }, 1
	},
	{	/* All machines with GMA36x0/Cedartrail, 0x0be0:0x0bef */
	    {	PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_GMA3600_0,
	    	0x0000, 0x0000 },
	    {	0xffff, 0xfff0, 0x0000, 0x0000 }, 1
	},
};
#endif

int
vga_pci_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	if (DEVICE_IS_VGA_PCI(pa->pa_class) == 0)
		return (0);

	/* check whether it is disabled by firmware */
	if ((pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG)
	    & (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE))
	    != (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE))
		return (0);

	/* If it's the console, we have a winner! */
	if (vga_is_console(pa->pa_iot, WSDISPLAY_TYPE_PCIVGA))
		return (1);

	/*
	 * If we might match, make sure that the card actually looks OK.
	 */
	if (!vga_common_probe(pa->pa_iot, pa->pa_memt))
		return (0);

	return (1);
}

void
vga_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct pci_attach_args *pa = aux;
	pcireg_t reg;
	struct vga_pci_softc *sc = (struct vga_pci_softc *)self;
#if !defined(SMALL_KERNEL) && NACPI > 0
	int prod, vend, subid, subprod, subvend, i;
#endif

	/*
	 * Enable bus master; X might need this for accelerated graphics.
	 */
	reg = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	reg |= PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, reg);

	sc->sc_type = WSDISPLAY_TYPE_PCIVGA;

	printf("\n");

#if !defined(SMALL_KERNEL) && NACPI > 0

#ifdef X86EMU
	if ((sc->sc_posth = vga_post_init(pa->pa_bus, pa->pa_device,
	    pa->pa_function)) == NULL)
		printf("couldn't set up vga POST handler\n");
#endif

	vend = PCI_VENDOR(pa->pa_id);
	prod = PCI_PRODUCT(pa->pa_id);
	subid = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);
	subvend = PCI_VENDOR(subid);
	subprod = PCI_PRODUCT(subid);

	for (i = 0; i < nitems(vga_devs); i++)
		if ((vend & vga_devs[i].rmask[0]) == vga_devs[i].rval[0] &&
		    (prod & vga_devs[i].rmask[1]) == vga_devs[i].rval[1] &&
		    (subvend & vga_devs[i].rmask[2]) == vga_devs[i].rval[2] &&
		    (subprod & vga_devs[i].rmask[3]) == vga_devs[i].rval[3]) {
			vga_pci_do_post = vga_devs[i].vga_pci_post;
			break;
		}
#endif

#ifdef RAMDISK_HOOKS
	if (vga_aperture_needed(pa))
		printf("%s: aperture needed\n", sc->sc_dev.dv_xname);
#endif

	sc->sc_vc = vga_common_attach(self, pa->pa_iot, pa->pa_memt,
	    sc->sc_type);
}

int
vga_pci_activate(struct device *self, int act)
{
	int rv = 0;

#if !defined(SMALL_KERNEL) && NACPI > 0
	struct vga_pci_softc *sc = (struct vga_pci_softc *)self;
#endif

	switch (act) {
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);
#if !defined(SMALL_KERNEL) && NACPI > 0
		/*
		 * Save the common vga state. This should theoretically only
		 * be necessary if we intend to POST, but it is preferrable
		 * to do it unconditionnaly, as many systems do not restore
		 * this state correctly upon resume.
		 */
		vga_save_state(sc);
#endif
		break;
	case DVACT_RESUME:
#if !defined(SMALL_KERNEL) && NACPI > 0
#if defined (X86EMU)
		if (vga_pci_do_post)
			vga_post_call(sc->sc_posth);
#endif
		vga_restore_state(sc);
#endif
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}

	return (rv);
}

paddr_t
vga_pci_mmap(void *v, off_t off, int prot)
{
	return -1;
}

int
vga_pci_cnattach(bus_space_tag_t iot, bus_space_tag_t memt,
    pci_chipset_tag_t pc, int bus, int device, int function)
{
	return (vga_cnattach(iot, memt, WSDISPLAY_TYPE_PCIVGA, 0));
}

int
vga_pci_ioctl(void *v, u_long cmd, caddr_t addr, int flag, struct proc *pb)
{
	int error = 0;

	switch (cmd) {
	case WSDISPLAYIO_GETPARAM:
		if (ws_get_param != NULL)
			return (*ws_get_param)((struct wsdisplay_param *)addr);
		else
			error = ENOTTY;
		break;
	case WSDISPLAYIO_SETPARAM:
		if (ws_set_param != NULL)
			return (*ws_set_param)((struct wsdisplay_param *)addr);
		else
			error = ENOTTY;
		break;
	default:
		error = ENOTTY;
	}

	return (error);
}

#if !defined(SMALL_KERNEL) && NACPI > 0
void
vga_save_state(struct vga_pci_softc *sc)
{
	struct vga_config *vc = sc->sc_vc;
	struct vga_handle *vh;
	struct vgascreen *scr;
	size_t i;
	char *buf;

	if (vc == NULL)
		return;

	vh = &vc->hdl;

	/*
	 * Save sequencer registers
	 */
	vga_ts_write(vh, syncreset, 1);	/* stop sequencer */
	buf = (char *)&sc->sc_save_ts;
	*buf++ = 0;
	for (i = 1; i < sizeof(sc->sc_save_ts); i++)
		*buf++ = _vga_ts_read(vh, i);
	vga_ts_write(vh, syncreset, 3);	/* start sequencer */
	/* pretend screen is not blanked */
	sc->sc_save_ts.mode &= ~0x20;
	sc->sc_save_ts.mode |= 0x80;

	/*
	 * Save CRTC registers
	 */
	buf = (char *)&sc->sc_save_crtc;
	for (i = 0; i < sizeof(sc->sc_save_crtc); i++)
		*buf++ = _pcdisplay_6845_read(&vh->vh_ph, i);

	/*
	 * Save ATC registers
	 */
	buf = (char *)&sc->sc_save_atc;
	for (i = 0; i < sizeof(sc->sc_save_atc); i++)
		*buf++ = _vga_attr_read(vh, i);

	/*
	 * Save GDC registers
	 */
	buf = (char *)&sc->sc_save_gdc;
	for (i = 0; i < sizeof(sc->sc_save_gdc); i++)
		*buf++ = _vga_gdc_read(vh, i);

	vga_save_palette(vc);

	/* XXX should also save font data */

	/*
	 * Save current screen contents if we have backing store for it,
	 * and intend to POST on resume.
	 * XXX Since we don't allocate backing store unless the second VT is
	 * XXX created, we could theoretically have no backing store available
	 * XXX at this point.
	 */
	if (vga_pci_do_post) {
		scr = vc->active;
		if (scr != NULL && scr->pcs.active && scr->pcs.mem != NULL)
			bus_space_read_region_2(vh->vh_memt, vh->vh_memh,
			    scr->pcs.dispoffset, scr->pcs.mem,
			    scr->pcs.type->ncols * scr->pcs.type->nrows);
	}
}

void
vga_restore_state(struct vga_pci_softc *sc)
{
	struct vga_config *vc = sc->sc_vc;
	struct vga_handle *vh;
	struct vgascreen *scr;
	size_t i;
	char *buf;

	if (vc == NULL)
		return;

	vh = &vc->hdl;

	/*
	 * Restore sequencer registers
	 */
	vga_ts_write(vh, syncreset, 1);	/* stop sequencer */
	buf = (char *)&sc->sc_save_ts + 1;
	for (i = 1; i < sizeof(sc->sc_save_ts); i++)
		_vga_ts_write(vh, i, *buf++);
	vga_ts_write(vh, syncreset, 3);	/* start sequencer */

	/*
	 * Restore CRTC registers
	 */
	/* unprotect registers 00-07 */
	vga_6845_write(vh, vsynce,
	    vga_6845_read(vh, vsynce) & ~0x80);
	buf = (char *)&sc->sc_save_crtc;
	for (i = 0; i < sizeof(sc->sc_save_crtc); i++)
		_pcdisplay_6845_write(&vh->vh_ph, i, *buf++);

	/*
	 * Restore ATC registers
	 */
	buf = (char *)&sc->sc_save_atc;
	for (i = 0; i < sizeof(sc->sc_save_atc); i++)
		_vga_attr_write(vh, i, *buf++);

	/*
	 * Restore GDC registers
	 */
	buf = (char *)&sc->sc_save_gdc;
	for (i = 0; i < sizeof(sc->sc_save_gdc); i++)
		_vga_gdc_write(vh, i, *buf++);

	vga_restore_fonts(vc);
	vga_restore_palette(vc);

	/*
	 * Restore current screen contents if we have backing store for it,
	 * and have POSTed on resume.
	 * XXX Since we don't allocate backing store unless the second VT is
	 * XXX created, we could theoretically have no backing store available
	 * XXX at this point.
	 */
	if (vga_pci_do_post) {
		scr = vc->active;
		if (scr != NULL && scr->pcs.active && scr->pcs.mem != NULL)
			bus_space_write_region_2(vh->vh_memt, vh->vh_memh,
			    scr->pcs.dispoffset, scr->pcs.mem,
			    scr->pcs.type->ncols * scr->pcs.type->nrows);
	}
}
#endif
@


1.86
log
@
remove unused vesafb code, had been commented out and not compiled in for
7 years (for some parts, 9 years), and was only ever referenced in i386
anyway.

ok jsg@@, matthieu@@, armani@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.85 2015/07/18 00:48:05 miod Exp $ */
a65 1
#include "drm.h"
a95 2
#include "intagp.h"

a100 5
#if NINTAGP > 0
int	intagpsubmatch(struct device *, void *, void *);
int	intagp_print(void *, const char *);
#endif 

a221 2
	vga_pci_bar_init(sc, pa);

a250 15
#if NINTAGP > 0
	/*
	 * attach intagp here instead of pchb so it can share mappings
	 * with the DRM.
	 */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL) {
		config_found_sm(self, aux, intagp_print, intagpsubmatch);

	}
#endif

#if NDRM > 0
	config_found_sm(self, aux, NULL, vga_drmsubmatch);
#endif

a293 22

#if NINTAGP > 0
int
intagpsubmatch(struct device *parent, void *match, void *aux)
{
	extern struct cfdriver intagp_cd;
	struct cfdata *cf = match;

	/* only allow intagp to attach */
	if (cf->cf_driver == &intagp_cd)
		return ((*cf->cf_attach->ca_match)(parent, match, aux));
	return (0);
}

int
intagp_print(void *vaa, const char *pnp)
{
	if (pnp)
		printf("intagp at %s", pnp);
	return (UNCONF);
}
#endif
@


1.85
log
@Shuffle include file ordering in preparation for future changes in vgavar.h,
which will have it depend upon wsdisplayvar.h.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.84 2015/03/29 18:45:22 miod Exp $ */
a96 4
#ifdef VESAFB
#include <dev/vesa/vesabiosvar.h>
#endif

a108 5
#ifdef VESAFB
int	vesafb_putcmap(struct vga_pci_softc *, struct wsdisplay_cmap *);
int	vesafb_getcmap(struct vga_pci_softc *, struct wsdisplay_cmap *);
#endif

a227 9
#ifdef VESAFB
	if (vesabios_softc != NULL && vesabios_softc->sc_nmodes > 0) {
		sc->sc_textmode = vesafb_get_mode(sc);
		printf(", vesafb\n");
		sc->sc_vc = vga_extended_attach(self, pa->pa_iot, pa->pa_memt,
		    sc->sc_type, vga_pci_mmap);
		return;
	}
#endif
a344 10
#ifdef VESAFB
	struct vga_config *vc = (struct vga_config *)v;
	struct vga_pci_softc *sc = (struct vga_pci_softc *)vc->vc_softc;

	if (sc->sc_mode == WSDISPLAYIO_MODE_DUMBFB) {
		if (off < 0 || off > vesabios_softc->sc_size)
			return (-1);
		return (sc->sc_base + off);
	}
#endif
a358 7
#ifdef VESAFB
	struct vga_config *vc = (struct vga_config *)v;
	struct vga_pci_softc *sc = (struct vga_pci_softc *)vc->vc_softc;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_gfx_mode *gfxmode;
	int mode;
#endif
a360 63
#ifdef VESAFB
	case WSDISPLAYIO_SMODE:
		mode = *(u_int *)addr;
		switch (mode) {
		case WSDISPLAYIO_MODE_EMUL:
			/* back to text mode */
			vesafb_set_mode(sc, sc->sc_textmode);
			sc->sc_mode = mode;
			break;
		case WSDISPLAYIO_MODE_DUMBFB:
			if (sc->sc_gfxmode == -1)
				return (-1);
			vesafb_set_mode(sc, sc->sc_gfxmode);
			sc->sc_mode = mode;
			break;
		default:
			error = -1;
		}
		break;
	case WSDISPLAYIO_GINFO:
		if (sc->sc_gfxmode == -1)
			return (-1);
		wdf = (void *)addr;
		wdf->height = sc->sc_height;
		wdf->width = sc->sc_width;
		wdf->depth = sc->sc_depth;
		wdf->cmsize = 256;
		break;

	case WSDISPLAYIO_LINEBYTES:
		if (sc->sc_gfxmode == -1)
			return (-1);
		*(u_int *)addr = sc->sc_linebytes;
		break;

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;
	case WSDISPLAYIO_GETCMAP:
		if (sc->sc_depth == 8)
			error = vesafb_getcmap(sc,
			    (struct wsdisplay_cmap *)addr);
		break;

	case WSDISPLAYIO_PUTCMAP:
		if (sc->sc_depth == 8)
			error = vesafb_putcmap(sc,
			    (struct wsdisplay_cmap *)addr);
		break;

	case WSDISPLAYIO_GETSUPPORTEDDEPTH:
		*(int *)addr = vesafb_get_supported_depth(sc);
		break;
		
	case WSDISPLAYIO_SETGFXMODE:
		gfxmode = (struct wsdisplay_gfx_mode *)addr;
		sc->sc_gfxmode = vesafb_find_mode(sc, gfxmode->width,
		    gfxmode->height, gfxmode->depth);
		if (sc->sc_gfxmode == -1) 
			error = -1;
		break;

#endif
@


1.84
log
@Restore user-loaded vga fonts upon X11->VT switch and upon resume; from
dan mclaughlin, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.83 2015/03/14 03:38:49 jsg Exp $ */
a86 1
#include <dev/ic/vgavar.h>
d91 1
@


1.83
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.82 2014/12/06 03:01:42 jsg Exp $ */
d594 1
@


1.82
log
@Repost video on all known Intel PowerVR devices not just GMA500, for
people unfortunate enough to own such machines.

Fixes broken suspend/resume on an Acer Aspire One D27-1375 with GMA36x0
reported by Sean Cody.

ok deraadt@@ mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.81 2014/07/28 15:00:27 jsg Exp $ */
a82 2

#include <dev/pci/agpvar.h>
@


1.81
log
@Limit the "aperture needed" printf to ramdisks via RAMDISK_HOOKS.
Originally with SMALL_KERNEL until sebastia@@ pointed out that not
all ramdisks are built with SMALL_KERNEL.
ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.80 2014/07/22 04:42:51 jsg Exp $ */
d160 1
a160 1
	{	/* All machines with Intel US15W (until more evidence) */
d165 1
a165 1
	{	/* All machines with Intel US15L (until more evidence) */
d169 20
@


1.80
log
@The aperture needed test should be in vgafb as well as vga@@pci.
Problem noticed/fix tested by sebastia@@ on macppc.
sparc64 problems in earlier diff pointed out by deraadt@@
'looks good' kettenis@@ 'commit' deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.79 2014/07/12 23:16:23 jsg Exp $ */
a123 1
int	vga_aperture_needed(struct pci_attach_args *);
d256 1
d259 1
@


1.79
log
@Print a line in dmesg to indicate if the aperture driver is
required to run X.  This will be used by the installer to decide
what value to set machdep.allowaperture to.

For devices supported by i915 and radeon kms machdep.allowaperture
will be set to 0.  Systems that have a graphics device commonly
found in servers (g200e*/aspeed/es1000 etc) will also not have
the aperture enabled as they generally don't need to run X.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.78 2014/06/01 00:37:37 mlarkin Exp $ */
a83 3
#include <dev/pci/drm/i915/i915_devlist.h>
#include <dev/pci/drm/radeon/radeon_devlist.h>

a173 22
static const struct pci_matchid aperture_blacklist[] = {
	/* server adapters found in mga200 drm driver */
	{ PCI_VENDOR_MATROX,	PCI_PRODUCT_MATROX_G200E_SE },
	{ PCI_VENDOR_MATROX,	PCI_PRODUCT_MATROX_G200E_SE_B },
	{ PCI_VENDOR_MATROX,	PCI_PRODUCT_MATROX_G200EH },
	{ PCI_VENDOR_MATROX,	PCI_PRODUCT_MATROX_G200ER },
	{ PCI_VENDOR_MATROX,	PCI_PRODUCT_MATROX_G200EV },
	{ PCI_VENDOR_MATROX,	PCI_PRODUCT_MATROX_G200EW },

	/* server adapters found in ast drm driver */
	{ PCI_VENDOR_ASPEED,	PCI_PRODUCT_ASPEED_AST2000 },
	{ PCI_VENDOR_ASPEED,	PCI_PRODUCT_ASPEED_AST2100 },

	/* ati adapters found in servers */
	{ PCI_VENDOR_ATI,		PCI_PRODUCT_ATI_RAGEXL },
	{ PCI_VENDOR_ATI,		PCI_PRODUCT_ATI_ES1000 },

	/* xgi found in some poweredges/supermicros/tyans */
	{ PCI_VENDOR_XGI,		PCI_PRODUCT_XGI_VOLARI_Z7 },
	{ PCI_VENDOR_XGI,		PCI_PRODUCT_XGI_VOLARI_Z9 },
};

a197 13
	return (1);
}

int
vga_aperture_needed(struct pci_attach_args *pa)
{
#if defined(__i386__) || defined(__amd64__) || \
    defined(__sparc64__) || defined(__macppc__)
	if (pci_matchbyid(pa, i915_devices, nitems(i915_devices)) ||
	    pci_matchbyid(pa, radeon_devices, nitems(radeon_devices)) ||
	    pci_matchbyid(pa, aperture_blacklist, nitems(aperture_blacklist)))
		return (0);
#endif
@


1.78
log
@
Remove real mode VGA repost option. It was used by nobody, and even if it
were to be enabled, it had a bug that prevented it from working anyway.

ok deraadt@@, kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.77 2014/03/28 17:57:11 mpi Exp $ */
d84 3
d127 1
a127 1

d177 22
d226 13
d294 3
@


1.77
log
@Reduce uvm include madness.  Use <uvm/uvm_extern.h> instead of
<uvm/uvm.h> if possible and remove double inclusions.

ok beck@@, mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.76 2014/03/26 14:41:41 mpi Exp $ */
a141 1
extern int do_real_mode_post;
d146 1
a146 2
	char	vga_pci_post;
	char	real_mode_post;
d158 2
a159 3
	 * Finally the last two values set what resume should do, repost with
	 * vga_pci (i.e. the x86emulator) or with a locore call to the video
	 * bios.
d164 1
a164 1
	    {	0xffff, 0xffff, 0x0000, 0x0000 }, 1, 0
d169 1
a169 1
	    {	0xffff, 0xffff, 0x0000, 0x0000 }, 1, 0
a252 2
			if (sc->sc_dev.dv_unit == 0)	/* main screen only */
				do_real_mode_post = vga_devs[i].real_mode_post;
d301 1
a301 5
		if (vga_pci_do_post) {
#ifdef obnoxious
			printf("%s: reposting video using BIOS.  Is this necessary?\n",
			    sc->sc_dev.dv_xname);
#endif
a302 1
		}
@


1.76
log
@No need to include <sys/lock.h> when only <sys/rwlock.h> is needed,
so remove the former and include the latter instead of pulling it
in <dev/pci/agpvar.h>.  This header already requires various other
types anyway.  While here remove unneeded headers.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.75 2014/03/17 22:01:56 kettenis Exp $ */
a76 2

#include <uvm/uvm.h>
@


1.75
log
@The AGP ioctl interface is gone; remove the header file as well.

ok matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.74 2013/12/06 21:03:04 deraadt Exp $ */
d76 1
@


1.74
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.73 2013/08/12 04:11:52 jsg Exp $ */
a75 1
#include <sys/agpio.h>
@


1.73
log
@Add a port of the TTM and Radeon DRM code from Linux 3.8.13.
Includes kernel modesetting, framebuffer console and support
for newer hardware.

Firmware needs to be present for acceleration and in some cases
modesetting to work.  It can be installed via fw_update
or manually via pkg_add.

With lots of help from kettenis@@ some macppc bits from mpi@@
and some ttm refcount/queue bits from FreeBSD.

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.72 2013/03/26 18:45:02 kettenis Exp $ */
a292 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
d320 1
a320 1
	case DVACT_POWERDOWN:
@


1.72
log
@Stop rePOSTing devices supported by inteldrm(4).  The driver now properly
restores the graphics mode and we should avoid running BIOS code whenever
possible as it isn't guaranteed to work and might actually hurt.

ok jsg@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.71 2013/03/18 10:12:40 kettenis Exp $ */
a175 6

	{	/* All ATI video until further notice */
	    {	PCI_VENDOR_ATI, 0x0000,
		0x0000, 0x0000 },
	    {	0xffff, 0x0000, 0x0000, 0x0000}, 1, 0
	},
d276 1
a276 1
	config_found_sm(self, aux, NULL, drmsubmatch);
@


1.71
log
@Provide a way for *drm(4) to prevent the VGA text console wsdisplay(4) instance
from attaching after it has taken over control of the VGA hardware.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.70 2013/03/04 21:52:36 kettenis Exp $ */
a172 12
	    	0x0000, 0x0000 },
	    {	0xffff, 0xffff, 0x0000, 0x0000 }, 1, 0
	},

	{	/*  Anything with on-die intel graphics, for now */
	    {	PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_ARRANDALE_IGD,	
	    	0x0000, 0x0000 },
	    {	0xffff, 0xffff, 0x0000, 0x0000 }, 1, 0
	},

	{	/*  Anything with on-die intel graphics, for now */
	    {	PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_CLARKDALE_IGD,
@


1.70
log
@Reorder code such that wsdisplay(4) attaches after drm(4).
Preparation for framebuffer console support on amd64/i386.

tested by many
ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.69 2012/10/08 21:47:50 deraadt Exp $ */
a229 1

d241 2
d248 1
a248 1
		    WSDISPLAY_TYPE_PCIVGA, vga_pci_mmap);
d298 1
a298 1
	    WSDISPLAY_TYPE_PCIVGA);
@


1.69
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.68 2012/08/22 20:58:30 mpi Exp $ */
a251 2
	sc->sc_vc = vga_common_attach(self, pa->pa_iot, pa->pa_memt,
	    WSDISPLAY_TYPE_PCIVGA);
d295 3
@


1.68
log
@Split out the bar functions required to attach drm(4) to share them
with macppc's vgafb(4) and maybe later on sparc64 drivers too.

suggested by and ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.67 2011/04/14 21:04:29 oga Exp $ */
d337 3
@


1.67
log
@Spacing nit.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.66 2011/04/14 21:02:20 oga Exp $ */
d66 1
a93 1

a105 1
#include "drm.h"
a110 1
void	vga_pci_bar_init(struct vga_pci_softc *, struct pci_attach_args *);
a115 4
#if NDRM > 0
int	drmsubmatch(struct device *, void *, void *);
int	vga_drm_print(void *, const char *);
#endif
d135 1
a135 1
    
a365 21
#if NDRM > 0
int
drmsubmatch(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct cfdriver *cd;
	size_t len = 0;
	char *sm;

	cd = cf->cf_driver;

	/* is this a *drm device? */
	len = strlen(cd->cd_name);
	sm = cd->cd_name + len - 3;
	if (strncmp(sm, "drm", 3) == 0)
		return ((*cf->cf_attach->ca_match)(parent, match, aux));

	return (0);
}
#endif

a481 110
}

#ifdef notyet
void
vga_pci_close(void *v)
{
}
#endif

/*
 * Prepare dev->bars to be used for information. we do this at startup
 * so we can do the whole array at once, dealing with 64-bit BARs correctly.
 */
void
vga_pci_bar_init(struct vga_pci_softc *dev, struct pci_attach_args *pa)
{
	pcireg_t type;
	int addr = PCI_MAPREG_START, i = 0;
	memcpy(&dev->pa, pa, sizeof(dev->pa));

	while (i < VGA_PCI_MAX_BARS) {
		dev->bars[i] = malloc(sizeof((*dev->bars[i])), M_DEVBUF,
		    M_NOWAIT | M_ZERO);
		if (dev->bars[i] == NULL) {
			return;
		}

		dev->bars[i]->addr = addr;

		type = dev->bars[i]->maptype = pci_mapreg_type(pa->pa_pc,
		    pa->pa_tag, addr);
		if (pci_mapreg_info(pa->pa_pc, pa->pa_tag, addr,
		    dev->bars[i]->maptype, &dev->bars[i]->base,
		    &dev->bars[i]->maxsize, &dev->bars[i]->flags) != 0) {
			free(dev->bars[i], M_DEVBUF);
			dev->bars[i] = NULL;
		}

		if (type == PCI_MAPREG_MEM_TYPE_64BIT) {
			addr += 8;
			i += 2;
		} else {
			addr += 4;
			i++;
		}
	}
}

/*
 * Get the vga_pci_bar struct for the address in question. returns NULL if
 * invalid BAR is passed.
 */
struct vga_pci_bar*
vga_pci_bar_info(struct vga_pci_softc *dev, int no)
{
	if (dev == NULL || no >= VGA_PCI_MAX_BARS)
		return (NULL);
	return (dev->bars[no]);
}

/*
 * map the BAR in question, returning the vga_pci_bar struct in case any more
 * processing needs to be done. Returns NULL on failure. Can be called multiple
 * times.
 */
struct vga_pci_bar*
vga_pci_bar_map(struct vga_pci_softc *dev, int addr, bus_size_t size,
    int busflags)
{
	struct vga_pci_bar *bar = NULL;
	int i;

	if (dev == NULL) 
		return (NULL);

	for (i = 0; i < VGA_PCI_MAX_BARS; i++) {
		if (dev->bars[i] && dev->bars[i]->addr == addr) {
			bar = dev->bars[i];
			break;
		}
	}
	if (bar == NULL) {
		printf("vga_pci_bar_map: given invalid address 0x%x\n", addr);
		return (NULL);
	}

	if (bar->mapped == 0) {
		if (pci_mapreg_map(&dev->pa, bar->addr, bar->maptype,
		    bar->flags | busflags, &bar->bst, &bar->bsh, NULL,
		    &bar->size, size)) {
			printf("vga_pci_bar_map: can't map bar 0x%x\n", addr);
			return (NULL);
		}
	}

	bar->mapped++;
	return (bar);
}

/*
 * "unmap" the BAR referred to by argument. If more than one place has mapped it
 * we just decrement the reference counter so nothing untoward happens.
 */
void
vga_pci_bar_unmap(struct vga_pci_bar *bar)
{
	if (bar != NULL && bar->mapped != 0) {
		if (--bar->mapped == 0)
			bus_space_unmap(bar->bst, bar->bsh, bar->size);
	}
@


1.66
log
@For the time being repost Intel clarkdale IGD.

Arrandale (on laptop i3 and i5) was already doing this, but Clarkdale (the
desktop chipsets) wasn't. This gives mikeb@@'s desktop a chance to get the video
back on resume.

While here, remove the vendor/subvendor ids from the Arrandale entry.
Just because someone doesn't have the same laptops as tested doesn't
mean inteldrm magically has the ability to restore the graphics chip.
This is possible to do without repost but fiddly and will take me a
while to sort out, so just repost the whole sodding lot for now.

ok ketteis@@, deraadt@@, mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.65 2010/12/26 15:41:00 miod Exp $ */
d551 2
a552 2
			addr+=4;
			++i;
@


1.65
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.64 2010/08/31 17:13:44 deraadt Exp $ */
d183 1
a183 1
	{	/* Thinkpad T510 (and similar models) */
d185 2
a186 2
	    	0x17aa, 0x215a },
	    {	0xffff, 0xffff, 0xffff, 0xffff }, 1, 0
d188 5
a192 4
	{	/* HP G62 (and similar models) */
	    {	PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_ARRANDALE_IGD,	
	    	0x103c, 0x1425 },
	    {	0xffff, 0xffff, 0xffff, 0xffff }, 1, 0
@


1.64
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.63 2010/08/08 19:33:35 miod Exp $ */
d402 1
a402 1
		return atop(sc->sc_base + off);
@


1.63
log
@fix broken english in commented out printf.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.62 2010/08/08 17:21:07 miod Exp $ */
d314 3
@


1.62
log
@Try to save the vga hardware state around suspend, and also redisplay the
textmode video memory contents if we had to POST the vga bios.
ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.61 2010/08/06 18:32:38 marco Exp $ */
d331 1
a331 1
			printf("%s: reposting video using BIOS.  Is this neccessary?\n",
@


1.61
log
@repost hp g62

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.60 2010/08/04 23:23:36 deraadt Exp $ */
d66 3
a106 3
#if defined(__i386__) || defined(__amd64__)
#include "acpi.h"
#endif
d124 7
a130 2
int vesafb_putcmap(struct vga_pci_softc *, struct wsdisplay_cmap *);
int vesafb_getcmap(struct vga_pci_softc *, struct wsdisplay_cmap *);
d251 1
a251 1
		vga_extended_attach(self, pa->pa_iot, pa->pa_memt,
d257 1
a257 1
	vga_common_attach(self, pa->pa_iot, pa->pa_memt,
d262 2
a269 1
#if !defined(SMALL_KERNEL) && NACPI > 0
d309 1
a309 1
#if defined (X86EMU) && NACPI > 0
d316 9
d327 2
a328 1
#if defined (X86EMU) && NACPI > 0
d330 1
d333 1
d337 2
d616 135
@


1.60
log
@re-post all ATI and all PowerVR (with an annoying message)
ok kettenis oga pirofti
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.59 2010/08/04 18:29:43 matthew Exp $ */
d181 5
@


1.59
log
@Add missing brace.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.58 2010/08/04 17:50:38 deraadt Exp $ */
d167 9
a175 4
	{	/* Sony VGN-P530H */
	    {	PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_US15W_IGD,	
	    	PCI_VENDOR_SONY, 0x9039 },
	    {	0xffff, 0xffff, 0xffff, 0xffff }, 1, 0
d177 1
d183 5
a187 14
	{	/* Lenovo ThinkPad X100e */
	    {	PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3200_2,
		0x17aa, 0x21b2 },
	    {	0xffff, 0xffff, 0xffff, 0xffff}, 1, 0
	},
	{	/* Gateway LT3103u (ATI Radeon X1250/RS690) */
	    {	PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1250IGP,
		0x1025, 0x028c },
	    {	0xffff, 0xffff, 0xffff, 0xffff}, 1, 0
	},
	{	/* Thinkpad T43p with ATI FireGL (M24) */
	    {	PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_M24GL,
		0x1014, 0x0570 },
	    {	0xffff, 0xffff, 0xffff, 0xffff}, 1, 0
a188 5
	{	/* HP Pavilion dv7-3160us with ATI Radeon HD4500 */
	    {	PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4500_M,
		0x103c, 0x3639 },
	    {	0xffff, 0xffff, 0xffff, 0xffff}, 1, 0
	}
@


1.58
log
@Print annoying stuff when re-posting the video, so that people will
eventually want to remove their video cards from the list here.
ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.57 2010/07/27 07:42:34 mlarkin Exp $ */
d320 1
@


1.57
log
@

Repost ATI Radeon HD4500 on HP Pavilion dv7-3160us using the emulator,
in the same style we have done for all other ATI Radeon devices found so
far. Fixes video on said machine on resume.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.56 2010/07/21 07:50:20 mlarkin Exp $ */
d316 3
a318 1
		if (vga_pci_do_post)
@


1.56
log
@

Repost ATI FireGL M24 using the emulator. This card is seen on some IBM
Thinkpad T43p models (and likely others).
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.55 2010/07/20 05:18:22 mlarkin Exp $ */
d190 5
@


1.55
log
@

VGA repost for ATI Radeon X1250IGP (as found on Gateway netbooks and
others). Repost via emulator or real mode code, either one works. Used the
emulator to keep it consistent with other Radeon devices already listed.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.54 2010/07/14 11:21:53 matthieu Exp $ */
d185 5
@


1.54
log
@Let vga_pci.c build in kernel configs without acpi. ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.53 2010/07/02 00:23:42 pirofti Exp $ */
d180 5
@


1.53
log
@Add Lenovo ThinkPad X100e quirk, from Brad.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.52 2010/07/02 00:09:37 pirofti Exp $ */
d104 3
d143 1
a143 1
#if !defined(SMALL_KERNEL) && (defined (__i386__) || defined (__amd64__))
d219 1
a219 1
#if !defined(SMALL_KERNEL) && (defined (__i386__) || defined (__amd64__))
d251 1
a251 1
#if !defined(SMALL_KERNEL) && (defined (__i386__) || defined (__amd64__))
d291 1
a291 1
#if defined (X86EMU) && (defined (__i386__) || defined (__amd64__))
d300 1
a300 1
#if defined (X86EMU) && (defined (__i386__) || defined (__amd64__))
@


1.52
log
@Switch to nitems for the table, save some space. `Looks good' deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.51 2010/07/01 23:38:29 mlarkin Exp $ */
d173 5
@


1.51
log
@

Repost T510 video using the emulator.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.50 2010/07/01 22:51:23 pirofti Exp $ */
a172 5
	},
	{
		/* NULL */
	    {	0,	0,	0,	0     },
	    {	0,	0,	0,	0     }, 0, 0
d250 1
a250 2
	for (i = 0; vga_devs[i].rval[0] && vga_devs[i].rval[1] &&
	    vga_devs[i].rval[2] && vga_devs[i].rval[3]; i++)
@


1.50
log
@It seems the x200s doesn't need the video bios call from locore.

Retested on yuo's machine with a clean kernel and it works fine without the
hack. This should also fix the issues other x200s users were seeing with
resuming from X.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.49 2010/07/01 17:05:06 deraadt Exp $ */
d167 5
@


1.49
log
@See, I said the #ifdef's are a confusing maze -- they confused me.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.48 2010/07/01 16:31:36 deraadt Exp $ */
a167 5
	},
	{	/* Thinkpad x200s */
	    {	PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82GM45_IGD_1, 
	    	0x17aa, 0x20e4 },	
	    {	0xffff, 0xffff, 0xffff, 0xffff }, 0, 1
@


1.48
log
@Make this compile with SMALL_KERNEL.  The #ifdef farm this produces should
probably be cleaned up...
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.47 2010/07/01 01:02:31 pirofti Exp $ */
d140 1
a140 1
#if !defined(SMALL_KERNEL) && defined (__i386__) || defined (__amd64__)
d216 1
a216 1
#if !defined(SMALL_KERNEL) && defined (__i386__) || defined (__amd64__)
d248 1
a248 1
#if !defined(SMALL_KERNEL) && defined (__i386__) || defined (__amd64__)
@


1.47
log
@Add a look-up table for machines that have special vga cards. This table will
tell, based on vendor/product/subvendor/subproduct ids, how the video reposting
should be done: via the emulator or the bios video call in locore. The default
is to do none of those, which is how most machines work.

Okay kettenis@@, deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.46 2009/11/28 22:43:22 kettenis Exp $ */
d140 1
a140 1
#if defined (__i386__) || defined (__amd64__)
d216 1
a216 1
#if defined (__i386__) || defined (__amd64__)
d248 1
a248 1
#if defined (__i386__) || defined (__amd64__)
@


1.46
log
@Fix previous; pointed out by stsp@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.45 2009/11/28 22:15:59 kettenis Exp $ */
d140 42
d216 4
d248 20
d289 4
d298 4
@


1.45
log
@Make sure we pass on DVACT_SUSPEND and DVACT_RESUME requests to our children
such that inteldrm(4) stands a chance at actually saving and restoring its
state.  Makes it possible to start X after a suspend/resume cycle on my
Dell laptop with Intel graphics.

ok jsg@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.44 2009/06/06 04:38:18 pirofti Exp $ */
a220 1
	struct vga_pci_softc *sc = (struct vga_pci_softc *)self;
@


1.44
log
@Remove the last VGA_POST defines with X86EMU. Okay deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.43 2009/06/06 00:35:00 pirofti Exp $ */
d107 1
d137 1
d216 18
@


1.43
log
@Add vga bios repost support. Fetched from the NetBSD tree mostly.

Tested on multiple i386 and it works, amd64 works also with a few
exceptions that will get fixed.

The initial effort of importing was done by oga@@, thanks!

Lots of testing and debugging by mlarkin@@ and me.
Okay deraadt@@, oga@@, mlarkin@@.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.42 2009/06/03 23:33:01 miod Exp $ */
d94 1
a94 1
#ifdef VGA_POST
d194 1
a194 1
#ifdef VGA_POST
@


1.42
log
@Make sure to fail WSDISPLAYIO_[GS]ETPARAM if it is not handled.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.41 2009/06/03 00:36:59 pirofti Exp $ */
d94 4
d193 6
@


1.41
log
@Add acpivideo support. This adds brightness support for all laptops
except thinkpads, they will use the acpithinkpad driver. The driver is
also hooked into wsconsole. So brightness can be adjusted via:

$ wsconsctl display.brightness=<percentage>

This is very helpfull on some laptops that have a nasty bios and get two
steps instead of one when pressing the brightness button.

Tested on various dell, fujitsu, acer, samsung and other laptops.

Okay marco@@, miod@@. Suggestions from kettenis@@.
Lots of reviews and help from miod@@, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.40 2009/06/02 11:22:45 deraadt Exp $ */
d349 1
a349 1
		if(ws_get_param != NULL)
d351 2
d355 1
a355 1
		if(ws_set_param != NULL)
d357 2
@


1.40
log
@Do not go one bar too far down the road; found by Parfait; ok oga
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.39 2008/11/22 21:26:48 oga Exp $ */
d120 10
d348 8
@


1.39
log
@Move the drm drivers over from:

vga1 at pci0
inteldrm0 at vga1

to

vga1 at pci0
inteldrm0 at vga1
drm0 at inteldrm0

i.e. a similar scheme to audio(4) where the interface attaches on top of
the wildly different drivers. This helps to clean up the code a lot
(more is coming) and help me start to move drm to being essentially bus
independent, which will help in the future.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.38 2008/11/09 15:11:19 oga Exp $ */
d398 1
a398 1
	if (dev == NULL || no > VGA_PCI_MAX_BARS)
@


1.38
log
@Rework that way that agp attaches.

previously, we had a static list of pcidevs and which agp driver would
be interanlly attached. Instead, split the agp drivers so they work like
audio(4), where we attach a driver, which sets up some callbacks and
initial state, then attaches the interface (agp(4)). Since this allows
us to attach different drivers in different places, and give them
/proper/ probe functions move most of the drivers back to attaching at
pchb, where they should, and intagp (formerly agp_i810) stays attaching
at vga, since it's part of the intel integrated graphics chips.

Diff shrinks the kernel slightly, gets rid of the annoying "no integrated
graphics" warning, and allows more cleanup later.

Tested by many. fix for alpha build (the only other vga_pci.c consumer)
suggested by miod.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.37 2008/08/12 23:10:41 oga Exp $ */
d99 1
a99 1
#include "drmbase.h"
d110 1
a110 1
#if NDRMBASE > 0
d191 1
a191 1
#if NDRMBASE > 0
d218 1
a218 1
#if NDRMBASE > 0
@


1.37
log
@Kill dmesg spam. Since we can't guarantee that a device is capable of
having a drm driver, don't print when we fail to attach one.

stops the "drm at vga? not supported" spam people are seeing.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.36 2008/08/10 00:18:35 brad Exp $ */
d98 1
a98 1
#include "agp.h"
d106 3
a108 3
#if NAGP > 0
int	agpsubmatch(struct device *, void *, void *);
int	agpbus_print(void *, const char *);
a123 14
#if NAGP > 0
struct pci_attach_args agp_pchb_pa;
int agp_pchb_pa_set = 0;

void
agp_set_pchb(struct pci_attach_args *pa)
{
	if (!agp_pchb_pa_set) {
		memcpy(&agp_pchb_pa, pa, sizeof *pa);
		agp_pchb_pa_set++;
	}
}
#endif

a154 3
#if NAGP >0
	struct agpbus_attach_args aba;
#endif
d180 1
a180 1
#if NAGP > 0
d182 2
a183 2
	 * attach agp here instead of pchb so it can share mappings
	 * with the DRM
d185 2
a186 4
	if (agp_pchb_pa_set) {
		aba.apa_pci_args = agp_pchb_pa;
		memcpy(&aba.apa_vga_args, pa, sizeof(struct pci_attach_args));
		config_found_sm(self, &aba, agpbus_print, agpsubmatch);
d196 1
a196 1
#if NAGP > 0
d198 1
a198 1
agpsubmatch(struct device *parent, void *match, void *aux)
d200 1
a200 1
	extern struct cfdriver agp_cd;
d203 2
a204 2
	/* only allow agp to attach */
	if (cf->cf_driver == &agp_cd)
d210 1
a210 1
agpbus_print(void *vaa, const char *pnp)
d213 1
a213 1
		printf("agp at %s", pnp);
@


1.36
log
@Style fixes and use of tabs for the DRM bits.

ok oga@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.35 2008/08/02 15:50:34 oga Exp $ */
d211 1
a211 1
	config_found_sm(self, aux, vga_drm_print, drmsubmatch);
a254 8
}

int
vga_drm_print(void *aux, const char *pnp)
{
	if (pnp)
		printf("drm at %s", pnp);
	return (UNSUPP);
@


1.35
log
@make the drm unsupported printf more in line with how the rest of them
work.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.34 2008/07/12 17:31:06 oga Exp $ */
d250 2
a251 2
	sm = cd->cd_name + len -3;
	if (strncmp(sm,"drm",3) == 0)
d260 3
a262 3
       if (pnp)
               printf("drm at %s", pnp);
       return (UNSUPP);
@


1.34
log
@Right now agp_generic_enable() is wrong. It has been since 2006. It
assumes that the display device and the agp bridge are the same device.
In almost all cases this is incorrect.

In order to correctly enable the agp device with the correct mode, we
need to set the AGP_COMMAND register on both the display and the bridge
with the right bits. Since agp is currently attaching at vga(4), due to
the problems with the intel integrated graphics (a problem that I still
need to solve, to be honest), for now just provide both pci_attach_args
to the agp init, and get what we need from there to do the enable.

This fixes the "agp bug" which i have been known to rant about, a lot.
So agp radeons now work with dri without needing to be forced to pci
mode.

This wasn't detected before, since the only non-drm consumer of agp is
the intel X driver, the i810 agp driver has its own enable function.

tested by many. ok kettenis@@.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.33 2008/06/12 00:58:47 oga Exp $ */
d261 1
a261 1
               printf("direct rendering for %s", pnp);
@


1.33
log
@Skip 64-bit BARs correctly when initing.

ok marco@@.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.32 2008/06/03 17:14:21 brad Exp $ */
d204 1
@


1.32
log
@Simplify the use of pci_mapreg_map().

ok oga@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.31 2008/05/06 19:19:02 oga Exp $ */
d407 7
a413 2
		addr+=4;
		++i;
@


1.31
log
@currently agp_i810 needs to map the same BAR as inteldrm, this obviously
fails.

In order to allow this, implement an API so that drm and agp can share
mappings for the BARs. Now it works as it should.

tested by many.
ok kettenis, miod said he'd look at it when it's in tree.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.30 2008/03/16 19:00:28 oga Exp $ */
d451 3
a453 8
		switch (bar->maptype) {
		case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
		case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
			if (pci_mapreg_map(&dev->pa, bar->addr, bar->maptype,
			    bar->flags | busflags, &bar->bst, &bar->bsh, NULL,
			    &bar->size, size) == 0)
				break;
		default:
@


1.30
log
@Make agp(4) attach at vga(4) instead of pchb(4). This is because sometimes
agp and drm need to use the same memory mapping, the best way to deal
with that is to allow them to share (that's coming later), for this to
work cleanly we move the attach point of agp.

Ideally most agp drivers would attach at pchb, with only agp_i810
(and any that work similarly) attaching at vga, but this will do for
now.

ok kettenis@@, miod@@.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.29 2007/11/28 23:37:34 oga Exp $ */
d104 1
a172 1
#ifdef VESAFB
a173 1
#endif
d195 2
d377 103
@


1.29
log
@Initial import of the DRM (direct rendering manager).

This is the kernel part necessary for DRI support in X. Disabled for now
because it still has a few bugs, but now I can work on it in tree. Also
requires the requisite bits in X, which are currently under discussion
on how to deal with them with privsep. ported from a combination of the
free and netbsd implementations.

Known bugs:
1) only the first occurence of X in any session will have dri, after
that something prevents it working.
2) if the machine does not have a dri capable card, the kernel panics.
Something's up in one of the probe functions. I haven't been able to
find it though.
3) radeon cards need to be forced to use PCI mode otherwise they get
into an infinite loop.

This is known to at least kinda work with SiS, radeons in pci mode and
intel cards.

ok deraadt, kinda ok art, a few other people had a quick look.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.28 2007/11/25 17:11:12 oga Exp $ */
d82 2
d98 1
d104 9
a112 1
int vga_drm_print(void *, const char *);
d123 14
d168 3
d196 12
d209 1
a209 1
	config_found(self, aux, vga_drm_print);
d213 42
d262 1
@


1.28
log
@Make agp attach as a device. This means that many more agp bridges
actually get detected and attached. Also adds a kernel api for
manipulating agp.

Enable this on i386 and amd64.

"I think you should commit it" deraadt@@, ok matthieu. Looked over by
several others.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.27 2007/11/03 10:09:03 martin Exp $ */
d96 2
d101 1
d167 12
@


1.27
log
@use DEVICE_IS_VGA_PCI in vga_pci_match()

ok brad@@ fgsch@@ also tested by oga@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.26 2007/01/28 20:28:50 gwk Exp $ */
a151 3
#ifdef PCIAGP
	agp_attach(parent, self, aux);
#endif
a178 3
#ifdef PCIAGP
	return agp_mmap(v, off, prot);
#else
a179 1
#endif
a264 12
#ifdef PCIAGP
	case AGPIOC_INFO:
	case AGPIOC_ACQUIRE:
	case AGPIOC_RELEASE:
	case AGPIOC_SETUP:
	case AGPIOC_ALLOCATE:
	case AGPIOC_DEALLOCATE:
	case AGPIOC_BIND:
	case AGPIOC_UNBIND:
		error = agp_ioctl(v, cmd, addr, flag, pb);
		break;
#endif
a275 3
#ifdef PCIAGP
	agp_close(v);
#endif
@


1.26
log
@Fix a number of issues with vesabios discovered by miod@@

1. Add bounds checking to vga_pci_mmap, fixing a potential security issue.
Limit the amount of memory to what the vbe info structure says the card
card has. This should be nicely refined to limit to the amount of memory
needed by the active resolution and depth but this will do for the time
being.

2. Fix several places in vesafb.c where the return of kvm86_bios_addpage()
isnt being checked. Also ensure that if vesafb_get_mode_info() fails that it
cleans up after itself by releasing the page it added.

3. Correct the range checks in vesafb_putcmap and vesafb_getcmap, harmonize
code with similar code found else where.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.25 2006/11/27 18:04:28 gwk Exp $ */
a112 1
	int potential;
d114 1
a114 14
	potential = 0;

	/*
	 * If it's prehistoric/vga or display/vga, we might match.
	 * For the console device, this is jut a sanity check.
	 */
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_PREHISTORIC &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_PREHISTORIC_VGA)
		potential = 1;
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_DISPLAY &&
	     PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_DISPLAY_VGA)
		potential = 1;

	if (!potential)
@


1.25
log
@commit vesabios for matthieu@@
ok deraadt, "slap it in" miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.24 2006/07/20 20:54:51 kettenis Exp $ */
d178 1
a178 1
 	printf("\n");
d191 2
@


1.24
log
@Enable bus master; X probably needs it to do accelerated graphics.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.23 2006/03/16 21:32:34 matthieu Exp $ */
d92 4
d100 5
d155 3
d169 10
a178 1
	printf("\n");
d186 8
d202 1
a202 1
vga_pci_cnattach(bus_space_tag_t iot, bus_space_tag_t memt, 
d212 7
d221 63
@


1.23
log
@Move the agpgart handling code to a separate file.
Ansify some remaining function declarations in vga_pci.c.
ok miod@@, dim@@.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.22 2006/03/15 21:46:32 miod Exp $ */
d145 8
@


1.22
log
@bits of my tree commited by Matthieu by mistake.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.21 2006/03/15 20:46:15 matthieu Exp $ */
a3 27
/*-
 * Copyright (c) 2000 Doug Rabson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$FreeBSD: src/sys/pci/agp.c,v 1.12 2001/05/19 01:28:07 alfred Exp $
 */
a87 6
#ifdef PCIAGP
#include <sys/fcntl.h>

#include <dev/pci/agpvar.h>
#include <dev/pci/agpreg.h>
#endif
a99 8
#ifdef PCIAGP
struct agp_memory *agp_find_memory(struct vga_pci_softc *sc, int id);
const struct agp_product *agp_lookup(struct pci_attach_args *pa);

struct pci_attach_args	agp_pchb_pa;
int	agp_pchb_pa_set = 0;
#endif

d101 1
a101 4
vga_pci_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d142 1
a142 3
vga_pci_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
a144 6
#ifdef PCIAGP
	struct vga_pci_softc *sc = (struct vga_pci_softc *)self;
	const struct agp_product *ap;
	u_int memsize;
	int i, ret;
#endif
d147 1
a147 54
	ap = agp_lookup(pa);
	if (ap) {
		static const int agp_max[][2] = {
			{0,		0},
			{32,		4},
			{64,		28},
			{128,		96},
			{256,		204},
			{512,		440},
			{1024,		942},
			{2048,		1920},
			{4096,		3932}
		};
#define	agp_max_size	 (sizeof(agp_max)/sizeof(agp_max[0]))

		/*
		 * Work out an upper bound for agp memory allocation. This
		 * uses a heuristic table from the Linux driver.
		 */
		memsize = ptoa(physmem) >> 20;

		for (i = 0; i < agp_max_size && memsize > agp_max[i][0]; i++)
			;
		if (i == agp_max_size)
			i = agp_max_size - 1;
		sc->sc_maxmem = agp_max[i][1] << 20;

		/*
		 * The lock is used to prevent re-entry to
		 * agp_generic_bind_memory() since that function can sleep.
		 */

		lockinit(&sc->sc_lock, PZERO|PCATCH, "agplk", 0, 0);

		TAILQ_INIT(&sc->sc_memory);

		sc->sc_pcitag = pa->pa_tag;
		sc->sc_pc = pa->pa_pc;
		sc->sc_id = pa->pa_id;
		sc->sc_dmat = pa->pa_dmat;

		pci_get_capability(sc->sc_pc, sc->sc_pcitag, PCI_CAP_AGP,
		    &sc->sc_capoff, NULL);

		ret = (*ap->ap_attach)(sc, pa, &agp_pchb_pa);
		if (ret == 0)
			printf(": aperture at 0x%lx, size 0x%lx",
			    (u_long)sc->sc_apaddr,
			    (u_long)AGP_GET_APERTURE(sc));
		else {
			sc->sc_chipc = NULL;
			printf(": AGP GART");
		}
	}
d158 3
a160 10
	struct vga_config* vs = (struct vga_config*) v;
	struct vga_pci_softc* sc = (struct vga_pci_softc *)vs->vc_softc;

	if (sc->sc_apaddr) {

		if (off > AGP_GET_APERTURE(sc))
			return (-1);

		return atop(sc->sc_apaddr + off);
	}
a161 1
	return -1;
d165 2
a166 4
vga_pci_cnattach(iot, memt, pc, bus, device, function)
	bus_space_tag_t iot, memt;
	pci_chipset_tag_t pc;
	int bus, device, function;
d172 1
a172 6
vga_pci_ioctl(v, cmd, addr, flag, p)
	void *v;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
a174 10
#ifdef PCIAGP
	struct vga_config *vc = v;
	struct vga_pci_softc *sc = (struct vga_pci_softc *)vc->vc_softc;
	struct agp_memory *mem;
	agp_info *info;
	agp_setup *setup;
	agp_allocate *alloc;
	agp_bind *bind;
	agp_unbind *unbind;
	vsize_t size;
d177 1
a178 2
		if (!sc->sc_chipc)
			return (ENXIO);
d186 1
a186 2
		if (cmd != AGPIOC_INFO && !(flag & FWRITE))
			return (EPERM);
a187 1
	}
a188 97

	switch (cmd) {
#ifdef PCIAGP
	case AGPIOC_INFO:
		info = (agp_info *)addr;
		bzero(info, sizeof *info);
		info->bridge_id = sc->sc_id;
		if (sc->sc_capoff != 0)
			info->agp_mode = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
			    AGP_STATUS + sc->sc_capoff);
		else
			info->agp_mode = 0; /* i810 doesn't have real AGP */
		info->aper_base = sc->sc_apaddr;
		info->aper_size = AGP_GET_APERTURE(sc) >> 20;
		info->pg_total =
		info->pg_system = sc->sc_maxmem >> AGP_PAGE_SHIFT;
		info->pg_used = sc->sc_allocated >> AGP_PAGE_SHIFT;
		break;

	case AGPIOC_ACQUIRE:
		if (sc->sc_state != AGP_ACQUIRE_FREE)
			error = EBUSY;
		else
			sc->sc_state = AGP_ACQUIRE_USER;
		break;

	case AGPIOC_RELEASE:
		if (sc->sc_state == AGP_ACQUIRE_FREE)
			break;

		if (sc->sc_state != AGP_ACQUIRE_USER) {
			error = EBUSY;
			break;
		}

		/*
		 * Clear out the aperture and free any
		 * outstanding memory blocks.
		 */
		TAILQ_FOREACH(mem, &sc->sc_memory, am_link) {
			if (mem->am_is_bound) {
				printf("agp_release_helper: mem %d is bound\n",
				    mem->am_id);
				AGP_UNBIND_MEMORY(sc, mem);
			}
		}
		sc->sc_state = AGP_ACQUIRE_FREE;
		break;

	case AGPIOC_SETUP:
		setup = (agp_setup *)addr;
		error = AGP_ENABLE(sc, setup->agp_mode);
		break;

	case AGPIOC_ALLOCATE:
		alloc = (agp_allocate *)addr;
		size = alloc->pg_count << AGP_PAGE_SHIFT;
		if (sc->sc_allocated + size > sc->sc_maxmem)
			error = EINVAL;
		else {
			mem = AGP_ALLOC_MEMORY(sc, alloc->type, size);
			if (mem) {
				alloc->key = mem->am_id;
				alloc->physical = mem->am_physical;
			} else
				error = ENOMEM;
		}
		break;

	case AGPIOC_DEALLOCATE:
		mem = agp_find_memory(sc, *(int *)addr);
		if (mem)
			AGP_FREE_MEMORY(sc, mem);
		else
			error = ENOENT;
		break;

	case AGPIOC_BIND:
		bind = (agp_bind *)addr;
		mem = agp_find_memory(sc, bind->key);
		if (!mem)
			error = ENOENT;
		else
			error = AGP_BIND_MEMORY(sc, mem,
			    bind->pg_start << AGP_PAGE_SHIFT);
		break;

	case AGPIOC_UNBIND:
		unbind = (agp_unbind *)addr;
		mem = agp_find_memory(sc, unbind->key);
		if (!mem)
			error = ENOENT;
		else
			error = AGP_UNBIND_MEMORY(sc, mem);
		break;
#endif /* PCIAGP */

a195 1
#ifdef PCIAGP
d200 3
a202 20
	struct vga_config *vc = v;
	struct vga_pci_softc *sc = (struct vga_pci_softc *)vc->vc_softc;
	struct agp_memory *mem;

	/*
	 * Clear out the aperture and free any
	 * outstanding memory blocks.
	 */
	TAILQ_FOREACH(mem, &sc->sc_memory, am_link) {
		if (mem->am_is_bound) {
			AGP_UNBIND_MEMORY(sc, mem);
		}
	}

	while (!TAILQ_EMPTY(&sc->sc_memory)) {
		mem = TAILQ_FIRST(&sc->sc_memory);
		AGP_FREE_MEMORY(sc, mem);
	}

	sc->sc_state = AGP_ACQUIRE_FREE;
a204 455

struct agp_memory *
agp_find_memory(struct vga_pci_softc *sc, int id)
{
	struct agp_memory *mem;

	AGP_DPF("searching for memory block %d\n", id);
	TAILQ_FOREACH(mem, &sc->sc_memory, am_link) {
		AGP_DPF("considering memory block %d\n", mem->am_id);
		if (mem->am_id == id)
			return (mem);
	}
	return 0;
}

const struct agp_product *
agp_lookup(struct pci_attach_args *pa)
{
	const struct agp_product *ap;

	if (!agp_pchb_pa_set)
		return (NULL);
	agp_pchb_pa_set = 0;

	/* First find the vendor. */
	for (ap = agp_products; ap->ap_attach != NULL; ap++)
		if (ap->ap_vendor == PCI_VENDOR(pa->pa_id))
			break;

	if (ap->ap_attach == NULL)
		return (NULL);

	/* Now find the product within the vendor's domain. */
	for (; ap->ap_attach != NULL; ap++) {
		/* Ran out of this vendor's section of the table. */
		if (ap->ap_vendor != PCI_VENDOR(pa->pa_id))
			return (NULL);

		if (ap->ap_product == PCI_PRODUCT(pa->pa_id))
			break;		/* Exact match. */
		if (ap->ap_product == (u_int32_t) -1)
			break;		/* Wildcard match. */
	}

	if (ap->ap_attach == NULL)
		ap = NULL;

	return (ap);
}

void
pciagp_set_pchb(struct pci_attach_args *pa)
{
	if (!agp_pchb_pa_set) {
		memcpy(&agp_pchb_pa, pa, sizeof *pa);
		agp_pchb_pa_set++;
	}
}

int
agp_map_aperture(struct vga_pci_softc *sc)
{
	/*
	 * Find and the aperture. Don't map it (yet), this would
	 * eat KVA.
	 */
	if (pci_mapreg_info(sc->sc_pc, sc->sc_pcitag, AGP_APBASE,
	    PCI_MAPREG_TYPE_MEM, &sc->sc_apaddr, &sc->sc_apsize,
	    &sc->sc_apflags) != 0)
		return ENXIO;

	return 0;
}

struct agp_gatt *
agp_alloc_gatt(struct vga_pci_softc *sc)
{
	u_int32_t apsize = AGP_GET_APERTURE(sc);
	u_int32_t entries = apsize >> AGP_PAGE_SHIFT;
	struct agp_gatt *gatt;
	int nseg;

	gatt = malloc(sizeof(*gatt), M_DEVBUF, M_NOWAIT);
	if (!gatt)
		return (NULL);
	bzero(gatt, sizeof(*gatt));
	gatt->ag_entries = entries;

	if (agp_alloc_dmamem(sc->sc_dmat, entries * sizeof(u_int32_t),
	    0, &gatt->ag_dmamap, (caddr_t *)&gatt->ag_virtual,
	    &gatt->ag_physical, &gatt->ag_dmaseg, 1, &nseg) != 0)
		return NULL;

	gatt->ag_size = entries * sizeof(u_int32_t);
	memset(gatt->ag_virtual, 0, gatt->ag_size);
	agp_flush_cache();

	return gatt;
}

void
agp_free_gatt(struct vga_pci_softc *sc, struct agp_gatt *gatt)
{
	agp_free_dmamem(sc->sc_dmat, gatt->ag_size, gatt->ag_dmamap,
	    (caddr_t)gatt->ag_virtual, &gatt->ag_dmaseg, 1);
	free(gatt, M_DEVBUF);
}

int
agp_generic_detach(struct vga_pci_softc *sc)
{
	lockmgr(&sc->sc_lock, LK_DRAIN, NULL);
	agp_flush_cache();
	return 0;
}

int
agp_generic_enable(struct vga_pci_softc *sc, u_int32_t mode)
{
	pcireg_t tstatus, mstatus;
	pcireg_t command;
	int rq, sba, fw, rate, capoff;
	
	if (pci_get_capability(sc->sc_pc, sc->sc_pcitag, PCI_CAP_AGP,
	     &capoff, NULL) == 0) {
		printf("agp_generic_enable: not an AGP capable device\n");
		return -1;
	}

	tstatus = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
	    sc->sc_capoff + AGP_STATUS);
	mstatus = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
	    capoff + AGP_STATUS);

	/* Set RQ to the min of mode, tstatus and mstatus */
	rq = AGP_MODE_GET_RQ(mode);
	if (AGP_MODE_GET_RQ(tstatus) < rq)
		rq = AGP_MODE_GET_RQ(tstatus);
	if (AGP_MODE_GET_RQ(mstatus) < rq)
		rq = AGP_MODE_GET_RQ(mstatus);

	/* Set SBA if all three can deal with SBA */
	sba = (AGP_MODE_GET_SBA(tstatus)
	       & AGP_MODE_GET_SBA(mstatus)
	       & AGP_MODE_GET_SBA(mode));

	/* Similar for FW */
	fw = (AGP_MODE_GET_FW(tstatus)
	       & AGP_MODE_GET_FW(mstatus)
	       & AGP_MODE_GET_FW(mode));

	/* Figure out the max rate */
	rate = (AGP_MODE_GET_RATE(tstatus)
		& AGP_MODE_GET_RATE(mstatus)
		& AGP_MODE_GET_RATE(mode));
	if (rate & AGP_MODE_RATE_4x)
		rate = AGP_MODE_RATE_4x;
	else if (rate & AGP_MODE_RATE_2x)
		rate = AGP_MODE_RATE_2x;
	else
		rate = AGP_MODE_RATE_1x;

	/* Construct the new mode word and tell the hardware  */
	command = AGP_MODE_SET_RQ(0, rq);
	command = AGP_MODE_SET_SBA(command, sba);
	command = AGP_MODE_SET_FW(command, fw);
	command = AGP_MODE_SET_RATE(command, rate);
	command = AGP_MODE_SET_AGP(command, 1);
	pci_conf_write(sc->sc_pc, sc->sc_pcitag,
	    sc->sc_capoff + AGP_COMMAND, command);
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, capoff + AGP_COMMAND, command);
	return 0;
}

struct agp_memory *
agp_generic_alloc_memory(struct vga_pci_softc *sc, int type, vsize_t size)
{
	struct agp_memory *mem;

	if (type != 0) {
		printf("agp_generic_alloc_memory: unsupported type %d\n", type);
		return 0;
	}

	mem = malloc(sizeof *mem, M_DEVBUF, M_WAITOK);
	if (mem == NULL)
		return NULL;

	if (bus_dmamap_create(sc->sc_dmat, size, size / PAGE_SIZE + 1,
	    size, 0, BUS_DMA_NOWAIT, &mem->am_dmamap) != 0) {
		free(mem, M_DEVBUF);
		return NULL;
	}

	mem->am_id = sc->sc_nextid++;
	mem->am_size = size;
	mem->am_type = 0;
	mem->am_physical = 0;
	mem->am_offset = 0;
	mem->am_is_bound = 0;
	TAILQ_INSERT_TAIL(&sc->sc_memory, mem, am_link);
	sc->sc_allocated += size;

	return mem;
}

int
agp_generic_free_memory(struct vga_pci_softc *sc, struct agp_memory *mem)
{
	if (mem->am_is_bound)
		return EBUSY;

	sc->sc_allocated -= mem->am_size;
	TAILQ_REMOVE(&sc->sc_memory, mem, am_link);
	bus_dmamap_destroy(sc->sc_dmat, mem->am_dmamap);
	free(mem, M_DEVBUF);
	return 0;
}

int
agp_generic_bind_memory(struct vga_pci_softc *sc, struct agp_memory *mem,
			off_t offset)
{
	bus_dma_segment_t *segs, *seg;
	bus_size_t done, j;
	bus_addr_t pa;
	off_t i, k;
	int contigpages, nseg, error;

	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL);

	if (mem->am_is_bound) {
		printf("AGP: memory already bound\n");
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
		return EINVAL;
	}

	if (offset < 0
	    || (offset & (AGP_PAGE_SIZE - 1)) != 0
	    || offset + mem->am_size > AGP_GET_APERTURE(sc)) {
		printf("AGP: binding memory at bad offset %#lx\n",
			      (unsigned long) offset);
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
		return EINVAL;
	}

	/*
	 * XXXfvdl
	 * The memory here needs to be directly accessable from the
	 * AGP video card, so it should be allocated using bus_dma.
	 * However, it need not be contiguous, since individual pages
	 * are translated using the GATT.
	 *
	 * Using a large chunk of contiguous memory may get in the way
	 * of other subsystems that may need one, so we try to be friendly
	 * and ask for allocation in chunks of a minimum of 8 pages
	 * of contiguous memory on average, falling back to 4, 2 and 1
	 * if really needed. Larger chunks are preferred, since allocating
	 * a bus_dma_segment per page would be overkill.
	 */

	for (contigpages = 32; contigpages > 0; contigpages >>= 1) {
		nseg = (mem->am_size / (contigpages * PAGE_SIZE)) + 1;
		segs = malloc(nseg * sizeof *segs, M_DEVBUF, M_WAITOK);
		if (segs == NULL)
			return ENOMEM;
		if ((error = bus_dmamem_alloc(sc->sc_dmat, mem->am_size, PAGE_SIZE, 0,
		    segs, nseg, &mem->am_nseg, BUS_DMA_WAITOK)) != 0) {
			free(segs, M_DEVBUF);
			AGP_DPF("bus_dmamem_alloc failed %d\n", error);
			continue;
		}
		if ((error = bus_dmamem_map(sc->sc_dmat, segs, mem->am_nseg,
		    mem->am_size, &mem->am_virtual, BUS_DMA_WAITOK)) != 0) {
			bus_dmamem_free(sc->sc_dmat, segs, mem->am_nseg);
			free(segs, M_DEVBUF);
			AGP_DPF("bus_dmamem_map failed %d\n", error);
			continue;
		}
		if ((error = bus_dmamap_load(sc->sc_dmat, mem->am_dmamap,
		    mem->am_virtual, mem->am_size, NULL,
		    BUS_DMA_WAITOK)) != 0) {
			bus_dmamem_unmap(sc->sc_dmat, mem->am_virtual,
			    mem->am_size);
			bus_dmamem_free(sc->sc_dmat, segs, mem->am_nseg);
			free(segs, M_DEVBUF);
			AGP_DPF("bus_dmamap_load failed %d\n", error);
			continue;
		}
		mem->am_dmaseg = segs;
		break;
	}

	if (contigpages == 0) {
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
		return ENOMEM;
	}

	/*
	 * Bind the individual pages and flush the chipset's
	 * TLB.
	 */
	done = 0;
	for (i = 0; i < mem->am_dmamap->dm_nsegs; i++) {
		seg = &mem->am_dmamap->dm_segs[i];
		/*
		 * Install entries in the GATT, making sure that if
		 * AGP_PAGE_SIZE < PAGE_SIZE and mem->am_size is not
		 * aligned to PAGE_SIZE, we don't modify too many GATT
		 * entries.
		 */
		for (j = 0; j < seg->ds_len && (done + j) < mem->am_size;
		     j += AGP_PAGE_SIZE) {
			pa = seg->ds_addr + j;
			AGP_DPF("binding offset %#lx to pa %#lx\n",
				(unsigned long)(offset + done + j),
				(unsigned long)pa);
			error = AGP_BIND_PAGE(sc, offset + done + j, pa);
			if (error) {
				/*
				 * Bail out. Reverse all the mappings
				 * and unwire the pages.
				 */
				for (k = 0; k < done + j; k += AGP_PAGE_SIZE)
					AGP_UNBIND_PAGE(sc, offset + k);

				bus_dmamap_unload(sc->sc_dmat, mem->am_dmamap);
				bus_dmamem_unmap(sc->sc_dmat, mem->am_virtual,
						 mem->am_size);
				bus_dmamem_free(sc->sc_dmat, mem->am_dmaseg,
						mem->am_nseg);
				free(mem->am_dmaseg, M_DEVBUF);
				lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
				return error;
			}
		}
		done += seg->ds_len;
	}

	/*
	 * Flush the cpu cache since we are providing a new mapping
	 * for these pages.
	 */
	agp_flush_cache();

	/*
	 * Make sure the chipset gets the new mappings.
	 */
	AGP_FLUSH_TLB(sc);

	mem->am_offset = offset;
	mem->am_is_bound = 1;

	lockmgr(&sc->sc_lock, LK_RELEASE, NULL);

	return 0;
}

int
agp_generic_unbind_memory(struct vga_pci_softc *sc, struct agp_memory *mem)
{
	int i;

	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL);

	if (!mem->am_is_bound) {
		printf("AGP: memory is not bound\n");
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
		return EINVAL;
	}


	/*
	 * Unbind the individual pages and flush the chipset's
	 * TLB. Unwire the pages so they can be swapped.
	 */
	for (i = 0; i < mem->am_size; i += AGP_PAGE_SIZE)
		AGP_UNBIND_PAGE(sc, mem->am_offset + i);

	agp_flush_cache();
	AGP_FLUSH_TLB(sc);

	bus_dmamap_unload(sc->sc_dmat, mem->am_dmamap);
	bus_dmamem_unmap(sc->sc_dmat, mem->am_virtual, mem->am_size);
	bus_dmamem_free(sc->sc_dmat, mem->am_dmaseg, mem->am_nseg);

	free(mem->am_dmaseg, M_DEVBUF);

	mem->am_offset = 0;
	mem->am_is_bound = 0;

	lockmgr(&sc->sc_lock, LK_RELEASE, NULL);

	return 0;
}

int
agp_alloc_dmamem(bus_dma_tag_t tag, size_t size, int flags,
		 bus_dmamap_t *mapp, caddr_t *vaddr, bus_addr_t *baddr,
		 bus_dma_segment_t *seg, int nseg, int *rseg)

{
	int error, level = 0;

	if ((error = bus_dmamem_alloc(tag, size, PAGE_SIZE, 0,
			seg, nseg, rseg, BUS_DMA_NOWAIT)) != 0)
		goto out;
	level++;

	if ((error = bus_dmamem_map(tag, seg, *rseg, size, vaddr,
			BUS_DMA_NOWAIT | flags)) != 0)
		goto out;
	level++;

	if ((error = bus_dmamap_create(tag, size, *rseg, size, 0,
			BUS_DMA_NOWAIT, mapp)) != 0)
		goto out;
	level++;

	if ((error = bus_dmamap_load(tag, *mapp, *vaddr, size, NULL,
			BUS_DMA_NOWAIT)) != 0)
		goto out;

	*baddr = (*mapp)->dm_segs[0].ds_addr;

	return 0;
out:
	switch (level) {
	case 3:
		bus_dmamap_destroy(tag, *mapp);
		/* FALLTHROUGH */
	case 2:
		bus_dmamem_unmap(tag, *vaddr, size);
		/* FALLTHROUGH */
	case 1:
		bus_dmamem_free(tag, seg, *rseg);
		break;
	default:
		break;
	}

	return error;
}

void
agp_free_dmamem(bus_dma_tag_t tag, size_t size, bus_dmamap_t map,
		caddr_t vaddr, bus_dma_segment_t *seg, int nseg)
{

	bus_dmamap_unload(tag, map);
	bus_dmamap_destroy(tag, map);
	bus_dmamem_unmap(tag, vaddr, size);
	bus_dmamem_free(tag, seg, nseg);
}
#endif	/* PCIAGP */
@


1.21
log
@Remove dead code (SUPPORTS_NON_CONSOLE and MD_DISPLAY_ISA_IOT)
ok miod@@, drahn@@, dim@@.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.20 2005/11/19 02:18:00 pedro Exp $ */
d427 1
d452 1
@


1.20
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.19 2005/11/10 22:57:37 martin Exp $ */
a178 4
#ifdef MD_DISPLAY_ISA_IOT
	if (!vga_common_probe(MD_DISPLAY_ISA_IOT, MD_DISPLAY_ISA_MEMT))
		return (0);
#else
a180 1
#endif
a189 1
#ifndef MD_DISPLAY_ISA_IOT
a190 1
#endif
a254 4
#ifdef MD_DISPLAY_ISA_IOT
	vga_extended_attach(self, MD_DISPLAY_ISA_IOT, ppc_isa_membus_space,
	    WSDISPLAY_TYPE_PCIVGA, vga_pci_mmap);
#else
a256 1
#endif
d427 25
d905 1
a905 1
#endif
@


1.20.2.1
log
@Errata #17:
       Insufficient validation in vga(4) may allow an attacker to gain
       root privileges if the kernel is compiled with option PCIAGP and
       the actual device is not an AGP device. The PCIAGP option is
       present by default on i386 kernels only.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.20 2005/11/19 02:18:00 pedro Exp $ */
d320 2
a328 2
		if (sc->sc_methods == NULL || sc->sc_chipc == NULL)
			return (ENXIO);
@


1.19
log
@be MI, use atop()
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.18 2005/06/11 00:48:06 miod Exp $ */
d549 1
a549 1
	lockmgr(&sc->sc_lock, LK_DRAIN, NULL, curproc);
d667 1
a667 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL, curproc);
d671 1
a671 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
d680 1
a680 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
d732 1
a732 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
d770 1
a770 1
				lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
d791 1
a791 1
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
d801 1
a801 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL, curproc);
d805 1
a805 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
d829 1
a829 1
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
@


1.18
log
@Typo in comments.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.17 2004/05/03 15:18:21 drahn Exp $ */
d283 1
a283 3
#ifdef __i386__
		return i386_btop(sc->sc_apaddr + off);
#endif
@


1.17
log
@Remove OpenBSD/pegaos, this has been announced before but delayed until
the tree was stable. No point in code supporting a company which screws
its employees being in the OpenBSD tree.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.15 2003/10/31 04:10:05 drahn Exp $ */
d223 1
a223 1
		 * uses a heurisitc table from the Linux driver.
@


1.16
log
@Change these defines to be a display specific define and also remove
the really long define. ok deraadt@@
@
text
@a287 4
#ifdef __pegasos__
	/* XXX */
		return off;
#endif
@


1.15
log
@Work around a problem where the vga code expects to be able to map isa
io/memory space using PCI io/mem descriptors.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.14.8.4 2003/10/14 15:06:16 drahn Exp $ */
d179 2
a180 2
#ifdef ISA_SPACE_NOT_ACCESSABLE_WITH_PCI_IOT
	if (!vga_common_probe(MD_ISA_IOT, MD_ISA_MEMT))
d195 1
a195 1
#ifndef ISA_SPACE_NOT_ACCESSABLE_WITH_PCI_IOT
d262 2
a263 2
#ifdef ISA_SPACE_NOT_ACCESSABLE_WITH_PCI_IOT
	vga_extended_attach(self, MD_ISA_IOT, ppc_isa_membus_space,
@


1.14
log
@remove a bunch of debugging printfs and disable agp_debug; prompted by millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.13 2002/07/13 20:33:47 mickey Exp $ */
d179 4
d185 1
d195 1
d197 1
d262 4
d268 1
d287 4
@


1.13
log
@fix ioctl processing logic; problem reported by postman pechkin
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.12 2002/07/12 20:17:03 mickey Exp $ */
a690 1
printf("nsegs=%d\n", nseg);
a692 1
{ printf("malloc(%d) failed\n", nseg * sizeof *segs);
a693 1
}
@


1.12
log
@support for the agp gart on various agp chipsets.
only i810 driver was tested though.
based on the netbsd's lkm, initially ported
by hunter@@dg.net.ua and later made into shape by mickey.
testing by art@@ and millert@@ .
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.11 2002/03/14 01:27:00 millert Exp $ */
d310 2
d319 3
a321 2
		if (!sc->sc_chipc)
			return (ENXIO);
a322 3

	if (cmd != AGPIOC_INFO && !(flag & FWRITE))
		return (EPERM);
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.10 2001/05/08 16:16:11 mickey Exp $ */
d4 61
d70 1
a70 1
 * 
d76 3
a78 3
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
d80 1
a80 1
 * 
d99 5
d115 7
a124 9
struct vga_pci_softc {
	struct device sc_dev; 
 
	pcitag_t sc_pcitag;		/* PCI tag, in case we need it. */
#if 0
	struct vga_config *sc_vc;	/* VGA configuration */
#endif
};

d127 1
d133 8
d191 1
d193 4
a196 1
	char devinfo[256];
d198 69
a266 1
	sc->sc_pcitag = pa->pa_tag;
d268 2
a269 2
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
	printf("\n");
d271 6
a276 2
	vga_common_attach(self, pa->pa_iot, pa->pa_memt,
			  WSDISPLAY_TYPE_PCIVGA);
d296 304
a599 1
	return (ENOTTY);
d601 285
@


1.10
log
@support a hook for vga_pci-based ioctls; aaron@@ ook
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.9 2000/11/19 03:28:53 aaron Exp $ */
d61 2
a62 2
int	vga_pci_match __P((struct device *, void *, void *));
void	vga_pci_attach __P((struct device *, struct device *, void *));
@


1.10.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.10 2001/05/08 16:16:11 mickey Exp $ */
d61 2
a62 2
int	vga_pci_match(struct device *, void *, void *);
void	vga_pci_attach(struct device *, struct device *, void *);
@


1.10.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.10.4.1 2002/06/11 03:42:27 art Exp $ */
a3 61
/*-
 * Copyright (c) 2000 Doug Rabson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$FreeBSD: src/sys/pci/agp.c,v 1.12 2001/05/19 01:28:07 alfred Exp $
 */
/*
 * Copyright (c) 2001 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Frank van der Linden for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project by
 *	Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
d9 1
a9 1
 *
d15 3
a17 3
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
d19 1
a19 1
 *
a37 5
#include <sys/agpio.h>

#include <uvm/uvm.h>

#include <machine/bus.h>
d49 2
a50 2
#ifdef PCIAGP
#include <sys/fcntl.h>
d52 6
a57 2
#include <dev/pci/agpvar.h>
#include <dev/pci/agpreg.h>
d59 1
a59 3

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
a62 1
paddr_t	vga_pci_mmap(void* v, off_t off, int prot);
a67 8
#ifdef PCIAGP
struct agp_memory *agp_find_memory(struct vga_pci_softc *sc, int id);
const struct agp_product *agp_lookup(struct pci_attach_args *pa);

struct pci_attach_args	agp_pchb_pa;
int	agp_pchb_pa_set = 0;
#endif

a117 1
#ifdef PCIAGP
d119 3
a121 4
	const struct agp_product *ap;
	u_int memsize;
	int i, ret;
#endif
d123 1
a123 56
#ifdef PCIAGP
	ap = agp_lookup(pa);
	if (ap) {
		static const int agp_max[][2] = {
			{0,		0},
			{32,		4},
			{64,		28},
			{128,		96},
			{256,		204},
			{512,		440},
			{1024,		942},
			{2048,		1920},
			{4096,		3932}
		};
#define	agp_max_size	 (sizeof(agp_max)/sizeof(agp_max[0]))

		/*
		 * Work out an upper bound for agp memory allocation. This
		 * uses a heurisitc table from the Linux driver.
		 */
		memsize = ptoa(physmem) >> 20;

		for (i = 0; i < agp_max_size && memsize > agp_max[i][0]; i++)
			;
		if (i == agp_max_size)
			i = agp_max_size - 1;
		sc->sc_maxmem = agp_max[i][1] << 20;

		/*
		 * The lock is used to prevent re-entry to
		 * agp_generic_bind_memory() since that function can sleep.
		 */

		lockinit(&sc->sc_lock, PZERO|PCATCH, "agplk", 0, 0);

		TAILQ_INIT(&sc->sc_memory);

		sc->sc_pcitag = pa->pa_tag;
		sc->sc_pc = pa->pa_pc;
		sc->sc_id = pa->pa_id;
		sc->sc_dmat = pa->pa_dmat;

		pci_get_capability(sc->sc_pc, sc->sc_pcitag, PCI_CAP_AGP,
		    &sc->sc_capoff, NULL);

		ret = (*ap->ap_attach)(sc, pa, &agp_pchb_pa);
		if (ret == 0)
			printf(": aperture at 0x%lx, size 0x%lx",
			    (u_long)sc->sc_apaddr,
			    (u_long)AGP_GET_APERTURE(sc));
		else {
			sc->sc_chipc = NULL;
			printf(": AGP GART");
		}
	}
#endif
d125 1
d127 1
a127 21
	    WSDISPLAY_TYPE_PCIVGA);
}

paddr_t
vga_pci_mmap(void *v, off_t off, int prot)
{
#ifdef PCIAGP
	struct vga_config* vs = (struct vga_config*) v;
	struct vga_pci_softc* sc = (struct vga_pci_softc *)vs->vc_softc;

	if (sc->sc_apaddr) {

		if (off > AGP_GET_APERTURE(sc))
			return (-1);

#ifdef __i386__
		return i386_btop(sc->sc_apaddr + off);
#endif
	}
#endif
	return -1;
d147 1
a147 585
	int error = 0;
#ifdef PCIAGP
	struct vga_config *vc = v;
	struct vga_pci_softc *sc = (struct vga_pci_softc *)vc->vc_softc;
	struct agp_memory *mem;
	agp_info *info;
	agp_setup *setup;
	agp_allocate *alloc;
	agp_bind *bind;
	agp_unbind *unbind;
	vsize_t size;

	switch (cmd) {
	case AGPIOC_INFO:
		if (!sc->sc_chipc)
			return (ENXIO);
	case AGPIOC_ACQUIRE:
	case AGPIOC_RELEASE:
	case AGPIOC_SETUP:
	case AGPIOC_ALLOCATE:
	case AGPIOC_DEALLOCATE:
	case AGPIOC_BIND:
	case AGPIOC_UNBIND:
		if (cmd != AGPIOC_INFO && !(flag & FWRITE))
			return (EPERM);
		break;
	}
#endif

	switch (cmd) {
#ifdef PCIAGP
	case AGPIOC_INFO:
		info = (agp_info *)addr;
		bzero(info, sizeof *info);
		info->bridge_id = sc->sc_id;
		if (sc->sc_capoff != 0)
			info->agp_mode = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
			    AGP_STATUS + sc->sc_capoff);
		else
			info->agp_mode = 0; /* i810 doesn't have real AGP */
		info->aper_base = sc->sc_apaddr;
		info->aper_size = AGP_GET_APERTURE(sc) >> 20;
		info->pg_total =
		info->pg_system = sc->sc_maxmem >> AGP_PAGE_SHIFT;
		info->pg_used = sc->sc_allocated >> AGP_PAGE_SHIFT;
		break;

	case AGPIOC_ACQUIRE:
		if (sc->sc_state != AGP_ACQUIRE_FREE)
			error = EBUSY;
		else
			sc->sc_state = AGP_ACQUIRE_USER;
		break;

	case AGPIOC_RELEASE:
		if (sc->sc_state == AGP_ACQUIRE_FREE)
			break;

		if (sc->sc_state != AGP_ACQUIRE_USER) {
			error = EBUSY;
			break;
		}

		/*
		 * Clear out the aperture and free any
		 * outstanding memory blocks.
		 */
		TAILQ_FOREACH(mem, &sc->sc_memory, am_link) {
			if (mem->am_is_bound) {
				printf("agp_release_helper: mem %d is bound\n",
				    mem->am_id);
				AGP_UNBIND_MEMORY(sc, mem);
			}
		}
		sc->sc_state = AGP_ACQUIRE_FREE;
		break;

	case AGPIOC_SETUP:
		setup = (agp_setup *)addr;
		error = AGP_ENABLE(sc, setup->agp_mode);
		break;

	case AGPIOC_ALLOCATE:
		alloc = (agp_allocate *)addr;
		size = alloc->pg_count << AGP_PAGE_SHIFT;
		if (sc->sc_allocated + size > sc->sc_maxmem)
			error = EINVAL;
		else {
			mem = AGP_ALLOC_MEMORY(sc, alloc->type, size);
			if (mem) {
				alloc->key = mem->am_id;
				alloc->physical = mem->am_physical;
			} else
				error = ENOMEM;
		}
		break;

	case AGPIOC_DEALLOCATE:
		mem = agp_find_memory(sc, *(int *)addr);
		if (mem)
			AGP_FREE_MEMORY(sc, mem);
		else
			error = ENOENT;
		break;

	case AGPIOC_BIND:
		bind = (agp_bind *)addr;
		mem = agp_find_memory(sc, bind->key);
		if (!mem)
			error = ENOENT;
		else
			error = AGP_BIND_MEMORY(sc, mem,
			    bind->pg_start << AGP_PAGE_SHIFT);
		break;

	case AGPIOC_UNBIND:
		unbind = (agp_unbind *)addr;
		mem = agp_find_memory(sc, unbind->key);
		if (!mem)
			error = ENOENT;
		else
			error = AGP_UNBIND_MEMORY(sc, mem);
		break;
#endif /* PCIAGP */

	default:
		error = ENOTTY;
	}

	return (error);
}

#ifdef PCIAGP
struct agp_memory *
agp_find_memory(struct vga_pci_softc *sc, int id)
{
	struct agp_memory *mem;

	AGP_DPF("searching for memory block %d\n", id);
	TAILQ_FOREACH(mem, &sc->sc_memory, am_link) {
		AGP_DPF("considering memory block %d\n", mem->am_id);
		if (mem->am_id == id)
			return (mem);
	}
	return 0;
}

const struct agp_product *
agp_lookup(struct pci_attach_args *pa)
{
	const struct agp_product *ap;

	if (!agp_pchb_pa_set)
		return (NULL);
	agp_pchb_pa_set = 0;

	/* First find the vendor. */
	for (ap = agp_products; ap->ap_attach != NULL; ap++)
		if (ap->ap_vendor == PCI_VENDOR(pa->pa_id))
			break;

	if (ap->ap_attach == NULL)
		return (NULL);

	/* Now find the product within the vendor's domain. */
	for (; ap->ap_attach != NULL; ap++) {
		/* Ran out of this vendor's section of the table. */
		if (ap->ap_vendor != PCI_VENDOR(pa->pa_id))
			return (NULL);

		if (ap->ap_product == PCI_PRODUCT(pa->pa_id))
			break;		/* Exact match. */
		if (ap->ap_product == (u_int32_t) -1)
			break;		/* Wildcard match. */
	}

	if (ap->ap_attach == NULL)
		ap = NULL;

	return (ap);
}

void
pciagp_set_pchb(struct pci_attach_args *pa)
{
	if (!agp_pchb_pa_set) {
		memcpy(&agp_pchb_pa, pa, sizeof *pa);
		agp_pchb_pa_set++;
	}
}

int
agp_map_aperture(struct vga_pci_softc *sc)
{
	/*
	 * Find and the aperture. Don't map it (yet), this would
	 * eat KVA.
	 */
	if (pci_mapreg_info(sc->sc_pc, sc->sc_pcitag, AGP_APBASE,
	    PCI_MAPREG_TYPE_MEM, &sc->sc_apaddr, &sc->sc_apsize,
	    &sc->sc_apflags) != 0)
		return ENXIO;

	return 0;
}

struct agp_gatt *
agp_alloc_gatt(struct vga_pci_softc *sc)
{
	u_int32_t apsize = AGP_GET_APERTURE(sc);
	u_int32_t entries = apsize >> AGP_PAGE_SHIFT;
	struct agp_gatt *gatt;
	int nseg;

	gatt = malloc(sizeof(*gatt), M_DEVBUF, M_NOWAIT);
	if (!gatt)
		return (NULL);
	bzero(gatt, sizeof(*gatt));
	gatt->ag_entries = entries;

	if (agp_alloc_dmamem(sc->sc_dmat, entries * sizeof(u_int32_t),
	    0, &gatt->ag_dmamap, (caddr_t *)&gatt->ag_virtual,
	    &gatt->ag_physical, &gatt->ag_dmaseg, 1, &nseg) != 0)
		return NULL;

	gatt->ag_size = entries * sizeof(u_int32_t);
	memset(gatt->ag_virtual, 0, gatt->ag_size);
	agp_flush_cache();

	return gatt;
}

void
agp_free_gatt(struct vga_pci_softc *sc, struct agp_gatt *gatt)
{
	agp_free_dmamem(sc->sc_dmat, gatt->ag_size, gatt->ag_dmamap,
	    (caddr_t)gatt->ag_virtual, &gatt->ag_dmaseg, 1);
	free(gatt, M_DEVBUF);
}

int
agp_generic_detach(struct vga_pci_softc *sc)
{
	lockmgr(&sc->sc_lock, LK_DRAIN, NULL, curproc);
	agp_flush_cache();
	return 0;
}

int
agp_generic_enable(struct vga_pci_softc *sc, u_int32_t mode)
{
	pcireg_t tstatus, mstatus;
	pcireg_t command;
	int rq, sba, fw, rate, capoff;
	
	if (pci_get_capability(sc->sc_pc, sc->sc_pcitag, PCI_CAP_AGP,
	     &capoff, NULL) == 0) {
		printf("agp_generic_enable: not an AGP capable device\n");
		return -1;
	}

	tstatus = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
	    sc->sc_capoff + AGP_STATUS);
	mstatus = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
	    capoff + AGP_STATUS);

	/* Set RQ to the min of mode, tstatus and mstatus */
	rq = AGP_MODE_GET_RQ(mode);
	if (AGP_MODE_GET_RQ(tstatus) < rq)
		rq = AGP_MODE_GET_RQ(tstatus);
	if (AGP_MODE_GET_RQ(mstatus) < rq)
		rq = AGP_MODE_GET_RQ(mstatus);

	/* Set SBA if all three can deal with SBA */
	sba = (AGP_MODE_GET_SBA(tstatus)
	       & AGP_MODE_GET_SBA(mstatus)
	       & AGP_MODE_GET_SBA(mode));

	/* Similar for FW */
	fw = (AGP_MODE_GET_FW(tstatus)
	       & AGP_MODE_GET_FW(mstatus)
	       & AGP_MODE_GET_FW(mode));

	/* Figure out the max rate */
	rate = (AGP_MODE_GET_RATE(tstatus)
		& AGP_MODE_GET_RATE(mstatus)
		& AGP_MODE_GET_RATE(mode));
	if (rate & AGP_MODE_RATE_4x)
		rate = AGP_MODE_RATE_4x;
	else if (rate & AGP_MODE_RATE_2x)
		rate = AGP_MODE_RATE_2x;
	else
		rate = AGP_MODE_RATE_1x;

	/* Construct the new mode word and tell the hardware  */
	command = AGP_MODE_SET_RQ(0, rq);
	command = AGP_MODE_SET_SBA(command, sba);
	command = AGP_MODE_SET_FW(command, fw);
	command = AGP_MODE_SET_RATE(command, rate);
	command = AGP_MODE_SET_AGP(command, 1);
	pci_conf_write(sc->sc_pc, sc->sc_pcitag,
	    sc->sc_capoff + AGP_COMMAND, command);
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, capoff + AGP_COMMAND, command);
	return 0;
}

struct agp_memory *
agp_generic_alloc_memory(struct vga_pci_softc *sc, int type, vsize_t size)
{
	struct agp_memory *mem;

	if (type != 0) {
		printf("agp_generic_alloc_memory: unsupported type %d\n", type);
		return 0;
	}

	mem = malloc(sizeof *mem, M_DEVBUF, M_WAITOK);
	if (mem == NULL)
		return NULL;

	if (bus_dmamap_create(sc->sc_dmat, size, size / PAGE_SIZE + 1,
	    size, 0, BUS_DMA_NOWAIT, &mem->am_dmamap) != 0) {
		free(mem, M_DEVBUF);
		return NULL;
	}

	mem->am_id = sc->sc_nextid++;
	mem->am_size = size;
	mem->am_type = 0;
	mem->am_physical = 0;
	mem->am_offset = 0;
	mem->am_is_bound = 0;
	TAILQ_INSERT_TAIL(&sc->sc_memory, mem, am_link);
	sc->sc_allocated += size;

	return mem;
}

int
agp_generic_free_memory(struct vga_pci_softc *sc, struct agp_memory *mem)
{
	if (mem->am_is_bound)
		return EBUSY;

	sc->sc_allocated -= mem->am_size;
	TAILQ_REMOVE(&sc->sc_memory, mem, am_link);
	bus_dmamap_destroy(sc->sc_dmat, mem->am_dmamap);
	free(mem, M_DEVBUF);
	return 0;
}

int
agp_generic_bind_memory(struct vga_pci_softc *sc, struct agp_memory *mem,
			off_t offset)
{
	bus_dma_segment_t *segs, *seg;
	bus_size_t done, j;
	bus_addr_t pa;
	off_t i, k;
	int contigpages, nseg, error;

	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL, curproc);

	if (mem->am_is_bound) {
		printf("AGP: memory already bound\n");
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
		return EINVAL;
	}

	if (offset < 0
	    || (offset & (AGP_PAGE_SIZE - 1)) != 0
	    || offset + mem->am_size > AGP_GET_APERTURE(sc)) {
		printf("AGP: binding memory at bad offset %#lx\n",
			      (unsigned long) offset);
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
		return EINVAL;
	}

	/*
	 * XXXfvdl
	 * The memory here needs to be directly accessable from the
	 * AGP video card, so it should be allocated using bus_dma.
	 * However, it need not be contiguous, since individual pages
	 * are translated using the GATT.
	 *
	 * Using a large chunk of contiguous memory may get in the way
	 * of other subsystems that may need one, so we try to be friendly
	 * and ask for allocation in chunks of a minimum of 8 pages
	 * of contiguous memory on average, falling back to 4, 2 and 1
	 * if really needed. Larger chunks are preferred, since allocating
	 * a bus_dma_segment per page would be overkill.
	 */

	for (contigpages = 32; contigpages > 0; contigpages >>= 1) {
		nseg = (mem->am_size / (contigpages * PAGE_SIZE)) + 1;
		segs = malloc(nseg * sizeof *segs, M_DEVBUF, M_WAITOK);
		if (segs == NULL)
			return ENOMEM;
		if ((error = bus_dmamem_alloc(sc->sc_dmat, mem->am_size, PAGE_SIZE, 0,
		    segs, nseg, &mem->am_nseg, BUS_DMA_WAITOK)) != 0) {
			free(segs, M_DEVBUF);
			AGP_DPF("bus_dmamem_alloc failed %d\n", error);
			continue;
		}
		if ((error = bus_dmamem_map(sc->sc_dmat, segs, mem->am_nseg,
		    mem->am_size, &mem->am_virtual, BUS_DMA_WAITOK)) != 0) {
			bus_dmamem_free(sc->sc_dmat, segs, mem->am_nseg);
			free(segs, M_DEVBUF);
			AGP_DPF("bus_dmamem_map failed %d\n", error);
			continue;
		}
		if ((error = bus_dmamap_load(sc->sc_dmat, mem->am_dmamap,
		    mem->am_virtual, mem->am_size, NULL,
		    BUS_DMA_WAITOK)) != 0) {
			bus_dmamem_unmap(sc->sc_dmat, mem->am_virtual,
			    mem->am_size);
			bus_dmamem_free(sc->sc_dmat, segs, mem->am_nseg);
			free(segs, M_DEVBUF);
			AGP_DPF("bus_dmamap_load failed %d\n", error);
			continue;
		}
		mem->am_dmaseg = segs;
		break;
	}

	if (contigpages == 0) {
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
		return ENOMEM;
	}

	/*
	 * Bind the individual pages and flush the chipset's
	 * TLB.
	 */
	done = 0;
	for (i = 0; i < mem->am_dmamap->dm_nsegs; i++) {
		seg = &mem->am_dmamap->dm_segs[i];
		/*
		 * Install entries in the GATT, making sure that if
		 * AGP_PAGE_SIZE < PAGE_SIZE and mem->am_size is not
		 * aligned to PAGE_SIZE, we don't modify too many GATT
		 * entries.
		 */
		for (j = 0; j < seg->ds_len && (done + j) < mem->am_size;
		     j += AGP_PAGE_SIZE) {
			pa = seg->ds_addr + j;
			AGP_DPF("binding offset %#lx to pa %#lx\n",
				(unsigned long)(offset + done + j),
				(unsigned long)pa);
			error = AGP_BIND_PAGE(sc, offset + done + j, pa);
			if (error) {
				/*
				 * Bail out. Reverse all the mappings
				 * and unwire the pages.
				 */
				for (k = 0; k < done + j; k += AGP_PAGE_SIZE)
					AGP_UNBIND_PAGE(sc, offset + k);

				bus_dmamap_unload(sc->sc_dmat, mem->am_dmamap);
				bus_dmamem_unmap(sc->sc_dmat, mem->am_virtual,
						 mem->am_size);
				bus_dmamem_free(sc->sc_dmat, mem->am_dmaseg,
						mem->am_nseg);
				free(mem->am_dmaseg, M_DEVBUF);
				lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
				return error;
			}
		}
		done += seg->ds_len;
	}

	/*
	 * Flush the cpu cache since we are providing a new mapping
	 * for these pages.
	 */
	agp_flush_cache();

	/*
	 * Make sure the chipset gets the new mappings.
	 */
	AGP_FLUSH_TLB(sc);

	mem->am_offset = offset;
	mem->am_is_bound = 1;

	lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);

	return 0;
}

int
agp_generic_unbind_memory(struct vga_pci_softc *sc, struct agp_memory *mem)
{
	int i;

	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL, curproc);

	if (!mem->am_is_bound) {
		printf("AGP: memory is not bound\n");
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
		return EINVAL;
	}


	/*
	 * Unbind the individual pages and flush the chipset's
	 * TLB. Unwire the pages so they can be swapped.
	 */
	for (i = 0; i < mem->am_size; i += AGP_PAGE_SIZE)
		AGP_UNBIND_PAGE(sc, mem->am_offset + i);

	agp_flush_cache();
	AGP_FLUSH_TLB(sc);

	bus_dmamap_unload(sc->sc_dmat, mem->am_dmamap);
	bus_dmamem_unmap(sc->sc_dmat, mem->am_virtual, mem->am_size);
	bus_dmamem_free(sc->sc_dmat, mem->am_dmaseg, mem->am_nseg);

	free(mem->am_dmaseg, M_DEVBUF);

	mem->am_offset = 0;
	mem->am_is_bound = 0;

	lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);

	return 0;
}

int
agp_alloc_dmamem(bus_dma_tag_t tag, size_t size, int flags,
		 bus_dmamap_t *mapp, caddr_t *vaddr, bus_addr_t *baddr,
		 bus_dma_segment_t *seg, int nseg, int *rseg)

{
	int error, level = 0;

	if ((error = bus_dmamem_alloc(tag, size, PAGE_SIZE, 0,
			seg, nseg, rseg, BUS_DMA_NOWAIT)) != 0)
		goto out;
	level++;

	if ((error = bus_dmamem_map(tag, seg, *rseg, size, vaddr,
			BUS_DMA_NOWAIT | flags)) != 0)
		goto out;
	level++;

	if ((error = bus_dmamap_create(tag, size, *rseg, size, 0,
			BUS_DMA_NOWAIT, mapp)) != 0)
		goto out;
	level++;

	if ((error = bus_dmamap_load(tag, *mapp, *vaddr, size, NULL,
			BUS_DMA_NOWAIT)) != 0)
		goto out;

	*baddr = (*mapp)->dm_segs[0].ds_addr;

	return 0;
out:
	switch (level) {
	case 3:
		bus_dmamap_destroy(tag, *mapp);
		/* FALLTHROUGH */
	case 2:
		bus_dmamem_unmap(tag, *vaddr, size);
		/* FALLTHROUGH */
	case 1:
		bus_dmamem_free(tag, seg, *rseg);
		break;
	default:
		break;
	}

	return error;
}

void
agp_free_dmamem(bus_dma_tag_t tag, size_t size, bus_dmamap_t map,
		caddr_t vaddr, bus_dma_segment_t *seg, int nseg)
{

	bus_dmamap_unload(tag, map);
	bus_dmamap_destroy(tag, map);
	bus_dmamem_unmap(tag, vaddr, size);
	bus_dmamem_free(tag, seg, nseg);
a148 1
#endif
@


1.9
log
@Don't print PCI device info twice during attach.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.8 2000/11/15 20:17:38 aaron Exp $ */
d31 2
d137 11
@


1.8
log
@Updated VGA driver; from NetBSD. Needed for wscons on i386 and alpha. These
files could probably be updated even a bit further (they are from mid-summer).

In addition, I've added support for console scrollback, somewhat inspired by
Linux's vgacon driver. Basically, instead of allocating our own buffer and
doing lots of copies, we take advantage of Video RAM and just modify the VGA
display origin register as appropriate. This approach has a few advantages:
simple to implement, no wasted KVM, it's fast, and after a boot you can now
scroll back all the way to the BIOS messages (assuming your msgbuf is of a
typical length :). Disadvantages are that the VRAM buffer is relatively
small (only 32k) and we do not support raster devices through this method.
(thanks to mickey@@ for pointing this out).

The code for this is fairly unobtrusive, so should we come up with a better
approach to console scrollback at a later time (i.e., even more platform
independent) it should be easy to revert this.

We're one step further in porting nice features of PCVT over to wscons.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d122 1
a122 2
	printf(": %s (rev. 0x%02x)\n", devinfo,
	    PCI_REVISION(pa->pa_class));
@


1.7
log
@new style pci attach printing
@
text
@d1 2
a2 2
/*	$OpenBSD: vga_pci.c,v 1.6 1997/11/06 12:26:56 niklas Exp $	*/
/*	$NetBSD: vga_pci.c,v 1.4 1996/12/05 01:39:38 cgd Exp $	*/
a36 5
#ifndef i386
#include <machine/autoconf.h>
#endif
#include <machine/pte.h>

d41 3
d47 3
d54 3
a56 1
	struct vga_config *sc_vc;	/* VGA configuration */ 
a58 1
#ifdef __BROKEN_INDIRECT_CONFIG
a59 3
#else
int	vga_pci_match __P((struct device *, struct cfdata *, void *));
#endif
a61 3
int	vgapcimmap __P((void *, off_t, int));
int	vgapciioctl __P((void *, u_long, caddr_t, int, struct proc *));

d63 1
a63 1
	sizeof(struct vga_pci_softc), (cfmatch_t)vga_pci_match, vga_pci_attach,
a65 3
pcitag_t vga_pci_console_tag;
struct vga_config vga_pci_console_vc;

a68 1
#ifdef __BROKEN_INDIRECT_CONFIG
a69 3
#else
	struct cfdata *match;
#endif
d91 6
d98 1
a98 1
	if (!bcmp(&pa->pa_tag, &vga_pci_console_tag, sizeof(pa->pa_tag)))
d117 1
a117 15
	struct vga_config *vc;
	int console;

	console = (!bcmp(&pa->pa_tag, &vga_pci_console_tag, sizeof(pa->pa_tag)));
	if (console)
		vc = sc->sc_vc = &vga_pci_console_vc;
	else {
		vc = sc->sc_vc = (struct vga_config *)
		    malloc(sizeof(struct vga_config), M_DEVBUF, M_WAITOK);

		/* set up bus-independent VGA configuration */
		vga_common_setup(pa->pa_iot, pa->pa_memt, vc);
	}
	vc->vc_mmap = vgapcimmap;
	vc->vc_ioctl = vgapciioctl;
d121 3
a123 1
	printf("\n");
d125 2
a126 1
	vga_wscons_attach(self, vc, console);
d129 2
a130 2
void
vga_pci_console(iot, memt, pc, bus, device, function)
d135 1
a135 33
	struct vga_config *vc = &vga_pci_console_vc;

	/* for later recognition */
	vga_pci_console_tag = pci_make_tag(pc, bus, device, function);

	/* set up bus-independent VGA configuration */
	vga_common_setup(iot, memt, vc);

	vga_wscons_console(vc);
}

int
vgapciioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct vga_pci_softc *sc = v;

	return (vgaioctl(sc->sc_vc, cmd, data, flag, p));
}

int
vgapcimmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
{
	struct vga_pci_softc *sc = v;

	return (vgammap(sc->sc_vc, offset, prot));
@


1.7.10.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/* $OpenBSD: vga_pci.c,v 1.9 2000/11/19 03:28:53 aaron Exp $ */
/* $NetBSD: vga_pci.c,v 1.3 1998/06/08 06:55:58 thorpej Exp $ */
d37 5
a45 3
#include <dev/ic/mc6845reg.h>
#include <dev/ic/pcdisplayvar.h>
#include <dev/ic/vgareg.h>
a48 3
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>

d53 1
a53 3
#if 0
	struct vga_config *sc_vc;	/* VGA configuration */
#endif
d56 1
d58 3
d63 3
d67 1
a67 1
	sizeof(struct vga_pci_softc), vga_pci_match, vga_pci_attach,
d70 3
d76 1
d78 3
a101 6
	/* check whether it is disabled by firmware */
	if ((pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG)
	    & (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE))
	    != (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE))
		return (0);

d103 1
a103 1
	if (vga_is_console(pa->pa_iot, WSDISPLAY_TYPE_PCIVGA))
d122 15
a136 1
	char devinfo[256];
a139 1
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
d142 1
a142 2
	vga_common_attach(self, pa->pa_iot, pa->pa_memt,
			  WSDISPLAY_TYPE_PCIVGA);
d145 2
a146 2
int
vga_pci_cnattach(iot, memt, pc, bus, device, function)
d151 33
a183 1
	return (vga_cnattach(iot, memt, WSDISPLAY_TYPE_PCIVGA, 0));
@


1.7.10.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: vga_pci.c,v 1.7.10.1 2001/05/14 22:26:01 niklas Exp $ */
a30 2
#include "vga.h"

a134 11
}

int
vga_pci_ioctl(v, cmd, addr, flag, p)
	void *v;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
{
	return (ENOTTY);
@


1.7.10.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d61 2
a62 2
int	vga_pci_match(struct device *, void *, void *);
void	vga_pci_attach(struct device *, struct device *, void *);
@


1.7.10.4
log
@Sync the SMP branch with 3.3
@
text
@a3 61
/*-
 * Copyright (c) 2000 Doug Rabson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$FreeBSD: src/sys/pci/agp.c,v 1.12 2001/05/19 01:28:07 alfred Exp $
 */
/*
 * Copyright (c) 2001 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Frank van der Linden for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project by
 *	Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
d9 1
a9 1
 *
d15 3
a17 3
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
d19 1
a19 1
 *
a37 5
#include <sys/agpio.h>

#include <uvm/uvm.h>

#include <machine/bus.h>
d49 2
a50 2
#ifdef PCIAGP
#include <sys/fcntl.h>
d52 6
a57 2
#include <dev/pci/agpvar.h>
#include <dev/pci/agpreg.h>
d59 1
a59 3

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
a62 1
paddr_t	vga_pci_mmap(void* v, off_t off, int prot);
a67 8
#ifdef PCIAGP
struct agp_memory *agp_find_memory(struct vga_pci_softc *sc, int id);
const struct agp_product *agp_lookup(struct pci_attach_args *pa);

struct pci_attach_args	agp_pchb_pa;
int	agp_pchb_pa_set = 0;
#endif

a117 1
#ifdef PCIAGP
d119 3
a121 4
	const struct agp_product *ap;
	u_int memsize;
	int i, ret;
#endif
d123 1
a123 56
#ifdef PCIAGP
	ap = agp_lookup(pa);
	if (ap) {
		static const int agp_max[][2] = {
			{0,		0},
			{32,		4},
			{64,		28},
			{128,		96},
			{256,		204},
			{512,		440},
			{1024,		942},
			{2048,		1920},
			{4096,		3932}
		};
#define	agp_max_size	 (sizeof(agp_max)/sizeof(agp_max[0]))

		/*
		 * Work out an upper bound for agp memory allocation. This
		 * uses a heurisitc table from the Linux driver.
		 */
		memsize = ptoa(physmem) >> 20;

		for (i = 0; i < agp_max_size && memsize > agp_max[i][0]; i++)
			;
		if (i == agp_max_size)
			i = agp_max_size - 1;
		sc->sc_maxmem = agp_max[i][1] << 20;

		/*
		 * The lock is used to prevent re-entry to
		 * agp_generic_bind_memory() since that function can sleep.
		 */

		lockinit(&sc->sc_lock, PZERO|PCATCH, "agplk", 0, 0);

		TAILQ_INIT(&sc->sc_memory);

		sc->sc_pcitag = pa->pa_tag;
		sc->sc_pc = pa->pa_pc;
		sc->sc_id = pa->pa_id;
		sc->sc_dmat = pa->pa_dmat;

		pci_get_capability(sc->sc_pc, sc->sc_pcitag, PCI_CAP_AGP,
		    &sc->sc_capoff, NULL);

		ret = (*ap->ap_attach)(sc, pa, &agp_pchb_pa);
		if (ret == 0)
			printf(": aperture at 0x%lx, size 0x%lx",
			    (u_long)sc->sc_apaddr,
			    (u_long)AGP_GET_APERTURE(sc));
		else {
			sc->sc_chipc = NULL;
			printf(": AGP GART");
		}
	}
#endif
d125 1
d127 1
a127 21
	    WSDISPLAY_TYPE_PCIVGA);
}

paddr_t
vga_pci_mmap(void *v, off_t off, int prot)
{
#ifdef PCIAGP
	struct vga_config* vs = (struct vga_config*) v;
	struct vga_pci_softc* sc = (struct vga_pci_softc *)vs->vc_softc;

	if (sc->sc_apaddr) {

		if (off > AGP_GET_APERTURE(sc))
			return (-1);

#ifdef __i386__
		return i386_btop(sc->sc_apaddr + off);
#endif
	}
#endif
	return -1;
d147 1
a147 585
	int error = 0;
#ifdef PCIAGP
	struct vga_config *vc = v;
	struct vga_pci_softc *sc = (struct vga_pci_softc *)vc->vc_softc;
	struct agp_memory *mem;
	agp_info *info;
	agp_setup *setup;
	agp_allocate *alloc;
	agp_bind *bind;
	agp_unbind *unbind;
	vsize_t size;

	switch (cmd) {
	case AGPIOC_INFO:
		if (!sc->sc_chipc)
			return (ENXIO);
	case AGPIOC_ACQUIRE:
	case AGPIOC_RELEASE:
	case AGPIOC_SETUP:
	case AGPIOC_ALLOCATE:
	case AGPIOC_DEALLOCATE:
	case AGPIOC_BIND:
	case AGPIOC_UNBIND:
		if (cmd != AGPIOC_INFO && !(flag & FWRITE))
			return (EPERM);
		break;
	}
#endif

	switch (cmd) {
#ifdef PCIAGP
	case AGPIOC_INFO:
		info = (agp_info *)addr;
		bzero(info, sizeof *info);
		info->bridge_id = sc->sc_id;
		if (sc->sc_capoff != 0)
			info->agp_mode = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
			    AGP_STATUS + sc->sc_capoff);
		else
			info->agp_mode = 0; /* i810 doesn't have real AGP */
		info->aper_base = sc->sc_apaddr;
		info->aper_size = AGP_GET_APERTURE(sc) >> 20;
		info->pg_total =
		info->pg_system = sc->sc_maxmem >> AGP_PAGE_SHIFT;
		info->pg_used = sc->sc_allocated >> AGP_PAGE_SHIFT;
		break;

	case AGPIOC_ACQUIRE:
		if (sc->sc_state != AGP_ACQUIRE_FREE)
			error = EBUSY;
		else
			sc->sc_state = AGP_ACQUIRE_USER;
		break;

	case AGPIOC_RELEASE:
		if (sc->sc_state == AGP_ACQUIRE_FREE)
			break;

		if (sc->sc_state != AGP_ACQUIRE_USER) {
			error = EBUSY;
			break;
		}

		/*
		 * Clear out the aperture and free any
		 * outstanding memory blocks.
		 */
		TAILQ_FOREACH(mem, &sc->sc_memory, am_link) {
			if (mem->am_is_bound) {
				printf("agp_release_helper: mem %d is bound\n",
				    mem->am_id);
				AGP_UNBIND_MEMORY(sc, mem);
			}
		}
		sc->sc_state = AGP_ACQUIRE_FREE;
		break;

	case AGPIOC_SETUP:
		setup = (agp_setup *)addr;
		error = AGP_ENABLE(sc, setup->agp_mode);
		break;

	case AGPIOC_ALLOCATE:
		alloc = (agp_allocate *)addr;
		size = alloc->pg_count << AGP_PAGE_SHIFT;
		if (sc->sc_allocated + size > sc->sc_maxmem)
			error = EINVAL;
		else {
			mem = AGP_ALLOC_MEMORY(sc, alloc->type, size);
			if (mem) {
				alloc->key = mem->am_id;
				alloc->physical = mem->am_physical;
			} else
				error = ENOMEM;
		}
		break;

	case AGPIOC_DEALLOCATE:
		mem = agp_find_memory(sc, *(int *)addr);
		if (mem)
			AGP_FREE_MEMORY(sc, mem);
		else
			error = ENOENT;
		break;

	case AGPIOC_BIND:
		bind = (agp_bind *)addr;
		mem = agp_find_memory(sc, bind->key);
		if (!mem)
			error = ENOENT;
		else
			error = AGP_BIND_MEMORY(sc, mem,
			    bind->pg_start << AGP_PAGE_SHIFT);
		break;

	case AGPIOC_UNBIND:
		unbind = (agp_unbind *)addr;
		mem = agp_find_memory(sc, unbind->key);
		if (!mem)
			error = ENOENT;
		else
			error = AGP_UNBIND_MEMORY(sc, mem);
		break;
#endif /* PCIAGP */

	default:
		error = ENOTTY;
	}

	return (error);
}

#ifdef PCIAGP
struct agp_memory *
agp_find_memory(struct vga_pci_softc *sc, int id)
{
	struct agp_memory *mem;

	AGP_DPF("searching for memory block %d\n", id);
	TAILQ_FOREACH(mem, &sc->sc_memory, am_link) {
		AGP_DPF("considering memory block %d\n", mem->am_id);
		if (mem->am_id == id)
			return (mem);
	}
	return 0;
}

const struct agp_product *
agp_lookup(struct pci_attach_args *pa)
{
	const struct agp_product *ap;

	if (!agp_pchb_pa_set)
		return (NULL);
	agp_pchb_pa_set = 0;

	/* First find the vendor. */
	for (ap = agp_products; ap->ap_attach != NULL; ap++)
		if (ap->ap_vendor == PCI_VENDOR(pa->pa_id))
			break;

	if (ap->ap_attach == NULL)
		return (NULL);

	/* Now find the product within the vendor's domain. */
	for (; ap->ap_attach != NULL; ap++) {
		/* Ran out of this vendor's section of the table. */
		if (ap->ap_vendor != PCI_VENDOR(pa->pa_id))
			return (NULL);

		if (ap->ap_product == PCI_PRODUCT(pa->pa_id))
			break;		/* Exact match. */
		if (ap->ap_product == (u_int32_t) -1)
			break;		/* Wildcard match. */
	}

	if (ap->ap_attach == NULL)
		ap = NULL;

	return (ap);
}

void
pciagp_set_pchb(struct pci_attach_args *pa)
{
	if (!agp_pchb_pa_set) {
		memcpy(&agp_pchb_pa, pa, sizeof *pa);
		agp_pchb_pa_set++;
	}
}

int
agp_map_aperture(struct vga_pci_softc *sc)
{
	/*
	 * Find and the aperture. Don't map it (yet), this would
	 * eat KVA.
	 */
	if (pci_mapreg_info(sc->sc_pc, sc->sc_pcitag, AGP_APBASE,
	    PCI_MAPREG_TYPE_MEM, &sc->sc_apaddr, &sc->sc_apsize,
	    &sc->sc_apflags) != 0)
		return ENXIO;

	return 0;
}

struct agp_gatt *
agp_alloc_gatt(struct vga_pci_softc *sc)
{
	u_int32_t apsize = AGP_GET_APERTURE(sc);
	u_int32_t entries = apsize >> AGP_PAGE_SHIFT;
	struct agp_gatt *gatt;
	int nseg;

	gatt = malloc(sizeof(*gatt), M_DEVBUF, M_NOWAIT);
	if (!gatt)
		return (NULL);
	bzero(gatt, sizeof(*gatt));
	gatt->ag_entries = entries;

	if (agp_alloc_dmamem(sc->sc_dmat, entries * sizeof(u_int32_t),
	    0, &gatt->ag_dmamap, (caddr_t *)&gatt->ag_virtual,
	    &gatt->ag_physical, &gatt->ag_dmaseg, 1, &nseg) != 0)
		return NULL;

	gatt->ag_size = entries * sizeof(u_int32_t);
	memset(gatt->ag_virtual, 0, gatt->ag_size);
	agp_flush_cache();

	return gatt;
}

void
agp_free_gatt(struct vga_pci_softc *sc, struct agp_gatt *gatt)
{
	agp_free_dmamem(sc->sc_dmat, gatt->ag_size, gatt->ag_dmamap,
	    (caddr_t)gatt->ag_virtual, &gatt->ag_dmaseg, 1);
	free(gatt, M_DEVBUF);
}

int
agp_generic_detach(struct vga_pci_softc *sc)
{
	lockmgr(&sc->sc_lock, LK_DRAIN, NULL, curproc);
	agp_flush_cache();
	return 0;
}

int
agp_generic_enable(struct vga_pci_softc *sc, u_int32_t mode)
{
	pcireg_t tstatus, mstatus;
	pcireg_t command;
	int rq, sba, fw, rate, capoff;
	
	if (pci_get_capability(sc->sc_pc, sc->sc_pcitag, PCI_CAP_AGP,
	     &capoff, NULL) == 0) {
		printf("agp_generic_enable: not an AGP capable device\n");
		return -1;
	}

	tstatus = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
	    sc->sc_capoff + AGP_STATUS);
	mstatus = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
	    capoff + AGP_STATUS);

	/* Set RQ to the min of mode, tstatus and mstatus */
	rq = AGP_MODE_GET_RQ(mode);
	if (AGP_MODE_GET_RQ(tstatus) < rq)
		rq = AGP_MODE_GET_RQ(tstatus);
	if (AGP_MODE_GET_RQ(mstatus) < rq)
		rq = AGP_MODE_GET_RQ(mstatus);

	/* Set SBA if all three can deal with SBA */
	sba = (AGP_MODE_GET_SBA(tstatus)
	       & AGP_MODE_GET_SBA(mstatus)
	       & AGP_MODE_GET_SBA(mode));

	/* Similar for FW */
	fw = (AGP_MODE_GET_FW(tstatus)
	       & AGP_MODE_GET_FW(mstatus)
	       & AGP_MODE_GET_FW(mode));

	/* Figure out the max rate */
	rate = (AGP_MODE_GET_RATE(tstatus)
		& AGP_MODE_GET_RATE(mstatus)
		& AGP_MODE_GET_RATE(mode));
	if (rate & AGP_MODE_RATE_4x)
		rate = AGP_MODE_RATE_4x;
	else if (rate & AGP_MODE_RATE_2x)
		rate = AGP_MODE_RATE_2x;
	else
		rate = AGP_MODE_RATE_1x;

	/* Construct the new mode word and tell the hardware  */
	command = AGP_MODE_SET_RQ(0, rq);
	command = AGP_MODE_SET_SBA(command, sba);
	command = AGP_MODE_SET_FW(command, fw);
	command = AGP_MODE_SET_RATE(command, rate);
	command = AGP_MODE_SET_AGP(command, 1);
	pci_conf_write(sc->sc_pc, sc->sc_pcitag,
	    sc->sc_capoff + AGP_COMMAND, command);
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, capoff + AGP_COMMAND, command);
	return 0;
}

struct agp_memory *
agp_generic_alloc_memory(struct vga_pci_softc *sc, int type, vsize_t size)
{
	struct agp_memory *mem;

	if (type != 0) {
		printf("agp_generic_alloc_memory: unsupported type %d\n", type);
		return 0;
	}

	mem = malloc(sizeof *mem, M_DEVBUF, M_WAITOK);
	if (mem == NULL)
		return NULL;

	if (bus_dmamap_create(sc->sc_dmat, size, size / PAGE_SIZE + 1,
	    size, 0, BUS_DMA_NOWAIT, &mem->am_dmamap) != 0) {
		free(mem, M_DEVBUF);
		return NULL;
	}

	mem->am_id = sc->sc_nextid++;
	mem->am_size = size;
	mem->am_type = 0;
	mem->am_physical = 0;
	mem->am_offset = 0;
	mem->am_is_bound = 0;
	TAILQ_INSERT_TAIL(&sc->sc_memory, mem, am_link);
	sc->sc_allocated += size;

	return mem;
}

int
agp_generic_free_memory(struct vga_pci_softc *sc, struct agp_memory *mem)
{
	if (mem->am_is_bound)
		return EBUSY;

	sc->sc_allocated -= mem->am_size;
	TAILQ_REMOVE(&sc->sc_memory, mem, am_link);
	bus_dmamap_destroy(sc->sc_dmat, mem->am_dmamap);
	free(mem, M_DEVBUF);
	return 0;
}

int
agp_generic_bind_memory(struct vga_pci_softc *sc, struct agp_memory *mem,
			off_t offset)
{
	bus_dma_segment_t *segs, *seg;
	bus_size_t done, j;
	bus_addr_t pa;
	off_t i, k;
	int contigpages, nseg, error;

	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL, curproc);

	if (mem->am_is_bound) {
		printf("AGP: memory already bound\n");
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
		return EINVAL;
	}

	if (offset < 0
	    || (offset & (AGP_PAGE_SIZE - 1)) != 0
	    || offset + mem->am_size > AGP_GET_APERTURE(sc)) {
		printf("AGP: binding memory at bad offset %#lx\n",
			      (unsigned long) offset);
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
		return EINVAL;
	}

	/*
	 * XXXfvdl
	 * The memory here needs to be directly accessable from the
	 * AGP video card, so it should be allocated using bus_dma.
	 * However, it need not be contiguous, since individual pages
	 * are translated using the GATT.
	 *
	 * Using a large chunk of contiguous memory may get in the way
	 * of other subsystems that may need one, so we try to be friendly
	 * and ask for allocation in chunks of a minimum of 8 pages
	 * of contiguous memory on average, falling back to 4, 2 and 1
	 * if really needed. Larger chunks are preferred, since allocating
	 * a bus_dma_segment per page would be overkill.
	 */

	for (contigpages = 32; contigpages > 0; contigpages >>= 1) {
		nseg = (mem->am_size / (contigpages * PAGE_SIZE)) + 1;
		segs = malloc(nseg * sizeof *segs, M_DEVBUF, M_WAITOK);
		if (segs == NULL)
			return ENOMEM;
		if ((error = bus_dmamem_alloc(sc->sc_dmat, mem->am_size, PAGE_SIZE, 0,
		    segs, nseg, &mem->am_nseg, BUS_DMA_WAITOK)) != 0) {
			free(segs, M_DEVBUF);
			AGP_DPF("bus_dmamem_alloc failed %d\n", error);
			continue;
		}
		if ((error = bus_dmamem_map(sc->sc_dmat, segs, mem->am_nseg,
		    mem->am_size, &mem->am_virtual, BUS_DMA_WAITOK)) != 0) {
			bus_dmamem_free(sc->sc_dmat, segs, mem->am_nseg);
			free(segs, M_DEVBUF);
			AGP_DPF("bus_dmamem_map failed %d\n", error);
			continue;
		}
		if ((error = bus_dmamap_load(sc->sc_dmat, mem->am_dmamap,
		    mem->am_virtual, mem->am_size, NULL,
		    BUS_DMA_WAITOK)) != 0) {
			bus_dmamem_unmap(sc->sc_dmat, mem->am_virtual,
			    mem->am_size);
			bus_dmamem_free(sc->sc_dmat, segs, mem->am_nseg);
			free(segs, M_DEVBUF);
			AGP_DPF("bus_dmamap_load failed %d\n", error);
			continue;
		}
		mem->am_dmaseg = segs;
		break;
	}

	if (contigpages == 0) {
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
		return ENOMEM;
	}

	/*
	 * Bind the individual pages and flush the chipset's
	 * TLB.
	 */
	done = 0;
	for (i = 0; i < mem->am_dmamap->dm_nsegs; i++) {
		seg = &mem->am_dmamap->dm_segs[i];
		/*
		 * Install entries in the GATT, making sure that if
		 * AGP_PAGE_SIZE < PAGE_SIZE and mem->am_size is not
		 * aligned to PAGE_SIZE, we don't modify too many GATT
		 * entries.
		 */
		for (j = 0; j < seg->ds_len && (done + j) < mem->am_size;
		     j += AGP_PAGE_SIZE) {
			pa = seg->ds_addr + j;
			AGP_DPF("binding offset %#lx to pa %#lx\n",
				(unsigned long)(offset + done + j),
				(unsigned long)pa);
			error = AGP_BIND_PAGE(sc, offset + done + j, pa);
			if (error) {
				/*
				 * Bail out. Reverse all the mappings
				 * and unwire the pages.
				 */
				for (k = 0; k < done + j; k += AGP_PAGE_SIZE)
					AGP_UNBIND_PAGE(sc, offset + k);

				bus_dmamap_unload(sc->sc_dmat, mem->am_dmamap);
				bus_dmamem_unmap(sc->sc_dmat, mem->am_virtual,
						 mem->am_size);
				bus_dmamem_free(sc->sc_dmat, mem->am_dmaseg,
						mem->am_nseg);
				free(mem->am_dmaseg, M_DEVBUF);
				lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
				return error;
			}
		}
		done += seg->ds_len;
	}

	/*
	 * Flush the cpu cache since we are providing a new mapping
	 * for these pages.
	 */
	agp_flush_cache();

	/*
	 * Make sure the chipset gets the new mappings.
	 */
	AGP_FLUSH_TLB(sc);

	mem->am_offset = offset;
	mem->am_is_bound = 1;

	lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);

	return 0;
}

int
agp_generic_unbind_memory(struct vga_pci_softc *sc, struct agp_memory *mem)
{
	int i;

	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL, curproc);

	if (!mem->am_is_bound) {
		printf("AGP: memory is not bound\n");
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
		return EINVAL;
	}


	/*
	 * Unbind the individual pages and flush the chipset's
	 * TLB. Unwire the pages so they can be swapped.
	 */
	for (i = 0; i < mem->am_size; i += AGP_PAGE_SIZE)
		AGP_UNBIND_PAGE(sc, mem->am_offset + i);

	agp_flush_cache();
	AGP_FLUSH_TLB(sc);

	bus_dmamap_unload(sc->sc_dmat, mem->am_dmamap);
	bus_dmamem_unmap(sc->sc_dmat, mem->am_virtual, mem->am_size);
	bus_dmamem_free(sc->sc_dmat, mem->am_dmaseg, mem->am_nseg);

	free(mem->am_dmaseg, M_DEVBUF);

	mem->am_offset = 0;
	mem->am_is_bound = 0;

	lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);

	return 0;
}

int
agp_alloc_dmamem(bus_dma_tag_t tag, size_t size, int flags,
		 bus_dmamap_t *mapp, caddr_t *vaddr, bus_addr_t *baddr,
		 bus_dma_segment_t *seg, int nseg, int *rseg)

{
	int error, level = 0;

	if ((error = bus_dmamem_alloc(tag, size, PAGE_SIZE, 0,
			seg, nseg, rseg, BUS_DMA_NOWAIT)) != 0)
		goto out;
	level++;

	if ((error = bus_dmamem_map(tag, seg, *rseg, size, vaddr,
			BUS_DMA_NOWAIT | flags)) != 0)
		goto out;
	level++;

	if ((error = bus_dmamap_create(tag, size, *rseg, size, 0,
			BUS_DMA_NOWAIT, mapp)) != 0)
		goto out;
	level++;

	if ((error = bus_dmamap_load(tag, *mapp, *vaddr, size, NULL,
			BUS_DMA_NOWAIT)) != 0)
		goto out;

	*baddr = (*mapp)->dm_segs[0].ds_addr;

	return 0;
out:
	switch (level) {
	case 3:
		bus_dmamap_destroy(tag, *mapp);
		/* FALLTHROUGH */
	case 2:
		bus_dmamem_unmap(tag, *vaddr, size);
		/* FALLTHROUGH */
	case 1:
		bus_dmamem_free(tag, seg, *rseg);
		break;
	default:
		break;
	}

	return error;
}

void
agp_free_dmamem(bus_dma_tag_t tag, size_t size, bus_dmamap_t map,
		caddr_t vaddr, bus_dma_segment_t *seg, int nseg)
{

	bus_dmamap_unload(tag, map);
	bus_dmamap_destroy(tag, map);
	bus_dmamem_unmap(tag, vaddr, size);
	bus_dmamem_free(tag, seg, nseg);
a148 1
#endif
@


1.7.10.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a178 4
#ifdef ISA_SPACE_NOT_ACCESSABLE_WITH_PCI_IOT
	if (!vga_common_probe(MD_ISA_IOT, MD_ISA_MEMT))
		return (0);
#else
a180 1
#endif
a189 1
#ifndef ISA_SPACE_NOT_ACCESSABLE_WITH_PCI_IOT
a190 1
#endif
a254 4
#ifdef ISA_SPACE_NOT_ACCESSABLE_WITH_PCI_IOT
	vga_extended_attach(self, MD_ISA_IOT, ppc_isa_membus_space,
	    WSDISPLAY_TYPE_PCIVGA, vga_pci_mmap);
#else
a256 1
#endif
a274 4
#endif
#ifdef __pegasos__
	/* XXX */
		return off;
@


1.7.10.6
log
@Merge with the trunk
@
text
@d179 2
a180 2
#ifdef MD_DISPLAY_ISA_IOT
	if (!vga_common_probe(MD_DISPLAY_ISA_IOT, MD_DISPLAY_ISA_MEMT))
d195 1
a195 1
#ifndef MD_DISPLAY_ISA_IOT
d262 2
a263 2
#ifdef MD_DISPLAY_ISA_IOT
	vga_extended_attach(self, MD_DISPLAY_ISA_IOT, ppc_isa_membus_space,
d287 4
@


1.6
log
@Add some missing things for the MI vga driver.  Move wscons to an MI place as
well.  $OpenBSD$ tagging
@
text
@d1 1
a1 1
/*	$OpenBSD: vga_pci.c,v 1.4 1996/12/05 01:39:38 cgd Exp $	*/
a122 1
	char devinfo[256];
d140 1
a140 3
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
	printf(": %s (rev. 0x%02x)\n", devinfo,
	    PCI_REVISION(pa->pa_class));
@


1.5
log
@We need an MI vga driver.  The alpha one was most MI.  Not entirely yet though.
Some files were move behind CVS back.
@
text
@d1 1
@


1.4
log
@typecast vga_pci_match to cgmatch_t
compare pci tags w/ bcmp
@
text
@d45 2
a46 2
#include <alpha/dev/vgavar.h>
#include <alpha/pci/vga_pcivar.h>
@


1.3
log
@wscons -> vga_xxx -> vga mmap() support. first cut
@
text
@d36 1
d38 1
d66 1
a66 1
	sizeof(struct vga_pci_softc), vga_pci_match, vga_pci_attach,
d102 1
a102 1
	if (pa->pa_tag == vga_pci_console_tag)
d125 1
a125 1
	console = (pa->pa_tag == vga_pci_console_tag);
@


1.2
log
@alpha/common/ insults my filec
@
text
@d60 3
d133 2
d160 24
@


1.1
log
@Sync with NetBSD 961207
@
text
@d43 1
a43 1
#include <alpha/common/vgavar.h>
@
