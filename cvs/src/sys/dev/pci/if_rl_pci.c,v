head	1.33;
access;
symbols
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.6
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.31.0.4
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.30.0.4
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.21.0.6
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.4
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.14.0.10
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.8
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.6
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.9.0.8
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.6.0.2
	UBC_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	SMP:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2;
locks; strict;
comment	@ * @;


1.33
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.32;
commitid	5gdEnqVoJuTuwdTu;

1.32
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.31;
commitid	5DvsamK0GblTp8ww;

1.31
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.30;
commitid	p4LJxGKbi0BU2cG6;

1.30
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.29;
commitid	yM2VFFhpDTeFQlve;

1.29
date	2014.11.24.02.03.37;	author brad;	state Exp;
branches;
next	1.28;
commitid	Wmnzf8bGQILqXRTG;

1.28
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.27;
commitid	TGHgrLxu6sxZoiFt;

1.27
date	2013.08.07.01.06.36;	author bluhm;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.07.01.03.57;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2013.02.08.08.00.34;	author jasper;	state Exp;
branches;
next	1.24;

1.24
date	2013.01.29.01.45.05;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2013.01.16.06.15.58;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2013.01.16.04.42.44;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.20;

1.20
date	2010.08.27.20.21.43;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2010.07.27.17.34.26;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.21.18.14.51;	author naddy;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.02.17.27.39;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.02.04.03.39;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2008.08.13.03.47.16;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.23.00.41.50;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.16.02.32.39;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.24.00.26.16;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.24.00.40.06;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.11.18.17.08;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.29.23.06.55;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.12.20.03.49;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.13.15.58.44;	author aaron;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2001.04.10.22.52.00;	author aaron;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.14.22.25.46;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.2.4.6;

1.2.4.6
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.33
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_rl_pci.c,v 1.32 2015/11/24 13:33:17 mpi Exp $ */

/*
 * Copyright (c) 1997, 1998
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/timeout.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/bus.h>

#include <dev/mii/miivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

/*
 * Default to using PIO access for this driver. On SMP systems,
 * there appear to be problems with memory mapped mode: it looks like
 * doing too many memory mapped access back to back in rapid succession
 * can hang the bus. I'm inclined to blame this on crummy design/construction
 * on the part of Realtek. Memory mapped mode does appear to work on
 * uniprocessor systems though.
 */
#define RL_USEIOSPACE

#include <dev/ic/rtl81x9reg.h>

int rl_pci_match(struct device *, void *, void *);
void rl_pci_attach(struct device *, struct device *, void *);
int rl_pci_detach(struct device *, int);

struct rl_pci_softc {
	struct rl_softc		psc_softc;
	pci_chipset_tag_t	psc_pc;
	bus_size_t		psc_mapsize;
};

struct cfattach rl_pci_ca = {
	sizeof(struct rl_pci_softc), rl_pci_match, rl_pci_attach, rl_pci_detach,
	rl_activate
};

const struct pci_matchid rl_pci_devices[] = {
	{ PCI_VENDOR_ABOCOM, PCI_PRODUCT_ABOCOM_FE2000VX },
	{ PCI_VENDOR_ACCTON, PCI_PRODUCT_ACCTON_5030 },
	{ PCI_VENDOR_ADDTRON, PCI_PRODUCT_ADDTRON_8139 },
	{ PCI_VENDOR_COREGA, PCI_PRODUCT_COREGA_2CB_TXD },
	{ PCI_VENDOR_COREGA, PCI_PRODUCT_COREGA_CB_TXD },
	{ PCI_VENDOR_DELTA, PCI_PRODUCT_DELTA_8139 },
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_DFE520TX_C1 },
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_DFE530TXPLUS },
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_DFE690TXD },
	{ PCI_VENDOR_DLINK2, PCI_PRODUCT_DLINK2_DFE530TXPLUS2 },
	{ PCI_VENDOR_NORTEL, PCI_PRODUCT_NORTEL_BS21 },
	{ PCI_VENDOR_PLANEX, PCI_PRODUCT_PLANEX_FNW_3603_TX },
	{ PCI_VENDOR_PLANEX, PCI_PRODUCT_PLANEX_FNW_3800_TX },
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8129 },
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8138 },
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8139D }
};

int
rl_pci_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_REALTEK &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_REALTEK_RT8139 &&
	    PCI_REVISION(pa->pa_class) == 0x10)
		return (1);

	return (pci_matchbyid((struct pci_attach_args *)aux, rl_pci_devices,
	    nitems(rl_pci_devices)));
}

void
rl_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct rl_pci_softc	*psc = (void *)self;
	struct rl_softc		*sc = &psc->psc_softc;
	struct pci_attach_args	*pa = aux;
	pci_chipset_tag_t	pc = pa->pa_pc;
	pci_intr_handle_t	ih;
	const char		*intrstr = NULL;

	/*
	 * Map control/status registers.
	 */

#ifdef RL_USEIOSPACE
	if (pci_mapreg_map(pa, RL_PCI_LOIO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->rl_btag, &sc->rl_bhandle, NULL, &psc->psc_mapsize, 0)) {
		printf(": can't map i/o space\n");
		return;
	}
#else
	if (pci_mapreg_map(pa, RL_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->rl_btag, &sc->rl_bhandle, NULL, &psc->psc_mapsize, 0)){
		printf(": can't map mem space\n");
		return;
	}
#endif

	/*
	 * Allocate our interrupt.
	 */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		bus_space_unmap(sc->rl_btag, sc->rl_bhandle, psc->psc_mapsize);
		return;
	}

	psc->psc_pc = pa->pa_pc;
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, rl_intr, sc,
	    self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(sc->rl_btag, sc->rl_bhandle, psc->psc_mapsize);
		return;
	}
	printf(": %s", intrstr);

	sc->sc_dmat = pa->pa_dmat;

	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_REALTEK_RT8129)
		sc->rl_type = RL_8129;
	else
		sc->rl_type = RL_8139;

	rl_attach(sc);
}

int
rl_pci_detach(struct device *self, int flags)
{
	struct rl_pci_softc	*psc = (void *)self;
	struct rl_softc		*sc = &psc->psc_softc;
	int			rv;

	rv = rl_detach(sc);
	if (rv)
		return (rv);

	if (sc->sc_ih != NULL)
		pci_intr_disestablish(psc->psc_pc, sc->sc_ih);

	bus_space_unmap(sc->rl_btag, sc->rl_bhandle, psc->psc_mapsize);

	return (0);
}
@


1.32
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.31 2015/03/14 03:38:48 jsg Exp $ */
a47 1
#include <net/if_dl.h>
@


1.31
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.30 2014/12/22 02:28:52 tedu Exp $ */
a48 1
#include <net/if_types.h>
@


1.30
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.29 2014/11/24 02:03:37 brad Exp $ */
a61 1
#include <dev/mii/mii.h>
@


1.29
log
@use the correct capitalization for Realtek.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.28 2014/07/22 13:12:11 mpi Exp $ */
a50 1
#ifdef INET
a52 1
#endif
@


1.28
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.27 2013/08/07 01:06:36 bluhm Exp $ */
d75 1
a75 1
 * on the part of RealTek. Memory mapped mode does appear to work on
@


1.27
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.26 2013/03/07 01:03:57 brad Exp $ */
a52 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.26
log
@Fix and simplify determining whether we're using a 8129 or 8139 chipset. Only
the 8129 PCI id is a 8129, everything else is a 8139.

Allows the D-Link DFE-520TX board to work and would ensure proper determination
of the chipset for at least the 8138 based boards (PCI/CardBus).

Tested by kirby@@
Ok kirby@@ sthen@@ chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.25 2013/02/08 08:00:34 jasper Exp $ */
a53 1
#include <netinet/in_var.h>
@


1.25
log
@add another DFE-530TX+

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.24 2013/01/29 01:45:05 brad Exp $ */
d185 5
@


1.24
log
@Add the PCI id for the D-Link DFE-520TX C1 board.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.23 2013/01/16 06:15:58 brad Exp $ */
d110 1
@


1.23
log
@Some corrections for D-Link device names.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.22 2013/01/16 04:42:44 brad Exp $ */
d107 1
@


1.22
log
@Sort the PCI ids.

ok dtucker@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.21 2011/04/03 15:36:02 jasper Exp $ */
d107 1
a107 1
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_530TXPLUS },
@


1.21
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.20 2010/08/27 20:21:43 deraadt Exp $ */
d101 1
d104 2
d108 1
d110 2
a112 2
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8139D },
	{ PCI_VENDOR_ABOCOM, PCI_PRODUCT_ABOCOM_FE2000VX },
d114 1
a114 5
	{ PCI_VENDOR_COREGA, PCI_PRODUCT_COREGA_CB_TXD },
	{ PCI_VENDOR_COREGA, PCI_PRODUCT_COREGA_2CB_TXD },
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_DFE690TXD },
	{ PCI_VENDOR_PLANEX, PCI_PRODUCT_PLANEX_FNW_3603_TX },
	{ PCI_VENDOR_PLANEX, PCI_PRODUCT_PLANEX_FNW_3800_TX }
@


1.20
log
@Move the activate function from pci to the the main driver, so that the
powerhook can use it
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.19 2010/07/27 17:34:26 deraadt Exp $ */
d128 1
a128 1
	    sizeof(rl_pci_devices)/sizeof(rl_pci_devices[0])));
@


1.19
log
@ca_activate function for suspend/resume
tested by mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.18 2009/12/21 18:14:51 naddy Exp $ */
a87 1
int rl_pci_activate(struct device *, int);
d97 1
a97 1
	rl_pci_activate
a203 25
}

int
rl_pci_activate(struct device *self, int act)
{
	struct rl_pci_softc *psc = (struct rl_pci_softc *)self;
	struct rl_softc	*sc = &psc->psc_softc;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int rv = 0;
	extern void rl_stop(struct rl_softc *);
	extern void rl_init(struct rl_softc *);

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			rl_stop(sc);
		rv = config_activate_children(self, act);
		break;
	case DVACT_RESUME:
		rv = config_activate_children(self, act);
		if (ifp->if_flags & IFF_UP)
			rl_init(sc);
		break;
	}
	return rv;
@


1.18
log
@Some cleaning for the rl(4) driver:
- ANSI
- KNF
- remove the use of register

from Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.17 2009/06/02 17:27:39 jsg Exp $ */
d88 1
d97 2
a98 1
	sizeof(struct rl_pci_softc), rl_pci_match, rl_pci_attach, rl_pci_detach
d207 24
@


1.17
log
@make rl at pci detachable; untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.16 2009/06/02 04:03:39 jsg Exp $ */
d117 1
a117 4
rl_pci_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d131 1
a131 3
rl_pci_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d133 6
a138 6
	struct rl_pci_softc *psc = (void *)self;
	struct rl_softc *sc = &psc->psc_softc;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
d189 3
a191 3
	struct rl_pci_softc *psc = (void *)self;
	struct rl_softc *sc = &psc->psc_softc;
	int rv;
@


1.16
log
@Add more CardBus ids to PCI attachments to cope with
things like the crazy ExpressCard->CardBus adapters which
make CardBus devices show as PCI devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.15 2008/08/13 03:47:16 brad Exp $ */
d87 7
d96 1
a96 1
	sizeof(struct rl_softc), rl_pci_match, rl_pci_attach,
d138 2
a139 1
	struct rl_softc *sc = (struct rl_softc *)self;
a143 1
	bus_size_t size;
d151 1
a151 1
	    &sc->rl_btag, &sc->rl_bhandle, NULL, &size, 0)) {
d157 1
a157 1
	    &sc->rl_btag, &sc->rl_bhandle, NULL, &size, 0)){
d168 1
a168 1
		bus_space_unmap(sc->rl_btag, sc->rl_bhandle, size);
d172 1
d181 1
a181 1
		bus_space_unmap(sc->rl_btag, sc->rl_bhandle, size);
d190 20
@


1.15
log
@Add the 8139D PCI id.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.14 2006/05/23 00:41:50 brad Exp $ */
d99 8
a106 1
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8139D }
@


1.14
log
@according to the Linux 8139cp driver the TTTech MC322 adapter uses
the 8139C+ chipset, so attach with re(4) instead of rl(4).

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.13 2006/05/16 02:32:39 brad Exp $ */
d98 2
a99 1
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8129 }
@


1.13
log
@attach 8139's capable of C+ mode to the re(4) driver, instead of the rl(4)
driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.12 2006/02/24 00:26:16 brad Exp $ */
d98 1
a98 2
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8129 },
	{ PCI_VENDOR_TTTECH, PCI_PRODUCT_TTTECH_MC322 }
@


1.12
log
@add TTTech MC322

PCI id from the Linux 8139cp driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.11 2005/10/24 00:40:06 brad Exp $ */
a98 1
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8139 },
d108 7
@


1.11
log
@- remove some redundnt checks before pci_mapreg_map()
- iosize -> size
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.10 2005/09/11 18:17:08 mickey Exp $ */
d100 1
@


1.10
log
@do not inline pci_mapreg_map() anymore as it is olrite now; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.9 2003/12/29 23:06:55 brad Exp $ */
d122 1
a122 10
	bus_size_t iosize;
	u_int32_t command;

	command = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);

#ifdef RL_USEIOSPACE
	if (!(command & PCI_COMMAND_IO_ENABLE)) {
		printf(": failed to enable i/o ports\n");
		return;
	}
d127 2
d130 1
a130 1
	    &sc->rl_btag, &sc->rl_bhandle, NULL, &iosize, 0)) {
a134 4
	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf(": failed to enable memory mapping\n");
		return;
	}
d136 1
a136 1
	    &sc->rl_btag, &sc->rl_bhandle, NULL, &iosize, 0)){
d147 1
a147 1
		bus_space_unmap(sc->rl_btag, sc->rl_bhandle, iosize);
d159 1
a159 1
		bus_space_unmap(sc->rl_btag, sc->rl_bhandle, iosize);
@


1.9
log
@no vtophys(), don't need uvm_extern.h anymore.

tested on alpha, i386, macppc and sparc64.

ok millert@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.8 2002/11/19 18:40:17 jason Exp $ */
a121 1
	bus_addr_t iobase;
d136 2
a137 5
	if (pci_io_find(pc, pa->pa_tag, RL_PCI_LOIO, &iobase, &iosize)) {
		printf(": can't find i/o space\n");
		return;
	}
	if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->rl_bhandle)) {
a140 1
	sc->rl_btag = pa->pa_iot;
d146 2
a147 5
	if (pci_mem_find(pc, pa->pa_tag, RL_PCI_LOMEM, &iobase, &iosize, NULL)){
		printf(": can't find mem space\n");
		return;
	}
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->rl_bhandle)) {
a150 1
	sc->rl_btag = pa->pa_memt;
d158 1
d170 1
@


1.8
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.7 2002/03/14 01:26:59 millert Exp $ */
a64 1
#include <uvm/uvm_extern.h>              /* for vtophys */
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.6 2001/11/06 19:53:19 miod Exp $ */
d93 8
a100 9
struct rl_type rl_pci_devs[] = {
	{ PCI_VENDOR_ACCTON, PCI_PRODUCT_ACCTON_5030		},
	{ PCI_VENDOR_ADDTRON, PCI_PRODUCT_ADDTRON_8139		},
	{ PCI_VENDOR_DELTA, PCI_PRODUCT_DELTA_8139		},
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_530TXPLUS		},
	{ PCI_VENDOR_NORTEL, PCI_PRODUCT_NORTEL_BS21		},
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8129	},
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8139	},
	{ 0, 0 }
d109 2
a110 9
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	struct rl_type *t;  
        
	for (t = rl_pci_devs; t->rl_vid != 0; t++) {
		if ((PCI_VENDOR(pa->pa_id) == t->rl_vid) &&
		    (PCI_PRODUCT(pa->pa_id) == t->rl_did))
			return (1);
	}
	return (0);
@


1.6
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.5 2001/09/11 20:05:25 miod Exp $ */
d86 2
a87 2
int rl_pci_match	__P((struct device *, void *, void *));
void rl_pci_attach	__P((struct device *, struct device *, void *));
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.6 2001/11/06 19:53:19 miod Exp $ */
d86 2
a87 2
int rl_pci_match(struct device *, void *, void *);
void rl_pci_attach(struct device *, struct device *, void *);
@


1.6.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d93 9
a101 8
const struct pci_matchid rl_pci_devices[] = {
	{ PCI_VENDOR_ACCTON, PCI_PRODUCT_ACCTON_5030 },
	{ PCI_VENDOR_ADDTRON, PCI_PRODUCT_ADDTRON_8139 },
	{ PCI_VENDOR_DELTA, PCI_PRODUCT_DELTA_8139 },
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_530TXPLUS },
	{ PCI_VENDOR_NORTEL, PCI_PRODUCT_NORTEL_BS21 },
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8129 },
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8139 },
d110 9
a118 2
	return (pci_matchbyid((struct pci_attach_args *)aux, rl_pci_devices,
	    sizeof(rl_pci_devices)/sizeof(rl_pci_devices[0])));
@


1.5
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.4 2001/08/25 10:13:29 art Exp $ */
d65 1
a65 1
#include <vm/vm.h>              /* for vtophys */
@


1.4
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.3 2001/08/12 20:03:49 mickey Exp $ */
a65 1
#include <vm/vm_kern.h>
@


1.3
log
@remove redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.2 2001/04/13 15:58:44 aaron Exp $ */
d175 1
a175 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.2
log
@Define RL_USEIOSPACE in the PCI bus piece, not the common piece; thanks jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.1 2001/04/10 22:52:00 aaron Exp $ */
a65 1
#include <vm/pmap.h>            /* for vtophys */
a66 1
#include <vm/vm_extern.h>
@


1.2.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.2 2001/04/13 15:58:44 aaron Exp $ */
@


1.2.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rl_pci.c,v 1.2.4.1 2001/05/14 22:25:46 niklas Exp $ */
d66 3
d177 2
a178 1
	if (pci_intr_map(pa, &ih)) {
@


1.2.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d65 1
a65 1
#include <uvm/uvm_extern.h>              /* for vtophys */
@


1.2.4.4
log
@Merge in -current from roughly a week ago
@
text
@d86 2
a87 2
int rl_pci_match(struct device *, void *, void *);
void rl_pci_attach(struct device *, struct device *, void *);
@


1.2.4.5
log
@Sync the SMP branch with 3.3
@
text
@d93 9
a101 8
const struct pci_matchid rl_pci_devices[] = {
	{ PCI_VENDOR_ACCTON, PCI_PRODUCT_ACCTON_5030 },
	{ PCI_VENDOR_ADDTRON, PCI_PRODUCT_ADDTRON_8139 },
	{ PCI_VENDOR_DELTA, PCI_PRODUCT_DELTA_8139 },
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_530TXPLUS },
	{ PCI_VENDOR_NORTEL, PCI_PRODUCT_NORTEL_BS21 },
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8129 },
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8139 },
d110 9
a118 2
	return (pci_matchbyid((struct pci_attach_args *)aux, rl_pci_devices,
	    sizeof(rl_pci_devices)/sizeof(rl_pci_devices[0])));
@


1.2.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d65 1
@


1.1
log
@Split RealTek 8129/8139 driver into bus-dependent and bus-independent parts;
prep for an rl CardBus attachment.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d76 10
@

