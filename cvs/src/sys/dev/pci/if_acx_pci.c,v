head	1.9;
access;
symbols
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.8
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.6
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.7.0.26
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.24
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.22
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.18
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.16
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.14
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.12
	OPENBSD_5_0:1.7.0.10
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.8
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.6
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.6.0.10
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.8
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.6
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.4
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.9
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.8;
commitid	5gdEnqVoJuTuwdTu;

1.8
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.7;
commitid	p4LJxGKbi0BU2cG6;

1.7
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.18.20.44.40;	author grange;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.10.20.20.04;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2006.08.19.23.17.12;	author mglocker;	state Exp;
branches;
next	1.3;

1.3
date	2006.08.14.21.12.10;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.03.17.23.03;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.03.08.45.03;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.9
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_acx_pci.c,v 1.8 2015/03/14 03:38:48 jsg Exp $  */

/*-
 * Copyright (c) 2006 Theo de Raadt <deraadt@@openbsd.org>
 * Copyright (c) 2005, 2006
 *	Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * PCI front-end for the ACX100/111
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/timeout.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/ic/acxvar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

struct acx_pci_softc {
	struct acx_softc	sc_acx;

	/* PCI specific goo */
	struct acx_opns		*sc_opns;
	pci_chipset_tag_t	sc_pc;
	void			*sc_ih;
	bus_size_t		sc_mapsize1;
	bus_size_t		sc_mapsize2;
	int			sc_intrline;

	/* hack for ACX100A */
	bus_space_tag_t		sc_io_bt;
	bus_space_handle_t	sc_io_bh;
	bus_size_t		sc_iomapsize;
};

/* Base Address Register */
#define ACX_PCI_BAR0	0x10
#define ACX_PCI_BAR1	0x14
#define ACX_PCI_BAR2	0x18

int	acx_pci_match(struct device *, void *, void *);
void	acx_pci_attach(struct device *, struct device *, void *);
int	acx_pci_detach(struct device *, int);

struct cfattach acx_pci_ca = {
	sizeof (struct acx_pci_softc), acx_pci_match, acx_pci_attach,
	acx_pci_detach
};

const struct pci_matchid acx_pci_devices[] = {
	{ PCI_VENDOR_TI, PCI_PRODUCT_TI_ACX100A	},
	{ PCI_VENDOR_TI, PCI_PRODUCT_TI_ACX100B	},
	{ PCI_VENDOR_TI, PCI_PRODUCT_TI_ACX111	}
};

int
acx_pci_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, acx_pci_devices,
	    sizeof (acx_pci_devices) / sizeof (acx_pci_devices[0])));
}

void
acx_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct acx_pci_softc *psc = (struct acx_pci_softc *)self;
	struct acx_softc *sc = &psc->sc_acx;
	struct pci_attach_args *pa = aux;
	const char *intrstr = NULL;
	pci_intr_handle_t ih;
	int error, b1 = ACX_PCI_BAR0, b2 = ACX_PCI_BAR1;

	sc->sc_dmat = pa->pa_dmat;
	psc->sc_pc = pa->pa_pc;

	/* map control/status registers */
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_TI_ACX100A) {
		error = pci_mapreg_map(pa, ACX_PCI_BAR0,
		    PCI_MAPREG_TYPE_IO, 0, &psc->sc_io_bt,
		    &psc->sc_io_bh, NULL, &psc->sc_iomapsize, 0);
		if (error != 0) {
			printf(": can't map i/o space\n");
			return;
		}
		b1 = ACX_PCI_BAR1;
		b2 = ACX_PCI_BAR2;
	}

	error = pci_mapreg_map(pa, b1, PCI_MAPREG_TYPE_MEM |
	    PCI_MAPREG_MEM_TYPE_32BIT, 0, &sc->sc_mem1_bt,
	    &sc->sc_mem1_bh, NULL, &psc->sc_mapsize1, 0);
	if (error != 0) {
		printf(": can't map mem1 space\n");
		return;
	}

	error = pci_mapreg_map(pa, b2, PCI_MAPREG_TYPE_MEM |
	    PCI_MAPREG_MEM_TYPE_32BIT, 0, &sc->sc_mem2_bt,
	    &sc->sc_mem2_bh, NULL, &psc->sc_mapsize2, 0);
	if (error != 0) {
		printf(": can't map mem2 space\n");
		return;
	}

	if (pci_intr_map(pa, &ih) != 0) {
		printf(": can't map interrupt\n");
		return;
	}

	intrstr = pci_intr_string(psc->sc_pc, ih);
	psc->sc_ih = pci_intr_establish(psc->sc_pc, ih, IPL_NET,
	    acx_intr, sc, sc->sc_dev.dv_xname);
	if (psc->sc_ih == NULL) {
		printf(": can't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s\n", intrstr);

	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_TI_ACX111)
		acx111_set_param(sc);
	else
		acx100_set_param(sc);

	acx_attach(sc);
}

int
acx_pci_detach(struct device *self, int flags)
{
	struct acx_pci_softc *psc = (struct acx_pci_softc *)self;
	struct acx_softc *sc = &psc->sc_acx;

	acx_detach(sc);
	pci_intr_disestablish(psc->sc_pc, psc->sc_ih);

	return 0;
}
@


1.8
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_acx_pci.c,v 1.7 2009/03/29 21:53:52 sthen Exp $  */
a40 1
#include <net/if_dl.h>
@


1.7
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_acx_pci.c,v 1.6 2006/11/18 20:44:40 grange Exp $  */
a51 1
#include <dev/ic/acxreg.h>
@


1.6
log
@Remove some useless variables/code dealing with cardbus BARs
reprogramming.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_acx_pci.c,v 1.5 2006/11/10 20:20:04 damien Exp $  */
d121 1
a121 1
			printf(": could not map i/o space\n");
d132 1
a132 1
		printf(": could not map memory1 space\n");
d140 1
a140 1
		printf(": could not map memory2 space\n");
d145 1
a145 1
		printf(": could not map interrupt\n");
d153 1
a153 1
		printf(": could not establish interrupt");
@


1.5
log
@acx(4) doesn't use rssadapt(9).
pgt(4) doesn't use rssadapt(9) nor amrr.
=> remove useless #include.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_acx_pci.c,v 1.4 2006/08/19 23:17:12 mglocker Exp $  */
a66 3
	pcireg_t		sc_iobar_val; /* acx100 only */
	pcireg_t		sc_bar1_val;
	pcireg_t		sc_bar2_val;
a108 1
	bus_addr_t base;
d119 1
a119 1
		    &psc->sc_io_bh, &base, &psc->sc_iomapsize, 0);
a123 1
		psc->sc_iobar_val = base | PCI_MAPREG_TYPE_IO;
d130 1
a130 1
	    &sc->sc_mem1_bh, &base, &psc->sc_mapsize1, 0);
a135 2
	psc->sc_bar1_val = base | PCI_MAPREG_TYPE_MEM;

d138 1
a138 1
	    &sc->sc_mem2_bh, &base, &psc->sc_mapsize2, 0);
a142 2

	psc->sc_bar2_val = base | PCI_MAPREG_TYPE_MEM;
@


1.4
log
@Replace existing rate adaption code with the ieee80211_amrr framework.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_acx_pci.c,v 1.3 2006/08/14 21:12:10 deraadt Exp $  */
a48 1
#include <net80211/ieee80211_rssadapt.h>
@


1.3
log
@split line
@
text
@d1 1
a1 1
/*	$OpenBSD: if_acx_pci.c,v 1.2 2006/08/03 17:23:03 brad Exp $  */
d48 1
@


1.2
log
@- initialize interrupt string to NULL.
- remove bogus 32-bit memory type flag when mapping I/O space.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_acx_pci.c,v 1.1 2006/08/03 08:45:03 deraadt Exp $  */
d168 1
a168 1
	printf(": %s", intrstr);
@


1.1
log
@pci front end for acx
@
text
@d1 1
a1 1
/*	$OpenBSD: if_acx_pci.c,v 1.6 2006/01/09 20:03:43 damien Exp $  */
d111 1
a111 1
	const char *intrstr;
d122 2
a123 3
		    PCI_MAPREG_TYPE_IO | PCI_MAPREG_MEM_TYPE_32BIT,
		    0, &psc->sc_io_bt, &psc->sc_io_bh, &base,
		    &psc->sc_iomapsize, 0);
@

