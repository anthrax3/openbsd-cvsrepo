head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.10
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.14
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.12
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.8
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.6
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.20.0.8
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.4
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.2
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.19.0.4
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.2
	OPENBSD_5_0:1.18.0.6
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.4
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.4.0.2
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.3.0.10
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.8
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.2.0.14
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.12
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.10
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.2
	SMP:1.2.0.8
	OPENBSD_3_3:1.2.0.6
	OPENBSD_3_3_BASE:1.2
	UBC:1.2.0.4
	UBC_SYNC_B:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.23
date	2014.05.27.12.40.00;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2014.03.26.14.41.41;	author mpi;	state Exp;
branches;
next	1.21;

1.21
date	2014.03.18.09.21.35;	author mpi;	state Exp;
branches;
next	1.20;

1.20
date	2012.11.13.23.36.17;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2011.10.24.15.42.33;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2010.08.07.20.47.24;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2010.08.07.17.44.09;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2009.05.10.16.57.44;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2009.05.10.15.28.45;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2009.05.10.14.44.42;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.09.15.11.19;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.02.10.29.34;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2008.01.04.00.23.26;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2007.12.07.17.35.22;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2007.12.06.22.49.39;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.26.15.35.15;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2007.11.25.17.11.12;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.06.23.50.54;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2007.08.04.19.40.25;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2004.10.01.04.08.46;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.25.23.31.04;	author fgsch;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2002.07.12.20.17.03;	author mickey;	state Exp;
branches;
next	;

1.2.4.1
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.23
log
@We're never going to detach agp(4), so remove the #ifdef'ed out code like we
already did for intagp(4).
@
text
@/*	$OpenBSD: agp_intel.c,v 1.22 2014/03/26 14:41:41 mpi Exp $	*/
/*	$NetBSD: agp_intel.c,v 1.3 2001/09/15 00:25:00 thorpej Exp $	*/

/*-
 * Copyright (c) 2000 Doug Rabson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$FreeBSD: src/sys/pci/agp_intel.c,v 1.4 2001/07/05 21:28:47 jhb Exp $
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/rwlock.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/agpvar.h>
#include <dev/pci/agpreg.h>

#include <machine/bus.h>

struct agp_intel_softc {
	struct device		 dev;
	struct agp_softc	*agpdev;
	struct agp_gatt 	*gatt;
	pci_chipset_tag_t	 isc_pc;
	pcitag_t		 isc_tag;
	bus_addr_t		 isc_apaddr;
	bus_size_t		 isc_apsize;
	u_int			 aperture_mask;
	enum {
		CHIP_INTEL,
		CHIP_I443,
		CHIP_I840,
		CHIP_I845,
		CHIP_I850,
		CHIP_I865
	}			 chiptype; 
	/* registers saved during a suspend/resume cycle. */
	pcireg_t		 savectrl;
	pcireg_t		 savecmd;
	pcireg_t		 savecfg;
};


void	agp_intel_attach(struct device *, struct device *, void *);
int	agp_intel_activate(struct device *, int);
void	agp_intel_save(struct agp_intel_softc *);
void	agp_intel_restore(struct agp_intel_softc *);
int	agp_intel_probe(struct device *, void *, void *);
bus_size_t agp_intel_get_aperture(void *);
int	agp_intel_set_aperture(void *, bus_size_t);
void	agp_intel_bind_page(void *, bus_addr_t, paddr_t, int);
void	agp_intel_unbind_page(void *, bus_addr_t);
void	agp_intel_flush_tlb(void *);

struct cfattach intelagp_ca = {
	sizeof(struct agp_intel_softc), agp_intel_probe, agp_intel_attach,
	NULL, agp_intel_activate
};

struct cfdriver intelagp_cd = {
	NULL, "intelagp", DV_DULL
};

const struct agp_methods agp_intel_methods = {
	agp_intel_bind_page,
	agp_intel_unbind_page,
	agp_intel_flush_tlb,
	/* default enable and memory routines */
};

int
agp_intel_probe(struct device *parent, void *match, void *aux)
{
	struct agp_attach_args	*aa = aux;
	struct pci_attach_args	*pa = aa->aa_pa;

	/* Must be a pchb */
	if (agpbus_probe(aa) == 0)
		return (0);

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_INTEL_82443LX:
	case PCI_PRODUCT_INTEL_82443BX:
	case PCI_PRODUCT_INTEL_82440BX:
	case PCI_PRODUCT_INTEL_82440BX_AGP:
	case PCI_PRODUCT_INTEL_82815_HB:
	case PCI_PRODUCT_INTEL_82820_HB:
	case PCI_PRODUCT_INTEL_82830M_HB:
	case PCI_PRODUCT_INTEL_82840_HB:
	case PCI_PRODUCT_INTEL_82845_HB:
	case PCI_PRODUCT_INTEL_82845G_HB:
	case PCI_PRODUCT_INTEL_82850_HB:	
	case PCI_PRODUCT_INTEL_82855PM_HB:
	case PCI_PRODUCT_INTEL_82855GM_HB:
	case PCI_PRODUCT_INTEL_82860_HB:
	case PCI_PRODUCT_INTEL_82865G_HB:
	case PCI_PRODUCT_INTEL_82875P_HB:
		return (1);
	}

	return (0);
}

void
agp_intel_attach(struct device *parent, struct device *self, void *aux)
{
	struct agp_intel_softc	*isc = (struct agp_intel_softc *)self;
	struct agp_attach_args	*aa = aux;
	struct pci_attach_args	*pa = aa->aa_pa;
	struct agp_gatt		*gatt;
	pcireg_t		 reg;
	u_int32_t		 value;

	isc->isc_pc = pa->pa_pc;
	isc->isc_tag = pa->pa_tag;

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_INTEL_82443LX:
	case PCI_PRODUCT_INTEL_82443BX:
	case PCI_PRODUCT_INTEL_82440BX:
	case PCI_PRODUCT_INTEL_82440BX_AGP:
		isc->chiptype = CHIP_I443;
		break;
	case PCI_PRODUCT_INTEL_82830M_HB:
	case PCI_PRODUCT_INTEL_82840_HB:
		isc->chiptype = CHIP_I840;
		break;
	case PCI_PRODUCT_INTEL_82845_HB:
	case PCI_PRODUCT_INTEL_82845G_HB:
	case PCI_PRODUCT_INTEL_82855PM_HB:
		isc->chiptype = CHIP_I845;
		break;
	case PCI_PRODUCT_INTEL_82850_HB:
		isc->chiptype = CHIP_I850;
		break;
	case PCI_PRODUCT_INTEL_82865G_HB:
	case PCI_PRODUCT_INTEL_82875P_HB:
		isc->chiptype = CHIP_I865;
		break;
	default:
		isc->chiptype = CHIP_INTEL;
		break;
	}

	if (pci_mapreg_info(pa->pa_pc, pa->pa_tag, AGP_APBASE,
	    PCI_MAPREG_TYPE_MEM, &isc->isc_apaddr, NULL, NULL) != 0) {
		printf(": can't get aperture info\n");
		return;
	}

	/* Determine maximum supported aperture size. */
	value = pci_conf_read(pa->pa_pc, pa->pa_tag, AGP_INTEL_APSIZE);
	pci_conf_write(pa->pa_pc, pa->pa_tag, AGP_INTEL_APSIZE, APSIZE_MASK);
	isc->aperture_mask = pci_conf_read(pa->pa_pc, pa->pa_tag,
		AGP_INTEL_APSIZE) & APSIZE_MASK;
	pci_conf_write(pa->pa_pc, pa->pa_tag, AGP_INTEL_APSIZE, value);
	isc->isc_apsize = agp_intel_get_aperture(isc);

	for (;;) {
		gatt = agp_alloc_gatt(pa->pa_dmat, isc->isc_apsize);
		if (gatt != NULL)
			break;

		/*
		 * almost certainly error allocating contigious dma memory
		 * so reduce aperture so that the gatt size reduces.
		 */
		isc->isc_apsize /= 2;
		if (agp_intel_set_aperture(isc, isc->isc_apsize)) {
			printf(": failed to set aperture\n");
			return;
		}
	}
	isc->gatt = gatt;

	/* Install the gatt. */
	pci_conf_write(pa->pa_pc, pa->pa_tag, AGP_INTEL_ATTBASE,
	    gatt->ag_physical);
	
	/* Enable the GLTB and setup the control register. */
	switch (isc->chiptype) {
	case CHIP_I443:
		pci_conf_write(isc->isc_pc, isc->isc_tag, AGP_INTEL_AGPCTRL,
		    AGPCTRL_AGPRSE | AGPCTRL_GTLB);
		break;
	default:
		pci_conf_write(isc->isc_pc, isc->isc_tag, AGP_INTEL_AGPCTRL,
		    pci_conf_read(isc->isc_pc, isc->isc_tag,
		    AGP_INTEL_AGPCTRL) | AGPCTRL_GTLB);
		break;
	}

	/* Enable things, clear errors etc. */
	switch (isc->chiptype) {
	case CHIP_I845:
	case CHIP_I865:
		reg = pci_conf_read(pa->pa_pc, pa->pa_tag, AGP_I840_MCHCFG);
		reg |= MCHCFG_AAGN;
		pci_conf_write(pa->pa_pc, pa->pa_tag, AGP_I840_MCHCFG, reg);
		break;
	case CHIP_I840:
	case CHIP_I850:
		reg = pci_conf_read(pa->pa_pc, pa->pa_tag, AGP_INTEL_AGPCMD);
		reg |= AGPCMD_AGPEN;
		pci_conf_write(pa->pa_pc, pa->pa_tag, AGP_INTEL_AGPCMD,
		    reg);
		reg = pci_conf_read(pa->pa_pc, pa->pa_tag, AGP_I840_MCHCFG);
		reg |= MCHCFG_AAGN;
		pci_conf_write(pa->pa_pc, pa->pa_tag, AGP_I840_MCHCFG,
		    reg);
		break;
	default:
		reg = pci_conf_read(pa->pa_pc, pa->pa_tag, AGP_INTEL_NBXCFG);
		reg &= ~NBXCFG_APAE;
		reg |=  NBXCFG_AAGN;
		pci_conf_write(pa->pa_pc, pa->pa_tag, AGP_INTEL_NBXCFG, reg);
		break;
	}

	/* Clear Error status */
	switch (isc->chiptype) {
	case CHIP_I840:
		pci_conf_write(pa->pa_pc, pa->pa_tag,
		    AGP_INTEL_I8XX_ERRSTS, 0xc000);
		break;
	case CHIP_I845:
	case CHIP_I850:
	case CHIP_I865:
		pci_conf_write(isc->isc_pc, isc->isc_tag,
		    AGP_INTEL_I8XX_ERRSTS, 0x00ff);
		break;

	default:
		reg = pci_conf_read(isc->isc_pc, isc->isc_tag,
		    AGP_INTEL_ERRCMD);
		pci_conf_write(isc->isc_pc, isc->isc_tag,
		    AGP_INTEL_ERRCMD, reg);
	}
	
	isc->agpdev = (struct agp_softc *)agp_attach_bus(pa, &agp_intel_methods,
	    isc->isc_apaddr, isc->isc_apsize, &isc->dev);
	return;
}

int
agp_intel_activate(struct device *arg, int act)
{
	struct agp_intel_softc *isc = (struct agp_intel_softc *)arg;

	switch (act) {
	case DVACT_SUSPEND:
		agp_intel_save(isc);
		break;
	case DVACT_RESUME:
		agp_intel_restore(isc);
		break;
	}

	return (0);
}

void
agp_intel_save(struct agp_intel_softc *isc)
{

	if (isc->chiptype != CHIP_I443) {
		isc->savectrl = pci_conf_read(isc->isc_pc, isc->isc_tag,
		    AGP_INTEL_AGPCTRL);
	}

	switch (isc->chiptype) {
	case CHIP_I845:
	case CHIP_I865:
		isc->savecmd = pci_conf_read(isc->isc_pc, isc->isc_tag,
		    AGP_I840_MCHCFG);

		break;
	case CHIP_I840:
	case CHIP_I850:
		isc->savecmd = pci_conf_read(isc->isc_pc, isc->isc_tag,
		    AGP_INTEL_AGPCMD);
		isc->savecfg = pci_conf_read(isc->isc_pc, isc->isc_tag,
		    AGP_I840_MCHCFG);

		break;
	default:
		isc->savecfg = pci_conf_read(isc->isc_pc, isc->isc_tag,
		    AGP_INTEL_NBXCFG);
		break;
	}
}

void
agp_intel_restore(struct agp_intel_softc *isc)
{
	pcireg_t	tmp;
	/*
	 * reset size now just in case, if it worked before then sanity
	 * checking will not fail
	 */
	(void)agp_intel_set_aperture(isc, isc->isc_apsize);

	/* Install the gatt. */
	pci_conf_write(isc->isc_pc, isc->isc_tag, AGP_INTEL_ATTBASE,
	    isc->gatt->ag_physical);
	
	/* Enable the GLTB and setup the control register. */
	switch (isc->chiptype) {
	case CHIP_I443:
		pci_conf_write(isc->isc_pc, isc->isc_tag, AGP_INTEL_AGPCTRL,
		    AGPCTRL_AGPRSE | AGPCTRL_GTLB);
		break;
	default:
		pci_conf_write(isc->isc_pc, isc->isc_tag, AGP_INTEL_AGPCTRL,
		    isc->savectrl);
		break;
	}

	/* Enable things, clear errors etc. */
	switch (isc->chiptype) {
	case CHIP_I845:
	case CHIP_I865:
		pci_conf_write(isc->isc_pc, isc->isc_tag,
		    AGP_I840_MCHCFG, isc->savecmd);
		break;
	case CHIP_I840:
	case CHIP_I850:
		pci_conf_write(isc->isc_pc, isc->isc_tag,
		    AGP_INTEL_AGPCMD, isc->savecmd);
		pci_conf_write(isc->isc_pc, isc->isc_tag,
		    AGP_I840_MCHCFG, isc->savecfg);
		break;
	default:
		pci_conf_write(isc->isc_pc, isc->isc_tag,
		    AGP_INTEL_NBXCFG, isc->savecfg);
		break;
	}

	/* Clear Error status */
	switch (isc->chiptype) {
	case CHIP_I840:
		pci_conf_write(isc->isc_pc, isc->isc_tag,
		    AGP_INTEL_I8XX_ERRSTS, 0xc000);
		break;
	case CHIP_I845:
	case CHIP_I850:
	case CHIP_I865:
		pci_conf_write(isc->isc_pc, isc->isc_tag,
		    AGP_INTEL_I8XX_ERRSTS, 0x00ff);
		break;
	default:
		tmp = pci_conf_read(isc->isc_pc, isc->isc_tag,
		    AGP_INTEL_ERRCMD);
		pci_conf_write(isc->isc_pc, isc->isc_tag,
		    AGP_INTEL_ERRCMD, tmp);
		break;
	}
}

bus_size_t
agp_intel_get_aperture(void *sc)
{
	struct agp_intel_softc *isc = sc;
	bus_size_t apsize;

	apsize = pci_conf_read(isc->isc_pc, isc->isc_tag,
	    AGP_INTEL_APSIZE) & isc->aperture_mask;

	/*
	 * The size is determined by the number of low bits of
	 * register APBASE which are forced to zero. The low 22 bits
	 * are always forced to zero and each zero bit in the apsize
	 * field just read forces the corresponding bit in the 27:22
	 * to be zero. We calculate the aperture size accordingly.
	 */
	return ((((apsize ^ isc->aperture_mask) << 22) | ((1 << 22) - 1)) + 1);
}

int
agp_intel_set_aperture(void *sc, bus_size_t aperture)
{
	struct agp_intel_softc *isc = sc;
	bus_size_t apsize;

	/*
	 * Reverse the magic from get_aperture.
	 */
	apsize = ((aperture - 1) >> 22) ^ isc->aperture_mask;

	/*
	 * Double check for sanity.
	 */
	if ((((apsize ^ isc->aperture_mask) << 22) |
	    ((1 << 22) - 1)) + 1 != aperture)
		return (EINVAL);

	pci_conf_write(isc->isc_pc, isc->isc_tag, AGP_INTEL_APSIZE, apsize);

	return (0);
}

void
agp_intel_bind_page(void *sc, bus_addr_t offset, paddr_t physical, int flags)
{
	struct agp_intel_softc *isc = sc;

	isc->gatt->ag_virtual[(offset - isc->isc_apaddr) >> AGP_PAGE_SHIFT] =
	    physical | 0x17;
}

void
agp_intel_unbind_page(void *sc, bus_size_t offset)
{
	struct agp_intel_softc *isc = sc;

	isc->gatt->ag_virtual[(offset - isc->isc_apaddr) >> AGP_PAGE_SHIFT] = 0;
}

void
agp_intel_flush_tlb(void *sc)
{
	struct agp_intel_softc *isc = sc;
	pcireg_t reg;

	switch (isc->chiptype) {
	case CHIP_I865:
	case CHIP_I850:
	case CHIP_I845:
	case CHIP_I840:
	case CHIP_I443:
		reg = pci_conf_read(isc->isc_pc, isc->isc_tag,
		    AGP_INTEL_AGPCTRL);
		reg &= ~AGPCTRL_GTLB;
		pci_conf_write(isc->isc_pc, isc->isc_tag,
		    AGP_INTEL_AGPCTRL, reg);
		pci_conf_write(isc->isc_pc, isc->isc_tag, AGP_INTEL_AGPCTRL,
		    reg | AGPCTRL_GTLB);
		break;
	default: /* XXX */
		pci_conf_write(isc->isc_pc, isc->isc_tag, AGP_INTEL_AGPCTRL,
		    0x2200);
		pci_conf_write(isc->isc_pc, isc->isc_tag, AGP_INTEL_AGPCTRL,
		    0x2280);
		break;
	}
}
@


1.22
log
@No need to include <sys/lock.h> when only <sys/rwlock.h> is needed,
so remove the former and include the latter instead of pulling it
in <dev/pci/agpvar.h>.  This header already requires various other
types anyway.  While here remove unneeded headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.21 2014/03/18 09:21:35 mpi Exp $	*/
a384 25

#if 0
int
agp_intel_detach(struct agp_softc *sc)
{
	int error;
	pcireg_t reg;
	struct agp_intel_softc *isc = sc->sc_chipc;

	error = agp_generic_detach(sc);
	if (error)
		return (error);

	/* XXX i845/i855PM/i840/i850E */
	reg = pci_conf_read(sc->sc_pc, sc->sc_tag, AGP_INTEL_NBXCFG);
	reg &= ~(1 << 9);
	printf("%s: set NBXCFG to %x\n", __FUNCTION__, reg);
	pci_conf_write(sc->sc_pc, sc->sc_tag, AGP_INTEL_NBXCFG, reg);
	pci_conf_write(sc->sc_pc, sc->sc_tag, AGP_INTEL_ATTBASE, 0);
	AGP_SET_APERTURE(sc, isc->initial_aperture);
	agp_free_gatt(sc, isc->gatt);

	return (0);
}
#endif
@


1.21
log
@<sys/agpio.h> is gone
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.20 2012/11/13 23:36:17 kettenis Exp $	*/
a34 2
#include <sys/kernel.h>
#include <sys/lock.h>
d36 1
@


1.20
log
@Writing a 1 to the MEF bit of the ERRSTS0 register of the 82443LX host bridge
when it is already cleared  will trigger an NMI if the corresponding bit ini
the ERRCMD register is enabled.  So instead of unconditionally writing 1 into
some of the bits, simply read the register and write back the value that we
just read.  This will clear any status bits that were set (since they are R/WC)
and leave all other bits alone.

Tested by Karlis Mikelsons.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.19 2011/10/24 15:42:33 oga Exp $	*/
a36 1
#include <sys/agpio.h>
a37 1
#include <sys/agpio.h>
@


1.19
log
@Fix unaligned pci config space access in intelagp.

tested by reported. ok kettenis@@ (who pointed out a botch i'd made, too).

While here remove definition of another (unused) unaligned access. to be added
back when it is actually used (this one pointed out by deraadt@@).
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.18 2010/08/07 20:47:24 deraadt Exp $	*/
a264 1
		reg |= 0x7000; /* Ack ERRSTS bits 8-10*/
a382 1
		tmp |= 0x7000; /* Ack ERRSTS bits 8-10*/
@


1.18
log
@break statements even on default cases
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.17 2010/08/07 17:44:09 oga Exp $	*/
d263 5
a267 1
		pci_conf_write(pa->pa_pc, pa->pa_tag, AGP_INTEL_ERRSTS, 0x70);
d326 1
d382 3
d386 1
a386 1
		    AGP_INTEL_ERRSTS, 0x70);
@


1.17
log
@Save and restore registers on suspend/resume.

An earlier iteration of this fixed the "no X, suspend, resume, startx,
boom" problem for sthen on his machine.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.16 2010/04/08 00:23:53 tedu Exp $	*/
d171 1
d219 1
d246 1
d315 1
d341 1
d361 1
d379 1
d492 1
@


1.16
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.15 2009/05/10 16:57:44 oga Exp $	*/
d66 4
d74 3
d85 2
a86 1
	sizeof(struct agp_intel_softc), agp_intel_probe, agp_intel_attach
d266 108
@


1.15
log
@Change agp attach (again) so that the driver passes in the aperture size.

While the aperture size may change during attach, it never changes after
the end of the subdriver attach function, so getting this value with a
function is a waste of time. shrinks things slightly and makes the code
clearer.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.14 2009/05/10 15:28:45 oga Exp $	*/
a36 1
#include <sys/proc.h>
@


1.14
log
@In preparation for using agp as a bus_dma backend for drm, convert the bind_page
and unbind_page callbacks from

int bind_page(void *, off_t, bus_addr_t)

to

void bind_page(void *, bus_addr_t, paddr_t, int)

We can make these function void by making sure that the agp code sanity
checks properly (it already mostly did), so by definition these
functions may not fail.  The flags field is currently unused (intagp at
least will have a use for it soon).

Been in my tree for ages.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.13 2009/05/10 14:44:42 oga Exp $	*/
d57 1
a66 1
	bus_size_t		 initial_aperture; /* startup aperture size */
a86 1
	agp_intel_get_aperture,
d178 1
a178 1
	isc->initial_aperture = agp_intel_get_aperture(isc);
d181 1
a181 2
		bus_size_t size = agp_intel_get_aperture(isc);
		gatt = agp_alloc_gatt(pa->pa_dmat, size);
d189 2
a190 1
		if (agp_intel_set_aperture(isc, size / 2)) {
d257 1
a257 1
	    isc->isc_apaddr, &isc->dev);
@


1.13
log
@change agp driver attach so that the driver passes in the base address
of its aperture, instead of the BAR and memory type. This is a little
larger, but allows the driver to know it's aperture address. Needed for
some future stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.12 2008/11/09 15:11:19 oga Exp $	*/
d74 2
a75 2
int	agp_intel_bind_page(void *, off_t, bus_addr_t);
int	agp_intel_unbind_page(void *, off_t);
d329 2
a330 2
int
agp_intel_bind_page(void *sc, off_t offset, bus_addr_t physical)
d334 2
a335 5
	if (offset < 0 || offset >= (isc->gatt->ag_entries << AGP_PAGE_SHIFT))
		return (EINVAL);

	isc->gatt->ag_virtual[offset >> AGP_PAGE_SHIFT] = physical | 0x17;
	return (0);
d338 2
a339 2
int
agp_intel_unbind_page(void *sc, off_t offset)
d343 1
a343 5
	if (offset < 0 || offset >= (isc->gatt->ag_entries << AGP_PAGE_SHIFT))
		return (EINVAL);

	isc->gatt->ag_virtual[offset >> AGP_PAGE_SHIFT] = 0;
	return (0);
@


1.12
log
@Rework that way that agp attaches.

previously, we had a static list of pcidevs and which agp driver would
be interanlly attached. Instead, split the agp drivers so they work like
audio(4), where we attach a driver, which sets up some callbacks and
initial state, then attaches the interface (agp(4)). Since this allows
us to attach different drivers in different places, and give them
/proper/ probe functions move most of the drivers back to attaching at
pchb, where they should, and intagp (formerly agp_i810) stays attaching
at vga, since it's part of the intel integrated graphics chips.

Diff shrinks the kernel slightly, gets rid of the annoying "no integrated
graphics" warning, and allows more cleanup later.

Tested by many. fix for alpha build (the only other vga_pci.c consumer)
suggested by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.11 2008/09/02 10:29:34 jsg Exp $	*/
d56 1
d167 6
d258 1
a258 1
	    AGP_APBASE, PCI_MAPREG_TYPE_MEM, &isc->dev);
@


1.11
log
@missing break;
ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.10 2008/01/04 00:23:26 kettenis Exp $	*/
a31 1

a41 1

d51 2
a52 1
	u_int32_t		initial_aperture; /* aperture size at startup */
d54 12
a65 9
	struct pci_attach_args 	vga_pa; /* vga card */
	u_int			aperture_mask;
	int			chiptype; 
#define	CHIP_INTEL	0x0
#define	CHIP_I443	0x1
#define	CHIP_I840	0x2
#define	CHIP_I845	0x3
#define	CHIP_I850	0x4
#define	CHIP_I865	0x5
d69 15
a83 6
int	agp_intel_vgamatch(struct pci_attach_args *);
u_int32_t agp_intel_get_aperture(struct agp_softc *);
int	agp_intel_set_aperture(struct agp_softc *, u_int32_t);
int	agp_intel_bind_page(struct agp_softc *, off_t, bus_addr_t);
int	agp_intel_unbind_page(struct agp_softc *, off_t);
void	agp_intel_flush_tlb(struct agp_softc *);
d85 1
a85 1
struct agp_methods agp_intel_methods = {
a86 1
	agp_intel_set_aperture,
d90 1
a90 5
	agp_generic_enable,
	agp_generic_alloc_memory,
	agp_generic_free_memory,
	agp_generic_bind_memory,
	agp_generic_unbind_memory,
d94 1
a94 1
agp_intel_vgamatch(struct pci_attach_args *pa)
d96 7
d104 3
a106 2
	case PCI_PRODUCT_INTEL_82443LX_AGP:
	case PCI_PRODUCT_INTEL_82443BX_AGP:
d108 12
a119 7
	case PCI_PRODUCT_INTEL_82840_AGP:
	case PCI_PRODUCT_INTEL_82845_AGP:
	case PCI_PRODUCT_INTEL_82845G_AGP:
	case PCI_PRODUCT_INTEL_82850_AGP:	/* i850/i860 */
	case PCI_PRODUCT_INTEL_82855PM_AGP:
	case PCI_PRODUCT_INTEL_82865G_AGP:
	case PCI_PRODUCT_INTEL_82875P_AGP:
d126 2
a127 2
int
agp_intel_attach(struct agp_softc *sc, struct pci_attach_args *pa)
d129 6
a134 4
	struct agp_intel_softc *isc;
	struct agp_gatt *gatt;
	pcireg_t reg;
	u_int32_t value;
d136 2
a137 5
	isc = malloc(sizeof *isc, M_AGP, M_NOWAIT | M_ZERO);
	if (isc == NULL) {
		printf("can't allocate chipset-specific softc\n");
		return (ENOMEM);
	}
d139 4
a142 19
	sc->sc_methods = &agp_intel_methods;
	sc->sc_chipc = isc;

	if (pci_find_device(&isc->vga_pa, agp_intel_vgamatch) == 0)
		isc->chiptype = CHIP_INTEL;

	pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_AGP, &sc->sc_capoff,
	    NULL);

	if (agp_map_aperture(pa, sc, AGP_APBASE, PCI_MAPREG_TYPE_MEM) != 0) {
		printf("can't map aperture\n");
		free(isc, M_AGP);
		sc->sc_chipc = NULL;
		return (ENXIO);
	}

	switch (PCI_PRODUCT(isc->vga_pa.pa_id)) {
	case PCI_PRODUCT_INTEL_82443LX_AGP:
	case PCI_PRODUCT_INTEL_82443BX_AGP:
d146 2
a147 1
	case PCI_PRODUCT_INTEL_82840_AGP:
d150 3
a152 3
	case PCI_PRODUCT_INTEL_82845_AGP:
	case PCI_PRODUCT_INTEL_82845G_AGP:
	case PCI_PRODUCT_INTEL_82855PM_AGP:
d155 1
a155 1
	case PCI_PRODUCT_INTEL_82850_AGP:
d158 2
a159 2
	case PCI_PRODUCT_INTEL_82865G_AGP:
	case PCI_PRODUCT_INTEL_82875P_AGP:
d162 2
d167 3
a169 4
	value = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_APSIZE);
	pci_conf_write(sc->sc_pc, sc->sc_pcitag,
		AGP_INTEL_APSIZE, APSIZE_MASK);
	isc->aperture_mask = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
d171 2
a172 2
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_APSIZE, value);
	isc->initial_aperture = AGP_GET_APERTURE(sc);
d175 3
a177 2
		gatt = agp_alloc_gatt(sc);
		if (gatt)
d181 2
a182 2
		 * Probably contigmalloc failure. Try reducing the
		 * aperture so that the gatt size reduces.
d184 3
a186 4
		if (AGP_SET_APERTURE(sc, AGP_GET_APERTURE(sc) / 2)) {
			agp_generic_detach(sc);
			printf("failed to set aperture\n");
			return (ENOMEM);
d192 1
a192 1
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_ATTBASE,
d198 1
a198 1
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_AGPCTRL,
d202 3
a204 3
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_AGPCTRL,
		    pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_AGPCTRL)
			| AGPCTRL_GTLB);
d211 1
a211 1
		reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_I840_MCHCFG);
d213 1
a213 1
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_I840_MCHCFG, reg);
d217 1
a217 1
		reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_AGPCMD);
d219 1
a219 1
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_AGPCMD,
d221 1
a221 1
		reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_I840_MCHCFG);
d223 1
a223 1
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_I840_MCHCFG,
d227 1
a227 1
		reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_NBXCFG);
d230 1
a230 1
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_NBXCFG, reg);
d236 1
a236 1
		pci_conf_write(sc->sc_pc, sc->sc_pcitag,
d242 1
a242 1
		pci_conf_write(sc->sc_pc, sc->sc_pcitag,
d247 1
a247 2
		pci_conf_write(sc->sc_pc, sc->sc_pcitag,
		    AGP_INTEL_ERRSTS, 0x70);
d249 4
a252 2

	return (0);
d268 1
a268 1
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_NBXCFG);
d271 2
a272 2
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_NBXCFG, reg);
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_ATTBASE, 0);
d280 2
a281 2
u_int32_t
agp_intel_get_aperture(struct agp_softc *sc)
d283 2
a284 2
	struct agp_intel_softc *isc = sc->sc_chipc;
	u_int32_t apsize;
d286 1
a286 1
	apsize = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
d300 1
a300 1
agp_intel_set_aperture(struct agp_softc *sc, u_int32_t aperture)
d302 2
a303 2
	struct agp_intel_softc *isc = sc->sc_chipc;
	u_int32_t apsize;
d317 1
a317 1
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_APSIZE, apsize);
d323 1
a323 1
agp_intel_bind_page(struct agp_softc *sc, off_t offset, bus_addr_t physical)
d325 1
a325 1
	struct agp_intel_softc *isc = sc->sc_chipc;
d335 1
a335 1
agp_intel_unbind_page(struct agp_softc *sc, off_t offset)
d337 1
a337 1
	struct agp_intel_softc *isc = sc->sc_chipc;
d347 1
a347 1
agp_intel_flush_tlb(struct agp_softc *sc)
d349 1
a349 1
	struct agp_intel_softc *isc = sc->sc_chipc;
d358 2
a359 1
		reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_AGPCTRL);
d361 3
a363 3
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_AGPCTRL,
		    reg);
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_AGPCTRL,
d367 1
a367 1
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_AGPCTRL,
d369 1
a369 1
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_AGPCTRL,
@


1.10
log
@Clean up Intel host bridge PCI IDs.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.9 2007/12/07 17:35:22 oga Exp $	*/
d195 1
a195 1

@


1.9
log
@KNF, no binary change.

Looked over by a few people.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.8 2007/12/06 22:49:39 oga Exp $	*/
a90 1
	case PCI_PRODUCT_INTEL_82855PE_AGP:
d94 3
d98 2
a99 3
	case PCI_PRODUCT_INTEL_82845_AGP:
	case PCI_PRODUCT_INTEL_82840_AGP:
	case PCI_PRODUCT_INTEL_82865_AGP:
a145 1
	case PCI_PRODUCT_INTEL_82855PE_AGP:
d147 2
d154 1
a154 1
	case PCI_PRODUCT_INTEL_82865_AGP:
@


1.8
log
@Destatic functions in the agp subsystem.

KNF coming shortly.

ok marco, jsg and mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.7 2007/11/26 15:35:15 deraadt Exp $	*/
d67 1
a67 1
int agp_intel_vgamatch(struct pci_attach_args *);
d69 4
a72 4
int agp_intel_set_aperture(struct agp_softc *, u_int32_t);
int agp_intel_bind_page(struct agp_softc *, off_t, bus_addr_t);
int agp_intel_unbind_page(struct agp_softc *, off_t);
void agp_intel_flush_tlb(struct agp_softc *);
a203 1
		{
a207 1
		}
a209 1
		{
d213 1
a213 1
			reg);
d217 1
a217 1
			reg);
a218 1
		}
a219 1
		{
a223 1
		}
d230 1
a230 1
			AGP_INTEL_I8XX_ERRSTS, 0xc000);
d236 1
a236 1
			AGP_INTEL_I8XX_ERRSTS, 0x00ff);
d241 1
a241 1
			AGP_INTEL_ERRSTS, 0x70);
d306 1
a306 1
			((1 << 22) - 1)) + 1 != aperture)
a349 1
		{
d353 1
a353 1
			reg);
d355 1
a355 1
			reg | AGPCTRL_GTLB);
a356 1
		}
a357 1
		{
d359 1
a359 1
			0x2200);
d361 1
a361 2
			0x2280);
		}
@


1.7
log
@correct newlines surrounding the sub-bus configuration, and unify
pchb's further
ok reyk oga
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.6 2007/11/25 17:11:12 oga Exp $	*/
d67 6
a72 5
static u_int32_t agp_intel_get_aperture(struct agp_softc *);
static int agp_intel_set_aperture(struct agp_softc *, u_int32_t);
static int agp_intel_bind_page(struct agp_softc *, off_t, bus_addr_t);
static int agp_intel_unbind_page(struct agp_softc *, off_t);
static void agp_intel_flush_tlb(struct agp_softc *);
d87 1
a87 1
static int
d254 1
a254 1
static int
d278 1
a278 1
static u_int32_t
d297 1
a297 1
static int
d320 1
a320 1
static int
d332 1
a332 1
static int
d344 1
a344 1
static void
@


1.6
log
@Make agp attach as a device. This means that many more agp bridges
actually get detected and attached. Also adds a kernel api for
manipulating agp.

Enable this on i386 and amd64.

"I think you should commit it" deraadt@@, ok matthieu. Looked over by
several others.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.5 2007/10/06 23:50:54 krw Exp $	*/
d115 1
a115 1
		printf(": can't allocate chipset-specific softc\n");
d122 1
a122 3
	if (pci_find_device(&isc->vga_pa, agp_intel_vgamatch) == 0) {
		printf(": using generic initialization for Intel AGP\n");
		printf("agp");
a123 1
	}
d129 1
a129 1
		printf(": can't map aperture\n");
d177 1
a177 1
			printf(": failed to set aperture\n");
@


1.5
log
@Simpliest memset(,0,) -> M_ZERO changes. One (caddr *) cast removal,
otherwise just adding M_ZERO to malloc() and removing the immediately
adjacent memset(,0,).
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.4 2007/08/04 19:40:25 reyk Exp $	*/
d46 1
a46 1
#include <dev/pci/vga_pcivar.h>
d53 11
a63 2
	u_int32_t	initial_aperture; /* aperture size at startup */
	struct agp_gatt *gatt;
d67 5
a71 5
static u_int32_t agp_intel_get_aperture(struct vga_pci_softc *);
static int agp_intel_set_aperture(struct vga_pci_softc *, u_int32_t);
static int agp_intel_bind_page(struct vga_pci_softc *, off_t, bus_addr_t);
static int agp_intel_unbind_page(struct vga_pci_softc *, off_t);
static void agp_intel_flush_tlb(struct vga_pci_softc *);
d86 19
d106 1
a106 2
agp_intel_attach(struct vga_pci_softc *sc, struct pci_attach_args *pa,
		 struct pci_attach_args *pchb_pa)
d111 1
d113 1
a113 1
	isc = malloc(sizeof *isc, M_DEVBUF, M_NOWAIT | M_ZERO);
d122 10
a131 1
	if (agp_map_aperture(sc, AGP_APBASE, PCI_MAPREG_TYPE_MEM) != 0) {
d133 1
a133 1
		free(isc, M_DEVBUF);
d138 29
d190 12
d203 30
a232 6
	/* XXXfvdl get rid of the magic constants */
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_AGPCTRL, 0x2280);
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_NBXCFG);
	reg &= ~(1 << 10);
	reg |=	(1 << 9);
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_NBXCFG, reg);
d234 17
a250 4
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_STS);
	reg &= ~0x00ff0000;
	reg |= (7 << 16);
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_STS, reg);
d257 1
a257 1
agp_intel_detach(struct vga_pci_softc *sc)
d267 1
d281 1
a281 1
agp_intel_get_aperture(struct vga_pci_softc *sc)
d283 1
d287 1
a287 1
	    AGP_INTEL_APSIZE) & 0x1f;
d296 1
a296 1
	return ((((apsize ^ 0x1f) << 22) | ((1 << 22) - 1)) + 1);
d300 1
a300 1
agp_intel_set_aperture(struct vga_pci_softc *sc, u_int32_t aperture)
d302 1
a303 1
	pcireg_t reg;
d308 1
a308 1
	apsize = ((aperture - 1) >> 22) ^ 0x1f;
d313 2
a314 1
	if ((((apsize ^ 0x1f) << 22) | ((1 << 22) - 1)) + 1 != aperture)
d317 1
a317 3
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_APSIZE);
	reg = (reg & 0xffffff00) | apsize;
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_APSIZE, reg);
d323 1
a323 1
agp_intel_bind_page(struct vga_pci_softc *sc, off_t offset, bus_addr_t physical)
d335 1
a335 1
agp_intel_unbind_page(struct vga_pci_softc *sc, off_t offset)
d347 1
a347 1
agp_intel_flush_tlb(struct vga_pci_softc *sc)
d349 26
a374 2
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_AGPCTRL, 0x2200);
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_AGPCTRL, 0x2280);
@


1.4
log
@Add AGP support for the intel i965 chipset, this also extends the
internal AGP API to work with 64bit PCI-Express memory and
non-standard AGP aperture bases.

tested by many
ok matthieu@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.3 2004/10/01 04:08:46 jsg Exp $	*/
d85 1
a85 1
	isc = malloc(sizeof *isc, M_DEVBUF, M_NOWAIT);
a89 1
	memset(isc, 0, sizeof *isc);
@


1.3
log
@add some missing $, ok djm@@ 'That looks fine to me' millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_intel.c,v 1.1 2001/10/25 21:44:00 thorpej Exp $	*/
d95 1
a95 1
	if (agp_map_aperture(sc) != 0) {
@


1.2
log
@- some KNF.
- comment out debugging printf for i810.
- remove checks for failure if malloc is used with M_WAITOK.

mickey@@ ok.
@
text
@d1 1
a1 1
/*	$OpentBSD: agp_intel.c,v 1.1 2001/10/25 21:44:00 thorpej Exp $	*/
@


1.2.4.1
log
@sync to -current
@
text
@@


1.1
log
@support for the agp gart on various agp chipsets.
only i810 driver was tested though.
based on the netbsd's lkm, initially ported
by hunter@@dg.net.ua and later made into shape by mickey.
testing by art@@ and millert@@ .
@
text
@d78 2
a79 1
agp_intel_attach(struct vga_pci_softc *sc, struct pci_attach_args *pa, struct pci_attach_args *pchb_pa)
d88 1
a88 1
		return ENOMEM;
d99 1
a99 1
		return ENXIO;
d116 1
a116 1
			return ENOMEM;
d138 1
a138 1
	return 0;
d151 1
a151 1
		return error;
d161 1
a161 1
	return 0;
d170 2
a171 1
	apsize = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_INTEL_APSIZE) & 0x1f;
d180 1
a180 1
	return (((apsize ^ 0x1f) << 22) | ((1 << 22) - 1)) + 1;
d198 1
a198 1
		return EINVAL;
d204 1
a204 1
	return 0;
d213 1
a213 1
		return EINVAL;
d216 1
a216 1
	return 0;
d225 1
a225 1
		return EINVAL;
d228 1
a228 1
	return 0;
a236 2


@

