head	1.189;
access;
symbols
	OPENBSD_6_2_BASE:1.189
	OPENBSD_6_1:1.186.0.4
	OPENBSD_6_1_BASE:1.186
	OPENBSD_6_0:1.184.0.4
	OPENBSD_6_0_BASE:1.184
	OPENBSD_5_9:1.183.0.2
	OPENBSD_5_9_BASE:1.183
	OPENBSD_5_8:1.177.0.4
	OPENBSD_5_8_BASE:1.177
	OPENBSD_5_7:1.173.0.4
	OPENBSD_5_7_BASE:1.173
	OPENBSD_5_6:1.170.0.4
	OPENBSD_5_6_BASE:1.170
	OPENBSD_5_5:1.167.0.4
	OPENBSD_5_5_BASE:1.167
	OPENBSD_5_4:1.164.0.2
	OPENBSD_5_4_BASE:1.164
	OPENBSD_5_3:1.163.0.2
	OPENBSD_5_3_BASE:1.163
	OPENBSD_5_2:1.161.0.2
	OPENBSD_5_2_BASE:1.161
	OPENBSD_5_1_BASE:1.160
	OPENBSD_5_1:1.160.0.4
	OPENBSD_5_0:1.160.0.2
	OPENBSD_5_0_BASE:1.160
	OPENBSD_4_9:1.158.0.2
	OPENBSD_4_9_BASE:1.158
	OPENBSD_4_8:1.157.0.2
	OPENBSD_4_8_BASE:1.157
	OPENBSD_4_7:1.156.0.2
	OPENBSD_4_7_BASE:1.156
	OPENBSD_4_6:1.152.0.2
	OPENBSD_4_6_BASE:1.152
	OPENBSD_4_5:1.150.0.2
	OPENBSD_4_5_BASE:1.150
	OPENBSD_4_4:1.146.0.2
	OPENBSD_4_4_BASE:1.146
	OPENBSD_4_3:1.144.0.2
	OPENBSD_4_3_BASE:1.144
	OPENBSD_4_2:1.142.0.2
	OPENBSD_4_2_BASE:1.142
	OPENBSD_4_1:1.139.0.2
	OPENBSD_4_1_BASE:1.139
	OPENBSD_4_0:1.125.0.2
	OPENBSD_4_0_BASE:1.125
	OPENBSD_3_9:1.95.0.2
	OPENBSD_3_9_BASE:1.95
	OPENBSD_3_8:1.78.0.2
	OPENBSD_3_8_BASE:1.78
	OPENBSD_3_7:1.62.0.2
	OPENBSD_3_7_BASE:1.62
	OPENBSD_3_6:1.45.0.2
	OPENBSD_3_6_BASE:1.45
	SMP_SYNC_A:1.41
	SMP_SYNC_B:1.41
	OPENBSD_3_5:1.38.0.2
	OPENBSD_3_5_BASE:1.38
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	UBC_SYNC_A:1.31
	OPENBSD_3_3:1.28.0.2
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.25
	UBC:1.19.0.2
	UBC_BASE:1.19
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.189
date	2017.06.04.04.29.23;	author dlg;	state Exp;
branches;
next	1.188;
commitid	fXLRVzawSmIxy8xT;

1.188
date	2017.06.02.10.47.30;	author dlg;	state Exp;
branches;
next	1.187;
commitid	9ETTLIfo1JhPNAu0;

1.187
date	2017.06.01.23.17.01;	author dlg;	state Exp;
branches;
next	1.186;
commitid	632HLgdJxGvqPuhh;

1.186
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.185;
commitid	VyLWTsbepAOk7VQM;

1.185
date	2017.01.08.18.08.14;	author visa;	state Exp;
branches;
next	1.184;
commitid	riH4VCDRaaOQfCKK;

1.184
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.183;
commitid	8YSL8ByWzGeIGBiJ;

1.183
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.182;
commitid	B0kwmVGiD5DVx4kv;

1.182
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.181;
commitid	5gdEnqVoJuTuwdTu;

1.181
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.180;
commitid	5DvsamK0GblTp8ww;

1.180
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.179;
commitid	eYnPulzvLjDImPCa;

1.179
date	2015.11.14.17.54.57;	author mpi;	state Exp;
branches;
next	1.178;
commitid	Waft2RDjXAxr4qZ9;

1.178
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.177;
commitid	hPF95ClMUQfeqQDX;

1.177
date	2015.07.19.06.28.12;	author yuo;	state Exp;
branches;
next	1.176;
commitid	vzHDNxGG1slGlZhk;

1.176
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.175;
commitid	MVWrtktB46JRxFWT;

1.175
date	2015.04.30.09.25.13;	author mpi;	state Exp;
branches;
next	1.174;
commitid	RcjE9ISA4bMvTANx;

1.174
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.173;
commitid	p4LJxGKbi0BU2cG6;

1.173
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.172;
commitid	yM2VFFhpDTeFQlve;

1.172
date	2014.08.20.03.29.35;	author dlg;	state Exp;
branches;
next	1.171;
commitid	3mBuNZLUvPNDs0mT;

1.171
date	2014.08.20.00.50.45;	author dlg;	state Exp;
branches;
next	1.170;
commitid	hqgZrq0W7DQC0H51;

1.170
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.169;
commitid	TGHgrLxu6sxZoiFt;

1.169
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.168;
commitid	OBNa5kfxQ2UXoiIw;

1.168
date	2014.04.19.18.29.39;	author henning;	state Exp;
branches;
next	1.167;

1.167
date	2013.12.28.03.36.25;	author deraadt;	state Exp;
branches;
next	1.166;

1.166
date	2013.08.21.05.21.44;	author dlg;	state Exp;
branches;
next	1.165;

1.165
date	2013.08.07.01.06.37;	author bluhm;	state Exp;
branches;
next	1.164;

1.164
date	2013.03.07.06.13.31;	author brad;	state Exp;
branches;
next	1.163;

1.163
date	2012.11.29.21.10.32;	author brad;	state Exp;
branches;
next	1.162;

1.162
date	2012.10.18.21.44.21;	author deraadt;	state Exp;
branches;
next	1.161;

1.161
date	2012.02.24.06.19.00;	author guenther;	state Exp;
branches;
next	1.160;

1.160
date	2011.06.22.16.44.27;	author tedu;	state Exp;
branches;
next	1.159;

1.159
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.158;

1.158
date	2010.09.20.07.40.38;	author deraadt;	state Exp;
branches;
next	1.157;

1.157
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.156;

1.156
date	2009.10.17.21.40.43;	author martynas;	state Exp;
branches;
next	1.155;

1.155
date	2009.10.15.17.54.56;	author deraadt;	state Exp;
branches;
next	1.154;

1.154
date	2009.10.04.18.32.40;	author deraadt;	state Exp;
branches;
next	1.153;

1.153
date	2009.08.13.14.24.47;	author jasper;	state Exp;
branches;
next	1.152;

1.152
date	2009.07.08.20.18.05;	author sthen;	state Exp;
branches;
next	1.151;

1.151
date	2009.03.30.19.09.43;	author kettenis;	state Exp;
branches;
next	1.150;

1.150
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.149;

1.149
date	2008.10.14.18.01.53;	author naddy;	state Exp;
branches;
next	1.148;

1.148
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.147;

1.147
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.146;

1.146
date	2008.05.24.01.32.54;	author brad;	state Exp;
branches;
next	1.145;

1.145
date	2008.05.23.08.49.27;	author brad;	state Exp;
branches;
next	1.144;

1.144
date	2008.03.02.19.16.43;	author brad;	state Exp;
branches;
next	1.143;

1.143
date	2008.01.17.12.43.17;	author brad;	state Exp;
branches;
next	1.142;

1.142
date	2007.05.26.16.44.21;	author reyk;	state Exp;
branches;
next	1.141;

1.141
date	2007.05.22.04.30.56;	author ray;	state Exp;
branches;
next	1.140;

1.140
date	2007.05.07.21.57.23;	author deraadt;	state Exp;
branches;
next	1.139;

1.139
date	2007.02.12.21.19.56;	author pedro;	state Exp;
branches;
next	1.138;

1.138
date	2007.02.10.02.27.56;	author krw;	state Exp;
branches;
next	1.137;

1.137
date	2007.02.03.12.50.26;	author kettenis;	state Exp;
branches;
next	1.136;

1.136
date	2007.01.18.04.56.33;	author krw;	state Exp;
branches;
next	1.135;

1.135
date	2007.01.05.21.32.25;	author kettenis;	state Exp;
branches;
next	1.134;

1.134
date	2007.01.03.23.04.28;	author kettenis;	state Exp;
branches;
next	1.133;

1.133
date	2007.01.03.11.49.16;	author krw;	state Exp;
branches;
next	1.132;

1.132
date	2006.12.06.23.34.44;	author reyk;	state Exp;
branches;
next	1.131;

1.131
date	2006.11.16.03.05.29;	author brad;	state Exp;
branches;
next	1.130;

1.130
date	2006.11.08.21.04.41;	author kettenis;	state Exp;
branches;
next	1.129;

1.129
date	2006.10.16.12.30.08;	author tom;	state Exp;
branches;
next	1.128;

1.128
date	2006.09.27.02.27.04;	author brad;	state Exp;
branches;
next	1.127;

1.127
date	2006.09.26.19.37.28;	author brad;	state Exp;
branches;
next	1.126;

1.126
date	2006.09.18.04.05.05;	author brad;	state Exp;
branches;
next	1.125;

1.125
date	2006.08.17.21.37.44;	author brad;	state Exp;
branches;
next	1.124;

1.124
date	2006.08.17.21.31.37;	author brad;	state Exp;
branches;
next	1.123;

1.123
date	2006.08.09.05.03.28;	author brad;	state Exp;
branches;
next	1.122;

1.122
date	2006.08.04.06.25.13;	author brad;	state Exp;
branches;
next	1.121;

1.121
date	2006.08.04.05.01.00;	author brad;	state Exp;
branches;
next	1.120;

1.120
date	2006.08.04.04.44.37;	author brad;	state Exp;
branches;
next	1.119;

1.119
date	2006.08.04.02.55.38;	author brad;	state Exp;
branches;
next	1.118;

1.118
date	2006.07.30.18.48.52;	author brad;	state Exp;
branches;
next	1.117;

1.117
date	2006.07.23.05.59.18;	author brad;	state Exp;
branches;
next	1.116;

1.116
date	2006.06.22.23.06.03;	author brad;	state Exp;
branches;
next	1.115;

1.115
date	2006.06.22.05.18.20;	author brad;	state Exp;
branches;
next	1.114;

1.114
date	2006.06.17.18.00.43;	author brad;	state Exp;
branches;
next	1.113;

1.113
date	2006.06.17.01.04.34;	author brad;	state Exp;
branches;
next	1.112;

1.112
date	2006.06.15.20.12.40;	author brad;	state Exp;
branches;
next	1.111;

1.111
date	2006.05.28.00.20.21;	author brad;	state Exp;
branches;
next	1.110;

1.110
date	2006.05.28.00.04.24;	author jason;	state Exp;
branches;
next	1.109;

1.109
date	2006.05.27.10.03.15;	author brad;	state Exp;
branches;
next	1.108;

1.108
date	2006.05.20.03.47.56;	author brad;	state Exp;
branches;
next	1.107;

1.107
date	2006.05.01.18.47.34;	author brad;	state Exp;
branches;
next	1.106;

1.106
date	2006.05.01.18.31.11;	author brad;	state Exp;
branches;
next	1.105;

1.105
date	2006.05.01.16.51.39;	author brad;	state Exp;
branches;
next	1.104;

1.104
date	2006.04.30.04.17.48;	author brad;	state Exp;
branches;
next	1.103;

1.103
date	2006.04.30.03.13.43;	author brad;	state Exp;
branches;
next	1.102;

1.102
date	2006.04.30.02.28.49;	author brad;	state Exp;
branches;
next	1.101;

1.101
date	2006.04.30.02.00.21;	author brad;	state Exp;
branches;
next	1.100;

1.100
date	2006.04.23.21.02.58;	author brad;	state Exp;
branches;
next	1.99;

1.99
date	2006.04.20.20.31.12;	author miod;	state Exp;
branches;
next	1.98;

1.98
date	2006.04.17.10.11.29;	author brad;	state Exp;
branches;
next	1.97;

1.97
date	2006.04.17.04.45.02;	author brad;	state Exp;
branches;
next	1.96;

1.96
date	2006.03.25.22.41.45;	author djm;	state Exp;
branches;
next	1.95;

1.95
date	2006.02.13.01.23.05;	author brad;	state Exp;
branches;
next	1.94;

1.94
date	2006.02.09.11.19.32;	author brad;	state Exp;
branches;
next	1.93;

1.93
date	2005.12.22.20.54.46;	author brad;	state Exp;
branches;
next	1.92;

1.92
date	2005.12.16.01.52.29;	author brad;	state Exp;
branches;
next	1.91;

1.91
date	2005.12.15.23.56.00;	author brad;	state Exp;
branches;
next	1.90;

1.90
date	2005.12.10.19.06.10;	author brad;	state Exp;
branches;
next	1.89;

1.89
date	2005.12.10.19.03.02;	author brad;	state Exp;
branches;
next	1.88;

1.88
date	2005.11.26.19.16.28;	author brad;	state Exp;
branches;
next	1.87;

1.87
date	2005.11.15.20.32.04;	author brad;	state Exp;
branches;
next	1.86;

1.86
date	2005.11.07.02.57.45;	author brad;	state Exp;
branches;
next	1.85;

1.85
date	2005.10.15.23.09.17;	author brad;	state Exp;
branches;
next	1.84;

1.84
date	2005.10.15.23.07.09;	author brad;	state Exp;
branches;
next	1.83;

1.83
date	2005.09.20.01.02.22;	author brad;	state Exp;
branches;
next	1.82;

1.82
date	2005.09.20.00.56.33;	author brad;	state Exp;
branches;
next	1.81;

1.81
date	2005.09.20.00.24.04;	author brad;	state Exp;
branches;
next	1.80;

1.80
date	2005.09.17.02.53.09;	author brad;	state Exp;
branches;
next	1.79;

1.79
date	2005.09.16.00.43.31;	author brad;	state Exp;
branches;
next	1.78;

1.78
date	2005.08.29.02.53.25;	author brad;	state Exp;
branches;
next	1.77;

1.77
date	2005.07.25.00.49.43;	author brad;	state Exp;
branches;
next	1.76;

1.76
date	2005.07.24.20.18.17;	author fgsch;	state Exp;
branches;
next	1.75;

1.75
date	2005.07.22.03.49.19;	author brad;	state Exp;
branches;
next	1.74;

1.74
date	2005.07.22.03.10.17;	author brad;	state Exp;
branches;
next	1.73;

1.73
date	2005.07.21.15.23.27;	author brad;	state Exp;
branches;
next	1.72;

1.72
date	2005.07.14.01.47.58;	author brad;	state Exp;
branches;
next	1.71;

1.71
date	2005.07.12.00.43.37;	author brad;	state Exp;
branches;
next	1.70;

1.70
date	2005.07.12.00.01.49;	author brad;	state Exp;
branches;
next	1.69;

1.69
date	2005.07.02.23.10.11;	author brad;	state Exp;
branches;
next	1.68;

1.68
date	2005.07.02.21.57.19;	author brad;	state Exp;
branches;
next	1.67;

1.67
date	2005.05.17.19.18.18;	author jason;	state Exp;
branches;
next	1.66;

1.66
date	2005.05.16.13.47.02;	author brad;	state Exp;
branches;
next	1.65;

1.65
date	2005.05.11.02.27.23;	author brad;	state Exp;
branches;
next	1.64;

1.64
date	2005.05.11.00.33.10;	author brad;	state Exp;
branches;
next	1.63;

1.63
date	2005.04.25.17.55.51;	author brad;	state Exp;
branches;
next	1.62;

1.62
date	2005.03.18.03.59.34;	author brad;	state Exp;
branches;
next	1.61;

1.61
date	2005.03.12.18.16.56;	author brad;	state Exp;
branches;
next	1.60;

1.60
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.59;

1.59
date	2005.01.02.01.46.17;	author brad;	state Exp;
branches;
next	1.58;

1.58
date	2005.01.01.23.10.43;	author brad;	state Exp;
branches;
next	1.57;

1.57
date	2005.01.01.21.53.24;	author brad;	state Exp;
branches;
next	1.56;

1.56
date	2005.01.01.07.11.19;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2004.12.22.23.40.28;	author brad;	state Exp;
branches;
next	1.54;

1.54
date	2004.12.14.20.58.15;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2004.12.08.04.26.53;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2004.12.08.01.45.04;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2004.11.16.19.34.58;	author brad;	state Exp;
branches;
next	1.50;

1.50
date	2004.11.16.17.45.54;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2004.11.16.14.41.47;	author brad;	state Exp;
branches;
next	1.48;

1.48
date	2004.11.11.19.08.00;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2004.10.14.15.27.39;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.45;

1.45
date	2004.08.20.06.17.05;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2004.08.19.16.31.42;	author mcbride;	state Exp;
branches;
next	1.43;

1.43
date	2004.08.05.19.57.17;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2004.08.04.19.37.26;	author mcbride;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.29.16.09.41;	author naddy;	state Exp;
branches;
next	1.40;

1.40
date	2004.05.24.14.15.43;	author naddy;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.09.21.52.17;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.09.20.39.56;	author matthieu;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.17.17.43.03;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.17.17.26.20;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.17.16.53.46;	author jason;	state Exp;
branches;
next	1.34;

1.34
date	2003.10.13.21.22.19;	author jason;	state Exp;
branches;
next	1.33;

1.33
date	2003.08.12.05.23.06;	author nate;	state Exp;
branches;
next	1.32;

1.32
date	2003.08.01.04.46.13;	author nate;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.14.01.54.15;	author nate;	state Exp;
branches;
next	1.30;

1.30
date	2003.05.08.04.20.05;	author nate;	state Exp;
branches;
next	1.29;

1.29
date	2003.05.08.02.16.37;	author nate;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.12.17.05.43;	author nate;	state Exp;
branches;
next	1.27;

1.27
date	2003.01.15.06.31.24;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2002.11.26.06.01.28;	author nate;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.08.23.32.16;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.04.00.09.08;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.12.09.51.20;	author kjc;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.15.20.45.31;	author nordin;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.11.01.31.21;	author nordin;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.10.05.00.55.40;	author nate;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.15.16.50.26;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.12.20.03.49;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.25.02.18.47;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.29.16.02.18;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.25.06.30.58;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.20.19.39.45;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.16.17.08.08;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.04.17.11.55;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.29.23.45.40;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.15.02.28.14;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	99.12.08.00.38.08;	author aaron;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.10.22.07.14.42;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.10.04.12.21.39;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	99.10.03.13.06.30;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	99.10.01.02.52.22;	author jason;	state Exp;
branches;
next	;

1.5.2.1
date	2000.02.20.11.57.05;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.05.14.22.25.46;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2001.07.04.10.42.20;	author niklas;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.5.2.7;

1.5.2.7
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.5.2.8;

1.5.2.8
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.5.2.9;

1.5.2.9
date	2003.05.13.19.35.06;	author ho;	state Exp;
branches;
next	1.5.2.10;

1.5.2.10
date	2003.05.16.00.29.41;	author niklas;	state Exp;
branches;
next	1.5.2.11;

1.5.2.11
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	1.5.2.12;

1.5.2.12
date	2004.06.05.23.12.51;	author niklas;	state Exp;
branches;
next	;

1.19.2.1
date	2002.01.31.22.55.35;	author niklas;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.189
log
@use htolem32 and lemtoh32 instead of htole32 and letoh32.

saves about half a k on sparc64.
@
text
@/*	$OpenBSD: if_sk.c,v 1.188 2017/06/02 10:47:30 dlg Exp $	*/

/*
 * Copyright (c) 1997, 1998, 1999, 2000
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: /c/ncvs/src/sys/pci/if_sk.c,v 1.20 2000/04/22 02:16:37 wpaul Exp $
 */

/*
 * Copyright (c) 2003 Nathan L. Binkert <binkertn@@umich.edu>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * SysKonnect SK-NET gigabit ethernet driver for FreeBSD. Supports
 * the SK-984x series adapters, both single port and dual port.
 * References:
 * 	The XaQti XMAC II datasheet,
 * http://www.freebsd.org/~wpaul/SysKonnect/xmacii_datasheet_rev_c_9-29.pdf
 *	The SysKonnect GEnesis manual, http://www.syskonnect.com
 *
 * Note: XaQti has been acquired by Vitesse, and Vitesse does not have the
 * XMAC II datasheet online. I have put my copy at people.freebsd.org as a
 * convenience to others until Vitesse corrects this problem:
 *
 * http://people.freebsd.org/~wpaul/SysKonnect/xmacii_datasheet_rev_c_9-29.pdf
 *
 * Written by Bill Paul <wpaul@@ee.columbia.edu>
 * Department of Electrical Engineering
 * Columbia University, New York City
 */

/*
 * The SysKonnect gigabit ethernet adapters consist of two main
 * components: the SysKonnect GEnesis controller chip and the XaQti Corp.
 * XMAC II gigabit ethernet MAC. The XMAC provides all of the MAC
 * components and a PHY while the GEnesis controller provides a PCI
 * interface with DMA support. Each card may have between 512K and
 * 2MB of SRAM on board depending on the configuration.
 *
 * The SysKonnect GEnesis controller can have either one or two XMAC
 * chips connected to it, allowing single or dual port NIC configurations.
 * SysKonnect has the distinction of being the only vendor on the market
 * with a dual port gigabit ethernet NIC. The GEnesis provides dual FIFOs,
 * dual DMA queues, packet/MAC/transmit arbiters and direct access to the
 * XMAC registers. This driver takes advantage of these features to allow
 * both XMACs to operate as independent interfaces.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/timeout.h>
#include <sys/device.h>
#include <sys/queue.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/brgphyreg.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/pci/if_skreg.h>
#include <dev/pci/if_skvar.h>

int skc_probe(struct device *, void *, void *);
void skc_attach(struct device *, struct device *self, void *aux);
int skc_detach(struct device *, int);
int skc_activate(struct device *, int);
int sk_probe(struct device *, void *, void *);
void sk_attach(struct device *, struct device *self, void *aux);
int sk_detach(struct device *, int);
int sk_activate(struct device *, int);
int skcprint(void *, const char *);
int sk_intr(void *);
void sk_intr_bcom(struct sk_if_softc *);
void sk_intr_xmac(struct sk_if_softc *);
void sk_intr_yukon(struct sk_if_softc *);
static __inline int sk_rxvalid(struct sk_softc *, u_int32_t, u_int32_t);
void sk_rxeof(struct sk_if_softc *);
void sk_txeof(struct sk_if_softc *);
int sk_encap(struct sk_if_softc *, struct mbuf *, u_int32_t *);
void sk_start(struct ifnet *);
int sk_ioctl(struct ifnet *, u_long, caddr_t);
void sk_init(void *);
void sk_init_xmac(struct sk_if_softc *);
void sk_init_yukon(struct sk_if_softc *);
void sk_stop(struct sk_if_softc *, int softonly);
void sk_watchdog(struct ifnet *);
int sk_ifmedia_upd(struct ifnet *);
void sk_ifmedia_sts(struct ifnet *, struct ifmediareq *);
void skc_reset(struct sk_softc *);
int sk_newbuf(struct sk_if_softc *);
int sk_reset(struct sk_if_softc *);
int sk_init_rx_ring(struct sk_if_softc *);
void sk_fill_rx_ring(struct sk_if_softc *);
int sk_init_tx_ring(struct sk_if_softc *);

int sk_xmac_miibus_readreg(struct device *, int, int);
void sk_xmac_miibus_writereg(struct device *, int, int, int);
void sk_xmac_miibus_statchg(struct device *);

int sk_marv_miibus_readreg(struct device *, int, int);
void sk_marv_miibus_writereg(struct device *, int, int, int);
void sk_marv_miibus_statchg(struct device *);

void sk_setfilt(struct sk_if_softc *, caddr_t, int);
void sk_iff(struct sk_if_softc *);
void sk_iff_xmac(struct sk_if_softc *);
void sk_iff_yukon(struct sk_if_softc *);

void sk_tick(void *);
void sk_yukon_tick(void *);

#ifdef SK_DEBUG
#define DPRINTF(x)	if (skdebug) printf x
#define DPRINTFN(n,x)	if (skdebug >= (n)) printf x
int	skdebug = 0;

void sk_dump_txdesc(struct sk_tx_desc *, int);
void sk_dump_mbuf(struct mbuf *);
void sk_dump_bytes(const char *, int);
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

/* supported device vendors */
const struct pci_matchid skc_devices[] = {
	{ PCI_VENDOR_3COM,		PCI_PRODUCT_3COM_3C940 },
	{ PCI_VENDOR_3COM,		PCI_PRODUCT_3COM_3C940B },
	{ PCI_VENDOR_CNET,		PCI_PRODUCT_CNET_GIGACARD },
	{ PCI_VENDOR_DLINK,		PCI_PRODUCT_DLINK_DGE530T_A1 },
	{ PCI_VENDOR_DLINK,		PCI_PRODUCT_DLINK_DGE530T_B1 },
	{ PCI_VENDOR_LINKSYS,		PCI_PRODUCT_LINKSYS_EG1064 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_BELKIN },
	{ PCI_VENDOR_SCHNEIDERKOCH,	PCI_PRODUCT_SCHNEIDERKOCH_SK98XX },
	{ PCI_VENDOR_SCHNEIDERKOCH,	PCI_PRODUCT_SCHNEIDERKOCH_SK98XX2 },
	{ PCI_VENDOR_SCHNEIDERKOCH,	PCI_PRODUCT_SCHNEIDERKOCH_SK9821 },
	{ PCI_VENDOR_SCHNEIDERKOCH,	PCI_PRODUCT_SCHNEIDERKOCH_SK9843 }
};

#define SK_LINKSYS_EG1032_SUBID 0x00151737

static inline u_int32_t
sk_win_read_4(struct sk_softc *sc, u_int32_t reg)
{
	return CSR_READ_4(sc, reg);
}

static inline u_int16_t
sk_win_read_2(struct sk_softc *sc, u_int32_t reg)
{
	return CSR_READ_2(sc, reg);
}

static inline u_int8_t
sk_win_read_1(struct sk_softc *sc, u_int32_t reg)
{
	return CSR_READ_1(sc, reg);
}

static inline void
sk_win_write_4(struct sk_softc *sc, u_int32_t reg, u_int32_t x)
{
	CSR_WRITE_4(sc, reg, x);
}

static inline void
sk_win_write_2(struct sk_softc *sc, u_int32_t reg, u_int16_t x)
{
	CSR_WRITE_2(sc, reg, x);
}

static inline void
sk_win_write_1(struct sk_softc *sc, u_int32_t reg, u_int8_t x)
{
	CSR_WRITE_1(sc, reg, x);
}

int
sk_xmac_miibus_readreg(struct device *dev, int phy, int reg)
{
	struct sk_if_softc *sc_if = (struct sk_if_softc *)dev;
	int i;

	DPRINTFN(9, ("sk_xmac_miibus_readreg\n"));

	if (sc_if->sk_phytype == SK_PHYTYPE_XMAC && phy != 0)
		return (0);

	SK_XM_WRITE_2(sc_if, XM_PHY_ADDR, reg|(phy << 8));
	SK_XM_READ_2(sc_if, XM_PHY_DATA);
	if (sc_if->sk_phytype != SK_PHYTYPE_XMAC) {
		for (i = 0; i < SK_TIMEOUT; i++) {
			DELAY(1);
			if (SK_XM_READ_2(sc_if, XM_MMUCMD) &
			    XM_MMUCMD_PHYDATARDY)
				break;
		}

		if (i == SK_TIMEOUT) {
			printf("%s: phy failed to come ready\n",
			    sc_if->sk_dev.dv_xname);
			return (0);
		}
	}
	DELAY(1);
	return (SK_XM_READ_2(sc_if, XM_PHY_DATA));
}

void
sk_xmac_miibus_writereg(struct device *dev, int phy, int reg, int val)
{
	struct sk_if_softc *sc_if = (struct sk_if_softc *)dev;
	int i;

	DPRINTFN(9, ("sk_xmac_miibus_writereg\n"));

	SK_XM_WRITE_2(sc_if, XM_PHY_ADDR, reg|(phy << 8));
	for (i = 0; i < SK_TIMEOUT; i++) {
		if (!(SK_XM_READ_2(sc_if, XM_MMUCMD) & XM_MMUCMD_PHYBUSY))
			break;
	}

	if (i == SK_TIMEOUT) {
		printf("%s: phy failed to come ready\n",
		    sc_if->sk_dev.dv_xname);
		return;
	}

	SK_XM_WRITE_2(sc_if, XM_PHY_DATA, val);
	for (i = 0; i < SK_TIMEOUT; i++) {
		DELAY(1);
		if (!(SK_XM_READ_2(sc_if, XM_MMUCMD) & XM_MMUCMD_PHYBUSY))
			break;
	}

	if (i == SK_TIMEOUT)
		printf("%s: phy write timed out\n", sc_if->sk_dev.dv_xname);
}

void
sk_xmac_miibus_statchg(struct device *dev)
{
	struct sk_if_softc *sc_if = (struct sk_if_softc *)dev;
	struct mii_data *mii = &sc_if->sk_mii;

	DPRINTFN(9, ("sk_xmac_miibus_statchg\n"));

	/*
	 * If this is a GMII PHY, manually set the XMAC's
	 * duplex mode accordingly.
	 */
	if (sc_if->sk_phytype != SK_PHYTYPE_XMAC) {
		if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX)
			SK_XM_SETBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_GMIIFDX);
		else
			SK_XM_CLRBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_GMIIFDX);
	}
}

int
sk_marv_miibus_readreg(struct device *dev, int phy, int reg)
{
	struct sk_if_softc *sc_if = (struct sk_if_softc *)dev;
	u_int16_t val;
	int i;

	if (phy != 0 ||
	    (sc_if->sk_phytype != SK_PHYTYPE_MARV_COPPER &&
	     sc_if->sk_phytype != SK_PHYTYPE_MARV_FIBER)) {
		DPRINTFN(9, ("sk_marv_miibus_readreg (skip) phy=%d, reg=%#x\n",
		    phy, reg));
		return (0);
	}

	SK_YU_WRITE_2(sc_if, YUKON_SMICR, YU_SMICR_PHYAD(phy) |
	    YU_SMICR_REGAD(reg) | YU_SMICR_OP_READ);

	for (i = 0; i < SK_TIMEOUT; i++) {
		DELAY(1);
		val = SK_YU_READ_2(sc_if, YUKON_SMICR);
		if (val & YU_SMICR_READ_VALID)
			break;
	}

	if (i == SK_TIMEOUT) {
		printf("%s: phy failed to come ready\n",
		    sc_if->sk_dev.dv_xname);
		return (0);
	}

 	DPRINTFN(9, ("sk_marv_miibus_readreg: i=%d, timeout=%d\n", i,
	    SK_TIMEOUT));

	val = SK_YU_READ_2(sc_if, YUKON_SMIDR);

	DPRINTFN(9, ("sk_marv_miibus_readreg phy=%d, reg=%#x, val=%#x\n",
	    phy, reg, val));

	return (val);
}

void
sk_marv_miibus_writereg(struct device *dev, int phy, int reg, int val)
{
	struct sk_if_softc *sc_if = (struct sk_if_softc *)dev;
	int i;

	DPRINTFN(9, ("sk_marv_miibus_writereg phy=%d reg=%#x val=%#x\n",
	    phy, reg, val));

	SK_YU_WRITE_2(sc_if, YUKON_SMIDR, val);
	SK_YU_WRITE_2(sc_if, YUKON_SMICR, YU_SMICR_PHYAD(phy) |
	    YU_SMICR_REGAD(reg) | YU_SMICR_OP_WRITE);

	for (i = 0; i < SK_TIMEOUT; i++) {
		DELAY(1);
		if (!(SK_YU_READ_2(sc_if, YUKON_SMICR) & YU_SMICR_BUSY))
			break;
	}

	if (i == SK_TIMEOUT)
		printf("%s: phy write timed out\n", sc_if->sk_dev.dv_xname);
}

void
sk_marv_miibus_statchg(struct device *dev)
{
	DPRINTFN(9, ("sk_marv_miibus_statchg: gpcr=%x\n",
	    SK_YU_READ_2(((struct sk_if_softc *)dev), YUKON_GPCR)));
}

void
sk_setfilt(struct sk_if_softc *sc_if, caddr_t addr, int slot)
{
	int base = XM_RXFILT_ENTRY(slot);

	SK_XM_WRITE_2(sc_if, base, letoh16(*(u_int16_t *)(&addr[0])));
	SK_XM_WRITE_2(sc_if, base + 2, letoh16(*(u_int16_t *)(&addr[2])));
	SK_XM_WRITE_2(sc_if, base + 4, letoh16(*(u_int16_t *)(&addr[4])));
}

void
sk_iff(struct sk_if_softc *sc_if)
{
	struct sk_softc *sc = sc_if->sk_softc;

	if (SK_IS_GENESIS(sc))
		sk_iff_xmac(sc_if);
	else
		sk_iff_yukon(sc_if);
}

void
sk_iff_xmac(struct sk_if_softc *sc_if)
{
	struct ifnet *ifp = &sc_if->arpcom.ac_if;
	struct arpcom *ac = &sc_if->arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	u_int32_t reg, hashes[2];
	u_int8_t dummy[] = { 0, 0, 0, 0, 0 ,0 };
	int h, i;

	reg = SK_XM_READ_4(sc_if, XM_MODE);
	reg &= ~(XM_MODE_RX_NOBROAD | XM_MODE_RX_PROMISC | XM_MODE_RX_USE_HASH |
	    XM_MODE_RX_USE_PERFECT | XM_MODE_RX_USE_STATION);
	ifp->if_flags &= ~IFF_ALLMULTI;

	/*
	 * Always accept frames destined to our station address.
	 */
	reg |= XM_MODE_RX_USE_STATION;

	/* don't use perfect filter. */
	for (i = 1; i < XM_RXFILT_MAX; i++)
		sk_setfilt(sc_if, (caddr_t)&dummy, i);

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		if (ifp->if_flags & IFF_PROMISC)
			reg |= XM_MODE_RX_PROMISC;
		else
			reg |= XM_MODE_RX_USE_HASH;
		hashes[0] = hashes[1] = 0xFFFFFFFF;
	} else {
		reg |= XM_MODE_RX_USE_HASH;
		/* Program new filter. */
		bzero(hashes, sizeof(hashes));

		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = ether_crc32_le(enm->enm_addrlo,
			    ETHER_ADDR_LEN) & ((1 << SK_HASH_BITS) - 1);

			if (h < 32)
				hashes[0] |= (1 << h);
			else
				hashes[1] |= (1 << (h - 32));

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	SK_XM_WRITE_4(sc_if, XM_MAR0, hashes[0]);
	SK_XM_WRITE_4(sc_if, XM_MAR2, hashes[1]);
	SK_XM_WRITE_4(sc_if, XM_MODE, reg);
}

void
sk_iff_yukon(struct sk_if_softc *sc_if)
{
	struct ifnet *ifp = &sc_if->arpcom.ac_if;
	struct arpcom *ac = &sc_if->arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	u_int32_t hashes[2];
	u_int16_t rcr;
	int h;

	rcr = SK_YU_READ_2(sc_if, YUKON_RCR);
	rcr &= ~(YU_RCR_MUFLEN | YU_RCR_UFLEN);
	ifp->if_flags &= ~IFF_ALLMULTI;

	/*
	 * Always accept frames destined to our station address.
	 */
	rcr |= YU_RCR_UFLEN;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		if (ifp->if_flags & IFF_PROMISC)
			rcr &= ~YU_RCR_UFLEN;
		else
			rcr |= YU_RCR_MUFLEN;
		hashes[0] = hashes[1] = 0xFFFFFFFF;
	} else {
		rcr |= YU_RCR_MUFLEN;
		/* Program new filter. */
		bzero(hashes, sizeof(hashes));

		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = ether_crc32_be(enm->enm_addrlo,
			    ETHER_ADDR_LEN) & ((1 << SK_HASH_BITS) - 1);

			if (h < 32)
				hashes[0] |= (1 << h);
			else
				hashes[1] |= (1 << (h - 32));

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	SK_YU_WRITE_2(sc_if, YUKON_MCAH1, hashes[0] & 0xffff);
	SK_YU_WRITE_2(sc_if, YUKON_MCAH2, (hashes[0] >> 16) & 0xffff);
	SK_YU_WRITE_2(sc_if, YUKON_MCAH3, hashes[1] & 0xffff);
	SK_YU_WRITE_2(sc_if, YUKON_MCAH4, (hashes[1] >> 16) & 0xffff);
	SK_YU_WRITE_2(sc_if, YUKON_RCR, rcr);
}

int
sk_init_rx_ring(struct sk_if_softc *sc_if)
{
	struct sk_chain_data	*cd = &sc_if->sk_cdata;
	struct sk_ring_data	*rd = sc_if->sk_rdata;
	int			i, nexti;

	bzero(rd->sk_rx_ring, sizeof(struct sk_rx_desc) * SK_RX_RING_CNT);

	for (i = 0; i < SK_RX_RING_CNT; i++) {
		cd->sk_rx_chain[i].sk_desc = &rd->sk_rx_ring[i];
		if (i == (SK_RX_RING_CNT - 1))
			nexti = 0;
		else
			nexti = i + 1;
		cd->sk_rx_chain[i].sk_next = &cd->sk_rx_chain[nexti];
		htolem32(&rd->sk_rx_ring[i].sk_next,
		    SK_RX_RING_ADDR(sc_if, nexti));
	}

	sc_if->sk_cdata.sk_rx_prod = 0;
	sc_if->sk_cdata.sk_rx_cons = 0;

	if_rxr_init(&sc_if->sk_cdata.sk_rx_ring, 2, SK_RX_RING_CNT);

	sk_fill_rx_ring(sc_if);

	return (0);
}

void
sk_fill_rx_ring(struct sk_if_softc *sc_if)
{
	struct if_rxring *rxr = &sc_if->sk_cdata.sk_rx_ring;
	u_int slots;

	for (slots = if_rxr_get(rxr, SK_RX_RING_CNT); slots > 0; slots--) {
		if (sk_newbuf(sc_if) == ENOBUFS)
			break;
	}
	if_rxr_put(rxr, slots);
}

int
sk_init_tx_ring(struct sk_if_softc *sc_if)
{
	struct sk_softc		*sc = sc_if->sk_softc;
	struct sk_chain_data	*cd = &sc_if->sk_cdata;
	struct sk_ring_data	*rd = sc_if->sk_rdata;
	bus_dmamap_t		dmamap;
	struct sk_txmap_entry	*entry;
	int			i, nexti;

	bzero(sc_if->sk_rdata->sk_tx_ring,
	    sizeof(struct sk_tx_desc) * SK_TX_RING_CNT);

	SIMPLEQ_INIT(&sc_if->sk_txmap_head);
	for (i = 0; i < SK_TX_RING_CNT; i++) {
		cd->sk_tx_chain[i].sk_desc = &rd->sk_tx_ring[i];
		if (i == (SK_TX_RING_CNT - 1))
			nexti = 0;
		else
			nexti = i + 1;
		cd->sk_tx_chain[i].sk_next = &cd->sk_tx_chain[nexti];
		htolem32(&rd->sk_tx_ring[i].sk_next,
		    SK_TX_RING_ADDR(sc_if, nexti));

		if (bus_dmamap_create(sc->sc_dmatag, SK_JLEN, SK_NTXSEG,
		   SK_JLEN, 0, BUS_DMA_NOWAIT, &dmamap))
			return (ENOBUFS);

		entry = malloc(sizeof(*entry), M_DEVBUF, M_NOWAIT);
		if (!entry) {
			bus_dmamap_destroy(sc->sc_dmatag, dmamap);
			return (ENOBUFS);
		}
		entry->dmamap = dmamap;
		SIMPLEQ_INSERT_HEAD(&sc_if->sk_txmap_head, entry, link);
	}

	sc_if->sk_cdata.sk_tx_prod = 0;
	sc_if->sk_cdata.sk_tx_cons = 0;
	sc_if->sk_cdata.sk_tx_cnt = 0;

	SK_CDTXSYNC(sc_if, 0, SK_TX_RING_CNT,
	    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

	return (0);
}

int
sk_newbuf(struct sk_if_softc *sc_if)
{
	struct mbuf		*m;
	struct sk_chain		*c;
	struct sk_rx_desc	*r;
	bus_dmamap_t		dmamap;
	u_int			prod;
	int			error;
	uint64_t		dva;

	m = MCLGETI(NULL, M_DONTWAIT, NULL, SK_JLEN);
	if (m == NULL)
		return (ENOBUFS);

	m->m_len = m->m_pkthdr.len = SK_JLEN;
	m_adj(m, ETHER_ALIGN);

	prod = sc_if->sk_cdata.sk_rx_prod;
	dmamap = sc_if->sk_cdata.sk_rx_map[prod];

	error = bus_dmamap_load_mbuf(sc_if->sk_softc->sc_dmatag, dmamap, m,
	    BUS_DMA_READ|BUS_DMA_NOWAIT);
	if (error) {
		m_freem(m);
		return (ENOBUFS);
	}

	bus_dmamap_sync(sc_if->sk_softc->sc_dmatag, dmamap, 0,
	    dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);

	c = &sc_if->sk_cdata.sk_rx_chain[prod];
	c->sk_mbuf = m;

	r = c->sk_desc;
	dva = dmamap->dm_segs[0].ds_addr;
	htolem32(&r->sk_data_lo, dva);
	htolem32(&r->sk_data_hi, dva >> 32);
	htolem32(&r->sk_ctl, dmamap->dm_segs[0].ds_len | SK_RXSTAT);

	SK_CDRXSYNC(sc_if, prod, BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);

	SK_INC(prod, SK_RX_RING_CNT);
	sc_if->sk_cdata.sk_rx_prod = prod;

	return (0);
}

/*
 * Set media options.
 */
int
sk_ifmedia_upd(struct ifnet *ifp)
{
	struct sk_if_softc *sc_if = ifp->if_softc;

	mii_mediachg(&sc_if->sk_mii);
	return (0);
}

/*
 * Report current media status.
 */
void
sk_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct sk_if_softc *sc_if = ifp->if_softc;

	mii_pollstat(&sc_if->sk_mii);
	ifmr->ifm_active = sc_if->sk_mii.mii_media_active;
	ifmr->ifm_status = sc_if->sk_mii.mii_media_status;
}

int
sk_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct sk_if_softc *sc_if = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *) data;
	struct mii_data *mii;
	int s, error = 0;

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			sk_init(sc_if);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				sk_init(sc_if);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				sk_stop(sc_if, 0);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		mii = &sc_if->sk_mii;
		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);
		break;

	case SIOCGIFRXR:
		error = if_rxr_ioctl((struct if_rxrinfo *)ifr->ifr_data,
		    NULL, SK_JLEN, &sc_if->sk_cdata.sk_rx_ring);

		break;

	default:
		error = ether_ioctl(ifp, &sc_if->arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			sk_iff(sc_if);
		error = 0;
	}

	splx(s);
	return (error);
}

/*
 * Probe for a SysKonnect GEnesis chip. Check the PCI vendor and device
 * IDs against our list and return a device name if we find a match.
 */
int
skc_probe(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pcireg_t subid;

	subid = pci_conf_read(pc, pa->pa_tag, PCI_SUBSYS_ID_REG);

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_LINKSYS &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_LINKSYS_EG1032 &&
	    subid == SK_LINKSYS_EG1032_SUBID)
		return (1);

	return (pci_matchbyid((struct pci_attach_args *)aux, skc_devices,
	    nitems(skc_devices)));
}

/*
 * Force the GEnesis into reset, then bring it out of reset.
 */
void
skc_reset(struct sk_softc *sc)
{
	u_int32_t imtimer_ticks;

	DPRINTFN(2, ("skc_reset\n"));

	CSR_WRITE_2(sc, SK_CSR, SK_CSR_SW_RESET);
	CSR_WRITE_2(sc, SK_CSR, SK_CSR_MASTER_RESET);
	if (SK_IS_YUKON(sc))
		CSR_WRITE_2(sc, SK_LINK_CTRL, SK_LINK_RESET_SET);

	DELAY(1000);
	CSR_WRITE_2(sc, SK_CSR, SK_CSR_SW_UNRESET);
	DELAY(2);
	CSR_WRITE_2(sc, SK_CSR, SK_CSR_MASTER_UNRESET);
	if (SK_IS_YUKON(sc))
		CSR_WRITE_2(sc, SK_LINK_CTRL, SK_LINK_RESET_CLEAR);

	DPRINTFN(2, ("sk_reset: sk_csr=%x\n", CSR_READ_2(sc, SK_CSR)));
	DPRINTFN(2, ("sk_reset: sk_link_ctrl=%x\n",
	    CSR_READ_2(sc, SK_LINK_CTRL)));

	if (SK_IS_GENESIS(sc)) {
		/* Configure packet arbiter */
		sk_win_write_2(sc, SK_PKTARB_CTL, SK_PKTARBCTL_UNRESET);
		sk_win_write_2(sc, SK_RXPA1_TINIT, SK_PKTARB_TIMEOUT);
		sk_win_write_2(sc, SK_TXPA1_TINIT, SK_PKTARB_TIMEOUT);
		sk_win_write_2(sc, SK_RXPA2_TINIT, SK_PKTARB_TIMEOUT);
		sk_win_write_2(sc, SK_TXPA2_TINIT, SK_PKTARB_TIMEOUT);
	}

	/* Enable RAM interface */
	sk_win_write_4(sc, SK_RAMCTL, SK_RAMCTL_UNRESET);

	/*
	 * Configure interrupt moderation. The moderation timer
	 * defers interrupts specified in the interrupt moderation
	 * timer mask based on the timeout specified in the interrupt
	 * moderation timer init register. Each bit in the timer
	 * register represents one tick, so to specify a timeout in
	 * microseconds, we have to multiply by the correct number of
	 * ticks-per-microsecond.
	 */
	switch (sc->sk_type) {
	case SK_GENESIS:
		imtimer_ticks = SK_IMTIMER_TICKS_GENESIS;
		break;
	default:
		imtimer_ticks = SK_IMTIMER_TICKS_YUKON;
		break;
	}
	sk_win_write_4(sc, SK_IMTIMERINIT, SK_IM_USECS(100));
	sk_win_write_4(sc, SK_IMMR, SK_ISR_TX1_S_EOF|SK_ISR_TX2_S_EOF|
	    SK_ISR_RX1_EOF|SK_ISR_RX2_EOF);
	sk_win_write_1(sc, SK_IMTIMERCTL, SK_IMCTL_START);
}

int
sk_probe(struct device *parent, void *match, void *aux)
{
	struct skc_attach_args *sa = aux;

	if (sa->skc_port != SK_PORT_A && sa->skc_port != SK_PORT_B)
		return (0);

	switch (sa->skc_type) {
	case SK_GENESIS:
	case SK_YUKON:
	case SK_YUKON_LITE:
	case SK_YUKON_LP:
		return (1);
	}

	return (0);
}

/*
 * Each XMAC chip is attached as a separate logical IP interface.
 * Single port cards will have only one logical interface of course.
 */
void
sk_attach(struct device *parent, struct device *self, void *aux)
{
	struct sk_if_softc *sc_if = (struct sk_if_softc *) self;
	struct sk_softc *sc = (struct sk_softc *)parent;
	struct skc_attach_args *sa = aux;
	struct ifnet *ifp;
	caddr_t kva;
	int i, error;

	sc_if->sk_port = sa->skc_port;
	sc_if->sk_softc = sc;
	sc->sk_if[sa->skc_port] = sc_if;

	if (sa->skc_port == SK_PORT_A)
		sc_if->sk_tx_bmu = SK_BMU_TXS_CSR0;
	if (sa->skc_port == SK_PORT_B)
		sc_if->sk_tx_bmu = SK_BMU_TXS_CSR1;

	DPRINTFN(2, ("begin sk_attach: port=%d\n", sc_if->sk_port));

	/*
	 * Get station address for this interface. Note that
	 * dual port cards actually come with three station
	 * addresses: one for each port, plus an extra. The
	 * extra one is used by the SysKonnect driver software
	 * as a 'virtual' station address for when both ports
	 * are operating in failover mode. Currently we don't
	 * use this extra address.
	 */
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		sc_if->arpcom.ac_enaddr[i] =
		    sk_win_read_1(sc, SK_MAC0_0 + (sa->skc_port * 8) + i);

	printf(": address %s\n",
	    ether_sprintf(sc_if->arpcom.ac_enaddr));

	/*
	 * Set up RAM buffer addresses. The NIC will have a certain
	 * amount of SRAM on it, somewhere between 512K and 2MB. We
	 * need to divide this up a) between the transmitter and
 	 * receiver and b) between the two XMACs, if this is a
	 * dual port NIC. Our algorithm is to divide up the memory
	 * evenly so that everyone gets a fair share.
	 */
	if (sk_win_read_1(sc, SK_CONFIG) & SK_CONFIG_SINGLEMAC) {
		u_int32_t		chunk, val;

		chunk = sc->sk_ramsize / 2;
		val = sc->sk_rboff / sizeof(u_int64_t);
		sc_if->sk_rx_ramstart = val;
		val += (chunk / sizeof(u_int64_t));
		sc_if->sk_rx_ramend = val - 1;
		sc_if->sk_tx_ramstart = val;
		val += (chunk / sizeof(u_int64_t));
		sc_if->sk_tx_ramend = val - 1;
	} else {
		u_int32_t		chunk, val;

		chunk = sc->sk_ramsize / 4;
		val = (sc->sk_rboff + (chunk * 2 * sc_if->sk_port)) /
		    sizeof(u_int64_t);
		sc_if->sk_rx_ramstart = val;
		val += (chunk / sizeof(u_int64_t));
		sc_if->sk_rx_ramend = val - 1;
		sc_if->sk_tx_ramstart = val;
		val += (chunk / sizeof(u_int64_t));
		sc_if->sk_tx_ramend = val - 1;
	}

	DPRINTFN(2, ("sk_attach: rx_ramstart=%#x rx_ramend=%#x\n"
	    "           tx_ramstart=%#x tx_ramend=%#x\n",
	    sc_if->sk_rx_ramstart, sc_if->sk_rx_ramend,
	    sc_if->sk_tx_ramstart, sc_if->sk_tx_ramend));

	/* Read and save PHY type */
	sc_if->sk_phytype = sk_win_read_1(sc, SK_EPROM1) & 0xF;

	/* Set PHY address */
	if (SK_IS_GENESIS(sc)) {
		switch (sc_if->sk_phytype) {
		case SK_PHYTYPE_XMAC:
			sc_if->sk_phyaddr = SK_PHYADDR_XMAC;
			break;
		case SK_PHYTYPE_BCOM:
			sc_if->sk_phyaddr = SK_PHYADDR_BCOM;
			break;
		default:
			printf("%s: unsupported PHY type: %d\n",
			    sc->sk_dev.dv_xname, sc_if->sk_phytype);
			return;
		}
	}

	if (SK_IS_YUKON(sc)) {
		if ((sc_if->sk_phytype < SK_PHYTYPE_MARV_COPPER &&
		    sc->sk_pmd != 'L' && sc->sk_pmd != 'S')) {
			/* not initialized, punt */
			sc_if->sk_phytype = SK_PHYTYPE_MARV_COPPER;

			sc->sk_coppertype = 1;
		}

		sc_if->sk_phyaddr = SK_PHYADDR_MARV;

		if (!(sc->sk_coppertype))
			sc_if->sk_phytype = SK_PHYTYPE_MARV_FIBER;
	}

	/* Allocate the descriptor queues. */
	if (bus_dmamem_alloc(sc->sc_dmatag, sizeof(struct sk_ring_data),
	    PAGE_SIZE, 0, &sc_if->sk_ring_seg, 1, &sc_if->sk_ring_nseg,
	    BUS_DMA_NOWAIT | BUS_DMA_ZERO)) {
		printf(": can't alloc rx buffers\n");
		goto fail;
	}
	if (bus_dmamem_map(sc->sc_dmatag, &sc_if->sk_ring_seg,
	    sc_if->sk_ring_nseg, sizeof(struct sk_ring_data),
	    &kva, BUS_DMA_NOWAIT)) {
		printf(": can't map dma buffers (%lu bytes)\n",
		    (ulong)sizeof(struct sk_ring_data));
		goto fail_1;
	}
	if (bus_dmamap_create(sc->sc_dmatag, sizeof(struct sk_ring_data), 1,
	    sizeof(struct sk_ring_data), 0, BUS_DMA_NOWAIT,
	    &sc_if->sk_ring_map)) {
		printf(": can't create dma map\n");
		goto fail_2;
	}
	if (bus_dmamap_load(sc->sc_dmatag, sc_if->sk_ring_map, kva,
	    sizeof(struct sk_ring_data), NULL, BUS_DMA_NOWAIT)) {
		printf(": can't load dma map\n");
		goto fail_3;
	}
	sc_if->sk_rdata = (struct sk_ring_data *)kva;

	for (i = 0; i < SK_RX_RING_CNT; i++) {
		error = bus_dmamap_create(sc->sc_dmatag, SK_JLEN, 1,
		    SK_JLEN, 0, 0, &sc_if->sk_cdata.sk_rx_map[i]);
		if (error != 0) {
			printf(": unable to create rx DMA map %d, "
			    "error = %d\n", i, error);
			goto fail_4;
		}
	}

	ifp = &sc_if->arpcom.ac_if;
	ifp->if_softc = sc_if;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = sk_ioctl;
	ifp->if_start = sk_start;
	ifp->if_watchdog = sk_watchdog;
	ifp->if_hardmtu = SK_JUMBO_MTU;
	IFQ_SET_MAXLEN(&ifp->if_snd, SK_TX_RING_CNT - 1);
	bcopy(sc_if->sk_dev.dv_xname, ifp->if_xname, IFNAMSIZ);

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	if (sk_reset(sc_if) == -1) {
		printf(": unknown device type %d\n", sc_if->sk_softc->sk_type);
		/* dealloc jumbo on error */
		goto fail_3;
	}

 	DPRINTFN(2, ("sk_attach: 1\n"));

	sc_if->sk_mii.mii_ifp = ifp;
	if (SK_IS_GENESIS(sc)) {
		sc_if->sk_mii.mii_readreg = sk_xmac_miibus_readreg;
		sc_if->sk_mii.mii_writereg = sk_xmac_miibus_writereg;
		sc_if->sk_mii.mii_statchg = sk_xmac_miibus_statchg;
	} else {
		sc_if->sk_mii.mii_readreg = sk_marv_miibus_readreg;
		sc_if->sk_mii.mii_writereg = sk_marv_miibus_writereg;
		sc_if->sk_mii.mii_statchg = sk_marv_miibus_statchg;
	}

	ifmedia_init(&sc_if->sk_mii.mii_media, 0,
	    sk_ifmedia_upd, sk_ifmedia_sts);
	if (SK_IS_GENESIS(sc)) {
		mii_attach(self, &sc_if->sk_mii, 0xffffffff, MII_PHY_ANY,
		    MII_OFFSET_ANY, 0);
	} else {
		mii_attach(self, &sc_if->sk_mii, 0xffffffff, MII_PHY_ANY,
		    MII_OFFSET_ANY, MIIF_DOPAUSE);
	}
	if (LIST_FIRST(&sc_if->sk_mii.mii_phys) == NULL) {
		printf("%s: no PHY found!\n", sc_if->sk_dev.dv_xname);
		ifmedia_add(&sc_if->sk_mii.mii_media, IFM_ETHER|IFM_MANUAL,
			    0, NULL);
		ifmedia_set(&sc_if->sk_mii.mii_media, IFM_ETHER|IFM_MANUAL);
	} else
		ifmedia_set(&sc_if->sk_mii.mii_media, IFM_ETHER|IFM_AUTO);

	if (SK_IS_GENESIS(sc)) {
		timeout_set(&sc_if->sk_tick_ch, sk_tick, sc_if);
		timeout_add_sec(&sc_if->sk_tick_ch, 1);
	} else
		timeout_set(&sc_if->sk_tick_ch, sk_yukon_tick, sc_if);

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

	DPRINTFN(2, ("sk_attach: end\n"));
	return;
fail_4:
	for (i = 0; i < SK_RX_RING_CNT; i++) {
		if (sc_if->sk_cdata.sk_rx_map[i] == NULL)
			continue;

		bus_dmamap_destroy(sc->sc_dmatag, sc_if->sk_cdata.sk_rx_map[i]);
	}
fail_3:
	bus_dmamem_unmap(sc->sc_dmatag, kva, sizeof(struct sk_ring_data));
fail_2:
	bus_dmamem_free(sc->sc_dmatag, &sc_if->sk_ring_seg, sc_if->sk_ring_nseg);
fail_1:
	bus_dmamap_destroy(sc->sc_dmatag, sc_if->sk_ring_map);
fail:
	sc->sk_if[sa->skc_port] = NULL;
}

int
sk_reset(struct sk_if_softc *sc_if)
{
	/*
	 * Do miibus setup.
	 */
	switch (sc_if->sk_softc->sk_type) {
	case SK_GENESIS:
		sk_init_xmac(sc_if);
		break;
	case SK_YUKON:
	case SK_YUKON_LITE:
	case SK_YUKON_LP:
		sk_init_yukon(sc_if);
		break;
	default:
		return (-1);
	}
	return (0);
}

int
sk_detach(struct device *self, int flags)
{
	struct sk_if_softc *sc_if = (struct sk_if_softc *)self;
	struct sk_softc *sc = sc_if->sk_softc;
	struct ifnet *ifp= &sc_if->arpcom.ac_if;

	if (sc->sk_if[sc_if->sk_port] == NULL)
		return (0);

	sk_stop(sc_if, 1);

	/* Detach any PHYs we might have. */
	if (LIST_FIRST(&sc_if->sk_mii.mii_phys) != NULL)
		mii_detach(&sc_if->sk_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	/* Delete any remaining media. */
	ifmedia_delete_instance(&sc_if->sk_mii.mii_media, IFM_INST_ANY);

	ether_ifdetach(ifp);
	if_detach(ifp);

	bus_dmamem_unmap(sc->sc_dmatag, (caddr_t)sc_if->sk_rdata,
	    sizeof(struct sk_ring_data));
	bus_dmamem_free(sc->sc_dmatag,
	    &sc_if->sk_ring_seg, sc_if->sk_ring_nseg);
	bus_dmamap_destroy(sc->sc_dmatag, sc_if->sk_ring_map);
	sc->sk_if[sc_if->sk_port] = NULL;

	return (0);
}

int
sk_activate(struct device *self, int act)
{
	struct sk_if_softc *sc_if = (void *)self;
	struct ifnet *ifp = &sc_if->arpcom.ac_if;
	int rv = 0;

	switch (act) {
	case DVACT_RESUME:
		sk_reset(sc_if);
		if (ifp->if_flags & IFF_RUNNING)
			sk_init(sc_if);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

int
skcprint(void *aux, const char *pnp)
{
	struct skc_attach_args *sa = aux;

	if (pnp)
		printf("sk port %c at %s",
		    (sa->skc_port == SK_PORT_A) ? 'A' : 'B', pnp);
	else
		printf(" port %c", (sa->skc_port == SK_PORT_A) ? 'A' : 'B');
	return (UNCONF);
}

/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
void
skc_attach(struct device *parent, struct device *self, void *aux)
{
	struct sk_softc *sc = (struct sk_softc *)self;
	struct pci_attach_args *pa = aux;
	struct skc_attach_args skca;
	pci_chipset_tag_t pc = pa->pa_pc;
	pcireg_t memtype;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
	u_int8_t skrs;
	char *revstr = NULL;

	DPRINTFN(2, ("begin skc_attach\n"));

	pci_set_powerstate(pa->pa_pc, pa->pa_tag, PCI_PMCSR_STATE_D0);

	/*
	 * Map control/status registers.
	 */
	memtype = pci_mapreg_type(pc, pa->pa_tag, SK_PCI_LOMEM);
	if (pci_mapreg_map(pa, SK_PCI_LOMEM, memtype, 0, &sc->sk_btag,
	    &sc->sk_bhandle, NULL, &sc->sk_bsize, 0)) {
		printf(": can't map mem space\n");
		return;
	}

	sc->sc_dmatag = pa->pa_dmat;

	sc->sk_type = sk_win_read_1(sc, SK_CHIPVER);
	sc->sk_rev = (sk_win_read_1(sc, SK_CONFIG) >> 4);
	sc->sk_pc = pc;

	/* bail out here if chip is not recognized */
	if (! SK_IS_GENESIS(sc) && ! SK_IS_YUKON(sc)) {
		printf(": unknown chip type: %d\n", sc->sk_type);
		goto fail_1;
	}
	DPRINTFN(2, ("skc_attach: allocate interrupt\n"));

	/* Allocate interrupt */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		goto fail_1;
	}

	intrstr = pci_intr_string(pc, ih);
	sc->sk_intrhand = pci_intr_establish(pc, ih, IPL_NET, sk_intr, sc,
	    self->dv_xname);
	if (sc->sk_intrhand == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail_1;
	}

	/* Reset the adapter. */
	skc_reset(sc);

	skrs = sk_win_read_1(sc, SK_EPROM0);
	if (SK_IS_GENESIS(sc)) {
		/* Read and save RAM size and RAMbuffer offset */
		switch(skrs) {
		case SK_RAMSIZE_512K_64:
			sc->sk_ramsize = 0x80000;
			sc->sk_rboff = SK_RBOFF_0;
			break;
		case SK_RAMSIZE_1024K_64:
			sc->sk_ramsize = 0x100000;
			sc->sk_rboff = SK_RBOFF_80000;
			break;
		case SK_RAMSIZE_1024K_128:
			sc->sk_ramsize = 0x100000;
			sc->sk_rboff = SK_RBOFF_0;
			break;
		case SK_RAMSIZE_2048K_128:
			sc->sk_ramsize = 0x200000;
			sc->sk_rboff = SK_RBOFF_0;
			break;
		default:
			printf(": unknown ram size: %d\n", skrs);
			goto fail_2;
			break;
		}
	} else {
		if (skrs == 0x00)
			sc->sk_ramsize = 0x20000;
		else
			sc->sk_ramsize = skrs * (1<<12);
		sc->sk_rboff = SK_RBOFF_0;
	}

	DPRINTFN(2, ("skc_attach: ramsize=%d (%dk), rboff=%d\n",
	    sc->sk_ramsize, sc->sk_ramsize / 1024, sc->sk_rboff));

	/* Read and save physical media type */
	sc->sk_pmd = sk_win_read_1(sc, SK_PMDTYPE);

	if (sc->sk_pmd == 'T' || sc->sk_pmd == '1')
		sc->sk_coppertype = 1;
	else
		sc->sk_coppertype = 0;

	switch (sc->sk_type) {
	case SK_GENESIS:
		sc->sk_name = "GEnesis";
		break;
	case SK_YUKON:
		sc->sk_name = "Yukon";
		break;
	case SK_YUKON_LITE:
		sc->sk_name = "Yukon Lite";
		break;
	case SK_YUKON_LP:
		sc->sk_name = "Yukon LP";
		break;
	default:
		sc->sk_name = "Yukon (Unknown)";
	}

	/* Yukon Lite Rev A0 needs special test, from sk98lin driver */
	if (sc->sk_type == SK_YUKON || sc->sk_type == SK_YUKON_LP) {
		u_int32_t flashaddr;
		u_int8_t testbyte;

		flashaddr = sk_win_read_4(sc, SK_EP_ADDR);

		/* test Flash-Address Register */
		sk_win_write_1(sc, SK_EP_ADDR+3, 0xff);
		testbyte = sk_win_read_1(sc, SK_EP_ADDR+3);

		if (testbyte != 0) {
			/* This is a Yukon Lite Rev A0 */
			sc->sk_type = SK_YUKON_LITE;
			sc->sk_rev = SK_YUKON_LITE_REV_A0;
			/* restore Flash-Address Register */
			sk_win_write_4(sc, SK_EP_ADDR, flashaddr);
		}
	}

	if (sc->sk_type == SK_YUKON_LITE) {
		switch (sc->sk_rev) {
		case SK_YUKON_LITE_REV_A0:
			revstr = "A0";
			break;
		case SK_YUKON_LITE_REV_A1:
			revstr = "A1";
			break;
		case SK_YUKON_LITE_REV_A3:
			revstr = "A3";
			break;
		default:
			;
		}
	}

	/* Announce the product name. */
	printf(", %s", sc->sk_name);
	if (revstr != NULL)
		printf(" rev. %s", revstr);
	printf(" (0x%x): %s\n", sc->sk_rev, intrstr);

	sc->sk_macs = 1;

	if (!(sk_win_read_1(sc, SK_CONFIG) & SK_CONFIG_SINGLEMAC))
		sc->sk_macs++;

	skca.skc_port = SK_PORT_A;
	skca.skc_type = sc->sk_type;
	skca.skc_rev = sc->sk_rev;
	(void)config_found(&sc->sk_dev, &skca, skcprint);

	if (sc->sk_macs > 1) {
		skca.skc_port = SK_PORT_B;
		skca.skc_type = sc->sk_type;
		skca.skc_rev = sc->sk_rev;
		(void)config_found(&sc->sk_dev, &skca, skcprint);
	}

	/* Turn on the 'driver is loaded' LED. */
	CSR_WRITE_2(sc, SK_LED, SK_LED_GREEN_ON);

	return;

fail_2:
	pci_intr_disestablish(pc, sc->sk_intrhand);
fail_1:
	bus_space_unmap(sc->sk_btag, sc->sk_bhandle, sc->sk_bsize);
}

int
skc_detach(struct device *self, int flags)
{
	struct sk_softc *sc = (struct sk_softc *)self;
	int rv;

	if (sc->sk_intrhand)
		pci_intr_disestablish(sc->sk_pc, sc->sk_intrhand);

	rv = config_detach_children(self, flags);
	if (rv != 0)
		return (rv);

	if (sc->sk_bsize > 0)
		bus_space_unmap(sc->sk_btag, sc->sk_bhandle, sc->sk_bsize);

	return(0);
}

int
skc_activate(struct device *self, int act)
{
	struct sk_softc *sc = (void *)self;
	int rv = 0;

	switch (act) {
	case DVACT_RESUME:
		skc_reset(sc);
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

int
sk_encap(struct sk_if_softc *sc_if, struct mbuf *m_head, u_int32_t *txidx)
{
	struct sk_softc		*sc = sc_if->sk_softc;
	struct sk_tx_desc	*f = NULL;
	u_int32_t		frag, cur, sk_ctl;
	int			i;
	struct sk_txmap_entry	*entry;
	bus_dmamap_t		txmap;
	uint64_t		dva;

	DPRINTFN(2, ("sk_encap\n"));

	entry = SIMPLEQ_FIRST(&sc_if->sk_txmap_head);
	if (entry == NULL) {
		DPRINTFN(2, ("sk_encap: no txmap available\n"));
		return (ENOBUFS);
	}
	txmap = entry->dmamap;

	cur = frag = *txidx;

	switch (bus_dmamap_load_mbuf(sc->sc_dmatag, txmap, m_head,
	    BUS_DMA_STREAMING | BUS_DMA_NOWAIT)) {
	case 0:
		break;

	case EFBIG: /* mbuf chain is too fragmented */
		if (m_defrag(m_head, M_DONTWAIT) == 0 &&
		    bus_dmamap_load_mbuf(sc->sc_dmatag, txmap, m_head,
		    BUS_DMA_STREAMING | BUS_DMA_NOWAIT) == 0)
			break;
	default:
		return (1);
	}

	/* Sync the DMA map. */
	bus_dmamap_sync(sc->sc_dmatag, txmap, 0, txmap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	for (i = 0; i < txmap->dm_nsegs; i++) {
		f = &sc_if->sk_rdata->sk_tx_ring[frag];
		dva = txmap->dm_segs[i].ds_addr;
		htolem32(&f->sk_data_lo, dva);
		htolem32(&f->sk_data_hi, dva >> 32);
		sk_ctl = txmap->dm_segs[i].ds_len | SK_OPCODE_DEFAULT;
		if (i == 0)
			sk_ctl |= SK_TXCTL_FIRSTFRAG;
		else
			sk_ctl |= SK_TXCTL_OWN;
		htolem32(&f->sk_ctl, sk_ctl);
		cur = frag;
		SK_INC(frag, SK_TX_RING_CNT);
	}

	sc_if->sk_cdata.sk_tx_chain[cur].sk_mbuf = m_head;
	SIMPLEQ_REMOVE_HEAD(&sc_if->sk_txmap_head, link);

	sc_if->sk_cdata.sk_tx_map[cur] = entry;
	sc_if->sk_rdata->sk_tx_ring[cur].sk_ctl |=
		htole32(SK_TXCTL_LASTFRAG|SK_TXCTL_EOF_INTR);

	/* Sync descriptors before handing to chip */
	SK_CDTXSYNC(sc_if, *txidx, txmap->dm_nsegs,
	    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

	sc_if->sk_rdata->sk_tx_ring[*txidx].sk_ctl |=
		htole32(SK_TXCTL_OWN);

	/* Sync first descriptor to hand it off */
	SK_CDTXSYNC(sc_if, *txidx, 1, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

	sc_if->sk_cdata.sk_tx_cnt += txmap->dm_nsegs;

#ifdef SK_DEBUG
	if (skdebug >= 2) {
		struct sk_tx_desc *desc;
		u_int32_t idx;
		for (idx = *txidx; idx != frag; SK_INC(idx, SK_TX_RING_CNT)) {
			desc = &sc_if->sk_rdata->sk_tx_ring[idx];
			sk_dump_txdesc(desc, idx);
		}
	}
#endif

	*txidx = frag;

	DPRINTFN(2, ("sk_encap: completed successfully\n"));

	return (0);
}

void
sk_start(struct ifnet *ifp)
{
	struct sk_if_softc	*sc_if = ifp->if_softc;
	struct sk_softc		*sc = sc_if->sk_softc;
	struct mbuf		*m_head = NULL;
	u_int32_t		idx = sc_if->sk_cdata.sk_tx_prod;
	int			post = 0;

	DPRINTFN(2, ("sk_start\n"));

	for (;;) {
		if (sc_if->sk_cdata.sk_tx_cnt + SK_NTXSEG + 1 >
		    SK_TX_RING_CNT) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}
		
		m_head = ifq_dequeue(&ifp->if_snd);
		if (m_head == NULL)
			break;

		/*
		 * Pack the data into the transmit ring. If we
		 * don't have room, set the OACTIVE flag and wait
		 * for the NIC to drain the ring.
		 */
		if (sk_encap(sc_if, m_head, &idx)) {
			m_freem(m_head);
			continue;
		}

		/* now we are committed to transmit the packet */

		/*
		 * If there's a BPF listener, bounce a copy of this frame
		 * to him.
		 */
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif

		post = 1;
	}
	if (post == 0)
		return;

	/* Transmit */
	sc_if->sk_cdata.sk_tx_prod = idx;
	CSR_WRITE_4(sc, sc_if->sk_tx_bmu, SK_TXBMU_TX_START);

	/* Set a timeout in case the chip goes out to lunch. */
	ifp->if_timer = SK_TX_TIMEOUT;
}


void
sk_watchdog(struct ifnet *ifp)
{
	struct sk_if_softc *sc_if = ifp->if_softc;

	/*
	 * Reclaim first as there is a possibility of losing Tx completion
	 * interrupts.
	 */
	sk_txeof(sc_if);
	if (sc_if->sk_cdata.sk_tx_cnt != 0) {
		printf("%s: watchdog timeout\n", sc_if->sk_dev.dv_xname);

		ifp->if_oerrors++;

		sk_init(sc_if);
	}
}

static __inline int
sk_rxvalid(struct sk_softc *sc, u_int32_t stat, u_int32_t len)
{
	if (sc->sk_type == SK_GENESIS) {
		if ((stat & XM_RXSTAT_ERRFRAME) == XM_RXSTAT_ERRFRAME ||
		    XM_RXSTAT_BYTES(stat) != len)
			return (0);
	} else {
		if ((stat & (YU_RXSTAT_CRCERR | YU_RXSTAT_LONGERR |
		    YU_RXSTAT_MIIERR | YU_RXSTAT_BADFC | YU_RXSTAT_GOODFC |
		    YU_RXSTAT_JABBER)) != 0 ||
		    (stat & YU_RXSTAT_RXOK) != YU_RXSTAT_RXOK ||
		    YU_RXSTAT_BYTES(stat) != len)
			return (0);
	}

	return (1);
}

void
sk_rxeof(struct sk_if_softc *sc_if)
{
	struct sk_softc		*sc = sc_if->sk_softc;
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
	struct if_rxring	*rxr = &sc_if->sk_cdata.sk_rx_ring;
	struct mbuf		*m;
	struct mbuf_list	ml = MBUF_LIST_INITIALIZER();
	struct sk_chain		*cur_rx;
	struct sk_rx_desc	*cur_desc;
	int			cur, total_len = 0;
	u_int32_t		rxstat, sk_ctl;
	bus_dmamap_t		dmamap;

	DPRINTFN(2, ("sk_rxeof\n"));

	cur = sc_if->sk_cdata.sk_rx_cons;
	while (if_rxr_inuse(rxr) > 0) {
		/* Sync the descriptor */
		SK_CDRXSYNC(sc_if, cur,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);

		cur_rx = &sc_if->sk_cdata.sk_rx_chain[cur];
		if (cur_rx->sk_mbuf == NULL)
			break;

		cur_desc = &sc_if->sk_rdata->sk_rx_ring[cur];
		sk_ctl = lemtoh32(&cur_desc->sk_ctl);
		if ((sk_ctl & SK_RXCTL_OWN) != 0)
			break;

		dmamap = sc_if->sk_cdata.sk_rx_map[cur];

		bus_dmamap_sync(sc_if->sk_softc->sc_dmatag, dmamap, 0,
		    dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(sc_if->sk_softc->sc_dmatag, dmamap);

		m = cur_rx->sk_mbuf;
		cur_rx->sk_mbuf = NULL;
		if_rxr_put(rxr, 1);
		SK_INC(cur, SK_RX_RING_CNT);

		total_len = SK_RXBYTES(sk_ctl);
		rxstat = lemtoh32(&cur_desc->sk_xmac_rxstat);

		if ((sk_ctl & (SK_RXCTL_STATUS_VALID | SK_RXCTL_FIRSTFRAG |
		    SK_RXCTL_LASTFRAG)) != (SK_RXCTL_STATUS_VALID |
		    SK_RXCTL_FIRSTFRAG | SK_RXCTL_LASTFRAG) ||
		    total_len < SK_MIN_FRAMELEN ||
		    total_len > SK_JUMBO_FRAMELEN ||
		    sk_rxvalid(sc, rxstat, total_len) == 0) {
			ifp->if_ierrors++;
			m_freem(m);
			continue;
		}

		m->m_pkthdr.len = m->m_len = total_len;

		ml_enqueue(&ml, m);
	}
	sc_if->sk_cdata.sk_rx_cons = cur;

	sk_fill_rx_ring(sc_if);

	if_input(ifp, &ml);
}

void
sk_txeof(struct sk_if_softc *sc_if)
{
	struct sk_softc		*sc = sc_if->sk_softc;
	struct sk_tx_desc	*cur_tx;
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
	u_int32_t		idx, sk_ctl;
	struct sk_txmap_entry	*entry;

	DPRINTFN(2, ("sk_txeof\n"));

	/*
	 * Go through our tx ring and free mbufs for those
	 * frames that have been sent.
	 */
	idx = sc_if->sk_cdata.sk_tx_cons;
	while (idx != sc_if->sk_cdata.sk_tx_prod) {
		SK_CDTXSYNC(sc_if, idx, 1,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);

		cur_tx = &sc_if->sk_rdata->sk_tx_ring[idx];
		sk_ctl = lemtoh32(&cur_tx->sk_ctl);
#ifdef SK_DEBUG
		if (skdebug >= 2)
			sk_dump_txdesc(cur_tx, idx);
#endif
		if (sk_ctl & SK_TXCTL_OWN) {
			SK_CDTXSYNC(sc_if, idx, 1, BUS_DMASYNC_PREREAD);
			break;
		}
		if (sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf != NULL) {
			entry = sc_if->sk_cdata.sk_tx_map[idx];

			m_freem(sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf);
			sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf = NULL;

			bus_dmamap_sync(sc->sc_dmatag, entry->dmamap, 0,
			    entry->dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);

			bus_dmamap_unload(sc->sc_dmatag, entry->dmamap);
			SIMPLEQ_INSERT_TAIL(&sc_if->sk_txmap_head, entry,
					  link);
			sc_if->sk_cdata.sk_tx_map[idx] = NULL;
		}
		sc_if->sk_cdata.sk_tx_cnt--;
		SK_INC(idx, SK_TX_RING_CNT);
	}
	ifp->if_timer = sc_if->sk_cdata.sk_tx_cnt > 0 ? SK_TX_TIMEOUT : 0;

	if (sc_if->sk_cdata.sk_tx_cnt < SK_TX_RING_CNT - 2)
		ifq_clr_oactive(&ifp->if_snd);

	sc_if->sk_cdata.sk_tx_cons = idx;
}

void
sk_tick(void *xsc_if)
{
	struct sk_if_softc *sc_if = xsc_if;
	struct mii_data *mii = &sc_if->sk_mii;
	struct ifnet *ifp = &sc_if->arpcom.ac_if;
	int i;

	DPRINTFN(2, ("sk_tick\n"));

	if (!(ifp->if_flags & IFF_UP))
		return;

	if (sc_if->sk_phytype == SK_PHYTYPE_BCOM) {
		sk_intr_bcom(sc_if);
		return;
	}

	/*
	 * According to SysKonnect, the correct way to verify that
	 * the link has come back up is to poll bit 0 of the GPIO
	 * register three times. This pin has the signal from the
	 * link sync pin connected to it; if we read the same link
	 * state 3 times in a row, we know the link is up.
	 */
	for (i = 0; i < 3; i++) {
		if (SK_XM_READ_2(sc_if, XM_GPIO) & XM_GPIO_GP0_SET)
			break;
	}

	if (i != 3) {
		timeout_add_sec(&sc_if->sk_tick_ch, 1);
		return;
	}

	/* Turn the GP0 interrupt back on. */
	SK_XM_CLRBIT_2(sc_if, XM_IMR, XM_IMR_GP0_SET);
	SK_XM_READ_2(sc_if, XM_ISR);
	mii_tick(mii);
	timeout_del(&sc_if->sk_tick_ch);
}

void
sk_yukon_tick(void *xsc_if)
{
	struct sk_if_softc *sc_if = xsc_if;
	struct mii_data *mii = &sc_if->sk_mii;
	int s;

	s = splnet();
	mii_tick(mii);
	splx(s);
	timeout_add_sec(&sc_if->sk_tick_ch, 1);
}

void
sk_intr_bcom(struct sk_if_softc *sc_if)
{
	struct mii_data *mii = &sc_if->sk_mii;
	struct ifnet *ifp = &sc_if->arpcom.ac_if;
	int status;

	DPRINTFN(2, ("sk_intr_bcom\n"));

	SK_XM_CLRBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_TX_ENB|XM_MMUCMD_RX_ENB);

	/*
	 * Read the PHY interrupt register to make sure
	 * we clear any pending interrupts.
	 */
	status = sk_xmac_miibus_readreg((struct device *)sc_if,
	    SK_PHYADDR_BCOM, BRGPHY_MII_ISR);

	if (!(ifp->if_flags & IFF_RUNNING)) {
		sk_init_xmac(sc_if);
		return;
	}

	if (status & (BRGPHY_ISR_LNK_CHG|BRGPHY_ISR_AN_PR)) {
		int lstat;
		lstat = sk_xmac_miibus_readreg((struct device *)sc_if,
		    SK_PHYADDR_BCOM, BRGPHY_MII_AUXSTS);

		if (!(lstat & BRGPHY_AUXSTS_LINK) && sc_if->sk_link) {
			mii_mediachg(mii);
			/* Turn off the link LED. */
			SK_IF_WRITE_1(sc_if, 0,
			    SK_LINKLED1_CTL, SK_LINKLED_OFF);
			sc_if->sk_link = 0;
		} else if (status & BRGPHY_ISR_LNK_CHG) {
			sk_xmac_miibus_writereg((struct device *)sc_if,
			    SK_PHYADDR_BCOM, BRGPHY_MII_IMR, 0xFF00);
			mii_tick(mii);
			sc_if->sk_link = 1;
			/* Turn on the link LED. */
			SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL,
			    SK_LINKLED_ON|SK_LINKLED_LINKSYNC_OFF|
			    SK_LINKLED_BLINK_OFF);
		} else {
			mii_tick(mii);
			timeout_add_sec(&sc_if->sk_tick_ch, 1);
		}
	}

	SK_XM_SETBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_TX_ENB|XM_MMUCMD_RX_ENB);
}

void
sk_intr_xmac(struct sk_if_softc	*sc_if)
{
	u_int16_t status = SK_XM_READ_2(sc_if, XM_ISR);

	DPRINTFN(2, ("sk_intr_xmac\n"));

	if (sc_if->sk_phytype == SK_PHYTYPE_XMAC) {
		if (status & XM_ISR_GP0_SET) {
			SK_XM_SETBIT_2(sc_if, XM_IMR, XM_IMR_GP0_SET);
			timeout_add_sec(&sc_if->sk_tick_ch, 1);
		}

		if (status & XM_ISR_AUTONEG_DONE) {
			timeout_add_sec(&sc_if->sk_tick_ch, 1);
		}
	}

	if (status & XM_IMR_TX_UNDERRUN)
		SK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_FLUSH_TXFIFO);

	if (status & XM_IMR_RX_OVERRUN)
		SK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_FLUSH_RXFIFO);
}

void
sk_intr_yukon(struct sk_if_softc *sc_if)
{
	u_int8_t status;

	status = SK_IF_READ_1(sc_if, 0, SK_GMAC_ISR);
	/* RX overrun */
	if ((status & SK_GMAC_INT_RX_OVER) != 0) {
		SK_IF_WRITE_1(sc_if, 0, SK_RXMF1_CTRL_TEST,
		    SK_RFCTL_RX_FIFO_OVER);
	}
	/* TX underrun */
	if ((status & SK_GMAC_INT_TX_UNDER) != 0) {
		SK_IF_WRITE_1(sc_if, 0, SK_TXMF1_CTRL_TEST,
		    SK_TFCTL_TX_FIFO_UNDER);
	}

	DPRINTFN(2, ("sk_intr_yukon status=%#x\n", status));
}

int
sk_intr(void *xsc)
{
	struct sk_softc		*sc = xsc;
	struct sk_if_softc	*sc_if0 = sc->sk_if[SK_PORT_A];
	struct sk_if_softc	*sc_if1 = sc->sk_if[SK_PORT_B];
	struct ifnet		*ifp0 = NULL, *ifp1 = NULL;
	u_int32_t		status;
	int			claimed = 0;

	status = CSR_READ_4(sc, SK_ISSR);
	if (status == 0 || status == 0xffffffff)
		return (0);

	if (sc_if0 != NULL)
		ifp0 = &sc_if0->arpcom.ac_if;
	if (sc_if1 != NULL)
		ifp1 = &sc_if1->arpcom.ac_if;

	for (; (status &= sc->sk_intrmask) != 0;) {
		claimed = 1;

		/* Handle receive interrupts first. */
		if (sc_if0 && (status & SK_ISR_RX1_EOF)) {
			sk_rxeof(sc_if0);
			CSR_WRITE_4(sc, SK_BMU_RX_CSR0,
			    SK_RXBMU_CLR_IRQ_EOF|SK_RXBMU_RX_START);
		}
		if (sc_if1 && (status & SK_ISR_RX2_EOF)) {
			sk_rxeof(sc_if1);
			CSR_WRITE_4(sc, SK_BMU_RX_CSR1,
			    SK_RXBMU_CLR_IRQ_EOF|SK_RXBMU_RX_START);
		}

		/* Then transmit interrupts. */
		if (sc_if0 && (status & SK_ISR_TX1_S_EOF)) {
			sk_txeof(sc_if0);
			CSR_WRITE_4(sc, SK_BMU_TXS_CSR0,
			    SK_TXBMU_CLR_IRQ_EOF);
		}
		if (sc_if1 && (status & SK_ISR_TX2_S_EOF)) {
			sk_txeof(sc_if1);
			CSR_WRITE_4(sc, SK_BMU_TXS_CSR1,
			    SK_TXBMU_CLR_IRQ_EOF);
		}

		/* Then MAC interrupts. */
		if (sc_if0 && (status & SK_ISR_MAC1) &&
		    (ifp0->if_flags & IFF_RUNNING)) {
			if (SK_IS_GENESIS(sc))
				sk_intr_xmac(sc_if0);
			else
				sk_intr_yukon(sc_if0);
		}

		if (sc_if1 && (status & SK_ISR_MAC2) &&
		    (ifp1->if_flags & IFF_RUNNING)) {
			if (SK_IS_GENESIS(sc))
				sk_intr_xmac(sc_if1);
			else
				sk_intr_yukon(sc_if1);

		}

		if (status & SK_ISR_EXTERNAL_REG) {
			if (sc_if0 != NULL &&
			    sc_if0->sk_phytype == SK_PHYTYPE_BCOM)
				sk_intr_bcom(sc_if0);

			if (sc_if1 != NULL &&
			    sc_if1->sk_phytype == SK_PHYTYPE_BCOM)
				sk_intr_bcom(sc_if1);
		}
		status = CSR_READ_4(sc, SK_ISSR);
	}

	CSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);

	if (ifp0 != NULL && !IFQ_IS_EMPTY(&ifp0->if_snd))
		sk_start(ifp0);
	if (ifp1 != NULL && !IFQ_IS_EMPTY(&ifp1->if_snd))
		sk_start(ifp1);

	return (claimed);
}

void
sk_init_xmac(struct sk_if_softc	*sc_if)
{
	struct sk_softc		*sc = sc_if->sk_softc;
	struct sk_bcom_hack	bhack[] = {
	{ 0x18, 0x0c20 }, { 0x17, 0x0012 }, { 0x15, 0x1104 }, { 0x17, 0x0013 },
	{ 0x15, 0x0404 }, { 0x17, 0x8006 }, { 0x15, 0x0132 }, { 0x17, 0x8006 },
	{ 0x15, 0x0232 }, { 0x17, 0x800D }, { 0x15, 0x000F }, { 0x18, 0x0420 },
	{ 0, 0 } };

	DPRINTFN(2, ("sk_init_xmac\n"));

	/* Unreset the XMAC. */
	SK_IF_WRITE_2(sc_if, 0, SK_TXF1_MACCTL, SK_TXMACCTL_XMAC_UNRESET);
	DELAY(1000);

	/* Reset the XMAC's internal state. */
	SK_XM_SETBIT_2(sc_if, XM_GPIO, XM_GPIO_RESETMAC);

	/* Save the XMAC II revision */
	sc_if->sk_xmac_rev = XM_XMAC_REV(SK_XM_READ_4(sc_if, XM_DEVID));

	/*
	 * Perform additional initialization for external PHYs,
	 * namely for the 1000baseTX cards that use the XMAC's
	 * GMII mode.
	 */
	if (sc_if->sk_phytype == SK_PHYTYPE_BCOM) {
		int			i = 0;
		u_int32_t		val;

		/* Take PHY out of reset. */
		val = sk_win_read_4(sc, SK_GPIO);
		if (sc_if->sk_port == SK_PORT_A)
			val |= SK_GPIO_DIR0|SK_GPIO_DAT0;
		else
			val |= SK_GPIO_DIR2|SK_GPIO_DAT2;
		sk_win_write_4(sc, SK_GPIO, val);

		/* Enable GMII mode on the XMAC. */
		SK_XM_SETBIT_2(sc_if, XM_HWCFG, XM_HWCFG_GMIIMODE);

		sk_xmac_miibus_writereg((struct device *)sc_if,
		    SK_PHYADDR_BCOM, MII_BMCR, BMCR_RESET);
		DELAY(10000);
		sk_xmac_miibus_writereg((struct device *)sc_if,
		    SK_PHYADDR_BCOM, BRGPHY_MII_IMR, 0xFFF0);

		/*
		 * Early versions of the BCM5400 apparently have
		 * a bug that requires them to have their reserved
		 * registers initialized to some magic values. I don't
		 * know what the numbers do, I'm just the messenger.
		 */
		if (sk_xmac_miibus_readreg((struct device *)sc_if,
		    SK_PHYADDR_BCOM, 0x03) == 0x6041) {
			while(bhack[i].reg) {
				sk_xmac_miibus_writereg((struct device *)sc_if,
				    SK_PHYADDR_BCOM, bhack[i].reg,
				    bhack[i].val);
				i++;
			}
		}
	}

	/* Set station address */
	SK_XM_WRITE_2(sc_if, XM_PAR0,
	    letoh16(*(u_int16_t *)(&sc_if->arpcom.ac_enaddr[0])));
	SK_XM_WRITE_2(sc_if, XM_PAR1,
	    letoh16(*(u_int16_t *)(&sc_if->arpcom.ac_enaddr[2])));
	SK_XM_WRITE_2(sc_if, XM_PAR2,
	    letoh16(*(u_int16_t *)(&sc_if->arpcom.ac_enaddr[4])));

	/* We don't need the FCS appended to the packet. */
	SK_XM_SETBIT_2(sc_if, XM_RXCMD, XM_RXCMD_STRIPFCS);

	/* We want short frames padded to 60 bytes. */
	SK_XM_SETBIT_2(sc_if, XM_TXCMD, XM_TXCMD_AUTOPAD);

	/*
	 * Enable the reception of all error frames. This is
	 * a necessary evil due to the design of the XMAC. The
	 * XMAC's receive FIFO is only 8K in size, however jumbo
	 * frames can be up to 9000 bytes in length. When bad
	 * frame filtering is enabled, the XMAC's RX FIFO operates
	 * in 'store and forward' mode. For this to work, the
	 * entire frame has to fit into the FIFO, but that means
	 * that jumbo frames larger than 8192 bytes will be
	 * truncated. Disabling all bad frame filtering causes
	 * the RX FIFO to operate in streaming mode, in which
	 * case the XMAC will start transferring frames out of the
	 * RX FIFO as soon as the FIFO threshold is reached.
	 */
	SK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_BADFRAMES|
	    XM_MODE_RX_GIANTS|XM_MODE_RX_RUNTS|XM_MODE_RX_CRCERRS|
	    XM_MODE_RX_INRANGELEN);

	SK_XM_SETBIT_2(sc_if, XM_RXCMD, XM_RXCMD_BIGPKTOK);

	/*
	 * Bump up the transmit threshold. This helps hold off transmit
	 * underruns when we're blasting traffic from both ports at once.
	 */
	SK_XM_WRITE_2(sc_if, XM_TX_REQTHRESH, SK_XM_TX_FIFOTHRESH);

	/* Program promiscuous mode and multicast filters. */
	sk_iff(sc_if);

	/* Clear and enable interrupts */
	SK_XM_READ_2(sc_if, XM_ISR);
	if (sc_if->sk_phytype == SK_PHYTYPE_XMAC)
		SK_XM_WRITE_2(sc_if, XM_IMR, XM_INTRS);
	else
		SK_XM_WRITE_2(sc_if, XM_IMR, 0xFFFF);

	/* Configure MAC arbiter */
	switch(sc_if->sk_xmac_rev) {
	case XM_XMAC_REV_B2:
		sk_win_write_1(sc, SK_RCINIT_RX1, SK_RCINIT_XMAC_B2);
		sk_win_write_1(sc, SK_RCINIT_TX1, SK_RCINIT_XMAC_B2);
		sk_win_write_1(sc, SK_RCINIT_RX2, SK_RCINIT_XMAC_B2);
		sk_win_write_1(sc, SK_RCINIT_TX2, SK_RCINIT_XMAC_B2);
		sk_win_write_1(sc, SK_MINIT_RX1, SK_MINIT_XMAC_B2);
		sk_win_write_1(sc, SK_MINIT_TX1, SK_MINIT_XMAC_B2);
		sk_win_write_1(sc, SK_MINIT_RX2, SK_MINIT_XMAC_B2);
		sk_win_write_1(sc, SK_MINIT_TX2, SK_MINIT_XMAC_B2);
		sk_win_write_1(sc, SK_RECOVERY_CTL, SK_RECOVERY_XMAC_B2);
		break;
	case XM_XMAC_REV_C1:
		sk_win_write_1(sc, SK_RCINIT_RX1, SK_RCINIT_XMAC_C1);
		sk_win_write_1(sc, SK_RCINIT_TX1, SK_RCINIT_XMAC_C1);
		sk_win_write_1(sc, SK_RCINIT_RX2, SK_RCINIT_XMAC_C1);
		sk_win_write_1(sc, SK_RCINIT_TX2, SK_RCINIT_XMAC_C1);
		sk_win_write_1(sc, SK_MINIT_RX1, SK_MINIT_XMAC_C1);
		sk_win_write_1(sc, SK_MINIT_TX1, SK_MINIT_XMAC_C1);
		sk_win_write_1(sc, SK_MINIT_RX2, SK_MINIT_XMAC_C1);
		sk_win_write_1(sc, SK_MINIT_TX2, SK_MINIT_XMAC_C1);
		sk_win_write_1(sc, SK_RECOVERY_CTL, SK_RECOVERY_XMAC_B2);
		break;
	default:
		break;
	}
	sk_win_write_2(sc, SK_MACARB_CTL,
	    SK_MACARBCTL_UNRESET|SK_MACARBCTL_FASTOE_OFF);

	sc_if->sk_link = 1;
}

void sk_init_yukon(struct sk_if_softc *sc_if)
{
	u_int32_t		phy, v;
	u_int16_t		reg;
	struct sk_softc		*sc;
	int			i;

	sc = sc_if->sk_softc;

	DPRINTFN(2, ("sk_init_yukon: start: sk_csr=%#x\n",
	    CSR_READ_4(sc_if->sk_softc, SK_CSR)));

	if (sc->sk_type == SK_YUKON_LITE &&
	    sc->sk_rev >= SK_YUKON_LITE_REV_A3) {
		/*
		 * Workaround code for COMA mode, set PHY reset.
		 * Otherwise it will not correctly take chip out of
		 * powerdown (coma)
		 */
		v = sk_win_read_4(sc, SK_GPIO);
		v |= SK_GPIO_DIR9 | SK_GPIO_DAT9;
		sk_win_write_4(sc, SK_GPIO, v);
	}

	DPRINTFN(6, ("sk_init_yukon: 1\n"));

	/* GMAC and GPHY Reset */
	SK_IF_WRITE_4(sc_if, 0, SK_GPHY_CTRL, SK_GPHY_RESET_SET);
	SK_IF_WRITE_4(sc_if, 0, SK_GMAC_CTRL, SK_GMAC_RESET_SET);
	DELAY(1000);

	DPRINTFN(6, ("sk_init_yukon: 2\n"));

	if (sc->sk_type == SK_YUKON_LITE &&
	    sc->sk_rev >= SK_YUKON_LITE_REV_A3) {
		/*
		 * Workaround code for COMA mode, clear PHY reset
		 */
		v = sk_win_read_4(sc, SK_GPIO);
		v |= SK_GPIO_DIR9;
		v &= ~SK_GPIO_DAT9;
		sk_win_write_4(sc, SK_GPIO, v);
	}

	phy = SK_GPHY_INT_POL_HI | SK_GPHY_DIS_FC | SK_GPHY_DIS_SLEEP |
		SK_GPHY_ENA_XC | SK_GPHY_ANEG_ALL | SK_GPHY_ENA_PAUSE;

	if (sc->sk_coppertype)
		phy |= SK_GPHY_COPPER;
	else
		phy |= SK_GPHY_FIBER;

	DPRINTFN(3, ("sk_init_yukon: phy=%#x\n", phy));

	SK_IF_WRITE_4(sc_if, 0, SK_GPHY_CTRL, phy | SK_GPHY_RESET_SET);
	DELAY(1000);
	SK_IF_WRITE_4(sc_if, 0, SK_GPHY_CTRL, phy | SK_GPHY_RESET_CLEAR);
	SK_IF_WRITE_4(sc_if, 0, SK_GMAC_CTRL, SK_GMAC_LOOP_OFF |
	    SK_GMAC_PAUSE_ON | SK_GMAC_RESET_CLEAR);

	DPRINTFN(3, ("sk_init_yukon: gmac_ctrl=%#x\n",
	    SK_IF_READ_4(sc_if, 0, SK_GMAC_CTRL)));

	DPRINTFN(6, ("sk_init_yukon: 3\n"));

	/* unused read of the interrupt source register */
	DPRINTFN(6, ("sk_init_yukon: 4\n"));
	SK_IF_READ_2(sc_if, 0, SK_GMAC_ISR);

	DPRINTFN(6, ("sk_init_yukon: 4a\n"));
	reg = SK_YU_READ_2(sc_if, YUKON_PAR);
	DPRINTFN(6, ("sk_init_yukon: YUKON_PAR=%#x\n", reg));

	/* MIB Counter Clear Mode set */
	reg |= YU_PAR_MIB_CLR;
	DPRINTFN(6, ("sk_init_yukon: YUKON_PAR=%#x\n", reg));
	DPRINTFN(6, ("sk_init_yukon: 4b\n"));
	SK_YU_WRITE_2(sc_if, YUKON_PAR, reg);

	/* MIB Counter Clear Mode clear */
	DPRINTFN(6, ("sk_init_yukon: 5\n"));
	reg &= ~YU_PAR_MIB_CLR;
	SK_YU_WRITE_2(sc_if, YUKON_PAR, reg);

	/* receive control reg */
	DPRINTFN(6, ("sk_init_yukon: 7\n"));
	SK_YU_WRITE_2(sc_if, YUKON_RCR, YU_RCR_CRCR);

	/* transmit parameter register */
	DPRINTFN(6, ("sk_init_yukon: 8\n"));
	SK_YU_WRITE_2(sc_if, YUKON_TPR, YU_TPR_JAM_LEN(0x3) |
	    YU_TPR_JAM_IPG(0xb) | YU_TPR_JAM2DATA_IPG(0x1a) );

	/* serial mode register */
	DPRINTFN(6, ("sk_init_yukon: 9\n"));
	SK_YU_WRITE_2(sc_if, YUKON_SMR, YU_SMR_DATA_BLIND(0x1c) |
	    YU_SMR_MFL_VLAN | YU_SMR_MFL_JUMBO | YU_SMR_IPG_DATA(0x1e));

	DPRINTFN(6, ("sk_init_yukon: 10\n"));
	/* Setup Yukon's address */
	for (i = 0; i < 3; i++) {
		/* Write Source Address 1 (unicast filter) */
		SK_YU_WRITE_2(sc_if, YUKON_SAL1 + i * 4,
		    sc_if->arpcom.ac_enaddr[i * 2] |
		    sc_if->arpcom.ac_enaddr[i * 2 + 1] << 8);
	}

	for (i = 0; i < 3; i++) {
		reg = sk_win_read_2(sc_if->sk_softc,
				    SK_MAC1_0 + i * 2 + sc_if->sk_port * 8);
		SK_YU_WRITE_2(sc_if, YUKON_SAL2 + i * 4, reg);
	}

	/* Program promiscuous mode and multicast filters. */
	DPRINTFN(6, ("sk_init_yukon: 11\n"));
	sk_iff(sc_if);

	/* enable interrupt mask for counter overflows */
	DPRINTFN(6, ("sk_init_yukon: 12\n"));
	SK_YU_WRITE_2(sc_if, YUKON_TIMR, 0);
	SK_YU_WRITE_2(sc_if, YUKON_RIMR, 0);
	SK_YU_WRITE_2(sc_if, YUKON_TRIMR, 0);

	/* Configure RX MAC FIFO Flush Mask */
	v = YU_RXSTAT_FOFL | YU_RXSTAT_CRCERR | YU_RXSTAT_MIIERR |
	    YU_RXSTAT_BADFC | YU_RXSTAT_GOODFC | YU_RXSTAT_RUNT |
	    YU_RXSTAT_JABBER;
	SK_IF_WRITE_2(sc_if, 0, SK_RXMF1_FLUSH_MASK, v);

	/* Disable RX MAC FIFO Flush for YUKON-Lite Rev. A0 only */
	if (sc->sk_type == SK_YUKON_LITE && sc->sk_rev == SK_YUKON_LITE_REV_A0)
		v = SK_TFCTL_OPERATION_ON;
	else
		v = SK_TFCTL_OPERATION_ON | SK_RFCTL_FIFO_FLUSH_ON;
	/* Configure RX MAC FIFO */
	SK_IF_WRITE_1(sc_if, 0, SK_RXMF1_CTRL_TEST, SK_RFCTL_RESET_CLEAR);
	SK_IF_WRITE_2(sc_if, 0, SK_RXMF1_CTRL_TEST, v);

	/* Increase flush threshould to 64 bytes */
	SK_IF_WRITE_2(sc_if, 0, SK_RXMF1_FLUSH_THRESHOLD,
	    SK_RFCTL_FIFO_THRESHOLD + 1);

	/* Configure TX MAC FIFO */
	SK_IF_WRITE_1(sc_if, 0, SK_TXMF1_CTRL_TEST, SK_TFCTL_RESET_CLEAR);
	SK_IF_WRITE_2(sc_if, 0, SK_TXMF1_CTRL_TEST, SK_TFCTL_OPERATION_ON);

	DPRINTFN(6, ("sk_init_yukon: end\n"));
}

/*
 * Note that to properly initialize any part of the GEnesis chip,
 * you first have to take it out of reset mode.
 */
void
sk_init(void *xsc_if)
{
	struct sk_if_softc	*sc_if = xsc_if;
	struct sk_softc		*sc = sc_if->sk_softc;
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
	struct mii_data		*mii = &sc_if->sk_mii;
	int			s;

	DPRINTFN(2, ("sk_init\n"));

	s = splnet();

	/* Cancel pending I/O and free all RX/TX buffers. */
	sk_stop(sc_if, 0);

	if (SK_IS_GENESIS(sc)) {
		/* Configure LINK_SYNC LED */
		SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_ON);
		SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL,
		    SK_LINKLED_LINKSYNC_ON);

		/* Configure RX LED */
		SK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL,
		    SK_RXLEDCTL_COUNTER_START);

		/* Configure TX LED */
		SK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL,
		    SK_TXLEDCTL_COUNTER_START);
	}

	/*
	 * Configure descriptor poll timer
	 *
	 * SK-NET GENESIS data sheet says that possibility of losing Start
	 * transmit command due to CPU/cache related interim storage problems
	 * under certain conditions. The document recommends a polling
	 * mechanism to send a Start transmit command to initiate transfer
	 * of ready descriptors regulary. To cope with this issue sk(4) now
	 * enables descriptor poll timer to initiate descriptor processing
	 * periodically as defined by SK_DPT_TIMER_MAX. However sk(4) still
	 * issue SK_TXBMU_TX_START to Tx BMU to get fast execution of Tx
	 * command instead of waiting for next descriptor polling time.
	 * The same rule may apply to Rx side too but it seems that is not
	 * needed at the moment.
	 * Since sk(4) uses descriptor polling as a last resort there is no
	 * need to set smaller polling time than maximum allowable one.
	 */
	SK_IF_WRITE_4(sc_if, 0, SK_DPT_INIT, SK_DPT_TIMER_MAX);

	/* Configure I2C registers */

	/* Configure XMAC(s) */
	switch (sc->sk_type) {
	case SK_GENESIS:
		sk_init_xmac(sc_if);
		break;
	case SK_YUKON:
	case SK_YUKON_LITE:
	case SK_YUKON_LP:
		sk_init_yukon(sc_if);
		break;
	}
	mii_mediachg(mii);

	if (SK_IS_GENESIS(sc)) {
		/* Configure MAC FIFOs */
		SK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_UNRESET);
		SK_IF_WRITE_4(sc_if, 0, SK_RXF1_END, SK_FIFO_END);
		SK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_ON);

		SK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_UNRESET);
		SK_IF_WRITE_4(sc_if, 0, SK_TXF1_END, SK_FIFO_END);
		SK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_ON);
	}

	/* Configure transmit arbiter(s) */
	SK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL,
	    SK_TXARCTL_ON|SK_TXARCTL_FSYNC_ON);

	/* Configure RAMbuffers */
	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_UNRESET);
	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_START, sc_if->sk_rx_ramstart);
	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_WR_PTR, sc_if->sk_rx_ramstart);
	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_RD_PTR, sc_if->sk_rx_ramstart);
	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_END, sc_if->sk_rx_ramend);
	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_ON);

	SK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_UNRESET);
	SK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_STORENFWD_ON);
	SK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_START, sc_if->sk_tx_ramstart);
	SK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_WR_PTR, sc_if->sk_tx_ramstart);
	SK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_RD_PTR, sc_if->sk_tx_ramstart);
	SK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_END, sc_if->sk_tx_ramend);
	SK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_ON);

	/* Configure BMUs */
	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_ONLINE);
	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_CURADDR_LO,
	    SK_RX_RING_ADDR(sc_if, 0));
	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_CURADDR_HI, 0);

	SK_IF_WRITE_4(sc_if, 1, SK_TXQS1_BMU_CSR, SK_TXBMU_ONLINE);
	SK_IF_WRITE_4(sc_if, 1, SK_TXQS1_CURADDR_LO,
	    SK_TX_RING_ADDR(sc_if, 0));
	SK_IF_WRITE_4(sc_if, 1, SK_TXQS1_CURADDR_HI, 0);

	/* Init descriptors */
	if (sk_init_rx_ring(sc_if) == ENOBUFS) {
		printf("%s: initialization failed: no "
		    "memory for rx buffers\n", sc_if->sk_dev.dv_xname);
		sk_stop(sc_if, 0);
		splx(s);
		return;
	}

	if (sk_init_tx_ring(sc_if) == ENOBUFS) {
		printf("%s: initialization failed: no "
		    "memory for tx buffers\n", sc_if->sk_dev.dv_xname);
		sk_stop(sc_if, 0);
		splx(s);
		return;
	}

	/* Configure interrupt handling */
	CSR_READ_4(sc, SK_ISSR);
	if (sc_if->sk_port == SK_PORT_A)
		sc->sk_intrmask |= SK_INTRS1;
	else
		sc->sk_intrmask |= SK_INTRS2;

	sc->sk_intrmask |= SK_ISR_EXTERNAL_REG;

	CSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);

	/* Start BMUs. */
	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_RX_START);

	if (SK_IS_GENESIS(sc)) {
		/* Enable XMACs TX and RX state machines */
		SK_XM_CLRBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_IGNPAUSE);
		SK_XM_SETBIT_2(sc_if, XM_MMUCMD,
		    XM_MMUCMD_TX_ENB|XM_MMUCMD_RX_ENB);
	}

	if (SK_IS_YUKON(sc)) {
		u_int16_t reg = SK_YU_READ_2(sc_if, YUKON_GPCR);
		reg |= YU_GPCR_TXEN | YU_GPCR_RXEN;
		SK_YU_WRITE_2(sc_if, YUKON_GPCR, reg);
	}

	/* Activate descriptor polling timer */
	SK_IF_WRITE_4(sc_if, 0, SK_DPT_TIMER_CTRL, SK_DPT_TCTL_START);
	/* start transfer of Tx descriptors */
	CSR_WRITE_4(sc, sc_if->sk_tx_bmu, SK_TXBMU_TX_START);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (SK_IS_YUKON(sc))
		timeout_add_sec(&sc_if->sk_tick_ch, 1);

	splx(s);
}

void
sk_stop(struct sk_if_softc *sc_if, int softonly)
{
	struct sk_softc		*sc = sc_if->sk_softc;
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
	bus_dmamap_t		dmamap;
	struct sk_txmap_entry	*dma;
	int			i;
	u_int32_t		val;

	DPRINTFN(2, ("sk_stop\n"));

	timeout_del(&sc_if->sk_tick_ch);

	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (!softonly) {
		/* stop Tx descriptor polling timer */
		SK_IF_WRITE_4(sc_if, 0, SK_DPT_TIMER_CTRL, SK_DPT_TCTL_STOP);
		/* stop transfer of Tx descriptors */
		CSR_WRITE_4(sc, sc_if->sk_tx_bmu, SK_TXBMU_TX_STOP);
		for (i = 0; i < SK_TIMEOUT; i++) {
			val = CSR_READ_4(sc, sc_if->sk_tx_bmu);
			if (!(val & SK_TXBMU_TX_STOP))
				break;
			DELAY(1);
		}
		if (i == SK_TIMEOUT) {
			printf("%s: cannot stop transfer of Tx descriptors\n",
			    sc_if->sk_dev.dv_xname);
		}
		/* stop transfer of Rx descriptors */
		SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_RX_STOP);
		for (i = 0; i < SK_TIMEOUT; i++) {
			val = SK_IF_READ_4(sc_if, 0, SK_RXQ1_BMU_CSR);
			if (!(val & SK_RXBMU_RX_STOP))
				break;
			DELAY(1);
		}
		if (i == SK_TIMEOUT) {
			printf("%s: cannot stop transfer of Rx descriptors\n",
			    sc_if->sk_dev.dv_xname);
		}

		if (sc_if->sk_phytype == SK_PHYTYPE_BCOM) {
			u_int32_t		val;

			/* Put PHY back into reset. */
			val = sk_win_read_4(sc, SK_GPIO);
			if (sc_if->sk_port == SK_PORT_A) {
				val |= SK_GPIO_DIR0;
				val &= ~SK_GPIO_DAT0;
			} else {
				val |= SK_GPIO_DIR2;
				val &= ~SK_GPIO_DAT2;
			}
			sk_win_write_4(sc, SK_GPIO, val);
		}

		/* Turn off various components of this interface. */
		SK_XM_SETBIT_2(sc_if, XM_GPIO, XM_GPIO_RESETMAC);
		switch (sc->sk_type) {
		case SK_GENESIS:
			SK_IF_WRITE_2(sc_if, 0, SK_TXF1_MACCTL,
			    SK_TXMACCTL_XMAC_RESET);
			SK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_RESET);
			break;
		case SK_YUKON:
		case SK_YUKON_LITE:
		case SK_YUKON_LP:
			SK_IF_WRITE_1(sc_if,0, SK_RXMF1_CTRL_TEST, SK_RFCTL_RESET_SET);
			SK_IF_WRITE_1(sc_if,0, SK_TXMF1_CTRL_TEST, SK_TFCTL_RESET_SET);
			break;
		}
		SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_OFFLINE);
		SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);
		SK_IF_WRITE_4(sc_if, 1, SK_TXQS1_BMU_CSR, SK_TXBMU_OFFLINE);
		SK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);
		SK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL, SK_TXARCTL_OFF);
		SK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);
		SK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);
		SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_OFF);
		SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_LINKSYNC_OFF);

		/* Disable interrupts */
		if (sc_if->sk_port == SK_PORT_A)
			sc->sk_intrmask &= ~SK_INTRS1;
		else
			sc->sk_intrmask &= ~SK_INTRS2;
		CSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);

		SK_XM_READ_2(sc_if, XM_ISR);
		SK_XM_WRITE_2(sc_if, XM_IMR, 0xFFFF);
	}

	/* Free RX and TX mbufs still in the queues. */
	for (i = 0; i < SK_RX_RING_CNT; i++) {
		if (sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf != NULL) {
			dmamap = sc_if->sk_cdata.sk_rx_map[i];
			bus_dmamap_sync(sc_if->sk_softc->sc_dmatag, dmamap, 0,
			    dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc_if->sk_softc->sc_dmatag, dmamap);
			m_freem(sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf);
			sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf = NULL;
		}
	}

	for (i = 0; i < SK_TX_RING_CNT; i++) {
		if (sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf != NULL) {
			m_freem(sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf);
			sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf = NULL;
			SIMPLEQ_INSERT_HEAD(&sc_if->sk_txmap_head,
			    sc_if->sk_cdata.sk_tx_map[i], link);
			sc_if->sk_cdata.sk_tx_map[i] = 0;
		}
	}

	while ((dma = SIMPLEQ_FIRST(&sc_if->sk_txmap_head))) {
		SIMPLEQ_REMOVE_HEAD(&sc_if->sk_txmap_head, link);
		bus_dmamap_destroy(sc->sc_dmatag, dma->dmamap);
		free(dma, M_DEVBUF, 0);
	}
}

struct cfattach skc_ca = {
	sizeof(struct sk_softc), skc_probe, skc_attach, skc_detach,
	skc_activate
};

struct cfdriver skc_cd = {
	0, "skc", DV_DULL
};

struct cfattach sk_ca = {
	sizeof(struct sk_if_softc), sk_probe, sk_attach, sk_detach,
	sk_activate
};

struct cfdriver sk_cd = {
	NULL, "sk", DV_IFNET
};

#ifdef SK_DEBUG
void
sk_dump_txdesc(struct sk_tx_desc *desc, int idx)
{
#define DESC_PRINT(X)					\
	if (X)						\
		printf("txdesc[%d]." #X "=%#x\n", idx, X);

	DESC_PRINT(letoh32(desc->sk_ctl));
	DESC_PRINT(letoh32(desc->sk_next));
	DESC_PRINT(letoh32(desc->sk_data_lo));
	DESC_PRINT(letoh32(desc->sk_data_hi));
	DESC_PRINT(letoh32(desc->sk_xmac_txstat));
	DESC_PRINT(letoh16(desc->sk_rsvd0));
	DESC_PRINT(letoh16(desc->sk_rsvd1));
#undef PRINT
}

void
sk_dump_bytes(const char *data, int len)
{
	int c, i, j;

	for (i = 0; i < len; i += 16) {
		printf("%08x  ", i);
		c = len - i;
		if (c > 16) c = 16;

		for (j = 0; j < c; j++) {
			printf("%02x ", data[i + j] & 0xff);
			if ((j & 0xf) == 7 && j > 0)
				printf(" ");
		}

		for (; j < 16; j++)
			printf("   ");
		printf("  ");

		for (j = 0; j < c; j++) {
			int ch = data[i + j] & 0xff;
			printf("%c", ' ' <= ch && ch <= '~' ? ch : ' ');
		}

		printf("\n");

		if (c < 16)
			break;
	}
}

void
sk_dump_mbuf(struct mbuf *m)
{
	int count = m->m_pkthdr.len;

	printf("m=%#lx, m->m_pkthdr.len=%#d\n", m, m->m_pkthdr.len);

	while (count > 0 && m) {
		printf("m=%#lx, m->m_data=%#lx, m->m_len=%d\n",
		    m, m->m_data, m->m_len);
		sk_dump_bytes(mtod(m, char *), m->m_len);

		count -= m->m_len;
		m = m->m_next;
	}
}
#endif
@


1.188
log
@handle 64bit dva in the tx path as well as the rx path.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.187 2017/06/01 23:17:01 dlg Exp $	*/
d540 2
a541 1
		rd->sk_rx_ring[i].sk_next = htole32(SK_RX_RING_ADDR(sc_if, nexti));
d588 2
a589 1
		rd->sk_tx_ring[i].sk_next = htole32(SK_TX_RING_ADDR(sc_if, nexti));
d650 3
a652 3
	r->sk_data_lo = htole32(dva);
	r->sk_data_hi = htole32(dva >> 32);
	r->sk_ctl = htole32(dmamap->dm_segs[0].ds_len | SK_RXSTAT);
d1434 2
a1435 2
		f->sk_data_lo = htole32(dva);
		f->sk_data_hi = htole32(dva >> 32);
d1441 1
a1441 1
		f->sk_ctl = htole32(sk_ctl);
d1604 2
a1605 1
		sk_ctl = letoh32(sc_if->sk_rdata->sk_rx_ring[cur].sk_ctl);
a1608 1
		cur_desc = &sc_if->sk_rdata->sk_rx_ring[cur];
d1620 2
a1621 2
		total_len = SK_RXBYTES(letoh32(cur_desc->sk_ctl));
		rxstat = letoh32(cur_desc->sk_xmac_rxstat);
d1666 1
a1666 1
		sk_ctl = letoh32(cur_tx->sk_ctl);
@


1.187
log
@reorder ops in sk_start to avoid possibly rolling back ifq_deq.

instead of checking for space after beggining to deq a packet, check
for space before committing to handling a packet. this means we
can use ifq_dequeue instead of ifq_deq_begin/commit/rollback.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.186 2017/01/22 10:17:38 dlg Exp $	*/
d621 1
d647 3
a649 2
	r->sk_data_lo = htole32(dmamap->dm_segs[0].ds_addr);
	r->sk_data_hi = htole32(((u_int64_t)dmamap->dm_segs[0].ds_addr) >> 32);
d1398 1
d1431 3
a1433 1
		f->sk_data_lo = htole32(txmap->dm_segs[i].ds_addr);
@


1.186
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.185 2017/01/08 18:08:14 visa Exp $	*/
d1408 4
a1411 4
#ifdef SK_DEBUG
	if (skdebug >= 2)
		sk_dump_mbuf(m_head);
#endif
d1413 7
a1419 9
	/*
	 * Start packing the mbufs in this chain into
	 * the fragment pointers. Stop when we run out
	 * of fragments or hit the end of the mbuf chain.
	 */
	if (bus_dmamap_load_mbuf(sc->sc_dmatag, txmap, m_head,
	    BUS_DMA_NOWAIT)) {
		DPRINTFN(2, ("sk_encap: dmamap failed\n"));
		return (ENOBUFS);
a1421 8
	if (txmap->dm_nsegs > (SK_TX_RING_CNT - sc_if->sk_cdata.sk_tx_cnt - 2)) {
		DPRINTFN(2, ("sk_encap: too few descriptors free\n"));
		bus_dmamap_unload(sc->sc_dmatag, txmap);
		return (ENOBUFS);
	}

	DPRINTFN(2, ("sk_encap: dm_nsegs=%d\n", txmap->dm_nsegs));

d1483 1
a1483 1
	int			pkts = 0;
d1487 8
a1494 2
	while (sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf == NULL) {
		m_head = ifq_deq_begin(&ifp->if_snd);
d1504 2
a1505 3
			ifq_deq_rollback(&ifp->if_snd, m_head);
			ifq_set_oactive(&ifp->if_snd);
			break;
a1508 2
		ifq_deq_commit(&ifp->if_snd, m_head);
		pkts++;
d1518 2
d1521 1
a1521 1
	if (pkts == 0)
d1525 2
a1526 3
	if (idx != sc_if->sk_cdata.sk_tx_prod) {
		sc_if->sk_cdata.sk_tx_prod = idx;
		CSR_WRITE_4(sc, sc_if->sk_tx_bmu, SK_TXBMU_TX_START);
d1528 2
a1529 3
		/* Set a timeout in case the chip goes out to lunch. */
		ifp->if_timer = SK_TX_TIMEOUT;
	}
@


1.185
log
@Use a macro for the Tx timeout value.

OK deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.184 2016/04/13 10:34:32 mpi Exp $	*/
a1674 2
		if (sk_ctl & SK_TXCTL_LASTFRAG)
			ifp->if_opackets++;
@


1.184
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.183 2015/11/25 03:09:59 dlg Exp $	*/
d1535 1
a1535 1
		ifp->if_timer = 5;
d1694 1
a1694 1
	ifp->if_timer = sc_if->sk_cdata.sk_tx_cnt > 0 ? 5 : 0;
@


1.183
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.182 2015/11/24 17:11:39 mpi Exp $	*/
a997 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.182
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.181 2015/11/24 13:33:17 mpi Exp $	*/
d1510 1
a1510 1
			ifp->if_flags |= IFF_OACTIVE;
d1698 1
a1698 1
		ifp->if_flags &= ~IFF_OACTIVE;
d2399 1
a2399 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2421 2
a2422 1
	ifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);
@


1.181
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.180 2015/11/20 03:35:23 dlg Exp $	*/
a102 1
#include <net/if_dl.h>
@


1.180
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.179 2015/11/14 17:54:57 mpi Exp $	*/
a103 1
#include <net/if_types.h>
@


1.179
log
@Do not include <net/if_vlan_var.h> when it's not necessary.

Because of the VLAN hacks in mpw(4) this file still contains the definition
of "struct ifvlan" which depends on <sys/refcnt.h> which in turns pull
<sys/atomic.h>...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.178 2015/10/25 13:04:28 mpi Exp $	*/
d1501 1
a1501 1
		IFQ_POLL(&ifp->if_snd, m_head);
d1511 1
d1517 1
a1517 1
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.178
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.177 2015/07/19 06:28:12 yuo Exp $	*/
a109 1
#include <net/if_vlan_var.h>
@


1.177
log
@use standardized register definition in mii.h rather than each
specific driver definition.

no logical change.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.176 2015/06/24 09:40:54 mpi Exp $	*/
a689 1
	struct ifaddr *ifa = (struct ifaddr *) data;
a700 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc_if->arpcom, ifa);
@


1.176
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.175 2015/04/30 09:25:13 mpi Exp $	*/
d116 1
d1989 1
a1989 1
		    SK_PHYADDR_BCOM, BRGPHY_MII_BMCR, BRGPHY_BMCR_RESET);
@


1.175
log
@Convert to if_input(), tweak and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.174 2015/03/14 03:38:48 jsg Exp $	*/
a1641 1
		ifp->if_ipackets++;
@


1.174
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.173 2014/12/22 02:28:52 tedu Exp $	*/
d1590 1
a1638 1
		m->m_pkthdr.rcvif = ifp;
d1641 1
a1642 8

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

		/* pass it on. */
		ether_input_mbuf(ifp, m);
d1647 2
@


1.173
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.172 2014/08/20 03:29:35 dlg Exp $	*/
a115 1
#include <dev/mii/mii.h>
@


1.172
log
@brad said i had some whitespace screwups in my previous diff. this cleans
them up and the others i found in this file.

no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.171 2014/08/20 00:50:45 dlg Exp $	*/
a105 1
#ifdef INET
a107 1
#endif
a701 1
#ifdef INET
a703 1
#endif
@


1.171
log
@replace sks jumbo allocator with MCLGETI. the system provides jumbos in
the right shape now, we dont have to do it by hand all over the place
any more.

rework the rxr ring management to use if_rxring while here.

largely based on if_sk.c r1.152 and if_skvar.h r1.4 by kettenis.
tested by me on:

skc0 at pci3 dev 11 function 0 "Schneider & Koch SK-98xx" rev 0x12, GEnesis (0x0): apic 3 int 5
sk0 at skc0 port A: address 00:00:5a:99:8a:ec
xmphy0 at sk0 phy 0: XMAC II Gigabit PHY, rev. 2

and this from ian mcwilliam

skc0 at pci0 dev 9 function 0 "D-Link DGE-530T B1" rev 0x11, Yukon Lite (0x9): apic 2 int 17
sk0 at skc0 port A: address 00:17:9a:ba:b5:39
eephy0 at sk0 phy 0: 88E1011 Gigabit PHY, rev. 5

tested by brad@@ too
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.170 2014/07/22 13:12:11 mpi Exp $	*/
d88 1
a88 1
 
d338 1
a338 1
			     phy, reg));
d342 3
a344 3
        SK_YU_WRITE_2(sc_if, YUKON_SMICR, YU_SMICR_PHYAD(phy) |
		      YU_SMICR_REGAD(reg) | YU_SMICR_OP_READ);
        
d354 1
a354 1
		       sc_if->sk_dev.dv_xname);
d357 1
a357 1
        
d359 1
a359 1
		     SK_TIMEOUT));
d361 1
a361 1
        val = SK_YU_READ_2(sc_if, YUKON_SMIDR);
d364 1
a364 1
		     phy, reg, val));
d376 1
a376 1
		     phy, reg, val));
d380 1
a380 1
		      YU_SMICR_REGAD(reg) | YU_SMICR_OP_WRITE);
d396 1
a396 1
		     SK_YU_READ_2(((struct sk_if_softc *)dev), YUKON_GPCR)));
d631 1
a631 1
        m->m_len = m->m_pkthdr.len = SK_JLEN;
d794 1
a794 1
		     CSR_READ_2(sc, SK_LINK_CTRL)));
d925 3
a927 3
		     "           tx_ramstart=%#x tx_ramend=%#x\n",
		     sc_if->sk_rx_ramstart, sc_if->sk_rx_ramend,
		     sc_if->sk_tx_ramstart, sc_if->sk_tx_ramend));
d970 3
a972 2
	if (bus_dmamem_map(sc->sc_dmatag, &sc_if->sk_ring_seg, sc_if->sk_ring_nseg,
	    sizeof(struct sk_ring_data), &kva, BUS_DMA_NOWAIT)) {
d974 1
a974 1
		       (ulong)sizeof(struct sk_ring_data));
d979 1
a979 1
            &sc_if->sk_ring_map)) {
d988 1
a988 1
        sc_if->sk_rdata = (struct sk_ring_data *)kva;
d1264 1
a1264 2
		     sc->sk_ramsize, sc->sk_ramsize / 1024,
		     sc->sk_rboff));
d1763 1
a1763 1
	struct sk_if_softc *sc_if = xsc_if;  
d1960 1
a1960 1
	struct sk_bcom_hack     bhack[] = {
d2114 1
a2114 1
		     CSR_READ_4(sc_if->sk_softc, SK_CSR)));
d2162 1
a2162 1
		      SK_GMAC_PAUSE_ON | SK_GMAC_RESET_CLEAR);
d2165 1
a2165 1
		     SK_IF_READ_4(sc_if, 0, SK_GMAC_CTRL)));
d2178 1
a2178 1
        reg |= YU_PAR_MIB_CLR;
d2185 1
a2185 1
        reg &= ~YU_PAR_MIB_CLR;
d2195 1
a2195 1
		      YU_TPR_JAM_IPG(0xb) | YU_TPR_JAM2DATA_IPG(0x1a) );
d2200 1
a2200 2
		      YU_SMR_MFL_VLAN | YU_SMR_MFL_JUMBO |
		      YU_SMR_IPG_DATA(0x1e));
d2206 3
a2208 3
		SK_YU_WRITE_2(sc_if, YUKON_SAL1 + i * 4, 
			      sc_if->arpcom.ac_enaddr[i * 2] |
			      sc_if->arpcom.ac_enaddr[i * 2 + 1] << 8);
d2277 1
a2277 1
			      SK_LINKLED_LINKSYNC_ON);
d2281 1
a2281 1
			      SK_RXLEDCTL_COUNTER_START);
d2285 1
a2285 1
			      SK_TXLEDCTL_COUNTER_START);
d2361 1
a2361 1
            SK_TX_RING_ADDR(sc_if, 0));
d2399 1
a2399 1
			       XM_MMUCMD_TX_ENB|XM_MMUCMD_RX_ENB);
d2449 1
a2449 1
		if (i == SK_TIMEOUT)
d2451 2
a2452 1
			      sc_if->sk_dev.dv_xname);
d2461 1
a2461 1
		if (i == SK_TIMEOUT)
d2463 2
a2464 1
			      sc_if->sk_dev.dv_xname);
d2486 1
a2486 1
				      SK_TXMACCTL_XMAC_RESET);
d2569 2
a2570 3
	if (X)					\
		printf("txdesc[%d]." #X "=%#x\n",	\
		       idx, X);
d2623 1
a2623 1
		       m, m->m_data, m->m_len);
@


1.170
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.169 2014/07/12 18:48:52 tedu Exp $	*/
d156 1
a156 4
int sk_newbuf(struct sk_if_softc *, int, struct mbuf *, bus_dmamap_t);
int sk_alloc_jumbo_mem(struct sk_if_softc *);
void *sk_jalloc(struct sk_if_softc *);
void sk_jfree(caddr_t, u_int, void *);
d159 1
a547 9
	for (i = 0; i < SK_RX_RING_CNT; i++) {
		if (sk_newbuf(sc_if, i, NULL,
		    sc_if->sk_cdata.sk_rx_jumbo_map) == ENOBUFS) {
			printf("%s: failed alloc of %dth mbuf\n",
			    sc_if->sk_dev.dv_xname, i);
			return (ENOBUFS);
		}
	}

d551 4
d558 13
d618 1
a618 2
sk_newbuf(struct sk_if_softc *sc_if, int i, struct mbuf *m,
	  bus_dmamap_t dmamap)
d620 1
a620 1
	struct mbuf		*m_new = NULL;
d623 3
d627 3
a629 6
	if (m == NULL) {
		caddr_t buf = NULL;

		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return (ENOBUFS);
d631 2
a632 8
		/* Allocate the jumbo buffer */
		buf = sk_jalloc(sc_if);
		if (buf == NULL) {
			m_freem(m_new);
			DPRINTFN(1, ("%s jumbo allocation failed -- packet "
			    "dropped!\n", sc_if->arpcom.ac_if.if_xname));
			return (ENOBUFS);
		}
d634 2
a635 14
		/* Attach the buffer to the mbuf */
		m_new->m_len = m_new->m_pkthdr.len = SK_JLEN;
		MEXTADD(m_new, buf, SK_JLEN, 0, sk_jfree, sc_if);
	} else {
		/*
	 	 * We're re-using a previously allocated mbuf;
		 * be sure to re-init pointers and lengths to
		 * default values.
		 */
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = SK_JLEN;
		m_new->m_data = m_new->m_ext.ext_buf;
	}
	m_adj(m_new, ETHER_ALIGN);
d637 4
a640 32
	c = &sc_if->sk_cdata.sk_rx_chain[i];
	r = c->sk_desc;
	c->sk_mbuf = m_new;
	r->sk_data_lo = htole32(dmamap->dm_segs[0].ds_addr +
	    (((vaddr_t)m_new->m_data
             - (vaddr_t)sc_if->sk_cdata.sk_jumbo_buf)));
	r->sk_ctl = htole32(SK_JLEN | SK_RXSTAT);

	SK_CDRXSYNC(sc_if, i, BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);

	return (0);
}

/*
 * Memory management for jumbo frames.
 */

int
sk_alloc_jumbo_mem(struct sk_if_softc *sc_if)
{
	struct sk_softc		*sc = sc_if->sk_softc;
	caddr_t			ptr, kva;
	bus_dma_segment_t	seg;
	int		i, rseg, state, error;
	struct sk_jpool_entry   *entry;

	state = error = 0;

	/* Grab a big chunk o' storage. */
	if (bus_dmamem_alloc(sc->sc_dmatag, SK_JMEM, PAGE_SIZE, 0,
			     &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
		printf(": can't alloc rx buffers");
d644 2
a645 27
	state = 1;
	if (bus_dmamem_map(sc->sc_dmatag, &seg, rseg, SK_JMEM, &kva,
			   BUS_DMA_NOWAIT)) {
		printf(": can't map dma buffers (%d bytes)", SK_JMEM);
		error = ENOBUFS;
		goto out;
	}

	state = 2;
	if (bus_dmamap_create(sc->sc_dmatag, SK_JMEM, 1, SK_JMEM, 0,
	    BUS_DMA_NOWAIT, &sc_if->sk_cdata.sk_rx_jumbo_map)) {
		printf(": can't create dma map");
		error = ENOBUFS;
		goto out;
	}

	state = 3;
	if (bus_dmamap_load(sc->sc_dmatag, sc_if->sk_cdata.sk_rx_jumbo_map,
			    kva, SK_JMEM, NULL, BUS_DMA_NOWAIT)) {
		printf(": can't load dma map");
		error = ENOBUFS;
		goto out;
	}

	state = 4;
	sc_if->sk_cdata.sk_jumbo_buf = (caddr_t)kva;
	DPRINTFN(1,("sk_jumbo_buf = 0x%08X\n", sc_if->sk_cdata.sk_jumbo_buf));
d647 2
a648 2
	LIST_INIT(&sc_if->sk_jfree_listhead);
	LIST_INIT(&sc_if->sk_jinuse_listhead);
d650 4
a653 38
	/*
	 * Now divide it up into 9K pieces and save the addresses
	 * in an array.
	 */
	ptr = sc_if->sk_cdata.sk_jumbo_buf;
	for (i = 0; i < SK_JSLOTS; i++) {
		sc_if->sk_cdata.sk_jslots[i] = ptr;
		ptr += SK_JLEN;
		entry = malloc(sizeof(struct sk_jpool_entry),
		    M_DEVBUF, M_NOWAIT);
		if (entry == NULL) {
			sc_if->sk_cdata.sk_jumbo_buf = NULL;
			printf(": no memory for jumbo buffer queue!");
			error = ENOBUFS;
			goto out;
		}
		entry->slot = i;
		LIST_INSERT_HEAD(&sc_if->sk_jfree_listhead,
				 entry, jpool_entries);
	}
out:
	if (error != 0) {
		switch (state) {
		case 4:
			bus_dmamap_unload(sc->sc_dmatag,
			    sc_if->sk_cdata.sk_rx_jumbo_map);
		case 3:
			bus_dmamap_destroy(sc->sc_dmatag,
			    sc_if->sk_cdata.sk_rx_jumbo_map);
		case 2:
			bus_dmamem_unmap(sc->sc_dmatag, kva, SK_JMEM);
		case 1:
			bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
			break;
		default:
			break;
		}
	}
d655 1
a655 2
	return (error);
}
d657 2
a658 7
/*
 * Allocate a jumbo buffer.
 */
void *
sk_jalloc(struct sk_if_softc *sc_if)
{
	struct sk_jpool_entry   *entry;
d660 1
a660 39
	entry = LIST_FIRST(&sc_if->sk_jfree_listhead);

	if (entry == NULL)
		return (NULL);

	LIST_REMOVE(entry, jpool_entries);
	LIST_INSERT_HEAD(&sc_if->sk_jinuse_listhead, entry, jpool_entries);
	return (sc_if->sk_cdata.sk_jslots[entry->slot]);
}

/*
 * Release a jumbo buffer.
 */
void
sk_jfree(caddr_t buf, u_int size, void	*arg)
{
	struct sk_jpool_entry *entry;
	struct sk_if_softc *sc;
	int i;

	/* Extract the softc struct pointer. */
	sc = (struct sk_if_softc *)arg;

	if (sc == NULL)
		panic("sk_jfree: can't find softc pointer!");

	/* calculate the slot this buffer belongs to */
	i = ((vaddr_t)buf
	     - (vaddr_t)sc->sk_cdata.sk_jumbo_buf) / SK_JLEN;

	if ((i < 0) || (i >= SK_JSLOTS))
		panic("sk_jfree: asked to free buffer that we don't manage!");

	entry = LIST_FIRST(&sc->sk_jinuse_listhead);
	if (entry == NULL)
		panic("sk_jfree: buffer not in use!");
	entry->slot = i;
	LIST_REMOVE(entry, jpool_entries);
	LIST_INSERT_HEAD(&sc->sk_jfree_listhead, entry, jpool_entries);
d728 6
d862 1
a862 1
	int i;
d989 8
a996 4
	/* Try to allocate memory for jumbo buffers. */
	if (sk_alloc_jumbo_mem(sc_if)) {
		printf(": jumbo buffer allocation failed\n");
		goto fail_3;
d1062 4
d1067 4
d1072 1
a1072 1
	bus_dmamem_unmap(sc->sc_dmatag, kva, sizeof(struct sk_ring_data));
a1073 2
	bus_dmamem_free(sc->sc_dmatag, &sc_if->sk_ring_seg, sc_if->sk_ring_nseg);
fail_3:
d1593 1
d1597 1
a1597 1
	int			i, cur, total_len = 0;
d1603 2
a1604 5
	i = sc_if->sk_cdata.sk_rx_prod;

	for (;;) {
		cur = i;

d1609 6
a1614 5
		sk_ctl = letoh32(sc_if->sk_rdata->sk_rx_ring[i].sk_ctl);
		if ((sk_ctl & SK_RXCTL_OWN) != 0) {
			/* Invalidate the descriptor -- it's not ready yet */
			SK_CDRXSYNC(sc_if, cur, BUS_DMASYNC_PREREAD);
			sc_if->sk_cdata.sk_rx_prod = i;
a1615 1
		}
a1616 1
		cur_rx = &sc_if->sk_cdata.sk_rx_chain[cur];
d1618 1
a1618 1
		dmamap = sc_if->sk_cdata.sk_rx_jumbo_map;
d1622 1
a1623 1
		rxstat = letoh32(cur_desc->sk_xmac_rxstat);
d1626 3
d1630 1
a1630 2

		SK_INC(i, SK_RX_RING_CNT);
d1639 1
a1639 1
			sk_newbuf(sc_if, cur, m, dmamap);
d1643 2
a1644 21
		/*
		 * Try to allocate a new jumbo buffer. If that
		 * fails, copy the packet to mbufs and put the
		 * jumbo buffer back in the ring so it can be
		 * re-used. If allocating mbufs fails, then we
		 * have to drop the packet.
		 */
		if (sk_newbuf(sc_if, cur, NULL, dmamap) == ENOBUFS) {
			struct mbuf		*m0;
			m0 = m_devget(mtod(m, char *), total_len, ETHER_ALIGN,
			    ifp);
			sk_newbuf(sc_if, cur, m, dmamap);
			if (m0 == NULL) {
				ifp->if_ierrors++;
				continue;
			}
			m = m0;
		} else {
			m->m_pkthdr.rcvif = ifp;
			m->m_pkthdr.len = m->m_len = total_len;
		}
d1656 3
d2428 1
d2519 4
@


1.169
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.168 2014/04/19 18:29:39 henning Exp $	*/
a107 4
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netinet/tcp.h>
@


1.168
log
@kill checksum offloading in sk.
it was RX only, nothing on the TX side
rather complex, might eat up (or more) offloading benefits in many cases
the hardware miscomputes the cksums sometimes, so we don't trust it
claiming a cksum is bad and re-do the cksum verification in sw then...
(but we trust it to not mark bad ones good? hmmmmmmmmm.)
diff was on tech for 3 months, nobody disagreed, everybody who spoke up
agrees or doesn't care.
pretty exactly a revert of the cksum offloading addition years ago, tested
by several, the only report i quickly find now is from David Higgs <higgsd
at gmail dot com>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.166 2013/08/21 05:21:44 dlg Exp $	*/
d2685 1
a2685 1
		free(dma, M_DEVBUF);
@


1.167
log
@Sync activate code sequnces to if_msk.c as much as possible, in case
one of these is ever found in a suspend/hibernate system.
@
text
@a182 1
void sk_rxcsum(struct ifnet *, struct mbuf *, const u_int16_t, const u_int16_t);
a551 3
		rd->sk_rx_ring[i].sk_csum1_start = htole16(ETHER_HDR_LEN);
		rd->sk_rx_ring[i].sk_csum2_start = htole16(ETHER_HDR_LEN +
		    sizeof(struct ip));
a1730 1
	u_int16_t		csum1, csum2;
a1762 3
		csum1 = letoh16(sc_if->sk_rdata->sk_rx_ring[i].sk_csum1);
		csum2 = letoh16(sc_if->sk_rdata->sk_rx_ring[i].sk_csum2);

a1799 2
		sk_rxcsum(ifp, m, csum1, csum2);

a1810 88
sk_rxcsum(struct ifnet *ifp, struct mbuf *m, const u_int16_t csum1, const u_int16_t csum2)
{
	struct ether_header *eh;
	struct ip *ip;
	u_int8_t *pp;
	int hlen, len, plen;
	u_int16_t iph_csum, ipo_csum, ipd_csum, csum;

	pp = mtod(m, u_int8_t *);
	plen = m->m_pkthdr.len;
	if (plen < sizeof(*eh))
		return;
	eh = (struct ether_header *)pp;
	iph_csum = in_cksum_addword(csum1, (~csum2 & 0xffff));

	if (eh->ether_type == htons(ETHERTYPE_VLAN)) {
		u_int16_t *xp = (u_int16_t *)pp;

		xp = (u_int16_t *)pp;
		if (xp[1] != htons(ETHERTYPE_IP))
			return;
		iph_csum = in_cksum_addword(iph_csum, (~xp[0] & 0xffff));
		iph_csum = in_cksum_addword(iph_csum, (~xp[1] & 0xffff));
		xp = (u_int16_t *)(pp + sizeof(struct ip));
		iph_csum = in_cksum_addword(iph_csum, xp[0]);
		iph_csum = in_cksum_addword(iph_csum, xp[1]);
		pp += EVL_ENCAPLEN;
	} else if (eh->ether_type != htons(ETHERTYPE_IP))
		return;

	pp += sizeof(*eh);
	plen -= sizeof(*eh);

	ip = (struct ip *)pp;

	if (ip->ip_v != IPVERSION)
		return;

	hlen = ip->ip_hl << 2;
	if (hlen < sizeof(struct ip))
		return;
	if (hlen > ntohs(ip->ip_len))
		return;

	/* Don't deal with truncated or padded packets. */
	if (plen != ntohs(ip->ip_len))
		return;

	len = hlen - sizeof(struct ip);
	if (len > 0) {
		u_int16_t *p;

		p = (u_int16_t *)(ip + 1);
		ipo_csum = 0;
		for (ipo_csum = 0; len > 0; len -= sizeof(*p), p++)
			ipo_csum = in_cksum_addword(ipo_csum, *p);
		iph_csum = in_cksum_addword(iph_csum, ipo_csum);
		ipd_csum = in_cksum_addword(csum2, (~ipo_csum & 0xffff));
	} else
		ipd_csum = csum2;

	if (iph_csum != 0xffff)
		return;
	m->m_pkthdr.csum_flags |= M_IPV4_CSUM_IN_OK;

	if (ip->ip_off & htons(IP_MF | IP_OFFMASK))
		return;                 /* ip frag, we're done for now */

	pp += hlen;

	/* Only know checksum protocol for udp/tcp */
	if (ip->ip_p == IPPROTO_UDP) {
		struct udphdr *uh = (struct udphdr *)pp;

		if (uh->uh_sum == 0)    /* udp with no checksum */
			return;
	} else if (ip->ip_p != IPPROTO_TCP)
		return;

	csum = in_cksum_phdr(ip->ip_src.s_addr, ip->ip_dst.s_addr,
	    htonl(ntohs(ip->ip_len) - hlen + ip->ip_p) + ipd_csum);
	if (csum == 0xffff) {
		m->m_pkthdr.csum_flags |= (ip->ip_p == IPPROTO_TCP) ?
		    M_TCP_CSUM_IN_OK : M_UDP_CSUM_IN_OK;
	}
}

void
a2721 3
	DESC_PRINT(letoh16(desc->sk_csum_startval));
	DESC_PRINT(letoh16(desc->sk_csum_startpos));
	DESC_PRINT(letoh16(desc->sk_csum_writepos));
@


1.166
log
@get rid of the copy argument in m_devget that let you provide an
alternative to bcopy since noone uses it.

while there use memcpy instead of bcopy because we know the memory cannot
overlap.

ok henning@@ matthew@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.165 2013/08/07 01:06:37 bluhm Exp $	*/
d136 1
d140 1
d159 1
a159 1
void sk_reset(struct sk_softc *);
d164 1
d920 1
a920 1
sk_reset(struct sk_softc *sc)
d924 1
a924 1
	DPRINTFN(2, ("sk_reset\n"));
d969 1
d1081 10
a1090 10
			case SK_PHYTYPE_XMAC:
				sc_if->sk_phyaddr = SK_PHYADDR_XMAC;
				break;
			case SK_PHYTYPE_BCOM:
				sc_if->sk_phyaddr = SK_PHYADDR_BCOM;
				break;
			default:
				printf("%s: unsupported PHY type: %d\n",
				    sc->sk_dev.dv_xname, sc_if->sk_phytype);
				return;
d1154 2
a1155 14
	/*
	 * Do miibus setup.
	 */
	switch (sc->sk_type) {
	case SK_GENESIS:
		sk_init_xmac(sc_if);
		break;
	case SK_YUKON:
	case SK_YUKON_LITE:
	case SK_YUKON_LP:
		sk_init_yukon(sc_if);
		break;
	default:
		printf(": unknown device type %d\n", sc->sk_type);
d1216 21
d1269 20
d1363 1
a1363 1
	sk_reset(sc);
d1517 18
d2788 2
a2789 1
	sizeof(struct sk_softc), skc_probe, skc_attach, skc_detach
d2797 2
a2798 1
	sizeof(struct sk_if_softc), sk_probe, sk_attach, sk_detach
@


1.165
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.164 2013/03/07 06:13:31 brad Exp $	*/
d1743 1
a1743 1
			    ifp, NULL);
@


1.164
log
@Rewrite the receive filter handling code and cleanup the ioctl bits.

ok chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.163 2012/11/29 21:10:32 brad Exp $	*/
a108 1
#include <netinet/in_var.h>
@


1.163
log
@Remove setting an initial assumed baudrate upon driver attach which is not
necessarily correct, there might not even be a link when attaching.

ok mikeb@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.162 2012/10/18 21:44:21 deraadt Exp $	*/
a173 2
u_int32_t sk_xmac_hash(caddr_t);
u_int32_t sk_yukon_hash(caddr_t);
d175 4
a178 2
void sk_setmulti(struct sk_if_softc *);
void sk_setpromisc(struct sk_if_softc *);
a403 18
u_int32_t
sk_xmac_hash(caddr_t addr)
{
	u_int32_t crc;

	crc = ether_crc32_le(addr, ETHER_ADDR_LEN);
	return (~crc & ((1 << SK_HASH_BITS) - 1));
}

u_int32_t
sk_yukon_hash(caddr_t addr)
{
	u_int32_t crc;

	crc = ether_crc32_be(addr, ETHER_ADDR_LEN);
	return (crc & ((1 << SK_HASH_BITS) - 1));
}

d415 1
a415 1
sk_setmulti(struct sk_if_softc *sc_if)
d418 11
a428 3
	struct ifnet *ifp= &sc_if->arpcom.ac_if;
	u_int32_t hashes[2] = { 0, 0 };
	int h, i;
d432 1
d434 6
d441 4
a444 5
	/* First, zot all the existing filters. */
	switch(sc->sk_type) {
	case SK_GENESIS:
		for (i = 1; i < XM_RXFILT_MAX; i++)
			sk_setfilt(sc_if, (caddr_t)&dummy, i);
d446 3
a448 12
		SK_XM_WRITE_4(sc_if, XM_MAR0, 0);
		SK_XM_WRITE_4(sc_if, XM_MAR2, 0);
		break;
	case SK_YUKON:
	case SK_YUKON_LITE:
	case SK_YUKON_LP:
		SK_YU_WRITE_2(sc_if, YUKON_MCAH1, 0);
		SK_YU_WRITE_2(sc_if, YUKON_MCAH2, 0);
		SK_YU_WRITE_2(sc_if, YUKON_MCAH3, 0);
		SK_YU_WRITE_2(sc_if, YUKON_MCAH4, 0);
		break;
	}
d450 7
a456 5
	/* Now program new ones. */
allmulti:
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
		hashes[0] = 0xFFFFFFFF;
		hashes[1] = 0xFFFFFFFF;
d458 4
a461 2
		i = 1;
		/* First find the tail of the list. */
d464 7
a470 31
			if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
				 ETHER_ADDR_LEN)) {
				ifp->if_flags |= IFF_ALLMULTI;
				goto allmulti;
			}
			/*
			 * Program the first XM_RXFILT_MAX multicast groups
			 * into the perfect filter. For all others,
			 * use the hash table.
			 */
			if (SK_IS_GENESIS(sc) && i < XM_RXFILT_MAX) {
				sk_setfilt(sc_if, enm->enm_addrlo, i);
				i++;
			}
			else {
				switch(sc->sk_type) {
				case SK_GENESIS:
					h = sk_xmac_hash(enm->enm_addrlo);
					break;

				case SK_YUKON:
				case SK_YUKON_LITE:
				case SK_YUKON_LP:
					h = sk_yukon_hash(enm->enm_addrlo);
					break;
				}
				if (h < 32)
					hashes[0] |= (1 << h);
				else
					hashes[1] |= (1 << (h - 32));
			}
d476 3
a478 16
	switch(sc->sk_type) {
	case SK_GENESIS:
		SK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_USE_HASH|
			       XM_MODE_RX_USE_PERFECT);
		SK_XM_WRITE_4(sc_if, XM_MAR0, hashes[0]);
		SK_XM_WRITE_4(sc_if, XM_MAR2, hashes[1]);
		break;
	case SK_YUKON:
	case SK_YUKON_LITE:
	case SK_YUKON_LP:
		SK_YU_WRITE_2(sc_if, YUKON_MCAH1, hashes[0] & 0xffff);
		SK_YU_WRITE_2(sc_if, YUKON_MCAH2, (hashes[0] >> 16) & 0xffff);
		SK_YU_WRITE_2(sc_if, YUKON_MCAH3, hashes[1] & 0xffff);
		SK_YU_WRITE_2(sc_if, YUKON_MCAH4, (hashes[1] >> 16) & 0xffff);
		break;
	}
d482 1
a482 1
sk_setpromisc(struct sk_if_softc *sc_if)
d484 16
a499 2
	struct sk_softc	*sc = sc_if->sk_softc;
	struct ifnet *ifp= &sc_if->arpcom.ac_if;
d501 2
a502 2
	switch(sc->sk_type) {
	case SK_GENESIS:
d504 1
a504 1
			SK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_PROMISC);
d506 18
a523 11
			SK_XM_CLRBIT_4(sc_if, XM_MODE, XM_MODE_RX_PROMISC);
		break;
	case SK_YUKON:
	case SK_YUKON_LITE:
	case SK_YUKON_LP:
		if (ifp->if_flags & IFF_PROMISC) {
			SK_YU_CLRBIT_2(sc_if, YUKON_RCR,
			    YU_RCR_UFLEN | YU_RCR_MUFLEN);
		} else {
			SK_YU_SETBIT_2(sc_if, YUKON_RCR,
			    YU_RCR_UFLEN | YU_RCR_MUFLEN);
a524 1
		break;
d526 6
d857 1
a857 1
#endif /* INET */
d862 4
a865 9
			if (ifp->if_flags & IFF_RUNNING &&
			    (ifp->if_flags ^ sc_if->sk_if_flags)
			     & IFF_PROMISC) {
				sk_setpromisc(sc_if);
				sk_setmulti(sc_if);
			} else {
				if (!(ifp->if_flags & IFF_RUNNING))
					sk_init(sc_if);
			}
a869 1
		sc_if->sk_if_flags = ifp->if_flags;
d884 1
a884 1
			sk_setmulti(sc_if);
a2156 1
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
a2224 6
	SK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_USE_STATION);

	if (ifp->if_flags & IFF_BROADCAST)
		SK_XM_CLRBIT_4(sc_if, XM_MODE, XM_MODE_RX_NOBROAD);
	else
		SK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_NOBROAD);
d2258 2
a2259 5
	/* Set promiscuous mode */
	sk_setpromisc(sc_if);

	/* Set multicast filter */
	sk_setmulti(sc_if);
d2415 1
a2415 4
	/* Set promiscuous mode */
	sk_setpromisc(sc_if);

	/* Set multicast filter */
d2417 1
a2417 1
	sk_setmulti(sc_if);
@


1.162
log
@Convert a number of old private copies of code which predates
pci_set_powerstate() to using it instead.  Many of these chunks of code had
bugs in them, especially missing delay() calls.  Some of them were doing
things our PCI subsystem is now responsible for handling.  If you have
any of the affected devices, please keep an eye out for regressions.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.161 2012/02/24 06:19:00 guenther Exp $	*/
a1169 1
	ifp->if_baudrate = 1000000000;
@


1.161
log
@Correct the spelling of "transferred" and "transferring"

from Tobias Ulmer (tobiasu at tmux.org); ok jmc@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.160 2011/06/22 16:44:27 tedu Exp $	*/
d1307 1
a1307 1
	pcireg_t command, memtype;
d1315 1
a1315 29
	/*
	 * Handle power management nonsense.
	 */
	command = pci_conf_read(pc, pa->pa_tag, SK_PCI_CAPID) & 0x000000FF;

	if (command == 0x01) {
		command = pci_conf_read(pc, pa->pa_tag, SK_PCI_PWRMGMTCTRL);
		if (command & SK_PSTATE_MASK) {
			u_int32_t		iobase, membase, irq;

			/* Save important PCI config data. */
			iobase = pci_conf_read(pc, pa->pa_tag, SK_PCI_LOIO);
			membase = pci_conf_read(pc, pa->pa_tag, SK_PCI_LOMEM);
			irq = pci_conf_read(pc, pa->pa_tag, SK_PCI_INTLINE);

			/* Reset the power state. */
			printf("%s chip is in D%d power mode "
			    "-- setting to D0\n", sc->sk_dev.dv_xname,
			    command & SK_PSTATE_MASK);
			command &= 0xFFFFFFFC;
			pci_conf_write(pc, pa->pa_tag,
			    SK_PCI_PWRMGMTCTRL, command);

			/* Restore PCI config data. */
			pci_conf_write(pc, pa->pa_tag, SK_PCI_LOIO, iobase);
			pci_conf_write(pc, pa->pa_tag, SK_PCI_LOMEM, membase);
			pci_conf_write(pc, pa->pa_tag, SK_PCI_INTLINE, irq);
		}
	}
@


1.160
log
@kill a few more casts that aren't helpful.  ok krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.159 2011/04/03 15:36:02 jasper Exp $	*/
d2305 1
a2305 1
	 * case the XMAC will start transfering frames out of the
@


1.159
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.158 2010/09/20 07:40:38 deraadt Exp $	*/
d561 1
a561 2
	bzero((char *)rd->sk_rx_ring,
	    sizeof(struct sk_rx_desc) * SK_RX_RING_CNT);
d601 1
a601 1
	bzero((char *)sc_if->sk_rdata->sk_tx_ring,
@


1.158
log
@Stop doing shutdown hooks in network drivers where possible.  We already
take all interfaces down, via their xxstop routines.  Claudio and I have
verified that none of the shutdown hooks do much extra beyond what xxstop
was already doing; it is largely a pile of junk.
ok claudio, some early comments by sthen; also read by matthew, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.157 2010/05/19 15:27:35 oga Exp $	*/
d938 1
a938 1
	    sizeof(skc_devices)/sizeof(skc_devices[0])));
@


1.157
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.156 2009/10/17 21:40:43 martynas Exp $	*/
a136 1
void skc_shutdown(void *);
a1238 2
	sc_if->sk_sdhook = shutdownhook_establish(skc_shutdown, sc);

a1270 3
	if (sc_if->sk_sdhook != NULL)
		shutdownhook_disestablish(sc_if->sk_sdhook);

a1708 17
}

void
skc_shutdown(void *v)
{
	struct sk_softc		*sc = v;

	DPRINTFN(2, ("sk_shutdown\n"));

	/* Turn off the 'driver is loaded' LED. */
	CSR_WRITE_2(sc, SK_LED, SK_LED_GREEN_OFF);

	/*
	 * Reset the GEnesis controller. Doing this should also
	 * assert the resets on the attached XMAC(s).
	 */
	sk_reset(sc);
@


1.156
log
@use sc->sk_bsize in the unmap call too;  ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.155 2009/10/15 17:54:56 deraadt Exp $	*/
d1137 1
a1137 1
	    BUS_DMA_NOWAIT)) {
a1158 1
	bzero(sc_if->sk_rdata, sizeof(struct sk_ring_data));
@


1.155
log
@Add detach support to a few more drivers, and in others do the neccessary
operations in the detach function in the right order.  Also ensure that the
interrupt handlers not trust registers that go away.
read over very carefully by dms, tested by me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.154 2009/10/04 18:32:40 deraadt Exp $	*/
a1317 1
	bus_size_t size;
d1525 1
a1525 1
	bus_space_unmap(sc->sk_btag, sc->sk_bhandle, size);
@


1.154
log
@Merge over a bunch of detach logic from msk(4) so that this driver can
detach as well
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.153 2009/08/13 14:24:47 jasper Exp $	*/
d155 1
a155 1
void sk_stop(struct sk_if_softc *);
d493 1
a493 1
					
d653 1
a653 1
		
d895 1
a895 1
				sk_stop(sc_if);
a1245 2
fail_3:
	bus_dmamap_destroy(sc->sc_dmatag, sc_if->sk_ring_map);
d1250 2
d1266 1
a1266 1
	timeout_del(&sc_if->sk_tick_ch);
a1280 1
	bus_dmamap_destroy(sc->sc_dmatag, sc_if->sk_ring_map);
d1285 1
d1535 3
a1541 3
	if (sc->sk_intrhand)
		pci_intr_disestablish(sc->sk_pc, sc->sk_intrhand);

d2563 1
a2563 1
	sk_stop(sc_if);
d2574 1
a2574 1
		
d2619 1
a2619 1
		
d2660 1
a2660 1
		sk_stop(sc_if);
d2668 1
a2668 1
		sk_stop(sc_if);
d2715 1
a2715 1
sk_stop(struct sk_if_softc *sc_if)
d2729 40
a2768 24
	/* stop Tx descriptor polling timer */
	SK_IF_WRITE_4(sc_if, 0, SK_DPT_TIMER_CTRL, SK_DPT_TCTL_STOP);
	/* stop transfer of Tx descriptors */
	CSR_WRITE_4(sc, sc_if->sk_tx_bmu, SK_TXBMU_TX_STOP);
	for (i = 0; i < SK_TIMEOUT; i++) {
		val = CSR_READ_4(sc, sc_if->sk_tx_bmu);
		if (!(val & SK_TXBMU_TX_STOP))
			break;
		DELAY(1);
	}
	if (i == SK_TIMEOUT)
		printf("%s: cannot stop transfer of Tx descriptors\n",
		      sc_if->sk_dev.dv_xname);
	/* stop transfer of Rx descriptors */
	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_RX_STOP);
	for (i = 0; i < SK_TIMEOUT; i++) {
		val = SK_IF_READ_4(sc_if, 0, SK_RXQ1_BMU_CSR);
		if (!(val & SK_RXBMU_RX_STOP))
			break;
		DELAY(1);
	}
	if (i == SK_TIMEOUT)
		printf("%s: cannot stop transfer of Rx descriptors\n",
		      sc_if->sk_dev.dv_xname);
d2770 24
a2793 2
	if (sc_if->sk_phytype == SK_PHYTYPE_BCOM) {
		u_int32_t		val;
d2795 6
a2800 11
		/* Put PHY back into reset. */
		val = sk_win_read_4(sc, SK_GPIO);
		if (sc_if->sk_port == SK_PORT_A) {
			val |= SK_GPIO_DIR0;
			val &= ~SK_GPIO_DAT0;
		} else {
			val |= SK_GPIO_DIR2;
			val &= ~SK_GPIO_DAT2;
		}
		sk_win_write_4(sc, SK_GPIO, val);
	}
d2802 2
a2803 14
	/* Turn off various components of this interface. */
	SK_XM_SETBIT_2(sc_if, XM_GPIO, XM_GPIO_RESETMAC);
	switch (sc->sk_type) {
	case SK_GENESIS:
		SK_IF_WRITE_2(sc_if, 0, SK_TXF1_MACCTL,
			      SK_TXMACCTL_XMAC_RESET);
		SK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_RESET);
		break;
	case SK_YUKON:
	case SK_YUKON_LITE:
	case SK_YUKON_LP:
		SK_IF_WRITE_1(sc_if,0, SK_RXMF1_CTRL_TEST, SK_RFCTL_RESET_SET);
		SK_IF_WRITE_1(sc_if,0, SK_TXMF1_CTRL_TEST, SK_TFCTL_RESET_SET);
		break;
a2804 19
	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_OFFLINE);
	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);
	SK_IF_WRITE_4(sc_if, 1, SK_TXQS1_BMU_CSR, SK_TXBMU_OFFLINE);
	SK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);
	SK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL, SK_TXARCTL_OFF);
	SK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);
	SK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);
	SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_OFF);
	SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_LINKSYNC_OFF);

	/* Disable interrupts */
	if (sc_if->sk_port == SK_PORT_A)
		sc->sk_intrmask &= ~SK_INTRS1;
	else
		sc->sk_intrmask &= ~SK_INTRS2;
	CSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);

	SK_XM_READ_2(sc_if, XM_ISR);
	SK_XM_WRITE_2(sc_if, XM_IMR, 0xFFFF);
d2884 1
a2884 1
		
d2893 1
a2893 1
		
d2895 1
a2895 1
		
@


1.153
log
@- consistify cfdriver for the ethernet drivers (0 -> NULL)

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.152 2009/07/08 20:18:05 sthen Exp $	*/
d136 1
d140 1
d1033 1
a1033 2
	bus_dma_segment_t seg;
	int i, rseg;
d1136 2
a1137 1
	    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
d1141 1
a1141 1
	if (bus_dmamem_map(sc->sc_dmatag, &seg, rseg,
d1241 1
a1241 1
	shutdownhook_establish(skc_shutdown, sc);
d1251 1
a1251 1
	bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
d1257 35
d1359 1
a1359 1
	    &sc->sk_bhandle, NULL, &size, 0)) {
d1368 1
d1530 19
d2830 1
a2830 1
	sizeof(struct sk_softc), skc_probe, skc_attach,
d2838 1
a2838 1
	sizeof(struct sk_if_softc), sk_probe, sk_attach,
@


1.152
log
@revert MCLGETI for sk(4) for now. commit requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.150 2008/11/28 02:44:18 brad Exp $	*/
d2785 1
a2785 1
	0, "sk", DV_IFNET
@


1.151
log
@Switch sk(4) over to using MCLGETI when allocating mbufs for the RX ring.
Another evil jumbo allocator bites the dust.
@
text
@d158 4
a161 1
int sk_newbuf(struct sk_if_softc *);
a163 1
void sk_fill_rx_ring(struct sk_if_softc *);
d576 9
a586 1
	sc_if->sk_cdata.sk_rx_cnt = 0;
a587 1
	sk_fill_rx_ring(sc_if);
a590 9
void
sk_fill_rx_ring(struct sk_if_softc *sc_if)
{
	while (sc_if->sk_cdata.sk_rx_cnt < SK_RX_RING_CNT) {
		if (sk_newbuf(sc_if) == ENOBUFS)
			break;
	}
}

d638 2
a639 1
sk_newbuf(struct sk_if_softc *sc_if)
d641 1
a643 4
	struct mbuf		*m;
	bus_dmamap_t		dmamap;
	u_int32_t		sk_ctl;
	int			i, error;
d645 15
a659 3
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (ENOBUFS);
d661 12
a672 4
	MCLGETI(m, M_DONTWAIT, &sc_if->arpcom.ac_if, SK_JLEN);
	if ((m->m_flags & M_EXT) == 0) {
		m_freem(m);
		return (ENOBUFS);
d674 1
a674 2
	m->m_len = m->m_pkthdr.len = SK_JLEN;
	m_adj(m, ETHER_ALIGN);
d676 12
a687 1
	dmamap = sc_if->sk_cdata.sk_rx_map[sc_if->sk_cdata.sk_rx_prod];
d689 19
a707 4
	error = bus_dmamap_load_mbuf(sc_if->sk_softc->sc_dmatag, dmamap, m,
	    BUS_DMA_READ|BUS_DMA_NOWAIT);
	if (error) {
		m_freem(m);
d711 68
a778 4
	if (dmamap->dm_nsegs > (SK_RX_RING_CNT - sc_if->sk_cdata.sk_rx_cnt)) {
		bus_dmamap_unload(sc_if->sk_softc->sc_dmatag, dmamap);
		m_freem(m);
		return (ENOBUFS);
d781 2
a782 2
	bus_dmamap_sync(sc_if->sk_softc->sc_dmatag, dmamap, 0,
	    dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);
d784 27
a810 3
	c = &sc_if->sk_cdata.sk_rx_chain[sc_if->sk_cdata.sk_rx_prod];
	r = c->sk_desc;
	c->sk_mbuf = m;
d812 2
a813 13
	sk_ctl = SK_RXSTAT;
	for (i = 0; i < dmamap->dm_nsegs; i++) {
		r->sk_data_lo = htole32(dmamap->dm_segs[i].ds_addr);
		r->sk_ctl = htole32(dmamap->dm_segs[i].ds_len | sk_ctl);
		sk_ctl &= ~SK_RXCTL_FIRSTFRAG;

		SK_INC(sc_if->sk_cdata.sk_rx_prod, SK_RX_RING_CNT);
		sc_if->sk_cdata.sk_rx_cnt++;

		c = &sc_if->sk_cdata.sk_rx_chain[sc_if->sk_cdata.sk_rx_prod];
		r = c->sk_desc;
		c->sk_mbuf = NULL;
	}
d815 2
a816 1
	SK_CDRXSYNC(sc_if, i, BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
d818 13
a830 1
	return (0);
a1032 1
	int error;
d1159 4
a1162 7
	for (i = 0; i < SK_RX_RING_CNT; i++) {
		if ((error = bus_dmamap_create(sc->sc_dmatag, SK_JLEN, 4,
		    SK_JLEN, 0, 0, &sc_if->sk_cdata.sk_rx_map[i])) != 0) {
			printf("\n%s: unable to create rx DMA map %d, "
			    "error = %d\n", sc->sk_dev.dv_xname, i, error);
			goto fail_4;
		}
a1243 7
fail_4:
	for (i = 0; i < SK_RX_RING_CNT; i++) {
		if (sc_if->sk_cdata.sk_rx_map[i] != NULL)
			bus_dmamap_destroy(sc->sc_dmatag,
			    sc_if->sk_cdata.sk_rx_map[i]);
	}

d1713 2
d1716 1
a1716 1
		cur = sc_if->sk_cdata.sk_rx_cons;
d1722 5
a1726 6
		cur_rx = &sc_if->sk_cdata.sk_rx_chain[cur];
		if (cur_rx->sk_mbuf == NULL)
			break;

		sk_ctl = letoh32(sc_if->sk_rdata->sk_rx_ring[cur].sk_ctl);
		if ((sk_ctl & SK_RXCTL_OWN) != 0)
d1728 1
d1730 1
d1732 1
a1732 5
		dmamap = sc_if->sk_cdata.sk_rx_map[cur];
		for (i = 0; i < dmamap->dm_nsegs; i++) {
			SK_INC(sc_if->sk_cdata.sk_rx_cons, SK_RX_RING_CNT);
			sc_if->sk_cdata.sk_rx_cnt--;
		}
a1735 1
		bus_dmamap_unload(sc_if->sk_softc->sc_dmatag, dmamap);
d1742 4
a1745 2
		csum1 = letoh16(sc_if->sk_rdata->sk_rx_ring[cur].sk_csum1);
		csum2 = letoh16(sc_if->sk_rdata->sk_rx_ring[cur].sk_csum2);
d1754 1
a1754 1
			m_freem(m);
d1758 21
a1778 2
		m->m_pkthdr.rcvif = ifp;
		m->m_pkthdr.len = m->m_len = total_len;
a1791 2

	sk_fill_rx_ring(sc_if);
@


1.150
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.149 2008/10/14 18:01:53 naddy Exp $	*/
d158 1
a158 4
int sk_newbuf(struct sk_if_softc *, int, struct mbuf *, bus_dmamap_t);
int sk_alloc_jumbo_mem(struct sk_if_softc *);
void *sk_jalloc(struct sk_if_softc *);
void sk_jfree(caddr_t, u_int, void *);
d161 1
a573 9
	for (i = 0; i < SK_RX_RING_CNT; i++) {
		if (sk_newbuf(sc_if, i, NULL,
		    sc_if->sk_cdata.sk_rx_jumbo_map) == ENOBUFS) {
			printf("%s: failed alloc of %dth mbuf\n",
			    sc_if->sk_dev.dv_xname, i);
			return (ENOBUFS);
		}
	}

d576 1
d578 1
d582 9
d638 1
a638 2
sk_newbuf(struct sk_if_softc *sc_if, int i, struct mbuf *m,
	  bus_dmamap_t dmamap)
a639 1
	struct mbuf		*m_new = NULL;
d642 4
d647 3
a649 2
	if (m == NULL) {
		caddr_t buf = NULL;
d651 4
a654 25
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return (ENOBUFS);
		
		/* Allocate the jumbo buffer */
		buf = sk_jalloc(sc_if);
		if (buf == NULL) {
			m_freem(m_new);
			DPRINTFN(1, ("%s jumbo allocation failed -- packet "
			    "dropped!\n", sc_if->arpcom.ac_if.if_xname));
			return (ENOBUFS);
		}

		/* Attach the buffer to the mbuf */
		m_new->m_len = m_new->m_pkthdr.len = SK_JLEN;
		MEXTADD(m_new, buf, SK_JLEN, 0, sk_jfree, sc_if);
	} else {
		/*
	 	 * We're re-using a previously allocated mbuf;
		 * be sure to re-init pointers and lengths to
		 * default values.
		 */
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = SK_JLEN;
		m_new->m_data = m_new->m_ext.ext_buf;
d656 2
a657 1
	m_adj(m_new, ETHER_ALIGN);
d659 1
a659 7
	c = &sc_if->sk_cdata.sk_rx_chain[i];
	r = c->sk_desc;
	c->sk_mbuf = m_new;
	r->sk_data_lo = htole32(dmamap->dm_segs[0].ds_addr +
	    (((vaddr_t)m_new->m_data
             - (vaddr_t)sc_if->sk_cdata.sk_jumbo_buf)));
	r->sk_ctl = htole32(SK_JLEN | SK_RXSTAT);
d661 6
a666 1
	SK_CDRXSYNC(sc_if, i, BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
d668 3
a670 22
	return (0);
}

/*
 * Memory management for jumbo frames.
 */

int
sk_alloc_jumbo_mem(struct sk_if_softc *sc_if)
{
	struct sk_softc		*sc = sc_if->sk_softc;
	caddr_t			ptr, kva;
	bus_dma_segment_t	seg;
	int		i, rseg, state, error;
	struct sk_jpool_entry   *entry;

	state = error = 0;

	/* Grab a big chunk o' storage. */
	if (bus_dmamem_alloc(sc->sc_dmatag, SK_JMEM, PAGE_SIZE, 0,
			     &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
		printf(": can't alloc rx buffers");
d674 2
a675 27
	state = 1;
	if (bus_dmamem_map(sc->sc_dmatag, &seg, rseg, SK_JMEM, &kva,
			   BUS_DMA_NOWAIT)) {
		printf(": can't map dma buffers (%d bytes)", SK_JMEM);
		error = ENOBUFS;
		goto out;
	}

	state = 2;
	if (bus_dmamap_create(sc->sc_dmatag, SK_JMEM, 1, SK_JMEM, 0,
	    BUS_DMA_NOWAIT, &sc_if->sk_cdata.sk_rx_jumbo_map)) {
		printf(": can't create dma map");
		error = ENOBUFS;
		goto out;
	}

	state = 3;
	if (bus_dmamap_load(sc->sc_dmatag, sc_if->sk_cdata.sk_rx_jumbo_map,
			    kva, SK_JMEM, NULL, BUS_DMA_NOWAIT)) {
		printf(": can't load dma map");
		error = ENOBUFS;
		goto out;
	}

	state = 4;
	sc_if->sk_cdata.sk_jumbo_buf = (caddr_t)kva;
	DPRINTFN(1,("sk_jumbo_buf = 0x%08X\n", sc_if->sk_cdata.sk_jumbo_buf));
d677 3
a679 2
	LIST_INIT(&sc_if->sk_jfree_listhead);
	LIST_INIT(&sc_if->sk_jinuse_listhead);
d681 12
a692 37
	/*
	 * Now divide it up into 9K pieces and save the addresses
	 * in an array.
	 */
	ptr = sc_if->sk_cdata.sk_jumbo_buf;
	for (i = 0; i < SK_JSLOTS; i++) {
		sc_if->sk_cdata.sk_jslots[i] = ptr;
		ptr += SK_JLEN;
		entry = malloc(sizeof(struct sk_jpool_entry),
		    M_DEVBUF, M_NOWAIT);
		if (entry == NULL) {
			sc_if->sk_cdata.sk_jumbo_buf = NULL;
			printf(": no memory for jumbo buffer queue!");
			error = ENOBUFS;
			goto out;
		}
		entry->slot = i;
		LIST_INSERT_HEAD(&sc_if->sk_jfree_listhead,
				 entry, jpool_entries);
	}
out:
	if (error != 0) {
		switch (state) {
		case 4:
			bus_dmamap_unload(sc->sc_dmatag,
			    sc_if->sk_cdata.sk_rx_jumbo_map);
		case 3:
			bus_dmamap_destroy(sc->sc_dmatag,
			    sc_if->sk_cdata.sk_rx_jumbo_map);
		case 2:
			bus_dmamem_unmap(sc->sc_dmatag, kva, SK_JMEM);
		case 1:
			bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
			break;
		default:
			break;
		}
d695 1
a695 2
	return (error);
}
d697 1
a697 47
/*
 * Allocate a jumbo buffer.
 */
void *
sk_jalloc(struct sk_if_softc *sc_if)
{
	struct sk_jpool_entry   *entry;

	entry = LIST_FIRST(&sc_if->sk_jfree_listhead);

	if (entry == NULL)
		return (NULL);

	LIST_REMOVE(entry, jpool_entries);
	LIST_INSERT_HEAD(&sc_if->sk_jinuse_listhead, entry, jpool_entries);
	return (sc_if->sk_cdata.sk_jslots[entry->slot]);
}

/*
 * Release a jumbo buffer.
 */
void
sk_jfree(caddr_t buf, u_int size, void	*arg)
{
	struct sk_jpool_entry *entry;
	struct sk_if_softc *sc;
	int i;

	/* Extract the softc struct pointer. */
	sc = (struct sk_if_softc *)arg;

	if (sc == NULL)
		panic("sk_jfree: can't find softc pointer!");

	/* calculate the slot this buffer belongs to */
	i = ((vaddr_t)buf
	     - (vaddr_t)sc->sk_cdata.sk_jumbo_buf) / SK_JLEN;

	if ((i < 0) || (i >= SK_JSLOTS))
		panic("sk_jfree: asked to free buffer that we don't manage!");

	entry = LIST_FIRST(&sc->sk_jinuse_listhead);
	if (entry == NULL)
		panic("sk_jfree: buffer not in use!");
	entry->slot = i;
	LIST_REMOVE(entry, jpool_entries);
	LIST_INSERT_HEAD(&sc->sk_jfree_listhead, entry, jpool_entries);
d900 1
d1027 7
a1033 4
	/* Try to allocate memory for jumbo buffers. */
	if (sk_alloc_jumbo_mem(sc_if)) {
		printf(": jumbo buffer allocation failed\n");
		goto fail_3;
d1115 7
a1590 2
	i = sc_if->sk_cdata.sk_rx_prod;

d1592 1
a1592 1
		cur = i;
d1598 6
a1603 5
		sk_ctl = letoh32(sc_if->sk_rdata->sk_rx_ring[i].sk_ctl);
		if ((sk_ctl & SK_RXCTL_OWN) != 0) {
			/* Invalidate the descriptor -- it's not ready yet */
			SK_CDRXSYNC(sc_if, cur, BUS_DMASYNC_PREREAD);
			sc_if->sk_cdata.sk_rx_prod = i;
a1604 1
		}
a1605 1
		cur_rx = &sc_if->sk_cdata.sk_rx_chain[cur];
d1607 5
a1611 1
		dmamap = sc_if->sk_cdata.sk_rx_jumbo_map;
d1615 1
d1622 2
a1623 4
		csum1 = letoh16(sc_if->sk_rdata->sk_rx_ring[i].sk_csum1);
		csum2 = letoh16(sc_if->sk_rdata->sk_rx_ring[i].sk_csum2);

		SK_INC(i, SK_RX_RING_CNT);
d1632 1
a1632 1
			sk_newbuf(sc_if, cur, m, dmamap);
d1636 2
a1637 21
		/*
		 * Try to allocate a new jumbo buffer. If that
		 * fails, copy the packet to mbufs and put the
		 * jumbo buffer back in the ring so it can be
		 * re-used. If allocating mbufs fails, then we
		 * have to drop the packet.
		 */
		if (sk_newbuf(sc_if, cur, NULL, dmamap) == ENOBUFS) {
			struct mbuf		*m0;
			m0 = m_devget(mtod(m, char *), total_len, ETHER_ALIGN,
			    ifp, NULL);
			sk_newbuf(sc_if, cur, m, dmamap);
			if (m0 == NULL) {
				ifp->if_ierrors++;
				continue;
			}
			m = m0;
		} else {
			m->m_pkthdr.rcvif = ifp;
			m->m_pkthdr.len = m->m_len = total_len;
		}
d1651 2
@


1.149
log
@Change m_devget()'s outdated and unused "offset" argument:  It is
now the offset into the first mbuf of the target chain before copying
the source data over.  From FreeBSD.

Convert drivers' use of m_devget().  Mostly from thib@@.

Update mbuf(9) man page.

ok claudio@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.148 2008/10/02 20:21:14 brad Exp $	*/
d862 1
a863 1
	struct ifaddr *ifa = (struct ifaddr *) data;
d879 1
a879 6
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ifp->if_hardmtu)
			error = EINVAL;
		else if (ifp->if_mtu != ifr->ifr_mtu)
			ifp->if_mtu = ifr->ifr_mtu;
		break;
a896 5
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc_if->arpcom) :
		    ether_delmulti(ifr, &sc_if->arpcom);
a897 10
		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				sk_setmulti(sc_if);
			error = 0;
		}
		break;
d903 1
d906 6
@


1.148
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.147 2008/09/10 14:01:22 blambert Exp $	*/
d1780 2
a1781 2
			m0 = m_devget(mtod(m, char *) - ETHER_ALIGN,
			    total_len + ETHER_ALIGN, 0, ifp, NULL);
a1786 1
			m_adj(m0, ETHER_ALIGN);
@


1.147
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.146 2008/05/24 01:32:54 brad Exp $	*/
a868 5
	if ((error = ether_ioctl(ifp, &sc_if->arpcom, command, data)) > 0) {
		splx(s);
		return (error);
	}

d924 1
a924 2
		error = ENOTTY;
		break;
a927 1

@


1.146
log
@Also recognize the Schneider & Koch SK-9821/SK-9843 adapters from
Fujitsu.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.145 2008/05/23 08:49:27 brad Exp $	*/
d1249 1
a1249 1
		timeout_add(&sc_if->sk_tick_ch, hz);
d1991 1
a1991 1
		timeout_add(&sc_if->sk_tick_ch, hz);
d2012 1
a2012 1
	timeout_add(&sc_if->sk_tick_ch, hz);
d2060 1
a2060 1
			timeout_add(&sc_if->sk_tick_ch, hz);
d2077 1
a2077 1
			timeout_add(&sc_if->sk_tick_ch, hz);
d2081 1
a2081 1
			timeout_add(&sc_if->sk_tick_ch, hz);
d2673 1
a2673 1
		timeout_add(&sc_if->sk_tick_ch, hz);
@


1.145
log
@Simplify the combination use of pci_mapreg_type()/pci_mapreg_map() as
suggested by dlg@@ awhile ago.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.144 2008/03/02 19:16:43 brad Exp $	*/
d207 2
@


1.144
log
@Change some spaces to tabs in the transmit functions.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.143 2008/01/17 12:43:17 brad Exp $	*/
a1337 1

d1339 2
a1340 8
	switch (memtype) {
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
		if (pci_mapreg_map(pa, SK_PCI_LOMEM,
				   memtype, 0, &sc->sk_btag, &sc->sk_bhandle,
				   NULL, &size, 0) == 0)
			break;
	default:
@


1.143
log
@Add splnet around mii_tick() in sk_yukon_tick().

ok kettenis@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.142 2007/05/26 16:44:21 reyk Exp $	*/
d1618 4
a1621 4
        struct sk_if_softc	*sc_if = ifp->if_softc;
        struct sk_softc		*sc = sc_if->sk_softc;
        struct mbuf		*m_head = NULL;
        u_int32_t		idx = sc_if->sk_cdata.sk_tx_prod;
@


1.142
log
@separate the attach information from the status information with a colon.

suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.141 2007/05/22 04:30:56 ray Exp $	*/
d2012 1
d2014 1
d2016 1
@


1.141
log
@%z in printf(9) is not the same as %z in printf(3).  Change to %lu
and cast arg to ulong.

OK miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.140 2007/05/07 21:57:23 deraadt Exp $	*/
d1076 1
a1076 1
	printf(", address %s\n",
@


1.140
log
@shrink code by not using __inline without static; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.139 2007/02/12 21:19:56 pedro Exp $	*/
d1159 2
a1160 2
		printf(": can't map dma buffers (%z bytes)\n",
		       sizeof(struct sk_ring_data));
@


1.139
log
@Fix prototype, from brad@@, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.138 2007/02/10 02:27:56 krw Exp $	*/
d144 1
a144 1
__inline int sk_rxvalid(struct sk_softc *, u_int32_t, u_int32_t);
d1704 1
a1704 1
__inline int
@


1.138
log
@Move HASH_BITS constant to if_skreg.h as SK_HASH_BITS.  Remove unused
code and an unnecessary comment, No functional change.

From brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.137 2007/02/03 12:50:26 kettenis Exp $	*/
d961 2
a962 1
void sk_reset(struct sk_softc *sc)
@


1.137
log
@Fix typo; clear tx FIFO underrun IRQ as intended instead of rx FIFO overrun
IRQ.  From brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.136 2007/01/18 04:56:33 krw Exp $	*/
a400 2
#define HASH_BITS	6
  
d407 1
a407 1
	return (~crc & ((1 << HASH_BITS) - 1));
d416 1
a416 1
	return (crc & ((1 << HASH_BITS) - 1));
a1221 1
		/* Yukon/Yukon-2 */
a2661 4
#if 0
		/* XXX disable 100Mbps and full duplex mode? */
		reg &= ~(YU_GPCR_SPEED | YU_GPCR_DPLX_DIS);
#endif
@


1.136
log
@Don't reinitialize card at every media change.

From Brad, tested by Brad, wilfried@@ and Johan M:son Lindman.

ok wilfried@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.135 2007/01/05 21:32:25 kettenis Exp $	*/
d2109 1
a2109 1
		SK_IF_WRITE_1(sc_if, 0, SK_RXMF1_CTRL_TEST,
@


1.135
log
@For Yukon-based cards, pass MIIF_DOPAUSE to mii_attach().

From brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.134 2007/01/03 23:04:28 kettenis Exp $	*/
a840 1
	sk_init(sc_if);
@


1.134
log
@In sk_marv_miibus_writereg, wait for busy flag to clear instead of
continuing when busy flag set.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.133 2007/01/03 11:49:16 krw Exp $	*/
d1233 7
a1239 2
	mii_attach(self, &sc_if->sk_mii, 0xffffffff, MII_PHY_ANY,
	    MII_OFFSET_ANY, 0);
@


1.133
log
@Don't say 'Marvell' twice for each sk/msk device in dmesg. No functional
change.

from brad@@ ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.132 2006/12/06 23:34:44 reyk Exp $	*/
d386 1
a386 1
		if (SK_YU_READ_2(sc_if, YUKON_SMICR) & YU_SMICR_BUSY)
@


1.132
log
@- Move TX ring full sanity check further up and check the number of DMA
segments from the DMA map, instead of counting the DMA segments in the
for loop and breaking out later.
- Unload the DMA map if encountering an error condition.

Tested on amd64/i386/sparc64

ok brad@@ mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.131 2006/11/16 03:05:29 brad Exp $	*/
d1429 1
a1429 1
		sc->sk_name = "SysKonnect GEnesis";
d1432 1
a1432 1
		sc->sk_name = "Marvell Yukon";
d1435 1
a1435 1
		sc->sk_name = "Marvell Yukon Lite";
d1438 1
a1438 1
		sc->sk_name = "Marvell Yukon LP";
d1441 1
a1441 1
		sc->sk_name = "Marvell Yukon (Unknown)";
@


1.131
log
@remove the small amount of code for Yukon-2 chipsets now that there is msk(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.130 2006/11/08 21:04:41 kettenis Exp $	*/
d1519 1
a1519 1
	u_int32_t		frag, cur, cnt = 0, sk_ctl;
d1551 6
a1563 4
		if ((SK_TX_RING_CNT - (sc_if->sk_cdata.sk_tx_cnt + cnt)) < 2) {
			DPRINTFN(2, ("sk_encap: too few descriptors free\n"));
			return (ENOBUFS);
		}
d1567 1
a1567 1
		if (cnt == 0)
a1573 1
		cnt++;
d1593 1
a1593 1
	sc_if->sk_cdata.sk_tx_cnt += cnt;
@


1.130
log
@Make XMAC work on on big-endian systems.

help & ok jason@@, ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.129 2006/10/16 12:30:08 tom Exp $	*/
a454 4
	case SK_YUKON_XL:
	case SK_YUKON_EC_U:
	case SK_YUKON_EC:
	case SK_YUKON_FE:
a494 4
				case SK_YUKON_XL:
				case SK_YUKON_EC_U:
				case SK_YUKON_EC:
				case SK_YUKON_FE:
a517 4
	case SK_YUKON_XL:
	case SK_YUKON_EC_U:
	case SK_YUKON_EC:
	case SK_YUKON_FE:
a541 4
	case SK_YUKON_XL:
	case SK_YUKON_EC_U:
	case SK_YUKON_EC:
	case SK_YUKON_FE:
a1010 5
	case SK_YUKON_EC:
	case SK_YUKON_XL:
	case SK_YUKON_FE:
		imtimer_ticks = SK_IMTIMER_TICKS_YUKON_EC;
		break;
a1032 6
#ifdef not_quite_yet
	case SK_YUKON_XL:
	case SK_YUKON_EC_U:
	case SK_YUKON_EC:
	case SK_YUKON_FE:
#endif
a1087 3
	 *
	 * Just to be contrary, Yukon2 appears to have separate memory
	 * for each MAC.
d1089 1
a1089 2
	if (SK_IS_YUKON2(sc) ||
	    sk_win_read_1(sc, SK_CONFIG) & SK_CONFIG_SINGLEMAC) {
a1208 4
	case SK_YUKON_XL:
	case SK_YUKON_EC_U:
	case SK_YUKON_EC:
	case SK_YUKON_FE:
d1422 1
a1422 3
	if (sc->sk_pmd == 'T' || sc->sk_pmd == '1' ||
	    (SK_IS_YUKON2(sc) && !(sc->sk_pmd == 'L' ||
	    sc->sk_pmd == 'S')))
a1439 12
	case SK_YUKON_XL:
		sc->sk_name = "Marvell Yukon-2 XL";
		break;
	case SK_YUKON_EC_U:
		sc->sk_name = "Marvell Yukon-2 EC Ultra";
		break;
	case SK_YUKON_EC:
		sc->sk_name = "Marvell Yukon-2 EC";
		break;
	case SK_YUKON_FE:
		sc->sk_name = "Marvell Yukon-2 FE";
		break;
a1479 48
	if (sc->sk_type == SK_YUKON_XL) {
		switch (sc->sk_rev) {
		case SK_YUKON_XL_REV_A0:
			revstr = "A0";
			break;
		case SK_YUKON_XL_REV_A1:
			revstr = "A1";
			break;
		case SK_YUKON_XL_REV_A2:
			revstr = "A2";
			break;
		case SK_YUKON_XL_REV_A3:
			revstr = "A3";
			break;
		default:
			;
		}
	}

	if (sc->sk_type == SK_YUKON_EC) {
		switch (sc->sk_rev) {
		case SK_YUKON_EC_REV_A1:
			revstr = "A1";
			break;
		case SK_YUKON_EC_REV_A2:
			revstr = "A2";
			break;
		case SK_YUKON_EC_REV_A3:
			revstr = "A3";
			break;
		default:
			;
		}
	}

	if (sc->sk_type == SK_YUKON_EC_U) {
		switch (sc->sk_rev) {
		case SK_YUKON_EC_U_REV_A0:
			revstr = "A0";
			break;
		case SK_YUKON_EC_U_REV_A1:
			revstr = "A1";
			break;
		default:
			;
		}
	}

d1488 2
a1489 13
	if (SK_IS_YUKON2(sc)) {
		u_int8_t hw;

		hw = sk_win_read_1(sc, SK_Y2_HWRES);
		if ((hw & SK_Y2_HWRES_LINK_MASK) == SK_Y2_HWRES_LINK_DUAL) {
			if ((sk_win_read_1(sc, SK_Y2_CLKGATE) &
			    SK_Y2_CLKGATE_LINK2_INACTIVE) == 0)
				sc->sk_macs++;
		}
	} else {
		if (!(sk_win_read_1(sc, SK_CONFIG) & SK_CONFIG_SINGLEMAC))
			sc->sk_macs++;
	}
a2571 4
	case SK_YUKON_XL:
	case SK_YUKON_EC_U:
	case SK_YUKON_EC:
	case SK_YUKON_FE:
a2746 4
	case SK_YUKON_XL:
	case SK_YUKON_EC_U:
	case SK_YUKON_EC:
	case SK_YUKON_FE:
@


1.129
log
@Fix some "is is"s.  ok otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.128 2006/09/27 02:27:04 brad Exp $	*/
d426 3
a428 3
	SK_XM_WRITE_2(sc_if, base, *(u_int16_t *)(&addr[0]));
	SK_XM_WRITE_2(sc_if, base + 2, *(u_int16_t *)(&addr[2]));
	SK_XM_WRITE_2(sc_if, base + 4, *(u_int16_t *)(&addr[4]));
d2373 1
a2373 1
	    *(u_int16_t *)(&sc_if->arpcom.ac_enaddr[0]));
d2375 1
a2375 1
	    *(u_int16_t *)(&sc_if->arpcom.ac_enaddr[2]));
d2377 1
a2377 1
	    *(u_int16_t *)(&sc_if->arpcom.ac_enaddr[4]));
@


1.128
log
@fix the use of LIST_INSERT_HEAD in [m]sk_alloc_jumbo_mem().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.127 2006/09/26 19:37:28 brad Exp $	*/
d2392 1
a2392 1
	 * Enable the reception of all error frames. This is is
@


1.127
log
@Set sk_jumbo_buf to NULL if malloc() fails in the for loop within
[m]sk_alloc_jumbo_mem().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.126 2006/09/18 04:05:05 brad Exp $	*/
d775 1
a775 5
		if (i)
			LIST_INSERT_HEAD(&sc_if->sk_jfree_listhead,
				 entry, jpool_entries);
		else
			LIST_INSERT_HEAD(&sc_if->sk_jinuse_listhead,
a834 1

@


1.126
log
@g/c unused SK_{SET,CLR}BIT macros

From riz@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.125 2006/08/17 21:37:44 brad Exp $	*/
d769 1
@


1.125
log
@cosmetic tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.124 2006/08/17 21:31:37 brad Exp $	*/
a193 18

#define SK_SETBIT(sc, reg, x)		\
	CSR_WRITE_4(sc, reg, CSR_READ_4(sc, reg) | x)

#define SK_CLRBIT(sc, reg, x)		\
	CSR_WRITE_4(sc, reg, CSR_READ_4(sc, reg) & ~x)

#define SK_WIN_SETBIT_4(sc, reg, x)	\
	sk_win_write_4(sc, reg, sk_win_read_4(sc, reg) | x)

#define SK_WIN_CLRBIT_4(sc, reg, x)	\
	sk_win_write_4(sc, reg, sk_win_read_4(sc, reg) & ~x)

#define SK_WIN_SETBIT_2(sc, reg, x)	\
	sk_win_write_2(sc, reg, sk_win_read_2(sc, reg) | x)

#define SK_WIN_CLRBIT_2(sc, reg, x)	\
	sk_win_write_2(sc, reg, sk_win_read_2(sc, reg) & ~x)
@


1.124
log
@remove PCI ids which msk(4) will match against from sk(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.123 2006/08/09 05:03:28 brad Exp $	*/
d932 2
a933 2
			    ((ifp->if_flags ^ sc_if->sk_if_flags)
			     & IFF_PROMISC)) {
d1297 1
a1297 2
	}
	else
@


1.123
log
@revert rev 1.119 as this seems to cause problems with some PHY.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.122 2006/08/04 06:25:13 brad Exp $	*/
a219 1
	{ PCI_VENDOR_DLINK,		PCI_PRODUCT_DLINK_DGE560T },
a222 15
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_3 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8035 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8036 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8038 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8052 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8050 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8053 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKONII_8021CU },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKONII_8022CU },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKONII_8021X },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKONII_8022X },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKONII_8061CU },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKONII_8062CU },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKONII_8061X },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKONII_8062X },
a224 2
	{ PCI_VENDOR_SCHNEIDERKOCH,	PCI_PRODUCT_SCHNEIDERKOCH_SK9Sxx },
	{ PCI_VENDOR_SCHNEIDERKOCH,	PCI_PRODUCT_SCHNEIDERKOCH_SK9Exx }
@


1.122
log
@and the same goes for sk_init_yukon().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.121 2006/08/04 05:01:00 brad Exp $	*/
d422 1
a422 1
		if (!(SK_YU_READ_2(sc_if, YUKON_SMICR) & YU_SMICR_BUSY))
@


1.121
log
@remove now redundant promiscuous mode handling code from sk_init_xmac().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.120 2006/08/04 04:44:37 brad Exp $	*/
d2590 1
a2590 2
	SK_YU_WRITE_2(sc_if, YUKON_RCR, YU_RCR_UFLEN | YU_RCR_MUFLEN |
		      YU_RCR_CRCR);
@


1.120
log
@refactor the promiscuous mode handling code and simplify the ioctl handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.119 2006/08/04 02:55:38 brad Exp $	*/
a2419 5

	if (ifp->if_flags & IFF_PROMISC)
		SK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_PROMISC);
	else
		SK_XM_CLRBIT_4(sc_if, XM_MODE, XM_MODE_RX_PROMISC);
@


1.119
log
@Fix busy check for PHY write operation with Yukon chips.

From yongari@@FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.118 2006/07/30 18:48:52 brad Exp $	*/
d177 1
d574 31
a918 1
	struct sk_softc *sc = sc_if->sk_softc;
d950 3
a952 38
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc_if->sk_if_flags & IFF_PROMISC)) {
				switch(sc->sk_type) {
				case SK_GENESIS:
					SK_XM_SETBIT_4(sc_if, XM_MODE,
					    XM_MODE_RX_PROMISC);
					break;
				case SK_YUKON:
				case SK_YUKON_LITE:
				case SK_YUKON_LP:
				case SK_YUKON_XL:
				case SK_YUKON_EC_U:
				case SK_YUKON_EC:
				case SK_YUKON_FE:
					SK_YU_CLRBIT_2(sc_if, YUKON_RCR,
					    YU_RCR_UFLEN | YU_RCR_MUFLEN);
					break;
				}
				sk_setmulti(sc_if);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc_if->sk_if_flags & IFF_PROMISC) {
				switch(sc->sk_type) {
				case SK_GENESIS:
					SK_XM_CLRBIT_4(sc_if, XM_MODE,
					    XM_MODE_RX_PROMISC);
					break;
				case SK_YUKON:
				case SK_YUKON_LITE:
				case SK_YUKON_LP:
				case SK_YUKON_XL:
				case SK_YUKON_EC_U:
				case SK_YUKON_EC:
				case SK_YUKON_FE:
					SK_YU_SETBIT_2(sc_if, YUKON_RCR,
					    YU_RCR_UFLEN | YU_RCR_MUFLEN);
					break;
				}
a962 1
		error = 0;
d2463 3
d2623 3
@


1.118
log
@Add more strict receive path packet validation routine. Previously
the driver could pass corrupted packets to the upper layer under
certain conditions.

From yongari@@FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.117 2006/07/23 05:59:18 brad Exp $	*/
d421 1
a421 1
		if (SK_YU_READ_2(sc_if, YUKON_SMICR) & YU_SMICR_BUSY)
d2860 1
a2860 1
		if ((val & SK_TXBMU_TX_STOP) == 0)
d2871 1
a2871 1
		if ((val & SK_RXBMU_RX_STOP) == 0)
@


1.117
log
@improved Yukon init routine with proper workaround for the PHY COMA mode.

From yongari@@FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.116 2006/06/22 23:06:03 brad Exp $	*/
d144 1
d1855 19
d1877 1
d1899 1
a1899 1
		if (sk_ctl & SK_RXCTL_OWN) {
d1923 6
a1928 1
		if (rxstat & XM_RXSTAT_ERRFRAME) {
@


1.116
log
@Add appropriate swapping for big-endian systems. Allows sk(4) to work
on macppc and sparc64.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.115 2006/06/22 05:18:20 brad Exp $	*/
d2499 8
a2506 3
		/* Take PHY out of reset. */
		sk_win_write_4(sc, SK_GPIO,
			(sk_win_read_4(sc, SK_GPIO) | SK_GPIO_DIR9) & ~SK_GPIO_DAT9);
d2509 2
a2512 6

	DPRINTFN(6, ("sk_init_yukon: 1\n"));

	SK_IF_WRITE_4(sc_if, 0, SK_GMAC_CTRL, SK_GMAC_RESET_SET);
	DELAY(1000);
	SK_IF_WRITE_4(sc_if, 0, SK_GMAC_CTRL, SK_GMAC_RESET_CLEAR);
d2517 11
@


1.115
log
@adjust PCI ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.114 2006/06/17 18:00:43 brad Exp $	*/
d577 1
a577 1
	int			i;
d584 9
a592 10
		if (i == (SK_RX_RING_CNT - 1)) {
			cd->sk_rx_chain[i].sk_next = &cd->sk_rx_chain[0];
			rd->sk_rx_ring[i].sk_next = SK_RX_RING_ADDR(sc_if, 0);
		} else {
			cd->sk_rx_chain[i].sk_next = &cd->sk_rx_chain[i + 1];
			rd->sk_rx_ring[i].sk_next = SK_RX_RING_ADDR(sc_if,i+1);
		}
		rd->sk_rx_ring[i].sk_csum1_start = ETHER_HDR_LEN;
		rd->sk_rx_ring[i].sk_csum2_start = ETHER_HDR_LEN +
		    sizeof(struct ip);
d618 1
a618 1
	int			i;
d626 6
a631 7
		if (i == (SK_TX_RING_CNT - 1)) {
			cd->sk_tx_chain[i].sk_next = &cd->sk_tx_chain[0];
			rd->sk_tx_ring[i].sk_next = SK_TX_RING_ADDR(sc_if, 0);
		} else {
			cd->sk_tx_chain[i].sk_next = &cd->sk_tx_chain[i + 1];
			rd->sk_tx_ring[i].sk_next = SK_TX_RING_ADDR(sc_if,i+1);
		}
d698 1
a698 1
	r->sk_data_lo = dmamap->dm_segs[0].ds_addr +
d700 2
a701 2
             - (vaddr_t)sc_if->sk_cdata.sk_jumbo_buf));
	r->sk_ctl = SK_JLEN | SK_RXSTAT;
d1672 1
a1672 1
	u_int32_t		frag, cur, cnt = 0;
d1716 2
a1717 2
		f->sk_data_lo = txmap->dm_segs[i].ds_addr;
		f->sk_ctl = txmap->dm_segs[i].ds_len | SK_OPCODE_DEFAULT;
d1719 1
a1719 1
			f->sk_ctl |= SK_TXCTL_FIRSTFRAG;
d1721 2
a1722 2
			f->sk_ctl |= SK_TXCTL_OWN;

d1733 1
a1733 1
		SK_TXCTL_LASTFRAG|SK_TXCTL_EOF_INTR;
d1739 2
a1740 1
	sc_if->sk_rdata->sk_tx_ring[*txidx].sk_ctl |= SK_TXCTL_OWN;
d1776 1
a1776 1
	while(sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf == NULL) {
d1862 1
a1862 1
	u_int32_t		rxstat;
d1877 2
a1878 1
		if (sc_if->sk_rdata->sk_rx_ring[i].sk_ctl & SK_RXCTL_OWN) {
d1892 1
a1892 1
		rxstat = cur_desc->sk_xmac_rxstat;
d1895 1
a1895 1
		total_len = SK_RXBYTES(cur_desc->sk_ctl);
d1897 2
a1898 2
		csum1 = sc_if->sk_rdata->sk_rx_ring[i].sk_csum1;
		csum2 = sc_if->sk_rdata->sk_rx_ring[i].sk_csum2;
d2039 1
a2039 1
	u_int32_t		idx;
d2049 1
a2049 1
	while(idx != sc_if->sk_cdata.sk_tx_prod) {
d2054 1
d2059 1
a2059 1
		if (cur_tx->sk_ctl & SK_TXCTL_OWN) {
d2063 1
a2063 1
		if (cur_tx->sk_ctl & SK_TXCTL_LASTFRAG)
d2941 1
a2941 1
	if (desc->X)					\
d2943 1
a2943 1
		       idx, desc->X);
d2945 10
a2954 10
	DESC_PRINT(sk_ctl);
	DESC_PRINT(sk_next);
	DESC_PRINT(sk_data_lo);
	DESC_PRINT(sk_data_hi);
	DESC_PRINT(sk_xmac_txstat);
	DESC_PRINT(sk_rsvd0);
	DESC_PRINT(sk_csum_startval);
	DESC_PRINT(sk_csum_startpos);
	DESC_PRINT(sk_csum_writepos);
	DESC_PRINT(sk_rsvd1);
@


1.114
log
@add sys/timeout.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.113 2006/06/17 01:04:34 brad Exp $	*/
d216 2
a217 1
	{ PCI_VENDOR_DLINK,		PCI_PRODUCT_DLINK_DGE530T },
a218 1
	{ PCI_VENDOR_DLINK,		PCI_PRODUCT_DLINK_DGE560T_2 },
@


1.113
log
@remove some whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.112 2006/06/15 20:12:40 brad Exp $	*/
d98 1
@


1.112
log
@Fix watchdog timeout errors seen on a few systems.

The SK-NET GENESIS document says reading the SK_ISSR register should stop
generating further interrupts, but it seems there is the possibility
of losing interrupts between reading the SK_ISSR register and determining
which interrupts have been reported. To cope with this situation we
continuously read the SK_ISSR register until there are no interrupts.

However, it seems that the above workaround does not fix all cases.
Add workaround code that tries to protect against false alarms from
the watchdog handler by trying to reclaim pending Tx descriptors
before resetting the hardware.

This should fix occasional watchdog timeouts seen with this driver.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.111 2006/05/28 00:20:21 brad Exp $	*/
a1149 1

d2549 1
a2549 1
        
d2618 1
a2618 1
		
@


1.111
log
@- remove ETHER_MAX_LEN_JUMBO and ETHERMTU_JUMBO.
- use if_hardmtu for MTU ioctl handlers.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.110 2006/05/28 00:04:24 jason Exp $	*/
d1824 7
a1830 1
	printf("%s: watchdog timeout\n", sc_if->sk_dev.dv_xname);
d1832 1
a1832 1
	ifp->if_oerrors++;
d1834 2
a1835 1
	sk_init(sc_if);
d2257 1
a2257 2
	status &= sc->sk_intrmask;
	if ((status & sc->sk_intrmask) != 0) {
d2311 1
@


1.110
log
@unknown ioctl is ENOTTY not EINVAL
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.109 2006/05/27 10:03:15 brad Exp $	*/
d911 1
a911 1
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ETHERMTU_JUMBO)
d1269 1
a1269 1
	ifp->if_hardmtu = ETHERMTU_JUMBO;
@


1.109
log
@remove IFCAP_JUMBO_MTU interface capabilities flag and set if_hardmtu in a few
more drivers.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.108 2006/05/20 03:47:56 brad Exp $	*/
d991 1
a991 1
		error = EINVAL;
@


1.108
log
@set if_jumbo_mtu and the IFCAP_JUMBO_MTU capabilities flag where
appropriate.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.107 2006/05/01 18:47:34 brad Exp $	*/
d1269 1
d1274 1
a1274 1
	ifp->if_capabilities = IFCAP_VLAN_MTU | IFCAP_JUMBO_MTU;
@


1.107
log
@Activate Tx descriptor poll timer in order to protect possible loss
of SK_TXBMU_TX_START command. Previously the driver continuously issued
SK_TXBMU_TX_START when it notices pending Tx descriptors not processed
yet in interrupt handler. That approach would add additional PCI
write access overhead under high Tx load situations and it might fail
if the first SK_TXBMU_TX_START was lost and no interrupt is generated
from the first SK_TXBMU_TX_START command.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.106 2006/05/01 18:31:11 brad Exp $	*/
a1268 1
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
d1272 2
@


1.106
log
@Added Rx/Tx FIFO flush support for Yukon

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.105 2006/05/01 16:51:39 brad Exp $	*/
d2072 1
a2072 4
	if (sc_if->sk_cdata.sk_tx_cnt == 0)
		ifp->if_timer = 0;
	else /* nudge chip to keep tx ring moving */
		CSR_WRITE_4(sc, sc_if->sk_tx_bmu, SK_TXBMU_TX_START);
d2649 19
d2777 5
d2798 1
d2805 25
@


1.105
log
@A new function sk_yukon_tick(), to handle auto-negotiation properly for
Yukon-based adapters.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.104 2006/04/30 04:17:48 brad Exp $	*/
d2213 1
a2213 2
sk_intr_yukon(sc_if)
	struct sk_if_softc *sc_if;
d2215 1
a2215 1
	int status;
d2217 11
a2227 1
	status = SK_IF_READ_2(sc_if, 0, SK_GMAC_ISR);
d2480 1
a2480 1
	u_int32_t		phy;
d2591 11
d2604 6
a2609 2
	SK_IF_WRITE_4(sc_if, 0, SK_RXMF1_CTRL_TEST, SK_RFCTL_OPERATION_ON);
	
d2612 1
a2612 1
	SK_IF_WRITE_4(sc_if, 0, SK_TXMF1_CTRL_TEST, SK_TFCTL_OPERATION_ON);
@


1.104
log
@- Use SK_IS_GENESIS/SK_IS_YUKON where appropriate
- Remove SK_YUKON_FAMILY
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.103 2006/04/30 03:13:43 brad Exp $	*/
d176 1
d1323 5
a1327 2
	timeout_set(&sc_if->sk_tick_ch, sk_tick, sc_if);
	timeout_add(&sc_if->sk_tick_ch, hz);
d2126 10
d2739 3
@


1.103
log
@- Interrupt handler now checks shared interrupt source and protects
  the interrupt handler from NULL pointer dereference which was caused
  by odd status word value. The status word can return 0xffffffff if the
  cable is unplugged while Rx/Tx/auto-negotiation is in progress.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.102 2006/04/30 02:28:49 brad Exp $	*/
d518 1
a518 1
			if (sc->sk_type == SK_GENESIS && i < XM_RXFILT_MAX) {
d1032 1
a1032 1
	if (SK_YUKON_FAMILY(sc->sk_type))
d1039 1
a1039 1
	if (SK_YUKON_FAMILY(sc->sk_type))
d1046 1
a1046 1
	if (sc->sk_type == SK_GENESIS) {
d1298 1
a1298 1
	if (sc->sk_type == SK_GENESIS) {
d1432 1
a1432 1
	if (sc->sk_type != SK_GENESIS && ! SK_YUKON_FAMILY(sc->sk_type)) {
d1459 1
a1459 1
	if (sc->sk_type == SK_GENESIS) {
d2259 1
a2259 1
			if (sc->sk_type == SK_GENESIS)
d2267 1
a2267 1
			if (sc->sk_type == SK_GENESIS)
d2599 1
a2599 1
	if (sc->sk_type == SK_GENESIS) {
d2633 1
a2633 1
	if (sc->sk_type == SK_GENESIS) {
d2706 1
a2706 1
	if (sc->sk_type == SK_GENESIS) {
d2713 1
a2713 1
	if (SK_YUKON_FAMILY(sc->sk_type)) {
@


1.102
log
@Update if_oerrors if we encounter watchdog error.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.101 2006/04/30 02:00:21 brad Exp $	*/
d2219 4
d2228 2
a2229 7
	for (;;) {
		status = CSR_READ_4(sc, SK_ISSR);
		DPRINTFN(2, ("sk_intr: status=%#x\n", status));

		if (!(status & sc->sk_intrmask))
			break;

@


1.101
log
@- Added/corrected register definitions for Yukon.
  (Register information from Linux skge driver.)

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.100 2006/04/23 21:02:58 brad Exp $	*/
d1819 2
@


1.100
log
@some more ANSI, KNF and other tidying up.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.99 2006/04/20 20:31:12 miod Exp $	*/
d2715 4
a2718 1
		reg &= ~(YU_GPCR_SPEED_EN | YU_GPCR_DPLX_EN);
@


1.99
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.98 2006/04/17 10:11:29 brad Exp $	*/
d288 1
a288 1
		return(0);
d303 1
a303 1
			return(0);
d307 1
a307 1
	return(SK_XM_READ_2(sc_if, XM_PHY_DATA));
d354 1
a354 1
		if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX) {
d356 1
a356 1
		} else {
a357 1
		}
d362 1
a362 3
sk_marv_miibus_readreg(dev, phy, reg)
	struct device *dev;
	int phy, reg;
d373 1
a373 1
		return(0);
d389 1
a389 1
		return 0;
d400 1
a400 1
	return val;
d404 1
a404 3
sk_marv_miibus_writereg(dev, phy, reg, val)
	struct device *dev;
	int phy, reg, val;
d427 1
a427 2
sk_marv_miibus_statchg(dev)
	struct device *dev;
d599 1
a599 1
			return(ENOBUFS);
d606 1
a606 1
	return(0);
d669 1
a669 1
			return(ENOBUFS);
d677 1
a677 1
			return(ENOBUFS);
d705 1
a705 1
	return(0);
d866 1
a866 1
	return(0);
d896 1
a896 1
		return error;
d902 2
a903 1
		switch (ifa->ifa_addr->sa_family) {
d905 1
a905 2
		case AF_INET:
			sk_init(sc_if);
a906 1
			break;
a907 4
		default:
			sk_init(sc_if);
			break;
		}
a955 1

d957 4
a960 2
			} else
				sk_init(sc_if);
d996 1
a996 1
	return(error);
d1091 1
a1091 1
		return(0);
d1678 1
a1678 1
		return ENOBUFS;
d1697 1
a1697 1
		return(ENOBUFS);
d1709 1
a1709 1
			return(ENOBUFS);
d1757 1
a1757 1
	return(0);
d1819 1
a1819 1
	ifp->if_flags &= ~IFF_RUNNING;
d2369 1
a2369 1
	if (ifp->if_flags & IFF_PROMISC) {
d2371 1
a2371 1
	} else {
a2372 1
	}
d2374 1
a2374 1
	if (ifp->if_flags & IFF_BROADCAST) {
d2376 1
a2376 1
	} else {
a2377 1
	}
d2454 1
a2454 2
void sk_init_yukon(sc_if)
	struct sk_if_softc	*sc_if;
a2594 5
	if (ifp->if_flags & IFF_RUNNING) {
		splx(s);
		return;
	}

a2717 1

@


1.98
log
@If there is a timeout while writing to the PHY in
sk_marv_miibus_writereg() then print a message
indicating so, as done in the XMAC case.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.97 2006/04/17 04:45:02 brad Exp $	*/
d1247 1
a1247 1
		printf(": can't map dma buffers (%d bytes)\n",
@


1.97
log
@Coviery CID 1108: Avoid NULL pointer deref.

Coverity CID 1105: Avoid NULL deref.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.96 2006/03/25 22:41:45 djm Exp $	*/
d426 3
@


1.96
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.95 2006/02/13 01:23:05 brad Exp $	*/
d2239 1
a2239 1
		if (status & SK_ISR_RX1_EOF) {
d2244 1
a2244 1
		if (status & SK_ISR_RX2_EOF) {
d2251 1
a2251 1
		if (status & SK_ISR_TX1_S_EOF) {
d2256 1
a2256 1
		if (status & SK_ISR_TX2_S_EOF) {
d2263 2
a2264 1
		if (status & SK_ISR_MAC1 && (ifp0->if_flags & IFF_RUNNING)) {
d2271 2
a2272 1
		if (status & SK_ISR_MAC2 && (ifp1->if_flags & IFF_RUNNING)) {
d2281 1
a2281 1
			if (ifp0 != NULL &&
d2285 1
a2285 1
			if (ifp1 != NULL &&
@


1.95
log
@add some ASIC revisions to the various switch cases and identify
some newer revs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.94 2006/02/09 11:19:32 brad Exp $	*/
d1803 1
a1803 1
			bpf_mtap(ifp->if_bpf, m_head);
d1929 1
a1929 1
			bpf_mtap(ifp->if_bpf, m);
@


1.94
log
@sync PCI id.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.93 2005/12/22 20:54:46 brad Exp $	*/
d490 4
d534 4
d561 4
d936 4
d956 4
d1577 48
d2636 4
d2779 4
@


1.93
log
@re-work PHY setup, media handling and dual-port detection.

Based on the Marvell FreeBSD driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.92 2005/12/16 01:52:29 brad Exp $	*/
a219 1
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_2 },
d223 1
d238 1
a238 1
	{ PCI_VENDOR_SCHNEIDERKOCH,	PCI_PRODUCT_SCHNEIDERKOCH_SK9Exx },
@


1.92
log
@remove unused code to use IO space.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.91 2005/12/15 23:56:00 brad Exp $	*/
d1182 1
a1182 1
	/* Read and save PHY type and set PHY address */
d1184 15
a1198 14
	switch (sc_if->sk_phytype) {
	case SK_PHYTYPE_XMAC:
		sc_if->sk_phyaddr = SK_PHYADDR_XMAC;
		break;
	case SK_PHYTYPE_BCOM:
		sc_if->sk_phyaddr = SK_PHYADDR_BCOM;
		break;
	case SK_PHYTYPE_MARV_COPPER:
		sc_if->sk_phyaddr = SK_PHYADDR_MARV;
		break;
	default:
		printf(": unsupported PHY type: %d\n",
		    sc_if->sk_phytype);
		goto fail;
d1200 10
a1209 4
	if (SK_IS_YUKON2(sc) && sc_if->sk_phytype < SK_PHYTYPE_MARV_COPPER &&
	    sc->sk_pmd != IFM_1000_SX && sc->sk_pmd != IFM_1000_LX) {
		/* not initialized, punt */
		sc_if->sk_phytype = SK_PHYTYPE_MARV_COPPER;
d1211 3
d1290 1
a1290 1
		/* yukon/yukon2 */
d1483 8
a1490 35
	skrs = sk_win_read_1(sc, SK_PMDTYPE);
	if (SK_IS_YUKON2(sc)) {
		switch (skrs) {
		case 'L':
			sc->sk_pmd = IFM_1000_LX;
			break;
		case 'S':
			sc->sk_pmd = IFM_1000_SX;
			break;
		case SK_PMD_1000BASETX:
		case SK_PMD_1000BASETX_ALT:
		default:
			sc->sk_pmd = IFM_1000_T;
			break;
		}
	} else {
		switch (skrs) {
		case SK_PMD_1000BASESX:
			sc->sk_pmd = IFM_1000_SX;
			break;
		case SK_PMD_1000BASELX:
			sc->sk_pmd = IFM_1000_LX;
			break;
		case SK_PMD_1000BASECX:
			sc->sk_pmd = IFM_1000_CX;
			break;
		case SK_PMD_1000BASETX:
		case SK_PMD_1000BASETX_ALT:
			sc->sk_pmd = IFM_1000_T;
			break;
		default:
			printf(": unknown media type: 0x%x\n", skrs);
			goto fail_2;
		}
	}
d1523 2
a1524 2
		uint32_t flashaddr;
		uint8_t testbyte;
d1563 1
a1563 4
	skca.skc_port = SK_PORT_A;
	skca.skc_type = sc->sk_type;
	skca.skc_rev = sc->sk_rev;
	(void)config_found(&sc->sk_dev, &skca, skcprint);
d1571 2
a1572 7
			    SK_Y2_CLKGATE_LINK2_INACTIVE) == 0) {
				skca.skc_port = SK_PORT_B;
				skca.skc_type = sc->sk_type;
				skca.skc_rev = sc->sk_rev;
				(void)config_found(&sc->sk_dev, &skca,
				    skcprint);
			}
d1575 14
a1588 6
		if (!(sk_win_read_1(sc, SK_CONFIG) & SK_CONFIG_SINGLEMAC)) {
			skca.skc_port = SK_PORT_B;
			skca.skc_type = sc->sk_type;
			skca.skc_rev = sc->sk_rev;
			(void)config_found(&sc->sk_dev, &skca, skcprint);
		}
d2429 3
a2431 3
	switch(sc_if->sk_softc->sk_pmd) {
	case IFM_1000_SX:
	case IFM_1000_LX:
a2432 7
		break;

	case IFM_1000_CX:
	case IFM_1000_T:
		phy |= SK_GPHY_COPPER;
		break;
	}
@


1.91
log
@merge printing of the revision and the interrupt string into one printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.90 2005/12/10 19:06:10 brad Exp $	*/
a129 3
#define	SK_VERBOSE
/* #define SK_USEIOSPACE */

a245 4
#ifdef SK_USEIOSPACE
	CSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));
	return CSR_READ_4(sc, SK_WIN_BASE + SK_REG(reg));
#else
a246 1
#endif
a251 4
#ifdef SK_USEIOSPACE
	CSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));
	return CSR_READ_2(sc, SK_WIN_BASE + SK_REG(reg));
#else
a252 1
#endif
a257 4
#ifdef SK_USEIOSPACE
	CSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));
	return CSR_READ_1(sc, SK_WIN_BASE + SK_REG(reg));
#else
a258 1
#endif
a263 4
#ifdef SK_USEIOSPACE
	CSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));
	CSR_WRITE_4(sc, SK_WIN_BASE + SK_REG(reg), x);
#else
a264 1
#endif
a269 4
#ifdef SK_USEIOSPACE
	CSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));
	CSR_WRITE_2(sc, SK_WIN_BASE + SK_REG(reg), x);
#else
a270 1
#endif
a275 4
#ifdef SK_USEIOSPACE
	CSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));
	CSR_WRITE_1(sc, SK_WIN_BASE + SK_REG(reg), x);
#else
a276 1
#endif
a1389 7
#ifdef SK_USEIOSPACE
	if (pci_mapreg_map(pa, SK_PCI_LOIO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->sk_btag, &sc->sk_bhandle, NULL, &size, 0)) {
		printf(": can't map i/o space\n");
		return;
 	}
#else
d1402 1
a1402 1
#endif
@


1.90
log
@sk_shutdown -> skc_shutdown and register the shutdown function with
shutdownhook_establish().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.89 2005/12/10 19:03:02 brad Exp $	*/
d1618 1
a1618 2
	printf(" (0x%x)", sc->sk_rev);
	printf(": %s\n", intrstr);
@


1.89
log
@shrink dmesg entry by one line by merging the chipset revision into
the skc line and fix various error condition printf's in skc_attach(),
sk_attach() and sk_alloc_jumbo_mem() so the messages will be displayed
properly.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.88 2005/11/26 19:16:28 brad Exp $	*/
d138 1
a155 1
void sk_shutdown(void *);
d1341 2
a1343 1

d1821 1
a1821 1
sk_shutdown(void *v)
@


1.88
log
@fix interrupt moderation timer frequencies for Yukon and Yukon-II based
chips.

From Jeff Rizzo on NetBSD's tech-net list, based on the Marvell
sk98lin Linux driver, and also matches what the Marvell FreeBSD
does.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.87 2005/11/15 20:32:04 brad Exp $	*/
d750 1
a750 1
		printf("%s: can't alloc rx buffers\n", sc->sk_dev.dv_xname);
d757 1
a757 2
		printf("%s: can't map dma buffers (%d bytes)\n",
		    sc->sk_dev.dv_xname, SK_JMEM);
d765 1
a765 1
		printf("%s: can't create dma map\n", sc->sk_dev.dv_xname);
d773 1
a773 1
		printf("%s: can't load dma map\n", sc->sk_dev.dv_xname);
d796 1
a796 2
			printf("%s: no memory for jumbo buffer queue!\n",
			    sc->sk_dev.dv_xname);
d802 1
a802 1
		LIST_INSERT_HEAD(&sc_if->sk_jfree_listhead,
d805 1
a805 1
		LIST_INSERT_HEAD(&sc_if->sk_jinuse_listhead,
d1170 1
a1170 1
	printf(": address %s\n",
d1228 3
a1230 3
		printf("%s: unsupported PHY type: %d\n",
		    sc->sk_dev.dv_xname, sc_if->sk_phytype);
		return;
d1242 1
a1242 1
		printf("%s: can't alloc rx buffers\n", sc->sk_dev.dv_xname);
d1247 2
a1248 2
		printf("%s: can't map dma buffers (%d bytes)\n",
		       sc_if->sk_dev.dv_xname, sizeof(struct sk_ring_data));
d1254 1
a1254 1
		printf("%s: can't create dma map\n", sc_if->sk_dev.dv_xname);
d1259 1
a1259 1
		printf("%s: can't load dma map\n", sc_if->sk_dev.dv_xname);
d1267 1
a1267 1
		printf("%s: jumbo buffer allocation failed\n", ifp->if_xname);
d1300 1
a1300 2
		printf("%s: unknown device type %d\n", sc->sk_dev.dv_xname,
		    sc->sk_type);
a1334 2
	DPRINTFN(2, ("sk_attach: 1\n"));

d1449 1
a1449 1
		printf("%s: unknown chip type\n",sc->sk_dev.dv_xname);
a1469 1
	printf(": %s\n", intrstr);
d1495 1
a1495 2
			printf("%s: unknown ram size: %d\n",
			    sc->sk_dev.dv_xname, skrs);
d1543 1
a1543 2
			printf("%s: unknown media type: 0x%x\n",
			    sc->sk_dev.dv_xname, sk_win_read_1(sc, SK_PMDTYPE));
d1614 1
a1614 1
	printf("%s: %s", sc->sk_dev.dv_xname, sc->sk_name);
d1617 2
a1618 1
	printf(" (0x%x)\n", sc->sk_rev);
@


1.87
log
@more accurately reflect the naming scheme of the Marvell Yukon devices with there
pcidevs entries.

Based on information from the Marvell Yukon/Yukon-II FreeBSD driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.86 2005/11/07 02:57:45 brad Exp $	*/
d1048 2
d1081 1
a1081 1
         * Configure interrupt moderation. The moderation timer
d1085 3
a1087 2
	 * register represents 18.825ns, so to specify a timeout in
	 * microseconds, we have to multiply by 54.
d1089 14
a1102 2
        sk_win_write_4(sc, SK_IMTIMERINIT, SK_IM_USECS(100));
        sk_win_write_4(sc, SK_IMMR, SK_ISR_TX1_S_EOF|SK_ISR_TX2_S_EOF|
d1104 1
a1104 1
        sk_win_write_1(sc, SK_IMTIMERCTL, SK_IMCTL_START);
@


1.86
log
@- splimp -> splnet
- remove spl's from attach
- removing redundant checks before pci_mapreg_map()
- fix dmesg printing
- de-allocate resources on failure to attach
- remove unused VLAN input code from vge(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.85 2005/10/15 23:09:17 brad Exp $	*/
d221 2
a222 3
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_SK_V2 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_SK_V2_BELKIN },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_1 },
a224 7
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_4 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_5 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_6 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_7 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_9 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_10 },
d230 10
a239 2
	{ PCI_VENDOR_SCHNEIDERKOCH,	PCI_PRODUCT_SCHNEIDERKOCH_GE },
	{ PCI_VENDOR_SCHNEIDERKOCH,	PCI_PRODUCT_SCHNEIDERKOCH_SK9821v2 },
@


1.85
log
@add 2 new Yukon PCI ids and recognize Yukon-2 EC Ultra ASIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.83 2005/09/20 01:02:22 brad Exp $	*/
d918 1
a918 1
	s = splimp();
d2589 1
a2589 1
	s = splimp();
@


1.84
log
@update Via and 3Com ids.
@
text
@d231 2
d1107 1
d1281 1
d1556 3
@


1.83
log
@memory, media handling and a bunch of register definitions for Yukon-2.

From jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.82 2005/09/20 00:56:33 brad Exp $	*/
d215 1
a215 1
	{ PCI_VENDOR_3COM,		PCI_PRODUCT_3COM_GIG },
@


1.82
log
@merge xmaciireg.h and yukonreg.h into if_skreg.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.81 2005/09/20 00:24:04 brad Exp $	*/
d1103 5
d1164 3
d1168 2
a1169 1
	if (sk_win_read_1(sc, SK_CONFIG) & SK_CONFIG_SINGLEMAC) {
d1216 6
d1277 3
d1292 1
a1292 2
	switch (sc->sk_type) {
	case SK_GENESIS:
d1296 2
a1297 4
		break;
	case SK_YUKON:
	case SK_YUKON_LITE:
	case SK_YUKON_LP:
a1300 1
		break;
@


1.81
log
@shuffle some stuff from skreg to skvar
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.80 2005/09/17 02:53:09 brad Exp $	*/
a134 2
#include <dev/pci/xmaciireg.h>
#include <dev/pci/yukonreg.h>
@


1.80
log
@add media detection and dual port detection for Yukon-2.

from jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.79 2005/09/16 00:43:31 brad Exp $	*/
d134 1
@


1.79
log
@- remove code to read PCI VPD as we do not use that anymore.
- remove some FreeBSD-ism's: struct resource *'s.
- fail more gracefully in sk_probe() instead of in sk_attach()
  for newer unsupported ASIC revisions.

From jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.78 2005/08/29 02:53:25 brad Exp $	*/
d1487 35
a1521 17
	switch(sk_win_read_1(sc, SK_PMDTYPE)) {
	case SK_PMD_1000BASESX:
		sc->sk_pmd = IFM_1000_SX;
		break;
	case SK_PMD_1000BASELX:
		sc->sk_pmd = IFM_1000_LX;
		break;
	case SK_PMD_1000BASECX:
		sc->sk_pmd = IFM_1000_CX;
		break;
	case SK_PMD_1000BASETX:
		sc->sk_pmd = IFM_1000_T;
		break;
	default:
		printf("%s: unknown media type: 0x%x\n",
		    sc->sk_dev.dv_xname, sk_win_read_1(sc, SK_PMDTYPE));
		goto fail_2;
d1597 21
a1617 5
	if (!(sk_win_read_1(sc, SK_CONFIG) & SK_CONFIG_SINGLEMAC)) {
		skca.skc_port = SK_PORT_B;
		skca.skc_type = sc->sk_type;
		skca.skc_rev = sc->sk_rev;
		(void)config_found(&sc->sk_dev, &skca, skcprint);
@


1.78
log
@- use pci_mapreg_type() to fix some systems that would fail to attach
  sk(4) with "can't map mem space".
- add missing newline for failure case of pci_intr_establish().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.77 2005/07/25 00:49:43 brad Exp $	*/
a165 3
u_int8_t sk_vpd_readbyte(struct sk_softc *, int);
void sk_vpd_read_res(struct sk_softc *, struct vpd_res *, int);
void sk_vpd_read(struct sk_softc *);
a310 87
/*
 * The VPD EEPROM contains Vital Product Data, as suggested in
 * the PCI 2.1 specification. The VPD data is separared into areas
 * denoted by resource IDs. The SysKonnect VPD contains an ID string
 * resource (the name of the adapter), a read-only area resource
 * containing various key/data fields and a read/write area which
 * can be used to store asset management information or log messages.
 * We read the ID string and read-only into buffers attached to
 * the controller softc structure for later use. At the moment,
 * we only use the ID string during sk_attach().
 */
u_int8_t
sk_vpd_readbyte(struct sk_softc *sc, int addr)
{
	int			i;

	sk_win_write_2(sc, SK_PCI_REG(SK_PCI_VPD_ADDR), addr);
	for (i = 0; i < SK_TIMEOUT; i++) {
		DELAY(1);
		if (sk_win_read_2(sc,
		    SK_PCI_REG(SK_PCI_VPD_ADDR)) & SK_VPD_FLAG)
			break;
	}

	if (i == SK_TIMEOUT)
		return(0);

	return(sk_win_read_1(sc, SK_PCI_REG(SK_PCI_VPD_DATA)));
}

void
sk_vpd_read_res(struct sk_softc *sc, struct vpd_res *res, int addr)
{
	int			i;
	u_int8_t		*ptr;

	ptr = (u_int8_t *)res;
	for (i = 0; i < sizeof(struct vpd_res); i++)
		ptr[i] = sk_vpd_readbyte(sc, i + addr);
}

void
sk_vpd_read(struct sk_softc *sc)
{
	int			pos = 0, i;
	struct vpd_res		res;

	if (sc->sk_vpd_prodname != NULL)
		free(sc->sk_vpd_prodname, M_DEVBUF);
	if (sc->sk_vpd_readonly != NULL)
		free(sc->sk_vpd_readonly, M_DEVBUF);
	sc->sk_vpd_prodname = NULL;
	sc->sk_vpd_readonly = NULL;

	sk_vpd_read_res(sc, &res, pos);

	if (res.vr_id != VPD_RES_ID) {
		printf("%s: bad VPD resource id: expected %x got %x\n",
		    sc->sk_dev.dv_xname, VPD_RES_ID, res.vr_id);
		return;
	}

	pos += sizeof(res);
	sc->sk_vpd_prodname = malloc(res.vr_len + 1, M_DEVBUF, M_NOWAIT);
	if (sc->sk_vpd_prodname == NULL)
		panic("sk_vpd_read");
	for (i = 0; i < res.vr_len; i++)
		sc->sk_vpd_prodname[i] = sk_vpd_readbyte(sc, i + pos);
	sc->sk_vpd_prodname[i] = '\0';
	pos += i;

	sk_vpd_read_res(sc, &res, pos);

	if (res.vr_id != VPD_RES_READ) {
		printf("%s: bad VPD resource id: expected %x got %x\n",
		    sc->sk_dev.dv_xname, VPD_RES_READ, res.vr_id);
		return;
	}

	pos += sizeof(res);
	sc->sk_vpd_readonly = malloc(res.vr_len, M_DEVBUF, M_NOWAIT);
	if (sc->sk_vpd_readonly == NULL)
		panic("sk_vpd_read");
	for (i = 0; i < res.vr_len; i++)
		sc->sk_vpd_readonly[i] = sk_vpd_readbyte(sc, i + pos);
}

d1099 9
a1107 1
	return (1);
a1447 3
	/* Read and save vital product data from EEPROM. */
	sk_vpd_read(sc);

d1575 2
d1581 2
@


1.77
log
@don't bother with printf in *_jalloc()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.76 2005/07/24 20:18:17 fgsch Exp $	*/
d1434 1
a1438 1
	u_int32_t command;
d1484 10
a1493 3
	if (pci_mapreg_map(pa, SK_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->sk_btag, &sc->sk_bhandle, NULL, &size, 0)) {
 		printf(": can't map mem space\n");
d1495 1
a1495 1
 	}
d1522 1
@


1.76
log
@simplify error paths and add some missing ones; brad@@ ok.
deallocation for jumbo memory left.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.75 2005/07/22 03:49:19 brad Exp $	*/
d931 1
a931 3
	if (entry == NULL) {
		DPRINTF(("%s: no free jumbo buffers\n",
		    sc_if->sk_dev.dv_xname));
a932 1
	}
@


1.75
log
@- sync sk_alloc_jumbo_mem() to look like bge's bge_alloc_jumbo_mem()
- oops, forgot to remove a line in sk_rxeof()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.74 2005/07/22 03:10:17 brad Exp $	*/
d1304 1
a1304 2
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		goto fail;
d1310 1
a1310 4
		bus_dmamem_unmap(sc->sc_dmatag, kva,
		    sizeof(struct sk_ring_data));
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		goto fail;
d1315 1
a1315 5
		bus_dmamap_destroy(sc->sc_dmatag, sc_if->sk_ring_map);
		bus_dmamem_unmap(sc->sc_dmatag, kva,
		    sizeof(struct sk_ring_data));
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		goto fail;
d1323 1
a1323 1
		goto fail;
d1352 3
a1354 2
		      sc->sk_type);
		goto fail;
d1403 6
d1484 1
a1484 1
		goto fail;
d1490 1
a1490 1
		goto fail;
d1501 1
a1501 2
		bus_space_unmap(sc->sk_btag, sc->sk_bhandle, size);
		goto fail;
d1508 1
a1508 2
		bus_space_unmap(sc->sk_btag, sc->sk_bhandle, size);
		goto fail;
d1518 1
a1518 2
		bus_space_unmap(sc->sk_btag, sc->sk_bhandle, size);
		goto fail;
d1550 2
a1551 3
			       sc->sk_dev.dv_xname, skrs);
			bus_space_unmap(sc->sk_btag, sc->sk_bhandle, size);
			goto fail_1;
d1583 1
a1583 2
		bus_space_unmap(sc->sk_btag, sc->sk_bhandle, size);
		goto fail_1;
a1664 1
fail:
d1667 2
d1670 1
a1670 1
	pci_intr_disestablish(pc, sc->sk_intrhand);
@


1.74
log
@also take the PCI subsystem id into consideration when trying to probe
for Linksys EG1032 cards, that way we do not try and attach to newer
rev 3 cards that use the RealTek 8169S chipset.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.73 2005/07/21 15:23:27 brad Exp $	*/
d831 1
a831 1
	int		i, rseg;
d834 2
d842 2
d848 2
a849 2
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		return (ENOBUFS);
d851 2
d856 2
a857 3
		bus_dmamem_unmap(sc->sc_dmatag, kva, SK_JMEM);
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		return (ENOBUFS);
d859 2
d864 2
a865 5
		bus_dmamap_destroy(sc->sc_dmatag,
				   sc_if->sk_cdata.sk_rx_jumbo_map);
		bus_dmamem_unmap(sc->sc_dmatag, kva, SK_JMEM);
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		return (ENOBUFS);
d867 2
a885 7
			bus_dmamap_unload(sc->sc_dmatag,
			    sc_if->sk_cdata.sk_rx_jumbo_map);
			bus_dmamap_destroy(sc->sc_dmatag,
			    sc_if->sk_cdata.sk_rx_jumbo_map);
			bus_dmamem_unmap(sc->sc_dmatag, kva, SK_JMEM);
			bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
			sc_if->sk_cdata.sk_jumbo_buf = NULL;
d888 2
a889 1
			return(ENOBUFS);
d899 18
d918 1
a918 1
	return(0);
a1942 2

	sc_if->sk_cdata.sk_rx_prod = i;
@


1.73
log
@- add bus_dmamap_sync()'s; From NetBSD
- use pci_mapreg_map()
- remove unnecessary splimp() usage in skc_attach()
- make sure to disestablish the interrupt on failure

Tested by a few end-users.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.72 2005/07/14 01:47:58 brad Exp $	*/
a223 1
	{ PCI_VENDOR_LINKSYS,		PCI_PRODUCT_LINKSYS_EG1032 },
d246 2
d1102 11
@


1.72
log
@add D-Link PCI id.

From: jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.71 2005/07/12 00:43:37 brad Exp $	*/
d762 3
d815 2
d1410 1
a1410 3
	bus_addr_t iobase;
	bus_size_t iosize;
	int s;
a1416 2
	s = splimp();

a1449 1
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
d1452 2
a1453 12
	if (!(command & PCI_COMMAND_IO_ENABLE)) {
		printf(": failed to enable I/O ports!\n");
		goto fail;
	}
	/*
	 * Map control/status registers.
	 */
	if (pci_io_find(pc, pa->pa_tag, SK_PCI_LOIO, &iobase, &iosize)) {
		printf(": can't find i/o space\n");
		goto fail;
	}
	if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->sk_bhandle)) {
d1456 1
a1456 2
	}
	sc->sk_btag = pa->pa_iot;
d1458 3
a1460 10
	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf(": failed to enable memory mapping!\n");
		goto fail;
	}
	if (pci_mem_find(pc, pa->pa_tag, SK_PCI_LOMEM, &iobase, &iosize, NULL)){
		printf(": can't find mem space\n");
		goto fail;
	}
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->sk_bhandle)) {
		printf(": can't map mem space\n");
d1462 1
a1462 4
	}
	sc->sk_btag = pa->pa_memt;

	DPRINTFN(2, ("skc_attach: iobase=%#x, iosize=%#x\n", iobase, iosize));
d1472 1
d1480 1
d1491 1
d1525 2
a1526 1
			goto fail;
d1558 2
a1559 1
		goto fail;
d1642 4
a1645 1
	splx(s);
d1687 4
d1711 1
d1715 5
d1721 4
d1841 1
a1841 1
	while(!(sc_if->sk_rdata->sk_rx_ring[i].sk_ctl & SK_RXCTL_OWN)) {
d1843 12
d1857 4
a1866 2
		dmamap = sc_if->sk_cdata.sk_rx_jumbo_map;

d2022 3
d2030 2
a2031 1
		if (cur_tx->sk_ctl & SK_TXCTL_OWN)
d2033 1
d2037 2
a2041 1
			entry = sc_if->sk_cdata.sk_tx_map[idx];
@


1.71
log
@remove unused prototype sk_free_jumbo_mem
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.70 2005/07/12 00:01:49 brad Exp $	*/
d223 1
@


1.70
log
@free resources for Jumbo buffers in sk_stop().

ok deraadt, krw, beck
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.69 2005/07/02 23:10:11 brad Exp $	*/
a161 1
void sk_free_jumbo_mem(struct sk_if_softc *);
@


1.69
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.68 2005/07/02 21:57:19 brad Exp $	*/
d2706 1
d2777 3
d2781 6
@


1.68
log
@- mbuf external storage is of (caddr_t), not (caddr_t *).
- check for MTU being too small with ETHERMIN
- don't bother reseting the card since it'll default to allowing Jumbos
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.67 2005/05/17 19:18:18 jason Exp $	*/
d2712 2
a2777 2

	ifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);
@


1.67
log
@remove spurious bpf_mtap (I think it's leftover debugging code from a year ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.66 2005/05/16 13:47:02 brad Exp $	*/
d774 1
a774 1
		caddr_t *buf = NULL;
d1009 1
a1009 1
		if (ifr->ifr_mtu > ETHERMTU_JUMBO)
d1011 1
a1011 1
		else {
a1012 3
			ifp->if_flags &= ~IFF_RUNNING;
			sk_init(sc_if);
		}
@


1.66
log
@add a newline here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.65 2005/05/11 02:27:23 brad Exp $	*/
d1967 1
a1967 3
	if (iph_csum != 0xffff) {
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m);
a1968 1
	}
@


1.65
log
@remove comment which is not valid anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.64 2005/05/11 00:33:10 brad Exp $	*/
d1327 1
a1327 1
		printf("%s: unknown device type %d", sc->sk_dev.dv_xname,
@


1.64
log
@- Also match on Yukon LP's for the Lite rev A0 test.
- Do not call mii_pollstat() from within device tick routines; the status
  information is updated by mii_tick().
- Take PHY out of reset for Yukon Lite rev A3. This resolves the
  intermittent "no PHY found!" issue.

From FreeBSD

- Recognize some newer Yukon chipsets

ok krw@@, tested by krw@@ and a few others, mostly with LOM Lite A3's but
also with some other ASIC revs too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.63 2005/04/25 17:55:51 brad Exp $	*/
a1580 2
	/* determine whether to name it with VPD or just make it up */
	/* Marvell Yukon VPD's can freqently be bogus */
@


1.63
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.62 2005/03/18 03:59:34 brad Exp $	*/
d1585 1
a1585 1
		sc->sk_name = sc->sk_vpd_prodname;
d1588 1
a1588 1
		sc->sk_name = "Marvell Yukon Gigabit Ethernet";
d1591 1
a1591 1
		sc->sk_name = "Marvell Yukon Lite Gigabit Ethernet";
d1594 10
a1603 1
		sc->sk_name = "Marvell Yukon LP Gigabit Ethernet";
d1606 1
a1606 1
		sc->sk_name = "Marvell Yukon (Unknown) Gigabit Ethernet";
d1610 1
a1610 1
	if (sc->sk_type == SK_YUKON) {
a2089 1
	mii_pollstat(mii);
a2135 1
			mii_pollstat(mii);
d2433 1
d2436 2
d2441 7
a2457 1

@


1.62
log
@fail to attach with a printf instead of a panic for newer yet unsupported
Yukon-2-based cards.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.61 2005/03/12 18:16:56 brad Exp $	*/
d1965 1
a1965 1
	m->m_pkthdr.csum |= M_IPV4_CSUM_IN_OK;
d1984 1
a1984 1
		m->m_pkthdr.csum |= (ip->ip_p == IPPROTO_TCP) ?
@


1.61
log
@add a bunch of PCI ids from the SysKonnect sk98lin driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.60 2005/01/15 05:24:11 brad Exp $	*/
d1327 1
a1327 1
		panic("%s: unknown device type %d", sc->sk_dev.dv_xname,
d1329 1
@


1.60
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.59 2005/01/02 01:46:17 brad Exp $	*/
d219 26
a244 8
	{ PCI_VENDOR_3COM,		PCI_PRODUCT_3COM_3C940},
	{ PCI_VENDOR_DLINK,		PCI_PRODUCT_DLINK_DGE530T},
	{ PCI_VENDOR_LINKSYS,		PCI_PRODUCT_LINKSYS_EG1032},
	{ PCI_VENDOR_LINKSYS,		PCI_PRODUCT_LINKSYS_EG1064},
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_SK_V2},
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_SK_V2_BELKIN},
	{ PCI_VENDOR_SCHNEIDERKOCH,	PCI_PRODUCT_SCHNEIDERKOCH_GE},
	{ PCI_VENDOR_SCHNEIDERKOCH,	PCI_PRODUCT_SCHNEIDERKOCH_SK9821v2},
d1582 16
a1597 35
	switch (pa->pa_id) {
	case PCI_ID_CODE(PCI_VENDOR_SCHNEIDERKOCH,
			 PCI_PRODUCT_SCHNEIDERKOCH_GE):
	case PCI_PRODUCT_SCHNEIDERKOCH_SK9821v2:
	case PCI_PRODUCT_3COM_3C940:
	case PCI_PRODUCT_LINKSYS_EG1032:
	case PCI_PRODUCT_LINKSYS_EG1064:
	case PCI_ID_CODE(PCI_VENDOR_SCHNEIDERKOCH,
			 PCI_PRODUCT_SCHNEIDERKOCH_SK9821v2):
	case PCI_ID_CODE(PCI_VENDOR_3COM,PCI_PRODUCT_3COM_3C940):
	case PCI_ID_CODE(PCI_VENDOR_LINKSYS,PCI_PRODUCT_LINKSYS_EG1032):
	case PCI_ID_CODE(PCI_VENDOR_LINKSYS,PCI_PRODUCT_LINKSYS_EG1064):
 		sc->sk_name = sc->sk_vpd_prodname;
 		break;
	case PCI_ID_CODE(PCI_VENDOR_MARVELL,PCI_PRODUCT_MARVELL_SK_V2):
	case PCI_ID_CODE(PCI_VENDOR_MARVELL,PCI_PRODUCT_MARVELL_SK_V2_BELKIN):
	case PCI_PRODUCT_DLINK_DGE530T:
	case PCI_ID_CODE(PCI_VENDOR_DLINK,PCI_PRODUCT_DLINK_DGE530T):
	/* whoops Yukon VPD prodname bears no resemblance to reality */
		switch (sc->sk_type) {
		case SK_GENESIS:
			sc->sk_name = sc->sk_vpd_prodname;
			break;
		case SK_YUKON:
			sc->sk_name = "Marvell Yukon Gigabit Ethernet";
			break;
		case SK_YUKON_LITE:
			sc->sk_name = "Marvell Yukon Lite Gigabit Ethernet";
			break;
		case SK_YUKON_LP:
			sc->sk_name = "Marvell Yukon LP Gigabit Ethernet";
			break;
		default:
			sc->sk_name = "Marvell Yukon (Unknown) Gigabit Ethernet";
		}
d1600 16
a1615 17
		if (sc->sk_type == SK_YUKON) {
			uint32_t flashaddr;
			uint8_t testbyte;
			
			flashaddr = sk_win_read_4(sc, SK_EP_ADDR);
			
			/* test Flash-Address Register */
			sk_win_write_1(sc, SK_EP_ADDR+3, 0xff);
			testbyte = sk_win_read_1(sc, SK_EP_ADDR+3);
			
			if (testbyte != 0) {
				/* This is a Yukon Lite Rev A0 */
				sc->sk_type = SK_YUKON_LITE;
				sc->sk_rev = SK_YUKON_LITE_REV_A0;
				/* restore Flash-Address Register */
				sk_win_write_4(sc, SK_EP_ADDR, flashaddr);
			}
a1616 3
		break;
	default:
		sc->sk_name = "Unkown Marvell";
a2089 1

@


1.59
log
@cleanup and better ram sizing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.58 2005/01/01 23:10:43 brad Exp $	*/
d1054 2
a1055 1
			sk_setmulti(sc_if);
@


1.58
log
@better chip/card identification.

From NetBSD

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.57 2005/01/01 21:53:24 brad Exp $	*/
d1391 1
d1474 1
a1474 1
	if ( sc->sk_type != SK_GENESIS && ! SK_YUKON_FAMILY(sc->sk_type)) {
d1503 1
a1504 1
		u_int8_t val = sk_win_read_1(sc, SK_EPROM0);
d1506 1
a1506 1
		switch(val) {
d1525 1
a1525 1
			       sc->sk_dev.dv_xname, val);
d1530 4
a1533 2
		u_int8_t val = sk_win_read_1(sc, SK_EPROM0);
		sc->sk_ramsize =  ( val == 0 ) ?  0x20000 : (( val * 4 )*1024);
d1600 1
a1600 1
		if ( sc->sk_type == SK_YUKON ) {
d1622 2
a1623 2
		
	if ( sc->sk_type == SK_YUKON_LITE ) {
d1643 1
a1643 1
        printf(" (0x%x)\n", sc->sk_rev);
@


1.57
log
@rev 1.92

only clear the IFF_OACTIVE flag when we have a chance of being able to
queue a packet to the hardware... instead of when the hardware queue is
empty..

don't initalize cur_tx now that it doesn't need to be...

rev 1.90

_OACTIVE is now handled better...

From FreeBSD

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.56 2005/01/01 07:11:19 krw Exp $	*/
a350 6
	/*
	 * Bail out quietly if the eeprom appears to be missing or empty.
	 */
	if (res.vr_id == 0xff && res.vr_len == 0xff && res.vr_pad == 0xff)
		return;

d591 2
d631 2
d654 2
d1010 2
d1026 2
d1093 1
a1093 1
	if (sc->sk_type == SK_YUKON)
d1100 1
a1100 1
	if (sc->sk_type == SK_YUKON)
d1303 2
d1322 2
d1392 1
a1432 22
#define SK_MK_ID(vnd,prd) \
    (((vnd) << PCI_VENDOR_SHIFT) | ((prd) << PCI_PRODUCT_SHIFT))

	switch (pa->pa_id) {
	case SK_MK_ID(PCI_VENDOR_SCHNEIDERKOCH, PCI_PRODUCT_SCHNEIDERKOCH_GE):
		sc->sk_type = SK_GENESIS;
		break;
	case SK_MK_ID(PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C940):
	case SK_MK_ID(PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_DGE530T):
	case SK_MK_ID(PCI_VENDOR_LINKSYS, PCI_PRODUCT_LINKSYS_EG1032):
	case SK_MK_ID(PCI_VENDOR_LINKSYS, PCI_PRODUCT_LINKSYS_EG1064):
	case SK_MK_ID(PCI_VENDOR_MARVELL, PCI_PRODUCT_MARVELL_SK_V2):
	case SK_MK_ID(PCI_VENDOR_MARVELL, PCI_PRODUCT_MARVELL_SK_V2_BELKIN):
	case SK_MK_ID(PCI_VENDOR_SCHNEIDERKOCH, PCI_PRODUCT_SCHNEIDERKOCH_SK9821v2):
		sc->sk_type = SK_YUKON;
		break;
	default:
		printf(": unknown device!\n");
		goto fail;
	}
#undef SK_MK_ID

d1469 8
d1558 78
d1637 4
a1640 1
	printf("%s: %s\n", sc->sk_dev.dv_xname, sc->sk_vpd_prodname);
d2593 2
d2680 1
a2680 1
	if (sc->sk_type == SK_YUKON) {
d2729 2
@


1.56
log
@Don't initialize the card (and start an autonegotiation!) every time
the IP address changes. Makes 'dhclient sk0' invocations way faster
and more consistant. i.e. one DHCPREQUEST elicts the DHCPACK.

ok brad@@ 'Wow. Great Idea.' deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.55 2004/12/22 23:40:28 brad Exp $	*/
d1707 3
a1709 2
	sc_if->sk_cdata.sk_tx_prod = idx;
	CSR_WRITE_4(sc, sc_if->sk_tx_bmu, SK_TXBMU_TX_START);
d1711 3
a1713 2
	/* Set a timeout in case the chip goes out to lunch. */
	ifp->if_timer = 5;
d1917 1
a1917 1
	struct sk_tx_desc	*cur_tx = NULL;
d1960 3
a1963 3

	if (cur_tx != NULL)
		ifp->if_flags &= ~IFF_OACTIVE;
@


1.55
log
@- add missing braces for SIOCSIFMTU switch case.
- allow reception of Jumbo frames all the time on GEnesis based cards,
same as Yukon based cards.

ok krw@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.54 2004/12/14 20:58:15 krw Exp $	*/
d995 1
d1721 1
d2483 5
@


1.54
log
@Fix off-by-one. From FreeBSD r1.87. Also in NetBSD. Field being filled
(sk_vpd_readonly) is not currently used, but the memory being tromped
on might be.

ok millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.53 2004/12/08 04:26:53 brad Exp $	*/
d993 1
a993 1
		else
d995 2
a996 1
		sk_init(sc_if);
d2291 1
a2291 4
	if (ifp->if_mtu > ETHER_MAX_LEN)
		SK_XM_SETBIT_2(sc_if, XM_RXCMD, XM_RXCMD_BIGPKTOK);
	else
		SK_XM_CLRBIT_2(sc_if, XM_RXCMD, XM_RXCMD_BIGPKTOK);
d2345 1
a2345 1
	u_int32_t		/*mac, */phy;
@


1.53
log
@use ETHER_MAX_LEN
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.52 2004/12/08 01:45:04 krw Exp $	*/
d384 1
a384 1
	for (i = 0; i < res.vr_len + 1; i++)
@


1.52
log
@Enable jumbo frames on Yukon varients of sk(4).

ok mcbride@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.51 2004/11/16 19:34:58 brad Exp $	*/
d2290 1
a2290 1
	if (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))
@


1.51
log
@Lower interrupt moderation timer to decrease service latency.

From NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.50 2004/11/16 17:45:54 brad Exp $	*/
d2428 2
a2429 1
		      YU_SMR_MFL_VLAN | YU_SMR_IPG_DATA(0x1e));
@


1.50
log
@back out previous commit and put the right change in which corresponds
to what the previous commit message said...

Fix tx queue (slist can be corrupted when tx interrupts hit within tx_encap).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.48 2004/11/11 19:08:00 brad Exp $	*/
d1121 1
a1121 1
        sk_win_write_4(sc, SK_IMTIMERINIT, SK_IM_USECS(200));
@


1.49
log
@Fix tx queue (slist can be corrupted when tx interrupts hit within tx_encap).

From NetBSD

ok henning@@ mcbride@@
@
text
@d384 1
a384 1
	for (i = 0; i < res.vr_len; i++)
a596 2
	case SK_YUKON_LITE:
	case SK_YUKON_LP:
a634 2
				case SK_YUKON_LITE:
				case SK_YUKON_LP:
a655 2
	case SK_YUKON_LITE:
	case SK_YUKON_LP:
d716 1
a716 1
	SLIST_INIT(&sc_if->sk_txmap_listhead);
d737 1
a737 1
		SLIST_INSERT_HEAD(&sc_if->sk_txmap_listhead, entry, link);
a1007 2
				case SK_YUKON_LITE:
				case SK_YUKON_LP:
a1021 2
				case SK_YUKON_LITE:
				case SK_YUKON_LP:
d1087 1
a1087 1
	if (SK_YUKON_FAMILY(sc->sk_type))
d1094 1
a1094 1
	if (SK_YUKON_FAMILY(sc->sk_type))
a1296 2
	case SK_YUKON_LITE:
	case SK_YUKON_LP:
a1313 2
	case SK_YUKON_LITE:
	case SK_YUKON_LP:
a1381 1
	char *revstr;
d1422 22
a1479 8
	sc->sk_type = sk_win_read_1(sc, SK_CHIPVER);
	sc->sk_rev = (sk_win_read_1(sc, SK_CONFIG) >> 4);

	/* bail out here if chip is not recognized */
	if ( sc->sk_type != SK_GENESIS && ! SK_YUKON_FAMILY(sc->sk_type)) {
		printf("%s: unknown chip type\n",sc->sk_dev.dv_xname);
		goto fail;
	}
a1560 80
	/* determine whether to name it with VPD or just make it up */
	/* Marvell Yukon VPD's can freqently be bogus */
	switch (pa->pa_id) {
	case PCI_ID_CODE(PCI_VENDOR_SCHNEIDERKOCH,
			 PCI_PRODUCT_SCHNEIDERKOCH_GE):
	case PCI_PRODUCT_SCHNEIDERKOCH_SK9821v2:
	case PCI_PRODUCT_3COM_3C940:
	case PCI_PRODUCT_DLINK_DGE530T:
	case PCI_PRODUCT_LINKSYS_EG1032:
	case PCI_PRODUCT_LINKSYS_EG1064:
	case PCI_ID_CODE(PCI_VENDOR_SCHNEIDERKOCH,
			 PCI_PRODUCT_SCHNEIDERKOCH_SK9821v2):
	case PCI_ID_CODE(PCI_VENDOR_3COM,PCI_PRODUCT_3COM_3C940):
	case PCI_ID_CODE(PCI_VENDOR_DLINK,PCI_PRODUCT_DLINK_DGE530T):
	case PCI_ID_CODE(PCI_VENDOR_LINKSYS,PCI_PRODUCT_LINKSYS_EG1032):
	case PCI_ID_CODE(PCI_VENDOR_LINKSYS,PCI_PRODUCT_LINKSYS_EG1064):
 		sc->sk_name = sc->sk_vpd_prodname;
 		break;
	case PCI_ID_CODE(PCI_VENDOR_MARVELL,PCI_PRODUCT_MARVELL_SK_V2):
	case PCI_ID_CODE(PCI_VENDOR_MARVELL,PCI_PRODUCT_MARVELL_SK_V2_BELKIN):
	/* whoops Yukon VPD prodname bears no resemblance to reality */
		switch (sc->sk_type) {
		case SK_GENESIS:
			sc->sk_name = sc->sk_vpd_prodname;
			break;
		case SK_YUKON:
			sc->sk_name = "Marvell Yukon Gigabit Ethernet";
			break;
		case SK_YUKON_LITE:
			sc->sk_name = "Marvell Yukon Lite Gigabit Ethernet";
			break;
		case SK_YUKON_LP:
			sc->sk_name = "Marvell Yukon LP Gigabit Ethernet";
			break;
		default:
			sc->sk_name = "Marvell Yukon (Unknown) Gigabit Ethernet";
		}

	/* Yukon Lite Rev A0 needs special test, from sk98lin driver */
		if ( sc->sk_type == SK_YUKON ) {
			uint32_t flashaddr;
			uint8_t testbyte;
			
			flashaddr = sk_win_read_4(sc,SK_EP_ADDR);
			
			/* test Flash-Address Register */
			sk_win_write_1(sc,SK_EP_ADDR+3, 0xff);
			testbyte = sk_win_read_1(sc, SK_EP_ADDR+3);
			
			if (testbyte != 0) {
				/* This is a Yukon Lite Rev A0 */
				sc->sk_type = SK_YUKON_LITE;
				sc->sk_rev = SK_YUKON_LITE_REV_A0;
				/* restore Flash-Address Register */
				sk_win_write_4(sc,SK_EP_ADDR,flashaddr);
			}
		}
		break;
	default:
		sc->sk_name = "Unkown Marvell";
	}
		
	if ( sc->sk_type == SK_YUKON_LITE ) {
		switch (sc->sk_rev) {
		case SK_YUKON_LITE_REV_A0:
			revstr = "A0";
			break;
		case SK_YUKON_LITE_REV_A1:
			revstr = "A1";
			break;
		case SK_YUKON_LITE_REV_A3:
			revstr = "A3";
			break;
		default:
			revstr = "";
		}
	} else {
		revstr = "";
	}

d1562 1
a1562 2
	printf("%s: %s rev. %s(0x%x)\n", sc->sk_dev.dv_xname,
		sc->sk_name, revstr, sc->sk_rev);
d1591 1
a1591 1
	entry = SLIST_FIRST(&sc_if->sk_txmap_listhead);
d1637 1
a1637 1
	SLIST_REMOVE_HEAD(&sc_if->sk_txmap_listhead, link);
d1943 1
a1943 1
			SLIST_INSERT_HEAD(&sc_if->sk_txmap_listhead, entry,
a2508 2
	case SK_YUKON_LITE:
	case SK_YUKON_LP:
d2594 1
a2594 1
	if (SK_YUKON_FAMILY(sc->sk_type)) {
a2642 2
	case SK_YUKON_LITE:
	case SK_YUKON_LP:
@


1.48
log
@- Fix Yukon ram sizing.
- Keep tx queue running by kicking the tx bmu repeatedly.
- Handle if_timer a bit better.

From NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.47 2004/10/14 15:27:39 brad Exp $	*/
d384 1
a384 1
	for (i = 0; i < res.vr_len + 1; i++)
d597 2
d637 2
d660 2
d1014 2
d1030 2
d1097 1
a1097 1
	if (sc->sk_type == SK_YUKON)
d1104 1
a1104 1
	if (sc->sk_type == SK_YUKON)
d1307 2
d1326 2
d1396 1
a1436 22
#define SK_MK_ID(vnd,prd) \
    (((vnd) << PCI_VENDOR_SHIFT) | ((prd) << PCI_PRODUCT_SHIFT))

	switch (pa->pa_id) {
	case SK_MK_ID(PCI_VENDOR_SCHNEIDERKOCH, PCI_PRODUCT_SCHNEIDERKOCH_GE):
		sc->sk_type = SK_GENESIS;
		break;
	case SK_MK_ID(PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C940):
	case SK_MK_ID(PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_DGE530T):
	case SK_MK_ID(PCI_VENDOR_LINKSYS, PCI_PRODUCT_LINKSYS_EG1032):
	case SK_MK_ID(PCI_VENDOR_LINKSYS, PCI_PRODUCT_LINKSYS_EG1064):
	case SK_MK_ID(PCI_VENDOR_MARVELL, PCI_PRODUCT_MARVELL_SK_V2):
	case SK_MK_ID(PCI_VENDOR_MARVELL, PCI_PRODUCT_MARVELL_SK_V2_BELKIN):
	case SK_MK_ID(PCI_VENDOR_SCHNEIDERKOCH, PCI_PRODUCT_SCHNEIDERKOCH_SK9821v2):
		sc->sk_type = SK_YUKON;
		break;
	default:
		printf(": unknown device!\n");
		goto fail;
	}
#undef SK_MK_ID

d1473 8
d1562 80
d1643 2
a1644 1
	printf("%s: %s\n", sc->sk_dev.dv_xname, sc->sk_vpd_prodname);
d2591 2
d2678 1
a2678 1
	if (sc->sk_type == SK_YUKON) {
d2727 2
@


1.47
log
@Bail out quietly if the eeprom appears to be missing or empty. Fixes
support for D-Link DGE-530T adapters.

From: FreeBSD via Blake Willis <blake at 2112 dot net>

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.46 2004/09/23 17:45:16 brad Exp $	*/
a1530 4

		DPRINTFN(2, ("skc_attach: ramsize=%d(%dk), rboff=%d\n",
			     sc->sk_ramsize, sc->sk_ramsize / 1024,
			     sc->sk_rboff));
d1532 2
a1533 1
		sc->sk_ramsize = 0x20000;
d1535 1
d1537 3
a1539 4
		DPRINTFN(2, ("skc_attach: ramsize=%dk (%d), rboff=%d\n",
			     sc->sk_ramsize / 1024, sc->sk_ramsize,
			     sc->sk_rboff));
	}
d1949 2
d1952 2
a1953 1
	}
@


1.46
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.45 2004/08/20 06:17:05 deraadt Exp $	*/
d351 6
a544 2
#define XMAC_POLY	0xEDB88320
#define GMAC_POLY	0x04C11DB7L
@


1.45
log
@a belkin ID on a sk card
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.44 2004/08/19 16:31:42 mcbride Exp $	*/
a1274 1
	ifp->if_mtu = ETHERMTU;
a1276 1
	ifp->if_output = ether_output;
@


1.44
log
@Don't complain about lack of jumbo storage when processing incoming packets
unless we're debugging.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.43 2004/08/05 19:57:17 brad Exp $	*/
d224 1
d1432 1
@


1.43
log
@remove some separate per driver constants and use
ETHER_MAX_LEN_JUMBO/ETHERMTU_JUMBO where appropriate.

ok mcbride@@ henning@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.42 2004/08/04 19:37:26 mcbride Exp $	*/
d885 2
a886 1
		printf("%s: no free jumbo buffers\n", sc_if->sk_dev.dv_xname);
@


1.42
log
@Make jumbo frames work.
- allocate and manage our own memory for rx packets rather than using
  mbuf clusters; code for this lifted from if_bge.c
- pass the correct size to bus_dmamap_create()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.41 2004/05/29 16:09:41 naddy Exp $	*/
d985 1
a985 1
		if (ifr->ifr_mtu > SK_JUMBO_MTU)
@


1.41
log
@replace hand-rolled CRC calculation in multicast hash setup with calls to
ether_crc32_*(); ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.40 2004/05/24 14:15:43 naddy Exp $	*/
d161 4
d684 2
a685 1
		if (sk_newbuf(sc_if, i, NULL, NULL) == ENOBUFS) {
d691 1
d722 2
a723 2
		if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, SK_NTXSEG,
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &dmamap))
a745 1
	struct sk_softc		*sc = sc_if->sk_softc;
d750 2
a751 13
	if (dmamap == NULL) {
		/* if (m) panic() */

		if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, 1, MCLBYTES,
				      0, BUS_DMA_NOWAIT, &dmamap)) {
			printf("%s: can't create recv map\n",
			       sc_if->sk_dev.dv_xname);
			return(ENOMEM);
		}
	} else if (m == NULL)
		bus_dmamap_unload(sc->sc_dmatag, dmamap);

	sc_if->sk_cdata.sk_rx_map[i] = dmamap;
a752 1
	if (m == NULL) {
d756 1
a756 1

d758 2
a759 2
		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
d761 3
a763 1
			return (ENOBUFS);
d766 3
a768 7
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;

		m_adj(m_new, ETHER_ALIGN);

		if (bus_dmamap_load_mbuf(sc->sc_dmatag, dmamap, m_new,
					 BUS_DMA_NOWAIT))
			return(ENOBUFS);
d776 1
a776 2
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_adj(m_new, ETHER_ALIGN);
d779 1
d784 86
a869 2
	r->sk_data_lo = dmamap->dm_segs[0].ds_addr;
	r->sk_ctl = dmamap->dm_segs[0].ds_len | SK_RXSTAT;
d875 52
d1180 1
a1180 1
	 * dual port NIC. Our algotithm is to divide up the memory
d1265 6
d1763 1
a1763 2
		dmamap = sc_if->sk_cdata.sk_rx_map[cur];
		sc_if->sk_cdata.sk_rx_map[cur] = 0;
@


1.40
log
@Make Yukon-style adapters also set up the multicast filter in sk_init().
This fixes various multicast-related problems.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.39 2004/04/09 21:52:17 henning Exp $	*/
d175 2
a176 2
u_int32_t xmac_calchash (caddr_t);
u_int32_t gmac_calchash (caddr_t);
d539 1
a539 1
xmac_calchash(caddr_t addr)
d541 1
a541 9
	u_int32_t		idx, bit, data, crc;

	/* Compute CRC for the address value. */
	crc = 0xFFFFFFFF; /* initial value */

	for (idx = 0; idx < 6; idx++) {
		for (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)
			crc = (crc >> 1) ^ (((crc ^ data) & 1) ? XMAC_POLY : 0);
	}
d543 1
d548 1
a548 1
gmac_calchash(caddr_t addr)
d550 1
a550 1
	u_int32_t               idx, bit, crc, tmpData, data;
d552 1
a552 29
	/* Compute CRC for the address value. */
	crc = 0xFFFFFFFF; /* initial value */
	
	for (idx = 0; idx < 6; idx++) {
		data = *addr++;
		
		/* Change bit order in byte. */
		tmpData = data;
		for (bit = 0; bit < 8; bit++) {
			if (tmpData & 1) {
				data |=  1 << (7 - bit);
			}
			else {
				data &= ~(1 << (7 - bit));
			}
			
			tmpData >>= 1;
		}
		
		crc ^= (data << 24);
		for (bit = 0; bit < 8; bit++) {
			if (crc & 0x80000000) {
				crc = (crc << 1) ^ GMAC_POLY;
			} else {
				crc <<= 1;
			}
		}
	}
	
d622 1
a622 1
					h = xmac_calchash(enm->enm_addrlo);
d626 1
a626 1
					h = gmac_calchash(enm->enm_addrlo);
@


1.39
log
@do not whine if we cannot get mbufs. the countless printfd makes the machine
crawl under mbuf starvation, making the situationmuch worse, and don't make
sense in the first place.
ok tdeval@@ millert@@ beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.38 2004/03/09 20:39:56 matthieu Exp $	*/
d2343 1
a2343 1
	/* clear all Multicast filter hash registers */
d2345 1
a2345 4
	SK_YU_WRITE_2(sc_if, YUKON_MCAH1, 0);
	SK_YU_WRITE_2(sc_if, YUKON_MCAH2, 0);
	SK_YU_WRITE_2(sc_if, YUKON_MCAH3, 0);
	SK_YU_WRITE_2(sc_if, YUKON_MCAH4, 0);
@


1.38
log
@Fix multicast on recent sk chipsets. Adapted from a patch by Keith Mitchell
in <http://lists.freebsd.org/pipermail/freebsd-hardware/2003-December/000851.html>
Ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.37 2003/12/17 17:43:03 jason Exp $	*/
d796 1
a796 3
		if (m_new == NULL) {
			printf("%s: no memory for rx list -- "
			    "packet dropped!\n", sc_if->sk_dev.dv_xname);
a797 1
		}
a1691 3
				printf("%s: no receive buffers "
				    "available -- packet dropped!\n",
				    sc_if->sk_dev.dv_xname);
@


1.37
log
@not qualifying a product based on vendor AND product ID just bugs me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.36 2003/12/17 17:26:20 jason Exp $	*/
d175 2
a176 1
u_int32_t sk_calchash(caddr_t);
d534 4
a537 3
#define SK_BITS		6
#define SK_POLY	0xEDB88320

d539 1
a539 1
sk_calchash(caddr_t addr)
d548 1
a548 1
			crc = (crc >> 1) ^ (((crc ^ data) & 1) ? SK_POLY : 0);
d551 38
a588 1
	return (~crc & ((1 << SK_BITS) - 1));
d655 9
a663 1
				h = sk_calchash(enm->enm_addrlo);
@


1.36
log
@marvell skv2 (smc9452TX); from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.35 2003/12/17 16:53:46 jason Exp $	*/
d1276 5
a1280 2
	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_SCHNEIDERKOCH_GE:
d1283 6
a1288 5
	case PCI_PRODUCT_SCHNEIDERKOCH_SK9821v2:
	case PCI_PRODUCT_3COM_3C940:
	case PCI_PRODUCT_DLINK_DGE530T:
	case PCI_PRODUCT_LINKSYS_EG1032:
	case PCI_PRODUCT_LINKSYS_EG1064:
d1295 1
@


1.35
log
@add support for linksys (eg1032v2, eg1064v2) and dlink (dge530t); from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.34 2003/10/13 21:22:19 jason Exp $	*/
d218 1
@


1.34
log
@rx checksum offload support (based on earlier code from aaron@@, but with
fixes by me).  Note: sk v1 chips can sometimes compute an incorrect cksum.
To deal with that, we never set the "bad" flags.  Ie. if the card says it's
good, we assume it's good.  If the card says it's bad, we fall back to
software.  Ugly?  You betcha.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.33 2003/08/12 05:23:06 nate Exp $	*/
d215 3
d1281 3
@


1.33
log
@add/update my copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.32 2003/08/01 04:46:13 nate Exp $	*/
d110 2
d116 1
d164 1
a164 2
void sk_vpd_read_res(struct sk_softc *,
					struct vpd_res *, int);
d179 1
d658 3
a1270 5
	command |= PCI_COMMAND_IO_ENABLE |
	    PCI_COMMAND_MEM_ENABLE |
	    PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
d1593 1
d1612 3
d1651 2
d1657 1
d1663 91
@


1.32
log
@Support for new Marvell based Gigabit Ethernet adapters
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.31 2003/05/14 01:54:15 nate Exp $	*/
d35 16
@


1.31
log
@Makefile sk(4) use bus_dma
ok jason
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.30 2003/05/08 04:20:05 nate Exp $	*/
a110 1
#define SK_USEIOSPACE
d112 1
d116 1
a122 1
int sk_attach_xmac(struct sk_softc *, int);
d126 1
d134 1
a143 6
u_int32_t sk_win_read_4(struct sk_softc *, int);
u_int16_t sk_win_read_2(struct sk_softc *, int);
u_int8_t sk_win_read_1(struct sk_softc *, int);
void sk_win_write_4(struct sk_softc *, int, u_int32_t);
void sk_win_write_2(struct sk_softc *, int, u_int32_t);
void sk_win_write_1(struct sk_softc *, int, u_int32_t);
d149 7
a155 3
int sk_miibus_readreg(struct device *, int, int);
void sk_miibus_writereg(struct device *, int, int, int);
void sk_miibus_statchg(struct device *);
d162 13
d193 9
a201 2
u_int32_t
sk_win_read_4(struct sk_softc *sc, int reg)
d203 1
d205 4
a208 1
	return(CSR_READ_4(sc, SK_WIN_BASE + SK_REG(reg)));
d211 2
a212 2
u_int16_t
sk_win_read_2(struct sk_softc *sc, int reg)
d214 1
d216 4
a219 1
	return(CSR_READ_2(sc, SK_WIN_BASE + SK_REG(reg)));
d222 2
a223 2
u_int8_t
sk_win_read_1(struct sk_softc *sc, int reg)
d225 1
d227 4
a230 1
	return(CSR_READ_1(sc, SK_WIN_BASE + SK_REG(reg)));
d233 2
a234 2
void
sk_win_write_4(struct sk_softc *sc, int reg, u_int32_t val)
d236 1
d238 4
a241 1
	CSR_WRITE_4(sc, SK_WIN_BASE + SK_REG(reg), val);
d244 2
a245 2
void
sk_win_write_2(struct sk_softc *sc, int reg, u_int32_t val)
d247 1
d249 4
a252 1
	CSR_WRITE_2(sc, SK_WIN_BASE + SK_REG(reg), (u_int32_t)val);
d255 2
a256 2
void
sk_win_write_1(struct sk_softc *sc, int reg, u_int32_t val)
d258 1
d260 4
a263 1
	CSR_WRITE_1(sc, SK_WIN_BASE + SK_REG(reg), val);
d354 1
a354 1
sk_miibus_readreg(struct device *dev, int phy, int reg)
d359 2
d385 1
a385 1
sk_miibus_writereg(struct device *dev, int phy, int reg, int val)
d390 2
d416 1
a416 1
sk_miibus_statchg(struct device *dev)
d421 2
d436 74
a509 1
#define SK_POLY		0xEDB88320
d511 1
d542 2
a543 1
	struct ifnet *ifp = &sc_if->arpcom.ac_if;
d552 15
a566 4
	for (i = 1; i < XM_RXFILT_MAX; i++)
		sk_setfilt(sc_if, (caddr_t)&dummy, i);
	SK_XM_WRITE_4(sc_if, XM_MAR0, 0);
	SK_XM_WRITE_4(sc_if, XM_MAR2, 0);
d578 2
a579 1
			if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
d588 1
a588 1
			if (i < XM_RXFILT_MAX) {
d604 14
a617 4
	SK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_USE_HASH|
	    XM_MODE_RX_USE_PERFECT);
	SK_XM_WRITE_4(sc_if, XM_MAR0, hashes[0]);
	SK_XM_WRITE_4(sc_if, XM_MAR2, hashes[1]);
d794 1
d834 10
a843 2
				SK_XM_SETBIT_4(sc_if, XM_MODE,
				    XM_MODE_RX_PROMISC);
d848 11
a858 2
				SK_XM_CLRBIT_4(sc_if, XM_MODE,
				    XM_MODE_RX_PROMISC);
d906 2
a907 7
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SCHNEIDERKOCH &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SCHNEIDERKOCH_GE)
		return (1);

	return (0);
d915 7
a921 2
	CSR_WRITE_4(sc, SK_CSR, SK_CSR_SW_RESET);
	CSR_WRITE_4(sc, SK_CSR, SK_CSR_MASTER_RESET);
d923 18
a940 9
	CSR_WRITE_4(sc, SK_CSR, SK_CSR_SW_UNRESET);
	CSR_WRITE_4(sc, SK_CSR, SK_CSR_MASTER_UNRESET);

	/* Configure packet arbiter */
	sk_win_write_2(sc, SK_PKTARB_CTL, SK_PKTARBCTL_UNRESET);
	sk_win_write_2(sc, SK_RXPA1_TINIT, SK_PKTARB_TIMEOUT);
	sk_win_write_2(sc, SK_TXPA1_TINIT, SK_PKTARB_TIMEOUT);
	sk_win_write_2(sc, SK_RXPA2_TINIT, SK_PKTARB_TIMEOUT);
	sk_win_write_2(sc, SK_TXPA2_TINIT, SK_PKTARB_TIMEOUT);
d993 3
a995 1
	
d1046 5
d1060 3
d1120 14
a1133 1
	sk_init_xmac(sc_if);
d1135 13
a1147 3
	sc_if->sk_mii.mii_readreg = sk_miibus_readreg;
	sc_if->sk_mii.mii_writereg = sk_miibus_writereg;
	sc_if->sk_mii.mii_statchg = sk_miibus_statchg;
d1155 1
a1155 1
		    0, NULL);
d1164 2
d1172 2
d1211 2
d1219 1
a1220 1

d1255 13
d1299 2
d1304 2
d1329 32
a1360 4
	/* Read and save RAM size and RAMbuffer offset */
	switch(sk_win_read_1(sc, SK_EPROM0)) {
	case SK_RAMSIZE_512K_64:
		sc->sk_ramsize = 0x80000;
d1362 4
a1365 18
		break;
	case SK_RAMSIZE_1024K_64:
		sc->sk_ramsize = 0x100000;
		sc->sk_rboff = SK_RBOFF_80000;
		break;
	case SK_RAMSIZE_1024K_128:
		sc->sk_ramsize = 0x100000;
		sc->sk_rboff = SK_RBOFF_0;
		break;
	case SK_RAMSIZE_2048K_128:
		sc->sk_ramsize = 0x200000;
		sc->sk_rboff = SK_RBOFF_0;
		break;
	default:
		printf("%s: unknown ram size: %d\n",
		    sc->sk_dev.dv_xname, sk_win_read_1(sc, SK_EPROM0));
		goto fail;
		break;
d1416 2
d1419 4
a1422 2
	if (entry == NULL)
		return (ENOBUFS);
d1427 5
d1437 3
a1439 1
	if (bus_dmamap_load_mbuf(sc->sc_dmatag, txmap, m_head, BUS_DMA_NOWAIT))
d1441 3
d1446 2
a1447 1
		if ((SK_TX_RING_CNT - (sc_if->sk_cdata.sk_tx_cnt + cnt)) < 2)
d1449 1
d1457 1
d1471 11
d1484 2
d1498 2
d1554 2
d1577 2
d1650 2
d1659 4
d1699 2
d1741 3
d1750 1
a1750 1
	status = sk_miibus_readreg((struct device *)sc_if,
d1760 1
a1760 1
		lstat = sk_miibus_readreg((struct device *)sc_if,
d1770 1
a1770 1
			sk_miibus_writereg((struct device *)sc_if,
d1793 2
d1813 11
d1841 2
d1873 14
a1886 7
		if (status & SK_ISR_MAC1 &&
		    ifp0->if_flags & IFF_RUNNING)
			sk_intr_xmac(sc_if0);

		if (status & SK_ISR_MAC2 &&
		    ifp1->if_flags & IFF_RUNNING)
			sk_intr_xmac(sc_if1);
d1889 2
a1890 1
			if (ifp0 != NULL)
d1892 3
a1894 1
			if (ifp1 != NULL)
d1920 2
d1952 2
a1953 2
		sk_miibus_writereg((struct device *)sc_if, SK_PHYADDR_BCOM,
		    BRGPHY_MII_BMCR, BRGPHY_BMCR_RESET);
d1955 2
a1956 2
		sk_miibus_writereg((struct device *)sc_if, SK_PHYADDR_BCOM,
		    BRGPHY_MII_IMR, 0xFFF0);
d1964 1
a1964 1
		if (sk_miibus_readreg((struct device *)sc_if,
d1967 1
a1967 1
				sk_miibus_writereg((struct device *)sc_if,
d2074 125
d2212 2
d2219 14
a2232 9
	/* Configure LINK_SYNC LED */
	SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_ON);
	SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_LINKSYNC_ON);

	/* Configure RX LED */
	SK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL, SK_RXLEDCTL_COUNTER_START);

	/* Configure TX LED */
	SK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_TXLEDCTL_COUNTER_START);
d2237 8
a2244 1
	sk_init_xmac(sc_if);
d2247 10
a2256 8
	/* Configure MAC FIFOs */
	SK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_UNRESET);
	SK_IF_WRITE_4(sc_if, 0, SK_RXF1_END, SK_FIFO_END);
	SK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_ON);

	SK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_UNRESET);
	SK_IF_WRITE_4(sc_if, 0, SK_TXF1_END, SK_FIFO_END);
	SK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_ON);
d2320 14
a2333 3
	/* Enable XMACs TX and RX state machines */
	SK_XM_CLRBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_IGNPAUSE);
	SK_XM_SETBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_TX_ENB|XM_MMUCMD_RX_ENB);
d2348 2
d2369 11
a2379 2
	SK_IF_WRITE_2(sc_if, 0, SK_TXF1_MACCTL, SK_TXMACCTL_XMAC_RESET);
	SK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_RESET);
d2433 72
@


1.30
log
@a bit more cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.29 2003/05/08 02:16:37 nate Exp $	*/
a102 3
#include <uvm/uvm_extern.h>              /* for vtophys */
#include <machine/bus.h>

d139 1
a139 2
int sk_newbuf(struct sk_if_softc *, struct sk_chain *,
    struct mbuf *);
d141 1
a141 1
void sk_init_tx_ring(struct sk_if_softc *);
d485 11
a495 1
		if (sk_newbuf(sc_if, &cd->sk_rx_chain[i], NULL) == ENOBUFS) {
a499 11
		if (i == (SK_RX_RING_CNT - 1)) {
			cd->sk_rx_chain[i].sk_next =
			    &cd->sk_rx_chain[0];
			rd->sk_rx_ring[i].sk_next = 
			    vtophys(&rd->sk_rx_ring[0]);
		} else {
			cd->sk_rx_chain[i].sk_next =
			    &cd->sk_rx_chain[i + 1];
			rd->sk_rx_ring[i].sk_next = 
			    vtophys(&rd->sk_rx_ring[i + 1]);
		}
a500 1

d507 1
a507 1
void
d510 1
d513 2
d520 1
d524 2
a525 4
			cd->sk_tx_chain[i].sk_next =
			    &cd->sk_tx_chain[0];
			rd->sk_tx_ring[i].sk_next = 
			    vtophys(&rd->sk_tx_ring[0]);
d527 2
a528 4
			cd->sk_tx_chain[i].sk_next =
			    &cd->sk_tx_chain[i + 1];
			rd->sk_tx_ring[i].sk_next = 
			    vtophys(&rd->sk_tx_ring[i + 1]);
d530 12
d547 2
d552 2
a553 1
sk_newbuf(struct sk_if_softc *sc_if, struct sk_chain *c, struct mbuf *m)
d555 1
d557 1
d560 14
d588 8
d603 2
a606 8
	m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;

	/*
	 * Adjust alignment so packet payload begins on a
	 * longword boundary. Mandatory for Alpha, useful on
	 * x86 too.
	 */
	m_adj(m_new, ETHER_ALIGN);
d608 1
d611 2
a612 2
	r->sk_data_lo = vtophys(mtod(m_new, caddr_t));
	r->sk_ctl = m_new->m_len | SK_RXSTAT;
a808 1
	bus_dmamap_t dmamap;
d899 2
a900 1
	    sizeof(struct sk_ring_data), 0, BUS_DMA_NOWAIT, &dmamap)) {
d907 1
a907 1
	if (bus_dmamap_load(sc->sc_dmatag, dmamap, kva,
d910 1
a910 1
		bus_dmamap_destroy(sc->sc_dmatag, dmamap);
d1165 1
a1166 1
	struct mbuf		*m;
d1168 8
d1184 16
a1199 16
	for (m = m_head; m != NULL; m = m->m_next) {
		if (m->m_len != 0) {
			if ((SK_TX_RING_CNT -
			    (sc_if->sk_cdata.sk_tx_cnt + cnt)) < 2)
				return(ENOBUFS);
			f = &sc_if->sk_rdata->sk_tx_ring[frag];
			f->sk_data_lo = vtophys(mtod(m, vaddr_t));
			f->sk_ctl = m->m_len | SK_OPCODE_DEFAULT;
			if (cnt == 0)
				f->sk_ctl |= SK_TXCTL_FIRSTFRAG;
			else
				f->sk_ctl |= SK_TXCTL_OWN;
			cur = frag;
			SK_INC(frag, SK_TX_RING_CNT);
			cnt++;
		}
d1202 3
a1204 3
	if (m != NULL)
		return(ENOBUFS);

a1206 1
	sc_if->sk_cdata.sk_tx_chain[cur].sk_mbuf = m_head;
d1294 2
a1295 2
	int			total_len = 0;
	int			i;
d1297 1
a1299 1
	cur_rx = &sc_if->sk_cdata.sk_rx_chain[i];
d1302 3
d1306 1
a1306 2
		cur_rx = &sc_if->sk_cdata.sk_rx_chain[i];
		rxstat = sc_if->sk_rdata->sk_rx_ring[i].sk_xmac_rxstat;
d1309 5
a1313 1
		total_len = SK_RXBYTES(sc_if->sk_rdata->sk_rx_ring[i].sk_ctl);
d1318 1
a1318 1
			sk_newbuf(sc_if, cur_rx, m);
d1329 1
a1329 1
		if (sk_newbuf(sc_if, cur_rx, NULL) == ENOBUFS) {
d1333 1
a1333 1
			sk_newbuf(sc_if, cur_rx, m);
d1364 1
d1368 1
d1384 9
d1822 1
a1822 1
	    vtophys(&sc_if->sk_rdata->sk_rx_ring[0]));
d1827 1
a1827 1
	    vtophys(&sc_if->sk_rdata->sk_tx_ring[0]));
d1838 8
a1845 1
	sk_init_tx_ring(sc_if);
@


1.29
log
@ansify, clean up formatting, remove useless return statements.
ok jason
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.28 2003/03/12 17:05:43 nate Exp $	*/
d374 2
a375 5
	struct sk_if_softc *sc_if;
	struct mii_data *mii;

	sc_if = (struct sk_if_softc *)dev;
	mii = &sc_if->sk_mii;
d422 1
a422 1
	struct ifnet *ifp;
a429 2
	ifp = &sc_if->arpcom.ac_if;

d480 2
a481 2
	struct sk_chain_data	*cd;
	struct sk_ring_data	*rd;
a483 3
	cd = &sc_if->sk_cdata;
	rd = sc_if->sk_rdata;

a1140 1
	m = m_head;
@


1.28
log
@sk is capable of transmitting and receiving longer packets for 802.1q vlans
thanks to David Gwynne <loki@@niteshade.net>.  ok jason@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.27 2003/01/15 06:31:24 art Exp $	*/
d184 2
a185 3
u_int32_t sk_win_read_4(sc, reg)
	struct sk_softc		*sc;
	int			reg;
d191 2
a192 3
u_int16_t sk_win_read_2(sc, reg)
	struct sk_softc		*sc;
	int			reg;
d198 2
a199 3
u_int8_t sk_win_read_1(sc, reg)
	struct sk_softc		*sc;
	int			reg;
d205 2
a206 4
void sk_win_write_4(sc, reg, val)
	struct sk_softc		*sc;
	int			reg;
	u_int32_t		val;
a209 1
	return;
d212 2
a213 4
void sk_win_write_2(sc, reg, val)
	struct sk_softc		*sc;
	int			reg;
	u_int32_t		val;
a216 1
	return;
d219 2
a220 4
void sk_win_write_1(sc, reg, val)
	struct sk_softc		*sc;
	int			reg;
	u_int32_t		val;
a223 1
	return;
d237 2
a238 3
u_int8_t sk_vpd_readbyte(sc, addr)
	struct sk_softc		*sc;
	int			addr;
d256 2
a257 4
void sk_vpd_read_res(sc, res, addr)
	struct sk_softc		*sc;
	struct vpd_res		*res;
	int			addr;
a264 2

	return;
d267 2
a268 2
void sk_vpd_read(sc)
	struct sk_softc		*sc;
a310 2

	return;
d314 1
a314 3
sk_miibus_readreg(dev, phy, reg)
	struct device *dev;
	int phy, reg;
d343 1
a343 3
sk_miibus_writereg(dev, phy, reg, val)
	struct device *dev;
	int phy, reg, val;
a368 2

	return;
d372 1
a372 2
sk_miibus_statchg(dev)
	struct device *dev;
a390 2

	return;
d396 2
a397 2
u_int32_t sk_calchash(addr)
	caddr_t			addr;
d412 2
a413 4
void sk_setfilt(sc_if, addr, slot)
	struct sk_if_softc	*sc_if;
	caddr_t			addr;
	int			slot;
d415 1
a415 3
	int			base;

	base = XM_RXFILT_ENTRY(slot);
a419 2

	return;
d423 1
a423 2
sk_setmulti(sc_if)
	struct sk_if_softc	*sc_if;
a479 2

	return;
d482 2
a483 2
int sk_init_rx_ring(sc_if)
	struct sk_if_softc	*sc_if;
d521 2
a522 2
void sk_init_tx_ring(sc_if)
	struct sk_if_softc	*sc_if;
d524 2
a525 2
	struct sk_chain_data	*cd;
	struct sk_ring_data	*rd;
a527 3
	cd = &sc_if->sk_cdata;
	rd = sc_if->sk_rdata;

a548 2

	return;
d551 2
a552 4
int sk_newbuf(sc_if, c, m)
	struct sk_if_softc	*sc_if;
	struct sk_chain		*c;
	struct mbuf		*m;
d601 1
a601 2
sk_ifmedia_upd(ifp)
	struct ifnet *ifp;
d614 1
a614 3
sk_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
d624 1
a624 4
sk_ioctl(ifp, command, data)
	struct ifnet *ifp;
	u_long command;
	caddr_t data;
d719 1
a719 3
skc_probe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d733 1
a733 2
void sk_reset(sc)
	struct sk_softc		*sc;
a762 2

	return;
d766 1
a766 3
sk_probe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d781 1
a781 3
sk_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d950 1
a950 3
skcprint(aux, pnp)
	void *aux;
	const char *pnp;
d967 1
a967 3
skc_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d1142 2
a1143 4
int sk_encap(sc_if, m_head, txidx)
        struct sk_if_softc	*sc_if;
        struct mbuf		*m_head;
        u_int32_t		*txidx;
d1189 2
a1190 2
void sk_start(ifp)
	struct ifnet		*ifp;
d1192 2
a1193 2
        struct sk_softc		*sc;
        struct sk_if_softc	*sc_if;
d1195 1
a1195 1
        u_int32_t		idx;
a1197 5
	sc_if = ifp->if_softc;
	sc = sc_if->sk_softc;

	idx = sc_if->sk_cdata.sk_tx_prod;

a1234 2

	return;
d1238 2
a1239 2
void sk_watchdog(ifp)
	struct ifnet		*ifp;
d1241 1
a1241 3
	struct sk_if_softc	*sc_if;

	sc_if = ifp->if_softc;
a1244 2

	return;
d1247 2
a1248 2
void sk_shutdown(v)
	void *v;
a1259 2

	return;
d1262 2
a1263 2
void sk_rxeof(sc_if)
	struct sk_if_softc	*sc_if;
d1265 1
a1266 1
	struct ifnet		*ifp;
a1271 1
	ifp = &sc_if->arpcom.ac_if;
a1326 2

	return;
d1329 2
a1330 2
void sk_txeof(sc_if)
	struct sk_if_softc	*sc_if;
d1333 1
a1333 1
	struct ifnet		*ifp;
a1335 2
	ifp = &sc_if->arpcom.ac_if;

a1359 2

	return;
d1363 1
a1363 2
sk_tick(xsc_if)
	void *xsc_if;
d1365 3
a1367 3
	struct sk_if_softc *sc_if;
	struct mii_data *mii;
	struct ifnet *ifp;
a1369 4
	sc_if = xsc_if;
	ifp = &sc_if->arpcom.ac_if;
	mii = &sc_if->sk_mii;

d1404 1
a1404 2
sk_intr_bcom(sc_if)
	struct sk_if_softc *sc_if;
d1406 2
a1407 3
	struct sk_softc *sc;
	struct mii_data *mii;
	struct ifnet *ifp;
a1409 4
	sc = sc_if->sk_softc;
	mii = &sc_if->sk_mii;
	ifp = &sc_if->arpcom.ac_if;

a1451 2

	return;
d1454 2
a1455 2
void sk_intr_xmac(sc_if)
	struct sk_if_softc	*sc_if;
d1457 1
a1457 5
	struct sk_softc		*sc;
	u_int16_t		status;

	sc = sc_if->sk_softc;
	status = SK_XM_READ_2(sc_if, XM_ISR);
a1474 2

	return;
d1477 2
a1478 2
int sk_intr(xsc)
	void			*xsc;
d1481 2
a1482 1
	struct sk_if_softc	*sc_if0 = NULL, *sc_if1 = NULL;
a1486 3
	sc_if0 = sc->sk_if[SK_PORT_A];
	sc_if1 = sc->sk_if[SK_PORT_B];

d1550 2
a1551 2
void sk_init_xmac(sc_if)
	struct sk_if_softc	*sc_if;
d1553 2
a1554 2
	struct sk_softc		*sc;
	struct ifnet		*ifp;
a1560 3
	sc = sc_if->sk_softc;
	ifp = &sc_if->arpcom.ac_if;

a1710 2

	return;
d1717 2
a1718 2
void sk_init(xsc)
	void			*xsc;
d1720 4
a1723 4
	struct sk_if_softc	*sc_if = xsc;
	struct sk_softc		*sc;
	struct ifnet		*ifp;
	struct mii_data		*mii;
a1727 4
	ifp = &sc_if->arpcom.ac_if;
	sc = sc_if->sk_softc;
	mii = &sc_if->sk_mii;

a1818 2

	return;
d1821 2
a1822 2
void sk_stop(sc_if)
	struct sk_if_softc	*sc_if;
d1824 2
a1826 5
	struct sk_softc		*sc;
	struct ifnet		*ifp;

	sc = sc_if->sk_softc;
	ifp = &sc_if->arpcom.ac_if;
a1884 2

	return;
@


1.27
log
@Get rid of the remaining vm_offset_t in pci drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.26 2002/11/26 06:01:28 nate Exp $	*/
d967 1
@


1.26
log
@1000baseTX -> 1000baseT
- More technically correct
- Matches FreeBSD and NetBSD
- Preserved #define for 1000baseTX for backwards compatibility
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.25 2002/06/08 23:32:16 jason Exp $	*/
d1227 1
a1227 1
			f->sk_data_lo = vtophys(mtod(m, vm_offset_t));
@


1.25
log
@add missing ioctl support for SIOCSIFMTU
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.24 2002/06/04 00:09:08 deraadt Exp $	*/
d1178 1
a1178 1
		sc->sk_pmd = IFM_1000_TX;
@


1.24
log
@spelling; raj@@cerias.purdue.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.23 2002/03/14 01:26:59 millert Exp $	*/
d703 7
@


1.23
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.22 2002/03/12 09:51:20 kjc Exp $	*/
d45 1
a45 1
 * Note: XaQti has been aquired by Vitesse, and Vitesse does not have the
d47 1
a47 1
 * convience to others until Vitesse corrects this problem:
@


1.22
log
@sync with KAME
ALTQify more drivers.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.21 2002/02/15 20:45:31 nordin Exp $	*/
d120 45
a164 45
int skc_probe		__P((struct device *, void *, void *));
void skc_attach		__P((struct device *, struct device *self, void *aux));
int sk_probe		__P((struct device *, void *, void *));
void sk_attach		__P((struct device *, struct device *self, void *aux));
int skcprint		__P((void *, const char *));
int sk_attach_xmac	__P((struct sk_softc *, int));
int sk_intr		__P((void *));
void sk_intr_bcom	__P((struct sk_if_softc *));
void sk_intr_xmac	__P((struct sk_if_softc *));
void sk_rxeof		__P((struct sk_if_softc *));
void sk_txeof		__P((struct sk_if_softc *));
int sk_encap		__P((struct sk_if_softc *, struct mbuf *, u_int32_t *));
void sk_start		__P((struct ifnet *));
int sk_ioctl		__P((struct ifnet *, u_long, caddr_t));
void sk_init		__P((void *));
void sk_init_xmac	__P((struct sk_if_softc *));
void sk_stop		__P((struct sk_if_softc *));
void sk_watchdog	__P((struct ifnet *));
void sk_shutdown	__P((void *));
int sk_ifmedia_upd	__P((struct ifnet *));
void sk_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));
void sk_reset		__P((struct sk_softc *));
int sk_newbuf		__P((struct sk_if_softc *, struct sk_chain *,
    struct mbuf *));
int sk_init_rx_ring	__P((struct sk_if_softc *));
void sk_init_tx_ring	__P((struct sk_if_softc *));
u_int32_t sk_win_read_4	__P((struct sk_softc *, int));
u_int16_t sk_win_read_2	__P((struct sk_softc *, int));
u_int8_t sk_win_read_1	__P((struct sk_softc *, int));
void sk_win_write_4	__P((struct sk_softc *, int, u_int32_t));
void sk_win_write_2	__P((struct sk_softc *, int, u_int32_t));
void sk_win_write_1	__P((struct sk_softc *, int, u_int32_t));
u_int8_t sk_vpd_readbyte	__P((struct sk_softc *, int));
void sk_vpd_read_res	__P((struct sk_softc *,
					struct vpd_res *, int));
void sk_vpd_read	__P((struct sk_softc *));

int sk_miibus_readreg	__P((struct device *, int, int));
void sk_miibus_writereg	__P((struct device *, int, int, int));
void sk_miibus_statchg	__P((struct device *));

u_int32_t sk_calchash	__P((caddr_t));
void sk_setfilt		__P((struct sk_if_softc *, caddr_t, int));
void sk_setmulti	__P((struct sk_if_softc *));
void sk_tick		__P((void *));
@


1.21
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.20 2002/01/11 01:31:21 nordin Exp $	*/
d960 2
a961 1
	ifp->if_snd.ifq_maxlen = SK_TX_RING_CNT - 1;
d1253 1
d1261 1
a1261 1
		IF_DEQUEUE(&ifp->if_snd, m_head);
a1270 1
			IF_PREPEND(&ifp->if_snd, m_head);
d1275 4
d1288 2
d1640 1
a1640 1
	if (ifp0 != NULL && ifp0->if_snd.ifq_head != NULL)
d1642 1
a1642 1
	if (ifp1 != NULL && ifp1->if_snd.ifq_head != NULL)
@


1.20
log
@Check result from malloc(9) when using M_NOWAIT. fgsch@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.19 2001/11/06 19:53:19 miod Exp $	*/
d752 1
a752 1
	(void)splx(s);
d1892 1
a1892 1
		(void)splx(s);
@


1.19
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.18 2001/10/05 00:55:40 nate Exp $	*/
d307 2
d324 2
@


1.19.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.20 2002/01/11 01:31:21 nordin Exp $	*/
a306 2
	if (sc->sk_vpd_prodname == NULL)
		panic("sk_vpd_read");
a321 2
	if (sc->sk_vpd_readonly == NULL)
		panic("sk_vpd_read");
@


1.19.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.19.2.1 2002/01/31 22:55:35 niklas Exp $	*/
d45 1
a45 1
 * Note: XaQti has been acquired by Vitesse, and Vitesse does not have the
d47 1
a47 1
 * convenience to others until Vitesse corrects this problem:
d120 45
a164 45
int skc_probe(struct device *, void *, void *);
void skc_attach(struct device *, struct device *self, void *aux);
int sk_probe(struct device *, void *, void *);
void sk_attach(struct device *, struct device *self, void *aux);
int skcprint(void *, const char *);
int sk_attach_xmac(struct sk_softc *, int);
int sk_intr(void *);
void sk_intr_bcom(struct sk_if_softc *);
void sk_intr_xmac(struct sk_if_softc *);
void sk_rxeof(struct sk_if_softc *);
void sk_txeof(struct sk_if_softc *);
int sk_encap(struct sk_if_softc *, struct mbuf *, u_int32_t *);
void sk_start(struct ifnet *);
int sk_ioctl(struct ifnet *, u_long, caddr_t);
void sk_init(void *);
void sk_init_xmac(struct sk_if_softc *);
void sk_stop(struct sk_if_softc *);
void sk_watchdog(struct ifnet *);
void sk_shutdown(void *);
int sk_ifmedia_upd(struct ifnet *);
void sk_ifmedia_sts(struct ifnet *, struct ifmediareq *);
void sk_reset(struct sk_softc *);
int sk_newbuf(struct sk_if_softc *, struct sk_chain *,
    struct mbuf *);
int sk_init_rx_ring(struct sk_if_softc *);
void sk_init_tx_ring(struct sk_if_softc *);
u_int32_t sk_win_read_4(struct sk_softc *, int);
u_int16_t sk_win_read_2(struct sk_softc *, int);
u_int8_t sk_win_read_1(struct sk_softc *, int);
void sk_win_write_4(struct sk_softc *, int, u_int32_t);
void sk_win_write_2(struct sk_softc *, int, u_int32_t);
void sk_win_write_1(struct sk_softc *, int, u_int32_t);
u_int8_t sk_vpd_readbyte(struct sk_softc *, int);
void sk_vpd_read_res(struct sk_softc *,
					struct vpd_res *, int);
void sk_vpd_read(struct sk_softc *);

int sk_miibus_readreg(struct device *, int, int);
void sk_miibus_writereg(struct device *, int, int, int);
void sk_miibus_statchg(struct device *);

u_int32_t sk_calchash(caddr_t);
void sk_setfilt(struct sk_if_softc *, caddr_t, int);
void sk_setmulti(struct sk_if_softc *);
void sk_tick(void *);
a703 7
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > SK_JUMBO_MTU)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		sk_init(sc_if);
		break;
d752 1
a752 1
	splx(s);
d960 1
a960 2
	IFQ_SET_MAXLEN(&ifp->if_snd, SK_TX_RING_CNT - 1);
	IFQ_SET_READY(&ifp->if_snd);
a1251 1
	int			pkts = 0;
d1259 1
a1259 1
		IFQ_POLL(&ifp->if_snd, m_head);
d1269 1
a1273 4
		/* now we are committed to transmit the packet */
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
		pkts++;

a1282 2
	if (pkts == 0)
		return;
d1633 1
a1633 1
	if (ifp0 != NULL && !IFQ_IS_EMPTY(&ifp0->if_snd))
d1635 1
a1635 1
	if (ifp1 != NULL && !IFQ_IS_EMPTY(&ifp1->if_snd))
d1892 1
a1892 1
		splx(s);
@


1.19.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d103 3
d142 2
a143 1
int sk_newbuf(struct sk_if_softc *, int, struct mbuf *, bus_dmamap_t);
d145 1
a145 1
int sk_init_tx_ring(struct sk_if_softc *);
d184 3
a186 2
u_int32_t
sk_win_read_4(struct sk_softc *sc, int reg)
d192 3
a194 2
u_int16_t
sk_win_read_2(struct sk_softc *sc, int reg)
d200 3
a202 2
u_int8_t
sk_win_read_1(struct sk_softc *sc, int reg)
d208 4
a211 2
void
sk_win_write_4(struct sk_softc *sc, int reg, u_int32_t val)
d215 1
d218 4
a221 2
void
sk_win_write_2(struct sk_softc *sc, int reg, u_int32_t val)
d225 1
d228 4
a231 2
void
sk_win_write_1(struct sk_softc *sc, int reg, u_int32_t val)
d235 1
d249 3
a251 2
u_int8_t
sk_vpd_readbyte(struct sk_softc *sc, int addr)
d269 4
a272 2
void
sk_vpd_read_res(struct sk_softc *sc, struct vpd_res *res, int addr)
d280 2
d284 2
a285 2
void
sk_vpd_read(struct sk_softc *sc)
d328 2
d333 3
a335 1
sk_miibus_readreg(struct device *dev, int phy, int reg)
d364 3
a366 1
sk_miibus_writereg(struct device *dev, int phy, int reg, int val)
d392 2
d397 2
a398 1
sk_miibus_statchg(struct device *dev)
d400 5
a404 2
	struct sk_if_softc *sc_if = (struct sk_if_softc *)dev;
	struct mii_data *mii = &sc_if->sk_mii;
d417 2
d424 2
a425 2
u_int32_t
sk_calchash(caddr_t addr)
d440 4
a443 2
void
sk_setfilt(struct sk_if_softc *sc_if, caddr_t addr, int slot)
d445 3
a447 1
	int base = XM_RXFILT_ENTRY(slot);
d452 2
d457 2
a458 1
sk_setmulti(struct sk_if_softc *sc_if)
d460 1
a460 1
	struct ifnet *ifp = &sc_if->arpcom.ac_if;
d468 2
d515 2
d519 2
a520 2
int
sk_init_rx_ring(struct sk_if_softc *sc_if)
d522 2
a523 2
	struct sk_chain_data	*cd = &sc_if->sk_cdata;
	struct sk_ring_data	*rd = sc_if->sk_rdata;
d526 3
d534 5
d540 4
a543 2
			cd->sk_rx_chain[i].sk_next = &cd->sk_rx_chain[0];
			rd->sk_rx_ring[i].sk_next = SK_RX_RING_ADDR(sc_if, 0);
d545 4
a548 2
			cd->sk_rx_chain[i].sk_next = &cd->sk_rx_chain[i + 1];
			rd->sk_rx_ring[i].sk_next = SK_RX_RING_ADDR(sc_if,i+1);
a551 7
	for (i = 0; i < SK_RX_RING_CNT; i++) {
		if (sk_newbuf(sc_if, i, NULL, NULL) == ENOBUFS) {
			printf("%s: failed alloc of %dth mbuf\n",
			    sc_if->sk_dev.dv_xname, i);
			return(ENOBUFS);
		}
	}
d558 2
a559 2
int
sk_init_tx_ring(struct sk_if_softc *sc_if)
d561 2
a562 5
	struct sk_softc		*sc = sc_if->sk_softc;
	struct sk_chain_data	*cd = &sc_if->sk_cdata;
	struct sk_ring_data	*rd = sc_if->sk_rdata;
	bus_dmamap_t		dmamap;
	struct sk_txmap_entry	*entry;
d565 3
a570 1
	SLIST_INIT(&sc_if->sk_txmap_listhead);
d574 4
a577 2
			cd->sk_tx_chain[i].sk_next = &cd->sk_tx_chain[0];
			rd->sk_tx_ring[i].sk_next = SK_TX_RING_ADDR(sc_if, 0);
d579 4
a582 12
			cd->sk_tx_chain[i].sk_next = &cd->sk_tx_chain[i + 1];
			rd->sk_tx_ring[i].sk_next = SK_TX_RING_ADDR(sc_if,i+1);
		}

		if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, SK_NTXSEG,
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &dmamap))
			return (ENOBUFS);

		entry = malloc(sizeof(*entry), M_DEVBUF, M_NOWAIT);
		if (!entry) {
			bus_dmamap_destroy(sc->sc_dmatag, dmamap);
			return (ENOBUFS);
a583 2
		entry->dmamap = dmamap;
		SLIST_INSERT_HEAD(&sc_if->sk_txmap_listhead, entry, link);
d590 1
a590 1
	return (0);
d593 4
a596 3
int
sk_newbuf(struct sk_if_softc *sc_if, int i, struct mbuf *m,
	  bus_dmamap_t dmamap)
a597 1
	struct sk_softc		*sc = sc_if->sk_softc;
a598 1
	struct sk_chain		*c;
a600 14
	if (dmamap == NULL) {
		/* if (m) panic() */

		if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, 1, MCLBYTES,
				      0, BUS_DMA_NOWAIT, &dmamap)) {
			printf("%s: can't create recv map\n",
			       sc_if->sk_dev.dv_xname);
			return(ENOMEM);
		}
	} else if (m == NULL)
		bus_dmamap_unload(sc->sc_dmatag, dmamap);

	sc_if->sk_cdata.sk_rx_map[i] = dmamap;

a614 8

		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;

		m_adj(m_new, ETHER_ALIGN);

		if (bus_dmamap_load_mbuf(sc->sc_dmatag, dmamap, m_new,
					 BUS_DMA_NOWAIT))
			return(ENOBUFS);
a621 2
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_adj(m_new, ETHER_ALIGN);
d624 8
a632 1
	c = &sc_if->sk_cdata.sk_rx_chain[i];
d635 2
a636 2
	r->sk_data_lo = dmamap->dm_segs[0].ds_addr;
	r->sk_ctl = dmamap->dm_segs[0].ds_len | SK_RXSTAT;
d645 2
a646 1
sk_ifmedia_upd(struct ifnet *ifp)
d659 3
a661 1
sk_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
d671 4
a674 1
sk_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
d769 3
a771 1
skc_probe(struct device *parent, void *match, void *aux)
d785 2
a786 1
void sk_reset(struct sk_softc *sc)
d816 2
d821 3
a823 1
sk_probe(struct device *parent, void *match, void *aux)
d838 3
a840 1
sk_attach(struct device *parent, struct device *self, void *aux)
d848 1
d939 1
a939 2
	    sizeof(struct sk_ring_data), 0, BUS_DMA_NOWAIT,
            &sc_if->sk_ring_map)) {
d946 1
a946 1
	if (bus_dmamap_load(sc->sc_dmatag, sc_if->sk_ring_map, kva,
d949 1
a949 1
		bus_dmamap_destroy(sc->sc_dmatag, sc_if->sk_ring_map);
a966 1
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
d1008 3
a1010 1
skcprint(void *aux, const char *pnp)
d1027 3
a1029 1
skc_attach(struct device *parent, struct device *self, void *aux)
d1178 1
a1178 1
		sc->sk_pmd = IFM_1000_T;
d1204 4
a1207 2
int
sk_encap(struct sk_if_softc *sc_if, struct mbuf *m_head, u_int32_t *txidx)
a1208 1
	struct sk_softc		*sc = sc_if->sk_softc;
d1210 1
a1211 8
	int			i;
	struct sk_txmap_entry	*entry;
	bus_dmamap_t		txmap;

	entry = SLIST_FIRST(&sc_if->sk_txmap_listhead);
	if (entry == NULL)
		return (ENOBUFS);
	txmap = entry->dmamap;
d1213 1
d1221 19
a1239 1
	if (bus_dmamap_load_mbuf(sc->sc_dmatag, txmap, m_head, BUS_DMA_NOWAIT))
a1241 18
	for (i = 0; i < txmap->dm_nsegs; i++) {
		if ((SK_TX_RING_CNT - (sc_if->sk_cdata.sk_tx_cnt + cnt)) < 2)
			return(ENOBUFS);
		f = &sc_if->sk_rdata->sk_tx_ring[frag];
		f->sk_data_lo = txmap->dm_segs[i].ds_addr;
		f->sk_ctl = txmap->dm_segs[i].ds_len | SK_OPCODE_DEFAULT;
		if (cnt == 0)
			f->sk_ctl |= SK_TXCTL_FIRSTFRAG;
		else
			f->sk_ctl |= SK_TXCTL_OWN;
		cur = frag;
		SK_INC(frag, SK_TX_RING_CNT);
		cnt++;
	}

	sc_if->sk_cdata.sk_tx_chain[cur].sk_mbuf = m_head;
	SLIST_REMOVE_HEAD(&sc_if->sk_txmap_listhead, link);
	sc_if->sk_cdata.sk_tx_map[cur] = entry;
d1244 1
d1253 2
a1254 2
void
sk_start(struct ifnet *ifp)
d1256 2
a1257 2
        struct sk_if_softc	*sc_if = ifp->if_softc;
        struct sk_softc		*sc = sc_if->sk_softc;
d1259 1
a1259 1
        u_int32_t		idx = sc_if->sk_cdata.sk_tx_prod;
d1262 5
d1304 2
d1309 2
a1310 2
void
sk_watchdog(struct ifnet *ifp)
d1312 3
a1314 1
	struct sk_if_softc *sc_if = ifp->if_softc;
d1318 2
d1322 2
a1323 2
void
sk_shutdown(void *v)
d1335 2
d1339 2
a1340 2
void
sk_rxeof(struct sk_if_softc *sc_if)
a1341 1
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
d1343 1
d1345 2
a1346 2
	struct sk_rx_desc	*cur_desc;
	int			i, cur, total_len = 0;
a1347 1
	bus_dmamap_t		dmamap;
d1349 1
d1351 1
a1353 3
		cur = i;
		cur_rx = &sc_if->sk_cdata.sk_rx_chain[cur];
		cur_desc = &sc_if->sk_rdata->sk_rx_ring[cur];
d1355 2
a1356 1
		rxstat = cur_desc->sk_xmac_rxstat;
d1359 1
a1359 5
		total_len = SK_RXBYTES(cur_desc->sk_ctl);

		dmamap = sc_if->sk_cdata.sk_rx_map[cur];
		sc_if->sk_cdata.sk_rx_map[cur] = 0;

d1364 1
a1364 1
			sk_newbuf(sc_if, cur, m, dmamap);
d1375 1
a1375 1
		if (sk_newbuf(sc_if, cur, NULL, dmamap) == ENOBUFS) {
d1379 1
a1379 1
			sk_newbuf(sc_if, cur, m, dmamap);
d1405 2
d1409 2
a1410 2
void
sk_txeof(struct sk_if_softc *sc_if)
a1411 1
	struct sk_softc		*sc = sc_if->sk_softc;
d1413 1
a1413 1
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
d1415 2
a1416 1
	struct sk_txmap_entry	*entry;
a1431 9

			entry = sc_if->sk_cdata.sk_tx_map[idx];
			bus_dmamap_sync(sc->sc_dmatag, entry->dmamap, 0,
			    entry->dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);

			bus_dmamap_unload(sc->sc_dmatag, entry->dmamap);
			SLIST_INSERT_HEAD(&sc_if->sk_txmap_listhead, entry,
					  link);
			sc_if->sk_cdata.sk_tx_map[idx] = NULL;
d1442 2
d1447 2
a1448 1
sk_tick(void *xsc_if)
d1450 3
a1452 3
	struct sk_if_softc *sc_if = xsc_if;
	struct mii_data *mii = &sc_if->sk_mii;
	struct ifnet *ifp = &sc_if->arpcom.ac_if;
d1455 4
d1493 2
a1494 1
sk_intr_bcom(struct sk_if_softc *sc_if)
d1496 3
a1498 2
	struct mii_data *mii = &sc_if->sk_mii;
	struct ifnet *ifp = &sc_if->arpcom.ac_if;
d1501 4
d1547 2
d1551 2
a1552 2
void
sk_intr_xmac(struct sk_if_softc	*sc_if)
d1554 5
a1558 1
	u_int16_t status = SK_XM_READ_2(sc_if, XM_ISR);
d1576 2
d1580 2
a1581 2
int
sk_intr(void *xsc)
d1584 1
a1584 2
	struct sk_if_softc	*sc_if0 = sc->sk_if[SK_PORT_A];
	struct sk_if_softc	*sc_if1 = sc->sk_if[SK_PORT_B];
d1589 3
d1655 2
a1656 2
void
sk_init_xmac(struct sk_if_softc	*sc_if)
d1658 2
a1659 2
	struct sk_softc		*sc = sc_if->sk_softc;
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
d1666 3
d1819 2
d1827 2
a1828 2
void
sk_init(void *xsc_if)
d1830 4
a1833 4
	struct sk_if_softc	*sc_if = xsc_if;
	struct sk_softc		*sc = sc_if->sk_softc;
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
	struct mii_data		*mii = &sc_if->sk_mii;
d1838 4
d1893 1
a1893 1
	    SK_RX_RING_ADDR(sc_if, 0));
d1898 1
a1898 1
            SK_TX_RING_ADDR(sc_if, 0));
d1909 1
a1909 8

	if (sk_init_tx_ring(sc_if) == ENOBUFS) {
		printf("%s: initialization failed: no "
		    "memory for tx buffers\n", sc_if->sk_dev.dv_xname);
		sk_stop(sc_if);
		splx(s);
		return;
	}
d1933 2
d1937 2
a1938 2
void
sk_stop(struct sk_if_softc *sc_if)
a1939 2
	struct sk_softc		*sc = sc_if->sk_softc;
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
d1941 5
d2004 2
@


1.18
log
@use positive logic for match
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.17 2001/09/11 20:05:25 miod Exp $	*/
d103 1
a103 1
#include <vm/vm.h>              /* for vtophys */
@


1.17
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.16 2001/08/25 10:13:29 art Exp $	*/
d764 3
a766 2
	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_SCHNEIDERKOCH)
		return (0);
d768 1
a768 4
	if (PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_SCHNEIDERKOCH_GE)
		return (0);

	return (1);
@


1.16
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.15 2001/08/15 16:50:26 jason Exp $	*/
a103 1
#include <vm/vm_kern.h>
@


1.15
log
@Add some stuff missed in a previous FreeBSD merge... Fixes the problem where
sk busy loops when carrier is lost until it returns; based on patch from
david langhorst <dirt@@monkey.org> and tested by John Ladwig <jladwig@@mango.lioness.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.14 2001/08/12 20:03:49 mickey Exp $	*/
d1110 1
a1110 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.14
log
@remove redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.13 2001/06/25 02:18:47 fgsch Exp $	*/
d1546 9
a1554 4
	if (status & XM_ISR_LINKEVENT) {
		SK_XM_SETBIT_2(sc_if, XM_IMR, XM_IMR_LINKEVENT);
		if (sc_if->sk_link == 1)
			sc_if->sk_link = 0;
a1555 3

	if (status & XM_ISR_AUTONEG_DONE)
		timeout_add(&sc_if->sk_tick_ch, hz);
@


1.13
log
@trivial ether_input_mbuf() conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.12 2001/03/29 16:02:18 jason Exp $	*/
a103 1
#include <vm/pmap.h>            /* for vtophys */
a104 1
#include <vm/vm_extern.h>
@


1.12
log
@From FreeBSD:
- Call mii_pollstat() after we bring up the link on a 1000baseTX card
  after autoneg so we make sure to set the link state and duplex mode
  correctly.
- Make sure to set the 'ignore pause frames' bit on the XMAC.
- Small linewrap fix.
- Add actual URL for XMAC II datasheet in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.11 2001/03/25 06:30:58 csapuntz Exp $	*/
a1329 1
	struct ether_header	*eh;
a1382 1
		eh = mtod(m, struct ether_header *);
d1388 2
a1389 3
		/* Remove header from mbuf and pass it on. */
		m_adj(m, sizeof(struct ether_header));
		ether_input(ifp, eh, m);
@


1.11
log
@Missing splx(s). Thanks to Dawson and team for finding this one
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.10 2001/02/20 19:39:45 mickey Exp $	*/
d46 4
a49 2
 * XMAC II datasheet online. I have put my copy at www.freebsd.org as a
 * convience to others until Vitesse corrects this problem.
d1518 2
a1519 1
			SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_OFF);
d1530 1
d1915 1
@


1.10
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.9 2000/10/16 17:08:08 aaron Exp $	*/
d1085 1
a1085 1
		return;
d1089 1
a1089 1
		return;
d1113 1
a1113 1
		return;
d1123 1
a1123 1
		return;
@


1.9
log
@Use mii_attach() directly instead of mii_phy_probe().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.8 2000/09/04 17:11:55 deraadt Exp $	*/
a991 4
#if NBPFILTER > 0
	bpfattach(&sc_if->arpcom.ac_if.if_bpf, ifp,
	    DLT_EN10MB, sizeof(struct ether_header));
#endif
@


1.8
log
@printing XaQti on 5 consecutive lines is stupid
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.7 2000/08/29 23:45:40 jason Exp $	*/
d972 2
a973 1
	mii_phy_probe(self, &sc_if->sk_mii, 0xffffffff);
@


1.7
log
@From FreeBSD: split out the support for XMAC-II phys and other phys
add xmphy & brgphy to GENERIC
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.6 2000/02/15 02:28:14 jason Exp $	*/
d866 1
a866 1
	printf(": <XaQti Corp. XMAC II> address %s\n",
@


1.6
log
@make sure to call ether_{add,del}multi() as appropriate in xxx_ioctl()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.5 1999/12/08 00:38:08 aaron Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997, 1998, 1999
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_sk.c,v 1.19 1999/09/25 04:50:27 wpaul Exp $
d41 2
a42 1
 * 	The XaQti XMAC II datasheet, http://www.xaqti.com
d45 4
d107 4
d128 1
a146 1
#ifdef notdef
a147 1
#endif
d157 5
a161 2
u_int16_t sk_phy_readreg	__P((struct sk_if_softc *, int));
void sk_phy_writereg	__P((struct sk_if_softc *, int, u_int32_t));
d165 1
a184 1
#ifdef notdef
a191 1
#endif
d329 4
a332 3
u_int16_t sk_phy_readreg(sc_if, reg)
	struct sk_if_softc	*sc_if;
	int			reg;
d334 5
a338 1
	int			i;
d340 9
a348 5
	SK_XM_WRITE_2(sc_if, XM_PHY_ADDR, reg);
	for (i = 0; i < SK_TIMEOUT; i++) {
		if (!(SK_XM_READ_2(sc_if, XM_MMUCMD) & XM_MMUCMD_PHYBUSY))
			break;
	}
d350 5
a354 4
	if (i == SK_TIMEOUT) {
		printf("%s: phy failed to come ready\n",
		    sc_if->sk_dev.dv_xname);
		return(0);
d356 1
a356 1

d360 4
a363 4
void sk_phy_writereg(sc_if, reg, val)
	struct sk_if_softc	*sc_if;
	int			reg;
	u_int32_t		val;
d365 2
a366 1
	int			i;
d368 1
a368 1
	SK_XM_WRITE_2(sc_if, XM_PHY_ADDR, reg);
d382 1
d393 25
d641 3
a643 2
int sk_ifmedia_upd(ifp)
	struct ifnet		*ifp;
d645 1
a645 28
	struct sk_if_softc	*sc_if;
	struct ifmedia		*ifm;

	sc_if = ifp->if_softc;
	ifm = &sc_if->ifmedia;

	if (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)
		return(EINVAL);

	switch(IFM_SUBTYPE(ifm->ifm_media)) {
	case IFM_AUTO:
		sk_phy_writereg(sc_if, XM_PHY_BMCR,
		    XM_BMCR_RENEGOTIATE|XM_BMCR_AUTONEGENBL);
		break;
	case IFM_1000_LX:
	case IFM_1000_SX:
	case IFM_1000_CX:
	case IFM_1000_TX:
		if ((ifm->ifm_media & IFM_GMASK) == IFM_FDX)
			sk_phy_writereg(sc_if, XM_PHY_BMCR, XM_BMCR_DUPLEX);
		else
			sk_phy_writereg(sc_if, XM_PHY_BMCR, 0);
		break;
	default:
		printf("%s: invalid media selected\n", sc_if->sk_dev.dv_xname);
		return(EINVAL);
		break;
	}
d647 2
d655 4
a658 3
void sk_ifmedia_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
d660 1
a660 22
	struct sk_softc		*sc;
	struct sk_if_softc	*sc_if;
	u_int16_t		bmsr, extsts;

	sc_if = ifp->if_softc;
	sc = sc_if->sk_softc;

	ifmr->ifm_status = IFM_AVALID;
	ifmr->ifm_active = IFM_ETHER;

	bmsr = sk_phy_readreg(sc_if, XM_PHY_BMSR);
	extsts = sk_phy_readreg(sc_if, XM_PHY_EXTSTS);

	if (!(bmsr & XM_BMSR_LINKSTAT))
		return;

	ifmr->ifm_status |= IFM_ACTIVE;
	ifmr->ifm_active |= sc->sk_pmd;;
	if (extsts & XM_EXTSTS_FULLDUPLEX)
		ifmr->ifm_active |= IFM_FDX;
	else
		ifmr->ifm_active |= IFM_HDX;
d662 3
a664 1
	return;
d676 1
d741 2
a742 1
		error = ifmedia_ioctl(ifp, ifr, &sc_if->ifmedia, command);
d902 15
d963 1
a963 1
	 * Do ifmedia setup.
d965 19
a983 6
	ifmedia_init(&sc_if->ifmedia, 0, sk_ifmedia_upd, sk_ifmedia_sts);
	ifmedia_add(&sc_if->ifmedia, IFM_ETHER|sc->sk_pmd, 0, NULL);
	ifmedia_add(&sc_if->ifmedia, IFM_ETHER|sc->sk_pmd|IFM_FDX, 0, NULL);
	ifmedia_add(&sc_if->ifmedia, IFM_ETHER|sc->sk_pmd|IFM_HDX, 0, NULL);
	ifmedia_add(&sc_if->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);
	ifmedia_set(&sc_if->ifmedia, IFM_ETHER|IFM_AUTO);
d1438 103
a1545 1
	u_int16_t		bmsr;
d1556 2
a1557 7
	if (status & XM_ISR_AUTONEG_DONE) {
		bmsr = sk_phy_readreg(sc_if, XM_PHY_BMSR);
		if (bmsr & XM_BMSR_LINKSTAT) {
			sc_if->sk_link = 1;
			SK_XM_CLRBIT_2(sc_if, XM_IMR, XM_IMR_LINKEVENT);
		}
	}
d1583 1
a1583 1
		ifp1 = &sc_if0->arpcom.ac_if;
d1617 2
a1618 1
		if (status & SK_ISR_MAC1)
d1621 2
a1622 1
		if (status & SK_ISR_MAC2)
d1624 7
d1648 5
d1661 3
d1667 43
d1771 4
a1774 3
	SK_XM_WRITE_2(sc_if, XM_IMR, XM_INTRS);

	sc_if->sk_link = 0;
d1806 2
d1821 1
d1828 1
d1847 1
d1905 3
d1934 17
d1952 1
d1971 3
@


1.5
log
@Remove unused #define cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.4 1999/10/22 07:14:42 deraadt Exp $	*/
d720 12
a731 2
		sk_setmulti(sc_if);
		error = 0;
@


1.5.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.6 2000/02/15 02:28:14 jason Exp $	*/
d720 2
a721 12
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc_if->arpcom) :
		    ether_delmulti(ifr, &sc_if->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			sk_setmulti(sc_if);
			error = 0;
		}
@


1.5.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.12 2001/03/29 16:02:18 jason Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997, 1998, 1999, 2000
d34 1
a34 1
 * $FreeBSD: /c/ncvs/src/sys/pci/if_sk.c,v 1.20 2000/04/22 02:16:37 wpaul Exp $
d41 1
a41 2
 * 	The XaQti XMAC II datasheet,
 * http://www.freebsd.org/~wpaul/SysKonnect/xmacii_datasheet_rev_c_9-29.pdf
a43 6
 * Note: XaQti has been aquired by Vitesse, and Vitesse does not have the
 * XMAC II datasheet online. I have put my copy at people.freebsd.org as a
 * convience to others until Vitesse corrects this problem:
 *
 * http://people.freebsd.org/~wpaul/SysKonnect/xmacii_datasheet_rev_c_9-29.pdf
 *
a101 4
#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/brgphyreg.h>

a118 1
void sk_intr_bcom	__P((struct sk_if_softc *));
d137 1
d139 1
d149 2
a150 5

int sk_miibus_readreg	__P((struct device *, int, int));
void sk_miibus_writereg	__P((struct device *, int, int, int));
void sk_miibus_statchg	__P((struct device *));

a153 1
void sk_tick		__P((void *));
d173 1
d181 1
d319 3
a321 4
int
sk_miibus_readreg(dev, phy, reg)
	struct device *dev;
	int phy, reg;
d323 1
a323 2
	struct sk_if_softc *sc_if = (struct sk_if_softc *)dev;
	int i;
d325 9
a333 1
	if (sc_if->sk_phytype == SK_PHYTYPE_XMAC && phy != 0)
d335 1
a336 17
	SK_XM_WRITE_2(sc_if, XM_PHY_ADDR, reg|(phy << 8));
	SK_XM_READ_2(sc_if, XM_PHY_DATA);
	if (sc_if->sk_phytype != SK_PHYTYPE_XMAC) {
		for (i = 0; i < SK_TIMEOUT; i++) {
			DELAY(1);
			if (SK_XM_READ_2(sc_if, XM_MMUCMD) &
			    XM_MMUCMD_PHYDATARDY)
				break;
		}

		if (i == SK_TIMEOUT) {
			printf("%s: phy failed to come ready\n",
			    sc_if->sk_dev.dv_xname);
			return(0);
		}
	}
	DELAY(1);
d340 4
a343 4
void
sk_miibus_writereg(dev, phy, reg, val)
	struct device *dev;
	int phy, reg, val;
d345 1
a345 2
	struct sk_if_softc *sc_if = (struct sk_if_softc *)dev;
	int i;
d347 1
a347 1
	SK_XM_WRITE_2(sc_if, XM_PHY_ADDR, reg|(phy << 8));
a360 1
		DELAY(1);
a370 25
void
sk_miibus_statchg(dev)
	struct device *dev;
{
	struct sk_if_softc *sc_if;
	struct mii_data *mii;

	sc_if = (struct sk_if_softc *)dev;
	mii = &sc_if->sk_mii;

	/*
	 * If this is a GMII PHY, manually set the XMAC's
	 * duplex mode accordingly.
	 */
	if (sc_if->sk_phytype != SK_PHYTYPE_XMAC) {
		if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX) {
			SK_XM_SETBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_GMIIFDX);
		} else {
			SK_XM_CLRBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_GMIIFDX);
		}
	}

	return;
}

d594 2
a595 3
int
sk_ifmedia_upd(ifp)
	struct ifnet *ifp;
d597 28
a624 1
	struct sk_if_softc *sc_if = ifp->if_softc;
a625 2
	sk_init(sc_if);
	mii_mediachg(&sc_if->sk_mii);
d632 3
a634 4
void
sk_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
d636 22
a657 1
	struct sk_if_softc *sc_if = ifp->if_softc;
d659 1
a659 3
	mii_pollstat(&sc_if->sk_mii);
	ifmr->ifm_active = sc_if->sk_mii.mii_media_active;
	ifmr->ifm_status = sc_if->sk_mii.mii_media_status;
a670 1
	struct mii_data *mii;
d735 1
a735 2
		mii = &sc_if->sk_mii;
		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);
d859 1
a859 1
	printf(": address %s\n",
a894 15
	/* Read and save PHY type and set PHY address */
	sc_if->sk_phytype = sk_win_read_1(sc, SK_EPROM1) & 0xF;
	switch (sc_if->sk_phytype) {
	case SK_PHYTYPE_XMAC:
		sc_if->sk_phyaddr = SK_PHYADDR_XMAC;
		break;
	case SK_PHYTYPE_BCOM:
		sc_if->sk_phyaddr = SK_PHYADDR_BCOM;
		break;
	default:
		printf("%s: unsupported PHY type: %d\n",
		    sc->sk_dev.dv_xname, sc_if->sk_phytype);
		return;
	}

d941 1
a941 1
	 * Do miibus setup.
d943 6
a948 20
	sk_init_xmac(sc_if);
	sc_if->sk_mii.mii_ifp = ifp;
	sc_if->sk_mii.mii_readreg = sk_miibus_readreg;
	sc_if->sk_mii.mii_writereg = sk_miibus_writereg;
	sc_if->sk_mii.mii_statchg = sk_miibus_statchg;
	ifmedia_init(&sc_if->sk_mii.mii_media, 0,
	    sk_ifmedia_upd, sk_ifmedia_sts);
	mii_attach(self, &sc_if->sk_mii, 0xffffffff, MII_PHY_ANY,
	    MII_OFFSET_ANY, 0);
	if (LIST_FIRST(&sc_if->sk_mii.mii_phys) == NULL) {
		printf("%s: no PHY found!\n", sc_if->sk_dev.dv_xname);
		ifmedia_add(&sc_if->sk_mii.mii_media, IFM_ETHER|IFM_MANUAL,
		    0, NULL);
		ifmedia_set(&sc_if->sk_mii.mii_media, IFM_ETHER|IFM_MANUAL);
	}
	else
		ifmedia_set(&sc_if->sk_mii.mii_media, IFM_ETHER|IFM_AUTO);

	timeout_set(&sc_if->sk_tick_ch, sk_tick, sc_if);
	timeout_add(&sc_if->sk_tick_ch, hz);
d956 4
d1053 1
a1053 1
		goto fail;
d1057 1
a1057 1
		goto fail;
d1081 1
a1081 1
		goto fail;
d1091 1
a1091 1
		goto fail;
a1402 105
void
sk_tick(xsc_if)
	void *xsc_if;
{
	struct sk_if_softc *sc_if;
	struct mii_data *mii;
	struct ifnet *ifp;
	int i;

	sc_if = xsc_if;
	ifp = &sc_if->arpcom.ac_if;
	mii = &sc_if->sk_mii;

	if (!(ifp->if_flags & IFF_UP))
		return;

	if (sc_if->sk_phytype == SK_PHYTYPE_BCOM) {
		sk_intr_bcom(sc_if);
		return;
	}

	/*
	 * According to SysKonnect, the correct way to verify that
	 * the link has come back up is to poll bit 0 of the GPIO
	 * register three times. This pin has the signal from the
	 * link sync pin connected to it; if we read the same link
	 * state 3 times in a row, we know the link is up.
	 */
	for (i = 0; i < 3; i++) {
		if (SK_XM_READ_2(sc_if, XM_GPIO) & XM_GPIO_GP0_SET)
			break;
	}

	if (i != 3) {
		timeout_add(&sc_if->sk_tick_ch, hz);
		return;
	}

	/* Turn the GP0 interrupt back on. */
	SK_XM_CLRBIT_2(sc_if, XM_IMR, XM_IMR_GP0_SET);
	SK_XM_READ_2(sc_if, XM_ISR);
	mii_tick(mii);
	mii_pollstat(mii);
	timeout_del(&sc_if->sk_tick_ch);
}

void
sk_intr_bcom(sc_if)
	struct sk_if_softc *sc_if;
{
	struct sk_softc *sc;
	struct mii_data *mii;
	struct ifnet *ifp;
	int status;

	sc = sc_if->sk_softc;
	mii = &sc_if->sk_mii;
	ifp = &sc_if->arpcom.ac_if;

	SK_XM_CLRBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_TX_ENB|XM_MMUCMD_RX_ENB);

	/*
	 * Read the PHY interrupt register to make sure
	 * we clear any pending interrupts.
	 */
	status = sk_miibus_readreg((struct device *)sc_if,
	    SK_PHYADDR_BCOM, BRGPHY_MII_ISR);

	if (!(ifp->if_flags & IFF_RUNNING)) {
		sk_init_xmac(sc_if);
		return;
	}

	if (status & (BRGPHY_ISR_LNK_CHG|BRGPHY_ISR_AN_PR)) {
		int lstat;
		lstat = sk_miibus_readreg((struct device *)sc_if,
		    SK_PHYADDR_BCOM, BRGPHY_MII_AUXSTS);

		if (!(lstat & BRGPHY_AUXSTS_LINK) && sc_if->sk_link) {
			mii_mediachg(mii);
			/* Turn off the link LED. */
			SK_IF_WRITE_1(sc_if, 0,
			    SK_LINKLED1_CTL, SK_LINKLED_OFF);
			sc_if->sk_link = 0;
		} else if (status & BRGPHY_ISR_LNK_CHG) {
			sk_miibus_writereg((struct device *)sc_if,
			    SK_PHYADDR_BCOM, BRGPHY_MII_IMR, 0xFF00);
			mii_tick(mii);
			sc_if->sk_link = 1;
			/* Turn on the link LED. */
			SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL,
			    SK_LINKLED_ON|SK_LINKLED_LINKSYNC_OFF|
			    SK_LINKLED_BLINK_OFF);
			mii_pollstat(mii);
		} else {
			mii_tick(mii);
			timeout_add(&sc_if->sk_tick_ch, hz);
		}
	}

	SK_XM_SETBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_TX_ENB|XM_MMUCMD_RX_ENB);

	return;
}

d1408 1
d1419 7
a1425 2
	if (status & XM_ISR_AUTONEG_DONE)
		timeout_add(&sc_if->sk_tick_ch, hz);
d1451 1
a1451 1
		ifp1 = &sc_if1->arpcom.ac_if;
d1485 1
a1485 2
		if (status & SK_ISR_MAC1 &&
		    ifp0->if_flags & IFF_RUNNING)
d1488 1
a1488 2
		if (status & SK_ISR_MAC2 &&
		    ifp1->if_flags & IFF_RUNNING)
a1489 7

		if (status & SK_ISR_EXTERNAL_REG) {
			if (ifp0 != NULL)
				sk_intr_bcom(sc_if0);
			if (ifp1 != NULL)
				sk_intr_bcom(sc_if1);
		}
a1506 5
	struct sk_bcom_hack     bhack[] = {
	{ 0x18, 0x0c20 }, { 0x17, 0x0012 }, { 0x15, 0x1104 }, { 0x17, 0x0013 },
	{ 0x15, 0x0404 }, { 0x17, 0x8006 }, { 0x15, 0x0132 }, { 0x17, 0x8006 },
	{ 0x15, 0x0232 }, { 0x17, 0x800D }, { 0x15, 0x000F }, { 0x18, 0x0420 },
	{ 0, 0 } };
a1514 3
	/* Reset the XMAC's internal state. */
	SK_XM_SETBIT_2(sc_if, XM_GPIO, XM_GPIO_RESETMAC);

a1517 43
	/*
	 * Perform additional initialization for external PHYs,
	 * namely for the 1000baseTX cards that use the XMAC's
	 * GMII mode.
	 */
	if (sc_if->sk_phytype == SK_PHYTYPE_BCOM) {
		int			i = 0;
		u_int32_t		val;

		/* Take PHY out of reset. */
		val = sk_win_read_4(sc, SK_GPIO);
		if (sc_if->sk_port == SK_PORT_A)
			val |= SK_GPIO_DIR0|SK_GPIO_DAT0;
		else
			val |= SK_GPIO_DIR2|SK_GPIO_DAT2;
		sk_win_write_4(sc, SK_GPIO, val);

		/* Enable GMII mode on the XMAC. */
		SK_XM_SETBIT_2(sc_if, XM_HWCFG, XM_HWCFG_GMIIMODE);

		sk_miibus_writereg((struct device *)sc_if, SK_PHYADDR_BCOM,
		    BRGPHY_MII_BMCR, BRGPHY_BMCR_RESET);
		DELAY(10000);
		sk_miibus_writereg((struct device *)sc_if, SK_PHYADDR_BCOM,
		    BRGPHY_MII_IMR, 0xFFF0);

		/*
		 * Early versions of the BCM5400 apparently have
		 * a bug that requires them to have their reserved
		 * registers initialized to some magic values. I don't
		 * know what the numbers do, I'm just the messenger.
		 */
		if (sk_miibus_readreg((struct device *)sc_if,
		    SK_PHYADDR_BCOM, 0x03) == 0x6041) {
			while(bhack[i].reg) {
				sk_miibus_writereg((struct device *)sc_if,
				    SK_PHYADDR_BCOM, bhack[i].reg,
				    bhack[i].val);
				i++;
			}
		}
	}

d1579 3
a1581 4
	if (sc_if->sk_phytype == SK_PHYTYPE_XMAC)
		SK_XM_WRITE_2(sc_if, XM_IMR, XM_INTRS);
	else
		SK_XM_WRITE_2(sc_if, XM_IMR, 0xFFFF);
a1612 2
	sc_if->sk_link = 1;

a1625 1
	struct mii_data		*mii;
a1631 1
	mii = &sc_if->sk_mii;
a1649 1
	mii_mediachg(mii);
a1706 3

	sc->sk_intrmask |= SK_ISR_EXTERNAL_REG;

a1712 1
	SK_XM_CLRBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_IGNPAUSE);
a1732 17
	timeout_del(&sc_if->sk_tick_ch);

	if (sc_if->sk_phytype == SK_PHYTYPE_BCOM) {
		u_int32_t		val;

		/* Put PHY back into reset. */
		val = sk_win_read_4(sc, SK_GPIO);
		if (sc_if->sk_port == SK_PORT_A) {
			val |= SK_GPIO_DIR0;
			val &= ~SK_GPIO_DAT0;
		} else {
			val |= SK_GPIO_DIR2;
			val &= ~SK_GPIO_DAT2;
		}
		sk_win_write_4(sc, SK_GPIO, val);
	}

a1733 1
	SK_XM_SETBIT_2(sc_if, XM_GPIO, XM_GPIO_RESETMAC);
a1751 3

	SK_XM_READ_2(sc_if, XM_ISR);
	SK_XM_WRITE_2(sc_if, XM_IMR, 0xFFFF);
@


1.5.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.5.2.2 2001/05/14 22:25:46 niklas Exp $	*/
d1330 1
d1384 1
d1390 3
a1392 2
		/* pass it on. */
		ether_input_mbuf(ifp, m);
@


1.5.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.5.2.3 2001/07/04 10:42:20 niklas Exp $	*/
d104 3
d767 2
a768 3
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SCHNEIDERKOCH &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SCHNEIDERKOCH_GE)
		return (1);
d770 4
a773 1
	return (0);
d1112 2
a1113 1
	if (pci_intr_map(pa, &ih)) {
d1548 5
a1552 5
	if (sc_if->sk_phytype == SK_PHYTYPE_XMAC) {
		if (status & XM_ISR_GP0_SET) {
			SK_XM_SETBIT_2(sc_if, XM_IMR, XM_IMR_GP0_SET);
			timeout_add(&sc_if->sk_tick_ch, hz);
		}
d1554 2
a1555 4
		if (status & XM_ISR_AUTONEG_DONE) {
			timeout_add(&sc_if->sk_tick_ch, hz);
		}
	}
@


1.5.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d103 1
a103 1
#include <uvm/uvm_extern.h>              /* for vtophys */
@


1.5.2.6
log
@Merge in trunk
@
text
@a306 2
	if (sc->sk_vpd_prodname == NULL)
		panic("sk_vpd_read");
a321 2
	if (sc->sk_vpd_readonly == NULL)
		panic("sk_vpd_read");
d748 1
a748 1
	splx(s);
d1888 1
a1888 1
		splx(s);
@


1.5.2.7
log
@Merge in -current from roughly a week ago
@
text
@d120 45
a164 45
int skc_probe(struct device *, void *, void *);
void skc_attach(struct device *, struct device *self, void *aux);
int sk_probe(struct device *, void *, void *);
void sk_attach(struct device *, struct device *self, void *aux);
int skcprint(void *, const char *);
int sk_attach_xmac(struct sk_softc *, int);
int sk_intr(void *);
void sk_intr_bcom(struct sk_if_softc *);
void sk_intr_xmac(struct sk_if_softc *);
void sk_rxeof(struct sk_if_softc *);
void sk_txeof(struct sk_if_softc *);
int sk_encap(struct sk_if_softc *, struct mbuf *, u_int32_t *);
void sk_start(struct ifnet *);
int sk_ioctl(struct ifnet *, u_long, caddr_t);
void sk_init(void *);
void sk_init_xmac(struct sk_if_softc *);
void sk_stop(struct sk_if_softc *);
void sk_watchdog(struct ifnet *);
void sk_shutdown(void *);
int sk_ifmedia_upd(struct ifnet *);
void sk_ifmedia_sts(struct ifnet *, struct ifmediareq *);
void sk_reset(struct sk_softc *);
int sk_newbuf(struct sk_if_softc *, struct sk_chain *,
    struct mbuf *);
int sk_init_rx_ring(struct sk_if_softc *);
void sk_init_tx_ring(struct sk_if_softc *);
u_int32_t sk_win_read_4(struct sk_softc *, int);
u_int16_t sk_win_read_2(struct sk_softc *, int);
u_int8_t sk_win_read_1(struct sk_softc *, int);
void sk_win_write_4(struct sk_softc *, int, u_int32_t);
void sk_win_write_2(struct sk_softc *, int, u_int32_t);
void sk_win_write_1(struct sk_softc *, int, u_int32_t);
u_int8_t sk_vpd_readbyte(struct sk_softc *, int);
void sk_vpd_read_res(struct sk_softc *,
					struct vpd_res *, int);
void sk_vpd_read(struct sk_softc *);

int sk_miibus_readreg(struct device *, int, int);
void sk_miibus_writereg(struct device *, int, int, int);
void sk_miibus_statchg(struct device *);

u_int32_t sk_calchash(caddr_t);
void sk_setfilt(struct sk_if_softc *, caddr_t, int);
void sk_setmulti(struct sk_if_softc *);
void sk_tick(void *);
d960 1
a960 2
	IFQ_SET_MAXLEN(&ifp->if_snd, SK_TX_RING_CNT - 1);
	IFQ_SET_READY(&ifp->if_snd);
a1251 1
	int			pkts = 0;
d1259 1
a1259 1
		IFQ_POLL(&ifp->if_snd, m_head);
d1269 1
a1273 4
		/* now we are committed to transmit the packet */
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
		pkts++;

a1282 2
	if (pkts == 0)
		return;
d1633 1
a1633 1
	if (ifp0 != NULL && !IFQ_IS_EMPTY(&ifp0->if_snd))
d1635 1
a1635 1
	if (ifp1 != NULL && !IFQ_IS_EMPTY(&ifp1->if_snd))
@


1.5.2.8
log
@Sync the SMP branch with 3.3
@
text
@d45 1
a45 1
 * Note: XaQti has been acquired by Vitesse, and Vitesse does not have the
d47 1
a47 1
 * convenience to others until Vitesse corrects this problem:
a703 7
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > SK_JUMBO_MTU)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		sk_init(sc_if);
		break;
a959 1
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
d1171 1
a1171 1
		sc->sk_pmd = IFM_1000_T;
d1220 1
a1220 1
			f->sk_data_lo = vtophys(mtod(m, vaddr_t));
@


1.5.2.9
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.5.2.8 2003/03/28 00:38:22 niklas Exp $	*/
d184 3
a186 2
u_int32_t
sk_win_read_4(struct sk_softc *sc, int reg)
d192 3
a194 2
u_int16_t
sk_win_read_2(struct sk_softc *sc, int reg)
d200 3
a202 2
u_int8_t
sk_win_read_1(struct sk_softc *sc, int reg)
d208 4
a211 2
void
sk_win_write_4(struct sk_softc *sc, int reg, u_int32_t val)
d215 1
d218 4
a221 2
void
sk_win_write_2(struct sk_softc *sc, int reg, u_int32_t val)
d225 1
d228 4
a231 2
void
sk_win_write_1(struct sk_softc *sc, int reg, u_int32_t val)
d235 1
d249 3
a251 2
u_int8_t
sk_vpd_readbyte(struct sk_softc *sc, int addr)
d269 4
a272 2
void
sk_vpd_read_res(struct sk_softc *sc, struct vpd_res *res, int addr)
d280 2
d284 2
a285 2
void
sk_vpd_read(struct sk_softc *sc)
d328 2
d333 3
a335 1
sk_miibus_readreg(struct device *dev, int phy, int reg)
d364 3
a366 1
sk_miibus_writereg(struct device *dev, int phy, int reg, int val)
d392 2
d397 2
a398 1
sk_miibus_statchg(struct device *dev)
d400 5
a404 2
	struct sk_if_softc *sc_if = (struct sk_if_softc *)dev;
	struct mii_data *mii = &sc_if->sk_mii;
d417 2
d424 2
a425 2
u_int32_t
sk_calchash(caddr_t addr)
d440 4
a443 2
void
sk_setfilt(struct sk_if_softc *sc_if, caddr_t addr, int slot)
d445 3
a447 1
	int base = XM_RXFILT_ENTRY(slot);
d452 2
d457 2
a458 1
sk_setmulti(struct sk_if_softc *sc_if)
d460 1
a460 1
	struct ifnet *ifp = &sc_if->arpcom.ac_if;
d468 2
d515 2
d519 2
a520 2
int
sk_init_rx_ring(struct sk_if_softc *sc_if)
d522 2
a523 2
	struct sk_chain_data	*cd = &sc_if->sk_cdata;
	struct sk_ring_data	*rd = sc_if->sk_rdata;
d526 3
d558 2
a559 2
void
sk_init_tx_ring(struct sk_if_softc *sc_if)
d561 2
a562 2
	struct sk_chain_data	*cd = &sc_if->sk_cdata;
	struct sk_ring_data	*rd = sc_if->sk_rdata;
d565 3
d589 2
d593 4
a596 2
int
sk_newbuf(struct sk_if_softc *sc_if, struct sk_chain *c, struct mbuf *m)
d645 2
a646 1
sk_ifmedia_upd(struct ifnet *ifp)
d659 3
a661 1
sk_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
d671 4
a674 1
sk_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
d769 3
a771 1
skc_probe(struct device *parent, void *match, void *aux)
d785 2
a786 1
void sk_reset(struct sk_softc *sc)
d816 2
d821 3
a823 1
sk_probe(struct device *parent, void *match, void *aux)
d838 3
a840 1
sk_attach(struct device *parent, struct device *self, void *aux)
d1009 3
a1011 1
skcprint(void *aux, const char *pnp)
d1028 3
a1030 1
skc_attach(struct device *parent, struct device *self, void *aux)
d1205 4
a1208 2
int
sk_encap(struct sk_if_softc *sc_if, struct mbuf *m_head, u_int32_t *txidx)
d1214 1
d1254 2
a1255 2
void
sk_start(struct ifnet *ifp)
d1257 2
a1258 2
        struct sk_if_softc	*sc_if = ifp->if_softc;
        struct sk_softc		*sc = sc_if->sk_softc;
d1260 1
a1260 1
        u_int32_t		idx = sc_if->sk_cdata.sk_tx_prod;
d1263 5
d1305 2
d1310 2
a1311 2
void
sk_watchdog(struct ifnet *ifp)
d1313 3
a1315 1
	struct sk_if_softc *sc_if = ifp->if_softc;
d1319 2
d1323 2
a1324 2
void
sk_shutdown(void *v)
d1336 2
d1340 2
a1341 2
void
sk_rxeof(struct sk_if_softc *sc_if)
a1342 1
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
d1344 1
d1350 1
d1406 2
d1410 2
a1411 2
void
sk_txeof(struct sk_if_softc *sc_if)
d1414 1
a1414 1
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
d1417 2
d1443 2
d1448 2
a1449 1
sk_tick(void *xsc_if)
d1451 3
a1453 3
	struct sk_if_softc *sc_if = xsc_if;
	struct mii_data *mii = &sc_if->sk_mii;
	struct ifnet *ifp = &sc_if->arpcom.ac_if;
d1456 4
d1494 2
a1495 1
sk_intr_bcom(struct sk_if_softc *sc_if)
d1497 3
a1499 2
	struct mii_data *mii = &sc_if->sk_mii;
	struct ifnet *ifp = &sc_if->arpcom.ac_if;
d1502 4
d1548 2
d1552 2
a1553 2
void
sk_intr_xmac(struct sk_if_softc	*sc_if)
d1555 5
a1559 1
	u_int16_t status = SK_XM_READ_2(sc_if, XM_ISR);
d1577 2
d1581 2
a1582 2
int
sk_intr(void *xsc)
d1585 1
a1585 2
	struct sk_if_softc	*sc_if0 = sc->sk_if[SK_PORT_A];
	struct sk_if_softc	*sc_if1 = sc->sk_if[SK_PORT_B];
d1590 3
d1656 2
a1657 2
void
sk_init_xmac(struct sk_if_softc	*sc_if)
d1659 2
a1660 2
	struct sk_softc		*sc = sc_if->sk_softc;
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
d1667 3
d1820 2
d1828 2
a1829 2
void
sk_init(void *xsc_if)
d1831 4
a1834 4
	struct sk_if_softc	*sc_if = xsc_if;
	struct sk_softc		*sc = sc_if->sk_softc;
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
	struct mii_data		*mii = &sc_if->sk_mii;
d1839 4
d1934 2
d1938 2
a1939 2
void
sk_stop(struct sk_if_softc *sc_if)
a1940 2
	struct sk_softc		*sc = sc_if->sk_softc;
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
d1942 5
d2005 2
@


1.5.2.10
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d103 3
d142 2
a143 1
int sk_newbuf(struct sk_if_softc *, int, struct mbuf *, bus_dmamap_t);
d145 1
a145 1
int sk_init_tx_ring(struct sk_if_softc *);
d489 5
d495 4
a498 2
			cd->sk_rx_chain[i].sk_next = &cd->sk_rx_chain[0];
			rd->sk_rx_ring[i].sk_next = SK_RX_RING_ADDR(sc_if, 0);
d500 4
a503 2
			cd->sk_rx_chain[i].sk_next = &cd->sk_rx_chain[i + 1];
			rd->sk_rx_ring[i].sk_next = SK_RX_RING_ADDR(sc_if,i+1);
a506 7
	for (i = 0; i < SK_RX_RING_CNT; i++) {
		if (sk_newbuf(sc_if, i, NULL, NULL) == ENOBUFS) {
			printf("%s: failed alloc of %dth mbuf\n",
			    sc_if->sk_dev.dv_xname, i);
			return(ENOBUFS);
		}
	}
d513 1
a513 1
int
a515 1
	struct sk_softc		*sc = sc_if->sk_softc;
a517 2
	bus_dmamap_t		dmamap;
	struct sk_txmap_entry	*entry;
a522 1
	SLIST_INIT(&sc_if->sk_txmap_listhead);
d526 4
a529 2
			cd->sk_tx_chain[i].sk_next = &cd->sk_tx_chain[0];
			rd->sk_tx_ring[i].sk_next = SK_TX_RING_ADDR(sc_if, 0);
d531 4
a534 2
			cd->sk_tx_chain[i].sk_next = &cd->sk_tx_chain[i + 1];
			rd->sk_tx_ring[i].sk_next = SK_TX_RING_ADDR(sc_if,i+1);
a535 12

		if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, SK_NTXSEG,
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &dmamap))
			return (ENOBUFS);

		entry = malloc(sizeof(*entry), M_DEVBUF, M_NOWAIT);
		if (!entry) {
			bus_dmamap_destroy(sc->sc_dmatag, dmamap);
			return (ENOBUFS);
		}
		entry->dmamap = dmamap;
		SLIST_INSERT_HEAD(&sc_if->sk_txmap_listhead, entry, link);
a540 2

	return (0);
d544 1
a544 2
sk_newbuf(struct sk_if_softc *sc_if, int i, struct mbuf *m,
	  bus_dmamap_t dmamap)
a545 1
	struct sk_softc		*sc = sc_if->sk_softc;
a546 1
	struct sk_chain		*c;
a548 14
	if (dmamap == NULL) {
		/* if (m) panic() */

		if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, 1, MCLBYTES,
				      0, BUS_DMA_NOWAIT, &dmamap)) {
			printf("%s: can't create recv map\n",
			       sc_if->sk_dev.dv_xname);
			return(ENOMEM);
		}
	} else if (m == NULL)
		bus_dmamap_unload(sc->sc_dmatag, dmamap);

	sc_if->sk_cdata.sk_rx_map[i] = dmamap;

a562 8

		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;

		m_adj(m_new, ETHER_ALIGN);

		if (bus_dmamap_load_mbuf(sc->sc_dmatag, dmamap, m_new,
					 BUS_DMA_NOWAIT))
			return(ENOBUFS);
a569 2
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_adj(m_new, ETHER_ALIGN);
d572 8
a580 1
	c = &sc_if->sk_cdata.sk_rx_chain[i];
d583 2
a584 2
	r->sk_data_lo = dmamap->dm_segs[0].ds_addr;
	r->sk_ctl = dmamap->dm_segs[0].ds_len | SK_RXSTAT;
d781 1
d872 1
a872 2
	    sizeof(struct sk_ring_data), 0, BUS_DMA_NOWAIT,
            &sc_if->sk_ring_map)) {
d879 1
a879 1
	if (bus_dmamap_load(sc->sc_dmatag, sc_if->sk_ring_map, kva,
d882 1
a882 1
		bus_dmamap_destroy(sc->sc_dmatag, sc_if->sk_ring_map);
a1136 1
	struct sk_softc		*sc = sc_if->sk_softc;
d1138 1
a1139 8
	int			i;
	struct sk_txmap_entry	*entry;
	bus_dmamap_t		txmap;

	entry = SLIST_FIRST(&sc_if->sk_txmap_listhead);
	if (entry == NULL)
		return (ENOBUFS);
	txmap = entry->dmamap;
d1148 19
a1166 1
	if (bus_dmamap_load_mbuf(sc->sc_dmatag, txmap, m_head, BUS_DMA_NOWAIT))
a1168 18
	for (i = 0; i < txmap->dm_nsegs; i++) {
		if ((SK_TX_RING_CNT - (sc_if->sk_cdata.sk_tx_cnt + cnt)) < 2)
			return(ENOBUFS);
		f = &sc_if->sk_rdata->sk_tx_ring[frag];
		f->sk_data_lo = txmap->dm_segs[i].ds_addr;
		f->sk_ctl = txmap->dm_segs[i].ds_len | SK_OPCODE_DEFAULT;
		if (cnt == 0)
			f->sk_ctl |= SK_TXCTL_FIRSTFRAG;
		else
			f->sk_ctl |= SK_TXCTL_OWN;
		cur = frag;
		SK_INC(frag, SK_TX_RING_CNT);
		cnt++;
	}

	sc_if->sk_cdata.sk_tx_chain[cur].sk_mbuf = m_head;
	SLIST_REMOVE_HEAD(&sc_if->sk_txmap_listhead, link);
	sc_if->sk_cdata.sk_tx_map[cur] = entry;
d1171 1
d1259 2
a1260 2
	struct sk_rx_desc	*cur_desc;
	int			i, cur, total_len = 0;
a1261 1
	bus_dmamap_t		dmamap;
d1264 1
a1266 3
		cur = i;
		cur_rx = &sc_if->sk_cdata.sk_rx_chain[cur];
		cur_desc = &sc_if->sk_rdata->sk_rx_ring[cur];
d1268 2
a1269 1
		rxstat = cur_desc->sk_xmac_rxstat;
d1272 1
a1272 5
		total_len = SK_RXBYTES(cur_desc->sk_ctl);

		dmamap = sc_if->sk_cdata.sk_rx_map[cur];
		sc_if->sk_cdata.sk_rx_map[cur] = 0;

d1277 1
a1277 1
			sk_newbuf(sc_if, cur, m, dmamap);
d1288 1
a1288 1
		if (sk_newbuf(sc_if, cur, NULL, dmamap) == ENOBUFS) {
d1292 1
a1292 1
			sk_newbuf(sc_if, cur, m, dmamap);
a1322 1
	struct sk_softc		*sc = sc_if->sk_softc;
a1325 1
	struct sk_txmap_entry	*entry;
a1340 9

			entry = sc_if->sk_cdata.sk_tx_map[idx];
			bus_dmamap_sync(sc->sc_dmatag, entry->dmamap, 0,
			    entry->dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);

			bus_dmamap_unload(sc->sc_dmatag, entry->dmamap);
			SLIST_INSERT_HEAD(&sc_if->sk_txmap_listhead, entry,
					  link);
			sc_if->sk_cdata.sk_tx_map[idx] = NULL;
d1770 1
a1770 1
	    SK_RX_RING_ADDR(sc_if, 0));
d1775 1
a1775 1
            SK_TX_RING_ADDR(sc_if, 0));
d1786 1
a1786 8

	if (sk_init_tx_ring(sc_if) == ENOBUFS) {
		printf("%s: initialization failed: no "
		    "memory for tx buffers\n", sc_if->sk_dev.dv_xname);
		sk_stop(sc_if);
		splx(s);
		return;
	}
@


1.5.2.11
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a37 16
 * Copyright (c) 2003 Nathan L. Binkert <binkertn@@umich.edu>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
a93 2
#include <netinet/udp.h>
#include <netinet/tcp.h>
a97 1
#include <net/if_vlan_var.h>
d111 1
a112 1
/* #define SK_USEIOSPACE */
a115 1
#include <dev/pci/yukonreg.h>
d122 1
a125 1
void sk_intr_yukon(struct sk_if_softc *);
a132 1
void sk_init_yukon(struct sk_if_softc *);
d142 6
d149 2
a150 1
void sk_vpd_read_res(struct sk_softc *, struct vpd_res *, int);
d153 3
a155 7
int sk_xmac_miibus_readreg(struct device *, int, int);
void sk_xmac_miibus_writereg(struct device *, int, int, int);
void sk_xmac_miibus_statchg(struct device *);

int sk_marv_miibus_readreg(struct device *, int, int);
void sk_marv_miibus_writereg(struct device *, int, int, int);
void sk_marv_miibus_statchg(struct device *);
a160 14
void sk_rxcsum(struct ifnet *, struct mbuf *, const u_int16_t, const u_int16_t);

#ifdef SK_DEBUG
#define DPRINTF(x)	if (skdebug) printf x
#define DPRINTFN(n,x)	if (skdebug >= (n)) printf x
int	skdebug = 0;

void sk_dump_txdesc(struct sk_tx_desc *, int);
void sk_dump_mbuf(struct mbuf *);
void sk_dump_bytes(const char *, int);
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif
d180 2
a181 13
/* supported device vendors */
const struct pci_matchid skc_devices[] = {
	{ PCI_VENDOR_3COM,		PCI_PRODUCT_3COM_3C940},
	{ PCI_VENDOR_DLINK,		PCI_PRODUCT_DLINK_DGE530T},
	{ PCI_VENDOR_LINKSYS,		PCI_PRODUCT_LINKSYS_EG1032},
	{ PCI_VENDOR_LINKSYS,		PCI_PRODUCT_LINKSYS_EG1064},
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_SK_V2},
	{ PCI_VENDOR_SCHNEIDERKOCH,	PCI_PRODUCT_SCHNEIDERKOCH_GE},
	{ PCI_VENDOR_SCHNEIDERKOCH,	PCI_PRODUCT_SCHNEIDERKOCH_SK9821v2},
};

static inline u_int32_t
sk_win_read_4(struct sk_softc *sc, u_int32_t reg)
a182 1
#ifdef SK_USEIOSPACE
d184 1
a184 4
	return CSR_READ_4(sc, SK_WIN_BASE + SK_REG(reg));
#else
	return CSR_READ_4(sc, reg);
#endif
d187 2
a188 2
static inline u_int16_t
sk_win_read_2(struct sk_softc *sc, u_int32_t reg)
a189 1
#ifdef SK_USEIOSPACE
d191 1
a191 4
	return CSR_READ_2(sc, SK_WIN_BASE + SK_REG(reg));
#else
	return CSR_READ_2(sc, reg);
#endif
d194 2
a195 2
static inline u_int8_t
sk_win_read_1(struct sk_softc *sc, u_int32_t reg)
a196 1
#ifdef SK_USEIOSPACE
d198 1
a198 4
	return CSR_READ_1(sc, SK_WIN_BASE + SK_REG(reg));
#else
	return CSR_READ_1(sc, reg);
#endif
d201 2
a202 2
static inline void
sk_win_write_4(struct sk_softc *sc, u_int32_t reg, u_int32_t x)
a203 1
#ifdef SK_USEIOSPACE
d205 1
a205 4
	CSR_WRITE_4(sc, SK_WIN_BASE + SK_REG(reg), x);
#else
	CSR_WRITE_4(sc, reg, x);
#endif
d208 2
a209 2
static inline void
sk_win_write_2(struct sk_softc *sc, u_int32_t reg, u_int16_t x)
a210 1
#ifdef SK_USEIOSPACE
d212 1
a212 4
	CSR_WRITE_2(sc, SK_WIN_BASE + SK_REG(reg), x);
#else
	CSR_WRITE_2(sc, reg, x);
#endif
d215 2
a216 2
static inline void
sk_win_write_1(struct sk_softc *sc, u_int32_t reg, u_int8_t x)
a217 1
#ifdef SK_USEIOSPACE
d219 1
a219 4
	CSR_WRITE_1(sc, SK_WIN_BASE + SK_REG(reg), x);
#else
	CSR_WRITE_1(sc, reg, x);
#endif
d310 1
a310 1
sk_xmac_miibus_readreg(struct device *dev, int phy, int reg)
a314 2
	DPRINTFN(9, ("sk_xmac_miibus_readreg\n"));

d339 1
a339 1
sk_xmac_miibus_writereg(struct device *dev, int phy, int reg, int val)
a343 2
	DPRINTFN(9, ("sk_xmac_miibus_writereg\n"));

d368 1
a368 1
sk_xmac_miibus_statchg(struct device *dev)
a372 2
	DPRINTFN(9, ("sk_xmac_miibus_statchg\n"));

d386 1
a386 74
int
sk_marv_miibus_readreg(dev, phy, reg)
	struct device *dev;
	int phy, reg;
{
	struct sk_if_softc *sc_if = (struct sk_if_softc *)dev;
	u_int16_t val;
	int i;

	if (phy != 0 ||
	    (sc_if->sk_phytype != SK_PHYTYPE_MARV_COPPER &&
	     sc_if->sk_phytype != SK_PHYTYPE_MARV_FIBER)) {
		DPRINTFN(9, ("sk_marv_miibus_readreg (skip) phy=%d, reg=%#x\n",
			     phy, reg));
		return(0);
	}

        SK_YU_WRITE_2(sc_if, YUKON_SMICR, YU_SMICR_PHYAD(phy) |
		      YU_SMICR_REGAD(reg) | YU_SMICR_OP_READ);
        
	for (i = 0; i < SK_TIMEOUT; i++) {
		DELAY(1);
		val = SK_YU_READ_2(sc_if, YUKON_SMICR);
		if (val & YU_SMICR_READ_VALID)
			break;
	}

	if (i == SK_TIMEOUT) {
		printf("%s: phy failed to come ready\n",
		       sc_if->sk_dev.dv_xname);
		return 0;
	}
        
 	DPRINTFN(9, ("sk_marv_miibus_readreg: i=%d, timeout=%d\n", i,
		     SK_TIMEOUT));

        val = SK_YU_READ_2(sc_if, YUKON_SMIDR);

	DPRINTFN(9, ("sk_marv_miibus_readreg phy=%d, reg=%#x, val=%#x\n",
		     phy, reg, val));

	return val;
}

void
sk_marv_miibus_writereg(dev, phy, reg, val)
	struct device *dev;
	int phy, reg, val;
{
	struct sk_if_softc *sc_if = (struct sk_if_softc *)dev;
	int i;

	DPRINTFN(9, ("sk_marv_miibus_writereg phy=%d reg=%#x val=%#x\n",
		     phy, reg, val));

	SK_YU_WRITE_2(sc_if, YUKON_SMIDR, val);
	SK_YU_WRITE_2(sc_if, YUKON_SMICR, YU_SMICR_PHYAD(phy) |
		      YU_SMICR_REGAD(reg) | YU_SMICR_OP_WRITE);

	for (i = 0; i < SK_TIMEOUT; i++) {
		DELAY(1);
		if (SK_YU_READ_2(sc_if, YUKON_SMICR) & YU_SMICR_BUSY)
			break;
	}
}

void
sk_marv_miibus_statchg(dev)
	struct device *dev;
{
	DPRINTFN(9, ("sk_marv_miibus_statchg: gpcr=%x\n",
		     SK_YU_READ_2(((struct sk_if_softc *)dev), YUKON_GPCR)));
}

a387 1
#define SK_POLY	0xEDB88320
d418 1
a418 2
	struct sk_softc *sc = sc_if->sk_softc;
	struct ifnet *ifp= &sc_if->arpcom.ac_if;
d427 4
a430 15
	switch(sc->sk_type) {
	case SK_GENESIS:
		for (i = 1; i < XM_RXFILT_MAX; i++)
			sk_setfilt(sc_if, (caddr_t)&dummy, i);

		SK_XM_WRITE_4(sc_if, XM_MAR0, 0);
		SK_XM_WRITE_4(sc_if, XM_MAR2, 0);
		break;
	case SK_YUKON:
		SK_YU_WRITE_2(sc_if, YUKON_MCAH1, 0);
		SK_YU_WRITE_2(sc_if, YUKON_MCAH2, 0);
		SK_YU_WRITE_2(sc_if, YUKON_MCAH3, 0);
		SK_YU_WRITE_2(sc_if, YUKON_MCAH4, 0);
		break;
	}
d442 1
a442 2
			if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
				 ETHER_ADDR_LEN)) {
d451 1
a451 1
			if (sc->sk_type == SK_GENESIS && i < XM_RXFILT_MAX) {
d467 4
a470 14
	switch(sc->sk_type) {
	case SK_GENESIS:
		SK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_USE_HASH|
			       XM_MODE_RX_USE_PERFECT);
		SK_XM_WRITE_4(sc_if, XM_MAR0, hashes[0]);
		SK_XM_WRITE_4(sc_if, XM_MAR2, hashes[1]);
		break;
	case SK_YUKON:
		SK_YU_WRITE_2(sc_if, YUKON_MCAH1, hashes[0] & 0xffff);
		SK_YU_WRITE_2(sc_if, YUKON_MCAH2, (hashes[0] >> 16) & 0xffff);
		SK_YU_WRITE_2(sc_if, YUKON_MCAH3, hashes[1] & 0xffff);
		SK_YU_WRITE_2(sc_if, YUKON_MCAH4, (hashes[1] >> 16) & 0xffff);
		break;
	}
a491 3
		rd->sk_rx_ring[i].sk_csum1_start = ETHER_HDR_LEN;
		rd->sk_rx_ring[i].sk_csum2_start = ETHER_HDR_LEN +
		    sizeof(struct ip);
a646 1
	struct sk_softc *sc = sc_if->sk_softc;
d686 2
a687 10
				switch(sc->sk_type) {
				case SK_GENESIS:
					SK_XM_SETBIT_4(sc_if, XM_MODE,
					    XM_MODE_RX_PROMISC);
					break;
				case SK_YUKON:
					SK_YU_CLRBIT_2(sc_if, YUKON_RCR,
					    YU_RCR_UFLEN | YU_RCR_MUFLEN);
					break;
				}
d692 2
a693 11
				switch(sc->sk_type) {
				case SK_GENESIS:
					SK_XM_CLRBIT_4(sc_if, XM_MODE,
					    XM_MODE_RX_PROMISC);
					break;
				case SK_YUKON:
					SK_YU_SETBIT_2(sc_if, YUKON_RCR,
					    YU_RCR_UFLEN | YU_RCR_MUFLEN);
					break;
				}

d741 7
a747 2
	return (pci_matchbyid((struct pci_attach_args *)aux, skc_devices,
	    sizeof(skc_devices)/sizeof(skc_devices[0])));
d755 5
a759 6
	DPRINTFN(2, ("sk_reset\n"));

	CSR_WRITE_2(sc, SK_CSR, SK_CSR_SW_RESET);
	CSR_WRITE_2(sc, SK_CSR, SK_CSR_MASTER_RESET);
	if (sc->sk_type == SK_YUKON)
		CSR_WRITE_2(sc, SK_LINK_CTRL, SK_LINK_RESET_SET);
d761 6
a766 19
	DELAY(1000);
	CSR_WRITE_2(sc, SK_CSR, SK_CSR_SW_UNRESET);
	DELAY(2);
	CSR_WRITE_2(sc, SK_CSR, SK_CSR_MASTER_UNRESET);
	if (sc->sk_type == SK_YUKON)
		CSR_WRITE_2(sc, SK_LINK_CTRL, SK_LINK_RESET_CLEAR);

	DPRINTFN(2, ("sk_reset: sk_csr=%x\n", CSR_READ_2(sc, SK_CSR)));
	DPRINTFN(2, ("sk_reset: sk_link_ctrl=%x\n",
		     CSR_READ_2(sc, SK_LINK_CTRL)));

	if (sc->sk_type == SK_GENESIS) {
		/* Configure packet arbiter */
		sk_win_write_2(sc, SK_PKTARB_CTL, SK_PKTARBCTL_UNRESET);
		sk_win_write_2(sc, SK_RXPA1_TINIT, SK_PKTARB_TIMEOUT);
		sk_win_write_2(sc, SK_TXPA1_TINIT, SK_PKTARB_TIMEOUT);
		sk_win_write_2(sc, SK_RXPA2_TINIT, SK_PKTARB_TIMEOUT);
		sk_win_write_2(sc, SK_TXPA2_TINIT, SK_PKTARB_TIMEOUT);
	}
d819 1
a819 3

	DPRINTFN(2, ("begin sk_attach: port=%d\n", sc_if->sk_port));

a869 5
	DPRINTFN(2, ("sk_attach: rx_ramstart=%#x rx_ramend=%#x\n"
		     "           tx_ramstart=%#x tx_ramend=%#x\n",
		     sc_if->sk_rx_ramstart, sc_if->sk_rx_ramend,
		     sc_if->sk_tx_ramstart, sc_if->sk_tx_ramend));

a878 3
	case SK_PHYTYPE_MARV_COPPER:
		sc_if->sk_phyaddr = SK_PHYADDR_MARV;
		break;
d936 1
a936 14
	switch (sc->sk_type) {
	case SK_GENESIS:
		sk_init_xmac(sc_if);
		break;
	case SK_YUKON:
		sk_init_yukon(sc_if);
		break;
	default:
		panic("%s: unknown device type %d", sc->sk_dev.dv_xname,
		      sc->sk_type);
	}

 	DPRINTFN(2, ("sk_attach: 1\n"));

d938 3
a940 13
	switch (sc->sk_type) {
	case SK_GENESIS:
		sc_if->sk_mii.mii_readreg = sk_xmac_miibus_readreg;
		sc_if->sk_mii.mii_writereg = sk_xmac_miibus_writereg;
		sc_if->sk_mii.mii_statchg = sk_xmac_miibus_statchg;
		break;
	case SK_YUKON:
		sc_if->sk_mii.mii_readreg = sk_marv_miibus_readreg;
		sc_if->sk_mii.mii_writereg = sk_marv_miibus_writereg;
		sc_if->sk_mii.mii_statchg = sk_marv_miibus_statchg;
		break;
	}

d948 1
a948 1
			    0, NULL);
a956 2
	DPRINTFN(2, ("sk_attach: 1\n"));

a962 2
	DPRINTFN(2, ("sk_attach: end\n"));

a999 2
	DPRINTFN(2, ("begin skc_attach\n"));

d1006 1
a1007 1
	if (command == 0x01) {
d1036 5
a1040 21

#define SK_MK_ID(vnd,prd) \
    (((vnd) << PCI_VENDOR_SHIFT) | ((prd) << PCI_PRODUCT_SHIFT))

	switch (pa->pa_id) {
	case SK_MK_ID(PCI_VENDOR_SCHNEIDERKOCH, PCI_PRODUCT_SCHNEIDERKOCH_GE):
		sc->sk_type = SK_GENESIS;
		break;
	case SK_MK_ID(PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C940):
	case SK_MK_ID(PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_DGE530T):
	case SK_MK_ID(PCI_VENDOR_LINKSYS, PCI_PRODUCT_LINKSYS_EG1032):
	case SK_MK_ID(PCI_VENDOR_LINKSYS, PCI_PRODUCT_LINKSYS_EG1064):
	case SK_MK_ID(PCI_VENDOR_MARVELL, PCI_PRODUCT_MARVELL_SK_V2):
	case SK_MK_ID(PCI_VENDOR_SCHNEIDERKOCH, PCI_PRODUCT_SCHNEIDERKOCH_SK9821v2):
		sc->sk_type = SK_YUKON;
		break;
	default:
		printf(": unknown device!\n");
		goto fail;
	}
#undef SK_MK_ID
a1072 2

	DPRINTFN(2, ("skc_attach: iobase=%#x, iosize=%#x\n", iobase, iosize));
a1075 2
	DPRINTFN(2, ("skc_attach: allocate interrupt\n"));

d1099 16
a1114 32
	if (sc->sk_type == SK_GENESIS) {
		u_int8_t val = sk_win_read_1(sc, SK_EPROM0);
		/* Read and save RAM size and RAMbuffer offset */
		switch(val) {
		case SK_RAMSIZE_512K_64:
			sc->sk_ramsize = 0x80000;
			sc->sk_rboff = SK_RBOFF_0;
			break;
		case SK_RAMSIZE_1024K_64:
			sc->sk_ramsize = 0x100000;
			sc->sk_rboff = SK_RBOFF_80000;
			break;
		case SK_RAMSIZE_1024K_128:
			sc->sk_ramsize = 0x100000;
			sc->sk_rboff = SK_RBOFF_0;
			break;
		case SK_RAMSIZE_2048K_128:
			sc->sk_ramsize = 0x200000;
			sc->sk_rboff = SK_RBOFF_0;
			break;
		default:
			printf("%s: unknown ram size: %d\n",
			       sc->sk_dev.dv_xname, val);
			goto fail;
			break;
		}

		DPRINTFN(2, ("skc_attach: ramsize=%d(%dk), rboff=%d\n",
			     sc->sk_ramsize, sc->sk_ramsize / 1024,
			     sc->sk_rboff));
	} else {
		sc->sk_ramsize = 0x20000;
d1116 6
a1121 4

		DPRINTFN(2, ("skc_attach: ramsize=%dk (%d), rboff=%d\n",
			     sc->sk_ramsize / 1024, sc->sk_ramsize,
			     sc->sk_rboff));
a1171 2
	DPRINTFN(2, ("sk_encap\n"));

d1173 2
a1174 4
	if (entry == NULL) {
		DPRINTFN(2, ("sk_encap: no txmap available\n"));
		return ENOBUFS;
	}
a1178 5
#ifdef SK_DEBUG
	if (skdebug >= 2)
		sk_dump_mbuf(m_head);
#endif

d1184 1
a1184 3
	if (bus_dmamap_load_mbuf(sc->sc_dmatag, txmap, m_head,
	    BUS_DMA_NOWAIT)) {
		DPRINTFN(2, ("sk_encap: dmamap failed\n"));
a1185 3
	}

	DPRINTFN(2, ("sk_encap: dm_nsegs=%d\n", txmap->dm_nsegs));
d1188 1
a1188 2
		if ((SK_TX_RING_CNT - (sc_if->sk_cdata.sk_tx_cnt + cnt)) < 2) {
			DPRINTFN(2, ("sk_encap: too few descriptors free\n"));
a1189 1
		}
a1196 1

a1209 11
#ifdef SK_DEBUG
	if (skdebug >= 2) {
		struct sk_tx_desc *desc;
		u_int32_t idx;
		for (idx = *txidx; idx != frag; SK_INC(idx, SK_TX_RING_CNT)) {
			desc = &sc_if->sk_rdata->sk_tx_ring[idx];
			sk_dump_txdesc(desc, idx);
		}
	}
#endif

a1211 2
	DPRINTFN(2, ("sk_encap: completed successfully\n"));

a1223 2
	DPRINTFN(2, ("sk_start\n"));

a1277 2
	DPRINTFN(2, ("sk_shutdown\n"));

a1297 3
	u_int16_t		csum1, csum2;

	DPRINTFN(2, ("sk_rxeof\n"));
a1313 3
		csum1 = sc_if->sk_rdata->sk_rx_ring[i].sk_csum1;
		csum2 = sc_if->sk_rdata->sk_rx_ring[i].sk_csum2;

a1349 2
		sk_rxcsum(ifp, m, csum1, csum2);

a1353 1

a1361 91
sk_rxcsum(struct ifnet *ifp, struct mbuf *m, const u_int16_t csum1, const u_int16_t csum2)
{
	struct ether_header *eh;
	struct ip *ip;
	u_int8_t *pp;
	int hlen, len, plen;
	u_int16_t iph_csum, ipo_csum, ipd_csum, csum;

	pp = mtod(m, u_int8_t *);
	plen = m->m_pkthdr.len;
	if (plen < sizeof(*eh))
		return;
	eh = (struct ether_header *)pp;
	iph_csum = in_cksum_addword(csum1, (~csum2 & 0xffff));

	if (eh->ether_type == htons(ETHERTYPE_VLAN)) {
		u_int16_t *xp = (u_int16_t *)pp;

		xp = (u_int16_t *)pp;
		if (xp[1] != htons(ETHERTYPE_IP))
			return;
		iph_csum = in_cksum_addword(iph_csum, (~xp[0] & 0xffff));
		iph_csum = in_cksum_addword(iph_csum, (~xp[1] & 0xffff));
		xp = (u_int16_t *)(pp + sizeof(struct ip));
		iph_csum = in_cksum_addword(iph_csum, xp[0]);
		iph_csum = in_cksum_addword(iph_csum, xp[1]);
		pp += EVL_ENCAPLEN;
	} else if (eh->ether_type != htons(ETHERTYPE_IP))
		return;

	pp += sizeof(*eh);
	plen -= sizeof(*eh);

	ip = (struct ip *)pp;

	if (ip->ip_v != IPVERSION)
		return;

	hlen = ip->ip_hl << 2;
	if (hlen < sizeof(struct ip))
		return;
	if (hlen > ntohs(ip->ip_len))
		return;

	/* Don't deal with truncated or padded packets. */
	if (plen != ntohs(ip->ip_len))
		return;

	len = hlen - sizeof(struct ip);
	if (len > 0) {
		u_int16_t *p;

		p = (u_int16_t *)(ip + 1);
		ipo_csum = 0;
		for (ipo_csum = 0; len > 0; len -= sizeof(*p), p++)
			ipo_csum = in_cksum_addword(ipo_csum, *p);
		iph_csum = in_cksum_addword(iph_csum, ipo_csum);
		ipd_csum = in_cksum_addword(csum2, (~ipo_csum & 0xffff));
	} else
		ipd_csum = csum2;

	if (iph_csum != 0xffff) {
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m);
		return;
	}
	m->m_pkthdr.csum |= M_IPV4_CSUM_IN_OK;

	if (ip->ip_off & htons(IP_MF | IP_OFFMASK))
		return;                 /* ip frag, we're done for now */

	pp += hlen;

	/* Only know checksum protocol for udp/tcp */
	if (ip->ip_p == IPPROTO_UDP) {
		struct udphdr *uh = (struct udphdr *)pp;

		if (uh->uh_sum == 0)    /* udp with no checksum */
			return;
	} else if (ip->ip_p != IPPROTO_TCP)
		return;

	csum = in_cksum_phdr(ip->ip_src.s_addr, ip->ip_dst.s_addr,
	    htonl(ntohs(ip->ip_len) - hlen + ip->ip_p) + ipd_csum);
	if (csum == 0xffff) {
		m->m_pkthdr.csum |= (ip->ip_p == IPPROTO_TCP) ?
		    M_TCP_CSUM_IN_OK : M_UDP_CSUM_IN_OK;
	}
}

void
a1369 2
	DPRINTFN(2, ("sk_txeof\n"));

a1376 4
#ifdef SK_DEBUG
		if (skdebug >= 2)
			sk_dump_txdesc(cur_tx, idx);
#endif
a1412 2
	DPRINTFN(2, ("sk_tick\n"));

a1452 3

	DPRINTFN(2, ("sk_intr_bcom\n"));

d1459 1
a1459 1
	status = sk_xmac_miibus_readreg((struct device *)sc_if,
d1469 1
a1469 1
		lstat = sk_xmac_miibus_readreg((struct device *)sc_if,
d1479 1
a1479 1
			sk_xmac_miibus_writereg((struct device *)sc_if,
a1501 2
	DPRINTFN(2, ("sk_intr_xmac\n"));

a1519 11
void
sk_intr_yukon(sc_if)
	struct sk_if_softc *sc_if;
{
	int status;

	status = SK_IF_READ_2(sc_if, 0, SK_GMAC_ISR);

	DPRINTFN(2, ("sk_intr_yukon status=%#x\n", status));
}

a1536 2
		DPRINTFN(2, ("sk_intr: status=%#x\n", status));

d1567 7
a1573 14
		if (status & SK_ISR_MAC1 && (ifp0->if_flags & IFF_RUNNING)) {
			if (sc->sk_type == SK_GENESIS)
				sk_intr_xmac(sc_if0);
			else
				sk_intr_yukon(sc_if0);
		}

		if (status & SK_ISR_MAC2 && (ifp1->if_flags & IFF_RUNNING)) {
			if (sc->sk_type == SK_GENESIS)
				sk_intr_xmac(sc_if1);
			else
				sk_intr_yukon(sc_if1);

		}
d1576 1
a1576 2
			if (ifp0 != NULL &&
			    sc_if0->sk_phytype == SK_PHYTYPE_BCOM)
d1578 1
a1578 3

			if (ifp1 != NULL &&
			    sc_if1->sk_phytype == SK_PHYTYPE_BCOM)
a1603 2
	DPRINTFN(2, ("sk_init_xmac\n"));

d1634 2
a1635 2
		sk_xmac_miibus_writereg((struct device *)sc_if,
		    SK_PHYADDR_BCOM, BRGPHY_MII_BMCR, BRGPHY_BMCR_RESET);
d1637 2
a1638 2
		sk_xmac_miibus_writereg((struct device *)sc_if,
		    SK_PHYADDR_BCOM, BRGPHY_MII_IMR, 0xFFF0);
d1646 1
a1646 1
		if (sk_xmac_miibus_readreg((struct device *)sc_if,
d1649 1
a1649 1
				sk_xmac_miibus_writereg((struct device *)sc_if,
a1755 125
void sk_init_yukon(sc_if)
	struct sk_if_softc	*sc_if;
{
	u_int32_t		/*mac, */phy;
	u_int16_t		reg;
	int			i;

	DPRINTFN(2, ("sk_init_yukon: start: sk_csr=%#x\n",
		     CSR_READ_4(sc_if->sk_softc, SK_CSR)));

	/* GMAC and GPHY Reset */
	SK_IF_WRITE_4(sc_if, 0, SK_GPHY_CTRL, SK_GPHY_RESET_SET);

	DPRINTFN(6, ("sk_init_yukon: 1\n"));

	SK_IF_WRITE_4(sc_if, 0, SK_GMAC_CTRL, SK_GMAC_RESET_SET);
	DELAY(1000);
	SK_IF_WRITE_4(sc_if, 0, SK_GMAC_CTRL, SK_GMAC_RESET_CLEAR);
	SK_IF_WRITE_4(sc_if, 0, SK_GMAC_CTRL, SK_GMAC_RESET_SET);
	DELAY(1000);


	DPRINTFN(6, ("sk_init_yukon: 2\n"));

	phy = SK_GPHY_INT_POL_HI | SK_GPHY_DIS_FC | SK_GPHY_DIS_SLEEP |
		SK_GPHY_ENA_XC | SK_GPHY_ANEG_ALL | SK_GPHY_ENA_PAUSE;

	switch(sc_if->sk_softc->sk_pmd) {
	case IFM_1000_SX:
	case IFM_1000_LX:
		phy |= SK_GPHY_FIBER;
		break;

	case IFM_1000_CX:
	case IFM_1000_T:
		phy |= SK_GPHY_COPPER;
		break;
	}

	DPRINTFN(3, ("sk_init_yukon: phy=%#x\n", phy));

	SK_IF_WRITE_4(sc_if, 0, SK_GPHY_CTRL, phy | SK_GPHY_RESET_SET);
	DELAY(1000);
	SK_IF_WRITE_4(sc_if, 0, SK_GPHY_CTRL, phy | SK_GPHY_RESET_CLEAR);
	SK_IF_WRITE_4(sc_if, 0, SK_GMAC_CTRL, SK_GMAC_LOOP_OFF |
		      SK_GMAC_PAUSE_ON | SK_GMAC_RESET_CLEAR);

	DPRINTFN(3, ("sk_init_yukon: gmac_ctrl=%#x\n",
		     SK_IF_READ_4(sc_if, 0, SK_GMAC_CTRL)));

	DPRINTFN(6, ("sk_init_yukon: 3\n"));

	/* unused read of the interrupt source register */
	DPRINTFN(6, ("sk_init_yukon: 4\n"));
	SK_IF_READ_2(sc_if, 0, SK_GMAC_ISR);

	DPRINTFN(6, ("sk_init_yukon: 4a\n"));
	reg = SK_YU_READ_2(sc_if, YUKON_PAR);
	DPRINTFN(6, ("sk_init_yukon: YUKON_PAR=%#x\n", reg));

	/* MIB Counter Clear Mode set */
        reg |= YU_PAR_MIB_CLR;
	DPRINTFN(6, ("sk_init_yukon: YUKON_PAR=%#x\n", reg));
	DPRINTFN(6, ("sk_init_yukon: 4b\n"));
	SK_YU_WRITE_2(sc_if, YUKON_PAR, reg);
        
	/* MIB Counter Clear Mode clear */
	DPRINTFN(6, ("sk_init_yukon: 5\n"));
        reg &= ~YU_PAR_MIB_CLR;
	SK_YU_WRITE_2(sc_if, YUKON_PAR, reg);

	/* receive control reg */
	DPRINTFN(6, ("sk_init_yukon: 7\n"));
	SK_YU_WRITE_2(sc_if, YUKON_RCR, YU_RCR_UFLEN | YU_RCR_MUFLEN |
		      YU_RCR_CRCR);

	/* transmit parameter register */
	DPRINTFN(6, ("sk_init_yukon: 8\n"));
	SK_YU_WRITE_2(sc_if, YUKON_TPR, YU_TPR_JAM_LEN(0x3) |
		      YU_TPR_JAM_IPG(0xb) | YU_TPR_JAM2DATA_IPG(0x1a) );

	/* serial mode register */
	DPRINTFN(6, ("sk_init_yukon: 9\n"));
	SK_YU_WRITE_2(sc_if, YUKON_SMR, YU_SMR_DATA_BLIND(0x1c) |
		      YU_SMR_MFL_VLAN | YU_SMR_IPG_DATA(0x1e));

	DPRINTFN(6, ("sk_init_yukon: 10\n"));
	/* Setup Yukon's address */
	for (i = 0; i < 3; i++) {
		/* Write Source Address 1 (unicast filter) */
		SK_YU_WRITE_2(sc_if, YUKON_SAL1 + i * 4, 
			      sc_if->arpcom.ac_enaddr[i * 2] |
			      sc_if->arpcom.ac_enaddr[i * 2 + 1] << 8);
	}

	for (i = 0; i < 3; i++) {
		reg = sk_win_read_2(sc_if->sk_softc,
				    SK_MAC1_0 + i * 2 + sc_if->sk_port * 8);
		SK_YU_WRITE_2(sc_if, YUKON_SAL2 + i * 4, reg);
	}

	/* clear all Multicast filter hash registers */
	DPRINTFN(6, ("sk_init_yukon: 11\n"));
	SK_YU_WRITE_2(sc_if, YUKON_MCAH1, 0);
	SK_YU_WRITE_2(sc_if, YUKON_MCAH2, 0);
	SK_YU_WRITE_2(sc_if, YUKON_MCAH3, 0);
	SK_YU_WRITE_2(sc_if, YUKON_MCAH4, 0);

	/* enable interrupt mask for counter overflows */
	DPRINTFN(6, ("sk_init_yukon: 12\n"));
	SK_YU_WRITE_2(sc_if, YUKON_TIMR, 0);
	SK_YU_WRITE_2(sc_if, YUKON_RIMR, 0);
	SK_YU_WRITE_2(sc_if, YUKON_TRIMR, 0);

	/* Configure RX MAC FIFO */
	SK_IF_WRITE_1(sc_if, 0, SK_RXMF1_CTRL_TEST, SK_RFCTL_RESET_CLEAR);
	SK_IF_WRITE_4(sc_if, 0, SK_RXMF1_CTRL_TEST, SK_RFCTL_OPERATION_ON);
	
	/* Configure TX MAC FIFO */
	SK_IF_WRITE_1(sc_if, 0, SK_TXMF1_CTRL_TEST, SK_TFCTL_RESET_CLEAR);
	SK_IF_WRITE_4(sc_if, 0, SK_TXMF1_CTRL_TEST, SK_TFCTL_OPERATION_ON);
		
	DPRINTFN(6, ("sk_init_yukon: end\n"));
}

a1768 2
	DPRINTFN(2, ("sk_init\n"));

d1774 9
a1782 14
	if (sc->sk_type == SK_GENESIS) {
		/* Configure LINK_SYNC LED */
		SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_ON);
		SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL,
			      SK_LINKLED_LINKSYNC_ON);

		/* Configure RX LED */
		SK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL,
			      SK_RXLEDCTL_COUNTER_START);
		
		/* Configure TX LED */
		SK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL,
			      SK_TXLEDCTL_COUNTER_START);
	}
d1787 1
a1787 8
	switch (sc->sk_type) {
	case SK_GENESIS:
		sk_init_xmac(sc_if);
		break;
	case SK_YUKON:
		sk_init_yukon(sc_if);
		break;
	}
d1790 8
a1797 10
	if (sc->sk_type == SK_GENESIS) {
		/* Configure MAC FIFOs */
		SK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_UNRESET);
		SK_IF_WRITE_4(sc_if, 0, SK_RXF1_END, SK_FIFO_END);
		SK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_ON);
		
		SK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_UNRESET);
		SK_IF_WRITE_4(sc_if, 0, SK_TXF1_END, SK_FIFO_END);
		SK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_ON);
	}
d1861 3
a1863 14
	if (sc->sk_type == SK_GENESIS) {
		/* Enable XMACs TX and RX state machines */
		SK_XM_CLRBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_IGNPAUSE);
		SK_XM_SETBIT_2(sc_if, XM_MMUCMD,
			       XM_MMUCMD_TX_ENB|XM_MMUCMD_RX_ENB);
	}

	if (sc->sk_type == SK_YUKON) {
		u_int16_t reg = SK_YU_READ_2(sc_if, YUKON_GPCR);
		reg |= YU_GPCR_TXEN | YU_GPCR_RXEN;
		reg &= ~(YU_GPCR_SPEED_EN | YU_GPCR_DPLX_EN);
		SK_YU_WRITE_2(sc_if, YUKON_GPCR, reg);
	}

a1877 2
	DPRINTFN(2, ("sk_stop\n"));

d1897 2
a1898 11
	switch (sc->sk_type) {
	case SK_GENESIS:
		SK_IF_WRITE_2(sc_if, 0, SK_TXF1_MACCTL,
			      SK_TXMACCTL_XMAC_RESET);
		SK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_RESET);
		break;
	case SK_YUKON:
		SK_IF_WRITE_1(sc_if,0, SK_RXMF1_CTRL_TEST, SK_RFCTL_RESET_SET);
		SK_IF_WRITE_1(sc_if,0, SK_TXMF1_CTRL_TEST, SK_TFCTL_RESET_SET);
		break;
	}
a1951 72

#ifdef SK_DEBUG
void
sk_dump_txdesc(struct sk_tx_desc *desc, int idx)
{
#define DESC_PRINT(X)					\
	if (desc->X)					\
		printf("txdesc[%d]." #X "=%#x\n",	\
		       idx, desc->X);

	DESC_PRINT(sk_ctl);
	DESC_PRINT(sk_next);
	DESC_PRINT(sk_data_lo);
	DESC_PRINT(sk_data_hi);
	DESC_PRINT(sk_xmac_txstat);
	DESC_PRINT(sk_rsvd0);
	DESC_PRINT(sk_csum_startval);
	DESC_PRINT(sk_csum_startpos);
	DESC_PRINT(sk_csum_writepos);
	DESC_PRINT(sk_rsvd1);
#undef PRINT
}

void
sk_dump_bytes(const char *data, int len)
{
	int c, i, j;

	for (i = 0; i < len; i += 16) {
		printf("%08x  ", i);
		c = len - i;
		if (c > 16) c = 16;

		for (j = 0; j < c; j++) {
			printf("%02x ", data[i + j] & 0xff);
			if ((j & 0xf) == 7 && j > 0)
				printf(" ");
		}
		
		for (; j < 16; j++)
			printf("   ");
		printf("  ");

		for (j = 0; j < c; j++) {
			int ch = data[i + j] & 0xff;
			printf("%c", ' ' <= ch && ch <= '~' ? ch : ' ');
		}
		
		printf("\n");
		
		if (c < 16)
			break;
	}
}

void
sk_dump_mbuf(struct mbuf *m)
{
	int count = m->m_pkthdr.len;

	printf("m=%#lx, m->m_pkthdr.len=%#d\n", m, m->m_pkthdr.len);

	while (count > 0 && m) {
		printf("m=%#lx, m->m_data=%#lx, m->m_len=%d\n",
		       m, m->m_data, m->m_len);
		sk_dump_bytes(mtod(m, char *), m->m_len);

		count -= m->m_len;
		m = m->m_next;
	}
}
#endif
@


1.5.2.12
log
@Merge with the trunk
@
text
@d175 1
a175 2
u_int32_t sk_xmac_hash(caddr_t);
u_int32_t sk_yukon_hash(caddr_t);
d533 3
a535 4
#define XMAC_POLY	0xEDB88320
#define GMAC_POLY	0x04C11DB7L
#define HASH_BITS	6
  
d537 1
a537 1
sk_xmac_hash(caddr_t addr)
d539 1
a539 1
	u_int32_t crc;
d541 2
a542 3
	crc = ether_crc32_le(addr, ETHER_ADDR_LEN);
	return (~crc & ((1 << HASH_BITS) - 1));
}
d544 4
a547 4
u_int32_t
sk_yukon_hash(caddr_t addr)
{
	u_int32_t crc;
d549 1
a549 2
	crc = ether_crc32_be(addr, ETHER_ADDR_LEN);
	return (crc & ((1 << HASH_BITS) - 1));
d616 1
a616 9
				switch(sc->sk_type) {
				case SK_GENESIS:
					h = sk_xmac_hash(enm->enm_addrlo);
					break;
					
				case SK_YUKON:
					h = sk_yukon_hash(enm->enm_addrlo);
					break;
				}
d749 3
a751 1
		if (m_new == NULL)
d753 1
d1648 3
d2302 1
a2302 1
	/* Set multicast filter */
d2304 4
a2307 1
	sk_setmulti(sc_if);
@


1.4
log
@fix some panic bugs; jason
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.3 1999/10/04 12:21:39 jason Exp $	*/
a153 8

#ifdef SK_USEIOSPACE
#define SK_RES		SYS_RES_IOPORT
#define SK_RID		SK_PCI_LOIO
#else
#define SK_RES		SYS_RES_MEMORY
#define SK_RID		SK_PCI_LOMEM
#endif
@


1.3
log
@m_new is the new mbuf, not m
fix calculation of buffer slot number
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.2 1999/10/03 13:06:30 jason Exp $	*/
d133 2
a134 6
int sk_newbuf		__P((struct sk_if_softc *,
					struct sk_chain *, struct mbuf *));
int sk_alloc_jumbo_mem	__P((struct sk_if_softc *));
void *sk_jalloc		__P((struct sk_if_softc *));
void sk_jfree		__P((struct mbuf *));
void sk_jref		__P((struct mbuf *));
a559 2
		caddr_t			*buf = NULL;

d568 2
a569 2
		buf = sk_jalloc(sc_if);
		if (buf == NULL) {
d571 1
a571 5
#ifdef SK_VERBOSE
			printf("%s: jumbo allocation failed "
			    "-- packet dropped!\n", sc_if->sk_dev.dv_xname);
#endif
			return(ENOBUFS);
a572 8

		/* Attach the buffer to the mbuf */
		m_new->m_data = m_new->m_ext.ext_buf = (void *)buf;
		m_new->m_flags |= M_EXT;
		m_new->m_ext.ext_size = m_new->m_pkthdr.len =
		    m_new->m_len = SK_MCLBYTES;
		m_new->m_ext.ext_free = sk_jfree;
		m_new->m_ext.ext_ref = sk_jref;
a579 1
		m_new->m_len = m_new->m_pkthdr.len = SK_MCLBYTES;
d582 1
a582 1
	m_new->m_ext.ext_handle = sc_if;
a599 166
 * Allocate jumbo buffer storage. The SysKonnect adapters support
 * "jumbograms" (9K frames), although SysKonnect doesn't currently
 * use them in their drivers. In order for us to use them, we need
 * large 9K receive buffers, however standard mbuf clusters are only
 * 2048 bytes in size. Consequently, we need to allocate and manage
 * our own jumbo buffer pool. Fortunately, this does not require an
 * excessive amount of additional code.
 */
int sk_alloc_jumbo_mem(sc_if)
	struct sk_if_softc	*sc_if;
{
	caddr_t			ptr;
	register int		i;
	struct sk_jpool_entry   *entry;

	/* Grab a big chunk o' storage. */

#ifndef UVM
        sc_if->sk_cdata.sk_jumbo_buf = (caddr_t) vm_page_alloc_contig(
	    SK_JMEM, 0x100000, 0xffffffff, PAGE_SIZE);
#else
	sc_if->sk_cdata.sk_jumbo_buf = (caddr_t) uvm_pagealloc_contig(
	    SK_JMEM, 0x100000, 0xffffffff, PAGE_SIZE);
#endif

	if (sc_if->sk_cdata.sk_jumbo_buf == NULL) {
		printf("%s: no memory for jumbo buffers!\n",
		    sc_if->sk_dev.dv_xname);
		return(ENOBUFS);
	}

	LIST_INIT(&sc_if->sk_jfree_listhead);
	LIST_INIT(&sc_if->sk_jinuse_listhead);

	/*
	 * Now divide it up into 9K pieces and save the addresses
	 * in an array.
	 */
	ptr = sc_if->sk_cdata.sk_jumbo_buf;
	for (i = 0; i < SK_JSLOTS; i++) {
		sc_if->sk_cdata.sk_jslots[i].sk_buf = ptr;
		sc_if->sk_cdata.sk_jslots[i].sk_inuse = 0;
		ptr += SK_MCLBYTES;
		entry = malloc(sizeof(struct sk_jpool_entry), 
		    M_DEVBUF, M_NOWAIT);
		if (entry == NULL) {
			free(sc_if->sk_cdata.sk_jumbo_buf, M_DEVBUF);
			sc_if->sk_cdata.sk_jumbo_buf = NULL;
			printf("%s: no memory for jumbo "
			    "buffer queue!\n", sc_if->sk_dev.dv_xname);
			return(ENOBUFS);
		}
		entry->slot = i;
		LIST_INSERT_HEAD(&sc_if->sk_jfree_listhead,
		    entry, jpool_entries);
	}

	return(0);
}

/*
 * Allocate a jumbo buffer.
 */
void *sk_jalloc(sc_if)
	struct sk_if_softc	*sc_if;
{
	struct sk_jpool_entry   *entry;
	
	entry = LIST_FIRST(&sc_if->sk_jfree_listhead);
	
	if (entry == NULL) {
#ifdef SK_VERBOSE
		printf("%s: no free jumbo buffers\n", sc_if->sk_dev.dv_xname);
#endif
		return(NULL);
	}

	LIST_REMOVE(entry, jpool_entries);
	LIST_INSERT_HEAD(&sc_if->sk_jinuse_listhead, entry, jpool_entries);
	sc_if->sk_cdata.sk_jslots[entry->slot].sk_inuse = 1;
	return(sc_if->sk_cdata.sk_jslots[entry->slot].sk_buf);
}

/*
 * Adjust usage count on a jumbo buffer. In general this doesn't
 * get used much because our jumbo buffers don't get passed around
 * a lot, but it's implemented for correctness.
 */
void
sk_jref(m)
	struct mbuf *m;
{
	caddr_t			buf = m->m_ext.ext_buf;
	u_int			size = m->m_ext.ext_size;
	struct sk_if_softc	*sc_if;
	register int		i;

	/* Extract the softc struct pointer. */
	sc_if = (struct sk_if_softc *)m->m_ext.ext_handle;

	if (sc_if == NULL)
		panic("sk_jref: can't find softc pointer!");

	if (size != SK_MCLBYTES)
		panic("sk_jref: adjusting refcount of buf of wrong size!");

	/* calculate the slot this buffer belongs to */

	i = ((vaddr_t)buf - (vaddr_t)sc_if->sk_cdata.sk_jumbo_buf) / SK_JLEN;

	if ((i < 0) || (i >= SK_JSLOTS))
		panic("sk_jref: asked to reference buffer "
		    "that we don't manage!");
	else if (sc_if->sk_cdata.sk_jslots[i].sk_inuse == 0)
		panic("sk_jref: buffer already free!");
	else
		sc_if->sk_cdata.sk_jslots[i].sk_inuse++;
}

/*
 * Release a jumbo buffer.
 */
void
sk_jfree(m)
	struct mbuf *m;
{
	caddr_t buf = m->m_ext.ext_buf;
	u_int size = m->m_ext.ext_size;
	struct sk_if_softc *sc_if;
	int i;
	struct sk_jpool_entry *entry;

	/* Extract the softc struct pointer. */
	sc_if = (struct sk_if_softc *)m->m_ext.ext_handle;

	if (sc_if == NULL)
		panic("sk_jfree: can't find softc pointer!");

	if (size != SK_MCLBYTES)
		panic("sk_jfree: freeing buffer of wrong size!");

	/* calculate the slot this buffer belongs to */

	i = ((vaddr_t)buf - (vaddr_t)sc_if->sk_cdata.sk_jumbo_buf) / SK_JLEN;

	if ((i < 0) || (i >= SK_JSLOTS))
		panic("sk_jfree: asked to free buffer that we don't manage!");
	else if (sc_if->sk_cdata.sk_jslots[i].sk_inuse == 0)
		panic("sk_jfree: buffer already free!");
	else {
		sc_if->sk_cdata.sk_jslots[i].sk_inuse--;
		if(sc_if->sk_cdata.sk_jslots[i].sk_inuse == 0) {
			entry = LIST_FIRST(&sc_if->sk_jinuse_listhead);
			if (entry == NULL)
				panic("sk_jfree: buffer not in use!");
			entry->slot = i;
			LIST_REMOVE(entry, jpool_entries);
			LIST_INSERT_HEAD(&sc_if->sk_jfree_listhead, 
					  entry, jpool_entries);
		}
	}

	return;
}

/*
d829 4
a832 1
	int i;
d894 28
a921 14
#ifndef UVM
	sc_if->sk_rdata = (struct sk_ring_data *) vm_page_alloc_contig(
	    sizeof(struct sk_ring_data), 0x100000, 0xffffffff, PAGE_SIZE);
#else
	sc_if->sk_rdata = (struct sk_ring_data *) uvm_pagealloc_contig(
	    sizeof(struct sk_ring_data), 0x100000, 0xffffffff, PAGE_SIZE);
#endif

	if (sc_if->sk_rdata == NULL) {
		printf("%s: no memory for list buffers!\n",
		    sc_if->sk_dev.dv_xname);
		free(sc_if, M_DEVBUF);
		sc->sk_if[sa->skc_port] = NULL;
		return;
d923 1
a923 1

a925 10
	/* Try to allocate memory for jumbo buffers. */
	if (sk_alloc_jumbo_mem(sc_if)) {
		printf("%s: jumbo buffer allocation failed\n",
		    sc_if->sk_dev.dv_xname);
		free(sc_if->sk_rdata, M_DEVBUF);
		free(sc_if, M_DEVBUF);
		sc->sk_if[sa->skc_port] = NULL;
		return;
	}

d958 4
d1073 1
d1413 1
a1413 3
		if (sc_if->sk_link == 1) {
			printf("%s: gigabit link down\n",
			    sc_if->sk_dev.dv_xname);
a1414 1
		}
a1421 2
			printf("%s: gigabit link up\n",
			    sc_if->sk_dev.dv_xname);
@


1.2
log
@take advantage of m->m_ext.ext_handle for storing the softc
(instead of stashing it in the buffer)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.1 1999/10/01 02:52:22 jason Exp $	*/
d601 1
a601 1
	m->m_ext.ext_handle = sc_if;
d762 1
a762 1
	i = ((vaddr_t)aptr - (vaddr_t)sc_if->sk_cdata.sk_jumbo_buf) / SK_JLEN;
@


1.1
log
@driver for SysKonnect 984x gigabit ethernet adapters; from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d601 1
d655 1
a655 5
	 * in an array. Note that we play an evil trick here by using
	 * the first few bytes in the buffer to hold the the address
	 * of the softc structure for this interface. This is because
	 * sk_jfree() needs it, but it is called by the mbuf management
	 * code which will not pass it to us explicitly.
a658 4
		u_int64_t		**aptr;
		aptr = (u_int64_t **)ptr;
		aptr[0] = (u_int64_t *)sc_if;
		ptr += sizeof(u_int64_t);
a713 1
	u_int64_t		**aptr;
d717 1
a717 2
	aptr = (u_int64_t **)(buf - sizeof(u_int64_t));
	sc_if = (struct sk_if_softc *)(aptr[0]);
d727 1
a727 2
	i = ((vm_offset_t)aptr 
	     - (vm_offset_t)sc_if->sk_cdata.sk_jumbo_buf) / SK_JLEN;
a735 2

	return;
a747 1
	u_int64_t **aptr;
d752 1
a752 2
	aptr = (u_int64_t **)(buf - sizeof(u_int64_t));
	sc_if = (struct sk_if_softc *)(aptr[0]);
d762 1
a762 2
	i = ((vm_offset_t)aptr 
	     - (vm_offset_t)sc_if->sk_cdata.sk_jumbo_buf) / SK_JLEN;
@

