head	1.32;
access;
symbols
	OPENBSD_6_1:1.32.0.4
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.29.0.8
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.28.0.6
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.27.0.6
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.24.0.4
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.2
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.11.0.8
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.6
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.6
	SMP:1.5.0.4
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	UBC_SYNC_B:1.4
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	UBC:1.2.0.4
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.32
date	2016.12.12.06.47.22;	author ratchov;	state Exp;
branches;
next	1.31;
commitid	UEkb48yET72XBBwl;

1.31
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.30;
commitid	qGgYgJTgEFuAoGj4;

1.30
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.29;
commitid	pi1a9KN0itEngOc4;

1.29
date	2015.05.11.06.46.22;	author ratchov;	state Exp;
branches;
next	1.28;
commitid	RaOGL5SyOGOZylwx;

1.28
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.27;
commitid	OBNa5kfxQ2UXoiIw;

1.27
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.26;

1.26
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.25;

1.25
date	2012.10.11.15.45.00;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2011.12.07.10.31.31;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.22;

1.22
date	2010.09.07.16.21.44;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2010.08.27.18.50.57;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2010.08.27.04.09.19;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.13.02.22.19;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.02.18.06.31;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.15;

1.15
date	2008.05.29.02.10.01;	author jakemsr;	state Exp;
branches;
next	1.14;

1.14
date	2008.04.21.00.32.43;	author jakemsr;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.22.03.16.35;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.17.00.50.46;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.25.23.54.21;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.21.18.16.41;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.08.09.04.10.11;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.07.14.11.04;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.11.05.03.10;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2002.10.04.20.01.19;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2002.08.08.13.51.25;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2002.04.08.06.06.10;	author deraadt;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2002.04.08.01.47.33;	author frantzen;	state Exp;
branches;
next	;

1.2.4.1
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;

1.5.4.1
date	2003.05.13.19.35.05;	author ho;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2004.02.19.10.56.26;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Remove (likely wrong) code commented since revision 1.1. From
Michael W. Bombardieri <mb at ii.net>
@
text
@/*	$OpenBSD: esa.c,v 1.31 2016/09/19 06:46:44 ratchov Exp $	*/
/* $NetBSD: esa.c,v 1.12 2002/03/24 14:17:35 jmcneill Exp $ */

/*
 * Copyright (c) 2001, 2002 Jared D. McNeill <jmcneill@@invisible.ca>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Shamelessly stolen from NetBSD who based it on FreeBSD's who in turn
 * based it on Linux's driver.  What a wonderful world.
 *
 *
 * ESS Allegro-1 / Maestro3 Audio Driver
 *
 * Based on the FreeBSD maestro3 driver and the NetBSD eap driver.
 * Original driver by Don Kim.
 *
 * The list management code could possibly be written better, but what
 * we have right now does the job nicely. Thanks to Zach Brown <zab@@zabbo.net>
 * and Andrew MacDonald <amac@@epsilon.yi.org> for helping me debug the
 * problems with the original list management code present in the Linux
 * driver.
 */

#include <sys/types.h>
#include <sys/errno.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/exec.h>
#include <sys/selinfo.h>
#include <sys/audioio.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>

#include <dev/audio_if.h>
#include <dev/ic/ac97.h>

#include <dev/pci/esareg.h>
#include <dev/pci/esavar.h>
#include <dev/microcode/esa/esadsp.h>

#define PCI_CBIO	0x10

#define ESA_DAC_DATA	0x1100

enum {
	ESS_ALLEGRO1,
	ESS_MAESTRO3
};

static struct esa_card_type {
	u_int16_t pci_vendor_id;
	u_int16_t pci_product_id;
	int type;
	int delay1, delay2;
} esa_card_types[] = {
	{ PCI_VENDOR_ESSTECH, PCI_PRODUCT_ESSTECH_ES1989,
	  ESS_ALLEGRO1, 50, 800 },
	{ PCI_VENDOR_ESSTECH, PCI_PRODUCT_ESSTECH_MAESTRO3,
	  ESS_MAESTRO3, 20, 500 },
	{ PCI_VENDOR_ESSTECH, PCI_PRODUCT_ESSTECH_MAESTRO3_2,
	  ESS_MAESTRO3, 20, 500 },
	{ 0, 0, 0, 0, 0 }
};

int		esa_match(struct device *, void *, void *);
void		esa_attach(struct device *, struct device *, void *);
int		esa_detach(struct device *, int);
int		esa_activate(struct device *, int);

/* audio(9) functions */
int		esa_open(void *, int);
void		esa_close(void *);
int		esa_set_params(void *, int, int, struct audio_params *,
			       struct audio_params *);
int		esa_round_blocksize(void *, int);
int		esa_commit_settings(void *);
int		esa_halt_output(void *);
int		esa_halt_input(void *);
int		esa_set_port(void *, mixer_ctrl_t *);
int		esa_get_port(void *, mixer_ctrl_t *);
int		esa_query_devinfo(void *, mixer_devinfo_t *);
void *		esa_malloc(void *, int, size_t, int, int);
void		esa_free(void *, void *, int);
size_t		esa_round_buffersize(void *, int, size_t);
int		esa_get_props(void *);
int		esa_trigger_output(void *, void *, void *, int,
				   void (*)(void *), void *,
				   struct audio_params *);
int		esa_trigger_input(void *, void *, void *, int,
				  void (*)(void *), void *,
				  struct audio_params *);

int		esa_intr(void *);
int		esa_allocmem(struct esa_softc *, size_t, size_t,
			     struct esa_dma *);
int		esa_freemem(struct esa_softc *, struct esa_dma *);

/* Supporting subroutines */
u_int16_t	esa_read_assp(struct esa_softc *, u_int16_t, u_int16_t);
void		esa_write_assp(struct esa_softc *, u_int16_t, u_int16_t,
			       u_int16_t);
int		esa_init_codec(struct esa_softc *);
int		esa_attach_codec(void *, struct ac97_codec_if *);
int		esa_read_codec(void *, u_int8_t, u_int16_t *);
int		esa_write_codec(void *, u_int8_t, u_int16_t);
void		esa_reset_codec(void *);
enum ac97_host_flags	esa_flags_codec(void *);
int		esa_wait(struct esa_softc *);
int		esa_init(struct esa_softc *);
void		esa_config(struct esa_softc *);
u_int8_t	esa_assp_halt(struct esa_softc *);
void		esa_codec_reset(struct esa_softc *);
int		esa_amp_enable(struct esa_softc *);
void		esa_enable_interrupts(struct esa_softc *);
u_int32_t	esa_get_pointer(struct esa_softc *, struct esa_channel *);

/* list management */
int		esa_add_list(struct esa_voice *, struct esa_list *, u_int16_t,
			     int);
void		esa_remove_list(struct esa_voice *, struct esa_list *, int);

/* power management */
int		esa_suspend(struct esa_softc *);
int		esa_resume(struct esa_softc *);

struct audio_hw_if esa_hw_if = {
	esa_open,
	esa_close,
	esa_set_params,
	esa_round_blocksize,
	esa_commit_settings,
	NULL,			/* init_output */
	NULL,			/* init_input */
	NULL,			/* start_output */
	NULL,			/* start_input */
	esa_halt_output,
	esa_halt_input,
	NULL,			/* speaker_ctl */
	NULL,			/* getfd */
	esa_set_port,
	esa_get_port,
	esa_query_devinfo,
	esa_malloc,
	esa_free,
	esa_round_buffersize,
	esa_get_props,
	esa_trigger_output,
	esa_trigger_input
};

struct cfdriver esa_cd = {
	NULL, "esa", DV_DULL
};

struct cfattach esa_ca = {
	sizeof(struct esa_softc), esa_match, esa_attach,
	esa_detach, esa_activate
};

/*
 * audio(9) functions
 */

int
esa_open(void *hdl, int flags)
{

	return (0);
}

void
esa_close(void *hdl)
{

	return;
}

int
esa_set_params(void *hdl, int setmode, int usemode, struct audio_params *play,
	       struct audio_params *rec)
{
	struct esa_voice *vc = hdl;
	struct esa_channel *ch;
	struct audio_params *p;
	int mode;

	for (mode = AUMODE_RECORD; mode != -1;
	     mode = (mode == AUMODE_RECORD) ? AUMODE_PLAY : -1) {
		if ((setmode & mode) == 0)
			continue;

		switch (mode) {
		case AUMODE_PLAY:
			p = play;
			ch = &vc->play;
			break;
		case AUMODE_RECORD:
			p = rec;
			ch = &vc->rec;
			break;
		}

		if (p->sample_rate < ESA_MINRATE)
			p->sample_rate = ESA_MINRATE;
		if (p->sample_rate > ESA_MAXRATE)
			p->sample_rate = ESA_MAXRATE;
		if (p->precision > 16)
			p->precision = 16;
		if (p->channels > 2)
			p->channels = 2;

		switch(p->encoding) {
		case AUDIO_ENCODING_SLINEAR_LE:
			if (p->precision != 16)
				return EINVAL;
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
		case AUDIO_ENCODING_ULINEAR_BE:
			if (p->precision != 8)
				return EINVAL;
			break;
		default:
			return (EINVAL);
		}
		p->bps = AUDIO_BPS(p->precision);
		p->msb = 1;

		ch->mode = *p;
	}

	return (0);
}

int
esa_commit_settings(void *hdl)
{
	struct esa_voice *vc = hdl;
	struct esa_softc *sc = (struct esa_softc *)vc->parent;
	struct audio_params *p = &vc->play.mode;
	struct audio_params *r = &vc->rec.mode;
	u_int32_t data;
	u_int32_t freq;
	int data_bytes = (((ESA_MINISRC_TMP_BUFFER_SIZE & ~1) +
			   (ESA_MINISRC_IN_BUFFER_SIZE & ~1) +
			   (ESA_MINISRC_OUT_BUFFER_SIZE & ~1) + 4) + 255)
			   &~ 255;

	/* playback */
	vc->play.data_offset = ESA_DAC_DATA + (data_bytes * vc->index);
	if (p->channels == 1)
		data = 1;
	else
		data = 0;
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
		       vc->play.data_offset + ESA_SRC3_MODE_OFFSET,
		       data);
	if (p->precision == 8)
		data = 1;
	else
		data = 0;
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
		       vc->play.data_offset + ESA_SRC3_WORD_LENGTH_OFFSET,
		       data);
	if ((freq = ((p->sample_rate << 15) + 24000) / 48000) != 0) {
		freq--;
	}
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
		       vc->play.data_offset + ESA_CDATA_FREQUENCY, freq);

	/* recording */
	vc->rec.data_offset = ESA_DAC_DATA + (data_bytes * vc->index) +
			      (data_bytes / 2);
	if (r->channels == 1)
		data = 1;
	else
		data = 0;
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
		       vc->rec.data_offset + ESA_SRC3_MODE_OFFSET,
		       data);
	if (r->precision == 8)
		data = 1;
	else
		data = 0;
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
		       vc->rec.data_offset + ESA_SRC3_WORD_LENGTH_OFFSET,
		       data);
	if ((freq = ((r->sample_rate << 15) + 24000) / 48000) != 0) {
		freq--;
	}
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
		       vc->rec.data_offset + ESA_CDATA_FREQUENCY, freq);

	return (0);
};

int
esa_round_blocksize(void *hdl, int bs)
{
	struct esa_voice *vc = hdl;

	/*
	 * Surely there has to be a better solution...
	 */
	vc->play.blksize = vc->rec.blksize = 4096;

	return (vc->play.blksize);
}

int
esa_halt_output(void *hdl)
{
	struct esa_voice *vc = hdl;
	struct esa_softc *sc = (struct esa_softc *)vc->parent;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int16_t data;

	if (vc->play.active == 0)
		return (0);

	mtx_enter(&audio_lock);
	vc->play.active = 0;

	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
		       ESA_CDATA_INSTANCE_READY + vc->play.data_offset, 0);

	sc->sc_ntimers--;
	if (sc->sc_ntimers == 0) {
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
			       ESA_KDATA_TIMER_COUNT_RELOAD, 0);
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
			       ESA_KDATA_TIMER_COUNT_CURRENT, 0);
		data = bus_space_read_2(iot, ioh, ESA_HOST_INT_CTRL);
		bus_space_write_2(iot, ioh, ESA_HOST_INT_CTRL,
		    data & ~ESA_CLKRUN_GEN_ENABLE);
	}

	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
		       ESA_KDATA_MIXER_TASK_NUMBER,
		       sc->mixer_list.indexmap[vc->index]);
	/* remove ourselves from the packed lists */
	esa_remove_list(vc, &sc->mixer_list, vc->index);
	esa_remove_list(vc, &sc->dma_list, vc->index);
	esa_remove_list(vc, &sc->msrc_list, vc->index);
	mtx_leave(&audio_lock);
	return (0);
}

int
esa_halt_input(void *hdl)
{
	struct esa_voice *vc = hdl;
	struct esa_softc *sc = (struct esa_softc *)vc->parent;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int32_t data;

	if (vc->rec.active == 0)
		return (0);

	mtx_enter(&audio_lock);
	vc->rec.active = 0;

	sc->sc_ntimers--;
	if (sc->sc_ntimers == 0) {
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
			       ESA_KDATA_TIMER_COUNT_RELOAD, 0);
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
			       ESA_KDATA_TIMER_COUNT_CURRENT, 0);
		data = bus_space_read_2(iot, ioh, ESA_HOST_INT_CTRL);
		bus_space_write_2(iot, ioh, ESA_HOST_INT_CTRL,
				  data & ~ESA_CLKRUN_GEN_ENABLE);
	}

	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, vc->rec.data_offset +
		       ESA_CDATA_INSTANCE_READY, 0);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, ESA_KDATA_ADC1_REQUEST,
		       0);

	/* remove ourselves from the packed lists */
	esa_remove_list(vc, &sc->adc1_list, vc->index + ESA_NUM_VOICES);
	esa_remove_list(vc, &sc->dma_list, vc->index + ESA_NUM_VOICES);
	esa_remove_list(vc, &sc->msrc_list, vc->index + ESA_NUM_VOICES);
	mtx_leave(&audio_lock);
	return (0);
}

void *
esa_malloc(void *hdl, int direction, size_t size, int type, int flags)
{
	struct esa_voice *vc = hdl;
	struct esa_softc *sc = (struct esa_softc *)vc->parent;
	struct esa_dma *p;
	int error;

	p = malloc(sizeof(*p), type, flags);
	if (!p)
		return (0);
	error = esa_allocmem(sc, size, 16, p);
	if (error) {
		free(p, type, 0);
		printf("%s: esa_malloc: not enough memory\n",
		    sc->sc_dev.dv_xname);
		return (0);
	}
	p->next = vc->dma;
	vc->dma = p;

	return (KERNADDR(p));
}

void
esa_free(void *hdl, void *addr, int type)
{
	struct esa_voice *vc = hdl;
	struct esa_softc *sc = (struct esa_softc *)vc->parent;
	struct esa_dma *p;
	struct esa_dma **pp;

	for (pp = &vc->dma; (p = *pp) != NULL; pp = &p->next)
		if (KERNADDR(p) == addr) {
			esa_freemem(sc, p);
			*pp = p->next;
			free(p, type, 0);
			return;
		}
}

int
esa_set_port(void *hdl, mixer_ctrl_t *mc)
{
	struct esa_voice *vc = hdl;
	struct esa_softc *sc = (struct esa_softc *)vc->parent;

	return (sc->codec_if->vtbl->mixer_set_port(sc->codec_if, mc));
}

int
esa_get_port(void *hdl, mixer_ctrl_t *mc)
{
	struct esa_voice *vc = hdl;
	struct esa_softc *sc = (struct esa_softc *)vc->parent;

	return (sc->codec_if->vtbl->mixer_get_port(sc->codec_if, mc));
}

int
esa_query_devinfo(void *hdl, mixer_devinfo_t *di)
{
	struct esa_voice *vc = hdl;
	struct esa_softc *sc = (struct esa_softc *)vc->parent;

	return (sc->codec_if->vtbl->query_devinfo(sc->codec_if, di));
}

size_t
esa_round_buffersize(void *hdl, int direction, size_t bufsize)
{
	struct esa_voice *vc = hdl;

	/*
	 * We must be able to do better than this...
	 */
	vc->play.bufsize = vc->rec.bufsize = 65536;

	return (vc->play.bufsize);
}

int
esa_get_props(void *hdl)
{

	return (AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT | AUDIO_PROP_FULLDUPLEX);
}

int
esa_trigger_output(void *hdl, void *start, void *end, int blksize,
			void (*intr)(void *), void *intrarg,
			struct audio_params *param)
{
	struct esa_voice *vc = hdl;
	struct esa_softc *sc = (struct esa_softc *)vc->parent;
	struct esa_dma *p;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int32_t data;
	u_int32_t bufaddr;
	u_int32_t i;
	size_t size;

	int data_bytes = (((ESA_MINISRC_TMP_BUFFER_SIZE & ~1) +
			   (ESA_MINISRC_IN_BUFFER_SIZE & ~1) +
			   (ESA_MINISRC_OUT_BUFFER_SIZE & ~1) + 4) + 255)
			   &~ 255;
	int dac_data = ESA_DAC_DATA + (data_bytes * vc->index);
	int dsp_in_size = ESA_MINISRC_IN_BUFFER_SIZE - (0x20 * 2);
	int dsp_out_size = ESA_MINISRC_OUT_BUFFER_SIZE - (0x20 * 2);
	int dsp_in_buf = dac_data + (ESA_MINISRC_TMP_BUFFER_SIZE / 2);
	int dsp_out_buf = dsp_in_buf + (dsp_in_size / 2) + 1;

	if (vc->play.active)
		return (EINVAL);

	for (p = vc->dma; p && KERNADDR(p) != start; p = p->next)
		;
	if (!p) {
		printf("%s: esa_trigger_output: bad addr %p\n",
		    sc->sc_dev.dv_xname, start);
		return (EINVAL);
	}

	vc->play.active = 1;
	vc->play.intr = intr;
	vc->play.arg = intrarg;
	vc->play.pos = 0;
	vc->play.count = 0;
	vc->play.buf = start;
	size = (size_t)(((caddr_t)end - (caddr_t)start));
	bufaddr = DMAADDR(p);
	vc->play.start = bufaddr;

#define LO(x) ((x) & 0x0000ffff)
#define HI(x) ((x) >> 16)

	mtx_enter(&audio_lock);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_CDATA_HOST_SRC_ADDRL, LO(bufaddr));
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_CDATA_HOST_SRC_ADDRH, HI(bufaddr));
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_CDATA_HOST_SRC_END_PLUS_1L, LO(bufaddr + size));
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_CDATA_HOST_SRC_END_PLUS_1H, HI(bufaddr + size));
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_CDATA_HOST_SRC_CURRENTL, LO(bufaddr));
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_CDATA_HOST_SRC_CURRENTH, HI(bufaddr));

	/* DSP buffers */
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_CDATA_IN_BUF_BEGIN, dsp_in_buf);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_CDATA_IN_BUF_END_PLUS_1, dsp_in_buf + (dsp_in_size / 2));
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_CDATA_IN_BUF_HEAD, dsp_in_buf);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_CDATA_IN_BUF_TAIL, dsp_in_buf);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_CDATA_OUT_BUF_BEGIN, dsp_out_buf);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_CDATA_OUT_BUF_END_PLUS_1, dsp_out_buf + (dsp_out_size / 2));
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_CDATA_OUT_BUF_HEAD, dsp_out_buf);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_CDATA_OUT_BUF_TAIL, dsp_out_buf);

	/* Some per-client initializers */
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_SRC3_DIRECTION_OFFSET + 12, dac_data + 40 + 8);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_SRC3_DIRECTION_OFFSET + 19, 0x400 + ESA_MINISRC_COEF_LOC);
	/* Enable or disable low-pass filter? (0xff if rate > 45000) */
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_SRC3_DIRECTION_OFFSET + 22,
	    vc->play.mode.sample_rate > 45000 ? 0xff : 0);
	/* Tell it which way DMA is going */
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_CDATA_DMA_CONTROL,
	    ESA_DMACONTROL_AUTOREPEAT + ESA_DMAC_PAGE3_SELECTOR +
	    ESA_DMAC_BLOCKF_SELECTOR);

	/* Set an armload of static initializers */
	for (i = 0; i < nitems(esa_playvals); i++)
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
		    esa_playvals[i].addr, esa_playvals[i].val);

	/* Put us in the packed task lists */
	esa_add_list(vc, &sc->msrc_list, dac_data >> ESA_DP_SHIFT_COUNT,
		     vc->index);
	esa_add_list(vc, &sc->dma_list, dac_data >> ESA_DP_SHIFT_COUNT,
		     vc->index);
	esa_add_list(vc, &sc->mixer_list, dac_data >> ESA_DP_SHIFT_COUNT,
		     vc->index);
#undef LO
#undef HI

	sc->sc_ntimers++;

	if (sc->sc_ntimers == 1) {
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
		    ESA_KDATA_TIMER_COUNT_RELOAD, 240);
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
		    ESA_KDATA_TIMER_COUNT_CURRENT, 240);
		data = bus_space_read_2(iot, ioh, ESA_HOST_INT_CTRL);
		bus_space_write_2(iot, ioh, ESA_HOST_INT_CTRL,
		    data | ESA_CLKRUN_GEN_ENABLE);
	}

	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, dac_data +
	    ESA_CDATA_INSTANCE_READY, 1);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
	    ESA_KDATA_MIXER_TASK_NUMBER,
	    sc->mixer_list.indexmap[vc->index]);
	mtx_leave(&audio_lock);
	return (0);
}

int
esa_trigger_input(void *hdl, void *start, void *end, int blksize,
			void (*intr)(void *), void *intrarg,
			struct audio_params *param)
{
	struct esa_voice *vc = hdl;
	struct esa_softc *sc = (struct esa_softc *)vc->parent;
	struct esa_dma *p;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int32_t data;
	u_int32_t bufaddr;
	u_int32_t i;
	size_t size;
	int data_bytes = (((ESA_MINISRC_TMP_BUFFER_SIZE & ~1) +
			   (ESA_MINISRC_IN_BUFFER_SIZE & ~1) +
			   (ESA_MINISRC_OUT_BUFFER_SIZE & ~1) + 4) + 255)
			   &~ 255;
	int adc_data = ESA_DAC_DATA + (data_bytes * vc->index) +
		       (data_bytes / 2);
	int dsp_in_size = ESA_MINISRC_IN_BUFFER_SIZE - (0x10 * 2);
	int dsp_out_size = ESA_MINISRC_OUT_BUFFER_SIZE - (0x10 * 2);
	int dsp_in_buf = adc_data + (ESA_MINISRC_TMP_BUFFER_SIZE / 2);
	int dsp_out_buf = dsp_in_buf + (dsp_in_size / 2) + 1;
	vc->rec.data_offset = adc_data;

	/* We only support 1 recording channel */
	if (vc->index > 0)
		return (ENODEV);

	if (vc->rec.active)
		return (EINVAL);

	for (p = vc->dma; p && KERNADDR(p) != start; p = p->next)
		;
	if (!p) {
		printf("%s: esa_trigger_input: bad addr %p\n",
		    sc->sc_dev.dv_xname, start);
		return (EINVAL);
	}

	vc->rec.active = 1;
	vc->rec.intr = intr;
	vc->rec.arg = intrarg;
	vc->rec.pos = 0;
	vc->rec.count = 0;
	vc->rec.buf = start;
	size = (size_t)(((caddr_t)end - (caddr_t)start));
	bufaddr = DMAADDR(p);
	vc->rec.start = bufaddr;

#define LO(x) ((x) & 0x0000ffff)
#define HI(x) ((x) >> 16)
	mtx_enter(&audio_lock);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, adc_data +
	    ESA_CDATA_HOST_SRC_ADDRL, LO(bufaddr));
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, adc_data +
	    ESA_CDATA_HOST_SRC_ADDRH, HI(bufaddr));
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, adc_data +
	    ESA_CDATA_HOST_SRC_END_PLUS_1L, LO(bufaddr + size));
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, adc_data +
	    ESA_CDATA_HOST_SRC_END_PLUS_1H, HI(bufaddr + size));
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, adc_data +
	    ESA_CDATA_HOST_SRC_CURRENTL, LO(bufaddr));
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, adc_data +
	    ESA_CDATA_HOST_SRC_CURRENTH, HI(bufaddr));

	/* DSP buffers */
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, adc_data +
	    ESA_CDATA_IN_BUF_BEGIN, dsp_in_buf);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, adc_data +
	    ESA_CDATA_IN_BUF_END_PLUS_1, dsp_in_buf + (dsp_in_size / 2));
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, adc_data +
	    ESA_CDATA_IN_BUF_HEAD, dsp_in_buf);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, adc_data +
	    ESA_CDATA_IN_BUF_TAIL, dsp_in_buf);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, adc_data +
	    ESA_CDATA_OUT_BUF_BEGIN, dsp_out_buf);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, adc_data +
	    ESA_CDATA_OUT_BUF_END_PLUS_1, dsp_out_buf + (dsp_out_size / 2));
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, adc_data +
	    ESA_CDATA_OUT_BUF_HEAD, dsp_out_buf);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, adc_data +
	    ESA_CDATA_OUT_BUF_TAIL, dsp_out_buf);

	/* Some per-client initializers */
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, adc_data +
	    ESA_SRC3_DIRECTION_OFFSET + 12, adc_data + 40 + 8);
	/* Tell it which way DMA is going */
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, adc_data +
	    ESA_CDATA_DMA_CONTROL,
	    ESA_DMACONTROL_DIRECTION + ESA_DMACONTROL_AUTOREPEAT +
	    ESA_DMAC_PAGE3_SELECTOR + ESA_DMAC_BLOCKF_SELECTOR);

	/* Set an armload of static initializers */
	for (i = 0; i < nitems(esa_recvals); i++)
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, adc_data +
		    esa_recvals[i].addr, esa_recvals[i].val);

	/* Put us in the packed task lists */
	esa_add_list(vc, &sc->adc1_list, adc_data >> ESA_DP_SHIFT_COUNT,
		     vc->index + ESA_NUM_VOICES);
	esa_add_list(vc, &sc->msrc_list, adc_data >> ESA_DP_SHIFT_COUNT,
		     vc->index + ESA_NUM_VOICES);
	esa_add_list(vc, &sc->dma_list, adc_data >> ESA_DP_SHIFT_COUNT,
		     vc->index + ESA_NUM_VOICES);
#undef LO
#undef HI

	sc->sc_ntimers++;
	if (sc->sc_ntimers == 1) {
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
		    ESA_KDATA_TIMER_COUNT_RELOAD, 240);
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
		    ESA_KDATA_TIMER_COUNT_CURRENT, 240);
		data = bus_space_read_2(iot, ioh, ESA_HOST_INT_CTRL);
		bus_space_write_2(iot, ioh, ESA_HOST_INT_CTRL,
		    data | ESA_CLKRUN_GEN_ENABLE);
	}

	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, adc_data +
	    ESA_CDATA_INSTANCE_READY, 1);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, ESA_KDATA_ADC1_REQUEST,
	    1);
	mtx_leave(&audio_lock);
	return (0);
}

/* Interrupt handler */

int
esa_intr(void *hdl)
{
	struct esa_softc *sc = hdl;
	struct esa_voice *vc;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int8_t status, ctl;
	u_int32_t pos;
	u_int32_t diff;
	u_int32_t play_blksize, play_bufsize;
	u_int32_t rec_blksize, rec_bufsize;
	int i, claimed = 0;

	mtx_enter(&audio_lock);
	status = bus_space_read_1(iot, ioh, ESA_HOST_INT_STATUS);
	if (status == 0xff) {
		mtx_leave(&audio_lock);
		return (0);
	}

	/* ack the interrupt */
	bus_space_write_1(iot, ioh, ESA_HOST_INT_STATUS, status);

	if (status & ESA_HV_INT_PENDING) {
		u_int8_t event;

		printf("%s: hardware volume interrupt\n", sc->sc_dev.dv_xname);
		event = bus_space_read_1(iot, ioh, ESA_HW_VOL_COUNTER_MASTER);
		switch(event) {
		case 0x99:
		case 0xaa:
		case 0x66:
		case 0x88:
			printf("%s: esa_intr: FIXME\n", sc->sc_dev.dv_xname);
			break;
		default:
			printf("%s: unknown hwvol event 0x%02x\n",
			    sc->sc_dev.dv_xname, event);
			break;
		}
		bus_space_write_1(iot, ioh, ESA_HW_VOL_COUNTER_MASTER, 0x88);
		claimed = 1;
	}

	if (status & ESA_ASSP_INT_PENDING) {
		ctl = bus_space_read_1(iot, ioh, ESA_ASSP_CONTROL_B);
		if (!(ctl & ESA_STOP_ASSP_CLOCK)) {
			ctl = bus_space_read_1(iot, ioh,
					       ESA_ASSP_HOST_INT_STATUS);
			if (ctl & ESA_DSP2HOST_REQ_TIMER) {
				bus_space_write_1(iot, ioh,
				    ESA_ASSP_HOST_INT_STATUS,
				    ESA_DSP2HOST_REQ_TIMER);
				for (i = 0; i < ESA_NUM_VOICES; i++) {
					vc = &sc->voice[i];
					if (vc->play.active) {
						play_blksize = vc->play.blksize;
						play_bufsize = vc->play.bufsize;
						pos = esa_get_pointer(sc, &vc->play)
						    % play_bufsize;
						diff = (play_bufsize + pos - vc->play.pos)
						    % play_bufsize;
						vc->play.pos = pos;
						vc->play.count += diff;
						while(vc->play.count >= play_blksize) {
							vc->play.count -= play_blksize;
							(*vc->play.intr)(vc->play.arg);
						}
					}
					if (vc->rec.active) {
						rec_blksize = vc->rec.blksize;
						rec_bufsize = vc->rec.bufsize;
						pos = esa_get_pointer(sc, &vc->rec)
						    % rec_bufsize;
						diff = (rec_bufsize + pos - vc->rec.pos)
						    % rec_bufsize;
						vc->rec.pos = pos;
						vc->rec.count += diff;
						while(vc->rec.count >= rec_blksize) {
							vc->rec.count -= rec_blksize;
							(*vc->rec.intr)(vc->rec.arg);
						}
					}
				}
			}
		}
		claimed = 1;
	}
	mtx_leave(&audio_lock);
	return (claimed);
}

int
esa_allocmem(struct esa_softc *sc, size_t size, size_t align,
		struct esa_dma *p)
{
	int error;

	p->size = size;
	error = bus_dmamem_alloc(sc->sc_dmat, p->size, align, 0,
				 p->segs, sizeof(p->segs) / sizeof(p->segs[0]),
				 &p->nsegs, BUS_DMA_NOWAIT);
	if (error)
		return (error);

	error = bus_dmamem_map(sc->sc_dmat, p->segs, p->nsegs, p->size,
				&p->addr, BUS_DMA_NOWAIT | BUS_DMA_COHERENT);
	if (error)
		goto free;

	error = bus_dmamap_create(sc->sc_dmat, p->size, 1, p->size, 0,
				  BUS_DMA_NOWAIT, &p->map);
	if (error)
		goto unmap;

	error = bus_dmamap_load(sc->sc_dmat, p->map, p->addr, p->size, NULL,
				BUS_DMA_NOWAIT);
	if (error)
		goto destroy;

	return (0);

destroy:
	bus_dmamap_destroy(sc->sc_dmat, p->map);
unmap:
	bus_dmamem_unmap(sc->sc_dmat, p->addr, p->size);
free:
	bus_dmamem_free(sc->sc_dmat, p->segs, p->nsegs);

	return (error);
}

int
esa_freemem(struct esa_softc *sc, struct esa_dma *p)
{

	bus_dmamap_unload(sc->sc_dmat, p->map);
	bus_dmamap_destroy(sc->sc_dmat, p->map);
	bus_dmamem_unmap(sc->sc_dmat, p->addr, p->size);
	bus_dmamem_free(sc->sc_dmat, p->segs, p->nsegs);

	return (0);
}

/*
 * Supporting Subroutines
 */
const struct pci_matchid esa_devices[] = {
	{ PCI_VENDOR_ESSTECH, PCI_PRODUCT_ESSTECH_ES1989 },
	{ PCI_VENDOR_ESSTECH, PCI_PRODUCT_ESSTECH_MAESTRO3 },
	{ PCI_VENDOR_ESSTECH, PCI_PRODUCT_ESSTECH_MAESTRO3_2 },
};

int
esa_match(struct device *dev, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, esa_devices,
	    nitems(esa_devices)));
}

void
esa_attach(struct device *parent, struct device *self, void *aux)
{
	struct esa_softc *sc = (struct esa_softc *)self;
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	pcitag_t tag = pa->pa_tag;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	struct esa_card_type *card;
	const char *intrstr;
	int i, len;

	for (card = esa_card_types; card->pci_vendor_id; card++)
		if (PCI_VENDOR(pa->pa_id) == card->pci_vendor_id &&
		    PCI_PRODUCT(pa->pa_id) == card->pci_product_id) {
			sc->type = card->type;
			sc->delay1 = card->delay1;
			sc->delay2 = card->delay2;
			break;
		}

	/* Map I/O register */
	if (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->sc_iot, &sc->sc_ioh, &sc->sc_iob, &sc->sc_ios, 0)) {
		printf(": can't map i/o space\n");
		return;
	}

	/* Initialize softc */
	sc->sc_tag = tag;
	sc->sc_pct = pc;
	sc->sc_dmat = pa->pa_dmat;

	/* Map and establish an interrupt */
	if (pci_intr_map(pa, &ih)) {
		printf(": can't map interrupt\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO | IPL_MPSAFE,
	    esa_intr, self, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": can't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
		return;
	}
	printf(": %s\n", intrstr);

	/* Power up chip */
	pci_set_powerstate(pc, tag, PCI_PMCSR_STATE_D0);

	/* Init chip */
	if (esa_init(sc) == -1) {
		printf("%s: esa_attach: unable to initialize the card\n",
		    sc->sc_dev.dv_xname);
		pci_intr_disestablish(pc, sc->sc_ih);
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
		return;
	}

	/* create suspend save area */
	len = sizeof(u_int16_t) * (ESA_REV_B_CODE_MEMORY_LENGTH
	    + ESA_REV_B_DATA_MEMORY_LENGTH + 1);
	sc->savemem = malloc(len, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sc->savemem == NULL) {
		printf("%s: unable to allocate suspend buffer\n",
		    sc->sc_dev.dv_xname);
		pci_intr_disestablish(pc, sc->sc_ih);
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
		return;
	}

	/*
	 * Every card I've seen has had their channels swapped with respect
	 * to the mixer. Ie:
	 *  $ mixerctl -w outputs.master=0,191
	 * Would result in the _right_ speaker being turned off.
	 *
	 * So, we will swap the left and right mixer channels to compensate
	 * for this.
	 */
	sc->codec_flags |= AC97_HOST_SWAPPED_CHANNELS;
	sc->codec_flags |= AC97_HOST_DONT_READ;

	/* Attach AC97 host interface */
	sc->host_if.arg = self;
	sc->host_if.attach = esa_attach_codec;
	sc->host_if.read = esa_read_codec;
	sc->host_if.write = esa_write_codec;
	sc->host_if.reset = esa_reset_codec;
	sc->host_if.flags = esa_flags_codec;

	if (ac97_attach(&sc->host_if) != 0) {
		pci_intr_disestablish(pc, sc->sc_ih);
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
		free(sc->savemem, M_DEVBUF, 0);
		return;
	}

	/* initialize list management structures */
	sc->mixer_list.mem_addr = ESA_KDATA_MIXER_XFER0;
	sc->mixer_list.max = ESA_MAX_VIRTUAL_MIXER_CHANNELS;
	sc->adc1_list.mem_addr = ESA_KDATA_ADC1_XFER0;
	sc->adc1_list.max = ESA_MAX_VIRTUAL_ADC1_CHANNELS;
	sc->dma_list.mem_addr = ESA_KDATA_DMA_XFER0;
	sc->dma_list.max = ESA_MAX_VIRTUAL_DMA_CHANNELS;
	sc->msrc_list.mem_addr = ESA_KDATA_INSTANCE0_MINISRC;
	sc->msrc_list.max = ESA_MAX_INSTANCE_MINISRC;

	/* initialize index maps */
	for (i = 0; i < ESA_NUM_VOICES * 2; i++) {
		sc->mixer_list.indexmap[i] = -1;
		sc->msrc_list.indexmap[i] = -1;
		sc->dma_list.indexmap[i] = -1;
		sc->adc1_list.indexmap[i] = -1;
	}
	for (i = 0; i < ESA_NUM_VOICES; i++) {
		sc->voice[i].parent = (struct device *)sc;
		sc->voice[i].index = i;
		sc->sc_audiodev[i] =
		    audio_attach_mi(&esa_hw_if, &sc->voice[i], &sc->sc_dev);
	}
}

int
esa_detach(struct device *self, int flags)
{
	struct esa_softc *sc = (struct esa_softc *)self;
	int i;

	for (i = 0; i < ESA_NUM_VOICES; i++) {
		if (sc->sc_audiodev[i] != NULL)
			config_detach(sc->sc_audiodev[i], flags);
	}

	if (sc->sc_ih != NULL)
		pci_intr_disestablish(sc->sc_pct, sc->sc_ih);
	if (sc->sc_ios)
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);

	free(sc->savemem, M_DEVBUF, 0);

	return (0);
}

u_int16_t
esa_read_assp(struct esa_softc *sc, u_int16_t region, u_int16_t index)
{
	u_int16_t data;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	bus_space_write_2(iot, ioh, ESA_DSP_PORT_MEMORY_TYPE,
	    region & ESA_MEMTYPE_MASK);
	bus_space_write_2(iot, ioh, ESA_DSP_PORT_MEMORY_INDEX, index);
	data = bus_space_read_2(iot, ioh, ESA_DSP_PORT_MEMORY_DATA);

	return (data);
}

void
esa_write_assp(struct esa_softc *sc, u_int16_t region, u_int16_t index,
		u_int16_t data)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	bus_space_write_2(iot, ioh, ESA_DSP_PORT_MEMORY_TYPE,
	    region & ESA_MEMTYPE_MASK);
	bus_space_write_2(iot, ioh, ESA_DSP_PORT_MEMORY_INDEX, index);
	bus_space_write_2(iot, ioh, ESA_DSP_PORT_MEMORY_DATA, data);

	return;
}

int
esa_init_codec(struct esa_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int32_t data;

	data = bus_space_read_1(iot, ioh, ESA_CODEC_COMMAND);

	return ((data & 0x1) ? 0 : 1);
}

int
esa_attach_codec(void *aux, struct ac97_codec_if *codec_if)
{
	struct esa_softc *sc = aux;

	sc->codec_if = codec_if;

	return (0);
}

int
esa_read_codec(void *aux, u_int8_t reg, u_int16_t *result)
{
	struct esa_softc *sc = aux;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	if (esa_wait(sc))
		printf("%s: esa_read_codec: timed out\n", sc->sc_dev.dv_xname);
	bus_space_write_1(iot, ioh, ESA_CODEC_COMMAND, (reg & 0x7f) | 0x80);
	delay(50);
	if (esa_wait(sc))
		printf("%s: esa_read_codec: timed out\n", sc->sc_dev.dv_xname);
	*result = bus_space_read_2(iot, ioh, ESA_CODEC_DATA);

	return (0);
}

int
esa_write_codec(void *aux, u_int8_t reg, u_int16_t data)
{
	struct esa_softc *sc = aux;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	if (esa_wait(sc)) {
		printf("%s: esa_write_codec: timed out\n", sc->sc_dev.dv_xname);
		return (-1);
	}
	bus_space_write_2(iot, ioh, ESA_CODEC_DATA, data);
	bus_space_write_1(iot, ioh, ESA_CODEC_COMMAND, reg & 0x7f);
	delay(50);

	return (0);
}

void
esa_reset_codec(void *aux)
{

	return;
}

enum ac97_host_flags
esa_flags_codec(void *aux)
{
	struct esa_softc *sc = aux;

	return (sc->codec_flags);
}

int
esa_wait(struct esa_softc *sc)
{
	int i, val;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	for (i = 0; i < 20; i++) {
		val = bus_space_read_1(iot, ioh, ESA_CODEC_STATUS);
		if ((val & 1) == 0)
			return (0);
		delay(2);
	}

	return (-1);
}

int
esa_init(struct esa_softc *sc)
{
	struct esa_voice *vc;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	pcitag_t tag = sc->sc_tag;
	pci_chipset_tag_t pc = sc->sc_pct;
	u_int32_t data, i, size;
	u_int8_t reset_state;
	int data_bytes = (((ESA_MINISRC_TMP_BUFFER_SIZE & ~1) +
			   (ESA_MINISRC_IN_BUFFER_SIZE & ~1) +
			   (ESA_MINISRC_OUT_BUFFER_SIZE & ~1) + 4) + 255)
			   &~ 255;

	/* Disable legacy emulation */
	data = pci_conf_read(pc, tag, PCI_LEGACY_AUDIO_CTRL);
	data |= DISABLE_LEGACY;
	pci_conf_write(pc, tag, PCI_LEGACY_AUDIO_CTRL, data);

	esa_config(sc);

	reset_state = esa_assp_halt(sc);

	esa_init_codec(sc);
	esa_codec_reset(sc);

	/* Zero kernel and mixer data */
	size = ESA_REV_B_DATA_MEMORY_UNIT_LENGTH * ESA_NUM_UNITS_KERNEL_DATA;
	for (i = 0; i < size / 2; i++) {
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
		    ESA_KDATA_BASE_ADDR + i, 0);
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
		    ESA_KDATA_BASE_ADDR2 + i, 0);
	}

	/* Init DMA pointer */
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, ESA_KDATA_CURRENT_DMA,
	    ESA_KDATA_DMA_XFER0);

	/* Write kernel code into memory */
	size = nitems(esa_assp_kernel_image);
	for (i = 0; i < size; i++)
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_CODE,
		    ESA_REV_B_CODE_MEMORY_BEGIN + i, esa_assp_kernel_image[i]);

	size = nitems(esa_assp_minisrc_image);
	for (i = 0; i < size; i++)
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_CODE, 0x400 + i,
		    esa_assp_minisrc_image[i]);

	/* Write the coefficients for the low pass filter */
	size = nitems(esa_minisrc_lpf_image);
	for (i = 0; i < size; i++)
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_CODE,
		    0x400 + ESA_MINISRC_COEF_LOC + i, esa_minisrc_lpf_image[i]);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_CODE,
	    0x400 + ESA_MINISRC_COEF_LOC + size, 0x8000);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, ESA_KDATA_TASK0, 0x400);
	/* Init the mixer number */
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
             ESA_KDATA_MIXER_TASK_NUMBER, 0);
	/* Extreme kernel master volume */
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
	    ESA_KDATA_DAC_LEFT_VOLUME, ESA_ARB_VOLUME);
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
            ESA_KDATA_DAC_RIGHT_VOLUME, ESA_ARB_VOLUME);

	if (esa_amp_enable(sc))
		return (-1);

	/* Zero entire DAC/ADC area */
	for (i = 0x1100; i < 0x1c00; i++)
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, i, 0);

	/* set some sane defaults */
	for (i = 0; i < ESA_NUM_VOICES; i++) {
		vc = &sc->voice[i];
		vc->play.data_offset = ESA_DAC_DATA + (data_bytes * i);
		vc->rec.data_offset = ESA_DAC_DATA + (data_bytes * i * 2);
	}

	esa_enable_interrupts(sc);

	bus_space_write_1(iot, ioh, ESA_DSP_PORT_CONTROL_REG_B,
	    reset_state | ESA_REGB_ENABLE_RESET);

	return (0);
}

void
esa_config(struct esa_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	pcitag_t tag = sc->sc_tag;
	pci_chipset_tag_t pc = sc->sc_pct;
	u_int32_t data;

	data = pci_conf_read(pc, tag, ESA_PCI_ALLEGRO_CONFIG);
	data &= ESA_REDUCED_DEBOUNCE;
	data |= ESA_PM_CTRL_ENABLE | ESA_CLK_DIV_BY_49 | ESA_USE_PCI_TIMING;
	pci_conf_write(pc, tag, ESA_PCI_ALLEGRO_CONFIG, data);

	bus_space_write_1(iot, ioh, ESA_ASSP_CONTROL_B, ESA_RESET_ASSP);
	data = pci_conf_read(pc, tag, ESA_PCI_ALLEGRO_CONFIG);
	data &= ~ESA_INT_CLK_SELECT;
	if (sc->type == ESS_MAESTRO3) {
		data &= ~ESA_INT_CLK_MULT_ENABLE;
		data |= ESA_INT_CLK_SRC_NOT_PCI;
	}
	data &= ~(ESA_CLK_MULT_MODE_SELECT | ESA_CLK_MULT_MODE_SELECT_2);
	pci_conf_write(pc, tag, ESA_PCI_ALLEGRO_CONFIG, data);

	if (sc->type == ESS_ALLEGRO1) {
		data = pci_conf_read(pc, tag, ESA_PCI_USER_CONFIG);
		data |= ESA_IN_CLK_12MHZ_SELECT;
		pci_conf_write(pc, tag, ESA_PCI_USER_CONFIG, data);
	}

	data = bus_space_read_1(iot, ioh, ESA_ASSP_CONTROL_A);
	data &= ~(ESA_DSP_CLK_36MHZ_SELECT | ESA_ASSP_CLK_49MHZ_SELECT);
	data |= ESA_ASSP_CLK_49MHZ_SELECT;	/* XXX: Assumes 49MHz DSP */
	data |= ESA_ASSP_0_WS_ENABLE;
	bus_space_write_1(iot, ioh, ESA_ASSP_CONTROL_A, data);

	bus_space_write_1(iot, ioh, ESA_ASSP_CONTROL_B, ESA_RUN_ASSP);

	return;
}

u_int8_t
esa_assp_halt(struct esa_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int8_t data, reset_state;

	data = bus_space_read_1(iot, ioh, ESA_DSP_PORT_CONTROL_REG_B);
	reset_state = data & ~ESA_REGB_STOP_CLOCK;
	delay(10000);		/* XXX use tsleep */
	bus_space_write_1(iot, ioh, ESA_DSP_PORT_CONTROL_REG_B,
			reset_state & ~ESA_REGB_ENABLE_RESET);
	delay(10000);		/* XXX use tsleep */

	return (reset_state);
}

void
esa_codec_reset(struct esa_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int16_t data, dir;
	int retry = 0;

	do {
		data = bus_space_read_2(iot, ioh, ESA_GPIO_DIRECTION);
		dir = data | 0x10; /* assuming pci bus master? */

		/* remote codec config */
		data = bus_space_read_2(iot, ioh, ESA_RING_BUS_CTRL_B);
		bus_space_write_2(iot, ioh, ESA_RING_BUS_CTRL_B,
		    data & ~ESA_SECOND_CODEC_ID_MASK);
		data = bus_space_read_2(iot, ioh, ESA_SDO_OUT_DEST_CTRL);
		bus_space_write_2(iot, ioh, ESA_SDO_OUT_DEST_CTRL,
		    data & ~ESA_COMMAND_ADDR_OUT);
		data = bus_space_read_2(iot, ioh, ESA_SDO_IN_DEST_CTRL);
		bus_space_write_2(iot, ioh, ESA_SDO_IN_DEST_CTRL,
		    data & ~ESA_STATUS_ADDR_IN);

		bus_space_write_2(iot, ioh, ESA_RING_BUS_CTRL_A,
				  ESA_IO_SRAM_ENABLE);
		delay(20);

		bus_space_write_2(iot, ioh, ESA_GPIO_DIRECTION,
		    dir & ~ESA_GPO_PRIMARY_AC97);
		bus_space_write_2(iot, ioh, ESA_GPIO_MASK,
				  ~ESA_GPO_PRIMARY_AC97);
		bus_space_write_2(iot, ioh, ESA_GPIO_DATA, 0);
		bus_space_write_2(iot, ioh, ESA_GPIO_DIRECTION,
		    dir | ESA_GPO_PRIMARY_AC97);
		delay(sc->delay1 * 1000);
		bus_space_write_2(iot, ioh, ESA_GPIO_DATA,
				  ESA_GPO_PRIMARY_AC97);
		delay(5);
		bus_space_write_2(iot, ioh, ESA_RING_BUS_CTRL_A,
		    ESA_IO_SRAM_ENABLE | ESA_SERIAL_AC_LINK_ENABLE);
		bus_space_write_2(iot, ioh, ESA_GPIO_MASK, ~0);
		delay(sc->delay2 * 1000);

		esa_read_codec(sc, 0x7c, &data);
		if ((data == 0) || (data == 0xffff)) {
			retry++;
			if (retry > 3) {
				printf("%s: esa_codec_reset: failed\n",
				    sc->sc_dev.dv_xname);
				break;
			}
			printf("%s: esa_codec_reset: retrying\n",
			    sc->sc_dev.dv_xname);
		} else
			retry = 0;
	} while (retry);

	return;
}

int
esa_amp_enable(struct esa_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int32_t gpo, polarity_port, polarity;
	u_int16_t data;

	switch (sc->type) {
	case ESS_ALLEGRO1:
		polarity_port = 0x1800;
		break;
	case ESS_MAESTRO3:
		polarity_port = 0x1100;
		break;
	default:
		printf("%s: esa_amp_enable: Unknown chip type!!!\n",
		    sc->sc_dev.dv_xname);
		return (1);
	}

	gpo = (polarity_port >> 8) & 0x0f;
	polarity = polarity_port >> 12;
	polarity = !polarity;	/* Enable */
	polarity = polarity << gpo;
	gpo = 1 << gpo;
	bus_space_write_2(iot, ioh, ESA_GPIO_MASK, ~gpo);
	data = bus_space_read_2(iot, ioh, ESA_GPIO_DIRECTION);
	bus_space_write_2(iot, ioh, ESA_GPIO_DIRECTION, data | gpo);
	data = ESA_GPO_SECONDARY_AC97 | ESA_GPO_PRIMARY_AC97 | polarity;
	bus_space_write_2(iot, ioh, ESA_GPIO_DATA, data);
	bus_space_write_2(iot, ioh, ESA_GPIO_MASK, ~0);

	return (0);
}

void
esa_enable_interrupts(struct esa_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int8_t data;

	bus_space_write_2(iot, ioh, ESA_HOST_INT_CTRL,
	    ESA_ASSP_INT_ENABLE | ESA_HV_INT_ENABLE);
	data = bus_space_read_1(iot, ioh, ESA_ASSP_CONTROL_C);
	bus_space_write_1(iot, ioh, ESA_ASSP_CONTROL_C,
	    data | ESA_ASSP_HOST_INT_ENABLE);
}

/*
 * List management
 */
int
esa_add_list(struct esa_voice *vc, struct esa_list *el,
	     u_int16_t val, int index)
{
	struct esa_softc *sc = (struct esa_softc *)vc->parent;

	el->indexmap[index] = el->currlen;
	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
		       el->mem_addr + el->currlen,
		       val);

	return (el->currlen++);
}

void
esa_remove_list(struct esa_voice *vc, struct esa_list *el, int index)
{
	struct esa_softc *sc = (struct esa_softc *)vc->parent;
	u_int16_t val;
	int lastindex = el->currlen - 1;
	int vindex = el->indexmap[index];
	int i;

	/* reset our virtual index */
	el->indexmap[index] = -1;

	if (vindex != lastindex) {
		val = esa_read_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
				    el->mem_addr + lastindex);
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
			       el->mem_addr + vindex,
			       val);
		for (i = 0; i < ESA_NUM_VOICES * 2; i++)
			if (el->indexmap[i] == lastindex)
				break;
		if (i >= ESA_NUM_VOICES * 2)
			printf("%s: esa_remove_list: invalid task index\n",
			       sc->sc_dev.dv_xname);
		else
			el->indexmap[i] = vindex;
	}

	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA,
		       el->mem_addr + lastindex, 0);
	el->currlen--;

	return;
}

int
esa_activate(struct device *self, int act)
{
	struct esa_softc *sc = (struct esa_softc *)self;

	switch (act) {
	case DVACT_SUSPEND:
		esa_suspend(sc);
		break;
	case DVACT_RESUME:
		esa_resume(sc);
		(sc->codec_if->vtbl->restore_ports)(sc->codec_if);
		break;
	}
	return 0;
}

int
esa_suspend(struct esa_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int i, index;

	index = 0;

	bus_space_write_2(iot, ioh, ESA_HOST_INT_CTRL, 0);
	bus_space_write_1(iot, ioh, ESA_ASSP_CONTROL_C, 0);

	esa_assp_halt(sc);

	/* Save ASSP state */
	for (i = ESA_REV_B_CODE_MEMORY_BEGIN; i <= ESA_REV_B_CODE_MEMORY_END;
	    i++)
		sc->savemem[index++] = esa_read_assp(sc,
		    ESA_MEMTYPE_INTERNAL_CODE, i);
	for (i = ESA_REV_B_DATA_MEMORY_BEGIN; i <= ESA_REV_B_DATA_MEMORY_END;
	    i++)
		sc->savemem[index++] = esa_read_assp(sc,
		    ESA_MEMTYPE_INTERNAL_DATA, i);

	return (0);
}

int
esa_resume(struct esa_softc *sc) {
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int i, index;
	u_int8_t reset_state;

	index = 0;

	esa_config(sc);

	reset_state = esa_assp_halt(sc);

	esa_codec_reset(sc);

	/* restore ASSP */
	for (i = ESA_REV_B_CODE_MEMORY_BEGIN; i <= ESA_REV_B_CODE_MEMORY_END;
	    i++)
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_CODE, i,
		    sc->savemem[index++]);
	for (i = ESA_REV_B_DATA_MEMORY_BEGIN; i <= ESA_REV_B_DATA_MEMORY_END;
	    i++)
		esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, i,
		    sc->savemem[index++]);

	esa_write_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, ESA_KDATA_DMA_ACTIVE, 0);
	bus_space_write_1(iot, ioh, ESA_DSP_PORT_CONTROL_REG_B,
	    reset_state | ESA_REGB_ENABLE_RESET);

	esa_enable_interrupts(sc);
	esa_amp_enable(sc);

	return (0);
}

u_int32_t
esa_get_pointer(struct esa_softc *sc, struct esa_channel *ch)
{
	u_int16_t hi = 0, lo = 0;
	u_int32_t addr;
	int data_offset = ch->data_offset;

	hi = esa_read_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, data_offset +
	    ESA_CDATA_HOST_SRC_CURRENTH);
	lo = esa_read_assp(sc, ESA_MEMTYPE_INTERNAL_DATA, data_offset +
	    ESA_CDATA_HOST_SRC_CURRENTL);

	addr = lo | ((u_int32_t)hi << 16);
	return (addr - ch->start);
}
@


1.31
log
@Remove unused getdev() audio driver functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.30 2016/09/14 06:12:19 ratchov Exp $	*/
a211 1
	//struct esa_softc *sc = (struct esa_softc *)vc->parent;
a615 3
	/* XXX */
	//esa_commit_settings(vc);

a744 3

	/* XXX */
	//esa_commit_settings(vc);
@


1.30
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.28 2014/07/12 18:48:51 tedu Exp $	*/
a93 6
struct audio_device esa_device = {
	"ESS Allegro",
	"",
	"esa"
};

a112 1
int		esa_getdev(void *, struct audio_device *);
a167 1
	esa_getdev,
a456 9
}

int
esa_getdev(void *hdl, struct audio_device *ret)
{

	*ret = esa_device;

	return (0);
@


1.29
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@a107 1
int		esa_query_encoding(void *, struct audio_encoding *);
a109 1
void		esa_get_default_params(void *, int, struct audio_params *);
a132 1
paddr_t		esa_mappage(void *addr, void *mem, off_t off, int prot);
a161 7
static audio_encoding_t esa_encoding[] = {
	{ 0, AudioEulinear, AUDIO_ENCODING_ULINEAR, 8, 1, 1, 0 },
	{ 1, AudioEslinear_le, AUDIO_ENCODING_SLINEAR_LE, 16, 2, 1, 0 }
};

#define ESA_NENCODINGS 8

a164 2
	NULL,			/* drain */
	esa_query_encoding,
a182 1
	esa_mappage,
d185 1
a185 2
	esa_trigger_input,
	esa_get_default_params
a215 17
esa_query_encoding(void *hdl, struct audio_encoding *ae)
{

	if (ae->index < 0 || ae->index >= ESA_NENCODINGS)
		return (EINVAL);
	*ae = esa_encoding[ae->index];

	return (0);
}

void
esa_get_default_params(void *addr, int mode, struct audio_params *params)
{
	ac97_get_default_params(params);
}

int
a1623 17
}

paddr_t
esa_mappage(void *addr, void *mem, off_t off, int prot)
{
	struct esa_voice *vc = addr;
	struct esa_softc *sc = (struct esa_softc *)vc->parent;
	struct esa_dma *p;

	if (off < 0)
		return (-1);
	for (p = vc->dma; p && KERNADDR(p) != mem; p = p->next)
		;
	if (!p)
		return (-1);
	return (bus_dmamem_mmap(sc->sc_dmat, p->segs, p->nsegs,
				off, prot, BUS_DMA_WAITOK));
@


1.28
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.27 2013/05/24 07:58:46 ratchov Exp $	*/
a63 2
#include <dev/mulaw.h>
#include <dev/auconv.h>
d167 1
a167 13
	{ 1, AudioEmulaw, AUDIO_ENCODING_ULAW, 8, 1, 1,
	    AUDIO_ENCODINGFLAG_EMULATED },
	{ 2, AudioEalaw, AUDIO_ENCODING_ALAW, 8, 1, 1,
	    AUDIO_ENCODINGFLAG_EMULATED },
	{ 3, AudioEslinear, AUDIO_ENCODING_SLINEAR, 8, 1, 1,
	    AUDIO_ENCODINGFLAG_EMULATED },
	{ 4, AudioEslinear_le, AUDIO_ENCODING_SLINEAR_LE, 16, 2, 1, 0 },
	{ 5, AudioEulinear_le, AUDIO_ENCODING_ULINEAR_LE, 16, 2, 1,
	    AUDIO_ENCODINGFLAG_EMULATED },
	{ 6, AudioEslinear_be, AUDIO_ENCODING_SLINEAR_BE, 16, 2, 1,
	    AUDIO_ENCODINGFLAG_EMULATED },
	{ 7, AudioEulinear_be, AUDIO_ENCODING_ULINEAR_BE, 16, 2, 1,
	    AUDIO_ENCODINGFLAG_EMULATED }
a280 3
		p->factor = 1;
		p->sw_code = 0;

a281 6
		case AUDIO_ENCODING_SLINEAR_BE:
			if (p->precision == 16)
				p->sw_code = swap_bytes;
			else
				p->sw_code = change_sign8;
			break;
d284 1
a284 1
				p->sw_code = change_sign8;
d286 1
d288 2
a289 26
			if (p->precision == 16) {
				if (mode == AUMODE_PLAY)
					p->sw_code =
					    swap_bytes_change_sign16_le;
				else
					p->sw_code =
					    change_sign16_swap_bytes_le;
			}
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			if (p->precision == 16)
				p->sw_code = change_sign16_le;
			break;
		case AUDIO_ENCODING_ULAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = mulaw_to_slinear16_le;
			} else
				p->sw_code = ulinear8_to_mulaw;
			break;
		case AUDIO_ENCODING_ALAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = alaw_to_slinear16_le;
			} else
				p->sw_code = ulinear8_to_alaw;
d326 1
a326 1
	if (p->precision * p->factor == 8)
d349 1
a349 1
	if (r->precision * r->factor == 8)
@


1.27
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.26 2013/05/15 08:29:24 ratchov Exp $	*/
d516 1
a516 1
		free(p, type);
d539 1
a539 1
			free(p, type);
d1128 1
a1128 1
		free(sc->savemem, M_DEVBUF);
d1173 1
a1173 1
	free(sc->savemem, M_DEVBUF);
@


1.26
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.25 2012/10/11 15:45:00 deraadt Exp $	*/
d1069 2
a1070 2
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO, esa_intr, self,
            sc->sc_dev.dv_xname);
@


1.25
log
@remove pci_set_powerstate() calls that are not needed, since the pci
framework does these more correctly
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.24 2011/12/07 10:31:31 kettenis Exp $	*/
d436 1
d460 1
a460 1

d476 1
d499 1
a499 1

d649 1
d731 1
a731 1

d788 1
a788 1

d862 1
a862 1

d882 1
d884 2
a885 1
	if (status == 0xff)
d887 1
d957 1
a957 1

@


1.24
log
@Make sure we only return 1 from the interrupt handler if the interrupt
actually was for us.  Fixes problems when the interrupt is shared.

tested by stu@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.23 2011/04/03 15:36:02 jasper Exp $	*/
a1642 2
	pci_set_powerstate(sc->sc_pct, sc->sc_tag, PCI_PMCSR_STATE_D3);

a1653 3

	pci_set_powerstate(sc->sc_pct, sc->sc_tag, PCI_PMCSR_STATE_D0);
	delay(10000);
@


1.23
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.22 2010/09/07 16:21:44 deraadt Exp $	*/
d877 1
a877 1
	int i;
d904 1
d949 1
d952 1
a952 1
	return (1);
@


1.22
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.21 2010/08/27 18:50:57 deraadt Exp $	*/
d1018 1
a1018 1
	    sizeof(esa_devices)/sizeof(esa_devices[0])));
@


1.21
log
@Since the changes in neo(4) work, it is very likely that the exact same
mechnical changes work in these drivers too.  Testing can occur after
this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.20 2010/08/27 04:09:19 deraadt Exp $	*/
a163 1
void		esa_powerhook(int, void *);
a1146 7

	sc->powerhook = powerhook_establish(esa_powerhook, sc);
	if (sc->powerhook == NULL)
		printf("%s: WARNING: unable to establish powerhook\n",
		    sc->sc_dev.dv_xname);

	return;
a1614 6
}

void
esa_powerhook(int why, void *hdl)
{
	esa_activate(hdl, why);
@


1.20
log
@kill PWR_STANDBY (apm can use PWR_SUSPEND instead).  While here, renumber
PWR_{SUSPEND,RESUME} so that they match the values of DAVCT_{SUSPEND,RESUME}
so that we can eventually (many more steps...) kill the powerhook garbage
and use the activate mechanism.
no objections
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.19 2010/07/15 03:43:11 jakemsr Exp $	*/
d105 1
d223 1
a223 1
	esa_detach, /*esa_activate*/ NULL
d1608 2
a1609 2
void
esa_powerhook(int why, void *hdl)
d1611 1
a1611 1
	struct esa_softc *sc = (struct esa_softc *)hdl;
d1613 2
a1614 2
	switch (why) {
	case PWR_SUSPEND:
d1617 1
a1617 1
	case PWR_RESUME:
d1622 7
@


1.19
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.18 2009/11/13 02:22:19 deraadt Exp $	*/
a1613 1
	case PWR_STANDBY:
@


1.18
log
@sizeof -> nitems, found by parfait; ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.17 2009/06/02 18:06:31 deraadt Exp $	*/
d168 14
a181 13
	{ 0, AudioEulinear, AUDIO_ENCODING_ULINEAR, 8, 0 },
	{ 1, AudioEmulaw, AUDIO_ENCODING_ULAW, 8,
		AUDIO_ENCODINGFLAG_EMULATED },
	{ 2, AudioEalaw, AUDIO_ENCODING_ALAW, 8, AUDIO_ENCODINGFLAG_EMULATED },
	{ 3, AudioEslinear, AUDIO_ENCODING_SLINEAR, 8,
		AUDIO_ENCODINGFLAG_EMULATED }, /* XXX: Are you sure? */
	{ 4, AudioEslinear_le, AUDIO_ENCODING_SLINEAR_LE, 16, 0 },
	{ 5, AudioEulinear_le, AUDIO_ENCODING_ULINEAR_LE, 16,
		AUDIO_ENCODINGFLAG_EMULATED },
	{ 6, AudioEslinear_be, AUDIO_ENCODING_SLINEAR_BE, 16,
		AUDIO_ENCODINGFLAG_EMULATED },
	{ 7, AudioEulinear_be, AUDIO_ENCODING_ULINEAR_BE, 16,
		AUDIO_ENCODINGFLAG_EMULATED }
d340 2
@


1.17
log
@The two "firmware" arrays only contained 16 bit values, but were being
being stored in an array of 32 bits.  waste of memory.  The bandpass
filter table only contained 16 bit values, but was being treaded as if it
was in an array of 32 bit values, thus what was being loaded into the chip
was totally wrong and this probably explains why I remember it sounded
horrid.
Not tested on real hardware; incorrect array accesses discovered by Parfait
ok oga
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.16 2008/10/25 22:30:43 jakemsr Exp $	*/
d691 1
a691 1
	for (i = 0; i < (sizeof(esa_playvals) / sizeof(esa_playvals[0])); i++)
d824 1
a824 1
	for (i = 0; i < (sizeof(esa_recvals) / sizeof(esa_recvals[0])); i++)
d1335 1
a1335 1
	size = sizeof(esa_assp_kernel_image);
d1340 1
a1340 1
	size = sizeof(esa_assp_minisrc_image);
d1346 1
a1346 1
	size = sizeof(esa_minisrc_lpf_image);
@


1.16
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.15 2008/05/29 02:10:01 jakemsr Exp $	*/
d1336 1
a1336 1
	for (i = 0; i < size / 2; i++)
d1341 1
a1341 1
	for (i = 0; i < size / 2; i++)
d1347 1
a1347 1
	for (i = 0; i < size / 2; i++)
@


1.15
log
@use ac97 default parameters for these ac97 based drivers.

this makes the emulation expansion factor 1 by default since there's no
emulation.  previously the factor was 2 because these drivers emulate
8-bit ulaw playback with 16-bit linear encodings.  having a factor
other than 1 by default creates block size and hiwat/lowat issues
with applications that set the block size and hiwat before other
parameters.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.14 2008/04/21 00:32:43 jakemsr Exp $	*/
d285 8
a292 5
		if (p->sample_rate < ESA_MINRATE ||
		    p->sample_rate > ESA_MAXRATE ||
		    (p->precision != 8 && p->precision != 16) ||
		    (p->channels < 1 || p->channels > 2))
			return (EINVAL);
@


1.14
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.13 2007/10/22 03:16:35 fgsch Exp $	*/
d112 1
d212 1
a212 1
	NULL
d251 6
@


1.13
log
@Use pci_set_powerstate(), shrinking the code and unifying the different
versions. ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.12 2007/09/17 00:50:46 krw Exp $	*/
d210 2
a211 1
	esa_trigger_input
@


1.12
log
@Some bzero() -> M_ZERO. ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.11 2006/01/25 23:54:21 brad Exp $	*/
a161 1
int		esa_power(struct esa_softc *, int);
d1060 1
a1060 1
	esa_power(sc, PCI_PMCSR_STATE_D0);
a1592 17
int
esa_power(struct esa_softc *sc, int state)
{
	pcitag_t tag = sc->sc_tag;
	pci_chipset_tag_t pc = sc->sc_pct;
	pcireg_t data;
	int pmcapreg;

	if (pci_get_capability(pc, tag, PCI_CAP_PWRMGMT, &pmcapreg, 0)) {
		data = pci_conf_read(pc, tag, pmcapreg + PCI_PMCSR);
		if ((data & PCI_PMCSR_STATE_MASK) != state)
			pci_conf_write(pc, tag, pmcapreg + PCI_PMCSR, state);
	}

	return (0);
}

d1634 1
a1634 1
	esa_power(sc, PCI_PMCSR_STATE_D3);
d1648 1
a1648 1
	esa_power(sc, PCI_PMCSR_STATE_D0);
@


1.11
log
@Wow, this is clearly wrong (found in esa_set_params):
        if (p->channels < 1 && p->channels > 2)
                return EINVAL;
Change the 'and' to an 'or' so the check actually does something.

From jmcneill NetBSD

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.10 2005/11/21 18:16:41 millert Exp $	*/
d1075 1
a1075 1
	sc->savemem = (u_int16_t *)malloc(len, M_DEVBUF, M_NOWAIT);
a1082 1
        bzero(sc->savemem, len);
@


1.10
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.9 2005/08/09 04:10:11 mickey Exp $	*/
d281 1
a281 1
		    (p->channels < 1 && p->channels > 2))
@


1.9
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.8 2003/10/07 14:11:04 fgsch Exp $	*/
d54 1
a54 1
#include <sys/select.h>
@


1.8
log
@use PCI_PMCSR instead of some magic value.
ok krw@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.6 2003/04/27 11:22:53 ho Exp $	*/
a1017 1
	u_int32_t data;
a1027 5

	data = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	data |= (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE
	    | PCI_COMMAND_MASTER_ENABLE);
	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, data);
@


1.7
log
@make dmesg prints closer to the rest of the drivers
@
text
@d1610 1
a1610 1
		data = pci_conf_read(pc, tag, pmcapreg + 4);
d1612 1
a1612 1
			pci_conf_write(pc, tag, pmcapreg + 4, state);
@


1.6
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.5 2002/11/19 18:40:17 jason Exp $	*/
d1019 1
a1019 7
	char devinfo[256];
	int revision, len;
	int i;

	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo, sizeof devinfo);
	revision = PCI_REVISION(pa->pa_class);
	printf(": %s (rev. 0x%02x)\n", devinfo, revision);
d1038 1
a1038 1
		printf("%s: can't map i/o space\n", sc->sc_dev.dv_xname);
d1049 1
a1049 1
		printf("%s: can't map interrupt\n", sc->sc_dev.dv_xname);
d1057 1
a1057 1
		printf("%s: can't establish interrupt", sc->sc_dev.dv_xname);
d1064 1
a1064 1
	printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname, intrstr);
@


1.5
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.4 2002/10/04 20:01:19 mickey Exp $	*/
d1023 1
a1023 1
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
@


1.5.4.1
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.5 2002/11/19 18:40:17 jason Exp $	*/
d1023 1
a1023 1
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo, sizeof devinfo);
@


1.5.4.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1019 7
a1025 1
	int i, len;
d1044 1
a1044 1
		printf(": can't map i/o space\n");
d1055 1
a1055 1
		printf(": can't map interrupt\n");
d1063 1
a1063 1
		printf(": can't establish interrupt");
d1070 1
a1070 1
	printf(": %s\n", intrstr);
d1616 1
a1616 1
		data = pci_conf_read(pc, tag, pmcapreg + PCI_PMCSR);
d1618 1
a1618 1
			pci_conf_write(pc, tag, pmcapreg + PCI_PMCSR, state);
@


1.4
log
@free resources on failures in attach, kill some spaces; from grendel@@zeitbombe.org
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.3 2002/08/08 13:51:25 aaron Exp $	*/
d995 5
d1004 2
a1005 13
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;

	switch(PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_ESSTECH:
		switch(PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_ESSTECH_ES1989:
		case PCI_PRODUCT_ESSTECH_MAESTRO3:
		case PCI_PRODUCT_ESSTECH_MAESTRO3_2:
			return (1);
		}
	}

	return (0);
@


1.3
log
@Use & to test if bits are set, not &&; art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.2 2002/04/08 06:06:10 deraadt Exp $	*/
d35 1
a35 1
 * 
d458 1
a458 1
	
d461 1
a461 1
		
d463 1
a463 1
	
d882 1
a882 1
		case 0x88:	
d977 1
a977 1
	return (error); 
d1062 1
d1073 1
d1085 2
d1097 2
d1108 1
a1108 1
	 * 
d1111 1
a1111 1
	 */ 
d1123 4
a1126 1
	if (ac97_attach(&sc->host_if) != 0)
d1128 1
d1575 1
a1575 1
	return (el->currlen++); 
d1626 1
a1626 1
		
d1653 1
a1653 1
	
d1707 1
a1707 1
	
d1743 1
a1743 1
	return (bus_dmamem_mmap(sc->sc_dmat, p->segs, p->nsegs, 
@


1.2
log
@tag repair
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1613 1
a1613 1
		if ((data && PCI_PMCSR_STATE_MASK) != state)
@


1.2.4.1
log
@Sync UBC branch to -current
@
text
@@


1.2.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: esa.c,v 1.2.4.1 2002/06/11 03:42:24 art Exp $	*/
d35 1
a35 1
 *
d458 1
a458 1

d461 1
a461 1

d463 1
a463 1

d882 1
a882 1
		case 0x88:
d977 1
a977 1
	return (error);
a1061 1
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
a1071 1
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
a1082 2
		pci_intr_disestablish(pc, sc->sc_ih);
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
a1092 2
		pci_intr_disestablish(pc, sc->sc_ih);
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
d1102 1
a1102 1
	 *
d1105 1
a1105 1
	 */
d1117 1
a1117 4
	if (ac97_attach(&sc->host_if) != 0) {
		pci_intr_disestablish(pc, sc->sc_ih);
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
		free(sc->savemem, M_DEVBUF);
a1118 1
	}
d1565 1
a1565 1
	return (el->currlen++);
d1613 1
a1613 1
		if ((data & PCI_PMCSR_STATE_MASK) != state)
d1616 1
a1616 1

d1643 1
a1643 1

d1697 1
a1697 1

d1733 1
a1733 1
	return (bus_dmamem_mmap(sc->sc_dmat, p->segs, p->nsegs,
@


1.2.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a994 5
const struct pci_matchid esa_devices[] = {
	{ PCI_VENDOR_ESSTECH, PCI_PRODUCT_ESSTECH_ES1989 },
	{ PCI_VENDOR_ESSTECH, PCI_PRODUCT_ESSTECH_MAESTRO3 },
	{ PCI_VENDOR_ESSTECH, PCI_PRODUCT_ESSTECH_MAESTRO3_2 },
};
d999 13
a1011 2
	return (pci_matchbyid((struct pci_attach_args *)aux, esa_devices,
	    sizeof(esa_devices)/sizeof(esa_devices[0])));
d1029 1
a1029 1
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo, sizeof devinfo);
@


1.1
log
@Allegro-1 and Maestro 3 driver ported from netbsd
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD */
@

