head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.12
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.16
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.14
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.10
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.8
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.6
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.4
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.2
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7;
locks; strict;
comment	@ * @;


1.14
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2010.08.31.17.13.44;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2010.08.05.20.21.36;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2009.05.13.08.35.29;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.23.12.46.51;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.23.18.18.58;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2007.04.07.05.59.49;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2007.04.06.01.04.52;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2007.04.05.02.38.28;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.31.23.42.18;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.31.03.11.38;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.22.06.32.14;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.22.02.48.42;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@/*	$OpenBSD: sili_pci.c,v 1.13 2012/10/08 21:47:50 deraadt Exp $ */

/*
 * Copyright (c) 2007 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/timeout.h>

#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/ata/atascsi.h>

#include <dev/ic/silireg.h>
#include <dev/ic/silivar.h>

int	sili_pci_match(struct device *, void *, void *);
void	sili_pci_attach(struct device *, struct device *, void *);
int	sili_pci_detach(struct device *, int);
int	sili_pci_activate(struct device *, int);

struct sili_pci_softc {
	struct sili_softc	psc_sili;

	pci_chipset_tag_t	psc_pc;
	pcitag_t		psc_tag;

	void			*psc_ih;
};

struct cfattach sili_pci_ca = {
	sizeof(struct sili_pci_softc),
	sili_pci_match,
	sili_pci_attach,
	sili_pci_detach,
	sili_pci_activate
};

struct sili_device {
	pci_vendor_id_t		sd_vendor;
	pci_product_id_t	sd_product;
	u_int			sd_nports;
};

const struct sili_device *sili_lookup(struct pci_attach_args *);

static const struct sili_device sili_devices[] = {
	{ PCI_VENDOR_CMDTECH,	PCI_PRODUCT_CMDTECH_3124, 4 },
	{ PCI_VENDOR_CMDTECH,	PCI_PRODUCT_CMDTECH_3131, 1 },
	{ PCI_VENDOR_CMDTECH,	PCI_PRODUCT_CMDTECH_3132, 2 },
	{ PCI_VENDOR_CMDTECH,	PCI_PRODUCT_CMDTECH_3531, 1 },
	{ PCI_VENDOR_CMDTECH,	PCI_PRODUCT_CMDTECH_AAR_1220SA, 2 },
	{ PCI_VENDOR_CMDTECH,	PCI_PRODUCT_CMDTECH_AAR_1225SA, 2 },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_3124, 4 }
};

const struct sili_device *
sili_lookup(struct pci_attach_args *pa)
{
	int				i;
	const struct sili_device	*sd;

	for (i = 0; i < nitems(sili_devices); i++) {
		sd = &sili_devices[i];
		if (sd->sd_vendor == PCI_VENDOR(pa->pa_id) &&
		    sd->sd_product == PCI_PRODUCT(pa->pa_id))
			return (sd);
	}

	return (NULL);
}

int
sili_pci_match(struct device *parent, void *match, void *aux)
{
	return (sili_lookup((struct pci_attach_args *)aux) != NULL);
}

void
sili_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct sili_pci_softc		*psc = (void *)self;
	struct sili_softc		*sc = &psc->psc_sili;
	struct pci_attach_args		*pa = aux;
	const struct sili_device	*sd;
	pcireg_t			memtype;
	pci_intr_handle_t		ih;
	const char			*intrstr;

	sd = sili_lookup(pa);

	psc->psc_pc = pa->pa_pc;
	psc->psc_tag = pa->pa_tag;
	psc->psc_ih = NULL;
	sc->sc_dmat = pa->pa_dmat;
	sc->sc_ios_global = 0;
	sc->sc_ios_port = 0;
	sc->sc_nports = sd->sd_nports;

	memtype = pci_mapreg_type(psc->psc_pc, psc->psc_tag,
	    SILI_PCI_BAR_GLOBAL);
	if (pci_mapreg_map(pa, SILI_PCI_BAR_GLOBAL, memtype, 0,
	    &sc->sc_iot_global, &sc->sc_ioh_global,
	    NULL, &sc->sc_ios_global, 0) != 0) {
		printf(": unable to map global registers\n");
		return;
	}

	memtype = pci_mapreg_type(psc->psc_pc, psc->psc_tag,
	    SILI_PCI_BAR_PORT);
	if (pci_mapreg_map(pa, SILI_PCI_BAR_PORT, memtype, 0,
	    &sc->sc_iot_port, &sc->sc_ioh_port,
	    NULL, &sc->sc_ios_port, 0) != 0) {
		printf(": unable to map port registers\n");
		goto unmap_global;
	}

	/* hook up the interrupt */
	if (pci_intr_map(pa, &ih)) {
		printf(": unable to map interrupt\n");
		goto unmap_port;
	}
	intrstr = pci_intr_string(psc->psc_pc, ih);
	psc->psc_ih = pci_intr_establish(psc->psc_pc, ih, IPL_BIO,
	    sili_intr, sc, sc->sc_dev.dv_xname);
	if (psc->psc_ih == NULL) {
		printf(": unable to map interrupt%s%s\n",
		    intrstr == NULL ? "" : " at ",
		    intrstr == NULL ? "" : intrstr);
		goto unmap_port;
	}
	printf(": %s", intrstr);

	if (sili_attach(sc) != 0) {
		/* error printed by sili_attach */
		goto deintr;
	}

	return;

deintr:
	pci_intr_disestablish(psc->psc_pc, psc->psc_ih);
	psc->psc_ih = NULL;
unmap_port:
	bus_space_unmap(sc->sc_iot_port, sc->sc_ioh_port, sc->sc_ios_port);
	sc->sc_ios_port = 0;
unmap_global:
	bus_space_unmap(sc->sc_iot_global, sc->sc_ioh_global,
	    sc->sc_ios_global);
	sc->sc_ios_global = 0;
}

int
sili_pci_detach(struct device *self, int flags)
{
	struct sili_pci_softc		*psc = (struct sili_pci_softc *)self;
	struct sili_softc		*sc = &psc->psc_sili;
	int				rv;

	rv = sili_detach(sc, flags);
	if (rv != 0)
		return (rv);

	if (psc->psc_ih != NULL) {
		pci_intr_disestablish(psc->psc_pc, psc->psc_ih);
		psc->psc_ih = NULL;
	}
	if (sc->sc_ios_port != 0) {
		bus_space_unmap(sc->sc_iot_port, sc->sc_ioh_port,
		    sc->sc_ios_port);
		sc->sc_ios_port = 0;
	}
	if (sc->sc_ios_global != 0) {
		bus_space_unmap(sc->sc_iot_global, sc->sc_ioh_global,
		    sc->sc_ios_global);
		sc->sc_ios_global = 0;
	}

	return (0);
}

int
sili_pci_activate(struct device *self, int act)
{
	struct sili_softc		*sc = (struct sili_softc *)self;
	int				 rv = 0;

	switch (act) {
	case DVACT_RESUME:
		sili_resume(sc);
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}
@


1.13
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: sili_pci.c,v 1.12 2010/08/31 17:13:44 deraadt Exp $ */
d209 2
a210 4
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
	case DVACT_SUSPEND:
d213 1
a213 5
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		break;
	case DVACT_RESUME:
		sili_resume(sc);
@


1.12
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili_pci.c,v 1.11 2010/08/05 20:21:36 kettenis Exp $ */
d213 3
@


1.11
log
@Suspend/resume support for sili(4).  Not perfect yet, but prevents us from
getting stuck.  Based on an initial diff from deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili_pci.c,v 1.10 2009/05/13 08:35:29 jsg Exp $ */
d209 3
a219 1

@


1.10
log
@Match on Adaptec AAR-1225SA, which should work according
to FreeBSD/Linux drivers.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sili_pci.c,v 1.9 2008/11/23 12:46:51 dlg Exp $ */
d40 1
d55 2
a56 1
	sili_pci_detach
d200 19
@


1.9
log
@sizeofa -> nitems
@
text
@d1 1
a1 1
/*	$OpenBSD: sili_pci.c,v 1.8 2007/11/23 18:18:58 dlg Exp $ */
d71 1
@


1.8
log
@feng shui
@
text
@d1 1
a1 1
/*	$OpenBSD: sili_pci.c,v 1.7 2007/04/07 05:59:49 dlg Exp $ */
d80 1
a80 1
	for (i = 0; i < sizeofa(sili_devices); i++) {
@


1.7
log
@sizeofa will give us the number of elements in an array. use it when
iterating over the pci device ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili_pci.c,v 1.6 2007/04/06 01:04:52 jsg Exp $ */
d51 3
a53 1
	sizeof(struct sili_pci_softc), sili_pci_match, sili_pci_attach,
@


1.6
log
@Match even more ids: 3131/3531 and some rebadged Intel/Adaptec
parts that show up in Linux driver.
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sili_pci.c,v 1.5 2007/04/05 02:38:28 dlg Exp $ */
d78 1
a78 1
	for (i = 0; i < (sizeof(sili_devices) / sizeof(sili_devices[0])); i++) {
@


1.5
log
@start defining the scatter/gather bits and the port request blocks (PRBs).
@
text
@d1 1
a1 1
/*	$OpenBSD: sili_pci.c,v 1.4 2007/03/31 23:42:18 jsg Exp $ */
d65 5
a69 1
	{ PCI_VENDOR_CMDTECH,	PCI_PRODUCT_CMDTECH_3132, 2 }
@


1.4
log
@Match on the 3132 as well.
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sili_pci.c,v 1.3 2007/03/31 03:11:38 dlg Exp $ */
d24 1
d31 2
@


1.3
log
@the attach glue now specifies how many ports the chip has.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili_pci.c,v 1.2 2007/03/22 06:32:14 dlg Exp $ */
d61 2
a62 1
	{ PCI_VENDOR_CMDTECH,	PCI_PRODUCT_CMDTECH_3124, 4 }
@


1.2
log
@map the global and port register spaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili_pci.c,v 1.1 2007/03/22 02:48:42 dlg Exp $ */
d52 4
a55 2
static const struct pci_matchid sili_devices[] = {
	{ PCI_VENDOR_CMDTECH,	PCI_PRODUCT_CMDTECH_3124 }
d58 22
d83 1
a83 2
	return (pci_matchbyid((struct pci_attach_args *)aux, sili_devices,
	    sizeof(sili_devices) / sizeof(sili_devices[0])));
d92 1
d97 2
d105 1
@


1.1
log
@import sili(4) so it can be worked on in the tree. this will support the
silicon image 3124/3132/3531 sata chipsets eventually.

so far this is the autoconf glue, an actual match routine for the 3124, and
interrupt establishment code. it is split up between pci and ic cos there
are cardbus variants of these controllers that we can support in the
future.

thanks to jolan@@ for the name, it was better liked than my initial
suggestion of siisl(4).
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d69 1
a69 1
//	pcireg_t			memtype;
d77 2
a78 1
	sc->sc_ios = 0;
d80 6
a85 9
#if 0
	/* find the appropriate memory base */
	for (r = PCI_MAPREG_START; r < PCI_MAPREG_END; r += sizeof(memtype)) {
		memtype = pci_mapreg_type(psc->psc_pc, psc->psc_tag, r);
		if ((memtype & PCI_MAPREG_TYPE_MASK) == PCI_MAPREG_TYPE_MEM)
			break;
	}
	if (r >= PCI_MAPREG_END) {
		printf(": unable to locate system interface registers\n");
d89 7
a95 4
	if (pci_mapreg_map(pa, r, memtype, 0, &sc->sc_iot, &sc->sc_ioh,
	    NULL, &sc->sc_ios, 0) != 0) {
		printf(": unable to map system interface registers\n");
		return;
a96 1
#endif
d101 1
a101 1
		goto unmap;
d110 1
a110 1
		goto unmap;
d124 7
a130 3
unmap:
//	bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
	sc->sc_ios = 0;
d148 9
a156 3
	if (sc->sc_ios != 0) {
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
		sc->sc_ios = 0;
@

