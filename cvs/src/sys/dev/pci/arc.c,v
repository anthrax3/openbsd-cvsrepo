head	1.107;
access;
symbols
	OPENBSD_6_1:1.107.0.4
	OPENBSD_6_1_BASE:1.107
	OPENBSD_6_0:1.107.0.6
	OPENBSD_6_0_BASE:1.107
	OPENBSD_5_9:1.107.0.2
	OPENBSD_5_9_BASE:1.107
	OPENBSD_5_8:1.106.0.6
	OPENBSD_5_8_BASE:1.106
	OPENBSD_5_7:1.106.0.4
	OPENBSD_5_7_BASE:1.106
	OPENBSD_5_6:1.103.0.4
	OPENBSD_5_6_BASE:1.103
	OPENBSD_5_5:1.101.0.4
	OPENBSD_5_5_BASE:1.101
	OPENBSD_5_4:1.96.0.2
	OPENBSD_5_4_BASE:1.96
	OPENBSD_5_3:1.95.0.8
	OPENBSD_5_3_BASE:1.95
	OPENBSD_5_2:1.95.0.6
	OPENBSD_5_2_BASE:1.95
	OPENBSD_5_1_BASE:1.95
	OPENBSD_5_1:1.95.0.4
	OPENBSD_5_0:1.95.0.2
	OPENBSD_5_0_BASE:1.95
	OPENBSD_4_9:1.92.0.2
	OPENBSD_4_9_BASE:1.92
	OPENBSD_4_8:1.91.0.2
	OPENBSD_4_8_BASE:1.91
	OPENBSD_4_7:1.80.0.2
	OPENBSD_4_7_BASE:1.80
	OPENBSD_4_6:1.78.0.6
	OPENBSD_4_6_BASE:1.78
	OPENBSD_4_5:1.78.0.2
	OPENBSD_4_5_BASE:1.78
	OPENBSD_4_4:1.77.0.2
	OPENBSD_4_4_BASE:1.77
	OPENBSD_4_3:1.75.0.2
	OPENBSD_4_3_BASE:1.75
	OPENBSD_4_2:1.65.0.2
	OPENBSD_4_2_BASE:1.65
	OPENBSD_4_1:1.58.0.2
	OPENBSD_4_1_BASE:1.58
	OPENBSD_4_0:1.48.0.2
	OPENBSD_4_0_BASE:1.48;
locks; strict;
comment	@ * @;


1.107
date	2015.09.10.18.10.33;	author deraadt;	state Exp;
branches;
next	1.106;
commitid	pbNNrPaFfPV40pxN;

1.106
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.105;
commitid	MyKPm9Q3dQu92BiX;

1.105
date	2015.01.12.00.07.55;	author dlg;	state Exp;
branches;
next	1.104;
commitid	fB0yoMAjpiRpqzsx;

1.104
date	2014.09.09.20.27.48;	author dlg;	state Exp;
branches;
next	1.103;
commitid	5kydSIG17Qj3n3iY;

1.103
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.102;
commitid	JtO5uXxVcnZfhUkR;

1.102
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.101;
commitid	OBNa5kfxQ2UXoiIw;

1.101
date	2014.02.08.16.02.42;	author chris;	state Exp;
branches;
next	1.100;

1.100
date	2014.02.08.15.58.01;	author chris;	state Exp;
branches;
next	1.99;

1.99
date	2014.01.24.02.47.12;	author dlg;	state Exp;
branches;
next	1.98;

1.98
date	2014.01.23.23.47.37;	author chris;	state Exp;
branches;
next	1.97;

1.97
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.94;

1.94
date	2011.07.08.22.09.27;	author matthew;	state Exp;
branches;
next	1.93;

1.93
date	2011.04.20.07.13.51;	author claudio;	state Exp;
branches;
next	1.92;

1.92
date	2010.09.07.16.21.44;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2010.08.07.03.50.02;	author krw;	state Exp;
branches;
next	1.90;

1.90
date	2010.07.18.12.49.10;	author mk;	state Exp;
branches;
next	1.89;

1.89
date	2010.07.02.20.54.36;	author mk;	state Exp;
branches;
next	1.88;

1.88
date	2010.07.02.20.52.14;	author mk;	state Exp;
branches;
next	1.87;

1.87
date	2010.07.01.03.20.38;	author matthew;	state Exp;
branches;
next	1.86;

1.86
date	2010.06.28.18.40.51;	author mk;	state Exp;
branches;
next	1.85;

1.85
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.84;

1.84
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.83;

1.83
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.82;

1.82
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.81;

1.81
date	2010.03.23.01.57.20;	author krw;	state Exp;
branches;
next	1.80;

1.80
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.79;

1.79
date	2009.08.13.11.10.27;	author dlg;	state Exp;
branches;
next	1.78;

1.78
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.77;

1.77
date	2008.07.17.13.16.29;	author jsg;	state Exp;
branches;
next	1.76;

1.76
date	2008.06.27.12.04.29;	author jsg;	state Exp;
branches;
next	1.75;

1.75
date	2007.11.05.01.18.21;	author dlg;	state Exp;
branches;
next	1.74;

1.74
date	2007.11.04.11.07.36;	author dlg;	state Exp;
branches;
next	1.73;

1.73
date	2007.11.04.10.13.05;	author dlg;	state Exp;
branches;
next	1.72;

1.72
date	2007.11.04.08.16.17;	author dlg;	state Exp;
branches;
next	1.71;

1.71
date	2007.10.30.13.22.57;	author dlg;	state Exp;
branches;
next	1.70;

1.70
date	2007.10.30.12.43.47;	author dlg;	state Exp;
branches;
next	1.69;

1.69
date	2007.10.30.12.32.46;	author dlg;	state Exp;
branches;
next	1.68;

1.68
date	2007.10.27.03.28.27;	author dlg;	state Exp;
branches;
next	1.67;

1.67
date	2007.10.22.09.58.05;	author dlg;	state Exp;
branches;
next	1.66;

1.66
date	2007.10.01.15.34.48;	author krw;	state Exp;
branches;
next	1.65;

1.65
date	2007.07.11.19.01.30;	author otto;	state Exp;
branches;
next	1.64;

1.64
date	2007.06.24.05.34.35;	author dlg;	state Exp;
branches;
next	1.63;

1.63
date	2007.05.29.22.17.50;	author todd;	state Exp;
branches;
next	1.62;

1.62
date	2007.05.20.04.39.35;	author ray;	state Exp;
branches;
next	1.61;

1.61
date	2007.03.27.11.25.17;	author jmc;	state Exp;
branches;
next	1.60;

1.60
date	2007.03.27.11.22.59;	author jmc;	state Exp;
branches;
next	1.59;

1.59
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2007.02.20.17.06.23;	author thib;	state Exp;
branches;
next	1.57;

1.57
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2006.12.22.22.55.36;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.54;

1.54
date	2006.11.04.23.11.31;	author dlg;	state Exp;
branches;
next	1.53;

1.53
date	2006.11.01.12.21.51;	author dlg;	state Exp;
branches;
next	1.52;

1.52
date	2006.11.01.12.12.32;	author dlg;	state Exp;
branches;
next	1.51;

1.51
date	2006.10.31.15.23.21;	author jolan;	state Exp;
branches;
next	1.50;

1.50
date	2006.09.25.22.49.28;	author dlg;	state Exp;
branches;
next	1.49;

1.49
date	2006.09.25.22.44.56;	author dlg;	state Exp;
branches;
next	1.48;

1.48
date	2006.08.28.05.36.00;	author dlg;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2006.08.28.00.53.34;	author dlg;	state Exp;
branches;
next	1.46;

1.46
date	2006.08.27.11.29.45;	author dlg;	state Exp;
branches;
next	1.45;

1.45
date	2006.08.27.09.56.20;	author dlg;	state Exp;
branches;
next	1.44;

1.44
date	2006.08.27.09.29.26;	author dlg;	state Exp;
branches;
next	1.43;

1.43
date	2006.08.27.09.14.19;	author dlg;	state Exp;
branches;
next	1.42;

1.42
date	2006.08.25.02.48.16;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2006.08.24.13.59.36;	author dlg;	state Exp;
branches;
next	1.40;

1.40
date	2006.08.24.13.43.47;	author dlg;	state Exp;
branches;
next	1.39;

1.39
date	2006.08.24.09.59.57;	author dlg;	state Exp;
branches;
next	1.38;

1.38
date	2006.08.24.09.43.48;	author dlg;	state Exp;
branches;
next	1.37;

1.37
date	2006.08.24.09.39.29;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2006.08.24.09.34.36;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2006.08.24.09.18.40;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2006.08.20.13.56.09;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2006.08.20.13.14.34;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2006.08.20.02.21.26;	author dlg;	state Exp;
branches;
next	1.31;

1.31
date	2006.08.20.02.20.04;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2006.08.20.02.13.49;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2006.08.20.02.06.54;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2006.08.18.13.57.11;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2006.08.18.13.55.52;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2006.08.18.10.40.04;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2006.08.18.10.27.06;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2006.08.18.04.07.11;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2006.08.18.01.20.14;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2006.08.17.12.31.16;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2006.08.17.12.16.35;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2006.08.15.04.26.58;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2006.08.15.02.09.02;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2006.08.14.15.22.27;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2006.08.14.14.43.36;	author dlg;	state Exp;
branches;
next	1.16;

1.16
date	2006.08.09.09.21.13;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.07.21.44.10;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.07.21.35.22;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.06.13.17.23;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2006.08.06.07.58.00;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2006.08.06.07.29.18;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.06.00.38.33;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2006.08.06.00.18.34;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.05.00.55.35;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2006.08.03.08.29.26;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2006.07.31.11.40.13;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2006.07.31.10.03.22;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2006.07.31.08.22.04;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2006.07.31.08.15.52;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2006.07.29.15.14.35;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2006.07.29.05.08.41;	author dlg;	state Exp;
branches;
next	;

1.48.2.1
date	2006.11.02.01.52.08;	author brad;	state Exp;
branches;
next	;


desc
@@


1.107
log
@sizes for free(); ok sthen
@
text
@/*	$OpenBSD: arc.c,v 1.106 2015/01/27 03:17:36 dlg Exp $ */

/*
 * Copyright (c) 2006 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Ching Huang   Support ARC1880,1882,1213,1223,1214
 */
#include "bio.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mutex.h>
#include <sys/device.h>
#include <sys/rwlock.h>
#include <sys/task.h>

#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <sys/sensors.h>
#if NBIO > 0
#include <sys/ioctl.h>
#include <dev/biovar.h>
#endif

#ifdef ARC_DEBUG
#define ARC_D_INIT	(1<<0)
#define ARC_D_RW	(1<<1)
#define ARC_D_DB	(1<<2)

int arcdebug = 0;

#define DPRINTF(p...)		do { if (arcdebug) printf(p); } while (0)
#define DNPRINTF(n, p...)	do { if ((n) & arcdebug) printf(p); } while (0)

#else
#define DPRINTF(p...)		/* p */
#define DNPRINTF(n, p...)	/* n, p */
#endif

#define ARC_HBA_TYPE_A    0x00000001
#define ARC_HBA_TYPE_B    0x00000002
#define ARC_HBA_TYPE_C    0x00000003
#define ARC_HBA_TYPE_D    0x00000004

#define ARC_RA_PCI_BAR			PCI_MAPREG_START
#define ARC_RB_DOORBELL_BAR		PCI_MAPREG_START
#define ARC_RB_RWBUFFER_BAR		PCI_MAPREG_PPB_END
#define ARC_RC_PCI_BAR			PCI_MAPREG_PCB_END
#define ARC_RD_PCI_BAR			PCI_MAPREG_START

#define ARCMSR_MAX_CCB_COUNT		264
#define ARCMSR_MAX_HBB_POSTQUEUE	264
#define ARCMSR_MAX_HBD_POSTQUEUE	256

/* Areca boards using the Intel IOP are Type A (RA) */

#define ARC_RA_INB_MSG0				0x0010
#define  ARC_RA_INB_MSG0_NOP			(0x00000000)
#define  ARC_RA_INB_MSG0_GET_CONFIG		(0x00000001)
#define  ARC_RA_INB_MSG0_SET_CONFIG		(0x00000002)
#define  ARC_RA_INB_MSG0_ABORT_CMD		(0x00000003)
#define  ARC_RA_INB_MSG0_STOP_BGRB		(0x00000004)
#define  ARC_RA_INB_MSG0_FLUSH_CACHE		(0x00000005)
#define  ARC_RA_INB_MSG0_START_BGRB		(0x00000006)
#define  ARC_RA_INB_MSG0_CHK331PENDING		(0x00000007)
#define  ARC_RA_INB_MSG0_SYNC_TIMER		(0x00000008)
#define ARC_RA_INB_MSG1				0x0014
#define ARC_RA_OUTB_ADDR0			0x0018
#define ARC_RA_OUTB_ADDR1			0x001c
#define  ARC_RA_OUTB_ADDR1_FIRMWARE_OK		(1<<31)
#define ARC_RA_INB_DOORBELL			0x0020
#define  ARC_RA_INB_DOORBELL_WRITE_OK		(1<<0)
#define  ARC_RA_INB_DOORBELL_READ_OK		(1<<1)
#define ARC_RA_OUTB_DOORBELL			0x002c
#define  ARC_RA_OUTB_DOORBELL_WRITE_OK		(1<<0)
#define  ARC_RA_OUTB_DOORBELL_READ_OK		(1<<1)
#define ARC_RA_INTRSTAT				0x0030
#define  ARC_RA_INTRSTAT_MSG0			(1<<0)
#define  ARC_RA_INTRSTAT_MSG1			(1<<1)
#define  ARC_RA_INTRSTAT_DOORBELL		(1<<2)
#define  ARC_RA_INTRSTAT_POSTQUEUE		(1<<3)
#define  ARC_RA_INTRSTAT_PCI			(1<<4)
#define  ARC_RA_INTR_STAT_ALL			0x1F
#define ARC_RA_INTRMASK				0x0034
#define  ARC_RA_INTRMASK_MSG0			(1<<0)
#define  ARC_RA_INTRMASK_MSG1			(1<<1)
#define  ARC_RA_INTRMASK_DOORBELL		(1<<2)
#define  ARC_RA_INTRMASK_POSTQUEUE		(1<<3)
#define  ARC_RA_INTRMASK_PCI			(1<<4)
#define  ARC_RA_INTR_MASK_ALL			0x1F
#define ARC_RA_POST_QUEUE			0x0040
#define  ARC_RA_POST_QUEUE_ADDR_SHIFT		5
#define  ARC_RA_POST_QUEUE_IAMBIOS		(1<<30)
#define  ARC_RA_POST_QUEUE_BIGFRAME		(1<<31)
#define ARC_RA_REPLY_QUEUE			0x0044
#define  ARC_RA_REPLY_QUEUE_ADDR_SHIFT		5
#define  ARC_RA_REPLY_QUEUE_ERR			(1<<28)
#define  ARC_RA_REPLY_QUEUE_IAMBIOS		(1<<30)
#define ARC_RA_MSGBUF				0x0a00
#define  ARC_RA_MSGBUF_LEN			1024
#define ARC_RA_IOC_WBUF_LEN			0x0e00
#define ARC_RA_IOC_WBUF				0x0e04
#define ARC_RA_IOC_RBUF_LEN			0x0f00
#define ARC_RA_IOC_RBUF				0x0f04
#define  ARC_RA_IOC_RWBUF_MAXLEN		124 /* for both RBUF and WBUF */

/* Areca boards using the Marvel IOP0 are Type B (RB) */

#define ARC_RB_DRV2IOP_DOORBELL		0x00020400
#define ARC_RB_DRV2IOP_DOORBELL_MASK	0x00020404
#define ARC_RB_IOP2DRV_DOORBELL		0x00020408
#define ARC_RB_IOP2DRV_DOORBELL_FIRMWARE_OK	(1<<31)
#define ARC_RB_IOP2DRV_DOORBELL_MASK	0x0002040c

/* Areca boards using the LSI IOP are Type C (RC) */

#define ARC_RC_INB_DOORBELL	   	0x20
#define ARC_RC_INTR_STAT		0x30
#define	ARC_RC_INTR_MASK		0x34
#define	ARC_RC_OUTB_DOORBELL		0x9C
#define	ARC_RC_OUTB_DOORBELL_CLR	0xA0
#define	ARC_RC_D2I_MSG_CMD_DONE		0x08
#define	ARC_RC_I2D_MSG_CMD_DONE		0x08
#define	ARC_RC_I2D_MSG_CMD_DONE_CLR	0x08
#define ARC_RC_INB_MSGADDR0		0xB0
#define ARC_RC_INB_MSGADDR1		0xB4
#define ARC_RC_OUTB_MSGADDR0		0xB8
#define ARC_RC_OUTB_MSGADDR1		0xBC
#define ARC_RC_OUTB_MSG_FIRMWARE_OK	0x80000000
#define ARC_RC_INB_POSTQ_LOW		0xC0
#define ARC_RC_INB_POSTQ_HIGH		0xC4
#define	ARC_RC_OUTB_REPLYQ_LOW		0xC8
#define	ARC_RC_OUTB_REPLYQ_HIGH		0xCC
#define	ARC_RC_MSG_WBUF_LEN		0x2000
#define	ARC_RC_MSG_WBUF			0x2004
#define	ARC_RC_MSG_RBUF_LEN		0x2100
#define	ARC_RC_MSG_RBUF			0x2104
#define	ARC_RC_MSG_RWBUF		0x2200

#define ARC_RC_INB_MSG0_NOP		(0x00000000)
#define ARC_RC_INB_MSG0_GET_CONFIG	(0x00000001)
#define ARC_RC_INB_MSG0_SET_CONFIG	(0x00000002)
#define ARC_RC_INB_MSG0_ABORT_CMD	(0x00000003)
#define ARC_RC_INB_MSG0_STOP_BGRB	(0x00000004)
#define ARC_RC_INB_MSG0_FLUSH_CACHE	(0x00000005)
#define ARC_RC_INB_MSG0_START_BGRB	(0x00000006)
#define ARC_RC_INB_MSG0_CHK331PENDING	(0x00000007)
#define ARC_RC_INB_MSG0_SYNC_TIMER	(0x00000008)

#define ARC_RC_D2I_DATA_WRITE_OK	0x00000002
#define ARC_RC_D2I_DATA_READ_OK		0x00000004
#define ARC_RC_D2I_MESSAGE_CMD_DONE	0x00000008
#define ARC_RC_D2I_POSTQUEUE_THROTTLING	0x00000010
#define ARC_RC_I2D_DATA_WRITE_OK	0x00000002
#define ARC_RC_I2D_DATA_WRITE_OK_CLEAR	0x00000002
#define ARC_RC_I2D_DATA_READ_OK		0x00000004
#define ARC_RC_I2D_DATA_READ_OK_CLEAR	0x00000004
#define ARC_RC_I2D_MESSAGE_CMD_DONE	0x00000008
#define ARC_RC_I2D_MESSAGE_CMD_DONE_CLEAR 0x00000008
#define ARC_RC_MESSAGE_FIRMWARE_OK	0x80000000

#define ARC_RC_INTR_STAT_UTILITY_A	(1<<0)
#define ARC_RC_INTR_STAT_DOORBELL	(1<<2)
#define ARC_RC_INTR_STAT_POSTQUEUE	(1<<3)
#define ARC_RC_INTR_MASK_ALL		0x0000000D
#define ARC_RC_INTR_MASK_UTILITY_A	(1<<0)
#define ARC_RC_INTR_MASK_DOORBELL	(1<<2)
#define ARC_RC_INTR_MASK_POSTQUEUE	(1<<3)
#define ARC_RC_REPLY_QUEUE_ERR		1
#define	ARC_RC_THROTTLE			12

/* Areca boards using the Marvell IOP 9580 are Type D (RD) */

#define ARC_RD_INTR_STAT		0x200
#define ARC_RD_HOST_INT_ENABLE		0x204
#define	ARC_RD_INTR_ENABLE		0x20C
#define	ARC_RD_D2I_MSG_CMD_DONE		0x08
#define	ARC_RD_I2D_MSG_CMD_DONE		0x2000000
#define	ARC_RD_I2D_MSG_CMD_DONE_CLR	0x2000000
#define ARC_RD_INB_MSGADDR0		0x400
#define ARC_RD_INB_MSGADDR1		0x404
#define ARC_RD_OUTB_MSGADDR0		0x420
#define ARC_RD_OUTB_MSGADDR1		0x424
#define ARC_RD_INB_DOORBELL		0x460
#define	ARC_RD_OUTB_DOORBELL		0x480
#define	ARC_RD_OUTB_DOORBELL_CLR	0x480
#define	ARC_RD_OUTB_DOORBELL_ENABLE	0x484
#define ARC_RD_OUTB_MSG_FIRMWARE_OK	0x80000000
#define ARC_RD_INB_POSTQ_LOW		0x1000
#define ARC_RD_INB_POSTQ_HIGH		0x1004
#define	ARC_RD_OUTB_REPLYQ_LOW		0x1060
#define	ARC_RD_OUTB_REPLYQ_HIGH		0x1064

#define ARC_RD_INB_WRITE_PTR		0x1018
#define ARC_RD_INB_READ_PTR		0x101C
#define	ARC_RD_OUTB_COPY_PTR		0x106C
#define	ARC_RD_OUTB_READ_PTR		0x1070
#define	ARC_RD_OUTB_INTR_CAUSE		0x1088
#define	ARC_RD_OUTB_INT_ENABLE		0x108C
#define	ARC_RD_MSG_WBUF_LEN		0x2000
#define	ARC_RD_MSG_WBUF			0x2004
#define	ARC_RD_MSG_RBUF_LEN		0x2100
#define	ARC_RD_MSG_RBUF			0x2104
#define	ARC_RD_MSG_RWBUF		0x2200

#define ARC_RD_INB_MSG0_NOP		(0x00000000)
#define ARC_RD_INB_MSG0_GET_CONFIG	(0x00000001)
#define ARC_RD_INB_MSG0_SET_CONFIG	(0x00000002)
#define ARC_RD_INB_MSG0_ABORT_CMD	(0x00000003)
#define ARC_RD_INB_MSG0_STOP_BGRB	(0x00000004)
#define ARC_RD_INB_MSG0_FLUSH_CACHE	(0x00000005)
#define ARC_RD_INB_MSG0_START_BGRB	(0x00000006)
#define ARC_RD_INB_MSG0_CHK331PENDING	(0x00000007)
#define ARC_RD_INB_MSG0_SYNC_TIMER	(0x00000008)

#define ARC_RD_D2I_DATA_WRITE_OK	0x00000001
#define ARC_RD_D2I_DATA_READ_OK		0x00000002
#define ARC_RD_D2I_MESSAGE_CMD_DONE	0x02000000
#define ARC_RD_D2I_POSTQUEUE_THROTTLING	0x00000010
#define ARC_RD_I2D_DATA_WRITE_OK	0x00000001
#define ARC_RD_I2D_DATA_WRITE_CLEAR	0x00000001
#define ARC_RD_I2D_DATA_READ_OK		0x00000002
#define ARC_RD_I2D_DATA_READ_CLEAR	0x00000002
#define ARC_RD_I2D_MESSAGE_CMD_DONE	0x02000000
#define ARC_RD_I2D_MESSAGE_CMD_DONE_CLEAR 0x02000000
#define ARC_RD_MESSAGE_FIRMWARE_OK	0x80000000

#define ARC_RD_INTR_STAT_DOORBELL	0x00001000
#define ARC_RD_INTR_STAT_POSTQUEUE	0x00000010
#define ARC_RD_INTR_ENABLE_ALL		0x00001010
#define ARC_RD_INTR_DISABLE_ALL		0x00000000
#define ARC_RD_INTR_ENABLE_DOORBELL	0x00001000
#define ARC_RD_INTR_ENABLE_POSTQUEUE	0x00000010
#define ARC_RD_REPLY_QUEUE_ERR		1
#define	ARC_RD_OUTB_LIST_INT_CLR	1

struct arc_msg_firmware_info {
	u_int32_t		signature;
#define ARC_FWINFO_SIGNATURE_GET_CONFIG		(0x87974060)
#define ARC_FWINFO_SIGNATURE_SET_CONFIG		(0x87974063)
	u_int32_t		request_len;
	u_int32_t		queue_len;
	u_int32_t		sdram_size;
	u_int32_t		sata_ports;
	u_int8_t		vendor[40];
	u_int8_t		model[8];
	u_int8_t		fw_version[16];
	u_int8_t		device_map[16];
	u_int32_t		cfgVersion;
	u_int8_t		cfgSerial[16];
	u_int32_t		cfgPicStatus;
} __packed;

/* definitions of the firmware commands sent via the doorbells */

struct arc_fw_hdr {
	u_int8_t		byte1;
	u_int8_t		byte2;
	u_int8_t		byte3;
} __packed;

/* the fw header must always equal this */
struct arc_fw_hdr arc_fw_hdr = { 0x5e, 0x01, 0x61 };

struct arc_fw_bufhdr {
	struct arc_fw_hdr	hdr;
	u_int16_t		len;
} __packed;

#define ARC_FW_RAIDINFO		0x20	/* opcode + raid# */
#define ARC_FW_VOLINFO		0x21	/* opcode + vol# */
#define ARC_FW_DISKINFO		0x22	/* opcode + physdisk# */
#define ARC_FW_SYSINFO		0x23	/* opcode. reply is fw_sysinfo */
#define ARC_FW_MUTE_ALARM	0x30	/* opcode only */
#define ARC_FW_SET_ALARM	0x31	/* opcode + 1 byte for setting */
#define ARC_FW_SET_ALARM_DISABLE	0x00
#define ARC_FW_SET_ALARM_ENABLE		0x01
#define ARC_FW_NOP		0x38	/* opcode only */

#define ARC_FW_CMD_OK		0x41
#define ARC_FW_BLINK		0x43
#define ARC_FW_BLINK_ENABLE		0x00
#define ARC_FW_BLINK_DISABLE	0x01
#define ARC_FW_CMD_PASS_REQD	0x4d

struct arc_fw_comminfo {
	u_int8_t		baud_rate;
	u_int8_t		data_bits;
	u_int8_t		stop_bits;
	u_int8_t		parity;
	u_int8_t		flow_control;
} __packed;

struct arc_fw_scsiattr {
	u_int8_t		channel; /* channel for SCSI target (0/1) */
	u_int8_t		target;
	u_int8_t		lun;
	u_int8_t		tagged;
	u_int8_t		cache;
	u_int8_t		speed;
} __packed;

struct arc_fw_raidinfo {
	u_int8_t		set_name[16];
	u_int32_t		capacity;
	u_int32_t		capacity2;
	u_int32_t		fail_mask;
	u_int8_t		device_array[32];
	u_int8_t		member_devices;
	u_int8_t		new_member_devices;
	u_int8_t		raid_state;
	u_int8_t		volumes;
	u_int8_t		volume_list[16];
	u_int8_t		reserved1[3];
	u_int8_t		free_segments;
	u_int32_t		raw_stripes[8];
	u_int32_t		reserved2[3];
	u_int8_t		vol_ListX[112];
	u_int8_t		devEncArray[32];
} __packed;

struct arc_fw_volinfo {
	u_int8_t		set_name[16];
	u_int32_t		capacity;
	u_int32_t		capacity2;
	u_int32_t		fail_mask;
	u_int32_t		stripe_size; /* in blocks */
	u_int32_t		new_fail_mask;
	u_int32_t		new_stripe_size;
	u_int32_t		volume_status;
#define ARC_FW_VOL_STATUS_NORMAL	0x00
#define ARC_FW_VOL_STATUS_INITTING	(1<<0)
#define ARC_FW_VOL_STATUS_FAILED	(1<<1)
#define ARC_FW_VOL_STATUS_MIGRATING	(1<<2)
#define ARC_FW_VOL_STATUS_REBUILDING	(1<<3)
#define ARC_FW_VOL_STATUS_NEED_INIT	(1<<4)
#define ARC_FW_VOL_STATUS_NEED_MIGRATE	(1<<5)
#define ARC_FW_VOL_STATUS_INIT_FLAG	(1<<6)
#define ARC_FW_VOL_STATUS_NEED_REGEN	(1<<7)
#define ARC_FW_VOL_STATUS_CHECKING	(1<<8)
#define ARC_FW_VOL_STATUS_NEED_CHECK	(1<<9)
	u_int32_t		progress;
	struct arc_fw_scsiattr	scsi_attr;
	u_int8_t		member_disks;
	u_int8_t		raid_level;
#define ARC_FW_VOL_RAIDLEVEL_0		0x00
#define ARC_FW_VOL_RAIDLEVEL_1		0x01
#define ARC_FW_VOL_RAIDLEVEL_3		0x02
#define ARC_FW_VOL_RAIDLEVEL_5		0x03
#define ARC_FW_VOL_RAIDLEVEL_6		0x04
#define ARC_FW_VOL_RAIDLEVEL_PASSTHRU	0x05
	u_int8_t		new_member_disks;
	u_int8_t		new_raid_level;
	u_int8_t		raid_set_number;
	u_int8_t		vol_state0;
	u_int32_t		host_speed;
	u_int32_t		vol_state;
	u_int8_t		vol_array[16];
	u_int8_t		num_5060volumes;
	u_int8_t		reserved[43];
} __packed;

struct arc_fw_diskinfo {
	u_int8_t		model[40];
	u_int8_t		serial[20];
	u_int8_t		firmware_rev[8];
	u_int32_t		capacity;
	u_int32_t		capacity2;
	u_int8_t		device_state;
	u_int8_t		pio_mode;
	u_int8_t		current_udma_mode;
	u_int8_t		udma_mode;
	u_int8_t		hot_spare_type;
	u_int8_t		raid_number; /* 0xff unowned */
	struct arc_fw_scsiattr	scsi_attr;
	u_int8_t		reserved[170];
} __packed;

struct arc_fw_sysinfo {
	u_int8_t		vendor_name[40];
	u_int8_t		serial_number[16];
	u_int8_t		firmware_version[16];
	u_int8_t		boot_version[16];
	u_int8_t		mb_version[16];
	u_int8_t		model_name[8];

	u_int8_t		local_ip[4];
	u_int8_t		current_ip[4];

	u_int32_t		time_tick;
	u_int32_t		cpu_speed;
	u_int32_t		icache;
	u_int32_t		dcache;
	u_int32_t		scache;
	u_int32_t		memory_size;
	u_int32_t		memory_speed;
	u_int32_t		events;

	u_int8_t		gsiMacAddress[6];
	u_int8_t		gsiDhcp;
	u_int8_t		alarm;
	u_int8_t		channel_usage;
	u_int8_t		max_ata_mode;
	u_int8_t		sdram_ecc;
	u_int8_t		rebuild_priority;
	struct arc_fw_comminfo	comm_a;
	struct arc_fw_comminfo	comm_b;
	u_int8_t		ide_channels;
	u_int8_t		scsi_host_channels;
	u_int8_t		ide_host_channels;
	u_int8_t		max_volume_set;
	u_int8_t		max_raid_set;
	u_int8_t		ether_port;
	u_int8_t		raid6_engine;
	u_int8_t		reserved[75];
} __packed;

struct arc_iop;
struct arc_ccb;
SLIST_HEAD(arc_ccb_list, arc_ccb);

struct InBound_SRB {
	u_int32_t addressLow;	/* pointer to SRB block */
	u_int32_t addressHigh;
	u_int32_t length;	/* in DWORDs */
	u_int32_t reserved0;
};

struct OutBound_SRB {
	u_int32_t addressLow;	/* pointer to SRB block */
	u_int32_t addressHigh;
};

struct arc_HBD_Msgu {
 	struct InBound_SRB post_qbuffer[ARCMSR_MAX_HBD_POSTQUEUE];
   	struct OutBound_SRB done_qbuffer[ARCMSR_MAX_HBD_POSTQUEUE+1];
	u_int16_t postq_index;
	u_int16_t doneq_index;
};

#define		ARC_MAX_CMDQ_PTR_LEN	sizeof(struct arc_HBD_Msgu)

struct arc_msg_scsicmd {
	u_int8_t		bus;
	u_int8_t		target;
	u_int8_t		lun;
	u_int8_t		function;

	u_int8_t		cdb_len;
	u_int8_t		sgl_len;
	u_int8_t		flags;
#define ARC_MSG_SCSICMD_FLAG_SGL_BSIZE_512	(1<<0)
#define ARC_MSG_SCSICMD_FLAG_FROM_BIOS		(1<<1)
#define ARC_MSG_SCSICMD_FLAG_WRITE		(1<<2)
#define ARC_MSG_SCSICMD_FLAG_SIMPLEQ	(0x00)
#define ARC_MSG_SCSICMD_FLAG_HEADQ		(0x08)
#define ARC_MSG_SCSICMD_FLAG_ORDERQ		(0x10)
	u_int8_t		msgPages;

	u_int32_t		context;
	u_int32_t		data_len;

#define ARC_MSG_CDBLEN				16
	u_int8_t		cdb[ARC_MSG_CDBLEN];

	u_int8_t		status;
#define ARC_MSG_STATUS_SELTIMEOUT		0xf0
#define ARC_MSG_STATUS_ABORTED			0xf1
#define ARC_MSG_STATUS_INIT_FAIL		0xf2
#define ARC_MSG_SENSELEN			15
	u_int8_t		sense_data[ARC_MSG_SENSELEN];

	/* followed by an sgl */
} __packed;

struct arc_sge {
	u_int32_t		sg_length;
#define ARC_SGE_64BIT				(1<<24)
	u_int32_t		sg_lo_addr;
	u_int32_t		sg_hi_addr;
} __packed;

#define ARC_MAX_TARGET		16
#define ARC_MAX_LUN		8
#define ARC_MAX_IOCMDLEN	512
#define ARC_BLOCKSIZE		512

/* the firmware deals with up to 256 or 512 byte command frames. */
/* sizeof(struct arc_msg_scsicmd) + (sizeof(struct arc_sge) * 38) == 508 */
#define ARC_SGL_MAXLEN		38
/* sizeof(struct arc_msg_scsicmd) + (sizeof(struct arc_sge) * 17) == 252 */
#define ARC_SGL_256LEN		17

struct arc_io_cmd {
	struct arc_msg_scsicmd	cmd;
	struct arc_sge	sgl[ARC_SGL_MAXLEN];
	u_int32_t		reserved1;
	struct arc_ccb	*ccb;
	u_int32_t		reserved2[6];
} __packed;

#define ARC_IO_CMD_LEN	512+32

/* stuff to manage a scsi command */
struct arc_ccb {
	struct arc_softc	*ccb_sc;

	struct scsi_xfer	*ccb_xs;

	bus_dmamap_t		ccb_dmamap;
	bus_addr_t		cmd_dma_offset;
	struct arc_io_cmd	*ccb_cmd;
	u_int32_t		ccb_cmd_post;

	SLIST_ENTRY(arc_ccb)	ccb_link;
	u_int32_t		arc_io_cmd_length;
};

struct arc_softc {
	struct device		sc_dev;
	const struct arc_iop	*sc_iop;
	struct scsi_link	sc_link;

	pci_chipset_tag_t	sc_pc;
	pcitag_t		sc_tag;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_size_t		sc_ios;
	bus_dma_tag_t		sc_dmat;

	void			*sc_ih;

	u_int32_t		sc_req_count;

	struct arc_dmamem	*sc_requests;
	struct arc_ccb		*sc_ccbs;
	struct arc_ccb_list	sc_ccb_free;
	struct mutex		sc_ccb_mtx;

	struct scsi_iopool	sc_iopool;
	struct scsibus_softc	*sc_scsibus;

	struct rwlock		sc_lock;
	volatile int		sc_talking;

	struct ksensor		*sc_sensors;
	struct ksensordev	sc_sensordev;
	int			sc_nsensors;

	u_int32_t		sc_ledmask;
	u_int32_t		sc_adp_type;
	u_int32_t		sc_ccb_phys_hi;
	u_int32_t		postQ_buffer;
	u_int32_t		doneQ_buffer;
	bus_addr_t		cmdQ_ptr_offset;
	struct arc_HBD_Msgu *pmu;
};
#define DEVNAME(_s)		((_s)->sc_dev.dv_xname)

/* wrap up the bus_dma api */
struct arc_dmamem {
	bus_dmamap_t		adm_map;
	bus_dma_segment_t	adm_seg;
	size_t			adm_size;
	caddr_t			adm_kva;
};
#define ARC_DMA_MAP(_adm)	((_adm)->adm_map)
#define ARC_DMA_DVA(_adm)	((_adm)->adm_map->dm_segs[0].ds_addr)
#define ARC_DMA_KVA(_adm)	((void *)(_adm)->adm_kva)

int	arc_match(struct device *, void *, void *);
void	arc_attach(struct device *, struct device *, void *);
int	arc_detach(struct device *, int);
int	arc_activate(struct device *, int);
int	arc_intr(void *);
int	arc_intr_A(void *);
int	arc_intr_C(void *);
int	arc_intr_D(void *);

/* interface for scsi midlayer to talk to */
void	arc_scsi_cmd(struct scsi_xfer *);
void	arc_minphys(struct buf *, struct scsi_link *);

/* code to deal with getting bits in and out of the bus space */
u_int32_t	arc_read(struct arc_softc *, bus_size_t);
void		arc_read_region(struct arc_softc *, bus_size_t,
			    void *, size_t);
void		arc_write(struct arc_softc *, bus_size_t, u_int32_t);
void		arc_write_region(struct arc_softc *, bus_size_t,
			    void *, size_t);
int			arc_wait_eq(struct arc_softc *, bus_size_t,
			    u_int32_t, u_int32_t);
int			arc_wait_ne(struct arc_softc *, bus_size_t,
			    u_int32_t, u_int32_t);
int			arc_msg0(struct arc_softc *, u_int32_t);

struct arc_dmamem	*arc_dmamem_alloc(struct arc_softc *, size_t);
void		arc_dmamem_free(struct arc_softc *,
			    struct arc_dmamem *);
void arc_free_ccb_src(struct arc_softc *sc);

int			arc_alloc_ccbs(struct arc_softc *);
struct arc_ccb	*arc_get_ccb(struct arc_softc *);
void		arc_put_ccb(struct arc_softc *, struct arc_ccb *);
int			arc_load_xs(struct arc_ccb *);
int			arc_complete(struct arc_softc *, struct arc_ccb *,
			    int);
void		arc_scsi_cmd_done(struct arc_softc *, struct arc_ccb *,
			    u_int32_t);

int			arc_map_pci_resources(struct arc_softc *,
			    struct pci_attach_args *);
void		arc_unmap_pci_resources(struct arc_softc *);
int		arc_chipA_firmware(struct arc_softc *);
int		arc_chipB_firmware(struct arc_softc *);
int		arc_chipC_firmware(struct arc_softc *);
int		arc_chipD_firmware(struct arc_softc *);
void 		arc_enable_all_intr(struct arc_softc *);
void 		arc_disable_all_intr(struct arc_softc *);
void 		arc_stop_bgrb_proc(struct arc_softc *sc);
void 		arc_flush_cache(struct arc_softc *sc);
void		arc_iop_set_conf(struct arc_softc *sc);

#if NBIO > 0
/* stuff to do messaging via the doorbells */
void		arc_lock(struct arc_softc *);
void		arc_unlock(struct arc_softc *);
void		arc_wait(struct arc_softc *);
u_int8_t	arc_msg_cksum(void *, u_int16_t);
int			arc_msgbuf(struct arc_softc *, void *, size_t,
			    void *, size_t, int);

/* bioctl */
int			arc_bioctl(struct device *, u_long, caddr_t);
int			arc_bio_inq(struct arc_softc *, struct bioc_inq *);
int			arc_bio_vol(struct arc_softc *, struct bioc_vol *);
int			arc_bio_disk(struct arc_softc *, struct bioc_disk *);
int			arc_bio_alarm(struct arc_softc *, struct bioc_alarm *);
int			arc_bio_alarm_state(struct arc_softc *,
			    struct bioc_alarm *);
int			arc_bio_blink(struct arc_softc *, struct bioc_blink *);

int			arc_bio_getvol(struct arc_softc *, int,
			    struct arc_fw_volinfo *);

#ifndef SMALL_KERNEL
struct arc_task {
	struct task t;
	struct arc_softc *sc;
};
/* sensors */
void			arc_create_sensors(void *);
void			arc_refresh_sensors(void *);
#endif /* SMALL_KERNEL */
#endif

struct cfattach arc_ca = {
	sizeof(struct arc_softc), arc_match, arc_attach, arc_detach,
	arc_activate
};

struct cfdriver arc_cd = {
	NULL, "arc", DV_DULL
};

struct scsi_adapter arc_switch = {
	arc_scsi_cmd, arc_minphys, NULL, NULL, NULL
};

/* real stuff for dealing with the hardware */
struct arc_iop {
	int			(*iop_query_firmware)(struct arc_softc *);
};

static const struct arc_iop arc_intel = {
	arc_chipA_firmware
};

static const struct arc_iop arc_marvell = {
	arc_chipB_firmware
};

static const struct arc_iop arc_lsi = {
	arc_chipC_firmware
};

static const struct arc_iop arc_marvell2 = {
	arc_chipD_firmware
};

struct arc_board {
	pcireg_t		ab_vendor;
	pcireg_t		ab_product;
	const struct arc_iop	*ab_iop;
};
const struct arc_board	*arc_match_board(struct pci_attach_args *);

static const struct arc_board arc_devices[] = {
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1110, &arc_intel },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1120, &arc_intel },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1130, &arc_intel },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1160, &arc_intel },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1170, &arc_intel },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1200, &arc_intel },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1200_B, &arc_marvell },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1202, &arc_intel },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1210, &arc_intel },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1214, &arc_marvell2 },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1220, &arc_intel },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1230, &arc_intel },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1260, &arc_intel },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1270, &arc_intel },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1280, &arc_intel },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1380, &arc_intel },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1381, &arc_intel },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1680, &arc_intel },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1681, &arc_intel },
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1880, &arc_lsi }
};

const struct arc_board *
arc_match_board(struct pci_attach_args *pa)
{
	const struct arc_board		*ab;
	int				i;

	for (i = 0; i < sizeof(arc_devices) / sizeof(arc_devices[0]); i++) {
		ab = &arc_devices[i];

		if (PCI_VENDOR(pa->pa_id) == ab->ab_vendor &&
		    PCI_PRODUCT(pa->pa_id) == ab->ab_product)
			return (ab);
	}

	return (NULL);
}

int
arc_match(struct device *parent, void *match, void *aux)
{
	return ((arc_match_board(aux) == NULL) ? 0 : 1);
}

void
arc_attach(struct device *parent, struct device *self, void *aux)
{
	struct arc_softc		*sc = (struct arc_softc *)self;
	struct pci_attach_args		*pa = aux;
	struct scsibus_attach_args	saa;
	struct device			*child;

	sc->sc_talking = 0;
	rw_init(&sc->sc_lock, "arcmsg");

	sc->sc_iop = arc_match_board(pa)->ab_iop;
	if(sc->sc_iop == &arc_intel)
		sc->sc_adp_type = ARC_HBA_TYPE_A;
	else if(sc->sc_iop == &arc_marvell)
		sc->sc_adp_type = ARC_HBA_TYPE_B;
	else if(sc->sc_iop == &arc_lsi)
		sc->sc_adp_type = ARC_HBA_TYPE_C;
	else if(sc->sc_iop == &arc_marvell2)
		sc->sc_adp_type = ARC_HBA_TYPE_D;
	if (arc_map_pci_resources(sc, pa) != 0) {
		/* error message printed by arc_map_pci_resources */
		return;
	}

	if (arc_alloc_ccbs(sc) != 0) {
		/* error message printed by arc_alloc_ccbs */
		goto unmap_pci;
	}

	arc_iop_set_conf(sc);

	if (sc->sc_iop->iop_query_firmware(sc) != 0) {
		/* error message printed by arc_query_firmware */
		goto unmap_pci;
	}

	sc->sc_link.adapter = &arc_switch;
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = ARC_MAX_TARGET;
	sc->sc_link.adapter_buswidth = ARC_MAX_TARGET;
	sc->sc_link.openings = sc->sc_req_count;
	sc->sc_link.pool = &sc->sc_iopool;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	child = config_found(self, &saa, scsiprint);
	sc->sc_scsibus = (struct scsibus_softc *)child;

	/* enable interrupts */
	arc_enable_all_intr(sc);

#if NBIO > 0
	if (bio_register(self, arc_bioctl) != 0)
		panic("%s: bioctl registration failed", DEVNAME(sc));

#ifndef SMALL_KERNEL
	/*
	 * you need to talk to the firmware to get volume info. our firmware
	 * interface relies on being able to sleep, so we need to use a thread
	 * to do the work.
	 */
	{
		struct arc_task *at;
		at = malloc(sizeof(*at), M_TEMP, M_WAITOK);

		at->sc = sc;
		task_set(&at->t, arc_create_sensors, at);
		task_add(systq, &at->t);
	}
#endif
#endif

	return;
unmap_pci:
	arc_unmap_pci_resources(sc);
}

int
arc_activate(struct device *self, int act)
{
	int rv = 0;

	switch (act) {
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		arc_detach(self, 0);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);	
}

int
arc_detach(struct device *self, int flags)
{
	struct arc_softc		*sc = (struct arc_softc *)self;

	arc_stop_bgrb_proc(sc);
	arc_flush_cache(sc);

	return (0);
}

int
arc_intr_A(void *arg)
{
	struct arc_softc		*sc = arg;
	struct arc_ccb			*ccb = NULL;
	char				*kva = ARC_DMA_KVA(sc->sc_requests);
	struct arc_io_cmd		*cmd;
	u_int32_t			reg, intrstat, error;
	int				ret = 0;

	intrstat = arc_read(sc, ARC_RA_INTRSTAT);
	intrstat &= ARC_RA_INTRSTAT_POSTQUEUE | ARC_RA_INTRSTAT_DOORBELL |
		ARC_RA_INTRSTAT_MSG0;
	arc_write(sc, ARC_RA_INTRSTAT, intrstat);

	if (intrstat & ARC_RA_INTRSTAT_DOORBELL) {
		ret = 1;
		if (sc->sc_talking) {
			/* if an ioctl is talking, wake it up */
			arc_write(sc, ARC_RA_INTRMASK,
			    ~ARC_RA_INTRMASK_POSTQUEUE);
			wakeup(sc);
		} else {
			/* otherwise drop it */
			reg = arc_read(sc, ARC_RA_OUTB_DOORBELL);
			arc_write(sc, ARC_RA_OUTB_DOORBELL, reg);
			if (reg & ARC_RA_OUTB_DOORBELL_WRITE_OK)
				arc_write(sc, ARC_RA_INB_DOORBELL,
				    ARC_RA_INB_DOORBELL_READ_OK);
		}
	}

	if (intrstat & ARC_RA_INTRSTAT_POSTQUEUE) {
		while ((reg = arc_read(sc, ARC_RA_REPLY_QUEUE)) != 0xffffffff) {
			ret = 1;
			cmd = (struct arc_io_cmd *)(kva +
		    	((reg << ARC_RA_REPLY_QUEUE_ADDR_SHIFT) -
		    	(u_int32_t)ARC_DMA_DVA(sc->sc_requests)));
			ccb = cmd->ccb;

			bus_dmamap_sync(sc->sc_dmat, ARC_DMA_MAP(sc->sc_requests),
		    	ccb->cmd_dma_offset, ARC_MAX_IOCMDLEN,
		    	BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

			error = (reg & ARC_RA_REPLY_QUEUE_ERR)? 1:0;
			arc_scsi_cmd_done(sc, ccb, error);
		}
	}
	return (ret);
}

int
arc_intr_C(void *arg)
{
	struct arc_softc		*sc = arg;
	struct arc_ccb			*ccb = NULL;
	char				*kva = ARC_DMA_KVA(sc->sc_requests);
	struct arc_io_cmd		*cmd;
	u_int32_t			reg, intrstat, obmsg, error;
	int				ret = 0, throttling;

	intrstat = arc_read(sc, ARC_RC_INTR_STAT);
	if (!(intrstat & (ARC_RC_INTR_STAT_POSTQUEUE | 
		ARC_RC_INTR_STAT_DOORBELL)))
		return (ret);

	if (intrstat & ARC_RC_INTR_STAT_DOORBELL) {
		ret = 1;
		if (sc->sc_talking) {
			/* if an ioctl is talking, wake it up */
			arc_write(sc, ARC_RC_INTR_MASK,
			    ~ARC_RC_INTR_MASK_POSTQUEUE);
			wakeup(sc);
		} else {
			/* otherwise drop it */
			reg = arc_read(sc, ARC_RC_OUTB_DOORBELL);
			arc_write(sc, ARC_RC_OUTB_DOORBELL_CLR, reg);
			if (reg & ARC_RC_I2D_DATA_WRITE_OK) {
				arc_write(sc, ARC_RC_INB_DOORBELL,
				    ARC_RC_I2D_DATA_READ_OK);
			}
/*			if (reg & ARC_RC_I2D_DATA_READ_OK) {
				arc_write(sc, ARC_RC_INB_DOORBELL,
				    ARC_RC_D2I_DATA_WRITE_OK);
			}
*/
			if (reg & ARC_RC_I2D_MESSAGE_CMD_DONE) {
				arc_write(sc, ARC_RC_OUTB_DOORBELL_CLR,
					ARC_RC_I2D_MSG_CMD_DONE_CLR);
				obmsg = arc_read(sc, ARC_RC_MSG_RWBUF);
				if (obmsg == ARC_FWINFO_SIGNATURE_GET_CONFIG)
					;	/* handle devices hot-plug */
			}
			
		}
	}

	if (intrstat & ARC_RC_INTR_STAT_POSTQUEUE) {
		ret = 1;
		throttling = 0;
		while (arc_read(sc, ARC_RC_INTR_STAT) &
			ARC_RC_INTR_STAT_POSTQUEUE) {
			reg = arc_read(sc, ARC_RC_OUTB_REPLYQ_LOW);
			cmd = (struct arc_io_cmd *)(kva + ((reg & 0xFFFFFFE0) -
		    	(u_int32_t)ARC_DMA_DVA(sc->sc_requests)));
			ccb = cmd->ccb;

			bus_dmamap_sync(sc->sc_dmat, ARC_DMA_MAP(sc->sc_requests),
		    	ccb->cmd_dma_offset, ARC_MAX_IOCMDLEN,
		    	BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

			error = (reg & ARC_RC_REPLY_QUEUE_ERR);
			arc_scsi_cmd_done(sc, ccb, error);
			throttling++;
			if(throttling == ARC_RC_THROTTLE) {
				arc_write(sc, ARC_RC_INB_DOORBELL,
				    ARC_RC_D2I_POSTQUEUE_THROTTLING);
				throttling = 0;
			}
		}
	}

	return (ret);
}

static u_int16_t
arcmsr_get_doneq_index(struct arc_HBD_Msgu *phbdmu)
{
	u_int16_t doneq_index, index_stripped;

	doneq_index = phbdmu->doneq_index;
	if (doneq_index & 0x4000) {
		index_stripped = doneq_index & 0xFF;
		index_stripped += 1;
		index_stripped %= ARCMSR_MAX_HBD_POSTQUEUE;
		phbdmu->doneq_index = index_stripped ?
		    (index_stripped | 0x4000) : index_stripped;
	} else {
		index_stripped = doneq_index;
		index_stripped += 1;
		index_stripped %= ARCMSR_MAX_HBD_POSTQUEUE;
		phbdmu->doneq_index = index_stripped ?
		    index_stripped : (index_stripped | 0x4000);
	}
	return (phbdmu->doneq_index);
}

int
arc_intr_D(void *arg)
{
	struct arc_softc		*sc = arg;
	struct arc_ccb			*ccb = NULL;
	char				*kva = ARC_DMA_KVA(sc->sc_requests);
	struct arc_io_cmd		*cmd;
	u_int32_t			reg, intrstat, obmsg, error;
	u_int32_t ob_write_ptr;
	u_int16_t doneq_index;
	int				ret = 0;
	struct arc_HBD_Msgu *pmu;

	intrstat = arc_read(sc, ARC_RD_INTR_STAT);
	if (!(intrstat & (ARC_RD_INTR_STAT_POSTQUEUE | 
		ARC_RD_INTR_STAT_DOORBELL)))
		return (ret);

	if (intrstat & ARC_RD_INTR_STAT_DOORBELL) {
		ret = 1;
		if (sc->sc_talking) {
			/* if an ioctl is talking, wake it up */
			arc_write(sc, ARC_RD_INTR_ENABLE,
			    ARC_RD_INTR_ENABLE_POSTQUEUE);
			wakeup(sc);
		} else {
			/* otherwise drop it */
			reg = arc_read(sc, ARC_RD_OUTB_DOORBELL);
			arc_write(sc, ARC_RD_OUTB_DOORBELL, reg);
			if (reg & ARC_RD_I2D_DATA_WRITE_OK) {
				arc_write(sc, ARC_RD_INB_DOORBELL,
				    ARC_RD_I2D_DATA_READ_OK);
			}
/*			if (reg & ARC_RD_I2D_DATA_READ_OK) {
				arc_write(sc, ARC_RD_INB_DOORBELL,
				    ARC_RD_D2I_DATA_WRITE_OK);
			}
*/
			if (reg & ARC_RD_I2D_MESSAGE_CMD_DONE) {
				arc_write(sc, ARC_RD_OUTB_DOORBELL_CLR,
					ARC_RD_I2D_MSG_CMD_DONE_CLR);
				obmsg = arc_read(sc, ARC_RD_MSG_RWBUF);
				if (obmsg == ARC_FWINFO_SIGNATURE_GET_CONFIG)
					;	/* handle devices hot-plug */
			}
			
		}
	}

	if (intrstat & ARC_RD_INTR_STAT_POSTQUEUE) {
		ret = 1;
		arc_write(sc, ARC_RD_OUTB_INTR_CAUSE, ARC_RD_OUTB_LIST_INT_CLR);
		bus_dmamap_sync(sc->sc_dmat, ARC_DMA_MAP(sc->sc_requests),
		    sc->cmdQ_ptr_offset, ARC_MAX_CMDQ_PTR_LEN,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
		pmu = sc->pmu;
		ob_write_ptr = pmu->done_qbuffer[0].addressLow;
		doneq_index = pmu->doneq_index;
		while ((doneq_index & 0xFF) != (ob_write_ptr & 0xFF)) {
			doneq_index = arcmsr_get_doneq_index(pmu);
			reg = pmu->done_qbuffer[(doneq_index & 0xFF)+1].addressLow;
			cmd = (struct arc_io_cmd *)(kva + ((reg & 0xFFFFFFF0) -
		    	(u_int32_t)ARC_DMA_DVA(sc->sc_requests)));
			ccb = cmd->ccb;
			bus_dmamap_sync(sc->sc_dmat, ARC_DMA_MAP(sc->sc_requests),
		   		ccb->cmd_dma_offset, ARC_MAX_IOCMDLEN,
		   		BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			error = (reg & ARC_RD_REPLY_QUEUE_ERR);
			arc_scsi_cmd_done(sc, ccb, error);
			arc_write(sc, ARC_RD_OUTB_READ_PTR, doneq_index);
			ob_write_ptr = pmu->done_qbuffer[0].addressLow;
		}
	}

	return (ret);
}

int
arc_intr(void *arg)
{
	struct arc_softc	*sc = arg;
	int		ret = 0;

	switch(sc->sc_adp_type) {
	case ARC_HBA_TYPE_A:
		ret = arc_intr_A(arg);
		break;
	case ARC_HBA_TYPE_C:
		ret = arc_intr_C(arg);
		break;
	case ARC_HBA_TYPE_D:
		ret = arc_intr_D(arg);
		break;
	}
	return (ret);
}

void
arc_scsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link		*link = xs->sc_link;
	struct arc_softc		*sc = link->adapter_softc;
	struct arc_ccb			*ccb;
	struct arc_msg_scsicmd		*cmd;
	u_int32_t			reg, cdb_len;
	int				s;
	struct arc_HBD_Msgu *pmu;
	u_int16_t index_stripped;
	u_int16_t postq_index;
	struct InBound_SRB *pinbound_srb;

	if (xs->cmdlen > ARC_MSG_CDBLEN) {
		bzero(&xs->sense, sizeof(xs->sense));
		xs->sense.error_code = SSD_ERRCODE_VALID | 0x70;
		xs->sense.flags = SKEY_ILLEGAL_REQUEST;
		xs->sense.add_sense_code = 0x20;
		xs->error = XS_SENSE;
		scsi_done(xs);
		return;
	}

	ccb = xs->io;
	ccb->ccb_xs = xs;

	if (arc_load_xs(ccb) != 0) {
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	cmd = &ccb->ccb_cmd->cmd;
	reg = ccb->ccb_cmd_post;
	ccb->ccb_cmd->ccb = ccb;
	/* bus is always 0 */
	cmd->target = link->target;
	cmd->lun = link->lun;
	cmd->function = 1; /* XXX magic number */

	cmd->cdb_len = xs->cmdlen;
	cmd->sgl_len = ccb->ccb_dmamap->dm_nsegs;
	if (xs->flags & SCSI_DATA_OUT)
		cmd->flags = ARC_MSG_SCSICMD_FLAG_WRITE;
	if (ccb->ccb_dmamap->dm_nsegs > ARC_SGL_256LEN) {
		cmd->flags |= ARC_MSG_SCSICMD_FLAG_SGL_BSIZE_512;
/*		reg |= ARC_RA_POST_QUEUE_BIGFRAME; */
	}

	cmd->data_len = htole32(xs->datalen);

	bcopy(xs->cmd, cmd->cdb, xs->cmdlen);

	/* we've built the command, let's put it on the hw */
	bus_dmamap_sync(sc->sc_dmat, ARC_DMA_MAP(sc->sc_requests),
	    ccb->cmd_dma_offset, ARC_MAX_IOCMDLEN,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	s = splbio();
	switch(sc->sc_adp_type) {
	case ARC_HBA_TYPE_A:
		if (cmd->flags & ARC_MSG_SCSICMD_FLAG_SGL_BSIZE_512)
			reg |= ARC_RA_POST_QUEUE_BIGFRAME;
		arc_write(sc, ARC_RA_POST_QUEUE, reg);
		break;
	case ARC_HBA_TYPE_C:
		cdb_len = sizeof(struct arc_msg_scsicmd) +
			sizeof(struct arc_sge) * ccb->ccb_dmamap->dm_nsegs;
		if (cdb_len > 0x300)
			cdb_len = 0x300;
		reg = reg | ((cdb_len - 1) >> 6) | 1;
		if (sc->sc_ccb_phys_hi)
			arc_write(sc, ARC_RC_INB_POSTQ_HIGH, sc->sc_ccb_phys_hi);
		arc_write(sc, ARC_RC_INB_POSTQ_LOW, reg);
		break;
	case ARC_HBA_TYPE_D:
			pmu = sc->pmu;
			postq_index = pmu->postq_index;
			pinbound_srb = (struct InBound_SRB *)&pmu->post_qbuffer[postq_index & 0xFF];

			pinbound_srb->addressHigh = sc->sc_ccb_phys_hi;
			pinbound_srb->addressLow = ccb->ccb_cmd_post;
			pinbound_srb->length = ccb->arc_io_cmd_length >> 2;
			cmd->context = ccb->ccb_cmd_post;
			if (postq_index & 0x4000) {
				index_stripped = postq_index & 0xFF;
				index_stripped += 1;
				index_stripped %= ARCMSR_MAX_HBD_POSTQUEUE;
				pmu->postq_index = index_stripped ? (index_stripped | 0x4000) : index_stripped;
			} else {
				index_stripped = postq_index;
				index_stripped += 1;
				index_stripped %= ARCMSR_MAX_HBD_POSTQUEUE;
				pmu->postq_index = index_stripped ? index_stripped : (index_stripped | 0x4000);
			}
			bus_dmamap_sync(sc->sc_dmat, ARC_DMA_MAP(sc->sc_requests),
			    sc->cmdQ_ptr_offset, ARC_MAX_CMDQ_PTR_LEN,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			arc_write(sc, ARC_RD_INB_WRITE_PTR, postq_index);
		break;
	}
	if (xs->flags & SCSI_POLL) {
		if (arc_complete(sc, ccb, xs->timeout) != 0) {
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
		}
	}
	splx(s);
}

int
arc_load_xs(struct arc_ccb *ccb)
{
	struct arc_softc		*sc = ccb->ccb_sc;
	struct scsi_xfer		*xs = ccb->ccb_xs;
	bus_dmamap_t			dmap = ccb->ccb_dmamap;
	struct arc_sge			*sgl = ccb->ccb_cmd->sgl, *sge;
	u_int64_t			addr;
	int				i, error;
	u_int32_t	msg_length;

	if (xs->datalen == 0)
	{
		ccb->arc_io_cmd_length = sizeof(struct arc_msg_scsicmd);
		ccb->ccb_cmd->cmd.msgPages = 1;
		return (0);
	}
	error = bus_dmamap_load(sc->sc_dmat, dmap,
	    xs->data, xs->datalen, NULL,
	    (xs->flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
	if (error != 0) {
		printf("%s: error %d loading dmamap\n", DEVNAME(sc), error);
		return (1);
	}

	for (i = 0; i < dmap->dm_nsegs; i++) {
		sge = &sgl[i];

		sge->sg_length = htole32(ARC_SGE_64BIT | dmap->dm_segs[i].ds_len);
		addr = dmap->dm_segs[i].ds_addr;
		sge->sg_hi_addr = htole32((u_int32_t)(addr >> 32));
		sge->sg_lo_addr = htole32((u_int32_t)addr);
	}
	ccb->arc_io_cmd_length = sizeof(struct arc_msg_scsicmd) + 
	    sizeof(struct arc_sge) * dmap->dm_nsegs;
	msg_length = ccb->arc_io_cmd_length;
	ccb->ccb_cmd->cmd.msgPages = (msg_length/256) + ((msg_length % 256) ? 1 : 0);

	bus_dmamap_sync(sc->sc_dmat, dmap, 0, dmap->dm_mapsize,
	    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :
	    BUS_DMASYNC_PREWRITE);

	return (0);
}

void
arc_scsi_cmd_done(struct arc_softc *sc, struct arc_ccb *ccb, u_int32_t error)
{
	struct scsi_xfer		*xs = ccb->ccb_xs;
	struct arc_msg_scsicmd		*cmd;

	if (xs->datalen != 0) {
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0,
		    ccb->ccb_dmamap->dm_mapsize, (xs->flags & SCSI_DATA_IN) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ccb->ccb_dmamap);
	}

	if (error) {
		cmd = &ccb->ccb_cmd->cmd;
		DPRINTF("%s: arc_scsi_cmd_done error! target 0x%x, lun 0x%x, "
			"status = 0x%x\n", DEVNAME(sc), cmd->target, cmd->lun,
			cmd->status);
		DPRINTF("%s: scsi cdb: 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
			", 0x%x, 0x%x, 0x%x\n", DEVNAME(sc), cmd->cdb[0], cmd->cdb[1],
			cmd->cdb[2], cmd->cdb[3],cmd->cdb[4], cmd->cdb[5],
			cmd->cdb[6], cmd->cdb[7],cmd->cdb[8], cmd->cdb[9]);

		switch (cmd->status) {
		case ARC_MSG_STATUS_SELTIMEOUT:
		case ARC_MSG_STATUS_ABORTED:
		case ARC_MSG_STATUS_INIT_FAIL:
			xs->status = SCSI_OK;
			xs->error = XS_SELTIMEOUT;
			break;

		case SCSI_CHECK:
			bzero(&xs->sense, sizeof(xs->sense));
			bcopy(cmd->sense_data, &xs->sense,
			    min(ARC_MSG_SENSELEN, sizeof(xs->sense)));
			xs->sense.error_code = SSD_ERRCODE_VALID | 0x70;
			xs->status = SCSI_CHECK;
			xs->error = XS_SENSE;
			xs->resid = 0;
			break;

		default:
			/* unknown device status */
			xs->error = XS_BUSY; /* try again later? */
			xs->status = SCSI_BUSY;
			break;
		}
	} else {
		xs->status = SCSI_OK;
		xs->error = XS_NOERROR;
		xs->resid = 0;
	}

	scsi_done(xs);
}

int
arc_complete(struct arc_softc *sc, struct arc_ccb *nccb, int timeout)
{
	struct arc_ccb			*ccb = NULL;
	char				*kva = ARC_DMA_KVA(sc->sc_requests);
	struct arc_io_cmd		*cmd;
	u_int32_t			reg, error, write_ptr;
	u_int16_t	doneq_index;
	struct arc_HBD_Msgu *phbdmu;
	int		ret = 0;
	
	arc_disable_all_intr(sc);
	do {
		switch(sc->sc_adp_type) {
		case ARC_HBA_TYPE_A:
			reg = arc_read(sc, ARC_RA_REPLY_QUEUE);
			error = (reg & ARC_RA_REPLY_QUEUE_ERR)? 1:0;
			break;
		case ARC_HBA_TYPE_C:
			reg = arc_read(sc, ARC_RC_OUTB_REPLYQ_LOW);
			error = (reg & ARC_RC_REPLY_QUEUE_ERR);
			break;
		case ARC_HBA_TYPE_D:
			phbdmu = sc->pmu;
			write_ptr = phbdmu->done_qbuffer[0].addressLow;
			doneq_index = phbdmu->doneq_index;
			if((write_ptr & 0xff) == (doneq_index & 0xff)) {
Loop0:
				reg = 0xffffffff;
			}	
			else {
				doneq_index = arcmsr_get_doneq_index(phbdmu);
				reg = phbdmu->done_qbuffer[(doneq_index & 0xFF)+1].addressLow;
				if (reg == 0)
					goto Loop0;
				arc_write(sc, ARC_RD_OUTB_READ_PTR, doneq_index);
			}
			error = (reg & ARC_RD_REPLY_QUEUE_ERR);
			break;
		}
		if (reg == 0xffffffff) {
			if (timeout-- == 0) {
				return (1);
			}
			delay(1000);
			continue;
		}

		switch(sc->sc_adp_type) {
		case ARC_HBA_TYPE_A:
			cmd = (struct arc_io_cmd *)(kva +
		    	((reg << ARC_RA_REPLY_QUEUE_ADDR_SHIFT) -
		    	ARC_DMA_DVA(sc->sc_requests)));
		    break;
		case ARC_HBA_TYPE_C:
		case ARC_HBA_TYPE_D:
			cmd = (struct arc_io_cmd *)(kva + ((reg & 0xFFFFFFE0) -
		    	ARC_DMA_DVA(sc->sc_requests)));
		    break;
		}
		ccb = cmd->ccb;

		bus_dmamap_sync(sc->sc_dmat, ARC_DMA_MAP(sc->sc_requests),
		    ccb->cmd_dma_offset, ARC_MAX_IOCMDLEN,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

		arc_scsi_cmd_done(sc, ccb, error);
			
	} while (nccb != ccb);
	arc_enable_all_intr(sc);

	return (ret);
}

void
arc_minphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > MAXPHYS)
		bp->b_bcount = MAXPHYS;
	minphys(bp);
}

void
arc_enable_all_intr(struct arc_softc *sc)
{
	u_int32_t int_mask;

	switch(sc->sc_adp_type) {
	case ARC_HBA_TYPE_A:
		int_mask = arc_read(sc, ARC_RA_INTRMASK);
		int_mask &= ~(ARC_RA_INTRMASK_POSTQUEUE |
			ARC_RA_INTRMASK_DOORBELL | ARC_RA_INTRMASK_MSG0);
		arc_write(sc, ARC_RA_INTRMASK, int_mask);
	    break;
	case ARC_HBA_TYPE_C:
		int_mask = arc_read(sc, ARC_RC_INTR_MASK);
		int_mask &= ~(ARC_RC_INTR_MASK_POSTQUEUE |
			ARC_RC_INTR_MASK_DOORBELL | ARC_RC_INTR_MASK_UTILITY_A);
		arc_write(sc, ARC_RC_INTR_MASK, int_mask);
	    break;
	case ARC_HBA_TYPE_D:
		int_mask = arc_read(sc, ARC_RD_INTR_ENABLE);
		int_mask |= ARC_RD_INTR_ENABLE_ALL;
		arc_write(sc, ARC_RD_INTR_ENABLE, int_mask);
	    break;
	}
}

void
arc_disable_all_intr(struct arc_softc *sc)
{
	u_int32_t int_mask;

	switch(sc->sc_adp_type) {
	case ARC_HBA_TYPE_A:
		int_mask = arc_read(sc, ARC_RA_INTRMASK);
		int_mask |= ARC_RA_INTR_MASK_ALL;
		arc_write(sc, ARC_RA_INTRMASK, int_mask);
		break;
	case ARC_HBA_TYPE_C:
		int_mask = arc_read(sc, ARC_RC_INTR_MASK);
		int_mask |= ARC_RC_INTR_MASK_ALL;
		arc_write(sc, ARC_RC_INTR_MASK, int_mask);
		break;
	case ARC_HBA_TYPE_D:
		int_mask = arc_read(sc, ARC_RD_INTR_ENABLE);
		int_mask &= ~ARC_RD_INTR_ENABLE_ALL;
		arc_write(sc, ARC_RD_INTR_ENABLE, ARC_RD_INTR_DISABLE_ALL);
		break;
	}
}

int
arc_map_pci_resources(struct arc_softc *sc, struct pci_attach_args *pa)
{
	pcireg_t			memtype;
	pci_intr_handle_t		ih;

	sc->sc_pc = pa->pa_pc;
	sc->sc_tag = pa->pa_tag;
	sc->sc_dmat = pa->pa_dmat;

	switch(sc->sc_adp_type) {
		case ARC_HBA_TYPE_A:
		memtype = pci_mapreg_type(sc->sc_pc, sc->sc_tag, ARC_RA_PCI_BAR);
		if (pci_mapreg_map(pa, ARC_RA_PCI_BAR, memtype, 0, &sc->sc_iot,
	    	&sc->sc_ioh, NULL, &sc->sc_ios, 0) != 0) {
			printf(": unable to map ARC_HBA_TYPE_A system"
				" interface register\n");
			return(1);
		}
		break;
		case ARC_HBA_TYPE_C:
		memtype = pci_mapreg_type(sc->sc_pc, sc->sc_tag, ARC_RC_PCI_BAR);
		if (pci_mapreg_map(pa, ARC_RC_PCI_BAR, memtype, 0, &sc->sc_iot,
	    	&sc->sc_ioh, NULL, &sc->sc_ios, 0) != 0) {
			printf(": unable to map ARC_HBA_TYPE_C system"
				" interface register\n");
			return(1);
		}
		break;
		case ARC_HBA_TYPE_D:
		memtype = pci_mapreg_type(sc->sc_pc, sc->sc_tag, ARC_RD_PCI_BAR);
		if (pci_mapreg_map(pa, ARC_RD_PCI_BAR, memtype, 0, &sc->sc_iot,
	    	&sc->sc_ioh, NULL, &sc->sc_ios, 0) != 0) {
			printf(": unable to map ARC_HBA_TYPE_D system"
				" interface register\n");
			return(1);
		}
		break; 
	}

	arc_disable_all_intr(sc);

	if (pci_intr_map(pa, &ih) != 0) {
		printf(": unable to map interrupt\n");
		goto unmap;
	}
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO,
	    arc_intr, sc, DEVNAME(sc));
	if (sc->sc_ih == NULL) {
		printf(": unable to map interrupt\n");
		goto unmap;
	}
	printf(": %s\n", pci_intr_string(pa->pa_pc, ih));

	return (0);

unmap:
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
	sc->sc_ios = 0;
	return (1);
}

void
arc_unmap_pci_resources(struct arc_softc *sc)
{
	pci_intr_disestablish(sc->sc_pc, sc->sc_ih);
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
	sc->sc_ios = 0;
}

int
arc_chipA_firmware(struct arc_softc *sc)
{
	struct arc_msg_firmware_info	fwinfo;
	char				string[81]; /* sizeof(vendor)*2+1 */
	u_int32_t	ob_doorbell;

	if (arc_wait_eq(sc, ARC_RA_OUTB_ADDR1, ARC_RA_OUTB_ADDR1_FIRMWARE_OK,
	    ARC_RA_OUTB_ADDR1_FIRMWARE_OK) != 0) {
		printf("%s: timeout waiting for firmware ok\n", DEVNAME(sc));
		return (1);
	}

	if (arc_msg0(sc, ARC_RA_INB_MSG0_GET_CONFIG) != 0) {
		printf("%s: timeout waiting for get config\n", DEVNAME(sc));
		return (1);
	}

	arc_read_region(sc, ARC_RA_MSGBUF, &fwinfo, sizeof(fwinfo));

	DNPRINTF(ARC_D_INIT, "%s: signature: 0x%08x\n", DEVNAME(sc),
	    letoh32(fwinfo.signature));

	if (letoh32(fwinfo.signature) != ARC_FWINFO_SIGNATURE_GET_CONFIG) {
		printf("%s: invalid firmware info from iop\n", DEVNAME(sc));
		return (1);
	}

	DNPRINTF(ARC_D_INIT, "%s: request_len: %d\n", DEVNAME(sc),
	    letoh32(fwinfo.request_len));
	DNPRINTF(ARC_D_INIT, "%s: queue_len: %d\n", DEVNAME(sc),
	    letoh32(fwinfo.queue_len));
	DNPRINTF(ARC_D_INIT, "%s: sdram_size: %d\n", DEVNAME(sc),
	    letoh32(fwinfo.sdram_size));
	DNPRINTF(ARC_D_INIT, "%s: sata_ports: %d\n", DEVNAME(sc),
	    letoh32(fwinfo.sata_ports), letoh32(fwinfo.sata_ports));

	scsi_strvis(string, fwinfo.vendor, sizeof(fwinfo.vendor));
	DNPRINTF(ARC_D_INIT, "%s: vendor: \"%s\"\n", DEVNAME(sc), string);
	scsi_strvis(string, fwinfo.model, sizeof(fwinfo.model));
	DNPRINTF(ARC_D_INIT, "%s: model: \"%s\"\n", DEVNAME(sc), string);

	scsi_strvis(string, fwinfo.fw_version, sizeof(fwinfo.fw_version));
	DNPRINTF(ARC_D_INIT, "%s: firmware: \"%s\"\n", DEVNAME(sc), string);

	if (letoh32(fwinfo.request_len) != ARC_MAX_IOCMDLEN) {
		printf("%s: unexpected request frame size (%d != %d)\n",
		    DEVNAME(sc), letoh32(fwinfo.request_len), ARC_MAX_IOCMDLEN);
		return (1);
	}

	sc->sc_req_count = letoh32(fwinfo.queue_len);

	if (arc_msg0(sc, ARC_RA_INB_MSG0_START_BGRB) != 0) {
		printf("%s: timeout waiting to start bg rebuild\n",
		    DEVNAME(sc));
		return (1);
	}

	/* clear doorbell buffer */
	ob_doorbell = arc_read(sc, ARC_RA_OUTB_DOORBELL);
	arc_write(sc, ARC_RA_OUTB_DOORBELL, ob_doorbell);
	arc_write(sc, ARC_RA_INB_DOORBELL, ARC_RA_INB_DOORBELL_READ_OK);

	printf("%s: %d ports, %dMB SDRAM, firmware %s\n",
	    DEVNAME(sc), letoh32(fwinfo.sata_ports),
	    letoh32(fwinfo.sdram_size), string);

	return (0);
}

int
arc_chipB_firmware(struct arc_softc *sc)
{
	if (arc_wait_eq(sc, ARC_RB_IOP2DRV_DOORBELL,
	    ARC_RA_OUTB_ADDR1_FIRMWARE_OK,
	    ARC_RA_OUTB_ADDR1_FIRMWARE_OK) != 0) {
		printf("%s: timeout waiting for firmware ok\n", DEVNAME(sc));
		return (1);
	}

	return (1);
}

int
arc_chipC_firmware(struct arc_softc *sc)
{
	struct arc_msg_firmware_info	fwinfo;
	char	string[81]; /* sizeof(vendor)*2+1 */
	u_int32_t	ob_doorbell;

	if (arc_wait_eq(sc, ARC_RC_OUTB_MSGADDR1, ARC_RC_OUTB_MSG_FIRMWARE_OK,
	    ARC_RC_OUTB_MSG_FIRMWARE_OK) != 0) {
		printf("%s: timeout waiting for firmware ok\n", DEVNAME(sc));
		return (1);
	}

	if (arc_msg0(sc, ARC_RC_INB_MSG0_GET_CONFIG) != 0) {
		printf("%s: timeout waiting for get config\n", DEVNAME(sc));
		return (1);
	}

	arc_read_region(sc, ARC_RC_MSG_RWBUF, &fwinfo, sizeof(fwinfo));

	DNPRINTF(ARC_D_INIT, "%s: signature: 0x%08x\n", DEVNAME(sc),
	    letoh32(fwinfo.signature));

	if (letoh32(fwinfo.signature) != ARC_FWINFO_SIGNATURE_GET_CONFIG) {
		printf("%s: invalid firmware info from iop\n", DEVNAME(sc));
		return (1);
	}

	DNPRINTF(ARC_D_INIT, "%s: request_len: %d\n", DEVNAME(sc),
	    letoh32(fwinfo.request_len));
	DNPRINTF(ARC_D_INIT, "%s: queue_len: %d\n", DEVNAME(sc),
	    letoh32(fwinfo.queue_len));
	DNPRINTF(ARC_D_INIT, "%s: sdram_size: %d\n", DEVNAME(sc),
	    letoh32(fwinfo.sdram_size));
	DNPRINTF(ARC_D_INIT, "%s: sata_ports: %d\n", DEVNAME(sc),
	    letoh32(fwinfo.sata_ports), letoh32(fwinfo.sata_ports));

	scsi_strvis(string, fwinfo.vendor, sizeof(fwinfo.vendor));
	DNPRINTF(ARC_D_INIT, "%s: vendor: \"%s\"\n", DEVNAME(sc), string);
	scsi_strvis(string, fwinfo.model, sizeof(fwinfo.model));
	DNPRINTF(ARC_D_INIT, "%s: model: \"%s\"\n", DEVNAME(sc), string);

	scsi_strvis(string, fwinfo.fw_version, sizeof(fwinfo.fw_version));
	DNPRINTF(ARC_D_INIT, "%s: firmware: \"%s\"\n", DEVNAME(sc), string);

	if (letoh32(fwinfo.request_len) != ARC_MAX_IOCMDLEN) {
		printf("%s: unexpected request frame size (%d != %d)\n",
		    DEVNAME(sc), letoh32(fwinfo.request_len), ARC_MAX_IOCMDLEN);
		return (1);
	}

	sc->sc_req_count = letoh32(fwinfo.queue_len);

	if (arc_msg0(sc, ARC_RC_INB_MSG0_START_BGRB) != 0) {
		printf("%s: timeout waiting to start bg rebuild\n",
		    DEVNAME(sc));
		return (1);
	}

	/* clear doorbell buffer */
	ob_doorbell = arc_read(sc, ARC_RC_OUTB_DOORBELL);
	arc_write(sc, ARC_RC_OUTB_DOORBELL_CLR, ob_doorbell);
	arc_write(sc, ARC_RC_INB_DOORBELL, ARC_RC_D2I_DATA_READ_OK);

	printf("%s: %d ports, %dMB SDRAM, firmware %s\n",
	    DEVNAME(sc), letoh32(fwinfo.sata_ports),
	    letoh32(fwinfo.sdram_size), string);

	return (0);
}

int
arc_chipD_firmware(struct arc_softc *sc)
{
	struct arc_msg_firmware_info	fwinfo;
	char	string[81]; /* sizeof(vendor)*2+1 */
	u_int32_t	ob_doorbell;

	if (arc_wait_eq(sc, ARC_RD_OUTB_MSGADDR1, ARC_RD_OUTB_MSG_FIRMWARE_OK,
	    ARC_RD_OUTB_MSG_FIRMWARE_OK) != 0) {
		printf("%s: timeout waiting for firmware ok\n", DEVNAME(sc));
		return (1);
	}

	if ((arc_read(sc, ARC_RD_OUTB_DOORBELL) & ARC_RD_I2D_MESSAGE_CMD_DONE))
		arc_write(sc, ARC_RD_OUTB_DOORBELL, ARC_RD_I2D_MESSAGE_CMD_DONE_CLEAR);

	if (arc_msg0(sc, ARC_RD_INB_MSG0_GET_CONFIG) != 0) {
		printf("%s: timeout waiting for get config\n", DEVNAME(sc));
		return (1);
	}

	arc_read_region(sc, ARC_RD_MSG_RWBUF, &fwinfo, sizeof(fwinfo));

	DNPRINTF(ARC_D_INIT, "%s: signature: 0x%08x\n", DEVNAME(sc),
	    letoh32(fwinfo.signature));

	if (letoh32(fwinfo.signature) != ARC_FWINFO_SIGNATURE_GET_CONFIG) {
		printf("%s: invalid firmware info from iop\n", DEVNAME(sc));
		return (1);
	}

	DNPRINTF(ARC_D_INIT, "%s: request_len: %d\n", DEVNAME(sc),
	    letoh32(fwinfo.request_len));
	DNPRINTF(ARC_D_INIT, "%s: queue_len: %d\n", DEVNAME(sc),
	    letoh32(fwinfo.queue_len));
	DNPRINTF(ARC_D_INIT, "%s: sdram_size: %d\n", DEVNAME(sc),
	    letoh32(fwinfo.sdram_size));
	DNPRINTF(ARC_D_INIT, "%s: sata_ports: %d\n", DEVNAME(sc),
	    letoh32(fwinfo.sata_ports), letoh32(fwinfo.sata_ports));

	scsi_strvis(string, fwinfo.vendor, sizeof(fwinfo.vendor));
	DNPRINTF(ARC_D_INIT, "%s: vendor: \"%s\"\n", DEVNAME(sc), string);
	scsi_strvis(string, fwinfo.model, sizeof(fwinfo.model));
	DNPRINTF(ARC_D_INIT, "%s: model: \"%s\"\n", DEVNAME(sc), string);

	scsi_strvis(string, fwinfo.fw_version, sizeof(fwinfo.fw_version));
	DNPRINTF(ARC_D_INIT, "%s: firmware: \"%s\"\n", DEVNAME(sc), string);

	if (letoh32(fwinfo.request_len) != ARC_MAX_IOCMDLEN) {
		printf("%s: unexpected request frame size (%d != %d)\n",
		    DEVNAME(sc), letoh32(fwinfo.request_len), ARC_MAX_IOCMDLEN);
		return (1);
	}

	sc->sc_req_count = letoh32(fwinfo.queue_len) - 1;

	if (arc_msg0(sc, ARC_RD_INB_MSG0_START_BGRB) != 0) {
		printf("%s: timeout waiting to start bg rebuild\n",
		    DEVNAME(sc));
		return (1);
	}

	/* clear doorbell buffer */
	ob_doorbell = arc_read(sc, ARC_RD_OUTB_DOORBELL);
	arc_write(sc, ARC_RD_OUTB_DOORBELL_CLR, ob_doorbell);
	arc_write(sc, ARC_RD_INB_DOORBELL, ARC_RD_D2I_DATA_READ_OK);

	printf("%s: %d ports, %dMB SDRAM, firmware %s\n",
	    DEVNAME(sc), letoh32(fwinfo.sata_ports),
	    letoh32(fwinfo.sdram_size), string);

	return (0);
}

void
arc_stop_bgrb_proc(struct arc_softc *sc)
{
	switch(sc->sc_adp_type) {
	case ARC_HBA_TYPE_A:
		if (arc_msg0(sc, ARC_RA_INB_MSG0_STOP_BGRB) != 0)
			printf("%s: timeout waiting to stop bg rebuild\n",
				DEVNAME(sc));
		break;
	case ARC_HBA_TYPE_C:
		if (arc_msg0(sc, ARC_RC_INB_MSG0_STOP_BGRB) != 0)
			printf("%s: timeout waiting to stop bg rebuild\n",
				DEVNAME(sc));
		break;
	case ARC_HBA_TYPE_D:
		if (arc_msg0(sc, ARC_RD_INB_MSG0_STOP_BGRB) != 0)
			printf("%s: timeout waiting to stop bg rebuild\n",
				DEVNAME(sc));
		break;
	}
}

void
arc_flush_cache(struct arc_softc *sc)
{
	switch(sc->sc_adp_type) {
	case ARC_HBA_TYPE_A:
		if (arc_msg0(sc, ARC_RA_INB_MSG0_FLUSH_CACHE) != 0)
			printf("%s: timeout waiting to flush cache\n",
				DEVNAME(sc));
		break;
	case ARC_HBA_TYPE_C:
		if (arc_msg0(sc, ARC_RC_INB_MSG0_FLUSH_CACHE) != 0)
			printf("%s: timeout waiting to flush cache\n",
				DEVNAME(sc));
		break;
	case ARC_HBA_TYPE_D:
		if (arc_msg0(sc, ARC_RD_INB_MSG0_FLUSH_CACHE) != 0)
			printf("%s: timeout waiting to flush cache\n",
				DEVNAME(sc));
		break;
	}
}

void
arc_iop_set_conf(struct arc_softc *sc)
{
	u_int32_t ccb_phys_hi;
	struct arc_HBD_Msgu *phbdmu;

	ccb_phys_hi = sc->sc_ccb_phys_hi;
	switch (sc->sc_adp_type) {
	case ARC_HBA_TYPE_A:
		arc_write(sc, ARC_RA_MSGBUF, ARC_FWINFO_SIGNATURE_SET_CONFIG);
		arc_write(sc, ARC_RA_MSGBUF+1, ccb_phys_hi);
		arc_msg0(sc, ARC_RA_INB_MSG0_SET_CONFIG);
		break;
	case ARC_HBA_TYPE_C:
		arc_write(sc, ARC_RC_MSG_RWBUF, ARC_FWINFO_SIGNATURE_SET_CONFIG);
		arc_write(sc, ARC_RC_MSG_RWBUF+1, ccb_phys_hi);
		arc_msg0(sc, ARC_RC_INB_MSG0_SET_CONFIG);
		break;
	case ARC_HBA_TYPE_D:
		phbdmu = sc->pmu;
		phbdmu->postq_index = 0;
		phbdmu->doneq_index = 0x40FF;
		arc_write(sc, ARC_RD_MSG_RWBUF, ARC_FWINFO_SIGNATURE_SET_CONFIG);
		arc_write(sc, ARC_RD_MSG_RWBUF+4, ccb_phys_hi);
		arc_write(sc, ARC_RD_MSG_RWBUF+8, sc->postQ_buffer);
		arc_write(sc, ARC_RD_MSG_RWBUF+12, sc->doneQ_buffer);
		arc_write(sc, ARC_RD_MSG_RWBUF+16, 0x100);
		arc_msg0(sc, ARC_RD_INB_MSG0_SET_CONFIG);
		break;
	}
}

#if NBIO > 0
int
arc_bioctl(struct device *self, u_long cmd, caddr_t addr)
{
	struct arc_softc		*sc = (struct arc_softc *)self;
	int				error = 0;

	DPRINTF("%s: arc_bioctl\n", DEVNAME(sc));
	switch (cmd) {
	case BIOCINQ:
		error = arc_bio_inq(sc, (struct bioc_inq *)addr);
		break;

	case BIOCVOL:
		error = arc_bio_vol(sc, (struct bioc_vol *)addr);
		break;

	case BIOCDISK:
		error = arc_bio_disk(sc, (struct bioc_disk *)addr);
		break;

	case BIOCALARM:
		error = arc_bio_alarm(sc, (struct bioc_alarm *)addr);
		break;

	case BIOCBLINK:
		error = arc_bio_blink(sc, (struct bioc_blink *)addr);
		break;

	default:
		error = ENOTTY;
		break;
	}

	return (error);
}

int
arc_bio_alarm(struct arc_softc *sc, struct bioc_alarm *ba)
{
	u_int8_t			request[2];
	u_int8_t			reply[1];
	size_t				len;
	int				error = 0;

	DPRINTF("%s: arc_bio_alarm\n", DEVNAME(sc));
	switch (ba->ba_opcode) {
	case BIOC_SAENABLE:
	case BIOC_SADISABLE:
		request[0] = ARC_FW_SET_ALARM;
		request[1] = (ba->ba_opcode == BIOC_SAENABLE) ?
		    ARC_FW_SET_ALARM_ENABLE : ARC_FW_SET_ALARM_DISABLE;
		len = sizeof(request);

		break;

	case BIOC_SASILENCE:
		request[0] = ARC_FW_MUTE_ALARM;
		len = 1;

		break;

	case BIOC_GASTATUS:
		/* system info is too big/ugly to deal with here */
		return (arc_bio_alarm_state(sc, ba));

	default:
		return (EOPNOTSUPP);
	}

	arc_lock(sc);
	error = arc_msgbuf(sc, request, len, reply, sizeof(reply), 0);
	arc_unlock(sc);

	if (error != 0)
		return (error);

	switch (reply[0]) {
	case ARC_FW_CMD_OK:
		return (0);
	case ARC_FW_CMD_PASS_REQD:
		return (EPERM);
	default:
		return (EIO);
	}
}

int
arc_bio_alarm_state(struct arc_softc *sc, struct bioc_alarm *ba)
{
	u_int8_t			request = ARC_FW_SYSINFO;
	struct arc_fw_sysinfo		*sysinfo;
	int				error = 0;

	sysinfo = malloc(sizeof(struct arc_fw_sysinfo), M_TEMP, M_WAITOK);

	request = ARC_FW_SYSINFO;

	arc_lock(sc);
	error = arc_msgbuf(sc, &request, sizeof(request),
	    sysinfo, sizeof(struct arc_fw_sysinfo), 0);
	arc_unlock(sc);

	if (error != 0)
		goto out;

	ba->ba_status = sysinfo->alarm;

out:
	free(sysinfo, M_TEMP, sizeof *sysinfo);
	return (error);
}


int
arc_bio_inq(struct arc_softc *sc, struct bioc_inq *bi)
{
	u_int8_t			request[2];
	struct arc_fw_sysinfo		*sysinfo;
	struct arc_fw_volinfo		*volinfo;
	int				maxvols, nvols = 0, i;
	int				error = 0;
	char	string[20];

	DPRINTF("%s: arc_bio_inq\n", DEVNAME(sc));
	sysinfo = malloc(sizeof(struct arc_fw_sysinfo), M_TEMP, M_WAITOK);
	volinfo = malloc(sizeof(struct arc_fw_volinfo), M_TEMP, M_WAITOK);

	arc_lock(sc);

	request[0] = ARC_FW_SYSINFO;
	error = arc_msgbuf(sc, request, 1, sysinfo,
	    sizeof(struct arc_fw_sysinfo), 0);
	if (error != 0) {
		DPRINTF("%s: arc_bio_inq get sysinfo failed!\n", DEVNAME(sc));
		goto out;
	}

	maxvols = sysinfo->max_volume_set;

	request[0] = ARC_FW_VOLINFO;
	for (i = 0; i < maxvols; i++) {
		request[1] = i;
		error = arc_msgbuf(sc, request, sizeof(request), volinfo,
		    sizeof(struct arc_fw_volinfo), 0);
		if (error != 0) {
			DPRINTF("%s: arc_bio_inq get volinfo failed!\n", DEVNAME(sc));
			goto out;
		}

		/*
		 * I can't find an easy way to see if the volume exists or not
		 * except to say that if it has no capacity then it isn't there.
		 * Ignore passthru volumes, bioc_vol doesn't understand them.
		 */
		if ((volinfo->capacity != 0 || volinfo->capacity2 != 0) &&
		    volinfo->raid_level != ARC_FW_VOL_RAIDLEVEL_PASSTHRU) {
			nvols++;
			scsi_strvis(string, volinfo->set_name, 16);
			DPRINTF("%s: volume set: \"%s\"\n", DEVNAME(sc), string);
		}
	}

	strlcpy(bi->bi_dev, DEVNAME(sc), sizeof(bi->bi_dev));
	bi->bi_novol = nvols;
	DPRINTF("%s: volume set number = %d\n", DEVNAME(sc), nvols);
out:
	arc_unlock(sc);
	free(volinfo, M_TEMP, sizeof *volinfo);
	free(sysinfo, M_TEMP, sizeof *sysinfo);
	return (error);
}

int
arc_bio_blink(struct arc_softc *sc, struct bioc_blink *blink)
{
	u_int8_t			 request[6];
	u_int32_t			 mask;
	int				 error = 0;

	DPRINTF("%s: arc_bio_blink\n", DEVNAME(sc));
	request[0] = ARC_FW_BLINK;
	request[1] = ARC_FW_BLINK_ENABLE;

	switch (blink->bb_status) {
	case BIOC_SBUNBLINK:
		sc->sc_ledmask &= ~(1 << blink->bb_target);
		break;
	case BIOC_SBBLINK:
		sc->sc_ledmask |= (1 << blink->bb_target);
		break;
	default:
		return (EINVAL);
	}

	mask = htole32(sc->sc_ledmask);
	bcopy(&mask, &request[2], 4);

	arc_lock(sc);
	error = arc_msgbuf(sc, request, sizeof(request), NULL, 0, 0);
	arc_unlock(sc);
	if (error)
		return (EIO);

	return (0);
}

int
arc_bio_getvol(struct arc_softc *sc, int vol, struct arc_fw_volinfo *volinfo)
{
	u_int8_t			request[2];
	struct arc_fw_sysinfo		*sysinfo;
	int				error = 0;
	int				maxvols, nvols = 0, i;

	DPRINTF("%s: arc_bio_getvol\n", DEVNAME(sc));
	sysinfo = malloc(sizeof(struct arc_fw_sysinfo), M_TEMP, M_WAITOK);

	request[0] = ARC_FW_SYSINFO;
	error = arc_msgbuf(sc, request, 1, sysinfo,
	    sizeof(struct arc_fw_sysinfo), 0);
	if (error != 0)
		goto out;

	maxvols = sysinfo->max_volume_set;

	request[0] = ARC_FW_VOLINFO;
	for (i = 0; i < maxvols; i++) {
		request[1] = i;
		error = arc_msgbuf(sc, request, sizeof(request), volinfo,
		    sizeof(struct arc_fw_volinfo), 0);
		if (error != 0)
			goto out;

		if ((volinfo->capacity == 0 && volinfo->capacity2 == 0) ||
		    volinfo->raid_level == ARC_FW_VOL_RAIDLEVEL_PASSTHRU)
			continue;

		if (nvols == vol)
			break;

		nvols++;
	}

	if (nvols != vol ||
	    (volinfo->capacity == 0 && volinfo->capacity2 == 0) ||
	    volinfo->raid_level == ARC_FW_VOL_RAIDLEVEL_PASSTHRU) {
		error = ENODEV;
		goto out;
	}

out:
	free(sysinfo, M_TEMP, sizeof *sysinfo);
	return (error);
}

int
arc_bio_vol(struct arc_softc *sc, struct bioc_vol *bv)
{
	struct arc_fw_volinfo		*volinfo;
	struct scsi_link		*sc_link;
	struct device			*dev;
	u_int64_t			blocks;
	u_int32_t			status;
	int				error = 0;

	DPRINTF("%s: arc_bio_vol\n", DEVNAME(sc));
	volinfo = malloc(sizeof(struct arc_fw_volinfo), M_TEMP, M_WAITOK);

	arc_lock(sc);
	error = arc_bio_getvol(sc, bv->bv_volid, volinfo);
	arc_unlock(sc);

	if (error != 0)
		goto out;

	bv->bv_percent = -1;
	bv->bv_seconds = 0;

	status = letoh32(volinfo->volume_status);
	if (status == 0x0) {
		if (letoh32(volinfo->fail_mask) == 0x0)
			bv->bv_status = BIOC_SVONLINE;
		else
			bv->bv_status = BIOC_SVDEGRADED;
	} else if (status & ARC_FW_VOL_STATUS_NEED_REGEN)
		bv->bv_status = BIOC_SVDEGRADED;
	else if (status & ARC_FW_VOL_STATUS_FAILED)
		bv->bv_status = BIOC_SVOFFLINE;
	else if (status & ARC_FW_VOL_STATUS_INITTING) {
		bv->bv_status = BIOC_SVBUILDING;
		bv->bv_percent = letoh32(volinfo->progress) / 10;
	} else if (status & ARC_FW_VOL_STATUS_REBUILDING) {
		bv->bv_status = BIOC_SVREBUILD;
		bv->bv_percent = letoh32(volinfo->progress) / 10;
	}

	blocks = (u_int64_t)letoh32(volinfo->capacity2) << 32;
	blocks += (u_int64_t)letoh32(volinfo->capacity);
	bv->bv_size = blocks * ARC_BLOCKSIZE; /* XXX */

	switch (volinfo->raid_level) {
	case ARC_FW_VOL_RAIDLEVEL_0:
		bv->bv_level = 0;
		break;
	case ARC_FW_VOL_RAIDLEVEL_1:
		bv->bv_level = 1;
		break;
	case ARC_FW_VOL_RAIDLEVEL_3:
		bv->bv_level = 3;
		break;
	case ARC_FW_VOL_RAIDLEVEL_5:
		bv->bv_level = 5;
		break;
	case ARC_FW_VOL_RAIDLEVEL_6:
		bv->bv_level = 6;
		break;
	case ARC_FW_VOL_RAIDLEVEL_PASSTHRU:
	default:
		bv->bv_level = -1;
		break;
	}

	bv->bv_nodisk = volinfo->member_disks;
	sc_link = scsi_get_link(sc->sc_scsibus, volinfo->scsi_attr.target,
	    volinfo->scsi_attr.lun);
	if (sc_link != NULL) {
		dev = sc_link->device_softc;
		strlcpy(bv->bv_dev, dev->dv_xname, sizeof(bv->bv_dev));
	}

out:
	free(volinfo, M_TEMP, sizeof *volinfo);
	return (error);
}

int
arc_bio_disk(struct arc_softc *sc, struct bioc_disk *bd)
{
	u_int8_t			request[2];
	struct arc_fw_volinfo		*volinfo;
	struct arc_fw_raidinfo		*raidinfo;
	struct arc_fw_diskinfo		*diskinfo;
	int				error = 0;
	u_int64_t			blocks;
	char				model[81];
	char				serial[41];
	char				rev[17];

	DPRINTF("%s: arc_bio_disk\n", DEVNAME(sc));
	volinfo = malloc(sizeof(struct arc_fw_volinfo), M_TEMP, M_WAITOK);
	raidinfo = malloc(sizeof(struct arc_fw_raidinfo), M_TEMP, M_WAITOK);
	diskinfo = malloc(sizeof(struct arc_fw_diskinfo), M_TEMP, M_WAITOK);

	arc_lock(sc);

	error = arc_bio_getvol(sc, bd->bd_volid, volinfo);
	if (error != 0)
		goto out;

	request[0] = ARC_FW_RAIDINFO;
	request[1] = volinfo->raid_set_number;
	error = arc_msgbuf(sc, request, sizeof(request), raidinfo,
	    sizeof(struct arc_fw_raidinfo), 0);
	if (error != 0)
		goto out;

	if (bd->bd_diskid > raidinfo->member_devices) {
		error = ENODEV;
		goto out;
	}

	if (raidinfo->device_array[bd->bd_diskid] == 0xff) {
		/*
		 * the disk doesn't exist anymore. bio is too dumb to be
		 * able to display that, so put it on another bus
		 */
		bd->bd_channel = 1;
		bd->bd_target = 0;
		bd->bd_lun = 0;
		bd->bd_status = BIOC_SDOFFLINE;
		strlcpy(bd->bd_vendor, "disk missing", sizeof(bd->bd_vendor));
		goto out;
	}

	request[0] = ARC_FW_DISKINFO;
	request[1] = raidinfo->device_array[bd->bd_diskid];
	error = arc_msgbuf(sc, request, sizeof(request), diskinfo,
	    sizeof(struct arc_fw_diskinfo), 1);
	if (error != 0)
		goto out;

#if 0
	bd->bd_channel = diskinfo->scsi_attr.channel;
	bd->bd_target = diskinfo->scsi_attr.target;
	bd->bd_lun = diskinfo->scsi_attr.lun;
#endif
	/*
	 * the firwmare doesnt seem to fill scsi_attr in, so fake it with
	 * the diskid.
	 */
	bd->bd_channel = 0;
	bd->bd_target = raidinfo->device_array[bd->bd_diskid];
	bd->bd_lun = 0;

	bd->bd_status = BIOC_SDONLINE;
	blocks = (u_int64_t)letoh32(diskinfo->capacity2) << 32;
	blocks += (u_int64_t)letoh32(diskinfo->capacity);
	bd->bd_size = blocks * ARC_BLOCKSIZE; /* XXX */

	scsi_strvis(model, diskinfo->model, sizeof(diskinfo->model));
	scsi_strvis(serial, diskinfo->serial, sizeof(diskinfo->serial));
	scsi_strvis(rev, diskinfo->firmware_rev,
	    sizeof(diskinfo->firmware_rev));

	snprintf(bd->bd_vendor, sizeof(bd->bd_vendor), "%s %s",
	    model, rev);
	strlcpy(bd->bd_serial, serial, sizeof(bd->bd_serial));

out:
	arc_unlock(sc);
	free(diskinfo, M_TEMP, sizeof *diskinfo);
	free(raidinfo, M_TEMP, sizeof *raidinfo);
	free(volinfo, M_TEMP, sizeof *volinfo);
	return (error);
}

u_int8_t
arc_msg_cksum(void *cmd, u_int16_t len)
{
	u_int8_t			*buf = cmd;
	u_int8_t			cksum;
	int				i;

	cksum = (u_int8_t)(len >> 8) + (u_int8_t)len;
	for (i = 0; i < len; i++)
		cksum += buf[i];

	return (cksum);
}

int
arc_msgbuf(struct arc_softc *sc, void *wptr, size_t wbuflen, void *rptr,
    size_t rbuflen, int sreadok)
{
	u_int8_t			rwbuf[ARC_RA_IOC_RWBUF_MAXLEN];
	u_int8_t			*wbuf, *rbuf, cksum;
	int				wlen, wdone = 0, rlen, rdone = 0;
	u_int16_t			rlenhdr = 0;
	struct arc_fw_bufhdr		*bufhdr;
	u_int32_t			reg, rwlen, write_ok, read_ok;
	int				error = 0;
#ifdef ARC_DEBUG
	int				i;
#endif

	DPRINTF("%s: arc_msgbuf wbuflen: %d rbuflen: %d\n",
	    DEVNAME(sc), wbuflen, rbuflen);

	switch(sc->sc_adp_type) {
	case ARC_HBA_TYPE_A:
		reg = arc_read(sc, ARC_RA_OUTB_DOORBELL);
		break;
	case ARC_HBA_TYPE_C:
		reg = arc_read(sc, ARC_RC_OUTB_DOORBELL);
		break;
	case ARC_HBA_TYPE_D:
		reg = arc_read(sc, ARC_RD_OUTB_DOORBELL);
		break;
	}
/*	if (reg)
		return (EBUSY); */

	wlen = sizeof(struct arc_fw_bufhdr) + wbuflen + 1; /* 1 for cksum */
	wbuf = malloc(wlen, M_TEMP, M_WAITOK);

	rlen = sizeof(struct arc_fw_bufhdr) + rbuflen + 1; /* 1 for cksum */
	rbuf = malloc(rlen, M_TEMP, M_WAITOK);

	DNPRINTF(ARC_D_DB, "%s: arc_msgbuf wlen: %d rlen: %d\n", DEVNAME(sc),
	    wlen, rlen);

	bufhdr = (struct arc_fw_bufhdr *)wbuf;
	bufhdr->hdr = arc_fw_hdr;
	bufhdr->len = htole16(wbuflen);
	bcopy(wptr, wbuf + sizeof(struct arc_fw_bufhdr), wbuflen);
	wbuf[wlen - 1] = arc_msg_cksum(wptr, wbuflen);

/*	reg = ARC_RA_OUTB_DOORBELL_READ_OK; */
	read_ok = 1;
	do {
		if ((read_ok) && wdone < wlen) {
			bzero(rwbuf, sizeof(rwbuf));
			rwlen = (wlen - wdone) % sizeof(rwbuf);
			bcopy(&wbuf[wdone], rwbuf, rwlen);

#ifdef ARC_DEBUG
			if (arcdebug & ARC_D_DB) {
				printf("%s: write %d:", DEVNAME(sc), rwlen);
				for (i = 0; i < rwlen; i++)
					printf(" 0x%02x", rwbuf[i]);
				printf("\n");
			}
#endif

			switch(sc->sc_adp_type) {
			case ARC_HBA_TYPE_A:
				/* copy the chunk to the hw */
				arc_write(sc, ARC_RA_IOC_WBUF_LEN, rwlen);
				arc_write_region(sc, ARC_RA_IOC_WBUF, rwbuf,
			    	sizeof(rwbuf));

				/* say we have a buffer for the hw */
				arc_write(sc, ARC_RA_INB_DOORBELL,
			    	ARC_RA_INB_DOORBELL_WRITE_OK);
				break;
			case ARC_HBA_TYPE_C:
				/* copy the chunk to the hw */
				arc_write(sc, ARC_RC_MSG_WBUF_LEN, rwlen);
				arc_write_region(sc, ARC_RC_MSG_WBUF, rwbuf,
			    	sizeof(rwbuf));

				/* say we have a buffer for the hw */
				arc_write(sc, ARC_RC_INB_DOORBELL,
			    	ARC_RC_D2I_DATA_WRITE_OK);
				break;
			case ARC_HBA_TYPE_D:
				/* copy the chunk to the hw */
				arc_write(sc, ARC_RD_MSG_WBUF_LEN, rwlen);
				arc_write_region(sc, ARC_RD_MSG_WBUF, rwbuf,
			    	sizeof(rwbuf));

				/* say we have a buffer for the hw */
				arc_write(sc, ARC_RD_INB_DOORBELL,
			    	ARC_RD_D2I_DATA_WRITE_OK);
				break;
			}
			wdone += rwlen;
		}

		if (rptr == NULL)
			goto out;

		switch(sc->sc_adp_type) {
		case ARC_HBA_TYPE_A:
			while ((reg = arc_read(sc, ARC_RA_OUTB_DOORBELL)) == 0)
				arc_wait(sc);
			arc_write(sc, ARC_RA_OUTB_DOORBELL, reg);
			write_ok = reg & ARC_RA_OUTB_DOORBELL_WRITE_OK;
			read_ok = reg & ARC_RA_OUTB_DOORBELL_READ_OK;
			break;
		case ARC_HBA_TYPE_C:
			while ((reg = arc_read(sc, ARC_RC_OUTB_DOORBELL)) == 0)
				arc_wait(sc);
			arc_write(sc, ARC_RC_OUTB_DOORBELL_CLR, reg);
			write_ok = reg & ARC_RC_I2D_DATA_WRITE_OK;
			read_ok = reg & ARC_RC_I2D_DATA_READ_OK;
			break;
		case ARC_HBA_TYPE_D:
			while ((reg = arc_read(sc, ARC_RD_OUTB_DOORBELL)) == 0)
				arc_wait(sc);
			arc_write(sc, ARC_RD_OUTB_DOORBELL_CLR, reg);
			write_ok = reg & ARC_RD_I2D_DATA_WRITE_OK;
			read_ok = reg & ARC_RD_I2D_DATA_READ_OK;
			break;
		}
		DNPRINTF(ARC_D_DB, "%s: reg: 0x%08x\n", DEVNAME(sc), reg);

		if ((write_ok) && rdone < rlen) {
			switch(sc->sc_adp_type) {
			case ARC_HBA_TYPE_A:
				rwlen = arc_read(sc, ARC_RA_IOC_RBUF_LEN);
				break;
			case ARC_HBA_TYPE_C:
				rwlen = arc_read(sc, ARC_RC_MSG_RBUF_LEN);
				break;
			case ARC_HBA_TYPE_D:
				rwlen = arc_read(sc, ARC_RD_MSG_RBUF_LEN);
				break;
			}
			if (rwlen > sizeof(rwbuf)) {
				DNPRINTF(ARC_D_DB, "%s:  rwlen too big\n",
				    DEVNAME(sc));
				error = EIO;
				goto out;
			}

			switch(sc->sc_adp_type) {
			case ARC_HBA_TYPE_A:
				arc_read_region(sc, ARC_RA_IOC_RBUF, rwbuf,
			    	sizeof(rwbuf));
				arc_write(sc, ARC_RA_INB_DOORBELL,
			    	ARC_RA_INB_DOORBELL_READ_OK);
				break;
			case ARC_HBA_TYPE_C:
				arc_read_region(sc, ARC_RC_MSG_RBUF, rwbuf,
			    	sizeof(rwbuf));
				arc_write(sc, ARC_RC_INB_DOORBELL,
			    	ARC_RC_I2D_DATA_READ_OK);
				break;
			case ARC_HBA_TYPE_D:
				arc_read_region(sc, ARC_RD_MSG_RBUF, rwbuf,
			    	sizeof(rwbuf));
				arc_write(sc, ARC_RD_INB_DOORBELL,
			    	ARC_RD_I2D_DATA_READ_OK);
				break;
			}
			if ((rlen > 3) && (rdone == 3)) {
				rlen = *(u_int16_t *)rwbuf;
				rlen = sizeof(struct arc_fw_bufhdr) + rlen + 1;
			}
#ifdef ARC_DEBUG
			printf("%s:  len: %d+%d=%d/%d\n", DEVNAME(sc),
			    rwlen, rdone, rwlen + rdone, rlen);
			if (arcdebug & ARC_D_DB) {
				printf("%s: read:", DEVNAME(sc));
				for (i = 0; i < rwlen; i++)
					printf(" 0x%02x", rwbuf[i]);
				printf("\n");
			}
#endif

			if ((rdone + rwlen) > rlen) {
				DNPRINTF(ARC_D_DB, "%s:  rwbuf too big\n",
				    DEVNAME(sc));
				error = EIO;
				goto out;
			}

			bcopy(rwbuf, &rbuf[rdone], rwlen);
			rdone += rwlen;

			/*
			 * Allow for short reads, by reading the length
			 * value from the response header and shrinking our
			 * idea of size, if required.
			 * This deals with the growth of diskinfo struct from
			 * 128 to 132 bytes.
			 */ 
			if (sreadok && rdone >= sizeof(struct arc_fw_bufhdr) &&
			    rlenhdr == 0) {
				bufhdr = (struct arc_fw_bufhdr *)rbuf;
				rlenhdr = letoh16(bufhdr->len);
				if (rlenhdr < rbuflen) {
					rbuflen = rlenhdr;
					rlen = sizeof(struct arc_fw_bufhdr) +
					    rbuflen + 1; /* 1 for cksum */
				}
			}
		}
	} while (rdone != rlen);

	bufhdr = (struct arc_fw_bufhdr *)rbuf;
	if (memcmp(&bufhdr->hdr, &arc_fw_hdr, sizeof(bufhdr->hdr)) != 0) {
		DNPRINTF(ARC_D_DB, "%s:  rbuf hdr is wrong\n", DEVNAME(sc));
		error = EIO;
		goto out;
	}

	if (bufhdr->len != htole16(rbuflen)) {
		DNPRINTF(ARC_D_DB, "%s:  get_len: 0x%x, req_len: 0x%x\n",
			DEVNAME(sc), bufhdr->len, rbuflen);
	}
	
	bcopy(rbuf + sizeof(struct arc_fw_bufhdr), rptr, bufhdr->len);
	cksum = arc_msg_cksum(rptr, bufhdr->len);
	if (rbuf[rlen - 1] != cksum) {
		DNPRINTF(ARC_D_DB, "%s:  invalid cksum, got :0x%x, calculated:"
			" 0x%x\n", DEVNAME(sc), rbuf[rlen-1], cksum);
		error = EIO;
		goto out;
	}

out:
	free(wbuf, M_TEMP, 0);
	free(rbuf, M_TEMP, 0);

	return (error);
}

void
arc_lock(struct arc_softc *sc)
{
	int				s;
	u_int32_t int_mask;

	rw_enter_write(&sc->sc_lock);
	s = splbio();
	switch(sc->sc_adp_type) {
	case ARC_HBA_TYPE_A:
		int_mask = arc_read(sc, ARC_RA_INTRMASK) | ARC_RA_INTRMASK_DOORBELL;
		arc_write(sc, ARC_RA_INTRMASK, int_mask);
		break;
	case ARC_HBA_TYPE_C:
		int_mask = arc_read(sc, ARC_RC_INTR_MASK) | ARC_RC_INTR_MASK_DOORBELL;
		arc_write(sc, ARC_RC_INTR_MASK, int_mask);
		break;
	case ARC_HBA_TYPE_D:
		int_mask = arc_read(sc, ARC_RD_INTR_ENABLE) & ~ARC_RD_INTR_ENABLE_DOORBELL;
		arc_write(sc, ARC_RD_INTR_ENABLE, int_mask);
		break;
	}
	sc->sc_talking = 1;
	splx(s);
}

void
arc_unlock(struct arc_softc *sc)
{
	int				s;
	u_int32_t int_mask;

	s = splbio();
	sc->sc_talking = 0;
	switch(sc->sc_adp_type) {
	case ARC_HBA_TYPE_A:
		int_mask = arc_read(sc, ARC_RA_INTRMASK) & ~ARC_RA_INTRMASK_DOORBELL;
		arc_write(sc, ARC_RA_INTRMASK, int_mask);
		break;
	case ARC_HBA_TYPE_C:
		int_mask = arc_read(sc, ARC_RC_INTR_MASK) & ~ARC_RC_INTR_MASK_DOORBELL;
		arc_write(sc, ARC_RC_INTR_MASK, int_mask);
		break;
	case ARC_HBA_TYPE_D:
		int_mask = arc_read(sc, ARC_RD_INTR_ENABLE) | ARC_RD_INTR_ENABLE_DOORBELL;
		arc_write(sc, ARC_RD_INTR_ENABLE, int_mask);
		break;
	}
	splx(s);
	rw_exit_write(&sc->sc_lock);
}

void
arc_wait(struct arc_softc *sc)
{
	int				s;
	u_int32_t int_mask;

	s = splbio();
	switch(sc->sc_adp_type) {
	case ARC_HBA_TYPE_A:
		int_mask = arc_read(sc, ARC_RA_INTRMASK) & ~ARC_RA_INTRMASK_DOORBELL;
		arc_write(sc, ARC_RA_INTRMASK, int_mask);
		if (tsleep(sc, PWAIT, "arcdb", hz) == EWOULDBLOCK) {
			int_mask = arc_read(sc, ARC_RA_INTRMASK) | ARC_RA_INTRMASK_DOORBELL;
			arc_write(sc, ARC_RA_INTRMASK, int_mask);
		}
		break;
	case ARC_HBA_TYPE_C:
		int_mask = arc_read(sc, ARC_RC_INTR_MASK) & ~ARC_RC_INTR_MASK_DOORBELL;
		arc_write(sc, ARC_RC_INTR_MASK, int_mask);
		if (tsleep(sc, PWAIT, "arcdb", hz) == EWOULDBLOCK) {
			int_mask = arc_read(sc, ARC_RC_INTR_MASK) | ARC_RC_INTR_MASK_DOORBELL;
			arc_write(sc, ARC_RC_INTR_MASK, int_mask);
		}
		break;
	case ARC_HBA_TYPE_D:
		int_mask = arc_read(sc, ARC_RD_INTR_ENABLE) | ARC_RD_INTR_ENABLE_DOORBELL;
		arc_write(sc, ARC_RD_INTR_ENABLE, int_mask);
		if (tsleep(sc, PWAIT, "arcdb", hz) == EWOULDBLOCK) {
			int_mask = arc_read(sc, ARC_RD_INTR_ENABLE) & ~ARC_RD_INTR_ENABLE_DOORBELL;
			arc_write(sc, ARC_RD_INTR_ENABLE, int_mask);
		}
		break;
	}
	splx(s);
}

#ifndef SMALL_KERNEL
void
arc_create_sensors(void *xat)
{
	struct arc_task		*at = xat;
	struct arc_softc	*sc = at->sc;
	struct bioc_inq		bi;
	struct bioc_vol		bv;
	int			i;

	free(at, M_TEMP, sizeof(*at));

	DPRINTF("%s: arc_create_sensors\n", DEVNAME(sc));
	/*
	 * XXX * this is bollocks. the firmware has garbage coming out of it
	 * so we have to wait a bit for it to finish spewing.
	 */
	tsleep(sc, PWAIT, "arcspew", 2 * hz);

	bzero(&bi, sizeof(bi));
	if (arc_bio_inq(sc, &bi) != 0) {
		printf("%s: unable to query firmware for sensor info\n",
		    DEVNAME(sc));
		return;
	}
	sc->sc_nsensors = bi.bi_novol;

	sc->sc_sensors = mallocarray(sc->sc_nsensors, sizeof(struct ksensor),
	    M_DEVBUF, M_WAITOK | M_ZERO);

	strlcpy(sc->sc_sensordev.xname, DEVNAME(sc),
	    sizeof(sc->sc_sensordev.xname));

	for (i = 0; i < sc->sc_nsensors; i++) {
		bzero(&bv, sizeof(bv));
		bv.bv_volid = i;
		if (arc_bio_vol(sc, &bv) != 0) {
			DPRINTF("%s: arc_bio_vol failed!\n", DEVNAME(sc));
			goto bad;
		}

		sc->sc_sensors[i].type = SENSOR_DRIVE;
		sc->sc_sensors[i].status = SENSOR_S_UNKNOWN;

		strlcpy(sc->sc_sensors[i].desc, bv.bv_dev,
		    sizeof(sc->sc_sensors[i].desc));

		sensor_attach(&sc->sc_sensordev, &sc->sc_sensors[i]);
	}

	if (sensor_task_register(sc, arc_refresh_sensors, 120) == NULL) {
		DPRINTF("%s: sensor_task_register failed!\n", DEVNAME(sc));
		goto bad;
	}

	sensordev_install(&sc->sc_sensordev);

	return;

bad:
	free(sc->sc_sensors, M_DEVBUF,
	    sc->sc_nsensors * sizeof(struct ksensor));
}

void
arc_refresh_sensors(void *arg)
{
	struct arc_softc	*sc = arg;
	struct bioc_vol		bv;
	int			i;

	for (i = 0; i < sc->sc_nsensors; i++) {
		bzero(&bv, sizeof(bv));
		bv.bv_volid = i;
		if (arc_bio_vol(sc, &bv)) {
			sc->sc_sensors[i].flags = SENSOR_FINVALID;
			return;
		}

		switch(bv.bv_status) {
		case BIOC_SVOFFLINE:
			sc->sc_sensors[i].value = SENSOR_DRIVE_FAIL;
			sc->sc_sensors[i].status = SENSOR_S_CRIT;
			break;

		case BIOC_SVDEGRADED:
			sc->sc_sensors[i].value = SENSOR_DRIVE_PFAIL;
			sc->sc_sensors[i].status = SENSOR_S_WARN;
			break;

		case BIOC_SVSCRUB:
		case BIOC_SVONLINE:
			sc->sc_sensors[i].value = SENSOR_DRIVE_ONLINE;
			sc->sc_sensors[i].status = SENSOR_S_OK;
			break;

		case BIOC_SVINVALID:
			/* FALLTRHOUGH */
		default:
			sc->sc_sensors[i].value = 0; /* unknown */
			sc->sc_sensors[i].status = SENSOR_S_UNKNOWN;
		}

	}
}
#endif /* SMALL_KERNEL */
#endif /* NBIO > 0 */

u_int32_t
arc_read(struct arc_softc *sc, bus_size_t r)
{
	u_int32_t			v;

	bus_space_barrier(sc->sc_iot, sc->sc_ioh, r, 4,
	    BUS_SPACE_BARRIER_READ);
	v = bus_space_read_4(sc->sc_iot, sc->sc_ioh, r);

	DNPRINTF(ARC_D_RW, "%s: arc_read 0x%x 0x%08x\n", DEVNAME(sc), r, v);

	return (v);
}

void
arc_read_region(struct arc_softc *sc, bus_size_t r, void *buf, size_t len)
{
	bus_space_barrier(sc->sc_iot, sc->sc_ioh, r, len,
	    BUS_SPACE_BARRIER_READ);
	bus_space_read_raw_region_4(sc->sc_iot, sc->sc_ioh, r, buf, len);
}

void
arc_write(struct arc_softc *sc, bus_size_t r, u_int32_t v)
{
	DNPRINTF(ARC_D_RW, "%s: arc_write 0x%x 0x%08x\n", DEVNAME(sc), r, v);

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, r, v);
	bus_space_barrier(sc->sc_iot, sc->sc_ioh, r, 4,
	    BUS_SPACE_BARRIER_WRITE);
}

void
arc_write_region(struct arc_softc *sc, bus_size_t r, void *buf, size_t len)
{
	bus_space_write_raw_region_4(sc->sc_iot, sc->sc_ioh, r, buf, len);
	bus_space_barrier(sc->sc_iot, sc->sc_ioh, r, len,
	    BUS_SPACE_BARRIER_WRITE);
}

int
arc_wait_eq(struct arc_softc *sc, bus_size_t r, u_int32_t mask,
    u_int32_t target)
{
	int				i;

	DNPRINTF(ARC_D_RW, "%s: arc_wait_eq 0x%x 0x%08x 0x%08x\n",
	    DEVNAME(sc), r, mask, target);

	for (i = 0; i < 10000; i++) {
		if ((arc_read(sc, r) & mask) == target)
			return (0);
		delay(1000);
	}

	return (1);
}

int
arc_wait_ne(struct arc_softc *sc, bus_size_t r, u_int32_t mask,
    u_int32_t target)
{
	int				i;

	DNPRINTF(ARC_D_RW, "%s: arc_wait_ne 0x%x 0x%08x 0x%08x\n",
	    DEVNAME(sc), r, mask, target);

	for (i = 0; i < 10000; i++) {
		if ((arc_read(sc, r) & mask) != target)
			return (0);
		delay(1000);
	}

	return (1);
}

int
arc_msg0(struct arc_softc *sc, u_int32_t m)
{
	switch(sc->sc_adp_type) {
		case ARC_HBA_TYPE_A:
		/* post message */
		arc_write(sc, ARC_RA_INB_MSG0, m);
		/* wait for the fw to do it */
		if (arc_wait_eq(sc, ARC_RA_INTRSTAT, ARC_RA_INTRSTAT_MSG0,
	    	ARC_RA_INTRSTAT_MSG0) != 0)
			return (1);

		/* ack it */
		arc_write(sc, ARC_RA_INTRSTAT, ARC_RA_INTRSTAT_MSG0);
		break;

		case ARC_HBA_TYPE_C:
		/* post message */
		arc_write(sc, ARC_RC_INB_MSGADDR0, m);
		arc_write(sc, ARC_RC_INB_DOORBELL, ARC_RC_D2I_MSG_CMD_DONE);
		/* wait for the fw to do it */
		if (arc_wait_eq(sc, ARC_RC_OUTB_DOORBELL, ARC_RC_I2D_MSG_CMD_DONE,
	    	ARC_RC_I2D_MSG_CMD_DONE) != 0)
			return (1);

		/* ack it */
		arc_write(sc, ARC_RC_OUTB_DOORBELL_CLR, ARC_RC_I2D_MSG_CMD_DONE_CLR);
		break;

		case ARC_HBA_TYPE_D:
		/* post message */
		arc_write(sc, ARC_RD_INB_MSGADDR0, m);
		/* wait for the fw to do it */
		if (arc_wait_eq(sc, ARC_RD_OUTB_DOORBELL, ARC_RD_I2D_MSG_CMD_DONE,
	    	ARC_RD_I2D_MSG_CMD_DONE) != 0)
			return (1);

		/* ack it */
		arc_write(sc, ARC_RD_OUTB_DOORBELL_CLR, ARC_RD_I2D_MSG_CMD_DONE_CLR);
		break;
	}
	return (0);
}

struct arc_dmamem *
arc_dmamem_alloc(struct arc_softc *sc, size_t size)
{
	struct arc_dmamem		*adm;
	int				nsegs;

	adm = malloc(sizeof(*adm), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (adm == NULL)
		return (NULL);

	adm->adm_size = size;

	if (bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &adm->adm_map) != 0)
		goto admfree;

	if (bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE, 0, &adm->adm_seg,
	    1, &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO) != 0)
		goto destroy;

	if (bus_dmamem_map(sc->sc_dmat, &adm->adm_seg, nsegs, size,
	    &adm->adm_kva, BUS_DMA_NOWAIT) != 0)
		goto free;

	if (bus_dmamap_load(sc->sc_dmat, adm->adm_map, adm->adm_kva, size,
	    NULL, BUS_DMA_NOWAIT) != 0)
		goto unmap;

	return (adm);

unmap:
	bus_dmamem_unmap(sc->sc_dmat, adm->adm_kva, size);
free:
	bus_dmamem_free(sc->sc_dmat, &adm->adm_seg, 1);
destroy:
	bus_dmamap_destroy(sc->sc_dmat, adm->adm_map);
admfree:
	free(adm, M_DEVBUF, sizeof *adm);

	return (NULL);
}

void
arc_dmamem_free(struct arc_softc *sc, struct arc_dmamem *adm)
{
	bus_dmamap_unload(sc->sc_dmat, adm->adm_map);
	bus_dmamem_unmap(sc->sc_dmat, adm->adm_kva, adm->adm_size);
	bus_dmamem_free(sc->sc_dmat, &adm->adm_seg, 1);
	bus_dmamap_destroy(sc->sc_dmat, adm->adm_map);
	free(adm, M_DEVBUF, sizeof *adm);
}

int
arc_alloc_ccbs(struct arc_softc *sc)
{
	struct arc_ccb		*ccb;
	u_int8_t			*cmd;
	u_int32_t			i, size, len;

	SLIST_INIT(&sc->sc_ccb_free);
	mtx_init(&sc->sc_ccb_mtx, IPL_BIO);

	size = sizeof(struct arc_ccb) * ARCMSR_MAX_CCB_COUNT;
	sc->sc_ccbs = malloc(size, M_DEVBUF, M_WAITOK | M_ZERO);

	len = ARC_IO_CMD_LEN;
	size = ARCMSR_MAX_CCB_COUNT * len;
	if(sc->sc_adp_type == ARC_HBA_TYPE_D)
		size += sizeof(struct arc_HBD_Msgu);
	sc->sc_requests = arc_dmamem_alloc(sc, size);
	if (sc->sc_requests == NULL) {
		printf("%s: unable to allocate ccb dmamem\n", DEVNAME(sc));
		goto free_ccbs;
	}
	cmd = ARC_DMA_KVA(sc->sc_requests);

	for (i = 0; i < ARCMSR_MAX_CCB_COUNT; i++) {
		ccb = &sc->sc_ccbs[i];

		if (bus_dmamap_create(sc->sc_dmat, MAXPHYS, ARC_SGL_MAXLEN,
		    MAXPHYS, 0, 0, &ccb->ccb_dmamap) != 0) {
			printf("%s: unable to create dmamap for ccb %d\n",
			    DEVNAME(sc), i);
			goto free_maps;
		}

		ccb->ccb_sc = sc;
		ccb->cmd_dma_offset = len * i;

		ccb->ccb_cmd = (struct arc_io_cmd *)&cmd[ccb->cmd_dma_offset];
		ccb->ccb_cmd_post = (ARC_DMA_DVA(sc->sc_requests) + 
		    ccb->cmd_dma_offset);
		if ((sc->sc_adp_type != ARC_HBA_TYPE_C) &&
		    (sc->sc_adp_type != ARC_HBA_TYPE_D))
			ccb->ccb_cmd_post = ccb->ccb_cmd_post >> 
				ARC_RA_POST_QUEUE_ADDR_SHIFT;
		arc_put_ccb(sc, ccb);
	}
	sc->sc_ccb_phys_hi = (u_int64_t)ARC_DMA_DVA(sc->sc_requests) >> 32;
	if(sc->sc_adp_type == ARC_HBA_TYPE_D) {
		sc->postQ_buffer = ARC_DMA_DVA(sc->sc_requests) +
		    (ARCMSR_MAX_CCB_COUNT * len);
		sc->doneQ_buffer = sc->postQ_buffer + (sizeof(struct InBound_SRB) *
		    ARCMSR_MAX_HBD_POSTQUEUE);
		sc->pmu = (struct arc_HBD_Msgu *)&cmd[ARCMSR_MAX_CCB_COUNT * len];
		sc->cmdQ_ptr_offset = ARCMSR_MAX_CCB_COUNT * len;
	}
	scsi_iopool_init(&sc->sc_iopool, sc,
	    (void *(*)(void *))arc_get_ccb,
	    (void (*)(void *, void *))arc_put_ccb);

	return (0);

free_maps:
	while ((ccb = arc_get_ccb(sc)) != NULL)
	    bus_dmamap_destroy(sc->sc_dmat, ccb->ccb_dmamap);
	arc_dmamem_free(sc, sc->sc_requests);

free_ccbs:
	free(sc->sc_ccbs, M_DEVBUF, sizeof(struct arc_ccb) * ARCMSR_MAX_CCB_COUNT);

	return (1);
}

void
arc_free_ccb_src(struct arc_softc *sc)
{
	struct arc_ccb			*ccb;

	while ((ccb = arc_get_ccb(sc)) != NULL)
	    bus_dmamap_destroy(sc->sc_dmat, ccb->ccb_dmamap);
	arc_dmamem_free(sc, sc->sc_requests);
	free(sc->sc_ccbs, M_DEVBUF, 0);
}

struct arc_ccb *
arc_get_ccb(struct arc_softc *sc)
{
	struct arc_ccb			*ccb;

	mtx_enter(&sc->sc_ccb_mtx);
	ccb = SLIST_FIRST(&sc->sc_ccb_free);
	if (ccb != NULL)
		SLIST_REMOVE_HEAD(&sc->sc_ccb_free, ccb_link);
	mtx_leave(&sc->sc_ccb_mtx);

	return (ccb);
}

void
arc_put_ccb(struct arc_softc *sc, struct arc_ccb *ccb)
{
	ccb->ccb_xs = NULL;
	bzero(ccb->ccb_cmd, ARC_IO_CMD_LEN);
	mtx_enter(&sc->sc_ccb_mtx);
	SLIST_INSERT_HEAD(&sc->sc_ccb_free, ccb, ccb_link);
	mtx_leave(&sc->sc_ccb_mtx);
}
@


1.106
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.105 2015/01/12 00:07:55 dlg Exp $ */
d1948 1
a1948 1
	free(sysinfo, M_TEMP, 0);
d2007 2
a2008 2
	free(volinfo, M_TEMP, 0);
	free(sysinfo, M_TEMP, 0);
d2091 1
a2091 1
	free(sysinfo, M_TEMP, 0);
d2171 1
a2171 1
	free(volinfo, M_TEMP, 0);
d2260 3
a2262 3
	free(diskinfo, M_TEMP, 0);
	free(raidinfo, M_TEMP, 0);
	free(volinfo, M_TEMP, 0);
d2667 2
a2668 1
	free(sc->sc_sensors, M_DEVBUF, 0);
d2872 1
a2872 1
	free(adm, M_DEVBUF, 0);
d2884 1
a2884 1
	free(adm, M_DEVBUF, 0);
d2954 1
a2954 1
	free(sc->sc_ccbs, M_DEVBUF, 0);
@


1.105
log
@stash the softc in the memory allocated for setting up a task for
creating sensors.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.104 2014/09/09 20:27:48 dlg Exp $ */
d677 1
a677 1
void			arc_create_sensors(void *, void *);
d837 1
a837 1
		task_set(&at->t, arc_create_sensors, at, NULL);
d2609 1
a2609 1
arc_create_sensors(void *xat, void *null)
@


1.104
log
@replace scsi_task(), which is a wrapper around workqs, with a quick
conversion to tasks.

tested by chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.103 2014/07/13 23:10:23 deraadt Exp $ */
d672 4
d833 2
a834 2
		struct task *t;
		t = malloc(sizeof(*t), M_TEMP, M_WAITOK);
d836 3
a838 2
		task_set(t, arc_create_sensors, sc, t);
		task_add(systq, t);
d2609 1
a2609 1
arc_create_sensors(void *xsc, void *xt)
d2611 2
a2612 2
	struct arc_softc	*sc = xsc;
	struct task		*t = xt;
d2617 1
a2617 1
	free(t, M_TEMP, sizeof(*t));
@


1.103
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.102 2014/07/12 18:48:51 tedu Exp $ */
d32 1
d828 7
a834 3
	if (scsi_task(arc_create_sensors, sc, NULL, 1) != 0)
		printf("%s: unable to schedule arc_create_sensors as a "
		    "scsi task", DEVNAME(sc));
d2604 1
a2604 1
arc_create_sensors(void *xsc, void *arg)
d2607 1
d2611 2
@


1.102
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.101 2014/02/08 16:02:42 chris Exp $ */
d2621 1
a2621 1
	sc->sc_sensors = malloc(sizeof(struct ksensor) * sc->sc_nsensors,
@


1.101
log
@Be conservative about the resources the controller advertises for
"type D" Marvel 9580. From Ching Huang, Areca.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.100 2014/02/08 15:58:01 chris Exp $ */
d1938 1
a1938 1
	free(sysinfo, M_TEMP);
d1997 2
a1998 2
	free(volinfo, M_TEMP);
	free(sysinfo, M_TEMP);
d2081 1
a2081 1
	free(sysinfo, M_TEMP);
d2161 1
a2161 1
	free(volinfo, M_TEMP);
d2250 3
a2252 3
	free(diskinfo, M_TEMP);
	free(raidinfo, M_TEMP);
	free(volinfo, M_TEMP);
d2503 2
a2504 2
	free(wbuf, M_TEMP);
	free(rbuf, M_TEMP);
d2654 1
a2654 1
	free(sc->sc_sensors, M_DEVBUF);
d2858 1
a2858 1
	free(adm, M_DEVBUF);
d2870 1
a2870 1
	free(adm, M_DEVBUF);
d2940 1
a2940 1
	free(sc->sc_ccbs, M_DEVBUF);
d2953 1
a2953 1
	free(sc->sc_ccbs, M_DEVBUF);
@


1.100
log
@Stop disablng/enabling interrupts in the interrupt handler for
"chip type D" which is Marvell 9580. None of the other types do
this and OpenBSD doesn't interrupt during the interrupt routine
anyways. From Ching Huang, Areca.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.99 2014/01/24 02:47:12 dlg Exp $ */
d1733 1
a1733 1
	sc->sc_req_count = letoh32(fwinfo.queue_len);
@


1.99
log
@DVA should be 64 bits, so make sure it is before getting the high bits.

the DVA macro should cast, but i am wary of the effects on all uses of it,
so fixing it in the one place that needs it.

fixes compiles on i386
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.98 2014/01/23 23:47:37 chris Exp $ */
d1021 1
a1021 1
	u_int32_t ob_write_ptr, int_enable;
a1030 3
	int_enable = arc_read(sc, ARC_RD_INTR_ENABLE);
	arc_write(sc, ARC_RD_INTR_ENABLE, ARC_RD_INTR_DISABLE_ALL);

a1085 1
	arc_write(sc, ARC_RD_INTR_ENABLE, int_enable | ARC_RD_INTR_ENABLE_ALL);
@


1.98
log
@Manufacturer driver update for ARC-1880, 1882, 1213, 1223, 1214

Tested on a variety of Intel-IOP cards

ok dlg@@ henning@@ "i'll ok to get this unstuck"
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.97 2013/12/06 21:03:03 deraadt Exp $ */
d2923 1
a2923 1
	sc->sc_ccb_phys_hi = ARC_DMA_DVA(sc->sc_requests) >> 32;
@


1.97
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.96 2013/05/30 16:15:02 deraadt Exp $ */
d19 3
d63 4
a66 1
/* Areca boards using the Intel IOP are Revision A (RA) */
d69 10
d80 1
a80 1
#define ARC_RA_INB_MSG0			0x0010
d90 3
a92 3
#define ARC_RA_INB_MSG1			0x0014
#define ARC_RA_OUTB_ADDR0		0x0018
#define ARC_RA_OUTB_ADDR1		0x001c
d94 1
a94 1
#define ARC_RA_INB_DOORBELL		0x0020
d97 1
a97 1
#define ARC_RA_OUTB_DOORBELL		0x002c
d100 1
a100 1
#define ARC_RA_INTRSTAT			0x0030
d106 2
a107 1
#define ARC_RA_INTRMASK			0x0034
d113 2
a114 1
#define ARC_RA_POST_QUEUE		0x0040
d118 1
a118 1
#define ARC_RA_REPLY_QUEUE		0x0044
d122 1
a122 1
#define ARC_RA_MSGBUF			0x0a00
d124 5
a128 5
#define ARC_RA_IOC_WBUF_LEN		0x0e00
#define ARC_RA_IOC_WBUF			0x0e04
#define ARC_RA_IOC_RBUF_LEN		0x0f00
#define ARC_RA_IOC_RBUF			0x0f04
#define  ARC_RA_IOC_RWBUF_MAXLEN	124 /* for both RBUF and WBUF */
d130 1
a130 1
/* Areca boards using the Marvel IOP are Revision B (RB) */
d135 1
a135 1
#define  ARC_RB_IOP2DRV_DOORBELL_FIRMWARE_OK	(1<<31)
d138 122
d263 1
d272 3
a274 56
} __packed;

struct arc_msg_scsicmd {
	u_int8_t		bus;
	u_int8_t		target;
	u_int8_t		lun;
	u_int8_t		function;

	u_int8_t		cdb_len;
	u_int8_t		sgl_len;
	u_int8_t		flags;
#define ARC_MSG_SCSICMD_FLAG_SGL_BSIZE_512	(1<<0)
#define ARC_MSG_SCSICMD_FLAG_FROM_BIOS		(1<<1)
#define ARC_MSG_SCSICMD_FLAG_WRITE		(1<<2)
#define ARC_MSG_SCSICMD_FLAG_SIMPLEQ		(0x00)
#define ARC_MSG_SCSICMD_FLAG_HEADQ		(0x08)
#define ARC_MSG_SCSICMD_FLAG_ORDERQ		(0x10)
	u_int8_t		reserved;

	u_int32_t		context;
	u_int32_t		data_len;

#define ARC_MSG_CDBLEN				16
	u_int8_t		cdb[ARC_MSG_CDBLEN];

	u_int8_t		status;
#define ARC_MSG_STATUS_SELTIMEOUT		0xf0
#define ARC_MSG_STATUS_ABORTED			0xf1
#define ARC_MSG_STATUS_INIT_FAIL		0xf2
#define ARC_MSG_SENSELEN			15
	u_int8_t		sense_data[ARC_MSG_SENSELEN];

	/* followed by an sgl */
} __packed;

struct arc_sge {
	u_int32_t		sg_hdr;
#define ARC_SGE_64BIT				(1<<24)
	u_int32_t		sg_lo_addr;
	u_int32_t		sg_hi_addr;
} __packed;

#define ARC_MAX_TARGET		16
#define ARC_MAX_LUN		8
#define ARC_MAX_IOCMDLEN	512
#define ARC_BLOCKSIZE		512

/* the firmware deals with up to 256 or 512 byte command frames. */
/* sizeof(struct arc_msg_scsicmd) + (sizeof(struct arc_sge) * 38) == 508 */
#define ARC_SGL_MAXLEN		38
/* sizeof(struct arc_msg_scsicmd) + (sizeof(struct arc_sge) * 17) == 252 */
#define ARC_SGL_256LEN		17

struct arc_io_cmd {
	struct arc_msg_scsicmd	cmd;
	struct arc_sge		sgl[ARC_SGL_MAXLEN];
d299 2
a300 2
#define  ARC_FW_SET_ALARM_DISABLE		0x00
#define  ARC_FW_SET_ALARM_ENABLE		0x01
d305 2
a306 2
#define  ARC_FW_BLINK_ENABLE			0x00
#define  ARC_FW_BLINK_DISABLE			0x01
d318 1
a318 1
	u_int8_t		channel;// channel for SCSI target (0/1)
d340 3
a342 1
	u_int8_t		reserved2[12];
d378 6
a383 1
	u_int8_t		reserved[5];
d396 2
a397 2
	u_int8_t		drive_select;
	u_int8_t		raid_number; // 0xff unowned
d399 1
a399 1
	u_int8_t		reserved[44];
a423 1

a440 6
int			arc_match(struct device *, void *, void *);
void			arc_attach(struct device *, struct device *, void *);
int			arc_detach(struct device *, int);
int			arc_activate(struct device *, int);
int			arc_intr(void *);

d445 97
d557 1
a557 1
	int			sc_req_count;
d575 6
d584 6
a589 3
struct cfattach arc_ca = {
	sizeof(struct arc_softc), arc_match, arc_attach, arc_detach,
	arc_activate
d591 3
d595 8
a602 3
struct cfdriver arc_cd = {
	NULL, "arc", DV_DULL
};
d605 2
a606 6
void			arc_scsi_cmd(struct scsi_xfer *);
void			arc_minphys(struct buf *, struct scsi_link *);

struct scsi_adapter arc_switch = {
	arc_scsi_cmd, arc_minphys, NULL, NULL, NULL
};
d609 2
a610 2
u_int32_t		arc_read(struct arc_softc *, bus_size_t);
void			arc_read_region(struct arc_softc *, bus_size_t,
d612 2
a613 2
void			arc_write(struct arc_softc *, bus_size_t, u_int32_t);
void			arc_write_region(struct arc_softc *, bus_size_t,
a620 14
#define arc_push(_s, _r)	arc_write((_s), ARC_RA_POST_QUEUE, (_r))
#define arc_pop(_s)		arc_read((_s), ARC_RA_REPLY_QUEUE)

/* wrap up the bus_dma api */
struct arc_dmamem {
	bus_dmamap_t		adm_map;
	bus_dma_segment_t	adm_seg;
	size_t			adm_size;
	caddr_t			adm_kva;
};
#define ARC_DMA_MAP(_adm)	((_adm)->adm_map)
#define ARC_DMA_DVA(_adm)	((_adm)->adm_map->dm_segs[0].ds_addr)
#define ARC_DMA_KVA(_adm)	((void *)(_adm)->adm_kva)

d622 1
a622 1
void			arc_dmamem_free(struct arc_softc *,
d624 1
a624 15

/* stuff to manage a scsi command */
struct arc_ccb {
	struct arc_softc	*ccb_sc;
	int			ccb_id;

	struct scsi_xfer	*ccb_xs;

	bus_dmamap_t		ccb_dmamap;
	bus_addr_t		ccb_offset;
	struct arc_io_cmd	*ccb_cmd;
	u_int32_t		ccb_cmd_post;

	SLIST_ENTRY(arc_ccb)	ccb_link;
};
d627 2
a628 2
struct arc_ccb		*arc_get_ccb(struct arc_softc *);
void			arc_put_ccb(struct arc_softc *, struct arc_ccb *);
d632 1
a632 1
void			arc_scsi_cmd_done(struct arc_softc *, struct arc_ccb *,
a634 5
/* real stuff for dealing with the hardware */
struct arc_iop {
	int			(*iop_query_firmware)(struct arc_softc *);
};

d637 10
a646 3
void			arc_unmap_pci_resources(struct arc_softc *);
int			arc_intel_query_firmware(struct arc_softc *);
int			arc_marvell_query_firmware(struct arc_softc *);
d650 4
a653 4
void			arc_lock(struct arc_softc *);
void			arc_unlock(struct arc_softc *);
void			arc_wait(struct arc_softc *);
u_int8_t		arc_msg_cksum(void *, u_int16_t);
d677 18
d696 1
a696 1
	arc_intel_query_firmware
d700 9
a708 1
	arc_marvell_query_firmware
d728 1
d737 2
a738 1
	{ PCI_VENDOR_ARECA, PCI_PRODUCT_ARECA_ARC1681, &arc_intel }
d776 8
a783 1

d789 2
a790 2
	if (sc->sc_iop->iop_query_firmware(sc) != 0) {
		/* error message printed by arc_query_firmware */
d794 4
a797 2
	if (arc_alloc_ccbs(sc) != 0) {
		/* error message printed by arc_alloc_ccbs */
d815 1
a815 2
	arc_write(sc, ARC_RA_INTRMASK,
	    ~(ARC_RA_INTRMASK_POSTQUEUE|ARC_RA_INTRSTAT_DOORBELL));
d860 2
a861 5
	if (arc_msg0(sc, ARC_RA_INB_MSG0_STOP_BGRB) != 0)
		printf("%s: timeout waiting to stop bg rebuild\n", DEVNAME(sc));

	if (arc_msg0(sc, ARC_RA_INB_MSG0_FLUSH_CACHE) != 0)
		printf("%s: timeout waiting to flush cache\n", DEVNAME(sc));
d867 1
a867 1
arc_intr(void *arg)
d873 1
a873 1
	u_int32_t			reg, intrstat;
d877 2
a878 1
	intrstat &= ARC_RA_INTRSTAT_POSTQUEUE | ARC_RA_INTRSTAT_DOORBELL;
d898 137
a1034 1
	while ((reg = arc_pop(sc)) != 0xffffffff) {
d1036 28
a1063 4
		cmd = (struct arc_io_cmd *)(kva +
		    ((reg << ARC_RA_REPLY_QUEUE_ADDR_SHIFT) -
		    (u_int32_t)ARC_DMA_DVA(sc->sc_requests)));
		ccb = &sc->sc_ccbs[letoh32(cmd->cmd.context)];
d1065 3
d1069 1
a1069 1
		    ccb->ccb_offset, ARC_MAX_IOCMDLEN,
d1071 22
d1094 16
a1109 1
		arc_scsi_cmd_done(sc, ccb, reg);
a1110 1

d1121 1
a1121 1
	u_int32_t			reg;
d1123 4
d1149 1
a1149 1

d1161 1
a1161 1
		reg |= ARC_RA_POST_QUEUE_BIGFRAME;
a1163 1
	cmd->context = htole32(ccb->ccb_id);
d1170 1
a1170 1
	    ccb->ccb_offset, ARC_MAX_IOCMDLEN,
d1174 42
a1215 1
	arc_push(sc, reg);
d1234 1
d1237 3
d1241 1
a1241 1

d1253 1
a1253 1
		sge->sg_hdr = htole32(ARC_SGE_64BIT | dmap->dm_segs[i].ds_len);
d1258 4
d1271 1
a1271 1
arc_scsi_cmd_done(struct arc_softc *sc, struct arc_ccb *ccb, u_int32_t reg)
d1283 1
a1283 1
	if (reg & ARC_RA_REPLY_QUEUE_ERR) {
d1285 7
d1332 6
a1337 2
	u_int32_t			reg;

d1339 27
a1365 1
		reg = arc_pop(sc);
d1367 1
a1367 1
			if (timeout-- == 0)
d1369 1
a1369 1

d1374 13
a1386 4
		cmd = (struct arc_io_cmd *)(kva +
		    ((reg << ARC_RA_REPLY_QUEUE_ADDR_SHIFT) -
		    ARC_DMA_DVA(sc->sc_requests)));
		ccb = &sc->sc_ccbs[letoh32(cmd->cmd.context)];
d1389 1
a1389 1
		    ccb->ccb_offset, ARC_MAX_IOCMDLEN,
d1392 2
a1393 1
		arc_scsi_cmd_done(sc, ccb, reg);
d1395 1
d1397 1
a1397 1
	return (0);
d1408 50
d1468 28
a1495 5
	memtype = pci_mapreg_type(sc->sc_pc, sc->sc_tag, ARC_RA_PCI_BAR);
	if (pci_mapreg_map(pa, ARC_RA_PCI_BAR, memtype, 0, &sc->sc_iot,
	    &sc->sc_ioh, NULL, &sc->sc_ios, 0) != 0) {
		printf(": unable to map system interface register\n");
		return(1);
d1498 2
d1529 1
a1529 1
arc_intel_query_firmware(struct arc_softc *sc)
d1533 1
a1564 1
#ifdef ARC_DEBUG
a1568 1
#endif /* ARC_DEBUG */
d1571 1
a1571 1
	DNPRINTF(ARC_D_INIT, "%s: model: \"%s\"\n", DEVNAME(sc), string);
d1587 5
d1600 1
a1600 1
arc_marvell_query_firmware(struct arc_softc *sc)
d1612 221
d1840 1
d1878 1
d1955 1
d1957 1
d1966 2
a1967 1
	if (error != 0)
d1969 1
d1978 2
a1979 1
		if (error != 0)
d1981 1
d1989 1
a1989 1
		    volinfo->raid_level != ARC_FW_VOL_RAIDLEVEL_PASSTHRU)
d1991 3
d1998 1
d2009 1
a2009 1
	u_int8_t			 request[5];
d2013 1
d2029 1
a2029 1
	bcopy(&mask, &request[2], 3);
d2031 1
d2033 1
d2048 1
d2099 1
d2182 1
a2273 1

d2279 1
a2279 1
	u_int8_t			*wbuf, *rbuf;
d2283 1
a2283 1
	u_int32_t			reg, rwlen;
d2289 1
a2289 1
	DNPRINTF(ARC_D_DB, "%s: arc_msgbuf wbuflen: %d rbuflen: %d\n",
d2292 13
a2304 2
	if (arc_read(sc, ARC_RA_OUTB_DOORBELL) != 0)
		return (EBUSY);
d2321 2
a2322 2
	reg = ARC_RA_OUTB_DOORBELL_READ_OK;

d2324 1
a2324 1
		if ((reg & ARC_RA_OUTB_DOORBELL_READ_OK) && wdone < wlen) {
d2338 6
a2343 8
			/* copy the chunk to the hw */
			arc_write(sc, ARC_RA_IOC_WBUF_LEN, rwlen);
			arc_write_region(sc, ARC_RA_IOC_WBUF, rwbuf,
			    sizeof(rwbuf));

			/* say we have a buffer for the hw */
			arc_write(sc, ARC_RA_INB_DOORBELL,
			    ARC_RA_INB_DOORBELL_WRITE_OK);
d2345 25
d2376 23
a2398 4
		while ((reg = arc_read(sc, ARC_RA_OUTB_DOORBELL)) == 0)
			arc_wait(sc);
		arc_write(sc, ARC_RA_OUTB_DOORBELL, reg);

d2401 12
a2412 2
		if ((reg & ARC_RA_OUTB_DOORBELL_WRITE_OK) && rdone < rlen) {
			rwlen = arc_read(sc, ARC_RA_IOC_RBUF_LEN);
d2420 24
a2443 6
			arc_read_region(sc, ARC_RA_IOC_RBUF, rwbuf,
			    sizeof(rwbuf));

			arc_write(sc, ARC_RA_INB_DOORBELL,
			    ARC_RA_INB_DOORBELL_READ_OK);

d2486 1
a2486 2
	if (memcmp(&bufhdr->hdr, &arc_fw_hdr, sizeof(bufhdr->hdr)) != 0 ||
	    bufhdr->len != htole16(rbuflen)) {
d2492 10
a2501 4
	bcopy(rbuf + sizeof(struct arc_fw_bufhdr), rptr, rbuflen);

	if (rbuf[rlen - 1] != arc_msg_cksum(rptr, rbuflen)) {
		DNPRINTF(ARC_D_DB, "%s:  invalid cksum\n", DEVNAME(sc));
d2517 1
d2521 14
a2534 1
	arc_write(sc, ARC_RA_INTRMASK, ~ARC_RA_INTRMASK_POSTQUEUE);
d2543 1
d2547 14
a2560 2
	arc_write(sc, ARC_RA_INTRMASK,
	    ~(ARC_RA_INTRMASK_POSTQUEUE|ARC_RA_INTRMASK_DOORBELL));
d2569 1
d2572 26
a2597 4
	arc_write(sc, ARC_RA_INTRMASK,
	    ~(ARC_RA_INTRMASK_POSTQUEUE|ARC_RA_INTRMASK_DOORBELL));
	if (tsleep(sc, PWAIT, "arcdb", hz) == EWOULDBLOCK)
		arc_write(sc, ARC_RA_INTRMASK, ~ARC_RA_INTRMASK_POSTQUEUE);
d2610 1
d2634 2
a2635 1
		if (arc_bio_vol(sc, &bv) != 0)
d2637 1
d2648 2
a2649 1
	if (sensor_task_register(sc, arc_refresh_sensors, 120) == NULL)
d2651 1
d2784 25
a2808 6
	/* post message */
	arc_write(sc, ARC_RA_INB_MSG0, m);
	/* wait for the fw to do it */
	if (arc_wait_eq(sc, ARC_RA_INTRSTAT, ARC_RA_INTRSTAT_MSG0,
	    ARC_RA_INTRSTAT_MSG0) != 0)
		return (1);
d2810 7
a2816 2
	/* ack it */
	arc_write(sc, ARC_RA_INTRSTAT, ARC_RA_INTRSTAT_MSG0);
d2818 4
d2880 1
a2880 1
	struct arc_ccb			*ccb;
d2882 1
a2882 1
	int				i;
d2887 2
a2888 2
	sc->sc_ccbs = malloc(sizeof(struct arc_ccb) * sc->sc_req_count,
	    M_DEVBUF, M_WAITOK | M_ZERO);
d2890 5
a2894 2
	sc->sc_requests = arc_dmamem_alloc(sc,
	    ARC_MAX_IOCMDLEN * sc->sc_req_count);
d2901 1
a2901 1
	for (i = 0; i < sc->sc_req_count; i++) {
d2912 1
a2912 6
		ccb->ccb_id = i;
		ccb->ccb_offset = ARC_MAX_IOCMDLEN * i;

		ccb->ccb_cmd = (struct arc_io_cmd *)&cmd[ccb->ccb_offset];
		ccb->ccb_cmd_post = (ARC_DMA_DVA(sc->sc_requests) +
		    ccb->ccb_offset) >> ARC_RA_POST_QUEUE_ADDR_SHIFT;
d2914 7
d2923 9
a2931 1

d2949 11
d2978 1
a2978 1
	bzero(ccb->ccb_cmd, ARC_MAX_IOCMDLEN);
@


1.96
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.95 2011/07/17 22:46:48 matthew Exp $ */
d633 1
a633 1
	int ret = 0;
a635 6
	case DVACT_QUIESCE:
		ret = config_activate_children(self, act);
		break;
	case DVACT_SUSPEND:
		ret = config_activate_children(self, act);
		break;
d637 1
a637 1
		ret = config_activate_children(self, act);
d640 2
a641 2
	case DVACT_RESUME:
		ret = config_activate_children(self, act);
d644 1
a644 1
	return (ret);	
@


1.95
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.94 2011/07/08 22:09:27 matthew Exp $ */
d350 1
a350 1
void			arc_shutdown(void *);
a371 2
	void			*sc_shutdownhook;

d394 2
a395 1
	sizeof(struct arc_softc), arc_match, arc_attach, arc_detach
a591 4
	sc->sc_shutdownhook = shutdownhook_establish(arc_shutdown, sc);
	if (sc->sc_shutdownhook == NULL)
		panic("unable to establish arc shutdownhook");

d631 23
a657 2
	shutdownhook_disestablish(sc->sc_shutdownhook);

a664 12
}

void
arc_shutdown(void *xsc)
{
	struct arc_softc		*sc = xsc;

	if (arc_msg0(sc, ARC_RA_INB_MSG0_STOP_BGRB) != 0)
		printf("%s: timeout waiting to stop bg rebuild\n", DEVNAME(sc));

	if (arc_msg0(sc, ARC_RA_INB_MSG0_FLUSH_CACHE) != 0)
		printf("%s: timeout waiting to flush cache\n", DEVNAME(sc));
@


1.94
log
@First batch of converting SCSI HBAs from setting saa_targets and
saa_luns instead of adapter_buswidth and luns in the prototype link.

ok dlg@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.93 2011/04/20 07:13:51 claudio Exp $ */
d600 1
a605 1
	saa.saa_targets = ARC_MAX_TARGET;
@


1.93
log
@Interrupt handlers should only return 1 if they did some work.  The
intrstat on arc may have other status bits set which are masked as
interrupt cause and not handled by our driver. So the intrstat ==
0 check does not work reliably. It is better to do use a variable
that is set to 1 when work is done and the cause is cleared.
This makes arc(4) behave on systems where interrupts are shared.
OK deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.92 2010/09/07 16:21:44 deraadt Exp $ */
a599 1
	sc->sc_link.adapter_buswidth = ARC_MAX_TARGET;
d605 1
@


1.92
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.91 2010/08/07 03:50:02 krw Exp $ */
d671 1
a673 2
	if (intrstat == 0x0)
		return (0);
d678 1
d695 1
d708 1
a708 1
	return (1);
@


1.91
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.90 2010/07/18 12:49:10 mk Exp $ */
d595 1
a595 1
		panic("unable to establish arc powerhook");
@


1.90
log
@Give each device on the bus full openings.

Tested by me on an ARC-1210 on both single and multi volume
configurations.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.89 2010/07/02 20:54:36 mk Exp $ */
d616 1
a616 1
		panic("%s: bioctl registration failed\n", DEVNAME(sc));
@


1.89
log
@Provide an iopool in arc(4).

ok dlg matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.88 2010/07/02 20:52:14 mk Exp $ */
d601 1
a601 1
	sc->sc_link.openings = sc->sc_req_count / ARC_MAX_TARGET;
@


1.88
log
@Protect the ccb free list with a mutex rather than splbio().
Requested by dlg when reviewing a different diff.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.87 2010/07/01 03:20:38 matthew Exp $ */
d381 1
d602 1
d730 1
a730 7
	ccb = arc_get_ccb(sc);
	if (ccb == NULL) {
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

a734 1
		arc_put_ccb(sc, ccb);
a859 1
	arc_put_ccb(sc, ccb);
d1928 4
@


1.87
log
@Change scsibus(4)'s scsi_link array to an SLIST to save memory on
sparsely populated buses.

ok dlg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.86 2010/06/28 18:40:51 mk Exp $ */
d26 1
d379 1
a727 1
	s = splbio();
a728 1
	splx(s);
a738 1
		s = splbio();
a740 1
		splx(s);
d1901 1
d1953 1
d1957 1
d1967 1
d1969 1
@


1.86
log
@Use an SLIST instead of a TAILQ for the ccb free list.  Order doesn't
matter, an SLIST is smaller, and the first element is more likely to be
in cache.  Previously we took from the head and returned to the tail,
which meant that we were using the ccb that was the least recently used
one which also means it has the smallest chance of being in cache.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.85 2010/06/28 18:31:02 krw Exp $ */
d1344 2
a1345 2
	sc_link = sc->sc_scsibus->sc_link[volinfo->scsi_attr.target]
	    [volinfo->scsi_attr.lun];
@


1.85
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.84 2010/05/20 00:55:17 krw Exp $ */
d354 1
a354 1
TAILQ_HEAD(arc_ccb_list, arc_ccb);
d451 1
a451 1
	TAILQ_ENTRY(arc_ccb)	ccb_link;
d1902 1
a1902 1
	TAILQ_INIT(&sc->sc_ccb_free);
d1954 1
a1954 1
	ccb = TAILQ_FIRST(&sc->sc_ccb_free);
d1956 1
a1956 1
		TAILQ_REMOVE(&sc->sc_ccb_free, ccb, ccb_link);
d1966 1
a1966 1
	TAILQ_INSERT_TAIL(&sc->sc_ccb_free, ccb, ccb_link);
@


1.84
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.83 2010/05/19 15:27:35 oga Exp $ */
a407 4
struct scsi_device arc_dev = {
	NULL, NULL, NULL, NULL
};

a593 1
	sc->sc_link.device = &arc_dev;
@


1.83
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.82 2010/04/08 00:23:53 tedu Exp $ */
a726 1
		s = splbio();
a727 1
		splx(s);
a735 1
		s = splbio();
a736 1
		splx(s);
@


1.82
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.81 2010/03/23 01:57:20 krw Exp $ */
d1869 1
a1869 1
	    1, &nsegs, BUS_DMA_NOWAIT) != 0)
a1878 2

	bzero(adm->adm_kva, size);
@


1.81
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.80 2010/01/09 23:15:06 krw Exp $ */
a26 1
#include <sys/proc.h>
@


1.80
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.79 2009/08/13 11:10:27 dlg Exp $ */
d402 1
a402 1
int			arc_scsi_cmd(struct scsi_xfer *);
d712 1
a712 1
int
a719 1
	int				rv = SUCCESSFULLY_QUEUED;
d731 1
a731 1
		return (COMPLETE);
d742 1
a742 1
		return (COMPLETE);
d753 1
a753 1
		return (COMPLETE);
a785 1
		rv = COMPLETE;
a791 2

	return (rv);
@


1.79
log
@set ITSDONE on the xs before calling scsi_done()
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.77 2008/07/17 13:16:29 jsg Exp $ */
a728 1
		xs->flags |= ITSDONE;
a739 1
		xs->flags |= ITSDONE;
a749 1
		xs->flags |= ITSDONE;
a789 1
			xs->flags |= ITSDONE;
a846 3

	/* timeout_del */
	xs->flags |= ITSDONE;
@


1.78
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d729 1
d741 1
d752 1
d793 1
@


1.77
log
@Increase the size of the diskinfo struct, which has grown
4 bytes in the new firmware.

To allow this to work on older firmwares add a "short read allowed"
flag to arc_msgbuf(), which will allow short reads by getting
the read length from the header of the response the firmware sends.

Only set the flag on the arc_msgbuf() call that deals with the diskinfo
struct for now.

Discussed with and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.76 2008/06/27 12:04:29 jsg Exp $ */
d403 1
a403 1
void			arc_minphys(struct buf *);
d922 1
a922 1
arc_minphys(struct buf *bp)
@


1.76
log
@Hook up the blinkenleds.

Lets cards like the 1261ML with SGPIO sideband on Mini SAS,
control locator LEDs through bioctl.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.75 2007/11/05 01:18:21 dlg Exp $ */
d304 1
a304 1
	u_int8_t		reserved[40];
d486 1
a486 1
			    void *, size_t);
d1123 1
a1123 1
	error = arc_msgbuf(sc, request, len, reply, sizeof(reply));
d1152 1
a1152 1
	    sysinfo, sizeof(struct arc_fw_sysinfo));
d1182 1
a1182 1
	    sizeof(struct arc_fw_sysinfo));
d1192 1
a1192 1
		    sizeof(struct arc_fw_volinfo));
d1239 1
a1239 1
	error = arc_msgbuf(sc, request, sizeof(request), NULL, 0);
d1258 1
a1258 1
	    sizeof(struct arc_fw_sysinfo));
d1268 1
a1268 1
		    sizeof(struct arc_fw_volinfo));
d1399 1
a1399 1
	    sizeof(struct arc_fw_raidinfo));
d1424 1
a1424 1
	    sizeof(struct arc_fw_diskinfo));
d1480 1
a1480 1
    size_t rbuflen)
d1485 1
d1587 18
@


1.75
log
@wait for the marvell firmware to become ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.74 2007/11/04 11:07:36 dlg Exp $ */
d216 3
d388 2
d496 1
d1078 4
d1216 31
d1541 3
@


1.74
log
@start providing function pointers to differentiate between the intel and
marvell boards.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.73 2007/11/04 10:13:05 dlg Exp $ */
d112 8
d1038 7
@


1.73
log
@very initial foundation for splitting things up to support both the
traditional intel iop and the new marvell one used on the ARC-1200 rev B.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.72 2007/11/04 08:16:17 dlg Exp $ */
d342 1
d348 1
d456 4
d463 2
a464 2
int			arc_query_firmware(struct arc_softc *);

a493 4
struct arc_iop {
	void			*a;
};

d495 1
a495 1
	NULL
d499 1
a499 1
	NULL
d564 1
a564 4
	if (arc_match_board(pa)->ab_iop == &arc_marvell) {
		printf(": unsupported IOP\n");
		return;
	}
d571 1
a571 1
	if (arc_query_firmware(sc) != 0) {
d961 1
a961 1
arc_query_firmware(struct arc_softc *sc)
d1025 6
@


1.72
log
@the 1200 and 1202 shoudl work fine too.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.71 2007/10/30 13:22:57 dlg Exp $ */
a59 20
static const struct pci_matchid arc_devices[] = {
	{ PCI_VENDOR_ARECA,	PCI_PRODUCT_ARECA_ARC1110 },
	{ PCI_VENDOR_ARECA,	PCI_PRODUCT_ARECA_ARC1120 },
	{ PCI_VENDOR_ARECA,	PCI_PRODUCT_ARECA_ARC1130 },
	{ PCI_VENDOR_ARECA,	PCI_PRODUCT_ARECA_ARC1160 },
	{ PCI_VENDOR_ARECA,	PCI_PRODUCT_ARECA_ARC1170 },
	{ PCI_VENDOR_ARECA,	PCI_PRODUCT_ARECA_ARC1200 },
	{ PCI_VENDOR_ARECA,	PCI_PRODUCT_ARECA_ARC1202 },
	{ PCI_VENDOR_ARECA,	PCI_PRODUCT_ARECA_ARC1210 },
	{ PCI_VENDOR_ARECA,	PCI_PRODUCT_ARECA_ARC1220 },
	{ PCI_VENDOR_ARECA,	PCI_PRODUCT_ARECA_ARC1230 },
	{ PCI_VENDOR_ARECA,	PCI_PRODUCT_ARECA_ARC1260 },
	{ PCI_VENDOR_ARECA,	PCI_PRODUCT_ARECA_ARC1270 },
	{ PCI_VENDOR_ARECA,	PCI_PRODUCT_ARECA_ARC1280 },
	{ PCI_VENDOR_ARECA,	PCI_PRODUCT_ARECA_ARC1380 },
	{ PCI_VENDOR_ARECA,	PCI_PRODUCT_ARECA_ARC1381 },
	{ PCI_VENDOR_ARECA,	PCI_PRODUCT_ARECA_ARC1680 },
	{ PCI_VENDOR_ARECA,	PCI_PRODUCT_ARECA_ARC1681 }
};

d488 57
d548 1
a548 2
	return (pci_matchbyid((struct pci_attach_args *)aux, arc_devices,
	    sizeof(arc_devices) / sizeof(arc_devices[0])));
d561 5
@


1.71
log
@shrink the intr establish code a bit. all that intrstr handling is cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.70 2007/10/30 12:43:47 dlg Exp $ */
d66 2
@


1.70
log
@the marvell based boards have difference registers to the current intel iop
based ones. this renames the register defines for the revision A boards
(the intel ones) to ARC_RA instead of ARC_REG so we can differentiate them
from the ARC_RB registers for revision B that are coming.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.69 2007/10/30 12:32:46 dlg Exp $ */
a877 1
	const char			*intrstr;
a893 1
	intrstr = pci_intr_string(pa->pa_pc, ih);
d897 1
a897 3
		printf(": unable to map interrupt%s%s\n",
		    intrstr == NULL ? "" : " at ",
		    intrstr == NULL ? "" : intrstr);
d900 1
a900 1
	printf(": %s\n", intrstr);
@


1.69
log
@if we cant query the firmware or allocate ccbs then clean up the pci
mappings. without this a problem board can cause a panic when the interrupt
handler touches unallocated memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.68 2007/10/27 03:28:27 dlg Exp $ */
d78 1
a78 1
#define ARC_PCI_BAR			PCI_MAPREG_START
d80 49
a128 47
#define ARC_REG_INB_MSG0		0x0010
#define  ARC_REG_INB_MSG0_NOP			(0x00000000)
#define  ARC_REG_INB_MSG0_GET_CONFIG		(0x00000001)
#define  ARC_REG_INB_MSG0_SET_CONFIG		(0x00000002)
#define  ARC_REG_INB_MSG0_ABORT_CMD		(0x00000003)
#define  ARC_REG_INB_MSG0_STOP_BGRB		(0x00000004)
#define  ARC_REG_INB_MSG0_FLUSH_CACHE		(0x00000005)
#define  ARC_REG_INB_MSG0_START_BGRB		(0x00000006)
#define  ARC_REG_INB_MSG0_CHK331PENDING		(0x00000007)
#define  ARC_REG_INB_MSG0_SYNC_TIMER		(0x00000008)
#define ARC_REG_INB_MSG1		0x0014
#define ARC_REG_OUTB_ADDR0		0x0018
#define ARC_REG_OUTB_ADDR1		0x001c
#define  ARC_REG_OUTB_ADDR1_FIRMWARE_OK		(1<<31)
#define ARC_REG_INB_DOORBELL		0x0020
#define  ARC_REG_INB_DOORBELL_WRITE_OK		(1<<0)
#define  ARC_REG_INB_DOORBELL_READ_OK		(1<<1)
#define ARC_REG_OUTB_DOORBELL		0x002c
#define  ARC_REG_OUTB_DOORBELL_WRITE_OK		(1<<0)
#define  ARC_REG_OUTB_DOORBELL_READ_OK		(1<<1)
#define ARC_REG_INTRSTAT		0x0030
#define  ARC_REG_INTRSTAT_MSG0			(1<<0)
#define  ARC_REG_INTRSTAT_MSG1			(1<<1)
#define  ARC_REG_INTRSTAT_DOORBELL		(1<<2)
#define  ARC_REG_INTRSTAT_POSTQUEUE		(1<<3)
#define  ARC_REG_INTRSTAT_PCI			(1<<4)
#define ARC_REG_INTRMASK		0x0034
#define  ARC_REG_INTRMASK_MSG0			(1<<0)
#define  ARC_REG_INTRMASK_MSG1			(1<<1)
#define  ARC_REG_INTRMASK_DOORBELL		(1<<2)
#define  ARC_REG_INTRMASK_POSTQUEUE		(1<<3)
#define  ARC_REG_INTRMASK_PCI			(1<<4)
#define ARC_REG_POST_QUEUE		0x0040
#define  ARC_REG_POST_QUEUE_ADDR_SHIFT		5
#define  ARC_REG_POST_QUEUE_IAMBIOS		(1<<30)
#define  ARC_REG_POST_QUEUE_BIGFRAME		(1<<31)
#define ARC_REG_REPLY_QUEUE		0x0044
#define  ARC_REG_REPLY_QUEUE_ADDR_SHIFT		5
#define  ARC_REG_REPLY_QUEUE_ERR		(1<<28)
#define  ARC_REG_REPLY_QUEUE_IAMBIOS		(1<<30)
#define ARC_REG_MSGBUF			0x0a00
#define  ARC_REG_MSGBUF_LEN		1024
#define ARC_REG_IOC_WBUF_LEN		0x0e00
#define ARC_REG_IOC_WBUF		0x0e04
#define ARC_REG_IOC_RBUF_LEN		0x0f00
#define ARC_REG_IOC_RBUF		0x0f04
#define  ARC_REG_IOC_RWBUF_MAXLEN	124 /* for both RBUF and WBUF */
d429 2
a430 2
#define arc_push(_s, _r)	arc_write((_s), ARC_REG_POST_QUEUE, (_r))
#define arc_pop(_s)		arc_read((_s), ARC_REG_REPLY_QUEUE)
d557 2
a558 2
	arc_write(sc, ARC_REG_INTRMASK,
	    ~(ARC_REG_INTRMASK_POSTQUEUE|ARC_REG_INTRSTAT_DOORBELL));
d588 1
a588 1
	if (arc_msg0(sc, ARC_REG_INB_MSG0_STOP_BGRB) != 0)
d591 1
a591 1
	if (arc_msg0(sc, ARC_REG_INB_MSG0_FLUSH_CACHE) != 0)
d602 1
a602 1
	if (arc_msg0(sc, ARC_REG_INB_MSG0_STOP_BGRB) != 0)
d605 1
a605 1
	if (arc_msg0(sc, ARC_REG_INB_MSG0_FLUSH_CACHE) != 0)
d618 1
a618 1
	intrstat = arc_read(sc, ARC_REG_INTRSTAT);
d621 2
a622 2
	intrstat &= ARC_REG_INTRSTAT_POSTQUEUE | ARC_REG_INTRSTAT_DOORBELL;
	arc_write(sc, ARC_REG_INTRSTAT, intrstat);
d624 1
a624 1
	if (intrstat & ARC_REG_INTRSTAT_DOORBELL) {
d627 2
a628 2
			arc_write(sc, ARC_REG_INTRMASK,
			    ~ARC_REG_INTRMASK_POSTQUEUE);
d632 5
a636 5
			reg = arc_read(sc, ARC_REG_OUTB_DOORBELL);
			arc_write(sc, ARC_REG_OUTB_DOORBELL, reg);
			if (reg & ARC_REG_OUTB_DOORBELL_WRITE_OK)
				arc_write(sc, ARC_REG_INB_DOORBELL,
				    ARC_REG_INB_DOORBELL_READ_OK);
d642 1
a642 1
		    ((reg << ARC_REG_REPLY_QUEUE_ADDR_SHIFT) -
d715 1
a715 1
		reg |= ARC_REG_POST_QUEUE_BIGFRAME;
d795 1
a795 1
	if (reg & ARC_REG_REPLY_QUEUE_ERR) {
d851 1
a851 1
		    ((reg << ARC_REG_REPLY_QUEUE_ADDR_SHIFT) -
d884 2
a885 2
	memtype = pci_mapreg_type(sc->sc_pc, sc->sc_tag, ARC_PCI_BAR);
	if (pci_mapreg_map(pa, ARC_PCI_BAR, memtype, 0, &sc->sc_iot,
d928 2
a929 2
	if (arc_wait_eq(sc, ARC_REG_OUTB_ADDR1, ARC_REG_OUTB_ADDR1_FIRMWARE_OK,
	    ARC_REG_OUTB_ADDR1_FIRMWARE_OK) != 0) {
d934 1
a934 1
	if (arc_msg0(sc, ARC_REG_INB_MSG0_GET_CONFIG) != 0) {
d939 1
a939 1
	arc_read_region(sc, ARC_REG_MSGBUF, &fwinfo, sizeof(fwinfo));
d976 1
a976 1
	if (arc_msg0(sc, ARC_REG_INB_MSG0_START_BGRB) != 0) {
d1382 1
a1382 1
	u_int8_t			rwbuf[ARC_REG_IOC_RWBUF_MAXLEN];
d1395 1
a1395 1
	if (arc_read(sc, ARC_REG_OUTB_DOORBELL) != 0)
d1413 1
a1413 1
	reg = ARC_REG_OUTB_DOORBELL_READ_OK;
d1416 1
a1416 1
		if ((reg & ARC_REG_OUTB_DOORBELL_READ_OK) && wdone < wlen) {
d1431 2
a1432 2
			arc_write(sc, ARC_REG_IOC_WBUF_LEN, rwlen);
			arc_write_region(sc, ARC_REG_IOC_WBUF, rwbuf,
d1436 2
a1437 2
			arc_write(sc, ARC_REG_INB_DOORBELL,
			    ARC_REG_INB_DOORBELL_WRITE_OK);
d1442 1
a1442 1
		while ((reg = arc_read(sc, ARC_REG_OUTB_DOORBELL)) == 0)
d1444 1
a1444 1
		arc_write(sc, ARC_REG_OUTB_DOORBELL, reg);
d1448 2
a1449 2
		if ((reg & ARC_REG_OUTB_DOORBELL_WRITE_OK) && rdone < rlen) {
			rwlen = arc_read(sc, ARC_REG_IOC_RBUF_LEN);
d1457 1
a1457 1
			arc_read_region(sc, ARC_REG_IOC_RBUF, rwbuf,
d1460 2
a1461 2
			arc_write(sc, ARC_REG_INB_DOORBELL,
			    ARC_REG_INB_DOORBELL_READ_OK);
d1516 1
a1516 1
	arc_write(sc, ARC_REG_INTRMASK, ~ARC_REG_INTRMASK_POSTQUEUE);
d1528 2
a1529 2
	arc_write(sc, ARC_REG_INTRMASK,
	    ~(ARC_REG_INTRMASK_POSTQUEUE|ARC_REG_INTRMASK_DOORBELL));
d1540 2
a1541 2
	arc_write(sc, ARC_REG_INTRMASK,
	    ~(ARC_REG_INTRMASK_POSTQUEUE|ARC_REG_INTRMASK_DOORBELL));
d1543 1
a1543 1
		arc_write(sc, ARC_REG_INTRMASK, ~ARC_REG_INTRMASK_POSTQUEUE);
d1726 1
a1726 1
	arc_write(sc, ARC_REG_INB_MSG0, m);
d1728 2
a1729 2
	if (arc_wait_eq(sc, ARC_REG_INTRSTAT, ARC_REG_INTRSTAT_MSG0,
	    ARC_REG_INTRSTAT_MSG0) != 0)
d1733 1
a1733 1
	arc_write(sc, ARC_REG_INTRSTAT, ARC_REG_INTRSTAT_MSG0);
d1828 1
a1828 1
		    ccb->ccb_offset) >> ARC_REG_POST_QUEUE_ADDR_SHIFT;
@


1.68
log
@the arc fimware can be configured with a password that is used to
restrict changes to its configuration. in our case we want to be
able to disable or enable the alarm. if a password is set though,
the firmware will reject that request with a PASSWORD_REQUIRED
response code. this change lets the kernel return EPERM instead of
EIO in that case.

if you dont have a password set on the firmware you can configure
the alarm just fine.

makes sense claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.67 2007/10/22 09:58:05 dlg Exp $ */
d472 1
d529 1
a529 1
		return;
d534 1
a534 1
		return;
d575 2
d910 8
@


1.67
log
@arc supports more than just SATA hbas, so dont say the ports are always
SATA ports. print "firmware" instead of "FW Version:" cos i think it looks
better. tested on a 1680 which seems to just work so far.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.66 2007/10/01 15:34:48 krw Exp $ */
d224 1
d1047 6
a1052 1
	if (reply[0] != ARC_FW_CMD_OK)
d1054 1
a1054 2

	return (0);
@


1.66
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...' where
obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.65 2007/07/11 19:01:30 otto Exp $ */
d968 1
a968 1
	printf("%s: %d SATA Ports, %dMB SDRAM, FW Version: %s\n",
@


1.65
log
@Use the full 64 bits available when reporting sizes; now bioctl shows
the correct size for my 4.TB volume. Original diff from dlg@@ with some
tweaks by me; ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.64 2007/06/24 05:34:35 dlg Exp $ */
d1553 1
a1553 2
	    M_DEVBUF, M_WAITOK);
	bzero(sc->sc_sensors, sizeof(struct ksensor) * sc->sc_nsensors);
d1726 1
a1726 1
	adm = malloc(sizeof(struct arc_dmamem), M_DEVBUF, M_NOWAIT);
a1729 1
	bzero(adm, sizeof(struct arc_dmamem));
d1784 1
a1784 2
	    M_DEVBUF, M_WAITOK);
	bzero(sc->sc_ccbs, sizeof(struct arc_ccb) * sc->sc_req_count);
@


1.64
log
@rework sensor tasks to use the kernels generic workq rather than a special
kernel thread of its own. the api has changed (which will be fixed in the
manpage shortly) so all the users of sensor tasks that i can find have
been fixed too.

noone tested, so its going in to force people to run with it.
"put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.63 2007/05/29 22:17:50 todd Exp $ */
d1114 1
a1114 1
		if (volinfo->capacity != 0 &&
d1154 1
a1154 1
		if (volinfo->capacity == 0 ||
d1164 2
a1165 1
	if (nvols != vol || volinfo->capacity == 0 ||
d1182 1
d1216 3
a1218 1
	bv->bv_size = (u_int64_t)letoh32(volinfo->capacity) * ARC_BLOCKSIZE;
d1263 1
d1324 3
a1326 1
	bd->bd_size = (u_int64_t)letoh32(diskinfo->capacity) * ARC_BLOCKSIZE;
@


1.63
log
@sprinkle some SMALL_KERNEL to permit bio/softraid to run on boot media
ok marco@@ then suggested deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.62 2007/05/20 04:39:35 ray Exp $ */
d1567 1
a1567 1
	if (sensor_task_register(sc, arc_refresh_sensors, 120) != 0)
@


1.62
log
@Add missing arguments to printf.

OK tedu@@, dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.61 2007/03/27 11:25:17 jmc Exp $ */
d495 1
d499 1
d560 1
d570 1
d1522 1
d1619 1
@


1.61
log
@more grammar fixups; from bret lambert and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.60 2007/03/27 11:22:59 jmc Exp $ */
d579 1
a579 1
		printf("%s: timeout waiting to stop bg rebuild\n");
d582 1
a582 1
		printf("%s: timeout waiting to flush cache\n");
d593 1
a593 1
		printf("%s: timeout waiting to stop bg rebuild\n");
d596 1
a596 1
		printf("%s: timeout waiting to flush cache\n");
d912 1
a912 1
		printf("%s: timeout waiting for firmware ok\n");
d917 1
a917 1
		printf("%s: timeout waiting for get config\n");
d959 2
a960 1
		printf("%s: timeout waiting to start bg rebuild\n");
@


1.60
log
@grammar from bret lambert, and one more from me;
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.59 2007/03/22 16:55:31 deraadt Exp $ */
d1105 3
a1107 3
		 * i cant find an easy way to see if the volume exists or not
		 * except to say that if it has no capacity then it isnt there.
		 * ignore passthru volumes, bioc_vol doesnt understand them.
@


1.59
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.58 2007/02/20 17:06:23 thib Exp $ */
d713 1
a713 1
	/* we've built the command, lets put it on the hw */
@


1.58
log
@No use checking malloc return when called with M_WAITOK.

ok dlg@@, tested by jolan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.57 2006/12/23 17:46:39 deraadt Exp $ */
d387 2
a388 2
	struct sensor		*sc_sensors;
	struct sensordev	sc_sensordev;
d1539 1
a1539 1
	sc->sc_sensors = malloc(sizeof(struct sensor) * sc->sc_nsensors,
d1541 1
a1541 1
	bzero(sc->sc_sensors, sizeof(struct sensor) * sc->sc_nsensors);
@


1.57
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.56 2006/12/22 22:55:36 deraadt Exp $ */
a1054 2
	if (sysinfo == NULL)
		return (ENOMEM);
a1083 3
	if (sysinfo == NULL)
		return (ENOMEM);

a1084 4
	if (volinfo == NULL) {
		free(sysinfo, M_TEMP);
		return (ENOMEM);
	}
a1131 2
	if (sysinfo == NULL)
		return (ENOMEM);
a1179 2
	if (volinfo == NULL)
		return (ENOMEM);
a1258 3
	if (volinfo == NULL)
		return (ENOMEM);

a1259 5
	if (raidinfo == NULL) {
		free(volinfo, M_TEMP);
		return (ENOMEM);
	}

a1260 5
	if (diskinfo == NULL) {
		free(raidinfo, M_TEMP);
		free(volinfo, M_TEMP);
		return (ENOMEM);
	}
a1369 2
	if (wbuf == NULL)
		return (ENOMEM);
a1372 4
	if (rbuf == NULL) {
		free(wbuf, M_TEMP);
		return (ENOMEM);
	}
a1540 2
	if (sc->sc_sensors == NULL)
		return;
a1772 4
	if (sc->sc_ccbs == NULL) {
		printf("%s: unable to allocate ccbs\n", DEVNAME(sc));
		return (1);
	}
@


1.56
log
@always include sensors.h
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.55 2006/11/28 23:59:45 dlg Exp $ */
d388 1
d1577 3
a1588 2
		strlcpy(sc->sc_sensors[i].device, DEVNAME(sc),
		    sizeof(sc->sc_sensors[i].device));
d1592 1
a1592 1
		sensor_add(&sc->sc_sensors[i]);
d1598 2
a1602 2
	while (--i >= 0)
		sensor_del(&sc->sc_sensors[i]);
@


1.55
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.54 2006/11/04 23:11:31 dlg Exp $ */
d39 1
a41 1
#include <sys/sensors.h>
@


1.54
log
@query the firmware for the number of volumes, and then iterate through them
to get the right names for sensor creation.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.53 2006/11/01 12:21:51 dlg Exp $ */
d511 1
d543 4
a546 1
	child = config_found(self, &sc->sc_link, scsiprint);
@


1.53
log
@dont walk the device list looking for our scsibus, it is stashed when we
attach it.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.52 2006/11/01 12:12:32 dlg Exp $ */
a375 1
	int			sc_disk_count;
d388 1
d495 1
a495 1
int			arc_create_sensors(struct arc_softc *);
d553 8
a560 2
	if (arc_create_sensors(sc) != 0)
		printf("%s: unable to create sensors\n", DEVNAME(sc));
a903 1
	int				i, j;
a944 6
	/* iterate through the device map and get a physical disk count */
	for (i = 0; i < 16; i++)
		for (j = 0; j < 8; j++)
			if (fwinfo.device_map[i] & (1 << j))
				sc->sc_disk_count++;

d1544 2
a1545 2
int
arc_create_sensors(struct arc_softc *sc)
d1547 3
a1549 1
	struct device		*dev;
d1552 15
a1566 1
	sc->sc_sensors = malloc(sizeof(struct sensor) * sc->sc_disk_count,
d1569 2
a1570 2
		return (1);
	bzero(sc->sc_sensors, sizeof(struct sensor) * sc->sc_disk_count);
d1572 4
a1575 2
	for (i = 0; i < sc->sc_disk_count; i++) {
		if (sc->sc_scsibus->sc_link[i][0] == NULL)
a1577 2
		dev = sc->sc_scsibus->sc_link[i][0]->device_softc;

d1583 1
a1583 1
		strlcpy(sc->sc_sensors[i].desc, dev->dv_xname,
d1589 1
a1589 1
	if (sensor_task_register(sc, arc_refresh_sensors, 10) != 0)
d1592 1
a1592 1
	return (0);
a1597 2

	return (1);
d1607 1
a1607 1
	for (i = 0; i < sc->sc_disk_count; i++) {
@


1.52
log
@whitespace fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.51 2006/10/31 15:23:21 jolan Exp $ */
a1548 1
	struct scsibus_softc	*ssc;
a1550 13
	TAILQ_FOREACH(dev, &alldevs, dv_list) {
		if (dev->dv_parent != &sc->sc_dev)
			continue;

		/* check if this is the scsibus for the logical disks */
		ssc = (struct scsibus_softc *)dev;
		if (ssc->adapter_link == &sc->sc_link)
			break;
	}

	if (ssc == NULL)
		return (1);

d1558 1
a1558 1
		if (ssc->sc_link[i][0] == NULL)
d1561 1
a1561 1
		dev = ssc->sc_link[i][0]->device_softc;
@


1.51
log
@first cut at sensors

help from & ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.50 2006/09/25 22:49:28 dlg Exp $ */
d235 5
a239 5
        u_int8_t		target;
        u_int8_t		lun;
        u_int8_t		tagged;
        u_int8_t		cache;
        u_int8_t		speed;
d327 3
a329 3
        u_int32_t		memory_size;
        u_int32_t		memory_speed;
        u_int32_t		events;
d331 2
a332 2
        u_int8_t		gsiMacAddress[6];
        u_int8_t		gsiDhcp;
d552 1
a552 1
	
d1569 1
a1569 1
	bzero(sc->sc_sensors, sizeof(struct sensor) * sc->sc_disk_count);	
@


1.50
log
@well, this is embarrassing.

it turns out a drivers detach code isnt called when the machine is shutting
down, which meant my bits to stop bgrb and sync the cache werent being
run. without those bits being run the filesystems on these controllers
were never clean on reboot, so we'd always get an fsck.

so now we provide a shutdown hook which does get run on shutdown to sync
the cache properly.

found by claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.48 2006/08/28 05:36:00 dlg Exp $ */
d41 1
d376 1
d387 2
d493 4
d552 3
d898 1
d940 5
a944 1
	/* device map? */
d1543 98
@


1.49
log
@enabling interrupts isnt a bug, so dont put XXX next to it.
only ack the interrupts we deal with in the interrupt handler.
use the correct macros when setting the interrupt mask.
@
text
@d353 1
d373 2
d523 4
d554 2
d563 12
@


1.48
log
@move the firmware messaging under NBIO since it's only used by bio.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.47 2006/08/28 00:53:34 dlg Exp $ */
d530 1
a530 1
	/* XXX enable interrupts */
d568 1
d1490 1
a1490 1
	    ~(ARC_REG_INTRMASK_POSTQUEUE|ARC_REG_INTRSTAT_DOORBELL));
d1502 1
a1502 1
	    ~(ARC_REG_INTRMASK_POSTQUEUE|ARC_REG_INTRSTAT_DOORBELL));
@


1.48.2.1
log
@MFC:
Fix by dlg@@

well, this is embarassing.

it turns out a drivers detach code isnt called when the machine is shutting
down which meant my bits to stop bgrb and sync the cache werent being
run. without those bits being run the filesystems on these controllers
were never clean on reboot, so we'd always get an fsck.

so now we provide a shutdown hook which does get run on shutdown to sync
the cache properly.

found by claudio@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.48 2006/08/28 05:36:00 dlg Exp $ */
a352 1
void			arc_shutdown(void *);
a371 2
	void			*sc_shutdownhook;

a519 4
	sc->sc_shutdownhook = shutdownhook_establish(arc_shutdown, sc);
	if (sc->sc_shutdownhook == NULL)
		panic("unable to establish arc powerhook");

a546 2
	shutdownhook_disestablish(sc->sc_shutdownhook);

a553 12
}

void
arc_shutdown(void *xsc)
{
	struct arc_softc		*sc = xsc;

	if (arc_msg0(sc, ARC_REG_INB_MSG0_STOP_BGRB) != 0)
		printf("%s: timeout waiting to stop bg rebuild\n");

	if (arc_msg0(sc, ARC_REG_INB_MSG0_FLUSH_CACHE) != 0)
		printf("%s: timeout waiting to flush cache\n");
@


1.47
log
@turns out the volume info contains a bitmap of failed physdisks in it, so
i can just check if this is non zero to see if a volume is degraded. this
means i dont have to pull the raid info page to find failed disks in the
volume inquiry.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.46 2006/08/27 11:29:45 dlg Exp $ */
d465 2
a475 1
#if NBIO > 0
a1315 1
#endif /* NBIO > 0 */
d1506 1
@


1.46
log
@sigh, this is annoying. it appears that the arc firmware doesnt care if a
volume is degraded, just if it is working or not. if a volume is degraded,
its still online, so we have to go look for missing disks. if a disk has
been replaced, but it is yet to be rebuilt, the firmware kindly tells us
that it needs rebuilding. we can figure out if a volume is degraded using
these two facts.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.45 2006/08/27 09:56:20 dlg Exp $ */
a1141 1
	struct arc_fw_raidinfo		*raidinfo;
a1143 1
	u_int8_t			request[2];
a1144 1
	int				i;
a1150 6
	raidinfo = malloc(sizeof(struct arc_fw_raidinfo), M_TEMP, M_WAITOK);
	if (raidinfo == NULL) {
		free(volinfo, M_TEMP);
		return (ENOMEM);
	}

d1152 2
a1154 1
	error = arc_bio_getvol(sc, bv->bv_volid, volinfo);
d1163 4
a1166 20
		bv->bv_status = BIOC_SVONLINE;
		/*
		 * the stupid firmware doesnt care if a volume is degraded,
		 * just if it is working or not. go see if any disks are
		 * missing and figure out if it's degraded for ourselves.
		 */
		request[0] = ARC_FW_RAIDINFO;
		request[1] = volinfo->raid_set_number;
		error = arc_msgbuf(sc, request, sizeof(request), raidinfo,
		    sizeof(struct arc_fw_raidinfo));
		if (error != 0)
			goto out;

		for (i = 0; i < raidinfo->member_devices; i++) {
			/* a missing disk shows up as 0xff */
			if (raidinfo->device_array[i] == 0xff) {
				bv->bv_status = BIOC_SVDEGRADED;
				break;
			}	
		}
a1211 2
	arc_unlock(sc);
	free(raidinfo, M_TEMP);
@


1.45
log
@try to get the status of the volume out of the arc firmware and into
bioctl output. this is actually a bit of a struggle since the firmware
doesnt represent these states well at all. im only showing the obvious
ones: online, init, rebuild, and offline. i have no idea how they tell if
a volume is degraded.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.44 2006/08/27 09:29:26 dlg Exp $ */
d1142 1
d1145 1
d1147 1
d1154 6
d1161 1
a1162 1
	arc_unlock(sc);
d1170 1
a1170 1
	if (status == 0x0)
d1172 21
d1236 2
@


1.44
log
@if a disk dissapears out of a raidset, then the raid info will list its id
as 0xff, and the command to query that phys disk will fail and cause the
ioctl to get stuck. so if the disk id is 0xff, fake an offline disk on
another bus since bioctl doesnt know how to show that properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.43 2006/08/27 09:14:19 dlg Exp $ */
d267 11
d1144 1
a1153 1

a1156 8
	sc_link = sc->sc_scsibus->sc_link[volinfo->scsi_attr.target]
	    [volinfo->scsi_attr.lun];
	if (sc_link == NULL) {
		error = ENODEV;
		goto out;
	}
	dev = sc_link->device_softc;

d1160 13
a1172 1
	bv->bv_status = BIOC_SVONLINE;
d1198 6
a1203 1
	strlcpy(bv->bv_dev, dev->dv_xname, sizeof(bv->bv_dev));
@


1.43
log
@little nit
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.42 2006/08/25 02:48:16 dlg Exp $ */
d1234 13
@


1.42
log
@fill in the controllers name in the inq ioctl. spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.41 2006/08/24 13:59:36 dlg Exp $ */
d692 1
a692 1
	if (error) {
@


1.41
log
@show the firmware revision of the disks.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.40 2006/08/24 13:43:47 dlg Exp $ */
d1069 1
@


1.40
log
@report the size of the disks and volumes correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.39 2006/08/24 09:59:57 dlg Exp $ */
d1197 3
a1199 1
	char				string[128];
d1259 8
a1266 4
	scsi_strvis(string, diskinfo->model, sizeof(diskinfo->model));
	strlcpy(bd->bd_vendor, string, sizeof(bd->bd_vendor));
	scsi_strvis(string, diskinfo->serial, sizeof(diskinfo->serial));
	strlcpy(bd->bd_serial, string, sizeof(bd->bd_serial));
@


1.39
log
@too much copy and paste. report raid 1 correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.38 2006/08/24 09:43:48 dlg Exp $ */
d183 1
d1157 1
a1157 2
	bv->bv_size = letoh32(volinfo->capacity) *
	    letoh32(volinfo->stripe_size) * 512;
d1255 1
a1255 1
	bd->bd_size = letoh32(diskinfo->capacity) * 512;
@


1.38
log
@ignore passthru volumes, struct bioc_vol isnt smart enough to know what
they are.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.37 2006/08/24 09:39:29 dlg Exp $ */
d1164 1
a1164 1
		bv->bv_level = 0;
@


1.37
log
@figure out the raid level of the volume.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.35 2006/08/24 09:18:40 dlg Exp $ */
d1060 2
a1061 1
		 * except to say that if it has no capacity then it isnt there
d1063 2
a1064 1
		if (volinfo->capacity != 0)
d1104 2
a1105 1
		if (volinfo->capacity == 0)
d1114 2
a1115 1
	if (nvols != vol || volinfo->capacity == 0) {
@


1.36
log
@oops, im unlocking too often
@
text
@d270 6
d1154 23
a1176 1
	bv->bv_level = 0;
@


1.35
log
@a start at the BIOC INQ, VOL, and DISK ioctls for fetching information
about the disks that are configured on the controller. so far this fetches
the right volumes and disks in each volume, but doesnt properly fill in the
status, the size of both the volumes and disks, the type of raid, or the
firmware version of the physical disks.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.32 2006/08/20 02:21:26 dlg Exp $ */
a1140 1
	arc_unlock(sc);
@


1.34
log
@stash a pointer to the scsibus attached to us. we can use this later to
find the names of our volumes.
@
text
@d458 3
d464 3
d917 12
d1011 225
@


1.33
log
@definitions of the messages for raid, volume, and physical disks
@
text
@d360 2
d475 1
d502 2
a503 1
	config_found(self, &sc->sc_link, scsiprint);
@


1.32
log
@get rid of the horror that was the ARC_FW_MSG macro
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.31 2006/08/20 02:20:04 dlg Exp $ */
d211 3
d229 61
@


1.31
log
@get rid of the old arc_msgbuf.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.30 2006/08/20 02:13:49 dlg Exp $ */
a218 10

/* variable length msg */
#define ARC_FW_MSG(_len)				\
struct {						\
	struct arc_fw_hdr	hdr;			\
	u_int16_t		len;			\
	u_int8_t		msg[(_len)];		\
	u_int8_t		cksum;			\
} __packed
#define ARC_FW_MSGBUF(_msg)	((void *)(_msg)->msg)
@


1.30
log
@cut the rest of the bioctl alarm stuff over to the new arc_msgbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.29 2006/08/20 02:06:54 dlg Exp $ */
d395 1
a395 1
u_int8_t		arc_msg_cksum(void *, size_t);
a398 4
u_int8_t arc_msg_cksum2(void *cmd, u_int16_t len);
int arc_msgbuf2(struct arc_softc *sc, void *wptr, size_t wbuflen, void *rptr,
    size_t rbuflen);

d898 1
a898 1
	error = arc_msgbuf2(sc, request, len, reply, sizeof(reply));
d924 1
a924 1
	error = arc_msgbuf2(sc, &request, sizeof(request),
d940 1
a940 98
arc_msg_cksum(void *cmd, size_t len)
{
	u_int8_t			*buf = cmd;
	u_int8_t			cksum = 0;
	int				i;

	/* starts after the header, ends before the cksum */
	for (i = sizeof(struct arc_fw_hdr); i < (len - 1); i++)
		cksum += buf[i];

	return (cksum);
}

int
arc_msgbuf(struct arc_softc *sc, void *wptr, size_t wlen, void *rptr,
    size_t rlen)
{
	u_int8_t			rwbuf[ARC_REG_IOC_RWBUF_MAXLEN];
	u_int8_t			*wbuf = wptr, *rbuf = rptr;
	int				wdone = 0, rdone = 0;
	u_int32_t			reg, rwlen;
#ifdef ARC_DEBUG
	int				i;
#endif

	DNPRINTF(ARC_D_DB, "%s: arc_msgbuf wlen: %d rlen: %d\n", DEVNAME(sc),
	    wlen, rlen);

	if (arc_read(sc, ARC_REG_OUTB_DOORBELL) != 0)
		return (EBUSY);

	reg = ARC_REG_OUTB_DOORBELL_READ_OK;

	do {
		if ((reg & ARC_REG_OUTB_DOORBELL_READ_OK) && wdone < wlen) {
			bzero(rwbuf, sizeof(rwbuf));
			rwlen = (wlen - wdone) % sizeof(rwbuf);
			bcopy(&wbuf[wdone], rwbuf, rwlen);
			wdone += rwlen;

#ifdef ARC_DEBUG
			if (arcdebug & ARC_D_DB) {
				printf("%s: write:", DEVNAME(sc));
				for (i = 0; i < rwlen; i++)
					printf(" 0x%02x", rwbuf[i]);
				printf("\n");
			}
#endif

			/* copy the chunk to the hw */
			arc_write(sc, ARC_REG_IOC_WBUF_LEN, rwlen);
			arc_write_region(sc, ARC_REG_IOC_WBUF, rwbuf,
			    sizeof(rwbuf));

			/* say we have a buffer for the hw */
			arc_write(sc, ARC_REG_INB_DOORBELL,
			    ARC_REG_INB_DOORBELL_WRITE_OK);
		}

		while ((reg = arc_read(sc, ARC_REG_OUTB_DOORBELL)) == 0)
			arc_wait(sc);
		arc_write(sc, ARC_REG_OUTB_DOORBELL, reg);

		DNPRINTF(ARC_D_DB, "%s: reg: 0x%08x\n", DEVNAME(sc), reg);

		if ((reg & ARC_REG_OUTB_DOORBELL_WRITE_OK) && rdone < rlen) {
			rwlen = arc_read(sc, ARC_REG_IOC_RBUF_LEN);
			arc_read_region(sc, ARC_REG_IOC_RBUF, rwbuf,
			    sizeof(rwbuf));

			arc_write(sc, ARC_REG_INB_DOORBELL,
			    ARC_REG_INB_DOORBELL_READ_OK);

#ifdef ARC_DEBUG
			printf("%s:  len: %d+%d=%d/%d\n", DEVNAME(sc),
			    rwlen, rdone, rwlen + rdone, rlen);
			if (arcdebug & ARC_D_DB) {
				printf("%s: read:", DEVNAME(sc));
				for (i = 0; i < rwlen; i++)
					printf(" 0x%02x", rwbuf[i]);
				printf("\n");
			}
#endif

			if ((rdone + rwlen) > rlen)
				return (EIO);

			bcopy(rwbuf, &rbuf[rdone], rwlen);
			rdone += rwlen;
		}

	} while (rdone != rlen);

	return (0);
}

u_int8_t
arc_msg_cksum2(void *cmd, u_int16_t len)
d955 1
a955 1
arc_msgbuf2(struct arc_softc *sc, void *wptr, size_t wbuflen, void *rptr,
d993 1
a993 1
	wbuf[wlen - 1] = arc_msg_cksum2(wptr, wbuflen);
d1078 1
a1078 1
	if (rbuf[rlen - 1] != arc_msg_cksum2(rptr, rbuflen)) {
@


1.29
log
@because the header on firmware commands causes the rest of the message to
be unaligned we basically need to bounce the contents of the message in and
out of what is submitted to the hardware. rather than have the callers of
arc_msgbuf do that, make arc_msgbuf do it for them. while we're here, make
arc_msgbuf do the checksumming and length checks so the callers dont have
to do that either.

this adds an alternative to arc_msgbuf that does the new functionality and
cuts arc_bio_alarm_state over to using it. i'll cut the other users of
arc_msgbuf over shortly and remove the old implementation.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.28 2006/08/18 13:57:11 dlg Exp $ */
d872 2
a873 4
	ARC_FW_MSG(2)			toggle;
	ARC_FW_MSG(1)			silence;
	ARC_FW_MSG(1)			reply;
	void				*request;
d880 2
a881 4
		toggle.hdr = arc_fw_hdr;
		toggle.len = htole16(sizeof(toggle.msg));
		toggle.msg[0] = ARC_FW_SET_ALARM;
		toggle.msg[1] = (ba->ba_opcode == BIOC_SAENABLE) ?
d883 1
a883 4
		toggle.cksum = arc_msg_cksum(&toggle, sizeof(toggle));

		request = &toggle;
		len = sizeof(toggle);
d888 2
a889 7
		silence.hdr = arc_fw_hdr;
		silence.len = htole16(sizeof(silence.msg));
		silence.msg[0] = ARC_FW_MUTE_ALARM;
		silence.cksum = arc_msg_cksum(&silence, sizeof(silence));

		request = &silence;
		len = sizeof(silence);
d902 1
a902 1
	error = arc_msgbuf(sc, request, len, &reply, sizeof(reply));
d908 1
a908 3
	if (memcmp(&reply.hdr, &arc_fw_hdr, sizeof(reply.hdr)) != 0 ||
	    reply.cksum != arc_msg_cksum(&reply, sizeof(reply)) ||
	    reply.msg[0] != ARC_FW_CMD_OK)
@


1.28
log
@oops, debug cruft shouldnt go into the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.27 2006/08/18 13:55:52 dlg Exp $ */
d206 5
d399 4
d931 1
a931 2
	ARC_FW_MSG(1)			request;
	ARC_FW_MSG(sizeof(struct arc_fw_sysinfo)) *reply;
d935 2
a936 2
	reply = malloc(sizeof(*reply), M_TEMP, M_WAITOK);
	if (reply == NULL)
d939 1
a939 6
	sysinfo = ARC_FW_MSGBUF(reply);

	request.hdr = arc_fw_hdr;
	request.len = htole16(sizeof(request.msg));
	request.msg[0] = ARC_FW_SYSINFO;
	request.cksum = arc_msg_cksum(&request, sizeof(request));
d942 2
a943 2
	error = arc_msgbuf(sc, &request, sizeof(request),
	    reply, sizeof(*reply));
a948 6
	if (memcmp(&reply->hdr, &arc_fw_hdr, sizeof(reply->hdr)) != 0 ||
	    reply->cksum != arc_msg_cksum(reply, sizeof(*reply))) {
		error = EIO;
		goto out;
	}

d952 1
a952 1
	free(reply, M_TEMP);
d1047 79
d1127 10
d1139 42
d1183 21
a1203 1
	return (0);
@


1.27
log
@add the sysinfo struct, and then use it to get the current state of the
alarm.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.26 2006/08/18 10:40:04 dlg Exp $ */
a950 3

	printf("%s: %s value: 0x%02x\n", DEVNAME(sc), __func__,
	    sysinfo->alarm);
@


1.26
log
@easy bio bits first. this is is code that should enable, disable, and
silence the alarm. the hardware can also report the state of the alarm,
but its embedded in a really large message im not 100% sure about yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.23 2006/08/18 01:20:14 dlg Exp $ */
d206 1
d225 48
d398 2
d896 4
d901 1
a901 2
		error = EOPNOTSUPP;
		break;
d917 43
@


1.25
log
@arc, meet bio. bio, meet arc.
@
text
@d348 1
d793 70
a862 1
	return (ENOTTY);
@


1.24
log
@fix up the arc fw message macros a bit. change a comment while here.
@
text
@d19 2
d39 5
d345 5
d394 5
d787 8
@


1.23
log
@a bit more infrastructure for firmware commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.22 2006/08/17 12:31:16 dlg Exp $ */
d199 7
a205 3
#define ARC_FW_MUTE_ALARM	0x30	/* defmsg */
#define ARC_FW_SET_ALARM	0x31	/* 0 is dis, 1 is en */
#define ARC_FW_NOP		0x38	/* defmsg */
d212 1
a212 1
	u_int8_t		msg[(len)];		\
d330 1
a330 1
/* these lock access to the read and write regions. */
@


1.22
log
@dont need debug in the tree
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.21 2006/08/17 12:16:35 dlg Exp $ */
d188 25
d330 1
d765 14
@


1.21
log
@man, i wish firmware commands were as easy as scsi io's on these
controllers. this is horrible code that is set up to allow a process, (eg
and ioctl or the sensor thread) to issue a command and get a response.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.19 2006/08/15 02:09:02 dlg Exp $ */
a36 2
#define ARC_DEBUG

d747 1
a747 1
	int				wdone = 0, rdone = 0, i;
d749 3
@


1.20
log
@when there's normal sense data i think the command completed ok, there's
just extra data. say there's no residual if that's the case.
@
text
@d25 2
d42 1
a117 1
#define  ARC_REG_IOC_WBUF_MAXLEN	124
d120 1
a120 1
#define  ARC_REG_IOC_RBUF_MAXLEN	124
d217 3
d303 6
d323 3
d351 2
a352 1
	arc_write(sc, ARC_REG_INTRMASK, ~ARC_REG_INTRMASK_POSTQUEUE);
d385 16
d741 119
@


1.19
log
@try to deal appropriate with errors from the io command reply
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.18 2006/08/14 15:22:27 dlg Exp $ */
d543 1
@


1.18
log
@start and stop bgrb during attach and detach respectively. as a bonus
flush the hbas cache on detach as well. writes on my raid5 seem to run fast
now.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.17 2006/08/14 14:43:36 dlg Exp $ */
d156 5
a160 1
#define ARC_MSG_SENSELEN			16
a161 3
#define ARC_MSG_SENSE_TIMEOUT			0xf0
#define ARC_MSG_SENSE_ABORTED			0xf1
#define ARC_MSG_SENSE_INIT_FAIL			0xf2
d513 1
d526 25
a550 2
		// printf("%s: something went wrong\n", DEVNAME(sc));
		xs->error = XS_DRIVER_STUFFUP;
@


1.17
log
@firmware commands (as opposed to io commands) are sent to the firmware via
the IOC_WBUF area in bus_space, and replies to it are read from the
IOC_RBUF area. the freebsd and linux drivers define these areas to be 32
dwords in length, but it then goes and casts these spaces to a struct that
has a 4 byte word at the start with the length of the message in it,
followed by a 124 byte buffer which is filled with the actual message in
it.

rather than screwing around with an extra struct and casts, we can define
this header as a register of its own, and the buffer as a separate region
in bus_space.

this simplifies command submission and the retrieval of the replies (which
is yet to be written properly).
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.16 2006/08/09 09:21:13 dlg Exp $ */
d248 1
d344 8
d630 1
a630 3
	arc_write(sc, ARC_REG_INB_MSG0, ARC_REG_INB_MSG0_GET_CONFIG);
	if (arc_wait_eq(sc, ARC_REG_INTRSTAT, ARC_REG_INTRSTAT_MSG0,
	    ARC_REG_INTRSTAT_MSG0) != 0) {
a633 1
	arc_write(sc, ARC_REG_INTRSTAT, ARC_REG_INTRSTAT_MSG0);
d674 5
d760 16
@


1.16
log
@define the size of regions in the register space in terms of bytes, not
dwords
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.15 2006/08/07 21:44:10 dlg Exp $ */
d86 2
d89 2
d113 6
a118 4
#define ARC_REG_IOC_WBUF		0x0e00
#define  ARC_REG_IOC_WBUF_LEN		128
#define ARC_REG_IOC_RBUF		0x0f00
#define  ARC_REG_IOC_RBUF_LEN		128
@


1.15
log
@whitespace fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.14 2006/08/07 21:35:22 dlg Exp $ */
d108 1
a108 1
#define  ARC_REG_MSGBUF_LEN		256	/* dwords */
d110 1
a110 1
#define  ARC_REG_IOC_WBUF_LEN		32	/* dwords */
d112 1
a112 1
#define  ARC_REG_IOC_RBUF_LEN		32	/* dwords */
@


1.14
log
@from the drivers side of the iop331 there is only one set of interrupt
registers to deal with, the other set are used on the firmware side of the
device. shrink a bit by removing the definitions of the firmwares
registers.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.13 2006/08/06 13:17:23 dlg Exp $ */
d355 1
a355 1
		cmd = (struct arc_io_cmd *)(kva + 
d539 1
a539 1
		cmd = (struct arc_io_cmd *)(kva + 
@


1.13
log
@endian fixes. this works on sparc64 now.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.12 2006/08/06 07:58:00 dlg Exp $ */
d86 14
a99 30
#define ARC_REG_INB_INTRSTAT		0x0024
#define  ARC_REG_INB_INTRSTAT_MSG0		(1<<0)
#define  ARC_REG_INB_INTRSTAT_MSG1		(1<<1)
#define  ARC_REG_INB_INTRSTAT_DOORBELL		(1<<2)
#define  ARC_REG_INB_INTRSTAT_DOORBELL_ERR	(1<<3)
#define  ARC_REG_INB_INTRSTAT_POSTQUEUE		(1<<4)
#define  ARC_REG_INB_INTRSTAT_QUEUEFULL		(1<<5)
#define  ARC_REG_INB_INTRSTAT_INDEX		(1<<6)
#define ARC_REG_INB_INTRMASK	0x0028
#define  ARC_REG_INB_INTRMASK_MSG0		(1<<0)
#define  ARC_REG_INB_INTRMASK_MSG1		(1<<1)
#define  ARC_REG_INB_INTRMASK_DOORBELL		(1<<2)
#define  ARC_REG_INB_INTRMASK_DOORBELL_ERR	(1<<3)
#define  ARC_REG_INB_INTRMASK_POSTQUEUE		(1<<4)
#define  ARC_REG_INB_INTRMASK_QUEUEFULL		(1<<5)
#define  ARC_REG_INB_INTRMASK_INDEX		(1<<6)
#define ARC_REG_OUTB_DOORBELL	0x002c
#define ARC_REG_OUTB_INTRSTAT	0x0030
#define  ARC_REG_OUTB_INTRSTAT_MSG0		(1<<0)
#define  ARC_REG_OUTB_INTRSTAT_MSG1		(1<<1)
#define  ARC_REG_OUTB_INTRSTAT_DOORBELL		(1<<2)
#define  ARC_REG_OUTB_INTRSTAT_POSTQUEUE	(1<<3)
#define  ARC_REG_OUTB_INTRSTAT_PCI		(1<<4)
#define ARC_REG_OUTB_INTRMASK	0x0034
#define  ARC_REG_OUTB_INTRMASK_MSG0		(1<<0)
#define  ARC_REG_OUTB_INTRMASK_MSG1		(1<<1)
#define  ARC_REG_OUTB_INTRMASK_DOORBELL		(1<<2)
#define  ARC_REG_OUTB_INTRMASK_POSTQUEUE	(1<<3)
#define  ARC_REG_OUTB_INTRMASK_PCI		(1<<4)
#define ARC_REG_POST_QUEUE	0x0040
d103 1
a103 1
#define ARC_REG_REPLY_QUEUE	0x0044
d107 6
a112 6
#define ARC_REG_MSGBUF		0x0a00
#define  ARC_REG_MSGBUF_LEN	256	/* dwords */
#define ARC_REG_IOC_WBUF	0x0e00
#define  ARC_REG_IOC_WBUF_LEN	32	/* dwords */
#define ARC_REG_IOC_RBUF	0x0f00
#define  ARC_REG_IOC_RBUF_LEN	32	/* dwords */
d329 1
a329 1
	arc_write(sc, ARC_REG_OUTB_INTRMASK, ~ARC_REG_OUTB_INTRMASK_POSTQUEUE);
d349 1
a349 1
	intrstat = arc_read(sc, ARC_REG_OUTB_INTRSTAT);
d352 1
a352 1
	arc_write(sc, ARC_REG_OUTB_INTRSTAT, intrstat);
d616 2
a617 2
	if (arc_wait_eq(sc, ARC_REG_OUTB_INTRSTAT, ARC_REG_OUTB_INTRSTAT_MSG0,
	    ARC_REG_OUTB_INTRSTAT_MSG0) != 0) {
d621 1
a621 1
	arc_write(sc, ARC_REG_OUTB_INTRSTAT, ARC_REG_OUTB_INTRSTAT_MSG0);
@


1.12
log
@fill out the interrupt handler. io is now no longer polled, and as a bonus
it's fairly fast :)
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.11 2006/08/06 07:29:18 dlg Exp $ */
d374 1
a374 1
		ccb = &sc->sc_ccbs[cmd->cmd.context];
d558 1
a558 1
		ccb = &sc->sc_ccbs[cmd->cmd.context];
@


1.11
log
@we can support more than one entry in an sgl, so stop lying to bus_dma
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.10 2006/08/06 00:38:33 dlg Exp $ */
d344 3
a358 1
#if 0
d360 22
a381 1
#endif
d383 1
a383 1
	return (0);
a459 1
#if 0
a460 1
#endif
a465 1
#if 0
a466 1
#endif
@


1.10
log
@less magic
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.9 2006/08/06 00:18:34 dlg Exp $ */
d825 2
a826 2
		if (bus_dmamap_create(sc->sc_dmat, MAXPHYS, 1, MAXPHYS, 0, 0,
		    &ccb->ccb_dmamap) != 0) {
@


1.9
log
@io commands are the only ones every posted on the queues, so hardcode the
type into the ccb rather than use void *s and insane casting to get at bits
of the command.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.8 2006/08/05 00:55:35 dlg Exp $ */
a116 2
#define  ARC_REG_POST_QUEUE_ADDR(r)	\
    ((r) >> ARC_REG_REPLY_QUEUE_ADDR_SHIFT)
a119 1
#define  ARC_REG_REPLY_QUEUE_ADDR_MASK		(0x07ffffff)
a120 2
#define  ARC_REG_REPLY_QUEUE_ADDR(r)	\
    (((r) & ARC_REG_REPLY_QUEUE_ADDR_MASK) << ARC_REG_REPLY_QUEUE_ADDR_SHIFT)
d537 2
a538 1
		    ((reg << 5) - ARC_DMA_DVA(sc->sc_requests)));
a545 1

d838 1
a838 1
		    ccb->ccb_offset) >> 5; /* XXX magic number */
@


1.8
log
@implement reply and post queue handling, but only polled for now. io should
work with this, but i cant test without disks.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.6 2006/07/31 11:40:13 dlg Exp $ */
d189 1
d192 1
a192 1
/* sizeof(struct arc_msg_scsicmd) + (sizeof(struct arc_sge) * 38) == 512 */
d194 1
a194 1
/* sizeof(struct arc_msg_scsicmd) + (sizeof(struct arc_sge) * 17) == 256 */
d197 5
a223 1
	int			sc_req_size;
d291 1
a291 1
	void			*ccb_cmd;
d413 1
a413 1
	cmd = ccb->ccb_cmd;
d437 1
a437 1
	    ccb->ccb_offset, sc->sc_req_size,
d464 1
a464 5
	struct {
		struct arc_msg_scsicmd		cmd;
		struct arc_sge			sgl[ARC_SGL_MAXLEN];
	} __packed			*bundle = ccb->ccb_cmd;
	struct arc_sge			*sge;
d480 1
a480 1
		sge = &bundle->sgl[i];
d528 1
a528 2
	struct arc_msg_scsicmd		*cmd;
	int				diff;
a531 1

d541 3
a543 4
		diff = (reg << 5) - ARC_DMA_DVA(sc->sc_requests);
		cmd = (struct arc_msg_scsicmd *)(kva + diff);

		ccb = &sc->sc_ccbs[cmd->context];
d546 1
a546 1
		    ccb->ccb_offset, sc->sc_req_size,
d656 6
a661 1
	sc->sc_req_size = letoh32(fwinfo.request_len); /* always 512 */
d820 1
a820 1
	    sc->sc_req_size * sc->sc_req_count);
d839 1
a839 1
		ccb->ccb_offset = sc->sc_req_size * i;
d841 1
a841 1
		ccb->ccb_cmd = &cmd[ccb->ccb_offset];
d877 1
a877 1
	bzero(ccb->ccb_cmd, sc->sc_req_size);
@


1.7
log
@white space fixes
@
text
@d115 13
a127 2
#define ARC_REG_INB_QUEUE	0x0040
#define ARC_REG_OUTB_QUEUE	0x0044
d171 5
a175 2
	u_int8_t		dev_stat;
	u_int8_t		sense_data[15];
d259 3
d287 1
a287 1
	bus_addr_t		ccb_cmd_dva;
d296 4
a365 1
#if 0 /* XXX this is real code */
d370 2
d380 1
d382 1
d391 1
d393 1
d398 10
d409 1
d417 1
a417 1
	/* sgl_len is set in load_xs */
d420 4
d430 16
a445 7
	if (arc_load_xs(ccb) != 0) {
		s = splbio();
		arc_put_ccb(sc, ccb);
		splx(s);
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return (COMPLETE);
d447 2
a448 1
#endif /* XXX this is real code */
d450 1
a450 3
	xs->error = XS_DRIVER_STUFFUP;
	scsi_done(xs);
	return (COMPLETE);
a486 4
	if (dmap->dm_nsegs > ARC_SGL_256LEN)
		bundle->cmd.flags |= ARC_MSG_SCSICMD_FLAG_SGL_BSIZE_512;
	bundle->cmd.sgl_len = dmap->dm_nsegs;

d495 64
d839 2
a840 2
		ccb->ccb_cmd_dva = (u_int32_t)ARC_DMA_DVA(sc->sc_requests) +
		    ccb->ccb_offset;
@


1.6
log
@take a scsi xfer from the midlayer and turn it into an areca io command.
its inside an if 0 chunk till i write the post and reply queue handling and
the response handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.5 2006/07/31 10:03:22 dlg Exp $ */
d169 1
a169 1
	u_int32_t               sg_lo_addr;
d218 1
a218 1
        NULL, "arc", DV_DULL
d442 3
a444 3
        bus_dmamap_sync(sc->sc_dmat, dmap, 0, dmap->dm_mapsize,
            (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :
            BUS_DMASYNC_PREWRITE);
d610 1
a610 1
			return (0);  
d614 1
a614 1
	return (1);         
d616 1
a616 1
        
d640 1
a640 1
        
d642 1
a642 1
        if (adm == NULL)
d687 1
a687 1
        free(adm, M_DEVBUF);
d764 3
a766 3
        ccb->ccb_xs = NULL;
        bzero(ccb->ccb_cmd, sc->sc_req_size);
        TAILQ_INSERT_TAIL(&sc->sc_ccb_free, ccb, ccb_link);
@


1.5
log
@hook arc up to the scsi midlayer
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.4 2006/07/31 08:22:04 dlg Exp $ */
d167 1
a167 1
	u_int32_t		sge_hdr;
d169 2
a170 2
	u_int32_t               sge_lo_addr;
	u_int32_t		sge_hi_addr;
d176 10
a185 4
int	arc_match(struct device *, void *, void *);
void	arc_attach(struct device *, struct device *, void *);
int	arc_detach(struct device *, int);
int	arc_intr(void *);
d223 1
a223 1
void			arc_minphys(struct buf *bp);
d278 1
d345 54
d404 45
d549 1
a549 1
	sc->sc_req_size = letoh32(fwinfo.request_len);
@


1.4
log
@tweak the hardware commands
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.3 2006/07/31 08:15:52 dlg Exp $ */
d21 1
d173 3
d215 12
d307 9
d335 15
@


1.3
log
@new pci ids for future controllers
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.2 2006/07/29 15:14:35 dlg Exp $ */
d124 1
a124 1
	u_int32_t	signature;
d126 8
a133 8
	u_int32_t	request_len;
	u_int32_t	queue_len;
	u_int32_t	sdram_size;
	u_int32_t	sata_ports;
	u_int8_t	vendor[40];
	u_int8_t	model[8];
	u_int8_t	fw_version[16];
	u_int8_t	device_map[16];
d156 2
a157 1
	u_int8_t		cdb[16];
d167 2
a169 1
	u_int32_t		sge_li_addr;
@


1.2
log
@not keeping the dma tag around means we panic when we try to use it during
allocation of dmaable memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc.c,v 1.1 2006/07/29 05:08:41 dlg Exp $ */
d61 5
a65 1
	{ PCI_VENDOR_ARECA,	PCI_PRODUCT_ARECA_ARC1280 }
@


1.1
log
@here's the real reason i removed the if_arc network goo: i wanted its name.

this is the start of a driver supporting the areca raid controllers. so far
it probes, attaches, establishes the interrupt, allocates all the necessary
memory and queries the firmware for operating params. the io path is yet to
be done. that is going to be hard to do since i dont have any sata disks to
plug into it.

thanks go to Billion Wu and Erich Chen from Areca for their assistance.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d314 1
a615 1

@

