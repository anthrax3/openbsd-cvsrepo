head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.44
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.42
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.30
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.38
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.36
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.34
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.32
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.28
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.26
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.24
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.22
	OPENBSD_5_0:1.9.0.20
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.18
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.16
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.12
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.14
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.10
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.8
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.6
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.18
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.16
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.14
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.12
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.10
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.8
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.6
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.8
	UBC:1.4.0.8
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	SMP:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.9
date	2006.12.17.22.18.16;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.04.00.34.28;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.26.20.04.50;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.01.11.26.32;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.27.00;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.18.04.37.21;	author nate;	state Exp;
branches
	1.4.4.1
	1.4.8.1;
next	1.3;

1.3
date	2000.10.14.18.04.07;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.04.16.00.56;	author ericj;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.03.19.30.23;	author mickey;	state Exp;
branches;
next	;

1.4.4.1
date	2001.05.14.22.25.58;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2002.03.28.15.35.59;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2003.03.28.00.38.25;	author niklas;	state Exp;
branches;
next	;

1.4.8.1
date	2002.06.11.03.42.27;	author art;	state Exp;
branches;
next	1.4.8.2;

1.4.8.2
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Remove unnecessary <dev/wscons/wscons_raster.h> inclusion.
@
text
@/* $OpenBSD: tgavar.h,v 1.8 2002/07/04 00:34:28 miod Exp $ */
/* $NetBSD: tgavar.h,v 1.8 2000/04/02 19:01:11 nathanw Exp $ */

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <dev/ic/ramdac.h>
#include <dev/pci/tgareg.h>
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>

struct tga_devconfig;
struct fbcmap;
struct fbcursor;
struct fbcurpos;

struct tga_conf {
	char	    *tgac_name;		/* name for this board type */

	struct ramdac_funcs *(*ramdac_funcs)(void);

	int	    tgac_phys_depth;	/* physical frame buffer depth */
	vsize_t   tgac_cspace_size;	/* core space size */
	vsize_t   tgac_vvbr_units;	/* what '1' in the VVBR means */

	int	    tgac_ndbuf;		/* number of display buffers */
	vaddr_t tgac_dbuf[2];		/* display buffer offsets/addresses */
	vsize_t   tgac_dbufsz[2];	/* display buffer sizes */

	int	    tgac_nbbuf;		/* number of display buffers */
	vaddr_t tgac_bbuf[2];		/* back buffer offsets/addresses */
	vsize_t   tgac_bbufsz[2];	/* back buffer sizes */
};

struct tga_devconfig {
	bus_space_tag_t dc_memt;
	bus_space_handle_t dc_memh;

	pcitag_t   	 dc_pcitag;	/* PCI tag */
	bus_addr_t	 dc_pcipaddr;	/* PCI phys addr. */

	bus_space_handle_t dc_regs;	/* registers; XXX: need aliases */

	int	    dc_tga_type;	/* the device type; see below */
	int	    dc_tga2;		/* True if it is a TGA2 */
	const struct tga_conf *dc_tgaconf; /* device buffer configuration */

	struct ramdac_funcs
		    *dc_ramdac_funcs;	/* The RAMDAC functions */
	struct ramdac_cookie
		    *dc_ramdac_cookie;	/* the RAMDAC type; see above */

	vaddr_t dc_vaddr;		/* memory space virtual base address */
	paddr_t dc_paddr;		/* memory space physical base address */

	int	    dc_wid;		/* width of frame buffer */
	int	    dc_ht;		/* height of frame buffer */
	int	    dc_rowbytes;	/* bytes in a FB scan line */

	vaddr_t dc_videobase;		/* base of flat frame buffer */

	struct rasops_info dc_rinfo;	/* raster display data */

	int	    dc_blanked;		/* currently had video disabled */
	void	    *dc_ramdac_private; /* RAMDAC private storage */

	void	    (*dc_ramdac_intr)(void *);
	int	    dc_intrenabled;	/* can we depend on interrupts yet? */
};
	
struct tga_softc {
	struct	device sc_dev;

	struct	tga_devconfig *sc_dc;	/* device configuration */
	void	*sc_intr;		/* interrupt handler info */
	u_int	sc_mode;	        /* wscons mode used */
	/* XXX should record intr fns/arg */

	int nscreens;
};

#define	TGA_TYPE_T8_01		0	/* 8bpp, 1MB */
#define	TGA_TYPE_T8_02		1	/* 8bpp, 2MB */
#define	TGA_TYPE_T8_22		2	/* 8bpp, 4MB */
#define	TGA_TYPE_T8_44		3	/* 8bpp, 8MB */
#define	TGA_TYPE_T32_04		4	/* 32bpp, 4MB */
#define	TGA_TYPE_T32_08		5	/* 32bpp, 8MB */
#define	TGA_TYPE_T32_88		6	/* 32bpp, 16MB */
#define	TGA_TYPE_POWERSTORM_4D20	7	/* unknown */
#define	TGA_TYPE_UNKNOWN	8	/* unknown */

#define	DEVICE_IS_TGA(class, id)					\
	    (((PCI_VENDOR(id) == PCI_VENDOR_DEC &&			\
	       PCI_PRODUCT(id) == PCI_PRODUCT_DEC_21030) ||		\
	       PCI_PRODUCT(id) == PCI_PRODUCT_DEC_PBXGB) ? 10 : 0)

int tga_cnattach(bus_space_tag_t, bus_space_tag_t, pci_chipset_tag_t,
		      int, int, int);

int	tga_identify(struct tga_devconfig *);
const struct tga_conf *tga_getconf(int);

int     tga_builtin_set_cursor(struct tga_devconfig *,
	    struct wsdisplay_cursor *);
int     tga_builtin_get_cursor(struct tga_devconfig *,
	    struct wsdisplay_cursor *);
int     tga_builtin_set_curpos(struct tga_devconfig *,
	    struct wsdisplay_curpos *);
int     tga_builtin_get_curpos(struct tga_devconfig *,
	    struct wsdisplay_curpos *);
int     tga_builtin_get_curmax(struct tga_devconfig *,
	    struct wsdisplay_curpos *);

/* Read a TGA register */
#define TGARREG(dc,reg) (bus_space_read_4((dc)->dc_memt, (dc)->dc_regs, \
	(reg) << 2))

/* Write a TGA register */
#define TGAWREG(dc,reg,val) bus_space_write_4((dc)->dc_memt, (dc)->dc_regs, \
	(reg) << 2, (val))

/* Write a TGA register at an alternate aliased location */
#define TGAWALREG(dc,reg,alias,val) bus_space_write_4( \
	(dc)->dc_memt, (dc)->dc_regs, \
	((alias) * TGA_CREGS_ALIAS) + ((reg) << 2), \
	(val))

/* Insert a write barrier */
#define TGAREGWB(dc,reg, nregs) bus_space_barrier( \
	(dc)->dc_memt, (dc)->dc_regs, \
	((reg) << 2), 4 * (nregs), BUS_SPACE_BARRIER_WRITE)

/* Insert a read barrier */
#define TGAREGRB(dc,reg, nregs) bus_space_barrier( \
	(dc)->dc_memt, (dc)->dc_regs, \
	((reg) << 2), 4 * (nregs), BUS_SPACE_BARRIER_READ)

/* Insert a read/write barrier */
#define TGAREGRWB(dc,reg, nregs) bus_space_barrier( \
	(dc)->dc_memt, (dc)->dc_regs, \
	((reg) << 2), 4 * (nregs), \
	BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE)
@


1.8
log
@Various tga hacks:
- some KNF touches
- use simpler constructs
- do not forget to make use of the tga interrupt when it is enabled (speeds
  up X11 startup and shutdown, hi matthieu!)
- implement the wscons screen burner facility
@
text
@d1 1
a1 1
/* $OpenBSD: tgavar.h,v 1.7 2002/04/26 20:04:50 matthieu Exp $ */
a33 1
#include <dev/wscons/wscons_raster.h>
@


1.7
log
@Add support for the WSDISPLAYIO_LINEBYTES ioctl and the
WSDISPLAYIO_MODE_DUMBFB  mode (mode where mmapping /dev/ttyC0 maps
the framebuffer only)
This makes the XF4 wsfb driver work on the TGA cards.
Ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: tgavar.h,v 1.6 2002/04/01 11:26:32 matthieu Exp $ */
d53 1
a53 1
	vaddr_t tgac_dbuf[2];	/* display buffer offsets/addresses */
d57 1
a57 1
	vaddr_t tgac_bbuf[2];	/* back buffer offsets/addresses */
d86 1
a86 1
	vaddr_t dc_videobase;	/* base of flat frame buffer */
d94 1
a94 1
	int		dc_intrenabled; /* can we depend on interrupts yet? */
@


1.6
log
@Add support for PowerStorm 4D20 TGA boqrds with IBM 561 ramdac (aka
32bit TGA) From NetBSD, ok deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: tgavar.h,v 1.5 2002/03/14 01:27:00 millert Exp $ */
d102 1
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: tgavar.h,v 1.4 2001/03/18 04:37:21 nate Exp $ */
d114 2
a115 1
#define	TGA_TYPE_UNKNOWN	7	/* unknown */
@


1.4
log
@New TGA driver for alpha.  Takes advantage of rasops code.
This now gives a working console on alpha when using TGA.
Code from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: tgavar.h,v 1.3 2000/10/14 18:04:07 aaron Exp $ */
d46 1
a46 1
	struct ramdac_funcs *(*ramdac_funcs) __P((void));
d93 1
a93 1
	void	    (*dc_ramdac_intr) __P((void *));
d121 2
a122 2
int tga_cnattach __P((bus_space_tag_t, bus_space_tag_t, pci_chipset_tag_t,
		      int, int, int));
d124 2
a125 2
int	tga_identify __P((struct tga_devconfig *));
const struct tga_conf *tga_getconf __P((int));
d127 10
a136 10
int     tga_builtin_set_cursor __P((struct tga_devconfig *,
	    struct wsdisplay_cursor *));
int     tga_builtin_get_cursor __P((struct tga_devconfig *,
	    struct wsdisplay_cursor *));
int     tga_builtin_set_curpos __P((struct tga_devconfig *,
	    struct wsdisplay_curpos *));
int     tga_builtin_get_curpos __P((struct tga_devconfig *,
	    struct wsdisplay_curpos *));
int     tga_builtin_get_curmax __P((struct tga_devconfig *,
	    struct wsdisplay_curpos *));
@


1.4.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: tgavar.h,v 1.4 2001/03/18 04:37:21 nate Exp $ */
d46 1
a46 1
	struct ramdac_funcs *(*ramdac_funcs)(void);
d93 1
a93 1
	void	    (*dc_ramdac_intr)(void *);
a101 1
	u_int	sc_mode;	        /* wscons mode used */
d114 1
a114 2
#define	TGA_TYPE_POWERSTORM_4D20	7	/* unknown */
#define	TGA_TYPE_UNKNOWN	8	/* unknown */
d121 2
a122 2
int tga_cnattach(bus_space_tag_t, bus_space_tag_t, pci_chipset_tag_t,
		      int, int, int);
d124 2
a125 2
int	tga_identify(struct tga_devconfig *);
const struct tga_conf *tga_getconf(int);
d127 10
a136 10
int     tga_builtin_set_cursor(struct tga_devconfig *,
	    struct wsdisplay_cursor *);
int     tga_builtin_get_cursor(struct tga_devconfig *,
	    struct wsdisplay_cursor *);
int     tga_builtin_set_curpos(struct tga_devconfig *,
	    struct wsdisplay_curpos *);
int     tga_builtin_get_curpos(struct tga_devconfig *,
	    struct wsdisplay_curpos *);
int     tga_builtin_get_curmax(struct tga_devconfig *,
	    struct wsdisplay_curpos *);
@


1.4.8.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: tgavar.h,v 1.4.8.1 2002/06/11 03:42:27 art Exp $ */
d53 1
a53 1
	vaddr_t tgac_dbuf[2];		/* display buffer offsets/addresses */
d57 1
a57 1
	vaddr_t tgac_bbuf[2];		/* back buffer offsets/addresses */
d86 1
a86 1
	vaddr_t dc_videobase;		/* base of flat frame buffer */
d94 1
a94 1
	int	    dc_intrenabled;	/* can we depend on interrupts yet? */
@


1.4.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: tgavar.h,v 1.4 2001/03/18 04:37:21 nate Exp $ */
@


1.4.4.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d46 1
a46 1
	struct ramdac_funcs *(*ramdac_funcs)(void);
d93 1
a93 1
	void	    (*dc_ramdac_intr)(void *);
d121 2
a122 2
int tga_cnattach(bus_space_tag_t, bus_space_tag_t, pci_chipset_tag_t,
		      int, int, int);
d124 2
a125 2
int	tga_identify(struct tga_devconfig *);
const struct tga_conf *tga_getconf(int);
d127 10
a136 10
int     tga_builtin_set_cursor(struct tga_devconfig *,
	    struct wsdisplay_cursor *);
int     tga_builtin_get_cursor(struct tga_devconfig *,
	    struct wsdisplay_cursor *);
int     tga_builtin_set_curpos(struct tga_devconfig *,
	    struct wsdisplay_curpos *);
int     tga_builtin_get_curpos(struct tga_devconfig *,
	    struct wsdisplay_curpos *);
int     tga_builtin_get_curmax(struct tga_devconfig *,
	    struct wsdisplay_curpos *);
@


1.4.4.3
log
@Sync the SMP branch with 3.3
@
text
@d53 1
a53 1
	vaddr_t tgac_dbuf[2];		/* display buffer offsets/addresses */
d57 1
a57 1
	vaddr_t tgac_bbuf[2];		/* back buffer offsets/addresses */
d86 1
a86 1
	vaddr_t dc_videobase;		/* base of flat frame buffer */
d94 1
a94 1
	int	    dc_intrenabled;	/* can we depend on interrupts yet? */
a101 1
	u_int	sc_mode;	        /* wscons mode used */
d114 1
a114 2
#define	TGA_TYPE_POWERSTORM_4D20	7	/* unknown */
#define	TGA_TYPE_UNKNOWN	8	/* unknown */
@


1.3
log
@Add $OpenBSD$ tags.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a32 1
#include <dev/rcons/raster.h>
d35 2
d44 1
a44 1
        char            *tgac_name;                /* name for this board type */
d46 1
a46 1
        struct ramdac_funcs *(*ramdac_funcs) __P((void));
d48 3
a50 3
        int            tgac_phys_depth;        /* physical frame buffer depth */
        vsize_t   tgac_cspace_size;        /* core space size */
        vsize_t   tgac_vvbr_units;        /* what '1' in the VVBR means */
d52 3
a54 3
        int            tgac_ndbuf;                /* number of display buffers */
        vaddr_t tgac_dbuf[2];        /* display buffer offsets/addresses */
        vsize_t   tgac_dbufsz[2];        /* display buffer sizes */
d56 3
a58 3
        int            tgac_nbbuf;                /* number of display buffers */
        vaddr_t tgac_bbuf[2];        /* back buffer offsets/addresses */
        vsize_t   tgac_bbufsz[2];        /* back buffer sizes */
d62 2
a63 23
        bus_space_tag_t dc_memt;
	pci_chipset_tag_t dc_pc;
        pcitag_t            dc_pcitag;        /* PCI tag */
        bus_addr_t         dc_pcipaddr;        /* PCI phys addr. */

	tga_reg_t   *dc_regs;                /* registers; XXX: need aliases */
        int            dc_tga_type;        /* the device type; see below */
        int            dc_tga2;                /* True if it is a TGA2 */
        const struct tga_conf *dc_tgaconf; /* device buffer configuration */

        struct ramdac_funcs
                    *dc_ramdac_funcs;        /* The RAMDAC functions */
        struct ramdac_cookie
                    *dc_ramdac_cookie;        /* the RAMDAC type; see above */

        vaddr_t dc_vaddr;                /* memory space virtual base address */
        paddr_t dc_paddr;                /* memory space physical base address */

        int            dc_wid;                /* width of frame buffer */
        int            dc_ht;                /* height of frame buffer */
        int            dc_rowbytes;        /* bytes in a FB scan line */

        vaddr_t dc_videobase;        /* base of flat frame buffer */
d65 2
a66 2
        struct raster        dc_raster;        /* raster description */
        struct rcons        dc_rcons;        /* raster blitter control info */
d68 1
a68 2
        int            dc_blanked;                /* currently had video disabled */
        void            *dc_ramdac_private; /* RAMDAC private storage */
d70 25
a94 2
        void            (*dc_ramdac_intr) __P((void *));
        int                dc_intrenabled; /* can we depend on interrupts yet? */
d96 1
a96 1
        
d98 1
a98 1
        struct        device sc_dev;
d100 3
a102 3
        struct        tga_devconfig *sc_dc;        /* device configuration */
        void        *sc_intr;                /* interrupt handler info */
        /* XXX should record intr fns/arg */
d104 1
a104 1
        int nscreens;
d107 13
a119 13
#define TGA_TYPE_T8_01                0        /* 8bpp, 1MB */
#define TGA_TYPE_T8_02                1        /* 8bpp, 2MB */
#define TGA_TYPE_T8_22                2        /* 8bpp, 4MB */
#define TGA_TYPE_T8_44                3        /* 8bpp, 8MB */
#define TGA_TYPE_T32_04                4        /* 32bpp, 4MB */
#define TGA_TYPE_T32_08                5        /* 32bpp, 8MB */
#define TGA_TYPE_T32_88                6        /* 32bpp, 16MB */
#define TGA_TYPE_UNKNOWN        7        /* unknown */

#define DEVICE_IS_TGA(class, id)                                        \
            (((PCI_VENDOR(id) == PCI_VENDOR_DEC &&                        \
               PCI_PRODUCT(id) == PCI_PRODUCT_DEC_21030) ||                \
               PCI_PRODUCT(id) == PCI_PRODUCT_DEC_PBXGB) ? 10 : 0)
d122 1
a122 1
                      int, int, int));
d124 1
a124 1
int     tga_identify __P((tga_reg_t *));
d128 1
a128 1
            struct wsdisplay_cursor *));
d130 1
a130 1
            struct wsdisplay_cursor *));
d132 1
a132 1
            struct wsdisplay_curpos *));
d134 1
a134 1
            struct wsdisplay_curpos *));
d136 31
a166 1
            struct wsdisplay_curpos *));
@


1.2
log
@
add support for tga2; from NetBSD
@
text
@d1 1
@


1.1
log
@closer approximation to an alpha using new wscons.
tga moved to dev/pci.
by request from alpha people.
@
text
@d1 1
a1 1
/* $NetBSD: tgavar.h,v 1.4 1998/08/18 08:23:46 thorpej Exp $ */
d30 1
d41 8
a48 27
struct tga_ramdac_conf {
	char	*tgar_name;
	void	(*tgar_init) __P((struct tga_devconfig *, int));
	int	(*tgar_intr) __P((void *));
	int	(*tgar_set_cmap) __P((struct tga_devconfig *,
		    struct wsdisplay_cmap *));
	int	(*tgar_get_cmap) __P((struct tga_devconfig *,
		    struct wsdisplay_cmap *));
	int	(*tgar_set_cursor) __P((struct tga_devconfig *,
		    struct wsdisplay_cursor *));
	int	(*tgar_get_cursor) __P((struct tga_devconfig *,
		    struct wsdisplay_cursor *));
	int	(*tgar_set_curpos) __P((struct tga_devconfig *,
		    struct wsdisplay_curpos *));
	int	(*tgar_get_curpos) __P((struct tga_devconfig *,
		    struct wsdisplay_curpos *));
	int	(*tgar_get_curmax) __P((struct tga_devconfig *,
		    struct wsdisplay_curpos *));

	/* Only called from the TGA built-in cursor handling code. */
	int	(*tgar_check_curcmap) __P((struct tga_devconfig *,
		    struct wsdisplay_cursor *));
	void	(*tgar_set_curcmap) __P((struct tga_devconfig *,
		    struct wsdisplay_cursor *));
	int	(*tgar_get_curcmap) __P((struct tga_devconfig *,
		    struct wsdisplay_cursor *));
};
d50 3
a52 2
struct tga_conf {
	char	    *tgac_name;		/* name for this board type */
d54 3
a56 13
	const struct tga_ramdac_conf
		    *tgac_ramdac;	/* the RAMDAC type; see above */
	int	    tgac_phys_depth;	/* physical frame buffer depth */
	vsize_t   tgac_cspace_size;	/* core space size */
	vsize_t   tgac_vvbr_units;	/* what '1' in the VVBR means */

	int	    tgac_ndbuf;		/* number of display buffers */
	vaddr_t tgac_dbuf[2];	/* display buffer offsets/addresses */
	vsize_t   tgac_dbufsz[2];	/* display buffer sizes */

	int	    tgac_nbbuf;		/* number of display buffers */
	vaddr_t tgac_bbuf[2];	/* back buffer offsets/addresses */
	vsize_t   tgac_bbufsz[2];	/* back buffer sizes */
d60 1
a60 1
	bus_space_tag_t dc_memt;
d62 2
d65 4
a68 2
	pcitag_t   	 dc_pcitag;	/* PCI tag */
	bus_addr_t	 dc_pcipaddr;	/* PCI phys addr. */
d70 4
a73 1
	tga_reg_t   *dc_regs;		/* registers; XXX: need aliases */
d75 2
a76 2
	int	    dc_tga_type;	/* the device type; see below */
	const struct tga_conf *dc_tgaconf; /* device buffer configuration */
d78 3
a80 2
	vaddr_t dc_vaddr;		/* memory space virtual base address */
	paddr_t dc_paddr;		/* memory space physical base address */
d82 1
a82 3
	int	    dc_wid;		/* width of frame buffer */
	int	    dc_ht;		/* height of frame buffer */
	int	    dc_rowbytes;	/* bytes in a FB scan line */
d84 2
a85 1
	vaddr_t dc_videobase;	/* base of flat frame buffer */
d87 2
a88 2
	struct raster	dc_raster;	/* raster description */
	struct rcons	dc_rcons;	/* raster blitter control info */
d90 2
a91 2
	int	    dc_blanked;		/* currently had video disabled */
	void	    *dc_ramdac_private; /* RAMDAC private storage */
d93 1
a93 1
	
d95 1
a95 1
	struct	device sc_dev;
d97 3
a99 3
	struct	tga_devconfig *sc_dc;	/* device configuration */
	void	*sc_intr;		/* interrupt handler info */
	/* XXX should record intr fns/arg */
d101 1
a101 1
	int nscreens;
d104 13
a116 12
#define	TGA_TYPE_T8_01		0	/* 8bpp, 1MB */
#define	TGA_TYPE_T8_02		1	/* 8bpp, 2MB */
#define	TGA_TYPE_T8_22		2	/* 8bpp, 4MB */
#define	TGA_TYPE_T8_44		3	/* 8bpp, 8MB */
#define	TGA_TYPE_T32_04		4	/* 32bpp, 4MB */
#define	TGA_TYPE_T32_08		5	/* 32bpp, 8MB */
#define	TGA_TYPE_T32_88		6	/* 32bpp, 16MB */
#define	TGA_TYPE_UNKNOWN	7	/* unknown */

#define	DEVICE_IS_TGA(class, id)					\
	    ((PCI_VENDOR(id) == PCI_VENDOR_DEC &&			\
	     PCI_PRODUCT(id) == PCI_PRODUCT_DEC_21030) ? 10 : 0)
d119 1
a119 1
		      int, int, int));
d121 1
a121 1
int	tga_identify __P((tga_reg_t *));
a123 3
extern const struct tga_ramdac_conf tga_ramdac_bt463;
extern const struct tga_ramdac_conf tga_ramdac_bt485;

d125 1
a125 1
	    struct wsdisplay_cursor *));
d127 1
a127 1
	    struct wsdisplay_cursor *));
d129 1
a129 1
	    struct wsdisplay_curpos *));
d131 1
a131 1
	    struct wsdisplay_curpos *));
d133 1
a133 1
	    struct wsdisplay_curpos *));
@

