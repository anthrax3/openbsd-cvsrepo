head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.2
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.4
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.10
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.14
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.12
	OPENBSD_5_0:1.3.0.10
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.8
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.6
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.14
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.12
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.10
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.8
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.6
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.4
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.2
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.1.0.2
	OPENBSD_3_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2016.03.19.11.34.22;	author mpi;	state Exp;
branches;
next	1.5;
commitid	15xZY6veDWwRM6Iq;

1.5
date	2014.12.10.12.27.57;	author mikeb;	state Exp;
branches;
next	1.4;
commitid	v6PAeA18rydwc5Vx;

1.4
date	2012.10.17.22.32.01;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.17.21.05.50;	author grange;	state Exp;
branches;
next	1.1;

1.1
date	2005.05.02.17.26.00;	author grange;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Reduces the noise around the global ``ticks'' variable by renaming
all the local ones to ``nticks''.

ok stefan@@, deraadt@@
@
text
@/*	$OpenBSD: ichwdt.c,v 1.5 2014/12/10 12:27:57 mikeb Exp $	*/

/*
 * Copyright (c) 2004, 2005 Alexander Yurchenko <grange@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Intel 6300ESB ICH watchdog timer driver.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/pci/ichreg.h>

#ifdef ICHWDT_DEBUG
#define DPRINTF(x) printf x
#else
#define DPRINTF(x)
#endif

struct ichwdt_softc {
	struct device sc_dev;

	pci_chipset_tag_t sc_pc;
	pcitag_t sc_tag;

	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;

	int sc_divisor;
	int sc_period;
};

int	ichwdt_match(struct device *, void *, void *);
void	ichwdt_attach(struct device *, struct device *, void *);
int	ichwdt_activate(struct device *, int);

int	ichwdt_cb(void *, int);

struct cfattach ichwdt_ca = {
	sizeof(struct ichwdt_softc),
	ichwdt_match,
	ichwdt_attach,
	NULL,
	ichwdt_activate
};

struct cfdriver ichwdt_cd = {
	NULL, "ichwdt", DV_DULL
};

const struct pci_matchid ichwdt_devices[] = {
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_6300ESB_WDT }
};

static __inline void
ichwdt_unlock_write(struct ichwdt_softc *sc, int reg, u_int32_t val)
{
	/* Register unlocking sequence */
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, ICH_WDT_RELOAD, 0x80);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, ICH_WDT_RELOAD, 0x86);

	/* Now it's possible to write to the register */
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, reg, val);
}

int
ichwdt_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, ichwdt_devices,
	    sizeof(ichwdt_devices) / sizeof(ichwdt_devices[0])));
}

void
ichwdt_attach(struct device *parent, struct device *self, void *aux)
{
	struct ichwdt_softc *sc = (struct ichwdt_softc *)self;
	struct pci_attach_args *pa = aux;
	u_int32_t reg;

	sc->sc_pc = pa->pa_pc;
	sc->sc_tag = pa->pa_tag;

	/* Map memory space */
	sc->sc_iot = pa->pa_iot;
	if (pci_mapreg_map(pa, ICH_WDT_BASE, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->sc_iot, &sc->sc_ioh, NULL, NULL, 0)) {
		printf(": can't map mem space\n");
		return;
	}

	/* Read current configuration */
	reg = pci_conf_read(sc->sc_pc, sc->sc_tag, ICH_WDT_CONF);
	DPRINTF((": conf 0x%x", reg));

	/* Get clock divisor */
	sc->sc_divisor = (reg & ICH_WDT_CONF_PRE ? 32 : 32768);
	printf(": %s clock", (reg & ICH_WDT_CONF_PRE ? "1MHz" : "1kHz"));

	/* Disable interrupts since we don't use first stage timeout alarm */
	reg &= ~ICH_WDT_CONF_INT_MASK;
	reg |= ICH_WDT_CONF_INT_DIS;
	pci_conf_write(sc->sc_pc, sc->sc_tag, ICH_WDT_CONF, reg);

	/* Check for reboot on timeout */
	reg = bus_space_read_4(sc->sc_iot, sc->sc_ioh, ICH_WDT_RELOAD);
	if (reg & ICH_WDT_RELOAD_TIMEOUT) {
		printf(": reboot on timeout");

		/* Clear timeout bit */
		ichwdt_unlock_write(sc, ICH_WDT_RELOAD,
		    ICH_WDT_RELOAD_TIMEOUT);
	}

	/* Disable watchdog */
	pci_conf_write(sc->sc_pc, sc->sc_tag, ICH_WDT_LOCK, 0);
	sc->sc_period = 0;
	
	printf("\n");

	/* Register new watchdog */
	wdog_register(ichwdt_cb, sc);
}

int
ichwdt_activate(struct device *self, int act)
{
	switch (act) {
	case DVACT_POWERDOWN:
		wdog_shutdown(self);
		break;
	}

	return (0);
}

int
ichwdt_cb(void *arg, int period)
{
	struct ichwdt_softc *sc = arg;
	int nticks;

	if (period == 0) {
		if (sc->sc_period != 0) {
			/* Disable watchdog */
			ichwdt_unlock_write(sc, ICH_WDT_RELOAD,
			    ICH_WDT_RELOAD_RLD);
			pci_conf_write(sc->sc_pc, sc->sc_tag, ICH_WDT_LOCK, 0);
			DPRINTF(("%s: disabled, conf 0x%x\n",
			    sc->sc_dev.dv_xname,
			    pci_conf_read(sc->sc_pc, sc->sc_tag,
			    ICH_WDT_LOCK)));
		}
	} else {
		/* 1000s should be enough for everyone */
		if (period > 1000)
			period = 1000;

		if (sc->sc_period != period) {
			/* Set new timeout */
			nticks = (period * 33000000) / sc->sc_divisor;
			ichwdt_unlock_write(sc, ICH_WDT_PRE1, nticks);
			ichwdt_unlock_write(sc, ICH_WDT_PRE2, 2);
			DPRINTF(("%s: timeout %ds (%d nticks)\n",
			    sc->sc_dev.dv_xname, period, nticks));
		}
		if (sc->sc_period == 0) {
			/* Enable watchdog */
			pci_conf_write(sc->sc_pc, sc->sc_tag, ICH_WDT_LOCK,
			    ICH_WDT_LOCK_ENABLED);
			DPRINTF(("%s: enabled, conf 0x%x\n",
			    sc->sc_dev.dv_xname,
			    pci_conf_read(sc->sc_pc, sc->sc_tag,
			    ICH_WDT_LOCK)));
		} else {
			/* Reset timer */
			ichwdt_unlock_write(sc, ICH_WDT_RELOAD,
			    ICH_WDT_RELOAD_RLD);
			DPRINTF(("%s: reloaded\n", sc->sc_dev.dv_xname));
		}
	}
	sc->sc_period = period;

	return (period);
}
@


1.5
log
@Convert watchdog(4) devices to use autoconf(9) framework.

ok deraadt, tests on glxpcib and ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ichwdt.c,v 1.4 2012/10/17 22:32:01 deraadt Exp $	*/
d161 1
a161 1
	int ticks;
d181 2
a182 2
			ticks = (period * 33000000) / sc->sc_divisor;
			ichwdt_unlock_write(sc, ICH_WDT_PRE1, ticks);
d184 2
a185 2
			DPRINTF(("%s: timeout %ds (%d ticks)\n",
			    sc->sc_dev.dv_xname, period, ticks));
@


1.4
log
@Swap arguments to wdog_register() since it is nicer, and prepare
wdog_shutdown() for external usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichwdt.c,v 1.3 2009/03/29 21:53:52 sthen Exp $	*/
d56 1
d63 3
a65 1
	ichwdt_attach
d143 12
@


1.3
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichwdt.c,v 1.2 2005/12/17 21:05:50 grange Exp $	*/
d139 1
a139 1
	wdog_register(sc, ichwdt_cb);
@


1.2
log
@This driver had no chances to work. Still has some issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichwdt.c,v 1.1 2005/05/02 17:26:00 grange Exp $	*/
d105 1
a105 1
		printf(": failed to map memory space\n");
@


1.1
log
@Add ichwdt(4): Intel 6300ESB ICH watchdog timer driver. Disabled for
now due to lack of testing. If you have a machine that uses this
device please contact me.

ok deraadt@@
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 2004 Alexander Yurchenko <grange@@openbsd.org>
a34 2
#define ICHWDT_DEBUG

d36 1
a36 1
#define DPRINTF(fmt, args...) printf(fmt, ##args)
d38 1
a38 1
#define DPRINTF(fmt, args...)
a49 1
	int sc_enabled;
d51 1
d109 1
d111 5
a115 1
	DPRINTF(": conf 0x%x", reg);
d117 1
a117 1
	/* Disable interrupts for now */
d120 1
d122 1
a122 2
	sc->sc_divisor = (reg & ICH_WDT_CONF_PRE ? 2 ^ 5 : 2 ^ 15);

d126 4
a129 1
		ichwdt_unlock_write(sc, ICH_WDT_RELOAD, reg);
d132 4
d146 1
a146 1
	pcireg_t reg;
d149 10
a158 4
		/* Disable watchdog timer */
		reg = pci_conf_read(sc->sc_pc, sc->sc_tag, ICH_WDT_LOCK);
		reg &= ~ICH_WDT_LOCK_ENABLED;
		pci_conf_write(sc->sc_pc, sc->sc_tag, ICH_WDT_LOCK, reg);
d160 26
a185 8
		/* Reset watchdog timer */
		ichwdt_unlock_write(sc, ICH_WDT_PRE1, 1);
		ichwdt_unlock_write(sc, ICH_WDT_PRE2, 1);

		reg = pci_conf_read(sc->sc_pc, sc->sc_tag, ICH_WDT_LOCK);
		reg &= ~ICH_WDT_LOCK_FREERUN;
		reg |= ICH_WDT_LOCK_ENABLED;
		pci_conf_write(sc->sc_pc, sc->sc_tag, ICH_WDT_LOCK, reg);
d187 1
@

