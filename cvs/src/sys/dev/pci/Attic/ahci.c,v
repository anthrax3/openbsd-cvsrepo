head	1.197;
access;
symbols
	OPENBSD_5_2:1.192.0.2
	OPENBSD_5_2_BASE:1.192
	OPENBSD_5_1_BASE:1.186
	OPENBSD_5_1:1.186.0.2
	OPENBSD_5_0:1.181.0.2
	OPENBSD_5_0_BASE:1.181
	OPENBSD_4_9:1.172.0.2
	OPENBSD_4_9_BASE:1.172
	OPENBSD_4_8:1.168.0.2
	OPENBSD_4_8_BASE:1.168
	OPENBSD_4_7:1.160.0.2
	OPENBSD_4_7_BASE:1.160
	OPENBSD_4_6:1.147.0.6
	OPENBSD_4_6_BASE:1.147
	OPENBSD_4_5:1.147.0.2
	OPENBSD_4_5_BASE:1.147
	OPENBSD_4_4:1.140.0.2
	OPENBSD_4_4_BASE:1.140
	OPENBSD_4_3:1.136.0.2
	OPENBSD_4_3_BASE:1.136
	OPENBSD_4_2:1.128.0.2
	OPENBSD_4_2_BASE:1.128
	OPENBSD_4_1:1.77.0.2
	OPENBSD_4_1_BASE:1.77;
locks; strict;
comment	@ * @;


1.197
date	2013.01.21.11.17.48;	author patrick;	state dead;
branches;
next	1.196;

1.196
date	2013.01.17.02.36.45;	author deraadt;	state Exp;
branches;
next	1.195;

1.195
date	2013.01.17.00.08.13;	author claudio;	state Exp;
branches;
next	1.194;

1.194
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.193;

1.193
date	2012.08.11.13.52.27;	author jmatthew;	state Exp;
branches;
next	1.192;

1.192
date	2012.07.02.13.24.53;	author jmatthew;	state Exp;
branches;
next	1.191;

1.191
date	2012.06.29.22.21.40;	author jmatthew;	state Exp;
branches;
next	1.190;

1.190
date	2012.06.28.10.23.21;	author sthen;	state Exp;
branches;
next	1.189;

1.189
date	2012.06.05.03.36.37;	author jmatthew;	state Exp;
branches;
next	1.188;

1.188
date	2012.05.05.10.10.12;	author sthen;	state Exp;
branches;
next	1.187;

1.187
date	2012.04.13.11.33.12;	author sasano;	state Exp;
branches;
next	1.186;

1.186
date	2012.02.04.21.44.54;	author krw;	state Exp;
branches;
next	1.185;

1.185
date	2011.11.14.00.25.17;	author mlarkin;	state Exp;
branches;
next	1.184;

1.184
date	2011.10.27.08.03.50;	author jmatthew;	state Exp;
branches;
next	1.183;

1.183
date	2011.10.26.10.59.00;	author jmatthew;	state Exp;
branches;
next	1.182;

1.182
date	2011.08.20.20.16.01;	author kettenis;	state Exp;
branches;
next	1.181;

1.181
date	2011.07.04.22.06.07;	author jmatthew;	state Exp;
branches;
next	1.180;

1.180
date	2011.06.14.10.40.14;	author jmatthew;	state Exp;
branches;
next	1.179;

1.179
date	2011.06.02.16.50.05;	author krw;	state Exp;
branches;
next	1.178;

1.178
date	2011.05.08.19.46.10;	author matthew;	state Exp;
branches;
next	1.177;

1.177
date	2011.04.24.11.09.48;	author dlg;	state Exp;
branches;
next	1.176;

1.176
date	2011.04.21.07.13.01;	author dlg;	state Exp;
branches;
next	1.175;

1.175
date	2011.04.21.02.37.31;	author dlg;	state Exp;
branches;
next	1.174;

1.174
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.173;

1.173
date	2011.04.03.17.04.19;	author krw;	state Exp;
branches;
next	1.172;

1.172
date	2011.01.28.06.32.31;	author dlg;	state Exp;
branches;
next	1.171;

1.171
date	2011.01.28.06.30.04;	author dlg;	state Exp;
branches;
next	1.170;

1.170
date	2011.01.26.21.41.00;	author drahn;	state Exp;
branches;
next	1.169;

1.169
date	2010.08.31.17.13.44;	author deraadt;	state Exp;
branches;
next	1.168;

1.168
date	2010.07.03.00.23.36;	author kettenis;	state Exp;
branches;
next	1.167;

1.167
date	2010.07.02.05.20.17;	author jsg;	state Exp;
branches;
next	1.166;

1.166
date	2010.06.29.18.57.53;	author kettenis;	state Exp;
branches;
next	1.165;

1.165
date	2010.05.24.04.40.14;	author dlg;	state Exp;
branches;
next	1.164;

1.164
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.163;

1.163
date	2010.04.16.22.15.39;	author kettenis;	state Exp;
branches;
next	1.162;

1.162
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.161;

1.161
date	2010.04.06.13.59.37;	author dlg;	state Exp;
branches;
next	1.160;

1.160
date	2010.03.15.19.54.54;	author drahn;	state Exp;
branches;
next	1.159;

1.159
date	2010.03.15.11.05.43;	author krw;	state Exp;
branches;
next	1.158;

1.158
date	2010.01.21.10.16.44;	author sthen;	state Exp;
branches;
next	1.157;

1.157
date	2010.01.10.13.19.02;	author grange;	state Exp;
branches;
next	1.156;

1.156
date	2009.12.28.01.36.12;	author krw;	state Exp;
branches;
next	1.155;

1.155
date	2009.12.08.08.41.59;	author dlg;	state Exp;
branches;
next	1.154;

1.154
date	2009.12.07.09.37.34;	author dlg;	state Exp;
branches;
next	1.153;

1.153
date	2009.11.01.01.50.15;	author dlg;	state Exp;
branches;
next	1.152;

1.152
date	2009.10.24.14.31.49;	author dlg;	state Exp;
branches;
next	1.151;

1.151
date	2009.10.17.21.44.00;	author jsg;	state Exp;
branches;
next	1.150;

1.150
date	2009.10.13.00.19.38;	author sthen;	state Exp;
branches;
next	1.149;

1.149
date	2009.10.05.11.49.26;	author deraadt;	state Exp;
branches;
next	1.148;

1.148
date	2009.09.13.13.26.39;	author matthieu;	state Exp;
branches;
next	1.147;

1.147
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.146;

1.146
date	2009.01.21.21.54.00;	author grange;	state Exp;
branches;
next	1.145;

1.145
date	2008.12.13.11.49.54;	author mikeb;	state Exp;
branches;
next	1.144;

1.144
date	2008.12.07.22.37.05;	author mikeb;	state Exp;
branches;
next	1.143;

1.143
date	2008.11.22.17.31.38;	author mikeb;	state Exp;
branches;
next	1.142;

1.142
date	2008.09.17.06.18.45;	author brad;	state Exp;
branches;
next	1.141;

1.141
date	2008.09.17.06.14.09;	author brad;	state Exp;
branches;
next	1.140;

1.140
date	2008.05.31.23.50.32;	author dlg;	state Exp;
branches;
next	1.139;

1.139
date	2008.04.19.01.18.39;	author djm;	state Exp;
branches;
next	1.138;

1.138
date	2008.04.08.19.30.09;	author kettenis;	state Exp;
branches;
next	1.137;

1.137
date	2008.04.08.12.20.31;	author jsg;	state Exp;
branches;
next	1.136;

1.136
date	2007.11.28.16.01.34;	author dlg;	state Exp;
branches;
next	1.135;

1.135
date	2007.11.28.13.47.09;	author dlg;	state Exp;
branches;
next	1.134;

1.134
date	2007.11.26.15.59.53;	author dlg;	state Exp;
branches;
next	1.133;

1.133
date	2007.11.19.01.18.48;	author pascoe;	state Exp;
branches;
next	1.132;

1.132
date	2007.11.05.07.06.02;	author dlg;	state Exp;
branches;
next	1.131;

1.131
date	2007.11.04.01.38.54;	author dlg;	state Exp;
branches;
next	1.130;

1.130
date	2007.10.27.10.51.21;	author dlg;	state Exp;
branches;
next	1.129;

1.129
date	2007.10.01.15.34.48;	author krw;	state Exp;
branches;
next	1.128;

1.128
date	2007.07.03.22.33.20;	author dlg;	state Exp;
branches;
next	1.127;

1.127
date	2007.07.03.22.28.14;	author dlg;	state Exp;
branches;
next	1.126;

1.126
date	2007.07.02.14.01.13;	author dlg;	state Exp;
branches;
next	1.125;

1.125
date	2007.07.02.01.29.54;	author dlg;	state Exp;
branches;
next	1.124;

1.124
date	2007.07.02.00.52.25;	author dlg;	state Exp;
branches;
next	1.123;

1.123
date	2007.07.02.00.46.22;	author dlg;	state Exp;
branches;
next	1.122;

1.122
date	2007.06.29.01.27.10;	author dlg;	state Exp;
branches;
next	1.121;

1.121
date	2007.06.29.01.06.17;	author dlg;	state Exp;
branches;
next	1.120;

1.120
date	2007.06.29.01.00.38;	author dlg;	state Exp;
branches;
next	1.119;

1.119
date	2007.06.12.12.09.15;	author grange;	state Exp;
branches;
next	1.118;

1.118
date	2007.05.30.03.55.19;	author tedu;	state Exp;
branches;
next	1.117;

1.117
date	2007.05.10.02.16.11;	author dlg;	state Exp;
branches;
next	1.116;

1.116
date	2007.04.22.05.08.34;	author dlg;	state Exp;
branches;
next	1.115;

1.115
date	2007.04.22.05.03.04;	author dlg;	state Exp;
branches;
next	1.114;

1.114
date	2007.04.22.03.49.31;	author deraadt;	state Exp;
branches;
next	1.113;

1.113
date	2007.04.21.23.59.33;	author dlg;	state Exp;
branches;
next	1.112;

1.112
date	2007.04.08.09.13.31;	author pascoe;	state Exp;
branches;
next	1.111;

1.111
date	2007.04.08.09.05.48;	author pascoe;	state Exp;
branches;
next	1.110;

1.110
date	2007.04.06.04.04.29;	author pascoe;	state Exp;
branches;
next	1.109;

1.109
date	2007.04.02.05.14.52;	author pascoe;	state Exp;
branches;
next	1.108;

1.108
date	2007.03.31.10.14.53;	author jasper;	state Exp;
branches;
next	1.107;

1.107
date	2007.03.31.07.42.23;	author dlg;	state Exp;
branches;
next	1.106;

1.106
date	2007.03.30.06.59.46;	author dlg;	state Exp;
branches;
next	1.105;

1.105
date	2007.03.29.07.40.10;	author pascoe;	state Exp;
branches;
next	1.104;

1.104
date	2007.03.29.02.35.41;	author pascoe;	state Exp;
branches;
next	1.103;

1.103
date	2007.03.28.06.40.19;	author pascoe;	state Exp;
branches;
next	1.102;

1.102
date	2007.03.28.06.29.27;	author pascoe;	state Exp;
branches;
next	1.101;

1.101
date	2007.03.28.06.24.22;	author pascoe;	state Exp;
branches;
next	1.100;

1.100
date	2007.03.28.06.19.48;	author pascoe;	state Exp;
branches;
next	1.99;

1.99
date	2007.03.27.07.31.15;	author dlg;	state Exp;
branches;
next	1.98;

1.98
date	2007.03.23.06.34.58;	author pascoe;	state Exp;
branches;
next	1.97;

1.97
date	2007.03.23.05.28.34;	author pascoe;	state Exp;
branches;
next	1.96;

1.96
date	2007.03.22.05.15.39;	author pascoe;	state Exp;
branches;
next	1.95;

1.95
date	2007.03.21.13.08.44;	author pascoe;	state Exp;
branches;
next	1.94;

1.94
date	2007.03.21.12.41.28;	author pascoe;	state Exp;
branches;
next	1.93;

1.93
date	2007.03.21.12.08.58;	author dlg;	state Exp;
branches;
next	1.92;

1.92
date	2007.03.21.00.09.16;	author dlg;	state Exp;
branches;
next	1.91;

1.91
date	2007.03.21.00.07.29;	author pascoe;	state Exp;
branches;
next	1.90;

1.90
date	2007.03.20.13.18.16;	author pascoe;	state Exp;
branches;
next	1.89;

1.89
date	2007.03.20.13.00.42;	author pascoe;	state Exp;
branches;
next	1.88;

1.88
date	2007.03.20.12.46.26;	author dlg;	state Exp;
branches;
next	1.87;

1.87
date	2007.03.20.12.01.18;	author pascoe;	state Exp;
branches;
next	1.86;

1.86
date	2007.03.20.11.22.40;	author pascoe;	state Exp;
branches;
next	1.85;

1.85
date	2007.03.20.08.47.46;	author pascoe;	state Exp;
branches;
next	1.84;

1.84
date	2007.03.20.07.38.45;	author pascoe;	state Exp;
branches;
next	1.83;

1.83
date	2007.03.20.07.36.21;	author pascoe;	state Exp;
branches;
next	1.82;

1.82
date	2007.03.20.07.09.42;	author pascoe;	state Exp;
branches;
next	1.81;

1.81
date	2007.03.20.06.43.06;	author pascoe;	state Exp;
branches;
next	1.80;

1.80
date	2007.03.20.05.46.50;	author pascoe;	state Exp;
branches;
next	1.79;

1.79
date	2007.03.20.05.33.02;	author pascoe;	state Exp;
branches;
next	1.78;

1.78
date	2007.03.20.04.38.11;	author pascoe;	state Exp;
branches;
next	1.77;

1.77
date	2007.03.07.03.25.24;	author pascoe;	state Exp;
branches;
next	1.76;

1.76
date	2007.03.06.14.24.24;	author pascoe;	state Exp;
branches;
next	1.75;

1.75
date	2007.03.06.14.15.51;	author pascoe;	state Exp;
branches;
next	1.74;

1.74
date	2007.03.06.12.25.00;	author dlg;	state Exp;
branches;
next	1.73;

1.73
date	2007.03.06.09.01.28;	author dlg;	state Exp;
branches;
next	1.72;

1.72
date	2007.03.06.09.00.03;	author dlg;	state Exp;
branches;
next	1.71;

1.71
date	2007.03.06.06.43.56;	author pascoe;	state Exp;
branches;
next	1.70;

1.70
date	2007.03.06.05.59.21;	author pascoe;	state Exp;
branches;
next	1.69;

1.69
date	2007.03.06.05.40.34;	author pascoe;	state Exp;
branches;
next	1.68;

1.68
date	2007.03.06.05.38.55;	author pascoe;	state Exp;
branches;
next	1.67;

1.67
date	2007.03.05.09.13.44;	author dlg;	state Exp;
branches;
next	1.66;

1.66
date	2007.03.05.09.12.39;	author dlg;	state Exp;
branches;
next	1.65;

1.65
date	2007.03.05.06.06.13;	author pascoe;	state Exp;
branches;
next	1.64;

1.64
date	2007.03.04.14.49.46;	author pascoe;	state Exp;
branches;
next	1.63;

1.63
date	2007.03.04.14.46.38;	author pascoe;	state Exp;
branches;
next	1.62;

1.62
date	2007.03.04.14.40.41;	author pascoe;	state Exp;
branches;
next	1.61;

1.61
date	2007.03.04.14.23.08;	author pascoe;	state Exp;
branches;
next	1.60;

1.60
date	2007.03.04.14.06.34;	author pascoe;	state Exp;
branches;
next	1.59;

1.59
date	2007.03.04.13.53.17;	author pascoe;	state Exp;
branches;
next	1.58;

1.58
date	2007.03.04.13.49.42;	author pascoe;	state Exp;
branches;
next	1.57;

1.57
date	2007.03.04.13.47.08;	author pascoe;	state Exp;
branches;
next	1.56;

1.56
date	2007.03.04.13.32.41;	author pascoe;	state Exp;
branches;
next	1.55;

1.55
date	2007.03.04.13.24.48;	author pascoe;	state Exp;
branches;
next	1.54;

1.54
date	2007.03.04.13.19.14;	author pascoe;	state Exp;
branches;
next	1.53;

1.53
date	2007.03.04.12.23.25;	author pascoe;	state Exp;
branches;
next	1.52;

1.52
date	2007.03.04.12.20.17;	author pascoe;	state Exp;
branches;
next	1.51;

1.51
date	2007.03.04.12.01.46;	author pascoe;	state Exp;
branches;
next	1.50;

1.50
date	2007.03.04.05.06.28;	author dlg;	state Exp;
branches;
next	1.49;

1.49
date	2007.03.04.05.04.32;	author dlg;	state Exp;
branches;
next	1.48;

1.48
date	2007.03.04.04.58.38;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2007.03.04.04.51.12;	author dlg;	state Exp;
branches;
next	1.46;

1.46
date	2007.02.20.22.33.37;	author dlg;	state Exp;
branches;
next	1.45;

1.45
date	2007.02.20.22.27.59;	author dlg;	state Exp;
branches;
next	1.44;

1.44
date	2007.02.20.22.25.30;	author dlg;	state Exp;
branches;
next	1.43;

1.43
date	2007.02.19.13.54.07;	author dlg;	state Exp;
branches;
next	1.42;

1.42
date	2007.02.18.01.27.55;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2007.02.17.05.39.15;	author dlg;	state Exp;
branches;
next	1.40;

1.40
date	2007.02.14.04.36.53;	author dlg;	state Exp;
branches;
next	1.39;

1.39
date	2007.02.06.04.44.01;	author dlg;	state Exp;
branches;
next	1.38;

1.38
date	2007.01.31.07.12.09;	author dlg;	state Exp;
branches;
next	1.37;

1.37
date	2007.01.05.12.22.53;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2007.01.04.12.14.51;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2007.01.04.12.02.49;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2007.01.04.11.48.03;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2007.01.04.11.37.12;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2007.01.04.08.39.21;	author dlg;	state Exp;
branches;
next	1.31;

1.31
date	2006.12.12.02.45.16;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2006.12.12.02.44.00;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2006.12.12.02.41.50;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2006.12.12.02.39.25;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.12.02.37.09;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2006.12.12.02.24.20;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2006.12.12.02.22.56;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2006.12.12.02.19.37;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2006.12.12.02.13.32;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2006.12.12.02.06.09;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2006.12.11.23.42.33;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2006.12.11.13.20.29;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2006.12.11.13.17.57;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.11.13.08.11;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2006.12.11.13.06.33;	author dlg;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.11.12.54.00;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2006.12.11.12.48.01;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.11.12.46.12;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.11.05.47.53;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.11.05.10.50;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.11.04.26.16;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.11.04.14.37;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2006.12.09.07.17.10;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2006.12.09.07.02.44;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2006.12.09.06.42.53;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2006.12.09.06.29.43;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.09.06.15.32;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.09.06.08.09;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.09.06.03.34;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.09.05.19.49;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.09.05.10.43;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.197
log
@Split AHCI in order to support devices which are not attached via pci.
Tested on a few machines, including JMicron and Intel AHCIs.

ok dlg@@ jmatthew@@
@
text
@/*	$OpenBSD: ahci.c,v 1.196 2013/01/17 02:36:45 deraadt Exp $ */

/*
 * Copyright (c) 2006 David Gwynne <dlg@@openbsd.org>
 * Copyright (c) 2010 Conformal Systems LLC <info@@conformal.com>
 * Copyright (c) 2010 Jonathan Matthew <jonathan@@d14n.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/queue.h>
#include <sys/mutex.h>
#include <sys/pool.h>

#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/ata/atascsi.h>
#include <dev/ata/pmreg.h>

/* change to AHCI_DEBUG for dmesg spam */
#define NO_AHCI_DEBUG

#ifdef AHCI_DEBUG
#define DPRINTF(m, f...) do { if ((ahcidebug & (m)) == (m)) printf(f); } \
    while (0)
#define AHCI_D_TIMEOUT		0x00
#define AHCI_D_VERBOSE		0x01
#define AHCI_D_INTR		0x02
#define AHCI_D_XFER		0x08
int ahcidebug = AHCI_D_VERBOSE;
#else
#define DPRINTF(m, f...)
#endif

#define AHCI_PCI_BAR		0x24
#define AHCI_PCI_ATI_SB600_MAGIC	0x40
#define AHCI_PCI_ATI_SB600_LOCKED	0x01
#define AHCI_PCI_INTERFACE	0x01

#define AHCI_PCI_INTEL_MAP		0x90
#define AHCI_PCI_INTEL_MAP_SC_4P	0x00
#define AHCI_PCI_INTEL_MAP_SC_6P	0x20
#define AHCI_PCI_INTEL_MAP_SMS_IDE	0x00
#define AHCI_PCI_INTEL_MAP_SMS_AHCI	0x40
#define AHCI_PCI_INTEL_MAP_SMS_RAID	0x80

#define AHCI_REG_CAP		0x000 /* HBA Capabilities */
#define  AHCI_REG_CAP_NP(_r)		(((_r) & 0x1f)+1) /* Number of Ports */
#define  AHCI_REG_CAP_SXS		(1<<5) /* External SATA */
#define  AHCI_REG_CAP_EMS		(1<<6) /* Enclosure Mgmt */
#define  AHCI_REG_CAP_CCCS		(1<<7) /* Cmd Coalescing */
#define  AHCI_REG_CAP_NCS(_r)		((((_r) & 0x1f00)>>8)+1) /* NCmds*/
#define  AHCI_REG_CAP_PSC		(1<<13) /* Partial State Capable */
#define  AHCI_REG_CAP_SSC		(1<<14) /* Slumber State Capable */
#define  AHCI_REG_CAP_PMD		(1<<15) /* PIO Multiple DRQ Block */
#define  AHCI_REG_CAP_FBSS		(1<<16) /* FIS-Based Switching */
#define  AHCI_REG_CAP_SPM		(1<<17) /* Port Multiplier */
#define  AHCI_REG_CAP_SAM		(1<<18) /* AHCI Only mode */
#define  AHCI_REG_CAP_SNZO		(1<<19) /* Non Zero DMA Offsets */
#define  AHCI_REG_CAP_ISS		(0xf<<20) /* Interface Speed Support */
#define  AHCI_REG_CAP_ISS_G1		(0x1<<20) /* Gen 1 (1.5 Gbps) */
#define  AHCI_REG_CAP_ISS_G1_2		(0x2<<20) /* Gen 1 and 2 (3 Gbps) */
#define  AHCI_REG_CAP_SCLO		(1<<24) /* Cmd List Override */
#define  AHCI_REG_CAP_SAL		(1<<25) /* Activity LED */
#define  AHCI_REG_CAP_SALP		(1<<26) /* Aggressive Link Pwr Mgmt */
#define  AHCI_REG_CAP_SSS		(1<<27) /* Staggered Spinup */
#define  AHCI_REG_CAP_SMPS		(1<<28) /* Mech Presence Switch */
#define  AHCI_REG_CAP_SSNTF		(1<<29) /* SNotification Register */
#define  AHCI_REG_CAP_SNCQ		(1<<30) /* Native Cmd Queuing */
#define  AHCI_REG_CAP_S64A		(1<<31) /* 64bit Addressing */
#define  AHCI_FMT_CAP		"\020" "\040S64A" "\037NCQ" "\036SSNTF" \
				    "\035SMPS" "\034SSS" "\033SALP" "\032SAL" \
				    "\031SCLO" "\024SNZO" "\023SAM" "\022SPM" \
				    "\021FBSS" "\020PMD" "\017SSC" "\016PSC" \
				    "\010CCCS" "\007EMS" "\006SXS"
#define AHCI_REG_GHC		0x004 /* Global HBA Control */
#define  AHCI_REG_GHC_HR		(1<<0) /* HBA Reset */
#define  AHCI_REG_GHC_IE		(1<<1) /* Interrupt Enable */
#define  AHCI_REG_GHC_MRSM		(1<<2) /* MSI Revert to Single Msg */
#define  AHCI_REG_GHC_AE		(1<<31) /* AHCI Enable */
#define AHCI_FMT_GHC		"\020" "\040AE" "\003MRSM" "\002IE" "\001HR"
#define AHCI_REG_IS		0x008 /* Interrupt Status */
#define AHCI_REG_PI		0x00c /* Ports Implemented */
#define AHCI_REG_VS		0x010 /* AHCI Version */
#define  AHCI_REG_VS_0_95		0x00000905 /* 0.95 */
#define  AHCI_REG_VS_1_0		0x00010000 /* 1.0 */
#define  AHCI_REG_VS_1_1		0x00010100 /* 1.1 */
#define  AHCI_REG_VS_1_2		0x00010200 /* 1.2 */
#define  AHCI_REG_VS_1_3		0x00010300 /* 1.3 */
#define AHCI_REG_CCC_CTL	0x014 /* Coalescing Control */
#define  AHCI_REG_CCC_CTL_INT(_r)	(((_r) & 0xf8) >> 3) /* CCC INT slot */
#define AHCI_REG_CCC_PORTS	0x018 /* Coalescing Ports */
#define AHCI_REG_EM_LOC		0x01c /* Enclosure Mgmt Location */
#define AHCI_REG_EM_CTL		0x020 /* Enclosure Mgmt Control */

#define AHCI_PORT_REGION(_p)	(0x100 + ((_p) * 0x80))
#define AHCI_PORT_SIZE		0x80

#define AHCI_PREG_CLB		0x00 /* Cmd List Base Addr */
#define AHCI_PREG_CLBU		0x04 /* Cmd List Base Hi Addr */
#define AHCI_PREG_FB		0x08 /* FIS Base Addr */
#define AHCI_PREG_FBU		0x0c /* FIS Base Hi Addr */
#define AHCI_PREG_IS		0x10 /* Interrupt Status */
#define  AHCI_PREG_IS_DHRS		(1<<0) /* Device to Host FIS */
#define  AHCI_PREG_IS_PSS		(1<<1) /* PIO Setup FIS */
#define  AHCI_PREG_IS_DSS		(1<<2) /* DMA Setup FIS */
#define  AHCI_PREG_IS_SDBS		(1<<3) /* Set Device Bits FIS */
#define  AHCI_PREG_IS_UFS		(1<<4) /* Unknown FIS */
#define  AHCI_PREG_IS_DPS		(1<<5) /* Descriptor Processed */
#define  AHCI_PREG_IS_PCS		(1<<6) /* Port Change */
#define  AHCI_PREG_IS_DMPS		(1<<7) /* Device Mechanical Presence */
#define  AHCI_PREG_IS_PRCS		(1<<22) /* PhyRdy Change */
#define  AHCI_PREG_IS_IPMS		(1<<23) /* Incorrect Port Multiplier */
#define  AHCI_PREG_IS_OFS		(1<<24) /* Overflow */
#define  AHCI_PREG_IS_INFS		(1<<26) /* Interface Non-fatal Error */
#define  AHCI_PREG_IS_IFS		(1<<27) /* Interface Fatal Error */
#define  AHCI_PREG_IS_HBDS		(1<<28) /* Host Bus Data Error */
#define  AHCI_PREG_IS_HBFS		(1<<29) /* Host Bus Fatal Error */
#define  AHCI_PREG_IS_TFES		(1<<30) /* Task File Error */
#define  AHCI_PREG_IS_CPDS		(1<<31) /* Cold Presence Detect */
#define AHCI_PFMT_IS		"\20" "\040CPDS" "\037TFES" "\036HBFS" \
				    "\035HBDS" "\034IFS" "\033INFS" "\031OFS" \
				    "\030IPMS" "\027PRCS" "\010DMPS" "\006DPS" \
				    "\007PCS" "\005UFS" "\004SDBS" "\003DSS" \
				    "\002PSS" "\001DHRS"
#define AHCI_PREG_IE		0x14 /* Interrupt Enable */
#define  AHCI_PREG_IE_DHRE		(1<<0) /* Device to Host FIS */
#define  AHCI_PREG_IE_PSE		(1<<1) /* PIO Setup FIS */
#define  AHCI_PREG_IE_DSE		(1<<2) /* DMA Setup FIS */
#define  AHCI_PREG_IE_SDBE		(1<<3) /* Set Device Bits FIS */
#define  AHCI_PREG_IE_UFE		(1<<4) /* Unknown FIS */
#define  AHCI_PREG_IE_DPE		(1<<5) /* Descriptor Processed */
#define  AHCI_PREG_IE_PCE		(1<<6) /* Port Change */
#define  AHCI_PREG_IE_DMPE		(1<<7) /* Device Mechanical Presence */
#define  AHCI_PREG_IE_PRCE		(1<<22) /* PhyRdy Change */
#define  AHCI_PREG_IE_IPME		(1<<23) /* Incorrect Port Multiplier */
#define  AHCI_PREG_IE_OFE		(1<<24) /* Overflow */
#define  AHCI_PREG_IE_INFE		(1<<26) /* Interface Non-fatal Error */
#define  AHCI_PREG_IE_IFE		(1<<27) /* Interface Fatal Error */
#define  AHCI_PREG_IE_HBDE		(1<<28) /* Host Bus Data Error */
#define  AHCI_PREG_IE_HBFE		(1<<29) /* Host Bus Fatal Error */
#define  AHCI_PREG_IE_TFEE		(1<<30) /* Task File Error */
#define  AHCI_PREG_IE_CPDE		(1<<31) /* Cold Presence Detect */
#define AHCI_PFMT_IE		"\20" "\040CPDE" "\037TFEE" "\036HBFE" \
				    "\035HBDE" "\034IFE" "\033INFE" "\031OFE" \
				    "\030IPME" "\027PRCE" "\010DMPE" "\007PCE" \
				    "\006DPE" "\005UFE" "\004SDBE" "\003DSE" \
				    "\002PSE" "\001DHRE"
#define AHCI_PREG_CMD		0x18 /* Command and Status */
#define  AHCI_PREG_CMD_ST		(1<<0) /* Start */
#define  AHCI_PREG_CMD_SUD		(1<<1) /* Spin Up Device */
#define  AHCI_PREG_CMD_POD		(1<<2) /* Power On Device */
#define  AHCI_PREG_CMD_CLO		(1<<3) /* Command List Override */
#define  AHCI_PREG_CMD_FRE		(1<<4) /* FIS Receive Enable */
#define  AHCI_PREG_CMD_CCS(_r)		(((_r) >> 8) & 0x1f) /* Curr CmdSlot# */
#define  AHCI_PREG_CMD_MPSS		(1<<13) /* Mech Presence State */
#define  AHCI_PREG_CMD_FR		(1<<14) /* FIS Receive Running */
#define  AHCI_PREG_CMD_CR		(1<<15) /* Command List Running */
#define  AHCI_PREG_CMD_CPS		(1<<16) /* Cold Presence State */
#define  AHCI_PREG_CMD_PMA		(1<<17) /* Port Multiplier Attached */
#define  AHCI_PREG_CMD_HPCP		(1<<18) /* Hot Plug Capable */
#define  AHCI_PREG_CMD_MPSP		(1<<19) /* Mech Presence Switch */
#define  AHCI_PREG_CMD_CPD		(1<<20) /* Cold Presence Detection */
#define  AHCI_PREG_CMD_ESP		(1<<21) /* External SATA Port */
#define  AHCI_PREG_CMD_ATAPI		(1<<24) /* Device is ATAPI */
#define  AHCI_PREG_CMD_DLAE		(1<<25) /* Drv LED on ATAPI Enable */
#define  AHCI_PREG_CMD_ALPE		(1<<26) /* Aggro Pwr Mgmt Enable */
#define  AHCI_PREG_CMD_ASP		(1<<27) /* Aggro Slumber/Partial */
#define  AHCI_PREG_CMD_ICC		0xf0000000 /* Interface Comm Ctrl */
#define  AHCI_PREG_CMD_ICC_SLUMBER	0x60000000
#define  AHCI_PREG_CMD_ICC_PARTIAL	0x20000000
#define  AHCI_PREG_CMD_ICC_ACTIVE	0x10000000
#define  AHCI_PREG_CMD_ICC_IDLE		0x00000000
#define  AHCI_PFMT_CMD		"\020" "\034ASP" "\033ALPE" "\032DLAE" \
				    "\031ATAPI" "\026ESP" "\025CPD" "\024MPSP" \
				    "\023HPCP" "\022PMA" "\021CPS" "\020CR" \
				    "\017FR" "\016MPSS" "\005FRE" "\004CLO" \
				    "\003POD" "\002SUD" "\001ST"
#define AHCI_PREG_TFD		0x20 /* Task File Data*/
#define  AHCI_PREG_TFD_STS		0xff
#define  AHCI_PREG_TFD_STS_ERR		(1<<0)
#define  AHCI_PREG_TFD_STS_DRQ		(1<<3)
#define  AHCI_PREG_TFD_STS_BSY		(1<<7)
#define  AHCI_PREG_TFD_ERR		0xff00
#define AHCI_PFMT_TFD_STS	"\20" "\010BSY" "\004DRQ" "\001ERR"
#define AHCI_PREG_SIG		0x24 /* Signature */
#define AHCI_PREG_SSTS		0x28 /* SATA Status */
#define  AHCI_PREG_SSTS_DET		0xf /* Device Detection */
#define  AHCI_PREG_SSTS_DET_NONE	0x0
#define  AHCI_PREG_SSTS_DET_DEV_NE	0x1
#define  AHCI_PREG_SSTS_DET_DEV		0x3
#define  AHCI_PREG_SSTS_DET_PHYOFFLINE	0x4
#define  AHCI_PREG_SSTS_SPD		0xf0 /* Current Interface Speed */
#define  AHCI_PREG_SSTS_SPD_NONE	0x00
#define  AHCI_PREG_SSTS_SPD_GEN1	0x10
#define  AHCI_PREG_SSTS_SPD_GEN2	0x20
#define  AHCI_PREG_SSTS_IPM		0xf00 /* Interface Power Management */
#define  AHCI_PREG_SSTS_IPM_NONE	0x000
#define  AHCI_PREG_SSTS_IPM_ACTIVE	0x100
#define  AHCI_PREG_SSTS_IPM_PARTIAL	0x200
#define  AHCI_PREG_SSTS_IPM_SLUMBER	0x600
#define AHCI_PREG_SCTL		0x2c /* SATA Control */
#define  AHCI_PREG_SCTL_DET		0xf /* Device Detection */
#define  AHCI_PREG_SCTL_DET_NONE	0x0
#define  AHCI_PREG_SCTL_DET_INIT	0x1
#define  AHCI_PREG_SCTL_DET_DISABLE	0x4
#define  AHCI_PREG_SCTL_SPD		0xf0 /* Speed Allowed */
#define  AHCI_PREG_SCTL_SPD_ANY		0x00
#define  AHCI_PREG_SCTL_SPD_GEN1	0x10
#define  AHCI_PREG_SCTL_SPD_GEN2	0x20
#define  AHCI_PREG_SCTL_IPM		0xf00 /* Interface Power Management */
#define  AHCI_PREG_SCTL_IPM_NONE	0x000
#define  AHCI_PREG_SCTL_IPM_NOPARTIAL	0x100
#define  AHCI_PREG_SCTL_IPM_NOSLUMBER	0x200
#define  AHCI_PREG_SCTL_IPM_DISABLED	0x300
#define AHCI_PREG_SERR		0x30 /* SATA Error */
#define  AHCI_PREG_SERR_ERR(_r)		((_r) & 0xffff)
#define  AHCI_PREG_SERR_ERR_I		(1<<0) /* Recovered Data Integrity */
#define  AHCI_PREG_SERR_ERR_M		(1<<1) /* Recovered Communications */
#define  AHCI_PREG_SERR_ERR_T		(1<<8) /* Transient Data Integrity */
#define  AHCI_PREG_SERR_ERR_C		(1<<9) /* Persistent Comm/Data */
#define  AHCI_PREG_SERR_ERR_P		(1<<10) /* Protocol */
#define  AHCI_PREG_SERR_ERR_E		(1<<11) /* Internal */
#define  AHCI_PFMT_SERR_ERR	"\020" "\014E" "\013P" "\012C" "\011T" "\002M" \
				    "\001I"
#define  AHCI_PREG_SERR_DIAG(_r)	(((_r) >> 16) & 0xffff)
#define  AHCI_PREG_SERR_DIAG_N		(1<<0) /* PhyRdy Change */
#define  AHCI_PREG_SERR_DIAG_I		(1<<1) /* Phy Internal Error */
#define  AHCI_PREG_SERR_DIAG_W		(1<<2) /* Comm Wake */
#define  AHCI_PREG_SERR_DIAG_B		(1<<3) /* 10B to 8B Decode Error */
#define  AHCI_PREG_SERR_DIAG_D		(1<<4) /* Disparity Error */
#define  AHCI_PREG_SERR_DIAG_C		(1<<5) /* CRC Error */
#define  AHCI_PREG_SERR_DIAG_H		(1<<6) /* Handshake Error */
#define  AHCI_PREG_SERR_DIAG_S		(1<<7) /* Link Sequence Error */
#define  AHCI_PREG_SERR_DIAG_T		(1<<8) /* Transport State Trans Err */
#define  AHCI_PREG_SERR_DIAG_F		(1<<9) /* Unknown FIS Type */
#define  AHCI_PREG_SERR_DIAG_X		(1<<10) /* Exchanged */
#define  AHCI_PFMT_SERR_DIAG	"\020" "\013X" "\012F" "\011T" "\010S" "\007H" \
				    "\006C" "\005D" "\004B" "\003W" "\002I" \
				    "\001N"
#define AHCI_PREG_SACT		0x34 /* SATA Active */
#define AHCI_PREG_CI		0x38 /* Command Issue */
#define  AHCI_PREG_CI_ALL_SLOTS	0xffffffff
#define AHCI_PREG_SNTF		0x3c /* SNotification */

#define AHCI_PREG_FBS		0x40 /* FIS-based Switching Control */
#define AHCI_PREG_FBS_DWE	0xf0000	/* Device With Error */
#define AHCI_PREG_FBS_ADO	0xf000	/* Active Device Optimization */
#define AHCI_PREG_FBS_DEV	0xf00	/* Device To Issue */
#define AHCI_PREG_FBS_SDE	(1<<2)	/* Single Device Error */
#define AHCI_PREG_FBS_DEC	(1<<1)	/* Device Error Clear */
#define AHCI_PREG_FBS_EN	(1<<0)	/* Enable */



struct ahci_cmd_hdr {
	u_int16_t		flags;
#define AHCI_CMD_LIST_FLAG_CFL		0x001f /* Command FIS Length */
#define AHCI_CMD_LIST_FLAG_A		(1<<5) /* ATAPI */
#define AHCI_CMD_LIST_FLAG_W		(1<<6) /* Write */
#define AHCI_CMD_LIST_FLAG_P		(1<<7) /* Prefetchable */
#define AHCI_CMD_LIST_FLAG_R		(1<<8) /* Reset */
#define AHCI_CMD_LIST_FLAG_B		(1<<9) /* BIST */
#define AHCI_CMD_LIST_FLAG_C		(1<<10) /* Clear Busy upon R_OK */
#define AHCI_CMD_LIST_FLAG_PMP		0xf000 /* Port Multiplier Port */
#define AHCI_CMD_LIST_FLAG_PMP_SHIFT	12
	u_int16_t		prdtl; /* sgl len */

	u_int32_t		prdbc; /* transferred byte count */

	u_int32_t		ctba_lo;
	u_int32_t		ctba_hi;

	u_int32_t		reserved[4];
} __packed;

struct ahci_rfis {
	u_int8_t		dsfis[28];
	u_int8_t		reserved1[4];
	u_int8_t		psfis[24];
	u_int8_t		reserved2[8];
	u_int8_t		rfis[24];
	u_int8_t		reserved3[4];
	u_int8_t		sdbfis[4];
	u_int8_t		ufis[64];
	u_int8_t		reserved4[96];
} __packed;

struct ahci_prdt {
	u_int32_t		dba_lo;
	u_int32_t		dba_hi;
	u_int32_t		reserved;
	u_int32_t		flags;
#define AHCI_PRDT_FLAG_INTR		(1<<31) /* interrupt on completion */
} __packed;

/* this makes ahci_cmd_table 512 bytes, supporting 128-byte alignment */
#define AHCI_MAX_PRDT		24

struct ahci_cmd_table {
	u_int8_t		cfis[64];	/* Command FIS */
	u_int8_t		acmd[16];	/* ATAPI Command */
	u_int8_t		reserved[48];

	struct ahci_prdt	prdt[AHCI_MAX_PRDT];
} __packed;

#define AHCI_MAX_PORTS		32

struct ahci_dmamem {
	bus_dmamap_t		adm_map;
	bus_dma_segment_t	adm_seg;
	size_t			adm_size;
	caddr_t			adm_kva;
};
#define AHCI_DMA_MAP(_adm)	((_adm)->adm_map)
#define AHCI_DMA_DVA(_adm)	((_adm)->adm_map->dm_segs[0].ds_addr)
#define AHCI_DMA_KVA(_adm)	((void *)(_adm)->adm_kva)

struct ahci_softc;
struct ahci_port;

struct ahci_ccb {
	/* ATA xfer associated with this CCB.  Must be 1st struct member. */
	struct ata_xfer		ccb_xa;

	int			ccb_slot;
	struct ahci_port	*ccb_port;

	bus_dmamap_t		ccb_dmamap;
	struct ahci_cmd_hdr	*ccb_cmd_hdr;
	struct ahci_cmd_table	*ccb_cmd_table;

	void			(*ccb_done)(struct ahci_ccb *);

	TAILQ_ENTRY(ahci_ccb)	ccb_entry;
};

struct ahci_port {
	struct ahci_softc	*ap_sc;
	bus_space_handle_t	ap_ioh;

#ifdef AHCI_COALESCE
	int			ap_num;
#endif

	struct ahci_rfis	*ap_rfis;
	struct ahci_dmamem	*ap_dmamem_rfis;

	struct ahci_dmamem	*ap_dmamem_cmd_list;
	struct ahci_dmamem	*ap_dmamem_cmd_table;

	volatile u_int32_t	ap_active;
	volatile u_int32_t	ap_active_cnt;
	volatile u_int32_t	ap_sactive;
	volatile u_int32_t	ap_pmp_ncq_port;
	struct ahci_ccb		*ap_ccbs;

	TAILQ_HEAD(, ahci_ccb)	ap_ccb_free;
	TAILQ_HEAD(, ahci_ccb)	ap_ccb_pending;
	struct mutex		ap_ccb_mtx;
	struct ahci_ccb		*ap_ccb_err;

	u_int32_t		ap_state;
#define AP_S_NORMAL			0
#define AP_S_PMP_PROBE			1
#define AP_S_PMP_PORT_PROBE		2
#define AP_S_ERROR_RECOVERY		3
#define AP_S_FATAL_ERROR		4

	int			ap_pmp_ports;
	int			ap_port;
	int			ap_pmp_ignore_ifs;

	/* For error recovery. */
#ifdef DIAGNOSTIC
	int			ap_err_busy;
#endif
	u_int32_t		ap_err_saved_sactive;
	u_int32_t		ap_err_saved_active;
	u_int32_t		ap_err_saved_active_cnt;

	u_int8_t		*ap_err_scratch;

#ifdef AHCI_DEBUG
	char			ap_name[16];
#define PORTNAME(_ap)	((_ap)->ap_name)
#else
#define PORTNAME(_ap)	DEVNAME((_ap)->ap_sc)
#endif
};

struct ahci_softc {
	struct device		sc_dev;

	void			*sc_ih;
	pci_chipset_tag_t	sc_pc;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_size_t		sc_ios;
	bus_dma_tag_t		sc_dmat;

	int			sc_flags;
#define AHCI_F_NO_NCQ			(1<<0)
#define AHCI_F_IPMS_PROBE		(1<<1)	/* IPMS on failed PMP probe */
#define AHCI_F_NO_PMP			(1<<2)	/* ignore PMP capability */

	u_int			sc_ncmds;

	struct ahci_port	*sc_ports[AHCI_MAX_PORTS];

	struct atascsi		*sc_atascsi;

	u_int32_t		sc_cap;

#ifdef AHCI_COALESCE
	u_int32_t		sc_ccc_mask;
	u_int32_t		sc_ccc_ports;
	u_int32_t		sc_ccc_ports_cur;
#endif
};
#define DEVNAME(_s)		((_s)->sc_dev.dv_xname)

struct ahci_device {
	pci_vendor_id_t		ad_vendor;
	pci_product_id_t	ad_product;
	int			(*ad_match)(struct pci_attach_args *);
	int			(*ad_attach)(struct ahci_softc *,
				    struct pci_attach_args *);
};

const struct ahci_device *ahci_lookup_device(struct pci_attach_args *);

int			ahci_no_match(struct pci_attach_args *);
int			ahci_vt8251_attach(struct ahci_softc *,
			    struct pci_attach_args *);
void			ahci_ati_sb_idetoahci(struct ahci_softc *,
			    struct pci_attach_args *pa);
int			ahci_ati_sb600_attach(struct ahci_softc *,
			    struct pci_attach_args *);
int			ahci_ati_sb700_attach(struct ahci_softc *,
			    struct pci_attach_args *);
int			ahci_amd_hudson2_attach(struct ahci_softc *,
			    struct pci_attach_args *);
int			ahci_intel_attach(struct ahci_softc *,
			    struct pci_attach_args *);

static const struct ahci_device ahci_devices[] = {
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_HUDSON2_SATA_1,
	    NULL,		ahci_amd_hudson2_attach },
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_HUDSON2_SATA_2,
	    NULL,		ahci_amd_hudson2_attach },
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_HUDSON2_SATA_3,
	    NULL,		ahci_amd_hudson2_attach },
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_HUDSON2_SATA_4,
	    NULL,		ahci_amd_hudson2_attach },
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_HUDSON2_SATA_5,
	    NULL,		ahci_amd_hudson2_attach },
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_HUDSON2_SATA_6,
	    NULL,		ahci_amd_hudson2_attach },

	{ PCI_VENDOR_ATI,	PCI_PRODUCT_ATI_SB600_SATA,
	    NULL,		ahci_ati_sb600_attach },
	{ PCI_VENDOR_ATI,	PCI_PRODUCT_ATI_SBX00_SATA_1,
	    NULL,		ahci_ati_sb700_attach },
	{ PCI_VENDOR_ATI,	PCI_PRODUCT_ATI_SBX00_SATA_2,
	    NULL,		ahci_ati_sb700_attach },
	{ PCI_VENDOR_ATI,	PCI_PRODUCT_ATI_SBX00_SATA_3,
	    NULL,		ahci_ati_sb700_attach },
	{ PCI_VENDOR_ATI,	PCI_PRODUCT_ATI_SBX00_SATA_4,
	    NULL,		ahci_ati_sb700_attach },
	{ PCI_VENDOR_ATI,	PCI_PRODUCT_ATI_SBX00_SATA_5,
	    NULL,		ahci_ati_sb700_attach },
	{ PCI_VENDOR_ATI,	PCI_PRODUCT_ATI_SBX00_SATA_6,
	    NULL,		ahci_ati_sb700_attach },

	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_6SERIES_AHCI_1,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_6SERIES_AHCI_2,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_6321ESB_AHCI,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801GR_AHCI,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801GBM_AHCI,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801H_AHCI_6P,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801H_AHCI_4P,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801HBM_AHCI,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801I_AHCI_1,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801I_AHCI_2,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801I_AHCI_3,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801JD_AHCI,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801JI_AHCI,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_3400_AHCI_1,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_3400_AHCI_2,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_3400_AHCI_3,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_3400_AHCI_4,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_EP80579_AHCI,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_3400_SATA_1,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_3400_SATA_2,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_3400_SATA_4,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_3400_SATA_6,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_6SERIES_SATA_1,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_6SERIES_SATA_2,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_7SERIES_SATA_1,
	    NULL,		ahci_intel_attach },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_7SERIES_SATA_2,
	    NULL,		ahci_intel_attach },

	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT8251_SATA,
	  ahci_no_match,	ahci_vt8251_attach }
};

int			ahci_pci_match(struct device *, void *, void *);
void			ahci_pci_attach(struct device *, struct device *,
			    void *);
int			ahci_pci_detach(struct device *, int);
int			ahci_pci_activate(struct device *, int);

#ifdef HIBERNATE
#include <uvm/uvm.h>
#include <sys/hibernate.h>
#include <sys/disk.h>
#include <sys/disklabel.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

void			ahci_hibernate_io_start(struct ahci_port *,
			    struct ahci_ccb *);
int			ahci_hibernate_io_poll(struct ahci_port *,
			    struct ahci_ccb *);
void			ahci_hibernate_load_prdt(struct ahci_ccb *);

int			ahci_hibernate_io(dev_t dev, daddr_t blkno,
			    vaddr_t addr, size_t size, int wr, void *page);
#endif

struct cfattach ahci_pci_ca = {
	sizeof(struct ahci_softc),
	ahci_pci_match,
	ahci_pci_attach,
	ahci_pci_detach,
	ahci_pci_activate
};

struct cfattach ahci_jmb_ca = {
	sizeof(struct ahci_softc),
	ahci_pci_match,
	ahci_pci_attach,
	ahci_pci_detach
};

struct cfdriver ahci_cd = {
	NULL, "ahci", DV_DULL
};


int			ahci_map_regs(struct ahci_softc *,
			    struct pci_attach_args *);
void			ahci_unmap_regs(struct ahci_softc *);
int			ahci_map_intr(struct ahci_softc *,
			    struct pci_attach_args *, pci_intr_handle_t);
void			ahci_unmap_intr(struct ahci_softc *);
void			ahci_enable_interrupts(struct ahci_port *);

int			ahci_init(struct ahci_softc *);
int			ahci_port_alloc(struct ahci_softc *, u_int);
void			ahci_port_free(struct ahci_softc *, u_int);
int			ahci_port_init(struct ahci_softc *, u_int);

int			ahci_port_start(struct ahci_port *, int);
int			ahci_port_stop(struct ahci_port *, int);
int			ahci_port_clo(struct ahci_port *);
int			ahci_port_softreset(struct ahci_port *);
int			ahci_port_portreset(struct ahci_port *, int);
int			ahci_port_signature(struct ahci_port *);
int			ahci_pmp_port_softreset(struct ahci_port *, int);
int			ahci_pmp_port_portreset(struct ahci_port *, int);
int			ahci_pmp_port_probe(struct ahci_port *ap, int pmp_port);

int			ahci_load_prdt(struct ahci_ccb *);
void			ahci_unload_prdt(struct ahci_ccb *);

int			ahci_poll(struct ahci_ccb *, int, void (*)(void *));
void			ahci_start(struct ahci_ccb *);

void			ahci_issue_pending_ncq_commands(struct ahci_port *);
void			ahci_issue_pending_commands(struct ahci_port *, int);

int			ahci_intr(void *);
u_int32_t		ahci_port_intr(struct ahci_port *, u_int32_t);

struct ahci_ccb		*ahci_get_ccb(struct ahci_port *);
void			ahci_put_ccb(struct ahci_ccb *);

struct ahci_ccb		*ahci_get_err_ccb(struct ahci_port *);
void			ahci_put_err_ccb(struct ahci_ccb *);

struct ahci_ccb		*ahci_get_pmp_ccb(struct ahci_port *);
void			ahci_put_pmp_ccb(struct ahci_ccb *);

int			ahci_port_read_ncq_error(struct ahci_port *, int *, int);

struct ahci_dmamem	*ahci_dmamem_alloc(struct ahci_softc *, size_t);
void			ahci_dmamem_free(struct ahci_softc *,
			    struct ahci_dmamem *);

u_int32_t		ahci_read(struct ahci_softc *, bus_size_t);
void			ahci_write(struct ahci_softc *, bus_size_t, u_int32_t);
int			ahci_wait_ne(struct ahci_softc *, bus_size_t,
			    u_int32_t, u_int32_t);

u_int32_t		ahci_pread(struct ahci_port *, bus_size_t);
void			ahci_pwrite(struct ahci_port *, bus_size_t, u_int32_t);
int			ahci_pwait_eq(struct ahci_port *, bus_size_t,
			    u_int32_t, u_int32_t, int);
void			ahci_flush_tfd(struct ahci_port *ap);
u_int32_t		ahci_active_mask(struct ahci_port *);
int			ahci_port_detect_pmp(struct ahci_port *);
void			ahci_pmp_probe_timeout(void *);

/* pmp operations */
int			ahci_pmp_read(struct ahci_port *, int, int,
			    u_int32_t *);
int			ahci_pmp_write(struct ahci_port *, int, int, u_int32_t);
int			ahci_pmp_phy_status(struct ahci_port *, int,
			    u_int32_t *);
int 			ahci_pmp_identify(struct ahci_port *, int *);


/* Wait for all bits in _b to be cleared */
#define ahci_pwait_clr(_ap, _r, _b, _n) \
   ahci_pwait_eq((_ap), (_r), (_b), 0, (_n))

/* Wait for all bits in _b to be set */
#define ahci_pwait_set(_ap, _r, _b, _n) \
   ahci_pwait_eq((_ap), (_r), (_b), (_b), (_n))



/* provide methods for atascsi to call */
int			ahci_ata_probe(void *, int, int);
void			ahci_ata_free(void *, int, int);
struct ata_xfer *	ahci_ata_get_xfer(void *, int);
void			ahci_ata_put_xfer(struct ata_xfer *);
void			ahci_ata_cmd(struct ata_xfer *);

struct atascsi_methods ahci_atascsi_methods = {
	ahci_ata_probe,
	ahci_ata_free,
	ahci_ata_get_xfer,
	ahci_ata_put_xfer,
	ahci_ata_cmd
};

/* ccb completions */
void			ahci_ata_cmd_done(struct ahci_ccb *);
void			ahci_pmp_cmd_done(struct ahci_ccb *);
void			ahci_ata_cmd_timeout(void *);
void			ahci_empty_done(struct ahci_ccb *);

const struct ahci_device *
ahci_lookup_device(struct pci_attach_args *pa)
{
	int				i;
	const struct ahci_device	*ad;

	for (i = 0; i < (sizeof(ahci_devices) / sizeof(ahci_devices[0])); i++) {
		ad = &ahci_devices[i];
		if (ad->ad_vendor == PCI_VENDOR(pa->pa_id) &&
		    ad->ad_product == PCI_PRODUCT(pa->pa_id))
			return (ad);
	}

	return (NULL);
}

int
ahci_no_match(struct pci_attach_args *pa)
{
	return (0);
}

int
ahci_vt8251_attach(struct ahci_softc *sc, struct pci_attach_args *pa)
{
	sc->sc_flags |= AHCI_F_NO_NCQ;

	return (0);
}

void
ahci_ati_sb_idetoahci(struct ahci_softc *sc, struct pci_attach_args *pa)
{
	pcireg_t			magic;

	if (PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_MASS_STORAGE_IDE) {
		magic = pci_conf_read(pa->pa_pc, pa->pa_tag,
		    AHCI_PCI_ATI_SB600_MAGIC);
		pci_conf_write(pa->pa_pc, pa->pa_tag,
		    AHCI_PCI_ATI_SB600_MAGIC,
		    magic | AHCI_PCI_ATI_SB600_LOCKED);

		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG,
		    PCI_CLASS_MASS_STORAGE << PCI_CLASS_SHIFT |
		    PCI_SUBCLASS_MASS_STORAGE_SATA << PCI_SUBCLASS_SHIFT |
		    AHCI_PCI_INTERFACE << PCI_INTERFACE_SHIFT |
		    PCI_REVISION(pa->pa_class) << PCI_REVISION_SHIFT);

		pci_conf_write(pa->pa_pc, pa->pa_tag,
		    AHCI_PCI_ATI_SB600_MAGIC, magic);
	}
}

int
ahci_ati_sb600_attach(struct ahci_softc *sc, struct pci_attach_args *pa)
{
	ahci_ati_sb_idetoahci(sc, pa);

	sc->sc_flags |= AHCI_F_IPMS_PROBE;

	return (0);
}

int
ahci_ati_sb700_attach(struct ahci_softc *sc, struct pci_attach_args *pa)
{
	ahci_ati_sb_idetoahci(sc, pa);

	sc->sc_flags |= AHCI_F_IPMS_PROBE;

	return (0);
}

int
ahci_amd_hudson2_attach(struct ahci_softc *sc, struct pci_attach_args *pa)
{
	ahci_ati_sb_idetoahci(sc, pa);

	sc->sc_flags |= AHCI_F_IPMS_PROBE;

	return (0);
}

int
ahci_intel_attach(struct ahci_softc *sc, struct pci_attach_args *pa)
{
	/* switch from pciide(4) to ahci(4) mode */
	if (PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_MASS_STORAGE_IDE) {
		pcireg_t	reg;

		reg = pci_conf_read(pa->pa_pc, pa->pa_tag,
		    AHCI_PCI_INTEL_MAP);
		pci_conf_write(pa->pa_pc, pa->pa_tag, AHCI_PCI_INTEL_MAP,
		    reg | AHCI_PCI_INTEL_MAP_SMS_AHCI |
		    AHCI_PCI_INTEL_MAP_SC_6P);
		/* clear BAR since it keeps the old IO value */
		pci_conf_write(pa->pa_pc, pa->pa_tag,
		    AHCI_PCI_BAR, 0);
	}
	sc->sc_flags |= AHCI_F_NO_PMP;
	return (0);
}

int
ahci_pci_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args		*pa = aux;
	const struct ahci_device	*ad;

	ad = ahci_lookup_device(pa);
	if (ad != NULL) {
		/* the device may need special checks to see if it matches */
		if (ad->ad_match != NULL)
			return (ad->ad_match(pa));

		return (2); /* match higher than pciide */
	}

	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_MASS_STORAGE &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_MASS_STORAGE_SATA &&
	    PCI_INTERFACE(pa->pa_class) == AHCI_PCI_INTERFACE)
		return (2);

	return (0);
}

void
ahci_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct ahci_softc		*sc = (struct ahci_softc *)self;
	struct pci_attach_args		*pa = aux;
	struct atascsi_attach_args	aaa;
	const struct ahci_device	*ad;
	pci_intr_handle_t		ih;
	u_int32_t			pi;
	int				i;

	sc->sc_pc = pa->pa_pc;

	ad = ahci_lookup_device(pa);
	if (ad != NULL && ad->ad_attach != NULL) {
		if (ad->ad_attach(sc, pa) != 0) {
			/* error should be printed by ad_attach */
			return;
		}
	}

	if (pci_intr_map_msi(pa, &ih) != 0 && pci_intr_map(pa, &ih) != 0) {
		printf(": unable to map interrupt\n");
		return;
	}
	printf(": %s,", pci_intr_string(pa->pa_pc, ih));

	if (ahci_map_regs(sc, pa) != 0) {
		/* error already printed by ahci_map_regs */
		return;
	}

	if (ahci_init(sc) != 0) {
		/* error already printed by ahci_init */
		goto unmap;
	}

	if (ahci_map_intr(sc, pa, ih) != 0) {
		/* error already printed by ahci_map_intr */
		goto unmap;
	}

	printf("\n");

	sc->sc_dmat = pa->pa_dmat;

	sc->sc_cap = ahci_read(sc, AHCI_REG_CAP);
	sc->sc_ncmds = AHCI_REG_CAP_NCS(sc->sc_cap);
#ifdef AHCI_DEBUG
	if (ahcidebug & AHCI_D_VERBOSE) {
		const char *gen;

		switch (sc->sc_cap & AHCI_REG_CAP_ISS) {
		case AHCI_REG_CAP_ISS_G1:
			gen = "1 (1.5Gbps)";
			break;
		case AHCI_REG_CAP_ISS_G1_2:
			gen = "1 (1.5Gbps) and 2 (3Gbps)";
			break;
		default:
			gen = "unknown";
			break;
		}

		printf("%s: capabilities 0x%b, %d ports, %d cmds, gen %s\n",
		    DEVNAME(sc), sc->sc_cap, AHCI_FMT_CAP,
		    AHCI_REG_CAP_NP(sc->sc_cap), sc->sc_ncmds, gen);
	}
#endif

	pi = ahci_read(sc, AHCI_REG_PI);
	DPRINTF(AHCI_D_VERBOSE, "%s: ports implemented: 0x%08x\n",
	    DEVNAME(sc), pi);

#ifdef AHCI_COALESCE
	/* Naive coalescing support - enable for all ports. */
	if (sc->sc_cap & AHCI_REG_CAP_CCCS) {
		u_int16_t		ccc_timeout = 20;
		u_int8_t		ccc_numcomplete = 12;
		u_int32_t		ccc_ctl;

		/* disable coalescing during reconfiguration. */
		ccc_ctl = ahci_read(sc, AHCI_REG_CCC_CTL);
		ccc_ctl &= ~0x00000001;
		ahci_write(sc, AHCI_REG_CCC_CTL, ccc_ctl);

		sc->sc_ccc_mask = 1 << AHCI_REG_CCC_CTL_INT(ccc_ctl);
		if (pi & sc->sc_ccc_mask) {
			/* A conflict with the implemented port list? */
			printf("%s: coalescing interrupt/implemented port list "
			    "conflict, PI: %08x, ccc_mask: %08x\n",
			    DEVNAME(sc), pi, sc->sc_ccc_mask);
			sc->sc_ccc_mask = 0;
			goto noccc;
		}

		/* ahci_port_start will enable each port when it starts. */
		sc->sc_ccc_ports = pi;
		sc->sc_ccc_ports_cur = 0;

		/* program thresholds and enable overall coalescing. */
		ccc_ctl &= ~0xffffff00;
		ccc_ctl |= (ccc_timeout << 16) | (ccc_numcomplete << 8);
		ahci_write(sc, AHCI_REG_CCC_CTL, ccc_ctl);
		ahci_write(sc, AHCI_REG_CCC_PORTS, 0);
		ahci_write(sc, AHCI_REG_CCC_CTL, ccc_ctl | 1);
	}
noccc:
#endif
	for (i = 0; i < AHCI_MAX_PORTS; i++) {
		if (!ISSET(pi, 1 << i)) {
			/* dont allocate stuff if the port isnt implemented */
			continue;
		}

		if (ahci_port_alloc(sc, i) == ENOMEM)
			goto freeports;
	}

	bzero(&aaa, sizeof(aaa));
	aaa.aaa_cookie = sc;
	aaa.aaa_methods = &ahci_atascsi_methods;
	aaa.aaa_minphys = NULL;
	aaa.aaa_nports = AHCI_MAX_PORTS;
	aaa.aaa_ncmds = sc->sc_ncmds - 1;
	if (!(sc->sc_flags & AHCI_F_NO_NCQ) &&
	    (sc->sc_cap & AHCI_REG_CAP_SNCQ)) {
		aaa.aaa_capability |= ASAA_CAP_NCQ | ASAA_CAP_PMP_NCQ;
		/* XXX enabling ASAA_CAP_PMP_NCQ with FBS:
		 * - some error recovery work required (single device vs port
		 *   errors)
		 * - probably need to look at storing our active ccb queue
		 *   differently so we can group ncq and non-ncq commands
		 *   for different ports.  as long as we preserve the order for
		 *   each port, we can reorder commands to get more ncq 
		 *   commands to run in parallel.
		 */
	}

	sc->sc_atascsi = atascsi_attach(&sc->sc_dev, &aaa);

	/* Enable interrupts */
	ahci_write(sc, AHCI_REG_GHC, AHCI_REG_GHC_AE | AHCI_REG_GHC_IE);

	return;

freeports:
	for (i = 0; i < AHCI_MAX_PORTS; i++) {
		if (sc->sc_ports[i] != NULL)
			ahci_port_free(sc, i);
	}
unmap:
	/* Disable controller */
	ahci_write(sc, AHCI_REG_GHC, 0);
	ahci_unmap_regs(sc);
	return;
}

int
ahci_pci_detach(struct device *self, int flags)
{
	struct ahci_softc		*sc = (struct ahci_softc *)self;
	int				 rv, i;

	if (sc->sc_atascsi != NULL) {
		rv = atascsi_detach(sc->sc_atascsi, flags);
		if (rv != 0)
			return (rv);
	}

	for (i = 0; i < AHCI_MAX_PORTS; i++) {
		if (sc->sc_ports[i] != NULL)
			ahci_port_free(sc, i);
	}

	ahci_unmap_intr(sc);
	ahci_unmap_regs(sc);

	return (0);
}

int
ahci_pci_activate(struct device *self, int act)
{
	struct ahci_softc		*sc = (struct ahci_softc *)self;
	int				 i, rv = 0;

	switch (act) {
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);
		break;
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		for (i = 0; i < AHCI_MAX_PORTS; i++) {
			if (sc->sc_ports[i] != NULL)
				ahci_port_stop(sc->sc_ports[i], 1);
		}
		break;
	case DVACT_RESUME:
		/* enable ahci (global interrupts disabled) */
		ahci_write(sc, AHCI_REG_GHC, AHCI_REG_GHC_AE);

		/* restore BIOS initialised parameters */
		ahci_write(sc, AHCI_REG_CAP, sc->sc_cap);

		for (i = 0; i < AHCI_MAX_PORTS; i++) {
			if (sc->sc_ports[i] != NULL)
				ahci_port_init(sc, i);
		}

		/* Enable interrupts */
		ahci_write(sc, AHCI_REG_GHC, AHCI_REG_GHC_AE | AHCI_REG_GHC_IE);

		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

int
ahci_map_regs(struct ahci_softc *sc, struct pci_attach_args *pa)
{
	pcireg_t			maptype;

	maptype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, AHCI_PCI_BAR);
	if (pci_mapreg_map(pa, AHCI_PCI_BAR, maptype, 0, &sc->sc_iot,
	    &sc->sc_ioh, NULL, &sc->sc_ios, 0) != 0) {
		printf(" unable to map registers\n");
		return (1);
	}

	return (0);
}

void
ahci_unmap_regs(struct ahci_softc *sc)
{
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
	sc->sc_ios = 0;
}

int
ahci_map_intr(struct ahci_softc *sc, struct pci_attach_args *pa,
    pci_intr_handle_t ih)
{
	sc->sc_ih = pci_intr_establish(sc->sc_pc, ih, IPL_BIO,
	    ahci_intr, sc, DEVNAME(sc));
	if (sc->sc_ih == NULL) {
		printf("%s: unable to map interrupt\n", DEVNAME(sc));
		return (1);
	}

	return (0);
}

void
ahci_unmap_intr(struct ahci_softc *sc)
{
	pci_intr_disestablish(sc->sc_pc, sc->sc_ih);
}

int
ahci_init(struct ahci_softc *sc)
{
	u_int32_t			reg, cap, pi;
	const char			*revision;

	DPRINTF(AHCI_D_VERBOSE, " GHC 0x%b", ahci_read(sc, AHCI_REG_GHC),
	    AHCI_FMT_GHC);

	/* save BIOS initialised parameters, enable staggered spin up */
	cap = ahci_read(sc, AHCI_REG_CAP);
	cap &= AHCI_REG_CAP_SMPS;
	cap |= AHCI_REG_CAP_SSS;
	pi = ahci_read(sc, AHCI_REG_PI);

	if (ISSET(AHCI_REG_GHC_AE, ahci_read(sc, AHCI_REG_GHC))) {
		/* reset the controller */
		ahci_write(sc, AHCI_REG_GHC, AHCI_REG_GHC_HR);
		if (ahci_wait_ne(sc, AHCI_REG_GHC, AHCI_REG_GHC_HR,
		    AHCI_REG_GHC_HR) != 0) {
			printf(" unable to reset controller\n");
			return (1);
		}
	}

	/* enable ahci (global interrupts disabled) */
	ahci_write(sc, AHCI_REG_GHC, AHCI_REG_GHC_AE);

	/* restore parameters */
	ahci_write(sc, AHCI_REG_CAP, cap);
	ahci_write(sc, AHCI_REG_PI, pi);

	/* check the revision */
	reg = ahci_read(sc, AHCI_REG_VS);
	switch (reg) {
	case AHCI_REG_VS_0_95:
		revision = "0.95";
		break;
	case AHCI_REG_VS_1_0:
		revision = "1.0";
		break;
	case AHCI_REG_VS_1_1:
		revision = "1.1";
		break;
	case AHCI_REG_VS_1_2:
		revision = "1.2";
		break;
	case AHCI_REG_VS_1_3:
		revision = "1.3";
		break;

	default:
		printf(" unsupported AHCI revision 0x%08x\n", reg);
		return (1);
	}

	printf(" AHCI %s", revision);

	return (0);
}

void
ahci_enable_interrupts(struct ahci_port *ap)
{
	ahci_pwrite(ap, AHCI_PREG_IE, AHCI_PREG_IE_TFEE | AHCI_PREG_IE_HBFE |
	    AHCI_PREG_IE_IFE | AHCI_PREG_IE_OFE | AHCI_PREG_IE_DPE |
	    AHCI_PREG_IE_UFE |
	    ((ap->ap_sc->sc_cap & AHCI_REG_CAP_SSNTF) ? AHCI_PREG_IE_IPME : 0) |
#ifdef AHCI_COALESCE
	    ((ap->ap_sc->sc_ccc_ports & (1 << ap->ap_port)) ? 0 :
	     (AHCI_PREG_IE_SDBE | AHCI_PREG_IE_DHRE))
#else
	    AHCI_PREG_IE_SDBE | AHCI_PREG_IE_DHRE
#endif
	    );
}

int
ahci_port_alloc(struct ahci_softc *sc, u_int port)
{
	struct ahci_port		*ap;
	struct ahci_ccb			*ccb;
	u_int64_t			dva;
	u_int32_t			cmd;
	struct ahci_cmd_hdr		*hdr;
	struct ahci_cmd_table		*table;
	int				i, rc = ENOMEM;

	ap = malloc(sizeof(*ap), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (ap == NULL) {
		printf("%s: unable to allocate memory for port %d\n",
		    DEVNAME(sc), port);
		goto reterr;
	}
	ap->ap_err_scratch = dma_alloc(DEV_BSIZE, PR_NOWAIT | PR_ZERO);
	if (ap->ap_err_scratch == NULL) {
		printf("%s: unable to allocate DMA scratch buf for port %d\n",
		    DEVNAME(sc), port);
		goto freeport;
	}

#ifdef AHCI_DEBUG
	snprintf(ap->ap_name, sizeof(ap->ap_name), "%s.%d",
	    DEVNAME(sc), port);
#endif
	ap->ap_port = port;
	sc->sc_ports[port] = ap;

	if (bus_space_subregion(sc->sc_iot, sc->sc_ioh,
	    AHCI_PORT_REGION(port), AHCI_PORT_SIZE, &ap->ap_ioh) != 0) {
		printf("%s: unable to create register window for port %d\n",
		    DEVNAME(sc), port);
		goto freeport;
	}

	ap->ap_sc = sc;
#ifdef AHCI_COALESCE
	ap->ap_num = port;
#endif
	TAILQ_INIT(&ap->ap_ccb_free);
	TAILQ_INIT(&ap->ap_ccb_pending);
	mtx_init(&ap->ap_ccb_mtx, IPL_BIO);

	/* Disable port interrupts */
	ahci_pwrite(ap, AHCI_PREG_IE, 0);

	/* Sec 10.1.2 - deinitialise port if it is already running */
	cmd = ahci_pread(ap, AHCI_PREG_CMD);
	if (ISSET(cmd, (AHCI_PREG_CMD_ST | AHCI_PREG_CMD_CR |
	    AHCI_PREG_CMD_FRE | AHCI_PREG_CMD_FR)) ||
	    ISSET(ahci_pread(ap, AHCI_PREG_SCTL), AHCI_PREG_SCTL_DET)) {
		int r;

		r = ahci_port_stop(ap, 1);
		if (r) {
			printf("%s: unable to disable %s, ignoring port %d\n",
			    DEVNAME(sc), r == 2 ? "CR" : "FR", port);
			rc = ENXIO;
			goto freeport;
		}

		/* Write DET to zero */
		ahci_pwrite(ap, AHCI_PREG_SCTL, 0);
	}

	/* XXX FBS - need to allocate 16x ahci_rfis struct? - but we don't
	 * know if there's a PMP attached or if the HBA supports FBS yet..
	 * reallocate when we enable FBS?
	 */

	/* Allocate RFIS */
	ap->ap_dmamem_rfis = ahci_dmamem_alloc(sc, sizeof(struct ahci_rfis));
	if (ap->ap_dmamem_rfis == NULL)
		goto nomem;

	/* Setup RFIS base address */
	ap->ap_rfis = (struct ahci_rfis *) AHCI_DMA_KVA(ap->ap_dmamem_rfis);
	dva = AHCI_DMA_DVA(ap->ap_dmamem_rfis);
	ahci_pwrite(ap, AHCI_PREG_FBU, (u_int32_t)(dva >> 32));
	ahci_pwrite(ap, AHCI_PREG_FB, (u_int32_t)dva);

	/* Enable FIS reception and activate port. */
	cmd = ahci_pread(ap, AHCI_PREG_CMD) & ~AHCI_PREG_CMD_ICC;
	cmd |= AHCI_PREG_CMD_FRE | AHCI_PREG_CMD_POD | AHCI_PREG_CMD_SUD;
	ahci_pwrite(ap, AHCI_PREG_CMD, cmd | AHCI_PREG_CMD_ICC_ACTIVE);

	/* Check whether port activated.  Skip it if not. */
	cmd = ahci_pread(ap, AHCI_PREG_CMD) & ~AHCI_PREG_CMD_ICC;
	if (!ISSET(cmd, AHCI_PREG_CMD_FRE)) {
		rc = ENXIO;
		goto freeport;
	}

	/* Allocate a CCB for each command slot */
	ap->ap_ccbs = malloc(sizeof(struct ahci_ccb) * sc->sc_ncmds, M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (ap->ap_ccbs == NULL) {
		printf("%s: unable to allocate command list for port %d\n",
		    DEVNAME(sc), port);
		goto freeport;
	}

	/* Command List Structures and Command Tables */
	ap->ap_dmamem_cmd_list = ahci_dmamem_alloc(sc,
	    sc->sc_ncmds * sizeof(struct ahci_cmd_hdr));
	ap->ap_dmamem_cmd_table = ahci_dmamem_alloc(sc,
	    sc->sc_ncmds * sizeof(struct ahci_cmd_table));
	if (ap->ap_dmamem_cmd_table == NULL || ap->ap_dmamem_cmd_list == NULL) {
nomem:
		printf("%s: unable to allocate DMA memory for port %d\n",
		    DEVNAME(sc), port);
		goto freeport;
	}

	/* Setup command list base address */
	dva = AHCI_DMA_DVA(ap->ap_dmamem_cmd_list);
	ahci_pwrite(ap, AHCI_PREG_CLBU, (u_int32_t)(dva >> 32));
	ahci_pwrite(ap, AHCI_PREG_CLB, (u_int32_t)dva);

	/* Split CCB allocation into CCBs and assign to command header/table */
	hdr = AHCI_DMA_KVA(ap->ap_dmamem_cmd_list);
	table = AHCI_DMA_KVA(ap->ap_dmamem_cmd_table);
	for (i = 0; i < sc->sc_ncmds; i++) {
		ccb = &ap->ap_ccbs[i];

		if (bus_dmamap_create(sc->sc_dmat, MAXPHYS, AHCI_MAX_PRDT,
		    (4 * 1024 * 1024), 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
		    &ccb->ccb_dmamap) != 0) {
			printf("%s: unable to create dmamap for port %d "
			    "ccb %d\n", DEVNAME(sc), port, i);
			goto freeport;
		}

		ccb->ccb_slot = i;
		ccb->ccb_port = ap;
		ccb->ccb_cmd_hdr = &hdr[i];
		ccb->ccb_cmd_table = &table[i];
		dva = AHCI_DMA_DVA(ap->ap_dmamem_cmd_table) +
		    ccb->ccb_slot * sizeof(struct ahci_cmd_table);
		ccb->ccb_cmd_hdr->ctba_hi = htole32((u_int32_t)(dva >> 32));
		ccb->ccb_cmd_hdr->ctba_lo = htole32((u_int32_t)dva);

		ccb->ccb_xa.fis =
		    (struct ata_fis_h2d *)ccb->ccb_cmd_table->cfis;
		ccb->ccb_xa.packetcmd = ccb->ccb_cmd_table->acmd;
		ccb->ccb_xa.tag = i;

		ccb->ccb_xa.state = ATA_S_COMPLETE;
		ahci_put_ccb(ccb);
	}

	/* grab a ccb for use during error recovery */
	ap->ap_ccb_err = &ap->ap_ccbs[sc->sc_ncmds - 1];
	TAILQ_REMOVE(&ap->ap_ccb_free, ap->ap_ccb_err, ccb_entry);
	ap->ap_ccb_err->ccb_xa.state = ATA_S_COMPLETE;

	/* Wait for ICC change to complete */
	ahci_pwait_clr(ap, AHCI_PREG_CMD, AHCI_PREG_CMD_ICC, 1);

	/* Reset port */
	rc = ahci_port_portreset(ap, 1);

	switch (rc) {
	case ENODEV:
		switch (ahci_pread(ap, AHCI_PREG_SSTS) & AHCI_PREG_SSTS_DET) {
		case AHCI_PREG_SSTS_DET_DEV_NE:
			printf("%s: device not communicating on port %d\n",
			    DEVNAME(sc), port);
			break;
		case AHCI_PREG_SSTS_DET_PHYOFFLINE:
			printf("%s: PHY offline on port %d\n", DEVNAME(sc),
			    port);
			break;
		default:
			DPRINTF(AHCI_D_VERBOSE, "%s: no device detected "
			    "on port %d\n", DEVNAME(sc), port);
			break;
		}
		goto freeport;

	case EBUSY:
		printf("%s: device on port %d didn't come ready, "
		    "TFD: 0x%b\n", DEVNAME(sc), port,
		    ahci_pread(ap, AHCI_PREG_TFD), AHCI_PFMT_TFD_STS);

		/* Try a soft reset to clear busy */
		rc = ahci_port_softreset(ap);
		if (rc) {
			printf("%s: unable to communicate "
			    "with device on port %d\n", DEVNAME(sc), port);
			goto freeport;
		}
		break;

	default:
		break;
	}

	DPRINTF(AHCI_D_VERBOSE, "%s: detected device on port %d; %d\n",
	    DEVNAME(sc), port, rc);

	/* Enable command transfers on port */
	if (ahci_port_start(ap, 0)) {
		printf("%s: failed to start command DMA on port %d, "
		    "disabling\n", DEVNAME(sc), port);
		rc = ENXIO;	/* couldn't start port */
	}

	/* Flush interrupts for port */
	ahci_pwrite(ap, AHCI_PREG_IS, ahci_pread(ap, AHCI_PREG_IS));
	ahci_write(sc, AHCI_REG_IS, 1 << port);

	ahci_enable_interrupts(ap);

freeport:
	if (rc != 0)
		ahci_port_free(sc, port);
reterr:
	return (rc);
}

void
ahci_port_free(struct ahci_softc *sc, u_int port)
{
	struct ahci_port		*ap = sc->sc_ports[port];
	struct ahci_ccb			*ccb;

	/* Ensure port is disabled and its interrupts are flushed */
	if (ap->ap_sc) {
		ahci_pwrite(ap, AHCI_PREG_CMD, 0);
		ahci_pwrite(ap, AHCI_PREG_IE, 0);
		ahci_pwrite(ap, AHCI_PREG_IS, ahci_pread(ap, AHCI_PREG_IS));
		ahci_write(sc, AHCI_REG_IS, 1 << port);
	}

	if (ap->ap_ccb_err)
		ahci_put_ccb(ap->ap_ccb_err);

	if (ap->ap_ccbs) {
		while ((ccb = ahci_get_ccb(ap)) != NULL)
			bus_dmamap_destroy(sc->sc_dmat, ccb->ccb_dmamap);
		free(ap->ap_ccbs, M_DEVBUF);
	}

	if (ap->ap_dmamem_cmd_list)
		ahci_dmamem_free(sc, ap->ap_dmamem_cmd_list);
	if (ap->ap_dmamem_rfis)
		ahci_dmamem_free(sc, ap->ap_dmamem_rfis);
	if (ap->ap_dmamem_cmd_table)
		ahci_dmamem_free(sc, ap->ap_dmamem_cmd_table);
	if (ap->ap_err_scratch)
		dma_free(ap->ap_err_scratch, DEV_BSIZE);

	/* bus_space(9) says we dont free the subregions handle */

	free(ap, M_DEVBUF);
	sc->sc_ports[port] = NULL;
}

int
ahci_port_init(struct ahci_softc *sc, u_int port)
{
	struct ahci_port		*ap;
	u_int64_t			dva;
	u_int32_t			cmd;
	int				rc = ENOMEM;

	ap = sc->sc_ports[port];
#ifdef AHCI_DEBUG
	snprintf(ap->ap_name, sizeof(ap->ap_name), "%s.%d",
	    DEVNAME(sc), port);
#endif

	/* Disable port interrupts */
	ahci_pwrite(ap, AHCI_PREG_IE, 0);

	/* Sec 10.1.2 - deinitialise port if it is already running */
	cmd = ahci_pread(ap, AHCI_PREG_CMD);
	if (ISSET(cmd, (AHCI_PREG_CMD_ST | AHCI_PREG_CMD_CR |
	    AHCI_PREG_CMD_FRE | AHCI_PREG_CMD_FR)) ||
	    ISSET(ahci_pread(ap, AHCI_PREG_SCTL), AHCI_PREG_SCTL_DET)) {
		int r;

		r = ahci_port_stop(ap, 1);
		if (r) {
			printf("%s: unable to disable %s, ignoring port %d\n",
			    DEVNAME(sc), r == 2 ? "CR" : "FR", port);
			rc = ENXIO;
			goto reterr;
		}

		/* Write DET to zero */
		ahci_pwrite(ap, AHCI_PREG_SCTL, 0);
	}

	/* Setup RFIS base address */
	ap->ap_rfis = (struct ahci_rfis *) AHCI_DMA_KVA(ap->ap_dmamem_rfis);
	dva = AHCI_DMA_DVA(ap->ap_dmamem_rfis);
	ahci_pwrite(ap, AHCI_PREG_FBU, (u_int32_t)(dva >> 32));
	ahci_pwrite(ap, AHCI_PREG_FB, (u_int32_t)dva);

	/* Enable FIS reception and activate port. */
	cmd = ahci_pread(ap, AHCI_PREG_CMD) & ~AHCI_PREG_CMD_ICC;
	cmd |= AHCI_PREG_CMD_FRE | AHCI_PREG_CMD_POD | AHCI_PREG_CMD_SUD;
	ahci_pwrite(ap, AHCI_PREG_CMD, cmd | AHCI_PREG_CMD_ICC_ACTIVE);

	/* Check whether port activated.  Skip it if not. */
	cmd = ahci_pread(ap, AHCI_PREG_CMD) & ~AHCI_PREG_CMD_ICC;
	if (!ISSET(cmd, AHCI_PREG_CMD_FRE)) {
		rc = ENXIO;
		goto reterr;
	}

	/* Setup command list base address */
	dva = AHCI_DMA_DVA(ap->ap_dmamem_cmd_list);
	ahci_pwrite(ap, AHCI_PREG_CLBU, (u_int32_t)(dva >> 32));
	ahci_pwrite(ap, AHCI_PREG_CLB, (u_int32_t)dva);

	/* Wait for ICC change to complete */
	ahci_pwait_clr(ap, AHCI_PREG_CMD, AHCI_PREG_CMD_ICC, 1);

	/* Reset port */
	rc = ahci_port_portreset(ap, 1);
	switch (rc) {
	case ENODEV:
		switch (ahci_pread(ap, AHCI_PREG_SSTS) & AHCI_PREG_SSTS_DET) {
		case AHCI_PREG_SSTS_DET_DEV_NE:
			printf("%s: device not communicating on port %d\n",
			    DEVNAME(sc), port);
			break;
		case AHCI_PREG_SSTS_DET_PHYOFFLINE:
			printf("%s: PHY offline on port %d\n", DEVNAME(sc),
			    port);
			break;
		default:
			DPRINTF(AHCI_D_VERBOSE, "%s: no device detected "
			    "on port %d\n", DEVNAME(sc), port);
			break;
		}
		goto reterr;

	case EBUSY:
		printf("%s: device on port %d didn't come ready, "
		    "TFD: 0x%b\n", DEVNAME(sc), port,
		    ahci_pread(ap, AHCI_PREG_TFD), AHCI_PFMT_TFD_STS);

		/* Try a soft reset to clear busy */
		rc = ahci_port_softreset(ap);
		if (rc) {
			printf("%s: unable to communicate "
			    "with device on port %d\n", DEVNAME(sc), port);
			goto reterr;
		}
		break;

	default:
		break;
	}
	DPRINTF(AHCI_D_VERBOSE, "%s: detected device on port %d\n",
	    DEVNAME(sc), port);

	if (ap->ap_pmp_ports > 0) {
		int p;

		for (p = 0; p < ap->ap_pmp_ports; p++) {
			int sig;

			/* might need to do a portreset first here? */

			/* softreset the port */
			if (ahci_pmp_port_softreset(ap, p)) {
				printf("%s.%d: unable to probe PMP port due to"
				    " softreset failure\n", PORTNAME(ap), p);
				continue;
			}

			sig = ahci_port_signature(ap);
			printf("%s.%d: port signature returned %d\n",
			    PORTNAME(ap), p, sig);
		}
	}

	/* Enable command transfers on port */
	if (ahci_port_start(ap, 0)) {
		printf("%s: failed to start command DMA on port %d, "
		    "disabling\n", DEVNAME(sc), port);
		rc = ENXIO;	/* couldn't start port */
	}

	/* Flush interrupts for port */
	ahci_pwrite(ap, AHCI_PREG_IS, ahci_pread(ap, AHCI_PREG_IS));
	ahci_write(sc, AHCI_REG_IS, 1 << port);

	ahci_enable_interrupts(ap);

reterr:
	return (rc);
}

int
ahci_port_start(struct ahci_port *ap, int fre_only)
{
	u_int32_t			r;

	/* XXX FBS: possibly turn FBS on here */

	/* Turn on FRE (and ST) */
	r = ahci_pread(ap, AHCI_PREG_CMD) & ~AHCI_PREG_CMD_ICC;
	r |= AHCI_PREG_CMD_FRE;
	if (!fre_only)
		r |= AHCI_PREG_CMD_ST;
	ahci_pwrite(ap, AHCI_PREG_CMD, r);

#ifdef AHCI_COALESCE
	/* (Re-)enable coalescing on the port. */
	if (ap->ap_sc->sc_ccc_ports & (1 << ap->ap_num)) {
		ap->ap_sc->sc_ccc_ports_cur |= (1 << ap->ap_num);
		ahci_write(ap->ap_sc, AHCI_REG_CCC_PORTS,
		    ap->ap_sc->sc_ccc_ports_cur);
	}
#endif

	/* Wait for CR to come on */
	if (!fre_only &&
	    ahci_pwait_set(ap, AHCI_PREG_CMD, AHCI_PREG_CMD_CR, 1))
		return (1);

	return (0);
}

int
ahci_port_stop(struct ahci_port *ap, int stop_fis_rx)
{
	u_int32_t			r;

#ifdef AHCI_COALESCE
	/* Disable coalescing on the port while it is stopped. */
	if (ap->ap_sc->sc_ccc_ports & (1 << ap->ap_num)) {
		ap->ap_sc->sc_ccc_ports_cur &= ~(1 << ap->ap_num);
		ahci_write(ap->ap_sc, AHCI_REG_CCC_PORTS,
		    ap->ap_sc->sc_ccc_ports_cur);
	}
#endif

	/* Turn off ST (and FRE) */
	r = ahci_pread(ap, AHCI_PREG_CMD) & ~AHCI_PREG_CMD_ICC;
	r &= ~AHCI_PREG_CMD_ST;
	if (stop_fis_rx)
		r &= ~AHCI_PREG_CMD_FRE;
	ahci_pwrite(ap, AHCI_PREG_CMD, r);

	/* Wait for CR to go off */
	if (ahci_pwait_clr(ap, AHCI_PREG_CMD, AHCI_PREG_CMD_CR, 1))
		return (1);

	/* Wait for FR to go off */
	if (stop_fis_rx &&
	    ahci_pwait_clr(ap, AHCI_PREG_CMD, AHCI_PREG_CMD_FR, 1))
		return (2);

	/* XXX FBS: possibly disable FBS here? */

	return (0);
}

/* AHCI command list override -> forcibly clear TFD.STS.{BSY,DRQ} */
int
ahci_port_clo(struct ahci_port *ap)
{
	struct ahci_softc		*sc = ap->ap_sc;
	u_int32_t			cmd;

	/* Only attempt CLO if supported by controller */
	if (!ISSET(ahci_read(sc, AHCI_REG_CAP), AHCI_REG_CAP_SCLO))
		return (1);

	/* Issue CLO */
	cmd = ahci_pread(ap, AHCI_PREG_CMD) & ~AHCI_PREG_CMD_ICC;
#ifdef DIAGNOSTIC
	if (ISSET(cmd, AHCI_PREG_CMD_ST))
		printf("%s: CLO requested while port running\n", PORTNAME(ap));
#endif
	ahci_pwrite(ap, AHCI_PREG_CMD, cmd | AHCI_PREG_CMD_CLO);

	/* Wait for completion */
	if (ahci_pwait_clr(ap, AHCI_PREG_CMD, AHCI_PREG_CMD_CLO, 1)) {
		printf("%s: CLO did not complete\n", PORTNAME(ap));
		return (1);
	}

	return (0);
}

/* AHCI soft reset, Section 10.4.1 */
int
ahci_port_softreset(struct ahci_port *ap)
{
	struct ahci_ccb			*ccb = NULL;
	struct ahci_cmd_hdr		*cmd_slot;
	u_int8_t			*fis;
	int				s, rc = EIO, oldstate;
	u_int32_t			cmd;

	DPRINTF(AHCI_D_VERBOSE, "%s: soft reset\n", PORTNAME(ap));

	s = splbio();
	oldstate = ap->ap_state;
	ap->ap_state = AP_S_ERROR_RECOVERY;

	/* Save previous command register state */
	cmd = ahci_pread(ap, AHCI_PREG_CMD) & ~AHCI_PREG_CMD_ICC;

	/* Idle port */
	if (ahci_port_stop(ap, 0)) {
		printf("%s: failed to stop port, cannot softreset\n",
		    PORTNAME(ap));
		goto err;
	}

	/* Request CLO if device appears hung */
	if (ISSET(ahci_pread(ap, AHCI_PREG_TFD), AHCI_PREG_TFD_STS_BSY |
	    AHCI_PREG_TFD_STS_DRQ))
		ahci_port_clo(ap);

	/* Clear port errors to permit TFD transfer */
	ahci_pwrite(ap, AHCI_PREG_SERR, ahci_pread(ap, AHCI_PREG_SERR));

	/* XXX FBS - need to ensure we don't enable FBS here, since we're
	 * resetting stuff
	 * (AHCI spec 9.3.8)
	 */
	/* Restart port */
	if (ahci_port_start(ap, 0)) {
		printf("%s: failed to start port, cannot softreset\n",
		    PORTNAME(ap));
		goto err;
	}

	/* Check whether CLO worked */
	if (ahci_pwait_clr(ap, AHCI_PREG_TFD,
	    AHCI_PREG_TFD_STS_BSY | AHCI_PREG_TFD_STS_DRQ, 1)) {
		printf("%s: CLO %s, need port reset\n", PORTNAME(ap),
		    ISSET(ahci_read(ap->ap_sc, AHCI_REG_CAP), AHCI_REG_CAP_SCLO)
		    ? "failed" : "unsupported");
		rc = EBUSY;
		goto err;
	}

	/* Prep first D2H command with SRST feature & clear busy/reset flags */
	ccb = ahci_get_err_ccb(ap);
	cmd_slot = ccb->ccb_cmd_hdr;
	bzero(ccb->ccb_cmd_table, sizeof(struct ahci_cmd_table));

	fis = ccb->ccb_cmd_table->cfis;
	fis[0] = ATA_FIS_TYPE_H2D;
	fis[15] = ATA_FIS_CONTROL_SRST;

	cmd_slot->prdtl = 0;
	cmd_slot->flags = htole16(5);	/* FIS length: 5 DWORDS */
	cmd_slot->flags |= htole16(AHCI_CMD_LIST_FLAG_C); /* Clear busy on OK */
	cmd_slot->flags |= htole16(AHCI_CMD_LIST_FLAG_R); /* Reset */
	cmd_slot->flags |= htole16(AHCI_CMD_LIST_FLAG_W); /* Write */

	ccb->ccb_xa.state = ATA_S_PENDING;
	if (ahci_poll(ccb, 1000, NULL) != 0)
		goto err;

	/* Prep second D2H command to read status and complete reset sequence */
	fis[0] = ATA_FIS_TYPE_H2D;
	fis[15] = 0;

	cmd_slot->prdtl = 0;
	cmd_slot->flags = htole16(5);	/* FIS length: 5 DWORDS */
	cmd_slot->flags |= htole16(AHCI_CMD_LIST_FLAG_W);

	ccb->ccb_xa.state = ATA_S_PENDING;
	if (ahci_poll(ccb, 1000, NULL) != 0)
		goto err;

	if (ahci_pwait_clr(ap, AHCI_PREG_TFD, AHCI_PREG_TFD_STS_BSY |
	    AHCI_PREG_TFD_STS_DRQ | AHCI_PREG_TFD_STS_ERR, 1)) {
		printf("%s: device didn't come ready after reset, TFD: 0x%b\n",
		    PORTNAME(ap), ahci_pread(ap, AHCI_PREG_TFD),
		    AHCI_PFMT_TFD_STS);
		rc = EBUSY;
		goto err;
	}

	rc = 0;
err:
	if (ccb != NULL) {
		/* Abort our command, if it failed, by stopping command DMA. */
		if (rc != 0 && ISSET(ap->ap_active, 1 << ccb->ccb_slot)) {
			printf("%s: stopping the port, softreset slot %d was "
			    "still active.\n", PORTNAME(ap), ccb->ccb_slot);
			ahci_port_stop(ap, 0);
		}
		ccb->ccb_xa.state = ATA_S_ERROR;
		ahci_put_err_ccb(ccb);
	}

	/* Restore saved CMD register state */
	ahci_pwrite(ap, AHCI_PREG_CMD, cmd);
	ap->ap_state = oldstate;

	splx(s);

	return (rc);
}

int
ahci_pmp_port_softreset(struct ahci_port *ap, int pmp_port)
{
	struct ahci_ccb		*ccb = NULL;
	u_int32_t		data;
	int			count;
	int			rc;
	int			s;
	struct ahci_cmd_hdr	*cmd_slot;
	u_int8_t		*fis;

	/* XXX FBS: ensure fbs is disabled on ap, since we're resetting
	 * devices (AHCI section 9.3.8)
	 */

	s = splbio();
	/* ignore spurious IFS errors while resetting */
	DPRINTF(AHCI_D_VERBOSE, "%s: now ignoring IFS\n", PORTNAME(ap));
	ap->ap_pmp_ignore_ifs = 1;

	count = 2;
	rc = 0;
	do {
		if (ccb != NULL) {
			ahci_put_pmp_ccb(ccb);
			ccb = NULL;
		}

		if (ahci_pmp_phy_status(ap, pmp_port, &data)) {
			printf("%s.%d: unable to clear PHY status\n",
			    PORTNAME(ap), pmp_port);
		}
		ahci_pwrite(ap, AHCI_PREG_SERR, -1);
		/* maybe don't do this on the first loop: */
		ahci_pwrite(ap, AHCI_PREG_IS, AHCI_PREG_IS_IFS);
		ahci_pmp_write(ap, pmp_port, SATA_PMREG_SERR, -1);

		/* send first softreset FIS */
		ccb = ahci_get_pmp_ccb(ap);
		cmd_slot = ccb->ccb_cmd_hdr;
		bzero(ccb->ccb_cmd_table, sizeof(struct ahci_cmd_table));

		fis = ccb->ccb_cmd_table->cfis;
		fis[0] = ATA_FIS_TYPE_H2D;
		fis[1] = pmp_port;
		fis[15] = ATA_FIS_CONTROL_SRST | ATA_FIS_CONTROL_4BIT;

		cmd_slot->prdtl = 0;
		cmd_slot->flags = htole16(5);	/* FIS length: 5 DWORDS */
		cmd_slot->flags |= htole16(AHCI_CMD_LIST_FLAG_C);
		cmd_slot->flags |= htole16(AHCI_CMD_LIST_FLAG_R);
		cmd_slot->flags |= htole16(pmp_port <<
		    AHCI_CMD_LIST_FLAG_PMP_SHIFT);

		ccb->ccb_xa.state = ATA_S_PENDING;

		DPRINTF(AHCI_D_VERBOSE, "%s.%d: sending PMP softreset cmd\n",
		    PORTNAME(ap), pmp_port);
		if (ahci_poll(ccb, 1000, ahci_pmp_probe_timeout) != 0) {
			printf("%s.%d: PMP port softreset cmd failed\n",
			       PORTNAME(ap), pmp_port);
			rc = EBUSY;
			if (count > 0) {
				/* probably delay a while to allow
				 * it to settle down?
				 */
			}
			continue;
		}

		/* send signature FIS */
		bzero(ccb->ccb_cmd_table, sizeof(struct ahci_cmd_table));
		fis[0] = ATA_FIS_TYPE_H2D;
		fis[1] = pmp_port;
		fis[15] = ATA_FIS_CONTROL_4BIT;

		cmd_slot->prdtl = 0;
		cmd_slot->flags = htole16(5);	/* FIS length: 5 DWORDS */
		cmd_slot->flags |= htole16(pmp_port <<
		    AHCI_CMD_LIST_FLAG_PMP_SHIFT);

		DPRINTF(AHCI_D_VERBOSE, "%s.%d: sending PMP probe status cmd\n",
		    PORTNAME(ap), pmp_port);
		ccb->ccb_xa.state = ATA_S_PENDING;
		if (ahci_poll(ccb, 5000, ahci_pmp_probe_timeout) != 0) {
			DPRINTF(AHCI_D_VERBOSE, "%s.%d: PMP probe status cmd "
			    "failed\n", PORTNAME(ap), pmp_port);
			rc = EBUSY;
			if (count > 0) {
				/* sleep a while? */
			}
			continue;
		}

		fis[15] = 0;
		break;
	} while (count--);

	if (ccb != NULL) {
		ahci_put_pmp_ccb(ccb);
		ccb = NULL;
	}

	/* clean up a bit */
	ahci_pmp_write(ap, pmp_port, SATA_PMREG_SERR, -1);
	ahci_pwrite(ap, AHCI_PREG_SERR, -1);
	ahci_pwrite(ap, AHCI_PREG_IS, AHCI_PREG_IS_IFS);
	ap->ap_pmp_ignore_ifs = 0;
	DPRINTF(AHCI_D_VERBOSE, "%s: no longer ignoring IFS\n", PORTNAME(ap));
	splx(s);

	return (rc);
}

int
ahci_pmp_port_probe(struct ahci_port *ap, int pmp_port)
{
	int sig;
	
	ap->ap_state = AP_S_PMP_PORT_PROBE;

	DPRINTF(AHCI_D_VERBOSE, "%s.%d: probing pmp port\n", PORTNAME(ap),
	    pmp_port);
	if (ahci_pmp_port_portreset(ap, pmp_port)) {
		printf("%s.%d: unable to probe PMP port; portreset failed\n",
		    PORTNAME(ap), pmp_port);
		ap->ap_state = AP_S_NORMAL;
		return (ATA_PORT_T_NONE);
	}

	if (ahci_pmp_port_softreset(ap, pmp_port)) {
		printf("%s.%d: unable to probe PMP port due to softreset "
		    "failure\n", PORTNAME(ap), pmp_port);
		ap->ap_state = AP_S_NORMAL;
		return (ATA_PORT_T_NONE);
	}

	sig = ahci_port_signature(ap);
	DPRINTF(AHCI_D_VERBOSE, "%s.%d: port signature returned %d\n",
	    PORTNAME(ap), pmp_port, sig);
	ap->ap_state = AP_S_NORMAL;
	return (sig);
}


void
ahci_flush_tfd(struct ahci_port *ap)
{
	u_int32_t r;

	r = ahci_pread(ap, AHCI_PREG_SERR);
	if (r & AHCI_PREG_SERR_DIAG_X)
		ahci_pwrite(ap, AHCI_PREG_SERR, AHCI_PREG_SERR_DIAG_X);
}

u_int32_t
ahci_active_mask(struct ahci_port *ap)
{
	u_int32_t mask;

	mask = ahci_pread(ap, AHCI_PREG_CI);
	if (ap->ap_sc->sc_cap & AHCI_REG_CAP_SNCQ)
		mask |= ahci_pread(ap, AHCI_PREG_SACT);
	return mask;
}

void
ahci_pmp_probe_timeout(void *cookie)
{
	struct ahci_ccb *ccb = cookie;
	struct ahci_port *ap = ccb->ccb_port;
	u_int32_t mask;

	DPRINTF(AHCI_D_VERBOSE, "%s: PMP probe cmd timed out\n", PORTNAME(ap));
	switch (ccb->ccb_xa.state) {
	case ATA_S_PENDING:
		TAILQ_REMOVE(&ap->ap_ccb_pending, ccb, ccb_entry);
		ccb->ccb_xa.state = ATA_S_TIMEOUT;
		break;

	case ATA_S_ONCHIP:
	case ATA_S_ERROR:  /* currently mostly here for the ATI SBx00 quirk */
		/* clear the command on-chip */
		KASSERT(ap->ap_active == (1 << ccb->ccb_slot) &&
		    ap->ap_sactive == 0);
		ahci_port_stop(ap, 0);
		ahci_port_start(ap, 0);

		if (ahci_active_mask(ap) != 0) {
			ahci_port_stop(ap, 0);
			ahci_port_start(ap, 0);
			mask = ahci_active_mask(ap);
			if (mask != 0) {
				printf("%s: ahci_pmp_probe_timeout: failed to "
				    "clear active cmds: %08x\n", PORTNAME(ap),
				    mask);
			}
		}

		ccb->ccb_xa.state = ATA_S_TIMEOUT;
		ap->ap_active &= ~(1 << ccb->ccb_slot);
		KASSERT(ap->ap_active_cnt > 0);
		--ap->ap_active_cnt;
		DPRINTF(AHCI_D_VERBOSE, "%s: timed out %d, active %x, count %d\n",
		    PORTNAME(ap), ccb->ccb_slot, ap->ap_active, ap->ap_active_cnt);
		break;

	default:
		panic("%s: ahci_pmp_probe_timeout: ccb in bad state %d",
			PORTNAME(ap), ccb->ccb_xa.state);
	}
}

int
ahci_port_signature(struct ahci_port *ap)
{
	u_int32_t sig;

	sig = ahci_pread(ap, AHCI_PREG_SIG);
	if ((sig & 0xffff0000) == (SATA_SIGNATURE_ATAPI & 0xffff0000))
		return (ATA_PORT_T_ATAPI);
	else if ((sig & 0xffff0000) == (SATA_SIGNATURE_PORT_MULTIPLIER &
	    0xffff0000))
		return (ATA_PORT_T_PM);
	else
		return (ATA_PORT_T_DISK);
}

int
ahci_pmp_port_portreset(struct ahci_port *ap, int pmp_port)
{
	u_int32_t cmd, data;
	int loop;
	int rc = 1;
	int s;

	s = splbio();
	DPRINTF(AHCI_D_VERBOSE, "%s.%d: PMP port reset\n", PORTNAME(ap),
	    pmp_port);

	cmd = ahci_pread(ap, AHCI_PREG_CMD) & ~AHCI_PREG_CMD_ICC;

	/* turn off power management and disable the PHY */
	data = AHCI_PREG_SCTL_IPM_DISABLED;
	/* maybe add AHCI_PREG_SCTL_DET_DISABLE */
	if (ahci_pmp_write(ap, pmp_port, SATA_PMREG_SERR, -1))
		goto err;
	if (ahci_pmp_write(ap, pmp_port, SATA_PMREG_SCTL, data))
		goto err;
	delay(10000);

	/* start COMRESET */
	data = AHCI_PREG_SCTL_IPM_DISABLED | AHCI_PREG_SCTL_DET_INIT;
	if ((ap->ap_sc->sc_dev.dv_cfdata->cf_flags & 0x01) != 0) {
		DPRINTF(AHCI_D_VERBOSE, "%s.%d: forcing GEN1\n", PORTNAME(ap),
		    pmp_port);
		data |= AHCI_PREG_SCTL_SPD_GEN1;
	} else
		data |= AHCI_PREG_SCTL_SPD_ANY;
	
	if (ahci_pmp_write(ap, pmp_port, SATA_PMREG_SCTL, data))
		goto err;

	/* give it a while to settle down */
	delay(100000);

	if (ahci_pmp_phy_status(ap, pmp_port, &data)) {
		printf("%s.%d: cannot clear PHY status\n", PORTNAME(ap),
		    pmp_port);
	}

	/* start trying to negotiate */
	ahci_pmp_write(ap, pmp_port, SATA_PMREG_SERR, -1);
	data = AHCI_PREG_SCTL_IPM_DISABLED | AHCI_PREG_SCTL_DET_NONE;
	if (ahci_pmp_write(ap, pmp_port, SATA_PMREG_SCTL, data))
		goto err;

	/* give it a while to detect */
	for (loop = 3; loop; --loop) {
		if (ahci_pmp_read(ap, pmp_port, SATA_PMREG_SSTS, &data))
			goto err;
		if (data & AHCI_PREG_SSTS_DET)
			break;
		delay(100000);
	}
	if (loop == 0) {
		printf("%s.%d: port is unplugged\n", PORTNAME(ap), pmp_port);
		goto err;
	}

	/* give it even longer to fully negotiate */
	for (loop = 30; loop; --loop) {
		if (ahci_pmp_read(ap, pmp_port, SATA_PMREG_SSTS, &data))
			goto err;
		if ((data & AHCI_PREG_SSTS_DET) == AHCI_PREG_SSTS_DET_DEV)
			break;
		delay(100000);
	}

	if (loop == 0) {
		printf("%s.%d: device is not negotiating\n", PORTNAME(ap),
		    pmp_port);
		goto err;
	}

	/* device detected */
	DPRINTF(AHCI_D_VERBOSE, "%s.%d: device detected\n", PORTNAME(ap),
	    pmp_port);

	/* clean up a bit */
	delay(100000);
	ahci_pmp_write(ap, pmp_port, SATA_PMREG_SERR, -1);
	ahci_pwrite(ap, AHCI_PREG_SERR, -1);
	ahci_pwrite(ap, AHCI_PREG_IS, AHCI_PREG_IS_IFS);

	rc = 0;
err:
	splx(s);
	return (rc);
}

/* AHCI port reset, Section 10.4.2 */
int
ahci_port_portreset(struct ahci_port *ap, int pmp)
{
	u_int32_t			cmd, r;
	int				rc, s;

	s = splbio();
	DPRINTF(AHCI_D_VERBOSE, "%s: port reset\n", PORTNAME(ap));

	/* Save previous command register state */
	cmd = ahci_pread(ap, AHCI_PREG_CMD) & ~AHCI_PREG_CMD_ICC;

	/* Clear ST, ignoring failure */
	ahci_port_stop(ap, 0);

	/* Perform device detection */
	ahci_pwrite(ap, AHCI_PREG_SCTL, 0);
	delay(10000);
	r = AHCI_PREG_SCTL_IPM_DISABLED | AHCI_PREG_SCTL_DET_INIT;
	if ((ap->ap_sc->sc_dev.dv_cfdata->cf_flags & 0x01) != 0) {
		DPRINTF(AHCI_D_VERBOSE, "%s: forcing GEN1\n", PORTNAME(ap));
		r |= AHCI_PREG_SCTL_SPD_GEN1;
	} else
		r |= AHCI_PREG_SCTL_SPD_ANY;
	ahci_pwrite(ap, AHCI_PREG_SCTL, r);
	delay(10000);	/* wait at least 1ms for COMRESET to be sent */
	r &= ~AHCI_PREG_SCTL_DET_INIT;
	r |= AHCI_PREG_SCTL_DET_NONE;
	ahci_pwrite(ap, AHCI_PREG_SCTL, r);
	delay(10000);

	/* Wait for device to be detected and communications established */
	if (ahci_pwait_eq(ap, AHCI_PREG_SSTS, AHCI_PREG_SSTS_DET,
	    AHCI_PREG_SSTS_DET_DEV, 1)) {
		rc = ENODEV;
		if (ahci_pread(ap, AHCI_PREG_SSTS) & AHCI_PREG_SSTS_DET) {
			/* this may be a port multiplier with no device
			 * on port 0, so still do the pmp check if requested.
			 */
		} else {
			goto err;
		}
	} else {
		/* Clear SERR (incl X bit), so TFD can update */
		ahci_pwrite(ap, AHCI_PREG_SERR, ahci_pread(ap, AHCI_PREG_SERR));

		/* Wait for device to become ready */
		if (ahci_pwait_clr(ap, AHCI_PREG_TFD, AHCI_PREG_TFD_STS_BSY |
		    AHCI_PREG_TFD_STS_DRQ | AHCI_PREG_TFD_STS_ERR, 3)) {
			/* even if the device doesn't wake up, check if there's
			 * a port multiplier there
			 */
			rc = EBUSY;
		} else {
			rc = 0;
		}
	}

	if (pmp != 0) {
		if (ahci_port_detect_pmp(ap) != 0) {
			rc = EBUSY;
		}
	}

err:
	/* Restore preserved port state */
	ahci_pwrite(ap, AHCI_PREG_CMD, cmd);
	splx(s);

	return (rc);
}

int
ahci_port_detect_pmp(struct ahci_port *ap)
{
	int				 count, pmp_rc, rc;
	u_int32_t			 r, cmd;
	struct ahci_cmd_hdr		*cmd_slot;
	struct ahci_ccb			*ccb = NULL;
	u_int8_t			*fis = NULL;

	if ((ap->ap_sc->sc_flags & AHCI_F_NO_PMP) ||
	    !ISSET(ahci_read(ap->ap_sc, AHCI_REG_CAP), AHCI_REG_CAP_SPM)) {
		return 0;
	}

	rc = 0;
	pmp_rc = 0;
	count = 2;
	do {
		DPRINTF(AHCI_D_VERBOSE, "%s: PMP probe %d\n", PORTNAME(ap),
		    count);
		if (ccb != NULL) {
			ahci_put_pmp_ccb(ccb);
			ccb = NULL;
		}
		ahci_port_stop(ap, 0);
		ap->ap_state = AP_S_PMP_PROBE;

		/* set PMA in cmd reg */
		cmd = ahci_pread(ap, AHCI_PREG_CMD) & ~AHCI_PREG_CMD_ICC;
		if ((cmd & AHCI_PREG_CMD_PMA) == 0) {
			cmd |= AHCI_PREG_CMD_PMA;
			ahci_pwrite(ap, AHCI_PREG_CMD, cmd);
		}

		/* Flush errors and request CLO unconditionally,
		 * then start the port
		 */
		r = ahci_pread(ap, AHCI_PREG_SERR);
		if (r & AHCI_PREG_SERR_DIAG_X)
			ahci_pwrite(ap, AHCI_PREG_SERR,
			    AHCI_PREG_SERR_DIAG_X);
		
		/* Request CLO */
		ahci_port_clo(ap);

		/* Clear port errors to permit TFD transfer */
		r = ahci_pread(ap, AHCI_PREG_SERR);
		ahci_pwrite(ap, AHCI_PREG_SERR, r);

		/* XXX FBS: ensure we don't enable FBS here, since
		 * we're resetting the port
		 * (AHCI section 9.3.8)
		 */
		/* Restart port */
		if (ahci_port_start(ap, 0)) {
			rc = EBUSY;
			printf("%s: failed to start port, cannot probe PMP\n",
			    PORTNAME(ap));
			break;
		}

		/* Check whether CLO worked */
		if (ahci_pwait_clr(ap, AHCI_PREG_TFD,
		    AHCI_PREG_TFD_STS_BSY | AHCI_PREG_TFD_STS_DRQ, 1)) {
			u_int32_t cap;

			cap = ahci_read(ap->ap_sc, AHCI_REG_CAP);
			printf("%s: CLO %s, need port reset\n",
			    PORTNAME(ap),
			    ISSET(cap, AHCI_REG_CAP_SCLO)
			    ? "failed" : "unsupported");
			pmp_rc = EBUSY;
			break;
		}

		/* Prep first command with SRST feature &
		 * clear busy/reset flags
		 */
		ccb = ahci_get_pmp_ccb(ap);
		cmd_slot = ccb->ccb_cmd_hdr;
		bzero(ccb->ccb_cmd_table,
		    sizeof(struct ahci_cmd_table));

		fis = ccb->ccb_cmd_table->cfis;
		fis[0] = ATA_FIS_TYPE_H2D;
		fis[1] = SATA_PMP_CONTROL_PORT;
		fis[15] = ATA_FIS_CONTROL_SRST | ATA_FIS_CONTROL_4BIT;

		cmd_slot->prdtl = 0;
		cmd_slot->flags = htole16(5); /* FIS length: 5 DWORDS */
		cmd_slot->flags |= htole16(AHCI_CMD_LIST_FLAG_C);
		cmd_slot->flags |= htole16(AHCI_CMD_LIST_FLAG_R);
		cmd_slot->flags |= htole16(AHCI_CMD_LIST_FLAG_PMP);

		DPRINTF(AHCI_D_VERBOSE, "%s: sending PMP reset cmd\n",
		    PORTNAME(ap));
		ccb->ccb_xa.state = ATA_S_PENDING;
		if (ahci_poll(ccb, 1000, ahci_pmp_probe_timeout) != 0) {
			DPRINTF(AHCI_D_VERBOSE, "%s: PMP reset cmd failed\n",
			    PORTNAME(ap));
			pmp_rc = EBUSY;
			continue;
		}

		if (ahci_pwait_clr(ap, AHCI_PREG_TFD,
		    AHCI_PREG_TFD_STS_BSY | AHCI_PREG_TFD_STS_DRQ, 1)) {
			printf("%s: port busy after first PMP probe FIS\n",
			    PORTNAME(ap));
		}

		/* clear errors in case the device
		 * didn't reset cleanly
		 */
		ahci_flush_tfd(ap);
		r = ahci_pread(ap, AHCI_PREG_SERR);
		ahci_pwrite(ap, AHCI_PREG_SERR, r);

		/* Prep second command to read status and
		 * complete reset sequence
		 */
		bzero(ccb->ccb_cmd_table,
		    sizeof(struct ahci_cmd_table));
		fis[0] = ATA_FIS_TYPE_H2D;
		fis[1] = SATA_PMP_CONTROL_PORT;
		fis[15] = ATA_FIS_CONTROL_4BIT;

		cmd_slot->prdtl = 0;
		cmd_slot->flags = htole16(5); /* FIS length: 5 DWORDS */
		cmd_slot->flags |= htole16(AHCI_CMD_LIST_FLAG_PMP);

		DPRINTF(AHCI_D_VERBOSE, "%s: sending PMP probe status cmd\n",
		    PORTNAME(ap));
		ccb->ccb_xa.state = ATA_S_PENDING;
		if (ahci_poll(ccb, 5000, ahci_pmp_probe_timeout) != 0) {
			DPRINTF(AHCI_D_VERBOSE, "%s: PMP probe status "
			    "cmd failed\n", PORTNAME(ap));
			pmp_rc = EBUSY;
			continue;
		}

		/* apparently we need to retry at least once
		 * to get the right signature
		 */
		fis[15] = 0;
		pmp_rc = 0;
	} while (--count);

	if (ccb != NULL) {
		ahci_put_pmp_ccb(ccb);
		ccb = NULL;
	}

	if (ap->ap_state == AP_S_PMP_PROBE) {
		ap->ap_state = AP_S_NORMAL;
	}

	if (pmp_rc == 0) {
		if (ahci_port_signature(ap) != ATA_PORT_T_PM) {
			DPRINTF(AHCI_D_VERBOSE, "%s: device is not a PMP\n",
			    PORTNAME(ap));
			pmp_rc = EBUSY;
		} else {
			DPRINTF(AHCI_D_VERBOSE, "%s: PMP found\n",
			    PORTNAME(ap));
		}
	}

	if (pmp_rc == 0) {
		if (ahci_pmp_identify(ap, &ap->ap_pmp_ports)) {
			pmp_rc = EBUSY;
		} else {
			/* XXX enable FBS if available */
			rc = 0;
		}
	}

	/* if PMP detection failed, so turn off the PMA bit and
	 * reset the port again
	 */
	if (pmp_rc != 0) {
		DPRINTF(AHCI_D_VERBOSE, "%s: no PMP found, resetting "
		    "the port\n", PORTNAME(ap));
		ahci_port_stop(ap, 0);
		ahci_port_clo(ap);
		cmd = ahci_pread(ap, AHCI_PREG_CMD) & ~AHCI_PREG_CMD_ICC;
		cmd &= ~AHCI_PREG_CMD_PMA;
		ahci_pwrite(ap, AHCI_PREG_CMD, cmd);

		ahci_pwrite(ap, AHCI_PREG_IE, 0);
		ahci_port_stop(ap, 0);
		if (ap->ap_sc->sc_cap & AHCI_REG_CAP_SSNTF)
			ahci_pwrite(ap, AHCI_PREG_SNTF, -1);
		ahci_flush_tfd(ap);
		ahci_pwrite(ap, AHCI_PREG_SERR, -1);

		ahci_pwrite(ap, AHCI_PREG_IS, -1);

		ahci_enable_interrupts(ap);

		ahci_port_portreset(ap, 0);
	}

	return (rc);
}

int
ahci_load_prdt(struct ahci_ccb *ccb)
{
	struct ahci_port		*ap = ccb->ccb_port;
	struct ahci_softc		*sc = ap->ap_sc;
	struct ata_xfer			*xa = &ccb->ccb_xa;
	struct ahci_prdt		*prdt = ccb->ccb_cmd_table->prdt, *prd;
	bus_dmamap_t			dmap = ccb->ccb_dmamap;
	struct ahci_cmd_hdr		*cmd_slot = ccb->ccb_cmd_hdr;
	u_int64_t			addr;
	int				i, error;

	if (xa->datalen == 0) {
		ccb->ccb_cmd_hdr->prdtl = 0;
		return (0);
	}

	error = bus_dmamap_load(sc->sc_dmat, dmap, xa->data, xa->datalen, NULL,
	    (xa->flags & ATA_F_NOWAIT) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
	if (error != 0) {
		printf("%s: error %d loading dmamap\n", PORTNAME(ap), error);
		return (1);
	}

	for (i = 0; i < dmap->dm_nsegs; i++) {
		prd = &prdt[i];

		addr = dmap->dm_segs[i].ds_addr;
		prd->dba_hi = htole32((u_int32_t)(addr >> 32));
		prd->dba_lo = htole32((u_int32_t)addr);
#ifdef DIAGNOSTIC
		if (addr & 1) {
			printf("%s: requested DMA at an odd address %llx\n",
			    PORTNAME(ap), (unsigned long long)addr);
			goto diagerr;
		}
		if (dmap->dm_segs[i].ds_len & 1) {
			printf("%s: requested DMA length %d is not even\n",
			    PORTNAME(ap), (int)dmap->dm_segs[i].ds_len);
			goto diagerr;
		}
#endif
		prd->flags = htole32(dmap->dm_segs[i].ds_len - 1);
	}
	if (xa->flags & ATA_F_PIO)
		prd->flags |= htole32(AHCI_PRDT_FLAG_INTR);

	cmd_slot->prdtl = htole16(dmap->dm_nsegs);

	bus_dmamap_sync(sc->sc_dmat, dmap, 0, dmap->dm_mapsize,
	    (xa->flags & ATA_F_READ) ? BUS_DMASYNC_PREREAD :
	    BUS_DMASYNC_PREWRITE);

	return (0);

#ifdef DIAGNOSTIC
diagerr:
	bus_dmamap_unload(sc->sc_dmat, dmap);
	return (1);
#endif
}

void
ahci_unload_prdt(struct ahci_ccb *ccb)
{
	struct ahci_port		*ap = ccb->ccb_port;
	struct ahci_softc		*sc = ap->ap_sc;
	struct ata_xfer			*xa = &ccb->ccb_xa;
	bus_dmamap_t			dmap = ccb->ccb_dmamap;

	if (xa->datalen != 0) {
		bus_dmamap_sync(sc->sc_dmat, dmap, 0, dmap->dm_mapsize,
		    (xa->flags & ATA_F_READ) ? BUS_DMASYNC_POSTREAD :
		    BUS_DMASYNC_POSTWRITE);

		bus_dmamap_unload(sc->sc_dmat, dmap);

		if (ccb->ccb_xa.flags & ATA_F_NCQ)
			xa->resid = 0;
		else
			xa->resid = xa->datalen -
			    letoh32(ccb->ccb_cmd_hdr->prdbc);
	}
}

int
ahci_poll(struct ahci_ccb *ccb, int timeout, void (*timeout_fn)(void *))
{
	struct ahci_port		*ap = ccb->ccb_port;
	int				s;

	s = splbio();
	ahci_start(ccb);
	do {
		if (ISSET(ahci_port_intr(ap, AHCI_PREG_CI_ALL_SLOTS),
		    1 << ccb->ccb_slot)) {
			splx(s);
			return (0);
		}
		if (ccb->ccb_xa.state == ATA_S_ERROR) {
			DPRINTF(AHCI_D_VERBOSE, "%s: ccb in slot %d errored\n",
			    PORTNAME(ap), ccb->ccb_slot);
			/* pretend it timed out? */
			if (timeout_fn != NULL) {
				timeout_fn(ccb);
			}
			splx(s);
			return (1);
		}

		delay(1000);
	} while (--timeout > 0);

	/* Run timeout while at splbio, otherwise ahci_intr could interfere. */
	if (timeout_fn != NULL)
		timeout_fn(ccb);

	splx(s);

	return (1);
}

void
ahci_start(struct ahci_ccb *ccb)
{
	struct ahci_port		*ap = ccb->ccb_port;
	struct ahci_softc		*sc = ap->ap_sc;

	/* Zero transferred byte count before transfer */
	ccb->ccb_cmd_hdr->prdbc = 0;

	/* Sync command list entry and corresponding command table entry */
	bus_dmamap_sync(sc->sc_dmat, AHCI_DMA_MAP(ap->ap_dmamem_cmd_list),
	    ccb->ccb_slot * sizeof(struct ahci_cmd_hdr),
	    sizeof(struct ahci_cmd_hdr), BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, AHCI_DMA_MAP(ap->ap_dmamem_cmd_table),
	    ccb->ccb_slot * sizeof(struct ahci_cmd_table),
	    sizeof(struct ahci_cmd_table), BUS_DMASYNC_PREWRITE);

	/* Prepare RFIS area for write by controller */
	bus_dmamap_sync(sc->sc_dmat, AHCI_DMA_MAP(ap->ap_dmamem_rfis), 0,
	    sizeof(struct ahci_rfis), BUS_DMASYNC_PREREAD);

	/* XXX FBS: need to figure out whether we still need to keep NCQ and
	 * non-queued commands separate when FBS is in use.  I guess probably
	 * not?  it's not particularly clear from the spec..
	 */

	if (ccb->ccb_xa.flags & ATA_F_NCQ) {
		/* Issue NCQ commands only when there are no outstanding
		 * standard commands. */
		if (ap->ap_active != 0 || !TAILQ_EMPTY(&ap->ap_ccb_pending) ||
		    (ap->ap_sactive != 0 &&
		     ap->ap_pmp_ncq_port != ccb->ccb_xa.pmp_port)) {
			TAILQ_INSERT_TAIL(&ap->ap_ccb_pending, ccb, ccb_entry);
		} else {
			/* XXX FBS: if using FBS, set AHCI_PREG_FBS_DEV
			 * to the port number
			 */

			KASSERT(ap->ap_active_cnt == 0);
			ap->ap_sactive |= (1 << ccb->ccb_slot);
			ccb->ccb_xa.state = ATA_S_ONCHIP;
			ahci_pwrite(ap, AHCI_PREG_SACT, 1 << ccb->ccb_slot);
			ahci_pwrite(ap, AHCI_PREG_CI, 1 << ccb->ccb_slot);
			ap->ap_pmp_ncq_port = ccb->ccb_xa.pmp_port;
		}
	} else {
		/* Wait for all NCQ commands to finish before issuing standard
		 * command. */
		if (ap->ap_sactive != 0 || ap->ap_active_cnt == 2)
			TAILQ_INSERT_TAIL(&ap->ap_ccb_pending, ccb, ccb_entry);
		else if (ap->ap_active_cnt < 2) {
			/* XXX FBS: if using FBS, set AHCI_PREG_FBS_DEV to the
			 * port number
			 */

			ap->ap_active |= 1 << ccb->ccb_slot;
			ccb->ccb_xa.state = ATA_S_ONCHIP;
			ahci_pwrite(ap, AHCI_PREG_CI, 1 << ccb->ccb_slot);
			ap->ap_active_cnt++;
		}
	}
}

void
ahci_issue_pending_ncq_commands(struct ahci_port *ap)
{
	struct ahci_ccb			*nextccb;
	u_int32_t			sact_change = 0;

	KASSERT(ap->ap_active_cnt == 0);

	nextccb = TAILQ_FIRST(&ap->ap_ccb_pending);
	if (nextccb == NULL || !(nextccb->ccb_xa.flags & ATA_F_NCQ))
		return;

	/* XXX FBS:
	 * - set AHCI_PREG_FBS_DEV for each command
	 * - one write to AHCI_PREG_CI per command
	 */

	/* Start all the NCQ commands at the head of the pending list.
	 * If a port multiplier is attached to the port, we can only
	 * issue commands for one of its ports at a time.
	 */
	if (ap->ap_sactive != 0 &&
	    ap->ap_pmp_ncq_port != nextccb->ccb_xa.pmp_port) {
		return;
	}

	ap->ap_pmp_ncq_port = nextccb->ccb_xa.pmp_port;
	do {
		TAILQ_REMOVE(&ap->ap_ccb_pending, nextccb, ccb_entry);
		sact_change |= 1 << nextccb->ccb_slot;
		nextccb->ccb_xa.state = ATA_S_ONCHIP;
		nextccb = TAILQ_FIRST(&ap->ap_ccb_pending);
	} while (nextccb && (nextccb->ccb_xa.flags & ATA_F_NCQ) &&
	    (nextccb->ccb_xa.pmp_port == ap->ap_pmp_ncq_port));

	ap->ap_sactive |= sact_change;
	ahci_pwrite(ap, AHCI_PREG_SACT, sact_change);
	ahci_pwrite(ap, AHCI_PREG_CI, sact_change);
}

void
ahci_issue_pending_commands(struct ahci_port *ap, int last_was_ncq)
{
	struct ahci_ccb			*nextccb;

	nextccb = TAILQ_FIRST(&ap->ap_ccb_pending);
	if (nextccb && (nextccb->ccb_xa.flags & ATA_F_NCQ)) {
		if (last_was_ncq) {
			KASSERT(nextccb->ccb_xa.pmp_port !=
			    ap->ap_pmp_ncq_port);
			/* otherwise it should have been started already */
		} else {
			ap->ap_active_cnt--;
		}

		/* Issue NCQ commands only when there are no outstanding
		 * standard commands, and previous NCQ commands for other
		 * PMP ports have finished.
		 */
		if (ap->ap_active == 0)
			ahci_issue_pending_ncq_commands(ap);
		else
			KASSERT(ap->ap_active_cnt == 1);
	} else if (nextccb) {
		if (ap->ap_sactive != 0 || last_was_ncq)
			KASSERT(ap->ap_active_cnt == 0);

		/* Wait for all NCQ commands to finish before issuing standard
		 * command. */
		if (ap->ap_sactive != 0)
			return;

		/* Keep up to 2 standard commands on-chip at a time. */
		do {
			TAILQ_REMOVE(&ap->ap_ccb_pending, nextccb, ccb_entry);
			ap->ap_active |= 1 << nextccb->ccb_slot;
			nextccb->ccb_xa.state = ATA_S_ONCHIP;
			/* XXX FBS: set AHCI_PREG_FBS_DEV here */
			ahci_pwrite(ap, AHCI_PREG_CI, 1 << nextccb->ccb_slot);
			if (last_was_ncq)
				ap->ap_active_cnt++;
			if (ap->ap_active_cnt == 2)
				break;
			KASSERT(ap->ap_active_cnt == 1);
			nextccb = TAILQ_FIRST(&ap->ap_ccb_pending);
		} while (nextccb && !(nextccb->ccb_xa.flags & ATA_F_NCQ));
	} else if (!last_was_ncq) {
		KASSERT(ap->ap_active_cnt == 1 || ap->ap_active_cnt == 2);

		/* Standard command finished, none waiting to start. */
		ap->ap_active_cnt--;
	} else {
		KASSERT(ap->ap_active_cnt == 0);

		/* NCQ command finished. */
	}
}

int
ahci_intr(void *arg)
{
	struct ahci_softc		*sc = arg;
	u_int32_t			is, ack = 0;
	int				port;

	/* Read global interrupt status */
	is = ahci_read(sc, AHCI_REG_IS);
	if (is == 0 || is == 0xffffffff)
		return (0);
	ack = is;

#ifdef AHCI_COALESCE
	/* Check coalescing interrupt first */
	if (is & sc->sc_ccc_mask) {
		DPRINTF(AHCI_D_INTR, "%s: command coalescing interrupt\n",
		    DEVNAME(sc));
		is &= ~sc->sc_ccc_mask;
		is |= sc->sc_ccc_ports_cur;
	}
#endif

	/* Process interrupts for each port */
	while (is) {
		port = ffs(is) - 1;
		if (sc->sc_ports[port])
			ahci_port_intr(sc->sc_ports[port],
			    AHCI_PREG_CI_ALL_SLOTS);
		is &= ~(1 << port);
	}

	/* Finally, acknowledge global interrupt */
	ahci_write(sc, AHCI_REG_IS, ack);

	return (1);
}

u_int32_t
ahci_port_intr(struct ahci_port *ap, u_int32_t ci_mask)
{
	struct ahci_softc		*sc = ap->ap_sc;
	u_int32_t			is, ci_saved, ci_masked, processed = 0;
	int				slot, need_restart = 0;
	int				process_error = 0;
	struct ahci_ccb			*ccb;
	volatile u_int32_t		*active;
#ifdef DIAGNOSTIC
	u_int32_t			tmp;
#endif

	is = ahci_pread(ap, AHCI_PREG_IS);

	/* Ack port interrupt only if checking all command slots. */
	if (ci_mask == AHCI_PREG_CI_ALL_SLOTS)
		ahci_pwrite(ap, AHCI_PREG_IS, is);

	if (is)
		DPRINTF(AHCI_D_INTR, "%s: interrupt: %b\n", PORTNAME(ap),
		    is, AHCI_PFMT_IS);

	if (ap->ap_sactive) {
		/* Active NCQ commands - use SActive instead of CI */
		KASSERT(ap->ap_active == 0);
		KASSERT(ap->ap_active_cnt == 0);
		ci_saved = ahci_pread(ap, AHCI_PREG_SACT);
		active = &ap->ap_sactive;
	} else {
		/* Save CI */
		ci_saved = ahci_pread(ap, AHCI_PREG_CI);
		active = &ap->ap_active;
	}

	if (is & AHCI_PREG_IS_TFES) {
		process_error = 1;
	} else if (is & AHCI_PREG_IS_DHRS) {
		u_int32_t tfd;
		u_int32_t cmd;
		u_int32_t serr;

		tfd = ahci_pread(ap, AHCI_PREG_TFD);
		cmd = ahci_pread(ap, AHCI_PREG_CMD);
		serr = ahci_pread(ap, AHCI_PREG_SERR);
		if ((tfd & AHCI_PREG_TFD_STS_ERR) &&
		    (cmd & AHCI_PREG_CMD_CR) == 0) {
			DPRINTF(AHCI_D_VERBOSE, "%s: DHRS error, TFD: %b, SERR:"
			    " %b, DIAG: %b\n", PORTNAME(ap), tfd,
			    AHCI_PFMT_TFD_STS, AHCI_PREG_SERR_ERR(serr),
			    AHCI_PFMT_SERR_ERR, AHCI_PREG_SERR_DIAG(serr),
			    AHCI_PFMT_SERR_DIAG);
			process_error = 1;
		} else {
			/* rfis copy back is in the normal execution path */
			ahci_pwrite(ap, AHCI_PREG_IS, AHCI_PREG_IS_DHRS);
		}
	}

	/* Command failed.  See AHCI 1.1 spec 6.2.2.1 and 6.2.2.2. */
	if (process_error) {
		u_int32_t		tfd, serr;
		int			err_slot;

		tfd = ahci_pread(ap, AHCI_PREG_TFD);
		serr = ahci_pread(ap, AHCI_PREG_SERR);

		if (ap->ap_sactive == 0) {
			/* Errored slot is easy to determine from CMD. */
			err_slot = AHCI_PREG_CMD_CCS(ahci_pread(ap,
			    AHCI_PREG_CMD));

			if ((ci_saved & (1 << err_slot)) == 0) {
				/*
				 * Hardware doesn't seem to report correct
				 * slot number. If there's only one
				 * outstanding command we can cope,
				 * otherwise fail all active commands.
				 */
				if (ap->ap_active_cnt == 1)
					err_slot = ffs(ap->ap_active) - 1;
				else
					goto failall;
			}

			ccb = &ap->ap_ccbs[err_slot];

			/* Preserve received taskfile data from the RFIS. */
			memcpy(&ccb->ccb_xa.rfis, ap->ap_rfis->rfis,
			    sizeof(struct ata_fis_d2h));
		} else
			err_slot = -1;	/* Must extract error from log page */

		DPRINTF(AHCI_D_VERBOSE, "%s: errored slot %d, TFD: %b, SERR:"
		    " %b, DIAG: %b\n", PORTNAME(ap), err_slot, tfd,
		    AHCI_PFMT_TFD_STS, AHCI_PREG_SERR_ERR(serr),
		    AHCI_PFMT_SERR_ERR, AHCI_PREG_SERR_DIAG(serr),
		    AHCI_PFMT_SERR_DIAG);

		/* Turn off ST to clear CI and SACT. */
		ahci_port_stop(ap, 0);
		need_restart = 1;

		/* Clear SERR to enable capturing new errors. */
		ahci_pwrite(ap, AHCI_PREG_SERR, serr);

		/* Acknowledge the interrupts we can recover from. */
		ahci_pwrite(ap, AHCI_PREG_IS, AHCI_PREG_IS_TFES |
		    AHCI_PREG_IS_IFS);
		is = ahci_pread(ap, AHCI_PREG_IS);

		/* If device hasn't cleared its busy status, try to idle it. */
		if (ISSET(tfd, AHCI_PREG_TFD_STS_BSY | AHCI_PREG_TFD_STS_DRQ)) {

			if ((ap->ap_state == AP_S_PMP_PORT_PROBE) ||
			    (ap->ap_state == AP_S_ERROR_RECOVERY)) {
				/* can't reset the port here, just make sure
				 * the operation fails and the port still works.
				 */
			} else if (ap->ap_pmp_ports != 0 && err_slot != -1) {
				printf("%s: error on PMP port %d, idling "
				    "device\n", PORTNAME(ap),
				    ccb->ccb_xa.pmp_port);
				if (ahci_pmp_port_softreset(ap,
				        ccb->ccb_xa.pmp_port) == 0) {
					printf("%s: unable to softreset port "
					    "%d\n", PORTNAME(ap),
					    ccb->ccb_xa.pmp_port);
					if (ahci_pmp_port_portreset(ap,
						ccb->ccb_xa.pmp_port)) {
						printf("%s: failed to port "
						    " reset %d, giving up on "
						    "it\n", PORTNAME(ap),
						    ccb->ccb_xa.pmp_port);
						goto fatal;
					}
				}
			} else {
				printf("%s: attempting to idle device\n",
				    PORTNAME(ap));
				if (ahci_port_softreset(ap)) {
					printf("%s: failed to soft reset "
					    "device\n", PORTNAME(ap));
					if (ahci_port_portreset(ap, 0)) {
						printf("%s: failed to port "
						    "reset device, give up on "
						    "it\n", PORTNAME(ap));
						goto fatal;
					}
				}
			}

			/* Had to reset device, can't gather extended info. */
		} else if (ap->ap_sactive) {
			/* Recover the NCQ error from log page 10h.
			 * XXX FBS: need to do things to figure out where the
			 * error came from.  without FBS, we know the PMP port
			 * responsible because we can only have queued commands
			 * active for one port at a time.
			 */
			ahci_port_read_ncq_error(ap, &err_slot,
			    ap->ap_pmp_ncq_port);
			if (err_slot < 0)
				goto failall;

			DPRINTF(AHCI_D_VERBOSE, "%s: NCQ errored slot %d\n",
				PORTNAME(ap), err_slot);

			ccb = &ap->ap_ccbs[err_slot];
		} else {
			/* Didn't reset, could gather extended info from log. */
		}

		/*
		 * If we couldn't determine the errored slot, reset the port
		 * and fail all the active slots.
		 */
		if (err_slot == -1) {
			if (ahci_port_softreset(ap) != 0 &&
			    ahci_port_portreset(ap, 0) != 0) {
				printf("%s: couldn't reset after NCQ error, "
				    "disabling device.\n", PORTNAME(ap));
				goto fatal;
			}
			printf("%s: couldn't recover NCQ error, failing "
			    "all outstanding commands.\n", PORTNAME(ap));
			goto failall;
		}

		/* Clear the failed command in saved CI so completion runs. */
		ci_saved &= ~(1 << err_slot);

		/* Note the error in the ata_xfer. */
		KASSERT(ccb->ccb_xa.state == ATA_S_ONCHIP);
		ccb->ccb_xa.state = ATA_S_ERROR;

#ifdef DIAGNOSTIC
		/* There may only be one outstanding standard command now. */
		if (ap->ap_sactive == 0) {
			tmp = ci_saved;
			if (tmp) {
				slot = ffs(tmp) - 1;
				tmp &= ~(1 << slot);
				KASSERT(tmp == 0);
			}
		}
#endif
	}

	/* ATI SBx00 AHCI controllers respond to PMP probes with IPMS interrupts
	 * when there's a normal SATA device attached.
	 */
	if ((ap->ap_state == AP_S_PMP_PROBE) &&
	    (ap->ap_sc->sc_flags & AHCI_F_IPMS_PROBE) &&
	    (is & AHCI_PREG_IS_IPMS)) {
		slot = AHCI_PREG_CMD_CCS(ahci_pread(ap, AHCI_PREG_CMD));
		DPRINTF(AHCI_D_INTR, "%s: slot %d received IPMS\n",
		    PORTNAME(ap), slot);

		ccb = &ap->ap_ccbs[slot];
		ccb->ccb_xa.state = ATA_S_ERROR;

		ahci_pwrite(ap, AHCI_PREG_IS, AHCI_PREG_IS_IPMS);
		is &= ~AHCI_PREG_IS_IPMS;
	}

	/* ignore IFS errors while resetting a PMP port */
	if ((is & AHCI_PREG_IS_IFS) /*&& ap->ap_pmp_ignore_ifs*/) {
		DPRINTF(AHCI_D_INTR, "%s: ignoring IFS while resetting PMP "
		    "port\n", PORTNAME(ap));

		need_restart = 1;
		ahci_pwrite(ap, AHCI_PREG_SERR, -1);
		ahci_pwrite(ap, AHCI_PREG_IS, AHCI_PREG_IS_IFS);
		is &= ~AHCI_PREG_IS_IFS;
		goto failall;
	}

	/* Check for remaining errors - they are fatal. */
	if (is & (AHCI_PREG_IS_TFES | AHCI_PREG_IS_HBFS | AHCI_PREG_IS_IFS |
	    AHCI_PREG_IS_OFS | AHCI_PREG_IS_UFS)) {
		printf("%s: unrecoverable errors (IS: %b), disabling port.\n",
		    PORTNAME(ap), is, AHCI_PFMT_IS);

		/* XXX try recovery first */
		goto fatal;
	}

	/* Fail all outstanding commands if we know the port won't recover. */
	if (ap->ap_state == AP_S_FATAL_ERROR) {
fatal:
		ap->ap_state = AP_S_FATAL_ERROR;
failall:

		/* Ensure port is shut down. */
		ahci_port_stop(ap, 1);

		/* Error all the active slots. */
		ci_masked = ci_saved & *active;
		while (ci_masked) {
			slot = ffs(ci_masked) - 1;
			ccb = &ap->ap_ccbs[slot];
			ci_masked &= ~(1 << slot);
			ccb->ccb_xa.state = ATA_S_ERROR;
		}

		/* Run completion for all active slots. */
		ci_saved &= ~*active;

		/* Don't restart the port if our problems were deemed fatal. */
		if (ap->ap_state == AP_S_FATAL_ERROR)
			need_restart = 0;
	}

	/*
	 * CCB completion is detected by noticing its slot's bit in CI has
	 * changed to zero some time after we activated it.
	 * If we are polling, we may only be interested in particular slot(s).
	 */
	ci_masked = ~ci_saved & *active & ci_mask;
	while (ci_masked) {
		slot = ffs(ci_masked) - 1;
		ccb = &ap->ap_ccbs[slot];
		ci_masked &= ~(1 << slot);

		DPRINTF(AHCI_D_INTR, "%s: slot %d is complete%s\n",
		    PORTNAME(ap), slot, ccb->ccb_xa.state == ATA_S_ERROR ?
		    " (error)" : "");

		bus_dmamap_sync(sc->sc_dmat,
		    AHCI_DMA_MAP(ap->ap_dmamem_cmd_list),
		    ccb->ccb_slot * sizeof(struct ahci_cmd_hdr),
		    sizeof(struct ahci_cmd_hdr), BUS_DMASYNC_POSTWRITE);

		bus_dmamap_sync(sc->sc_dmat,
		    AHCI_DMA_MAP(ap->ap_dmamem_cmd_table),
		    ccb->ccb_slot * sizeof(struct ahci_cmd_table),
		    sizeof(struct ahci_cmd_table), BUS_DMASYNC_POSTWRITE);

		bus_dmamap_sync(sc->sc_dmat,
		    AHCI_DMA_MAP(ap->ap_dmamem_rfis), 0,
		    sizeof(struct ahci_rfis), BUS_DMASYNC_POSTREAD);

		*active &= ~(1 << ccb->ccb_slot);
		/* Copy the rfis into the ccb if we were asked for it */
		if (ccb->ccb_xa.state == ATA_S_ONCHIP &&
		    ccb->ccb_xa.flags & ATA_F_GET_RFIS) {
			memcpy(&ccb->ccb_xa.rfis,
			       ap->ap_rfis->rfis,
			       sizeof(struct ata_fis_d2h));
		}

		ccb->ccb_done(ccb);

		processed |= 1 << ccb->ccb_slot;
	}

	if (need_restart) {
		/* Restart command DMA on the port */
		ahci_port_start(ap, 0);

		/* Re-enable outstanding commands on port. */
		if (ci_saved) {
#ifdef DIAGNOSTIC
			tmp = ci_saved;
			while (tmp) {
				slot = ffs(tmp) - 1;
				tmp &= ~(1 << slot);
				ccb = &ap->ap_ccbs[slot];
				KASSERT(ccb->ccb_xa.state == ATA_S_ONCHIP);
				KASSERT((!!(ccb->ccb_xa.flags & ATA_F_NCQ)) ==
				    (!!ap->ap_sactive));
			}
#endif
			DPRINTF(AHCI_D_VERBOSE, "%s: ahci_port_intr "
			    "re-enabling%s slots %08x\n", PORTNAME(ap),
			    ap->ap_sactive ? " NCQ" : "", ci_saved);

			/* XXX FBS:
			 * - need to set AHCI_PREG_FBS_DEV for each command
			 * - can't do multiple commands with a single write to
			 *   AHCI_PREG_CI
			 */
			if (ap->ap_sactive)
				ahci_pwrite(ap, AHCI_PREG_SACT, ci_saved);
			ahci_pwrite(ap, AHCI_PREG_CI, ci_saved);
		}
	}

	return (processed);
}

struct ahci_ccb *
ahci_get_ccb(struct ahci_port *ap)
{
	struct ahci_ccb			*ccb;

	mtx_enter(&ap->ap_ccb_mtx);
	ccb = TAILQ_FIRST(&ap->ap_ccb_free);
	if (ccb != NULL) {
		KASSERT(ccb->ccb_xa.state == ATA_S_PUT);
		TAILQ_REMOVE(&ap->ap_ccb_free, ccb, ccb_entry);
		ccb->ccb_xa.state = ATA_S_SETUP;
	}
	mtx_leave(&ap->ap_ccb_mtx);

	return (ccb);
}

void
ahci_put_ccb(struct ahci_ccb *ccb)
{
	struct ahci_port		*ap = ccb->ccb_port;

#ifdef DIAGNOSTIC
	if (ccb->ccb_xa.state != ATA_S_COMPLETE &&
	    ccb->ccb_xa.state != ATA_S_TIMEOUT &&
	    ccb->ccb_xa.state != ATA_S_ERROR) {
		printf("%s: invalid ata_xfer state %02x in ahci_put_ccb, "
		    "slot %d\n", PORTNAME(ccb->ccb_port), ccb->ccb_xa.state,
		    ccb->ccb_slot);
	}
#endif

	ccb->ccb_xa.state = ATA_S_PUT;
	mtx_enter(&ap->ap_ccb_mtx);
	TAILQ_INSERT_TAIL(&ap->ap_ccb_free, ccb, ccb_entry);
	mtx_leave(&ap->ap_ccb_mtx);
}

struct ahci_ccb *
ahci_get_err_ccb(struct ahci_port *ap)
{
	struct ahci_ccb *err_ccb;
	u_int32_t sact;

	splassert(IPL_BIO);

	/* No commands may be active on the chip. */
	sact = ahci_pread(ap, AHCI_PREG_SACT);
	if (sact != 0)
		printf("ahci_get_err_ccb but SACT %08x != 0?\n", sact);
	KASSERT(ahci_pread(ap, AHCI_PREG_CI) == 0);

#ifdef DIAGNOSTIC
	KASSERT(ap->ap_err_busy == 0);
	ap->ap_err_busy = 1;
#endif
	/* Save outstanding command state. */
	ap->ap_err_saved_active = ap->ap_active;
	ap->ap_err_saved_active_cnt = ap->ap_active_cnt;
	ap->ap_err_saved_sactive = ap->ap_sactive;

	/*
	 * Pretend we have no commands outstanding, so that completions won't
	 * run prematurely.
	 */
	ap->ap_active = ap->ap_active_cnt = ap->ap_sactive = 0;

	/*
	 * Grab a CCB to use for error recovery.  This should never fail, as
	 * we ask atascsi to reserve one for us at init time.
	 */
	err_ccb = ap->ap_ccb_err;
	err_ccb->ccb_xa.flags = 0;
	err_ccb->ccb_xa.state = ATA_S_SETUP;
	err_ccb->ccb_done = ahci_empty_done;

	return (err_ccb);
}

void
ahci_put_err_ccb(struct ahci_ccb *ccb)
{
	struct ahci_port *ap = ccb->ccb_port;
	u_int32_t sact;

	splassert(IPL_BIO);

#ifdef DIAGNOSTIC
	KASSERT(ap->ap_err_busy);
#endif
	/* No commands may be active on the chip */
	sact = ahci_pread(ap, AHCI_PREG_SACT);
	if (sact != 0)
		printf("ahci_port_err_ccb_restore but SACT %08x != 0?\n", sact);
	KASSERT(ahci_pread(ap, AHCI_PREG_CI) == 0);

#ifdef DIAGNOSTIC
	/* Done with the CCB */
	KASSERT(ccb == ap->ap_ccb_err);
#endif

	/* Restore outstanding command state */
	ap->ap_sactive = ap->ap_err_saved_sactive;
	ap->ap_active_cnt = ap->ap_err_saved_active_cnt;
	ap->ap_active = ap->ap_err_saved_active;

#ifdef DIAGNOSTIC
	ap->ap_err_busy = 0;
#endif
}

struct ahci_ccb *
ahci_get_pmp_ccb(struct ahci_port *ap)
{
	struct ahci_ccb *ccb;
	u_int32_t sact;

	/* some PMP commands need to be issued on slot 1,
	 * particularly the command that clears SRST and
	 * fetches the device signature.
	 *
	 * ensure the chip is idle and ccb 1 is available.
	 */
	splassert(IPL_BIO);

	sact = ahci_pread(ap, AHCI_PREG_SACT);
	if (sact != 0)
		printf("ahci_get_pmp_ccb; SACT %08x != 0\n", sact);
	KASSERT(ahci_pread(ap, AHCI_PREG_CI) == 0);

	ccb = &ap->ap_ccbs[1];
	KASSERT(ccb->ccb_xa.state == ATA_S_PUT);
	ccb->ccb_xa.flags = 0;
	ccb->ccb_done = ahci_pmp_cmd_done;

	mtx_enter(&ap->ap_ccb_mtx);
	TAILQ_REMOVE(&ap->ap_ccb_free, ccb, ccb_entry);
	mtx_leave(&ap->ap_ccb_mtx);

	return ccb;
}

void
ahci_put_pmp_ccb(struct ahci_ccb *ccb)
{
	struct ahci_port *ap = ccb->ccb_port;
	u_int32_t sact;
	
	/* make sure this is the right ccb */
	KASSERT(ccb == &ap->ap_ccbs[1]);

	/* No commands may be active on the chip */
	sact = ahci_pread(ap, AHCI_PREG_SACT);
	if (sact != 0)
		printf("ahci_port_err_ccb_restore but SACT %08x != 0?\n", sact);
	KASSERT(ahci_pread(ap, AHCI_PREG_CI) == 0);

	ccb->ccb_xa.state = ATA_S_PUT;
	mtx_enter(&ap->ap_ccb_mtx);
	TAILQ_INSERT_TAIL(&ap->ap_ccb_free, ccb, ccb_entry);
	mtx_leave(&ap->ap_ccb_mtx);
}

int
ahci_port_read_ncq_error(struct ahci_port *ap, int *err_slotp, int pmp_port)
{
	struct ahci_ccb			*ccb;
	struct ahci_cmd_hdr		*cmd_slot;
	u_int32_t			cmd;
	struct ata_fis_h2d		*fis;
	int				rc = EIO, oldstate;

	DPRINTF(AHCI_D_VERBOSE, "%s: read log page\n", PORTNAME(ap));
	oldstate = ap->ap_state;
	ap->ap_state = AP_S_ERROR_RECOVERY;

	/* Save command register state. */
	cmd = ahci_pread(ap, AHCI_PREG_CMD) & ~AHCI_PREG_CMD_ICC;

	/* Port should have been idled already.  Start it. */
	KASSERT((cmd & AHCI_PREG_CMD_CR) == 0);
	ahci_port_start(ap, 0);

	/* Prep error CCB for READ LOG EXT, page 10h, 1 sector. */
	ccb = ahci_get_err_ccb(ap);
	ccb->ccb_xa.flags = ATA_F_NOWAIT | ATA_F_READ | ATA_F_POLL;
	ccb->ccb_xa.data = ap->ap_err_scratch;
	ccb->ccb_xa.datalen = 512;
	cmd_slot = ccb->ccb_cmd_hdr;
	bzero(ccb->ccb_cmd_table, sizeof(struct ahci_cmd_table));

	fis = (struct ata_fis_h2d *)ccb->ccb_cmd_table->cfis;
	fis->type = ATA_FIS_TYPE_H2D;
	fis->flags = ATA_H2D_FLAGS_CMD | pmp_port;
	fis->command = ATA_C_READ_LOG_EXT;
	fis->lba_low = 0x10;		/* queued error log page (10h) */
	fis->sector_count = 1;		/* number of sectors (1) */
	fis->sector_count_exp = 0;
	fis->lba_mid = 0;		/* starting offset */
	fis->lba_mid_exp = 0;
	fis->device = 0;

	cmd_slot->flags = htole16(5);	/* FIS length: 5 DWORDS */
	cmd_slot->flags |= htole16(pmp_port << AHCI_CMD_LIST_FLAG_PMP_SHIFT);

	if (ahci_load_prdt(ccb) != 0) {
		rc = ENOMEM;	/* XXX caller must abort all commands */
		goto err;
	}

	ccb->ccb_xa.state = ATA_S_PENDING;
	if (ahci_poll(ccb, 1000, NULL) != 0 ||
	    ccb->ccb_xa.state == ATA_S_ERROR)
		goto err;

	rc = 0;
err:
	/* Abort our command, if it failed, by stopping command DMA. */
	if (rc != 0 && ISSET(ap->ap_active, 1 << ccb->ccb_slot)) {
		printf("%s: log page read failed, slot %d was still active.\n",
		    PORTNAME(ap), ccb->ccb_slot);
		ahci_port_stop(ap, 0);
	}

	/* Done with the error CCB now. */
	ahci_unload_prdt(ccb);
	ahci_put_err_ccb(ccb);

	/* Extract failed register set and tags from the scratch space. */
	if (rc == 0) {
		struct ata_log_page_10h		*log;
		int				err_slot;

		log = (struct ata_log_page_10h *)ap->ap_err_scratch;
		if (ISSET(log->err_regs.type, ATA_LOG_10H_TYPE_NOTQUEUED)) {
			/* Not queued bit was set - wasn't an NCQ error? */
			printf("%s: read NCQ error page, but not an NCQ "
			    "error?\n", PORTNAME(ap));
			rc = ESRCH;
		} else {
			/* Copy back the log record as a D2H register FIS. */
			*err_slotp = err_slot = log->err_regs.type &
			    ATA_LOG_10H_TYPE_TAG_MASK;

			ccb = &ap->ap_ccbs[err_slot];
			memcpy(&ccb->ccb_xa.rfis, &log->err_regs,
			    sizeof(struct ata_fis_d2h));
			ccb->ccb_xa.rfis.type = ATA_FIS_TYPE_D2H;
			ccb->ccb_xa.rfis.flags = 0;
		}
	}

	/* Restore saved CMD register state */
	ahci_pwrite(ap, AHCI_PREG_CMD, cmd);
	ap->ap_state = oldstate;

	return (rc);
}

struct ahci_dmamem *
ahci_dmamem_alloc(struct ahci_softc *sc, size_t size)
{
	struct ahci_dmamem		*adm;
	int				nsegs;

	adm = malloc(sizeof(*adm), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (adm == NULL)
		return (NULL);

	adm->adm_size = size;

	if (bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &adm->adm_map) != 0)
		goto admfree;

	if (bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE, 0, &adm->adm_seg,
	    1, &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO) != 0)
		goto destroy;

	if (bus_dmamem_map(sc->sc_dmat, &adm->adm_seg, nsegs, size,
	    &adm->adm_kva, BUS_DMA_NOWAIT) != 0)
		goto free;

	if (bus_dmamap_load(sc->sc_dmat, adm->adm_map, adm->adm_kva, size,
	    NULL, BUS_DMA_NOWAIT) != 0)
		goto unmap;

	return (adm);

unmap:
	bus_dmamem_unmap(sc->sc_dmat, adm->adm_kva, size);
free:
	bus_dmamem_free(sc->sc_dmat, &adm->adm_seg, 1);
destroy:
	bus_dmamap_destroy(sc->sc_dmat, adm->adm_map);
admfree:
	free(adm, M_DEVBUF);

	return (NULL);
}

void
ahci_dmamem_free(struct ahci_softc *sc, struct ahci_dmamem *adm)
{
	bus_dmamap_unload(sc->sc_dmat, adm->adm_map);
	bus_dmamem_unmap(sc->sc_dmat, adm->adm_kva, adm->adm_size);
	bus_dmamem_free(sc->sc_dmat, &adm->adm_seg, 1);
	bus_dmamap_destroy(sc->sc_dmat, adm->adm_map);
	free(adm, M_DEVBUF);
}

u_int32_t
ahci_read(struct ahci_softc *sc, bus_size_t r)
{
	bus_space_barrier(sc->sc_iot, sc->sc_ioh, r, 4,
	    BUS_SPACE_BARRIER_READ);
	return (bus_space_read_4(sc->sc_iot, sc->sc_ioh, r));
}

void
ahci_write(struct ahci_softc *sc, bus_size_t r, u_int32_t v)
{
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, r, v);
	bus_space_barrier(sc->sc_iot, sc->sc_ioh, r, 4,
	    BUS_SPACE_BARRIER_WRITE);
}

int
ahci_wait_ne(struct ahci_softc *sc, bus_size_t r, u_int32_t mask,
    u_int32_t target)
{
	int				i;

	for (i = 0; i < 1000; i++) {
		if ((ahci_read(sc, r) & mask) != target)
			return (0);
		delay(1000);
	}

	return (1);
}

u_int32_t
ahci_pread(struct ahci_port *ap, bus_size_t r)
{
	bus_space_barrier(ap->ap_sc->sc_iot, ap->ap_ioh, r, 4,
	    BUS_SPACE_BARRIER_READ);
	return (bus_space_read_4(ap->ap_sc->sc_iot, ap->ap_ioh, r));
}

void
ahci_pwrite(struct ahci_port *ap, bus_size_t r, u_int32_t v)
{
	bus_space_write_4(ap->ap_sc->sc_iot, ap->ap_ioh, r, v);
	bus_space_barrier(ap->ap_sc->sc_iot, ap->ap_ioh, r, 4,
	    BUS_SPACE_BARRIER_WRITE);
}

int
ahci_pwait_eq(struct ahci_port *ap, bus_size_t r, u_int32_t mask,
    u_int32_t target, int n)
{
	int				i;

	for (i = 0; i < n * 1000; i++) {
		if ((ahci_pread(ap, r) & mask) == target)
			return (0);
		delay(1000);
	}

	return (1);
}

int
ahci_ata_probe(void *xsc, int port, int lun)
{
	struct ahci_softc		*sc = xsc;
	struct ahci_port		*ap = sc->sc_ports[port];

	if (ap == NULL)
		return (ATA_PORT_T_NONE);

	if (lun != 0) {
		int pmp_port = lun - 1;
		if (pmp_port >= ap->ap_pmp_ports) {
			return (ATA_PORT_T_NONE);
		}
		return (ahci_pmp_port_probe(ap, pmp_port));
	} else {
		return (ahci_port_signature(ap));
	}
}

void
ahci_ata_free(void *xsc, int port, int lun)
{

}

struct ata_xfer *
ahci_ata_get_xfer(void *aaa_cookie, int port)
{
	struct ahci_softc		*sc = aaa_cookie;
	struct ahci_port		*ap = sc->sc_ports[port];
	struct ahci_ccb			*ccb;

	ccb = ahci_get_ccb(ap);
	if (ccb == NULL) {
		DPRINTF(AHCI_D_XFER, "%s: ahci_ata_get_xfer: NULL ccb\n",
		    PORTNAME(ap));
		return (NULL);
	}

	DPRINTF(AHCI_D_XFER, "%s: ahci_ata_get_xfer got slot %d\n",
	    PORTNAME(ap), ccb->ccb_slot);

	return ((struct ata_xfer *)ccb);
}

void
ahci_ata_put_xfer(struct ata_xfer *xa)
{
	struct ahci_ccb			*ccb = (struct ahci_ccb *)xa;

	DPRINTF(AHCI_D_XFER, "ahci_ata_put_xfer slot %d\n", ccb->ccb_slot);

	ahci_put_ccb(ccb);
}

void
ahci_ata_cmd(struct ata_xfer *xa)
{
	struct ahci_ccb			*ccb = (struct ahci_ccb *)xa;
	struct ahci_cmd_hdr		*cmd_slot;
	int				s;

	if (ccb->ccb_port->ap_state == AP_S_FATAL_ERROR)
		goto failcmd;

	ccb->ccb_done = ahci_ata_cmd_done;

	cmd_slot = ccb->ccb_cmd_hdr;
	cmd_slot->flags = htole16(5); /* FIS length (in DWORDs) */
	cmd_slot->flags |= htole16(xa->pmp_port <<
	    AHCI_CMD_LIST_FLAG_PMP_SHIFT);

	if (xa->flags & ATA_F_WRITE)
		cmd_slot->flags |= htole16(AHCI_CMD_LIST_FLAG_W);

	if (xa->flags & ATA_F_PACKET)
		cmd_slot->flags |= htole16(AHCI_CMD_LIST_FLAG_A);

	if (ahci_load_prdt(ccb) != 0)
		goto failcmd;

	timeout_set(&xa->stimeout, ahci_ata_cmd_timeout, ccb);

	xa->state = ATA_S_PENDING;

	if (xa->flags & ATA_F_POLL)
		ahci_poll(ccb, xa->timeout, ahci_ata_cmd_timeout);
	else {
		s = splbio();
		timeout_add_msec(&xa->stimeout, xa->timeout);
		ahci_start(ccb);
		splx(s);
	}

	return;

failcmd:
	s = splbio();
	xa->state = ATA_S_ERROR;
	ata_complete(xa);
	splx(s);
}

void
ahci_pmp_cmd_done(struct ahci_ccb *ccb)
{
	struct ata_xfer			*xa = &ccb->ccb_xa;

	if (xa->state == ATA_S_ONCHIP || xa->state == ATA_S_ERROR)
		ahci_issue_pending_commands(ccb->ccb_port,
		    xa->flags & ATA_F_NCQ);

	xa->state = ATA_S_COMPLETE;
}


void
ahci_ata_cmd_done(struct ahci_ccb *ccb)
{
	struct ata_xfer			*xa = &ccb->ccb_xa;

	timeout_del(&xa->stimeout);

	if (xa->state == ATA_S_ONCHIP || xa->state == ATA_S_ERROR)
		ahci_issue_pending_commands(ccb->ccb_port,
		    xa->flags & ATA_F_NCQ);

	ahci_unload_prdt(ccb);

	if (xa->state == ATA_S_ONCHIP)
		xa->state = ATA_S_COMPLETE;
#ifdef DIAGNOSTIC
	else if (xa->state != ATA_S_ERROR && xa->state != ATA_S_TIMEOUT)
		printf("%s: invalid ata_xfer state %02x in ahci_ata_cmd_done, "
		    "slot %d\n", PORTNAME(ccb->ccb_port), xa->state,
		    ccb->ccb_slot);
#endif
	if (xa->state != ATA_S_TIMEOUT)
		ata_complete(xa);
}

void
ahci_ata_cmd_timeout(void *arg)
{
	struct ahci_ccb			*ccb = arg;
	struct ata_xfer			*xa = &ccb->ccb_xa;
	struct ahci_port		*ap = ccb->ccb_port;
	int				s, ccb_was_started, ncq_cmd;
	volatile u_int32_t		*active;

	s = splbio();

	ncq_cmd = (xa->flags & ATA_F_NCQ);
	active = ncq_cmd ? &ap->ap_sactive : &ap->ap_active;

	if (ccb->ccb_xa.state == ATA_S_PENDING) {
		DPRINTF(AHCI_D_TIMEOUT, "%s: command for slot %d timed out "
		    "before it got on chip\n", PORTNAME(ap), ccb->ccb_slot);
		TAILQ_REMOVE(&ap->ap_ccb_pending, ccb, ccb_entry);
		ccb_was_started = 0;
	} else if (ccb->ccb_xa.state == ATA_S_ONCHIP && ahci_port_intr(ap,
	    1 << ccb->ccb_slot)) {
		DPRINTF(AHCI_D_TIMEOUT, "%s: final poll of port completed "
		    "command in slot %d\n", PORTNAME(ap), ccb->ccb_slot);
		goto ret;
	} else if (ccb->ccb_xa.state != ATA_S_ONCHIP) {
		DPRINTF(AHCI_D_TIMEOUT, "%s: command slot %d already "
		    "handled%s\n", PORTNAME(ap), ccb->ccb_slot,
		    ISSET(*active, 1 << ccb->ccb_slot) ?
		    " but slot is still active?" : ".");
		goto ret;
	} else if (!ISSET(ahci_pread(ap, ncq_cmd ? AHCI_PREG_SACT :
	    AHCI_PREG_CI), 1 << ccb->ccb_slot) && ISSET(*active,
	    1 << ccb->ccb_slot)) {
		DPRINTF(AHCI_D_TIMEOUT, "%s: command slot %d completed but "
		    "IRQ handler didn't detect it.  Why?\n", PORTNAME(ap),
		    ccb->ccb_slot);
		*active &= ~(1 << ccb->ccb_slot);
		ccb->ccb_done(ccb);
		goto ret;
	} else {
		ccb_was_started = 1;
	}

	/* Complete the slot with a timeout error. */
	ccb->ccb_xa.state = ATA_S_TIMEOUT;
	*active &= ~(1 << ccb->ccb_slot);
	DPRINTF(AHCI_D_TIMEOUT, "%s: run completion (1)\n", PORTNAME(ap));
	ccb->ccb_done(ccb);	/* This won't issue pending commands or run the
				   atascsi completion. */

	/* Reset port to abort running command. */
	if (ccb_was_started) {
		DPRINTF(AHCI_D_TIMEOUT, "%s: resetting port to abort%s command "
		    "in slot %d, pmp port %d, active %08x\n", PORTNAME(ap),
		    ncq_cmd ? " NCQ" : "", ccb->ccb_slot, xa->pmp_port, *active);
		if (ahci_port_softreset(ap) != 0 && ahci_port_portreset(ap, 0)
		    != 0) {
			printf("%s: failed to reset port during timeout "
			    "handling, disabling it\n", PORTNAME(ap));
			ap->ap_state = AP_S_FATAL_ERROR;
		}

		/* Restart any other commands that were aborted by the reset. */
		if (*active) {
			DPRINTF(AHCI_D_TIMEOUT, "%s: re-enabling%s slots "
			    "%08x\n", PORTNAME(ap), ncq_cmd ? " NCQ" : "",
			    *active);
			if (ncq_cmd)
				ahci_pwrite(ap, AHCI_PREG_SACT, *active);
			ahci_pwrite(ap, AHCI_PREG_CI, *active);
		}
	}

	/* Issue any pending commands now. */
	DPRINTF(AHCI_D_TIMEOUT, "%s: issue pending\n", PORTNAME(ap));
	if (ccb_was_started)
		ahci_issue_pending_commands(ap, ncq_cmd);
	else if (ap->ap_active == 0)
		ahci_issue_pending_ncq_commands(ap);

	/* Complete the timed out ata_xfer I/O (may generate new I/O). */
	DPRINTF(AHCI_D_TIMEOUT, "%s: run completion (2)\n", PORTNAME(ap));
	ata_complete(xa);

	DPRINTF(AHCI_D_TIMEOUT, "%s: splx\n", PORTNAME(ap));
ret:
	splx(s);
}

void
ahci_empty_done(struct ahci_ccb *ccb)
{
	if (ccb->ccb_xa.state != ATA_S_ERROR)
		ccb->ccb_xa.state = ATA_S_COMPLETE;
}

int
ahci_pmp_read(struct ahci_port *ap, int target, int which, u_int32_t *datap)
{
	struct ahci_ccb	*ccb;
	struct ata_fis_h2d *fis;
	int error;

	ccb = ahci_get_pmp_ccb(ap);
	if (ccb == NULL) {
		printf("%s: NULL ccb!\n", PORTNAME(ap));
		return (1);
	}
	ccb->ccb_xa.flags = ATA_F_POLL | ATA_F_GET_RFIS;
	ccb->ccb_xa.pmp_port = SATA_PMP_CONTROL_PORT;
	ccb->ccb_xa.state = ATA_S_PENDING;
	
	bzero(ccb->ccb_cmd_table, sizeof(struct ahci_cmd_table));
	fis = (struct ata_fis_h2d *)ccb->ccb_cmd_table->cfis;
	fis->type = ATA_FIS_TYPE_H2D;
	fis->flags = ATA_H2D_FLAGS_CMD | SATA_PMP_CONTROL_PORT;
	fis->command = ATA_C_READ_PM;
	fis->features = which;
	fis->device = target | ATA_H2D_DEVICE_LBA;
	fis->control = ATA_FIS_CONTROL_4BIT;

	if (ahci_poll(ccb, 1000, ahci_pmp_probe_timeout) != 0) {
		error = 1;
	} else {
		*datap = ccb->ccb_xa.rfis.sector_count |
		    (ccb->ccb_xa.rfis.lba_low << 8) |
		    (ccb->ccb_xa.rfis.lba_mid << 16) |
		    (ccb->ccb_xa.rfis.lba_high << 24);
		error = 0;
	}
	ahci_put_pmp_ccb(ccb);
	return (error);
}

int
ahci_pmp_write(struct ahci_port *ap, int target, int which, u_int32_t data)
{
	struct ahci_ccb	*ccb;
	struct ata_fis_h2d *fis;
	int error;

	ccb = ahci_get_pmp_ccb(ap);
	if (ccb == NULL) {
		printf("%s: NULL ccb!\n", PORTNAME(ap));
		return (1);
	}
	ccb->ccb_xa.flags = ATA_F_POLL;
	ccb->ccb_xa.pmp_port = SATA_PMP_CONTROL_PORT;
	ccb->ccb_xa.state = ATA_S_PENDING;

	bzero(ccb->ccb_cmd_table, sizeof(struct ahci_cmd_table));
	fis = (struct ata_fis_h2d *)ccb->ccb_cmd_table->cfis;
	fis->type = ATA_FIS_TYPE_H2D;
	fis->flags = ATA_H2D_FLAGS_CMD | SATA_PMP_CONTROL_PORT;
	fis->command = ATA_C_WRITE_PM;
	fis->features = which;
	fis->device = target | ATA_H2D_DEVICE_LBA;
	fis->sector_count = (u_int8_t)data;
	fis->lba_low = (u_int8_t)(data >> 8);
	fis->lba_mid = (u_int8_t)(data >> 16);
	fis->lba_high = (u_int8_t)(data >> 24);
	fis->control = ATA_FIS_CONTROL_4BIT;

	error = ahci_poll(ccb, 1000, ahci_pmp_probe_timeout);
	ahci_put_pmp_ccb(ccb);
	return (error);
}

int
ahci_pmp_phy_status(struct ahci_port *ap, int target, u_int32_t *datap)
{
	int error;

	error = ahci_pmp_read(ap, target, SATA_PMREG_SSTS, datap);
	if (error == 0)
		error = ahci_pmp_write(ap, target, SATA_PMREG_SERR, -1);
	if (error)
		*datap = 0;

	return (error);
}

int
ahci_pmp_identify(struct ahci_port *ap, int *ret_nports)
{
	u_int32_t chipid;
	u_int32_t rev;
	u_int32_t nports;
	u_int32_t features;
	u_int32_t enabled;
	int s;

	s = splbio();

	if (ahci_pmp_read(ap, 15, 0, &chipid) ||
	    ahci_pmp_read(ap, 15, 1, &rev) ||
	    ahci_pmp_read(ap, 15, 2, &nports) ||
	    ahci_pmp_read(ap, 15, SATA_PMREG_FEA, &features) ||
	    ahci_pmp_read(ap, 15, SATA_PMREG_FEAEN, &enabled)) {
		printf("%s: port multiplier identification failed\n",
		    PORTNAME(ap));
		splx(s);
		return (1);
	}
	splx(s);

	nports &= 0x0F;

	/* ignore SEMB port on SiI3726 port multiplier chips */
	if (chipid == 0x37261095) {
		nports--;
	}

	printf("%s: port multiplier found: chip=%08x rev=0x%b nports=%d, "
	    "features: 0x%b, enabled: 0x%b\n", PORTNAME(ap), chipid, rev,
	    SATA_PFMT_PM_REV, nports, features, SATA_PFMT_PM_FEA, enabled,
	    SATA_PFMT_PM_FEA);

	*ret_nports = nports;
	return (0);
}


#ifdef HIBERNATE
void
ahci_hibernate_io_start(struct ahci_port *ap, struct ahci_ccb *ccb)
{
	ccb->ccb_cmd_hdr->prdbc = 0;
	ahci_pwrite(ap, AHCI_PREG_CI, 1 << ccb->ccb_slot);
}

int
ahci_hibernate_io_poll(struct ahci_port *ap, struct ahci_ccb *ccb)
{
	u_int32_t			is, ci_saved;
	int				process_error = 0;

	is = ahci_pread(ap, AHCI_PREG_IS);

	ci_saved = ahci_pread(ap, AHCI_PREG_CI);

	if (is & AHCI_PREG_IS_DHRS) {
		u_int32_t tfd;
		u_int32_t cmd;
		u_int32_t serr;

		tfd = ahci_pread(ap, AHCI_PREG_TFD);
		cmd = ahci_pread(ap, AHCI_PREG_CMD);
		serr = ahci_pread(ap, AHCI_PREG_SERR);
		if ((tfd & AHCI_PREG_TFD_STS_ERR) &&
		    (cmd & AHCI_PREG_CMD_CR) == 0) {
			process_error = 1;
		} else {
			ahci_pwrite(ap, AHCI_PREG_IS, AHCI_PREG_IS_DHRS);
		}
	} else if (is & (AHCI_PREG_IS_TFES | AHCI_PREG_IS_HBFS |
	    AHCI_PREG_IS_IFS | AHCI_PREG_IS_OFS | AHCI_PREG_IS_UFS)) {
		process_error = 1;
	}

	/* Command failed.  See AHCI 1.1 spec 6.2.2.1 and 6.2.2.2. */
	if (process_error) {

		/* Turn off ST to clear CI and SACT. */
		ahci_port_stop(ap, 0);

		/* just return an error indicator?  we can't meaningfully
		 * recover, and on the way back out we'll DVACT_RESUME which
		 * resets and reinits the port.
		 */
		return (EIO);
	}

	/* command is finished when the bit in CI for the slot goes to 0 */
	if (ci_saved & (1 << ccb->ccb_slot)) {
		return (EAGAIN);
	}

	return (0);
}

void
ahci_hibernate_load_prdt(struct ahci_ccb *ccb)
{
	struct ata_xfer			*xa = &ccb->ccb_xa;
	struct ahci_prdt		*prdt = ccb->ccb_cmd_table->prdt, *prd;
	struct ahci_cmd_hdr		*cmd_slot = ccb->ccb_cmd_hdr;
	int				i;
	paddr_t				data_phys;
	u_int64_t			data_bus_phys;
	vaddr_t				data_addr;
	size_t				seglen;
	size_t				buflen;

	if (xa->datalen == 0) {
		ccb->ccb_cmd_hdr->prdtl = 0;
		return;
	}

	/* derived from i386/amd64 _bus_dma_load_buffer;
	 * for amd64 the buffer will always be dma safe.
	 */
	 
	buflen = xa->datalen;
	data_addr = (vaddr_t)xa->data;
	for (i = 0; buflen > 0; i++) {
		prd = &prdt[i];

		pmap_extract(pmap_kernel(), data_addr, &data_phys);
		data_bus_phys = data_phys;

		seglen = PAGE_SIZE - ((u_long)data_addr & PGOFSET);
		if (buflen < seglen)
			seglen = buflen;

		prd->dba_hi = htole32((u_int32_t)(data_bus_phys >> 32));
		prd->dba_lo = htole32((u_int32_t)data_bus_phys);
		prd->flags = htole32(seglen - 1);
		data_addr += seglen;
		buflen -= seglen;
	}

	cmd_slot->prdtl = htole16(i);
}

int
ahci_hibernate_io(dev_t dev, daddr_t blkno, vaddr_t addr, size_t size,
    int op, void *page)
{
	/* we use the 'real' ahci_port and ahci_softc here, but
	 * never write to them
	 */
	struct {
		struct ahci_cmd_hdr cmd_hdr[32]; /* page aligned, 1024 bytes */
		struct ahci_rfis rfis;		 /* 1k aligned, 256 bytes */
		/* cmd table isn't actually used because of mysteries */
		struct ahci_cmd_table cmd_table; /* 256 aligned, 512 bytes */
		struct ahci_port *ap;
		struct ahci_ccb ccb_buf;
		struct ahci_ccb *ccb;
		struct ahci_cmd_hdr *hdr_buf;
		int pmp_port;
	} *my = page;
	struct ata_fis_h2d *fis;
	u_int32_t sector_count;
	struct ahci_cmd_hdr *cmd_slot;
	int rc;
	int timeout;

	if (op == HIB_INIT) {
		struct device *disk;
		struct device *scsibus;
		struct ahci_softc *sc;
		extern struct cfdriver sd_cd;
		struct scsi_link *link;
		struct scsibus_softc *bus_sc;
		int port;
		paddr_t page_phys;
		u_int64_t item_phys;
		u_int32_t cmd;

		/* map dev to an ahci port */
		disk = disk_lookup(&sd_cd, DISKUNIT(dev));
		scsibus = disk->dv_parent;
		sc = (struct ahci_softc *)disk->dv_parent->dv_parent;

		/* find the scsi_link for the device, which has the port */
		port = -1;
		bus_sc = (struct scsibus_softc *)scsibus;
		SLIST_FOREACH(link, &bus_sc->sc_link, bus_list) {
			if (link->device_softc == disk) {
				/* link->adapter_softc == sc->sc_atascsi */
				port = link->target;
				if (link->lun > 0)
					my->pmp_port = link->lun - 1;
				else
					my->pmp_port = 0;

				break;
			}
		}
		if (port == -1) {
			/* don't know where the disk is */
			return (EIO);
		}

		my->ap = sc->sc_ports[port];
		
		/* we're going to use the first command slot,
		 * so ensure it's not already in use
		 */
		if (my->ap->ap_ccbs[0].ccb_xa.state != ATA_S_PUT) {
			/* this shouldn't happen, we should be idle */
			return (EIO);
		}

		/* stop the port so we can relocate to the hibernate page */
		if (ahci_port_stop(my->ap, 1)) {
			return (EIO);
		}
		ahci_pwrite(my->ap, AHCI_PREG_SCTL, 0);

		pmap_extract(pmap_kernel(), (vaddr_t)page, &page_phys);

		/* Setup RFIS base address */
		item_phys = page_phys + ((void *)&my->rfis - page);
		ahci_pwrite(my->ap, AHCI_PREG_FBU,
		    (u_int32_t)(item_phys >> 32));
		ahci_pwrite(my->ap, AHCI_PREG_FB, (u_int32_t)item_phys);

		/* Enable FIS reception and activate port. */
		cmd = ahci_pread(my->ap, AHCI_PREG_CMD) & ~AHCI_PREG_CMD_ICC;
		cmd |= AHCI_PREG_CMD_FRE | AHCI_PREG_CMD_POD |
		    AHCI_PREG_CMD_SUD;
		ahci_pwrite(my->ap, AHCI_PREG_CMD, cmd |
		    AHCI_PREG_CMD_ICC_ACTIVE);

		/* Check whether port activated.  */
		cmd = ahci_pread(my->ap, AHCI_PREG_CMD) & ~AHCI_PREG_CMD_ICC;
		if (!ISSET(cmd, AHCI_PREG_CMD_FRE)) {
			return (EIO);
		}

		/* Set up the single CCB */
		my->ccb = &my->ccb_buf;
		my->ccb->ccb_slot = 0;
		my->ccb->ccb_port = my->ap;

		/* Setup command list base address */
		item_phys = page_phys + ((void *)&my->cmd_hdr - page);
		ahci_pwrite(my->ap, AHCI_PREG_CLBU,
		    (u_int32_t)(item_phys >> 32));
		ahci_pwrite(my->ap, AHCI_PREG_CLB, (u_int32_t)item_phys);

		my->ccb->ccb_cmd_hdr = &my->cmd_hdr[0];

		/* use existing cmd table - don't know why moving to a new one fails */
		my->ccb->ccb_cmd_table = my->ap->ap_ccbs[0].ccb_cmd_table;
		pmap_extract(pmap_kernel(),
		    (vaddr_t)AHCI_DMA_KVA(my->ap->ap_dmamem_cmd_table),
		    &page_phys);
		item_phys = page_phys;
#if 0
		/* use cmd table in hibernate page (doesn't work) */
		my->ccb->ccb_cmd_table = &my->cmd_table;
		item_phys = page_phys + ((void *)&my->cmd_table - page);
#endif
		my->ccb->ccb_cmd_hdr->ctba_hi =
		    htole32((u_int32_t)(item_phys >> 32));
		my->ccb->ccb_cmd_hdr->ctba_lo = htole32((u_int32_t)item_phys);

		my->ccb->ccb_xa.fis =
		    (struct ata_fis_h2d *)my->ccb->ccb_cmd_table->cfis;
		my->ccb->ccb_xa.packetcmd = my->ccb->ccb_cmd_table->acmd;
		my->ccb->ccb_xa.tag = 0;

		/* Wait for ICC change to complete */
		ahci_pwait_clr(my->ap, AHCI_PREG_CMD, AHCI_PREG_CMD_ICC, 1);

		if (ahci_port_start(my->ap, 0)) {
			return (EIO);
		}

		/* Flush interrupts for port */
		ahci_pwrite(my->ap, AHCI_PREG_IS, ahci_pread(my->ap,
		    AHCI_PREG_IS));
		ahci_write(sc, AHCI_REG_IS, 1 << port);

		ahci_enable_interrupts(my->ap);
		return (0);
	} else if (op == HIB_DONE) {
		ahci_pci_activate(&my->ap->ap_sc->sc_dev, DVACT_RESUME);
		return (0);
	}

	/* build fis */
	sector_count = size / 512;	/* dlg promises this is okay */
	my->ccb->ccb_xa.flags = op == HIB_W ? ATA_F_WRITE : ATA_F_READ;
	fis = my->ccb->ccb_xa.fis;
	fis->flags = ATA_H2D_FLAGS_CMD | my->pmp_port;
	fis->lba_low = blkno & 0xff;
	fis->lba_mid = (blkno >> 8) & 0xff;
	fis->lba_high = (blkno >> 16) & 0xff;

	if (sector_count > 0x100 || blkno > 0xfffffff) {
		/* Use LBA48 */
		fis->command = op == HIB_W ? ATA_C_WRITEDMA_EXT :
		    ATA_C_READDMA_EXT;
		fis->device = ATA_H2D_DEVICE_LBA;
		fis->lba_low_exp = (blkno >> 24) & 0xff;
		fis->lba_mid_exp = (blkno >> 32) & 0xff;
		fis->lba_high_exp = (blkno >> 40) & 0xff;
		fis->sector_count = sector_count & 0xff;
		fis->sector_count_exp = (sector_count >> 8) & 0xff;
	} else {
		/* Use LBA */
		fis->command = op == HIB_W ? ATA_C_WRITEDMA : ATA_C_READDMA;
		fis->device = ATA_H2D_DEVICE_LBA | ((blkno >> 24) & 0x0f);
		fis->sector_count = sector_count & 0xff;
	}

	my->ccb->ccb_xa.data = (void *)addr;
	my->ccb->ccb_xa.datalen = size;
	my->ccb->ccb_xa.pmp_port = my->pmp_port;
	my->ccb->ccb_xa.flags |= ATA_F_POLL;

	cmd_slot = my->ccb->ccb_cmd_hdr;
	cmd_slot->flags = htole16(5); /* FIS length (in DWORDs) */
	cmd_slot->flags |=
	    htole16(my->pmp_port << AHCI_CMD_LIST_FLAG_PMP_SHIFT);

	if (op == HIB_W)
		cmd_slot->flags |= htole16(AHCI_CMD_LIST_FLAG_W);

	ahci_hibernate_load_prdt(my->ccb);

	ahci_hibernate_io_start(my->ap, my->ccb);
	timeout = 1000;
	while ((rc = ahci_hibernate_io_poll(my->ap, my->ccb)) == EAGAIN) {
		delay(1000);
		timeout--;
		if (timeout == 0) {
			return (EIO);
		}
	}

	return (0);
}

#endif
@


1.196
log
@Add a hibernate HIB_DONE op.  After the memory-side-effect driver finishes
IO to the disk, DVACT_RESUME the controller back to normal operation.  That
allows us to do the full DVACT_POWERDOWN sequence afterwards.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.195 2013/01/17 00:08:13 claudio Exp $ */
@


1.195
log
@Force the latest 3 generations of Intel SATA chipsets into AHCI mode.
This makes MacBook Pro with bootcamp more happy to run OpenBSD since
by default it boots up with IDE mode enabled on those chips which results
in all sorts of troubles with the at least the DVD drive.
With and OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.194 2012/10/08 21:47:50 deraadt Exp $ */
d4041 3
@


1.194
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.193 2012/08/11 13:52:27 jmatthew Exp $ */
d61 7
d535 16
d791 13
@


1.193
log
@Fix state tracking for the error ccb, and pay attention when the READ_LOG_EXT
command used in ncq error recovery fails.  Fixes 'ccb->ccb_xa.state ==
ATA_S_ONCHIP' assertion failures when talking to dying disks.

broken disk supplied by Aidan Rowe
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.192 2012/07/02 13:24:53 jmatthew Exp $ */
d987 3
@


1.192
log
@Hibernate i/o implementation for ahci(4).  This works with an ATI SBx00
controller, but other brands (jmicron and intel have been tested)
don't like something in the sleep process so they just lock up.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.191 2012/06/29 22:21:40 jmatthew Exp $ */
d3091 1
d3229 2
a3230 1
	if (ahci_poll(ccb, 1000, NULL) != 0)
d3625 2
a3626 1
	ccb->ccb_xa.state = ATA_S_COMPLETE;
@


1.191
log
@fix obvious panic on resume with AHCI_DEBUG enabled

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.190 2012/06/28 10:23:21 sthen Exp $ */
d540 1
d542 11
d3752 1
d3754 101
d3859 195
a4053 1
	return (EIO);
d4055 2
a4056 1
#endif /* HIBERNATE */
@


1.190
log
@Fix issues with AMD chipset ahci(4) attach functions.
from Brad, ok jmatthew mikeb.

- Have the SB700 attach routine properly call the IDE to AHCI
function and migrate the ATI_SBX00_SATA_1 PCI id to using
the SB700 attach routine. The SB600 routine was being used
because it does the proper call. This just makes it so all
of the SB700 controllers use the same attach routine, especially
incase any other workarounds/errata type things come up or
not setting SB600 things for SB700.

- Have the Hudson-2 attach routine set the AHCI_F_IPMS_PROBE
flag to resolve the issue with Port Multiplier support. The
SB700 attachment function was being used because it was
setting the flag. This also fixes the other Hudson-2 AHCI
controllers so they won't experience the same issue.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.189 2012/06/05 03:36:37 jmatthew Exp $ */
d1391 1
a1395 1
	ap = sc->sc_ports[port];
@


1.189
log
@When error recovery fails, just fail the command.  Attempting error
recovery again results in a panic as the ccb used for error recovery is
already in use.

ok dlg@@, tested by benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.188 2012/05/05 10:10:12 sthen Exp $ */
d467 1
a467 1
	    NULL,		ahci_ati_sb700_attach },
d480 1
a480 1
	    NULL,		ahci_ati_sb600_attach },
d736 2
d739 1
d747 2
@


1.188
log
@Sync with renamed and new AMD Hudson-2 entries done in pcidevs r1.1640
From Brad, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.187 2012/04/13 11:33:12 sasano Exp $ */
d382 2
a383 1
#define AP_S_FATAL_ERROR		3
d1619 1
a1619 1
	int				s, rc = EIO;
d1625 2
d1722 1
d2763 2
a2764 1
			if (ap->ap_state == AP_S_PMP_PORT_PROBE) {
d2766 1
a2766 1
				 * the probe fails and the port still works.
d3170 1
a3170 1
	int				rc = EIO;
d3173 2
d3253 1
@


1.187
log
@Fix waiting problem at boot on AMD Hudson's AHCI.

Ok by mikeb@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.186 2012/02/04 21:44:54 krw Exp $ */
d463 1
a463 1
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_HUDSON2_SATA,
d465 1
a465 1
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_HUDSON_AHCI_1,
d467 8
@


1.186
log
@Close races where timer is started on a command and then an splbio()
is called before the command is started. This might have resulted
in the timeout firing and invalidating the command before it is
started. Move the timeout_add_* inside the relevant splbio()/splx().

ok miod@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.185 2011/11/14 00:25:17 mlarkin Exp $ */
d465 2
@


1.185
log
@

Use a fixed io_page for all hibernate I/O, which is needed for
ahci_hibernate_io, a skeleton of which is also provided in this diff.

This code is from deraadt@@. Tested on a few wd machines to ensure it works
there as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.184 2011/10/27 08:03:50 jmatthew Exp $ */
d3443 1
a3444 2

		s = splbio();
@


1.184
log
@Split AHCI port multiplier detection out into a separate function.
As a side effect, we now restore the correct (original) command register
value rather than one read halfway through the reset process, which
gets port multipliers working on some ATI devices.  Also tested on JMicron
and Intel AHCIs.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.183 2011/10/26 10:59:00 jmatthew Exp $ */
d528 7
d3717 9
@


1.183
log
@Convert some ahci port multiplier printfs to DPRINTFs as they're
only useful for debugging.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.182 2011/08/20 20:16:01 kettenis Exp $ */
d609 1
d2034 1
a2034 4
	int				rc, count, pmp_rc, s;
	struct ahci_cmd_hdr		*cmd_slot;
	struct ahci_ccb			*ccb = NULL;
	u_int8_t			*fis = NULL;
d2088 24
a2111 2
	if (pmp == 0 ||
	    (ap->ap_sc->sc_flags & AHCI_F_NO_PMP) ||
d2113 1
a2113 1
		goto err;
d2116 1
d2157 1
a2157 1
			rc = 1;
a2302 5

err:
	/* Restore preserved port state */
	ahci_pwrite(ap, AHCI_PREG_CMD, cmd);
	splx(s);
@


1.182
log
@Don't wait for FR to come on after setting the FRE bit in the port command
register.  The spec doesn't say we have to do this while it mentions several
times one needs to wait for FR to clear after clearing FRE.  The Linux driver
doesn't wait for it either.  This allows us to get rid of the AHCI_F_IGN_FR
quirk.

As a side-effect this diff will probably stop ahci(4) attaching to (some)
NVIDIA fakeRAID devices.  That's good since it is consistent with what we
do for Intel fakeRAID.

ok mikeb@@, jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.181 2011/07/04 22:06:07 jmatthew Exp $ */
d1724 1
a1724 1
	printf("%s: now ignoring IFS\n", PORTNAME(ap));
d1815 1
a1815 1
	printf("%s: no longer ignoring IFS\n", PORTNAME(ap));
d1828 2
a1829 1
	printf("%s.%d: probing pmp port\n", PORTNAME(ap), pmp_port);
d1845 2
a1846 2
	printf("%s.%d: port signature returned %d\n", PORTNAME(ap), pmp_port,
	    sig);
d2013 2
a2014 1
	printf("%s.%d: device detected\n", PORTNAME(ap), pmp_port);
@


1.181
log
@Intel AHCIs don't support port multipliers so far, yet some (mostly ICH9 and 3400
series) report that they do, and some BIOSes for those chipsets don't clear
the capability bit like they're supposed to.  Since we know it doesn't work,
don't check for port multipliers on these controllers.  Replaces my earlier hack
for a specific 3400 series device.

ok kettenis@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.180 2011/06/14 10:40:14 jmatthew Exp $ */
d419 2
a420 3
#define AHCI_F_IGN_FR			(1<<1)
#define AHCI_F_IPMS_PROBE		(1<<2)	/* IPMS on failed PMP probe */
#define AHCI_F_NO_PMP			(1<<3)	/* ignore PMP capability */
a460 2
int			ahci_nvidia_mcp_attach(struct ahci_softc *,
			    struct pci_attach_args *);
a517 21
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_MCP65_AHCI_2,
	    NULL,		ahci_nvidia_mcp_attach },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_MCP67_AHCI_1,
	    NULL,		ahci_nvidia_mcp_attach },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_MCP73_AHCI_5,
	    NULL,		ahci_nvidia_mcp_attach },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_MCP73_AHCI_9,
	    NULL,		ahci_nvidia_mcp_attach },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_MCP77_AHCI_5,
	    NULL,		ahci_nvidia_mcp_attach },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_MCP77_AHCI_6,
	    NULL,		ahci_nvidia_mcp_attach },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_MCP79_AHCI_1,
	    NULL,		ahci_nvidia_mcp_attach },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_MCP79_AHCI_2,
	    NULL,		ahci_nvidia_mcp_attach },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_MCP79_AHCI_3,
	    NULL,		ahci_nvidia_mcp_attach },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_MCP79_AHCI_4,
	    NULL,		ahci_nvidia_mcp_attach },

d709 1
a709 1
	sc->sc_flags |= AHCI_F_IGN_FR | AHCI_F_IPMS_PROBE;
a736 8
ahci_nvidia_mcp_attach(struct ahci_softc *sc, struct pci_attach_args *pa)
{
	sc->sc_flags |= AHCI_F_IGN_FR;
	
	return (0);
}

int
a1520 6

	if (!(ap->ap_sc->sc_flags & AHCI_F_IGN_FR)) {
		/* Wait for FR to come on */
		if (ahci_pwait_set(ap, AHCI_PREG_CMD, AHCI_PREG_CMD_FR, 1))
			return (2);
	}
@


1.180
log
@Intel 3400 AHCI responds to PMP probes like ATI SBx00 chips.
Unknown whether this also applies to product id 3b23 as well as 3b22.

Problem reported by John Danks in PR6630

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.179 2011/06/02 16:50:05 krw Exp $ */
d421 1
d460 1
a460 1
int			ahci_intel_3400_1_attach(struct ahci_softc *,
d484 26
d511 9
a519 1
	    NULL,		ahci_intel_3400_1_attach },
d754 1
a754 1
ahci_intel_3400_1_attach(struct ahci_softc *sc, struct pci_attach_args *pa)
d756 1
a756 1
	sc->sc_flags |= AHCI_F_IPMS_PROBE;
d2127 1
@


1.179
log
@Attempt msi interrupt mapping, with fall back to old-style mapping. Works
on my non-msi capable ahci and several msi capable setups. Dark
suspicions that some will NOT work so put it in to smoke any such
systems into the open.

ok deraadt@@ mk@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.178 2011/05/08 19:46:10 matthew Exp $ */
d459 2
d483 3
d715 7
@


1.178
log
@Move ata_put_xfer() from ata_xfer to atascsi_methods.  It's just silly
to have a non-changing function pointer be part of an object rather
than it's virtual method table.

ok dlg@@; tested on ahci(4) by Mattieu Baptiste, jasper@@, and Jason
Crawford; no sili(4) testers, but identical changes to ahci(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.177 2011/04/24 11:09:48 dlg Exp $ */
d765 1
a765 1
	if (pci_intr_map(pa, &ih) != 0) {
@


1.177
log
@get the error ccbs state right for a put when a port is empty. should get
rid of noise during boot.

reported by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.176 2011/04/21 07:13:01 dlg Exp $ */
d625 1
a1230 2

		ccb->ccb_xa.ata_put_xfer = ahci_ata_put_xfer;
@


1.176
log
@steal the ccb for error handling before it might be needed during the
port init.

problem reported by RD Thrush in PR6590
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.175 2011/04/21 02:37:31 dlg Exp $ */
d1240 1
@


1.175
log
@ahci asks atascsi to reserve a ccb to use for error handling, but then
atascsi goes and throws away all the ccbs that the disk wont use, including
the reserved one.

this makes ahci reserve its own ccb.

light testing by krw@@ without regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.174 2011/04/07 15:30:16 miod Exp $ */
d1237 4
a1297 4

	/* grab a ccb for use during error recovery */
	ap->ap_ccb_err = &ap->ap_ccbs[sc->sc_ncmds - 1];
	TAILQ_REMOVE(&ap->ap_ccb_free, ap->ap_ccb_err, ccb_entry);
@


1.174
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.173 2011/04/03 17:04:19 krw Exp $ */
d376 1
d867 1
a867 2
	aaa.aaa_ncmds = sc->sc_ncmds;
	aaa.aaa_capability = ASAA_CAP_NEEDS_RESERVED;
d1295 4
d1320 3
d3022 1
a3022 2
	err_ccb = ahci_get_ccb(ap);
	KASSERT(err_ccb != NULL);
d3026 1
a3026 1
	return err_ccb;
d3046 1
d3048 2
a3049 1
	ahci_put_ccb(ccb);
@


1.173
log
@Another driver made safer for big mem by dma_alloc/dma_free'ing
memory used for i/o.

ok dlg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.172 2011/01/28 06:32:31 dlg Exp $ */
d2478 1
a2478 1
	if (ap->ap_sactive != NULL &&
@


1.172
log
@we deal with polled ccbs erroring out properly, we dont have to complain
about it unless we want verbose debug shizz.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.171 2011/01/28 06:30:04 dlg Exp $ */
d30 1
d395 1
a395 1
	u_int8_t		ap_err_scratch[512];
d1098 6
d1328 2
@


1.171
log
@ahci0: timed out 1, active 0, count 0 during pmp probe timeouts should be
quiet unless we want verbose output.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.170 2011/01/26 21:41:00 drahn Exp $ */
d2363 2
a2364 2
			printf("%s: ccb in slot %d errored\n", PORTNAME(ap),
			    ccb->ccb_slot);
@


1.170
log
@Add port multiplier support, has been in snaps for a while with no reported
issues. No actual OKs, but general acknowledgement and 'get it in' from several.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.169 2010/08/31 17:13:44 deraadt Exp $ */
d1884 2
a1885 2
		printf("%s: timed out %d, active %x, count %d\n", PORTNAME(ap),
		    ccb->ccb_slot, ap->ap_active, ap->ap_active_cnt);
@


1.169
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.168 2010/07/03 00:23:36 kettenis Exp $ */
d5 2
d38 1
d259 10
d279 1
d369 1
d378 7
a384 1
#define AP_S_FATAL_ERROR		1
d418 1
d453 2
d468 10
d536 1
d547 5
a551 1
int			ahci_port_portreset(struct ahci_port *);
d571 4
a574 1
int			ahci_port_read_ncq_error(struct ahci_port *, int *);
d589 12
d613 2
a614 2
int			ahci_ata_probe(void *, int);
void			ahci_ata_free(void *, int);
d628 1
d690 4
a693 1
	sc->sc_flags |= AHCI_F_IGN_FR;
d695 4
d868 12
a879 2
	    (sc->sc_cap & AHCI_REG_CAP_SNCQ))
		aaa.aaa_capability |= ASAA_CAP_NCQ;
d1064 16
d1102 1
d1142 5
d1234 2
a1235 1
	rc = ahci_port_portreset(ap);
d1271 3
a1273 2
	DPRINTF(AHCI_D_VERBOSE, "%s: detected device on port %d\n",
	    DEVNAME(sc), port);
d1286 1
a1286 11
	/* Enable port interrupts */
	ahci_pwrite(ap, AHCI_PREG_IE, AHCI_PREG_IE_TFEE | AHCI_PREG_IE_HBFE |
	    AHCI_PREG_IE_IFE | AHCI_PREG_IE_OFE | AHCI_PREG_IE_DPE |
	    AHCI_PREG_IE_UFE |
#ifdef AHCI_COALESCE
	    ((sc->sc_ccc_ports & (1 << port)) ? 0 : (AHCI_PREG_IE_SDBE |
	    AHCI_PREG_IE_DHRE))
#else
	    AHCI_PREG_IE_SDBE | AHCI_PREG_IE_DHRE
#endif
	    );
d1391 1
a1391 1
	rc = ahci_port_portreset(ap);
d1430 21
d1462 1
a1462 11
	/* Enable port interrupts */
	ahci_pwrite(ap, AHCI_PREG_IE, AHCI_PREG_IE_TFEE | AHCI_PREG_IE_HBFE |
	    AHCI_PREG_IE_IFE | AHCI_PREG_IE_OFE | AHCI_PREG_IE_DPE |
	    AHCI_PREG_IE_UFE |
#ifdef AHCI_COALESCE
	    ((sc->sc_ccc_ports & (1 << port)) ? 0 : (AHCI_PREG_IE_SDBE |
	    AHCI_PREG_IE_DHRE))
#else
	    AHCI_PREG_IE_SDBE | AHCI_PREG_IE_DHRE
#endif
	    );
d1473 2
d1535 2
d1600 4
d1627 2
a1628 2
	fis[0] = 0x27;	/* Host to device */
	fis[15] = 0x04;	/* SRST DEVCTL */
d1641 1
a1641 1
	fis[0] = 0x27;	/* Host to device */
d1682 319
d2003 1
a2003 1
ahci_port_portreset(struct ahci_port *ap)
d2006 4
a2009 1
	int				rc;
d2011 1
d2040 25
d2068 183
a2250 2
	/* Clear SERR (incl X bit), so TFD can update */
	ahci_pwrite(ap, AHCI_PREG_SERR, ahci_pread(ap, AHCI_PREG_SERR));
d2252 1
a2252 5
	/* Wait for device to become ready */
	if (ahci_pwait_clr(ap, AHCI_PREG_TFD, AHCI_PREG_TFD_STS_BSY |
	    AHCI_PREG_TFD_STS_DRQ | AHCI_PREG_TFD_STS_ERR, 3)) {
		rc = EBUSY;
		goto err;
a2254 1
	rc = 0;
d2258 1
d2362 10
d2406 5
d2414 3
a2416 1
		if (ap->ap_active != 0 || !TAILQ_EMPTY(&ap->ap_ccb_pending))
d2418 5
a2422 1
		else {
d2428 1
d2436 4
d2460 15
a2474 1
	/* Start all the NCQ commands at the head of the pending list. */
d2480 2
a2481 1
	} while (nextccb && (nextccb->ccb_xa.flags & ATA_F_NCQ));
a2485 2

	return;
d2495 7
a2501 2
		KASSERT(last_was_ncq == 0);	/* otherwise it should have
						 * been started already. */
d2504 3
a2506 2
		 * standard commands. */
		ap->ap_active_cnt--;
d2525 1
d2590 1
d2619 24
d2644 1
a2644 1
	if (is & AHCI_PREG_IS_TFES) {
d2697 25
a2721 3
			printf("%s: attempting to idle device\n", PORTNAME(ap));
			if (ahci_port_softreset(ap)) {
				printf("%s: failed to soft reset device\n",
d2723 9
a2731 5
				if (ahci_port_portreset(ap)) {
					printf("%s: failed to port reset "
					    "device, give up on it\n",
					    PORTNAME(ap));
					goto fatal;
d2737 8
a2744 2
			/* Recover the NCQ error from log page 10h. */
			ahci_port_read_ncq_error(ap, &err_slot);
d2762 1
a2762 1
			    ahci_port_portreset(ap) != 0) {
d2792 29
d2887 8
d2921 5
d3044 52
d3097 1
a3097 1
ahci_port_read_ncq_error(struct ahci_port *ap, int *err_slotp)
d3124 1
a3124 1
	fis->flags = ATA_H2D_FLAGS_CMD;
d3134 1
d3303 1
a3303 1
ahci_ata_probe(void *xsc, int port)
a3306 1
	u_int32_t			sig;
d3311 9
a3319 5
	sig = ahci_pread(ap, AHCI_PREG_SIG);
	if ((sig & 0xffff0000) == (SATA_SIGNATURE_ATAPI & 0xffff0000))
		return (ATA_PORT_T_ATAPI);
	else
		return (ATA_PORT_T_DISK);
d3323 1
a3323 1
ahci_ata_free(void *xsc, int port)
d3372 2
d3408 13
d3498 3
a3500 3
		    "in slot %d, active %08x\n", PORTNAME(ap), ncq_cmd ? " NCQ"
		    : "", ccb->ccb_slot, *active);
		if (ahci_port_softreset(ap) != 0 && ahci_port_portreset(ap)
d3538 126
@


1.168
log
@Turns out the

/* XXX maybe more than the default wait is appropriate here? */

in ahci_port_portreset() is true, at least when we come out of suspend.
Allow a timeout of 3s here while keeping all the other delays at 1s.

ok dlg@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.167 2010/07/02 05:20:17 jsg Exp $ */
d858 3
a885 1

@


1.167
log
@add more MCP79 AHCI ids to the list of devices that need special handling,
lets ahci work on jcr's Alienware M17x.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.166 2010/06/29 18:57:53 kettenis Exp $ */
d546 1
a546 1
			    u_int32_t, u_int32_t);
d549 2
a550 1
#define ahci_pwait_clr(_ap, _r, _b) ahci_pwait_eq((_ap), (_r), (_b), 0)
d553 4
a556 1
#define ahci_pwait_set(_ap, _r, _b) ahci_pwait_eq((_ap), (_r), (_b), (_b))
d1135 1
a1135 1
	ahci_pwait_clr(ap, AHCI_PREG_CMD, AHCI_PREG_CMD_ICC);
d1300 1
a1300 1
	ahci_pwait_clr(ap, AHCI_PREG_CMD, AHCI_PREG_CMD_ICC);
d1392 1
a1392 1
		if (ahci_pwait_set(ap, AHCI_PREG_CMD, AHCI_PREG_CMD_FR))
d1397 2
a1398 1
	if (!fre_only && ahci_pwait_set(ap, AHCI_PREG_CMD, AHCI_PREG_CMD_CR))
d1426 1
a1426 1
	if (ahci_pwait_clr(ap, AHCI_PREG_CMD, AHCI_PREG_CMD_CR))
d1430 2
a1431 1
	if (stop_fis_rx && ahci_pwait_clr(ap, AHCI_PREG_CMD, AHCI_PREG_CMD_FR))
d1457 1
a1457 1
	if (ahci_pwait_clr(ap, AHCI_PREG_CMD, AHCI_PREG_CMD_CLO)) {
d1506 1
a1506 1
	    AHCI_PREG_TFD_STS_BSY | AHCI_PREG_TFD_STS_DRQ)) {
d1546 1
a1546 1
	    AHCI_PREG_TFD_STS_DRQ | AHCI_PREG_TFD_STS_ERR)) {
d1608 1
a1608 1
	    AHCI_PREG_SSTS_DET_DEV)) {
a1614 1
	delay(1000000);
a1616 1
	/* XXX maybe more than the default wait is appropriate here? */
d1618 1
a1618 1
	    AHCI_PREG_TFD_STS_DRQ | AHCI_PREG_TFD_STS_ERR)) {
d2459 1
a2459 1
    u_int32_t target)
d2463 1
a2463 1
	for (i = 0; i < 1000; i++) {
@


1.166
log
@Add code to make ahci(4) suspend/resume properly.  Probably not perfect yet,
but it seems to work reliably on several laptops.

ok dlg@@ (a while ago), tested by mlarkin@@ and marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.165 2010/05/24 04:40:14 dlg Exp $ */
d458 6
@


1.165
log
@atascsi may (will) reuse ata_xfers, meaning the xa state that
ahci_ata_cmd is called with might be the state of the xfer that
ahci set previously.  this stops ahci_ata_cmd from checking the
state of ata_xfers its given, and instead trusts that atascsi is
doing the right thing.

reported and fix tested by matthew dempsky, who also did an awesome
job of tracing the problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.164 2010/05/19 15:27:35 oga Exp $ */
d404 2
d468 1
d474 2
a475 1
	ahci_pci_detach
d500 1
d677 1
a677 1
	u_int32_t			cap, pi;
d715 2
a716 2
	cap = ahci_read(sc, AHCI_REG_CAP);
	sc->sc_ncmds = AHCI_REG_CAP_NCS(cap);
d721 1
a721 1
		switch (cap & AHCI_REG_CAP_ISS) {
d734 2
a735 2
		    DEVNAME(sc), cap, AHCI_FMT_CAP,
		    AHCI_REG_CAP_NP(cap), sc->sc_ncmds, gen);
d745 1
a745 1
	if (cap & AHCI_REG_CAP_CCCS) {
d795 2
a796 1
	if (!(sc->sc_flags & AHCI_F_NO_NCQ) && (cap & AHCI_REG_CAP_SNCQ))
d842 36
d1231 129
d1603 1
@


1.164
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.163 2010/04/16 22:15:39 kettenis Exp $ */
a1566 2
	KASSERT(ccb->ccb_xa.state == ATA_S_PENDING);

a2348 2

	KASSERT(xa->state == ATA_S_SETUP);
@


1.163
log
@Remove Intel RAID IDs for now.  They can be added back when code has been
written to detect the Intel RAID metadata format such that we no longer risk
overwriting it.  If this makes you lose your disks, you'll need to change the
controller type from RAID to AHCI in the BIOS to get them back.

ok marco@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.162 2010/04/08 00:23:53 tedu Exp $ */
d2195 1
a2195 1
	    1, &nsegs, BUS_DMA_NOWAIT) != 0)
a2204 2

	bzero(adm->adm_kva, size);
@


1.162
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.161 2010/04/06 13:59:37 dlg Exp $ */
a441 9

	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801GR_RAID,
	    NULL,		NULL },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801H_RAID,
	    NULL,		NULL },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801HBM_RAID,
	    NULL,		NULL },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801JI_RAID,
	    NULL,		NULL },
@


1.161
log
@add Intel 82801GR RAID.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.160 2010/03/15 19:54:54 drahn Exp $ */
d25 1
a25 1
#include <sys/proc.h>
@


1.160
log
@Add support for 82801HBM RAID.  'that diff can go in' kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.159 2010/03/15 11:05:43 krw Exp $ */
d443 2
@


1.159
log
@Add id for Intel 82801JI RAID. Lets HP GL360 G6 see internal SATA
drives.

Reported on misc@@ by 'a b <rclocal () yahoo ! co ! uk', who also
tested the diff from Brad.

ok kettenis@@ for 4.7.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.158 2010/01/21 10:16:44 sthen Exp $ */
d444 2
@


1.158
log
@Use ahci_nvidia_mcp_attach() for nvidia MCP79 ("Ion"), without which
the driver fails to detect disks.  From Wouter Coene, ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.157 2010/01/10 13:19:02 grange Exp $ */
d444 2
@


1.157
log
@ATI AHCI seems not to put slot number into the command register
on error as the spec requires. This triggers kernel assertion
error because zero is read from the register and wrong ccb is picked
from the queue. To cope with it if there's only one outstanding
command get its slot number from the active commands mask, otherwise
fail all active commands.

ok krw@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.156 2009/12/28 01:36:12 krw Exp $ */
d457 2
@


1.156
log
@Add MCP73_AHCI_5 to list of devices started in that special NVidia
way. Fixes ahci on my Acer Aspire AX1800-E9102.

Clue from jsg@@, ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.155 2009/12/08 08:41:59 dlg Exp $ */
d1773 14
@


1.155
log
@claim Intel 82801H RAID by pci id. it might be in RAID mode, not ahci.

makes the disks in a dell 960 work. there's probably a lot of other ids
that should be added here too
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.153 2009/11/01 01:50:15 dlg Exp $ */
d449 2
@


1.154
log
@get rid of the return codes from command submission, ata_cmd handlers
now return void. all state about a command is now represented within
the ata_xfer structure, and all layers using it (both hba and
atascsi) now check only ata_xfer.

this relies on my scsi midlayer changes. it was written just before
the second last backout of the midlayer.
@
text
@d443 3
@


1.153
log
@add support for the ati sb900^Whudson2 chips.

from brad
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.152 2009/10/24 14:31:49 dlg Exp $ */
d544 1
a544 1
int			ahci_ata_cmd(struct ata_xfer *);
d2329 1
a2329 1
int
d2359 1
a2359 1
	if (xa->flags & ATA_F_POLL) {
d2361 6
a2366 1
		return (ATA_COMPLETE);
d2369 1
a2369 6
	timeout_add_msec(&xa->stimeout, xa->timeout);

	s = splbio();
	ahci_start(ccb);
	splx(s);
	return (ATA_QUEUED);
d2374 1
a2374 1
	xa->complete(xa);
a2375 1
	return (ATA_ERROR);
d2400 1
a2400 1
		xa->complete(xa);
d2485 1
a2485 1
	xa->complete(xa);
@


1.152
log
@recognise ahci 1.3 devices, maybe they'll Just Work(tm).
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.151 2009/10/17 21:44:00 jsg Exp $ */
d425 2
d429 2
d435 3
d588 2
a589 2
int
ahci_ati_sb600_attach(struct ahci_softc *sc, struct pci_attach_args *pa)
d609 6
d617 8
@


1.151
log
@Another MCP77 controller that while matched already by class,
needs to be told to use the nvidia specific quirks to
detect attached devices.

From and tested by minusf@@obiit.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.150 2009/10/13 00:19:38 sthen Exp $ */
d99 1
d898 3
@


1.150
log
@sort the device list. from Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.149 2009/10/05 11:49:26 deraadt Exp $ */
d442 2
@


1.149
log
@nvidia MCP73 on acer aspire m1640; proger@@uaoug.org.ua
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.148 2009/09/13 13:26:39 matthieu Exp $ */
a429 2
	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT8251_SATA,
	    ahci_no_match,	ahci_vt8251_attach },
d434 1
d439 2
d443 3
a445 2
	{ PCI_VENDOR_NVIDIA,    PCI_PRODUCT_NVIDIA_MCP73_AHCI_9,
	    NULL,		ahci_nvidia_mcp_attach }
@


1.148
log
@ATI SB700 can be handled in ahci mode like SB600. suggested by
and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.147 2009/02/16 21:19:07 miod Exp $ */
d441 2
@


1.147
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.146 2009/01/21 21:54:00 grange Exp $ */
d433 2
@


1.146
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.145 2008/12/13 11:49:54 mikeb Exp $ */
d752 1
a752 1
	aaa.aaa_minphys = minphys;
@


1.145
log
@;5Anvidia mcp67 ahci controller also needs special handling.

from Marko Pecic.  thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.144 2008/12/07 22:37:05 mikeb Exp $ */
d2331 1
a2331 1
	timeout_add(&xa->stimeout, (xa->timeout * hz) / 1000);
@


1.144
log
@yet another one nvidia ahci controller that needs special handling.

from form@@.

ok dlg, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.143 2008/11/22 17:31:38 mikeb Exp $ */
d435 2
@


1.143
log
@Some nVidia MCP77 AHCI controllers need special handling.  There's 12
PCI ID's for MCP77 in our database, but to stay on a safe side, this
change affects device 0x0ad4 only.  Other ones could be added later.

Problem reported and fixed tested by gilles@@ on Acer Aspire X3200.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.142 2008/09/17 06:18:45 brad Exp $ */
d426 1
a426 1
int			ahci_nvidia_mcp77_attach(struct ahci_softc *,
d434 2
d437 1
a437 1
	    NULL,		ahci_nvidia_mcp77_attach }
d598 1
a598 1
ahci_nvidia_mcp77_attach(struct ahci_softc *sc, struct pci_attach_args *pa)
@


1.142
log
@ATI IXPx00 -> SBx00
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.141 2008/09/17 06:14:09 brad Exp $ */
d426 2
d433 3
a435 1
	    NULL,		ahci_ati_sb600_attach }
d592 8
@


1.141
log
@Update for renamed ATI PCI ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.140 2008/05/31 23:50:32 dlg Exp $ */
d53 2
a54 2
#define AHCI_PCI_ATI_IXP600_MAGIC	0x40
#define AHCI_PCI_ATI_IXP600_LOCKED	0x01
d424 1
a424 1
int			ahci_ati_ixp600_attach(struct ahci_softc *,
d431 1
a431 1
	    NULL,		ahci_ati_ixp600_attach }
d565 1
a565 1
ahci_ati_ixp600_attach(struct ahci_softc *sc, struct pci_attach_args *pa)
d571 1
a571 1
		    AHCI_PCI_ATI_IXP600_MAGIC);
d573 2
a574 2
		    AHCI_PCI_ATI_IXP600_MAGIC,
		    magic | AHCI_PCI_ATI_IXP600_LOCKED);
d583 1
a583 1
		    AHCI_PCI_ATI_IXP600_MAGIC, magic);
@


1.140
log
@if a dma mapping contains oddly addressed or odd length segments, then we
reject that mapping. this diff cleans up the mapping if it fails those
diagnostics.

found while looking into an issue for krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.139 2008/04/19 01:18:39 djm Exp $ */
d430 1
a430 1
	{ PCI_VENDOR_ATI,	PCI_PRODUCT_ATI_IXP_SATA_600,
@


1.139
log
@add a driver flag to force the negotiation of SATA 1 transfers
(1.5Gb/s). Useful where faster speeds are unstable; ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.138 2008/04/08 19:30:09 kettenis Exp $ */
d1430 1
a1430 1
			return (1);
d1435 1
a1435 1
			return (1);
d1450 6
@


1.138
log
@pci_chipset_tag_t already_t is_t a_t pointer_t
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.137 2008/04/08 12:20:31 jsg Exp $ */
d1357 6
a1362 2
	r = AHCI_PREG_SCTL_IPM_DISABLED | AHCI_PREG_SCTL_SPD_ANY |
	    AHCI_PREG_SCTL_DET_INIT;
@


1.137
log
@Make ahci detachable.  Not tested as the ppb on my shitty nvidia
board doesn't seem to properly propagate expresscard interrupts.

Incoporating suggestions from dlg and kettenis, ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.136 2007/11/28 16:01:34 dlg Exp $ */
d386 1
a386 1
	pci_chipset_tag_t	*sc_pc;
@


1.136
log
@the ccb lists protect themselves, so we dont have to check if we're at
splbio when getting and putting ata xfers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.135 2007/11/28 13:47:09 dlg Exp $ */
d386 1
d437 1
d440 4
a443 1
	sizeof(struct ahci_softc), ahci_pci_match, ahci_pci_attach
d447 4
a450 1
	sizeof(struct ahci_softc), ahci_pci_match, ahci_pci_attach
d460 1
a460 2
void			ahci_unmap_regs(struct ahci_softc *,
			    struct pci_attach_args *);
d463 1
a463 4
#ifdef notyet
void			ahci_unmap_intr(struct ahci_softc *,
			    struct pci_attach_args *);
#endif
d625 2
d751 1
a751 1
	for (i = 0; i < AHCI_MAX_PORTS; i++)
d754 1
d758 1
a758 1
	ahci_unmap_regs(sc, pa);
d763 23
d801 1
a801 1
ahci_unmap_regs(struct ahci_softc *sc, struct pci_attach_args *pa)
d811 1
a811 1
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO,
a820 2
#ifdef notyet
/* one day we'll have hotplug pci */
d822 1
a822 1
ahci_unmap_intr(struct ahci_softc *sc, struct pci_attach_args *pa)
d824 1
a824 1
	pci_intr_disestablish(pa->pa_pc, sc->sc_ih);
a825 1
#endif
d1634 1
a1634 1
	if (is == 0)
@


1.135
log
@make ata controllers protect their own command lists so atascsi doesnt have
to continually go to splbio to ensure its safe to work on them. shrinks
code a little.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.134 2007/11/26 15:59:53 dlg Exp $ */
a2219 2
	splassert(IPL_BIO);

a2236 2

	splassert(IPL_BIO);
@


1.134
log
@drive port probes from the scsi midlayer now that it will ask the adapter
if a device is there before doing any scsi commands. also implement a free
path for when devices are detached. software hotplug has been tested on
sili, and ahci is still working according to claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.133 2007/11/19 01:18:48 pascoe Exp $ */
d27 1
d358 1
d895 1
d1879 1
d1886 1
d1907 1
d1909 1
@


1.133
log
@When ignoring whether FR turns on or not, we should still set FRE,
otherwise we risk leaving the port disabled after a stop/start during
error recovery.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.132 2007/11/05 07:06:02 dlg Exp $ */
d511 1
d518 1
d2198 6
@


1.132
log
@recognise (and use) ahci 1.2 controllers.

diff from Henrik Gustafsson
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.131 2007/11/04 01:38:54 dlg Exp $ */
d392 1
a392 1
#define AHCI_F_NO_FER			(1<<1)
d578 1
a578 1
	sc->sc_flags |= AHCI_F_NO_FER;
d1110 1
a1110 2
	if (!(ap->ap_sc->sc_flags & AHCI_F_NO_FER))
		r |= AHCI_PREG_CMD_FRE;
d1124 1
a1124 1
	if (!(ap->ap_sc->sc_flags & AHCI_F_NO_FER)) {
@


1.131
log
@when the ati ahci stuff is in the ide compat mode, it can sometimes cause
a wdc(4) controller to appear. this code disables the compat mode using
some magic niklas gleaned from the linux driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.130 2007/10/27 10:51:21 dlg Exp $ */
d97 1
d839 3
@


1.130
log
@work around a chip bug on the ati ixp600 ahci controller. diff mostly from
niklas@@ and tested on hardware generously provided by paul de weird.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.129 2007/10/01 15:34:48 krw Exp $ */
d558 19
@


1.129
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...' where
obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.128 2007/07/03 22:33:20 dlg Exp $ */
d52 2
d391 1
d420 2
d425 3
a427 1
	    ahci_no_match,	ahci_vt8251_attach }
d556 8
d1087 2
a1088 1
	r |= AHCI_PREG_CMD_FRE;
d1102 5
a1106 3
	/* Wait for FR to come on */
	if (ahci_pwait_set(ap, AHCI_PREG_CMD, AHCI_PREG_CMD_FR))
		return (2);
@


1.128
log
@join ahci attach code back together into one function.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.127 2007/07/03 22:28:14 dlg Exp $ */
d827 1
a827 1
	ap = malloc(sizeof(struct ahci_port), M_DEVBUF, M_NOWAIT);
a832 1
	bzero(ap, sizeof(struct ahci_port));
d901 1
a901 1
	    M_NOWAIT);
a906 1
	bzero(ap->ap_ccbs, sizeof(struct ahci_ccb) * sc->sc_ncmds);
d2031 1
a2031 1
	adm = malloc(sizeof(struct ahci_dmamem), M_DEVBUF, M_NOWAIT);
a2034 1
	bzero(adm, sizeof(struct ahci_dmamem));
@


1.127
log
@jmb pretends to be pci now, so i dont need to let it see ahci_softc so it
can provide its own attach glue to ahci.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.126 2007/07/02 14:01:13 dlg Exp $ */
a439 2
int			ahci_attach(struct ahci_softc *,
			    struct pci_attach_args *, pci_intr_handle_t);
d576 1
d579 2
a595 11
	ahci_attach(sc, pa, ih);
}

int
ahci_attach(struct ahci_softc *sc, struct pci_attach_args *pa,
    pci_intr_handle_t ih)
{
	struct atascsi_attach_args	aaa;
	u_int32_t			cap, pi;
	int				i;

d598 1
a598 1
		return (1);
d703 1
a703 1
	return (0);
d713 1
a713 1
	return (1);
@


1.126
log
@kettenis suggested that i can use pci_intr_map twice on the same device
safely, so i tried it and it worked great. i can reuse the pci_attach_args
to attach ahci and now pciide to jmb without really modifying either of
them. lots of code shrinks.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.124 2007/07/02 00:52:25 dlg Exp $ */
a35 2
#include <dev/pci/ahcivar.h>

a50 2
#define DEVNAME(_s)		((_s)->sc_dev.dv_xname)

d314 3
d377 27
d439 3
@


1.125
log
@dont attach on jmicron parts now that jmb(4) does that for us.
@
text
@d405 4
@


1.124
log
@move ahci_softc and the prototype for ahci_attach into a header so other
code will be able to see it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.123 2007/07/02 00:46:22 dlg Exp $ */
a388 3
int			ahci_jmicron_match(struct pci_attach_args *);
int			ahci_jmicron_attach(struct ahci_softc *,
			    struct pci_attach_args *);
a392 10
	{ PCI_VENDOR_JMICRON,	PCI_PRODUCT_JMICRON_JMB360,
	    ahci_jmicron_match, ahci_jmicron_attach },
	{ PCI_VENDOR_JMICRON,	PCI_PRODUCT_JMICRON_JMB361,
	    ahci_jmicron_match, ahci_jmicron_attach },
	{ PCI_VENDOR_JMICRON,	PCI_PRODUCT_JMICRON_JMB363,
	    ahci_jmicron_match, ahci_jmicron_attach },
	{ PCI_VENDOR_JMICRON,	PCI_PRODUCT_JMICRON_JMB365,
	    ahci_jmicron_match, ahci_jmicron_attach },
	{ PCI_VENDOR_JMICRON,	PCI_PRODUCT_JMICRON_JMB366,
	    ahci_jmicron_match, ahci_jmicron_attach },
a505 93
	return (0);
}

/* JMicron registers */
#define JM_PCI_CTL0		0x40 /* control register 0 */
#define  JM_PCI_CTL0_ROM_EN		(1<<31)	/* External Option ROM */
#define  JM_PCI_CTL0_IDWR_EN		(1<<30) /* Device ID Write */
#define  JM_PCI_CTL0_MSI64_EN		(1<<25) /* 64bit MSI Addr Mode */
#define  JM_PCI_CTL0_MSI_EN		(1<<24) /* MSI Addr Mode */
#define  JM_PCI_CTL0_IDEDMA_CFG		(1<<23) /* PCIIDE DMA Chan Cfg */
#define  JM_PCI_CTL0_PCIIDE_CS		(1<<22) /* PCIIDE channels Swap */
#define  JM_PCI_CTL0_SATA_PS		(1<<21) /* SATA channel M/S swap */
#define  JM_PCI_CTL0_AHCI_PS		(1<<20) /* SATA AHCI ports swap */
#define  JM_PCI_CTL0_F1_SUBCLASS_M	0xc0000 /* subclass for func 1 */
#define  JM_PCI_CTL0_F0_SUBCLASS_M	0x30000 /* subclass for func 0 */
#define  JM_PCI_CTL0_SUBCLASS_IDE	0x0 /* IDE Controller */
#define  JM_PCI_CTL0_SUBCLASS_RAID	0x1 /* RAID Controller */
#define  JM_PCI_CTL0_SUBCLASS_AHCI	0x2 /* AHCI Controller */
#define  JM_PCI_CTL0_SUBCLASS_OTHER	0x3 /* Other Mass Storage */
#define  JM_PCI_CTL0_F1_SUBCLASS(_m)	((_m)<<18) /* subclass for func 1 */
#define  JM_PCI_CTL0_F0_SUBCLASS(_m)	((_m)<<16) /* subclass for func 0 */
#define  JM_PCI_CTL0_SATA1_AHCI		(1<<15) /* SATA port 1 AHCI enable */
#define  JM_PCI_CTL0_SATA1_IDE		(1<<14) /* SATA port 1 IDE enable */
#define  JM_PCI_CTL0_SATA0_AHCI		(1<<13) /* SATA port 0 AHCI enable */
#define  JM_PCI_CTL0_SATA0_IDE		(1<<12) /* SATA port 0 PCIIDE enable */
#define  JM_PCI_CTL0_AHCI_F1		(1<<9) /* AHCI on function 1 */
#define  JM_PCI_CTL0_AHCI_EN		(1<<8) /* ACHI enable */
#define  JM_PCI_CTL0_PATA0_RST		(1<<6) /* PATA port 0 reset */
#define  JM_PCI_CTL0_PATA0_EN		(1<<5) /* PATA port 0 enable */
#define  JM_PCI_CTL0_PATA0_SEC		(1<<4) /* PATA 0 enable on 2nd chan */
#define  JM_PCI_CTL0_PATA0_40P		(1<<3) /* PATA 0 40pin cable */
#define  JM_PCI_CTL0_PCIIDE_F1		(1<<1) /* PCIIDE on function 1 */
#define  JM_PCI_CTL0_PATA0_PRI		(1<<0) /* PATA 0 enable on 1st chan */

#define JM_PCI_CTL5		0x80 /* control register 8 */
#define  JM_PCI_CTL5_PATA1_PRI		(1<<24) /* force PATA 1 on chan0 */

int
ahci_jmicron_match(struct pci_attach_args *pa)
{
	/*
	 * we're only ever going to configure function 0 as the ahci port,
	 * so only match on it
	 */
	if (pa->pa_function != 0)
		return (0);

	return (1);
}

int
ahci_jmicron_attach(struct ahci_softc *sc, struct pci_attach_args *pa)
{
	u_int32_t			ctl0, ctl5;

	ctl0 = pci_conf_read(pa->pa_pc, pa->pa_tag, JM_PCI_CTL0);
	ctl0 &= ~(JM_PCI_CTL0_PCIIDE_F1 | JM_PCI_CTL0_AHCI_EN | 
	    JM_PCI_CTL0_AHCI_F1 | JM_PCI_CTL0_SATA0_IDE |
	    JM_PCI_CTL0_SATA0_AHCI | JM_PCI_CTL0_SATA1_IDE |
	    JM_PCI_CTL0_SATA1_AHCI | JM_PCI_CTL0_F1_SUBCLASS_M |
	    JM_PCI_CTL0_F0_SUBCLASS_M | JM_PCI_CTL0_PCIIDE_CS |
	    JM_PCI_CTL0_IDEDMA_CFG);

	ctl5 = pci_conf_read(pa->pa_pc, pa->pa_tag, JM_PCI_CTL5);
	ctl5 &= ~JM_PCI_CTL5_PATA1_PRI;

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_JMICRON_JMB360:
		/* set to single function AHCI mode */
		ctl0 |= JM_PCI_CTL0_AHCI_EN | JM_PCI_CTL0_SATA0_AHCI |
		    JM_PCI_CTL0_SATA1_AHCI |
		    JM_PCI_CTL0_F0_SUBCLASS(JM_PCI_CTL0_SUBCLASS_AHCI);
		break;

	case PCI_PRODUCT_JMICRON_JMB366:
	case PCI_PRODUCT_JMICRON_JMB365:
		/* wire the second PATA port in the right place */
		ctl5 |= JM_PCI_CTL5_PATA1_PRI;
		/* FALLTHROUGH */
	case PCI_PRODUCT_JMICRON_JMB363:
	case PCI_PRODUCT_JMICRON_JMB361:
		/* enable AHCI and put IDE on the second function */
		ctl0 |= JM_PCI_CTL0_PCIIDE_F1 | JM_PCI_CTL0_AHCI_EN |
		    JM_PCI_CTL0_SATA0_AHCI | JM_PCI_CTL0_SATA1_AHCI |
		    JM_PCI_CTL0_F0_SUBCLASS(JM_PCI_CTL0_SUBCLASS_AHCI) |
		    JM_PCI_CTL0_F1_SUBCLASS(JM_PCI_CTL0_SUBCLASS_IDE) |
		    JM_PCI_CTL0_PCIIDE_CS | JM_PCI_CTL0_IDEDMA_CFG;
                break;
	}

	pci_conf_write(pa->pa_pc, pa->pa_tag, JM_PCI_CTL0, ctl0);
	pci_conf_write(pa->pa_pc, pa->pa_tag, JM_PCI_CTL5, ctl5);

@


1.123
log
@pull ahci_attach apart slightly to accommodate attaching ahci(4) to things
other than pci(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.122 2007/06/29 01:27:10 dlg Exp $ */
d36 2
d53 2
a317 3
struct ahci_softc;
struct ahci_port;

a377 26
struct ahci_softc {
	struct device		sc_dev;

	void			*sc_ih;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_size_t		sc_ios;
	bus_dma_tag_t		sc_dmat;

	int			sc_flags;
#define AHCI_F_NO_NCQ			(1<<0)

	u_int			sc_ncmds;
	struct ahci_port	*sc_ports[AHCI_MAX_PORTS];

	struct atascsi		*sc_atascsi;

#ifdef AHCI_COALESCE
	u_int32_t		sc_ccc_mask;
	u_int32_t		sc_ccc_ports;
	u_int32_t		sc_ccc_ports_cur;
#endif
};
#define DEVNAME(_s)	((_s)->sc_dev.dv_xname)

a420 3

int			ahci_attach(struct ahci_softc *,
			    struct pci_attach_args *, pci_intr_handle_t);
@


1.122
log
@when we attach to the jmicron controllers, whack their configuration around
a bit. this guarantees that the controller has its ahci stuff enabled for
us to use (which was previously done with magic numbers). this also configs
the controller to enable a second function for pciide to attach to.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.121 2007/06/29 01:06:17 dlg Exp $ */
d435 3
a437 2
int			ahci_match(struct device *, void *, void *);
void			ahci_attach(struct device *, struct device *, void *);
d439 2
a440 2
struct cfattach ahci_ca = {
	sizeof(struct ahci_softc), ahci_match, ahci_attach
d447 3
d455 1
a455 1
			    struct pci_attach_args *);
d652 1
a652 1
ahci_match(struct device *parent, void *match, void *aux)
d675 1
a675 1
ahci_attach(struct device *parent, struct device *self, void *aux)
d680 1
a680 3
	struct atascsi_attach_args	aaa;
	u_int32_t			cap, pi;
	int				i;
d690 17
d709 1
a709 1
		return;
d717 1
a717 1
	if (ahci_map_intr(sc, pa) != 0) {
d809 1
a809 1
	sc->sc_atascsi = atascsi_attach(self, &aaa);
d814 1
a814 1
	return;
a822 1

d824 1
d835 1
a835 1
		printf(": unable to map registers\n");
d850 2
a851 1
ahci_map_intr(struct ahci_softc *sc, struct pci_attach_args *pa)
a852 8
	pci_intr_handle_t		ih;
	const char			*intrstr;

	if (pci_intr_map(pa, &ih) != 0) {
		printf(": unable to map interrupt\n");
		return (1);
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
d856 1
a856 3
		printf(": unable to map interrupt%s%s\n",
		    intrstr == NULL ? "" : " at ",
		    intrstr == NULL ? "" : intrstr);
a858 1
	printf(": %s", intrstr);
d892 1
a892 1
			printf(": unable to reset controller\n");
d918 1
a918 1
		printf(": unsupported AHCI revision 0x%08x\n", reg);
d922 1
a922 1
	printf(": AHCI %s", revision);
@


1.121
log
@demystify a little more of the jmicron pci control registers
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.120 2007/06/29 01:00:38 dlg Exp $ */
d556 8
a563 2
/* 19:18 Sub-Class Code Configuration for Function 1 */
/* 17:16 Sub-Class Code Configuration for Function 0 */
d583 4
d596 1
a596 1
	u_int32_t			ccr;
d598 37
a634 5
	/* Switch JMICRON ports to AHCI mode */
	ccr = pci_conf_read(pa->pa_pc, pa->pa_tag, 0x40);
	ccr &= ~0x0000ff00;
	ccr |=  0x0000a100;
	pci_conf_write(pa->pa_pc, pa->pa_tag, 0x40, ccr);
@


1.120
log
@define away some of the magic on jmicron controllers
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.119 2007/06/12 12:09:15 grange Exp $ */
d570 3
@


1.119
log
@Use SATA_SIGNATURE_ATAPI constant instead of a magic number.
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.118 2007/05/30 03:55:19 tedu Exp $ */
d545 25
@


1.118
log
@my (dlg says crappy) laptop requires some more delays in port_reset or
things go really crazy.
ok/help toby tom.  dlg unhappy but ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.117 2007/05/10 02:16:11 dlg Exp $ */
d2187 1
a2187 1
	if ((sig & 0xffff0000) == 0xeb140000)
@


1.117
log
@remove and hide code that isn't used.

found by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.115 2007/04/22 05:03:04 dlg Exp $ */
d1318 1
d1322 1
a1322 1
	delay(2000);	/* wait at least 1ms for COMRESET to be sent */
d1326 1
a1326 1
	delay(2000);
@


1.116
log
@mark the ccb used for error handling as complete when it completes. this
prevents dmesg spam when we return this ccb to the free list.
@
text
@d452 1
d455 1
a492 2
int			ahci_wait_eq(struct ahci_softc *, bus_size_t,
			    u_int32_t, u_int32_t);
a499 2
int			ahci_pwait_ne(struct ahci_port *, bus_size_t,
			    u_int32_t, u_int32_t);
d784 2
d791 1
a2129 15
ahci_wait_eq(struct ahci_softc *sc, bus_size_t r, u_int32_t mask,
    u_int32_t target)
{
	int				i;

	for (i = 0; i < 1000; i++) {
		if ((ahci_read(sc, r) & mask) == target)
			return (0);
		delay(1000);
	}

	return (1);
}

int
a2167 15
			return (0);
		delay(1000);
	}

	return (1);
}

int
ahci_pwait_ne(struct ahci_port *ap, bus_size_t r, u_int32_t mask,
    u_int32_t target)
{
	int				i;

	for (i = 0; i < 1000; i++) {
		if ((ahci_pread(ap, r) & mask) != target)
@


1.115
log
@unload the dmamap of the ccb used in ncq error handling once we've finished
with it. prevents free panics on sparc64.

found by deraadt on a v215.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.114 2007/04/22 03:49:31 deraadt Exp $ */
d2422 1
a2422 1
	/* do nothing */
@


1.114
log
@prettier debug, if it is ever re-enabled, ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.113 2007/04/21 23:59:33 dlg Exp $ */
d2024 1
@


1.113
log
@disable ahci debug output. ahci is working on the majority of chipsets,
and its not helping us on those that arent.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.112 2007/04/08 09:13:31 pascoe Exp $ */
d657 1
a657 1
		printf("%s: capabilities: 0x%b ports: %d ncmds: %d gen: %s\n",
@


1.112
log
@Whitespace/long line fixups.  No code change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.111 2007/04/08 09:05:48 pascoe Exp $ */
d36 2
a37 1
#define AHCI_DEBUG
@


1.111
log
@Add compile-time support for coalescing command interrupts to reduce the
overall interrupt rate.

#define AHCI_COALESCE to enable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.110 2007/04/06 04:04:29 pascoe Exp $ */
d39 2
a40 1
#define DPRINTF(m, f...) do { if ((ahcidebug & (m)) == (m)) printf(f); } while (0)
d479 1
a479 1
struct ahci_ccb 	*ahci_get_err_ccb(struct ahci_port *);
a513 1

d682 1
a682 1
			    "conflict, PI: %08x, ccc_mask: %08x\n", 
d1138 2
a1139 1
		ahci_write(ap->ap_sc, AHCI_REG_CCC_PORTS, ap->ap_sc->sc_ccc_ports_cur);
d1425 2
a1426 1
			xa->resid = xa->datalen - letoh32(ccb->ccb_cmd_hdr->prdbc);
a1583 1

d2038 1
a2038 1
			*err_slotp = err_slot = log->err_regs.type & 
d2381 2
a2382 2
		    "in slot %d, active %08x\n", PORTNAME(ap), ncq_cmd ? " NCQ" :
		    "", ccb->ccb_slot, *active);
@


1.110
log
@Wait until we have idled the port before obtaining the error CCB, so as
to avoid tripping a KASSERT in the case when there is more than one
outstanding command.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.109 2007/04/02 05:14:52 pascoe Exp $ */
d94 1
d335 4
d395 2
d665 36
d879 3
d1048 8
a1055 1
	    AHCI_PREG_IE_UFE | AHCI_PREG_IE_SDBE | AHCI_PREG_IE_DHRE);
d1109 9
d1134 8
d1602 1
@


1.109
log
@Read log page 10h to determine the NCQ error, instead of aborting all
active commands when an error is encountered.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.108 2007/03/31 10:14:53 jasper Exp $ */
d1122 1
a1122 1
	struct ahci_ccb			*ccb;
a1130 1
	ccb = ahci_get_err_ccb(ap);
d1168 1
@


1.108
log
@re-blacklist the via vt8251, there's still something fishy..

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.107 2007/03/31 07:42:23 dlg Exp $ */
d360 2
d474 2
d1639 6
d1646 1
a1646 1
			/* XXX recover NCQ error here */
d1662 1
a1662 1
			printf("%s: couldn't recover from NCQ error, failing "
d1891 90
@


1.107
log
@reenable the via 8251 sata chipset. jasper proved it can work if we dont
do ncq, so this diff quirks it.

tested by jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.106 2007/03/30 06:59:46 dlg Exp $ */
d421 1
a421 1
	    NULL,		ahci_vt8251_attach }
@


1.106
log
@the VT8251 SATA says it is ahci, but we aren't ready for it. we need to
quirk a few things before it will work.

this blacklists that controller in ahci so pciide will be able to match it
instead.

found by jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.105 2007/03/29 07:40:10 pascoe Exp $ */
d378 3
d396 2
a397 1
	int			(*ad_attach)(struct pci_attach_args *);
d404 4
a407 1
int			ahci_jmicron_attach(struct pci_attach_args *);
d421 1
a421 1
	    ahci_no_match,	NULL }
d546 1
a546 1
ahci_jmicron_attach(struct pci_attach_args *pa)
d560 8
d602 1
a602 1
		if (ad->ad_attach(pa) != 0) {
d671 1
a671 1
	if (cap & AHCI_REG_CAP_SNCQ)
@


1.105
log
@Avoid leaking a ccb in error paths.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.104 2007/03/29 02:35:41 pascoe Exp $ */
d398 1
d412 3
a414 1
	    ahci_jmicron_match, ahci_jmicron_attach }
d521 6
@


1.104
log
@Correct some minor whitespace issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.103 2007/03/28 06:40:19 pascoe Exp $ */
d1845 3
@


1.103
log
@While we are determining which NCQ command failed, we will need to ensure
that we don't accidentally complete any other outstanding commands.

This introduces wrappers around get_ccb and put_ccb that can temporarily
stash our outstanding command state while we are issuing recovery commands.

This is just the first step in NCQ recovery - for now we will reset the port
on error which will permit further commands to be issued after a NCQ error.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.99 2007/03/27 07:31:15 dlg Exp $ */
d934 1
a934 1
			DPRINTF(AHCI_D_VERBOSE, "%s: no device detected"
d973 2
a974 2
	     AHCI_PREG_IE_IFE | AHCI_PREG_IE_OFE | AHCI_PREG_IE_DPE |
	     AHCI_PREG_IE_UFE | AHCI_PREG_IE_SDBE | AHCI_PREG_IE_DHRE);
d1811 1
a1811 1
	/* 
d1818 1
a1818 1
	 * Grab a CCB to use for error recovery.  This should never fail, as 
@


1.102
log
@Due to a logic inversion, we would error out any commands that had completed
successfully and not the ones that had actually failed to complete when unable
to recover from an NCQ error.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.101 2007/03/28 06:24:22 pascoe Exp $ */
d352 8
d459 3
d1103 1
a1103 5
	ccb = ahci_get_ccb(ap);
	splx(s);
	if (ccb == NULL)
		goto err;
	ccb->ccb_done = ahci_empty_done;
a1187 1
		s = splbio();
d1189 1
a1189 2
		ahci_put_ccb(ccb);
		splx(s);
d1195 2
d1617 4
a1620 1
		/* If we couldn't determine the errored slot, fail all. */
d1622 6
d1786 68
@


1.101
log
@Improve output of some debugging messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.100 2007/03/28 06:19:48 pascoe Exp $ */
d1657 1
a1657 1
		ci_masked = ~ci_saved & *active;
d1665 2
a1666 2
		/* Run completion for all slots. */
		ci_saved = 0;
@


1.100
log
@Some more safety checks on ccb state.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.99 2007/03/27 07:31:15 dlg Exp $ */
a1680 2
		DPRINTF(AHCI_D_INTR, "%s: slot %d is complete\n", PORTNAME(ap),
		    slot);
d1684 4
d2102 2
a2103 2
			printf("%s: failed to reset port during error "
			    "recovery, disabling it\n", PORTNAME(ap));
@


1.99
log
@attach ahci based on the pci class and interface fields, not just on a
list of pci devices.

WARNING: this will cause your disks to change name (wd -> sd) on a
supported controller.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.97 2007/03/23 05:28:34 pascoe Exp $ */
d1743 1
d1974 2
@


1.98
log
@Turn AHCI_DEBUG back on for now, so we can see if any commands are timing
out or erroring around the cache flush time.
@
text
@d50 1
d539 7
a545 2
	if (ad == NULL)
		return (0);
d547 4
a550 3
	/* the device may need special checks to see if it matches */
	if (ad->ad_match != NULL)
		return (ad->ad_match(pa));
d552 1
a552 1
	return (2); /* match higher than pciide */
d566 1
a566 4
	if (ad == NULL)
		panic("ahci attach cant find a device it matched on");

	if (ad->ad_attach != NULL) {
@


1.97
log
@Track the ATA xfer's state more closely - may help us identify why some
are seeing a panic at halt time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.96 2007/03/22 05:15:39 pascoe Exp $ */
d36 1
a36 1
#define NO_AHCI_DEBUG
@


1.96
log
@Let atascsi issue NCQ commands if the controller supports it.

This includes a nasty hack to reduce openings and throw away command slots
if the device supports a lower queue depth than the host controller does.
Yes, we're thinking about a better solution.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.95 2007/03/21 13:08:44 pascoe Exp $ */
d898 1
d1178 1
d1750 10
@


1.95
log
@NCQ commands generate a "Set Device Bits" FIS upon completion.  Enable the
generation of interrupts when they arrive.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.94 2007/03/21 12:41:28 pascoe Exp $ */
d555 1
a555 1
	u_int32_t			reg;
d588 2
a589 2
	reg = ahci_read(sc, AHCI_REG_CAP);
	sc->sc_ncmds = AHCI_REG_CAP_NCS(reg);
d594 1
a594 1
		switch (reg & AHCI_REG_CAP_ISS) {
d607 2
a608 2
		    DEVNAME(sc), reg, AHCI_FMT_CAP,
		    AHCI_REG_CAP_NP(reg), sc->sc_ncmds, gen);
d612 1
a612 1
	reg = ahci_read(sc, AHCI_REG_PI);
d614 1
a614 1
	    DEVNAME(sc), reg);
d616 1
a616 1
		if (!ISSET(reg, 1 << i)) {
d630 4
a633 1
	aaa.aaa_ncmds = sc->sc_ncmds - 1; /* Reserve a slot for soft resets. */
@


1.94
log
@Add support for issuing NCQ commands via AHCI.

Because you cannot have NCQ commands active at the same time as standard
(non-queued) commands, we must introduce a queueing scheme into the driver.

This scheme ensures that a standard command is only issued to the drive when
all currently active NCQ commands have finished, and that NCQ command issue
is delayed when we have a pending standard command.

Additionally, the queueing scheme adds a constraint to ensure that there are
never more than two standard commands issued on a port at once.  This should
ensure that commands become active in the order they were submitted (regardless
of their command slot number) both initially and when the port is reactivated
after error recovery.

These points mean that issuing a standard command effectively serialises the
port, which may help us implement meaningful I/O barriers in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.93 2007/03/21 12:08:58 dlg Exp $ */
d955 1
a955 1
	     AHCI_PREG_IE_UFE | AHCI_PREG_IE_DHRE);
@


1.93
log
@dont print if there is a device found or not, you can figure that out by
seeing things attach to the scsibus.

ok pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.92 2007/03/21 00:09:16 dlg Exp $ */
d69 1
a69 1
#define  AHCI_REG_CAP_SALP		(1<<26) /* Aggresive Link Pwr Mgmt */
d242 1
a242 1
#define AHCI_PREG_ACT		0x34 /* SATA Active */
d340 2
d343 1
d345 1
d441 3
d790 2
a865 1
	TAILQ_INIT(&ap->ap_ccb_free);
d1307 4
a1310 1
		xa->resid = xa->datalen - letoh32(ccb->ccb_cmd_hdr->prdbc);
a1313 1

d1323 2
a1324 1
		if (ahci_port_intr(ap, 1 << ccb->ccb_slot)) {
d1335 1
a1335 1
	
d1347 2
d1364 102
a1465 3
	ccb->ccb_xa.state = ATA_S_ONCHIP;
	ap->ap_active |= 1 << ccb->ccb_slot;
	ahci_pwrite(ap, AHCI_PREG_CI, 1 << ccb->ccb_slot);
d1468 1
d1513 4
d1528 11
a1538 2
	/* Save CI */
	ci_saved = ahci_pread(ap, AHCI_PREG_CI);
d1540 1
a1540 1
	/* Command failed.  See AHCI 1.1 spec 6.2.2.1. */
d1548 11
a1558 7
		err_slot = AHCI_PREG_CMD_CCS(ahci_pread(ap,
		    AHCI_PREG_CMD));
		ccb = &ap->ap_ccbs[err_slot];

		/* Preserve received taskfile data from the RFIS. */
		memcpy(&ccb->ccb_xa.rfis, ap->ap_rfis->rfis,
		    sizeof(struct ata_fis_d2h));
d1593 4
d1601 7
d1614 12
d1642 1
d1648 1
a1648 1
		ci_masked = ~ci_saved & ap->ap_active;
a1663 1

d1669 1
a1669 1
	ci_masked = ~ci_saved & ap->ap_active & ci_mask;
d1691 1
a1691 1
		ap->ap_active &= ~(1 << ccb->ccb_slot);
d1703 11
d1715 2
a1716 2
			    "re-enabling slots %08x\n", PORTNAME(ap),
			    ci_saved);
d1718 2
a1721 1
		
d2003 4
d2011 6
d2027 2
a2028 1
	int				s;
d2032 3
d2038 2
d2047 2
a2048 2
		    "handled%s\n", PORTNAME(ap), ccb->ccb_slot, 
		    ISSET(ap->ap_active, 1 << ccb->ccb_slot) ? 
d2051 3
a2053 2
	} else if (!ISSET(ahci_pread(ap, AHCI_PREG_CI), 1 << ccb->ccb_slot) &&
	    ISSET(ap->ap_active, 1 << ccb->ccb_slot)) {
d2057 1
a2057 1
		ap->ap_active &= ~(1 << ccb->ccb_slot);
d2060 2
d2064 1
a2064 1
	/* Complete the slot with timeout flag set. */
d2066 1
a2066 1
	ap->ap_active &= ~(1 << ccb->ccb_slot);
d2068 14
a2081 1
	ccb->ccb_done(ccb);
d2083 9
a2091 7
	/* Reset port. */
	DPRINTF(AHCI_D_TIMEOUT, "%s: resetting port to abort command in slot %d, "
	    "active %08x\n", PORTNAME(ap), ccb->ccb_slot, ap->ap_active);
	if (ahci_port_softreset(ap) != 0 && ahci_port_portreset(ap) != 0) {
		printf("%s: failed to reset port during error recovery, "
		    "disabling it\n", PORTNAME(ap));
		ap->ap_state = AP_S_FATAL_ERROR;
d2094 6
a2099 6
	/* Restart any outstanding commands that were stopped by the reset. */
	if (ap->ap_active) {
		DPRINTF(AHCI_D_TIMEOUT, "%s: re-enabling slots %08x\n",
		    PORTNAME(ap), ap->ap_active);
		ahci_pwrite(ap, AHCI_PREG_CI, ap->ap_active);
	}
@


1.92
log
@replace the array of u_int8_ts for the fis/registers with a struct to make
it a bit easier to read. there are variations on this, but they can be
defined later.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.91 2007/03/21 00:07:29 pascoe Exp $ */
d36 1
a36 1
#define AHCI_DEBUG
a896 1
		printf("%s: ", DEVNAME(sc));
d899 2
a900 1
			printf("device not communicating");
d903 2
a904 1
			printf("PHY offline");
d907 3
a909 1
			printf("no device detected");
a910 1
		printf(" on port %d, disabling.\n", port);
d914 3
a916 3
		printf("%s: device on port %d didn't come ready, TFD: 0x%b\n",
		    DEVNAME(sc), port, ahci_pread(ap, AHCI_PREG_TFD),
		    AHCI_PFMT_TFD_STS);
d921 2
a922 2
			printf("%s: unable to communicate with device on port "
			    "%d, disabling\n", DEVNAME(sc), port);
d930 2
a931 1
	printf("%s: detected device on port %d\n", DEVNAME(sc), port);
@


1.91
log
@For now, reserve one opening so we always have a CCB free to issue a soft
reset with during error recovery.  Also, ensure that that CCB has been
stopped on the chip before putting it back in the pool.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.90 2007/03/20 13:18:16 pascoe Exp $ */
d880 4
a883 3
		ccb->ccb_xa.cmd.tx = (struct ata_regs *)ccb->ccb_cmd_table->cfis;
		ccb->ccb_xa.cmd.packetcmd = ccb->ccb_cmd_table->acmd;
		ccb->ccb_xa.cmd.tag = i;
d1424 2
a1425 2
		memcpy(&ccb->ccb_xa.cmd.rx_err.regs, ap->ap_rfis->rfis,
		    sizeof(struct ata_regs));
a1790 1
	ccb->ccb_cmd_table->cfis[0] = REGS_TYPE_REG_H2D;
@


1.90
log
@Use ALLOCNOW flag when creating PRDT dmamap, otherwise it could fail during
error handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.89 2007/03/20 13:00:42 pascoe Exp $ */
d623 1
a623 1
	aaa.aaa_ncmds = sc->sc_ncmds;
a1131 4
	cmd_slot = ccb->ccb_cmd_hdr;
	bzero(ccb->ccb_cmd_table, sizeof(struct ahci_cmd_table));

	fis = ccb->ccb_cmd_table->cfis;
d1133 1
d1148 1
d1155 6
@


1.89
log
@Our timeout and error handlers complete the commands for us, so we should
always return ATA_COMPLETE in the polled transfer case.  Also, respect the
passed in timeout value when polling.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.88 2007/03/20 12:46:26 dlg Exp $ */
d864 2
a865 1
		    (4 * 1024 * 1024), 0, 0, &ccb->ccb_dmamap) != 0) {
d1237 1
a1237 2
	error = bus_dmamap_load(sc->sc_dmat, dmap,
	    xa->data, xa->datalen, NULL,
@


1.88
log
@commit the rest of the jmicron ids. jsg has been trying to get me to add
these since last year, but i didnt see the point till the code would be
useful anywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.87 2007/03/20 12:01:18 pascoe Exp $ */
d1805 1
a1805 2
		if (ahci_poll(ccb, 1000, ahci_ata_cmd_timeout) != 0)
			return (ATA_ERROR);
@


1.87
log
@Add support for ATA PACKET commands.  This should make ATAPI cdrom drives,
etc, just work.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.86 2007/03/20 11:22:40 pascoe Exp $ */
d389 2
d392 6
@


1.86
log
@Catch failed commands and copy the error taskfile back to the ata_cmd,
so that atascsi can deal with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.85 2007/03/20 08:47:46 pascoe Exp $ */
d872 2
d1785 3
@


1.85
log
@Add timeout handling for ATA commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.84 2007/03/20 07:38:45 pascoe Exp $ */
d244 1
d343 4
d430 1
a430 1
int			ahci_port_intr(struct ahci_port *, u_int32_t);
d1364 2
a1365 1
			ahci_port_intr(sc->sc_ports[port], 0xffffffff);
d1375 1
a1375 1
int
d1379 2
a1380 2
	u_int32_t			is, ci, cmd, tfd;
	int				slot, processed = 0;
d1386 1
a1386 1
	if (ci_mask == 0xffffffff)
d1393 65
a1457 1
	/* Check for fatal errors, shut down if any. */
d1462 20
a1481 6
		if (is & AHCI_PREG_IS_TFES) {
			cmd = ahci_pread(ap, AHCI_PREG_CMD);
			tfd = ahci_pread(ap, AHCI_PREG_TFD);
			DPRINTF(AHCI_D_INTR, "%s: current slot %d, TFD: %b\n",
			    PORTNAME(ap), AHCI_PREG_CMD_CCS(cmd), tfd,
			    AHCI_PFMT_TFD_STS);
a1482 1
		ahci_port_stop(ap, 0);
d1484 6
a1489 4
		/*
		 * XXX reissue commands individually and/or notify callbacks
		 *     about the failure.
		 */
d1492 1
d1498 3
a1500 3
	ci = ~ahci_pread(ap, AHCI_PREG_CI) & ap->ap_active & ci_mask;
	while (ci) {
		slot = ffs(ci) - 1;
d1504 1
a1504 1
		ci &= ~(1 << slot);
d1526 15
d1772 3
d1871 3
a1873 2
		DPRINTF(AHCI_D_TIMEOUT, "%s: failed to reset port\n",
		    PORTNAME(ap));
@


1.84
log
@Spec says we can't write anything other than the global host control register
before we enable AHCI, so enable it before resetting saved capabilities.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.83 2007/03/20 07:36:21 pascoe Exp $ */
d39 2
a40 1
#define DPRINTF(m, f...) do { if (ahcidebug & (m)) printf(f); } while (0)
d421 1
a421 1
int			ahci_poll(struct ahci_ccb *, int);
d469 1
d1111 2
a1112 1
	if (ahci_poll(ccb, 1000) != 0)
d1126 2
a1127 1
	if (ahci_poll(ccb, 1000) != 0)
d1282 1
a1282 1
ahci_poll(struct ahci_ccb *ccb, int timeout)
d1297 5
a1303 2
	/* XXX cleanup! */

d1328 1
d1683 2
d1688 1
a1688 1
		if (ahci_poll(ccb, 1000) != 0)
d1693 2
d1713 2
d1717 63
a1779 1
	xa->state = ATA_S_COMPLETE;
d1781 4
@


1.83
log
@Minor style fixup.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.82 2007/03/20 07:09:42 pascoe Exp $ */
d705 3
a710 3

	/* enable ahci (global interrupts disabled) */
	ahci_write(sc, AHCI_REG_GHC, AHCI_REG_GHC_AE);
@


1.82
log
@Request "descriptor processed" interrupts only for PIO requests (inquiry,
etc), and request that the D2H FIS at the completion of all (DMA) commands
generate an interrupt.

This makes each data transfer generate one interrupt instead of two and
should guarantee that the interrupt that is generated actually arrives
after the command has completed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.81 2007/03/20 06:43:06 pascoe Exp $ */
d1617 1
a1617 1
		return ATA_PORT_T_ATAPI;
d1619 1
a1619 1
		return ATA_PORT_T_DISK;
@


1.81
log
@Calculate the residual and copy it back to the scsi_xfer, so that RW actually
works.

From dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.80 2007/03/20 05:46:50 pascoe Exp $ */
d43 1
a43 1
int ahcidebug = AHCI_D_VERBOSE | AHCI_D_INTR;
d925 1
a925 1
	     AHCI_PREG_IE_UFE);
d1245 2
a1246 1
	prd->flags |= htole32(AHCI_PRDT_FLAG_INTR);
@


1.80
log
@Split PRDT unload out into its own function, for symmetry.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.79 2007/03/20 05:33:02 pascoe Exp $ */
d1270 2
@


1.79
log
@Instead of having a copy of every register that we will issue in the ata_cmd,
simply include a pointer to the command FIS that we will issue to the device.

Include another space where we can copy back an error register set from a
failed command.

This means that we can now build and issue arbitrary commands from atascsi,
and retrieve errors back.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.78 2007/03/20 04:38:11 pascoe Exp $ */
d418 2
d1256 18
a1695 2
	struct ahci_port		*ap = ccb->ccb_port;
	struct ahci_softc		*sc = ap->ap_sc;
a1696 1
	bus_dmamap_t			dmap = ccb->ccb_dmamap;
d1698 1
a1698 7
	if (xa->datalen != 0) {
		bus_dmamap_sync(sc->sc_dmat, dmap, 0, dmap->dm_mapsize,
		    (xa->flags & ATA_F_READ) ? BUS_DMASYNC_POSTREAD :
		    BUS_DMASYNC_POSTWRITE);

		bus_dmamap_unload(sc->sc_dmat, dmap);
	}
@


1.78
log
@Change API for struct ata_xfer allocation to move it into the device that
atascsi will be driving, and add it to the AHCI CCB.

This effectively gives us all the resources we need for a transfer in one
hit, meaning that we don't need to worry about whether we will have a pool
shortage or not enough CCBs.  The SCSI mid layer should take care to never
exceed the number of CCBs we have available, based on our sc_link.openings.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.77 2007/03/07 03:25:24 pascoe Exp $ */
d862 2
a1637 1
	u_int8_t			*fis;
d1641 2
d1644 1
a1644 1
	bzero(ccb->ccb_cmd_table, sizeof(struct ahci_cmd_table));
d1646 2
a1647 21
	fis = ccb->ccb_cmd_table->cfis;
	fis[0] = 0x27;
	fis[1] = 0x80;
	fis[2] = xa->cmd.command;
	fis[3] = xa->cmd.features;
	fis[4] = xa->cmd.sector;
	fis[5] = (xa->cmd.cyl & 0xff);
	fis[6] = (xa->cmd.cyl >> 8) & 0xff;
	fis[7] = xa->cmd.head & 0x0f;
	fis[8] = 0;
	fis[9] = 0;
	fis[10] = 0;
	fis[11] = 0;
	fis[12] = xa->cmd.count;
	fis[13] = 0;
	fis[14] = 0;
	fis[15] = 0x08;
	fis[16] = 0;
	fis[17] = 0;
	fis[18] = 0;
	fis[19] = 0;
a1650 4

	cmd_slot->flags = htole16(5); /* FIS length (in DWORDs) */
	if (xa->flags & ATA_F_WRITE)
		cmd_slot->flags |= htole16(AHCI_CMD_LIST_FLAG_W);
@


1.77
log
@Implement hardware interrupt handler.  For now, detect command completion
and shut down the controller upon error (no recovery).
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.76 2007/03/06 14:24:24 pascoe Exp $ */
d42 1
d312 3
a321 1
	struct ata_xfer		*ccb_xa;
d425 1
a425 1
void			ahci_put_ccb(struct ahci_port *, struct ahci_ccb *);
d453 4
a456 1
int			ahci_ata_cmd(void *, struct ata_xfer *);
d460 1
d862 3
a864 1
		ahci_put_ccb(ap, ccb);
d1134 1
a1134 1
		ahci_put_ccb(ap, ccb);
d1201 1
a1201 1
	struct ata_xfer			*xa = ccb->ccb_xa;
d1416 1
a1416 1
	if (ccb != NULL)
d1418 2
d1425 1
a1425 1
ahci_put_ccb(struct ahci_port *ap, struct ahci_ccb *ccb)
d1427 3
d1597 34
d1632 1
a1632 1
ahci_ata_cmd(void *xsc, struct ata_xfer *xa)
d1634 1
a1634 3
	struct ahci_softc		*sc = xsc;
	struct ahci_port		*ap = sc->sc_ports[xa->port->ap_port];
	struct ahci_ccb			*ccb;
a1638 10
	if (ap == NULL)
		return (ATA_ERROR);

	s = splbio();
	ccb = ahci_get_ccb(ap);
	splx(s);
	if (ccb == NULL)
		return (ATA_ERROR);

	ccb->ccb_xa = xa;
d1665 2
a1666 6
	if (ahci_load_prdt(ccb) != 0) {
		s = splbio();
		ahci_put_ccb(ap, ccb);
		splx(s);
		return (ATA_ERROR);
	}
d1672 2
d1684 7
d1698 1
a1698 1
	struct ata_xfer			*xa = ccb->ccb_xa;
a1708 1
	ahci_put_ccb(ap, ccb);
@


1.76
log
@Add missing splx in poll path.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.75 2007/03/06 14:15:51 pascoe Exp $ */
d41 2
a42 1
int ahcidebug = AHCI_D_VERBOSE;
d360 4
d603 3
d613 3
d908 6
d1226 1
a1226 1
			    PORTNAME(ap), dmap->dm_segs[i].ds_len);
d1294 31
a1324 1
	return (0);
d1331 2
a1333 2
	u_int32_t			ci;
	int				i, intr = 0;
d1335 35
d1371 23
a1393 3
	for (i = 0; i < sc->sc_ncmds; i++) {
		if (ISSET(ci, 1 << i)) {
			ccb = &ap->ap_ccbs[i];
d1395 1
a1395 19
			bus_dmamap_sync(sc->sc_dmat,
			    AHCI_DMA_MAP(ap->ap_dmamem_cmd_list),
			    ccb->ccb_slot * sizeof(struct ahci_cmd_hdr),
			    sizeof(struct ahci_cmd_hdr),
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_sync(sc->sc_dmat,
			    AHCI_DMA_MAP(ap->ap_dmamem_cmd_table),
			    ccb->ccb_slot * sizeof(struct ahci_cmd_table),
			    sizeof(struct ahci_cmd_table),
			    BUS_DMASYNC_POSTWRITE);

			bus_dmamap_sync(sc->sc_dmat,
			    AHCI_DMA_MAP(ap->ap_dmamem_rfis), 0,
			    sizeof(struct ahci_rfis), BUS_DMASYNC_POSTREAD);

			ap->ap_active &= ~(1 << ccb->ccb_slot);
			ccb->ccb_done(ccb);
			intr = 1;
		}
d1398 1
a1398 1
	return (intr);
d1640 1
a1640 1
	if (1 || xa->flags & ATA_F_POLL) {
@


1.75
log
@Update CCS macro to return the current command slot rather than just being
a mask.

Fix some typos and try to keep functions in the same order as prototypes
to make the code easier to navigate.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.74 2007/03/06 12:25:00 dlg Exp $ */
d1235 2
a1236 1
		if (ahci_port_intr(ap, 1 << ccb->ccb_slot))
d1238 1
@


1.74
log
@big changes to the completion path in ahci.c

- add a ccb_done member to the ahci_ccb, which points to a function that
is used to complete the current xfer
- ccbs no longer rely on an ata_xfer being provided for submission to work
- ahci is stupid and has no way to telling you the difference between an
empty command slot, and a completed command. we keep track of active
commands with ap_active in ahci_port, so we dont try and complete commands
we havent actually submitted
- ahci_start simple submits a command to the hardware now
- provide the start of an interrupt handler for each port (which is not yet
called by the controllers interrupt handler)
- provide an ahci_poll which is built on top of ahci_start and
ahci_port_intr
- remove the fake ata_xfers from the softreset path
- on completion of an ahci command, sync the relevant dma memory
- provide a completion path for ata_xfers which syncs the xfers buffer
and calls the xfers completion handler

in atascsi.c:

- start defining the contents of the response to an ATA IDENTIFY command
specific to SATA
- implement the faking of scsi inquiries, so now you'll actually see a disk
attach to ahci.
- start implementing a fake scsi read capacity. it presents a fake geometry
though, so dont get too excited when ahci magically makes your disk have a
terabyte in size.

lots of discussion, help, tweaks, and an ok from pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.73 2007/03/06 09:01:28 dlg Exp $ */
d105 1
a105 1
#define  AHCI_PREG_IS_SDBS		(1<<3) /* Set Devince Bits FIS */
d128 1
a128 1
#define  AHCI_PREG_IE_SDBE		(1<<3) /* Set Devince Bits FIS */
d153 1
a153 1
#define  AHCI_PREG_CMD_CCS		0x1f00 /* Current Command Slot */
a393 1
int			ahci_init(struct ahci_softc *);
d398 2
d406 1
a407 1
int			ahci_port_softreset(struct ahci_port *);
d410 1
a411 1
int			ahci_poll(struct ahci_ccb *, int);
d473 23
a511 9
int
ahci_jmicron_match(struct pci_attach_args *pa)
{
	if (pa->pa_function != 0)
		return (0);

	return (1);
}

a605 14
}

int
ahci_jmicron_attach(struct pci_attach_args *pa)
{
	u_int32_t			ccr;

	/* Switch JMICRON ports to AHCI mode */
	ccr = pci_conf_read(pa->pa_pc, pa->pa_tag, 0x40);
	ccr &= ~0x0000ff00;
	ccr |=  0x0000a100;
	pci_conf_write(pa->pa_pc, pa->pa_tag, 0x40, ccr);

	return (0);
@


1.73
log
@since we dont overwrite the dva of the cmd_table in the cmd_hdr now, we
dont have to carry the cmd_tables dva around in the ccb anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.72 2007/03/06 09:00:03 dlg Exp $ */
d313 1
a313 2
	struct ata_xfer		*ccb_xa;

d317 2
a318 1
	bus_dmamap_t		ccb_dmamap;
d333 1
d409 2
a410 1
int			ahci_start(struct ahci_ccb *);
d413 1
d451 4
a1018 1
	struct ata_xfer			xa;
d1027 1
a1064 3
	bzero(&xa, sizeof(struct ata_xfer));
	xa.flags = ATA_F_POLL | ATA_F_WRITE;
	ccb->ccb_xa = &xa;
d1072 1
a1072 3
	if (ahci_load_prdt(ccb))
		goto err;

d1078 1
a1078 1
	if (ahci_start(ccb) != ATA_COMPLETE)
a1081 3
	bzero(&xa, sizeof(struct ata_xfer));
	xa.flags = ATA_F_POLL | ATA_F_WRITE;
	ccb->ccb_xa = &xa;
d1088 1
a1088 3
	if (ahci_load_prdt(ccb))
		goto err;

d1092 1
a1092 1
	if (ahci_start(ccb) != ATA_COMPLETE)
d1226 21
a1250 2
	int				rc = ATA_QUEUED;
	int				s;
d1267 1
a1267 1
	s = splbio();
a1268 14
	if (ccb->ccb_xa->flags & ATA_F_POLL) {
		if (ahci_pwait_clr(ap, AHCI_PREG_CI, 1 << ccb->ccb_slot)) {
			/* Command didn't go inactive.  XXX: wait longer? */
			printf("%s: polled command didn't go inactive\n",
			    PORTNAME(ap));
			/* Shutdown port.  XXX: recover via port reset? */
			ahci_port_stop(ap, 0);
			rc = ATA_ERROR;
		} else
			rc = ATA_COMPLETE;
	}
	splx(s);

	return (rc);
d1277 37
d1516 1
d1553 37
a1589 1
	return (ahci_start(ccb));
@


1.72
log
@dont do pointer maths with void *
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.71 2007/03/06 06:43:56 pascoe Exp $ */
a316 1
	u_int64_t		ccb_cmd_table_dva;
@


1.71
log
@Apply a SG segment size limit and remove the length check.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.70 2007/03/06 05:59:21 pascoe Exp $ */
d714 3
a717 1
	u_int32_t			cmd;
d816 2
d830 2
a831 4
		ccb->ccb_cmd_hdr = AHCI_DMA_KVA(ap->ap_dmamem_cmd_list) +
		    ccb->ccb_slot * sizeof(struct ahci_cmd_hdr);
		ccb->ccb_cmd_table = AHCI_DMA_KVA(ap->ap_dmamem_cmd_table) +
		    ccb->ccb_slot * sizeof(struct ahci_cmd_table);
@


1.70
log
@No need to continually assign the control table addresses, provided we don't
ever zero out the whole command header.

Also add some diagnostic checks to ensure we don't violate any of the
controller's DMA address/size restrictions.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.67 2007/03/05 09:13:44 dlg Exp $ */
d818 1
a818 1
		    MAXPHYS, 0, 0, &ccb->ccb_dmamap) != 0) {
a1211 4
		}
		if (dmap->dm_segs[i].ds_len > 0x1fffff) {
			printf("%s: requested DMA length %d is too long\n",
			    PORTNAME(ap), dmap->dm_segs[i].ds_len);
@


1.69
log
@dlg@@ advises that the bus_space operations will endian convert the DMA base
addresses for me when it writes to the registers.  Don't swap them manually.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.68 2007/03/06 05:38:55 pascoe Exp $ */
d408 1
a408 1
int			ahci_load_prdt(struct ahci_ccb *, struct ata_xfer *);
d830 1
a830 1
		ccb->ccb_cmd_table_dva = AHCI_DMA_DVA(ap->ap_dmamem_cmd_table) +
d832 2
d1067 3
a1073 2
	cmd_slot->ctba_hi = htole32((u_int32_t)(ccb->ccb_cmd_table_dva >> 32));
	cmd_slot->ctba_lo = htole32((u_int32_t)ccb->ccb_cmd_table_dva);
d1088 3
a1092 2
	cmd_slot->ctba_hi = htole32((u_int32_t)(ccb->ccb_cmd_table_dva >> 32));
	cmd_slot->ctba_lo = htole32((u_int32_t)ccb->ccb_cmd_table_dva);
d1107 2
a1108 1
	if (ccb != NULL)
d1110 2
d1172 1
a1172 1
ahci_load_prdt(struct ahci_ccb *ccb, struct ata_xfer *xa)
d1176 1
d1179 1
a1179 1
	struct ahci_cmd_hdr		*cmd_slot;
d1183 2
a1184 1
	if (xa->datalen == 0)
d1186 1
d1202 16
a1217 1

d1222 1
a1222 3
	cmd_slot = ccb->ccb_cmd_hdr;
	cmd_slot->prdtl = htole16(ccb->ccb_dmamap->dm_nsegs);
	cmd_slot->prdbc = 0;
d1239 3
a1292 1
	/* scrub bits */
a1480 1
	bzero(cmd_slot, sizeof(struct ahci_cmd_hdr));
d1505 1
a1505 1
	if (ahci_load_prdt(ccb, xa) != 0) {
a1514 2
	cmd_slot->ctba_hi = htole32((u_int32_t)(ccb->ccb_cmd_table_dva >> 32));
	cmd_slot->ctba_lo = htole32((u_int32_t)ccb->ccb_cmd_table_dva);
@


1.68
log
@Make the 1:1 mapping of command slot to command header/table entries
explicit by including pointers to both of them in the ccb.

Inspired by dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.67 2007/03/05 09:13:44 dlg Exp $ */
d770 2
a771 2
	ahci_pwrite(ap, AHCI_PREG_FBU, htole32((u_int32_t)(dva >> 32)));
	ahci_pwrite(ap, AHCI_PREG_FB, htole32((u_int32_t)dva));
d809 2
a810 2
	ahci_pwrite(ap, AHCI_PREG_CLBU, htole32((u_int32_t)(dva >> 32)));
	ahci_pwrite(ap, AHCI_PREG_CLB, htole32((u_int32_t)dva));
@


1.67
log
@add a reminder about the extra attach function
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.66 2007/03/05 09:12:39 dlg Exp $ */
d283 1
a283 1
/* this makes ahci_cmd_table 512 bytes, which is good for alignment */
d315 1
a330 1
	struct ahci_cmd_hdr	*ap_cmd_list;
a712 1
	u_int8_t			*kva;
d768 1
a768 1
	kva = AHCI_DMA_KVA(ap->ap_dmamem_rfis);
a769 1
	ap->ap_rfis = (struct ahci_rfis *)kva;
a807 1
	kva = AHCI_DMA_KVA(ap->ap_dmamem_cmd_list);
a808 1
	ap->ap_cmd_list = (struct ahci_cmd_hdr *)kva;
d812 1
a812 1
	/* Split CCB allocation into CCBs and assign command table entries */
a813 2
	kva = AHCI_DMA_KVA(ap->ap_dmamem_cmd_table);
	dva = AHCI_DMA_DVA(ap->ap_dmamem_cmd_table);
a823 5
		/*
		 * NB: ahci_start assumes a 1:1 mapping of CCB slot number
		 * to command slot and command table positions in its
		 * bus_dmasync_calls.
		 */
d826 6
a831 4
		ccb->ccb_cmd_table = (struct ahci_cmd_table *)
		    (kva + i * sizeof(struct ahci_cmd_table));
		ccb->ccb_cmd_table_dva =
		    dva + i * sizeof(struct ahci_cmd_table);
d1058 1
a1058 2
	cmd_slot = &ap->ap_cmd_list[ccb->ccb_slot];
	bzero(cmd_slot, sizeof(struct ahci_cmd_hdr));
d1079 1
a1079 2
	cmd_slot = &ap->ap_cmd_list[ccb->ccb_slot];
	bzero(cmd_slot, sizeof(struct ahci_cmd_hdr));
d1197 1
a1197 1
	cmd_slot = &ap->ap_cmd_list[ccb->ccb_slot];
a1219 1
	/* NB this assumes a 1:1 mapping of ccb slot to command table entry */
d1455 1
a1455 1
	cmd_slot = &ap->ap_cmd_list[ccb->ccb_slot];
@


1.66
log
@add space for a match and attach routine to the device list, so particular
controllers can specify extra code to run at match or attach time.

use this on jmicron controllers to restrict attaching to ahci on pci
function 0 (high functions are normal pciide style controllers), and to
do the CCR tweaking to enable ahci.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.65 2007/03/05 06:06:13 pascoe Exp $ */
d506 2
a507 1
		if (ad->ad_attach(pa) != 0)
d509 1
@


1.65
log
@Recognise ATAPI device signatures.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.64 2007/03/04 14:49:46 pascoe Exp $ */
a295 7
static const struct pci_matchid ahci_devices[] = {
	{ PCI_VENDOR_JMICRON,	PCI_PRODUCT_JMICRON_JMB361 }
};

int			ahci_match(struct device *, void *, void *);
void			ahci_attach(struct device *, struct device *, void *);

d362 20
d449 16
d468 21
a488 2
	return (pci_matchbyid((struct pci_attach_args *)aux, ahci_devices,
	    sizeof(ahci_devices) / sizeof(ahci_devices[0])));
d496 1
d501 3
a503 8
	/* Switch JMICRON ports to AHCI mode */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_JMICRON) {
		u_int32_t ccr;

		ccr = pci_conf_read(pa->pa_pc, pa->pa_tag, 0x40);
		ccr &= ~0x0000ff00;
		ccr |=  0x0000a100;
		pci_conf_write(pa->pa_pc, pa->pa_tag, 0x40, ccr);
d505 2
a506 2
		/* Only function 0 is SATA */
		if (pa->pa_function != 0)
d583 14
@


1.64
log
@Fix non AHCI_DEBUG build.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.63 2007/03/04 14:46:38 pascoe Exp $ */
d1375 1
d1380 5
a1384 1
	return (ATA_PORT_T_DISK);
@


1.63
log
@Replace empty ahci_ata_{probe,cmd} stubs with ones that do something.

Mostly from dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.62 2007/03/04 14:40:41 pascoe Exp $ */
d347 2
@


1.62
log
@Include port number in debug messages, where appropriate.

Clean up some whitespace problems.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.61 2007/03/04 14:23:08 pascoe Exp $ */
a1201 12
int
ahci_ata_probe(void *xsc, int port)
{
	return (0);
}

int
ahci_ata_cmd(void *xsc, struct ata_xfer *xa)
{
	return (0);
}

d1366 74
@


1.61
log
@Now actually activate ports and try to detect devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.60 2007/03/04 14:06:34 pascoe Exp $ */
d343 5
d664 4
a787 1
	printf("ahci_portreset returned %d\n", rc);
a810 1
		printf("ahci_portsoftreset returned %d\n", rc);
d821 1
d924 1
a924 1
	u_int32_t 			cmd;
d934 1
a934 1
		printf("%s: CLO requested while port running\n", DEVNAME(sc));
d940 1
a940 1
		printf("%s: CLO did not complete\n", DEVNAME(sc));
d958 1
a958 1
	DPRINTF(AHCI_D_VERBOSE, "%s: soft reset\n", DEVNAME(ap->ap_sc));
d972 1
a972 1
		    DEVNAME(ap->ap_sc));
d987 1
a987 1
		    DEVNAME(ap->ap_sc));
d994 1
a994 1
		printf("%s: CLO %s, need port reset\n", DEVNAME(ap->ap_sc),
d1045 1
a1045 1
		    DEVNAME(ap->ap_sc), ahci_pread(ap, AHCI_PREG_TFD),
d1065 2
a1066 2
	u_int32_t cmd, r;
	int rc;
d1068 1
a1068 1
	DPRINTF(AHCI_D_VERBOSE, "%s: port reset\n", DEVNAME(ap->ap_sc));
d1131 1
a1131 1
		printf("%s: error %d loading dmamap\n", DEVNAME(sc), error);
d1184 1
a1184 1
			    DEVNAME(sc));
a1212 1

@


1.60
log
@Save BIOS configured parameters over reset.  Always enable staggered spin-up.

Don't clean interrupt status now - have to flush individual ports' status first.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.59 2007/03/04 13:53:17 pascoe Exp $ */
d649 1
a658 1
	ap->ap_sc = sc;
d668 24
d704 12
d759 5
d774 47
a820 1
	rc = 0;
d822 3
d837 8
@


1.59
log
@Add support for enabling/disabling port activity, and soft/port resets.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.56 2007/03/04 13:32:41 pascoe Exp $ */
d589 1
a589 1
	u_int32_t			reg;
d595 6
d611 5
a615 1
	/* enable ahci */
a634 4

	/* clean interrupts */
	reg = ahci_read(sc, AHCI_REG_IS);
	ahci_write(sc, AHCI_REG_IS, reg);
@


1.58
log
@Add support for issuing a (polled) command.
@
text
@d382 6
d762 240
d1073 2
@


1.57
log
@Add function to set up Physical Region Descriptor Tables, mostly from dlg@@
@
text
@d383 1
d797 37
@


1.56
log
@Oops, remove duplicate prototypes that I mismerged.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.55 2007/03/04 13:24:48 pascoe Exp $ */
d382 2
d752 44
@


1.55
log
@Third argument to pci_mapreg_map is the "map type", not "memory type".
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.54 2007/03/04 13:19:14 pascoe Exp $ */
a369 2
int			ahci_intr(void *);

d382 2
a397 2
u_int32_t		ahci_pread(struct ahci_port *, bus_size_t);
void			ahci_pwrite(struct ahci_port *, bus_size_t, u_int32_t);
@


1.54
log
@Perform separate memory allocations for the RFIS, command list and command
tables.  Avoids alignment issues and simplifies the calculation of the ranges
to sync before DMA.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.53 2007/03/04 12:23:25 pascoe Exp $ */
d530 1
a530 1
	pcireg_t			memtype;
d532 2
a533 2
	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, AHCI_PCI_BAR);
	if (pci_mapreg_map(pa, AHCI_PCI_BAR, memtype, 0, &sc->sc_iot,
@


1.53
log
@When freeing port memory, use actual pointer to port rather than random memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.52 2007/03/04 12:20:17 pascoe Exp $ */
a333 1
	struct ahci_dmamem	*ap_dmamem;
d335 2
d338 2
d504 1
a504 1
		if (ahci_port_alloc(sc, i) != 0)
d517 1
a517 1
        return;
d520 1
a520 1
	for (i = 0; i < AHCI_MAX_PORTS; i++) {
a522 1
	}
d635 1
a635 2
	int				offset = 0;
	int				i;
d641 1
a641 1
		return (1);
d646 1
a646 1
	TAILQ_INIT(&ap->ap_ccb_free);
d655 13
d673 1
a673 1
		goto freeregion;
d677 10
a686 9
	/* calculate the size of the dmaable memory this port will need.  */
	i = sizeof(struct ahci_cmd_table) * sc->sc_ncmds +
	    sizeof(struct ahci_rfis) +
	    sizeof(struct ahci_cmd_hdr) * sc->sc_ncmds;
	ap->ap_dmamem = ahci_dmamem_alloc(sc, i);
	if (ap->ap_dmamem == NULL) {
		printf("unable to allocate dmamem for port %d\n", DEVNAME(sc),
		    port);
		goto freeccbs;
a687 2
	kva = AHCI_DMA_KVA(ap->ap_dmamem);
	dva = AHCI_DMA_DVA(ap->ap_dmamem);
d689 11
d705 3
a707 3
			printf("unable to create dmamap for port %d ccb %d\n",
			    DEVNAME(sc), port, i);
			goto freemaps;
d712 4
a715 3
		ccb->ccb_cmd_table = (struct ahci_cmd_table *)(kva + offset);
		ccb->ccb_cmd_table_dva = dva + offset;
		offset += sizeof(struct ahci_cmd_table);
d720 1
a720 12
	ap->ap_rfis = (struct ahci_rfis *)(kva + offset);
	ahci_pwrite(ap, AHCI_PREG_FB, (u_int32_t)(dva + offset));
	ahci_pwrite(ap, AHCI_PREG_FBU, (u_int32_t)((dva + offset) >> 32));
	offset += sizeof(struct ahci_rfis);

	ap->ap_cmd_list = (struct ahci_cmd_hdr *)(kva + offset);
	ahci_pwrite(ap, AHCI_PREG_CLB, (u_int32_t)(dva + offset));
	ahci_pwrite(ap, AHCI_PREG_CLBU, (u_int32_t)((dva + offset) >> 32));

	sc->sc_ports[port] = ap;

	return (0);
a721 8
freemaps:
	while ((ccb = ahci_get_ccb(ap)) != NULL)
		bus_dmamap_destroy(sc->sc_dmat, ccb->ccb_dmamap);
	ahci_dmamem_free(sc, ap->ap_dmamem);
freeccbs:
	free(ap->ap_ccbs, M_DEVBUF);
freeregion:
	/* bus_space(9) says no cleanup necessary for subregions */
d723 4
a726 2
	free(ap, M_DEVBUF);
	return (1);
a733 1
	int				i;
d735 5
a739 2
	for (i = 0; i < sc->sc_ncmds; i++) {
		ccb = &ap->ap_ccbs[i];
d741 6
a746 2
		bus_dmamap_destroy(sc->sc_dmat, ccb->ccb_dmamap);
	}
a747 1
	ahci_dmamem_free(sc, ap->ap_dmamem);
d749 1
a749 1
	free(ap->ap_ccbs, M_DEVBUF);
@


1.52
log
@Add functions to wait for bit changes in port registers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.51 2007/03/04 12:01:46 pascoe Exp $ */
d724 1
a724 1
	struct ahci_port		*ap;
a727 2
	ap = sc->sc_ports[i];

d738 1
a738 1
	sc->sc_ports[i] = NULL;
@


1.51
log
@HBAs by JMICRON have an additional "Controller Control Register" that
must be programmed to switch the ports into AHCI mode.  Do so.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.50 2007/03/04 05:06:28 dlg Exp $ */
d390 7
d399 1
a399 1
int			ahci_wait_eq(struct ahci_softc *, bus_size_t,
d401 1
a401 1
int			ahci_wait_ne(struct ahci_softc *, bus_size_t,
d404 6
d852 30
d899 1
a899 1
ahci_wait_eq(struct ahci_softc *sc, bus_size_t r, u_int32_t mask,
d905 1
a905 1
		if ((ahci_read(sc, r) & mask) == target)
d914 1
a914 1
ahci_wait_ne(struct ahci_softc *sc, bus_size_t r, u_int32_t mask,
d920 1
a920 1
		if ((ahci_read(sc, r) & mask) != target)
@


1.50
log
@comment members of ahci_cmd_table
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.49 2007/03/04 05:04:32 dlg Exp $ */
d421 14
@


1.49
log
@pull the prdt into the ahci_cmd_table struct, which gets rid of ahci_cmd.

from pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.48 2007/03/04 04:58:38 dlg Exp $ */
d287 2
a288 2
	u_int8_t		cfis[64];
	u_int8_t		acmd[16];
@


1.48
log
@rename struct ahci_cmd_list to ahci_cmd_hdr to better match the spec and
make it easier to read the code. fix the ordering of the flags and prdtl
fields.

from pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.47 2007/03/04 04:51:12 dlg Exp $ */
a274 6
struct ahci_cmd_table {
	u_int8_t		cfis[64];
	u_int8_t		acmd[16];
	u_int8_t		reserved[48];
} __packed;

d283 1
a283 1
/* this makes ahci_cmd 512 bytes, which is good for alignment */
d286 6
a291 3
struct ahci_cmd {
	struct ahci_cmd_table	table;
	struct ahci_prdt		prdt[AHCI_MAX_PRDT];
d322 2
a323 2
	struct ahci_cmd		*ccb_cmd;
	u_int64_t		ccb_cmd_dva;
d637 1
a637 1
	i = sizeof(struct ahci_cmd) * sc->sc_ncmds +
d661 3
a663 3
		ccb->ccb_cmd = (struct ahci_cmd *)(kva + offset);
		ccb->ccb_cmd_dva = dva + offset;
		offset += sizeof(struct ahci_cmd);
@


1.47
log
@reverse the order of the fields in the %b fmt strings so that they read
the bitfield from left to right like us humans do.

from pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.46 2007/02/20 22:33:37 dlg Exp $ */
d243 1
a243 2
struct ahci_cmd_list {
	u_int16_t		prdtl; /* sgl len */
d253 1
d255 1
a255 1
	u_int32_t		prdbc; /* datalen */
d339 1
a339 1
	struct ahci_cmd_list	*ap_cmd_list;
d642 1
a642 1
	    sizeof(struct ahci_cmd_list) * sc->sc_ncmds;
d676 1
a676 1
	ap->ap_cmd_list = (struct ahci_cmd_list *)(kva + offset);
@


1.46
log
@rename ccb_id to ccb_slot so its more clear what its used for. stash a
pointer to the port and the ata_xfer in there too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.45 2007/02/20 22:27:59 dlg Exp $ */
d72 5
a76 5
#define  AHCI_FMT_CAP		"\020" "\006SXS" "\007EMS" "\010CCCS" \
				    "\016PSC" "\017SSC" "\020PMD" "\021FBSS" \
				    "\022SPM" "\023SAM" "\024SNZO" "\031SCLO" \
				    "\032SAL" "\033SALP" "\034SSS" "\035SMPS" \
				    "\036SSNTF" "\037NCQ" "\040S64A"
d82 1
a82 1
#define AHCI_FMT_GHC		"\020" "\001HR" "\002IE" "\003MRSM" "\040AE"
d119 5
a123 5
#define AHCI_PFMT_IS		"\20" "\001DHRS" "\002PSS" "\003DSS" \
				    "\004SDBS" "\005UFS" "\006DPS" "\007PCS" \
				    "\010DMPS" "\027PRCS" "\030IPMS"  \
				    "\031OFS" "\033INFS" "\034IFS" "\035HBDS" \
				    "\036HBFS" "\037TFES" "\040CPDS"
d142 5
a146 5
#define AHCI_PFMT_IE		"\20" "\001DHRE" "\002PSE" "\003DSE" \
				    "\004SDBE" "\005UFE" "\006DPE" "\007PCE" \
				    "\010DMPE" "\027PRCE" "\030IPME"  \
				    "\031OFE" "\033INFE" "\034IFE" "\035HBDE" \
				    "\036HBFE" "\037TFEE" "\040CPDE"
d172 5
a176 5
#define  AHCI_PFMT_CMD		"\020" "\001ST" "\002SUD" "\003POD" \
				    "\004CLO" "\005FRE" "\016MPSS" "\017FR" \
				    "\020CR" "\021CPS" "\022PMA" "\023HPCP" \
				    "\024MPSP" "\025CPD" "\026ESP" \
				    "\031ATAPI" "\032DLAE" "\033ALPE" "\034ASP"
d183 1
a183 1
#define AHCI_PFMT_TFD_STS	"\20" "\001ERR" "\004DRQ" "\010BSY"
d222 2
a223 2
#define  AHCI_PFMT_SERR_ERR	"\020" "\001I" "\002M" "\011T" "\012C" \
				    "\013P" "\014E"
d236 3
a238 3
#define  AHCI_PFMT_SERR_DIAG	"\020" "\001N" "\002I" "\003W" "\004B" \
				    "\005D" "\006C" "\007H" "\010S" "\011T" \
				    "\012F" "\013X"
@


1.45
log
@oops, missed one in the cmd list entry
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.44 2007/02/20 22:25:30 dlg Exp $ */
d317 1
d320 4
a323 1
	int			ccb_id;
d662 2
a663 1
		ccb->ccb_id = i;
@


1.44
log
@fill some macros for ahci structures. fix a spello while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.43 2007/02/19 13:54:07 dlg Exp $ */
d246 1
@


1.43
log
@stick atascsi onto ahci, which in turn attaches a scsibus. while this
compiles, it definitely doesnt work.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.42 2007/02/18 01:27:55 dlg Exp $ */
d183 1
a183 1
#define AHCI_PFTM_TFD_STS	"\20" "\001ERR" "\004DRQ" "\010BSY"
d246 7
d285 1
@


1.42
log
@reorder allocation of the ports resources so register manipulation can be
done earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.41 2007/02/17 05:39:15 dlg Exp $ */
d34 2
d344 2
d387 9
d408 1
d468 9
d710 13
@


1.41
log
@only reset the controller if it is already enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.40 2007/02/14 04:36:53 dlg Exp $ */
d587 7
d599 1
a599 1
		goto freeport;
a602 7
	if (bus_space_subregion(sc->sc_iot, sc->sc_ioh,
	    AHCI_PORT_REGION(port), AHCI_PORT_SIZE, &ap->ap_ioh) != 0) {
		printf("%s: unable to create register window for port %d\n",
		    DEVNAME(sc), port);
		goto freeccbs;
	}

d653 2
@


1.40
log
@%b format string for the GHC register. less whitespace while here
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.36 2007/01/04 12:14:51 dlg Exp $ */
d523 11
a533 6
	/* reset the controller */
	ahci_write(sc, AHCI_REG_GHC, AHCI_REG_GHC_HR);
	if (ahci_wait_ne(sc, AHCI_REG_GHC, AHCI_REG_GHC_HR,
	    AHCI_REG_GHC_HR) != 0) {
		printf(": unable to reset controller\n");
		return (1);
@


1.39
log
@add macros describing the ports interrupt status, interrupt enable, task
file descriptor, sata control, and sata error registers. some %b fmt
strings are sprinkled around so i can read all this goo better as well.
@
text
@a69 1

a74 1

d80 1
a169 1

a174 1

@


1.38
log
@macros describing a ports sata status register
@
text
@d101 22
d124 22
d179 6
d189 2
a190 2
#define  AHCI_PREG_SSTS_DET_DEV_NOPHY	0x1
#define  AHCI_PREG_SSTS_DET_DEV_PHY	0x3
d202 13
d216 24
@


1.37
log
@macros for the bits in the ports CMD register. free %b fmt string for it
while im here.
@
text
@d137 14
@


1.36
log
@use the right variable when finding a ports register window, not one that
contains random garbage on the stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.35 2007/01/04 12:02:49 dlg Exp $ */
d103 31
@


1.35
log
@stash the dva for each command in the ccb, and program the hardware with
the dva of the rfis and command list.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.34 2007/01/04 11:48:03 dlg Exp $ */
d463 1
a463 1
	    AHCI_PORT_REGION(i), AHCI_PORT_SIZE, &ap->ap_ioh) != 0) {
@


1.34
log
@fix up some port regs so their names are more in line with what is in the
spec.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.33 2007/01/04 11:37:12 dlg Exp $ */
d182 1
d438 2
d480 1
d493 3
a495 2
		ccb->ccb_cmd = (struct ahci_cmd *)kva;
		kva += sizeof(struct ahci_cmd);
d500 8
a507 4
	ap->ap_rfis = (struct ahci_rfis *)kva;
	kva += sizeof(struct ahci_rfis);

	ap->ap_cmd_list = (struct ahci_cmd_list *)kva;
@


1.33
log
@allocate the dmamem that each port will need, and hopefully point our
structs at all the right bits of it. the dma addresses arent taken care of
yet, just the kva ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.32 2007/01/04 08:39:21 dlg Exp $ */
d105 4
a108 4
#define AHCI_PREG_Status	0x28 /* SATA Status */
#define AHCI_PREG_Control	0x2c /* SATA Control */
#define AHCI_PREG_Error		0x30 /* SATA Error */
#define AHCI_PREG_Active	0x34 /* SATA Active */
d110 1
@


1.32
log
@use ISSET instead of &, cos it looks cleaner
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.30 2006/12/12 02:44:00 dlg Exp $ */
d148 1
d178 4
d191 4
a196 2

	struct ahci_dmamem	*ap_dmamem;
d435 1
d465 11
a475 1
	/* XXX alloc dma mem */
d487 3
a489 1
		/* XXX point ccb at its cmd structures in dma mem */
d494 5
d506 1
a506 1
	/* XXX free dma mem */
d529 1
a529 1
	/* XXX free dma mem */
@


1.31
log
@small cleanup after feng shui
@
text
@d307 1
a307 1
		if (((1 << i) & reg) == 0) {
@


1.30
log
@after allocating the ahci_port bits, stash it in the softc rather than
drop it. im guessing at some point we'll want to use each port, knowing
where they are can help.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.29 2006/12/12 02:41:50 dlg Exp $ */
a284 1
		reg = ahci_read(sc, AHCI_REG_CAP);
@


1.29
log
@feng shui
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.28 2006/12/12 02:39:25 dlg Exp $ */
d474 2
@


1.28
log
@for each port the controller says is hooked up, go and allocate our
ahci_port structs for it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.27 2006/12/12 02:37:09 dlg Exp $ */
a259 2
	sc->sc_dmat = pa->pa_dmat;

d277 4
a419 3

	reg = ahci_read(sc, AHCI_REG_CAP);
	sc->sc_ncmds = AHCI_REG_CAP_NCS(reg);
@


1.27
log
@start implementing the bits that allocate the per port structures and their
ccb lists. this is missing handling of the dmamem each port needs to
manage, but that can wait till i figure out how it fits together. insane
stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.26 2006/12/12 02:24:20 dlg Exp $ */
d257 2
a280 1
		u_int32_t reg = ahci_read(sc, AHCI_REG_CAP);
d283 1
d302 12
a313 1
	return;
d315 7
@


1.26
log
@remember our dma tag. be able to do dma is like, really cool. man.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.25 2006/12/12 02:22:56 dlg Exp $ */
d226 2
d403 86
@


1.25
log
@add functions to get and put ccbs out of each ports command free list.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.24 2006/12/12 02:19:37 dlg Exp $ */
d255 2
@


1.24
log
@add wrappers for reading and writing a ports registers called ahci_pread,
and ahci_pwrite. these will use an io handle into a window of the
controllers register space that can be created with bus_space_subregion,
and which is stored in the ahci_port struct.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.23 2006/12/12 02:13:32 dlg Exp $ */
d227 3
d405 19
@


1.23
log
@introduce the command control blocks, and the concept that they are managed
per port rather than as a big list for the whole controller. the softc
has an array of pointers to a struct that manages all the shizz relevant to
a particular port. when we map the controllers ports, we'll allocate these
as needed.

if the port isnt implemented, we leave its pointer in the softc null and
use that to decide if a drive might be there or not, rather than lookup up
the PI register all the time. a comparison has to null has to be cheaper
than doing bit operations, surely.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.22 2006/12/12 02:06:09 dlg Exp $ */
d183 3
d233 2
d472 16
@


1.22
log
@stash the number of commands each port can do in the softc
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.21 2006/12/11 23:42:33 dlg Exp $ */
d26 1
d174 15
d200 1
@


1.21
log
@use oct bits consistently in the format string for %b. pointed out by
deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.20 2006/12/11 13:20:29 dlg Exp $ */
d182 2
d267 1
a267 1
		    AHCI_REG_CAP_NP(reg), AHCI_REG_CAP_NCS(reg), gen);
d369 3
@


1.20
log
@oops, we want to return when everything goes well in ahci_attach, rather
than fall through to the bits that do cleanup when an error occurs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.19 2006/12/11 13:17:57 dlg Exp $ */
d72 2
a73 2
				    "\x12SPM" "\x13SAM" "\x14SNZO" "\x19SCLO" \
				    "\x1aSAL" "\x1bSALP" "\x1cSSS" "\x1dSMPS" \
@


1.19
log
@remove the argument to all the port registers that say which port you want
to address. instead make them simply offsets from the start of a ports
register space, which is something we can easily set up with
bus_space_subregion. this should make the code a lot easier to read later
on.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.18 2006/12/11 13:08:11 dlg Exp $ */
d268 2
@


1.18
log
@dont stash the implemented ports map, im going to use a different
mechanism to figure out if a port is usable or not later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.17 2006/12/11 13:06:33 dlg Exp $ */
d92 2
a93 1
#define _PO(_p)			(0x100 + ((_p) * 0x80)) /* port offset */
d95 14
a108 14
#define AHCI_PREG_CLB(_p)	(_PO(_p)+0x00) /* Cmd List Base Addr */
#define AHCI_PREG_CLBU(_p)	(_PO(_p)+0x04) /* Cmd List Base Hi Addr */
#define AHCI_PREG_FB(_p)	(_PO(_p)+0x08) /* FIS Base Addr */
#define AHCI_PREG_FBU(_p)	(_PO(_p)+0x0c) /* FIS Base Hi Addr */
#define AHCI_PREG_IS(_p)	(_PO(_p)+0x10) /* Interrupt Status */
#define AHCI_PREG_IE(_p)	(_PO(_p)+0x14) /* Interrupt Enable */
#define AHCI_PREG_CMD(_p)	(_PO(_p)+0x18) /* Command and Status */
#define AHCI_PREG_TFD(_p)	(_PO(_p)+0x20) /* Task File Data*/
#define AHCI_PREG_SIG(_p)	(_PO(_p)+0x24) /* Signature */
#define AHCI_PREG_Status(_p)	(_PO(_p)+0x28) /* SATA Status */
#define AHCI_PREG_Control(_p)	(_PO(_p)+0x2c) /* SATA Control */
#define AHCI_PREG_Error(_p)	(_PO(_p)+0x30) /* SATA Error */
#define AHCI_PREG_Active(_p)	(_PO(_p)+0x34) /* SATA Active */
#define AHCI_PREG_CI(_p)	(_PO(_p)+0x38) /* Command Issue */
@


1.17
log
@define the command structs used by the ports.

this stuff isnt endearing me to ata at all, and apparently ahci is a good
ata controller. the command path looks way more complicated than it needs
to be (or maybe i am used to really good scsi controllers, i dont know). a
lot of the terminology seems annoyingly different just for the sake of
being different. i mean, what is the advantage of calling a scatter gather
lement a "physical region descriptor table"? noone else calls it that.
there's a lot of weird stuff in here.

blah.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.16 2006/12/11 12:54:00 dlg Exp $ */
a180 2

	u_int32_t		sc_portmap;
a264 2
		printf("%s: ports implemented: 0x%08x\n", DEVNAME(sc),
		    sc->sc_portmap);
a363 2

	sc->sc_portmap = ahci_read(sc, AHCI_REG_PI);
@


1.16
log
@pull the wrapper for allocations of dma mem with a single segment in from
arc, which got it from mpi, which got it from ami. grange is right, we
should look at pushing it back up into the bus_dma api somewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.15 2006/12/11 12:48:01 dlg Exp $ */
d109 46
d454 1
a454 1
{ 
d469 1
a469 1
{ 
@


1.15
log
@oops, too far for the match/attach funcs
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.14 2006/12/11 12:46:12 dlg Exp $ */
d116 10
d160 4
d332 55
@


1.14
log
@give the function prototypes a bit more room for the return type.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.13 2006/12/11 05:47:53 dlg Exp $ */
d113 2
a114 3
int				ahci_match(struct device *, void *, void *);
void				ahci_attach(struct device *, struct device *,
				    void *);
@


1.13
log
@per port register definitions
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.12 2006/12/11 05:10:50 dlg Exp $ */
d113 3
a115 2
int		ahci_match(struct device *, void *, void *);
void		ahci_attach(struct device *, struct device *, void *);
d139 1
a139 1
int		ahci_intr(void *);
d141 16
a156 12
int		ahci_map_regs(struct ahci_softc *, struct pci_attach_args *);
void		ahci_unmap_regs(struct ahci_softc *, struct pci_attach_args *);
int		ahci_init(struct ahci_softc *);
int		ahci_map_intr(struct ahci_softc *, struct pci_attach_args *);
void		ahci_unmap_intr(struct ahci_softc *, struct pci_attach_args *);

u_int32_t	ahci_read(struct ahci_softc *, bus_size_t);
void		ahci_write(struct ahci_softc *, bus_size_t, u_int32_t);
int		ahci_wait_eq(struct ahci_softc *, bus_size_t,
		    u_int32_t, u_int32_t);
int		ahci_wait_ne(struct ahci_softc *, bus_size_t,
		    u_int32_t, u_int32_t);
@


1.12
log
@fix %b format string now that deraadt fixed printf
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.11 2006/12/11 04:26:16 dlg Exp $ */
d91 17
@


1.11
log
@stash the field showing which ports are hooked up, and dump it if verbose
debug is on
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.10 2006/12/11 04:14:37 dlg Exp $ */
d74 1
a74 1
				    "\036SSNTF" "\037NCQ" "\040 S64A"
@


1.10
log
@if ahci debug and verbose output is enabled, then dump the cap register.
this also fixes a few reg definition errors i found after having them
dumped.

something seems really screwy with %b. i cant select the 32nd bit position
using \x20 or \040, so im using \32 and the rest are octal (\oNN). hex
(\xNN) seems really really borked, and the compiler doesnt like eating some
of the dec ones (eg, \8BITNAME).
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.9 2006/12/09 07:17:10 dlg Exp $ */
d108 2
d183 1
a183 1
		printf("%s: CAP: 0x%b ports: %d ncmds: %d gen: %s\n",
d186 2
d287 2
@


1.9
log
@sigh, split the bus space mapping and interrupt hookup apart so i can
reset the controller and clear interrupts off it before doing the hookup.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.8 2006/12/09 07:02:44 dlg Exp $ */
d33 2
d46 1
a46 1
#define  AHCI_REG_CAP_NP(_r)		((r) & 0x1f) /* Number of Ports */
d50 1
a50 1
#define  AHCI_REG_CAP_NCS(_r)		(((_r) & 0xf80)>>7) /* No. Cmd Slots */
d57 4
a60 4
#define  AHCI_REG_CAP_SNZO		(1<<18) /* Non Zero DMA Offsets */
#define  AHCI_REG_CAP_ISS		(0xf<<18) /* Interface Speed Support */
#define  AHCI_REG_CAP_ISS_G1		(0x1<<18) /* Gen 1 (1.5 Gbps) */
#define  AHCI_REG_CAP_ISS_G1_2		(0x2<<18) /* Gen 1 and 2 (3 Gbps) */
d69 7
d163 23
@


1.8
log
@reset the hba and set the enable bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.7 2006/12/09 06:42:53 dlg Exp $ */
d112 2
a113 2
int		ahci_map_pci(struct ahci_softc *, struct pci_attach_args *);
void		ahci_unmap_pci(struct ahci_softc *, struct pci_attach_args *);
d115 2
d138 2
a139 2
	if (ahci_map_pci(sc, pa) != 0) {
		/* error already printed by ahci_map_pci */
d148 7
d156 1
a156 1
	ahci_unmap_pci(sc, pa);
d160 1
a160 1
ahci_map_pci(struct ahci_softc *sc, struct pci_attach_args *pa)
a162 2
	pci_intr_handle_t		ih;
	const char			*intrstr;
d171 16
d189 1
a189 1
		goto unmap;
d198 1
a198 1
		goto unmap;
a202 5

unmap:
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
	sc->sc_ios = 0;
	return (1);
d206 1
a206 1
ahci_unmap_pci(struct ahci_softc *sc, struct pci_attach_args *pa)
a208 3

	bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
	sc->sc_ios = 0;
d214 1
a214 1
	u_int32_t			vs;
d229 2
a230 2
	vs = ahci_read(sc, AHCI_REG_VS);
	switch (vs) {
d242 1
a242 1
		printf(": unsupported AHCI revision 0x%08x\n", vs);
d246 5
a250 1
	printf(": AHCI %s\n", revision);
@


1.7
log
@figure out which revision of ahci we're trying to use and print it out.
if we don't know about it, bomb out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.6 2006/12/09 06:29:43 dlg Exp $ */
d113 2
d140 8
a153 1
	u_int32_t			vs;
a155 1
	const char			*revision;
a163 17
	vs = ahci_read(sc, AHCI_REG_VS);
	switch (vs) {
	case AHCI_REG_VS_0_95:
		revision = "0.95";
		break;
	case AHCI_REG_VS_1_0:
		revision = "1.0";
		break;
	case AHCI_REG_VS_1_1:
		revision = "1.1";
		break;

	default:
		printf(": unsupported revision (0x%08x)\n", vs);
		goto unmap;
	}

d177 1
a177 2

	printf(": %s, AHCI %s\n", intrstr, revision);
d185 49
@


1.6
log
@split the mapping of the pci resources out of the main attach func
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.4 2006/12/09 06:08:09 dlg Exp $ */
d75 3
d144 1
d147 1
d156 17
d187 1
a187 1
	printf(": %s\n", intrstr);
@


1.5
log
@add wrappers for safe access to the register space. stolen from arc (which
stole them from mpi).
@
text
@d109 2
d130 10
d148 1
a148 1
		return;
d164 1
d167 1
a167 1
	return;
d172 1
@


1.4
log
@add macros for debug shizz
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.3 2006/12/09 06:03:34 dlg Exp $ */
d109 6
d165 46
@


1.3
log
@bit definitions for the cap and ghc registers
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.2 2006/12/09 05:19:49 dlg Exp $ */
d32 8
@


1.2
log
@registers for hba control
@
text
@d1 1
a1 1
/*	$OpenBSD: ahci.c,v 1.1 2006/12/09 05:10:43 dlg Exp $ */
d33 1
a33 1
#define AHCI_PCI_BAR			0x24
d35 36
a70 9
#define AHCI_REG_CAP			0x000 /* HBA Capabilities */
#define AHCI_REG_GHC			0x004 /* Global HBA Control */
#define AHCI_REG_IS			0x008 /* Interrupt Status */
#define AHCI_REG_PI			0x00c /* Ports Implemented */
#define AHCI_REG_VS			0x010 /* AHCI Version */
#define AHCI_REG_CCC_CTL		0x014 /* Coalescing Control */
#define AHCI_REG_CCC_PORTS		0x018 /* Coalescing Ports */
#define AHCI_REG_EM_LOC			0x01c /* Enclosure Mgmt Location */
#define AHCI_REG_EM_CTL			0x020 /* Enclosure Mgmt Control */
@


1.1
log
@the start of a driver for ahci controllers. this does nothing but map the
register space and hook an interrupt up for the controller i have, but it
is going into the tree so i can work on it.

commit early, commit often
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d34 10
@

