head	1.16;
access;
symbols
	OPENBSD_5_7:1.14.0.4
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.16
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.14
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.10
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.8
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.6
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.12.0.4
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.11.0.16
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.18
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.14
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.12
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.10
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.8
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.6
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.8.0.8
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.6
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.8
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.8
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.2
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.16
date	2015.04.09.18.58.22;	author deraadt;	state dead;
branches;
next	1.15;
commitid	cDamcqFPw3HffP51;

1.15
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.14;
commitid	p4LJxGKbi0BU2cG6;

1.14
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.13;
commitid	t9FBKDfc4VDxpEy2;

1.13
date	2011.07.06.02.42.28;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2005.11.07.00.29.21;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.05.11.49.01;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.12.06.35.11;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.02.22.50.00;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.12.20.33.50;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.09.13.13.43;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.01.18.01.41;	author chris;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.10.26.23.47.14;	author chris;	state Exp;
branches;
next	1.1;

1.1
date	99.07.01.23.10.40;	author deraadt;	state Exp;
branches;
next	;

1.3.2.1
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2004.06.05.23.12.50;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Send lmc(4) and san(4) to the HDLC framed bit bucket in the sky.
@
text
@/*	$OpenBSD: if_lmc_common.c,v 1.15 2015/03/14 03:38:48 jsg Exp $ */
/*	$NetBSD: if_lmc_common.c,v 1.1 1999/03/25 03:32:43 explorer Exp $	*/

/*-
 * Copyright (c) 1997-1999 LAN Media Corporation (LMC)
 * All rights reserved.  www.lanmedia.com
 *
 * This code is written by Michael Graff <graff@@vix.com> for LMC.
 * The code is derived from permitted modifications to software created
 * by Matt Thomas (matt@@3am-software.com).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following disclaimer
 *    in the documentation and/or other materials provided with the
 *    distribution.
 * 3. All marketing or advertising materials mentioning features or
 *    use of this software must display the following acknowledgement:
 *      This product includes software developed by LAN Media Corporation
 *      and its contributors.
 * 4. Neither the name of LAN Media Corporation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY LAN MEDIA CORPORATION AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1994-1997 Matt Thomas (matt@@3am-software.com)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_types.h>
#include <net/if_dl.h>
#include <net/netisr.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <net/if_sppp.h>

#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/ic/dc21040reg.h>

#define d_length1 u.bd_length1
#define d_length2 u.bd_length2
#define d_flag u.bd_flag

#include <dev/pci/if_lmc_types.h>
#include <dev/pci/if_lmcioctl.h>
#include <dev/pci/if_lmcvar.h>

void
lmc_gpio_mkinput(lmc_softc_t * const sc, u_int32_t bits)
{
	sc->lmc_gpio_io &= ~bits;
	LMC_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET | (sc->lmc_gpio_io));
}

void
lmc_gpio_mkoutput(lmc_softc_t * const sc, u_int32_t bits)
{
	sc->lmc_gpio_io |= bits;
	LMC_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET | (sc->lmc_gpio_io));
}

void
lmc_led_on(lmc_softc_t * const sc, u_int32_t led)
{
	sc->lmc_miireg16 &= ~led;
	lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);
}

void
lmc_led_off(lmc_softc_t * const sc, u_int32_t led)
{
	sc->lmc_miireg16 |= led;
	lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);
}

void
lmc_reset(lmc_softc_t * const sc)
{
	sc->lmc_miireg16 |= LMC_MII16_FIFO_RESET;
	lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);

	sc->lmc_miireg16 &= ~LMC_MII16_FIFO_RESET;
	lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);

	/*
	 * make some of the GPIO pins be outputs
	 */
	lmc_gpio_mkoutput(sc, LMC_GEP_DP | LMC_GEP_RESET);

	/*
	 * drive DP and RESET low to force configuration.  This also forces
	 * the transmitter clock to be internal, but we expect to reset
	 * that later anyway.
	 */
	sc->lmc_gpio &= ~(LMC_GEP_DP | LMC_GEP_RESET);
	LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);

	/*
	 * hold for more than 10 microseconds
	 */
	DELAY(50);

	/*
	 * stop driving Xilinx-related signals
	 */
	lmc_gpio_mkinput(sc, LMC_GEP_DP | LMC_GEP_RESET);

	/*
	 * busy wait for the chip to reset
	 */
	while ((LMC_CSR_READ(sc, csr_gp) & LMC_GEP_DP) == 0);

	/*
	 * Call media specific init routine
	 */
	sc->lmc_media->init(sc);
}

void
lmc_dec_reset(lmc_softc_t * const sc)
{
#ifndef __linux__
	lmc_ringinfo_t *ri;
	lmc_desc_t *di;
#endif
	u_int32_t val;

	/*
	 * disable all interrupts
	 */
	sc->lmc_intrmask = 0;
	LMC_CSR_WRITE(sc, csr_intr, sc->lmc_intrmask);

	/*
	 * we are, obviously, down.
	 */
#ifndef __linux__
	sc->lmc_flags &= ~(LMC_IFUP | LMC_MODEMOK);

	DP(("lmc_dec_reset\n"));
#endif

	/*
	 * Reset the chip with a software reset command.
	 * Wait 10 microseconds (actually 50 PCI cycles but at 
	 * 33MHz that comes to two microseconds but wait a
	 * bit longer anyways)
	 */
	LMC_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);
	DELAY(10);
	sc->lmc_cmdmode = LMC_CSR_READ(sc, csr_command);

	/*
	 * We want:
	 *   no ethernet address in frames we write
	 *   disable padding (txdesc, padding disable)
	 *   ignore runt frames (rdes0 bit 15)
	 *   no receiver watchdog or transmitter jabber timer
	 *       (csr15 bit 0,14 == 1)
	 *   if using 16-bit CRC, turn off CRC (trans desc, crc disable)
	 */

#ifndef TULIP_CMD_RECEIVEALL
#define TULIP_CMD_RECEIVEALL 0x40000000L
#endif

	sc->lmc_cmdmode |= ( TULIP_CMD_PROMISCUOUS
			       | TULIP_CMD_FULLDUPLEX
			       | TULIP_CMD_PASSBADPKT
			       | TULIP_CMD_NOHEARTBEAT
			       | TULIP_CMD_PORTSELECT
			       | TULIP_CMD_RECEIVEALL
			       | TULIP_CMD_MUSTBEONE
			       );
	sc->lmc_cmdmode &= ~( TULIP_CMD_OPERMODE
				| TULIP_CMD_THRESHOLDCTL
				| TULIP_CMD_STOREFWD
				| TULIP_CMD_TXTHRSHLDCTL
				);

	LMC_CSR_WRITE(sc, csr_command, sc->lmc_cmdmode);

	/*
	 * disable receiver watchdog and transmit jabber
	 */
	val = LMC_CSR_READ(sc, csr_sia_general);
	val |= (TULIP_WATCHDOG_TXDISABLE | TULIP_WATCHDOG_RXDISABLE);
	LMC_CSR_WRITE(sc, csr_sia_general, val);

	/*
	 * turn off those LEDs...
	 */
	sc->lmc_miireg16 |= LMC_MII16_LED_ALL;
	lmc_led_on(sc, LMC_MII16_LED0);

#ifndef __linux__
	/*
	 * reprogram the tx desc, rx desc, and PCI bus options
	 */
	LMC_CSR_WRITE(sc, csr_txlist, sc->lmc_txdescmap->dm_segs[0].ds_addr);
	LMC_CSR_WRITE(sc, csr_rxlist, sc->lmc_rxdescmap->dm_segs[0].ds_addr);
	LMC_CSR_WRITE(sc, csr_busmode,
		(1 << (LMC_BURSTSIZE(sc->lmc_unit) + 8))
		|TULIP_BUSMODE_CACHE_ALIGN8
		|TULIP_BUSMODE_READMULTIPLE);

	IFQ_SET_MAXLEN(&sc->lmc_txq, LMC_TXDESCS);

	/*
	 * Free all the mbufs that were on the transmit ring.
	 */
	for (;;) {
		bus_dmamap_t map;
		struct mbuf *m;

		IF_DEQUEUE(&sc->lmc_txq, m);
		if (m == NULL)
			break;
		map = LMC_GETCTX(m, bus_dmamap_t);
		bus_dmamap_unload(sc->lmc_dmatag, map);
		sc->lmc_txmaps[sc->lmc_txmaps_free++] = map;
		m_freem(m);
	}

	/*
	 * reset descriptor state and reclaim all descriptors.
	 */
	ri = &sc->lmc_txinfo;
	ri->ri_nextin = ri->ri_nextout = ri->ri_first;
	ri->ri_free = ri->ri_max;
	for (di = ri->ri_first; di < ri->ri_last; di++)
		di->d_status = 0;
	bus_dmamap_sync(sc->lmc_dmatag, sc->lmc_txdescmap,
		0, sc->lmc_txdescmap->dm_mapsize,
		BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

	/*
	 * We need to collect all the mbufs were on the 
	 * receive ring before we reinit it either to put
	 * them back on or to know if we have to allocate
	 * more.
	 */
	ri = &sc->lmc_rxinfo;
	ri->ri_nextin = ri->ri_nextout = ri->ri_first;
	ri->ri_free = ri->ri_max;
	for (di = ri->ri_first; di < ri->ri_last; di++) {
		u_int32_t ctl = di->d_ctl;
		di->d_status = 0;
		di->d_ctl = LMC_CTL(LMC_CTL_FLGS(ctl),0,0);
		di->d_addr1 = 0;
		di->d_addr2 = 0;
	}
	bus_dmamap_sync(sc->lmc_dmatag, sc->lmc_rxdescmap,
		0, sc->lmc_rxdescmap->dm_mapsize,
		BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	for (;;) {
		bus_dmamap_t map;
		struct mbuf *m;
		IF_DEQUEUE(&sc->lmc_rxq, m);
		if (m == NULL)
			break;
		map = LMC_GETCTX(m, bus_dmamap_t);
		bus_dmamap_unload(sc->lmc_dmatag, map);
		sc->lmc_rxmaps[sc->lmc_rxmaps_free++] = map;
		m_freem(m);
	}
#endif
}

void
lmc_initcsrs(lmc_softc_t * const sc, lmc_csrptr_t csr_base,
	     size_t csr_size)
{
	sc->lmc_csrs.csr_busmode	= csr_base +  0 * csr_size;
	sc->lmc_csrs.csr_txpoll		= csr_base +  1 * csr_size;
	sc->lmc_csrs.csr_rxpoll		= csr_base +  2 * csr_size;
	sc->lmc_csrs.csr_rxlist		= csr_base +  3 * csr_size;
	sc->lmc_csrs.csr_txlist		= csr_base +  4 * csr_size;
	sc->lmc_csrs.csr_status		= csr_base +  5 * csr_size;
	sc->lmc_csrs.csr_command	= csr_base +  6 * csr_size;
	sc->lmc_csrs.csr_intr		= csr_base +  7 * csr_size;
	sc->lmc_csrs.csr_missed_frames	= csr_base +  8 * csr_size;
	sc->lmc_csrs.csr_9		= csr_base +  9 * csr_size;
	sc->lmc_csrs.csr_10		= csr_base + 10 * csr_size;
	sc->lmc_csrs.csr_11		= csr_base + 11 * csr_size;
	sc->lmc_csrs.csr_12		= csr_base + 12 * csr_size;
	sc->lmc_csrs.csr_13		= csr_base + 13 * csr_size;
	sc->lmc_csrs.csr_14		= csr_base + 14 * csr_size;
	sc->lmc_csrs.csr_15		= csr_base + 15 * csr_size;
}
@


1.15
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_common.c,v 1.14 2014/12/05 15:50:04 mpi Exp $ */
@


1.14
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_common.c,v 1.13 2011/07/06 02:42:28 henning Exp $ */
a76 2

#include <dev/pci/pcidevs.h>
@


1.13
log
@cosnistently use IFQ_SET_MAXLEN, surfaced in a discussion with + ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_common.c,v 1.12 2010/04/08 00:23:53 tedu Exp $ */
d81 1
@


1.12
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_common.c,v 1.11 2005/11/07 00:29:21 brad Exp $ */
d264 1
a264 1
	sc->lmc_txq.ifq_maxlen = LMC_TXDESCS;
@


1.11
log
@first round of lmc(4) cleaning. removes a good portion of the ifdef
crud making this readable.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_common.c,v 1.10 2005/11/05 11:49:01 brad Exp $ */
a75 1
#include <sys/proc.h>	/* only for declaration of wakeup() used by vm.h */
@


1.10
log
@add bus_dma and big endian support.

From NetBSD

Thanks to Jason Ackley for testing on i386/amd64/sparc64
with both T1 and T3 cards.

"looks ok" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_common.c,v 1.9 2004/05/12 06:35:11 tedu Exp $ */
d66 2
a76 3
#if defined(__FreeBSD__)
#include <machine/clock.h>
#elif defined(__bsdi__) || defined(__NetBSD__) || defined(__OpenBSD__)
a77 9
#endif

#if defined(__NetBSD__)
#include <dev/pci/pcidevs.h>
#include "rnd.h"
#if NRND > 0
#include <sys/rnd.h>
#endif
#endif
a78 1
#if defined(__OpenBSD__)
a79 1
#endif
a85 1
#include "bpfilter.h"
a89 1
#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
a90 1
#endif
d92 1
a92 6
#if defined(__bsdi__)
#if INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#endif
a93 34
#include <net/netisr.h>
#include <net/if.h>
#include <net/netisr.h>
#include <net/if_types.h>
#include <net/if_p2p.h>
#include <net/if_c_hdlc.h>
#endif

#if defined(__FreeBSD__)
#include <vm/pmap.h>
#include <pci.h>
#if NPCI > 0
#include <pci/pcivar.h>
#include <pci/dc21040reg.h>
#define INCLUDE_PATH_PREFIX "pci/"
#endif
#endif /* __FreeBSD__ */

#if defined(__bsdi__)
#include <i386/pci/ic/dc21040.h>
#include <i386/isa/isa.h>
#include <i386/isa/icu.h>
#include <i386/isa/dma.h>
#include <i386/isa/isavar.h>
#include <i386/pci/pci.h>

#define	INCLUDE_PATH_PREFIX	"i386/pci/"
#endif /* __bsdi__ */

#if defined(__NetBSD__) || defined(__OpenBSD__)
#include <machine/bus.h>
#if defined(__alpha__) && defined(__NetBSD__)
#include <machine/intr.h>
#endif
a96 2
#define	INCLUDE_PATH_PREFIX	"dev/pci/"
#endif /* __NetBSD__ */
a97 1
#if defined(__OpenBSD__)
a100 1
#endif
a101 9
/*
 * Sigh.  Every OS puts these in different places.  NetBSD and FreeBSD use
 * a C preprocessor that allows this hack, but BSDI does not.
 */
#if defined(__NetBSD__) || defined(__FreeBSD__)
#include INCLUDE_PATH_PREFIX "if_lmc_types.h"
#include INCLUDE_PATH_PREFIX "if_lmcioctl.h"
#include INCLUDE_PATH_PREFIX "if_lmcvar.h"
#elif defined(__OpenBSD__)
a104 5
#else /* BSDI */
#include "i386/pci/if_lmc_types.h"
#include "i386/pci/if_lmcioctl.h"
#include "i386/pci/if_lmcvar.h"
#endif
@


1.9
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_common.c,v 1.8 2002/06/02 22:50:00 deraadt Exp $ */
a102 2
#include <uvm/uvm_extern.h>

d254 1
a254 1
	tulip_desc_t *di;
d330 2
a331 4
	LMC_CSR_WRITE(sc, csr_txlist,
			LMC_KVATOPHYS(sc, &sc->lmc_txinfo.ri_first[0]));
	LMC_CSR_WRITE(sc, csr_rxlist,
			LMC_KVATOPHYS(sc, &sc->lmc_rxinfo.ri_first[0]));
d333 3
a335 4
			(1 << (LMC_BURSTSIZE(sc->lmc_unit) + 8))
			|TULIP_BUSMODE_CACHE_ALIGN8
			|TULIP_BUSMODE_READMULTIPLE
			|(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_BIGENDIAN : 0));
d343 1
d349 3
d363 3
d377 1
d379 3
a381 2
		di->d_length1 = 0; di->d_addr1 = 0;
		di->d_length2 = 0; di->d_addr2 = 0;
d383 3
d387 1
d392 3
@


1.8
log
@withough -> without
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_common.c,v 1.7 2001/11/06 19:53:19 miod Exp $ */
a100 1
#include <net/bpfdesc.h>
@


1.7
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_common.c,v 1.6 2001/09/11 20:05:25 miod Exp $ */
d52 1
a52 1
 *    derived from this software withough specific prior written permission
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_common.c,v 1.7 2001/11/06 19:53:19 miod Exp $ */
d52 1
a52 1
 *    derived from this software without specific prior written permission
@


1.6
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_common.c,v 1.5 2001/08/12 20:33:50 mickey Exp $ */
d104 1
a104 1
#include <vm/vm.h>
@


1.5
log
@absolutely no need to include vm_parm.h after vm.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_common.c,v 1.4 2001/07/09 13:13:43 espie Exp $ */
a104 1
#include <vm/vm_kern.h>
@


1.4
log
@Remove dubious #include MACRO "string" construct (non-ANSI)
and use the more correct #include <file.h> style.

From discussion with millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_common.c,v 1.3 2000/02/01 18:01:41 chris Exp $ */
a104 1
#include <vm/vm_param.h>
@


1.3
log
@general cleanup (remove LMC_IOMAPPED crud entirely)
add correct rcs tags
sync w/lmc's lmc_media.c regarding watchdog support
(So, the LEDs on the T1/T3 cards [the ones with built-in CSU/DSUs], and also
the DS1 "SSI" card should now change according to various line conditions, as
ths manual says they do)
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d169 1
a169 1
#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)
d173 4
@


1.3.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_common.c,v 1.3 2000/02/01 18:01:41 chris Exp $ */
d105 2
d169 1
a169 1
#if defined(__NetBSD__) || defined(__FreeBSD__)
a172 4
#elif defined(__OpenBSD__)
#include <dev/pci/if_lmc_types.h>
#include <dev/pci/if_lmcioctl.h>
#include <dev/pci/if_lmcvar.h>
@


1.3.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d104 1
a104 1
#include <uvm/uvm_extern.h>
@


1.3.2.3
log
@Sync the SMP branch with 3.3
@
text
@d52 1
a52 1
 *    derived from this software without specific prior written permission
@


1.3.2.4
log
@Merge with the trunk
@
text
@d101 1
@


1.2
log
@Support LMC1200
Based on LMC's Linux code
@
text
@d1 1
@


1.1
log
@lmc driver; ported by chris@@dqc.org
@
text
@d241 1
a241 2
	while ((LMC_CSR_READ(sc, csr_gp) & LMC_GEP_DP) == 0)
		;
@

