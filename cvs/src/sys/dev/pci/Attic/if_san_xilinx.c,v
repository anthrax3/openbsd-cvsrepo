head	1.34;
access;
symbols
	OPENBSD_5_7:1.32.0.4
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.4
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.26.0.4
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.2
	OPENBSD_5_0:1.25.0.2
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.24.0.10
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.8
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.4
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.21.0.4
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.18.0.6
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.34
date	2015.04.09.18.58.22;	author deraadt;	state dead;
branches;
next	1.33;
commitid	cDamcqFPw3HffP51;

1.33
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.32;
commitid	p4LJxGKbi0BU2cG6;

1.32
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.31;
commitid	t9FBKDfc4VDxpEy2;

1.31
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.30;
commitid	uzzBR7hz9ncd4O6G;

1.30
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.29;
commitid	TGHgrLxu6sxZoiFt;

1.29
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.28;
commitid	OBNa5kfxQ2UXoiIw;

1.28
date	2013.08.07.01.06.37;	author bluhm;	state Exp;
branches;
next	1.27;

1.27
date	2012.09.19.22.37.23;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2011.09.18.11.17.57;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.07.19.09.10;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2008.11.26.18.01.43;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2008.09.18.15.16.30;	author naddy;	state Exp;
branches;
next	1.22;

1.22
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.08.04.15.15;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.12.13.56.40;	author chl;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.20.20.31.12;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.13.05.56.22;	author canacar;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.08.20.51.00;	author canacar;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.08.20.23.42;	author canacar;	state Exp;
branches;
next	1.14;

1.14
date	2005.09.17.15.10.31;	author canacar;	state Exp;
branches;
next	1.13;

1.13
date	2005.09.14.05.08.05;	author canacar;	state Exp;
branches;
next	1.12;

1.12
date	2005.09.04.18.27.28;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.01.23.35.42;	author canacar;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.25.17.55.51;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.05.20.11.10;	author canacar;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.01.21.42.36;	author canacar;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.01.18.37.07;	author mcbride;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.07.06.10.24;	author mcbride;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.10.10.14.47;	author grange;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.16.15.11.45;	author alex;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.28.01.16.30;	author mcbride;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.26.20.17.23;	author mcbride;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.26.06.42.33;	author alex;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Send lmc(4) and san(4) to the HDLC framed bit bucket in the sky.
@
text
@/*	$OpenBSD: if_san_xilinx.c,v 1.33 2015/03/14 03:38:48 jsg Exp $	*/

/*-
 * Copyright (c) 2001-2004 Sangoma Technologies (SAN)
 * All rights reserved.  www.sangoma.com
 *
 * This code is written by Nenad Corbic <ncorbic@@sangoma.com> and
 * Alex Feldman <al.feldman@@sangoma.com> for SAN.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following disclaimer
 *    in the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name of Sangoma Technologies nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY SANGOMA TECHNOLOGIES AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/syslog.h>
#include <sys/ioccom.h>
#include <sys/malloc.h>
#include <sys/errno.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/kernel.h>
#include <sys/time.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_media.h>
#include <netinet/in.h>
#include <netinet/udp.h>
#include <netinet/ip.h>
#include <net/if_sppp.h>

#include <machine/bus.h>

#include <dev/pci/if_san_common.h>
#include <dev/pci/if_san_obsd.h>
#include <dev/pci/if_san_xilinx.h>


/* Private critical flags */
enum {
	POLL_CRIT = PRIV_CRIT,
	TX_BUSY,
	RX_BUSY,
	TASK_POLL,
	CARD_DOWN
};

enum {
	LINK_DOWN,
	DEVICE_DOWN
};

#define MAX_IP_ERRORS	10

#define PORT(x)   (x == 0 ? "PRIMARY" : "SECONDARY" )
#define MAX_TX_BUF	10
#define MAX_RX_BUF	10

#undef DEB_XILINX

#if 1
# define TRUE_FIFO_SIZE 1
#else
# undef  TRUE_FIFO_SIZE
# define HARD_FIFO_CODE 0x01
#endif

static int aft_rx_copyback = MHLEN;


struct xilinx_rx_buffer {
	SIMPLEQ_ENTRY(xilinx_rx_buffer) entry;
	struct mbuf *mbuf;
	bus_dmamap_t dma_map;
	wp_rx_element_t rx_el;
};

SIMPLEQ_HEAD(xilinx_rx_head, xilinx_rx_buffer);

/*
 * This structure is placed in the private data area of the device structure.
 * The card structure used to occupy the private area but now the following
 * structure will incorporate the card structure along with Protocol specific
 * data
 */
typedef struct {
	wanpipe_common_t	common;

	struct ifqueue	wp_tx_pending_list;
	struct ifqueue	wp_tx_complete_list;
	struct xilinx_rx_head	wp_rx_free_list;
	struct xilinx_rx_head	wp_rx_complete_list;
	struct xilinx_rx_buffer *wp_rx_buffers;
	struct xilinx_rx_buffer *wp_rx_buffer_last;
	struct xilinx_rx_buffer	*rx_dma_buf;

	bus_dma_tag_t	dmatag;
	bus_dmamap_t	tx_dmamap;
	struct mbuf	*tx_dma_mbuf;
	u_int8_t	tx_dma_cnt;

	unsigned long	time_slot_map;
	unsigned char	num_of_time_slots;
	long		logic_ch_num;

	unsigned char	dma_status;
	unsigned char	ignore_modem;
	struct ifqueue	udp_queue;

	unsigned long	router_start_time;

	unsigned long	tick_counter;		/* For 5s timeout counter */
	unsigned long	router_up_time;

	unsigned char	mc;			/* Mulitcast support on/off */
	unsigned char	udp_pkt_src;		/* udp packet processing */
	unsigned short	timer_int_enabled;

	unsigned char	interface_down;

	u_int8_t	gateway;
	u_int8_t	true_if_encoding;

	char		if_name[IFNAMSIZ+1];

	u_int8_t	idle_flag;
	u_int16_t	max_idle_size;
	u_int8_t	idle_start;

	u_int8_t	pkt_error;
	u_int8_t	rx_fifo_err_cnt;

	int		first_time_slot;

	unsigned long	tx_dma_addr;
	unsigned int	tx_dma_len;
	unsigned char	rx_dma;
	unsigned char   pci_retry;

	unsigned char	fifo_size_code;
	unsigned char	fifo_base_addr;
	unsigned char	fifo_size;

	int		dma_mtu;

	void		*prot_ch;
	wan_trace_t	trace_info;
}xilinx_softc_t;
#define WAN_IFP_TO_SOFTC(ifp)	(xilinx_softc_t *)((ifp)->if_softc)

/* Route Status options */
#define NO_ROUTE	0x00
#define ADD_ROUTE	0x01
#define ROUTE_ADDED	0x02
#define REMOVE_ROUTE	0x03

#define WP_WAIT		0
#define WP_NO_WAIT	1

/* variable for keeping track of enabling/disabling FT1 monitor status */
/* static int rCount; */

extern void disable_irq(unsigned int);
extern void enable_irq(unsigned int);

extern int ticks;

/**SECTOIN**************************************************
 *
 * Function Prototypes
 *
 ***********************************************************/

/* WAN link driver entry points. These are called by the WAN router module. */
static int	wan_xilinx_release(sdla_t*, struct ifnet *);

/* Network device interface */
static int	wan_xilinx_up(struct ifnet *);
static int	wan_xilinx_down(struct ifnet *);
static int	wan_xilinx_ioctl(struct ifnet *, u_long cmd, struct ifreq *);
static int	wan_xilinx_send(struct mbuf *, struct ifnet *);

static void	handle_front_end_state(void *);
static void	enable_timer(void *);

/* Miscellaneous Functions */
static void	port_set_state (sdla_t *, int);

/* Interrupt handlers */
static void	wp_xilinx_isr (sdla_t *);

/* Miscellaneous functions */
static int	process_udp_mgmt_pkt(sdla_t *, struct ifnet *,
		    xilinx_softc_t *, int);
/* Bottom half handlers */
static void	xilinx_process_packet(xilinx_softc_t *);

static int	xilinx_chip_configure(sdla_t *);
static int	xilinx_chip_unconfigure(sdla_t *);
static int	xilinx_dev_configure(sdla_t *, xilinx_softc_t *);
static void	xilinx_dev_unconfigure(sdla_t *, xilinx_softc_t *);
static int	xilinx_dma_rx(sdla_t *, xilinx_softc_t *);
static void	xilinx_dev_enable(sdla_t *, xilinx_softc_t *);
static void	xilinx_dev_close(sdla_t *, xilinx_softc_t *);
static int	xilinx_dma_tx (sdla_t *, xilinx_softc_t *);
static void	xilinx_dma_tx_complete (sdla_t *, xilinx_softc_t *);
static void	xilinx_dma_rx_complete (sdla_t *, xilinx_softc_t *);
static void	xilinx_dma_max_logic_ch(sdla_t *);
static int	xilinx_init_rx_dev_fifo(sdla_t *, xilinx_softc_t *,
		    unsigned char);
static void	xilinx_init_tx_dma_descr(sdla_t *, xilinx_softc_t *);
static int	xilinx_init_tx_dev_fifo(sdla_t *, xilinx_softc_t *,
		    unsigned char);
static void	xilinx_tx_post_complete(sdla_t *, xilinx_softc_t *,
		    struct mbuf *);
static void	xilinx_rx_post_complete(sdla_t *, xilinx_softc_t *,
		    struct xilinx_rx_buffer *, struct mbuf **, u_char *);


static char	request_xilinx_logical_channel_num(sdla_t *, xilinx_softc_t *,
		    long *);
static void	free_xilinx_logical_channel_num (sdla_t *, int);


static unsigned char read_cpld(sdla_t *, unsigned short);
static unsigned char write_cpld(sdla_t *, unsigned short, unsigned char);

static void	front_end_interrupt(sdla_t *, unsigned long);
static void	enable_data_error_intr(sdla_t *);
static void	disable_data_error_intr(sdla_t *, unsigned char);

static void	xilinx_tx_fifo_under_recover(sdla_t *, xilinx_softc_t *);

static int	xilinx_write_ctrl_hdlc(sdla_t *, u_int32_t,
		    u_int8_t, u_int32_t);

static int	set_chan_state(sdla_t*, struct ifnet*, int);

static int	fifo_error_interrupt(sdla_t *, unsigned long);
static int	request_fifo_baddr_and_size(sdla_t *, xilinx_softc_t *);
static int	map_fifo_baddr_and_size(sdla_t *,
		    unsigned char, unsigned char *);
static int	free_fifo_baddr_and_size(sdla_t *, xilinx_softc_t *);

static void	aft_red_led_ctrl(sdla_t *, int);
static void	aft_led_timer(void *);

static int	aft_core_ready(sdla_t *);
static int	aft_alloc_rx_buffers(xilinx_softc_t *);
static void	aft_release_rx_buffers(xilinx_softc_t *);
static int	aft_alloc_rx_dma_buff(xilinx_softc_t *, int);
static void	aft_reload_rx_dma_buff(xilinx_softc_t *,
		    struct xilinx_rx_buffer *);
static void	aft_release_rx_dma_buff(xilinx_softc_t *,
		    struct xilinx_rx_buffer *);


/* TE1 Control registers  */
static WRITE_FRONT_END_REG_T write_front_end_reg;
static READ_FRONT_END_REG_T  read_front_end_reg;

static void	wan_ifmedia_sts(struct ifnet *, struct ifmediareq *);
static int	wan_ifmedia_upd(struct ifnet *);

static void
xilinx_delay(int sec)
{
#if 0
	unsigned long timeout = ticks;
	while ((ticks - timeout) < (sec * hz)) {
		schedule();
	}
#endif
}

void *
wan_xilinx_init(sdla_t *card)
{
	xilinx_softc_t	*sc;
	struct ifnet	*ifp;

	/* Verify configuration ID */
	bit_clear((u_int8_t *)&card->critical, CARD_DOWN);

	card->u.xilinx.num_of_ch = 0;
	card->u.xilinx.mru_trans = 1500;
	card->u.xilinx.dma_per_ch = 10;

	/* TE1 Make special hardware initialization for T1/E1 board */

	if (IS_TE1(&card->fe_te.te_cfg)) {
		card->write_front_end_reg = write_front_end_reg;
		card->read_front_end_reg = read_front_end_reg;
		card->te_enable_timer = enable_timer;
		card->te_link_state = handle_front_end_state;
	} else
		card->front_end_status = FE_CONNECTED;

	/* WARNING: After this point the init function
	 * must return with 0.  The following bind
	 * functions will cause problems if structures
	 * below are not initialized */

	card->del_if	 = &wan_xilinx_release;
	card->iface_up   = &wan_xilinx_up;
	card->iface_down = &wan_xilinx_down;
	card->iface_send = &wan_xilinx_send;
	card->iface_ioctl= &wan_xilinx_ioctl;

	write_cpld(card, LED_CONTROL_REG, 0x0E);

	sdla_getcfg(card->hw, SDLA_BASEADDR, &card->u.xilinx.bar);

	xilinx_delay(1);

	timeout_set(&card->u.xilinx.led_timer, aft_led_timer, (void *)card);

	/* allocate and initialize private data */
	sc = malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sc == NULL)
		return (NULL);

	ifp = (struct ifnet *)&sc->common.ifp;
	ifp->if_softc = sc;
	sc->common.card	= card;
	if (wanpipe_generic_register(card, ifp, card->devname)) {
		free(sc, M_DEVBUF, 0);
		return (NULL);
	}

	strlcpy(sc->if_name, ifp->if_xname, IFNAMSIZ);
	sc->first_time_slot = -1;
	sc->time_slot_map = 0;
	sdla_getcfg(card->hw, SDLA_DMATAG, &sc->dmatag);

	IFQ_SET_MAXLEN(&sc->wp_tx_pending_list, MAX_TX_BUF);
	IFQ_SET_MAXLEN(&sc->wp_tx_complete_list, MAX_TX_BUF);

	aft_alloc_rx_buffers(sc);

	xilinx_delay(1);

	ifmedia_init(&sc->common.ifm, 0, wan_ifmedia_upd, wan_ifmedia_sts);

	if (IS_TE1(&card->fe_te.te_cfg)) {
		ifmedia_add(&sc->common.ifm, IFM_TDM|IFM_TDM_T1, 0, NULL);
		ifmedia_add(&sc->common.ifm, IFM_TDM|IFM_TDM_T1_AMI, 0, NULL);
		ifmedia_add(&sc->common.ifm, IFM_TDM|IFM_TDM_E1, 0, NULL);
		ifmedia_add(&sc->common.ifm, IFM_TDM|IFM_TDM_E1_AMI, 0, NULL);

		ifmedia_add(&sc->common.ifm,
		    IFM_TDM|IFM_TDM_T1|IFM_TDM_PPP, 0, NULL);
		ifmedia_add(&sc->common.ifm,
		    IFM_TDM|IFM_TDM_T1_AMI|IFM_TDM_PPP, 0, NULL);
		ifmedia_add(&sc->common.ifm,
		    IFM_TDM|IFM_TDM_E1|IFM_TDM_PPP, 0, NULL);
		ifmedia_add(&sc->common.ifm,
		    IFM_TDM|IFM_TDM_E1_AMI|IFM_TDM_PPP, 0, NULL);

		ifmedia_set(&sc->common.ifm, IFM_TDM|IFM_TDM_T1);
	} else {
		/* Currently we not support ifmedia types for other
		 * front end types.
		 */
	}

	return (sc);
}

static int
wan_xilinx_release(sdla_t* card, struct ifnet* ifp)
{
	xilinx_softc_t *sc = ifp->if_softc;

	IF_PURGE(&sc->wp_tx_pending_list);

	if (sc->tx_dma_addr && sc->tx_dma_len) {
		sc->tx_dma_addr = 0;
		sc->tx_dma_len = 0;
	}

	if (sc->tx_dma_mbuf) {
		log(LOG_INFO, "freeing tx dma mbuf\n");
		bus_dmamap_unload(sc->dmatag, sc->tx_dmamap);
		m_freem(sc->tx_dma_mbuf);
		sc->tx_dma_mbuf = NULL;
	}

#if 0
	bus_dmamap_destroy(sc->dmatag, sc->tx_dmamap);
#endif
	if (sc->rx_dma_buf) {
		SIMPLEQ_INSERT_TAIL(&sc->wp_rx_free_list,
		    sc->rx_dma_buf, entry);
		sc->rx_dma_buf = NULL;
	}

	aft_release_rx_buffers(sc);

	wanpipe_generic_unregister(ifp);
	ifp->if_softc = NULL;
	free(sc, M_DEVBUF, 0);

	return (0);
}

static void
wan_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmreq)
{
	wanpipe_common_t	*common = (wanpipe_common_t *)ifp->if_softc;
	struct ifmedia		*ifm;

	WAN_ASSERT1(common == NULL);
	ifm = &common->ifm;
	ifmreq->ifm_active = ifm->ifm_cur->ifm_media;
}

static int
wan_ifmedia_upd(struct ifnet *ifp)
{
	wanpipe_common_t	*common = (wanpipe_common_t *)ifp->if_softc;
	sdla_t			*card;

	WAN_ASSERT(common == NULL);
	WAN_ASSERT(common->card == NULL);
	card = (sdla_t *)common->card;

	if (IS_TE1(&card->fe_te.te_cfg))
		return (sdla_te_setcfg(ifp, &common->ifm));

	return (EINVAL);
}


/*
 * KERNEL Device Entry Interfaces
 */

static int
wan_xilinx_up(struct ifnet *ifp)
{
	xilinx_softc_t	*sc = ifp->if_softc;
	sdla_t		*card = NULL;
	struct timeval	 tv;
	int		 err = 0;

	WAN_ASSERT(sc == NULL);
	WAN_ASSERT(sc->common.card == NULL);
	card = (sdla_t *)sc->common.card;

	if (card->state != WAN_DISCONNECTED)
		return (0);

	sc->time_slot_map = card->fe_te.te_cfg.active_ch;
	sc->dma_mtu = xilinx_valid_mtu(ifp->if_mtu+100);

	if (!sc->dma_mtu) {
		log(LOG_INFO, "%s:%s: Error invalid MTU %u\n",
		    card->devname, sc->if_name, ifp->if_mtu);
		return (EINVAL);
	}

#ifdef DEBUG_INIT
	log(LOG_INFO, "%s: Allocating %d dma mbuf len=%d\n",
	    card->devname, card->u.xilinx.dma_per_ch, sc->dma_mtu);
#endif
	if (aft_alloc_rx_dma_buff(sc, card->u.xilinx.dma_per_ch) == 0)
		return (ENOMEM);

	if (bus_dmamap_create(sc->dmatag, sc->dma_mtu, 1, sc->dma_mtu,
	      0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &sc->tx_dmamap)) {
		log(LOG_INFO, "%s: Failed to allocate tx dmamap\n",
		    sc->if_name);
		return (ENOMEM);
	}

	err = xilinx_chip_configure(card);
	if (err)
		return (EINVAL);

	card->isr = &wp_xilinx_isr;

	err = xilinx_dev_configure(card, sc);
	if (err) {
		xilinx_chip_unconfigure(card);
		return (EINVAL);
	}
	xilinx_delay(1);

	/* Initialize the router start time.
	 * Used by wanpipemon debugger to indicate
	 * how long has	the interface been up */
	microtime(&tv);
	sc->router_start_time = tv.tv_sec;

	xilinx_init_tx_dma_descr(card, sc);
	xilinx_dev_enable(card, sc);

	sc->ignore_modem = 0x0F;
	bit_clear((u_int8_t *)&card->critical, CARD_DOWN);
	port_set_state(card, WAN_CONNECTING);

	return (err);
}

static int
wan_xilinx_down(struct ifnet *ifp)
{
	xilinx_softc_t	*sc = ifp->if_softc;
	sdla_t		*card = (sdla_t *)sc->common.card;
	struct xilinx_rx_buffer *buf;
	int		s;

	if (card->state == WAN_DISCONNECTED)
		return (0);

	xilinx_dev_close(card, sc);

	/* Disable DMA ENGINE before we perform
	 * core reset.  Otherwise, we will receive
	 * rx fifo errors on subsequent resetart. */
	disable_data_error_intr(card, DEVICE_DOWN);

	bit_set((u_int8_t *)&card->critical, CARD_DOWN);

	timeout_del(&card->u.xilinx.led_timer);

	/* TE1 - Unconfiging, only on shutdown */
	if (IS_TE1(&card->fe_te.te_cfg))
		sdla_te_unconfig(card);

	s = splnet();

	card->isr = NULL;

	if (sc->tx_dma_addr && sc->tx_dma_len) {
		sc->tx_dma_addr = 0;
		sc->tx_dma_len = 0;
	}

	if (sc->tx_dma_mbuf) {
		bus_dmamap_unload(sc->dmatag, sc->tx_dmamap);
		m_freem(sc->tx_dma_mbuf);
		sc->tx_dma_mbuf = NULL;
	}

	bus_dmamap_destroy(sc->dmatag, sc->tx_dmamap);

	/* If there is something left in rx_dma_buf, then move it to
	 * rx_free_list.
	 */
	if (sc->rx_dma_buf) {
		aft_reload_rx_dma_buff(sc, sc->rx_dma_buf);
		sc->rx_dma_buf = NULL;
	}

	while ((buf = SIMPLEQ_FIRST(&sc->wp_rx_free_list)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&sc->wp_rx_free_list, entry);
		aft_release_rx_dma_buff(sc, buf);
	}

	while ((buf = SIMPLEQ_FIRST(&sc->wp_rx_complete_list)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&sc->wp_rx_complete_list, entry);
		aft_release_rx_dma_buff(sc, buf);		
	}

	splx(s);

	DELAY(10);

	xilinx_dev_unconfigure(card, sc);
	xilinx_chip_unconfigure(card);

	port_set_state(card, WAN_DISCONNECTED);
	sc->ignore_modem = 0x00;
	return (0);
}

static int
wan_xilinx_send(struct mbuf* m, struct ifnet* ifp)
{

	xilinx_softc_t *sc = ifp->if_softc;
	sdla_t *card = (sdla_t *)sc->common.card;

	/* Mark interface as busy. The kernel will not
	 * attempt to send any more packets until we clear
	 * this condition */

	if (m == NULL)
		/* This should never happen. Just a sanity check.
		 */
		return (EINVAL);

	if (card->state != WAN_CONNECTED) {
		/*
		 * The card is still not ready to transmit...
		 * drop this packet!
		 */
		m_freem(m);
		return (EINVAL);

	} else {
		if (IF_QFULL(&sc->wp_tx_pending_list)) {
			int err;
#ifdef DEBUG_TX
			log(LOG_INFO, "%s: Tx pending queue FULL\n",
				ifp->if_xname);
#endif
			/*
			 * TX pending queue is full. Try to send packet
			 * from tx_pending queue (first)
			 */
			err = xilinx_dma_tx(card, sc);
			if (!err && !IF_QFULL(&sc->wp_tx_pending_list))
				/*
				 * On success, we have place for the new
				 * tx packet, try to send it now!
				 */
				goto wan_xilinx_dma_tx_try;

			/*
			 * Tx pedning queue is full. I can't accept new
			 * tx packet, drop this packet and set interface
			 * queue to OACTIVE
			 */
			m_freem(m);
			ifp->if_flags |= IFF_OACTIVE;

			return (EBUSY);
		} else {
wan_xilinx_dma_tx_try:
			IF_ENQUEUE(&sc->wp_tx_pending_list, m);
			xilinx_dma_tx(card, sc);
		}
	}

	return (0);
}

static int
wan_xilinx_ioctl(struct ifnet *ifp, u_long cmd, struct ifreq *ifr)
{
	xilinx_softc_t	*sc = (xilinx_softc_t *)ifp->if_softc;
	struct mbuf	*m;
	sdla_t		*card;
	wan_udp_pkt_t	*wan_udp_pkt;
	int err = 0;

	if (!sc)
		return (ENODEV);

	card = (sdla_t *)sc->common.card;

	switch (cmd) {
	case SIOC_WANPIPE_PIPEMON:

		if ((err = suser(curproc, 0)) != 0)
			break;

		if (IF_QFULL(&sc->udp_queue))
			return (EBUSY);

		/*
		 * For performance reasons test the critical
		 * here before spin lock
		 */
		if (bit_test((u_int8_t *)&card->in_isr, 0))
			return (EBUSY);

		m = wan_mbuf_alloc(sizeof(wan_udp_pkt_t));
		if (m == NULL)
			return (ENOMEM);

		wan_udp_pkt = mtod(m, wan_udp_pkt_t *);
		if (copyin(ifr->ifr_data, &wan_udp_pkt->wan_udp_hdr,
		    sizeof(wan_udp_hdr_t))) {
			m_freem(m);
			return (EFAULT);
		}
		IF_ENQUEUE(&sc->udp_queue, m);

		process_udp_mgmt_pkt(card, ifp, sc, 1);

		if (copyout(&wan_udp_pkt->wan_udp_hdr, ifr->ifr_data,
		    sizeof(wan_udp_hdr_t))) {
			m_freem(m);
			return (EFAULT);
		}

		IF_DEQUEUE(&sc->udp_queue, m);
		m_freem(m);
		return (0);

	default:
		if (card->ioctl)
			err = card->ioctl(ifp, cmd, ifr);
		break;
	}

	return (err);
}

/*
 * Process all "wanpipemon" debugger commands.  This function
 * performs all debugging tasks:
 *
 *	Line Tracing
 *	Line/Hardware Statistics
 *	Protocol Statistics
 *
 * "wanpipemon" utility is a user-space program that
 * is used to debug the WANPIPE product.
 */
static int
process_udp_mgmt_pkt(sdla_t* card, struct ifnet* ifp,
    xilinx_softc_t* sc, int local_dev )
{
	struct mbuf	*m;
	unsigned short	 buffer_length;
	wan_udp_pkt_t	*wan_udp_pkt;
	wan_trace_t	*trace_info = NULL;
	struct timeval	 tv;

	IF_POLL(&sc->udp_queue, m);
	if (m == NULL)
		return (EINVAL);

	wan_udp_pkt = mtod(m, wan_udp_pkt_t *);
	trace_info=&sc->trace_info;

	{
		struct mbuf *m0;

		wan_udp_pkt->wan_udp_opp_flag = 0;

		switch (wan_udp_pkt->wan_udp_command) {

		case READ_CONFIGURATION:
		case READ_CODE_VERSION:
			wan_udp_pkt->wan_udp_return_code = 0;
			wan_udp_pkt->wan_udp_data_len = 0;
			break;


		case ENABLE_TRACING:

			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			wan_udp_pkt->wan_udp_data_len = 0;

			if (!bit_test((u_int8_t *)
			    &trace_info->tracing_enabled, 0)) {

				trace_info->trace_timeout = ticks;

				IF_PURGE(&trace_info->ifq);
				if (wan_udp_pkt->wan_udp_data[0] == 0) {
					bit_clear((u_int8_t *)
					    &trace_info->tracing_enabled, 1);
					log(LOG_INFO, "%s: ADSL L3 "
					    "trace enabled!\n", card->devname);
				} else if (wan_udp_pkt->wan_udp_data[0] == 1) {
					bit_clear((u_int8_t *)
					    &trace_info->tracing_enabled, 2 );
					bit_set((u_int8_t *)
					    &trace_info->tracing_enabled, 1);
					log(LOG_INFO, "%s: ADSL L2 "
					    "trace enabled!\n", card->devname);
				} else {
					bit_clear((u_int8_t *)
					    &trace_info->tracing_enabled, 1);
					bit_set((u_int8_t *)
					    &trace_info->tracing_enabled, 2);
					log(LOG_INFO, "%s: ADSL L1 "
					    "trace enabled!\n", card->devname);
				}
				bit_set((u_int8_t *)&
				    trace_info->tracing_enabled, 0);

			} else {
				log(LOG_INFO, "%s: Error: AFT "
				    "trace running!\n", card->devname);
				wan_udp_pkt->wan_udp_return_code = 2;
			}

			break;

		case DISABLE_TRACING:
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;

			if (bit_test((u_int8_t *)
			    &trace_info->tracing_enabled, 0)) {
				bit_clear((u_int8_t *)
				    &trace_info->tracing_enabled, 0);
				bit_clear((u_int8_t *)
				    &trace_info->tracing_enabled, 1);
				bit_clear((u_int8_t *)
				    &trace_info->tracing_enabled, 2);
				IF_PURGE(&trace_info->ifq);
				log(LOG_INFO, "%s: Disabling ADSL trace\n",
				    card->devname);
			} else {
				/*
				 * set return code to line trace already
				 * disabled
				 */
				wan_udp_pkt->wan_udp_return_code = 1;
			}

			break;

		case GET_TRACE_INFO:
			if (bit_test((u_int8_t *)
			    &trace_info->tracing_enabled, 0)) {
				trace_info->trace_timeout = ticks;
			} else {
				log(LOG_INFO, "%s: Error AFT trace "
				    "not enabled\n", card->devname);
				/* set return code */
				wan_udp_pkt->wan_udp_return_code = 1;
				break;
			}

			buffer_length = 0;
			wan_udp_pkt->wan_udp_aft_num_frames = 0;
			wan_udp_pkt->wan_udp_aft_ismoredata = 0;

			while (!IF_IS_EMPTY(&trace_info->ifq)) {
				IF_POLL(&trace_info->ifq, m0);
				if (m0 == NULL) {
					log(LOG_INFO, "%s: No more "
					    "trace packets in trace queue!\n",
					    card->devname);
					break;
				}
				if ((WAN_MAX_DATA_SIZE - buffer_length) <
				    m0->m_pkthdr.len) {
					/*
					 * indicate there are more frames
					 * on board & exit
					 */
					wan_udp_pkt->wan_udp_aft_ismoredata
								= 0x01;
					break;
				}

				m_copydata(m0, 0, m0->m_pkthdr.len,
				    &wan_udp_pkt->wan_udp_data[buffer_length]);
				buffer_length += m0->m_pkthdr.len;
				IF_DEQUEUE(&trace_info->ifq, m0);
				if (m0)
					m_freem(m0);
				wan_udp_pkt->wan_udp_aft_num_frames++;
			}
			/* set the data length and return code */
			wan_udp_pkt->wan_udp_data_len = buffer_length;
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			break;

		case ROUTER_UP_TIME:
			microtime(&tv);
			sc->router_up_time = tv.tv_sec;
			sc->router_up_time -= sc->router_start_time;
			*(unsigned long *)&wan_udp_pkt->wan_udp_data =
					sc->router_up_time;
			wan_udp_pkt->wan_udp_data_len = sizeof(unsigned long);
			wan_udp_pkt->wan_udp_return_code = 0;
			break;

		case WAN_GET_MEDIA_TYPE:
		case WAN_FE_GET_STAT:
		case WAN_FE_SET_LB_MODE:
		case WAN_FE_FLUSH_PMON:
		case WAN_FE_GET_CFG:

			if (IS_TE1(&card->fe_te.te_cfg)) {
				sdla_te_udp(card,
				    &wan_udp_pkt->wan_udp_cmd,
				    &wan_udp_pkt->wan_udp_data[0]);
			} else {
				if (wan_udp_pkt->wan_udp_command ==
				    WAN_GET_MEDIA_TYPE) {
					wan_udp_pkt->wan_udp_data_len =
					    sizeof(unsigned char);
					wan_udp_pkt->wan_udp_return_code =
					    WAN_CMD_OK;
				} else {
					wan_udp_pkt->wan_udp_return_code =
					    WAN_UDP_INVALID_CMD;
				}
			}
			break;

		case WAN_GET_PROTOCOL:
			wan_udp_pkt->wan_udp_aft_num_frames = WANCONFIG_AFT;
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			wan_udp_pkt->wan_udp_data_len = 1;
			break;

		case WAN_GET_PLATFORM:
			wan_udp_pkt->wan_udp_data[0] = WAN_PLATFORM_ID;
			wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
			wan_udp_pkt->wan_udp_data_len = 1;
			break;

		default:
			wan_udp_pkt->wan_udp_data_len = 0;
			wan_udp_pkt->wan_udp_return_code = 0xCD;

			log(LOG_INFO, "%s: Warning, Illegal UDP "
			    "command attempted from network: %x\n",
			    card->devname, wan_udp_pkt->wan_udp_command);
			break;
		}
	}

	wan_udp_pkt->wan_udp_request_reply = UDPMGMT_REPLY;
	return (1);
}

/*
 * FIRMWARE Specific Interface Functions
 */

static int
xilinx_chip_configure(sdla_t *card)
{
	u_int32_t reg, tmp;
	int err = 0;
	u_int16_t adapter_type, adptr_security;

#ifdef DEBUG_INIT
	log(LOG_DEBUG, "Xilinx Chip Configuration. -- \n");
#endif
	xilinx_delay(1);

	sdla_bus_read_4(card->hw, XILINX_CHIP_CFG_REG, &reg);

	/* Configure for T1 or E1 front end */
	if (IS_T1(&card->fe_te.te_cfg)) {
		card->u.xilinx.num_of_time_slots = NUM_OF_T1_CHANNELS;
		bit_clear((u_int8_t *)&reg, INTERFACE_TYPE_T1_E1_BIT);
		bit_set((u_int8_t *)&reg, FRONT_END_FRAME_FLAG_ENABLE_BIT);
	} else if (IS_E1(&card->fe_te.te_cfg)) {
		card->u.xilinx.num_of_time_slots = NUM_OF_E1_CHANNELS;
		bit_set((u_int8_t *)&reg, INTERFACE_TYPE_T1_E1_BIT);
		bit_set((u_int8_t *)&reg, FRONT_END_FRAME_FLAG_ENABLE_BIT);
	} else {
		log(LOG_INFO, "%s: Error: Xilinx doesn't "
		    "support non T1/E1 interface!\n", card->devname);
		return (EINVAL);
	}

	sdla_bus_write_4(card->hw, XILINX_CHIP_CFG_REG, reg);

	DELAY(10000);

	/* Reset PMC */
	sdla_bus_read_4(card->hw, XILINX_CHIP_CFG_REG, &reg);
	bit_clear((u_int8_t *)&reg, FRONT_END_RESET_BIT);
	sdla_bus_write_4(card->hw, XILINX_CHIP_CFG_REG, reg);
	DELAY(1000);

	bit_set((u_int8_t *)&reg, FRONT_END_RESET_BIT);
	sdla_bus_write_4(card->hw, XILINX_CHIP_CFG_REG, reg);
	DELAY(100);

#ifdef DEBUG_INIT
	log(LOG_DEBUG, "--- Chip Reset. -- \n");
#endif

	/* Reset Chip Core */
	sdla_bus_read_4(card->hw, XILINX_CHIP_CFG_REG, &reg);
	bit_set((u_int8_t *)&reg, CHIP_RESET_BIT);
	sdla_bus_write_4(card->hw, XILINX_CHIP_CFG_REG, reg);

	DELAY(100);

	/* Disable the chip/hdlc reset condition */
	bit_clear((u_int8_t *)&reg, CHIP_RESET_BIT);

	/* Disable ALL chip interrupts */
	bit_clear((u_int8_t *)&reg, GLOBAL_INTR_ENABLE_BIT);
	bit_clear((u_int8_t *)&reg, ERROR_INTR_ENABLE_BIT);
	bit_clear((u_int8_t *)&reg, FRONT_END_INTR_ENABLE_BIT);

	sdla_bus_write_4(card->hw, XILINX_CHIP_CFG_REG, reg);

	xilinx_delay(1);

	sdla_getcfg(card->hw, SDLA_ADAPTERTYPE, &adapter_type);
	DELAY(100);

#ifdef DEBUG_INIT
	log(LOG_INFO, "%s: Hardware Adapter Type 0x%X\n",
	    card->devname, adapter_type);
#endif

	adptr_security = read_cpld(card, SECURITY_CPLD_REG);
	adptr_security = adptr_security >> SECURITY_CPLD_SHIFT;
	adptr_security = adptr_security & SECURITY_CPLD_MASK;

#ifdef DEBUG_INIT
	switch (adptr_security) {
	case SECURITY_1LINE_UNCH:
		log(LOG_INFO, "%s: Security 1 Line UnCh\n", card->devname);
		break;
	case SECURITY_1LINE_CH:
		log(LOG_INFO, "%s: Security 1 Line Ch\n", card->devname);
		break;
	case SECURITY_2LINE_UNCH:
		log(LOG_INFO, "%s: Security 2 Line UnCh\n", card->devname);
		break;
	case SECURITY_2LINE_CH:
		log(LOG_INFO, "%s: Security 2 Line Ch\n", card->devname);
		break;
	default:
		log(LOG_INFO, "%s: Error Invalid Security ID = 0x%X\n",
		    card->devname, adptr_security);
		/* return EINVAL;*/
	}
#endif

	/* Turn off Onboard RED LED */
	sdla_bus_read_4(card->hw, XILINX_CHIP_CFG_REG, &reg);
	bit_set((u_int8_t *)&reg, XILINX_RED_LED);
	sdla_bus_write_4(card->hw, XILINX_CHIP_CFG_REG, reg);
	DELAY(10);

	err = aft_core_ready(card);
	if (err != 0)
		log(LOG_INFO, "%s: WARNING: HDLC Core Not Ready: B4 TE CFG!\n",
		    card->devname);

	log(LOG_INFO, "%s: Configuring A101 PMC T1/E1/J1 Front End\n",
	    card->devname);

	if (sdla_te_config(card)) {
		log(LOG_INFO, "%s: Failed %s configuration!\n", card->devname,
		    IS_T1(&card->fe_te.te_cfg)?"T1":"E1");
		return (EINVAL);
	}

	xilinx_delay(1);

	err = aft_core_ready(card);
	if (err != 0) {
		log(LOG_INFO, "%s: Error: HDLC Core Not Ready!\n",
		    card->devname);

		sdla_bus_read_4(card->hw, XILINX_CHIP_CFG_REG, &reg);

		/* Disable the chip/hdlc reset condition */
		bit_set((u_int8_t *)&reg, CHIP_RESET_BIT);

		sdla_bus_write_4(card->hw, XILINX_CHIP_CFG_REG, reg);
		return (err);
	}

#ifdef DEBUG_INIT
	log(LOG_INFO, "%s: HDLC Core Ready 0x%08X\n",
	    card->devname, reg);
#endif

	xilinx_delay(1);

	/* Setup global DMA parameters */
	reg = 0;
	reg|=(XILINX_DMA_SIZE    << DMA_SIZE_BIT_SHIFT);
	reg|=(XILINX_DMA_FIFO_UP << DMA_FIFO_HI_MARK_BIT_SHIFT);
	reg|=(XILINX_DMA_FIFO_LO << DMA_FIFO_LO_MARK_BIT_SHIFT);

	/*
	 * Enable global DMA engine and set to default
	 * number of active channels. Note: this value will
	 * change in dev configuration
	 */
	reg|=(XILINX_DEFLT_ACTIVE_CH << DMA_ACTIVE_CHANNEL_BIT_SHIFT);
	bit_set((u_int8_t *)&reg, DMA_ENGINE_ENABLE_BIT);

#ifdef DEBUG_INIT
	log(LOG_INFO, "--- Setup DMA control Reg. -- \n");
#endif

	sdla_bus_write_4(card->hw, XILINX_DMA_CONTROL_REG, reg);

#ifdef DEBUG_INIT
	log(LOG_INFO, "--- Tx/Rx global enable. -- \n");
#endif

	xilinx_delay(1);

	reg = 0;
	sdla_bus_write_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, reg);

	/* Clear interrupt pending registers befor first interrupt enable */
	sdla_bus_read_4(card->hw, XILINX_DMA_RX_INTR_PENDING_REG, &tmp);
	sdla_bus_read_4(card->hw, XILINX_DMA_TX_INTR_PENDING_REG, &tmp);
	sdla_bus_read_4(card->hw, XILINX_HDLC_RX_INTR_PENDING_REG, &tmp);
	sdla_bus_read_4(card->hw, XILINX_HDLC_TX_INTR_PENDING_REG, &tmp);
	sdla_bus_read_4(card->hw, XILINX_CHIP_CFG_REG, (u_int32_t *)&reg);
	if (bit_test((u_int8_t *)&reg, DMA_INTR_FLAG)) {
		log(LOG_INFO, "%s: Error: Active DMA Interrupt Pending. !\n",
		    card->devname);

		reg = 0;
		/* Disable the chip/hdlc reset condition */
		bit_set((u_int8_t *)&reg, CHIP_RESET_BIT);
		sdla_bus_write_4(card->hw, XILINX_CHIP_CFG_REG, reg);
		return (err);
	}
	if (bit_test((u_int8_t *)&reg, ERROR_INTR_FLAG)) {
		log(LOG_INFO, "%s: Error: Active Error Interrupt Pending. !\n",
		    card->devname);

		reg = 0;
		/* Disable the chip/hdlc reset condition */
		bit_set((u_int8_t *)&reg, CHIP_RESET_BIT);
		sdla_bus_write_4(card->hw, XILINX_CHIP_CFG_REG, reg);
		return (err);
	}


	/* Alawys disable global data and error interrupts */
	bit_clear((u_int8_t *)&reg, GLOBAL_INTR_ENABLE_BIT);
	bit_clear((u_int8_t *)&reg, ERROR_INTR_ENABLE_BIT);

	/* Always enable the front end interrupt */
	bit_set((u_int8_t *)&reg, FRONT_END_INTR_ENABLE_BIT);

#ifdef DEBUG_INIT
	log(LOG_DEBUG, "--- Set Global Interrupts (0x%X)-- \n", reg);
#endif

	xilinx_delay(1);

	sdla_bus_write_4(card->hw, XILINX_CHIP_CFG_REG, reg);

	return (err);
}

static int
xilinx_chip_unconfigure(sdla_t *card)
{
	u_int32_t	reg = 0;

	sdla_bus_write_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, reg);
	sdla_bus_read_4(card->hw, XILINX_CHIP_CFG_REG, &reg);
	/* Enable the chip/hdlc reset condition */
	reg = 0;
	bit_set((u_int8_t *)&reg, CHIP_RESET_BIT);

	sdla_bus_write_4(card->hw, XILINX_CHIP_CFG_REG, reg);
	return (0);
}

static int
xilinx_dev_configure(sdla_t *card, xilinx_softc_t *sc)
{
	u_int32_t reg;
	long free_logic_ch, i;

	sc->logic_ch_num=-1;

	if (!IS_TE1(&card->fe_te.te_cfg))
		return (EINVAL);

	if (IS_E1(&card->fe_te.te_cfg)) {
		log(LOG_DEBUG, "%s: Time Slot Orig 0x%lX  Shifted 0x%lX\n",
		    sc->if_name, sc->time_slot_map, sc->time_slot_map << 1);
		sc->time_slot_map = sc->time_slot_map << 1;
		bit_clear((u_int8_t *)&sc->time_slot_map, 0);
	}

	/*
	 * Channel definition section. If not channels defined
	 * return error
	 */
	if (sc->time_slot_map == 0) {
		log(LOG_INFO, "%s: Invalid Channel Selection 0x%lX\n",
		    card->devname, sc->time_slot_map);
		return (EINVAL);
	}

#ifdef DEBUG_INIT
	log(LOG_INFO, "%s:%s: Active channels = 0x%lX\n", card->devname,
	    sc->if_name, sc->time_slot_map);
#endif
	xilinx_delay(1);

	/*
	 * Check that the time slot is not being used. If it is
	 * stop the interface setup.  Notice, though we proceed
	 * to check for all timeslots before we start binding
	 * the channels in.  This way, we don't have to go back
	 * and clean the time_slot_map
	 */
	for (i = 0; i < card->u.xilinx.num_of_time_slots; i++) {
		if (bit_test((u_int8_t *)&sc->time_slot_map, i)) {

			if (sc->first_time_slot == -1) {
#ifdef DEBUG_INIT
				log(LOG_INFO, "%s: Setting first time "
				    "slot to %ld\n", card->devname, i);
#endif
				sc->first_time_slot = i;
			}

#ifdef DEBUG_INIT
			log(LOG_DEBUG, "%s: Configuring %s for timeslot %ld\n",
			    card->devname, sc->if_name,
			    IS_E1(&card->fe_te.te_cfg)?i:i+1);
#endif
			if (bit_test((u_int8_t *)
			    &card->u.xilinx.time_slot_map, i)) {
				log(LOG_INFO, "%s: Channel/Time Slot "
				    "resource conflict!\n", card->devname);
				log(LOG_INFO, "%s: %s: Channel/Time Slot "
				    "%ld, aready in use!\n",
				    card->devname, sc->if_name, (i+1));

				return (EEXIST);
			}

			/* Calculate the number of timeslots for this if */
			++sc->num_of_time_slots;
		}
	}

	xilinx_delay(1);

	sc->logic_ch_num = request_xilinx_logical_channel_num(card,
	    sc, &free_logic_ch);
	if (sc->logic_ch_num == -1)
		return (EBUSY);

	xilinx_delay(1);

	for (i = 0; i < card->u.xilinx.num_of_time_slots; i++) {
		if (bit_test((u_int8_t *)&sc->time_slot_map, i)) {

			bit_set((u_int8_t *)&card->u.xilinx.time_slot_map, i);

			sdla_bus_read_4(card->hw,
			    XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
			reg &= ~TIMESLOT_BIT_MASK;

			/* FIXME do not hardcode !*/
			reg &= HDLC_LCH_TIMESLOT_MASK; /* mask not valid bits*/

			/* Select a Timeslot for configuration */
			sdla_bus_write_4(card->hw,
			    XILINX_TIMESLOT_HDLC_CHAN_REG,
			    (reg | (i << TIMESLOT_BIT_SHIFT)));

			reg = sc->logic_ch_num & CONTROL_RAM_DATA_MASK;

#ifdef TRUE_FIFO_SIZE
			reg |= (sc->fifo_size_code & HDLC_FIFO_SIZE_MASK) <<
			    HDLC_FIFO_SIZE_SHIFT;
#else
			reg |= (HARD_FIFO_CODE &
			    HDLC_FIFO_SIZE_MASK) << HDLC_FIFO_SIZE_SHIFT;
#endif /* TRUE_FIFO_SIZE */

			reg |= (sc->fifo_base_addr & HDLC_FIFO_BASE_ADDR_MASK)
			    << HDLC_FIFO_BASE_ADDR_SHIFT;

#ifdef DEBUG_INIT
			log(LOG_INFO, "Setting Timeslot %ld to logic "
			    "ch %ld Reg=0x%X\n", i, sc->logic_ch_num, reg);
#endif
			xilinx_write_ctrl_hdlc(card, i,
			    XILINX_CONTROL_RAM_ACCESS_BUF, reg);
		}
	}

	if (free_logic_ch != -1) {

		char free_ch_used = 0;

		for (i = 0; i < card->u.xilinx.num_of_time_slots; i++) {
			if (!bit_test((u_int8_t *)
			    &card->u.xilinx.time_slot_map, i)) {

				sdla_bus_read_4(card->hw,
				    XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);

				reg &= ~TIMESLOT_BIT_MASK;
				/* mask not valid bits */
				reg &= HDLC_LCH_TIMESLOT_MASK;

				/* Select a Timeslot for configuration */
				sdla_bus_write_4(card->hw,
				    XILINX_TIMESLOT_HDLC_CHAN_REG,
				    (reg | (i << TIMESLOT_BIT_SHIFT)));

				reg = free_logic_ch&CONTROL_RAM_DATA_MASK;

				/* For the rest of the unused logic channels
				 * bind them to timeslot 31 and set the fifo
				 * size to 32 byte = Code = 0x00 */
				reg |= (FIFO_32B & HDLC_FIFO_SIZE_MASK)
				    << HDLC_FIFO_SIZE_SHIFT;

				reg |= (free_logic_ch &
				    HDLC_FIFO_BASE_ADDR_MASK) <<
				    HDLC_FIFO_BASE_ADDR_SHIFT;

#ifdef DEBUG_INIT
				log(LOG_INFO, "Setting Timeslot "
				    "%ld to free logic ch %ld Reg=0x%X\n",
				    i, free_logic_ch, reg);
#endif
				xilinx_write_ctrl_hdlc(card, i,
				    XILINX_CONTROL_RAM_ACCESS_BUF, reg);

				free_ch_used = 1;
			}
		}

		/* We must check if the free logic has been bound
		 * to any timeslots */
		if (free_ch_used) {
#ifdef DEBUG_INIT
			log(LOG_INFO, "%s: Setting Free CH %ld to idle\n",
			    sc->if_name, free_logic_ch);
#endif
			xilinx_delay(1);

			/* Setup the free logic channel as IDLE */

			sdla_bus_read_4(card->hw,
			    XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);

			reg &= ~HDLC_LOGIC_CH_BIT_MASK;

			/* mask not valid bits */
			reg &= HDLC_LCH_TIMESLOT_MASK;

			sdla_bus_write_4(card->hw,
			    XILINX_TIMESLOT_HDLC_CHAN_REG,
			    (reg|(free_logic_ch&HDLC_LOGIC_CH_BIT_MASK)));

			reg = 0;
			bit_clear((u_int8_t *)&reg, HDLC_RX_PROT_DISABLE_BIT);
			bit_clear((u_int8_t *)&reg, HDLC_TX_PROT_DISABLE_BIT);

			bit_set((u_int8_t *)&reg, HDLC_RX_ADDR_RECOGN_DIS_BIT);

			xilinx_write_ctrl_hdlc(card, sc->first_time_slot,
			    XILINX_HDLC_CONTROL_REG, reg);
		}
	}

	/* Select an HDLC logic channel for configuration */
	sdla_bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);

	reg &= ~HDLC_LOGIC_CH_BIT_MASK;
	reg &= HDLC_LCH_TIMESLOT_MASK;         /* mask not valid bits */

	sdla_bus_write_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG,
	    (reg | (sc->logic_ch_num & HDLC_LOGIC_CH_BIT_MASK)));

	reg = 0;

	/* HDLC engine is enabled on the above logical channels */
	bit_clear((u_int8_t *)&reg, HDLC_RX_PROT_DISABLE_BIT);
	bit_clear((u_int8_t *)&reg, HDLC_TX_PROT_DISABLE_BIT);

	bit_set((u_int8_t *)&reg, HDLC_TX_CHAN_ENABLE_BIT);
	bit_set((u_int8_t *)&reg, HDLC_RX_ADDR_RECOGN_DIS_BIT);

	xilinx_write_ctrl_hdlc(card, sc->first_time_slot,
	    XILINX_HDLC_CONTROL_REG, reg);

	return (0);
}

static void
xilinx_dev_unconfigure(sdla_t *card, xilinx_softc_t *sc)
{
	u_int32_t reg;
	int i, s;

#ifdef DEBUG_INIT
	log(LOG_DEBUG, "\n-- Unconfigure Xilinx. --\n");
#endif

	/* Select an HDLC logic channel for configuration */
	if (sc->logic_ch_num != -1) {

		sdla_bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
		reg &= ~HDLC_LOGIC_CH_BIT_MASK;
		reg &= HDLC_LCH_TIMESLOT_MASK;	/* mask not valid bits */

		sdla_bus_write_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG,
		    (reg | (sc->logic_ch_num & HDLC_LOGIC_CH_BIT_MASK)));

		reg = 0x00020000;
		xilinx_write_ctrl_hdlc(card, sc->first_time_slot,
		    XILINX_HDLC_CONTROL_REG, reg);

		for (i = 0; i < card->u.xilinx.num_of_time_slots; i++) {
			if (bit_test((u_int8_t *)&sc->time_slot_map, i)) {
				sdla_bus_read_4(card->hw,
				    XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
				reg &= ~TIMESLOT_BIT_MASK;

				/* mask not valid bits */
				reg &= HDLC_LCH_TIMESLOT_MASK;

				/* Select a Timeslot for configuration */
				sdla_bus_write_4(card->hw,
				    XILINX_TIMESLOT_HDLC_CHAN_REG,
				    (reg | (i<<TIMESLOT_BIT_SHIFT)));

				reg = 31 & CONTROL_RAM_DATA_MASK;
				reg |= (FIFO_32B & HDLC_FIFO_SIZE_MASK) <<
				    HDLC_FIFO_SIZE_SHIFT;
				reg |= (31 & HDLC_FIFO_BASE_ADDR_MASK) <<
				    HDLC_FIFO_BASE_ADDR_SHIFT;

#ifdef DEBUG_INIT
				log(LOG_INFO, "Setting Timeslot %d "
				    "to logic ch %d Reg=0x%X\n", i, 31 , reg);
#endif
				xilinx_write_ctrl_hdlc(card, i,
				    XILINX_CONTROL_RAM_ACCESS_BUF, reg);
			}
		}

		/*
		 * Lock to protect the logic ch map to sc device array
		 */
		s = splnet();
		free_xilinx_logical_channel_num(card, sc->logic_ch_num);
		for (i = 0; i < card->u.xilinx.num_of_time_slots; i++)
			if (bit_test((u_int8_t *)&sc->time_slot_map, i))
				--sc->num_of_time_slots;

		free_fifo_baddr_and_size(card, sc);
		splx(s);

		sc->logic_ch_num = -1;

		for (i = 0; i < card->u.xilinx.num_of_time_slots; i++)
			if (bit_test((u_int8_t *)&sc->time_slot_map, i))
				bit_clear((u_int8_t *)
				    &card->u.xilinx.time_slot_map, i);
	}
}

#define FIFO_RESET_TIMEOUT_CNT 1000
#define FIFO_RESET_TIMEOUT_US  10
static int
xilinx_init_rx_dev_fifo(sdla_t *card, xilinx_softc_t *sc, unsigned char wait)
{
	u_int32_t reg;
	u_int32_t dma_descr;
	u_int8_t  timeout = 1;
	u_int16_t i;

	/* Clean RX DMA fifo */
	dma_descr = (unsigned long)(sc->logic_ch_num << 4) +
	    XILINX_RxDMA_DESCRIPTOR_HI;
	reg = 0;
	bit_set((u_int8_t *)&reg, INIT_DMA_FIFO_CMD_BIT);

#ifdef DEBUG_INIT
	log(LOG_DEBUG,
	    "%s: Clearing RX Fifo DmaDescr=(0x%X) Reg=(0x%X) (%s)\n",
	    sc->if_name, dma_descr, reg, __FUNCTION__);
#endif

	sdla_bus_write_4(card->hw, dma_descr, reg);

	if (wait == WP_WAIT) {
		for (i = 0; i < FIFO_RESET_TIMEOUT_CNT; i++) {
			sdla_bus_read_4(card->hw, dma_descr, &reg);
			if (bit_test((u_int8_t *)&reg, INIT_DMA_FIFO_CMD_BIT)) {
				DELAY(FIFO_RESET_TIMEOUT_US);
				continue;
			}
			timeout = 0;
			break;
		}

#ifdef DEBUG_INIT
		if (timeout)
			log(LOG_INFO, "%s:%s: Error: Rx fifo reset "
			    "timedout %u us\n", card->devname,
			    sc->if_name, i * FIFO_RESET_TIMEOUT_US);
		else
			log(LOG_INFO, "%s:%s: Rx Fifo reset "
			    "successful %u us\n", card->devname, sc->if_name,
			    i * FIFO_RESET_TIMEOUT_US);
#endif
	} else
		timeout = 0;

	return (timeout);
}

static int
xilinx_init_tx_dev_fifo(sdla_t *card, xilinx_softc_t *sc, unsigned char wait)
{
	u_int32_t reg;
	u_int32_t dma_descr;
	u_int8_t  timeout = 1;
	u_int16_t i;

	/* Clean TX DMA fifo */
	dma_descr = (unsigned long)(sc->logic_ch_num << 4) +
	    XILINX_TxDMA_DESCRIPTOR_HI;
	reg = 0;
	bit_set((u_int8_t *)&reg, INIT_DMA_FIFO_CMD_BIT);

#ifdef DEBUG_INIT
	log(LOG_DEBUG,
	    "%s: Clearing TX Fifo DmaDescr=(0x%X) Reg=(0x%X) (%s)\n",
	    sc->if_name, dma_descr, reg, __FUNCTION__);
#endif
	sdla_bus_write_4(card->hw, dma_descr, reg);

	if (wait == WP_WAIT) {
		for (i = 0; i < FIFO_RESET_TIMEOUT_CNT; i++) {
			sdla_bus_read_4(card->hw, dma_descr, &reg);
			if (bit_test((u_int8_t *)&reg, INIT_DMA_FIFO_CMD_BIT)) {
				DELAY(FIFO_RESET_TIMEOUT_US);
				continue;
			}
			timeout = 0;
			break;
		}

#ifdef DEBUG_INIT
		if (timeout)
			log(LOG_INFO, "%s:%s: Error: Tx fifo reset "
			    "timedout %u us\n", card->devname, sc->if_name,
			    i * FIFO_RESET_TIMEOUT_US);
		else
			log(LOG_INFO, "%s:%s: Tx Fifo reset "
			    "successful %u us\n", card->devname, sc->if_name,
			    i * FIFO_RESET_TIMEOUT_US);
#endif
	} else
		timeout = 0;

	return (timeout);
}


static void
xilinx_dev_enable(sdla_t *card, xilinx_softc_t *sc)
{
	u_int32_t reg;

#ifdef DEBUG_INIT
	log(LOG_INFO, "%s: Enabling Global Inter Mask !\n", sc->if_name);
#endif
	/* Enable Logic Channel Interrupts for DMA and fifo */
	sdla_bus_read_4(card->hw, XILINX_GLOBAL_INTER_MASK, &reg);
	bit_set((u_int8_t *)&reg, sc->logic_ch_num);

	sdla_bus_write_4(card->hw, XILINX_GLOBAL_INTER_MASK, reg);

	bit_set((u_int8_t *)&card->u.xilinx.active_ch_map, sc->logic_ch_num);
}

static void
xilinx_dev_close(sdla_t *card, xilinx_softc_t *sc)
{
	u_int32_t reg;
	unsigned long dma_descr;
	int s;

#ifdef DEBUG_INIT
	log(LOG_DEBUG, "-- Close Xilinx device. --\n");
#endif
	/* Disable Logic Channel Interrupts for DMA and fifo */
	sdla_bus_read_4(card->hw, XILINX_GLOBAL_INTER_MASK, &reg);

	bit_clear((u_int8_t *)&reg, sc->logic_ch_num);
	bit_clear((u_int8_t *)&card->u.xilinx.active_ch_map, sc->logic_ch_num);

	/*
	 * We are masking the sc interrupt.
	 * Lock to make sure that the interrupt is
	 * not running
	 */
	s = splnet();
	sdla_bus_write_4(card->hw, XILINX_GLOBAL_INTER_MASK, reg);
	splx(s);

	reg = 0;

	/* Select an HDLC logic channel for configuration */
	sdla_bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);

	reg &= ~HDLC_LOGIC_CH_BIT_MASK;
	reg &= HDLC_LCH_TIMESLOT_MASK;         /* mask not valid bits */

	sdla_bus_write_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG,
	    (reg | (sc->logic_ch_num & HDLC_LOGIC_CH_BIT_MASK)));


	reg = 0;
	xilinx_write_ctrl_hdlc(card, sc->first_time_slot,
	    XILINX_HDLC_CONTROL_REG, reg);

	/* Clear descriptors */
	reg = 0;
	dma_descr=(sc->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
	sdla_bus_write_4(card->hw, dma_descr, reg);
	dma_descr=(sc->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
	sdla_bus_write_4(card->hw, dma_descr, reg);

	/* FIXME: Cleanp up Tx and Rx buffers */
}

static int
xilinx_dma_rx(sdla_t *card, xilinx_softc_t *sc)
{
	u_int32_t reg;
	unsigned long dma_descr;
	unsigned long bus_addr;
	wp_rx_element_t *rx_el;

	/* sanity check: make sure that DMA is in ready state */
#if 0
	dma_descr=(sc->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
	sdla_bus_read_4(card->hw, dma_descr, &reg);

	if (bit_test((u_int8_t *)&reg, RxDMA_HI_DMA_GO_READY_BIT)) {
		log(LOG_INFO, "%s: Error: RxDMA GO Ready bit set on dma Rx\n",
				card->devname);
		return (EFAULT);
	}
#endif

	if (sc->rx_dma_buf) {
		log(LOG_INFO, "%s: Critial Error: Rx Dma Buf busy!\n",
		    sc->if_name);
		return (EINVAL);
	}

	sc->rx_dma_buf = SIMPLEQ_FIRST(&sc->wp_rx_free_list);

	if (sc->rx_dma_buf == NULL) {
		if (aft_alloc_rx_dma_buff(sc, 1) == 0) {
			log(LOG_INFO, "%s: Critical Error no rx dma buf!",
			    sc->if_name);
			return (ENOMEM);
		}
		sc->rx_dma_buf = SIMPLEQ_FIRST(&sc->wp_rx_free_list);
	}

	SIMPLEQ_REMOVE_HEAD(&sc->wp_rx_free_list, entry);

	bus_dmamap_sync(sc->dmatag, sc->rx_dma_buf->dma_map, 0, sc->dma_mtu,
             BUS_DMASYNC_PREREAD);

	rx_el = &sc->rx_dma_buf->rx_el;
	memset(rx_el, 0, sizeof(*rx_el));

	bus_addr = sc->rx_dma_buf->dma_map->dm_segs[0].ds_addr;
	rx_el->dma_addr = bus_addr;

	/* Write the pointer of the data packet to the
	 * DMA address register */
	reg = bus_addr;

	/* Set the 32bit alignment of the data length.
	 * Since we are setting up for rx, set this value
	 * to Zero */
	reg &= ~(RxDMA_LO_ALIGNMENT_BIT_MASK);

	dma_descr = (sc->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_LO;

#ifdef DEBUG_RX
	log(LOG_INFO, "%s: RxDMA_LO = 0x%X, BusAddr=0x%lX "
	    "DmaDescr=0x%lX (%s)\n", card->devname, reg, bus_addr,
	    dma_descr, __FUNCTION__);
#endif
	sdla_bus_write_4(card->hw, dma_descr, reg);

	dma_descr=(unsigned long)(sc->logic_ch_num << 4) +
	    XILINX_RxDMA_DESCRIPTOR_HI;

	reg = 0;

	reg |= (sc->dma_mtu >> 2) & RxDMA_HI_DMA_DATA_LENGTH_MASK;

#ifdef TRUE_FIFO_SIZE
	reg |= (sc->fifo_size_code & DMA_FIFO_SIZE_MASK) <<
	    DMA_FIFO_SIZE_SHIFT;
#else

	reg |= (HARD_FIFO_CODE & DMA_FIFO_SIZE_MASK) << DMA_FIFO_SIZE_SHIFT;
#endif
	reg |= (sc->fifo_base_addr&DMA_FIFO_BASE_ADDR_MASK) <<
	    DMA_FIFO_BASE_ADDR_SHIFT;

	bit_set((u_int8_t *)&reg, RxDMA_HI_DMA_GO_READY_BIT);

#ifdef DEBUG_RX
	log(LOG_INFO, "%s: RXDMA_HI = 0x%X, BusAddr=0x%lX DmaDescr=0x%lX "
	    "(%s)\n", sc->if_name, reg, bus_addr, dma_descr, __FUNCTION__);
#endif

	sdla_bus_write_4(card->hw, dma_descr, reg);

	bit_set((u_int8_t *)&sc->rx_dma, 0);

	return (0);
}


static int
xilinx_dma_tx(sdla_t *card, xilinx_softc_t *sc)
{
	u_int32_t reg = 0;
	struct mbuf *m;
	unsigned long dma_descr;
	unsigned char len_align = 0;
	int len = 0;

#ifdef DEBUG_TX
	log(LOG_INFO, "------ Setup Tx DMA descriptor. --\n");
#endif

	if (bit_test((u_int8_t *)&sc->dma_status, TX_BUSY)) {
#ifdef DEBUG_TX
		log(LOG_INFO, "%s:  TX_BUSY set (%s:%d)!\n",
		    sc->if_name, __FUNCTION__, __LINE__);
#endif
		return EBUSY;
	}
	bit_set((u_int8_t *)&sc->dma_status, TX_BUSY);


	/*
	 * Free the previously skb dma mapping.
	 * In this case the tx interrupt didn't finish and we must re-transmit.
	 */
	if (sc->tx_dma_addr && sc->tx_dma_len) {
		log(LOG_INFO, "%s: Unmaping tx_dma_addr in %s\n",
		    sc->if_name, __FUNCTION__);

		sc->tx_dma_addr = 0;
		sc->tx_dma_len = 0;
	}

	/* Free the previously sent tx packet. To
	 * minimize tx isr, the previously transmitted
	 * packet is deallocated here */
	if (sc->tx_dma_mbuf) {
		bus_dmamap_unload(sc->dmatag, sc->tx_dmamap);
		m_freem(sc->tx_dma_mbuf);
		sc->tx_dma_mbuf = NULL;
	}

	/* check queue pointers before starting transmission */

	/* sanity check: make sure that DMA is in ready state */
	dma_descr = (sc->logic_ch_num << 4) + XILINX_TxDMA_DESCRIPTOR_HI;

#ifdef DEBUG_TX
	log(LOG_INFO, "%s: sc logic ch=%ld dma_descr=0x%lx set (%s:%d)!\n",
	    sc->if_name, sc->logic_ch_num, dma_descr, __FUNCTION__, __LINE__);
#endif

	sdla_bus_read_4(card->hw, dma_descr, &reg);

	if (bit_test((u_int8_t *)&reg, TxDMA_HI_DMA_GO_READY_BIT)) {
		log(LOG_INFO, "%s: Error: TxDMA GO Ready bit set "
		    "on dma Tx 0x%X\n", card->devname, reg);
		bit_clear((u_int8_t *)&sc->dma_status, TX_BUSY);
		return (EFAULT);
	}

	IF_DEQUEUE(&sc->wp_tx_pending_list, m);

	if (!m) {
		bit_clear((u_int8_t *)&sc->dma_status, TX_BUSY);
		return (ENOBUFS);
	}

	len = m->m_len;
	if (len > MAX_XILINX_TX_DMA_SIZE) {
		/* FIXME: We need to split this frame into
		 *        multiple parts.  For now though
		 *        just drop it :) */
		log(LOG_INFO, "%s: Tx len %d > %d (MAX TX DMA LEN)\n",
		    sc->if_name, len, MAX_XILINX_TX_DMA_SIZE);
		m_freem(m);
		bit_clear((u_int8_t *)&sc->dma_status, TX_BUSY);
		return (EINVAL);
	}

	if (ADDR_MASK(mtod(m, caddr_t), 0x03)) {
		/* The mbuf should already be aligned */
		log(LOG_INFO, "%s: TX packet not aligned!\n",
		    sc->if_name);
		m_freem(m);
		bit_clear((u_int8_t *)&sc->dma_status, TX_BUSY);
		return (EINVAL);
	}

	if (bus_dmamap_load(sc->dmatag, sc->tx_dmamap,
	    mtod(m, void *), len, NULL, BUS_DMA_NOWAIT | BUS_DMA_WRITE)) {
		log(LOG_INFO, "%s: Failed to load TX mbuf for DMA!\n",
		    sc->if_name);
		m_freem(m);
		bit_clear((u_int8_t *)&sc->dma_status, TX_BUSY);
		return (EINVAL);		
	}

	sc->tx_dma_addr = sc->tx_dmamap->dm_segs[0].ds_addr;
	sc->tx_dma_len = len;

	if (sc->tx_dma_addr & 0x03) {
		log(LOG_INFO, "%s: Error: Tx Ptr not aligned "
		    "to 32bit boundary!\n", card->devname);
		m_freem(m);
		bit_clear((u_int8_t *)&sc->dma_status, TX_BUSY);
		return (EINVAL);
	}

	sc->tx_dma_mbuf = m;

	/* WARNING: Do not use the "skb" pointer from
	 *          here on.  The skb pointer might not exist if
	 *          we are in transparent mode */

	dma_descr = (sc->logic_ch_num << 4) + XILINX_TxDMA_DESCRIPTOR_LO;

	/* Write the pointer of the data packet to the
	 * DMA address register */
	reg = sc->tx_dma_addr;

	bus_dmamap_sync(sc->dmatag, sc->tx_dmamap, 0, len,
	    BUS_DMASYNC_PREWRITE);

	/* Set the 32bit alignment of the data length.
	 * Used to pad the tx packet to the 32 bit
	 * boundary */
	reg &= ~(TxDMA_LO_ALIGNMENT_BIT_MASK);
	reg |= (len & 0x03);

	if (len & 0x03)
		len_align = 1;

#ifdef DEBUG_TX
	log(LOG_INFO, "%s: TXDMA_LO=0x%X PhyAddr=0x%lX DmaDescr=0x%lX (%s)\n",
		sc->if_name, reg, sc->tx_dma_addr, dma_descr, __FUNCTION__);
#endif

	sdla_bus_write_4(card->hw, dma_descr, reg);

	dma_descr = (sc->logic_ch_num << 4) + XILINX_TxDMA_DESCRIPTOR_HI;

	reg = 0;
	reg |= (((len >> 2) + len_align) & TxDMA_HI_DMA_DATA_LENGTH_MASK);

#ifdef TRUE_FIFO_SIZE
	reg |= (sc->fifo_size_code & DMA_FIFO_SIZE_MASK) <<
	    DMA_FIFO_SIZE_SHIFT;
#else

	reg |= (HARD_FIFO_CODE & DMA_FIFO_SIZE_MASK) << DMA_FIFO_SIZE_SHIFT;
#endif
	reg |= (sc->fifo_base_addr & DMA_FIFO_BASE_ADDR_MASK) <<
	    DMA_FIFO_BASE_ADDR_SHIFT;

	/*
	 * Only enable the Frame Start/Stop on
	 * non-transparent hdlc configuration
	 */
	bit_set((u_int8_t *)&reg, TxDMA_HI_DMA_FRAME_START_BIT);
	bit_set((u_int8_t *)&reg, TxDMA_HI_DMA_FRAME_END_BIT);

	bit_set((u_int8_t *)&reg, TxDMA_HI_DMA_GO_READY_BIT);

#ifdef DEBUG_TX
	log(LOG_INFO, "%s: TXDMA_HI=0x%X DmaDescr=0x%lX (%s)\n",
	    sc->if_name, reg, dma_descr, __FUNCTION__);
#endif

	sdla_bus_write_4(card->hw, dma_descr, reg);

	return (0);

}

static void
xilinx_dma_tx_complete(sdla_t *card, xilinx_softc_t *sc)
{
	u_int32_t reg = 0;
	unsigned long dma_descr;

#ifdef DEBUG_TX
	log(LOG_INFO, "%s: TX DMA complete\n", card->devname);
#endif
	/* DEBUGTX */
/*	sdla_bus_read_4(card->hw, 0x78, &tmp1); */

	dma_descr = (sc->logic_ch_num << 4) + XILINX_TxDMA_DESCRIPTOR_HI;
	sdla_bus_read_4(card->hw, dma_descr, &reg);

	if (sc->tx_dma_mbuf == NULL) {
		log(LOG_INFO,
		    "%s: Critical Error: Tx DMA intr: no tx mbuf !\n",
		    card->devname);
		bit_clear((u_int8_t *)&sc->dma_status, TX_BUSY);
		return;
	}

	bus_dmamap_sync(sc->dmatag, sc->tx_dmamap, 0, sc->tx_dma_len,
             BUS_DMASYNC_POSTWRITE);

	sc->tx_dma_addr = 0;
	sc->tx_dma_len = 0;

	/* Do not free the packet here,
	 * copy the packet dma info into csum
	 * field and let the bh handler analyze
	 * the transmitted packet.
	 */

	if (reg & TxDMA_HI_DMA_PCI_ERROR_RETRY_TOUT) {
		log(LOG_INFO, "%s:%s: PCI Error: 'Retry' "
		    "exceeds maximum (64k): Reg=0x%X!\n",
		    card->devname, sc->if_name, reg);

		if (++sc->pci_retry < 3) {
			bit_set((u_int8_t *)&reg,
				TxDMA_HI_DMA_GO_READY_BIT);

			log(LOG_INFO, "%s: Retry: TXDMA_HI=0x%X "
			    "DmaDescr=0x%lX (%s)\n",
			    sc->if_name, reg, dma_descr, __FUNCTION__);

			sdla_bus_write_4(card->hw, dma_descr, reg);
			return;
		}
	}

	sc->pci_retry = 0;
	sc->tx_dma_mbuf->m_pkthdr.csum_flags = reg & 0xFFFF;
	sc->tx_dma_mbuf->m_pkthdr.ether_vtag = (reg >> 16) & 0xFFFF;
	IF_ENQUEUE(&sc->wp_tx_complete_list, sc->tx_dma_mbuf);
	sc->tx_dma_mbuf = NULL;

	bit_clear((u_int8_t *)&sc->dma_status, TX_BUSY);

	xilinx_process_packet(sc);
}

static void
xilinx_tx_post_complete(sdla_t *card, xilinx_softc_t *sc, struct mbuf *m)
{
	struct ifnet	*ifp;
	u_int32_t reg;

	WAN_ASSERT1(sc == NULL);
	reg = (m->m_pkthdr.ether_vtag << 16) + m->m_pkthdr.csum_flags;
	ifp = (struct ifnet *)&sc->common.ifp;
	if ((bit_test((u_int8_t *)&reg, TxDMA_HI_DMA_GO_READY_BIT)) ||
	    (reg & TxDMA_HI_DMA_DATA_LENGTH_MASK) ||
	    (reg & TxDMA_HI_DMA_PCI_ERROR_MASK)) {

#ifdef DEBUG_TX
		log(LOG_INFO, "%s:%s: Tx DMA Descriptor=0x%lX\n",
			card->devname, sc->if_name, reg);
#endif

		/* Checking Tx DMA Go bit. Has to be '0' */
		if (bit_test((u_int8_t *)&reg, TxDMA_HI_DMA_GO_READY_BIT))
			log(LOG_INFO, "%s:%s: Error: TxDMA Intr: "
			    "GO bit set on Tx intr\n",
			    card->devname, sc->if_name);

		if (reg & TxDMA_HI_DMA_DATA_LENGTH_MASK)
			log(LOG_INFO, "%s:%s: Error: TxDMA Length "
			"not equal 0 \n", card->devname, sc->if_name);

		/* Checking Tx DMA PCI error status. Has to be '0's */
		if (reg & TxDMA_HI_DMA_PCI_ERROR_MASK) {

			if (reg & TxDMA_HI_DMA_PCI_ERROR_M_ABRT)
				log(LOG_INFO, "%s:%s: Tx Error: "
				    "Abort from Master: pci fatal error!\n",
				    card->devname, sc->if_name);

			if (reg & TxDMA_HI_DMA_PCI_ERROR_T_ABRT)
				log(LOG_INFO, "%s:%s: Tx Error: "
				    "Abort from Target: pci fatal error!\n",
				    card->devname, sc->if_name);

			if (reg & TxDMA_HI_DMA_PCI_ERROR_DS_TOUT) {
				log(LOG_INFO, "%s:%s: Tx Warning: "
				    "PCI Latency Timeout!\n",
				    card->devname, sc->if_name);
				goto tx_post_ok;
			}
			if (reg & TxDMA_HI_DMA_PCI_ERROR_RETRY_TOUT)
				log(LOG_INFO, "%s:%s: Tx Error: 'Retry' "
				    "exceeds maximum (64k): pci fatal error!\n",
				    card->devname, sc->if_name);
		}
		goto tx_post_exit;
	}

tx_post_ok:

	if (ifp)
		ifp->if_opackets++;

	/* Indicate that the first tx frame went
	 * out on the transparent link */
	bit_set((u_int8_t *)&sc->idle_start, 0);

tx_post_exit:

	if (!xilinx_dma_tx(card, sc)) {
		/*
		 * If we were able to transmit and the interface is set to
		 * OACTIVE remove this flag and let kernel try to transmit.
		 */
		if (ifp->if_flags & IFF_OACTIVE)
			ifp->if_flags &= ~IFF_OACTIVE;
	}
	return;
}

static void
xilinx_dma_rx_complete(sdla_t *card, xilinx_softc_t *sc)
{
	struct xilinx_rx_buffer *buf;
	unsigned long dma_descr;
	wp_rx_element_t *rx_el;

	bit_clear((u_int8_t *)&sc->rx_dma, 0);

	if (sc->rx_dma_buf == NULL) {
		log(LOG_INFO,
		    "%s: Critical Error: rx_dma_mbuf\n", sc->if_name);
		return;
	}

	rx_el = &sc->rx_dma_buf->rx_el;

	/* Reading Rx DMA descriptor information */
	dma_descr=(sc->logic_ch_num << 4) + XILINX_RxDMA_DESCRIPTOR_LO;
	sdla_bus_read_4(card->hw, dma_descr, &rx_el->align);
	rx_el->align &= RxDMA_LO_ALIGNMENT_BIT_MASK;

	dma_descr = (sc->logic_ch_num << 4) + XILINX_RxDMA_DESCRIPTOR_HI;
	sdla_bus_read_4(card->hw, dma_descr, &rx_el->reg);

	rx_el->pkt_error = sc->pkt_error;
	sc->pkt_error = 0;

#ifdef DEBUG_RX
	log(LOG_INFO, "%s: RX HI=0x%X  LO=0x%X DMA=0x%lX (%s:%d)\n",
	    sc->if_name, rx_el->reg, rx_el->align, rx_el->dma_addr,
	    __FUNCTION__, __LINE__);
#endif

	buf = sc->rx_dma_buf;
	sc->rx_dma_buf = NULL;

	xilinx_dma_rx(card, sc);

	SIMPLEQ_INSERT_TAIL(&sc->wp_rx_complete_list, buf, entry);

	xilinx_process_packet(sc);

/*	sdla_bus_read_4(card->hw, 0x80, &rx_empty); */
}


static void
xilinx_rx_post_complete(sdla_t *card, xilinx_softc_t *sc,
    struct xilinx_rx_buffer *buf, struct mbuf **new_m, u_char *pkt_error)
{
	struct ifnet	*ifp;
	unsigned int len, data_error = 0;
	wp_rx_element_t *rx_el = &buf->rx_el;
	struct mbuf *m = buf->mbuf;

	WAN_ASSERT1(sc == NULL);
	ifp = (struct ifnet *)&sc->common.ifp;	/*m->m_pkthdr.rcvif;*/

#ifdef DEBUG_RX
	log(LOG_INFO, "%s: RX HI=0x%X  LO=0x%X DMA=0x%lX (%s:%d)\n",
	    sc->if_name, rx_el->reg, rx_el->align, rx_el->dma_addr,
	    __FUNCTION__, __LINE__);
#endif
	rx_el->align &= RxDMA_LO_ALIGNMENT_BIT_MASK;
	*pkt_error = 0;
	*new_m = NULL;


	/* Checking Rx DMA Go bit. Has to be '0' */
	if (bit_test((u_int8_t *)&rx_el->reg, RxDMA_HI_DMA_GO_READY_BIT)) {
		log(LOG_INFO, "%s: Error: RxDMA Intr: GO bit set on Rx intr\n",
		    card->devname);
		ifp->if_ierrors++;
		goto rx_comp_error;
	}

	/* Checking Rx DMA PCI error status. Has to be '0's */
	if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_MASK) {
#ifdef DEBUG_ERR
		if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_M_ABRT)
			log(LOG_INFO, "%s: Rx Error: Abort from Master: "
			    "pci fatal error!\n", card->devname);

		if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_T_ABRT)
			log(LOG_INFO, "%s: Rx Error: Abort from Target: "
			    "pci fatal error!\n", card->devname);

		if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_DS_TOUT)
			log(LOG_INFO, "%s: Rx Error: No 'DeviceSelect' "
			    "from target: pci fatal error!\n", card->devname);

		if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_RETRY_TOUT)
			log(LOG_INFO, "%s: Rx Error: 'Retry' exceeds maximum "
			    "(64k): pci fatal error!\n", card->devname);

		log(LOG_INFO, "%s: RXDMA PCI ERROR = 0x%x\n",
		    card->devname, rx_el->reg);
#endif
		if (ifp)
			ifp->if_ierrors++;

		goto rx_comp_error;
	}

	/* Checking Rx DMA Frame start bit. (information for api) */
	if (!bit_test((u_int8_t *)&rx_el->reg, RxDMA_HI_DMA_FRAME_START_BIT)) {
#ifdef DEBUG_ERR
		log(LOG_INFO, "%s: RxDMA Intr: Start flag missing: "
		    "MTU Mismatch! Reg=0x%X\n", card->devname, rx_el->reg);
#endif
		if (ifp)
			ifp->if_ierrors++;
		goto rx_comp_error;
	}

	/* Checking Rx DMA Frame end bit. (information for api) */
	if (!bit_test((u_int8_t *)&rx_el->reg, RxDMA_HI_DMA_FRAME_END_BIT)) {
#ifdef DEBUG_ERR
		log(LOG_INFO, "%s: RxDMA Intr: End flag missing: "
		    "MTU Mismatch! Reg=0x%X\n", card->devname, rx_el->reg);
#endif
		if (ifp)
			ifp->if_ierrors++;
		goto rx_comp_error;

	} else {  /* Check CRC error flag only if this is the end of Frame */

		if (bit_test((u_int8_t *)&rx_el->reg,
		    RxDMA_HI_DMA_CRC_ERROR_BIT)) {
#ifdef DEBUG_ERR
			log(LOG_INFO, "%s: RxDMA Intr: CRC Error! Reg=0x%X\n",
			    card->devname, rx_el->reg);
#endif
			if (ifp)
				ifp->if_ierrors++;

			bit_set((u_int8_t *)&rx_el->pkt_error,
			    WP_CRC_ERROR_BIT);
			data_error = 1;
		}

		/* Check if this frame is an abort, if it is
		 * drop it and continue receiving */
		if (bit_test((u_int8_t *)&rx_el->reg,
		    RxDMA_HI_DMA_FRAME_ABORT_BIT)) {
#ifdef DEBUG_ERR
			log(LOG_INFO, "%s: RxDMA Intr: Abort! Reg=0x%X\n",
			    card->devname, rx_el->reg);
#endif
			if (ifp)
			    ifp->if_ierrors++;

			bit_set((u_int8_t *)&rx_el->pkt_error,
			    WP_ABORT_ERROR_BIT);
			data_error = 1;
		}

		if (data_error)
			goto rx_comp_error;
	}

	len = rx_el->reg & RxDMA_HI_DMA_DATA_LENGTH_MASK;

	/* In HDLC mode, calculate rx length based
	 * on alignment value, received from DMA */
	len = (((sc->dma_mtu >> 2) - len) << 2) -
	    (~(rx_el->align) & RxDMA_LO_ALIGNMENT_BIT_MASK);

	*pkt_error = rx_el->pkt_error;

	/* After a RX FIFO overflow, we must mark max 7
	 * subsequent frames since firmware, cannot
	 * guarantee the contents of the fifo */

	if (bit_test((u_int8_t *)&rx_el->pkt_error, WP_FIFO_ERROR_BIT)) {
		if (++sc->rx_fifo_err_cnt >= WP_MAX_FIFO_FRAMES) {
			sc->rx_fifo_err_cnt = 0;
		}
		bit_set((u_int8_t *)pkt_error, WP_FIFO_ERROR_BIT);
	} else {
		if (sc->rx_fifo_err_cnt) {
			if (++sc->rx_fifo_err_cnt >= WP_MAX_FIFO_FRAMES) {
				sc->rx_fifo_err_cnt = 0;
			}
			bit_set((u_int8_t *)pkt_error, WP_FIFO_ERROR_BIT);
		}
	}

	bus_dmamap_sync(sc->dmatag, sc->rx_dma_buf->dma_map, 0, len,
             BUS_DMASYNC_POSTREAD);

	m->m_len = m->m_pkthdr.len = len;

	if (len > aft_rx_copyback) {
		/* The rx size is big enough, thus
		 * send this buffer up the stack
		 * and allocate another one */
		*new_m = m;
		buf->mbuf = NULL;
	} else {
		struct mbuf *m0;
		/* The rx packet is very
		 * small thus, allocate a new
		 * buffer and pass it up */
		if ((m0 = m_copym2(m, 0, len, M_NOWAIT)) == NULL) {
			log(LOG_INFO, "%s: Failed to allocate mbuf!\n",
			    sc->if_name);
			if (ifp)
			    ifp->if_ierrors++;
		} else
			*new_m = m0;
	}

 rx_comp_error:
	aft_reload_rx_dma_buff(sc, buf);

	return;
}


static char
request_xilinx_logical_channel_num(sdla_t *card, xilinx_softc_t *sc,
    long *free_ch)
{
	char logic_ch = -1, free_logic_ch = -1;
	int i, err;

	*free_ch = -1;

#ifdef DEBUG_INIT
	log(LOG_INFO, "-- Request_Xilinx_logic_channel_num:--\n");
	log(LOG_INFO, "%s: Global Num Timeslots=%d  "
	    "Global Logic ch Map 0x%lX (%s:%d)\n",
	    sc->if_name, card->u.xilinx.num_of_time_slots,
	    card->u.xilinx.logic_ch_map, __FUNCTION__, __LINE__);
#endif

	err = request_fifo_baddr_and_size(card, sc);
	if (err)
		return (-1);

	for (i = 0; i < card->u.xilinx.num_of_time_slots; i++) {
		if (!bit_test((u_int8_t *)&card->u.xilinx.logic_ch_map, i)) {
			bit_set((u_int8_t *)&card->u.xilinx.logic_ch_map, i);
			logic_ch = i;
			break;
		}
	}

	if (logic_ch == -1)
		return (logic_ch);

	for (i = 0; i < card->u.xilinx.num_of_time_slots; i++) {
		if (!bit_test((u_int8_t *)&card->u.xilinx.logic_ch_map, i)) {
			free_logic_ch = HDLC_FREE_LOGIC_CH;
			break;
		}
	}

	if (card->u.xilinx.dev_to_ch_map[(unsigned char)logic_ch]) {
		log(LOG_INFO, "%s: Error, request logical ch=%d map busy\n",
		    card->devname, logic_ch);
		return (-1);
	}

	*free_ch = free_logic_ch;

	card->u.xilinx.dev_to_ch_map[(unsigned char)logic_ch] = (void *)sc;

	if (logic_ch > card->u.xilinx.top_logic_ch) {
		card->u.xilinx.top_logic_ch = logic_ch;
		xilinx_dma_max_logic_ch(card);
	}

	return (logic_ch);
}

static void
free_xilinx_logical_channel_num(sdla_t *card, int logic_ch)
{
	bit_clear((u_int8_t *)&card->u.xilinx.logic_ch_map, logic_ch);
	card->u.xilinx.dev_to_ch_map[logic_ch] = NULL;

	if (logic_ch >= card->u.xilinx.top_logic_ch) {
		int i;

		card->u.xilinx.top_logic_ch = XILINX_DEFLT_ACTIVE_CH;

		for (i = 0; i < card->u.xilinx.num_of_time_slots; i++) {
			if (card->u.xilinx.dev_to_ch_map[logic_ch])
				card->u.xilinx.top_logic_ch = i;
		}

		xilinx_dma_max_logic_ch(card);
	}

}

static void
xilinx_dma_max_logic_ch(sdla_t *card)
{
	u_int32_t reg;

#ifdef DEBUG_INIT
	log(LOG_INFO, "-- Xilinx_dma_max_logic_ch :--\n");
#endif

	sdla_bus_read_4(card->hw, XILINX_DMA_CONTROL_REG, &reg);

	/* Set up the current highest active logic channel */

	reg &= DMA_ACTIVE_CHANNEL_BIT_MASK;
	reg |= (card->u.xilinx.top_logic_ch << DMA_ACTIVE_CHANNEL_BIT_SHIFT);

	sdla_bus_write_4(card->hw, XILINX_DMA_CONTROL_REG, reg);
}

static int
aft_alloc_rx_buffers(xilinx_softc_t *sc)
{
	struct xilinx_rx_buffer *buf;

	SIMPLEQ_INIT(&sc->wp_rx_free_list);
	SIMPLEQ_INIT(&sc->wp_rx_complete_list);

	/* allocate receive buffers in one cluster */
	buf = malloc(sizeof(*buf) * MAX_RX_BUF, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (buf == NULL)
		return (1);

	sc->wp_rx_buffers = buf;
	sc->wp_rx_buffer_last = buf;

	return (0);
}

static void
aft_release_rx_buffers(xilinx_softc_t *sc)
{
	struct xilinx_rx_buffer *buf;

	if (sc->wp_rx_buffers == NULL)
		return;

	while ((buf = SIMPLEQ_FIRST(&sc->wp_rx_free_list)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&sc->wp_rx_free_list, entry);
		aft_release_rx_dma_buff(sc, buf);
	}

	while ((buf = SIMPLEQ_FIRST(&sc->wp_rx_complete_list)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&sc->wp_rx_complete_list, entry);
		aft_release_rx_dma_buff(sc, buf);		
	}

	free(sc->wp_rx_buffers, M_DEVBUF, 0);

	sc->wp_rx_buffers = NULL;
	sc->wp_rx_buffer_last = NULL;
}

/* Allocate an mbuf and setup dma_map. */
static int
aft_alloc_rx_dma_buff(xilinx_softc_t *sc, int num)
{
	struct xilinx_rx_buffer *buf, *ebuf;
	int n;

	ebuf = sc->wp_rx_buffers + MAX_RX_BUF;
	buf = sc->wp_rx_buffer_last;

	for (n = 0; n < num; n++) {
		int i;
		for (i = 0; i < MAX_RX_BUF; i++) {
			if (buf->mbuf == NULL)
				break;
			if (++buf == ebuf)
				buf = sc->wp_rx_buffers;
		}

		if (buf->mbuf != NULL)
			break;

		sc->wp_rx_buffer_last = buf;

		buf->mbuf = wan_mbuf_alloc(sc->dma_mtu);
		if (buf->mbuf == NULL)
			break;

		if (bus_dmamap_create(sc->dmatag, sc->dma_mtu, 1, sc->dma_mtu,
		    0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &buf->dma_map)) {
			m_freem(buf->mbuf);
			buf->mbuf = NULL;
			break;
		}

		if (bus_dmamap_load(sc->dmatag, buf->dma_map,
		    mtod(buf->mbuf, void *), sc->dma_mtu, NULL,
		    BUS_DMA_NOWAIT | BUS_DMA_READ)) {
			aft_release_rx_dma_buff(sc, buf);
			break;
		}

		SIMPLEQ_INSERT_TAIL(&sc->wp_rx_free_list, buf, entry);
	}

	return (n);
}

static void
aft_reload_rx_dma_buff(xilinx_softc_t *sc, struct xilinx_rx_buffer *buf)
{
	bus_dmamap_unload(sc->dmatag, buf->dma_map);
	if (buf->mbuf == NULL) {
		buf->mbuf = wan_mbuf_alloc(sc->dma_mtu);
		if (buf->mbuf == NULL) {
			bus_dmamap_destroy(sc->dmatag, buf->dma_map);
			return;
		}
	}
	if (bus_dmamap_load(sc->dmatag, buf->dma_map, mtod(buf->mbuf, void *),
	    sc->dma_mtu, NULL, BUS_DMA_NOWAIT | BUS_DMA_READ)) {
		aft_release_rx_dma_buff(sc, buf);
		return;
	}

	SIMPLEQ_INSERT_TAIL(&sc->wp_rx_free_list, buf, entry);
}

static void
aft_release_rx_dma_buff(xilinx_softc_t *sc, struct xilinx_rx_buffer *buf)
{
	bus_dmamap_destroy(sc->dmatag, buf->dma_map);
	m_freem(buf->mbuf);
	buf->mbuf = NULL;
}

static void
enable_timer(void *card_id)
{
	sdla_t *card = (sdla_t *)card_id;
	int	s;

	s = splnet();
	sdla_te_polling(card);
	splx(s);

	return;
}

static void
xilinx_process_packet(xilinx_softc_t *sc)
{
	struct ifnet	*ifp;
	struct mbuf	*new_m, *m;
	unsigned char	 pkt_error;

	WAN_ASSERT1(sc == NULL);
	for (;;) {
		struct xilinx_rx_buffer *buf;
		buf = SIMPLEQ_FIRST(&sc->wp_rx_complete_list);
		if (buf == NULL)
			break;

		SIMPLEQ_REMOVE_HEAD(&sc->wp_rx_complete_list, entry);

		new_m = NULL;
		pkt_error = 0;

		xilinx_rx_post_complete(sc->common.card, sc, buf, &new_m,
		    &pkt_error);
		if (new_m) {
			ifp = (struct ifnet *)&sc->common.ifp;
#ifdef DEBUG_RX
			log(LOG_INFO, "%s: Receiving packet %d bytes!\n",
			    ifp->if_xname, new_m->m_len);
#endif
			wanpipe_generic_input(ifp, new_m);
		}
	}

	for (;;) {
		IF_DEQUEUE(&sc->wp_tx_complete_list, m);
		if (m == NULL)
			break;
		xilinx_tx_post_complete(sc->common.card, sc, m);
		m_freem(m);
	}

	return;
}

static int
fifo_error_interrupt(sdla_t *card, unsigned long reg)
{
	u_int32_t rx_status, tx_status;
	u_int32_t err = 0;
	u_int32_t i;
	xilinx_softc_t *sc;

#ifdef DEBUG_ERR
	log(LOG_INFO, "%s: Fifo error interrupt!\n", card->devname);
#endif

	/* Clear HDLC pending registers */
	sdla_bus_read_4(card->hw, XILINX_HDLC_TX_INTR_PENDING_REG, &tx_status);
	sdla_bus_read_4(card->hw, XILINX_HDLC_RX_INTR_PENDING_REG, &rx_status);

	if (card->state != WAN_CONNECTED) {
		log(LOG_INFO, "%s: Warning: Ignoring Error Intr: link disc!\n",
		    card->devname);
		return (0);
	}

	tx_status &= card->u.xilinx.active_ch_map;
	rx_status &= card->u.xilinx.active_ch_map;

	if (tx_status != 0) {
		for (i = 0; i < card->u.xilinx.num_of_time_slots; i++) {
			if (bit_test((u_int8_t *)&tx_status, i) &&
			    bit_test((u_int8_t *)&card->u.xilinx.logic_ch_map,
			    i)) {
				struct ifnet	*ifp;

				sc = (xilinx_softc_t *)
				    card->u.xilinx.dev_to_ch_map[i];
				if (!sc) {
					log(LOG_INFO, "Warning: ignoring tx "
					    "error intr: no dev!\n");
					continue;
				}

				ifp = (struct ifnet *)&sc->common.ifp;
#if 0
				if (!(ifp->if_flags & IFF_UP)) {
					log(LOG_INFO, "%s: Warning: ignoring "
					    "tx error intr: dev down 0x%X "
					    "UP=0x%X!\n", ifp->if_xname,
					    sc->common.state,
					    sc->ignore_modem);
					continue;
				}
#endif

				if (card->state != WAN_CONNECTED) {
					log(LOG_INFO, "%s: Warning: ignoring "
					    "tx error intr: dev disc!\n",
					     ifp->if_xname);
					continue;
				}

#ifdef DEBUG_ERR
				log(LOG_INFO, "%s:%s: Warning TX Fifo Error "
				    "on LogicCh=%ld Slot=%d!\n",
				    card->devname, sc->if_name,
				    sc->logic_ch_num, i);
#endif
				xilinx_tx_fifo_under_recover(card, sc);
				err=EINVAL;
			}
		}
	}


	if (rx_status != 0) {
		for (i = 0; i < card->u.xilinx.num_of_time_slots; i++) {
			if (bit_test((u_int8_t *)&rx_status, i) &&
			    bit_test((u_int8_t *)&card->u.xilinx.logic_ch_map,
			    i)) {
				struct ifnet	*ifp;
				sc = (xilinx_softc_t *)
				    card->u.xilinx.dev_to_ch_map[i];
				if (!sc)
					continue;

				ifp = (struct ifnet *)&sc->common.ifp;
#if 0
				if (!(ifp->if_flags & IFF_UP)) {
					log(LOG_INFO, "%s: Warning: ignoring "
					    "rx error intr: dev down "
					    "0x%X UP=0x%X!\n", ifp->if_xname,
					    sc->common.state,
					    sc->ignore_modem);
					continue;
				}
#endif

				if (card->state != WAN_CONNECTED) {
					log(LOG_INFO, "%s: Warning: ignoring "
					    "rx error intr: dev disc!\n",
					    ifp->if_xname);
					continue;
				}

#ifdef DEBUG_ERR
				log(LOG_INFO, "%s:%s: Warning RX Fifo Error "
				    "on LCh=%ld Slot=%d RxDMA=%d\n",
				    card->devname, sc->if_name,
				     sc->logic_ch_num, i,
				     sc->rx_dma);
#endif

#if 0
{
				unsigned long dma_descr;
				unsigned int reg;
				dma_descr = (sc->logic_ch_num << 4) +
				    XILINX_RxDMA_DESCRIPTOR_HI;
				sdla_bus_read_4(card->hw, dma_descr, &reg);
				log(LOG_INFO, "%s: Hi Descriptor 0x%X\n",
				    sc->if_name, reg);
}
#endif

				bit_set((u_int8_t *)&sc->pkt_error,
				    WP_FIFO_ERROR_BIT);
				err = EINVAL;
			}
		}
	}

	return (err);
}


static void
front_end_interrupt(sdla_t *card, unsigned long reg)
{
	sdla_te_intr(card);
	handle_front_end_state(card);
	return;
}

/*
 * HARDWARE Interrupt Handlers
 */


/*
 * Main interrupt service routine.
 * Determine the interrupt received and handle it.
 */
static void
wp_xilinx_isr(sdla_t* card)
{
	int i;
	u_int32_t reg;
	u_int32_t dma_tx_reg, dma_rx_reg;
	xilinx_softc_t *sc;

	if (bit_test((u_int8_t *)&card->critical, CARD_DOWN)) {
		log(LOG_INFO, "%s: Card down, ignoring interrupt !!!!!!!!\n",
		    card->devname);
		return;
	}

	bit_set((u_int8_t *)&card->in_isr, 0);

/*	write_cpld(card, LED_CONTROL_REG, 0x0F);*/

	/*
	 * Disable all chip Interrupts  (offset 0x040)
	 *  -- "Transmit/Receive DMA Engine"  interrupt disable
	 *  -- "FiFo/Line Abort Error"        interrupt disable
	 */
	sdla_bus_read_4(card->hw, XILINX_CHIP_CFG_REG, &reg);

	if (bit_test((u_int8_t *)&reg, SECURITY_STATUS_FLAG)) {
		log(LOG_INFO, "%s: Critical: Chip Security Compromised!\n",
					card->devname);
		log(LOG_INFO, "%s: Disabling Driver!\n",
					card->devname);

		port_set_state(card, WAN_DISCONNECTED);
		disable_data_error_intr(card, CARD_DOWN);
		goto isr_end;
	}

	/*
	 * Note: If interrupts are received without pending flags, it usually
	 * indicates that the interrupt * is being shared.
	 */
	if (bit_test((u_int8_t *)&reg, FRONT_END_INTR_ENABLE_BIT)) {
		if (bit_test((u_int8_t *)&reg, FRONT_END_INTR_FLAG)) {
			front_end_interrupt(card, reg);
			if (card->u.xilinx.state_change_exit_isr) {
				card->u.xilinx.state_change_exit_isr = 0;
				/*
				 * The state change occured, skip all
				 * other interrupts
				 */
				goto isr_end;
			}
		}
	}

	/*
	 * Test Fifo Error Interrupt
	 * If set shutdown all interfaces and reconfigure
	 */
	if (bit_test((u_int8_t *)&reg, ERROR_INTR_ENABLE_BIT))
		if (bit_test((u_int8_t *)&reg, ERROR_INTR_FLAG))
			fifo_error_interrupt(card, reg);

	/*
	 * Checking for Interrupt source:
	 * 1. Receive DMA Engine
	 * 2. Transmit DMA Engine
	 * 3. Error conditions.
	 */
	if (bit_test((u_int8_t *)&reg, GLOBAL_INTR_ENABLE_BIT) &&
		bit_test((u_int8_t *)&reg, DMA_INTR_FLAG)) {

		/* Receive DMA Engine */
		sdla_bus_read_4(card->hw, XILINX_DMA_RX_INTR_PENDING_REG,
		    &dma_rx_reg);

		dma_rx_reg &= card->u.xilinx.active_ch_map;

		if (dma_rx_reg == 0)
			goto isr_rx;

		for (i = 0; i < card->u.xilinx.num_of_time_slots; i++) {
			if (bit_test((u_int8_t *)&dma_rx_reg, i) &&
				bit_test((u_int8_t *)
				    &card->u.xilinx.logic_ch_map, i)) {
				sc = (xilinx_softc_t *)
				    card->u.xilinx.dev_to_ch_map[i];
				if (!sc) {
					log(LOG_INFO, "%s: Error: No Dev for "
					    "Rx logical ch=%d\n",
					    card->devname, i);
					continue;
				}

				xilinx_dma_rx_complete(card, sc);
			}
		}
isr_rx:

		/* Transmit DMA Engine */
		sdla_bus_read_4(card->hw, XILINX_DMA_TX_INTR_PENDING_REG,
		    &dma_tx_reg);

		dma_tx_reg &= card->u.xilinx.active_ch_map;

		if (dma_tx_reg == 0)
			goto isr_tx;

		for (i = 0; i < card->u.xilinx.num_of_time_slots; i++) {
			if (bit_test((u_int8_t *)&dma_tx_reg, i) &&
				bit_test((u_int8_t *)
				     &card->u.xilinx.logic_ch_map, i)) {
				sc = (xilinx_softc_t *)
				    card->u.xilinx.dev_to_ch_map[i];
				if (!sc) {
					log(LOG_INFO, "%s: Error: No Dev for "
					    "Tx logical ch=%d\n",
					    card->devname, i);
					continue;
				}

				xilinx_dma_tx_complete(card, sc);
			}
		}
	}

isr_tx:

isr_end:

/*	write_cpld(card, LED_CONTROL_REG, 0x0E); */

	bit_clear((u_int8_t *)&card->in_isr, 0);
	return;
}


/*
 * TASK Functions and Triggers
 */

/*
 * port_set_state
 *
 * Set PORT state.
 *
 */
static void
port_set_state(sdla_t *card, int state)
{
	wanpipe_common_t	*common;

	if (card->state != state) {
		switch (state) {
		case WAN_CONNECTED:
			log(LOG_INFO, "%s: Link connected!\n", card->devname);
			aft_red_led_ctrl(card, AFT_LED_OFF);
			aft_green_led_ctrl(card, AFT_LED_ON);
			break;

		case WAN_CONNECTING:
			log(LOG_INFO, "%s: Link connecting...\n",
			    card->devname);
			aft_red_led_ctrl(card, AFT_LED_ON);
			aft_green_led_ctrl(card, AFT_LED_OFF);
			break;

		case WAN_DISCONNECTED:
			log(LOG_INFO, "%s: Link disconnected!\n",
			    card->devname);
			aft_red_led_ctrl(card, AFT_LED_ON);
			aft_green_led_ctrl(card, AFT_LED_OFF);
			break;
		}
		card->state = state;
		LIST_FOREACH(common, &card->dev_head, next) {
			struct ifnet *ifp = (struct ifnet *)&common->ifp;
			if (ifp)
				set_chan_state(card, ifp, state);
		}
	}
}


/*
 * handle_front_end_state
 */

static void
handle_front_end_state(void *card_id)
{
	sdla_t *card = (sdla_t *)card_id;

	if (card->front_end_status == FE_CONNECTED) {
		enable_data_error_intr(card);
		port_set_state(card, WAN_CONNECTED);
		card->u.xilinx.state_change_exit_isr = 1;
	} else {
		port_set_state(card, WAN_CONNECTING);
		disable_data_error_intr(card, LINK_DOWN);
		card->u.xilinx.state_change_exit_isr = 1;
	}
}

static unsigned char
read_cpld(sdla_t *card, unsigned short cpld_off)
{
	u_int16_t     org_off;
	u_int8_t      tmp;

	cpld_off &= ~BIT_DEV_ADDR_CLEAR;
	cpld_off |= BIT_DEV_ADDR_CPLD;

	/* Save the current address. */
	sdla_bus_read_2(card->hw, XILINX_MCPU_INTERFACE_ADDR, &org_off);

	sdla_bus_write_2(card->hw, XILINX_MCPU_INTERFACE_ADDR, cpld_off);

	sdla_bus_read_1(card->hw, XILINX_MCPU_INTERFACE, &tmp);

	/* Restore original address */
	sdla_bus_write_2(card->hw, XILINX_MCPU_INTERFACE_ADDR, org_off);

	return (tmp);
}

static unsigned char
write_cpld(sdla_t *card, unsigned short off, unsigned char data)
{
	u_int16_t org_off;

	off &= ~BIT_DEV_ADDR_CLEAR;
	off |= BIT_DEV_ADDR_CPLD;

	/* Save the current original address */
	sdla_bus_read_2(card->hw, XILINX_MCPU_INTERFACE_ADDR, &org_off);

	sdla_bus_write_2(card->hw, XILINX_MCPU_INTERFACE_ADDR, off);

	/* This delay is required to avoid bridge optimization
	 * (combining two writes together)*/
	DELAY(5);

	sdla_bus_write_1(card->hw, XILINX_MCPU_INTERFACE, data);

	/* This delay is required to avoid bridge optimization
	 * (combining two writes together)*/
	DELAY(5);

	/* Restore the original address */
	sdla_bus_write_2(card->hw, XILINX_MCPU_INTERFACE_ADDR, org_off);

	return (0);
}

static unsigned char
write_front_end_reg(void *card1, unsigned short off, unsigned char value)
{
	sdla_t *card = (sdla_t *)card1;

	off &= ~BIT_DEV_ADDR_CLEAR;
	sdla_bus_write_2(card->hw, XILINX_MCPU_INTERFACE_ADDR, off);
	/*
	 * These delays are required to avoid bridge optimization
	 * (combining two writes together)
	 */
	DELAY(5);
	sdla_bus_write_1(card->hw, XILINX_MCPU_INTERFACE, value);
	DELAY(5);

	return (0);
}


/*
 * Read TE1/56K Front end registers
 */
static unsigned char
read_front_end_reg(void *card1, unsigned short off)
{
	sdla_t* card = (sdla_t *)card1;
	u_int8_t	tmp;

	off &= ~BIT_DEV_ADDR_CLEAR;
	sdla_bus_write_2(card->hw, XILINX_MCPU_INTERFACE_ADDR, off);
	sdla_bus_read_1(card->hw, XILINX_MCPU_INTERFACE, &tmp);
	DELAY(5);

	return (tmp);
}


/*
 *    Run only after the front end comes up from down state.
 *
 *    Clean the DMA Tx/Rx pending interrupts.
 *       (Ignore since we will reconfigure
 *        all dma descriptors. DMA controler
 *        was already disabled on link down)
 *
 *    For all channels clean Tx/Rx Fifo
 *
 *    Enable DMA controler
 *        (This starts the fifo cleaning
 *         process)
 *
 *    For all channels reprogram Tx/Rx DMA
 *    descriptors.
 *
 *    Clean the Tx/Rx Error pending interrupts.
 *        (Since dma fifo's are now empty)
 *
 *    Enable global DMA and Error interrutps.
 *
 */

static void
enable_data_error_intr(sdla_t *card)
{
	wanpipe_common_t	*common;
	struct ifnet		*ifp;
	u_int32_t		reg;

	/* Clean Tx/Rx DMA interrupts */
	sdla_bus_read_4(card->hw, XILINX_DMA_RX_INTR_PENDING_REG, &reg);
	sdla_bus_read_4(card->hw, XILINX_DMA_TX_INTR_PENDING_REG, &reg);

	/* For all channels clean Tx/Rx fifos */
	LIST_FOREACH(common, &card->dev_head, next) {
		xilinx_softc_t *sc;

		ifp = (struct ifnet *)&common->ifp;
		if (!ifp || !ifp->if_softc)
			continue;
		sc = ifp->if_softc;
#if 0
		if (!(ifp->if_flags & IFF_UP))
			continue;
#endif

#ifdef DEBUG_INIT
		log(LOG_INFO, "%s: Init interface fifo no wait %s\n",
			sc->if_name, __FUNCTION__);
#endif
		xilinx_init_rx_dev_fifo(card, sc, WP_NO_WAIT);
		xilinx_init_tx_dev_fifo(card, sc, WP_NO_WAIT);
	}

	/*
	 * Enable DMA controler, in order to start the
	 * fifo cleaning
	 */
	sdla_bus_read_4(card->hw, XILINX_DMA_CONTROL_REG, &reg);
	bit_set((u_int8_t *)&reg, DMA_ENGINE_ENABLE_BIT);
	sdla_bus_write_4(card->hw, XILINX_DMA_CONTROL_REG, reg);

	/* For all channels clean Tx/Rx fifos */
	LIST_FOREACH(common, &card->dev_head, next) {
		xilinx_softc_t *sc;

		ifp = (struct ifnet *)&common->ifp;
		if (!ifp || ifp->if_softc == NULL)
			continue;
		sc = ifp->if_softc;
#if 0
		if (!(ifp->if_flags & IFF_UP))
			continue;
#endif


#ifdef DEBUG_INIT
		log(LOG_INFO, "%s: Init interface fifo %s\n",
		    sc->if_name, __FUNCTION__);
#endif

		xilinx_init_rx_dev_fifo(card, sc, WP_WAIT);
		xilinx_init_tx_dev_fifo(card, sc, WP_WAIT);

#ifdef DEBUG_INIT
		log(LOG_INFO, "%s: Clearing Fifo and idle_flag %s\n",
		    card->devname, sc->if_name);
#endif
		bit_clear((u_int8_t *)&sc->idle_start, 0);
	}

	/* For all channels, reprogram Tx/Rx DMA descriptors.
	 * For Tx also make sure that the BUSY flag is clear
	 * and previoulsy Tx packet is deallocated */
	LIST_FOREACH(common, &card->dev_head, next) {
		xilinx_softc_t *sc;

		ifp = (struct ifnet *)&common->ifp;
		if (!ifp || !ifp->if_softc)
			continue;
		sc = ifp->if_softc;
#if 0
		if (!(ifp->if_flags & IFF_UP)) {
			continue;
		}
#endif

#ifdef DEBUG_INIT
		log(LOG_INFO, "%s: Init interface %s\n",
		    sc->if_name, __FUNCTION__);
#endif

		if (sc->rx_dma_buf) {
			aft_reload_rx_dma_buff(sc, sc->rx_dma_buf);
			sc->rx_dma_buf = NULL;
		}

		xilinx_dma_rx(card, sc);

		if (sc->tx_dma_addr && sc->tx_dma_len) {
			sc->tx_dma_addr = 0;
			sc->tx_dma_len = 0;
		}

		if (sc->tx_dma_mbuf) {
			bus_dmamap_unload(sc->dmatag, sc->tx_dmamap);
			m_freem(sc->tx_dma_mbuf);
			sc->tx_dma_mbuf = NULL;
		}

		bit_clear((u_int8_t *)&sc->dma_status, TX_BUSY);
		bit_clear((u_int8_t *)&sc->idle_start, 0);

#ifdef DEBUG_INIT
		log(LOG_INFO, "%s: Clearing Fifo and idle_flag %s\n",
		    card->devname, sc->if_name);
#endif
	}

	/*
	 * Clean Tx/Rx Error interrupts, since fifos are now
	 * empty, and Tx fifo may generate an underrun which
	 * we want to ignore :)
	 */
	sdla_bus_read_4(card->hw, XILINX_HDLC_RX_INTR_PENDING_REG, &reg);
	sdla_bus_read_4(card->hw, XILINX_HDLC_TX_INTR_PENDING_REG, &reg);

	/* Enable Global DMA and Error Interrupts */
	reg = 0;
	sdla_bus_read_4(card->hw, XILINX_CHIP_CFG_REG, &reg);
	bit_set((u_int8_t *)&reg, GLOBAL_INTR_ENABLE_BIT);
	bit_set((u_int8_t *)&reg, ERROR_INTR_ENABLE_BIT);
	sdla_bus_write_4(card->hw, XILINX_CHIP_CFG_REG, reg);

	return;
}

static void
disable_data_error_intr(sdla_t *card, unsigned char event)
{
	u_int32_t reg;

	sdla_bus_read_4(card->hw, XILINX_CHIP_CFG_REG, &reg);
	bit_clear((u_int8_t *)&reg, GLOBAL_INTR_ENABLE_BIT);
	bit_clear((u_int8_t *)&reg, ERROR_INTR_ENABLE_BIT);
	if (event == DEVICE_DOWN)
		bit_clear((u_int8_t *)&reg, FRONT_END_INTR_ENABLE_BIT);

	sdla_bus_write_4(card->hw, XILINX_CHIP_CFG_REG, reg);

	sdla_bus_read_4(card->hw, XILINX_DMA_CONTROL_REG, &reg);
	bit_clear((u_int8_t *)&reg, DMA_ENGINE_ENABLE_BIT);
	sdla_bus_write_4(card->hw, XILINX_DMA_CONTROL_REG, reg);

}

static void
xilinx_init_tx_dma_descr(sdla_t *card, xilinx_softc_t *sc)
{
	unsigned long dma_descr;
	unsigned long reg = 0;

	dma_descr = (sc->logic_ch_num << 4) + XILINX_TxDMA_DESCRIPTOR_HI;
	sdla_bus_write_4(card->hw, dma_descr, reg);
}



static void
xilinx_tx_fifo_under_recover(sdla_t *card, xilinx_softc_t *sc)
{
	struct ifnet *ifp = (struct ifnet *)&sc->common.ifp;
	u_int32_t reg = 0;
	unsigned long dma_descr;

#ifdef DEBUG_ERR
	log(LOG_INFO, "%s:%s: Tx Fifo Recovery \n",
	    card->devname, sc->if_name);
#endif

	/* Initialize Tx DMA descriptor: Stop DMA */
	dma_descr = (sc->logic_ch_num << 4) + XILINX_TxDMA_DESCRIPTOR_HI;
	sdla_bus_write_4(card->hw, dma_descr, reg);

	/* Clean the TX FIFO */
	xilinx_init_tx_dev_fifo(card, sc, WP_WAIT);
	if (sc->tx_dma_addr && sc->tx_dma_len) {
		sc->tx_dma_addr = 0;
		sc->tx_dma_len = 0;
	}

	/* Requeue the current tx packet, for re-transmission */
	if (sc->tx_dma_mbuf) {
		IF_PREPEND(&sc->wp_tx_pending_list,
		    (struct mbuf *)sc->tx_dma_mbuf);
		sc->tx_dma_mbuf = NULL;
	}

	/*
	 * Wake up the stack, because tx dma interrupt failed
	 */
	if (ifp)
		ifp->if_oerrors++;

#ifdef DEBUG_ERR
	log(LOG_INFO, "%s:%s: Tx Fifo Recovery: Restarting Transmission \n",
	    card->devname, sc->if_name);
#endif

	/* Re-start transmission */
	bit_clear((u_int8_t *)&sc->dma_status, TX_BUSY);
	if (!xilinx_dma_tx(card, sc)) {
		/* If we was able to transmit and the interface is set
		 * to OACTIVE remove this flag and let kernel try to
		 * transmit.
		 */
		if (ifp->if_flags & IFF_OACTIVE)
			ifp->if_flags &= ~IFF_OACTIVE;
	}
	return;
}

static int
xilinx_write_ctrl_hdlc(sdla_t *card, u_int32_t timeslot,
    u_int8_t reg_off, u_int32_t data)
{
	u_int32_t reg;
	u_int32_t ts_orig = timeslot;
	unsigned long timeout = ticks;

	if (timeslot == 0)
		timeslot = card->u.xilinx.num_of_time_slots - 2;
	else if (timeslot == 1)
		timeslot = card->u.xilinx.num_of_time_slots - 1;
	else
		timeslot -= 2;

	timeslot = timeslot << XILINX_CURRENT_TIMESLOT_SHIFT;
	timeslot &= XILINX_CURRENT_TIMESLOT_MASK;

	for (;;) {
		sdla_bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
		reg &= XILINX_CURRENT_TIMESLOT_MASK;

		if (reg == timeslot) {
			sdla_bus_write_4(card->hw, reg_off, data);
			return (0);
		}

		if ((ticks-timeout) > 1) {
			log(LOG_INFO, "%s: Error: Access to timeslot %d "
			    "timed out!\n", card->devname, ts_orig);
			return (EIO);
		}
	}

	return (EIO);
}

static int
set_chan_state(sdla_t *card, struct ifnet *ifp, int state)
{
	xilinx_softc_t *sc = ifp->if_softc;

	if (sc == NULL)
		return (0);

	if (state == WAN_CONNECTED) {
#ifdef DEBUG_INIT
		log(LOG_INFO, "%s: Setting idle_start to 0\n", sc->if_name);
#endif
		bit_clear((u_int8_t *)&sc->idle_start, 0);
		sc->common.ifp.pp_up(&sc->common.ifp);
	} else if (state == WAN_DISCONNECTED)
		sc->common.ifp.pp_down(&sc->common.ifp);

	return (0);
}


static char fifo_size_vector[] = {1, 2, 4, 8, 16, 32};
static char fifo_code_vector[] = {0, 1, 3, 7, 0xF, 0x1F};

static int
request_fifo_baddr_and_size(sdla_t *card, xilinx_softc_t *sc)
{
	unsigned char req_fifo_size, fifo_size;
	int i;

	/*
	 * Calculate the optimal fifo size based
	 * on the number of time slots requested
	 */

	if (IS_T1(&card->fe_te.te_cfg)) {
		if (sc->num_of_time_slots == NUM_OF_T1_CHANNELS)
			req_fifo_size = 32;
		else if (sc->num_of_time_slots == 1)
			req_fifo_size = 1;
		else if (sc->num_of_time_slots == 2 ||
		    sc->num_of_time_slots == 3)
			req_fifo_size = 2;
		else if (sc->num_of_time_slots >= 4 &&
		    sc->num_of_time_slots <= 7)
			req_fifo_size = 4;
		else if (sc->num_of_time_slots >= 8 &&
		    sc->num_of_time_slots <= 15)
			req_fifo_size = 8;
		else if (sc->num_of_time_slots >= 16 &&
		    sc->num_of_time_slots <= 23)
			req_fifo_size = 16;
		else {
			log(LOG_INFO, "%s: Invalid number of timeslots %d\n",
			    card->devname, sc->num_of_time_slots);
			return (EINVAL);
		}
	} else {
		if (sc->num_of_time_slots == (NUM_OF_E1_CHANNELS-1))
			req_fifo_size = 32;
		else if (sc->num_of_time_slots == 1)
			req_fifo_size = 1;
		else if (sc->num_of_time_slots == 2 ||
		    sc->num_of_time_slots == 3)
			req_fifo_size = 2;
		else if (sc->num_of_time_slots >= 4 &&
		    sc->num_of_time_slots <= 7)
			req_fifo_size = 4;
		else if (sc->num_of_time_slots >= 8 &&
		    sc->num_of_time_slots <= 15)
			req_fifo_size = 8;
		else if (sc->num_of_time_slots >= 16 &&
		    sc->num_of_time_slots <= 31)
			req_fifo_size = 16;
		else {
			log(LOG_INFO,
			    "%s:%s: Invalid number of timeslots %d\n",
			    card->devname, sc->if_name, sc->num_of_time_slots);
			return (EINVAL);
		}
	}

#ifdef DEBUG_INIT
	log(LOG_INFO, "%s:%s: Optimal Fifo Size =%d  Timeslots=%d \n",
	    card->devname, sc->if_name, req_fifo_size, sc->num_of_time_slots);
#endif
	fifo_size = map_fifo_baddr_and_size(card, req_fifo_size,
	    &sc->fifo_base_addr);

	if (fifo_size == 0 || sc->fifo_base_addr == 31) {
		log(LOG_INFO, "%s:%s: Error: Failed to obtain fifo size %d "
		    "or addr %d\n", card->devname, sc->if_name, fifo_size,
		    sc->fifo_base_addr);
		return (EINVAL);
	}

#ifdef DEBUG_INIT
	log(LOG_INFO, "%s:%s: Optimal Fifo Size =%d TS=%d New Fifo Size=%d\n",
	    card->devname, sc->if_name, req_fifo_size, sc->num_of_time_slots,
	    fifo_size);
#endif

	for (i = 0; i < sizeof(fifo_size_vector); i++) {
		if (fifo_size_vector[i] == fifo_size) {
			sc->fifo_size_code = fifo_code_vector[i];
			break;
		}
	}

	if (fifo_size != req_fifo_size)
		log(LOG_INFO, "%s:%s: WARN: Failed to obtain the req "
		    "fifo %d got %d\n", card->devname, sc->if_name,
		    req_fifo_size, fifo_size);

#ifdef DEBUG_INIT
	log(LOG_INFO, "%s: %s:Fifo Size=%d  TS=%d Fifo Code=%d Addr=%d\n",
	    card->devname, sc->if_name, fifo_size, sc->num_of_time_slots,
	    sc->fifo_size_code, sc->fifo_base_addr);
#endif
	sc->fifo_size = fifo_size;

	return (0);
}


static int
map_fifo_baddr_and_size(sdla_t *card, unsigned char fifo_size,
    unsigned char *addr)
{
	u_int32_t reg = 0;
	int i;

	for (i = 0; i < fifo_size; i++)
		bit_set((u_int8_t *)&reg, i);

#ifdef DEBUG_INIT
	log(LOG_INFO, "%s: Trying to MAP 0x%X  to 0x%lX\n",
	     card->devname, reg, card->u.xilinx.fifo_addr_map);
#endif
	for (i = 0; i < 32; i += fifo_size) {
		if (card->u.xilinx.fifo_addr_map & (reg << i))
			continue;
		card->u.xilinx.fifo_addr_map |= reg << i;
		*addr = i;

#ifdef DEBUG_INIT
		log(LOG_INFO, "%s: Card fifo Map 0x%lX Addr =%d\n",
		    card->devname, card->u.xilinx.fifo_addr_map, i);
#endif
		return (fifo_size);
	}

	if (fifo_size == 1)
		return (0);

	fifo_size = fifo_size >> 1;

	return map_fifo_baddr_and_size(card, fifo_size, addr);
}


static int
free_fifo_baddr_and_size(sdla_t *card, xilinx_softc_t *sc)
{
	u_int32_t reg = 0;
	int i;

	for (i = 0; i < sc->fifo_size; i++)
		bit_set((u_int8_t *)&reg, i);

#ifdef DEBUG_INIT
	log(LOG_INFO, "%s: Unmapping 0x%X from 0x%lX\n", card->devname,
	    reg << sc->fifo_base_addr, card->u.xilinx.fifo_addr_map);
#endif
	card->u.xilinx.fifo_addr_map &= ~(reg << sc->fifo_base_addr);

#ifdef DEBUG_INIT
	log(LOG_INFO, "%s: New Map is 0x%lX\n",
		card->devname, card->u.xilinx.fifo_addr_map);
#endif

	sc->fifo_size = 0;
	sc->fifo_base_addr = 0;

	return (0);
}

static void
aft_red_led_ctrl(sdla_t *card, int mode)
{
	unsigned int led;

	sdla_bus_read_4(card->hw, XILINX_CHIP_CFG_REG, &led);

	if (mode == AFT_LED_ON)
		bit_clear((u_int8_t *)&led, XILINX_RED_LED);
	else if (mode == AFT_LED_OFF)
		bit_set((u_int8_t *)&led, XILINX_RED_LED);
	else {
		if (bit_test((u_int8_t *)&led, XILINX_RED_LED))
			bit_clear((u_int8_t *)&led, XILINX_RED_LED);
		else
			bit_set((u_int8_t *)&led, XILINX_RED_LED);
	}

	sdla_bus_write_4(card->hw, XILINX_CHIP_CFG_REG, led);
}

static void
aft_led_timer(void *data)
{
	sdla_t *card=(sdla_t *)data;
	unsigned int te_alarm;

	if (bit_test((u_int8_t *)&card->critical, CARD_DOWN))
		return;

	if (IS_TE1(&card->fe_te.te_cfg)) {
		int s = splnet();

		te_alarm = sdla_te_alarm(card, 0);
		te_alarm &= ~(BIT_OOSMF_ALARM|BIT_OOCMF_ALARM);

		if (!te_alarm) {
			if (card->state == WAN_CONNECTED) {
				aft_red_led_ctrl(card, AFT_LED_OFF);
				aft_green_led_ctrl(card, AFT_LED_ON);
			} else {
				aft_red_led_ctrl(card, AFT_LED_OFF);
				aft_green_led_ctrl(card, AFT_LED_TOGGLE);
			}

		} else if (te_alarm & (BIT_RED_ALARM|BIT_LOS_ALARM)) {
			/* Red or LOS Alarm solid RED */
			aft_red_led_ctrl(card, AFT_LED_ON);
			aft_green_led_ctrl(card, AFT_LED_OFF);
		} else if (te_alarm & BIT_OOF_ALARM) {
			/* OOF Alarm flashing RED */
			aft_red_led_ctrl(card, AFT_LED_TOGGLE);
			aft_green_led_ctrl(card, AFT_LED_OFF);
		} else if (te_alarm & BIT_AIS_ALARM) {
			/* AIS - Blue Alarm flasing RED and GREEN */
			aft_red_led_ctrl(card, AFT_LED_TOGGLE);
			aft_green_led_ctrl(card, AFT_LED_TOGGLE);
		} else if (te_alarm & BIT_YEL_ALARM) {
			/* Yellow Alarm */
			aft_red_led_ctrl(card, AFT_LED_ON);
			aft_green_led_ctrl(card, AFT_LED_ON);
		} else {

			/* Default case shouldn't happen */
			log(LOG_INFO, "%s: Unknown Alarm 0x%X\n",
			    card->devname, te_alarm);
			aft_red_led_ctrl(card, AFT_LED_ON);
			aft_green_led_ctrl(card, AFT_LED_ON);
		}

		splx(s);
		timeout_add_sec(&card->u.xilinx.led_timer, 1);
	}
}


int
aft_core_ready(sdla_t *card)
{
	u_int32_t reg;
	volatile unsigned char cnt = 0;

	for (;;) {
		sdla_bus_read_4(card->hw, XILINX_CHIP_CFG_REG, &reg);
		if (!bit_test((u_int8_t *)&reg, HDLC_CORE_READY_FLAG_BIT)) {
			/* The HDLC Core is not ready! we have
			** an error. */
			if (++cnt > 5)
				return  (EINVAL);
			else
				DELAY(500);
				/* WARNING: we cannot do this while in
				 * critical area */
		} else
			return (0);
	}

	return (EINVAL);
}
@


1.33
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.32 2014/12/05 15:50:04 mpi Exp $	*/
@


1.32
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.31 2014/09/14 14:17:25 jsg Exp $	*/
a48 1
#include <net/bpf.h>
@


1.31
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.30 2014/07/22 13:12:11 mpi Exp $	*/
d51 1
a52 2
#include <net/netisr.h>
#include <net/if_sppp.h>
d56 1
@


1.30
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.29 2014/07/12 18:48:52 tedu Exp $	*/
a43 1
#include <sys/proc.h>
@


1.29
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.28 2013/08/07 01:06:37 bluhm Exp $	*/
a54 1
#include <netinet/in_systm.h>
@


1.28
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.27 2012/09/19 22:37:23 jsg Exp $	*/
d355 1
a355 1
		free(sc, M_DEVBUF);
d430 1
a430 1
	free(sc, M_DEVBUF);
d2421 1
a2421 1
	free(sc->wp_rx_buffers, M_DEVBUF);
@


1.27
log
@ioctl requests are u_long not int, spotted via clang
ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.26 2011/09/18 11:17:57 miod Exp $	*/
a56 1
#include <netinet/in_var.h>
@


1.26
log
@Fix various format string types to as a minimum match the width of the
variables being processed.
ok bluhm@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.25 2011/07/07 19:09:10 henning Exp $	*/
d209 1
a209 1
static int	wan_xilinx_ioctl(struct ifnet *, int cmd, struct ifreq *);
d671 1
a671 1
wan_xilinx_ioctl(struct ifnet *ifp, int cmd, struct ifreq *ifr)
@


1.25
log
@i NEVER NEVER NEVER want to see ifqueue->ifq_len = anything. sorry, that is
horrid and must be wrong. now in this case it is actually harmless - but
setting them to 0 just after having malloc'd it with M_ZERO is pointless
to begin with. ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.24 2008/11/26 18:01:43 dlg Exp $	*/
d487 1
a487 1
		log(LOG_INFO, "%s:%s: Error invalid MTU %lu\n",
@


1.24
log
@dont have bpf.h expose the kernel ticks variable wherever it is includeing.

it is very confusing like this.

ok deraadt@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.23 2008/09/18 15:16:30 naddy Exp $	*/
a365 1
	sc->wp_tx_pending_list.ifq_len = 0;
a366 1
	sc->wp_tx_complete_list.ifq_len = 0;
@


1.23
log
@Introduce the infrastructure required to support hardware VLAN tag
stripping:  Add a field to the mbuf pkthdr to hold the tag and an
mbuf flag that tells if the tag is valid.  Inspired by FreeBSD.

Struct packing suggested by kettenis@@.   csum_flags is now 16 bits.
Adapt to this in the drivers.

ok reyk@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.22 2008/09/10 14:01:22 blambert Exp $	*/
d194 2
@


1.22
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.21 2007/10/08 04:15:15 krw Exp $	*/
d1980 2
a1981 1
	sc->tx_dma_mbuf->m_pkthdr.csum_flags = reg;
d1994 1
a1994 1
	unsigned long	reg = m->m_pkthdr.csum_flags;
d1997 1
@


1.21
log
@More simple memset(,0,) -> M_ZERO changes. In this batch move to
size(*p) as the first malloc() parameter where p is declared locally
and thus easy to check. Add M_ZERO to gpe_table allocation in acpi.c
even though there is no obvious bzero or memset nearby.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.20 2007/09/17 01:33:33 krw Exp $	*/
d3537 1
a3537 1
		timeout_add(&card->u.xilinx.led_timer, hz);
@


1.20
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.19 2007/09/12 13:56:40 chl Exp $	*/
d346 1
a346 1
	sc = malloc(sizeof(xilinx_softc_t), M_DEVBUF, M_NOWAIT);
a349 1
	memset(sc, 0, sizeof(xilinx_softc_t));
@


1.19
log
@s/atoin/ation/ typos

ok ray@@ cnst@@ moritz@@ sobrado@@ millert@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.18 2006/04/20 20:31:12 miod Exp $	*/
d2393 1
a2393 1
	buf = malloc(sizeof(*buf) * MAX_RX_BUF, M_DEVBUF, M_NOWAIT);
a2396 1
	bzero(buf, sizeof(*buf) * MAX_RX_BUF);
@


1.18
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.17 2005/12/13 05:56:22 canacar Exp $	*/
d1069 1
a1069 1
		log(LOG_INFO, "%s: Failed %s configuratoin!\n", card->devname,
@


1.17
log
@if_san_common.c
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.16 2005/11/08 20:51:00 canacar Exp $	*/
d488 1
a488 1
		log(LOG_INFO, "%s:%s: Error invalid MTU %d\n",
d1835 1
a1835 1
		    sc->if_name, MAX_XILINX_TX_DMA_SIZE);
@


1.16
log
@Remove some leftover debugging cruft and an unnecessary check.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.15 2005/11/08 20:23:42 canacar Exp $	*/
d2046 1
a2046 1
	if (ifp) {
a2047 2
		ifp->if_obytes += m->m_len;
	}
@


1.15
log
@Use bus_dma(9) in san(4).  Now works on amd64.  Still works on i386
as tested extensively by Greg Mortensen, many thanks.  ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.14 2005/09/17 15:10:31 canacar Exp $	*/
d2411 1
a2411 3
	if (sc->wp_rx_buffers == NULL) {
		printf("%s: release_rx_buffers called with no buffers!\n",
		       sc->if_name, MAX_RX_BUF, sizeof(*buf), (void *)buf);
a2412 1
	}
a2500 5
	if (buf->mbuf == NULL) {
		printf("%s: Error, buffer already free!\n");
		return;
	}

@


1.14
log
@KNF and remove function/line number references from log messages
no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.13 2005/09/14 05:10:24 canacar Exp $	*/
d100 9
a117 1
	struct ifqueue	wp_tx_free_list;
d120 5
a124 2
	struct ifqueue	wp_rx_free_list;
	struct ifqueue	wp_rx_complete_list;
d126 2
a130 2
	struct mbuf	*rx_dma_mbuf;

a163 1
	struct mbuf	*tx_idle_mbuf;
d244 1
a244 1
		    struct mbuf *, struct mbuf **, unsigned char *);
a274 2
static int	aft_alloc_rx_dma_buff(sdla_t *, xilinx_softc_t *, int);
static int	aft_init_requeue_free_m(xilinx_softc_t *, struct mbuf *);
d276 8
d362 1
a363 2
	IFQ_SET_MAXLEN(&sc->wp_tx_free_list, MAX_TX_BUF);
	sc->wp_tx_free_list.ifq_len = 0;
d368 2
a369 4
	IFQ_SET_MAXLEN(&sc->wp_rx_free_list, MAX_RX_BUF);
	sc->wp_rx_free_list.ifq_len = 0;
	IFQ_SET_MAXLEN(&sc->wp_rx_complete_list, MAX_RX_BUF);
	sc->wp_rx_complete_list.ifq_len = 0;
a404 3
	IF_PURGE(&sc->wp_rx_free_list);
	IF_PURGE(&sc->wp_rx_complete_list);
	IF_PURGE(&sc->wp_tx_free_list);
d414 1
d419 7
a425 4
	if (sc->tx_idle_mbuf) {
		log(LOG_INFO, "freeing idle tx dma mbuf\n");
		m_freem(sc->tx_idle_mbuf);
		sc->tx_idle_mbuf = NULL;
d428 1
a428 4
	if (sc->rx_dma_mbuf) {
		m_freem(sc->rx_dma_mbuf);
		sc->rx_dma_mbuf = NULL;
	}
d497 9
a505 3
	err = aft_alloc_rx_dma_buff(card, sc, card->u.xilinx.dma_per_ch);
	if (err)
		return (EINVAL);
d541 1
a541 1
	struct mbuf	*m;
d572 1
d577 8
a584 3
	if (sc->tx_idle_mbuf) {
		m_freem(sc->tx_idle_mbuf);
		sc->tx_idle_mbuf = NULL;
d587 3
a589 6
	/* If there is something left in rx_dma_buf, then
	** move it to rx_free_list. */
	if (sc->rx_dma_mbuf) {
		m = sc->rx_dma_mbuf;
		aft_init_requeue_free_m(sc, m);
		sc->rx_dma_mbuf = NULL;
d592 3
a594 7
	/* If there is something in rx_complete_list, then
	** move evething to rx_free_list. */
	for (;;) {
		IF_DEQUEUE(&sc->wp_rx_complete_list, m);
		if (m == NULL)
			break;
		IF_ENQUEUE(&sc->wp_rx_free_list, m);
d1672 1
a1672 1
	if (sc->rx_dma_mbuf) {
d1678 1
a1678 1
	IF_DEQUEUE(&sc->wp_rx_free_list, sc->rx_dma_mbuf);
d1680 7
a1686 6
	if (!sc->rx_dma_mbuf) {
		log(LOG_INFO, "%s: Critical Error no rx dma buf "
		    "Free=%d Comp=%d!\n", sc->if_name,
		    sc->wp_rx_free_list.ifq_len,
		    sc->wp_rx_complete_list.ifq_len);
		return (ENOMEM);
d1689 1
a1689 4
	rx_el = mtod(sc->rx_dma_mbuf, wp_rx_element_t *);
	sc->rx_dma_mbuf->m_len = sizeof(wp_rx_element_t);
	sc->rx_dma_mbuf->m_pkthdr.len = sc->rx_dma_mbuf->m_len;
	memset(rx_el, 0, sizeof(wp_rx_element_t));
d1691 2
a1692 2
	bus_addr = kvtop(mtod(sc->rx_dma_mbuf, caddr_t) +
	    sc->rx_dma_mbuf->m_len);
d1694 4
d1789 1
a1789 2
		log(LOG_INFO, "%s: Deallocating tx_dma_mbuf in %s\n",
		    sc->if_name, __FUNCTION__);
d1818 22
a1839 12
	} else {
		len = m->m_len;
		if (len > MAX_XILINX_TX_DMA_SIZE) {
			/* FIXME: We need to split this frame into
			 *        multiple parts.  For now though
			 *        just drop it :) */
			log(LOG_INFO, "%s: Tx len %d > %d (MAX TX DMA LEN)\n",
			    sc->if_name, len, MAX_XILINX_TX_DMA_SIZE);
			m_freem(m);
			bit_clear((u_int8_t *)&sc->dma_status, TX_BUSY);
			return (EINVAL);
		}
d1841 7
a1847 11
		if (mtod(m, u_int32_t)  & 0x03) {
			/* The mbuf should already be aligned */
			log(LOG_INFO, "%s: TX packet not aligned!\n",
			    sc->if_name, MAX_XILINX_TX_DMA_SIZE);
			m_freem(m);
			bit_clear((u_int8_t *)&sc->dma_status, TX_BUSY);
			return (EINVAL);
		}
			
		sc->tx_dma_addr = kvtop(mtod(m, caddr_t));
		sc->tx_dma_len = len;
d1850 3
d1856 1
a1856 4

		if (m)
			m_freem(m);

d1873 3
d1942 1
a1942 1
	if (!sc->tx_dma_mbuf) {
d1948 13
a1960 3
	} else {
		sc->tx_dma_addr = 0;
		sc->tx_dma_len = 0;
d1962 4
d1967 3
a1969 5
		/* Do not free the packet here,
		 * copy the packet dma info into csum
		 * field and let the bh handler analyze
		 * the transmitted packet.
		 */
d1971 3
a1973 12
		if (reg & TxDMA_HI_DMA_PCI_ERROR_RETRY_TOUT) {
			log(LOG_INFO, "%s:%s: PCI Error: 'Retry' "
			    "exceeds maximum (64k): Reg=0x%X!\n",
			    card->devname, sc->if_name, reg);

			if (++sc->pci_retry < 3) {
				bit_set((u_int8_t *)&reg,
				    TxDMA_HI_DMA_GO_READY_BIT);

				log(LOG_INFO, "%s: Retry: TXDMA_HI=0x%X "
				    "DmaDescr=0x%lX (%s)\n",
				    sc->if_name, reg, dma_descr, __FUNCTION__);
d1975 2
a1976 3
				sdla_bus_write_4(card->hw, dma_descr, reg);
				return;
			}
d1978 1
d1980 4
a1983 4
		sc->pci_retry = 0;
		sc->tx_dma_mbuf->m_pkthdr.csum_flags = reg;
		IF_ENQUEUE(&sc->wp_tx_complete_list, sc->tx_dma_mbuf);
		sc->tx_dma_mbuf = NULL;
d1985 1
a1985 1
		bit_clear((u_int8_t *)&sc->dma_status, TX_BUSY);
d1987 1
a1987 2
		xilinx_process_packet(sc);
	}
d2071 1
a2072 1
	struct mbuf *m;
d2077 1
a2077 1
	if (!sc->rx_dma_mbuf) {
d2083 1
a2083 1
	rx_el = mtod(sc->rx_dma_mbuf, wp_rx_element_t *);
d2102 2
a2103 2
	m = sc->rx_dma_mbuf;
	sc->rx_dma_mbuf = NULL;
d2107 1
a2107 1
	IF_ENQUEUE(&sc->wp_rx_complete_list, m);
d2117 1
a2117 1
    struct mbuf *m, struct mbuf **new_m, unsigned char *pkt_error)
d2121 2
a2122 1
	wp_rx_element_t *rx_el = mtod(m, wp_rx_element_t *);
d2146 1
a2146 1
	if (rx_el->reg&RxDMA_HI_DMA_PCI_ERROR_MASK) {
d2257 5
a2265 4
		memset(mtod(m, caddr_t), 0, sizeof(wp_rx_element_t));
		m->m_len += len;
		m->m_pkthdr.len = m->m_len;
		m_adj(m, sizeof(wp_rx_element_t));
d2267 1
a2267 2

		aft_alloc_rx_dma_buff(card, sc, 1);
d2269 1
a2269 1
		struct mbuf	*m0;
d2273 1
a2273 2
		m0 = wan_mbuf_alloc(len);
		if (m0 == NULL) {
d2278 2
a2279 7
			goto rx_comp_error;
		}

		m0->m_len = m0->m_pkthdr.len = len;
		memcpy(mtod(m0, caddr_t), mtod(m, caddr_t) + m->m_len, len);
		*new_m = m0;
		aft_init_requeue_free_m(sc, m);
d2282 2
a2283 1
	return;
a2284 3
rx_comp_error:

	aft_init_requeue_free_m(sc, m);
d2387 21
a2407 1
aft_init_requeue_free_m(xilinx_softc_t *sc, struct mbuf *m)
d2409 1
a2409 1
	int err;
d2411 5
a2415 2
	m->m_data = (m->m_flags & M_EXT) ? m->m_ext.ext_buf : m->m_pktdat;
	m->m_pkthdr.len	= m->m_len = 0;
d2417 4
a2420 2
	memset(mtod(m, caddr_t), 0, sizeof(wp_rx_element_t));
	IF_ENQUEUE(&sc->wp_rx_free_list, m);
d2422 9
a2430 1
	return (err);
d2433 1
d2435 1
a2435 1
aft_alloc_rx_dma_buff(sdla_t *card, xilinx_softc_t *sc, int num)
d2437 30
a2466 2
	int i;
	struct mbuf *m;
d2468 5
a2472 6
	for (i = 0; i < num; i++) {
		m = wan_mbuf_alloc(sc->dma_mtu);
		if (m == NULL) {
			log(LOG_INFO, "%s: %s  no memory\n",
					sc->if_name, __FUNCTION__);
			return (ENOMEM);
d2474 2
a2475 1
		IF_ENQUEUE(&sc->wp_rx_free_list, m);
d2478 34
a2511 1
	return (0);
d2536 3
a2538 2
		IF_DEQUEUE(&sc->wp_rx_complete_list, m);
		if (m == NULL)
d2541 2
d2546 1
a2546 6
		/*
		 * The post function will take care of the skb and new_skb
		 * buffer.  If new_skb buffer exists, driver must pass it up
		 * the stack, or free it
		 */
		xilinx_rx_post_complete(sc->common.card, sc, m, &new_m,
d2673 2
a2674 2
				    "on LCh=%ld Slot=%d RxCL=%d RxFL=%d "
				    "RxDMA=%d\n", card->devname, sc->if_name,
a2675 2
				     sc->wp_rx_complete_list.ifq_len,
				     sc->wp_rx_free_list.ifq_len,
d2906 2
a2907 1
static void handle_front_end_state(void *card_id)
d3124 3
a3126 7
		if (sc->rx_dma_mbuf) {
			wp_rx_element_t *rx_el;
			struct mbuf *m = sc->rx_dma_mbuf;

			sc->rx_dma_mbuf = NULL;
			rx_el = mtod(m, wp_rx_element_t *);
			aft_init_requeue_free_m(sc, m);
d3137 1
@


1.13
log
@decrease RX copy treshold to MHLEN to prevent
unnecessary copying if already allocating a cluster.
fix a comment and remove a bogus check while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.12 2005/09/04 18:27:28 brad Exp $	*/
a302 1

d307 1
a307 1
	} else {
a308 1
	}
d331 1
a331 1
	if (sc == NULL) {
d333 1
a333 1
	}
a342 1

d344 1
a344 1
	sc->first_time_slot=-1;
d361 1
d383 1
d418 1
d422 1
a434 1
	return;
d446 1
d469 2
a470 1
	if (card->state != WAN_DISCONNECTED) {
d472 1
a472 1
	}
d475 1
d487 1
a487 1
	if (err) {
a488 1
	}
d491 1
a491 1
	if (err) {
a492 1
	}
d515 1
d527 1
a527 1
	if (card->state == WAN_DISCONNECTED) {
d529 1
a529 1
	}
d542 1
a542 1
	if (IS_TE1(&card->fe_te.te_cfg)) {
a543 1
	}
d604 1
a604 1
	if (m == NULL) {
a607 1
	}
a617 1

d629 1
a629 1
			if (!err && !IF_QFULL(&sc->wp_tx_pending_list)) {
d635 1
a635 1
			}
d643 1
d664 1
a664 1
	if (!sc) {
d666 1
a666 1
	}
d669 2
a670 3
	switch (cmd)
	{
		case SIOC_WANPIPE_PIPEMON:
d672 2
a673 2
			if ((err = suser(curproc, 0)) != 0)
				break;
d675 2
a676 3
			if (IF_QFULL(&sc->udp_queue)) {
				return (EBUSY);
			}
d678 6
a683 7
			/*
			 * For performance reasons test the critical
			 * here before spin lock
			 */
			if (bit_test((u_int8_t *)&card->in_isr, 0)) {
				return (EBUSY);
			}
d685 3
a687 11
			m = wan_mbuf_alloc(sizeof(wan_udp_pkt_t));
			if (m == NULL) {
				return (ENOMEM);
			}
			wan_udp_pkt = mtod(m, wan_udp_pkt_t *);
			if (copyin(ifr->ifr_data, &wan_udp_pkt->wan_udp_hdr,
			    sizeof(wan_udp_hdr_t))) {
				m_freem(m);
				return (EFAULT);
			}
			IF_ENQUEUE(&sc->udp_queue, m);
d689 7
a695 1
			process_udp_mgmt_pkt(card, ifp, sc, 1);
d697 1
a697 5
			if (copyout(&wan_udp_pkt->wan_udp_hdr, ifr->ifr_data,
			    sizeof(wan_udp_hdr_t))) {
				m_freem(m);
				return (EFAULT);
			}
d699 2
a700 1
			IF_DEQUEUE(&sc->udp_queue, m);
d702 6
a707 1
			return (0);
d709 4
a712 5
		default:
			if (card->ioctl) {
				err = card->ioctl(ifp, cmd, ifr);
			}
			break;
a802 1

a815 1

a826 1

d865 1
a865 1
				if (m0) {
a866 1
				}
d892 2
a893 2
					    &wan_udp_pkt->wan_udp_cmd,
					    &wan_udp_pkt->wan_udp_data[0]);
a932 1

d1045 1
a1045 1
	if (err != 0) {
a1048 2
	}

d1072 2
a1073 1
	} else {
d1075 2
a1076 2
		log(LOG_INFO, "%s: HDLC Core Ready 0x%08X\n",
		    card->devname, reg);
a1077 1
 }
d1179 1
a1179 1
	if (!IS_TE1(&card->fe_te.te_cfg)) {
a1180 1
	}
d1230 2
a1231 2
				log(LOG_INFO, "%s: Channel/Time "
				    "Slot resource conflict!\n", card->devname);
d1248 1
a1248 1
	if (sc->logic_ch_num == -1) {
a1249 1
	}
d1260 1
a1260 1
			reg&=~TIMESLOT_BIT_MASK;
d1263 1
a1263 2
			reg &= HDLC_LCH_TIMESLOT_MASK; /* mask not valid bits */

d1270 1
a1270 2

			reg = sc->logic_ch_num&CONTROL_RAM_DATA_MASK;
d1273 1
a1273 1
			reg |= (sc->fifo_size_code&HDLC_FIFO_SIZE_MASK) <<
d1276 2
a1277 2
			reg |= (HARD_FIFO_CODE&HDLC_FIFO_SIZE_MASK) <<
			    HDLC_FIFO_SIZE_SHIFT;
d1280 2
a1281 2
			reg |= (sc->fifo_base_addr&HDLC_FIFO_BASE_ADDR_MASK) <<
			    HDLC_FIFO_BASE_ADDR_SHIFT;
d1310 1
a1310 1
				    (reg|(i<<TIMESLOT_BIT_SHIFT)));
d1373 2
a1374 2
	reg&=~HDLC_LOGIC_CH_BIT_MASK;
	reg&= HDLC_LCH_TIMESLOT_MASK;         /* mask not valid bits */
d1377 1
a1377 1
	    (reg|(sc->logic_ch_num&HDLC_LOGIC_CH_BIT_MASK)));
d1409 1
a1409 1
		reg &= HDLC_LCH_TIMESLOT_MASK;         /* mask not valid bits */
d1412 1
a1412 1
		    (reg | (sc->logic_ch_num&HDLC_LOGIC_CH_BIT_MASK)));
d1452 2
a1453 2
		for (i = 0; i < card->u.xilinx.num_of_time_slots; i++) {
			if (bit_test((u_int8_t *)&sc->time_slot_map, i)) {
d1455 1
a1455 2
			}
		}
d1461 2
a1462 2
		for (i = 0; i < card->u.xilinx.num_of_time_slots; i++) {
			if (bit_test((u_int8_t *)&sc->time_slot_map, i)) {
a1464 2
			}
		}
d1485 2
a1486 1
	log(LOG_DEBUG, "%s: Clearing RX Fifo DmaDescr=(0x%X) Reg=(0x%X) (%s)\n",
d1504 1
a1504 1
		if (timeout) {
d1508 1
a1508 1
		} else {
a1511 1
		}
d1513 1
a1513 1
	} else {
a1514 1
	}
d1534 2
a1535 1
	log(LOG_DEBUG, "%s: Clearing TX Fifo DmaDescr=(0x%X) Reg=(0x%X) (%s)\n",
d1552 1
a1552 1
		if (timeout) {
d1556 1
a1556 1
		} else {
a1559 1
		}
d1561 1
a1561 1
	} else {
a1562 1
	}
d1612 1
a1612 1
       /* Select an HDLC logic channel for configuration */
d1619 1
a1619 1
	    (reg|(sc->logic_ch_num&HDLC_LOGIC_CH_BIT_MASK)));
d1636 2
a1637 1
static int xilinx_dma_rx(sdla_t *card, xilinx_softc_t *sc)
d1689 1
a1689 1
	reg&=~(RxDMA_LO_ALIGNMENT_BIT_MASK);
d1691 1
a1691 1
	dma_descr=(sc->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_LO;
a1776 1

d1807 2
a1808 3
			log(LOG_INFO, "%s: Tx len %d > %d (MAX TX DMA LEN) "
			    "(%s:%d)!\n", sc->if_name, len,
			    MAX_XILINX_TX_DMA_SIZE, __FUNCTION__, __LINE__);
d1816 2
a1817 3
			log(LOG_INFO, "%s: TX packet not aligned "
			    "(%s:%d)!\n", sc->if_name,
			    MAX_XILINX_TX_DMA_SIZE, __FUNCTION__, __LINE__);
d1831 1
a1831 1
		if (m) {
a1832 1
		}
d1856 1
a1856 1
	if (len & 0x03) {
a1857 1
	}
d1872 2
a1873 1
	reg |= (sc->fifo_size_code & DMA_FIFO_SIZE_MASK) << DMA_FIFO_SIZE_SHIFT;
d1911 1
a1911 1
/*      sdla_bus_read_4(card->hw, 0x78, &tmp1); */
d1917 2
a1918 2

		log(LOG_INFO, "%s: Critical Error: Tx DMA intr: no tx mbuf !\n",
a1921 1

a1933 1

a1959 1

a1961 1

d1980 1
a1980 1
		if (bit_test((u_int8_t *)&reg, TxDMA_HI_DMA_GO_READY_BIT)) {
a1983 1
		}
d1985 1
a1985 1
		if (reg & TxDMA_HI_DMA_DATA_LENGTH_MASK) {
a1987 1
		}
d1990 1
a1990 1
		if (reg&TxDMA_HI_DMA_PCI_ERROR_MASK) {
d1992 1
a1992 1
			if (reg & TxDMA_HI_DMA_PCI_ERROR_M_ABRT) {
d1996 2
a1997 2
			}
			if (reg & TxDMA_HI_DMA_PCI_ERROR_T_ABRT) {
d2001 1
a2001 1
			}
d2008 1
a2008 1
			if (reg & TxDMA_HI_DMA_PCI_ERROR_RETRY_TOUT) {
a2011 1
			}
d2034 1
a2034 1
		if (ifp->if_flags & IFF_OACTIVE) {
a2035 1
		}
d2050 2
a2051 1
		log(LOG_INFO, "%s: Critical Error: rx_dma_mbuf\n", sc->if_name);
a2117 2

		if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_M_ABRT) {
d2119 1
d2122 2
a2123 4
#endif
		}
		if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_T_ABRT) {
#ifdef DEBUG_ERR
d2126 2
a2127 4
#endif
		}
		if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_DS_TOUT) {
#ifdef DEBUG_ERR
d2130 2
a2131 4
#endif
		}
		if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_RETRY_TOUT) {
#ifdef DEBUG_ERR
d2134 1
a2134 3
#endif
		}
#ifdef DEBUG_ERR
d2139 2
a2140 1
		    ifp->if_ierrors++;
d2161 2
a2162 1
		if (ifp) ifp->if_ierrors++;
d2174 1
a2174 1
			    ifp->if_ierrors++;
d2191 1
d2197 1
a2197 1
		if (data_error) {
a2198 1
		}
a2231 3
#if 0
		memset(&skb->cb[0], 0, sizeof(wp_rx_element_t));
#endif
d2286 1
a2286 1
	if (err) {
a2287 1
	}
d2297 1
a2297 1
	if (logic_ch == -1) {
a2298 1
	}
a2321 1

d2337 1
a2337 1
			if (card->u.xilinx.dev_to_ch_map[logic_ch]) {
a2338 1
			}
d2368 1
a2368 1
	int			err;
d2370 1
a2370 1
	m->m_data	= (m->m_flags & M_EXT) ? m->m_ext.ext_buf : m->m_pktdat;
d2375 1
d2407 1
d2535 1
a2535 1
				if (!sc) {
a2536 1
				}
d2544 2
a2545 1
					    sc->common.state, sc->ignore_modem);
d2571 1
a2571 1
				dma_descr=(sc->logic_ch_num<<4) +
d2607 2
a2608 1
static void wp_xilinx_isr(sdla_t* card)
d2665 2
a2666 2
	if (bit_test((u_int8_t *)&reg, ERROR_INTR_ENABLE_BIT)) {
		if (bit_test((u_int8_t *)&reg, ERROR_INTR_FLAG)) {
a2667 2
		}
	}
a2677 1

d2684 1
a2684 1
		if (dma_rx_reg == 0) {
a2685 1
		}
d2711 1
a2711 1
		if (dma_tx_reg == 0) {
a2712 1
		}
d2783 1
a2783 1
			if (ifp) {
a2784 1
			}
d2827 1
d2856 1
d2921 2
a2922 1
static void enable_data_error_intr(sdla_t *card)
d2941 1
a2941 1
		if (!(ifp->if_flags & IFF_UP)) {
a2942 1
		}
d2970 1
a2970 1
		if (!(ifp->if_flags & IFF_UP)) {
a2971 1
		}
d3059 2
a3060 1
static void disable_data_error_intr(sdla_t *card, unsigned char event)
d3067 1
a3067 1
	if (event == DEVICE_DOWN) {
d3069 1
a3069 1
	}
d3084 1
a3084 1
	dma_descr=(sc->logic_ch_num << 4) + XILINX_TxDMA_DESCRIPTOR_HI;
d3098 2
a3099 1
	log(LOG_INFO, "%s:%s: Tx Fifo Recovery \n", card->devname, sc->if_name);
d3123 2
a3124 1
	if (ifp) ifp->if_oerrors++;
d3138 1
a3138 1
		if (ifp->if_flags & IFF_OACTIVE) {
a3139 1
		}
d3152 1
a3152 1
	if (timeslot == 0) {
d3154 1
a3154 1
	} else if (timeslot == 1) {
d3156 1
a3156 1
	} else {
a3157 1
	}
d3186 1
a3186 1
	if (sc == NULL) {
d3188 1
a3188 1
	}
d3205 2
a3206 1
static int request_fifo_baddr_and_size(sdla_t *card, xilinx_softc_t *sc)
d3217 1
a3217 2

		if (sc->num_of_time_slots == NUM_OF_T1_CHANNELS) {
d3219 1
a3219 1
		} else if (sc->num_of_time_slots == 1) {
d3221 2
a3222 2
		} else if (sc->num_of_time_slots == 2 ||
		    sc->num_of_time_slots == 3) {
d3224 2
a3225 2
		} else if (sc->num_of_time_slots >= 4 &&
		    sc->num_of_time_slots <= 7) {
d3227 2
a3228 2
		} else if (sc->num_of_time_slots >= 8 &&
		    sc->num_of_time_slots <= 15) {
d3230 2
a3231 2
		} else if (sc->num_of_time_slots >= 16 &&
		    sc->num_of_time_slots <= 23) {
d3233 1
a3233 1
		} else {
d3239 1
a3239 1
		if (sc->num_of_time_slots == (NUM_OF_E1_CHANNELS-1)) {
d3241 1
a3241 1
		} else if (sc->num_of_time_slots == 1) {
d3243 2
a3244 2
		} else if (sc->num_of_time_slots == 2 ||
		    sc->num_of_time_slots == 3) {
d3246 2
a3247 2
		} else if (sc->num_of_time_slots >= 4 &&
		    sc->num_of_time_slots <= 7) {
d3249 2
a3250 2
		} else if (sc->num_of_time_slots >= 8 &&
		    sc->num_of_time_slots <= 15) {
d3252 2
a3253 2
		} else if (sc->num_of_time_slots >= 16 &&
		    sc->num_of_time_slots <= 31) {
d3255 3
a3257 2
		} else {
			log(LOG_INFO, "%s:%s: Invalid number of timeslots %d\n",
d3269 1
d3290 1
a3290 1
	if (fifo_size != req_fifo_size) {
a3293 1
	}
d3313 1
a3313 1
	for (i = 0; i < fifo_size; i++) {
a3314 1
	}
d3321 1
a3321 1
		if (card->u.xilinx.fifo_addr_map & (reg << i)) {
a3322 1
		}
d3333 1
a3333 1
	if (fifo_size == 1) {
a3334 1
	}
d3348 1
a3348 1
	for (i = 0; i < sc->fifo_size; i++) {
a3349 1
	}
d3375 1
a3375 1
	if (mode == AFT_LED_ON) {
d3377 1
a3377 1
	} else if (mode == AFT_LED_OFF) {
d3379 2
a3380 2
	} else {
		if (bit_test((u_int8_t *)&led, XILINX_RED_LED)) {
d3382 1
a3382 1
		} else {
a3383 1
		}
d3395 1
a3395 1
	if (bit_test((u_int8_t *)&card->critical, CARD_DOWN)) {
a3396 1
	}
d3455 1
a3455 1
			if (++cnt > 5) {
d3457 1
a3457 1
			} else {
d3461 1
a3461 2
			}
		} else {
a3462 1
		}
@


1.12
log
@a couple typos
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.11 2005/09/01 23:35:42 canacar Exp $	*/
d97 1
a97 1
static int aft_rx_copyback = 1000;
a1697 6

	if (!bus_addr) {
		log(LOG_INFO, "%s: %s Critical error pci_map_single() "
		    "failed!\n", sc->if_name, __FUNCTION__);
		return EINVAL;
	}
@


1.11
log
@Make sure the packets are aligned for dma while copying,
cleanup extra alignment code, and check lengths properly while copying.
tested by Greg Mortensen thevision at pobox com
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.10 2005/04/25 17:55:51 brad Exp $	*/
d1803 1
a1803 1
	/* check queue pointers befor start transmittion */
d1831 1
a1831 1
			 *        multiple parts.  For now thought
d1843 1
a1843 1
			log(LOG_INFO, "%s: TX packed not aligned "
d1857 1
a1857 1
		    "to 32bit boudary!\n", card->devname);
d1869 1
a1869 1
	/* WARNING: Do ont use the "skb" pointer from
@


1.10
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.9 2005/04/05 20:11:10 canacar Exp $	*/
a166 5

	u_int8_t		tx_dma_status;
	bus_dma_segment_t	tx_dma_seg;
	int			tx_dma_rseg;
	caddr_t			tx_dma_vaddr;
a569 8
	if (bit_test((u_int8_t *)&sc->tx_dma_status, TX_DMA_BUF_INIT)){
		bus_dma_tag_t	dmat;

		sdla_getcfg(card->hw, SDLA_DMATAG, &dmat);
		bus_dmamem_unmap(dmat, sc->tx_dma_vaddr, sc->dma_mtu);
		bus_dmamem_free(dmat, &sc->tx_dma_seg, sc->tx_dma_rseg);
		bit_clear((u_int8_t *)&sc->tx_dma_status, TX_DMA_BUF_INIT);
	}
d1842 7
a1848 51
			if (!bit_test((u_int8_t *)&sc->tx_dma_status,
							TX_DMA_BUF_INIT)) {
				bus_dma_tag_t	dmat;
				int err;

				sdla_getcfg(card->hw, SDLA_DMATAG, &dmat);
				err = bus_dmamem_alloc(
						dmat,
						sc->dma_mtu,
						PAGE_SIZE,
						0,
						&sc->tx_dma_seg,
						1,
						&sc->tx_dma_rseg,
						BUS_DMA_NOWAIT);
				if (err) {
					log(LOG_INFO,
					"%s: Failed allocate DMA buffer!\n",
						sc->if_name);
					m_freem(m);
					bit_clear((u_int8_t *)&sc->dma_status,
								TX_BUSY);
					return (EINVAL);
				}
				err = bus_dmamem_map(
						dmat,
						&sc->tx_dma_seg,
						sc->tx_dma_rseg,
						sc->dma_mtu,
						(caddr_t*)&sc->tx_dma_vaddr,
						BUS_DMA_NOWAIT);
				if (err) {
					log(LOG_INFO,
					"%s: Failed to map DMA buffer!\n",
						sc->if_name);
					bus_dmamem_free(
						dmat,
						&sc->tx_dma_seg,
						sc->tx_dma_rseg);
					m_freem(m);
					bit_clear((u_int8_t *)&sc->dma_status,
								TX_BUSY);
					return (EINVAL);
				}
				bit_set((u_int8_t *)&sc->tx_dma_status,
							TX_DMA_BUF_INIT);
			}
			memcpy(sc->tx_dma_vaddr, mtod(m, caddr_t), m->m_len);
			sc->tx_dma_addr = kvtop(sc->tx_dma_vaddr);
		} else {
			sc->tx_dma_addr = kvtop(mtod(m, caddr_t));
d1850 2
@


1.9
log
@prevent non-root users to invoke wanpipe ioctls.
noticed by uwe@@, looks ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.8 2005/04/01 21:42:36 canacar Exp $	*/
d2038 1
a2038 1
		sc->tx_dma_mbuf->m_pkthdr.csum = reg;
d2054 1
a2054 1
	unsigned long	reg = m->m_pkthdr.csum;
@


1.8
log
@Improve san(4) driver:

* Some KNF, fix return values (from -Exxx to Exxx)
* Some string handling paranoia.
* Use ifconfig media options to switch between ppp and cHDLC modes,
  based on patch from claudio@@
* tcpdump works, patch from claudio@@
* ppp mode now works.

Lots of testing & feedback by Greg Mortensen,
Additional testing Sean Knox
ok alex@@, go go go deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.7 2005/03/01 18:37:07 mcbride Exp $	*/
d44 1
d685 3
@


1.7
log
@- make large packets work without hanging the interface
- make tcpdump attach correctly

by Alex Feldman prodded via Greg Mortensen <thevision@@pobox.com>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.6 2004/12/07 06:10:24 mcbride Exp $	*/
d373 10
d450 4
a453 4
	if (IS_TE1(&card->fe_te.te_cfg)) {
		return (sdla_te_setcfg(card, &common->ifm));
	}
	return (-EINVAL);
d480 1
a480 1
		return (-EINVAL);
d489 1
a489 1
		return (-EINVAL);
d494 1
a494 1
		return (-EINVAL);
d502 1
a502 1
		return (-EINVAL);
d618 1
a618 1
		return (-EINVAL);
d627 1
a627 1
		return (-EINVAL);
d656 1
a656 1
			return (-EBUSY);
d677 1
a677 1
		return (-ENODEV);
d686 1
a686 1
				return (-EBUSY);
d694 1
a694 1
				return (-EBUSY);
d699 1
a699 1
				return (-ENOMEM);
d705 1
a705 1
				return (-EFAULT);
d714 1
a714 1
				return (-EFAULT);
d753 3
a755 3
	if (m == NULL) {
		return (-EINVAL);
	}
d983 1
a983 1
		return (-EINVAL);
d1052 1
a1052 1
		/* return -EINVAL;*/
d1075 1
a1075 1
		return (-EINVAL);
d1200 1
a1200 1
		return (-EINVAL);
d1217 1
a1217 1
		return (-EINVAL);
d1257 1
a1257 1
				return (-EEXIST);
d1270 1
a1270 1
		return (-EBUSY);
d1680 1
a1680 1
		return -EFAULT;
d1687 1
a1687 1
		return (-EINVAL);
d1697 1
a1697 1
		return (-ENOMEM);
d1711 1
a1711 1
		return -EINVAL;
d1784 1
a1784 1
		return -EBUSY;
d1828 1
a1828 1
		return (-EFAULT);
d1835 1
a1835 1
		return (-ENOBUFS);
d1847 1
a1847 1
			return (-EINVAL);
d1873 1
a1873 1
					return (-EINVAL);
d1893 1
a1893 1
					return (-EINVAL);
d1915 1
a1915 1
		return (-EINVAL);
d2490 1
a2490 1
			return (-ENOMEM);
d2620 1
a2620 1
				err=-EINVAL;
d2680 1
a2680 1
				err = -EINVAL;
d3276 1
a3276 1
			return (-EIO);
d3280 1
a3280 1
	return (-EIO);
d3296 3
a3298 1
	}
d3338 1
a3338 1
			return (-EINVAL);
d3360 1
a3360 1
			return (-EINVAL);
d3374 1
a3374 1
		return (-EINVAL);
d3563 1
a3563 1
				return  (-EINVAL);
d3574 1
a3574 1
	return (-EINVAL);
@


1.6
log
@Cleanup. Rename some defines, add wp_lite_set_te1_cfg()
(used to change LBO and T1/E1 clock configurations)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.5 2004/11/10 10:14:47 grange Exp $	*/
d687 1
a687 1
			m = wan_mbuf_alloc();
d1770 1
d1773 1
a2319 1
		m_adj(m, sizeof(wp_rx_element_t));
d2322 1
d2331 1
a2331 1
		m0 = wan_mbuf_alloc();
d2476 1
a2476 1
		m = wan_mbuf_alloc();
@


1.5
log
@strncpy->strlcpy
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.4 2004/07/16 15:11:45 alex Exp $	*/
d342 2
a350 2
	ifp->if_softc = sc;
	sc->common.card	= card;
@


1.4
log
@Aft source update.
mcbride ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c,v 1.3 2004/06/28 01:16:30 mcbride Exp $	*/
d348 1
a348 1
	strncpy(sc->if_name, ifp->if_xname, IFNAMSIZ);
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_xilinx.c, v 1.2 2004/06/26 20:17:23 mcbride Exp $	*/
a35 1
#include </usr/include/bitstring.h>
d60 2
d167 4
d564 9
d862 2
a863 1
					wan_udp_pkt->wan_udp_aft_ismoredata = 0x01;
a1824 1

d1838 53
a1890 1
		sc->tx_dma_addr = kvtop(mtod(m, caddr_t));
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d7 1
a7 1
 * This code is written by Nenad Corbic <ncorbic@@sangoma.com> and 
d36 28
a63 28
# include </usr/include/bitstring.h>
# include <sys/types.h>
# include <sys/param.h>
# include <sys/systm.h>
# include <sys/syslog.h>
# include <sys/ioccom.h>
# include <sys/malloc.h>
# include <sys/errno.h>
# include <sys/mbuf.h>
# include <sys/socket.h>
# include <sys/kernel.h>
# include <sys/time.h>
# include <sys/timeout.h>

# include <net/bpf.h>
# include <net/if.h>
# include <net/if_media.h>
# include <net/netisr.h>
# include <net/if_sppp.h>
# include <netinet/in_systm.h>
# include <netinet/in.h>
# include <netinet/in_var.h>
# include <netinet/udp.h>
# include <netinet/ip.h>

# include <dev/pci/if_san_common.h>
# include <dev/pci/if_san_obsd.h>
# include <dev/pci/if_san_xilinx.h>
a64 1
/****** Defines & Macros ****************************************************/
d75 1
a75 1
enum { 
d86 1
a86 1
#undef DEB_XILINX    
d88 1
a88 1
#if 1 
d95 1
a95 1
static int aft_rx_copyback=1000;
a96 1
/******Data Structures*****************************************************/
d98 2
a99 1
/* This structure is placed in the private data area of the device structure.
d101 2
a102 1
 * structure will incorporate the card structure along with Protocol specific data
d104 2
a105 3
typedef struct 
{
	wanpipe_common_t 	common;
d108 1
a108 1
	struct ifqueue 	wp_tx_pending_list;
d110 2
a111 2
	struct ifqueue 	wp_rx_free_list;
	struct ifqueue 	wp_rx_complete_list;
d118 3
a120 3
	unsigned long 	time_slot_map;
	unsigned char 	num_of_time_slots;
	long          	logic_ch_num;
d123 1
a123 1
	unsigned char 	ignore_modem;
d126 1
a126 1
	unsigned long 	router_start_time;
d128 2
a129 2
	unsigned long 	tick_counter;		/* For 5s timeout counter */
	unsigned long 	router_up_time;
d131 3
a133 3
	unsigned char  	mc;			/* Mulitcast support on/off */
	unsigned char 	udp_pkt_src;		/* udp packet processing */
	unsigned short 	timer_int_enabled;
d135 1
a135 1
	unsigned char 	interface_down;
d137 2
a138 2
	u_int8_t 	gateway;
	u_int8_t 	true_if_encoding;
d140 1
a140 1
	char 		if_name[IFNAMSIZ+1];
d150 1
a150 1
	
d156 1
a156 1
	
d159 1
a159 1
	unsigned char 	fifo_size;
d167 1
a167 1
#define WAN_IFP_TO_SOFTC(ifp)	(xilinx_softc_t*)((ifp)->if_softc)
d175 1
a175 1
#define WP_WAIT 	0
d191 1
a191 1
static int 	wan_xilinx_release(sdla_t*, struct ifnet*);
d194 4
a197 4
static int 	wan_xilinx_up (struct ifnet*);
static int 	wan_xilinx_down(struct ifnet*);
static int 	wan_xilinx_ioctl(struct ifnet*, int cmd, struct ifreq*);
static int 	wan_xilinx_send (struct mbuf*, struct ifnet*);
d199 2
a200 2
static void 	handle_front_end_state(void*);
static void 	enable_timer(void*);
d203 1
a203 1
static void 	port_set_state (sdla_t*, int);
d206 1
a206 1
static void 	wp_xilinx_isr (sdla_t*);
d209 2
a210 3
static int 	process_udp_mgmt_pkt(sdla_t*, struct ifnet*,
				xilinx_softc_t*,
				int);
d212 1
a212 1
static void xilinx_process_packet(xilinx_softc_t*);
d214 53
a266 49
static int xilinx_chip_configure(sdla_t*);
static int xilinx_chip_unconfigure(sdla_t*);
static int xilinx_dev_configure(sdla_t*, xilinx_softc_t*);
static void xilinx_dev_unconfigure(sdla_t*, xilinx_softc_t*);
static int xilinx_dma_rx(sdla_t*, xilinx_softc_t*);
static void xilinx_dev_enable(sdla_t*, xilinx_softc_t*);
static void xilinx_dev_close(sdla_t*, xilinx_softc_t*);
static int xilinx_dma_tx (sdla_t*, xilinx_softc_t*);
static void xilinx_dma_tx_complete (sdla_t*, xilinx_softc_t*);
static void xilinx_dma_rx_complete (sdla_t*, xilinx_softc_t*);
static void xilinx_dma_max_logic_ch(sdla_t*);
static int xilinx_init_rx_dev_fifo(sdla_t*, xilinx_softc_t*, unsigned char);
static void xilinx_init_tx_dma_descr(sdla_t*, xilinx_softc_t*);
static int xilinx_init_tx_dev_fifo(sdla_t*, xilinx_softc_t*, unsigned char);
static void xilinx_tx_post_complete (sdla_t*, xilinx_softc_t*, struct mbuf*);
static void xilinx_rx_post_complete (sdla_t*, xilinx_softc_t*,
                                     struct mbuf*,
                                     struct mbuf**,
                                     unsigned char*);


static char request_xilinx_logical_channel_num (sdla_t*, xilinx_softc_t*, long*);
static void free_xilinx_logical_channel_num (sdla_t*, int);


static unsigned char read_cpld(sdla_t*, unsigned short);
static unsigned char write_cpld(sdla_t*, unsigned short,unsigned char);

static void front_end_interrupt(sdla_t*, unsigned long);
static void  enable_data_error_intr(sdla_t*);
static void  disable_data_error_intr(sdla_t*, unsigned char);

static void xilinx_tx_fifo_under_recover (sdla_t*, xilinx_softc_t*);

static int xilinx_write_ctrl_hdlc(sdla_t*, u_int32_t, u_int8_t, u_int32_t);

static int set_chan_state(sdla_t*, struct ifnet*, int);

static int fifo_error_interrupt(sdla_t*, unsigned long);
static int request_fifo_baddr_and_size(sdla_t*, xilinx_softc_t*);
static int map_fifo_baddr_and_size(sdla_t*, unsigned char, unsigned char*);
static int free_fifo_baddr_and_size (sdla_t*, xilinx_softc_t*);

static void aft_red_led_ctrl(sdla_t*, int);
static void aft_led_timer(void*);

static int aft_alloc_rx_dma_buff(sdla_t*, xilinx_softc_t*, int);
static int aft_init_requeue_free_m(xilinx_softc_t*, struct mbuf*);
static int aft_core_ready(sdla_t*);
d272 2
a273 2
static void wan_ifmedia_sts(struct ifnet*, struct ifmediareq*);
static int wan_ifmedia_upd(struct ifnet*);
d275 2
a276 1
static void xilinx_delay(int sec)
d279 2
a280 2
	unsigned long timeout=ticks;
	while ((ticks-timeout)<(sec*hz)){
d286 2
a287 12
/**SECTION*********************************************************
 *
 * Public Functions
 *
 ******************************************************************/

/*============================================================================
 * wan_xilinx_init - 
 *
 */

void* wan_xilinx_init (sdla_t* card)
d293 1
a293 1
	bit_clear((u_int8_t*)&card->critical, CARD_DOWN);
d298 1
a298 1
		
d301 1
a301 1
	if (IS_TE1(&card->fe_te.te_cfg)){
d307 1
a307 1
	}else{
a314 6
	
        card->del_if	 = &wan_xilinx_release;
        card->iface_up   = &wan_xilinx_up;
        card->iface_down = &wan_xilinx_down;
        card->iface_send = &wan_xilinx_send;
        card->iface_ioctl= &wan_xilinx_ioctl;
d316 7
a322 1
	write_cpld(card,LED_CONTROL_REG,0x0E);
d328 1
a328 1
	timeout_set(&card->u.xilinx.led_timer, aft_led_timer, (void*)card);
d332 2
a333 2
	if(sc == NULL){
		return NULL;
d336 2
a337 2
	ifp = (struct ifnet*)&sc->common.ifp;
	if (wanpipe_generic_register(card, ifp, card->devname)){
d339 1
a339 1
		return NULL;
d341 1
a341 1
	
d345 1
a345 1
	sc->common.card		= card;
d361 1
a361 1
	
d363 1
a363 1
	if (IS_TE1(&card->fe_te.te_cfg)){
d369 1
a369 1
	}else{
d371 2
a372 1
		** front end types. */
d374 1
a374 1
	return sc;
d377 2
a378 6
/*============================================================================
 * wan_xilinx_release
 *
 *
 */
static int wan_xilinx_release (sdla_t* card, struct ifnet* ifp)
d380 1
a380 1
	xilinx_softc_t* 	sc = ifp->if_softc;
d387 4
a390 4
        if (sc->tx_dma_addr && sc->tx_dma_len){
                sc->tx_dma_addr=0;
                sc->tx_dma_len=0;
        }
d392 1
a392 1
	if (sc->tx_dma_mbuf){
d395 1
a395 1
		sc->tx_dma_mbuf=NULL;
d398 1
a398 1
	if (sc->tx_idle_mbuf){
d401 1
a401 1
		sc->tx_idle_mbuf=NULL;
d404 4
a407 4
	if (sc->rx_dma_mbuf){
                m_freem(sc->rx_dma_mbuf);
		sc->rx_dma_mbuf=NULL;
        }
d411 1
a411 1
	return 0;
d414 2
a415 1
static void wan_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmreq)
d417 1
a417 1
	wanpipe_common_t	*common = (wanpipe_common_t*)ifp->if_softc;
d426 2
a427 1
static int wan_ifmedia_upd(struct ifnet *ifp)
d429 1
a429 1
	wanpipe_common_t	*common = (wanpipe_common_t*)ifp->if_softc;
d434 3
a436 3
	card = (sdla_t*)common->card;
	if (IS_TE1(&card->fe_te.te_cfg)){
		return sdla_te_setcfg(card, &common->ifm);
d438 1
a438 1
	return -EINVAL;
d442 3
a444 5
/**SECTION***********************************************************
 *
 * 	KERNEL Device Entry Interfaces
 *
 ********************************************************************/
d446 2
a447 7


/*============================================================================
 * wan_xilinx_up
 *
 */
static int wan_xilinx_up (struct ifnet* ifp)
d451 2
a452 2
	struct timeval 	tv;
	int		err = 0;
d456 3
a458 3
	card = (sdla_t*)sc->common.card;
	if (card->state != WAN_DISCONNECTED){
		return 0;
d462 1
a462 1
	if (!sc->dma_mtu){
d464 2
a465 4
			card->devname,
			sc->if_name,
			ifp->if_mtu);
		return -EINVAL;
d468 1
a468 1
#if defined(DEBUG_INIT)
d470 5
a474 7
			card->devname,
			card->u.xilinx.dma_per_ch,
			sc->dma_mtu);
#endif	
	err=aft_alloc_rx_dma_buff(card, sc, card->u.xilinx.dma_per_ch);
	if (err){
		return -EINVAL;
d477 3
a479 3
	err=xilinx_chip_configure(card);
	if (err){
		return -EINVAL;
d482 4
a485 4
        card->isr = &wp_xilinx_isr;
	
	err=xilinx_dev_configure(card, sc);
	if (err){
d487 1
a487 1
		return -EINVAL;
d497 2
a498 2
	xilinx_init_tx_dma_descr(card,sc);
	xilinx_dev_enable(card,sc);
d500 2
a501 2
	sc->ignore_modem=0x0F;
	bit_clear((u_int8_t*)&card->critical, CARD_DOWN);
d503 1
a503 1
	return err;
d506 2
a507 5
/*============================================================================
 * wan_xilinx_down
 *
 */
static int wan_xilinx_down (struct ifnet* ifp)
d510 3
a512 3
	sdla_t		*card = (sdla_t*)sc->common.card;
	struct mbuf 	*m;
	int 		s;
d514 2
a515 2
	if (card->state == WAN_DISCONNECTED){
		return 0;
d517 1
a517 1
	xilinx_dev_close(card,sc);
d519 4
a522 4
	/* Disable DMA ENGINE before we perform 
         * core reset.  Otherwise, we will receive
         * rx fifo errors on subsequent resetart. */
	disable_data_error_intr(card,DEVICE_DOWN);
d524 1
a524 1
	bit_set((u_int8_t*)&card->critical, CARD_DOWN);
d527 1
a527 1
	
d535 1
a535 6
	card->isr=NULL;
	
	if (sc->tx_dma_addr && sc->tx_dma_len){
                sc->tx_dma_addr=0;
                sc->tx_dma_len=0;
        }
d537 6
a542 1
	if (sc->tx_dma_mbuf){
d544 1
a544 1
		sc->tx_dma_mbuf=NULL;
d547 1
a547 1
	if (sc->tx_idle_mbuf){
d549 1
a549 1
		sc->tx_idle_mbuf=NULL;
d552 1
a552 1
	/* If there is something left in rx_dma_buf, then 
d554 2
a555 2
	if (sc->rx_dma_mbuf){
		m=sc->rx_dma_mbuf;
d557 3
a559 3
		sc->rx_dma_mbuf=NULL;
        }
	/* If there is something in rx_complete_list, then 
d561 1
a561 1
	for(;;){
d575 3
a577 3
	port_set_state(card,  WAN_DISCONNECTED);
	sc->ignore_modem=0x00;
	return 0;
d580 2
a581 6
/*============================================================================
 * wan_xilinx_send
 *
 *
 */
static int wan_xilinx_send (struct mbuf* m, struct ifnet* ifp)
d585 1
a585 1
	sdla_t *card = (sdla_t*)sc->common.card;
d591 1
a591 1
	if (m == NULL){
d594 1
a594 1
		return -EINVAL;
d597 5
a601 2
	if (card->state != WAN_CONNECTED){
		/* The card is still not ready to transmit... drop this packet! */
d603 1
a603 1
		return -EINVAL;
d605 1
a605 1
	}else {
d607 1
a607 1
		if (IF_QFULL(&sc->wp_tx_pending_list)){
d609 1
a609 1
#if defined(DEBUG_TX)
d613 10
a622 6
			/* TX pending queue is full. Try to send packet
			** from tx_pending queue (first) */
			err = xilinx_dma_tx(card,sc);
			if (!err && !IF_QFULL(&sc->wp_tx_pending_list)){
				/* On success, we have place for the new 
				** tx packet, try to send it now! */
d625 5
a629 3
			/* Tx pedning queue is full. I can't accept new
			** tx packet, drop this packet and set interface
			** queue to OACTIVE */
d632 2
a633 2
			return -EBUSY;
		}else{
d636 1
a636 1
			xilinx_dma_tx(card,sc);
d640 1
a640 1
	return 0;
d643 1
a643 9


/*========================================================================
 *
 * wan_xilinx_ioctl
 *
 *
 */
static int 
d646 1
a646 1
	xilinx_softc_t	*sc= (xilinx_softc_t*)ifp->if_softc;
d650 1
a650 1
	int err=0;
d652 2
a653 2
	if (!sc){
		return -ENODEV;
d655 1
a655 1
	card=(sdla_t*)sc->common.card;
d657 1
a657 1
	switch(cmd)
d661 2
a662 2
			if (IF_QFULL(&sc->udp_queue)){
				return -EBUSY;
d665 6
a670 4
			/* For performance reasons test the critical
			 * here before spin lock */
			if (bit_test((u_int8_t*)&card->in_isr, 0)){
				return -EBUSY;
d674 2
a675 2
			if (m == NULL){
				return -ENOMEM;
d677 3
a679 2
			wan_udp_pkt = mtod(m, wan_udp_pkt_t*);
			if (copyin(ifr->ifr_data, &wan_udp_pkt->wan_udp_hdr,sizeof(wan_udp_hdr_t))){
d681 1
a681 1
				return -EFAULT;
d685 1
a685 1
			process_udp_mgmt_pkt(card,ifp,sc,1);
d687 2
a688 1
			if (copyout(&wan_udp_pkt->wan_udp_hdr,ifr->ifr_data, sizeof(wan_udp_hdr_t))){
d690 1
a690 1
				return -EFAULT;
d695 1
a695 1
			return 0;
d698 1
a698 1
			if (card->ioctl){
d704 1
a704 1
	return err;
d707 1
a707 3
/*=============================================================================
 * process_udp_mgmt_pkt
 *
d711 3
a713 3
 * 	Line Tracing
 * 	Line/Hardware Statistics
 * 	Protocol Statistics
a716 1
 *
d718 3
a720 3
#if 1
static int process_udp_mgmt_pkt(sdla_t* card, struct ifnet* ifp,
				xilinx_softc_t* sc, int local_dev )
d723 1
a723 1
	unsigned short	buffer_length;
d725 2
a726 2
	wan_trace_t 	*trace_info=NULL;
	struct timeval 	tv;
d729 2
a730 2
	if (m == NULL){
		return -EINVAL;
d735 1
a735 2
   	{

d740 1
a740 1
		switch(wan_udp_pkt->wan_udp_command) {
d745 1
a745 1
			wan_udp_pkt->wan_udp_data_len=0;
d747 1
a747 1
	
d750 1
a750 1
	
d753 4
a756 3
			
			if (!bit_test((u_int8_t*)&trace_info->tracing_enabled, 0)){
						
d758 1
a758 1
					
d760 19
a778 14
				if (wan_udp_pkt->wan_udp_data[0] == 0){
					bit_clear((u_int8_t*)&trace_info->tracing_enabled, 1);
					log(LOG_INFO, "%s: ADSL L3 trace enabled!\n",
						card->devname);
				}else if (wan_udp_pkt->wan_udp_data[0] == 1){
					bit_clear((u_int8_t*)&trace_info->tracing_enabled,2 );
					bit_set((u_int8_t*)&trace_info->tracing_enabled,1);
					log(LOG_INFO, "%s: ADSL L2 trace enabled!\n",
							card->devname);
				}else{
					bit_clear((u_int8_t*)&trace_info->tracing_enabled, 1);
					bit_set((u_int8_t*)&trace_info->tracing_enabled,2);
					log(LOG_INFO, "%s: ADSL L1 trace enabled!\n",
							card->devname);
d780 2
a781 1
				bit_set ((u_int8_t*)&trace_info->tracing_enabled, 0);
d783 3
a785 3
			}else{
				log(LOG_INFO, "%s: Error: AFT trace running!\n",
						card->devname);
d788 1
a788 1
					
d792 1
a792 1
			
d794 9
a802 6
			
			if(bit_test((u_int8_t*)&trace_info->tracing_enabled, 0)) {
					
				bit_clear((u_int8_t*)&trace_info->tracing_enabled, 0);
				bit_clear((u_int8_t*)&trace_info->tracing_enabled, 1);
				bit_clear((u_int8_t*)&trace_info->tracing_enabled, 2);
d805 7
a811 5
							card->devname);
					
			}else{
				/* set return code to line trace already 
				   disabled */
d817 1
a817 1
	        case GET_TRACE_INFO:
d819 2
a820 1
			if(bit_test((u_int8_t*)&trace_info->tracing_enabled, 0)){
d822 3
a824 3
			}else{
				log(LOG_INFO, "%s: Error AFT trace not enabled\n",
						card->devname);
d831 1
a831 1
			wan_udp_pkt->wan_udp_aft_num_frames = 0;	
d833 2
a834 2
					
			while (!IF_IS_EMPTY(&trace_info->ifq)){
d836 4
a839 3
				if (m0 == NULL){	
					log(LOG_INFO, "%s: No more trace packets in trace queue!\n",
								card->devname);
d842 6
a847 2
				if ((WAN_MAX_DATA_SIZE - buffer_length) < m0->m_pkthdr.len){
					/* indicate there are more frames on board & exit */
d852 2
a853 4
				m_copydata(m0, 
					   0, 
					   m0->m_pkthdr.len, 
					   &wan_udp_pkt->wan_udp_data[buffer_length]);
d856 1
a856 1
				if (m0){
d870 2
a871 2
			*(unsigned long *)&wan_udp_pkt->wan_udp_data = 
					sc->router_up_time;	
d875 1
a875 1
	
d879 1
a879 1
 		case WAN_FE_FLUSH_PMON:
d882 2
a883 2
			if (IS_TE1(&card->fe_te.te_cfg)){
				sdla_te_udp(card, 
d886 10
a895 6
			}else{
				if (wan_udp_pkt->wan_udp_command == WAN_GET_MEDIA_TYPE){
		    			wan_udp_pkt->wan_udp_data_len = sizeof(unsigned char); 
					wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
				}else{
					wan_udp_pkt->wan_udp_return_code = WAN_UDP_INVALID_CMD;
a899 2


d901 4
a904 4
		   	wan_udp_pkt->wan_udp_aft_num_frames = WANCONFIG_AFT;
		    	wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
		    	wan_udp_pkt->wan_udp_data_len = 1;
		    	break;
d907 4
a910 4
		    	wan_udp_pkt->wan_udp_data[0] = WAN_PLATFORM_ID;
		    	wan_udp_pkt->wan_udp_return_code = WAN_CMD_OK;
		    	wan_udp_pkt->wan_udp_data_len = 1;
		    	break;
d915 4
a918 3
	
			log(LOG_INFO, "%s: Warning, Illegal UDP command attempted from network: %x\n",
				card->devname,wan_udp_pkt->wan_udp_command);
d920 2
a921 2
		} /* end of switch */
     	} /* end of else */
d924 1
a924 1
	return 1;
a926 8
#endif

/**SECTION**********************************************************
 *
 * 	FIRMWARE Specific Interface Functions
 *
 *******************************************************************/

d928 2
a929 4
/*============================================================================
 * xilinx_chip_configure
 *
 *
d932 2
a933 1
static int xilinx_chip_configure(sdla_t *card)
d935 3
a937 3
	u_int32_t reg,tmp;
	int err=0;
	u_int16_t adapter_type,adptr_security;
d939 2
a940 2
#if defined(DEBUG_INIT)
    	log(LOG_DEBUG, "Xilinx Chip Configuration. -- \n");
d944 2
a945 2
	sdla_bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
	
d947 12
a958 12
	if (IS_T1(&card->fe_te.te_cfg)){
		card->u.xilinx.num_of_time_slots=NUM_OF_T1_CHANNELS;
		bit_clear((u_int8_t*)&reg, INTERFACE_TYPE_T1_E1_BIT);
		bit_set((u_int8_t*)&reg, FRONT_END_FRAME_FLAG_ENABLE_BIT);
	}else if (IS_E1(&card->fe_te.te_cfg)){
		card->u.xilinx.num_of_time_slots=NUM_OF_E1_CHANNELS;
		bit_set((u_int8_t*)&reg, INTERFACE_TYPE_T1_E1_BIT);
		bit_set((u_int8_t*)&reg, FRONT_END_FRAME_FLAG_ENABLE_BIT);
	}else{
		log(LOG_INFO, "%s: Error: Xilinx doesn't support non T1/E1 interface!\n",
				card->devname);
		return -EINVAL;
d961 1
a961 1
	sdla_bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
d965 9
a973 9
        /* Reset PMC */
        sdla_bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
        bit_clear((u_int8_t*)&reg, FRONT_END_RESET_BIT);
        sdla_bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
        DELAY(1000);

        bit_set((u_int8_t*)&reg, FRONT_END_RESET_BIT);
        sdla_bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
        DELAY(100);
d975 1
a975 1
#if defined(DEBUG_INIT)
d980 3
a982 3
	sdla_bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
	bit_set((u_int8_t*)&reg, CHIP_RESET_BIT);
	sdla_bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
d987 1
a987 1
	bit_clear((u_int8_t*)&reg, CHIP_RESET_BIT);
d990 3
a992 3
	bit_clear((u_int8_t*)&reg, GLOBAL_INTR_ENABLE_BIT);
	bit_clear((u_int8_t*)&reg, ERROR_INTR_ENABLE_BIT);
	bit_clear((u_int8_t*)&reg, FRONT_END_INTR_ENABLE_BIT);
d994 1
a994 1
	sdla_bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
d1001 1
a1001 1
#if defined(DEBUG_INIT)
d1003 1
a1003 1
			card->devname,adapter_type);
d1006 1
a1006 1
	adptr_security = read_cpld(card,SECURITY_CPLD_REG);
d1010 2
a1011 2
#if defined(DEBUG_INIT)
	switch(adptr_security){
d1013 1
a1013 2
		log(LOG_INFO, "%s: Security 1 Line UnCh\n",
			card->devname);
d1016 1
a1016 2
		log(LOG_INFO, "%s: Security 1 Line Ch\n",
                        card->devname);
d1019 1
a1019 2
		log(LOG_INFO, "%s: Security 2 Line UnCh\n",
                        card->devname);
d1022 1
a1022 2
		log(LOG_INFO, "%s: Security 2 Line Ch\n",
                        card->devname);
d1025 3
a1027 3
		log(LOG_INFO, "%s: Error Invalid Security ID=0x%X\n",
                        card->devname,adptr_security);
		/*return -EINVAL;*/
d1032 3
a1034 3
	sdla_bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);		
	bit_set((u_int8_t*)&reg, XILINX_RED_LED);
	sdla_bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
d1037 2
a1038 2
	err=aft_core_ready(card);
	if (err != 0){
d1040 1
a1040 1
                                        card->devname);
d1043 1
a1043 1
	
d1045 1
a1045 1
                	        card->devname);
d1047 5
a1051 6
	if (sdla_te_config(card)){
       		log(LOG_INFO, "%s: Failed %s configuratoin!\n",
                                	card->devname,
                                	IS_T1(&card->fe_te.te_cfg)?"T1":"E1");
               	return -EINVAL;
       	}
d1055 2
a1056 2
	err=aft_core_ready(card);
	if (err != 0){
d1058 1
a1058 1
					card->devname);
d1060 1
a1060 1
		sdla_bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
d1063 1
a1063 1
		bit_set((u_int8_t*)&reg, CHIP_RESET_BIT);
d1065 4
a1068 4
		sdla_bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
		return err;
    	} else{
#if defined(DEBUG_INIT)
d1070 1
a1070 1
                                        card->devname,reg);
d1072 1
a1072 1
    	}
d1077 1
a1077 1
	reg=0;
d1082 2
a1083 1
	/* Enable global DMA engine and set to default
d1085 2
a1086 1
	 * change in dev configuration */
d1088 1
a1088 1
	bit_set((u_int8_t*)&reg, DMA_ENGINE_ENABLE_BIT);
d1090 2
a1091 2
#if defined(DEBUG_INIT)
    	log(LOG_INFO, "--- Setup DMA control Reg. -- \n");
d1094 1
a1094 1
	sdla_bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
d1096 1
a1096 1
#if defined(DEBUG_INIT)
d1102 2
a1103 2
	reg=0;
	sdla_bus_write_4(card->hw,XILINX_TIMESLOT_HDLC_CHAN_REG,reg);
d1105 1
a1105 1
    	/* Clear interrupt pending registers befor first interrupt enable */
d1108 6
a1113 6
	sdla_bus_read_4(card->hw,XILINX_HDLC_RX_INTR_PENDING_REG, &tmp);
	sdla_bus_read_4(card->hw,XILINX_HDLC_TX_INTR_PENDING_REG, &tmp);
	sdla_bus_read_4(card->hw,XILINX_CHIP_CFG_REG, (u_int32_t*)&reg);
	if (bit_test((u_int8_t*)&reg, DMA_INTR_FLAG)){
        	log(LOG_INFO, "%s: Error: Active DMA Interrupt Pending. !\n",
					card->devname);
d1115 1
a1115 1
	        reg = 0;
d1117 7
a1123 7
		bit_set((u_int8_t*)&reg, CHIP_RESET_BIT);
		sdla_bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
        	return err;
	}
	if (bit_test((u_int8_t*)&reg, ERROR_INTR_FLAG)){
        	log(LOG_INFO, "%s: Error: Active Error Interrupt Pending. !\n",
					card->devname);
d1127 3
a1129 3
		bit_set((u_int8_t*)&reg, CHIP_RESET_BIT);
		sdla_bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
		return err;
d1133 3
a1135 4
	/* Alawys disable global data and error
         * interrupts */
    	bit_clear((u_int8_t*)&reg, GLOBAL_INTR_ENABLE_BIT);
	bit_clear((u_int8_t*)&reg, ERROR_INTR_ENABLE_BIT); 
d1138 1
a1138 1
	bit_set((u_int8_t*)&reg, FRONT_END_INTR_ENABLE_BIT);
d1140 2
a1141 2
#if defined(DEBUG_INIT)
    	log(LOG_DEBUG, "--- Set Global Interrupts (0x%X)-- \n",reg);
d1146 1
d1148 1
a1148 3
	sdla_bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);

	return err;
d1151 2
a1152 7
/*============================================================================
 * xilinx_chip_unconfigure
 *
 *
 */

static int xilinx_chip_unconfigure(sdla_t *card)
d1155 3
a1157 3
 
        sdla_bus_write_4(card->hw,XILINX_TIMESLOT_HDLC_CHAN_REG,reg);
	sdla_bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
d1159 2
a1160 2
	reg=0;
	bit_set((u_int8_t*)&reg, CHIP_RESET_BIT);
d1162 2
a1163 2
	sdla_bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
	return 0;
d1166 2
a1167 8

/*============================================================================
 * xilinx_dev_configure
 *
 *
 */

static int xilinx_dev_configure(sdla_t *card, xilinx_softc_t *sc)
d1170 1
a1170 1
	long free_logic_ch,i;
d1174 2
a1175 2
	if (!IS_TE1(&card->fe_te.te_cfg)){
		return -EINVAL;
d1178 1
a1178 1
	if (IS_E1(&card->fe_te.te_cfg)){
d1180 3
a1182 5
			sc->if_name,
			sc->time_slot_map,
			sc->time_slot_map<<1);
		sc->time_slot_map=sc->time_slot_map<<1;
		bit_clear((u_int8_t*)&sc->time_slot_map, 0);
d1185 5
a1189 3
	/* Channel definition section. If not channels defined
	 * return error */
	if (sc->time_slot_map == 0){
d1191 2
a1192 2
				card->devname,sc->time_slot_map);
		return -EINVAL;
d1195 3
a1197 3
#if defined(DEBUG_INIT)
	log(LOG_INFO, "%s:%s: Active channels = 0x%lX\n",
		card->devname,sc->if_name,sc->time_slot_map);
d1201 2
a1202 1
	/* Check that the time slot is not being used. If it is
d1206 4
a1209 3
	 * and clean the time_slot_map */
	for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
		if (bit_test((u_int8_t*)&sc->time_slot_map, i)){
d1211 4
a1214 4
			if (sc->first_time_slot == -1){
#if defined(DEBUG_INIT)
				log(LOG_INFO, "%s: Setting first time slot to %ld\n",
						card->devname,i);
d1216 1
a1216 1
				sc->first_time_slot=i;
d1219 1
a1219 1
#if defined(DEBUG_INIT)
d1221 2
a1222 2
					card->devname, sc->if_name, 
				        IS_E1(&card->fe_te.te_cfg)?i:i+1);
d1224 7
a1230 5
			if (bit_test((u_int8_t*)&card->u.xilinx.time_slot_map, i)){
				log(LOG_INFO, "%s: Channel/Time Slot resource conflict!\n",
						card->devname);
				log(LOG_INFO, "%s: %s: Channel/Time Slot %ld, aready in use!\n",
						card->devname,sc->if_name,(i+1));
d1232 1
a1232 1
				return -EEXIST;
d1235 1
a1235 2
			/* Calculate the number of timeslots for this
                         * interface */
d1242 4
a1245 3
	sc->logic_ch_num=request_xilinx_logical_channel_num(card, sc, &free_logic_ch);
	if (sc->logic_ch_num == -1){
		return -EBUSY;
d1250 2
a1251 2
	for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
		if (bit_test((u_int8_t*)&sc->time_slot_map, i)){
d1253 1
a1253 1
			bit_set((u_int8_t*)&card->u.xilinx.time_slot_map, i);
d1255 2
a1256 1
			sdla_bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
d1259 2
a1260 2
			/*FIXME do not hardcode !*/
            		reg&= HDLC_LCH_TIMESLOT_MASK;         /* mask not valid bits */
d1265 2
a1266 3
				       XILINX_TIMESLOT_HDLC_CHAN_REG,
		                       (reg|(i<<TIMESLOT_BIT_SHIFT)));
		
d1268 2
a1269 1
			reg=sc->logic_ch_num&CONTROL_RAM_DATA_MASK;
d1272 2
a1273 1
			reg|=(sc->fifo_size_code&HDLC_FIFO_SIZE_MASK)<<HDLC_FIFO_SIZE_SHIFT;
d1275 3
a1277 3
	
			reg|=(HARD_FIFO_CODE&HDLC_FIFO_SIZE_MASK)<<HDLC_FIFO_SIZE_SHIFT;
#endif
d1279 2
a1280 2
			reg|=(sc->fifo_base_addr&HDLC_FIFO_BASE_ADDR_MASK)<<
						HDLC_FIFO_BASE_ADDR_SHIFT;
d1282 3
a1284 3
#if defined(DEBUG_INIT)
			log(LOG_INFO, "Setting Timeslot %ld to logic ch %ld Reg=0x%X\n",
				        i, sc->logic_ch_num,reg);
d1286 2
a1287 6

			xilinx_write_ctrl_hdlc(card, 
                                               i,
                                               XILINX_CONTROL_RAM_ACCESS_BUF,
					       reg);

d1291 1
a1291 1
	if (free_logic_ch != -1){
d1293 1
a1293 1
		char free_ch_used=0;
d1295 3
a1297 2
		for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
			if (!bit_test((u_int8_t*)&card->u.xilinx.time_slot_map, i)){
d1299 2
a1300 3
				sdla_bus_read_4(card->hw, 
                                                          XILINX_TIMESLOT_HDLC_CHAN_REG, 
							  &reg);
d1302 3
a1304 2
        		        reg&=~TIMESLOT_BIT_MASK;
		                reg&= HDLC_LCH_TIMESLOT_MASK;         /* mask not valid bits */
d1308 2
a1309 2
					       XILINX_TIMESLOT_HDLC_CHAN_REG,
					       (reg|(i<<TIMESLOT_BIT_SHIFT)));
d1311 1
a1311 2

				reg=free_logic_ch&CONTROL_RAM_DATA_MASK;
d1314 13
a1326 11
                                 * bind them to timeslot 31 and set the fifo
                                 * size to 32 byte = Code=0x00 */

	                        reg|=(FIFO_32B&HDLC_FIFO_SIZE_MASK)<<HDLC_FIFO_SIZE_SHIFT;

                        	reg|=(free_logic_ch&HDLC_FIFO_BASE_ADDR_MASK)<<
                                                HDLC_FIFO_BASE_ADDR_SHIFT;

#if defined(DEBUG_INIT)
				log(LOG_INFO, "Setting Timeslot %ld to free logic ch %ld Reg=0x%X\n",
                                        i, free_logic_ch,reg);
d1328 2
a1329 4
				xilinx_write_ctrl_hdlc(card, 
                                                       i,
                                                       XILINX_CONTROL_RAM_ACCESS_BUF,
						       reg);
d1331 1
a1331 1
				free_ch_used=1;
a1334 1

d1336 3
a1338 4
                 * to any timeslots */
		if (free_ch_used){

#if defined(DEBUG_INIT)
d1340 1
a1340 1
					sc->if_name,free_logic_ch);
d1346 4
a1349 1
			sdla_bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
d1351 2
a1352 2
			reg&=~HDLC_LOGIC_CH_BIT_MASK;
	        	reg&=HDLC_LCH_TIMESLOT_MASK;         /* mask not valid bits */
d1355 2
a1356 2
                        	XILINX_TIMESLOT_HDLC_CHAN_REG,
                        	(reg|(free_logic_ch&HDLC_LOGIC_CH_BIT_MASK)));
d1358 8
a1365 10
			reg=0;
			bit_clear((u_int8_t*)&reg, HDLC_RX_PROT_DISABLE_BIT);
                	bit_clear((u_int8_t*)&reg, HDLC_TX_PROT_DISABLE_BIT);

	        	bit_set((u_int8_t*)&reg, HDLC_RX_ADDR_RECOGN_DIS_BIT);

			xilinx_write_ctrl_hdlc(card,
                                               sc->first_time_slot,
                                               XILINX_HDLC_CONTROL_REG,
                                               reg);
d1373 1
a1373 1
    	reg&= HDLC_LCH_TIMESLOT_MASK;         /* mask not valid bits */
d1375 2
a1376 3
	sdla_bus_write_4(card->hw,
			XILINX_TIMESLOT_HDLC_CHAN_REG,
			(reg|(sc->logic_ch_num&HDLC_LOGIC_CH_BIT_MASK)));
d1378 1
a1378 1
	reg=0;
d1381 2
a1382 2
	bit_clear((u_int8_t*)&reg, HDLC_RX_PROT_DISABLE_BIT);
	bit_clear((u_int8_t*)&reg, HDLC_TX_PROT_DISABLE_BIT);
d1384 2
a1385 2
	bit_set((u_int8_t*)&reg, HDLC_TX_CHAN_ENABLE_BIT);
	bit_set((u_int8_t*)&reg, HDLC_RX_ADDR_RECOGN_DIS_BIT);
d1387 2
a1388 4
	xilinx_write_ctrl_hdlc(card,
                               sc->first_time_slot,
                               XILINX_HDLC_CONTROL_REG,
                               reg);
d1390 1
a1390 1
	return 0;
d1393 2
a1394 2

static void xilinx_dev_unconfigure(sdla_t *card, xilinx_softc_t *sc)
d1399 1
a1399 1
#if defined(DEBUG_INIT)
d1404 1
a1404 1
	if (sc->logic_ch_num != -1){
d1406 16
a1421 3
		sdla_bus_read_4(card->hw,XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
		reg&=~HDLC_LOGIC_CH_BIT_MASK;
		reg&= HDLC_LCH_TIMESLOT_MASK;         /* mask not valid bits */
d1423 2
a1424 3
		sdla_bus_write_4(card->hw,
				XILINX_TIMESLOT_HDLC_CHAN_REG,
				(reg|(sc->logic_ch_num&HDLC_LOGIC_CH_BIT_MASK)));
d1426 4
d1431 5
a1435 5
		reg=0x00020000;
	        xilinx_write_ctrl_hdlc(card,
                               sc->first_time_slot,
                               XILINX_HDLC_CONTROL_REG,
                               reg);
d1437 3
a1439 23

	        for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
        	        if (bit_test((u_int8_t*)&sc->time_slot_map, i)){

                        	sdla_bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
                        	reg&=~TIMESLOT_BIT_MASK;
                        	reg&= HDLC_LCH_TIMESLOT_MASK;         /* mask not valid bits */

                        	/* Select a Timeslot for configuration */
                        	sdla_bus_write_4(card->hw,
                                       XILINX_TIMESLOT_HDLC_CHAN_REG,
                                       (reg|(i<<TIMESLOT_BIT_SHIFT)));


                        	reg=31&CONTROL_RAM_DATA_MASK;

                        	reg|=(FIFO_32B&HDLC_FIFO_SIZE_MASK)<<HDLC_FIFO_SIZE_SHIFT;
                        	reg|=(31&HDLC_FIFO_BASE_ADDR_MASK)<<
                                                HDLC_FIFO_BASE_ADDR_SHIFT;

#if defined(DEBUG_INIT)
                        	log(LOG_INFO, "Setting Timeslot %d to logic ch %d Reg=0x%X\n",
                                	        i, 31 ,reg);
d1441 2
a1442 4
	                        xilinx_write_ctrl_hdlc(card,
        	                                       i,
                	                               XILINX_CONTROL_RAM_ACCESS_BUF,
                        	                       reg);
d1446 3
a1448 2
		/* Lock to protect the logic ch map to 
	         * sc device array */
d1450 3
a1452 3
		free_xilinx_logical_channel_num(card,sc->logic_ch_num);
		for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
			if (bit_test((u_int8_t*)&sc->time_slot_map, i)){
d1456 1
a1456 1
		free_fifo_baddr_and_size(card,sc);
d1459 1
a1459 1
		sc->logic_ch_num=-1;
d1461 4
a1464 3
		for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
			if (bit_test((u_int8_t*)&sc->time_slot_map, i)){
				bit_clear((u_int8_t*)&card->u.xilinx.time_slot_map, i);
d1472 2
a1473 1
static int xilinx_init_rx_dev_fifo(sdla_t *card, xilinx_softc_t *sc, unsigned char wait)
d1475 3
a1477 4

        u_int32_t reg;
        u_int32_t dma_descr;
	u_int8_t  timeout=1;
d1480 17
a1496 17
        /* Clean RX DMA fifo */
        dma_descr=(unsigned long)(sc->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
        reg=0;
        bit_set((u_int8_t*)&reg, INIT_DMA_FIFO_CMD_BIT);

#if defined(DEBUG_INIT)
        log(LOG_DEBUG, "%s: Clearing RX Fifo DmaDescr=(0x%X) Reg=(0x%X) (%s)\n",
                                sc->if_name,
                                dma_descr,reg, __FUNCTION__);
#endif

       	sdla_bus_write_4(card->hw,dma_descr,reg);

	if (wait == WP_WAIT){
		for(i=0;i<FIFO_RESET_TIMEOUT_CNT;i++){
			sdla_bus_read_4(card->hw,dma_descr,&reg);
			if (bit_test((u_int8_t*)&reg, INIT_DMA_FIFO_CMD_BIT)){
d1500 1
a1500 1
			timeout=0;
d1502 1
a1502 1
		} 
d1504 9
a1512 7
#if defined(DEBUG_INIT)
		if (timeout){
			log(LOG_INFO, "%s:%s: Error: Rx fifo reset timedout %u us\n",
				card->devname,sc->if_name,i*FIFO_RESET_TIMEOUT_US);
		}else{
			log(LOG_INFO, "%s:%s: Rx Fifo reset successful %u us\n",
				card->devname,sc->if_name,i*FIFO_RESET_TIMEOUT_US); 
d1515 2
a1516 2
	}else{
		timeout=0;
d1519 1
a1519 1
	return timeout;
d1522 2
a1523 1
static int xilinx_init_tx_dev_fifo(sdla_t *card, xilinx_softc_t *sc, unsigned char wait)
d1526 2
a1527 2
        u_int32_t dma_descr;
        u_int8_t  timeout=1;
d1530 22
a1551 4
        /* Clean TX DMA fifo */
        dma_descr=(unsigned long)(sc->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
        reg=0;
        bit_set((u_int8_t*)&reg, INIT_DMA_FIFO_CMD_BIT);
d1553 10
a1562 4
#if defined(DEBUG_INIT)
        log(LOG_DEBUG, "%s: Clearing TX Fifo DmaDescr=(0x%X) Reg=(0x%X) (%s)\n",
                                sc->if_name,
                                dma_descr,reg, __FUNCTION__);
d1564 2
a1565 24
        sdla_bus_write_4(card->hw,dma_descr,reg);

	if (wait == WP_WAIT){
        	for(i=0;i<FIFO_RESET_TIMEOUT_CNT;i++){
                	sdla_bus_read_4(card->hw,dma_descr,&reg);
                	if (bit_test((u_int8_t*)&reg, INIT_DMA_FIFO_CMD_BIT)){
                        	DELAY(FIFO_RESET_TIMEOUT_US);
                        	continue;
                	}
               		timeout=0;
               		break;
        	}

#if defined(DEBUG_INIT)
        	if (timeout){
                	log(LOG_INFO, "%s:%s: Error: Tx fifo reset timedout %u us\n",
                                card->devname,sc->if_name,i*FIFO_RESET_TIMEOUT_US);
        	}else{
                	log(LOG_INFO, "%s:%s: Tx Fifo reset successful %u us\n",
                                card->devname,sc->if_name,i*FIFO_RESET_TIMEOUT_US);
        	}
#endif
	}else{
		timeout=0;
d1568 1
a1568 1
	return timeout;
d1572 2
a1573 1
static void xilinx_dev_enable(sdla_t *card, xilinx_softc_t *sc)
d1575 1
a1575 1
        u_int32_t reg;
d1577 2
a1578 2
#if defined(DEBUG_INIT)
	log(LOG_INFO, "%s: Enabling Global Inter Mask !\n",sc->if_name);
d1581 2
a1582 3
	sdla_bus_read_4(card->hw,
                                  XILINX_GLOBAL_INTER_MASK, &reg);
	bit_set((u_int8_t*)&reg, sc->logic_ch_num);
d1584 1
a1584 2
	sdla_bus_write_4(card->hw,
                                  XILINX_GLOBAL_INTER_MASK, reg);
d1586 1
a1586 1
	bit_set((u_int8_t*)&card->u.xilinx.active_ch_map, sc->logic_ch_num);
d1589 2
a1590 1
static void xilinx_dev_close(sdla_t *card, xilinx_softc_t *sc)
d1596 2
a1597 2
#if defined(DEBUG_INIT)	
    	log(LOG_DEBUG, "-- Close Xilinx device. --\n");
d1599 2
a1600 2
        /* Disable Logic Channel Interrupts for DMA and fifo */
        sdla_bus_read_4(card->hw, XILINX_GLOBAL_INTER_MASK, &reg);
d1602 2
a1603 2
        bit_clear((u_int8_t*)&reg, sc->logic_ch_num);
	bit_clear((u_int8_t*)&card->u.xilinx.active_ch_map, sc->logic_ch_num);
d1605 5
a1609 3
	/* We are masking the sc interrupt. 
         * Lock to make sure that the interrupt is
         * not running */
d1611 1
a1611 1
        sdla_bus_write_4(card->hw, XILINX_GLOBAL_INTER_MASK, reg);
d1614 1
a1614 1
	reg=0;
d1617 12
a1628 15
 	sdla_bus_read_4(card->hw, XILINX_TIMESLOT_HDLC_CHAN_REG, &reg);
	
       	reg&=~HDLC_LOGIC_CH_BIT_MASK;
       	reg&= HDLC_LCH_TIMESLOT_MASK;         /* mask not valid bits */

       	sdla_bus_write_4(card->hw,
                       XILINX_TIMESLOT_HDLC_CHAN_REG,
                       (reg|(sc->logic_ch_num&HDLC_LOGIC_CH_BIT_MASK)));


	reg=0;
	xilinx_write_ctrl_hdlc(card,
                               sc->first_time_slot,
                               XILINX_HDLC_CONTROL_REG,
                               reg);
d1630 2
a1631 2
    	/* Clear descriptors */
	reg=0;
d1633 1
a1633 1
	sdla_bus_write_4(card->hw,dma_descr,reg);
d1635 1
a1635 1
	sdla_bus_write_4(card->hw,dma_descr,reg);
d1650 1
a1650 1
	sdla_bus_read_4(card->hw,dma_descr, &reg);
d1652 1
a1652 1
	if (bit_test((u_int8_t*)&reg,RxDMA_HI_DMA_GO_READY_BIT)){
d1659 1
a1659 1
	if (sc->rx_dma_mbuf){
d1661 2
a1662 2
				sc->if_name);
		return -EINVAL;
d1667 6
a1672 7
	if (!sc->rx_dma_mbuf){
		log(LOG_INFO, "%s: Critical Error no rx dma buf Free=%d Comp=%d!\n",
				sc->if_name,
				sc->wp_rx_free_list.ifq_len,
				sc->wp_rx_complete_list.ifq_len);
	
		return -ENOMEM;
d1675 1
a1675 1
	rx_el = mtod(sc->rx_dma_mbuf, wp_rx_element_t*);
d1678 8
a1685 7
	memset(rx_el,0,sizeof(wp_rx_element_t));
	
	bus_addr = kvtop(mtod(sc->rx_dma_mbuf, caddr_t) + sc->rx_dma_mbuf->m_len);

	if (!bus_addr){
		log(LOG_INFO, "%s: %s Critical error pci_map_single() failed!\n",
				sc->if_name,__FUNCTION__);
d1688 2
a1689 2
	
	rx_el->dma_addr=bus_addr;
d1693 1
a1693 1
	reg=bus_addr;
d1700 1
a1700 1
    	dma_descr=(sc->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_LO;
d1702 4
a1705 3
#if defined(DEBUG_RX)
	log(LOG_INFO,"%s: RxDMA_LO = 0x%X, BusAddr=0x%lX DmaDescr=0x%lX (%s)\n",
		card->devname,reg,bus_addr,dma_descr, __FUNCTION__);
d1707 1
a1707 1
	sdla_bus_write_4(card->hw,dma_descr,reg);
d1709 2
a1710 1
	dma_descr=(unsigned long)(sc->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
d1712 1
a1712 1
    	reg =0;
d1714 1
a1714 1
	reg|=(sc->dma_mtu>>2)&RxDMA_HI_DMA_DATA_LENGTH_MASK;
d1717 2
a1718 1
	reg|=(sc->fifo_size_code&DMA_FIFO_SIZE_MASK)<<DMA_FIFO_SIZE_SHIFT;
d1721 1
a1721 1
	reg|=(HARD_FIFO_CODE&DMA_FIFO_SIZE_MASK)<<DMA_FIFO_SIZE_SHIFT;
d1723 2
a1724 2
        reg|=(sc->fifo_base_addr&DMA_FIFO_BASE_ADDR_MASK)<<
                              DMA_FIFO_BASE_ADDR_SHIFT;	
d1726 1
a1726 1
	bit_set((u_int8_t*)&reg, RxDMA_HI_DMA_GO_READY_BIT);
d1728 3
a1730 3
#if defined(DEBUG_RX)
	log(LOG_INFO, "%s: RXDMA_HI = 0x%X, BusAddr=0x%lX DmaDescr=0x%lX (%s)\n",
 	             sc->if_name, reg,bus_addr,dma_descr, __FUNCTION__);
d1733 1
a1733 1
	sdla_bus_write_4(card->hw,dma_descr,reg);
d1735 3
a1737 3
	bit_set((u_int8_t*)&sc->rx_dma, 0);
	
	return 0;
d1741 2
a1742 1
static int xilinx_dma_tx (sdla_t *card, xilinx_softc_t *sc)
d1744 1
a1744 1
	u_int32_t reg=0;
d1747 2
a1748 2
	unsigned char len_align=0;
	int len=0;
d1750 2
a1751 2
#if defined(DEBUG_TX)
    	log(LOG_INFO, "------ Setup Tx DMA descriptor. --\n");
d1754 1
a1754 1
	if (bit_test((u_int8_t*)&sc->dma_status, TX_BUSY)){
d1756 1
a1756 1
				sc->if_name, __FUNCTION__,__LINE__);
d1759 1
a1759 1
	bit_set((u_int8_t*)&sc->dma_status, TX_BUSY);
d1762 5
a1766 5
	/* Free the previously skb dma mapping. 
         * In this case the tx interrupt didn't finish
         * and we must re-transmit.*/

        if (sc->tx_dma_addr && sc->tx_dma_len){
d1768 1
a1768 1
                                sc->if_name,__FUNCTION__);
d1770 3
a1772 3
                sc->tx_dma_addr=0;
		sc->tx_dma_len=0;
        }
d1775 3
a1777 3
         * minimize tx isr, the previously transmitted
         * packet is deallocated here */
	if (sc->tx_dma_mbuf){
d1779 1
a1779 1
				sc->if_name,__FUNCTION__);
d1781 1
a1781 1
		sc->tx_dma_mbuf=NULL;
d1785 1
a1785 1
	/* check queue pointers befor start transmittion */ 
d1788 1
a1788 1
	dma_descr=(sc->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
d1790 1
a1790 1
#if defined(DEBUG_TX)
d1792 1
a1792 2
                        sc->if_name, sc->logic_ch_num,dma_descr,
			__FUNCTION__,__LINE__);
d1795 1
a1795 1
	sdla_bus_read_4(card->hw,dma_descr, &reg);
d1797 5
a1801 5
	if (bit_test((u_int8_t*)&reg, TxDMA_HI_DMA_GO_READY_BIT)){
		log(LOG_INFO, "%s: Error: TxDMA GO Ready bit set on dma Tx 0x%X\n",
				card->devname,reg);
		bit_clear((u_int8_t*)&sc->dma_status, TX_BUSY);
		return -EFAULT;
d1806 5
a1810 5
	if (!m){
		bit_clear((u_int8_t*)&sc->dma_status, TX_BUSY);
		return -ENOBUFS;
	}else{
			
d1812 1
a1812 1
		if (len > MAX_XILINX_TX_DMA_SIZE){
d1816 3
a1818 3
			log(LOG_INFO, "%s: Tx len %d > %d (MAX TX DMA LEN) (%s:%d)!\n",
                	        	sc->if_name, len, MAX_XILINX_TX_DMA_SIZE,
					__FUNCTION__,__LINE__);
d1820 2
a1821 2
			bit_clear((u_int8_t*)&sc->dma_status, TX_BUSY);
			return -EINVAL;
d1828 3
a1830 3
	if (sc->tx_dma_addr & 0x03){
		log(LOG_INFO, "%s: Error: Tx Ptr not aligned to 32bit boudary!\n",
				card->devname);
d1832 1
a1832 1
		if (m){
d1836 2
a1837 2
		bit_clear((u_int8_t*)&sc->dma_status, TX_BUSY);
		return -EINVAL;
d1840 1
a1840 1
	sc->tx_dma_mbuf=m;
d1843 2
a1844 2
         *          here on.  The skb pointer might not exist if
         *          we are in transparent mode */
d1846 1
a1846 1
	dma_descr=(sc->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_LO;
d1850 1
a1850 1
	reg=sc->tx_dma_addr;
d1855 2
a1856 2
	reg&=~(TxDMA_LO_ALIGNMENT_BIT_MASK);
	reg|=(len&0x03);
d1858 2
a1859 2
	if (len&0x03){
		len_align=1;
d1862 1
a1862 1
#if defined(DEBUG_TX)
d1864 1
a1864 1
		sc->if_name, reg,sc->tx_dma_addr,dma_descr, __FUNCTION__);
d1867 1
a1867 1
	sdla_bus_write_4(card->hw,dma_descr,reg);
d1869 1
a1869 1
	dma_descr=(sc->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
d1871 2
a1872 2
	reg=0;
	reg|=(((len>>2)+len_align)&TxDMA_HI_DMA_DATA_LENGTH_MASK);
d1875 1
a1875 1
        reg|=(sc->fifo_size_code&DMA_FIFO_SIZE_MASK)<<DMA_FIFO_SIZE_SHIFT;
d1878 1
a1878 1
        reg|=(HARD_FIFO_CODE&DMA_FIFO_SIZE_MASK)<<DMA_FIFO_SIZE_SHIFT;
d1880 2
a1881 2
        reg|=(sc->fifo_base_addr&DMA_FIFO_BASE_ADDR_MASK)<<
                              DMA_FIFO_BASE_ADDR_SHIFT;
d1883 6
a1888 2
	/* Only enable the Frame Start/Stop on
         * non-transparent hdlc configuration */
d1890 1
a1890 2
	bit_set((u_int8_t*)&reg, TxDMA_HI_DMA_FRAME_START_BIT);
	bit_set((u_int8_t*)&reg, TxDMA_HI_DMA_FRAME_END_BIT);
d1892 1
a1892 3
	bit_set((u_int8_t*)&reg, TxDMA_HI_DMA_GO_READY_BIT);

#if defined(DEBUG_TX)
d1894 1
a1894 1
			sc->if_name, reg,dma_descr, __FUNCTION__);
d1897 1
a1897 1
	sdla_bus_write_4(card->hw,dma_descr,reg);
d1899 1
a1899 1
	return 0;
d1903 2
a1904 1
static void xilinx_dma_tx_complete (sdla_t *card, xilinx_softc_t *sc)
d1906 1
a1906 1
	u_int32_t reg=0;
d1909 1
a1909 1
#if defined(DEBUG_TX)
d1913 1
a1913 1
/*      sdla_bus_read_4(card->hw,0x78, &tmp1); */
d1915 2
a1916 2
	dma_descr=(sc->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
	sdla_bus_read_4(card->hw,dma_descr, &reg);
d1918 1
a1918 1
    	if (!sc->tx_dma_mbuf){
d1921 2
a1922 2
                   			card->devname);
		bit_clear((u_int8_t*)&sc->dma_status, TX_BUSY);
d1925 3
a1927 3
	}else{
		sc->tx_dma_addr=0;
		sc->tx_dma_len=0;
a1928 6
	
		/* Do not free the packet here, 
                 * copy the packet dma info into csum
               	 * field and let the bh handler analyze
               	 * the transmitted packet. 
  		 */
d1930 7
a1936 1
		if (reg & TxDMA_HI_DMA_PCI_ERROR_RETRY_TOUT){
d1938 3
a1940 2
			log(LOG_INFO, "%s:%s: PCI Error: 'Retry' exceeds maximum (64k): Reg=0x%X!\n",
                                        card->devname,sc->if_name,reg);
d1942 3
a1944 2
			if (++sc->pci_retry < 3){
				bit_set((u_int8_t*)&reg, TxDMA_HI_DMA_GO_READY_BIT);
d1946 3
a1948 2
       				log(LOG_INFO, "%s: Retry: TXDMA_HI=0x%X DmaDescr=0x%lX (%s)\n",
                       			sc->if_name, reg,dma_descr, __FUNCTION__);
d1950 1
a1950 1
       				sdla_bus_write_4(card->hw,dma_descr,reg);
d1952 1
a1952 1
			}				
d1955 1
a1955 1
		sc->pci_retry=0;
d1958 1
a1958 1
		sc->tx_dma_mbuf=NULL;
d1960 1
a1960 1
		bit_clear((u_int8_t*)&sc->dma_status, TX_BUSY);
d1968 2
a1969 1
static void xilinx_tx_post_complete (sdla_t *card, xilinx_softc_t *sc, struct mbuf *m)
d1971 1
a1971 1
	struct ifnet	*ifp; 
d1975 2
a1976 2
	ifp = (struct ifnet*)&sc->common.ifp;
	if ((bit_test((u_int8_t*)&reg, TxDMA_HI_DMA_GO_READY_BIT)) ||
d1978 1
a1978 1
	    (reg & TxDMA_HI_DMA_PCI_ERROR_MASK)){
d1980 1
a1980 1
#if defined(DEBUG_TX)
d1982 1
a1982 1
			card->devname,sc->if_name,reg);
d1986 28
a2013 24
		if (bit_test((u_int8_t*)&reg, TxDMA_HI_DMA_GO_READY_BIT)){
        		log(LOG_INFO, "%s:%s: Error: TxDMA Intr: GO bit set on Tx intr\n",
                   		card->devname,sc->if_name);
		}

		if (reg & TxDMA_HI_DMA_DATA_LENGTH_MASK){
               		log(LOG_INFO, "%s:%s: Error: TxDMA Length not equal 0 \n",
                   		card->devname,sc->if_name);
	        }   
 
    		/* Checking Tx DMA PCI error status. Has to be '0's */
		if (reg&TxDMA_HI_DMA_PCI_ERROR_MASK){
                	     	
			if (reg & TxDMA_HI_DMA_PCI_ERROR_M_ABRT){
        			log(LOG_INFO, "%s:%s: Tx Error: Abort from Master: pci fatal error!\n",
                	     		card->devname,sc->if_name);
			}
			if (reg & TxDMA_HI_DMA_PCI_ERROR_T_ABRT){
        			log(LOG_INFO, "%s:%s: Tx Error: Abort from Target: pci fatal error!\n",
                	     		card->devname,sc->if_name);
			}
			if (reg & TxDMA_HI_DMA_PCI_ERROR_DS_TOUT){
        			log(LOG_INFO, "%s:%s: Tx Warning: PCI Latency Timeout!\n",
                	     		card->devname,sc->if_name);
d2016 4
a2019 3
			if (reg & TxDMA_HI_DMA_PCI_ERROR_RETRY_TOUT){
        			log(LOG_INFO, "%s:%s: Tx Error: 'Retry' exceeds maximum (64k): pci fatal error!\n",
                	     		card->devname,sc->if_name);
d2026 2
a2027 2
	
	if (ifp){
d2032 3
a2034 3
        /* Indicate that the first tx frame went
         * out on the transparent link */
        bit_set((u_int8_t*)&sc->idle_start, 0);
d2038 6
a2043 4
        if (!xilinx_dma_tx(card,sc)){
		/* If we was able to transmit and the interface is set to OACTIVE
		** remove this flag and let kernel try to transmit. */
		if (ifp->if_flags & IFF_OACTIVE){
d2050 2
a2051 1
static void xilinx_dma_rx_complete (sdla_t *card, xilinx_softc_t *sc)
d2057 4
a2060 4
	bit_clear((u_int8_t*)&sc->rx_dma, 0);
	
	if (!sc->rx_dma_mbuf){
		log(LOG_INFO, "%s: Critical Error: rx_dma_mbuf\n",sc->if_name);
d2064 1
a2064 1
	rx_el= mtod(sc->rx_dma_mbuf, wp_rx_element_t *);
d2066 4
a2069 4
    	/* Reading Rx DMA descriptor information */
	dma_descr=(sc->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_LO;
	sdla_bus_read_4(card->hw,dma_descr, &rx_el->align);
	rx_el->align&=RxDMA_LO_ALIGNMENT_BIT_MASK;
d2071 2
a2072 2
    	dma_descr=(sc->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
	sdla_bus_read_4(card->hw,dma_descr, &rx_el->reg);
d2075 1
a2075 1
	sc->pkt_error=0;
d2077 1
a2077 1
#if defined(DEBUG_RX)
d2079 2
a2080 2
			sc->if_name,rx_el->reg,rx_el->align,rx_el->dma_addr, 
			__FUNCTION__,__LINE__);   
d2082 5
a2086 5
	
	m=sc->rx_dma_mbuf;
	sc->rx_dma_mbuf=NULL;
	
	xilinx_dma_rx(card,sc);
d2092 1
a2092 1
/*    	sdla_bus_read_4(card->hw,0x80, &rx_empty); */
d2096 3
a2098 4
static void xilinx_rx_post_complete (sdla_t *card, xilinx_softc_t *sc, 
				     struct mbuf *m, 
				     struct mbuf **new_m,
				     unsigned char *pkt_error)
d2101 1
a2101 1
    	unsigned int len,data_error = 0;
d2105 1
a2105 1
	ifp = (struct ifnet*)&sc->common.ifp;	/*m->m_pkthdr.rcvif;*/
d2107 1
a2107 1
#if defined(DEBUG_RX)
d2109 12
a2120 15
			sc->if_name,
			rx_el->reg,
			rx_el->align,
			rx_el->dma_addr, 
			__FUNCTION__,__LINE__);   
#endif
	rx_el->align&=RxDMA_LO_ALIGNMENT_BIT_MASK;
	*pkt_error=0;
	*new_m=NULL;

	
    	/* Checking Rx DMA Go bit. Has to be '0' */
	if (bit_test((u_int8_t*)&rx_el->reg, RxDMA_HI_DMA_GO_READY_BIT)){
        	log(LOG_INFO, "%s: Error: RxDMA Intr: GO bit set on Rx intr\n",
				card->devname);
d2124 1
a2124 1
    
d2126 1
a2126 1
	if (rx_el->reg&RxDMA_HI_DMA_PCI_ERROR_MASK){
d2128 16
a2143 22
		if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_M_ABRT){
#if defined(DEBUG_ERR)
                	log(LOG_INFO, "%s: Rx Error: Abort from Master: pci fatal error!\n",
                                   card->devname);
#endif
                }
                if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_T_ABRT){
#if defined(DEBUG_ERR)
                        log(LOG_INFO, "%s: Rx Error: Abort from Target: pci fatal error!\n",
                                   card->devname);
#endif
                }
                if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_DS_TOUT){
#if defined(DEBUG_ERR)
                        log(LOG_INFO, "%s: Rx Error: No 'DeviceSelect' from target: pci fatal error!\n",
                                    card->devname);
#endif
                }
                if (rx_el->reg & RxDMA_HI_DMA_PCI_ERROR_RETRY_TOUT){
#if defined(DEBUG_ERR)
                        log(LOG_INFO, "%s: Rx Error: 'Retry' exceeds maximum (64k): pci fatal error!\n",
                                    card->devname);
d2145 8
a2152 2
                }
#if defined(DEBUG_ERR)
d2154 1
a2154 1
				card->devname,rx_el->reg);
d2156 2
a2157 1
		if (ifp) ifp->if_ierrors++;
d2162 4
a2165 4
	if (!bit_test((u_int8_t*)&rx_el->reg, RxDMA_HI_DMA_FRAME_START_BIT)){
#if defined(DEBUG_ERR)
		log(LOG_INFO, "%s: RxDMA Intr: Start flag missing: MTU Mismatch! Reg=0x%X\n",
				card->devname,rx_el->reg);
d2167 2
a2168 1
		if (ifp) ifp->if_ierrors++;
d2171 1
a2171 1
    
d2173 4
a2176 4
	if (!bit_test((u_int8_t*)&rx_el->reg, RxDMA_HI_DMA_FRAME_END_BIT)){
#if defined(DEBUG_ERR)
		log(LOG_INFO, "%s: RxDMA Intr: End flag missing: MTU Mismatch! Reg=0x%X\n",
				card->devname,rx_el->reg);
d2180 16
a2195 12
	
       	} else {  /* Check CRC error flag only if this is the end of Frame */
       	
		if (bit_test((u_int8_t*)&rx_el->reg, RxDMA_HI_DMA_CRC_ERROR_BIT)){
#if defined(DEBUG_ERR)
               		log(LOG_INFO, "%s: RxDMA Intr: CRC Error! Reg=0x%X\n",
                               		card->devname,rx_el->reg);
#endif
			if (ifp) ifp->if_ierrors++;
			bit_set((u_int8_t*)&rx_el->pkt_error, WP_CRC_ERROR_BIT);	
               		data_error = 1;
       		}
d2198 4
a2201 3
               	 * drop it and continue receiving */
		if (bit_test((u_int8_t*)&rx_el->reg, RxDMA_HI_DMA_FRAME_ABORT_BIT)){
#if defined(DEBUG_ERR)
d2203 1
a2203 1
					card->devname,rx_el->reg);
d2205 4
a2208 2
			if (ifp) ifp->if_ierrors++;
			bit_set((u_int8_t*)&rx_el->pkt_error, WP_ABORT_ERROR_BIT);
d2212 1
a2212 1
		if (data_error){
d2214 2
a2215 2
		}	
    	}
d2217 1
a2217 1
	len=rx_el->reg&RxDMA_HI_DMA_DATA_LENGTH_MASK;
d2220 3
a2222 2
         * on alignment value, received from DMA */
	len=(((sc->dma_mtu>>2)-len)<<2) - (~(rx_el->align)&RxDMA_LO_ALIGNMENT_BIT_MASK);
d2224 1
a2224 1
	*pkt_error=rx_el->pkt_error;
d2226 3
a2228 3
	/* After a RX FIFO overflow, we must mark max 7 
         * subsequent frames since firmware, cannot 
         * guarantee the contents of the fifo */
d2230 3
a2232 3
	if (bit_test((u_int8_t*)&rx_el->pkt_error, WP_FIFO_ERROR_BIT)){
		if (++sc->rx_fifo_err_cnt >= WP_MAX_FIFO_FRAMES){
			sc->rx_fifo_err_cnt=0;
d2234 5
a2238 5
		bit_set((u_int8_t*)pkt_error, WP_FIFO_ERROR_BIT);
	}else{
		if (sc->rx_fifo_err_cnt){
			if (++sc->rx_fifo_err_cnt >= WP_MAX_FIFO_FRAMES){
                        	sc->rx_fifo_err_cnt=0;
d2240 1
a2240 1
			bit_set((u_int8_t*)pkt_error, WP_FIFO_ERROR_BIT);
d2244 1
a2244 1
	if (len > aft_rx_copyback){
d2248 2
a2249 2
#if 0		
		memset(&skb->cb[0],0,sizeof(wp_rx_element_t));
d2251 1
a2251 1
		memset(mtod(m, caddr_t),0,sizeof(wp_rx_element_t));
d2255 1
a2255 1
		*new_m=m;
d2257 2
a2258 2
		aft_alloc_rx_dma_buff(card,sc,1);
	}else{
d2261 1
a2261 1
		 * small thus, allocate a new 
d2264 1
a2264 1
		if (m0 == NULL){
d2266 3
a2268 2
					sc->if_name);
			if (ifp) ifp->if_ierrors++;
d2283 1
a2283 1
    	return;
d2287 3
a2289 1
static char request_xilinx_logical_channel_num (sdla_t *card, xilinx_softc_t *sc, long *free_ch)
d2291 2
a2292 2
	char logic_ch=-1, free_logic_ch=-1;
	int i,err;
d2294 1
a2294 1
	*free_ch=-1;
d2296 1
a2296 1
#if defined(DEBUG_INIT)
d2298 4
a2301 5
	log(LOG_INFO, "%s: Global Num Timeslots=%d  Global Logic ch Map 0x%lX (%s:%d)\n",
		sc->if_name,
                card->u.xilinx.num_of_time_slots,
                card->u.xilinx.logic_ch_map,
		__FUNCTION__,__LINE__);
d2304 3
a2306 3
	err=request_fifo_baddr_and_size(card,sc);
	if (err){
		return -1;
d2309 4
a2312 5

	for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
		if (!bit_test((u_int8_t*)&card->u.xilinx.logic_ch_map, i)){
			bit_set((u_int8_t*)&card->u.xilinx.logic_ch_map, i);
			logic_ch=i;
d2317 2
a2318 2
	if (logic_ch == -1){
		return logic_ch;
d2321 3
a2323 3
	for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
		if (!bit_test((u_int8_t*)&card->u.xilinx.logic_ch_map, i)){
			free_logic_ch=HDLC_FREE_LOGIC_CH;
d2328 1
a2328 1
	if (card->u.xilinx.dev_to_ch_map[(unsigned char)logic_ch]){
d2330 2
a2331 2
				card->devname,logic_ch);
		return -1;
d2334 1
a2334 1
	*free_ch=free_logic_ch;
d2336 1
a2336 1
	card->u.xilinx.dev_to_ch_map[(unsigned char)logic_ch]=(void*)sc;
d2338 2
a2339 2
	if (logic_ch > card->u.xilinx.top_logic_ch){
		card->u.xilinx.top_logic_ch=logic_ch;
d2344 1
a2344 1
	return logic_ch;
d2347 2
a2348 1
static void free_xilinx_logical_channel_num (sdla_t *card, int logic_ch)
d2350 2
a2351 2
	bit_clear ((u_int8_t*)&card->u.xilinx.logic_ch_map, logic_ch);
	card->u.xilinx.dev_to_ch_map[logic_ch]=NULL;
d2353 1
a2353 1
	if (logic_ch >= card->u.xilinx.top_logic_ch){
d2356 1
a2356 1
		card->u.xilinx.top_logic_ch=XILINX_DEFLT_ACTIVE_CH;
d2358 3
a2360 3
		for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
			if (card->u.xilinx.dev_to_ch_map[logic_ch]){
				card->u.xilinx.top_logic_ch=i;
d2369 2
a2370 1
static void xilinx_dma_max_logic_ch(sdla_t *card)
d2374 1
a2374 1
#if defined(DEBUG_INIT)
d2378 1
a2378 1
	sdla_bus_read_4(card->hw,XILINX_DMA_CONTROL_REG, &reg);
d2380 1
a2380 1
        /* Set up the current highest active logic channel */
d2382 2
a2383 2
	reg&=DMA_ACTIVE_CHANNEL_BIT_MASK;
        reg|=(card->u.xilinx.top_logic_ch << DMA_ACTIVE_CHANNEL_BIT_SHIFT);
d2385 1
a2385 1
        sdla_bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
d2388 2
a2389 1
static int aft_init_requeue_free_m(xilinx_softc_t *sc, struct mbuf *m)
d2391 1
a2391 1
	int 			err;
d2393 1
a2393 1
	m->m_data 	= (m->m_flags & M_EXT) ? m->m_ext.ext_buf : m->m_pktdat;
d2396 1
a2396 1
	memset(mtod(m, caddr_t),0,sizeof(wp_rx_element_t));
d2398 1
a2398 1
	return err;
d2401 2
a2402 1
static int aft_alloc_rx_dma_buff(sdla_t *card, xilinx_softc_t *sc, int num)
d2406 2
a2407 2
	
	for (i=0;i<num;i++){
d2409 1
a2409 1
		if (m == NULL){
d2411 2
a2412 2
					sc->if_name,__FUNCTION__);
			return -ENOMEM;
d2417 1
a2417 1
	return 0;
d2420 2
a2421 7



/*============================================================================
 * Enable timer interrupt
 */
static void enable_timer (void* card_id)
d2423 1
a2423 1
	sdla_t	*card = (sdla_t*)card_id;
d2432 2
a2433 1
static void xilinx_process_packet(xilinx_softc_t *sc)
d2435 3
a2437 3
	struct ifnet	*ifp;	
	struct mbuf 	*new_m, *m;
	unsigned char	pkt_error;
d2440 1
a2440 1
	for(;;){
d2445 2
a2446 2
		new_m=NULL;
		pkt_error=0;
d2448 10
a2457 12
		/* The post function will take care
		 * of the skb and new_skb buffer.
		 * If new_skb buffer exists, driver
		 * must pass it up the stack, or free it */
		xilinx_rx_post_complete (sc->common.card, sc,
                                   	 m,
                                     	 &new_m,
                                     	 &pkt_error);
		if (new_m){

			ifp = (struct ifnet*)&sc->common.ifp;
#if defined(DEBUG_RX)
d2459 1
a2459 1
					ifp->if_xname, new_m->m_len);
d2465 1
a2465 1
	for(;;){
d2469 1
a2469 1
		xilinx_tx_post_complete (sc->common.card,sc,m);
d2476 2
a2477 1
static int fifo_error_interrupt(sdla_t *card, unsigned long reg)
d2479 2
a2480 2
        u_int32_t rx_status, tx_status;
	u_int32_t err=0;
d2484 2
a2485 3
#if defined(DEBUG_ERR)
	log(LOG_INFO, "%s: Fifo error interrupt!\n",
					card->devname);
d2488 18
a2505 16
        /* Clear HDLC pending registers */
        sdla_bus_read_4(card->hw,XILINX_HDLC_TX_INTR_PENDING_REG,&tx_status);
        sdla_bus_read_4(card->hw,XILINX_HDLC_RX_INTR_PENDING_REG,&rx_status);
	
	if (card->state != WAN_CONNECTED){
        	log(LOG_INFO, "%s: Warning: Ignoring Error Intr: link disc!\n",
                                  card->devname);
                return 0;
        }

	tx_status&=card->u.xilinx.active_ch_map;
	rx_status&=card->u.xilinx.active_ch_map;

        if (tx_status != 0){
		for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
			if (bit_test((u_int8_t*)&tx_status, i) && bit_test((u_int8_t*)&card->u.xilinx.logic_ch_map, i)){
d2507 6
a2512 4
				
				sc=(xilinx_softc_t*)card->u.xilinx.dev_to_ch_map[i];
				if (!sc){
					log(LOG_INFO, "Warning: ignoring tx error intr: no dev!\n");
d2516 1
a2516 1
				ifp = (struct ifnet*)&sc->common.ifp;
d2518 6
a2523 5
				if (!(ifp->if_flags & IFF_UP)){
					log(LOG_INFO, "%s: Warning: ignoring tx error intr: dev down 0x%X  UP=0x%X!\n",
						ifp->if_xname,
						sc->common.state,
						sc->ignore_modem);
d2528 4
a2531 3
				if (card->state != WAN_CONNECTED){
					log(LOG_INFO, "%s: Warning: ignoring tx error intr: dev disc!\n",
                                               	ifp->if_xname);
d2535 5
a2539 3
#if defined(DEBUG_ERR)
                		log(LOG_INFO, "%s:%s: Warning TX Fifo Error on LogicCh=%ld Slot=%d!\n",
                           		card->devname,sc->if_name,sc->logic_ch_num,i);
d2541 1
a2541 1
				xilinx_tx_fifo_under_recover(card,sc);
d2545 1
a2545 1
        }
d2548 5
a2552 3
        if (rx_status != 0){
		for (i=0;i<card->u.xilinx.num_of_time_slots;i++){
			if (bit_test((u_int8_t*)&rx_status, i) && bit_test((u_int8_t*)&card->u.xilinx.logic_ch_map, i)){
d2554 3
a2556 2
				sc=(xilinx_softc_t*)card->u.xilinx.dev_to_ch_map[i];
				if (!sc){
d2560 1
a2560 1
				ifp = (struct ifnet*)&sc->common.ifp;
d2562 5
a2566 5
				if (!(ifp->if_flags & IFF_UP)){
					log(LOG_INFO, "%s: Warning: ignoring rx error intr: dev down 0x%X UP=0x%X!\n",
						ifp->if_xname,
						sc->common.state,
						sc->ignore_modem);
d2571 15
a2585 15
				if (card->state != WAN_CONNECTED){
					log(LOG_INFO, "%s: Warning: ignoring rx error intr: dev disc!\n",
						ifp->if_xname);
                                        continue;
                                }

#if defined(DEBUG_ERR)
                		log(LOG_INFO, "%s:%s: Warning RX Fifo Error on LCh=%ld Slot=%d RxCL=%d RxFL=%d RxDMA=%d\n",
                           		card->devname,
					sc->if_name,
					sc->logic_ch_num,
					i,
					sc->wp_rx_complete_list.ifq_len,
					sc->wp_rx_free_list.ifq_len,
					sc->rx_dma);
d2592 5
a2596 3
			     	dma_descr=(sc->logic_ch_num<<4) + XILINX_RxDMA_DESCRIPTOR_HI;
			        sdla_bus_read_4(card->hw, dma_descr, &reg);
				log(LOG_INFO, "%s: Hi Descriptor 0x%X\n",sc->if_name,reg);
d2600 3
a2602 3
				bit_set((u_int8_t*)&sc->pkt_error, WP_FIFO_ERROR_BIT);

				err=-EINVAL;
d2605 1
a2605 1
        }
d2607 1
a2607 1
	return err;
d2611 2
a2612 1
static void front_end_interrupt(sdla_t *card, unsigned long reg)
d2619 3
a2621 5
/**SECTION***************************************************************
 *
 * 	HARDWARE Interrupt Handlers
 *
 ***********************************************************************/
d2624 1
a2624 3
/*============================================================================
 * wan_xilinx_isr
 *
d2626 1
a2626 2
 * Determin the interrupt received and handle it.
 *
d2628 1
a2628 1
static void wp_xilinx_isr (sdla_t* card)
d2630 1
a2630 1
    	int i;
d2632 1
a2632 1
	u_int32_t dma_tx_reg,dma_rx_reg;
d2635 1
a2635 1
	if (bit_test((u_int8_t*)&card->critical, CARD_DOWN)){
d2637 1
a2637 1
			card->devname);	
d2641 1
d2643 1
a2643 1
    	bit_set((u_int8_t*)&card->in_isr, 0);
d2645 6
a2650 1
/*	write_cpld(card,LED_CONTROL_REG,0x0F);*/
d2652 1
a2652 8
	/* -----------------2/6/2003 9:02AM------------------
	* Disable all chip Interrupts  (offset 0x040)
	*  -- "Transmit/Receive DMA Engine"  interrupt disable
	*  -- "FiFo/Line Abort Error"        interrupt disable
	* --------------------------------------------------*/
	sdla_bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);

	if (bit_test((u_int8_t*)&reg, SECURITY_STATUS_FLAG)){
a2656 4
		log(LOG_INFO, "%s: Please call Sangoma Tech Suppor!\n",
					card->devname);
		log(LOG_INFO, "%s: (www.sangoma.com)!\n",
					card->devname);
d2658 2
a2659 2
		port_set_state(card,WAN_DISCONNECTED);
		disable_data_error_intr(card,CARD_DOWN);
d2663 13
a2675 10
	/* Note: If interrupts are received without pending
	** flags, it usually indicates that the interrupt
	** is being shared.  (Check 'cat /proc/interrupts') */
	if (bit_test((u_int8_t*)&reg, FRONT_END_INTR_ENABLE_BIT)){
		if (bit_test((u_int8_t*)&reg, FRONT_END_INTR_FLAG)){
              		front_end_interrupt(card,reg);
			if (card->u.xilinx.state_change_exit_isr){
				card->u.xilinx.state_change_exit_isr=0;
				/* The state change occured, skip all
				** other interrupts */
d2681 7
a2687 6
	/* Test Fifo Error Interrupt,
	** If set shutdown all interfaces and
	** reconfigure */
	if (bit_test((u_int8_t*)&reg, ERROR_INTR_ENABLE_BIT)){
		if (bit_test((u_int8_t*)&reg, ERROR_INTR_FLAG)){
			fifo_error_interrupt(card,reg);
d2691 8
a2698 8
	/* -----------------2/6/2003 9:37AM------------------
	** Checking for Interrupt source:
	** 1. Receive DMA Engine
	** 2. Transmit DMA Engine
	** 3. Error conditions.
	** --------------------------------------------------*/
	if (bit_test((u_int8_t*)&reg, GLOBAL_INTR_ENABLE_BIT) &&
		bit_test((u_int8_t*)&reg, DMA_INTR_FLAG)){
d2701 3
a2703 4
        	/* Receive DMA Engine */
		sdla_bus_read_4(card->hw,
                                XILINX_DMA_RX_INTR_PENDING_REG,
                                &dma_rx_reg);
d2705 1
a2705 1
		dma_rx_reg&=card->u.xilinx.active_ch_map;
d2707 1
a2707 1
		if (dma_rx_reg == 0){
d2711 10
a2720 7
		for (i=0; i<card->u.xilinx.num_of_time_slots ;i++){
			if (bit_test((u_int8_t*)&dma_rx_reg, i) &&
				bit_test((u_int8_t*)&card->u.xilinx.logic_ch_map, i)){
				sc=(xilinx_softc_t*)card->u.xilinx.dev_to_ch_map[i];
				if (!sc){
					log(LOG_INFO, "%s: Error: No Dev for Rx logical ch=%d\n",
							card->devname,i);
d2724 1
a2724 1
				xilinx_dma_rx_complete(card,sc);
d2729 3
a2731 4
	        /* Transmit DMA Engine */
		sdla_bus_read_4(card->hw,
					  XILINX_DMA_TX_INTR_PENDING_REG, 
					  &dma_tx_reg);
d2733 1
a2733 1
		dma_tx_reg&=card->u.xilinx.active_ch_map;
d2735 1
a2735 1
		if (dma_tx_reg == 0){
d2739 10
a2748 7
		for (i=0; i<card->u.xilinx.num_of_time_slots ;i++){
			if (bit_test((u_int8_t*)&dma_tx_reg, i) &&
				bit_test((u_int8_t*)&card->u.xilinx.logic_ch_map, i)){
				sc=(xilinx_softc_t*)card->u.xilinx.dev_to_ch_map[i];
				if (!sc){
					log(LOG_INFO, "%s: Error: No Dev for Tx logical ch=%d\n",
							card->devname,i);
d2752 1
a2752 1
				xilinx_dma_tx_complete(card,sc);
a2758 3
	/* -----------------2/6/2003 10:36AM-----------------
	 *    Finish of the interupt handler
	 * --------------------------------------------------*/
d2761 1
a2761 1
/*	write_cpld(card,LED_CONTROL_REG,0x0E); */
d2763 1
a2763 1
	bit_clear((u_int8_t*)&card->in_isr, 0);
d2768 3
a2770 5
/**SECTION*************************************************************
 *
 * 	TASK Functions and Triggers
 *
 **********************************************************************/
d2772 1
a2772 2

/*============================================================================
d2778 2
a2779 1
static void port_set_state (sdla_t *card, int state)
d2783 2
a2784 2
	if (card->state != state){
		switch (state){
d2786 3
a2788 4
			log(LOG_INFO,  "%s: Link connected!\n",
					card->devname);
			aft_red_led_ctrl(card,AFT_LED_OFF);
			aft_green_led_ctrl(card,AFT_LED_ON);
d2792 4
a2795 4
			log(LOG_INFO,  "%s: Link connecting...\n",
					card->devname);
			aft_red_led_ctrl(card,AFT_LED_ON);
			aft_green_led_ctrl(card,AFT_LED_OFF);
d2799 4
a2802 4
			log(LOG_INFO,  "%s: Link disconnected!\n",
					card->devname);
			aft_red_led_ctrl(card,AFT_LED_ON);
			aft_green_led_ctrl(card,AFT_LED_OFF);
d2806 3
a2808 3
		LIST_FOREACH(common, &card->dev_head, next){
			struct ifnet* ifp = (struct ifnet*)&common->ifp;
			if (ifp){
d2816 1
a2816 1
/*============================================================
a2817 2
 *
 *
d2822 1
a2822 1
	sdla_t*	card = (sdla_t*)card_id;
d2824 1
a2824 1
	if (card->front_end_status == FE_CONNECTED){
d2826 6
a2831 6
		port_set_state(card,WAN_CONNECTED);
		card->u.xilinx.state_change_exit_isr=1;
	}else{
		port_set_state(card,WAN_CONNECTING);
		disable_data_error_intr(card,LINK_DOWN);
		card->u.xilinx.state_change_exit_isr=1;
d2835 2
a2836 1
static unsigned char read_cpld(sdla_t *card, unsigned short cpld_off)
d2845 3
a2847 7
	sdla_bus_read_2(card->hw,
				XILINX_MCPU_INTERFACE_ADDR,
				&org_off);

	sdla_bus_write_2(card->hw,
				XILINX_MCPU_INTERFACE_ADDR,
				cpld_off);
d2849 1
a2849 1
	sdla_bus_read_1(card->hw,XILINX_MCPU_INTERFACE, &tmp);
d2852 2
a2853 4
	sdla_bus_write_2(card->hw,
				XILINX_MCPU_INTERFACE_ADDR,
				org_off);
	return tmp;
d2857 1
a2857 1
write_cpld(sdla_t *card, unsigned short off,unsigned char data)
d2859 1
a2859 1
	u_int16_t             org_off;
d2865 3
a2867 7
	sdla_bus_read_2(card->hw,
				XILINX_MCPU_INTERFACE_ADDR,
				&org_off);

	sdla_bus_write_2(card->hw,
				XILINX_MCPU_INTERFACE_ADDR,
				off);
d2869 1
a2869 1
	/* This delay is required to avoid bridge optimization 
d2873 1
a2873 3
	sdla_bus_write_1(card->hw,
				XILINX_MCPU_INTERFACE,
				data);
d2875 1
a2875 1
	/* This delay is required to avoid bridge optimization 
d2880 2
a2881 4
	sdla_bus_write_2(card->hw,
				XILINX_MCPU_INTERFACE_ADDR,
				org_off);
	return 0;
d2885 1
a2885 1
write_front_end_reg(void* card1, unsigned short off, unsigned char value)
d2887 1
a2887 1
	sdla_t* card = (sdla_t*)card1;
d2890 3
a2892 4
	sdla_bus_write_2(card->hw,XILINX_MCPU_INTERFACE_ADDR, off);
	/* AF: Sep 10, 2003
	 * IMPORTANT
	 * This delays are required to avoid bridge optimization 
d2896 1
a2896 1
	sdla_bus_write_1(card->hw,XILINX_MCPU_INTERFACE, value);
d2899 1
a2899 1
	return 0;
d2903 1
a2903 1
/*=======================================================================
d2906 2
a2907 1
static unsigned char read_front_end_reg (void* card1, unsigned short off)
d2909 1
a2909 1
	sdla_t* card = (sdla_t*)card1;
d2914 1
a2914 1
	sdla_bus_read_1(card->hw,XILINX_MCPU_INTERFACE, &tmp);
d2917 1
a2917 1
	return tmp;
d2921 2
a2922 7
/*=========================================
 * enable_data_error_intr
 *
 * Description:
 *	
 *    Run only after the front end comes
 *    up from down state.
d2937 1
a2937 1
 * 
d2940 2
a2941 2
 *   
 *    Enable global DMA and Error interrutps.    
d2952 2
a2953 5
	sdla_bus_read_4(card->hw,
				XILINX_DMA_RX_INTR_PENDING_REG, &reg);
	sdla_bus_read_4(card->hw,
				XILINX_DMA_TX_INTR_PENDING_REG, &reg);

d2956 1
a2956 1
	LIST_FOREACH(common, &card->dev_head, next){
d2959 1
a2959 1
		ifp = (struct ifnet*)&common->ifp;
d2964 1
a2964 1
		if (!(ifp->if_flags & IFF_UP)){
d2969 1
a2969 1
#if defined(DEBUG_INIT)
d2971 1
a2971 1
				sc->if_name, __FUNCTION__);
d2977 7
a2983 5
	/* Enable DMA controler, in order to start the
	** fifo cleaning */
	sdla_bus_read_4(card->hw,XILINX_DMA_CONTROL_REG,&reg);
	bit_set((u_int8_t*)&reg, DMA_ENGINE_ENABLE_BIT);
	sdla_bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
d2986 1
a2986 1
	LIST_FOREACH(common, &card->dev_head, next){
d2989 1
a2989 1
		ifp = (struct ifnet*)&common->ifp;
d2994 1
a2994 1
		if (!(ifp->if_flags & IFF_UP)){
d3000 1
a3000 1
#if defined(DEBUG_INIT)
d3002 1
a3002 1
					sc->if_name, __FUNCTION__);
d3008 1
a3008 1
#if defined(DEBUG_INIT)
d3010 1
a3010 1
				card->devname,sc->if_name);
d3012 1
a3012 1
		bit_clear((u_int8_t*)&sc->idle_start, 0);
d3018 1
a3018 2

	LIST_FOREACH(common, &card->dev_head, next){
d3021 1
a3021 1
		ifp = (struct ifnet*)&common->ifp;
d3026 1
a3026 1
		if (!(ifp->if_flags & IFF_UP)){
d3031 1
a3031 1
#if defined(DEBUG_INIT)
d3033 1
a3033 1
				sc->if_name, __FUNCTION__);
d3036 1
a3036 1
		if (sc->rx_dma_mbuf){
d3038 1
a3038 1
			struct mbuf *m=sc->rx_dma_mbuf;
d3040 1
a3040 1
			sc->rx_dma_mbuf=NULL;
d3045 1
a3045 1
		xilinx_dma_rx(card,sc);
d3047 3
a3049 3
		if (sc->tx_dma_addr && sc->tx_dma_len){
			sc->tx_dma_addr=0;
			sc->tx_dma_len=0;
d3052 1
a3052 1
		if (sc->tx_dma_mbuf){
d3054 1
a3054 1
			sc->tx_dma_mbuf=NULL;
d3057 2
a3058 2
		bit_clear((u_int8_t*)&sc->dma_status, TX_BUSY);
		bit_clear((u_int8_t*)&sc->idle_start, 0);
d3060 1
a3060 1
#if defined(DEBUG_INIT)
d3062 1
a3062 1
			card->devname,sc->if_name);
d3066 7
a3072 7
	/* Clean Tx/Rx Error interrupts, since fifos are now
         * empty, and Tx fifo may generate an underrun which
         * we want to ignore :) */
	sdla_bus_read_4(card->hw,
				XILINX_HDLC_RX_INTR_PENDING_REG, &reg);
	sdla_bus_read_4(card->hw,
				XILINX_HDLC_TX_INTR_PENDING_REG, &reg);
d3075 5
a3079 6

	reg=0;
	sdla_bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
	bit_set((u_int8_t*)&reg, GLOBAL_INTR_ENABLE_BIT);
	bit_set((u_int8_t*)&reg, ERROR_INTR_ENABLE_BIT);
	sdla_bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
d3088 5
a3092 5
	sdla_bus_read_4(card->hw,XILINX_CHIP_CFG_REG,&reg);
	bit_clear((u_int8_t*)&reg, GLOBAL_INTR_ENABLE_BIT);
	bit_clear((u_int8_t*)&reg, ERROR_INTR_ENABLE_BIT);
	if (event==DEVICE_DOWN){
		bit_clear((u_int8_t*)&reg, FRONT_END_INTR_ENABLE_BIT);
d3094 1
a3094 1
	sdla_bus_write_4(card->hw,XILINX_CHIP_CFG_REG,reg);
d3096 3
a3098 3
	sdla_bus_read_4(card->hw,XILINX_DMA_CONTROL_REG,&reg);
	bit_clear((u_int8_t*)&reg, DMA_ENGINE_ENABLE_BIT);
	sdla_bus_write_4(card->hw,XILINX_DMA_CONTROL_REG,reg);
d3102 2
a3103 1
static void xilinx_init_tx_dma_descr(sdla_t *card, xilinx_softc_t *sc)
d3106 1
a3106 1
	unsigned long reg=0;
d3108 2
a3109 2
	dma_descr=(sc->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
	sdla_bus_write_4(card->hw,dma_descr, reg);
d3114 2
a3115 1
static void xilinx_tx_fifo_under_recover (sdla_t *card, xilinx_softc_t *sc)
d3117 2
a3118 2
	struct ifnet	*ifp = (struct ifnet*)&sc->common.ifp;
	u_int32_t reg=0;
d3121 2
a3122 3
#if defined(DEBUG_ERR)
	log(LOG_INFO, "%s:%s: Tx Fifo Recovery \n",
			card->devname,sc->if_name);
d3125 3
a3127 3
       	/* Initialize Tx DMA descriptor: Stop DMA */
	dma_descr=(sc->logic_ch_num<<4) + XILINX_TxDMA_DESCRIPTOR_HI;
	sdla_bus_write_4(card->hw,dma_descr, reg);
d3131 3
a3133 3
	if (sc->tx_dma_addr && sc->tx_dma_len){
		sc->tx_dma_addr=0;
		sc->tx_dma_len=0;
d3136 2
a3137 3
	/* Requeue the current tx packet, for 
	** re-transmission */
	if (sc->tx_dma_mbuf){
d3139 2
a3140 2
				(struct mbuf*)sc->tx_dma_mbuf);
		sc->tx_dma_mbuf=NULL;
d3143 3
a3145 2
	/* Wake up the stack, because tx dma interrupt
	** failed */
d3148 1
a3148 1
#if defined(DEBUG_ERR)
d3150 1
a3150 1
				card->devname,sc->if_name);
d3154 2
a3155 2
	bit_clear((u_int8_t*)&sc->dma_status, TX_BUSY);
	if (!xilinx_dma_tx(card,sc)){
d3157 4
a3160 3
		** to OACTIVE remove this flag and let kernel try to
		** transmit. */
		if (ifp->if_flags & IFF_OACTIVE){
d3168 2
a3169 1
xilinx_write_ctrl_hdlc(sdla_t *card, u_int32_t timeslot, u_int8_t reg_off, u_int32_t data)
d3172 2
a3173 2
	u_int32_t ts_orig=timeslot;
	unsigned long timeout=ticks;
d3175 6
a3180 6
	if (timeslot == 0){
		timeslot=card->u.xilinx.num_of_time_slots-2;
	}else if (timeslot == 1){
		timeslot=card->u.xilinx.num_of_time_slots-1;
	}else{
		timeslot-=2;
d3183 2
a3184 2
	timeslot=timeslot<<XILINX_CURRENT_TIMESLOT_SHIFT;
	timeslot&=XILINX_CURRENT_TIMESLOT_MASK;
d3186 3
a3188 3
	for (;;){
		sdla_bus_read_4(card->hw,XILINX_TIMESLOT_HDLC_CHAN_REG,&reg);
		reg&=XILINX_CURRENT_TIMESLOT_MASK;
d3190 3
a3192 3
		if (reg == timeslot){
			sdla_bus_write_4(card->hw,reg_off,data);
			return 0;
d3195 4
a3198 5
		if ((ticks-timeout) > 1){
			log(LOG_INFO,
			"%s: Error: Access to timeslot %d timed out!\n",
				card->devname,ts_orig);
			return -EIO;
d3202 1
a3202 1
	return -EIO;
d3205 2
a3206 1
static int set_chan_state(sdla_t* card, struct ifnet* ifp, int state)
d3210 2
a3211 2
	if (sc == NULL){
		return 0;
d3213 3
a3215 4
	if (state == WAN_CONNECTED){
#if defined(DEBUG_INIT)
		log(LOG_INFO, "%s: Setting idle_start to 0\n",
				sc->if_name);
d3217 1
a3217 1
		bit_clear((u_int8_t*)&sc->idle_start, 0);
d3220 1
a3220 1
	return 0;
d3225 1
a3225 1
static char fifo_code_vector[] = {0, 1, 3, 7,0xF,0x1F};
d3229 1
a3229 1
	unsigned char req_fifo_size,fifo_size;
d3232 4
a3235 2
	/* Calculate the optimal fifo size based
         * on the number of time slots requested */
d3237 1
a3237 1
	if (IS_T1(&card->fe_te.te_cfg)){
d3239 17
a3255 17
		if (sc->num_of_time_slots == NUM_OF_T1_CHANNELS){
			req_fifo_size=32;
		}else if (sc->num_of_time_slots == 1){
			req_fifo_size=1;
		}else if (sc->num_of_time_slots == 2 ||
					sc->num_of_time_slots == 3){
			req_fifo_size=2;
		}else if (sc->num_of_time_slots >= 4 &&
					sc->num_of_time_slots<= 7){
			req_fifo_size=4;
		}else if (sc->num_of_time_slots >= 8 &&
					sc->num_of_time_slots<= 15){
			req_fifo_size=8;
		}else if (sc->num_of_time_slots >= 16 &&
					sc->num_of_time_slots<= 23){
			req_fifo_size=16;
		}else{
d3257 24
a3280 28
					card->devname,
					sc->num_of_time_slots);
			return -EINVAL;
		}
	}else{
		if (sc->num_of_time_slots == (NUM_OF_E1_CHANNELS-1)){
			req_fifo_size=32;
		}else if (sc->num_of_time_slots == 1){
			req_fifo_size=1;
		}else if (sc->num_of_time_slots == 2 ||
				sc->num_of_time_slots == 3){
			req_fifo_size=2;
		}else if (sc->num_of_time_slots >= 4 &&
				sc->num_of_time_slots <= 7){
			req_fifo_size=4;
		}else if (sc->num_of_time_slots >= 8 &&
				sc->num_of_time_slots <= 15){
			req_fifo_size=8;
		}else if (sc->num_of_time_slots >= 16 &&
				sc->num_of_time_slots <= 31){
			req_fifo_size=16;
		}else{
			log(LOG_INFO,
			"%s:%s: Invalid number of timeslots %d\n",
					card->devname,
					sc->if_name,
					sc->num_of_time_slots);
			return -EINVAL;
d3284 1
a3284 1
#if defined(DEBUG_INIT)
d3286 9
a3294 16
				card->devname,
				sc->if_name,
				req_fifo_size,
				sc->num_of_time_slots);
#endif
	fifo_size=map_fifo_baddr_and_size(card,
					req_fifo_size,
					&sc->fifo_base_addr);
	if (fifo_size == 0 || sc->fifo_base_addr == 31){
		log(LOG_INFO,
		"%s:%s: Error: Failed to obtain fifo size %d or addr %d\n",
				card->devname,
				sc->if_name,
				fifo_size,
				sc->fifo_base_addr);
		return -EINVAL;
d3297 1
a3297 1
#if defined(DEBUG_INIT)
d3299 2
a3300 5
			card->devname,
			sc->if_name,
			req_fifo_size,
			sc->num_of_time_slots,
			fifo_size);
d3303 3
a3305 3
	for (i=0;i<sizeof(fifo_size_vector);i++){
		if (fifo_size_vector[i] == fifo_size){
			sc->fifo_size_code=fifo_code_vector[i];
d3310 4
a3313 7
	if (fifo_size != req_fifo_size){
		log(LOG_INFO,
		"%s:%s: WARN: Failed to obtain the req fifo %d got %d\n",
			card->devname,
			sc->if_name,
			req_fifo_size,
			fifo_size);
d3316 1
a3316 1
#if defined(DEBUG_INIT)
d3318 2
a3319 3
		card->devname,sc->if_name,fifo_size,
		sc->num_of_time_slots,sc->fifo_size_code,
		sc->fifo_base_addr);
d3323 1
a3323 1
	return 0;
d3328 2
a3329 1
map_fifo_baddr_and_size(sdla_t *card, unsigned char fifo_size, unsigned char *addr)
d3331 1
a3331 1
	u_int32_t reg=0;
d3334 2
a3335 2
	for (i=0;i<fifo_size;i++){
		bit_set((u_int8_t*)&reg, i);
d3338 1
a3338 1
#if defined(DEBUG_INIT)
d3340 1
a3340 1
			card->devname,reg,card->u.xilinx.fifo_addr_map);
d3342 2
a3343 2
	for (i=0;i<32;i+=fifo_size){
		if (card->u.xilinx.fifo_addr_map & (reg<<i)){
d3346 2
a3347 2
		card->u.xilinx.fifo_addr_map |= reg<<i;
		*addr=i;
d3349 1
a3349 1
#if defined(DEBUG_INIT)
d3351 1
a3351 1
			card->devname,card->u.xilinx.fifo_addr_map,i);
d3353 1
a3353 1
		return fifo_size;
d3356 2
a3357 2
	if (fifo_size == 1){
		return 0;
d3362 1
a3362 1
	return map_fifo_baddr_and_size(card,fifo_size,addr);
d3366 2
a3367 1
static int free_fifo_baddr_and_size (sdla_t *card, xilinx_softc_t *sc)
d3369 1
a3369 1
	u_int32_t reg=0;
d3372 2
a3373 2
	for (i=0;i<sc->fifo_size;i++){
		bit_set((u_int8_t*)&reg, i);
d3376 3
a3378 5
#if defined(DEBUG_INIT)
	log(LOG_INFO, "%s: Unmapping 0x%X from 0x%lX\n",
		card->devname,
		reg<<sc->fifo_base_addr,
		card->u.xilinx.fifo_addr_map);
d3380 1
a3380 1
	card->u.xilinx.fifo_addr_map &= ~(reg<<sc->fifo_base_addr);
d3382 1
a3382 1
#if defined(DEBUG_INIT)
d3387 2
a3388 2
	sc->fifo_size=0;
	sc->fifo_base_addr=0;
d3390 1
a3390 1
	return 0;
d3393 2
a3394 1
static void aft_red_led_ctrl(sdla_t *card, int mode)
d3398 1
a3398 1
	sdla_bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &led);
d3400 9
a3408 9
	if (mode == AFT_LED_ON){
		bit_clear((u_int8_t*)&led, XILINX_RED_LED);
	}else if (mode == AFT_LED_OFF){
		bit_set((u_int8_t*)&led, XILINX_RED_LED);
	}else{
		if (bit_test((u_int8_t*)&led, XILINX_RED_LED)){
			bit_clear((u_int8_t*)&led, XILINX_RED_LED);
		}else{
			bit_set((u_int8_t*)&led, XILINX_RED_LED);
d3412 1
a3412 1
	sdla_bus_write_4(card->hw,XILINX_CHIP_CFG_REG, led);
d3415 2
a3416 1
static void aft_led_timer(void *data)
d3418 1
a3418 1
	sdla_t *card=(sdla_t*)data;
d3421 1
a3421 1
	if (bit_test((u_int8_t*)&card->critical, CARD_DOWN)){
d3429 1
a3429 1
		te_alarm&=~(BIT_OOSMF_ALARM|BIT_OOCMF_ALARM);
d3431 2
a3432 2
		if (!te_alarm){
			if (card->state == WAN_CONNECTED){
d3435 1
a3435 1
			}else{
d3440 1
a3440 1
		}else if (te_alarm & (BIT_RED_ALARM|BIT_LOS_ALARM)){
d3444 1
a3444 1
		}else if (te_alarm & BIT_OOF_ALARM){
d3448 1
a3448 1
		}else if (te_alarm & BIT_AIS_ALARM){
d3452 1
a3452 1
		}else if (te_alarm & BIT_YEL_ALARM){
d3456 1
a3456 1
		}else{
d3460 1
a3460 1
					card->devname,te_alarm);
d3466 1
a3466 1
		timeout_add(&card->u.xilinx.led_timer,hz);
d3471 2
a3472 1
int aft_core_ready(sdla_t *card)
d3475 1
a3475 1
	volatile unsigned char cnt=0;
d3477 3
a3479 3
	for (;;){
		sdla_bus_read_4(card->hw,XILINX_CHIP_CFG_REG, &reg);
		if (!bit_test((u_int8_t*)&reg, HDLC_CORE_READY_FLAG_BIT)){
d3482 3
a3484 3
			if (++cnt > 5){
				return  -EINVAL;
			}else{
d3486 2
a3487 2
                                /* WARNING: we cannot do this while in
                                 * critical area */
d3489 2
a3490 2
		}else{
			return 0;
d3494 1
a3494 1
	return -EINVAL;
a3495 3


/****** End ****************************************************************/
@


1.1
log
@Sangoma Network Device driver for AFT series card (initiali version).
ok mcbride@@
@
text
@d1 2
@

