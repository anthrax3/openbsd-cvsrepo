head	1.30;
access;
symbols
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.27.0.6
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.27.0.4
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	UBC_SYNC_A:1.26
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.23
	UBC:1.21.0.2
	UBC_BASE:1.21
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.9.0.2
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.30
date	2005.05.10.01.37.30;	author brad;	state dead;
branches;
next	1.29;

1.29
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2003.08.19.14.01.35;	author mpech;	state Exp;
branches;
next	1.26;

1.26
date	2002.12.15.13.18.50;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.14.07.35.18;	author kjc;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.03.20.01.36;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.09.20.17.02.31;	author mpech;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.12.20.03.49;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.27.06.34.50;	author kjc;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.25.02.18.48;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.12.15.40.31;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.22.01.38.54;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.23.22.59.09;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.20.19.39.43;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.17.15.47.12;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.21.20.54.04;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	99.11.17.05.21.18;	author jason;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	99.09.30.00.12.21;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	99.06.29.17.13.40;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	99.03.16.04.26.39;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	99.03.10.20.04.13;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	99.02.26.17.05.55;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	98.10.10.04.30.09;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	98.09.22.21.54.55;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	98.09.21.05.24.54;	author jason;	state Exp;
branches;
next	;

1.9.2.1
date	2000.02.21.22.29.13;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.05.14.22.25.47;	author niklas;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2001.07.04.10.42.25;	author niklas;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.9.2.7;

1.9.2.7
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.9.2.8;

1.9.2.8
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	;

1.21.2.1
date	2002.06.11.03.42.26;	author art;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2003.05.19.22.18.01;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.30
log
@put this in the Attic
@
text
@/*	$OpenBSD: if_tx.c,v 1.29 2005/01/15 05:24:11 brad Exp $	*/
/* $FreeBSD: src/sys/pci/if_tx.c,v 1.45 2001/02/07 20:11:02 semenu Exp $ */

/*-
 * Copyright (c) 1997 Semen Ustimenko (semen@@iclub.nsu.ru)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * EtherPower II 10/100  Fast Ethernet (tx0)
 * (aka SMC9432TX based on SMC83c170 EPIC chip)
 * 
 * Thanks are going to Steve Bauer and Jason Wright.
 *
 * todo:
 *	Implement FULL IFF_MULTICAST support.
 *	
 */

/* We should define compile time options before if_txvar.h included */
#define	EARLY_RX	1
/*#define	EPIC_DEBUG	1*/

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/queue.h>

#if defined(__FreeBSD__)
#define NBPFILTER	1

#include <net/if.h>
#include <net/if_arp.h>
#include <net/ethernet.h>
#include <net/if_media.h>

#include <net/bpf.h>

#include <vm/vm.h>              /* for vtophys */
#include <vm/pmap.h>            /* for vtophys */
#include <machine/clock.h>      /* for DELAY */
#include <machine/bus_memio.h>
#include <machine/bus_pio.h>
#include <machine/bus.h>
#include <machine/resource.h>
#include <sys/bus.h>
#include <sys/rman.h>

#include <pci/pcireg.h>
#include <pci/pcivar.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/miidevs.h>

#include <dev/mii/lxtphyreg.h>

#include "miibus_if.h"

#include <pci/if_txvar.h>
#else /* __OpenBSD__ */
#include "bpfilter.h"

#include <sys/device.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/if_media.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#endif

#ifdef IPX
#include <netipx/ipx.h>
#include <netipx/ipx_if.h>
#endif

#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <uvm/uvm_extern.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/miidevs.h>
#include <dev/mii/lxtphyreg.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <dev/pci/if_txvar.h>
#endif

#if defined(__FreeBSD__)
MODULE_DEPEND(tx, miibus, 1, 1, 1);
#endif

#if defined(__FreeBSD__)
#define EPIC_INTR_RET_TYPE void
#define EPIC_MIIBUS_WRITEREG_RET_TYPE int
#define EPIC_STATIC static
#else /* __OpenBSD__ */
#define EPIC_INTR_RET_TYPE int
#define EPIC_MIIBUS_WRITEREG_RET_TYPE void
#define EPIC_STATIC
#endif

EPIC_STATIC int epic_ifioctl(register struct ifnet *, u_long, caddr_t);
EPIC_STATIC EPIC_INTR_RET_TYPE epic_intr(void *);
EPIC_STATIC int epic_common_attach(epic_softc_t *);
EPIC_STATIC void epic_ifstart(struct ifnet *);
EPIC_STATIC void epic_ifwatchdog(struct ifnet *);
EPIC_STATIC int epic_init(epic_softc_t *);
EPIC_STATIC void epic_stop(epic_softc_t *);
EPIC_STATIC void epic_rx_done(epic_softc_t *);
EPIC_STATIC void epic_tx_done(epic_softc_t *);
EPIC_STATIC int epic_init_rings(epic_softc_t *);
EPIC_STATIC void epic_free_rings(epic_softc_t *);
EPIC_STATIC void epic_stop_activity(epic_softc_t *);
EPIC_STATIC void epic_start_activity(epic_softc_t *);
EPIC_STATIC void epic_set_rx_mode(epic_softc_t *);
EPIC_STATIC void epic_set_tx_mode(epic_softc_t *);
EPIC_STATIC void epic_set_mc_table(epic_softc_t *);
EPIC_STATIC int epic_read_eeprom(epic_softc_t *,u_int16_t);
EPIC_STATIC void epic_output_eepromw(epic_softc_t *, u_int16_t);
EPIC_STATIC u_int16_t epic_input_eepromw(epic_softc_t *);
EPIC_STATIC u_int8_t epic_eeprom_clock(epic_softc_t *,u_int8_t);
EPIC_STATIC void epic_write_eepromreg(epic_softc_t *,u_int8_t);
EPIC_STATIC u_int8_t epic_read_eepromreg(epic_softc_t *);

EPIC_STATIC int epic_read_phy_reg(epic_softc_t *, int, int);
EPIC_STATIC void epic_write_phy_reg(epic_softc_t *, int, int, int);

EPIC_STATIC int epic_miibus_readreg(struct device*, int, int);
EPIC_STATIC EPIC_MIIBUS_WRITEREG_RET_TYPE epic_miibus_writereg(struct device*, int, int, int);
EPIC_STATIC void epic_miibus_statchg(struct device *);
EPIC_STATIC void epic_miibus_mediainit(struct device *);


EPIC_STATIC int epic_ifmedia_upd(struct ifnet *);
EPIC_STATIC void epic_ifmedia_sts(struct ifnet *, struct ifmediareq *);
EPIC_STATIC void epic_tick(void *);

/* -------------------------------------------------------------------------
   OS-specific part
   ------------------------------------------------------------------------- */

#if defined(__OpenBSD__)
/* -----------------------------OpenBSD------------------------------------- */

int epic_openbsd_probe(struct device *,void *,void *);
void epic_openbsd_attach(struct device *, struct device *, void *);
void epic_openbsd_shutdown(void *);

struct cfattach tx_ca = {
	sizeof(epic_softc_t), epic_openbsd_probe, epic_openbsd_attach 
};
struct cfdriver tx_cd = {
	NULL,"tx",DV_IFNET
};

/* Synopsis: Check if device id corresponds with SMC83C170 id. */
int 
epic_openbsd_probe(
    struct device *parent,
    void *match,
    void *aux )
{
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == SMC_VENDORID &&
	    PCI_PRODUCT(pa->pa_id) == SMC_DEVICEID_83C170)
		return (1);
	return (0);
}

void
epic_openbsd_attach(
    struct device *parent,
    struct device *self,
    void *aux )
{
	epic_softc_t *sc = (epic_softc_t*)self;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
	struct ifnet *ifp;
	bus_size_t iosize; 
	u_int32_t command;

	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	    PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);

	if ((command & (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE)) == 0) {
		printf(": neither i/o nor mem enabled\n");
		return;
	}

	if (command & PCI_COMMAND_MEM_ENABLE) {
		if (pci_mapreg_map(pa, PCI_BASEMEM, PCI_MAPREG_TYPE_MEM, 0,
		    &sc->sc_st, &sc->sc_sh, NULL, &iosize, 0)) {
			printf(": can't map mem space\n");
			return;
		}
	} else {
		if (pci_mapreg_map(pa, PCI_BASEIO, PCI_MAPREG_TYPE_IO, 0,
		    &sc->sc_st, &sc->sc_sh, NULL, &iosize, 0)) {
			printf(": can't map i/o space\n");
			return;
		}
	}

	ifp = &sc->sc_if;
	bcopy(sc->dev.dv_xname, ifp->if_xname,IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = epic_ifioctl;
	ifp->if_start = epic_ifstart;
	ifp->if_watchdog = epic_ifwatchdog;
	IFQ_SET_READY(&ifp->if_snd);

	/* Fetch card id */
	sc->cardvend = pci_conf_read(pc, pa->pa_tag, PCI_SUBVEND_0);
	sc->cardid = pci_conf_read(pc, pa->pa_tag, PCI_SUBDEV_0);

	/* Do common attach procedure */
	if( epic_common_attach(sc) ) return;

	/* Map interrupt */
	if( pci_intr_map(pa, &ih)) {
		printf(": can't map interrupt\n");
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, epic_intr, sc, 
	    self->dv_xname);

	if( NULL == sc->sc_ih ) {
		printf(": can't establish interrupt");
		if( intrstr )printf(" at %s",intrstr);
		printf("\n");
		return;
	} 

	/* Display some info */
	printf(": %s address %s\n", intrstr, ether_sprintf(sc->sc_macaddr));

	/* Init ifmedia interface */
	ifmedia_init(&sc->miibus.mii_media, 0,
		epic_ifmedia_upd, epic_ifmedia_sts);
	sc->miibus.mii_ifp = ifp;
	sc->miibus.mii_readreg = epic_miibus_readreg;
	sc->miibus.mii_writereg = epic_miibus_writereg;
	sc->miibus.mii_statchg = epic_miibus_statchg;
	mii_phy_probe(self, &sc->miibus, 0xffffffff);
	if (LIST_FIRST(&sc->miibus.mii_phys) == NULL) {
		ifmedia_add(&sc->miibus.mii_media, IFM_ETHER|IFM_NONE,0,NULL);
		ifmedia_set(&sc->miibus.mii_media, IFM_ETHER|IFM_NONE);
        } else
		ifmedia_set(&sc->miibus.mii_media, IFM_ETHER|IFM_AUTO);

	timeout_set(&sc->sc_tmo, epic_tick, sc);

	/* Attach os interface and bpf */
	if_attach(ifp);
	ether_ifattach(ifp);

	/* Set shutdown routine to stop DMA process */ 
	shutdownhook_establish(epic_openbsd_shutdown, sc);
}

/* Simple call epic_stop() */
void
epic_openbsd_shutdown(
    void *sc)
{
	epic_stop(sc);
}

#else /* __FreeBSD__ */
/* -----------------------------FreeBSD------------------------------------- */

static int epic_freebsd_probe(device_t);
static int epic_freebsd_attach(device_t);
static void epic_freebsd_shutdown(device_t);
static int epic_freebsd_detach(device_t);
static struct epic_type *epic_devtype(device_t);

static device_method_t epic_methods[] = {
	/* Device interface */   
	DEVMETHOD(device_probe,		epic_freebsd_probe),
	DEVMETHOD(device_attach,	epic_freebsd_attach),
	DEVMETHOD(device_detach,	epic_freebsd_detach),
	DEVMETHOD(device_shutdown,	epic_freebsd_shutdown),

	/* bus interface */
	DEVMETHOD(bus_print_child,	bus_generic_print_child),
	DEVMETHOD(bus_driver_added,	bus_generic_driver_added),

	/* MII interface */
	DEVMETHOD(miibus_readreg,	epic_miibus_readreg),
	DEVMETHOD(miibus_writereg,	epic_miibus_writereg),
	DEVMETHOD(miibus_statchg,	epic_miibus_statchg),
	DEVMETHOD(miibus_mediainit,	epic_miibus_mediainit),

	{ 0, 0 }
};

static driver_t epic_driver = {
        "tx",
        epic_methods,
        sizeof(epic_softc_t)
};

static devclass_t epic_devclass;

DRIVER_MODULE(if_tx, pci, epic_driver, epic_devclass, 0, 0);
DRIVER_MODULE(miibus, tx, miibus_driver, miibus_devclass, 0, 0);

static struct epic_type epic_devs[] = {
	{ SMC_VENDORID, SMC_DEVICEID_83C170,
		"SMC EtherPower II 10/100" },   
	{ 0, 0, NULL }
};

static int
epic_freebsd_probe(dev)
	device_t dev;
{
	struct epic_type *t;

	t = epic_devtype(dev);

	if (t != NULL) {
		device_set_desc(dev, t->name);
		return(0);
	}

	return(ENXIO);
}

static struct epic_type *
epic_devtype(dev)
	device_t dev;
{
	struct epic_type *t;

	t = epic_devs;

	while(t->name != NULL) {
		if ((pci_get_vendor(dev) == t->ven_id) &&
		    (pci_get_device(dev) == t->dev_id)) {
			return(t);
		}
		t++;
	}
	return (NULL);
}

#if defined(EPIC_USEIOSPACE)
#define	EPIC_RES	SYS_RES_IOPORT
#define	EPIC_RID	PCIR_BASEIO
#else
#define	EPIC_RES	SYS_RES_MEMORY
#define	EPIC_RID	PCIR_BASEMEM
#endif

/*
 * Do FreeBSD-specific attach routine, like map registers, alloc softc
 * structure and etc.
 */
static int
epic_freebsd_attach(dev)
	device_t dev;
{
	struct ifnet *ifp;
	epic_softc_t *sc;
	u_int32_t command;
	int unit, error;
	int i, s, rid, tmp;

	s = splimp ();

	sc = device_get_softc(dev);
	unit = device_get_unit(dev);

	/* Preinitialize softc structure */
    	bzero(sc, sizeof(epic_softc_t));		
	sc->unit = unit;
	sc->dev = dev;

	/* Fill ifnet structure */
	ifp = &sc->sc_if;
	ifp->if_unit = unit;
	ifp->if_name = "tx";
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST;
	ifp->if_ioctl = epic_ifioctl;
	ifp->if_start = epic_ifstart;
	ifp->if_watchdog = epic_ifwatchdog;
	ifp->if_init = (if_init_f_t*)epic_init;
	ifp->if_timer = 0;
	ifp->if_baudrate = 10000000;
	IFQ_SET_MAXLEN(&ifp->if_snd, TX_RING_SIZE - 1);
	IFQ_SET_READY(&ifp->if_snd);

	/* Enable ports, memory and busmastering */
	command = pci_read_config(dev, PCIR_COMMAND, 4);
	command |= PCIM_CMD_PORTEN | PCIM_CMD_MEMEN | PCIM_CMD_BUSMASTEREN;
	pci_write_config(dev, PCIR_COMMAND, command, 4);
	command = pci_read_config(dev, PCIR_COMMAND, 4);

#if defined(EPIC_USEIOSPACE)
	if (!(command & PCIM_CMD_PORTEN)) {
		device_printf(dev, "failed to enable I/O mapping!\n");
		error = ENXIO;
		goto fail;
	}
#else
	if (!(command & PCIM_CMD_MEMEN)) {
		device_printf(dev, "failed to enable memory mapping!\n");
		error = ENXIO;
		goto fail;
	}
#endif

	rid = EPIC_RID;
	sc->res = bus_alloc_resource(dev, EPIC_RES, &rid, 0, ~0, 1,
	    RF_ACTIVE);

	if (sc->res == NULL) {
		device_printf(dev, "couldn't map ports/memory\n");
		error = ENXIO;
		goto fail;
	}

	sc->sc_st = rman_get_bustag(sc->res);
	sc->sc_sh = rman_get_bushandle(sc->res);

	/* Allocate interrupt */
	rid = 0;
	sc->irq = bus_alloc_resource(dev, SYS_RES_IRQ, &rid, 0, ~0, 1,
	    RF_SHAREABLE | RF_ACTIVE);

	if (sc->irq == NULL) {
		device_printf(dev, "couldn't map interrupt\n");
		bus_release_resource(dev, EPIC_RES, EPIC_RID, sc->res);
		error = ENXIO;
		goto fail;
	}

	error = bus_setup_intr(dev, sc->irq, INTR_TYPE_NET,
	    epic_intr, sc, &sc->sc_ih);

	if (error) {
		bus_release_resource(dev, SYS_RES_IRQ, 0, sc->irq);
		bus_release_resource(dev, EPIC_RES, EPIC_RID, sc->res);
		device_printf(dev, "couldn't set up irq\n");
		goto fail;
	}

	/* Bring the chip out of low-power mode and reset it. */
	CSR_WRITE_4( sc, GENCTL, GENCTL_SOFT_RESET );
	DELAY(500);

	/* Workaround for Application Note 7-15 */
	for (i=0; i<16; i++) CSR_WRITE_4(sc, TEST1, TEST1_CLOCK_TEST);

	/*
	 * Do ifmedia setup.
	 */
	if (mii_phy_probe(dev, &sc->miibus,
	    epic_ifmedia_upd, epic_ifmedia_sts)) {
		device_printf(dev, "MII without any PHY!?\n");
		bus_teardown_intr(dev, sc->irq, sc->sc_ih);
		bus_release_resource(dev, SYS_RES_IRQ, 0, sc->irq);
		bus_release_resource(dev, EPIC_RES, EPIC_RID, sc->res);
		error = ENXIO;
		goto fail;
	}

	/* Do OS independent part, including chip wakeup and reset */
	if (epic_common_attach(sc)) {
		device_printf(dev, "memory distribution error\n");
		bus_teardown_intr(dev, sc->irq, sc->sc_ih);
		bus_release_resource(dev, SYS_RES_IRQ, 0, sc->irq);
		bus_release_resource(dev, EPIC_RES, EPIC_RID, sc->res);
		error = ENXIO;
		goto fail;
	}

	/* Fetch card id */
	sc->cardvend = pci_read_config(sc->dev, PCIR_SUBVEND_0, 2);
	sc->cardid = pci_read_config(sc->dev, PCIR_SUBDEV_0, 2);
	printf("vend/id(%x/%x) ", sc->cardvend, sc->cardid);

	/* Display ethernet address ,... */
	device_printf(dev, "address %6D,", sc->sc_macaddr, ":");

	/* board type and ... */
	printf(" type ");
	for(i=0x2c;i<0x32;i++) {
		tmp = epic_read_eeprom( sc, i );
		if( ' ' == (u_int8_t)tmp ) break;
		printf("%c",(u_int8_t)tmp);
		tmp >>= 8;
		if( ' ' == (u_int8_t)tmp ) break;
		printf("%c",(u_int8_t)tmp);
	}
	printf("\n");

	/* Attach to OS's managers */
	ether_ifattach(ifp, ETHER_BPF_SUPPORTED);
	callout_handle_init(&sc->stat_ch);

fail:
	splx(s);

	return(error);
}

/*
 * Detach driver and free resources
 */
static int
epic_freebsd_detach(dev)
	device_t dev;
{
	struct ifnet *ifp;
	epic_softc_t *sc;
	int s;

	s = splimp();

	sc = device_get_softc(dev);
	ifp = &sc->arpcom.ac_if;

	ether_ifdetach(ifp, ETHER_BPF_SUPPORTED);

	epic_stop(sc);

	bus_generic_detach(dev);
	device_delete_child(dev, sc->miibus);

	bus_teardown_intr(dev, sc->irq, sc->sc_ih);
	bus_release_resource(dev, SYS_RES_IRQ, 0, sc->irq);
	bus_release_resource(dev, EPIC_RES, EPIC_RID, sc->res);

	free(sc->pool, M_DEVBUF);

	splx(s);

	return(0);
}

#undef	EPIC_RES
#undef	EPIC_RID

/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
EPIC_STATIC void
epic_freebsd_shutdown(dev)
	device_t dev;
{
	epic_softc_t *sc;

	sc = device_get_softc(dev);

	epic_stop(sc);

	return;
}
#endif /* __OpenBSD__ */

/* ------------------------------------------------------------------------
   OS-independing part
   ------------------------------------------------------------------------ */

/*
 * This is if_ioctl handler. 
 */
EPIC_STATIC int
epic_ifioctl(ifp, command, data)
	struct ifnet *ifp;
	u_long command;
	caddr_t data;
{
	epic_softc_t *sc = ifp->if_softc;
	struct mii_data	*mii;
	struct ifreq *ifr = (struct ifreq *) data;
	int x, error = 0;

	x = splimp();

	switch (command) {
#if defined(__FreeBSD__)
	case SIOCSIFADDR:
	case SIOCGIFADDR:
	case SIOCSIFMTU:
		error = ether_ioctl(ifp, command, data);
		break;
#else /* __OpenBSD__ */
	case SIOCSIFADDR: {
		struct ifaddr *ifa = (struct ifaddr *)data;
		
		ifp->if_flags |= IFF_UP;
		switch(ifa->ifa_addr->sa_family) {
#if INET
		case AF_INET:
			epic_stop(sc);
			epic_init(sc);
			arp_ifinit(&sc->arpcom,ifa);
			break;
#endif
#if NS
		case AF_NS: {
			register struct ns_addr * ina = &IA_SNS(ifa)->sns_addr;

			if( ns_nullhost(*ina) ) 
				ina->x_host = 
				    *(union ns_host *) LLADDR(ifp->if_sadl);
			else
				bcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),
				    ifp->if_addrlen);

			epic_stop(sc);
			epic_init(sc);
			break;
		}
#endif
		default:
			epic_stop(sc);
			epic_init(sc);		
			break;
		}
		break;
	}
#endif /* __FreeBSD__ */

	case SIOCSIFFLAGS:
		/*
		 * If the interface is marked up and stopped, then start it.
		 * If it is marked down and running, then stop it.
		 */
		if (ifp->if_flags & IFF_UP) {
			if ((ifp->if_flags & IFF_RUNNING) == 0) {
				epic_init(sc);
				break;
			}
		} else {
			if (ifp->if_flags & IFF_RUNNING) {
				epic_stop(sc);
				break;
			}
		}

		/* Handle IFF_PROMISC flag */
		epic_stop_activity(sc);	
		epic_set_rx_mode(sc);
		epic_start_activity(sc);	
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		/* Update out multicast list */
#if defined(__FreeBSD__) && __FreeBSD_version >= 300000
		epic_set_mc_table(sc);
		error = 0;
#else
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti((struct ifreq *)data, &sc->arpcom) :
		    ether_delmulti((struct ifreq *)data, &sc->arpcom);

		if (error == ENETRESET) {
			if (ifp->if_flags & IFF_RUNNING)
				epic_set_mc_table(sc);
			error = 0;
		}
#endif
		break;

	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		mii = epic_mii_ptr(sc);
		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);
		break;

	default:
		error = EINVAL;
	}
	splx(x);

	return error;
}

/*
 * OS-independed part of attach process. allocate memory for descriptors
 * and frag lists, wake up chip, read MAC address and PHY identyfier.
 * Return -1 on failure.
 */
EPIC_STATIC int
epic_common_attach(sc)
	epic_softc_t *sc;
{
	int i;
	caddr_t pool;

	i = sizeof(struct epic_frag_list)*TX_RING_SIZE +
	    sizeof(struct epic_rx_desc)*RX_RING_SIZE + 
	    sizeof(struct epic_tx_desc)*TX_RING_SIZE + PAGE_SIZE;
	sc->pool = (epic_softc_t *) malloc( i, M_DEVBUF, M_NOWAIT);

	if (sc->pool == NULL) {
		printf(": can't allocate memory for buffers\n");
		return -1;
	}
	bzero(sc->pool, i);

	/* Align pool on PAGE_SIZE */
	pool = (caddr_t)sc->pool;
	pool = (caddr_t)((u_int32_t)(pool + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1));

	/* Distribute memory */
	sc->tx_flist = (void *)pool;
	pool += sizeof(struct epic_frag_list)*TX_RING_SIZE;
	sc->rx_desc = (void *)pool;
	pool += sizeof(struct epic_rx_desc)*RX_RING_SIZE;
	sc->tx_desc = (void *)pool;

	/* Bring the chip out of low-power mode. */
	CSR_WRITE_4( sc, GENCTL, GENCTL_SOFT_RESET);
	DELAY(500);

	/* Workaround for Application Note 7-15 */
	for (i=0; i<16; i++) CSR_WRITE_4(sc, TEST1, TEST1_CLOCK_TEST);

	/* Read mac address from EEPROM */
	for (i = 0; i < ETHER_ADDR_LEN / sizeof(u_int16_t); i++)
		((u_int16_t *)sc->sc_macaddr)[i] = epic_read_eeprom(sc,i);

	/* Set defaults */
	sc->tx_threshold = TRANSMIT_THRESHOLD;
	sc->txcon = TXCON_DEFAULT;
	sc->miicfg = MIICFG_SMI_ENABLE;
	sc->phyid = EPIC_UNKN_PHY;
	sc->serinst = -1;

	if (sc->cardvend != SMC_VENDORID) 
		printf(EPIC_FORMAT ": unknown card vendor 0x%04x\n", EPIC_ARGS(sc), sc->cardvend);

	return 0;
}

/*
 * This is if_start handler. It takes mbufs from if_snd queue
 * and queue them for transmit, one by one, until TX ring become full
 * or queue become empty.
 */
EPIC_STATIC void
epic_ifstart(ifp)
	struct ifnet * ifp;
{
	epic_softc_t *sc = ifp->if_softc;
	struct epic_tx_buffer *buf;
	struct epic_tx_desc *desc;
	struct epic_frag_list *flist;
	struct mbuf *m0;
	register struct mbuf *m;
	register int i;

	while( sc->pending_txs < TX_RING_SIZE  ){
		buf = sc->tx_buffer + sc->cur_tx;
		desc = sc->tx_desc + sc->cur_tx;
		flist = sc->tx_flist + sc->cur_tx;

		/* Get next packet to send */
		IFQ_DEQUEUE( &ifp->if_snd, m0 );

		/* If nothing to send, return */
		if( NULL == m0 ) return;

		/* Fill fragments list */
		for( m=m0, i=0;
		    (NULL != m) && (i < EPIC_MAX_FRAGS);
		    m = m->m_next, i++ ) {
			flist->frag[i].fraglen = m->m_len; 
			flist->frag[i].fragaddr = vtophys( mtod(m, caddr_t) );
		}
		flist->numfrags = i;

		/* If packet was more than EPIC_MAX_FRAGS parts, */
		/* recopy packet to new allocated mbuf cluster */
		if( NULL != m ){
			EPIC_MGETCLUSTER(m);
			if( NULL == m ){
				printf(EPIC_FORMAT ": cannot allocate mbuf cluster\n",EPIC_ARGS(sc));
				m_freem(m0);
				ifp->if_oerrors++;
				continue;
			}

			m_copydata( m0, 0, m0->m_pkthdr.len, mtod(m,caddr_t) );
			flist->frag[0].fraglen = 
			     m->m_pkthdr.len = m->m_len = m0->m_pkthdr.len;
			m->m_pkthdr.rcvif = ifp;

			flist->numfrags = 1;
			flist->frag[0].fragaddr = vtophys( mtod(m, caddr_t) );
			m_freem(m0);
			m0 = m;
		}

		buf->mbuf = m0;
		sc->pending_txs++;
		sc->cur_tx = ( sc->cur_tx + 1 ) & TX_RING_MASK;
		desc->control = 0x01;
		desc->txlength = 
		    max(m0->m_pkthdr.len,ETHER_MIN_LEN-ETHER_CRC_LEN);
		desc->status = 0x8000;
		CSR_WRITE_4( sc, COMMAND, COMMAND_TXQUEUED );

		/* Set watchdog timer */
		ifp->if_timer = 8;

#if NBPFILTER > 0
		if( ifp->if_bpf ) 
			bpf_mtap( EPIC_BPFTAP_ARG(ifp), m0 );
#endif
	}

	ifp->if_flags |= IFF_OACTIVE;

	return;
	
}

/*
 * Synopsis: Finish all received frames.
 */
EPIC_STATIC void
epic_rx_done(sc)
	epic_softc_t *sc;
{
	u_int16_t len;
	struct epic_rx_buffer *buf;
	struct epic_rx_desc *desc;
	struct mbuf *m;

	while( !(sc->rx_desc[sc->cur_rx].status & 0x8000) ) { 
		buf = sc->rx_buffer + sc->cur_rx;
		desc = sc->rx_desc + sc->cur_rx;

		/* Switch to next descriptor */
		sc->cur_rx = (sc->cur_rx+1) & RX_RING_MASK;

		/* Check for errors, this should happend */
		/* only if SAVE_ERRORED_PACKETS is set, */
		/* normaly rx errors generate RXE interrupt */
		if( !(desc->status & 1) ) {
			dprintf((EPIC_FORMAT ": Rx error status: 0x%x\n",EPIC_ARGS(sc),desc->status));
			sc->sc_if.if_ierrors++;
			desc->status = 0x8000;
			continue;
		}

		/* Save packet length and mbuf contained packet */ 
		len = desc->rxlength - ETHER_CRC_LEN;
		m = buf->mbuf;

		/* Try to get mbuf cluster */
		EPIC_MGETCLUSTER( buf->mbuf );
		if( NULL == buf->mbuf ) { 
			printf(EPIC_FORMAT ": cannot allocate mbuf cluster\n",EPIC_ARGS(sc));
			buf->mbuf = m;
			desc->status = 0x8000;
			sc->sc_if.if_ierrors++;
			continue;
		}

		/* Point to new mbuf, and give descriptor to chip */
		desc->bufaddr = vtophys( mtod( buf->mbuf, caddr_t ) );
		desc->status = 0x8000;

		/*
		 * First mbuf in packet holds the ethernet and
		 * packet headers.
		 */
		m->m_pkthdr.rcvif = &(sc->sc_if);
		m->m_pkthdr.len = m->m_len = len;

#if !defined(__FreeBSD__)
#if NBPFILTER > 0
		/* Give mbuf to BPFILTER */
		if( sc->sc_if.if_bpf ) 
			bpf_mtap( EPIC_BPFTAP_ARG(&sc->sc_if), m );
#endif /* NBPFILTER > 0 */
#endif /* !__FreeBSD__ */

		/* Give mbuf to OS */
		ether_input_mbuf(&sc->sc_if, m);

		/* Successfuly received frame */
		sc->sc_if.if_ipackets++;
        }

	return;
}

/*
 * Synopsis: Do last phase of transmission. I.e. if desc is 
 * transmitted, decrease pending_txs counter, free mbuf contained
 * packet, switch to next descriptor and repeat until no packets
 * are pending or descriptor is not transmitted yet.
 */
EPIC_STATIC void
epic_tx_done(sc)
	epic_softc_t *sc;
{
	struct epic_tx_buffer *buf;
	struct epic_tx_desc *desc;
	u_int16_t status;

	while( sc->pending_txs > 0 ){
		buf = sc->tx_buffer + sc->dirty_tx;
		desc = sc->tx_desc + sc->dirty_tx;
		status = desc->status;

		/* If packet is not transmitted, thou followed */
		/* packets are not transmitted too */
		if( status & 0x8000 ) break;

		/* Packet is transmitted. Switch to next and */
		/* free mbuf */
		sc->pending_txs--;
		sc->dirty_tx = (sc->dirty_tx + 1) & TX_RING_MASK;
		m_freem( buf->mbuf );
		buf->mbuf = NULL;

		/* Check for errors and collisions */
		if( status & 0x0001 ) sc->sc_if.if_opackets++;
		else sc->sc_if.if_oerrors++;
		sc->sc_if.if_collisions += (status >> 8) & 0x1F;
#if defined(EPIC_DEBUG)
		if( (status & 0x1001) == 0x1001 ) 
			dprintf((EPIC_FORMAT ": frame not transmitted due collisions\n",EPIC_ARGS(sc)));
#endif
	}

	if( sc->pending_txs < TX_RING_SIZE ) 
		sc->sc_if.if_flags &= ~IFF_OACTIVE;
}

/*
 * Interrupt function
 */
EPIC_STATIC EPIC_INTR_RET_TYPE
epic_intr(arg)
    void *arg;
{
    epic_softc_t * sc = (epic_softc_t *) arg;
    int status,i=4;
#if defined(__OpenBSD__)
    int claimed = 0;
#endif

    while( i-- && ((status = CSR_READ_4(sc, INTSTAT)) & INTSTAT_INT_ACTV) ){
#if defined(__OpenBSD__)
	claimed = 1;
#endif
	CSR_WRITE_4( sc, INTSTAT, status );

	if( status & (INTSTAT_RQE|INTSTAT_RCC|INTSTAT_OVW) ) {
            epic_rx_done( sc );
            if( status & (INTSTAT_RQE|INTSTAT_OVW) ){
#if defined(EPIC_DEBUG)
                if( status & INTSTAT_OVW ) 
                    printf(EPIC_FORMAT ": RX buffer overflow\n",EPIC_ARGS(sc));
                if( status & INTSTAT_RQE ) 
                    printf(EPIC_FORMAT ": RX FIFO overflow\n",EPIC_ARGS(sc));
#endif
                if( !(CSR_READ_4( sc, COMMAND ) & COMMAND_RXQUEUED) )
                    CSR_WRITE_4( sc, COMMAND, COMMAND_RXQUEUED );
                sc->sc_if.if_ierrors++;
            }
        }

        if( status & (INTSTAT_TXC|INTSTAT_TCC|INTSTAT_TQE) ) {
            epic_tx_done( sc );
	    if(!(sc->sc_if.if_flags & IFF_OACTIVE) &&
		!IFQ_IS_EMPTY( &sc->sc_if.if_snd ))
		    epic_ifstart( &sc->sc_if );
	}

	/* Check for errors */
	if( status & (INTSTAT_FATAL|INTSTAT_PMA|INTSTAT_PTA|
		      INTSTAT_APE|INTSTAT_DPE|INTSTAT_TXU|INTSTAT_RXE) ){
    	    if( status & (INTSTAT_FATAL|INTSTAT_PMA|INTSTAT_PTA|
			  INTSTAT_APE|INTSTAT_DPE) ){
		printf(EPIC_FORMAT ": PCI fatal error occurred (%s%s%s%s)\n",
    		    EPIC_ARGS(sc),
		    (status&INTSTAT_PMA)?"PMA":"",
		    (status&INTSTAT_PTA)?" PTA":"",
		    (status&INTSTAT_APE)?" APE":"",
		    (status&INTSTAT_DPE)?" DPE":""
		);

		epic_stop(sc);
		epic_init(sc);
		
	    	break;
	    }

	    if (status & INTSTAT_RXE) {
		dprintf((EPIC_FORMAT ": CRC/Alignment error\n",EPIC_ARGS(sc)));
		sc->sc_if.if_ierrors++;
	    }

	    /* Tx FIFO underflow. Increase tx threshold, */
	    /* if it grown above 2048, disable EARLY_TX */
	    if (status & INTSTAT_TXU) {
		if( sc->tx_threshold > 0x800 ) {
		    sc->txcon &= ~TXCON_EARLY_TRANSMIT_ENABLE;
    		    dprintf((EPIC_FORMAT ": TX underrun error, early tx disabled\n",EPIC_ARGS(sc)));
		} else {
		    sc->tx_threshold += 0x40;
    		    dprintf((EPIC_FORMAT ": TX underrun error, tx threshold increased to %d\n",EPIC_ARGS(sc),sc->tx_threshold));
		}

		CSR_WRITE_4(sc, COMMAND, COMMAND_TXUGO | COMMAND_TXQUEUED);
		epic_stop_activity(sc);
		epic_set_tx_mode(sc);
		epic_start_activity(sc);
		sc->sc_if.if_oerrors++;
	    }
	}
    }

    /* If no packets are pending, thus no timeouts */
    if( sc->pending_txs == 0 ) sc->sc_if.if_timer = 0;

#if defined(__OpenBSD__)
    return claimed;
#endif
}

/*
 * Synopsis: This one is called if packets wasn't transmitted
 * during timeout. Try to deallocate transmitted packets, and 
 * if success continue to work.
 */
EPIC_STATIC void
epic_ifwatchdog(ifp)
	struct ifnet *ifp;
{
	epic_softc_t *sc = ifp->if_softc;
	int x;

	x = splimp();

	printf(EPIC_FORMAT ": device timeout %d packets, ",
	    EPIC_ARGS(sc),sc->pending_txs);

	/* Try to finish queued packets */
	epic_tx_done( sc );

	/* If not successful */
	if( sc->pending_txs > 0 ){

		ifp->if_oerrors+=sc->pending_txs;

		/* Reinitialize board */
		printf("reinitialization\n");
		epic_stop(sc);
		epic_init(sc);

	} else 
		printf("seems we can continue normally\n");

	/* Start output */
	if( !IFQ_IS_EMPTY( &ifp->if_snd ) ) epic_ifstart( ifp );

	splx(x);
}

/*
 * Set media options.
 */
EPIC_STATIC int
epic_ifmedia_upd(ifp)
	struct ifnet *ifp;
{
	epic_softc_t *sc;
	struct mii_data *mii;
	struct ifmedia *ifm;
	struct mii_softc *miisc;
	int cfg, media;

	sc = ifp->if_softc;

	mii = epic_mii_ptr(sc);

	ifm = &mii->mii_media;
	media = ifm->ifm_cur->ifm_media;

	/* Do not do anything if interface is not up */
	if(!(ifp->if_flags & IFF_UP))
		return (0);

	/*
	 * Lookup current selected PHY
	 */
	if (IFM_INST(media) == sc->serinst) {
		sc->phyid = EPIC_SERIAL;
		sc->physc = NULL;
	} else {
		/* If we're not selecting serial interface, select MII mode */
		sc->miicfg &= ~MIICFG_SERIAL_ENABLE;
		CSR_WRITE_4(sc, MIICFG, sc->miicfg);

		dprintf((EPIC_FORMAT ": MII selected\n", EPIC_ARGS(sc)));

		/* Default to unknown PHY */
		sc->phyid = EPIC_UNKN_PHY;

		/* Lookup selected PHY */
		for (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;
		     miisc = LIST_NEXT(miisc, mii_list)) {
			if (IFM_INST(media) == miisc->mii_inst) {
				sc->physc = miisc;
				break;
			}
		}

		/* Identify selected PHY */
		if (sc->physc) {
			int id1, id2, model, oui;

			id1 = PHY_READ(sc->physc, MII_PHYIDR1);
			id2 = PHY_READ(sc->physc, MII_PHYIDR2);

			oui = MII_OUI(id1, id2);
			model = MII_MODEL(id2);
			switch (oui) {
			case MII_OUI_QUALSEMI:
				if (model == MII_MODEL_QUALSEMI_QS6612)
					sc->phyid = EPIC_QS6612_PHY;
				break;
			case MII_OUI_xxALTIMA:
				if (model == MII_MODEL_xxALTIMA_AC101)
					sc->phyid = EPIC_AC101_PHY;
				break;
			case MII_OUI_xxLEVEL1:
				if (model == MII_MODEL_xxLEVEL1_LXT970)
					sc->phyid = EPIC_LXT970_PHY;
				break;
			}
		}
	}

	/*
	 * Do PHY specific card setup
	 */

	/* Call this, to isolate all not selected PHYs and
	 * set up selected
	 */
	mii_mediachg(mii);

	/* Do our own setup */
	switch (sc->phyid) {
	case EPIC_QS6612_PHY:
		break;
	case EPIC_AC101_PHY:
		/* We have to powerup fiber transceivers */
		if (IFM_SUBTYPE(media) == IFM_100_FX)
			sc->miicfg |= MIICFG_694_ENABLE;
		else
			sc->miicfg &= ~MIICFG_694_ENABLE;
		CSR_WRITE_4(sc, MIICFG, sc->miicfg);
	
		break;
	case EPIC_LXT970_PHY:
		/* We have to powerup fiber transceivers */
		cfg = PHY_READ(sc->physc, MII_LXTPHY_CONFIG);
		if (IFM_SUBTYPE(media) == IFM_100_FX)
			cfg |= CONFIG_LEDC1 | CONFIG_LEDC0;
		else
			cfg &= ~(CONFIG_LEDC1 | CONFIG_LEDC0);
		PHY_WRITE(sc->physc, MII_LXTPHY_CONFIG, cfg);

		break;
	case EPIC_SERIAL:
		/* Select serial PHY, (10base2/BNC usually) */
		sc->miicfg |= MIICFG_694_ENABLE | MIICFG_SERIAL_ENABLE;
		CSR_WRITE_4(sc, MIICFG, sc->miicfg);

		/* There is no driver to fill this */
		mii->mii_media_active = media;
		mii->mii_media_status = 0;

		/* We need to call this manualy as i wasn't called
		 * in mii_mediachg()
		 */
		epic_miibus_statchg(&sc->dev);

		dprintf((EPIC_FORMAT ": SERIAL selected\n", EPIC_ARGS(sc)));

		break;
	default:
		printf(EPIC_FORMAT ": ERROR! Unknown PHY selected\n", EPIC_ARGS(sc));
		return (EINVAL);
	}

	return(0);
}

/*
 * Report current media status.
 */
EPIC_STATIC void
epic_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
{
	epic_softc_t *sc;
	struct mii_data *mii;
	struct ifmedia *ifm;

	sc = ifp->if_softc;
	mii = epic_mii_ptr(sc);
	ifm = &mii->mii_media;

	/* Nothing should be selected if interface is down */
	if(!(ifp->if_flags & IFF_UP)) {
		ifmr->ifm_active = IFM_NONE;
		ifmr->ifm_status = 0;

		return;
	}

	/* Call underlying pollstat, if not serial PHY */
	if (sc->phyid != EPIC_SERIAL)
		mii_pollstat(mii);

	/* Simply copy media info */
	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;

	return;
}

/*
 * Callback routine, called on media change.
 */
EPIC_STATIC void
epic_miibus_statchg(dev)
	struct device* dev;
{
	epic_softc_t *sc;
	struct mii_data *mii;
	int media;

	sc = epic_dev_ptr(dev);
	mii = epic_mii_ptr(sc);
	media = mii->mii_media_active;

	sc->txcon &= ~(TXCON_LOOPBACK_MODE | TXCON_FULL_DUPLEX);

	/* If we are in full-duplex mode or loopback operation,
	 * we need to decouple receiver and transmitter.
	 */
	if (IFM_OPTIONS(media) & (IFM_FDX | IFM_LOOP))
 		sc->txcon |= TXCON_FULL_DUPLEX;

	/* On some cards we need manualy set fullduplex led */
	if (sc->cardid == SMC9432FTX ||
	    sc->cardid == SMC9432FTX_SC) {
		if (IFM_OPTIONS(media) & IFM_FDX) 
			sc->miicfg |= MIICFG_694_ENABLE;
		else
			sc->miicfg &= ~MIICFG_694_ENABLE;

		CSR_WRITE_4(sc, MIICFG, sc->miicfg);
	}

	/* Update baudrate */
	if (IFM_SUBTYPE(media) == IFM_100_TX ||
	    IFM_SUBTYPE(media) == IFM_100_FX)
		sc->sc_if.if_baudrate = 100000000;
	else
		sc->sc_if.if_baudrate = 10000000;

	epic_set_tx_mode(sc);

	return;
}

EPIC_STATIC void epic_miibus_mediainit(dev)
	struct device* dev;
{
        epic_softc_t *sc;
        struct mii_data *mii;
	struct ifmedia *ifm;
	int media;

	sc = epic_dev_ptr(dev);
	mii = epic_mii_ptr(sc);
	ifm = &mii->mii_media;

	/* Add Serial Media Interface if present, this applies to
	 * SMC9432BTX serie
	 */
	if(CSR_READ_4(sc, MIICFG) & MIICFG_PHY_PRESENT) {
		/* Store its instance */
		sc->serinst = mii->mii_instance++;

		/* Add as 10base2/BNC media */
		media = IFM_MAKEWORD(IFM_ETHER, IFM_10_2, 0, sc->serinst);
		ifmedia_add(ifm, media, 0, NULL);

		/* Report to user */
		printf(EPIC_FORMAT ": serial PHY detected (10Base2/BNC)\n",EPIC_ARGS(sc));
	}

	return;
}


/*
 * Reset chip, allocate rings, and update media.
 */
EPIC_STATIC int
epic_init(sc)
	epic_softc_t *sc;
{       
	struct ifnet *ifp = &sc->sc_if;
	struct mii_data *mii;
	int s,i;
 
	s = splimp();

	/* If interface is already running, then we need not do anything */ 
	if (ifp->if_flags & IFF_RUNNING) {
		splx(s);
		return 0;
	}

	/* Soft reset the chip (we have to power up card before) */
	CSR_WRITE_4( sc, GENCTL, 0 );
	CSR_WRITE_4( sc, GENCTL, GENCTL_SOFT_RESET );

	/*
	 * Reset takes 15 pci ticks which depends on PCI bus speed.
	 * Assuming it >= 33000000 hz, we have wait at least 495e-6 sec.
	 */
	DELAY(500);

	/* Wake up */
	CSR_WRITE_4( sc, GENCTL, 0 );

	/* Workaround for Application Note 7-15 */
	for (i=0; i<16; i++) CSR_WRITE_4(sc, TEST1, TEST1_CLOCK_TEST);

	/* Initialize rings */
	if( epic_init_rings( sc ) ) {
		printf(EPIC_FORMAT ": failed to init rings\n",EPIC_ARGS(sc));
		splx(s);
		return -1;
	}	

	/* Give rings to EPIC */
	CSR_WRITE_4( sc, PRCDAR, vtophys( sc->rx_desc ) );
	CSR_WRITE_4( sc, PTCDAR, vtophys( sc->tx_desc ) );

	/* Put node address to EPIC */
	CSR_WRITE_4( sc, LAN0, ((u_int16_t *)sc->sc_macaddr)[0] );
        CSR_WRITE_4( sc, LAN1, ((u_int16_t *)sc->sc_macaddr)[1] );
	CSR_WRITE_4( sc, LAN2, ((u_int16_t *)sc->sc_macaddr)[2] );

	/* Set tx mode, includeing transmit threshold */
	epic_set_tx_mode(sc);

	/* Compute and set RXCON. */
	epic_set_rx_mode( sc );

	/* Set multicast table */
	epic_set_mc_table( sc );

	/* Enable interrupts by setting the interrupt mask. */
	CSR_WRITE_4( sc, INTMASK,
		INTSTAT_RCC  | /* INTSTAT_RQE | INTSTAT_OVW | INTSTAT_RXE | */
		/* INTSTAT_TXC | */ INTSTAT_TCC | INTSTAT_TQE | INTSTAT_TXU |
		INTSTAT_FATAL);

	/* Acknowledge all pending interrupts */
	CSR_WRITE_4(sc, INTSTAT, CSR_READ_4(sc, INTSTAT));

	/* Enable interrupts,  set for PCI read multiple and etc */
	CSR_WRITE_4( sc, GENCTL,
		GENCTL_ENABLE_INTERRUPT | GENCTL_MEMORY_READ_MULTIPLE |
		GENCTL_ONECOPY | GENCTL_RECEIVE_FIFO_THRESHOLD64 );

	/* Mark interface running ... */
	if( ifp->if_flags & IFF_UP ) ifp->if_flags |= IFF_RUNNING;
	else ifp->if_flags &= ~IFF_RUNNING;

	/* ... and free */
	ifp->if_flags &= ~IFF_OACTIVE;

	/* Start Rx process */
	epic_start_activity(sc);

	/* Reset all PHYs */
	mii = epic_mii_ptr(sc);
        if (mii->mii_instance) {
		struct mii_softc	*miisc;
		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
			mii_phy_reset(miisc);
	}

	/* Set appropriate media */
	epic_ifmedia_upd(ifp);

	splx(s);

	timeout_add(&sc->sc_tmo, hz);

	return 0;
}

/*
 * Synopsis: calculate and set Rx mode. Chip must be in idle state to
 * access RXCON.
 */
EPIC_STATIC void
epic_set_rx_mode(sc)
	epic_softc_t *sc;
{
	u_int32_t 		flags = sc->sc_if.if_flags;
        u_int32_t 		rxcon = RXCON_DEFAULT;

	rxcon |= (flags & IFF_PROMISC) ? RXCON_PROMISCUOUS_MODE : 0;

	CSR_WRITE_4( sc, RXCON, rxcon );

	return;
}

/*
 * Synopsis: Set transmit control register. Chip must be in idle state to
 * access TXCON.
 */
EPIC_STATIC void
epic_set_tx_mode(sc)
	epic_softc_t *sc;
{
	if (sc->txcon & TXCON_EARLY_TRANSMIT_ENABLE)
		CSR_WRITE_4 (sc, ETXTHR, sc->tx_threshold);

	CSR_WRITE_4 (sc, TXCON, sc->txcon);
}

/*
 * Synopsis: This function should update multicast hash table.
 * I suppose there is a bug in chips MC filter so this function
 * only set it to receive all MC packets. The second problem is
 * that we should wait for TX and RX processes to stop before
 * reprogramming MC filter. The epic_stop_activity() and 
 * epic_start_activity() should help to do this.
 */
EPIC_STATIC void
epic_set_mc_table(sc)
	epic_softc_t *sc;
{
	struct ifnet *ifp = &sc->sc_if;

	if( ifp->if_flags & IFF_MULTICAST ){
		CSR_WRITE_4( sc, MC0, 0xFFFF );
		CSR_WRITE_4( sc, MC1, 0xFFFF );
		CSR_WRITE_4( sc, MC2, 0xFFFF );
		CSR_WRITE_4( sc, MC3, 0xFFFF );
	}

	return;
}


/* 
 * Synopsis: Start receive process and transmit one, if they need.
 */
EPIC_STATIC void
epic_start_activity(sc)
	epic_softc_t *sc;
{
	/* Start rx process */
	CSR_WRITE_4(sc, COMMAND,
		COMMAND_RXQUEUED | COMMAND_START_RX |
		(sc->pending_txs?COMMAND_TXQUEUED:0));
	dprintf((EPIC_FORMAT ": activity started\n",EPIC_ARGS(sc)));
}

/*
 * Synopsis: Completely stop Rx and Tx processes. If TQE is set additional
 * packet needs to be queued to stop Tx DMA.
 */
EPIC_STATIC void
epic_stop_activity(sc)
    epic_softc_t *sc;
{
    int i;

    /* Stop Tx and Rx DMA */
    CSR_WRITE_4(sc,COMMAND,COMMAND_STOP_RX|COMMAND_STOP_RDMA|COMMAND_STOP_TDMA);

    /* Wait Rx and Tx DMA to stop (why 1 ms ??? XXX) */
    dprintf((EPIC_FORMAT ": waiting Rx and Tx DMA to stop\n",EPIC_ARGS(sc)));
    for(i=0;i<0x1000;i++) {
	if((CSR_READ_4(sc,INTSTAT) & (INTSTAT_TXIDLE | INTSTAT_RXIDLE)) == 
	   (INTSTAT_TXIDLE | INTSTAT_RXIDLE) )
	    break;
	DELAY(1);
    }

    if( !(CSR_READ_4(sc,INTSTAT)&INTSTAT_RXIDLE) ) 
	printf(EPIC_FORMAT ": can't stop Rx DMA\n",EPIC_ARGS(sc));

    if( !(CSR_READ_4(sc,INTSTAT)&INTSTAT_TXIDLE) ) 
	printf(EPIC_FORMAT ": can't stop Tx DMA\n",EPIC_ARGS(sc));

    /* Catch all finished packets */
    epic_rx_done(sc);
    epic_tx_done(sc);

    /*
     * May need to queue one more packet if TQE, this is rare but existing
     * case.
     */
    if( (CSR_READ_4( sc, INTSTAT ) & INTSTAT_TQE) &&
       !(CSR_READ_4( sc, INTSTAT ) & INTSTAT_TXIDLE) ) {
	struct epic_tx_desc *desc;
	struct epic_frag_list *flist;
	struct epic_tx_buffer *buf;
	struct mbuf *m0;

	dprintf((EPIC_FORMAT ": queue last packet\n",EPIC_ARGS(sc)));

	desc = sc->tx_desc + sc->cur_tx;
	flist = sc->tx_flist + sc->cur_tx;
	buf = sc->tx_buffer + sc->cur_tx;

	if ((desc->status & 0x8000) || (buf->mbuf != NULL))
	    return;

	MGETHDR(m0,M_DONTWAIT,MT_DATA);
	if (NULL == m0)
	    return;

	/* Prepare mbuf */
	m0->m_len = min(MHLEN,ETHER_MIN_LEN-ETHER_CRC_LEN);
	flist->frag[0].fraglen = m0->m_len;
	m0->m_pkthdr.len = m0->m_len;
	m0->m_pkthdr.rcvif = &sc->sc_if;
	bzero(mtod(m0,caddr_t),m0->m_len);

	/* Fill fragments list */
	flist->frag[0].fraglen = m0->m_len; 
	flist->frag[0].fragaddr = vtophys( mtod(m0, caddr_t) );
	flist->numfrags = 1;

	/* Fill in descriptor */
	buf->mbuf = m0;
	sc->pending_txs++;
	sc->cur_tx = (sc->cur_tx + 1) & TX_RING_MASK;
	desc->control = 0x01;
	desc->txlength = max(m0->m_pkthdr.len,ETHER_MIN_LEN-ETHER_CRC_LEN);
	desc->status = 0x8000;

	/* Launch transmition */
	CSR_WRITE_4(sc, COMMAND, COMMAND_STOP_TDMA | COMMAND_TXQUEUED);

	/* Wait Tx DMA to stop (for how long??? XXX) */
	dprintf((EPIC_FORMAT ": waiting Tx DMA to stop\n",EPIC_ARGS(sc)));
	for(i=0;i<1000;i++) {
	    if( (CSR_READ_4(sc,INTSTAT)&INTSTAT_TXIDLE) == INTSTAT_TXIDLE )
		break;
	    DELAY(1);
	}

	if( !(CSR_READ_4(sc,INTSTAT)&INTSTAT_TXIDLE) )
	    printf(EPIC_FORMAT ": can't stop TX DMA\n",EPIC_ARGS(sc));
	else
	    epic_tx_done(sc);
    }

    dprintf((EPIC_FORMAT ": activity stoped\n",EPIC_ARGS(sc)));
}

/*
 *  Synopsis: Shut down board and deallocates rings.
 */
EPIC_STATIC void
epic_stop(sc)
	epic_softc_t *sc;
{
	int s;

	timeout_del(&sc->sc_tmo);

	s = splimp();

	sc->sc_if.if_timer = 0;

	/* Disable interrupts */
	CSR_WRITE_4( sc, INTMASK, 0 );
	CSR_WRITE_4( sc, GENCTL, 0 );

	/* Try to stop Rx and TX processes */
	epic_stop_activity(sc);

	/* Reset chip */
	CSR_WRITE_4( sc, GENCTL, GENCTL_SOFT_RESET );
	DELAY(1000);

	/* Make chip go to bed */
	CSR_WRITE_4(sc, GENCTL, GENCTL_POWER_DOWN);

	/* Free memory allocated for rings */
	epic_free_rings(sc);

	/* Mark as stoped */
	sc->sc_if.if_flags &= ~IFF_RUNNING;

	splx(s);
	return;
}

/*
 * Synopsis: This function should free all memory allocated for rings.
 */ 
EPIC_STATIC void
epic_free_rings(sc)
	epic_softc_t *sc;
{
	int i;

	for(i=0;i<RX_RING_SIZE;i++){
		struct epic_rx_buffer *buf = sc->rx_buffer + i;
		struct epic_rx_desc *desc = sc->rx_desc + i;
		
		desc->status = 0;
		desc->buflength = 0;
		desc->bufaddr = 0;

		if( buf->mbuf ) m_freem( buf->mbuf );
		buf->mbuf = NULL;
	}

	for(i=0;i<TX_RING_SIZE;i++){
		struct epic_tx_buffer *buf = sc->tx_buffer + i;
		struct epic_tx_desc *desc = sc->tx_desc + i;

		desc->status = 0;
		desc->buflength = 0;
		desc->bufaddr = 0;

		if( buf->mbuf ) m_freem( buf->mbuf );
		buf->mbuf = NULL;
	}
}

/*
 * Synopsis:  Allocates mbufs for Rx ring and point Rx descs to them.
 * Point Tx descs to fragment lists. Check that all descs and fraglists
 * are bounded and aligned properly.
 */
EPIC_STATIC int
epic_init_rings(sc)
	epic_softc_t *sc;
{
	int i;

	sc->cur_rx = sc->cur_tx = sc->dirty_tx = sc->pending_txs = 0;

	for (i = 0; i < RX_RING_SIZE; i++) {
		struct epic_rx_buffer *buf = sc->rx_buffer + i;
		struct epic_rx_desc *desc = sc->rx_desc + i;

		desc->status = 0;		/* Owned by driver */
		desc->next = vtophys( sc->rx_desc + ((i+1) & RX_RING_MASK) );

		if( (desc->next & 3) || ((desc->next & 0xFFF) + sizeof(struct epic_rx_desc) > 0x1000 ) )
			printf(EPIC_FORMAT ": WARNING! rx_desc is misbound or misaligned\n",EPIC_ARGS(sc));

		EPIC_MGETCLUSTER( buf->mbuf );
		if( NULL == buf->mbuf ) {
			epic_free_rings(sc);
			return -1;
		}
		desc->bufaddr = vtophys( mtod(buf->mbuf,caddr_t) );

		desc->buflength = ETHER_MAX_FRAME_LEN;
		desc->status = 0x8000;			/* Give to EPIC */

	}

	for (i = 0; i < TX_RING_SIZE; i++) {
		struct epic_tx_buffer *buf = sc->tx_buffer + i;
		struct epic_tx_desc *desc = sc->tx_desc + i;

		desc->status = 0;
		desc->next = vtophys( sc->tx_desc + ( (i+1) & TX_RING_MASK ) );

		if( (desc->next & 3) || ((desc->next & 0xFFF) + sizeof(struct epic_tx_desc) > 0x1000 ) )
			printf(EPIC_FORMAT ": WARNING! tx_desc is misbound or misaligned\n",EPIC_ARGS(sc));

		buf->mbuf = NULL;
		desc->bufaddr = vtophys( sc->tx_flist + i );
		if( (desc->bufaddr & 3) || ((desc->bufaddr & 0xFFF) + sizeof(struct epic_frag_list) > 0x1000 ) )
			printf(EPIC_FORMAT ": WARNING! frag_list is misbound or misaligned\n",EPIC_ARGS(sc));
	}

	return 0;
}

/*
 * EEPROM operation functions
 */
EPIC_STATIC void
epic_write_eepromreg(sc, val)
	epic_softc_t *sc;
	u_int8_t val;
{
	u_int16_t i;

	CSR_WRITE_1( sc, EECTL, val );

	for (i=0; i<0xFF; i++)
		if( !(CSR_READ_1( sc, EECTL ) & 0x20) ) break;

	return;
}

EPIC_STATIC u_int8_t
epic_read_eepromreg(sc)
	epic_softc_t *sc;
{
	return CSR_READ_1(sc, EECTL);
}  

EPIC_STATIC u_int8_t
epic_eeprom_clock(sc, val)
	epic_softc_t *sc;
	u_int8_t val;
{
	epic_write_eepromreg( sc, val );
	epic_write_eepromreg( sc, (val | 0x4) );
	epic_write_eepromreg( sc, val );
	
	return epic_read_eepromreg( sc );
}

EPIC_STATIC void
epic_output_eepromw(sc, val)
	epic_softc_t *sc;
	u_int16_t val;
{
	int i;          
	for( i = 0xF; i >= 0; i--){
		if( (val & (1 << i)) ) epic_eeprom_clock( sc, 0x0B );
		else epic_eeprom_clock( sc, 3);
	}
}

EPIC_STATIC u_int16_t
epic_input_eepromw(sc)
	epic_softc_t *sc;
{
	int i;
	int tmp;
	u_int16_t retval = 0;

	for( i = 0xF; i >= 0; i--) {	
		tmp = epic_eeprom_clock( sc, 0x3 );
		if( tmp & 0x10 ){
			retval |= (1 << i);
		}
	}
	return retval;
}

EPIC_STATIC int
epic_read_eeprom(sc, loc)
	epic_softc_t *sc;
	u_int16_t loc;
{
	u_int16_t dataval;
	u_int16_t read_cmd;

	epic_write_eepromreg( sc , 3);

	if( epic_read_eepromreg( sc ) & 0x40 )
		read_cmd = ( loc & 0x3F ) | 0x180;
	else
		read_cmd = ( loc & 0xFF ) | 0x600;

	epic_output_eepromw( sc, read_cmd );

        dataval = epic_input_eepromw( sc );

	epic_write_eepromreg( sc, 1 );
	
	return dataval;
}

/*
 * Here goes MII read/write routines
 */
EPIC_STATIC int
epic_read_phy_reg(sc, phy, reg)
	epic_softc_t *sc;
	int phy, reg;
{
	int i;

	CSR_WRITE_4 (sc, MIICTL, ((reg << 4) | (phy << 9) | 0x01));

	for (i=0;i<0x100;i++) {
		if( !(CSR_READ_4(sc, MIICTL) & 0x01) ) break;
		DELAY(1);
	}

	return (CSR_READ_4 (sc, MIIDATA));
}

EPIC_STATIC void
epic_write_phy_reg(sc, phy, reg, val)
	epic_softc_t *sc;
	int phy, reg, val;
{
	int i;

	CSR_WRITE_4 (sc, MIIDATA, val);
	CSR_WRITE_4 (sc, MIICTL, ((reg << 4) | (phy << 9) | 0x02));

	for(i=0;i<0x100;i++) {
		if( !(CSR_READ_4(sc, MIICTL) & 0x02) ) break;
		DELAY(1);
	}

	return;
}

EPIC_STATIC int
epic_miibus_readreg(dev, phy, reg)
	struct device* dev;
	int phy, reg;
{
	epic_softc_t *sc;

	sc = epic_dev_ptr(dev);

	return (PHY_READ_2(sc, phy, reg));
}

EPIC_STATIC EPIC_MIIBUS_WRITEREG_RET_TYPE
epic_miibus_writereg(dev, phy, reg, data)
	struct device* dev;
	int phy, reg, data;
{
	epic_softc_t *sc;

	sc = epic_dev_ptr(dev);

	PHY_WRITE_2(sc, phy, reg, data);

#if !defined(__OpenBSD__)
	return (0);
#endif
}

EPIC_STATIC void
epic_tick(vsc)
	void *vsc;
{
	epic_softc_t *sc = vsc;
	struct mii_data *mii;

	mii = epic_mii_ptr(sc);
	if (sc->phyid != EPIC_SERIAL)
		mii_tick(mii);
}
@


1.29
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.28 2004/09/23 17:45:16 brad Exp $	*/
@


1.28
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.27 2003/08/19 14:01:35 mpech Exp $	*/
d719 2
a720 1
			epic_set_mc_table(sc);
@


1.27
log
@missing break.

jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.26 2002/12/15 13:18:50 henning Exp $	*/
a440 1
	ifp->if_output = ether_output;
@


1.26
log
@and one more typo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.25 2002/11/19 18:40:17 jason Exp $	*/
d681 1
@


1.25
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.24 2002/11/14 07:35:18 kjc Exp $	*/
d1120 1
a1120 1
		printf("seems we can continue normaly\n");
@


1.24
log
@mark tx as altq-ready.
this line was in epic_freebsd_attach() but not in epic_openbsd_attach().

PR 2955
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.23 2002/06/03 20:01:36 deraadt Exp $	*/
a207 2
	if( PCI_VENDOR(pa->pa_id) != SMC_VENDORID )
		return 0;
d209 4
a212 4
	if( PCI_PRODUCT(pa->pa_id) == SMC_DEVICEID_83C170 )
		return 1;

	return 0;
@


1.23
log
@spell transceiver correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.22 2002/03/14 01:26:59 millert Exp $	*/
d264 1
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.21 2001/11/06 19:53:19 miod Exp $	*/
d1218 1
a1218 1
		/* We have to powerup fiber tranceivers */
d1227 1
a1227 1
		/* We have to powerup fiber tranceivers */
@


1.21
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.20 2001/09/20 17:02:31 mpech Exp $	*/
d146 35
a180 35
EPIC_STATIC int epic_ifioctl __P((register struct ifnet *, u_long, caddr_t));
EPIC_STATIC EPIC_INTR_RET_TYPE epic_intr __P((void *));
EPIC_STATIC int epic_common_attach __P((epic_softc_t *));
EPIC_STATIC void epic_ifstart __P((struct ifnet *));
EPIC_STATIC void epic_ifwatchdog __P((struct ifnet *));
EPIC_STATIC int epic_init __P((epic_softc_t *));
EPIC_STATIC void epic_stop __P((epic_softc_t *));
EPIC_STATIC void epic_rx_done __P((epic_softc_t *));
EPIC_STATIC void epic_tx_done __P((epic_softc_t *));
EPIC_STATIC int epic_init_rings __P((epic_softc_t *));
EPIC_STATIC void epic_free_rings __P((epic_softc_t *));
EPIC_STATIC void epic_stop_activity __P((epic_softc_t *));
EPIC_STATIC void epic_start_activity __P((epic_softc_t *));
EPIC_STATIC void epic_set_rx_mode __P((epic_softc_t *));
EPIC_STATIC void epic_set_tx_mode __P((epic_softc_t *));
EPIC_STATIC void epic_set_mc_table __P((epic_softc_t *));
EPIC_STATIC int epic_read_eeprom __P((epic_softc_t *,u_int16_t));
EPIC_STATIC void epic_output_eepromw __P((epic_softc_t *, u_int16_t));
EPIC_STATIC u_int16_t epic_input_eepromw __P((epic_softc_t *));
EPIC_STATIC u_int8_t epic_eeprom_clock __P((epic_softc_t *,u_int8_t));
EPIC_STATIC void epic_write_eepromreg __P((epic_softc_t *,u_int8_t));
EPIC_STATIC u_int8_t epic_read_eepromreg __P((epic_softc_t *));

EPIC_STATIC int epic_read_phy_reg __P((epic_softc_t *, int, int));
EPIC_STATIC void epic_write_phy_reg __P((epic_softc_t *, int, int, int));

EPIC_STATIC int epic_miibus_readreg __P((struct device*, int, int));
EPIC_STATIC EPIC_MIIBUS_WRITEREG_RET_TYPE epic_miibus_writereg __P((struct device*, int, int, int));
EPIC_STATIC void epic_miibus_statchg __P((struct device *));
EPIC_STATIC void epic_miibus_mediainit __P((struct device *));


EPIC_STATIC int epic_ifmedia_upd __P((struct ifnet *));
EPIC_STATIC void epic_ifmedia_sts __P((struct ifnet *, struct ifmediareq *));
EPIC_STATIC void epic_tick __P((void *));
d189 3
a191 3
int epic_openbsd_probe __P((struct device *,void *,void *));
void epic_openbsd_attach __P((struct device *, struct device *, void *));
void epic_openbsd_shutdown __P((void *));
d326 5
a330 5
static int epic_freebsd_probe __P((device_t));
static int epic_freebsd_attach __P((device_t));
static void epic_freebsd_shutdown __P((device_t));
static int epic_freebsd_detach __P((device_t));
static struct epic_type *epic_devtype __P((device_t));
@


1.21.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.21 2001/11/06 19:53:19 miod Exp $	*/
d146 35
a180 35
EPIC_STATIC int epic_ifioctl(register struct ifnet *, u_long, caddr_t);
EPIC_STATIC EPIC_INTR_RET_TYPE epic_intr(void *);
EPIC_STATIC int epic_common_attach(epic_softc_t *);
EPIC_STATIC void epic_ifstart(struct ifnet *);
EPIC_STATIC void epic_ifwatchdog(struct ifnet *);
EPIC_STATIC int epic_init(epic_softc_t *);
EPIC_STATIC void epic_stop(epic_softc_t *);
EPIC_STATIC void epic_rx_done(epic_softc_t *);
EPIC_STATIC void epic_tx_done(epic_softc_t *);
EPIC_STATIC int epic_init_rings(epic_softc_t *);
EPIC_STATIC void epic_free_rings(epic_softc_t *);
EPIC_STATIC void epic_stop_activity(epic_softc_t *);
EPIC_STATIC void epic_start_activity(epic_softc_t *);
EPIC_STATIC void epic_set_rx_mode(epic_softc_t *);
EPIC_STATIC void epic_set_tx_mode(epic_softc_t *);
EPIC_STATIC void epic_set_mc_table(epic_softc_t *);
EPIC_STATIC int epic_read_eeprom(epic_softc_t *,u_int16_t);
EPIC_STATIC void epic_output_eepromw(epic_softc_t *, u_int16_t);
EPIC_STATIC u_int16_t epic_input_eepromw(epic_softc_t *);
EPIC_STATIC u_int8_t epic_eeprom_clock(epic_softc_t *,u_int8_t);
EPIC_STATIC void epic_write_eepromreg(epic_softc_t *,u_int8_t);
EPIC_STATIC u_int8_t epic_read_eepromreg(epic_softc_t *);

EPIC_STATIC int epic_read_phy_reg(epic_softc_t *, int, int);
EPIC_STATIC void epic_write_phy_reg(epic_softc_t *, int, int, int);

EPIC_STATIC int epic_miibus_readreg(struct device*, int, int);
EPIC_STATIC EPIC_MIIBUS_WRITEREG_RET_TYPE epic_miibus_writereg(struct device*, int, int, int);
EPIC_STATIC void epic_miibus_statchg(struct device *);
EPIC_STATIC void epic_miibus_mediainit(struct device *);


EPIC_STATIC int epic_ifmedia_upd(struct ifnet *);
EPIC_STATIC void epic_ifmedia_sts(struct ifnet *, struct ifmediareq *);
EPIC_STATIC void epic_tick(void *);
d189 3
a191 3
int epic_openbsd_probe(struct device *,void *,void *);
void epic_openbsd_attach(struct device *, struct device *, void *);
void epic_openbsd_shutdown(void *);
d326 5
a330 5
static int epic_freebsd_probe(device_t);
static int epic_freebsd_attach(device_t);
static void epic_freebsd_shutdown(device_t);
static int epic_freebsd_detach(device_t);
static struct epic_type *epic_devtype(device_t);
d1218 1
a1218 1
		/* We have to powerup fiber transceivers */
d1227 1
a1227 1
		/* We have to powerup fiber transceivers */
@


1.21.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d208 2
d211 4
a214 4
	if (PCI_VENDOR(pa->pa_id) == SMC_VENDORID &&
	    PCI_PRODUCT(pa->pa_id) == SMC_DEVICEID_83C170)
		return (1);
	return (0);
a263 1
	IFQ_SET_READY(&ifp->if_snd);
d1121 1
a1121 1
		printf("seems we can continue normally\n");
@


1.20
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.19 2001/08/25 10:13:29 art Exp $	*/
d118 1
a118 1
#include <vm/vm.h>
@


1.19
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.18 2001/08/12 20:03:49 mickey Exp $	*/
d1043 1
a1043 1
		printf(EPIC_FORMAT ": PCI fatal error occured (%s%s%s%s)\n",
@


1.18
log
@remove redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.17 2001/06/27 06:34:50 kjc Exp $	*/
d273 1
a273 2
	if( pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.17
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.16 2001/06/25 02:18:48 fgsch Exp $	*/
a118 1
#include <vm/pmap.h>
@


1.16
log
@trivial ether_input_mbuf() conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.15 2001/06/12 15:40:31 niklas Exp $	*/
d450 2
a451 1
	ifp->if_snd.ifq_maxlen = TX_RING_SIZE - 1;
d823 1
a823 1
		IF_DEQUEUE( &ifp->if_snd, m0 );
d1036 1
a1036 1
		sc->sc_if.if_snd.ifq_head )
d1126 1
a1126 1
	if( ifp->if_snd.ifq_head ) epic_ifstart( ifp );
@


1.15
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.14 2001/03/22 01:38:54 angelos Exp $	*/
a892 1
	struct ether_header *eh;
a932 1
		eh = mtod( m, struct ether_header * );
a943 4
		/* Second mbuf holds packet ifself */
		m->m_pkthdr.len = m->m_len = len - sizeof(struct ether_header);
		m->m_data += sizeof( struct ether_header );

d945 1
a945 1
		ether_input(&sc->sc_if, eh, m);
@


1.14
log
@Reformat comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.13 2001/02/23 22:59:09 jason Exp $	*/
d246 1
a246 1
		    &sc->sc_st, &sc->sc_sh, NULL, &iosize)) {
d252 1
a252 1
		    &sc->sc_st, &sc->sc_sh, NULL, &iosize)) {
@


1.13
log
@Merge with FreeBSD:
more portable between fbsd and obsd
real mii support
prefer memory mapped registers (if configuration supports it)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.12 2001/02/20 19:39:43 mickey Exp $	*/
d929 5
a933 2
		
		/* First mbuf in packet holds the ethernet and packet headers */
@


1.12
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: if_tx.c,v 1.11 2000/10/17 15:47:12 jason Exp $	*/
/* $FreeBSD: src/sys/pci/if_tx.c,v 1.40 2000/07/13 22:54:34 archie Exp $ */
a37 2
 *	Refactor out Free/Open compat cruft
 *	Modularize, Modularize, and Modularize some more
d79 3
d123 2
d139 2
a142 5
#endif

#if defined(__FreeBSD__)
#define EPIC_MIIBUS_WRITEREG_RET_TYPE int
#else /* __OpenBSD__ */
a143 5
#endif

#if defined(__FreeBSD__)
#define EPIC_STATIC static
#else /* __OpenBSD__ */
a152 1
EPIC_STATIC void epic_reset __P((epic_softc_t *));
d174 1
d176 1
a177 1
EPIC_STATIC EPIC_MIIBUS_WRITEREG_RET_TYPE epic_miibus_writereg __P((struct device*, int, int, int));
d181 1
d190 3
a192 3
EPIC_STATIC int epic_openbsd_probe __P((struct device *,void *,void *));
EPIC_STATIC void epic_openbsd_attach __P((struct device *, struct device *, void *));
EPIC_STATIC void epic_openbsd_shutdown __P((void *));
d202 1
a202 1
EPIC_STATIC int 
d218 1
a218 1
EPIC_STATIC void
a229 1
	bus_addr_t iobase;
a235 1

d239 2
a240 3
#ifdef EPIC_USEIOSPACE
	if (!(command & PCI_COMMAND_IO_ENABLE)) {
		printf(": failed to enable I/O ports\n");
d243 13
a255 3
	if( pci_io_find(pc, pa->pa_tag, PCI_BASEIO, &iobase, &iosize)) {
		printf(": can't find i/o space\n");
		return;
a256 20
	if( bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->sc_sh)) {
		printf(": can't map i/o space\n");
		return;
	}
	sc->sc_st = pa->pa_iot;
#else
	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf(": failed to enable memory mapping\n");
		return;
	}
	if( pci_mem_find(pc, pa->pa_tag, PCI_BASEMEM, &iobase, &iosize, NULL)) {
		printf(": can't find mem space\n");
		return;
	}
	if( bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->sc_sh)) {
		printf(": can't map i/o space\n");
		return;
	}
	sc->sc_st = pa->pa_memt;
#endif
a257 3
	/*
	 * Set up if
	 */
d259 1
a259 1
	bcopy(sc->dev.dv_xname, ifp->if_xname, IFNAMSIZ);
d266 5
a270 3
	/*
	 * Do common attach procedure
	 */
d273 1
a273 3
	/*
	 * Map interrupt 
	 */
a288 1
	printf(": %s",intrstr);
d291 1
a291 6
	printf(" address %s\n",ether_sprintf(sc->sc_macaddr));

	/*
	 * ifmedia setup
	 */
	ifmedia_init(&sc->miibus.mii_media, 0, epic_ifmedia_upd, epic_ifmedia_sts);
d293 3
a295 3
	/*
	 * mii setup
	 */
d300 1
a300 4

	mii_attach(self, &sc->miibus, 0xffffffff, MII_PHY_ANY,
	    MII_OFFSET_ANY, 0);

d304 1
a304 1
        } else {
a305 1
	}
d307 1
d317 2
a318 4
/*
 * Simply call epic_stop()
 */
EPIC_STATIC void
d328 5
a332 6
EPIC_STATIC int epic_freebsd_probe __P((struct device*));
EPIC_STATIC int epic_freebsd_attach __P((struct device*));
EPIC_STATIC void epic_freebsd_shutdown __P((struct device*));
EPIC_STATIC int epic_freebsd_detach __P((struct device*));
EPIC_STATIC struct epic_type *epic_devtype __P((struct device*));
EPIC_STATIC void epic_miibus_mediainit __P((struct device*));
d334 1
a334 1
EPIC_STATIC device_method_t epic_methods[] = {
d354 1
a354 1
EPIC_STATIC driver_t epic_driver = {
d360 1
a360 1
EPIC_STATIC devclass_t epic_devclass;
d365 1
a365 1
EPIC_STATIC struct epic_type epic_devs[] = {
d371 1
a371 1
EPIC_STATIC int
d373 1
a373 1
	struct device* dev;
d387 1
a387 1
EPIC_STATIC struct epic_type *
d389 1
a389 1
	struct device* dev;
d417 1
a417 1
EPIC_STATIC int
d419 1
a419 1
	struct device* dev;
d507 7
d537 5
d555 1
a555 1
	printf ("\n");
d570 1
a570 1
EPIC_STATIC int
d572 1
a572 1
	struct device* dev;
a604 23
 *
 */
EPIC_STATIC void epic_miibus_mediainit(dev)
	struct device* dev;
{
        epic_softc_t *sc;
        struct mii_data *mii;
	struct ifmedia *ifm;
	int media;
	
	sc = epic_dev_ptr(dev);
	mii = epic_mii_ptr(sc);
	ifm = &mii->mii_media;

	if(CSR_READ_4(sc, MIICFG) & MIICFG_PHY_PRESENT) {
		media = IFM_MAKEWORD(IFM_ETHER, IFM_10_2, 0, mii->mii_instance);
		printf(EPIC_FORMAT ": serial PHY detected (10Base2/BNC)\n",EPIC_ARGS(sc));
		ifmedia_add(ifm, media, 0, NULL);
	}

	return;
}
/*
d610 1
a610 1
	struct device* dev;
d623 1
a623 1
   OS-independent part
a627 1
 * This is a mess
a635 1
	int x, error = 0;
d638 1
d743 1
a743 1
 * and frag lists, wake up chip, and read MAC address.
a752 3
	/*
	 * Allocate memory for io buffers
	 */
d764 1
a764 3
	/*
	 * Align pool on PAGE_SIZE
	 */
d768 1
a768 3
	/*
	 * Distribute memory 
	 */
d775 6
a780 4
	/*
	 * reset the chip
	 */
	epic_reset( sc );
d782 1
a782 3
	/*
	 * Read mac address from EEPROM
	 */
d786 1
a786 3
	/*
	 * Set defaults
	 */
d789 6
d801 2
a802 2
 * and quque them for transmit, one by one, until TX ring become full
 * or quque become empty.
a1002 1
 * This is a mess
d1143 2
d1151 1
d1157 50
a1206 8
	if((IFM_INST(ifm->ifm_cur->ifm_media) == mii->mii_instance) &&
	   (IFM_SUBTYPE(ifm->ifm_cur->ifm_media) == IFM_10_2)) {
		/* Call this, to isolate (and powerdown ?) all PHYs */
		mii_mediachg(mii);

		/* Select BNC */
		CSR_WRITE_4(sc, MIICFG, MIICFG_SERIAL_ENABLE |
					MIICFG_694_ENABLE | MIICFG_SMI_ENABLE);
d1208 44
a1251 1
		/* Update txcon register */
d1254 1
a1254 4
		return (0);
	} else if(IFM_INST(ifm->ifm_cur->ifm_media) < mii->mii_instance) {
		/* Select MII */
		CSR_WRITE_4(sc, MIICFG, MIICFG_SMI_ENABLE);
d1256 4
a1259 4
		/* Give it to miibus... */
		mii_mediachg(mii);

		return (0);
d1262 1
a1262 1
	return(EINVAL);
d1281 1
d1289 2
a1290 5
	if((IFM_INST(ifm->ifm_cur->ifm_media) == mii->mii_instance) &&
	   (IFM_SUBTYPE(ifm->ifm_cur->ifm_media) == IFM_10_2)) {
		ifmr->ifm_active = ifm->ifm_cur->ifm_media;
		ifmr->ifm_status = 0;
	} else if(IFM_INST(ifm->ifm_cur->ifm_media) < mii->mii_instance) {
d1292 4
a1295 6
		ifmr->ifm_active = mii->mii_media_active;
		ifmr->ifm_status = mii->mii_media_status;
	} else {
		ifmr->ifm_active = IFM_NONE;
		ifmr->ifm_status = 0;
	}
d1309 1
d1313 1
d1317 1
a1317 2
	/*
	 * If we are in full-duplex mode or loopback operation,
d1320 1
a1320 1
	if (mii->mii_media_active & (IFM_FDX | IFM_LOOP))
d1323 14
a1336 1
	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_100_TX)
a1345 1
#if defined(__FreeBSD__)
d1353 1
a1353 1
	
d1358 3
d1362 8
a1369 1
		media = IFM_MAKEWORD(IFM_ETHER, IFM_10_2, 0, mii->mii_instance);
a1370 1
		ifmedia_add(ifm, media, 0, NULL);
d1375 1
a1375 1
#endif
d1386 1
a1386 1
	int s;
d1395 1
a1395 1
#ifdef __reset
a1410 2
#endif
	epic_reset( sc );
d1439 2
a1440 2
		INTSTAT_RCC | INTSTAT_RQE | INTSTAT_OVW | INTSTAT_RXE |
		INTSTAT_TXC | INTSTAT_TCC | INTSTAT_TQE | INTSTAT_TXU |
d1443 3
d1465 1
a1465 2
		for (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;
		     miisc = LIST_NEXT(miisc, mii_list))
d1474 2
a1479 24
 * Reset the epic chip
 */
EPIC_STATIC void epic_reset(sc)
	epic_softc_t *sc;
{
	int	i;

	/* Soft reset the chip (we have to power up card before) */
	CSR_WRITE_4( sc, GENCTL, 0 );
	CSR_WRITE_4( sc, GENCTL, GENCTL_SOFT_RESET );

	/*
	 * Reset takes 15 pci ticks which depends on PCI bus speed.
	 * Assuming it >= 33000000 hz, we have wait at least 495e-6 sec.
	 */
	DELAY(500);

	/* Wake up */
	CSR_WRITE_4( sc, GENCTL, 0 );

	/* Workaround for Application Note 7-15 */
	for (i=0; i<16; i++) CSR_WRITE_4(sc, TEST1, TEST1_CLOCK_TEST);
}
/*
d1655 2
d1927 12
@


1.11
log
@update tx from freebsd sources based on patch from pr#1405
(dadams@@sleethal.com), but local changes preserved and ifmedia ioctls
fixed; deraadt/aaron ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.10 2000/02/21 20:54:04 jason Exp $	*/
a340 4
#if NBPFILTER > 0
	bpfattach(&sc->sc_if.if_bpf, ifp, DLT_EN10MB,
	    sizeof(struct ether_header));
#endif
@


1.10
log
@From FreeBSD: Correct use of NULL/0
@
text
@d1 2
a2 2
/*	$OpenBSD: if_tx.c,v 1.9 1999/11/17 05:21:18 jason Exp $	*/
/* $FreeBSD: src/sys/pci/if_tx.c,v 1.34 1999/12/21 11:14:10 eivind Exp $ */
d38 2
a39 1
 *	Test, test and test again:-(
a43 2
/*#define	EPIC_NOIFMEDIA	1*/
/*#define	EPIC_USEIOSPACE	1*/
a46 22
#if defined(EPIC_DEBUG)
#define dprintf(a) printf a
#else
#define dprintf(a)
#endif

/* Macro to get either mbuf cluster or nothing */
#define EPIC_MGETCLUSTER(m) \
	{ MGETHDR((m),M_DONTWAIT,MT_DATA); \
	  if (m) { \
	    MCLGET((m),M_DONTWAIT); \
	    if( 0 == ((m)->m_flags & M_EXT) ){ \
	      m_freem(m); \
	      (m) = NULL; \
	    } \
	  } \
	}

#include "bpfilter.h"
#include "pci.h"

#if NPCI > 0
d49 1
d54 35
a88 1
#include <sys/sockio.h>
a92 4

#if !defined(SIOCSIFMEDIA) || defined(EPIC_NOIFMEDIA)
#define EPIC_NOIFMEDIA	1
#else
a93 1
#endif
d100 1
a114 1
#include <net/bpfdesc.h>
d117 2
a118 6
#if defined(__OpenBSD__)
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/device.h>

#include <netinet/if_ether.h>
d120 2
a121 1
#include <vm/vm.h>
d128 1
a128 7
#else /* __FreeBSD__ */
#include <net/if_mib.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <vm/vm.h>
#include <vm/pmap.h>
#include <machine/clock.h>
d130 2
a131 2
#include <pci/pcivar.h>
#include <pci/if_txvar.h>
a134 5
#if __FreeBSD_version >= 300000
#define EPIC_IFIOCTL_CMD_TYPE u_long
#else
#define EPIC_IFIOCTL_CMD_TYPE int
#endif
a136 1
#define EPIC_IFIOCTL_CMD_TYPE u_long
d140 43
a182 51
int epic_ifioctl __P((register struct ifnet *, EPIC_IFIOCTL_CMD_TYPE, caddr_t));
EPIC_INTR_RET_TYPE epic_intr __P((void *));
int epic_common_attach __P((epic_softc_t *));
void epic_ifstart __P((struct ifnet *));
void epic_ifwatchdog __P((struct ifnet *));
int epic_init __P((epic_softc_t *));
void epic_stop __P((epic_softc_t *));
void epic_rx_done __P((epic_softc_t *));
void epic_tx_done __P((epic_softc_t *));
int epic_init_rings __P((epic_softc_t *));
void epic_free_rings __P((epic_softc_t *));
void epic_stop_activity __P((epic_softc_t *));
void epic_start_activity __P((epic_softc_t *));
void epic_set_rx_mode __P((epic_softc_t *));
void epic_set_tx_mode __P((epic_softc_t *));
void epic_set_mc_table __P((epic_softc_t *));
void epic_set_media_speed __P((epic_softc_t *));
void epic_init_phy __P((epic_softc_t *));
void epic_dump_state __P((epic_softc_t *));
int epic_autoneg __P((epic_softc_t *));
int epic_read_eeprom __P((epic_softc_t *,u_int16_t));
void epic_output_eepromw __P((epic_softc_t *, u_int16_t));
u_int16_t epic_input_eepromw __P((epic_softc_t *));
u_int8_t epic_eeprom_clock __P((epic_softc_t *,u_int8_t));
void epic_write_eepromreg __P((epic_softc_t *,u_int8_t));
u_int8_t epic_read_eepromreg __P((epic_softc_t *));
u_int16_t epic_read_phy_register __P((epic_softc_t *, u_int16_t));
void epic_write_phy_register __P((epic_softc_t *, u_int16_t, u_int16_t));
#if 0
void epic_dump_phy_regs __P((epic_softc_t *));
#endif

#if !defined(EPIC_NOIFMEDIA)
int epic_ifmedia_change __P((struct ifnet *));
void epic_ifmedia_status __P((struct ifnet *, struct ifmediareq *));
#endif

int epic_mtypes [] = {
	IFM_ETHER | IFM_10_T,
	IFM_ETHER | IFM_10_T | IFM_FDX,
	IFM_ETHER | IFM_100_TX,
	IFM_ETHER | IFM_100_TX | IFM_FDX,
	IFM_ETHER | IFM_10_T | IFM_LOOP,
	IFM_ETHER | IFM_10_T | IFM_FDX | IFM_LOOP,
	IFM_ETHER | IFM_10_T | IFM_LOOP | IFM_FLAG1,
	IFM_ETHER | IFM_100_TX | IFM_LOOP,
	IFM_ETHER | IFM_100_TX | IFM_LOOP | IFM_FLAG1,
	IFM_ETHER | IFM_100_TX | IFM_FDX | IFM_LOOP,
	IFM_ETHER | IFM_AUTO
};
#define	EPIC_MTYPESNUM (sizeof(epic_mtypes) / sizeof(epic_mtypes[0]))
d184 2
d194 3
a196 3
int epic_openbsd_probe __P((struct device *,void *,void *));
void epic_openbsd_attach __P((struct device *, struct device *, void *));
void epic_shutdown __P((void *));
d206 1
a206 1
int 
d216 1
a216 1
	if( PCI_PRODUCT(pa->pa_id) == CHIPID_83C170 )
d222 1
a222 1
void
a235 1
	int i;
a236 3
#if !defined(EPIC_NOIFMEDIA)
	int tmp;
#endif
d239 1
a239 2
	command |= PCI_COMMAND_IO_ENABLE |
	    PCI_COMMAND_MEM_ENABLE |
d241 1
d247 1
a247 1
		printf(": failed to enable memory mapping\n");
d250 1
a250 1
	if( pci_io_find(pc, pa->pa_tag, PCI_CBIO, &iobase, &iosize)) {
d264 1
a264 1
	if( pci_mem_find(pc, pa->pa_tag, PCI_CBMA, &iobase, &iosize, NULL)) {
d275 3
d279 1
a279 1
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname,IFNAMSIZ);
d286 3
a288 1
	/* Do common attach procedure */
d291 3
a293 1
	/* Map interrupt */
d312 1
a312 43
	printf(" address %s",ether_sprintf(sc->sc_macaddr));
	/* Read current media config and display it too */
	i = PHY_READ_2( sc, DP83840_BMCR );
#if !defined(EPIC_NOIFMEDIA)
	tmp = IFM_ETHER;
#endif
	if( i & BMCR_AUTONEGOTIATION ){
		printf(", Auto-Neg ");

		/* To avoid bug in QS6612 read LPAR enstead of BMSR */
		i = PHY_READ_2( sc, DP83840_LPAR );
		if( i & (ANAR_100_TX|ANAR_100_TX_FD) ) printf("100Mbps");
		else printf("10Mbps");
		if( i & (ANAR_10_FD|ANAR_100_TX_FD) ) printf(" FD");
#if !defined(EPIC_NOIFMEDIA)
		tmp |= IFM_AUTO;
#endif
	} else {
#if defined(EPIC_NOIFMEDIA)
		ifp->if_flags |= IFF_LINK0;
#endif
		if( i & BMCR_100MBPS ) {
			printf(", 100Mbps");
#if !defined(EPIC_NOIFMEDIA)
			tmp |= IFM_100_TX;
#else
			ifp->if_flags |= IFF_LINK2;
#endif
		} else {
			printf(", 10Mbps");
#if !defined(EPIC_NOIFMEDIA)
			tmp |= IFM_10_T;
#endif
		}
		if( i & BMCR_FULL_DUPLEX ) {
			printf(" FD");
#if !defined(EPIC_NOIFMEDIA)
			tmp |= IFM_FDX;
#else
			ifp->if_flags |= IFF_LINK1;
#endif
		}
	}
d314 4
a317 3
	/* Init ifmedia interface */
#if !defined(EPIC_NOIFMEDIA)
	ifmedia_init(&sc->ifmedia,0,epic_ifmedia_change,epic_ifmedia_status);
d319 17
a335 2
	for (i=0; i<EPIC_MTYPESNUM; i++)
		ifmedia_add(&sc->ifmedia,epic_mtypes[i],0,NULL);
a336 2
	ifmedia_set(&sc->ifmedia, tmp);
#endif
d347 1
a347 2
	shutdownhook_establish(epic_shutdown, sc);
	printf("\n");
d350 5
a354 3
/* Simple call epic_stop() */
void
epic_shutdown(
d363 25
a387 12
const char* epic_freebsd_probe __P((pcici_t, pcidi_t));
void epic_freebsd_attach __P((pcici_t, int));
void epic_shutdown __P((int, void *));

/* Global variables */
u_long epic_pci_count;
struct pci_device txdevice = { 
	"tx",
	epic_freebsd_probe,
	epic_freebsd_attach,
	&epic_pci_count,
	NULL
d390 5
a394 2
/* Append this driver to pci drivers list */
COMPAT_PCI_DRIVER (tx, txdevice);
d396 14
a409 5
/* Synopsis: Check if device id corresponds with SMC83C170 id.  */
const char*
epic_freebsd_probe(
    pcici_t config_id,
    pcidi_t device_id)
d411 3
a413 2
	if( PCI_VENDORID(device_id) != SMC_VENDORID )
		return NULL;
d415 4
a418 2
	if( PCI_CHIPID(device_id) == CHIPID_83C170 )
		return "SMC 83c170";
d420 1
a420 1
	return NULL;
d423 26
d453 3
a455 4
void
epic_freebsd_attach(
    pcici_t config_id,
    int unit)
a458 5
#if defined(EPIC_USEIOSPACE)
	u_int32_t iobase;
#else
	caddr_t	pmembase;
#endif
d460 2
a461 1
	int i,s,tmp;
d463 1
a463 1
	printf("tx%d",unit);
d465 2
a466 3
	/* Allocate memory for softc, hardware descriptors and frag lists */
	sc = (epic_softc_t *) malloc( sizeof(epic_softc_t), M_DEVBUF, M_NOWAIT);
	if (sc == NULL)	return;
d471 1
d480 1
d485 8
a492 2
	ifp->if_output = ether_output;
	ifp->if_snd.ifq_maxlen = TX_RING_SIZE;
a493 1
	/* Get iobase or membase */
d495 21
a515 9
	command = PCI_CONF_READ(PCI_CFCS);
	command |= PCI_CFCS_IOEN;
	PCI_CONF_WRITE(PCI_CFCS, command);
	command = PCI_CONF_READ(PCI_CFCS);

	if (!(command & PCI_CFCS_IOEN)) {
		printf(": failed to enable memory mapping!\n");
		free(sc, M_DEVBUF);
		return;
d518 13
a530 4
	if (!pci_map_port(config_id, PCI_CBIO,(u_short *) &(sc->iobase))) {
		printf(": cannot map port\n");
		free(sc, M_DEVBUF);
		return;
d532 9
a540 10
#else
	command = PCI_CONF_READ(PCI_CFCS);
	command |= PCI_CFCS_MAEN;
	PCI_CONF_WRITE(PCI_CFCS, command);
	command = PCI_CONF_READ(PCI_CFCS);

	if (!(command & PCI_CFCS_MAEN)) {
		printf(": failed to enable memory mapping!\n");
		free(sc, M_DEVBUF);
		return;
d543 11
a553 4
	if (!pci_map_mem(config_id, PCI_CBMA,(vm_offset_t *) &(sc->csr),(vm_offset_t *) &pmembase)) {
		printf(": cannot map memory\n"); 
		free(sc, M_DEVBUF);
		return;
a554 1
#endif
d557 8
a564 5
	if( epic_common_attach(sc) ) return;

	command = PCI_CONF_READ(PCI_CFCS);
	command |= PCI_CFCS_BMEN;
	PCI_CONF_WRITE(PCI_CFCS, command);
d567 1
a567 3
	printf(": address %02x:%02x:%02x:%02x:%02x:%02x,",
		sc->sc_macaddr[0],sc->sc_macaddr[1],sc->sc_macaddr[2],
		sc->sc_macaddr[3],sc->sc_macaddr[4],sc->sc_macaddr[5]);
d579 1
d581 3
a583 42
	/* Read current media config and display it too */
	i = PHY_READ_2( sc, DP83840_BMCR );
#if !defined(EPIC_NOIFMEDIA)
	tmp = IFM_ETHER;
#endif
	if( i & BMCR_AUTONEGOTIATION ){
		printf(", Auto-Neg ");

		/* To avoid bug in QS6612 read LPAR enstead of BMSR */
		i = PHY_READ_2( sc, DP83840_LPAR );
		if( i & (ANAR_100_TX|ANAR_100_TX_FD) ) printf("100Mbps ");
		else printf("10Mbps ");
		if( i & (ANAR_10_FD|ANAR_100_TX_FD) ) printf("FD");
#if !defined(EPIC_NOIFMEDIA)
		tmp |= IFM_AUTO;
#endif
	} else {
#if defined(EPIC_NOIFMEDIA)
		ifp->if_flags |= IFF_LINK0;
#endif
		if( i & BMCR_100MBPS ) {
			printf(", 100Mbps ");
#if !defined(EPIC_NOIFMEDIA)
			tmp |= IFM_100_TX;
#else
			ifp->if_flags |= IFF_LINK2;
#endif
		} else {
			printf(", 10Mbps ");
#if !defined(EPIC_NOIFMEDIA)
			tmp |= IFM_10_T;
#endif
		}
		if( i & BMCR_FULL_DUPLEX ) {
			printf("FD");
#if !defined(EPIC_NOIFMEDIA)
			tmp |= IFM_FDX;
#else
			ifp->if_flags |= IFF_LINK1;
#endif
		}
	}
d585 2
a586 3
	/* Init ifmedia interface */
#if !defined(EPIC_NOIFMEDIA)
	ifmedia_init(&sc->ifmedia,0,epic_ifmedia_change,epic_ifmedia_status);
d588 2
a589 2
	for (i=0; i<EPIC_MTYPESNUM; i++)
		ifmedia_add(&sc->ifmedia,epic_mtypes[i],0,NULL);
d591 10
a600 2
	ifmedia_set(&sc->ifmedia, tmp);
#endif
d604 6
a609 6
	/* Map interrupt */
	if( !pci_map_int(config_id, epic_intr, (void*)sc, &net_imask) ) {
		printf(": couldn't map interrupt\n");
		free(sc, M_DEVBUF);
		return;
	}
d611 2
a612 2
	/* Set shut down routine to stop DMA processes on reboot */
	at_shutdown(epic_shutdown, sc, SHUTDOWN_POST_SYNC);
d614 3
a616 3
	/*  Attach to if manager */
	if_attach(ifp);
	ether_ifattach(ifp);
d618 1
a618 3
#if NBPFILTER > 0
	bpfattach(ifp,DLT_EN10MB, sizeof(struct ether_header));
#endif
d622 26
a647 1
	printf("\n");
d651 11
a662 5
void
epic_shutdown(
    int howto,
    void *sc)
{
d664 2
a666 1

d670 1
a670 1
   OS-independing part
d675 1
d677 5
a681 5
int
epic_ifioctl __P((
    register struct ifnet * ifp,
    EPIC_IFIOCTL_CMD_TYPE command,
    caddr_t data))
d685 2
d709 1
a709 1
#endif /* __FreeBSD__ */
d732 1
a732 1
#endif
d751 1
a752 2

		/* Handle IFF_PROMISC flag */
a753 5

#if defined(EPIC_NOIFMEDIA)
		/* Handle IFF_LINKx flags */
		epic_set_media_speed(sc);
#endif
a774 1
#if !defined(EPIC_NOIFMEDIA)
d777 2
a778 2
		error = ifmedia_ioctl(ifp, (struct ifreq *)data, 
		    &sc->ifmedia, command);
a779 1
#endif
d791 1
a791 1
 * and frag lists, wake up chip, read MAC address and PHY identyfier.
d794 3
a796 3
int
epic_common_attach(
    epic_softc_t *sc)
d801 3
d806 1
a806 1
	    sizeof(struct epic_tx_desc)*TX_RING_SIZE + PAGE_SIZE,
d815 3
a817 1
	/* Align pool on PAGE_SIZE */
d821 3
a823 1
	/* Distribute memory */
d830 4
a833 2
	/* Bring the chip out of low-power mode. */
	CSR_WRITE_4( sc, GENCTL, GENCTL_SOFT_RESET);
d835 3
a837 4
	/* Workaround for Application Note 7-15 */
	for (i=0; i<16; i++) CSR_WRITE_4(sc, TEST1, TEST1_CLOCK_TEST);

	/* Read mac address from EEPROM */
d841 3
a843 6
	/* Identify PHY */
	sc->phyid = PHY_READ_2(sc, DP83840_PHYIDR1 )<<6;
	sc->phyid|= (PHY_READ_2( sc, DP83840_PHYIDR2 )>>10)&0x3F;
	if( QS6612_OUI != sc->phyid ) 
		printf(": WARNING! PHY unknown (0x%x)",sc->phyid);

d855 4
a858 2
void
epic_ifstart(struct ifnet * const ifp){
a866 14
#if 0
	/* If no link is established, simply free all mbufs in queue */
	PHY_READ_2( sc, DP83840_BMSR );
	if( !(BMSR_LINK_STATUS & PHY_READ_2( sc, DP83840_BMSR )) ){
		IF_DEQUEUE( &ifp->if_snd, m0 );
		while( m0 ) {
			m_freem(m0);
			IF_DEQUEUE( &ifp->if_snd, m0 );
		}
		return;
	}
#endif

	/* Link is OK, queue packets to NIC */
a877 11
		/* If descriptor is busy, set IFF_OACTIVE and exit */
		if( desc->status & 0x8000 ) {
			dprintf((EPIC_FORMAT ": desc is busy in ifstart, up and down interface please\n",EPIC_ARGS(sc)));
			break;
		}

		if( buf->mbuf ) {
			dprintf((EPIC_FORMAT ": mbuf not freed in ifstart, up and down interface please\n",EPIC_ARGS(sc)));
			break;
		}

d923 1
a923 5
#if defined(__FreeBSD__)
			bpf_mtap( ifp, m0 );
#else /* __OpenBSD__ */
			bpf_mtap( ifp->if_bpf, m0 );
#endif /* __FreeBSD__ */
d934 1
a934 2
 *
 * splimp() invoked before epic_intr_normal()
d936 3
a938 3
void
epic_rx_done __P((
	epic_softc_t *sc ))
d986 1
d990 1
a990 5
#if defined(__FreeBSD__)
			bpf_mtap( &sc->sc_if, m );
#else /* __OpenBSD__ */
			bpf_mtap( sc->sc_if.if_bpf, m );
#endif /* __FreeBSD__ */
d992 1
d1014 3
a1016 3
void
epic_tx_done __P(( 
    register epic_softc_t *sc ))
d1054 1
a1054 2
 *
 * splimp() assumed to be done 
d1056 3
a1058 3
EPIC_INTR_RET_TYPE
epic_intr (
    void *arg)
a1065 1

a1079 2
                if( sc->sc_if.if_flags & IFF_DEBUG ) 
                    epic_dump_state(sc);
a1093 40
        if( (status & INTSTAT_GP2) && (QS6612_OUI == sc->phyid) ) {
	    u_int32_t phystatus = PHY_READ_2( sc, QS6612_INTSTAT );

	    if( phystatus & INTSTAT_AN_COMPLETE ) {
		u_int32_t bmcr;
		if( epic_autoneg(sc) == EPIC_FULL_DUPLEX ) {
		    dprintf((EPIC_FORMAT ": going fullduplex\n",EPIC_ARGS(sc)));
		    bmcr = BMCR_FULL_DUPLEX | PHY_READ_2( sc, DP83840_BMCR );
		    sc->txcon |= TXCON_FULL_DUPLEX;
		} else {
		    /* Default to half-duplex */
		    dprintf((EPIC_FORMAT ": going halfduplex\n",EPIC_ARGS(sc)));
		    bmcr = ~BMCR_FULL_DUPLEX & PHY_READ_2( sc, DP83840_BMCR );
		    sc->txcon &= ~TXCON_FULL_DUPLEX;
		}

		/* There is apparently QS6612 chip bug: */
		/* BMCR_FULL_DUPLEX flag is not updated by */
		/* autonegotiation process, so update it by hands */
		/* so we can rely on it in epic_ifmedia_status() */
		PHY_WRITE_2( sc, DP83840_BMCR, bmcr );

		epic_stop_activity(sc);
		epic_set_tx_mode(sc);
		epic_start_activity(sc);
	    }

	    PHY_READ_2(sc, DP83840_BMSR);
	    if( !(PHY_READ_2(sc, DP83840_BMSR) & BMSR_LINK_STATUS) ) {
		dprintf((EPIC_FORMAT ": WARNING! link down\n",EPIC_ARGS(sc)));
		sc->flags |= EPIC_LINK_DOWN;
	    } else {
    		dprintf((EPIC_FORMAT ": link up\n",EPIC_ARGS(sc)));
		sc->flags &= ~EPIC_LINK_DOWN;
	    }

	    /* We should clear GP2 int again after we clear it on PHY */
	    CSR_WRITE_4( sc, INTSTAT, INTSTAT_GP2 ); 
	}

a1106 2
		epic_dump_state(sc);

a1149 2
 *
 * splimp() invoked here
d1151 3
a1153 3
void
epic_ifwatchdog __P((
    struct ifnet *ifp))
d1168 1
a1168 3
#if defined(EPIC_DEBUG)
		if( ifp->if_flags & IFF_DEBUG ) epic_dump_state(sc);
#endif
d1185 6
a1190 4
#if defined(SIOCSIFMEDIA) && !defined(EPIC_NOIFMEDIA)
int
epic_ifmedia_change __P((
    struct ifnet * ifp))
d1192 5
a1196 1
	epic_softc_t *sc = (epic_softc_t *)(ifp->if_softc);
d1198 1
a1198 2
	if (IFM_TYPE(sc->ifmedia.ifm_media) != IFM_ETHER)
        	return (EINVAL);
d1200 4
a1203 1
	if (!(ifp->if_flags & IFF_UP))
d1206 22
a1227 3
	epic_stop_activity(sc);
	epic_set_media_speed(sc);
	epic_start_activity(sc);
d1229 1
a1229 1
	return 0;
d1232 7
a1238 4
void
epic_ifmedia_status __P((
    struct ifnet * ifp,
    struct ifmediareq *ifmr))
d1240 11
a1250 3
	epic_softc_t *sc = ifp->if_softc;
	u_int32_t bmcr;
	u_int32_t bmsr;
a1251 1
	if (!(ifp->if_flags & IFF_UP))
d1253 1
d1255 42
a1296 1
	bmcr = PHY_READ_2( sc, DP83840_BMCR );
d1298 1
a1298 2
	PHY_READ_2( sc, DP83840_BMSR );
	bmsr = PHY_READ_2( sc, DP83840_BMSR );
d1300 2
a1301 2
	ifmr->ifm_active = IFM_ETHER;
	ifmr->ifm_status = IFM_AVALID;
d1303 17
a1319 4
	if( !(bmsr & BMSR_LINK_STATUS) ) { 
		ifmr->ifm_active |= 
		    (bmcr&BMCR_AUTONEGOTIATION)?IFM_AUTO:IFM_NONE;
		return;
d1322 1
a1322 8
	ifmr->ifm_status |= IFM_ACTIVE;
	ifmr->ifm_active |= (bmcr & BMCR_100MBPS) ? IFM_100_TX : IFM_10_T;
	ifmr->ifm_active |= (bmcr & BMCR_FULL_DUPLEX) ? IFM_FDX : 0;
	if ((sc->txcon & TXCON_LOOPBACK_MODE) == TXCON_LOOPBACK_MODE_INT)
		ifmr->ifm_active |= (IFM_LOOP | IFM_FLAG1);
	else if ((sc->txcon & TXCON_LOOPBACK_MODE) == TXCON_LOOPBACK_MODE_PHY)
		ifmr->ifm_active |= IFM_LOOP;

d1327 1
a1327 3
 * Reset chip, PHY, allocate rings
 * 
 * splimp() invoked here
d1329 3
a1331 3
int 
epic_init __P((
    epic_softc_t * sc))
d1334 2
a1335 1
	int s,i;
d1339 6
d1360 2
d1392 1
a1392 2
		INTSTAT_FATAL |
		((QS6612_OUI == sc->phyid)?INTSTAT_GP2:0) );
a1398 3
	/* Set media speed mode */
	epic_set_media_speed( sc );

d1409 12
d1422 1
d1427 1
a1427 2
 * Synopsis: calculate and set Rx mode. Chip must be in idle state to
 * access RXCON.
d1429 2
a1430 3
void
epic_set_rx_mode(
    epic_softc_t * sc)
d1432 1
a1432 2
	u_int32_t flags = sc->sc_if.if_flags;
        u_int32_t rxcon = RXCON_DEFAULT | RXCON_RECEIVE_MULTICAST_FRAMES | RXCON_RECEIVE_BROADCAST_FRAMES;
d1434 3
a1436 1
	rxcon |= (flags & IFF_PROMISC)?RXCON_PROMISCUOUS_MODE:0;
d1438 5
a1442 1
	CSR_WRITE_4( sc, RXCON, rxcon );
d1444 2
a1445 2
	return;
}
d1447 2
a1448 14
#if 0
void
epic_dump_phy_regs(epic_softc_t *sc)
{

	printf("BMCR: 0x%04x\n", PHY_READ_2(sc, DP83840_BMCR));
	printf("BMSR: 0x%04x\n", PHY_READ_2(sc, DP83840_BMSR));
	printf("ANAR: 0x%04x\n", PHY_READ_2(sc, DP83840_ANAR));
	printf("LPAR: 0x%04x\n", PHY_READ_2(sc, DP83840_LPAR));
	printf("ANER: 0x%04x\n", PHY_READ_2(sc, DP83840_ANER));
	printf("MCTL: 0x%04x\n", PHY_READ_2(sc, QS6612_MCTL));
	printf("INTSTAT: 0x%04x\n", PHY_READ_2(sc, QS6612_INTSTAT));
	printf("INTMASK: 0x%04x\n", PHY_READ_2(sc, QS6612_INTMASK));
	printf("BPCR: 0x%04x\n", PHY_READ_2(sc, QS6612_BPCR));
a1449 2
#endif

d1451 2
a1452 1
 * Synopsis: Reset PHY and do PHY-special initialization:
d1454 3
a1456 3
void
epic_init_phy __P((
    epic_softc_t * sc))
d1458 2
a1459 10
	u_int32_t i;

	/* Reset PHY (We have to take the delay from manual XXX) */
	PHY_WRITE_2(sc, DP83840_BMCR, BMCR_RESET);
	DELAY(10);
	for(i=0;i<0x1000;i++) {
		if( !(PHY_READ_2(sc, DP83840_BMCR) & BMCR_RESET) )
			break;
		DELAY(1);
	}
d1461 1
a1461 2
	if( PHY_READ_2(sc, DP83840_BMCR) & BMCR_RESET )
		printf(EPIC_FORMAT ": WARNING! cant reset PHY\n",EPIC_ARGS(sc));
d1463 1
a1463 114
	PHY_WRITE_2(sc, DP83840_BMCR, 0 );
	PHY_WRITE_2(sc, DP83840_BMCR, BMCR_LOOPBACK | BMCR_ISOLATE );

	switch( sc->phyid ){
	case QS6612_OUI: {
		/* Init QS6612 and EPIC to generate interrupt */
		CSR_WRITE_4(sc, NVCTL, NVCTL_GP1_OUTPUT_ENABLE | NVCTL_GP1);

		/* Mask interrupts sources */
		PHY_WRITE_2(sc, QS6612_INTMASK,
			PHY_READ_2(sc, QS6612_INTSTAT) |	
			INTMASK_THUNDERLAN | INTSTAT_AN_COMPLETE |
			INTSTAT_LINK_STATUS );

		/* Enable QS6612 extended cable length capabilites */
		/* PHY_WRITE_2(sc, QS6612_MCTL,			   */
		/*	PHY_READ_2(sc, QS6612_MCTL) | MCTL_BTEXT); */

		break;
	}
	default:
		break;
	}
}

/*
 * Synopsis: Set PHY to media type specified by IFF_LINK* flags or
 * ifmedia structure. Chip must be in idle state to access TXCON.
 */
void
epic_set_media_speed __P((
    epic_softc_t * sc))
{
	u_int16_t media;
#if !defined(EPIC_NOIFMEDIA)
	u_int32_t tgtmedia = sc->ifmedia.ifm_cur->ifm_media;
#endif

	epic_init_phy(sc);

#if !defined(EPIC_NOIFMEDIA)
	if( IFM_SUBTYPE(tgtmedia) != IFM_AUTO ){
		/* Clean previous values */
		sc->txcon &= ~(TXCON_LOOPBACK_MODE | TXCON_FULL_DUPLEX);
		media = 0;

		/* Set mode */
		media |= (IFM_SUBTYPE(tgtmedia)==IFM_100_TX) ? BMCR_100MBPS : 0;
		if (tgtmedia & IFM_FDX) {
			media |= BMCR_FULL_DUPLEX;
 			sc->txcon |= TXCON_FULL_DUPLEX;
		}
		if (tgtmedia & IFM_LOOP) {
			if (tgtmedia & IFM_FLAG1)
				sc->txcon |= TXCON_LOOPBACK_MODE_INT;
			else {
				media |= BMCR_LOOPBACK | BMCR_ISOLATE;
				sc->txcon |= TXCON_LOOPBACK_MODE_PHY;
			}
		}

		sc->sc_if.if_baudrate = 
			(IFM_SUBTYPE(tgtmedia)==IFM_100_TX)?100000000:10000000;

		PHY_WRITE_2( sc, DP83840_BMCR, media );
	}
#else /* EPIC_NOIFMEDIA */
	struct ifnet *ifp = &sc->sc_if;

	if( ifp->if_flags & IFF_LINK0 ) {
		/* Set mode */
		media = 0;
		media|= (ifp->if_flags & IFF_LINK2) ? BMCR_100MBPS : 0;
		media|= (ifp->if_flags & IFF_LINK1) ? BMCR_FULL_DUPLEX : 0;

		sc->sc_if.if_baudrate = 
			(ifp->if_flags & IFF_LINK2)?100000000:10000000;

		PHY_WRITE_2( sc, DP83840_BMCR, media );

		if( ifp->if_flags & IFF_LINK2 ) sc->txcon |= TXCON_FULL_DUPLEX;
		else sc->txcon &= ~TXCON_FULL_DUPLEX; 
 
		CSR_WRITE_4( sc, TXCON, sc->txcon );
	}
#endif /* !EPIC_NOIFMEDIA */
	  else {
		sc->sc_if.if_baudrate = 100000000;

		sc->txcon &= ~TXCON_FULL_DUPLEX; 
		CSR_WRITE_4(sc, TXCON, sc->txcon);

		/* Set and restart autoneg */
		PHY_WRITE_2(sc, DP83840_BMCR, BMCR_AUTONEGOTIATION );
		PHY_WRITE_2(sc, DP83840_BMCR,
			BMCR_AUTONEGOTIATION | BMCR_RESTART_AUTONEG);

		/* If it is not QS6612 PHY, try to get result of autoneg. */
		if( QS6612_OUI != sc->phyid ) {
			/* Wait 3 seconds for the autoneg to finish
			 * This is the recommended time from the DP83840A data
			 * sheet Section 7.1
			 */
        		DELAY(3000000);
			
			if( epic_autoneg(sc) == EPIC_FULL_DUPLEX ) {
				sc->txcon |= TXCON_FULL_DUPLEX;
				CSR_WRITE_4(sc, TXCON, sc->txcon);
			}
		}
		/* Else it will be done when GP2 int occured */
	}

	epic_set_tx_mode(sc);
d1469 2
a1470 78
 * This functions get results of the autoneg processes of the phy
 * It implements the workaround that is described in section 7.2 & 7.3 of the 
 * DP83840A data sheet
 * http://www.national.com/ds/DP/DP83840A.pdf
 */
int 
epic_autoneg(
    epic_softc_t * sc)
{
	u_int16_t media;
	u_int16_t i;

        /* BMSR must be read twice to update the link status bit
	 * since that bit is a latch bit
         */
	PHY_READ_2( sc, DP83840_BMSR);
	i = PHY_READ_2( sc, DP83840_BMSR);
        
        if ((i & BMSR_LINK_STATUS) && (i & BMSR_AUTONEG_COMPLETE)){
		i = PHY_READ_2( sc, DP83840_LPAR );

		if ( i & (ANAR_100_TX_FD|ANAR_10_FD) )
			return 	EPIC_FULL_DUPLEX;
		else
			return EPIC_HALF_DUPLEX;
        } else {   
		/*Auto-negotiation or link status is not 1
		  Thus the auto-negotiation failed and one
		  must take other means to fix it.
		 */

		/* ANER must be read twice to get the correct reading for the 
		 * Multiple link fault bit -- it is a latched bit
	 	 */
 		PHY_READ_2( sc, DP83840_ANER );
		i = PHY_READ_2( sc, DP83840_ANER );
	
		if ( i & ANER_MULTIPLE_LINK_FAULT ) {
			/* it can be forced to 100Mb/s Half-Duplex */
	 		media = PHY_READ_2( sc, DP83840_BMCR );
			media &= ~(BMCR_AUTONEGOTIATION | BMCR_FULL_DUPLEX);
			media |= BMCR_100MBPS;
			PHY_WRITE_2( sc, DP83840_BMCR, media );
		
			/* read BMSR again to determine link status */
			PHY_READ_2( sc, DP83840_BMSR );
			i=PHY_READ_2( sc, DP83840_BMSR );
		
			if (i & BMSR_LINK_STATUS){
				/* port is linked to the non Auto-Negotiation
				 * 100Mbs partner.
			 	 */
				return EPIC_HALF_DUPLEX;
			}
			else {
				media = PHY_READ_2( sc, DP83840_BMCR);
				media &= ~(BMCR_AUTONEGOTIATION | BMCR_FULL_DUPLEX | BMCR_100MBPS);
				PHY_WRITE_2( sc, DP83840_BMCR, media);
				PHY_READ_2( sc, DP83840_BMSR );
				i = PHY_READ_2( sc, DP83840_BMSR );

				if (i & BMSR_LINK_STATUS) {
					/*port is linked to the non
					 * Auto-Negotiation10Mbs partner
			 	 	 */
					return EPIC_HALF_DUPLEX;
				}
			}
		}
		/* If we get here we are most likely not connected
		 * so lets default it to half duplex
		 */
		return EPIC_HALF_DUPLEX;
	}
	
}

/*
d1472 3
a1474 3
void
epic_set_tx_mode (
    epic_softc_t *sc )
d1476 2
d1479 1
a1479 4
    if( sc->txcon & TXCON_EARLY_TRANSMIT_ENABLE )
	CSR_WRITE_4( sc, ETXTHR, sc->tx_threshold );

    CSR_WRITE_4( sc, TXCON, sc->txcon );
d1490 3
a1492 3
void
epic_set_mc_table (
    epic_softc_t * sc)
d1510 9
a1518 9
void
epic_start_activity __P((
    epic_softc_t * sc))
{
    /* Start rx process */
    CSR_WRITE_4(sc, COMMAND,
	COMMAND_RXQUEUED | COMMAND_START_RX |
	(sc->pending_txs?COMMAND_TXQUEUED:0));
    dprintf((EPIC_FORMAT ": activity started\n",EPIC_ARGS(sc)));
d1525 3
a1527 3
void
epic_stop_activity __P((
    epic_softc_t * sc))
a1618 2
 *
 *  splimp() invoked here
d1620 3
a1622 3
void
epic_stop __P((
    epic_softc_t * sc))
d1657 3
a1659 3
void
epic_free_rings __P((
    epic_softc_t * sc))
d1693 4
a1696 2
int
epic_init_rings(epic_softc_t * sc){
d1745 4
a1748 3
void epic_write_eepromreg __P((
    epic_softc_t *sc,
    u_int8_t val))
d1760 3
a1762 3
u_int8_t
epic_read_eepromreg __P((
    epic_softc_t *sc))
d1764 1
a1764 1
	return CSR_READ_1( sc,EECTL );
d1767 4
a1770 4
u_int8_t
epic_eeprom_clock __P((
    epic_softc_t *sc,
    u_int8_t val))
d1779 4
a1782 4
void
epic_output_eepromw __P((
    epic_softc_t * sc,
    u_int16_t val))
d1791 3
a1793 3
u_int16_t
epic_input_eepromw __P((
    epic_softc_t *sc))
d1808 4
a1811 4
int
epic_read_eeprom __P((
    epic_softc_t *sc,
    u_int16_t loc))
d1832 7
a1838 4
u_int16_t
epic_read_phy_register __P((
    epic_softc_t *sc,
    u_int16_t loc))
d1842 1
a1842 1
	CSR_WRITE_4( sc, MIICTL, ((loc << 4) | 0x0601) );
d1845 1
a1845 1
		if( !(CSR_READ_4( sc, MIICTL )&1) ) break;
d1849 1
a1849 1
	return CSR_READ_4( sc, MIIDATA );
d1852 4
a1855 5
void
epic_write_phy_register __P((
    epic_softc_t * sc,
    u_int16_t loc,
    u_int16_t val))
d1859 2
a1860 2
	CSR_WRITE_4( sc, MIIDATA, val );
	CSR_WRITE_4( sc, MIICTL, ((loc << 4) | 0x0602) );
d1862 2
a1863 2
	for( i=0;i<0x100;i++) {
		if( !(CSR_READ_4( sc, MIICTL )&2) ) break;
d1870 26
a1895 34
void
epic_dump_state __P((
    epic_softc_t * sc))
{
	int j;
	struct epic_tx_desc *tdesc;
	struct epic_rx_desc *rdesc;
	printf(EPIC_FORMAT ": cur_rx: %d, pending_txs: %d, dirty_tx: %d, cur_tx: %d\n", EPIC_ARGS(sc),sc->cur_rx,sc->pending_txs,sc->dirty_tx,sc->cur_tx);
	printf(EPIC_FORMAT ": COMMAND: 0x%08x, INTSTAT: 0x%08x\n",EPIC_ARGS(sc),CSR_READ_4(sc,COMMAND),CSR_READ_4(sc,INTSTAT));
	printf(EPIC_FORMAT ": PRCDAR: 0x%08x, PTCDAR: 0x%08x\n",EPIC_ARGS(sc),CSR_READ_4(sc,PRCDAR),CSR_READ_4(sc,PTCDAR));
	printf(EPIC_FORMAT ": dumping rx descriptors\n",EPIC_ARGS(sc));
	for(j=0;j<RX_RING_SIZE;j++){
		rdesc = sc->rx_desc + j;
		printf("desc%d: %4d 0x%04x, 0x%08x, %4d, 0x%08x\n",
			j,
			rdesc->rxlength,rdesc->status,
			rdesc->bufaddr,
			rdesc->buflength,
			rdesc->next
		);
	}
	printf(EPIC_FORMAT ": dumping tx descriptors\n",EPIC_ARGS(sc));
	for(j=0;j<TX_RING_SIZE;j++){
		tdesc = sc->tx_desc + j;
		printf(
 		"desc%d: %4d 0x%04x, 0x%08lx, 0x%04x %4u, 0x%08lx, mbuf: %p\n",
			j,
			tdesc->txlength,tdesc->status,
			(u_long)tdesc->bufaddr,
			tdesc->control,tdesc->buflength,
			(u_long)tdesc->next,
			(void *)sc->tx_buffer[j].mbuf
		);
	}
a1896 1
#endif /* NPCI > 0 */
@


1.9
log
@merge with freebsd:
o make sure busmaster/io/mem bits are set appropriately
o make sure the card powers up correctly
@
text
@d1 2
a2 2
/*	$OpenBSD: if_tx.c,v 1.8 1999/09/30 00:12:21 jason Exp $	*/
/* $FreeBSD: src/sys/pci/if_tx.c,v 1.33 1999/10/29 09:56:51 semenu Exp $ */
d59 1
a59 1
	    if( NULL == ((m)->m_flags & M_EXT) ){ \
@


1.9.2.1
log
@sync with -current
@
text
@d1 2
a2 2
/*	$OpenBSD: if_tx.c,v 1.10 2000/02/21 20:54:04 jason Exp $	*/
/* $FreeBSD: src/sys/pci/if_tx.c,v 1.34 1999/12/21 11:14:10 eivind Exp $ */
d59 1
a59 1
	    if( 0 == ((m)->m_flags & M_EXT) ){ \
@


1.9.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: if_tx.c,v 1.14 2001/03/22 01:38:54 angelos Exp $	*/
/* $FreeBSD: src/sys/pci/if_tx.c,v 1.45 2001/02/07 20:11:02 semenu Exp $ */
d38 1
d43 2
d48 22
a71 1
#include <sys/sockio.h>
d76 1
a76 38
#include <sys/queue.h>

#if defined(__FreeBSD__)
#define NBPFILTER	1

#include <net/if.h>
#include <net/if_arp.h>
#include <net/ethernet.h>
#include <net/if_media.h>

#include <net/bpf.h>

#include <vm/vm.h>              /* for vtophys */
#include <vm/pmap.h>            /* for vtophys */
#include <machine/clock.h>      /* for DELAY */
#include <machine/bus_memio.h>
#include <machine/bus_pio.h>
#include <machine/bus.h>
#include <machine/resource.h>
#include <sys/bus.h>
#include <sys/rman.h>

#include <pci/pcireg.h>
#include <pci/pcivar.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/miidevs.h>

#include <dev/mii/lxtphyreg.h>

#include "miibus_if.h"

#include <pci/if_txvar.h>
#else /* __OpenBSD__ */
#include "bpfilter.h"

#include <sys/device.h>
d81 4
d86 1
a92 1
#include <netinet/if_ether.h>
d107 1
d110 7
a117 6
#include <vm/pmap.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/miidevs.h>
#include <dev/mii/lxtphyreg.h>
d124 10
d137 4
a140 1
MODULE_DEPEND(tx, miibus, 1, 1, 1);
a141 2

#if defined(__FreeBSD__)
a142 2
#define EPIC_MIIBUS_WRITEREG_RET_TYPE int
#define EPIC_STATIC static
d144 1
a145 2
#define EPIC_MIIBUS_WRITEREG_RET_TYPE void
#define EPIC_STATIC
d148 52
a199 35
EPIC_STATIC int epic_ifioctl __P((register struct ifnet *, u_long, caddr_t));
EPIC_STATIC EPIC_INTR_RET_TYPE epic_intr __P((void *));
EPIC_STATIC int epic_common_attach __P((epic_softc_t *));
EPIC_STATIC void epic_ifstart __P((struct ifnet *));
EPIC_STATIC void epic_ifwatchdog __P((struct ifnet *));
EPIC_STATIC int epic_init __P((epic_softc_t *));
EPIC_STATIC void epic_stop __P((epic_softc_t *));
EPIC_STATIC void epic_rx_done __P((epic_softc_t *));
EPIC_STATIC void epic_tx_done __P((epic_softc_t *));
EPIC_STATIC int epic_init_rings __P((epic_softc_t *));
EPIC_STATIC void epic_free_rings __P((epic_softc_t *));
EPIC_STATIC void epic_stop_activity __P((epic_softc_t *));
EPIC_STATIC void epic_start_activity __P((epic_softc_t *));
EPIC_STATIC void epic_set_rx_mode __P((epic_softc_t *));
EPIC_STATIC void epic_set_tx_mode __P((epic_softc_t *));
EPIC_STATIC void epic_set_mc_table __P((epic_softc_t *));
EPIC_STATIC int epic_read_eeprom __P((epic_softc_t *,u_int16_t));
EPIC_STATIC void epic_output_eepromw __P((epic_softc_t *, u_int16_t));
EPIC_STATIC u_int16_t epic_input_eepromw __P((epic_softc_t *));
EPIC_STATIC u_int8_t epic_eeprom_clock __P((epic_softc_t *,u_int8_t));
EPIC_STATIC void epic_write_eepromreg __P((epic_softc_t *,u_int8_t));
EPIC_STATIC u_int8_t epic_read_eepromreg __P((epic_softc_t *));

EPIC_STATIC int epic_read_phy_reg __P((epic_softc_t *, int, int));
EPIC_STATIC void epic_write_phy_reg __P((epic_softc_t *, int, int, int));

EPIC_STATIC int epic_miibus_readreg __P((struct device*, int, int));
EPIC_STATIC EPIC_MIIBUS_WRITEREG_RET_TYPE epic_miibus_writereg __P((struct device*, int, int, int));
EPIC_STATIC void epic_miibus_statchg __P((struct device *));
EPIC_STATIC void epic_miibus_mediainit __P((struct device *));


EPIC_STATIC int epic_ifmedia_upd __P((struct ifnet *));
EPIC_STATIC void epic_ifmedia_sts __P((struct ifnet *, struct ifmediareq *));
EPIC_STATIC void epic_tick __P((void *));
d210 1
a210 1
void epic_openbsd_shutdown __P((void *));
d230 1
a230 1
	if( PCI_PRODUCT(pa->pa_id) == SMC_DEVICEID_83C170 )
d248 1
d250 1
d252 3
d257 2
a258 1
	command |= PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
d263 21
a283 2
	if ((command & (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE)) == 0) {
		printf(": neither i/o nor mem enabled\n");
d286 3
a288 13

	if (command & PCI_COMMAND_MEM_ENABLE) {
		if (pci_mapreg_map(pa, PCI_BASEMEM, PCI_MAPREG_TYPE_MEM, 0,
		    &sc->sc_st, &sc->sc_sh, NULL, &iosize)) {
			printf(": can't map mem space\n");
			return;
		}
	} else {
		if (pci_mapreg_map(pa, PCI_BASEIO, PCI_MAPREG_TYPE_IO, 0,
		    &sc->sc_st, &sc->sc_sh, NULL, &iosize)) {
			printf(": can't map i/o space\n");
			return;
		}
d290 2
d294 1
a294 1
	bcopy(sc->dev.dv_xname, ifp->if_xname,IFNAMSIZ);
a300 4
	/* Fetch card id */
	sc->cardvend = pci_conf_read(pc, pa->pa_tag, PCI_SUBVEND_0);
	sc->cardid = pci_conf_read(pc, pa->pa_tag, PCI_SUBDEV_0);

d320 1
d323 43
a365 1
	printf(": %s address %s\n", intrstr, ether_sprintf(sc->sc_macaddr));
d368 5
a372 12
	ifmedia_init(&sc->miibus.mii_media, 0,
		epic_ifmedia_upd, epic_ifmedia_sts);
	sc->miibus.mii_ifp = ifp;
	sc->miibus.mii_readreg = epic_miibus_readreg;
	sc->miibus.mii_writereg = epic_miibus_writereg;
	sc->miibus.mii_statchg = epic_miibus_statchg;
	mii_phy_probe(self, &sc->miibus, 0xffffffff);
	if (LIST_FIRST(&sc->miibus.mii_phys) == NULL) {
		ifmedia_add(&sc->miibus.mii_media, IFM_ETHER|IFM_NONE,0,NULL);
		ifmedia_set(&sc->miibus.mii_media, IFM_ETHER|IFM_NONE);
        } else
		ifmedia_set(&sc->miibus.mii_media, IFM_ETHER|IFM_AUTO);
d374 2
a375 1
	timeout_set(&sc->sc_tmo, epic_tick, sc);
d380 4
d386 2
a387 1
	shutdownhook_establish(epic_openbsd_shutdown, sc);
d392 1
a392 1
epic_openbsd_shutdown(
d401 12
a412 24
static int epic_freebsd_probe __P((device_t));
static int epic_freebsd_attach __P((device_t));
static void epic_freebsd_shutdown __P((device_t));
static int epic_freebsd_detach __P((device_t));
static struct epic_type *epic_devtype __P((device_t));

static device_method_t epic_methods[] = {
	/* Device interface */   
	DEVMETHOD(device_probe,		epic_freebsd_probe),
	DEVMETHOD(device_attach,	epic_freebsd_attach),
	DEVMETHOD(device_detach,	epic_freebsd_detach),
	DEVMETHOD(device_shutdown,	epic_freebsd_shutdown),

	/* bus interface */
	DEVMETHOD(bus_print_child,	bus_generic_print_child),
	DEVMETHOD(bus_driver_added,	bus_generic_driver_added),

	/* MII interface */
	DEVMETHOD(miibus_readreg,	epic_miibus_readreg),
	DEVMETHOD(miibus_writereg,	epic_miibus_writereg),
	DEVMETHOD(miibus_statchg,	epic_miibus_statchg),
	DEVMETHOD(miibus_mediainit,	epic_miibus_mediainit),

	{ 0, 0 }
d415 2
a416 32
static driver_t epic_driver = {
        "tx",
        epic_methods,
        sizeof(epic_softc_t)
};

static devclass_t epic_devclass;

DRIVER_MODULE(if_tx, pci, epic_driver, epic_devclass, 0, 0);
DRIVER_MODULE(miibus, tx, miibus_driver, miibus_devclass, 0, 0);

static struct epic_type epic_devs[] = {
	{ SMC_VENDORID, SMC_DEVICEID_83C170,
		"SMC EtherPower II 10/100" },   
	{ 0, 0, NULL }
};

static int
epic_freebsd_probe(dev)
	device_t dev;
{
	struct epic_type *t;

	t = epic_devtype(dev);

	if (t != NULL) {
		device_set_desc(dev, t->name);
		return(0);
	}

	return(ENXIO);
}
d418 5
a422 3
static struct epic_type *
epic_devtype(dev)
	device_t dev;
d424 2
a425 1
	struct epic_type *t;
d427 2
a428 1
	t = epic_devs;
d430 1
a430 8
	while(t->name != NULL) {
		if ((pci_get_vendor(dev) == t->ven_id) &&
		    (pci_get_device(dev) == t->dev_id)) {
			return(t);
		}
		t++;
	}
	return (NULL);
a432 8
#if defined(EPIC_USEIOSPACE)
#define	EPIC_RES	SYS_RES_IOPORT
#define	EPIC_RID	PCIR_BASEIO
#else
#define	EPIC_RES	SYS_RES_MEMORY
#define	EPIC_RID	PCIR_BASEMEM
#endif

d437 4
a440 3
static int
epic_freebsd_attach(dev)
	device_t dev;
d444 5
d450 1
a450 2
	int unit, error;
	int i, s, rid, tmp;
d452 1
a452 1
	s = splimp ();
d454 3
a456 2
	sc = device_get_softc(dev);
	unit = device_get_unit(dev);
a460 1
	sc->dev = dev;
a468 1
	ifp->if_output = ether_output;
d473 2
a474 8
	ifp->if_baudrate = 10000000;
	ifp->if_snd.ifq_maxlen = TX_RING_SIZE - 1;

	/* Enable ports, memory and busmastering */
	command = pci_read_config(dev, PCIR_COMMAND, 4);
	command |= PCIM_CMD_PORTEN | PCIM_CMD_MEMEN | PCIM_CMD_BUSMASTEREN;
	pci_write_config(dev, PCIR_COMMAND, command, 4);
	command = pci_read_config(dev, PCIR_COMMAND, 4);
d476 1
d478 9
a486 4
	if (!(command & PCIM_CMD_PORTEN)) {
		device_printf(dev, "failed to enable I/O mapping!\n");
		error = ENXIO;
		goto fail;
a487 7
#else
	if (!(command & PCIM_CMD_MEMEN)) {
		device_printf(dev, "failed to enable memory mapping!\n");
		error = ENXIO;
		goto fail;
	}
#endif
d489 4
a492 8
	rid = EPIC_RID;
	sc->res = bus_alloc_resource(dev, EPIC_RES, &rid, 0, ~0, 1,
	    RF_ACTIVE);

	if (sc->res == NULL) {
		device_printf(dev, "couldn't map ports/memory\n");
		error = ENXIO;
		goto fail;
d494 10
a503 14

	sc->sc_st = rman_get_bustag(sc->res);
	sc->sc_sh = rman_get_bushandle(sc->res);

	/* Allocate interrupt */
	rid = 0;
	sc->irq = bus_alloc_resource(dev, SYS_RES_IRQ, &rid, 0, ~0, 1,
	    RF_SHAREABLE | RF_ACTIVE);

	if (sc->irq == NULL) {
		device_printf(dev, "couldn't map interrupt\n");
		bus_release_resource(dev, EPIC_RES, EPIC_RID, sc->res);
		error = ENXIO;
		goto fail;
d506 4
a509 28
	error = bus_setup_intr(dev, sc->irq, INTR_TYPE_NET,
	    epic_intr, sc, &sc->sc_ih);

	if (error) {
		bus_release_resource(dev, SYS_RES_IRQ, 0, sc->irq);
		bus_release_resource(dev, EPIC_RES, EPIC_RID, sc->res);
		device_printf(dev, "couldn't set up irq\n");
		goto fail;
	}

	/* Bring the chip out of low-power mode and reset it. */
	CSR_WRITE_4( sc, GENCTL, GENCTL_SOFT_RESET );
	DELAY(500);

	/* Workaround for Application Note 7-15 */
	for (i=0; i<16; i++) CSR_WRITE_4(sc, TEST1, TEST1_CLOCK_TEST);

	/*
	 * Do ifmedia setup.
	 */
	if (mii_phy_probe(dev, &sc->miibus,
	    epic_ifmedia_upd, epic_ifmedia_sts)) {
		device_printf(dev, "MII without any PHY!?\n");
		bus_teardown_intr(dev, sc->irq, sc->sc_ih);
		bus_release_resource(dev, SYS_RES_IRQ, 0, sc->irq);
		bus_release_resource(dev, EPIC_RES, EPIC_RID, sc->res);
		error = ENXIO;
		goto fail;
d511 1
d514 1
a514 8
	if (epic_common_attach(sc)) {
		device_printf(dev, "memory distribution error\n");
		bus_teardown_intr(dev, sc->irq, sc->sc_ih);
		bus_release_resource(dev, SYS_RES_IRQ, 0, sc->irq);
		bus_release_resource(dev, EPIC_RES, EPIC_RID, sc->res);
		error = ENXIO;
		goto fail;
	}
d516 3
a518 4
	/* Fetch card id */
	sc->cardvend = pci_read_config(sc->dev, PCIR_SUBVEND_0, 2);
	sc->cardid = pci_read_config(sc->dev, PCIR_SUBDEV_0, 2);
	printf("vend/id(%x/%x) ", sc->cardvend, sc->cardid);
d521 3
a523 1
	device_printf(dev, "address %6D,", sc->sc_macaddr, ":");
a534 1
	printf("\n");
d536 7
a542 3
	/* Attach to OS's managers */
	ether_ifattach(ifp, ETHER_BPF_SUPPORTED);
	callout_handle_init(&sc->stat_ch);
d544 38
a581 2
fail:
	splx(s);
d583 2
a584 2
	return(error);
}
d586 2
a587 10
/*
 * Detach driver and free resources
 */
static int
epic_freebsd_detach(dev)
	device_t dev;
{
	struct ifnet *ifp;
	epic_softc_t *sc;
	int s;
d591 6
a596 2
	sc = device_get_softc(dev);
	ifp = &sc->arpcom.ac_if;
d598 2
a599 1
	ether_ifdetach(ifp, ETHER_BPF_SUPPORTED);
d601 3
a603 1
	epic_stop(sc);
d605 3
a607 2
	bus_generic_detach(dev);
	device_delete_child(dev, sc->miibus);
d609 1
a609 3
	bus_teardown_intr(dev, sc->irq, sc->sc_ih);
	bus_release_resource(dev, SYS_RES_IRQ, 0, sc->irq);
	bus_release_resource(dev, EPIC_RES, EPIC_RID, sc->res);
d611 1
a611 1
	free(sc->pool, M_DEVBUF);
d613 1
a613 3
	splx(s);

	return(0);
d616 4
a619 10
#undef	EPIC_RES
#undef	EPIC_RID

/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
EPIC_STATIC void
epic_freebsd_shutdown(dev)
	device_t dev;
a620 4
	epic_softc_t *sc;

	sc = device_get_softc(dev);

d622 1
a623 2
	return;
}
d633 5
a637 5
EPIC_STATIC int
epic_ifioctl(ifp, command, data)
	struct ifnet *ifp;
	u_long command;
	caddr_t data;
a639 2
	struct mii_data	*mii;
	struct ifreq *ifr = (struct ifreq *) data;
d663 1
a663 1
#endif
d686 1
a686 1
#endif /* __FreeBSD__ */
d705 2
a707 1
		epic_stop_activity(sc);	
d709 5
d735 1
d738 2
a739 2
		mii = epic_mii_ptr(sc);
		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);
d741 1
d756 3
a758 3
EPIC_STATIC int
epic_common_attach(sc)
	epic_softc_t *sc;
d765 1
a765 1
	    sizeof(struct epic_tx_desc)*TX_RING_SIZE + PAGE_SIZE;
a786 1
	DELAY(500);
d795 6
a800 1
	/* Set defaults */
a802 6
	sc->miicfg = MIICFG_SMI_ENABLE;
	sc->phyid = EPIC_UNKN_PHY;
	sc->serinst = -1;

	if (sc->cardvend != SMC_VENDORID) 
		printf(EPIC_FORMAT ": unknown card vendor 0x%04x\n", EPIC_ARGS(sc), sc->cardvend);
d809 2
a810 2
 * and queue them for transmit, one by one, until TX ring become full
 * or queue become empty.
d812 2
a813 4
EPIC_STATIC void
epic_ifstart(ifp)
	struct ifnet * ifp;
{
d822 14
d847 11
d903 5
a907 1
			bpf_mtap( EPIC_BPFTAP_ARG(ifp), m0 );
d918 2
a919 1
 * Synopsis: Finish all received frames.
d921 3
a923 3
EPIC_STATIC void
epic_rx_done(sc)
	epic_softc_t *sc;
d965 2
a966 5

		/*
		 * First mbuf in packet holds the ethernet and
		 * packet headers.
		 */
a970 1
#if !defined(__FreeBSD__)
d974 5
a978 1
			bpf_mtap( EPIC_BPFTAP_ARG(&sc->sc_if), m );
a979 1
#endif /* !__FreeBSD__ */
d1001 3
a1003 3
EPIC_STATIC void
epic_tx_done(sc)
	epic_softc_t *sc;
d1041 2
d1044 3
a1046 3
EPIC_STATIC EPIC_INTR_RET_TYPE
epic_intr(arg)
    void *arg;
d1054 1
d1069 2
d1085 40
d1138 2
d1183 2
d1186 3
a1188 3
EPIC_STATIC void
epic_ifwatchdog(ifp)
	struct ifnet *ifp;
d1203 3
a1205 1

d1222 4
a1225 6
/*
 * Set media options.
 */
EPIC_STATIC int
epic_ifmedia_upd(ifp)
	struct ifnet *ifp;
d1227 1
a1227 7
	epic_softc_t *sc;
	struct mii_data *mii;
	struct ifmedia *ifm;
	struct mii_softc *miisc;
	int cfg, media;

	sc = ifp->if_softc;
d1229 2
a1230 1
	mii = epic_mii_ptr(sc);
d1232 1
a1232 5
	ifm = &mii->mii_media;
	media = ifm->ifm_cur->ifm_media;

	/* Do not do anything if interface is not up */
	if(!(ifp->if_flags & IFF_UP))
d1235 3
a1237 24
	/*
	 * Lookup current selected PHY
	 */
	if (IFM_INST(media) == sc->serinst) {
		sc->phyid = EPIC_SERIAL;
		sc->physc = NULL;
	} else {
		/* If we're not selecting serial interface, select MII mode */
		sc->miicfg &= ~MIICFG_SERIAL_ENABLE;
		CSR_WRITE_4(sc, MIICFG, sc->miicfg);

		dprintf((EPIC_FORMAT ": MII selected\n", EPIC_ARGS(sc)));

		/* Default to unknown PHY */
		sc->phyid = EPIC_UNKN_PHY;

		/* Lookup selected PHY */
		for (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;
		     miisc = LIST_NEXT(miisc, mii_list)) {
			if (IFM_INST(media) == miisc->mii_inst) {
				sc->physc = miisc;
				break;
			}
		}
d1239 1
a1239 81
		/* Identify selected PHY */
		if (sc->physc) {
			int id1, id2, model, oui;

			id1 = PHY_READ(sc->physc, MII_PHYIDR1);
			id2 = PHY_READ(sc->physc, MII_PHYIDR2);

			oui = MII_OUI(id1, id2);
			model = MII_MODEL(id2);
			switch (oui) {
			case MII_OUI_QUALSEMI:
				if (model == MII_MODEL_QUALSEMI_QS6612)
					sc->phyid = EPIC_QS6612_PHY;
				break;
			case MII_OUI_xxALTIMA:
				if (model == MII_MODEL_xxALTIMA_AC101)
					sc->phyid = EPIC_AC101_PHY;
				break;
			case MII_OUI_xxLEVEL1:
				if (model == MII_MODEL_xxLEVEL1_LXT970)
					sc->phyid = EPIC_LXT970_PHY;
				break;
			}
		}
	}

	/*
	 * Do PHY specific card setup
	 */

	/* Call this, to isolate all not selected PHYs and
	 * set up selected
	 */
	mii_mediachg(mii);

	/* Do our own setup */
	switch (sc->phyid) {
	case EPIC_QS6612_PHY:
		break;
	case EPIC_AC101_PHY:
		/* We have to powerup fiber tranceivers */
		if (IFM_SUBTYPE(media) == IFM_100_FX)
			sc->miicfg |= MIICFG_694_ENABLE;
		else
			sc->miicfg &= ~MIICFG_694_ENABLE;
		CSR_WRITE_4(sc, MIICFG, sc->miicfg);
	
		break;
	case EPIC_LXT970_PHY:
		/* We have to powerup fiber tranceivers */
		cfg = PHY_READ(sc->physc, MII_LXTPHY_CONFIG);
		if (IFM_SUBTYPE(media) == IFM_100_FX)
			cfg |= CONFIG_LEDC1 | CONFIG_LEDC0;
		else
			cfg &= ~(CONFIG_LEDC1 | CONFIG_LEDC0);
		PHY_WRITE(sc->physc, MII_LXTPHY_CONFIG, cfg);

		break;
	case EPIC_SERIAL:
		/* Select serial PHY, (10base2/BNC usually) */
		sc->miicfg |= MIICFG_694_ENABLE | MIICFG_SERIAL_ENABLE;
		CSR_WRITE_4(sc, MIICFG, sc->miicfg);

		/* There is no driver to fill this */
		mii->mii_media_active = media;
		mii->mii_media_status = 0;

		/* We need to call this manualy as i wasn't called
		 * in mii_mediachg()
		 */
		epic_miibus_statchg(&sc->dev);

		dprintf((EPIC_FORMAT ": SERIAL selected\n", EPIC_ARGS(sc)));

		break;
	default:
		printf(EPIC_FORMAT ": ERROR! Unknown PHY selected\n", EPIC_ARGS(sc));
		return (EINVAL);
	}

	return(0);
d1242 4
a1245 7
/*
 * Report current media status.
 */
EPIC_STATIC void
epic_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
d1247 3
a1249 12
	epic_softc_t *sc;
	struct mii_data *mii;
	struct ifmedia *ifm;

	sc = ifp->if_softc;
	mii = epic_mii_ptr(sc);
	ifm = &mii->mii_media;

	/* Nothing should be selected if interface is down */
	if(!(ifp->if_flags & IFF_UP)) {
		ifmr->ifm_active = IFM_NONE;
		ifmr->ifm_status = 0;
d1251 1
a1252 23
	}

	/* Call underlying pollstat, if not serial PHY */
	if (sc->phyid != EPIC_SERIAL)
		mii_pollstat(mii);

	/* Simply copy media info */
	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;

	return;
}

/*
 * Callback routine, called on media change.
 */
EPIC_STATIC void
epic_miibus_statchg(dev)
	struct device* dev;
{
	epic_softc_t *sc;
	struct mii_data *mii;
	int media;
d1254 1
a1254 3
	sc = epic_dev_ptr(dev);
	mii = epic_mii_ptr(sc);
	media = mii->mii_media_active;
d1256 2
a1257 1
	sc->txcon &= ~(TXCON_LOOPBACK_MODE | TXCON_FULL_DUPLEX);
d1259 2
a1260 5
	/* If we are in full-duplex mode or loopback operation,
	 * we need to decouple receiver and transmitter.
	 */
	if (IFM_OPTIONS(media) & (IFM_FDX | IFM_LOOP))
 		sc->txcon |= TXCON_FULL_DUPLEX;
d1262 4
a1265 9
	/* On some cards we need manualy set fullduplex led */
	if (sc->cardid == SMC9432FTX ||
	    sc->cardid == SMC9432FTX_SC) {
		if (IFM_OPTIONS(media) & IFM_FDX) 
			sc->miicfg |= MIICFG_694_ENABLE;
		else
			sc->miicfg &= ~MIICFG_694_ENABLE;

		CSR_WRITE_4(sc, MIICFG, sc->miicfg);
d1268 7
a1274 8
	/* Update baudrate */
	if (IFM_SUBTYPE(media) == IFM_100_TX ||
	    IFM_SUBTYPE(media) == IFM_100_FX)
		sc->sc_if.if_baudrate = 100000000;
	else
		sc->sc_if.if_baudrate = 10000000;

	epic_set_tx_mode(sc);
a1275 31
	return;
}

EPIC_STATIC void epic_miibus_mediainit(dev)
	struct device* dev;
{
        epic_softc_t *sc;
        struct mii_data *mii;
	struct ifmedia *ifm;
	int media;

	sc = epic_dev_ptr(dev);
	mii = epic_mii_ptr(sc);
	ifm = &mii->mii_media;

	/* Add Serial Media Interface if present, this applies to
	 * SMC9432BTX serie
	 */
	if(CSR_READ_4(sc, MIICFG) & MIICFG_PHY_PRESENT) {
		/* Store its instance */
		sc->serinst = mii->mii_instance++;

		/* Add as 10base2/BNC media */
		media = IFM_MAKEWORD(IFM_ETHER, IFM_10_2, 0, sc->serinst);
		ifmedia_add(ifm, media, 0, NULL);

		/* Report to user */
		printf(EPIC_FORMAT ": serial PHY detected (10Base2/BNC)\n",EPIC_ARGS(sc));
	}

	return;
d1277 1
a1277 1

d1280 3
a1282 1
 * Reset chip, allocate rings, and update media.
d1284 3
a1286 3
EPIC_STATIC int
epic_init(sc)
	epic_softc_t *sc;
a1288 1
	struct mii_data *mii;
a1292 6
	/* If interface is already running, then we need not do anything */ 
	if (ifp->if_flags & IFF_RUNNING) {
		splx(s);
		return 0;
	}

d1336 4
a1339 6
		INTSTAT_RCC  | /* INTSTAT_RQE | INTSTAT_OVW | INTSTAT_RXE | */
		/* INTSTAT_TXC | */ INTSTAT_TCC | INTSTAT_TQE | INTSTAT_TXU |
		INTSTAT_FATAL);

	/* Acknowledge all pending interrupts */
	CSR_WRITE_4(sc, INTSTAT, CSR_READ_4(sc, INTSTAT));
d1346 3
d1359 55
a1413 6
	/* Reset all PHYs */
	mii = epic_mii_ptr(sc);
        if (mii->mii_instance) {
		struct mii_softc	*miisc;
		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
			mii_phy_reset(miisc);
d1416 2
a1417 2
	/* Set appropriate media */
	epic_ifmedia_upd(ifp);
d1419 2
a1420 1
	splx(s);
d1422 14
a1435 1
	timeout_add(&sc->sc_tmo, hz);
d1437 5
a1441 1
	return 0;
d1445 2
a1446 2
 * Synopsis: calculate and set Rx mode. Chip must be in idle state to
 * access RXCON.
d1448 3
a1450 3
EPIC_STATIC void
epic_set_rx_mode(sc)
	epic_softc_t *sc;
d1452 4
a1455 2
	u_int32_t 		flags = sc->sc_if.if_flags;
        u_int32_t 		rxcon = RXCON_DEFAULT;
d1457 1
a1457 1
	rxcon |= (flags & IFF_PROMISC) ? RXCON_PROMISCUOUS_MODE : 0;
d1459 74
a1532 1
	CSR_WRITE_4( sc, RXCON, rxcon );
d1538 4
a1541 2
 * Synopsis: Set transmit control register. Chip must be in idle state to
 * access TXCON.
d1543 77
a1619 3
EPIC_STATIC void
epic_set_tx_mode(sc)
	epic_softc_t *sc;
a1620 2
	if (sc->txcon & TXCON_EARLY_TRANSMIT_ENABLE)
		CSR_WRITE_4 (sc, ETXTHR, sc->tx_threshold);
d1622 4
a1625 1
	CSR_WRITE_4 (sc, TXCON, sc->txcon);
d1636 3
a1638 3
EPIC_STATIC void
epic_set_mc_table(sc)
	epic_softc_t *sc;
d1656 3
a1658 3
EPIC_STATIC void
epic_start_activity(sc)
	epic_softc_t *sc;
d1660 5
a1664 5
	/* Start rx process */
	CSR_WRITE_4(sc, COMMAND,
		COMMAND_RXQUEUED | COMMAND_START_RX |
		(sc->pending_txs?COMMAND_TXQUEUED:0));
	dprintf((EPIC_FORMAT ": activity started\n",EPIC_ARGS(sc)));
d1671 3
a1673 3
EPIC_STATIC void
epic_stop_activity(sc)
    epic_softc_t *sc;
d1765 2
d1768 3
a1770 3
EPIC_STATIC void
epic_stop(sc)
	epic_softc_t *sc;
a1773 2
	timeout_del(&sc->sc_tmo);

d1805 3
a1807 3
EPIC_STATIC void
epic_free_rings(sc)
	epic_softc_t *sc;
d1841 2
a1842 4
EPIC_STATIC int
epic_init_rings(sc)
	epic_softc_t *sc;
{
d1891 3
a1893 4
EPIC_STATIC void
epic_write_eepromreg(sc, val)
	epic_softc_t *sc;
	u_int8_t val;
d1905 3
a1907 3
EPIC_STATIC u_int8_t
epic_read_eepromreg(sc)
	epic_softc_t *sc;
d1909 1
a1909 1
	return CSR_READ_1(sc, EECTL);
d1912 4
a1915 4
EPIC_STATIC u_int8_t
epic_eeprom_clock(sc, val)
	epic_softc_t *sc;
	u_int8_t val;
d1924 4
a1927 4
EPIC_STATIC void
epic_output_eepromw(sc, val)
	epic_softc_t *sc;
	u_int16_t val;
d1936 3
a1938 3
EPIC_STATIC u_int16_t
epic_input_eepromw(sc)
	epic_softc_t *sc;
d1953 4
a1956 4
EPIC_STATIC int
epic_read_eeprom(sc, loc)
	epic_softc_t *sc;
	u_int16_t loc;
d1977 4
a1980 7
/*
 * Here goes MII read/write routines
 */
EPIC_STATIC int
epic_read_phy_reg(sc, phy, reg)
	epic_softc_t *sc;
	int phy, reg;
d1984 1
a1984 1
	CSR_WRITE_4 (sc, MIICTL, ((reg << 4) | (phy << 9) | 0x01));
d1987 1
a1987 1
		if( !(CSR_READ_4(sc, MIICTL) & 0x01) ) break;
d1991 1
a1991 1
	return (CSR_READ_4 (sc, MIIDATA));
d1994 5
a1998 4
EPIC_STATIC void
epic_write_phy_reg(sc, phy, reg, val)
	epic_softc_t *sc;
	int phy, reg, val;
d2002 2
a2003 2
	CSR_WRITE_4 (sc, MIIDATA, val);
	CSR_WRITE_4 (sc, MIICTL, ((reg << 4) | (phy << 9) | 0x02));
d2005 2
a2006 2
	for(i=0;i<0x100;i++) {
		if( !(CSR_READ_4(sc, MIICTL) & 0x02) ) break;
d2013 3
a2015 4
EPIC_STATIC int
epic_miibus_readreg(dev, phy, reg)
	struct device* dev;
	int phy, reg;
d2017 30
a2046 33
	epic_softc_t *sc;

	sc = epic_dev_ptr(dev);

	return (PHY_READ_2(sc, phy, reg));
}

EPIC_STATIC EPIC_MIIBUS_WRITEREG_RET_TYPE
epic_miibus_writereg(dev, phy, reg, data)
	struct device* dev;
	int phy, reg, data;
{
	epic_softc_t *sc;

	sc = epic_dev_ptr(dev);

	PHY_WRITE_2(sc, phy, reg, data);

#if !defined(__OpenBSD__)
	return (0);
#endif
}

EPIC_STATIC void
epic_tick(vsc)
	void *vsc;
{
	epic_softc_t *sc = vsc;
	struct mii_data *mii;

	mii = epic_mii_ptr(sc);
	if (sc->phyid != EPIC_SERIAL)
		mii_tick(mii);
d2048 1
@


1.9.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.9.2.2 2001/05/14 22:25:47 niklas Exp $	*/
d246 1
a246 1
		    &sc->sc_st, &sc->sc_sh, NULL, &iosize, 0)) {
d252 1
a252 1
		    &sc->sc_st, &sc->sc_sh, NULL, &iosize, 0)) {
d450 1
a450 2
	IFQ_SET_MAXLEN(&ifp->if_snd, TX_RING_SIZE - 1);
	IFQ_SET_READY(&ifp->if_snd);
d822 1
a822 1
		IFQ_DEQUEUE( &ifp->if_snd, m0 );
d893 1
d934 1
d946 4
d951 1
a951 1
		ether_input_mbuf(&sc->sc_if, m);
d1041 1
a1041 1
		!IFQ_IS_EMPTY( &sc->sc_if.if_snd ))
d1131 1
a1131 1
	if( !IFQ_IS_EMPTY( &ifp->if_snd ) ) epic_ifstart( ifp );
@


1.9.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.9.2.3 2001/07/04 10:42:25 niklas Exp $	*/
d119 1
d274 2
a275 1
	if( pci_intr_map(pa, &ih)) {
d1045 1
a1045 1
		printf(EPIC_FORMAT ": PCI fatal error occurred (%s%s%s%s)\n",
@


1.9.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d118 1
a118 1
#include <uvm/uvm_extern.h>
@


1.9.2.6
log
@Merge in -current from roughly a week ago
@
text
@d146 35
a180 35
EPIC_STATIC int epic_ifioctl(register struct ifnet *, u_long, caddr_t);
EPIC_STATIC EPIC_INTR_RET_TYPE epic_intr(void *);
EPIC_STATIC int epic_common_attach(epic_softc_t *);
EPIC_STATIC void epic_ifstart(struct ifnet *);
EPIC_STATIC void epic_ifwatchdog(struct ifnet *);
EPIC_STATIC int epic_init(epic_softc_t *);
EPIC_STATIC void epic_stop(epic_softc_t *);
EPIC_STATIC void epic_rx_done(epic_softc_t *);
EPIC_STATIC void epic_tx_done(epic_softc_t *);
EPIC_STATIC int epic_init_rings(epic_softc_t *);
EPIC_STATIC void epic_free_rings(epic_softc_t *);
EPIC_STATIC void epic_stop_activity(epic_softc_t *);
EPIC_STATIC void epic_start_activity(epic_softc_t *);
EPIC_STATIC void epic_set_rx_mode(epic_softc_t *);
EPIC_STATIC void epic_set_tx_mode(epic_softc_t *);
EPIC_STATIC void epic_set_mc_table(epic_softc_t *);
EPIC_STATIC int epic_read_eeprom(epic_softc_t *,u_int16_t);
EPIC_STATIC void epic_output_eepromw(epic_softc_t *, u_int16_t);
EPIC_STATIC u_int16_t epic_input_eepromw(epic_softc_t *);
EPIC_STATIC u_int8_t epic_eeprom_clock(epic_softc_t *,u_int8_t);
EPIC_STATIC void epic_write_eepromreg(epic_softc_t *,u_int8_t);
EPIC_STATIC u_int8_t epic_read_eepromreg(epic_softc_t *);

EPIC_STATIC int epic_read_phy_reg(epic_softc_t *, int, int);
EPIC_STATIC void epic_write_phy_reg(epic_softc_t *, int, int, int);

EPIC_STATIC int epic_miibus_readreg(struct device*, int, int);
EPIC_STATIC EPIC_MIIBUS_WRITEREG_RET_TYPE epic_miibus_writereg(struct device*, int, int, int);
EPIC_STATIC void epic_miibus_statchg(struct device *);
EPIC_STATIC void epic_miibus_mediainit(struct device *);


EPIC_STATIC int epic_ifmedia_upd(struct ifnet *);
EPIC_STATIC void epic_ifmedia_sts(struct ifnet *, struct ifmediareq *);
EPIC_STATIC void epic_tick(void *);
d189 3
a191 3
int epic_openbsd_probe(struct device *,void *,void *);
void epic_openbsd_attach(struct device *, struct device *, void *);
void epic_openbsd_shutdown(void *);
d326 5
a330 5
static int epic_freebsd_probe(device_t);
static int epic_freebsd_attach(device_t);
static void epic_freebsd_shutdown(device_t);
static int epic_freebsd_detach(device_t);
static struct epic_type *epic_devtype(device_t);
@


1.9.2.7
log
@Sync the SMP branch with 3.3
@
text
@d208 2
d211 4
a214 4
	if (PCI_VENDOR(pa->pa_id) == SMC_VENDORID &&
	    PCI_PRODUCT(pa->pa_id) == SMC_DEVICEID_83C170)
		return (1);
	return (0);
a263 1
	IFQ_SET_READY(&ifp->if_snd);
d1121 1
a1121 1
		printf("seems we can continue normally\n");
d1218 1
a1218 1
		/* We have to powerup fiber transceivers */
d1227 1
a1227 1
		/* We have to powerup fiber transceivers */
@


1.9.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a680 1
		break;
@


1.8
log
@remove static's
@
text
@d1 2
a2 2
/*	$OpenBSD: if_tx.c,v 1.7 1999/06/29 17:13:40 jason Exp $	*/
/*	$FreeBSD: if_tx.c,v 1.27 1999/05/10 00:20:46 peter Exp $	*/
a27 3
 *
 *	$FreeBSD: if_tx.c,v 1.21 1999/03/09 17:30:12 andreas Exp $
 *
a36 2
 *	Deal with bus mastering, i.e. i realy don't know what to do with
 *	    it and how it can improve performance.
a247 1
	bus_space_tag_t iot = pa->pa_iot;
d251 1
d256 12
d272 15
a286 1
	if( bus_space_map(iot, iobase, iosize, 0, &sc->sc_sh)) {
d290 2
a291 1
	sc->sc_st = iot;
d449 1
d478 11
d495 11
d513 1
d516 4
d786 1
a786 1
	CSR_WRITE_4( sc, GENCTL, 0x0000 );
@


1.7
log
@sync with freebsd:
comment out some debugging code, rcsid changes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tx.c,v 1.6 1999/03/16 04:26:39 jason Exp $	*/
d153 28
a180 28
static int epic_ifioctl __P((register struct ifnet *, EPIC_IFIOCTL_CMD_TYPE, caddr_t));
static EPIC_INTR_RET_TYPE epic_intr __P((void *));
static int epic_common_attach __P((epic_softc_t *));
static void epic_ifstart __P((struct ifnet *));
static void epic_ifwatchdog __P((struct ifnet *));
static int epic_init __P((epic_softc_t *));
static void epic_stop __P((epic_softc_t *));
static __inline void epic_rx_done __P((epic_softc_t *));
static __inline void epic_tx_done __P((epic_softc_t *));
static int epic_init_rings __P((epic_softc_t *));
static void epic_free_rings __P((epic_softc_t *));
static void epic_stop_activity __P((epic_softc_t *));
static void epic_start_activity __P((epic_softc_t *));
static void epic_set_rx_mode __P((epic_softc_t *));
static void epic_set_tx_mode __P((epic_softc_t *));
static void epic_set_mc_table __P((epic_softc_t *));
static void epic_set_media_speed __P((epic_softc_t *));
static void epic_init_phy __P((epic_softc_t *));
static void epic_dump_state __P((epic_softc_t *));
static int epic_autoneg __P((epic_softc_t *));
static int epic_read_eeprom __P((epic_softc_t *,u_int16_t));
static void epic_output_eepromw __P((epic_softc_t *, u_int16_t));
static u_int16_t epic_input_eepromw __P((epic_softc_t *));
static u_int8_t epic_eeprom_clock __P((epic_softc_t *,u_int8_t));
static void epic_write_eepromreg __P((epic_softc_t *,u_int8_t));
static u_int8_t epic_read_eepromreg __P((epic_softc_t *));
static u_int16_t epic_read_phy_register __P((epic_softc_t *, u_int16_t));
static void epic_write_phy_register __P((epic_softc_t *, u_int16_t, u_int16_t));
d186 2
a187 2
static int epic_ifmedia_change __P((struct ifnet *));
static void epic_ifmedia_status __P((struct ifnet *, struct ifmediareq *));
d213 3
a215 3
static int epic_openbsd_probe __P((struct device *,void *,void *));
static void epic_openbsd_attach __P((struct device *, struct device *, void *));
static void epic_shutdown __P((void *));
d225 1
a225 1
static int 
d241 1
a241 1
static void
d369 1
a369 1
static void
d379 3
a381 3
static const char* epic_freebsd_probe __P((pcici_t, pcidi_t));
static void epic_freebsd_attach __P((pcici_t, int));
static void epic_shutdown __P((int, void *));
d384 2
a385 2
static u_long epic_pci_count;
static struct pci_device txdevice = { 
d397 1
a397 1
static const char*
d415 1
a415 1
static void
d566 1
a566 1
static void
d583 1
a583 1
static int
d706 1
a706 1
static int
d762 1
a762 1
static void
d871 1
a871 1
static __inline void
d951 1
a951 1
static __inline void
d994 1
a994 1
static EPIC_INTR_RET_TYPE
d1136 1
a1136 1
static void
d1173 1
a1173 1
static int
d1192 1
a1192 1
static void
d1234 1
a1234 1
static int 
d1317 1
a1317 1
static void
d1351 1
a1351 1
static void
d1398 1
a1398 1
static void
d1493 1
a1493 1
static int 
d1567 1
a1567 1
static void
d1586 1
a1586 1
static void
d1606 1
a1606 1
static void
d1621 1
a1621 1
static void
d1718 1
a1718 1
static void
d1755 1
a1755 1
static void
d1791 1
a1791 1
static int
d1841 1
a1841 1
static void epic_write_eepromreg __P((
d1855 1
a1855 1
static u_int8_t
d1862 1
a1862 1
static u_int8_t
d1874 1
a1874 1
static void
d1886 1
a1886 1
static u_int16_t
d1903 1
a1903 1
static int
d1927 1
a1927 1
static u_int16_t
d1944 1
a1944 1
static void
d1963 1
a1963 1
static void
@


1.6
log
@merge with freesbd:
o put media types in a structure for ifmedia adding
o make sure ifp->if_snd.ifq_maxlen is initialized
o add workaround for app note 7-15
o more checks for IFF_UP
o use DELAY() instead of counters
@
text
@d1 2
a2 2
/*	$OpenBSD: if_tx.c,v 1.5 1999/03/10 20:04:13 jason Exp $	*/
/*	$FreeBSD: if_tx.c,v 1.22 1999/03/14 08:30:23 semenu Exp $ */
d181 1
d183 1
d390 2
a391 1
	NULL };
d394 1
a394 1
DATA_SET ( pcidevice_set, txdevice );
d1331 1
d1333 2
a1334 1
epic_dump_phy_regs(epic_softc_t *sc) {
d1346 1
a1997 6
#if 0
static void epic_kldinit (void * a) {
	pci_register_lkm (&txdevice, 0);
}
PSEUDO_SET(epic_kldinit,if_tx);
#endif
@


1.5
log
@fix freebsd id's
Merge with FreeBSD: longer delay when accessing mii, type fixups
@
text
@d1 2
a2 2
/*	$OpenBSD: if_tx.c,v 1.4 1999/02/26 17:05:55 jason Exp $	*/
/*	$FreeBSD: if_tx.c,v 1.21 1999/03/09 17:30:12 andreas Exp $ */
d181 1
d188 16
d346 4
a349 8
	ifmedia_add(&sc->ifmedia,IFM_ETHER|IFM_10_T,0,NULL);
	ifmedia_add(&sc->ifmedia,IFM_ETHER|IFM_10_T|IFM_LOOP,0,NULL);
	ifmedia_add(&sc->ifmedia,IFM_ETHER|IFM_10_T|IFM_FDX,0,NULL);
	ifmedia_add(&sc->ifmedia,IFM_ETHER|IFM_100_TX,0,NULL);
	ifmedia_add(&sc->ifmedia,IFM_ETHER|IFM_100_TX|IFM_LOOP,0,NULL);
	ifmedia_add(&sc->ifmedia,IFM_ETHER|IFM_100_TX|IFM_FDX,0,NULL);
	ifmedia_add(&sc->ifmedia,IFM_ETHER|IFM_AUTO,0,NULL);
	ifmedia_add(&sc->ifmedia,IFM_ETHER|IFM_LOOP,0,NULL);
d448 1
d529 4
a532 8
	ifmedia_add(&sc->ifmedia,IFM_ETHER|IFM_10_T,0,NULL);
	ifmedia_add(&sc->ifmedia,IFM_ETHER|IFM_10_T|IFM_LOOP,0,NULL);
	ifmedia_add(&sc->ifmedia,IFM_ETHER|IFM_10_T|IFM_FDX,0,NULL);
	ifmedia_add(&sc->ifmedia,IFM_ETHER|IFM_100_TX,0,NULL);
	ifmedia_add(&sc->ifmedia,IFM_ETHER|IFM_100_TX|IFM_LOOP,0,NULL);
	ifmedia_add(&sc->ifmedia,IFM_ETHER|IFM_100_TX|IFM_FDX,0,NULL);
	ifmedia_add(&sc->ifmedia,IFM_ETHER|IFM_AUTO,0,NULL);
	ifmedia_add(&sc->ifmedia,IFM_ETHER|IFM_LOOP,0,NULL);
d652 2
d661 1
d735 2
a736 2
	/* Magic?!  If we don't set this bit the MII interface won't work. */
	CSR_WRITE_4( sc, TEST1, 0x0008 );
d769 1
d780 1
d801 1
a801 1
			dprintf((EPIC_FORMAT ": mbuf not freed in ifstart, up and down interface plase\n",EPIC_ARGS(sc)));
d946 1
a946 1
 * are pending or descriptro is not transmitted yet.
d1038 1
a1040 1
		    CSR_WRITE_4( sc, TXCON, sc->txcon );
d1043 1
a1045 1
		    CSR_WRITE_4( sc, TXCON, sc->txcon );
d1053 4
d1109 1
a1113 3

		/* Restart the transmit process. */
		/* CSR_WRITE_4(sc, COMMAND, COMMAND_TXUGO|COMMAND_TXQUEUED); */
d1179 4
d1184 1
d1198 3
d1216 7
a1222 3
	ifmr->ifm_active |= (bmcr&BMCR_100MBPS)?IFM_100_TX:IFM_10_T;
	ifmr->ifm_active |= (bmcr&BMCR_FULL_DUPLEX)?IFM_FDX:0;
	ifmr->ifm_active |= ((CSR_READ_4(sc,TXCON)&TXCON_LOOPBACK_MODE)==TXCON_LOOPBACK_MODE_INT)?IFM_LOOP:0;
d1236 1
a1236 1
	int s;
d1240 2
a1241 1
	/* Soft reset the chip */
d1244 5
a1248 2
	/* Reset takes 15 pci ticks which depends on processor speed */
	DELAY(1);
d1253 2
a1254 2
	/* ?????? */
	CSR_WRITE_4( sc, TEST1, 0x0008);
a1277 4
	/* Set media speed mode */
	epic_init_phy( sc );
	epic_set_media_speed( sc );

d1293 3
d1311 2
a1312 1
 * Synopsis: calculate and set Rx mode
d1328 14
d1351 11
a1361 4
	/* Reset PHY */
	PHY_WRITE_2( sc, DP83840_BMCR, BMCR_RESET );
	for(i=0;i<0x100000;i++)
		if( !(PHY_READ_2( sc, DP83840_BMCR ) & BMCR_RESET) ) break;
d1363 2
a1364 2
	if( PHY_READ_2( sc, DP83840_BMCR ) & BMCR_RESET )
		printf(EPIC_FORMAT ": WARNING! cannot reset PHY\n",EPIC_ARGS(sc));
d1367 9
a1375 5
	case QS6612_OUI:
		/* Init QS6612 and EPIC to generate interrupt when AN complete*/
		CSR_WRITE_4( sc, NVCTL, NVCTL_GP1_OUTPUT_ENABLE );
		PHY_READ_2( sc, QS6612_INTSTAT );
		PHY_WRITE_2( sc, QS6612_INTMASK, INTMASK_THUNDERLAN | INTSTAT_AN_COMPLETE | INTSTAT_LINK_STATUS );
d1378 3
a1380 1
		PHY_WRITE_2( sc, QS6612_MCTL, PHY_READ_2( sc,QS6612_MCTL ) | MCTL_BTEXT );
d1382 1
d1390 1
a1390 1
 * ifmedia structure.
a1396 1

d1399 3
d1403 1
d1405 4
d1410 13
a1422 2
		media = (IFM_SUBTYPE(tgtmedia)==IFM_100_TX) ? BMCR_100MBPS : 0;
		media|= (tgtmedia&IFM_FDX) ? BMCR_FULL_DUPLEX : 0;
a1427 7

		if( tgtmedia & IFM_FDX ) sc->txcon |= TXCON_FULL_DUPLEX;
		else sc->txcon &= ~TXCON_FULL_DUPLEX;
		if( tgtmedia & IFM_LOOP ) sc->txcon |= TXCON_LOOPBACK_MODE_INT;
		else sc->txcon &= ~TXCON_LOOPBACK_MODE_INT;
		
		CSR_WRITE_4( sc, TXCON, sc->txcon );
d1434 2
a1435 1
		media = (ifp->if_flags & IFF_LINK2) ? BMCR_100MBPS : 0;
d1456 3
a1458 2
		PHY_WRITE_2( sc, DP83840_BMCR,
			BMCR_AUTONEGOTIATION | BMCR_RESTART_AUTONEG );
d1476 2
d1598 1
a1598 1
 * Synopsis: Start receive process and transmit, if need
d1604 5
a1608 2
	/* Start rx process */
	CSR_WRITE_4( sc, COMMAND, COMMAND_RXQUEUED | COMMAND_START_RX | (sc->pending_txs?COMMAND_TXQUEUED:0));
a1620 3
    /* Turn it to loopback mode */	
    CSR_WRITE_4( sc, TXCON, TXCON_SLOT_TIME|TXCON_LOOPBACK_MODE_INT );

d1624 2
a1625 2
    /* Wait only Rx DMA */
    dprintf((EPIC_FORMAT ": waiting Rx DMA to stop\n",EPIC_ARGS(sc)));
d1627 2
a1628 1
	if( (CSR_READ_4(sc,INTSTAT) & INTSTAT_RXIDLE) == INTSTAT_RXIDLE )
d1634 4
a1637 1
	printf(EPIC_FORMAT ": can't stop RX DMA\n",EPIC_ARGS(sc));
d1639 8
a1646 1
    /* May need to queue one more packet if TQE */
d1648 6
a1653 1
       !(CSR_READ_4( sc, INTSTAT ) & INTSTAT_TXIDLE) ){
d1656 26
a1681 5
	sc->tx_desc[sc->cur_tx].bufaddr = vtophys( sc );
	sc->tx_desc[sc->cur_tx].buflength = ETHER_MIN_LEN-ETHER_CRC_LEN;
	sc->tx_desc[sc->cur_tx].control = 0x14;
	sc->tx_desc[sc->cur_tx].txlength = ETHER_MIN_LEN-ETHER_CRC_LEN;
	sc->tx_desc[sc->cur_tx].status = 0x8000;
d1683 3
a1685 1
	sc->pending_txs++;
d1687 2
a1688 1
	CSR_WRITE_4( sc, COMMAND, COMMAND_TXQUEUED );
d1690 1
d1692 2
a1693 4
	/* Wait TX DMA to stop */
	for(i=0;i<0x1000;i++) {
	    if( (CSR_READ_4(sc,INTSTAT)&INTSTAT_TXIDLE) == INTSTAT_TXIDLE ) {
		sc->pending_txs--;
a1694 1
	    }
d1700 3
d1704 1
a1704 3
	/* Restore old TX state */
	CSR_WRITE_4( sc, TXCON, sc->txcon );
    }
d1731 4
a1734 1
	DELAY(10);
d1843 1
a1843 1
	for( i=0;i<0xFF; i++)
d1930 4
a1933 1
	for( i=0;i<0x100000;i++) if( !(CSR_READ_4( sc, MIICTL )&1) ) break;
d1949 4
a1952 1
	for( i=0;i<0x100000;i++) if( !(CSR_READ_4( sc, MIICTL )&2) ) break;
d1992 6
@


1.4
log
@compensate for the fact that the check for ownership of a unicast packet
has moved to ether_input()
@
text
@d1 2
a2 1
/*	$OpenBSD: if_tx.c,v 1.3 1998/10/10 04:30:09 jason Exp $	*/
d29 1
a29 1
 *	$Id: if_tx.c,v 1.3 1998/10/10 04:30:09 jason Exp $
d142 3
d146 1
d364 1
a364 1
static char* epic_freebsd_probe __P((pcici_t, pcidi_t));
d381 1
a381 1
static char*
d411 1
a411 2
	int i,k,s,tmp;
	u_int32_t pool;
d654 1
a654 1
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
d1812 1
a1812 1
	for( i=0;i<0x1000;i++) if( !(CSR_READ_4( sc, MIICTL )&1) ) break;
d1828 1
a1828 1
	for( i=0;i<0x1000;i++) if( !(CSR_READ_4( sc, MIICTL )&2) ) break;
d1857 2
a1858 1
		printf("desc%d: %4d 0x%04x, 0x%08x, 0x%04x %4d, 0x%08x, mbuf: 0x%08x\n",
d1861 1
a1861 1
			tdesc->bufaddr,
d1863 2
a1864 2
			tdesc->next,
			sc->tx_buffer[j].mbuf
@


1.3
log
@add OpenBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d28 1
a28 1
 *	$Id: if_tx.c,v 1.2 1998/09/22 21:54:55 jason Exp $
d907 1
a907 8

		/* Accept only our packets, broadcasts and multicasts */
		if( (eh->ether_dhost[0] & 1) == 0 &&
		    bcmp(eh->ether_dhost,sc->sc_macaddr,ETHER_ADDR_LEN)){
			m_freem(m);
			continue;
		}
#endif
@


1.2
log
@Updated driver from Ustimenko Semen <semen@@iclub.nsu.ru>:
o Cleaned up ifmedia support
o Improved ring & mbuf handling
@
text
@d1 2
d28 1
a28 1
 *	$Id: if_tx.c,v 1.1 1998/09/21 05:24:54 jason Exp $
@


1.1
log
@SMC 83C170 EPIC support from; Semen Ustimenko (semen@@iclub.nsu.ru)
This is the chip found on the SMC EtherPower II 10/100 boards.
@
text
@d26 1
a26 1
 *	$Id: if_tx.c,v 1.31 1998/06/05 13:23:45 galv Exp $
d33 2
d36 1
a36 1
 * TODO:
d230 4
a233 1
	int i, tmp;
d746 3
a748 1
	struct mbuf *m,*m0;
d750 1
a750 5
#if defined(EPIC_DEBUG)
	if( ifp->if_flags & IFF_DEBUG ) epic_dump_state(sc);
#endif
	/* If no link is established,   */
	/* simply free all mbufs in queue */
d785 5
a789 5
		flist->numfrags = 0;
		for(m=m0;(NULL!=m)&&(flist->numfrags<63);m=m->m_next) {
			flist->frag[flist->numfrags].fraglen = m->m_len; 
			flist->frag[flist->numfrags].fragaddr = vtophys( mtod(m, caddr_t) );
			flist->numfrags++;
d791 1
d793 1
a793 1
		/* If packet was more than 63 parts, */
d805 2
a806 1
			flist->frag[0].fraglen = m->m_pkthdr.len = m->m_len = m0->m_pkthdr.len;
a814 1
		/* Save mbuf */
a815 2

		/* Packet queued successful */
d817 1
a817 5

		/* Switch to next descriptor */
		sc->cur_tx = ( sc->cur_tx + 1 ) % TX_RING_SIZE;

		/* Does not generate TXC */
d819 2
a820 5

		/* Packet should be at least ETHER_MIN_LEN */
		desc->txlength = max(m0->m_pkthdr.len,ETHER_MIN_LEN-ETHER_CRC_LEN);

		/* Pass ownership to the chip */
a821 2

		/* Trigger an immediate transmit demand. */
a823 4
#if defined(EPIC_DEBUG)
		if( ifp->if_flags & IFF_DEBUG ) epic_dump_state(sc);
#endif

a850 1
        int i = 0;
d857 1
a857 3
	while( !(sc->rx_desc[sc->cur_rx].status & 0x8000) && \
		i++ < RX_RING_SIZE ) {

d862 1
a862 1
		sc->cur_rx = (sc->cur_rx+1) % RX_RING_SIZE;
d954 1
a954 1
		sc->dirty_tx = (sc->dirty_tx + 1) % TX_RING_SIZE;
d1076 1
a1076 1
		printf(EPIC_FORMAT ": CRC/Alignment error\n",EPIC_ARGS(sc));
d1080 2
a1081 2
	    /* Tx FIFO underflow. Should not happend if */
	    /* we don't use early tx, handle it anyway */
d1097 1
a1097 1
		CSR_WRITE_4(sc, COMMAND, COMMAND_TXUGO | COMMAND_TXQUEUED);
d1570 1
a1570 1
	sc->cur_tx = (sc->cur_tx + 1)%TX_RING_SIZE;
d1679 1
a1679 1
		desc->next = vtophys( sc->rx_desc + ((i+1)%RX_RING_SIZE) );
d1701 1
a1701 1
		desc->next = vtophys( sc->tx_desc + ( (i+1)%TX_RING_SIZE ) );
@

