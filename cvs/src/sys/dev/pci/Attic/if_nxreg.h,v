head	1.29;
access;
symbols;
locks; strict;
comment	@ * @;


1.29
date	2007.08.14.18.54.39;	author reyk;	state dead;
branches;
next	1.28;

1.28
date	2007.05.28.19.44.15;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.26.18.11.42;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.26.01.10.52;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.05.02.12.04;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.05.01.54.02;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.04.04.18.10;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.03.21.05.41;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.03.20.50.56;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.02.19.57.44;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.01.21.56.21;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.01.16.25.48;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.01.11.44.47;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.01.02.25.31;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.01.02.20.14;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2007.04.30.22.53.09;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2007.04.30.21.22.56;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.30.10.55.08;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.04.28.19.10.46;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.28.18.07.29;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.28.17.23.37;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2007.04.28.15.59.05;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2007.04.28.13.58.12;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.04.27.19.56.56;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.04.27.19.46.47;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2007.04.27.19.44.47;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2007.04.27.19.37.39;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.27.14.46.25;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2007.04.16.16.21.11;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.29
log
@remove my unfinished version of the nx driver, we have a better solution

requested by dlg@@
ok deraadt@@
@
text
@/*	$OpenBSD: if_nxreg.h,v 1.28 2007/05/28 19:44:15 reyk Exp $	*/

/*
 * Copyright (c) 2007 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * NetXen NX2031/NX2035 register definitions partially based on:
 * http://www.netxen.com/products/downloads/
 *     Ethernet_Driver_Ref_Guide_Open_Source.pdf
 */

#ifndef _NX_REG_H
#define _NX_REG_H

/*
 * Common definitions
 */

#define NX_MAX_PORTS		4
#define NX_MAX_MTU		ETHER_MTU

#define NX_MAX_TX_DESC		128	/* XXX 4096 */
#define NX_MAX_RX_DESC		128	/* XXX 32768 */
#define NX_MAX_JUMBO_DESC	64	/* XXX 1024 */
#define NX_MAX_TSO_DESC		32	/* XXX 64 */
#define NX_MAX_STATUS_DESC	NX_MAX_RX_DESC

#define NX_JUMBO_MTU		8000	/* less than 9k */
#define NX_DMA_ALIGN		8	/* 64bit alignment */
#define NX_POLL_SENSOR		10	/* read temp sensor every 10s */

#define NX_WAIT			1
#define NX_NOWAIT		0

/* This driver supported the 3.4.31 (3.4.xx) NIC firmware */
#define NX_FIRMWARE_MAJOR	3
#define NX_FIRMWARE_MINOR	4
#define NX_FIRMWARE_BUILD	31

#define NX_FIRMWARE_VER		(					\
	(NX_FIRMWARE_MAJOR << 16) | (NX_FIRMWARE_MINOR << 8) |		\
	NX_FIRMWARE_BUILD						\
)

/* Used to indicate various states of the NIC and its firmware */
enum nx_state {
	NX_S_FAIL	= -1,	/* Failed to initialize the device */
	NX_S_OFFLINE	= 0,	/* Firmware is not active yet */
	NX_S_RESET	= 2,	/* Firmware is in reset state */
	NX_S_BOOT	= 3,	/* Chipset is booting the firmware */
	NX_S_LOADED	= 4,	/* Firmware is loaded but not initialized */
	NX_S_RELOADED	= 5,	/* Firmware is reloaded and initialized */
	NX_S_READY	= 6	/* Device has been initialized and is ready */
};

/*
 * Hardware descriptors
 */

struct nx_txdesc {
	u_int64_t		tx_word0;
#define  NX_TXDESC0_TCPHDROFF_S	0		/* TCP header offset */
#define  NX_TXDESC0_TCPHDROFF_M	0x00000000000000ffULL
#define  NX_TXDESC0_IPHDROFF_S	8		/* IP header offset */
#define  NX_TXDESC0_IPHDROFF_M	0x000000000000ff00
#define  NX_TXDESC0_F_S		16		/* flags */
#define  NX_TXDESC0_F_M		0x00000000007f0000ULL
#define   NX_TXDESC0_F_VLAN	(1<<8)		/* VLAN tagged */
#define   NX_TXDESC0_F_TSO	(1<<1)		/* TSO enabled */
#define   NX_TXDESC0_F_CKSUM	(1<<0)		/* checksum enabled */
#define  NX_TXDESC0_OP_S	23		/* opcode */
#define  NX_TXDESC0_OP_M	0x000000001f800000ULL
#define   NX_TXDESC0_OP_TX_TSO	(1<<4)		/* TCP packet, do TSO */
#define   NX_TXDESC0_OP_TX_IP	(1<<3)		/* IP packet, compute cksum */
#define   NX_TXDESC0_OP_TX_UDP	(1<<2)		/* UDP packet, compute cksum */
#define   NX_TXDESC0_OP_TX_TCP	(1<<1)		/* TCP packet, compute cksum */
#define   NX_TXDESC0_OP_TX	(1<<0)		/* raw Ethernet packet */
#define  NX_TXDESC0_RES0_S	29		/* Reserved */
#define  NX_TXDESC0_RES0_M	0x00000000e0000000ULL
#define  NX_TXDESC0_NBUF_S	32		/* number of buffers */
#define  NX_TXDESC0_NBUF_M	0x000000ff00000000ULL
#define  NX_TXDESC0_LENGTH_S	40		/* length */
#define  NX_TXDESC0_LENGTH_M	0xffffff0000000000ULL
	u_int64_t		tx_addr2;	/* address of buffer 2 */
	u_int64_t		tx_word2;
#define  NX_TXDESC2_HANDLE_S	0		/* handle of the buffer */
#define  NX_TXDESC2_HANDLE_M	0x000000000000ffffULL
#define  NX_TXDESC2_MSS_S	16		/* MSS for the packet */
#define  NX_TXDESC2_MSS_M	0x00000000ffff0000ULL
#define  NX_TXDESC2_PORT_S	32		/* interface port */
#define  NX_TXDESC2_PORT_M	0x0000000f00000000ULL
#define  NX_TXDESC2_CTXID_S	36		/* context ID */
#define  NX_TXDESC2_CTXID_M	0x000000f000000000ULL
#define  NX_TXDESC2_HDRLENGTH_S	40		/* MAC+IP+TCP length for TSO */
#define  NX_TXDESC2_HDRLENGTH_M	0x0000ff0000000000ULL
#define  NX_TXDESC2_IPSECID_S	48		/* IPsec offloading SA/ID */
#define  NX_TXDESC2_IPSECID_M	0xffff000000000000ULL
	u_int64_t		tx_addr3;	/* address of buffer 3 */
	u_int64_t		tx_addr1;	/* address of buffer 1 */
	u_int64_t		tx_buflength;
#define  NX_TXDESC_BUFLENGTH1_S	0		/* length of buffer 1 */
#define  NX_TXDESC_BUFLENGTH1_M	0x000000000000ffffULL
#define  NX_TXDESC_BUFLENGTH2_S	16		/* length of buffer 2 */
#define  NX_TXDESC_BUFLENGTH2_M	0x00000000ffff0000ULL
#define  NX_TXDESC_BUFLENGTH3_S	32		/* length of buffer 3 */
#define  NX_TXDESC_BUFLENGTH3_M	0x0000ffff00000000ULL
#define  NX_TXDESC_BUFLENGTH4_S	48		/* length of buffer 4 */
#define  NX_TXDESC_BUFLENGTH4_M	0xffff000000000000ULL
	u_int64_t		tx_addr4;	/* address of buffer 4 */
	u_int64_t		tx_word7;	/* reserved */
} __packed;

struct nx_rxdesc {
	u_int16_t		rx_handle;	/* handle of the buffer */
	u_int16_t		rx_reserved;
	u_int32_t		rx_length;	/* length of the buffer */
	u_int64_t		rx_addr;	/* address of buffer */
} __packed;

struct nx_statusdesc {
	u_int16_t		rx_port;
#define  NX_STSDESC_PORT_S	0		/* interface port */
#define  NX_STSDESC_PORT_M	0x000f
#define  NX_STSDESC_STS_S	4		/* completion status */
#define  NX_STSDESC_STS_M	0x00f0
#define   NX_STSDESC_STS_NOCHK	1		/* checksum not verified */
#define   NX_STSDESC_STS_CHKOK	2		/* checksum verified ok */
#define  NX_STSDESC_TYPE_S	8		/* type/index of the ring */
#define  NX_STSDESC_TYPE_M	0x0f00
#define  NX_STSDESC_OPCODE_S	12		/* opcode */
#define  NX_STSDESC_OPCODE_M	0xf000
#define   NX_STSDESC_OPCODE	0xa		/* received packet */
	u_int16_t		rx_length;	/* total length of the packet */
	u_int16_t		rx_handle;	/* handle of the buffer */
	u_int16_t		rx_owner;
#define  NX_STSDESC_OWNER_S	0		/* owner of the descriptor */
#define  NX_STSDESC_OWNER_M	0x0003
#define   NX_STSDESC_OWNER_HOST	1		/* owner is the host (t.b.d) */
#define   NX_STSDESC_OWNER_CARD	2		/* owner is the card */
#define  NX_STSDESC_PROTO_S	2		/* protocol type */
#define  NX_STSDESC_PROTO_M	0x003c
} __packed;

struct nx_rxcontext {
	u_int64_t		rxc_ringaddr;
	u_int32_t		rxc_ringsize;
	u_int32_t		rxc_reserved;
} __packed;

#define NX_NRXCONTEXT		3
#define NX_RX_CONTEXT		0
#define NX_JUMBO_CONTEXT	1
#define NX_TSO_CONTEXT		2

/* DMA-mapped ring context for the Rx, Tx, and Status rings */
struct nx_ringcontext {
	u_int64_t		rc_txconsumeroff;
	u_int64_t		rc_txringaddr;
	u_int32_t		rc_txringsize;
	u_int32_t		rc_reserved;

	struct nx_rxcontext	rc_rxcontext[NX_NRXCONTEXT];

	u_int64_t		rc_statusringaddr;
	u_int32_t		rc_statusringsize;

	u_int32_t		rc_id;		/* context identifier */

	/* d3 state register, dummy dma address */
	u_int64_t		rc_reserved1;
	u_int64_t		rc_reserved2;

	u_int32_t		rc_txconsumer;
} __packed;

/*
 * Memory layout
 */

#define NXBAR0			PCI_MAPREG_START
#define NXBAR4			(PCI_MAPREG_START + 16)

/* PCI memory setup */
#define NXPCIMEM_SIZE_128MB	0x08000000	/* 128MB size */
#define NXPCIMEM_SIZE_32MB	0x02000000	/* 32MB size */

/* PCI memory address ranges */
#define NXADDR_DDR_NET		0x0000000000000000ULL
#define NXADDR_DDR_NET_END	0x000000000fffffffULL
#define NXADDR_PCIE		0x0000000800000000ULL
#define NXADDR_PCIE_END		0x0000000fffffffffULL
#define NXADDR_OCM0		0x0000000200000000ULL
#define NXADDR_OCM0_END		0x00000002000fffffULL
#define NXADDR_OCM1		0x0000000200400000ULL
#define NXADDR_OCM1_END		0x00000002004fffffULL
#define NXADDR_QDR_NET		0x0000000300000000ULL
#define NXADDR_QDR_NET_END	0x00000003001fffffULL

/* Memory mapping in the default PCI window */
#define NXPCIMAP_DDR_NET	0x00000000
#define NXPCIMAP_DDR_MD		0x02000000
#define NXPCIMAP_QDR_NET	0x04000000
#define NXPCIMAP_DIRECT_CRB	0x04400000
#define NXPCIMAP_OCM0		0x05000000
#define NXPCIMAP_OCM1		0x05100000
#define NXPCIMAP_CRB		0x06000000

/* Offsets inside NXPCIMAP_CRB */
#define NXMEMMAP_PCIE_0		0x00100000
#define NXMEMMAP_NIU		0x00600000
#define NXMEMMAP_PPE_0		0x01100000
#define NXMEMMAP_PPE_1		0x01200000
#define NXMEMMAP_PPE_2		0x01300000
#define NXMEMMAP_PPE_3		0x01400000
#define NXMEMMAP_PPE_D		0x01500000
#define NXMEMMAP_PPE_I		0x01600000
#define NXMEMMAP_PCIE_1		0x02100000
#define NXMEMMAP_SW		0x02200000
#define NXMEMMAP_SIR		0x03200000
#define NXMEMMAP_ROMUSB		0x03300000

/* NXPCIMAP_CRB window (total offsets) */
#define NXMEMMAP_WINDOW_SIZE	0x02000000
#define NXMEMMAP_WINDOW0_START	0x06000000
#define NXMEMMAP_WINDOW0_END	0x07ffffff
#define NXMEMMAP_WINDOW1_START	0x08000000
#define NXMEMMAP_WINDOW1_END	0x09ffffff

#define NXMEMMAP_HWTRANS_M	0xfff00000

/* Window 0 register map  */
#define NXPCIE(_x)		((_x) + 0x06100000)	/* PCI Express */
#define NXNIU(_x)		((_x) + 0x06600000)	/* Network Int Unit */
#define NXPPE_0(_x)		((_x) + 0x07100000)	/* PEGNET 0 */
#define NXPPE_1(_x)		((_x) + 0x07200000)	/* PEGNET 0 */
#define NXPPE_2(_x)		((_x) + 0x07300000)	/* PEGNET 0 */
#define NXPPE_3(_x)		((_x) + 0x07400000)	/* PEGNET 0 */
#define NXPPE_D(_x)		((_x) + 0x07500000)	/* PEGNET D-Cache */
#define NXPPE_I(_x)		((_x) + 0x07600000)	/* PEGNET I-Cache */

/* Window 1 register map */
#define NXPCIE_1(_x)		((_x) + 0x08100000)	/* PCI Express' */
#define NXSW(_x)		((_x) + 0x08200000)	/* Software defined */
#define NXSIR(_x)		((_x) + 0x09200000)	/* 2nd interrupt */
#define NXROMUSB(_x)		((_x) + 0x09300000)	/* ROMUSB */

/* The IMEZ/HMEZ NICs have multiple PCI functions with different registers */
#define NXPCIE_FUNC(_r, _f)	(NXPCIE(_r) + ((_f) * 0x20))

/* Flash layout */
#define NXFLASHMAP_CRBINIT_0	0x00000000	/* CRBINIT */
#define  NXFLASHMAP_CRBINIT_M	0x7fffffff	/* ROM memory barrier */
#define  NXFLASHMAP_CRBINIT_MAX	1023		/* Max CRBINIT entries */
#define NXFLASHMAP_INFO		0x00004000	/* board configuration */
#define NXFLASHMAP_INITCODE	0x00006000	/* chipset-specific code */
#define NXFLASHMAP_BOOTLOADER	0x00010000	/* boot loader */
#define  NXFLASHMAP_BOOTLDSIZE	0x4000		/* boot loader size */
#define NXFLASHMAP_FIRMWARE_0	0x00043000	/* compressed firmware image */
#define NXFLASHMAP_FIRMWARE_1	0x00200000	/* backup firmware image */
#define NXFLASHMAP_PXE		0x003d0000	/* PXE image */
#define NXFLASHMAP_USER		0x003e8000	/* user-specific ares */
#define NXFLASHMAP_VPD		0x003e8c00	/* vendor private data */
#define NXFLASHMAP_LICENSE	0x003e9000	/* firmware license (?) */
#define NXFLASHMAP_CRBINIT_1	0x003f0000	/* backup of CRBINIT */

/*
 * Doorbell messages
 */

/* Register in the doorbell memory region */
#define NXDB			0x00000000
#define  NXDB_PEGID_M		0x00000003	/* Chipset unit */
#define  NXDB_PEGID_S		0
#define   NXDB_PEGID_RX		1		/* Rx unit */
#define   NXDB_PEGID_TX		2		/* Tx unit */
#define  NXDB_PRIVID		0x00000004	/* Must be set */
#define  NXDB_COUNT_M		0x0003fff8	/* Doorbell count */
#define  NXDB_COUNT_S		3
#define  NXDB_CTXID_M		0x0ffc0000	/* Context ID */
#define  NXDB_CTXID_S		18
#define  NXDB_OPCODE_M		0xf0000000	/* Doorbell opcode */
#define  NXDB_OPCODE_S		28
#define   NXDB_OPCODE_RCV_PROD	0
#define   NXDB_OPCODE_JRCV_PROD	1
#define   NXDB_OPCODE_TSO_PROD	2
#define   NXDB_OPCODE_CMD_PROD	3
#define   NXDB_OPCODE_UPD_CONS	4
#define   NXDB_OPCODE_RESET_CTX	5

/*
 * PCI Express Registers
 */

/* Interrupt Vector */
#define NXISR_INT_VECTOR		NXPCIE(0x00010100)
#define  NXISR_INT_VECTOR_TARGET3	(1<<10)	/* interrupt for function 3 */
#define  NXISR_INT_VECTOR_TARGET2	(1<<9)	/* interrupt for function 2 */
#define  NXISR_INT_VECTOR_TARGET1	(1<<8)	/* interrupt for function 1 */
#define  NXISR_INT_VECTOR_TARGET0	(1<<7)	/* interrupt for function 0 */
#define   NXISR_INT_VECTOR_PORT(_n)	(NXISR_INT_VECTOR_TARGET0 << (_n))
#define  NXISR_INT_VECTOR_RC_INT	(1<<5)	/* root complex interrupt */

/* Interrupt Mask */
#define NXISR_INT_MASK			NXPCIE(0x00010104)
#define  NXISR_INT_MASK_TARGET3		(1<<10)	/* mask for function 3 */
#define  NXISR_INT_MASK_TARGET2		(1<<9)	/* mask for function 2 */
#define  NXISR_INT_MASK_TARGET1		(1<<8)	/* mask for function 1 */
#define  NXISR_INT_MASK_TARGET0		(1<<7)	/* mask for function 0 */
#define   NXISR_INT_MASK_PORT(_n)	(NXISR_INT_MASK_TARGET0 << (_n))
#define  NXISR_INT_MASK_RC_INT		(1<<5)	/* root complex mask */
#define NXISR_INT_MASK_ENABLE		0x0000077f
#define NXISR_INT_MASK_DISABLE		0x000007ff

/* Interrupt target mask and status */
#define NXISR_TARGET_STATUS		NXPCIE(0x00010118)
#define NXISR_TARGET_MASK		NXPCIE(0x00010128)
#define  NXISR_TARGET_MASK_ENABLE	0x00000bff
#define  NXISR_TARGET_MASK_DISABLE	0xffffffff

/* Memory windows */
#define NXDDR_WINDOW(_f)		NXPCIE_FUNC(0x00010200, _f)
#define  NXDDR_WINDOW_1			(1<<25)	/* Set this flag for Win 1 */
#define  NXDDR_WINDOW_S			25
#define  NXDDR_WINDOW_M			0x000003ff
#define  NXDDR_WINDOW_SIZE		0x02000000
#define NXQDR_WINDOW(_f)		NXPCIE_FUNC(0x00010208, _f)
#define  NXQDR_WINDOW_1			(1<<25)	/* Set this flag for Win 1 */
#define  NXQDR_WINDOW_S			22
#define  NXQDR_WINDOW_M			0x0000003f
#define  NXQDR_WINDOW_SIZE		0x00400000
#define NXCRB_WINDOW(_f)		NXPCIE_FUNC(0x00010210, _f)
#define  NXCRB_WINDOW_1			(1<<25)	/* Set this flag for Win 1 */
#define  NXCRB_WINDOW_S			25
#define  NXCRB_WINDOW_M			0x00000004
#define  NXCRB_WINDOW_SIZE		0x02000000

/* Lock registers (semaphores between chipset and driver) */
#define NXSEM_FLASH_LOCK	NXPCIE_1(0x0001c010)	/* Flash lock */
#define  NXSEM_FLASH_LOCK_M	0xffffffff
#define  NXSEM_FLASH_LOCKED	(1<<0)			/* R/O: is locked */
#define NXSEM_FLASH_UNLOCK	NXPCIE_1(0x0001c014)	/* Flash unlock */
#define NXSEM_PHY_LOCK		NXPCIE_1(0x0001c018)	/* PHY lock */
#define  NXSEM_PHY_LOCK_M	0xffffffff
#define  NXSEM_PHY_LOCKED	(1<<0)			/* R/O: is locked */
#define NXSEM_PHY_UNLOCK	PXPCIE_1(0x0001c01c)	/* PHY unlock */

/*
 * Network Interface Unit (NIU) registers
 */

/* Mode Register (see also NXNIU_RESET_SYS_FIFOS) */
#define NXNIU_MODE			NXNIU(0x00000000)
#define  NXNIU_MODE_XGE			(1<<2)	/* XGE interface enabled */
#define  NXNIU_MODE_GBE			(1<<1)	/* 4 GbE interfaces enabled */
#define  NXNIU_MODE_FC			(1<<0)	/* *Fibre Channel enabled */
#define NXNIU_MODE_DEF			NUI_XGE_ENABLE

/* 10G - 1G Mode Enable Register */
#define NXNIU_XG_SINGLE_TERM		NXNIU(0x00000004)
#define  NXNIU_XG_SINGLE_TERM_ENABLE	(1<<0)	/* Enable 10G + 1G mode */
#define NXNIU_XG_SINGLE_TERM_DEF	0		/* Disabled */

/* XGE Reset Register */
#define NXNIU_XG_RESET			NXNIU(0x0000001c)
#define  NXNIU_XG_RESET_CD		(1<<1)	/* Reset channels CD */
#define  NXNIU_XG_RESET_AB		(1<<0)	/* Reset channels AB */
#define NXNIU_XG_RESET_DEF		(NXNIU_XG_RESET_AB|NXNIU_XG_RESET_CD)

/* Interrupt Mask Register */
#define NXNIU_INT_MASK			NXNIU(0x00000040)
#define  NXNIU_INT_MASK_XG		(1<<6)	/* XGE Interrupt Mask */
#define  NXNIU_INT_MASK_RES5		(1<<5)	/* Reserved bit */
#define  NXNIU_INT_MASK_RES4		(1<<4)	/* Reserved bit */
#define  NXNIU_INT_MASK_GB3		(1<<3)	/* GbE 3 Interrupt Mask */
#define  NXNIU_INT_MASK_GB2		(1<<2)	/* GbE 2 Interrupt Mask */
#define  NXNIU_INT_MASK_GB1		(1<<1)	/* GbE 1 Interrupt Mask */
#define  NXNIU_INT_MASK_GB0		(1<<0)	/* GbE 0 Interrupt Mask */
#define NXNIU_INT_MASK_DEF		(				\
	NXNIU_INT_MASK_XG|NXNIU_INT_MASK_RES5|NXNIU_INT_MASK_RES4|	\
	NXNIU_INT_MASK_GB3|NXNIU_INT_MASK_GB2|NXNIU_INT_MASK_GB1|	\
	NXNIU_INT_MASK_GB0)			/* Reserved bits enabled */

/* Reset System FIFOs Register (needed before changing NXNIU_MODE) */
#define NXNIU_RESET_SYS_FIFOS		NXNIU(0x00000088)
#define  NXNIU_RESET_SYS_FIFOS_RX	(1<<31)	/* Reset all Rx FIFOs */
#define  NXNIU_RESET_SYS_FIFOS_TX	(1<<0)	/* Reset all Tx FIFOs */
#define NXNIU_RESET_SYS_FIFOS_DEF	0	/* Disabled */

/* Flow control registers */
#define NXNIU_XGE_PAUSE_CONTROL		NXNIU(0x00000098)
#define  NXNIU_XGE_PAUSE_S(_n)		((_n) * 3)
#define  NXNIU_XGE_PAUSE_M		0x00000007
#define  NXNIU_XGE_PAUSE_DISABLED	(1<<0)	/* Tx Pause (always Rx) */
#define  NXNIU_XGE_PAUSE_REQUEST	(1<<1)	/* Request pause */
#define  NXNIU_XGE_PAUSE_ONOFF		(1<<2)	/* Request pause on/off */
#define NXNIU_XGE_PAUSE_LEVEL		NXNIU(0x000000dc)

/*
 * Port-specific NIU registers, will be mapped to a subregion
 */

#define NXNIU_PORT_SIZE			0x00010000
#define NXNIU_PORT(_r, _n)		NXNIU((_r) + (_n) * NXNIU_PORT_SIZE)

#define NXNIU_FC(_n)			NXNIU_PORT(0x00010000, _n)
#define NXNIU_GBE(_n)			NXNIU_PORT(0x00030000, _n)
#define NXNIU_XGE(_n)			NXNIU_PORT(0x00070000, _n)

/* XGE Configuration 0 Register */
#define NX_XGE_CONFIG0			0x0000
#define  NXNIU_XGE_CONFIG0_SOFTRST_FIFO	(1<<31)	/* Soft reset FIFOs */
#define  NXNIU_XGE_CONFIG0_SOFTRST_MAC	(1<<4)	/* Soft reset XGE MAC */
#define  NXNIU_XGE_CONFIG0_RX_ENABLE	(1<<2)	/* Enable frame Rx */
#define  NXNIU_XGE_CONFIG0_TX_ENABLE	(1<<0)	/* Enable frame Tx */
#define NXNIU_XGE_CONFIG0_DEF		0	/* Disabled */

/* XGE Configuration 1 Register */
#define NX_XGE_CONFIG1			0x0004
#define  NXNIU_XGE_CONFIG1_PROMISC	(1<<13)	/* Pass all Rx frames */
#define  NXNIU_XGE_CONFIG1_MCAST_ENABLE	(1<<12) /* Rx all multicast frames */
#define  NXNIU_XGE_CONFIG1_SEQ_ERROR	(1<<10) /* Sequence error detection */
#define  NXNIU_XGE_CONFIG1_NO_PAUSE	(1<<8)	/* Ignore pause frames */
#define  NXNIU_XGE_CONFIG1_LOCALERR	(1<<6)	/* Wire local error */
#define   NXNIU_XGE_CONFIG1_LOCALERR_FE	0	/* Signal with 0xFE */
#define   NXNIU_XGE_CONFIG1_LOCALERR_I	1	/* Signal with Ierr */
#define  NXNIU_XGE_CONFIG1_NO_MAXSIZE	(1<<5)	/* Ignore max Rx size */
#define  NXNIU_XGE_CONFIG1_CRC_TX	(1<<1)	/* Append CRC to Tx frames */
#define  NXNIU_XGE_CONFIG1_CRC_RX	(1<<0)	/* Remove CRC from Rx frames */
#define NXNIU_XGE_CONFIG1_DEF		0	/* Disabled */

/* XGE Station Address (lladdr) Register */
#define NX_XGE_STATION_ADDR_HI		0x000c	/* High lladdr */	
#define NX_XGE_STATION_ADDR_LO		0x0010	/* low lladdr */

/*
 * Software defined registers (used by the firmware or the driver)
 */

/* Chipset state registers */
#define NXSW_ROM_LOCK_ID	NXSW(0x2100)	/* Used for locking the ROM */
#define  NXSW_ROM_LOCK_DRV	0x0d417340	/* Driver ROM lock ID */
#define NXSW_PHY_LOCK_ID	NXSW(0x2120)	/* Used for locking the PHY */
#define  NXSW_PHY_LOCK_DRV	0x44524956	/* Driver PHY lock ID */
#define NXSW_FW_VERSION_MAJOR	NXSW(0x2150)	/* Major f/w version */
#define NXSW_FW_VERSION_MINOR	NXSW(0x2154)	/* Minor f/w version */
#define NXSW_FW_VERSION_BUILD	NXSW(0x2158)	/* Build/Sub f/w version */
#define NXSW_BOOTLD_CONFIG	NXSW(0x21fc)
#define  NXSW_BOOTLD_CONFIG_ROM	0x00000000	/* Load firmware from flasg */
#define  NXSW_BOOTLD_CONFIG_RAM	0x12345678	/* Load firmware from memory */

/* Misc SW registers */
#define NXSW_CMD_PRODUCER_OFF	NXSW(0x2208)	/* Producer CMD ring index */
#define NXSW_CMD_CONSUMER_OFF	NXSW(0x220c)	/* Consumer CMD ring index */
#define NXSW_CMD_ADDR_HI	NXSW(0x2218)	/* CMD ring phys address */
#define NXSW_CMD_ADDR_LO	NXSW(0x221c)	/* CMD ring phys address */
#define NXSW_CMD_RING_SIZE	NXSW(0x22c8)	/* Entries in the CMD ring */
#define NXSW_CMDPEG_STATE	NXSW(0x2250)	/* State of the firmware */
#define  NXSW_CMDPEG_STATE_M	0xffff		/* State mask */
#define  NXSW_CMDPEG_INIT_START	0xff00		/* Start of initialization */
#define  NXSW_CMDPEG_INIT_DONE	0xff01		/* Initialization complete */
#define  NXSW_CMDPEG_INIT_ACK	0xf00f		/* Initialization ACKed */
#define  NXSW_CMDPEG_INIT_FAIL	0xffff		/* Initialization failed */
#define NXSW_GLOBAL_INT_COAL	NXSW(0x2264)	/* Interrupt coalescing */
#define NXSW_INT_COAL_MODE	NXSW(0x2268)	/* Reserved */
#define NXSW_MAX_RCV_BUFS	NXSW(0x226c)	/* Interrupt tuning register */
#define NXSW_TX_INT_THRESHOLD	NXSW(0x2270)	/* Interrupt tuning register */
#define NXSW_RX_PKT_TIMER	NXSW(0x2274)	/* Interrupt tuning register */
#define NXSW_TX_PKT_TIMER	NXSW(0x2278)	/* Interrupt tuning register */
#define NXSW_RX_PKT_CNT		NXSW(0x227c)	/* Rx packet count register */
#define NXSW_RX_TMR_CNT		NXSW(0x2280)	/* Rx timer count register */
#define NXSW_XG_STATE		NXSW(0x2294)	/* PHY state register */
#define  NXSW_XG_LINK_UP	(1<<4)		/* 10G PHY state up */
#define  NXSW_XG_LINK_DOWN	(1<<5)		/* 10G PHY state down */
#define NXSW_MPORT_MODE		NXSW(0x22c4)	/* Multi port mode */
#define  NXSW_MPORT_MODE_M	0xffff		/* Mode mask */
#define  NXSW_MPORT_MODE_1FUNC	0x1111		/* Single function mode */
#define  NXSW_MPORT_MODE_NFUNC	0x2222		/* Multi function mode */

#define NXSW_TEMP		NXSW(0x23b4)	/* Temperature sensor */
#define  NXSW_TEMP_STATE_M	0x0000ffff	/* Temp state mask */
#define  NXSW_TEMP_STATE_S	0		/* Temp state shift */
#define   NXSW_TEMP_STATE_NONE	0x0000		/* Temp state is UNSPEC */
#define   NXSW_TEMP_STATE_OK	0x0001		/* Temp state is OK */
#define   NXSW_TEMP_STATE_WARN	0x0002		/* Temp state is WARNING */
#define   NXSW_TEMP_STATE_CRIT	0x0003		/* Temp state is CRITICAL */
#define  NXSW_TEMP_VAL_M	0xffff0000	/* Temp deg celsius mask */
#define  NXSW_TEMP_VAL_S	16		/* Temp deg celsius shift */
#define NXSW_DRIVER_VER		NXSW(0x24a0)	/* Host driver version */

/*
 * Port-specific SW registers, cannot be mapped to a subregion because
 * they're using different offsets between the registers. Ugh, we have to
 * define a mapping table to avoid a ton of ugly if's in the code.
 */
enum nxsw_portreg {
	NXSW_RCV_PRODUCER_OFF	= 0,		/* Producer Rx ring index */
	NXSW_RCV_CONSUMER_OFF,			/* Consumer Rx ring index */
	NXSW_GLOBALRCV_RING,			/* Address of Rx buffer */
	NXSW_RCV_RING_SIZE,			/* Entries in the Rx ring */

	NXSW_JRCV_PRODUCER_OFF,			/* Producer jumbo ring index */
	NXSW_JRCV_CONSUMER_OFF,			/* Consumer jumbo ring index */
	NXSW_GLOBALJRCV_RING,			/* Address of jumbo buffer */
	NXSW_JRCV_RING_SIZE,			/* Entries in the jumbo ring */

	NXSW_TSO_PRODUCER_OFF,			/* Producer TSO ring index */
	NXSW_TSO_CONSUMER_OFF,			/* Consumer TSO ring index */
	NXSW_GLOBALOTSO_RING,			/* Address of TSO buffer */
	NXSW_TSO_RING_SIZE,			/* Entries in the TSO ring */

	NXSW_STATUS_RING,			/* Address of status ring */
	NXSW_STATUS_PROD,			/* Producer status index */
	NXSW_STATUS_CONS,			/* Consumer status index */
	NXSW_RCVPEG_STATE,			/* State of the NX2031 */
#define  NXSW_RCVPEG_STATE_M	0xffff		/* State mask */
#define  NXSW_RCVPEG_INIT_START	0xff00		/* Start of initialization */
#define  NXSW_RCVPEG_INIT_DONE	0xff01		/* Initialization complete */
#define  NXSW_RCVPEG_INIT_ACK	0xf00f		/* Initialization ACKed */
#define  NXSW_RCVPEG_INIT_FAIL	0xffff		/* Initialization failed */
	NXSW_STATUS_RING_SIZE,			/* Entries in the status ring */

	NXSW_CONTEXT_ADDR_LO,			/* Low address of context */
	NXSW_CONTEXT,				/* Context register */
#define  NXSW_CONTEXT_M		0xffff		/* Context register mask */
#define  NXSW_CONTEXT_SIG	0xdee0		/* Context signature */
#define  NXSW_CONTEXT_RESET	0xbad0		/* Context reset */
	NXSW_CONTEXT_ADDR_HI,			/* High address of context */

	NXSW_PORTREG_MAX
};
#define NXSW_PORTREGS		{					\
	{ NXSW(0x2300), NXSW(0x2344), NXSW(0x23d8), NXSW(0x242c) },	\
	{ NXSW(0x2304), NXSW(0x2348), NXSW(0x23dc), NXSW(0x2430) },	\
	{ NXSW(0x2308), NXSW(0x234c), NXSW(0x23f0), NXSW(0x2434) },	\
	{ NXSW(0x230c), NXSW(0x2350), NXSW(0x23f4), NXSW(0x2438) },	\
									\
	{ NXSW(0x2310), NXSW(0x2354), NXSW(0x23f8), NXSW(0x243c) },	\
	{ NXSW(0x2314), NXSW(0x2358), NXSW(0x23fc), NXSW(0x2440) },	\
	{ NXSW(0x2318), NXSW(0x235c), NXSW(0x2400), NXSW(0x2444) },	\
	{ NXSW(0x231c), NXSW(0x2360), NXSW(0x2404), NXSW(0x2448) },	\
									\
	{ NXSW(0x2320), NXSW(0x2364), NXSW(0x2408), NXSW(0x244c) },	\
	{ NXSW(0x2324), NXSW(0x2368), NXSW(0x240c), NXSW(0x2450) },	\
	{ NXSW(0x2328), NXSW(0x236c), NXSW(0x2410), NXSW(0x2454) },	\
	{ NXSW(0x232c), NXSW(0x2370), NXSW(0x2414), NXSW(0x2458) },	\
									\
	{ NXSW(0x2330), NXSW(0x2374), NXSW(0x2418), NXSW(0x245c) },	\
	{ NXSW(0x2334), NXSW(0x2378), NXSW(0x241c), NXSW(0x2460) },	\
	{ NXSW(0x2338), NXSW(0x237c), NXSW(0x2420), NXSW(0x2464) },	\
	{ NXSW(0x233c), NXSW(0x2380), NXSW(0x2424), NXSW(0x2468) },	\
	{ NXSW(0x2340), NXSW(0x2384), NXSW(0x2428), NXSW(0x246c) },	\
									\
	{ NXSW(0x2388), NXSW(0x2390), NXSW(0x2398), NXSW(0x23a0) },	\
	{ NXSW(0x238c), NXSW(0x2394), NXSW(0x239c), NXSW(0x23a4) },	\
	{ NXSW(0x23c0), NXSW(0x23c4), NXSW(0x23c8), NXSW(0x23cc) }	\
}

/*
 * Port-specific SW registers, will be mapped to a subregion
 */

/*
 * Secondary Interrupt Registers
 */

/* I2Q Register */
#define NXI2Q_CLR_PCI_HI		NXSIR(0x00000034)
#define  NXI2Q_CLR_PCI_HI_PHY		(1<<13)	/* PHY interrupt */
#define NXI2Q_CLR_PCI_HI_DEF		0	/* Cleared */

/*
 * ROMUSB registers
 */

/* Status Register */
#define NXROMUSB_GLB_STATUS		NXROMUSB(0x00000004)	/* ROM Status */
#define  NXROMUSB_GLB_STATUS_DONE	(1<<1)			/* Ready */

/* Reset Unit Register */
#define NXROMUSB_GLB_SW_RESET		NXROMUSB(0x00000008)
#define  NXROMUSB_GLB_SW_RESET_EFC_SIU	(1<<30)	/* EFC_SIU reset */
#define  NXROMUSB_GLB_SW_RESET_NIU	(1<<29)	/* NIU software reset */
#define  NXROMUSB_GLB_SW_RESET_U0QMSQG	(1<<28)	/* Network side QM_SQG reset */
#define  NXROMUSB_GLB_SW_RESET_U1QMSQG	(1<<27)	/* Storage side QM_SQG reset */
#define  NXROMUSB_GLB_SW_RESET_C2C1	(1<<26)	/* Chip to Chip 1 reset */
#define  NXROMUSB_GLB_SW_RESET_C2C0	(1<<25)	/* Chip to Chip 2 reset */
#define  NXROMUSB_GLB_SW_RESET_U1PEGI	(1<<11)	/* Storage Pegasus I-Cache */
#define  NXROMUSB_GLB_SW_RESET_U1PEGD	(1<<10)	/* Storage Pegasus D-Cache */
#define  NXROMUSB_GLB_SW_RESET_U1PEG3	(1<<9)	/* Storage Pegasus3 reset */
#define  NXROMUSB_GLB_SW_RESET_U1PEG2	(1<<8)	/* Storage Pegasus2 reset */
#define  NXROMUSB_GLB_SW_RESET_U1PEG1	(1<<7)	/* Storage Pegasus1 reset */
#define  NXROMUSB_GLB_SW_RESET_U1PEG0	(1<<6)	/* Storage Pegasus0 reset */
#define  NXROMUSB_GLB_SW_RESET_U0PEGI	(1<<11)	/* Network Pegasus I-Cache */
#define  NXROMUSB_GLB_SW_RESET_U0PEGD	(1<<10)	/* Network Pegasus D-Cache */
#define  NXROMUSB_GLB_SW_RESET_U0PEG3	(1<<9)	/* Network Pegasus3 reset */
#define  NXROMUSB_GLB_SW_RESET_U0PEG2	(1<<8)	/* Network Pegasus2 reset */
#define  NXROMUSB_GLB_SW_RESET_U0PEG1	(1<<7)	/* Network Pegasus1 reset */
#define  NXROMUSB_GLB_SW_RESET_U0PEG0	(1<<6)	/* Network Pegasus0 reset */
#define  NXROMUSB_GLB_SW_RESET_PPE	0xf0	/* Protocol Processing Engine */
#define  NXROMUSB_GLB_SW_RESET_XDMA	0x8000ff;
#define NXROMUSB_GLB_SW_RESET_DEF	0xffffffff

/* Casper Reset Register */
#define NXROMUSB_GLB_CAS_RESET		NXROMUSB(0x00000038)
#define  NXROMUSB_GLB_CAS_RESET_ENABLE	(1<<0)	/* Enable Casper reset */
#define  NXROMUSB_GLB_CAS_RESET_DISABLE	0
#define NXROMUSB_GLB_CAS_RESET_DEF	0	/* Disabled */

/* Reset register */
#define NXROMUSB_GLB_PEGTUNE		NXROMUSB(0x0000005c)
#define  NXROMUSB_GLB_PEGTUNE_DONE	(1<<0)

/* Chip clock control register */
#define NXROMUSB_GLB_CHIPCLKCONTROL	NXROMUSB(0x000000a8)
#define  NXROMUSB_GLB_CHIPCLKCONTROL_ON	0x00003fff

/* ROM Register */
#define NXROMUSB_ROM_CONTROL		NXROMUSB(0x00010000)
#define NXROMUSB_ROM_OPCODE		NXROMUSB(0x00010004)
#define  NXROMUSB_ROM_OPCODE_READ	0x0000000b
#define NXROMUSB_ROM_ADDR		NXROMUSB(0x00010008)
#define NXROMUSB_ROM_WDATA		NXROMUSB(0x0001000c)
#define NXROMUSB_ROM_ABYTE_CNT		NXROMUSB(0x00010010)
#define NXROMUSB_ROM_DUMMY_BYTE_CNT	NXROMUSB(0x00010014)
#define NXROMUSB_ROM_RDATA		NXROMUSB(0x00010018)
#define NXROMUSB_ROM_AGT_TAG		NXROMUSB(0x0001001c)
#define NXROMUSB_ROM_TIME_PARM		NXROMUSB(0x00010020)
#define NXROMUSB_ROM_CLK_DIV		NXROMUSB(0x00010024)
#define NXROMUSB_ROM_MISS_INSTR		NXROMUSB(0x00010028)

/*
 * Flash data structures
 */

enum nxb_board_types {
	NXB_BOARDTYPE_P1BD		= 0,
	NXB_BOARDTYPE_P1SB		= 1,
	NXB_BOARDTYPE_P1SMAX		= 2,
	NXB_BOARDTYPE_P1SOCK		= 3,

	NXB_BOARDTYPE_P2SOCK31		= 8,
	NXB_BOARDTYPE_P2SOCK35		= 9,

	NXB_BOARDTYPE_P2SB35_4G		= 10,
	NXB_BOARDTYPE_P2SB31_10G	= 11,
	NXB_BOARDTYPE_P2SB31_2G		= 12,
	NXB_BOARDTYPE_P2SB31_10GIMEZ	= 13,
	NXB_BOARDTYPE_P2SB31_10GHMEZ	= 14,
	NXB_BOARDTYPE_P2SB31_10GCX4	= 15
};

#define NXB_MAX_PORTS	NX_MAX_PORTS		/* max supported ports */

struct nxb_info {
	u_int32_t	ni_hdrver;		/* Board info version */
#define  NXB_VERSION	0x00000001		/* board information version */

	u_int32_t	ni_board_mfg;
	u_int32_t	ni_board_type;
	u_int32_t	ni_board_num;

	u_int32_t	ni_chip_id;
	u_int32_t	ni_chip_minor;
	u_int32_t	ni_chip_major;
	u_int32_t	ni_chip_pkg;
	u_int32_t	ni_chip_lot;

	u_int32_t	ni_port_mask;
	u_int32_t	ni_peg_mask;
	u_int32_t	ni_icache;
	u_int32_t	ni_dcache;
	u_int32_t	ni_casper;

	u_int32_t	ni_lladdr0_low;
	u_int32_t	ni_lladdr1_low;
	u_int32_t	ni_lladdr2_low;
	u_int32_t	ni_lladdr3_low;

	u_int32_t	ni_mnsync_mode;
	u_int32_t	ni_mnsync_shift_cclk;
	u_int32_t	ni_mnsync_shift_mclk;
	u_int32_t	ni_mnwb_enable;
	u_int32_t	ni_mnfreq_crystal;
	u_int32_t	ni_mnfreq_speed;
	u_int32_t	ni_mnorg;
	u_int32_t	ni_mndepth;
	u_int32_t	ni_mnranks0;
	u_int32_t	ni_mnranks1;
	u_int32_t	ni_mnrd_latency0;
	u_int32_t	ni_mnrd_latency1;
	u_int32_t	ni_mnrd_latency2;
	u_int32_t	ni_mnrd_latency3;
	u_int32_t	ni_mnrd_latency4;
	u_int32_t	ni_mnrd_latency5;
	u_int32_t	ni_mnrd_latency6;
	u_int32_t	ni_mnrd_latency7;
	u_int32_t	ni_mnrd_latency8;
	u_int32_t	ni_mndll[18];
	u_int32_t	ni_mnddr_mode;
	u_int32_t	ni_mnddr_extmode;
	u_int32_t	ni_mntiming0;
	u_int32_t	ni_mntiming1;
	u_int32_t	ni_mntiming2;

	u_int32_t	ni_snsync_mode;
	u_int32_t	ni_snpt_mode;
	u_int32_t	ni_snecc_enable;
	u_int32_t	ni_snwb_enable;
	u_int32_t	ni_snfreq_crystal;
	u_int32_t	ni_snfreq_speed;
	u_int32_t	ni_snorg;
	u_int32_t	ni_sndepth;
	u_int32_t	ni_sndll;
	u_int32_t	ni_snrd_latency;

	u_int32_t	ni_lladdr0_high;
	u_int32_t	ni_lladdr1_high;
	u_int32_t	ni_lladdr2_high;
	u_int32_t	ni_lladdr3_high;

	u_int32_t	ni_magic;
#define  NXB_MAGIC	0x12345678		/* magic value */

	u_int32_t	ni_mnrd_imm;
	u_int32_t	ni_mndll_override;
} __packed;

#define NXB_MAX_PORT_LLADDRS	32

struct nxb_imageinfo {
	u_int32_t	nim_bootld_ver;
	u_int32_t	nim_bootld_size;
	u_int32_t	nim_image_ver;
#define  NXB_IMAGE_MAJOR_S	0
#define  NXB_IMAGE_MAJOR_M	0x000000ff
#define  NXB_IMAGE_MINOR_S	8
#define  NXB_IMAGE_MINOR_M	0x0000ff00
#define  NXB_IMAGE_BUILD_S	16
#define  NXB_IMAGE_BUILD_M	0xffff0000
	u_int32_t	nim_image_size;
} __packed;

struct nxb_userinfo {
	u_int8_t		nu_flash_md5[1024];

	struct nxb_imageinfo	nu_image;

	u_int32_t		nu_primary;
	u_int32_t		nu_secondary;
	u_int64_t		nu_lladdr[NXB_MAX_PORTS * NXB_MAX_PORT_LLADDRS];
	u_int32_t		nu_subsys_id;
	u_int8_t		nu_serial_num[32];
	u_int32_t		nu_bios_ver;

	/* Followed by user-specific data */
} __packed;

/* Appended to the on-disk firmware image, values in network byte order */
struct nxb_firmware_header {
	u_int32_t		 fw_hdrver;
#define NX_FIRMWARE_HDRVER	 0	/* version of the firmware header */
	struct nxb_imageinfo	 fw_image;
#define fw_image_ver		 fw_image.nim_image_ver
#define fw_image_size		 fw_image.nim_image_size
#define fw_bootld_ver		 fw_image.nim_bootld_ver
#define fw_bootld_size		 fw_image.nim_bootld_size
} __packed;

#endif /* _NX_REG_H */
@


1.28
log
@make it compile on i386
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.27 2007/05/26 18:11:42 reyk Exp $	*/
@


1.27
log
@tx descriptor fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.26 2007/05/26 01:10:52 reyk Exp $	*/
d201 10
a210 10
#define NXADDR_DDR_NET		0x0000000000000000
#define NXADDR_DDR_NET_END	0x000000000fffffff
#define NXADDR_PCIE		0x0000000800000000
#define NXADDR_PCIE_END		0x0000000fffffffff
#define NXADDR_OCM0		0x0000000200000000
#define NXADDR_OCM0_END		0x00000002000fffff
#define NXADDR_OCM1		0x0000000200400000
#define NXADDR_OCM1_END		0x00000002004fffff
#define NXADDR_QDR_NET		0x0000000300000000
#define NXADDR_QDR_NET_END	0x00000003001fffff
@


1.26
log
@update some registers and the tx descriptor layout to match the latest
firmware that we use. also start to implement initial bits of the tx
path and interrupt handling (work in progress).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.25 2007/05/05 02:12:04 reyk Exp $	*/
d93 1
a93 1
#define  NX_TXDESC0_NBUF_S	0		/* number of buffers */
d95 1
a95 1
#define  NX_TXDESC0_LENGTH_S	8		/* length */
@


1.25
log
@disable the interrupts on interface shutdown
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.24 2007/05/05 01:54:02 reyk Exp $	*/
d74 50
a123 42
	u_int8_t		tx_tcpoff;	/* IP header offset for TSO */
	u_int8_t		tx_ipoff;	/* TCP header offset for TSO */
	u_int16_t		tx_flags;
#define  NX_TXDESC_F_S		0		/* flags */
#define  NX_TXDESC_F_M		0x007f
#define   NX_TXDESC_F_VLAN	(1<<8)		/* VLAN tagged */
#define   NX_TXDESC_F_TSO	(1<<1)		/* TSO enabled */
#define   NX_TXDESC_F_CKSUM	(1<<0)		/* checksum enabled */
#define  NX_TXDESC_OP_S		7		/* opcode */
#define  NX_TXDESC_OP_M		0x1f80
#define   NX_TXDESC_OP_STOPSTTS	(1<<9)		/* Stop statistics */
#define   NX_TXDESC_OP_GETSTATS	(1<<8)		/* Get statistics */
#define   NX_TXDESC_OP_TX_TSO	(1<<5)		/* TCP packet, do TSO */
#define   NX_TXDESC_OP_TX_IP	(1<<4)		/* IP packet, compute cksum */
#define   NX_TXDESC_OP_TX_UDP	(1<<3)		/* UDP packet, compute cksum */
#define   NX_TXDESC_OP_TX_TCP	(1<<2)		/* TCP packet, compute cksum */
#define   NX_TXDESC_OP_TX	(1<<1)		/* raw Ethernet packet */
	u_int32_t		tx_length;
#define  NX_TXDESC_NBUF_S	0		/* number of buffers */
#define  NX_TXDESC_NBUG_M	0x000000ff
#define  NX_TXDESC_LENGTH_S	8		/* length */
#define  NX_TXDESC_LENGTH_M	0xffffff00
	u_int32_t		tx_addr2_low;	/* low address of buffer 2 */
	u_int32_t		tx_addr2_high;	/* high address of buffer 2 */
	u_int16_t		tx_handle;	/* handle of the buffer */
	u_int16_t		tx_mss;		/* MSS for the packet */
	u_int8_t		tx_port;	/* interface port */
#define  NX_TXDESC_PORT_S	0
#define  NX_TXDESC_PORT_M	0x0f
	u_int8_t		tx_hdrlength;	/* MAC+IP+TCP length for TSO */
	u_int16_t		tx_reserved;
	u_int32_t		tx_addr3_low;	/* low address of buffer 3 */
	u_int32_t		tx_addr3_high;	/* high address of buffer 3 */
	u_int32_t		tx_addr1_low;	/* low address of buffer 1 */
	u_int32_t		tx_addr1_high;	/* high address of buffer 1 */
	u_int16_t		tx_buf1_length;	/* length of buffer 1 */
	u_int16_t		tx_buf2_length;	/* length of buffer 2 */
	u_int16_t		tx_buf3_length;	/* length of buffer 3 */
	u_int16_t		tx_buf4_length;	/* length of buffer 4 */
	u_int32_t		tx_addr4_low;	/* low address of buffer 4 */
	u_int32_t		tx_addr4_high;	/* high address of buffer 4 */
	u_int64_t		tx_reserved1;
d130 1
a130 2
	u_int32_t		rx_addr_low;	/* low address of buffer */
	u_int32_t		rx_addr_high;	/* high address of buffer */
d158 1
a158 2
	u_int32_t		rxc_ringaddr_low;
	u_int32_t		rxc_ringaddr_high;
d170 2
a171 4
	u_int32_t		rc_txconsumeroff_low;
	u_int32_t		rc_txconsumeroff_high;
	u_int32_t		rc_txringaddr_low;
	u_int32_t		rc_txringaddr_high;
d177 1
a177 2
	u_int32_t		rc_statusringaddr_low;
	u_int32_t		rc_statusringaddr_high;
d280 24
d325 1
a325 1
#define NXISR_INT_MASK_DISABLE		0x00000000
d331 1
a331 1
#define  NXISR_TARGET_MASK_DISABLE	0x00000000
@


1.24
log
@allocate dma memory, setup rx/tx/status rings, initialize the ring
context, and enable interrupts. it is not yet ready - i still need to
implement the rx/tx handlers, handle the producer/consumer ids, and
make it work.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.23 2007/05/04 04:18:10 reyk Exp $	*/
d298 1
d304 1
@


1.23
log
@swap the port register table arrays to make it better readble and fix some
register typos... on init, wait for the receive engine to be ready before
setting up the descriptor rings.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.22 2007/05/03 21:05:41 reyk Exp $	*/
d32 2
a33 1
#define NX_MAX_PORTS	4
d35 9
a43 2
#define NX_MAX_MTU	ETHER_MTU
#define NX_JUMBO_MTU	8000		/* less than 9k */
d45 2
a46 3
#define NX_DMA_ALIGN	8		/* 64bit alignment */

#define NX_POLL_SENSOR	10		/* read temp sensor every 10s */
d122 2
a123 1
	u_int64_t		rx_addr;	/* address of the buffer */
d151 4
a154 4
	u_int32_t		rc_ringaddr_low;
	u_int32_t		rc_ringaddr_high;
	u_int32_t		rc_ringsize;
	u_int32_t		rc_reserved;
d158 3
d164 2
a165 1
	u_int64_t		rc_txconsumer_off;
d168 2
a169 2

	u_int32_t		rc_txring_size;
d175 1
a175 1
	u_int32_t		rc_statusring_size;
d180 2
a181 1
	u_int64_t		rc_reserved[2];
d286 1
d295 1
d297 6
d507 4
a511 1
	NXSW_CONTEXT_SIG,			/* Context signature */
@


1.22
log
@allocate DMA memory for the per-port Rx, Tx (command), and Status ring
context.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.20 2007/05/02 19:57:44 reyk Exp $	*/
d170 1
a170 1
	u_int32_t		rc_align;	/* 64bit aligned */
d437 4
a457 1

d478 5
d485 4
d492 24
a515 25
	{								\
	    NXSW(0x2300), NXSW(0x2304), NXSW(0x2308), NXSW(0x230c),	\
	    NXSW(0x2310), NXSW(0x2314), NXSW(0x2318), NXSW(0x231c),	\
	    NXSW(0x2320), NXSW(0x2324), NXSW(0x2328), NXSW(0x232c),	\
	    NXSW(0x2320), NXSW(0x2324), NXSW(0x2328), NXSW(0x232c),	\
	    NXSW(0x2340)						\
	}, {								\
	    NXSW(0x2344), NXSW(0x2348), NXSW(0x234c), NXSW(0x2350),	\
	    NXSW(0x2354), NXSW(0x2358), NXSW(0x235c), NXSW(0x2360),	\
	    NXSW(0x2364), NXSW(0x2368), NXSW(0x236c), NXSW(0x2370),	\
	    NXSW(0x2374), NXSW(0x2378), NXSW(0x237c), NXSW(0x2380),	\
	    NXSW(0x2384)						\
	}, {								\
	    NXSW(0x23d8), NXSW(0x23dc), NXSW(0x23f0), NXSW(0x23f4),	\
	    NXSW(0x23f8), NXSW(0x23fc), NXSW(0x2400), NXSW(0x2404),	\
	    NXSW(0x2408), NXSW(0x240c), NXSW(0x2410), NXSW(0x2414),	\
	    NXSW(0x2418), NXSW(0x241c), NXSW(0x2420), NXSW(0x2424),	\
	    NXSW(0x2428)						\
	}, {								\
	    NXSW(0x242c), NXSW(0x2430), NXSW(0x2434), NXSW(0x2438),	\
	    NXSW(0x243c), NXSW(0x2440), NXSW(0x2444), NXSW(0x2448),	\
	    NXSW(0x244c), NXSW(0x2450), NXSW(0x2454), NXSW(0x2458),	\
	    NXSW(0x245c), NXSW(0x2460), NXSW(0x2464), NXSW(0x2468),	\
	    NXSW(0x246c)						\
	}								\
@


1.21
log
@a nxb NIC can have up to 4 nx ports and the latest firmware uses some
port-specific registers, for the NIU (phy) and the CRB (~mac). fine.

but i have to use an ugly mapping table for the port-specific crb
registers because their offsets are not consistent and do not allow to
use a subregion per port. ugh.
@
text
@d37 2
d140 31
@


1.20
log
@carefully set the correct memory windows (crb/pci) and add a dummy
read after changing the windows to make sure that the value has been
set. also change the code to automatically set the correct window
which is less error-prone than the manual approach. these changes
finally fix the problems with reset and firmware loading.
this commit also includes some unrelated changes like register
updates, port-specific register mapping, rx/tx pause status etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.19 2007/05/01 21:56:21 reyk Exp $	*/
a383 6
#define NXSW_RCV_PRODUCER_OFF	NXSW(0x2300)	/* Producer Rx ring index */
#define NXSW_RCV_CONSUMER_OFF	NXSW(0x2304)	/* Consumer Rx ring index */
#define NXSW_RCV_GLOBAL_RING	NXSW(0x2308)	/* Address of Rx buffer */
#define NXSW_RCV_STATUS_RING	NXSW(0x2360)	/* Address of Rx status ring */
#define NXSW_RCV_STATUS_PROD	NXSW(0x2364)	/* Producer Rx status index */
#define NXSW_RCV_STATUS_CONS	NXSW(0x2368)	/* Consumer Rx status index */
a386 3
#define NXSW_RCV_RING_SIZE	NXSW(0x230c)	/* Entries in the Rx ring */
#define NXSW_JRCV_RING_SIZE	NXSW(0x230c)	/* Entries in the jumbo ring */
#define NXSW_RCVPEG_STATE	NXSW(0x236c)	/* State of the NX2031 */
d404 1
a404 3
#define NXSW_JRCV_PRODUCER_OFF	NXSW(0x22f4)	/* Producer jumbo ring index */
#define NXSW_JRCV_CONSUMER_OFF	NXSW(0x22f8)	/* Consumer jumbo ring index */
#define NXSW_JRCV_GLOBAL_RING	NXSW(0x2308)	/* Address of jumbo buffer */
d415 62
@


1.19
log
@some fixes
- fix the reset path and remove the '#if 0'. firmware loading makes me cry
- update the SW (CRB) register offsets to match the upcoming 3.4.31 firmware
- the link state and ifmedia should work now with a register and code fix
- ...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.18 2007/05/01 16:25:48 reyk Exp $	*/
d65 22
a86 1
	u_int64_t		tx_next;	/* reserved */
a88 19
	u_int32_t		tx_length;
#define  NX_TXDESC_LENGTH_S	0		/* length */
#define  NX_TXDESC_LENGTH_M	0x00ffffff
#define  NX_TXDESC_TCPOFF_S	24		/* TCP header offset for TSO */
#define  NX_TXDESC_TCPOFF_M	0xff000000
	u_int8_t		tx_ipoff;	/* IP header offset for TSO */
	u_int8_t		tx_nbuf;	/* number of buffers */
	u_int8_t		tx_flags;
#define  NX_TXDESC_F_VLAN	(1<<8)		/* VLAN tagged */
#define  NX_TXDESC_F_TSO	(1<<1)		/* TSO enabled */
#define  NX_TXDESC_F_CKSUM	(1<<0)		/* checksum enabled */
	u_int8_t		tx_opcode;
#define  NX_TXDESC_OP_STOPSTATS	(1<<9)		/* Stop statistics */
#define  NX_TXDESC_OP_GETSTATS	(1<<8)		/* Get statistics */
#define  NX_TXDESC_OP_TX_TSO	(1<<5)		/* TCP packet, do TSO */
#define  NX_TXDESC_OP_TX_IP	(1<<4)		/* IP packet, compute cksum */
#define  NX_TXDESC_OP_TX_UDP	(1<<3)		/* UDP packet, compute cksum */
#define  NX_TXDESC_OP_TX_TCP	(1<<2)		/* TCP packet, compute cksum */
#define  NX_TXDESC_OP_TX	(1<<1)		/* raw Ethernet packet */
d106 1
d173 1
a173 4
#define NXMEMMAP_WINDOW0_START	0x00000000
#define NXMEMMAP_WINDOW0_END	0x01ffffff
#define NXMEMMAP_WINDOW_SIZE	0x02000000
#define NXMEMMAP_PCIE		0x00100000
d181 2
a182 3
#define NXMEMMAP_WINDOW1_START	0x02000000
#define NXMEMMAP_WINDOW1_END	0x07ffffff
#define NXMEMMAP_SW		0x02200000	/* XXX 0x02400000? */
d186 7
d206 4
a209 4
#define NXPCIE_1(_x)		((_x) + 0x06100000)	/* PCI Express' */
#define NXSW(_x)		((_x) + 0x06200000)	/* Software defined */
#define NXSIR(_x)		((_x) + 0x07200000)	/* 2nd interrupt */
#define NXROMUSB(_x)		((_x) + 0x07300000)	/* ROMUSB */
d263 3
d268 1
a268 1
#define NXSEM_FLASH_LOCK	NXPCIE(0x0001c010)	/* Flash lock */
d271 2
a272 2
#define NXSEM_FLASH_UNLOCK	NXPCIE(0x0001c014)	/* Flash unlock */
#define NXSEM_PHY_LOCK		NXPCIE(0x0001c018)	/* PHY lock */
d275 1
a275 1
#define NXSEM_PHY_UNLOCK	PXPCIE(0x0001c01c)	/* PHY unlock */
d319 20
d340 1
a340 1
#define NXNIU_XGE_CONFIG0		NXNIU(0x00070000)
d348 1
a348 1
#define NXNIU_XGE_CONFIG1		NXNIU(0x00070004)
d361 4
d400 1
@


1.18
log
@export the temperature sensor found on the nx(4) NICs. it reports degC
and the states UNSPEC, OK, WARN, and CRIT. the driver should use this
later to shutdown the NIC if the state becomes CRITical.

hw.sensors.nxb0.temp0=37.00 degC, OK
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.17 2007/05/01 11:44:47 reyk Exp $	*/
d43 5
a47 1
#define NX_FIRMWARE_VER		0x001f0403
d148 13
d163 1
d165 2
d215 1
a215 1
#define  NXFLASHMAP_BOOTLDSIZE	1024		/* boot loader size */
d244 11
a254 1
/* SW Window */
d351 12
a362 12
#define NXSW_RCV_PRODUCER_OFF	NXSW(0x2218)	/* Producer Rx ring index */
#define NXSW_RCV_CONSUMER_OFF	NXSW(0x221c)	/* Consumer Rx ring index */
#define NXSW_RCV_GLOBAL_RING	NXSW(0x2220)	/* Address of Rx buffer */
#define NXSW_RCV_STATUS_RING	NXSW(0x2224)	/* Address of Rx status ring */
#define NXSW_RCV_STATUS_PROD	NXSW(0x2228)	/* Producer Rx status index */
#define NXSW_RCV_STATUS_CONS	NXSW(0x222c)	/* Consumer Rx status index */
#define NXSW_CMD_ADDR_HI	NXSW(0x2230)	/* CMD ring phys address */
#define NXSW_CMD_ADDR_LO	NXSW(0x2234)	/* CMD ring phys address */
#define NXSW_CMD_RING_SIZE	NXSW(0x2238)	/* Entries in the CMD ring */
#define NXSW_RCV_RING_SIZE	NXSW(0x223c)	/* Entries in the Rx ring */
#define NXSW_JRCV_RING_SIZE	NXSW(0x2240)	/* Entries in the jumbo ring */
#define NXSW_RCVPEG_STATE	NXSW(0x2248)	/* State of the NX2031 */
d368 9
a376 9
#define NXSW_GLOBAL_INT_COAL	NXSW(0x2280)	/* Interrupt coalescing */
#define NXSW_INT_COAL_MODE	NXSW(0x2284)	/* Reserved */
#define NXSW_MAX_RCV_BUFS	NXSW(0x2288)	/* Interrupt tuning register */
#define NXSW_TX_INT_THRESHOLD	NXSW(0x228c)	/* Interrupt tuning register */
#define NXSW_RX_PKT_TIMER	NXSW(0x2290)	/* Interrupt tuning register */
#define NXSW_TX_PKT_TIMER	NXSW(0x2294)	/* Interrupt tuning register */
#define NXSW_RX_PKT_CNT		NXSW(0x2298)	/* Rx packet count register */
#define NXSW_RX_TMR_CNT		NXSW(0x229c)	/* Rx timer count register */
#define NXSW_XG_STATE		NXSW(0x22a0)	/* PHY state register */
d379 3
a381 3
#define NXSW_JRCV_PRODUCER_OFF	NXSW(0x2300)	/* Producer jumbo ring index */
#define NXSW_JRCV_CONSUMER_OFF	NXSW(0x2304)	/* Consumer jumbo ring index */
#define NXSW_JRCV_GLOBAL_RING	NXSW(0x2220)	/* Address of jumbo buffer */
d431 1
@


1.17
log
@shuffle some code and add additional states in the reset path. use a
scheduled timeout to check for the boot process to finish in the reset
code instead of waiting for a loooong delay (still use the long delay
in the initial boot on attach because i cannot defer the
initialization there).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.16 2007/05/01 02:25:31 reyk Exp $	*/
d35 3
a37 1
#define NX_JUMBO_MTU	8000			/* less than 9k */
@


1.16
log
@fix some register offsets
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.15 2007/05/01 02:20:14 reyk Exp $	*/
d47 5
a51 4
	NX_S_RESET	= 1,	/* Firmware is in reset state */
	NX_S_BOOT	= 2,	/* Chipset is booting the firmware */
	NX_S_LOADED	= 3,	/* Firmware is loaded but not initialized */
	NX_S_READY	= 4	/* Device has been initialized and is ready */
d193 1
@


1.15
log
@implement the soft reset of the hardware according to section 3.5.6 of
the doc).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.14 2007/04/30 22:53:09 reyk Exp $	*/
a306 14
#define NXSW_TEMP		NXSW(0x01b4)	/* Temperature sensor */
#define  NXSW_TEMP_STATE_M	0x0000ffff	/* Temp state mask */
#define  NXSW_TEMP_STATE_S	0		/* Temp state shift */
#define   NXSW_TEMP_STATE_NONE	0x0000		/* Temp state is UNSPEC */
#define   NXSW_TEMP_STATE_OK	0x0001		/* Temp state is OK */
#define   NXSW_TEMP_STATE_WARN	0x0002		/* Temp state is WARNING */
#define   NXSW_TEMP_STATE_CRIT	0x0003		/* Temp state is CRITICAL */
#define  NXSW_TEMP_VAL_M	0xffff0000	/* Temp deg celsius mask */
#define  NXSW_TEMP_VAL_S	16		/* Temp deg celsius shift */
#define NXSW_BOOTLD_CONFIG	NXSW(0x01fc)
#define  NXSW_BOOTLD_CONFIG_ROM	0x00000000	/* Load firmware from flasg */
#define  NXSW_BOOTLD_CONFIG_RAM	0x12345678	/* Load firmware from memory */

/* Version registers of the loaded firmware */
d310 3
d348 9
@


1.14
log
@better handling of the firmware state madness
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.13 2007/04/30 21:22:56 reyk Exp $	*/
d41 1
d47 4
a50 3
	NX_S_BOOT	= 1,	/* Chipset is booting the firmware */
	NX_S_LOADED	= 2,	/* Firmware is loaded but not initialized */
	NX_S_READY	= 3	/* Device has been initialized and is ready */
d147 2
d152 8
d164 2
d169 6
d187 2
d359 1
d398 1
@


1.13
log
@initial code for firmware loading and initialization. it is used by
the reset function and will be used later to load an
alternative/updated firmware image and bootloader from disk if the
images from the flash are not supported by the driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.12 2007/04/30 10:55:08 reyk Exp $	*/
d46 2
a47 1
	NX_S_BOOTING	= 1,	/* Chipset is booting the firmware */
d280 1
a280 1
/* Lock ID registers */
d285 9
a293 2

/* Boot loader configuration */
@


1.12
log
@move the firmware validation to a mountroot hook to allow loading of
an alternative firmware image from disk (not yet implemented). this
also minimizes the additional delay to wait for the firmware to become
ready because the firmware bootstrap is triggered in the attach
function and the state is polled later in the mountroot hook.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.11 2007/04/28 19:10:46 reyk Exp $	*/
d44 1
d138 2
d285 5
d371 2
a372 1
#define  NXRUMUSB_GLB_CAS_RESET_ENABLE	(1<<0)	/* Enable Casper reset */
d379 4
a417 2
#define NXB_VERSION	0x00000001		/* board information version */
#define NXB_MAGIC	0x12345678		/* magic value */
d422 1
d488 1
d496 13
d510 1
a510 1
	u_int8_t	nu_flash_md5[1024];
d512 1
a512 2
	u_int32_t	nu_bootloader_ver;
	u_int32_t	nu_bootloader_size;
d514 6
a519 2
	u_int32_t	nu_image_ver;
	u_int32_t	nu_image_size;
d521 2
a522 6
	u_int32_t	nu_primary;
	u_int32_t	nu_secondary;
	u_int64_t	nu_lladdr[NXB_MAX_PORTS * NXB_MAX_PORT_LLADDRS];
	u_int32_t	nu_subsys_id;
	u_int8_t	nu_serial_num[32];
	u_int32_t	nu_bios_ver;
d524 9
a532 1
	/* Followed by user-specific data */
@


1.11
log
@initialize and bootstrap the device and enable the firmware
verification check. the NIC's bootstrap process can take up to 10
seconds.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.10 2007/04/28 18:07:29 reyk Exp $	*/
d41 7
@


1.10
log
@attach the available ports and print the lladdr (no operation yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.9 2007/04/28 17:23:37 reyk Exp $	*/
d296 1
d359 4
d490 1
@


1.9
log
@validate the firmware version, this driver requires 3.4.xx (3.4.31).
this code is not enabled yet because i need to bootstrap the chipset
first.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.8 2007/04/28 15:59:05 reyk Exp $	*/
d375 17
@


1.8
log
@read more information from flash - get the user info field and copy
one lladdr per port.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.7 2007/04/28 13:58:12 reyk Exp $	*/
d37 5
d269 1
d275 6
@


1.7
log
@add code to access the flash memory in the ROMUSB register area and
read the board information data from the flash on startup. this is required
to determine the board type, version, etc. etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.6 2007/04/27 19:56:56 reyk Exp $	*/
d360 8
a367 1
/* Board information */
d440 19
a458 3
#define NXB_VERSION	0x00000001		/* board information version */
#define NXB_MAGIC	0x12345678		/* magic value */
#define NXB_MAX_PORTS	NX_MAX_PORTS		/* max supported ports */
@


1.6
log
@update a comment to reflect the truth - the documentation that is
available online is incomplete or even outdated and this driver is
only partially based on it. other information is obtained from the
netxen reference driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.5 2007/04/27 19:46:47 reyk Exp $	*/
d121 1
d128 1
d137 1
a137 2
#define NXPCIE(_x)		((_x) + 0x00100000)	/* PCI Express */
#define NXPCIE_1(_x)		((_x) + 0x06100000)	/* PCI Express */
d141 1
d147 14
a160 1
#define NXPCIE_FUNC(_r, _f)	(NXPCIE_1(_r) + ((_f) * 0x20))
d184 11
a194 1
#define  NXCRB_WINDOW_1			(1<<25)
d315 4
d349 1
d359 77
@


1.5
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.4 2007/04/27 19:44:47 reyk Exp $	*/
d20 1
a20 1
 * NetXen NX2031 register definitions based on:
@


1.4
log
@registers are accessed via configurable windows in the PCI memory space,
some macro abstraction is required to support different window mappings.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.3 2007/04/27 19:37:39 reyk Exp $	*/
d81 1
a81 1
} __packed;	
@


1.3
log
@also map the seconds PCI memory space
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.2 2007/04/27 14:46:25 reyk Exp $	*/
d127 20
d152 1
a152 1
#define NXISR_INT_VECTOR		0x00010100
d160 1
a160 1
#define NXISR_INT_MASK			0x00010104
d167 4
d176 1
a176 1
#define NXNIU_MODE			0x00000000
d183 1
a183 1
#define NXNIU_XG_SINGLE_TERM		0x00000004
d188 1
a188 1
#define NXNIU_XG_RESET			0x0000001c
d194 1
a194 1
#define NXNIU_INT_MASK			0x00000040
d208 1
a208 1
#define NXNIU_RESET_SYS_FIFOS		0x00000088
d214 1
a214 1
#define NXNIU_XGE_CONFIG0		0x00070000
d222 1
a222 1
#define NXNIU_XGE_CONFIG1		0x00070004
d239 37
a275 32
#define NXSW_CMD_PRODUCER_OFFSET	0x2208	/* Producer CMD ring index */
#define NXSW_CMD_CONSUMER_OFFSET	0x220c	/* Consumer CMD ring index */
#define NXSW_RCV_PRODUCER_OFFSET	0x2218	/* Producer Rx ring index */
#define NXSW_RCV_CONSUMER_OFFSET	0x221c	/* Consumer Rx ring index */
#define NXSW_RCV_GLOBAL_RING		0x2220	/* Address of Rx buffer */
#define NXSW_RCV_STATUS_RING		0x2224	/* Address of Rx status ring */
#define NXSW_RCV_STATUS_PRODUCER	0x2228	/* Producer Rx status index */
#define NXSW_RCV_STATUS_CONSUMER	0x222c	/* Consumer Rx status index */
#define NXSW_CMD_ADDR_HI		0x2230	/* CMD ring phys address */
#define NXSW_CMD_ADDR_LO		0x2234	/* CMD ring phys address */
#define NXSW_CMD_RING_SIZE		0x2238	/* Entries in the CMD ring */
#define NXSW_RCV_RING_SIZE		0x223c	/* Entries in the Rx ring */
#define NXSW_JRCV_RING_SIZE		0x2240	/* Entries in the jumbo ring */
#define NXSW_RCVPEG_STATE		0x2248	/* State of the NX2031 */
#define NXSW_CMDPEG_STATE		0x2250	/* State of the firmware */
#define  NXSW_CMDPEG_STATE_INIT_START	0xff00	/* Start of initialization */
#define  NXSW_CMDPEG_STATE_INIT_DONE	0xff01	/* Initialization complete */
#define  NXSW_CMDPEG_STATE_INIT_FAILED	0xffff	/* Initialization failed */
#define NXSW_GLOBAL_INT_COAL		0x2280	/* Interrupt coalescing */
#define NXSW_INT_COAL_MODE		0x2284	/* Reserved */
#define NXSW_MAX_RCV_BUFS		0x2288	/* Interrupt tuning register */
#define NXSW_TX_INT_THRESHOLD		0x228c	/* Interrupt tuning register */
#define NXSW_RX_PKT_TIMER		0x2290	/* Interrupt tuning register */
#define NXSW_TX_PKT_TIMER		0x2294	/* Interrupt tuning register */
#define NXSW_RX_PKT_CNT			0x2298	/* Rx packet count register */
#define NXSW_RX_TMR_CNT			0x229c	/* Rx timer count register */
#define NXSW_XG_STATE			0x22a0	/* PHY state register */
#define  NXSW_XG_LINK_UP		(1<<4)	/* 10G PHY state up */
#define  NXSW_XG_LINK_DOWN		(1<<5)	/* 10G PHY state down */
#define NXSW_JRCV_PRODUCER_OFFSET	0x2300	/* Producer jumbo ring index */
#define NXSW_JRCV_CONSUMER_OFFSET	0x2304	/* Consumer jumbo ring index */
#define NXSW_JRCV_GLOBAL_RING		0x2220	/* Address of jumbo buffer */
d282 1
a282 1
#define NXI2Q_CLR_PCI_HI		0x00000034
d286 4
d291 1
a291 1
#define NXROMUSB_GLB_SW_RESET		0x1a100008
d313 1
a313 1
#define NXROMUSB_GLB_CAS_RESET		0x1a100038
d316 13
@


1.2
log
@add a section to define the nx memory layout
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nxreg.h,v 1.1 2007/04/16 16:21:11 reyk Exp $	*/
d117 3
@


1.1
log
@Start a driver for the NetXen Inc. multi port 10Gb and Gigabit
Ethernet devices. The driver attaches as nxb at pci for the
controller/board and nx at nxb for each port.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d113 10
@

