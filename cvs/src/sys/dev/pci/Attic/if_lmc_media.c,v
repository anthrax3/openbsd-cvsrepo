head	1.20;
access;
symbols
	OPENBSD_5_7:1.18.0.4
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.20
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.18
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.14
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.12
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.10
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.8
	OPENBSD_5_0:1.17.0.6
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.4
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.16.0.16
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.18
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.14
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.12
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.10
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.8
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.6
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.14.0.6
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.13.0.6
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.4
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.12.0.6
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.4
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.8
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.2
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.20
date	2015.04.09.18.58.22;	author deraadt;	state dead;
branches;
next	1.19;
commitid	cDamcqFPw3HffP51;

1.19
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.18;
commitid	p4LJxGKbi0BU2cG6;

1.18
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.17;
commitid	t9FBKDfc4VDxpEy2;

1.17
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.07.00.29.21;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.05.11.49.01;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.12.06.35.11;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.11.19.20.27;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.23.14.17.07;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.12.20.33.50;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.09.13.13.43;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.27.06.02.50;	author nate;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.27.05.44.56;	author nate;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.14.17.29.11;	author chris;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.06.17.57.56;	author chris;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.02.01.18.01.41;	author chris;	state Exp;
branches;
next	1.2;

1.2
date	99.10.26.23.47.14;	author chris;	state Exp;
branches;
next	1.1;

1.1
date	99.07.01.23.10.40;	author deraadt;	state Exp;
branches;
next	;

1.4.2.1
date	2001.07.04.10.42.15;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2004.06.05.23.12.50;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Send lmc(4) and san(4) to the HDLC framed bit bucket in the sky.
@
text
@/* $OpenBSD: if_lmc_media.c,v 1.19 2015/03/14 03:38:48 jsg Exp $ */
/* $Id: if_lmc_media.c,v 1.19 2015/03/14 03:38:48 jsg Exp $ */

/*-
 * Copyright (c) 1997-1999 LAN Media Corporation (LMC)
 * All rights reserved.  www.lanmedia.com
 *
 * This code is written by Michael Graff <graff@@vix.com> for LMC.
 * The code is derived from permitted modifications to software created
 * by Matt Thomas (matt@@3am-software.com).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following disclaimer
 *    in the documentation and/or other materials provided with the
 *    distribution.
 * 3. All marketing or advertising materials mentioning features or
 *    use of this software must display the following acknowledgement:
 *      This product includes software developed by LAN Media Corporation
 *      and its contributors.
 * 4. Neither the name of LAN Media Corporation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY LAN MEDIA CORPORATION AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <dev/pci/pcidevs.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_types.h>
#include <net/if_dl.h>
#include <net/netisr.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <net/if_sppp.h>

#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

#include <dev/pci/if_lmc_types.h>
#include <dev/pci/if_lmcioctl.h>
#include <dev/pci/if_lmcvar.h>

/*
 * For lack of a better place, put the T1 cable stuff here.
 */
char *lmc_t1_cables[] = {
	"V.10/RS423", "EIA530A", "reserved", "X.21", "V.35",
	"EIA449/EIA530/V.36", "V.28/EIA232", "none", NULL
};

/*
 * protocol independent method.
 */
static void	lmc_set_protocol(lmc_softc_t * const, lmc_ctl_t *);

/*
 * media independent methods to check on media status, link, light LEDs,
 * etc.
 */
static void	lmc_ds3_init(lmc_softc_t * const);
static void	lmc_ds3_default(lmc_softc_t * const);
static void	lmc_ds3_set_status(lmc_softc_t * const, lmc_ctl_t *);
static void	lmc_ds3_set_100ft(lmc_softc_t * const, int);
static int	lmc_ds3_get_link_status(lmc_softc_t * const);
static void	lmc_ds3_set_crc_length(lmc_softc_t * const, int);
static void	lmc_ds3_set_scram(lmc_softc_t * const, int);
static void	lmc_ds3_watchdog(lmc_softc_t * const);

static void	lmc_hssi_init(lmc_softc_t * const);
static void	lmc_hssi_default(lmc_softc_t * const);
static void	lmc_hssi_set_status(lmc_softc_t * const, lmc_ctl_t *);
static void	lmc_hssi_set_clock(lmc_softc_t * const, int);
static int	lmc_hssi_get_link_status(lmc_softc_t * const);
static void	lmc_hssi_set_link_status(lmc_softc_t * const, int);
static void	lmc_hssi_set_crc_length(lmc_softc_t * const, int);
static void	lmc_hssi_watchdog(lmc_softc_t * const);

static void     lmc_ssi_init(lmc_softc_t * const);
static void     lmc_ssi_default(lmc_softc_t * const);
static void     lmc_ssi_set_status(lmc_softc_t * const, lmc_ctl_t *);
static void     lmc_ssi_set_clock(lmc_softc_t * const, int);
static void     lmc_ssi_set_speed(lmc_softc_t * const, lmc_ctl_t *);
static int      lmc_ssi_get_link_status(lmc_softc_t * const);
static void     lmc_ssi_set_link_status(lmc_softc_t * const, int);
static void     lmc_ssi_set_crc_length(lmc_softc_t * const, int);
static void	lmc_ssi_watchdog(lmc_softc_t * const);

static void	lmc_t1_init(lmc_softc_t * const);
static void	lmc_t1_default(lmc_softc_t * const);
static void	lmc_t1_set_status(lmc_softc_t * const, lmc_ctl_t *);
static int	lmc_t1_get_link_status(lmc_softc_t * const);
static void     lmc_t1_set_circuit_type(lmc_softc_t * const, int);
static void	lmc_t1_set_crc_length(lmc_softc_t * const, int);
static void	lmc_t1_set_clock(lmc_softc_t * const, int);
static void	lmc_t1_watchdog(lmc_softc_t * const);

static void	lmc_dummy_set_1(lmc_softc_t * const, int);
static void	lmc_dummy_set2_1(lmc_softc_t * const, lmc_ctl_t *);

static inline void write_av9110_bit(lmc_softc_t *, int);
static void	write_av9110(lmc_softc_t *, u_int32_t, u_int32_t, u_int32_t,
			     u_int32_t, u_int32_t);

lmc_media_t lmc_ds3_media = {
	lmc_ds3_init,			/* special media init stuff */
	lmc_ds3_default,		/* reset to default state */
	lmc_ds3_set_status,		/* reset status to state provided */
	lmc_dummy_set_1,		/* set clock source */
	lmc_dummy_set2_1,		/* set line speed */
	lmc_ds3_set_100ft,		/* set cable length */
	lmc_ds3_set_scram,		/* set scrambler */
	lmc_ds3_get_link_status,	/* get link status */
	lmc_dummy_set_1,		/* set link status */
	lmc_ds3_set_crc_length,		/* set CRC length */
	lmc_dummy_set_1,		/* set T1 or E1 circuit type */
	lmc_ds3_watchdog
};

lmc_media_t lmc_hssi_media = {
	lmc_hssi_init,			/* special media init stuff */
	lmc_hssi_default,		/* reset to default state */
	lmc_hssi_set_status,		/* reset status to state provided */
	lmc_hssi_set_clock,		/* set clock source */
	lmc_dummy_set2_1,		/* set line speed */
	lmc_dummy_set_1,		/* set cable length */
	lmc_dummy_set_1,		/* set scrambler */
	lmc_hssi_get_link_status,	/* get link status */
	lmc_hssi_set_link_status,	/* set link status */
	lmc_hssi_set_crc_length,	/* set CRC length */
	lmc_dummy_set_1,		/* set T1 or E1 circuit type */
	lmc_hssi_watchdog
};

lmc_media_t lmc_ssi_media = {
	lmc_ssi_init,			/* special media init stuff */
        lmc_ssi_default,		/* reset to default state */
        lmc_ssi_set_status,		/* reset status to state provided */
        lmc_ssi_set_clock,		/* set clock source */
        lmc_ssi_set_speed,		/* set line speed */
        lmc_dummy_set_1,		/* set cable length */
        lmc_dummy_set_1,		/* set scrambler */
        lmc_ssi_get_link_status,	/* get link status */
        lmc_ssi_set_link_status,	/* set link status */
        lmc_ssi_set_crc_length,		/* set CRC length */
        lmc_dummy_set_1,		/* set T1 or E1 circuit type */
	lmc_ssi_watchdog
};

lmc_media_t lmc_t1_media = {
	lmc_t1_init,			/* special media init stuff */
	lmc_t1_default,			/* reset to default state */
	lmc_t1_set_status,		/* reset status to state provided */
        lmc_t1_set_clock,		/* set clock source */
        lmc_dummy_set2_1,		/* set line speed */
	lmc_dummy_set_1,		/* set cable length */
	lmc_dummy_set_1,		/* set scrambler */
	lmc_t1_get_link_status,		/* get link status */
        lmc_dummy_set_1,		/* set link status */
	lmc_t1_set_crc_length,		/* set CRC length */
        lmc_t1_set_circuit_type,	/* set T1 or E1 circuit type */
	lmc_t1_watchdog
};

static void
lmc_dummy_set_1(lmc_softc_t * const sc, int a)
{
}

static void
lmc_dummy_set2_1(lmc_softc_t * const sc, lmc_ctl_t *a)
{
}

/*
 *  HSSI methods
 */

static void
lmc_hssi_init(lmc_softc_t * const sc)
{
	sc->ictl.cardtype = LMC_CTL_CARDTYPE_LMC5200;

	lmc_gpio_mkoutput(sc, LMC_GEP_HSSI_CLOCK);
}

static void
lmc_hssi_default(lmc_softc_t * const sc)
{
	sc->lmc_miireg16 = LMC_MII16_LED_ALL;

	sc->lmc_media->set_link_status(sc, LMC_LINK_DOWN);
	sc->lmc_media->set_clock_source(sc, LMC_CTL_CLOCK_SOURCE_EXT);
	sc->lmc_media->set_crc_length(sc, LMC_CTL_CRC_LENGTH_16);
}

/*
 * Given a user provided state, set ourselves up to match it.  This will
 * always reset the card if needed.
 */
static void
lmc_hssi_set_status(lmc_softc_t * const sc, lmc_ctl_t *ctl)
{
	if (ctl == NULL) {
		sc->lmc_media->set_clock_source(sc, sc->ictl.clock_source);
		lmc_set_protocol(sc, NULL);

		return;
	}

	/*
	 * check for change in clock source
	 */
	if (ctl->clock_source && !sc->ictl.clock_source) {
		sc->lmc_media->set_clock_source(sc, LMC_CTL_CLOCK_SOURCE_INT);
		sc->lmc_timing = LMC_CTL_CLOCK_SOURCE_INT;
	} else if (!ctl->clock_source && sc->ictl.clock_source) {
		sc->lmc_timing = LMC_CTL_CLOCK_SOURCE_EXT;
		sc->lmc_media->set_clock_source(sc, LMC_CTL_CLOCK_SOURCE_EXT);
	}

	lmc_set_protocol(sc, ctl);
}

/*
 * 1 == internal, 0 == external
 */
static void
lmc_hssi_set_clock(lmc_softc_t * const sc, int ie)
{
	if (ie == LMC_CTL_CLOCK_SOURCE_EXT) {
		sc->lmc_gpio |= LMC_GEP_HSSI_CLOCK;
		LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);
		sc->ictl.clock_source = LMC_CTL_CLOCK_SOURCE_EXT;
		printf(LMC_PRINTF_FMT ": clock external\n",
		       LMC_PRINTF_ARGS);
	} else {
		sc->lmc_gpio &= ~(LMC_GEP_HSSI_CLOCK);
		LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);
		sc->ictl.clock_source = LMC_CTL_CLOCK_SOURCE_INT;
		printf(LMC_PRINTF_FMT ": clock internal\n",
		       LMC_PRINTF_ARGS);
	}
}

/*
 * return hardware link status.
 * 0 == link is down, 1 == link is up.
 */
static int
lmc_hssi_get_link_status(lmc_softc_t * const sc)
{
	u_int16_t link_status;

	link_status = lmc_mii_readreg(sc, 0, 16);

	if ((link_status & LMC_MII16_HSSI_CA) == LMC_MII16_HSSI_CA)
		return 1;
	else
		return 0;
}

static void
lmc_hssi_set_link_status(lmc_softc_t * const sc, int state)
{
	if (state == LMC_LINK_UP)
		sc->lmc_miireg16 |= LMC_MII16_HSSI_TA;
	else
		sc->lmc_miireg16 &= ~LMC_MII16_HSSI_TA;

	lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);
}

/*
 * 0 == 16bit, 1 == 32bit
 */
static void
lmc_hssi_set_crc_length(lmc_softc_t * const sc, int state)
{
	if (state == LMC_CTL_CRC_LENGTH_32) {
		/* 32 bit */
		sc->lmc_miireg16 |= LMC_MII16_HSSI_CRC;
		sc->ictl.crc_length = LMC_CTL_CRC_LENGTH_32;
	} else {
		/* 16 bit */
		sc->lmc_miireg16 &= ~LMC_MII16_HSSI_CRC;
		sc->ictl.crc_length = LMC_CTL_CRC_LENGTH_16;
	}

	lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);
}

static void
lmc_hssi_watchdog (lmc_softc_t * const sc)
{
	/* HSSI is blank */
}

static void
lmc_ds3_watchdog (lmc_softc_t * const sc)
{
	sc->lmc_miireg16 = lmc_mii_readreg (sc, 0, 16);
	if (sc->lmc_miireg16 & 0x0018)
	{
		printf("%s: AIS Received\n", sc->lmc_xname);
		lmc_led_on (sc, LMC_DS3_LED1 | LMC_DS3_LED2);
	}
}

/*
 *  DS3 methods
 */

/*
 * Set cable length
 */
static void
lmc_ds3_set_100ft(lmc_softc_t * const sc, int ie)
{
	if (ie == LMC_CTL_CABLE_LENGTH_GT_100FT) {
		sc->lmc_miireg16 &= ~LMC_MII16_DS3_ZERO;
		sc->ictl.cable_length = LMC_CTL_CABLE_LENGTH_GT_100FT;
	} else if (ie == LMC_CTL_CABLE_LENGTH_LT_100FT) {
		sc->lmc_miireg16 |= LMC_MII16_DS3_ZERO;
		sc->ictl.cable_length = LMC_CTL_CABLE_LENGTH_LT_100FT;
	}
	lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);
}

static void
lmc_ds3_default(lmc_softc_t * const sc)
{
	sc->lmc_miireg16 = LMC_MII16_LED_ALL;

	sc->lmc_media->set_link_status(sc, LMC_LINK_DOWN);
	sc->lmc_media->set_cable_length(sc, LMC_CTL_CABLE_LENGTH_LT_100FT);
	sc->lmc_media->set_scrambler(sc, LMC_CTL_OFF);
	sc->lmc_media->set_crc_length(sc, LMC_CTL_CRC_LENGTH_16);
}

/*
 * Given a user provided state, set ourselves up to match it.  This will
 * always reset the card if needed.
 */
static void
lmc_ds3_set_status(lmc_softc_t * const sc, lmc_ctl_t *ctl)
{
	if (ctl == NULL) {
		sc->lmc_media->set_cable_length(sc, sc->ictl.cable_length);
		sc->lmc_media->set_scrambler(sc, sc->ictl.scrambler_onoff);
		lmc_set_protocol(sc, NULL);

		return;
	}

	/*
	 * check for change in cable length setting
	 */
	if (ctl->cable_length && !sc->ictl.cable_length)
		lmc_ds3_set_100ft(sc, LMC_CTL_CABLE_LENGTH_GT_100FT);
	else if (!ctl->cable_length && sc->ictl.cable_length)
		lmc_ds3_set_100ft(sc, LMC_CTL_CABLE_LENGTH_LT_100FT);

	/*
	 * Check for change in scrambler setting (requires reset)
	 */
	if (ctl->scrambler_onoff && !sc->ictl.scrambler_onoff)
		lmc_ds3_set_scram(sc, LMC_CTL_ON);
	else if (!ctl->scrambler_onoff && sc->ictl.scrambler_onoff)
		lmc_ds3_set_scram(sc, LMC_CTL_OFF);

	lmc_set_protocol(sc, ctl);
}

static void
lmc_ds3_init(lmc_softc_t * const sc)
{
	int i;

	sc->ictl.cardtype = LMC_CTL_CARDTYPE_LMC5245;

	/* writes zeros everywhere */
	for (i = 0 ; i < 21 ; i++) {
		lmc_mii_writereg(sc, 0, 17, i);
		lmc_mii_writereg(sc, 0, 18, 0);
	}

	/* set some essential bits */
	lmc_mii_writereg(sc, 0, 17, 1);
	lmc_mii_writereg(sc, 0, 18, 0x05);	/* ser, xtx */

	lmc_mii_writereg(sc, 0, 17, 5);
	lmc_mii_writereg(sc, 0, 18, 0x80);	/* emode */

	lmc_mii_writereg(sc, 0, 17, 14);
	lmc_mii_writereg(sc, 0, 18, 0x30);	/* rcgen, tcgen */

	/* clear counters and latched bits */
	for (i = 0 ; i < 21 ; i++) {
		lmc_mii_writereg(sc, 0, 17, i);
		lmc_mii_readreg(sc, 0, 18);
	}
}

/*
 * 1 == DS3 payload scrambled, 0 == not scrambled
 */
static void
lmc_ds3_set_scram(lmc_softc_t * const sc, int ie)
{
	if (ie == LMC_CTL_ON) {
		sc->lmc_miireg16 |= LMC_MII16_DS3_SCRAM;
		sc->ictl.scrambler_onoff = LMC_CTL_ON;
	} else {
		sc->lmc_miireg16 &= ~LMC_MII16_DS3_SCRAM;
		sc->ictl.scrambler_onoff = LMC_CTL_OFF;
	}
	lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);
}

/*
 * return hardware link status.
 * 0 == link is down, 1 == link is up.
 */
static int
lmc_ds3_get_link_status(lmc_softc_t * const sc)
{
	u_int16_t link_status;

	lmc_mii_writereg(sc, 0, 17, 7);
	link_status = lmc_mii_readreg(sc, 0, 18);

	if ((link_status & LMC_FRAMER_REG0_DLOS) == 0)
		return 1;
	else
		return 0;
}

/*
 * 0 == 16bit, 1 == 32bit
 */
static void
lmc_ds3_set_crc_length(lmc_softc_t * const sc, int state)
{
	if (state == LMC_CTL_CRC_LENGTH_32) {
		/* 32 bit */
		sc->lmc_miireg16 |= LMC_MII16_DS3_CRC;
		sc->ictl.crc_length = LMC_CTL_CRC_LENGTH_32;
	} else {
		/* 16 bit */
		sc->lmc_miireg16 &= ~LMC_MII16_DS3_CRC;
		sc->ictl.crc_length = LMC_CTL_CRC_LENGTH_16;
	}

	lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);
}


/*
 *  SSI methods
 */

static void
lmc_ssi_init(lmc_softc_t * const sc)
{
	u_int16_t mii17;
	int cable;

	sc->ictl.cardtype = LMC_CTL_CARDTYPE_LMC1000;

	mii17 = lmc_mii_readreg(sc, 0, 17);

        cable = (mii17 & LMC_MII17_SSI_CABLE_MASK) >> LMC_MII17_SSI_CABLE_SHIFT;
	sc->ictl.cable_type = cable;

        lmc_gpio_mkoutput(sc, LMC_GEP_SSI_TXCLOCK);
}

static void
lmc_ssi_default(lmc_softc_t * const sc)
{
	sc->lmc_miireg16 = LMC_MII16_LED_ALL;

	/*
	 * make TXCLOCK always be an output
	 */
        lmc_gpio_mkoutput(sc, LMC_GEP_SSI_TXCLOCK);

	sc->lmc_media->set_link_status(sc, LMC_LINK_DOWN);
	sc->lmc_media->set_clock_source(sc, LMC_CTL_CLOCK_SOURCE_EXT);
	sc->lmc_media->set_speed(sc, NULL);
	sc->lmc_media->set_crc_length(sc, LMC_CTL_CRC_LENGTH_16);
}

/*
 * Given a user provided state, set ourselves up to match it.  This will
 * always reset the card if needed.
 */
static void
lmc_ssi_set_status(lmc_softc_t * const sc, lmc_ctl_t *ctl)
{
	if (ctl == NULL) {
		sc->lmc_media->set_clock_source(sc, sc->ictl.clock_source);
		sc->lmc_media->set_speed(sc, &sc->ictl);
		lmc_set_protocol(sc, NULL);

		return;
	}

	/*
	 * check for change in clock source
	 */
	if (ctl->clock_source == LMC_CTL_CLOCK_SOURCE_INT
            && sc->ictl.clock_source == LMC_CTL_CLOCK_SOURCE_EXT) {
		sc->lmc_media->set_clock_source(sc, LMC_CTL_CLOCK_SOURCE_INT);
		sc->lmc_timing = LMC_CTL_CLOCK_SOURCE_INT;
        } else if (ctl->clock_source == LMC_CTL_CLOCK_SOURCE_EXT
                 && sc->ictl.clock_source == LMC_CTL_CLOCK_SOURCE_INT) {
		sc->lmc_media->set_clock_source(sc, LMC_CTL_CLOCK_SOURCE_EXT);
		sc->lmc_timing = LMC_CTL_CLOCK_SOURCE_EXT;
	}

	if (ctl->clock_rate != sc->ictl.clock_rate)
		sc->lmc_media->set_speed(sc, ctl);

	lmc_set_protocol(sc, ctl);
}

/*
 * 1 == internal, 0 == external
 */
static void
lmc_ssi_set_clock(lmc_softc_t * const sc, int ie)
{
	if (ie == LMC_CTL_CLOCK_SOURCE_EXT) {
                sc->lmc_gpio &= ~(LMC_GEP_SSI_TXCLOCK);
		LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);
		sc->ictl.clock_source = LMC_CTL_CLOCK_SOURCE_EXT;
		printf(LMC_PRINTF_FMT ": clock external\n",
		       LMC_PRINTF_ARGS);
	} else {
                sc->lmc_gpio |= LMC_GEP_SSI_TXCLOCK;
		LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);
		sc->ictl.clock_source = LMC_CTL_CLOCK_SOURCE_INT;
		printf(LMC_PRINTF_FMT ": clock internal\n",
		       LMC_PRINTF_ARGS);
	}
}

static void
lmc_ssi_set_speed(lmc_softc_t * const sc, lmc_ctl_t *ctl)
{
	lmc_ctl_t *ictl = &sc->ictl;
	lmc_av9110_t *av;

        /* original settings for clock rate of:
         *  100 KHz (8,25,0,0,2) were incorrect
         *  they should have been 80,125,1,3,3
         *  There are 17 param combinations to produce this freq.
         *  For 1.5 MHz use 120,100,1,1,2 (226 param. combinations)
         */
	if (ctl == NULL) {
                av = &ictl->cardspec.ssi;
                ictl->clock_rate = 1500000;
		av->f = ictl->clock_rate;
                av->n = 120;
                av->m = 100;
                av->v = 1;
                av->x = 1;
		av->r = 2;

		write_av9110(sc, av->n, av->m, av->v, av->x, av->r);
		return;
	}

        av = &ctl->cardspec.ssi;

	if (av->f == 0)
		return;

	ictl->clock_rate = av->f;  /* really, this is the rate we are */
        ictl->cardspec.ssi = *av;

	write_av9110(sc, av->n, av->m, av->v, av->x, av->r);
}

/*
 * return hardware link status.
 * 0 == link is down, 1 == link is up.
 */
static int
lmc_ssi_get_link_status(lmc_softc_t * const sc)
{
	u_int16_t link_status;

	/*
	 * missing CTS?  Hmm.  If we require CTS on, we may never get the
	 * link to come up, so omit it in this test.
	 *
	 * Also, it seems that with a loopback cable, DCD isn't asserted,
	 * so just check for things like this:
	 *	DSR _must_ be asserted.
	 *	One of DCD or CTS must be asserted.
	 */

#ifdef CONFIG_LMC_IGNORE_HARDWARE_HANDSHAKE
        link_status = LMC_CSR_READ(sc, csr_gp_timer);
        link_status = 0x0000ffff - ( link_status & 0x0000ffff);

        return( link_status );
#else  

	link_status = lmc_mii_readreg(sc, 0, 16);

        if ((link_status & LMC_MII16_SSI_DSR) == 0)
		return (0);

        if ((link_status & (LMC_MII16_SSI_CTS | LMC_MII16_SSI_DCD)) == 0)
		return (0);

	return (1);
#endif
}

static void
lmc_ssi_set_link_status(lmc_softc_t * const sc, int state)
{
	if (state == LMC_LINK_UP) {
                sc->lmc_miireg16 |= (LMC_MII16_SSI_DTR | LMC_MII16_SSI_RTS);
		printf(LMC_PRINTF_FMT ": asserting DTR and RTS\n",
		       LMC_PRINTF_ARGS);
	} else {
                sc->lmc_miireg16 &= ~(LMC_MII16_SSI_DTR | LMC_MII16_SSI_RTS);
		printf(LMC_PRINTF_FMT ": deasserting DTR and RTS\n",
		       LMC_PRINTF_ARGS);
	}

	lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);

}

/*
 * 0 == 16bit, 1 == 32bit
 */
static void
lmc_ssi_set_crc_length(lmc_softc_t * const sc, int state)
{
	if (state == LMC_CTL_CRC_LENGTH_32) {
		/* 32 bit */
                sc->lmc_miireg16 |= LMC_MII16_SSI_CRC;
		sc->ictl.crc_length = LMC_CTL_CRC_LENGTH_32;
                sc->lmc_crcSize = LMC_CTL_CRC_BYTESIZE_4;

	} else {
		/* 16 bit */
                sc->lmc_miireg16 &= ~LMC_MII16_SSI_CRC;
		sc->ictl.crc_length = LMC_CTL_CRC_LENGTH_16;
                sc->lmc_crcSize = LMC_CTL_CRC_BYTESIZE_2;
	}

	lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);
}

/*
 * These are bits to program the ssi frequency generator
 */
static inline void
write_av9110_bit(lmc_softc_t *sc, int c)
{
	/*
	 * set the data bit as we need it.
	 */
	sc->lmc_gpio &= ~(LMC_GEP_SERIALCLK);
	if (c & 0x01)
		sc->lmc_gpio |= LMC_GEP_SERIAL;
	else
		sc->lmc_gpio &= ~(LMC_GEP_SERIAL);
	LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);

	/*
	 * set the clock to high
	 */
	sc->lmc_gpio |= LMC_GEP_SERIALCLK;
	LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);

	/*
	 * set the clock to low again.
	 */
	sc->lmc_gpio &= ~(LMC_GEP_SERIALCLK);
	LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);
}

static void
write_av9110(lmc_softc_t *sc, u_int32_t n, u_int32_t m, u_int32_t v,
	     u_int32_t x, u_int32_t r)
{
	int i;

#if 0
	printf(LMC_PRINTF_FMT ": speed %u, %d %d %d %d %d\n",
	       LMC_PRINTF_ARGS, sc->ictl.clock_rate,
	       n, m, v, x, r);
#endif

        sc->lmc_gpio |= LMC_GEP_SSI_GENERATOR;
	sc->lmc_gpio &= ~(LMC_GEP_SERIAL | LMC_GEP_SERIALCLK);
	LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);

	/*
	 * Set the TXCLOCK, GENERATOR, SERIAL, and SERIALCLK
	 * as outputs.
	 */
	lmc_gpio_mkoutput(sc, (LMC_GEP_SERIAL | LMC_GEP_SERIALCLK
                               | LMC_GEP_SSI_GENERATOR));

        sc->lmc_gpio &= ~(LMC_GEP_SSI_GENERATOR);
	LMC_CSR_WRITE(sc, csr_gp, sc->lmc_gpio);

	/*
	 * a shifting we will go...
	 */
	for (i = 0 ; i < 7 ; i++)
		write_av9110_bit(sc, n >> i);
	for (i = 0 ; i < 7 ; i++)
		write_av9110_bit(sc, m >> i);
	for (i = 0 ; i < 1 ; i++)
		write_av9110_bit(sc, v >> i);
	for (i = 0 ; i < 2 ; i++)
		write_av9110_bit(sc, x >> i);
	for (i = 0 ; i < 2 ; i++)
		write_av9110_bit(sc, r >> i);
	for (i = 0 ; i < 5 ; i++)
		write_av9110_bit(sc, 0x17 >> i);

	/*
	 * stop driving serial-related signals
	 */
	lmc_gpio_mkinput(sc,
			 (LMC_GEP_SERIAL | LMC_GEP_SERIALCLK
                          | LMC_GEP_SSI_GENERATOR));
}

static void
lmc_ssi_watchdog (lmc_softc_t * const sc)
{
	u_int16_t mii17;
	struct ssicsr2 {
		unsigned short dtr:1, dsr:1, rts:1, cable:3, crc:1, led0:1,
		led1:1, led2:1, led3:1, fifo:1, ll:1, rl:1, tm:1, loop:1;
	};
	struct ssicsr2 *ssicsr;
	mii17 = lmc_mii_readreg (sc, 0, 17);
	ssicsr = (struct ssicsr2 *) &mii17;
	if (ssicsr->cable == 7) {
		lmc_led_off (sc, LMC_MII16_LED2);
	}
	else {
		lmc_led_on (sc, LMC_MII16_LED2);
	}

}


/*
 *  T1 methods
 */

/*
 * The framer regs are multiplexed through MII regs 17 & 18
 *  write the register address to MII reg 17 and the *  data to MII reg 18. */
static void lmc_t1_write(lmc_softc_t * const sc, int a, int d)
{
        lmc_mii_writereg(sc, 0, 17, a);        
	lmc_mii_writereg(sc, 0, 18, d);
}

static int lmc_t1_read(lmc_softc_t * const sc, int a)
{
	lmc_mii_writereg(sc, 0, 17, a);
	return lmc_mii_readreg(sc, 0, 18);
}

static void
   lmc_t1_init(lmc_softc_t * const sc)
{
        u_int16_t mii16;
        int     i;

        sc->ictl.cardtype = LMC_CTL_CARDTYPE_LMC1200;
        mii16 = lmc_mii_readreg(sc, 0, 16);

	mii16 &= ~LMC_MII16_T1_XOE;
	lmc_mii_writereg (sc, 0, 16, mii16);
	sc->lmc_miireg16 = mii16;

        /* reset 8370 */
        mii16 &= ~LMC_MII16_T1_RST;
        lmc_mii_writereg(sc, 0, 16, mii16 | LMC_MII16_T1_RST);
        lmc_mii_writereg(sc, 0, 16, mii16);

        /* set T1 or E1 line impedance */
        /* mii16 &= ~LMC_MII16_T1_Z; */
        mii16 |= LMC_MII16_T1_Z;
        lmc_mii_writereg(sc, 0, 16, mii16);

	/* Standard LMC1200 init code */
        lmc_t1_write(sc, 0x01, 0x1B);  /* CR0     - primary control          */
        lmc_t1_write(sc, 0x02, 0x42);  /* JAT_CR  - jitter atten config      */
        lmc_t1_write(sc, 0x14, 0x00);  /* LOOP    - loopback config          */
        lmc_t1_write(sc, 0x15, 0x00);  /* DL3_TS  - xtrnl datalink timeslot  */
        lmc_t1_write(sc, 0x18, 0xFF);  /* PIO     - programmable I/O         */
        lmc_t1_write(sc, 0x19, 0x30);  /* POE     - programmable OE          */
        lmc_t1_write(sc, 0x1A, 0x0F);  /* CMUX    - clock input mux          */
        lmc_t1_write(sc, 0x20, 0x41);  /* LIU_CR  - RX LIU config            */
        lmc_t1_write(sc, 0x22, 0x76);  /* RLIU_CR - RX LIU config            */
        lmc_t1_write(sc, 0x40, 0x03);  /* RCR0    - RX config                */
        lmc_t1_write(sc, 0x45, 0x00);  /* RALM    - RX alarm config          */
        lmc_t1_write(sc, 0x46, 0x05);  /* LATCH   - RX alarm/err/cntr latch  */
        lmc_t1_write(sc, 0x68, 0x40);  /* TLIU_CR - TX LIU config            */
        lmc_t1_write(sc, 0x70, 0x0D);  /* TCR0    - TX framer config         */
        lmc_t1_write(sc, 0x71, 0x05);  /* TCR1    - TX config                */
        lmc_t1_write(sc, 0x72, 0x0B);  /* TFRM    - TX frame format          */
        lmc_t1_write(sc, 0x73, 0x00);  /* TERROR  - TX error insert          */
        lmc_t1_write(sc, 0x74, 0x00);  /* TMAN    - TX manual Sa/FEBE config */
        lmc_t1_write(sc, 0x75, 0x00);  /* TALM    - TX alarm signal config   */
        lmc_t1_write(sc, 0x76, 0x00);  /* TPATT   - TX test pattern config   */
        lmc_t1_write(sc, 0x77, 0x00);  /* TLB     - TX inband loopback confg */
        lmc_t1_write(sc, 0x90, 0x05);  /* CLAD_CR - clock rate adapter confg */
        lmc_t1_write(sc, 0x91, 0x05);  /* CSEL    - clad freq sel            */
        lmc_t1_write(sc, 0xA6, 0x00);  /* DL1_CTL - DL1 control              */
        lmc_t1_write(sc, 0xB1, 0x00);  /* DL2_CTL - DL2 control              */
        lmc_t1_write(sc, 0xD0, 0x47);  /* SBI_CR  - sys bus iface config     */
        lmc_t1_write(sc, 0xD1, 0x70);  /* RSB_CR  - RX sys bus config        */
        lmc_t1_write(sc, 0xD4, 0x30);  /* TSB_CR  - TX sys bus config        */
        for (i=0; i<32; i++)
        {
                lmc_t1_write(sc, 0x0E0+i, 0x00); /*SBCn sysbus perchannel ctl */
                lmc_t1_write(sc, 0x100+i, 0x00); /* TPCn - TX per-channel ctl */
                lmc_t1_write(sc, 0x180+i, 0x00); /* RPCn - RX per-channel ctl */
        }
        for (i=1; i<25; i++)
	{                lmc_t1_write(sc, 0x0E0+i, 0x0D);
					/* SBCn - sys bus per-channel ctl    */
	}

	mii16 |= LMC_MII16_T1_XOE;
	lmc_mii_writereg(sc, 0, 16, mii16);
        sc->lmc_miireg16 = mii16;
}

static void   lmc_t1_default(lmc_softc_t * const sc)
{
        sc->lmc_miireg16 = LMC_MII16_LED_ALL;
        sc->lmc_media->set_link_status(sc, LMC_LINK_DOWN);
        sc->lmc_media->set_circuit_type(sc, LMC_CTL_CIRCUIT_TYPE_T1);
        sc->lmc_media->set_crc_length(sc, LMC_CTL_CRC_LENGTH_16);
}

/*
 * Given a user provided state, set ourselves up to match it.  This will
 * always reset the card if needed.
 */

static void
lmc_t1_set_status(lmc_softc_t * const sc, lmc_ctl_t *ctl){
	if (ctl == NULL) {
		sc->lmc_media->set_circuit_type(sc, sc->ictl.circuit_type);
		lmc_set_protocol(sc, NULL);

		return;
	}

        /*
         * check for change in circuit type
	 */

	if (ctl->circuit_type == LMC_CTL_CIRCUIT_TYPE_T1
		&& sc->ictl.circuit_type == LMC_CTL_CIRCUIT_TYPE_E1)
		sc->lmc_media->set_circuit_type(sc,LMC_CTL_CIRCUIT_TYPE_E1 );
	else if (ctl->circuit_type == LMC_CTL_CIRCUIT_TYPE_E1
		&& sc->ictl.circuit_type == LMC_CTL_CIRCUIT_TYPE_T1)
		sc->lmc_media->set_circuit_type(sc, LMC_CTL_CIRCUIT_TYPE_T1);
	lmc_set_protocol(sc, ctl);
}

/*
 * return hardware link status.
 * 0 == link is down, 1 == link is up.
 */

static int
lmc_t1_get_link_status(lmc_softc_t * const sc){
	u_int16_t link_status;
	lmc_mii_writereg(sc, 0, 17, T1FRAMER_ALARM1_STATUS );
	link_status = lmc_mii_readreg(sc, 0, 18);

        /*
	 * LMC 1200 LED definitions
         * led0 yellow = far-end adapter is in Red alarm condition
  	 * led1 blue = received an Alarm Indication signal (upstream failure)
         * led2 Green = power to adapter, Gate Array loaded & driver attached
         * led3 red = Loss of Signal (LOS) or out of frame (OOF) conditions
	 * detected on T3 receive signal
         */

        /* detect a change in Blue alarm indication signal */

        if( (sc->t1_alarm1_status & T1F_RAIS) != (link_status & T1F_RAIS) )
        {
                if( link_status & T1F_RAIS )
                {                        /* turn on blue LED */
                        printf("%s: link status: RAIS turn ON Blue %x\n", sc->lmc_xname, link_status); /* DEBUG */
                        lmc_led_on(sc, LMC_DS3_LED1);
                }
                else
                {                        /* turn off blue LED */
                        printf("%s: link status: RAIS turn OFF Blue %x\n", sc->lmc_xname, link_status ); /* DEBUG */
			lmc_led_off(sc, LMC_DS3_LED1);
                }       
	}
        /*
	 * T1F_RYEL wiggles quite a bit,
	 *  taking it out until I understand why -baz 6/22/99
         */
                /* Yellow alarm indication */
                if( (sc->t1_alarm1_status &  T1F_RMYEL) !=
                        (link_status & T1F_RMYEL) )
                {
		if( (link_status & (T1F_RYEL | T1F_RMYEL)) == 0 )
                        {
				/* turn off yellow LED */
       		                printf("%s: link status: RYEL turn OFF Yellow %x\n", sc->lmc_xname, link_status); /* DEBUG */
                    	        lmc_led_off(sc, LMC_DS3_LED0);

                        }
                        else
                        {
                                /* turn on yellow LED */                         
                                printf("%s: link status: RYEL turn ON Yellow %x\n", sc->lmc_xname, link_status); /* DEBUG */
                                lmc_led_on(sc, LMC_DS3_LED0);
                        }
                }


        sc->t1_alarm1_status = link_status;

        lmc_mii_writereg(sc, 0, 17, T1FRAMER_ALARM2_STATUS );
        sc->t1_alarm2_status = lmc_mii_readreg(sc, 0, 18);

        /* link status based upon T1 receive loss of frame or
         * loss of signal - RED alarm indication */
        if ((link_status & (T1F_RLOF | T1F_RLOS)) == 0)
                return 1;
        else
                return 0;
}

/*
 * 1 == T1 Circuit Type , 0 == E1 Circuit Type
 */
static void
   lmc_t1_set_circuit_type(lmc_softc_t * const sc, int ie)
{
        if (ie == LMC_CTL_CIRCUIT_TYPE_T1)
        {
                sc->lmc_miireg16 |= LMC_MII16_T1_Z;
                sc->ictl.circuit_type = LMC_CTL_CIRCUIT_TYPE_T1;
        } else {                sc->lmc_miireg16 &= ~LMC_MII16_T1_Z;
                sc->ictl.scrambler_onoff = LMC_CTL_CIRCUIT_TYPE_E1;
        }
        lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);
}

/*
 * 0 == 16bit, 1 == 32bit */
static void
   lmc_t1_set_crc_length(lmc_softc_t * const sc, int state)
{
        if (state == LMC_CTL_CRC_LENGTH_32) {
                /* 32 bit */
                sc->lmc_miireg16 |= LMC_MII16_T1_CRC;
                sc->ictl.crc_length = LMC_CTL_CRC_LENGTH_32;
                sc->lmc_crcSize = LMC_CTL_CRC_BYTESIZE_4;

        } else {
                /* 16 bit */
                sc->lmc_miireg16 &= ~LMC_MII16_T1_CRC;
                sc->ictl.crc_length = LMC_CTL_CRC_LENGTH_16;
                sc->lmc_crcSize = LMC_CTL_CRC_BYTESIZE_2;

        }

        lmc_mii_writereg(sc, 0, 16, sc->lmc_miireg16);
}

/*
 * 1 == internal, 0 == external
 */
static void
lmc_t1_set_clock (lmc_softc_t * const sc, int ie)
{
	if (ie == LMC_CTL_CLOCK_SOURCE_EXT) {
		sc->lmc_gpio &= ~(LMC_GEP_SSI_TXCLOCK);
		LMC_CSR_WRITE (sc, csr_gp, sc->lmc_gpio);
		sc->ictl.clock_source = LMC_CTL_CLOCK_SOURCE_EXT;
		printf (LMC_PRINTF_FMT ": clock external\n", LMC_PRINTF_ARGS);
	}
	else {
		sc->lmc_gpio |= LMC_GEP_SSI_TXCLOCK;
		LMC_CSR_WRITE (sc, csr_gp, sc->lmc_gpio);
		sc->ictl.clock_source = LMC_CTL_CLOCK_SOURCE_INT;
		printf (LMC_PRINTF_FMT ": clock internal\n", LMC_PRINTF_ARGS);
	}
}

static void
lmc_t1_watchdog(lmc_softc_t * const sc)
{
	int t1stat;

	/* read alarm 1 status (receive) */
	t1stat = lmc_t1_read (sc, 0x47);
	/* blue alarm -- RAIS */
	if (t1stat & 0x08) {
		if (sc->lmc_blue != 1)
			printf ("%s: AIS Received\n", sc->lmc_xname);
		lmc_led_on (sc, LMC_DS3_LED1 | LMC_DS3_LED2);
		sc->lmc_blue = 1;
	} else {
		if (sc->lmc_blue == 1)
			printf ("%s: AIS ok\n", sc->lmc_xname);
		lmc_led_off (sc, LMC_DS3_LED1);
		lmc_led_on (sc, LMC_DS3_LED2);
		sc->lmc_blue = 0;
	}

	/* Red alarm -- LOS | LOF */
	if (t1stat & 0x04) {
		/* Only print the error once */
		if (sc->lmc_red != 1)
			printf ("%s: Red Alarm\n", sc->lmc_xname);
		lmc_led_on (sc, LMC_DS3_LED2 | LMC_DS3_LED3);
		sc->lmc_red = 1;
	} else { 
		if (sc->lmc_red == 1)
			printf ("%s: Red Alarm ok\n", sc->lmc_xname);
	lmc_led_off (sc, LMC_DS3_LED3);
	lmc_led_on (sc, LMC_DS3_LED2);
	sc->lmc_red = 0;
	}

	/* check for Receive Multiframe Yellow Alarm
	 * Ignore Receive Yellow Alarm
	 */
	if (t1stat & 0x80) {
		if (sc->lmc_yel != 1) {
			printf ("%s: Receive Yellow Alarm\n", sc->lmc_xname);
		}
			lmc_led_on (sc, LMC_DS3_LED0 | LMC_DS3_LED2);
			sc->lmc_yel = 1;
	}
	else {
		if (sc->lmc_yel == 1)
		printf ("%s: Yellow Alarm ok\n", sc->lmc_xname);
		lmc_led_off (sc, LMC_DS3_LED0);
		lmc_led_on (sc, LMC_DS3_LED2);
		sc->lmc_yel = 0;
	}
}


static void
lmc_set_protocol(lmc_softc_t * const sc, lmc_ctl_t *ctl)
{
	if (ctl == 0) {
		sc->ictl.keepalive_onoff = LMC_CTL_ON;

		return;
	}

	if (ctl->keepalive_onoff != sc->ictl.keepalive_onoff) {
		switch (ctl->keepalive_onoff) {
		case LMC_CTL_ON:
			printf(LMC_PRINTF_FMT ": enabling keepalive\n",
			       LMC_PRINTF_ARGS);
			sc->ictl.keepalive_onoff = LMC_CTL_ON;
			sc->lmc_sppp.pp_flags = PP_CISCO | PP_KEEPALIVE;
			break;
		case LMC_CTL_OFF:
			printf(LMC_PRINTF_FMT ": disabling keepalive\n",
			       LMC_PRINTF_ARGS);
			sc->ictl.keepalive_onoff = LMC_CTL_OFF;
			sc->lmc_sppp.pp_flags = PP_CISCO;
		}
	}
}
@


1.19
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 2
a2 2
/* $OpenBSD: if_lmc_media.c,v 1.18 2014/12/05 15:50:04 mpi Exp $ */
/* $Id: if_lmc_media.c,v 1.18 2014/12/05 15:50:04 mpi Exp $ */
@


1.18
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 2
a2 2
/* $OpenBSD: if_lmc_media.c,v 1.17 2010/04/08 00:23:53 tedu Exp $ */
/* $Id: if_lmc_media.c,v 1.17 2010/04/08 00:23:53 tedu Exp $ */
a71 1
#include <dev/ic/dc21040reg.h>
@


1.17
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 2
a2 2
/* $OpenBSD: if_lmc_media.c,v 1.16 2005/11/07 00:29:21 brad Exp $ */
/* $Id: if_lmc_media.c,v 1.16 2005/11/07 00:29:21 brad Exp $ */
d57 1
@


1.16
log
@first round of lmc(4) cleaning. removes a good portion of the ifdef
crud making this readable.

ok dlg@@
@
text
@d1 2
a2 2
/* $OpenBSD: if_lmc_media.c,v 1.15 2005/11/05 11:49:01 brad Exp $ */
/* $Id: if_lmc_media.c,v 1.15 2005/11/05 11:49:01 brad Exp $ */
a51 1
#include <sys/proc.h>	/* only for declaration of wakeup() used by vm.h */
@


1.15
log
@add bus_dma and big endian support.

From NetBSD

Thanks to Jason Ackley for testing on i386/amd64/sparc64
with both T1 and T3 cards.

"looks ok" dlg@@
@
text
@d1 2
a2 2
/* $OpenBSD: if_lmc_media.c,v 1.14 2004/05/12 06:35:11 tedu Exp $ */
/* $Id: if_lmc_media.c,v 1.14 2004/05/12 06:35:11 tedu Exp $ */
d42 2
a52 3
#if defined(__FreeBSD__)
#include <machine/clock.h>
#elif defined(__bsdi__) || defined(__NetBSD__) || defined(__OpenBSD__)
a53 9
#endif

#if defined(__NetBSD__)
#include <dev/pci/pcidevs.h>
#include "rnd.h"
#if NRND > 0
#include <sys/rnd.h>
#endif
#endif
a54 1
#if defined(__OpenBSD__)
a55 1
#endif
a61 1
#include "bpfilter.h"
a65 1
#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
a66 1
#endif
d68 1
a68 32
#if defined(__bsdi__)
#if INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#endif

#include <net/netisr.h>
#include <net/if.h>
#include <net/netisr.h>
#include <net/if_types.h>
#include <net/if_p2p.h>
#include <net/if_c_hdlc.h>
#endif

#if defined(__FreeBSD__)
#include <vm/pmap.h>
#include <pci.h>
#if NPCI > 0
#include <pci/pcivar.h>
#include <pci/dc21040reg.h>
#define INCLUDE_PATH_PREFIX "pci/"
#endif
#endif /* __FreeBSD__ */

#if defined(__bsdi__)
#include <i386/pci/ic/dc21040.h>
#include <i386/isa/isa.h>
#include <i386/isa/icu.h>
#include <i386/isa/dma.h>
#include <i386/isa/isavar.h>
#include <i386/pci/pci.h>
a69 8
#define	INCLUDE_PATH_PREFIX	"i386/pci/"
#endif /* __bsdi__ */

#if defined(__NetBSD__) || defined(__OpenBSD__)
#include <machine/bus.h>
#if defined(__alpha__) && defined(__NetBSD__)
#include <machine/intr.h>
#endif
a72 2
#define	INCLUDE_PATH_PREFIX	"dev/pci/"
#endif /* __NetBSD__ */
a73 9
/*
 * Sigh.  Every OS puts these in different places.  NetBSD and FreeBSD use
 * a C preprocessor that allows this hack, but BSDI does not.
 */
#if defined(__NetBSD__) || defined(__FreeBSD__)
#include INCLUDE_PATH_PREFIX "if_lmc_types.h"
#include INCLUDE_PATH_PREFIX "if_lmcioctl.h"
#include INCLUDE_PATH_PREFIX "if_lmcvar.h"
#elif defined(__OpenBSD__)
a76 5
#else /* BSDI */
#include "i386/pci/if_lmc_types.h"
#include "i386/pci/if_lmcioctl.h"
#include "i386/pci/if_lmcvar.h"
#endif
a1114 1
#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)
a1129 1
#endif
@


1.14
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 2
a2 2
/* $OpenBSD: if_lmc_media.c,v 1.13 2003/02/11 19:20:27 mickey Exp $ */
/* $Id: if_lmc_media.c,v 1.13 2003/02/11 19:20:27 mickey Exp $ */
a77 2

#include <uvm/uvm_extern.h>
@


1.13
log
@be consistant on Hz vs hz
@
text
@d1 2
a2 2
/* $OpenBSD: if_lmc_media.c,v 1.12 2001/11/06 19:53:19 miod Exp $ */
/* $Id: if_lmc_media.c,v 1.12 2001/11/06 19:53:19 miod Exp $ */
a76 1
#include <net/bpfdesc.h>
@


1.12
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 2
a2 2
/* $OpenBSD: if_lmc_media.c,v 1.11 2001/09/11 20:05:25 miod Exp $ */
/* $Id: if_lmc_media.c,v 1.11 2001/09/11 20:05:25 miod Exp $ */
d664 1
a664 1
         *  100 Khz (8,25,0,0,2) were incorrect
d667 1
a667 1
         *  For 1.5 Mhz use 120,100,1,1,2 (226 param. combinations)
@


1.12.2.1
log
@sync
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $Id$ */
d664 1
a664 1
         *  100 KHz (8,25,0,0,2) were incorrect
d667 1
a667 1
         *  For 1.5 MHz use 120,100,1,1,2 (226 param. combinations)
@


1.11
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 2
a2 2
/* $OpenBSD: if_lmc_media.c,v 1.10 2001/08/23 14:17:07 aaron Exp $ */
/* $Id: if_lmc_media.c,v 1.10 2001/08/23 14:17:07 aaron Exp $ */
d80 1
a80 1
#include <vm/vm.h>
@


1.10
log
@recieve -> receive
@
text
@d1 2
a2 2
/* $OpenBSD: if_lmc_media.c,v 1.9 2001/08/12 20:33:50 mickey Exp $ */
/* $Id: if_lmc_media.c,v 1.9 2001/08/12 20:33:50 mickey Exp $ */
a80 1
#include <vm/vm_kern.h>
@


1.9
log
@absolutely no need to include vm_parm.h after vm.h
@
text
@d1 2
a2 2
/* $OpenBSD: if_lmc_media.c,v 1.8 2001/07/09 13:13:43 espie Exp $ */
/* $Id: if_lmc_media.c,v 1.8 2001/07/09 13:13:43 espie Exp $ */
d1134 1
a1134 1
			printf ("%s: AIS Recieved\n", sc->lmc_xname);
d1160 2
a1161 2
	/* check for Recieve Multiframe Yellow Alarm
	 * Ignore Recieve Yellow Alarm
d1165 1
a1165 1
			printf ("%s: Recieve Yellow Alarm\n", sc->lmc_xname);
@


1.8
log
@Remove dubious #include MACRO "string" construct (non-ANSI)
and use the more correct #include <file.h> style.

From discussion with millert@@.
@
text
@d1 2
a2 2
/* $OpenBSD: if_lmc_media.c,v 1.7 2001/06/27 06:02:50 nate Exp $ */
/* $Id: if_lmc_media.c,v 1.7 2001/06/27 06:02:50 nate Exp $ */
a80 1
#include <vm/vm_param.h>
@


1.7
log
@missed one
@
text
@d1 2
a2 2
/* $OpenBSD: if_lmc_media.c,v 1.6 2001/06/27 05:44:56 nate Exp $ */
/* $Id: if_lmc_media.c,v 1.6 2001/06/27 05:44:56 nate Exp $ */
d139 1
a139 1
#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)
d143 4
@


1.6
log
@recieve -> receive
@
text
@d1 2
a2 2
/* $OpenBSD: if_lmc_media.c,v 1.5 2001/05/14 17:29:11 chris Exp $ */
/* $Id: if_lmc_media.c,v 1.5 2001/05/14 17:29:11 chris Exp $ */
d1126 1
a1126 1
	/* read alarm 1 status (recieve) */
@


1.5
log
@From PR 1820 - initialize builin CSU/DSU card properly
@
text
@d1 2
a2 2
/* $OpenBSD: if_lmc_media.c,v 1.4 2000/02/06 17:57:56 chris Exp $ */
/* $Id: if_lmc_media.c,v 1.4 2000/02/06 17:57:56 chris Exp $ */
d410 1
a410 1
		printf("%s: AIS Recieved\n", sc->lmc_xname);
@


1.4
log
@missing \n on printf
@
text
@d1 2
a2 2
/* $OpenBSD: if_lmc_media.c,v 1.3 2000/02/01 18:01:41 chris Exp $ */
/* $Id: if_lmc_media.c,v 1.3 2000/02/01 18:01:41 chris Exp $ */
d897 4
d950 4
a953 3
        /*  XXX
        mii16 |= LMC_MII16_T1_XOE;        lmc_mii_writereg(sc, 0, 16, mii16);
        sc->lmc_miireg16 = mii16;        */
@


1.4.2.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/* $OpenBSD: if_lmc_media.c,v 1.4 2000/02/06 17:57:56 chris Exp $ */
/* $Id: if_lmc_media.c,v 1.4 2000/02/06 17:57:56 chris Exp $ */
d410 1
a410 1
		printf("%s: AIS Received\n", sc->lmc_xname);
a896 4
	mii16 &= ~LMC_MII16_T1_XOE;
	lmc_mii_writereg (sc, 0, 16, mii16);
	sc->lmc_miireg16 = mii16;

d946 3
a948 4

	mii16 |= LMC_MII16_T1_XOE;
	lmc_mii_writereg(sc, 0, 16, mii16);
        sc->lmc_miireg16 = mii16;
d1121 1
a1121 1
	/* read alarm 1 status (receive) */
@


1.4.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/* $OpenBSD: if_lmc_media.c,v 1.4.2.1 2001/07/04 10:42:15 niklas Exp $ */
/* $Id: if_lmc_media.c,v 1.4.2.1 2001/07/04 10:42:15 niklas Exp $ */
d81 2
d139 1
a139 1
#if defined(__NetBSD__) || defined(__FreeBSD__)
a142 4
#elif defined(__OpenBSD__)
#include <dev/pci/if_lmc_types.h>
#include <dev/pci/if_lmcioctl.h>
#include <dev/pci/if_lmcvar.h>
d1131 1
a1131 1
			printf ("%s: AIS Received\n", sc->lmc_xname);
d1157 2
a1158 2
	/* check for Receive Multiframe Yellow Alarm
	 * Ignore Receive Yellow Alarm
d1162 1
a1162 1
			printf ("%s: Receive Yellow Alarm\n", sc->lmc_xname);
@


1.4.2.3
log
@Merge in -current
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $Id: if_lmc_media.c,v 1.4.2.2 2001/10/31 03:22:46 nate Exp $ */
d80 1
a80 1
#include <uvm/uvm_extern.h>
@


1.4.2.4
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/* $Id$ */
d664 1
a664 1
         *  100 KHz (8,25,0,0,2) were incorrect
d667 1
a667 1
         *  For 1.5 MHz use 120,100,1,1,2 (226 param. combinations)
@


1.4.2.5
log
@Merge with the trunk
@
text
@d77 1
@


1.3
log
@general cleanup (remove LMC_IOMAPPED crud entirely)
add correct rcs tags
sync w/lmc's lmc_media.c regarding watchdog support
(So, the LEDs on the T1/T3 cards [the ones with built-in CSU/DSUs], and also
the DS1 "SSI" card should now change according to various line conditions, as
ths manual says they do)
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $Id: lmc_media.c,v 1.4 1999/11/24 11:49:57 asj Exp $ */
d1146 1
a1146 1
			printf ("%s: Red Alarm ok", sc->lmc_xname);
@


1.2
log
@Support LMC1200
Based on LMC's Linux code
@
text
@d1 2
a2 2
/* $OpenBSD $ */
/* $Id: if_lmc_media.c,v 1.23 1999/03/01 15:12:24 explorer Exp $ */
d173 1
d182 1
d192 1
d200 2
d221 2
a222 1
	lmc_dummy_set_1                 /* set T1 or E1 circuit type */
d236 2
a237 1
	lmc_dummy_set_1                 /* set T1 or E1 circuit type */
d251 2
a252 1
        lmc_dummy_set_1			/* set T1 or E1 circuit type */
d259 2
a260 2
        lmc_dummy_set_1,                /* set clock source */
        lmc_dummy_set2_1,                       /* set line speed */
d264 1
a264 1
        lmc_dummy_set_1,                /* set link status */
d266 2
a267 1
        lmc_t1_set_circuit_type /* set T1 or E1 circuit type */
d297 1
a297 1
	sc->lmc_media->set_link_status(sc, 0);
d371 1
a371 1
	if (state)
d398 16
d440 1
a440 1
	sc->lmc_media->set_link_status(sc, 0);
d594 1
a594 1
	sc->lmc_media->set_link_status(sc, 0);
d733 1
a733 1
	if (state) {
d848 21
a881 1
/* XXX future to be integtrated with if_lmc.c for alarms
a886 2
*/

d954 1
a954 1
        sc->lmc_media->set_link_status(sc, 0);
d1012 1
a1012 1
                        printf(" link status: RAIS turn ON Blue %x\n", link_status ); /* DEBUG */
d1017 1
a1017 1
                        printf(" link status: RAIS turn OFF Blue %x\n", link_status ); /* DEBUG */
d1032 1
a1032 1
       		                printf(" link status: RYEL turn OFF Yellow %x\n", link_status ); /* DEBUG */
d1039 1
a1039 1
                                printf(" link status: RYEL turn ON Yellow %x\n", link_status ); /* DEBUG */
d1095 76
@


1.1
log
@lmc driver; ported by chris@@dqc.org
@
text
@d1 2
a2 1
/*	$NetBSD: if_lmc_media.c,v 1.1 1999/03/25 03:32:43 explorer Exp $	*/
d9 2
d182 9
a193 2
static void	lmc_t1_set_clock(lmc_softc_t * const, int);
static void	lmc_t1_set_speed(lmc_softc_t * const, lmc_ctl_t *);
d195 1
a195 1
static void	lmc_t1_set_link_status(lmc_softc_t * const, int);
d216 1
d230 15
d251 2
a252 2
	lmc_t1_set_clock,		/* set clock source */
	lmc_t1_set_speed,		/* set line speed */
d256 1
a256 1
	lmc_t1_set_link_status,		/* set link status */
d258 1
d310 1
a310 1
	if (ctl->clock_source && !sc->ictl.clock_source)
d312 3
a314 1
	else if (!ctl->clock_source && sc->ictl.clock_source)
d316 1
d540 1
a540 1
 *  T1 methods
d544 1
a544 1
lmc_t1_init(lmc_softc_t * const sc)
d553 1
a553 1
	cable = (mii17 & LMC_MII17_T1_CABLE_MASK) >> LMC_MII17_T1_CABLE_SHIFT;
d556 1
a556 1
	lmc_gpio_mkoutput(sc, LMC_GEP_T1_TXCLOCK);
d560 1
a560 1
lmc_t1_default(lmc_softc_t * const sc)
d567 1
a567 1
	lmc_gpio_mkoutput(sc, LMC_GEP_T1_TXCLOCK);
d580 1
a580 1
lmc_t1_set_status(lmc_softc_t * const sc, lmc_ctl_t *ctl)
d594 1
a594 1
	    && sc->ictl.clock_source == LMC_CTL_CLOCK_SOURCE_EXT)
d596 3
a598 2
	else if (ctl->clock_source == LMC_CTL_CLOCK_SOURCE_EXT
		 && sc->ictl.clock_source == LMC_CTL_CLOCK_SOURCE_INT)
d600 2
d613 1
a613 1
lmc_t1_set_clock(lmc_softc_t * const sc, int ie)
d616 1
a616 1
		sc->lmc_gpio &= ~(LMC_GEP_T1_TXCLOCK);
d622 1
a622 1
		sc->lmc_gpio |= LMC_GEP_T1_TXCLOCK;
d631 1
a631 1
lmc_t1_set_speed(lmc_softc_t * const sc, lmc_ctl_t *ctl)
d636 6
d643 2
a644 2
		av = &ictl->cardspec.t1;
		ictl->clock_rate = 100000;
d646 4
a649 4
		av->n = 8;
		av->m = 25;
		av->v = 0;
		av->x = 0;
d656 1
a656 1
	av = &ctl->cardspec.t1;
d662 1
a662 1
	ictl->cardspec.t1 = *av;
d672 1
a672 1
lmc_t1_get_link_status(lmc_softc_t * const sc)
d685 8
d695 1
a695 1
	if ((link_status & LMC_MII16_T1_DSR) == 0)
d698 1
a698 1
	if ((link_status & (LMC_MII16_T1_CTS | LMC_MII16_T1_DCD)) == 0)
d702 1
d706 1
a706 1
lmc_t1_set_link_status(lmc_softc_t * const sc, int state)
d709 1
a709 1
		sc->lmc_miireg16 |= (LMC_MII16_T1_DTR | LMC_MII16_T1_RTS);
d713 1
a713 1
		sc->lmc_miireg16 &= ~(LMC_MII16_T1_DTR | LMC_MII16_T1_RTS);
d719 1
d726 1
a726 1
lmc_t1_set_crc_length(lmc_softc_t * const sc, int state)
d730 1
a730 1
		sc->lmc_miireg16 |= LMC_MII16_T1_CRC;
d732 2
d736 1
a736 1
		sc->lmc_miireg16 &= ~LMC_MII16_T1_CRC;
d738 1
d745 1
a745 1
 * These are bits to program the T1 frequency generator
d785 1
a785 1
	sc->lmc_gpio |= LMC_GEP_T1_GENERATOR;
d794 1
a794 1
			       | LMC_GEP_T1_GENERATOR));
d796 1
a796 1
	sc->lmc_gpio &= ~(LMC_GEP_T1_GENERATOR);
d820 231
a1050 1
			  | LMC_GEP_T1_GENERATOR));
@

