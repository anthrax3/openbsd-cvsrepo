head	1.24;
access;
symbols;
locks; strict;
comment	@ * @;


1.24
date	2012.10.29.18.36.42;	author mikeb;	state dead;
branches;
next	1.23;

1.23
date	2012.10.29.18.17.39;	author mikeb;	state Exp;
branches;
next	1.22;

1.22
date	2012.10.29.18.14.28;	author mikeb;	state Exp;
branches;
next	1.21;

1.21
date	2012.10.26.23.35.09;	author mikeb;	state Exp;
branches;
next	1.20;

1.20
date	2012.10.26.22.45.36;	author mikeb;	state Exp;
branches;
next	1.19;

1.19
date	2012.10.26.18.11.07;	author mikeb;	state Exp;
branches;
next	1.18;

1.18
date	2012.10.26.18.05.50;	author mikeb;	state Exp;
branches;
next	1.17;

1.17
date	2012.10.26.17.56.24;	author mikeb;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.15.19.23.23;	author mikeb;	state Exp;
branches;
next	1.15;

1.15
date	2012.10.12.18.24.31;	author mikeb;	state Exp;
branches;
next	1.14;

1.14
date	2012.10.12.17.41.40;	author mikeb;	state Exp;
branches;
next	1.13;

1.13
date	2012.10.12.15.16.45;	author mikeb;	state Exp;
branches;
next	1.12;

1.12
date	2012.10.11.16.38.10;	author mikeb;	state Exp;
branches;
next	1.11;

1.11
date	2012.10.11.16.33.57;	author mikeb;	state Exp;
branches;
next	1.10;

1.10
date	2012.08.09.19.23.35;	author mikeb;	state Exp;
branches;
next	1.9;

1.9
date	2012.08.09.19.19.49;	author mikeb;	state Exp;
branches;
next	1.8;

1.8
date	2012.08.09.19.03.14;	author mikeb;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.09.18.49.57;	author mikeb;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.09.12.43.46;	author mikeb;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.07.17.16.26;	author mikeb;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.06.21.55.31;	author mikeb;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.02.22.14.31;	author mikeb;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.02.22.06.29;	author mikeb;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.02.17.35.52;	author mikeb;	state Exp;
branches;
next	;


desc
@@


1.24
log
@merge oce.c into if_oce.c and rename oce{reg,var}.h to if_oce{reg,var}.h
@
text
@/* 	$OpenBSD: ocevar.h,v 1.23 2012/10/29 18:17:39 mikeb Exp $	*/

/*-
 * Copyright (C) 2012 Emulex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Emulex Corporation nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Contact Information:
 * freebsd-drivers@@emulex.com
 *
 * Emulex
 * 3333 Susan Street
 * Costa Mesa, CA 92626
 */

/* OCE device driver module component revision informaiton */
#define COMPONENT_REVISION		"4.2.127.0"

#define IS_BE(sc)	((sc->flags & OCE_FLAGS_BE2) | \
			 (sc->flags & OCE_FLAGS_BE3) ? 1 : 0)
#define IS_XE201(sc)	((sc->flags & OCE_FLAGS_XE201) ? 1 : 0)

/* proportion Service Level Interface queues */
#define OCE_MAX_UNITS			2
#define OCE_MAX_PPORT			OCE_MAX_UNITS
#define OCE_MAX_VPORT			OCE_MAX_UNITS

/* This should be powers of 2. Like 2,4,8 & 16 */
#define OCE_MAX_RSS			4 /* TODO: 8 */
#define OCE_LEGACY_MODE_RSS		4 /* For BE3 Legacy mode */

#define OCE_MIN_RQ			1
#define OCE_MIN_WQ			1

#define OCE_MAX_RQ			OCE_MAX_RSS + 1 /* one default queue */
#define OCE_MAX_WQ			8

#define OCE_MAX_EQ			32
#define OCE_MAX_CQ			OCE_MAX_RQ + OCE_MAX_WQ + 1 /* one MCC queue */
#define OCE_MAX_CQ_EQ			8 /* Max CQ that can attached to an EQ */

#define OCE_DEFAULT_WQ_EQD		80
#define OCE_MAX_PACKET_Q		16
#define OCE_RQ_BUF_SIZE			2048
#define OCE_LSO_MAX_SIZE		(64 * 1024)
#define LONG_TIMEOUT			30
#define OCE_MAX_JUMBO_FRAME_SIZE	16360
#define OCE_MAX_MTU			(OCE_MAX_JUMBO_FRAME_SIZE - \
					 ETHER_VLAN_ENCAP_LEN -     \
					 ETHER_HDR_LEN - ETHER_CRC_LEN)

#define OCE_MAX_TX_ELEMENTS		29
#define OCE_MAX_TX_DESC			1024
#define OCE_MAX_TX_SIZE			65535
#define OCE_MAX_RX_SIZE			4096
#define OCE_MAX_RQ_POSTS		255

#define RSS_ENABLE_IPV4			0x1
#define RSS_ENABLE_TCP_IPV4		0x2
#define RSS_ENABLE_IPV6			0x4
#define RSS_ENABLE_TCP_IPV6		0x8

/* flow control definitions */
#define OCE_FC_NONE			0x00000000
#define OCE_FC_TX			0x00000001
#define OCE_FC_RX			0x00000002
#define OCE_DEFAULT_FLOW_CONTROL	(OCE_FC_TX | OCE_FC_RX)

/* Interface capabilities to give device when creating interface */
#define  OCE_CAPAB_FLAGS 		(MBX_RX_IFACE_FLAGS_BROADCAST     | \
					 MBX_RX_IFACE_FLAGS_UNTAGGED      | \
					 MBX_RX_IFACE_FLAGS_PROMISC       | \
					 MBX_RX_IFACE_FLAGS_MCAST_PROMISC | \
					 MBX_RX_IFACE_FLAGS_RSS)
					/* MBX_RX_IFACE_FLAGS_RSS | \ */
					/* MBX_RX_IFACE_FLAGS_PASS_L3L4_ERR) */

/* Interface capabilities to enable by default (others set dynamically) */
#define  OCE_CAPAB_ENABLE		(MBX_RX_IFACE_FLAGS_BROADCAST | \
					 MBX_RX_IFACE_FLAGS_UNTAGGED)
					/* MBX_RX_IFACE_FLAGS_RSS        | \ */
					/* MBX_RX_IFACE_FLAGS_PASS_L3L4_ERR) */

#define ETH_ADDR_LEN			6
#define MAX_VLANFILTER_SIZE		64
#define MAX_VLANS			4096

#define BSWAP_8(x)		((x) & 0xff)
#define BSWAP_16(x)		((BSWAP_8(x) << 8) | BSWAP_8((x) >> 8))
#define BSWAP_32(x)		((BSWAP_16(x) << 16) | BSWAP_16((x) >> 16))
#define BSWAP_64(x)		((BSWAP_32(x) << 32) | BSWAP_32((x) >> 32))

#define for_all_wq_queues(sc, wq, i) 	\
		for (i = 0, wq = sc->wq[0]; i < sc->nwqs; i++, wq = sc->wq[i])
#define for_all_rq_queues(sc, rq, i) 	\
		for (i = 0, rq = sc->rq[0]; i < sc->nrqs; i++, rq = sc->rq[i])
#define for_all_eq_queues(sc, eq, i) 	\
		for (i = 0, eq = sc->eq[0]; i < sc->neqs; i++, eq = sc->eq[i])
#define for_all_cq_queues(sc, cq, i) 	\
		for (i = 0, cq = sc->cq[0]; i < sc->ncqs; i++, cq = sc->cq[i])

/* Flash specific */
#define IOCTL_COOKIE			"SERVERENGINES CORP"
#define MAX_FLASH_COMP			32

#define IMG_ISCSI			160
#define IMG_REDBOOT			224
#define IMG_BIOS			34
#define IMG_PXEBIOS			32
#define IMG_FCOEBIOS			33
#define IMG_ISCSI_BAK			176
#define IMG_FCOE			162
#define IMG_FCOE_BAK			178
#define IMG_NCSI			16
#define IMG_PHY				192
#define FLASHROM_OPER_FLASH		1
#define FLASHROM_OPER_SAVE		2
#define FLASHROM_OPER_REPORT		4
#define FLASHROM_OPER_FLASH_PHY		9
#define FLASHROM_OPER_SAVE_PHY		10
#define TN_8022				13

enum {
	PHY_TYPE_CX4_10GB = 0,
	PHY_TYPE_XFP_10GB,
	PHY_TYPE_SFP_1GB,
	PHY_TYPE_SFP_PLUS_10GB,
	PHY_TYPE_KR_10GB,
	PHY_TYPE_KX4_10GB,
	PHY_TYPE_BASET_10GB,
	PHY_TYPE_BASET_1GB,
	PHY_TYPE_BASEX_1GB,
	PHY_TYPE_SGMII,
	PHY_TYPE_DISABLED = 255
};

/* Ring related */
#define	GET_Q_NEXT(_START, _STEP, _END)	\
	((((_START) + (_STEP)) < (_END)) ? ((_START) + (_STEP))	\
	: (((_START) + (_STEP)) - (_END)))

#define	RING_NUM_FREE(_r)	\
	(uint32_t)((_r)->num_items - (_r)->num_used)
#define	RING_GET(_r, _n)	\
	(_r)->cidx = GET_Q_NEXT((_r)->cidx, _n, (_r)->num_items)
#define	RING_PUT(_r, _n)	\
	(_r)->pidx = GET_Q_NEXT((_r)->pidx, _n, (_r)->num_items)

#define OCE_DMAPTR(_o, _t) 		((_t *)(_o)->vaddr)

#define	RING_GET_CONSUMER_ITEM_VA(_r, _t)	\
	(OCE_DMAPTR(&(_r)->dma, _t) + (_r)->cidx)
#define	RING_GET_PRODUCER_ITEM_VA(_r, _t)	\
	(OCE_DMAPTR(&(_r)->dma, _t) + (_r)->pidx)


struct oce_packet_desc {
	struct mbuf *		mbuf;
	bus_dmamap_t		map;
	int			nsegs;
	uint32_t		wqe_idx;
};

struct oce_dma_mem {
	bus_dma_tag_t		tag;
	bus_dmamap_t		map;
	bus_dma_segment_t	segs;
	int			nsegs;
	bus_size_t		size;
	caddr_t			vaddr;
	bus_addr_t		paddr;
};

struct oce_ring {
	uint16_t		cidx;	/* Get ptr */
	uint16_t		pidx;	/* Put Ptr */
	size_t			item_size;
	size_t			num_items;
	uint32_t		num_used;
	struct oce_dma_mem	dma;
};

#define TRUE					1
#define FALSE					0

#define	DEFAULT_MQ_MBOX_TIMEOUT			(5 * 1000 * 1000)
#define	MBX_READY_TIMEOUT			(1 * 1000 * 1000)
#define	DEFAULT_DRAIN_TIME			200
#define	MBX_TIMEOUT_SEC				5
#define	STAT_TIMEOUT				2000000

/* size of the packet descriptor array in a transmit queue */
#define OCE_TX_RING_SIZE			512
#define OCE_RX_RING_SIZE			1024
#define OCE_WQ_PACKET_ARRAY_SIZE		(OCE_TX_RING_SIZE/2)
#define OCE_RQ_PACKET_ARRAY_SIZE		(OCE_RX_RING_SIZE)

struct oce_softc;

enum cq_len {
	CQ_LEN_256  = 256,
	CQ_LEN_512  = 512,
	CQ_LEN_1024 = 1024
};

enum eq_len {
	EQ_LEN_256  = 256,
	EQ_LEN_512  = 512,
	EQ_LEN_1024 = 1024,
	EQ_LEN_2048 = 2048,
	EQ_LEN_4096 = 4096
};

enum eqe_size {
	EQE_SIZE_4  = 4,
	EQE_SIZE_16 = 16
};

enum qtype {
	QTYPE_EQ,
	QTYPE_MQ,
	QTYPE_WQ,
	QTYPE_RQ,
	QTYPE_CQ,
	QTYPE_RSS
};

struct eq_config {
	enum eq_len		q_len;
	enum eqe_size		item_size;
	int			q_vector_num;
	int			min_eqd;
	int			max_eqd;
	int			cur_eqd;
};

struct oce_eq {
	struct oce_softc *	sc;
	struct oce_ring *	ring;
	enum qtype		type;
	int			id;

	struct oce_cq *		cq[OCE_MAX_CQ_EQ];
	int			cq_valid;

	struct eq_config	cfg;
};

struct cq_config {
	enum cq_len		q_len;
	int			item_size;
	int			nodelay;
	int			dma_coalescing;
	int			ncoalesce;
	int			eventable;
};

struct oce_cq {
	struct oce_softc *	sc;
	struct oce_ring *	ring;
	enum qtype		type;
	int			id;

	struct oce_eq *		eq;

	struct cq_config 	cfg;

	void			(*cq_intr)(void *);
	void *			cb_arg;
};

struct mq_config {
	int			eqd;
	int			q_len;
};

struct oce_mq {
	struct oce_softc *	sc;
	struct oce_ring *	ring;
	enum qtype		type;
	int			id;

	struct oce_cq *		cq;

	struct mq_config	cfg;
};

struct wq_config {
	int			wq_type;
	int			buf_size;
	int			q_len;
	int			eqd;		/* interrupt delay */
	int			nbufs;
};

struct oce_wq {
	struct oce_softc *	sc;
	struct oce_ring *	ring;
	enum qtype		type;
	int			id;

	bus_dma_tag_t		tag;

	struct oce_cq		*cq;
	struct oce_packet_desc	pckts[OCE_WQ_PACKET_ARRAY_SIZE];

	uint32_t		packets_in;
	uint32_t		packets_out;

	struct wq_config	cfg;
};

struct rq_config {
	int			q_len;
	int			frag_size;
	int			mtu;
	int			if_id;
	int			is_rss_queue;
	int			eqd;
	int			nbufs;
};

struct oce_rq {
	struct oce_softc *	sc;
	struct oce_ring *	ring;
	enum qtype		type;
	int			id;

	bus_dma_tag_t		tag;

	struct oce_cq *		cq;
	struct oce_packet_desc	pckts[OCE_RQ_PACKET_ARRAY_SIZE];

	uint32_t		packets_in;
	uint32_t		packets_out;
	uint32_t		pending;

	uint32_t		rss_cpuid;

#ifdef OCE_LRO
	struct lro_ctrl		lro;
	int			lro_pkts_queued;
#endif

	struct rq_config	cfg;
};

struct link_status {
	uint8_t			physical_port;
	uint8_t			mac_duplex;
	uint8_t			mac_speed;
	uint8_t			mac_fault;
	uint8_t			mgmt_mac_duplex;
	uint8_t			mgmt_mac_speed;
	uint16_t		qos_link_speed;
	uint32_t		logical_link_status;
} __packed;

#define OCE_FLAGS_PCIX			0x00000001
#define OCE_FLAGS_PCIE			0x00000002
#define OCE_FLAGS_MSI_CAPABLE		0x00000004
#define OCE_FLAGS_MSIX_CAPABLE		0x00000008
#define OCE_FLAGS_USING_MSI		0x00000010
#define OCE_FLAGS_USING_MSIX		0x00000020
#define OCE_FLAGS_RESET_RQD		0x00000040
#define OCE_FLAGS_VIRTUAL_PORT		0x00000080
#define OCE_FLAGS_MBOX_ENDIAN_RQD	0x00000100
#define OCE_FLAGS_BE3			0x00000200
#define OCE_FLAGS_XE201			0x00000400
#define OCE_FLAGS_BE2			0x00000800

struct oce_softc {
	struct device		dev;

	uint32_t		flags;

	struct pci_attach_args	pa;

	bus_space_tag_t		cfg_iot;
	bus_space_handle_t	cfg_ioh;
	bus_size_t		cfg_size;

	bus_space_tag_t		csr_iot;
	bus_space_handle_t	csr_ioh;
	bus_size_t		csr_size;

	bus_space_tag_t		db_iot;
	bus_space_handle_t	db_ioh;
	bus_size_t		db_size;

	struct arpcom		arpcom;
	struct ifmedia		media;
	int			link_active;
	uint8_t			link_status;
	uint8_t			link_speed;
	uint8_t			duplex;
	uint32_t		qos_link_speed;

	struct oce_dma_mem	bsmbx;

	uint32_t		port_id;
	uint32_t		function_mode;
	uint32_t		function_caps;
	uint32_t		max_tx_rings;
	uint32_t		max_rx_rings;

	struct oce_wq		*wq[OCE_MAX_WQ];	/* TX work queues */
	struct oce_rq		*rq[OCE_MAX_RQ];	/* RX work queues */
	struct oce_cq		*cq[OCE_MAX_CQ];	/* Completion queues */
	struct oce_eq		*eq[OCE_MAX_EQ];	/* Event queues */
	struct oce_mq		*mq;			/* Mailbox queue */

	ushort			neqs;
	ushort			ncqs;
	ushort			nrqs;
	ushort			nwqs;
	ushort			intr_count;
	ushort			tx_ring_size;
	ushort			rx_ring_size;
	ushort			rq_frag_size;
	ushort			rss_enable;

	uint32_t		if_id;		/* interface ID */
	uint32_t		nifs;		/* number of adapter interfaces, 0 or 1 */
	uint32_t		pmac_id;	/* PMAC id */

	char			macaddr[ETH_ADDR_LEN];

	uint32_t		if_cap_flags;

	uint32_t		flow_control;

	int			be3_native;
	uint32_t		pvid;

	uint64_t		rx_errors;
	uint64_t		tx_errors;

	struct timeout		timer;
	struct timeout		rxrefill;
};

/**************************************************
 * BUS memory read/write macros
 * BE3: accesses three BAR spaces (CFG, CSR, DB)
 * Lancer: accesses one BAR space (CFG)
 **************************************************/
#if 1
#define OCE_READ_REG32(sc, space, o) \
	((IS_BE(sc)) ? (bus_space_read_4((sc)->space##_iot, \
				      (sc)->space##_ioh,o)) \
		  : (bus_space_read_4((sc)->cfg_iot, (sc)->cfg_ioh,o)))
#define OCE_READ_REG16(sc, space, o) \
	((IS_BE(sc)) ? (bus_space_read_2((sc)->space##_iot, \
				      (sc)->space##_ioh,o)) \
		  : (bus_space_read_2((sc)->cfg_iot, (sc)->cfg_ioh,o)))
#define OCE_READ_REG8(sc, space, o) \
	((IS_BE(sc)) ? (bus_space_read_1((sc)->space##_iot, \
				      (sc)->space##_ioh,o)) \
		  : (bus_space_read_1((sc)->cfg_iot, (sc)->cfg_ioh,o)))

#define OCE_WRITE_REG32(sc, space, o, v) \
	((IS_BE(sc)) ? (bus_space_write_4((sc)->space##_iot, \
				       (sc)->space##_ioh,o,v)) \
		  : (bus_space_write_4((sc)->cfg_iot, (sc)->cfg_ioh,o,v)))
#define OCE_WRITE_REG16(sc, space, o, v) \
	((IS_BE(sc)) ? (bus_space_write_2((sc)->space##_iot, \
				       (sc)->space##_ioh,o,v)) \
		  : (bus_space_write_2((sc)->cfg_iot, (sc)->cfg_ioh,o,v)))
#define OCE_WRITE_REG8(sc, space, o, v) \
	((IS_BE(sc)) ? (bus_space_write_1((sc)->space##_iot, \
				       (sc)->space##_ioh,o,v)) \
		  : (bus_space_write_1((sc)->cfg_iot, (sc)->cfg_ioh,o,v)))
#else
static __inline u_int32_t
oce_bus_read_4(bus_space_tag_t tag, bus_space_handle_t handle, bus_size_t reg)
{
	bus_space_barrier(tag, handle, reg, 4, BUS_SPACE_BARRIER_READ);
	return (bus_space_read_4(tag, handle, reg));
}

static __inline u_int16_t
oce_bus_read_2(bus_space_tag_t tag, bus_space_handle_t handle, bus_size_t reg)
{
	bus_space_barrier(tag, handle, reg, 2, BUS_SPACE_BARRIER_READ);
	return (bus_space_read_2(tag, handle, reg));
}

static __inline u_int8_t
oce_bus_read_1(bus_space_tag_t tag, bus_space_handle_t handle, bus_size_t reg)
{
	bus_space_barrier(tag, handle, reg, 1, BUS_SPACE_BARRIER_READ);
	return (bus_space_read_1(tag, handle, reg));
}

static __inline void
oce_bus_write_4(bus_space_tag_t tag, bus_space_handle_t handle, bus_size_t reg,
    u_int32_t val)
{
	bus_space_write_4(tag, handle, reg, val);
	bus_space_barrier(tag, handle, reg, 4, BUS_SPACE_BARRIER_WRITE);
}

static __inline void
oce_bus_write_2(bus_space_tag_t tag, bus_space_handle_t handle, bus_size_t reg,
    u_int16_t val)
{
	bus_space_write_2(tag, handle, reg, val);
	bus_space_barrier(tag, handle, reg, 2, BUS_SPACE_BARRIER_WRITE);
}

static __inline void
oce_bus_write_1(bus_space_tag_t tag, bus_space_handle_t handle, bus_size_t reg,
    u_int8_t val)
{
	bus_space_write_1(tag, handle, reg, val);
	bus_space_barrier(tag, handle, reg, 1, BUS_SPACE_BARRIER_WRITE);
}

#define OCE_READ_REG32(sc, space, o) \
	((IS_BE(sc)) ? (oce_bus_read_4((sc)->space##_iot, \
				      (sc)->space##_ioh,o)) \
		  : (oce_bus_read_4((sc)->cfg_iot, (sc)->cfg_ioh,o)))
#define OCE_READ_REG16(sc, space, o) \
	((IS_BE(sc)) ? (oce_bus_read_2((sc)->space##_iot, \
				      (sc)->space##_ioh,o)) \
		  : (oce_bus_read_2((sc)->cfg_iot, (sc)->cfg_ioh,o)))
#define OCE_READ_REG8(sc, space, o) \
	((IS_BE(sc)) ? (oce_bus_read_1((sc)->space##_iot, \
				      (sc)->space##_ioh,o)) \
		  : (oce_bus_read_1((sc)->cfg_iot, (sc)->cfg_ioh,o)))

#define OCE_WRITE_REG32(sc, space, o, v) \
	((IS_BE(sc)) ? (oce_bus_write_4((sc)->space##_iot, \
				       (sc)->space##_ioh,o,v)) \
		  : (oce_bus_write_4((sc)->cfg_iot, (sc)->cfg_ioh,o,v)))
#define OCE_WRITE_REG16(sc, space, o, v) \
	((IS_BE(sc)) ? (oce_bus_write_2((sc)->space##_iot, \
				       (sc)->space##_ioh,o,v)) \
		  : (oce_bus_write_2((sc)->cfg_iot, (sc)->cfg_ioh,o,v)))
#define OCE_WRITE_REG8(sc, space, o, v) \
	((IS_BE(sc)) ? (oce_bus_write_1((sc)->space##_iot, \
				       (sc)->space##_ioh,o,v)) \
		  : (oce_bus_write_1((sc)->cfg_iot, (sc)->cfg_ioh,o,v)))
#endif

/***********************************************************
 * DMA memory functions
 ***********************************************************/
#define oce_dma_sync(d, f) \
	bus_dmamap_sync((d)->tag, (d)->map, 0, (d)->map->dm_mapsize, f)
int  oce_dma_alloc(struct oce_softc *sc, bus_size_t size,
    struct oce_dma_mem *dma);
void oce_dma_free(struct oce_softc *sc, struct oce_dma_mem *dma);
void oce_dma_map_addr(void *arg, bus_dma_segment_t *segs, int nseg,
    int error);
void oce_destroy_ring(struct oce_softc *sc, struct oce_ring *ring);
struct oce_ring *oce_create_ring(struct oce_softc *sc, int q_len,
    int num_entries, int max_segs);
int oce_load_ring(struct oce_softc *sc, struct oce_ring *ring,
    struct phys_addr *pa_list, int max_segs);

/************************************************************
 * Firmware functions
 ************************************************************/
int  oce_init_fw(struct oce_softc *sc);
int  oce_check_native_mode(struct oce_softc *sc);
int  oce_create_iface(struct oce_softc *sc, uint8_t *macaddr);
int  oce_update_mcast(struct oce_softc *sc,
    uint8_t multi[][ETH_ADDR_LEN], int naddr);

/************************************************************
 * Mailbox functions
 ************************************************************/
int oce_mbox_init(struct oce_softc *sc);
void oce_first_mcc(struct oce_softc *sc);

int oce_get_link_status(struct oce_softc *sc);
int oce_set_promisc(struct oce_softc *sc, int enable);
int oce_config_rss(struct oce_softc *sc, uint32_t if_id, int enable);

int oce_macaddr_get(struct oce_softc *sc, uint8_t *macaddr);
int oce_macaddr_add(struct oce_softc *sc, uint8_t *macaddr,
    uint32_t if_id, uint32_t *pmac_id);
int oce_macaddr_del(struct oce_softc *sc, uint32_t if_id,
    uint32_t pmac_id);

int oce_new_rq(struct oce_softc *sc, struct oce_rq *rq);
int oce_new_wq(struct oce_softc *sc, struct oce_wq *wq);
int oce_new_mq(struct oce_softc *sc, struct oce_mq *mq);
int oce_new_eq(struct oce_softc *sc, struct oce_eq *eq);
int oce_new_cq(struct oce_softc *sc, struct oce_cq *cq);
int oce_destroy_queue(struct oce_softc *sc, enum qtype qtype, uint32_t qid);

/************************************************************
 * Statistics functions
 ************************************************************/
int  oce_update_stats(struct oce_softc *sc, u_int64_t *rxe, u_int64_t *txe);

/* Capabilities */
#define OCE_MAX_RSP_HANDLED		64

#define OCE_MAC_LOOPBACK		0x0
#define OCE_PHY_LOOPBACK		0x1
#define OCE_ONE_PORT_EXT_LOOPBACK	0x2
#define OCE_NO_LOOPBACK			0xff

#define DW_SWAP(x, l)

#define ADDR_HI(x)		((uint32_t)((uint64_t)(x) >> 32))
#define ADDR_LO(x)		((uint32_t)((uint64_t)(x) & 0xffffffff))

#define IFCAP_HWCSUM \
	(IFCAP_CSUM_IPv4 | IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4)
#define IF_LRO_ENABLED(ifp)  (((ifp)->if_capabilities & IFCAP_LRO) ? 1:0)
#define IF_LSO_ENABLED(ifp)  (((ifp)->if_capabilities & IFCAP_TSO4) ? 1:0)
#define IF_CSUM_ENABLED(ifp) (((ifp)->if_capabilities & IFCAP_HWCSUM) ? 1:0)

static inline int
ilog2(unsigned int v)
{
	int r = 0;

	while (v >>= 1)
		r++;
	return (r);
}
@


1.23
log
@rearrange the function layout a bit
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.22 2012/10/29 18:14:28 mikeb Exp $	*/
@


1.22
log
@oce_get_fw_config is useless; ditch it
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.21 2012/10/26 23:35:09 mikeb Exp $	*/
d607 3
a611 3
int oce_macaddr_add(struct oce_softc *sc, uint8_t *macaddr,
    uint32_t if_id, uint32_t *pmac_id);
int oce_read_macaddr(struct oce_softc *sc, uint8_t *macaddr);
@


1.21
log
@oce_first_mcc_cmd doesn't return anything of value so make it void;
shorten it to oce_first_mcc while here
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.20 2012/10/26 22:45:36 mikeb Exp $	*/
a591 1
int  oce_get_fw_config(struct oce_softc *sc);
@


1.20
log
@simplify the way we collect statistics
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.19 2012/10/26 18:11:07 mikeb Exp $	*/
d602 1
a602 1
int oce_first_mcc_cmd(struct oce_softc *sc);
@


1.19
log
@remove stuff that either is no longer or was never used
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.18 2012/10/26 18:05:50 mikeb Exp $	*/
a207 135
struct oce_be_stats {
	uint8_t  be_on_die_temperature;
	uint32_t be_tx_events;
	uint32_t eth_red_drops;
	uint32_t rx_drops_no_pbuf;
	uint32_t rx_drops_no_txpb;
	uint32_t rx_drops_no_erx_descr;
	uint32_t rx_drops_no_tpre_descr;
	uint32_t rx_drops_too_many_frags;
	uint32_t rx_drops_invalid_ring;
	uint32_t forwarded_packets;
	uint32_t rx_drops_mtu;
	uint32_t rx_crc_errors;
	uint32_t rx_alignment_symbol_errors;
	uint32_t rx_pause_frames;
	uint32_t rx_priority_pause_frames;
	uint32_t rx_control_frames;
	uint32_t rx_in_range_errors;
	uint32_t rx_out_range_errors;
	uint32_t rx_frame_too_long;
	uint32_t rx_address_match_errors;
	uint32_t rx_dropped_too_small;
	uint32_t rx_dropped_too_short;
	uint32_t rx_dropped_header_too_small;
	uint32_t rx_dropped_tcp_length;
	uint32_t rx_dropped_runt;
	uint32_t rx_ip_checksum_errs;
	uint32_t rx_tcp_checksum_errs;
	uint32_t rx_udp_checksum_errs;
	uint32_t rx_switched_unicast_packets;
	uint32_t rx_switched_multicast_packets;
	uint32_t rx_switched_broadcast_packets;
	uint32_t tx_pauseframes;
	uint32_t tx_priority_pauseframes;
	uint32_t tx_controlframes;
	uint32_t rxpp_fifo_overflow_drop;
	uint32_t rx_input_fifo_overflow_drop;
	uint32_t pmem_fifo_overflow_drop;
	uint32_t jabber_events;
};

struct oce_xe_stats {
	uint64_t tx_pkts;
	uint64_t tx_unicast_pkts;
	uint64_t tx_multicast_pkts;
	uint64_t tx_broadcast_pkts;
	uint64_t tx_bytes;
	uint64_t tx_unicast_bytes;
	uint64_t tx_multicast_bytes;
	uint64_t tx_broadcast_bytes;
	uint64_t tx_discards;
	uint64_t tx_errors;
	uint64_t tx_pause_frames;
	uint64_t tx_pause_on_frames;
	uint64_t tx_pause_off_frames;
	uint64_t tx_internal_mac_errors;
	uint64_t tx_control_frames;
	uint64_t tx_pkts_64_bytes;
	uint64_t tx_pkts_65_to_127_bytes;
	uint64_t tx_pkts_128_to_255_bytes;
	uint64_t tx_pkts_256_to_511_bytes;
	uint64_t tx_pkts_512_to_1023_bytes;
	uint64_t tx_pkts_1024_to_1518_bytes;
	uint64_t tx_pkts_1519_to_2047_bytes;
	uint64_t tx_pkts_2048_to_4095_bytes;
	uint64_t tx_pkts_4096_to_8191_bytes;
	uint64_t tx_pkts_8192_to_9216_bytes;
	uint64_t tx_lso_pkts;
	uint64_t rx_pkts;
	uint64_t rx_unicast_pkts;
	uint64_t rx_multicast_pkts;
	uint64_t rx_broadcast_pkts;
	uint64_t rx_bytes;
	uint64_t rx_unicast_bytes;
	uint64_t rx_multicast_bytes;
	uint64_t rx_broadcast_bytes;
	uint32_t rx_unknown_protos;
	uint64_t rx_discards;
	uint64_t rx_errors;
	uint64_t rx_crc_errors;
	uint64_t rx_alignment_errors;
	uint64_t rx_symbol_errors;
	uint64_t rx_pause_frames;
	uint64_t rx_pause_on_frames;
	uint64_t rx_pause_off_frames;
	uint64_t rx_frames_too_long;
	uint64_t rx_internal_mac_errors;
	uint32_t rx_undersize_pkts;
	uint32_t rx_oversize_pkts;
	uint32_t rx_fragment_pkts;
	uint32_t rx_jabbers;
	uint64_t rx_control_frames;
	uint64_t rx_control_frames_unknown_opcode;
	uint32_t rx_in_range_errors;
	uint32_t rx_out_of_range_errors;
	uint32_t rx_address_match_errors;
	uint32_t rx_vlan_mismatch_errors;
	uint32_t rx_dropped_too_small;
	uint32_t rx_dropped_too_short;
	uint32_t rx_dropped_header_too_small;
	uint32_t rx_dropped_invalid_tcp_length;
	uint32_t rx_dropped_runt;
	uint32_t rx_ip_checksum_errors;
	uint32_t rx_tcp_checksum_errors;
	uint32_t rx_udp_checksum_errors;
	uint32_t rx_non_rss_pkts;
	uint64_t rx_ipv4_pkts;
	uint64_t rx_ipv6_pkts;
	uint64_t rx_ipv4_bytes;
	uint64_t rx_ipv6_bytes;
	uint64_t rx_nic_pkts;
	uint64_t rx_tcp_pkts;
	uint64_t rx_iscsi_pkts;
	uint64_t rx_management_pkts;
	uint64_t rx_switched_unicast_pkts;
	uint64_t rx_switched_multicast_pkts;
	uint64_t rx_switched_broadcast_pkts;
	uint64_t num_forwards;
	uint32_t rx_fifo_overflow;
	uint32_t rx_input_fifo_overflow;
	uint64_t rx_drops_too_many_frags;
	uint32_t rx_drops_invalid_queue;
	uint64_t rx_drops_mtu;
	uint64_t rx_pkts_64_bytes;
	uint64_t rx_pkts_65_to_127_bytes;
	uint64_t rx_pkts_128_to_255_bytes;
	uint64_t rx_pkts_256_to_511_bytes;
	uint64_t rx_pkts_512_to_1023_bytes;
	uint64_t rx_pkts_1024_to_1518_bytes;
	uint64_t rx_pkts_1519_to_2047_bytes;
	uint64_t rx_pkts_2048_to_4095_bytes;
	uint64_t rx_pkts_4096_to_8191_bytes;
	uint64_t rx_pkts_8192_to_9216_bytes;
};

a459 6

	union {
		struct mbx_get_pport_stats xe;
		struct mbx_get_nic_stats_v0 be2;
		struct mbx_get_nic_stats be3;
	} stats;
@


1.18
log
@cleanup oce_init_fw; use less bitfields
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.17 2012/10/26 17:56:24 mikeb Exp $	*/
d42 1
a42 1
#define COMPONENT_REVISION "4.2.127.0"
d44 3
a46 4
#define IS_BE(sc)	(((sc->flags & OCE_FLAGS_BE3) | \
			 (sc->flags & OCE_FLAGS_BE2))? 1:0)
#define IS_XE201(sc)	((sc->flags & OCE_FLAGS_XE201) ? 1:0)
#define HAS_A0_CHIP(sc)	((sc->flags & OCE_FLAGS_HAS_A0_CHIP) ? 1:0)
d54 2
a55 2
#define OCE_MAX_RSS			4 /* TODO: 8*/
#define OCE_LEGACY_MODE_RSS		4 /* For BE3 Legacy mode*/
d74 2
a75 2
					    ETHER_VLAN_ENCAP_LEN - \
					    ETHER_HDR_LEN - ETHER_CRC_LEN)
d113 4
a116 7
#define upper_32_bits(n)		((uint32_t)(((n) >> 16) >> 16))
#define BSWAP_8(x)			((x) & 0xff)
#define BSWAP_16(x)			((BSWAP_8(x) << 8) | BSWAP_8((x) >> 8))
#define BSWAP_32(x)			((BSWAP_16(x) << 16) | \
					 BSWAP_16((x) >> 16))
#define BSWAP_64(x)			((BSWAP_32(x) << 32) | \
					BSWAP_32((x) >> 32))
a207 6
/* Stats */
#define OCE_UNICAST_PACKET	0
#define OCE_MULTICAST_PACKET	1
#define OCE_BROADCAST_PACKET	2
#define OCE_RSVD_PACKET		3

d778 1
a778 1
#define ADDR_LO(x)		((uint32_t)((uint64_t)(x) & 0xffffffff));
@


1.17
log
@rename oce_config_nic_rss to oce_config_rss and merge oce_rss_itbl_init in;
cleanup oce_set_promisc and oce_config_vlan function arguments, a bunch of
defines and prototypes while at it.
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.16 2012/10/15 19:23:23 mikeb Exp $	*/
d535 1
a535 1
#define OCE_FLAGS_FUNCRESET_RQD		0x00000040
@


1.16
log
@major cleanup of the queue allocation code;  we need only half of
those functions.  fixup some dma syncs, not tested yet though.
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.15 2012/10/12 18:24:31 mikeb Exp $	*/
d96 5
a100 5
#define  OCE_CAPAB_FLAGS 		(MBX_RX_IFACE_FLAGS_BROADCAST    | \
					MBX_RX_IFACE_FLAGS_UNTAGGED      | \
					MBX_RX_IFACE_FLAGS_PROMISCUOUS   | \
					MBX_RX_IFACE_FLAGS_MCAST_PROMISCUOUS | \
					MBX_RX_IFACE_FLAGS_RSS)
d106 1
a106 2
					MBX_RX_IFACE_FLAGS_UNTAGGED   | \
					MBX_RX_IFACE_FLAGS_RSS)
d745 1
a745 1
int  oce_create_iface(struct oce_softc *sc, uint8_t *);
d756 2
a757 3
int oce_set_promisc(struct oce_softc *sc, uint32_t enable);
int oce_config_nic_rss(struct oce_softc *sc, uint32_t if_id,
    uint16_t enable_rss);
@


1.15
log
@no need to fetch and print the fw revision
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.14 2012/10/12 17:41:40 mikeb Exp $	*/
a398 13
enum qstate {
	QDELETED = 0x0,
	QCREATED = 0x1
};

struct oce_queue {
	struct oce_softc *	sc;
	struct oce_ring *	ring;
	uint32_t		id;
	enum qtype		type;
	enum qstate		state;
};

a410 1
	uint32_t		id;
d412 1
a412 1
	enum qstate		state;
a431 1
	uint32_t		id;
d433 1
a433 1
	enum qstate		state;
d439 1
a439 1
	void			(*cq_handler)(void *);
a450 1
	uint32_t		id;
d452 1
a452 1
	enum qstate		state;
a469 1
	uint32_t		id;
d471 1
a471 1
	enum qstate		state;
a481 2

	int			queue_index;
a496 1
	uint32_t		id;
d498 1
a498 1
	enum qstate		state;
a516 2

	int			queue_index;
d767 5
a771 7
int oce_create_qeueu(struct oce_softc *sc, struct oce_queue *q,
    enum qtype qtype);
int oce_create_rq(struct oce_softc *sc, struct oce_rq *rq);
int oce_create_wq(struct oce_softc *sc, struct oce_wq *wq);
int oce_create_mq(struct oce_softc *sc, struct oce_mq *mq);
int oce_create_eq(struct oce_softc *sc, struct oce_eq *eq);
int oce_create_cq(struct oce_softc *sc, struct oce_cq *cq);
@


1.14
log
@major cleanup
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.13 2012/10/12 15:16:45 mikeb Exp $	*/
a591 2
	char			fw_version[32];

a593 1
	uint32_t		asic_revision;
a765 1
int  oce_get_fw_version(struct oce_softc *sc);
d812 1
a812 1
#define IS_ALIGNED(x,a)		((x % a) == 0)
@


1.13
log
@a bit of janitoring
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.12 2012/10/11 16:38:10 mikeb Exp $	*/
d188 4
a191 4
	struct mbuf *mbuf;
	bus_dmamap_t map;
	int nsegs;
	uint32_t wqe_idx;
d195 7
a201 7
	bus_dma_tag_t tag;
	bus_dmamap_t map;
	bus_dma_segment_t segs;
	int nsegs;
	bus_size_t size;
	caddr_t vaddr;
	bus_addr_t paddr;
d205 6
a210 6
	uint16_t cidx;	/* Get ptr */
	uint16_t pidx;	/* Put Ptr */
	size_t item_size;
	size_t num_items;
	uint32_t num_used;
	struct oce_dma_mem dma;
a353 1
typedef int boolean_t;
d369 7
a375 1
struct oce_dev;
d399 1
a399 1
typedef enum qstate_e {
d402 9
a410 1
} qstate_t;
d413 6
a418 6
	enum eq_len q_len;
	enum eqe_size item_size;
	uint32_t q_vector_num;
	uint8_t min_eqd;
	uint8_t max_eqd;
	uint8_t cur_eqd;
d422 8
a429 10
	uint32_t eq_id;
	void *parent;
	void *cb_context;
	struct oce_ring *ring;
	qstate_t qstate;
	struct oce_cq *cq[OCE_MAX_CQ_EQ];
	int cq_valid;
	struct eq_config eq_cfg;
	int vector;
};
d431 1
a431 4
enum cq_len {
	CQ_LEN_256  = 256,
	CQ_LEN_512  = 512,
	CQ_LEN_1024 = 1024
d435 6
a440 6
	enum cq_len q_len;
	uint32_t item_size;
	boolean_t is_eventable;
	boolean_t sol_eventable;
	boolean_t nodelay;
	uint16_t dma_coalescing;
d444 12
a455 8
	uint32_t cq_id;
	void *parent;
	struct oce_eq *eq;
	void (*cq_handler)(void *);
	void *cb_arg;
	struct oce_ring *ring;
	qstate_t qstate;
	struct cq_config cq_cfg;
d459 2
a460 2
	uint32_t eqd;
	uint8_t q_len;
d464 7
a470 9
	void *parent;
	struct oce_ring *ring;
	uint32_t mq_id;
	struct oce_cq *cq;
	struct oce_cq *async_cq;
	uint32_t mq_free;
	qstate_t qstate;
	struct mq_config cfg;
};
d472 1
a472 4
struct oce_mbx_ctx {
	struct oce_mbx *mbx;
	void (*cb) (void *ctx);
	void *cb_ctx;
d476 5
a480 8
	uint8_t wq_type;
	uint16_t buf_size;
	uint32_t q_len;
	uint16_t pd_id;
	uint16_t pci_fn_num;
	uint32_t eqd;	/* interrupt delay */
	uint32_t nbufs;
	uint32_t nhdl;
d483 16
a498 10
struct oce_tx_queue_stats {
	uint64_t tx_pkts;
	uint64_t tx_bytes;
	uint32_t tx_reqs;
	uint32_t tx_stops; /* number of times TX Q was stopped */
	uint32_t tx_wrbs;
	uint32_t tx_compl;
	uint32_t tx_rate;
	uint32_t ipv6_ext_hdr_tx_drop;
};
d500 1
a500 17
struct oce_wq {
	void *parent;
	struct oce_ring *ring;
	struct oce_cq *cq;
	bus_dma_tag_t tag;
	struct oce_packet_desc pckts[OCE_WQ_PACKET_ARRAY_SIZE];
	uint32_t packets_in;
	uint32_t packets_out;
	uint32_t wqm_used;
	boolean_t resched;
	uint32_t wq_free;
	uint32_t tx_deferd;
	uint32_t pkt_drops;
	qstate_t qstate;
	uint16_t wq_id;
	struct wq_config cfg;
	int queue_index;
d504 7
a510 7
	uint32_t q_len;
	uint32_t frag_size;
	uint32_t mtu;
	uint32_t if_id;
	uint32_t is_rss_queue;
	uint32_t eqd;
	uint32_t nbufs;
d513 17
a529 14
struct oce_rx_queue_stats {
	uint32_t rx_post_fail;
	uint32_t rx_ucast_pkts;
	uint32_t rx_compl;
	uint64_t rx_bytes;
	uint64_t rx_bytes_prev;
	uint64_t rx_pkts;
	uint32_t rx_rate;
	uint32_t rx_mcast_pkts;
	uint32_t rxcp_err;
	uint32_t rx_frags;
	uint32_t prev_rx_frags;
	uint32_t rx_fps;
};
a530 19
struct oce_rq {
	struct rq_config cfg;
	uint32_t rq_id;
	int queue_index;
	uint32_t rss_cpuid;
	void *parent;
	struct oce_ring *ring;
	struct oce_cq *cq;
	bus_dma_tag_t tag;
	struct oce_packet_desc pckts[OCE_RQ_PACKET_ARRAY_SIZE];
	uint32_t packets_in;
	uint32_t packets_out;
	uint32_t pending;
#ifdef notdef
	struct mbuf *head;
	struct mbuf *tail;
	int fragsleft;
#endif
	qstate_t qstate;
d532 2
a533 2
	struct lro_ctrl lro;
	int lro_pkts_queued;
d535 4
d542 8
a549 8
	uint8_t physical_port;
	uint8_t mac_duplex;
	uint8_t mac_speed;
	uint8_t mac_fault;
	uint8_t mgmt_mac_duplex;
	uint8_t mgmt_mac_speed;
	uint16_t qos_link_speed;
	uint32_t logical_link_status;
d566 3
a568 1
	struct device dev;
d570 1
a570 1
	uint32_t flags;
d572 50
a621 1
	struct pci_attach_args pa;
d623 1
a623 52
	bus_space_tag_t cfg_btag;
	bus_space_handle_t cfg_bhandle;
	bus_size_t cfg_size;

	bus_space_tag_t csr_btag;
	bus_space_handle_t csr_bhandle;
	bus_size_t csr_size;

	bus_space_tag_t db_btag;
	bus_space_handle_t db_bhandle;
	bus_size_t db_size;

	struct arpcom arpcom;
	struct ifmedia media;
	int link_active;
	uint8_t link_status;
	uint8_t link_speed;
	uint8_t duplex;
	uint32_t qos_link_speed;

	char fw_version[32];
	struct mac_address_format macaddr;

	struct oce_dma_mem bsmbx;

	uint32_t config_number;
	uint32_t asic_revision;
	uint32_t port_id;
	uint32_t function_mode;
	uint32_t function_caps;
	uint32_t max_tx_rings;
	uint32_t max_rx_rings;

	struct oce_wq *wq[OCE_MAX_WQ];	/* TX work queues */
	struct oce_rq *rq[OCE_MAX_RQ];	/* RX work queues */
	struct oce_cq *cq[OCE_MAX_CQ];	/* Completion queues */
	struct oce_eq *eq[OCE_MAX_EQ];	/* Event queues */
	struct oce_mq *mq;		/* Mailbox queue */

	ushort neqs;
	ushort ncqs;
	ushort nrqs;
	ushort nwqs;
	ushort intr_count;
	ushort tx_ring_size;
	ushort rx_ring_size;
	ushort rq_frag_size;
	ushort rss_enable;

	uint32_t if_id;		/* interface ID */
	uint32_t nifs;		/* number of adapter interfaces, 0 or 1 */
	uint32_t pmac_id;	/* PMAC id */
d625 1
a625 1
	uint32_t if_cap_flags;
d627 1
a627 1
	uint32_t flow_control;
d629 2
a630 2
	char be3_native;
	uint32_t pvid;
d638 2
a639 2
	uint64_t rx_errors;
	uint64_t tx_errors;
d641 2
a642 2
	struct timeout timer;
	struct timeout rxrefill;
d652 3
a654 4
	((IS_BE(sc)) ? (bus_space_read_4((sc)->space##_btag, \
				      (sc)->space##_bhandle,o)) \
		  : (bus_space_read_4((sc)->cfg_btag, \
				      (sc)->cfg_bhandle,o)))
d656 3
a658 4
	((IS_BE(sc)) ? (bus_space_read_2((sc)->space##_btag, \
				      (sc)->space##_bhandle,o)) \
		  : (bus_space_read_2((sc)->cfg_btag, \
				      (sc)->cfg_bhandle,o)))
d660 3
a662 4
	((IS_BE(sc)) ? (bus_space_read_1((sc)->space##_btag, \
				      (sc)->space##_bhandle,o)) \
		  : (bus_space_read_1((sc)->cfg_btag, \
				      (sc)->cfg_bhandle,o)))
d665 3
a667 4
	((IS_BE(sc)) ? (bus_space_write_4((sc)->space##_btag, \
				       (sc)->space##_bhandle,o,v)) \
		  : (bus_space_write_4((sc)->cfg_btag, \
				       (sc)->cfg_bhandle,o,v)))
d669 3
a671 4
	((IS_BE(sc)) ? (bus_space_write_2((sc)->space##_btag, \
				       (sc)->space##_bhandle,o,v)) \
		  : (bus_space_write_2((sc)->cfg_btag, \
				       (sc)->cfg_bhandle,o,v)))
d673 3
a675 4
	((IS_BE(sc)) ? (bus_space_write_1((sc)->space##_btag, \
				       (sc)->space##_bhandle,o,v)) \
		  : (bus_space_write_1((sc)->cfg_btag, \
				       (sc)->cfg_bhandle,o,v)))
d723 3
a725 4
	((IS_BE(sc)) ? (oce_bus_read_4((sc)->space##_btag, \
				      (sc)->space##_bhandle,o)) \
		  : (oce_bus_read_4((sc)->cfg_btag, \
				      (sc)->cfg_bhandle,o)))
d727 3
a729 4
	((IS_BE(sc)) ? (oce_bus_read_2((sc)->space##_btag, \
				      (sc)->space##_bhandle,o)) \
		  : (oce_bus_read_2((sc)->cfg_btag, \
				      (sc)->cfg_bhandle,o)))
d731 3
a733 4
	((IS_BE(sc)) ? (oce_bus_read_1((sc)->space##_btag, \
				      (sc)->space##_bhandle,o)) \
		  : (oce_bus_read_1((sc)->cfg_btag, \
				      (sc)->cfg_bhandle,o)))
d736 3
a738 4
	((IS_BE(sc)) ? (oce_bus_write_4((sc)->space##_btag, \
				       (sc)->space##_bhandle,o,v)) \
		  : (oce_bus_write_4((sc)->cfg_btag, \
				       (sc)->cfg_bhandle,o,v)))
d740 3
a742 4
	((IS_BE(sc)) ? (oce_bus_write_2((sc)->space##_btag, \
				       (sc)->space##_bhandle,o,v)) \
		  : (oce_bus_write_2((sc)->cfg_btag, \
				       (sc)->cfg_bhandle,o,v)))
d744 3
a746 4
	((IS_BE(sc)) ? (oce_bus_write_1((sc)->space##_btag, \
				       (sc)->space##_bhandle,o,v)) \
		  : (oce_bus_write_1((sc)->cfg_btag, \
				       (sc)->cfg_bhandle,o,v)))
d766 1
a766 1
 * Some functions
d768 5
a772 5
int  oce_hw_pci_alloc(struct oce_softc *sc);
int  oce_hw_init(struct oce_softc *sc);
void oce_hw_intr_enable(struct oce_softc *sc);
void oce_hw_intr_disable(struct oce_softc *sc);
int  oce_create_iface(struct oce_softc *sc);
d779 1
d787 1
a787 1
int oce_mbox_macaddr_del(struct oce_softc *sc, uint32_t if_id,
d789 1
a789 1
int oce_mbox_macaddr_add(struct oce_softc *sc, uint8_t *mac_addr,
d791 1
a791 2
int oce_read_mac_addr(struct oce_softc *sc, uint32_t if_id, uint8_t perm,
    uint8_t type, struct mac_address_format *mac);
d793 8
a800 7
int oce_mbox_create_rq(struct oce_rq *rq);
int oce_mbox_create_wq(struct oce_wq *wq);
int oce_mbox_create_mq(struct oce_mq *mq);
int oce_mbox_create_eq(struct oce_eq *eq);
int oce_mbox_create_cq(struct oce_cq *cq, uint32_t ncoalesce,
    uint32_t is_eventable);
int oce_mbox_destroy_q(struct oce_softc *sc, enum qtype qtype, uint32_t qid);
@


1.12
log
@rework the firmware interface and incorporate all the guts into
one single function instead of spreading them across 10 others.
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.11 2012/10/11 16:33:57 mikeb Exp $	*/
d785 1
a785 1
    struct oce_dma_mem *dma, int flags);
d792 1
a792 1
uint32_t oce_page_list(struct oce_softc *sc, struct oce_ring *ring,
@


1.11
log
@better integer log2 implementation, checked with what linux is doing
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.10 2012/08/09 19:23:35 mikeb Exp $	*/
d650 5
a654 1
	struct oce_dma_mem stats_mem;
d796 1
a796 1
 * oce_hw_xxx functions
a799 3
int  oce_create_nw_interface(struct oce_softc *sc);
void oce_delete_nw_interface(struct oce_softc *sc);
int  oce_hw_update_multicast(struct oce_softc *sc);
d802 3
a808 5
int oce_mbox_init(struct oce_softc *sc);
int oce_mbox_dispatch(struct oce_softc *sc, uint32_t tmo_sec);
int oce_mbox_post(struct oce_softc *sc, struct oce_mbx *mbx,
    struct oce_mbx_ctx *mbxctx);
int oce_mbox_wait(struct oce_softc *sc, uint32_t tmo_sec);
d812 1
a812 1
int oce_rxf_set_promiscuous(struct oce_softc *sc, uint32_t enable);
d829 1
a829 3
void mbx_common_req_hdr_init(struct mbx_hdr *hdr, uint8_t dom, uint8_t port,
    uint8_t subsys, uint8_t opcode, uint32_t timeout, uint32_t payload_len,
    uint8_t version);
d834 1
a834 3
int  oce_stats_init(struct oce_softc *sc);
void oce_stats_free(struct oce_softc *sc);
int  oce_stats_get(struct oce_softc *sc, u_int64_t *rxe, u_int64_t *txe);
@


1.10
log
@oops. missed these conflicts in the previous commit
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.9 2012/08/09 19:19:49 mikeb Exp $	*/
d860 2
a861 2
#define OCE_LOG2(x) 		(oce_highbit(x))
static inline uint32_t oce_highbit(uint32_t x)
d863 1
a863 13
	int i;
	int c;
	int b;

	c = 0;
	b = 0;

	for (i = 0; i < 32; i++) {
		if ((1 << i) & x) {
			c++;
			b = i;
		}
	}
d865 3
a867 4
	if (c == 1)
		return b;

	return 0;
@


1.9
log
@try to make sense of the firmware statistics by counting rx and tx erorrs
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.8 2012/08/09 19:03:14 mikeb Exp $	*/
a836 2
void oce_refresh_queue_stats(struct oce_softc *sc);
int  oce_refresh_nic_stats(struct oce_softc *sc);
d839 1
@


1.8
log
@remove internal queue stats, use if_* counters wherever possible
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.7 2012/08/09 18:49:57 mikeb Exp $	*/
d260 1
a260 1
struct oce_xe201_stats {
a353 7
struct oce_drv_stats {
	union {
		struct oce_be_stats be;
		struct oce_xe201_stats xe201;
	} u0;
};

d651 4
a654 1
	struct oce_drv_stats oce_stats_info;
@


1.7
log
@respect the mtu value that ifconfig sets
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.6 2012/08/09 12:43:46 mikeb Exp $	*/
a218 21
struct oce_rx_stats {
	/* Total Receive Stats */
	uint64_t t_rx_pkts;
	uint64_t t_rx_bytes;
	uint32_t t_rx_frags;
	uint32_t t_rx_mcast_pkts;
	uint32_t t_rx_ucast_pkts;
	uint32_t t_rxcp_errs;
};

struct oce_tx_stats {
	/*Total Transmit Stats */
	uint64_t t_tx_pkts;
	uint64_t t_tx_bytes;
	uint32_t t_tx_reqs;
	uint32_t t_tx_stops;
	uint32_t t_tx_wrbs;
	uint32_t t_tx_compl;
	uint32_t t_ipv6_ext_hdr_tx_drop;
};

a354 2
	struct oce_rx_stats rx;
	struct oce_tx_stats tx;
a513 1
	struct oce_tx_queue_stats tx_stats;
a559 1
	struct oce_rx_queue_stats rx_stats;
@


1.6
log
@remove oce_dmamap_sync wrapper
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.5 2012/08/07 17:16:26 mikeb Exp $	*/
d75 2
a76 2
						ETHER_VLAN_ENCAP_LEN - \
						ETHER_HDR_LEN)
@


1.5
log
@a bit of cleanup and a tx delay tweak
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.4 2012/08/06 21:55:31 mikeb Exp $	*/
a808 2
#define oce_dmamap_sync(t, m, f) \
	bus_dmamap_sync(t, m, 0, (m)->dm_mapsize, f)
@


1.4
log
@kill sc->promisc
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.3 2012/08/02 22:14:31 mikeb Exp $	*/
d68 1
a68 1
#define OCE_DEFAULT_WQ_EQD		64
a442 1
	uint32_t ref_count;
a473 1
	uint32_t ref_count;
@


1.3
log
@get rid of some "capabilities" leftovers
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.2 2012/08/02 22:06:29 mikeb Exp $	*/
a82 1
#define OCE_DEFAULT_PROMISCUOUS		0
a679 1
	char promisc;
@


1.2
log
@we use a central pci database; no reason to keep duplicates around
@
text
@d1 1
a1 1
/* 	$OpenBSD: ocevar.h,v 1.1 2012/08/02 17:35:52 mikeb Exp $	*/
a877 1
#define OCE_MODCAP_RSS			0
a878 1
extern uint32_t oce_max_rsp_handled;	/* max responses */
@


1.1
log
@Add a driver for Emulex OneConnect 10Gb Ethernet obtained from FreeBSD
but heavily massaged to look like other BSD network drivers. Support is
provided for cards based on the following controllers:

 o  ServerEngines BladeEngine 2
 o  ServerEngines BladeEngine 3
 o  Emulex Lancer
@
text
@d1 1
a1 1
/* 	$OpenBSD$	*/
a43 9

/* OCE devices supported by this driver */
#define PCI_VENDOR_EMULEX		0x10df	/* Emulex */
#define PCI_VENDOR_SERVERENGINES	0x19a2	/* ServerEngines (BE) */
#define PCI_PRODUCT_BE2			0x0700	/* BE2 network adapter */
#define PCI_PRODUCT_BE3			0x0710	/* BE3 network adapter */
#define PCI_PRODUCT_XE201		0xe220	/* XE201 network adapter */
#define PCI_PRODUCT_XE201_VF		0xe228	/* XE201 with VF in Lancer */

a47 1

@

