head	1.24;
access;
symbols;
locks; strict;
comment	@ * @;


1.24
date	2012.10.29.18.36.42;	author mikeb;	state dead;
branches;
next	1.23;

1.23
date	2012.10.29.18.22.45;	author mikeb;	state Exp;
branches;
next	1.22;

1.22
date	2012.10.29.18.22.11;	author mikeb;	state Exp;
branches;
next	1.21;

1.21
date	2012.10.29.18.17.39;	author mikeb;	state Exp;
branches;
next	1.20;

1.20
date	2012.10.29.18.14.28;	author mikeb;	state Exp;
branches;
next	1.19;

1.19
date	2012.10.26.23.35.09;	author mikeb;	state Exp;
branches;
next	1.18;

1.18
date	2012.10.26.22.45.36;	author mikeb;	state Exp;
branches;
next	1.17;

1.17
date	2012.10.26.18.05.50;	author mikeb;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.26.17.56.24;	author mikeb;	state Exp;
branches;
next	1.15;

1.15
date	2012.10.25.17.53.11;	author mikeb;	state Exp;
branches;
next	1.14;

1.14
date	2012.10.25.17.01.26;	author mikeb;	state Exp;
branches;
next	1.13;

1.13
date	2012.10.15.19.23.23;	author mikeb;	state Exp;
branches;
next	1.12;

1.12
date	2012.10.12.18.24.31;	author mikeb;	state Exp;
branches;
next	1.11;

1.11
date	2012.10.12.17.41.40;	author mikeb;	state Exp;
branches;
next	1.10;

1.10
date	2012.10.12.15.16.45;	author mikeb;	state Exp;
branches;
next	1.9;

1.9
date	2012.10.11.16.38.10;	author mikeb;	state Exp;
branches;
next	1.8;

1.8
date	2012.10.11.16.34.30;	author mikeb;	state Exp;
branches;
next	1.7;

1.7
date	2012.10.11.16.33.57;	author mikeb;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.10.16.24.56;	author mikeb;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.09.19.29.03;	author mikeb;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.09.19.19.49;	author mikeb;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.09.19.12.45;	author mikeb;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.09.19.03.14;	author mikeb;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.02.17.35.52;	author mikeb;	state Exp;
branches;
next	;


desc
@@


1.24
log
@merge oce.c into if_oce.c and rename oce{reg,var}.h to if_oce{reg,var}.h
@
text
@/*	$OpenBSD: oce.c,v 1.23 2012/10/29 18:22:45 mikeb Exp $	*/

/*
 * Copyright (c) 2012 Mike Belopuhov
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*-
 * Copyright (C) 2012 Emulex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Emulex Corporation nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Contact Information:
 * freebsd-drivers@@emulex.com
 *
 * Emulex
 * 3333 Susan Street
 * Costa Mesa, CA 92626
 */

#include "bpfilter.h"
#include "vlan.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#endif

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#if NVLAN > 0
#include <net/if_types.h>
#include <net/if_vlan_var.h>
#endif

#include <dev/rndvar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

#include <dev/pci/ocereg.h>
#include <dev/pci/ocevar.h>

int oce_mbox_dispatch(struct oce_softc *sc);

int oce_cmd(struct oce_softc *sc, int subsys, int opcode, int version,
    void *payload, int length);

int oce_config_vlan(struct oce_softc *sc, uint32_t if_id,
    struct normal_vlan *vtag_arr, int vtag_cnt, int untagged, int promisc);
int oce_set_flow_control(struct oce_softc *sc, uint32_t flow_control);

int oce_stats_be2(struct oce_softc *sc, uint64_t *rxe, uint64_t *txe);
int oce_stats_be3(struct oce_softc *sc, uint64_t *rxe, uint64_t *txe);
int oce_stats_xe(struct oce_softc *sc, uint64_t *rxe, uint64_t *txe);

/**
 * @@brief Wait for FW to become ready and reset it
 * @@param sc		software handle to the device
 */
int
oce_init_fw(struct oce_softc *sc)
{
	struct ioctl_common_function_reset fwcmd;
	uint32_t reg;
	int err = 0, tmo = 60000;

	/* read semaphore CSR */
	reg = OCE_READ_REG32(sc, csr, MPU_EP_SEMAPHORE(sc));

	/* if host is ready then wait for fw ready else send POST */
	if ((reg & MPU_EP_SEM_STAGE_MASK) <= POST_STAGE_AWAITING_HOST_RDY) {
		reg = (reg & ~MPU_EP_SEM_STAGE_MASK) | POST_STAGE_CHIP_RESET;
		OCE_WRITE_REG32(sc, csr, MPU_EP_SEMAPHORE(sc), reg);
	}

	/* wait for FW to become ready */
	for (;;) {
		if (--tmo == 0)
			break;

		DELAY(1000);

		reg = OCE_READ_REG32(sc, csr, MPU_EP_SEMAPHORE(sc));
		if (reg & MPU_EP_SEM_ERROR) {
			printf(": POST failed: %#x\n", reg);
			return (ENXIO);
		}
		if ((reg & MPU_EP_SEM_STAGE_MASK) == POST_STAGE_ARMFW_READY) {
			/* reset FW */
			if (sc->flags & OCE_FLAGS_RESET_RQD) {
				bzero(&fwcmd, sizeof(fwcmd));
				err = oce_cmd(sc, SUBSYS_COMMON,
				    OPCODE_COMMON_FUNCTION_RESET,
				    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
			}
			return (err);
		}
	}

	printf(": POST timed out: %#x\n", reg);

	return (ENXIO);
}

static inline int
oce_mbox_wait(struct oce_softc *sc)
{
	int i;

	for (i = 0; i < 20000; i++) {
		if (OCE_READ_REG32(sc, db, PD_MPU_MBOX_DB) &
		    PD_MPU_MBOX_DB_READY)
			return (0);
		DELAY(100);
	}
	return (ETIMEDOUT);
}

/**
 * @@brief Mailbox dispatch
 * @@param sc		software handle to the device
 */
int
oce_mbox_dispatch(struct oce_softc *sc)
{
	uint32_t pa, reg;
	int err;

	pa = (uint32_t)((uint64_t)sc->bsmbx.paddr >> 34);
	reg = PD_MPU_MBOX_DB_HI | (pa << PD_MPU_MBOX_DB_ADDR_SHIFT);

	if ((err = oce_mbox_wait(sc)) != 0)
		goto out;

	OCE_WRITE_REG32(sc, db, PD_MPU_MBOX_DB, reg);

	pa = (uint32_t)((uint64_t)sc->bsmbx.paddr >> 4) & 0x3fffffff;
	reg = pa << PD_MPU_MBOX_DB_ADDR_SHIFT;

	if ((err = oce_mbox_wait(sc)) != 0)
		goto out;

	OCE_WRITE_REG32(sc, db, PD_MPU_MBOX_DB, reg);

	oce_dma_sync(&sc->bsmbx, BUS_DMASYNC_POSTWRITE);

	if ((err = oce_mbox_wait(sc)) != 0)
		goto out;

out:
	oce_dma_sync(&sc->bsmbx, BUS_DMASYNC_PREREAD);
	if (err)
		printf("%s: mailbox timeout\n", sc->dev.dv_xname);
	return (err);
}

/**
 * @@brief Function to initialize the hw with host endian information
 * @@param sc		software handle to the device
 * @@returns		0 on success, ETIMEDOUT on failure
 */
int
oce_mbox_init(struct oce_softc *sc)
{
	struct oce_bmbx *bmbx = OCE_DMAPTR(&sc->bsmbx, struct oce_bmbx);
	uint8_t *ptr = (uint8_t *)&bmbx->mbx;

	if (sc->flags & OCE_FLAGS_MBOX_ENDIAN_RQD) {
		/* Endian Signature */
		*ptr++ = 0xff;
		*ptr++ = 0x12;
		*ptr++ = 0x34;
		*ptr++ = 0xff;
		*ptr++ = 0xff;
		*ptr++ = 0x56;
		*ptr++ = 0x78;
		*ptr = 0xff;

		return (oce_mbox_dispatch(sc));
	}

	return (0);
}

int
oce_cmd(struct oce_softc *sc, int subsys, int opcode, int version,
    void *payload, int length)
{
	struct oce_bmbx *bmbx = OCE_DMAPTR(&sc->bsmbx, struct oce_bmbx);
	struct oce_mbx *mbx = &bmbx->mbx;
	struct oce_dma_mem sgl;
	struct mbx_hdr *hdr;
	caddr_t epayload = NULL;
	int err;

	if (length > OCE_MBX_PAYLOAD) {
		if (oce_dma_alloc(sc, length, &sgl))
			return (-1);
		epayload = OCE_DMAPTR(&sgl, char);
	}

	oce_dma_sync(&sc->bsmbx, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	bzero(mbx, sizeof(struct oce_mbx));

	mbx->payload_length = length;

	if (epayload) {
		mbx->u0.s.sge_count = 1;
		oce_dma_sync(&sgl, BUS_DMASYNC_PREWRITE);
		bcopy(payload, epayload, length);
		mbx->payload.u0.u1.sgl[0].paddr = sgl.paddr;
		mbx->payload.u0.u1.sgl[0].length = length;
		hdr = OCE_DMAPTR(&sgl, struct mbx_hdr);
	} else {
		mbx->u0.s.embedded = 1;
		bcopy(payload, &mbx->payload, length);
		hdr = (struct mbx_hdr *)&mbx->payload;
	}

	hdr->u0.req.opcode = opcode;
	hdr->u0.req.subsystem = subsys;
	hdr->u0.req.request_length = length - sizeof(*hdr);
	hdr->u0.req.version = version;
	if (opcode == OPCODE_COMMON_FUNCTION_RESET)
		hdr->u0.req.timeout = 2 * MBX_TIMEOUT_SEC;
	else
		hdr->u0.req.timeout = MBX_TIMEOUT_SEC;

	err = oce_mbox_dispatch(sc);
	if (err == 0) {
		if (epayload) {
			oce_dma_sync(&sgl, BUS_DMASYNC_POSTWRITE);
			bcopy(epayload, payload, length);
		} else
			bcopy(&mbx->payload, payload, length);
	} else
		printf("%s: mailbox error %d\n", sc->dev.dv_xname, err);
	if (epayload)
		oce_dma_free(sc, &sgl);
	return (err);
}

/**
 * @@brief	Firmware will send gracious notifications during
 *		attach only after sending first mcc commnad. We
 *		use MCC queue only for getting async and mailbox
 *		for sending cmds. So to get gracious notifications
 *		atleast send one dummy command on mcc.
 */
void
oce_first_mcc(struct oce_softc *sc)
{
	struct oce_mbx *mbx;
	struct oce_mq *mq = sc->mq;
	struct mbx_hdr *hdr;
	struct mbx_get_common_fw_version *fwcmd;
	uint32_t reg_value;

	mbx = RING_GET_PRODUCER_ITEM_VA(mq->ring, struct oce_mbx);
	bzero(mbx, sizeof(struct oce_mbx));

	fwcmd = (struct mbx_get_common_fw_version *)&mbx->payload;

	hdr = &fwcmd->hdr;
	hdr->u0.req.subsystem = SUBSYS_COMMON;
	hdr->u0.req.opcode = OPCODE_COMMON_GET_FW_VERSION;
	hdr->u0.req.version = OCE_MBX_VER_V0;
	hdr->u0.req.timeout = MBX_TIMEOUT_SEC;
	hdr->u0.req.request_length = sizeof(*fwcmd) - sizeof(*hdr);

	mbx->u0.s.embedded = 1;
	mbx->payload_length = sizeof(*fwcmd);
	oce_dma_sync(&mq->ring->dma, BUS_DMASYNC_PREREAD |
	    BUS_DMASYNC_PREWRITE);
	RING_PUT(mq->ring, 1);
	reg_value = (1 << 16) | mq->id;
	OCE_WRITE_REG32(sc, db, PD_MQ_DB, reg_value);
}

/**
 * @@brief Function for creating a network interface.
 * @@param sc		software handle to the device
 * @@returns		0 on success, error otherwise
 */
int
oce_create_iface(struct oce_softc *sc, uint8_t *macaddr)
{
	struct mbx_create_common_iface fwcmd;
	uint32_t capab_flags, capab_en_flags;
	int err = 0;

	/* interface capabilities to give device when creating interface */
	capab_flags = OCE_CAPAB_FLAGS;

	/* capabilities to enable by default (others set dynamically) */
	capab_en_flags = OCE_CAPAB_ENABLE;

	if (IS_XE201(sc)) {
		/* LANCER A0 workaround */
		capab_en_flags &= ~MBX_RX_IFACE_FLAGS_PASS_L3L4_ERR;
		capab_flags &= ~MBX_RX_IFACE_FLAGS_PASS_L3L4_ERR;
	}

	/* enable capabilities controlled via driver startup parameters */
	if (sc->rss_enable)
		capab_en_flags |= MBX_RX_IFACE_FLAGS_RSS;
	else {
		capab_en_flags &= ~MBX_RX_IFACE_FLAGS_RSS;
		capab_flags &= ~MBX_RX_IFACE_FLAGS_RSS;
	}

	bzero(&fwcmd, sizeof(fwcmd));

	fwcmd.params.req.version = 0;
	fwcmd.params.req.cap_flags = htole32(capab_flags);
	fwcmd.params.req.enable_flags = htole32(capab_en_flags);
	if (macaddr != NULL) {
		bcopy(macaddr, &fwcmd.params.req.mac_addr[0], ETH_ADDR_LEN);
		fwcmd.params.req.mac_invalid = 0;
	} else
		fwcmd.params.req.mac_invalid = 1;

	err = oce_cmd(sc, SUBSYS_COMMON, OPCODE_COMMON_CREATE_IFACE,
	    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
	if (err)
		return (err);

	sc->if_id = letoh32(fwcmd.params.rsp.if_id);

	if (macaddr != NULL)
		sc->pmac_id = letoh32(fwcmd.params.rsp.pmac_id);

	sc->nifs++;

	sc->if_cap_flags = capab_en_flags;

	/* Enable VLAN Promisc on HW */
	err = oce_config_vlan(sc, (uint8_t)sc->if_id, NULL, 0, 1, 1);
	if (err)
		return (err);

	/* set default flow control */
	err = oce_set_flow_control(sc, sc->flow_control);
	if (err)
		return (err);

	return 0;
}

/**
 * @@brief Function to send the mbx command to configure vlan
 * @@param sc 		software handle to the device
 * @@param if_id 	interface identifier index
 * @@param vtag_arr	array of vlan tags
 * @@param vtag_cnt	number of elements in array
 * @@param untagged	boolean TRUE/FLASE
 * @@param promisc	flag to enable/disable VLAN promiscuous mode
 * @@returns		0 on success, EIO on failure
 */
int
oce_config_vlan(struct oce_softc *sc, uint32_t if_id,
    struct normal_vlan *vtag_arr, int vtag_cnt, int untagged, int promisc)
{
	struct mbx_common_config_vlan fwcmd;
	int err;

	bzero(&fwcmd, sizeof(fwcmd));

	fwcmd.params.req.if_id = if_id;
	fwcmd.params.req.promisc = promisc;
	fwcmd.params.req.untagged = untagged;
	fwcmd.params.req.num_vlans = vtag_cnt;

	if (!promisc)
		bcopy(vtag_arr, fwcmd.params.req.tags.normal_vlans,
			vtag_cnt * sizeof(struct normal_vlan));

	err = oce_cmd(sc, SUBSYS_COMMON, OPCODE_COMMON_CONFIG_IFACE_VLAN,
	    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
	return (err);
}

/**
 * @@brief Function to set flow control capability in the hardware
 * @@param sc 		software handle to the device
 * @@param flow_control	flow control flags to set
 * @@returns		0 on success, EIO on failure
 */
int
oce_set_flow_control(struct oce_softc *sc, uint32_t flow_control)
{
	struct mbx_common_get_set_flow_control fwcmd;
	int err;

	bzero(&fwcmd, sizeof(fwcmd));

	if (flow_control & OCE_FC_TX)
		fwcmd.tx_flow_control = 1;
	if (flow_control & OCE_FC_RX)
		fwcmd.rx_flow_control = 1;

	err = oce_cmd(sc, SUBSYS_COMMON, OPCODE_COMMON_SET_FLOW_CONTROL,
	    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
	return (err);
}

#ifdef OCE_RSS
/**
 * @@brief Function to set flow control capability in the hardware
 * @@param sc 		software handle to the device
 * @@param if_id 	interface id to read the address from
 * @@param enable	0=disable, RSS_ENABLE_xxx flags otherwise
 * @@returns		0 on success, EIO on failure
 */
int
oce_config_rss(struct oce_softc *sc, uint32_t if_id, int enable)
{
	struct mbx_config_nic_rss fwcmd;
	uint8_t *tbl = &fwcmd.params.req.cputable;
	int i, j, err;

	bzero(&fwcmd, sizeof(fwcmd));

	if (enable)
		fwcmd.params.req.enable_rss = RSS_ENABLE_IPV4 |
		    RSS_ENABLE_TCP_IPV4 | RSS_ENABLE_IPV6 |
		    RSS_ENABLE_TCP_IPV6);
	fwcmd.params.req.flush = OCE_FLUSH;
	fwcmd.params.req.if_id = htole32(if_id);

	arc4random_buf(fwcmd.params.req.hash, sizeof(fwcmd.params.req.hash));

	/*
	 * Initialize the RSS CPU indirection table.
	 *
	 * The table is used to choose the queue to place incomming packets.
	 * Incomming packets are hashed.  The lowest bits in the hash result
	 * are used as the index into the CPU indirection table.
	 * Each entry in the table contains the RSS CPU-ID returned by the NIC
	 * create.  Based on the CPU ID, the receive completion is routed to
	 * the corresponding RSS CQs.  (Non-RSS packets are always completed
	 * on the default (0) CQ).
	 */
	for (i = 0, j = 0; j < sc->nrqs; j++) {
		if (sc->rq[j]->cfg.is_rss_queue)
			tbl[i++] = sc->rq[j]->rss_cpuid;
	}
	if (i > 0)
		fwcmd->params.req.cpu_tbl_sz_log2 = htole16(ilog2(i));
	else
		return (ENXIO);

	err = oce_cmd(sc, SUBSYS_NIC, OPCODE_NIC_CONFIG_RSS,
	    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
	return (err);
}
#endif	/* OCE_RSS */

/**
 * @@brief Function for hardware update multicast filter
 * @@param sc		software handle to the device
 * @@param multi		table of multicast addresses
 * @@param naddr		number of multicast addresses in the table
 */
int
oce_update_mcast(struct oce_softc *sc,
    uint8_t multi[][ETH_ADDR_LEN], int naddr)
{
	struct mbx_set_common_iface_multicast fwcmd;
	int err;

	bzero(&fwcmd, sizeof(fwcmd));

	bcopy(&multi[0], &fwcmd.params.req.mac[0], naddr * ETH_ADDR_LEN);
	fwcmd.params.req.num_mac = htole16(naddr);
	fwcmd.params.req.if_id = sc->if_id;

	err = oce_cmd(sc, SUBSYS_COMMON, OPCODE_COMMON_SET_IFACE_MULTICAST,
	    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
	return (err);
}

/**
 * @@brief RXF function to enable/disable device promiscuous mode
 * @@param sc		software handle to the device
 * @@param enable	enable/disable flag
 * @@returns		0 on success, EIO on failure
 * @@note
 *	The OPCODE_NIC_CONFIG_PROMISCUOUS command deprecated for Lancer.
 *	This function uses the COMMON_SET_IFACE_RX_FILTER command instead.
 */
int
oce_set_promisc(struct oce_softc *sc, int enable)
{
	struct mbx_set_common_iface_rx_filter fwcmd;
	struct iface_rx_filter_ctx *req;
	int rc;

	bzero(&fwcmd, sizeof(fwcmd));

	req = &fwcmd.params.req;
	req->if_id = sc->if_id;
	req->iface_flags_mask = MBX_RX_IFACE_FLAGS_PROMISC |
				MBX_RX_IFACE_FLAGS_VLAN_PROMISC;
	if (enable)
		req->iface_flags = req->iface_flags_mask;

	rc = oce_cmd(sc, SUBSYS_COMMON, OPCODE_COMMON_SET_IFACE_RX_FILTER,
	    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));

	return rc;
}

/**
 * @@brief Function to query the link status from the hardware
 * @@param sc 		software handle to the device
 * @@param[out] link	pointer to the structure returning link attributes
 * @@returns		0 on success, EIO on failure
 */
int
oce_get_link_status(struct oce_softc *sc)
{
	struct mbx_query_common_link_config fwcmd;
	struct link_status link;
	int err;

	bzero(&fwcmd, sizeof(fwcmd));

	err = oce_cmd(sc, SUBSYS_COMMON, OPCODE_COMMON_QUERY_LINK_CONFIG,
	    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
	if (err)
		return (err);

	bcopy(&fwcmd.params.rsp, &link, sizeof(struct link_status));
	link.logical_link_status = letoh32(link.logical_link_status);
	link.qos_link_speed = letoh16(link.qos_link_speed);

	if (link.logical_link_status == NTWK_LOGICAL_LINK_UP)
		sc->link_status = NTWK_LOGICAL_LINK_UP;
	else
		sc->link_status = NTWK_LOGICAL_LINK_DOWN;

	if (link.mac_speed > 0 && link.mac_speed < 5)
		sc->link_speed = link.mac_speed;
	else
		sc->link_speed = 0;

	sc->duplex = link.mac_duplex;

	sc->qos_link_speed = (uint32_t )link.qos_link_speed * 10;

	return (0);
}

int
oce_macaddr_get(struct oce_softc *sc, uint8_t *macaddr)
{
	struct mbx_query_common_iface_mac fwcmd;
	int err;

	bzero(&fwcmd, sizeof(fwcmd));

	fwcmd.params.req.type = MAC_ADDRESS_TYPE_NETWORK;
	fwcmd.params.req.permanent = 1;

	err = oce_cmd(sc, SUBSYS_COMMON, OPCODE_COMMON_QUERY_IFACE_MAC,
	    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
	if (err == 0)
		bcopy(&fwcmd.params.rsp.mac.mac_addr[0], macaddr, ETH_ADDR_LEN);
	return (err);
}

int
oce_macaddr_add(struct oce_softc *sc, uint8_t *enaddr, uint32_t if_id,
    uint32_t *pmac_id)
{
	struct mbx_add_common_iface_mac fwcmd;
	int err;

	bzero(&fwcmd, sizeof(fwcmd));

	fwcmd.params.req.if_id = htole16(if_id);
	bcopy(enaddr, fwcmd.params.req.mac_address, ETH_ADDR_LEN);

	err = oce_cmd(sc, SUBSYS_COMMON, OPCODE_COMMON_ADD_IFACE_MAC,
	    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
	if (err == 0)
		*pmac_id = letoh32(fwcmd.params.rsp.pmac_id);
	return (err);
}

int
oce_macaddr_del(struct oce_softc *sc, uint32_t if_id, uint32_t pmac_id)
{
	struct mbx_del_common_iface_mac fwcmd;
	int err;

	bzero(&fwcmd, sizeof(fwcmd));

	fwcmd.params.req.if_id = htole16(if_id);
	fwcmd.params.req.pmac_id = htole32(pmac_id);

	err = oce_cmd(sc, SUBSYS_COMMON, OPCODE_COMMON_DEL_IFACE_MAC,
	    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
	return (err);
}

int
oce_check_native_mode(struct oce_softc *sc)
{
	struct mbx_common_set_function_cap fwcmd;
	int err;

	bzero(&fwcmd, sizeof(fwcmd));

	fwcmd.params.req.valid_capability_flags = CAP_SW_TIMESTAMPS |
	    CAP_BE3_NATIVE_ERX_API;
	fwcmd.params.req.capability_flags = CAP_BE3_NATIVE_ERX_API;

	err = oce_cmd(sc, SUBSYS_COMMON,
	    OPCODE_COMMON_SET_FUNCTIONAL_CAPS, OCE_MBX_VER_V0, &fwcmd,
	    sizeof(fwcmd));
	if (err)
		return (err);

	sc->be3_native = fwcmd.params.rsp.capability_flags &
	    CAP_BE3_NATIVE_ERX_API;

	return (0);
}

int
oce_new_rq(struct oce_softc *sc, struct oce_rq *rq)
{
	struct mbx_create_nic_rq fwcmd;
	int err, npages;

	bzero(&fwcmd, sizeof(fwcmd));

	npages = oce_load_ring(sc, rq->ring, &fwcmd.params.req.pages[0],
	    nitems(fwcmd.params.req.pages));
	if (!npages) {
		printf("%s: failed to load the rq ring\n", __func__);
		return (1);
	}

	if (IS_XE201(sc)) {
		fwcmd.params.req.frag_size = rq->cfg.frag_size / 2048;
		fwcmd.params.req.page_size = 1;
	} else
		fwcmd.params.req.frag_size = ilog2(rq->cfg.frag_size);
	fwcmd.params.req.num_pages = npages;
	fwcmd.params.req.cq_id = rq->cq->id;
	fwcmd.params.req.if_id = htole32(sc->if_id);
	fwcmd.params.req.max_frame_size = htole16(rq->cfg.mtu);
	fwcmd.params.req.is_rss_queue = htole32(rq->cfg.is_rss_queue);

	err = oce_cmd(sc, SUBSYS_NIC, OPCODE_NIC_CREATE_RQ,
	    IS_XE201(sc) ? OCE_MBX_VER_V1 : OCE_MBX_VER_V0, &fwcmd,
	    sizeof(fwcmd));
	if (err)
		return (err);

	rq->id = letoh16(fwcmd.params.rsp.rq_id);
	rq->rss_cpuid = fwcmd.params.rsp.rss_cpuid;

	return (0);
}

int
oce_new_wq(struct oce_softc *sc, struct oce_wq *wq)
{
	struct mbx_create_nic_wq fwcmd;
	int err, npages;

	bzero(&fwcmd, sizeof(fwcmd));

	npages = oce_load_ring(sc, wq->ring, &fwcmd.params.req.pages[0],
	    nitems(fwcmd.params.req.pages));
	if (!npages) {
		printf("%s: failed to load the wq ring\n", __func__);
		return (1);
	}

	if (IS_XE201(sc))
		fwcmd.params.req.if_id = sc->if_id;
	fwcmd.params.req.nic_wq_type = wq->cfg.wq_type;
	fwcmd.params.req.num_pages = npages;
	fwcmd.params.req.wq_size = ilog2(wq->cfg.q_len) + 1;
	fwcmd.params.req.cq_id = htole16(wq->cq->id);
	fwcmd.params.req.ulp_num = 1;

	err = oce_cmd(sc, SUBSYS_NIC, OPCODE_NIC_CREATE_WQ,
	    IS_XE201(sc) ? OCE_MBX_VER_V1 : OCE_MBX_VER_V0, &fwcmd,
	    sizeof(fwcmd));
	if (err)
		return (err);

	wq->id = letoh16(fwcmd.params.rsp.wq_id);

	return (0);
}

int
oce_new_mq(struct oce_softc *sc, struct oce_mq *mq)
{
	struct mbx_create_common_mq_ex fwcmd;
	union oce_mq_ext_ctx *ctx;
	int err, npages;

	bzero(&fwcmd, sizeof(fwcmd));

	npages = oce_load_ring(sc, mq->ring, &fwcmd.params.req.pages[0],
	    nitems(fwcmd.params.req.pages));
	if (!npages) {
		printf("%s: failed to load the mq ring\n", __func__);
		return (-1);
	}

	ctx = &fwcmd.params.req.context;
	ctx->v0.num_pages = npages;
	ctx->v0.cq_id = mq->cq->id;
	ctx->v0.ring_size = ilog2(mq->cfg.q_len) + 1;
	ctx->v0.valid = 1;
	/* Subscribe to Link State and Group 5 Events(bits 1 and 5 set) */
	ctx->v0.async_evt_bitmap = 0xffffffff;

	err = oce_cmd(sc, SUBSYS_COMMON, OPCODE_COMMON_CREATE_MQ_EXT,
	    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
	if (err)
		return (err);

	mq->id = letoh16(fwcmd.params.rsp.mq_id);

	return (0);
}

int
oce_new_eq(struct oce_softc *sc, struct oce_eq *eq)
{
	struct mbx_create_common_eq fwcmd;
	int err, npages;

	bzero(&fwcmd, sizeof(fwcmd));

	npages = oce_load_ring(sc, eq->ring, &fwcmd.params.req.pages[0],
	    nitems(fwcmd.params.req.pages));
	if (!npages) {
		printf("%s: failed to load the eq ring\n", __func__);
		return (-1);
	}

	fwcmd.params.req.ctx.num_pages = htole16(npages);
	fwcmd.params.req.ctx.valid = 1;
	fwcmd.params.req.ctx.size = (eq->cfg.item_size == 4) ? 0 : 1;
	fwcmd.params.req.ctx.count = ilog2(eq->cfg.q_len / 256);
	fwcmd.params.req.ctx.armed = 0;
	fwcmd.params.req.ctx.delay_mult = htole32(eq->cfg.cur_eqd);

	err = oce_cmd(sc, SUBSYS_COMMON, OPCODE_COMMON_CREATE_EQ,
	    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
	if (err)
		return (err);

	eq->id = letoh16(fwcmd.params.rsp.eq_id);

	return (0);
}

int
oce_new_cq(struct oce_softc *sc, struct oce_cq *cq)
{
	struct mbx_create_common_cq fwcmd;
	union oce_cq_ctx *ctx;
	int err, npages;

	bzero(&fwcmd, sizeof(fwcmd));

	npages = oce_load_ring(sc, cq->ring, &fwcmd.params.req.pages[0],
	    nitems(fwcmd.params.req.pages));
	if (!npages) {
		printf("%s: failed to load the cq ring\n", __func__);
		return (-1);
	}

	ctx = &fwcmd.params.req.cq_ctx;

	if (IS_XE201(sc)) {
		ctx->v2.num_pages = htole16(npages);
		ctx->v2.page_size = 1; /* for 4K */
		ctx->v2.eventable = cq->cfg.eventable;
		ctx->v2.valid = 1;
		ctx->v2.count = ilog2(cq->cfg.q_len / 256);
		ctx->v2.nodelay = cq->cfg.nodelay;
		ctx->v2.coalesce_wm = cq->cfg.ncoalesce;
		ctx->v2.armed = 0;
		ctx->v2.eq_id = cq->eq->id;
		if (ctx->v2.count == 3) {
			if (cq->cfg.q_len > (4*1024)-1)
				ctx->v2.cqe_count = (4*1024)-1;
			else
				ctx->v2.cqe_count = cq->cfg.q_len;
		}
	} else {
		ctx->v0.num_pages = htole16(npages);
		ctx->v0.eventable = cq->cfg.eventable;
		ctx->v0.valid = 1;
		ctx->v0.count = ilog2(cq->cfg.q_len / 256);
		ctx->v0.nodelay = cq->cfg.nodelay;
		ctx->v0.coalesce_wm = cq->cfg.ncoalesce;
		ctx->v0.armed = 0;
		ctx->v0.eq_id = cq->eq->id;
	}

	err = oce_cmd(sc, SUBSYS_COMMON, OPCODE_COMMON_CREATE_CQ,
	    IS_XE201(sc) ? OCE_MBX_VER_V2 : OCE_MBX_VER_V0, &fwcmd,
	    sizeof(fwcmd));
	if (err)
		return (err);

	cq->id = letoh16(fwcmd.params.rsp.cq_id);

	return (0);
}

int
oce_destroy_queue(struct oce_softc *sc, enum qtype qtype, uint32_t qid)
{
	struct mbx_destroy_common_mq fwcmd;
	int opcode, subsys, err;

	switch (qtype) {
	case QTYPE_CQ:
		opcode = OPCODE_COMMON_DESTROY_CQ;
		subsys = SUBSYS_COMMON;
		break;
	case QTYPE_EQ:
		opcode = OPCODE_COMMON_DESTROY_EQ;
		subsys = SUBSYS_COMMON;
		break;
	case QTYPE_MQ:
		opcode = OPCODE_COMMON_DESTROY_MQ;
		subsys = SUBSYS_COMMON;
		break;
	case QTYPE_RQ:
		opcode = OPCODE_NIC_DELETE_RQ;
		subsys = SUBSYS_NIC;
		break;
	case QTYPE_WQ:
		opcode = OPCODE_NIC_DELETE_WQ;
		subsys = SUBSYS_NIC;
		break;
	default:
		return (EINVAL);
	}

	bzero(&fwcmd, sizeof(fwcmd));

	fwcmd.params.req.id = htole16(qid);

	err = oce_cmd(sc, subsys, opcode, OCE_MBX_VER_V0, &fwcmd,
	    sizeof(fwcmd));
	return (err);
}

int
oce_stats_be2(struct oce_softc *sc, uint64_t *rxe, uint64_t *txe)
{
	struct mbx_get_nic_stats_v0 fwcmd;
	struct oce_pmem_stats *ms;
	struct oce_rxf_stats_v0 *rs;
	struct oce_port_rxf_stats_v0 *ps;
	int err;

	bzero(&fwcmd, sizeof(fwcmd));

	err = oce_cmd(sc, SUBSYS_NIC, OPCODE_NIC_GET_STATS, OCE_MBX_VER_V0,
	    &fwcmd, sizeof(fwcmd));
	if (err)
		return (err);

	ms = &fwcmd.params.rsp.stats.pmem;
	rs = &fwcmd.params.rsp.stats.rxf;
	ps = &rs->port[sc->port_id];

	*rxe = ps->rx_crc_errors + ps->rx_in_range_errors +
	    ps->rx_frame_too_long + ps->rx_dropped_runt +
	    ps->rx_ip_checksum_errs + ps->rx_tcp_checksum_errs +
	    ps->rx_udp_checksum_errs + ps->rxpp_fifo_overflow_drop +
	    ps->rx_dropped_tcp_length + ps->rx_dropped_too_small +
	    ps->rx_dropped_too_short + ps->rx_out_range_errors +
	    ps->rx_dropped_header_too_small + ps->rx_input_fifo_overflow_drop +
	    ps->rx_alignment_symbol_errors;
	if (sc->if_id)
		*rxe += rs->port1_jabber_events;
	else
		*rxe += rs->port0_jabber_events;
	*rxe += ms->eth_red_drops;

	*txe = 0; /* hardware doesn't provide any extra tx error statistics */

	return (0);
}

int
oce_stats_be3(struct oce_softc *sc, uint64_t *rxe, uint64_t *txe)
{
	struct mbx_get_nic_stats fwcmd;
	struct oce_pmem_stats *ms;
	struct oce_rxf_stats_v1 *rs;
	struct oce_port_rxf_stats_v1 *ps;
	int err;

	bzero(&fwcmd, sizeof(fwcmd));

	err = oce_cmd(sc, SUBSYS_NIC, OPCODE_NIC_GET_STATS, OCE_MBX_VER_V1,
	    &fwcmd, sizeof(fwcmd));
	if (err)
		return (err);

	ms = &fwcmd.params.rsp.stats.pmem;
	rs = &fwcmd.params.rsp.stats.rxf;
	ps = &rs->port[sc->port_id];

	*rxe = ps->rx_crc_errors + ps->rx_in_range_errors +
	    ps->rx_frame_too_long + ps->rx_dropped_runt +
	    ps->rx_ip_checksum_errs + ps->rx_tcp_checksum_errs +
	    ps->rx_udp_checksum_errs + ps->rxpp_fifo_overflow_drop +
	    ps->rx_dropped_tcp_length + ps->rx_dropped_too_small +
	    ps->rx_dropped_too_short + ps->rx_out_range_errors +
	    ps->rx_dropped_header_too_small + ps->rx_input_fifo_overflow_drop +
	    ps->rx_alignment_symbol_errors + ps->jabber_events;
	*rxe += ms->eth_red_drops;

	*txe = 0; /* hardware doesn't provide any extra tx error statistics */

	return (0);
}

int
oce_stats_xe(struct oce_softc *sc, uint64_t *rxe, uint64_t *txe)
{
	struct mbx_get_pport_stats fwcmd;
	struct oce_pport_stats *pps;
	int err;

	bzero(&fwcmd, sizeof(fwcmd));

	fwcmd.params.req.reset_stats = 0;
	fwcmd.params.req.port_number = sc->if_id;

	err = oce_cmd(sc, SUBSYS_NIC, OPCODE_NIC_GET_PPORT_STATS,
	    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
	if (err)
		return (err);

	pps = &fwcmd.params.rsp.pps;

	*rxe = pps->rx_discards + pps->rx_errors + pps->rx_crc_errors +
	    pps->rx_alignment_errors + pps->rx_symbol_errors +
	    pps->rx_frames_too_long + pps->rx_internal_mac_errors +
	    pps->rx_undersize_pkts + pps->rx_oversize_pkts + pps->rx_jabbers +
	    pps->rx_control_frames_unknown_opcode + pps->rx_in_range_errors +
	    pps->rx_out_of_range_errors + pps->rx_ip_checksum_errors +
	    pps->rx_tcp_checksum_errors + pps->rx_udp_checksum_errors +
	    pps->rx_fifo_overflow + pps->rx_input_fifo_overflow +
	    pps->rx_drops_too_many_frags + pps->rx_drops_mtu;

	*txe = pps->tx_discards + pps->tx_errors + pps->tx_internal_mac_errors;

	return (0);
}

int
oce_update_stats(struct oce_softc *sc, uint64_t *rxe, uint64_t *txe)
{
	if (IS_BE(sc)) {
		if (sc->flags & OCE_FLAGS_BE2)
			return (oce_stats_be2(sc, rxe, txe));
		else
			return (oce_stats_be3(sc, rxe, txe));
	}
	return (oce_stats_xe(sc, rxe, txe));
}
@


1.23
log
@don't split mq sge paddr into low and high parts
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.22 2012/10/29 18:22:11 mikeb Exp $	*/
@


1.22
log
@rename oce_fw to oce_cmd and shorten MBX_SUBSYSTEM_* defines to SUBSYS_
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.21 2012/10/29 18:17:39 mikeb Exp $	*/
d268 1
a268 2
		mbx->payload.u0.u1.sgl[0].pa_lo = ADDR_LO(sgl.paddr);
		mbx->payload.u0.u1.sgl[0].pa_hi = ADDR_HI(sgl.paddr);
@


1.21
log
@rearrange the function layout a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.20 2012/10/29 18:14:28 mikeb Exp $	*/
d101 1
a101 1
int oce_fw(struct oce_softc *sc, int subsys, int opcode, int version,
d148 3
a150 3
				err = oce_fw(sc, MBX_SUBSYSTEM_COMMON,
				    OPCODE_COMMON_FUNCTION_RESET, OCE_MBX_VER_V0,
				    &fwcmd, sizeof(fwcmd));
d242 1
a242 1
oce_fw(struct oce_softc *sc, int subsys, int opcode, int version,
d323 1
a323 1
	hdr->u0.req.subsystem = MBX_SUBSYSTEM_COMMON;
d381 1
a381 1
	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON, OPCODE_COMMON_CREATE_IFACE,
d436 1
a436 1
	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON, OPCODE_COMMON_CONFIG_IFACE_VLAN,
d460 1
a460 1
	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON, OPCODE_COMMON_SET_FLOW_CONTROL,
d511 1
a511 1
	err = oce_fw(sc, MBX_SUBSYSTEM_NIC, OPCODE_NIC_CONFIG_RSS,
d536 2
a537 3
	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON,
	    OPCODE_COMMON_SET_IFACE_MULTICAST, OCE_MBX_VER_V0,
	    &fwcmd, sizeof(fwcmd));
d566 1
a566 1
	rc = oce_fw(sc, MBX_SUBSYSTEM_COMMON, OPCODE_COMMON_SET_IFACE_RX_FILTER,
d587 1
a587 1
	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON, OPCODE_COMMON_QUERY_LINK_CONFIG,
d624 1
a624 1
	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON, OPCODE_COMMON_QUERY_IFACE_MAC,
d643 1
a643 1
	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON, OPCODE_COMMON_ADD_IFACE_MAC,
d661 1
a661 1
	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON, OPCODE_COMMON_DEL_IFACE_MAC,
d678 1
a678 1
	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON,
d716 1
a716 1
	err = oce_fw(sc, MBX_SUBSYSTEM_NIC, OPCODE_NIC_CREATE_RQ,
d751 1
a751 1
	err = oce_fw(sc, MBX_SUBSYSTEM_NIC, OPCODE_NIC_CREATE_WQ,
d786 1
a786 1
	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON, OPCODE_COMMON_CREATE_MQ_EXT,
d818 1
a818 1
	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON, OPCODE_COMMON_CREATE_EQ,
d873 1
a873 1
	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON, OPCODE_COMMON_CREATE_CQ,
d893 1
a893 1
		subsys = MBX_SUBSYSTEM_COMMON;
d897 1
a897 1
		subsys = MBX_SUBSYSTEM_COMMON;
d901 1
a901 1
		subsys = MBX_SUBSYSTEM_COMMON;
d905 1
a905 1
		subsys = MBX_SUBSYSTEM_NIC;
d909 1
a909 1
		subsys = MBX_SUBSYSTEM_NIC;
d919 2
a920 1
	err = oce_fw(sc, subsys, opcode, OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
d935 2
a936 2
	err = oce_fw(sc, MBX_SUBSYSTEM_NIC, OPCODE_NIC_GET_STATS,
	    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
d974 2
a975 2
	err = oce_fw(sc, MBX_SUBSYSTEM_NIC, OPCODE_NIC_GET_STATS,
	    OCE_MBX_VER_V1, &fwcmd, sizeof(fwcmd));
d1010 1
a1010 1
	err = oce_fw(sc, MBX_SUBSYSTEM_NIC, OPCODE_NIC_GET_PPORT_STATS,
@


1.20
log
@oce_get_fw_config is useless; ditch it
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.19 2012/10/26 23:35:09 mikeb Exp $	*/
a160 70
/**
 * @@brief Function for creating a network interface.
 * @@param sc		software handle to the device
 * @@returns		0 on success, error otherwise
 */
int
oce_create_iface(struct oce_softc *sc, uint8_t *macaddr)
{
	struct mbx_create_common_iface fwcmd;
	uint32_t capab_flags, capab_en_flags;
	int err = 0;

	/* interface capabilities to give device when creating interface */
	capab_flags = OCE_CAPAB_FLAGS;

	/* capabilities to enable by default (others set dynamically) */
	capab_en_flags = OCE_CAPAB_ENABLE;

	if (IS_XE201(sc)) {
		/* LANCER A0 workaround */
		capab_en_flags &= ~MBX_RX_IFACE_FLAGS_PASS_L3L4_ERR;
		capab_flags &= ~MBX_RX_IFACE_FLAGS_PASS_L3L4_ERR;
	}

	/* enable capabilities controlled via driver startup parameters */
	if (sc->rss_enable)
		capab_en_flags |= MBX_RX_IFACE_FLAGS_RSS;
	else {
		capab_en_flags &= ~MBX_RX_IFACE_FLAGS_RSS;
		capab_flags &= ~MBX_RX_IFACE_FLAGS_RSS;
	}

	bzero(&fwcmd, sizeof(fwcmd));

	fwcmd.params.req.version = 0;
	fwcmd.params.req.cap_flags = htole32(capab_flags);
	fwcmd.params.req.enable_flags = htole32(capab_en_flags);
	if (macaddr != NULL) {
		bcopy(macaddr, &fwcmd.params.req.mac_addr[0], ETH_ADDR_LEN);
		fwcmd.params.req.mac_invalid = 0;
	} else
		fwcmd.params.req.mac_invalid = 1;

	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON, OPCODE_COMMON_CREATE_IFACE,
	    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
	if (err)
		return (err);

	sc->if_id = letoh32(fwcmd.params.rsp.if_id);

	if (macaddr != NULL)
		sc->pmac_id = letoh32(fwcmd.params.rsp.pmac_id);

	sc->nifs++;

	sc->if_cap_flags = capab_en_flags;

	/* Enable VLAN Promisc on HW */
	err = oce_config_vlan(sc, (uint8_t)sc->if_id, NULL, 0, 1, 1);
	if (err)
		return (err);

	/* set default flow control */
	err = oce_set_flow_control(sc, sc->flow_control);
	if (err)
		return (err);

	return 0;
}

d338 5
d344 1
a344 1
oce_read_macaddr(struct oce_softc *sc, uint8_t *macaddr)
d346 23
a368 2
	struct mbx_query_common_iface_mac fwcmd;
	int err;
d372 8
a379 2
	fwcmd.params.req.type = MAC_ADDRESS_TYPE_NETWORK;
	fwcmd.params.req.permanent = 1;
d381 1
a381 1
	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON, OPCODE_COMMON_QUERY_IFACE_MAC,
d383 23
a405 3
	if (err == 0)
		bcopy(&fwcmd.params.rsp.mac.mac_addr[0], macaddr, ETH_ADDR_LEN);
	return (err);
d612 18
@


1.19
log
@oce_first_mcc_cmd doesn't return anything of value so make it void;
shorten it to oce_first_mcc while here
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.18 2012/10/26 22:45:36 mikeb Exp $	*/
a368 34
}

/**
 * @@brief Function to query the fw attributes from the hw
 * @@param sc		software handle to the device
 * @@returns		0 on success, EIO on failure
 */
int
oce_get_fw_config(struct oce_softc *sc)
{
	struct mbx_common_query_fw_config fwcmd;
	int err;

	bzero(&fwcmd, sizeof(fwcmd));

	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON,
	    OPCODE_COMMON_QUERY_FIRMWARE_CONFIG, OCE_MBX_VER_V0, &fwcmd,
	    sizeof(fwcmd));
	if (err)
		return (err);

	sc->port_id	  = fwcmd.params.rsp.port_id;
	sc->function_mode = fwcmd.params.rsp.function_mode;
	sc->function_caps = fwcmd.params.rsp.function_caps;

	if (fwcmd.params.rsp.ulp[0].ulp_mode & ULP_NIC_MODE) {
		sc->max_tx_rings = fwcmd.params.rsp.ulp[0].nic_wq_tot;
		sc->max_rx_rings = fwcmd.params.rsp.ulp[0].lro_rqid_tot;
	} else {
		sc->max_tx_rings = fwcmd.params.rsp.ulp[1].nic_wq_tot;
		sc->max_rx_rings = fwcmd.params.rsp.ulp[1].lro_rqid_tot;
	}

	return (0);
@


1.18
log
@simplify the way we collect statistics
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.17 2012/10/26 18:05:50 mikeb Exp $	*/
d412 2
a413 2
int
oce_first_mcc_cmd(struct oce_softc *sc)
a439 2

	return (0);
@


1.17
log
@cleanup oce_init_fw; use less bitfields
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.16 2012/10/26 17:56:24 mikeb Exp $	*/
d108 3
a110 4
int oce_mbox_get_nic_stats_v0(struct oce_softc *sc, void *buf);
int oce_mbox_get_nic_stats(struct oce_softc *sc, void *buf);
int oce_mbox_get_pport_stats(struct oce_softc *sc, void *buf,
    uint32_t reset_stats);
a959 7
/**
 * @@brief Function to get NIC statistics for BE2 devices
 * @@param sc 		software handle to the device
 * @@param *buf		pointer to where to store statistics
 * @@returns		0 on success, EIO on failure
 * @@note		command depricated in Lancer
 */
d961 1
a961 1
oce_mbox_get_nic_stats_v0(struct oce_softc *sc, void *buf)
d963 4
a966 1
	struct mbx_get_nic_stats_v0 *fwcmd = buf;
d969 1
a969 1
	bzero(fwcmd, sizeof(*fwcmd));
d972 3
a974 66
	    OCE_MBX_VER_V0, fwcmd, sizeof(*fwcmd));
	return (err);
}

/**
 * @@brief Function to get NIC statistics for BE3 devices
 * @@param sc 		software handle to the device
 * @@param *buf		pointer to where to store statistics
 * @@returns		0 on success, EIO on failure
 * @@note		command depricated in Lancer
 */
int
oce_mbox_get_nic_stats(struct oce_softc *sc, void *buf)
{
	struct mbx_get_nic_stats *fwcmd = buf;
	int err;

	bzero(fwcmd, sizeof(*fwcmd));

	err = oce_fw(sc, MBX_SUBSYSTEM_NIC, OPCODE_NIC_GET_STATS,
	    OCE_MBX_VER_V1, fwcmd, sizeof(*fwcmd));
	return (err);
}

/**
 * @@brief Function to get pport (physical port) statistics
 * @@param sc 		software handle to the device
 * @@param *buf		pointer to where to store statistics
 * @@param reset_stats	resets statistics of set
 * @@returns		0 on success, EIO on failure
 */
int
oce_mbox_get_pport_stats(struct oce_softc *sc, void *buf, uint32_t reset_stats)
{
	struct mbx_get_pport_stats *fwcmd = buf;
	int err;

	bzero(fwcmd, sizeof(*fwcmd));

	fwcmd->params.req.reset_stats = reset_stats;
	fwcmd->params.req.port_number = sc->if_id;

	err = oce_fw(sc, MBX_SUBSYSTEM_NIC, OPCODE_NIC_GET_PPORT_STATS,
	    OCE_MBX_VER_V0, fwcmd, sizeof(*fwcmd));
	return (err);
}

static inline void
update_stats_xe(struct oce_softc *sc, u_int64_t *rxe, u_int64_t *txe)
{
	struct mbx_get_pport_stats *mbx;
	struct oce_pport_stats *pps;

	mbx = &sc->stats.xe;
	mbx = (struct mbx_get_pport_stats *)&sc->stats;
	pps = &mbx->params.rsp.pps;

	*rxe = pps->rx_discards + pps->rx_errors + pps->rx_crc_errors +
	    pps->rx_alignment_errors + pps->rx_symbol_errors +
	    pps->rx_frames_too_long + pps->rx_internal_mac_errors +
	    pps->rx_undersize_pkts + pps->rx_oversize_pkts + pps->rx_jabbers +
	    pps->rx_control_frames_unknown_opcode + pps->rx_in_range_errors +
	    pps->rx_out_of_range_errors + pps->rx_ip_checksum_errors +
	    pps->rx_tcp_checksum_errors + pps->rx_udp_checksum_errors +
	    pps->rx_fifo_overflow + pps->rx_input_fifo_overflow +
	    pps->rx_drops_too_many_frags + pps->rx_drops_mtu;
d976 2
a977 14
	*txe = pps->tx_discards + pps->tx_errors + pps->tx_internal_mac_errors;
}

static inline void
update_stats_be2(struct oce_softc *sc, u_int64_t *rxe, u_int64_t *txe)
{
	struct mbx_get_nic_stats_v0 *mbx;
	struct oce_pmem_stats *ms;
	struct oce_rxf_stats_v0 *rs;
	struct oce_port_rxf_stats_v0 *ps;

	mbx = &sc->stats.be2;
	ms = &mbx->params.rsp.stats.pmem;
	rs = &mbx->params.rsp.stats.rxf;
d995 2
d999 2
a1000 2
static inline void
update_stats_be3(struct oce_softc *sc, u_int64_t *rxe, u_int64_t *txe)
d1002 1
a1002 1
	struct mbx_get_nic_stats *mbx;
d1006 3
d1010 7
a1016 3
	mbx = &sc->stats.be3;
	ms = &mbx->params.rsp.stats.pmem;
	rs = &mbx->params.rsp.stats.rxf;
d1030 2
d1035 1
a1035 1
oce_update_stats(struct oce_softc *sc, u_int64_t *rxe, u_int64_t *txe)
d1037 5
a1041 1
	int rc = 0;
d1043 28
d1072 4
a1075 14
		if (sc->flags & OCE_FLAGS_BE2) {
			rc = oce_mbox_get_nic_stats_v0(sc, &sc->stats);
			if (!rc)
				update_stats_be2(sc, rxe, txe);
		} else {
			rc = oce_mbox_get_nic_stats(sc, &sc->stats);
			if (!rc)
				update_stats_be3(sc, rxe, txe);
		}

	} else {
		rc = oce_mbox_get_pport_stats(sc, &sc->stats, 0);
		if (!rc)
			update_stats_xe(sc, rxe, txe);
d1077 1
a1077 2

	return rc;
@


1.16
log
@rename oce_config_nic_rss to oce_config_rss and merge oce_rss_itbl_init in;
cleanup oce_set_promisc and oce_config_vlan function arguments, a bunch of
defines and prototypes while at it.
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.15 2012/10/25 17:53:11 mikeb Exp $	*/
d121 2
a122 3
	mpu_ep_semaphore_t post_status;
	int tmo = 60000;
	int err = 0;
d125 1
a125 1
	post_status.dw0 = OCE_READ_REG32(sc, csr, MPU_EP_SEMAPHORE(sc));
d128 3
a130 3
	if (post_status.bits.stage <= POST_STAGE_AWAITING_HOST_RDY) {
		post_status.bits.stage = POST_STAGE_CHIP_RESET;
		OCE_WRITE_REG32(sc, csr, MPU_EP_SEMAPHORE(sc), post_status.dw0);
d140 4
a143 4
		post_status.dw0 = OCE_READ_REG32(sc, csr, MPU_EP_SEMAPHORE(sc));
		if (post_status.bits.error) {
			printf(": POST failed: %x\n", post_status.dw0);
			return ENXIO;
d145 1
a145 1
		if (post_status.bits.stage == POST_STAGE_ARMFW_READY) {
d147 2
a148 2
			bzero(&fwcmd, sizeof(fwcmd));
			if (sc->flags & OCE_FLAGS_FUNCRESET_RQD)
d152 1
d157 1
a157 1
	printf(": POST timed out: %x\n", post_status.dw0);
d159 1
a159 1
	return ENXIO;
@


1.15
log
@make oce_mbox_{dispatch,wait} more readable and use less bitfields
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.14 2012/10/25 17:01:26 mikeb Exp $	*/
d105 1
a105 2
    struct normal_vlan *vtag_arr, uint8_t vtag_cnt, uint32_t untagged,
    uint32_t enable_promisc);
a106 4
int oce_rss_itbl_init(struct oce_softc *sc, struct mbx_config_nic_rss *fwcmd);

int oce_set_common_iface_rx_filter(struct oce_softc *sc,
    struct oce_dma_mem *sgl);
d470 1
a470 1
 * @@param enable_promisc flag to enable/disable VLAN promiscuous mode
d475 1
a475 2
    struct normal_vlan *vtag_arr, uint8_t vtag_cnt, uint32_t untagged,
    uint32_t enable_promisc)
d482 3
a484 3
	fwcmd.params.req.if_id = (uint8_t) if_id;
	fwcmd.params.req.promisc = (uint8_t) enable_promisc;
	fwcmd.params.req.untagged = (uint8_t) untagged;
d487 1
a487 1
	if (!enable_promisc)
a521 41
 * @@brief Initialize the RSS CPU indirection table
 *
 * The table is used to choose the queue to place the incomming packets.
 * Incomming packets are hashed.  The lowest bits in the hash result
 * are used as the index into the CPU indirection table.
 * Each entry in the table contains the RSS CPU-ID returned by the NIC
 * create.  Based on the CPU ID, the receive completion is routed to
 * the corresponding RSS CQs.  (Non-RSS packets are always completed
 * on the default (0) CQ).
 *
 * @@param sc 		software handle to the device
 * @@param *fwcmd	pointer to the rss mbox command
 * @@returns		none
 */
int
oce_rss_itbl_init(struct oce_softc *sc, struct mbx_config_nic_rss *fwcmd)
{
	int i = 0, j = 0, rc = 0;
	uint8_t *tbl = fwcmd->params.req.cputable;

	for (j = 0; j < sc->nrqs; j++) {
		if (sc->rq[j]->cfg.is_rss_queue) {
			tbl[i] = sc->rq[j]->rss_cpuid;
			i = i + 1;
		}
	}
	if (i == 0) {
		printf("%s: error: Invalid number of RSS RQ's\n",
		    sc->dev.dv_xname);
		rc = ENXIO;

	}

	/* fill log2 value indicating the size of the CPU table */
	if (rc == 0)
		fwcmd->params.req.cpu_tbl_sz_log2 = htole16(ilog2(i));

	return rc;
}

/**
d525 1
a525 1
 * @@param enable_rss	0=disable, RSS_ENABLE_xxx flags otherwise
d529 1
a529 1
oce_config_nic_rss(struct oce_softc *sc, uint32_t if_id, uint16_t enable_rss)
d532 2
a533 1
	int err;
d537 1
a537 1
	if (enable_rss)
d546 19
a564 3
	err = oce_rss_itbl_init(sc, &fwcmd);
	if (err)
		return (err);
d573 1
a573 1
 * @@brief		Function for hardware update multicast filter
d598 1
a598 1
 * @@brief 		RXF function to enable/disable device promiscuous mode
d607 1
a607 1
oce_set_promisc(struct oce_softc *sc, uint32_t enable)
d617 2
a618 2
	req->iface_flags_mask = MBX_RX_IFACE_FLAGS_PROMISCUOUS |
				MBX_RX_IFACE_FLAGS_VLAN_PROMISCUOUS;
@


1.14
log
@Fix a hilarious bug where oce_set_promisc wouldn't zero out the
command buffer it sent to the card but an incorrect assignment of
the DMA address pointing to this buffer would offset the problem.
Once I've fixed an incorrect assignment oce_init started to fail.
Turns out that oce_set_promisc is about the only function whose
command size is larger than the payload of the standard command
buffer and needs an external chunk of DMA memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.13 2012/10/15 19:23:23 mikeb Exp $	*/
a98 1
int oce_mbox_wait(struct oce_softc *sc);
d168 1
a168 7
 * @@brief	Allocate PCI resources.
 *
 * @@param sc		software handle to the device
 * @@returns		0 if successful, or error
 */
/**
 * @@brief		Function for creating nw interface.
d237 1
a237 5
/**
 * @@brief Mailbox wait
 * @@param sc		software handle to the device
 */
int
a239 1
	pd_mpu_mbox_db_t mbox_db;
d243 2
a244 2
		mbox_db.dw0 = OCE_READ_REG32(sc, db, PD_MPU_MBOX_DB);
		if (mbox_db.bits.ready)
a247 3

	printf("%s: Mailbox timed out\n", sc->dev.dv_xname);

d258 13
a270 19
	pd_mpu_mbox_db_t mbox_db;
	uint32_t pa;
	int rc;

	oce_dma_sync(&sc->bsmbx, BUS_DMASYNC_PREWRITE);
	pa = (uint32_t) ((uint64_t) sc->bsmbx.paddr >> 34);
	bzero(&mbox_db, sizeof(pd_mpu_mbox_db_t));
	mbox_db.bits.ready = 0;
	mbox_db.bits.hi = 1;
	mbox_db.bits.address = pa;

	rc = oce_mbox_wait(sc);
	if (rc == 0) {
		OCE_WRITE_REG32(sc, db, PD_MPU_MBOX_DB, mbox_db.dw0);

		pa = (uint32_t) ((uint64_t) sc->bsmbx.paddr >> 4) & 0x3fffffff;
		mbox_db.bits.ready = 0;
		mbox_db.bits.hi = 0;
		mbox_db.bits.address = pa;
d272 2
a273 1
		rc = oce_mbox_wait(sc);
d275 1
a275 2
		if (rc == 0) {
			OCE_WRITE_REG32(sc, db, PD_MPU_MBOX_DB, mbox_db.dw0);
d277 1
a277 1
			rc = oce_mbox_wait(sc);
d279 2
a280 3
			oce_dma_sync(&sc->bsmbx, BUS_DMASYNC_POSTWRITE);
		}
	}
d282 5
a286 1
	return rc;
d297 2
a298 3
	struct oce_bmbx *mbx;
	uint8_t *ptr;
	int ret = 0;
a300 3
		mbx = OCE_DMAPTR(&sc->bsmbx, struct oce_bmbx);
		ptr = (uint8_t *) &mbx->mbx;

d311 1
a311 1
		ret = oce_mbox_dispatch(sc);
d314 1
a314 1
	return ret;
@


1.13
log
@major cleanup of the queue allocation code;  we need only half of
those functions.  fixup some dma syncs, not tested yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.12 2012/10/12 18:24:31 mikeb Exp $	*/
a338 5
/**
 * @@brief Function to initialize the hw with host endian information
 * @@param sc		software handle to the device
 * @@returns		0 on success, !0 on failure
 */
d348 1
a348 1
	int err, embed = 1;
a350 1
		embed = 0;
d356 2
a360 1
	mbx->tag[0] = 0;	/* ??? */
d362 1
a362 5
	if (embed) {
		mbx->u0.s.embedded = 1;
		bcopy(payload, &mbx->payload, length);
		hdr = (struct mbx_hdr *)&mbx->payload;
	} else {
d367 1
a367 1
		mbx->payload.u0.u1.sgl[0].pa_lo = ADDR_HI(sgl.paddr);
d370 4
d387 1
a387 1
		if (!embed) {
d393 2
a394 2
		printf("%s: %s: error %d\n", sc->dev.dv_xname, __func__, err);
	if (!embed)
d469 1
a469 1
	return 0;
a539 1

d664 2
@


1.12
log
@no need to fetch and print the fw revision
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.11 2012/10/12 17:41:40 mikeb Exp $	*/
d785 1
a785 1
oce_create_rq(struct oce_softc *sc, struct oce_rq *rq)
d823 1
a823 1
oce_create_wq(struct oce_softc *sc, struct oce_wq *wq)
d857 1
a857 1
oce_create_mq(struct oce_softc *sc, struct oce_mq *mq)
d891 1
a891 1
oce_create_eq(struct oce_softc *sc, struct oce_eq *eq)
d923 1
a923 1
oce_create_cq(struct oce_softc *sc, struct oce_cq *cq)
@


1.11
log
@major cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.10 2012/10/12 15:16:45 mikeb Exp $	*/
a404 20
 * @@brief 		Function to get the firmware version
 * @@param sc		software handle to the device
 * @@returns		0 on success, EIO on failure
 */
int
oce_get_fw_version(struct oce_softc *sc)
{
	struct mbx_get_common_fw_version fwcmd;
	int err;

	bzero(&fwcmd, sizeof(fwcmd));

	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON, OPCODE_COMMON_GET_FW_VERSION,
	    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
	if (err == 0)
		bcopy(fwcmd.params.rsp.fw_ver_str, sc->fw_version, 32);
	return (err);
}

/**
a422 1
	sc->asic_revision = fwcmd.params.rsp.asic_revision;
@


1.10
log
@a bit of janitoring
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.9 2012/10/11 16:38:10 mikeb Exp $	*/
a98 2
int oce_reset_fw(struct oce_softc *sc);
int oce_post(struct oce_softc *sc);
a100 1
int oce_mbox_init(struct oce_softc *sc);
a104 5
int oce_get_fw_version(struct oce_softc *sc);
int oce_get_fw_config(struct oce_softc *sc);
int oce_if_create(struct oce_softc *sc, uint32_t cap_flags, uint32_t en_flags,
    uint16_t vlan_tag, uint8_t *mac_addr, uint32_t *if_id);
int oce_if_del(struct oce_softc *sc, uint32_t if_id);
a113 2
int oce_mbox_check_native_mode(struct oce_softc *sc);

d120 1
a120 1
 * @@brief		Function to post status
d124 1
a124 1
oce_post(struct oce_softc *sc)
d126 1
d129 1
d140 1
a140 1
	/* wait for FW ready */
d149 1
a149 2
			printf("%s: POST failed: %x\n", sc->dev.dv_xname,
			    post_status.dw0);
d152 9
a160 2
		if (post_status.bits.stage == POST_STAGE_ARMFW_READY)
			return 0;
d163 1
a163 1
	printf("%s: POST timed out: %x\n", sc->dev.dv_xname, post_status.dw0);
a168 57
 * @@brief		Function for hardware initialization
 * @@param sc		software handle to the device
 */
int
oce_hw_init(struct oce_softc *sc)
{
	int rc = 0;

	rc = oce_post(sc);
	if (rc)
		return rc;

	/* create the bootstrap mailbox */
	rc = oce_dma_alloc(sc, sizeof(struct oce_bmbx), &sc->bsmbx);
	if (rc) {
		printf("%s: Mailbox alloc failed\n", sc->dev.dv_xname);
		return rc;
	}

	rc = oce_reset_fw(sc);
	if (rc)
		goto error;

	rc = oce_mbox_init(sc);
	if (rc)
		goto error;

	rc = oce_get_fw_version(sc);
	if (rc)
		goto error;

	rc = oce_get_fw_config(sc);
	if (rc)
		goto error;

	sc->macaddr.size_of_struct = 6;
	rc = oce_read_mac_addr(sc, 0, 1, MAC_ADDRESS_TYPE_NETWORK,
					&sc->macaddr);
	if (rc)
		goto error;

	if (IS_BE(sc) && (sc->flags & OCE_FLAGS_BE3)) {
		rc = oce_mbox_check_native_mode(sc);
		if (rc)
			goto error;
	} else
		sc->be3_native = 0;

	return rc;

error:
	oce_dma_free(sc, &sc->bsmbx);
	printf("%s: Hardware initialisation failed\n", sc->dev.dv_xname);
	return rc;
}

/**
a173 76
int
oce_hw_pci_alloc(struct oce_softc *sc)
{
	struct pci_attach_args *pa = &sc->pa;
	pci_sli_intf_t intf;
	pcireg_t memtype, reg;

	/* setup the device config region */
	if (IS_BE(sc) && (sc->flags & OCE_FLAGS_BE2))
		reg = OCE_BAR_CFG_BE2;
	else
		reg = OCE_BAR_CFG;

	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, reg);
	if (pci_mapreg_map(pa, reg, memtype, 0, &sc->cfg_btag,
	    &sc->cfg_bhandle, NULL, &sc->cfg_size,
	    IS_BE(sc) ? 0 : 32768)) {
		printf(": can't find cfg mem space\n");
		return ENXIO;
	}

	/* Read the SLI_INTF register and determine whether we
	 * can use this port and its features
	 */
	intf.dw0 = pci_conf_read(pa->pa_pc, pa->pa_tag, OCE_INTF_REG_OFFSET);

	if (intf.bits.sli_valid != OCE_INTF_VALID_SIG) {
		printf(": invalid signature\n");
		goto fail_1;
	}

	if (intf.bits.sli_rev != OCE_INTF_SLI_REV4) {
		printf(": adapter doesnt support SLI revision %d\n",
		    intf.bits.sli_rev);
		goto fail_1;
	}

	if (intf.bits.sli_if_type == OCE_INTF_IF_TYPE_1)
		sc->flags |= OCE_FLAGS_MBOX_ENDIAN_RQD;

	if (intf.bits.sli_hint1 == OCE_INTF_FUNC_RESET_REQD)
		sc->flags |= OCE_FLAGS_FUNCRESET_RQD;

	if (intf.bits.sli_func_type == OCE_INTF_VIRT_FUNC)
		sc->flags |= OCE_FLAGS_VIRTUAL_PORT;

	/* Lancer has one BAR (CFG) but BE3 has three (CFG, CSR, DB) */
	if (IS_BE(sc)) {
		/* set up CSR region */
		reg = OCE_BAR_CSR;
		memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, reg);
		if (pci_mapreg_map(pa, reg, memtype, 0, &sc->csr_btag,
		    &sc->csr_bhandle, NULL, &sc->csr_size, 0)) {
			printf(": can't find csr mem space\n");
			goto fail_1;
		}

		/* set up DB doorbell region */
		reg = OCE_BAR_DB;
		memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, reg);
		if (pci_mapreg_map(pa, reg, memtype, 0, &sc->db_btag,
		    &sc->db_bhandle, NULL, &sc->db_size, 0)) {
			printf(": can't find csr mem space\n");
			goto fail_2;
		}
	}

	return 0;

fail_2:
	bus_space_unmap(sc->csr_btag, sc->csr_bhandle, sc->csr_size);
fail_1:
	bus_space_unmap(sc->cfg_btag, sc->cfg_bhandle, sc->cfg_size);
	return ENXIO;
}

d180 1
a180 1
oce_create_iface(struct oce_softc *sc)
d182 3
a184 3
	int rc;
	uint32_t capab_flags;
	uint32_t capab_en_flags;
d206 20
a225 4
	rc = oce_if_create(sc, capab_flags, capab_en_flags, 0,
	    &sc->macaddr.mac_addr[0], &sc->if_id);
	if (rc)
		return rc;
d232 3
a234 3
	rc = oce_config_vlan(sc, (uint8_t)sc->if_id, NULL, 0, 1, 1);
	if (rc)
		goto error;
d237 3
a239 3
	rc = oce_set_flow_control(sc, sc->flow_control);
	if (rc)
		goto error;
d241 1
a241 79
	return rc;

error:
	oce_if_del(sc, sc->if_id);
	sc->nifs--;
	return rc;
}

/**
 * @@brief 		Function for hardware enable interupts.
 * @@param sc		software handle to the device
 */
void
oce_hw_intr_enable(struct oce_softc *sc)
{
	uint32_t reg;

	reg = OCE_READ_REG32(sc, cfg, PCICFG_INTR_CTRL);
	reg |= HOSTINTR_MASK;
	OCE_WRITE_REG32(sc, cfg, PCICFG_INTR_CTRL, reg);
}

/**
 * @@brief 		Function for hardware disable interupts
 * @@param sc		software handle to the device
 */
void
oce_hw_intr_disable(struct oce_softc *sc)
{
	uint32_t reg;

	reg = OCE_READ_REG32(sc, cfg, PCICFG_INTR_CTRL);
	reg &= ~HOSTINTR_MASK;
	OCE_WRITE_REG32(sc, cfg, PCICFG_INTR_CTRL, reg);
}

/**
 * @@brief		Function for hardware update multicast filter
 * @@param sc		software handle to the device
 * @@param multi		table of multicast addresses
 * @@param naddr		number of multicast addresses in the table
 */
int
oce_update_mcast(struct oce_softc *sc,
    uint8_t multi[][ETH_ADDR_LEN], int naddr)
{
	struct mbx_set_common_iface_multicast fwcmd;
	int err;

	bzero(&fwcmd, sizeof(fwcmd));

	bcopy(&multi[0], &fwcmd.params.req.mac[0], naddr * ETH_ADDR_LEN);
	fwcmd.params.req.num_mac = htole16(naddr);
	fwcmd.params.req.if_id = sc->if_id;

	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON,
	    OPCODE_COMMON_SET_IFACE_MULTICAST, OCE_MBX_VER_V0,
	    &fwcmd, sizeof(fwcmd));
	return (err);
}

/**
 * @@brief Reset (firmware) common function
 * @@param sc		software handle to the device
 * @@returns		0 on success, ETIMEDOUT on failure
 */
int
oce_reset_fw(struct oce_softc *sc)
{
	struct ioctl_common_function_reset fwcmd;
	int err = 0;

	bzero(&fwcmd, sizeof(fwcmd));

	if (sc->flags & OCE_FLAGS_FUNCRESET_RQD)
		err = oce_fw(sc, MBX_SUBSYSTEM_COMMON,
		    OPCODE_COMMON_FUNCTION_RESET, OCE_MBX_VER_V0,
		    &fwcmd, sizeof(fwcmd));
	return (err);
a424 74
 * @@brief	Firmware will send gracious notifications during
 *		attach only after sending first mcc commnad. We
 *		use MCC queue only for getting async and mailbox
 *		for sending cmds. So to get gracious notifications
 *		atleast send one dummy command on mcc.
 */
int
oce_first_mcc_cmd(struct oce_softc *sc)
{
	struct oce_mbx *mbx;
	struct oce_mq *mq = sc->mq;
	struct mbx_hdr *hdr;
	struct mbx_get_common_fw_version *fwcmd;
	uint32_t reg_value;

	mbx = RING_GET_PRODUCER_ITEM_VA(mq->ring, struct oce_mbx);
	bzero(mbx, sizeof(struct oce_mbx));

	fwcmd = (struct mbx_get_common_fw_version *)&mbx->payload;

	hdr = &fwcmd->hdr;
	hdr->u0.req.subsystem = MBX_SUBSYSTEM_COMMON;
	hdr->u0.req.opcode = OPCODE_COMMON_GET_FW_VERSION;
	hdr->u0.req.version = OCE_MBX_VER_V0;
	hdr->u0.req.timeout = MBX_TIMEOUT_SEC;
	hdr->u0.req.request_length = sizeof(*fwcmd) - sizeof(*hdr);

	mbx->u0.s.embedded = 1;
	mbx->payload_length = sizeof(*fwcmd);
	oce_dma_sync(&mq->ring->dma, BUS_DMASYNC_PREREAD |
	    BUS_DMASYNC_PREWRITE);
	RING_PUT(mq->ring, 1);
	reg_value = (1 << 16) | mq->mq_id;
	OCE_WRITE_REG32(sc, db, PD_MQ_DB, reg_value);

	return 0;
}

/**
 * @@brief Function to read the mac address associated with an interface
 * @@param sc		software handle to the device
 * @@param if_id 	interface id to read the address from
 * @@param perm 		set to 1 if reading the factory mac address.
 *			In this case if_id is ignored
 * @@param type 		type of the mac address, whether network or storage
 * @@param[out] mac 	[OUTPUT] pointer to a buffer containing the
 *			mac address when the command succeeds.
 * @@returns		0 on success, EIO on failure
 */
int
oce_read_mac_addr(struct oce_softc *sc, uint32_t if_id, uint8_t perm,
    uint8_t type, struct mac_address_format *mac)
{
	struct mbx_query_common_iface_mac fwcmd;
	int err;

	bzero(&fwcmd, sizeof(fwcmd));

	fwcmd.params.req.type = type;
	fwcmd.params.req.permanent = perm;
	if (!perm)
		fwcmd.params.req.if_id = (uint16_t)if_id;

	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON, OPCODE_COMMON_QUERY_IFACE_MAC,
	    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
	if (err == 0) {
		mac->size_of_struct = fwcmd.params.rsp.mac.size_of_struct;
		bcopy(&fwcmd.params.rsp.mac.mac_addr[0], &mac->mac_addr[0],
		    mac->size_of_struct);
	}
	return (err);
}

/**
a442 1
	sc->config_number = fwcmd.params.rsp.config_number;
d460 5
a464 10
 *
 * @@brief function to create a device interface
 * @@param sc		software handle to the device
 * @@param cap_flags	capability flags
 * @@param en_flags	enable capability flags
 * @@param vlan_tag	optional vlan tag to associate with the if
 * @@param mac_addr	pointer to a buffer containing the mac address
 * @@param[out] if_id	[OUTPUT] pointer to an integer to hold the ID of the
 interface created
 * @@returns		0 on success, EIO on failure
d467 1
a467 2
oce_if_create(struct oce_softc *sc, uint32_t cap_flags, uint32_t en_flags,
    uint16_t vlan_tag, uint8_t *mac_addr, uint32_t *if_id)
d469 5
a473 2
	struct mbx_create_common_iface fwcmd;
	int err = 0;
d475 2
a476 1
	bzero(&fwcmd, sizeof(fwcmd));
d478 1
a478 9
	fwcmd.params.req.version = 0;
	fwcmd.params.req.cap_flags = htole32(cap_flags);
	fwcmd.params.req.enable_flags = htole32(en_flags);
	if (mac_addr != NULL) {
		bcopy(mac_addr, &fwcmd.params.req.mac_addr[0], 6);
		fwcmd.params.req.vlan_tag.u0.normal.vtag = htole16(vlan_tag);
		fwcmd.params.req.mac_invalid = 0;
	} else
		fwcmd.params.req.mac_invalid = 1;
d480 6
a485 4
	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON, OPCODE_COMMON_CREATE_IFACE,
	    OCE_MBX_VER_V0, &fwcmd, sizeof(fwcmd));
	if (err)
		return (err);
d487 7
a493 1
	*if_id = letoh32(fwcmd.params.rsp.if_id);
d495 1
a495 4
	if (mac_addr != NULL)
		sc->pmac_id = letoh32(fwcmd.params.rsp.pmac_id);

	return (0);
a497 6
/**
 * @@brief		Function to delete an interface
 * @@param sc 		software handle to the device
 * @@param if_id		ID of the interface to delete
 * @@returns		0 on success, EIO on failure
 */
d499 1
a499 1
oce_if_del(struct oce_softc *sc, uint32_t if_id)
d501 1
a501 1
	struct mbx_destroy_common_iface fwcmd;
d506 2
a507 1
	fwcmd.params.req.if_id = if_id;
d509 1
a509 1
	err = oce_fw(sc, MBX_SUBSYSTEM_COMMON, OPCODE_COMMON_DESTROY_IFACE,
d511 2
d652 25
d747 1
a747 1
oce_mbox_macaddr_add(struct oce_softc *sc, uint8_t *mac_addr, uint32_t if_id,
d756 1
a756 1
	bcopy(mac_addr, fwcmd.params.req.mac_address, ETH_ADDR_LEN);
d766 1
a766 1
oce_mbox_macaddr_del(struct oce_softc *sc, uint32_t if_id, uint32_t pmac_id)
d782 1
a782 1
oce_mbox_check_native_mode(struct oce_softc *sc)
d806 1
a806 1
oce_mbox_create_rq(struct oce_rq *rq)
a808 1
	struct oce_softc *sc = rq->parent;
a810 3
	if (rq->qstate == QCREATED)
		return 0;

d826 1
a826 1
	fwcmd.params.req.cq_id = rq->cq->cq_id;
d837 1
a837 1
	rq->rq_id = letoh16(fwcmd.params.rsp.rq_id);
d844 1
a844 1
oce_mbox_create_wq(struct oce_wq *wq)
a846 1
	struct oce_softc *sc = wq->parent;
d863 1
a863 1
	fwcmd.params.req.cq_id = htole16(wq->cq->cq_id);
d872 1
a872 1
	wq->wq_id = letoh16(fwcmd.params.rsp.wq_id);
d878 1
a878 1
oce_mbox_create_mq(struct oce_mq *mq)
a880 1
	struct oce_softc *sc = mq->parent;
d895 1
a895 1
	ctx->v0.cq_id = mq->cq->cq_id;
d906 1
a906 1
	mq->mq_id = letoh16(fwcmd.params.rsp.mq_id);
d912 1
a912 1
oce_mbox_create_eq(struct oce_eq *eq)
a914 1
	struct oce_softc *sc = eq->parent;
d928 2
a929 2
	fwcmd.params.req.ctx.size = (eq->eq_cfg.item_size == 4) ? 0 : 1;
	fwcmd.params.req.ctx.count = ilog2(eq->eq_cfg.q_len / 256);
d931 1
a931 1
	fwcmd.params.req.ctx.delay_mult = htole32(eq->eq_cfg.cur_eqd);
d938 1
a938 1
	eq->eq_id = letoh16(fwcmd.params.rsp.eq_id);
d944 1
a944 2
oce_mbox_create_cq(struct oce_cq *cq, uint32_t ncoalesce,
    uint32_t is_eventable)
a946 1
	struct oce_softc *sc = cq->parent;
d964 1
a964 1
		ctx->v2.eventable = is_eventable;
d966 3
a968 3
		ctx->v2.count = ilog2(cq->cq_cfg.q_len / 256);
		ctx->v2.nodelay = cq->cq_cfg.nodelay;
		ctx->v2.coalesce_wm = ncoalesce;
d970 1
a970 1
		ctx->v2.eq_id = cq->eq->eq_id;
d972 1
a972 1
			if (cq->cq_cfg.q_len > (4*1024)-1)
d975 1
a975 1
				ctx->v2.cqe_count = cq->cq_cfg.q_len;
d979 1
a979 1
		ctx->v0.eventable = is_eventable;
d981 3
a983 3
		ctx->v0.count = ilog2(cq->cq_cfg.q_len / 256);
		ctx->v0.nodelay = cq->cq_cfg.nodelay;
		ctx->v0.coalesce_wm = ncoalesce;
d985 1
a985 1
		ctx->v0.eq_id = cq->eq->eq_id;
d994 1
a994 1
	cq->cq_id = letoh16(fwcmd.params.rsp.cq_id);
d1000 1
a1000 1
oce_mbox_destroy_q(struct oce_softc *sc, enum qtype qtype, uint32_t qid)
d1006 4
a1013 4
	case QTYPE_CQ:
		opcode = OPCODE_COMMON_DESTROY_CQ;
		subsys = MBX_SUBSYSTEM_COMMON;
		break;
d1018 4
a1023 4
		subsys = MBX_SUBSYSTEM_NIC;
		break;
	case QTYPE_RQ:
		opcode = OPCODE_NIC_DELETE_RQ;
@


1.9
log
@rework the firmware interface and incorporate all the guts into
one single function instead of spreading them across 10 others.
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.8 2012/10/11 16:34:30 mikeb Exp $	*/
d184 1
a184 1
	rc = oce_dma_alloc(sc, sizeof(struct oce_bmbx), &sc->bsmbx, 0);
d554 1
a554 1
		if (oce_dma_alloc(sc, length, &sgl, 0))
d1072 1
a1072 1
	npages = oce_page_list(sc, rq->ring, &fwcmd.params.req.pages[0],
d1111 1
a1111 1
	npages = oce_page_list(sc, wq->ring, &fwcmd.params.req.pages[0],
d1147 1
a1147 1
	npages = oce_page_list(sc, mq->ring, &fwcmd.params.req.pages[0],
d1181 1
a1181 1
	npages = oce_page_list(sc, eq->ring, &fwcmd.params.req.pages[0],
d1216 1
a1216 1
	npages = oce_page_list(sc, cq->ring, &fwcmd.params.req.pages[0],
@


1.8
log
@kill a scary unused function
@
text
@d1 17
a17 1
/*	$OpenBSD: oce.c,v 1.7 2012/10/11 16:33:57 mikeb Exp $	*/
d99 1
d101 7
a107 1
int oce_reset_fun(struct oce_softc *sc);
a108 1

a117 1
int oce_update_multicast(struct oce_softc *sc, struct oce_dma_mem *pdma_mem);
d124 4
a127 6
int oce_mbox_get_nic_stats_v0(struct oce_softc *sc,
    struct oce_dma_mem *pstats_dma_mem);
int oce_mbox_get_nic_stats(struct oce_softc *sc,
    struct oce_dma_mem *pstats_dma_mem);
int oce_mbox_get_pport_stats(struct oce_softc *sc,
    struct oce_dma_mem *pstats_dma_mem, uint32_t reset_stats);
d190 1
a190 1
	rc = oce_reset_fun(sc);
d315 1
a315 1
oce_create_nw_interface(struct oce_softc *sc)
d363 2
a364 1
	oce_delete_nw_interface(sc);
a368 14
 * @@brief		Function to delete a nw interface.
 * @@param sc		software handle to the device
 */
void
oce_delete_nw_interface(struct oce_softc *sc)
{
	/* currently only single interface is implmeneted */
	if (sc->nifs > 0) {
		oce_if_del(sc, sc->if_id);
		sc->nifs--;
	}
}

/**
d399 2
d403 2
a404 1
oce_hw_update_multicast(struct oce_softc *sc)
d406 4
a409 5
	struct ether_multi *enm;
	struct ether_multistep step;
	struct mbx_set_common_iface_multicast *req = NULL;
	struct oce_dma_mem dma;
	int rc = 0;
d411 3
a413 24
	/* Allocate DMA mem*/
	if (oce_dma_alloc(sc, sizeof(struct mbx_set_common_iface_multicast),
							&dma, 0))
		return ENOMEM;

	req = OCE_DMAPTR(&dma, struct mbx_set_common_iface_multicast);
	bzero(req, sizeof(struct mbx_set_common_iface_multicast));

	ETHER_FIRST_MULTI(step, &sc->arpcom, enm);
	while (enm != NULL) {
		if (req->params.req.num_mac == OCE_MAX_MC_FILTER_SIZE) {
			/*More multicast addresses than our hardware table
			  So Enable multicast promiscus in our hardware to
			  accept all multicat packets
			*/
			req->params.req.promiscuous = 1;
			break;
		}
		bcopy(enm->enm_addrlo,
			&req->params.req.mac[req->params.req.num_mac],
			ETH_ADDR_LEN);
		req->params.req.num_mac = req->params.req.num_mac + 1;
		ETHER_NEXT_MULTI(step, enm);
	}
d415 4
a418 4
	req->params.req.if_id = sc->if_id;
	rc = oce_update_multicast(sc, &dma);
	oce_dma_free(sc, &dma);
	return rc;
d427 1
a427 1
oce_reset_fun(struct oce_softc *sc)
d429 2
a430 22
	struct oce_mbx *mbx;
	struct oce_bmbx *mb;
	struct ioctl_common_function_reset *fwcmd;
	int rc = 0;

	if (sc->flags & OCE_FLAGS_FUNCRESET_RQD) {
		mb = OCE_DMAPTR(&sc->bsmbx, struct oce_bmbx);
		mbx = &mb->mbx;
		bzero(mbx, sizeof(struct oce_mbx));

		fwcmd = (struct ioctl_common_function_reset *)&mbx->payload;
		mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
					MBX_SUBSYSTEM_COMMON,
					OPCODE_COMMON_FUNCTION_RESET,
					10,	/* MBX_TIMEOUT_SEC */
					sizeof(struct
					    ioctl_common_function_reset),
					OCE_MBX_VER_V0);

		mbx->u0.s.embedded = 1;
		mbx->payload_length =
		    sizeof(struct ioctl_common_function_reset);
d432 1
a432 2
		rc = oce_mbox_dispatch(sc, 2);
	}
d434 5
a438 1
	return rc;
a443 1
 * @@param tmo_sec	timeout in seconds
d446 1
a446 1
oce_mbox_wait(struct oce_softc *sc, uint32_t tmo_sec)
a447 1
	tmo_sec *= 10000;
d449 1
d451 1
a451 6
	for (;;) {
		if (tmo_sec != 0) {
			if (--tmo_sec == 0)
				break;
		}

a452 1

d454 1
a454 2
			return 0;

d460 1
a460 1
	return ETIMEDOUT;
a465 1
 * @@param tmo_sec	timeout in seconds
d468 1
a468 1
oce_mbox_dispatch(struct oce_softc *sc, uint32_t tmo_sec)
d481 1
a481 1
	rc = oce_mbox_wait(sc, tmo_sec);
d490 1
a490 1
		rc = oce_mbox_wait(sc, tmo_sec);
d495 1
a495 1
			rc = oce_mbox_wait(sc, tmo_sec);
a504 25
 * @@brief 		Mailbox common request header initialization
 * @@param hdr		mailbox header
 * @@param dom		domain
 * @@param port		port
 * @@param subsys	subsystem
 * @@param opcode	opcode
 * @@param timeout	timeout
 * @@param payload_len	payload length
 */
void
mbx_common_req_hdr_init(struct mbx_hdr *hdr, uint8_t dom, uint8_t port,
    uint8_t subsys, uint8_t opcode, uint32_t timeout, uint32_t payload_len,
    uint8_t version)
{
	hdr->u0.req.opcode = opcode;
	hdr->u0.req.subsystem = subsys;
	hdr->u0.req.port_number = port;
	hdr->u0.req.domain = dom;

	hdr->u0.req.timeout = timeout;
	hdr->u0.req.request_length = payload_len - sizeof(struct mbx_hdr);
	hdr->u0.req.version = version;
}

/**
d530 1
a530 1
		ret = oce_mbox_dispatch(sc, 0);
d537 65
d609 2
a610 21
	struct oce_mbx mbx;
	struct mbx_get_common_fw_version *fwcmd;
	int ret = 0;

	bzero(&mbx, sizeof(struct oce_mbx));

	fwcmd = (struct mbx_get_common_fw_version *)&mbx.payload;
	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_COMMON,
				OPCODE_COMMON_GET_FW_VERSION,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_get_common_fw_version),
				OCE_MBX_VER_V0);

	mbx.u0.s.embedded = 1;
	mbx.payload_length = sizeof(struct mbx_get_common_fw_version);
	DW_SWAP(u32ptr(&mbx), mbx.payload_length + OCE_BMBX_RHDR_SZ);

	ret = oce_mbox_post(sc, &mbx, NULL);
	if (ret)
		return ret;
d612 1
a612 1
	bcopy(fwcmd->params.rsp.fw_ver_str, sc->fw_version, 32);
d614 5
a618 1
	return 0;
d633 1
d641 8
a648 6
	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_COMMON,
				OPCODE_COMMON_GET_FW_VERSION,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_get_common_fw_version),
				OCE_MBX_VER_V0);
d650 1
a650 1
	mbx->payload_length = sizeof(struct mbx_get_common_fw_version);
a660 61
 * @@brief		Function to post a MBX to the mbox
 * @@param sc		software handle to the device
 * @@param mbx 		pointer to the MBX to send
 * @@param mbxctx	pointer to the mbx context structure
 * @@returns		0 on success, error on failure
 */
int
oce_mbox_post(struct oce_softc *sc, struct oce_mbx *mbx, struct oce_mbx_ctx *mbxctx)
{
	struct oce_mbx *mb_mbx = NULL;
	struct oce_mq_cqe *mb_cqe = NULL;
	struct oce_bmbx *mb = NULL;
	int rc = 0;
	uint32_t tmo = 0;
	uint32_t cstatus = 0;
	uint32_t xstatus = 0;

	mb = OCE_DMAPTR(&sc->bsmbx, struct oce_bmbx);
	mb_mbx = &mb->mbx;

	/* get the tmo */
	tmo = mbx->tag[0];
	mbx->tag[0] = 0;

	/* copy mbx into mbox */
	bcopy(mbx, mb_mbx, sizeof(struct oce_mbx));

	/* now dispatch */
	rc = oce_mbox_dispatch(sc, tmo);
	if (rc == 0) {
		/*
		 * the command completed successfully. Now get the
		 * completion queue entry
		 */
		mb_cqe = &mb->cqe;
		DW_SWAP(u32ptr(&mb_cqe->u0.dw[0]), sizeof(struct oce_mq_cqe));

		/* copy mbox mbx back */
		bcopy(mb_mbx, mbx, sizeof(struct oce_mbx));

		/* pick up the mailbox status */
		cstatus = mb_cqe->u0.s.completion_status;
		xstatus = mb_cqe->u0.s.extended_status;

		/*
		 * store the mbx context in the cqe tag section so that
		 * the upper layer handling the cqe can associate the mbx
		 * with the response
		 */
		if (cstatus == 0 && mbxctx) {
			/* save context */
			mbxctx->mbx = mb_mbx;
			bcopy(&mbxctx, mb_cqe->u0.s.mq_tag,
				sizeof(struct oce_mbx_ctx *));
		}
	}

	return rc;
}

/**
d675 2
a676 3
	struct oce_mbx mbx;
	struct mbx_query_common_iface_mac *fwcmd;
	int ret = 0;
d678 1
a678 1
	bzero(&mbx, sizeof(struct oce_mbx));
d680 2
a681 9
	fwcmd = (struct mbx_query_common_iface_mac *)&mbx.payload;
	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_COMMON,
				OPCODE_COMMON_QUERY_IFACE_MAC,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_query_common_iface_mac),
				OCE_MBX_VER_V0);

	fwcmd->params.req.permanent = perm;
d683 1
a683 3
		fwcmd->params.req.if_id = (uint16_t) if_id;
	else
		fwcmd->params.req.if_id = 0;
d685 8
a692 16
	fwcmd->params.req.type = type;

	mbx.u0.s.embedded = 1;
	mbx.payload_length = sizeof(struct mbx_query_common_iface_mac);
	DW_SWAP(u32ptr(&mbx), mbx.payload_length + OCE_BMBX_RHDR_SZ);

	ret = oce_mbox_post(sc, &mbx, NULL);
	if (ret)
		return ret;

	/* copy the mac addres in the output parameter */
	mac->size_of_struct = fwcmd->params.rsp.mac.size_of_struct;
	bcopy(&fwcmd->params.rsp.mac.mac_addr[0], &mac->mac_addr[0],
		mac->size_of_struct);

	return 0;
d703 2
a704 3
	struct oce_mbx mbx;
	struct mbx_common_query_fw_config *fwcmd;
	int ret = 0;
d706 1
a706 1
	bzero(&mbx, sizeof(struct oce_mbx));
d708 15
a722 27
	fwcmd = (struct mbx_common_query_fw_config *)&mbx.payload;
	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_COMMON,
				OPCODE_COMMON_QUERY_FIRMWARE_CONFIG,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_common_query_fw_config),
				OCE_MBX_VER_V0);

	mbx.u0.s.embedded = 1;
	mbx.payload_length = sizeof(struct mbx_common_query_fw_config);
	DW_SWAP(u32ptr(&mbx), mbx.payload_length + OCE_BMBX_RHDR_SZ);

	ret = oce_mbox_post(sc, &mbx, NULL);
	if (ret)
		return ret;

	DW_SWAP(u32ptr(fwcmd), sizeof(struct mbx_common_query_fw_config));

	sc->config_number = fwcmd->params.rsp.config_number;
	sc->asic_revision = fwcmd->params.rsp.asic_revision;
	sc->port_id	  = fwcmd->params.rsp.port_id;
	sc->function_mode = fwcmd->params.rsp.function_mode;
	sc->function_caps = fwcmd->params.rsp.function_caps;

	if (fwcmd->params.rsp.ulp[0].ulp_mode & ULP_NIC_MODE) {
		sc->max_tx_rings = fwcmd->params.rsp.ulp[0].nic_wq_tot;
		sc->max_rx_rings = fwcmd->params.rsp.ulp[0].lro_rqid_tot;
d724 2
a725 2
		sc->max_tx_rings = fwcmd->params.rsp.ulp[1].nic_wq_tot;
		sc->max_rx_rings = fwcmd->params.rsp.ulp[1].lro_rqid_tot;
d728 1
a728 2
	return 0;

d747 2
a748 3
	struct oce_mbx mbx;
	struct mbx_create_common_iface *fwcmd;
	int rc = 0;
d750 1
a750 1
	bzero(&mbx, sizeof(struct oce_mbx));
d752 3
a754 12
	fwcmd = (struct mbx_create_common_iface *)&mbx.payload;
	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_COMMON,
				OPCODE_COMMON_CREATE_IFACE,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_create_common_iface),
				OCE_MBX_VER_V0);
	DW_SWAP(u32ptr(&fwcmd->hdr), sizeof(struct mbx_hdr));

	fwcmd->params.req.version = 0;
	fwcmd->params.req.cap_flags = htole32(cap_flags);
	fwcmd->params.req.enable_flags = htole32(en_flags);
d756 5
a760 7
		bcopy(mac_addr, &fwcmd->params.req.mac_addr[0], 6);
		fwcmd->params.req.vlan_tag.u0.normal.vtag = htole16(vlan_tag);
		fwcmd->params.req.mac_invalid = 0;
	} else {
		fwcmd->params.req.mac_invalid = 1;
		printf(": invalid mac");
	}
d762 4
a765 3
	mbx.u0.s.embedded = 1;
	mbx.payload_length = sizeof(struct mbx_create_common_iface);
	DW_SWAP(u32ptr(&mbx), OCE_BMBX_RHDR_SZ);
d767 1
a767 5
	rc = oce_mbox_post(sc, &mbx, NULL);
	if (rc)
		return rc;

	*if_id = letoh32(fwcmd->params.rsp.if_id);
d770 1
a770 1
		sc->pmac_id = letoh32(fwcmd->params.rsp.pmac_id);
d772 1
a772 1
	return 0;
d784 2
a785 3
	struct oce_mbx mbx;
	struct mbx_destroy_common_iface *fwcmd;
	int rc = 0;
d787 1
a787 1
	bzero(&mbx, sizeof(struct oce_mbx));
d789 1
a789 13
	fwcmd = (struct mbx_destroy_common_iface *)&mbx.payload;
	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_COMMON,
				OPCODE_COMMON_DESTROY_IFACE,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_destroy_common_iface),
				OCE_MBX_VER_V0);

	fwcmd->params.req.if_id = if_id;

	mbx.u0.s.embedded = 1;
	mbx.payload_length = sizeof(struct mbx_destroy_common_iface);
	DW_SWAP(u32ptr(&mbx), mbx.payload_length + OCE_BMBX_RHDR_SZ);
d791 3
a793 2
	rc = oce_mbox_post(sc, &mbx, NULL);
	return rc;
d811 2
a812 3
	struct oce_mbx mbx;
	struct mbx_common_config_vlan *fwcmd;
	int rc;
d814 1
a814 2
	bzero(&mbx, sizeof(struct oce_mbx));
	fwcmd = (struct mbx_common_config_vlan *)&mbx.payload;
d816 4
a819 11
	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_COMMON,
				OPCODE_COMMON_CONFIG_IFACE_VLAN,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_common_config_vlan),
				OCE_MBX_VER_V0);

	fwcmd->params.req.if_id = (uint8_t) if_id;
	fwcmd->params.req.promisc = (uint8_t) enable_promisc;
	fwcmd->params.req.untagged = (uint8_t) untagged;
	fwcmd->params.req.num_vlans = vtag_cnt;
d821 2
a822 2
	if (!enable_promisc) {
		bcopy(vtag_arr, fwcmd->params.req.tags.normal_vlans,
a823 6
	}
	mbx.u0.s.embedded = 1;
	mbx.payload_length = sizeof(struct mbx_common_config_vlan);
	DW_SWAP(u32ptr(&mbx), (OCE_BMBX_RHDR_SZ + mbx.payload_length));

	rc = oce_mbox_post(sc, &mbx, NULL);
d825 3
a827 1
	return rc;
d839 2
a840 6
	struct oce_mbx mbx;
	struct mbx_common_get_set_flow_control *fwcmd =
		(struct mbx_common_get_set_flow_control *)&mbx.payload;
	int rc;

	bzero(&mbx, sizeof(struct oce_mbx));
d842 1
a842 6
	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_COMMON,
				OPCODE_COMMON_SET_FLOW_CONTROL,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_common_get_set_flow_control),
				OCE_MBX_VER_V0);
d845 1
a845 1
		fwcmd->tx_flow_control = 1;
d848 1
a848 7
		fwcmd->rx_flow_control = 1;

	mbx.u0.s.embedded = 1;
	mbx.payload_length = sizeof(struct mbx_common_get_set_flow_control);
	DW_SWAP(u32ptr(&mbx), mbx.payload_length + OCE_BMBX_RHDR_SZ);

	rc = oce_mbox_post(sc, &mbx, NULL);
d850 3
a852 1
	return rc;
a876 1

d907 2
a908 20
	int rc;
	struct oce_mbx mbx;
	struct mbx_config_nic_rss *fwcmd =
				(struct mbx_config_nic_rss *)&mbx.payload;

	bzero(&mbx, sizeof(struct oce_mbx));

	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_NIC,
				OPCODE_NIC_CONFIG_RSS,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_config_nic_rss),
				OCE_MBX_VER_V0);
	if (enable_rss)
		fwcmd->params.req.enable_rss = (RSS_ENABLE_IPV4 |
						RSS_ENABLE_TCP_IPV4 |
						RSS_ENABLE_IPV6 |
						RSS_ENABLE_TCP_IPV6);
	fwcmd->params.req.flush = OCE_FLUSH;
	fwcmd->params.req.if_id = htole32(if_id);
d910 1
a910 1
	arc4random_buf(fwcmd->params.req.hash, sizeof(fwcmd->params.req.hash));
d912 16
a927 11
	rc = oce_rss_itbl_init(sc, fwcmd);
	if (rc == 0) {
		mbx.u0.s.embedded = 1;
		mbx.payload_length = sizeof(struct mbx_config_nic_rss);
		DW_SWAP(u32ptr(&mbx), mbx.payload_length + OCE_BMBX_RHDR_SZ);

		rc = oce_mbox_post(sc, &mbx, NULL);

	}

	return rc;
d941 1
a941 1
oce_rxf_set_promiscuous(struct oce_softc *sc, uint32_t enable)
d943 2
a944 4
	struct mbx_set_common_iface_rx_filter *fwcmd;
	int sz = sizeof(struct mbx_set_common_iface_rx_filter);
	iface_rx_filter_ctx_t *req;
	struct oce_dma_mem sgl;
d947 2
a948 8
	/* allocate mbx payload's dma scatter/gather memory */
	rc = oce_dma_alloc(sc, sz, &sgl, 0);
	if (rc)
		return rc;

	fwcmd = OCE_DMAPTR(&sgl, struct mbx_set_common_iface_rx_filter);

	req =  &fwcmd->params.req;
d951 2
a952 5
	if (enable) {
		req->iface_flags = MBX_RX_IFACE_FLAGS_PROMISCUOUS |
				   MBX_RX_IFACE_FLAGS_VLAN_PROMISCUOUS;
	}
	req->if_id = sc->if_id;
d954 2
a955 2
	rc = oce_set_common_iface_rx_filter(sc, &sgl);
	oce_dma_free(sc, &sgl);
a960 37
 * @@brief 			Function modify and select rx filter options
 * @@param sc			software handle to the device
 * @@param sgl			scatter/gather request/response
 * @@returns			0 on success, error code on failure
 */
int
oce_set_common_iface_rx_filter(struct oce_softc *sc, struct oce_dma_mem *sgl)
{
	struct oce_mbx mbx;
	int mbx_sz = sizeof(struct mbx_set_common_iface_rx_filter);
	struct mbx_set_common_iface_rx_filter *fwcmd;
	int rc;

	bzero(&mbx, sizeof(struct oce_mbx));
	fwcmd = OCE_DMAPTR(sgl, struct mbx_set_common_iface_rx_filter);

	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_COMMON,
				OPCODE_COMMON_SET_IFACE_RX_FILTER,
				MBX_TIMEOUT_SEC,
				mbx_sz,
				OCE_MBX_VER_V0);

	oce_dma_sync(sgl, BUS_DMASYNC_PREWRITE);
	mbx.u0.s.embedded = 0;
	mbx.u0.s.sge_count = 1;
	mbx.payload.u0.u1.sgl[0].pa_lo = ADDR_LO(sgl->paddr);
	mbx.payload.u0.u1.sgl[0].pa_hi = ADDR_HI(sgl->paddr);
	mbx.payload.u0.u1.sgl[0].length = mbx_sz;
	mbx.payload_length = mbx_sz;
	DW_SWAP(u32ptr(&mbx), mbx.payload_length + OCE_BMBX_RHDR_SZ);

	rc = oce_mbox_post(sc, &mbx, NULL);
	return rc;
}

/**
d969 1
d971 1
a971 3
	struct oce_mbx mbx;
	struct mbx_query_common_link_config *fwcmd;
	int rc = 0;
d973 1
a973 1
	bzero(&mbx, sizeof(struct oce_mbx));
d975 8
a982 24
	fwcmd = (struct mbx_query_common_link_config *)&mbx.payload;
	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_COMMON,
				OPCODE_COMMON_QUERY_LINK_CONFIG,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_query_common_link_config),
				OCE_MBX_VER_V0);

	mbx.u0.s.embedded = 1;
	mbx.payload_length = sizeof(struct mbx_query_common_link_config);
	DW_SWAP(u32ptr(&mbx), mbx.payload_length + OCE_BMBX_RHDR_SZ);

	rc = oce_mbox_post(sc, &mbx, NULL);

	if (rc) {
		printf("%s: Could not get link speed: %d\n",
		    sc->dev.dv_xname, rc);
		return rc;
	} else {
		/* interpret response */
		bcopy(&fwcmd->params.rsp, &link, sizeof(struct link_status));
		link.logical_link_status = letoh32(link.logical_link_status);
		link.qos_link_speed = letoh16(link.qos_link_speed);
	}
d998 1
a998 183
	return rc;
}

int
oce_mbox_get_nic_stats_v0(struct oce_softc *sc, struct oce_dma_mem *pstats_dma_mem)
{
	struct oce_mbx mbx;
	struct mbx_get_nic_stats_v0 *fwcmd;
	int rc = 0;

	bzero(&mbx, sizeof(struct oce_mbx));

	fwcmd = OCE_DMAPTR(pstats_dma_mem, struct mbx_get_nic_stats_v0);
	bzero(fwcmd, sizeof(struct mbx_get_nic_stats_v0));

	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_NIC,
				OPCODE_NIC_GET_STATS,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_get_nic_stats_v0),
				OCE_MBX_VER_V0);

	mbx.u0.s.embedded = 0;
	mbx.u0.s.sge_count = 1;

	oce_dma_sync(pstats_dma_mem, BUS_DMASYNC_PREWRITE);

	mbx.payload.u0.u1.sgl[0].pa_lo = ADDR_LO(pstats_dma_mem->paddr);
	mbx.payload.u0.u1.sgl[0].pa_hi = ADDR_HI(pstats_dma_mem->paddr);
	mbx.payload.u0.u1.sgl[0].length = sizeof(struct mbx_get_nic_stats_v0);

	mbx.payload_length = sizeof(struct mbx_get_nic_stats_v0);

	DW_SWAP(u32ptr(&mbx), mbx.payload_length + OCE_BMBX_RHDR_SZ);

	rc = oce_mbox_post(sc, &mbx, NULL);

	oce_dma_sync(pstats_dma_mem, BUS_DMASYNC_POSTWRITE);

	if (rc) {
		printf("%s: Could not get nic statistics: %d\n",
		    sc->dev.dv_xname, rc);
	}

	return rc;
}

/**
 * @@brief Function to get NIC statistics
 * @@param sc 		software handle to the device
 * @@param *stats	pointer to where to store statistics
 * @@param reset_stats	resets statistics of set
 * @@returns		0 on success, EIO on failure
 * @@note		command depricated in Lancer
 */
int
oce_mbox_get_nic_stats(struct oce_softc *sc, struct oce_dma_mem *pstats_dma_mem)
{
	struct oce_mbx mbx;
	struct mbx_get_nic_stats *fwcmd;
	int rc = 0;

	bzero(&mbx, sizeof(struct oce_mbx));
	fwcmd = OCE_DMAPTR(pstats_dma_mem, struct mbx_get_nic_stats);
	bzero(fwcmd, sizeof(struct mbx_get_nic_stats));

	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_NIC,
				OPCODE_NIC_GET_STATS,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_get_nic_stats),
				OCE_MBX_VER_V1);


	mbx.u0.s.embedded = 0;  /* stats too large for embedded mbx rsp */
	mbx.u0.s.sge_count = 1; /* using scatter gather instead */

	oce_dma_sync(pstats_dma_mem, BUS_DMASYNC_PREWRITE);
	mbx.payload.u0.u1.sgl[0].pa_lo = ADDR_LO(pstats_dma_mem->paddr);
	mbx.payload.u0.u1.sgl[0].pa_hi = ADDR_HI(pstats_dma_mem->paddr);
	mbx.payload.u0.u1.sgl[0].length = sizeof(struct mbx_get_nic_stats);

	mbx.payload_length = sizeof(struct mbx_get_nic_stats);
	DW_SWAP(u32ptr(&mbx), mbx.payload_length + OCE_BMBX_RHDR_SZ);

	rc = oce_mbox_post(sc, &mbx, NULL);
	oce_dma_sync(pstats_dma_mem, BUS_DMASYNC_POSTWRITE);
	if (rc) {
		printf("%s: Could not get nic statistics: %d\n",
		    sc->dev.dv_xname, rc);
	}
	return rc;
}

/**
 * @@brief Function to get pport (physical port) statistics
 * @@param sc 		software handle to the device
 * @@param *stats	pointer to where to store statistics
 * @@param reset_stats	resets statistics of set
 * @@returns		0 on success, EIO on failure
 */
int
oce_mbox_get_pport_stats(struct oce_softc *sc,
    struct oce_dma_mem *pstats_dma_mem, uint32_t reset_stats)
{
	struct oce_mbx mbx;
	struct mbx_get_pport_stats *fwcmd;
	int rc = 0;

	bzero(&mbx, sizeof(struct oce_mbx));
	fwcmd = OCE_DMAPTR(pstats_dma_mem, struct mbx_get_pport_stats);
	bzero(fwcmd, sizeof(struct mbx_get_pport_stats));

	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_NIC,
				OPCODE_NIC_GET_PPORT_STATS,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_get_pport_stats),
				OCE_MBX_VER_V0);

	fwcmd->params.req.reset_stats = reset_stats;
	fwcmd->params.req.port_number = sc->if_id;

	mbx.u0.s.embedded = 0;	/* stats too large for embedded mbx rsp */
	mbx.u0.s.sge_count = 1; /* using scatter gather instead */

	oce_dma_sync(pstats_dma_mem, BUS_DMASYNC_PREWRITE);
	mbx.payload.u0.u1.sgl[0].pa_lo = ADDR_LO(pstats_dma_mem->paddr);
	mbx.payload.u0.u1.sgl[0].pa_hi = ADDR_HI(pstats_dma_mem->paddr);
	mbx.payload.u0.u1.sgl[0].length = sizeof(struct mbx_get_pport_stats);

	mbx.payload_length = sizeof(struct mbx_get_pport_stats);
	DW_SWAP(u32ptr(&mbx), mbx.payload_length + OCE_BMBX_RHDR_SZ);

	rc = oce_mbox_post(sc, &mbx, NULL);
	oce_dma_sync(pstats_dma_mem, BUS_DMASYNC_POSTWRITE);

	if (rc != 0) {
		printf("%s: Could not get physical port statistics: %d\n",
		    sc->dev.dv_xname, rc);
	}

	return rc;
}

/**
 * @@brief               Function to update the muticast filter with
 *                      values in dma_mem
 * @@param sc            software handle to the device
 * @@param dma_mem       pointer to dma memory region
 * @@returns             0 on success, EIO on failure
 */
int
oce_update_multicast(struct oce_softc *sc, struct oce_dma_mem *pdma_mem)
{
	struct oce_mbx mbx;
	struct oce_mq_sge *sgl;
	struct mbx_set_common_iface_multicast *req = NULL;
	int rc = 0;

	req = OCE_DMAPTR(pdma_mem, struct mbx_set_common_iface_multicast);
	mbx_common_req_hdr_init(&req->hdr, 0, 0,
				MBX_SUBSYSTEM_COMMON,
				OPCODE_COMMON_SET_IFACE_MULTICAST,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_set_common_iface_multicast),
				OCE_MBX_VER_V0);

	bzero(&mbx, sizeof(struct oce_mbx));

	mbx.u0.s.embedded = 0; /*Non embeded*/
	mbx.payload_length = sizeof(struct mbx_set_common_iface_multicast);
	mbx.u0.s.sge_count = 1;
	sgl = &mbx.payload.u0.u1.sgl[0];
	sgl->pa_hi = htole32(upper_32_bits(pdma_mem->paddr));
	sgl->pa_lo = htole32((pdma_mem->paddr) & 0xFFFFFFFF);
	sgl->length = htole32(mbx.payload_length);

	DW_SWAP(u32ptr(&mbx), mbx.payload_length + OCE_BMBX_RHDR_SZ);

	rc = oce_mbox_post(sc, &mbx, NULL);

	return rc;
d1005 2
a1006 3
	struct oce_mbx mbx;
	struct mbx_add_common_iface_mac *fwcmd;
	int rc = 0;
d1008 1
a1008 1
	bzero(&mbx, sizeof(struct oce_mbx));
d1010 2
a1011 19
	fwcmd = (struct mbx_add_common_iface_mac *)&mbx.payload;
	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_COMMON,
				OPCODE_COMMON_ADD_IFACE_MAC,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_add_common_iface_mac),
				OCE_MBX_VER_V0);

	fwcmd->params.req.if_id = (uint16_t) if_id;
	bcopy(mac_addr, fwcmd->params.req.mac_address, 6);

	mbx.u0.s.embedded = 1;
	mbx.payload_length = sizeof(struct  mbx_add_common_iface_mac);
	DW_SWAP(u32ptr(&mbx), mbx.payload_length + OCE_BMBX_RHDR_SZ);
	rc = oce_mbox_post(sc, &mbx, NULL);
	if (rc)
		return rc;

	*pmac_id = fwcmd->params.rsp.pmac_id;
d1013 5
a1017 1
	return rc;
d1023 2
a1024 3
	struct oce_mbx mbx;
	struct mbx_del_common_iface_mac *fwcmd;
	int rc = 0;
d1026 1
a1026 1
	bzero(&mbx, sizeof(struct oce_mbx));
d1028 2
a1029 14
	fwcmd = (struct mbx_del_common_iface_mac *)&mbx.payload;
	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_COMMON,
				OPCODE_COMMON_DEL_IFACE_MAC,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_del_common_iface_mac),
				OCE_MBX_VER_V0);

	fwcmd->params.req.if_id = (uint16_t)if_id;
	fwcmd->params.req.pmac_id = pmac_id;

	mbx.u0.s.embedded = 1;
	mbx.payload_length = sizeof(struct  mbx_del_common_iface_mac);
	DW_SWAP(u32ptr(&mbx), mbx.payload_length + OCE_BMBX_RHDR_SZ);
d1031 3
a1033 2
	rc = oce_mbox_post(sc, &mbx, NULL);
	return rc;
d1039 4
a1042 3
	struct oce_mbx mbx;
	struct mbx_common_set_function_cap *fwcmd;
	int rc = 0;
d1044 3
a1046 1
	bzero(&mbx, sizeof(struct oce_mbx));
d1048 5
a1052 22
	fwcmd = (struct mbx_common_set_function_cap *)&mbx.payload;
	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_COMMON,
				OPCODE_COMMON_SET_FUNCTIONAL_CAPS,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_common_set_function_cap),
				OCE_MBX_VER_V0);

	fwcmd->params.req.valid_capability_flags = CAP_SW_TIMESTAMPS |
							CAP_BE3_NATIVE_ERX_API;

	fwcmd->params.req.capability_flags = CAP_BE3_NATIVE_ERX_API;

	mbx.u0.s.embedded = 1;
	mbx.payload_length = sizeof(struct mbx_common_set_function_cap);
	DW_SWAP(u32ptr(&mbx), mbx.payload_length + OCE_BMBX_RHDR_SZ);

	rc = oce_mbox_post(sc, &mbx, NULL);
	if (rc != 0)
		printf(" mbox failure!");
	//if (rc != 0)		This can fail in legacy mode. So skip
	//	FN_LEAVE(rc);
d1054 2
a1055 2
	sc->be3_native = fwcmd->params.rsp.capability_flags
			& CAP_BE3_NATIVE_ERX_API;
d1057 1
a1057 1
	return 0;
d1063 1
a1063 2
	struct oce_mbx mbx;
	struct mbx_create_nic_rq *fwcmd;
d1065 1
a1065 1
	int num_pages, version, rc = 0;
d1070 1
a1070 7
	bzero(&mbx, sizeof(struct oce_mbx));

	fwcmd = (struct mbx_create_nic_rq *)&mbx.payload;
	if (IS_XE201(sc))
		version = OCE_MBX_VER_V1;
	else
		version = OCE_MBX_VER_V0;
d1072 3
a1074 9
	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_NIC,
				OPCODE_NIC_CREATE_RQ, MBX_TIMEOUT_SEC,
				sizeof(struct mbx_create_nic_rq),
				version);

	num_pages = oce_page_list(sc, rq->ring, &fwcmd->params.req.pages[0],
	    nitems(fwcmd->params.req.pages));
	if (!num_pages) {
d1076 1
a1076 1
		goto out;
d1079 3
a1081 3
	if (version == OCE_MBX_VER_V1) {
		fwcmd->params.req.frag_size = rq->cfg.frag_size / 2048;
		fwcmd->params.req.page_size = 1;
d1083 12
a1094 13
		fwcmd->params.req.frag_size = ilog2(rq->cfg.frag_size);
	fwcmd->params.req.num_pages = num_pages;
	fwcmd->params.req.cq_id = rq->cq->cq_id;
	fwcmd->params.req.if_id = htole32(sc->if_id);
	fwcmd->params.req.max_frame_size = htole16(rq->cfg.mtu);
	fwcmd->params.req.is_rss_queue = htole32(rq->cfg.is_rss_queue);

	mbx.u0.s.embedded = 1;
	mbx.payload_length = sizeof(struct mbx_create_nic_rq);

	rc = oce_mbox_post(sc, &mbx, NULL);
	if (rc)
		goto out;
d1096 2
a1097 2
	rq->rq_id = letoh16(fwcmd->params.rsp.rq_id);
	rq->rss_cpuid = fwcmd->params.rsp.rss_cpuid;
d1099 1
a1099 2
out:
	return rc;
d1105 1
a1105 2
	struct oce_mbx mbx;
	struct mbx_create_nic_wq *fwcmd;
d1107 1
a1107 1
	int num_pages, version, rc = 0;
d1109 1
a1109 1
	bzero(&mbx, sizeof(struct oce_mbx));
d1111 3
a1113 16
	fwcmd = (struct mbx_create_nic_wq *)&mbx.payload;
	if (IS_XE201(sc)) {
		version = OCE_MBX_VER_V1;
		fwcmd->params.req.if_id = sc->if_id;
	} else
		version = OCE_MBX_VER_V0;

	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_NIC,
				OPCODE_NIC_CREATE_WQ, MBX_TIMEOUT_SEC,
				sizeof(struct mbx_create_nic_wq),
				version);

	num_pages = oce_page_list(sc, wq->ring, &fwcmd->params.req.pages[0],
	    nitems(fwcmd->params.req.pages));
	if (!num_pages) {
d1115 1
a1115 1
		goto out;
d1118 13
a1130 5
	fwcmd->params.req.nic_wq_type = wq->cfg.wq_type;
	fwcmd->params.req.num_pages = num_pages;
	fwcmd->params.req.wq_size = ilog2(wq->cfg.q_len) + 1;
	fwcmd->params.req.cq_id = htole16(wq->cq->cq_id);
	fwcmd->params.req.ulp_num = 1;
d1132 1
a1132 2
	mbx.u0.s.embedded = 1;
	mbx.payload_length = sizeof(struct mbx_create_nic_wq);
d1134 1
a1134 8
	rc = oce_mbox_post(sc, &mbx, NULL);
	if (rc)
		goto out;

	wq->wq_id = letoh16(fwcmd->params.rsp.wq_id);

out:
	return 0;
d1140 1
a1140 2
	struct oce_mbx mbx;
	struct mbx_create_common_mq_ex *fwcmd = NULL;
d1142 2
a1143 2
	oce_mq_ext_ctx_t *ctx;
	int num_pages, version, rc = 0;
d1145 1
a1145 1
	bzero(&mbx, sizeof(struct oce_mbx));
d1147 3
a1149 12
	fwcmd = (struct mbx_create_common_mq_ex *)&mbx.payload;
	version = OCE_MBX_VER_V0;
	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_COMMON,
				OPCODE_COMMON_CREATE_MQ_EXT,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_create_common_mq_ex),
				version);

	num_pages = oce_page_list(sc, mq->ring, &fwcmd->params.req.pages[0],
	    nitems(fwcmd->params.req.pages));
	if (!num_pages) {
d1151 1
a1151 1
		goto out;
d1154 2
a1155 2
	ctx = &fwcmd->params.req.context;
	ctx->v0.num_pages = num_pages;
d1162 4
a1165 7
	mbx.u0.s.embedded = 1;
	mbx.payload_length = sizeof(struct mbx_create_common_mq_ex);
	DW_SWAP(u32ptr(&mbx), mbx.payload_length + OCE_BMBX_RHDR_SZ);

	rc = oce_mbox_post(sc, &mbx, NULL);
	if (rc)
		goto out;
d1167 1
a1167 1
	mq->mq_id = letoh16(fwcmd->params.rsp.mq_id);
d1169 1
a1169 2
out:
	return rc;
d1175 1
a1175 2
	struct oce_mbx mbx;
	struct mbx_create_common_eq *fwcmd;
d1177 1
a1177 4
	int rc = 0;
	uint32_t num_pages;

	bzero(&mbx, sizeof(struct oce_mbx));
d1179 1
a1179 1
	fwcmd = (struct mbx_create_common_eq *)&mbx.payload;
d1181 3
a1183 9
	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_COMMON,
				OPCODE_COMMON_CREATE_EQ, MBX_TIMEOUT_SEC,
				sizeof(struct mbx_create_common_eq),
				OCE_MBX_VER_V0);

	num_pages = oce_page_list(sc, eq->ring, &fwcmd->params.req.pages[0],
	    nitems(fwcmd->params.req.pages));
	if (!num_pages) {
d1185 1
a1185 1
		goto out;
d1188 6
a1193 6
	fwcmd->params.req.ctx.num_pages = htole16(num_pages);
	fwcmd->params.req.ctx.valid = 1;
	fwcmd->params.req.ctx.size = (eq->eq_cfg.item_size == 4) ? 0 : 1;
	fwcmd->params.req.ctx.count = ilog2(eq->eq_cfg.q_len / 256);
	fwcmd->params.req.ctx.armed = 0;
	fwcmd->params.req.ctx.delay_mult = htole32(eq->eq_cfg.cur_eqd);
d1195 4
a1198 2
	mbx.u0.s.embedded = 1;
	mbx.payload_length = sizeof(struct mbx_create_common_eq);
d1200 1
a1200 3
	rc = oce_mbox_post(sc, &mbx, NULL);
	if (rc)
		goto out;
d1202 1
a1202 4
	eq->eq_id = letoh16(fwcmd->params.rsp.eq_id);

out:
	return rc;
d1209 1
a1209 2
	struct oce_mbx mbx;
	struct mbx_create_common_cq *fwcmd;
d1211 2
a1212 7
	uint8_t version;
	oce_cq_ctx_t *ctx;
	uint32_t num_pages, page_size;
	int rc = 0;


	bzero(&mbx, sizeof(struct oce_mbx));
d1214 1
a1214 1
	fwcmd = (struct mbx_create_common_cq *)&mbx.payload;
d1216 3
a1218 15
	if (IS_XE201(sc))
		version = OCE_MBX_VER_V2;
	else
		version = OCE_MBX_VER_V0;

	mbx_common_req_hdr_init(&fwcmd->hdr, 0, 0,
				MBX_SUBSYSTEM_COMMON,
				OPCODE_COMMON_CREATE_CQ,
				MBX_TIMEOUT_SEC,
				sizeof(struct mbx_create_common_cq),
				version);

	num_pages = oce_page_list(sc, cq->ring, &fwcmd->params.req.pages[0],
	    nitems(fwcmd->params.req.pages));
	if (!num_pages) {
d1220 1
a1220 1
		goto out;
d1223 1
a1223 1
	page_size = 1;  /* 1 for 4K */
d1225 3
a1227 5
	ctx = &fwcmd->params.req.cq_ctx;

	if (version == OCE_MBX_VER_V2) {
		ctx->v2.num_pages = htole16(num_pages);
		ctx->v2.page_size = page_size;
d1242 1
a1242 1
		ctx->v0.num_pages = htole16(num_pages);
d1252 82
a1333 2
	mbx.u0.s.embedded = 1;
	mbx.payload_length = sizeof(struct mbx_create_common_cq);
d1335 21
a1355 3
	rc = oce_mbox_post(sc, &mbx, NULL);
	if (rc)
		goto out;
d1357 2
a1358 1
	cq->cq_id = letoh16(fwcmd->params.rsp.cq_id);
d1360 3
a1362 2
out:
	return rc;
d1371 2
a1372 1
	mbx = OCE_DMAPTR(&sc->stats_mem, struct mbx_get_pport_stats);
d1396 1
a1396 1
	mbx = OCE_DMAPTR(&sc->stats_mem, struct mbx_get_nic_stats_v0);
d1426 1
a1426 1
	mbx = OCE_DMAPTR(&sc->stats_mem, struct mbx_get_nic_stats);
d1445 1
a1445 25
oce_stats_init(struct oce_softc *sc)
{
	int rc = 0, sz;

	if (IS_BE(sc)) {
		if (sc->flags & OCE_FLAGS_BE2)
			sz = sizeof(struct mbx_get_nic_stats_v0);
		else
			sz = sizeof(struct mbx_get_nic_stats);
	} else
		sz = sizeof(struct mbx_get_pport_stats);

	rc = oce_dma_alloc(sc, sz, &sc->stats_mem, 0);

	return rc;
}

void
oce_stats_free(struct oce_softc *sc)
{
	oce_dma_free(sc, &sc->stats_mem);
}

int
oce_stats_get(struct oce_softc *sc, u_int64_t *rxe, u_int64_t *txe)
d1451 1
a1451 1
			rc = oce_mbox_get_nic_stats_v0(sc, &sc->stats_mem);
d1455 1
a1455 1
			rc = oce_mbox_get_nic_stats(sc, &sc->stats_mem);
d1461 1
a1461 1
		rc = oce_mbox_get_pport_stats(sc, &sc->stats_mem, 0);
@


1.7
log
@better integer log2 implementation, checked with what linux is doing
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.6 2012/08/10 16:24:56 mikeb Exp $	*/
a83 1
int oce_fw_clean(struct oce_softc *sc);
a468 31
}

/**
 * @@brief  		This funtions tells firmware we are
 *			done with commands.
 * @@param sc            software handle to the device
 * @@returns             0 on success, ETIMEDOUT on failure
 */
int
oce_fw_clean(struct oce_softc *sc)
{
	struct oce_bmbx *mbx;
	uint8_t *ptr;
	int ret = 0;

	mbx = OCE_DMAPTR(&sc->bsmbx, struct oce_bmbx);
	ptr = (uint8_t *)&mbx->mbx;

	/* Endian Signature */
	*ptr++ = 0xff;
	*ptr++ = 0xaa;
	*ptr++ = 0xbb;
	*ptr++ = 0xff;
	*ptr++ = 0xff;
	*ptr++ = 0xcc;
	*ptr++ = 0xdd;
	*ptr = 0xff;

	ret = oce_mbox_dispatch(sc, 2);

	return ret;
@


1.6
log
@cleanup some #define's and #ifdef's
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.5 2012/08/09 19:29:03 mikeb Exp $	*/
d1082 1
a1082 1
		fwcmd->params.req.cpu_tbl_sz_log2 = htole16(OCE_LOG2(i));
d1586 1
a1586 1
		fwcmd->params.req.frag_size = OCE_LOG2(rq->cfg.frag_size);
d1639 1
a1639 1
	fwcmd->params.req.wq_size = OCE_LOG2(wq->cfg.q_len) + 1;
d1686 1
a1686 1
	ctx->v0.ring_size = OCE_LOG2(mq->cfg.q_len) + 1;
d1734 1
a1734 1
	fwcmd->params.req.ctx.count = OCE_LOG2(eq->eq_cfg.q_len / 256);
d1796 1
a1796 1
		ctx->v2.count = OCE_LOG2(cq->cq_cfg.q_len / 256);
d1811 1
a1811 1
		ctx->v0.count = OCE_LOG2(cq->cq_cfg.q_len / 256);
@


1.5
log
@don't compile rss functions in unless OCE_RSS is specified
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.4 2012/08/09 19:19:49 mikeb Exp $	*/
d224 1
a224 1
		reg = OCE_DEV_BE2_CFG_BAR;
d226 1
a226 1
		reg = OCE_DEV_CFG_BAR;
d264 1
a264 1
		reg = OCE_PCI_CSR_BAR;
d273 1
a273 1
		reg = OCE_PCI_DB_BAR;
@


1.4
log
@try to make sense of the firmware statistics by counting rx and tx erorrs
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.3 2012/08/09 19:12:45 mikeb Exp $	*/
d1044 1
d1132 1
@


1.3
log
@more htole conversions
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.2 2012/08/09 19:03:14 mikeb Exp $	*/
a109 3
void copy_stats_to_sc_xe201(struct oce_softc *sc);
void copy_stats_to_sc_be3(struct oce_softc *sc);
void copy_stats_to_sc_be2(struct oce_softc *sc);
d1829 2
a1830 2
void
copy_stats_to_sc_xe201(struct oce_softc *sc)
d1832 2
a1833 135
	struct oce_xe201_stats *adapter_stats;
	struct mbx_get_pport_stats *nic_mbx;
	struct pport_stats *port_stats;

	nic_mbx = OCE_DMAPTR(&sc->stats_mem, struct mbx_get_pport_stats);
	port_stats = &nic_mbx->params.rsp.pps;
	adapter_stats = &sc->oce_stats_info.u0.xe201;

	adapter_stats->tx_pkts = port_stats->tx_pkts;
	adapter_stats->tx_unicast_pkts = port_stats->tx_unicast_pkts;
	adapter_stats->tx_multicast_pkts = port_stats->tx_multicast_pkts;
	adapter_stats->tx_broadcast_pkts = port_stats->tx_broadcast_pkts;
	adapter_stats->tx_bytes = port_stats->tx_bytes;
	adapter_stats->tx_unicast_bytes = port_stats->tx_unicast_bytes;
	adapter_stats->tx_multicast_bytes = port_stats->tx_multicast_bytes;
	adapter_stats->tx_broadcast_bytes = port_stats->tx_broadcast_bytes;
	adapter_stats->tx_discards = port_stats->tx_discards;
	adapter_stats->tx_errors = port_stats->tx_errors;
	adapter_stats->tx_pause_frames = port_stats->tx_pause_frames;
	adapter_stats->tx_pause_on_frames = port_stats->tx_pause_on_frames;
	adapter_stats->tx_pause_off_frames = port_stats->tx_pause_off_frames;
	adapter_stats->tx_internal_mac_errors =
		port_stats->tx_internal_mac_errors;
	adapter_stats->tx_control_frames = port_stats->tx_control_frames;
	adapter_stats->tx_pkts_64_bytes = port_stats->tx_pkts_64_bytes;
	adapter_stats->tx_pkts_65_to_127_bytes =
		port_stats->tx_pkts_65_to_127_bytes;
	adapter_stats->tx_pkts_128_to_255_bytes =
		port_stats->tx_pkts_128_to_255_bytes;
	adapter_stats->tx_pkts_256_to_511_bytes =
		port_stats->tx_pkts_256_to_511_bytes;
	adapter_stats->tx_pkts_512_to_1023_bytes =
		port_stats->tx_pkts_512_to_1023_bytes;
	adapter_stats->tx_pkts_1024_to_1518_bytes =
		port_stats->tx_pkts_1024_to_1518_bytes;
	adapter_stats->tx_pkts_1519_to_2047_bytes =
		port_stats->tx_pkts_1519_to_2047_bytes;
	adapter_stats->tx_pkts_2048_to_4095_bytes =
		port_stats->tx_pkts_2048_to_4095_bytes;
	adapter_stats->tx_pkts_4096_to_8191_bytes =
		port_stats->tx_pkts_4096_to_8191_bytes;
	adapter_stats->tx_pkts_8192_to_9216_bytes =
		port_stats->tx_pkts_8192_to_9216_bytes;
	adapter_stats->tx_lso_pkts = port_stats->tx_lso_pkts;
	adapter_stats->rx_pkts = port_stats->rx_pkts;
	adapter_stats->rx_unicast_pkts = port_stats->rx_unicast_pkts;
	adapter_stats->rx_multicast_pkts = port_stats->rx_multicast_pkts;
	adapter_stats->rx_broadcast_pkts = port_stats->rx_broadcast_pkts;
	adapter_stats->rx_bytes = port_stats->rx_bytes;
	adapter_stats->rx_unicast_bytes = port_stats->rx_unicast_bytes;
	adapter_stats->rx_multicast_bytes = port_stats->rx_multicast_bytes;
	adapter_stats->rx_broadcast_bytes = port_stats->rx_broadcast_bytes;
	adapter_stats->rx_unknown_protos = port_stats->rx_unknown_protos;
	adapter_stats->rx_discards = port_stats->rx_discards;
	adapter_stats->rx_errors = port_stats->rx_errors;
	adapter_stats->rx_crc_errors = port_stats->rx_crc_errors;
	adapter_stats->rx_alignment_errors = port_stats->rx_alignment_errors;
	adapter_stats->rx_symbol_errors = port_stats->rx_symbol_errors;
	adapter_stats->rx_pause_frames = port_stats->rx_pause_frames;
	adapter_stats->rx_pause_on_frames = port_stats->rx_pause_on_frames;
	adapter_stats->rx_pause_off_frames = port_stats->rx_pause_off_frames;
	adapter_stats->rx_frames_too_long = port_stats->rx_frames_too_long;
	adapter_stats->rx_internal_mac_errors =
		port_stats->rx_internal_mac_errors;
	adapter_stats->rx_undersize_pkts = port_stats->rx_undersize_pkts;
	adapter_stats->rx_oversize_pkts = port_stats->rx_oversize_pkts;
	adapter_stats->rx_fragment_pkts = port_stats->rx_fragment_pkts;
	adapter_stats->rx_jabbers = port_stats->rx_jabbers;
	adapter_stats->rx_control_frames = port_stats->rx_control_frames;
	adapter_stats->rx_control_frames_unknown_opcode =
		port_stats->rx_control_frames_unknown_opcode;
	adapter_stats->rx_in_range_errors = port_stats->rx_in_range_errors;
	adapter_stats->rx_out_of_range_errors =
		port_stats->rx_out_of_range_errors;
	adapter_stats->rx_address_match_errors =
		port_stats->rx_address_match_errors;
	adapter_stats->rx_vlan_mismatch_errors =
		port_stats->rx_vlan_mismatch_errors;
	adapter_stats->rx_dropped_too_small = port_stats->rx_dropped_too_small;
	adapter_stats->rx_dropped_too_short = port_stats->rx_dropped_too_short;
	adapter_stats->rx_dropped_header_too_small =
		port_stats->rx_dropped_header_too_small;
	adapter_stats->rx_dropped_invalid_tcp_length =
		port_stats->rx_dropped_invalid_tcp_length;
	adapter_stats->rx_dropped_runt = port_stats->rx_dropped_runt;
	adapter_stats->rx_ip_checksum_errors =
		port_stats->rx_ip_checksum_errors;
	adapter_stats->rx_tcp_checksum_errors =
		port_stats->rx_tcp_checksum_errors;
	adapter_stats->rx_udp_checksum_errors =
		port_stats->rx_udp_checksum_errors;
	adapter_stats->rx_non_rss_pkts = port_stats->rx_non_rss_pkts;
	adapter_stats->rx_ipv4_pkts = port_stats->rx_ipv4_pkts;
	adapter_stats->rx_ipv6_pkts = port_stats->rx_ipv6_pkts;
	adapter_stats->rx_ipv4_bytes = port_stats->rx_ipv4_bytes;
	adapter_stats->rx_ipv6_bytes = port_stats->rx_ipv6_bytes;
	adapter_stats->rx_nic_pkts = port_stats->rx_nic_pkts;
	adapter_stats->rx_tcp_pkts = port_stats->rx_tcp_pkts;
	adapter_stats->rx_iscsi_pkts = port_stats->rx_iscsi_pkts;
	adapter_stats->rx_management_pkts = port_stats->rx_management_pkts;
	adapter_stats->rx_switched_unicast_pkts =
		port_stats->rx_switched_unicast_pkts;
	adapter_stats->rx_switched_multicast_pkts =
		port_stats->rx_switched_multicast_pkts;
	adapter_stats->rx_switched_broadcast_pkts =
		port_stats->rx_switched_broadcast_pkts;
	adapter_stats->num_forwards = port_stats->num_forwards;
	adapter_stats->rx_fifo_overflow = port_stats->rx_fifo_overflow;
	adapter_stats->rx_input_fifo_overflow =
		port_stats->rx_input_fifo_overflow;
	adapter_stats->rx_drops_too_many_frags =
		port_stats->rx_drops_too_many_frags;
	adapter_stats->rx_drops_invalid_queue =
		port_stats->rx_drops_invalid_queue;
	adapter_stats->rx_drops_mtu = port_stats->rx_drops_mtu;
	adapter_stats->rx_pkts_64_bytes = port_stats->rx_pkts_64_bytes;
	adapter_stats->rx_pkts_65_to_127_bytes =
		port_stats->rx_pkts_65_to_127_bytes;
	adapter_stats->rx_pkts_128_to_255_bytes =
		port_stats->rx_pkts_128_to_255_bytes;
	adapter_stats->rx_pkts_256_to_511_bytes =
		port_stats->rx_pkts_256_to_511_bytes;
	adapter_stats->rx_pkts_512_to_1023_bytes =
		port_stats->rx_pkts_512_to_1023_bytes;
	adapter_stats->rx_pkts_1024_to_1518_bytes =
		port_stats->rx_pkts_1024_to_1518_bytes;
	adapter_stats->rx_pkts_1519_to_2047_bytes =
		port_stats->rx_pkts_1519_to_2047_bytes;
	adapter_stats->rx_pkts_2048_to_4095_bytes =
		port_stats->rx_pkts_2048_to_4095_bytes;
	adapter_stats->rx_pkts_4096_to_8191_bytes =
		port_stats->rx_pkts_4096_to_8191_bytes;
	adapter_stats->rx_pkts_8192_to_9216_bytes =
		port_stats->rx_pkts_8192_to_9216_bytes;
}
d1835 2
a1836 44
void
copy_stats_to_sc_be2(struct oce_softc *sc)
{
	struct oce_be_stats *adapter_stats;
	struct oce_pmem_stats *pmem;
	struct oce_rxf_stats_v0 *rxf_stats;
	struct oce_port_rxf_stats_v0 *port_stats;
	struct mbx_get_nic_stats_v0 *nic_mbx;
	uint32_t port = sc->port_id;

	nic_mbx = OCE_DMAPTR(&sc->stats_mem, struct mbx_get_nic_stats_v0);
	pmem = &nic_mbx->params.rsp.stats.pmem;
	rxf_stats = &nic_mbx->params.rsp.stats.rxf;
	port_stats = &nic_mbx->params.rsp.stats.rxf.port[port];

	adapter_stats = &sc->oce_stats_info.u0.be;

	/* Update stats */
	adapter_stats->rx_pause_frames = port_stats->rx_pause_frames;
	adapter_stats->rx_crc_errors = port_stats->rx_crc_errors;
	adapter_stats->rx_control_frames = port_stats->rx_control_frames;
	adapter_stats->rx_in_range_errors = port_stats->rx_in_range_errors;
	adapter_stats->rx_frame_too_long = port_stats->rx_frame_too_long;
	adapter_stats->rx_dropped_runt = port_stats->rx_dropped_runt;
	adapter_stats->rx_ip_checksum_errs = port_stats->rx_ip_checksum_errs;
	adapter_stats->rx_tcp_checksum_errs = port_stats->rx_tcp_checksum_errs;
	adapter_stats->rx_udp_checksum_errs = port_stats->rx_udp_checksum_errs;
	adapter_stats->rxpp_fifo_overflow_drop =
					port_stats->rxpp_fifo_overflow_drop;
	adapter_stats->rx_dropped_tcp_length =
		port_stats->rx_dropped_tcp_length;
	adapter_stats->rx_dropped_too_small = port_stats->rx_dropped_too_small;
	adapter_stats->rx_dropped_too_short = port_stats->rx_dropped_too_short;
	adapter_stats->rx_out_range_errors = port_stats->rx_out_range_errors;
	adapter_stats->rx_dropped_header_too_small =
		port_stats->rx_dropped_header_too_small;
	adapter_stats->rx_input_fifo_overflow_drop =
		port_stats->rx_input_fifo_overflow_drop;
	adapter_stats->rx_address_match_errors =
		port_stats->rx_address_match_errors;
	adapter_stats->rx_alignment_symbol_errors =
		port_stats->rx_alignment_symbol_errors;
	adapter_stats->tx_pauseframes = port_stats->tx_pauseframes;
	adapter_stats->tx_controlframes = port_stats->tx_controlframes;
d1838 34
d1873 1
a1873 1
		adapter_stats->jabber_events = rxf_stats->port1_jabber_events;
d1875 2
a1876 1
		adapter_stats->jabber_events = rxf_stats->port0_jabber_events;
d1878 1
a1878 11
	adapter_stats->rx_drops_no_pbuf = rxf_stats->rx_drops_no_pbuf;
	adapter_stats->rx_drops_no_txpb = rxf_stats->rx_drops_no_txpb;
	adapter_stats->rx_drops_no_erx_descr = rxf_stats->rx_drops_no_erx_descr;
	adapter_stats->rx_drops_invalid_ring = rxf_stats->rx_drops_invalid_ring;
	adapter_stats->forwarded_packets = rxf_stats->forwarded_packets;
	adapter_stats->rx_drops_mtu = rxf_stats->rx_drops_mtu;
	adapter_stats->rx_drops_no_tpre_descr =
		rxf_stats->rx_drops_no_tpre_descr;
	adapter_stats->rx_drops_too_many_frags =
		rxf_stats->rx_drops_too_many_frags;
	adapter_stats->eth_red_drops = pmem->eth_red_drops;
d1881 2
a1882 2
void
copy_stats_to_sc_be3(struct oce_softc *sc)
d1884 19
a1902 57
	struct oce_be_stats *adapter_stats;
	struct oce_pmem_stats *pmem;
	struct oce_rxf_stats_v1 *rxf_stats;
	struct oce_port_rxf_stats_v1 *port_stats;
	struct mbx_get_nic_stats *nic_mbx;
	uint32_t port = sc->port_id;

	nic_mbx = OCE_DMAPTR(&sc->stats_mem, struct mbx_get_nic_stats);
	pmem = &nic_mbx->params.rsp.stats.pmem;
	rxf_stats = &nic_mbx->params.rsp.stats.rxf;
	port_stats = &nic_mbx->params.rsp.stats.rxf.port[port];

	adapter_stats = &sc->oce_stats_info.u0.be;

	/* Update stats */
	adapter_stats->pmem_fifo_overflow_drop =
		port_stats->pmem_fifo_overflow_drop;
	adapter_stats->rx_priority_pause_frames =
		port_stats->rx_priority_pause_frames;
	adapter_stats->rx_pause_frames = port_stats->rx_pause_frames;
	adapter_stats->rx_crc_errors = port_stats->rx_crc_errors;
	adapter_stats->rx_control_frames = port_stats->rx_control_frames;
	adapter_stats->rx_in_range_errors = port_stats->rx_in_range_errors;
	adapter_stats->rx_frame_too_long = port_stats->rx_frame_too_long;
	adapter_stats->rx_dropped_runt = port_stats->rx_dropped_runt;
	adapter_stats->rx_ip_checksum_errs = port_stats->rx_ip_checksum_errs;
	adapter_stats->rx_tcp_checksum_errs = port_stats->rx_tcp_checksum_errs;
	adapter_stats->rx_udp_checksum_errs = port_stats->rx_udp_checksum_errs;
	adapter_stats->rx_dropped_tcp_length =
		port_stats->rx_dropped_tcp_length;
	adapter_stats->rx_dropped_too_small = port_stats->rx_dropped_too_small;
	adapter_stats->rx_dropped_too_short = port_stats->rx_dropped_too_short;
	adapter_stats->rx_out_range_errors = port_stats->rx_out_range_errors;
	adapter_stats->rx_dropped_header_too_small =
		port_stats->rx_dropped_header_too_small;
	adapter_stats->rx_input_fifo_overflow_drop =
		port_stats->rx_input_fifo_overflow_drop;
	adapter_stats->rx_address_match_errors =
		port_stats->rx_address_match_errors;
	adapter_stats->rx_alignment_symbol_errors =
		port_stats->rx_alignment_symbol_errors;
	adapter_stats->rxpp_fifo_overflow_drop =
		port_stats->rxpp_fifo_overflow_drop;
	adapter_stats->tx_pauseframes = port_stats->tx_pauseframes;
	adapter_stats->tx_controlframes = port_stats->tx_controlframes;
	adapter_stats->jabber_events = port_stats->jabber_events;

	adapter_stats->rx_drops_no_pbuf = rxf_stats->rx_drops_no_pbuf;
	adapter_stats->rx_drops_no_txpb = rxf_stats->rx_drops_no_txpb;
	adapter_stats->rx_drops_no_erx_descr = rxf_stats->rx_drops_no_erx_descr;
	adapter_stats->rx_drops_invalid_ring = rxf_stats->rx_drops_invalid_ring;
	adapter_stats->forwarded_packets = rxf_stats->forwarded_packets;
	adapter_stats->rx_drops_mtu = rxf_stats->rx_drops_mtu;
	adapter_stats->rx_drops_no_tpre_descr =
		rxf_stats->rx_drops_no_tpre_descr;
	adapter_stats->rx_drops_too_many_frags =
		rxf_stats->rx_drops_too_many_frags;
d1904 1
a1904 1
	adapter_stats->eth_red_drops = pmem->eth_red_drops;
d1932 1
a1932 1
oce_refresh_nic_stats(struct oce_softc *sc)
d1934 1
a1934 1
	int rc = 0, reset = 0;
d1940 1
a1940 1
				copy_stats_to_sc_be2(sc);
d1944 1
a1944 1
				copy_stats_to_sc_be3(sc);
d1948 1
a1948 1
		rc = oce_mbox_get_pport_stats(sc, &sc->stats_mem, reset);
d1950 1
a1950 1
			copy_stats_to_sc_xe201(sc);
@


1.2
log
@remove internal queue stats, use if_* counters wherever possible
@
text
@d1 1
a1 1
/*	$OpenBSD: oce.c,v 1.1 2012/08/02 17:35:52 mikeb Exp $	*/
d1590 3
a1592 3
	fwcmd->params.req.if_id = sc->if_id;
	fwcmd->params.req.max_frame_size = rq->cfg.mtu;
	fwcmd->params.req.is_rss_queue = rq->cfg.is_rss_queue;
@


1.1
log
@Add a driver for Emulex OneConnect 10Gb Ethernet obtained from FreeBSD
but heavily massaged to look like other BSD network drivers. Support is
provided for cards based on the following controllers:

 o  ServerEngines BladeEngine 2
 o  ServerEngines BladeEngine 3
 o  Emulex Lancer
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a1829 33
}

void
oce_refresh_queue_stats(struct oce_softc *sc)
{
	struct oce_drv_stats *adapter_stats;
	int i;

	adapter_stats = &sc->oce_stats_info;

	/* Caluculate total TX and TXstats from all queues */

	for (i = 0; i < sc->nrqs; i++) {
		adapter_stats->rx.t_rx_pkts += sc->rq[i]->rx_stats.rx_pkts;
		adapter_stats->rx.t_rx_bytes += sc->rq[i]->rx_stats.rx_bytes;
		adapter_stats->rx.t_rx_frags += sc->rq[i]->rx_stats.rx_frags;
		adapter_stats->rx.t_rx_mcast_pkts +=
					sc->rq[i]->rx_stats.rx_mcast_pkts;
		adapter_stats->rx.t_rx_ucast_pkts +=
					sc->rq[i]->rx_stats.rx_ucast_pkts;
		adapter_stats->rx.t_rxcp_errs += sc-> rq[i]->rx_stats.rxcp_err;
	}

	for (i = 0; i < sc->nwqs; i++) {
		adapter_stats->tx.t_tx_reqs += sc->wq[i]->tx_stats.tx_reqs;
		adapter_stats->tx.t_tx_stops += sc->wq[i]->tx_stats.tx_stops;
		adapter_stats->tx.t_tx_wrbs += sc->wq[i]->tx_stats.tx_wrbs;
		adapter_stats->tx.t_tx_compl += sc->wq[i]->tx_stats.tx_compl;
		adapter_stats->tx.t_tx_bytes += sc->wq[i]->tx_stats.tx_bytes;
		adapter_stats->tx.t_tx_pkts += sc->wq[i]->tx_stats.tx_pkts;
		adapter_stats->tx.t_ipv6_ext_hdr_tx_drop +=
				sc->wq[i]->tx_stats.ipv6_ext_hdr_tx_drop;
	}
@

