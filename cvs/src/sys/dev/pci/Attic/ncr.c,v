head	1.73;
access;
symbols
	OPENBSD_3_7:1.71.0.4
	OPENBSD_3_7_BASE:1.71
	OPENBSD_3_6:1.71.0.2
	OPENBSD_3_6_BASE:1.71
	SMP_SYNC_A:1.68
	SMP_SYNC_B:1.68
	OPENBSD_3_5:1.68.0.2
	OPENBSD_3_5_BASE:1.68
	OPENBSD_3_4:1.67.0.2
	OPENBSD_3_4_BASE:1.67
	UBC_SYNC_A:1.67
	OPENBSD_3_3:1.66.0.2
	OPENBSD_3_3_BASE:1.66
	OPENBSD_3_2:1.64.0.2
	OPENBSD_3_2_BASE:1.64
	OPENBSD_3_1:1.63.0.2
	OPENBSD_3_1_BASE:1.63
	UBC_SYNC_B:1.64
	UBC:1.62.0.2
	UBC_BASE:1.62
	OPENBSD_3_0:1.61.0.2
	OPENBSD_3_0_BASE:1.61
	OPENBSD_2_9_BASE:1.54
	OPENBSD_2_9:1.54.0.2
	OPENBSD_2_8:1.52.0.2
	OPENBSD_2_8_BASE:1.52
	OPENBSD_2_7:1.50.0.4
	OPENBSD_2_7_BASE:1.50
	SMP:1.50.0.2
	SMP_BASE:1.50
	kame_19991208:1.47
	OPENBSD_2_6:1.46.0.2
	OPENBSD_2_6_BASE:1.46
	OPENBSD_2_5:1.45.0.2
	OPENBSD_2_5_BASE:1.45
	OPENBSD_2_4:1.41.0.2
	OPENBSD_2_4_BASE:1.41
	OPENBSD_2_3:1.37.0.2
	OPENBSD_2_3_BASE:1.37
	OPENBSD_2_2:1.31.0.2
	OPENBSD_2_2_BASE:1.31
	OPENBSD_2_1:1.29.0.2
	OPENBSD_2_1_BASE:1.29
	OPENBSD_2_0:1.13.0.2
	OPENBSD_2_0_BASE:1.13
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.73
date	2005.05.27.02.13.52;	author martin;	state dead;
branches;
next	1.72;

1.72
date	2005.05.23.23.26.56;	author tedu;	state Exp;
branches;
next	1.71;

1.71
date	2004.06.25.00.54.27;	author tholo;	state Exp;
branches;
next	1.70;

1.70
date	2004.06.24.19.35.23;	author tholo;	state Exp;
branches;
next	1.69;

1.69
date	2004.06.21.23.50.35;	author tholo;	state Exp;
branches;
next	1.68;

1.68
date	2003.11.07.10.16.45;	author jmc;	state Exp;
branches;
next	1.67;

1.67
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.66;

1.66
date	2003.02.11.19.20.27;	author mickey;	state Exp;
branches;
next	1.65;

1.65
date	2003.01.05.22.41.35;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2002.06.04.00.09.08;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2001.08.26.00.45.08;	author fgsch;	state Exp;
branches;
next	1.60;

1.60
date	2001.08.25.10.13.30;	author art;	state Exp;
branches;
next	1.59;

1.59
date	2001.08.19.15.07.34;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2001.08.12.20.03.49;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2001.06.12.15.40.32;	author niklas;	state Exp;
branches;
next	1.56;

1.56
date	2001.05.16.19.31.40;	author mickey;	state Exp;
branches;
next	1.55;

1.55
date	2001.05.16.12.51.49;	author ho;	state Exp;
branches;
next	1.54;

1.54
date	2001.04.06.04.42.07;	author csapuntz;	state Exp;
branches;
next	1.53;

1.53
date	2001.01.25.03.50.51;	author todd;	state Exp;
branches;
next	1.52;

1.52
date	2000.10.08.19.36.09;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2000.08.01.13.45.26;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2000.02.08.01.25.02;	author millert;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2000.02.07.23.09.53;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2000.02.06.22.03.19;	author niklas;	state Exp;
branches;
next	1.47;

1.47
date	99.12.02.22.12.13;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	99.06.06.23.17.24;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	99.04.05.16.38.04;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	99.03.30.21.53.38;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	99.03.21.01.07.36;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	99.01.11.01.51.58;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	98.08.07.16.48.19;	author pefo;	state Exp;
branches;
next	1.40;

1.40
date	98.07.21.07.16.37;	author downsj;	state Exp;
branches;
next	1.39;

1.39
date	98.07.16.07.06.05;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	98.05.23.03.14.24;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	98.03.22.17.27.44;	author pefo;	state Exp;
branches;
next	1.36;

1.36
date	98.03.17.15.59.46;	author pefo;	state Exp;
branches;
next	1.35;

1.35
date	98.01.07.11.03.31;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	98.01.05.13.35.21;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	97.12.03.21.43.35;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	97.12.01.18.58.48;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	97.10.11.11.05.27;	author pefo;	state Exp;
branches;
next	1.30;

1.30
date	97.09.07.03.36.43;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	97.04.30.16.26.34;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	97.04.10.16.51.38;	author pefo;	state Exp;
branches;
next	1.27;

1.27
date	97.04.10.16.33.08;	author pefo;	state Exp;
branches;
next	1.26;

1.26
date	97.03.03.00.25.03;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	97.01.22.21.46.51;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	97.01.17.05.32.08;	author kstailey;	state Exp;
branches;
next	1.23;

1.23
date	97.01.15.05.50.44;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	96.11.30.23.04.38;	author downsj;	state Exp;
branches;
next	1.21;

1.21
date	96.11.30.21.54.53;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	96.11.28.23.28.08;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	96.11.23.21.47.04;	author kstailey;	state Exp;
branches;
next	1.18;

1.18
date	96.11.12.20.30.57;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	96.10.31.01.05.12;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	96.10.18.15.43.56;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	96.10.13.20.36.14;	author downsj;	state Exp;
branches;
next	1.14;

1.14
date	96.10.12.01.08.13;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	96.09.05.23.14.00;	author dm;	state Exp;
branches;
next	1.12;

1.12
date	96.09.05.23.07.00;	author dm;	state Exp;
branches;
next	1.11;

1.11
date	96.08.21.22.27.57;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.06.10.07.34.47;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.26.00.27.45;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.07.07.38.40;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.25.22;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.18.23.47.59;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.02.20.04.36.17;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	95.12.27.22.06.47;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.01.01.51.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.26.01.35.41;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.40;	author deraadt;	state Exp;
branches;
next	;

1.50.2.1
date	2001.05.14.22.25.50;	author niklas;	state Exp;
branches;
next	1.50.2.2;

1.50.2.2
date	2001.07.04.10.42.40;	author niklas;	state Exp;
branches;
next	1.50.2.3;

1.50.2.3
date	2001.07.14.10.02.17;	author ho;	state Exp;
branches;
next	1.50.2.4;

1.50.2.4
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.50.2.5;

1.50.2.5
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.50.2.6;

1.50.2.6
date	2002.03.28.15.35.58;	author niklas;	state Exp;
branches;
next	1.50.2.7;

1.50.2.7
date	2003.03.28.00.38.23;	author niklas;	state Exp;
branches;
next	1.50.2.8;

1.50.2.8
date	2003.04.19.19.17.49;	author niklas;	state Exp;
branches;
next	1.50.2.9;

1.50.2.9
date	2003.05.13.19.35.06;	author ho;	state Exp;
branches;
next	1.50.2.10;

1.50.2.10
date	2004.02.19.10.56.28;	author niklas;	state Exp;
branches;
next	;

1.62.2.1
date	2002.06.11.03.42.26;	author art;	state Exp;
branches;
next	1.62.2.2;

1.62.2.2
date	2003.05.19.22.18.01;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.73
log
@byebye ncr(4) and some vtophys
@
text
@/*	$OpenBSD: ncr.c,v 1.72 2005/05/23 23:26:56 tedu Exp $	*/
/*	$NetBSD: ncr.c,v 1.63 1997/09/23 02:39:15 perry Exp $	*/

/**************************************************************************
**
**  Id: ncr.c,v 1.112 1997/11/07 09:20:56 phk Exp
**
**  Device driver for the   NCR 53C8xx   PCI-SCSI-Controller.
**
**  FreeBSD / NetBSD / OpenBSD
**
**-------------------------------------------------------------------------
**
**  Written for 386bsd and FreeBSD by
**	Wolfgang Stanglmeier	<wolf@@cologne.de>
**	Stefan Esser		<se@@mi.Uni-Koeln.de>
**
**  Ported to NetBSD by
**	Charles M. Hannum	<mycroft@@gnu.ai.mit.edu>
**
**  Modified for big endian systems by
**	Per Fogelstrom for RTMX Inc, North Carolina. <pefo@@opsycon.se>
**
**-------------------------------------------------------------------------
**
** Copyright (c) 1994 Wolfgang Stanglmeier.  All rights reserved.
**
** Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions
** are met:
** 1. Redistributions of source code must retain the above copyright
**    notice, this list of conditions and the following disclaimer.
** 2. Redistributions in binary form must reproduce the above copyright
**    notice, this list of conditions and the following disclaimer in the
**    documentation and/or other materials provided with the distribution.
** 3. The name of the author may not be used to endorse or promote products
**    derived from this software without specific prior written permission.
**
** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
***************************************************************************
*/

#define NCR_DATE "pl24 96/12/14"

#define NCR_VERSION	(2)
#define	MAX_UNITS	(16)

#define NCR_GETCC_WITHMSG

#if defined (__FreeBSD__) && defined(KERNEL)
#include "opt_ncr.h"
#endif /* defined (__FreeBSD__) && defined(KERNEL) */

#ifdef FAILSAFE
#ifndef SCSI_NCR_DFLT_TAGS
#define	SCSI_NCR_DFLT_TAGS (0)
#endif /* SCSI_NCR_DFLT_TAGS */
#define	NCR_CDROM_ASYNC
#endif /* FAILSAFE */

/*==========================================================
**
**	Configuration and Debugging
**
**	May be overwritten in <arch/conf/xxxx>
**
**==========================================================
*/

/*
**    SCSI address of this device.
**    The boot routines should have set it.
**    If not, use this.
*/

#ifndef SCSI_NCR_MYADDR
#define SCSI_NCR_MYADDR      (7)
#endif /* SCSI_NCR_MYADDR */

/*
**    The default synchronous period factor
**    (0=asynchronous)
**    If maximum synchronous frequency is defined, use it instead.
*/

#ifndef	SCSI_NCR_MAX_SYNC

#ifndef SCSI_NCR_DFLT_SYNC
#define SCSI_NCR_DFLT_SYNC   (10)
#endif /* SCSI_NCR_DFLT_SYNC */

#else

#if	SCSI_NCR_MAX_SYNC == 0
#define	SCSI_NCR_DFLT_SYNC 0
#else
#define	SCSI_NCR_DFLT_SYNC (250000 / SCSI_NCR_MAX_SYNC)
#endif

#endif

/*
**    The minimal asynchronous pre-scaler period (ns)
**    Shall be 40.
*/

#ifndef SCSI_NCR_MIN_ASYNC
#define SCSI_NCR_MIN_ASYNC   (40)
#endif /* SCSI_NCR_MIN_ASYNC */

/*
**    The maximal bus with (in log2 byte)
**    (0=8 bit, 1=16 bit)
*/

#ifndef SCSI_NCR_MAX_WIDE
#define SCSI_NCR_MAX_WIDE   (1)
#endif /* SCSI_NCR_MAX_WIDE */

/*
**    The maximum number of tags per logic unit.
**    Used only for disk devices that support tags.
*/

#ifndef SCSI_NCR_DFLT_TAGS
#define SCSI_NCR_DFLT_TAGS    (4)
#endif /* SCSI_NCR_DFLT_TAGS */

/*==========================================================
**
**      Configuration and Debugging
**
**==========================================================
*/

/*
**    Number of targets supported by the driver.
**    n permits target numbers 0..n-1.
**    Default is 16, meaning targets #0..#15.
**    #7 is the host adapter.
*/

#define MAX_TARGET  (16)

/*
**    Number of logic units supported by the driver.
**    n enables logic unit numbers 0..n-1.
**    The common SCSI devices require only
**    one lun, so take 1 as the default.
*/

#ifndef	MAX_LUN
#define MAX_LUN     (8)
#endif	/* MAX_LUN */

/*
**    The maximum number of jobs scheduled for starting.
**    There should be one slot per target, and one slot
**    for each tag of each target in use.
*/

#ifndef MAX_START
#define MAX_START   (256)
#endif

/*
**    The maximum number of segments a transfer is split into.
*/

#define MAX_SCATTER (33)

/*
**    The maximum transfer length (should be >= 64k).
**    MUST NOT be greater than (MAX_SCATTER-1) * PAGE_SIZE.
*/

#ifdef __OpenBSD__
#define MAX_SIZE  ((MAX_SCATTER-1) * (long) NBPG)
#else
#define MAX_SIZE  ((MAX_SCATTER-1) * (long) PAGE_SIZE)
#endif

/*
**	other
*/

#define NCR_SNOOP_TIMEOUT (1000000)

/*==========================================================
**
**      Include files
**
**==========================================================
*/

#ifdef __OpenBSD__
#ifdef _KERNEL
#define KERNEL
#endif
#else
#include <stddef.h>
#endif

#include <sys/param.h>
#include <sys/time.h>

#ifdef KERNEL
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/kernel.h>
#ifndef __OpenBSD__
#include <sys/sysctl.h>
#include <machine/clock.h>
#else
#include <sys/timeout.h>
#endif
#include <uvm/uvm_extern.h>
#endif /* KERNEL */


#ifndef __OpenBSD__
#include <pci/pcivar.h>
#include <pci/pcireg.h>
#include <pci/ncrreg.h>
#else
#include <sys/device.h>
#include <machine/bus.h>
#include <machine/intr.h>
#include <dev/pci/ncrreg.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#if !defined(__alpha__) && !defined(__mips__) && !defined(__powerpc__)
#define DELAY(x)	delay(x)
#endif
#include <scsi/scsi_all.h>
#endif /* __OpenBSD__ */

#include <scsi/scsiconf.h>

#ifdef __OpenBSD__
#define	__BROKEN_INDIRECT_CONFIG
#ifdef NCR_VERBOSE
#define bootverbose	NCR_VERBOSE
#else
#define bootverbose	0
#endif
#endif

#if !defined(NCR_KVATOPHYS)
#define NCR_KVATOPHYS(sc, va) vtophys(va)
#endif

#if defined(__OpenBSD__) && defined(__alpha__)
/* XXX XXX NEED REAL DMA MAPPING SUPPORT XXX XXX */
#undef vtophys
#define	vtophys(va)	alpha_XXX_dmamap((vm_offset_t)(va))
#endif

/*==========================================================
**
**	Debugging tags
**
**==========================================================
*/

#define DEBUG_ALLOC    (0x0001)
#define DEBUG_PHASE    (0x0002)
#define DEBUG_POLL     (0x0004)
#define DEBUG_QUEUE    (0x0008)
#define DEBUG_RESULT   (0x0010)
#define DEBUG_SCATTER  (0x0020)
#define DEBUG_SCRIPT   (0x0040)
#define DEBUG_TINY     (0x0080)
#define DEBUG_TIMING   (0x0100)
#define DEBUG_NEGO     (0x0200)
#define DEBUG_TAGS     (0x0400)
#define DEBUG_FREEZE   (0x0800)
#define DEBUG_RESTART  (0x1000)

/*
**    Enable/Disable debug messages.
**    Can be changed at runtime too.
*/

#ifdef SCSI_NCR_DEBUG
	#define DEBUG_FLAGS ncr_debug
#else /* SCSI_NCR_DEBUG */
	#define SCSI_NCR_DEBUG	0
	#define DEBUG_FLAGS	0
#endif /* SCSI_NCR_DEBUG */



/*==========================================================
**
**	assert ()
**
**==========================================================
**
**	modified copy from 386bsd:/usr/include/sys/assert.h
**
**----------------------------------------------------------
*/

#undef assert
#define	assert(expression) { \
	if (!(expression)) { \
		(void)printf(\
			"assertion \"%s\" failed: file \"%s\", line %d\n", \
			#expression, \
			__FILE__, __LINE__); \
	} \
}

/*==========================================================
**
**	Access to the controller chip.
**
**==========================================================
*/

#ifdef __OpenBSD__

#define	INB(r) \
    INB_OFF(offsetof(struct ncr_reg, r))
#define	INB_OFF(o) \
    bus_space_read_1 (np->sc_st, np->sc_sh, (o))
#define	INW(r) \
    bus_space_read_2 (np->sc_st, np->sc_sh, offsetof(struct ncr_reg, r))
#define	INL(r) \
    INL_OFF(offsetof(struct ncr_reg, r))
#define	INL_OFF(o) \
    bus_space_read_4 (np->sc_st, np->sc_sh, (o))

#define	OUTB(r, val) \
    bus_space_write_1 (np->sc_st, np->sc_sh, offsetof(struct ncr_reg, r), (val))
#define	OUTW(r, val) \
    bus_space_write_2 (np->sc_st, np->sc_sh, offsetof(struct ncr_reg, r), (val))
#define	OUTL(r, val) \
    OUTL_OFF(offsetof(struct ncr_reg, r), (val))
#define	OUTL_OFF(o, val) \
    bus_space_write_4 (np->sc_st, np->sc_sh, (o), (val))

#define	READSCRIPT_OFF(base, off) \
    SCR_BO(base ? *((int32_t *)((char *)base + (off))) : \
    bus_space_read_4 (np->ram_tag, np->ram_handle, off))

#define	WRITESCRIPT_OFF(base, off, val) \
    do {								\
    	if (base)							\
    		*((int32_t *)((char *)base + (off))) = (SCR_BO(val));	\
    	else								\
    		bus_space_write_4 (np->ram_tag, np->ram_handle, off, SCR_BO(val)); \
    } while (0)

#define	READSCRIPT(r) \
    READSCRIPT_OFF(np->script, offsetof(struct script, r))

#define	WRITESCRIPT(r, val) \
    WRITESCRIPT_OFF(np->script, offsetof(struct script, r), val)

#else /* !__OpenBSD__ */

#ifdef NCR_IOMAPPED

#define	INB(r) inb (np->port + offsetof(struct ncr_reg, r))
#define	INB_OFF(o) inb (np->port + (o))
#define	INW(r) inw (np->port + offsetof(struct ncr_reg, r))
#define	INL(r) inl (np->port + offsetof(struct ncr_reg, r))
#define	INL_OFF(o) inl (np->port + (o))

#define	OUTB(r, val) outb (np->port+offsetof(struct ncr_reg,r),(val))
#define	OUTW(r, val) outw (np->port+offsetof(struct ncr_reg,r),(val))
#define	OUTL(r, val) outl (np->port+offsetof(struct ncr_reg,r),(val))
#define	OUTL_OFF(o, val) outl (np->port+(o),(val))

#else

#define	INB(r) (np->reg->r)
#define	INB_OFF(o) (*((volatile int8_t *)((char *)np->reg + (o))))
#define	INW(r) (np->reg->r)
#define	INL(r) (np->reg->r)
#define	INL_OFF(o) (*((volatile int32_t *)((char *)np->reg + (o))))

#define	OUTB(r, val) np->reg->r = (val)
#define	OUTW(r, val) np->reg->r = (val)
#define	OUTL(r, val) np->reg->r = (val)
#define	OUTL_OFF(o, val) *((volatile int32_t *)((char *)np->reg + (o))) = val

#endif

#define	READSCRIPT_OFF(base, off) (*((int32_t *)((char *)base + (off))))
#define	READSCRIPT(r) (np->script->r)
#define	WRITESCRIPT(r, val) np->script->r = (val)

#endif /* __OpenBSD__ */

/*
**	Set bit field ON, OFF
*/

#define OUTONB(r, m)	OUTB(r, INB(r) | (m))
#define OUTOFFB(r, m)	OUTB(r, INB(r) & ~(m))
#define OUTONW(r, m)	OUTW(r, INW(r) | (m))
#define OUTOFFW(r, m)	OUTW(r, INW(r) & ~(m))
#define OUTONL(r, m)	OUTL(r, INL(r) | (m))
#define OUTOFFL(r, m)	OUTL(r, INL(r) & ~(m))

/*==========================================================
**
**	Command control block states.
**
**==========================================================
*/

#define HS_IDLE		(0)
#define HS_BUSY		(1)
#define HS_NEGOTIATE	(2)	/* sync/wide data transfer*/
#define HS_DISCONNECT	(3)	/* Disconnected by target */

#define HS_COMPLETE	(4)
#define HS_SEL_TIMEOUT	(5)	/* Selection timeout      */
#define HS_RESET	(6)	/* SCSI reset	     */
#define HS_ABORTED	(7)	/* Transfer aborted       */
#define HS_TIMEOUT	(8)	/* Software timeout       */
#define HS_FAIL		(9)	/* SCSI or PCI bus errors */
#define HS_UNEXPECTED	(10)	/* Unexpected disconnect  */

#define HS_DONEMASK	(0xfc)

/*==========================================================
**
**	Software Interrupt Codes
**
**==========================================================
*/

#define	SIR_SENSE_RESTART	(1)
#define	SIR_SENSE_FAILED	(2)
#define	SIR_STALL_RESTART	(3)
#define	SIR_STALL_QUEUE		(4)
#define	SIR_NEGO_SYNC		(5)
#define	SIR_NEGO_WIDE		(6)
#define	SIR_NEGO_FAILED		(7)
#define	SIR_NEGO_PROTO		(8)
#define	SIR_REJECT_RECEIVED	(9)
#define	SIR_REJECT_SENT		(10)
#define	SIR_IGN_RESIDUE		(11)
#define	SIR_MISSING_SAVE	(12)
#define	SIR_MAX			(12)

/*==========================================================
**
**	Extended error codes.
**	xerr_status field of struct ccb.
**
**==========================================================
*/

#define	XE_OK		(0)
#define	XE_EXTRA_DATA	(1)	/* unexpected data phase */
#define	XE_BAD_PHASE	(2)	/* illegal phase (4/5)   */

/*==========================================================
**
**	Negotiation status.
**	nego_status field	of struct ccb.
**
**==========================================================
*/

#define NS_SYNC		(1)
#define NS_WIDE		(2)

/*==========================================================
**
**	"Special features" of targets.
**	quirks field		of struct tcb.
**	actualquirks field	of struct ccb.
**
**==========================================================
*/

#define	QUIRK_AUTOSAVE	(0x01)
#define	QUIRK_NOMSG	(0x02)
#define QUIRK_NOSYNC	(0x10)
#define QUIRK_NOWIDE16	(0x20)
#define QUIRK_NOTAGS	(0x40)
#define	QUIRK_UPDATE	(0x80)

/*==========================================================
**
**	Capability bits in Inquire response byte 7.
**
**==========================================================
*/

#define	INQ7_QUEUE	(0x02)
#define	INQ7_SYNC	(0x10)
#define	INQ7_WIDE16	(0x20)

/*==========================================================
**
**	Misc.
**
**==========================================================
*/

#define CCB_MAGIC	(0xf2691ad2)
#define	MAX_TAGS	(16)		/* hard limit */

/*==========================================================
**
**	OS dependencies.
**
**	Note that various types are defined in ncrreg.h.
**
**==========================================================
*/

#define PRINT_ADDR(xp) sc_print_addr(xp->sc_link)

/*==========================================================
**
**	Declaration of structs.
**
**==========================================================
*/

struct tcb;
struct lcb;
struct ccb;
struct ncb;
struct script;

typedef struct ncb * ncb_p;
typedef struct tcb * tcb_p;
typedef struct lcb * lcb_p;
typedef struct ccb * ccb_p;

struct link {
	ncrcmd	l_cmd;
	ncrcmd	l_paddr;
};

struct	usrcmd {
	u_long	target;
	u_long	lun;
	u_long	data;
	u_long	cmd;
};

#define UC_SETSYNC      10
#define UC_SETTAGS	11
#define UC_SETDEBUG	12
#define UC_SETORDER	13
#define UC_SETWIDE	14
#define UC_SETFLAG	15

#define	UF_TRACE	(0x01)

/*---------------------------------------
**
**	Timestamps for profiling
**
**---------------------------------------
*/

struct tstamp {
	struct timeval	start;
	struct timeval	end;
	struct timeval	select;
	struct timeval	command;
	struct timeval	data;
	struct timeval	status;
	struct timeval	disconnect;
	struct timeval	reselect;
};

/*
**	profiling data (per device)
*/

struct profile {
	u_long	num_trans;
	u_long	num_bytes;
	u_long	num_disc;
	u_long	num_break;
	u_long	num_int;
	u_long	num_fly;
	u_long	ms_setup;
	u_long	ms_data;
	u_long	ms_disc;
	u_long	ms_post;
};

/*==========================================================
**
**	Declaration of structs:		target control block
**
**==========================================================
*/

struct tcb {
	/*
	**	during reselection the ncr jumps to this point
	**	with SFBR set to the encoded target number
	**	with bit 7 set.
	**	if it's not this target, jump to the next.
	**
	**	JUMP  IF (SFBR != #target#)
	**	@@(next tcb)
	*/

	struct link   jump_tcb;

	/*
	**	load the actual values for the sxfer and the scntl3
	**	register (sync/wide mode).
	**
	**	SCR_COPY (1);
	**	@@(sval field of this tcb)
	**	@@(sxfer register)
	**	SCR_COPY (1);
	**	@@(wval field of this tcb)
	**	@@(scntl3 register)
	*/

	ncrcmd	getscr[6];

	/*
	**	if next message is "identify"
	**	then load the message to SFBR,
	**	else load 0 to SFBR.
	**
	**	CALL
	**	<RESEL_LUN>
	*/

	struct link   call_lun;

	/*
	**	now look for the right lun.
	**
	**	JUMP
	**	@@(first ccb of this lun)
	*/

	struct link   jump_lcb;

	/*
	**	pointer to interrupted getcc ccb
	*/

	ccb_p   hold_cp;

	/*
	**	pointer to ccb used for negotiating.
	**	Avoid to start a nego for all queued commands
	**	when tagged command queuing is enabled.
	*/

	ccb_p   nego_cp;

	/*
	**	statistical data
	*/

	u_long	transfers;
	u_long	bytes;

	/*
	**	user settable limits for sync transfer
	**	and tagged commands.
	*/

	u_char	usrsync;
	u_char	usrtags;
	u_char	usrwide;
	u_char	usrflag;

	/*
	**	negotiation of wide and synch transfer.
	**	device quirks.
	*/

/*0*/	u_char	minsync;
/*1*/	u_char	sval;
/*2*/	u_short	period;
/*0*/	u_char	maxoffs;

/*1*/	u_char	quirks;

/*2*/	u_char	widedone;
/*3*/	u_char	wval;
	/*
	**	inquire data
	*/
#define MAX_INQUIRE 36
	u_char	inqdata[MAX_INQUIRE];

	/*
	**	the lcb's of this tcb
	*/

	lcb_p   lp[MAX_LUN];
};

/*==========================================================
**
**	Declaration of structs:		lun control block
**
**==========================================================
*/

struct lcb {
	/*
	**	during reselection the ncr jumps to this point
	**	with SFBR set to the "Identify" message.
	**	if it's not this lun, jump to the next.
	**
	**	JUMP  IF (SFBR != #lun#)
	**	@@(next lcb of this target)
	*/

	struct link	jump_lcb;

	/*
	**	if next message is "simple tag",
	**	then load the tag to SFBR,
	**	else load 0 to SFBR.
	**
	**	CALL
	**	<RESEL_TAG>
	*/

	struct link	call_tag;

	/*
	**	now look for the right ccb.
	**
	**	JUMP
	**	@@(first ccb of this lun)
	*/

	struct link	jump_ccb;

	/*
	**	start of the ccb chain
	*/

	ccb_p	next_ccb;

	/*
	**	Control of tagged queueing
	*/

	u_char		reqccbs;
	u_char		actccbs;
	u_char		reqlink;
	u_char		actlink;
	u_char		usetags;
	u_char		lasttag;
};

/*==========================================================
**
**      Declaration of structs:     COMMAND control block
**
**==========================================================
**
**	This substructure is copied from the ccb to a
**	global address after selection (or reselection)
**	and copied back before disconnect.
**
**	These fields are accessible to the script processor.
**
**----------------------------------------------------------
*/

struct head {
	/*
	**	Execution of a ccb starts at this point.
	**	It's a jump to the "SELECT" label
	**	of the script.
	**
	**	After successful selection the script
	**	processor overwrites it with a jump to
	**	the IDLE label of the script.
	*/

	struct link	launch;

	/*
	**	Saved data pointer.
	**	Points to the position in the script
	**	responsible for the actual transfer
	**	of data.
	**	It's written after reception of a
	**	"SAVE_DATA_POINTER" message.
	**	The goalpointer points after
	**	the last transfer command.
	*/

	u_int32_t	savep;
	u_int32_t	lastp;
	u_int32_t	goalp;

	/*
	**	The virtual address of the ccb
	**	containing this header.
	*/

	ccb_p	cp;

	/*
	**	space for some timestamps to gather
	**	profiling data about devices and this driver.
	*/

	struct tstamp	stamp;

	/*
	**	status fields.
	*/

	u_char		status[8];
};

/*
**	The status bytes are used by the host and the script processor.
**
**	The first four byte are copied to the scratchb register
**	(declared as scr0..scr3 in ncrreg.h) just after the select/reselect,
**	and copied back just after disconnecting.
**	Inside the script the XX_REG are used.
**
**	The last four bytes are used inside the script by "COPY" commands.
**	Because source and destination must have the same alignment
**	in a longword, the fields HAVE to be at the choosen offsets.
**		xerr_st	(4)	0	(0x34)	scratcha
**		sync_st	(5)	1	(0x05)	sxfer
**		wide_st	(7)	3	(0x03)	scntl3
*/

/*
**	First four bytes (script)
*/
#define  QU_REG	scr0
#define  HS_REG	scr1
#define  HS_PRT	nc_scr1
#define  SS_REG	scr2
#define  PS_REG	scr3

/*
**	First four bytes (host)
*/
#define  actualquirks  phys.header.status[0]
#define  host_status   phys.header.status[1]
#define  scsi_status   phys.header.status[2]
#define  parity_status phys.header.status[3]

/*
**	Last four bytes (script)
*/
#define  xerr_st       header.status[4]	/* MUST be ==0 mod 4 */
#define  sync_st       header.status[5]	/* MUST be ==1 mod 4 */
#define  nego_st       header.status[6]
#define  wide_st       header.status[7]	/* MUST be ==3 mod 4 */

/*
**	Last four bytes (host)
*/
#define  xerr_status   phys.xerr_st
#define  sync_status   phys.sync_st
#define  nego_status   phys.nego_st
#define  wide_status   phys.wide_st

/*==========================================================
**
**      Declaration of structs:     Data structure block
**
**==========================================================
**
**	During execution of a ccb by the script processor,
**	the DSA (data structure address) register points
**	to this substructure of the ccb.
**	This substructure contains the header with
**	the script-processor-changable data and
**	data blocks for the indirect move commands.
**
**----------------------------------------------------------
*/

struct dsb {

	/*
	**	Header.
	**	Has to be the first entry,
	**	because it's jumped to by the
	**	script processor
	*/

	struct head	header;

	/*
	**	Table data for Script
	*/

	struct scr_tblsel  select;
	struct scr_tblmove smsg  ;
	struct scr_tblmove smsg2 ;
	struct scr_tblmove cmd   ;
	struct scr_tblmove scmd  ;
	struct scr_tblmove sense ;
	struct scr_tblmove data [MAX_SCATTER];
};

/*==========================================================
**
**      Declaration of structs:     Command control block.
**
**==========================================================
**
**	During execution of a ccb by the script processor,
**	the DSA (data structure address) register points
**	to this substructure of the ccb.
**	This substructure contains the header with
**	the script-processor-changable data and then
**	data blocks for the indirect move commands.
**
**----------------------------------------------------------
*/


struct ccb {
	/*
	**	This filler ensures that the global header is
	**	cache line size aligned.
	*/
	ncrcmd	filler[4];

	/*
	**	during reselection the ncr jumps to this point.
	**	If a "SIMPLE_TAG" message was received,
	**	then SFBR is set to the tag.
	**	else SFBR is set to 0
	**	If looking for another tag, jump to the next ccb.
	**
	**	JUMP  IF (SFBR != #TAG#)
	**	@@(next ccb of this lun)
	*/

	struct link		jump_ccb;

	/*
	**	After execution of this call, the return address
	**	(in  the TEMP register) points to the following
	**	data structure block.
	**	So copy it to the DSA register, and start
	**	processing of this data structure.
	**
	**	CALL
	**	<RESEL_TMP>
	*/

	struct link		call_tmp;

	/*
	**	This is the data structure which is
	**	to be executed by the script processor.
	*/

	struct dsb		phys;

	/*
	**	If a data transfer phase is terminated too early
	**	(after reception of a message (i.e. DISCONNECT)),
	**	we have to prepare a mini script to transfer
	**	the rest of the data.
	*/

	ncrcmd			patch[8];

	/*
	**	The general SCSI driver provides a
	**	pointer to a control block.
	*/

	struct scsi_xfer	*xfer;

	/*
	**	We prepare a message to be sent after selection,
	**	and a second one to be sent after getcc selection.
	**      Contents are IDENTIFY and SIMPLE_TAG.
	**	While negotiating sync or wide transfer,
	**	a SDTM or WDTM message is appended.
	*/

	u_char			scsi_smsg [8];
	u_char			scsi_smsg2[8];
#if defined(__mips__)
	u_char			local_sense[sizeof(struct scsi_sense_data)];
#endif

	/*
	**	Lock this ccb.
	**	Flag is used while looking for a free ccb.
	*/

	u_long		magic;

	/*
	**	Physical address of this instance of ccb
	*/

	u_long		p_ccb;

	/*
	**	Completion time out for this job.
	**	It's set to time of start + allowed number of seconds.
	*/

	u_long		tlimit;

	/*
	**	All ccbs of one hostadapter are chained.
	*/

	ccb_p		link_ccb;

	/*
	**	All ccbs of one target/lun are chained.
	*/

	ccb_p		next_ccb;

	/*
	**	Sense command
	*/

	u_char		sensecmd[6];

	/*
	**	Tag for this transfer.
	**	It's patched into jump_ccb.
	**	If it's not zero, a SIMPLE_TAG
	**	message is included in smsg.
	*/

	u_char			tag;
};

#define CCB_PHYS(cp,lbl)	(cp->p_ccb + offsetof(struct ccb, lbl))

/*==========================================================
**
**      Declaration of structs:     NCR device descriptor
**
**==========================================================
*/

struct ncb {
#ifndef __OpenBSD__
	/*
	**	The global header.
	**	Accessible to both the host and the
	**	script-processor.
	**	We assume it is cache line size aligned.
	*/
	struct head     header;
#endif

#ifdef __OpenBSD__
	struct device sc_dev;
	pci_chipset_tag_t sc_pc;
	void *sc_ih;
	bus_space_tag_t sc_st;
	bus_space_handle_t sc_sh;
	int sc_iomapped;
#else /* !__OpenBSD__ */
	int	unit;
#endif /* __OpenBSD__ */

	/*-----------------------------------------------
	**	Scripts ..
	**-----------------------------------------------
	**
	**	During reselection the ncr jumps to this point.
	**	The SFBR register is loaded with the encoded target id.
	**
	**	Jump to the first target.
	**
	**	JUMP
	**	@@(next tcb)
	*/
	struct link     jump_tcb;

	/*-----------------------------------------------
	**	Configuration ..
	**-----------------------------------------------
	**
	**	virtual and physical addresses
	**	of the 53c810 chip.
	*/
#ifdef __OpenBSD__
	bus_addr_t	paddr;

	bus_space_tag_t ram_tag;
	bus_space_handle_t ram_handle;
	bus_addr_t	paddr2;
	int		scriptmapped;
#else
	vm_offset_t     vaddr;
	vm_offset_t     paddr;

	vm_offset_t     vaddr2;
	vm_offset_t     paddr2;

	/*
	**	pointer to the chip's registers.
	*/
	volatile
	struct ncr_reg* reg;
#endif

	/*
	**	Scripts instance virtual address.
	*/
	struct script	*script;
	struct scripth	*scripth;

	/*
	**	Scripts instance physical address.
	*/
	u_long		p_script;
	u_long		p_scripth;

	/*
	**	The SCSI address of the host adapter.
	*/
	u_char		myaddr;

	/*
	**	timing parameters
	*/
	u_char		minsync;	/* Minimum sync period factor	*/
	u_char		maxsync;	/* Maximum sync period factor	*/
	u_char		maxoffs;	/* Max scsi offset		*/
	u_char		clock_divn;	/* Number of clock divisors	*/
	u_long		clock_khz;	/* SCSI clock frequency in KHz	*/
	u_long		features;	/* Chip features map		*/
	u_char		multiplier;	/* Clock multiplier (1,2,4)	*/

	u_char		maxburst;	/* log base 2 of dwords burst	*/

	/*
	**	BIOS supplied PCI bus options
	*/
	u_char		rv_scntl3;
	u_char		rv_dcntl;
	u_char		rv_dmode;
	u_char		rv_ctest3;
	u_char		rv_ctest4;
	u_char		rv_ctest5;
	u_char		rv_gpcntl;
	u_char		rv_stest2;

	/*-----------------------------------------------
	**	Link to the generic SCSI driver
	**-----------------------------------------------
	*/

	struct scsi_link	sc_link;

	/*-----------------------------------------------
	**	Job control
	**-----------------------------------------------
	**
	**	Commands from user
	*/
	struct usrcmd	user;
	u_char		order;

	/*
	**	Target data
	*/
	struct tcb	target[MAX_TARGET];

	/*
	**	Start queue.
	*/
	u_int32_t	squeue [MAX_START];
	u_short		squeueput;
	u_short		actccbs;

	/*
	**	Timeout handler
	*/
	u_long		heartbeat;
	u_short		ticks;
	u_short		latetime;
	u_long		lasttime;
#ifdef __FreeBSD__
	struct		callout_handle timeout_ch;
#elif defined (__OpenBSD__)
	struct		timeout sc_timeout;
#endif

	/*-----------------------------------------------
	**	Debug and profiling
	**-----------------------------------------------
	**
	**	register dump
	*/
	struct ncr_reg	regdump;
	struct timeval	regtime;

	/*
	**	Profiling data
	*/
	struct profile	profile;
	u_long		disc_phys;
	u_long		disc_ref;

#ifdef __OpenBSD__
	/*
	**	The global header.
	**	Accessible to both the host and the
	**	script-processor.
	**	We assume it is cache line size aligned.
	*/
	struct head     header;
#endif

	/*
	**	The global control block.
	**	It's used only during the configuration phase.
	**	A target control block will be created
	**	after the first successful transfer.
	**	It is allocated separately in order to ensure
	**	cache line size alignment.
	*/
	struct ccb      *ccb;

	/*
	**	message buffers.
	**	Should be longword aligned,
	**	because they're written with a
	**	COPY script command.
	*/
	u_char		msgout[8];
	u_char		msgin [8];
	u_int32_t	lastmsg;

	/*
	**	Buffer for STATUS_IN phase.
	*/
	u_char		scratch;

	/*
	**	controller chip dependent maximal transfer width.
	*/
	u_char		maxwide;

	/*
	**	option for M_IDENTIFY message: enables disconnecting
	*/
	u_char		disc;

#if defined(NCR_IOMAPPED) && !defined(__OpenBSD__)
	/*
	**	address of the ncr control registers in io space
	*/
	u_short		port;
#endif
};

#define NCB_SCRIPT_PHYS(np,lbl)	(np->p_script + offsetof (struct script, lbl))
#define NCB_SCRIPTH_PHYS(np,lbl) (np->p_scripth + offsetof (struct scripth,lbl))

/*==========================================================
**
**
**      Script for NCR-Processor.
**
**	Use ncr_script_fill() to create the variable parts.
**	Use ncr_script_copy_and_bind() to make a copy and
**	bind to physical addresses.
**
**
**==========================================================
**
**	We have to know the offsets of all labels before
**	we reach them (for forward jumps).
**	Therefore we declare a struct here.
**	If you make changes inside the script,
**	DONT FORGET TO CHANGE THE LENGTHS HERE!
**
**----------------------------------------------------------
*/

/*
**	Script fragments which are loaded into the on-board RAM
**	of 825A, 875 and 895 chips.
*/
struct script {
	ncrcmd	start		[  7];
	ncrcmd	start0		[  2];
	ncrcmd	start1		[  3];
	ncrcmd  startpos	[  1];
	ncrcmd  trysel		[  8];
	ncrcmd	skip		[  8];
	ncrcmd	skip2		[  3];
	ncrcmd  idle		[  2];
	ncrcmd	select		[ 18];
	ncrcmd	prepare		[  4];
	ncrcmd	loadpos		[ 14];
	ncrcmd	prepare2	[ 24];
	ncrcmd	setmsg		[  5];
	ncrcmd  clrack		[  2];
	ncrcmd  dispatch	[ 33];
	ncrcmd	no_data		[ 17];
	ncrcmd  checkatn	[ 10];
	ncrcmd  command		[ 15];
	ncrcmd  status		[ 27];
	ncrcmd  msg_in		[ 26];
	ncrcmd  msg_bad		[  6];
	ncrcmd  complete	[ 13];
	ncrcmd	cleanup		[ 12];
	ncrcmd	cleanup0	[  9];
	ncrcmd	signal		[ 12];
	ncrcmd  save_dp		[  5];
	ncrcmd  restore_dp	[  5];
	ncrcmd  disconnect	[ 12];
	ncrcmd  disconnect0	[  5];
	ncrcmd  disconnect1	[ 23];
	ncrcmd	msg_out		[  9];
	ncrcmd	msg_out_done	[  7];
	ncrcmd  badgetcc	[  6];
	ncrcmd	reselect	[  8];
	ncrcmd	reselect1	[  8];
	ncrcmd	reselect2	[  8];
	ncrcmd	resel_tmp	[  5];
	ncrcmd  resel_lun	[ 18];
	ncrcmd	resel_tag	[ 24];
	ncrcmd  data_in		[MAX_SCATTER * 4 + 7];
	ncrcmd  data_out	[MAX_SCATTER * 4 + 7];
};

/*
**	Script fragments which stay in main memory for all chips.
*/
struct scripth {
	ncrcmd  tryloop		[MAX_START*5+2];
	ncrcmd  msg_parity	[  6];
	ncrcmd	msg_reject	[  8];
	ncrcmd	msg_ign_residue	[ 32];
	ncrcmd  msg_extended	[ 18];
	ncrcmd  msg_ext_2	[ 18];
	ncrcmd	msg_wdtr	[ 27];
	ncrcmd  msg_ext_3	[ 18];
	ncrcmd	msg_sdtr	[ 27];
	ncrcmd	msg_out_abort	[ 10];
	ncrcmd  getcc		[  4];
	ncrcmd  getcc1		[  5];
#ifdef NCR_GETCC_WITHMSG
	ncrcmd	getcc2		[ 29];
#else
	ncrcmd	getcc2		[ 14];
#endif
	ncrcmd	getcc3		[  6];
	ncrcmd	aborttag	[  4];
	ncrcmd	abort		[ 22];
	ncrcmd	snooptest	[  9];
	ncrcmd	snoopend	[  2];
};

/*==========================================================
**
**
**      Function headers.
**
**
**==========================================================
*/

#ifdef KERNEL
static	void	ncr_alloc_ccb	(ncb_p np, u_long target, u_long lun);
static	void	ncr_complete	(ncb_p np, ccb_p cp);
static	int	ncr_delta	(struct timeval * from, struct timeval * to);
static	void	ncr_exception	(ncb_p np);
static	void	ncr_free_ccb	(ncb_p np, ccb_p cp, int flags);
static	void	ncr_selectclock	(ncb_p np, u_char scntl3);
static	void	ncr_getclock	(ncb_p np, u_char multiplier);
static	ccb_p	ncr_get_ccb	(ncb_p np, u_long flags, u_long t,u_long l);
static	void	ncr_init	(ncb_p np, char * msg, u_long code);
#ifdef __OpenBSD__
static	int	ncr_intr	(void *vnp);
#else
static	void	ncr_intr	(void *vnp);
static  u_int32_t ncr_info	(int unit);
#endif	/* !__OpenBSD__ */	
static	void	ncr_int_ma	(ncb_p np, u_char dstat);
static	void	ncr_int_sir	(ncb_p np);
static  void    ncr_int_sto     (ncb_p np);
#ifdef __OpenBSD__
static	u_long	ncr_lookup	(char *id);
#endif
static	void	ncr_min_phys	(struct buf *bp);
static	void	ncr_negotiate	(struct ncb* np, struct tcb* tp);
static	void	ncr_opennings	(ncb_p np, lcb_p lp, struct scsi_xfer * xp);
static	void	ncb_profile	(ncb_p np, ccb_p cp);
static	void	ncr_script_copy_and_bind
				(ncb_p np, ncrcmd *src, ncrcmd *dst, int len);
static  void    ncr_script_fill (struct script * scr, struct scripth *scrh);
static	int	ncr_scatter	(ncb_p np, struct dsb* phys, vm_offset_t vaddr,
				 vm_size_t datalen);
static	void	ncr_setmaxtags	(tcb_p tp, u_long usrtags);
static	void	ncr_getsync	(ncb_p np, u_char sfac, u_char *fakp,
				 u_char *scntl3p);
static	void	ncr_setsync	(ncb_p np, ccb_p cp,u_char scntl3,u_char sxfer);
static	void	ncr_settags     (tcb_p tp, lcb_p lp, u_long usrtags);
static	void	ncr_setwide	(ncb_p np, ccb_p cp, u_char wide, u_char ack);
static	int	ncr_show_msg	(u_char * msg);
static	int	ncr_snooptest	(ncb_p np);
static	int32_t	ncr_start       (struct scsi_xfer *xp);
static	void	ncr_timeout	(void *arg);
static	void	ncr_usercmd	(ncb_p np);
static  void    ncr_wakeup      (ncb_p np, u_long code);

#ifdef __OpenBSD__
#ifdef __BROKEN_INDIRECT_CONFIG
static	int	ncr_probe	(struct device *, void *, void *);
#else
static	int	ncr_probe	(struct device *, struct cfdata *, void *);
#endif
static	void	ncr_attach	(struct device *, struct device *, void *);
#else /* !__OpenBSD__ */
static  char   *ncr_probe       (pcici_t tag, pcidi_t type);
static	void	ncr_attach	(pcici_t tag, int unit);
#endif /* __OpenBSD__ */

#endif /* KERNEL */

/*==========================================================
**
**
**      Global static data.
**
**
**==========================================================
*/


#if 0
static char ident[] =
	"\n$OpenBSD: ncr.c,v 1.72 2005/05/23 23:26:56 tedu Exp $\n";
#endif

static const u_long	ncr_version = NCR_VERSION	* 11
	+ (u_long) sizeof (struct ncb)	*  7
	+ (u_long) sizeof (struct ccb)	*  5
	+ (u_long) sizeof (struct lcb)	*  3
	+ (u_long) sizeof (struct tcb)	*  2;

#ifdef KERNEL

#ifndef __OpenBSD__
static const int nncr=MAX_UNITS;	/* XXX to be replaced by SYSCTL */
ncb_p         ncrp [MAX_UNITS];		/* XXX to be replaced by SYSCTL */
#endif /* !__OpenBSD__ */

static int ncr_debug = SCSI_NCR_DEBUG;
#ifndef __OpenBSD__
SYSCTL_INT(_debug, OID_AUTO, ncr_debug, CTLFLAG_RW, &ncr_debug, 0, "");
#endif /* !__OpenBSD__ */

static int ncr_cache; /* to be aligned _NOT_ static */

/*==========================================================
**
**
**      Global static data:	auto configure
**
**
**==========================================================
*/

#define	NCR_810_ID	(0x00011000ul)
#define	NCR_815_ID	(0x00041000ul)
#define	NCR_820_ID	(0x00021000ul)
#define	NCR_825_ID	(0x00031000ul)
#define	NCR_860_ID	(0x00061000ul)
#define	NCR_875_ID	(0x000f1000ul)
#define	NCR_875_ID2	(0x008f1000ul)
#define	NCR_885_ID	(0x000d1000ul)
#define	NCR_895_ID	(0x000c1000ul)
#define	NCR_895A_ID	(0x00121000ul)
#define	NCR_896_ID	(0x000b1000ul)
#define	NCR_1510_ID	(0x00101000ul)
#define	NCR_1510D_ID	(0x000a1000ul)

#ifdef __OpenBSD__

struct	cfattach ncr_ca = {
	sizeof(struct ncb), ncr_probe, ncr_attach
};

struct	cfdriver ncr_cd = {
	NULL, "ncr", DV_DULL
};

#else /* !__OpenBSD__ */

static u_long ncr_count;

static struct	pci_device ncr_device = {
	"ncr",
	ncr_probe,
	ncr_attach,
	&ncr_count,
	NULL
};

DATA_SET (pcidevice_set, ncr_device);

#endif /* !__OpenBSD__ */

static struct scsi_adapter ncr_switch =
{
	ncr_start,
	ncr_min_phys,
	0,
	0,
#ifndef __OpenBSD__
	ncr_info,
	"ncr",
#endif /* !__OpenBSD__ */
};

static struct scsi_device ncr_dev =
{
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default 'done' routine */
#ifndef __OpenBSD__
	"ncr",
#endif /* !__OpenBSD__ */
};

#ifdef __OpenBSD__

#define	ncr_name(np)	(np->sc_dev.dv_xname)

#else /* !__OpenBSD__ */

static char *ncr_name (ncb_p np)
{
	static char name[10];
	snprintf(name, sizeof name, "ncr%d", np->unit);
	return (name);
}
#endif

/*==========================================================
**
**
**      Scripts for NCR-Processor.
**
**      Use ncr_script_bind for binding to physical addresses.
**
**
**==========================================================
**
**	NADDR generates a reference to a field of the controller data.
**	PADDR generates a reference to another part of the script.
**	RADDR generates a reference to a script processor register.
**	FADDR generates a reference to a script processor register
**		with offset.
**
**----------------------------------------------------------
*/

#define	RELOC_SOFTC	0x40000000
#define	RELOC_LABEL	0x50000000
#define	RELOC_REGISTER	0x60000000
#define	RELOC_KVAR	0x70000000
#define	RELOC_LABELH	0x80000000
#define	RELOC_MASK	0xf0000000

#define	NADDR(label)	(RELOC_SOFTC | offsetof(struct ncb, label))
#define PADDR(label)    (RELOC_LABEL | offsetof(struct script, label))
#define PADDRH(label)   (RELOC_LABELH | offsetof(struct scripth, label))
#define	RADDR(label)	(RELOC_REGISTER | REG(label))
#define	FADDR(label,ofs)(RELOC_REGISTER | ((REG(label))+(ofs)))
#define	KVAR(which)	(RELOC_KVAR | (which))

#define KVAR_TIME_TV_SEC		(0)
#define KVAR_TIME			(1)
#define KVAR_NCR_CACHE			(2)

#define	SCRIPT_KVAR_FIRST		(0)
#define	SCRIPT_KVAR_LAST		(3)

/*
 * Kernel variables referenced in the scripts.
 * THESE MUST ALL BE ALIGNED TO A 4-BYTE BOUNDARY.
 */
#ifdef __OpenBSD__
/*
 * XXX - set up a timer that will update a local copy of microuptime once
 * every tick.
 */
static unsigned long script_kvars[] = {
	(unsigned long)&mono_time.tv_sec,
	(unsigned long)&mono_time,
	(unsigned long)&ncr_cache,
};
#else
static void *script_kvars[] =
	{ &time.tv_sec, &time, &ncr_cache };
#endif

static	struct script script0 = {
/*--------------------------< START >-----------------------*/ {
	/*
	**	Claim to be still alive ...
	*/
	SCR_COPY (sizeof (((struct ncb *)0)->heartbeat)),
		KVAR (KVAR_TIME_TV_SEC),
		NADDR (heartbeat),
	/*
	**      Make data structure address invalid.
	**      clear SIGP.
	*/
	SCR_LOAD_REG (dsa, 0xff),
		0,
	SCR_FROM_REG (ctest2),
		0,
}/*-------------------------< START0 >----------------------*/,{
	/*
	**	Hook for interrupted GetConditionCode.
	**	Will be patched to ... IFTRUE by
	**	the interrupt handler.
	*/
	SCR_INT ^ IFFALSE (0),
		SIR_SENSE_RESTART,

}/*-------------------------< START1 >----------------------*/,{
	/*
	**	Hook for stalled start queue.
	**	Will be patched to IFTRUE by the interrupt handler.
	*/
	SCR_INT ^ IFFALSE (0),
		SIR_STALL_RESTART,
	/*
	**	Then jump to a certain point in tryloop.
	**	Due to the lack of indirect addressing the code
	**	is self modifying here.
	*/
	SCR_JUMP,
}/*-------------------------< STARTPOS >--------------------*/,{
		PADDRH(tryloop),

}/*-------------------------< TRYSEL >----------------------*/,{
	/*
	**	Now:
	**	DSA: Address of a Data Structure
	**	or   Address of the IDLE-Label.
	**
	**	TEMP:	Address of a script, which tries to
	**		start the NEXT entry.
	**
	**	Save the TEMP register into the SCRATCHA register.
	**	Then copy the DSA to TEMP and RETURN.
	**	This is kind of an indirect jump.
	**	(The script processor has NO stack, so the
	**	CALL is actually a jump and link, and the
	**	RETURN is an indirect jump.)
	**
	**	If the slot was empty, DSA contains the address
	**	of the IDLE part of this script. The processor
	**	jumps to IDLE and waits for a reselect.
	**	It will wake up and try the same slot again
	**	after the SIGP bit becomes set by the host.
	**
	**	If the slot was not empty, DSA contains
	**	the address of the phys-part of a ccb.
	**	The processor jumps to this address.
	**	phys starts with head,
	**	head starts with launch,
	**	so actually the processor jumps to
	**	the lauch part.
	**	If the entry is scheduled for execution,
	**	then launch contains a jump to SELECT.
	**	If it's not scheduled, it contains a jump to IDLE.
	*/
	SCR_COPY (4),
		RADDR (temp),
		RADDR (scratcha),
	SCR_COPY (4),
		RADDR (dsa),
		RADDR (temp),
	SCR_RETURN,
		0

}/*-------------------------< SKIP >------------------------*/,{
	/*
	**	This entry has been canceled.
	**	Next time use the next slot.
	*/
	SCR_COPY (4),
		RADDR (scratcha),
		PADDR (startpos),
	/*
	**	patch the launch field.
	**	should look like an idle process.
	*/
	SCR_COPY_F (4),
		RADDR (dsa),
		PADDR (skip2),
	SCR_COPY (8),
		PADDR (idle),
}/*-------------------------< SKIP2 >-----------------------*/,{
		0,
	SCR_JUMP,
		PADDR(start),
}/*-------------------------< IDLE >------------------------*/,{
	/*
	**	Nothing to do?
	**	Wait for reselect.
	*/
	SCR_JUMP,
		PADDR(reselect),

}/*-------------------------< SELECT >----------------------*/,{
	/*
	**	DSA	contains the address of a scheduled
	**		data structure.
	**
	**	SCRATCHA contains the address of the script,
	**		which starts the next entry.
	**
	**	Set Initiator mode.
	**
	**	(Target mode is left as an exercise for the reader)
	*/

	SCR_CLR (SCR_TRG),
		0,
	SCR_LOAD_REG (HS_REG, 0xff),
		0,

	/*
	**      And try to select this target.
	*/
	SCR_SEL_TBL_ATN ^ offsetof (struct dsb, select),
		PADDR (reselect),

	/*
	**	Now there are 4 possibilities:
	**
	**	(1) The ncr loses arbitration.
	**	This is ok, because it will try again,
	**	when the bus becomes idle.
	**	(But beware of the timeout function!)
	**
	**	(2) The ncr is reselected.
	**	Then the script processor takes the jump
	**	to the RESELECT label.
	**
	**	(3) The ncr completes the selection.
	**	Then it will execute the next statement.
	**
	**	(4) There is a selection timeout.
	**	Then the ncr should interrupt the host and stop.
	**	Unfortunately, it seems to continue execution
	**	of the script. But it will fail with an
	**	IID-interrupt on the next WHEN.
	*/

	SCR_JUMPR ^ IFTRUE (WHEN (SCR_MSG_IN)),
		0,

	/*
	**	Send the IDENTIFY and SIMPLE_TAG messages
	**	(and the M_X_SYNC_REQ message)
	*/
	SCR_MOVE_TBL ^ SCR_MSG_OUT,
		offsetof (struct dsb, smsg),
#ifdef undef /* XXX better fail than try to deal with this ... */
	SCR_JUMPR ^ IFTRUE (WHEN (SCR_MSG_OUT)),
		-16,
#endif
	SCR_CLR (SCR_ATN),
		0,
	SCR_COPY (1),
		RADDR (sfbr),
		NADDR (lastmsg),
	/*
	**	Selection complete.
	**	Next time use the next slot.
	*/
	SCR_COPY (4),
		RADDR (scratcha),
		PADDR (startpos),
}/*-------------------------< PREPARE >----------------------*/,{
	/*
	**      The ncr doesn't have an indirect load
	**	or store command. So we have to
	**	copy part of the control block to a
	**	fixed place, where we can access it.
	**
	**	We patch the address part of a
	**	COPY command with the DSA-register.
	*/
	SCR_COPY_F (4),
		RADDR (dsa),
		PADDR (loadpos),
	/*
	**	then we do the actual copy.
	*/
	SCR_COPY (sizeof (struct head)),
	/*
	**	continued after the next label ...
	*/

}/*-------------------------< LOADPOS >---------------------*/,{
		0,
		NADDR (header),
	/*
	**      Mark this ccb as not scheduled.
	*/
	SCR_COPY (8),
		PADDR (idle),
		NADDR (header.launch),
	/*
	**      Set a time stamp for this selection
	*/
	SCR_COPY (sizeof (struct timeval)),
		KVAR (KVAR_TIME),
		NADDR (header.stamp.select),
	/*
	**      load the savep (saved pointer) into
	**      the TEMP register (actual pointer)
	*/
	SCR_COPY (4),
		NADDR (header.savep),
		RADDR (temp),
	/*
	**      Initialize the status registers
	*/
	SCR_COPY (4),
		NADDR (header.status),
		RADDR (scr0),

}/*-------------------------< PREPARE2 >---------------------*/,{
	/*
	**      Load the synchronous mode register
	*/
	SCR_COPY (1),
		NADDR (sync_st),
		RADDR (sxfer),
	/*
	**      Load the wide mode and timing register
	*/
	SCR_COPY (1),
		NADDR (wide_st),
		RADDR (scntl3),
	/*
	**	Initialize the msgout buffer with a NOOP message.
	*/
	SCR_LOAD_REG (scratcha, M_NOOP),
		0,
	SCR_COPY (1),
		RADDR (scratcha),
		NADDR (msgout),
	SCR_COPY (1),
		RADDR (scratcha),
		NADDR (msgin),
	/*
	**	Message in phase ?
	*/
	SCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),
		PADDR (dispatch),
	/*
	**	Extended or reject message ?
	*/
	SCR_FROM_REG (sbdl),
		0,
	SCR_JUMP ^ IFTRUE (DATA (M_EXTENDED)),
		PADDR (msg_in),
	SCR_JUMP ^ IFTRUE (DATA (M_REJECT)),
		PADDRH (msg_reject),
	/*
	**	normal processing
	*/
	SCR_JUMP,
		PADDR (dispatch),
}/*-------------------------< SETMSG >----------------------*/,{
	SCR_COPY (1),
		RADDR (scratcha),
		NADDR (msgout),
	SCR_SET (SCR_ATN),
		0,
}/*-------------------------< CLRACK >----------------------*/,{
	/*
	**	Terminate possible pending message phase.
	*/
	SCR_CLR (SCR_ACK),
		0,

}/*-----------------------< DISPATCH >----------------------*/,{
	SCR_FROM_REG (HS_REG),
		0,
	SCR_INT ^ IFTRUE (DATA (HS_NEGOTIATE)),
		SIR_NEGO_FAILED,
	/*
	**	remove bogus output signals
	*/
	SCR_REG_REG (socl, SCR_AND, CACK|CATN),
		0,
	SCR_RETURN ^ IFTRUE (WHEN (SCR_DATA_OUT)),
		0,
	SCR_RETURN ^ IFTRUE (IF (SCR_DATA_IN)),
		0,
	SCR_JUMP ^ IFTRUE (IF (SCR_MSG_OUT)),
		PADDR (msg_out),
	SCR_JUMP ^ IFTRUE (IF (SCR_MSG_IN)),
		PADDR (msg_in),
	SCR_JUMP ^ IFTRUE (IF (SCR_COMMAND)),
		PADDR (command),
	SCR_JUMP ^ IFTRUE (IF (SCR_STATUS)),
		PADDR (status),
	/*
	**      Discard one illegal phase byte, if required.
	*/
	SCR_LOAD_REG (scratcha, XE_BAD_PHASE),
		0,
	SCR_COPY (1),
		RADDR (scratcha),
		NADDR (xerr_st),
	SCR_JUMPR ^ IFFALSE (IF (SCR_ILG_OUT)),
		8,
	SCR_MOVE_ABS (1) ^ SCR_ILG_OUT,
		NADDR (scratch),
	SCR_JUMPR ^ IFFALSE (IF (SCR_ILG_IN)),
		8,
	SCR_MOVE_ABS (1) ^ SCR_ILG_IN,
		NADDR (scratch),
	SCR_JUMP,
		PADDR (dispatch),

}/*-------------------------< NO_DATA >--------------------*/,{
	/*
	**	The target wants to tranfer too much data
	**	or in the wrong direction.
	**      Remember that in extended error.
	*/
	SCR_LOAD_REG (scratcha, XE_EXTRA_DATA),
		0,
	SCR_COPY (1),
		RADDR (scratcha),
		NADDR (xerr_st),
	/*
	**      Discard one data byte, if required.
	*/
	SCR_JUMPR ^ IFFALSE (WHEN (SCR_DATA_OUT)),
		8,
	SCR_MOVE_ABS (1) ^ SCR_DATA_OUT,
		NADDR (scratch),
	SCR_JUMPR ^ IFFALSE (IF (SCR_DATA_IN)),
		8,
	SCR_MOVE_ABS (1) ^ SCR_DATA_IN,
		NADDR (scratch),
	/*
	**      .. and repeat as required.
	*/
	SCR_CALL,
		PADDR (dispatch),
	SCR_JUMP,
		PADDR (no_data),
}/*-------------------------< CHECKATN >--------------------*/,{
	/*
	**	If AAP (bit 1 of scntl0 register) is set
	**	and a parity error is detected,
	**	the script processor asserts ATN.
	**
	**	The target should switch to a MSG_OUT phase
	**	to get the message.
	*/
	SCR_FROM_REG (socl),
		0,
	SCR_JUMP ^ IFFALSE (MASK (CATN, CATN)),
		PADDR (dispatch),
	/*
	**	count it
	*/
	SCR_REG_REG (PS_REG, SCR_ADD, 1),
		0,
	/*
	**	Prepare a M_ID_ERROR message
	**	(initiator detected error).
	**	The target should retry the transfer.
	*/
	SCR_LOAD_REG (scratcha, M_ID_ERROR),
		0,
	SCR_JUMP,
		PADDR (setmsg),

}/*-------------------------< COMMAND >--------------------*/,{
	/*
	**	If this is not a GETCC transfer ...
	*/
	SCR_FROM_REG (SS_REG),
		0,
/*<<<*/	SCR_JUMPR ^ IFTRUE (DATA (S_CHECK_COND)),
		28,
	/*
	**	... set a timestamp ...
	*/
	SCR_COPY (sizeof (struct timeval)),
		KVAR (KVAR_TIME),
		NADDR (header.stamp.command),
	/*
	**	... and send the command
	*/
	SCR_MOVE_TBL ^ SCR_COMMAND,
		offsetof (struct dsb, cmd),
	SCR_JUMP,
		PADDR (dispatch),
	/*
	**	Send the GETCC command
	*/
/*>>>*/	SCR_MOVE_TBL ^ SCR_COMMAND,
		offsetof (struct dsb, scmd),
	SCR_JUMP,
		PADDR (dispatch),

}/*-------------------------< STATUS >--------------------*/,{
	/*
	**	set the timestamp.
	*/
	SCR_COPY (sizeof (struct timeval)),
		KVAR (KVAR_TIME),
		NADDR (header.stamp.status),
	/*
	**	If this is a GETCC transfer,
	*/
	SCR_FROM_REG (SS_REG),
		0,
/*<<<*/	SCR_JUMPR ^ IFFALSE (DATA (S_CHECK_COND)),
		40,
	/*
	**	get the status
	*/
	SCR_MOVE_ABS (1) ^ SCR_STATUS,
		NADDR (scratch),
	/*
	**	Save status to scsi_status.
	**	Mark as complete.
	**	And wait for disconnect.
	*/
	SCR_TO_REG (SS_REG),
		0,
	SCR_REG_REG (SS_REG, SCR_OR, S_SENSE),
		0,
	SCR_LOAD_REG (HS_REG, HS_COMPLETE),
		0,
	SCR_JUMP,
		PADDR (checkatn),
	/*
	**	If it was no GETCC transfer,
	**	save the status to scsi_status.
	*/
/*>>>*/	SCR_MOVE_ABS (1) ^ SCR_STATUS,
		NADDR (scratch),
	SCR_TO_REG (SS_REG),
		0,
	/*
	**	if it was no check condition ...
	*/
	SCR_JUMP ^ IFTRUE (DATA (S_CHECK_COND)),
		PADDR (checkatn),
	/*
	**	... mark as complete.
	*/
	SCR_LOAD_REG (HS_REG, HS_COMPLETE),
		0,
	SCR_JUMP,
		PADDR (checkatn),

}/*-------------------------< MSG_IN >--------------------*/,{
	/*
	**	Get the first byte of the message
	**	and save it to SCRATCHA.
	**
	**	The script processor doesn't negate the
	**	ACK signal after this transfer.
	*/
	SCR_MOVE_ABS (1) ^ SCR_MSG_IN,
		NADDR (msgin[0]),
	/*
	**	Check for message parity error.
	*/
	SCR_TO_REG (scratcha),
		0,
	SCR_FROM_REG (socl),
		0,
	SCR_JUMP ^ IFTRUE (MASK (CATN, CATN)),
		PADDRH (msg_parity),
	SCR_FROM_REG (scratcha),
		0,
	/*
	**	Parity was ok, handle this message.
	*/
	SCR_JUMP ^ IFTRUE (DATA (M_COMPLETE)),
		PADDR (complete),
	SCR_JUMP ^ IFTRUE (DATA (M_SAVE_DP)),
		PADDR (save_dp),
	SCR_JUMP ^ IFTRUE (DATA (M_RESTORE_DP)),
		PADDR (restore_dp),
	SCR_JUMP ^ IFTRUE (DATA (M_DISCONNECT)),
		PADDR (disconnect),
	SCR_JUMP ^ IFTRUE (DATA (M_EXTENDED)),
		PADDRH (msg_extended),
	SCR_JUMP ^ IFTRUE (DATA (M_NOOP)),
		PADDR (clrack),
	SCR_JUMP ^ IFTRUE (DATA (M_REJECT)),
		PADDRH (msg_reject),
	SCR_JUMP ^ IFTRUE (DATA (M_IGN_RESIDUE)),
		PADDRH (msg_ign_residue),
	/*
	**	Rest of the messages left as
	**	an exercise ...
	**
	**	Unimplemented messages:
	**	fall through to MSG_BAD.
	*/
}/*-------------------------< MSG_BAD >------------------*/,{
	/*
	**	unimplemented message - reject it.
	*/
	SCR_INT,
		SIR_REJECT_SENT,
	SCR_LOAD_REG (scratcha, M_REJECT),
		0,
	SCR_JUMP,
		PADDR (setmsg),

}/*-------------------------< COMPLETE >-----------------*/,{
	/*
	**	Complete message.
	**
	**	If it's not the get condition code,
	**	copy TEMP register to LASTP in header.
	*/
	SCR_FROM_REG (SS_REG),
		0,
/*<<<*/	SCR_JUMPR ^ IFTRUE (MASK (S_SENSE, S_SENSE)),
		12,
	SCR_COPY (4),
		RADDR (temp),
		NADDR (header.lastp),
/*>>>*/	/*
	**	When we terminate the cycle by clearing ACK,
	**	the target may disconnect immediately.
	**
	**	We don't want to be told of an
	**	"unexpected disconnect",
	**	so we disable this feature.
	*/
	SCR_REG_REG (scntl2, SCR_AND, 0x7f),
		0,
	/*
	**	Terminate cycle ...
	*/
	SCR_CLR (SCR_ACK|SCR_ATN),
		0,
	/*
	**	... and wait for the disconnect.
	*/
	SCR_WAIT_DISC,
		0,
}/*-------------------------< CLEANUP >-------------------*/,{
	/*
	**      dsa:    Pointer to ccb
	**	      or xxxxxxFF (no ccb)
	**
	**      HS_REG:   Host-Status (<>0!)
	*/
	SCR_FROM_REG (dsa),
		0,
	SCR_JUMP ^ IFTRUE (DATA (0xff)),
		PADDR (signal),
	/*
	**      dsa is valid.
	**	save the status registers
	*/
	SCR_COPY (4),
		RADDR (scr0),
		NADDR (header.status),
	/*
	**	and copy back the header to the ccb.
	*/
	SCR_COPY_F (4),
		RADDR (dsa),
		PADDR (cleanup0),
	SCR_COPY (sizeof (struct head)),
		NADDR (header),
}/*-------------------------< CLEANUP0 >--------------------*/,{
		0,

	/*
	**	If command resulted in "check condition"
	**	status and is not yet completed,
	**	try to get the condition code.
	*/
	SCR_FROM_REG (HS_REG),
		0,
/*<<<*/	SCR_JUMPR ^ IFFALSE (MASK (0, HS_DONEMASK)),
		16,
	SCR_FROM_REG (SS_REG),
		0,
	SCR_JUMP ^ IFTRUE (DATA (S_CHECK_COND)),
		PADDRH(getcc2),
}/*-------------------------< SIGNAL >----------------------*/,{
	/*
	**	if status = queue full,
	**	reinsert in startqueue and stall queue.
	*/
/*>>>*/	SCR_FROM_REG (SS_REG),
		0,
	SCR_INT ^ IFTRUE (DATA (S_QUEUE_FULL)),
		SIR_STALL_QUEUE,
	/*
	**	And make the DSA register invalid.
	*/
	SCR_LOAD_REG (dsa, 0xff), /* invalid */
		0,
	/*
	**	if job completed ...
	*/
	SCR_FROM_REG (HS_REG),
		0,
	/*
	**	... signal completion to the host
	*/
	SCR_INT_FLY ^ IFFALSE (MASK (0, HS_DONEMASK)),
		0,
	/*
	**	Auf zu neuen Schandtaten!
	*/
	SCR_JUMP,
		PADDR(start),

}/*-------------------------< SAVE_DP >------------------*/,{
	/*
	**	SAVE_DP message:
	**	Copy TEMP register to SAVEP in header.
	*/
	SCR_COPY (4),
		RADDR (temp),
		NADDR (header.savep),
	SCR_JUMP,
		PADDR (clrack),
}/*-------------------------< RESTORE_DP >---------------*/,{
	/*
	**	RESTORE_DP message:
	**	Copy SAVEP in header to TEMP register.
	*/
	SCR_COPY (4),
		NADDR (header.savep),
		RADDR (temp),
	SCR_JUMP,
		PADDR (clrack),

}/*-------------------------< DISCONNECT >---------------*/,{
	/*
	**	If QUIRK_AUTOSAVE is set,
	**	do an "save pointer" operation.
	*/
	SCR_FROM_REG (QU_REG),
		0,
/*<<<*/	SCR_JUMPR ^ IFFALSE (MASK (QUIRK_AUTOSAVE, QUIRK_AUTOSAVE)),
		12,
	/*
	**	like SAVE_DP message:
	**	Copy TEMP register to SAVEP in header.
	*/
	SCR_COPY (4),
		RADDR (temp),
		NADDR (header.savep),
/*>>>*/	/*
	**	Check if temp==savep or temp==goalp:
	**	if not, log a missing save pointer message.
	**	In fact, it's a comparison mod 256.
	**
	**	Hmmm, I hadn't thought that I would be urged to
	**	write this kind of ugly self modifying code.
	**
	**	It's unbelievable, but the ncr53c8xx isn't able
	**	to subtract one register from another.
	*/
	SCR_FROM_REG (temp),
		0,
	/*
	**	You are not expected to understand this ..
	**
	**	CAUTION: only little endian architectures supported! XXX
	*/
	SCR_COPY_F (1),
		NADDR (header.savep),
		PADDR (disconnect0),
}/*-------------------------< DISCONNECT0 >--------------*/,{
/*<<<*/	SCR_JUMPR ^ IFTRUE (DATA (1)),
		20,
	/*
	**	neither this
	*/
	SCR_COPY_F (1),
		NADDR (header.goalp),
		PADDR (disconnect1),
}/*-------------------------< DISCONNECT1 >--------------*/,{
	SCR_INT ^ IFFALSE (DATA (1)),
		SIR_MISSING_SAVE,
/*>>>*/

	/*
	**	DISCONNECTing  ...
	**
	**	disable the "unexpected disconnect" feature,
	**	and remove the ACK signal.
	*/
	SCR_REG_REG (scntl2, SCR_AND, 0x7f),
		0,
	SCR_CLR (SCR_ACK|SCR_ATN),
		0,
	/*
	**	Wait for the disconnect.
	*/
	SCR_WAIT_DISC,
		0,
	/*
	**	Profiling:
	**	Set a time stamp,
	**	and count the disconnects.
	*/
	SCR_COPY (sizeof (struct timeval)),
		KVAR (KVAR_TIME),
		NADDR (header.stamp.disconnect),
	SCR_COPY (4),
		NADDR (disc_phys),
		RADDR (temp),
	SCR_REG_REG (temp, SCR_ADD, 0x01),
		0,
	SCR_COPY (4),
		RADDR (temp),
		NADDR (disc_phys),
	/*
	**	Status is: DISCONNECTED.
	*/
	SCR_LOAD_REG (HS_REG, HS_DISCONNECT),
		0,
	SCR_JUMP,
		PADDR (cleanup),

}/*-------------------------< MSG_OUT >-------------------*/,{
	/*
	**	The target requests a message.
	*/
	SCR_MOVE_ABS (1) ^ SCR_MSG_OUT,
		NADDR (msgout),
	SCR_COPY (1),
		RADDR (sfbr),
		NADDR (lastmsg),
	/*
	**	If it was no ABORT message ...
	*/
	SCR_JUMP ^ IFTRUE (DATA (M_ABORT)),
		PADDRH (msg_out_abort),
	/*
	**	... wait for the next phase
	**	if it's a message out, send it again, ...
	*/
	SCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_OUT)),
		PADDR (msg_out),
}/*-------------------------< MSG_OUT_DONE >--------------*/,{
	/*
	**	... else clear the message ...
	*/
	SCR_LOAD_REG (scratcha, M_NOOP),
		0,
	SCR_COPY (4),
		RADDR (scratcha),
		NADDR (msgout),
	/*
	**	... and process the next phase
	*/
	SCR_JUMP,
		PADDR (dispatch),

}/*------------------------< BADGETCC >---------------------*/,{
	/*
	**	If SIGP was set, clear it and try again.
	*/
	SCR_FROM_REG (ctest2),
		0,
	SCR_JUMP ^ IFTRUE (MASK (CSIGP,CSIGP)),
		PADDRH (getcc2),
	SCR_INT,
		SIR_SENSE_FAILED,
}/*-------------------------< RESELECT >--------------------*/,{
	/*
	**	This NOP will be patched with LED OFF
	**	SCR_REG_REG (gpreg, SCR_OR, 0x01)
	*/
	SCR_NO_OP,
		0,

	/*
	**	make the DSA invalid.
	*/
	SCR_LOAD_REG (dsa, 0xff),
		0,
	SCR_CLR (SCR_TRG),
		0,
	/*
	**	Sleep waiting for a reselection.
	**	If SIGP is set, special treatment.
	**
	**	Zu allem bereit ..
	*/
	SCR_WAIT_RESEL,
		PADDR(reselect2),
}/*-------------------------< RESELECT1 >--------------------*/,{
	/*
	**	This NOP will be patched with LED ON
	**	SCR_REG_REG (gpreg, SCR_AND, 0xfe)
	*/
	SCR_NO_OP,
		0,
	/*
	**	... zu nichts zu gebrauchen ?
	**
	**      load the target id into the SFBR
	**	and jump to the control block.
	**
	**	Look at the declarations of
	**	- struct ncb
	**	- struct tcb
	**	- struct lcb
	**	- struct ccb
	**	to understand what's going on.
	*/
	SCR_REG_SFBR (ssid, SCR_AND, 0x8F),
		0,
	SCR_TO_REG (sdid),
		0,
	SCR_JUMP,
		NADDR (jump_tcb),
}/*-------------------------< RESELECT2 >-------------------*/,{
	/*
	**	This NOP will be patched with LED ON
	**	SCR_REG_REG (gpreg, SCR_AND, 0xfe)
	*/
	SCR_NO_OP,
		0,
	/*
	**	If it's not connected :(
	**	-> interrupted by SIGP bit.
	**	Jump to start.
	*/
	SCR_FROM_REG (ctest2),
		0,
	SCR_JUMP ^ IFTRUE (MASK (CSIGP,CSIGP)),
		PADDR (start),
	SCR_JUMP,
		PADDR (reselect),

}/*-------------------------< RESEL_TMP >-------------------*/,{
	/*
	**	The return address in TEMP
	**	is in fact the data structure address,
	**	so copy it to the DSA register.
	*/
	SCR_COPY (4),
		RADDR (temp),
		RADDR (dsa),
	SCR_JUMP,
		PADDR (prepare),

}/*-------------------------< RESEL_LUN >-------------------*/,{
	/*
	**	come back to this point
	**	to get an IDENTIFY message
	**	Wait for a msg_in phase.
	*/
/*<<<*/	SCR_JUMPR ^ IFFALSE (WHEN (SCR_MSG_IN)),
		48,
	/*
	**	message phase
	**	It's not a sony, it's a trick:
	**	read the data without acknowledging it.
	*/
	SCR_FROM_REG (sbdl),
		0,
/*<<<*/	SCR_JUMPR ^ IFFALSE (MASK (M_IDENTIFY, 0x98)),
		32,
	/*
	**	It WAS an Identify message.
	**	get it and ack it!
	*/
	SCR_MOVE_ABS (1) ^ SCR_MSG_IN,
		NADDR (msgin),
	SCR_CLR (SCR_ACK),
		0,
	/*
	**	Mask out the lun.
	*/
	SCR_REG_REG (sfbr, SCR_AND, 0x07),
		0,
	SCR_RETURN,
		0,
	/*
	**	No message phase or no IDENTIFY message:
	**	return 0.
	*/
/*>>>*/	SCR_LOAD_SFBR (0),
		0,
	SCR_RETURN,
		0,

}/*-------------------------< RESEL_TAG >-------------------*/,{
	/*
	**	come back to this point
	**	to get a SIMPLE_TAG message
	**	Wait for a MSG_IN phase.
	*/
/*<<<*/	SCR_JUMPR ^ IFFALSE (WHEN (SCR_MSG_IN)),
		64,
	/*
	**	message phase
	**	It's a trick - read the data
	**	without acknowledging it.
	*/
	SCR_FROM_REG (sbdl),
		0,
/*<<<*/	SCR_JUMPR ^ IFFALSE (DATA (M_SIMPLE_TAG)),
		48,
	/*
	**	It WAS a SIMPLE_TAG message.
	**	get it and ack it!
	*/
	SCR_MOVE_ABS (1) ^ SCR_MSG_IN,
		NADDR (msgin),
	SCR_CLR (SCR_ACK),
		0,
	/*
	**	Wait for the second byte (the tag)
	*/
/*<<<*/	SCR_JUMPR ^ IFFALSE (WHEN (SCR_MSG_IN)),
		24,
	/*
	**	Get it and ack it!
	*/
	SCR_MOVE_ABS (1) ^ SCR_MSG_IN,
		NADDR (msgin),
	SCR_CLR (SCR_ACK|SCR_CARRY),
		0,
	SCR_RETURN,
		0,
	/*
	**	No message phase or no SIMPLE_TAG message
	**	or no second byte: return 0.
	*/
/*>>>*/	SCR_LOAD_SFBR (0),
		0,
	SCR_SET (SCR_CARRY),
		0,
	SCR_RETURN,
		0,

}/*-------------------------< DATA_IN >--------------------*/,{
/*
**	Because the size depends on the
**	#define MAX_SCATTER parameter,
**	it is filled in at runtime.
**
**	SCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_IN)),
**		PADDR (no_data),
**	SCR_COPY (sizeof (struct timeval)),
**		KVAR (KVAR_TIME),
**		NADDR (header.stamp.data),
**	SCR_MOVE_TBL ^ SCR_DATA_IN,
**		offsetof (struct dsb, data[ 0]),
**
**  ##===========< i=1; i<MAX_SCATTER >=========
**  ||	SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN)),
**  ||		PADDR (checkatn),
**  ||	SCR_MOVE_TBL ^ SCR_DATA_IN,
**  ||		offsetof (struct dsb, data[ i]),
**  ##==========================================
**
**	SCR_CALL,
**		PADDR (checkatn),
**	SCR_JUMP,
**		PADDR (no_data),
*/
0
}/*-------------------------< DATA_OUT >-------------------*/,{
/*
**	Because the size depends on the
**	#define MAX_SCATTER parameter,
**	it is filled in at runtime.
**
**	SCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_OUT)),
**		PADDR (no_data),
**	SCR_COPY (sizeof (struct timeval)),
**		KVAR (KVAR_TIME),
**		NADDR (header.stamp.data),
**	SCR_MOVE_TBL ^ SCR_DATA_OUT,
**		offsetof (struct dsb, data[ 0]),
**
**  ##===========< i=1; i<MAX_SCATTER >=========
**  ||	SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT)),
**  ||		PADDR (dispatch),
**  ||	SCR_MOVE_TBL ^ SCR_DATA_OUT,
**  ||		offsetof (struct dsb, data[ i]),
**  ##==========================================
**
**	SCR_CALL,
**		PADDR (dispatch),
**	SCR_JUMP,
**		PADDR (no_data),
**
**---------------------------------------------------------
*/
#ifdef __OpenBSD__
0
#else
(u_long)&ident
#endif

}/*--------------------------------------------------------*/
};


static	struct scripth scripth0 = {
/*-------------------------< TRYLOOP >---------------------*/{
/*
**	Load an entry of the start queue into dsa
**	and try to start it by jumping to TRYSEL.
**
**	Because the size depends on the
**	#define MAX_START parameter, it is filled
**	in at runtime.
**
**-----------------------------------------------------------
**
**  ##===========< I=0; i<MAX_START >===========
**  ||	SCR_COPY (4),
**  ||		NADDR (squeue[i]),
**  ||		RADDR (dsa),
**  ||	SCR_CALL,
**  ||		PADDR (trysel),
**  ##==========================================
**
**	SCR_JUMP,
**		PADDRH(tryloop),
**
**-----------------------------------------------------------
*/
0
}/*-------------------------< MSG_PARITY >---------------*/,{
	/*
	**	count it
	*/
	SCR_REG_REG (PS_REG, SCR_ADD, 0x01),
		0,
	/*
	**	send a "message parity error" message.
	*/
	SCR_LOAD_REG (scratcha, M_PARITY),
		0,
	SCR_JUMP,
		PADDR (setmsg),
}/*-------------------------< MSG_REJECT >---------------*/,{
	/*
	**	If a negotiation was in progress,
	**	negotiation failed.
	*/
	SCR_FROM_REG (HS_REG),
		0,
	SCR_INT ^ IFTRUE (DATA (HS_NEGOTIATE)),
		SIR_NEGO_FAILED,
	/*
	**	else make host log this message
	*/
	SCR_INT ^ IFFALSE (DATA (HS_NEGOTIATE)),
		SIR_REJECT_RECEIVED,
	SCR_JUMP,
		PADDR (clrack),

}/*-------------------------< MSG_IGN_RESIDUE >----------*/,{
	/*
	**	Terminate cycle
	*/
	SCR_CLR (SCR_ACK),
		0,
	SCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),
		PADDR (dispatch),
	/*
	**	get residue size.
	*/
	SCR_MOVE_ABS (1) ^ SCR_MSG_IN,
		NADDR (msgin[1]),
	/*
	**	Check for message parity error.
	*/
	SCR_TO_REG (scratcha),
		0,
	SCR_FROM_REG (socl),
		0,
	SCR_JUMP ^ IFTRUE (MASK (CATN, CATN)),
		PADDRH (msg_parity),
	SCR_FROM_REG (scratcha),
		0,
	/*
	**	Size is 0 .. ignore message.
	*/
	SCR_JUMP ^ IFTRUE (DATA (0)),
		PADDR (clrack),
	/*
	**	Size is not 1 .. have to interrupt.
	*/
/*<<<*/	SCR_JUMPR ^ IFFALSE (DATA (1)),
		40,
	/*
	**	Check for residue byte in swide register
	*/
	SCR_FROM_REG (scntl2),
		0,
/*<<<*/	SCR_JUMPR ^ IFFALSE (MASK (WSR, WSR)),
		16,
	/*
	**	There IS data in the swide register.
	**	Discard it.
	*/
	SCR_REG_REG (scntl2, SCR_OR, WSR),
		0,
	SCR_JUMP,
		PADDR (clrack),
	/*
	**	Load again the size to the sfbr register.
	*/
/*>>>*/	SCR_FROM_REG (scratcha),
		0,
/*>>>*/	SCR_INT,
		SIR_IGN_RESIDUE,
	SCR_JUMP,
		PADDR (clrack),

}/*-------------------------< MSG_EXTENDED >-------------*/,{
	/*
	**	Terminate cycle
	*/
	SCR_CLR (SCR_ACK),
		0,
	SCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),
		PADDR (dispatch),
	/*
	**	get length.
	*/
	SCR_MOVE_ABS (1) ^ SCR_MSG_IN,
		NADDR (msgin[1]),
	/*
	**	Check for message parity error.
	*/
	SCR_TO_REG (scratcha),
		0,
	SCR_FROM_REG (socl),
		0,
	SCR_JUMP ^ IFTRUE (MASK (CATN, CATN)),
		PADDRH (msg_parity),
	SCR_FROM_REG (scratcha),
		0,
	/*
	*/
	SCR_JUMP ^ IFTRUE (DATA (3)),
		PADDRH (msg_ext_3),
	SCR_JUMP ^ IFFALSE (DATA (2)),
		PADDR (msg_bad),
}/*-------------------------< MSG_EXT_2 >----------------*/,{
	SCR_CLR (SCR_ACK),
		0,
	SCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),
		PADDR (dispatch),
	/*
	**	get extended message code.
	*/
	SCR_MOVE_ABS (1) ^ SCR_MSG_IN,
		NADDR (msgin[2]),
	/*
	**	Check for message parity error.
	*/
	SCR_TO_REG (scratcha),
		0,
	SCR_FROM_REG (socl),
		0,
	SCR_JUMP ^ IFTRUE (MASK (CATN, CATN)),
		PADDRH (msg_parity),
	SCR_FROM_REG (scratcha),
		0,
	SCR_JUMP ^ IFTRUE (DATA (M_X_WIDE_REQ)),
		PADDRH (msg_wdtr),
	/*
	**	unknown extended message
	*/
	SCR_JUMP,
		PADDR (msg_bad)
}/*-------------------------< MSG_WDTR >-----------------*/,{
	SCR_CLR (SCR_ACK),
		0,
	SCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),
		PADDR (dispatch),
	/*
	**	get data bus width
	*/
	SCR_MOVE_ABS (1) ^ SCR_MSG_IN,
		NADDR (msgin[3]),
	SCR_FROM_REG (socl),
		0,
	SCR_JUMP ^ IFTRUE (MASK (CATN, CATN)),
		PADDRH (msg_parity),
	/*
	**	let the host do the real work.
	*/
	SCR_INT,
		SIR_NEGO_WIDE,
	/*
	**	let the target fetch our answer.
	*/
	SCR_SET (SCR_ATN),
		0,
	SCR_CLR (SCR_ACK),
		0,

	SCR_INT ^ IFFALSE (WHEN (SCR_MSG_OUT)),
		SIR_NEGO_PROTO,
	/*
	**	Send the M_X_WIDE_REQ
	*/
	SCR_MOVE_ABS (4) ^ SCR_MSG_OUT,
		NADDR (msgout),
	SCR_CLR (SCR_ATN),
		0,
	SCR_COPY (1),
		RADDR (sfbr),
		NADDR (lastmsg),
	SCR_JUMP,
		PADDR (msg_out_done),

}/*-------------------------< MSG_EXT_3 >----------------*/,{
	SCR_CLR (SCR_ACK),
		0,
	SCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),
		PADDR (dispatch),
	/*
	**	get extended message code.
	*/
	SCR_MOVE_ABS (1) ^ SCR_MSG_IN,
		NADDR (msgin[2]),
	/*
	**	Check for message parity error.
	*/
	SCR_TO_REG (scratcha),
		0,
	SCR_FROM_REG (socl),
		0,
	SCR_JUMP ^ IFTRUE (MASK (CATN, CATN)),
		PADDRH (msg_parity),
	SCR_FROM_REG (scratcha),
		0,
	SCR_JUMP ^ IFTRUE (DATA (M_X_SYNC_REQ)),
		PADDRH (msg_sdtr),
	/*
	**	unknown extended message
	*/
	SCR_JUMP,
		PADDR (msg_bad)

}/*-------------------------< MSG_SDTR >-----------------*/,{
	SCR_CLR (SCR_ACK),
		0,
	SCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),
		PADDR (dispatch),
	/*
	**	get period and offset
	*/
	SCR_MOVE_ABS (2) ^ SCR_MSG_IN,
		NADDR (msgin[3]),
	SCR_FROM_REG (socl),
		0,
	SCR_JUMP ^ IFTRUE (MASK (CATN, CATN)),
		PADDRH (msg_parity),
	/*
	**	let the host do the real work.
	*/
	SCR_INT,
		SIR_NEGO_SYNC,
	/*
	**	let the target fetch our answer.
	*/
	SCR_SET (SCR_ATN),
		0,
	SCR_CLR (SCR_ACK),
		0,

	SCR_INT ^ IFFALSE (WHEN (SCR_MSG_OUT)),
		SIR_NEGO_PROTO,
	/*
	**	Send the M_X_SYNC_REQ
	*/
	SCR_MOVE_ABS (5) ^ SCR_MSG_OUT,
		NADDR (msgout),
	SCR_CLR (SCR_ATN),
		0,
	SCR_COPY (1),
		RADDR (sfbr),
		NADDR (lastmsg),
	SCR_JUMP,
		PADDR (msg_out_done),

}/*-------------------------< MSG_OUT_ABORT >-------------*/,{
	/*
	**	After ABORT message,
	**
	**	expect an immediate disconnect, ...
	*/
	SCR_REG_REG (scntl2, SCR_AND, 0x7f),
		0,
	SCR_CLR (SCR_ACK|SCR_ATN),
		0,
	SCR_WAIT_DISC,
		0,
	/*
	**	... and set the status to "ABORTED"
	*/
	SCR_LOAD_REG (HS_REG, HS_ABORTED),
		0,
	SCR_JUMP,
		PADDR (cleanup),

}/*-------------------------< GETCC >-----------------------*/,{
	/*
	**	The ncr doesn't have an indirect load
	**	or store command. So we have to
	**	copy part of the control block to a
	**	fixed place, where we can modify it.
	**
	**	We patch the address part of a COPY command
	**	with the address of the dsa register ...
	*/
	SCR_COPY_F (4),
		RADDR (dsa),
		PADDRH (getcc1),
	/*
	**	... then we do the actual copy.
	*/
	SCR_COPY (sizeof (struct head)),
}/*-------------------------< GETCC1 >----------------------*/,{
		0,
		NADDR (header),
	/*
	**	Initialize the status registers
	*/
	SCR_COPY (4),
		NADDR (header.status),
		RADDR (scr0),
}/*-------------------------< GETCC2 >----------------------*/,{
	/*
	**	Get the condition code from a target.
	**
	**	DSA points to a data structure.
	**	Set TEMP to the script location
	**	that receives the condition code.
	**
	**	Because there is no script command
	**	to load a longword into a register,
	**	we use a CALL command.
	*/
/*<<<*/	SCR_CALLR,
		24,
	/*
	**	Get the condition code.
	*/
	SCR_MOVE_TBL ^ SCR_DATA_IN,
		offsetof (struct dsb, sense),
	/*
	**	No data phase may follow!
	*/
	SCR_CALL,
		PADDR (checkatn),
	SCR_JUMP,
		PADDR (no_data),
/*>>>*/

	/*
	**	The CALL jumps to this point.
	**	Prepare for a RESTORE_POINTER message.
	**	Save the TEMP register into the saved pointer.
	*/
	SCR_COPY (4),
		RADDR (temp),
		NADDR (header.savep),
	/*
	**	Load scratcha, because in case of a selection timeout,
	**	the host will expect a new value for startpos in
	**	the scratcha register.
	*/
	SCR_COPY (4),
		PADDR (startpos),
		RADDR (scratcha),
#ifdef NCR_GETCC_WITHMSG
	/*
	**	If QUIRK_NOMSG is set, select without ATN.
	**	and don't send a message.
	*/
	SCR_FROM_REG (QU_REG),
		0,
	SCR_JUMP ^ IFTRUE (MASK (QUIRK_NOMSG, QUIRK_NOMSG)),
		PADDRH(getcc3),
	/*
	**	Then try to connect to the target.
	**	If we are reselected, special treatment
	**	of the current job is required before
	**	accepting the reselection.
	*/
	SCR_SEL_TBL_ATN ^ offsetof (struct dsb, select),
		PADDR(badgetcc),
	/*
	**	Send the IDENTIFY message.
	**	In case of short transfer, remove ATN.
	*/
	SCR_MOVE_TBL ^ SCR_MSG_OUT,
		offsetof (struct dsb, smsg2),
	SCR_CLR (SCR_ATN),
		0,
	/*
	**	save the first byte of the message.
	*/
	SCR_COPY (1),
		RADDR (sfbr),
		NADDR (lastmsg),
	SCR_JUMP,
		PADDR (prepare2),

#endif
}/*-------------------------< GETCC3 >----------------------*/,{
	/*
	**	Try to connect to the target.
	**	If we are reselected, special treatment
	**	of the current job is required before
	**	accepting the reselection.
	**
	**	Silly target won't accept a message.
	**	Select without ATN.
	*/
	SCR_SEL_TBL ^ offsetof (struct dsb, select),
		PADDR(badgetcc),
	/*
	**	Force error if selection timeout
	*/
	SCR_JUMPR ^ IFTRUE (WHEN (SCR_MSG_IN)),
		0,
	/*
	**	don't negotiate.
	*/
	SCR_JUMP,
		PADDR (prepare2),
}/*-------------------------< ABORTTAG >-------------------*/,{
	/*
	**      Abort a bad reselection.
	**	Set the message to ABORT vs. ABORT_TAG
	*/
	SCR_LOAD_REG (scratcha, M_ABORT_TAG),
		0,
	SCR_JUMPR ^ IFFALSE (CARRYSET),
		8,
}/*-------------------------< ABORT >----------------------*/,{
	SCR_LOAD_REG (scratcha, M_ABORT),
		0,
	SCR_COPY (1),
		RADDR (scratcha),
		NADDR (msgout),
	SCR_SET (SCR_ATN),
		0,
	SCR_CLR (SCR_ACK),
		0,
	/*
	**	and send it.
	**	we expect an immediate disconnect
	*/
	SCR_REG_REG (scntl2, SCR_AND, 0x7f),
		0,
	SCR_MOVE_ABS (1) ^ SCR_MSG_OUT,
		NADDR (msgout),
	SCR_COPY (1),
		RADDR (sfbr),
		NADDR (lastmsg),
	SCR_CLR (SCR_ACK|SCR_ATN),
		0,
	SCR_WAIT_DISC,
		0,
	SCR_JUMP,
		PADDR (start),
}/*-------------------------< SNOOPTEST >-------------------*/,{
	/*
	**	Read the variable.
	*/
	SCR_COPY (4),
		KVAR (KVAR_NCR_CACHE),
		RADDR (scratcha),
	/*
	**	Write the variable.
	*/
	SCR_COPY (4),
		RADDR (temp),
		KVAR (KVAR_NCR_CACHE),
	/*
	**	Read back the variable.
	*/
	SCR_COPY (4),
		KVAR (KVAR_NCR_CACHE),
		RADDR (temp),
}/*-------------------------< SNOOPEND >-------------------*/,{
	/*
	**	And stop.
	*/
	SCR_INT,
		99,
}/*--------------------------------------------------------*/
};


/*==========================================================
**
**
**	Fill in #define dependent parts of the script
**
**
**==========================================================
*/

void ncr_script_fill (struct script * scr, struct scripth * scrh)
{
	int	i;
	ncrcmd	*p;

	p = scrh->tryloop;
	for (i=0; i<MAX_START; i++) {
		*p++ =SCR_COPY (4);
		*p++ =NADDR (squeue[i]);
		*p++ =RADDR (dsa);
		*p++ =SCR_CALL;
		*p++ =PADDR (trysel);
	};
	*p++ =SCR_JUMP;
	*p++ =PADDRH(tryloop);

	assert ((u_long)p == (u_long)&scrh->tryloop + sizeof (scrh->tryloop));

	p = scr->data_in;

	*p++ =SCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_IN));
	*p++ =PADDR (no_data);
	*p++ =SCR_COPY (sizeof (struct timeval));
	*p++ =(ncrcmd) KVAR (KVAR_TIME);
	*p++ =NADDR (header.stamp.data);
	*p++ =SCR_MOVE_TBL ^ SCR_DATA_IN;
	*p++ =offsetof (struct dsb, data[ 0]);

	for (i=1; i<MAX_SCATTER; i++) {
		*p++ =SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN));
		*p++ =PADDR (checkatn);
		*p++ =SCR_MOVE_TBL ^ SCR_DATA_IN;
		*p++ =offsetof (struct dsb, data[i]);
	};

	*p++ =SCR_CALL;
	*p++ =PADDR (checkatn);
	*p++ =SCR_JUMP;
	*p++ =PADDR (no_data);

	assert ((u_long)p == (u_long)&scr->data_in + sizeof (scr->data_in));

	p = scr->data_out;

	*p++ =SCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_OUT));
	*p++ =PADDR (no_data);
	*p++ =SCR_COPY (sizeof (struct timeval));
	*p++ =(ncrcmd) KVAR (KVAR_TIME);
	*p++ =NADDR (header.stamp.data);
	*p++ =SCR_MOVE_TBL ^ SCR_DATA_OUT;
	*p++ =offsetof (struct dsb, data[ 0]);

	for (i=1; i<MAX_SCATTER; i++) {
		*p++ =SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT));
		*p++ =PADDR (dispatch);
		*p++ =SCR_MOVE_TBL ^ SCR_DATA_OUT;
		*p++ =offsetof (struct dsb, data[i]);
	};

	*p++ =SCR_CALL;
	*p++ =PADDR (dispatch);
	*p++ =SCR_JUMP;
	*p++ =PADDR (no_data);

	assert ((u_long)p == (u_long)&scr->data_out + sizeof (scr->data_out));
}

/*==========================================================
**
**
**	Copy and rebind a script.
**
**
**==========================================================
*/

static void ncr_script_copy_and_bind (ncb_p np, ncrcmd *src, ncrcmd *dst, int len)
{
	ncrcmd  opcode, new, old, tmp1, tmp2;
	ncrcmd	*start, *end;
	int relocs, offset;

	start = src;
	end = src + len/4;
	offset = 0;

	while (src < end) {

		opcode = *src++;
		WRITESCRIPT_OFF(dst, offset, opcode);
		offset += 4;

		/*
		**	If we forget to change the length
		**	in struct script, a field will be
		**	padded with 0. This is an illegal
		**	command.
		*/

		if (opcode == 0) {
			printf ("%s: ERROR0 IN SCRIPT at %ld.\n",
				ncr_name(np), (long)(src-start-1));
			DELAY (1000000);
		};

		if (DEBUG_FLAGS & DEBUG_SCRIPT)
			printf ("%p:  <%x>\n",
				(src-1), (unsigned)opcode);

		/*
		**	We don't have to decode ALL commands
		*/
		switch (opcode >> 28) {

		case 0xc:
			/*
			**	COPY has TWO arguments.
			*/
			relocs = 2;
			tmp1 = src[0];
			if ((tmp1 & RELOC_MASK) == RELOC_KVAR)
				tmp1 = 0;
			tmp2 = src[1];
			if ((tmp2 & RELOC_MASK) == RELOC_KVAR)
				tmp2 = 0;
			if ((tmp1 ^ tmp2) & 3) {
				printf ("%s: ERROR1 IN SCRIPT at %ld.\n",
					ncr_name(np), (long)(src-start-1));
				DELAY (1000000);
			}
			/*
			**	If PREFETCH feature not enabled, remove
			**	the NO FLUSH bit if present.
			*/
			if ((opcode & SCR_NO_FLUSH) && !(np->features&FE_PFEN))
				WRITESCRIPT_OFF(dst, offset - 4,
				    (opcode & ~SCR_NO_FLUSH));
			break;

		case 0x0:
			/*
			**	MOVE (absolute address)
			*/
			relocs = 1;
			break;

		case 0x8:
			/*
			**	JUMP / CALL
			**	dont't relocate if relative :-)
			*/
			if (opcode & 0x00800000)
				relocs = 0;
			else
				relocs = 1;
			break;

		case 0x4:
		case 0x5:
		case 0x6:
		case 0x7:
			relocs = 1;
			break;

		default:
			relocs = 0;
			break;
		};

		if (relocs) {
			while (relocs--) {
				old = *src++;

				switch (old & RELOC_MASK) {
				case RELOC_REGISTER:
					new = (old & ~RELOC_MASK) + np->paddr;
					break;
				case RELOC_LABEL:
					new = (old & ~RELOC_MASK) + np->p_script;
					break;
				case RELOC_LABELH:
					new = (old & ~RELOC_MASK) + np->p_scripth;
					break;
				case RELOC_SOFTC:
					new = (old & ~RELOC_MASK) + NCR_KVATOPHYS(np, np);
					break;
				case RELOC_KVAR:
					if (((old & ~RELOC_MASK) <
					     SCRIPT_KVAR_FIRST) ||
					    ((old & ~RELOC_MASK) >
					     SCRIPT_KVAR_LAST))
						panic("ncr KVAR out of range");
					new = NCR_KVATOPHYS(np, (void *)script_kvars[old &
					    ~RELOC_MASK]);
					break;
				case 0:
					/* Don't relocate a 0 address. */
					if (old == 0) {
						new = old;
						break;
					}
					/* fall through */
				default:
					panic("ncr_script_copy_and_bind: weird relocation %x @@ %ld", old, (long)(src - start));
					break;
				}

				WRITESCRIPT_OFF(dst, offset, new);
				offset += 4;
			}
		} else {
			WRITESCRIPT_OFF(dst, offset, *src);
			offset += 4;
			src++;
		}

	};
}

/*==========================================================
**
**
**      Auto configuration.
**
**
**==========================================================
*/

/*----------------------------------------------------------
**
**	Reduce the transfer length to the max value
**	we can transfer safely.
**
**      Reading a block greater then MAX_SIZE from the
**	raw (character) device exercises a memory leak
**	in the vm subsystem. This is common to ALL devices.
**	We have submitted a description of this bug to
**	<FreeBSD-bugs@@freefall.cdrom.com>.
**	It should be fixed in the current release.
**
**----------------------------------------------------------
*/

#ifndef __OpenBSD__
void ncr_min_phys (struct  buf *bp)
{
	if ((unsigned long)bp->b_bcount > MAX_SIZE) bp->b_bcount = MAX_SIZE;
}
#else
void ncr_min_phys (struct buf *bp)
{
	if (bp->b_bcount > MAX_SIZE)
		bp->b_bcount = MAX_SIZE;
	minphys(bp);
}
#endif

/*----------------------------------------------------------
**
**	Maximal number of outstanding requests per target.
**
**----------------------------------------------------------
*/

#ifndef __OpenBSD__
u_int32_t ncr_info (int unit)
{
	return (1);   /* may be changed later */
}
#endif

/*----------------------------------------------------------
**
**	NCR chip devices table and chip look up function.
**	Features bit are defined in ncrreg.h. Is it the
**	right place?
**
**----------------------------------------------------------
*/
typedef struct {
	unsigned long	device_id;
	unsigned short	minrevid;
	unsigned char	maxburst;
	unsigned char	maxoffs;
	unsigned char	clock_divn;
	unsigned int	features;
} ncr_chip;

static ncr_chip ncr_chip_table[] = {
 {NCR_810_ID, 0x00,	4,  8, 4,
 FE_ERL}
 ,
 {NCR_810_ID, 0x10,	4,  8, 4,
 FE_ERL|FE_LDSTR|FE_PFEN|FE_BOF}
 ,
 {NCR_815_ID, 0x00,	4,  8, 4,
 FE_ERL|FE_BOF}
 ,
 {NCR_820_ID, 0x00,	4,  8, 4,
 FE_WIDE|FE_ERL}
 ,
 {NCR_825_ID, 0x00,	4,  8, 4,
 FE_WIDE|FE_ERL|FE_BOF}
 ,
 {NCR_825_ID, 0x10,	7,  8, 4,
 FE_WIDE|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}
 ,
 {NCR_860_ID, 0x00,	4,  8, 5,
 FE_ULTRA|FE_CLK80|FE_CACHE_SET|FE_LDSTR|FE_PFEN}
 ,
 {NCR_875_ID, 0x00,	7, 16, 5,
 FE_WIDE|FE_ULTRA|FE_CLK80|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}
 ,
 {NCR_875_ID, 0x02,	7, 16, 5,
 FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}
 ,
#ifdef NCR_NARROW_875J
 {NCR_875_ID2, 0x00,	4,  8, 5,
 FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}
#else
 {NCR_875_ID2, 0x00,	7, 16, 5,
 FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}
#endif
 ,
 {NCR_885_ID, 0x00,	7, 16, 5,
 FE_WIDE|FE_ULTRA|FE_DBLR|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}
 ,
 {NCR_895_ID, 0x00,	7, 31, 7,
 FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}
 ,
 {NCR_895A_ID, 0x00,	7, 31, 7,
 FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}
 ,
 {NCR_896_ID, 0x00,	7, 31, 7,
 FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}
 ,
 {NCR_1510_ID, 0x00,	7, 31, 7,
 FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}
 ,
 {NCR_1510D_ID, 0x00,	7, 31, 7,
 FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}
};

static int ncr_chip_lookup(u_long device_id, u_char revision_id)
{
	int i, found;
	
	found = -1;
	for (i = 0; i < sizeof(ncr_chip_table)/sizeof(ncr_chip_table[0]); i++) {
		if (device_id	== ncr_chip_table[i].device_id &&
		    ncr_chip_table[i].minrevid <= revision_id) {
			if (found < 0 ||
			    ncr_chip_table[found].minrevid
			      < ncr_chip_table[i].minrevid) {
				found = i;
			}
		}
	}
	return found;
}

/*----------------------------------------------------------
**
**	Probe the hostadapter.
**
**----------------------------------------------------------
*/

#ifdef __OpenBSD__

int
ncr_probe(parent, match, aux)
	struct device *parent;
#ifdef __BROKEN_INDIRECT_CONFIG
	void *match;
#else
	struct cfdata *match;
#endif
	void *aux;
{
	struct pci_attach_args * const pa = aux;
	u_char rev = PCI_REVISION(pa->pa_class);
#if 0
	struct cfdata *cf = match;

	if (!pci_targmatch(cf, pa))
		return 0;
#endif
	if (ncr_chip_lookup(pa->pa_id, rev) < 0)
		return 0;

	return 1;
}

#else /* !__OpenBSD__ */


static	char *ncr_probe (pcici_t tag, pcidi_t type)
{
	u_char rev = PCI_REVISION(pa->pa_class);
	int i;

	i = ncr_chip_lookup(type, rev);
	if (i >= 0)
		return ncr_chip_table[i].name;

	return (NULL);
}

#endif /* !__OpenBSD__ */


/*==========================================================
**
**	NCR chip clock divisor table.
**	Divisors are multiplied by 10,000,000 in order to make
**	calculations more simple.
**
**==========================================================
*/

#define _5M 5000000
static u_long div_10M[] =
	{2*_5M, 3*_5M, 4*_5M, 6*_5M, 8*_5M, 12*_5M, 16*_5M};

/*===============================================================
**
**	NCR chips allow burst lengths of 2, 4, 8, 16, 32, 64, 128
**	transfers. 32,64,128 are only supported by 875 and 895 chips.
**	We use log base 2 (burst length) as internal code, with
**	value 0 meaning "burst disabled".
**
**===============================================================
*/

/*
 *	Burst length from burst code.
 */
#define burst_length(bc) (!(bc))? 0 : 1 << (bc)

/*
 *	Burst code from io register bits.
 */
#define burst_code(dmode, ctest4, ctest5) \
	(ctest4) & 0x80? 0 : (((dmode) & 0xc0) >> 6) + ((ctest5) & 0x04) + 1

/*
 *	Set initial io register bits from burst code.
 */
static void ncr_init_burst(ncb_p np, u_char bc)
{
	np->rv_ctest4	&= ~0x80;
	np->rv_dmode	&= ~(0x3 << 6);
	np->rv_ctest5	&= ~0x4;

	if (!bc) {
		np->rv_ctest4	|= 0x80;
	}
	else {
		--bc;
		np->rv_dmode	|= ((bc & 0x3) << 6);
		np->rv_ctest5	|= (bc & 0x4);
	}
}

/*==========================================================
**
**
**      Auto configuration:  attach and init a host adapter.
**
**
**==========================================================
*/

#ifdef __OpenBSD__
void
ncr_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	int retval;
	pci_intr_handle_t intrhandle;
	const char *intrstr;
	ncb_p np = (void *)self;
	u_long	period;
	int	i;
	u_char rev = PCI_REVISION(pa->pa_class);
	bus_space_tag_t iot, memt;
	bus_space_handle_t ioh, memh;
	bus_addr_t ioaddr, memaddr;
	int ioh_valid, memh_valid;
	char *type;

#if defined(__mips__)
	pci_sync_cache(pc, (vm_offset_t)np, sizeof (struct ncb));
	np = (struct ncb *)PHYS_TO_UNCACHED(NCR_KVATOPHYS(np, np));
#endif /*__mips__*/

	np->sc_pc = pc;
	np->ccb = (ccb_p) malloc (sizeof (struct ccb), M_DEVBUF, M_NOWAIT);
	if (np->ccb == NULL)
		return;
#if defined(__mips__)
	pci_sync_cache(pc, (vm_offset_t)np->ccb, sizeof (struct ccb));
	np->ccb = (struct ccb *)PHYS_TO_UNCACHED(NCR_KVATOPHYS(np, np->ccb));
#endif /* __mips__ */
	bzero (np->ccb, sizeof (*np->ccb));

	/*
	**	Try to map the controller chip to
	**	virtual and physical memory.
	*/

	ioh_valid = (pci_mapreg_map(pa, 0x10, PCI_MAPREG_TYPE_IO, 0,
	    &iot, &ioh, &ioaddr, NULL, 0) == 0);
	memh_valid = (pci_mapreg_map(pa, 0x14,
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,
	    &memt, &memh, &memaddr, NULL, 0) == 0);

#if defined(NCR_IOMAPPED)
	if (ioh_valid) {
		np->sc_st = iot;
		np->sc_sh = ioh;
		np->paddr = ioaddr;
		np->sc_iomapped = 1;
	} else if (memh_valid) {
		np->sc_st = memt;
		np->sc_sh = memh;
		np->paddr = memaddr;
		np->sc_iomapped = 0;
	}
#else /* defined(NCR_IOMAPPED) */
	if (memh_valid) {
		np->sc_st = memt;
		np->sc_sh = memh;
		np->paddr = memaddr;
		np->sc_iomapped = 0;
	} else if (ioh_valid) {
		np->sc_st = iot;
		np->sc_sh = ioh;
		np->paddr = ioaddr;
		np->sc_iomapped = 1;
	}
#endif /* defined(NCR_IOMAPPED) */
	else {
		printf(": unable to map device registers\n");
		return;
	}

	/*
	**	Set up the controller chip's interrupt.
	*/
	retval = pci_intr_map(pa, &intrhandle);
	if (retval) {
		printf(": couldn't map interrupt\n");
		return;
	}
	intrstr = pci_intr_string(pc, intrhandle);
	np->sc_ih = pci_intr_establish(pc, intrhandle, IPL_BIO,
	    ncr_intr, np, self->dv_xname);
	if (np->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}

	i = ncr_chip_lookup(pa->pa_id, rev);
	if (ncr_chip_table[i].features & FE_ULTRA2)
		type = "ultra2";
	else if (ncr_chip_table[i].features & FE_ULTRA)
		type = "ultra";
	else
		type = "fast";
	if (intrstr != NULL)
		printf(": %s%s scsi, %s\n", type,
		    (ncr_chip_table[i].features & FE_WIDE) ? " wide" : "",
		    intrstr);
	else
		printf(": %s%s scsi\n", type,
		    (ncr_chip_table[i].features & FE_WIDE) ? " wide" : "");

#else /* !__OpenBSD__ */

static	void ncr_attach (pcici_t config_id, int unit)
{
	ncb_p np = (struct ncb*) 0;
#if ! (__FreeBSD__ >= 2)
	extern unsigned bio_imask;
#endif

#if (__FreeBSD__ >= 2)
	struct scsibus_data *scbus;
#endif
	u_char	rev = 0;
	u_long	period;
	int	i;

	/*
	**	allocate and initialize structures.
	*/

	if (!np) {
		np = (ncb_p) malloc (sizeof (struct ncb), M_DEVBUF, M_WAITOK);
		ncrp[unit]=np;
	}
	bzero (np, sizeof (*np));

	np->ccb = (ccb_p) malloc (sizeof (struct ccb), M_DEVBUF, M_WAITOK);
#if defined(__mips__)
	pci_sync_cache(pc, (vm_offset_t)np->ccb, sizeof (struct ccb));
	np->ccb = (struct ccb *)PHYS_TO_UNCACHED(NCR_KVATOPHYS(np, np->ccb));
#endif /* __mips__ */
	bzero (np->ccb, sizeof (*np->ccb));

	np->unit = unit;

	/*
	**	Try to map the controller chip to
	**	virtual and physical memory.
	*/

	if (!pci_map_mem (config_id, 0x14, &np->vaddr, &np->paddr))
		return;

	/*
	**	Make the controller's registers available.
	**	Now the INB INW INL OUTB OUTW OUTL macros
	**	can be used safely.
	*/

	np->reg = (struct ncr_reg*) np->vaddr;

#ifdef NCR_IOMAPPED
	/*
	**	Try to map the controller chip into iospace.
	*/

	if (!pci_map_port (config_id, 0x10, &np->port))
		return;
#endif

#endif /* !__OpenBSD__ */

	/*
	**	Save some controller register default values
	*/

	np->rv_scntl3	= INB(nc_scntl3) & 0x77;
	np->rv_dmode	= INB(nc_dmode)  & 0xce;
	np->rv_dcntl	= INB(nc_dcntl)  & 0xa9;
	np->rv_ctest3	= INB(nc_ctest3) & 0x01;
	np->rv_ctest4	= INB(nc_ctest4) & 0x88;
	np->rv_ctest5	= INB(nc_ctest5) & 0x24;
	np->rv_gpcntl	= INB(nc_gpcntl);
	np->rv_stest2	= INB(nc_stest2) & 0x20;

	if (bootverbose >= 2) {
		printf ("\tBIOS values:  SCNTL3:%02x DMODE:%02x  DCNTL:%02x\n",
			np->rv_scntl3, np->rv_dmode, np->rv_dcntl);
		printf ("\t              CTEST3:%02x CTEST4:%02x CTEST5:%02x\n",
			np->rv_ctest3, np->rv_ctest4, np->rv_ctest5);
	}

	np->rv_dcntl  |= NOCOM;

	/*
	**	Do chip dependent initialization.
	*/

#ifndef __OpenBSD__
	rev = pci_conf_read (config_id, PCI_CLASS_REG) & 0xff;
#endif /* !__OpenBSD__ */

	/*
	**	Get chip features from chips table.
	*/
#ifndef __OpenBSD__
	i = ncr_chip_lookup(pci_conf_read(config_id, PCI_ID_REG), rev);
#endif /* !__OpenBSD__ */

	if (i >= 0) {
		np->maxburst	= ncr_chip_table[i].maxburst;
		np->maxoffs	= ncr_chip_table[i].maxoffs;
		np->clock_divn	= ncr_chip_table[i].clock_divn;
		np->features	= ncr_chip_table[i].features;
	} else {	/* Should'nt happen if probe() is ok */
		np->maxburst	= 4;
		np->maxoffs	= 8;
		np->clock_divn	= 4;
		np->features	= FE_ERL;
	}

	np->maxwide	= np->features & FE_WIDE ? 1 : 0;
#ifdef NEED_PCI_SCSI_CLOCK_FUNC
	{
	int b, d, f; 
        pci_decompose_tag(pc, pa->pa_tag, &b, &d, &f); \
	if((np->clock_khz = pci_scsi_clock(pc, b, d)) == 0)
		np->clock_khz	= np->features & FE_CLK80 ? 80000 : 40000;
	}
#else
	np->clock_khz	= np->features & FE_CLK80 ? 80000 : 40000;
#endif
	if	(np->features & FE_QUAD)	np->multiplier = 4;
	else if	(np->features & FE_DBLR)	np->multiplier = 2;
	else					np->multiplier = 1;

	/*
	**	Get the frequency of the chip's clock.
	**	Find the right value for scntl3.
	*/
	if (np->features & (FE_ULTRA|FE_ULTRA2))
		ncr_getclock(np, np->multiplier);

#ifdef NCR_TEKRAM_EEPROM
	if (bootverbose) {
		printf ("%s: Tekram EEPROM read %s\n",
			ncr_name(np),
			read_tekram_eeprom (np, NULL) ?
			"succeeded" : "failed");
	}
#endif /* NCR_TEKRAM_EEPROM */

	/*
	 *	If scntl3 != 0, we assume BIOS is present.
	 */
	if (np->rv_scntl3)
		np->features |= FE_BIOS;

	/*
	 * Divisor to be used for async (timer pre-scaler).
	 */
	i = np->clock_divn - 1;
	while (i >= 0) {
		--i;
		if (10ul * SCSI_NCR_MIN_ASYNC * np->clock_khz > div_10M[i]) {
			++i;
			break;
		}
	}
	np->rv_scntl3 = i+1;

	/*
	 * Minimum synchronous period factor supported by the chip.
	 * Btw, 'period' is in tenths of nanoseconds.
	 */

	period = (4 * div_10M[0] + np->clock_khz - 1) / np->clock_khz;
	if	(period <= 250)		np->minsync = 10;
	else if	(period <= 303)		np->minsync = 11;
	else if	(period <= 500)		np->minsync = 12;
	else				np->minsync = (period + 40 - 1) / 40;

	/*
	 * Check against chip SCSI standard support (SCSI-2,ULTRA,ULTRA2).
	 */

	if	(np->minsync < 25 && !(np->features & (FE_ULTRA|FE_ULTRA2)))
		np->minsync = 25;
	else if	(np->minsync < 12 && !(np->features & FE_ULTRA2))
		np->minsync = 12;

	/*
	 * Maximum synchronous period factor supported by the chip.
	 */

	period = (11 * div_10M[np->clock_divn - 1]) / (4 * np->clock_khz);
	np->maxsync = period > 2540 ? 254 : period / 10;

	/*
	 * Now, some features available with Symbios compatible boards.
	 * LED support through GPIO0 and DIFF support.
	 */

#ifdef	SCSI_NCR_SYMBIOS_COMPAT
	if (!(np->rv_gpcntl & 0x01))
		np->features |= FE_LED0;
#if 0	/* Not safe enough without NVRAM support or user settable option */
	if (!(INB(nc_gpreg) & 0x08))
		np->features |= FE_DIFF;
#endif
#endif	/* SCSI_NCR_SYMBIOS_COMPAT */

	/*
	 * Prepare initial IO registers settings.
	 * Trust BIOS only if we believe we have one and if we want to.
	 */
#ifdef	SCSI_NCR_TRUST_BIOS
	if (!(np->features & FE_BIOS)) {
#else
	if (1) {
#endif
		np->rv_dmode = 0;
		np->rv_dcntl = NOCOM;
		np->rv_ctest3 = 0;
		np->rv_ctest4 = MPEE;
		np->rv_ctest5 = 0;
		np->rv_stest2 = 0;

		if (np->features & FE_ERL)
			np->rv_dmode 	|= ERL;	  /* Enable Read Line */
		if (np->features & FE_BOF)
			np->rv_dmode 	|= BOF;	  /* Burst Opcode Fetch */
		if (np->features & FE_ERMP)
			np->rv_dmode	|= ERMP;  /* Enable Read Multiple */
		if (np->features & FE_CLSE)
			np->rv_dcntl	|= CLSE;  /* Cache Line Size Enable */
		if (np->features & FE_WRIE)
			np->rv_ctest3	|= WRIE;  /* Write and Invalidate */
		if (np->features & FE_PFEN)
			np->rv_dcntl	|= PFEN;  /* Prefetch Enable */
		if (np->features & FE_DFS)
			np->rv_ctest5	|= DFS;	  /* Dma Fifo Size */
		if (np->features & FE_DIFF)	
			np->rv_stest2	|= 0x20;  /* Differential mode */
		ncr_init_burst(np, np->maxburst); /* Max dwords burst length */
	} else {
		np->maxburst =
			burst_code(np->rv_dmode, np->rv_ctest4, np->rv_ctest5);
	}

#ifndef NCR_IOMAPPED
	/*
	**	Get on-chip SRAM address, if supported
	*/
#ifdef __OpenBSD__
	if ((np->features & FE_RAM) && sizeof(struct script) <= 4096) {
		if (pci_mapreg_map(pa, 0x18,
		    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,
		    &memt, &memh, &memaddr, NULL, 0) == 0) {
			np->ram_tag = memt;
			np->ram_handle = memh;
			np->paddr2 = memaddr;
			np->scriptmapped = 1;
		} else {
			np->scriptmapped = 0;
		}
	}
#else /* !__OpenBSD__ */
	if ((np->features & FE_RAM) && sizeof(struct script) <= 4096)
		(void)(!pci_map_mem (config_id,0x18, &np->vaddr2, &np->paddr2));
#endif	/* __OpenBSD__ */
#endif	/* !NCR_IOMAPPED */

	/*
	**	Allocate structure for script relocation.
	*/
#ifdef __FreeBSD__
	if (np->vaddr2 != NULL) {
		np->script = (struct script *) np->vaddr2;
		np->p_script = np->paddr2;
	} else if (sizeof (struct script) > PAGE_SIZE) {
		np->script  = (struct script*) vm_page_alloc_contig
			(round_page(sizeof (struct script)),
			 0x100000, 0xffffffff, PAGE_SIZE);
#else
	if (ISSCRIPTRAMMAPPED(np)) {
		/*
		 * A NULL value means that the script is in the chip's
		 * on-board RAM and has no virtual address.
		 */
		np->script = NULL;
		np->p_script = np->paddr2;
#endif /* __FreeBSD__ */
	} else {
		np->script  = (struct script *)
			malloc (sizeof (struct script), M_DEVBUF, M_WAITOK);
#if defined(__mips__)
	pci_sync_cache(pc, (vm_offset_t)np->script, sizeof (struct script));
	np->script = (struct script *)PHYS_TO_UNCACHED(NCR_KVATOPHYS(np, np->script));
#endif /*__mips__*/
	}

#ifdef __FreeBSD__
	if (sizeof (struct scripth) > PAGE_SIZE) {
		np->scripth = (struct scripth*) vm_page_alloc_contig
			(round_page(sizeof (struct scripth)),
			 0x100000, 0xffffffff, PAGE_SIZE);
	} else
#endif /* __FreeBSD__ */
		{
		np->scripth = (struct scripth *)
			malloc (sizeof (struct scripth), M_DEVBUF, M_WAITOK);
#if defined(__mips__)
		pci_sync_cache(pc, (vm_offset_t)np->scripth, sizeof (struct scripth));
		np->scripth = (struct scripth *)PHYS_TO_UNCACHED(NCR_KVATOPHYS(np, np->scripth));
#endif /*__mips__*/
	}

#ifdef SCSI_NCR_PCI_CONFIG_FIXUP
	/*
	**	If cache line size is enabled, check PCI config space and
	**	try to fix it up if necessary.
	*/
#ifdef PCIR_CACHELNSZ	/* To be sure that new PCI stuff is present */
	{
		u_char cachelnsz = pci_cfgread(config_id, PCIR_CACHELNSZ, 1);
		u_short command  = pci_cfgread(config_id, PCIR_COMMAND, 2);

		if (!cachelnsz) {
			cachelnsz = 8;
			printf("%s: setting PCI cache line size register to %d.\n",
				ncr_name(np), (int)cachelnsz);
			pci_cfgwrite(config_id, PCIR_CACHELNSZ, cachelnsz, 1);
		}

		if (!(command & (1<<4))) {
			command |= (1<<4);
			printf("%s: setting PCI command write and invalidate.\n",
				ncr_name(np));
			pci_cfgwrite(config_id, PCIR_COMMAND, command, 2);
		}
	}
#endif /* PCIR_CACHELNSZ */

#endif /* SCSI_NCR_PCI_CONFIG_FIXUP */

	/*
	**	Bells and whistles   ;-)
	*/
	if (bootverbose)
		printf("%s: minsync=%d, maxsync=%d, maxoffs=%d, %d dwords burst, %s dma fifo\n",
		ncr_name(np), np->minsync, np->maxsync, np->maxoffs,
		burst_length(np->maxburst),
		(np->rv_ctest5 & DFS) ? "large" : "normal");

	/*
	**	Print some complementary information that can be helpfull.
	*/
	if (bootverbose)
		printf("%s: %s, %s IRQ driver%s\n",
			ncr_name(np),
			np->rv_stest2 & 0x20 ? "differential" : "single-ended",
			np->rv_dcntl & IRQM ? "totem pole" : "open drain",
			ISSCRIPTRAMMAPPED(np) ? ", using on-chip SRAM" : "");
			
	/*
	**	Patch scripts to physical addresses
	*/
	ncr_script_fill (&script0, &scripth0);

	if (np->script)
		np->p_script = NCR_KVATOPHYS(np, np->script);
	np->p_scripth	= NCR_KVATOPHYS(np, np->scripth);

	ncr_script_copy_and_bind (np, (ncrcmd *) &script0,
			(ncrcmd *) np->script, sizeof(struct script));

	ncr_script_copy_and_bind (np, (ncrcmd *) &scripth0,
		(ncrcmd *) np->scripth, sizeof(struct scripth));

	np->ccb->p_ccb	= NCR_KVATOPHYS (np, np->ccb);

	/*
	**    Patch the script for LED support.
	*/

	if (np->features & FE_LED0) {
		WRITESCRIPT(reselect[0],  SCR_REG_REG(gpreg, SCR_OR,  0x01));
		WRITESCRIPT(reselect1[0], SCR_REG_REG(gpreg, SCR_AND, 0xfe));
		WRITESCRIPT(reselect2[0], SCR_REG_REG(gpreg, SCR_AND, 0xfe));
	}

	/*
	**	init data structure
	*/

	np->jump_tcb.l_cmd	= SCR_BO(SCR_JUMP);
	np->jump_tcb.l_paddr	= SCR_BO(NCB_SCRIPTH_PHYS (np, abort));

	/*
	**  Get SCSI addr of host adapter (set by bios?).
	*/

	np->myaddr = INB(nc_scid) & 0x07;
	if (!np->myaddr) np->myaddr = SCSI_NCR_MYADDR;

#ifdef NCR_DUMP_REG
	/*
	**	Log the initial register contents
	*/
	{
		int reg;
#ifdef __OpenBSD__
		u_long config_id = pa->pa_tag;
#endif /* __OpenBSD__ */
		for (reg=0; reg<256; reg+=4) {
			if (reg%16==0) printf ("reg[%2x]", reg);
			printf (" %08x", (int)pci_conf_read (config_id, reg));
			if (reg%16==12) printf ("\n");
		}
	}
#endif /* NCR_DUMP_REG */

	/*
	**	Reset chip.
	*/

	OUTB (nc_istat,  SRST);
	DELAY (1000);
	OUTB (nc_istat,  0   );


	/*
	**	Now check the cache handling of the pci chipset.
	*/

	if (ncr_snooptest (np)) {
		printf ("CACHE INCORRECTLY CONFIGURED.\n");
		return;
	};

#ifndef __OpenBSD__
	/*
	**	Install the interrupt handler.
	*/

	if (!pci_map_int (config_id, ncr_intr, np, &bio_imask))
		printf ("\tinterruptless mode: reduced performance.\n");
#endif /* !__OpenBSD__ */

	/*
	**	After SCSI devices have been opened, we cannot
	**	reset the bus safely, so we do it here.
	**	Interrupt handler does the real work.
	*/

	OUTB (nc_scntl1, CRST);
	DELAY (1000);

	/*
	**	Process the reset exception,
	**	if interrupts are not enabled yet.
	**	Then enable disconnects.
	*/
	ncr_exception (np);
	np->disc = 1;

	/*
	**	Now let the generic SCSI driver
	**	look for the SCSI devices on the bus ..
	*/

#ifdef __OpenBSD__
	np->sc_link.adapter_softc = np;
	np->sc_link.adapter_target = np->myaddr;
	np->sc_link.openings = 1;
	if (np->maxwide)
		np->sc_link.adapter_buswidth = MAX_TARGET;
#else /* !__OpenBSD__ */
	np->sc_link.adapter_unit = unit;
	np->sc_link.adapter_softc = np;
	np->sc_link.adapter_targ = np->myaddr;
	np->sc_link.fordriver	 = 0;
#endif /* !__OpenBSD__ */
	np->sc_link.adapter      = &ncr_switch;
	np->sc_link.device       = &ncr_dev;
	np->sc_link.flags	 = 0;

#ifdef __OpenBSD__
	config_found(self, &np->sc_link, scsiprint);
#else /* !__OpenBSD__ */
#if (__FreeBSD__ >= 2)
	scbus = scsi_alloc_bus();
	if(!scbus)
		return;
	scbus->adapter_link = &np->sc_link;

	if(np->maxwide)
		scbus->maxtarg = 15;

	if (bootverbose) {
		unsigned t_from = 0;
		unsigned t_to   = scbus->maxtarg;
		unsigned myaddr = np->myaddr;

		char *txt_and = "";
		printf ("%s scanning for targets ", ncr_name (np));
		if (t_from < myaddr) {
			printf ("%d..%d ", t_from, myaddr -1);
			txt_and = "and ";
		}
		if (myaddr < t_to)
			printf ("%s%d..%d ", txt_and, myaddr +1, t_to);
		printf ("(V%d " NCR_DATE ")\n", NCR_VERSION);
	}
		
	scsi_attachdevs (scbus);
	scbus = NULL;   /* Upper-level SCSI code owns this now */
#else
	scsi_attachdevs (&np->sc_link);
#endif /* !__FreeBSD__ >= 2 */
#endif /* !__OpenBSD__ */

	/*
	**	start the timeout daemon
	*/
	timeout_set(&np->sc_timeout, ncr_timeout, np);
	ncr_timeout (np);
	np->lasttime=0;

	/*
	**  use SIMPLE TAG messages by default
	*/

	np->order = M_SIMPLE_TAG;

	/*
	**  Done.
	*/

	return;
}

/*==========================================================
**
**
**	Process pending device interrupts.
**
**
**==========================================================
*/

#ifdef __OpenBSD__
static int
#else /* !__OpenBSD__ */
static void
#endif /* __OpenBSD__ */
ncr_intr(vnp)
	void *vnp;
{
#ifdef __OpenBSD__
	int n = 0;
#endif
	ncb_p np = vnp;
	int oldspl = splbio();

	if (DEBUG_FLAGS & DEBUG_TINY) printf ("[");

	if (INB(nc_istat) & (INTF|SIP|DIP)) {
		/*
		**	Repeat until no outstanding ints
		*/
		do {
			ncr_exception (np);
		} while (INB(nc_istat) & (INTF|SIP|DIP));

#ifdef __OpenBSD__
		n=1;
#endif
		np->ticks = 100;
	};

	if (DEBUG_FLAGS & DEBUG_TINY) printf ("]\n");

	splx (oldspl);
#ifdef __OpenBSD__
	return (n);
#endif
}

/*==========================================================
**
**
**	Start execution of a SCSI command.
**	This is called from the generic SCSI driver.
**
**
**==========================================================
*/

static int32_t ncr_start (struct scsi_xfer * xp)
{
	ncb_p np  = (ncb_p) xp->sc_link->adapter_softc;

	struct scsi_generic * cmd = (struct scsi_generic *)xp->cmd;
	ccb_p cp;
	lcb_p lp;
	tcb_p tp = &np->target[xp->sc_link->target];

	int	i, oldspl, segments, flags = xp->flags, pollmode;
	u_char	qidx, nego, idmsg, *msgptr;
	u_long  msglen, msglen2;

	/*---------------------------------------------
	**
	**   Reset SCSI bus
	**
	**	Interrupt handler does the real work.
	**
	**---------------------------------------------
	*/

	if (flags & SCSI_RESET) {
		OUTB (nc_scntl1, CRST);
		DELAY (1000);
		return(COMPLETE);
	};

	/*---------------------------------------------
	**
	**      Some shortcuts ...
	**
	**---------------------------------------------
	*/

	if ((xp->sc_link->target == np->myaddr	  ) ||
		(xp->sc_link->target >= MAX_TARGET) ||
		(xp->sc_link->lun    >= MAX_LUN   ) ||
		(flags    & SCSI_DATA_UIO)) {
		xp->error = XS_DRIVER_STUFFUP;
		return(COMPLETE);
	};

	/*---------------------------------------------
	**
	**      Diskaccess to partial blocks?
	**
	**---------------------------------------------
	*/

	if ((xp->datalen & 0x1ff) && !(tp->inqdata[0] & 0x1f)) {
		switch (cmd->opcode) {
		case 0x28:  /* READ_BIG  (10) */
		case 0xa8:  /* READ_HUGE (12) */
		case 0x2a:  /* WRITE_BIG (10) */
		case 0xaa:  /* WRITE_HUGE(12) */
			PRINT_ADDR(xp);
			printf ("access to partial disk block refused.\n");
			xp->error = XS_DRIVER_STUFFUP;
			return(COMPLETE);
		};
	};

	if ((unsigned)xp->datalen > 128*1024*1024) {
		PRINT_ADDR(xp);
		printf ("trying to transfer %8x bytes, mem addr = %p\n",
			xp->datalen, xp->data);
		{
			int j;
			PRINT_ADDR(xp);
			printf ("command: %2x (", cmd->opcode);
			for (j = 0; j<11; j++)
				printf (" %2x", cmd->bytes[j]);
			printf (")\n");
		}
	}

	if (DEBUG_FLAGS & DEBUG_TINY) {
		PRINT_ADDR(xp);
		printf ("CMD=%x F=%x A=%p L=%x ",
			cmd->opcode, (unsigned)xp->flags, xp->data,
			(unsigned)xp->datalen);
	}

	/*--------------------------------------------
	**
	**   Sanity checks ...
	**	copied from Elischer's Adaptec driver.
	**
	**--------------------------------------------
	*/

	flags = xp->flags;
	if(flags & ITSDONE) {
		printf("%s: ?ITSDONE?\n", ncr_name (np));
		xp->flags &= ~ITSDONE;
	};

	if (xp->bp)
		flags |= (SCSI_NOSLEEP); /* just to be sure */

	/*---------------------------------------------------
	**
	**	Assign a ccb / bind xp
	**
	**----------------------------------------------------
	*/

#if defined(__mips__)
	if (xp->data && xp->datalen) {
		pci_sync_cache(np->sc_pc, (vm_offset_t)xp->data, xp->datalen);
	} 
	pci_sync_cache(np->sc_pc, (vm_offset_t)xp->cmd, xp->cmdlen);
	pci_sync_cache(np->sc_pc, (vm_offset_t)&xp->sense, sizeof(struct scsi_sense_data));
#endif /* __mips__ */

	oldspl = splbio();

	if (!(cp=ncr_get_ccb (np, flags, xp->sc_link->target,
		xp->sc_link->lun))) {
		printf ("%s: no ccb.\n", ncr_name (np));
		xp->error = XS_DRIVER_STUFFUP;
		splx(oldspl);
		return(TRY_AGAIN_LATER);
	};
	cp->xfer = xp;

	/*---------------------------------------------------
	**
	**	timestamp
	**
	**----------------------------------------------------
	*/

	bzero (&cp->phys.header.stamp, sizeof (struct tstamp));
#ifdef __OpenBSD__
	microuptime(&cp->phys.header.stamp.start);
#else
	gettime(&cp->phys.header.stamp.start);
#endif

	/*----------------------------------------------------
	**
	**	Get device quirks from a speciality table.
	**
	**	@@GENSCSI@@
	**	This should be a part of the device table
	**	in "scsi_conf.c".
	**
	**----------------------------------------------------
	*/

	if (tp->quirks & QUIRK_UPDATE) {
#ifdef __OpenBSD__
		tp->quirks = ncr_lookup ((char *) &tp->inqdata[0]);
#else
		int q = xp->sc_link->quirks;
		tp->quirks = QUIRK_NOMSG;
		if (q & SD_Q_NO_TAGS)
			tp->quirks |= QUIRK_NOTAGS;
		if (q & SD_Q_NO_SYNC)
			tp->quirks |= QUIRK_NOSYNC;
		if (q & SD_Q_NO_WIDE)
			tp->quirks |= QUIRK_NOWIDE16;
#endif
		if (bootverbose && (tp->quirks & ~QUIRK_NOMSG)) {
			PRINT_ADDR(xp);
			printf ("NCR quirks=0x%x\n", tp->quirks);
		};
		/*
		**	set number of tags
		*/
		ncr_setmaxtags (tp, tp->usrtags);
	};

	/*---------------------------------------------------
	**
	**	negotiation required?
	**
	**----------------------------------------------------
	*/

	nego = 0;

	if (!tp->nego_cp && tp->inqdata[7]) {
		/*
		**	negotiate wide transfers ?
		*/

		if (!tp->widedone) {
			if (tp->inqdata[7] & INQ7_WIDE16) {
				nego = NS_WIDE;
			} else
				tp->widedone=1;
		};

		/*
		**	negotiate synchronous transfers?
		*/

		if (!nego && !tp->period) {
			if (SCSI_NCR_DFLT_SYNC
#ifdef NCR_CDROM_ASYNC
			    && ((tp->inqdata[0] & 0x1f) != 5)
#endif /* NCR_CDROM_ASYNC */
			    && (tp->inqdata[7] & INQ7_SYNC)) {
				nego = NS_SYNC;
			} else {
				tp->period  =0xffff;
				tp->sval = 0xe0;
				PRINT_ADDR(xp);
				printf ("asynchronous.\n");
			};
		};

		/*
		**	remember nego is pending for the target.
		**	Avoid to start a nego for all queued commands
		**	when tagged command queuing is enabled.
		*/

		if (nego)
			tp->nego_cp = cp;
	};

	/*---------------------------------------------------
	**
	**	choose a new tag ...
	**
	**----------------------------------------------------
	*/

	if ((lp = tp->lp[xp->sc_link->lun]) && (lp->usetags)) {
		/*
		**	assign a tag to this ccb!
		*/
		while (!cp->tag) {
			ccb_p cp2 = lp->next_ccb;
			lp->lasttag = lp->lasttag % 255 + 1;
			while (cp2 && cp2->tag != lp->lasttag)
				cp2 = cp2->next_ccb;
			if (cp2) continue;
			cp->tag=lp->lasttag;
			if (DEBUG_FLAGS & DEBUG_TAGS) {
				PRINT_ADDR(xp);
				printf ("using tag #%d.\n", cp->tag);
			};
		};
	} else {
		cp->tag=0;
	};

	/*----------------------------------------------------
	**
	**	Build the identify / tag / sdtr message
	**
	**----------------------------------------------------
	*/

	idmsg = M_IDENTIFY | xp->sc_link->lun;
	if ((cp!=np->ccb) && (np->disc))
		idmsg |= 0x40;

	msgptr = cp->scsi_smsg;
	msglen = 0;
	msgptr[msglen++] = idmsg;

	if (cp->tag) {
	    char tag;

	    tag = np->order;
	    if (tag == 0) {
		/*
		**	Ordered write ops, unordered read ops.
		*/
		switch (cmd->opcode) {
		case 0x08:  /* READ_SMALL (6) */
		case 0x28:  /* READ_BIG  (10) */
		case 0xa8:  /* READ_HUGE (12) */
		    tag = M_SIMPLE_TAG;
		    break;
		default:
		    tag = M_ORDERED_TAG;
		}
	    }
	    msgptr[msglen++] = tag;
	    msgptr[msglen++] = cp -> tag;
	}

	switch (nego) {
	case NS_SYNC:
		msgptr[msglen++] = M_EXTENDED;
		msgptr[msglen++] = 3;
		msgptr[msglen++] = M_X_SYNC_REQ;
		msgptr[msglen++] = tp->minsync;
		msgptr[msglen++] = tp->maxoffs;
		if (DEBUG_FLAGS & DEBUG_NEGO) {
			PRINT_ADDR(cp->xfer);
			printf ("sync msgout: ");
			ncr_show_msg (&cp->scsi_smsg [msglen-5]);
			printf (".\n");
		};
		break;
	case NS_WIDE:
		msgptr[msglen++] = M_EXTENDED;
		msgptr[msglen++] = 2;
		msgptr[msglen++] = M_X_WIDE_REQ;
		msgptr[msglen++] = tp->usrwide;
		if (DEBUG_FLAGS & DEBUG_NEGO) {
			PRINT_ADDR(cp->xfer);
			printf ("wide msgout: ");
			ncr_show_msg (&cp->scsi_smsg [msglen-4]);
			printf (".\n");
		};
		break;
	};

	/*----------------------------------------------------
	**
	**	Build the identify message for getcc.
	**
	**----------------------------------------------------
	*/

	cp -> scsi_smsg2 [0] = idmsg;
	msglen2 = 1;

	/*----------------------------------------------------
	**
	**	Build the data descriptors
	**
	**----------------------------------------------------
	*/

	segments = ncr_scatter (np, &cp->phys, (vm_offset_t) xp->data,
					(vm_size_t) xp->datalen);

	if (segments < 0) {
		xp->error = XS_DRIVER_STUFFUP;
		ncr_free_ccb(np, cp, flags);
		splx(oldspl);
		return(COMPLETE);
	};

	/*----------------------------------------------------
	**
	**	Set the SAVED_POINTER.
	**
	**----------------------------------------------------
	*/

	if (flags & SCSI_DATA_IN) {
		u_long sp;
		sp = NCB_SCRIPT_PHYS (np, data_in);
		cp->phys.header.savep = SCR_BO(sp);
		cp->phys.header.goalp = SCR_BO(sp + 20 + segments * 16);
	} else if (flags & SCSI_DATA_OUT) {
		u_long sp;
		sp = NCB_SCRIPT_PHYS (np, data_out);
		cp->phys.header.savep = SCR_BO(sp);
		cp->phys.header.goalp = SCR_BO(sp + 20 + segments * 16);
	} else {
		cp->phys.header.savep = SCR_BO(NCB_SCRIPT_PHYS (np, no_data));
		cp->phys.header.goalp = cp->phys.header.savep;
	};
	cp->phys.header.lastp = cp->phys.header.savep;


	/*----------------------------------------------------
	**
	**	fill in ccb
	**
	**----------------------------------------------------
	**
	**
	**	physical -> virtual backlink
	**	Generic SCSI command
	*/
	cp->phys.header.cp		= cp;
	/*
	**	Startqueue
	*/
	cp->phys.header.launch.l_paddr	= SCR_BO(NCB_SCRIPT_PHYS (np, select));
	cp->phys.header.launch.l_cmd	= SCR_BO(SCR_JUMP);
	/*
	**	select
	*/
	cp->phys.select.sel_id		= xp->sc_link->target;
	cp->phys.select.sel_scntl3	= tp->wval;
	cp->phys.select.sel_sxfer	= tp->sval;
	/*
	**	message
	*/
	cp->phys.smsg.addr		= SCR_BO(CCB_PHYS (cp, scsi_smsg));
	cp->phys.smsg.size		= SCR_BO(msglen);

	cp->phys.smsg2.addr		= SCR_BO(CCB_PHYS (cp, scsi_smsg2));
	cp->phys.smsg2.size		= SCR_BO(msglen2);
	/*
	**	command
	*/
	cp->phys.cmd.addr		= SCR_BO(NCR_KVATOPHYS (np, cmd));
	cp->phys.cmd.size		= SCR_BO(xp->cmdlen);
	/*
	**	sense command
	*/
	cp->phys.scmd.addr		= SCR_BO(CCB_PHYS (cp, sensecmd));
	cp->phys.scmd.size		= SCR_BO(6);
	/*
	**	patch requested size into sense command
	*/
	cp->sensecmd[0]			= 0x03;
	cp->sensecmd[1]			= xp->sc_link->lun << 5;
	cp->sensecmd[4]			= sizeof(struct scsi_sense_data);
	if (xp->req_sense_length)
		cp->sensecmd[4]		= xp->req_sense_length;
	/*
	**	sense data
	*/
#if defined(__mips__)
	cp->phys.sense.addr		= SCR_BO(NCR_KVATOPHYS (np, &cp->local_sense));
#else
	cp->phys.sense.addr		= SCR_BO(NCR_KVATOPHYS (np, &cp->xfer->sense));
#endif
	cp->phys.sense.size		= SCR_BO(sizeof(struct scsi_sense_data));
	/*
	**	status
	*/
	cp->actualquirks		= tp->quirks;
	cp->host_status			= nego ? HS_NEGOTIATE : HS_BUSY;
	cp->scsi_status			= S_ILLEGAL;
	cp->parity_status		= 0;

	cp->xerr_status			= XE_OK;
	cp->sync_status			= tp->sval;
	cp->nego_status			= nego;
	cp->wide_status			= tp->wval;

	/*----------------------------------------------------
	**
	**	Critical region: start this job.
	**
	**----------------------------------------------------
	*/

	/*
	**	reselect pattern and activate this job.
	*/

	cp->jump_ccb.l_cmd	= SCR_BO((SCR_JUMP ^ IFFALSE (DATA (cp->tag))));
#ifdef __OpenBSD__
	cp->tlimit		= time_uptime + xp->timeout / 1000 + 2;
#else
	cp->tlimit		= time.tv_sec + xp->timeout / 1000 + 2;
#endif
	cp->magic		= CCB_MAGIC;

	/*
	**	insert into start queue.
	*/

	qidx = np->squeueput + 1;
	if (qidx >= MAX_START) qidx=0;
	np->squeue [qidx	 ] = SCR_BO(NCB_SCRIPT_PHYS (np, idle));
	np->squeue [np->squeueput] = SCR_BO(CCB_PHYS (cp, phys));
	np->squeueput = qidx;

	if(DEBUG_FLAGS & DEBUG_QUEUE)
		printf ("%s: queuepos=%d tryoffset=%d.\n", ncr_name (np),
		np->squeueput,
		(unsigned)(READSCRIPT(startpos[0])-
			   (NCB_SCRIPTH_PHYS (np, tryloop))));

	/*
	**	Script processor may be waiting for reselect.
	**	Wake it up.
	*/
	OUTB (nc_istat, SIGP);

	/*
	**	and reenable interrupts
	*/
#ifdef __OpenBSD__
	pollmode = flags & SCSI_POLL;
#else
	pollmode = flags & SCSI_NOMASK;
#endif
	splx (oldspl);

	/*
	**	If interrupts are enabled, return now.
	**	Command is successfully queued.
	*/

	if (!pollmode) {
		if(DEBUG_FLAGS & DEBUG_TINY) printf ("Q");
		return(SUCCESSFULLY_QUEUED);
	};

	/*----------------------------------------------------
	**
	**	Interrupts not yet enabled - have to poll.
	**
	**----------------------------------------------------
	*/

	if (DEBUG_FLAGS & DEBUG_POLL) printf("P");

	for (i=xp->timeout; i && !(xp->flags & ITSDONE);i--) {
		if ((DEBUG_FLAGS & DEBUG_POLL) && (cp->host_status))
			printf ("%c", (cp->host_status & 0xf) + '0');
		DELAY (1000);
		ncr_exception (np);
	};

	/*
	**	Abort if command not done.
	*/
	if (!(xp->flags & ITSDONE)) {
		printf ("%s: aborting job ...\n", ncr_name (np));
		OUTB (nc_istat, CABRT);
		DELAY (100000);
		OUTB (nc_istat, SIGP);
		ncr_exception (np);
	};

	if (!(xp->flags & ITSDONE)) {
		printf ("%s: abortion failed at %x.\n",
			ncr_name (np), (unsigned) INL(nc_dsp));
		ncr_init (np, "timeout", HS_TIMEOUT);
	};

	if (!(xp->flags & ITSDONE)) {
		cp-> host_status = HS_SEL_TIMEOUT;
		ncr_complete (np, cp);
	};

	if (DEBUG_FLAGS & DEBUG_RESULT) {
		printf ("%s: result: %x %x.\n",
			ncr_name (np), cp->host_status, cp->scsi_status);
	};
	switch (xp->error) {
	case  0     : return (COMPLETE);
	case XS_BUSY: return (TRY_AGAIN_LATER);
	};
	return (COMPLETE);
}

/*==========================================================
**
**
**	Complete execution of a SCSI command.
**	Signal completion to the generic SCSI driver.
**
**
**==========================================================
*/

void ncr_complete (ncb_p np, ccb_p cp)
{
	struct scsi_xfer * xp;
	tcb_p tp;
	lcb_p lp;

	/*
	**	Sanity check
	*/

	if (!cp || (cp->magic!=CCB_MAGIC) || !cp->xfer) return;
	cp->magic = 1;
	cp->tlimit= 0;

	/*
	**	No Reselect anymore.
	*/
	cp->jump_ccb.l_cmd = SCR_BO((SCR_JUMP));

	/*
	**	No starting.
	*/
	cp->phys.header.launch.l_paddr= SCR_BO(NCB_SCRIPT_PHYS (np, idle));

	/*
	**	timestamp
	*/
	ncb_profile (np, cp);

	if (DEBUG_FLAGS & DEBUG_TINY)
		printf ("CCB=%lx STAT=%x/%x\n", (unsigned long)cp & 0xfff,
			cp->host_status,cp->scsi_status);

	xp = cp->xfer;
	cp->xfer = NULL;
	tp = &np->target[xp->sc_link->target];
	lp = tp->lp[xp->sc_link->lun];

#if defined(__mips__)
	/*
	**	Move sense data back to request struct.
	*/
	{
		int i;
		u_char *p = (u_char *)&xp->sense;
		for(i = 0; i < sizeof(struct scsi_sense_data); i++) {
			*p++ = cp->local_sense[i];
		}
	}
#endif
	/*
	**	We do not queue more than 1 ccb per target
	**	with negotiation at any time. If this ccb was
	**	used for negotiation, clear this info in the tcb.
	*/

	if (cp == tp->nego_cp)
		tp->nego_cp = 0;

	/*
	**	Check for parity errors.
	*/

	if (cp->parity_status) {
		PRINT_ADDR(xp);
		printf ("%d parity error(s), fallback.\n", cp->parity_status);
		/*
		**	fallback to asynch transfer.
		*/
		tp->usrsync=255;
		tp->period =  0;
	};

	/*
	**	Check for extended errors.
	*/

	if (cp->xerr_status != XE_OK) {
		PRINT_ADDR(xp);
		switch (cp->xerr_status) {
		case XE_EXTRA_DATA:
			printf ("extraneous data discarded.\n");
			break;
		case XE_BAD_PHASE:
			printf ("illegal scsi phase (4/5).\n");
			break;
		default:
			printf ("extended error %d.\n", cp->xerr_status);
			break;
		};
		if (cp->host_status==HS_COMPLETE)
			cp->host_status = HS_FAIL;
	};

	/*
	**	Check the status.
	*/
#ifdef __OpenBSD__
	if (xp->error != XS_NOERROR) {

                /*
                **      Don't override the error value.
                */
	} else
#endif /* __OpenBSD__ */
	if (   (cp->host_status == HS_COMPLETE)
		&& (cp->scsi_status == S_GOOD)) {

		/*
		**	All went well.
		*/

		xp->resid = 0;

		/*
		** if (cp->phys.header.lastp != cp->phys.header.goalp)...
		**
		**	@@RESID@@
		**	Could dig out the correct value for resid,
		**	but it would be quite complicated.
		**
		**	The ah1542.c driver sets it to 0 too ...
		*/

		/*
		**	Try to assign a ccb to this nexus
		*/
		ncr_alloc_ccb (np, xp->sc_link->target, xp->sc_link->lun);

		/*
		**	On inquire cmd (0x12) save some data.
		*/
		if (xp->cmd->opcode == 0x12 && xp->sc_link->lun == 0) {
			bcopy (	xp->data,
				&tp->inqdata,
				sizeof (tp->inqdata));
			/*
			**	prepare negotiation of synch and wide.
			*/
			ncr_negotiate (np, tp);

			/*
			**	force quirks update before next command start
			*/
			tp->quirks |= QUIRK_UPDATE;
		};

		/*
		**	Announce changes to the generic driver
		*/
		if (lp) {
			if (lp->reqlink != lp->actlink)
				ncr_opennings (np, lp, xp);
		};

		tp->bytes     += xp->datalen;
		tp->transfers ++;
#ifndef __OpenBSD__
	} else if (xp->flags & SCSI_ERR_OK) {

		/*
		**   Not correct, but errors expected.
		*/
		xp->resid = 0;
#endif /* !__OpenBSD__ */
	} else if ((cp->host_status == HS_COMPLETE)
		&& (cp->scsi_status == (S_SENSE|S_GOOD))) {

		/*
		**   Check condition code
		*/
		xp->error = XS_SENSE;

		if (DEBUG_FLAGS & (DEBUG_RESULT|DEBUG_TINY)) {
			u_char * p = (u_char *) & xp->sense;
			int i;
			printf ("\n%s: sense data:", ncr_name (np));
			for (i=0; i<14; i++) printf (" %x", *p++);
			printf (".\n");
		};

	} else if ((cp->host_status == HS_COMPLETE)
		   && ((cp->scsi_status == S_BUSY)
		       || (cp->scsi_status == S_CONFLICT))) {

		/*
		**   Target is busy, or reservation conflict
		*/
		xp->error = XS_BUSY;

	} else if (cp->host_status == HS_SEL_TIMEOUT) {

		/*
		**   Device failed selection
		*/
		xp->error = XS_SELTIMEOUT;

	} else if(cp->host_status == HS_TIMEOUT) {

		/*
		**   No response
		*/
		xp->error = XS_TIMEOUT;

	} else {

		/*
		**  Other protocol messes
		*/
		PRINT_ADDR(xp);
		printf ("COMMAND FAILED (%x %x) @@%p.\n",
			cp->host_status, cp->scsi_status, cp);

		xp->error = XS_TIMEOUT;
	}

	xp->flags |= ITSDONE;

	/*
	**	trace output
	*/

	if (tp->usrflag & UF_TRACE) {
		u_char * p;
		int i;
		PRINT_ADDR(xp);
		printf (" CMD:");
		p = (u_char *) &xp->cmd->opcode;
		for (i=0; i<xp->cmdlen; i++) printf (" %x", *p++);

		if (cp->host_status==HS_COMPLETE) {
			switch (cp->scsi_status) {
			case S_GOOD:
				printf ("  GOOD");
				break;
			case S_CHECK_COND:
				printf ("  SENSE:");
				p = (u_char *) &xp->sense;
				for (i=0; i<xp->req_sense_length; i++)
					printf (" %x", *p++);
				break;
			default:
				printf ("  STAT: %x\n", cp->scsi_status);
				break;
			};
		} else printf ("  HOSTERROR: %x", cp->host_status);
		printf ("\n");
	};

	/*
	**	Free this ccb
	*/
	ncr_free_ccb (np, cp, xp->flags);

	/*
	**	signal completion to generic driver.
	*/
	scsi_done (xp);
}

/*==========================================================
**
**
**	Signal all (or one) control block done.
**
**
**==========================================================
*/

void ncr_wakeup (ncb_p np, u_long code)
{
	/*
	**	Starting at the default ccb and following
	**	the links, complete all jobs with a
	**	host_status greater than "disconnect".
	**
	**	If the "code" parameter is not zero,
	**	complete all jobs that are not IDLE.
	*/

	ccb_p cp = np->ccb;
	while (cp) {
		switch (cp->host_status) {

		case HS_IDLE:
			break;

		case HS_DISCONNECT:
			if(DEBUG_FLAGS & DEBUG_TINY) printf ("D");
			/* fall through */

		case HS_BUSY:
		case HS_NEGOTIATE:
			if (!code) break;
			cp->host_status = code;

			/* fall through */

		default:
			ncr_complete (np, cp);
			break;
		};
		cp = cp -> link_ccb;
	};
}

/*==========================================================
**
**
**	Start NCR chip.
**
**
**==========================================================
*/

void ncr_init (ncb_p np, char * msg, u_long code)
{
	int	i;
	u_long	usrsync;
	u_char	usrwide;

	/*
	**	Reset chip.
	*/

	OUTB (nc_istat,  SRST);
	DELAY (1000);
	OUTB (nc_istat, 0);

	/*
	**	Message.
	*/

	if (msg) printf ("%s: restart (%s).\n", ncr_name (np), msg);

	/*
	**	Clear Start Queue
	*/

	for (i=0;i<MAX_START;i++)
		np -> squeue [i] = SCR_BO(NCB_SCRIPT_PHYS (np, idle));

	/*
	**	Start at first entry.
	*/

	np->squeueput = 0;
	WRITESCRIPT(startpos[0], NCB_SCRIPTH_PHYS (np, tryloop));
	WRITESCRIPT(start0  [0], SCR_INT ^ IFFALSE (0));

	/*
	**	Wakeup all pending jobs.
	*/

	ncr_wakeup (np, code);

	/*
	**	Init chip.
	*/

	OUTB (nc_istat,  0x00   );      /*  Remove Reset, abort ...	     */
	OUTB (nc_scntl0, 0xca   );      /*  full arb., ena parity, par->ATN  */
	OUTB (nc_scntl1, 0x00	);	/*  odd parity, and remove CRST!!    */
	ncr_selectclock(np, np->rv_scntl3); /* Select SCSI clock             */
	OUTB (nc_scid  , RRE|np->myaddr);/*  host adapter SCSI address       */
	OUTW (nc_respid, 1ul<<np->myaddr);/*  id to respond to		     */
	OUTB (nc_istat , SIGP	);	/*  Signal Process		     */
	OUTB (nc_dmode , np->rv_dmode);	/* XXX modify burstlen ??? */
	OUTB (nc_dcntl , np->rv_dcntl);
	OUTB (nc_ctest3, np->rv_ctest3);
	OUTB (nc_ctest5, np->rv_ctest5);
	OUTB (nc_ctest4, np->rv_ctest4);/*  enable master parity checking    */
	OUTB (nc_stest2, np->rv_stest2|EXT); /* Extended Sreq/Sack filtering */
	OUTB (nc_stest3, TE     );	/*  TolerANT enable		     */
	OUTB (nc_stime0, 0x0b	);	/*  HTH = disabled, STO = 0.1 sec.   */

	if (bootverbose >= 2) {
		printf ("\tACTUAL values:SCNTL3:%02x DMODE:%02x  DCNTL:%02x\n",
			np->rv_scntl3, np->rv_dmode, np->rv_dcntl);
		printf ("\t              CTEST3:%02x CTEST4:%02x CTEST5:%02x\n",
			np->rv_ctest3, np->rv_ctest4, np->rv_ctest5);
	}

	/*
	**    Enable GPIO0 pin for writing if LED support.
	*/

	if (np->features & FE_LED0) {
		OUTOFFB (nc_gpcntl, 0x01);
	}

	/*
	**	Reinitialize usrsync.
	**	Have to renegotiate synch mode.
	*/

	usrsync = 255;
	if (SCSI_NCR_DFLT_SYNC) {
		usrsync = SCSI_NCR_DFLT_SYNC;
		if (usrsync > np->maxsync)
			usrsync = np->maxsync;
		if (usrsync < np->minsync)
			usrsync = np->minsync;
	};

	/*
	**	Reinitialize usrwide.
	**	Have to renegotiate wide mode.
	*/

	usrwide = (SCSI_NCR_MAX_WIDE);
	if (usrwide > np->maxwide) usrwide=np->maxwide;

	/*
	**	Disable disconnects.
	*/

	np->disc = 0;

	/*
	**	Fill in target structure.
	*/

	for (i=0;i<MAX_TARGET;i++) {
		tcb_p tp = &np->target[i];

		tp->sval    = 0;
		tp->wval    = np->rv_scntl3;

		tp->usrsync = usrsync;
		tp->usrwide = usrwide;

		ncr_negotiate (np, tp);
	}

	/*
	**      enable ints
	*/

	OUTW (nc_sien , STO|HTH|MA|SGE|UDC|RST);
	OUTB (nc_dien , MDPE|BF|ABRT|SSI|SIR|IID);

	/*
	**    Start script processor.
	*/

	OUTL (nc_dsp, NCB_SCRIPT_PHYS (np, start));
}

/*==========================================================
**
**	Prepare the negotiation values for wide and
**	synchronous transfers.
**
**==========================================================
*/

static void ncr_negotiate (struct ncb* np, struct tcb* tp)
{
	/*
	**	minsync unit is 4ns !
	*/

	u_long minsync = tp->usrsync;

	/*
	**	if not scsi 2
	**	don't believe FAST!
	*/

	if ((minsync < 50) && (tp->inqdata[2] & 0x0f) < 2)
		minsync=50;

	/*
	**	our limit ..
	*/

	if (minsync < np->minsync)
		minsync = np->minsync;

	/*
	**	divider limit
	*/

	if (minsync > np->maxsync)
		minsync = 255;

	tp->minsync = minsync;
	tp->maxoffs = (minsync<255 ? np->maxoffs : 0);

	/*
	**	period=0: has to negotiate sync transfer
	*/

	tp->period=0;

	/*
	**	widedone=0: has to negotiate wide transfer
	*/
	tp->widedone=0;
}

/*==========================================================
**
**	Get clock factor and sync divisor for a given
**	synchronous factor period.
**	Returns the clock factor (in sxfer) and scntl3
**	synchronous divisor field.
**
**==========================================================
*/

static void ncr_getsync(ncb_p np, u_char sfac, u_char *fakp, u_char *scntl3p)
{
	u_long	clk = np->clock_khz;	/* SCSI clock frequency in kHz	*/
	int	div = np->clock_divn;	/* Number of divisors supported	*/
	u_long	fak;			/* Sync factor in sxfer		*/
	u_long	per;			/* Period in tenths of ns	*/
	u_long	kpc;			/* (per * clk)			*/

	/*
	**	Compute the synchronous period in tenths of nano-seconds
	*/
	if	(sfac <= 10)	per = 250;
	else if	(sfac == 11)	per = 303;
	else if	(sfac == 12)	per = 500;
	else			per = 40 * sfac;

	/*
	**	Look for the greatest clock divisor that allows an
	**	input speed faster than the period.
	*/
	kpc = per * clk;
	while (--div >= 0)
		if (kpc >= (div_10M[div] * 4)) break;

	/*
	**	Calculate the lowest clock factor that allows an output
	**	speed not faster than the period.
	*/
	fak = (kpc - 1) / div_10M[div] + 1;

#if 0	/* You can #if 1 if you think this optimization is usefull */

	per = (fak * div_10M[div]) / clk;

	/*
	**	Why not to try the immediate lower divisor and to choose
	**	the one that allows the fastest output speed ?
	**	We dont want input speed too much greater than output speed.
	*/
	if (div >= 1 && fak < 6) {
		u_long fak2, per2;
		fak2 = (kpc - 1) / div_10M[div-1] + 1;
		per2 = (fak2 * div_10M[div-1]) / clk;
		if (per2 < per && fak2 <= 6) {
			fak = fak2;
			per = per2;
			--div;
		}
	}
#endif

	if (fak < 4) fak = 4;	/* Should never happen, too bad ... */

	/*
	**	Compute and return sync parameters for the ncr
	*/
	*fakp		= fak - 4;
	*scntl3p	= ((div+1) << 4) + (sfac < 25 ? 0x80 : 0);
}

/*==========================================================
**
**	Switch sync mode for current job and it's target
**
**==========================================================
*/

static void ncr_setsync (ncb_p np, ccb_p cp, u_char scntl3, u_char sxfer)
{
	struct scsi_xfer *xp;
	tcb_p tp;
	int div;
	u_char target = INB (nc_sdid) & 0x0f;

	assert (cp);
	if (!cp) return;

	xp = cp->xfer;
	assert (xp);
	if (!xp) return;
	assert (target == (xp->sc_link->target & 0x0f));

	tp = &np->target[target];

	if (!scntl3 || !(sxfer & 0x1f))
		scntl3 = np->rv_scntl3;
	scntl3 = (scntl3 & 0xf0) | (tp->wval & EWS) | (np->rv_scntl3 & 0x07);

	/*
	**	Deduce the value of controller sync period from scntl3.
	**	period is in tenths of nano-seconds.
	*/

	div = ((scntl3 >> 4) & 0x7);
	if ((sxfer & 0x1f) && div)
		tp->period = (((sxfer>>5)+4)*div_10M[div-1])/np->clock_khz;
	else
		tp->period = 0xffff;

	/*
	**	 Stop there if sync parameters are unchanged
	*/

	if (tp->sval == sxfer && tp->wval == scntl3) return;
	tp->sval = sxfer;
	tp->wval = scntl3;

	/*
	**	Bells and whistles   ;-)
	*/
	PRINT_ADDR(xp);
	if (sxfer & 0x1f) {
		unsigned f10 = 100000 << (tp->widedone ? tp->widedone -1 : 0);
		unsigned mb10 = (f10 + tp->period/2) / tp->period;
		/*
		**  Disable extended Sreq/Sack filtering
		*/
		if (tp->period <= 2000) OUTOFFB (nc_stest2, EXT);
		printf ("%d.%d MB/s (%d ns, offset %d)\n",
			mb10 / 10, mb10 % 10, tp->period / 10, sxfer & 0x1f);
	} else  printf ("asynchronous.\n");

	/*
	**	set actual value and sync_status
	*/
	OUTB (nc_sxfer, sxfer);
	np->sync_st = sxfer;
	OUTB (nc_scntl3, scntl3);
	np->wide_st = scntl3;

	/*
	**	patch ALL ccbs of this target.
	*/
	for (cp = np->ccb; cp; cp = cp->link_ccb) {
		if (!cp->xfer) continue;
		if (cp->xfer->sc_link->target != target) continue;
		cp->sync_status = sxfer;
		cp->wide_status = scntl3;
	};
}

/*==========================================================
**
**	Switch wide mode for current job and it's target
**	SCSI specs say: a SCSI device that accepts a WDTR
**	message shall reset the synchronous agreement to
**	asynchronous mode.
**
**==========================================================
*/

static void ncr_setwide (ncb_p np, ccb_p cp, u_char wide, u_char ack)
{
	struct scsi_xfer *xp;
	u_short target = INB (nc_sdid) & 0x0f;
	tcb_p tp;
	u_char	scntl3;
	u_char	sxfer;

	assert (cp);
	if (!cp) return;

	xp = cp->xfer;
	assert (xp);
	if (!xp) return;
	assert (target == (xp->sc_link->target & 0x0f));

	tp = &np->target[target];
	tp->widedone  =  wide+1;
	scntl3 = (tp->wval & (~EWS)) | (wide ? EWS : 0);

	sxfer = ack ? 0 : tp->sval;

	/*
	**	 Stop there if sync/wide parameters are unchanged
	*/
	if (tp->sval == sxfer && tp->wval == scntl3) return;
	tp->sval = sxfer;
	tp->wval = scntl3;

	/*
	**	Bells and whistles   ;-)
	*/
	PRINT_ADDR(xp);
	if (scntl3 & EWS)
		printf ("WIDE SCSI (16 bit) enabled\n");
	else
		printf ("WIDE SCSI disabled\n");

	/*
	**	set actual value and sync_status
	*/
	OUTB (nc_sxfer, sxfer);
	np->sync_st = sxfer;
	OUTB (nc_scntl3, scntl3);
	np->wide_st = scntl3;

	/*
	**	patch ALL ccbs of this target.
	*/
	for (cp = np->ccb; cp; cp = cp->link_ccb) {
		if (!cp->xfer) continue;
		if (cp->xfer->sc_link->target != target) continue;
		cp->sync_status = sxfer;
		cp->wide_status = scntl3;
	};
}

/*==========================================================
**
**	Switch tagged mode for a target.
**
**==========================================================
*/

static void ncr_setmaxtags (tcb_p tp, u_long usrtags)
{
	int l;
	for (l=0; l<MAX_LUN; l++) {
		lcb_p lp;
		if (!tp) break;
		lp=tp->lp[l];
		if (!lp) continue;
		ncr_settags (tp, lp, usrtags);
	};
}

static void ncr_settags (tcb_p tp, lcb_p lp, u_long usrtags)
{
	u_char reqtags, tmp;

	if ((!tp) || (!lp)) return;

	/*
	**	only devices capable of tagges commands
	**	only disk devices
	**	only if enabled by user ..
	*/
	if ((tp->inqdata[0] & 0x1f) != 0x00
	    || (tp->inqdata[7] & INQ7_QUEUE) == 0
	    || (tp->quirks & QUIRK_NOTAGS) != 0) {
	    usrtags=0;
	}
	if (usrtags) {
		reqtags = usrtags;
		if (lp->actlink <= 1)
			lp->usetags=reqtags;
	} else {
		reqtags = 1;
		if (lp->actlink <= 1)
			lp->usetags=0;
	};

	/*
	**	don't announce more than available.
	*/
	tmp = lp->actccbs;
	if (tmp > reqtags) tmp = reqtags;
	lp->reqlink = tmp;

	/*
	**	don't discard if announced.
	*/
	tmp = lp->actlink;
	if (tmp < reqtags) tmp = reqtags;
	lp->reqccbs = tmp;
	if (lp->reqlink < lp->reqccbs)
		lp->reqlink = lp->reqccbs;
}

/*----------------------------------------------------
**
**	handle user commands
**
**----------------------------------------------------
*/

static void ncr_usercmd (ncb_p np)
{
	u_char t;
	tcb_p tp;

	switch (np->user.cmd) {

	case 0: return;

	case UC_SETSYNC:
		for (t=0; t<MAX_TARGET; t++) {
			if (!((np->user.target>>t)&1)) continue;
			tp = &np->target[t];
			tp->usrsync = np->user.data;
			ncr_negotiate (np, tp);
		};
		break;

	case UC_SETTAGS:
		if (np->user.data > MAX_TAGS)
			break;
		for (t=0; t<MAX_TARGET; t++) {
			if (!((np->user.target>>t)&1)) continue;
			tp = &np->target[t];
			tp->usrtags = np->user.data;
			ncr_setmaxtags (tp, tp->usrtags);
		};
		break;

	case UC_SETDEBUG:
		ncr_debug = np->user.data;
		break;

	case UC_SETORDER:
		np->order = np->user.data;
		break;

	case UC_SETWIDE:
		for (t=0; t<MAX_TARGET; t++) {
			u_long size;
			if (!((np->user.target>>t)&1)) continue;
			tp = &np->target[t];
			size = np->user.data;
			if (size > np->maxwide) size=np->maxwide;
			tp->usrwide = size;
			ncr_negotiate (np, tp);
		};
		break;

	case UC_SETFLAG:
		for (t=0; t<MAX_TARGET; t++) {
			if (!((np->user.target>>t)&1)) continue;
			tp = &np->target[t];
			tp->usrflag = np->user.data;
		};
		break;
	}
	np->user.cmd=0;
}




/*==========================================================
**
**
**	ncr timeout handler.
**
**
**==========================================================
**
**	Misused to keep the driver running when
**	interrupts are not configured correctly.
**
**----------------------------------------------------------
*/

static void ncr_timeout (void *arg)
{
	ncb_p	np = arg;
#ifdef __OpenBSD__
	u_long	thistime = time_uptime;
#else
	u_long	thistime = time.tv_sec;
#endif
	u_long	step  = np->ticks;
	u_long	count = 0;
	long signed   t;
	ccb_p cp;

	if (np->lasttime != thistime) {
		/*
		**	block ncr interrupts
		*/
		int oldspl = splbio();
		np->lasttime = thistime;

		ncr_usercmd (np);

		/*----------------------------------------------------
		**
		**	handle ncr chip timeouts
		**
		**	Assumption:
		**	We have a chance to arbitrate for the
		**	SCSI bus at least every 10 seconds.
		**
		**----------------------------------------------------
		*/

		t = thistime - np->heartbeat;

		if (t<2) np->latetime=0; else np->latetime++;

		if (np->latetime>2) {
			/*
			**      If there are no requests, the script
			**      processor will sleep on SEL_WAIT_RESEL.
			**      But we have to check whether it died.
			**      Let's try to wake it up.
			*/
			OUTB (nc_istat, SIGP);
		};

		/*----------------------------------------------------
		**
		**	handle ccb timeouts
		**
		**----------------------------------------------------
		*/

		for (cp=np->ccb; cp; cp=cp->link_ccb) {
			/*
			**	look for timed out ccbs.
			*/
			if (!cp->host_status) continue;
			count++;
			if (cp->tlimit > thistime) continue;

			/*
			**	Disable reselect.
			**      Remove it from startqueue.
			*/
			cp->jump_ccb.l_cmd = SCR_BO((SCR_JUMP));
			if (cp->phys.header.launch.l_paddr ==
				SCR_BO(NCB_SCRIPT_PHYS (np, select))) {
				printf ("%s: timeout ccb=%p (skip)\n",
					ncr_name (np), cp);
				cp->phys.header.launch.l_paddr
				= SCR_BO(NCB_SCRIPT_PHYS (np, skip));
			};

			switch (cp->host_status) {

			case HS_BUSY:
			case HS_NEGOTIATE:
				/*
				** still in start queue ?
				*/
				if (cp->phys.header.launch.l_paddr ==
					SCR_BO(NCB_SCRIPT_PHYS (np, skip)))
					continue;

				/* fall through */
			case HS_DISCONNECT:
				cp->host_status=HS_TIMEOUT;
			};
			cp->tag = 0;

			/*
			**	wakeup this ccb.
			*/
			ncr_complete (np, cp);
		};
		splx (oldspl);
	}

#ifdef __FreeBSD__
	np->timeout_ch = timeout (ncr_timeout, (caddr_t) np, step ? step : 1);
#else
	timeout_add(&np->sc_timeout, step ? step : 1);
#endif

	if (INB(nc_istat) & (INTF|SIP|DIP)) {

		/*
		**	Process pending interrupts.
		*/

		int	oldspl	= splbio ();
		if (DEBUG_FLAGS & DEBUG_TINY) printf ("{");
		ncr_exception (np);
		if (DEBUG_FLAGS & DEBUG_TINY) printf ("}");
		splx (oldspl);
	};
}

/*==========================================================
**
**	log message for real hard errors
**
**	"ncr0 targ 0?: ERROR (ds:si) (so-si-sd) (sxfer/scntl3) @@ name (dsp:dbc)."
**	"	      reg: r0 r1 r2 r3 r4 r5 r6 ..... rf."
**
**	exception register:
**		ds:	dstat
**		si:	sist
**
**	SCSI bus lines:
**		so:	control lines as driven by NCR.
**		si:	control lines as seen by NCR.
**		sd:	scsi data lines as seen by NCR.
**
**	wide/fastmode:
**		sxfer:	(see the manual)
**		scntl3:	(see the manual)
**
**	current script command:
**		dsp:	script address (relative to start of script).
**		dbc:	first word of script command.
**
**	First 16 register of the chip:
**		r0..rf
**
**==========================================================
*/

static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)
{
	u_int32_t dsp;
	int	script_ofs;
	int	script_size;
	char	*script_name;
	u_char	*script_base;
	int	i;

	dsp	= INL (nc_dsp);

	if (np->p_script < dsp &&
	    dsp <= np->p_script + sizeof(struct script)) {
		script_ofs	= dsp - np->p_script;
		script_size	= sizeof(struct script);
		script_base	= (u_char *) np->script;
		script_name	= "script";
	}
	else if (np->p_scripth < dsp &&
		 dsp <= np->p_scripth + sizeof(struct scripth)) {
		script_ofs	= dsp - np->p_scripth;
		script_size	= sizeof(struct scripth);
		script_base	= (u_char *) np->scripth;
		script_name	= "scripth";
	} else {
		script_ofs	= dsp;
		script_size	= 0;
		script_base	= 0;
		script_name	= "mem";
	}

	printf ("%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @@ (%s %x:%08x).\n",
		ncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,
		(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),
		(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,
		(unsigned)INL (nc_dbc));

	if (((script_ofs & 3) == 0) &&
	    (unsigned)script_ofs < script_size) {
		printf ("%s: script cmd = %08x\n", ncr_name(np),
		    (int)READSCRIPT_OFF(script_base, script_ofs));
	}

        printf ("%s: regdump:", ncr_name(np));
        for (i=0; i<16;i++)
            printf (" %02x", (unsigned)INB_OFF(i));
        printf (".\n");
}

/*==========================================================
**
**
**	ncr chip exception handler.
**
**
**==========================================================
*/

void ncr_exception (ncb_p np)
{
	u_int8_t	istat, dstat;
	u_int16_t	sist;

	/*
	**	interrupt on the fly ?
	*/
	while ((istat = INB (nc_istat)) & INTF) {
		if (DEBUG_FLAGS & DEBUG_TINY) printf ("F ");
		OUTB (nc_istat, INTF);
		np->profile.num_fly++;
		ncr_wakeup (np, 0);
	};
	if (!(istat & (SIP|DIP))) {
		return;
	}

	/*
	**	Steinbach's Guideline for Systems Programming:
	**	Never test for an error condition you don't know how to handle.
	*/

	sist  = (istat & SIP) ? INW (nc_sist)  : 0;
	dstat = (istat & DIP) ? INB (nc_dstat) : 0;
	np->profile.num_int++;

	if (DEBUG_FLAGS & DEBUG_TINY)
		printf ("<%d|%x:%x|%x:%x>",
			INB(nc_scr0),
			dstat,sist,
			(unsigned)INL(nc_dsp),
			(unsigned)INL(nc_dbc));
	if ((dstat==DFE) && (sist==PAR)) return;

/*==========================================================
**
**	First the normal cases.
**
**==========================================================
*/
	/*-------------------------------------------
	**	SCSI reset
	**-------------------------------------------
	*/

	if (sist & RST) {
		ncr_init (np, bootverbose ? "scsi reset" : NULL, HS_RESET);
		return;
	};

	/*-------------------------------------------
	**	selection timeout
	**
	**	IID excluded from dstat mask!
	**	(chip bug)
	**-------------------------------------------
	*/

	if ((sist  & STO) &&
		!(sist  & (GEN|HTH|MA|SGE|UDC|RST|PAR)) &&
		!(dstat & (MDPE|BF|ABRT|SIR))) {
		ncr_int_sto (np);
		return;
	};

	/*-------------------------------------------
	**      Phase mismatch.
	**-------------------------------------------
	*/

	if ((sist  & MA) &&
		!(sist  & (STO|GEN|HTH|SGE|UDC|RST|PAR)) &&
		!(dstat & (MDPE|BF|ABRT|SIR|IID))) {
		ncr_int_ma (np, dstat);
		return;
	};

	/*----------------------------------------
	**	move command with length 0
	**----------------------------------------
	*/

	if ((dstat & IID) &&
		!(sist  & (STO|GEN|HTH|MA|SGE|UDC|RST|PAR)) &&
		!(dstat & (MDPE|BF|ABRT|SIR)) &&
		((INL(nc_dbc) & 0xf8000000) == SCR_MOVE_TBL)) {
		/*
		**      Target wants more data than available.
		**	The "no_data" script will do it.
		*/
		OUTL (nc_dsp, NCB_SCRIPT_PHYS (np, no_data));
		return;
	};

	/*-------------------------------------------
	**	Programmed interrupt
	**-------------------------------------------
	*/

	if ((dstat & SIR) &&
		!(sist  & (STO|GEN|HTH|MA|SGE|UDC|RST|PAR)) &&
		!(dstat & (MDPE|BF|ABRT|IID)) &&
		(INB(nc_dsps) <= SIR_MAX)) {
		ncr_int_sir (np);
		return;
	};

	/*========================================
	**	log message for real hard errors
	**========================================
	*/

	ncr_log_hard_error(np, sist, dstat);

	/*========================================
	**	do the register dump
	**========================================
	*/

#ifdef __OpenBSD__
	if (time_uptime - np->regtime.tv_sec>10) {
		int i;
		microuptime(&np->regtime);
#else
	if (time.tv_sec - np->regtime.tv_sec>10) {
		int i;
		gettime(&np->regtime);
#endif
		for (i=0; i<sizeof(np->regdump); i++)
			((char *)&np->regdump)[i] = INB_OFF(i);
		np->regdump.nc_dstat = dstat;
		np->regdump.nc_sist  = sist;
	};


	/*----------------------------------------
	**	clean up the dma fifo
	**----------------------------------------
	*/

	if ( (INB(nc_sstat0) & (ILF|ORF|OLF)   ) ||
	     (INB(nc_sstat1) & (FF3210)	) ||
	     (INB(nc_sstat2) & (ILF1|ORF1|OLF1)) ||	/* wide .. */
	     !(dstat & DFE)) {
		printf ("%s: have to clear fifos.\n", ncr_name (np));
		OUTB (nc_stest3, TE|CSF);	/* clear scsi fifo */
		OUTB (nc_ctest3, np->rv_ctest3 | CLF);
						/* clear dma fifo  */
	}

	/*----------------------------------------
	**	handshake timeout
	**----------------------------------------
	*/

	if (sist & HTH) {
		printf ("%s: handshake timeout\n", ncr_name(np));
		OUTB (nc_scntl1, CRST);
		DELAY (1000);
		OUTB (nc_scntl1, 0x00);
		OUTB (nc_scr0, HS_FAIL);
		OUTL (nc_dsp, NCB_SCRIPT_PHYS (np, cleanup));
		return;
	}

	/*----------------------------------------
	**	unexpected disconnect
	**----------------------------------------
	*/

	if ((sist  & UDC) &&
		!(sist  & (STO|GEN|HTH|MA|SGE|RST|PAR)) &&
		!(dstat & (MDPE|BF|ABRT|SIR|IID))) {
		OUTB (nc_scr0, HS_UNEXPECTED);
		OUTL (nc_dsp, NCB_SCRIPT_PHYS (np, cleanup));
		return;
	};

	/*----------------------------------------
	**	cannot disconnect
	**----------------------------------------
	*/

	if ((dstat & IID) &&
		!(sist  & (STO|GEN|HTH|MA|SGE|UDC|RST|PAR)) &&
		!(dstat & (MDPE|BF|ABRT|SIR)) &&
		((INL(nc_dbc) & 0xf8000000) == SCR_WAIT_DISC)) {
		/*
		**      Unexpected data cycle while waiting for disconnect.
		*/
		if (INB(nc_sstat2) & LDSC) {
			/*
			**	It's an early reconnect.
			**	Let's continue ...
			*/
			OUTB (nc_dcntl, np->rv_dcntl | STD);
			/*
			**	info message
			*/
			printf ("%s: INFO: LDSC while IID.\n",
				ncr_name (np));
			return;
		};
		printf ("%s: target %d doesn't release the bus.\n",
			ncr_name (np), INB (nc_sdid)&0x0f);
		/*
		**	return without restarting the NCR.
		**	timeout will do the real work.
		*/
		return;
	};

	/*----------------------------------------
	**	single step
	**----------------------------------------
	*/

	if ((dstat & SSI) &&
		!(sist  & (STO|GEN|HTH|MA|SGE|UDC|RST|PAR)) &&
		!(dstat & (MDPE|BF|ABRT|SIR|IID))) {
		OUTB (nc_dcntl, np->rv_dcntl | STD);
		return;
	};

/*
**	@@RECOVER@@ HTH, SGE, ABRT.
**
**	We should try to recover from these interrupts.
**	They may occur if there are problems with synch transfers, or
**	if targets are switched on or off while the driver is running.
*/

	if (sist & SGE) {
		/* clear scsi offsets */
		OUTB (nc_ctest3, np->rv_ctest3 | CLF);
	}

	/*
	**	Freeze controller to be able to read the messages.
	*/

	if (DEBUG_FLAGS & DEBUG_FREEZE) {
		int i;
		unsigned char val;
		for (i=0; i<0x60; i++) {
			switch (i%16) {

			case 0:
				printf ("%s: reg[%d0]: ",
					ncr_name(np),i/16);
				break;
			case 4:
			case 8:
			case 12:
				printf (" ");
				break;
			};
			val = INB_OFF(i);
			printf (" %x%x", val/16, val%16);
			if (i%16==15) printf (".\n");
		};

#ifdef __FreeBSD__
		untimeout (ncr_timeout, (caddr_t) np, np->timeout_ch);
#else
		timeout_del(&np->sc_timeout);
#endif

		printf ("%s: halted!\n", ncr_name(np));
		/*
		**	don't restart controller ...
		*/
		OUTB (nc_istat,  SRST);
		return;
	};

#ifdef NCR_FREEZE
	/*
	**	Freeze system to be able to read the messages.
	*/
	printf ("ncr: fatal error: system halted - press reset to reboot ...");
	(void) splhigh();
	for (;;);
#endif

	/*
	**	sorry, have to kill ALL jobs ...
	*/

	ncr_init (np, "fatal error", HS_FAIL);
}

/*==========================================================
**
**	ncr chip exception handler for selection timeout
**
**==========================================================
**
**	There seems to be a bug in the 53c810.
**	Although a STO-Interrupt is pending,
**	it continues executing script commands.
**	But it will fail and interrupt (IID) on
**	the next instruction where it's looking
**	for a valid phase.
**
**----------------------------------------------------------
*/

void ncr_int_sto (ncb_p np)
{
	u_long dsa, scratcha, diff;
	ccb_p cp;
	if (DEBUG_FLAGS & DEBUG_TINY) printf ("T");

	/*
	**	look for ccb and set the status.
	*/

	dsa = INL (nc_dsa);
	cp = np->ccb;
	while (cp && (CCB_PHYS (cp, phys) != dsa))
		cp = cp->link_ccb;

	if (cp) {
		cp-> host_status = HS_SEL_TIMEOUT;
		ncr_complete (np, cp);
	};

	/*
	**	repair start queue
	*/

	scratcha = INL (nc_scratcha);
	diff = scratcha - NCB_SCRIPTH_PHYS (np, tryloop);

/*	assert ((diff <= MAX_START * 20) && !(diff % 20));*/

	if ((diff <= MAX_START * 20) && !(diff % 20)) {
		WRITESCRIPT(startpos[0], scratcha);
		OUTL (nc_dsp, NCB_SCRIPT_PHYS (np, start));
		return;
	};
	ncr_init (np, "selection timeout", HS_FAIL);
}

/*==========================================================
**
**
**	ncr chip exception handler for phase errors.
**
**
**==========================================================
**
**	We have to construct a new transfer descriptor,
**	to transfer the rest of the current block.
**
**----------------------------------------------------------
*/

static void ncr_int_ma (ncb_p np, u_char dstat)
{
	u_int32_t	dbc;
	u_int32_t	rest;
	u_int32_t	dsa;
	u_int32_t	dsp;
	u_int32_t	nxtdsp;
	void	*vdsp_base;
	size_t	vdsp_off;
	u_int32_t	oadr, olen;
	u_int32_t	*tblp;
	ncrcmd	*newcmd;
	u_int32_t	cmd, sbcl, delta, ss0, ss2, ctest5;
	ccb_p	cp;

	dsp = INL (nc_dsp);
	dsa = INL (nc_dsa);
	dbc = INL (nc_dbc);
	ss0 = INB (nc_sstat0);
	ss2 = INB (nc_sstat2);
	sbcl= INB (nc_sbcl);

	cmd = dbc >> 24;
	rest= dbc & 0xffffff;

	ctest5 = (np->rv_ctest5 & DFS) ? INB (nc_ctest5) : 0;
	if (ctest5 & DFS)
		delta=(((ctest5<<8) | (INB (nc_dfifo) & 0xff)) - rest) & 0x3ff;
	else
		delta=(INB (nc_dfifo) - rest) & 0x7f;


	/*
	**	The data in the dma fifo has not been transferred to
	**	the target -> add the amount to the rest
	**	and clear the data.
	**	Check the sstat2 register in case of wide transfer.
	*/

	if (!(dstat & DFE)) rest += delta;
	if (ss0 & OLF) rest++;
	if (ss0 & ORF) rest++;
	if (INB(nc_scntl3) & EWS) {
		if (ss2 & OLF1) rest++;
		if (ss2 & ORF1) rest++;
	};
	OUTB (nc_ctest3, np->rv_ctest3 | CLF);	/* clear dma fifo  */
	OUTB (nc_stest3, TE|CSF);		/* clear scsi fifo */

	/*
	**	locate matching cp
	*/
	dsa = INL (nc_dsa);
	cp = np->ccb;
	while (cp && (CCB_PHYS (cp, phys) != dsa))
		cp = cp->link_ccb;

	if (!cp) {
	    printf ("%s: SCSI phase error fixup: CCB already dequeued (%p)\n",
		    ncr_name (np), np->header.cp);
	    return;
	}
	if (cp != np->header.cp) {
	    printf ("%s: SCSI phase error fixup: CCB address mismatch (0x%08lx != 0x%08lx) np->ccb = %p\n",
		    ncr_name (np), (u_long) cp, (u_long) np->header.cp, np->ccb);
/*	    return;*/
	}

	/*
	**	find the interrupted script command,
	**	and the address at which to continue.
	*/

	if (dsp == NCR_KVATOPHYS (np, &cp->patch[2])) {
		vdsp_base = cp;
		vdsp_off = offsetof(struct ccb, patch[0]);
		nxtdsp = READSCRIPT_OFF(vdsp_base, vdsp_off + 3*4);
	} else if (dsp == NCR_KVATOPHYS (np, &cp->patch[6])) {
		vdsp_base = cp;
		vdsp_off = offsetof(struct ccb, patch[4]);
		nxtdsp = READSCRIPT_OFF(vdsp_base, vdsp_off + 3*4);
	} else if (dsp > np->p_script &&
		   dsp <= np->p_script + sizeof(struct script)) {
		vdsp_base = np->script;
		vdsp_off = dsp - np->p_script - 8;
		nxtdsp = dsp;
	} else {
		vdsp_base = np->scripth;
		vdsp_off = dsp - np->p_scripth - 8;
		nxtdsp = dsp;
	};

	/*
	**	log the information
	*/
	if (DEBUG_FLAGS & (DEBUG_TINY|DEBUG_PHASE)) {
		printf ("P%x%x ",cmd&7, sbcl&7);
		printf ("RL=%d D=%d SS0=%x ",
			(unsigned) rest, (unsigned) delta, ss0);
	};
	if (DEBUG_FLAGS & DEBUG_PHASE) {
		printf ("\nCP=%p CP2=%p DSP=%x NXT=%x VDSP_BASE=%p VDSP_OFF=0x%x CMD=%x ",
			cp, np->header.cp, (unsigned)dsp,
			(unsigned)nxtdsp, vdsp_base, (unsigned)vdsp_off, cmd);
	};

	/*
	**	get old startaddress and old length.
	*/

	oadr = READSCRIPT_OFF(vdsp_base, vdsp_off + 1*4);

	if (cmd & 0x10) {	/* Table indirect */
		tblp = (u_int32_t *) ((char *) &cp->phys + oadr);
		olen = SCR_BO(tblp[0]);
		oadr = SCR_BO(tblp[1]);
	} else {
		tblp = (u_int32_t *) 0;
		olen = READSCRIPT_OFF(vdsp_base, vdsp_off) & 0xffffff;
	};

	if (DEBUG_FLAGS & DEBUG_PHASE) {
		printf ("OCMD=%x\nTBLP=%p OLEN=%x OADR=%x\n",
			(unsigned) (READSCRIPT_OFF(vdsp_base, vdsp_off) >> 24),
			tblp,
			(unsigned) olen,
			(unsigned) oadr);
	};

	/*
	**	if old phase not dataphase, leave here.
	*/

	if (cmd != (READSCRIPT_OFF(vdsp_base, vdsp_off) >> 24)) {
		PRINT_ADDR(cp->xfer);
		printf ("internal error: cmd=%02x != %02x=(vdsp[0] >> 24)\n",
			(unsigned)cmd,
			(unsigned)READSCRIPT_OFF(vdsp_base, vdsp_off) >> 24);
		
		return;
	}
	if (cmd & 0x06) {
		PRINT_ADDR(cp->xfer);
		printf ("phase change %x-%x %d@@%08x resid=%d.\n",
			cmd&7, sbcl&7, (unsigned)olen,
			(unsigned)oadr, (unsigned)rest);

		OUTB (nc_dcntl, np->rv_dcntl | STD);
		return;
	};

	/*
	**	choose the correct patch area.
	**	if savep points to one, choose the other.
	*/

	newcmd = cp->patch;
	if (cp->phys.header.savep == SCR_BO(NCR_KVATOPHYS (np, newcmd))) newcmd+=4;

	/*
	**	fillin the commands
	*/

	newcmd[0] = SCR_BO(((cmd & 0x0f) << 24) | rest);
	newcmd[1] = SCR_BO(oadr + olen - rest);
	newcmd[2] = SCR_BO(SCR_JUMP);
	newcmd[3] = SCR_BO(nxtdsp);

	if (DEBUG_FLAGS & DEBUG_PHASE) {
		PRINT_ADDR(cp->xfer);
		printf ("newcmd[%ld] %x %x %x %x.\n",
			(long)(newcmd - cp->patch),
			(unsigned)newcmd[0],
			(unsigned)newcmd[1],
			(unsigned)newcmd[2],
			(unsigned)newcmd[3]);
	}
	/*
	**	fake the return address (to the patch).
	**	and restart script processor at dispatcher.
	*/
	np->profile.num_break++;
	OUTL (nc_temp, NCR_KVATOPHYS (np, newcmd));
	if ((cmd & 7) == 0)
		OUTL (nc_dsp, NCB_SCRIPT_PHYS (np, dispatch));
	else
		OUTL (nc_dsp, NCB_SCRIPT_PHYS (np, checkatn));
}

/*==========================================================
**
**
**      ncr chip exception handler for programmed interrupts.
**
**
**==========================================================
*/

static int ncr_show_msg (u_char * msg)
{
	u_char i;
	printf ("%x",*msg);
	if (*msg==M_EXTENDED) {
		for (i=1;i<8;i++) {
			if (i-1>msg[1]) break;
			printf ("-%x",msg[i]);
		};
		return (i+1);
	} else if ((*msg & 0xf0) == 0x20) {
		printf ("-%x",msg[1]);
		return (2);
	};
	return (1);
}

void ncr_int_sir (ncb_p np)
{
	u_char scntl3;
	u_char chg, ofs, per, fak, wide;
	u_char num = INB (nc_dsps);
	ccb_p	cp=0;
	u_long	dsa;
	u_char	target = INB (nc_sdid) & 0x0f;
	tcb_p	tp     = &np->target[target];
	int     i;
	if (DEBUG_FLAGS & DEBUG_TINY) printf ("I#%d", num);

	switch (num) {
	case SIR_SENSE_RESTART:
	case SIR_STALL_RESTART:
		break;

	default:
		/*
		**	lookup the ccb
		*/
		dsa = INL (nc_dsa);
		cp = np->ccb;
		while (cp && (CCB_PHYS (cp, phys) != dsa))
			cp = cp->link_ccb;

		assert (cp);
		if (!cp)
			goto out;
		assert (cp == np->header.cp);
		if (cp != np->header.cp)
			goto out;
	}

	switch (num) {

/*--------------------------------------------------------------------
**
**	Processing of interrupted getcc selects
**
**--------------------------------------------------------------------
*/

	case SIR_SENSE_RESTART:
		/*------------------------------------------
		**	Script processor is idle.
		**	Look for interrupted "check cond"
		**------------------------------------------
		*/

		if (DEBUG_FLAGS & DEBUG_RESTART)
			printf ("%s: int#%d",ncr_name (np),num);
		cp = (ccb_p) 0;
		for (i=0; i<MAX_TARGET; i++) {
			if (DEBUG_FLAGS & DEBUG_RESTART) printf (" t%d", i);
			tp = &np->target[i];
			if (DEBUG_FLAGS & DEBUG_RESTART) printf ("+");
			cp = tp->hold_cp;
			if (!cp) continue;
			if (DEBUG_FLAGS & DEBUG_RESTART) printf ("+");
			if ((cp->host_status==HS_BUSY) &&
				(cp->scsi_status==S_CHECK_COND))
				break;
			if (DEBUG_FLAGS & DEBUG_RESTART) printf ("- (remove)");
			tp->hold_cp = cp = (ccb_p) 0;
		};

		if (cp) {
			if (DEBUG_FLAGS & DEBUG_RESTART)
				printf ("+ restart job ..\n");
			OUTL (nc_dsa, CCB_PHYS (cp, phys));
			OUTL (nc_dsp, NCB_SCRIPTH_PHYS (np, getcc));
			return;
		};

		/*
		**	no job, resume normal processing
		*/
		if (DEBUG_FLAGS & DEBUG_RESTART) printf (" -- remove trap\n");
		WRITESCRIPT(start0[0], SCR_INT ^ IFFALSE (0));
		break;

	case SIR_SENSE_FAILED:
		/*-------------------------------------------
		**	While trying to select for
		**	getting the condition code,
		**	a target reselected us.
		**-------------------------------------------
		*/
		if (DEBUG_FLAGS & DEBUG_RESTART) {
			PRINT_ADDR(cp->xfer);
			printf ("in getcc reselect by t%d.\n",
				INB(nc_ssid) & 0x0f);
		}

		/*
		**	Mark this job
		*/
		cp->host_status = HS_BUSY;
		cp->scsi_status = S_CHECK_COND;
		np->target[cp->xfer->sc_link->target].hold_cp = cp;

		/*
		**	And patch code to restart it.
		*/
		WRITESCRIPT(start0[0], SCR_INT);
		break;

/*-----------------------------------------------------------------------------
**
**	Was Sie schon immer ueber transfermode negotiation wissen wollten ...
**
**	We try to negotiate sync and wide transfer only after
**	a successful inquire command. We look at byte 7 of the
**	inquire data to determine the capabilities if the target.
**
**	When we try to negotiate, we append the negotiation message
**	to the identify and (maybe) simple tag message.
**	The host status field is set to HS_NEGOTIATE to mark this
**	situation.
**
**	If the target doesn't answer this message immidiately
**	(as required by the standard), the SIR_NEGO_FAIL interrupt
**	will be raised eventually.
**	The handler removes the HS_NEGOTIATE status, and sets the
**	negotiated value to the default (async / nowide).
**
**	If we receive a matching answer immediately, we check it
**	for validity, and set the values.
**
**	If we receive a Reject message immediately, we assume the
**	negotiation has failed, and fall back to standard values.
**
**	If we receive a negotiation message while not in HS_NEGOTIATE
**	state, it's a target initiated negotiation. We prepare a
**	(hopefully) valid answer, set our parameters, and send back
**	this answer to the target.
**
**	If the target doesn't fetch the answer (no message out phase),
**	we assume the negotiation has failed, and fall back to default
**	settings.
**
**	When we set the values, we adjust them in all ccbs belonging
**	to this target, in the controller's register, and in the "phys"
**	field of the controller's struct ncb.
**
**	Possible cases:		   hs  sir   msg_in value  send   goto
**	We try try to negotiate:
**	-> target doesnt't msgin   NEG FAIL  noop   defa.  -      dispatch
**	-> target rejected our msg NEG FAIL  reject defa.  -      dispatch
**	-> target answered  (ok)   NEG SYNC  sdtr   set    -      clrack
**	-> target answered (!ok)   NEG SYNC  sdtr   defa.  REJ--->msg_bad
**	-> target answered  (ok)   NEG WIDE  wdtr   set    -      clrack
**	-> target answered (!ok)   NEG WIDE  wdtr   defa.  REJ--->msg_bad
**	-> any other msgin	   NEG FAIL  noop   defa.  -      dispatch
**
**	Target tries to negotiate:
**	-> incoming message	   --- SYNC  sdtr   set    SDTR   -
**	-> incoming message	   --- WIDE  wdtr   set    WDTR   -
**      We sent our answer:
**	-> target doesn't msgout   --- PROTO ?      defa.  -      dispatch
**
**-----------------------------------------------------------------------------
*/

	case SIR_NEGO_FAILED:
		/*-------------------------------------------------------
		**
		**	Negotiation failed.
		**	Target doesn't send an answer message,
		**	or target rejected our message.
		**
		**      Remove negotiation request.
		**
		**-------------------------------------------------------
		*/
		OUTB (HS_PRT, HS_BUSY);

		/* fall through */

	case SIR_NEGO_PROTO:
		/*-------------------------------------------------------
		**
		**	Negotiation failed.
		**	Target doesn't fetch the answer message.
		**
		**-------------------------------------------------------
		*/

		if (DEBUG_FLAGS & DEBUG_NEGO) {
			PRINT_ADDR(cp->xfer);
			printf ("negotiation failed sir=%x status=%x.\n",
				num, cp->nego_status);
		};

		/*
		**	any error in negotiation:
		**	fall back to default mode.
		*/
		switch (cp->nego_status) {

		case NS_SYNC:
			ncr_setsync (np, cp, 0, 0xe0);
			break;

		case NS_WIDE:
			ncr_setwide (np, cp, 0, 0);
			break;

		};
		np->msgin [0] = M_NOOP;
		np->msgout[0] = M_NOOP;
		cp->nego_status = 0;
		OUTL (nc_dsp, NCB_SCRIPT_PHYS (np, dispatch));
		break;

	case SIR_NEGO_SYNC:
		/*
		**	Synchronous request message received.
		*/

		if (DEBUG_FLAGS & DEBUG_NEGO) {
			PRINT_ADDR(cp->xfer);
			printf ("sync msgin: ");
			(void) ncr_show_msg (np->msgin);
			printf (".\n");
		};

		/*
		**	get requested values.
		*/

		chg = 0;
		per = np->msgin[3];
		ofs = np->msgin[4];
		if (ofs==0) per=255;

		/*
		**      if target sends SDTR message,
		**	      it CAN transfer synch.
		*/

		if (ofs)
			tp->inqdata[7] |= INQ7_SYNC;

		/*
		**	check values against driver limits.
		*/

		if (per < np->minsync)
			{chg = 1; per = np->minsync;}
		if (per < tp->minsync)
			{chg = 1; per = tp->minsync;}
		if (ofs > tp->maxoffs)
			{chg = 1; ofs = tp->maxoffs;}

		/*
		**	Check against controller limits.
		*/

		fak	= 7;
		scntl3	= 0;
		if (ofs != 0) {
			ncr_getsync(np, per, &fak, &scntl3);
			if (fak > 7) {
				chg = 1;
				ofs = 0;
			}
		}
		if (ofs == 0) {
			fak	= 7;
			per	= 0;
			scntl3	= 0;
			tp->minsync = 0;
		}

		if (DEBUG_FLAGS & DEBUG_NEGO) {
			PRINT_ADDR(cp->xfer);
			printf ("sync: per=%d scntl3=0x%x ofs=%d fak=%d chg=%d.\n",
				per, scntl3, ofs, fak, chg);
		}

		if (INB (HS_PRT) == HS_NEGOTIATE) {
			OUTB (HS_PRT, HS_BUSY);
			switch (cp->nego_status) {

			case NS_SYNC:
				/*
				**      This was an answer message
				*/
				if (chg) {
					/*
					**	Answer wasn't acceptable.
					*/
					ncr_setsync (np, cp, 0, 0xe0);
					OUTL (nc_dsp, NCB_SCRIPT_PHYS (np, msg_bad));
				} else {
					/*
					**	Answer is ok.
					*/
					ncr_setsync (np,cp,scntl3,(fak<<5)|ofs);
					OUTL (nc_dsp, NCB_SCRIPT_PHYS (np, clrack));
				};
				return;

			case NS_WIDE:
				ncr_setwide (np, cp, 0, 0);
				break;
			};
		};

		/*
		**	It was a request. Set value and
		**      prepare an answer message
		*/

		ncr_setsync (np, cp, scntl3, (fak<<5)|ofs);

		np->msgout[0] = M_EXTENDED;
		np->msgout[1] = 3;
		np->msgout[2] = M_X_SYNC_REQ;
		np->msgout[3] = per;
		np->msgout[4] = ofs;

		cp->nego_status = NS_SYNC;

		if (DEBUG_FLAGS & DEBUG_NEGO) {
			PRINT_ADDR(cp->xfer);
			printf ("sync msgout: ");
			(void) ncr_show_msg (np->msgout);
			printf (".\n");
		}

		if (!ofs) {
			OUTL (nc_dsp, NCB_SCRIPT_PHYS (np, msg_bad));
			return;
		}
		np->msgin [0] = M_NOOP;

		break;

	case SIR_NEGO_WIDE:
		/*
		**	Wide request message received.
		*/
		if (DEBUG_FLAGS & DEBUG_NEGO) {
			PRINT_ADDR(cp->xfer);
			printf ("wide msgin: ");
			(void) ncr_show_msg (np->msgin);
			printf (".\n");
		};

		/*
		**	get requested values.
		*/

		chg  = 0;
		wide = np->msgin[3];

		/*
		**      if target sends WDTR message,
		**	      it CAN transfer wide.
		*/

		if (wide)
			tp->inqdata[7] |= INQ7_WIDE16;

		/*
		**	check values against driver limits.
		*/

		if (wide > tp->usrwide)
			{chg = 1; wide = tp->usrwide;}

		if (DEBUG_FLAGS & DEBUG_NEGO) {
			PRINT_ADDR(cp->xfer);
			printf ("wide: wide=%d chg=%d.\n", wide, chg);
		}

		if (INB (HS_PRT) == HS_NEGOTIATE) {
			OUTB (HS_PRT, HS_BUSY);
			switch (cp->nego_status) {

			case NS_WIDE:
				/*
				**      This was an answer message
				*/
				if (chg) {
					/*
					**	Answer wasn't acceptable.
					*/
					ncr_setwide (np, cp, 0, 1);
					OUTL (nc_dsp, NCB_SCRIPT_PHYS (np, msg_bad));
				} else {
					/*
					**	Answer is ok.
					*/
					ncr_setwide (np, cp, wide, 1);
					OUTL (nc_dsp, NCB_SCRIPT_PHYS (np, clrack));
				};
				return;

			case NS_SYNC:
				ncr_setsync (np, cp, 0, 0xe0);
				break;
			};
		};

		/*
		**	It was a request, set value and
		**      prepare an answer message
		*/

		ncr_setwide (np, cp, wide, 1);

		np->msgout[0] = M_EXTENDED;
		np->msgout[1] = 2;
		np->msgout[2] = M_X_WIDE_REQ;
		np->msgout[3] = wide;

		np->msgin [0] = M_NOOP;

		cp->nego_status = NS_WIDE;

		if (DEBUG_FLAGS & DEBUG_NEGO) {
			PRINT_ADDR(cp->xfer);
			printf ("wide msgout: ");
			(void) ncr_show_msg (np->msgout);
			printf (".\n");
		}
		break;

/*--------------------------------------------------------------------
**
**	Processing of special messages
**
**--------------------------------------------------------------------
*/

	case SIR_REJECT_RECEIVED:
		/*-----------------------------------------------
		**
		**	We received a M_REJECT message.
		**
		**-----------------------------------------------
		*/

		PRINT_ADDR(cp->xfer);
		printf ("M_REJECT received (%x:%x).\n",
			(unsigned)np->lastmsg, np->msgout[0]);
		break;

	case SIR_REJECT_SENT:
		/*-----------------------------------------------
		**
		**	We received an unknown message
		**
		**-----------------------------------------------
		*/

		PRINT_ADDR(cp->xfer);
		printf ("M_REJECT sent for ");
		(void) ncr_show_msg (np->msgin);
		printf (".\n");
		break;

/*--------------------------------------------------------------------
**
**	Processing of special messages
**
**--------------------------------------------------------------------
*/

	case SIR_IGN_RESIDUE:
		/*-----------------------------------------------
		**
		**	We received an IGNORE RESIDUE message,
		**	which couldn't be handled by the script.
		**
		**-----------------------------------------------
		*/

		PRINT_ADDR(cp->xfer);
		printf ("M_IGN_RESIDUE received, but not yet implemented.\n");
		break;

	case SIR_MISSING_SAVE:
		/*-----------------------------------------------
		**
		**	We received an DISCONNECT message,
		**	but the datapointer wasn't saved before.
		**
		**-----------------------------------------------
		*/

		PRINT_ADDR(cp->xfer);
		printf ("M_DISCONNECT received, but datapointer not saved:\n"
			"\tdata=%x save=%x goal=%x.\n",
			(unsigned) INL (nc_temp),
			SCR_BO((unsigned) np->header.savep),
			SCR_BO((unsigned) np->header.goalp));
		break;

/*--------------------------------------------------------------------
**
**	Processing of a "S_QUEUE_FULL" status.
**
**	The current command has been rejected,
**	because there are too many in the command queue.
**	We have started too many commands for that target.
**
**	If possible, reinsert at head of queue.
**	Stall queue until there are no disconnected jobs
**	(ncr is REALLY idle). Then restart processing.
**
**	We should restart the current job after the controller
**	has become idle. But this is not yet implemented.
**
**--------------------------------------------------------------------
*/
	case SIR_STALL_QUEUE:
		/*-----------------------------------------------
		**
		**	Stall the start queue.
		**
		**-----------------------------------------------
		*/
		PRINT_ADDR(cp->xfer);
		printf ("queue full.\n");

		WRITESCRIPT(start1[0], SCR_INT);

		/*
		**	Try to disable tagged transfers.
		*/
		ncr_setmaxtags (&np->target[target], 0);

		/*
		** @@QUEUE@@
		**
		**	Should update the launch field of the
		**	current job to be able to restart it.
		**	Then prepend it to the start queue.
		*/

		/* fall through */

	case SIR_STALL_RESTART:
		/*-----------------------------------------------
		**
		**	Enable selecting again,
		**	if NO disconnected jobs.
		**
		**-----------------------------------------------
		*/
		/*
		**	Look for a disconnected job.
		*/
		cp = np->ccb;
		while (cp && cp->host_status != HS_DISCONNECT)
			cp = cp->link_ccb;

		/*
		**	if there is one, ...
		*/
		if (cp) {
			/*
			**	wait for reselection
			*/
			OUTL (nc_dsp, NCB_SCRIPT_PHYS (np, reselect));
			return;
		};

		/*
		**	else remove the interrupt.
		*/

		printf ("%s: queue empty.\n", ncr_name (np));
		WRITESCRIPT(start1[0], SCR_INT ^ IFFALSE (0));
		break;
	};

out:
	OUTB (nc_dcntl, np->rv_dcntl | STD);
}

/*==========================================================
**
**
**	Acquire a control block
**
**
**==========================================================
*/

static	ccb_p ncr_get_ccb
	(ncb_p np, u_long flags, u_long target, u_long lun)
{
	lcb_p lp;
	ccb_p cp = (ccb_p) 0;
	int oldspl;

	oldspl = splbio();
	/*
	**	Lun structure available ?
	*/

	lp = np->target[target].lp[lun];
	if (lp) {
		cp = lp->next_ccb;

		/*
		**	Look for free CCB
		*/

		while (cp && cp->magic) {
			cp = cp->next_ccb;
		}
	}

	/*
	**	if nothing available, take the default.
	*/

	if (!cp) cp = np->ccb;

	/*
	**	Wait until available.
	*/

	while (cp->magic) {
		if (flags & SCSI_NOSLEEP) break;
		if (tsleep ((caddr_t)cp, PRIBIO|PCATCH, "ncr", 0))
			break;
	};

	if (cp->magic) {
		splx(oldspl);
		return ((ccb_p) 0);
	}

	cp->magic = 1;
	splx(oldspl);
	return (cp);
}

/*==========================================================
**
**
**	Release one control block
**
**
**==========================================================
*/

void ncr_free_ccb (ncb_p np, ccb_p cp, int flags)
{
	/*
	**    sanity
	*/

	assert (cp != NULL);

	cp -> host_status = HS_IDLE;
	cp -> magic = 0;
	if (cp == np->ccb)
		wakeup ((caddr_t) cp);
}

/*==========================================================
**
**
**      Allocation of resources for Targets/Luns/Tags.
**
**
**==========================================================
*/

static	void ncr_alloc_ccb (ncb_p np, u_long target, u_long lun)
{
	tcb_p tp;
	lcb_p lp;
	ccb_p cp;

	assert (np != NULL);

	if (target>=MAX_TARGET) return;
	if (lun   >=MAX_LUN   ) return;

	tp=&np->target[target];

	if (!tp->jump_tcb.l_cmd) {

		/*
		**	initialize it.
		*/
		tp->jump_tcb.l_cmd   = SCR_BO((SCR_JUMP^IFFALSE (DATA (0x80 + target))));
		tp->jump_tcb.l_paddr = np->jump_tcb.l_paddr;

		tp->getscr[0] =
			(np->features & FE_PFEN)? SCR_BO(SCR_COPY(1)) : SCR_BO(SCR_COPY_F(1));
		tp->getscr[1] = SCR_BO(NCR_KVATOPHYS (np, &tp->sval));
		tp->getscr[2] = SCR_BO(np->paddr + offsetof (struct ncr_reg, nc_sxfer));
		tp->getscr[3] = tp->getscr[0];
		tp->getscr[4] = SCR_BO(NCR_KVATOPHYS (np, &tp->wval));
		tp->getscr[5] = SCR_BO(np->paddr + offsetof (struct ncr_reg, nc_scntl3));

		assert (( (offsetof(struct ncr_reg, nc_sxfer) ^
			offsetof(struct tcb    , sval    )) &3) == 0);
		assert (( (offsetof(struct ncr_reg, nc_scntl3) ^
			offsetof(struct tcb    , wval    )) &3) == 0);

		tp->call_lun.l_cmd   = SCR_BO((SCR_CALL));
		tp->call_lun.l_paddr = SCR_BO(NCB_SCRIPT_PHYS (np, resel_lun));

		tp->jump_lcb.l_cmd   = SCR_BO((SCR_JUMP));
		tp->jump_lcb.l_paddr = SCR_BO(NCB_SCRIPTH_PHYS (np, abort));
		np->jump_tcb.l_paddr = SCR_BO(NCR_KVATOPHYS (np, &tp->jump_tcb));

		tp->usrtags = SCSI_NCR_DFLT_TAGS;
		ncr_setmaxtags (tp, tp->usrtags);
	}

	/*
	**	Logic unit control block
	*/
	lp = tp->lp[lun];
	if (!lp) {
		/*
		**	Allocate a lcb
		*/
		lp = (lcb_p) malloc (sizeof (struct lcb), M_DEVBUF, M_NOWAIT);
		if (!lp) return;

#if defined(__mips__)
		pci_sync_cache(np->sc_pc, (vm_offset_t)lp, sizeof (struct lcb));
		lp = (struct lcb *)PHYS_TO_UNCACHED(NCR_KVATOPHYS(np, lp));
#endif /* __mips__ */

		/*
		**	Initialize it
		*/
		bzero (lp, sizeof (*lp));
		lp->jump_lcb.l_cmd   = SCR_BO((SCR_JUMP ^ IFFALSE (DATA (lun))));
		lp->jump_lcb.l_paddr = tp->jump_lcb.l_paddr;

		lp->call_tag.l_cmd   = SCR_BO((SCR_CALL));
		lp->call_tag.l_paddr = SCR_BO(NCB_SCRIPT_PHYS (np, resel_tag));

		lp->jump_ccb.l_cmd   = SCR_BO((SCR_JUMP));
		lp->jump_ccb.l_paddr = SCR_BO(NCB_SCRIPTH_PHYS (np, aborttag));

		lp->actlink = 1;

		/*
		**   Chain into LUN list
		*/
		tp->jump_lcb.l_paddr = SCR_BO(NCR_KVATOPHYS (np, &lp->jump_lcb));
		tp->lp[lun] = lp;

	}

	/*
	**	Limit possible number of ccbs.
	**
	**	If tagged command queueing is enabled,
	**	can use more than one ccb.
	*/

	if (np->actccbs >= MAX_START-2)
		return;
	if (lp->actccbs && (lp->actccbs >= lp->reqccbs))
		return;

	/*
	**	Allocate a ccb
	*/
	cp = (ccb_p) malloc (sizeof (struct ccb), M_DEVBUF, M_NOWAIT);

	if (!cp)
		return;

#if defined(__mips__)
	pci_sync_cache(np->sc_pc, (vm_offset_t)cp, sizeof (struct ccb));
	cp = (struct ccb *)PHYS_TO_UNCACHED(NCR_KVATOPHYS(np, cp));
#endif /* __mips__ */

	if (DEBUG_FLAGS & DEBUG_ALLOC) {
		printf ("new ccb @@%p.\n", cp);
	}

	/*
	**	Count it
	*/
	lp->actccbs++;
	np->actccbs++;

	/*
	**	Initialize it
	*/
	bzero (cp, sizeof (*cp));

	/*
	**	Fill in physical addresses
	*/

	cp->p_ccb	     = NCR_KVATOPHYS (np, cp);

	/*
	**	Chain into reselect list
	*/
	cp->jump_ccb.l_cmd   = SCR_BO(SCR_JUMP);
	cp->jump_ccb.l_paddr = lp->jump_ccb.l_paddr;
	lp->jump_ccb.l_paddr = SCR_BO(CCB_PHYS (cp, jump_ccb));
	cp->call_tmp.l_cmd   = SCR_BO(SCR_CALL);
	cp->call_tmp.l_paddr = SCR_BO(NCB_SCRIPT_PHYS (np, resel_tmp));

	/*
	**	Chain into wakeup list
	*/
	cp->link_ccb      = np->ccb->link_ccb;
	np->ccb->link_ccb  = cp;

	/*
	**	Chain into CCB list
	*/
	cp->next_ccb	= lp->next_ccb;
	lp->next_ccb	= cp;
}

/*==========================================================
**
**
**	Announce the number of ccbs/tags to the scsi driver.
**
**
**==========================================================
*/

static void ncr_opennings (ncb_p np, lcb_p lp, struct scsi_xfer * xp)
{
	/*
	**	want to reduce the number ...
	*/
	if (lp->actlink > lp->reqlink) {

		/*
		**	Try to  reduce the count.
		**	We assume to run at splbio ..
		*/
		u_char diff = lp->actlink - lp->reqlink;

		if (!diff) return;

#ifdef __OpenBSD__
		if (diff > xp->sc_link->openings)
			diff = xp->sc_link->openings;

		xp->sc_link->openings	-= diff;
#else
		if (diff > xp->sc_link->opennings)
			diff = xp->sc_link->opennings;

		xp->sc_link->opennings	-= diff;
#endif
		lp->actlink		-= diff;
		if (DEBUG_FLAGS & DEBUG_TAGS)
			printf ("%s: actlink: diff=%d, new=%d, req=%d\n",
				ncr_name(np), diff, lp->actlink, lp->reqlink);
		return;
	};

	/*
	**	want to increase the number ?
	*/
	if (lp->reqlink > lp->actlink) {
		u_char diff = lp->reqlink - lp->actlink;

		xp->sc_link->openings	+= diff;
		lp->actlink		+= diff;
		wakeup ((caddr_t) xp->sc_link);
		if (DEBUG_FLAGS & DEBUG_TAGS)
			printf ("%s: actlink: diff=%d, new=%d, req=%d\n",
				ncr_name(np), diff, lp->actlink, lp->reqlink);
	};
}

/*==========================================================
**
**
**	Build Scatter Gather Block
**
**
**==========================================================
**
**	The transfer area may be scattered among
**	several non adjacent physical pages.
**
**	We may use MAX_SCATTER blocks.
**
**----------------------------------------------------------
*/

static	int	ncr_scatter
	(ncb_p np, struct dsb* phys, vm_offset_t vaddr, vm_size_t datalen)
{
	u_long	paddr, pnext;

	u_short	segment  = 0;
	u_long	segsize, segaddr;
	u_long	size, csize    = 0;
	u_long	chunk = MAX_SIZE;
	int	free;

	bzero (&phys->data, sizeof (phys->data));
	if (!datalen) return (0);

	paddr = NCR_KVATOPHYS (np, (void *)vaddr);

	/*
	**	insert extra break points at a distance of chunk.
	**	We try to reduce the number of interrupts caused
	**	by unexpected phase changes due to disconnects.
	**	A typical harddisk may disconnect before ANY block.
	**	If we wanted to avoid unexpected phase changes at all
	**	we had to use a break point every 512 bytes.
	**	Of course the number of scatter/gather blocks is
	**	limited.
	*/

	free = MAX_SCATTER - 1;

#ifdef __OpenBSD__
	if (vaddr & (NBPG-1)) free -= datalen / NBPG;
#else
	if (vaddr & PAGE_MASK) free -= datalen / PAGE_SIZE;
#endif

	if (free>1)
		while ((chunk * free >= 2 * datalen) && (chunk>=1024))
			chunk /= 2;

	if(DEBUG_FLAGS & DEBUG_SCATTER)
		printf("ncr?:\tscattering virtual=0x%x size=%d chunk=%d.\n",
			(unsigned) vaddr, (unsigned) datalen, (unsigned) chunk);

	/*
	**   Build data descriptors.
	*/
	while (datalen && (segment < MAX_SCATTER)) {

		/*
		**	this segment is empty
		*/
		segsize = 0;
		segaddr = paddr;
		pnext   = paddr;

		if (!csize) csize = chunk;

		while ((datalen) && (paddr == pnext) && (csize)) {

			/*
			**	continue this segment
			*/
#ifdef __OpenBSD__
			pnext = (paddr & (~(NBPG - 1))) + NBPG;
#else
			pnext = (paddr & (~PAGE_MASK)) + PAGE_SIZE;
#endif

			/*
			**	Compute max size
			*/

			size = pnext - paddr;		/* page size */
			if (size > datalen) size = datalen;  /* data size */
			if (size > csize  ) size = csize  ;  /* chunksize */

			segsize += size;
			vaddr   += size;
			csize   -= size;
			datalen -= size;
			paddr    = NCR_KVATOPHYS (np, (void *)vaddr);
		};

		if(DEBUG_FLAGS & DEBUG_SCATTER)
			printf ("\tseg #%d  addr=%x  size=%d  (rest=%d).\n",
			segment,
			(unsigned) segaddr,
			(unsigned) segsize,
			(unsigned) datalen);

		phys->data[segment].addr = SCR_BO(segaddr);
		phys->data[segment].size = SCR_BO(segsize);
		segment++;
	}

	if (datalen) {
		printf("ncr?: scatter/gather failed (residue=%d).\n",
			(unsigned) datalen);
		return (-1);
	};

	return (segment);
}

/*==========================================================
**
**
**	Test the pci bus snoop logic :-(
**
**	Has to be called with interrupts disabled.
**
**
**==========================================================
*/

#if !defined(NCR_IOMAPPED) || defined(__OpenBSD__)
static int ncr_regtest (struct ncb* np)
{
	register volatile u_int32_t data;
	/*
	**	ncr registers may NOT be cached.
	**	write 0xffffffff to a read only register area,
	**	and try to read it back.
	*/
	data = 0xffffffff;
	OUTL_OFF(offsetof(struct ncr_reg, nc_dstat), data);
	data = INL_OFF(offsetof(struct ncr_reg, nc_dstat));
#if 1
	if (data == 0xffffffff) {
#else
	if ((data & 0xe2f0fffd) != 0x02000080) {
#endif
		printf ("CACHE TEST FAILED: reg dstat-sstat2 readback %x.\n",
			(unsigned) data);
		return (0x10);
	};
	return (0);
}
#endif

static int ncr_snooptest (struct ncb* np)
{
	volatile u_int32_t ncr_rd, ncr_wr, ncr_bk, host_rd, host_wr, pc;
	int	i, err=0;

#if !defined(NCR_IOMAPPED) || defined(__OpenBSD__)
#ifdef __OpenBSD__
	if (!np->sc_iomapped)
#endif
	{
		err |= ncr_regtest (np);
		if (err) return (err);
	}
#endif
	/*
	**	init
	*/
	pc  = NCB_SCRIPTH_PHYS (np, snooptest);
	host_wr = 1;
	ncr_wr  = 2;
	/*
	**	Set memory and register.
	*/
	ncr_cache = host_wr;
#if defined(__mips__)
	pci_sync_cache(np->sc_pc, (vm_offset_t)&ncr_cache, sizeof (ncr_cache));
#endif /* __mips__ */
	OUTL (nc_temp, SCR_BO(ncr_wr));
	/*
	**	Start script (exchange values)
	*/
	OUTL (nc_dsp, pc);
	/*
	**	Wait 'til done (with timeout)
	*/
	for (i=0; i<NCR_SNOOP_TIMEOUT; i++)
		if (INB(nc_istat) & (INTF|SIP|DIP))
			break;
	/*
	**	Save termination position.
	*/
	pc = INL (nc_dsp);
	/*
	**	Read memory and register.
	*/
	host_rd = ncr_cache;
	ncr_rd  = SCR_BO(INL (nc_scratcha));
	ncr_bk  = SCR_BO(INL (nc_temp));
	/*
	**	Reset ncr chip
	*/
	OUTB (nc_istat,  SRST);
	DELAY (1000);
	OUTB (nc_istat,  0   );
	/*
	**	check for timeout
	*/
	if (i>=NCR_SNOOP_TIMEOUT) {
		printf ("CACHE TEST FAILED: timeout.\n");
		return (0x20);
	};
	/*
	**	Check termination position.
	*/
	if (pc != NCB_SCRIPTH_PHYS (np, snoopend)+8) {
		printf ("CACHE TEST FAILED: script execution failed.\n");
		printf ("start=%08lx, pc=%08lx, end=%08lx\n",
			(u_long) NCB_SCRIPTH_PHYS (np, snooptest), (u_long) pc,
			(u_long) NCB_SCRIPTH_PHYS (np, snoopend) +8);
		return (0x40);
	};
	/*
	**	Show results.
	*/
	if (host_wr != ncr_rd) {
		printf ("CACHE TEST FAILED: host wrote %d, ncr read %d.\n",
			(int) host_wr, (int) ncr_rd);
		err |= 1;
	};
	if (host_rd != ncr_wr) {
		printf ("CACHE TEST FAILED: ncr wrote %d, host read %d.\n",
			(int) ncr_wr, (int) host_rd);
		err |= 2;
	};
	if (ncr_bk != ncr_wr) {
		printf ("CACHE TEST FAILED: ncr wrote %d, read back %d.\n",
			(int) ncr_wr, (int) ncr_bk);
		err |= 4;
	};
	return (err);
}

/*==========================================================
**
**
**	Profiling the drivers and targets performance.
**
**
**==========================================================
*/

/*
**	Compute the difference in milliseconds.
**/

static	int ncr_delta (struct timeval * from, struct timeval * to)
{
	if (!from->tv_sec) return (-1);
	if (!to  ->tv_sec) return (-2);
	return ( (to->tv_sec  - from->tv_sec  -       2)*1000+
		+(to->tv_usec - from->tv_usec + 2000000)/1000);
}

#define PROFILE  cp->phys.header.stamp
static	void ncb_profile (ncb_p np, ccb_p cp)
{
	int co, da, st, en, di, se, post,work,disc;
	u_long diff;

#ifdef __OpenBSD__
	getmicrouptime(&PROFILE.end);
#else
	gettime(&PROFILE.end);
#endif

	st = ncr_delta (&PROFILE.start,&PROFILE.status);
	if (st<0) return;	/* status  not reached  */

	da = ncr_delta (&PROFILE.start,&PROFILE.data);
	if (da<0) return;	/* No data transfer phase */

	co = ncr_delta (&PROFILE.start,&PROFILE.command);
	if (co<0) return;	/* command not executed */

	en = ncr_delta (&PROFILE.start,&PROFILE.end),
	di = ncr_delta (&PROFILE.start,&PROFILE.disconnect),
	se = ncr_delta (&PROFILE.start,&PROFILE.select);
	post = en - st;

	/*
	**	@@PROFILE@@  Disconnect time invalid if multiple disconnects
	*/

	if (di>=0) disc = se-di; else  disc = 0;

	work = (st - co) - disc;

	diff = (np->disc_phys - np->disc_ref) & 0xff;
	np->disc_ref += diff;

	np->profile.num_trans	+= 1;
	if (cp->xfer)
	np->profile.num_bytes	+= cp->xfer->datalen;
	np->profile.num_disc	+= diff;
	np->profile.ms_setup	+= co;
	np->profile.ms_data	+= work;
	np->profile.ms_disc	+= disc;
	np->profile.ms_post	+= post;
}
#undef PROFILE

#ifdef __OpenBSD__
/*==========================================================
**
**
**	Device lookup.
**
**	@@GENSCSI@@ should be integrated to scsiconf.c
**
**
**==========================================================
*/

struct table_entry {
	char *	manufacturer;
	char *	model;
	char *	version;
	u_long	info;
};

static struct table_entry device_tab[] =
{
#ifdef NCR_GETCC_WITHMSG
	{"HP      ", "C372", "", QUIRK_NOTAGS|QUIRK_NOMSG},
	{"", "", "", QUIRK_NOMSG},
	{"SONY", "SDT-5000", "3.17", QUIRK_NOMSG},
	{"WangDAT", "Model 2600", "01.7", QUIRK_NOMSG},
	{"WangDAT", "Model 3200", "02.2", QUIRK_NOMSG},
	{"WangDAT", "Model 1300", "02.4", QUIRK_NOMSG},
#endif
	{"", "", "", 0} /* catch all: must be last entry. */
};

static u_long ncr_lookup(char * id)
{
	struct table_entry * p = device_tab;
	char *d, *r, c;

	for (;;p++) {

		d = id+8;
		r = p->manufacturer;
		while ((c=*r++)) if (c!=*d++) break;
		if (c) continue;

		d = id+16;
		r = p->model;
		while ((c=*r++)) if (c!=*d++) break;
		if (c) continue;

		d = id+32;
		r = p->version;
		while ((c=*r++)) if (c!=*d++) break;
		if (c) continue;

		return (p->info);
	}
}
#endif /* __OpenBSD__ */

/*==========================================================
**
**	Determine the ncr's clock frequency.
**	This is essential for the negotiation
**	of the synchronous transfer rate.
**
**==========================================================
**
**	Note: we have to return the correct value.
**	THERE IS NO SAVE DEFAULT VALUE.
**
**	Most NCR/SYMBIOS boards are delivered with a 40 MHz clock.
**	53C860 and 53C875 rev. 1 support fast20 transfers but
**	do not have a clock doubler and so are provided with a
**	80 MHz clock. All other fast20 boards incorporate a doubler
**	and so should be delivered with a 40 MHz clock.
**	The future fast40 chips (895/895) use a 40 MHz base clock
**	and provide a clock quadrupler (160 MHz). The code below
**	tries to deal as cleverly as possible with all this stuff.
**
**----------------------------------------------------------
*/

/*
 *	Select NCR SCSI clock frequency
 */
static void ncr_selectclock(ncb_p np, u_char scntl3)
{
	if (np->multiplier < 2) {
		OUTB(nc_scntl3,	scntl3);
		return;
	}

	if (bootverbose >= 2)
		printf ("%s: enabling clock multiplier\n", ncr_name(np));

	OUTB(nc_stest1, DBLEN);	   /* Enable clock multiplier		  */
	if (np->multiplier > 2) {  /* Poll bit 5 of stest4 for quadrupler */
		int i = 20;
		while (!(INB(nc_stest4) & LCKFRQ) && --i > 0)
			DELAY(20);
		if (!i)
			printf("%s: the chip cannot lock the frequency\n", ncr_name(np));
	} else			/* Wait 20 micro-seconds for doubler	*/
		DELAY(20);
	OUTB(nc_stest3, HSC);		/* Halt the scsi clock		*/
	OUTB(nc_scntl3,	scntl3);
	OUTB(nc_stest1, (DBLEN|DBLSEL));/* Select clock multiplier	*/
	OUTB(nc_stest3, 0x00);		/* Restart scsi clock 		*/
}

/*
 *	calculate NCR SCSI clock frequency (in KHz)
 */
static unsigned
ncrgetfreq (ncb_p np, int gen)
{
	int ms = 0;
	/*
	 * Measure GEN timer delay in order
	 * to calculate SCSI clock frequency
	 *
	 * This code will never execute too
	 * many loop iterations (if DELAY is
	 * reasonably correct). It could get
	 * too low a delay (too high a freq.)
	 * if the CPU is slow executing the
	 * loop for some reason (an NMI, for
	 * example). For this reason we will
	 * if multiple measurements are to be
	 * performed trust the higher delay
	 * (lower frequency returned).
	 */
	OUTB (nc_stest1, 0);	/* make sure clock doubler is OFF	    */
	OUTW (nc_sien , 0);	/* mask all scsi interrupts		    */
	(void) INW (nc_sist);	/* clear pending scsi interrupt		    */
	OUTB (nc_dien , 0);	/* mask all dma interrupts		    */
	(void) INW (nc_sist);	/* another one, just to be sure :)	    */
	OUTB (nc_scntl3, 4);	/* set pre-scaler to divide by 3	    */
	OUTB (nc_stime1, 0);	/* disable general purpose timer	    */
	OUTB (nc_stime1, gen);	/* set to nominal delay of (1<<gen) * 125us */
	while (!(INW(nc_sist) & GEN) && ms++ < 1000)
		DELAY(1000);	/* count ms				    */
	OUTB (nc_stime1, 0);	/* disable general purpose timer	    */
	OUTB (nc_scntl3, 0);
	/*
	 * Set prescaler to divide by whatever "0" means.
	 * "0" ought to choose divide by 2, but appears
	 * to set divide by 3.5 mode in my 53c810 ...
	 */
	OUTB (nc_scntl3, 0);

	if (bootverbose >= 2)
	  	printf ("\tDelay (GEN=%d): %u msec\n", gen, ms);
	/*
	 * adjust for prescaler, and convert into KHz
	 */
	return ms ? ((1 << gen) * 4440) / ms : 0;
}

static void ncr_getclock (ncb_p np, u_char multiplier)
{
	unsigned char scntl3;
	unsigned char stest1;
	scntl3 = INB(nc_scntl3);
	stest1 = INB(nc_stest1);
	
	np->multiplier = 1;
	/* always false, except for 875 with clock doubler selected */
	if ((stest1 & (DBLEN+DBLSEL)) == DBLEN+DBLSEL) {
		np->multiplier	= multiplier;
		np->clock_khz	= 40000 * multiplier;
	} else {
		if ((scntl3 & 7) == 0) {
			unsigned f1, f2;
			/* throw away first result */
			(void) ncrgetfreq (np, 11);
			f1 = ncrgetfreq (np, 11);
			f2 = ncrgetfreq (np, 11);

			if (bootverbose >= 2)
			  printf ("\tNCR clock is %uKHz, %uKHz\n", f1, f2);
			if (f1 > f2) f1 = f2;	/* trust lower result	*/
			if (f1 > 45000) {
				scntl3 = 5;	/* >45MHz: assume 80MHz	*/
			} else {
				scntl3 = 3;	/* <45MHz: assume 40MHz	*/
			}
		}
		else if ((scntl3 & 7) == 5)
			np->clock_khz = 80000;	/* Probably a 875 rev. 1 ? */
	}
}

/*=========================================================================*/

#ifdef NCR_TEKRAM_EEPROM

struct tekram_eeprom_dev {
  u_char	devmode;
#define	TKR_PARCHK	0x01
#define	TKR_TRYSYNC	0x02
#define	TKR_ENDISC	0x04
#define	TKR_STARTUNIT	0x08
#define	TKR_USETAGS	0x10
#define	TKR_TRYWIDE	0x20
  u_char	syncparam;	/* max. sync transfer rate (table ?) */
  u_char	filler1;
  u_char	filler2;
};


struct tekram_eeprom {
  struct tekram_eeprom_dev
		dev[16];
  u_char	adaptid;
  u_char	adaptmode;
#define	TKR_ADPT_GT2DRV	0x01
#define	TKR_ADPT_GT1GB	0x02
#define	TKR_ADPT_RSTBUS	0x04
#define	TKR_ADPT_ACTNEG	0x08
#define	TKR_ADPT_NOSEEK	0x10
#define	TKR_ADPT_MORLUN	0x20
  u_char	delay;		/* unit ? (table ???) */
  u_char	tags;		/* use 4 times as many ... */
  u_char	filler[60];
};

static void
tekram_write_bit (ncb_p np, int bit)
{
	u_char val = 0x10 + ((bit & 1) << 1);

	DELAY(10);
	OUTB (nc_gpreg, val);
	DELAY(10);
	OUTB (nc_gpreg, val | 0x04);
	DELAY(10);
	OUTB (nc_gpreg, val);
	DELAY(10);
}

static int
tekram_read_bit (ncb_p np)
{
	OUTB (nc_gpreg, 0x10);
	DELAY(10);
	OUTB (nc_gpreg, 0x14);
	DELAY(10);
	return INB (nc_gpreg) & 1;
}

static u_short
read_tekram_eeprom_reg (ncb_p np, int reg)
{
	int bit;
	u_short result = 0;
	int cmd = 0x80 | reg;

	OUTB (nc_gpreg, 0x10);

	tekram_write_bit (np, 1);
	for (bit = 7; bit >= 0; bit--)
	{
		tekram_write_bit (np, cmd >> bit);
	}

	for (bit = 0; bit < 16; bit++)
	{
		result <<= 1;
		result |= tekram_read_bit (np);
	}

	OUTB (nc_gpreg, 0x00);
	return result;
}

static int
read_tekram_eeprom(ncb_p np, struct tekram_eeprom *buffer)
{
	u_short *p = (u_short *) buffer;
	u_short sum = 0;
	int i;

	if (INB (nc_gpcntl) != 0x09)
	{
		return 0;
        }
	for (i = 0; i < 64; i++)
	{
		u_short val;
if((i&0x0f) == 0) printf ("%02x:", i*2);
		val = read_tekram_eeprom_reg (np, i);
		if (p)
			*p++ = val;
		sum += val;
if((i&0x01) == 0x00) printf (" ");
		printf ("%02x%02x", val & 0xff, (val >> 8) & 0xff);
if((i&0x0f) == 0x0f) printf ("\n");
	}
printf ("Sum = %04x\n", sum);
	return sum == 0x1234;
}
#endif /* NCR_TEKRAM_EEPROM */

/*=========================================================================*/
#endif /* KERNEL */
@


1.72
log
@loose is not lose. ok deraadt tdeval and a few more typos from jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.71 2004/06/25 00:54:27 tholo Exp $	*/
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.71 2004/06/25 00:54:27 tholo Exp $\n";
@


1.71
log
@Minor fixes suggested by nordin@@ and henning@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.70 2004/06/24 19:35:23 tholo Exp $	*/
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.70 2004/06/24 19:35:23 tholo Exp $\n";
d1776 1
a1776 1
	**	(1) The ncr looses arbitration.
@


1.70
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.69 2004/06/21 23:50:35 tholo Exp $	*/
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.69 2004/06/21 23:50:35 tholo Exp $\n";
d1624 1
a1624 1
 * XXX - set up a timer that will update a local copy or microuptime once
@


1.69
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.68 2003/11/07 10:16:45 jmc Exp $	*/
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.68 2003/11/07 10:16:45 jmc Exp $\n";
d1623 4
d4480 1
a4480 1
	cp->phys.header.stamp.start = mono_time;
d6099 1
a6099 1
		np->regtime = mono_time;
d7714 1
a7714 1
	PROFILE.end = mono_time;
@


1.68
log
@adress -> address, and a few more; all from Jonathon Gray;

(mvme68k/mvme88k) vs.c and (vax) if_le.c ok miod@@
isakmpd ones ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.67 2003/04/27 11:22:53 ho Exp $	*/
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.67 2003/04/27 11:22:53 ho Exp $\n";
d4791 1
a4791 1
	cp->tlimit		= mono_time.tv_sec + xp->timeout / 1000 + 2;
d5768 1
a5768 1
	u_long	thistime = mono_time.tv_sec;
d6093 1
a6093 1
	if (mono_time.tv_sec - np->regtime.tv_sec>10) {
@


1.67
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.66 2003/02/11 19:20:27 mickey Exp $	*/
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.66 2003/02/11 19:20:27 mickey Exp $\n";
d5905 1
a5905 1
**		dsp:	script adress (relative to start of script).
@


1.66
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.65 2003/01/05 22:41:35 deraadt Exp $	*/
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.65 2003/01/05 22:41:35 deraadt Exp $\n";
d1573 1
a1573 1
	sprintf(name, "ncr%d", np->unit);
@


1.65
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.64 2002/06/04 00:09:08 deraadt Exp $	*/
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.64 2002/06/04 00:09:08 deraadt Exp $\n";
d7821 1
a7821 1
**	Most NCR/SYMBIOS boards are delivered with a 40 Mhz clock.
d7826 2
a7827 2
**	The future fast40 chips (895/895) use a 40 Mhz base clock
**	and provide a clock quadrupler (160 Mhz). The code below
d7934 1
a7934 1
				scntl3 = 5;	/* >45Mhz: assume 80MHz	*/
d7936 1
a7936 1
				scntl3 = 3;	/* <45Mhz: assume 40MHz	*/
@


1.64
log
@spelling; raj@@cerias.purdue.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.63 2002/03/14 03:16:06 millert Exp $	*/
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.63 2002/03/14 03:16:06 millert Exp $\n";
d6660 1
a6660 1
**	a successfull inquire command. We look at byte 7 of the
@


1.63
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.62 2001/11/06 19:53:19 miod Exp $	*/
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.62 2001/11/06 19:53:19 miod Exp $\n";
d7136 1
a7136 1
**	Aquire a control block
@


1.62
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.61 2001/08/26 00:45:08 fgsch Exp $	*/
d1419 1
a1419 1
static	u_long	ncr_lookup	(char* id);
d1451 1
a1451 1
static  char*	ncr_probe       (pcici_t tag, pcidi_t type);
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.61 2001/08/26 00:45:08 fgsch Exp $\n";
d3562 1
a3562 1
static	char* ncr_probe (pcici_t tag, pcidi_t type)
d4494 1
a4494 1
		tp->quirks = ncr_lookup ((char*) &tp->inqdata[0]);
d5072 1
a5072 1
			u_char * p = (u_char*) & xp->sense;
d5125 1
a5125 1
		p = (u_char*) &xp->cmd->opcode;
d5135 1
a5135 1
				p = (u_char*) &xp->sense;
d6102 1
a6102 1
			((char*)&np->regdump)[i] = INB_OFF(i);
d6445 1
a6445 1
		tblp = (u_int32_t *) ((char*) &cp->phys + oadr);
@


1.62.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.62 2001/11/06 19:53:19 miod Exp $	*/
d1419 1
a1419 1
static	u_long	ncr_lookup	(char *id);
d1451 1
a1451 1
static  char   *ncr_probe       (pcici_t tag, pcidi_t type);
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.62 2001/11/06 19:53:19 miod Exp $\n";
d3562 1
a3562 1
static	char *ncr_probe (pcici_t tag, pcidi_t type)
d4494 1
a4494 1
		tp->quirks = ncr_lookup ((char *) &tp->inqdata[0]);
d5072 1
a5072 1
			u_char * p = (u_char *) & xp->sense;
d5125 1
a5125 1
		p = (u_char *) &xp->cmd->opcode;
d5135 1
a5135 1
				p = (u_char *) &xp->sense;
d6102 1
a6102 1
			((char *)&np->regdump)[i] = INB_OFF(i);
d6445 1
a6445 1
		tblp = (u_int32_t *) ((char *) &cp->phys + oadr);
d7136 1
a7136 1
**	Acquire a control block
@


1.62.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1469 1
a1469 1
	"\n$OpenBSD$\n";
d1573 1
a1573 1
	snprintf(name, sizeof name, "ncr%d", np->unit);
d6660 1
a6660 1
**	a successful inquire command. We look at byte 7 of the
d7821 1
a7821 1
**	Most NCR/SYMBIOS boards are delivered with a 40 MHz clock.
d7826 2
a7827 2
**	The future fast40 chips (895/895) use a 40 MHz base clock
**	and provide a clock quadrupler (160 MHz). The code below
d7934 1
a7934 1
				scntl3 = 5;	/* >45MHz: assume 80MHz	*/
d7936 1
a7936 1
				scntl3 = 3;	/* <45MHz: assume 40MHz	*/
@


1.61
log
@remove useless INUSE references from scsi_xfer->flags; art@@ miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.60 2001/08/25 10:13:30 art Exp $	*/
d228 1
a228 2
#include <vm/vm.h>
#include <vm/vm_extern.h>
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.60 2001/08/25 10:13:30 art Exp $\n";
@


1.60
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.59 2001/08/19 15:07:34 miod Exp $	*/
d1470 1
a1470 1
	"\n$OpenBSD: ncr.c,v 1.59 2001/08/19 15:07:34 miod Exp $\n";
a4433 5
	if (!(flags & INUSE)) {
		printf("%s: ?INUSE?\n", ncr_name (np));
		xp->flags |= INUSE;
	};

@


1.59
log
@More old timeouts removal, mainly affected unused/unmaintained code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.58 2001/08/12 20:03:49 mickey Exp $	*/
d1470 1
a1470 1
	"\n$OpenBSD: ncr.c,v 1.58 2001/08/12 20:03:49 mickey Exp $\n";
d3720 1
a3720 2
	retval = pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &intrhandle);
@


1.58
log
@remove redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.57 2001/06/12 15:40:32 niklas Exp $	*/
d225 2
d1218 2
d1470 1
a1470 1
	"\n$OpenBSD: ncr.c,v 1.57 2001/06/12 15:40:32 niklas Exp $\n";
d4268 1
d5874 1
a5874 1
	timeout (ncr_timeout, (caddr_t) np, step ? step : 1);
d6245 1
a6245 1
		untimeout (ncr_timeout, (caddr_t) np);
@


1.57
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.56 2001/05/16 19:31:40 mickey Exp $	*/
a226 1
#include <vm/pmap.h>
d1466 1
a1466 1
	"\n$OpenBSD: ncr.c,v 1.56 2001/05/16 19:31:40 mickey Exp $\n";
@


1.56
log
@it is notright to malloc() w/  WAITOK at attach time, put back NULL check and change to NOWAIT
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.55 2001/05/16 12:51:49 ho Exp $	*/
d1467 1
a1467 1
	"\n$OpenBSD: ncr.c,v 1.55 2001/05/16 12:51:49 ho Exp $\n";
d3678 2
a3679 3
	ioh_valid = (pci_mapreg_map(pa, 0x10,
	    PCI_MAPREG_TYPE_IO, 0,
	    &iot, &ioh, &ioaddr, NULL) == 0);
d3682 1
a3682 1
	    &memt, &memh, &memaddr, NULL) == 0);
d3997 1
a3997 1
		    &memt, &memh, &memaddr, NULL) == 0) {
@


1.55
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.54 2001/04/06 04:42:07 csapuntz Exp $	*/
d1467 1
a1467 1
	"\n$OpenBSD: ncr.c,v 1.54 2001/04/06 04:42:07 csapuntz Exp $\n";
d3664 3
a3666 1
	np->ccb = (ccb_p) malloc (sizeof (struct ccb), M_DEVBUF, M_WAITOK);
@


1.54
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.53 2001/01/25 03:50:51 todd Exp $	*/
d1467 1
a1467 1
	"\n$OpenBSD: ncr.c,v 1.53 2001/01/25 03:50:51 todd Exp $\n";
a3664 1
	if (!np->ccb) return;
a3769 1
		if (!np) return;
a3774 1
	if (!np->ccb) return;
@


1.53
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.52 2000/10/08 19:36:09 millert Exp $	*/
a213 2
#define	offsetof(type, member)	((size_t)(&((type *)0)->member))

d1467 1
a1467 1
	"\n$OpenBSD: ncr.c,v 1.52 2000/10/08 19:36:09 millert Exp $\n";
@


1.52
log
@Add support for Symbios (NCR) 1510 and 1510D.  Based on a patch from
redjade@@ada.snu.ac.kr.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.51 2000/08/01 13:45:26 millert Exp $	*/
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.51 2000/08/01 13:45:26 millert Exp $\n";
d6372 1
a6372 1
	**	The data in the dma fifo has not been transfered to
@


1.51
log
@Add Symbios 53C895A support; armin@@wolfermann.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.50 2000/02/08 01:25:02 millert Exp $	*/
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.50 2000/02/08 01:25:02 millert Exp $\n";
d1512 2
d3499 6
@


1.50
log
@Remove name field from ncr_chip_table since it doesn't have the chip name
anymore.  Instead, we print the scsi version supported based on the
features flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.49 2000/02/07 23:09:53 deraadt Exp $	*/
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.49 2000/02/07 23:09:53 deraadt Exp $\n";
d1510 1
d3491 3
@


1.50.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.54 2001/04/06 04:42:07 csapuntz Exp $	*/
d214 2
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.54 2001/04/06 04:42:07 csapuntz Exp $\n";
a1509 1
#define	NCR_895A_ID	(0x00121000ul)
a1510 2
#define	NCR_1510_ID	(0x00101000ul)
#define	NCR_1510D_ID	(0x000a1000ul)
a3491 3
 {NCR_895A_ID, 0x00,	7, 31, 7,
 FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}
 ,
a3493 6
 ,
 {NCR_1510_ID, 0x00,	7, 31, 7,
 FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}
 ,
 {NCR_1510D_ID, 0x00,	7, 31, 7,
 FE_WIDE|FE_ULTRA2|FE_QUAD|FE_CACHE_SET|FE_DFS|FE_LDSTR|FE_PFEN|FE_RAM}
d6360 1
a6360 1
	**	The data in the dma fifo has not been transferred to
@


1.50.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.50.2.1 2001/05/14 22:25:50 niklas Exp $	*/
d1467 1
a1467 1
	"\n$OpenBSD: ncr.c,v 1.50.2.1 2001/05/14 22:25:50 niklas Exp $\n";
d3664 2
a3665 3
	np->ccb = (ccb_p) malloc (sizeof (struct ccb), M_DEVBUF, M_NOWAIT);
	if (np->ccb == NULL)
		return;
d3677 3
a3679 2
	ioh_valid = (pci_mapreg_map(pa, 0x10, PCI_MAPREG_TYPE_IO, 0,
	    &iot, &ioh, &ioaddr, NULL, 0) == 0);
d3682 1
a3682 1
	    &memt, &memh, &memaddr, NULL, 0) == 0);
d3771 1
d3777 1
d3999 1
a3999 1
		    &memt, &memh, &memaddr, NULL, 0) == 0) {
@


1.50.2.3
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.50.2.2 2001/07/04 10:42:40 niklas Exp $	*/
d243 1
a243 1
#if !defined(__alpha__) && !defined(__mips__) && !defined(__powerpc__) && !defined(__i386__)
d1467 1
a1467 1
	"\n$OpenBSD: ncr.c,v 1.50.2.2 2001/07/04 10:42:40 niklas Exp $\n";
@


1.50.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.50.2.3 2001/07/14 10:02:17 ho Exp $	*/
a224 2
#else
#include <sys/timeout.h>
d227 1
a1216 2
#elif defined (__OpenBSD__)
	struct		timeout sc_timeout;
d1467 1
a1467 1
	"\n$OpenBSD: ncr.c,v 1.50.2.3 2001/07/14 10:02:17 ho Exp $\n";
d3717 2
a3718 1
	retval = pci_intr_map(pa, &intrhandle);
a4264 1
	timeout_set(&np->sc_timeout, ncr_timeout, np);
d4431 5
d5870 1
a5870 1
	timeout_add(&np->sc_timeout, step ? step : 1);
d6241 1
a6241 1
		timeout_del(&np->sc_timeout);
@


1.50.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d228 2
a229 1
#include <uvm/uvm_extern.h>
d1470 1
a1470 1
	"\n$OpenBSD$\n";
@


1.50.2.6
log
@Merge in -current from roughly a week ago
@
text
@d1419 1
a1419 1
static	u_long	ncr_lookup	(char *id);
d1451 1
a1451 1
static  char   *ncr_probe       (pcici_t tag, pcidi_t type);
d3562 1
a3562 1
static	char *ncr_probe (pcici_t tag, pcidi_t type)
d4494 1
a4494 1
		tp->quirks = ncr_lookup ((char *) &tp->inqdata[0]);
d5072 1
a5072 1
			u_char * p = (u_char *) & xp->sense;
d5125 1
a5125 1
		p = (u_char *) &xp->cmd->opcode;
d5135 1
a5135 1
				p = (u_char *) &xp->sense;
d6102 1
a6102 1
			((char *)&np->regdump)[i] = INB_OFF(i);
d6445 1
a6445 1
		tblp = (u_int32_t *) ((char *) &cp->phys + oadr);
@


1.50.2.7
log
@Sync the SMP branch with 3.3
@
text
@d6660 1
a6660 1
**	a successful inquire command. We look at byte 7 of the
d7136 1
a7136 1
**	Acquire a control block
d7821 1
a7821 1
**	Most NCR/SYMBIOS boards are delivered with a 40 MHz clock.
d7826 2
a7827 2
**	The future fast40 chips (895/895) use a 40 MHz base clock
**	and provide a clock quadrupler (160 MHz). The code below
d7934 1
a7934 1
				scntl3 = 5;	/* >45MHz: assume 80MHz	*/
d7936 1
a7936 1
				scntl3 = 3;	/* <45MHz: assume 40MHz	*/
@


1.50.2.8
log
@A sweep to fix remaining files not in sync with the SMP_SYNC_B point.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.66 2003/02/11 19:20:27 mickey Exp $	*/
d243 1
a243 1
#if !defined(__alpha__) && !defined(__mips__) && !defined(__powerpc__)
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.66 2003/02/11 19:20:27 mickey Exp $\n";
@


1.50.2.9
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.50.2.8 2003/04/19 19:17:49 niklas Exp $	*/
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.50.2.8 2003/04/19 19:17:49 niklas Exp $\n";
d1573 1
a1573 1
	snprintf(name, sizeof name, "ncr%d", np->unit);
@


1.50.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1469 1
a1469 1
	"\n$OpenBSD$\n";
d5905 1
a5905 1
**		dsp:	script address (relative to start of script).
@


1.49
log
@remove verbosity in dmesg; openbsd commit #10,000 for me
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.48 2000/02/06 22:03:19 niklas Exp $	*/
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.48 2000/02/06 22:03:19 niklas Exp $\n";
a3443 1
	char	       *name;
d3451 1
a3451 1
 {NCR_810_ID, 0x00,	"fast10",			4,  8, 4,
d3454 1
a3454 1
 {NCR_810_ID, 0x10,	"fast10",			4,  8, 4,
d3457 1
a3457 1
 {NCR_815_ID, 0x00,	"fast10", 			4,  8, 4,
d3460 1
a3460 1
 {NCR_820_ID, 0x00,	"fast10 wide", 		4,  8, 4,
d3463 1
a3463 1
 {NCR_825_ID, 0x00,	"fast10 wide",		4,  8, 4,
d3466 1
a3466 1
 {NCR_825_ID, 0x10,	"fast10 wide",		7,  8, 4,
d3469 1
a3469 1
 {NCR_860_ID, 0x00,	"fast20",			4,  8, 5,
d3472 1
a3472 1
 {NCR_875_ID, 0x00,	"fast20 wide",		7, 16, 5,
d3475 1
a3475 1
 {NCR_875_ID, 0x02,	"fast20 wide",		7, 16, 5,
d3479 1
a3479 1
 {NCR_875_ID2, 0x00,	"fast20",			4,  8, 5,
d3482 1
a3482 1
 {NCR_875_ID2, 0x00,	"fast20 wide",		7, 16, 5,
d3486 1
a3486 1
 {NCR_885_ID, 0x00,	"fast20 wide",		7, 16, 5,
d3489 1
a3489 1
 {NCR_895_ID, 0x00,	"fast40 wide",		7, 31, 7,
d3492 1
a3492 1
 {NCR_896_ID, 0x00,	"fast40 wide",		7, 31, 7,
d3646 1
d3725 6
d3732 3
a3734 1
		printf(": %s, %s\n", ncr_chip_table[i].name, intrstr);
d3736 2
a3737 1
		printf(": %s\n", ncr_chip_table[i].name);
@


1.48
log
@LVD support, from FreeBSD, tested for half a year by several people
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.47 1999/12/02 22:12:13 millert Exp $	*/
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.47 1999/12/02 22:12:13 millert Exp $\n";
d3452 1
a3452 1
 {NCR_810_ID, 0x00,	"ncr 53c810 fast10 scsi",		4,  8, 4,
d3455 1
a3455 1
 {NCR_810_ID, 0x10,	"ncr 53c810a fast10 scsi",		4,  8, 4,
d3458 1
a3458 1
 {NCR_815_ID, 0x00,	"ncr 53c815 fast10 scsi", 		4,  8, 4,
d3461 1
a3461 1
 {NCR_820_ID, 0x00,	"ncr 53c820 fast10 wide scsi", 		4,  8, 4,
d3464 1
a3464 1
 {NCR_825_ID, 0x00,	"ncr 53c825 fast10 wide scsi",		4,  8, 4,
d3467 1
a3467 1
 {NCR_825_ID, 0x10,	"ncr 53c825a fast10 wide scsi",		7,  8, 4,
d3470 1
a3470 1
 {NCR_860_ID, 0x00,	"ncr 53c860 fast20 scsi",		4,  8, 5,
d3473 1
a3473 1
 {NCR_875_ID, 0x00,	"ncr 53c875 fast20 wide scsi",		7, 16, 5,
d3476 1
a3476 1
 {NCR_875_ID, 0x02,	"ncr 53c875 fast20 wide scsi",		7, 16, 5,
d3480 1
a3480 1
 {NCR_875_ID2, 0x00,	"ncr 53c875j fast20 scsi",		4,  8, 5,
d3483 1
a3483 1
 {NCR_875_ID2, 0x00,	"ncr 53c875j fast20 wide scsi",		7, 16, 5,
d3487 1
a3487 1
 {NCR_885_ID, 0x00,	"ncr 53c885 fast20 wide scsi",		7, 16, 5,
d3490 1
a3490 1
 {NCR_895_ID, 0x00,	"ncr 53c895 fast40 wide scsi",		7, 31, 7,
d3493 1
a3493 1
 {NCR_896_ID, 0x00,	"ncr 53c896 fast40 wide scsi",		7, 31, 7,
@


1.47
log
@o Crank MAX_START back up to 256 and allow it to be overridden.  This time we
  leave SCSI_NCR_DFLT_TAGS alone since turning off tags caused some problems.
o Use new pci routines in attach (from NetBSD).  This also repairs
  -DNCR_IOMAPPED.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.46 1999/06/06 23:17:24 deraadt Exp $	*/
d99 1
a99 1
#define SCSI_NCR_DFLT_SYNC   (12)
d1327 1
a1327 1
	ncrcmd	select		[ 22];
d1342 2
a1343 2
	ncrcmd	cleanup0	[ 11];
	ncrcmd	signal		[ 10];
d1379 1
a1379 1
	ncrcmd	getcc2		[ 33];
d1383 1
a1383 1
	ncrcmd	getcc3		[ 10];
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.46 1999/06/06 23:17:24 deraadt Exp $\n";
a1791 8
	**	Save target id to ctest0 register
	*/

	SCR_FROM_REG (sdid),
		0,
	SCR_TO_REG (ctest0),
		0,
	/*
a2232 5
	/*
	**	And make the DSA register invalid.
	*/
/*>>>*/	SCR_LOAD_REG (dsa, 0xff), /* invalid */
		0,
d2238 1
a2238 1
	SCR_FROM_REG (SS_REG),
d2243 5
d2464 1
a2464 1
	SCR_TO_REG (ctest0),
a3048 7
	**	save target id.
	*/
	SCR_FROM_REG (sdid),
		0,
	SCR_TO_REG (ctest0),
		0,
	/*
a3078 7
	**	save target id.
	*/
	SCR_FROM_REG (sdid),
		0,
	SCR_TO_REG (ctest0),
		0,
	/*
d5468 1
a5468 1
	u_char target = INB (nc_ctest0) & 0x0f;
d5550 1
a5550 1
	u_short target = INB (nc_ctest0) & 0x0f;
d5932 1
a5932 1
		ncr_name (np), (unsigned)INB (nc_ctest0)&0x0f, dstat, sist,
d6163 1
a6163 1
			ncr_name (np), INB (nc_ctest0)&0x0f);
d6540 1
a6540 1
	u_char	target = INB (nc_ctest0) & 0x0f;
@


1.46
log
@complete blind luck made this work without a volatile
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.45 1999/04/05 16:38:04 millert Exp $	*/
a169 1
**    The calculation below is actually quite silly ...
d172 3
a174 1
#define MAX_START   (MAX_TARGET + (MAX_TARGET - 1) * SCSI_NCR_DFLT_TAGS)
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.45 1999/04/05 16:38:04 millert Exp $\n";
d3556 2
a3557 2
	struct pci_attach_args *pa = aux;
	u_char rev = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG) & 0xff;
d3575 1
a3575 1
	u_char rev = pci_conf_read (tag, PCI_CLASS_REG) & 0xff;
a3656 1
	bus_space_tag_t memt = pa->pa_memt;
d3658 1
a3658 2
	bus_size_t memsize;
	int retval, cacheable;
d3664 5
a3668 1
	u_char rev = pci_conf_read(pc, pa->pa_tag, PCI_CLASS_REG) & 0xff;
a3674 1
	np->sc_st = memt;
d3689 30
a3718 5
	retval = pci_mem_find(pc, pa->pa_tag, 0x14, &np->paddr,
	    &memsize, &cacheable);
	if (retval) {
		printf(": couldn't find memory region\n");
		return;
d3720 3
a3722 5

	/* Map the memory.  Note that we never want it to be cacheable. */
	retval = bus_space_map(pa->pa_memt, np->paddr, memsize, 0, &np->sc_sh);
	if (retval) {
		printf(": couldn't map memory region\n");
d3998 14
a4011 1
#ifndef __OpenBSD__
d4352 1
a4352 1
	int	i, oldspl, segments, flags = xp->flags;
d4830 5
d4842 3
a4844 9
#ifdef __OpenBSD__
	if (!(flags & SCSI_POLL)) {
#else /* !__OpenBSD__ */
	if (!(flags & SCSI_NOMASK)) {
#endif /* __OpenBSD__ */
		if (np->lasttime) {
			if(DEBUG_FLAGS & DEBUG_TINY) printf ("Q");
			return(SUCCESSFULLY_QUEUED);
		};
a4888 6
#ifdef __OpenBSD__
	if (!(flags & SCSI_POLL))
#else /* !__OpenBSD__ */
	if (!(flags & SCSI_NOMASK))
#endif /* __OpenBSD__ */
		return (SUCCESSFULLY_QUEUED);
d4957 1
a4957 1
	**	We donnot queue more than 1 ccb per target
d5904 1
a5904 1
**		so:	control lines as driver by NCR.
d7602 1
@


1.45
log
@revert to rev 1.42 until after 2.5 release
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.42 1999/01/11 01:51:58 millert Exp $	*/
d1468 1
a1468 1
	"\n$OpenBSD: ncr.c,v 1.42 1999/01/11 01:51:58 millert Exp $\n";
d7569 1
a7569 1
	u_int32_t ncr_rd, ncr_wr, ncr_bk, host_rd, host_wr, pc;
@


1.44
log
@Crank MAX_START to 256 instead of making it dependent on MAX_TARGET and
SCSI_NCR_DFLT_TAGS
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.43 1999/03/21 01:07:36 millert Exp $	*/
a132 1
**    To enable tagged queuing set this to be >= 4.
d136 1
a136 1
#define SCSI_NCR_DFLT_TAGS    (0)
d170 1
d173 1
a173 1
#define MAX_START   (256)
d1468 1
a1468 1
	"\n$OpenBSD: ncr.c,v 1.43 1999/03/21 01:07:36 millert Exp $\n";
@


1.43
log
@Do not enable command tagged queuing by default
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.42 1999/01/11 01:51:58 millert Exp $	*/
a170 1
**    The calculation below is actually quite silly ...
d173 1
a173 1
#define MAX_START   (MAX_TARGET + (MAX_TARGET - 1) * SCSI_NCR_DFLT_TAGS)
d1468 1
a1468 1
	"\n$OpenBSD: ncr.c,v 1.42 1999/01/11 01:51:58 millert Exp $\n";
@


1.42
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.41 1998/08/07 16:48:19 pefo Exp $	*/
d133 1
d137 1
a137 1
#define SCSI_NCR_DFLT_TAGS    (4)
d1469 1
a1469 1
	"\n$OpenBSD: ncr.c,v 1.41 1998/08/07 16:48:19 pefo Exp $\n";
@


1.41
log
@com.c needs to know about mem mapped ports in ppc systems.

ncr.c and if_de.c needs some hooks for systems with ncr and dec
ether chips on the motherboard that runs on odd clocks and doesn't
support a srom. srom is emulated in machine dependent code.

big endian support for ncr and dec ether finished. the 21040
have some more coding requirements if it is to run BE since
it does not have the descriptor endian swap configuration bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.40 1998/07/21 07:16:37 downsj Exp $	*/
d1468 1
a1468 1
	"\n$OpenBSD: ncr.c,v 1.40 1998/07/21 07:16:37 downsj Exp $\n";
d3386 1
a3386 1
					panic("ncr_script_copy_and_bind: weird relocation %x @@ %ld\n", old, (long)(src - start));
@


1.40
log
@#ifdef for a weird card and a strange configuration
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.39 1998/07/16 07:06:05 millert Exp $	*/
d1468 1
a1468 1
	"\n$OpenBSD: ncr.c,v 1.39 1998/07/16 07:06:05 millert Exp $\n";
d3841 7
a3847 3
#if defined(__mips__) /* XXX FIXME - This is gross XXX */
	np->clock_khz	= 66000;
	np->clock_khz	= 48000;
d3850 1
a3850 1
#endif /*__mips__*/
@


1.39
log
@MAXSTART had an implicate assumption that MAXTARGETS was 8 when it is really 16
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.38 1998/05/23 03:14:24 millert Exp $	*/
d1468 1
a1468 1
	"\n$OpenBSD: ncr.c,v 1.38 1998/05/23 03:14:24 millert Exp $\n";
d3500 4
d3506 1
@


1.38
log
@Don't play games with PAGE_SIZE and PAGE_MASK.  Previously I was #undef'ing the real ones but that's gross.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.37 1998/03/22 17:27:44 pefo Exp $	*/
d149 2
a150 2
**    Default is 7, meaning targets #0..#6.
**    #7 .. is myself.
d173 1
a173 1
#define MAX_START   (MAX_TARGET + 7 * SCSI_NCR_DFLT_TAGS)
d1468 1
a1468 1
	"\n$OpenBSD: ncr.c,v 1.37 1998/03/22 17:27:44 pefo Exp $\n";
d7284 2
a7285 1
	if (np->actccbs >= MAX_START-2) return;
@


1.37
log
@Fix some minor type error and a ++ sideeffect error in a macro call.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.36 1998/03/17 15:59:46 pefo Exp $	*/
d186 3
d190 1
d252 1
a252 1
#ifdef __OpenBSD__	/* XXX */
a253 7
#undef PAGE_SIZE
#undef PAGE_MASK
#define	PAGE_SIZE	NBPG
#define	PAGE_MASK	(NBPG-1)
#endif

#ifdef __OpenBSD__
d1468 1
a1468 1
	"\n$OpenBSD: ncr.c,v 1.36 1998/03/17 15:59:46 pefo Exp $\n";
d7446 3
d7450 1
d7479 3
d7483 1
@


1.36
log
@Code to handle mips non coherent caches added. Also a fix for the 'data
buffer on stack' problem. Everything ifdefed __mips__
Still needs some fix for scsi clock freq. check on mips.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.35 1998/01/07 11:03:31 deraadt Exp $	*/
d240 1
a240 1
#if !defined(__alpha__) && !defined(__mips__)
d1471 1
a1471 1
	"\n$OpenBSD: ncr.c,v 1.35 1998/01/07 11:03:31 deraadt Exp $\n";
d3397 1
a3397 1
			WRITESCRIPT_OFF(dst, offset, *src++);
d3399 1
d7434 1
a7434 1
	paddr = NCR_KVATOPHYS (np, vaddr);
d7492 1
a7492 1
			paddr    = NCR_KVATOPHYS (np, vaddr);
@


1.35
log
@now this is really pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.34 1998/01/05 13:35:21 deraadt Exp $	*/
d240 1
a240 1
#ifndef __alpha__
d264 4
d1017 3
d1430 1
a1430 1
static	int	ncr_scatter	(struct dsb* phys, vm_offset_t vaddr,
d1471 1
a1471 1
	"\n$OpenBSD: ncr.c,v 1.34 1998/01/05 13:35:21 deraadt Exp $\n";
d3370 1
a3370 1
					new = (old & ~RELOC_MASK) + vtophys(np);
d3378 1
a3378 1
					new = vtophys((void *)script_kvars[old &
d3664 5
d3673 4
d3753 4
d3838 4
d3843 1
d3995 4
d4011 4
d4070 2
a4071 2
		np->p_script = vtophys(np->script);
	np->p_scripth	= vtophys(np->scripth);
d4079 1
a4079 1
	np->ccb->p_ccb	= vtophys (np->ccb);
d4411 8
d4637 1
a4637 1
	segments = ncr_scatter (&cp->phys, (vm_offset_t) xp->data,
d4704 1
a4704 1
	cp->phys.cmd.addr		= SCR_BO(vtophys (cmd));
d4722 5
a4726 1
	cp->phys.sense.addr		= SCR_BO(vtophys (&cp->xfer->sense));
d4906 12
d6375 1
a6375 1
	if (dsp == vtophys (&cp->patch[2])) {
d6379 1
a6379 1
	} else if (dsp == vtophys (&cp->patch[6])) {
d6459 1
a6459 1
	if (cp->phys.header.savep == SCR_BO(vtophys (newcmd))) newcmd+=4;
d6484 1
a6484 1
	OUTL (nc_temp, vtophys (newcmd));
d7218 1
a7218 1
		tp->getscr[1] = SCR_BO(vtophys (&tp->sval));
d7221 1
a7221 1
		tp->getscr[4] = SCR_BO(vtophys (&tp->wval));
d7234 1
a7234 1
		np->jump_tcb.l_paddr = SCR_BO(vtophys (&tp->jump_tcb));
d7251 5
d7274 1
a7274 1
		tp->jump_lcb.l_paddr = SCR_BO(vtophys (&lp->jump_lcb));
d7298 5
d7322 1
a7322 1
	cp->p_ccb	     = vtophys (cp);
d7420 1
a7420 1
	(struct dsb* phys, vm_offset_t vaddr, vm_size_t datalen)
d7433 1
a7433 1
	paddr = vtophys (vaddr);
d7491 1
a7491 1
			paddr    = vtophys (vaddr);
d7574 3
@


1.34
log
@new style pci attach printing
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.33 1997/12/03 21:43:35 millert Exp $	*/
d1464 1
a1464 1
	"\n$OpenBSD: ncr.c,v 1.33 1997/12/03 21:43:35 millert Exp $\n";
d3671 1
a3671 1
		printf("\n%s: couldn't find memory region\n", self->dv_xname);
d3678 1
a3678 1
		printf("\n%s: couldn't map memory region\n", self->dv_xname);
d3688 1
a3688 1
		printf("\n%s: couldn't map interrupt\n", self->dv_xname);
d3695 1
a3695 1
		printf("\n%s: couldn't establish interrupt", self->dv_xname);
d3704 1
a3704 1
		printf(" %s, %s\n", ncr_chip_table[i].name, intrstr);
d3706 1
a3706 1
		printf(" %s\n", ncr_chip_table[i].name);
@


1.33
log
@Move "struct head header" in struct ncb down to where it used to
be.  Found by Ken, fixed by Niklas.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.32 1997/12/01 18:58:48 millert Exp $	*/
d1464 1
a1464 1
	"\n$OpenBSD: ncr.c,v 1.32 1997/12/01 18:58:48 millert Exp $\n";
d3704 1
a3704 1
		printf(": %s, %s\n", ncr_chip_table[i].name, intrstr);
d3706 1
a3706 1
		printf(": %s\n", ncr_chip_table[i].name);
@


1.32
log
@Newer ncr driver from NetBSD minus the scsipi stuff and with
changes to make it diff usefully against the FreeBSD driver.
Tested on alpha and i386, not tested on powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.31 1997/10/11 11:05:27 pefo Exp $	*/
d1072 1
d1080 1
d1232 10
d1464 1
a1464 1
	"\n$OpenBSD: ncr.c,v 1.63 1997/09/23 02:39:15 perry Exp $\n";
@


1.31
log
@Modification for Big Endian systems. This driver is now usable in big endian
systems with PCI bus. The modifications were done for the new powerpc port.
Most changes are done in the scripts handling storing the scripts in little
endian byte order for the scripts processor in the NCR chip.
@
text
@d1 2
a2 2
/*	$OpenBSD: ncr.c,v 1.30 1997/09/07 03:36:43 millert Exp $	*/
/*	$NetBSD: ncr.c,v 1.56 1997/03/04 21:42:34 mycroft Exp $	*/
d6 3
a8 1
**  Device driver for the   NCR 53C810   PCI-SCSI-Controller.
a59 4
#ifdef __OpenBSD__
#define __BROKEN_INDIRECT_CONFIG
#endif

d91 1
a91 1
**    The maximal synchronous frequency in kHz.
d93 22
d117 3
a119 3
#ifndef SCSI_NCR_MAX_SYNC
#define SCSI_NCR_MAX_SYNC   (10000)
#endif /* SCSI_NCR_MAX_SYNC */
d183 1
a183 1
**    MUST NOT be greater than (MAX_SCATTER-1) * NBPG.
d186 1
a186 1
#define MAX_SIZE  ((MAX_SCATTER-1) * (long) NBPG)
d201 1
a201 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d205 2
a210 1
#include <sys/types.h>
a212 1
#include <sys/proc.h>
d219 1
a219 4
#if defined(__NetBSD__) || defined(__OpenBSD__)
#define bootverbose	1
#endif
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
a223 1
#include <vm/vm_param.h>
d229 1
a229 1
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
d237 1
a237 1
#include <dev/pci/ncr_reg.h>
d240 1
a240 1
#if !defined(__alpha__) && !defined(__powerpc__)
d243 2
a244 1
#endif /* __NetBSD__ || __OpenBSD__ */      
a245 1
#include <scsi/scsi_all.h>
d248 17
a264 1
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(__alpha__)
d333 1
a333 3
#if defined(__NetBSD__) || defined(__OpenBSD__)

#ifdef NCR_IOMAPPED
d338 1
a338 1
    bus_space_read_1 (np->sc_memt, np->sc_bah, (o))
d340 1
a340 1
    bus_space_read_2 (np->sc_memt, np->sc_bah, offsetof(struct ncr_reg, r))
d344 1
a344 1
    bus_space_read_4 (np->sc_memt, np->sc_bah, (o))
d347 1
a347 1
    bus_space_write_1 (np->sc_memt, np->sc_bah, offsetof(struct ncr_reg, r), (val))
d349 1
a349 1
    bus_space_write_2 (np->sc_memt, np->sc_bah, offsetof(struct ncr_reg, r), (val))
d353 1
a353 1
    bus_space_write_4 (np->sc_memt, np->sc_bah, (o), (val))
d355 11
a365 1
#else
d367 2
a368 10
#define	INB(r) \
    INB_OFF(offsetof(struct ncr_reg, r))
#define	INB_OFF(o) \
    bus_space_read_1 (np->sc_memt, np->sc_bah, (o))
#define	INW(r) \
    bus_space_read_2 (np->sc_memt, np->sc_bah, offsetof(struct ncr_reg, r))
#define	INL(r) \
    INL_OFF(offsetof(struct ncr_reg, r))
#define	INL_OFF(o) \
    bus_space_read_4 (np->sc_memt, np->sc_bah, (o))
d370 2
a371 8
#define	OUTB(r, val) \
    bus_space_write_1 (np->sc_memt, np->sc_bah, offsetof(struct ncr_reg, r), (val))
#define	OUTW(r, val) \
    bus_space_write_2 (np->sc_memt, np->sc_bah, offsetof(struct ncr_reg, r), (val))
#define	OUTL(r, val) \
    OUTL_OFF(offsetof(struct ncr_reg, r), (val))
#define	OUTL_OFF(o, val) \
    bus_space_write_4 (np->sc_memt, np->sc_bah, (o), (val))
d373 1
a373 1
#endif
d375 1
a375 1
#else /* !(__NetBSD__ || __OpenBSD__) */ 
a376 2
#ifdef NCR_IOMAPPED
 
d391 1
a391 1
#define	INB_OFF(o) (*((volatile INT8 *)((char *)np->reg + (o))))
d394 1
a394 1
#define	INL_OFF(o) (*((volatile INT32 *)((char *)np->reg + (o))))
d399 1
a399 1
#define	OUTL_OFF(o, val) *((volatile INT32 *)((char *)np->reg + (o))) = val
d403 16
a418 1
#endif /* __NetBSD__ || __OpenBSD__ */      
d527 1
a527 1
**	Note that various types are defined in ncr_reg.h.
d669 8
d816 3
a818 3
	u_long		savep;
	u_long		lastp;
	u_long		goalp;
d845 1
a845 1
**	(declared as scr0..scr3 in ncr_reg.h) just after the select/reselect,
d949 6
d1072 9
a1080 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d1082 1
d1084 4
a1087 4
	bus_space_tag_t sc_memt;
	pci_chipset_tag_t sc_pc;
	bus_space_handle_t sc_bah;
#else /* !(__NetBSD__ || __OpenBSD__) */ 
d1089 1
a1089 1
#endif /* __NetBSD__ || __OpenBSD__ */      
d1112 8
a1119 1
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
a1121 3
#else
	bus_addr_t	paddr;
#endif
d1123 3
a1125 1
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
d1134 1
a1134 1
	**	A copy of the script, relocated for this ncb.
d1137 1
d1140 1
a1140 1
	**	Physical address of this instance of ncb->script
d1143 1
d1148 1
a1148 1
	u_char	  myaddr;
d1153 9
a1161 2
	u_char		ns_sync;
	u_char		maxoffs;
d1170 1
d1172 2
d1199 1
a1199 1
	u_long		squeue [MAX_START];
d1210 3
a1230 7
	**	The global header.
	**	Accessible to both the host and the
	**	script-processor.
	*/
	struct head     header;

	/*
d1235 2
d1238 1
a1238 1
	struct ccb      ccb;
d1248 1
a1248 1
	u_long		lastmsg;
d1265 1
a1265 1
#if defined(NCR_IOMAPPED) && !(defined(__NetBSD__) || defined(__OpenBSD__))
d1274 1
d1297 4
a1305 1
	ncrcmd  tryloop		[MAX_START*5+2];
a1322 8
	ncrcmd  msg_parity	[  6];
	ncrcmd	msg_reject	[  8];
	ncrcmd	msg_ign_residue	[ 32];
	ncrcmd  msg_extended	[ 18];
	ncrcmd  msg_ext_2	[ 18];
	ncrcmd	msg_wdtr	[ 27];
	ncrcmd  msg_ext_3	[ 18];
	ncrcmd	msg_sdtr	[ 27];
d1334 24
a1366 8
	ncrcmd  badgetcc	[  6];
	ncrcmd	reselect	[ 12];
	ncrcmd	reselect2	[  6];
	ncrcmd	resel_tmp	[  5];
	ncrcmd  resel_lun	[ 18];
	ncrcmd	resel_tag	[ 24];
	ncrcmd  data_in		[MAX_SCATTER * 4 + 7];
	ncrcmd  data_out	[MAX_SCATTER * 4 + 7];
d1388 2
a1389 1
static	void	ncr_getclock	(ncb_p np);
d1392 1
a1392 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d1396 3
a1398 3
static  U_INT32 ncr_info	(int unit);
#endif	/* !(__NetBSD__ || __OpenBSD__) */ 	
static	void	ncr_int_ma	(ncb_p np);
d1401 1
a1401 1
#ifndef NEW_SCSICONF
d1403 1
a1403 2
#endif /* NEW_SCSICONF */
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
a1404 3
#else
static	void	ncr_minphys	(struct buf *bp);
#endif
d1409 2
a1410 2
				(struct script * script, ncb_p np);
static  void    ncr_script_fill (struct script * scr);
d1414 5
a1418 3
static	void	ncr_setsync	(ncb_p np, ccb_p cp, u_char sxfer);
static	void	ncr_settags     (tcb_p tp, lcb_p lp);
static	void	ncr_setwide	(ncb_p np, ccb_p cp, u_char wide);
d1421 2
a1422 2
static	INT32	ncr_start       (struct scsi_xfer *xp);
static	void	ncr_timeout	(ncb_p np);
d1426 1
a1426 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d1433 1
a1433 1
#else /* !(__NetBSD__ || __OpenBSD__) */ 
d1436 1
a1436 1
#endif /* __NetBSD__ || __OpenBSD__ */      
d1452 1
a1452 1
	"\n$OpenBSD: ncr.c,v 1.30 1997/09/07 03:36:43 millert Exp $\n";
d1463 1
a1463 1
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
d1466 1
a1466 1
#endif /* !(__NetBSD__ || __OpenBSD__) */ 
d1469 1
a1469 1
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
d1471 1
a1471 1
#endif /* !(__NetBSD__ || __OpenBSD__) */ 
d1486 1
d1490 4
d1495 1
a1495 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d1505 1
a1505 1
#else /* !(__NetBSD__ || __OpenBSD__) */ 
d1519 1
a1519 1
#endif /* !(__NetBSD__ || __OpenBSD__) */ 
a1523 1
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
a1524 3
#else
	ncr_minphys,
#endif
d1527 1
a1527 1
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
d1530 1
a1530 1
#endif /* !(__NetBSD__ || __OpenBSD__) */ 
d1539 1
a1539 1
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
d1541 1
a1541 1
#endif /* !(__NetBSD__ || __OpenBSD__) */ 
d1544 1
a1544 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d1548 1
a1548 1
#else /* !(__NetBSD__ || __OpenBSD__) */ 
d1581 1
d1586 1
d1591 3
a1593 3
#define	SCRIPT_KVAR_MONO_TIME_TV_SEC	(0)
#define	SCRIPT_KVAR_MONO_TIME		(SCRIPT_KVAR_MONO_TIME_TV_SEC + 1)
#define	SCRIPT_KVAR_NCR_CACHE		(SCRIPT_KVAR_MONO_TIME + 1)
d1595 2
a1596 2
#define	SCRIPT_KVAR_FIRST		SCRIPT_KVAR_MONO_TIME_TV_SEC
#define	SCRIPT_KVAR_LAST		SCRIPT_KVAR_NCR_CACHE
d1602 1
d1608 4
d1619 1
a1619 1
		KVAR(SCRIPT_KVAR_MONO_TIME_TV_SEC),
d1652 1
a1652 26
		PADDR(tryloop),
}/*-------------------------< TRYLOOP >---------------------*/,{
/*
**	Load an entry of the start queue into dsa
**	and try to start it by jumping to TRYSEL.
**
**	Because the size depends on the
**	#define MAX_START parameter, it is filled
**	in at runtime.
**
**-----------------------------------------------------------
**
**  ##===========< I=0; i<MAX_START >===========
**  ||	SCR_COPY (4),
**  ||		NADDR (squeue[i]),
**  ||		RADDR (dsa),
**  ||	SCR_CALL,
**  ||		PADDR (trysel),
**  ##==========================================
**
**	SCR_JUMP,
**		PADDR(tryloop),
**
**-----------------------------------------------------------
*/
0
d1708 1
a1708 1
	SCR_COPY (4),
d1814 1
a1814 1
	SCR_COPY (4),
d1838 1
a1838 1
		KVAR(SCRIPT_KVAR_MONO_TIME),
d1891 1
a1891 1
		PADDR (msg_reject),
d2020 1
a2020 1
		KVAR(SCRIPT_KVAR_MONO_TIME),
d2042 1
a2042 1
		KVAR(SCRIPT_KVAR_MONO_TIME),
d2108 1
a2108 1
		PADDR (msg_parity),
d2123 1
a2123 1
		PADDR (msg_extended),
d2127 1
a2127 1
		PADDR (msg_reject),
d2129 1
a2129 1
		PADDR (msg_ign_residue),
d2148 1
a2148 1
}/*-------------------------< MSG_PARITY >---------------*/,{
d2150 4
a2153 1
	**	count it
d2155 1
a2155 1
	SCR_REG_REG (PS_REG, SCR_ADD, 0x01),
d2157 12
a2168 2
	/*
	**	send a "message parity error" message.
d2170 1
a2170 1
	SCR_LOAD_REG (scratcha, M_PARITY),
a2171 3
	SCR_JUMP,
		PADDR (setmsg),
}/*-------------------------< MSG_REJECT >---------------*/,{
d2173 1
a2173 2
	**	If a negotiation was in progress,
	**	negotiation failed.
d2175 1
a2175 1
	SCR_FROM_REG (HS_REG),
a2176 2
	SCR_INT ^ IFTRUE (DATA (HS_NEGOTIATE)),
		SIR_NEGO_FAILED,
d2178 1
a2178 1
	**	else make host log this message
d2180 3
a2182 6
	SCR_INT ^ IFFALSE (DATA (HS_NEGOTIATE)),
		SIR_REJECT_RECEIVED,
	SCR_JUMP,
		PADDR (clrack),

}/*-------------------------< MSG_IGN_RESIDUE >----------*/,{
d2184 4
a2187 1
	**	Terminate cycle
d2189 1
a2189 1
	SCR_CLR (SCR_ACK),
d2191 2
a2192 2
	SCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),
		PADDR (dispatch),
d2194 2
a2195 1
	**	get residue size.
d2197 3
a2199 2
	SCR_MOVE_ABS (1) ^ SCR_MSG_IN,
		NADDR (msgin[1]),
d2201 1
a2201 1
	**	Check for message parity error.
d2203 522
a2724 7
	SCR_TO_REG (scratcha),
		0,
	SCR_FROM_REG (socl),
		0,
	SCR_JUMP ^ IFTRUE (MASK (CATN, CATN)),
		PADDR (msg_parity),
	SCR_FROM_REG (scratcha),
d2782 1
a2782 1
		PADDR (msg_parity),
d2788 1
a2788 1
		PADDR (msg_ext_3),
d2809 1
a2809 1
		PADDR (msg_parity),
d2813 1
a2813 1
		PADDR (msg_wdtr),
d2832 1
a2832 1
		PADDR (msg_parity),
d2869 2
a2870 241
	SCR_MOVE_ABS (1) ^ SCR_MSG_IN,
		NADDR (msgin[2]),
	/*
	**	Check for message parity error.
	*/
	SCR_TO_REG (scratcha),
		0,
	SCR_FROM_REG (socl),
		0,
	SCR_JUMP ^ IFTRUE (MASK (CATN, CATN)),
		PADDR (msg_parity),
	SCR_FROM_REG (scratcha),
		0,
	SCR_JUMP ^ IFTRUE (DATA (M_X_SYNC_REQ)),
		PADDR (msg_sdtr),
	/*
	**	unknown extended message
	*/
	SCR_JUMP,
		PADDR (msg_bad)

}/*-------------------------< MSG_SDTR >-----------------*/,{
	SCR_CLR (SCR_ACK),
		0,
	SCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),
		PADDR (dispatch),
	/*
	**	get period and offset
	*/
	SCR_MOVE_ABS (2) ^ SCR_MSG_IN,
		NADDR (msgin[3]),
	SCR_FROM_REG (socl),
		0,
	SCR_JUMP ^ IFTRUE (MASK (CATN, CATN)),
		PADDR (msg_parity),
	/*
	**	let the host do the real work.
	*/
	SCR_INT,
		SIR_NEGO_SYNC,
	/*
	**	let the target fetch our answer.
	*/
	SCR_SET (SCR_ATN),
		0,
	SCR_CLR (SCR_ACK),
		0,

	SCR_INT ^ IFFALSE (WHEN (SCR_MSG_OUT)),
		SIR_NEGO_PROTO,
	/*
	**	Send the M_X_SYNC_REQ
	*/
	SCR_MOVE_ABS (5) ^ SCR_MSG_OUT,
		NADDR (msgout),
	SCR_CLR (SCR_ATN),
		0,
	SCR_COPY (1),
		RADDR (sfbr),
		NADDR (lastmsg),
	SCR_JUMP,
		PADDR (msg_out_done),

}/*-------------------------< COMPLETE >-----------------*/,{
	/*
	**	Complete message.
	**
	**	If it's not the get condition code,
	**	copy TEMP register to LASTP in header.
	*/
	SCR_FROM_REG (SS_REG),
		0,
/*<<<*/	SCR_JUMPR ^ IFTRUE (MASK (S_SENSE, S_SENSE)),
		12,
	SCR_COPY (4),
		RADDR (temp),
		NADDR (header.lastp),
/*>>>*/	/*
	**	When we terminate the cycle by clearing ACK,
	**	the target may disconnect immediately.
	**
	**	We don't want to be told of an
	**	"unexpected disconnect",
	**	so we disable this feature.
	*/
	SCR_REG_REG (scntl2, SCR_AND, 0x7f),
		0,
	/*
	**	Terminate cycle ...
	*/
	SCR_CLR (SCR_ACK|SCR_ATN),
		0,
	/*
	**	... and wait for the disconnect.
	*/
	SCR_WAIT_DISC,
		0,
}/*-------------------------< CLEANUP >-------------------*/,{
	/*
	**      dsa:    Pointer to ccb
	**	      or xxxxxxFF (no ccb)
	**
	**      HS_REG:   Host-Status (<>0!)
	*/
	SCR_FROM_REG (dsa),
		0,
	SCR_JUMP ^ IFTRUE (DATA (0xff)),
		PADDR (signal),
	/*
	**      dsa is valid.
	**	save the status registers
	*/
	SCR_COPY (4),
		RADDR (scr0),
		NADDR (header.status),
	/*
	**	and copy back the header to the ccb.
	*/
	SCR_COPY (4),
		RADDR (dsa),
		PADDR (cleanup0),
	SCR_COPY (sizeof (struct head)),
		NADDR (header),
}/*-------------------------< CLEANUP0 >--------------------*/,{
		0,

	/*
	**	If command resulted in "check condition"
	**	status and is not yet completed,
	**	try to get the condition code.
	*/
	SCR_FROM_REG (HS_REG),
		0,
/*<<<*/	SCR_JUMPR ^ IFFALSE (MASK (0, HS_DONEMASK)),
		16,
	SCR_FROM_REG (SS_REG),
		0,
	SCR_JUMP ^ IFTRUE (DATA (S_CHECK_COND)),
		PADDR(getcc2),
	/*
	**	And make the DSA register invalid.
	*/
/*>>>*/	SCR_LOAD_REG (dsa, 0xff), /* invalid */
		0,
}/*-------------------------< SIGNAL >----------------------*/,{
	/*
	**	if status = queue full,
	**	reinsert in startqueue and stall queue.
	*/
	SCR_FROM_REG (SS_REG),
		0,
	SCR_INT ^ IFTRUE (DATA (S_QUEUE_FULL)),
		SIR_STALL_QUEUE,
	/*
	**	if job completed ...
	*/
	SCR_FROM_REG (HS_REG),
		0,
	/*
	**	... signal completion to the host
	*/
	SCR_INT_FLY ^ IFFALSE (MASK (0, HS_DONEMASK)),
		0,
	/*
	**	Auf zu neuen Schandtaten!
	*/
	SCR_JUMP,
		PADDR(start),

}/*-------------------------< SAVE_DP >------------------*/,{
	/*
	**	SAVE_DP message:
	**	Copy TEMP register to SAVEP in header.
	*/
	SCR_COPY (4),
		RADDR (temp),
		NADDR (header.savep),
	SCR_JUMP,
		PADDR (clrack),
}/*-------------------------< RESTORE_DP >---------------*/,{
	/*
	**	RESTORE_DP message:
	**	Copy SAVEP in header to TEMP register.
	*/
	SCR_COPY (4),
		NADDR (header.savep),
		RADDR (temp),
	SCR_JUMP,
		PADDR (clrack),

}/*-------------------------< DISCONNECT >---------------*/,{
	/*
	**	If QUIRK_AUTOSAVE is set,
	**	do an "save pointer" operation.
	*/
	SCR_FROM_REG (QU_REG),
		0,
/*<<<*/	SCR_JUMPR ^ IFFALSE (MASK (QUIRK_AUTOSAVE, QUIRK_AUTOSAVE)),
		12,
	/*
	**	like SAVE_DP message:
	**	Copy TEMP register to SAVEP in header.
	*/
	SCR_COPY (4),
		RADDR (temp),
		NADDR (header.savep),
/*>>>*/	/*
	**	Check if temp==savep or temp==goalp:
	**	if not, log a missing save pointer message.
	**	In fact, it's a comparison mod 256.
	**
	**	Hmmm, I hadn't thought that I would be urged to
	**	write this kind of ugly self modifying code.
	**
	**	It's unbelievable, but the ncr53c8xx isn't able
	**	to subtract one register from another.
	*/
	SCR_FROM_REG (temp),
		0,
	/*
	**	You are not expected to understand this ..
	**
	**	CAUTION: only little endian architectures supported! XXX
	*/
	SCR_COPY (1),
		NADDR (header.savep),
		PADDR (disconnect0),
}/*-------------------------< DISCONNECT0 >--------------*/,{
/*<<<*/	SCR_JUMPR ^ IFTRUE (DATA (1)),
		20,
	/*
	**	neither this
	*/
	SCR_COPY (1),
		NADDR (header.goalp),
		PADDR (disconnect1),
}/*-------------------------< DISCONNECT1 >--------------*/,{
	SCR_INT ^ IFFALSE (DATA (1)),
		SIR_MISSING_SAVE,
/*>>>*/

d2872 1
a2872 4
	**	DISCONNECTing  ...
	**
	**	disable the "unexpected disconnect" feature,
	**	and remove the ACK signal.
d2874 3
a2876 1
	SCR_REG_REG (scntl2, SCR_AND, 0x7f),
d2878 3
a2880 1
	SCR_CLR (SCR_ACK|SCR_ATN),
d2882 2
d2885 1
a2885 1
	**	Wait for the disconnect.
d2887 5
a2891 1
	SCR_WAIT_DISC,
d2893 2
d2896 1
a2896 3
	**	Profiling:
	**	Set a time stamp,
	**	and count the disconnects.
d2898 3
a2900 7
	SCR_COPY (sizeof (struct timeval)),
		KVAR(SCRIPT_KVAR_MONO_TIME),
		NADDR (header.stamp.disconnect),
	SCR_COPY (4),
		NADDR (disc_phys),
		RADDR (temp),
	SCR_REG_REG (temp, SCR_ADD, 0x01),
d2902 7
a2908 3
	SCR_COPY (4),
		RADDR (temp),
		NADDR (disc_phys),
d2910 1
a2910 1
	**	Status is: DISCONNECTED.
d2912 3
a2914 1
	SCR_LOAD_REG (HS_REG, HS_DISCONNECT),
a2915 2
	SCR_JUMP,
		PADDR (cleanup),
d2917 2
a2918 1
}/*-------------------------< MSG_OUT >-------------------*/,{
d2920 1
a2920 1
	**	The target requests a message.
d2922 1
a2922 1
	SCR_MOVE_ABS (1) ^ SCR_MSG_OUT,
d2924 2
a2928 23
	/*
	**	If it was no ABORT message ...
	*/
	SCR_JUMP ^ IFTRUE (DATA (M_ABORT)),
		PADDR (msg_out_abort),
	/*
	**	... wait for the next phase
	**	if it's a message out, send it again, ...
	*/
	SCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_OUT)),
		PADDR (msg_out),
}/*-------------------------< MSG_OUT_DONE >--------------*/,{
	/*
	**	... else clear the message ...
	*/
	SCR_LOAD_REG (scratcha, M_NOOP),
		0,
	SCR_COPY (4),
		RADDR (scratcha),
		NADDR (msgout),
	/*
	**	... and process the next phase
	*/
d2930 2
a2931 1
		PADDR (dispatch),
d2962 1
a2962 1
	SCR_COPY (4),
d2964 1
a2964 1
		PADDR (getcc1),
d3030 1
a3030 1
		PADDR(getcc3),
d3077 1
a3077 160
	**	save target id.
	*/
	SCR_FROM_REG (sdid),
		0,
	SCR_TO_REG (ctest0),
		0,
	/*
	**	Force error if selection timeout
	*/
	SCR_JUMPR ^ IFTRUE (WHEN (SCR_MSG_IN)),
		0,
	/*
	**	don't negotiate.
	*/
	SCR_JUMP,
		PADDR (prepare2),

}/*------------------------< BADGETCC >---------------------*/,{
	/*
	**	If SIGP was set, clear it and try again.
	*/
	SCR_FROM_REG (ctest2),
		0,
	SCR_JUMP ^ IFTRUE (MASK (CSIGP,CSIGP)),
		PADDR (getcc2),
	SCR_INT,
		SIR_SENSE_FAILED,
}/*-------------------------< RESELECT >--------------------*/,{
	/*
	**	make the DSA invalid.
	*/
	SCR_LOAD_REG (dsa, 0xff),
		0,
	SCR_CLR (SCR_TRG),
		0,
	/*
	**	Sleep waiting for a reselection.
	**	If SIGP is set, special treatment.
	**
	**	Zu allem bereit ..
	*/
	SCR_WAIT_RESEL,
		PADDR(reselect2),
	/*
	**	... zu nichts zu gebrauchen ?
	**
	**      load the target id into the SFBR
	**	and jump to the control block.
	**
	**	Look at the declarations of
	**	- struct ncb
	**	- struct tcb
	**	- struct lcb
	**	- struct ccb
	**	to understand what's going on.
	*/
	SCR_REG_SFBR (ssid, SCR_AND, 0x8F),
		0,
	SCR_TO_REG (ctest0),
		0,
	SCR_JUMP,
		NADDR (jump_tcb),
}/*-------------------------< RESELECT2 >-------------------*/,{
	/*
	**	If it's not connected :(
	**	-> interrupted by SIGP bit.
	**	Jump to start.
	*/
	SCR_FROM_REG (ctest2),
		0,
	SCR_JUMP ^ IFTRUE (MASK (CSIGP,CSIGP)),
		PADDR (start),
	SCR_JUMP,
		PADDR (reselect),

}/*-------------------------< RESEL_TMP >-------------------*/,{
	/*
	**	The return address in TEMP
	**	is in fact the data structure address,
	**	so copy it to the DSA register.
	*/
	SCR_COPY (4),
		RADDR (temp),
		RADDR (dsa),
	SCR_JUMP,
		PADDR (prepare),

}/*-------------------------< RESEL_LUN >-------------------*/,{
	/*
	**	come back to this point
	**	to get an IDENTIFY message
	**	Wait for a msg_in phase.
	*/
/*<<<*/	SCR_JUMPR ^ IFFALSE (WHEN (SCR_MSG_IN)),
		48,
	/*
	**	message phase
	**	It's not a sony, it's a trick:
	**	read the data without acknowledging it.
	*/
	SCR_FROM_REG (sbdl),
		0,
/*<<<*/	SCR_JUMPR ^ IFFALSE (MASK (M_IDENTIFY, 0x98)),
		32,
	/*
	**	It WAS an Identify message.
	**	get it and ack it!
	*/
	SCR_MOVE_ABS (1) ^ SCR_MSG_IN,
		NADDR (msgin),
	SCR_CLR (SCR_ACK),
		0,
	/*
	**	Mask out the lun.
	*/
	SCR_REG_REG (sfbr, SCR_AND, 0x07),
		0,
	SCR_RETURN,
		0,
	/*
	**	No message phase or no IDENTIFY message:
	**	return 0.
	*/
/*>>>*/	SCR_LOAD_SFBR (0),
		0,
	SCR_RETURN,
		0,

}/*-------------------------< RESEL_TAG >-------------------*/,{
	/*
	**	come back to this point
	**	to get a SIMPLE_TAG message
	**	Wait for a MSG_IN phase.
	*/
/*<<<*/	SCR_JUMPR ^ IFFALSE (WHEN (SCR_MSG_IN)),
		64,
	/*
	**	message phase
	**	It's a trick - read the data
	**	without acknowledging it.
	*/
	SCR_FROM_REG (sbdl),
		0,
/*<<<*/	SCR_JUMPR ^ IFFALSE (DATA (M_SIMPLE_TAG)),
		48,
	/*
	**	It WAS a SIMPLE_TAG message.
	**	get it and ack it!
	*/
	SCR_MOVE_ABS (1) ^ SCR_MSG_IN,
		NADDR (msgin),
	SCR_CLR (SCR_ACK),
		0,
	/*
	**	Wait for the second byte (the tag)
	*/
/*<<<*/	SCR_JUMPR ^ IFFALSE (WHEN (SCR_MSG_IN)),
		24,
	/*
	**	Get it and ack it!
d3079 1
a3079 3
	SCR_MOVE_ABS (1) ^ SCR_MSG_IN,
		NADDR (msgin),
	SCR_CLR (SCR_ACK|SCR_CARRY),
d3081 1
a3081 1
	SCR_RETURN,
d3084 1
a3084 2
	**	No message phase or no SIMPLE_TAG message
	**	or no second byte: return 0.
d3086 1
a3086 1
/*>>>*/	SCR_LOAD_SFBR (0),
d3088 5
a3092 61
	SCR_SET (SCR_CARRY),
		0,
	SCR_RETURN,
		0,

}/*-------------------------< DATA_IN >--------------------*/,{
/*
**	Because the size depends on the
**	#define MAX_SCATTER parameter,
**	it is filled in at runtime.
**
**	SCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_IN)),
**		PADDR (no_data),
**	SCR_COPY (sizeof (struct timeval)),
**		KVAR(SCRIPT_KVAR_MONO_TIME),
**		NADDR (header.stamp.data),
**	SCR_MOVE_TBL ^ SCR_DATA_IN,
**		offsetof (struct dsb, data[ 0]),
**
**  ##===========< i=1; i<MAX_SCATTER >=========
**  ||	SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN)),
**  ||		PADDR (checkatn),
**  ||	SCR_MOVE_TBL ^ SCR_DATA_IN,
**  ||		offsetof (struct dsb, data[ i]),
**  ##==========================================
**
**	SCR_CALL,
**		PADDR (checkatn),
**	SCR_JUMP,
**		PADDR (no_data),
*/
0
}/*-------------------------< DATA_OUT >-------------------*/,{
/*
**	Because the size depends on the
**	#define MAX_SCATTER parameter,
**	it is filled in at runtime.
**
**	SCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_IN)),
**		PADDR (no_data),
**	SCR_COPY (sizeof (struct timeval)),
**		KVAR(SCRIPT_KVAR_MONO_TIME),
**		NADDR (header.stamp.data),
**	SCR_MOVE_TBL ^ SCR_DATA_OUT,
**		offsetof (struct dsb, data[ 0]),
**
**  ##===========< i=1; i<MAX_SCATTER >=========
**  ||	SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT)),
**  ||		PADDR (dispatch),
**  ||	SCR_MOVE_TBL ^ SCR_DATA_OUT,
**  ||		offsetof (struct dsb, data[ i]),
**  ##==========================================
**
**	SCR_CALL,
**		PADDR (dispatch),
**	SCR_JUMP,
**		PADDR (no_data),
**
**---------------------------------------------------------
*/
0
d3134 1
a3134 1
		KVAR(SCRIPT_KVAR_NCR_CACHE),
d3141 1
a3141 1
		KVAR(SCRIPT_KVAR_NCR_CACHE),
d3146 1
a3146 1
		KVAR(SCRIPT_KVAR_NCR_CACHE),
d3157 1
d3167 1
a3167 1
void ncr_script_fill (struct script * scr)
d3172 1
a3172 1
	p = scr->tryloop;
d3181 1
a3181 1
	*p++ =PADDR(tryloop);
d3183 1
a3183 1
	assert ((u_long)p == (u_long)&scr->tryloop + sizeof (scr->tryloop));
d3190 1
a3190 1
	*p++ =KVAR(SCRIPT_KVAR_MONO_TIME);
d3214 1
a3214 1
	*p++ =KVAR(SCRIPT_KVAR_MONO_TIME);
d3243 1
a3243 1
static void ncr_script_copy_and_bind (struct script *script, ncb_p np)
d3246 2
a3247 15
	ncrcmd	*src, *dst, *start, *end;
	int relocs;

#if !(defined(__NetBSD__) || defined(__OpenBSD__))
	np->script = (struct script*) vm_page_alloc_contig 
	(round_page(sizeof (struct script)), 0x100000, 0xffffffff, PAGE_SIZE);
#else  /* !(__NetBSD__ || __OpenBSD__) */
	np->script = (struct script *)
		malloc (sizeof (struct script), M_DEVBUF, M_WAITOK);
#endif /* __NetBSD__ || __OpenBSD__ */      

	np->p_script = vtophys(np->script);

	src = script->start;
	dst = np->script->start;
d3250 2
a3251 1
	end = src + (sizeof (struct script) / 4);
d3256 2
a3257 1
		*dst++ = SCR_BO(opcode);
d3273 2
a3274 1
			printf ("%p:  <%x>\n", (src-1), (unsigned)opcode);
d3296 8
a3303 1
			};
d3347 3
d3370 1
a3370 1
					panic("ncr_script_copy_and_bind: weird relocation %x\n", old);
d3374 2
a3375 1
				*dst++ = SCR_BO(new);
d3377 3
d3381 1
a3381 4
		else {
			*dst++ = SCR_BO(*src);
			src++;
		}
d3409 1
a3409 1
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
d3415 1
a3415 1
void ncr_minphys (struct buf *bp)
d3417 1
a3417 1
	if(bp->b_bcount > MAX_SIZE)
d3430 2
a3431 2
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
U_INT32 ncr_info (int unit)
d3439 77
d3521 1
a3521 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d3534 1
d3541 1
a3541 5
	if (pa->pa_id != NCR_810_ID &&
	    pa->pa_id != NCR_815_ID &&
	    pa->pa_id != NCR_825_ID &&
	    pa->pa_id != NCR_860_ID &&
	    pa->pa_id != NCR_875_ID)
d3547 1
a3547 1
#else /* !(__NetBSD__ || __OpenBSD__) */ 
d3553 1
a3553 14
	switch (type) {

	case NCR_810_ID:
		return (rev & 0xf0) == 0x00
			? ("ncr 53c810 scsi") 
			: ("ncr 53c810a scsi");

	case NCR_815_ID:
		return ("ncr 53c815 scsi");

	case NCR_825_ID:
		return (rev & 0xf0) == 0x00
			? ("ncr 53c825 wide scsi")
			: ("ncr 53c825a wide scsi");
d3555 3
a3557 2
	case NCR_860_ID:
		return ("ncr 53c860 scsi");
a3558 3
	case NCR_875_ID:
		return ("ncr 53c875 wide scsi");
	}
d3562 36
a3597 1
#endif /* !(__NetBSD__ || __OpenBSD__) */ 
d3599 18
d3627 1
a3627 4
#define	MIN_ASYNC_PD	40
#define	MIN_SYNC_PD	20

#if defined(__NetBSD__) || defined(__OpenBSD__)
d3641 2
a3642 1
	int wide = 0;
d3645 1
a3645 23
	printf(": NCR ");
	switch (pa->pa_id) {
	case NCR_810_ID:
		printf((rev & 0xf0) == 0x00 ? "53c810" : "53c810a");
		break;
	case NCR_815_ID:
		printf("53c815");
		break;
	case NCR_825_ID:
		printf((rev & 0xf0) == 0x00 ? "53c825 Wide" : "53c825a Wide");
		wide = 1;
		break;
	case NCR_860_ID:
		printf("53c860");
		break;
	case NCR_875_ID:
		printf("53c875 Wide");
		wide = 1;
		break;
	}
	printf(" SCSI\n");

	np->sc_memt = memt;
d3647 3
d3659 1
a3659 1
		printf("%s: couldn't find memory region\n", self->dv_xname);
d3664 1
a3664 2
	retval = bus_space_map(pa->pa_memt, np->paddr, memsize, 0,
	    &np->sc_bah);
d3666 1
a3666 1
		printf("%s: couldn't map memory region\n", self->dv_xname);
d3676 1
a3676 1
		printf("%s: couldn't map interrupt\n", self->dv_xname);
a3679 4
#ifndef __OpenBSD__
	np->sc_ih = pci_intr_establish(pc, intrhandle, IPL_BIO,
	    ncr_intr, np);
#else /* !__OpenBSD__ */
a3681 1
#endif /* __OpenBSD__ */
d3683 1
a3683 1
		printf("%s: couldn't establish interrupt", self->dv_xname);
d3689 2
d3692 3
a3694 1
		printf("%s: interrupting at %s\n", self->dv_xname, intrstr);
d3696 1
a3696 1
#else /* !(__NetBSD__ || __OpenBSD__) */ 
d3708 3
d3713 1
a3713 1
	**	allocate structure
d3721 213
d3936 1
a3936 1
	**	initialize structure.
d3938 21
d3960 11
a3970 2
	bzero (np, sizeof (*np));
	np->unit = unit;
d3972 1
d3974 2
a3975 2
	**	Try to map the controller chip to
	**	virtual and physical memory.
d3977 4
d3982 6
a3987 2
	if (!pci_map_mem (config_id, 0x14, &np->vaddr, &np->paddr))
		return;
d3989 8
a3996 5
	/*
	**	Make the controller's registers available.
	**	Now the INB INW INL OUTB OUTW OUTL macros
	**	can be used safely.
	*/
d3998 1
a3998 1
	np->reg = (struct ncr_reg*) np->vaddr;
a3999 1
#ifdef NCR_IOMAPPED
d4001 1
a4001 1
	**	Try to map the controller chip into iospace.
d4003 5
a4007 6

	if (!pci_map_port (config_id, 0x10, &np->port))
		return;
#endif

#endif /* !(__NetBSD__ || __OpenBSD__) */ 
d4010 1
a4010 1
	**	Save some controller register default values
d4012 7
a4018 7

	np->rv_dmode  = INB (nc_dmode);
	np->rv_dcntl  = INB (nc_dcntl) | CLSE | PFEN | NOCOM;
	np->rv_ctest3 = INB (nc_ctest3);
	np->rv_ctest5 = 0;
	np->rv_scntl3 = 0x13;	/* default: 40MHz clock */

d4020 1
a4020 1
	**	Do chip dependent initialization.
d4022 5
d4028 2
a4029 3
	np->maxwide   = 0;
	np->ns_sync   = 25;	/* in units of 4ns */
	np->maxoffs   = 8;
d4031 2
a4032 4
	/*
	**	Get the frequency of the chip's clock.
	**	Find the right value for scntl3.
	*/
d4034 1
a4034 35
#if defined(__NetBSD__) || defined(__OpenBSD__)
	switch (pa->pa_id) {
#else /* !(__NetBSD__ || __OpenBSD__) */ 
	switch (pci_conf_read (config_id, PCI_ID_REG)) {
#endif /* __NetBSD__ || __OpenBSD__ */      
	case NCR_825_ID:
	    {
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
		u_char rev = pci_conf_read (config_id, PCI_CLASS_REG) & 0xff;
#endif /* !(__NetBSD__ || __OpenBSD__) */ 
		if ((rev & 0xf0) == 0x10)
			np->maxoffs = 16;
		np->maxwide = 1;
		break;
	    }
	case NCR_860_ID:
		np->rv_scntl3 = 0x35;	/* always assume 80MHz clock for 860 */
		/*np->ns_sync   = 12;*/	/* in units of 4ns */
		break;
	case NCR_875_ID:
		np->maxwide = 1;
		/*np->ns_sync   = 12;*/	/* in units of 4ns */
		np->maxoffs = 16;
#ifdef NCR_TEKRAM_EEPROM
		if (bootverbose) 
		{
			printf ("%s: Tekram EEPROM read %s\n",
				ncr_name(np),
				read_tekram_eeprom (np, NULL) ?
				"succeeded" : "failed");
		}
#endif /* NCR_TEKRAM_EEPROM */
		ncr_getclock(np);
		break;
	}
d4037 1
a4037 1
	**	Patch script to physical addresses
d4040 5
a4044 3
	ncr_script_fill (&script0);
	ncr_script_copy_and_bind (&script0, np);
	np->ccb.p_ccb		= vtophys (&np->ccb);
d4051 1
a4051 1
	np->jump_tcb.l_paddr	= SCR_BO(NCB_SCRIPT_PHYS (np, abort));
d4066 1
a4066 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d4068 1
a4068 1
#endif /* __NetBSD__ || __OpenBSD__ */      
d4071 1
a4071 1
			printf (" %08x", (int)pci_conf_read (pc, config_id, reg));
d4095 1
a4095 1
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
d4102 1
a4102 1
#endif /* __NetBSD__ || __OpenBSD__ */      
d4126 1
a4126 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a4129 4
#ifndef __OpenBSD__
	np->sc_link.channel      = SCSI_CHANNEL_ONLY_ONE;
	np->sc_link.max_target   = wide ? 15 : 7;
#else
d4132 1
a4132 2
#endif /* __OpenBSD__ */
#else /* !(__NetBSD__ || __OpenBSD__) */ 
d4137 1
a4137 1
#endif /* !(__NetBSD__ || __OpenBSD__) */ 
d4142 1
a4142 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d4144 1
a4144 1
#else /* !(__NetBSD__ || __OpenBSD__) */ 
d4175 1
a4175 1
#endif /* !(__NetBSD__ || __OpenBSD__) */ 
d4188 1
d4205 1
a4205 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d4207 1
a4207 1
#else /* !(__NetBSD__ || __OpenBSD__) */ 
d4209 1
a4209 1
#endif /* __NetBSD__ || __OpenBSD__ */      
d4213 1
a4213 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d4229 2
a4230 2
#if defined(__NetBSD__) || defined(__OpenBSD__)
		n = 1;
d4238 1
a4238 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d4253 1
a4253 1
static INT32 ncr_start (struct scsi_xfer * xp)
d4255 1
a4255 1
	ncb_p np = (ncb_p) xp->sc_link->adapter_softc;
d4257 1
a4257 1
	struct scsi_generic * cmd = xp->cmd;
d4318 1
a4318 1
		printf ("trying to transfer %8x bytes, mem addr = %p\n", 
d4321 1
a4321 1
			int i;
d4324 2
a4325 2
			for (i = 0; i<11; i++)
				printf (" %2x", cmd->bytes[i]);
d4332 1
a4332 1
		printf ("CMD=%x F=%x A=%p L=%x ", 
d4368 2
a4369 1
	if (!(cp=ncr_get_ccb (np, flags, xp->sc_link->target, xp->sc_link->lun))) {
d4385 1
d4387 3
d4403 2
a4404 2
#ifdef NEW_SCSICONF
		tp->quirks = xp->sc_link->quirks;
d4406 8
a4413 1
		tp->quirks = ncr_lookup ((char*) &tp->inqdata[0]);
d4415 1
a4415 1
		if (tp->quirks & ~QUIRK_NOMSG) {
d4417 1
a4417 1
			printf ("quirks=%x.\n", tp->quirks);
d4419 4
d4434 1
a4434 1
	if (tp->inqdata[7]) {
d4451 1
a4451 1
			if (SCSI_NCR_MAX_SYNC 
d4464 9
d4510 1
a4510 1
	if ((cp!=&np->ccb) && (np->disc))
d4696 1
d4698 3
d4716 2
a4717 2
		SCR_BO((unsigned)(np->script->startpos[0]))- 
			   (NCB_SCRIPT_PHYS (np, tryloop)));
d4735 3
a4737 3
#if defined(__NetBSD__) || defined(__OpenBSD__)
        if (!(flags & SCSI_POLL)) {
#else /* !(__NetBSD__ || __OpenBSD__) */  
d4739 1
a4739 1
#endif /* __NetBSD__ || __OpenBSD__ */      
d4788 3
a4790 3
#if defined(__NetBSD__) || defined(__OpenBSD__)
        if (!(flags & SCSI_POLL)) 
#else /* !(__NetBSD__ || __OpenBSD__) */  
d4792 1
a4792 1
#endif /* __NetBSD__ || __OpenBSD__ */      
d4841 1
a4841 1
		printf ("CCB=%lx STAT=%x/%x\n", (unsigned long)cp,
d4850 9
d4868 1
a4868 1
		tp->usrsync = 255;
d4889 1
a4889 1
		if (cp->host_status == HS_COMPLETE)
d4896 4
a4899 4
#if defined(__NetBSD__) || defined(__OpenBSD__)
	if (xp->error != XS_NOERROR) { 
                                
                /*              
d4902 2
a4903 2
	} else                        
#endif /* __NetBSD__ || __OpenBSD__ */      
a4934 6

			/*
			**	set number of tags
			*/
			ncr_setmaxtags (tp, tp->usrtags);

a4949 1
			ncr_settags (tp, lp);
d4956 1
a4956 1
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
d4963 1
a4963 1
#endif /* !(__NetBSD__ || __OpenBSD__) */ 
d4981 2
a4982 1
		&& (cp->scsi_status == S_BUSY)) {
d4985 1
a4985 1
		**   Target is busy.
d4995 1
d5079 1
a5079 1
	ccb_p cp = &np->ccb;
a5118 1
	u_char	burstlen;
d5126 1
d5146 2
a5147 2
	np->script->startpos[0] = SCR_BO(NCB_SCRIPT_PHYS (np, tryloop));
	np->script->start0  [0] = SCR_BO(SCR_INT ^ IFFALSE (0));
a5158 3
	burstlen = 0xc0;		/* XXX 53c875 needs code change to   */
					/*     be able to use larger bursts  */

d5162 1
a5162 1
	OUTB (nc_scntl3, np->rv_scntl3);/*  timing prescaler		     */
d5170 2
a5171 2
	OUTB (nc_ctest4, MPEE	);	/*  enable master parity checking    */
	OUTB (nc_stest2, EXT    );	/*  Extended Sreq/Sack filtering     */
d5175 13
a5187 8
#ifdef __FreeBSD__
	if (bootverbose) {
	  printf ("\tBIOS values: dmode: %02x, dcntl: %02x, ctest3: %02x\n",
		np->rv_dmode, np->rv_dcntl, np->rv_ctest3);
	  printf ("\tdmode: %02x/%02x, dcntl: %02x/%02x, ctest3: %02x/%02x\n",
		burstlen | ERL | ERMP | BOF, INB (nc_dmode),
		CLSE | PFEN | NOCOM, INB (nc_dcntl),
		WRIE, INB (nc_ctest3));
a5188 1
#endif /* __FreeBSD__ */
d5196 6
a5201 9
	if (SCSI_NCR_MAX_SYNC) {
		u_long period;
		period =1000000/SCSI_NCR_MAX_SYNC; /* ns = 10e6 / kHz */
		if (period <= 11 * np->ns_sync) {
			if (period < 4 * np->ns_sync)
				usrsync = np->ns_sync;
			else
				usrsync = period / 4;
		};
d5276 2
a5277 2
	if (minsync < np->ns_sync)
		minsync = np->ns_sync;
d5283 1
a5283 1
	if (minsync > (np->ns_sync * 11) / 4)
d5303 70
d5378 1
a5378 1
static void ncr_setsync (ncb_p np, ccb_p cp, u_char sxfer)
d5382 1
a5393 1
	tp->period= sxfer&0x1f ? ((sxfer>>5)+4) * np->ns_sync : 0xffff;
d5395 20
a5414 1
	if (tp->sval == sxfer) return;
d5416 1
d5423 1
a5423 1
		unsigned f10 = 10000 << (tp->widedone ? tp->widedone -1 : 0);
d5428 1
a5428 1
		if (tp->period <= 200) OUTB (nc_stest2, 0);
d5430 1
a5430 1
			mb10 / 10, mb10 % 10, tp->period, sxfer & 0x1f);
d5438 2
d5444 1
a5444 1
	for (cp = &np->ccb; cp; cp = cp->link_ccb) {
d5448 1
d5455 3
d5462 1
a5462 1
static void ncr_setwide (ncb_p np, ccb_p cp, u_char wide)
d5467 2
a5468 1
	u_char	scntl3 = np->rv_scntl3 | (wide ? EWS : 0);
d5480 9
a5488 1
	if (tp->wval == scntl3) return;
d5495 4
a5498 2
	printf ("WIDE SCSI %sabled\n",
	    (scntl3 & EWS) ? "(16 bit) en" : "dis");
d5503 2
d5511 1
a5511 1
	for (cp = &np->ccb; cp; cp = cp->link_ccb) {
d5514 1
a5528 1
	tp->usrtags = usrtags;
d5534 1
a5534 1
		ncr_settags (tp, lp);
d5538 1
a5538 1
static void ncr_settags (tcb_p tp, lcb_p lp)
d5549 4
a5552 2
	if ((tp->inqdata[7] & INQ7_QUEUE) == 0) {
	    tp->usrtags=0;
d5554 2
a5555 5
	if (tp->quirks & QUIRK_NOTAGS) {
		tp->usrtags = 0;
	}
	if (tp->usrtags && ((tp->inqdata[0] & 0x1f) == 0x00)) {
		reqtags = tp->usrtags;
d5577 2
d5611 3
a5613 1
			ncr_setmaxtags (&np->target[t], np->user.data);
d5665 1
a5665 1
static void ncr_timeout (ncb_p np)
d5667 2
d5670 3
d5719 1
a5719 1
		for (cp=&np->ccb; cp; cp=cp->link_ccb) {
d5765 5
a5769 1
	timeout (TIMEOUT ncr_timeout, (caddr_t) np, step ? step : 1);
d5787 79
d5875 2
a5876 4
	U_INT8	istat, dstat;
	U_INT16	sist;
	U_INT32	dsp, dsa;
	int	i, script_ofs;
d5896 1
a5896 1
 	sist  = (istat & SIP) ? INW (nc_sist)  : 0;
d5947 1
a5947 1
		ncr_int_ma (np);
d5982 7
d5993 1
d5997 5
a6007 51
	/*=========================================
	**	log message for real hard errors
	**=========================================

	"ncr0 targ 0?: ERROR (ds:si) (so-si-sd) (sxfer/scntl3) @@ (dsp:dbc)."
	"	      reg: r0 r1 r2 r3 r4 r5 r6 ..... rf."

	exception register:
		ds:	dstat
		si:	sist

	SCSI bus lines:
		so:	control lines as driver by NCR.
		si:	control lines as seen by NCR.
		sd:	scsi data lines as seen by NCR.

	wide/fastmode:
		sxfer:	(see the manual)
		scntl3:	(see the manual)

	current script command:
		dsp:	script adress (relative to start of script).
		dbc:	first word of script command.

	First 16 register of the chip:
		r0..rf

	=============================================
	*/

	dsp = (unsigned) INL (nc_dsp);
	dsa = (unsigned) INL (nc_dsa);

	script_ofs = dsp - np->p_script;

	printf ("%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @@ (%x:%08x).\n",
		ncr_name (np), INB (nc_ctest0)&0x0f, dstat, sist,
		INB (nc_socl), INB (nc_sbcl), INB (nc_sbdl),
		INB (nc_sxfer),INB (nc_scntl3), script_ofs,
		(unsigned) INL (nc_dbc));

	if (((script_ofs & 3) == 0) &&
	    (unsigned)script_ofs < sizeof(struct script)) {
		printf ("\tscript cmd = %08x\n", 
			*(ncrcmd *)((char*)np->script +script_ofs));
	}

	printf ("\treg:\t");
	for (i=0; i<16;i++)
		printf (" %02x", INB_OFF(i));
	printf (".\n");
d6102 1
a6102 1
**	They may occur if there are problems with synch transfers, or 
d6136 5
a6140 1
		untimeout (TIMEOUT ncr_timeout, (caddr_t) np);
d6193 1
a6193 1
	cp = &np->ccb;
d6207 1
a6207 1
	diff = scratcha - NCB_SCRIPT_PHYS (np, tryloop);
d6212 1
a6212 1
		np->script->startpos[0] = SCR_BO(scratcha);
d6233 1
a6233 1
static void ncr_int_ma (ncb_p np)
d6235 9
a6243 8
	U_INT32	dbc;
	U_INT32	rest;
	U_INT32	dsa;
	U_INT32	dsp;
	U_INT32	nxtdsp;
	U_INT32	*vdsp;
	U_INT32	oadr, olen;
	U_INT32	*tblp;
d6245 1
a6245 1
	U_INT32	cmd, sbcl, delta, ss0, ss2;
d6257 7
a6263 1
	delta=(INB (nc_dfifo) - rest) & 0x7f;
d6272 1
a6272 1
	if (! (INB(nc_dstat) & DFE)) rest += delta;
d6286 1
a6286 1
	cp = &np->ccb;
d6291 2
a6292 2
	    printf ("%s: SCSI phase error fixup: CCB already dequeued (0x%08lx)\n", 
		    ncr_name (np), (u_long) np->header.cp);
d6296 2
a6297 2
	    printf ("%s: SCSI phase error fixup: CCB address mismatch (0x%08lx != 0x%08lx) np.ccb = %p\n", 
		    ncr_name (np), (u_long) cp, (u_long) np->header.cp, &np->ccb);
d6307 3
a6309 2
		vdsp = &cp->patch[0];
		nxtdsp = SCR_BO(vdsp[3]);
d6311 8
a6318 2
		vdsp = &cp->patch[4];
		nxtdsp = SCR_BO(vdsp[3]);
d6320 2
a6321 1
		vdsp = (U_INT32 *) ((char*)np->script - np->p_script + dsp -8);
d6334 1
a6334 1
		printf ("\nCP=%p CP2=%p DSP=%x NXT=%x VDSP=%p CMD=%x ",
d6336 1
a6336 1
			(unsigned)nxtdsp, vdsp, cmd);
d6343 1
a6343 1
	oadr = SCR_BO(vdsp[1]);
d6346 1
a6346 1
		tblp = (U_INT32 *) ((char*) &cp->phys + oadr);
d6350 2
a6351 2
		tblp = (U_INT32 *) 0;
		olen = SCR_BO(vdsp[0]) & 0xffffff;
d6356 1
a6356 1
			(unsigned) (SCR_BO(vdsp[0]) >> 24),
d6366 1
a6366 1
	if (cmd != (SCR_BO(vdsp[0]) >> 24)) {
d6369 2
a6370 1
			(unsigned)cmd, (unsigned)SCR_BO(vdsp[0]) >> 24);
d6416 4
a6419 1
	OUTL (nc_dsp, NCB_SCRIPT_PHYS (np, dispatch));
d6450 1
d6470 1
a6470 1
		cp = &np->ccb;
d6519 1
a6519 1
			OUTL (nc_dsp, NCB_SCRIPT_PHYS (np, getcc));
d6527 1
a6527 1
		np->script->start0[0] =  SCR_INT ^ IFFALSE (0);
d6553 1
a6553 1
		np->script->start0[0] =  SCR_INT;
d6583 1
a6583 1
**	(hopefully) valid answer, set our parameters, and send back 
d6590 1
a6590 1
**	When we set the values, we adjust them in all ccbs belonging 
d6650 1
a6650 1
			ncr_setsync (np, cp, 0xe0);
d6654 1
a6654 1
			ncr_setwide (np, cp, 0);
d6697 2
a6698 2
		if (per < np->ns_sync)
			{chg = 1; per = np->ns_sync;}
d6707 3
d6711 2
a6712 2
			fak = (4ul * per - 1) / np->ns_sync - 3;
			if (fak>7) {
d6718 3
a6720 2
			fak = 7;
			per = 0;
d6726 2
a6727 2
			printf ("sync: per=%d ofs=%d fak=%d chg=%d.\n",
				per, ofs, fak, chg);
d6742 1
a6742 1
					ncr_setsync (np, cp, 0xe0);
d6748 1
a6748 1
					ncr_setsync (np, cp, (fak<<5)|ofs);
d6754 1
a6754 1
				ncr_setwide (np, cp, 0);
d6764 1
a6764 1
		ncr_setsync (np, cp, (fak<<5)|ofs);
d6839 1
a6839 1
					ncr_setwide (np, cp, 0);
d6845 1
a6845 1
					ncr_setwide (np, cp, wide);
d6851 1
a6851 1
				ncr_setsync (np, cp, 0xe0);
d6861 1
a6861 1
		ncr_setwide (np, cp, wide);
d6978 1
a6978 1
		np->script->start1[0] =  SCR_INT;
d7006 1
a7006 1
		cp = &np->ccb;
d7026 1
a7026 1
		np->script->start1[0] =  SCR_INT ^ IFFALSE (0);
d7049 1
d7072 1
a7072 1
	if (!cp) cp = &np->ccb;
d7113 1
a7113 1
	if (cp == &np->ccb)
d7147 2
a7148 1
		tp->getscr[0] = SCR_BO(SCR_COPY (1));
d7151 1
a7151 1
		tp->getscr[3] = SCR_BO(SCR_COPY (1));
d7164 1
a7164 1
		tp->jump_lcb.l_paddr = SCR_BO(NCB_SCRIPT_PHYS (np, abort));
d7167 2
a7168 1
		ncr_setmaxtags (tp, SCSI_NCR_DFLT_TAGS);
d7193 1
a7193 1
		lp->jump_ccb.l_paddr = SCR_BO(NCB_SCRIPT_PHYS (np, aborttag));
d7257 2
a7258 2
	cp->link_ccb      = np->ccb.link_ccb;
	np->ccb.link_ccb  = cp;
d7291 1
a7291 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d7296 1
a7296 1
#else /* !(__NetBSD__ || __OpenBSD__) */ 
d7301 1
a7301 1
#endif /* __NetBSD__ || __OpenBSD__ */      
a7314 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a7315 3
#else /* !(__NetBSD__ || __OpenBSD__) */ 
		xp->sc_link->opennings	+= diff;
#endif /* __NetBSD__ || __OpenBSD__ */      
d7354 1
a7354 1
	paddr = vtophys ((void *)vaddr);
d7369 1
a7369 1
	if (vaddr & (NBPG-1)) free -= datalen / NBPG;
d7398 1
a7398 1
			pnext = (paddr & (~(NBPG - 1))) + NBPG;
d7412 1
a7412 1
			paddr    = vtophys ((void *)vaddr);
d7447 1
a7447 1
#ifndef NCR_IOMAPPED
d7450 1
a7450 1
	register volatile u_long data;
d7474 10
a7483 5
	u_long	ncr_rd, ncr_wr, ncr_bk, host_rd, host_wr, pc, err=0;
	int	i;
#ifndef NCR_IOMAPPED
	err |= ncr_regtest (np);
	if (err) return (err);
d7488 1
a7488 1
	pc  = NCB_SCRIPT_PHYS (np, snooptest);
d7532 1
a7532 1
	if (pc != NCB_SCRIPT_PHYS (np, snoopend)+8) {
d7534 3
a7536 3
		printf ("\tstart=%08lx, pc=%08lx, end=%08lx\n", 
			NCB_SCRIPT_PHYS (np, snooptest), pc,
			NCB_SCRIPT_PHYS (np, snoopend) +8);
d7587 1
d7589 3
d7629 1
a7640 2
#ifndef NEW_SCSICONF

d7686 1
a7686 1
#endif
d7691 1
a7691 1
**	This is important for the negotiation
d7699 8
a7706 5
**	We assume that all NCR based boards are delivered
**	with a 40Mhz clock. Because we have to divide
**	by an integer value greater than 3, only clock
**	frequencies of 40Mhz (/4) or 50MHz (/5) permit
**	the FAST-SCSI rate of 10MHz.
d7711 27
a7737 3
#ifndef NCR_CLOCK
#	define NCR_CLOCK 40
#endif /* NCR_CLOCK */
d7747 1
a7747 1
	 * Measure GEN timer delay in order 
d7751 1
a7751 1
	 * many loop iterations (if DELAY is 
d7754 1
a7754 1
	 * if the CPU is slow executing the 
d7757 2
a7758 2
	 * if multiple measurements are to be 
	 * performed trust the higher delay 
d7780 1
a7780 1
	if (bootverbose)
d7783 1
a7783 1
	 * adjust for prescaler, and convert into KHz 
d7788 1
a7788 1
static void ncr_getclock (ncb_p np)
d7794 2
a7795 1
	  
d7798 2
a7799 2
		OUTB(nc_stest1, 0);
		scntl3 = 3;
d7808 1
a7808 1
			if (bootverbose)
d7817 2
a7818 7
	}

	np->rv_scntl3 = ((scntl3 & 0x7) << 4) -0x20 + (scntl3 & 0x7);

	if (bootverbose) {
		printf ("\tinitial value of SCNTL3 = %02x, final = %02x\n",
			scntl3, np->rv_scntl3);
d7841 1
a7841 1
  struct tekram_eeprom_dev 
d7905 1
a7905 1
static int 
@


1.30
log
@From NetBSD:
    Add QUIRK_NOTAGS quirk type and quirk for HP C372.
    Print quirks (other than QUIRK_NOMSG) for a device when it is config'd.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.29 1997/04/30 16:26:34 millert Exp $	*/
d19 3
d224 1
a224 1
#ifndef __alpha__
d1363 1
a1363 1
	"\n$OpenBSD: ncr.c,v 1.29 1997/04/30 16:26:34 millert Exp $\n";
d3139 2
a3140 1
		*dst++ = opcode = *src++;
d3246 1
a3246 1
				*dst++ = new;
d3248 5
a3252 3
		} else
			*dst++ = *src++;

d3606 2
a3607 2
	np->jump_tcb.l_cmd	= SCR_JUMP;
	np->jump_tcb.l_paddr	= NCB_SCRIPT_PHYS (np, abort);
d3627 1
a3627 1
			printf (" %08x", (int)pci_conf_read (config_id, reg));
d4137 4
a4140 2
		cp->phys.header.savep = NCB_SCRIPT_PHYS (np, data_in);
		cp->phys.header.goalp = cp->phys.header.savep +20 +segments*16;
d4142 4
a4145 2
		cp->phys.header.savep = NCB_SCRIPT_PHYS (np, data_out);
		cp->phys.header.goalp = cp->phys.header.savep +20 +segments*16;
d4147 1
a4147 1
		cp->phys.header.savep = NCB_SCRIPT_PHYS (np, no_data);
d4167 2
a4168 2
	cp->phys.header.launch.l_paddr	= NCB_SCRIPT_PHYS (np, select);
	cp->phys.header.launch.l_cmd	= SCR_JUMP;
d4178 2
a4179 2
	cp->phys.smsg.addr		= CCB_PHYS (cp, scsi_smsg);
	cp->phys.smsg.size		= msglen;
d4181 2
a4182 2
	cp->phys.smsg2.addr		= CCB_PHYS (cp, scsi_smsg2);
	cp->phys.smsg2.size		= msglen2;
d4186 2
a4187 2
	cp->phys.cmd.addr		= vtophys (cmd);
	cp->phys.cmd.size		= xp->cmdlen;
d4191 2
a4192 2
	cp->phys.scmd.addr		= CCB_PHYS (cp, sensecmd);
	cp->phys.scmd.size		= 6;
d4204 2
a4205 2
	cp->phys.sense.addr		= vtophys (&cp->xfer->sense);
	cp->phys.sense.size		= sizeof(struct scsi_sense_data);
d4230 1
a4230 1
	cp->jump_ccb.l_cmd	= (SCR_JUMP ^ IFFALSE (DATA (cp->tag)));
d4240 2
a4241 2
	np->squeue [qidx	 ] = NCB_SCRIPT_PHYS (np, idle);
	np->squeue [np->squeueput] = CCB_PHYS (cp, phys);
d4247 2
a4248 2
		(unsigned)(np->script->startpos[0]- 
			   (NCB_SCRIPT_PHYS (np, tryloop))));
d4359 1
a4359 1
	cp->jump_ccb.l_cmd = (SCR_JUMP);
d4364 1
a4364 1
	cp->phys.header.launch.l_paddr= NCB_SCRIPT_PHYS (np, idle);
d4372 1
a4372 1
		printf ("CCB=%lx STAT=%x/%x\n", (unsigned long)cp & 0xfff,
d4666 1
a4666 1
		np -> squeue [i] = NCB_SCRIPT_PHYS (np, idle);
d4673 2
a4674 2
	np->script->startpos[0] = NCB_SCRIPT_PHYS (np, tryloop);
	np->script->start0  [0] = SCR_INT ^ IFFALSE (0);
d5143 1
a5143 1
			cp->jump_ccb.l_cmd = (SCR_JUMP);
d5145 1
a5145 1
				NCB_SCRIPT_PHYS (np, select)) {
d5149 1
a5149 1
				= NCB_SCRIPT_PHYS (np, skip);
d5160 1
a5160 1
					NCB_SCRIPT_PHYS (np, skip))
d5577 1
a5577 1
		np->script->startpos[0] = scratcha;
d5666 1
a5666 1
		nxtdsp = vdsp[3];
d5669 1
a5669 1
		nxtdsp = vdsp[3];
d5693 1
a5693 1
	oadr = vdsp[1];
d5697 2
a5698 2
		olen = tblp[0];
		oadr = tblp[1];
d5701 1
a5701 1
		olen = vdsp[0] & 0xffffff;
d5706 1
a5706 1
			(unsigned) (vdsp[0] >> 24),
d5716 1
a5716 1
	if (cmd != (vdsp[0] >> 24)) {
d5719 1
a5719 1
			(unsigned)cmd, (unsigned)vdsp[0] >> 24);
d5739 1
a5739 1
	if (cp->phys.header.savep == vtophys (newcmd)) newcmd+=4;
d5745 4
a5748 4
	newcmd[0] = ((cmd & 0x0f) << 24) | rest;
	newcmd[1] = oadr + olen - rest;
	newcmd[2] = SCR_JUMP;
	newcmd[3] = nxtdsp;
d6288 2
a6289 2
			(unsigned) np->header.savep,
			(unsigned) np->header.goalp);
a6389 1

d6484 1
a6484 1
		tp->jump_tcb.l_cmd   = (SCR_JUMP^IFFALSE (DATA (0x80 + target)));
d6487 6
a6492 6
		tp->getscr[0] = SCR_COPY (1);
		tp->getscr[1] = vtophys (&tp->sval);
		tp->getscr[2] = np->paddr + offsetof (struct ncr_reg, nc_sxfer);
		tp->getscr[3] = SCR_COPY (1);
		tp->getscr[4] = vtophys (&tp->wval);
		tp->getscr[5] = np->paddr + offsetof (struct ncr_reg, nc_scntl3);
d6499 2
a6500 2
		tp->call_lun.l_cmd   = (SCR_CALL);
		tp->call_lun.l_paddr = NCB_SCRIPT_PHYS (np, resel_lun);
d6502 3
a6504 3
		tp->jump_lcb.l_cmd   = (SCR_JUMP);
		tp->jump_lcb.l_paddr = NCB_SCRIPT_PHYS (np, abort);
		np->jump_tcb.l_paddr = vtophys (&tp->jump_tcb);
d6524 1
a6524 1
		lp->jump_lcb.l_cmd   = (SCR_JUMP ^ IFFALSE (DATA (lun)));
d6527 2
a6528 2
		lp->call_tag.l_cmd   = (SCR_CALL);
		lp->call_tag.l_paddr = NCB_SCRIPT_PHYS (np, resel_tag);
d6530 2
a6531 2
		lp->jump_ccb.l_cmd   = (SCR_JUMP);
		lp->jump_ccb.l_paddr = NCB_SCRIPT_PHYS (np, aborttag);
d6538 1
a6538 1
		tp->jump_lcb.l_paddr = vtophys (&lp->jump_lcb);
d6586 1
a6586 1
	cp->jump_ccb.l_cmd   = SCR_JUMP;
d6588 3
a6590 3
	lp->jump_ccb.l_paddr = CCB_PHYS (cp, jump_ccb);
	cp->call_tmp.l_cmd   = SCR_CALL;
	cp->call_tmp.l_paddr = NCB_SCRIPT_PHYS (np, resel_tmp);
d6696 1
a6696 1
	paddr = vtophys (vaddr);
d6754 1
a6754 1
			paddr    = vtophys (vaddr);
d6764 2
a6765 2
		phys->data[segment].addr = segaddr;
		phys->data[segment].size = segsize;
d6832 1
a6832 1
	OUTL (nc_temp, ncr_wr);
d6851 2
a6852 2
	ncr_rd  = INL (nc_scratcha);
	ncr_bk  = INL (nc_temp);
@


1.29
log
@Change an splhigh() -> splbio().  From NetBSD (mycroft)
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.28 1997/04/10 16:51:38 pefo Exp $	*/
d457 1
d1360 1
a1360 1
	"\n$OpenBSD: ncr.c,v 1.28 1997/04/10 16:51:38 pefo Exp $\n";
d3957 1
a3957 2
#ifndef NCR_GETCC_WITHMSG
		if (tp->quirks) {
a3960 1
#endif
d4909 2
a4910 4
	if (scntl3 & EWS)
		printf ("WIDE SCSI (16 bit) enabled.\n");
	else
		printf ("WIDE SCSI disabled.\n");
d4962 3
d6976 1
@


1.28
log
@These two was not ready for commit yet. Backed out.
@
text
@d1 2
a2 2
/*	$OpenBSD: ncr.c,v 1.26 1997/03/03 00:25:03 millert Exp $	*/
/*	$NetBSD: ncr.c,v 1.55 1997/01/10 05:57:10 perry Exp $	*/
d1359 1
a1359 1
	"\n$OpenBSD: ncr.c,v 1.26 1997/03/03 00:25:03 millert Exp $\n";
d6381 1
a6381 1
	oldspl = splhigh();
@


1.27
log
@Add Matrox Mystique
@
text
@a93 1
#define SCSI_NCR_MAX_SYNC 0
d221 1
a221 1
#if !defined __alpha__ && !defined __mips__
a3122 4
#if defined(__mips__)
	R4K_HitFlushDCache(np->script, sizeof (struct script));
	np->script = (struct script *)PHYS_TO_UNCACHED(vtophys(np->script));
#endif /* __mips__ */
a3398 5
#if defined(__mips__)
	R4K_HitFlushDCache(np, sizeof (struct ncb));
	np = (struct ncb *)PHYS_TO_UNCACHED(vtophys(np));
#endif /* __mips__ */

a3535 3
#if defined(__mips__)
	np->rv_scntl3 = 0x24;	/* default: 67MHz clock */
#else
a3536 1
#endif
a3542 3
#if defined(__mips__)
	np->ns_sync   = 22;	/* in units of 4ns */
#else
a3543 1
#endif
d3583 1
a3918 8
#if defined(__mips__)
	if (xp->data && xp->datalen) {
		R4K_HitFlushDCache(xp->data, xp->datalen);
	}
	R4K_HitFlushDCache(xp->cmd, xp->cmdlen);
	R4K_HitFlushDCache(&xp->sense, sizeof(struct scsi_sense_data));
#endif /* __mips__ */

d4687 1
a4687 1
	OUTB (nc_dmode , 0x80 /*np->rv_dmode*/);/* XXX modify burstlen ??? */
a4691 3
#if defined(__mips__)
	OUTB (nc_stest1, 0x80   );	/*  Disable external SCSI clock      */
#endif
a4715 6

		/* Don't negotiate a period that we cant't handle !!! */
		if(period % np->ns_sync) {
			period = ((period / np->ns_sync) + 1) * np->ns_sync;
		}

a6510 4
#if defined(__mips__)
		R4K_HitFlushDCache(lp, sizeof (struct lcb));
		lp = (struct lcb *)PHYS_TO_UNCACHED(vtophys(lp));
#endif /* __mips__ */
d6549 1
a6552 5
#if defined(__mips__)
	R4K_HitFlushDCache(cp, sizeof (struct ccb));
	cp = (struct ccb *)PHYS_TO_UNCACHED(vtophys(cp));
#endif /* __mips__ */

a6822 3
#if defined(__mips__)
	R4K_HitFlushDCache(&ncr_cache, sizeof (ncr_cache));
#endif /* __mips__ */
@


1.26
log
@Sync with NetBSD which is syncing with FreeBSD, whee!
OpenBSD-specific changes are surrounded by #ifdef __OpenBSD__
or #ifndef __OpenBSD__
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.25 1997/01/22 21:46:51 deraadt Exp $	*/
d94 1
d222 1
a222 1
#ifndef __alpha__
d1360 1
a1360 1
	"\n$OpenBSD: ncr.c,v 1.55 1997/01/10 05:57:10 perry Exp $\n";
d3124 4
d3404 5
d3546 3
d3550 1
d3557 3
d3561 1
a3600 1
		ncr_getclock(np);
d3936 8
d4712 1
a4712 1
	OUTB (nc_dmode , np->rv_dmode);	/* XXX modify burstlen ??? */
d4717 3
d4744 6
d6545 4
a6586 1

d6590 5
d6865 3
@


1.25
log
@only go into wide scsi mode if the card supports it
@
text
@d1 2
a2 2
/*	$OpenBSD: ncr.c,v 1.24 1997/01/17 05:32:08 kstailey Exp $	*/
/*	$NetBSD: ncr.c,v 1.48 1996/10/25 21:33:33 cgd Exp $	*/
d8 1
a8 1
**  FreeBSD / NetBSD
a17 1
**	Dave Huang		<khym@@bga.com>
d48 1
a48 1
#define NCR_DATE "pl23 95/09/07"
d55 10
a64 1
#ifdef	FAILSAFE
d66 3
a68 3
#define	MAX_LUN		(1)
#define	CDROM_ASYNC
#endif	/* FAILSAFE */
d135 2
d139 1
d141 1
d224 1
a224 1
#endif /* __NetBSD__ */
d261 1
a261 1
#ifdef SCSI_DEBUG_FLAGS
d263 2
a264 2
#else /* SCSI_DEBUG_FLAGS */
	#define SCSI_DEBUG_FLAGS	0
d266 1
a266 1
#endif /* SCSI_DEBUG_FLAGS */
d346 1
a346 1
#else /* !__NetBSD__ */
d369 3
a371 3
#define	OUTB(r, val) np->reg->r = val
#define	OUTW(r, val) np->reg->r = val
#define	OUTL(r, val) np->reg->r = val
d376 1
a376 1
#endif /* __NetBSD__ */
d1021 1
a1021 1
#else /* !__NetBSD__ */
d1023 1
a1023 1
#endif /* __NetBSD__ */
a1078 1
	u_char		ns_async;
d1080 5
d1086 4
d1302 1
a1302 1
#endif	/* !__NetBSD__ */
d1320 1
a1320 1
static	int	ncr_scatter	(ncb_p np, struct dsb* phys, vm_offset_t vaddr,
d1334 1
d1336 3
d1340 1
a1340 1
#else /* !__NetBSD__ */
d1343 1
a1343 1
#endif /* __NetBSD__ */
d1359 1
a1359 1
	"\n$NetBSD: ncr.c,v 1.48 1996/10/25 21:33:33 cgd Exp $\n";
d1372 2
a1373 2
ncb_p		ncrp [MAX_UNITS];	/* XXX to be replaced by SYSCTL */
#endif /* !__NetBSD__ */
d1375 2
a1376 2
static int ncr_debug = SCSI_DEBUG_FLAGS;
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
d1378 1
a1378 1
#endif /* !__NetBSD__ */
a1391 1
#define	NCR_810AP_ID	(0x00051000ul)
d1407 1
a1407 1
#else /* !__NetBSD__ */
d1421 1
a1421 1
#endif /* !__NetBSD__ */
d1436 1
a1436 1
#endif /* !__NetBSD__ */
d1447 1
a1447 1
#endif /* !__NetBSD__ */
d1454 1
a1454 1
#else /* !__NetBSD__ */
d3118 1
a3118 1
	np->script = (struct script*) vm_page_alloc_contig
d3120 1
a3120 1
#else  /* !__NetBSD___ */
d3123 1
a3123 1
#endif /* __NetBSD__ */
d3145 2
a3146 2
			printf ("%s: ERROR0 IN SCRIPT at %d.\n",
				ncr_name(np), src-start-1);
d3170 2
a3171 2
				printf ("%s: ERROR1 IN SCRIPT at %d.\n",
					ncr_name(np), src-start-1);
d3313 6
a3318 1
	void *match, *aux;
a3327 1
	    pa->pa_id != NCR_810AP_ID &&
d3337 1
a3337 1
#else /* !__NetBSD__ */
d3342 1
d3346 3
a3348 4
		return ("ncr 53c810 scsi");

	case NCR_810AP_ID:
		return ("ncr 53c810ap scsi");
d3354 3
a3356 1
		return ("ncr 53c825 wide scsi");
d3367 1
a3367 1
#endif /* !__NetBSD__ */
a3382 1

d3397 1
d3402 1
a3402 4
		printf("53c810");
		break;
	case NCR_810AP_ID:
		printf("53c810ap");
d3408 1
a3408 1
		printf("53c825 Wide");
d3454 4
d3460 1
d3471 1
a3471 1
#else /* !__NetBSD__ */
d3526 11
a3536 1
#endif /* !__NetBSD__ */
d3542 3
a3544 4
	np->maxwide = 0;
	np->rv_scntl3 = 0x13;	/* default: 40MHz clock */
	np->ns_sync   = 25;	/* XXX no support for Fast-20, yet */
	np->ns_async  = 50;
d3553 1
a3553 1
#else /* !__NetBSD__ */
d3555 1
a3555 1
#endif /* __NetBSD__ */
d3557 6
d3565 1
d3568 1
d3572 11
a3608 8
	/*
	**	Reset chip.
	*/

	OUTB (nc_istat,  SRST);
	DELAY (1000);
	OUTB (nc_istat,  0   );

d3617 1
a3617 1
#endif /* __NetBSD__ */
d3624 1
d3627 1
a3627 1
	**	Reset chip, once again.
a3633 1
#endif /* NCR_DUMP_REG */
d3651 1
a3651 1
#endif /* __NetBSD__ */
d3681 1
d3685 2
a3686 2
#endif
#else /* !__NetBSD__ */
d3691 1
a3691 1
#endif /* !__NetBSD__ */
d3698 1
a3698 1
#else
d3729 1
a3729 1
#endif /* !__NetBSD__ */
d3760 1
a3760 1
#else /* !__NetBSD__ */
d3762 1
a3762 1
#endif /* __NetBSD__ */
d3885 3
a3887 2
		printf ("CMD=%x F=%p A=%p L=%p ", 
			cmd->opcode, xp->flags, xp->data, xp->datalen);
d3991 1
a3991 1
#if defined (CDROM_ASYNC) || defined (GENERIC)
d3993 1
a3993 1
#endif
d4114 1
a4114 1
	segments = ncr_scatter (np, &cp->phys, (vm_offset_t) xp->data,
d4259 1
a4259 1
#else /* !__NetBSD__ */ 
d4261 1
a4261 1
#endif /* __NetBSD__ */
d4312 1
a4312 1
#else /* !__NetBSD__ */ 
d4314 1
a4314 1
#endif /* __NetBSD__ */
d4363 1
a4363 2
		printf ("CCB=%p STAT=%x/%x\n",
			(caddr_t)((vm_offset_t)cp & 0xfff),
d4381 1
a4381 1
		tp->usrsync=255;
d4402 1
a4402 1
		if (cp->host_status==HS_COMPLETE)
d4416 1
a4416 1
#endif /* __NetBSD__ */
d4444 1
a4444 1
		if (xp->cmd->opcode == 0x12) {
d4483 1
a4483 1
#endif /* !__NetBSD__ */
d4677 2
a4678 8
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
	if (pci_max_burst_len < 4) {
		static u_char tbl[4]={0,0,0x40,0x80};
		burstlen = tbl[pci_max_burst_len];
	} else burstlen = 0xc0;
#else /* !__NetBSD__ */
	burstlen = 0xc0;
#endif /* __NetBSD__ */
d4680 1
a4680 1
	OUTB (nc_istat,  0      );      /*  Remove Reset, abort ...	     */
d4687 5
a4691 3
	OUTB (nc_dmode , burstlen);	/*  Burst length = 2 .. 16 transfers */
	OUTB (nc_dcntl , NOCOM  );      /*  no single step mode, protect SFBR*/
	OUTB (nc_ctest4, 0x08	);	/*  enable master parity checking    */
d4696 11
a4783 2
	if (minsync < 25) minsync=25;

d4807 1
a4807 1
	tp->maxoffs = (minsync<255 ? 8 : 0);
d4843 1
a4843 1
	tp->period= sxfer&0xf ? ((sxfer>>5)+4) * np->ns_sync : 0xffff;
d4852 3
a4854 1
	if (sxfer & 0x0f) {
d4859 2
a4860 4
		printf ("%s%dns (%d Mb/sec) offset %d.\n",
			tp->period<200 ? "FAST SCSI-2 ":"",
			tp->period, (1000+tp->period/2)/tp->period,
			sxfer & 0x0f);
d5109 1
a5109 1
			**      Let's wake it up.
a5113 19
#ifdef undef
		if (np->latetime>4) {
			/*
			**	Although we tried to wake it up,
			**	the script processor didn't respond.
			**
			**	May be a target is hanging,
			**	or another initator lets a tape device
			**	rewind with disconnect disabled :-(
			**
			**	We won't accept that.
			*/
			if (INB (nc_sbcl) & CBSY)
				OUTB (nc_scntl1, CRST);
			DELAY (1000);
			ncr_init (np, "ncr dead ?", HS_TIMEOUT);
			np->heartbeat = thistime;
		};
#endif
d5217 1
a5218 1
	sist  = (istat & SIP) ? INW (nc_sist)  : 0;
d5379 2
a5380 1
		OUTB (nc_ctest3, CLF);		/* clear dma fifo  */
d5428 1
a5428 1
			OUTB (nc_dcntl, (STD|NOCOM));
d5453 1
a5453 1
		OUTB (nc_dcntl, (STD|NOCOM));
d5466 2
a5467 1
		OUTB (nc_ctest3, CLF);		/* clear scsi offsets */
d5627 2
a5628 2
	OUTB (nc_ctest3, CLF   );	/* clear dma fifo  */
	OUTB (nc_stest3, TE|CSF);	/* clear scsi fifo */
d5719 1
a5719 1
		OUTB (nc_dcntl, (STD|NOCOM));
d5742 2
a5743 2
		printf ("newcmd[%d] %x %x %x %x.\n",
			newcmd - cp->patch,
d6362 1
a6362 1
	OUTB (nc_dcntl, (STD|NOCOM));
d6379 1
d6381 1
d6394 3
a6396 1
		while (cp && cp->magic) cp = cp->next_ccb;
d6415 2
a6416 1
	if (cp->magic)
d6418 1
d6421 1
d6625 1
a6625 1
#else /* !__NetBSD__ */
d6630 1
a6630 1
#endif /* __NetBSD__ */
d6646 1
a6646 1
#else /* !__NetBSD__ */
d6648 1
a6648 1
#endif /* __NetBSD__ */
d6674 1
a6674 1
	(ncb_p np, struct dsb* phys, vm_offset_t vaddr, vm_size_t datalen)
d6862 3
d7047 184
a7230 74
 	 * This code will never execute too
 	 * many loop iterations (if DELAY is 
 	 * reasonably correct). It could get
 	 * too low a delay (too high a freq.)
 	 * if the CPU is slow executing the 
 	 * loop for some reason (an NMI, for
 	 * example). For this reason we will
 	 * if multiple measurements are to be 
 	 * performed trust the higher delay 
 	 * (lower frequency returned).
 	 */
 	OUTB (nc_stest1, 0);	/* make sure clock doubler is OFF	    */
 	OUTW (nc_sien , 0);	/* mask all scsi interrupts		    */
 	(void) INW (nc_sist);	/* clear pending scsi interrupt		    */
 	OUTB (nc_dien , 0);	/* mask all dma interrupts		    */
 	(void) INW (nc_sist);	/* another one, just to be sure :)	    */
 	OUTB (nc_scntl3, 4);	/* set pre-scaler to divide by 3	    */
 	OUTB (nc_stime1, 0);	/* disable general purpose timer	    */
 	OUTB (nc_stime1, gen);	/* set to nominal delay of (1<<gen) * 125us */
 	while (!(INW(nc_sist) & GEN) && ms++ < 1000)
 		DELAY(1000);	/* count ms				    */
 	OUTB (nc_stime1, 0);	/* disable general purpose timer	    */
 	OUTB (nc_scntl3, 0);
 	/*
 	 * Set prescaler to divide by whatever "0" means.
 	 * "0" ought to choose divide by 2, but appears
 	 * to set divide by 3.5 mode in my 53c810 ...
 	 */
 	OUTB (nc_scntl3, 0);
 
 	if (bootverbose)
 	  	printf ("\tDelay (GEN=%d): %u msec\n", gen, ms);
 	/*
 	 * adjust for prescaler, and convert into KHz 
 	 */
 	return ms ? ((1 << gen) * 4440) / ms : 0;
 }
 
 static void ncr_getclock (ncb_p np)
 {
 	unsigned char scntl3;
 	unsigned char stest1;
 	scntl3 = INB(nc_scntl3);
 	stest1 = INB(nc_stest1);
 	  
 	/* always false, except for 875 with clock doubler selected */
 	if ((stest1 & (DBLEN+DBLSEL)) == DBLEN+DBLSEL) {
 		OUTB(nc_stest1, 0);
 		scntl3 = 3;
 	} else {
 		if ((scntl3 & 7) == 0) {
 			unsigned f1, f2;
 			/* throw away first result */
 			(void) ncrgetfreq (np, 11);
 			f1 = ncrgetfreq (np, 11);
 			f2 = ncrgetfreq (np, 11);
 
 			if (bootverbose)
 			  printf ("\tNCR clock is %uKHz, %uKHz\n", f1, f2);
 			if (f1 > f2) f1 = f2;	/* trust lower result	*/
 			if (f1 > 45000) {
 				scntl3 = 5;	/* >45Mhz: assume 80MHz	*/
 			} else {
 				scntl3 = 3;	/* <45Mhz: assume 40MHz	*/
 			}
 		}
 	}
 
 	np->rv_scntl3 = ((scntl3 & 0x7) << 4) -0x20 + (scntl3 & 0x7);
 
 	if (bootverbose) {
 		printf ("\tinitial value of SCNTL3 = %02x, final = %02x\n",
 			scntl3, np->rv_scntl3);
 	}
d7232 1
@


1.24
log
@ncr_print() -> scsiprint()
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.23 1997/01/15 05:50:44 deraadt Exp $	*/
a3626 1
	np->sc_link.adapter_buswidth = MAX_TARGET;
d3630 3
@


1.23
log
@sc_link.adapter_buswidth, set to 16 if wide scsi. if 0 it gets converted
to 8 internally so that drivers do not need to init it for regular scsi :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.22 1996/11/30 23:04:38 downsj Exp $	*/
a3352 16
#if defined(__OpenBSD__)

int ncr_print __P((void *, const char *));

int
ncr_print(aux, name)
	void *aux;
	const char *name;
{

	if (name != NULL)
		printf("%s: scsibus ", name);
	return UNCONF;
}

#endif
d3642 1
a3642 3
#if defined(__OpenBSD__)
	config_found(self, &np->sc_link, ncr_print);
#elif defined(__NetBSD__)
d3644 1
a3644 1
#else /* !__NetBSD__ */
@


1.22
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.21 1996/11/30 21:54:53 millert Exp $	*/
d3643 1
@


1.21
log
@fix order of #if defined's so it compiles
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.20 1996/11/28 23:28:08 niklas Exp $	*/
d3519 2
a3520 2
	np->ns_sync = 25;
	np->ns_async = 50;
d5194 2
a5195 2
	dstat = INB (nc_dstat);
	sist  = INW (nc_sist) ;
a7079 2
 	np->ns_sync   = 25;
 	np->ns_async  = 50;
@


1.20
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.19 1996/11/23 21:47:04 kstailey Exp $	*/
d3657 3
a3659 1
#if defined(__NetBSD__)
a3660 2
#elif defined(__OpenBSD__)
	config_found(self, &np->sc_link, ncr_print);
@


1.19
log
@added const to second parameter of cfprint_t routines
@
text
@d1 2
a2 2
/*	$OpenBSD: ncr.c,v 1.18 1996/11/12 20:30:57 niklas Exp $	*/
/*	$NetBSD: ncr.c,v 1.35.4.1 1996/06/03 20:32:17 cgd Exp $	*/
d169 2
a171 3
/*
 * Normally found in the userland header stddef.h, which isn't available.
 */
a172 4
#endif
#else
#include <stddef.h>
#endif
d204 1
a204 1
#include <machine/bus.old.h>
d219 2
a220 1
#define	vtophys(va)	__alpha_bus_XXX_dmamap(np->sc_bc, (void *)(va))
d269 1
d293 1
a293 1
    bus_io_read_1 (np->sc_bc, np->sc_ioh, (o))
d295 1
a295 1
    bus_io_read_2 (np->sc_bc, np->sc_ioh, offsetof(struct ncr_reg, r))
d299 1
a299 1
    bus_io_read_4 (np->sc_bc, np->sc_ioh, (o))
d302 1
a302 1
    bus_io_write_1 (np->sc_bc, np->sc_ioh, offsetof(struct ncr_reg, r), (val))
d304 1
a304 1
    bus_io_write_2 (np->sc_bc, np->sc_ioh, offsetof(struct ncr_reg, r), (val))
d308 1
a308 1
    bus_io_write_4 (np->sc_bc, np->sc_ioh, (o), (val))
d315 1
a315 1
    bus_mem_read_1 (np->sc_bc, np->sc_memh, (o))
d317 1
a317 1
    bus_mem_read_2 (np->sc_bc, np->sc_memh, offsetof(struct ncr_reg, r))
d321 1
a321 1
    bus_mem_read_4 (np->sc_bc, np->sc_memh, (o))
d324 1
a324 1
    bus_mem_write_1 (np->sc_bc, np->sc_memh, offsetof(struct ncr_reg, r), (val))
d326 1
a326 1
    bus_mem_write_2 (np->sc_bc, np->sc_memh, offsetof(struct ncr_reg, r), (val))
d330 1
a330 1
    bus_mem_write_4 (np->sc_bc, np->sc_memh, (o), (val))
d1006 1
a1006 1
	bus_chipset_tag_t sc_bc;
d1008 1
a1008 5
#ifdef NCR_IOMAPPED
	bus_io_handle_t sc_ioh;
#else /* !NCR_IOMAPPED */
	bus_mem_handle_t sc_memh;
#endif /* NCR_IOMAPPED */
d1038 1
a1038 1
	bus_mem_addr_t	paddr;
d1335 1
a1335 1
	"\n$NetBSD: ncr.c,v 1.35.4.1 1996/06/03 20:32:17 cgd Exp $\n";
d1483 5
a1487 2
static void *script_kvars[] =
	{ (void *)&mono_time.tv_sec, (void *)&mono_time, (void *)&ncr_cache };
d3203 1
a3203 1
					new = vtophys(script_kvars[old &
d3353 1
a3353 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d3368 3
d3377 1
a3377 1
	bus_chipset_tag_t bc = pa->pa_bc;
d3379 1
a3379 1
	bus_mem_size_t memsize;
d3384 1
d3399 1
d3406 1
d3411 1
a3411 1
	np->sc_bc = bc;
d3427 2
a3428 1
	retval = bus_mem_map(pa->pa_bc, np->paddr, memsize, 0, &np->sc_memh);
d3644 3
d3657 3
a3659 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
@


1.18
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.17 1996/10/31 01:05:12 niklas Exp $	*/
d3359 1
a3359 1
int ncr_print __P((void *, char *));
d3364 1
a3364 1
	char *name;
@


1.17
log
@-Wall fixes needed by alpha
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.15 1996/10/13 20:36:14 downsj Exp $	*/
d209 1
a209 1
#include <machine/bus.h>
@


1.16
log
@-Wall happiness + feed np into ncr_scatter so vtophys will work on alpha
@
text
@d169 5
d175 2
a177 1
#include <stddef.h>
@


1.15
log
@Updated driver to match FreeBSD, from Dave Huang <khym@@bga.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.14 1996/10/12 01:08:13 downsj Exp $	*/
d1301 1
a1301 1
static	int	ncr_scatter	(struct dsb* phys, vm_offset_t vaddr,
d3834 2
a3835 3
		printf ("CMD=%x F=%x A=%x L=%x ", 
			cmd->opcode, (unsigned)xp->flags, 
			(unsigned) xp->data, (unsigned) xp->datalen);
d4062 1
a4062 1
	segments = ncr_scatter (&cp->phys, (vm_offset_t) xp->data,
d4311 2
a4312 1
		printf ("CCB=%x STAT=%x/%x\n", (unsigned)cp & 0xfff,
d6628 1
a6628 1
	(struct dsb* phys, vm_offset_t vaddr, vm_size_t datalen)
@


1.14
log
@Support LUNs.  My God...
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.13 1996/09/05 23:14:00 dm Exp $	*/
d18 1
d56 6
d104 3
a106 3
#ifndef SCSI_NCR_MAX_TAGS
#define SCSI_NCR_MAX_TAGS    (4)
#endif /* SCSI_NCR_MAX_TAGS */
d138 1
a138 1
#define MAX_START   (MAX_TARGET + 7 * SCSI_NCR_MAX_TAGS)
d183 3
d187 1
a188 3
#include <machine/cpu.h> /* bootverbose */
#else
#define bootverbose	1
d191 2
a197 1
#include <sys/devconf.h>
a200 1
extern PRINT_ADDR();
a214 3
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
#include <machine/clock.h>
#endif /* __NetBSD__ */
d1205 1
a1205 1
	ncrcmd	select		[ 24];
d1270 1
a1270 1
static	void	ncr_alloc_ccb	(ncb_p np, struct scsi_xfer * xp);
d1275 1
a1275 1
static	void	ncr_getclock	(ncb_p np, u_char scntl3);
d1279 3
a1281 3
static	int     ncr_intr        (void *);
#else	/* !__NetBSD__ */
static	int	ncr_intr	(ncb_p np);
d1283 1
a1283 1
#endif	/* __NetBSD__ */	
d1301 2
a1302 2
static	int	ncr_scatter	(ncb_p np, struct dsb* phys,u_long vaddr,
				    u_long datalen);
d1317 1
a1317 1
#else /* !__NetBSD */
d1339 1
a1339 1
u_long	ncr_version = NCR_VERSION	* 11
d1348 2
a1349 2
u_long		nncr=MAX_UNITS;
ncb_p		ncrp [MAX_UNITS];
d1353 3
d1357 1
a1357 1
int ncr_cache; /* to be aligned _NOT_ static */
d1389 1
a1389 1
struct	pci_device ncr_device = {
d1401 1
a1401 1
struct scsi_adapter ncr_switch =
d1417 1
a1417 1
struct scsi_device ncr_dev =
d1687 1
d1690 1
d2759 1
a2759 1
	SCR_REG_SFBR (ssid, SCR_AND, 0x87),
d3485 8
d3508 10
d3524 5
d3531 1
a3531 3
		break;
	default:
		np->maxwide = 0;
a3549 10
#if !(defined(__NetBSD__)  || defined(__OpenBSD__))
	/*
	**	Make the controller's registers available.
	**	Now the INB INW INL OUTB OUTW OUTL macros
	**	can be used safely.
	*/

	np->reg = (struct ncr_reg*) np->vaddr;
#endif

a3557 7
	**	Get the value of the chip's clock.
	**	Find the right value for scntl3.
	*/

	ncr_getclock (np, INB(nc_scntl3));

	/*
d3637 1
d3687 5
d3708 1
a3708 5
int
ncr_intr(arg)
        void *arg;
{               
        ncb_p np = arg;
d3710 4
a3713 3
int
ncr_intr(np)
	ncb_p np;
d3715 1
a3715 1
#endif /* __NetBSD__ */
d3717 2
d3731 3
a3733 1
		n=1;
d3740 1
d3742 1
d3757 1
a3757 5
#if defined(__NetBSD__) || defined(__OpenBSD__)
	ncb_p np  = xp->sc_link->adapter_softc;
#else /*__NetBSD__*/
	ncb_p np  = ncrp[xp->sc_link->adapter_unit];
#endif/*__NetBSD__*/
d3765 1
a3765 1
	u_char	ptr, nego, idmsg;
a3767 2


d3818 14
d3834 3
a3836 2
		printf ("CMD=%x F=%x L=%x ", cmd->opcode,
			(unsigned)xp->flags, (unsigned) xp->datalen);
d3924 11
d3938 1
a3938 1
		if (!tp->period) {
a3951 11

		/*
		**	negotiate wide transfers ?
		*/

		if (!tp->widedone) {
			if (tp->inqdata[7] & INQ7_WIDE16) {
				if (!nego) nego = NS_WIDE;
			} else
				tp->widedone=1;
		};
a3988 10
#ifndef NCR_NO_DISCONNECT
	/*---------------------------------------------------------------------
	** Some users have problems with this driver.
	** I assume that the current problems relate to a conflict between
	** a disconnect and an immediately following reconnect operation.
	** With this option one can prevent the driver from using disconnects.
	** Without disconnects the performance will be severely degraded.
	** But it may help to trace down the core problem.
	**---------------------------------------------------------------------
	*/
a3990 1
#endif
d3992 3
a3994 2
	cp -> scsi_smsg [0] = idmsg;
	msglen=1;
d3997 1
d3999 2
d4008 2
a4009 2
			cp -> scsi_smsg [msglen] = M_SIMPLE_TAG;
			break;
d4011 1
a4011 1
			cp -> scsi_smsg [msglen] = M_ORDERED_TAG;
d4013 3
a4015 11

		/*
		**	can be overwritten by ncrcontrol
		*/
		switch (np->order) {
		case M_SIMPLE_TAG:
		case M_ORDERED_TAG:
			cp -> scsi_smsg [msglen] = np->order;
		};
		msglen++;
		cp -> scsi_smsg [msglen++] = cp -> tag;
d4020 5
a4024 5
		cp -> scsi_smsg [msglen++] = M_EXTENDED;
		cp -> scsi_smsg [msglen++] = 3;
		cp -> scsi_smsg [msglen++] = M_X_SYNC_REQ;
		cp -> scsi_smsg [msglen++] = tp->minsync;
		cp -> scsi_smsg [msglen++] = tp->maxoffs;
d4033 4
a4036 4
		cp -> scsi_smsg [msglen++] = M_EXTENDED;
		cp -> scsi_smsg [msglen++] = 2;
		cp -> scsi_smsg [msglen++] = M_X_WIDE_REQ;
		cp -> scsi_smsg [msglen++] = tp->usrwide;
d4063 1
a4063 1
	segments = ncr_scatter (np, &cp->phys, (vm_offset_t) xp->data,
a4117 1
/*	cp->phys.smsg.addr		= cp->p_scsi_smsg;*/
a4120 1
/*	cp->phys.smsg2.addr		= cp->p_scsi_smsg2;*/
a4130 1
/*	cp->phys.scmd.addr		= cp->p_sensecmd;*/
d4178 3
a4180 3
	ptr = np->squeueput + 1;
	if (ptr >= MAX_START) ptr=0;
	np->squeue [ptr	  ] = NCB_SCRIPT_PHYS (np, idle);
d4182 1
a4182 1
	np->squeueput = ptr;
d4312 1
a4312 1
		printf ("CCB=%lx STAT=%x/%x\n", (unsigned long)cp & 0xfff,
d4388 1
a4388 1
		ncr_alloc_ccb (np, xp);
d4457 7
a4463 2
	} else if ((cp->host_status == HS_SEL_TIMEOUT)
		|| (cp->host_status == HS_TIMEOUT)) {
d4647 1
a4647 1
	OUTB (nc_stime0, 0xfb	);	/*  HTH = 1.6sec  STO = 0.1 sec.     */
d4776 1
a4776 1
	u_char target = INB (nc_ctest0)&7;
d4784 1
a4784 1
	assert (target == (xp->sc_link->target & 7));
d4833 1
a4833 1
	u_short target = INB (nc_ctest0)&7;
d4843 1
a4843 1
	assert (target == (xp->sc_link->target & 7));
d4906 4
a4909 2
	if ((  tp->inqdata[7] & INQ7_QUEUE) && ((tp->inqdata[0] & 0x1f)==0x00)
		&& tp->usrtags) {
d5058 1
d5076 1
a5076 1

d5166 1
a5166 1
		if (DEBUG_FLAGS & DEBUG_TINY) printf ("F");
d5171 3
a5173 2

	if (!(istat & (SIP|DIP))) return;
d5605 3
a5607 3
	    printf ("%s: SCSI phase error fixup: CCB address mismatch (0x%08lx != 0x%08lx)\n", 
		    ncr_name (np), (u_long) cp, (u_long) np->header.cp);
	    return;
d5751 1
a5751 1
	u_char	target = INB (nc_ctest0) & 7;
d6069 1
a6069 1
			(void) ncr_show_msg (np->msgin);
d6167 1
a6167 1
			(void) ncr_show_msg (np->msgin);
d6411 1
a6411 1
static	void ncr_alloc_ccb (ncb_p np, struct scsi_xfer * xp)
a6416 3
	u_long	target;
	u_long	lun;

a6417 4
	assert (xp != NULL);

	target = xp->sc_link->target;
	lun    = xp->sc_link->lun;
d6451 1
a6451 1
		ncr_setmaxtags (tp, SCSI_NCR_MAX_TAGS);
a6507 1
		PRINT_ADDR(xp);
d6628 1
a6628 1
	(ncb_p np, struct dsb* phys, vm_offset_t vaddr, vm_size_t datalen)
d6987 5
a6991 2

static void ncr_getclock (ncb_p np, u_char scntl3)
d6993 1
a6993 4
	u_char	tbl[6] = {6,2,3,4,6,8};
	u_char	f;
	u_char	ns_clock = (1000/NCR_CLOCK);

d6995 79
a7073 35
	**	Compute the best value for scntl3.
	*/
/*
	f = (2 * MIN_SYNC_PD - 1) / ns_clock;
	if (!f ) f=1;
	if (f>4) f=4;
	np -> ns_sync = (ns_clock * tbl[f]) / 2;
	np -> rv_scntl3 = f<<4;

	f = (2 * MIN_ASYNC_PD - 1) / ns_clock;
	if (!f ) f=1;
	if (f>4) f=4;
	np -> ns_async = (ns_clock * tbl[f]) / 2;
	np -> rv_scntl3 |= f;
	if (DEBUG_FLAGS & DEBUG_TIMING)
		printf ("%s: sclk=%d async=%d sync=%d (ns) scntl3=0x%x\n",
		ncr_name (np), ns_clock, np->ns_async, np->ns_sync, np->rv_scntl3);
*/

	/*
	 *	For now just preserve the BIOS setting ...
	 */

	if ((scntl3 & 7) == 0) {
		scntl3 = 3; /* assume 40MHz if no value supplied by BIOS */
	}

	np->ns_sync   = 25;
	np->ns_async  = 50;
	np->rv_scntl3 = ((scntl3 & 0x7) << 4) -0x20 + (scntl3 & 0x7);

	if (bootverbose) {
		printf ("\tinitial value of SCNTL3 = %02x, final = %02x\n",
			scntl3, np->rv_scntl3);
	}
@


1.13
log
@se@@freebsd.org: fix sync transfer negotiation.
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.12 1996/09/05 23:07:00 dm Exp $	*/
a119 2
**    The common SCSI devices require only
**    one lun, so take 1 as the default.
d122 1
a122 1
#define MAX_LUN     (1)
@


1.12
log
@se@@freebsd.org: some changes for the 53c860 and the 53c875
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.11 1996/08/21 22:27:57 deraadt Exp $	*/
d5982 12
a5993 3
		fak = (4ul * per - 1) / np->ns_sync - 3;
		if (ofs && (fak>7))   {chg = 1; ofs = 0;}
		if (!ofs) fak=7;
@


1.11
log
@check for __OpenBSD__, prep for tossing __NetBSD__?
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.10 1996/06/10 07:34:47 deraadt Exp $	*/
d1272 1
a1272 1
static	void	ncr_getclock	(ncb_p np);
d3543 1
a3543 1
	ncr_getclock (np);
d6966 1
a6966 1
static void ncr_getclock (ncb_p np)
d6968 1
a6968 1
	u_char	tbl[5] = {6,2,3,4,6};
d6975 1
a6975 1

d6990 18
@


1.10
log
@sync to 0607
@
text
@d1 1
a1 1
/*	$OpenBSD: ncr.c,v 1.9 1996/05/26 00:27:45 deraadt Exp $	*/
d161 1
a161 1
#ifdef __NetBSD__
d178 1
a178 1
#ifndef __NetBSD__
d189 1
a189 1
#ifndef __NetBSD__
d209 1
a209 1
#ifndef __NetBSD__
d213 1
a213 1
#if defined(__NetBSD__) && defined(__alpha__)
d280 1
a280 1
#ifdef __NetBSD__
d997 1
a997 1
#ifdef __NetBSD__
d1032 1
a1032 1
#ifndef __NetBSD__
d1039 1
a1039 1
#ifndef __NetBSD__
d1161 1
a1161 1
#if defined(NCR_IOMAPPED) && !defined(__NetBSD__)
d1275 1
a1275 1
#ifdef __NetBSD__
d1287 1
a1287 1
#ifndef __NetBSD__
d1311 1
a1311 1
#ifdef __NetBSD__
d1344 1
a1344 1
#ifndef __NetBSD__
d1369 1
a1369 1
#ifdef __NetBSD__
d1398 1
a1398 1
#ifndef __NetBSD__
d1405 1
a1405 1
#ifndef __NetBSD__
d1417 1
a1417 1
#ifndef __NetBSD__
d1422 1
a1422 1
#ifdef __NetBSD__
d3084 1
a3084 1
#ifndef __NetBSD__
d3240 1
a3240 1
#ifndef __NetBSD__
d3261 1
a3261 1
#ifndef __NetBSD__
d3275 1
a3275 1
#ifdef __NetBSD__
d3343 1
a3343 1
#ifdef __NetBSD__
d3492 1
a3492 1
#ifdef __NetBSD__
d3521 1
a3521 1
#ifndef __NetBSD__
d3559 1
a3559 1
#ifdef __NetBSD__
d3588 1
a3588 1
#ifndef __NetBSD__
d3619 1
a3619 1
#ifdef __NetBSD__
d3632 1
a3632 1
#ifdef __NetBSD__
d3689 1
a3689 1
#ifdef __NetBSD__
d3736 1
a3736 1
#ifdef __NetBSD__
d4194 1
a4194 1
#ifdef __NetBSD__
d4247 1
a4247 1
#ifdef __NetBSD__
d4346 1
a4346 1
#ifdef __NetBSD__
d4413 1
a4413 1
#ifndef __NetBSD__
d4609 1
a4609 1
#ifndef __NetBSD__
d6552 1
a6552 1
#ifdef __NetBSD__
d6576 1
a6576 1
#ifdef __NetBSD__
@


1.9
log
@sync 0521
@
text
@d1 2
a2 2
/*	$OpenBSD: ncr.c,v 1.8 1996/05/07 07:38:40 deraadt Exp $	*/
/*	$NetBSD: ncr.c,v 1.35 1996/05/13 00:03:26 mycroft Exp $	*/
d215 1
a215 1
#define	vtophys(va)	(vtophys(va) | 0x40000000)
d1298 2
a1299 1
static	int	ncr_scatter	(struct dsb* phys,u_long vaddr,u_long datalen);
d1333 1
a1333 1
	"\n$NetBSD: ncr.c,v 1.35 1996/05/13 00:03:26 mycroft Exp $\n";
d4048 1
a4048 1
	segments = ncr_scatter (&cp->phys, (vm_offset_t) xp->data,
d6606 1
a6606 1
	(struct dsb* phys, vm_offset_t vaddr, vm_size_t datalen)
@


1.8
log
@sync with 0504 -- prototypes and bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: ncr.c,v 1.7 1996/04/21 22:25:22 deraadt Exp $	*/
/*	$NetBSD: ncr.c,v 1.34 1996/05/03 17:39:49 christos Exp $	*/
a197 1
#ifdef __alpha__
a198 1
#endif
d1332 1
a1332 1
	"\n$NetBSD: ncr.c,v 1.34 1996/05/03 17:39:49 christos Exp $\n";
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: ncr.c,v 1.6 1996/04/18 23:47:59 niklas Exp $	*/
/*	$NetBSD: ncr.c,v 1.33 1996/04/03 08:44:15 mycroft Exp $	*/
a1275 1
static  U_INT32 ncr_info	(int unit);
d1281 1
d1332 1
d1334 2
a1335 1
	"\n$NetBSD: ncr.c,v 1.33 1996/04/03 08:44:15 mycroft Exp $\n";
d3262 1
d3267 1
d3283 2
a3285 1
	struct pci_attach_args *pa = aux;
a3286 1
#ifdef 0
d3346 2
d4301 1
a4301 1
		printf ("CCB=%x STAT=%x/%x\n", (unsigned long)cp & 0xfff,
d4768 1
a4768 1
	assert (target == xp->sc_link->target & 7);
d4827 1
a4827 1
	assert (target == xp->sc_link->target & 7);
@


1.6
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ncr.c,v 1.29 1996/03/14 05:21:20 cgd Exp $	*/
d198 3
d204 1
d206 1
d215 4
d1003 1
d1333 1
a1333 1
	"\n$NetBSD: ncr.c,v 1.29 1996/03/14 05:21:20 cgd Exp $\n";
d1370 6
a1375 2
struct	cfdriver ncrcd = {
	NULL, "ncr", ncr_probe, ncr_attach, DV_DULL, sizeof(struct ncb)
d3343 3
a3345 1
ncr_print()
d3347 4
d3359 6
a3364 1
	int retval;
d3390 3
d3398 4
a3401 3
	retval = pci_map_mem(pa->pa_tag, 0x14, (vm_offset_t *)&np->sc_memh,
	    &np->paddr);
	if (retval)
d3403 1
d3405 4
a3408 3
	np->sc_ih = pci_map_int(pa->pa_tag, IPL_BIO, ncr_intr, np,
	    np->sc_dev.dv_xname);
	if (np->sc_ih == NULL)
d3410 1
d3412 21
@


1.5
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 3
a5 2
**  $Id: ncr.c,v 1.4 1995/12/27 22:06:47 deraadt Exp $
**
d197 1
d199 1
a200 1
#include <dev/pci/pcireg.h>
d202 1
a202 1
#endif /* __NetBSD */
d208 1
a208 1
#endif /* __NetBSD */
d273 2
d277 48
d326 1
d329 1
d334 1
d338 10
a347 7
#define INB(r) (np->reg->r)
#define INW(r) (np->reg->r)
#define INL(r) (np->reg->r)

#define OUTB(r, val) np->reg->r = val
#define OUTW(r, val) np->reg->r = val
#define OUTL(r, val) np->reg->r = val
d351 2
d459 2
a463 9
#ifdef __NetBSD__
	#define INT32     int
	#define U_INT32   u_int
	#define TIMEOUT   (void*)
#else  /*__NetBSD__*/
	#define INT32     int32
	#define U_INT32   u_int32
	#define TIMEOUT   (timeout_func_t)
#endif /*__NetBSD__*/
d485 2
a486 2
	u_long	l_cmd;
	u_long	l_paddr;
d912 1
a912 1
	u_long			patch[8];
d993 6
d1024 1
d1027 3
d1031 1
d1037 1
d1153 1
a1153 1
#ifdef NCR_IOMAPPED
d1323 1
a1323 1
	"\n$Id: ncr.c,v 1.4 1995/12/27 22:06:47 deraadt Exp $\n";
d1443 1
d1450 15
d1472 1
a1472 1
		(ncrcmd) &time.tv_sec,
d1714 1
a1714 1
		(ncrcmd) &time,
d1896 1
a1896 1
		(ncrcmd) &time,
d1918 1
a1918 1
		(ncrcmd) &time,
d2483 1
a2483 1
		(ncrcmd) &time,
d2867 1
a2867 1
**		(ncrcmd) &time,
d2894 1
a2894 1
**		(ncrcmd) &time,
d2913 1
a2913 2
(u_long)&ident

d2955 1
a2955 1
		(ncrcmd) &ncr_cache,
d2962 1
a2962 1
		(ncrcmd) &ncr_cache,
d2967 1
a2967 1
		(ncrcmd) &ncr_cache,
d3010 1
a3010 1
	*p++ =(ncrcmd) &time;
d3034 1
a3034 1
	*p++ =(ncrcmd) &time;
d3065 1
a3065 1
	ncrcmd  opcode, new, old;
d3070 1
a3070 1
	np->script = (struct script*) vm_page_alloc_contig 
d3103 1
a3103 2
			printf ("%x:  <%x>\n",
				(unsigned)(src-1), (unsigned)opcode);
d3115 7
a3121 1
			if ((src[0] ^ src[1]) & 3) {
d3172 9
d3189 1
a3189 1
					new = vtophys(old);
d3342 22
a3363 6
	/*
	** XXX NetBSD
	** Perhaps try to figure what which model chip it is and print that
	** out.
	*/
	printf("\n");
d3370 2
a3371 1
	retval = pci_map_mem(pa->pa_tag, 0x14, &np->vaddr, &np->paddr);
d3376 1
a3376 1
				np->sc_dev.dv_xname);
d3463 1
d3471 1
d3798 1
a3798 1
	cp->phys.header.stamp.start = time;
d4101 1
a4101 1
	cp->tlimit		= time.tv_sec + xp->timeout / 1000 + 2;
d4242 1
a4242 1
		printf ("CCB=%x STAT=%x/%x\n", (unsigned)cp & 0xfff,
d4401 2
a4402 2
		printf ("COMMAND FAILED (%x %x) @@%x.\n",
			cp->host_status, cp->scsi_status, (unsigned)cp);
d4941 1
a4941 1
	u_long	thistime = time.tv_sec;
d5021 2
a5022 2
				printf ("%s: timeout ccb=%x (skip)\n",
					ncr_name (np), (unsigned)cp);
d5079 3
a5081 3
	u_char	istat, dstat;
	u_short	sist;
	u_long	dsp, dsa;
d5191 1
a5191 1
	if (time.tv_sec - np->regtime.tv_sec>10) {
d5193 1
a5193 1
		np->regtime = time;
d5195 1
a5195 1
			((char*)&np->regdump)[i] = ((char*)np->reg)[i];
d5249 1
a5249 1
		printf (" %02x", ((u_char*)np->reg)[i]);
d5372 1
a5372 1
			val = ((unsigned char*) np->vaddr) [i];
d5472 10
a5481 9
	u_long	dbc;
	u_long	rest;
	u_long	dsa;
	u_long	dsp;
	u_long	nxtdsp;
	u_long	*vdsp;
	u_long	oadr, olen;
	u_long	*tblp, *newcmd;
	u_char	cmd, sbcl, delta, ss0, ss2;
d5543 1
a5543 1
		vdsp = (u_long*) ((char*)np->script - np->p_script + dsp -8);
d5556 3
a5558 4
		printf ("\nCP=%x CP2=%x DSP=%x NXT=%x VDSP=%x CMD=%x ",
			(unsigned)cp, (unsigned)np->header.cp,
			(unsigned)dsp,
			(unsigned)nxtdsp, (unsigned)vdsp, cmd);
d5568 1
a5568 1
		tblp = (u_long*) ((char*) &cp->phys + oadr);
d5572 1
a5572 1
		tblp = (u_long*) 0;
d5577 1
a5577 1
		printf ("OCMD=%x\nTBLP=%x OLEN=%x OADR=%x\n",
d5579 1
a5579 1
			(unsigned) tblp,
d6428 1
a6428 1
		printf ("new ccb @@%x.\n", (unsigned) cp);
d6657 1
a6657 1
	register volatile u_long data, *addr;
a6662 1
	addr = (u_long*) &np->reg->nc_dstat;
d6664 2
a6665 2
	*addr= data;
	data = *addr;
d6786 1
a6786 1
	PROFILE.end = time;
a6935 2


@


1.4
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d3 1
a3 1
**  $Id: ncr.c,v 1.3 1995/12/01 01:51:21 deraadt Exp $
d1258 1
a1258 1
	"\n$Id: ncr.c,v 1.3 1995/12/01 01:51:21 deraadt Exp $\n";
d3264 2
a3265 1
	np->sc_ih = pci_map_int(pa->pa_tag, IPL_BIO, ncr_intr, np);
@


1.3
log
@from netbsd:
Changed to use the hacked up version Thor got from the original
maintainers. It is uglier than mycroft's version, but it works on a
lot more machines than his does. Hopefully this can be fixed "for
real" after the release. Note that although it works on a superset of
the machines that mycroft's did, it is still broken on some slower
machines with fast disks. The thing is full of timing bugs. Sigh.
@
text
@d3 1
a3 1
**  $Id: ncr.c,v 1.18.2.2 1995/11/23 20:50:06 perry Exp $
d1258 1
a1258 1
	"\n$Id: ncr.c,v 1.18.2.2 1995/11/23 20:50:06 perry Exp $\n";
d3264 1
a3264 1
	np->sc_ih = pci_map_int(pa->pa_tag, PCI_IPL_BIO, ncr_intr, np);
@


1.2
log
@DV_DISK -> DV_DULL
@
text
@a0 2
/*	$NetBSD: ncr.c,v 1.18.2.1 1995/10/23 15:53:32 pk Exp $	*/

d3 1
a3 1
**  $Id: ncr.c,v 1.18.2.1 1995/10/23 15:53:32 pk Exp $
a52 3
#ifdef __i386__
#define NCR_IOMAPPED
#endif
d160 7
d172 1
a172 1
#ifdef _KERNEL
d178 1
d185 1
a185 1
#endif /* _KERNEL */
d200 1
a200 1
#endif /* __NetBSD__ */
a202 1
#include <scsi/scsi_message.h>
d206 1
a206 3
#else /* __NetBSD__ */
#include <machine/pio.h>
#endif /* __NetBSD__ */
d277 3
a279 3
#define	OUTB(r, val) outb (np->port + offsetof(struct ncr_reg, r), (val))
#define	OUTW(r, val) outw (np->port + offsetof(struct ncr_reg, r), (val))
#define	OUTL(r, val) outl (np->port + offsetof(struct ncr_reg, r), (val))
d287 3
a289 3
#define OUTB(r, val) (np->reg->r = (val))
#define OUTW(r, val) (np->reg->r = (val))
#define OUTL(r, val) (np->reg->r = (val))
d307 1
a307 1
#define HS_RESET	(6)	/* SCSI reset	          */
d361 15
d406 1
a406 1
#else  /* !__NetBSD__ */
d410 1
a410 1
#endif /* __NetBSD__ */
a451 10

/*==========================================================
**
**	Access to fields of structs.
**
**==========================================================
*/

#define	offsetof(type, member)	((size_t)(&((type *)0)->member))

d1084 1
a1084 1
	**	option for MSG_IDENTIFY message: enables disconnecting
d1092 1
a1092 1
	int		port;
d1193 10
a1202 10
#ifdef _KERNEL
void	ncr_alloc_ccb	(ncb_p np, struct scsi_xfer * xp);
void	ncr_complete	(ncb_p np, ccb_p cp);
int	ncr_delta	(struct timeval * from, struct timeval * to);
void	ncr_exception	(ncb_p np);
void	ncr_free_ccb	(ncb_p np, ccb_p cp, int flags);
void	ncr_getclock	(ncb_p np);
ccb_p	ncr_get_ccb	(ncb_p np, u_long flags, u_long t,u_long l);
U_INT32 ncr_info	(int unit);
void	ncr_init	(ncb_p np, char * msg, u_long code);
d1204 1
a1204 1
int     ncr_intr        (void *);
d1206 5
a1210 5
int	ncr_intr	(ncb_p np);
#endif	/* __NetBSD__ */
void	ncr_int_ma	(ncb_p np);
void	ncr_int_sir	(ncb_p np);
void    ncr_int_sto     (ncb_p np);
d1212 1
a1212 1
u_long	ncr_lookup	(char* id);
d1214 9
a1222 5
void	ncr_minphys	(struct buf *bp);
void	ncr_negotiate	(struct ncb* np, struct tcb* tp);
void	ncr_openings	(ncb_p np, lcb_p lp, struct scsi_xfer * xp);
void	ncb_profile	(ncb_p np, ccb_p cp);
void	ncr_script_copy_and_bind
d1224 12
a1235 12
void    ncr_script_fill (struct script * scr);
int	ncr_scatter	(struct dsb* phys,u_long vaddr,u_long datalen);
void	ncr_setmaxtags	(tcb_p tp, u_long usrtags);
void	ncr_setsync	(ncb_p np, ccb_p cp, u_char sxfer);
void	ncr_settags     (tcb_p tp, lcb_p lp);
void	ncr_setwide	(ncb_p np, ccb_p cp, u_char wide);
int	ncr_show_msg	(u_char * msg);
int	ncr_snooptest	(ncb_p np);
INT32	ncr_start       (struct scsi_xfer *xp);
void	ncr_timeout	(ncb_p np);
void	ncr_usercmd	(ncb_p np);
void    ncr_wakeup      (ncb_p np, u_long code);
d1238 2
a1239 2
int	ncr_probe	(struct device *, void *, void *);
void	ncr_attach	(struct device *, struct device *, void *);
d1241 2
a1242 2
char*	ncr_probe       (pcici_t tag, pcidi_t type);
void	ncr_attach	(pcici_t tag, int unit);
d1245 1
a1245 1
#endif /* _KERNEL */
d1258 1
a1258 1
	"\n$Id: ncr.c,v 1.18.2.1 1995/10/23 15:53:32 pk Exp $\n";
d1266 1
a1266 1
#ifdef _KERNEL
d1273 1
a1273 1
int ncr_debug = SCSI_DEBUG_FLAGS;
d1301 1
a1301 1
u_long ncr_count;
d1318 3
d1322 1
d1348 1
a1348 1
char *ncr_name (ncb_p np)
d1581 1
a1581 1
	**	(and the MSG_EXT_SDTR message)
d1665 1
a1665 1
	SCR_LOAD_REG (scratcha, MSG_NOOP),
d1683 1
a1683 1
	SCR_JUMP ^ IFTRUE (DATA (MSG_EXTENDED)),
d1685 1
a1685 1
	SCR_JUMP ^ IFTRUE (DATA (MSG_MESSAGE_REJECT)),
d1794 1
a1794 1
	**	Prepare a MSG_INITIATOR_DET_ERR message
d1798 1
a1798 1
	SCR_LOAD_REG (scratcha, MSG_INITIATOR_DET_ERR),
d1809 1
a1809 1
/*<<<*/	SCR_JUMPR ^ IFTRUE (DATA (SCSI_CHECK)),
d1844 1
a1844 1
/*<<<*/	SCR_JUMPR ^ IFFALSE (DATA (SCSI_CHECK)),
d1875 1
a1875 1
	SCR_JUMP ^ IFTRUE (DATA (SCSI_CHECK)),
d1909 1
a1909 1
	SCR_JUMP ^ IFTRUE (DATA (MSG_CMDCOMPLETE)),
d1911 1
a1911 1
	SCR_JUMP ^ IFTRUE (DATA (MSG_SAVEDATAPOINTER)),
d1913 1
a1913 1
	SCR_JUMP ^ IFTRUE (DATA (MSG_RESTOREPOINTERS)),
d1915 1
a1915 1
	SCR_JUMP ^ IFTRUE (DATA (MSG_DISCONNECT)),
d1917 1
a1917 1
	SCR_JUMP ^ IFTRUE (DATA (MSG_EXTENDED)),
d1919 1
a1919 1
	SCR_JUMP ^ IFTRUE (DATA (MSG_NOOP)),
d1921 1
a1921 1
	SCR_JUMP ^ IFTRUE (DATA (MSG_MESSAGE_REJECT)),
d1923 1
a1923 1
	SCR_JUMP ^ IFTRUE (DATA (MSG_IGN_WIDE_RESIDUE)),
d1938 1
a1938 1
	SCR_LOAD_REG (scratcha, MSG_MESSAGE_REJECT),
d1952 1
a1952 1
	SCR_LOAD_REG (scratcha, MSG_PARITY_ERROR),
d2083 1
a2083 1
	SCR_JUMP ^ IFTRUE (DATA (MSG_EXT_WDTR)),
d2120 1
a2120 1
	**	Send the MSG_EXT_WDTR
d2153 1
a2153 1
	SCR_JUMP ^ IFTRUE (DATA (MSG_EXT_SDTR)),
d2191 1
a2191 1
	**	Send the MSG_EXT_SDTR
d2277 1
a2277 1
	SCR_JUMP ^ IFTRUE (DATA (SCSI_CHECK)),
d2332 1
a2332 1
	**	If SDEV_AUTOSAVE is set,
d2337 1
a2337 1
/*<<<*/	SCR_JUMPR ^ IFFALSE (MASK (SDEV_AUTOSAVE, SDEV_AUTOSAVE)),
d2432 1
a2432 1
	SCR_JUMP ^ IFTRUE (DATA (MSG_ABORT)),
d2444 1
a2444 1
	SCR_LOAD_REG (scratcha, MSG_NOOP),
d2546 1
a2546 1
	**	If SDEV_NOSYNCWIDE is set, select without ATN.
d2551 1
a2551 1
	SCR_JUMP ^ IFTRUE (MASK (SDEV_NOSYNCWIDE, SDEV_NOSYNCWIDE)),
d2701 1
a2701 1
/*<<<*/	SCR_JUMPR ^ IFFALSE (MASK (MSG_IDENTIFY(0, 0), 0x98)),
d2742 1
a2742 1
/*<<<*/	SCR_JUMPR ^ IFFALSE (DATA (MSG_SIMPLE_Q_TAG)),
d2839 1
a2839 1
	SCR_LOAD_REG (scratcha, MSG_ABORT_TAG),
d2844 1
a2844 1
	SCR_LOAD_REG (scratcha, MSG_ABORT),
d2983 1
a2983 1
void ncr_script_copy_and_bind (struct script *script, ncb_p np)
d2990 1
a2990 1
	np->script = (struct script*) vm_page_alloc_contig
d3121 7
d3131 6
d3139 1
a3139 1
	if (bp->b_bcount > MAX_SIZE)
d3143 1
d3174 4
d3186 1
a3186 1
	return (1);
d3191 2
a3192 1
char* ncr_probe (pcici_t tag, pcidi_t type)
a3212 3

	default:
		return (NULL);
d3214 1
d3245 1
d3260 2
a3261 9
	if (pci_map_mem(pa->pa_tag, 0x14, &np->vaddr, &np->paddr))
		return;

#ifdef NCR_IOMAPPED
	/*
	**	Try to map the controller chip into iospace.
	*/

	if (pci_map_io(pa->pa_tag, 0x10, &np->port))
a3262 1
#endif
d3268 1
d3271 1
a3271 1
void ncr_attach (pcici_t config_id, int unit)
d3387 3
a3391 3
#ifdef __NetBSD__
			printf (" %08x", (int)pci_conf_read (pa->pa_tag, reg));
#else /* !__NetBSD__ */
a3392 1
#endif /* __NetBSD__ */
a3439 1
#ifndef NCR_NO_DISCONNECT
a3440 1
#endif
d3487 1
a3487 1

d3520 3
a3522 3
	void *arg;
{
	ncb_p np = arg;
d3562 1
a3562 1
INT32 ncr_start (struct scsi_xfer * xp)
d3611 20
d3646 7
a3652 2
	if ((flags & (ITSDONE|INUSE)) != INUSE) {
		printf("%s: done or not in use?\n", ncr_name (np));
d3654 4
a3657 2
		xp->flags |= INUSE;
	}
d3686 25
d3726 1
a3726 1
			if (SCSI_NCR_MAX_SYNC
d3786 2
d3797 3
a3799 1
	idmsg = MSG_IDENTIFY(xp->sc_link->lun, np->disc && (cp != &np->ccb));
d3802 1
a3802 1
	msglen = 1;
d3813 1
a3813 1
			cp -> scsi_smsg [msglen] = MSG_SIMPLE_Q_TAG;
d3816 1
a3816 2
			cp -> scsi_smsg [msglen] = MSG_ORDERED_Q_TAG;
			break;
d3823 2
a3824 2
		case MSG_SIMPLE_Q_TAG:
		case MSG_ORDERED_Q_TAG:
a3825 1
			break;
d3833 1
a3833 1
		cp -> scsi_smsg [msglen++] = MSG_EXTENDED;
d3835 1
a3835 1
		cp -> scsi_smsg [msglen++] = MSG_EXT_SDTR;
d3846 1
a3846 1
		cp -> scsi_smsg [msglen++] = MSG_EXTENDED;
d3848 1
a3848 1
		cp -> scsi_smsg [msglen++] = MSG_EXT_WDTR;
d3954 1
a3956 2
	else
		cp->sensecmd[4]		= sizeof(struct scsi_sense_data);
d3965 1
a3965 1
	cp->actualquirks		= xp->sc_link->quirks;
d4003 1
a4003 1
		(unsigned)(np->script->startpos[0]-
d4023 2
a4024 2
	if (!(flags & SCSI_POLL)) {
#else /* !__NetBSD__ */
d4075 10
a4084 3

	if (xp->error == XS_BUSY)
		return (TRY_AGAIN_LATER);
a4173 10
	if (xp->error != XS_NOERROR) {

		/*
		**      Don't override the error value.
		*/

	} else if (cp->host_status != HS_COMPLETE) {

		switch (cp->host_status) {
		case HS_SEL_TIMEOUT:
d4175 6
a4180 5
			/*
			**	Selection timeout; device missing.
			*/
			xp->error = XS_SELTIMEOUT;
			break;
d4182 2
a4183 56

		case HS_TIMEOUT:
			/*
			**	No response to command.
			*/
			xp->error = XS_TIMEOUT;
			break;

		default:
			/*
			**	Other protocol messes.
			*/
			PRINT_ADDR(xp);
			printf ("COMMAND FAILED (%x %x) @@%x.\n",
				cp->host_status, cp->scsi_status, (unsigned)cp);
			xp->error = XS_DRIVER_STUFFUP;
			break;
		}

	} else if (cp->scsi_status != SCSI_OK) {

		switch (cp->scsi_status) {
		case S_SENSE|SCSI_OK:
			/*
			**	Check condition code.
			*/
			xp->error = XS_SENSE;

			if (DEBUG_FLAGS & (DEBUG_RESULT|DEBUG_TINY)) {
				u_char * p = (u_char*) & xp->sense;
				int i;
				printf ("\n%s: sense data:", ncr_name (np));
				for (i=0; i<14; i++) printf (" %x", *p++);
				printf (".\n");
			};
			break;

		case SCSI_BUSY:
			/*
			**	Target is busy.
			*/
			xp->error = XS_BUSY;
			break;

		default:
			/*
			**	Other protocol messes.
			*/
			PRINT_ADDR(xp);
			printf ("COMMAND FAILED (%x %x) @@%x.\n",
				cp->host_status, cp->scsi_status, (unsigned)cp);
			xp->error = XS_DRIVER_STUFFUP;
			break;
		}

	} else {
d4223 5
d4236 1
a4236 1
				ncr_openings (np, lp, xp);
d4241 50
d4309 1
a4309 1
			case SCSI_OK:
d4312 1
a4312 1
			case SCSI_CHECK:
d4529 1
a4529 1
void ncr_negotiate (struct ncb* np, struct tcb* tp)
d4583 1
a4583 1
void ncr_setsync (ncb_p np, ccb_p cp, u_char sxfer)
d4641 1
a4641 1
void ncr_setwide (ncb_p np, ccb_p cp, u_char wide)
d4693 1
a4693 1
void ncr_setmaxtags (tcb_p tp, u_long usrtags)
d4706 1
a4706 1
void ncr_settags (tcb_p tp, lcb_p lp)
d4750 1
a4750 1
void ncr_usercmd (ncb_p np)
d4825 1
a4825 1
void ncr_timeout (ncb_p np)
a4926 1
				break;
d5129 1
a5129 1
		printf ("\tscript cmd = %08x\n",
d5230 1
a5230 1
**	They may occur if there are problems with synch transfers, or
d5246 12
a5257 1
			if (i%16==0) printf("%s: reg[%02x]:", ncr_name(np), i);
d5356 1
a5356 1
void ncr_int_ma (ncb_p np)
d5406 1
a5406 1
	    printf ("%s: SCSI phase error fixup: CCB already dequeued (0x%08lx)\n",
d5411 1
a5411 1
	    printf ("%s: SCSI phase error fixup: CCB address mismatch (0x%08lx != 0x%08lx)\n",
d5478 1
a5478 1

d5535 1
a5535 1
int ncr_show_msg (u_char * msg)
d5539 1
a5539 1
	if (*msg==MSG_EXTENDED) {
a5582 1
		break;
d5612 1
a5612 1
				(cp->scsi_status==SCSI_CHECK))
d5650 1
a5650 1
		cp->scsi_status = SCSI_CHECK;
d5686 1
a5686 1
**	(hopefully) valid answer, set our parameters, and send back
d5693 1
a5693 1
**	When we set the values, we adjust them in all ccbs belonging
d5761 2
a5762 2
		np->msgin [0] = MSG_NOOP;
		np->msgout[0] = MSG_NOOP;
d5856 1
a5856 1
		np->msgout[0] = MSG_EXTENDED;
d5858 1
a5858 1
		np->msgout[2] = MSG_EXT_SDTR;
d5875 1
a5875 1
		np->msgin [0] = MSG_NOOP;
d5953 1
a5953 1
		np->msgout[0] = MSG_EXTENDED;
d5955 1
a5955 1
		np->msgout[2] = MSG_EXT_WDTR;
d5958 1
a5958 1
		np->msgin [0] = MSG_NOOP;
d5980 1
a5980 1
		**	We received a MSG_MESSAGE_REJECT message.
d5986 1
a5986 1
		printf ("MSG_MESSAGE_REJECT received (%x:%x).\n",
d5999 1
a5999 1
		printf ("MSG_MESSAGE_REJECT sent for ");
d6021 1
a6021 1
		printf ("MSG_IGN_WIDE_RESIDUE received, but not yet implemented.\n");
d6034 1
a6034 1
		printf ("MSG_DISCONNECT received, but datapointer not saved:\n"
d6133 2
a6134 1
ccb_p ncr_get_ccb (ncb_p np, u_long flags, u_long target, u_long lun)
d6209 1
a6209 1
void ncr_alloc_ccb (ncb_p np, struct scsi_xfer * xp)
d6365 1
a6365 1
void ncr_openings (ncb_p np, lcb_p lp, struct scsi_xfer * xp)
d6378 1
a6378 1
		if (diff == 0) return;
d6380 1
d6385 6
d6404 1
d6406 3
d6433 2
a6434 1
int ncr_scatter (struct dsb* phys, vm_offset_t vaddr, vm_size_t datalen)
d6541 1
a6541 1
int ncr_regtest (struct ncb* np)
d6566 1
a6566 1
int ncr_snooptest (struct ncb* np)
d6659 1
a6659 1
int ncr_delta (struct timeval * from, struct timeval * to)
d6668 1
a6668 1
void ncb_profile (ncb_p np, ccb_p cp)
d6713 59
d6795 1
a6795 1
void ncr_getclock (ncb_p np)
d6822 3
a6824 1
#endif /* _KERNEL */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ncr.c,v 1.18 1995/10/02 16:48:36 mycroft Exp $	*/
d5 1
a5 1
**  $Id: ncr.c,v 1.18 1995/10/02 16:48:36 mycroft Exp $
d1249 1
a1249 1
	"\n$Id: ncr.c,v 1.18 1995/10/02 16:48:36 mycroft Exp $\n";
d1287 1
a1287 1
	NULL, "ncr", ncr_probe, ncr_attach, DV_DISK, sizeof(struct ncb)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

