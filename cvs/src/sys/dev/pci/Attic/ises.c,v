head	1.34;
access;
symbols
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.31.0.6
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.31.0.4
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.2
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.27.0.4
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.24.0.4
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.23
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.22
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	SMP:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2;
locks; strict;
comment	@ * @;


1.34
date	2008.05.07.02.45.03;	author krw;	state dead;
branches;
next	1.33;

1.33
date	2007.10.01.15.34.48;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2007.09.18.22.02.18;	author djm;	state Exp;
branches;
next	1.31;

1.31
date	2006.06.29.21.34.51;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2006.04.20.20.31.12;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.26.14.31.26;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.09.04.10.12;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.07.14.42.26;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.07.01.41.37;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.04.16.59.31;	author grange;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.07.11.31.24;	author ho;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.18.18.16.21;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.05.21.21.17;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.05.21.03.46;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.09.03.11.38;	author deraadt;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.21.19.41.13;	author ho;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.09.19.42.05;	author ho;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.02.09.18.15;	author ho;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.27.00.20.16;	author ho;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.25.22.30.07;	author ho;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.24.21.08.07;	author ho;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.23.21.06.48;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.23.18.30.37;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.12.15.40.32;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.05.15.32.27;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.04.13.07.19;	author ho;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.28.20.02.59;	author angelos;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2001.01.30.14.07.44;	author ho;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.29.23.36.43;	author ho;	state Exp;
branches;
next	1.1;

1.1
date	2001.01.29.08.45.58;	author ho;	state Exp;
branches;
next	;

1.4.4.1
date	2001.05.14.22.25.49;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.07.04.10.42.34;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2002.03.28.15.35.58;	author niklas;	state Exp;
branches;
next	1.4.4.6;

1.4.4.6
date	2003.03.28.00.38.23;	author niklas;	state Exp;
branches;
next	1.4.4.7;

1.4.4.7
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	1.4.4.8;

1.4.4.8
date	2004.06.05.23.12.51;	author niklas;	state Exp;
branches;
next	;

1.18.2.1
date	2002.06.11.03.42.26;	author art;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.10.29.00.33.29;	author art;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2003.05.19.22.18.01;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Rather than fixing ises(4), nuke it.

ok deraadt@@
@
text
@/*	$OpenBSD: ises.c,v 1.33 2007/10/01 15:34:48 krw Exp $	*/

/*
 * Copyright (c) 2000, 2001 Håkan Olsson (ho@@crt.se)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * PCC-ISES hardware crypto accelerator
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/mbuf.h>
#include <sys/timeout.h>
#include <sys/device.h>
#include <sys/queue.h>

#include <crypto/cryptodev.h>
#include <crypto/cryptosoft.h>
#include <dev/rndvar.h>
#include <crypto/md5.h>
#include <crypto/sha1.h>
#include <crypto/rmd160.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/pci/isesreg.h>
#include <dev/pci/isesvar.h>
#include <dev/microcode/ises/ises_fw.h>

/*
 * Prototypes and count for the pci_device structure
 */
int	ises_match(struct device *, void *, void *);
void	ises_attach(struct device *, struct device *, void *);

void	ises_initstate(void *);
void	ises_hrng_init(struct ises_softc *);
void	ises_hrng(void *);
void	ises_process_oqueue(struct ises_softc *);
int	ises_queue_cmd(struct ises_softc *, u_int32_t, u_int32_t *, 
		       u_int32_t (*)(struct ises_softc *, struct ises_cmd *));
u_int32_t ises_get_fwversion(struct ises_softc *);
int	ises_assert_cmd_mode(struct ises_softc *);

int	ises_intr(void *);
int	ises_newsession(u_int32_t *, struct cryptoini *);
int	ises_freesession(u_int64_t);
int	ises_process(struct cryptop *);
void	ises_callback(struct ises_q *);
int	ises_feed(struct ises_softc *);
int	ises_bchu_switch_session(struct ises_softc *, 
				      struct ises_session *, int);
u_int32_t ises_bchu_switch_final(struct ises_softc *, struct ises_cmd *);

void	ises_read_dma(struct ises_softc *);

#define READ_REG(sc,r) \
    bus_space_read_4((sc)->sc_memt, (sc)->sc_memh,r)

#define WRITE_REG(sc,reg,val) \
    bus_space_write_4((sc)->sc_memt, (sc)->sc_memh, reg, val)

/* XXX This should probably be (x) = htole32((x)) */
#define SWAP32(x) ((x) = swap32((x)))

#ifdef ISESDEBUG
#  define DPRINTF(x) printf x
#else
#  define DPRINTF(x)
#endif

#ifdef ISESDEBUG
void	ises_debug_init(struct ises_softc *);
void	ises_debug_2(void);
void	ises_debug_loop(void *);
void	ises_showreg(void);
void	ises_debug_parse_omr(struct ises_softc *);
void	ises_debug_simple_cmd(struct ises_softc *, u_int32_t, u_int32_t);
struct ises_softc *ises_sc;
struct timeout ises_db_timeout;
int ises_db;
#endif

/* For HRNG entropy collection, these values gather 1600 bytes/s */
#ifndef ISESRNGBITS
#define ISESRNGBITS	128		/* Bits per iteration (mult. of 32) */
#define ISESRNGIPS	100		/* Iterations per second */
#endif

/* XXX Disable HRNG while debugging. */
#define ISES_HRNG_DISABLED

/* Maximum number of times we try to download the firmware. */
#define ISES_MAX_DOWNLOAD_RETRIES	3

struct cfattach ises_ca = {
	sizeof(struct ises_softc), ises_match, ises_attach,
};

struct cfdriver ises_cd = {
	0, "ises", DV_DULL
};

struct ises_stats {
	u_int64_t	ibytes;
	u_int64_t	obytes;
	u_int32_t	ipkts;
	u_int32_t	opkts;
	u_int32_t	invalid;
	u_int32_t	nomem;
} isesstats;

int
ises_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_PIJNENBURG &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_PIJNENBURG_PCC_ISES)
		return (1);

	return (0);
}

void
ises_attach(struct device *parent, struct device *self, void *aux)
{
	struct ises_softc *sc = (struct ises_softc *)self;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
	bus_size_t memsize;

	bus_dma_segment_t seg;
	int nsegs, error, state;

	SIMPLEQ_INIT(&sc->sc_queue);
	SIMPLEQ_INIT(&sc->sc_qchip);
	SIMPLEQ_INIT(&sc->sc_cmdq);
	state = 0;

	/* Map control/status registers. */
	if (pci_mapreg_map(pa, PCI_MAPREG_START,
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0, &sc->sc_memt,
	    &sc->sc_memh, NULL, &memsize, 0)) {
		printf(": can't find mem space\n");
		return;
	}
	state++;

	/* Map interrupt. */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		goto fail;
	}
	state++;

	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, ises_intr, sc,
	    self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt\n");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail;
	}

	/* Initialize DMA map */
	sc->sc_dmat = pa->pa_dmat;
	error = bus_dmamap_create(sc->sc_dmat, 1 << PGSHIFT, 1, 1 << PGSHIFT,
	    0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &sc->sc_dmamap);
	if (error) {
		printf(": cannot create dma map (%d)\n", error);
		goto fail;
	}
	state++;

	/* Allocate in DMAable memory. */
	if (bus_dmamem_alloc(sc->sc_dmat, ISES_B_DATASIZE, 1, 0, &seg, 1,
	    &nsegs, BUS_DMA_NOWAIT)) {
		printf(": can't alloc dma buffer space\n");
		goto fail;
	}
	state++;

	if (bus_dmamem_map(sc->sc_dmat, &seg, nsegs, ISES_B_DATASIZE,
	    &sc->sc_dma_data, 0)) {
		printf(": can't map dma buffer space\n");
		goto fail;
	}
	state++;

	printf(": %s\n", intrstr);

	bzero(&isesstats, sizeof(isesstats));

	sc->sc_cid = crypto_get_driverid(0);

	if (sc->sc_cid < 0)
		goto fail;

	/*
	 * Since none of the initialization steps generate interrupts
	 * for example, the hardware reset, we use a number of timeouts
	 * (or init states) to do the rest of the chip initialization.
	 */

	sc->sc_initstate = 0;
	startuphook_establish(ises_initstate, sc);

#ifdef ISESDEBUG
	ises_debug_init(sc);
#endif
	return;

 fail:
	switch (state) { /* Always fallthrough here. */
	case 5:
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)&sc->sc_dma_data,
		    sizeof sc->sc_dma_data);
		/* FALLTHROUGH */
	case 4:
		bus_dmamem_free(sc->sc_dmat, &seg, nsegs);
		/* FALLTHROUGH */
	case 3:
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_dmamap);
		/* FALLTHROUGH */
	case 2:
		pci_intr_disestablish(pc, sc->sc_ih);
		/* FALLTHROUGH */
	case 1:
		bus_space_unmap(sc->sc_memt, sc->sc_memh, memsize);
		/* FALLTHROUGH */
	default: /* 0 */
		break;
	}
	return;
}

void
ises_initstate(void *v)
{
	/*
	 * Step through chip initialization.
	 * sc->sc_initstate tells us what to do.
	 */
	extern int hz;
	struct ises_softc *sc = v;
	char *dv = sc->sc_dv.dv_xname;
	u_int32_t stat;
	int p, ticks, algs[CRYPTO_ALGORITHM_MAX + 1];
	static int retry_count = 0; /* XXX Should be in softc */

	ticks = hz * 3 / 2; /* 1.5s */ 

	p = ISES_STAT_IDP_STATE(READ_REG(sc, ISES_A_STAT));
	DPRINTF(("%s: initstate %d, IDP state is %d \"%s\"\n", dv, 
		  sc->sc_initstate, p, ises_idp_state[p]));

	switch (sc->sc_initstate) {
	case 0:
		/* Called by dostartuphooks(9). */
		timeout_set(&sc->sc_timeout, ises_initstate, sc);
		sc->sc_initstate++;

		/* FALLTHROUGH */
	case 1:
		/* Power up the chip (clear powerdown bit) */
		stat = READ_REG(sc, ISES_BO_STAT);
		if (stat & ISES_BO_STAT_POWERDOWN) {
			stat &= ~ISES_BO_STAT_POWERDOWN;
			WRITE_REG(sc, ISES_BO_STAT, stat);
			/* Selftests will take 1 second. */
			break;
		}
#if 1
		else {
			/* Power down the chip for sane init, then rerun. */
			stat |= ISES_BO_STAT_POWERDOWN;
			WRITE_REG(sc, ISES_BO_STAT, stat);
			sc->sc_initstate--; /* Rerun state 1. */
			break;
		}
#else
		/* FALLTHROUGH (chip is already powered up) */
		sc->sc_initstate++;
#endif

	case 2:
		/* Perform a hardware reset */
		stat = 0;

		printf ("%s: initializing...\n", dv);

		/* Clear all possible bypass bits. */
		for (p = 0; p < 128; p++)
			WRITE_REG(sc, ISES_B_BDATAOUT, 0L);

		stat |= ISES_BO_STAT_HWRESET;
		WRITE_REG(sc, ISES_BO_STAT, stat);
		stat &= ~ISES_BO_STAT_HWRESET;
		WRITE_REG(sc, ISES_BO_STAT, stat);
		/* Again, selftests will take 1 second. */
		break;

	case 3:
		/* Set AConf to zero, i.e 32-bits access to A-int. */
		stat = READ_REG(sc, ISES_BO_STAT);
		stat &= ~ISES_BO_STAT_ACONF;
		WRITE_REG(sc, ISES_BO_STAT, stat);

		/* Is the firmware already loaded? */
		if (READ_REG(sc, ISES_A_STAT) & ISES_STAT_HW_DA) {
			/* Yes it is, jump ahead a bit */
			ticks = 1;
			sc->sc_initstate += 3; /* Next step --> 7 */
			break;
		}

		/*
		 * Download the Basic Functionality firmware.
		 */

		p = ISES_STAT_IDP_STATE(READ_REG(sc, ISES_A_STAT));
		if (p == ISES_IDP_WFPL) {
			/* We're ready to download. */
			ticks = 1;
			sc->sc_initstate += 2; /* Next step --> 6 */
			break;
		}

		/*
		 * Prior to downloading we need to reset the NSRAM.
		 * Setting the tamper bit will erase the contents
		 * in 1 microsecond.
		 */
		stat = READ_REG(sc, ISES_BO_STAT);
		stat |= ISES_BO_STAT_TAMPER;
		WRITE_REG(sc, ISES_BO_STAT, stat);
		ticks = 1;
		break;

	case 4:
		/* After tamper bit has been set, powerdown chip. */
		stat = READ_REG(sc, ISES_BO_STAT);
		stat |= ISES_BO_STAT_POWERDOWN;
		WRITE_REG(sc, ISES_BO_STAT, stat);
		/* Wait one second for power to dissipate. */
		break;

	case 5:
		/* Clear tamper and powerdown bits. */
		stat = READ_REG(sc, ISES_BO_STAT);
		stat &= ~(ISES_BO_STAT_TAMPER | ISES_BO_STAT_POWERDOWN);
		WRITE_REG(sc, ISES_BO_STAT, stat);
		/* Again we need to wait a second for selftests. */
		break;

	case 6:
		/*
		 * We'll need some space in the input queue (IQF)
		 * and we need to be in the 'waiting for program
		 * length' IDP state (0x4).
		 */
		p = ISES_STAT_IDP_STATE(READ_REG(sc, ISES_A_STAT));
		if (READ_REG(sc, ISES_A_IQF) < 4 || p != ISES_IDP_WFPL) {
			if (retry_count++ < ISES_MAX_DOWNLOAD_RETRIES) {
				/* Retry download. */
				sc->sc_initstate -= 5; /* Next step --> 2 */
				ticks = 1;
				break;
			}
			retry_count = 0;
			printf("%s: cannot download firmware, "
			    "IDP state is \"%s\"\n", dv, ises_idp_state[p]);
			return;
		}

		/* Write firmware length */
		WRITE_REG(sc, ISES_A_IQD, ISES_BF_IDPLEN);

		/* Write firmware code */
		for (p = 0; p < sizeof(ises_bf_fw)/sizeof(u_int32_t); p++) {
			WRITE_REG(sc, ISES_A_IQD, ises_bf_fw[p]);
			if (READ_REG(sc, ISES_A_IQF) < 4)
				DELAY(10);
		}

		/* Write firmware CRC */
		WRITE_REG(sc, ISES_A_IQD, ISES_BF_IDPCRC);

		/* Wait 1s while chip resets and runs selftests */
		break;

	case 7:
		/* Did the download succed? */
		if (READ_REG(sc, ISES_A_STAT) & ISES_STAT_HW_DA) {
			ticks = 1;
			break;
		}

		/* We failed. */
		goto fail;

	case 8:
		if (ises_assert_cmd_mode(sc) < 0)
			goto fail;

		/*
		 * Now that the basic functionality firmware should be
		 * up and running, try to get the firmware version.
		 */

		stat = ises_get_fwversion(sc);
		if (stat == 0)
			goto fail;

		printf("%s: firmware v%d.%d loaded (%d bytes)", dv,
		    stat & 0xffff, (stat >> 16) & 0xffff, ISES_BF_IDPLEN << 2);

		/* We can use firmware versions 1.x & 2.x */
		switch (stat & 0xffff) {
		case 0:
			printf(" diagnostic, %s disabled\n", dv);
			goto fail;
		case 1: /* Basic Func "base" firmware */
		case 2: /* Basic Func "ipsec" firmware, no ADP code */
			break;
		default:
			printf(" unknown, %s disabled\n", dv);
			goto fail;
		}

		stat = READ_REG(sc, ISES_A_STAT);
		DPRINTF((", mode %s",
		    ises_sw_mode[ISES_STAT_SW_MODE(stat)]));

		/* Reuse the timeout for HRNG entropy collection. */
		timeout_del(&sc->sc_timeout);
		ises_hrng_init(sc);

		/* Set the interrupt mask */
		sc->sc_intrmask = ISES_STAT_BCHU_OAF | ISES_STAT_BCHU_ERR |
		    ISES_STAT_BCHU_OFHF | ISES_STAT_SW_OQSINC |
		    ISES_STAT_LNAU_BUSY_1 | ISES_STAT_LNAU_ERR_1 |
		    ISES_STAT_LNAU_BUSY_2 | ISES_STAT_LNAU_ERR_2;
#if 0
		    ISES_STAT_BCHU_ERR | ISES_STAT_BCHU_OAF |
		    ISES_STAT_BCHU_IFE | ISES_STAT_BCHU_IFHE |
		    ISES_STAT_BCHU_OFHF | ISES_STAT_BCHU_OFF;
#endif

		WRITE_REG(sc, ISES_A_INTE, sc->sc_intrmask);

		/* We're done. */
		printf("\n");

		/* Register ourselves with crypto framework. */
		bzero(algs, sizeof(algs));

		algs[CRYPTO_3DES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_DES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_MD5_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_SHA1_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_RIPEMD160_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;

		crypto_register(sc->sc_cid, algs,
		    ises_newsession, ises_freesession, ises_process);
		return;

	default:
		printf("%s: entered unknown initstate %d\n", dv,
		    sc->sc_initstate);
		goto fail;
	}

	/* Increment state counter and schedule next step in 'ticks' ticks. */
	sc->sc_initstate++;
	timeout_add(&sc->sc_timeout, ticks);
	return;

 fail:
	printf("%s: firmware failure\n", dv);
	timeout_del(&sc->sc_timeout);
	return;
}

/* Put a command on the A-interface queue. */
int
ises_queue_cmd(struct ises_softc *sc, u_int32_t cmd, u_int32_t *data, 
	       u_int32_t (*callback)(struct ises_softc *, struct ises_cmd *))
{
	struct ises_cmd *cq;
	int p, len, s, code;

	len = cmd >> 24;
	code = (cmd >> 16) & 0xFF;

#ifdef ISESDEBUG
	if (code != ISES_CMD_HBITS) /* ... since this happens 100 times/s */
		DPRINTF(("%s: queueing cmd 0x%x len %d\n", sc->sc_dv.dv_xname,
		    code, len));
#endif

	s = splnet();

	if (len > READ_REG(sc, ISES_A_IQF)) {
		splx(s);
		return (EAGAIN); /* XXX ENOMEM ? */
	}

	cq = malloc(sizeof(*cq), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (cq == NULL) {
		splx(s);
		isesstats.nomem++;
		return (ENOMEM);
	}
	cq->cmd_code = code;
	cq->cmd_cb = callback;
	cq->cmd_session = sc->sc_cursession;
	SIMPLEQ_INSERT_TAIL(&sc->sc_cmdq, cq, cmd_next);

	WRITE_REG(sc, ISES_A_IQD, cmd);

	/* LNAU register data should be written in reverse order */
	if ((code >= ISES_CMD_LW_A_1 && code <= ISES_CMD_LW_U_1) || /* LNAU1 */
	    (code >= ISES_CMD_LW_A_2 && code <= ISES_CMD_LW_U_2))   /* LNAU2 */
		for (p = len - 1; p >= 0; p--)
			WRITE_REG(sc, ISES_A_IQD, *(data + p));
	else
		for (p = 0; p < len; p++)
			WRITE_REG(sc, ISES_A_IQD, *(data + p));

	/* Signal 'command ready'. */
	WRITE_REG(sc, ISES_A_IQS, 0);

	splx(s);
	return (0);
}

/* Process all completed responses in the output queue. */
void
ises_process_oqueue(struct ises_softc *sc)
{
#ifdef ISESDEBUG
	char *dv = sc->sc_dv.dv_xname;
#endif
	struct ises_cmd *cq;
	struct ises_session *ses;
	u_int32_t oqs, r, d;
	int cmd, len, c, s;

	r = READ_REG(sc, ISES_A_OQS);
	if (r > 1)
		DPRINTF(("%s:process_oqueue: OQS=%d\n", dv, r));

	/* OQS gives us the number of responses we have to process. */
	while ((oqs = READ_REG(sc, ISES_A_OQS)) > 0) {
		/* Read command response. [ len(8) | cmd(8) | rc(16) ] */
		r = READ_REG(sc, ISES_A_OQD);
		len = (r >> 24);
		cmd = (r >> 16) & 0xff;
		r   = r & 0xffff;

		s = splnet();
		if (!SIMPLEQ_EMPTY(&sc->sc_cmdq)) {
			cq = SIMPLEQ_FIRST(&sc->sc_cmdq);
			SIMPLEQ_REMOVE_HEAD(&sc->sc_cmdq, cmd_next);
			cq->cmd_rlen = len;
		} else {
			cq = NULL;
			DPRINTF(("%s:process_oqueue: cmd queue empty!\n", dv));
		}
		splx(s);

		if (r) {
			/* Ouch. This command generated an error */
			DPRINTF(("%s:process_oqueue: cmd 0x%x err %d\n", dv, 
			    cmd, (r & ISES_RC_MASK)));
			/* Abort any running session switch to force a retry.*/
			sc->sc_switching = 0;
			/* Return to CMD mode. This will reset all queues. */
			(void)ises_assert_cmd_mode(sc);
		} else {
			/* Use specified callback, if any */
			if (cq && cq->cmd_cb) {
				if (cmd == cq->cmd_code) {
					cq->cmd_cb(sc, cq);
					cmd = ISES_CMD_NONE;
				} else {
					DPRINTF(("%s:process_oqueue: expected"
					    " cmd 0x%x, got 0x%x\n", dv, 
					    cq->cmd_code, cmd));
					/* XXX Some error handling here? */
				}
			}

			switch (cmd) {
			case ISES_CMD_NONE:
				break;

			case ISES_CMD_HBITS:
				/* XXX How about increasing the pool size? */
				/* XXX Use add_entropy_words instead? */
				/* XXX ... at proper spl */
				/* Cmd generated by ises_rng() via timeouts */
				while (len--) {
					d = READ_REG(sc, ISES_A_OQD);
					add_true_randomness(d);
				}
				break;

			case ISES_CMD_LUPLOAD_1:
				/* Get result of LNAU 1 operation. */
				DPRINTF(("%s:process_oqueue: LNAU 1 result "
				     "upload (len=%d)\n", dv, len));
				sc->sc_lnau1_rlen = len;
				bzero(sc->sc_lnau1_r, 2048 / 8);
				while (len--) {
					/* first word is LSW */
					sc->sc_lnau1_r[len] = 
					    READ_REG(sc, ISES_A_OQD);
				}
				break;

			case ISES_CMD_LUPLOAD_2:
				/* Get result of LNAU 1 operation. */
				DPRINTF(("%s:process_oqueue: LNAU 2 result "
				     "upload (len=%d)\n", dv, len));
				sc->sc_lnau2_rlen = len;
				bzero(sc->sc_lnau1_r, 2048 / 8);
				while (len--) {
					/* first word is LSW */
					sc->sc_lnau2_r[len] = 
					    READ_REG(sc, ISES_A_OQD);
				}
				break;

			case ISES_CMD_BR_OMR:
				ses = &sc->sc_sessions[cq->cmd_session];
				ses->omr = READ_REG(sc, ISES_A_OQD);
				DPRINTF(("%s:process_oqueue: read OMR[%08x]\n",
				    dv, ses->omr));
#ifdef ISESDEBUG
				ises_debug_parse_omr(sc);
#endif
				break;

			case ISES_CMD_BSWITCH:
				/* XXX Currently BSWITCH does not work. */
				DPRINTF(("%s:process_oqueue: BCHU_SWITCH\n"));
				/* Put switched BCHU session in cur session. */
				ses = &sc->sc_sessions[cq->cmd_session];
				for(c = 0; len > 0; len--, c++)
#if 0 /* Don't store the key, just drain the data */
					*((u_int32_t *)&ses + c) =
#endif
					    READ_REG(sc, ISES_A_OQD);

				sc->sc_switching = 0;
				ises_feed (sc);
				break;

			case ISES_CMD_BW_HMLR:
				/* XXX Obsoleted by ises_bchu_switch_final */
				DPRINTF(("%s:process_oqueue: CMD_BW_HMLR !?\n",
				    dv));
				break;

			default:
				/* All other are ok (no response data) */
				DPRINTF(("%s:process_oqueue cmd 0x%x len %d\n",
				    dv, cmd, len));
				if (cq && cq->cmd_cb) 
					len -= cq->cmd_cb(sc, cq);
			}
		}

		if (cq)
			free(cq, M_DEVBUF);
		
		/* This will drain any remaining data and ACK this reponse. */
		while (len-- > 0)
			d = READ_REG(sc, ISES_A_OQD);
		WRITE_REG(sc, ISES_A_OQS, 0);
		if (oqs > 1)
			DELAY(1); /* Wait for fw to decrement OQS (8 clocks) */
	}
}

int
ises_intr(void *arg)
{
	struct ises_softc *sc = arg;
	u_int32_t ints, dma_status, cmd; 
	char *dv = sc->sc_dv.dv_xname;

	dma_status = READ_REG(sc, ISES_DMA_STATUS);

	if (!(dma_status & (ISES_DMA_STATUS_R_ERR | ISES_DMA_STATUS_W_ERR))) {
		if ((sc->sc_dma_mask & ISES_DMA_STATUS_R_RUN) != 0 &&
		    (dma_status & ISES_DMA_STATUS_R_RUN) == 0) {
			DPRINTF(("%s: DMA read complete\n", dv));

			bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
			    sc->sc_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);

			/* XXX Pick up and return the data.*/

			WRITE_REG(sc, ISES_DMA_RESET, 0);
		}
		if ((sc->sc_dma_mask & ISES_DMA_STATUS_W_RUN) != 0 &&
		    (dma_status & ISES_DMA_STATUS_W_RUN) == 0) {
			DPRINTF(("%s: DMA write complete\n", dv));

			bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
			    sc->sc_dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);

			WRITE_REG(sc, ISES_DMA_RESET, 0);
			ises_feed(sc);
		}
	} else {
		printf ("%s: DMA error\n", dv);
		WRITE_REG(sc, ISES_DMA_RESET, 0);
	}

	ints = READ_REG(sc, ISES_A_INTS);
	if (!(ints & sc->sc_intrmask)) {
		DPRINTF (("%s: other intr mask [%08x]\n", ints));
		return (0); /* Not our interrupt. */
	}

	/* Clear all set intr bits. */
	WRITE_REG(sc, ISES_A_INTS, ints);

#if 0
	/* Check it we've got room for more data. */
	if (READ_REG(sc, ISES_A_STAT) &
	    (ISES_STAT_BCHU_IFE | ISES_STAT_BCHU_IFHE))
		ises_feed(sc);
#endif

	/* Does the A-intf output queue have data we need to process? */
	if (ints & ISES_STAT_SW_OQSINC)
		ises_process_oqueue(sc);

	if (ints & ISES_STAT_LNAU_BUSY_1) {
		DPRINTF(("%s:ises_intr: LNAU 1 job complete\n", dv));
		/* upload LNAU 1 result (into sc->sc_lnau1_r) */
		cmd = ISES_MKCMD(ISES_CMD_LUPLOAD_1, 0);
		ises_queue_cmd(sc, cmd, NULL, NULL);
	}

	if (ints & ISES_STAT_LNAU_BUSY_2) {
		DPRINTF(("%s:ises_intr: LNAU 2 job complete\n", dv));
		/* upload LNAU 2 result (into sc->sc_lnau2_r) */
		cmd = ISES_MKCMD(ISES_CMD_LUPLOAD_2, 0);
		ises_queue_cmd(sc, cmd, NULL, NULL);
	}

	if (ints & ISES_STAT_LNAU_ERR_1) {
		DPRINTF(("%s:ises_intr: LNAU 1 error\n", dv));
		sc->sc_lnau1_rlen = -1;
	}

	if (ints & ISES_STAT_LNAU_ERR_2) {
		DPRINTF(("%s:ises_intr: LNAU 2 error\n", dv));
		sc->sc_lnau2_rlen = -1;
	}

	if (ints & ISES_STAT_BCHU_OAF) {	/* output data available */
		DPRINTF(("%s:ises_intr: BCHU_OAF bit set\n", dv));
		/* Read DMA data from B-interface. */
		ises_read_dma (sc);
	}

	if (ints & ISES_STAT_BCHU_ERR) {	/* We got a BCHU error */
		DPRINTF(("%s:ises_intr: BCHU error\n", dv));
		/* XXX Error handling */
	}

	if (ints & ISES_STAT_BCHU_OFHF) {	/* Output is half full */
		DPRINTF(("%s:ises_intr: BCHU output FIFO half full\n", dv));
		/* XXX drain data? */
	}

#if 0 /* XXX Useful? */
	if (ints & ISES_STAT_BCHU_OFF) {	/* Output is full */
		/* XXX drain data / error handling? */
	}
#endif
	return (1);
}

int
ises_feed(struct ises_softc *sc)
{
	struct ises_q *q;
	bus_dma_segment_t *ds = &sc->sc_dmamap->dm_segs[0];
	u_int32_t dma_status;
	int s;
#ifdef ISESDEBUG
	char *dv = sc->sc_dv.dv_xname;
#endif

	DPRINTF(("%s:ises_feed: called (sc = %p)\n", dv, sc));
	DELAY(1000000);

	s = splnet();
	/* Anything to do? */
	if (SIMPLEQ_EMPTY(&sc->sc_queue) ||
	    (READ_REG(sc, ISES_A_STAT) & ISES_STAT_BCHU_IFF)) {
		splx(s);
		return (0);
	}

	/* Pick the first */
	q = SIMPLEQ_FIRST(&sc->sc_queue);
	splx(s);

	/* If we're currently switching sessions, we'll have to wait. */
	if (sc->sc_switching != 0) {
		DPRINTF(("%s:ises_feed: waiting for session switch\n", dv));
		return (0);
	}

	/* If on-chip data is not correct for this data, switch session. */
	if (sc->sc_cursession != q->q_sesn) {
		/* Session switch required */
		DPRINTF(("%s:ises_feed: initiating session switch\n", dv));
		if (ises_bchu_switch_session (sc, &q->q_session, q->q_sesn))
			sc->sc_cursession = q->q_sesn;
		else
			DPRINTF(("%s:ises_feed: session switch failed\n", dv));
		return (0);
	}

	DPRINTF(("%s:ises_feed: feed to chip (q = %p)\n", dv, q));
	DELAY(2000000);

	s = splnet();
	SIMPLEQ_REMOVE_HEAD(&sc->sc_queue, q_next);
	SIMPLEQ_INSERT_TAIL(&sc->sc_qchip, q, q_next);
	--sc->sc_nqueue;
	splx(s);

	if (q->q_crp->crp_flags & CRYPTO_F_IMBUF)
		bus_dmamap_load_mbuf(sc->sc_dmat, sc->sc_dmamap, 
		    q->q_src.mbuf, BUS_DMA_NOWAIT);
	else if (q->q_crp->crp_flags & CRYPTO_F_IOV)
		bus_dmamap_load_uio(sc->sc_dmat, sc->sc_dmamap, q->q_src.uio,
		    BUS_DMA_NOWAIT);
	/* ... else */	

	/* Start writing data to the ises. */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
	    sc->sc_dmamap->dm_mapsize, BUS_DMASYNC_PREWRITE);
	
	DPRINTF(("%s:ises_feed: writing DMA\n", dv));
	DELAY(1000000);

	sc->sc_dma_mask |= ISES_DMA_STATUS_W_RUN;

	WRITE_REG(sc, ISES_DMA_WRITE_START, ds->ds_addr);
	WRITE_REG(sc, ISES_DMA_WRITE_COUNT, ISES_DMA_WCOUNT(ds->ds_len));

	dma_status = READ_REG(sc, ISES_DMA_STATUS);
	dma_status |= ISES_DMA_CTRL_ILT | ISES_DMA_CTRL_RLINE;
	WRITE_REG(sc, ISES_DMA_CTRL, dma_status);

	DPRINTF(("%s:ises_feed: done\n", dv));
	return (0);
}

/*
 * Allocate a new 'session' and return an encoded session id.  'sidp'
 * contains our registration id, and should contain an encoded session
 * id on successful allocation.
 */
int
ises_newsession(u_int32_t *sidp, struct cryptoini *cri)
{
	struct cryptoini *c, *mac = NULL, *enc = NULL;
	struct ises_softc *sc = NULL;
	struct ises_session *ses;
	MD5_CTX	   md5ctx;
	SHA1_CTX   sha1ctx;
	RMD160_CTX rmd160ctx;
	int i, sesn;
#ifdef ISESDEBUG
	char *dv;
#endif

	if (sidp == NULL || cri == NULL)
		return (EINVAL);

	for (i = 0; i < ises_cd.cd_ndevs; i++) {
		sc = ises_cd.cd_devs[i];
		if (sc == NULL || sc->sc_cid == (*sidp))
			break;
	}
	if (sc == NULL)
		return (EINVAL);
#ifdef ISESDEBUG
	dv = sc->sc_dv.dv_xname;
#endif

	DPRINTF(("%s:ises_newsession: start\n", dv));

	for (c = cri; c != NULL; c = c->cri_next) {
		if (c->cri_alg == CRYPTO_MD5_HMAC ||
		    c->cri_alg == CRYPTO_SHA1_HMAC ||
		    c->cri_alg == CRYPTO_RIPEMD160_HMAC) {
			if (mac)
				return (EINVAL);
			mac = c;
		} else if (c->cri_alg == CRYPTO_DES_CBC ||
		    c->cri_alg == CRYPTO_3DES_CBC) {
			if (enc)
				return (EINVAL);
			enc = c;
		} else
			return (EINVAL);
	}
	if (mac == 0 && enc == 0)
		return (EINVAL);

#ifdef ISESDEBUG
	printf ("%s:ises_newsession: mac=%p(%d) enc=%p(%d)\n",
	   dv, mac, (mac ? mac->cri_alg : -1), enc, (enc ? enc->cri_alg : -1));
#endif

	/* Allocate a new session */
	if (sc->sc_sessions == NULL) {
		ses = sc->sc_sessions = (struct ises_session *)
		    malloc(sizeof(struct ises_session), M_DEVBUF, M_NOWAIT);
		if (ses == NULL) {
			isesstats.nomem++;
			return (ENOMEM);
		}
		sc->sc_cursession = -1;
		sesn = 0;
		sc->sc_nsessions = 1;
	} else {
		ses = NULL;
		for (sesn = 0; sesn < sc->sc_nsessions; sesn++)
			if (sc->sc_sessions[sesn].omr == 0) {
				ses = &sc->sc_sessions[sesn];
				sc->sc_cursession = sesn;
				break;
			}

		if (ses == NULL) {
			i = sc->sc_nsessions * sizeof(struct ises_session);
			ses = (struct ises_session *)
			    malloc(i + sizeof(struct ises_session), M_DEVBUF,
			    M_NOWAIT);
			if (ses == NULL) {
				isesstats.nomem++;
				return (ENOMEM);
			}

			bcopy(sc->sc_sessions, ses, i);
			bzero(sc->sc_sessions, i);
			free(sc->sc_sessions, M_DEVBUF);
			sc->sc_sessions = ses;
			ses = &sc->sc_sessions[sc->sc_nsessions];
			sc->sc_cursession = sc->sc_nsessions;
			sc->sc_nsessions++;
		}
	}

	DPRINTF(("%s:ises_newsession: nsessions=%d cursession=%d\n", dv,
	    sc->sc_nsessions, sc->sc_cursession));

	bzero(ses, sizeof(struct ises_session));

	/* Select data path through B-interface. */
	ses->omr |= ISES_SELR_BCHU_DIS;

	if (enc) {
		/* get an IV, network byte order */
		/* XXX switch to using builtin HRNG ! */
		arc4random_bytes(ses->sccr, sizeof(ses->sccr));

		/* crypto key */
		if (enc->cri_alg == CRYPTO_DES_CBC) {
			bcopy(enc->cri_key, &ses->kr[0], 8);
			bcopy(enc->cri_key, &ses->kr[2], 8);
			bcopy(enc->cri_key, &ses->kr[4], 8);
		} else
			bcopy(enc->cri_key, &ses->kr[0], 24);

		SWAP32(ses->kr[0]);
		SWAP32(ses->kr[1]);
		SWAP32(ses->kr[2]);
		SWAP32(ses->kr[3]);
		SWAP32(ses->kr[4]);
		SWAP32(ses->kr[5]);
	}

	if (mac) {
		for (i = 0; i < mac->cri_klen / 8; i++)
			mac->cri_key[i] ^= HMAC_IPAD_VAL;

		switch (mac->cri_alg) {
		case CRYPTO_MD5_HMAC:
			MD5Init(&md5ctx);
			MD5Update(&md5ctx, mac->cri_key, mac->cri_klen / 8);
			MD5Update(&md5ctx, hmac_ipad_buffer, HMAC_BLOCK_LEN -
			    (mac->cri_klen / 8));
			MD5Final((u_int8_t *)&ses->cvr, &md5ctx);
			break;
		case CRYPTO_SHA1_HMAC:
			SHA1Init(&sha1ctx);
			SHA1Update(&sha1ctx, mac->cri_key, mac->cri_klen / 8);
			SHA1Update(&sha1ctx, hmac_ipad_buffer, HMAC_BLOCK_LEN -
			    (mac->cri_klen / 8));
			SHA1Final((u_int8_t *)ses->cvr, &sha1ctx);
			break;
		case CRYPTO_RIPEMD160_HMAC:
		default:
			RMD160Init(&rmd160ctx);
			RMD160Update(&rmd160ctx, mac->cri_key,
			    mac->cri_klen / 8);
			RMD160Update(&rmd160ctx, hmac_ipad_buffer,
			    HMAC_BLOCK_LEN - (mac->cri_klen / 8));
			RMD160Final((u_int8_t *)ses->cvr, &rmd160ctx);
			break;
		}

		for (i = 0; i < mac->cri_klen / 8; i++)
			mac->cri_key[i] ^= (HMAC_IPAD_VAL ^ HMAC_OPAD_VAL);

		switch (mac->cri_alg) {
		case CRYPTO_MD5_HMAC:
			MD5Init(&md5ctx);
			MD5Update(&md5ctx, mac->cri_key, mac->cri_klen / 8);
			MD5Update(&md5ctx, hmac_opad_buffer, HMAC_BLOCK_LEN -
			    (mac->cri_klen / 8));
			MD5Update(&md5ctx, (u_int8_t *)ses->cvr,
			    sizeof(md5ctx.state));
			MD5Final((u_int8_t *)ses->cvr, &md5ctx);
			break;
		case CRYPTO_SHA1_HMAC:
			SHA1Init(&sha1ctx);
			SHA1Update(&sha1ctx, mac->cri_key, mac->cri_klen / 8);
			SHA1Update(&sha1ctx, hmac_opad_buffer, HMAC_BLOCK_LEN -
			    (mac->cri_klen / 8));
			SHA1Update(&sha1ctx, (u_int8_t *)ses->cvr,
			    sizeof(sha1ctx.state));
			SHA1Final((u_int8_t *)ses->cvr, &sha1ctx);
			break;
		case CRYPTO_RIPEMD160_HMAC:
		default:
			RMD160Init(&rmd160ctx);
			RMD160Update(&rmd160ctx, mac->cri_key,
			    mac->cri_klen / 8);
			RMD160Update(&rmd160ctx, hmac_opad_buffer,
			    HMAC_BLOCK_LEN - (mac->cri_klen / 8));
			RMD160Update(&rmd160ctx, (u_int8_t *)ses->cvr, 
			    sizeof(rmd160ctx.state));
			RMD160Final((u_int8_t *)ses->cvr, &rmd160ctx);
			break;
		}

		for (i = 0; i < mac->cri_klen / 8; i++)
			mac->cri_key[i] ^= HMAC_OPAD_VAL;
	}

	DPRINTF(("%s:ises_newsession: done\n", dv));
	*sidp = ISES_SID(sc->sc_dv.dv_unit, sesn);
	return (0);
}

/* Deallocate a session. */
int
ises_freesession(u_int64_t tsid)
{
	struct ises_softc *sc;
	int card, sesn;
	u_int32_t sid = ((u_int32_t)tsid) & 0xffffffff;

	card = ISES_CARD(sid);
	if (card >= ises_cd.cd_ndevs || ises_cd.cd_devs[card] == NULL)
		return (EINVAL);

	sc = ises_cd.cd_devs[card];
	sesn = ISES_SESSION(sid);

	DPRINTF(("%s:ises_freesession: freeing session %d\n",
	    sc->sc_dv.dv_xname, sesn));

	if (sc->sc_cursession == sesn)
		sc->sc_cursession = -1;

	bzero(&sc->sc_sessions[sesn], sizeof(sc->sc_sessions[sesn]));

	return (0);
}

/* Called by the crypto framework, crypto(9). */
int
ises_process(struct cryptop *crp)
{
	struct ises_softc *sc;
	struct ises_q *q;
	struct cryptodesc *maccrd, *enccrd, *crd;
	struct ises_session *ses;
	int card, s, err = EINVAL;
	int encoffset, macoffset, cpskip, sskip, dskip, stheend, dtheend;
	int cpoffset, coffset;
#if 0
	int nicealign;
#endif
#ifdef ISESDEBUG
	char *dv;
#endif

	if (crp == NULL || crp->crp_callback == NULL)
		return (EINVAL);

	card = ISES_CARD(crp->crp_sid);
	if (card >= ises_cd.cd_ndevs || ises_cd.cd_devs[card] == NULL)
		goto errout;

	sc = ises_cd.cd_devs[card];
#ifdef ISESDEBUG
	dv = sc->sc_dv.dv_xname;
#endif

	DPRINTF(("%s:ises_process: start (crp = %p)\n", dv, crp));

	s = splnet();
	if (sc->sc_nqueue == ISES_MAX_NQUEUE) {
		splx(s);
		goto memerr;
	}
	splx(s);

	q = malloc(sizeof(*q), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (q == NULL)
		goto memerr;

	q->q_sesn = ISES_SESSION(crp->crp_sid);
	ses = &sc->sc_sessions[q->q_sesn];

	DPRINTF(("%s:ises_process: session %d selected\n", dv, q->q_sesn));

	q->q_sc = sc;
	q->q_crp = crp;

	if (crp->crp_flags & CRYPTO_F_IMBUF) {
		q->q_src.mbuf = (struct mbuf *)crp->crp_buf;
		q->q_dst.mbuf = (struct mbuf *)crp->crp_buf;
	} else if (crp->crp_flags & CRYPTO_F_IOV) {
		q->q_src.uio = (struct uio *)crp->crp_buf;
		q->q_dst.uio = (struct uio *)crp->crp_buf;
	} else {
		/* XXX for now... */
		goto errout;
	}

	/*
	 * Check if the crypto descriptors are sane. We accept:
	 * - just one crd; either auth or crypto
	 * - two crds; must be one auth and one crypto, although now
	 *   for encryption we only want the first to be crypto, while
	 *   for decryption the second one should be crypto.
	 */
	maccrd = enccrd = NULL;
	for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
		switch (crd->crd_alg) {
		case CRYPTO_MD5_HMAC:
		case CRYPTO_SHA1_HMAC:
		case CRYPTO_RIPEMD160_HMAC:
			if (maccrd || (enccrd &&
			    (enccrd->crd_flags & CRD_F_ENCRYPT) == 0))
				goto errout;
			maccrd = crd;
			break;
		case CRYPTO_DES_CBC:
		case CRYPTO_3DES_CBC:
			if (enccrd ||
			    (maccrd && (crd->crd_flags & CRD_F_ENCRYPT)))
				goto errout;
			enccrd = crd;
			break;
		default:
			goto errout;
		}
	}
	if (!maccrd && !enccrd)
		goto errout;

	DPRINTF(("%s:ises_process: enc=%p mac=%p\n", dv, enccrd, maccrd));

	/* Select data path through B-interface. */
	q->q_session.omr |= ISES_SELR_BCHU_DIS;

	if (enccrd) {
		encoffset = enccrd->crd_skip;

		/* Select algorithm */
		if (enccrd->crd_alg == CRYPTO_3DES_CBC)
			q->q_session.omr |= ISES_SOMR_BOMR_3DES;
		else
			q->q_session.omr |= ISES_SOMR_BOMR_DES;

		/* Set CBC mode */
		q->q_session.omr |= ISES_SOMR_FMR_CBC;

		if (enccrd->crd_flags & CRD_F_ENCRYPT) {
			/* Set encryption bit */
			q->q_session.omr |= ISES_SOMR_EDR;

			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
				bcopy(enccrd->crd_iv, q->q_session.sccr, 8);
			else {
				q->q_session.sccr[0] = ses->sccr[0];
				q->q_session.sccr[1] = ses->sccr[1];
			}

			if ((enccrd->crd_flags & CRD_F_IV_PRESENT) == 0) {
				if (crp->crp_flags & CRYPTO_F_IMBUF)
					m_copyback(q->q_src.mbuf,
					    enccrd->crd_inject, 8,
					    (caddr_t)q->q_session.sccr);
				else if (crp->crp_flags & CRYPTO_F_IOV)
					cuio_copyback(q->q_src.uio,
					    enccrd->crd_inject, 8,
					    (caddr_t)q->q_session.sccr);
				/* XXX else ... */
			}
		} else {
			/* Clear encryption bit == decrypt mode */
			q->q_session.omr &= ~ISES_SOMR_EDR;

			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
				bcopy(enccrd->crd_iv, q->q_session.sccr, 8);
			else if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copydata(q->q_src.mbuf, enccrd->crd_inject,
				    8, (caddr_t)q->q_session.sccr);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copydata(q->q_src.uio,
				    enccrd->crd_inject, 8,
				    (caddr_t)q->q_session.sccr);
			/* XXX else ... */
		}

		q->q_session.kr[0] = ses->kr[0];
		q->q_session.kr[1] = ses->kr[1];
		q->q_session.kr[2] = ses->kr[2];
		q->q_session.kr[3] = ses->kr[3];
		q->q_session.kr[4] = ses->kr[4];
		q->q_session.kr[5] = ses->kr[5];

		SWAP32(q->q_session.sccr[0]);
		SWAP32(q->q_session.sccr[1]);
	}

	if (maccrd) {
		macoffset = maccrd->crd_skip;

		/* Select algorithm */
		switch (crd->crd_alg) {
		case CRYPTO_MD5_HMAC:
			q->q_session.omr |= ISES_HOMR_HFR_MD5;
			break;
		case CRYPTO_SHA1_HMAC:
			q->q_session.omr |= ISES_HOMR_HFR_SHA1;
			break;
		case CRYPTO_RIPEMD160_HMAC:
		default:
			q->q_session.omr |= ISES_HOMR_HFR_RMD160;
			break;
		}

		q->q_session.cvr[0] = ses->cvr[0];
		q->q_session.cvr[1] = ses->cvr[1];
		q->q_session.cvr[2] = ses->cvr[2];
		q->q_session.cvr[3] = ses->cvr[3];
		q->q_session.cvr[4] = ses->cvr[4];
	}

	if (enccrd && maccrd) {
		/* XXX Check if ises handles differing end of auth/enc etc */
		/* XXX For now, assume not (same as ubsec). */
		if (((encoffset + enccrd->crd_len) !=
		    (macoffset + maccrd->crd_len)) ||
		    (enccrd->crd_skip < maccrd->crd_skip)) {
			goto errout;
		}

		sskip = maccrd->crd_skip;
		cpskip = dskip = enccrd->crd_skip;
		stheend = maccrd->crd_len;
		dtheend = enccrd->crd_len;
		coffset = cpskip - sskip;
		cpoffset = cpskip + dtheend;
		/* XXX DEBUG ? */
	} else {
		cpskip = dskip = sskip = macoffset + encoffset;
		dtheend = enccrd ? enccrd->crd_len : maccrd->crd_len;
		stheend = dtheend;
		cpoffset = cpskip + dtheend;
		coffset = 0;
	}
	q->q_offset = coffset >> 2;

#if 0	/* XXX not sure about this, in bus_dma context */

	if (crp->crp_flags & CRYPTO_F_IMBUF)
		q->q_src_l = mbuf2pages(q->q_src.mbuf, &q->q_src_npa,
		    q->q_src_packp, q->q_src_packl, 1, &nicealign);
	else if (crp->crp_flags & CRYPTO_F_IOV)
		q->q_src_l = iov2pages(q->q_src.uio, &q->q_src_npa,
		    q->q_src_packp, q->q_src_packl, 1, &nicealign);
	/* XXX else */

	DPRINTF(("%s:ises_process: foo2pages called!\n", dv));

	if (q->q_src_l == 0)
		goto memerr;
	else if (q->q_src_l > 0xfffc) {
		err = EIO;
		goto errout;
	}

	/* XXX ... */

	if (enccrd == NULL && maccrd != NULL) {
		/* XXX ... */
	} else {
		if (!nicealign && (crp->crp_flags & CRYPTO_F_IOV)) {
			goto errout;
		} else if (!nicealign && (crp->crp_flags & CRYPTO_F_IMBUF)) {
			int totlen, len;
			struct mbuf *m, *top, **mp;

			totlen = q->q_dst_l = q->q_src_l;
			if (q->q_src.mbuf->m_flags & M_PKTHDR) {
				MGETHDR(m, M_DONTWAIT, MT_DATA);
				M_DUP_PKTHDR(m, q->q_src.mbuf);
				len = MHLEN;
			} else {
				MGET(m, M_DONTWAIT, MT_DATA);
				len = MLEN;
			}
			if (m == NULL)
				goto memerr;
			if (totlen >= MINCLSIZE) {
				MCLGET(m, M_DONTWAIT);
				if (m->m_flags & M_EXT)
					len = MCLBYTES;
			}
			m->m_len = len;
			top = NULL;
			mp = &top;

			while (totlen > 0) {
				if (top) {
					MGET(m, M_DONTWAIT, MT_DATA);
					if (m == NULL) {
						m_freem(top);
						goto memerr;
					}
					len = MLEN;
				}
				if (top && totlen >= MINCLSIZE) {
					MCLGET(m, M_DONTWAIT);
					if (m->m_flags & M_EXT)
						len = MCLBYTES;
				}
				m->m_len = len = min(totlen, len);
				totlen -= len;
				*mp = m;

				mp = &m->m_next;
			}
			q->q_dst.mbuf = top;
#if notyet
			ubsec_mcopy(q->q_src.mbuf, q->q_dst.mbuf, cpskip, cpoffset);
#endif
		} else
			q->q_dst.mbuf = q->q_src.mbuf;

#if 0
		/* XXX ? */
		q->q_dst_l = mbuf2pages(q->q_dst.mbuf, &q->q_dst_npa,
		    &q->q_dst_packp, &q->q_dst_packl, 1, NULL);
#endif
	}

#endif /* XXX */

	DPRINTF(("%s:ises_process: queueing request\n", dv));

	s = splnet();
	SIMPLEQ_INSERT_TAIL(&sc->sc_queue, q, q_next);
	sc->sc_nqueue++;
	splx(s);
	ises_feed(sc);

	return (0);

memerr:
	err = ENOMEM;
	isesstats.nomem++;
errout:
	DPRINTF(("%s:ises_process: an error occurred, err=%d, q=%p\n", dv, 
		 err, q));

	if (err == EINVAL)
		isesstats.invalid++;

	if (q) {
		if (q->q_src.mbuf != q->q_dst.mbuf)
			m_freem(q->q_dst.mbuf);
		free(q, M_DEVBUF);
	}
	crp->crp_etype = err;
	crypto_done(crp);
	return (0);
}

void
ises_callback(struct ises_q *q)
{
	struct cryptop *crp = (struct cryptop *)q->q_crp;
	struct cryptodesc *crd;
	struct ises_softc *sc = q->q_sc;
	u_int8_t *sccr;

	if ((crp->crp_flags & CRYPTO_F_IMBUF) && 
	    (q->q_src.mbuf != q->q_dst.mbuf)) {
		m_freem(q->q_src.mbuf);
		crp->crp_buf = (caddr_t)q->q_dst.mbuf;
	}

	if (q->q_session.omr & ISES_SOMR_EDR) {
		/* Copy out IV after encryption. */
		sccr = (u_int8_t *)&sc->sc_sessions[q->q_sesn].sccr;
		for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
			if (crd->crd_alg != CRYPTO_DES_CBC &&
			    crd->crd_alg != CRYPTO_3DES_CBC)
				continue;
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copydata((struct mbuf *)crp->crp_buf,
				    crd->crd_skip + crd->crd_len - 8, 8, sccr);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copydata((struct uio *)crp->crp_buf,
				    crd->crd_skip + crd->crd_len - 8, 8, sccr);
		}
	}

	for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
		if (crd->crd_alg != CRYPTO_MD5_HMAC &&
		    crd->crd_alg != CRYPTO_SHA1_HMAC &&
		    crd->crd_alg != CRYPTO_RIPEMD160_HMAC)
			continue;
		if (crp->crp_flags & CRYPTO_F_IMBUF)
			m_copyback((struct mbuf *)crp->crp_buf,
			   crd->crd_inject, 12, (u_int8_t *)q->q_macbuf);
		else if (crp->crp_flags & CRYPTO_F_IOV)
			bcopy((u_int8_t *)q->q_macbuf, crp->crp_mac, 12);
		/* XXX else ... */
		break;
	}

	free(q, M_DEVBUF);
	DPRINTF(("%s:ises_callback: calling crypto_done\n",
	    sc->sc_dv.dv_xname));
	crypto_done(crp);
}

/* Initilize the ISES hardware RNG, and set up timeouts. */
void
ises_hrng_init(struct ises_softc *sc)
{
	u_int32_t cmd, r;
	int i;
#ifdef ISESDEBUG
	struct timeval tv1, tv2;
#endif

	/* Asking for random data will seed LFSR and start the RBG */
	cmd = ISES_MKCMD(ISES_CMD_HBITS, 1);
	r   = 8; /* 8 * 32 = 256 bits */

	if (ises_queue_cmd(sc, cmd, &r, NULL))
		return;

	/* Wait until response arrives. */
	for (i = 1000; i && READ_REG(sc, ISES_A_OQS) == 0; i--)
		DELAY(10);

	if (!READ_REG(sc, ISES_A_OQS))
		return;

	/* Drain cmd response and 8*32 bits data */
	for (i = 0; i <= r; i++)
		(void)READ_REG(sc, ISES_A_OQD);

	/* ACK the response */
	WRITE_REG(sc, ISES_A_OQS, 0);
	DELAY(1);
	printf(", rng active");

#ifdef ISESDEBUG
	/* Benchmark the HRNG. */

	/*
	 * XXX These values gets surprisingly large. Docs state the
	 * HNRG produces > 1 mbit/s of random data. The values I'm seeing
	 * are much higher, ca 2.7-2.8 mbit/s. AFAICT the algorithm is sound.
	 * Compiler optimization issues, perhaps?
	 */

#define ISES_WPR 250
#define ISES_ROUNDS 100
	cmd = ISES_MKCMD(ISES_CMD_HBITS, 1);
	r = ISES_WPR;

	/* Queue 100 cmds; each generate 250 32-bit words of rnd data. */
	microtime(&tv1);
	for (i = 0; i < ISES_ROUNDS; i++)
		ises_queue_cmd(sc, cmd, &r, NULL);
	for (i = 0; i < ISES_ROUNDS; i++) {
		while (READ_REG(sc, ISES_A_OQS) == 0) ; /* Wait for response */

		(void)READ_REG(sc, ISES_A_OQD);		/* read response */
		for (r = ISES_WPR; r--;)
			(void)READ_REG(sc, ISES_A_OQD);	/* read data */
		WRITE_REG(sc, ISES_A_OQS, 0);		/* ACK resp */
		DELAY(1); /* OQS needs 1us to decrement */
	}
	microtime(&tv2);

	timersub(&tv2, &tv1, &tv1);
	tv1.tv_usec += 1000000 * tv1.tv_sec;
	printf(", %dKb/sec",
	    ISES_WPR * ISES_ROUNDS * 32 / 1024 * 1000000 / tv1.tv_usec);
#endif

	timeout_set(&sc->sc_timeout, ises_hrng, sc);
#ifndef ISES_HRNG_DISABLED
	ises_hrng(sc); /* Call first update */
#endif
}

/* Called by timeout (and once by ises_init_hrng()). */
void
ises_hrng(void *v)
{
	/*
	 * Throw a HRNG read random bits command on the command queue.
	 * The normal loop will manage the result and add it to the pool.
	 */
	struct ises_softc *sc = v;
	u_int32_t cmd, n;
	extern int hz; /* from param.c */

	timeout_add(&sc->sc_timeout, hz / ISESRNGIPS);

	if (ises_assert_cmd_mode(sc) != 0)
		return;

	cmd = ISES_MKCMD(ISES_CMD_HBITS, 1);
	n   = (ISESRNGBITS >> 5) & 0xff; /* ask for N 32 bit words */

	ises_queue_cmd(sc, cmd, &n, NULL);
}

u_int32_t
ises_get_fwversion(struct ises_softc *sc)
{
	u_int32_t r;
	int i;

	r = ISES_MKCMD(ISES_CMD_CHIP_ID, 0);
	WRITE_REG(sc, ISES_A_IQD, r);
	WRITE_REG(sc, ISES_A_IQS, 0);

	for (i = 100; i > 0 && READ_REG(sc, ISES_A_OQS) == 0; i--)
		DELAY(1);

	if (i < 1)
		return (0); /* No response */

	r = READ_REG(sc, ISES_A_OQD);

	/* Check validity. On error drain reponse data. */
	if (((r >> 16) & 0xff) != ISES_CMD_CHIP_ID ||
	    ((r >> 24) & 0xff) != 3 || (r & ISES_RC_MASK) != ISES_RC_SUCCESS) {
		if ((r & ISES_RC_MASK) == ISES_RC_SUCCESS)
			for (i = ((r >> 24) & 0xff); i; i--)
				(void)READ_REG(sc, ISES_A_OQD);
		r = 0;
		goto out;
	}

	r = READ_REG(sc, ISES_A_OQD); /* read version */
	(void)READ_REG(sc, ISES_A_OQD); /* Discard 64bit "chip-id" */
	(void)READ_REG(sc, ISES_A_OQD);
 out:
	WRITE_REG(sc, ISES_A_OQS, 0); /* Ack the response */
	DELAY(1);
	return (r);
}

/*
 * ises_assert_cmd_mode() returns
 *   -1 for failure to go to cmd
 *    0 if mode already was cmd
 *   >0 if mode was other (WFC/WFR) but now is cmd (this has reset the queues)
 */
int
ises_assert_cmd_mode(struct ises_softc *sc)
{
	switch (ISES_STAT_SW_MODE(READ_REG(sc, ISES_A_STAT))) {
	case 0x0: /* Selftest. XXX This is a transient state. */
		DELAY(1000000);
		if (ISES_STAT_SW_MODE(READ_REG(sc, ISES_A_STAT)) == 0)
			return (-1);
		return (ises_assert_cmd_mode(sc));
	case 0x1: /* Command mode */
		return (0);
	case 0x2: /* Waiting For Continue / WFC */
		bus_space_write_2(sc->sc_memt, sc->sc_memh, ISES_A_CTRL,
		    ISES_A_CTRL_CONTINUE);
		DELAY(1);
		return ((ISES_STAT_SW_MODE(READ_REG(sc, ISES_A_STAT)) == 0) ?
		    1 : -1);
	case 0x3: /* Waiting For Reset / WFR */
		bus_space_write_2(sc->sc_memt, sc->sc_memh, ISES_A_CTRL,
		    ISES_A_CTRL_RESET);
		DELAY(1000000);
		return ((ISES_STAT_SW_MODE(READ_REG(sc, ISES_A_STAT)) == 0) ?
		    2 : -1);
	default:
		return (-1); /* Unknown mode */
	}
}

int
ises_bchu_switch_session (struct ises_softc *sc, struct ises_session *ss, 
			  int new_session)
{
	/* It appears that the BCHU_SWITCH_SESSION command is broken. */
	/* We have to work around it. */
	
	u_int32_t cmd;

	/* Do we have enough in-queue space? Count cmds + data, 16bit words. */
	if ((8 * 2 + sizeof (*ss) / 2) > READ_REG(sc, ISES_A_IQF))
		return (0);

	/* Mark 'switch' in progress. */
	sc->sc_switching = new_session + 1;

	/* Write the key. */
	cmd = ISES_MKCMD(ISES_CMD_BW_KR0, 2);
	ises_queue_cmd(sc, cmd, &ss->kr[4], NULL);
	cmd = ISES_MKCMD(ISES_CMD_BW_KR1, 2);
	ises_queue_cmd(sc, cmd, &ss->kr[2], NULL);
	cmd = ISES_MKCMD(ISES_CMD_BW_KR2, 2);
	ises_queue_cmd(sc, cmd, &ss->kr[0], NULL);

	/* Write OMR - Operation Method Register, clears SCCR+CVR+DBCR+HMLR */
	cmd = ISES_MKCMD(ISES_CMD_BW_OMR, 1);
	ises_queue_cmd(sc, cmd, &ss->omr, NULL);

	/* Write SCCR - Symmetric Crypto Chaining Register (IV) */
	cmd = ISES_MKCMD(ISES_CMD_BW_SCCR, 2);
	ises_queue_cmd(sc, cmd, &ss->sccr[0], NULL);

	/* Write CVR - Chaining Variables Register (hash state) */
	cmd = ISES_MKCMD(ISES_CMD_BW_CVR, 5);
	ises_queue_cmd(sc, cmd, &ss->cvr[0], NULL);

	/* Write DBCR - Data Block Count Register */
	cmd = ISES_MKCMD(ISES_CMD_BW_DBCR, 2);
	ises_queue_cmd(sc, cmd, &ss->dbcr[0], NULL);

	/* Write HMLR - Hash Message Length Register - last cmd in switch */
	cmd = ISES_MKCMD(ISES_CMD_BW_HMLR, 2);
	ises_queue_cmd(sc, cmd, &ss->hmlr[0], ises_bchu_switch_final);

	return (1);
}

u_int32_t
ises_bchu_switch_final (struct ises_softc *sc, struct ises_cmd *cmd)
{
	/* Session switch is complete. */

	DPRINTF(("%s:ises_bchu_switch_final: switch complete\n",
	    sc->sc_dv.dv_xname));

	sc->sc_cursession = sc->sc_switching - 1;
	sc->sc_switching = 0;

	/* Retry/restart feed. */
	ises_feed(sc);

	return (0);
}

/* XXX Currently unused. */
void
ises_read_dma (struct ises_softc *sc)
{
	bus_dma_segment_t *ds = &sc->sc_dmamap->dm_segs[0];
	u_int32_t dma_status;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
	    sc->sc_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);

	WRITE_REG(sc, ISES_DMA_READ_START, ds->ds_addr);
	WRITE_REG(sc, ISES_DMA_READ_START, ISES_DMA_RCOUNT(ds->ds_len));

	dma_status = READ_REG(sc, ISES_DMA_STATUS);
	dma_status |= ISES_DMA_CTRL_ILT | ISES_DMA_CTRL_WRITE;
	WRITE_REG(sc, ISES_DMA_CTRL, dma_status);
}

#ifdef ISESDEBUG
/*
 * Development code section below here.
 */

void
ises_debug_init (struct ises_softc *sc)
{
	ises_sc = sc;
	ises_db = 0;
	timeout_set (&ises_db_timeout, ises_debug_loop, sc);
	timeout_add (&ises_db_timeout, 100);
	printf ("ises0: ISESDEBUG active (ises_sc = %p)\n", ises_sc);
}

void
ises_debug_2 (void)
{
	timeout_set (&ises_db_timeout, ises_debug_loop, ises_sc);
	timeout_add (&ises_db_timeout, 100);
	printf ("ises0: another debug timeout scheduled!\n");
}

void
ises_debug_simple_cmd (struct ises_softc *sc, u_int32_t code, u_int32_t d)
{
	u_int32_t cmd, data;
	
	cmd = ISES_MKCMD(code, (d ? 1 : 0));
	data = d;
	ises_queue_cmd(sc, cmd, &d, NULL);
}

void
ises_debug_loop (void *v)
{
	struct ises_softc *sc = (struct ises_softc *)v;
	struct ises_session ses;
	u_int32_t cmd, stat;
	int i;

	if (ises_db)
		printf ("ises0: ises_db = %d  sc = %p\n", ises_db, sc);

	timeout_add (&ises_db_timeout, 300); /* Every 3 secs */

	stat = READ_REG(sc, ISES_A_OQS);
	cmd  = READ_REG(sc, ISES_A_IQS);
	if (stat || cmd)
		printf ("ises0: IQS=%d OQS=%d / IQF=%d OQF=%d\n",
		    cmd, stat, READ_REG(sc, ISES_A_IQF),
		    READ_REG(sc, ISES_A_OQF));
	
	switch (ises_db) {
	default: 
		/* 0 - do nothing (just loop) */
		break;
	case 1:
		/* Just dump register info */
		ises_showreg();
		break;
	case 2:
		/* Reset LNAU 1 registers */
		ises_debug_simple_cmd(sc, ISES_CMD_LRESET_1, 0);
		
		/* Compute R = (141 * 5623) % 117 (R should be 51 (0x33)) */
		ises_debug_simple_cmd(sc, ISES_CMD_LW_A_1, 141);
		ises_debug_simple_cmd(sc, ISES_CMD_LW_B_1, 5623);
		ises_debug_simple_cmd(sc, ISES_CMD_LW_N_1, 117);
		
		/* Launch LNAU operation. */
		ises_debug_simple_cmd(sc, ISES_CMD_LMULMOD_1, 0);
		break;
	case 3:
		/* Read result LNAU_1 R register (should not be necessary) */
		ises_debug_simple_cmd(sc, ISES_CMD_LUPLOAD_1, 0);
		break;
	case 4:
		/* Print result */
		printf ("LNAU_1 R length = %d\n", sc->sc_lnau1_rlen);
		for (i = 0; i < sc->sc_lnau1_rlen; i++)
			printf ("W%02d-[%08x]-(%u)\t%s", i, sc->sc_lnau1_r[i],
			    sc->sc_lnau1_r[i], (i%4)==3 ? "\n" : "");
		printf ("%s", (i%4) ? "\n" : "");
		break;
	case 5:
		/* Crypto. */

		/* Load BCHU session data */
		bzero(&ses, sizeof ses);
		ses.kr[0] = 0xD0;
		ses.kr[1] = 0xD1;
		ses.kr[2] = 0xD2;
		ses.kr[3] = 0xD3;
		ses.kr[4] = 0xD4;
		ses.kr[5] = 0xD5;

		/* cipher data out is hash in, SHA1, 3DES, encrypt, ECB */
		ses.omr = ISES_SELR_BCHU_HISOF | ISES_HOMR_HFR_SHA1 |
		    ISES_SOMR_BOMR_3DES | ISES_SOMR_EDR | ISES_SOMR_FMR_ECB;

#if 1
		printf ("Queueing home-cooked session switch\n");
		ises_bchu_switch_session(sc, &ses, 0);
#else /* switch session does not appear to work - it never returns */
		printf ("Queueing BCHU session switch\n");
		cmd = ISES_MKCMD(ISES_CMD_BSWITCH, sizeof ses / 4);
		printf ("session is %d 32bit words (== 18 ?), cmd = [%08x]\n", 
			sizeof ses / 4, cmd);
		ises_queue_cmd(sc, cmd, (u_int32_t *)&ses, NULL);
#endif
		
		break;
	case 96:
		printf ("Stopping HRNG data collection\n");
		timeout_del(&sc->sc_timeout);
		break;
	case 97:
		printf ("Restarting HRNG data collection\n");
		if (!timeout_pending(&sc->sc_timeout))
			timeout_add(&sc->sc_timeout, hz);
		break;
	case 98:
		printf ("Resetting (wait >1s before cont.)\n");
		stat = ISES_BO_STAT_HWRESET;
		WRITE_REG(sc, ISES_BO_STAT, stat);
		stat &= ~ISES_BO_STAT_HWRESET;
		WRITE_REG(sc, ISES_BO_STAT, stat);
		break;
	case 99:
		printf ("Resetting everything!\n");
		if (timeout_pending(&sc->sc_timeout))
			timeout_del(&sc->sc_timeout);
		timeout_set(&sc->sc_timeout, ises_initstate, sc);
		sc->sc_initstate = 0;
		ises_initstate(sc);
		break;
	}
	
	ises_db = 0; 
}

void
ises_showreg (void)
{
	struct ises_softc *sc = ises_sc;
	u_int32_t stat, cmd;
	
	/* Board register */
	
	printf ("Board register: ");
	stat = READ_REG(sc, ISES_BO_STAT);
	
	if (stat & ISES_BO_STAT_LOOP)
		printf ("LoopMode ");
	if (stat & ISES_BO_STAT_TAMPER)
		printf ("Tamper ");
	if (stat & ISES_BO_STAT_POWERDOWN)
		printf ("PowerDown ");
	if (stat & ISES_BO_STAT_ACONF)
		printf ("16bitA-IF ");
	if (stat & ISES_BO_STAT_HWRESET)
		printf ("HWReset");
	if (stat & ISES_BO_STAT_AIRQ)
		printf ("A-IFintr");
	printf("\n");
	
	/* A interface */
	
	printf ("A Interface STAT register: \n\tLNAU-[");
	stat = READ_REG(sc, ISES_A_STAT);
	if (stat & ISES_STAT_LNAU_MASKED)
		printf ("masked");
	else {
		if (stat & ISES_STAT_LNAU_BUSY_1)
			printf ("busy1 ");
		if (stat & ISES_STAT_LNAU_ERR_1)
			printf ("err1 ");
		if (stat & ISES_STAT_LNAU_BUSY_2)
			printf ("busy2 ");
		if (stat & ISES_STAT_LNAU_ERR_2)
			printf ("err2 ");
	}
	printf ("]\n\tBCHU-[");
	
	if (stat & ISES_STAT_BCHU_MASKED)
		printf ("masked");
	else {
		if (stat & ISES_STAT_BCHU_BUSY)
			printf ("busy ");
		if (stat & ISES_STAT_BCHU_ERR)
			printf ("err ");
		if (stat & ISES_STAT_BCHU_SCIF)
			printf ("cr-inop ");
		if (stat & ISES_STAT_BCHU_HIF)
			printf ("ha-inop ");
		if (stat & ISES_STAT_BCHU_DDB)
			printf ("dscd-data ");
		if (stat & ISES_STAT_BCHU_IRF)
			printf ("inp-req ");
		if (stat & ISES_STAT_BCHU_OAF)
			printf ("out-avail ");
		if (stat & ISES_STAT_BCHU_DIE)
			printf ("inp-enabled ");
		if (stat & ISES_STAT_BCHU_UE)
			printf ("ififo-empty ");
		if (stat & ISES_STAT_BCHU_IFE)
			printf ("ififo-half ");
		if (stat & ISES_STAT_BCHU_IFHE)
			printf ("ififo-full ");
		if (stat & ISES_STAT_BCHU_OFE)
			printf ("ofifo-empty ");
		if (stat & ISES_STAT_BCHU_OFHF)
			printf ("ofifo-half ");
		if (stat & ISES_STAT_BCHU_OFF)
			printf ("ofifo-full ");
	}
	printf ("] \n\tmisc-[");
	
	if (stat & ISES_STAT_HW_DA)
		printf ("downloaded-appl ");
	if (stat & ISES_STAT_HW_ACONF)
		printf ("A-IF-conf ");
	if (stat & ISES_STAT_SW_WFOQ)
		printf ("OQ-wait ");
	if (stat & ISES_STAT_SW_OQSINC)
		printf ("OQS-increased ");
	printf ("]\n\t");
	
	if (stat & ISES_STAT_HW_DA)
		printf ("SW-mode is \"%s\"", 
		    ises_sw_mode[ISES_STAT_SW_MODE(stat)]);
	else
		printf ("IDP-state is \"%s\"", 
		    ises_idp_state[ISES_STAT_IDP_STATE(stat)]);
	printf ("\n");

	printf ("\tOQS = %d  IQS = %d  OQF = %d  IQF = %d\n", 
	    READ_REG(sc, ISES_A_OQS), READ_REG(sc, ISES_A_IQS),
	    READ_REG(sc, ISES_A_OQF), READ_REG(sc, ISES_A_IQF));
	
	/* B interface */
	
	printf ("B-interface status register contains [%08x]\n", 
	    READ_REG(sc, ISES_B_STAT));
	
	/* DMA */
	
	printf ("DMA read starts at 0x%x, length %d bytes\n", 
	    READ_REG(sc, ISES_DMA_READ_START), 
	    READ_REG(sc, ISES_DMA_READ_COUNT) >> 16);
	
	printf ("DMA write starts at 0x%x, length %d bytes\n",
	    READ_REG(sc, ISES_DMA_WRITE_START),
	    READ_REG(sc, ISES_DMA_WRITE_COUNT) & 0x00ff);

	stat = READ_REG(sc, ISES_DMA_STATUS);
	printf ("DMA status register contains [%08x]\n", stat);

	if (stat & ISES_DMA_CTRL_ILT)
		printf (" -- Ignore latency timer\n");
	if (stat & 0x0C000000)
		printf (" -- PCI Read - multiple\n");
	else if (stat & 0x08000000)
		printf (" -- PCI Read - line\n");

	if (stat & ISES_DMA_STATUS_R_RUN)
		printf (" -- PCI Read running/incomplete\n");
	else
		printf (" -- PCI Read complete\n");
	if (stat & ISES_DMA_STATUS_R_ERR)
		printf (" -- PCI Read DMA Error\n");

	if (stat & ISES_DMA_STATUS_W_RUN)
		printf (" -- PCI Write running/incomplete\n");
	else
		printf (" -- PCI Write complete\n");
	if (stat & ISES_DMA_STATUS_W_ERR)
		printf (" -- PCI Write DMA Error\n");

	/* OMR / HOMR / SOMR */
	
	/*
	 * All these means throwing a cmd on to the A-interface, and then
	 * reading the result.
	 *
	 * Currently, put debug output in process_oqueue...
	 */
	
	printf ("Queueing Operation Method Register (OMR) READ cmd...\n");
	cmd = ISES_MKCMD(ISES_CMD_BR_OMR, 0);
	ises_queue_cmd(sc, cmd, NULL, NULL);
}

void
ises_debug_parse_omr (struct ises_softc *sc)
{
	u_int32_t omr = sc->sc_sessions[sc->sc_cursession].omr;
	
	printf ("SELR : ");
	if (omr & ISES_SELR_BCHU_EH)
		printf ("cont-on-error ");
	else
		printf ("stop-on-error ");
	
	if (omr & ISES_SELR_BCHU_HISOF)
		printf ("HU-input-is-SCU-output ");
	
	if (omr & ISES_SELR_BCHU_DIS)
		printf ("data-interface-select=B ");
	else
		printf ("data-interface-select=DataIn/DataOut ");
	
	printf ("\n");
	
	printf ("HOMR : ");
	if (omr & ISES_HOMR_HMTR)
		printf ("expect-padded-hash-msg ");
	else
		printf ("expect-plaintext-hash-msg ");
	
	printf ("ER=%d ", (omr & ISES_HOMR_ER) >> 20); /* ick */
	
	printf ("HFR=");
	switch (omr & ISES_HOMR_HFR) {
	case ISES_HOMR_HFR_NOP:
		printf ("inactive ");
		break;
	case ISES_HOMR_HFR_MD5:
		printf ("MD5 ");
		break;
	case ISES_HOMR_HFR_RMD160:
		printf ("RMD160 ");
		break;
	case ISES_HOMR_HFR_RMD128:
		printf ("RMD128 ");
		break;
	case ISES_HOMR_HFR_SHA1:
		printf ("SHA-1 ");
		break;
	default:
		printf ("reserved! ");
		break;
	}
	printf ("\nSOMR : ");
	
	switch (omr & ISES_SOMR_BOMR) {
	case ISES_SOMR_BOMR_NOP:
		printf ("NOP ");
		break;
	case ISES_SOMR_BOMR_TRANSPARENT:
		printf ("transparent ");
		break;
	case ISES_SOMR_BOMR_DES:
		printf ("DES ");
		break;
	case ISES_SOMR_BOMR_3DES2:
		printf ("3DES-2 ");
		break;
	case ISES_SOMR_BOMR_3DES:
		printf ("3DES-3 ");
		break;
	default:
		if (omr & ISES_SOMR_BOMR_SAFER)
			printf ("SAFER ");
		else
			printf ("reserved! ");
		break;
	}
	
	if (omr & ISES_SOMR_EDR)
		printf ("mode=encrypt ");
	else
		printf ("mode=decrypt ");
	
	switch (omr & ISES_SOMR_FMR) {
	case ISES_SOMR_FMR_ECB:
		printf ("ECB");
		break;
	case ISES_SOMR_FMR_CBC:
		printf ("CBC");
		break;
	case ISES_SOMR_FMR_CFB64:
		printf ("CFB64");
		break;
	case ISES_SOMR_FMR_OFB64:
		printf ("OFB64");
		break;
	default:
		/* Nada */
	}
	printf ("\n");
}

#endif /* ISESDEBUG */
@


1.33
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...' where
obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.32 2007/09/18 22:02:18 djm Exp $	*/
@


1.32
log
@arc4random_bytes() is the preferred interface for generating nonces;
"looks ok" markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.31 2006/06/29 21:34:51 deraadt Exp $	*/
d543 1
a543 2
	cq = (struct ises_cmd *) 
	    malloc(sizeof (struct ises_cmd), M_DEVBUF, M_NOWAIT);
a548 1
	bzero(cq, sizeof (struct ises_cmd));
d1172 1
a1172 1
	q = (struct ises_q *)malloc(sizeof(struct ises_q), M_DEVBUF, M_NOWAIT);
a1174 1
	bzero(q, sizeof(struct ises_q));
@


1.31
log
@do not check for master/io/mem enables; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.30 2006/04/20 20:31:12 miod Exp $	*/
d1017 1
a1017 1
		get_random_bytes(ses->sccr, sizeof(ses->sccr));
@


1.30
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.29 2005/11/26 14:31:26 krw Exp $	*/
a162 1
	u_int32_t cmd;
a170 12

	/* Verify PCI space */
	cmd = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	if (!(cmd & PCI_COMMAND_MEM_ENABLE)) {
		printf(": failed to enable memory mapping\n");
		return;
	}

	if (!(cmd & PCI_COMMAND_MASTER_ENABLE)) {
		printf(": failed to enable bus mastering\n");
		return;
	}
@


1.29
log
@Add some missing 'break;'s in auich and auixp that lint spotted. While
here, use FALLTHRU or FALLTHROUGH to make lint even happier.

ok marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.28 2005/08/09 04:10:12 mickey Exp $	*/
d1555 1
a1555 1
	printf(", rng active", sc->sc_dv.dv_xname);
@


1.28
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.27 2004/05/07 14:42:26 millert Exp $	*/
d265 1
d268 1
d271 1
d274 1
d277 1
d308 1
a310 1
		sc->sc_initstate++;
@


1.27
log
@Replace RSA-derived md5 code with code derived from Colin Plumb's PD version.
This moves md5.c out of libkern and into sys/crypto where it belongs (as
requested by markus@@).  Note that md5.c is still mandatory (dev/rnd.c uses it).
Verified with IPsec + hmac-md5 and tcp md5sig. OK henning@@ and hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.26 2004/05/07 01:41:37 tedu Exp $	*/
a174 4
	cmd |= PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, cmd);
	cmd = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);

@


1.26
log
@free the right thing on failure, in case this ever gets used
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.25 2004/05/04 16:59:31 grange Exp $	*/
d47 1
a47 1
#include <sys/md5k.h>
@


1.25
log
@Remove useless ``elm'' argument from the SIMPLEQ_REMOVE_HEAD macro.
This matches our SLIST behaviour and NetBSD's SIMPLEQ as well.

ok millert krw deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.24 2003/06/07 11:31:24 ho Exp $	*/
d266 1
a266 1
	case 4:
d269 2
d272 1
a272 1
		bus_dmamem_free(sc->sc_dmat, &seg, nsegs);
d274 1
a274 1
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_dmamap);
d276 1
a276 1
		pci_intr_disestablish(pc, sc->sc_ih);
d278 1
a278 1
		bus_space_unmap(sc->sc_memt, sc->sc_memh, memsize);
@


1.24
log
@Remove clause 3.
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.23 2003/02/18 18:16:21 jason Exp $	*/
d611 1
a611 1
			SIMPLEQ_REMOVE_HEAD(&sc->sc_cmdq, cq, cmd_next);
d885 1
a885 1
	SIMPLEQ_REMOVE_HEAD(&sc->sc_queue, q, q_next);
@


1.23
log
@convert to new registration scheme
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.22 2002/07/05 21:21:17 jason Exp $	*/
a14 2
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.22
log
@Never call crp_callback directly, use crypto_done() instead
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.21 2002/07/05 21:03:46 jason Exp $	*/
d294 1
a294 1
	int p, ticks;
d502 9
a510 1
		p = crypto_register(sc->sc_cid, CRYPTO_3DES_CBC, 0, 0,
a511 11
		p |= crypto_register(sc->sc_cid, CRYPTO_DES_CBC, 0, 0,
		    NULL, NULL, NULL);
		p |= crypto_register(sc->sc_cid, CRYPTO_MD5_HMAC, 0, 0,
		    NULL, NULL, NULL);
		p |= crypto_register(sc->sc_cid, CRYPTO_SHA1_HMAC, 0, 0,
		    NULL, NULL, NULL);
		p |= crypto_register(sc->sc_cid, CRYPTO_RIPEMD160_HMAC, 0, 0,
		    NULL, NULL, NULL);
		if (p)
			printf("%s: could not register all algorithms\n", dv);

@


1.21
log
@KNF (no space after casts)
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.20 2002/03/14 03:16:06 millert Exp $	*/
d1472 1
a1472 1
	crp->crp_callback(crp);
@


1.20
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.19 2002/03/14 01:26:59 millert Exp $	*/
d1130 1
a1130 1
	u_int32_t sid = ((u_int32_t) tsid) & 0xffffffff;
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.18 2001/11/09 03:11:38 deraadt Exp $	*/
d71 2
a72 3
int	ises_queue_cmd __P((struct ises_softc *, u_int32_t, u_int32_t *, 
			    u_int32_t (*)(struct ises_softc *, 
					  struct ises_cmd *)));
@


1.18
log
@be way more sure that software cannot be used
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.17 2001/11/05 17:25:58 art Exp $	*/
d64 2
a65 2
int	ises_match __P((struct device *, void *, void *));
void	ises_attach __P((struct device *, struct device *, void *));
d67 4
a70 4
void	ises_initstate __P((void *));
void	ises_hrng_init __P((struct ises_softc *));
void	ises_hrng __P((void *));
void	ises_process_oqueue __P((struct ises_softc *));
d74 2
a75 2
u_int32_t ises_get_fwversion __P((struct ises_softc *));
int	ises_assert_cmd_mode __P((struct ises_softc *));
d77 9
a85 9
int	ises_intr __P((void *));
int	ises_newsession __P((u_int32_t *, struct cryptoini *));
int	ises_freesession __P((u_int64_t));
int	ises_process __P((struct cryptop *));
void	ises_callback __P((struct ises_q *));
int	ises_feed __P((struct ises_softc *));
int	ises_bchu_switch_session __P((struct ises_softc *, 
				      struct ises_session *, int));
u_int32_t ises_bchu_switch_final __P((struct ises_softc *, struct ises_cmd *));
d87 1
a87 1
void	ises_read_dma __P((struct ises_softc *));
d105 6
a110 6
void	ises_debug_init __P((struct ises_softc *));
void	ises_debug_2 __P((void));
void	ises_debug_loop __P((void *));
void	ises_showreg __P((void));
void	ises_debug_parse_omr __P((struct ises_softc *));
void	ises_debug_simple_cmd __P((struct ises_softc *, u_int32_t, u_int32_t));
@


1.18.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.18 2001/11/09 03:11:38 deraadt Exp $	*/
d64 2
a65 2
int	ises_match(struct device *, void *, void *);
void	ises_attach(struct device *, struct device *, void *);
d67 19
a85 18
void	ises_initstate(void *);
void	ises_hrng_init(struct ises_softc *);
void	ises_hrng(void *);
void	ises_process_oqueue(struct ises_softc *);
int	ises_queue_cmd(struct ises_softc *, u_int32_t, u_int32_t *, 
		       u_int32_t (*)(struct ises_softc *, struct ises_cmd *));
u_int32_t ises_get_fwversion(struct ises_softc *);
int	ises_assert_cmd_mode(struct ises_softc *);

int	ises_intr(void *);
int	ises_newsession(u_int32_t *, struct cryptoini *);
int	ises_freesession(u_int64_t);
int	ises_process(struct cryptop *);
void	ises_callback(struct ises_q *);
int	ises_feed(struct ises_softc *);
int	ises_bchu_switch_session(struct ises_softc *, 
				      struct ises_session *, int);
u_int32_t ises_bchu_switch_final(struct ises_softc *, struct ises_cmd *);
d87 1
a87 1
void	ises_read_dma(struct ises_softc *);
d105 6
a110 6
void	ises_debug_init(struct ises_softc *);
void	ises_debug_2(void);
void	ises_debug_loop(void *);
void	ises_showreg(void);
void	ises_debug_parse_omr(struct ises_softc *);
void	ises_debug_simple_cmd(struct ises_softc *, u_int32_t, u_int32_t);
@


1.18.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.18.2.1 2002/06/11 03:42:26 art Exp $	*/
d1130 1
a1130 1
	u_int32_t sid = ((u_int32_t)tsid) & 0xffffffff;
d1472 1
a1472 1
	crypto_done(crp);
@


1.18.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d294 1
a294 1
	int p, ticks, algs[CRYPTO_ALGORITHM_MAX + 1];
d502 12
a513 7
		bzero(algs, sizeof(algs));

		algs[CRYPTO_3DES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_DES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_MD5_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_SHA1_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_RIPEMD160_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
a514 2
		crypto_register(sc->sc_cid, algs,
		    ises_newsession, ises_freesession, ises_process);
@


1.17
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.16 2001/09/21 19:41:13 ho Exp $	*/
d248 1
a248 1
	sc->sc_cid = crypto_get_driverid();
@


1.16
log
@Not yet working, but getting a bit closer.
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.15 2001/08/25 10:13:29 art Exp $	*/
d754 2
a755 2
			bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 
			    BUS_DMASYNC_POSTREAD);
d765 2
a766 2
			bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 
			    BUS_DMASYNC_POSTWRITE);
d905 2
a906 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, BUS_DMASYNC_PREWRITE);
d1767 2
a1768 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, BUS_DMASYNC_PREREAD);
@


1.15
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.14 2001/08/09 19:42:05 ho Exp $	*/
d83 3
a85 2
void	ises_bchu_switch_session __P((struct ises_softc *, 
				      struct ises_session *));
d122 6
d296 1
d298 1
a298 1
	ticks = hz; 
d301 1
a301 1
	DPRINTF (("%s: initstate %d, IDP state is %d \"%s\"\n", dv, 
d320 1
a320 1
#if 0
d360 1
a360 1
			sc->sc_initstate += 4; /* Next step --> 7 */
d366 11
d400 1
a400 1
		/* Again, wait one second for selftests. */
d410 8
a417 1
		if (READ_REG(sc, ISES_A_IQF) < 4 || p != 0x4) {
a502 1
#ifdef notyet
a514 1
#endif
d548 2
a549 2
		DPRINTF(("%s: queuing cmd %d len %d\n", sc->sc_dv.dv_xname,
		    cmd, len));
d626 7
a632 3
			/* This command generated an error */
			DPRINTF(("%s:process_oqueue: cmd %d err %d\n", dv, cmd,
			    (r & ISES_RC_MASK)));
d641 1
a641 1
					    " cmd %d, got %d\n", dv, 
d699 1
d714 2
a715 6
				/*
				 * This return indicates our homecooked
				 * session switch is complete. Start data
				 * feed.
				 */
				DPRINTF(("%s:process_oqueue: sesn switched\n",
a716 4
				sc->sc_switching = 0;

				/* Retry/restart */
				ises_feed(sc);
d721 1
a721 1
				DPRINTF(("%s:process_oqueue [cmd %d len %d]\n",
d757 1
a757 1
			/* XXX */
a760 1

d777 2
a778 1
	if (!(ints & sc->sc_intrmask))
d780 1
d822 2
a823 1
		/* ises_process_oqueue(sc); */
d855 3
d880 4
a883 2
		ises_bchu_switch_session (sc, &q->q_session);
		sc->sc_cursession = q->q_sesn;
d887 3
d908 3
d919 1
d956 2
d989 2
a990 1
		sc->sc_cursession = sesn = 0;
d1035 1
a1035 1
		if (c->cri_alg == CRYPTO_DES_CBC) {
d1142 3
d1160 4
a1163 1
	int cpoffset, coffset, nicealign;
d1180 2
d1245 2
d1360 2
a1361 2
#if 0
	/* XXX not sure about this, in bus_dma context */
d1364 1
a1364 1
		    &q->q_src_packp, &q->q_src_packl, 1, &nicealign);
d1367 1
a1367 1
		    &q->q_src_packp, &q->q_src_packl, 1, &nicealign);
d1369 2
a1370 1
#endif
d1374 4
d1384 3
a1386 1
		if (!nicealign) {
d1444 2
d1596 1
d1598 1
d1695 3
a1697 2
void
ises_bchu_switch_session (struct ises_softc *sc, struct ises_session *ss)
d1704 4
d1709 1
a1709 1
	sc->sc_switching = 1;
d1724 1
a1724 1
	cmd = ISES_MKCMD(ISES_CMD_BW_SCCR, 1);
d1728 1
a1728 1
	cmd = ISES_MKCMD(ISES_CMD_BW_SCCR, 5);
d1732 1
a1732 1
	cmd = ISES_MKCMD(ISES_CMD_BW_SCCR, 2);
d1735 1
a1735 1
	/* Write HMLR - Hash Message Length Register */
d1737 20
a1756 1
	ises_queue_cmd(sc, cmd, &ss->hmlr[0], NULL);
d1879 1
a1879 1
		ises_bchu_switch_session(sc, &ses);
d2009 1
a2009 1
		printf ("LDP-state is \"%s\"", 
d2013 3
a2015 2
	printf ("\tOQS = %d\n\tIQS = %d\n", READ_REG(sc, ISES_A_OQS),
	    READ_REG(sc, ISES_A_IQS));
@


1.14
log
@Use a startup hook for the rest of the chip initialization.
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.13 2001/07/02 09:18:15 ho Exp $	*/
d195 1
a195 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin, pa->pa_intrline,
	    &ih)) {
@


1.13
log
@Put the ISES firmware under dev/microcode/.
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.12 2001/06/27 00:20:16 ho Exp $	*/
d254 2
a255 2
	timeout_set(&sc->sc_timeout, ises_initstate, sc);
	ises_initstate(sc);
d299 6
d313 9
d324 1
d326 1
a326 1
	case 1:
d343 1
a343 1
	case 2:
d369 1
a369 1
	case 3:
d377 1
a377 1
	case 4:
d385 1
a385 1
	case 5:
d414 1
a414 1
	case 6:
d424 1
a424 1
	case 7:
d479 1
a479 1
		crypto_register(sc->sc_cid, CRYPTO_3DES_CBC, 0, 0,
d481 1
a481 1
		crypto_register(sc->sc_cid, CRYPTO_DES_CBC, 0, 0,
d483 1
a483 1
		crypto_register(sc->sc_cid, CRYPTO_MD5_HMAC, 0, 0,
d485 1
a485 1
		crypto_register(sc->sc_cid, CRYPTO_SHA1_HMAC, 0, 0,
d487 1
a487 1
		crypto_register(sc->sc_cid, CRYPTO_RIPEMD160_HMAC, 0, 0,
d489 2
@


1.12
log
@Remove an unused function call.
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.11 2001/06/25 22:30:07 ho Exp $	*/
d59 1
@


1.11
log
@Cleanup/rewrite. Some further work. No crypto yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.10 2001/06/24 21:08:07 ho Exp $	*/
a86 3
/* XXX for now... */
void	ubsec_mcopy __P((struct mbuf *, struct mbuf *, int, int));

d1358 1
d1360 1
@


1.10
log
@Some cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.9 2001/06/23 21:06:48 angelos Exp $	*/
d83 3
a85 1
				      struct ises_bchu_session *));
d226 2
a227 2
	if (bus_dmamem_alloc(sc->sc_dmat, sizeof sc->sc_dma_data, 1, 0, &seg,
	    1, &nsegs, BUS_DMA_NOWAIT)) {
d233 2
a234 2
	if (bus_dmamem_map(sc->sc_dmat, &seg, nsegs, sizeof sc->sc_dma_data,
	    (caddr_t *)&sc->sc_dma_data, 0)) {
d295 3
a297 3
#if 0 /* Too noisy */
	DPRINTF (("%s: entered initstate %d\n", dv, sc->sc_initstate));
#endif
d506 8
a513 2
	
	s = splimp();
d530 1
d559 1
d561 1
a561 1
	int cmd, len, c;
d575 1
d584 1
d646 2
a647 1
				sc->sc_bsession.omr = READ_REG(sc, ISES_A_OQD);
d649 1
a649 1
				    dv, sc->sc_bsession.omr));
d657 2
a658 1
				/* Put switched BCHU session in sc_bsession. */
d660 3
a662 1
					*((u_int32_t *)&sc->sc_bsession + c) =
d664 17
d708 1
a708 3
	volatile u_int32_t ints;
	u_int32_t cmd;
#ifdef ISESDEBUG
d710 30
a739 1
#endif
d745 2
a746 1
	WRITE_REG(sc, ISES_A_INTS, ints); /* Clear all set intr bits. */
d755 2
a756 1
	if (ints & ISES_STAT_SW_OQSINC) {	/* A-intf output q has data */
a757 1
	}
d810 24
d835 7
a841 13
	while (!SIMPLEQ_EMPTY(&sc->sc_queue)) {
		if (READ_REG(sc, ISES_A_STAT) & ISES_STAT_BCHU_IFF)
			break;
		q = SIMPLEQ_FIRST(&sc->sc_queue);
#if 0
		WRITE_REG(sc, ISES_OFFSET_BCHU_DATA,
		    (u_int32_t)vtophys(&q->q_mcr));
		printf("feed: q->chip %08x %08x\n", q,
		    (u_int32_t)vtophys(&q->q_mcr));
#endif
		SIMPLEQ_REMOVE_HEAD(&sc->sc_queue, q, q_next);
		--sc->sc_nqueue;
		SIMPLEQ_INSERT_TAIL(&sc->sc_qchip, q, q_next);
d843 27
d888 3
d902 3
d924 5
d937 1
a937 1
		sesn = 0;
d942 1
a942 1
			if (sc->sc_sessions[sesn].ses_used == 0) {
d944 1
d963 1
d968 3
d972 3
a974 1
	ses->ses_used = 1;
d979 1
a979 1
		get_random_bytes(ses->ses_iv, sizeof(ses->ses_iv));
d983 3
a985 3
			bcopy(enc->cri_key, &ses->ses_deskey[0], 8);
			bcopy(enc->cri_key, &ses->ses_deskey[2], 8);
			bcopy(enc->cri_key, &ses->ses_deskey[4], 8);
d987 1
a987 1
			bcopy(enc->cri_key, &ses->ses_deskey[0], 24);
d989 6
a994 6
		SWAP32(ses->ses_deskey[0]);
		SWAP32(ses->ses_deskey[1]);
		SWAP32(ses->ses_deskey[2]);
		SWAP32(ses->ses_deskey[3]);
		SWAP32(ses->ses_deskey[4]);
		SWAP32(ses->ses_deskey[5]);
d1007 1
a1007 2
			bcopy(md5ctx.state, ses->ses_hminner,
			    sizeof(md5ctx.state));
d1014 1
a1014 2
			bcopy(sha1ctx.state, ses->ses_hminner,
			    sizeof(sha1ctx.state));
d1023 1
a1023 2
			bcopy(rmd160ctx.state, ses->ses_hminner,
			    sizeof(rmd160ctx.state));
d1034 1
a1034 1
			MD5Update(&md5ctx, hmac_ipad_buffer, HMAC_BLOCK_LEN -
d1036 1
a1036 1
			bcopy(md5ctx.state, ses->ses_hmouter,
d1038 1
d1043 1
a1043 1
			SHA1Update(&sha1ctx, hmac_ipad_buffer, HMAC_BLOCK_LEN -
d1045 1
a1045 1
			bcopy(sha1ctx.state, ses->ses_hmouter,
d1047 1
d1054 1
a1054 1
			RMD160Update(&rmd160ctx, hmac_ipad_buffer,
d1056 1
a1056 1
			bcopy(rmd160ctx.state, ses->ses_hmouter,
d1058 1
d1066 1
d1071 1
a1071 3
/*
 * Deallocate a session.
 */
d1085 4
d1094 1
a1097 1
	int card, err;
d1102 5
a1106 4
#if 0
	int s, i, j;
#else
	int s;
a1107 3
	int encoffset = 0, macoffset = 0;
	int sskip, stheend, dtheend, cpskip, cpoffset, dskip, nicealign;
	int16_t coffset;
d1113 1
a1113 2
	if (card >= ises_cd.cd_ndevs || ises_cd.cd_devs[card] == NULL) {
		err = EINVAL;
a1114 1
	}
d1117 3
d1124 1
a1124 2
		err = ENOMEM;
		goto errout;
d1129 2
a1130 4
	if (q == NULL) {
		err = ENOMEM;
		goto errout;
	}
d1136 1
a1136 1
	/* XXX */
d1142 5
a1146 2
		q->q_src_m = (struct mbuf *)crp->crp_buf;
		q->q_dst_m = (struct mbuf *)crp->crp_buf;
d1148 1
a1148 1
		err = EINVAL;
a1159 1
	err = EINVAL;
d1183 3
a1185 1
	err = 0;
d1190 1
d1192 1
a1192 1
			q->q_bsession.omr |= ISES_SOMR_BOMR_3DES;
d1194 4
a1197 2
			q->q_bsession.omr |= ISES_SOMR_BOMR_DES;
		q->q_bsession.omr |= ISES_SOMR_FMR_CBC;
d1200 2
a1201 1
			q->q_bsession.omr |= ISES_SOMR_EDR; /* XXX */
d1204 1
a1204 1
				bcopy(enccrd->crd_iv, q->q_bsession.sccr, 8);
d1206 2
a1207 2
				q->q_bsession.sccr[0] = ses->ses_iv[0];
				q->q_bsession.sccr[1] = ses->ses_iv[1];
d1210 11
a1220 3
			if ((enccrd->crd_flags & CRD_F_IV_PRESENT) == 0)
				m_copyback(q->q_src_m, enccrd->crd_inject,
				    8, (caddr_t)q->q_bsession.sccr);
d1222 2
a1223 1
			q->q_bsession.omr &= ~ISES_SOMR_EDR; /* XXX */
d1226 9
a1234 4
				bcopy(enccrd->crd_iv, q->q_bsession.sccr, 8);
			else
				m_copyback(q->q_src_m, enccrd->crd_inject,
				    8, (caddr_t)q->q_bsession.sccr);
d1237 6
a1242 6
		q->q_bsession.kr[0] = ses->ses_deskey[0];
		q->q_bsession.kr[1] = ses->ses_deskey[1];
		q->q_bsession.kr[2] = ses->ses_deskey[2];
		q->q_bsession.kr[3] = ses->ses_deskey[3];
		q->q_bsession.kr[4] = ses->ses_deskey[4];
		q->q_bsession.kr[5] = ses->ses_deskey[5];
d1244 2
a1245 2
		SWAP32(q->q_bsession.sccr[0]);
		SWAP32(q->q_bsession.sccr[1]);
d1251 1
d1254 1
a1254 1
			q->q_bsession.omr |= ISES_HOMR_HFR_MD5;
d1257 1
a1257 1
			q->q_bsession.omr |= ISES_HOMR_HFR_SHA1;
d1261 1
a1261 1
			q->q_bsession.omr |= ISES_HOMR_HFR_RMD160;
d1265 5
a1269 13
		q->q_hminner[0] = ses->ses_hminner[0];
		q->q_hminner[1] = ses->ses_hminner[1];
		q->q_hminner[2] = ses->ses_hminner[2];
		q->q_hminner[3] = ses->ses_hminner[3];
		q->q_hminner[4] = ses->ses_hminner[4];
		q->q_hminner[5] = ses->ses_hminner[5];

		q->q_hmouter[0] = ses->ses_hmouter[0];
		q->q_hmouter[1] = ses->ses_hmouter[1];
		q->q_hmouter[2] = ses->ses_hmouter[2];
		q->q_hmouter[3] = ses->ses_hmouter[3];
		q->q_hmouter[4] = ses->ses_hmouter[4];
		q->q_hmouter[5] = ses->ses_hmouter[5];
a1277 1
			err = EINVAL;
d1297 10
a1306 8
	q->q_src_l = mbuf2pages(q->q_src_m, &q->q_src_npa, &q->q_src_packp,
	    &q->q_src_packl, 1, &nicealign);
	if (q->q_src_l == 0) {
		err = ENOMEM;
		goto errout;
	}

	/* XXX mcr stuff; q->q_mcr->mcr_pktlen = stheend; */
d1308 2
a1309 3
#if 0 /* XXX */
	for (i = j = 0; i < q->q_src_npa; i++) {
		bus_dma_segment_t *ds;
d1311 1
a1311 36
		/* XXX DEBUG? */

		if (sskip) {
			if (sskip >= q->q_src_packl) {
				sskip -= q->q_src_packl;
				continue;
			}
			q->q_src_packp += sskip;
			q->q_src_packl -= sskip;
			sskip = 0;
		}

		ds = NULL; /* XXX initial packet */

		ds->ds_addr = q->q_src_packp;
		if (stheend) {
			if (q->q_src_packl > stheend) {
				ds->ds_len = stheend;
				stheend = 0;
			} else {
				ds->ds_len = q->q_src_packl;
				stheend -= ds->ds_len;
			}
		} else
			ds->ds_len = q->q_src_packl;

		if ((i + 1) == q->q_src_npa)
			ds->ds_next = 0;
		else
			ds->ds_next = vtophys(&q->q_srcpkt);

		j++;
	}

#endif /* XXX */
	/* XXX DEBUG ? */
d1314 1
a1314 1
		/* XXX mcr stuff */
d1321 1
a1321 1
			if (q->q_src_m->m_flags & M_PKTHDR) {
d1323 1
a1323 1
				M_DUP_PKTHDR(m, q->q_src_m);
d1329 2
a1330 4
			if (m == NULL) {
				err = ENOMEM;
				goto errout;
			}
d1345 1
a1345 2
						err = ENOMEM;
						goto errout;
d1360 2
a1361 2
			q->q_dst_m = top;
			ubsec_mcopy(q->q_src_m, q->q_dst_m, cpskip, cpoffset);
d1363 1
a1363 1
			q->q_dst_m = q->q_src_m;
d1365 3
a1367 1
		q->q_dst_l = mbuf2pages(q->q_dst_m, &q->q_dst_npa,
a1368 42

#if 0
		for (i = j = 0; i < q->q_dst_npa; i++) {
			struct bus_dma_segment_t *ds;

			if (dskip) {
				if (dskip >= q->q_dst_packl[i]) {
					dskip -= q->q_dst_packl[i];
					continue;
				}
				q->q_dst_packp[i] += dskip;
				q->q_dst_packl[i] -= dskip;
				dskip = 0;
			}

			if (j == 0)
				ds = NULL; /* &q->q_mcr->mcr_opktbuf; */
			else
				ds = &q->q_dstpkt[j - 1];

			ds->ds_addr = q->q_dst_packp[i];

			if (dtheend) {
				if (q->q_dst_packl[i] > dtheend) {
					ds->ds_len = dtheend;
					dtheend = 0;
				} else {
					ds->ds_len = q->q_dst_packl[i];
					dtheend -= ds->ds_len;
				}
			} else
				ds->ds_len = q->q_dst_packl[i];

			if ((i + 1) == q->q_dst_npa) {
				if (maccrd)
					ds->ds_next = vtophys(q->q_macbuf);
				else
					ds->ds_next = 0;
			} else
				ds->ds_next = vtophys(&q->q_dstpkt[j]);
			j++;
		}
d1372 2
d1377 1
a1378 1
	splx(s);
d1382 3
d1386 4
a1389 3
	if (err == ENOMEM)
		isesstats.nomem++;
	else if (err == EINVAL)
d1393 2
a1394 2
		if (q->q_src_m != q->q_dst_m)
			m_freem(q->q_dst_m);
d1407 2
d1410 20
a1429 3
	if ((crp->crp_flags & CRYPTO_F_IMBUF) && (q->q_src_m != q->q_dst_m)) {
		m_freem(q->q_src_m);
		crp->crp_buf = (caddr_t)q->q_dst_m;
d1437 6
a1442 2
		m_copyback((struct mbuf *)crp->crp_buf,
		    crd->crd_inject, 12, (u_int8_t *)&q->q_macbuf[0]);
d1447 2
d1619 57
a1709 27
ises_bchu_switch_session (struct ises_softc *sc, struct ises_bchu_session *ss)
{
	/* It appears that the BCHU_SWITCH_SESSION command is broken. */
	/* We have to work around it. */
	
	u_int32_t cmd;

	cmd = ISES_MKCMD(ISES_CMD_BR_KR0, 0); 
	ises_queue_cmd(sc, cmd, NULL, NULL);
	cmd = ISES_MKCMD(ISES_CMD_BR_KR1, 0); 
	ises_queue_cmd(sc, cmd, NULL, NULL);
	cmd = ISES_MKCMD(ISES_CMD_BR_KR2, 0); 
	ises_queue_cmd(sc, cmd, NULL, NULL);
	
	cmd = ISES_MKCMD(ISES_CMD_BR_OMR, 0); 
	ises_queue_cmd(sc, cmd, NULL, NULL);
	cmd = ISES_MKCMD(ISES_CMD_BR_SCCR, 0); 
	ises_queue_cmd(sc, cmd, NULL, NULL);
	cmd = ISES_MKCMD(ISES_CMD_BR_DBCR, 0); 
	ises_queue_cmd(sc, cmd, NULL, NULL);
	cmd = ISES_MKCMD(ISES_CMD_BR_HMLR, 0); 
	ises_queue_cmd(sc, cmd, NULL, NULL);
	cmd = ISES_MKCMD(ISES_CMD_BR_CVR, 0); 
	ises_queue_cmd(sc, cmd, NULL, NULL);
}

void
d1713 1
a1713 1
	struct ises_bchu_session bses;
d1765 7
a1771 7
		bzero(&bses, sizeof bses);
		bses.kr[0] = 0xD0;
		bses.kr[1] = 0xD1;
		bses.kr[2] = 0xD2;
		bses.kr[3] = 0xD3;
		bses.kr[4] = 0xD4;
		bses.kr[5] = 0xD5;
d1774 1
a1774 1
		bses.omr = ISES_SELR_BCHU_HISOF | ISES_HOMR_HFR_SHA1 |
d1777 4
a1780 13
		printf ("Queueing OMR write\n");
		cmd = ISES_MKCMD(ISES_CMD_BW_OMR, 1);
		ises_queue_cmd(sc, cmd, &bses.omr, NULL);

		printf ("Queueing KR0, KR1, KR2 writes\n");
		cmd = ISES_MKCMD(ISES_CMD_BW_KR0, 2);
		ises_queue_cmd(sc, cmd, &bses.kr[4], NULL);
		cmd = ISES_MKCMD(ISES_CMD_BW_KR1, 2);
		ises_queue_cmd(sc, cmd, &bses.kr[2], NULL);
		cmd = ISES_MKCMD(ISES_CMD_BW_KR2, 2);
		ises_queue_cmd(sc, cmd, &bses.kr[0], NULL);

#if 0 /* switch session does not appear to work - it never returns */
d1782 1
a1782 1
		cmd = ISES_MKCMD(ISES_CMD_BSWITCH, sizeof bses / 4);
d1784 2
a1785 2
			sizeof bses / 4, cmd);
		ises_queue_cmd(sc, cmd, (u_int32_t *)&bses, NULL);
d1972 1
a1972 1
	u_int32_t omr = sc->sc_bsession.omr;
d1984 3
a1986 1
		printf ("data-interface-select ");
@


1.9
log
@Conform to new crypto_register() prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.8 2001/06/23 18:30:37 deraadt Exp $	*/
a157 1
	bus_addr_t membase;
d188 1
a188 1
	    &sc->sc_memh, &membase, &memsize, 0)) {
d216 1
a216 1
	    0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &sc->sc_dmamap_xfer);
d224 2
a225 2
	if (bus_dmamem_alloc(sc->sc_dmat, sizeof sc->sc_dmamap, 1, 0, &seg, 1,
	    &nsegs, BUS_DMA_NOWAIT)) {
d231 2
a232 3
	sc->sc_dmamap_phys = seg.ds_addr;
	if (bus_dmamem_map(sc->sc_dmat, &seg, nsegs, sizeof sc->sc_dmamap,
	    (caddr_t *)&sc->sc_dmamap, 0)) {
d264 2
a265 2
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)&sc->sc_dmamap,
		    sizeof sc->sc_dmamap);
d269 1
a269 1
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_dmamap_xfer);
d405 2
a406 3
		/* We failed. We cannot do anything else. */
		printf ("%s: firmware download failed\n", dv);
		return;
d424 1
a424 1
		/* We can use firmware version 1.x & 2.x */
d535 1
d1171 1
a1171 1
		struct ises_pktbuf *pb;
d1185 1
a1185 1
		pb = NULL; /* XXX initial packet */
d1187 1
a1187 1
		pb->pb_addr = q->q_src_packp;
d1190 1
a1190 1
				pb->pb_len = stheend;
d1193 2
a1194 2
				pb->pb_len = q->q_src_packl;
				stheend -= pb->pb_len;
d1197 1
a1197 1
			pb->pb_len = q->q_src_packl;
d1200 1
a1200 1
			pb->pb_next = 0;
d1202 1
a1202 1
			pb->pb_next = vtophys(&q->q_srcpkt);
d1270 1
a1270 1
			struct ises_pktbuf *pb;
d1283 1
a1283 1
				pb = NULL; /* &q->q_mcr->mcr_opktbuf; */
d1285 1
a1285 1
				pb = &q->q_dstpkt[j - 1];
d1287 1
a1287 1
			pb->pb_addr = q->q_dst_packp[i];
d1291 1
a1291 1
					pb->pb_len = dtheend;
d1294 2
a1295 2
					pb->pb_len = q->q_dst_packl[i];
					dtheend -= pb->pb_len;
d1298 1
a1298 1
				pb->pb_len = q->q_dst_packl[i];
d1302 1
a1302 1
					pb->pb_next = vtophys(q->q_macbuf);
d1304 1
a1304 1
					pb->pb_next = 0;
d1306 1
a1306 1
				pb->pb_next = vtophys(&q->q_dstpkt[j]);
d1813 1
a1813 1
	    READ_REG(sc, ISES_DMA_READ_COUNT));
d1817 11
a1827 1
	    READ_REG(sc, ISES_DMA_WRITE_COUNT));
d1829 13
a1841 2
	printf ("DMA status register contains [%08x]\n", 
	    READ_REG(sc, ISES_DMA_STATUS));
@


1.8
log
@merge crypto/crypto{dev,}.h to crypto/cryptodev.h, to avoid name conflicts inside OpenSSL codebase
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.7 2001/06/12 15:40:32 niklas Exp $	*/
d466 1
a466 1
		crypto_register(sc->sc_cid, CRYPTO_3DES_CBC,
d468 8
a475 6
		crypto_register(sc->sc_cid, CRYPTO_DES_CBC, NULL, NULL, NULL);
		crypto_register(sc->sc_cid, CRYPTO_MD5_HMAC, NULL, NULL, NULL);
		crypto_register(sc->sc_cid, CRYPTO_SHA1_HMAC, NULL, NULL,
		    NULL);
		crypto_register(sc->sc_cid, CRYPTO_RIPEMD160_HMAC, NULL, NULL,
		    NULL);
@


1.7
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.6 2001/06/05 15:32:27 ho Exp $	*/
d46 1
a46 1
#include <crypto/crypto.h>
@


1.6
log
@memset/memcpy -> bzero/bcopy. Some KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.5 2001/06/04 13:07:19 ho Exp $	*/
d189 1
a189 1
	    &sc->sc_memh, &membase, &memsize)) {
@


1.5
log
@Some further work. No crypto yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.4 2001/03/28 20:02:59 angelos Exp $	*/
d242 1
a242 1
	memset (&isesstats, 0, sizeof(isesstats));
d520 1
a520 1
	memset(cq, 0, sizeof (struct ises_cmd));
d612 1
a612 1
				memset (sc->sc_lnau1_r, 0, 2048 / 8);
d625 1
a625 1
				memset (sc->sc_lnau1_r, 0, 2048 / 8);
d840 2
a841 2
			memcpy(ses, sc->sc_sessions, i);
			memset(sc->sc_sessions, 0, i);
d849 1
a849 1
	memset(ses, 0, sizeof(struct ises_session));
d859 3
a861 3
			memcpy(&ses->ses_deskey[0], enc->cri_key, 8);
			memcpy(&ses->ses_deskey[2], enc->cri_key, 8);
			memcpy(&ses->ses_deskey[4], enc->cri_key, 8);
d863 1
a863 1
			memcpy(&ses->ses_deskey[0], enc->cri_key, 24);
d883 1
a883 1
			memcpy(ses->ses_hminner, md5ctx.state,
d891 1
a891 1
			memcpy(ses->ses_hminner, sha1ctx.state,
d901 1
a901 1
			memcpy(ses->ses_hminner, rmd160ctx.state,
d915 1
a915 1
			memcpy(ses->ses_hmouter, md5ctx.state,
d923 1
a923 1
			memcpy(ses->ses_hmouter, sha1ctx.state,
d933 1
a933 1
			memcpy(ses->ses_hmouter, rmd160ctx.state,
d962 1
a962 1
	memset(&sc->sc_sessions[sesn], 0, sizeof(sc->sc_sessions[sesn]));
d1008 1
a1008 1
	memset(q, 0, sizeof(struct ises_q));
d1644 1
a1644 1
		memset(&bses, 0, sizeof bses);
@


1.4
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.3 2001/01/30 14:07:44 ho Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000 Håkan Olsson (ho@@crt.se)
a42 4
#include <vm/vm.h>
#include <vm/vm_extern.h>
#include <vm/pmap.h>
#include <machine/pmap.h>
d70 3
a72 1
int	ises_queue_cmd __P((struct ises_softc *, u_int32_t, u_int32_t *));
d82 2
d94 1
d103 12
d129 9
d167 1
d242 2
d258 3
a260 1

d450 3
a452 1
		    ISES_STAT_BCHU_OFHF | ISES_STAT_SW_OQSINC;
d497 2
a498 1
ises_queue_cmd(struct ises_softc *sc, u_int32_t cmd, u_int32_t *data)
d500 2
a501 1
	int p, len, s;
d504 2
a505 1

d513 12
d527 8
a534 2
	for (p = 0; p < len; p++)
		WRITE_REG(sc, ISES_A_IQD, *(data + p));
d549 1
d551 5
a555 1
	int cmd, len;
d565 9
d576 1
a576 1
			DPRINTF(("%s: cmd %d error %d\n", dv, cmd,
d578 14
a591 1
		} else
d593 3
d607 26
d634 14
a647 3
				sc->sc_omr = READ_REG(sc, ISES_A_OQD);
				DPRINTF(("%s: read sc->sc_omr [%08x]\n", dv,
				    sc->sc_omr));
d652 4
d657 1
d659 9
a667 6
	/* This will drain any remaining data and ACK this reponse. */
	while (len-- > 0)
		d = READ_REG(sc, ISES_A_OQD);
	WRITE_REG(sc, ISES_A_OQS, 0);
	if (oqs > 1)
		DELAY(1); /* Wait for firmware to decrement OQS (8 clocks) */
d676 4
d698 24
d723 1
a723 1
		DPRINTF(("ises_intr: BCHU_OAF bit set\n"));
d728 1
a728 1
		DPRINTF(("ises_intr: BCHU error\n"));
d733 1
a733 1
		DPRINTF(("ises_intr: BCHU output FIFO half full\n"));
d777 1
a777 1
	struct ises_session *ses = NULL;
d812 1
d816 2
a817 1
		if (ses == NULL)
d819 1
d823 1
d830 1
a830 1
		if (ses == NULL)  {
d835 2
a836 1
			if (ses == NULL)
d838 1
d877 2
a878 1
		if (mac->cri_alg == CRYPTO_MD5_HMAC) {
d885 2
a886 1
		} else if (mac->cri_alg == CRYPTO_SHA1_HMAC) {
d893 3
a895 1
		} else {
d903 1
d909 2
a910 1
		if (mac->cri_alg == CRYPTO_MD5_HMAC) {
d917 2
a918 1
		} else if (mac->cri_alg == CRYPTO_SHA1_HMAC) {
d925 3
a927 1
		} else {
d935 1
d1064 1
a1064 1
			q->q_ctx.pc_omrflags |= ISES_SOMR_BOMR_3DES;
d1066 2
a1067 2
			q->q_ctx.pc_omrflags |= ISES_SOMR_BOMR_DES;
		q->q_ctx.pc_omrflags |= ISES_SOMR_FMR_CBC;
d1070 1
a1070 1
			q->q_ctx.pc_omrflags |= ISES_SOMR_EDR; /* XXX */
d1073 1
a1073 1
				bcopy(enccrd->crd_iv, q->q_ctx.pc_iv, 8);
d1075 2
a1076 2
				q->q_ctx.pc_iv[0] = ses->ses_iv[0];
				q->q_ctx.pc_iv[1] = ses->ses_iv[1];
d1081 1
a1081 1
				    8, (caddr_t)q->q_ctx.pc_iv);
d1083 1
a1083 1
			q->q_ctx.pc_omrflags &= ~ISES_SOMR_EDR; /* XXX */
d1086 1
a1086 1
				bcopy(enccrd->crd_iv, q->q_ctx.pc_iv, 8);
d1089 1
a1089 1
				    8, (caddr_t)q->q_ctx.pc_iv);
d1092 6
a1097 6
		q->q_ctx.pc_deskey[0] = ses->ses_deskey[0];
		q->q_ctx.pc_deskey[1] = ses->ses_deskey[1];
		q->q_ctx.pc_deskey[2] = ses->ses_deskey[2];
		q->q_ctx.pc_deskey[3] = ses->ses_deskey[3];
		q->q_ctx.pc_deskey[4] = ses->ses_deskey[4];
		q->q_ctx.pc_deskey[5] = ses->ses_deskey[5];
d1099 2
a1100 2
		SWAP32(q->q_ctx.pc_iv[0]);
		SWAP32(q->q_ctx.pc_iv[1]);
d1108 1
a1108 1
			q->q_ctx.pc_omrflags |= ISES_HOMR_HFR_MD5;
d1111 1
a1111 1
			q->q_ctx.pc_omrflags |= ISES_HOMR_HFR_SHA1;
d1115 1
a1115 1
			q->q_ctx.pc_omrflags |= ISES_HOMR_HFR_RMD160;
d1119 13
a1131 13
		q->q_ctx.pc_hminner[0] = ses->ses_hminner[0];
		q->q_ctx.pc_hminner[1] = ses->ses_hminner[1];
		q->q_ctx.pc_hminner[2] = ses->ses_hminner[2];
		q->q_ctx.pc_hminner[3] = ses->ses_hminner[3];
		q->q_ctx.pc_hminner[4] = ses->ses_hminner[4];
		q->q_ctx.pc_hminner[5] = ses->ses_hminner[5];

		q->q_ctx.pc_hmouter[0] = ses->ses_hmouter[0];
		q->q_ctx.pc_hmouter[1] = ses->ses_hmouter[1];
		q->q_ctx.pc_hmouter[2] = ses->ses_hmouter[2];
		q->q_ctx.pc_hmouter[3] = ses->ses_hmouter[3];
		q->q_ctx.pc_hmouter[4] = ses->ses_hmouter[4];
		q->q_ctx.pc_hmouter[5] = ses->ses_hmouter[5];
d1158 1
a1158 1
	q->q_ctx.pc_offset = coffset >> 2;
d1321 5
d1375 1
a1375 1
	if (ises_queue_cmd(sc, cmd, &r))
d1412 1
a1412 1
		ises_queue_cmd(sc, cmd, &r);
a1429 1
	printf("\n");
d1454 1
a1454 1
	ises_queue_cmd(sc, cmd, &n);
d1527 408
@


1.4.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.4 2001/03/28 20:02:59 angelos Exp $	*/
@


1.4.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.4.4.1 2001/05/14 22:25:49 niklas Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000, 2001 Håkan Olsson (ho@@crt.se)
d43 4
d50 1
a50 1
#include <crypto/cryptodev.h>
a62 1
#include <dev/microcode/ises/ises_fw.h>
d74 1
a74 3
int	ises_queue_cmd __P((struct ises_softc *, u_int32_t, u_int32_t *, 
			    u_int32_t (*)(struct ises_softc *, 
					  struct ises_cmd *)));
a83 2
void	ises_bchu_switch_session __P((struct ises_softc *, 
				      struct ises_session *));
d85 2
a86 1
void	ises_read_dma __P((struct ises_softc *));
a93 1
/* XXX This should probably be (x) = htole32((x)) */
a101 12
#ifdef ISESDEBUG
void	ises_debug_init __P((struct ises_softc *));
void	ises_debug_2 __P((void));
void	ises_debug_loop __P((void *));
void	ises_showreg __P((void));
void	ises_debug_parse_omr __P((struct ises_softc *));
void	ises_debug_simple_cmd __P((struct ises_softc *, u_int32_t, u_int32_t));
struct ises_softc *ises_sc;
struct timeout ises_db_timeout;
int ises_db;
#endif

a115 9
struct ises_stats {
	u_int64_t	ibytes;
	u_int64_t	obytes;
	u_int32_t	ipkts;
	u_int32_t	opkts;
	u_int32_t	invalid;
	u_int32_t	nomem;
} isesstats;

d136 1
a144 1
	SIMPLEQ_INIT(&sc->sc_cmdq);
d166 1
a166 1
	    &sc->sc_memh, NULL, &memsize, 0)) {
d194 1
a194 1
	    0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &sc->sc_dmamap);
d202 1
a202 1
	if (bus_dmamem_alloc(sc->sc_dmat, ISES_B_DATASIZE, 1, 0, &seg, 1,
d209 3
a211 2
	if (bus_dmamem_map(sc->sc_dmat, &seg, nsegs, ISES_B_DATASIZE,
	    &sc->sc_dma_data, 0)) {
a218 2
	bzero(&isesstats, sizeof(isesstats));

d233 1
a233 3
#ifdef ISESDEBUG
	ises_debug_init(sc);
#endif
d239 2
a240 2
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)&sc->sc_dma_data,
		    sizeof sc->sc_dma_data);
d244 1
a244 1
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_dmamap);
d268 3
a270 3
	p = ISES_STAT_IDP_STATE(READ_REG(sc, ISES_A_STAT));
	DPRINTF (("%s: initstate %d, IDP state is %d \"%s\"\n", dv, 
		  sc->sc_initstate, p, ises_idp_state[p]));
d380 3
a382 2
		/* We failed. */
		goto fail;
d400 1
a400 1
		/* We can use firmware versions 1.x & 2.x */
d423 1
a423 3
		    ISES_STAT_BCHU_OFHF | ISES_STAT_SW_OQSINC |
		    ISES_STAT_LNAU_BUSY_1 | ISES_STAT_LNAU_ERR_1 |
		    ISES_STAT_LNAU_BUSY_2 | ISES_STAT_LNAU_ERR_2;
d437 1
a437 1
		crypto_register(sc->sc_cid, CRYPTO_3DES_CBC, 0, 0,
d439 6
a444 8
		crypto_register(sc->sc_cid, CRYPTO_DES_CBC, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(sc->sc_cid, CRYPTO_MD5_HMAC, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(sc->sc_cid, CRYPTO_SHA1_HMAC, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(sc->sc_cid, CRYPTO_RIPEMD160_HMAC, 0, 0,
		    NULL, NULL, NULL);
d468 1
a468 2
ises_queue_cmd(struct ises_softc *sc, u_int32_t cmd, u_int32_t *data, 
	       u_int32_t (*callback)(struct ises_softc *, struct ises_cmd *))
d470 1
a470 2
	struct ises_cmd *cq;
	int p, len, s, code;
a472 1
	code = (cmd >> 16) & 0xFF;
d474 1
a474 7
#ifdef ISESDEBUG
	if (code != ISES_CMD_HBITS) /* ... since this happens 100 times/s */
		DPRINTF(("%s: queuing cmd %d len %d\n", sc->sc_dv.dv_xname,
		    cmd, len));
#endif

	s = splnet();
a480 13
	cq = (struct ises_cmd *) 
	    malloc(sizeof (struct ises_cmd), M_DEVBUF, M_NOWAIT);
	if (cq == NULL) {
		splx(s);
		isesstats.nomem++;
		return (ENOMEM);
	}
	bzero(cq, sizeof (struct ises_cmd));
	cq->cmd_code = code;
	cq->cmd_cb = callback;
	cq->cmd_session = sc->sc_cursession;
	SIMPLEQ_INSERT_TAIL(&sc->sc_cmdq, cq, cmd_next);

d483 2
a484 8
	/* LNAU register data should be written in reverse order */
	if ((code >= ISES_CMD_LW_A_1 && code <= ISES_CMD_LW_U_1) || /* LNAU1 */
	    (code >= ISES_CMD_LW_A_2 && code <= ISES_CMD_LW_U_2))   /* LNAU2 */
		for (p = len - 1; p >= 0; p--)
			WRITE_REG(sc, ISES_A_IQD, *(data + p));
	else
		for (p = 0; p < len; p++)
			WRITE_REG(sc, ISES_A_IQD, *(data + p));
a485 1
	/* Signal 'command ready'. */
a498 2
	struct ises_cmd *cq;
	struct ises_session *ses;
d500 1
a500 5
	int cmd, len, c, s;

	r = READ_REG(sc, ISES_A_OQS);
	if (r > 1)
		DPRINTF(("%s:process_oqueue: OQS=%d\n", dv, r));
a509 11
		s = splnet();
		if (!SIMPLEQ_EMPTY(&sc->sc_cmdq)) {
			cq = SIMPLEQ_FIRST(&sc->sc_cmdq);
			SIMPLEQ_REMOVE_HEAD(&sc->sc_cmdq, cq, cmd_next);
			cq->cmd_rlen = len;
		} else {
			cq = NULL;
			DPRINTF(("%s:process_oqueue: cmd queue empty!\n", dv));
		}
		splx(s);

d512 1
a512 1
			DPRINTF(("%s:process_oqueue: cmd %d err %d\n", dv, cmd,
d514 1
a514 14
		} else {
			/* Use specified callback, if any */
			if (cq && cq->cmd_cb) {
				if (cmd == cq->cmd_code) {
					cq->cmd_cb(sc, cq);
					cmd = ISES_CMD_NONE;
				} else {
					DPRINTF(("%s:process_oqueue: expected"
					    " cmd %d, got %d\n", dv, 
					    cq->cmd_code, cmd));
					/* XXX Some error handling here? */
				}
			}

a515 3
			case ISES_CMD_NONE:
				break;

a526 26
			case ISES_CMD_LUPLOAD_1:
				/* Get result of LNAU 1 operation. */
				DPRINTF(("%s:process_oqueue: LNAU 1 result "
				     "upload (len=%d)\n", dv, len));
				sc->sc_lnau1_rlen = len;
				bzero(sc->sc_lnau1_r, 2048 / 8);
				while (len--) {
					/* first word is LSW */
					sc->sc_lnau1_r[len] = 
					    READ_REG(sc, ISES_A_OQD);
				}
				break;

			case ISES_CMD_LUPLOAD_2:
				/* Get result of LNAU 1 operation. */
				DPRINTF(("%s:process_oqueue: LNAU 2 result "
				     "upload (len=%d)\n", dv, len));
				sc->sc_lnau2_rlen = len;
				bzero(sc->sc_lnau1_r, 2048 / 8);
				while (len--) {
					/* first word is LSW */
					sc->sc_lnau2_r[len] = 
					    READ_REG(sc, ISES_A_OQD);
				}
				break;

d528 3
a530 35
				ses = &sc->sc_sessions[cq->cmd_session];
				ses->omr = READ_REG(sc, ISES_A_OQD);
				DPRINTF(("%s:process_oqueue: read OMR[%08x]\n",
				    dv, ses->omr));
#ifdef ISESDEBUG
				ises_debug_parse_omr(sc);
#endif
				break;

			case ISES_CMD_BSWITCH:
				DPRINTF(("%s:process_oqueue: BCHU_SWITCH\n"));
				/* Put switched BCHU session in cur session. */
				ses = &sc->sc_sessions[cq->cmd_session];
				for(c = 0; len > 0; len--, c++)
#if 0 /* Don't store the key, just drain the data */
					*((u_int32_t *)&ses + c) =
#endif
					    READ_REG(sc, ISES_A_OQD);

				sc->sc_switching = 0;
				ises_feed (sc);
				break;

			case ISES_CMD_BW_HMLR:
				/*
				 * This return indicates our homecooked
				 * session switch is complete. Start data
				 * feed.
				 */
				DPRINTF(("%s:process_oqueue: sesn switched\n",
				    dv));
				sc->sc_switching = 0;

				/* Retry/restart */
				ises_feed(sc);
a534 4
				DPRINTF(("%s:process_oqueue [cmd %d len %d]\n",
				    dv, cmd, len));
				if (cq && cq->cmd_cb) 
					len -= cq->cmd_cb(sc, cq);
a535 1
		}
d537 6
a542 9
		if (cq)
			free(cq, M_DEVBUF);
		
		/* This will drain any remaining data and ACK this reponse. */
		while (len-- > 0)
			d = READ_REG(sc, ISES_A_OQD);
		WRITE_REG(sc, ISES_A_OQS, 0);
		if (oqs > 1)
			DELAY(1); /* Wait for fw to decrement OQS (8 clocks) */
d550 1
a550 32
	u_int32_t ints, dma_status, cmd; 
	char *dv = sc->sc_dv.dv_xname;

	dma_status = READ_REG(sc, ISES_DMA_STATUS);

	if (!(dma_status & (ISES_DMA_STATUS_R_ERR | ISES_DMA_STATUS_W_ERR))) {
		if ((sc->sc_dma_mask & ISES_DMA_STATUS_R_RUN) != 0 &&
		    (dma_status & ISES_DMA_STATUS_R_RUN) == 0) {
			DPRINTF(("%s: DMA read complete\n", dv));

			bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 
			    BUS_DMASYNC_POSTREAD);

			/* XXX */

			WRITE_REG(sc, ISES_DMA_RESET, 0);
		}

		if ((sc->sc_dma_mask & ISES_DMA_STATUS_W_RUN) != 0 &&
		    (dma_status & ISES_DMA_STATUS_W_RUN) == 0) {
			DPRINTF(("%s: DMA write complete\n", dv));

			bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 
			    BUS_DMASYNC_POSTWRITE);

			WRITE_REG(sc, ISES_DMA_RESET, 0);
			ises_feed(sc);
		}
	} else {
		printf ("%s: DMA error\n", dv);
		WRITE_REG(sc, ISES_DMA_RESET, 0);
	}
d556 1
a556 2
	/* Clear all set intr bits. */
	WRITE_REG(sc, ISES_A_INTS, ints);
d565 1
a565 2
	/* Does the A-intf output queue have data we need to process? */
	if (ints & ISES_STAT_SW_OQSINC)
a566 23

	if (ints & ISES_STAT_LNAU_BUSY_1) {
		DPRINTF(("%s:ises_intr: LNAU 1 job complete\n", dv));
		/* upload LNAU 1 result (into sc->sc_lnau1_r) */
		cmd = ISES_MKCMD(ISES_CMD_LUPLOAD_1, 0);
		ises_queue_cmd(sc, cmd, NULL, NULL);
	}

	if (ints & ISES_STAT_LNAU_BUSY_2) {
		DPRINTF(("%s:ises_intr: LNAU 2 job complete\n", dv));
		/* upload LNAU 2 result (into sc->sc_lnau2_r) */
		cmd = ISES_MKCMD(ISES_CMD_LUPLOAD_2, 0);
		ises_queue_cmd(sc, cmd, NULL, NULL);
	}

	if (ints & ISES_STAT_LNAU_ERR_1) {
		DPRINTF(("%s:ises_intr: LNAU 1 error\n", dv));
		sc->sc_lnau1_rlen = -1;
	}

	if (ints & ISES_STAT_LNAU_ERR_2) {
		DPRINTF(("%s:ises_intr: LNAU 2 error\n", dv));
		sc->sc_lnau2_rlen = -1;
d570 1
a570 1
		DPRINTF(("%s:ises_intr: BCHU_OAF bit set\n", dv));
d575 1
a575 1
		DPRINTF(("%s:ises_intr: BCHU error\n", dv));
d580 1
a580 1
		DPRINTF(("%s:ises_intr: BCHU output FIFO half full\n", dv));
a595 6
	bus_dma_segment_t *ds = &sc->sc_dmamap->dm_segs[0];
	u_int32_t dma_status;
	int s;
#ifdef ISESDEBUG
	char *dv = sc->sc_dv.dv_xname;
#endif
d597 13
a609 6
	s = splnet();
	/* Anything to do? */
	if (SIMPLEQ_EMPTY(&sc->sc_queue) ||
	    (READ_REG(sc, ISES_A_STAT) & ISES_STAT_BCHU_IFF)) {
		splx(s);
		return (0);
a610 46

	/* Pick the first */
	q = SIMPLEQ_FIRST(&sc->sc_queue);
	splx(s);

	/* If we're currently switching sessions, we'll have to wait. */
	if (sc->sc_switching != 0) {
		DPRINTF(("%s:ises_feed: waiting for session switch\n", dv));
		return (0);
	}

	/* If on-chip data is not correct for this data, switch session. */
	if (sc->sc_cursession != q->q_sesn) {
		/* Session switch required */
		DPRINTF(("%s:ises_feed: initiating session switch\n", dv));
		ises_bchu_switch_session (sc, &q->q_session);
		sc->sc_cursession = q->q_sesn;
		return (0);
	}

	s = splnet();
	SIMPLEQ_REMOVE_HEAD(&sc->sc_queue, q, q_next);
	SIMPLEQ_INSERT_TAIL(&sc->sc_qchip, q, q_next);
	--sc->sc_nqueue;
	splx(s);

	if (q->q_crp->crp_flags & CRYPTO_F_IMBUF)
		bus_dmamap_load_mbuf(sc->sc_dmat, sc->sc_dmamap, 
		    q->q_src.mbuf, BUS_DMA_NOWAIT);
	else if (q->q_crp->crp_flags & CRYPTO_F_IOV)
		bus_dmamap_load_uio(sc->sc_dmat, sc->sc_dmamap, q->q_src.uio,
		    BUS_DMA_NOWAIT);
	/* ... else */	

	/* Start writing data to the ises. */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, BUS_DMASYNC_PREWRITE);
	
	DPRINTF(("%s:ises_feed: writing DMA\n", dv));

	WRITE_REG(sc, ISES_DMA_WRITE_START, ds->ds_addr);
	WRITE_REG(sc, ISES_DMA_WRITE_COUNT, ISES_DMA_WCOUNT(ds->ds_len));

	dma_status = READ_REG(sc, ISES_DMA_STATUS);
	dma_status |= ISES_DMA_CTRL_ILT | ISES_DMA_CTRL_RLINE;
	WRITE_REG(sc, ISES_DMA_CTRL, dma_status);

d624 1
a624 1
	struct ises_session *ses;
a628 3
#ifdef ISESDEBUG
	char *dv;
#endif
a639 3
#ifdef ISESDEBUG
	dv = sc->sc_dv.dv_xname;
#endif
a658 6
#ifdef ISESDEBUG
	printf ("%s:ises_newsession: mac=%p(%d) enc=%p(%d)\n",
	   dv, mac, (mac ? mac->cri_alg : -1), enc, (enc ? enc->cri_alg : -1));
#endif

	/* Allocate a new session */
d662 1
a662 2
		if (ses == NULL) {
			isesstats.nomem++;
d664 1
a664 2
		}
		sc->sc_cursession = sesn = 0;
a666 1
		ses = NULL;
d668 1
a668 1
			if (sc->sc_sessions[sesn].omr == 0) {
a669 1
				sc->sc_cursession = sesn;
d673 1
a673 1
		if (ses == NULL) {
d678 1
a678 2
			if (ses == NULL) {
				isesstats.nomem++;
a679 1
			}
d681 2
a682 2
			bcopy(sc->sc_sessions, ses, i);
			bzero(sc->sc_sessions, i);
a685 1
			sc->sc_cursession = sc->sc_nsessions;
d690 2
a691 7
	DPRINTF(("%s:ises_newsession: nsessions=%d cursession=%d\n", dv,
	    sc->sc_nsessions, sc->sc_cursession));

	bzero(ses, sizeof(struct ises_session));

	/* Select data path through B-interface. */
	ses->omr |= ISES_SELR_BCHU_DIS;
d696 1
a696 1
		get_random_bytes(ses->sccr, sizeof(ses->sccr));
d700 3
a702 3
			bcopy(enc->cri_key, &ses->kr[0], 8);
			bcopy(enc->cri_key, &ses->kr[2], 8);
			bcopy(enc->cri_key, &ses->kr[4], 8);
d704 1
a704 1
			bcopy(enc->cri_key, &ses->kr[0], 24);
d706 6
a711 6
		SWAP32(ses->kr[0]);
		SWAP32(ses->kr[1]);
		SWAP32(ses->kr[2]);
		SWAP32(ses->kr[3]);
		SWAP32(ses->kr[4]);
		SWAP32(ses->kr[5]);
d718 1
a718 2
		switch (mac->cri_alg) {
		case CRYPTO_MD5_HMAC:
d723 3
a725 3
			MD5Final((u_int8_t *)&ses->cvr, &md5ctx);
			break;
		case CRYPTO_SHA1_HMAC:
d730 3
a732 4
			SHA1Final((u_int8_t *)ses->cvr, &sha1ctx);
			break;
		case CRYPTO_RIPEMD160_HMAC:
		default:
d738 2
a739 2
			RMD160Final((u_int8_t *)ses->cvr, &rmd160ctx);
			break;
d745 1
a745 2
		switch (mac->cri_alg) {
		case CRYPTO_MD5_HMAC:
d748 1
a748 1
			MD5Update(&md5ctx, hmac_opad_buffer, HMAC_BLOCK_LEN -
d750 1
a750 1
			MD5Update(&md5ctx, (u_int8_t *)ses->cvr,
d752 1
a752 3
			MD5Final((u_int8_t *)ses->cvr, &md5ctx);
			break;
		case CRYPTO_SHA1_HMAC:
d755 1
a755 1
			SHA1Update(&sha1ctx, hmac_opad_buffer, HMAC_BLOCK_LEN -
d757 1
a757 1
			SHA1Update(&sha1ctx, (u_int8_t *)ses->cvr,
d759 1
a759 4
			SHA1Final((u_int8_t *)ses->cvr, &sha1ctx);
			break;
		case CRYPTO_RIPEMD160_HMAC:
		default:
d763 1
a763 1
			RMD160Update(&rmd160ctx, hmac_opad_buffer,
d765 1
a765 1
			RMD160Update(&rmd160ctx, (u_int8_t *)ses->cvr, 
a766 2
			RMD160Final((u_int8_t *)ses->cvr, &rmd160ctx);
			break;
a772 1
	DPRINTF(("%s:ises_newsession: done\n", dv));
d777 3
a779 1
/* Deallocate a session. */
d793 1
a793 5

	DPRINTF(("%s:ises_freesession: freeing session %d\n",
	    sc->sc_dv.dv_xname, sesn));

	bzero(&sc->sc_sessions[sesn], sizeof(sc->sc_sessions[sesn]));
a797 1
/* Called by the crypto framework, crypto(9). */
d801 1
d806 4
a809 5
	int card, s, err = EINVAL;
	int encoffset, macoffset, cpskip, sskip, dskip, stheend, dtheend;
	int cpoffset, coffset, nicealign;
#ifdef ISESDEBUG
	char *dv;
d811 3
d819 2
a820 1
	if (card >= ises_cd.cd_ndevs || ises_cd.cd_devs[card] == NULL)
d822 1
a824 3
#ifdef ISESDEBUG
	dv = sc->sc_dv.dv_xname;
#endif
d829 2
a830 1
		goto memerr;
d835 5
a839 3
	if (q == NULL)
		goto memerr;
	bzero(q, sizeof(struct ises_q));
d844 1
a844 1
	DPRINTF(("%s:ises_process: session %d selected\n", dv, q->q_sesn));
d850 2
a851 5
		q->q_src.mbuf = (struct mbuf *)crp->crp_buf;
		q->q_dst.mbuf = (struct mbuf *)crp->crp_buf;
	} else if (crp->crp_flags & CRYPTO_F_IOV) {
		q->q_src.uio = (struct uio *)crp->crp_buf;
		q->q_dst.uio = (struct uio *)crp->crp_buf;
d853 1
a853 1
		/* XXX for now... */
d865 1
d889 1
a889 3

	/* Select data path through B-interface. */
	q->q_session.omr |= ISES_SELR_BCHU_DIS;
a893 1
		/* Select algorithm */
d895 1
a895 1
			q->q_session.omr |= ISES_SOMR_BOMR_3DES;
d897 2
a898 4
			q->q_session.omr |= ISES_SOMR_BOMR_DES;

		/* Set CBC mode */
		q->q_session.omr |= ISES_SOMR_FMR_CBC;
d901 1
a901 2
			/* Set encryption bit */
			q->q_session.omr |= ISES_SOMR_EDR;
d904 1
a904 1
				bcopy(enccrd->crd_iv, q->q_session.sccr, 8);
d906 2
a907 2
				q->q_session.sccr[0] = ses->sccr[0];
				q->q_session.sccr[1] = ses->sccr[1];
d910 3
a912 11
			if ((enccrd->crd_flags & CRD_F_IV_PRESENT) == 0) {
				if (crp->crp_flags & CRYPTO_F_IMBUF)
					m_copyback(q->q_src.mbuf,
					    enccrd->crd_inject, 8,
					    (caddr_t)q->q_session.sccr);
				else if (crp->crp_flags & CRYPTO_F_IOV)
					cuio_copyback(q->q_src.uio,
					    enccrd->crd_inject, 8,
					    (caddr_t)q->q_session.sccr);
				/* XXX else ... */
			}
d914 1
a914 2
			/* Clear encryption bit == decrypt mode */
			q->q_session.omr &= ~ISES_SOMR_EDR;
d917 4
a920 9
				bcopy(enccrd->crd_iv, q->q_session.sccr, 8);
			else if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copydata(q->q_src.mbuf, enccrd->crd_inject,
				    8, (caddr_t)q->q_session.sccr);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copydata(q->q_src.uio,
				    enccrd->crd_inject, 8,
				    (caddr_t)q->q_session.sccr);
			/* XXX else ... */
d923 6
a928 6
		q->q_session.kr[0] = ses->kr[0];
		q->q_session.kr[1] = ses->kr[1];
		q->q_session.kr[2] = ses->kr[2];
		q->q_session.kr[3] = ses->kr[3];
		q->q_session.kr[4] = ses->kr[4];
		q->q_session.kr[5] = ses->kr[5];
d930 2
a931 2
		SWAP32(q->q_session.sccr[0]);
		SWAP32(q->q_session.sccr[1]);
a936 1
		/* Select algorithm */
d939 1
a939 1
			q->q_session.omr |= ISES_HOMR_HFR_MD5;
d942 1
a942 1
			q->q_session.omr |= ISES_HOMR_HFR_SHA1;
d946 1
a946 1
			q->q_session.omr |= ISES_HOMR_HFR_RMD160;
d950 13
a962 5
		q->q_session.cvr[0] = ses->cvr[0];
		q->q_session.cvr[1] = ses->cvr[1];
		q->q_session.cvr[2] = ses->cvr[2];
		q->q_session.cvr[3] = ses->cvr[3];
		q->q_session.cvr[4] = ses->cvr[4];
d971 1
d989 40
a1028 1
	q->q_offset = coffset >> 2;
d1030 4
a1033 10
#if 0
	/* XXX not sure about this, in bus_dma context */
	if (crp->crp_flags & CRYPTO_F_IMBUF)
		q->q_src_l = mbuf2pages(q->q_src.mbuf, &q->q_src_npa,
		    &q->q_src_packp, &q->q_src_packl, 1, &nicealign);
	else if (crp->crp_flags & CRYPTO_F_IOV)
		q->q_src_l = iov2pages(q->q_src.uio, &q->q_src_npa,
		    &q->q_src_packp, &q->q_src_packl, 1, &nicealign);
	/* XXX else */
#endif
d1035 2
a1036 2
	if (q->q_src_l == 0)
		goto memerr;
d1038 2
a1039 1
	/* XXX ... */
d1042 1
a1042 1
		/* XXX ... */
d1049 1
a1049 1
			if (q->q_src.mbuf->m_flags & M_PKTHDR) {
d1051 1
a1051 1
				M_DUP_PKTHDR(m, q->q_src.mbuf);
d1057 4
a1060 2
			if (m == NULL)
				goto memerr;
d1075 2
a1076 1
						goto memerr;
d1091 2
a1092 4
			q->q_dst.mbuf = top;
#if notyet
			ubsec_mcopy(q->q_src.mbuf, q->q_dst.mbuf, cpskip, cpoffset);
#endif
d1094 4
a1097 1
			q->q_dst.mbuf = q->q_src.mbuf;
d1100 40
a1139 3
		/* XXX ? */
		q->q_dst_l = mbuf2pages(q->q_dst.mbuf, &q->q_dst_npa,
		    &q->q_dst_packp, &q->q_dst_packl, 1, NULL);
a1142 2
	DPRINTF(("%s:ises_process: queueing request\n", dv));

d1146 1
a1147 1
	ises_feed(sc);
a1150 3
memerr:
	err = ENOMEM;
	isesstats.nomem++;
a1151 6
	DPRINTF(("%s:ises_process: an error occurred, err=%d, q=%p\n", dv, 
		 err, q));

	if (err == EINVAL)
		isesstats.invalid++;

d1153 2
a1154 2
		if (q->q_src.mbuf != q->q_dst.mbuf)
			m_freem(q->q_dst.mbuf);
a1166 2
	struct ises_softc *sc = q->q_sc;
	u_int8_t *sccr;
d1168 3
a1170 20
	if ((crp->crp_flags & CRYPTO_F_IMBUF) && 
	    (q->q_src.mbuf != q->q_dst.mbuf)) {
		m_freem(q->q_src.mbuf);
		crp->crp_buf = (caddr_t)q->q_dst.mbuf;
	}

	if (q->q_session.omr & ISES_SOMR_EDR) {
		/* Copy out IV after encryption. */
		sccr = (u_int8_t *)&sc->sc_sessions[q->q_sesn].sccr;
		for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
			if (crd->crd_alg != CRYPTO_DES_CBC &&
			    crd->crd_alg != CRYPTO_3DES_CBC)
				continue;
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copydata((struct mbuf *)crp->crp_buf,
				    crd->crd_skip + crd->crd_len - 8, 8, sccr);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copydata((struct uio *)crp->crp_buf,
				    crd->crd_skip + crd->crd_len - 8, 8, sccr);
		}
d1178 2
a1179 6
		if (crp->crp_flags & CRYPTO_F_IMBUF)
			m_copyback((struct mbuf *)crp->crp_buf,
			   crd->crd_inject, 12, (u_int8_t *)q->q_macbuf);
		else if (crp->crp_flags & CRYPTO_F_IOV)
			bcopy((u_int8_t *)q->q_macbuf, crp->crp_mac, 12);
		/* XXX else ... */
a1183 2
	DPRINTF(("%s:ises_callback: calling crypto_done\n",
	    sc->sc_dv.dv_xname));
d1201 1
a1201 1
	if (ises_queue_cmd(sc, cmd, &r, NULL))
d1238 1
a1238 1
		ises_queue_cmd(sc, cmd, &r, NULL);
d1256 1
d1281 1
a1281 1
	ises_queue_cmd(sc, cmd, &n, NULL);
a1353 452

void
ises_bchu_switch_session (struct ises_softc *sc, struct ises_session *ss)
{
	/* It appears that the BCHU_SWITCH_SESSION command is broken. */
	/* We have to work around it. */
	
	u_int32_t cmd;

	/* Mark 'switch' in progress. */
	sc->sc_switching = 1;

	/* Write the key. */
	cmd = ISES_MKCMD(ISES_CMD_BW_KR0, 2);
	ises_queue_cmd(sc, cmd, &ss->kr[4], NULL);
	cmd = ISES_MKCMD(ISES_CMD_BW_KR1, 2);
	ises_queue_cmd(sc, cmd, &ss->kr[2], NULL);
	cmd = ISES_MKCMD(ISES_CMD_BW_KR2, 2);
	ises_queue_cmd(sc, cmd, &ss->kr[0], NULL);

	/* Write OMR - Operation Method Register, clears SCCR+CVR+DBCR+HMLR */
	cmd = ISES_MKCMD(ISES_CMD_BW_OMR, 1);
	ises_queue_cmd(sc, cmd, &ss->omr, NULL);

	/* Write SCCR - Symmetric Crypto Chaining Register (IV) */
	cmd = ISES_MKCMD(ISES_CMD_BW_SCCR, 1);
	ises_queue_cmd(sc, cmd, &ss->sccr[0], NULL);

	/* Write CVR - Chaining Variables Register (hash state) */
	cmd = ISES_MKCMD(ISES_CMD_BW_SCCR, 5);
	ises_queue_cmd(sc, cmd, &ss->cvr[0], NULL);

	/* Write DBCR - Data Block Count Register */
	cmd = ISES_MKCMD(ISES_CMD_BW_SCCR, 2);
	ises_queue_cmd(sc, cmd, &ss->dbcr[0], NULL);

	/* Write HMLR - Hash Message Length Register */
	cmd = ISES_MKCMD(ISES_CMD_BW_HMLR, 2);
	ises_queue_cmd(sc, cmd, &ss->hmlr[0], NULL);
}

/* XXX Currently unused. */
void
ises_read_dma (struct ises_softc *sc)
{
	bus_dma_segment_t *ds = &sc->sc_dmamap->dm_segs[0];
	u_int32_t dma_status;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, BUS_DMASYNC_PREREAD);

	WRITE_REG(sc, ISES_DMA_READ_START, ds->ds_addr);
	WRITE_REG(sc, ISES_DMA_READ_START, ISES_DMA_RCOUNT(ds->ds_len));

	dma_status = READ_REG(sc, ISES_DMA_STATUS);
	dma_status |= ISES_DMA_CTRL_ILT | ISES_DMA_CTRL_WRITE;
	WRITE_REG(sc, ISES_DMA_CTRL, dma_status);
}

#ifdef ISESDEBUG
/*
 * Development code section below here.
 */

void
ises_debug_init (struct ises_softc *sc)
{
	ises_sc = sc;
	ises_db = 0;
	timeout_set (&ises_db_timeout, ises_debug_loop, sc);
	timeout_add (&ises_db_timeout, 100);
	printf ("ises0: ISESDEBUG active (ises_sc = %p)\n", ises_sc);
}

void
ises_debug_2 (void)
{
	timeout_set (&ises_db_timeout, ises_debug_loop, ises_sc);
	timeout_add (&ises_db_timeout, 100);
	printf ("ises0: another debug timeout scheduled!\n");
}

void
ises_debug_simple_cmd (struct ises_softc *sc, u_int32_t code, u_int32_t d)
{
	u_int32_t cmd, data;
	
	cmd = ISES_MKCMD(code, (d ? 1 : 0));
	data = d;
	ises_queue_cmd(sc, cmd, &d, NULL);
}

void
ises_debug_loop (void *v)
{
	struct ises_softc *sc = (struct ises_softc *)v;
	struct ises_session ses;
	u_int32_t cmd, stat;
	int i;

	if (ises_db)
		printf ("ises0: ises_db = %d  sc = %p\n", ises_db, sc);

	timeout_add (&ises_db_timeout, 300); /* Every 3 secs */

	stat = READ_REG(sc, ISES_A_OQS);
	cmd  = READ_REG(sc, ISES_A_IQS);
	if (stat || cmd)
		printf ("ises0: IQS=%d OQS=%d / IQF=%d OQF=%d\n",
		    cmd, stat, READ_REG(sc, ISES_A_IQF),
		    READ_REG(sc, ISES_A_OQF));
	
	switch (ises_db) {
	default: 
		/* 0 - do nothing (just loop) */
		break;
	case 1:
		/* Just dump register info */
		ises_showreg();
		break;
	case 2:
		/* Reset LNAU 1 registers */
		ises_debug_simple_cmd(sc, ISES_CMD_LRESET_1, 0);
		
		/* Compute R = (141 * 5623) % 117 (R should be 51 (0x33)) */
		ises_debug_simple_cmd(sc, ISES_CMD_LW_A_1, 141);
		ises_debug_simple_cmd(sc, ISES_CMD_LW_B_1, 5623);
		ises_debug_simple_cmd(sc, ISES_CMD_LW_N_1, 117);
		
		/* Launch LNAU operation. */
		ises_debug_simple_cmd(sc, ISES_CMD_LMULMOD_1, 0);
		break;
	case 3:
		/* Read result LNAU_1 R register (should not be necessary) */
		ises_debug_simple_cmd(sc, ISES_CMD_LUPLOAD_1, 0);
		break;
	case 4:
		/* Print result */
		printf ("LNAU_1 R length = %d\n", sc->sc_lnau1_rlen);
		for (i = 0; i < sc->sc_lnau1_rlen; i++)
			printf ("W%02d-[%08x]-(%u)\t%s", i, sc->sc_lnau1_r[i],
			    sc->sc_lnau1_r[i], (i%4)==3 ? "\n" : "");
		printf ("%s", (i%4) ? "\n" : "");
		break;
	case 5:
		/* Crypto. */

		/* Load BCHU session data */
		bzero(&ses, sizeof ses);
		ses.kr[0] = 0xD0;
		ses.kr[1] = 0xD1;
		ses.kr[2] = 0xD2;
		ses.kr[3] = 0xD3;
		ses.kr[4] = 0xD4;
		ses.kr[5] = 0xD5;

		/* cipher data out is hash in, SHA1, 3DES, encrypt, ECB */
		ses.omr = ISES_SELR_BCHU_HISOF | ISES_HOMR_HFR_SHA1 |
		    ISES_SOMR_BOMR_3DES | ISES_SOMR_EDR | ISES_SOMR_FMR_ECB;

#if 1
		printf ("Queueing home-cooked session switch\n");
		ises_bchu_switch_session(sc, &ses);
#else /* switch session does not appear to work - it never returns */
		printf ("Queueing BCHU session switch\n");
		cmd = ISES_MKCMD(ISES_CMD_BSWITCH, sizeof ses / 4);
		printf ("session is %d 32bit words (== 18 ?), cmd = [%08x]\n", 
			sizeof ses / 4, cmd);
		ises_queue_cmd(sc, cmd, (u_int32_t *)&ses, NULL);
#endif
		
		break;
	case 96:
		printf ("Stopping HRNG data collection\n");
		timeout_del(&sc->sc_timeout);
		break;
	case 97:
		printf ("Restarting HRNG data collection\n");
		if (!timeout_pending(&sc->sc_timeout))
			timeout_add(&sc->sc_timeout, hz);
		break;
	case 98:
		printf ("Resetting (wait >1s before cont.)\n");
		stat = ISES_BO_STAT_HWRESET;
		WRITE_REG(sc, ISES_BO_STAT, stat);
		stat &= ~ISES_BO_STAT_HWRESET;
		WRITE_REG(sc, ISES_BO_STAT, stat);
		break;
	case 99:
		printf ("Resetting everything!\n");
		if (timeout_pending(&sc->sc_timeout))
			timeout_del(&sc->sc_timeout);
		timeout_set(&sc->sc_timeout, ises_initstate, sc);
		sc->sc_initstate = 0;
		ises_initstate(sc);
		break;
	}
	
	ises_db = 0; 
}

void
ises_showreg (void)
{
	struct ises_softc *sc = ises_sc;
	u_int32_t stat, cmd;
	
	/* Board register */
	
	printf ("Board register: ");
	stat = READ_REG(sc, ISES_BO_STAT);
	
	if (stat & ISES_BO_STAT_LOOP)
		printf ("LoopMode ");
	if (stat & ISES_BO_STAT_TAMPER)
		printf ("Tamper ");
	if (stat & ISES_BO_STAT_POWERDOWN)
		printf ("PowerDown ");
	if (stat & ISES_BO_STAT_ACONF)
		printf ("16bitA-IF ");
	if (stat & ISES_BO_STAT_HWRESET)
		printf ("HWReset");
	if (stat & ISES_BO_STAT_AIRQ)
		printf ("A-IFintr");
	printf("\n");
	
	/* A interface */
	
	printf ("A Interface STAT register: \n\tLNAU-[");
	stat = READ_REG(sc, ISES_A_STAT);
	if (stat & ISES_STAT_LNAU_MASKED)
		printf ("masked");
	else {
		if (stat & ISES_STAT_LNAU_BUSY_1)
			printf ("busy1 ");
		if (stat & ISES_STAT_LNAU_ERR_1)
			printf ("err1 ");
		if (stat & ISES_STAT_LNAU_BUSY_2)
			printf ("busy2 ");
		if (stat & ISES_STAT_LNAU_ERR_2)
			printf ("err2 ");
	}
	printf ("]\n\tBCHU-[");
	
	if (stat & ISES_STAT_BCHU_MASKED)
		printf ("masked");
	else {
		if (stat & ISES_STAT_BCHU_BUSY)
			printf ("busy ");
		if (stat & ISES_STAT_BCHU_ERR)
			printf ("err ");
		if (stat & ISES_STAT_BCHU_SCIF)
			printf ("cr-inop ");
		if (stat & ISES_STAT_BCHU_HIF)
			printf ("ha-inop ");
		if (stat & ISES_STAT_BCHU_DDB)
			printf ("dscd-data ");
		if (stat & ISES_STAT_BCHU_IRF)
			printf ("inp-req ");
		if (stat & ISES_STAT_BCHU_OAF)
			printf ("out-avail ");
		if (stat & ISES_STAT_BCHU_DIE)
			printf ("inp-enabled ");
		if (stat & ISES_STAT_BCHU_UE)
			printf ("ififo-empty ");
		if (stat & ISES_STAT_BCHU_IFE)
			printf ("ififo-half ");
		if (stat & ISES_STAT_BCHU_IFHE)
			printf ("ififo-full ");
		if (stat & ISES_STAT_BCHU_OFE)
			printf ("ofifo-empty ");
		if (stat & ISES_STAT_BCHU_OFHF)
			printf ("ofifo-half ");
		if (stat & ISES_STAT_BCHU_OFF)
			printf ("ofifo-full ");
	}
	printf ("] \n\tmisc-[");
	
	if (stat & ISES_STAT_HW_DA)
		printf ("downloaded-appl ");
	if (stat & ISES_STAT_HW_ACONF)
		printf ("A-IF-conf ");
	if (stat & ISES_STAT_SW_WFOQ)
		printf ("OQ-wait ");
	if (stat & ISES_STAT_SW_OQSINC)
		printf ("OQS-increased ");
	printf ("]\n\t");
	
	if (stat & ISES_STAT_HW_DA)
		printf ("SW-mode is \"%s\"", 
		    ises_sw_mode[ISES_STAT_SW_MODE(stat)]);
	else
		printf ("LDP-state is \"%s\"", 
		    ises_idp_state[ISES_STAT_IDP_STATE(stat)]);
	printf ("\n");

	printf ("\tOQS = %d\n\tIQS = %d\n", READ_REG(sc, ISES_A_OQS),
	    READ_REG(sc, ISES_A_IQS));
	
	/* B interface */
	
	printf ("B-interface status register contains [%08x]\n", 
	    READ_REG(sc, ISES_B_STAT));
	
	/* DMA */
	
	printf ("DMA read starts at 0x%x, length %d bytes\n", 
	    READ_REG(sc, ISES_DMA_READ_START), 
	    READ_REG(sc, ISES_DMA_READ_COUNT) >> 16);
	
	printf ("DMA write starts at 0x%x, length %d bytes\n",
	    READ_REG(sc, ISES_DMA_WRITE_START),
	    READ_REG(sc, ISES_DMA_WRITE_COUNT) & 0x00ff);

	stat = READ_REG(sc, ISES_DMA_STATUS);
	printf ("DMA status register contains [%08x]\n", stat);

	if (stat & ISES_DMA_CTRL_ILT)
		printf (" -- Ignore latency timer\n");
	if (stat & 0x0C000000)
		printf (" -- PCI Read - multiple\n");
	else if (stat & 0x08000000)
		printf (" -- PCI Read - line\n");

	if (stat & ISES_DMA_STATUS_R_RUN)
		printf (" -- PCI Read running/incomplete\n");
	else
		printf (" -- PCI Read complete\n");
	if (stat & ISES_DMA_STATUS_R_ERR)
		printf (" -- PCI Read DMA Error\n");

	if (stat & ISES_DMA_STATUS_W_RUN)
		printf (" -- PCI Write running/incomplete\n");
	else
		printf (" -- PCI Write complete\n");
	if (stat & ISES_DMA_STATUS_W_ERR)
		printf (" -- PCI Write DMA Error\n");

	/* OMR / HOMR / SOMR */
	
	/*
	 * All these means throwing a cmd on to the A-interface, and then
	 * reading the result.
	 *
	 * Currently, put debug output in process_oqueue...
	 */
	
	printf ("Queueing Operation Method Register (OMR) READ cmd...\n");
	cmd = ISES_MKCMD(ISES_CMD_BR_OMR, 0);
	ises_queue_cmd(sc, cmd, NULL, NULL);
}

void
ises_debug_parse_omr (struct ises_softc *sc)
{
	u_int32_t omr = sc->sc_sessions[sc->sc_cursession].omr;
	
	printf ("SELR : ");
	if (omr & ISES_SELR_BCHU_EH)
		printf ("cont-on-error ");
	else
		printf ("stop-on-error ");
	
	if (omr & ISES_SELR_BCHU_HISOF)
		printf ("HU-input-is-SCU-output ");
	
	if (omr & ISES_SELR_BCHU_DIS)
		printf ("data-interface-select=B ");
	else
		printf ("data-interface-select=DataIn/DataOut ");
	
	printf ("\n");
	
	printf ("HOMR : ");
	if (omr & ISES_HOMR_HMTR)
		printf ("expect-padded-hash-msg ");
	else
		printf ("expect-plaintext-hash-msg ");
	
	printf ("ER=%d ", (omr & ISES_HOMR_ER) >> 20); /* ick */
	
	printf ("HFR=");
	switch (omr & ISES_HOMR_HFR) {
	case ISES_HOMR_HFR_NOP:
		printf ("inactive ");
		break;
	case ISES_HOMR_HFR_MD5:
		printf ("MD5 ");
		break;
	case ISES_HOMR_HFR_RMD160:
		printf ("RMD160 ");
		break;
	case ISES_HOMR_HFR_RMD128:
		printf ("RMD128 ");
		break;
	case ISES_HOMR_HFR_SHA1:
		printf ("SHA-1 ");
		break;
	default:
		printf ("reserved! ");
		break;
	}
	printf ("\nSOMR : ");
	
	switch (omr & ISES_SOMR_BOMR) {
	case ISES_SOMR_BOMR_NOP:
		printf ("NOP ");
		break;
	case ISES_SOMR_BOMR_TRANSPARENT:
		printf ("transparent ");
		break;
	case ISES_SOMR_BOMR_DES:
		printf ("DES ");
		break;
	case ISES_SOMR_BOMR_3DES2:
		printf ("3DES-2 ");
		break;
	case ISES_SOMR_BOMR_3DES:
		printf ("3DES-3 ");
		break;
	default:
		if (omr & ISES_SOMR_BOMR_SAFER)
			printf ("SAFER ");
		else
			printf ("reserved! ");
		break;
	}
	
	if (omr & ISES_SOMR_EDR)
		printf ("mode=encrypt ");
	else
		printf ("mode=decrypt ");
	
	switch (omr & ISES_SOMR_FMR) {
	case ISES_SOMR_FMR_ECB:
		printf ("ECB");
		break;
	case ISES_SOMR_FMR_CBC:
		printf ("CBC");
		break;
	case ISES_SOMR_FMR_CFB64:
		printf ("CFB64");
		break;
	case ISES_SOMR_FMR_OFB64:
		printf ("OFB64");
		break;
	default:
		/* Nada */
	}
	printf ("\n");
}

#endif /* ISESDEBUG */
@


1.4.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.4.4.2 2001/07/04 10:42:34 niklas Exp $	*/
d83 2
a84 3
int	ises_bchu_switch_session __P((struct ises_softc *, 
				      struct ises_session *, int));
u_int32_t ises_bchu_switch_final __P((struct ises_softc *, struct ises_cmd *));
a120 6
/* XXX Disable HRNG while debugging. */
#define ISES_HRNG_DISABLED

/* Maximum number of times we try to download the firmware. */
#define ISES_MAX_DOWNLOAD_RETRIES	3

d195 2
a196 1
	if (pci_intr_map(pa, &ih)) {
d254 2
a255 2
	startuphook_establish(ises_initstate, sc);

a289 1
	static int retry_count = 0; /* XXX Should be in softc */
d291 1
a291 1
	ticks = hz * 3 / 2; /* 1.5s */ 
d294 1
a294 1
	DPRINTF(("%s: initstate %d, IDP state is %d \"%s\"\n", dv, 
a298 6
		/* Called by dostartuphooks(9). */
		timeout_set(&sc->sc_timeout, ises_initstate, sc);

		/* FALLTHROUGH */
		sc->sc_initstate++;
	case 1:
a306 9
#if 1
		else {
			/* Power down the chip for sane init, then rerun. */
			stat |= ISES_BO_STAT_POWERDOWN;
			WRITE_REG(sc, ISES_BO_STAT, stat);
			sc->sc_initstate--; /* Rerun state 1. */
			break;
		}
#else
a308 1
#endif
d310 1
a310 1
	case 2:
d327 1
a327 1
	case 3:
d337 1
a337 1
			sc->sc_initstate += 3; /* Next step --> 7 */
a342 11
		 */

		p = ISES_STAT_IDP_STATE(READ_REG(sc, ISES_A_STAT));
		if (p == ISES_IDP_WFPL) {
			/* We're ready to download. */
			ticks = 1;
			sc->sc_initstate += 2; /* Next step --> 6 */
			break;
		}

		/*
d353 1
a353 1
	case 4:
d361 1
a361 1
	case 5:
d366 1
a366 1
		/* Again we need to wait a second for selftests. */
d369 1
a369 1
	case 6:
d376 1
a376 8
		if (READ_REG(sc, ISES_A_IQF) < 4 || p != ISES_IDP_WFPL) {
			if (retry_count++ < ISES_MAX_DOWNLOAD_RETRIES) {
				/* Retry download. */
				sc->sc_initstate -= 5; /* Next step --> 2 */
				ticks = 1;
				break;
			}
			retry_count = 0;
d398 1
a398 1
	case 7:
d408 1
a408 1
	case 8:
d462 2
a463 1
		p = crypto_register(sc->sc_cid, CRYPTO_3DES_CBC, 0, 0,
d465 1
a465 1
		p |= crypto_register(sc->sc_cid, CRYPTO_DES_CBC, 0, 0,
d467 1
a467 1
		p |= crypto_register(sc->sc_cid, CRYPTO_MD5_HMAC, 0, 0,
d469 1
a469 1
		p |= crypto_register(sc->sc_cid, CRYPTO_SHA1_HMAC, 0, 0,
d471 1
a471 1
		p |= crypto_register(sc->sc_cid, CRYPTO_RIPEMD160_HMAC, 0, 0,
d473 1
a473 2
		if (p)
			printf("%s: could not register all algorithms\n", dv);
d507 2
a508 2
		DPRINTF(("%s: queueing cmd 0x%x len %d\n", sc->sc_dv.dv_xname,
		    code, len));
d585 3
a587 7
			/* Ouch. This command generated an error */
			DPRINTF(("%s:process_oqueue: cmd 0x%x err %d\n", dv, 
			    cmd, (r & ISES_RC_MASK)));
			/* Abort any running session switch to force a retry.*/
			sc->sc_switching = 0;
			/* Return to CMD mode. This will reset all queues. */
			(void)ises_assert_cmd_mode(sc);
d596 1
a596 1
					    " cmd 0x%x, got 0x%x\n", dv, 
a653 1
				/* XXX Currently BSWITCH does not work. */
d668 6
a673 2
				/* XXX Obsoleted by ises_bchu_switch_final */
				DPRINTF(("%s:process_oqueue: CMD_BW_HMLR !?\n",
d675 4
d683 1
a683 1
				DPRINTF(("%s:process_oqueue cmd 0x%x len %d\n",
d719 1
a719 1
			/* XXX Pick up and return the data.*/
d723 1
d740 1
a740 2
	if (!(ints & sc->sc_intrmask)) {
		DPRINTF (("%s: other intr mask [%08x]\n", ints));
a741 1
	}
d783 1
a783 2
		/* Read DMA data from B-interface. */
		ises_read_dma (sc);
a814 3
	DPRINTF(("%s:ises_feed: called (sc = %p)\n", dv, sc));
	DELAY(1000000);

d837 2
a838 4
		if (ises_bchu_switch_session (sc, &q->q_session, q->q_sesn))
			sc->sc_cursession = q->q_sesn;
		else
			DPRINTF(("%s:ises_feed: session switch failed\n", dv));
a841 3
	DPRINTF(("%s:ises_feed: feed to chip (q = %p)\n", dv, q));
	DELAY(2000000);

a859 3
	DELAY(1000000);

	sc->sc_dma_mask |= ISES_DMA_STATUS_W_RUN;
a867 1
	DPRINTF(("%s:ises_feed: done\n", dv));
a903 2
	DPRINTF(("%s:ises_newsession: start\n", dv));

d935 1
a935 2
		sc->sc_cursession = -1;
		sesn = 0;
d980 1
a980 1
		if (enc->cri_alg == CRYPTO_DES_CBC) {
a1086 3
	if (sc->sc_cursession == sesn)
		sc->sc_cursession = -1;

d1102 1
a1102 4
	int cpoffset, coffset;
#if 0
	int nicealign;
#endif
a1118 2
	DPRINTF(("%s:ises_process: start (crp = %p)\n", dv, crp));

a1181 2
	DPRINTF(("%s:ises_process: enc=%p mac=%p\n", dv, enccrd, maccrd));

d1295 2
a1296 2
#if 0	/* XXX not sure about this, in bus_dma context */

d1299 1
a1299 1
		    q->q_src_packp, q->q_src_packl, 1, &nicealign);
d1302 1
a1302 1
		    q->q_src_packp, q->q_src_packl, 1, &nicealign);
d1304 1
a1304 2

	DPRINTF(("%s:ises_process: foo2pages called!\n", dv));
a1307 4
	else if (q->q_src_l > 0xfffc) {
		err = EIO;
		goto errout;
	}
d1314 1
a1314 3
		if (!nicealign && (crp->crp_flags & CRYPTO_F_IOV)) {
			goto errout;
		} else if (!nicealign && (crp->crp_flags & CRYPTO_F_IMBUF)) {
a1371 2
#endif /* XXX */

a1521 1
#ifndef ISES_HRNG_DISABLED
a1522 1
#endif
d1619 2
a1620 3
int
ises_bchu_switch_session (struct ises_softc *sc, struct ises_session *ss, 
			  int new_session)
a1626 4
	/* Do we have enough in-queue space? Count cmds + data, 16bit words. */
	if ((8 * 2 + sizeof (*ss) / 2) > READ_REG(sc, ISES_A_IQF))
		return (0);

d1628 1
a1628 1
	sc->sc_switching = new_session + 1;
d1643 1
a1643 1
	cmd = ISES_MKCMD(ISES_CMD_BW_SCCR, 2);
d1647 1
a1647 1
	cmd = ISES_MKCMD(ISES_CMD_BW_CVR, 5);
d1651 1
a1651 1
	cmd = ISES_MKCMD(ISES_CMD_BW_DBCR, 2);
d1654 1
a1654 1
	/* Write HMLR - Hash Message Length Register - last cmd in switch */
d1656 1
a1656 20
	ises_queue_cmd(sc, cmd, &ss->hmlr[0], ises_bchu_switch_final);

	return (1);
}

u_int32_t
ises_bchu_switch_final (struct ises_softc *sc, struct ises_cmd *cmd)
{
	/* Session switch is complete. */

	DPRINTF(("%s:ises_bchu_switch_final: switch complete\n",
	    sc->sc_dv.dv_xname));

	sc->sc_cursession = sc->sc_switching - 1;
	sc->sc_switching = 0;

	/* Retry/restart feed. */
	ises_feed(sc);

	return (0);
d1779 1
a1779 1
		ises_bchu_switch_session(sc, &ses, 0);
d1909 1
a1909 1
		printf ("IDP-state is \"%s\"", 
d1913 2
a1914 3
	printf ("\tOQS = %d  IQS = %d  OQF = %d  IQF = %d\n", 
	    READ_REG(sc, ISES_A_OQS), READ_REG(sc, ISES_A_IQS),
	    READ_REG(sc, ISES_A_OQF), READ_REG(sc, ISES_A_IQF));
@


1.4.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d248 1
a248 1
	sc->sc_cid = crypto_get_driverid(0);
d754 2
a755 2
			bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
			    sc->sc_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
d765 2
a766 2
			bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
			    sc->sc_dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);
d905 1
a905 2
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
	    sc->sc_dmamap->dm_mapsize, BUS_DMASYNC_PREWRITE);
d1766 1
a1766 2
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
	    sc->sc_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);
@


1.4.4.5
log
@Merge in -current from roughly a week ago
@
text
@d64 2
a65 2
int	ises_match(struct device *, void *, void *);
void	ises_attach(struct device *, struct device *, void *);
d67 19
a85 18
void	ises_initstate(void *);
void	ises_hrng_init(struct ises_softc *);
void	ises_hrng(void *);
void	ises_process_oqueue(struct ises_softc *);
int	ises_queue_cmd(struct ises_softc *, u_int32_t, u_int32_t *, 
		       u_int32_t (*)(struct ises_softc *, struct ises_cmd *));
u_int32_t ises_get_fwversion(struct ises_softc *);
int	ises_assert_cmd_mode(struct ises_softc *);

int	ises_intr(void *);
int	ises_newsession(u_int32_t *, struct cryptoini *);
int	ises_freesession(u_int64_t);
int	ises_process(struct cryptop *);
void	ises_callback(struct ises_q *);
int	ises_feed(struct ises_softc *);
int	ises_bchu_switch_session(struct ises_softc *, 
				      struct ises_session *, int);
u_int32_t ises_bchu_switch_final(struct ises_softc *, struct ises_cmd *);
d87 1
a87 1
void	ises_read_dma(struct ises_softc *);
d105 6
a110 6
void	ises_debug_init(struct ises_softc *);
void	ises_debug_2(void);
void	ises_debug_loop(void *);
void	ises_showreg(void);
void	ises_debug_parse_omr(struct ises_softc *);
void	ises_debug_simple_cmd(struct ises_softc *, u_int32_t, u_int32_t);
@


1.4.4.6
log
@Sync the SMP branch with 3.3
@
text
@d294 1
a294 1
	int p, ticks, algs[CRYPTO_ALGORITHM_MAX + 1];
d502 12
a513 7
		bzero(algs, sizeof(algs));

		algs[CRYPTO_3DES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_DES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_MD5_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_SHA1_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_RIPEMD160_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
a514 2
		crypto_register(sc->sc_cid, algs,
		    ises_newsession, ises_freesession, ises_process);
d1130 1
a1130 1
	u_int32_t sid = ((u_int32_t)tsid) & 0xffffffff;
d1472 1
a1472 1
	crypto_done(crp);
@


1.4.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d15 2
@


1.4.4.8
log
@Merge with the trunk
@
text
@d47 1
a47 1
#include <crypto/md5.h>
d266 1
a266 1
	case 5:
d269 1
a269 1
	case 4:
d271 1
a271 1
	case 3:
d273 1
a273 1
	case 2:
d275 1
a275 1
	case 1:
a276 2
	default: /* 0 */
		break;
d611 1
a611 1
			SIMPLEQ_REMOVE_HEAD(&sc->sc_cmdq, cmd_next);
d885 1
a885 1
	SIMPLEQ_REMOVE_HEAD(&sc->sc_queue, q_next);
@


1.3
log
@KNF from niklas@@. :)
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.2 2001/01/29 23:36:43 ho Exp $	*/
d1051 1
a1051 1
				M_COPY_PKTHDR(m, q->q_src_m);
@


1.2
log
@Generate less random data. Suggested by mickey@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ises.c,v 1.1 2001/01/29 08:45:58 ho Exp $	*/
d86 1
a86 1
void    ubsec_mcopy __P((struct mbuf *, struct mbuf *, int, int));
d88 1
a88 1
#define	READ_REG(sc,r) \
d94 1
a94 1
#define	SWAP32(x) ((x) = swap32((x)))
d109 1
a109 1
	sizeof (struct ises_softc), ises_match, ises_attach,
d119 1
a119 1
	struct pci_attach_args *pa = (struct pci_attach_args *) aux;
d164 3
a166 4
	if (pci_mapreg_map (pa, PCI_MAPREG_START, 
			    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT,
			    0, &sc->sc_memt, &sc->sc_memh, &membase, 
			    &memsize)) {
d174 1
a174 1
			 &ih)) {
d193 2
a194 3
	error = bus_dmamap_create (sc->sc_dmat, 1 << PGSHIFT, 1, 1 << PGSHIFT,
				   0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, 
				   &sc->sc_dmamap_xfer);
d196 1
a196 1
		printf (": cannot create dma map (%d)\n", error);
d202 3
a204 3
	if (bus_dmamem_alloc (sc->sc_dmat, sizeof sc->sc_dmamap, 1, 0, &seg, 
			      1, &nsegs, BUS_DMA_NOWAIT)) {
		printf (": can't alloc dma buffer space\n");
d210 3
a212 3
	if (bus_dmamem_map (sc->sc_dmat, &seg, nsegs, sizeof sc->sc_dmamap,
			    (caddr_t *)&sc->sc_dmamap, 0)) {
		printf (": can't map dma buffer space\n");
d224 1
a224 1
	/* 
d231 2
a232 2
	timeout_set (&sc->sc_timeout, ises_initstate, sc);
	ises_initstate (sc); 
d237 13
a249 14
	switch (state) /* Always fallthrough here. */
	  {
	  case 4:
		  bus_dmamem_unmap(sc->sc_dmat, (caddr_t)&sc->sc_dmamap, 
				   sizeof sc->sc_dmamap);
	  case 3:
		  bus_dmamem_free(sc->sc_dmat, &seg, nsegs);
	  case 2:
		  bus_dmamap_destroy(sc->sc_dmat, sc->sc_dmamap_xfer);
	  case 1:
		  pci_intr_disestablish(pc, sc->sc_ih);
	  default: /* 0 */
		  bus_space_unmap(sc->sc_memt, sc->sc_memh, memsize);
	  }
d254 1
a254 1
ises_initstate (void *v)
d256 2
a257 2
  	/* 
	 * Step through chip initialization. 
d261 1
a261 1
  	struct ises_softc *sc = v;
d272 6
a277 25
	switch (sc->sc_initstate)
		{
		case 0:
			/* Power up the chip (clear powerdown bit) */
			stat = READ_REG(sc, ISES_BO_STAT);
			if (stat & ISES_BO_STAT_POWERDOWN) {
				stat &= ~ISES_BO_STAT_POWERDOWN;
				WRITE_REG(sc, ISES_BO_STAT, stat);
				/* Selftests will take 1 second. */
				break;
			} 
			/* FALLTHROUGH (chip is already powered up) */
			sc->sc_initstate++;

		case 1:
			/* Perform a hardware reset */
			stat = 0;

			printf ("%s: initializing...\n", dv);

			/* Clear all possible bypass bits. */
			for (p = 0; p < 128; p++)
				WRITE_REG(sc, ISES_B_BDATAOUT, 0L);

			stat |= ISES_BO_STAT_HWRESET;
d279 1
a279 3
			stat &= ~ISES_BO_STAT_HWRESET;
			WRITE_REG(sc, ISES_BO_STAT, stat);
			/* Again, selftests will take 1 second. */
d281 3
d285 26
a310 23
		case 2:
			/* Set AConf to zero, i.e 32-bits access to A-int. */
			stat = READ_REG(sc, ISES_BO_STAT);
			stat &= ~ISES_BO_STAT_ACONF;
			WRITE_REG(sc, ISES_BO_STAT, stat);
			
			/* Is the firmware already loaded? */
			if (READ_REG(sc, ISES_A_STAT) & ISES_STAT_HW_DA) {
				/* Yes it is, jump ahead a bit */
				ticks = 1;
				sc->sc_initstate += 4; /* Next step --> 7 */
				break;
			}
			
			/* 
			 * Download the Basic Functionality firmware.
			 * Prior to downloading we need to reset the NSRAM.
			 * Setting the tamper bit will erase the contents
			 * in 1 microsecond.
			 */
			stat = READ_REG(sc, ISES_BO_STAT);
			stat |= ISES_BO_STAT_TAMPER;
			WRITE_REG(sc, ISES_BO_STAT, stat);
d312 1
d314 21
d336 7
a342 7
		case 3:
			/* After tamper bit has been set, powerdown chip. */
			stat = READ_REG(sc, ISES_BO_STAT);
			stat |= ISES_BO_STAT_POWERDOWN;
			WRITE_REG(sc, ISES_BO_STAT, stat);
			/* Wait one second for power to dissipate. */
			break;
d344 12
a355 8
		case 4:
			/* Clear tamper and powerdown bits. */
			stat = READ_REG(sc, ISES_BO_STAT);
			stat &= ~(ISES_BO_STAT_TAMPER | 
				  ISES_BO_STAT_POWERDOWN);
			WRITE_REG(sc, ISES_BO_STAT, stat);
			/* Again, wait one second for selftests. */
			break;
d357 2
a358 13
		case 5:
			/*
			 * We'll need some space in the input queue (IQF) 
			 * and we need to be in the 'waiting for program
			 * length' IDP state (0x4).
			 */
			p = ISES_STAT_IDP_STATE(READ_REG(sc, ISES_A_STAT));
			if (READ_REG(sc, ISES_A_IQF) < 4 || p != 0x4) {
				printf("%s: cannot download firmware, "
				       "IDP state is \"%s\"\n", dv,
				       ises_idp_state[p]);
				return;
			}
d360 6
a365 2
			/* Write firmware length */
			WRITE_REG(sc, ISES_A_IQD, ISES_BF_IDPLEN);
d367 2
a368 7
			/* Write firmware code */
			for (p = 0; p < sizeof (ises_bf_fw)/sizeof (u_int32_t);
			     p++) {
				WRITE_REG(sc, ISES_A_IQD, ises_bf_fw[p]);
				if (READ_REG(sc, ISES_A_IQF) < 4)
					DELAY(10);
			}
d370 2
a371 2
			/* Write firmware CRC */
			WRITE_REG(sc, ISES_A_IQD, ISES_BF_IDPCRC);
d373 4
a376 1
			/* Wait 1s while chip resets and runs selftests */
d378 5
d384 15
a398 6
		case 6:
			/* Did the download succed? */
			if (READ_REG(sc, ISES_A_STAT) & ISES_STAT_HW_DA) {
				ticks = 1;
				break;
			}
d400 12
a411 33
			/* We failed. We cannot do anything else. */
			printf ("%s: firmware download failed\n", dv);
			return;
			
		case 7:
			if (ises_assert_cmd_mode(sc) < 0)
				goto fail;

			/*
			 * Now that the basic functionality firmware should be
			 * up and running, try to get the firmware version.
			 */
			
			stat = ises_get_fwversion(sc);
			if (stat == 0)
				goto fail;
			
			printf("%s: firmware v%d.%d loaded (%d bytes)", dv, 
			       stat & 0xffff, (stat >> 16) & 0xffff,
			       ISES_BF_IDPLEN << 2);
			
			/* We can use firmware version 1.x & 2.x */
			switch (stat & 0xffff) {
			case 0:
				printf (" diagnostic, %s disabled\n", dv);
				goto fail;
			case 1: /* Basic Func "base" firmware */
			case 2: /* Basic Func "ipsec" firmware, no ADP code */
				break;
			default:
				printf(" unknown, %s disabled\n", dv);
				goto fail;
			}
d413 11
a423 12
			stat = READ_REG(sc, ISES_A_STAT);
			DPRINTF((", mode %s",
				 ises_sw_mode[ISES_STAT_SW_MODE(stat)]));
			
			/* Reuse the timeout for HRNG entropy collection. */
			timeout_del (&sc->sc_timeout);
			ises_hrng_init (sc);
			
			/* Set the interrupt mask */
			sc->sc_intrmask =
				ISES_STAT_BCHU_OAF | ISES_STAT_BCHU_ERR | 
				ISES_STAT_BCHU_OFHF | ISES_STAT_SW_OQSINC;
d425 3
a427 3
				ISES_STAT_BCHU_ERR | ISES_STAT_BCHU_OAF |
				ISES_STAT_BCHU_IFE | ISES_STAT_BCHU_IFHE |
				ISES_STAT_BCHU_OFHF | ISES_STAT_BCHU_OFF;
d430 1
a430 1
			WRITE_REG(sc, ISES_A_INTE, sc->sc_intrmask);
d432 2
a433 2
			/* We're done. */
			printf("\n");
d435 1
a435 1
			/* Register ourselves with crypto framework. */
d437 8
a444 11
			crypto_register(sc->sc_cid, CRYPTO_3DES_CBC,
					ises_newsession, ises_freesession, 
					ises_process);
			crypto_register(sc->sc_cid, CRYPTO_DES_CBC, 
					NULL, NULL, NULL);
			crypto_register(sc->sc_cid, CRYPTO_MD5_HMAC, 
					NULL, NULL, NULL);
			crypto_register(sc->sc_cid, CRYPTO_SHA1_HMAC, 
					NULL, NULL, NULL);
			crypto_register(sc->sc_cid, CRYPTO_RIPEMD160_HMAC, 
					NULL, NULL, NULL);
d447 8
a454 8
			return;
			
		default:
			printf ("%s: entered unknown initstate %d\n", dv, 
				sc->sc_initstate);
			goto fail;
		}
	
d457 1
a457 1
	timeout_add (&sc->sc_timeout, ticks);
d461 2
a462 2
	printf ("%s: firmware failure\n", dv);
	timeout_del (&sc->sc_timeout);
d466 1
a466 1
/* Put a command on the A-interface queue. */			
d568 1
a568 1
	
d625 1
a625 1
	MD5_CTX    md5ctx;
d672 1
a672 1
		
d674 1
a674 1
		  	i = sc->sc_nsessions * sizeof (struct ises_session);
d676 2
a677 2
			    malloc(i + sizeof (struct ises_session), M_DEVBUF,
				   M_NOWAIT);
d680 1
a680 1
			
d688 1
a688 1
	}	
d690 1
a690 1
	memset(ses, 0, sizeof (struct ises_session));
d697 1
a697 1
		
d705 1
a705 1
		
d717 1
a717 1
		
d722 3
a724 3
				  (mac->cri_klen / 8));
			memcpy(ses->ses_hminner, md5ctx.state, 
			       sizeof(md5ctx.state));
d729 4
a732 4
				  (mac->cri_klen / 8));
			memcpy(ses->ses_hminner, sha1ctx.state, 
			       sizeof(sha1ctx.state));
		} else { 
d734 6
a739 6
			RMD160Update(&rmd160ctx, mac->cri_key, 
				     mac->cri_klen / 8);
			RMD160Update(&rmd160ctx, hmac_ipad_buffer, 
				     HMAC_BLOCK_LEN - (mac->cri_klen / 8));
			memcpy(ses->ses_hminner, rmd160ctx.state, 
			       sizeof(rmd160ctx.state));
d744 1
a744 1
		
d749 3
a751 3
				  (mac->cri_klen / 8));
			memcpy(ses->ses_hmouter, md5ctx.state, 
			       sizeof(md5ctx.state));
d756 4
a759 4
				  (mac->cri_klen / 8));
			memcpy(ses->ses_hmouter, sha1ctx.state, 
			       sizeof(sha1ctx.state));
		} else { 
d761 6
a766 6
			RMD160Update(&rmd160ctx, mac->cri_key, 
				     mac->cri_klen / 8);
			RMD160Update(&rmd160ctx, hmac_ipad_buffer, 
				     HMAC_BLOCK_LEN - (mac->cri_klen / 8));
			memcpy(ses->ses_hmouter, rmd160ctx.state, 
			       sizeof(rmd160ctx.state));
d786 1
a786 1
	
d848 1
a848 1
	
d857 1
a857 1
	/* 
d861 1
a861 1
	 *   for encryption we only want the first to be crypto, while 
d871 1
a871 1
			if (maccrd || (enccrd && 
d878 1
a878 1
			if (enccrd || 
d909 1
a909 1
			
d912 1
a912 1
					   8, (caddr_t)q->q_ctx.pc_iv);
d918 1
a918 1
			else 
d920 1
a920 1
					   8, (caddr_t)q->q_ctx.pc_iv);
d936 1
a936 1
		
d945 1
a945 1
		default: 
d956 1
a956 1
		
d969 1
a969 1
		     (macoffset + maccrd->crd_len)) ||
d974 1
a974 1
		
d990 3
a992 3
	
	q->q_src_l = mbuf2pages (q->q_src_m, &q->q_src_npa, &q->q_src_packp,
				 &q->q_src_packl, 1, &nicealign);
d997 1
a997 1
	
d999 1
a999 1
	
d1005 1
a1005 1
		
d1015 1
a1015 1
		
d1017 1
a1017 1
		
d1034 1
a1034 1
		
d1045 44
a1088 44
                        int totlen, len;
                        struct mbuf *m, *top, **mp;
			
                        totlen = q->q_dst_l = q->q_src_l;
                        if (q->q_src_m->m_flags & M_PKTHDR) {
                                MGETHDR(m, M_DONTWAIT, MT_DATA);
                                M_COPY_PKTHDR(m, q->q_src_m);
                                len = MHLEN;
                        } else {
                                MGET(m, M_DONTWAIT, MT_DATA);
                                len = MLEN;
                        }
                        if (m == NULL) {
                                err = ENOMEM;
                                goto errout;
                        }
                        if (totlen >= MINCLSIZE) {
                                MCLGET(m, M_DONTWAIT);
                                if (m->m_flags & M_EXT)
                                        len = MCLBYTES;
                        }
                        m->m_len = len;
                        top = NULL;
                        mp = &top;
			
                        while (totlen > 0) {
                                if (top) {
                                        MGET(m, M_DONTWAIT, MT_DATA);
                                        if (m == NULL) {
                                                m_freem(top);
                                                err = ENOMEM;
                                                goto errout;
                                        }
                                        len = MLEN;
                                }
                                if (top && totlen >= MINCLSIZE) {
                                        MCLGET(m, M_DONTWAIT);
                                        if (m->m_flags & M_EXT)
                                                len = MCLBYTES;
                                }
                                m->m_len = len = min(totlen, len);
                                totlen -= len;
                                *mp = m;
				
d1090 8
a1097 9
                        }
                        q->q_dst_m = top;
                        ubsec_mcopy(q->q_src_m, q->q_dst_m, cpskip, cpoffset);
                } else
                        q->q_dst_m = q->q_src_m;
		
                q->q_dst_l = mbuf2pages(q->q_dst_m, &q->q_dst_npa,
					&q->q_dst_packp, &q->q_dst_packl, 
					1, NULL);
d1101 2
a1102 2
                        struct ises_pktbuf *pb;
			
d1104 31
a1134 31
                                if (dskip >= q->q_dst_packl[i]) {
                                        dskip -= q->q_dst_packl[i];
                                        continue;
                                }
                                q->q_dst_packp[i] += dskip;
                                q->q_dst_packl[i] -= dskip;
                                dskip = 0;
                        }
			
                        if (j == 0)
                                pb = NULL; /* &q->q_mcr->mcr_opktbuf; */
                        else
                                pb = &q->q_dstpkt[j - 1];

                        pb->pb_addr = q->q_dst_packp[i];
			
                        if (dtheend) {
                                if (q->q_dst_packl[i] > dtheend) {
                                        pb->pb_len = dtheend;
                                        dtheend = 0;
                                } else {
                                        pb->pb_len = q->q_dst_packl[i];
                                        dtheend -= pb->pb_len;
                                }
                        } else
                                pb->pb_len = q->q_dst_packl[i];
			
                        if ((i + 1) == q->q_dst_npa) {
                                if (maccrd)
                                        pb->pb_next = vtophys(q->q_macbuf);
                                else
d1136 5
a1140 5
                        } else
                                pb->pb_next = vtophys(&q->q_dstpkt[j]);
                        j++;
                }
#endif	
d1150 1
a1150 1
					
d1223 1
a1223 1
	/* 
d1226 1
a1226 1
	 * are much higher, ca 2.7-2.8 mbit/s. AFAICT the algorithm is sound. 
d1249 1
a1249 1
	
d1252 2
a1253 2
	printf(", %dKb/sec", 
	       ISES_WPR * ISES_ROUNDS * 32 / 1024 * 1000000 / tv1.tv_usec);
d1256 1
a1256 1
	printf ("\n");
d1273 1
a1273 2
	/* XXX How often should we repeat? */
	timeout_add(&sc->sc_timeout, hz/ISESRNGIPS);
d1289 1
a1289 1
  
d1296 1
a1296 1
  
d1307 1
a1307 1
				(void) READ_REG(sc, ISES_A_OQD);
d1313 2
a1314 2
	(void) READ_REG (sc, ISES_A_OQD); /* Discard 64bit "chip-id" */
	(void) READ_REG (sc, ISES_A_OQD);
d1321 2
a1322 2
/* 
 * ises_assert_cmd_mode() returns 
d1330 23
a1352 21
  switch (ISES_STAT_SW_MODE(READ_REG(sc, ISES_A_STAT))) {
  case 0x0: /* Selftest. XXX This is a transient state. */
  	DELAY(1000000);
	if (ISES_STAT_SW_MODE(READ_REG(sc, ISES_A_STAT)) == 0)
		return (-1);
	return (ises_assert_cmd_mode(sc));
  case 0x1: /* Command mode */
  	return (0);
  case 0x2: /* Waiting For Continue / WFC */
    	bus_space_write_2(sc->sc_memt, sc->sc_memh, ISES_A_CTRL,
	    ISES_A_CTRL_CONTINUE);
	DELAY(1);
	return ((ISES_STAT_SW_MODE(READ_REG(sc, ISES_A_STAT)) == 0) ? 1 : -1);
  case 0x3: /* Waiting For Reset / WFR */
    	bus_space_write_2(sc->sc_memt, sc->sc_memh, ISES_A_CTRL,
	    ISES_A_CTRL_RESET);
	DELAY(1000000);
	return ((ISES_STAT_SW_MODE(READ_REG(sc, ISES_A_STAT)) == 0) ? 2 : -1);
  default:
  	return (-1); /* Unknown mode */
  }
a1353 1

@


1.1
log
@Driver for the Pijnenburg PCC-ISES crypto chip. For now, it only generates
random data for the system entropy pool. No crypto yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d102 1
a102 1
/* For HRNG entropy collection, these values gather 5KB/s */
d104 2
a105 2
#define ISESRNGBITS	4096		/* Bits per iteration */
#define ISESRNGIPS	10		/* Iterations per second */
@

