head	1.17;
access;
symbols
	OPENBSD_5_7:1.16.0.6
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.18
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.16
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.14
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.12
	OPENBSD_5_0:1.14.0.10
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.8
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.6
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.12.0.4
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.17
date	2015.04.09.18.58.22;	author deraadt;	state dead;
branches;
next	1.16;
commitid	cDamcqFPw3HffP51;

1.16
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.15;
commitid	OBNa5kfxQ2UXoiIw;

1.15
date	2013.11.11.03.08.20;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.20.20.03.45;	author grange;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.01.15.34.48;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.20.20.31.12;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.01.21.42.36;	author canacar;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.13.10.47.24;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.01.18.37.07;	author mcbride;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.13.03.37.14;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.07.06.10.24;	author mcbride;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.25.13.09.11;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.16.15.11.45;	author alex;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.26.22.05.25;	author mcbride;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.26.20.17.23;	author mcbride;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.26.06.42.33;	author alex;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Send lmc(4) and san(4) to the HDLC framed bit bucket in the sky.
@
text
@/*	$OpenBSD: if_sandrv.c,v 1.16 2014/07/12 18:48:52 tedu Exp $	*/

/*-
 * Copyright (c) 2001-2004 Sangoma Technologies (SAN)
 * All rights reserved.  www.sangoma.com
 *
 * This code is written by Alex Feldman <al.feldman@@sangoma.com> for SAN.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following disclaimer
 *    in the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name of Sangoma Technologies nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY SANGOMA TECHNOLOGIES AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#define __SDLA_HW_LEVEL
#define __SDLADRV__

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/syslog.h>
#include <sys/malloc.h>
#include <sys/kernel.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/if_san_front_end.h>
#include <dev/pci/if_sandrv.h>

#define	EXEC_DELAY	20	/* shared memory access delay, mks */
#define EXEC_TIMEOUT	(hz*2)
#define MAX_NLOOPS	(EXEC_DELAY*2000)
			/* timeout used if jiffies are stopped
			** EXEC_DELAY=20
			** EXEC_TIMEOUT=EXEC_DELAY*2000 = 40000
			** 40000 ~= 80 jiffies = EXEC_TIMEOUT */

#define	EXEC_HZ_DIVISOR	8/10
			/* We don't want to wait a full second on sdla_exec
			** timeout, thus use HZ * EXEC_HZ_DIVISOR to get
			** the number of jiffies we would like to wait */

#define IS_SUPPORTED_ADAPTER(hw)	((hw)->type == SDLA_AFT)

#define SDLA_CTYPE_NAME(type)			\
	((type) == SDLA_AFT) ? "AFT" : "Unknown"

#define IS_AFT(hw)	(hw->type == SDLA_AFT)

/* Definitions for identifying and finding S514 PCI adapters */
#define V3_VENDOR_ID		0x11B0		/* V3 vendor ID number */
#define V3_DEVICE_ID		0x0002		/* V3 device ID number */
#define SANGOMA_SUBSYS_VENDOR	0x4753		/* ID for Sangoma */

/* Definition for identifying and finding XILINX PCI adapters */
#define SANGOMA_PCI_VENDOR	0x1923		/* Old value -> 0x11B0 */
#define SANGOMA_PCI_VENDOR_OLD	0x10EE		/* Old value -> 0x11B0 */
#define SANGOMA_PCI_DEVICE	0x0300		/* Old value -> 0x0200 */

#define A101_1TE1_SUBSYS_VENDOR	0xA010	/* A101 with T1/E1 1 line  */
#define A101_2TE1_SUBSYS_VENDOR	0xA011	/* A101 with T1/E1 2 lines */
#define A105_T3_SUBSYS_VENDOR	0xA020	/* A102 with T3 */

/* Read PCI SUBVENDOR ID */
#define PCI_SUBVENDOR_MASK	0xFFFF
#define PCI_SUBVENDOR(pa)	(pci_conf_read(pa->pa_pc, pa->pa_tag,	\
				    PCI_SUBSYS_ID_REG) & PCI_SUBVENDOR_MASK)
#define PCI_DEVICE_MASK		0xFFFF0000
#define PCI_DEVICE(id)		((id & PCI_DEVICE_MASK ) >> 16)

/* Status values */
#define SDLA_MEM_RESERVED	0x0001
#define SDLA_MEM_MAPPED		0x0002
#define SDLA_IO_MAPPED		0x0004
#define SDLA_PCI_ENABLE		0x0008

struct san_softc {
	struct device		dev;
	struct pci_attach_args	pa;
};

typedef struct sdla_hw_probe {
	int				used;
	unsigned char			hw_info[100];
	LIST_ENTRY(sdla_hw_probe)	next;
} sdla_hw_probe_t;

/*
 * This structure keeps common parameters per physical card.
 */
typedef struct sdlahw_card {
	int			used;
	unsigned int		type;		/* S50x/S514/ADSL/XILINX */
	unsigned int		atype;		/* SubVendor ID */
	unsigned char		core_id;	/* SubSystem ID [0..7] */
	unsigned char		core_rev;	/* SubSystem ID [8..15] */
	unsigned char		pci_extra_ver;
	unsigned int		slot_no;
	unsigned int		bus_no;
	bus_space_tag_t		memt;
	struct pci_attach_args	pa;	/* PCI config header info */
	pci_intr_handle_t	ih;
	LIST_ENTRY(sdlahw_card)	next;
} sdlahw_card_t;

/*
 * Adapter hardware configuration. Pointer to this structure is passed to all
 * APIs.
 */
typedef struct sdlahw {
	int			 used;
	unsigned		 magic;
	char			 devname[20];
	u_int16_t		 status;
	int			 irq;		/* interrupt request level */
	unsigned int		 cpu_no;	/* PCI CPU Number */
	char			 auto_pci_cfg;	/* Auto PCI configuration */
	bus_addr_t		 mem_base_addr;
	bus_space_handle_t	 dpmbase;	/* dual-port memory base */
	unsigned		 dpmsize;	/* dual-port memory size */
	unsigned long		 memory;	/* memory size */

	unsigned		 reserved[5];
	unsigned char		 hw_info[100];

	u_int16_t		 configured;
	void			*arg;		/* card structure */
	sdla_hw_probe_t		*hwprobe;
	sdlahw_card_t		*hwcard;
	LIST_ENTRY(sdlahw)	 next;
} sdlahw_t;

/* Entry Point for Low-Level function */
int sdladrv_init(void);
int sdladrv_exit(void);

static int sdla_pci_probe(int, struct pci_attach_args *);

/* PCI bus interface function */
static int sdla_pci_write_config_word(void *, int, u_int16_t);
static int sdla_pci_write_config_dword(void *, int, u_int32_t);
static int sdla_pci_read_config_byte(void *, int, u_int8_t *);
static int sdla_pci_read_config_word(void *, int, u_int16_t *);
static int sdla_pci_read_config_dword(void *, int, u_int32_t *);

static int sdla_detect	(sdlahw_t *);
static int sdla_detect_aft(sdlahw_t *);
static int sdla_exec(sdlahw_t *, unsigned long);
static void sdla_peek_by_4(sdlahw_t *, unsigned long, u_int8_t *, unsigned int);
static void sdla_poke_by_4(sdlahw_t *, unsigned long, u_int8_t *, unsigned int);

static sdlahw_card_t* sdla_card_register(u_int16_t, int, int);
#if 0
static int sdla_card_unregister (unsigned char, int, int, int);
#endif
static sdlahw_card_t* sdla_card_search(u_int16_t, int, int);

static sdlahw_t* sdla_hw_register(sdlahw_card_t *, int, int, void *);
#if 0
static int sdla_hw_unregister(sdlahw_card_t*, int);
#endif
static sdlahw_t* sdla_hw_search(u_int16_t, int, int, int);

static sdlahw_t* sdla_aft_hw_select (sdlahw_card_t *, int, int,
    struct pci_attach_args *);
static void sdla_save_hw_probe (sdlahw_t*, int);

/* SDLA PCI device relative entry point */
int	san_match(struct device *, void *, void *);
void	san_attach(struct device *, struct device *, void *);


struct cfdriver san_cd = {
	NULL, "san", DV_IFNET
};

struct cfattach san_ca = {
	sizeof(struct san_softc), san_match, san_attach
};

extern int ticks;

/* SDLA ISA/PCI varibles */
static int       Sangoma_cards_no = 0;
static int       Sangoma_devices_no = 0;
static int       Sangoma_PCI_cards_no = 0;

/* private data */
char		*san_drvname = "san";

/* Array of already initialized PCI slots */
static int pci_slot_ar[MAX_S514_CARDS];

LIST_HEAD(, sdlahw_card) sdlahw_card_head =
	LIST_HEAD_INITIALIZER(sdlahw_card_head);
LIST_HEAD(, sdlahw) sdlahw_head =
	LIST_HEAD_INITIALIZER(sdlahw_head);
LIST_HEAD(, sdla_hw_probe) sdlahw_probe_head =
	LIST_HEAD_INITIALIZER(sdlahw_probe_head);
static sdla_hw_type_cnt_t sdla_adapter_cnt;



/*
 * PCI Device Driver Entry Points
 */
int
san_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args*	pa = aux;
	u_int16_t		vendor_id = PCI_VENDOR(pa->pa_id);
	u_int16_t		device_id = PCI_DEVICE(pa->pa_id);

	if ((vendor_id == SANGOMA_PCI_VENDOR ||
	    vendor_id == SANGOMA_PCI_VENDOR_OLD) &&
	    device_id == SANGOMA_PCI_DEVICE) {
		return (1);
	}
	return (0);
}

#define PCI_CBIO	0x10
void
san_attach(struct device *parent, struct device *self, void *aux)
{
	struct pci_attach_args*		pa = aux;
	u_int16_t			vendor_id = PCI_VENDOR(pa->pa_id);
	u_int16_t			subvendor_id = PCI_SUBVENDOR(pa);
	int				atype = 0x00;

	atype = PCI_PRODUCT(pci_conf_read(pa->pa_pc, pa->pa_tag,
	    PCI_SUBSYS_ID_REG));
	switch (vendor_id) {
	case SANGOMA_PCI_VENDOR_OLD:
	case SANGOMA_PCI_VENDOR:
		switch (subvendor_id) {
		case A101_1TE1_SUBSYS_VENDOR:
			atype	= A101_ADPTR_1TE1;
			break;
		case A101_2TE1_SUBSYS_VENDOR:
			atype	= A101_ADPTR_2TE1;
			break;
		default:
			return;
		}
		break;
	default:
		return;
	}

	if (sdla_pci_probe(atype, pa)) {
		printf(": PCI probe FAILED!\n");
		return;
	}

#ifdef DEBUG
	switch (PCI_VENDOR(pa->pa_id)) {
	case V3_VENDOR_ID:
		switch (atype) {
		case S5141_ADPTR_1_CPU_SERIAL:
			log(LOG_INFO, "%s: Sangoma S5141/FT1 (Single CPU) "
			    "adapter\n", self->dv_xname);
			break;
		case S5142_ADPTR_2_CPU_SERIAL:
			log(LOG_INFO, "%s: Sangoma S5142 (Dual CPU) adapter\n",
			    self->dv_xname);
			break;
		case S5143_ADPTR_1_CPU_FT1:
			log(LOG_INFO, "%s: Sangoma S5143 (Single CPU) "
			    "FT1 adapter\n", self->dv_xname);
			break;
		case S5144_ADPTR_1_CPU_T1E1:
		case S5148_ADPTR_1_CPU_T1E1:
			log(LOG_INFO, "%s: Sangoma S5144 (Single CPU) "
			    "T1/E1 adapter\n", self->dv_xname);
			break;
		case S5145_ADPTR_1_CPU_56K:
			log(LOG_INFO, "%s: Sangoma S5145 (Single CPU) "
			    "56K adapter\n", self->dv_xname);
			break;
		case S5147_ADPTR_2_CPU_T1E1:
			log(LOG_INFO, "%s: Sangoma S5147 (Dual CPU) "
			    "T1/E1 adapter\n", self->dv_xname);
			break;
		}
		break;

	case SANGOMA_PCI_VENDOR_OLD:
		switch (atype) {
		case A101_ADPTR_1TE1:
			log(LOG_INFO, "%s: Sangoma AFT (1 channel) "
			    "T1/E1 adapter\n", self->dv_xname);
			break;
		case A101_ADPTR_2TE1:
			log(LOG_INFO, "%s: Sangoma AFT (2 channels) "
			    "T1/E1 adapter\n", self->dv_xname);
			break;
		}
		break;
	}
#endif
	return;
}

/*
 * Module init point.
 */
int
sdladrv_init(void)
{
	int volatile i = 0;

	/* Initialize the PCI Card array, which
	 * will store flags, used to mark
	 * card initialization state */
	for (i=0; i<MAX_S514_CARDS; i++)
		pci_slot_ar[i] = 0xFF;

	bzero(&sdla_adapter_cnt, sizeof(sdla_hw_type_cnt_t));

	return (0);
}

/*
 * Module deinit point.
 * o release all remaining system resources
 */
int
sdladrv_exit(void)
{
#if 0
	sdla_hw_probe_t	*elm_hw_probe;
	sdlahw_t	*elm_hw;
	sdlahw_card_t	*elm_hw_card;


	elm_hw = LIST_FIRST(&sdlahw_head);
	while (elm_hw) {
		sdlahw_t	*tmp = elm_hw;
		elm_hw = LIST_NEXT(elm_hw, next);
		if (sdla_hw_unregister(tmp->hwcard, tmp->cpu_no) == EBUSY)
			return EBUSY;
	}
	LIST_INIT(&sdlahw_head);

	elm_hw_card = LIST_FIRST(&sdlahw_card_head);
	while (elm_hw_card) {
		sdlahw_card_t	*tmp = elm_hw_card;
		elm_hw_card = LIST_NEXT(elm_hw_card, next);
		if (sdla_card_unregister(tmp->hw_type,
					 tmp->slot_no,
					 tmp->bus_no,
					 tmp->ioport) == EBUSY)
			return EBUSY;
	}
	LIST_INIT(&sdlahw_card_head);

	elm_hw_probe = LIST_FIRST(&sdlahw_probe_head);
	while (elm_hw_probe) {
		sdla_hw_probe_t *tmp = elm_hw_probe;
		elm_hw_probe = LIST_NEXT(elm_hw_probe, next);
		if (tmp->used){
			log(LOG_INFO, "HW probe info is in used (%s)\n",
					elm_hw_probe->hw_info);
			return EBUSY;
		}
		LIST_REMOVE(tmp, next);
		free(tmp, M_DEVBUF, 0);
	}
#endif
	return (0);
}

static void
sdla_save_hw_probe(sdlahw_t *hw, int port)
{
	sdla_hw_probe_t *tmp_hw_probe;

	tmp_hw_probe = malloc(sizeof(*tmp_hw_probe), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (tmp_hw_probe == NULL)
		return;

	snprintf(tmp_hw_probe->hw_info, sizeof(tmp_hw_probe->hw_info),
		"%s : SLOT=%d : BUS=%d : IRQ=%d : CPU=%c : PORT=%s",
		SDLA_ADPTR_DECODE(hw->hwcard->atype), hw->hwcard->slot_no,
		hw->hwcard->bus_no, hw->irq, SDLA_GET_CPU(hw->cpu_no), "PRI");

	hw->hwprobe = tmp_hw_probe;
	tmp_hw_probe->used++;
	LIST_INSERT_HEAD(&sdlahw_probe_head, tmp_hw_probe, next);
}

static sdlahw_t*
sdla_aft_hw_select(sdlahw_card_t *hwcard, int cpu_no,
    int irq, struct pci_attach_args *pa)
{
	sdlahw_t*	hw = NULL;
	int		number_of_cards = 0;

	hwcard->type = SDLA_AFT;
	switch (hwcard->atype) {
	case A101_ADPTR_1TE1:
		hw = sdla_hw_register(hwcard, cpu_no, irq, pa);
		sdla_save_hw_probe(hw, 0);
		number_of_cards += 1;
#ifdef DEBUG
		log(LOG_INFO, "%s: %s T1/E1 card found (%s rev.%d), "
		    "cpu(s) 1, bus #%d, slot #%d, irq #%d\n", san_drvname,
		     SDLA_ADPTR_DECODE(hwcard->atype),
		     AFT_CORE_ID_DECODE(hwcard->core_id), hwcard->core_rev,
		     hwcard->bus_no, hwcard->slot_no, irq);
#endif /* DEBUG */
		break;
	case A101_ADPTR_2TE1:
		hw = sdla_hw_register(hwcard, cpu_no, irq, pa);
		sdla_save_hw_probe(hw, 0);
		number_of_cards += 1;
#ifdef DEBUG
		log(LOG_INFO, "%s: %s T1/E1 card found (%s rev.%d), "
		    "cpu(s) 2, bus #%d, slot #%d, irq #%d\n", san_drvname,
		    SDLA_ADPTR_DECODE(hwcard->atype),
		    AFT_CORE_ID_DECODE(hwcard->core_id), hwcard->core_rev,
		    hwcard->bus_no, hwcard->slot_no, irq);
#endif /* DEBUG */
		break;
	case A105_ADPTR_1_CHN_T3E3:

		hw = sdla_hw_register(hwcard, cpu_no, irq, pa);
		sdla_save_hw_probe(hw, 0);
		number_of_cards += 1;
#ifdef DEBUG
		log(LOG_INFO, "%s: %s T3/E3 card found, cpu(s) 1,"
		     "bus #%d, slot #%d, irq #%d\n", san_drvname,
		     SDLA_ADPTR_DECODE(hwcard->atype),
		     hwcard->bus_no, hwcard->slot_no, irq);
#endif /* DEBUG */
		break;
	default:
		log(LOG_INFO, "%s: Unknown adapter %04X "
		    "(bus #%d, slot #%d, irq #%d)!\n", san_drvname,
		    hwcard->atype, hwcard->bus_no, hwcard->slot_no, irq);
		break;
	}

	return (hw);
}


static int
sdla_pci_probe(int atype, struct pci_attach_args *pa)
{
	sdlahw_card_t*	hwcard;
	sdlahw_t*	hw;
	/*sdladev_t*	dev = NULL;*/
	int dual_cpu = 0;
	int bus, slot, cpu = SDLA_CPU_A;
	u_int16_t vendor_id, subvendor_id, device_id;
	u_int8_t irq;
	pci_intr_handle_t	ih;
	const char*			intrstr = NULL;

	bus = pa->pa_bus;
	slot = pa->pa_device;
	vendor_id = PCI_VENDOR(pa->pa_id);
	subvendor_id = PCI_SUBVENDOR(pa);
	device_id = PCI_DEVICE(pa->pa_id);
	irq = (u_int8_t)pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_INTLINE);

	/* Map and establish the interrupt */
	if (pci_intr_map(pa, &ih)) {
		printf(": can't map interrupt\n");
		return (EINVAL);
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	if (intrstr != NULL)
		printf(" %s\n", intrstr);

	Sangoma_cards_no ++;
reg_new_card:
	Sangoma_PCI_cards_no ++;
	hwcard = sdla_card_register(atype, slot, bus);
	if (hwcard == NULL)
		return (EINVAL);

	hwcard->memt	= pa->pa_memt;
	hwcard->ih	= ih;
	hwcard->pa	= *pa;
	/* Increment number of available Sangoma devices */
	Sangoma_devices_no ++;
	switch (atype) {
	case A101_ADPTR_1TE1:
	case A101_ADPTR_2TE1:
		hw = sdla_aft_hw_select(hwcard, cpu, irq, pa);
		sdla_adapter_cnt.AFT_adapters++;
		if (atype == A101_ADPTR_2TE1)
			dual_cpu = 1;
		break;

	}

	if (hw == NULL)
	    return (EINVAL);
	if (san_dev_attach(hw, hw->devname, sizeof(hw->devname)))
		return (EINVAL);

	hw->used++;

	if (dual_cpu && cpu == SDLA_CPU_A) {
		cpu = SDLA_CPU_B;
		goto reg_new_card;
	}

	return (0);
}

int
sdla_intr_establish(void *phw, int (*intr_func)(void*), void* intr_arg)
{
	sdlahw_t	*hw = (sdlahw_t*)phw;
	sdlahw_card_t	*hwcard;

	WAN_ASSERT(hw == NULL);
	hwcard = hw->hwcard;
	if (pci_intr_establish(hwcard->pa.pa_pc, hwcard->ih, IPL_NET,
	    intr_func, intr_arg, "san") == NULL)
		return (EINVAL);

	return 0;
}

int
sdla_intr_disestablish(void *phw)
{
	sdlahw_t	*hw = (sdlahw_t*)phw;

	log(LOG_INFO, "%s: Disestablish interrupt is not defined!\n",
	    hw->devname);
	return (EINVAL);
}

int
sdla_get_hw_devices(void)
{
	return (Sangoma_devices_no);
}

void*
sdla_get_hw_adptr_cnt(void)
{
	return (&sdla_adapter_cnt);
}

static sdlahw_card_t*
sdla_card_register(u_int16_t atype, int slot_no, int bus_no)
{
	sdlahw_card_t	*new_hwcard, *last_hwcard;

	new_hwcard = sdla_card_search(atype, slot_no, bus_no);
	if (new_hwcard)
		return (new_hwcard);

	new_hwcard = malloc(sizeof(*new_hwcard), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (!new_hwcard)
		return (NULL);

	new_hwcard->atype	= atype;
	new_hwcard->slot_no	= slot_no;
	new_hwcard->bus_no	= bus_no;

	if (LIST_EMPTY(&sdlahw_card_head)) {
		/* Initialize SAN HW parameters */
		sdladrv_init();
	}
	LIST_FOREACH(last_hwcard, &sdlahw_card_head, next) {
		if (!LIST_NEXT(last_hwcard, next))
			break;
	}

	if (last_hwcard)
		LIST_INSERT_AFTER(last_hwcard, new_hwcard, next);
	else
		LIST_INSERT_HEAD(&sdlahw_card_head, new_hwcard, next);

	return (new_hwcard);
}

#if 0
static int
sdla_card_unregister(u_int16_t atype, int slot_no, int bus_no, int ioport)
{
	sdlahw_card_t*	tmp_card;

	LIST_FOREACH(tmp_card, &sdlahw_card_head, next){
		if (tmp_card->atype != atype){
			continue;
		}
		if (tmp_card->slot_no == slot_no &&
					tmp_card->bus_no == bus_no){
			break;
		}
	}
	if (tmp_card == NULL){
		log(LOG_INFO,
		"Error: Card didn't find %04X card (slot=%d, bus=%d)\n"
				atype, slot_no, bus_no);
		return (EFAULT)
	}
	if (tmp_card->used){
		log(LOG_INFO,
		"Error: Card is still in used (slot=%d,bus=%d,used=%d)\n",
				slot_no, bus_no, tmp_card->used);
		return (EBUSY);
	}
	LIST_REMOVE(tmp_card, next);
	free(tmp_card, M_DEVBUF, 0);
	return 0;
}
#endif

static sdlahw_card_t*
sdla_card_search(u_int16_t atype, int slot_no, int bus_no)
{
	sdlahw_card_t*	tmp_card;

	LIST_FOREACH(tmp_card, &sdlahw_card_head, next) {
		if (tmp_card->atype != atype)
			continue;

		if (tmp_card->slot_no == slot_no &&
		    tmp_card->bus_no == bus_no)
			return (tmp_card);
	}
	return (NULL);
}

static sdlahw_t*
sdla_hw_register(sdlahw_card_t *card, int cpu_no, int irq, void *dev)
{
	sdlahw_t	*new_hw, *last_hw;

	new_hw = sdla_hw_search(card->atype, card->slot_no,
	    card->bus_no, cpu_no);
	if (new_hw)
		return (new_hw);

	new_hw = malloc(sizeof(*new_hw), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (!new_hw)
		return (NULL);

	new_hw->cpu_no	= cpu_no;
	new_hw->irq	= irq;
	new_hw->hwcard	= card;
#if 0
	new_hw->dev	= dev;
#endif
	new_hw->magic	= SDLAHW_MAGIC;
	card->used++;

	LIST_FOREACH(last_hw, &sdlahw_head, next) {
		if (!LIST_NEXT(last_hw, next))
			break;
	}
	if (last_hw)
		LIST_INSERT_AFTER(last_hw, new_hw, next);
	else
		LIST_INSERT_HEAD(&sdlahw_head, new_hw, next);

	return (new_hw);
}

#if 0
static int
sdla_hw_unregister(sdlahw_card_t* hwcard, int cpu_no)
{
	sdlahw_t*	tmp_hw;
	int		i;

	LIST_FOREACH(tmp_hw, &sdlahw_head, next) {
		if (tmp_hw->hwcard != hwcard)
			continue;

		if (tmp_hw->cpu_no == cpu_no)
			break;
	}

	if (tmp_hw == NULL) {
		log(LOG_INFO,
		"Error: Failed to find device (slot=%d,bus=%d,cpu=%c)\n",
		hwcard->slot_no, hwcard->bus_no, SDLA_GET_CPU(cpu_no));
		return (EFAULT);
	}
	if (tmp_hw->used) {
		log(LOG_INFO,
		"Error: Device is still in used (slot=%d,bus=%d,cpu=%c,%d)\n",
				hwcard->slot_no,
				hwcard->bus_no,
				SDLA_GET_CPU(cpu_no),
				hwcard->used);
		return (EBUSY);
	}

	tmp_hw->hwprobe = NULL;
	tmp_hw->hwcard = NULL;
	hwcard->used--;			/* Decrement card usage */
	LIST_REMOVE(tmp_hw, next);
	free(tmp_hw, M_DEVBUF, 0);

	return (0);
}
#endif

static sdlahw_t*
sdla_hw_search(u_int16_t atype, int slot_no, int bus_no, int cpu_no)
{
	sdlahw_t*	tmp_hw;

	
	LIST_FOREACH(tmp_hw, &sdlahw_head, next) {
		if (tmp_hw->hwcard == NULL) {
			log(LOG_INFO,
			"Critical Error: sdla_cpu_search: line %d\n",
					__LINE__);
			// XXX REMOVE in LIST_FOREACH
			LIST_REMOVE(tmp_hw, next);
			continue;
		}
		if (tmp_hw->hwcard->atype != atype) {
			// XXX why ???
			LIST_REMOVE(tmp_hw, next);
			continue;
		}
		if (tmp_hw->hwcard->slot_no == slot_no &&
		    tmp_hw->hwcard->bus_no == bus_no &&
		    tmp_hw->cpu_no == cpu_no)
			return (tmp_hw);
	}

	return (NULL);
}


/*
 * Set up adapter.
 * o detect adapter type
 * o set up adapter shared memory
 * Return:	0	ok.
 *		< 0	error
 */

int
sdla_setup(void *phw)
{
	sdlahw_card_t*	hwcard = NULL;
	sdlahw_t*	hw = (sdlahw_t*)phw;
	int		err=0;

	WAN_ASSERT(hw == NULL);
	SDLA_MAGIC(hw);
	WAN_ASSERT(hw->hwcard == NULL);
	hwcard = hw->hwcard;
	switch (hwcard->type) {
	case SDLA_AFT:
		break;

	default:
		log(LOG_INFO, "%s: Invalid card type %x\n",
				hw->devname, hw->hwcard->type);
		return (EINVAL);
	}

	hw->dpmsize = SDLA_WINDOWSIZE;

	err = sdla_detect(hw);
	return (err);
}


/*
 * Shut down SDLA: disable shared memory access and interrupts, stop CPU, etc.
 */
int
sdla_down(void *phw)
{
	sdlahw_card_t*	card = NULL;
	sdlahw_t*	hw = (sdlahw_t*)phw;

	WAN_ASSERT(hw == NULL);
	SDLA_MAGIC(hw);
	WAN_ASSERT(hw->hwcard == NULL);
	card = hw->hwcard;
	switch (card->type) {
	case SDLA_AFT:
		/* free up the allocated virtual memory */
		if (hw->status & SDLA_MEM_MAPPED) {
			bus_space_unmap(hw->hwcard->memt,
					hw->dpmbase,
					XILINX_PCI_MEM_SIZE);
			hw->status &= ~SDLA_MEM_MAPPED;
		}
		break;

	default:
		return (EINVAL);
	}
	return (0);
}

/*
 * Read the hardware interrupt status.
 */
int
sdla_read_int_stat(void *phw, u_int32_t *int_status)
{
	sdlahw_card_t*	card = NULL;
	sdlahw_t*	hw = (sdlahw_t*)phw;

	WAN_ASSERT(hw == NULL);
	SDLA_MAGIC(hw);
	WAN_ASSERT(hw->hwcard == NULL);
	card = hw->hwcard;
	switch (card->type) {
	case SDLA_AFT:
		sdla_pci_read_config_dword(hw, PCI_INT_STATUS, int_status);
	}
	return (0);
}


/*
 * Generate an interrupt to adapter's CPU.
 */
int
sdla_cmd(void *phw, unsigned long offset, wan_mbox_t *mbox)
{
	sdlahw_t	*hw = (sdlahw_t*)phw;
	int		 len = sizeof(wan_cmd_t);
	int		 err = 0;
	u_int8_t	 value;

	SDLA_MAGIC(hw);
	len += mbox->wan_data_len;

	sdla_peek(hw, offset, (void*)&value, 1);
	if (value != 0x00) {
		log(LOG_INFO, "%s: opp flag set on entry to sdla_exec!\n",
				hw->devname);
		return (0);
	}
	mbox->wan_opp_flag = 0x00;
	sdla_poke(hw, offset, (void*)mbox, len);

	err = sdla_exec(hw, offset);
	if (!err) {
		log(LOG_INFO, "%s: Command 0x%02X failed!\n",
					hw->devname, mbox->wan_command);
		return (WAN_CMD_TIMEOUT);
	}
	sdla_peek(hw, offset, (void*)mbox, sizeof(wan_cmd_t));
	if (mbox->wan_data_len) {
		sdla_peek(hw, offset+offsetof(wan_mbox_t, wan_data),
		    mbox->wan_data, mbox->wan_data_len);
	}

	return (mbox->wan_return_code);
}

/*
 * Execute Adapter Command.
 * o Set exec flag.
 * o Busy-wait until flag is reset.
 * o Return number of loops made, or 0 if command timed out.
 */
static int
sdla_exec(sdlahw_t *hw, unsigned long offset)
{
	volatile unsigned long	tstop;
	volatile unsigned long	nloops;
	u_int8_t		value;

	value = 0x01;
	sdla_poke(hw, offset, (void*)&value, 1);
	tstop = ticks + EXEC_TIMEOUT;

	sdla_peek(hw, offset, (void*)&value, 1);
	for (nloops = 1; value == 0x01; ++ nloops) {
		DELAY(EXEC_DELAY);
		if (ticks - tstop > 0 || nloops > MAX_NLOOPS) {
			log(LOG_INFO, "%s: Timeout %lu ticks (max=%lu) "
			    "loops %lu (max=%u)\n", hw->devname,
			    (ticks-tstop+EXEC_TIMEOUT),
			    (unsigned long)EXEC_TIMEOUT, nloops, MAX_NLOOPS);
			return (0);		/* time is up! */
		}
		sdla_peek(hw, offset, (void*)&value, 1);
	}

	return (nloops);
}


/*
 * Read absolute adapter memory.
 * Transfer data from adapter's memory to data buffer.
 *
 * Note:
 * Care should be taken when crossing dual-port memory window boundary.
 * This function is not atomic, so caller must disable interrupt if
 * interrupt routines are accessing adapter shared memory.
 */
int
sdla_peek(void *phw, unsigned long addr, void *buf, unsigned len)
{
	sdlahw_card_t*	card = NULL;
	sdlahw_t*	hw = (sdlahw_t*)phw;
	int err = 0;

	WAN_ASSERT(hw == NULL);
	SDLA_MAGIC(hw);
	WAN_ASSERT(hw->hwcard == NULL);
	card = hw->hwcard;
	if (addr + len > hw->memory)	/* verify arguments */
		return (EINVAL);

	switch (card->type) {
	case SDLA_AFT:
		sdla_peek_by_4(hw, addr, buf, len);
		break;

	default:
		log(LOG_INFO, "%s: Invalid card type 0x%X\n",
			__FUNCTION__,card->type);
		err = (EINVAL);
		break;
	}
	return (err);
}


/*
 * Read data from adapter's memory to a data buffer in 4-byte chunks.
 * Note that we ensure that the SDLA memory address is on a 4-byte boundary
 * before we begin moving the data in 4-byte chunks.
*/
static void
sdla_peek_by_4(sdlahw_t *hw, unsigned long offset, u_int8_t *buf,
    unsigned int len)
{
	/* byte copy data until we get to a 4-byte boundary */
	while (len && (offset & 0x03)) {
		sdla_bus_read_1(hw, offset++, buf);
		buf++;
		len--;
	}

	/* copy data in 4-byte chunks */
	while (len >= 4) {
		sdla_bus_read_4(hw, offset, (u_int32_t*)buf);
		buf += 4;
		offset += 4;
		len -= 4;
	}

	/* byte copy any remaining data */
	while (len) {
		sdla_bus_read_1(hw, offset++, buf);
		buf++;
		len--;
	}
}

/*
 * Write Absolute Adapter Memory.
 * Transfer data from data buffer to adapter's memory.
 *
 * Note:
 * Care should be taken when crossing dual-port memory window boundary.
 * This function is not atomic, so caller must disable interrupt if
 * interrupt routines are accessing adapter shared memory.
 */
int
sdla_poke(void *phw, unsigned long addr, void *buf, unsigned len)
{
	sdlahw_card_t*	card = NULL;
	sdlahw_t*	hw = (sdlahw_t*)phw;
	int err = 0;

	WAN_ASSERT(hw == NULL);
	SDLA_MAGIC(hw);
	WAN_ASSERT(hw->hwcard == NULL);
	card = hw->hwcard;
	if (addr + len > hw->memory) {	/* verify arguments */
		return (EINVAL);
	}

	switch (card->type) {
	case SDLA_AFT:
		sdla_poke_by_4(hw, addr, buf, len);
		break;

	default:
		log(LOG_INFO, "%s: Invalid card type 0x%X\n",
			__FUNCTION__,card->type);
		err = (EINVAL);
		break;
	}
	return (err);
}


/*
 * Write from a data buffer to adapter's memory in 4-byte chunks.
 * Note that we ensure that the SDLA memory address is on a 4-byte boundary
 * before we begin moving the data in 4-byte chunks.
*/
static void
sdla_poke_by_4(sdlahw_t *hw, unsigned long offset, u_int8_t *buf,
    unsigned int len)
{
	/* byte copy data until we get to a 4-byte boundary */
	while (len && (offset & 0x03)) {
		sdla_bus_write_1(hw, offset++, *buf);
		buf++;
		len --;
	}

	/* copy data in 4-byte chunks */
	while (len >= 4) {
		sdla_bus_write_4(hw, offset, *(unsigned long *)buf);
		offset += 4;
		buf += 4;
		len -= 4;
	}

	/* byte copy any remaining data */
	while (len) {
		sdla_bus_write_1(hw, offset++, *buf);
		buf++;
		len --;
	}
}

int
sdla_poke_byte(void *phw, unsigned long offset, u_int8_t value)
{
	sdlahw_t *hw = (sdlahw_t*)phw;

	SDLA_MAGIC(hw);
	/* Sangoma ISA card sdla_bus_write_1(hw, offset, value); */
	sdla_poke(hw, offset, (void*)&value, 1);
	return (0);
}

int
sdla_set_bit(void *phw, unsigned long offset, u_int8_t value)
{
	sdlahw_t	*hw = (sdlahw_t*)phw;
	u_int8_t	 tmp;

	SDLA_MAGIC(hw);
	/* Sangoma ISA card -> sdla_bus_read_1(hw, offset, &tmp); */
	sdla_peek(hw, offset, (void*)&tmp, 1);
	tmp |= value;
	/* Sangoma ISA card -> sdla_bus_write_1(hw, offset, tmp); */
	sdla_poke(hw, offset, (void*)&tmp, 1);
	return (0);
}

int
sdla_clear_bit(void *phw, unsigned long offset, u_int8_t value)
{
	sdlahw_t	*hw = (sdlahw_t*)phw;
	u_int8_t	 tmp;

	SDLA_MAGIC(hw);
	/* Sangoma ISA card -> sdla_bus_read_1(hw, offset, &tmp); */
	sdla_peek(hw, offset, (void*)&tmp, 1);
	tmp &= ~value;
	/* Sangoma ISA card -> sdla_bus_write_1(hw, offset, tmp); */
	sdla_poke(hw, offset, (void*)&tmp, 1);
	return (0);
}

/*
 * Find the AFT HDLC PCI adapter in the PCI bus.
 * Return the number of AFT adapters found (0 if no adapter found).
 */
static int
sdla_detect_aft(sdlahw_t *hw)
{
	sdlahw_card_t	*card;
	u_int16_t	 ut_u16;

	WAN_ASSERT(hw == NULL);
	WAN_ASSERT(hw->hwcard == NULL);
	card = hw->hwcard;
	sdla_pci_read_config_dword(hw,
	    (hw->cpu_no == SDLA_CPU_A) ? PCI_IO_BASE_DWORD :
	    PCI_MEM_BASE0_DWORD, (u_int32_t*)&hw->mem_base_addr);
	if (!hw->mem_base_addr) {
		if (hw->cpu_no == SDLA_CPU_B) {
			printf("%s: No PCI memory allocated for CPU #B\n",
					hw->devname);
		} else {
			printf("%s: No PCI memory allocated to card\n",
					hw->devname);
		}
		return (EINVAL);
	}
#ifdef DEBUG
	log(LOG_INFO,  "%s: AFT PCI memory at 0x%lX\n",
				hw->devname, (unsigned long)hw->mem_base_addr);
#endif /* DEBUG */
	sdla_pci_read_config_byte(hw, PCI_INTLINE, (u_int8_t*)&hw->irq);
	if (hw->irq == PCI_IRQ_NOT_ALLOCATED) {
		printf("%s: IRQ not allocated to AFT adapter\n", hw->devname);
		return (EINVAL);
	}

#ifdef DEBUG
	log(LOG_INFO, "%s: IRQ %d allocated to the AFT PCI card\n",
	    hw->devname, hw->irq);
#endif /* DEBUG */

	hw->memory=XILINX_PCI_MEM_SIZE;

	/* Map the physical PCI memory to virtual memory */
	bus_space_map(hw->hwcard->memt, hw->mem_base_addr, XILINX_PCI_MEM_SIZE,
	    0, &hw->dpmbase);
	if (!hw->dpmbase) {
		printf("%s: can't map mem space\n", hw->devname);
		return (EINVAL);
	}
	hw->status |= SDLA_MEM_MAPPED;


	/* Enable master operation on PCI and enable bar0 memory */
	sdla_pci_read_config_word(hw, XILINX_PCI_CMD_REG, &ut_u16);
	ut_u16 |=0x06;
	sdla_pci_write_config_word(hw, XILINX_PCI_CMD_REG, ut_u16);

	/* Set PCI Latency of 0xFF*/
	sdla_pci_write_config_dword(hw, XILINX_PCI_LATENCY_REG,
	    XILINX_PCI_LATENCY);

	return (0);
}


/*
 * Detect adapter type.
 */
static int
sdla_detect(sdlahw_t *hw)
{
	sdlahw_card_t	*card = NULL;
	int		 err = 0;

	WAN_ASSERT(hw == NULL);
	WAN_ASSERT(hw->hwcard == NULL);
	card = hw->hwcard;
	switch (card->type) {
	case SDLA_AFT:
		err = sdla_detect_aft(hw);
		break;
	}
	if (err)
		sdla_down(hw);

	return (err);
}

int
sdla_is_te1(void *phw)
{
	sdlahw_card_t	*hwcard = NULL;
	sdlahw_t	*hw = (sdlahw_t*)phw;

	WAN_ASSERT(hw == NULL);
	SDLA_MAGIC(hw);
	WAN_ASSERT(hw->hwcard == NULL);
	hwcard = hw->hwcard;
	switch (hwcard->atype) {
	case S5144_ADPTR_1_CPU_T1E1:
	case S5147_ADPTR_2_CPU_T1E1:
	case S5148_ADPTR_1_CPU_T1E1:
	case A101_ADPTR_1TE1:
	case A101_ADPTR_2TE1:
		return (1);
	}
	return (0);
}

int
sdla_check_mismatch(void *phw, unsigned char media)
{
	sdlahw_card_t	*hwcard = NULL;
	sdlahw_t	*hw = (sdlahw_t*)phw;

	WAN_ASSERT(hw == NULL);
	SDLA_MAGIC(hw);
	WAN_ASSERT(hw->hwcard == NULL);
	hwcard = hw->hwcard;
	if (media == WAN_MEDIA_T1 ||
	    media == WAN_MEDIA_E1) {
		if (hwcard->atype != S5144_ADPTR_1_CPU_T1E1 &&
		    hwcard->atype != S5147_ADPTR_2_CPU_T1E1 &&
		    hwcard->atype != S5148_ADPTR_1_CPU_T1E1) {
			log(LOG_INFO, "%s: Error: Card type mismatch: "
			    "User=T1/E1 Actual=%s\n", hw->devname,
			    SDLA_ADPTR_DECODE(hwcard->atype));
			return (EIO);
		}
		hwcard->atype = S5144_ADPTR_1_CPU_T1E1;

	} else if (media == WAN_MEDIA_56K) {
		if (hwcard->atype != S5145_ADPTR_1_CPU_56K) {
			log(LOG_INFO, "%s: Error: Card type mismatch: "
			    "User=56K Actual=%s\n", hw->devname,
			    SDLA_ADPTR_DECODE(hwcard->atype));
			return (EIO);
		}
	} else {
		if (hwcard->atype == S5145_ADPTR_1_CPU_56K ||
		    hwcard->atype == S5144_ADPTR_1_CPU_T1E1 ||
		    hwcard->atype == S5147_ADPTR_2_CPU_T1E1 ||
		    hwcard->atype == S5148_ADPTR_1_CPU_T1E1) {
			log(LOG_INFO, "%s: Error: Card type mismatch: "
			    "User=S514(1/2/3) Actual=%s\n", hw->devname,
			    SDLA_ADPTR_DECODE(hwcard->atype));
			return (EIO);
		}
	}

	return (0);
}

int
sdla_getcfg(void *phw, int type, void *value)
{
	sdlahw_t*	hw = (sdlahw_t*)phw;
	sdlahw_card_t *hwcard;

	WAN_ASSERT(hw == NULL);
	SDLA_MAGIC(hw);
	WAN_ASSERT(hw->hwcard == NULL);
	hwcard = hw->hwcard;
	switch (type) {
	case SDLA_CARDTYPE:
		*(u_int16_t*)value = hwcard->type;
		break;
	case SDLA_MEMBASE:
		*(bus_space_handle_t*)value = hw->dpmbase;
		break;
	case SDLA_MEMEND:
		*(u_int32_t*)value = ((unsigned long)hw->dpmbase +
		    hw->dpmsize - 1);
		break;
	case SDLA_MEMSIZE:
		*(u_int16_t*)value = hw->dpmsize;
		break;
	case SDLA_MEMORY:
		*(u_int32_t*)value = hw->memory;
		break;
	case SDLA_IRQ:
		*(u_int16_t*)value = hw->irq;
		break;
	case SDLA_ADAPTERTYPE:
		*(u_int16_t*)value = hwcard->atype;
		break;
	case SDLA_CPU:
		*(u_int16_t*)value = hw->cpu_no;
		break;
	case SDLA_SLOT:
		*(u_int16_t*)value = hwcard->slot_no;
		break;
	case SDLA_BUS:
		*(u_int16_t*)value = hwcard->bus_no;
		break;
	case SDLA_DMATAG:
		*(bus_dma_tag_t*)value = hwcard->pa.pa_dmat;
		break;
	case SDLA_PCIEXTRAVER:
		*(u_int8_t*)value = hwcard->pci_extra_ver;
		break;
	case SDLA_BASEADDR:
		*(u_int32_t*)value = hw->mem_base_addr;
		break;
	}
	return (0);
}


int
sdla_get_hwcard(void *phw, void **phwcard)
{
	sdlahw_t *hw = (sdlahw_t*)phw;

	WAN_ASSERT(hw == NULL);
	SDLA_MAGIC(hw);

	*phwcard = hw->hwcard;
	return (0);
}


int
sdla_get_hwprobe(void *phw, void **str)
{
	sdlahw_t *hw = (sdlahw_t*)phw;

	WAN_ASSERT(hw == NULL);
	SDLA_MAGIC(hw);

	if (hw->hwprobe)
		*str = hw->hwprobe->hw_info;

	return (0);
}

int
sdla_bus_write_1(void *phw, unsigned int offset, u_int8_t value)
{
	sdlahw_t *hw = (sdlahw_t*)phw;

	WAN_ASSERT(hw == NULL);
	SDLA_MAGIC(hw);
	if (!(hw->status & SDLA_MEM_MAPPED))
		return (0);
	bus_space_write_1(hw->hwcard->memt, hw->dpmbase, offset, value);
	return (0);
}

int
sdla_bus_write_2(void *phw, unsigned int offset, u_int16_t value)
{
	sdlahw_t *hw = (sdlahw_t*)phw;

	WAN_ASSERT(hw == NULL);
	SDLA_MAGIC(hw);
	if (!(hw->status & SDLA_MEM_MAPPED))
		return (0);
	bus_space_write_2(hw->hwcard->memt, hw->dpmbase, offset, value);
	return (0);
}

int
sdla_bus_write_4(void *phw, unsigned int offset, u_int32_t value)
{
	sdlahw_t *hw = (sdlahw_t*)phw;

	WAN_ASSERT(hw == NULL);
	SDLA_MAGIC(hw);
	if (!(hw->status & SDLA_MEM_MAPPED))
		return (0);
	bus_space_write_4(hw->hwcard->memt, hw->dpmbase, offset, value);
	return (0);
}

int
sdla_bus_read_1(void *phw, unsigned int offset, u_int8_t *value)
{
	sdlahw_t *hw = (sdlahw_t*)phw;

	WAN_ASSERT2(hw == NULL, 0);
	SDLA_MAGIC(hw);
	if (!(hw->status & SDLA_MEM_MAPPED))
		return (0);
	*value = bus_space_read_1(hw->hwcard->memt, hw->dpmbase, offset);
	return (0);
}

int
sdla_bus_read_2(void *phw, unsigned int offset, u_int16_t *value)
{
	sdlahw_t *hw = (sdlahw_t*)phw;

	WAN_ASSERT2(hw == NULL, 0);
	SDLA_MAGIC(hw);
	if (!(hw->status & SDLA_MEM_MAPPED))
		return (0);
	*value = bus_space_read_2(hw->hwcard->memt, hw->dpmbase, offset);
	return (0);
}

int
sdla_bus_read_4(void *phw, unsigned int offset, u_int32_t *value)
{
	sdlahw_t *hw = (sdlahw_t*)phw;

	WAN_ASSERT2(hw == NULL, 0);
	WAN_ASSERT2(hw->dpmbase == 0, 0);
	SDLA_MAGIC(hw);
	if (!(hw->status & SDLA_MEM_MAPPED))
		return (0);
	*value = bus_space_read_4(hw->hwcard->memt, hw->dpmbase, offset);
	return (0);
}

static int
sdla_pci_read_config_dword(void *phw, int reg, u_int32_t *value)
{
	sdlahw_t	*hw = (sdlahw_t*)phw;
	sdlahw_card_t	*hwcard;

	WAN_ASSERT(hw == NULL);
	SDLA_MAGIC(hw);
	WAN_ASSERT(hw->hwcard == NULL);
	hwcard = hw->hwcard;
	*value = pci_conf_read(hwcard->pa.pa_pc, hwcard->pa.pa_tag, reg);
	return (0);
}

static int
sdla_pci_read_config_word(void *phw, int reg, u_int16_t *value)
{
	sdlahw_t	*hw = (sdlahw_t*)phw;
	sdlahw_card_t	*hwcard;
	u_int32_t	 tmp = 0x00;

	WAN_ASSERT(hw == NULL);
	SDLA_MAGIC(hw);
	WAN_ASSERT(hw->hwcard == NULL);
	hwcard = hw->hwcard;
	tmp = pci_conf_read(hwcard->pa.pa_pc, hwcard->pa.pa_tag, reg);
	*value = (u_int16_t)((tmp >> 16) & 0xFFFF);
	return (0);
}

static int
sdla_pci_read_config_byte(void *phw, int reg, u_int8_t *value)
{
	sdlahw_t	*hw = (sdlahw_t*)phw;
	sdlahw_card_t	*hwcard;
	u_int32_t	 tmp = 0x00;

	WAN_ASSERT(hw == NULL);
	SDLA_MAGIC(hw);
	WAN_ASSERT(hw->hwcard == NULL);
	hwcard = hw->hwcard;
	tmp = pci_conf_read(hwcard->pa.pa_pc, hwcard->pa.pa_tag, reg);
	*value = (u_int8_t)(tmp & 0xFF);
	return (0);
}

static int
sdla_pci_write_config_dword(void *phw, int reg, u_int32_t value)
{
	sdlahw_t *hw = (sdlahw_t*)phw;
	sdlahw_card_t *card;

	WAN_ASSERT(hw == NULL);
	SDLA_MAGIC(hw);
	WAN_ASSERT(hw->hwcard == NULL);
	card = hw->hwcard;
	pci_conf_write(card->pa.pa_pc, card->pa.pa_tag, reg, value);
	return (0);
}

static int
sdla_pci_write_config_word(void *phw, int reg, u_int16_t value)
{
	sdlahw_t *hw = (sdlahw_t*)phw;
	sdlahw_card_t *card;

	WAN_ASSERT(hw == NULL);
	SDLA_MAGIC(hw);
	WAN_ASSERT(hw->hwcard == NULL);
	card = hw->hwcard;
	pci_conf_write(card->pa.pa_pc, card->pa.pa_tag, reg, value);
	return (0);
}
@


1.16
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sandrv.c,v 1.15 2013/11/11 03:08:20 dlg Exp $	*/
@


1.15
log
@replace things like "start + interval > ticks" with
"ticks - start > interval" because the latter copes with ticks wrapping.

pointed out by guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sandrv.c,v 1.14 2009/03/29 21:53:52 sthen Exp $	*/
d388 1
a388 1
		free(tmp, M_DEVBUF);
d635 1
a635 1
	free(tmp_card, M_DEVBUF);
d726 1
a726 1
	free(tmp_hw, M_DEVBUF);
@


1.14
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sandrv.c,v 1.13 2009/01/20 20:03:45 grange Exp $	*/
d907 1
a907 1
		if (ticks > tstop || nloops > MAX_NLOOPS) {
@


1.13
log
@Change the ``buf'' parameter of sdla_{peek,poke}_by_4()
from void * to u_int_8 * to avoid redundant and illegal lvalue
casts. No functional changes.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sandrv.c,v 1.12 2007/10/01 15:34:48 krw Exp $	*/
d491 1
a491 1
		printf(": couldn't map interrupt\n");
d1150 1
a1150 1
		printf("%s: couldn't map memory\n", hw->devname);
@


1.12
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...' where
obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sandrv.c,v 1.11 2006/04/20 20:31:12 miod Exp $	*/
d169 2
a170 2
static void sdla_peek_by_4(sdlahw_t *, unsigned long, void *, unsigned int);
static void sdla_poke_by_4(sdlahw_t *, unsigned long, void *, unsigned int);
d965 2
a966 1
sdla_peek_by_4(sdlahw_t *hw, unsigned long offset, void *buf, unsigned int len)
d970 2
a971 2
		sdla_bus_read_1(hw, offset++, (u_int8_t*)buf);
		((u_int8_t *)buf)++;
d978 1
a978 1
		(u_int8_t*)buf += 4;
d985 2
a986 2
		sdla_bus_read_1(hw, offset++, (u_int8_t*)buf);
		((u_int8_t *)buf)++;
d1036 2
a1037 1
sdla_poke_by_4(sdlahw_t *hw, unsigned long offset, void *buf, unsigned int len)
d1041 2
a1042 2
		sdla_bus_write_1(hw, offset++, *(char *)buf);
		((char *)buf) ++;
d1050 1
a1050 1
		(char*)buf += 4;
d1056 2
a1057 2
		sdla_bus_write_1(hw, offset++, *(char *)buf);
		((char *)buf) ++;
@


1.11
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sandrv.c,v 1.10 2005/04/01 21:42:36 canacar Exp $	*/
d399 1
a399 1
	tmp_hw_probe = malloc(sizeof(sdla_hw_probe_t), M_DEVBUF, M_NOWAIT);
a402 2
	bzero(tmp_hw_probe, sizeof(sdla_hw_probe_t));

d582 1
a582 1
	new_hwcard = malloc(sizeof(sdlahw_card_t), M_DEVBUF, M_NOWAIT);
a585 2
	bzero(new_hwcard, sizeof(sdlahw_card_t));

d666 1
a666 1
	new_hw = malloc(sizeof(sdlahw_t), M_DEVBUF, M_NOWAIT);
a668 2

	bzero(new_hw, sizeof(sdlahw_t));
@


1.10
log
@Improve san(4) driver:

* Some KNF, fix return values (from -Exxx to Exxx)
* Some string handling paranoia.
* Use ifconfig media options to switch between ppp and cHDLC modes,
  based on patch from claudio@@
* tcpdump works, patch from claudio@@
* ppp mode now works.

Lots of testing & feedback by Greg Mortensen,
Additional testing Sean Knox
ok alex@@, go go go deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sandrv.c,v 1.9 2005/03/13 10:47:24 brad Exp $	*/
d558 1
a558 1
	log(LOG_INFO, "%d: Disestablish interrupt is not defined!\n",
@


1.9
log
@revert rev 1.8
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sandrv.c,v 1.8 2005/03/01 18:37:07 mcbride Exp $	*/
d234 4
a237 5
	if (!(vendor_id == SANGOMA_PCI_VENDOR &&
	    device_id == SANGOMA_PCI_DEVICE) ||
	    (vendor_id == SANGOMA_PCI_VENDOR_OLD &&
	    device_id == SANGOMA_PCI_DEVICE)) {
		return (0);
d239 1
a239 1
	return (1);
d339 1
a339 1
	memset(&sdla_adapter_cnt,0,sizeof(sdla_hw_type_cnt_t));
d361 2
a362 3
		if (sdla_hw_unregister(tmp->hwcard, tmp->cpu_no) == -EBUSY){
			return -EBUSY;
		}
d373 2
a374 3
					 tmp->ioport) == -EBUSY){
			return -EBUSY;
		}
d385 1
a385 1
			return -EBUSY;
d400 1
a400 1
	if (!tmp_hw_probe)
d403 1
a403 1
	memset(tmp_hw_probe,0,sizeof(sdla_hw_probe_t));
d492 1
a492 1
	if (pci_intr_map(pa,&ih)) {
d494 1
a494 1
		return (-EINVAL);
d497 1
a497 1
	if (intrstr != NULL) {
d499 1
a499 1
	}
d504 3
a506 3
	if (hwcard == NULL) {
		return (-EINVAL);
	}
d517 2
a518 1
		if (atype == A101_ADPTR_2TE1) dual_cpu = 1;
d524 4
a527 4
	    return (-EINVAL);
	if (san_dev_attach(hw, hw->devname)) {
		return (-EINVAL);
	}
d539 1
a539 1
sdla_intr_establish(void *phw, int(*intr_func)(void*), void* intr_arg)
d547 3
a549 3
	    intr_func, intr_arg, "san") == NULL) {
		return (-EINVAL);
	}
d560 1
a560 1
	return (-EINVAL);
d569 2
a570 2
void
*sdla_get_hw_adptr_cnt(void)
d581 1
a581 1
	if (new_hwcard) {
d583 1
a583 1
	}
d585 1
a585 1
	if (!new_hwcard) {
a586 1
	}
d588 1
a588 1
	memset(new_hwcard,0,sizeof(sdlahw_card_t));
d599 1
a599 1
		if (!LIST_NEXT(last_hwcard, next)) {
a600 1
		}
d602 2
a603 1
	if (last_hwcard) {
d605 1
a605 1
	} else {
d607 1
a607 1
	}
d630 1
a630 1
		return -EFAULT;
d636 1
a636 1
		return -EBUSY;
d650 1
a650 1
		if (tmp_card->atype != atype) {
d652 1
a652 1
		}
d654 1
a654 1
		    tmp_card->bus_no == bus_no) {
a655 1
		}
d667 1
a667 1
	if (new_hw) {
d669 1
a669 1
	}
d674 1
a674 1
	memset(new_hw,0,sizeof(sdlahw_t));
d686 1
a686 1
		if (!LIST_NEXT(last_hw, next)) {
a687 1
		}
d689 1
a689 1
	if (last_hw) {
d691 1
a691 1
	}else{
d693 1
a693 1
	}
d704 2
a705 2
	LIST_FOREACH(tmp_hw, &sdlahw_head, next){
		if (tmp_hw->hwcard != hwcard){
d707 2
a708 2
		}
		if (tmp_hw->cpu_no == cpu_no){
a709 1
		}
d711 2
a712 1
	if (tmp_hw == NULL){
d716 1
a716 1
		return -EFAULT;
d718 1
a718 1
	if (tmp_hw->used){
d725 1
a725 1
		return -EBUSY;
d733 2
a734 1
	return 0;
d743 1
d749 1
d754 1
d760 1
a760 1
		    tmp_hw->cpu_no == cpu_no) {
a761 1
		}
d763 1
d794 1
a794 1
		return (-EINVAL);
d829 1
a829 1
		return (-EINVAL);
d948 1
a948 1
		return (-EINVAL);
d958 1
a958 1
		err = -EINVAL;
d1017 1
a1017 1
		return (-EINVAL);
d1028 1
a1028 1
		err = -EINVAL;
d1131 1
a1131 1
		return (-EINVAL);
d1140 1
a1140 1
		return (-EINVAL);
d1155 1
a1155 1
		return (-EINVAL);
d1190 1
a1190 1
	if (err) {
d1192 1
a1192 1
	}
d1235 1
a1235 1
			return (-EIO);
d1239 1
a1239 1
	}else if (media == WAN_MEDIA_56K) {
d1244 1
a1244 1
			return (-EIO);
d1246 1
a1246 1
	}else{
d1254 1
a1254 1
			return (-EIO);
d1257 1
d1338 1
a1338 1
	if (hw->hwprobe) {
d1340 1
a1340 1
	}
@


1.8
log
@- make large packets work without hanging the interface
- make tcpdump attach correctly

by Alex Feldman prodded via Greg Mortensen <thevision@@pobox.com>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sandrv.c,v 1.6 2004/12/07 06:10:24 mcbride Exp $	*/
d189 2
a190 2
int	san_match	__P((struct device *, void *, void *));
void	san_attach	__P((struct device *, struct device *, void *));
@


1.7
log
@Remove __P usage in sys that has crept back in.
'Looks fine' millert@@, ok miod@@
@
text
@d189 2
a190 2
int	san_match(struct device *, void *, void *);
void	san_attach(struct device *, struct device *, void *);
@


1.6
log
@Cleanup. Rename some defines, add wp_lite_set_te1_cfg()
(used to change LBO and T1/E1 clock configurations)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sandrv.c,v 1.5 2004/08/25 13:09:11 markus Exp $	*/
d189 2
a190 2
int	san_match	__P((struct device *, void *, void *));
void	san_attach	__P((struct device *, struct device *, void *));
@


1.5
log
@unbreak DEBUG; ok henning, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sandrv.c,v 1.4 2004/07/16 15:11:45 alex Exp $	*/
d1228 2
a1229 2
	if (media == WANOPT_MEDIA_T1 ||
	    media == WANOPT_MEDIA_E1) {
d1240 1
a1240 1
	}else if (media == WANOPT_MEDIA_56K) {
@


1.4
log
@Aft source update.
mcbride ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sandrv.c,v 1.3 2004/06/26 22:05:25 mcbride Exp $	*/
a308 4
	case PCI_VENDOR_ID_GSI:
		log(LOG_INFO, "%s: Sangoma S518 ADSL adapter\n",
					self->dv_xname);
		break;
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sandrv.c,v 1.2 2004/06/26 20:17:23 mcbride Exp $	*/
d174 1
a174 1
static int sdla_card_unregister (unsigned char hw_type, int slot_no, int bus_no, int ioport);
d180 1
a180 1
static int sdla_hw_unregister(sdlahw_card_t* card, int cpu_no);
d390 1
a390 1
			log(LOG_INFO, "sdladrv: HW probe info is in used (%s)\n",
d620 1
a620 1
sdla_card_unregister (u_int16_t atype, int slot_no, int bus_no, int ioport)
d634 2
a635 1
		log(LOG_INFO, "Error: Card didn't find %04X card (slot=%d, bus=%d)\n",
d640 2
a641 1
		log(LOG_INFO, "Error: Card is still in used (slot=%d,bus=%d,used=%d)\n",
d708 1
a708 1
sdla_hw_unregister (sdlahw_card_t* hwcard, int cpu_no)
d722 3
a724 2
		log(LOG_INFO, "Error: Failed to find device (slot=%d,bus=%d,cpu=%c)\n",
				hwcard->slot_no, hwcard->bus_no, SDLA_GET_CPU(cpu_no));
d728 6
a733 2
		log(LOG_INFO, "Error: Device is still in used (slot=%d,bus=%d,cpu=%c,used=%d)\n",
				hwcard->slot_no, hwcard->bus_no, SDLA_GET_CPU(cpu_no), hwcard->used);
d753 3
a755 1
			log(LOG_INFO, "Critical Error: sdla_cpu_search: line %d\n", __LINE__);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 11
a48 25
/*
****************************************************************************
****		For Debug purpose (only OpenBSD)			****
****************************************************************************
*/

/***************************************************************************
****		I N C L U D E  		F I L E S			****
***************************************************************************/

# include <sys/types.h>
# include <sys/param.h>
# include <sys/systm.h>
# include <sys/syslog.h>
# include <sys/malloc.h>
# include <sys/kernel.h>

# include <dev/pci/pcireg.h>
# include <dev/pci/pcivar.h>
# include <dev/pci/if_san_front_end.h>
# include <dev/pci/if_sandrv.h>

/***************************************************************************
****			M A C R O S / D E F I N E S			****
***************************************************************************/
d51 1
a51 1
# define EXEC_TIMEOUT	(hz*2)
d53 1
a53 1
 			/* timeout used if jiffies are stopped
d55 1
a55 1
			** EXEC_TIMEOUT=EXEC_DELAY*2000 = 40000 
d57 2
a58 2
 
#define	EXEC_HZ_DIVISOR	8/10    
d60 1
a60 1
			** timeout, thus use HZ * EXEC_HZ_DIVISOR to get 
d67 1
a67 1
			
d72 2
a73 2
#define V3_DEVICE_ID  		0x0002		/* V3 device ID number */
#define SANGOMA_SUBSYS_VENDOR 	0x4753		/* ID for Sangoma */
d86 2
a87 1
#define PCI_SUBVENDOR(pa)	(pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG) & PCI_SUBVENDOR_MASK)
d97 1
a97 2
struct san_softc
{
d99 1
a99 1
	struct pci_attach_args 	pa;
d103 1
a103 1
	int 				used;
d112 1
a112 1
	int 			used;
d117 1
a117 1
	unsigned char 		pci_extra_ver;
d126 1
a126 1
/*----------------------------------------------------------------------------
d130 21
a150 22
typedef struct sdlahw
{
	int			used;
	unsigned		magic;
	char			devname[20];
	u_int16_t		status;
	int 			irq;		/* interrupt request level */
	unsigned int		cpu_no;		/* PCI CPU Number */
	char 			auto_pci_cfg;	/* Auto PCI configuration */
	bus_addr_t 		mem_base_addr;
	bus_space_handle_t	dpmbase;	/* dual-port memory base */
	unsigned 		dpmsize;	/* dual-port memory size */
	unsigned long 		memory;		/* memory size */

	unsigned 		reserved[5];
	unsigned char		hw_info[100];

	u_int16_t		configured;
	void			*arg;			/* card structure */
	sdla_hw_probe_t*	hwprobe;
	sdlahw_card_t*		hwcard;
	LIST_ENTRY(sdlahw)	next;
a152 1
/****** Function Prototypes *************************************************/
d157 1
a157 1
static int sdla_pci_probe(int, struct pci_attach_args*);
d160 11
a170 11
static int sdla_pci_write_config_word(void*, int, u_int16_t);
static int sdla_pci_write_config_dword(void*, int, u_int32_t);
static int sdla_pci_read_config_byte(void*, int, u_int8_t*);
static int sdla_pci_read_config_word(void*, int, u_int16_t*);
static int sdla_pci_read_config_dword(void*, int, u_int32_t*);

static int sdla_detect	(sdlahw_t* hw);
static int sdla_detect_aft(sdlahw_t* hw);
static int sdla_exec (sdlahw_t* hw, unsigned long offset);
static void sdla_peek_by_4 (sdlahw_t*, unsigned long, void*, unsigned int);
static void sdla_poke_by_4 (sdlahw_t*, unsigned long, void*, unsigned int);
d172 1
a172 1
static sdlahw_card_t* sdla_card_register(u_int16_t atype, int slot_no, int bus_no);
d176 1
a176 1
static sdlahw_card_t* sdla_card_search(u_int16_t atype, int slot_no, int bus_no);
d178 1
a178 1
static sdlahw_t* sdla_hw_register(sdlahw_card_t* card, int cpu_no, int irq, void*);
d182 1
a182 1
static sdlahw_t* sdla_hw_search(u_int16_t atype, int slot_no, int bus_no, int cpu_no);
d184 7
a190 2
static sdlahw_t* sdla_aft_hw_select (sdlahw_card_t* card, int cpu_no, int irq, struct pci_attach_args* pa);
static void sdla_save_hw_probe (sdlahw_t* hw, int port);
a192 6
/* SDLA PCI device relative entry point 				*/
int 	san_match	__P((struct device*, void*, void*));
void 	san_attach __P((struct device*, struct device*, void*));

/****** Global Data *********************************************************/

d209 1
a209 1
char		*san_drvname	= "san";
d214 6
a219 6
LIST_HEAD(, sdlahw_card) sdlahw_card_head = 
			LIST_HEAD_INITIALIZER(sdlahw_card_head);
LIST_HEAD(, sdlahw) sdlahw_head = 
			LIST_HEAD_INITIALIZER(sdlahw_head);
LIST_HEAD(, sdla_hw_probe) sdlahw_probe_head = 
			LIST_HEAD_INITIALIZER(sdlahw_probe_head);
a222 1
/***************************************************************************/
d224 5
a228 4
/******* PCI Device Driver Entry Points ********************************/
int san_match(parent, match, aux)
	struct device* parent;
	void* match, *aux;
d231 2
a232 2
	u_int16_t		vendor_id = PCI_VENDOR(pa->pa_id);	
	u_int16_t		device_id = PCI_DEVICE(pa->pa_id);	
d234 5
a238 3
	if (!(vendor_id == SANGOMA_PCI_VENDOR && device_id == SANGOMA_PCI_DEVICE) ||
	     (vendor_id == SANGOMA_PCI_VENDOR_OLD && device_id == SANGOMA_PCI_DEVICE)){
		return 0;
d240 1
a240 1
	return 1;
d244 2
a245 3
void san_attach(parent, self, aux)
	struct device *parent, *self;
	void*	aux;
d248 7
a254 6
	u_int16_t			vendor_id = PCI_VENDOR(pa->pa_id);	
	u_int16_t			subvendor_id = PCI_SUBVENDOR(pa);	
	int 				atype = 0x00;

	atype = PCI_PRODUCT(pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG));
	switch(vendor_id){
d257 1
a257 1
		switch(subvendor_id){
d272 1
a272 1
	if (sdla_pci_probe(atype, pa)){
d277 2
a278 2
#if defined(DEBUG)
	switch(PCI_VENDOR(pa->pa_id)){
d280 1
a280 1
		switch(atype){
d282 2
a283 2
    			log(LOG_INFO, "%s: Sangoma S5141/FT1 (Single CPU) adapter\n", 
							self->dv_xname);
d286 2
a287 2
			log(LOG_INFO, "%s: Sangoma S5142 (Dual CPU) adapter\n", 
							self->dv_xname);
d290 2
a291 2
    			log(LOG_INFO, "%s: Sangoma S5143 (Single CPU) FT1 adapter\n", 
							self->dv_xname);
d295 2
a296 2
    			log(LOG_INFO, "%s: Sangoma S5144 (Single CPU) T1/E1 adapter\n", 
							self->dv_xname);
d298 3
a300 3
		case S5145_ADPTR_1_CPU_56K:		
    			log(LOG_INFO, "%s: Sangoma S5145 (Single CPU) 56K adapter\n", 
							self->dv_xname);
d303 2
a304 2
    			log(LOG_INFO, "%s: Sangoma S5147 (Dual CPU) T1/E1 adapter\n", 
							self->dv_xname);
d310 1
a310 1
    		log(LOG_INFO, "%s: Sangoma S518 ADSL adapter\n", 
d314 1
a314 1
		switch(atype){
d316 2
a317 2
    			log(LOG_INFO, "%s: Sangoma AFT (1 channel) T1/E1 adapter\n", 
							self->dv_xname);
d320 2
a321 2
    			log(LOG_INFO, "%s: Sangoma AFT (2 channels) T1/E1 adapter\n", 
							self->dv_xname);
d325 1
a325 1
	}	
d330 1
a330 1
/*==========================================================================
d333 2
a334 1
int sdladrv_init(void)
d336 1
a336 1
	int volatile i=0;
d339 2
a340 2
         * will store flags, used to mark 
         * card initialization state */
d346 1
a346 1
	return 0;
d349 1
a349 1
/*============================================================================
d353 2
a354 1
int sdladrv_exit (void)
d363 1
a363 1
	while(elm_hw){
d373 1
a373 1
	while(elm_hw_card){
d376 3
a378 3
		if (sdla_card_unregister(tmp->hw_type, 
					 tmp->slot_no, 
					 tmp->bus_no, 
d386 1
a386 1
	while(elm_hw_probe){
d398 1
a398 1
	return 0;
d401 2
a402 14
/*
*****************************************************************************
*****************************************************************************
G***		S A N G O M A  H A R D W A R E  P R O B E 		*****
*****************************************************************************
*****************************************************************************
*/
/*
*****************************************************************************
**			sdla_save_hw_probe
*****************************************************************************
*/
static void 
sdla_save_hw_probe (sdlahw_t* hw, int port)
d411 1
a411 2
	
	/*sprintf(tmp_hw_probe->hw_info,*/
d413 3
a415 7
		"%s : SLOT=%d : BUS=%d : IRQ=%d : CPU=%c : PORT=%s", 
		SDLA_ADPTR_DECODE(hw->hwcard->atype), 
		hw->hwcard->slot_no, 
		hw->hwcard->bus_no, 
		hw->irq, 
		SDLA_GET_CPU(hw->cpu_no), 
		"PRI");
d422 3
a424 7

/*
*****************************************************************************
**			sdla_hw_select
*****************************************************************************
*/
static sdlahw_t* sdla_aft_hw_select (sdlahw_card_t* hwcard, int cpu_no, int irq, struct pci_attach_args* pa)
d426 1
a426 1
	sdlahw_t*	hw=NULL;
d428 1
a428 1
	
d430 1
a430 1
	switch(hwcard->atype){
d435 7
a441 8
#if defined(DEBUG)
		log(LOG_INFO, "%s: %s T1/E1 card found (%s rev.%d), cpu(s) 1, bus #%d, slot #%d, irq #%d\n",
				san_drvname,
               	        	SDLA_ADPTR_DECODE(hwcard->atype), 
				AFT_CORE_ID_DECODE(hwcard->core_id),
				hwcard->core_rev,
               	        	hwcard->bus_no, hwcard->slot_no, irq);
#endif
a442 1

d447 7
a453 8
#if defined(DEBUG)
		log(LOG_INFO, "%s: %s T1/E1 card found (%s rev.%d), cpu(s) 2, bus #%d, slot #%d, irq #%d\n",
				san_drvname,
               	        	SDLA_ADPTR_DECODE(hwcard->atype), 
				AFT_CORE_ID_DECODE(hwcard->core_id),
				hwcard->core_rev,
				hwcard->bus_no, hwcard->slot_no, irq);
#endif
a454 1

d460 6
a465 8
#if defined(DEBUG)
		log(LOG_INFO, "%s: %s T3/E3 card found, cpu(s) 1, bus #%d, slot #%d, irq #%d\n",
				san_drvname,
               	        	SDLA_ADPTR_DECODE(hwcard->atype), 
				hwcard->bus_no, 
				hwcard->slot_no,
				irq);
#endif
a466 2

		
d468 4
a471 5
		log(LOG_INFO, 
			"%s: Unknown adapter %04X (bus #%d, slot #%d, irq #%d)!\n",
                       	san_drvname, hwcard->atype, hwcard->bus_no, hwcard->slot_no, irq);

		break;		
d474 1
a474 1
	return hw;
d478 2
a479 1
static int sdla_pci_probe(int atype, struct pci_attach_args* pa)
d499 1
a499 1
	if (pci_intr_map(pa,&ih)){
d501 1
a501 1
		return -EINVAL;
d504 1
a504 1
	if (intrstr != NULL){
d511 2
a512 2
	if (hwcard == NULL){
		return -EINVAL;
d519 1
a519 1
	switch(atype){
d529 4
a532 3
	if (hw == NULL) return -EINVAL;
	if (san_dev_attach(hw, hw->devname)){
		return -EINVAL;
d536 1
a536 1
	if (dual_cpu && cpu == SDLA_CPU_A){
d540 2
a541 2
	
	return 0;
d544 2
a545 1
int sdla_intr_establish(void *phw, int(*intr_func)(void*), void* intr_arg)
d552 3
a554 8
	if (pci_intr_establish(
			hwcard->pa.pa_pc, 
			hwcard->ih, 
			IPL_NET, 
			intr_func, 
			intr_arg,
			"san") == NULL){
		return -EINVAL;
d558 3
a560 2
 
int sdla_intr_disestablish(void *phw)
d565 2
a566 2
				hw->devname);
	return -EINVAL;
d569 2
a570 6
/*
*****************************************************************************
**			sdla_get_hw_devices
*****************************************************************************
*/
int sdla_get_hw_devices (void)
d572 1
a572 1
	return Sangoma_devices_no;
d575 2
a576 6
/*
*****************************************************************************
**			sdla_get_hw_adptr_cnt
*****************************************************************************
*/
void *sdla_get_hw_adptr_cnt (void)
d578 2
a579 2
	return &sdla_adapter_cnt;
}	
d581 1
a581 6
/*
*****************************************************************************
**			sdla_card_register
*****************************************************************************
*/
static sdlahw_card_t* 
d587 2
a588 2
	if (new_hwcard){
		return new_hwcard;
d591 2
a592 2
	if (!new_hwcard){
		return NULL;
d596 1
a596 1
	
d599 1
a599 1
	new_hwcard->bus_no  	= bus_no;
d601 1
a601 1
	if (LIST_EMPTY(&sdlahw_card_head)){
d605 2
a606 2
	LIST_FOREACH(last_hwcard, &sdlahw_card_head, next){
		if (!LIST_NEXT(last_hwcard, next)){
d610 4
a613 4
	if (last_hwcard){
		LIST_INSERT_AFTER(last_hwcard, new_hwcard, next); 
	}else{
		LIST_INSERT_HEAD(&sdlahw_card_head, new_hwcard, next); 
d615 1
a615 1
	return new_hwcard;
a617 5
/*
*****************************************************************************
**			sdla_card_unregister
*****************************************************************************
*/
d619 1
a619 1
static int 
d628 1
a628 1
		if (tmp_card->slot_no == slot_no && 
d648 1
a648 5
/*
*****************************************************************************
**			sdla_card_search
*****************************************************************************
*/
d653 3
a655 3
	
	LIST_FOREACH(tmp_card, &sdlahw_card_head, next){
		if (tmp_card->atype != atype){
d658 3
a660 3
		if (tmp_card->slot_no == slot_no && 
					tmp_card->bus_no == bus_no){
			return tmp_card;
d663 1
a663 1
	return NULL;
d666 2
a667 7
/*
*****************************************************************************
**			sdla_cpu_register
*****************************************************************************
*/
static sdlahw_t* 
sdla_hw_register(sdlahw_card_t* card, int cpu_no, int irq, void* dev)
d671 4
a674 3
	new_hw = sdla_hw_search(card->atype, card->slot_no, card->bus_no, cpu_no); 
	if (new_hw){
		return new_hw;
d678 1
a678 1
		return NULL;
d681 1
a681 1
	
d691 2
a692 2
	LIST_FOREACH(last_hw, &sdlahw_head, next){
		if (!LIST_NEXT(last_hw, next)){
d696 2
a697 2
	if (last_hw){
		LIST_INSERT_AFTER(last_hw, new_hw, next); 
d699 1
a699 1
		LIST_INSERT_HEAD(&sdlahw_head, new_hw, next); 
d701 1
a701 1
	return new_hw;
a703 5
/*
*****************************************************************************
**			sdla_hw_unregister
*****************************************************************************
*/
d705 1
a705 1
static int 
d709 1
a709 1
	int 		i;
d733 1
a733 1
	LIST_REMOVE(tmp_hw, next); 
d738 1
a738 5
/*
*****************************************************************************
**			sdla_cpu_search
*****************************************************************************
*/
d743 3
a745 3
	
	LIST_FOREACH(tmp_hw, &sdlahw_head, next){
		if (tmp_hw->hwcard == NULL){
d750 1
a750 1
		if (tmp_hw->hwcard->atype != atype){
d754 4
a757 4
		if (tmp_hw->hwcard->slot_no == slot_no && 
		    tmp_hw->hwcard->bus_no == bus_no && 
		    tmp_hw->cpu_no == cpu_no){
			return tmp_hw;
d760 1
a760 1
	return NULL;
a764 10
*****************************************************************************
*****************************************************************************
***	    S A N G O M A  H A R D W A R E  R E G I S T E R		*****
*****************************************************************************
*****************************************************************************
*/

/******* Kernel APIs ********************************************************/

/*============================================================================
d771 3
a773 2
/* ALEX int sdla_setup (sdlahw_t* hw, void* sfm, unsigned len)*/
int sdla_setup (void* phw)
d783 1
a783 1
	switch(hwcard->type){
d786 1
a786 1
		
d790 1
a790 1
		return -EINVAL;
d794 1
a794 1
	
d796 2
a797 2
	return err;
} 
d800 1
a800 1
/*============================================================================
d803 2
a804 1
int sdla_down (void* phw)
d816 1
a816 1
		if (hw->status & SDLA_MEM_MAPPED){
d822 1
a822 1
                break;
d825 1
a825 1
		return -EINVAL;
d827 1
a827 1
	return 0;
d830 1
a830 1
/*============================================================================
d833 2
a834 1
int sdla_read_int_stat (void* phw, u_int32_t* int_status)
d843 1
a843 1
	switch(card->type){
d847 1
a847 1
	return 0;
d851 1
a851 1
/*============================================================================
d854 2
a855 1
int sdla_cmd (void* phw, unsigned long offset, wan_mbox_t* mbox)
d857 5
a861 5
	sdlahw_t*	hw = (sdlahw_t*)phw;
	int		len = sizeof(wan_cmd_t);
	int		err = 0;
	u_int8_t		value;
	
d864 1
a864 1
		
d866 1
a866 1
	if (value != 0x00){ 
d869 1
a869 1
		return 0;
d873 1
a873 1
	
d875 1
a875 1
	if (!err){
d878 1
a878 1
		return WAN_CMD_TIMEOUT;
d881 3
a883 3
	if (mbox->wan_data_len){
		sdla_peek(hw, offset+offsetof(wan_mbox_t, wan_data), 
			  mbox->wan_data, mbox->wan_data_len);
d885 2
a886 2
	
	return mbox->wan_return_code;	
d889 1
a889 1
/*============================================================================
d895 2
a896 1
static int sdla_exec (sdlahw_t* hw, unsigned long offset)
d901 1
a901 1
	
d906 2
a907 2
	sdla_peek(hw, offset, (void*)&value, 1); 
	for (nloops = 1; value == 0x01; ++ nloops){ 
d909 6
a914 8
		if (ticks > tstop || nloops > MAX_NLOOPS){ 
			log(LOG_INFO, "%s: Timeout %lu ticks (max=%lu) loops %lu (max=%u)\n",
					hw->devname,
					(ticks-tstop+EXEC_TIMEOUT),
					(unsigned long)EXEC_TIMEOUT,
					nloops,
					MAX_NLOOPS);
			return 0;		/* time is up! */ 
d916 1
a916 1
		sdla_peek(hw, offset, (void*)&value, 1); 
d919 1
a919 1
	return nloops;
a920 1
	
d922 2
a923 1
/*============================================================================
d932 2
a933 1
int sdla_peek (void* phw, unsigned long addr, void* buf, unsigned len)
d944 1
a944 1
		return -EINVAL;
d946 1
a946 1
	switch(card->type){
d956 2
a957 2
        }
	return err;
d961 1
a961 1
/*============================================================================
d966 2
a967 2
static void 
sdla_peek_by_4 (sdlahw_t* hw, unsigned long offset, void* buf, unsigned int len)
d970 1
a970 1
	while (len && (offset & 0x03)){ 
d972 2
a973 2
		((u_int8_t *)buf) ++;
		len --;
d977 1
a977 1
	while (len >= 4){ 
d985 1
a985 1
	while (len){ 
d987 2
a988 2
		((u_int8_t *)buf) ++;
		len --;
d992 1
a992 1
/*============================================================================
d1001 2
a1002 1
int sdla_poke (void* phw, unsigned long addr, void* buf, unsigned len)
d1006 1
a1006 1
       	int err = 0;
d1012 2
a1013 2
	if (addr + len > hw->memory){	/* verify arguments */
		return -EINVAL;
d1015 2
a1016 2
   
	switch (card->type){
d1027 1
a1027 1
	return err;
d1031 1
a1031 1
/*============================================================================
d1036 2
a1037 1
static void sdla_poke_by_4 (sdlahw_t* hw, unsigned long offset, void* buf, unsigned int len)
d1040 1
a1040 1
	while (len && (offset & 0x03)){ 
d1047 1
a1047 1
	while (len >= 4){ 
d1055 1
a1055 1
	while (len){ 
d1062 2
a1063 1
int sdla_poke_byte (void* phw, unsigned long offset, u_int8_t value)
d1065 1
a1065 1
	sdlahw_t*	hw = (sdlahw_t*)phw;
d1070 1
a1070 1
	return 0;
d1073 2
a1074 1
int sdla_set_bit (void* phw, unsigned long offset, u_int8_t value)
d1076 2
a1077 2
	sdlahw_t*	hw = (sdlahw_t*)phw;
	u_int8_t		tmp;
d1085 1
a1085 1
	return 0;
d1088 2
a1089 2

int sdla_clear_bit (void* phw, unsigned long offset, u_int8_t value)
d1091 2
a1092 2
	sdlahw_t*	hw = (sdlahw_t*)phw;
	u_int8_t		tmp;
d1100 1
a1100 1
	return 0;
a1102 3

/****** Hardware-Specific Functions *****************************************/

a1103 8
*****************************************************************************
*****************************************************************************
***	    S A N G O M A  H A R D W A R E  D E T E C T I O N 		*****
*****************************************************************************
*****************************************************************************
*/

/*============================================================================
d1107 2
a1108 1
static int sdla_detect_aft(sdlahw_t* hw)
d1110 2
a1111 2
	sdlahw_card_t*	card;
	u_int16_t	ut_u16;
d1117 4
a1120 4
		   (hw->cpu_no == SDLA_CPU_A) ? PCI_IO_BASE_DWORD : 
			    	PCI_MEM_BASE0_DWORD, (u_int32_t*)&hw->mem_base_addr);
	if (!hw->mem_base_addr){
		if(hw->cpu_no == SDLA_CPU_B){
d1123 1
a1123 1
		}else{
d1127 1
a1127 1
		return -EINVAL;
d1129 1
a1129 1
#if defined(DEBUG)
d1132 1
a1132 1
#endif
d1134 9
a1142 10
        if(hw->irq == PCI_IRQ_NOT_ALLOCATED) {
                printf("%s: IRQ not allocated to AFT adapter\n",
			hw->devname);
                return -EINVAL;
        }

#if defined(DEBUG)
	log(LOG_INFO,  "%s: IRQ %d allocated to the AFT PCI card\n",
		hw->devname, hw->irq);
#endif
d1145 7
a1151 11
	
	/* map the physical PCI memory to virtual memory */
        bus_space_map(hw->hwcard->memt, 
			    hw->mem_base_addr, 
			    XILINX_PCI_MEM_SIZE, 
			    0, 
			    &hw->dpmbase);
	if (!hw->dpmbase){
		printf("%s: couldn't map memory\n",
			hw->devname);
                return -EINVAL;
d1156 1
a1156 2
	/* Enable master operation on PCI and enable
	 * bar0 memory */
d1162 2
a1163 1
	sdla_pci_write_config_dword(hw, XILINX_PCI_LATENCY_REG, XILINX_PCI_LATENCY); 
d1165 1
a1165 1
	return 0;
d1169 1
a1169 2
/* 
 * ============================================================================
d1172 2
a1173 1
static int sdla_detect (sdlahw_t* hw)
d1175 2
a1176 2
	sdlahw_card_t*	card = NULL;
	int		err = 0;
d1181 1
a1181 1
	switch (card->type){ 
d1186 1
a1186 1
	if (err){
d1189 1
a1189 1
	return err;
d1192 2
a1193 12



/*
*****************************************************************************
*****************************************************************************
***		H A R D W A R E    C O N F I G U R A T I O N		*****
*****************************************************************************
*****************************************************************************
*/

int sdla_is_te1(void* phw)
d1195 2
a1196 2
	sdlahw_card_t*	hwcard = NULL;
	sdlahw_t*	hw = (sdlahw_t*)phw;
d1202 1
a1202 1
	switch(hwcard->atype){
d1208 1
a1208 1
		return 1;
d1210 1
a1210 3
	return 0;


d1213 2
a1214 1
int sdla_check_mismatch(void* phw, unsigned char media)
d1216 2
a1217 2
	sdlahw_card_t*	hwcard = NULL;
	sdlahw_t*	hw = (sdlahw_t*)phw;
d1223 2
a1224 2
	if (media == WANOPT_MEDIA_T1 || 
	    media == WANOPT_MEDIA_E1){
d1227 5
a1231 5
		    hwcard->atype != S5148_ADPTR_1_CPU_T1E1){
			log(LOG_INFO, "%s: Error: Card type mismatch: User=T1/E1 Actual=%s\n",
				hw->devname,
				SDLA_ADPTR_DECODE(hwcard->atype));
			return -EIO;
d1234 7
a1240 7
		
	}else if (media == WANOPT_MEDIA_56K){
		if (hwcard->atype != S5145_ADPTR_1_CPU_56K){
			log(LOG_INFO, "%s: Error: Card type mismatch: User=56K Actual=%s\n",
				hw->devname,
				SDLA_ADPTR_DECODE(hwcard->atype));
			return -EIO;
d1246 5
a1250 5
		    hwcard->atype == S5148_ADPTR_1_CPU_T1E1){
			log(LOG_INFO, "%s: Error: Card type mismatch: User=S514(1/2/3) Actual=%s\n",
				hw->devname,
				SDLA_ADPTR_DECODE(hwcard->atype));
			return -EIO;
d1253 1
a1253 1
	return 0;
d1256 2
a1257 1
int sdla_getcfg(void* phw, int type, void* value)
d1260 1
a1260 1
	sdlahw_card_t*	hwcard;
d1266 1
a1266 1
	switch(type){
d1274 2
a1275 1
		*(u_int32_t*)value = ((unsigned long)hw->dpmbase + hw->dpmsize - 1);
d1308 1
a1308 1
	return 0;
d1312 2
a1313 1
int sdla_get_hwcard(void* phw, void** phwcard)
d1315 1
a1315 1
	sdlahw_t*	hw = (sdlahw_t*)phw;
d1321 1
a1321 1
	return 0;
d1325 2
a1326 1
int sdla_get_hwprobe(void* phw, void** str)
d1328 1
a1328 1
	sdlahw_t*	hw = (sdlahw_t*)phw;
d1333 1
a1333 1
	if (hw->hwprobe){
d1336 1
a1336 1
	return 0;
d1339 4
a1342 7
/*
*****************************************************************************
*****************************************************************************
***			M I S C E L L A N E O U S			*****
*****************************************************************************
*****************************************************************************
*/
d1344 1
a1344 5
int sdla_bus_write_1(void* phw, unsigned int offset, u_int8_t value) 
{
	sdlahw_t*	hw = (sdlahw_t*)phw;
	
	WAN_ASSERT(hw == NULL);	
d1346 2
a1347 1
	if (!(hw->status & SDLA_MEM_MAPPED)) return 0;
d1349 1
a1349 1
	return 0;
d1352 2
a1353 1
int sdla_bus_write_2(void* phw, unsigned int offset, u_int16_t value) 
d1355 1
a1355 1
	sdlahw_t*	hw = (sdlahw_t*)phw;
d1357 1
a1357 1
	WAN_ASSERT(hw == NULL);	
d1359 2
a1360 1
	if (!(hw->status & SDLA_MEM_MAPPED)) return 0;
d1362 1
a1362 1
	return 0;
d1365 2
a1366 1
int sdla_bus_write_4(void* phw, unsigned int offset, u_int32_t value) 
d1368 1
a1368 1
	sdlahw_t*	hw = (sdlahw_t*)phw;
d1370 1
a1370 1
	WAN_ASSERT(hw == NULL);	
d1372 2
a1373 1
	if (!(hw->status & SDLA_MEM_MAPPED)) return 0;
d1375 1
a1375 1
	return 0;
d1378 2
a1379 1
int sdla_bus_read_1(void* phw, unsigned int offset, u_int8_t* value)
d1381 1
a1381 1
	sdlahw_t*	hw = (sdlahw_t*)phw;
d1383 1
a1383 1
	WAN_ASSERT2(hw == NULL, 0);	
d1385 4
a1388 3
	if (!(hw->status & SDLA_MEM_MAPPED)) return 0;
	*value = bus_space_read_1(hw->hwcard->memt, hw->dpmbase, offset); 
	return 0;
d1391 2
a1392 1
int sdla_bus_read_2(void* phw, unsigned int offset, u_int16_t* value)
d1394 1
a1394 1
	sdlahw_t*	hw = (sdlahw_t*)phw;
d1396 1
a1396 1
	WAN_ASSERT2(hw == NULL, 0);	
d1398 4
a1401 3
	if (!(hw->status & SDLA_MEM_MAPPED)) return 0;
	*value = bus_space_read_2(hw->hwcard->memt, hw->dpmbase, offset); 
	return 0;
d1404 2
a1405 1
int sdla_bus_read_4(void* phw, unsigned int offset, u_int32_t* value)
d1407 1
a1407 1
	sdlahw_t*	hw = (sdlahw_t*)phw;
d1409 2
a1410 2
	WAN_ASSERT2(hw == NULL, 0);	
	WAN_ASSERT2(hw->dpmbase == 0, 0);	
d1412 4
a1415 3
	if (!(hw->status & SDLA_MEM_MAPPED)) return 0;
	*value = bus_space_read_4(hw->hwcard->memt, hw->dpmbase, offset); 
	return 0;
d1418 2
a1419 1
static int sdla_pci_read_config_dword(void* phw, int reg, u_int32_t* value)
d1421 2
a1422 2
	sdlahw_t*	hw = (sdlahw_t*)phw;
	sdlahw_card_t*	hwcard;
d1429 1
a1429 1
	return 0;
d1432 2
a1433 1
static int sdla_pci_read_config_word(void* phw, int reg, u_int16_t* value)
d1435 3
a1437 3
	sdlahw_t*	hw = (sdlahw_t*)phw;
	sdlahw_card_t*	hwcard;
	u_int32_t		tmp = 0x00;
d1445 1
a1445 1
	return 0;
d1448 2
a1449 1
static int sdla_pci_read_config_byte(void* phw, int reg, u_int8_t* value)
d1451 3
a1453 3
	sdlahw_t*	hw = (sdlahw_t*)phw;
	sdlahw_card_t*	hwcard;
	u_int32_t		tmp = 0x00;
d1461 1
a1461 1
	return 0;
d1464 2
a1465 1
static int sdla_pci_write_config_dword(void* phw, int reg, u_int32_t value)
d1467 2
a1468 2
	sdlahw_t*	hw = (sdlahw_t*)phw;
	sdlahw_card_t*	card;
d1474 2
a1475 2
	pci_conf_write(card->pa.pa_pc, card->pa.pa_tag, reg, value); 
	return 0;
d1478 2
a1479 1
static int sdla_pci_write_config_word(void* phw, int reg, u_int16_t value)
d1481 2
a1482 2
	sdlahw_t*	hw = (sdlahw_t*)phw;
	sdlahw_card_t*	card;
d1488 2
a1489 2
	pci_conf_write(card->pa.pa_pc, card->pa.pa_tag, reg, value); 
	return 0;
a1490 2


@


1.1
log
@Sangoma Network Device driver for AFT series card (initiali version).
ok mcbride@@
@
text
@d1 2
@

