head	1.20;
access;
symbols
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	UBC_SYNC_A:1.20
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.20
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	SMP:1.1.0.2
	SMP_BASE:1.1;
locks; strict;
comment	@ * @;


1.20
date	2002.04.15.06.23.07;	author deraadt;	state dead;
branches;
next	1.19;

1.19
date	2002.03.12.09.51.20;	author kjc;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.24.18.25.55;	author mjacob;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.10.06.22.42.53;	author mjacob;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.05.19.22.39;	author mjacob;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.27.06.34.51;	author kjc;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.24.20.27.03;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.12.15.40.31;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.13.00.27.57;	author mjacob;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.20.19.39.44;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.29.04.33.59;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.07.02.35.55;	author mjacob;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.06.01.02.14;	author mjacob;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.11.15.11.39;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.06.23.32.12;	author mjacob;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.06.06.19.08;	author mjacob;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.26.23.16.12;	author chris;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.22.18.15.20;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.11.14.51.50;	author jason;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2000.03.24.09.09.18;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.05.14.22.25.49;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.07.04.10.42.32;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2003.03.28.00.38.23;	author niklas;	state dead;
branches;
next	;

1.18.2.1
date	2002.06.11.03.42.26;	author art;	state dead;
branches;
next	;


desc
@@


1.20
log
@wx is totally gone now
@
text
@/* $OpenBSD: if_wx.c,v 1.19 2002/03/12 09:51:20 kjc Exp $ */
/*
 * Principal Author: Matthew Jacob <mjacob@@feral.com>
 * Copyright (c) 1999, 2001 by Traakan Software
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice unmodified, this list of conditions, and the following
 *    disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Additional Copyright (c) 2001 by Parag Patel
 * under same licence for MII PHY code.
 */

/*
 * Intel Gigabit Ethernet (82452/82453) Driver.
 * Inspired by fxp driver by David Greenman for FreeBSD, and by
 * Bill Paul's work in other FreeBSD network drivers.
 */

/*
 * Many bug fixes gratefully acknowledged from:
 *
 *	The folks at Sitara Networks
 */

/*
 * Options
 */

/*
 * Use only every other 16 byte receive descriptor, leaving the ones
 * in between empty. This card is most efficient at reading/writing
 * 32 byte cache lines, so avoid all the (not working for early rev
 * cards) MWI and/or READ/MODIFY/WRITE cycles updating one descriptor
 * would have you do.
 *
 * This isn't debugged yet.
 */
/* #define	PADDED_CELL	1 */

/*
 * Since the includes are a mess, they'll all be in if_wxvar.h
 */

#include <dev/pci/if_wxvar.h>

#ifdef __alpha__
#undef vtophys
#define	vtophys(va)	alpha_XXX_dmamap((vm_offset_t)(va))
#endif /* __alpha__ */

/*
 * Function Prototpes, yadda yadda...
 */

static int wx_intr(void *);
static void wx_handle_link_intr(wx_softc_t *);
static void wx_check_link(wx_softc_t *);
static void wx_handle_rxint(wx_softc_t *);
static void wx_gc(wx_softc_t *);
static void wx_start(struct ifnet *);
static int wx_ioctl(struct ifnet *, IOCTL_CMD_TYPE, caddr_t);
static int wx_ifmedia_upd(struct ifnet *);
static void wx_ifmedia_sts(struct ifnet *, struct ifmediareq *);
static int wx_init(void *);
static void wx_hw_stop(wx_softc_t *);
static void wx_set_addr(wx_softc_t *, int, u_int8_t *);
static int wx_hw_initialize(wx_softc_t *);
static void wx_stop(wx_softc_t *);
static void wx_txwatchdog(struct ifnet *);
static int wx_get_rbuf(wx_softc_t *, rxpkt_t *);
static void wx_rxdma_map(wx_softc_t *, rxpkt_t *, struct mbuf *);

static INLINE void wx_eeprom_raise_clk(wx_softc_t *, u_int32_t);
static INLINE void wx_eeprom_lower_clk(wx_softc_t *, u_int32_t);
static INLINE void wx_eeprom_sobits(wx_softc_t *, u_int16_t, u_int16_t);
static INLINE u_int16_t wx_eeprom_sibits(wx_softc_t *);
static INLINE void wx_eeprom_cleanup(wx_softc_t *);
static INLINE u_int16_t wx_read_eeprom_word(wx_softc_t *, int);
static void wx_read_eeprom(wx_softc_t *, u_int16_t *, int, int);

static int wx_attach_common(wx_softc_t *);
static void wx_watchdog(void *);

static INLINE void wx_mwi_whackon(wx_softc_t *);
static INLINE void wx_mwi_unwhack(wx_softc_t *);
static int wx_dring_setup(wx_softc_t *);
static void wx_dring_teardown(wx_softc_t *);

static int wx_attach_phy(wx_softc_t *);
static int wx_miibus_readreg(void *, int, int);
static int wx_miibus_writereg(void *, int, int, int);
static void wx_miibus_statchg(void *);

static u_int32_t wx_mii_shift_in(wx_softc_t *);
static void wx_mii_shift_out(wx_softc_t *, u_int32_t, u_int32_t);

#define	WX_DISABLE_INT(sc)	WRITE_CSR(sc, WXREG_IMCLR, WXDISABLE)
#define	WX_ENABLE_INT(sc)	WRITE_CSR(sc, WXREG_IMASK, sc->wx_ienable)

/*
 * Until we do a bit more work, we can get no bigger than MCLBYTES
 */
#if	0
#define	WX_MAXMTU	(WX_MAX_PKT_SIZE_JUMBO - sizeof (struct ether_header))
#else
#define	WX_MAXMTU	(MCLBYTES - sizeof (struct ether_header))
#endif

#define	DPRINTF(sc, x)	if (sc->wx_debug) printf x
#define	IPRINTF(sc, x)	if (sc->wx_verbose) printf x

static const char ldn[] = "%s: link down\n";
static const char lup[] = "%s: link up\n";
static const char sqe[] = "%s: receive sequence error\n";
static const char ane[] = "%s: /C/ ordered sets seen- enabling ANE\n";
static const char inane[] = "%s: no /C/ ordered sets seen- disabling ANE\n";


#define	MATCHARG	void *

static int	wx_match(struct device *, MATCHARG, void *);
static void	wx_attach(struct device *, struct device *, void *);
static void	wx_shutdown(void *);
static int	wx_ether_ioctl(struct ifnet *, IOCTL_CMD_TYPE, caddr_t);
static int	wx_mc_setup(wx_softc_t *);
#define		ether_ioctl	wx_ether_ioctl

/*
 * Life *should* be simple- we only read/write 32 bit values in registers.
 * Unfortunately, some platforms define bus_space functions in a fashion
 * such that they cannot be used as part of a for loop, for example.
 */

static INLINE u_int32_t _read_csr (wx_softc_t *, u_int32_t);
static INLINE void _write_csr(wx_softc_t *, u_int32_t, u_int32_t);

static INLINE u_int32_t
_read_csr(wx_softc_t *sc, u_int32_t reg)
{
	return bus_space_read_4(sc->w.st, sc->w.sh, reg);
}

static INLINE void
_write_csr(wx_softc_t *sc, u_int32_t reg, u_int32_t val)
{
	bus_space_write_4(sc->w.st, sc->w.sh, reg, val);
}

struct cfattach wx_ca = {
	sizeof (wx_softc_t), wx_match, wx_attach
};

struct cfdriver wx_cd = {
	0, "wx", DV_IFNET
};

/*
 * Check if a device is an 82452.
 */
static int
wx_match(struct device *parent, MATCHARG match, void *aux)
{
	struct pci_attach_args *pa = aux;
	if (PCI_VENDOR(pa->pa_id) != WX_VENDOR_INTEL) {
		return (0);
	}
	switch (PCI_PRODUCT(pa->pa_id)) {
	case WX_PRODUCT_82452:
	case WX_PRODUCT_LIVENGOOD:
	case WX_PRODUCT_82452_SC:
	case WX_PRODUCT_82543:
		break;
	default:
		return (0);
	}
	return (1);
}

static void
wx_attach(struct device *parent, struct device *self, void *aux)
{
	wx_softc_t *sc = (wx_softc_t *)self;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
	u_int32_t data;
	struct ifnet *ifp;

	sc->w.pci_pc = pa->pa_pc;
	sc->w.pci_tag = pa->pa_tag;

	/*
	 * Map control/status registers.
	 */
	if (pci_mapreg_map(pa, WX_MMBA, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->w.st, &sc->w.sh, NULL, NULL, 0)) {
		printf(": can't map registers\n");
		return;
	}

	sc->wx_idnrev = (PCI_PRODUCT(pa->pa_id) << 16) |
		(pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG) & 0xff);

        /*
         * Let the BIOS do it's job- but check for sanity.
         */
	data = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);
	switch ((data >> PCI_CACHELINE_SHIFT) & PCI_CACHELINE_MASK) {
	case 4:
	case 8:
	case 16:
	case 32:
		break;
	default:
		data &= ~(PCI_CACHELINE_MASK << PCI_CACHELINE_SHIFT);
		data |= (8 << PCI_CACHELINE_SHIFT);
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG, data);
		break;
	}

	if (wx_attach_common(sc)) {
		printf("\n");
		return;
	}

	if (!IS_LIVENGOOD_CU(sc)) {
		printf(": address %s", ether_sprintf(sc->wx_enaddr));
	}

	/*
	 * Allocate our interrupt.
	 */
	if (pci_intr_map(pa, &ih)) {
		printf(", couldn't map interrupt\n");
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->w.ih = pci_intr_establish(pc, ih, IPL_NET, wx_intr, sc,
	    self->dv_xname);
	if (sc->w.ih == NULL) {
		printf(", couldn't establish interrupt\n");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	if (!IS_LIVENGOOD_CU(sc)) {
		printf(", %s\n", intrstr);
	}
	ifp = &sc->wx_if;
	bcopy(sc->wx_name, ifp->if_xname, IFNAMSIZ);
	ifp->if_mtu = WX_MAXMTU;
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = wx_ioctl;
	ifp->if_start = wx_start;
	ifp->if_watchdog = wx_txwatchdog;
	IFQ_SET_READY(&ifp->if_snd);

	/*
	 * Attach the interface.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

	/*
	 * Add shutdown hook so that DMA is disabled prior to reboot. Not
	 * doing do could allow DMA to corrupt kernel memory during the
	 * reboot before the driver initializes.
	 */
	shutdownhook_establish(wx_shutdown, sc);
}

static int
wx_attach_phy(wx_softc_t *sc)
{

	mii_data_t *mii = WX_MII_FROM_SOFTC(sc);
	ifmedia_init(&mii->mii_media, 0, wx_ifmedia_upd, wx_ifmedia_sts);
        mii->mii_ifp = &sc->wx_if;
	mii->mii_readreg = (mii_readreg_t) wx_miibus_readreg;
	mii->mii_writereg = (mii_writereg_t) wx_miibus_writereg;
	mii->mii_statchg = (mii_statchg_t) wx_miibus_statchg;
	mii_phy_probe(&sc->w.dev, mii, 0xffffffff);
	if (LIST_FIRST(&mii->mii_phys) == NULL) {
		ifmedia_add(&mii->mii_media, IFM_ETHER|IFM_NONE, 0, NULL);
		ifmedia_set(&mii->mii_media, IFM_ETHER|IFM_NONE);
	} else {
		ifmedia_set(&mii->mii_media, IFM_ETHER|IFM_AUTO);
	}
	return 0;
}

/*
 * Device shutdown routine. Called at system shutdown after sync. The
 * main purpose of this routine is to shut off receiver DMA so that
 * kernel memory doesn't get clobbered during warmboot.
 */
static void
wx_shutdown(void *sc)
{
	wx_hw_stop((wx_softc_t *) sc);
}

static int
wx_ether_ioctl(struct ifnet *ifp, IOCTL_CMD_TYPE cmd, caddr_t data)
{
	struct ifaddr *ifa = (struct ifaddr *) data;
	int error = 0;
	wx_softc_t *sc = SOFTC_IFP(ifp);

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		error = wx_init(sc);
		if (error) {
			ifp->if_flags &= ~IFF_UP;
			break;
		}
		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			arp_ifinit(&sc->w.arpcom, ifa);
			break;
#endif
#ifdef NS
		case AF_NS:
		{
			 register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;
			 if (ns_nullhost(*ina))
				ina->x_host = *(union ns_host *)
				    LLADDR(ifp->if_sadl);
			 else
				bcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),
				    ifp->if_addrlen);
			 break;
		}
#endif
		default:
			break;
		}

		break;

	default:
		error = EINVAL;
		break;
	}

	return (0);
}

/*
 * Program multicast addresses.
 *
 * This function must be called at splimp, but it may sleep.
 */
static int
wx_mc_setup(wx_softc_t *sc)
{
	struct ifnet *ifp = &sc->wx_if;
	struct ether_multistep step;
	struct ether_multi *enm;

	/*
	 * XXX: drain TX queue
	 */
	if (sc->tactive) {
		return (EBUSY);
	}

	wx_stop(sc);

	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
		sc->all_mcasts = 1;
		return (wx_init(sc));
	}

	ETHER_FIRST_MULTI(step, &sc->w.arpcom, enm);
	while (enm != NULL) {
		if (memcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0)
			continue;
		if (sc->wx_nmca >= WX_RAL_TAB_SIZE-1) {
			sc->wx_nmca = 0;
			sc->all_mcasts = 1;
			break;
		}
		bcopy(enm->enm_addrlo, 
		    (void *) &sc->wx_mcaddr[sc->wx_nmca++][0], 6);
		ETHER_NEXT_MULTI(step, enm);
	}
	return (wx_init(sc));
}

static INLINE void
wx_mwi_whackon(wx_softc_t *sc)
{
	sc->wx_cmdw =
	    pci_conf_read(sc->w.pci_pc, sc->w.pci_tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(sc->w.pci_pc, sc->w.pci_tag,
	    PCI_COMMAND_STATUS_REG, sc->wx_cmdw & ~MWI);
}

static INLINE void
wx_mwi_unwhack(wx_softc_t *sc)
{
	if (sc->wx_cmdw & MWI) {
		pci_conf_write(sc->w.pci_pc, sc->w.pci_tag,
		    PCI_COMMAND_STATUS_REG, sc->wx_cmdw & ~MWI);
	}
}

static int
wx_dring_setup(wx_softc_t *sc)
{
	size_t len;

	len = sizeof (wxrd_t) * WX_MAX_RDESC;
	if (len > NBPG) {
		printf("%s: len (%lx) over a page for the receive ring\n",
		    sc->wx_name, len);
		return (-1);
	}
	len = NBPG;
	sc->rdescriptors = (wxrd_t *) WXMALLOC(len);
	if (sc->rdescriptors == NULL) {
		printf("%s: could not allocate rcv descriptors\n", sc->wx_name);
		return (-1);
	}

	if (((intptr_t)sc->rdescriptors) & 0xfff) {
		printf("%s: rcv descriptors not 4KB aligned\n", sc->wx_name);
		return (-1);
	}
        bzero(sc->rdescriptors, len);

	len = sizeof (wxtd_t) * WX_MAX_TDESC;
	if (len > NBPG) {
		printf("%s: len (%lx) over a page for the xmit ring\n",
		    sc->wx_name, len);
		return (-1);
	}
	len = NBPG;
	sc->tdescriptors = (wxtd_t *) WXMALLOC(len);
	if (sc->tdescriptors == NULL) {
		printf("%s: could not allocate xmt descriptors\n", sc->wx_name);
		return (-1);
	}
	if (((intptr_t)sc->tdescriptors) & 0xfff) {
		printf("%s: xmt descriptors not 4KB aligned\n", sc->wx_name);
		return (-1);
	}
        bzero(sc->tdescriptors, len);
	return (0);
}

static void
wx_dring_teardown(wx_softc_t *sc)
{
	if (sc->rdescriptors) {
		WXFREE(sc->rdescriptors);
		sc->rdescriptors = NULL;
	}
	if (sc->tdescriptors) {
		WXFREE(sc->tdescriptors);
		sc->tdescriptors = NULL;
	}
}


/*
 * Do generic parts of attach. Our registers have been mapped
 * and our interrupt registered.
 */
static int
wx_attach_common(wx_softc_t *sc)
{
	size_t len;
	u_int32_t tmp;
	int ll = 0;

	/*
	 * First, check for revision support.
	 */
	if (sc->wx_idnrev < WX_WISEMAN_2_0) {
		printf("%s: cannot support ID 0x%x, revision %d chips\n",
		    sc->wx_name, sc->wx_idnrev >> 16, sc->wx_idnrev & 0xffff);
		return (ENXIO);
	}

	/*
	 * Second, reset the chip.
	 */
	wx_hw_stop(sc);

	/*
	 * Third, validate our EEPROM.
	 */

	/* TBD */

	/*
	 * Fourth, read eeprom for our MAC address and other things.
	 */
	wx_read_eeprom(sc, (u_int16_t *)sc->wx_enaddr, WX_EEPROM_MAC_OFF, 3);

	/*
	 * Fifth, establish some adapter parameters.
	 */
	sc->wx_dcr = 0;

	if (IS_LIVENGOOD_CU(sc)) {

		sc->wx_mii = 1;

		/* settings to talk to PHY */
		sc->wx_dcr |= WXDCR_FRCSPD | WXDCR_FRCDPX | WXDCR_SLU;
		WRITE_CSR(sc, WXREG_DCR, sc->wx_dcr);

		/*
		 * Raise the PHY's reset line to make it operational.
		 */
		tmp = READ_CSR(sc, WXREG_EXCT);
		tmp |= WXPHY_RESET_DIR4;
		WRITE_CSR(sc, WXREG_EXCT, tmp);
		DELAY(20*1000);

		tmp = READ_CSR(sc, WXREG_EXCT);
		tmp &= ~WXPHY_RESET4;
		WRITE_CSR(sc, WXREG_EXCT, tmp);
		DELAY(20*1000);

		tmp = READ_CSR(sc, WXREG_EXCT);
		tmp |= WXPHY_RESET4;
		WRITE_CSR(sc, WXREG_EXCT, tmp);
		DELAY(20*1000);

		printf(": address %s\n", ether_sprintf(sc->wx_enaddr));
		if (wx_attach_phy(sc)) {
			goto fail;
		}
	} else {
		ifmedia_init(&sc->wx_media, IFM_IMASK,
		    wx_ifmedia_upd, wx_ifmedia_sts);

		ifmedia_add(&sc->wx_media, IFM_ETHER|IFM_1000_SX, 0, NULL);
		ifmedia_add(&sc->wx_media,
		    IFM_ETHER|IFM_1000_SX|IFM_FDX, 0, NULL);
		ifmedia_set(&sc->wx_media, IFM_ETHER|IFM_1000_SX|IFM_FDX);

		sc->wx_media.ifm_media = sc->wx_media.ifm_cur->ifm_media;
	}

	/*
	 * Sixth, establish a default device control register word.
	 */
	ll += 1;
	if (sc->wx_cfg1 & WX_EEPROM_CTLR1_FD)
		sc->wx_dcr |= WXDCR_FD;
	if (sc->wx_cfg1 & WX_EEPROM_CTLR1_ILOS)
		sc->wx_dcr |= WXDCR_ILOS;

	tmp = (sc->wx_cfg1 >> WX_EEPROM_CTLR1_SWDPIO_SHIFT) & WXDCR_SWDPIO_MASK;
	sc->wx_dcr |= (tmp << WXDCR_SWDPIO_SHIFT);

	if (sc->wx_no_ilos)
		sc->wx_dcr &= ~WXDCR_ILOS;
	if (sc->wx_ilos)
		sc->wx_dcr |= WXDCR_ILOS;
	if (sc->wx_no_flow == 0)
		sc->wx_dcr |= WXDCR_RFCE | WXDCR_TFCE;

	/*
	 * Seventh, allocate various sw structures...
	 */
	len = sizeof (rxpkt_t) * WX_MAX_RDESC;
	sc->rbase = (rxpkt_t *) WXMALLOC(len);
	if (sc->rbase == NULL) {
                goto fail;
	}
        bzero(sc->rbase, len);
	ll += 1;

	len = sizeof (txpkt_t) * WX_MAX_TDESC;
	sc->tbase = (txpkt_t *) WXMALLOC(len);
        if (sc->tbase == NULL) {
                goto fail;
	}
        bzero(sc->tbase, len);
	ll += 1;

	/*
	 * Eighth, allocate and dma map (platform dependent) descriptor rings.
	 * They have to be aligned on a 4KB boundary.
	 */
	if (wx_dring_setup(sc) == 0) {
		return (0);
	}

fail:
	printf("%s: failed to do common attach (%d)\n", sc->wx_name, ll);
	wx_dring_teardown(sc);
	if (sc->rbase) {
		WXFREE(sc->rbase);
		sc->rbase = NULL;
	}
	if (sc->tbase) {
		WXFREE(sc->tbase);
		sc->tbase = NULL;
	}
	return (ENOMEM);
}

/*
 * EEPROM functions.
 */

static INLINE void
wx_eeprom_raise_clk(wx_softc_t *sc, u_int32_t regval)
{
	WRITE_CSR(sc, WXREG_EECDR, regval | WXEECD_SK);
	DELAY(50);
}

static INLINE void
wx_eeprom_lower_clk(wx_softc_t *sc, u_int32_t regval)
{
	WRITE_CSR(sc, WXREG_EECDR, regval & ~WXEECD_SK);
	DELAY(50);
}

static INLINE void
wx_eeprom_sobits(wx_softc_t *sc, u_int16_t data, u_int16_t count)
{
	u_int32_t regval, mask;

	mask = 1 << (count - 1);
	regval = READ_CSR(sc, WXREG_EECDR) & ~(WXEECD_DI|WXEECD_DO);

	do {
		if (data & mask)
			regval |= WXEECD_DI;
		else
			regval &= ~WXEECD_DI;
		WRITE_CSR(sc, WXREG_EECDR, regval); DELAY(50);
		wx_eeprom_raise_clk(sc, regval);
		wx_eeprom_lower_clk(sc, regval);
		mask >>= 1;
	} while (mask != 0);
	WRITE_CSR(sc, WXREG_EECDR, regval & ~WXEECD_DI);
}

static INLINE u_int16_t
wx_eeprom_sibits(wx_softc_t *sc)
{
	unsigned int regval, i;
	u_int16_t data;

	data = 0;
	regval = READ_CSR(sc, WXREG_EECDR) & ~(WXEECD_DI|WXEECD_DO);
	for (i = 0; i != 16; i++) {
		data <<= 1;
		wx_eeprom_raise_clk(sc, regval);
		regval = READ_CSR(sc, WXREG_EECDR) & ~WXEECD_DI;
		if (regval & WXEECD_DO) {
			data |= 1;
		}
		wx_eeprom_lower_clk(sc, regval);
	}
	return (data);
}

static INLINE void
wx_eeprom_cleanup(wx_softc_t *sc)
{
	u_int32_t regval;
	regval = READ_CSR(sc, WXREG_EECDR) & ~(WXEECD_DI|WXEECD_CS);
	WRITE_CSR(sc, WXREG_EECDR, regval); DELAY(50);
	wx_eeprom_raise_clk(sc, regval);
	wx_eeprom_lower_clk(sc, regval);
}

static u_int16_t INLINE 
wx_read_eeprom_word(wx_softc_t *sc, int offset)
{
	u_int16_t       data;
	WRITE_CSR(sc, WXREG_EECDR, WXEECD_CS);
	wx_eeprom_sobits(sc, EEPROM_READ_OPCODE, 3);
	wx_eeprom_sobits(sc, offset, 6);
	data = wx_eeprom_sibits(sc);
	wx_eeprom_cleanup(sc);
	return (data);
}

static void
wx_read_eeprom(wx_softc_t *sc, u_int16_t *data, int offset, int words)
{
	int i;
	for (i = 0; i < words; i++) {
		*data++ = wx_read_eeprom_word(sc, offset++);
	}
	sc->wx_cfg1 = wx_read_eeprom_word(sc, WX_EEPROM_CTLR1_OFF);
}

/*
 * Start packet transmission on the interface.
 */

static void
wx_start(struct ifnet *ifp)
{
	wx_softc_t *sc = SOFTC_IFP(ifp);
	u_int16_t widx = WX_MAX_TDESC, cidx, nactv;

	WX_LOCK(sc);
	DPRINTF(sc, ("%s: wx_start\n", sc->wx_name));
	nactv = sc->tactive;
	while (nactv < WX_MAX_TDESC - 1) {
		int ndesc, plen;
		int gctried = 0;
		struct mbuf *m, *mb_head;

		IFQ_DEQUEUE(&ifp->if_snd, mb_head);
		if (mb_head == NULL) {
			break;
		}
		sc->wx_xmitwanted++;

		/*
		 * If we have a packet less than ethermin, pad it out.
		 */
		if (mb_head->m_pkthdr.len < WX_MIN_RPKT_SIZE) {
			if (mb_head->m_next == NULL) {
				mb_head->m_len = WX_MIN_RPKT_SIZE;
			} else {
				MGETHDR(m, M_DONTWAIT, MT_DATA);
				if (m == NULL) {
					m_freem(mb_head);
					break;
				}
				m_copydata(mb_head, 0, mb_head->m_pkthdr.len,
				    mtod(m, caddr_t));
				m->m_pkthdr.len = m->m_len = WX_MIN_RPKT_SIZE;
				bzero(mtod(m, char *) + mb_head->m_pkthdr.len,
				     WX_MIN_RPKT_SIZE - mb_head->m_pkthdr.len);
				sc->wx_xmitpullup++;
				m_freem(mb_head);
				mb_head = m;
			}
		}
	again:
		cidx = sc->tnxtfree;
		nactv = sc->tactive;


		/*
		 * Go through each of the mbufs in the chain and initialize
		 * the transmit buffer descriptors with the physical address
		 * and size of that mbuf. If we have a length less than our
		 * minimum transmit size, we bail (to do a pullup). If we run
		 * out of descriptors, we also bail and try and do a pullup.
		 */
		for (plen = ndesc = 0, m = mb_head; m != NULL; m = m->m_next) {
			vm_offset_t vptr;
			wxtd_t *td;

			/*
			 * If this mbuf has no data, skip it.
			 */
			if (m->m_len == 0) {
				continue;
			}

			/*
			 * This appears to be a bogus check the PRO1000T.
			 * I think they meant that the minimum packet size
			 * is in fact WX_MIN_XPKT_SIZE (all data loaded)
			 */
#if	0
			/*
			 * If this mbuf is too small for the chip's minimum,
			 * break out to cluster it.
			 */
			if (m->m_len < WX_MIN_XPKT_SIZE) {
				sc->wx_xmitrunt++;
				break;
			}
#endif

			/*
			 * Do we have a descriptor available for this mbuf?
			 */
			if (++nactv == WX_MAX_TDESC) {
				if (gctried++ == 0) {
					sc->wx_xmitgc++;
					wx_gc(sc);
					goto again;
				}
				break;
			}
			sc->tbase[cidx].dptr = m;
			td = &sc->tdescriptors[cidx];
			td->length = m->m_len;
			plen += m->m_len;

			vptr = mtod(m, vm_offset_t);
			td->address.highpart = 0;
			td->address.lowpart = vtophys(vptr);

			td->cso = 0;
			td->status = 0;
			td->special = 0;
			td->cmd = 0;
			td->css = 0;

			if (sc->wx_debug) {
				printf("%s: XMIT[%d] %p vptr %lx (length %d "
				    "DMA addr %x) idx %d\n", sc->wx_name,
				    ndesc, m, (long) vptr, td->length,
				    td->address.lowpart, cidx);
			}
			ndesc++;
			cidx = T_NXT_IDX(cidx);
		}

		/*
		 * If we get here and m is NULL, we can send
		 * the the packet chain described by mb_head.
		 */
		if (m == NULL) {
			/*
			 * Mark the last descriptor with EOP and tell the
			 * chip to insert a final checksum.
			 */
			wxtd_t *td = &sc->tdescriptors[T_PREV_IDX(cidx)];
			td->cmd = TXCMD_EOP|TXCMD_IFCS;
			/*
			 * Set up a delayed interrupt when this packet
			 * is sent and the descriptor written back.
			 * Additional packets completing will cause
			 * interrupt to be delayed further. Therefore,
			 * after the *last* packet is sent, after the delay
			 * period in TIDV, an interrupt will be generated
			 * which will cause us to garbage collect.
			 */
			td->cmd |= TXCMD_IDE|TXCMD_RPS;

			/*
			 * Don't xmit odd length packets.
			 * We're okay with bumping things
			 * up as long as our mbuf allocation
			 * is always larger than our MTU
			 * by a comfortable amount.
			 *
			 * Yes, it's a hole to run past the end
			 * of a packet.
			 */
			if (plen & 0x1) {
				sc->wx_oddpkt++;
				td->length++;
			}

			sc->tbase[sc->tnxtfree].sidx = sc->tnxtfree;
			sc->tbase[sc->tnxtfree].eidx = cidx;
			sc->tbase[sc->tnxtfree].next = NULL;
			if (sc->tbsyf) {
				sc->tbsyl->next = &sc->tbase[sc->tnxtfree];
			} else {
				sc->tbsyf = &sc->tbase[sc->tnxtfree];
			}
			sc->tbsyl = &sc->tbase[sc->tnxtfree];
			sc->tnxtfree = cidx;
			sc->tactive = nactv;
			ifp->if_timer = 10;
#if	NBPFILTER > 0
			if (ifp->if_bpf)
				bpf_mtap(WX_BPFTAP_ARG(ifp), mb_head);
#endif
			/* defer xmit until we've got them all */
			widx = cidx;
			continue;
		}

		/*
		 * Otherwise, we couldn't send this packet for some reason.
		 *
		 * If don't have a descriptor available, and this is a
		 * single mbuf packet, freeze output so that later we
		 * can restart when we have more room. Otherwise, we'll
		 * try and cluster the request. We've already tried to
		 * garbage collect completed descriptors.
		 */
		if (nactv == WX_MAX_TDESC && mb_head->m_next == NULL) {
			sc->wx_xmitputback++;
			ifp->if_flags |= IFF_OACTIVE;
#ifdef ALTQ
			/*
			 * XXX when altq is enabled, we can't put the
			 * packet back to the queue.
			 * just give up this packet for now.
			 */
			if (ALTQ_IS_ENABLED(&ifp->if_snd)) {
				m_freem(mb_head);
				break;
			}
#endif
			IF_PREPEND(&ifp->if_snd, mb_head);
			break;
		}

		/*
		 * Otherwise, it's either a fragment length somewhere in the
		 * chain that isn't at least WX_MIN_XPKT_SIZE in length or
		 * the number of fragments exceeds the number of descriptors
		 * available.
		 *
		 * We could try a variety of strategies here- if this is
		 * a length problem for single mbuf packet or a length problem
		 * for the last mbuf in a chain (we could just try and adjust
		 * it), but it's just simpler to try and cluster it.
		 */
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL) {
			m_freem(mb_head);
			break;
		}
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			m_freem(m);
			m_freem(mb_head);
			break;
		}
		m_copydata(mb_head, 0, mb_head->m_pkthdr.len, mtod(m, caddr_t));
		m->m_pkthdr.len = m->m_len = mb_head->m_pkthdr.len;
		m_freem(mb_head);
		mb_head = m;
		sc->wx_xmitcluster++;
		goto again;
	}

	if (widx < WX_MAX_TDESC) {
		if (IS_WISEMAN(sc)) {
			WRITE_CSR(sc, WXREG_TDT, widx);
		} else {
			WRITE_CSR(sc, WXREG_TDT_LIVENGOOD, widx);
		}
	}

	if (sc->tactive == WX_MAX_TDESC - 1) {
		sc->wx_xmitgc++;
		wx_gc(sc);
		if (sc->tactive >= WX_MAX_TDESC - 1) {
			sc->wx_xmitblocked++;
			ifp->if_flags |= IFF_OACTIVE;
		}
	}

	/* used SW LED to indicate transmission active */
	if (sc->tactive > 0 && sc->wx_mii) {
		WRITE_CSR(sc, WXREG_DCR,
		    READ_CSR(sc, WXREG_DCR) | (WXDCR_SWDPIO0|WXDCR_SWDPIN0));
	}
	WX_UNLOCK(sc);
}

/*
 * Process interface interrupts.
 */
static int
wx_intr(void *arg)
{
	wx_softc_t *sc = arg;
	int claimed = 0;

	WX_ILOCK(sc);
	/*
	 * Read interrupt cause register. Reading it clears bits.
	 */
	sc->wx_icr = READ_CSR(sc, WXREG_ICR);
	if (sc->wx_icr) {
		claimed++;
		WX_DISABLE_INT(sc);
		sc->wx_intr++;
		if (sc->wx_icr & (WXISR_LSC|WXISR_RXSEQ|WXISR_GPI_EN1)) {
			sc->wx_linkintr++;
			wx_handle_link_intr(sc);
		}
		wx_handle_rxint(sc);
		if (sc->wx_icr & WXISR_TXDW) {
			sc->wx_txqe++;
			wx_gc(sc);
		}
#if	0
		if (sc->wx_icr & WXISR_TXQE) {
			sc->wx_txqe++;
			wx_gc(sc);
		}
#endif
		if (sc->wx_if.if_snd.ifq_head != NULL) {
			wx_start(&sc->wx_if);
		}
		WX_ENABLE_INT(sc);
	}
	WX_IUNLK(sc);
	return (claimed);
}

static void
wx_handle_link_intr(wx_softc_t *sc)
{
	u_int32_t txcw, rxcw, dcr, dsr;

	sc->wx_linkintr++;

	dcr = READ_CSR(sc, WXREG_DCR);
	DPRINTF(sc, ("%s: handle_link_intr: icr=%#x dcr=%#x\n",
	    sc->wx_name, sc->wx_icr, dcr));
	if (sc->wx_mii) {
		mii_data_t *mii = WX_MII_FROM_SOFTC(sc);
		mii_pollstat(mii);
		if (mii->mii_media_status & IFM_ACTIVE) {
			if (IFM_SUBTYPE(mii->mii_media_active) == IFM_NONE) {
				IPRINTF(sc, (ldn, sc->wx_name));
				sc->linkup = 0;
			} else {
				IPRINTF(sc, (lup, sc->wx_name));
				sc->linkup = 1;
			}
			WRITE_CSR(sc, WXREG_DCR, sc->wx_dcr);
		} else if (sc->wx_icr & WXISR_RXSEQ) {
			DPRINTF(sc, (sqe, sc->wx_name));
		}
		return;
	}

	txcw = READ_CSR(sc, WXREG_XMIT_CFGW);
	rxcw = READ_CSR(sc, WXREG_RECV_CFGW);
	dsr = READ_CSR(sc, WXREG_DSR);

	/*
	 * If we have LOS or are now receiving Ordered Sets and are not
	 * doing auto-negotiation, restore autonegotiation.
	 */

	if (((dcr & WXDCR_SWDPIN1) || (rxcw & WXRXCW_C)) &&
	    ((txcw & WXTXCW_ANE) == 0)) {
		DPRINTF(sc, (ane, sc->wx_name));
		WRITE_CSR(sc, WXREG_XMIT_CFGW, WXTXCW_DEFAULT);
		sc->wx_dcr &= ~WXDCR_SLU;
		WRITE_CSR(sc, WXREG_DCR, sc->wx_dcr);
		sc->ane_failed = 0;
	}

	if (sc->wx_icr & WXISR_LSC) {
		if (READ_CSR(sc, WXREG_DSR) & WXDSR_LU) {
			IPRINTF(sc, (lup, sc->wx_name));
			sc->linkup = 1;
			sc->wx_dcr |= (WXDCR_SWDPIO0|WXDCR_SWDPIN0);
		} else {
			IPRINTF(sc, (ldn, sc->wx_name));
			sc->linkup = 0;
			sc->wx_dcr &= ~(WXDCR_SWDPIO0|WXDCR_SWDPIN0);
		}
		WRITE_CSR(sc, WXREG_DCR, sc->wx_dcr);
	} else {
		DPRINTF(sc, (sqe, sc->wx_name));
	}
}

static void
wx_check_link(wx_softc_t *sc)
{
	u_int32_t rxcw, dcr, dsr;

	if (sc->wx_mii) {
		mii_pollstat(WX_MII_FROM_SOFTC(sc));
		return;
	}

	rxcw = READ_CSR(sc, WXREG_RECV_CFGW);
	dcr = READ_CSR(sc, WXREG_DCR);
	dsr = READ_CSR(sc, WXREG_DSR);

	if ((dsr & WXDSR_LU) == 0 && (dcr & WXDCR_SWDPIN1) == 0 &&
	    (rxcw & WXRXCW_C) == 0) {
		if (sc->ane_failed == 0) {
			sc->ane_failed = 1;
			return;
		}
		DPRINTF(sc, (inane, sc->wx_name));
		WRITE_CSR(sc, WXREG_XMIT_CFGW, WXTXCW_DEFAULT & ~WXTXCW_ANE);
		if (sc->wx_idnrev < WX_WISEMAN_2_1)
			sc->wx_dcr &= ~WXDCR_TFCE;
		sc->wx_dcr |= WXDCR_SLU;
     		WRITE_CSR(sc, WXREG_DCR, sc->wx_dcr);
	} else if ((rxcw & WXRXCW_C) != 0 && (dcr & WXDCR_SLU) != 0) {
		DPRINTF(sc, (ane, sc->wx_name));
		WRITE_CSR(sc, WXREG_XMIT_CFGW, WXTXCW_DEFAULT);
		sc->wx_dcr &= ~WXDCR_SLU;
		WRITE_CSR(sc, WXREG_DCR, sc->wx_dcr);
	}
}

static void
wx_handle_rxint(wx_softc_t *sc)
{
	struct ether_header *eh;
	struct mbuf *m0, *mb, *pending[WX_MAX_RDESC];
	struct ifnet *ifp = &sc->wx_if;
	int npkts, ndesc, lidx, idx, tlen;

	DPRINTF(sc, ("%s: wx_handle_rxint\n", sc->wx_name));

	for (m0 = sc->rpending, tlen = ndesc = npkts = 0, idx = sc->rnxt,
	    lidx = R_PREV_IDX(idx); ndesc < WX_MAX_RDESC;
	    ndesc++, lidx = idx, idx = R_NXT_IDX(idx)) {
		wxrd_t *rd;
		rxpkt_t *rxpkt;
		int length, offset, lastframe;

		rd = &sc->rdescriptors[idx];
		/*
		 * XXX: DMA Flush descriptor
		 */
		if ((rd->status & RDSTAT_DD) == 0) {
			if (m0) {
				if (sc->rpending == NULL) {
					m0->m_pkthdr.len = tlen;
					sc->rpending = m0;
				} else {
					m_freem(m0);
				}
				m0 = NULL;
			}
			DPRINTF(sc, ("%s: WXRX: ndesc %d idx %d lidx %d\n",
			    sc->wx_name, ndesc, idx, lidx));
			break;
		}

		if (rd->errors != 0) {
			printf("%s: packet with errors (%x)\n",
			    sc->wx_name, rd->errors);
			rd->status = 0;
			ifp->if_ierrors++;
			if (m0) {
				m_freem(m0);
				m0 = NULL;
				if (sc->rpending) {
					m_freem(sc->rpending);
					sc->rpending = NULL;
				}
			}
			continue;
		}


		rxpkt = &sc->rbase[idx];
		mb = rxpkt->dptr;
		if (mb == NULL) {
			printf("%s: receive descriptor with no mbuf\n",
			    sc->wx_name);
			(void) wx_get_rbuf(sc, rxpkt);
			rd->status = 0;
			ifp->if_ierrors++;
			if (m0) {
				m_freem(m0);
				m0 = NULL;
				if (sc->rpending) {
					m_freem(sc->rpending);
					sc->rpending = NULL;
				}
			}
			continue;
		}

		/* XXX: Flush DMA for rxpkt */

		if (wx_get_rbuf(sc, rxpkt)) {
			sc->wx_rxnobuf++;
			wx_rxdma_map(sc, rxpkt, mb);
			ifp->if_ierrors++;
			rd->status = 0;
			if (m0) {
				m_freem(m0);
				m0 = NULL;
				if (sc->rpending) {
					m_freem(sc->rpending);
					sc->rpending = NULL;
				}
			}
			continue;
		}

		/*
		 * Save the completing packet's offset value and length
		 * and install the new one into the descriptor.
		 */
		lastframe = (rd->status & RDSTAT_EOP) != 0;
		length = rd->length;
		offset = rd->address.lowpart & 0xff;
		bzero (rd, sizeof (*rd));
		rd->address.lowpart = rxpkt->dma_addr + WX_RX_OFFSET_VALUE;

		mb->m_len = length;
		mb->m_data += offset;
		mb->m_next = NULL;
		if (m0 == NULL) {
			m0 = mb;
			tlen = length;
		} else if (m0 == sc->rpending) {
			/*
			 * Pick up where we left off before. If
			 * we have an offset (we're assuming the
			 * first frame has an offset), then we've
			 * lost sync somewhere along the line.
			 */
			if (offset) {
				printf("%s: lost sync with partial packet\n",
				    sc->wx_name);
				m_freem(sc->rpending);
				sc->rpending = NULL;
				m0 = mb;
				tlen = length;
			} else {
				sc->rpending = NULL;
				tlen = m0->m_pkthdr.len;
			}
		} else {
			tlen += length;
		}

		DPRINTF(sc, ("%s: RDESC[%d] len %d off %d lastframe %d\n",
		    sc->wx_name, idx, mb->m_len, offset, lastframe));
		if (m0 != mb)
			m_cat(m0, mb);
		if (lastframe == 0) {
			continue;
		}
		m0->m_pkthdr.rcvif = ifp;
		m0->m_pkthdr.len = tlen - WX_CRC_LENGTH;
		mb->m_len -= WX_CRC_LENGTH;

		eh = mtod(m0, struct ether_header *);
		/*
		 * No need to check for promiscous mode since 
		 * the decision to keep or drop the packet is
		 * handled by ether_input()
		 */
		pending[npkts++] = m0;
		m0 = NULL;
		tlen = 0;
	}

	if (ndesc) {
		if (IS_WISEMAN(sc)) {
			WRITE_CSR(sc, WXREG_RDT0, lidx);
		} else {
			WRITE_CSR(sc, WXREG_RDT0_LIVENGOOD, lidx);
		}
		sc->rnxt = idx;
	}

	if (npkts) {
		sc->wx_rxintr++;
	}

	for (idx = 0; idx < npkts; idx++) {
		mb = pending[idx];
#if	NBPFILTER > 0
                if (ifp->if_bpf) {
                        bpf_mtap(WX_BPFTAP_ARG(ifp), mb);
		}
#endif
		ifp->if_ipackets++;
		DPRINTF(sc, ("%s: RECV packet length %d\n",
		    sc->wx_name, mb->m_pkthdr.len));
		ether_input_mbuf(ifp, mb);
	}
}

static void
wx_gc(wx_softc_t *sc)
{
	struct ifnet *ifp = &sc->wx_if;
	txpkt_t *txpkt;
	u_int32_t tdh;

	WX_LOCK(sc);
	txpkt = sc->tbsyf;
	if (IS_WISEMAN(sc)) {
		tdh = READ_CSR(sc, WXREG_TDH);
	} else {
		tdh = READ_CSR(sc, WXREG_TDH_LIVENGOOD);
	}
	while (txpkt != NULL) {
		u_int32_t end = txpkt->eidx, cidx = tdh;

		/*
		 * Normalize start..end indices to 2 *
	 	 * WX_MAX_TDESC range to eliminate wrap.
		 */
		if (txpkt->eidx < txpkt->sidx) {
			end += WX_MAX_TDESC;
		}

		/*
		 * Normalize current chip index to 2 *
	 	 * WX_MAX_TDESC range to eliminate wrap.
		 */
		if (cidx < txpkt->sidx) {
			cidx += WX_MAX_TDESC;
		}

		/*
		 * If the current chip index is between low and
		 * high indices for this packet, it's not finished
		 * transmitting yet. Because transmits are done FIFO,
		 * this means we're done garbage collecting too.
		 */

		if (txpkt->sidx <= cidx && cidx < txpkt->eidx) {
			DPRINTF(sc, ("%s: TXGC %d..%d TDH %d\n", sc->wx_name,
			    txpkt->sidx, txpkt->eidx, tdh));
			break;
		}
		ifp->if_opackets++;

		if (txpkt->dptr) {
			(void) m_freem(txpkt->dptr);
		} else {
			printf("%s: null mbuf in gc\n", sc->wx_name);
		}

		for (cidx = txpkt->sidx; cidx != txpkt->eidx;
		    cidx = T_NXT_IDX(cidx)) {
			txpkt_t *tmp;
			wxtd_t *td;

			td = &sc->tdescriptors[cidx];
			if (td->status & TXSTS_EC) {
				IPRINTF(sc, ("%s: excess collisions\n",
				    sc->wx_name));
				ifp->if_collisions++;
				ifp->if_oerrors++;
			}
			if (td->status & TXSTS_LC) {
				IPRINTF(sc,
				    ("%s: lost carrier\n", sc->wx_name));
				ifp->if_oerrors++;
			}
			tmp = &sc->tbase[cidx];
			DPRINTF(sc, ("%s: TXGC[%d] %p %d..%d done nact %d "
			    "TDH %d\n", sc->wx_name, cidx, tmp->dptr,
			    txpkt->sidx, txpkt->eidx, sc->tactive, tdh));
			tmp->dptr = NULL;
			if (sc->tactive == 0) {
				printf("%s: nactive < 0?\n", sc->wx_name);
			} else {
				sc->tactive -= 1;
			}
			bzero(td, sizeof (*td));
		}
		sc->tbsyf = txpkt->next;
		txpkt = sc->tbsyf;
	}
	if (sc->tactive < WX_MAX_TDESC - 1) {
		ifp->if_timer = 0;
		ifp->if_flags &= ~IFF_OACTIVE;
	}

	/* used SW LED to indicate transmission not active */
	if (sc->tactive == 0 && sc->wx_mii) {
		WRITE_CSR(sc, WXREG_DCR,
		    READ_CSR(sc, WXREG_DCR) & ~(WXDCR_SWDPIO0|WXDCR_SWDPIN0));
	}
	WX_UNLOCK(sc);
}

static void
wx_watchdog(void *arg)
{
	wx_softc_t *sc = arg;

	WX_LOCK(sc);
	if (sc->wx_needreinit) {
		WX_UNLOCK(sc);
		if (wx_init(sc) == 0) {
			WX_LOCK(sc);
			sc->wx_needreinit = 0;
		} else {
			WX_LOCK(sc);
		}
	} else {
		wx_gc(sc);
		wx_check_link(sc);
	}
	WX_UNLOCK(sc);

	/*
	 * Schedule another timeout one second from now.
	 */
	TIMEOUT(sc, wx_watchdog, sc, hz);
}

/*
 * Stop and reinitialize the hardware
 */
static void
wx_hw_stop(wx_softc_t *sc)
{
	u_int32_t icr;
	DPRINTF(sc, ("%s: wx_hw_stop\n", sc->wx_name));
	WX_DISABLE_INT(sc);
	if (sc->wx_idnrev < WX_WISEMAN_2_1) {
		wx_mwi_whackon(sc);
	}
	WRITE_CSR(sc, WXREG_DCR, WXDCR_RST);
	DELAY(20 * 1000);
	icr = READ_CSR(sc, WXREG_ICR);
	if (sc->wx_idnrev < WX_WISEMAN_2_1) {
		wx_mwi_unwhack(sc);
	}
}

static void
wx_set_addr(wx_softc_t *sc, int idx, u_int8_t *mac)
{
	u_int32_t t0, t1;
	DPRINTF(sc, ("%s: wx_set_addr\n", sc->wx_name));
	t0 = (mac[0]) | (mac[1] << 8) | (mac[2] << 16) | (mac[3] << 24);
	t1 = (mac[4] << 0) | (mac[5] << 8);
	t1 |= WX_RAL_AV;
	WRITE_CSR(sc, WXREG_RAL_LO(idx), t0);
	WRITE_CSR(sc, WXREG_RAL_HI(idx), t1);
}

static int
wx_hw_initialize(wx_softc_t *sc)
{
	int i;

	DPRINTF(sc, ("%s: wx_hw_initialize\n", sc->wx_name));

	WRITE_CSR(sc, WXREG_VET, 0);
	for (i = 0; i < (WX_VLAN_TAB_SIZE << 2); i += 4) {
		WRITE_CSR(sc, (WXREG_VFTA + i), 0);
	}
	if (sc->wx_idnrev < WX_WISEMAN_2_1) {
		wx_mwi_whackon(sc);
		WRITE_CSR(sc, WXREG_RCTL, WXRCTL_RST);
		DELAY(5 * 1000);
	}
	/*
	 * Load the first receiver address with our MAC address,
	 * and load as many multicast addresses as can fit into
	 * the receive address array.
	 */
	wx_set_addr(sc, 0, sc->wx_enaddr);
	for (i = 1; i <= sc->wx_nmca; i++) {
		if (i >= WX_RAL_TAB_SIZE) {
			break;
		} else {
			wx_set_addr(sc, i, sc->wx_mcaddr[i-1]);
		}
	}

	while (i < WX_RAL_TAB_SIZE) {
		WRITE_CSR(sc, WXREG_RAL_LO(i), 0);
		WRITE_CSR(sc, WXREG_RAL_HI(i), 0);
		i++;
	}

	if (sc->wx_idnrev < WX_WISEMAN_2_1) {
		WRITE_CSR(sc, WXREG_RCTL, 0);
		DELAY(1 * 1000);
		wx_mwi_unwhack(sc);
	}

	/*
	 * Clear out the hashed multicast table array.
	 */
	for (i = 0; i < WX_MC_TAB_SIZE; i++) {
		WRITE_CSR(sc, WXREG_MTA + (sizeof (u_int32_t) * 4), 0);
	}

	if (IS_LIVENGOOD_CU(sc)) {
		/*
		 * has a PHY - raise its reset line to make it operational
		 */
		u_int32_t tmp = READ_CSR(sc, WXREG_EXCT);
		tmp |= WXPHY_RESET_DIR4;
		WRITE_CSR(sc, WXREG_EXCT, tmp);
		DELAY(20*1000);

		tmp = READ_CSR(sc, WXREG_EXCT);
		tmp &= ~WXPHY_RESET4;
		WRITE_CSR(sc, WXREG_EXCT, tmp);
		DELAY(20*1000);

		tmp = READ_CSR(sc, WXREG_EXCT);
		tmp |= WXPHY_RESET4;
		WRITE_CSR(sc, WXREG_EXCT, tmp);
		DELAY(20*1000);
	} else if (IS_LIVENGOOD(sc)) {
		u_int16_t tew;

		/*
		 * Handle link control
		 */
		WRITE_CSR(sc, WXREG_DCR, sc->wx_dcr | WXDCR_LRST);
		DELAY(50 * 1000);

		wx_read_eeprom(sc, &tew, WX_EEPROM_CTLR2_OFF, 1);
		tew = (tew & WX_EEPROM_CTLR2_SWDPIO) << WX_EEPROM_EXT_SHIFT;
		WRITE_CSR(sc, WXREG_EXCT, (u_int32_t)tew);
	}

	if (sc->wx_dcr & (WXDCR_RFCE|WXDCR_TFCE)) {
		WRITE_CSR(sc, WXREG_FCAL, FC_FRM_CONST_LO);
		WRITE_CSR(sc, WXREG_FCAH, FC_FRM_CONST_HI);
		WRITE_CSR(sc, WXREG_FCT, FC_TYP_CONST);
	} else {
		WRITE_CSR(sc, WXREG_FCAL, 0);
		WRITE_CSR(sc, WXREG_FCAH, 0);
		WRITE_CSR(sc, WXREG_FCT, 0);
	}
	WRITE_CSR(sc, WXREG_FLOW_XTIMER, WX_XTIMER_DFLT);

	if (IS_WISEMAN(sc)) {
		if (sc->wx_idnrev < WX_WISEMAN_2_1) {
			WRITE_CSR(sc, WXREG_FLOW_RCV_HI, 0);
			WRITE_CSR(sc, WXREG_FLOW_RCV_LO, 0);
			sc->wx_dcr &= ~(WXDCR_RFCE|WXDCR_TFCE);
		} else {
			WRITE_CSR(sc, WXREG_FLOW_RCV_HI, WX_RCV_FLOW_HI_DFLT);
			WRITE_CSR(sc, WXREG_FLOW_RCV_LO, WX_RCV_FLOW_LO_DFLT);
		}
	} else {
		WRITE_CSR(sc, WXREG_FLOW_RCV_HI_LIVENGOOD, WX_RCV_FLOW_HI_DFLT);
		WRITE_CSR(sc, WXREG_FLOW_RCV_LO_LIVENGOOD, WX_RCV_FLOW_LO_DFLT);
	}

	if (!IS_LIVENGOOD_CU(sc))
		WRITE_CSR(sc, WXREG_XMIT_CFGW, WXTXCW_DEFAULT);

	WRITE_CSR(sc, WXREG_DCR, sc->wx_dcr);
	DELAY(50 * 1000);

	if (!IS_LIVENGOOD_CU(sc)) {
		/*
		 * The pin stuff is all FM from the Linux driver.
		 */
		if ((READ_CSR(sc, WXREG_DCR) & WXDCR_SWDPIN1) == 0) {
			for (i = 0; i < (WX_LINK_UP_TIMEOUT/10); i++) {
				DELAY(10 * 1000);
				if (READ_CSR(sc, WXREG_DSR) & WXDSR_LU) {
					sc->linkup = 1;
					break;
				}
			}
			if (sc->linkup == 0) {
				sc->ane_failed = 1;
				wx_check_link(sc);
			}
			sc->ane_failed = 0;
		} else {
			printf("%s: SWDPIO1 did not clear- check for reversed "
				"or disconnected cable\n", sc->wx_name);
			/* but return okay anyway */
		}
	}

	sc->wx_ienable = WXIENABLE_DEFAULT;
	return (0);
}

/*
 * Stop the interface. Cancels the statistics updater and resets the interface.
 */
static void
wx_stop(wx_softc_t *sc)
{
	txpkt_t *txp;
	rxpkt_t *rxp;
	struct ifnet *ifp = &sc->wx_if;

	DPRINTF(sc, ("%s: wx_stop\n", sc->wx_name));
	/*
	 * Cancel stats updater.
	 */
	UNTIMEOUT(wx_watchdog, sc, sc);

	/*
	 * Reset the chip
	 */
	wx_hw_stop(sc);

	/*
	 * Release any xmit buffers.
	 */
	for (txp = sc->tbase; txp && txp < &sc->tbase[WX_MAX_TDESC]; txp++) {
		if (txp->dptr) {
			m_free(txp->dptr);
			txp->dptr = NULL;
		}
	}

	/*
	 * Free all the receive buffers.
	 */
	for (rxp = sc->rbase; rxp && rxp < &sc->rbase[WX_MAX_RDESC]; rxp++) {
		if (rxp->dptr) {
			m_free(rxp->dptr);
			rxp->dptr = NULL;
		}
	}

	if (sc->rpending) {
		m_freem(sc->rpending);
		sc->rpending = NULL;
	}

	/*
	 * And we're outta here...
	 */

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
	ifp->if_timer = 0;
}

/*
 * Transmit Watchdog
 */
static void
wx_txwatchdog(struct ifnet *ifp)
{
	wx_softc_t *sc = SOFTC_IFP(ifp);
	printf("%s: device timeout\n", sc->wx_name);
	ifp->if_oerrors++;
	if (wx_init(sc)) {
		printf("%s: could not re-init device\n", sc->wx_name);
		sc->wx_needreinit = 1;
	}
}

static int
wx_init(void *xsc)
{
	struct ifmedia *ifm;
	wx_softc_t *sc = xsc;
	struct ifnet *ifp = &sc->wx_if;
	rxpkt_t *rxpkt;
	wxrd_t *rd;
	size_t len;
	int i, bflags;

	DPRINTF(sc, ("%s: wx_init\n", sc->wx_name));
	WX_LOCK(sc);

	/*
	 * Cancel any pending I/O by resetting things.
	 * wx_stop will free any allocated mbufs.
	 */
	wx_stop(sc);

	/*
	 * Reset the hardware. All network addresses loaded here, but
	 * neither the receiver nor the transmitter are enabled.
	 */

	if (wx_hw_initialize(sc)) {
		DPRINTF(sc, ("%s: wx_hw_initialize failed\n", sc->wx_name));
		WX_UNLOCK(sc);
		return (EIO);
	}

	/*
	 * Set up the receive ring stuff.
	 */
	len = sizeof (wxrd_t) * WX_MAX_RDESC;
	bzero(sc->rdescriptors, len);
	for (rxpkt = sc->rbase, i = 0; rxpkt != NULL && i < WX_MAX_RDESC;
	    i += RXINCR, rxpkt++) {
		rd = &sc->rdescriptors[i];
		if (wx_get_rbuf(sc, rxpkt)) {
			break;
		}
		rd->address.lowpart = rxpkt->dma_addr + WX_RX_OFFSET_VALUE;
	}
	if (i != WX_MAX_RDESC) {
		printf("%s: could not set up rbufs\n", sc->wx_name);
		wx_stop(sc);
		WX_UNLOCK(sc);
		return (ENOMEM);
	}

	/*
	 * Set up transmit parameters and enable the transmitter.
	 */
	sc->tnxtfree = sc->tactive = 0;
	sc->tbsyf = sc->tbsyl = NULL;
	WRITE_CSR(sc, WXREG_TCTL, 0);
	DELAY(5 * 1000);
	if (IS_WISEMAN(sc)) {
		WRITE_CSR(sc, WXREG_TDBA_LO,
			vtophys((vm_offset_t)&sc->tdescriptors[0]));
		WRITE_CSR(sc, WXREG_TDBA_HI, 0);
		WRITE_CSR(sc, WXREG_TDLEN, WX_MAX_TDESC * sizeof (wxtd_t));
		WRITE_CSR(sc, WXREG_TDH, 0);
		WRITE_CSR(sc, WXREG_TDT, 0);
		WRITE_CSR(sc, WXREG_TQSA_HI, 0);
		WRITE_CSR(sc, WXREG_TQSA_LO, 0);
		WRITE_CSR(sc, WXREG_TIPG, WX_WISEMAN_TIPG_DFLT);
		WRITE_CSR(sc, WXREG_TIDV, 5000);
	} else {
		WRITE_CSR(sc, WXREG_TDBA_LO_LIVENGOOD,
			vtophys((vm_offset_t)&sc->tdescriptors[0]));
		WRITE_CSR(sc, WXREG_TDBA_HI_LIVENGOOD, 0);
		WRITE_CSR(sc, WXREG_TDLEN_LIVENGOOD,
			WX_MAX_TDESC * sizeof (wxtd_t));
		WRITE_CSR(sc, WXREG_TDH_LIVENGOOD, 0);
		WRITE_CSR(sc, WXREG_TDT_LIVENGOOD, 0);
		WRITE_CSR(sc, WXREG_TQSA_HI, 0);
		WRITE_CSR(sc, WXREG_TQSA_LO, 0);
		WRITE_CSR(sc, WXREG_TIPG, WX_LIVENGOOD_TIPG_DFLT);
		WRITE_CSR(sc, WXREG_TIDV_LIVENGOOD, 5000);
	}
	WRITE_CSR(sc, WXREG_TCTL, (WXTCTL_CT(WX_COLLISION_THRESHOLD) |
	    WXTCTL_COLD(WX_FDX_COLLISION_DX) | WXTCTL_EN));
	/*
	 * Set up receive parameters and enable the receiver.
	 */

	sc->rnxt = 0;
	WRITE_CSR(sc, WXREG_RCTL, 0);
	DELAY(5 * 1000);
	if (IS_WISEMAN(sc)) {
		WRITE_CSR(sc, WXREG_RDTR0, WXRDTR_FPD);
		WRITE_CSR(sc, WXREG_RDBA0_LO,
		    vtophys((vm_offset_t)&sc->rdescriptors[0]));
		WRITE_CSR(sc, WXREG_RDBA0_HI, 0);
		WRITE_CSR(sc, WXREG_RDLEN0, WX_MAX_RDESC * sizeof (wxrd_t));
		WRITE_CSR(sc, WXREG_RDH0, 0);
		WRITE_CSR(sc, WXREG_RDT0, (WX_MAX_RDESC - RXINCR));
	} else {
		/*
		 * The delay should yield ~10us receive interrupt delay 
		 */
		WRITE_CSR(sc, WXREG_RDTR0_LIVENGOOD, WXRDTR_FPD | 0x40);
		WRITE_CSR(sc, WXREG_RDBA0_LO_LIVENGOOD,
		    vtophys((vm_offset_t)&sc->rdescriptors[0]));
		WRITE_CSR(sc, WXREG_RDBA0_HI_LIVENGOOD, 0);
		WRITE_CSR(sc, WXREG_RDLEN0_LIVENGOOD,
		    WX_MAX_RDESC * sizeof (wxrd_t));
		WRITE_CSR(sc, WXREG_RDH0_LIVENGOOD, 0);
		WRITE_CSR(sc, WXREG_RDT0_LIVENGOOD, (WX_MAX_RDESC - RXINCR));
	}
	WRITE_CSR(sc, WXREG_RDTR1, 0);
	WRITE_CSR(sc, WXREG_RDBA1_LO, 0);
	WRITE_CSR(sc, WXREG_RDBA1_HI, 0);
	WRITE_CSR(sc, WXREG_RDLEN1, 0);
	WRITE_CSR(sc, WXREG_RDH1, 0);
	WRITE_CSR(sc, WXREG_RDT1, 0);

	if (ifp->if_mtu > ETHERMTU) {
		bflags = WXRCTL_EN | WXRCTL_LPE | WXRCTL_2KRBUF;
	} else {
		bflags = WXRCTL_EN | WXRCTL_2KRBUF;
	}

	WRITE_CSR(sc, WXREG_RCTL, bflags |
	    ((ifp->if_flags & IFF_BROADCAST) ? WXRCTL_BAM : 0) |
	    ((ifp->if_flags & IFF_PROMISC) ? WXRCTL_UPE : 0) |
	    ((sc->all_mcasts) ? WXRCTL_MPE : 0));

	/*
	 * Enable Interrupts
	 */
	WX_ENABLE_INT(sc);

	if (sc->wx_mii) {
		mii_mediachg(WX_MII_FROM_SOFTC(sc));
	} else {
		ifm = &sc->wx_media;
		i = ifm->ifm_media;
		ifm->ifm_media = ifm->ifm_cur->ifm_media;
		wx_ifmedia_upd(ifp);
		ifm->ifm_media = i;
	}

	/*
	 * Mark that we're up and running...
	 */
	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;


	/*
	 * Start stats updater.
	 */
	TIMEOUT(sc, wx_watchdog, sc, hz);

	WX_UNLOCK(sc);
	/*
	 * And we're outta here...
	 */
	return (0);
}

/*
 * Get a receive buffer for our use (and dma map the data area).
 * 
 * The Wiseman chip can have buffers be 256, 512, 1024 or 2048 bytes in size.
 * The LIVENGOOD chip can go higher (up to 16K), but what's the point as
 * we aren't doing non-MCLGET memory management.
 *
 * It wants them aligned on 256 byte boundaries, but can actually cope
 * with an offset in the first 255 bytes of the head of a receive frame.
 *
 * We'll allocate a MCLBYTE sized cluster but *not* adjust the data pointer
 * by any alignment value. Instead, we'll tell the chip to offset by any
 * alignment and we'll catch the alignment on the backend at interrupt time.
 */
static void
wx_rxdma_map(wx_softc_t *sc, rxpkt_t *rxpkt, struct mbuf *mb)
{
	rxpkt->dptr = mb;
	rxpkt->dma_addr = vtophys(mtod(mb, vm_offset_t));
}

static int
wx_get_rbuf(wx_softc_t *sc, rxpkt_t *rxpkt)
{
	struct mbuf *mb;
	MGETHDR(mb, M_DONTWAIT, MT_DATA);
	if (mb == NULL) {
		rxpkt->dptr = NULL;
		return (-1);
	}
	MCLGET(mb, M_DONTWAIT);
	if ((mb->m_flags & M_EXT) == 0) {
		m_freem(mb);
		rxpkt->dptr = NULL;
		return (-1);
	}
	wx_rxdma_map(sc, rxpkt, mb);
	return (0);
}

static int
wx_ioctl(struct ifnet *ifp, IOCTL_CMD_TYPE command, caddr_t data)
{
	wx_softc_t *sc = SOFTC_IFP(ifp);
	struct ifreq *ifr = (struct ifreq *) data;
	int error = 0;

	WX_LOCK(sc);
	switch (command) {
	case SIOCSIFADDR:
	case SIOCGIFADDR:
		error = ether_ioctl(ifp, command, data);
		break;
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > WX_MAXMTU || ifr->ifr_mtu < ETHERMIN) {
			error = EINVAL;
                } else if (ifp->if_mtu != ifr->ifr_mtu) {
			ifp->if_mtu = ifr->ifr_mtu;
			error = wx_init(sc);
                }
                break;
	case SIOCSIFFLAGS:
		sc->all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;

		/*
		 * If interface is marked up and not running, then start it.
		 * If it is marked down and running, stop it.
		 * If it's up then re-initialize it. This is so flags
		 * such as IFF_PROMISC are handled.
		 */
		if (ifp->if_flags & IFF_UP) {
			if ((ifp->if_flags & IFF_RUNNING) == 0) {
				error = wx_init(sc);
			}
		} else {
			if (ifp->if_flags & IFF_RUNNING) {
				wx_stop(sc);
			}
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		sc->all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;
		error = wx_mc_setup(sc);
		break;
	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		DPRINTF(sc, ("%s: ioctl SIOC[GS]IFMEDIA: command=%#lx\n",
		    sc->wx_name, command));
		if (sc->wx_mii) {
			mii_data_t *mii = WX_MII_FROM_SOFTC(sc);
			error = ifmedia_ioctl(ifp, ifr,
			    &mii->mii_media, command);
		} else {
			error = ifmedia_ioctl(ifp, ifr, &sc->wx_media, command);
		}

		break;
	default:
		error = EINVAL;
	}

	WX_UNLOCK(sc);
	return (error);
}

static int
wx_ifmedia_upd(struct ifnet *ifp)
{
	struct wx_softc *sc = SOFTC_IFP(ifp);
	struct ifmedia *ifm;

	DPRINTF(sc, ("%s: ifmedia_upd\n", sc->wx_name));

	if (sc->wx_mii) {
		mii_mediachg(WX_MII_FROM_SOFTC(sc));
		return 0;
	}

	ifm = &sc->wx_media;

	if (IFM_TYPE(ifm->ifm_media) != IFM_ETHER) {
		return (EINVAL);
	}

	return (0);
}

static void
wx_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	u_int32_t dsr;
	struct wx_softc *sc = SOFTC_IFP(ifp);

	DPRINTF(sc, ("%s: ifmedia_sts: ", sc->wx_name));

	if (sc->wx_mii) {
		mii_data_t *mii = WX_MII_FROM_SOFTC(sc);
		mii_pollstat(mii);
		ifmr->ifm_active = mii->mii_media_active;
		ifmr->ifm_status = mii->mii_media_status;
		DPRINTF(sc, ("active=%#x status=%#x\n",
		    ifmr->ifm_active, ifmr->ifm_status));
		return;
	}

	DPRINTF(sc, ("\n"));
	ifmr->ifm_status = IFM_AVALID;
	ifmr->ifm_active = IFM_ETHER;

	if (sc->linkup == 0)
		return;

	ifmr->ifm_status |= IFM_ACTIVE;
	dsr = READ_CSR(sc, WXREG_DSR);
	if (IS_LIVENGOOD(sc)) {
		if (dsr &  WXDSR_1000BT) {
			if (IS_LIVENGOOD_CU(sc)) {
				ifmr->ifm_status |= IFM_1000_TX;
			}
			else {
				ifmr->ifm_status |= IFM_1000_SX;
			}
		} else if (dsr & WXDSR_100BT) {
			ifmr->ifm_status |= IFM_100_FX;	/* ?? */
		} else {
			ifmr->ifm_status |= IFM_10_T;	/* ?? */
		}
	} else {
		ifmr->ifm_status |= IFM_1000_SX;
	}
	if (dsr & WXDSR_FD) {
		ifmr->ifm_active |= IFM_FDX;
	}
}


#define RAISE_CLOCK(sc, dcr)	\
		WRITE_CSR(sc, WXREG_DCR, (dcr) | WXPHY_MDC), DELAY(2)

#define LOWER_CLOCK(sc, dcr)	\
		WRITE_CSR(sc, WXREG_DCR, (dcr) & ~WXPHY_MDC), DELAY(2)

static u_int32_t
wx_mii_shift_in(wx_softc_t *sc)
{
	u_int32_t dcr, i;
	u_int32_t data = 0;

	dcr = READ_CSR(sc, WXREG_DCR);
	dcr &= ~(WXPHY_MDIO_DIR | WXPHY_MDIO);
	WRITE_CSR(sc, WXREG_DCR, dcr);
	RAISE_CLOCK(sc, dcr);
	LOWER_CLOCK(sc, dcr);

	for (i = 0; i < 16; i++) {
		data <<= 1;
		RAISE_CLOCK(sc, dcr);
		dcr = READ_CSR(sc, WXREG_DCR);

		if (dcr & WXPHY_MDIO)
			data |= 1;
		
		LOWER_CLOCK(sc, dcr);
	}

	RAISE_CLOCK(sc, dcr);
	LOWER_CLOCK(sc, dcr);
	return (data);
}

static void
wx_mii_shift_out(wx_softc_t *sc, u_int32_t data, u_int32_t count)
{
	u_int32_t dcr, mask;

	dcr = READ_CSR(sc, WXREG_DCR);
	dcr |= WXPHY_MDIO_DIR | WXPHY_MDC_DIR;

	for (mask = (1 << (count - 1)); mask; mask >>= 1) {
		if (data & mask)
			dcr |= WXPHY_MDIO;
		else
			dcr &= ~WXPHY_MDIO;

		WRITE_CSR(sc, WXREG_DCR, dcr);
		DELAY(2);
		RAISE_CLOCK(sc, dcr);
		LOWER_CLOCK(sc, dcr);
	}
}

static int
wx_miibus_readreg(void *arg, int phy, int reg)
{
	wx_softc_t *sc = WX_SOFTC_FROM_MII_ARG(arg);
	unsigned int data = 0;

	if (!IS_LIVENGOOD_CU(sc)) {
		return 0;
	}
	wx_mii_shift_out(sc, WXPHYC_PREAMBLE, WXPHYC_PREAMBLE_LEN);
	wx_mii_shift_out(sc, reg | (phy << 5) | (WXPHYC_READ << 10) |
	    (WXPHYC_SOF << 12), 14);
	data = wx_mii_shift_in(sc);
	return (data & WXMDIC_DATA_MASK);
}

static int
wx_miibus_writereg(void *arg, int phy, int reg, int data)
{
	wx_softc_t *sc = WX_SOFTC_FROM_MII_ARG(arg);
	if (!IS_LIVENGOOD_CU(sc)) {
		return 0;
	}
	wx_mii_shift_out(sc, WXPHYC_PREAMBLE, WXPHYC_PREAMBLE_LEN);
	wx_mii_shift_out(sc, (u_int32_t)data | (WXPHYC_TURNAROUND << 16) |
	    (reg << 18) | (phy << 23) | (WXPHYC_WRITE << 28) |
	    (WXPHYC_SOF << 30), 32);
	return (0);
}

static void
wx_miibus_statchg(void *arg)
{
	wx_softc_t *sc = WX_SOFTC_FROM_MII_ARG(arg);
	mii_data_t *mii = WX_MII_FROM_SOFTC(sc);
	u_int32_t dcr, tctl;

	if (mii == NULL)
		return;

	dcr = sc->wx_dcr;
	tctl = READ_CSR(sc, WXREG_TCTL);
	DPRINTF(sc, ("%s: statchg dcr=%#x tctl=%#x", sc->wx_name, dcr, tctl));

	dcr |= WXDCR_FRCSPD | WXDCR_FRCDPX | WXDCR_SLU;
	dcr &= ~(WXDCR_SPEED_MASK | WXDCR_ASDE /* | WXDCR_ILOS */);

	if (mii->mii_media_status & IFM_ACTIVE) {
		if (IFM_SUBTYPE(mii->mii_media_active) == IFM_NONE) {
			DPRINTF(sc, (" link-down\n"));
			sc->linkup = 0;
			return;
		}

		sc->linkup = 1;
	}

	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_TX) {
		DPRINTF(sc, (" 1000TX"));
		dcr |= WXDCR_1000BT;
	} else if (IFM_SUBTYPE(mii->mii_media_active) == IFM_100_TX) {
		DPRINTF(sc, (" 100TX"));
		dcr |= WXDCR_100BT;
	} else	/* assume IFM_10_TX */ {
		DPRINTF(sc, (" 10TX"));
		dcr |= WXDCR_10BT;
	}

	if (mii->mii_media_active & IFM_FDX) {
		DPRINTF(sc, ("-FD"));
		tctl = WXTCTL_CT(WX_COLLISION_THRESHOLD) |
		    WXTCTL_COLD(WX_FDX_COLLISION_DX) | WXTCTL_EN;
		dcr |= WXDCR_FD;
	} else {
		DPRINTF(sc, ("-HD"));
		tctl = WXTCTL_CT(WX_COLLISION_THRESHOLD) |
		    WXTCTL_COLD(WX_HDX_COLLISION_DX) | WXTCTL_EN;
		dcr &= ~WXDCR_FD;
	}

	/* FLAG0==rx-flow-control FLAG1==tx-flow-control */
	if (mii->mii_media_active & IFM_FLAG0) {
		dcr |= WXDCR_RFCE;
	} else {
		dcr &= ~WXDCR_RFCE;
	}

	if (mii->mii_media_active & IFM_FLAG1) {
		dcr |= WXDCR_TFCE;
	} else {
		dcr &= ~WXDCR_TFCE;
	}

	if (dcr & (WXDCR_RFCE|WXDCR_TFCE)) {
		WRITE_CSR(sc, WXREG_FCAL, FC_FRM_CONST_LO);
		WRITE_CSR(sc, WXREG_FCAH, FC_FRM_CONST_HI);
		WRITE_CSR(sc, WXREG_FCT, FC_TYP_CONST);
	} else {
		WRITE_CSR(sc, WXREG_FCAL, 0);
		WRITE_CSR(sc, WXREG_FCAH, 0);
		WRITE_CSR(sc, WXREG_FCT, 0);
	}

	DPRINTF(sc, (" dcr=%#x tctl=%#x\n", dcr, tctl));
	WRITE_CSR(sc, WXREG_TCTL, tctl);
	sc->wx_dcr = dcr;
	WRITE_CSR(sc, WXREG_DCR, dcr);
}
@


1.19
log
@sync with KAME
ALTQify more drivers.
ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: if_wx.c,v 1.18 2001/10/24 18:25:55 mjacob Exp $ */
@


1.18
log
@More cleanups from FreeBSD version- principally getting rid of bogus
pullup for small mbufs (which was unnecessary); setting txint delay;
@
text
@d1 1
a1 1
/* $OpenBSD: if_wx.c,v 1.17 2001/10/06 22:42:53 mjacob Exp $ */
d279 1
d744 1
a744 1
		IF_DEQUEUE(&ifp->if_snd, mb_head);
@


1.18.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: if_wx.c,v 1.18 2001/10/24 18:25:55 mjacob Exp $ */
@


1.17
log
@Completely strip away all non-OpenBSD code to clean things up. Fix the
setting of cacheline to something that the chip wants. Apply several
bug fixes from Sitara networks with respect to transmit descriptor
wraparound. Don't do tx descriptor garbage collection in the interrupt
service routine. Increase the number of rx descriptors to 256.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wx.c,v 1.16 2001/09/05 19:22:39 mjacob Exp $ */
d120 4
d125 3
a529 1
	sc->wx_txint_delay = 128;
d733 1
a733 1
	u_int16_t cidx, nactv;
d739 1
a739 1
		int ndesc;
d753 14
a766 2
			MGETHDR(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
d768 1
a768 1
				break;
a769 8
			m_copydata(mb_head, 0, mb_head->m_pkthdr.len,
			    mtod(m, caddr_t));
			m->m_pkthdr.len = m->m_len = WX_MIN_RPKT_SIZE;
			bzero(mtod(m, char *) + mb_head->m_pkthdr.len,
			     WX_MIN_RPKT_SIZE - mb_head->m_pkthdr.len);
			sc->wx_xmitpullup++;
			m_freem(mb_head);
			mb_head = m;
d783 1
a783 1
		for (ndesc = 0, m = mb_head; m != NULL; m = m->m_next) {
d795 7
a801 1
			 * If this packet is too small for the chip's minimum,
d804 1
a804 1
			if (m->m_len < WX_MIN_RPKT_SIZE) {
d808 1
d824 1
d857 25
d895 1
a895 6
			if (IS_WISEMAN(sc)) {
				WRITE_CSR(sc, WXREG_TDT, cidx);
			} else {
				WRITE_CSR(sc, WXREG_TDT_LIVENGOOD, cidx);
			}
#if	NBFILTER > 0
d899 2
d961 8
d970 6
a975 2
		sc->wx_xmitblocked++;
		ifp->if_flags |= IFF_OACTIVE;
d1005 1
d1009 11
a1019 1
		if (IFQ_IS_EMPTY(&sc->wx_if.if_snd) == 0) {
a1398 5
/*
 * Periodic timer to update packet in/out/collision statistics,
 * and, more importantly, garbage collect completed transmissions
 * and to handle link status changes.
 */
d1405 12
a1416 2
	wx_gc(sc);
	wx_check_link(sc);
d1422 1
a1422 1
	VTIMEOUT(sc, wx_watchdog, sc, hz);
d1662 1
a1662 1
		VTIMEOUT(sc, (void (*)(void *))wx_init, sc, hz);
d1734 1
a1734 1
		WRITE_CSR(sc, WXREG_TIDV, sc->wx_txint_delay);
d1746 1
a1746 1
		WRITE_CSR(sc, WXREG_TIDV_LIVENGOOD, sc->wx_txint_delay);
d1766 4
a1769 1
		WRITE_CSR(sc, WXREG_RDTR0_LIVENGOOD, WXRDTR_FPD);
d1901 3
a1903 1
			error = wx_init(sc);
@


1.16
log
@Pick up a bugfix from FreeBSD: In wx_hw_stop, a bogus additional write
to WXREG_IMASK enabled *all* interrupt causes while we were trying to
*disable* them all. Oops.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wx.c,v 1.15 2001/08/25 10:13:29 art Exp $ */
d3 1
a3 1
 * Principal Author: Matthew Jacob
d40 6
a58 4
/*
 * Enable JumboGrams. This seems to work.
 */
/* #define	WX_JUMBO	1 */
a63 1
#if	defined(__NetBSD__) || defined(__OpenBSD__)
a64 3
#elif	defined(__FreeBSD__)
#include <pci/if_wxvar.h>
#endif
d120 1
a120 6
#define	JUMBOMTU	(WX_MAX_PKT_SIZE_JUMBO - sizeof (struct ether_header))
#ifdef	WX_JUMBO
#define	WX_MAXMTU	JUMBOMTU
#else
#define	WX_MAXMTU	ETHERMTU
#endif
a131 2
#if defined(__NetBSD__) || defined(__OpenBSD__)
#if defined(__BROKEN_INDIRECT_CONFIG) || defined(__OpenBSD__)
a132 3
#else
#define	MATCHARG	struct cfdata *
#endif
a165 1
#ifdef __OpenBSD__
a168 1
#endif
a205 5
#if	defined(__NetBSD__)
	if (bootverbose)
		sc->wx_verbose = 1;
#endif

a213 3
#ifndef __OpenBSD__
	printf(": Intel GigaBit Ethernet\n");
#endif
d218 3
d222 12
a233 3
	data &= ~(PCI_CACHELINE_MASK << PCI_CACHELINE_SHIFT);
	data |= (WX_CACHELINE_SIZE << PCI_CACHELINE_SHIFT);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG, data);
a235 1
#ifdef __OpenBSD__
a236 1
#endif
a239 4
#ifndef __OpenBSD__
	printf("%s: Ethernet address %s\n",
	    sc->wx_name, ether_sprintf(sc->wx_enaddr));
#else
a242 1
#endif
a247 3
#ifndef __OpenBSD__
		printf("%s: couldn't map interrupt\n", sc->wx_name);
#else
a248 1
#endif
a251 1
#if defined(__OpenBSD__)
a253 3
#else
	sc->w.ih = pci_intr_establish(pc, ih, IPL_NET, wx_intr, sc);
#endif
a254 3
#ifndef __OpenBSD__
		printf("%s: couldn't establish interrupt", sc->wx_name);
#else
a255 1
#endif
a260 3
#ifndef __OpenBSD__
	printf("%s: interrupting at %s\n", sc->wx_name, intrstr);
#else
a263 2
#endif

a276 1
#ifdef __OpenBSD__
a277 2
#else
	ether_ifattach(ifp, sc->wx_enaddr);
a278 5
#if	NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB,
	    sizeof (struct ether_header));
#endif
#endif
d291 10
a300 11
	sc->wx_mii = &sc->w.mii_data;
	ifmedia_init(&sc->wx_mii->mii_media, 0, wx_ifmedia_upd, wx_ifmedia_sts);
        sc->wx_mii->mii_ifp = &sc->wx_if;
	sc->wx_mii->mii_readreg = (mii_readreg_t) wx_miibus_readreg;
	sc->wx_mii->mii_writereg = (mii_writereg_t) wx_miibus_writereg;
	sc->wx_mii->mii_statchg = (mii_statchg_t) wx_miibus_statchg;
	mii_phy_probe(&sc->w.dev, sc->wx_mii, 0xffffffff);
	if (LIST_FIRST(&sc->wx_mii->mii_phys) == NULL) {
		ifmedia_add(&sc->wx_mii->mii_media,
		    IFM_ETHER|IFM_NONE, 0, NULL);
		ifmedia_set(&sc->wx_mii->mii_media, IFM_ETHER|IFM_NONE);
d302 1
a302 1
		ifmedia_set(&sc->wx_mii->mii_media, IFM_ETHER|IFM_AUTO);
a335 1
#ifdef __OpenBSD__
a336 3
#else
			arp_ifinit(ifp, ifa);
#endif
d379 1
a379 1
	 * XXX: drain TX queue- use a tsleep/wakeup until done.
a391 1
#ifdef __OpenBSD__
a392 4
#else
	ETHER_FIRST_MULTI(step, &sc->w.ethercom, enm);
#endif

a482 338
#elif	defined(__FreeBSD__)
static int wx_mc_setup(wx_softc_t *);
/*
 * Program multicast addresses.
 *
 * This function must be called at splimp, but it may sleep.
 */
static int
wx_mc_setup(wx_softc_t *sc)
{
	struct ifnet *ifp = &sc->wx_if;
	struct ifmultiaddr *ifma;

	/*
	 * XXX: drain TX queue- use a tsleep/wakeup until done.
	 */
	if (sc->tactive) {
		return (EBUSY);
	}

	wx_stop(sc);

	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
		sc->all_mcasts = 1;
		return (wx_init(sc));
	}

	sc->wx_nmca = 0;
	TAILQ_FOREACH(ifma, &ifp->if_multiaddrs, ifma_link) {
		if (ifma->ifma_addr->sa_family != AF_LINK) {
			continue;
		}
		if (sc->wx_nmca >= WX_RAL_TAB_SIZE-1) {
			sc->wx_nmca = 0;
			sc->all_mcasts = 1;
			break;
		}
		bcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),
		    (void *) &sc->wx_mcaddr[sc->wx_nmca++][0], 6);
	}
	return (wx_init(sc));
}

/*
 * Return identification string if this is device is ours.
 */
static int
wx_probe(device_t dev)
{
	if (pci_get_vendor(dev) != WX_VENDOR_INTEL) {
		return (ENXIO);
	}
	switch (pci_get_device(dev)) {
	case WX_PRODUCT_82452:
		device_set_desc(dev, "Intel PRO/1000 Gigabit (WISEMAN)");
		break;
	case WX_PRODUCT_LIVENGOOD:
		device_set_desc(dev, "Intel PRO/1000 (LIVENGOOD)");
		break;
	case WX_PRODUCT_82452_SC:
		device_set_desc(dev, "Intel PRO/1000 F Gigabit Ethernet");
		break;
	case WX_PRODUCT_82543:
		device_set_desc(dev, "Intel PRO/1000 T Gigabit Ethernet");
		break;
	default:
		return (ENXIO);
	}
	return (0);
}

static int
wx_attach(device_t dev)
{
	int error = 0;
	wx_softc_t *sc = device_get_softc(dev);
	struct ifnet *ifp;
	u_int32_t val;
	int rid;

	bzero(sc, sizeof (wx_softc_t));

	callout_handle_init(&sc->w.sch);
	sc->w.dev = dev;

	if (bootverbose)
		sc->wx_verbose = 1;

	if (getenv_int ("wx_debug", &rid)) {
		if (rid & (1 << device_get_unit(dev))) {
			sc->wx_debug = 1;
		}
	}

	if (getenv_int("wx_no_ilos", &rid)) {
		if (rid & (1 << device_get_unit(dev))) {
			sc->wx_no_ilos = 1;
		}
	}

	if (getenv_int("wx_ilos", &rid)) {
		if (rid & (1 << device_get_unit(dev))) {
			sc->wx_ilos = 1;
		}
	}

	if (getenv_int("wx_no_flow", &rid)) {
		if (rid & (1 << device_get_unit(dev))) {
			sc->wx_no_flow = 1;
		}
	}

#ifdef	SMPNG
	mtx_init(&sc->wx_mtx, device_get_nameunit(dev), MTX_DEF | MTX_RECURSE);
#endif

	WX_LOCK(sc);
	/*
 	 * get revision && id...
	 */
	sc->wx_idnrev = (pci_get_device(dev) << 16) | (pci_get_revid(dev));

	/*
	 * Enable bus mastering, make sure that the cache line size is right.
	 */
	val = pci_read_config(dev, PCIR_COMMAND, 2);
	val |= (PCIM_CMD_MEMEN|PCIM_CMD_BUSMASTEREN);
	pci_write_config(dev, PCIR_COMMAND, val, 2);

	val = pci_read_config(dev, PCIR_CACHELNSZ, 1);
	if (val != 0x10) {
		pci_write_config(dev, PCIR_CACHELNSZ, 0x10, 1);
	}


	/*
	 * Map control/status registers.
	 */
	rid = WX_MMBA;
	sc->w.mem = bus_alloc_resource(dev, SYS_RES_MEMORY,
	    &rid, 0, ~0, 1, RF_ACTIVE);
	if (!sc->w.mem) {
		device_printf(dev, "could not map memory\n");
		error = ENXIO;
		goto out;
        }
	sc->w.st = rman_get_bustag(sc->w.mem);
	sc->w.sh = rman_get_bushandle(sc->w.mem);

	rid = 0;
	sc->w.irq = bus_alloc_resource(dev, SYS_RES_IRQ,
	    &rid, 0, ~0, 1, RF_SHAREABLE | RF_ACTIVE);
	if (sc->w.irq == NULL) {
		device_printf(dev, "could not map interrupt\n");
		error = ENXIO;
		goto out;
	}
	error = bus_setup_intr(dev, sc->w.irq, INTR_TYPE_NET,
	    (void (*)(void *))wx_intr, sc, &sc->w.ih);
	if (error) {
		device_printf(dev, "could not setup irq\n");
		goto out;
	}
	if (wx_attach_common(sc)) {
		bus_teardown_intr(dev, sc->w.irq, sc->w.ih);
		bus_release_resource(dev, SYS_RES_IRQ, 0, sc->w.irq);
		bus_release_resource(dev, SYS_RES_MEMORY, WX_MMBA, sc->w.mem);
		error = ENXIO;
		goto out;
	}
	device_printf(dev, "Ethernet address %02x:%02x:%02x:%02x:%02x:%02x\n",
	    sc->w.arpcom.ac_enaddr[0], sc->w.arpcom.ac_enaddr[1],
	    sc->w.arpcom.ac_enaddr[2], sc->w.arpcom.ac_enaddr[3],
	    sc->w.arpcom.ac_enaddr[4], sc->w.arpcom.ac_enaddr[5]);
	(void) snprintf(sc->wx_name, sizeof (sc->wx_name) - 1, "wx%d",
	    device_get_unit(dev));

	ifp = &sc->w.arpcom.ac_if;
	ifp->if_unit = device_get_unit(dev);
	ifp->if_name = "wx";
	ifp->if_mtu = WX_MAXMTU;
	ifp->if_output = ether_output;
	ifp->if_baudrate = 1000000000;
	ifp->if_init = (void (*)(void *))wx_init;
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = wx_ioctl;
	ifp->if_start = wx_start;
	ifp->if_watchdog = wx_txwatchdog;
	IFQ_SET_MAXLEN(&ifp->if_snd, WX_MAX_TDESC - 1);
	IFQ_SET_READY(&ifp->if_snd);
	ether_ifattach(ifp, ETHER_BPF_SUPPORTED);
out:
	WX_UNLOCK(sc);
	return (error);
}

static int
wx_attach_phy(wx_softc_t *sc)
{
	if (mii_phy_probe(sc->w.dev, &sc->w.miibus, wx_ifmedia_upd,
	    wx_ifmedia_sts)) {
		printf("%s: no PHY probed!\n", sc->wx_name);
		return (-1);
	}
	sc->wx_mii = device_get_softc(sc->w.miibus);
	return 0;
}

static int
wx_detach(device_t dev)
{
	wx_softc_t *sc = device_get_softc(dev);

	WX_LOCK(sc);
	ether_ifdetach(&sc->w.arpcom.ac_if, ETHER_BPF_SUPPORTED);
	wx_stop(sc);

	bus_generic_detach(dev);
	device_delete_child(dev, sc->w.miibus);

	bus_teardown_intr(dev, sc->w.irq, sc->w.ih);
	bus_release_resource(dev, SYS_RES_IRQ, 0, sc->w.irq);
	bus_release_resource(dev, SYS_RES_MEMORY, WX_MMBA, sc->w.mem);
	WX_UNLOCK(sc);
	return (0);
}

static int
wx_shutdown(device_t dev)
{
	wx_hw_stop((wx_softc_t *) device_get_softc(dev));
	return (0);
}

static INLINE void
wx_mwi_whackon(wx_softc_t *sc)
{
	sc->wx_cmdw = pci_read_config(sc->w.dev, PCIR_COMMAND, 2);
	pci_write_config(sc->w.dev, PCIR_COMMAND, sc->wx_cmdw & ~MWI, 2);
}

static INLINE void
wx_mwi_unwhack(wx_softc_t *sc)
{
	if (sc->wx_cmdw & MWI) {
		pci_write_config(sc->w.dev, PCIR_COMMAND, sc->wx_cmdw, 2);
	}
}

static int
wx_dring_setup(wx_softc_t *sc)
{
	size_t len;

	len = sizeof (wxrd_t) * WX_MAX_RDESC;
	sc->rdescriptors = (wxrd_t *)
	    contigmalloc(len, M_DEVBUF, M_NOWAIT, 0, ~0, 4096, 0);
	if (sc->rdescriptors == NULL) {
		printf("%s: could not allocate rcv descriptors\n", sc->wx_name);
		return (-1);
	}
	if (((intptr_t)sc->rdescriptors) & 0xfff) {
		contigfree(sc->rdescriptors, len, M_DEVBUF);
		sc->rdescriptors = NULL;
		printf("%s: rcv descriptors not 4KB aligned\n", sc->wx_name);
		return (-1);
	}
        bzero(sc->rdescriptors, len);

	len = sizeof (wxtd_t) * WX_MAX_TDESC;
	sc->tdescriptors = (wxtd_t *)
	    contigmalloc(len, M_DEVBUF, M_NOWAIT, 0, ~0, 4096, 0);
	if (sc->tdescriptors == NULL) {
		contigfree(sc->rdescriptors,
		    sizeof (wxrd_t) * WX_MAX_RDESC, M_DEVBUF);
		sc->rdescriptors = NULL;
		printf("%s: could not allocate xmt descriptors\n", sc->wx_name);
		return (-1);
	}
	if (((intptr_t)sc->tdescriptors) & 0xfff) {
		contigfree(sc->rdescriptors,
		    sizeof (wxrd_t) * WX_MAX_RDESC, M_DEVBUF);
		sc->rdescriptors = NULL;
		printf("%s: xmt descriptors not 4KB aligned\n", sc->wx_name);
		return (-1);
	}
        bzero(sc->tdescriptors, len);
	return (0);
}

static void
wx_dring_teardown(wx_softc_t *sc)
{
	if (sc->rdescriptors) {
		contigfree(sc->rdescriptors,
		    sizeof (wxrd_t) * WX_MAX_RDESC, M_DEVBUF);
		sc->rdescriptors = NULL;
	}
	if (sc->tdescriptors) {
		contigfree(sc->tdescriptors,
		    sizeof (wxtd_t) * WX_MAX_TDESC, M_DEVBUF);
		sc->tdescriptors = NULL;
	}
}

static void
wx_miibus_mediainit(void *arg)
{
}

static device_method_t wx_methods[] = {
	/* Device interface */
	DEVMETHOD(device_probe,		wx_probe),
	DEVMETHOD(device_attach,	wx_attach),
	DEVMETHOD(device_detach,	wx_detach),
	DEVMETHOD(device_shutdown,	wx_shutdown),

	/* bus interface */
	DEVMETHOD(bus_print_child,	bus_generic_print_child),
	DEVMETHOD(bus_driver_added,	bus_generic_driver_added),

	/* MII interface */
	DEVMETHOD(miibus_readreg,	wx_miibus_readreg),
	DEVMETHOD(miibus_writereg,	wx_miibus_writereg),
	DEVMETHOD(miibus_statchg,	wx_miibus_statchg),
	DEVMETHOD(miibus_mediainit,	wx_miibus_mediainit),

	{ 0, 0 }
};

static driver_t wx_driver = {
	"wx", wx_methods, sizeof(wx_softc_t),
};
static devclass_t wx_devclass;
DRIVER_MODULE(if_wx, pci, wx_driver, wx_devclass, 0, 0);
DRIVER_MODULE(miibus, wx, miibus_driver, miibus_devclass, 0, 0);
#endif
d528 2
a551 1
#ifdef __OpenBSD__
a552 1
#endif
d560 1
a560 2
		ifmedia_add(&sc->wx_media,
		    IFM_ETHER|IFM_1000_SX, 0, NULL);
d732 1
a732 1
	while (nactv < WX_MAX_TDESC) {
d737 1
a737 1
		IFQ_DEQUEUE(&ifp->if_snd, mb_head);
d786 1
a786 1
			 * break out to to cluster it.
d921 1
a921 1
	if (sc->tactive == WX_MAX_TDESC) {
a955 3
		if (sc->tactive) {
			wx_gc(sc);
		}
d976 4
a979 4
		mii_pollstat(sc->wx_mii);
		if (sc->wx_mii->mii_media_status & IFM_ACTIVE) {
			if (IFM_SUBTYPE(sc->wx_mii->mii_media_active) ==
			    IFM_NONE) {
d1033 1
a1033 1
		mii_pollstat(sc->wx_mii);
d1079 3
a1233 5
#if defined(__FreeBSD__)
		eh = mtod(mb, struct ether_header *);
		m_adj(mb, sizeof (struct ether_header));
		ether_input(ifp, eh, mb);
#elif defined(__OpenBSD__)
a1234 3
#else
                (*ifp->if_input)(ifp, mb);
#endif
d1323 1
a1323 1
	if (sc->tactive < WX_MAX_TDESC) {
a1729 6
	/*
	 * Mark that we're up and running...
	 */
	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;

d1731 1
a1731 1
		mii_mediachg(sc->wx_mii);
d1740 6
a1745 1
	WX_UNLOCK(sc);
d1752 1
d1762 4
a1765 1
 * This chip can have buffers be 256, 512, 1024 or 2048 bytes in size.
a1808 1
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
a1809 1
#endif
a1811 2

#ifdef	SIOCSIFMTU
a1819 2
#endif

a1837 1
#ifdef	SIOCADDMULTI
a1839 12
#if defined(__NetBSD__)
	{
		int all_mc_change = (sc->all_mcasts ==
		    ((ifp->if_flags & IFF_ALLMULTI) ? 1 : 0));
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->w.ethercom) :
		    ether_delmulti(ifr, &sc->w.ethercom);
		if (error != ENETRESET && all_mc_change == 0) {
			break;
		}
	}
#endif
a1842 2
#endif
#ifdef	SIOCGIFMEDIA
d1848 1
d1850 1
a1850 1
			    &sc->wx_mii->mii_media, command);
a1855 1
#endif
d1873 1
a1873 1
		mii_mediachg(sc->wx_mii);
d1895 4
a1898 3
		mii_pollstat(sc->wx_mii);
		ifmr->ifm_active = sc->wx_mii->mii_media_active;
		ifmr->ifm_status = sc->wx_mii->mii_media_status;
d2024 1
a2024 1
	mii_data_t *mii = sc->wx_mii;
@


1.15
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wx.c,v 1.14 2001/06/27 06:34:51 kjc Exp $ */
d1764 1
a1769 1
	WRITE_CSR(sc, WXREG_IMASK, ~0);
a1773 1
	WX_DISABLE_INT(sc);
@


1.14
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/* $OpenBSD: if_wx.c,v 1.13 2001/06/24 20:27:03 fgsch Exp $ */
d264 1
a264 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.13
log
@more ether_input_mbuf() conversion.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wx.c,v 1.12 2001/06/12 15:40:31 niklas Exp $ */
d725 2
a726 1
	ifp->if_snd.ifq_maxlen = WX_MAX_TDESC - 1;
d1129 1
a1129 1
		IF_DEQUEUE(&ifp->if_snd, mb_head);
d1268 11
d1351 1
a1351 1
		if (sc->wx_if.if_snd.ifq_head != NULL) {
@


1.12
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wx.c,v 1.11 2001/04/13 00:27:57 mjacob Exp $ */
d1614 1
a1614 1
#if defined(__FreeBSD__) || defined(__OpenBSD__)
d1618 2
@


1.11
log
@Pull in (correct) support for LIVENGOOD fibre cards (some register locations
changed between Wiseman && Livengood. Pull in support for the LIVENGOOD with
a PHY (82543_CU) that supports 10/100/1000- this is the Intel PRO1000T. This
depends on the Marvell phy support in mii.

Do a bunch of ansification. Attempt to *still* keep the OpenBSD printf
stuff sane, but this area needs some more cleanup. It'd probably be best
to fork the OpenBSD code away from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: $ */
d229 1
a229 1
	    &sc->w.st, &sc->w.sh, NULL, NULL)) {
@


1.10
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wx.c,v 1.9 2001/01/29 04:33:59 deraadt Exp $	*/
d3 2
a4 1
 * Copyright (c) 1999, Traakan Software
d29 2
d34 1
a34 1
 * Intel Gigabit Ethernet (82452) Driver.
d77 41
a117 33
static int wx_intr		__P((void *));
static void wx_handle_link_intr	__P((wx_softc_t *));
static void wx_check_link	__P((wx_softc_t *));
static void wx_handle_rxint	__P((wx_softc_t *));
static void wx_gc		__P((wx_softc_t *));
static void wx_start		__P((struct ifnet *));
static int wx_ioctl		__P((struct ifnet *, IOCTL_CMD_TYPE, caddr_t));
static int wx_ifmedia_upd	__P((struct ifnet *));
static void wx_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));
static int wx_init		__P((void *));
static void wx_hw_stop		__P((wx_softc_t *));
static void wx_set_addr		__P((wx_softc_t *, int, u_int8_t *));
static int wx_hw_initialize	__P((wx_softc_t *));
static void wx_stop		__P((wx_softc_t *));
static void wx_txwatchdog	__P((struct ifnet *));
static int wx_get_rbuf		__P((wx_softc_t *, rxpkt_t *));
static void wx_rxdma_map	__P((wx_softc_t *, rxpkt_t *, struct mbuf *));

static INLINE void wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));
static INLINE void wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));
static INLINE void wx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));
static INLINE u_int16_t wx_eeprom_sibits __P((wx_softc_t *));
static INLINE void wx_eeprom_cleanup __P((wx_softc_t *));
static INLINE u_int16_t wx_read_eeprom_word __P((wx_softc_t *, int));
static void wx_read_eeprom __P((wx_softc_t *, u_int16_t *, int, int));

static int wx_attach_common	__P((wx_softc_t *));
static void wx_watchdog		__P((void *));

static INLINE void wx_mwi_whackon	__P((wx_softc_t *));
static INLINE void wx_mwi_unwhack	__P((wx_softc_t *));
static int wx_dring_setup	__P((wx_softc_t *));
static void wx_dring_teardown	__P((wx_softc_t *));
d129 10
d146 5
a150 5
static int	wx_match	__P((struct device *, MATCHARG, void *));
static void	wx_attach	__P((struct device *, struct device *, void *));
static void	wx_shutdown	__P((void *));
static int	wx_ether_ioctl	__P((struct ifnet *, IOCTL_CMD_TYPE, caddr_t));
static int	wx_mc_setup	__P((wx_softc_t *));
d159 2
a160 2
static INLINE u_int32_t _read_csr __P((struct wx_softc *, u_int32_t));
static INLINE void _write_csr __P((struct wx_softc *, u_int32_t, u_int32_t));
d162 2
a163 3
static INLINE u_int32_t _read_csr(sc, reg)
	struct wx_softc *sc;
	u_int32_t reg;
d168 2
a169 4
static INLINE void _write_csr(sc, reg, val)
	struct wx_softc *sc;
	u_int32_t reg;
	u_int32_t val;
a173 4


static wx_softc_t *wxlist;

d188 1
a188 4
wx_match(parent, match, aux)
	struct device *parent;
	MATCHARG match;
	void *aux;
d198 1
d207 1
a207 3
wx_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d209 1
a209 1
	wx_softc_t *tmp, *sc = (wx_softc_t *)self;
d220 5
d256 3
a258 1
	printf(": address %s", ether_sprintf(sc->wx_enaddr));
d294 3
a296 1
	printf(", %s\n", intrstr);
d328 5
d334 11
a344 5
	tmp = wxlist;
	if (tmp) {
		while (tmp->wx_next)
			tmp = tmp->wx_next;
		tmp->wx_next = sc;
d346 1
a346 1
		wxlist = sc;
d348 1
d357 1
a357 2
wx_shutdown(sc)
	void *sc;
d363 1
a363 4
wx_ether_ioctl(ifp, cmd, data)
	struct ifnet *ifp;
	IOCTL_CMD_TYPE cmd;
	caddr_t data;
d420 1
a420 2
wx_mc_setup(sc)
	wx_softc_t *sc;
d462 1
a462 2
wx_mwi_whackon(sc)
	wx_softc_t *sc;
d471 1
a471 2
wx_mwi_unwhack(sc)
	wx_softc_t *sc;
d480 1
a480 2
wx_dring_setup(sc)
	wx_softc_t *sc;
d497 1
a497 1
	if (((u_long)sc->rdescriptors) & 0xfff) {
d515 1
a515 1
	if (((u_long)sc->tdescriptors) & 0xfff) {
d524 1
a524 2
wx_dring_teardown(sc)
	wx_softc_t *sc;
d537 1
a537 1
static int	wx_mc_setup	__P((wx_softc_t *));
d544 1
a544 2
wx_mc_setup(sc)
	wx_softc_t *sc;
d563 2
a564 2
	for (ifma = ifp->if_multiaddrs.lh_first, sc->wx_nmca = 0;
	    ifma != NULL; ifma = ifma->ifma_link.le_next) {
a581 1
static wx_softc_t *wxlist;
d590 1
a590 1
		device_set_desc(dev, "Intel GigaBit Ethernet (WISEMAN)");
d593 2
a594 1
		device_set_desc(dev, "Intel GigaBit Ethernet (LIVENGOOD)");
d596 4
a599 1
		device_set_desc(dev, "Intel GigaBit Ethernet (LIVENGOOD_SC)");
d611 1
a611 1
	wx_softc_t *tmp, *sc = device_get_softc(dev);
d613 1
a613 1
	u_long val;
d621 4
a624 1
	if (getenv_int("wx_debug", &rid)) {
d649 1
a649 1
	mtx_init(&sc->wx_mtx, device_get_nameunit(dev), MTX_DEF);
a726 8
	tmp = wxlist;
	if (tmp) {
		while (tmp->wx_next)
			tmp = tmp->wx_next;
		tmp->wx_next = sc;
	} else {
		wxlist = sc;
	}
d733 12
d752 4
d771 1
a771 2
wx_mwi_whackon(sc)
	wx_softc_t *sc;
d778 1
a778 2
wx_mwi_unwhack(sc)
	wx_softc_t *sc;
d786 1
a786 2
wx_dring_setup(sc)
	wx_softc_t *sc;
d797 1
a797 1
	if (((u_long)sc->rdescriptors) & 0xfff) {
d815 1
a815 1
	if (((u_long)sc->tdescriptors) & 0xfff) {
d827 1
a827 2
wx_dring_teardown(sc)
	wx_softc_t *sc;
d841 5
d852 11
d871 1
a871 1

d879 1
a879 2
wx_attach_common(sc)
	wx_softc_t *sc;
d914 44
a957 6
	ifmedia_init(&sc->wx_media, IFM_IMASK, wx_ifmedia_upd, wx_ifmedia_sts);
	ifmedia_add(&sc->wx_media, IFM_ETHER|IFM_1000_SX, 0, NULL);
	ifmedia_add(&sc->wx_media, IFM_ETHER|IFM_1000_SX|IFM_FDX, 0, NULL);
	ifmedia_set(&sc->wx_media, IFM_ETHER|IFM_1000_SX|IFM_FDX);
	sc->wx_media.ifm_media = sc->wx_media.ifm_cur->ifm_media;
	ll += 1;
d962 1
a962 1
	sc->wx_dcr = 0;
a977 1

d1024 1
a1024 3
wx_eeprom_raise_clk(sc, regval)
	wx_softc_t     *sc;
	u_int32_t	regval;
d1031 1
a1031 3
wx_eeprom_lower_clk(sc, regval)
	wx_softc_t     *sc;
	u_int32_t	regval;
d1038 1
a1038 4
wx_eeprom_sobits(sc, data, count)
	wx_softc_t     *sc;
	u_int16_t	data;
	u_int16_t	count;
a1057 1

d1059 1
a1059 2
wx_eeprom_sibits(sc)
	wx_softc_t     *sc;
a1077 2


d1079 1
a1079 2
wx_eeprom_cleanup(sc)
	wx_softc_t     *sc;
d1089 1
a1089 3
wx_read_eeprom_word(sc, offset)
	wx_softc_t     *sc;
	int             offset;
d1101 1
a1101 5
wx_read_eeprom(sc, data, offset, words)
	wx_softc_t *sc;
	u_int16_t *data;
	int offset;
	int words;
d1115 1
a1115 2
wx_start(ifp)
	struct ifnet *ifp;
d1121 1
d1152 1
a1152 1
again:
d1243 6
a1248 2
			WRITE_CSR(sc, WXREG_TDT, cidx);
#if	NBPFILTER > 0
d1305 6
d1318 1
a1318 2
wx_intr(arg)
	void *arg;
d1332 1
a1332 1
		if (sc->wx_icr & (WXISR_LSC|WXISR_RXSEQ)) {
d1349 1
a1349 2
wx_handle_link_intr(sc)
	wx_softc_t *sc;
d1356 20
d1387 1
a1387 4
		if (sc->wx_debug) {
			printf("%s: /C/ ordered sets seen- enabling ANE\n",
			    sc->wx_name);
		}
d1396 1
a1396 2
			if (sc->wx_debug)
				printf("%s: gigabit link up\n", sc->wx_name);
d1400 1
a1400 2
			if (sc->wx_debug)
				printf("%s: gigabit link down\n", sc->wx_name);
d1406 1
a1406 1
		printf("%s: receive sequence error\n", sc->wx_name);
d1411 1
a1411 2
wx_check_link(sc)
	wx_softc_t *sc;
d1415 5
d1430 1
a1430 4
		if (sc->wx_debug) {
			printf("%s: no /C/ ordered sets seen- disabling ANE\n",
			    sc->wx_name);
		}
d1437 1
a1437 4
		if (sc->wx_debug) {
			printf("%s: /C/ ordered sets seen- enabling ANE\n",
			    sc->wx_name);
		}
d1445 1
a1445 2
wx_handle_rxint(sc)
	wx_softc_t *sc;
d1452 2
d1472 2
a1473 4
			if (sc->wx_debug) {
				printf("WXRX: ndesc %d idx %d lidx %d\n",
				    ndesc, idx, lidx);
			}
d1569 2
a1570 4
		if (sc->wx_debug) {
			printf("%s: RDESC[%d] len %d off %d lastframe %d\n",
			    sc->wx_name, idx, mb->m_len, offset, lastframe);
		}
d1592 5
a1596 1
		WRITE_CSR(sc, WXREG_RDT0, lidx);
d1611 3
a1613 5
                ifp->if_ipackets++;
		if (sc->wx_debug) {
			printf("%s: RECV packet length %d\n",
			    sc->wx_name, mb->m_pkthdr.len);
		}
d1625 1
a1625 2
wx_gc(sc)
	wx_softc_t *sc;
d1633 5
a1637 1
	tdh = READ_CSR(sc, WXREG_TDH);
d1665 2
a1666 4
			if (sc->wx_debug) {
				printf("%s: TXGC %d..%d TDH %d\n", sc->wx_name,
				    txpkt->sidx, txpkt->eidx, tdh);
			}
d1684 2
a1685 3
				if (sc->wx_debug)
					printf("%s: excess collisions\n",
					    sc->wx_name);
d1690 2
a1691 3
				if (sc->wx_debug)
					printf("%s: lost carrier\n",
					    sc->wx_name);
d1695 3
a1697 5
			if (sc->wx_debug) {
				printf("%s: TXGC[%d] %p %d..%d done nact %d "
				    "TDH %d\n", sc->wx_name, cidx, tmp->dptr,
				    txpkt->sidx, txpkt->eidx, sc->tactive, tdh);
			}
d1713 6
d1728 1
a1728 2
wx_watchdog(arg)
	void *arg;
d1747 1
a1747 2
wx_hw_stop(sc)
	wx_softc_t *sc;
d1750 1
d1765 1
a1765 4
wx_set_addr(sc, idx, mac)
	wx_softc_t *sc;
	int idx;
	u_int8_t *mac;
d1768 1
d1777 1
a1777 2
wx_hw_initialize(sc)
	wx_softc_t *sc;
d1781 1
a1781 6
	if (IS_LIVENGOOD(sc)) {
		if ((READ_CSR(sc, WXREG_DSR) & WXDSR_TBIMODE) == 0) {
			printf("%s: no fibre mode detected\n", sc->wx_name);
			return (-1);
		}
	}
d1825 20
a1844 5
	/*
	 * Handle link control
	 */
	WRITE_CSR(sc, WXREG_DCR, sc->wx_dcr | WXDCR_LRST);
	DELAY(50 * 1000);
d1846 5
a1851 2
	if (IS_LIVENGOOD(sc)) {
		u_int16_t tew;
d1868 9
a1876 4
	if (sc->wx_idnrev < WX_WISEMAN_2_1) {
		WRITE_CSR(sc, WXREG_FLOW_RCV_HI, 0);
		WRITE_CSR(sc, WXREG_FLOW_RCV_LO, 0);
		sc->wx_dcr &= ~(WXDCR_RFCE|WXDCR_TFCE);
d1878 2
a1879 2
		WRITE_CSR(sc, WXREG_FLOW_RCV_HI, WX_RCV_FLOW_HI_DFLT);
		WRITE_CSR(sc, WXREG_FLOW_RCV_LO, WX_RCV_FLOW_LO_DFLT);
d1881 4
a1884 1
	WRITE_CSR(sc, WXREG_XMIT_CFGW, WXTXCW_DEFAULT);
d1888 15
a1902 9
	/*
	 * The pin stuff is all FM from the Linux driver.
	 */
	if ((READ_CSR(sc, WXREG_DCR) & WXDCR_SWDPIN1) == 0) {
		for (i = 0; i < (WX_LINK_UP_TIMEOUT/10); i++) {
			DELAY(10 * 1000);
			if (READ_CSR(sc, WXREG_DSR) & WXDSR_LU) {
				sc->linkup = 1;
				break;
d1904 5
a1909 9
		if (sc->linkup == 0) {
			sc->ane_failed = 1;
			wx_check_link(sc);
		}
		sc->ane_failed = 0;
	} else {
		printf("%s: swdpio1 did not clear- check for reversed or "
		    "disconnected cable\n", sc->wx_name);
		/* but return okay anyway */
d1911 1
d1920 1
a1920 2
wx_stop(sc)
	wx_softc_t *sc;
d1926 1
d1974 1
a1974 2
wx_txwatchdog(ifp)
	struct ifnet *ifp;
d1986 1
a1986 2
wx_init(xsc)
	void *xsc;
d1996 1
d2011 1
a2042 8
	WRITE_CSR(sc, WXREG_TDBA_LO,
		vtophys((vm_offset_t)&sc->tdescriptors[0]));
	WRITE_CSR(sc, WXREG_TDBA_HI, 0);
	WRITE_CSR(sc, WXREG_TDLEN, WX_MAX_TDESC * sizeof (wxtd_t));
	WRITE_CSR(sc, WXREG_TDH, 0);
	WRITE_CSR(sc, WXREG_TDT, 0);
	WRITE_CSR(sc, WXREG_TQSA_HI, 0);
	WRITE_CSR(sc, WXREG_TQSA_LO, 0);
d2044 8
d2053 1
d2055 9
d2065 1
a2066 1
	WRITE_CSR(sc, WXREG_TIDV, sc->wx_txint_delay);
d2076 18
a2093 7
	WRITE_CSR(sc, WXREG_RDTR0, WXRDTR_FPD);
	WRITE_CSR(sc, WXREG_RDBA0_LO,
	    vtophys((vm_offset_t)&sc->rdescriptors[0]));
	WRITE_CSR(sc, WXREG_RDBA0_HI, 0);
	WRITE_CSR(sc, WXREG_RDLEN0, WX_MAX_RDESC * sizeof (wxrd_t));
	WRITE_CSR(sc, WXREG_RDH0, 0);
	WRITE_CSR(sc, WXREG_RDT0, (WX_MAX_RDESC - RXINCR));
d2123 10
a2132 5
	ifm = &sc->wx_media;
	i = ifm->ifm_media;
	ifm->ifm_media = ifm->ifm_cur->ifm_media;
	wx_ifmedia_upd(ifp);
	ifm->ifm_media = i;
d2158 1
a2158 4
wx_rxdma_map(sc, rxpkt, mb)
	wx_softc_t *sc;
	rxpkt_t *rxpkt;
	struct mbuf *mb;
d2165 1
a2165 3
wx_get_rbuf(sc, rxpkt)
	wx_softc_t *sc;
	rxpkt_t *rxpkt;
d2184 1
a2184 4
wx_ioctl(ifp, command, data)
	struct ifnet *ifp;
	IOCTL_CMD_TYPE command;
	caddr_t data;
d2250 9
a2258 1
		error = ifmedia_ioctl(ifp, ifr, &sc->wx_media, command);
d2270 1
a2270 2
wx_ifmedia_upd(ifp)
	struct ifnet *ifp;
d2273 8
a2280 1
	struct ifmedia *ifm = &sc->wx_media;
d2282 3
a2284 1
	if (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)
d2286 2
d2292 1
a2292 3
wx_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
d2297 12
d2319 6
a2324 1
			ifmr->ifm_status |= IFM_1000_SX;
d2336 165
@


1.9
log
@init the interface before interrupt establishment; and change to OpenBSD printing "rules"
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wx.c,v 1.8 2000/12/07 02:35:55 mjacob Exp $	*/
a296 1
#endif
d301 1
@


1.8
log
@Thanks to Peter Galbavy <peter.galbavy@@knowledge.com> for noticing-
need #if NBPFILTER > 0 around a couple of spots.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wx.c,v 1.7 2000/12/06 01:02:14 mjacob Exp $	*/
d218 1
d220 23
d249 1
d251 3
d264 1
d266 3
d274 1
d276 3
a278 14
	sc->wx_idnrev = (PCI_PRODUCT(pa->pa_id) << 16) |
		(pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG) & 0xff);

	data = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);
	data &= ~(PCI_CACHELINE_MASK << PCI_CACHELINE_SHIFT);
	data |= (WX_CACHELINE_SIZE << PCI_CACHELINE_SHIFT);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG, data);

	if (wx_attach_common(sc)) {
		return;
	}

	printf("%s: Ethernet address %s\n",
	    sc->wx_name, ether_sprintf(sc->wx_enaddr));
@


1.7
log
@Merge together FreeBSD && OpenBSD versions, benefitting OpenBSD with
getting LIVENGOOD (newer chipset) support. There will be a bit more
coming down the pipe with this in a couple of weeks when I get the
board that does 10/100/1000 all through CAT-5 cable....
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wx.c,v 1.6 2000/08/11 15:11:39 deraadt Exp $	*/
d1157 1
d1160 1
d1497 1
d1501 1
@


1.6
log
@silence chatty messages
@
text
@d1 1
a1 2
/*	$OpenBSD: if_wx.c,v 1.5 2000/07/06 23:32:12 mjacob Exp $	*/

a27 1
 * $FreeBSD: src/sys/pci/if_wx.c,v 1.5 2000/01/25 06:09:53 mjacob Exp $
d183 6
a188 1
	if (PCI_PRODUCT(pa->pa_id) != WX_PRODUCT_82452) {
d218 1
d236 1
a236 1
		printf("couldn't establish interrupt");
d242 3
a244 2
	sc->revision =
		pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG) & 0xff;
d255 2
a256 1
	printf(": %s, address %s\n", intrstr, ether_sprintf(sc->wx_enaddr));
d543 14
a556 4
	if ((pci_get_vendor(dev) == WX_VENDOR_INTEL) &&
	    (pci_get_device(dev) == WX_PRODUCT_82452)) {
		device_set_desc(dev, "Intel GigaBit Ethernet");
		return 0;
d558 1
a558 1
	return (ENXIO);
a566 1
	int s;
d599 10
a608 1
	s = splimp();
a620 4
	/*
 	 * get revision
	 */
	sc->revision = pci_read_config(dev, PCIR_CLASS, 1);
d663 1
a675 1
	if_attach(ifp);
d677 1
a677 2
	ether_ifattach(ifp);
	bpfattach(ifp, DLT_EN10MB, sizeof(struct ether_header));
d687 1
a687 1
	splx(s);
d695 3
a697 2
	int s = splimp();
	if_detach(&sc->w.arpcom.ac_if);
d702 1
a702 1
	splx(s);
d744 2
d755 3
d762 3
d777 2
a778 1
		WXFREE(sc->rdescriptors);
d782 2
a783 1
		WXFREE(sc->tdescriptors);
d820 3
a822 3
	if (sc->revision < 2) {
		printf("%s: cannot support revision %d chips\n",
		    sc->wx_name, sc->revision);
d1034 1
d1212 1
d1225 1
d1246 1
d1282 2
a1283 1
			/* printf("%s: gigabit link now up\n", sc->wx_name); */
d1287 2
a1288 1
			/* printf("%s: gigabit link now down\n", sc->wx_name); */
d1319 1
a1319 1
		if (sc->revision == 2)
d1473 6
a1478 1
#ifdef __OpenBSD__
a1479 14
#else
		eh = mtod(m0, struct ether_header *);
		if ((ifp->if_flags & IFF_PROMISC) &&
		    (bcmp(eh->ether_dhost, sc->wx_enaddr, ETHER_ADDR_LEN) &&
		    (eh->ether_dhost[0] & 1) == 0)) {
			m_freem(m0);
			if (sc->rpending) {
				m_freem(sc->rpending);
				sc->rpending = NULL;
			}
                } else {
			pending[npkts++] = m0;
		}
#endif
d1518 2
a1519 3
	txpkt_t *txpkt = sc->tbsyf;
	u_int32_t tdh = READ_CSR(sc, WXREG_TDH);
	int s;
d1521 3
a1523 1
	s = splimp();
d1572 3
a1574 1
				/* printf("%s: excess collisions\n", sc->wx_name); */
d1579 3
a1581 1
				/* printf("%s: lost carrier\n", sc->wx_name); */
d1605 1
a1605 1
	splx(s);
a1617 1
	int s;
d1619 1
a1619 1
	s = splimp();
d1622 1
a1622 1
	splx(s);
d1627 1
a1627 1
	TIMEOUT(sc, wx_watchdog, sc, hz);
d1638 1
a1638 1
	if (sc->revision == 2) {
d1645 1
a1645 1
	if (sc->revision == 2) {
d1671 7
d1682 1
a1682 1
	if (sc->revision == 2) {
d1707 1
a1707 1
	if (sc->revision == 2) {
d1726 8
d1744 2
a1745 1
	if (sc->revision == 2) {
d1862 1
a1862 1
	int s, i, bflags;
d1864 1
a1864 1
	s = splimp();
d1878 1
d1898 1
d1917 5
a1921 1
	WRITE_CSR(sc, WXREG_TIPG, WX_TIPG_DFLT);
a1946 1
		/* printf("%s: enabling for jumbo packets\n", sc->wx_name); */
d1973 1
a1973 1
	splx(s);
d2036 1
a2036 1
	int s, error = 0;
d2038 1
a2038 1
	s = splimp();
d2105 1
a2105 1
	(void) splx(s);
d2126 1
d2135 14
a2148 2
	ifmr->ifm_status |= IFM_ACTIVE|IFM_1000_SX;
	if (READ_CSR(sc, WXREG_DSR) & WXDSR_FD)
d2150 1
@


1.5
log
@#ifdef SIOCGIFMTU should have been SIOCSIFMTU.
Noticed by:  Chris Cappuccio <chris@@dqc.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wx.c,v 1.4 2000/07/06 06:19:08 mjacob Exp $	*/
d1248 1
a1248 1
			printf("%s: gigabit link now up\n", sc->wx_name);
d1252 1
a1252 1
			printf("%s: gigabit link now down\n", sc->wx_name);
d1544 1
a1544 1
				printf("%s: excess collisions\n", sc->wx_name);
d1549 1
a1549 1
				printf("%s: lost carrier\n", sc->wx_name);
d1894 1
a1894 1
		printf("%s: enabling for jumbo packets\n", sc->wx_name);
@


1.4
log
@Port latest in from FreeBSD- finally have some of the link issues sorted
out so we should now be able to work with switches.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wx.c,v 1.3 2000/04/26 23:16:12 chris Exp $	*/
d1995 1
a1995 1
#ifdef	SIOCGIFMTU
@


1.3
log
@Enable SIOCSIFMTU, as it is supported by if.c and ifconfig now
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wx.c,v 1.2 2000/03/22 18:15:20 deraadt Exp $	*/
d78 1
d90 1
a90 1
static void wx_watchdog		__P((struct ifnet *));
d103 1
a103 1
static void wx_stats_update	__P((void *));
d259 1
a259 1
	ifp->if_watchdog = wx_watchdog;
d654 1
a654 1
	ifp->if_watchdog = wx_watchdog;
d788 10
a797 1
	 * First, reset the chip.
d802 1
a802 1
	 * Second, validate our EEPROM.
d808 1
a808 1
	 * Third, read eeprom for our MAC address and other things.
d813 1
a813 1
	 * Fourth, establish some adapter parameters.
d824 1
a824 1
	 * Fifth, establish a default device control register word.
d844 1
a844 1
	 * Sixth, allocate various sw structures...
d863 1
a863 1
	 * Seventh, allocate and dma map (platform dependent) descriptor rings.
d1220 2
d1223 73
a1295 1
	printf("%s: link intr 0x%x\n", sc->wx_name, sc->wx_icr);
d1577 3
a1579 1
 * Update packet in/out/collision statistics.
d1582 1
a1582 1
wx_stats_update(arg)
d1590 1
d1596 1
a1596 1
	TIMEOUT(sc, wx_stats_update, sc, hz);
d1681 7
d1701 1
d1714 1
a1714 1
		for (i = 0; i < 500; i++) {
d1721 5
d1727 3
a1729 6
		printf("%s: swdpio did not clear\n", sc->wx_name);
		return (-1);
	}
	if (sc->linkup == 0) {
		printf("%s: link never came up\n", sc->wx_name);
		return (-1);
d1749 1
a1749 1
	UNTIMEOUT(wx_stats_update, sc, sc);
d1790 1
a1790 1
 * Watchdog/transmission transmit timeout handler.
d1793 1
a1793 1
wx_watchdog(ifp)
d1926 1
a1926 1
	TIMEOUT(sc, wx_stats_update, sc, hz);
d1995 1
d2004 1
@


1.2
log
@single line attach message
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wx.c,v 1.1 2000/02/11 14:51:50 jason Exp $	*/
a1897 1
#if defined(SIOCSIFMTU) && !defined(__OpenBSD__)
a1905 1
#endif
@


1.1
log
@Intel 82452 (Pro/1000) driver from mjacob@@feral.com
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a213 1
	printf(": Intel GigaBit Ethernet\n");
d231 1
a231 1
		printf("%s: couldn't establish interrupt", sc->wx_name);
a236 1
	printf("%s: interrupting at %s\n", sc->wx_name, intrstr);
d249 1
a249 2
	printf("%s: Ethernet address %s\n",
	    sc->wx_name, ether_sprintf(sc->wx_enaddr));
@


1.1.2.1
log
@Sync with -current
@
text
@d214 1
d232 1
a232 1
		printf("couldn't establish interrupt");
d238 1
d251 2
a252 1
	printf(": %s, address %s\n", intrstr, ether_sprintf(sc->wx_enaddr));
@


1.1.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 1
/* $OpenBSD: if_wx.c,v 1.11 2001/04/13 00:27:57 mjacob Exp $ */
d4 1
a4 2
 * Principal Author: Matthew Jacob
 * Copyright (c) 1999, 2001 by Traakan Software
d29 1
a29 2
 * Additional Copyright (c) 2001 by Parag Patel
 * under same licence for MII PHY code.
d33 1
a33 1
 * Intel Gigabit Ethernet (82452/82453) Driver.
d76 32
a107 41
static int wx_intr(void *);
static void wx_handle_link_intr(wx_softc_t *);
static void wx_check_link(wx_softc_t *);
static void wx_handle_rxint(wx_softc_t *);
static void wx_gc(wx_softc_t *);
static void wx_start(struct ifnet *);
static int wx_ioctl(struct ifnet *, IOCTL_CMD_TYPE, caddr_t);
static int wx_ifmedia_upd(struct ifnet *);
static void wx_ifmedia_sts(struct ifnet *, struct ifmediareq *);
static int wx_init(void *);
static void wx_hw_stop(wx_softc_t *);
static void wx_set_addr(wx_softc_t *, int, u_int8_t *);
static int wx_hw_initialize(wx_softc_t *);
static void wx_stop(wx_softc_t *);
static void wx_txwatchdog(struct ifnet *);
static int wx_get_rbuf(wx_softc_t *, rxpkt_t *);
static void wx_rxdma_map(wx_softc_t *, rxpkt_t *, struct mbuf *);

static INLINE void wx_eeprom_raise_clk(wx_softc_t *, u_int32_t);
static INLINE void wx_eeprom_lower_clk(wx_softc_t *, u_int32_t);
static INLINE void wx_eeprom_sobits(wx_softc_t *, u_int16_t, u_int16_t);
static INLINE u_int16_t wx_eeprom_sibits(wx_softc_t *);
static INLINE void wx_eeprom_cleanup(wx_softc_t *);
static INLINE u_int16_t wx_read_eeprom_word(wx_softc_t *, int);
static void wx_read_eeprom(wx_softc_t *, u_int16_t *, int, int);

static int wx_attach_common(wx_softc_t *);
static void wx_watchdog(void *);

static INLINE void wx_mwi_whackon(wx_softc_t *);
static INLINE void wx_mwi_unwhack(wx_softc_t *);
static int wx_dring_setup(wx_softc_t *);
static void wx_dring_teardown(wx_softc_t *);

static int wx_attach_phy(wx_softc_t *);
static int wx_miibus_readreg(void *, int, int);
static int wx_miibus_writereg(void *, int, int, int);
static void wx_miibus_statchg(void *);

static u_int32_t wx_mii_shift_in(wx_softc_t *);
static void wx_mii_shift_out(wx_softc_t *, u_int32_t, u_int32_t);
a118 10
#define	DPRINTF(sc, x)	if (sc->wx_debug) printf x
#define	IPRINTF(sc, x)	if (sc->wx_verbose) printf x

static const char ldn[] = "%s: link down\n";
static const char lup[] = "%s: link up\n";
static const char sqe[] = "%s: receive sequence error\n";
static const char ane[] = "%s: /C/ ordered sets seen- enabling ANE\n";
static const char inane[] = "%s: no /C/ ordered sets seen- disabling ANE\n";


d126 5
a130 5
static int	wx_match(struct device *, MATCHARG, void *);
static void	wx_attach(struct device *, struct device *, void *);
static void	wx_shutdown(void *);
static int	wx_ether_ioctl(struct ifnet *, IOCTL_CMD_TYPE, caddr_t);
static int	wx_mc_setup(wx_softc_t *);
d139 2
a140 2
static INLINE u_int32_t _read_csr (wx_softc_t *, u_int32_t);
static INLINE void _write_csr(wx_softc_t *, u_int32_t, u_int32_t);
d142 3
a144 2
static INLINE u_int32_t
_read_csr(wx_softc_t *sc, u_int32_t reg)
d149 4
a152 2
static INLINE void
_write_csr(wx_softc_t *sc, u_int32_t reg, u_int32_t val)
d157 4
d175 4
a178 1
wx_match(struct device *parent, MATCHARG match, void *aux)
d184 1
a184 7
	switch (PCI_PRODUCT(pa->pa_id)) {
	case WX_PRODUCT_82452:
	case WX_PRODUCT_LIVENGOOD:
	case WX_PRODUCT_82452_SC:
	case WX_PRODUCT_82543:
		break;
	default:
d191 3
a193 1
wx_attach(struct device *parent, struct device *self, void *aux)
d195 1
a195 1
	wx_softc_t *sc = (wx_softc_t *)self;
a205 5
#if	defined(__NetBSD__)
	if (bootverbose)
		sc->wx_verbose = 1;
#endif

a213 27
#ifndef __OpenBSD__
	printf(": Intel GigaBit Ethernet\n");
#endif

	sc->wx_idnrev = (PCI_PRODUCT(pa->pa_id) << 16) |
		(pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG) & 0xff);

	data = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);
	data &= ~(PCI_CACHELINE_MASK << PCI_CACHELINE_SHIFT);
	data |= (WX_CACHELINE_SIZE << PCI_CACHELINE_SHIFT);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG, data);

	if (wx_attach_common(sc)) {
#ifdef __OpenBSD__
		printf("\n");
#endif
		return;
	}

#ifndef __OpenBSD__
	printf("%s: Ethernet address %s\n",
	    sc->wx_name, ether_sprintf(sc->wx_enaddr));
#else
	if (!IS_LIVENGOOD_CU(sc)) {
		printf(": address %s", ether_sprintf(sc->wx_enaddr));
	}
#endif
a219 1
#ifndef __OpenBSD__
a220 3
#else
		printf(", couldn't map interrupt\n");
#endif
d231 1
a231 5
#ifndef __OpenBSD__
		printf("%s: couldn't establish interrupt", sc->wx_name);
#else
		printf(", couldn't establish interrupt\n");
#endif
d237 10
a246 5
#ifndef __OpenBSD__
	printf("%s: interrupting at %s\n", sc->wx_name, intrstr);
#else
	if (!IS_LIVENGOOD_CU(sc)) {
		printf(", %s\n", intrstr);
d248 2
a249 1
#endif
d258 1
a258 1
	ifp->if_watchdog = wx_txwatchdog;
d268 1
a273 1
#endif
a279 1
}
d281 5
a285 15
static int
wx_attach_phy(wx_softc_t *sc)
{

	sc->wx_mii = &sc->w.mii_data;
	ifmedia_init(&sc->wx_mii->mii_media, 0, wx_ifmedia_upd, wx_ifmedia_sts);
        sc->wx_mii->mii_ifp = &sc->wx_if;
	sc->wx_mii->mii_readreg = (mii_readreg_t) wx_miibus_readreg;
	sc->wx_mii->mii_writereg = (mii_writereg_t) wx_miibus_writereg;
	sc->wx_mii->mii_statchg = (mii_statchg_t) wx_miibus_statchg;
	mii_phy_probe(&sc->w.dev, sc->wx_mii, 0xffffffff);
	if (LIST_FIRST(&sc->wx_mii->mii_phys) == NULL) {
		ifmedia_add(&sc->wx_mii->mii_media,
		    IFM_ETHER|IFM_NONE, 0, NULL);
		ifmedia_set(&sc->wx_mii->mii_media, IFM_ETHER|IFM_NONE);
d287 1
a287 1
		ifmedia_set(&sc->wx_mii->mii_media, IFM_ETHER|IFM_AUTO);
a288 1
	return 0;
d297 2
a298 1
wx_shutdown(void *sc)
d304 4
a307 1
wx_ether_ioctl(struct ifnet *ifp, IOCTL_CMD_TYPE cmd, caddr_t data)
d364 2
a365 1
wx_mc_setup(wx_softc_t *sc)
d407 2
a408 1
wx_mwi_whackon(wx_softc_t *sc)
d417 2
a418 1
wx_mwi_unwhack(wx_softc_t *sc)
d427 2
a428 1
wx_dring_setup(wx_softc_t *sc)
d445 1
a445 1
	if (((intptr_t)sc->rdescriptors) & 0xfff) {
d463 1
a463 1
	if (((intptr_t)sc->tdescriptors) & 0xfff) {
d472 2
a473 1
wx_dring_teardown(wx_softc_t *sc)
d486 1
a486 1
static int wx_mc_setup(wx_softc_t *);
d493 2
a494 1
wx_mc_setup(wx_softc_t *sc)
d513 2
a514 2
	sc->wx_nmca = 0;
	TAILQ_FOREACH(ifma, &ifp->if_multiaddrs, ifma_link) {
d532 1
d536 4
a539 2
	if (pci_get_vendor(dev) != WX_VENDOR_INTEL) {
		return (ENXIO);
d541 1
a541 17
	switch (pci_get_device(dev)) {
	case WX_PRODUCT_82452:
		device_set_desc(dev, "Intel PRO/1000 Gigabit (WISEMAN)");
		break;
	case WX_PRODUCT_LIVENGOOD:
		device_set_desc(dev, "Intel PRO/1000 (LIVENGOOD)");
		break;
	case WX_PRODUCT_82452_SC:
		device_set_desc(dev, "Intel PRO/1000 F Gigabit Ethernet");
		break;
	case WX_PRODUCT_82543:
		device_set_desc(dev, "Intel PRO/1000 T Gigabit Ethernet");
		break;
	default:
		return (ENXIO);
	}
	return (0);
d548 1
a548 1
	wx_softc_t *sc = device_get_softc(dev);
d550 2
a551 1
	u_int32_t val;
d559 1
a559 4
	if (bootverbose)
		sc->wx_verbose = 1;

	if (getenv_int ("wx_debug", &rid)) {
d583 1
a583 10
#ifdef	SMPNG
	mtx_init(&sc->wx_mtx, device_get_nameunit(dev), MTX_DEF | MTX_RECURSE);
#endif

	WX_LOCK(sc);
	/*
 	 * get revision && id...
	 */
	sc->wx_idnrev = (pci_get_device(dev) << 16) | (pci_get_revid(dev));

d596 4
a641 1

d653 2
a654 1
	ifp->if_watchdog = wx_txwatchdog;
d656 10
a665 1
	ether_ifattach(ifp, ETHER_BPF_SUPPORTED);
d667 1
a667 1
	WX_UNLOCK(sc);
a671 12
wx_attach_phy(wx_softc_t *sc)
{
	if (mii_phy_probe(sc->w.dev, &sc->w.miibus, wx_ifmedia_upd,
	    wx_ifmedia_sts)) {
		printf("%s: no PHY probed!\n", sc->wx_name);
		return (-1);
	}
	sc->wx_mii = device_get_softc(sc->w.miibus);
	return 0;
}

static int
d675 2
a676 3

	WX_LOCK(sc);
	ether_ifdetach(&sc->w.arpcom.ac_if, ETHER_BPF_SUPPORTED);
a677 4

	bus_generic_detach(dev);
	device_delete_child(dev, sc->w.miibus);

d681 1
a681 1
	WX_UNLOCK(sc);
d693 2
a694 1
wx_mwi_whackon(wx_softc_t *sc)
d701 2
a702 1
wx_mwi_unwhack(wx_softc_t *sc)
d710 2
a711 1
wx_dring_setup(wx_softc_t *sc)
d722 1
a722 3
	if (((intptr_t)sc->rdescriptors) & 0xfff) {
		contigfree(sc->rdescriptors, len, M_DEVBUF);
		sc->rdescriptors = NULL;
a731 3
		contigfree(sc->rdescriptors,
		    sizeof (wxrd_t) * WX_MAX_RDESC, M_DEVBUF);
		sc->rdescriptors = NULL;
d735 1
a735 4
	if (((intptr_t)sc->tdescriptors) & 0xfff) {
		contigfree(sc->rdescriptors,
		    sizeof (wxrd_t) * WX_MAX_RDESC, M_DEVBUF);
		sc->rdescriptors = NULL;
d744 2
a745 1
wx_dring_teardown(wx_softc_t *sc)
d748 1
a748 2
		contigfree(sc->rdescriptors,
		    sizeof (wxrd_t) * WX_MAX_RDESC, M_DEVBUF);
d752 1
a752 2
		contigfree(sc->tdescriptors,
		    sizeof (wxtd_t) * WX_MAX_TDESC, M_DEVBUF);
a756 5
static void
wx_miibus_mediainit(void *arg)
{
}

a762 11

	/* bus interface */
	DEVMETHOD(bus_print_child,	bus_generic_print_child),
	DEVMETHOD(bus_driver_added,	bus_generic_driver_added),

	/* MII interface */
	DEVMETHOD(miibus_readreg,	wx_miibus_readreg),
	DEVMETHOD(miibus_writereg,	wx_miibus_writereg),
	DEVMETHOD(miibus_statchg,	wx_miibus_statchg),
	DEVMETHOD(miibus_mediainit,	wx_miibus_mediainit),

d771 1
a771 1
DRIVER_MODULE(miibus, wx, miibus_driver, miibus_devclass, 0, 0);
d779 2
a780 1
wx_attach_common(wx_softc_t *sc)
d787 1
a787 10
	 * First, check for revision support.
	 */
	if (sc->wx_idnrev < WX_WISEMAN_2_0) {
		printf("%s: cannot support ID 0x%x, revision %d chips\n",
		    sc->wx_name, sc->wx_idnrev >> 16, sc->wx_idnrev & 0xffff);
		return (ENXIO);
	}

	/*
	 * Second, reset the chip.
d792 1
a792 1
	 * Third, validate our EEPROM.
d798 1
a798 1
	 * Fourth, read eeprom for our MAC address and other things.
d803 1
a803 1
	 * Fifth, establish some adapter parameters.
d806 6
a811 44
	sc->wx_dcr = 0;

	if (IS_LIVENGOOD_CU(sc)) {

		/* settings to talk to PHY */
		sc->wx_dcr |= WXDCR_FRCSPD | WXDCR_FRCDPX | WXDCR_SLU;
		WRITE_CSR(sc, WXREG_DCR, sc->wx_dcr);

		/*
		 * Raise the PHY's reset line to make it operational.
		 */
		tmp = READ_CSR(sc, WXREG_EXCT);
		tmp |= WXPHY_RESET_DIR4;
		WRITE_CSR(sc, WXREG_EXCT, tmp);
		DELAY(20*1000);

		tmp = READ_CSR(sc, WXREG_EXCT);
		tmp &= ~WXPHY_RESET4;
		WRITE_CSR(sc, WXREG_EXCT, tmp);
		DELAY(20*1000);

		tmp = READ_CSR(sc, WXREG_EXCT);
		tmp |= WXPHY_RESET4;
		WRITE_CSR(sc, WXREG_EXCT, tmp);
		DELAY(20*1000);

#ifdef __OpenBSD__
		printf(": address %s\n", ether_sprintf(sc->wx_enaddr));
#endif
		if (wx_attach_phy(sc)) {
			goto fail;
		}
	} else {
		ifmedia_init(&sc->wx_media, IFM_IMASK,
		    wx_ifmedia_upd, wx_ifmedia_sts);

		ifmedia_add(&sc->wx_media,
		    IFM_ETHER|IFM_1000_SX, 0, NULL);
		ifmedia_add(&sc->wx_media,
		    IFM_ETHER|IFM_1000_SX|IFM_FDX, 0, NULL);
		ifmedia_set(&sc->wx_media, IFM_ETHER|IFM_1000_SX|IFM_FDX);

		sc->wx_media.ifm_media = sc->wx_media.ifm_cur->ifm_media;
	}
d814 1
a814 1
	 * Sixth, establish a default device control register word.
d816 1
a816 1
	ll += 1;
d832 1
d834 1
a834 1
	 * Seventh, allocate various sw structures...
d853 1
a853 1
	 * Eighth, allocate and dma map (platform dependent) descriptor rings.
d879 3
a881 1
wx_eeprom_raise_clk(wx_softc_t *sc, u_int32_t regval)
d888 3
a890 1
wx_eeprom_lower_clk(wx_softc_t *sc, u_int32_t regval)
d897 4
a900 1
wx_eeprom_sobits(wx_softc_t *sc, u_int16_t data, u_int16_t count)
d920 1
d922 2
a923 1
wx_eeprom_sibits(wx_softc_t *sc)
d942 2
d945 2
a946 1
wx_eeprom_cleanup(wx_softc_t *sc)
d956 3
a958 1
wx_read_eeprom_word(wx_softc_t *sc, int offset)
d970 5
a974 1
wx_read_eeprom(wx_softc_t *sc, u_int16_t *data, int offset, int words)
d988 2
a989 1
wx_start(struct ifnet *ifp)
a993 2
	WX_LOCK(sc);
	DPRINTF(sc, ("%s: wx_start\n", sc->wx_name));
d1024 1
a1024 1
	again:
d1115 1
a1115 6
			if (IS_WISEMAN(sc)) {
				WRITE_CSR(sc, WXREG_TDT, cidx);
			} else {
				WRITE_CSR(sc, WXREG_TDT_LIVENGOOD, cidx);
			}
#if	NBFILTER > 0
a1117 1
#endif
a1170 7

	/* used SW LED to indicate transmission active */
	if (sc->tactive > 0 && sc->wx_mii) {
		WRITE_CSR(sc, WXREG_DCR,
		    READ_CSR(sc, WXREG_DCR) | (WXDCR_SWDPIO0|WXDCR_SWDPIN0));
	}
	WX_UNLOCK(sc);
d1177 2
a1178 1
wx_intr(void *arg)
a1182 1
	WX_ILOCK(sc);
d1191 1
a1191 1
		if (sc->wx_icr & (WXISR_LSC|WXISR_RXSEQ|WXISR_GPI_EN1)) {
a1202 1
	WX_IUNLK(sc);
d1207 2
a1208 1
wx_handle_link_intr(wx_softc_t *sc)
a1209 2
	u_int32_t txcw, rxcw, dcr, dsr;

d1211 1
a1211 54

	dcr = READ_CSR(sc, WXREG_DCR);
	DPRINTF(sc, ("%s: handle_link_intr: icr=%#x dcr=%#x\n",
	    sc->wx_name, sc->wx_icr, dcr));
	if (sc->wx_mii) {
		mii_pollstat(sc->wx_mii);
		if (sc->wx_mii->mii_media_status & IFM_ACTIVE) {
			if (IFM_SUBTYPE(sc->wx_mii->mii_media_active) ==
			    IFM_NONE) {
				IPRINTF(sc, (ldn, sc->wx_name));
				sc->linkup = 0;
			} else {
				IPRINTF(sc, (lup, sc->wx_name));
				sc->linkup = 1;
			}
			WRITE_CSR(sc, WXREG_DCR, sc->wx_dcr);
		} else if (sc->wx_icr & WXISR_RXSEQ) {
			DPRINTF(sc, (sqe, sc->wx_name));
		}
		return;
	}

	txcw = READ_CSR(sc, WXREG_XMIT_CFGW);
	rxcw = READ_CSR(sc, WXREG_RECV_CFGW);
	dsr = READ_CSR(sc, WXREG_DSR);

	/*
	 * If we have LOS or are now receiving Ordered Sets and are not
	 * doing auto-negotiation, restore autonegotiation.
	 */

	if (((dcr & WXDCR_SWDPIN1) || (rxcw & WXRXCW_C)) &&
	    ((txcw & WXTXCW_ANE) == 0)) {
		DPRINTF(sc, (ane, sc->wx_name));
		WRITE_CSR(sc, WXREG_XMIT_CFGW, WXTXCW_DEFAULT);
		sc->wx_dcr &= ~WXDCR_SLU;
		WRITE_CSR(sc, WXREG_DCR, sc->wx_dcr);
		sc->ane_failed = 0;
	}

	if (sc->wx_icr & WXISR_LSC) {
		if (READ_CSR(sc, WXREG_DSR) & WXDSR_LU) {
			IPRINTF(sc, (lup, sc->wx_name));
			sc->linkup = 1;
			sc->wx_dcr |= (WXDCR_SWDPIO0|WXDCR_SWDPIN0);
		} else {
			IPRINTF(sc, (ldn, sc->wx_name));
			sc->linkup = 0;
			sc->wx_dcr &= ~(WXDCR_SWDPIO0|WXDCR_SWDPIN0);
		}
		WRITE_CSR(sc, WXREG_DCR, sc->wx_dcr);
	} else {
		DPRINTF(sc, (sqe, sc->wx_name));
	}
d1215 2
a1216 35
wx_check_link(wx_softc_t *sc)
{
	u_int32_t rxcw, dcr, dsr;

	if (sc->wx_mii) {
		mii_pollstat(sc->wx_mii);
		return;
	}

	rxcw = READ_CSR(sc, WXREG_RECV_CFGW);
	dcr = READ_CSR(sc, WXREG_DCR);
	dsr = READ_CSR(sc, WXREG_DSR);

	if ((dsr & WXDSR_LU) == 0 && (dcr & WXDCR_SWDPIN1) == 0 &&
	    (rxcw & WXRXCW_C) == 0) {
		if (sc->ane_failed == 0) {
			sc->ane_failed = 1;
			return;
		}
		DPRINTF(sc, (inane, sc->wx_name));
		WRITE_CSR(sc, WXREG_XMIT_CFGW, WXTXCW_DEFAULT & ~WXTXCW_ANE);
		if (sc->wx_idnrev < WX_WISEMAN_2_1)
			sc->wx_dcr &= ~WXDCR_TFCE;
		sc->wx_dcr |= WXDCR_SLU;
     		WRITE_CSR(sc, WXREG_DCR, sc->wx_dcr);
	} else if ((rxcw & WXRXCW_C) != 0 && (dcr & WXDCR_SLU) != 0) {
		DPRINTF(sc, (ane, sc->wx_name));
		WRITE_CSR(sc, WXREG_XMIT_CFGW, WXTXCW_DEFAULT);
		sc->wx_dcr &= ~WXDCR_SLU;
		WRITE_CSR(sc, WXREG_DCR, sc->wx_dcr);
	}
}

static void
wx_handle_rxint(wx_softc_t *sc)
a1222 2
	DPRINTF(sc, ("%s: wx_handle_rxint\n", sc->wx_name));

d1241 4
a1244 2
			DPRINTF(sc, ("%s: WXRX: ndesc %d idx %d lidx %d\n",
			    sc->wx_name, ndesc, idx, lidx));
d1340 4
a1343 2
		DPRINTF(sc, ("%s: RDESC[%d] len %d off %d lastframe %d\n",
		    sc->wx_name, idx, mb->m_len, offset, lastframe));
d1353 3
d1357 12
a1368 6
		/*
		 * No need to check for promiscous mode since 
		 * the decision to keep or drop the packet is
		 * handled by ether_input()
		 */
		pending[npkts++] = m0;
d1374 1
a1374 5
		if (IS_WISEMAN(sc)) {
			WRITE_CSR(sc, WXREG_RDT0, lidx);
		} else {
			WRITE_CSR(sc, WXREG_RDT0_LIVENGOOD, lidx);
		}
a1383 1
#if	NBPFILTER > 0
d1387 5
a1391 4
#endif
		ifp->if_ipackets++;
		DPRINTF(sc, ("%s: RECV packet length %d\n",
		    sc->wx_name, mb->m_pkthdr.len));
d1403 2
a1404 1
wx_gc(wx_softc_t *sc)
d1407 3
a1409 2
	txpkt_t *txpkt;
	u_int32_t tdh;
d1411 1
a1411 7
	WX_LOCK(sc);
	txpkt = sc->tbsyf;
	if (IS_WISEMAN(sc)) {
		tdh = READ_CSR(sc, WXREG_TDH);
	} else {
		tdh = READ_CSR(sc, WXREG_TDH_LIVENGOOD);
	}
d1439 4
a1442 2
			DPRINTF(sc, ("%s: TXGC %d..%d TDH %d\n", sc->wx_name,
			    txpkt->sidx, txpkt->eidx, tdh));
d1460 1
a1460 2
				IPRINTF(sc, ("%s: excess collisions\n",
				    sc->wx_name));
d1465 1
a1465 2
				IPRINTF(sc,
				    ("%s: lost carrier\n", sc->wx_name));
d1469 5
a1473 3
			DPRINTF(sc, ("%s: TXGC[%d] %p %d..%d done nact %d "
			    "TDH %d\n", sc->wx_name, cidx, tmp->dptr,
			    txpkt->sidx, txpkt->eidx, sc->tactive, tdh));
d1489 1
a1489 7

	/* used SW LED to indicate transmission not active */
	if (sc->tactive == 0 && sc->wx_mii) {
		WRITE_CSR(sc, WXREG_DCR,
		    READ_CSR(sc, WXREG_DCR) & ~(WXDCR_SWDPIO0|WXDCR_SWDPIN0));
	}
	WX_UNLOCK(sc);
d1493 1
a1493 3
 * Periodic timer to update packet in/out/collision statistics,
 * and, more importantly, garbage collect completed transmissions
 * and to handle link status changes.
d1496 2
a1497 1
wx_watchdog(void *arg)
d1500 1
d1502 1
a1502 1
	WX_LOCK(sc);
d1504 1
a1504 2
	wx_check_link(sc);
	WX_UNLOCK(sc);
d1509 1
a1509 1
	VTIMEOUT(sc, wx_watchdog, sc, hz);
d1516 2
a1517 1
wx_hw_stop(wx_softc_t *sc)
d1520 1
a1520 2
	DPRINTF(sc, ("%s: wx_hw_stop\n", sc->wx_name));
	if (sc->wx_idnrev < WX_WISEMAN_2_1) {
d1527 1
a1527 1
	if (sc->wx_idnrev < WX_WISEMAN_2_1) {
d1534 4
a1537 1
wx_set_addr(wx_softc_t *sc, int idx, u_int8_t *mac)
a1539 1
	DPRINTF(sc, ("%s: wx_set_addr\n", sc->wx_name));
d1548 2
a1549 1
wx_hw_initialize(wx_softc_t *sc)
a1552 2
	DPRINTF(sc, ("%s: wx_hw_initialize\n", sc->wx_name));

d1557 1
a1557 1
	if (sc->wx_idnrev < WX_WISEMAN_2_1) {
d1582 1
a1582 1
	if (sc->wx_idnrev < WX_WISEMAN_2_1) {
a1593 33

	if (IS_LIVENGOOD_CU(sc)) {
		/*
		 * has a PHY - raise its reset line to make it operational
		 */
		u_int32_t tmp = READ_CSR(sc, WXREG_EXCT);
		tmp |= WXPHY_RESET_DIR4;
		WRITE_CSR(sc, WXREG_EXCT, tmp);
		DELAY(20*1000);

		tmp = READ_CSR(sc, WXREG_EXCT);
		tmp &= ~WXPHY_RESET4;
		WRITE_CSR(sc, WXREG_EXCT, tmp);
		DELAY(20*1000);

		tmp = READ_CSR(sc, WXREG_EXCT);
		tmp |= WXPHY_RESET4;
		WRITE_CSR(sc, WXREG_EXCT, tmp);
		DELAY(20*1000);
	} else if (IS_LIVENGOOD(sc)) {
		u_int16_t tew;

		/*
		 * Handle link control
		 */
		WRITE_CSR(sc, WXREG_DCR, sc->wx_dcr | WXDCR_LRST);
		DELAY(50 * 1000);

		wx_read_eeprom(sc, &tew, WX_EEPROM_CTLR2_OFF, 1);
		tew = (tew & WX_EEPROM_CTLR2_SWDPIO) << WX_EEPROM_EXT_SHIFT;
		WRITE_CSR(sc, WXREG_EXCT, (u_int32_t)tew);
	}

d1604 3
a1606 10

	if (IS_WISEMAN(sc)) {
		if (sc->wx_idnrev < WX_WISEMAN_2_1) {
			WRITE_CSR(sc, WXREG_FLOW_RCV_HI, 0);
			WRITE_CSR(sc, WXREG_FLOW_RCV_LO, 0);
			sc->wx_dcr &= ~(WXDCR_RFCE|WXDCR_TFCE);
		} else {
			WRITE_CSR(sc, WXREG_FLOW_RCV_HI, WX_RCV_FLOW_HI_DFLT);
			WRITE_CSR(sc, WXREG_FLOW_RCV_LO, WX_RCV_FLOW_LO_DFLT);
		}
d1608 2
a1609 2
		WRITE_CSR(sc, WXREG_FLOW_RCV_HI_LIVENGOOD, WX_RCV_FLOW_HI_DFLT);
		WRITE_CSR(sc, WXREG_FLOW_RCV_LO_LIVENGOOD, WX_RCV_FLOW_LO_DFLT);
d1611 1
a1611 4

	if (!IS_LIVENGOOD_CU(sc))
		WRITE_CSR(sc, WXREG_XMIT_CFGW, WXTXCW_DEFAULT);

d1615 9
a1623 15
	if (!IS_LIVENGOOD_CU(sc)) {
		/*
		 * The pin stuff is all FM from the Linux driver.
		 */
		if ((READ_CSR(sc, WXREG_DCR) & WXDCR_SWDPIN1) == 0) {
			for (i = 0; i < (WX_LINK_UP_TIMEOUT/10); i++) {
				DELAY(10 * 1000);
				if (READ_CSR(sc, WXREG_DSR) & WXDSR_LU) {
					sc->linkup = 1;
					break;
				}
			}
			if (sc->linkup == 0) {
				sc->ane_failed = 1;
				wx_check_link(sc);
a1624 5
			sc->ane_failed = 0;
		} else {
			printf("%s: SWDPIO1 did not clear- check for reversed "
				"or disconnected cable\n", sc->wx_name);
			/* but return okay anyway */
d1626 7
a1633 1

d1642 2
a1643 1
wx_stop(wx_softc_t *sc)
a1648 1
	DPRINTF(sc, ("%s: wx_stop\n", sc->wx_name));
d1652 1
a1652 1
	UNTIMEOUT(wx_watchdog, sc, sc);
d1693 1
a1693 1
 * Transmit Watchdog
d1696 2
a1697 1
wx_txwatchdog(struct ifnet *ifp)
d1709 2
a1710 1
wx_init(void *xsc)
d1718 1
a1718 1
	int i, bflags;
d1720 1
a1720 2
	DPRINTF(sc, ("%s: wx_init\n", sc->wx_name));
	WX_LOCK(sc);
a1733 2
		DPRINTF(sc, ("%s: wx_hw_initialize failed\n", sc->wx_name));
		WX_UNLOCK(sc);
a1752 1
		WX_UNLOCK(sc);
d1763 10
a1772 24
	if (IS_WISEMAN(sc)) {
		WRITE_CSR(sc, WXREG_TDBA_LO,
			vtophys((vm_offset_t)&sc->tdescriptors[0]));
		WRITE_CSR(sc, WXREG_TDBA_HI, 0);
		WRITE_CSR(sc, WXREG_TDLEN, WX_MAX_TDESC * sizeof (wxtd_t));
		WRITE_CSR(sc, WXREG_TDH, 0);
		WRITE_CSR(sc, WXREG_TDT, 0);
		WRITE_CSR(sc, WXREG_TQSA_HI, 0);
		WRITE_CSR(sc, WXREG_TQSA_LO, 0);
		WRITE_CSR(sc, WXREG_TIPG, WX_WISEMAN_TIPG_DFLT);
		WRITE_CSR(sc, WXREG_TIDV, sc->wx_txint_delay);
	} else {
		WRITE_CSR(sc, WXREG_TDBA_LO_LIVENGOOD,
			vtophys((vm_offset_t)&sc->tdescriptors[0]));
		WRITE_CSR(sc, WXREG_TDBA_HI_LIVENGOOD, 0);
		WRITE_CSR(sc, WXREG_TDLEN_LIVENGOOD,
			WX_MAX_TDESC * sizeof (wxtd_t));
		WRITE_CSR(sc, WXREG_TDH_LIVENGOOD, 0);
		WRITE_CSR(sc, WXREG_TDT_LIVENGOOD, 0);
		WRITE_CSR(sc, WXREG_TQSA_HI, 0);
		WRITE_CSR(sc, WXREG_TQSA_LO, 0);
		WRITE_CSR(sc, WXREG_TIPG, WX_LIVENGOOD_TIPG_DFLT);
		WRITE_CSR(sc, WXREG_TIDV_LIVENGOOD, sc->wx_txint_delay);
	}
d1782 7
a1788 18
	if (IS_WISEMAN(sc)) {
		WRITE_CSR(sc, WXREG_RDTR0, WXRDTR_FPD);
		WRITE_CSR(sc, WXREG_RDBA0_LO,
		    vtophys((vm_offset_t)&sc->rdescriptors[0]));
		WRITE_CSR(sc, WXREG_RDBA0_HI, 0);
		WRITE_CSR(sc, WXREG_RDLEN0, WX_MAX_RDESC * sizeof (wxrd_t));
		WRITE_CSR(sc, WXREG_RDH0, 0);
		WRITE_CSR(sc, WXREG_RDT0, (WX_MAX_RDESC - RXINCR));
	} else {
		WRITE_CSR(sc, WXREG_RDTR0_LIVENGOOD, WXRDTR_FPD);
		WRITE_CSR(sc, WXREG_RDBA0_LO_LIVENGOOD,
		    vtophys((vm_offset_t)&sc->rdescriptors[0]));
		WRITE_CSR(sc, WXREG_RDBA0_HI_LIVENGOOD, 0);
		WRITE_CSR(sc, WXREG_RDLEN0_LIVENGOOD,
		    WX_MAX_RDESC * sizeof (wxrd_t));
		WRITE_CSR(sc, WXREG_RDH0_LIVENGOOD, 0);
		WRITE_CSR(sc, WXREG_RDT0_LIVENGOOD, (WX_MAX_RDESC - RXINCR));
	}
d1797 1
d1819 6
a1824 11
	if (sc->wx_mii) {
		mii_mediachg(sc->wx_mii);
	} else {
		ifm = &sc->wx_media;
		i = ifm->ifm_media;
		ifm->ifm_media = ifm->ifm_cur->ifm_media;
		wx_ifmedia_upd(ifp);
		ifm->ifm_media = i;
	}

	WX_UNLOCK(sc);
d1829 1
a1829 1
	TIMEOUT(sc, wx_watchdog, sc, hz);
d1849 4
a1852 1
wx_rxdma_map(wx_softc_t *sc, rxpkt_t *rxpkt, struct mbuf *mb)
d1859 3
a1861 1
wx_get_rbuf(wx_softc_t *sc, rxpkt_t *rxpkt)
d1880 4
a1883 1
wx_ioctl(struct ifnet *ifp, IOCTL_CMD_TYPE command, caddr_t data)
d1887 1
a1887 1
	int error = 0;
d1889 1
a1889 1
	WX_LOCK(sc);
d1898 1
a1898 1
#ifdef	SIOCSIFMTU
d1949 1
a1949 9
		DPRINTF(sc, ("%s: ioctl SIOC[GS]IFMEDIA: command=%#lx\n",
		    sc->wx_name, command));
		if (sc->wx_mii) {
			error = ifmedia_ioctl(ifp, ifr,
			    &sc->wx_mii->mii_media, command);
		} else {
			error = ifmedia_ioctl(ifp, ifr, &sc->wx_media, command);
		}

d1956 1
a1956 1
	WX_UNLOCK(sc);
d1961 2
a1962 1
wx_ifmedia_upd(struct ifnet *ifp)
d1965 1
a1965 8
	struct ifmedia *ifm;

	DPRINTF(sc, ("%s: ifmedia_upd\n", sc->wx_name));

	if (sc->wx_mii) {
		mii_mediachg(sc->wx_mii);
		return 0;
	}
d1967 1
a1967 3
	ifm = &sc->wx_media;

	if (IFM_TYPE(ifm->ifm_media) != IFM_ETHER) {
a1968 2
	}

d1973 3
a1975 1
wx_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
a1976 1
	u_int32_t dsr;
a1978 12
	DPRINTF(sc, ("%s: ifmedia_sts: ", sc->wx_name));

	if (sc->wx_mii) {
		mii_pollstat(sc->wx_mii);
		ifmr->ifm_active = sc->wx_mii->mii_media_active;
		ifmr->ifm_status = sc->wx_mii->mii_media_status;
		DPRINTF(sc, ("active=%#x status=%#x\n",
		    ifmr->ifm_active, ifmr->ifm_status));
		return;
	}

	DPRINTF(sc, ("\n"));
d1985 2
a1986 19
	ifmr->ifm_status |= IFM_ACTIVE;
	dsr = READ_CSR(sc, WXREG_DSR);
	if (IS_LIVENGOOD(sc)) {
		if (dsr &  WXDSR_1000BT) {
			if (IS_LIVENGOOD_CU(sc)) {
				ifmr->ifm_status |= IFM_1000_TX;
			}
			else {
				ifmr->ifm_status |= IFM_1000_SX;
			}
		} else if (dsr & WXDSR_100BT) {
			ifmr->ifm_status |= IFM_100_FX;	/* ?? */
		} else {
			ifmr->ifm_status |= IFM_10_T;	/* ?? */
		}
	} else {
		ifmr->ifm_status |= IFM_1000_SX;
	}
	if (dsr & WXDSR_FD) {
a1987 166
	}
}


#define RAISE_CLOCK(sc, dcr)	\
		WRITE_CSR(sc, WXREG_DCR, (dcr) | WXPHY_MDC), DELAY(2)

#define LOWER_CLOCK(sc, dcr)	\
		WRITE_CSR(sc, WXREG_DCR, (dcr) & ~WXPHY_MDC), DELAY(2)

static u_int32_t
wx_mii_shift_in(wx_softc_t *sc)
{
	u_int32_t dcr, i;
	u_int32_t data = 0;

	dcr = READ_CSR(sc, WXREG_DCR);
	dcr &= ~(WXPHY_MDIO_DIR | WXPHY_MDIO);
	WRITE_CSR(sc, WXREG_DCR, dcr);
	RAISE_CLOCK(sc, dcr);
	LOWER_CLOCK(sc, dcr);

	for (i = 0; i < 16; i++) {
		data <<= 1;
		RAISE_CLOCK(sc, dcr);
		dcr = READ_CSR(sc, WXREG_DCR);

		if (dcr & WXPHY_MDIO)
			data |= 1;
		
		LOWER_CLOCK(sc, dcr);
	}

	RAISE_CLOCK(sc, dcr);
	LOWER_CLOCK(sc, dcr);
	return (data);
}

static void
wx_mii_shift_out(wx_softc_t *sc, u_int32_t data, u_int32_t count)
{
	u_int32_t dcr, mask;

	dcr = READ_CSR(sc, WXREG_DCR);
	dcr |= WXPHY_MDIO_DIR | WXPHY_MDC_DIR;

	for (mask = (1 << (count - 1)); mask; mask >>= 1) {
		if (data & mask)
			dcr |= WXPHY_MDIO;
		else
			dcr &= ~WXPHY_MDIO;

		WRITE_CSR(sc, WXREG_DCR, dcr);
		DELAY(2);
		RAISE_CLOCK(sc, dcr);
		LOWER_CLOCK(sc, dcr);
	}
}

static int
wx_miibus_readreg(void *arg, int phy, int reg)
{
	wx_softc_t *sc = WX_SOFTC_FROM_MII_ARG(arg);
	unsigned int data = 0;

	if (!IS_LIVENGOOD_CU(sc)) {
		return 0;
	}
	wx_mii_shift_out(sc, WXPHYC_PREAMBLE, WXPHYC_PREAMBLE_LEN);
	wx_mii_shift_out(sc, reg | (phy << 5) | (WXPHYC_READ << 10) |
	    (WXPHYC_SOF << 12), 14);
	data = wx_mii_shift_in(sc);
	return (data & WXMDIC_DATA_MASK);
}

static int
wx_miibus_writereg(void *arg, int phy, int reg, int data)
{
	wx_softc_t *sc = WX_SOFTC_FROM_MII_ARG(arg);
	if (!IS_LIVENGOOD_CU(sc)) {
		return 0;
	}
	wx_mii_shift_out(sc, WXPHYC_PREAMBLE, WXPHYC_PREAMBLE_LEN);
	wx_mii_shift_out(sc, (u_int32_t)data | (WXPHYC_TURNAROUND << 16) |
	    (reg << 18) | (phy << 23) | (WXPHYC_WRITE << 28) |
	    (WXPHYC_SOF << 30), 32);
	return (0);
}

static void
wx_miibus_statchg(void *arg)
{
	wx_softc_t *sc = WX_SOFTC_FROM_MII_ARG(arg);
	mii_data_t *mii = sc->wx_mii;
	u_int32_t dcr, tctl;

	if (mii == NULL)
		return;

	dcr = sc->wx_dcr;
	tctl = READ_CSR(sc, WXREG_TCTL);
	DPRINTF(sc, ("%s: statchg dcr=%#x tctl=%#x", sc->wx_name, dcr, tctl));

	dcr |= WXDCR_FRCSPD | WXDCR_FRCDPX | WXDCR_SLU;
	dcr &= ~(WXDCR_SPEED_MASK | WXDCR_ASDE /* | WXDCR_ILOS */);

	if (mii->mii_media_status & IFM_ACTIVE) {
		if (IFM_SUBTYPE(mii->mii_media_active) == IFM_NONE) {
			DPRINTF(sc, (" link-down\n"));
			sc->linkup = 0;
			return;
		}

		sc->linkup = 1;
	}

	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_TX) {
		DPRINTF(sc, (" 1000TX"));
		dcr |= WXDCR_1000BT;
	} else if (IFM_SUBTYPE(mii->mii_media_active) == IFM_100_TX) {
		DPRINTF(sc, (" 100TX"));
		dcr |= WXDCR_100BT;
	} else	/* assume IFM_10_TX */ {
		DPRINTF(sc, (" 10TX"));
		dcr |= WXDCR_10BT;
	}

	if (mii->mii_media_active & IFM_FDX) {
		DPRINTF(sc, ("-FD"));
		tctl = WXTCTL_CT(WX_COLLISION_THRESHOLD) |
		    WXTCTL_COLD(WX_FDX_COLLISION_DX) | WXTCTL_EN;
		dcr |= WXDCR_FD;
	} else {
		DPRINTF(sc, ("-HD"));
		tctl = WXTCTL_CT(WX_COLLISION_THRESHOLD) |
		    WXTCTL_COLD(WX_HDX_COLLISION_DX) | WXTCTL_EN;
		dcr &= ~WXDCR_FD;
	}

	/* FLAG0==rx-flow-control FLAG1==tx-flow-control */
	if (mii->mii_media_active & IFM_FLAG0) {
		dcr |= WXDCR_RFCE;
	} else {
		dcr &= ~WXDCR_RFCE;
	}

	if (mii->mii_media_active & IFM_FLAG1) {
		dcr |= WXDCR_TFCE;
	} else {
		dcr &= ~WXDCR_TFCE;
	}

	if (dcr & (WXDCR_RFCE|WXDCR_TFCE)) {
		WRITE_CSR(sc, WXREG_FCAL, FC_FRM_CONST_LO);
		WRITE_CSR(sc, WXREG_FCAH, FC_FRM_CONST_HI);
		WRITE_CSR(sc, WXREG_FCT, FC_TYP_CONST);
	} else {
		WRITE_CSR(sc, WXREG_FCAL, 0);
		WRITE_CSR(sc, WXREG_FCAH, 0);
		WRITE_CSR(sc, WXREG_FCT, 0);
	}

	DPRINTF(sc, (" dcr=%#x tctl=%#x\n", dcr, tctl));
	WRITE_CSR(sc, WXREG_TCTL, tctl);
	sc->wx_dcr = dcr;
	WRITE_CSR(sc, WXREG_DCR, dcr);
@


1.1.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: if_wx.c,v 1.1.2.2 2001/05/14 22:25:49 niklas Exp $ */
d229 1
a229 1
	    &sc->w.st, &sc->w.sh, NULL, NULL, 0)) {
d725 1
a725 2
	IFQ_SET_MAXLEN(&ifp->if_snd, WX_MAX_TDESC - 1);
	IFQ_SET_READY(&ifp->if_snd);
d1128 1
a1128 1
		IFQ_DEQUEUE(&ifp->if_snd, mb_head);
a1266 11
#ifdef ALTQ
			/*
			 * XXX when altq is enabled, we can't put the
			 * packet back to the queue.
			 * just give up this packet for now.
			 */
			if (ALTQ_IS_ENABLED(&ifp->if_snd)) {
				m_freem(mb_head);
				break;
			}
#endif
d1339 1
a1339 1
		if (IFQ_IS_EMPTY(&sc->wx_if.if_snd) == 0) {
d1614 1
a1614 1
#if defined(__FreeBSD__)
a1617 2
#elif defined(__OpenBSD__)
		ether_input_mbuf(ifp, mb);
@


1.1.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: if_wx.c,v 1.1.2.3 2001/07/04 10:42:32 niklas Exp $ */
d3 1
a3 1
 * Principal Author: Matthew Jacob <mjacob@@feral.com>
a39 6
 * Many bug fixes gratefully acknowledged from:
 *
 *	The folks at Sitara Networks
 */

/*
d53 4
d62 1
d64 3
d122 3
a124 5
/*
 * Until we do a bit more work, we can get no bigger than MCLBYTES
 */
#if	0
#define	WX_MAXMTU	(WX_MAX_PKT_SIZE_JUMBO - sizeof (struct ether_header))
d126 1
a126 1
#define	WX_MAXMTU	(MCLBYTES - sizeof (struct ether_header))
d139 2
d142 3
d178 1
d182 1
d220 5
d233 3
a239 3
        /*
         * Let the BIOS do it's job- but check for sanity.
         */
d241 3
a243 12
	switch ((data >> PCI_CACHELINE_SHIFT) & PCI_CACHELINE_MASK) {
	case 4:
	case 8:
	case 16:
	case 32:
		break;
	default:
		data &= ~(PCI_CACHELINE_MASK << PCI_CACHELINE_SHIFT);
		data |= (8 << PCI_CACHELINE_SHIFT);
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG, data);
		break;
	}
d246 1
d248 1
d252 4
d259 1
d264 5
a268 1
	if (pci_intr_map(pa, &ih)) {
d270 1
d274 1
d277 3
d281 3
d285 1
d291 3
d297 2
d312 1
d314 2
d317 5
d334 11
a344 10
	mii_data_t *mii = WX_MII_FROM_SOFTC(sc);
	ifmedia_init(&mii->mii_media, 0, wx_ifmedia_upd, wx_ifmedia_sts);
        mii->mii_ifp = &sc->wx_if;
	mii->mii_readreg = (mii_readreg_t) wx_miibus_readreg;
	mii->mii_writereg = (mii_writereg_t) wx_miibus_writereg;
	mii->mii_statchg = (mii_statchg_t) wx_miibus_statchg;
	mii_phy_probe(&sc->w.dev, mii, 0xffffffff);
	if (LIST_FIRST(&mii->mii_phys) == NULL) {
		ifmedia_add(&mii->mii_media, IFM_ETHER|IFM_NONE, 0, NULL);
		ifmedia_set(&mii->mii_media, IFM_ETHER|IFM_NONE);
d346 1
a346 1
		ifmedia_set(&mii->mii_media, IFM_ETHER|IFM_AUTO);
d380 1
d382 3
d427 1
a427 1
	 * XXX: drain TX queue
d440 1
d442 4
d536 338
d914 1
a918 2
		sc->wx_mii = 1;

d941 1
d943 1
d951 2
a952 1
		ifmedia_add(&sc->wx_media, IFM_ETHER|IFM_1000_SX, 0, NULL);
d1119 1
a1119 1
	u_int16_t widx = WX_MAX_TDESC, cidx, nactv;
d1124 2
a1125 2
	while (nactv < WX_MAX_TDESC - 1) {
		int ndesc, plen;
d1129 1
a1129 1
		IF_DEQUEUE(&ifp->if_snd, mb_head);
d1139 2
a1140 14
			if (mb_head->m_next == NULL) {
				mb_head->m_len = WX_MIN_RPKT_SIZE;
			} else {
				MGETHDR(m, M_DONTWAIT, MT_DATA);
				if (m == NULL) {
					m_freem(mb_head);
					break;
				}
				m_copydata(mb_head, 0, mb_head->m_pkthdr.len,
				    mtod(m, caddr_t));
				m->m_pkthdr.len = m->m_len = WX_MIN_RPKT_SIZE;
				bzero(mtod(m, char *) + mb_head->m_pkthdr.len,
				     WX_MIN_RPKT_SIZE - mb_head->m_pkthdr.len);
				sc->wx_xmitpullup++;
d1142 1
a1142 1
				mb_head = m;
d1144 8
d1165 1
a1165 1
		for (plen = ndesc = 0, m = mb_head; m != NULL; m = m->m_next) {
d1177 2
a1178 8
			 * This appears to be a bogus check the PRO1000T.
			 * I think they meant that the minimum packet size
			 * is in fact WX_MIN_XPKT_SIZE (all data loaded)
			 */
#if	0
			/*
			 * If this mbuf is too small for the chip's minimum,
			 * break out to cluster it.
d1180 1
a1180 1
			if (m->m_len < WX_MIN_XPKT_SIZE) {
a1183 1
#endif
a1198 1
			plen += m->m_len;
a1230 25
			/*
			 * Set up a delayed interrupt when this packet
			 * is sent and the descriptor written back.
			 * Additional packets completing will cause
			 * interrupt to be delayed further. Therefore,
			 * after the *last* packet is sent, after the delay
			 * period in TIDV, an interrupt will be generated
			 * which will cause us to garbage collect.
			 */
			td->cmd |= TXCMD_IDE|TXCMD_RPS;

			/*
			 * Don't xmit odd length packets.
			 * We're okay with bumping things
			 * up as long as our mbuf allocation
			 * is always larger than our MTU
			 * by a comfortable amount.
			 *
			 * Yes, it's a hole to run past the end
			 * of a packet.
			 */
			if (plen & 0x1) {
				sc->wx_oddpkt++;
				td->length++;
			}
d1244 6
a1249 1
#if	NBPFILTER > 0
a1252 2
			/* defer xmit until we've got them all */
			widx = cidx;
d1313 3
a1315 15
	if (widx < WX_MAX_TDESC) {
		if (IS_WISEMAN(sc)) {
			WRITE_CSR(sc, WXREG_TDT, widx);
		} else {
			WRITE_CSR(sc, WXREG_TDT_LIVENGOOD, widx);
		}
	}

	if (sc->tactive == WX_MAX_TDESC - 1) {
		sc->wx_xmitgc++;
		wx_gc(sc);
		if (sc->tactive >= WX_MAX_TDESC - 1) {
			sc->wx_xmitblocked++;
			ifp->if_flags |= IFF_OACTIVE;
		}
a1344 1
			sc->wx_linkintr++;
d1348 1
a1348 7
		if (sc->wx_icr & WXISR_TXDW) {
			sc->wx_txqe++;
			wx_gc(sc);
		}
#if	0
		if (sc->wx_icr & WXISR_TXQE) {
			sc->wx_txqe++;
d1351 1
a1351 2
#endif
		if (sc->wx_if.if_snd.ifq_head != NULL) {
d1371 4
a1374 4
		mii_data_t *mii = WX_MII_FROM_SOFTC(sc);
		mii_pollstat(mii);
		if (mii->mii_media_status & IFM_ACTIVE) {
			if (IFM_SUBTYPE(mii->mii_media_active) == IFM_NONE) {
d1428 1
a1428 1
		mii_pollstat(WX_MII_FROM_SOFTC(sc));
a1473 3
		/*
		 * XXX: DMA Flush descriptor
		 */
d1626 5
d1632 3
d1723 1
a1723 1
	if (sc->tactive < WX_MAX_TDESC - 1) {
d1736 5
d1747 2
a1748 12
	if (sc->wx_needreinit) {
		WX_UNLOCK(sc);
		if (wx_init(sc) == 0) {
			WX_LOCK(sc);
			sc->wx_needreinit = 0;
		} else {
			WX_LOCK(sc);
		}
	} else {
		wx_gc(sc);
		wx_check_link(sc);
	}
d1754 1
a1754 1
	TIMEOUT(sc, wx_watchdog, sc, hz);
a1764 1
	WX_DISABLE_INT(sc);
d1770 1
d1775 1
d1995 1
a1995 1
		sc->wx_needreinit = 1;
d2067 1
a2067 1
		WRITE_CSR(sc, WXREG_TIDV, 5000);
d2079 1
a2079 1
		WRITE_CSR(sc, WXREG_TIDV_LIVENGOOD, 5000);
d2099 1
a2099 4
		/*
		 * The delay should yield ~10us receive interrupt delay 
		 */
		WRITE_CSR(sc, WXREG_RDTR0_LIVENGOOD, WXRDTR_FPD | 0x40);
d2131 6
d2138 1
a2138 1
		mii_mediachg(WX_MII_FROM_SOFTC(sc));
d2147 1
a2147 6
	/*
	 * Mark that we're up and running...
	 */
	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;

a2153 1
	WX_UNLOCK(sc);
d2163 1
a2163 4
 * The Wiseman chip can have buffers be 256, 512, 1024 or 2048 bytes in size.
 * The LIVENGOOD chip can go higher (up to 16K), but what's the point as
 * we aren't doing non-MCLGET memory management.
 *
d2207 1
d2209 1
d2212 2
d2222 2
d2234 1
a2234 3
			if ((ifp->if_flags & IFF_RUNNING) == 0) {
				error = wx_init(sc);
			}
d2242 1
d2245 12
d2260 2
a2266 1
			mii_data_t *mii = WX_MII_FROM_SOFTC(sc);
d2268 1
a2268 1
			    &mii->mii_media, command);
d2274 1
d2292 1
a2292 1
		mii_mediachg(WX_MII_FROM_SOFTC(sc));
d2314 3
a2316 4
		mii_data_t *mii = WX_MII_FROM_SOFTC(sc);
		mii_pollstat(mii);
		ifmr->ifm_active = mii->mii_media_active;
		ifmr->ifm_status = mii->mii_media_status;
d2442 1
a2442 1
	mii_data_t *mii = WX_MII_FROM_SOFTC(sc);
@


1.1.2.5
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a278 1
	IFQ_SET_READY(&ifp->if_snd);
d743 1
a743 1
		IFQ_DEQUEUE(&ifp->if_snd, mb_head);
@


1.1.2.6
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/* $OpenBSD: if_wx.c,v 1.1.2.5 2002/03/28 15:35:57 niklas Exp $ */
@


