head	1.28;
access;
symbols
	OPENBSD_5_4:1.27.0.12
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.10
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.8
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.6
	OPENBSD_5_0:1.27.0.4
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.24.0.14
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.12
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.10
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.8
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.6
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.4
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.23.0.6
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.4
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.21.0.4
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.20
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.8
	OPENBSD_2_8:1.13.0.6
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.4
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.2
	SMP_BASE:1.13
	kame_19991208:1.13
	OPENBSD_2_6:1.11.0.8
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.6
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.4
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2013.10.28.12.33.32;	author mpi;	state dead;
branches;
next	1.27;

1.27
date	2010.09.20.07.40.38;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.13.14.24.47;	author jasper;	state Exp;
branches;
next	1.25;

1.25
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.24;

1.24
date	2005.09.11.18.17.08;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.12.06.35.11;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.29.23.06.55;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.09.03.14.18;	author todd;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.02.22.50.00;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.12.20.33.50;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	99.11.30.02.25.53;	author jason;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	99.11.23.04.49.30;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	98.01.07.11.03.28;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.11.28.23.28.06;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	96.10.04.19.31.30;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.06.17.14.02.38;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.05.26.00.27.43;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.10.12.41.26;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.25.19;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.18.23.47.58;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.02.20.04.36.16;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.06.45;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.39;	author deraadt;	state Exp;
branches;
next	;

1.13.2.1
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.13.2.5;

1.13.2.5
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	1.13.2.6;

1.13.2.6
date	2004.06.05.23.12.50;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.28
log
@tedu FDDI support and the 3 flavors the driver for DEC devices, even
miod@@ cannot find two boards using the same media.

With precious punctuation review from guenther@@, thanks!

ok deraadt@@, henning@@
@
text
@/*	$OpenBSD: if_fpa.c,v 1.27 2010/09/20 07:40:38 deraadt Exp $	*/
/*	$NetBSD: if_fpa.c,v 1.15 1996/10/21 22:56:40 thorpej Exp $	*/

/*-
 * Copyright (c) 1995, 1996 Matt Thomas <matt@@3am-software.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Id: if_fpa.c,v 1.8 1996/05/17 01:15:18 thomas Exp
 *
 */

/*
 * DEC PDQ FDDI Controller; code for BSD derived operating systems
 *
 *   This module supports the DEC DEFPA PCI FDDI Controller
 */


#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/if_dl.h>
#include <net/route.h>

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#endif
#include <net/if_fddi.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>
#include <dev/ic/pdqvar.h>
#include <dev/ic/pdqreg.h>

#define	DEFPA_LATENCY	0x88
#define	DEFPA_CBMA	(PCI_MAPREG_START + 0)	/* Config Base Memory Address */
#define	DEFPA_CBIO	(PCI_MAPREG_START + 4)	/* Config Base I/O Address */

int  pdq_pci_ifintr(void *);
int  pdq_pci_match(struct device *, void *, void *);
void pdq_pci_attach(struct device *, struct device *, void *aux);

int
pdq_pci_ifintr(arg)
	void *arg;
{
	pdq_softc_t *sc = (pdq_softc_t *)arg;
	(void) pdq_interrupt(sc->sc_pdq);
	return (1);
}

int
pdq_pci_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DEC &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_DEFPA)
		return (1);
	return (0);
}

void
pdq_pci_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	pdq_softc_t *sc = (pdq_softc_t *)self;
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	u_int32_t data;
	pci_intr_handle_t intrhandle;
	const char *intrstr;
	bus_size_t csrsize;

	data = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);
	if (PCI_LATTIMER(data) < DEFPA_LATENCY) {
		data &= ~(PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT);
		data |= (DEFPA_LATENCY & PCI_LATTIMER_MASK)
		    << PCI_LATTIMER_SHIFT;
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG, data);
	}

	bcopy(sc->sc_dev.dv_xname, sc->sc_if.if_xname, IFNAMSIZ);
	sc->sc_if.if_flags = 0;
	sc->sc_if.if_softc = sc;

	/*
	 * NOTE: sc_bc is an alias for sc_csrtag and sc_membase is an
	 * alias for sc_csrhandle.  sc_iobase is not used in this front-end.
	 */
#ifdef PDQ_IOMAPPED
	if (pci_mapreg_map(pa, DEFPA_CBIO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->sc_csrtag, &sc->sc_csrhandle, NULL, &csrsize, 0)) {
		printf(": can't map i/o space\n");
		return;
	}
#else
	if (pci_mapreg_map(pa, DEFPA_CBMA, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->sc_csrtag, &sc->sc_csrhandle, NULL, &csrsize, 0)) {
		printf(": can't map mem space\n");
		return;
	}
#endif

	if (pci_intr_map(pa, &intrhandle)) {
		printf(": couldn't map interrupt\n");
		bus_space_unmap(sc->sc_csrtag, sc->sc_csrhandle, csrsize);
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, intrhandle);
	sc->sc_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_NET,
	    pdq_pci_ifintr, sc, self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(sc->sc_csrtag, sc->sc_csrhandle, csrsize);
		return;
	}
	if (intrstr != NULL)
		printf(": %s\n", intrstr);

	sc->sc_pdq = pdq_initialize(sc->sc_csrtag, sc->sc_csrhandle,
	    sc->sc_if.if_xname, 0, (void *) sc, PDQ_DEFPA);
	if (sc->sc_pdq == NULL) {
		printf(": initialization failed\n");
		bus_space_unmap(sc->sc_csrtag, sc->sc_csrhandle, csrsize);
		return;
	}

	bcopy((caddr_t) sc->sc_pdq->pdq_hwaddr.lanaddr_bytes,
	    sc->sc_arpcom.ac_enaddr, 6);
	pdq_ifattach(sc, NULL);
}

struct cfattach fpa_ca = {
	sizeof(pdq_softc_t), pdq_pci_match, pdq_pci_attach
};

struct cfdriver fpa_cd = {
	NULL, "fpa", DV_IFNET
};
@


1.27
log
@Stop doing shutdown hooks in network drivers where possible.  We already
take all interfaces down, via their xxstop routines.  Claudio and I have
verified that none of the shutdown hooks do much extra beyond what xxstop
was already doing; it is largely a pile of junk.
ok claudio, some early comments by sthen; also read by matthew, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.26 2009/08/13 14:24:47 jasper Exp $	*/
@


1.26
log
@- consistify cfdriver for the ethernet drivers (0 -> NULL)

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.25 2009/03/29 21:53:52 sthen Exp $	*/
a172 6

	sc->sc_ats = shutdownhook_establish((void (*)(void *)) pdq_hwreset,
	    sc->sc_pdq);
	if (sc->sc_ats == NULL)
		printf("%s: warning: couldn't establish shutdown hook\n",
		    self->dv_xname);
@


1.25
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.24 2005/09/11 18:17:08 mickey Exp $	*/
d186 1
a186 1
	0, "fpa", DV_IFNET
@


1.24
log
@do not inline pci_mapreg_map() anymore as it is olrite now; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.23 2004/05/12 06:35:11 tedu Exp $	*/
d132 1
a132 1
		printf(": can't map I/O space!\n");
d138 1
a138 1
		printf(": can't map memory space!\n");
@


1.23
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.22 2003/12/29 23:06:55 brad Exp $	*/
a110 1
	bus_addr_t csrbase;
a111 1
	int cacheable = 0;
d130 3
a132 3
	sc->sc_csrtag = pa->pa_iot;
	if (pci_io_find(pa->pa_pc, pa->pa_tag, DEFPA_CBIO, &csrbase, &csrsize)){
		printf(": can't find I/O space!\n");
d136 3
a138 4
	sc->sc_csrtag = pa->pa_memt;
	if (pci_mem_find(pa->pa_pc, pa->pa_tag, DEFPA_CBMA, &csrbase, &csrsize,
	    &cacheable)) {
		printf(": can't find memory space!\n");
a142 6
	if (bus_space_map(sc->sc_csrtag, csrbase, csrsize, cacheable,
	    &sc->sc_csrhandle)) {
		printf(": can't map CSRs!\n");
		return;
	}

d145 1
d156 1
d166 1
@


1.22
log
@no vtophys(), don't need uvm_extern.h anymore.

tested on alpha, i386, macppc and sparc64.

ok millert@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.21 2002/11/19 18:40:17 jason Exp $	*/
a55 1
#include <net/bpfdesc.h>
@


1.21
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.20 2002/06/09 03:14:18 todd Exp $	*/
a63 2

#include <uvm/uvm_extern.h>
@


1.20
log
@a step towards consistancy; in general:
	'struct arpcom foo' -> 'struct arpcom sc_arpcom'
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.19 2002/06/02 22:50:00 deraadt Exp $	*/
d97 4
a100 5
	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_DEC)
		return (0);
	if (PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_DEC_DEFPA)
		return (0);
	return (1);
@


1.19
log
@withough -> without
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.18 2002/03/14 01:26:58 millert Exp $	*/
d181 1
a181 1
	    sc->sc_ac.ac_enaddr, 6);
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.17 2001/11/06 19:53:19 miod Exp $	*/
d14 1
a14 1
 *    derived from this software withough specific prior written permission
@


1.17
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.16 2001/09/11 20:05:25 miod Exp $	*/
d76 3
a78 3
int  pdq_pci_ifintr	__P((void *));
int  pdq_pci_match	__P((struct device *, void *, void *));
void pdq_pci_attach	__P((struct device *, struct device *, void *aux));
@


1.17.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.17 2001/11/06 19:53:19 miod Exp $	*/
d14 1
a14 1
 *    derived from this software without specific prior written permission
d76 3
a78 3
int  pdq_pci_ifintr(void *);
int  pdq_pci_match(struct device *, void *, void *);
void pdq_pci_attach(struct device *, struct device *, void *aux);
d181 1
a181 1
	    sc->sc_arpcom.ac_enaddr, 6);
@


1.17.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d97 5
a101 4
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DEC &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_DEFPA)
		return (1);
	return (0);
@


1.16
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.15 2001/08/25 10:13:29 art Exp $	*/
d65 1
a65 1
#include <vm/vm.h>
@


1.15
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.14 2001/08/12 20:33:50 mickey Exp $	*/
a65 1
#include <vm/vm_kern.h>
@


1.14
log
@absolutely no need to include vm_parm.h after vm.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.13 1999/11/30 02:25:53 jason Exp $	*/
d157 1
a157 2
	if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &intrhandle)) {
@


1.13
log
@KNF and cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.12 1999/11/23 04:49:30 jason Exp $	*/
a66 1
#include <vm/vm_param.h>
@


1.13.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.13 1999/11/30 02:25:53 jason Exp $	*/
d66 2
d158 2
a159 1
	if (pci_intr_map(pa, &intrhandle)) {
@


1.13.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 1
a65 1
#include <uvm/uvm_extern.h>
@


1.13.2.3
log
@Merge in -current from roughly a week ago
@
text
@d76 3
a78 3
int  pdq_pci_ifintr(void *);
int  pdq_pci_match(struct device *, void *, void *);
void pdq_pci_attach(struct device *, struct device *, void *aux);
@


1.13.2.4
log
@Sync the SMP branch with 3.3
@
text
@d14 1
a14 1
 *    derived from this software without specific prior written permission
d97 5
a101 4
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DEC &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_DEFPA)
		return (1);
	return (0);
d181 1
a181 1
	    sc->sc_arpcom.ac_enaddr, 6);
@


1.13.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d65 2
@


1.13.2.6
log
@Merge with the trunk
@
text
@d56 1
@


1.12
log
@pretty up kernel printf's
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.11 1998/01/07 11:03:28 deraadt Exp $	*/
a45 3
#if defined(__FreeBSD__)
#include <sys/devconf.h>
#elif defined(__bsdi__) || defined(__NetBSD__) || defined(__OpenBSD__)
a46 1
#endif
a62 3
#if defined(__FreeBSD__)
#include <netinet/if_fddi.h>
#else
a63 1
#endif
a68 17
#if defined(__FreeBSD__)
#include "fpa.h"
#include <pci/pcivar.h>
#include <i386/isa/icu.h>
#include <pci/pdqvar.h>
#include <pci/pdqreg.h>
#elif defined(__bsdi__)
#if BSDI_VERSION < 199401
#include <i386/isa/isavar.h>
#include <i386/isa/icu.h>
#define	DRQNONE		0
#define IRQSHARE	0
#endif
#include <i386/pci/pci.h>
#include <i386/pci/pdqvar.h>
#include <i386/pci/pdqreg.h>
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a72 7
#endif /* __NetBSD__ */


#define	DEC_VENDORID		0x1011
#define	DEFPA_CHIPID		0x000F
#define	PCI_VENDORID(x)		((x) & 0xFFFF)
#define	PCI_CHIPID(x)		(((x) >> 16) & 0xFFFF)
d75 2
d78 3
a80 21
#define	PCI_CFLT	0x0C	/* Configuration Latency */
#define	PCI_CBMA	0x10	/* Configuration Base Memory Address */
#define	PCI_CBIO	0x14	/* Configuration Base I/O Address */

#if defined(__FreeBSD__)
static pdq_softc_t *pdqs_pci[NFPA];
#define	PDQ_PCI_UNIT_TO_SOFTC(unit)	(pdqs_pci[unit])
#if BSD >= 199506
#define	pdq_pci_ifwatchdog		NULL
#endif

#elif defined(__bsdi__)
extern struct cfdriver fpacd;
#define	PDQ_PCI_UNIT_TO_SOFTC(unit)	((pdq_softc_t *)fpacd.cd_devs[unit])

#elif defined(__NetBSD__) || defined(__OpenBSD__)
extern struct cfattach fpa_ca;
extern struct cfdriver fpa_cd;
#define	PDQ_PCI_UNIT_TO_SOFTC(unit)	((pdq_softc_t *)fpa_cd.cd_devs[unit])
#define	pdq_pci_ifwatchdog		NULL
#endif
d82 3
a84 12
#ifndef pdq_pci_ifwatchdog
static ifnet_ret_t
pdq_pci_ifwatchdog(
    int unit)
{
    pdq_ifwatchdog(&PDQ_PCI_UNIT_TO_SOFTC(unit)->sc_if);
}
#endif

static int
pdq_pci_ifintr(
    void *arg)
d86 3
a88 116
    pdq_softc_t * const sc = (pdq_softc_t *) arg;
#ifdef __FreeBSD__
    return pdq_interrupt(sc->sc_pdq);
#elif defined(__bsdi__) || defined(__NetBSD__) || defined(__OpenBSD__)
    (void) pdq_interrupt(sc->sc_pdq);
    return 1;
#endif
}

#if defined(__FreeBSD__)
/*
 * This is the PCI configuration support.  Since the PDQ is available
 * on both EISA and PCI boards, one must be careful in how defines the
 * PDQ in the config file.
 */
static char *
pdq_pci_probe(
    pcici_t config_id,
    pcidi_t device_id)
{
    if (PCI_VENDORID(device_id) == DEC_VENDORID &&
	    PCI_CHIPID(device_id) == DEFPA_CHIPID)
	return "Digital DEFPA PCI FDDI Controller";
    return NULL;
}

static void
pdq_pci_attach(
    pcici_t config_id,
    int unit)
{
    pdq_softc_t *sc;
    vm_offset_t va_csrs, pa_csrs;
    pdq_uint32_t data;

    if (unit > NFPA) {
	printf("fpa%d: not configured; kernel is built for only %d device%s.\n",
	       unit, NFPA, NFPA == 1 ? "" : "s");
	return;
    }

    data = pci_conf_read(config_id, PCI_CFLT);
    if ((data & 0xFF00) < (DEFPA_LATENCY << 8)) {
	data &= ~0xFF00;
	data |= DEFPA_LATENCY << 8;
	pci_conf_write(config_id, PCI_CFLT, data);
    }

    sc = (pdq_softc_t *) malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT);
    if (sc == NULL)
	return;

    bzero(sc, sizeof(pdq_softc_t));	/* Zero out the softc*/
    if (!pci_map_mem(config_id, PCI_CBMA, &va_csrs, &pa_csrs)) {
	free((void *) sc, M_DEVBUF);
	return;
    }

    sc->sc_if.if_name = "fpa";
    sc->sc_if.if_unit = unit;
    sc->sc_membase = (pdq_bus_memaddr_t) va_csrs;
    sc->sc_pdq = pdq_initialize(PDQ_BUS_PCI, sc->sc_membase,
				sc->sc_if.if_name, sc->sc_if.if_unit,
				(void *) sc, PDQ_DEFPA);
    if (sc->sc_pdq == NULL) {
	free((void *) sc, M_DEVBUF);
	return;
    }
    bcopy((caddr_t) sc->sc_pdq->pdq_hwaddr.lanaddr_bytes, sc->sc_ac.ac_enaddr, 6);
    pdqs_pci[unit] = sc;
    pdq_ifattach(sc, pdq_pci_ifwatchdog);
    pci_map_int(config_id, pdq_pci_ifintr, (void*) sc, &net_imask);
}

static int
pdq_pci_shutdown(
    struct kern_devconf *kdc,
    int force)
{
    if (kdc->kdc_unit < NFPA)
	pdq_hwreset(PDQ_PCI_UNIT_TO_SOFTC(kdc->kdc_unit)->sc_pdq);
    (void) dev_detach(kdc);
    return 0;
}

static u_long pdq_pci_count;

struct pci_device fpadevice = {
    "fpa",
    pdq_pci_probe,
    pdq_pci_attach,
    &pdq_pci_count,
    pdq_pci_shutdown,
};

#ifdef DATA_SET
DATA_SET (pcidevice_set, fpadevice);
#endif
#elif defined(__bsdi__)

static int
pdq_pci_match(
    pci_devaddr_t *pa)
{
    int irq;
    int id;

    id = pci_inl(pa, PCI_VENDOR_ID);
    if (PCI_VENDORID(id) != DEC_VENDORID || PCI_CHIPID(id) != DEFPA_CHIPID)
	return 0;

    irq = pci_inl(pa, PCI_I_LINE) & 0xFF;
    if (irq == 0 || irq >= 16)
	return 0;

    return 1;
d92 12
a103 50
pdq_pci_probe(
    struct device *parent,
    struct cfdata *cf,
    void *aux)
{
    struct isa_attach_args *ia = (struct isa_attach_args *) aux;
    pdq_uint32_t irq, data;
    pci_devaddr_t *pa;

    pa = pci_scan(pdq_pci_match);
    if (pa == NULL)
	return 0;

    irq = (1 << (pci_inl(pa, PCI_I_LINE) & 0xFF));

    if (ia->ia_irq != IRQUNK && irq != ia->ia_irq) {
	printf("fpa%d: error: desired IRQ of %d does not match device's actual IRQ of %d\n",
	       cf->cf_unit,
	       ffs(ia->ia_irq) - 1, ffs(irq) - 1);
	return 0;
    }
    if (ia->ia_irq == IRQUNK) {
	(void) isa_irqalloc(irq);
	ia->ia_irq = irq;
    }

    /* PCI bus masters don't use host DMA channels */
    ia->ia_drq = DRQNONE;

    /* Get the memory base address; assume the BIOS set it up correctly */
    ia->ia_maddr = (caddr_t) (pci_inl(pa, PCI_CBMA) & ~7);
    pci_outl(pa, PCI_CBMA, 0xFFFFFFFF);
    ia->ia_msize = ((~pci_inl(pa, PCI_CBMA)) | 7) + 1;
    pci_outl(pa, PCI_CBMA, (int) ia->ia_maddr);

    /* Disable I/O space access */
    pci_outl(pa, PCI_COMMAND, pci_inl(pa, PCI_COMMAND) & ~1);
    ia->ia_iobase = 0;
    ia->ia_iosize = 0;

    /* Make sure the latency timer is what the DEFPA likes */
    data = pci_inl(pa, PCI_CFLT);
    if ((data & 0xFF00) < (DEFPA_LATENCY << 8)) {
	data &= ~0xFF00;
	data |= DEFPA_LATENCY << 8;
	pci_outl(pa, PCI_CFLT, data);
    }
    ia->ia_irq |= IRQSHARE;

    return 1;
d107 30
a136 94
pdq_pci_attach(
    struct device *parent,
    struct device *self,
    void *aux)
{
    pdq_softc_t *sc = (pdq_softc_t *) self;
    register struct isa_attach_args *ia = (struct isa_attach_args *) aux;
    register struct ifnet *ifp = &sc->sc_if;
    int i;

    sc->sc_if.if_unit = sc->sc_dev.dv_unit;
    sc->sc_if.if_name = "fpa";
    sc->sc_if.if_flags = 0;
    sc->sc_membase = (pdq_bus_memaddr_t) mapphys((vm_offset_t)ia->ia_maddr, ia->ia_msize);

    sc->sc_pdq = pdq_initialize(PDQ_BUS_PCI, sc->sc_membase,
				sc->sc_if.if_nme, sc->sc_if.if_unit,
				(void *) sc, PDQ_DEFPA);
    if (sc->sc_pdq == NULL) {
	printf("fpa%d: initialization failed\n", sc->sc_if.if_unit);
	return;
    }

    bcopy((caddr_t) sc->sc_pdq->pdq_hwaddr.lanaddr_bytes, sc->sc_ac.ac_enaddr, 6);

    pdq_ifattach(sc, pdq_pci_ifwatchdog);

    isa_establish(&sc->sc_id, &sc->sc_dev);

    sc->sc_ih.ih_fun = pdq_pci_ifintr;
    sc->sc_ih.ih_arg = (void *)sc;
    intr_establish(ia->ia_irq, &sc->sc_ih, DV_NET);

    sc->sc_ats.func = (void (*)(void *)) pdq_hwreset;
    sc->sc_ats.arg = (void *) sc->sc_pdq;
    atshutdown(&sc->sc_ats, ATSH_ADD);
}

struct cfdriver fpacd = {
    0, "fpa", pdq_pci_probe, pdq_pci_attach,
#if _BSDI_VERSION >= 199401
    DV_IFNET,
#endif
    sizeof(pdq_softc_t)
};

#elif defined(__NetBSD__) || defined(__OpenBSD__)

static int
pdq_pci_match(
    struct device *parent,
    void *match,
    void *aux)
{
    struct pci_attach_args *pa = (struct pci_attach_args *) aux;

    if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_DEC)
	return 0;
    if (PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_DEC_DEFPA)
	return 0;

    return 1;
}

static void
pdq_pci_attach(
    struct device * const parent,
    struct device * const self,
    void * const aux)
{
    pdq_softc_t * const sc = (pdq_softc_t *) self;
    struct pci_attach_args * const pa = (struct pci_attach_args *) aux;
    pdq_uint32_t data;
    pci_intr_handle_t intrhandle;
    const char *intrstr;
    bus_addr_t csrbase;
    bus_size_t csrsize;
    int cacheable = 0;

    data = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CFLT);
    if ((data & 0xFF00) < (DEFPA_LATENCY << 8)) {
	data &= ~0xFF00;
	data |= DEFPA_LATENCY << 8;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_CFLT, data);
    }

    bcopy(sc->sc_dev.dv_xname, sc->sc_if.if_xname, IFNAMSIZ);
    sc->sc_if.if_flags = 0;
    sc->sc_if.if_softc = sc;

    /*
     * NOTE: sc_bc is an alias for sc_csrtag and sc_membase is an
     * alias for sc_csrhandle.  sc_iobase is not used in this front-end.
     */
d138 5
a142 5
    sc->sc_csrtag = pa->pa_iot;
    if (pci_io_find(pa->pa_pc, pa->pa_tag, PCI_CBIO, &csrbase, &csrsize)) {
	printf(": can't find I/O space!\n");
	return;
    }
d144 31
a174 7
    sc->sc_csrtag = pa->pa_memt;
    if (pci_mem_find(pa->pa_pc, pa->pa_tag, PCI_CBMA, &csrbase, &csrsize,
      &cacheable)) {
	printf(": can't find memory space!\n");
	return;
    }
#endif
d176 16
a191 38
    if (bus_space_map(sc->sc_csrtag, csrbase, csrsize, cacheable,
      &sc->sc_csrhandle)) {
	printf(": can't map CSRs!\n");
	return;
    }

    if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
		     pa->pa_intrline, &intrhandle)) {
	printf(": couldn't map interrupt\n");
	return;
    }
    intrstr = pci_intr_string(pa->pa_pc, intrhandle);
    sc->sc_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_NET, pdq_pci_ifintr,
	sc, self->dv_xname);
    if (sc->sc_ih == NULL) {
	printf(": couldn't establish interrupt");
	if (intrstr != NULL)
	    printf(" at %s", intrstr);
	printf("\n");
	return;
    }
    if (intrstr != NULL)
	printf(": %s\n", intrstr);

    sc->sc_pdq = pdq_initialize(sc->sc_csrtag, sc->sc_csrhandle,
				sc->sc_if.if_xname, 0,
				(void *) sc, PDQ_DEFPA);
    if (sc->sc_pdq == NULL) {
	printf(": initialization failed\n");
	return;
    }

    bcopy((caddr_t) sc->sc_pdq->pdq_hwaddr.lanaddr_bytes, sc->sc_ac.ac_enaddr, 6);
    pdq_ifattach(sc, pdq_pci_ifwatchdog);

    sc->sc_ats = shutdownhook_establish((void (*)(void *)) pdq_hwreset, sc->sc_pdq);
    if (sc->sc_ats == NULL)
	printf("%s: warning: couldn't establish shutdown hook\n", self->dv_xname);
d195 1
a195 1
    sizeof(pdq_softc_t), pdq_pci_match, pdq_pci_attach
d199 1
a199 1
    0, "fpa", DV_IFNET
a200 2

#endif /* __NetBSD__ */
@


1.11
log
@now this is really pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.10 1996/11/28 23:28:06 niklas Exp $	*/
a429 11
    sc->sc_pdq = pdq_initialize(sc->sc_csrtag, sc->sc_csrhandle,
				sc->sc_if.if_xname, 0,
				(void *) sc, PDQ_DEFPA);
    if (sc->sc_pdq == NULL) {
	printf(": initialization failed\n");
	return;
    }

    bcopy((caddr_t) sc->sc_pdq->pdq_hwaddr.lanaddr_bytes, sc->sc_ac.ac_enaddr, 6);
    pdq_ifattach(sc, pdq_pci_ifwatchdog);

d445 13
a461 2
    if (intrstr != NULL)
	printf(": %s\n", intrstr);
@


1.10
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fpa.c,v 1.15 1996/10/21 22:56:40 thorpej Exp $	*/
d412 1
a412 1
	printf("\n%s: can't find I/O space!\n", sc->sc_dev.dv_xname);
d419 1
a419 1
	printf("\n%s: can't find memory space!\n", sc->sc_dev.dv_xname);
d426 1
a426 1
	printf("\n%s: can't map CSRs!\n", sc->sc_dev.dv_xname);
d434 1
a434 1
	printf("%s: initialization failed\n", sc->sc_dev.dv_xname);
d443 1
a443 1
	printf("%s: couldn't map interrupt\n", self->dv_xname);
d450 1
a450 1
	printf("%s: couldn't establish interrupt", self->dv_xname);
d461 1
a461 1
	printf("%s: interrupting at %s\n", self->dv_xname, intrstr);
@


1.9
log
@__OpenBSD__
@
text
@d1 2
a2 1
/*	$NetBSD: if_fpa.c,v 1.11 1996/05/20 15:53:02 thorpej Exp $	*/
d390 3
a392 7
#ifdef PDQ_IOMAPPED
    bus_io_addr_t iobase;
    bus_io_size_t iosize;
#else
    bus_mem_addr_t membase;
    bus_mem_size_t memsize;
#endif
a400 1
    sc->sc_bc = pa->pa_bc;
d405 4
d410 3
a412 3
    if (pci_io_find(pa->pa_pc, pa->pa_tag, PCI_CBIO, &iobase, &iosize)
	    || bus_io_map(pa->pa_bc, iobase, iosize, &sc->sc_iobase)){
        printf("\n%s: can't map I/O space!\n", sc->sc_dev.dv_xname);
d416 4
a419 3
    if (pci_mem_find(pa->pa_pc, pa->pa_tag, PCI_CBMA, &membase, &memsize, NULL)
	    || bus_mem_map(pa->pa_bc, membase, memsize, 0, &sc->sc_membase)) {
	printf("\n%s: can't map memory space!\n", sc->sc_dev.dv_xname);
d424 7
a430 1
    sc->sc_pdq = pdq_initialize(sc->sc_bc, sc->sc_membase,
@


1.8
log
@probe routine has to have a way to succeed; netbsd pr#2555; peter@@peter.noc.demon.net
@
text
@d47 1
a47 1
#elif defined(__bsdi__) || defined(__NetBSD__)
d92 1
a92 1
#elif defined(__NetBSD__)
d122 1
a122 1
#elif defined(__NetBSD__)
d145 1
a145 1
#elif defined(__bsdi__) || defined(__NetBSD__)
d360 1
a360 1
#elif defined(__NetBSD__)
@


1.7
log
@sync 0521
@
text
@d375 1
a375 1
    return 0;
@


1.6
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 1
a1 2
/*	$OpenBSD: if_fpa.c,v 1.4 1996/04/18 23:47:58 niklas Exp $	*/
/*	$NetBSD: if_fpa.c,v 1.8 1996/05/07 02:17:23 thorpej Exp $	*/
d4 1
a4 1
 * Copyright (c) 1995 Matt Thomas (thomas@@lkg.dec.com)
d26 1
a26 50
 * Id: if_fpa.c,v 1.2 1995/08/20 18:56:11 thomas Exp
 *
 * Log: if_fpa.c,v
 * Revision 1.2  1995/08/20  18:56:11  thomas
 * Misc. changes for NetBSD
 *
 * Revision 1.1  1995/08/16  22:57:28  thomas
 * Initial revision
 *
 * Revision 1.13  1995/08/04  21:54:56  thomas
 * Clean IRQ processing under BSD/OS.
 * A receive tweaks.  (print source of MAC CRC errors, etc.)
 *
 * Revision 1.12  1995/06/02  16:04:22  thomas
 * Use correct PCI defs for BSDI now that they have fixed them.
 * Increment the slot number 0x1000, not one! (*duh*)
 *
 * Revision 1.11  1995/04/21  13:23:55  thomas
 * Fix a few pub in the DEFPA BSDI support
 *
 * Revision 1.10  1995/04/20  21:46:42  thomas
 * Why???
 * ,
 *
 * Revision 1.9  1995/04/20  20:17:33  thomas
 * Add PCI support for BSD/OS.
 * Fix BSD/OS EISA support.
 * Set latency timer for DEFPA to recommended value if 0.
 *
 * Revision 1.8  1995/04/04  22:54:29  thomas
 * Fix DEFEA support
 *
 * Revision 1.7  1995/03/14  01:52:52  thomas
 * Update for new FreeBSD PCI Interrupt interface
 *
 * Revision 1.6  1995/03/10  17:06:59  thomas
 * Update for latest version of FreeBSD.
 * Compensate for the fast that the ifp will not be first thing
 * in softc on BSDI.
 *
 * Revision 1.5  1995/03/07  19:59:42  thomas
 * First pass at BSDI EISA support
 *
 * Revision 1.4  1995/03/06  17:06:03  thomas
 * Add transmit timeout support.
 * Add support DEFEA (untested).
 *
 * Revision 1.3  1995/03/03  13:48:35  thomas
 * more fixes
 *
a32 2
 * Written by Matt Thomas
 *
a37 1
#include <sys/systm.h>
d47 1
a47 1
#elif defined(__bsdi__) || defined(__NetBSD__) || defined(__OpenBSD__)
d80 1
a81 1
#include <pci/pdq_os.h>
d83 6
d90 1
d92 2
a93 3
#include <i386/pci/pdq_os.h>
#elif defined(__NetBSD__) || defined (__OpenBSD__)
#include <dev/pci/pcireg.h>
d95 1
d97 1
a97 2
#include <dev/ic/pdqvar.h>
#endif /* __NetBSD__ || __OpenBSD */
d109 1
a111 21
/*
 * This is the PCI configuration support.  Since the PDQ is available
 * on both EISA and PCI boards, one must be careful in how defines the
 * PDQ in the config file.
 */
static char *pdq_pci_probe (pcici_t config_id, pcidi_t device_id);
static void pdq_pci_attach(pcici_t config_id, int unit);
static int pdq_pci_shutdown(struct kern_devconf *, int);
static u_long pdq_pci_count;

struct pci_device fpadevice = {
    "fpa",
    pdq_pci_probe,
    pdq_pci_attach,
    &pdq_pci_count,
    pdq_pci_shutdown,
};

#ifdef DATA_SET
DATA_SET (pcidevice_set, fpadevice);
#endif
d114 3
a116 1
#endif /* __FreeBSD__ */
d118 1
a118 1
#if defined(__bsdi__)
a120 1
#endif
d122 1
a122 1
#if defined(__NetBSD__) || defined (__OpenBSD__)
d126 1
d129 1
a129 22
#if defined(__NetBSD__)
static ifnet_ret_t
pdq_pci_ifinit(
    struct ifnet *ifp)
{
    pdq_ifinit((pdq_softc_t *)(ifp->if_softc));
}

static ifnet_ret_t
pdq_pci_ifwatchdog(
    struct ifnet *ifp)
{
    pdq_ifwatchdog((pdq_softc_t *)(ifp->if_softc));
}
#else
static ifnet_ret_t 
pdq_pci_ifinit(
    int unit) 
{
    pdq_ifinit(PDQ_PCI_UNIT_TO_SOFTC(unit));
}

d134 1
a134 1
    pdq_ifwatchdog(PDQ_PCI_UNIT_TO_SOFTC(unit));
d145 1
a145 1
#elif defined(__bsdi__) || defined(__NetBSD__) || defined(__OpenBSD__)
d152 5
d184 1
a184 1
    if ((data & 0xFF00) == 0) {
d202 3
a204 1
    sc->sc_pdq = pdq_initialize((void *) va_csrs, "fpa", unit,
d212 1
a212 1
    pdq_ifattach(sc, pdq_pci_ifinit, pdq_pci_ifwatchdog);
d226 14
d282 3
a284 4
    if (ia->ia_irq == IRQUNK && (ia->ia_irq = isa_irqalloc(irq)) == 0) {
	printf("fpa%d: error: IRQ %d is already in use\n", cf->cf_unit,
	       ffs(irq) - 1);
	return 0;
d303 1
a303 1
    if ((data & 0xFF00) == 0) {
d308 1
d327 1
d329 3
a331 2
    sc->sc_pdq = pdq_initialize((void *) mapphys((vm_offset_t)ia->ia_maddr, ia->ia_msize), "fpa",
				sc->sc_if.if_unit, (void *) sc, PDQ_DEFPA);
d339 1
a339 1
    pdq_ifattach(sc, pdq_pci_ifinit, pdq_pci_ifwatchdog);
d345 1
a345 1
    intr_establish(ia->ia_irq, &sc->sc_ih, DV_NET, sc->sc_dv.dv_xname);
d353 5
a357 1
    0, "fpa", pdq_pci_probe, pdq_pci_attach, DV_IFNET, sizeof(pdq_softc_t)
d360 1
a360 1
#elif defined(__NetBSD__) || defined (__OpenBSD__)
d363 1
a363 1
pdq_pci_probe(
d370 3
a372 1
    if (PCI_VENDORID(pa->pa_id) != DEC_VENDORID)
a373 2
    if (PCI_CHIPID(pa->pa_id) == DEFPA_CHIPID)
	return 1;
a383 2
    vm_offset_t va_csrs, pa_csrs;
    pdq_uint32_t data;
d386 10
a395 1
    pci_chipset_tag_t pc = pa->pa_pc;
d397 2
a398 2
    data = pci_conf_read(pc, pa->pa_tag, PCI_CFLT);
    if ((data & 0xFF00) == 0) {
d401 1
a401 1
	pci_conf_write(pc, pa->pa_tag, PCI_CFLT, data);
d404 15
a418 1
    if (pci_map_mem(pa->pa_tag, PCI_CBMA, &va_csrs, &pa_csrs))
d420 2
d423 5
a427 7
    bcopy(sc->sc_dev.dv_xname, sc->sc_if.if_xname, IFNAMSIZ);
    sc->sc_if.if_softc = sc;
    sc->sc_if.if_flags = 0;
    sc->sc_pdq = pdq_initialize((void *) va_csrs,
        sc->sc_dev.dv_cfdata->cf_driver->cd_name, sc->sc_dev.dv_unit,
	(void *) sc, PDQ_DEFPA);
    if (sc->sc_pdq == NULL)
d429 1
a429 3
    bcopy((caddr_t) sc->sc_pdq->pdq_hwaddr.lanaddr_bytes, sc->sc_ac.ac_enaddr,
	6);
    pdq_ifattach(sc, pdq_pci_ifinit, pdq_pci_ifwatchdog);
d431 11
a441 1
    sc->sc_ih = pci_map_int(pa->pa_tag, IPL_NET, pdq_pci_ifintr, sc);
d443 4
a446 1
	printf("%s: error: couldn't map interrupt\n", sc->sc_dev.dv_xname);
d449 2
a450 2
#if 0
    sc->sc_ats = shutdownhook_establish(pdq_hwreset, sc);
d452 3
a454 3
	printf("%s: warning: couldn't establish shutdown hook\n",
	       sc->sc_dev.dv_xname);
#endif
d458 1
a458 1
    sizeof(pdq_softc_t), pdq_pci_probe, pdq_pci_attach
d464 2
a465 1
#endif /* __NetBSD__ || __OpenBSD__ */
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d2 1
a2 1
/*	$NetBSD: if_fpa.c,v 1.7 1996/03/17 00:55:30 thorpej Exp $	*/
d194 1
d197 15
a211 1
    int unit)
d222 1
d447 1
d449 1
a449 1
    data = pci_conf_read(pa->pa_tag, PCI_CFLT);
d453 1
a453 1
	pci_conf_write(pa->pa_tag, PCI_CFLT, data);
d459 2
a460 2
    sc->sc_if.if_name = "fpa";
    sc->sc_if.if_unit = sc->sc_dev.dv_unit;
d462 3
a464 2
    sc->sc_pdq = pdq_initialize((void *) va_csrs, sc->sc_if.if_name,
				sc->sc_if.if_unit, (void *) sc, PDQ_DEFPA);
d471 1
a471 2
    sc->sc_ih = pci_map_int(pa->pa_tag, IPL_NET, pdq_pci_ifintr, sc
	sc->sc_dev.dv_xname);
d473 1
a473 1
	printf("fpa%d: error: couldn't map interrupt\n",  sc->sc_if.if_unit);
d479 2
a480 2
	printf("fpa%d: warning: couldn't establish shutdown hook\n",
	       sc->sc_if.if_unit);
@


1.4
log
@NetBSD 960317 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d392 1
a392 1
    intr_establish(ia->ia_irq, &sc->sc_ih, DV_NET);
@


1.3
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 2
a2 1
/*	$NetBSD: if_fpa.c,v 1.2 1995/08/19 04:35:25 cgd Exp $	*/
d26 52
d100 1
a100 1
#elif defined(__bsdi__) || defined(__NetBSD__)
d139 2
a140 1
#elif defined(__NetBSD__)
d144 1
a144 1
#endif /* __NetBSD__ */
d183 1
a183 1
#if defined(__bsdi__) || defined(__NetBSD__)
d188 6
d215 1
a215 1
#elif defined(__bsdi__) || defined(__NetBSD__)
d403 1
a403 1
#elif defined(__NetBSD__)
d449 2
a450 1
    bcopy((caddr_t) sc->sc_pdq->pdq_hwaddr.lanaddr_bytes, sc->sc_ac.ac_enaddr, 6);
d453 2
a454 2
    sc->sc_ih = pci_map_int(pa->pa_tag, IPL_NET, pdq_pci_ifintr, sc,
			    sc->sc_dev.dv_xname);
d467 6
a472 2
struct cfdriver fpacd = {
    0, "fpa", pdq_pci_probe, pdq_pci_attach, DV_IFNET, sizeof(pdq_softc_t)
d474 1
a474 1
#endif /* __NetBSD__ */
@


1.2
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d392 2
a393 1
    sc->sc_ih = pci_map_int(pa->pa_tag, IPL_NET, pdq_pci_ifintr, sc);
@


1.1
log
@Initial revision
@
text
@d392 1
a392 1
    sc->sc_ih = pci_map_int(pa->pa_tag, PCI_IPL_NET, pdq_pci_ifintr, sc);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
