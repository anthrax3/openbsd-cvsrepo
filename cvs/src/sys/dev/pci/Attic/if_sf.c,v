head	1.41;
access;
symbols
	OPENBSD_4_0:1.40.0.2
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.17
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.4;
locks; strict;
comment	@ * @;


1.41
date	2006.12.06.20.07.52;	author martin;	state dead;
branches;
next	1.40;

1.40
date	2006.08.22.19.11.46;	author martin;	state Exp;
branches;
next	1.39;

1.39
date	2006.07.20.11.23.49;	author martin;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.11.23.14.41;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.28.00.04.24;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.25.22.41.45;	author djm;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.20.16.15.03;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.07.02.57.45;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.11.19.41.34;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.11.18.17.08;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2005.08.09.04.10.12;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2005.07.02.23.10.11;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.11.03.44.27;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2004.11.29.07.22.44;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.01.02.43.28;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.30.02.01.31;	author mcbride;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.26.19.00.35;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.09.21.52.17;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.29.17.19.17;	author avsm;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.29.13.23.12;	author avsm;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.15.06.31.24;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.15.20.45.31;	author nordin;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.12.20.03.49;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.27.06.34.48;	author kjc;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.24.20.26.59;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.20.19.39.44;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.03.05.59.17;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.16.17.08.08;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.02.19.23.54;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.01.22.49.57;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.15.02.28.14;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	99.12.08.00.38.07;	author aaron;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.12.08.00.29.26;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	99.12.08.00.25.54;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	99.11.03.02.45.08;	author aaron;	state Exp;
branches;
next	;

1.4.2.1
date	2000.02.20.11.57.04;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2000.03.02.07.04.39;	author niklas;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2001.05.14.22.25.46;	author niklas;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2001.07.04.10.42.18;	author niklas;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.4.2.7;

1.4.2.7
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.4.2.8;

1.4.2.8
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.4.2.9;

1.4.2.9
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.4.2.10;

1.4.2.10
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	1.4.2.11;

1.4.2.11
date	2004.06.05.23.12.50;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.41
log
@replace Adaptec AIC-6915 Starfire driver with the fully bus_dma(9)-able
driver from NetBSD

ok brad@@ reyk@@

additional testing Nick Nauwelaerts
@
text
@/*	$OpenBSD: if_sf.c,v 1.40 2006/08/22 19:11:46 martin Exp $ */
/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/pci/if_sf.c,v 1.23 2000/07/14 19:11:02 wpaul Exp $
 */

/*
 * Adaptec AIC-6915 "Starfire" PCI fast ethernet driver for FreeBSD.
 * Programming manual is available from:
 * http://download.adaptec.com/pdfs/user_guides/aic6915_pg.pdf.
 *
 * Written by Bill Paul <wpaul@@ctr.columbia.edu>
 * Department of Electical Engineering
 * Columbia University, New York City
 */

/*
 * The Adaptec AIC-6915 "Starfire" is a 64-bit 10/100 PCI ethernet
 * controller designed with flexibility and reducing CPU load in mind.
 * The Starfire offers high and low priority buffer queues, a
 * producer/consumer index mechanism and several different buffer
 * queue and completion queue descriptor types. Any one of a number
 * of different driver designs can be used, depending on system and
 * OS requirements. This driver makes use of type0 transmit frame
 * descriptors (since BSD fragments packets across an mbuf chain)
 * and two RX buffer queues prioritized on size (one queue for small
 * frames that will fit into a single mbuf, another with full size
 * mbuf clusters for everything else). The producer/consumer indexes
 * and completion queues are also used.
 *
 * One downside to the Starfire has to do with alignment: buffer
 * queues must be aligned on 256-byte boundaries, and receive buffers
 * must be aligned on longword boundaries. The receive buffer alignment
 * causes problems on the Alpha platform, where the packet payload
 * should be longword aligned. There is no simple way around this.
 *
 * For receive filtering, the Starfire offers 16 perfect filter slots
 * and a 512-bit hash table.
 *
 * The Starfire has no internal transceiver, relying instead on an
 * external MII-based transceiver. Accessing registers on external
 * PHYs is done through a special register map rather than with the
 * usual bitbang MDIO method.
 *
 * Accessing the registers on the Starfire is a little tricky. The
 * Starfire has a 512K internal register space. When programmed for
 * PCI memory mapped mode, the entire register space can be accessed
 * directly. However in I/O space mode, only 256 bytes are directly
 * mapped into PCI I/O space. The other registers can be accessed
 * indirectly using the SF_INDIRECTIO_ADDR and SF_INDIRECTIO_DATA
 * registers inside the 256-byte I/O window.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>

#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <uvm/uvm_extern.h>              /* for vtophys */

#include <sys/device.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#define SF_USEIOSPACE

#include <dev/pci/if_sfreg.h>

int sf_probe(struct device *, void *, void *);
void sf_attach(struct device *, struct device *, void *);
int sf_intr(void *);
void sf_shutdown(void *);
void sf_stats_update(void *);
void sf_rxeof(struct sf_softc *);
void sf_txeof(struct sf_softc *);
int sf_encap(struct sf_softc *, struct sf_tx_bufdesc_type0 *,
				struct mbuf *);
void sf_start(struct ifnet *);
int sf_ioctl(struct ifnet *, u_long, caddr_t);
void sf_init(void *);
void sf_stop(struct sf_softc *);
void sf_watchdog(struct ifnet *);
int sf_ifmedia_upd(struct ifnet *);
void sf_ifmedia_sts(struct ifnet *, struct ifmediareq *);
void sf_reset(struct sf_softc *);
int sf_init_rx_ring(struct sf_softc *);
void sf_init_tx_ring(struct sf_softc *);
int sf_newbuf(struct sf_softc *, struct sf_rx_bufdesc_type0 *,
				struct mbuf *);
void sf_setmulti(struct sf_softc *);
int sf_setperf(struct sf_softc *, int, caddr_t);
int sf_sethash(struct sf_softc *, caddr_t, int);
#ifdef notdef
int sf_setvlan(struct sf_softc *, int, u_int32_t);
#endif

u_int8_t sf_read_eeprom(struct sf_softc *, int);

int sf_miibus_readreg(struct device *, int, int);
void sf_miibus_writereg(struct device *, int, int, int);
void sf_miibus_statchg(struct device *);

u_int32_t csr_read_4(struct sf_softc *, int);
void csr_write_4(struct sf_softc *, int, u_int32_t);
void sf_txthresh_adjust(struct sf_softc *);

#define SF_SETBIT(sc, reg, x)	\
	csr_write_4(sc, reg, csr_read_4(sc, reg) | x)

#define SF_CLRBIT(sc, reg, x)				\
	csr_write_4(sc, reg, csr_read_4(sc, reg) & ~x)

u_int32_t csr_read_4(sc, reg)
	struct sf_softc		*sc;
	int			reg;
{
	u_int32_t		val;

#ifdef SF_USEIOSPACE
	CSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);
	val = CSR_READ_4(sc, SF_INDIRECTIO_DATA);
#else
	val = CSR_READ_4(sc, (reg + SF_RMAP_INTREG_BASE));
#endif

	return(val);
}

u_int8_t sf_read_eeprom(sc, reg)
	struct sf_softc		*sc;
	int			reg;
{
	u_int8_t		val;

	val = (csr_read_4(sc, SF_EEADDR_BASE +
	    (reg & 0xFFFFFFFC)) >> (8 * (reg & 3))) & 0xFF;

	return(val);
}

void csr_write_4(sc, reg, val)
	struct sf_softc		*sc;
	int			reg;
	u_int32_t		val;
{
#ifdef SF_USEIOSPACE
	CSR_WRITE_4(sc, SF_INDIRECTIO_ADDR, reg + SF_RMAP_INTREG_BASE);
	CSR_WRITE_4(sc, SF_INDIRECTIO_DATA, val);
#else
	CSR_WRITE_4(sc, (reg + SF_RMAP_INTREG_BASE), val);
#endif
	return;
}

/*
 * Copy the address 'mac' into the perfect RX filter entry at
 * offset 'idx.' The perfect filter only has 16 entries so do
 * some sanity tests.
 */
int sf_setperf(sc, idx, mac)
	struct sf_softc		*sc;
	int			idx;
	caddr_t			mac;
{
	u_int16_t		*p;

	if (idx < 0 || idx > SF_RXFILT_PERFECT_CNT)
		return(EINVAL);

	if (mac == NULL)
		return(EINVAL);

	p = (u_int16_t *)mac;

	csr_write_4(sc, SF_RXFILT_PERFECT_BASE +
	    (idx * SF_RXFILT_PERFECT_SKIP), htons(p[2]));
	csr_write_4(sc, SF_RXFILT_PERFECT_BASE +
	    (idx * SF_RXFILT_PERFECT_SKIP) + 4, htons(p[1]));
	csr_write_4(sc, SF_RXFILT_PERFECT_BASE +
	    (idx * SF_RXFILT_PERFECT_SKIP) + 8, htons(p[0]));

	return(0);
}

/*
 * Set the bit in the 512-bit hash table that corresponds to the
 * specified mac address 'mac.' If 'prio' is nonzero, update the
 * priority hash table instead of the filter hash table.
 */
int sf_sethash(sc, mac, prio)
	struct sf_softc		*sc;
	caddr_t			mac;
	int			prio;
{
	u_int32_t		h = 0;

	if (mac == NULL)
		return(EINVAL);

	h = (ether_crc32_be(mac, ETHER_ADDR_LEN) >> 23) & 0x1FF;

	if (prio) {
		SF_SETBIT(sc, SF_RXFILT_HASH_BASE + SF_RXFILT_HASH_PRIOOFF +
		    (SF_RXFILT_HASH_SKIP * (h >> 4)), (1 << (h & 0xF)));
	} else {
		SF_SETBIT(sc, SF_RXFILT_HASH_BASE + SF_RXFILT_HASH_ADDROFF +
		    (SF_RXFILT_HASH_SKIP * (h >> 4)), (1 << (h & 0xF)));
	}

	return(0);
}

#ifdef notdef
/*
 * Set a VLAN tag in the receive filter.
 */
int sf_setvlan(sc, idx, vlan)
	struct sf_softc		*sc;
	int			idx;
	u_int32_t		vlan;
{
	if (idx < 0 || idx >> SF_RXFILT_HASH_CNT)
		return(EINVAL);

	csr_write_4(sc, SF_RXFILT_HASH_BASE +
	    (idx * SF_RXFILT_HASH_SKIP) + SF_RXFILT_HASH_VLANOFF, vlan);

	return(0);
}
#endif

int sf_miibus_readreg(self, phy, reg)
	struct device		*self;
	int			phy, reg;
{
	struct sf_softc		*sc = (struct sf_softc *)self;
	int			i;
	u_int32_t		val = 0;

	for (i = 0; i < SF_TIMEOUT; i++) {
		val = csr_read_4(sc, SF_PHY_REG(phy, reg));
		if (val & SF_MII_DATAVALID)
			break;
	}

	if (i == SF_TIMEOUT)
		return(0);

	if ((val & 0x0000FFFF) == 0xFFFF)
		return(0);

	return(val & 0x0000FFFF);
}

void sf_miibus_writereg(self, phy, reg, val)
	struct device		*self;
	int phy, reg, val;
{
	struct sf_softc		*sc = (struct sf_softc *)self;
	int			i;
	int			busy;

	csr_write_4(sc, SF_PHY_REG(phy, reg), val);

	for (i = 0; i < SF_TIMEOUT; i++) {
		busy = csr_read_4(sc, SF_PHY_REG(phy, reg));
		if (!(busy & SF_MII_BUSY))
			break;
	}

	return;
}

void sf_miibus_statchg(self)
	struct device		*self;
{
	struct sf_softc		*sc = (struct sf_softc *)self;
	struct mii_data		*mii;

	mii = &sc->sc_mii;

	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX) {
		SF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_FULLDUPLEX);
		csr_write_4(sc, SF_BKTOBKIPG, SF_IPGT_FDX);
	} else {
		SF_CLRBIT(sc, SF_MACCFG_1, SF_MACCFG1_FULLDUPLEX);
		csr_write_4(sc, SF_BKTOBKIPG, SF_IPGT_HDX);
	}

	return;
}

void sf_setmulti(sc)
	struct sf_softc		*sc;
{
	struct ifnet		*ifp;
	int			i;
	struct arpcom		*ac = &sc->arpcom;
	struct ether_multi	*enm;
	struct ether_multistep	step;
	u_int8_t		dummy[] = { 0, 0, 0, 0, 0, 0 };

	ifp = &sc->arpcom.ac_if;

	/* First zot all the existing filters. */
	for (i = 1; i < SF_RXFILT_PERFECT_CNT; i++)
		sf_setperf(sc, i, (char *)&dummy);
	for (i = SF_RXFILT_HASH_BASE;
	    i < (SF_RXFILT_HASH_MAX + 1); i += 4)
		csr_write_4(sc, i, 0);
	SF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_ALLMULTI);

	/* Now program new ones. */
allmulti:
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
		SF_SETBIT(sc, SF_RXFILT, SF_RXFILT_ALLMULTI);
	} else {
		i = 1;
		/* First find the tail of the list. */
		ETHER_FIRST_MULTI(step, ac, enm);

		/* Now traverse the list backwards. */
		while (enm != NULL) {
			if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
			    ETHER_ADDR_LEN)) {
				ifp->if_flags |= IFF_ALLMULTI;
				goto allmulti;
			}

			/* if (enm->enm_addrlo->sa_family != AF_LINK)
				continue; */
			/*
			 * Program the first 15 multicast groups
			 * into the perfect filter. For all others,
			 * use the hash table.
			 */
			if (i < SF_RXFILT_PERFECT_CNT) {
				sf_setperf(sc, i, enm->enm_addrlo);
				i++;
				continue;
			}

			sf_sethash(sc, enm->enm_addrlo, 0);
			ETHER_NEXT_MULTI(step, enm);
		}
	}

	return;
}

/*
 * Set media options.
 */
int sf_ifmedia_upd(ifp)
	struct ifnet		*ifp;
{
	struct sf_softc		*sc;
	struct mii_data		*mii;

	sc = ifp->if_softc;
	mii = &sc->sc_mii;
	sc->sf_link = 0;
	if (mii->mii_instance) {
		struct mii_softc	*miisc;
		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
			mii_phy_reset(miisc);
	}
	mii_mediachg(mii);

	return(0);
}

/*
 * Report current media status.
 */
void sf_ifmedia_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
{
	struct sf_softc		*sc;
	struct mii_data		*mii;

	sc = ifp->if_softc;
	mii = &sc->sc_mii;

	mii_pollstat(mii);
	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;

	return;
}

int sf_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
{
	struct sf_softc		*sc = ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *) data;
	struct ifaddr		*ifa = (struct ifaddr *)data;
	struct mii_data		*mii;
	int			s, error = 0;

	s = splnet();

	if ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {
		splx(s);
		return error;
	}

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			sf_init(sc);
			arp_ifinit(&sc->arpcom, ifa);
			break;
		default:
			sf_init(sc);
			break;
		}
		break;
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->sf_if_flags & IFF_PROMISC)) {
				SF_SETBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->sf_if_flags & IFF_PROMISC) {
				SF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);
			} else if (!(ifp->if_flags & IFF_RUNNING))
				sf_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				sf_stop(sc);
		}
		sc->sf_if_flags = ifp->if_flags;
		error = 0;
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				sf_setmulti(sc);
			error = 0;
		}
		break;
	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		mii = &sc->sc_mii;
		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);
		break;
	default:
		error = ENOTTY;
		break;
	}

	splx(s);

	return(error);
}

void sf_reset(sc)
	struct sf_softc		*sc;
{
	int			i;

	csr_write_4(sc, SF_GEN_ETH_CTL, 0);
	SF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);
	DELAY(1000);
	SF_CLRBIT(sc, SF_MACCFG_1, SF_MACCFG1_SOFTRESET);

	SF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_RESET);

	for (i = 0; i < SF_TIMEOUT; i++) {
		DELAY(10);
		if (!(csr_read_4(sc, SF_PCI_DEVCFG) & SF_PCIDEVCFG_RESET))
			break;
	}

	if (i == SF_TIMEOUT)
		printf("%s: reset never completed!\n", sc->sc_dev.dv_xname);

	/* Wait a little while for the chip to get its brains in order. */
	DELAY(1000);
	return;
}

/*
 * Probe for an Adaptec AIC-6915 chip. Check the PCI vendor and device
 * IDs against our list and return a device name if we find a match.
 * We also check the subsystem ID so that we can identify exactly which
 * NIC has been found, if possible.
 */
int sf_probe(parent, match, aux)
	struct device		*parent;
	void			*match;
	void			*aux;
{
	struct pci_attach_args	*pa = (struct pci_attach_args *)aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ADP &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADP_AIC6915)
		return(1);

	return(0);
}

/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
void sf_attach(parent, self, aux)
	struct device		*parent, *self;
	void			*aux;
{
	int			i;
	const char		*intrstr = NULL;
	u_int32_t		command;
	struct sf_softc		*sc = (struct sf_softc *)self;
	struct pci_attach_args	*pa = aux;
	pci_chipset_tag_t	pc = pa->pa_pc;
	pci_intr_handle_t	ih;
	struct ifnet		*ifp;
	bus_size_t		size;

	/*
	 * Handle power management nonsense.
	 */
	command = pci_conf_read(pc, pa->pa_tag, SF_PCI_CAPID) & 0x000000FF;
	if (command == 0x01) {

		command = pci_conf_read(pc, pa->pa_tag, SF_PCI_PWRMGMTCTRL);
		if (command & SF_PSTATE_MASK) {
			u_int32_t		iobase, membase, irq;

			/* Save important PCI config data. */
			iobase = pci_conf_read(pc, pa->pa_tag, SF_PCI_LOIO);
			membase = pci_conf_read(pc, pa->pa_tag, SF_PCI_LOMEM);
			irq = pci_conf_read(pc, pa->pa_tag, SF_PCI_INTLINE);

			/* Reset the power state. */
			printf("%s: chip is in D%d power mode -- setting to D0\n",
				sc->sc_dev.dv_xname, command & SF_PSTATE_MASK);
			command &= 0xFFFFFFFC;
			pci_conf_write(pc, pa->pa_tag, SF_PCI_PWRMGMTCTRL, command);

			/* Restore PCI config data. */
			pci_conf_write(pc, pa->pa_tag, SF_PCI_LOIO, iobase);
			pci_conf_write(pc, pa->pa_tag, SF_PCI_LOMEM, membase);
			pci_conf_write(pc, pa->pa_tag, SF_PCI_INTLINE, irq);
		}
	}

	/*
	 * Map control/status registers.
	 */

#ifdef SF_USEIOSPACE
	if (pci_mapreg_map(pa, SF_PCI_LOIO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->sf_btag, &sc->sf_bhandle, NULL, &size, 0)) {
		printf(": can't map I/O space\n");
		return;
	}
#else
	if (pci_mapreg_map(pa, SF_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->sf_btag, &sc->sf_bhandle, NULL, &size, 0)){
		printf(": can't map mem space\n");
		return;
	}
#endif

	/* Allocate interrupt */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		goto fail_1;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, sf_intr, sc,
	    self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail_1;
	}
	printf(": %s", intrstr);

	/* Reset the adapter. */
	sf_reset(sc);

	/*
	 * Get station address from the EEPROM.
	 */
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		sc->arpcom.ac_enaddr[i] =
		    sf_read_eeprom(sc, SF_EE_NODEADDR + ETHER_ADDR_LEN - i);

	printf(", address %s\n", ether_sprintf(sc->arpcom.ac_enaddr));

	/* Allocate the descriptor queues. */
	sc->sf_ldata_ptr = malloc(sizeof(struct sf_list_data) + 8,
				M_DEVBUF, M_NOWAIT);
	if (sc->sf_ldata_ptr == NULL) {
		printf(": no memory for list buffers!\n");
		goto fail_2;
	}

	sc->sf_ldata = (struct sf_list_data *)sc->sf_ldata_ptr;
	bzero(sc->sf_ldata, sizeof(struct sf_list_data));

	ifp = &sc->arpcom.ac_if;
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = sf_ioctl;
	ifp->if_start = sf_start;
	ifp->if_watchdog = sf_watchdog;
	ifp->if_baudrate = 10000000;
	IFQ_SET_MAXLEN(&ifp->if_snd, SF_TX_DLIST_CNT - 1);
	IFQ_SET_READY(&ifp->if_snd);
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);

	/*
	 * Initialize our media structures and probe the MII.
	 */
	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = sf_miibus_readreg;
	sc->sc_mii.mii_writereg = sf_miibus_writereg;
	sc->sc_mii.mii_statchg = sf_miibus_statchg;
	ifmedia_init(&sc->sc_mii.mii_media, 0, sf_ifmedia_upd, sf_ifmedia_sts);
	mii_attach(self, &sc->sc_mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY,
	    0);
	if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE, 0, NULL);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);
	} else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

	shutdownhook_establish(sf_shutdown, sc);
	return;

fail_2:
	pci_intr_disestablish(pc, sc->sc_ih);

fail_1:
	bus_space_unmap(sc->sf_btag, sc->sf_bhandle, size);
}

int sf_init_rx_ring(sc)
	struct sf_softc		*sc;
{
	struct sf_list_data	*ld;
	int			i;

	ld = sc->sf_ldata;

	bzero((char *)ld->sf_rx_dlist_big,
	    sizeof(struct sf_rx_bufdesc_type0) * SF_RX_DLIST_CNT);
	bzero((char *)ld->sf_rx_clist,
	    sizeof(struct sf_rx_cmpdesc_type3) * SF_RX_CLIST_CNT);

	for (i = 0; i < SF_RX_DLIST_CNT; i++) {
		if (sf_newbuf(sc, &ld->sf_rx_dlist_big[i], NULL) == ENOBUFS)
			return(ENOBUFS);
	}

	return(0);
}

void sf_init_tx_ring(sc)
	struct sf_softc		*sc;
{
	struct sf_list_data	*ld;
	int			i;

	ld = sc->sf_ldata;

	bzero((char *)ld->sf_tx_dlist,
	    sizeof(struct sf_tx_bufdesc_type0) * SF_TX_DLIST_CNT);
	bzero((char *)ld->sf_tx_clist,
	    sizeof(struct sf_tx_cmpdesc_type0) * SF_TX_CLIST_CNT);

	for (i = 0; i < SF_TX_DLIST_CNT; i++)
		ld->sf_tx_dlist[i].sf_id = SF_TX_BUFDESC_ID;
	for (i = 0; i < SF_TX_CLIST_CNT; i++)
		ld->sf_tx_clist[i].sf_type = SF_TXCMPTYPE_TX;

	ld->sf_tx_dlist[SF_TX_DLIST_CNT - 1].sf_end = 1;
	sc->sf_tx_cnt = 0;

	return;
}

int sf_newbuf(sc, c, m)
	struct sf_softc		*sc;
	struct sf_rx_bufdesc_type0	*c;
	struct mbuf		*m;
{
	struct mbuf		*m_new = NULL;

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return(ENOBUFS);

		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			m_freem(m_new);
			return(ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
	} else {
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
	}

	m_adj(m_new, sizeof(u_int64_t));

	c->sf_mbuf = m_new;
	c->sf_addrlo = SF_RX_HOSTADDR(vtophys(mtod(m_new, vaddr_t)));
	c->sf_valid = 1;

	return(0);
}

/*
 * The starfire is programmed to use 'normal' mode for packet reception,
 * which means we use the consumer/producer model for both the buffer
 * descriptor queue and the completion descriptor queue. The only problem
 * with this is that it involves a lot of register accesses: we have to
 * read the RX completion consumer and producer indexes and the RX buffer
 * producer index, plus the RX completion consumer and RX buffer producer
 * indexes have to be updated. It would have been easier if Adaptec had
 * put each index in a separate register, especially given that the damn
 * NIC has a 512K register space.
 *
 * In spite of all the lovely features that Adaptec crammed into the 6915,
 * it is marred by one truly stupid design flaw, which is that receive
 * buffer addresses must be aligned on a longword boundary. This forces
 * the packet payload to be unaligned, which is suboptimal on the x86 and
 * completely unuseable on the Alpha. Our only recourse is to copy received
 * packets into properly aligned buffers before handing them off.
 */

void sf_rxeof(sc)
	struct sf_softc		*sc;
{
	struct mbuf		*m;
	struct ifnet		*ifp;
	struct sf_rx_bufdesc_type0	*desc;
	struct sf_rx_cmpdesc_type3	*cur_rx;
	u_int32_t		rxcons, rxprod;
	int			cmpprodidx, cmpconsidx, bufprodidx;

	ifp = &sc->arpcom.ac_if;

	rxcons = csr_read_4(sc, SF_CQ_CONSIDX);
	rxprod = csr_read_4(sc, SF_RXDQ_PTR_Q1);
	cmpprodidx = SF_IDX_LO(csr_read_4(sc, SF_CQ_PRODIDX));
	cmpconsidx = SF_IDX_LO(rxcons);
	bufprodidx = SF_IDX_LO(rxprod);

	while (cmpconsidx != cmpprodidx) {
		struct mbuf		*m0;

		cur_rx = &sc->sf_ldata->sf_rx_clist[cmpconsidx];
		desc = &sc->sf_ldata->sf_rx_dlist_big[cur_rx->sf_endidx];
		m = desc->sf_mbuf;
		SF_INC(cmpconsidx, SF_RX_CLIST_CNT);
		SF_INC(bufprodidx, SF_RX_DLIST_CNT);

		if (!(cur_rx->sf_status1 & SF_RXSTAT1_OK)) {
			ifp->if_ierrors++;
			sf_newbuf(sc, desc, m);
			continue;
		}

		m0 = m_devget(mtod(m, char *) - ETHER_ALIGN,
		    cur_rx->sf_len + ETHER_ALIGN, 0, ifp, NULL);
		sf_newbuf(sc, desc, m);
		if (m0 == NULL) {
			ifp->if_ierrors++;
			continue;
		}
		m_adj(m0, ETHER_ALIGN);
		m = m0;

		ifp->if_ipackets++;

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

		/* pass it on. */
		ether_input_mbuf(ifp, m);
	}

	csr_write_4(sc, SF_CQ_CONSIDX,
	    (rxcons & ~SF_CQ_CONSIDX_RXQ1) | cmpconsidx);
	csr_write_4(sc, SF_RXDQ_PTR_Q1,
	    (rxprod & ~SF_RXDQ_PRODIDX) | bufprodidx);

	return;
}

/*
 * Read the transmit status from the completion queue and release
 * mbufs. Note that the buffer descriptor index in the completion
 * descriptor is an offset from the start of the transmit buffer
 * descriptor list in bytes. This is important because the manual
 * gives the impression that it should match the producer/consumer
 * index, which is the offset in 8 byte blocks.
 */
void sf_txeof(sc)
	struct sf_softc		*sc;
{
	int			txcons, cmpprodidx, cmpconsidx;
	struct sf_tx_cmpdesc_type1 *cur_cmp;
	struct sf_tx_bufdesc_type0 *cur_tx;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	txcons = csr_read_4(sc, SF_CQ_CONSIDX);
	cmpprodidx = SF_IDX_HI(csr_read_4(sc, SF_CQ_PRODIDX));
	cmpconsidx = SF_IDX_HI(txcons);

	while (cmpconsidx != cmpprodidx) {
		cur_cmp = &sc->sf_ldata->sf_tx_clist[cmpconsidx];
		cur_tx = &sc->sf_ldata->sf_tx_dlist[cur_cmp->sf_index >> 7];

		if (cur_cmp->sf_txstat & SF_TXSTAT_TX_OK)
			ifp->if_opackets++;
		else {
			if (cur_cmp->sf_txstat & SF_TXSTAT_TX_UNDERRUN)
				sf_txthresh_adjust(sc);
			ifp->if_oerrors++;
		}

		sc->sf_tx_cnt--;
		if (cur_tx->sf_mbuf != NULL) {
			m_freem(cur_tx->sf_mbuf);
			cur_tx->sf_mbuf = NULL;
		} else
			break;
		SF_INC(cmpconsidx, SF_TX_CLIST_CNT);
	}

	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_OACTIVE;

	csr_write_4(sc, SF_CQ_CONSIDX,
	    (txcons & ~SF_CQ_CONSIDX_TXQ) |
	    ((cmpconsidx << 16) & 0xFFFF0000));

	return;
}

void
sf_txthresh_adjust(sc)
	struct sf_softc *sc;
{
	u_int32_t txfctl;
	u_int8_t txthresh;

	txfctl = csr_read_4(sc, SF_TX_FRAMCTL);
	txthresh = txfctl & SF_TXFRMCTL_TXTHRESH;
	if (txthresh < 0xFF) {
		txthresh++;
		txfctl &= ~SF_TXFRMCTL_TXTHRESH;
		txfctl |= txthresh;
#ifdef SF_DEBUG
		printf("%s: tx underrun, increasing tx threshold to %d bytes\n",
		    sc->sc_dev.dv_xname, txthresh * 4);
#endif
		csr_write_4(sc, SF_TX_FRAMCTL, txfctl);
	}

	return;
}

int sf_intr(arg)
	void			*arg;
{
	struct sf_softc		*sc;
	struct ifnet		*ifp;
	u_int32_t		status;
	int			claimed = 0;

	sc = arg;
	ifp = &sc->arpcom.ac_if;

	if (!(csr_read_4(sc, SF_ISR_SHADOW) & SF_ISR_PCIINT_ASSERTED))
		return claimed;

	/* Disable interrupts. */
	csr_write_4(sc, SF_IMR, 0x00000000);

	for (;;) {
		status = csr_read_4(sc, SF_ISR);
		if (status)
			csr_write_4(sc, SF_ISR, status);

		if (!(status & SF_INTRS))
			break;

		claimed = 1;

		if (status & SF_ISR_RXDQ1_DMADONE)
			sf_rxeof(sc);

		if (status & SF_ISR_TX_TXDONE ||
		    status & SF_ISR_TX_DMADONE ||
		    status & SF_ISR_TX_QUEUEDONE ||
		    status & SF_ISR_TX_LOFIFO)
			sf_txeof(sc);

		if (status & SF_ISR_TX_LOFIFO)
			sf_txthresh_adjust(sc);

		if (status & SF_ISR_ABNORMALINTR) {
			if (status & SF_ISR_STATSOFLOW) {
				timeout_del(&sc->sc_stats_tmo);
				sf_stats_update(sc);
			} else
				sf_init(sc);
		}
	}

	/* Re-enable interrupts. */
	csr_write_4(sc, SF_IMR, SF_INTRS);

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		sf_start(ifp);

	return claimed;
}

void sf_init(xsc)
	void			*xsc;
{
	struct sf_softc		*sc = xsc;
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	struct mii_data		*mii;
	int			i, s;

	s = splnet();

	mii = &sc->sc_mii;

	sf_stop(sc);
	sf_reset(sc);

	/* Init all the receive filter registers */
	for (i = SF_RXFILT_PERFECT_BASE;
	    i < (SF_RXFILT_HASH_MAX + 1); i += 4)
		csr_write_4(sc, i, 0);

	/* Empty stats counter registers. */
	for (i = 0; i < sizeof(struct sf_stats)/sizeof(u_int32_t); i++)
		csr_write_4(sc, SF_STATS_BASE +
		    (i + sizeof(u_int32_t)), 0);

	/* Init our MAC address */
	csr_write_4(sc, SF_PAR0, *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));
	csr_write_4(sc, SF_PAR1, *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));
	sf_setperf(sc, 0, (caddr_t)&sc->arpcom.ac_enaddr);

	if (sf_init_rx_ring(sc) == ENOBUFS) {
		printf("%s: initialization failed: no "
		    "memory for rx buffers\n", sc->sc_dev.dv_xname);
		splx(s);
		return;
	}

	sf_init_tx_ring(sc);

	csr_write_4(sc, SF_RXFILT, SF_PERFMODE_NORMAL|SF_HASHMODE_WITHVLAN);

	/* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC) {
		SF_SETBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);
	} else {
		SF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_PROMISC);
	}

	if (ifp->if_flags & IFF_BROADCAST) {
		SF_SETBIT(sc, SF_RXFILT, SF_RXFILT_BROAD);
	} else {
		SF_CLRBIT(sc, SF_RXFILT, SF_RXFILT_BROAD);
	}

	/*
	 * Load the multicast filter.
	 */
	sf_setmulti(sc);

	/* Init the completion queue indexes */
	csr_write_4(sc, SF_CQ_CONSIDX, 0);
	csr_write_4(sc, SF_CQ_PRODIDX, 0);

	/* Init the RX completion queue */
	csr_write_4(sc, SF_RXCQ_CTL_1,
	    vtophys((vaddr_t)sc->sf_ldata->sf_rx_clist) & SF_RXCQ_ADDR);
	SF_SETBIT(sc, SF_RXCQ_CTL_1, SF_RXCQTYPE_3);

	/* Init RX DMA control. */
	SF_SETBIT(sc, SF_RXDMA_CTL, SF_RXDMA_REPORTBADPKTS);

	/* Init the RX buffer descriptor queue. */
	csr_write_4(sc, SF_RXDQ_ADDR_Q1,
	    vtophys((vaddr_t)sc->sf_ldata->sf_rx_dlist_big));
	csr_write_4(sc, SF_RXDQ_CTL_1, (MCLBYTES << 16) | SF_DESCSPACE_16BYTES);
	csr_write_4(sc, SF_RXDQ_PTR_Q1, SF_RX_DLIST_CNT - 1);

	/* Init the TX completion queue */
	csr_write_4(sc, SF_TXCQ_CTL,
	    vtophys((vaddr_t)sc->sf_ldata->sf_tx_clist) & SF_RXCQ_ADDR);

	/* Init the TX buffer descriptor queue. */
	csr_write_4(sc, SF_TXDQ_ADDR_HIPRIO,
		vtophys((vaddr_t)sc->sf_ldata->sf_tx_dlist));
	SF_SETBIT(sc, SF_TX_FRAMCTL, SF_TXFRMCTL_CPLAFTERTX);
	csr_write_4(sc, SF_TXDQ_CTL,
	    SF_TXBUFDESC_TYPE0|SF_TXMINSPACE_128BYTES|SF_TXSKIPLEN_8BYTES);
	SF_SETBIT(sc, SF_TXDQ_CTL, SF_TXDQCTL_NODMACMP);

	/* Enable autopadding of short TX frames. */
	SF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_AUTOPAD);

	/* Enable interrupts. */
	csr_write_4(sc, SF_IMR, SF_INTRS);
	SF_SETBIT(sc, SF_PCI_DEVCFG, SF_PCIDEVCFG_INTR_ENB);

	/* Enable the RX and TX engines. */
	SF_SETBIT(sc, SF_GEN_ETH_CTL, SF_ETHCTL_RX_ENB|SF_ETHCTL_RXDMA_ENB);
	SF_SETBIT(sc, SF_GEN_ETH_CTL, SF_ETHCTL_TX_ENB|SF_ETHCTL_TXDMA_ENB);

	sf_ifmedia_upd(ifp);

	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;

	splx(s);

	timeout_set(&sc->sc_stats_tmo, sf_stats_update, sc);
	timeout_add(&sc->sc_stats_tmo, hz);

	return;
}

int sf_encap(sc, c, m_head)
	struct sf_softc		*sc;
	struct sf_tx_bufdesc_type0 *c;
	struct mbuf		*m_head;
{
	int			frag = 0;
	struct sf_frag		*f = NULL;
	struct mbuf		*m;

	m = m_head;

	for (m = m_head, frag = 0; m != NULL; m = m->m_next) {
		if (m->m_len != 0) {
			if (frag == SF_MAXFRAGS)
				break;
			f = &c->sf_frags[frag];
			if (frag == 0)
				f->sf_pktlen = m_head->m_pkthdr.len;
			f->sf_fraglen = m->m_len;
			f->sf_addr = vtophys(mtod(m, vaddr_t));
			frag++;
		}
	}

	if (m != NULL) {
		struct mbuf		*m_new = NULL;

		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL) {
			printf("%s: no memory for tx list\n",
			    sc->sc_dev.dv_xname);
			return(1);
		}

		if (m_head->m_pkthdr.len > MHLEN) {
			MCLGET(m_new, M_DONTWAIT);
			if (!(m_new->m_flags & M_EXT)) {
				m_freem(m_new);
				printf("%s: no memory for tx list\n",
				    sc->sc_dev.dv_xname);
				return(1);
			}
		}
		m_copydata(m_head, 0, m_head->m_pkthdr.len,
		    mtod(m_new, caddr_t));
		m_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;
		m_freem(m_head);
		m_head = m_new;
		f = &c->sf_frags[0];
		f->sf_fraglen = f->sf_pktlen = m_head->m_pkthdr.len;
		f->sf_addr = vtophys(mtod(m_head, vaddr_t));
		frag = 1;
	}

	c->sf_mbuf = m_head;
	c->sf_id = SF_TX_BUFDESC_ID;
	c->sf_fragcnt = frag;
	c->sf_intr = 1;
	c->sf_caltcp = 0;
	c->sf_crcen = 1;

	return(0);
}

void sf_start(ifp)
	struct ifnet		*ifp;
{
	struct sf_softc		*sc;
	struct sf_tx_bufdesc_type0 *cur_tx = NULL;
	struct mbuf		*m_head = NULL;
	int			i, txprod;

	sc = ifp->if_softc;

	if (!sc->sf_link && ifp->if_snd.ifq_len < 10)
		return;

	if (ifp->if_flags & IFF_OACTIVE)
		return;

	txprod = csr_read_4(sc, SF_TXDQ_PRODIDX);
	i = SF_IDX_HI(txprod) >> 4;

	if (sc->sf_ldata->sf_tx_dlist[i].sf_mbuf != NULL) {
		printf("%s: TX ring full, resetting\n", sc->sc_dev.dv_xname);
		sf_init(sc);
		txprod = csr_read_4(sc, SF_TXDQ_PRODIDX);
		i = SF_IDX_HI(txprod) >> 4;
	}

	while(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf == NULL) {
		if (sc->sf_tx_cnt >= (SF_TX_DLIST_CNT - 5)) {
			ifp->if_flags |= IFF_OACTIVE;
			cur_tx = NULL;
			break;
		}
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
		if (m_head == NULL)
			break;

		cur_tx = &sc->sf_ldata->sf_tx_dlist[i];
		if (sf_encap(sc, cur_tx, m_head)) {
			m_freem(m_head);
			continue;
		}

#if NBPFILTER > 0
		/*
		 * If there's a BPF listener, bounce a copy of this frame
		 * to him.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, cur_tx->sf_mbuf,
			    BPF_DIRECTION_OUT);
#endif

		SF_INC(i, SF_TX_DLIST_CNT);
		sc->sf_tx_cnt++;
		/*
		 * Don't let the TX DMA queue get too full.
		 */
		if (sc->sf_tx_cnt > 64)
			break;
	}

	if (cur_tx == NULL)
		return;

	/* Transmit */
	csr_write_4(sc, SF_TXDQ_PRODIDX,
	    (txprod & ~SF_TXDQ_PRODIDX_HIPRIO) |
	    ((i << 20) & 0xFFFF0000));

	ifp->if_timer = 5;

	return;
}

void sf_stop(sc)
	struct sf_softc		*sc;
{
	int			i;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	timeout_del(&sc->sc_stats_tmo);

	ifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);

	csr_write_4(sc, SF_GEN_ETH_CTL, 0);
	csr_write_4(sc, SF_CQ_CONSIDX, 0);
	csr_write_4(sc, SF_CQ_PRODIDX, 0);
	csr_write_4(sc, SF_RXDQ_ADDR_Q1, 0);
	csr_write_4(sc, SF_RXDQ_CTL_1, 0);
	csr_write_4(sc, SF_RXDQ_PTR_Q1, 0);
	csr_write_4(sc, SF_TXCQ_CTL, 0);
	csr_write_4(sc, SF_TXDQ_ADDR_HIPRIO, 0);
	csr_write_4(sc, SF_TXDQ_CTL, 0);
	sf_reset(sc);

	sc->sf_link = 0;

	for (i = 0; i < SF_RX_DLIST_CNT; i++) {
		if (sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf != NULL) {
			m_freem(sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf);
			sc->sf_ldata->sf_rx_dlist_big[i].sf_mbuf = NULL;
		}
	}

	for (i = 0; i < SF_TX_DLIST_CNT; i++) {
		if (sc->sf_ldata->sf_tx_dlist[i].sf_mbuf != NULL) {
			m_freem(sc->sf_ldata->sf_tx_dlist[i].sf_mbuf);
			sc->sf_ldata->sf_tx_dlist[i].sf_mbuf = NULL;
		}
	}

	return;
}

/*
 * Note: it is important that this function not be interrupted. We
 * use a two-stage register access scheme: if we are interrupted in
 * between setting the indirect address register and reading from the
 * indirect data register, the contents of the address register could
 * be changed out from under us.
 */     
void sf_stats_update(xsc)
	void			*xsc;
{
	struct sf_softc		*sc;
	struct ifnet		*ifp;
	struct mii_data		*mii;
	struct sf_stats		stats;
	u_int32_t		*ptr;
	int			i, s;

	s = splnet();

	sc = xsc;
	ifp = &sc->arpcom.ac_if;
	mii = &sc->sc_mii;

	ptr = (u_int32_t *)&stats;
	for (i = 0; i < sizeof(stats)/sizeof(u_int32_t); i++)
		ptr[i] = csr_read_4(sc, SF_STATS_BASE +
		    (i + sizeof(u_int32_t)));

	for (i = 0; i < sizeof(stats)/sizeof(u_int32_t); i++)
		csr_write_4(sc, SF_STATS_BASE +
		    (i + sizeof(u_int32_t)), 0);

	ifp->if_collisions += stats.sf_tx_single_colls +
	    stats.sf_tx_multi_colls + stats.sf_tx_excess_colls;

	mii_tick(mii);
	if (!sc->sf_link && mii->mii_media_status & IFM_ACTIVE &&
	    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
		sc->sf_link++;
		if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
			sf_start(ifp);
	}

	splx(s);

	timeout_add(&sc->sc_stats_tmo, hz);

	return;
}

void sf_watchdog(ifp)
	struct ifnet		*ifp;
{
	struct sf_softc		*sc;

	sc = ifp->if_softc;

	ifp->if_oerrors++;
	printf("%s: watchdog timeout\n", sc->sc_dev.dv_xname);

	sf_stop(sc);
	sf_reset(sc);
	sf_init(sc);

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		sf_start(ifp);

	return;
}

void sf_shutdown(v)
	void			*v;
{
	struct sf_softc		*sc = (struct sf_softc *)v;
	
	sf_stop(sc);
}

struct cfattach sf_ca = {
	sizeof(struct sf_softc), sf_probe, sf_attach
};

struct cfdriver sf_cd = {
	0, "sf", DV_IFNET
};

@


1.40
log
@use LIST_FOREACH; from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.39 2006/07/20 11:23:49 martin Exp $ */
@


1.39
log
@fix various ways of spelling 'access' wrong in comments
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.38 2006/07/11 23:14:41 brad Exp $ */
d423 1
a423 2
		for (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;
		    miisc = LIST_NEXT(miisc, mii_list))
@


1.38
log
@put the increasing tx threshold message under SF_DEBUG
instead of DIAGNOSTIC.

From Nick Nauwelaerts in PR 5176
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.37 2006/05/28 00:04:24 jason Exp $ */
d74 1
a74 1
 * Acesssing the registers on the Starfire is a little tricky. The
@


1.37
log
@unknown ioctl is ENOTTY not EINVAL
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.36 2006/03/25 22:41:45 djm Exp $ */
d951 1
a951 1
#ifdef DIAGNOSTIC
@


1.36
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.35 2006/03/20 16:15:03 brad Exp $ */
d524 1
a524 1
		error = EINVAL;
@


1.35
log
@de-register.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.34 2005/11/07 02:57:45 brad Exp $ */
d870 1
a870 1
			bpf_mtap(ifp->if_bpf, m);
d1243 2
a1244 1
			bpf_mtap(ifp->if_bpf, cur_tx->sf_mbuf);
@


1.34
log
@- splimp -> splnet
- remove spl's from attach
- removing redundant checks before pci_mapreg_map()
- fix dmesg printing
- de-allocate resources on failure to attach
- remove unused VLAN input code from vge(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.33 2005/09/11 19:41:34 mickey Exp $ */
d536 1
a536 1
	register int		i;
@


1.33
log
@oops. unused var
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.32 2005/09/11 18:17:08 mickey Exp $ */
d463 1
a463 1
	s = splimp();
d587 1
a587 1
	int			s, i;
d595 1
a595 3
	bus_size_t		iosize;

	s = splimp();
a627 1
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
a629 4
	if (!(command & PCI_COMMAND_IO_ENABLE)) {
		printf(": failed to enable I/O ports\n");
		goto fail;
	}
d631 1
a631 1
	    &sc->sf_btag, &sc->sf_bhandle, NULL, &iosize, 0)) {
d633 1
a633 1
		goto fail;
a635 4
	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf(": failed to enable memory mapping\n");
		goto fail;
	}
d637 1
a637 1
	    &sc->sf_btag, &sc->sf_bhandle, NULL, &iosize, 0)){
d639 1
a639 1
		goto fail;
d670 1
a670 1
	printf(" address %s\n", ether_sprintf(sc->arpcom.ac_enaddr));
d676 2
a677 2
		printf("%s: no memory for list buffers!\n", sc->sc_dev.dv_xname);
		goto fail_1;
d717 4
d723 1
a723 4
	bus_space_unmap(sc->sf_btag, sc->sf_bhandle, iosize);
fail:
	splx(s);
	return;
d1026 1
a1026 1
	s = splimp();
d1327 1
a1327 1
	s = splimp();
@


1.32
log
@do not inline pci_mapreg_map() anymore as it is olrite now; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.31 2005/08/09 04:10:12 mickey Exp $ */
a594 1
	bus_addr_t		iobase;
@


1.31
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.30 2005/07/02 23:10:11 brad Exp $ */
d638 2
a639 5
	if (pci_io_find(pc, pa->pa_tag, SF_PCI_LOIO, &iobase, &iosize)) {
		printf(": can't find I/O space\n");
		goto fail;
	}
	if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->sf_bhandle)) {
a642 1
	sc->sf_btag = pa->pa_iot;
d648 2
a649 5
	if (pci_mem_find(pc, pa->pa_tag, SF_PCI_LOMEM, &iobase, &iosize, NULL)){
		printf(": can't find mem space\n");
		goto fail;
	}
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->sf_bhandle)) {
a652 1
	sc->sf_btag = pa->pa_memt;
d658 1
a658 1
		goto fail;
d668 1
a668 1
		goto fail;
d689 1
a689 1
		goto fail;
d730 2
@


1.30
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.29 2005/05/11 03:44:27 brad Exp $ */
a630 4
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	    PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
@


1.29
log
@Do not call mii_pollstat() from within device tick routines; the status
information is updated by mii_tick().

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.28 2005/01/15 05:24:11 brad Exp $ */
d1299 2
a1326 2

	ifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);
@


1.28
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.27 2004/11/29 07:22:44 jsg Exp $ */
d1367 3
a1369 5
	if (!sc->sf_link) {
		mii_pollstat(mii);
		if (mii->mii_media_status & IFM_ACTIVE &&
		    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE)
			sc->sf_link++;
@


1.27
log
@From FreeBSD: Correct URL of the programming manual.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.26 2004/09/23 17:45:16 brad Exp $ */
d513 2
a514 1
			sf_setmulti(sc);
@


1.26
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.25 2004/06/01 02:43:28 tedu Exp $ */
d39 1
a39 1
 * ftp.adaptec.com:/pub/BBS/userguides/aic6915_pg.pdf.
@


1.25
log
@some revisions have issues sending lots of packets.
apply a workaround from freebsd.  pr3061 from nick nauwelaerts
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.24 2004/05/30 02:01:31 mcbride Exp $ */
a707 1
	ifp->if_mtu = ETHERMTU;
a709 1
	ifp->if_output = ether_output;
@


1.24
log
@Multicast fixups:
- remove bogus use of LLADDR
- scrap sf_calchash in favour of ether_crc32_be
- accept all multicast when we encounter a multicast range
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.23 2004/04/26 19:00:35 tedu Exp $ */
d163 1
a931 1
		SF_INC(cmpconsidx, SF_TX_CLIST_CNT);
d935 3
a937 1
		else
d939 1
d945 3
a947 1
		}
d960 23
d1013 4
a1016 1
		if (status & SF_ISR_TX_TXDONE)
d1019 3
d1182 2
a1183 1
			printf("%s: no memory for tx list", sc->sc_dev.dv_xname);
d1191 1
a1191 1
				printf("%s: no memory for tx list",
d1227 1
a1227 1
	if (!sc->sf_link)
d1236 7
d1244 5
d1270 4
a1273 1
		if (sc->sf_tx_cnt == (SF_TX_DLIST_CNT - 2))
@


1.23
log
@vaddr_t casts for vtophys, works on amd64.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.22 2004/04/09 21:52:17 henning Exp $ */
a155 1
u_int32_t sf_calchash(caddr_t);
a211 25
u_int32_t sf_calchash(addr)
	caddr_t			addr;
{
	u_int32_t		crc, carry;
	int			i, j;
	u_int8_t		c;

	/* Compute CRC for the address value. */
	crc = 0xFFFFFFFF; /* initial value */

	for (i = 0; i < 6; i++) {
		c = *(addr + i);
		for (j = 0; j < 8; j++) {
			carry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);
			crc <<= 1;
			c >>= 1;
			if (carry)
				crc = (crc ^ 0x04c11db6) | carry;
		}
	}

	/* return the filter bit position */
	return(crc >> 23 & 0x1FF);
}

d257 1
a257 1
	h = sf_calchash(mac);
d371 1
d381 6
d395 1
a395 2
				sf_setperf(sc, i,
			LLADDR((struct sockaddr_dl *)enm->enm_addrlo));
d400 1
a400 2
			sf_sethash(sc,
			    LLADDR((struct sockaddr_dl *)enm->enm_addrlo), 0);
@


1.22
log
@do not whine if we cannot get mbufs. the countless printfd makes the machine
crawl under mbuf starvation, making the situationmuch worse, and don't make
sense in the first place.
ok tdeval@@ millert@@ beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.21 2003/06/29 17:19:17 avsm Exp $ */
d840 1
a840 1
	c->sf_addrlo = SF_RX_HOSTADDR(vtophys(mtod(m_new, caddr_t)));
d1092 1
a1092 1
	    vtophys(sc->sf_ldata->sf_rx_clist) & SF_RXCQ_ADDR);
d1100 1
a1100 1
	    vtophys(sc->sf_ldata->sf_rx_dlist_big));
d1106 1
a1106 1
	    vtophys(sc->sf_ldata->sf_tx_clist) & SF_RXCQ_ADDR);
d1110 1
a1110 1
		vtophys(sc->sf_ldata->sf_tx_dlist));
d1189 1
a1189 1
		f->sf_addr = vtophys(mtod(m_head, caddr_t));
@


1.21
log
@nuke sf_unit; jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.20 2003/06/29 13:23:12 avsm Exp $ */
d822 1
a822 3
		if (m_new == NULL) {
			printf("%s: no memory for rx list -- "
			    "packet dropped!\n", sc->sc_dev.dv_xname);
a823 1
		}
a826 2
			printf("%s: no memory for rx list -- "
			    "packet dropped!\n", sc->sc_dev.dv_xname);
@


1.20
log
@bad format string; %s -> %d
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.19 2003/01/15 06:31:24 art Exp $ */
d571 1
a571 1
		printf("sf%d: reset never completed!\n", sc->sf_unit);
a617 1
	sc->sf_unit = sc->sc_dev.dv_unit;
d635 2
a636 2
			printf("sf%d: chip is in D%d power mode "
			"-- setting to D0\n", sc->sf_unit, command & SF_PSTATE_MASK);
d719 1
a719 1
		printf("sf%d: no memory for list buffers!\n", sc->sf_unit);
d823 2
a824 2
			printf("sf%d: no memory for rx list -- "
			    "packet dropped!\n", sc->sf_unit);
d830 2
a831 2
			printf("sf%d: no memory for rx list -- "
			    "packet dropped!\n", sc->sf_unit);
d1063 2
a1064 2
		printf("sf%d: initialization failed: no "
		    "memory for rx buffers\n", sc->sf_unit);
d1174 1
a1174 1
			printf("sf%d: no memory for tx list", sc->sf_unit);
d1182 2
a1183 2
				printf("sf%d: no memory for tx list",
				    sc->sf_unit);
d1368 1
a1368 1
	printf("sf%d: watchdog timeout\n", sc->sf_unit);
@


1.19
log
@Get rid of the remaining vm_offset_t in pci drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.18 2002/11/19 18:40:17 jason Exp $ */
d720 1
a720 1
		printf("%s: no memory for list buffers!\n", sc->sf_unit);
@


1.18
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.17 2002/03/14 01:26:59 millert Exp $ */
d1165 1
a1165 1
			f->sf_addr = vtophys(mtod(m, vm_offset_t));
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.16 2002/02/15 20:45:31 nordin Exp $ */
d591 2
a592 5
	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_ADP)
		return(0);

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_ADP_AIC6915:
a593 1
	}
@


1.16
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.15 2001/11/06 19:53:19 miod Exp $ */
d127 24
a150 24
int sf_probe		__P((struct device *, void *, void *));
void sf_attach		__P((struct device *, struct device *, void *));
int sf_intr		__P((void *));
void sf_shutdown	__P((void *));
void sf_stats_update	__P((void *));
void sf_rxeof		__P((struct sf_softc *));
void sf_txeof		__P((struct sf_softc *));
int sf_encap		__P((struct sf_softc *, struct sf_tx_bufdesc_type0 *,
				struct mbuf *));
void sf_start		__P((struct ifnet *));
int sf_ioctl		__P((struct ifnet *, u_long, caddr_t));
void sf_init		__P((void *));
void sf_stop		__P((struct sf_softc *));
void sf_watchdog	__P((struct ifnet *));
int sf_ifmedia_upd	__P((struct ifnet *));
void sf_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));
void sf_reset		__P((struct sf_softc *));
int sf_init_rx_ring	__P((struct sf_softc *));
void sf_init_tx_ring	__P((struct sf_softc *));
int sf_newbuf		__P((struct sf_softc *, struct sf_rx_bufdesc_type0 *,
				struct mbuf *));
void sf_setmulti	__P((struct sf_softc *));
int sf_setperf		__P((struct sf_softc *, int, caddr_t));
int sf_sethash		__P((struct sf_softc *, caddr_t, int));
d152 1
a152 1
int sf_setvlan		__P((struct sf_softc *, int, u_int32_t));
d155 2
a156 2
u_int8_t sf_read_eeprom	__P((struct sf_softc *, int));
u_int32_t sf_calchash	__P((caddr_t));
d158 3
a160 3
int sf_miibus_readreg	__P((struct device *, int, int));
void sf_miibus_writereg	__P((struct device *, int, int, int));
void sf_miibus_statchg	__P((struct device *));
d162 2
a163 2
u_int32_t csr_read_4	__P((struct sf_softc *, int));
void csr_write_4	__P((struct sf_softc *, int, u_int32_t));
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.14 2001/08/25 10:13:29 art Exp $ */
d547 1
a547 1
	(void)splx(s);
d1070 1
a1070 1
		(void)splx(s);
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.15 2001/11/06 19:53:19 miod Exp $ */
d127 24
a150 24
int sf_probe(struct device *, void *, void *);
void sf_attach(struct device *, struct device *, void *);
int sf_intr(void *);
void sf_shutdown(void *);
void sf_stats_update(void *);
void sf_rxeof(struct sf_softc *);
void sf_txeof(struct sf_softc *);
int sf_encap(struct sf_softc *, struct sf_tx_bufdesc_type0 *,
				struct mbuf *);
void sf_start(struct ifnet *);
int sf_ioctl(struct ifnet *, u_long, caddr_t);
void sf_init(void *);
void sf_stop(struct sf_softc *);
void sf_watchdog(struct ifnet *);
int sf_ifmedia_upd(struct ifnet *);
void sf_ifmedia_sts(struct ifnet *, struct ifmediareq *);
void sf_reset(struct sf_softc *);
int sf_init_rx_ring(struct sf_softc *);
void sf_init_tx_ring(struct sf_softc *);
int sf_newbuf(struct sf_softc *, struct sf_rx_bufdesc_type0 *,
				struct mbuf *);
void sf_setmulti(struct sf_softc *);
int sf_setperf(struct sf_softc *, int, caddr_t);
int sf_sethash(struct sf_softc *, caddr_t, int);
d152 1
a152 1
int sf_setvlan(struct sf_softc *, int, u_int32_t);
d155 2
a156 2
u_int8_t sf_read_eeprom(struct sf_softc *, int);
u_int32_t sf_calchash(caddr_t);
d158 3
a160 3
int sf_miibus_readreg(struct device *, int, int);
void sf_miibus_writereg(struct device *, int, int, int);
void sf_miibus_statchg(struct device *);
d162 2
a163 2
u_int32_t csr_read_4(struct sf_softc *, int);
void csr_write_4(struct sf_softc *, int, u_int32_t);
d547 1
a547 1
	splx(s);
d1070 1
a1070 1
		splx(s);
@


1.15.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d591 5
a595 2
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ADP &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADP_AIC6915)
d597 1
d1169 1
a1169 1
			f->sf_addr = vtophys(mtod(m, vaddr_t));
@


1.14
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.13 2001/08/12 20:03:49 mickey Exp $ */
d112 1
a112 1
#include <vm/vm.h>              /* for vtophys */
@


1.13
log
@remove redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.12 2001/06/27 06:34:48 kjc Exp $ */
d692 1
a692 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin, pa->pa_intrline,
	    &ih)) {
@


1.12
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.11 2001/06/24 20:26:59 fgsch Exp $ */
a112 1
#include <vm/pmap.h>            /* for vtophys */
@


1.11
log
@more ether_input_mbuf() conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.10 2001/02/20 19:39:44 mickey Exp $ */
d742 2
a743 1
	ifp->if_snd.ifq_maxlen = SF_TX_DLIST_CNT - 1;
d1033 1
a1033 1
	if (ifp->if_snd.ifq_head != NULL)
d1235 1
a1235 1
		IF_DEQUEUE(&ifp->if_snd, m_head);
d1356 1
a1356 1
		if (ifp->if_snd.ifq_head != NULL)
d1381 1
a1381 1
	if (ifp->if_snd.ifq_head != NULL)
@


1.10
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.9 2001/02/03 05:59:17 mickey Exp $ */
a878 1
	struct ether_header	*eh;
a918 1
		eh = mtod(m, struct ether_header *);
d926 2
a927 4
		/* Remove header from mbuf and pass it on. */
		m_adj(m, sizeof(struct ether_header));
		ether_input(ifp, eh, m);

@


1.9
log
@new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.8 2000/10/16 17:08:08 aaron Exp $ */
a766 4
#if NBPFILTER > 0
	bpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
		  sizeof(struct ether_header));
#endif
@


1.8
log
@Use mii_attach() directly instead of mii_phy_probe().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.7 2000/08/02 19:23:54 aaron Exp $ */
d94 1
d1030 1
a1030 1
				untimeout(sf_stats_update, sc);
d1151 1
a1151 1
	timeout(sf_stats_update, sc, hz);
d1153 2
a1154 1
	splx(s);
d1288 1
a1288 1
	untimeout(sf_stats_update, sc);
d1367 1
a1367 1
	timeout(sf_stats_update, sc, hz);
d1369 1
a1369 1
	splx(s);
@


1.7
log
@Put missing call to sf_setmulti() in sf_init() so the multicast filter will
be programmed correctly; from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.6 2000/03/01 22:49:57 aaron Exp $ */
d752 2
a753 1
	mii_phy_probe(self, &sc->sc_mii, 0xffffffff);
@


1.6
log
@If sf_encap() fails, we need to drop the packet. If sf_encap() reassembles
the mbufs into one big cluster, we need to pass the new pointer to
bpf_mtap(). From art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.5 2000/02/15 02:28:14 jason Exp $ */
d33 1
a33 1
 * $FreeBSD: src/sys/pci/if_sf.c,v 1.18 1999/12/05 20:02:44 wpaul Exp $
d1097 5
@


1.5
log
@make sure to call ether_{add,del}multi() as appropriate in xxx_ioctl()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.4 1999/12/08 00:38:07 aaron Exp $ */
d1239 4
a1242 1
		sf_encap(sc, cur_tx, m_head);
d1250 1
a1250 1
			bpf_mtap(ifp->if_bpf, m_head);
@


1.4
log
@Remove unused #define cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.3 1999/12/08 00:29:26 aaron Exp $ */
d524 12
a535 2
		sf_setmulti(sc);
		error = 0;
@


1.4.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.5 2000/02/15 02:28:14 jason Exp $ */
d524 2
a525 12
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			sf_setmulti(sc);
			error = 0;
		}
@


1.4.2.2
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d1239 1
a1239 4
		if (sf_encap(sc, cur_tx, m_head)) {
			m_freem(m_head);
			continue;
		}
d1247 1
a1247 1
			bpf_mtap(ifp->if_bpf, cur_tx->sf_mbuf);
@


1.4.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.10 2001/02/20 19:39:44 mickey Exp $ */
d33 1
a33 1
 * $FreeBSD: src/sys/pci/if_sf.c,v 1.23 2000/07/14 19:11:02 wpaul Exp $
a93 1
#include <sys/timeout.h>
d752 1
a752 2
	mii_attach(self, &sc->sc_mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY,
	    0);
d765 4
d1028 1
a1028 1
				timeout_del(&sc->sc_stats_tmo);
a1097 5
	/*
	 * Load the multicast filter.
	 */
	sf_setmulti(sc);

d1144 2
a1147 3
	timeout_set(&sc->sc_stats_tmo, sf_stats_update, sc);
	timeout_add(&sc->sc_stats_tmo, hz);

d1280 1
a1280 1
	timeout_del(&sc->sc_stats_tmo);
d1359 2
a1361 2

	timeout_add(&sc->sc_stats_tmo, hz);
@


1.4.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.4.2.3 2001/05/14 22:25:46 niklas Exp $ */
d742 1
a742 2
	IFQ_SET_MAXLEN(&ifp->if_snd, SF_TX_DLIST_CNT - 1);
	IFQ_SET_READY(&ifp->if_snd);
d879 1
d920 1
d928 4
a931 2
		/* pass it on. */
		ether_input_mbuf(ifp, m);
d1036 1
a1036 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
d1238 1
a1238 1
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
d1359 1
a1359 1
		if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
d1384 1
a1384 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
@


1.4.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.4.2.4 2001/07/04 10:42:18 niklas Exp $ */
d113 1
d693 2
a694 1
	if (pci_intr_map(pa, &ih)) {
@


1.4.2.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d112 1
a112 1
#include <uvm/uvm_extern.h>              /* for vtophys */
@


1.4.2.7
log
@Merge in trunk
@
text
@d547 1
a547 1
	splx(s);
d1070 1
a1070 1
		splx(s);
@


1.4.2.8
log
@Merge in -current from roughly a week ago
@
text
@d127 24
a150 24
int sf_probe(struct device *, void *, void *);
void sf_attach(struct device *, struct device *, void *);
int sf_intr(void *);
void sf_shutdown(void *);
void sf_stats_update(void *);
void sf_rxeof(struct sf_softc *);
void sf_txeof(struct sf_softc *);
int sf_encap(struct sf_softc *, struct sf_tx_bufdesc_type0 *,
				struct mbuf *);
void sf_start(struct ifnet *);
int sf_ioctl(struct ifnet *, u_long, caddr_t);
void sf_init(void *);
void sf_stop(struct sf_softc *);
void sf_watchdog(struct ifnet *);
int sf_ifmedia_upd(struct ifnet *);
void sf_ifmedia_sts(struct ifnet *, struct ifmediareq *);
void sf_reset(struct sf_softc *);
int sf_init_rx_ring(struct sf_softc *);
void sf_init_tx_ring(struct sf_softc *);
int sf_newbuf(struct sf_softc *, struct sf_rx_bufdesc_type0 *,
				struct mbuf *);
void sf_setmulti(struct sf_softc *);
int sf_setperf(struct sf_softc *, int, caddr_t);
int sf_sethash(struct sf_softc *, caddr_t, int);
d152 1
a152 1
int sf_setvlan(struct sf_softc *, int, u_int32_t);
d155 2
a156 2
u_int8_t sf_read_eeprom(struct sf_softc *, int);
u_int32_t sf_calchash(caddr_t);
d158 3
a160 3
int sf_miibus_readreg(struct device *, int, int);
void sf_miibus_writereg(struct device *, int, int, int);
void sf_miibus_statchg(struct device *);
d162 2
a163 2
u_int32_t csr_read_4(struct sf_softc *, int);
void csr_write_4(struct sf_softc *, int, u_int32_t);
@


1.4.2.9
log
@Sync the SMP branch with 3.3
@
text
@d591 5
a595 2
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ADP &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADP_AIC6915)
d597 1
d1169 1
a1169 1
			f->sf_addr = vtophys(mtod(m, vaddr_t));
@


1.4.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d571 1
a571 1
		printf("%s: reset never completed!\n", sc->sc_dev.dv_xname);
d618 1
d636 2
a637 2
			printf("%s: chip is in D%d power mode -- setting to D0\n",
				sc->sc_dev.dv_xname, command & SF_PSTATE_MASK);
d720 1
a720 1
		printf("%s: no memory for list buffers!\n", sc->sc_dev.dv_xname);
d824 2
a825 2
			printf("%s: no memory for rx list -- "
			    "packet dropped!\n", sc->sc_dev.dv_xname);
d831 2
a832 2
			printf("%s: no memory for rx list -- "
			    "packet dropped!\n", sc->sc_dev.dv_xname);
d1064 2
a1065 2
		printf("%s: initialization failed: no "
		    "memory for rx buffers\n", sc->sc_dev.dv_xname);
d1175 1
a1175 1
			printf("%s: no memory for tx list", sc->sc_dev.dv_xname);
d1183 2
a1184 2
				printf("%s: no memory for tx list",
				    sc->sc_dev.dv_xname);
d1369 1
a1369 1
	printf("%s: watchdog timeout\n", sc->sc_dev.dv_xname);
@


1.4.2.11
log
@Merge with the trunk
@
text
@d156 1
a163 1
void sf_txthresh_adjust(struct sf_softc *);
d213 25
d283 1
a283 1
	h = (ether_crc32_be(mac, ETHER_ADDR_LEN) >> 23) & 0x1FF;
a396 1
allmulti:
a405 6
			if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
			    ETHER_ADDR_LEN)) {
				ifp->if_flags |= IFF_ALLMULTI;
				goto allmulti;
			}

d414 2
a415 1
				sf_setperf(sc, i, enm->enm_addrlo);
d420 2
a421 1
			sf_sethash(sc, enm->enm_addrlo, 0);
d822 3
a824 1
		if (m_new == NULL)
d826 1
d830 2
d845 1
a845 1
	c->sf_addrlo = SF_RX_HOSTADDR(vtophys(mtod(m_new, vaddr_t)));
d957 1
d961 1
a961 3
		else {
			if (cur_cmp->sf_txstat & SF_TXSTAT_TX_UNDERRUN)
				sf_txthresh_adjust(sc);
a962 1
		}
d968 1
a968 3
		} else
			break;
		SF_INC(cmpconsidx, SF_TX_CLIST_CNT);
a980 23
void
sf_txthresh_adjust(sc)
	struct sf_softc *sc;
{
	u_int32_t txfctl;
	u_int8_t txthresh;

	txfctl = csr_read_4(sc, SF_TX_FRAMCTL);
	txthresh = txfctl & SF_TXFRMCTL_TXTHRESH;
	if (txthresh < 0xFF) {
		txthresh++;
		txfctl &= ~SF_TXFRMCTL_TXTHRESH;
		txfctl |= txthresh;
#ifdef DIAGNOSTIC
		printf("%s: tx underrun, increasing tx threshold to %d bytes\n",
		    sc->sc_dev.dv_xname, txthresh * 4);
#endif
		csr_write_4(sc, SF_TX_FRAMCTL, txfctl);
	}

	return;
}

d1011 1
a1011 4
		if (status & SF_ISR_TX_TXDONE ||
		    status & SF_ISR_TX_DMADONE ||
		    status & SF_ISR_TX_QUEUEDONE ||
		    status & SF_ISR_TX_LOFIFO)
a1013 3
		if (status & SF_ISR_TX_LOFIFO)
			sf_txthresh_adjust(sc);

d1097 1
a1097 1
	    vtophys((vaddr_t)sc->sf_ldata->sf_rx_clist) & SF_RXCQ_ADDR);
d1105 1
a1105 1
	    vtophys((vaddr_t)sc->sf_ldata->sf_rx_dlist_big));
d1111 1
a1111 1
	    vtophys((vaddr_t)sc->sf_ldata->sf_tx_clist) & SF_RXCQ_ADDR);
d1115 1
a1115 1
		vtophys((vaddr_t)sc->sf_ldata->sf_tx_dlist));
d1174 1
a1174 2
			printf("%s: no memory for tx list\n",
			    sc->sc_dev.dv_xname);
d1182 1
a1182 1
				printf("%s: no memory for tx list\n",
d1194 1
a1194 1
		f->sf_addr = vtophys(mtod(m_head, vaddr_t));
d1218 1
a1218 1
	if (!sc->sf_link && ifp->if_snd.ifq_len < 10)
a1226 7
	if (sc->sf_ldata->sf_tx_dlist[i].sf_mbuf != NULL) {
		printf("%s: TX ring full, resetting\n", sc->sc_dev.dv_xname);
		sf_init(sc);
		txprod = csr_read_4(sc, SF_TXDQ_PRODIDX);
		i = SF_IDX_HI(txprod) >> 4;
	}

a1227 5
		if (sc->sf_tx_cnt >= (SF_TX_DLIST_CNT - 5)) {
			ifp->if_flags |= IFF_OACTIVE;
			cur_tx = NULL;
			break;
		}
d1249 1
a1249 4
		/*
		 * Don't let the TX DMA queue get too full.
		 */
		if (sc->sf_tx_cnt > 64)
@


1.3
log
@Whoops; forgot to bump FreeBSD version numbers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.2 1999/12/08 00:25:54 aaron Exp $ */
a163 8

#ifdef SF_USEIOSPACE
#define SF_RES			SYS_RES_IOPORT
#define SF_RID			SF_PCI_LOIO
#else
#define SF_RES			SYS_RES_MEMORY
#define SF_RID			SF_PCI_LOMEM
#endif
@


1.2
log
@Sync with FreeBSD:
- Reset the PHY before selecting a mode.
- Program IPG register to match duplex setting in accordance with Adaptec
manual recommendations.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf.c,v 1.1 1999/11/03 02:45:08 aaron Exp $ */
d33 1
a33 1
 * $FreeBSD: src/sys/pci/if_sf.c,v 1.16 1999/09/26 18:35:30 wpaul Exp $
@


1.1
log
@Driver for Adaptec "StarFire" AIC6915-based Ethernet cards; from FreeBSD.
Thanks to jason@@ for lots of debugging help.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d375 1
d378 1
d448 7
d513 10
a522 1
			sf_init(sc);
d527 1
a1128 7
	/* Make sure the duplex mode is set correctly. */
	if ((mii->mii_media.ifm_media & IFM_GMASK) == IFM_FDX) {
		SF_SETBIT(sc, SF_MACCFG_1, SF_MACCFG1_FULLDUPLEX);
	} else {
		SF_CLRBIT(sc, SF_MACCFG_1, SF_MACCFG1_FULLDUPLEX);
	}       

d1137 1
a1137 1
	mii_mediachg(mii);
d1222 3
d1288 2
d1345 8
@

