head	1.27;
access;
symbols
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	UBC_SYNC_A:1.27
	UBC_SYNC_B:1.27
	SMP:1.24.0.2
	SMP_BASE:1.24
	kame_19991208:1.22
	OPENBSD_2_6:1.21.0.2
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.19.0.2
	OPENBSD_2_5_BASE:1.19
	OPENBSD_2_4:1.17.0.2
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7;
locks; strict;
comment	@ * @;


1.27
date	2000.04.18.18.44.29;	author jason;	state dead;
branches;
next	1.26;

1.26
date	2000.04.18.03.40.55;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2000.03.30.02.49.35;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2000.01.09.22.36.46;	author jason;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2000.01.08.05.54.44;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	99.11.11.16.23.19;	author provos;	state Exp;
branches;
next	1.21;

1.21
date	99.10.14.18.28.39;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	99.10.09.19.45.02;	author downsj;	state Exp;
branches;
next	1.19;

1.19
date	99.02.26.17.05.53;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	98.12.30.03.02.47;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	98.09.22.18.58.03;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	98.08.28.22.28.51;	author downsj;	state Exp;
branches;
next	1.15;

1.15
date	98.08.24.18.52.17;	author downsj;	state Exp;
branches;
next	1.14;

1.14
date	98.08.21.20.29.10;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	98.07.02.21.15.45;	author downsj;	state Exp;
branches;
next	1.12;

1.12
date	98.05.26.07.22.13;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.03.10.21.37.44;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.01.11.13.43.03;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.01.07.11.03.29;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.01.05.13.35.20;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.07.31.01.14.59;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.07.09.18.22.39;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.07.06.16.06.47;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.07.06.14.30.57;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	97.07.05.23.13.06;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.07.05.03.11.50;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.07.03.07.22.53;	author deraadt;	state Exp;
branches;
next	;

1.24.2.1
date	2001.05.14.22.25.44;	author niklas;	state dead;
branches;
next	;


desc
@@


1.27
log
@split fxp into bus independent and dependent (pci) parts (cardbus to come)
@
text
@/*	$OpenBSD: if_fxp.c,v 1.26 2000/04/18 03:40:55 jason Exp $	*/
/*	$NetBSD: if_fxp.c,v 1.2 1997/06/05 02:01:55 thorpej Exp $	*/

/*
 * Copyright (c) 1995, David Greenman
 * All rights reserved.
 *
 * Modifications to support NetBSD:
 * Copyright (c) 1997 Jason R. Thorpe.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice unmodified, this list of conditions, and the following
 *    disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	Id: if_fxp.c,v 1.55 1998/08/04 08:53:12 dg Exp
 */

/*
 * Intel EtherExpress Pro/100B PCI Fast Ethernet driver
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/syslog.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>
#include <net/if_types.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#endif

#ifdef IPX
#include <netipx/ipx.h>
#include <netipx/ipx_if.h>
#endif

#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

#if NBPFILTER > 0
#include <net/bpf.h>
#include <net/bpfdesc.h>
#endif

#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/device.h>

#include <netinet/if_ether.h>

#include <vm/vm.h>

#include <machine/cpu.h>
#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/mii/miivar.h>

#include <dev/pci/if_fxpreg.h>
#include <dev/pci/if_fxpvar.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#ifdef __alpha__		/* XXX */
/* XXX XXX NEED REAL DMA MAPPING SUPPORT XXX XXX */
#undef vtophys
#define	vtophys(va)	alpha_XXX_dmamap((vm_offset_t)(va))
#endif /* __alpha__ */

#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)

/*
 * NOTE!  On the Alpha, we have an alignment constraint.  The
 * card DMAs the packet immediately following the RFA.  However,
 * the first thing in the packet is a 14-byte Ethernet header.
 * This means that the packet is misaligned.  To compensate,
 * we actually offset the RFA 2 bytes into the cluster.  This
 * aligns the packet after the Ethernet header at a 32-bit
 * boundary.  HOWEVER!  This means that the RFA is misaligned!
 */
#define	RFA_ALIGNMENT_FUDGE	2

/*
 * Inline function to copy a 16-bit aligned 32-bit quantity.
 */
static __inline void fxp_lwcopy __P((volatile u_int32_t *,
	volatile u_int32_t *));
static __inline void
fxp_lwcopy(src, dst)
	volatile u_int32_t *src, *dst;
{
	volatile u_int16_t *a = (u_int16_t *)src;
	volatile u_int16_t *b = (u_int16_t *)dst;

	b[0] = a[0];
	b[1] = a[1];
}

/*
 * Template for default configuration parameters.
 * See struct fxp_cb_config for the bit definitions.
 */
static u_char fxp_cb_config_template[] = {
	0x0, 0x0,		/* cb_status */
	0x80, 0x2,		/* cb_command */
	0xff, 0xff, 0xff, 0xff,	/* link_addr */
	0x16,	/*  0 */
	0x8,	/*  1 */
	0x0,	/*  2 */
	0x0,	/*  3 */
	0x0,	/*  4 */
	0x80,	/*  5 */
	0xb2,	/*  6 */
	0x3,	/*  7 */
	0x1,	/*  8 */
	0x0,	/*  9 */
	0x26,	/* 10 */
	0x0,	/* 11 */
	0x60,	/* 12 */
	0x0,	/* 13 */
	0xf2,	/* 14 */
	0x48,	/* 15 */
	0x0,	/* 16 */
	0x40,	/* 17 */
	0xf3,	/* 18 */
	0x0,	/* 19 */
	0x3f,	/* 20 */
	0x5	/* 21 */
};

/* Supported media types. */
struct fxp_supported_media {
	const int	fsm_phy;	/* PHY type */
	const int	*fsm_media;	/* the media array */
	const int	fsm_nmedia;	/* the number of supported media */
	const int	fsm_defmedia;	/* default media for this PHY */
};

int fxp_mediachange		__P((struct ifnet *));
void fxp_mediastatus		__P((struct ifnet *, struct ifmediareq *));
static inline void fxp_scb_wait	__P((struct fxp_softc *));
int fxp_intr			__P((void *));
void fxp_start			__P((struct ifnet *));
int fxp_ioctl			__P((struct ifnet *, u_long, caddr_t));
void fxp_init			__P((void *));
void fxp_stop			__P((struct fxp_softc *, int));
void fxp_watchdog		__P((struct ifnet *));
int fxp_add_rfabuf		__P((struct fxp_softc *, struct mbuf *));
int fxp_mdi_read		__P((struct device *, int, int));
void fxp_mdi_write		__P((struct device *, int, int, int));
void fxp_autosize_eeprom	__P((struct fxp_softc *));
void fxp_statchg		__P((struct device *));
void fxp_read_eeprom		__P((struct fxp_softc *, u_int16_t *,
				    int, int));
int fxp_attach_common	__P((struct fxp_softc *, u_int8_t *));

void fxp_stats_update		__P((void *));
void fxp_mc_setup		__P((struct fxp_softc *));

/*
 * Set initial transmit threshold at 64 (512 bytes). This is
 * increased by 64 (512 bytes) at a time, to maximum of 192
 * (1536 bytes), if an underrun occurs.
 */
static int tx_threshold = 64;

/*
 * Number of transmit control blocks. This determines the number
 * of transmit buffers that can be chained in the CB list.
 * This must be a power of two.
 */
#define FXP_NTXCB	128

/*
 * Number of completed TX commands at which point an interrupt
 * will be generated to garbage collect the attached buffers.
 * Must be at least one less than FXP_NTXCB, and should be
 * enough less so that the transmitter doesn't becomes idle
 * during the buffer rundown (which would reduce performance).
 */
#define FXP_CXINT_THRESH 120

/*
 * TxCB list index mask. This is used to do list wrap-around.
 */
#define FXP_TXCB_MASK	(FXP_NTXCB - 1)

/*
 * Number of receive frame area buffers. These are large so chose
 * wisely.
 */
#define FXP_NRFABUFS	64

/*
 * Maximum number of seconds that the receiver can be idle before we
 * assume it's dead and attempt to reset it by reprogramming the
 * multicast filter. This is part of a work-around for a bug in the
 * NIC. See fxp_stats_update().
 */
#define FXP_MAX_RX_IDLE	15

/*
 * Wait for the previous command to be accepted (but not necessarily
 * completed).
 */
static inline void
fxp_scb_wait(sc)
	struct fxp_softc *sc;
{
	int i = 10000;

	while (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) && --i);
}

/*************************************************************
 * Operating system-specific autoconfiguration glue
 *************************************************************/

int fxp_match __P((struct device *, void *, void *));
void fxp_attach __P((struct device *, struct device *, void *));

void	fxp_shutdown __P((void *));
void	fxp_power __P((int, void *));

/* Compensate for lack of a generic ether_ioctl() */
int	fxp_ether_ioctl __P((struct ifnet *, u_long, caddr_t));
#define	ether_ioctl	fxp_ether_ioctl

struct cfattach fxp_ca = {
	sizeof(struct fxp_softc), fxp_match, fxp_attach
};

struct cfdriver fxp_cd = {
	NULL, "fxp", DV_IFNET
};

/*
 * Check if a device is an 82557.
 */
int
fxp_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_INTEL)
		return (0);

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_INTEL_82557:
	case PCI_PRODUCT_INTEL_82559:
		return (1);
	}

	return (0);
}

void
fxp_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct fxp_softc *sc = (struct fxp_softc *)self;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
	u_int8_t enaddr[6];
	struct ifnet *ifp;
	bus_space_tag_t iot = pa->pa_iot;
	bus_addr_t iobase;
	bus_size_t iosize;

	if (pci_io_find(pc, pa->pa_tag, FXP_PCI_IOBA, &iobase, &iosize)) {
		printf(": can't find i/o space\n");
		return;
	}

	if (bus_space_map(iot, iobase, iosize, 0, &sc->sc_sh)) {
		printf(": can't map i/o space\n");
		return;
	}
	sc->sc_st = iot;

	/*
	 * Allocate our interrupt.
	 */
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
		printf(": couldn't map interrupt\n");
		return;
	}

	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, fxp_intr, sc,
	    self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}

	/* Do generic parts of attach. */
	if (fxp_attach_common(sc, enaddr)) {
		/* Failed! */
		return;
	}


	ifp = &sc->arpcom.ac_if;
	bcopy(enaddr, sc->arpcom.ac_enaddr, sizeof(enaddr));
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = fxp_ioctl;
	ifp->if_start = fxp_start;
	ifp->if_watchdog = fxp_watchdog;

	printf(": %s, address %s\n", intrstr,
	    ether_sprintf(sc->arpcom.ac_enaddr));

	/*
	 * Initialize our media structures and probe the MII.
	 */
	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = fxp_mdi_read;
	sc->sc_mii.mii_writereg = fxp_mdi_write;
	sc->sc_mii.mii_statchg = fxp_statchg;
	ifmedia_init(&sc->sc_mii.mii_media, 0, fxp_mediachange,
	    fxp_mediastatus);
	mii_phy_probe(self, &sc->sc_mii, 0xffffffff);
	/* If no phy found, just use auto mode */
	if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL,
		    0, NULL);
		printf("%s: no phy found, using manual mode\n",
		    sc->sc_dev.dv_xname);
	}

	if (ifmedia_match(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL, 0))
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL);
	else if (ifmedia_match(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO, 0))
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);
	else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_10_T);

	/*
	 * Attach the interface.
	 */
	if_attach(ifp);
	/*
	 * Let the system queue as many packets as we have available
	 * TX descriptors.
	 */
	ifp->if_snd.ifq_maxlen = FXP_NTXCB - 1;
	ether_ifattach(ifp);
#if NBPFILTER > 0
	bpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
	    sizeof(struct ether_header));
#endif

	/*
	 * Add shutdown hook so that DMA is disabled prior to reboot. Not
	 * doing do could allow DMA to corrupt kernel memory during the
	 * reboot before the driver initializes.
	 */
	shutdownhook_establish(fxp_shutdown, sc);

	/*
	 * Add suspend hook, for similiar reasons..
	 */
	powerhook_establish(fxp_power, sc);
}

/*
 * Device shutdown routine. Called at system shutdown after sync. The
 * main purpose of this routine is to shut off receiver DMA so that
 * kernel memory doesn't get clobbered during warmboot.
 */
void
fxp_shutdown(sc)
	void *sc;
{
	fxp_stop((struct fxp_softc *) sc, 0);
}

/*
 * Power handler routine. Called when the system is transitioning
 * into/out of power save modes.  As with fxp_shutdown, the main
 * purpose of this routine is to shut off receiver DMA so it doesn't
 * clobber kernel memory at the wrong time.
 */
void
fxp_power(why, arg)
	int why;
	void *arg;
{
	struct fxp_softc *sc = arg;
	struct ifnet *ifp;
	int s;

	s = splnet();
	if (why != PWR_RESUME)
		fxp_stop(sc, 0);
	else {
		ifp = &sc->arpcom.ac_if;
		if (ifp->if_flags & IFF_UP)
			fxp_init(sc);
	}
	splx(s);
}

int
fxp_ether_ioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct ifaddr *ifa = (struct ifaddr *) data;
	struct fxp_softc *sc = ifp->if_softc;

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;

		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			fxp_init(sc);
			arp_ifinit(&sc->arpcom, ifa);
			break;
#endif
#ifdef NS
		case AF_NS:
		    {
			 register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			 if (ns_nullhost(*ina))
				ina->x_host = *(union ns_host *)
				    LLADDR(ifp->if_sadl);
			 else
				bcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),
				    ifp->if_addrlen);
			 /* Set new address. */
			 fxp_init(sc);
			 break;
		    }
#endif
		default:
			fxp_init(sc);
			break;
		}
		break;

	default:
		return (EINVAL);
	}

	return (0);
}

/*************************************************************
 * End of operating system-specific autoconfiguration glue
 *************************************************************/

/*
 * Do generic parts of attach.
 */
int
fxp_attach_common(sc, enaddr)
	struct fxp_softc *sc;
	u_int8_t *enaddr;
{
	u_int16_t data;
	int i;

	/*
	 * Reset to a stable state.
	 */
	CSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);
	DELAY(10);

	sc->cbl_base = malloc(sizeof(struct fxp_cb_tx) * FXP_NTXCB,
	    M_DEVBUF, M_NOWAIT);
	if (sc->cbl_base == NULL)
		goto fail;

	sc->fxp_stats = malloc(sizeof(struct fxp_stats), M_DEVBUF, M_NOWAIT);
	if (sc->fxp_stats == NULL)
		goto fail;
	bzero(sc->fxp_stats, sizeof(struct fxp_stats));

	sc->mcsp = malloc(sizeof(struct fxp_cb_mcs), M_DEVBUF, M_NOWAIT);
	if (sc->mcsp == NULL)
		goto fail;

	/*
	 * Pre-allocate our receive buffers.
	 */
	for (i = 0; i < FXP_NRFABUFS; i++) {
		if (fxp_add_rfabuf(sc, NULL) != 0) {
			goto fail;
		}
	}

	/*
	 * Find out how large of an SEEPROM we have.
	 */
	fxp_autosize_eeprom(sc);

	/*
	 * Get info about the primary PHY
	 */
	fxp_read_eeprom(sc, (u_int16_t *)&data, 6, 1);
	sc->phy_primary_addr = data & 0xff;
	sc->phy_primary_device = (data >> 8) & 0x3f;
	sc->phy_10Mbps_only = data >> 15;

	/*
	 * Read MAC address.
	 */
	fxp_read_eeprom(sc, (u_int16_t *)enaddr, 0, 3);
	return (0);

 fail:
	printf("%s: Failed to malloc memory\n", sc->sc_dev.dv_xname);
	if (sc->cbl_base)
		free(sc->cbl_base, M_DEVBUF);
	if (sc->fxp_stats)
		free(sc->fxp_stats, M_DEVBUF);
	if (sc->mcsp)
		free(sc->mcsp, M_DEVBUF);
	/* frees entire chain */
	if (sc->rfa_headm)
		m_freem(sc->rfa_headm);

	return (ENOMEM);
}

/*
 * From NetBSD:
 *
 * Figure out EEPROM size.
 *
 * 559's can have either 64-word or 256-word EEPROMs, the 558
 * datasheet only talks about 64-word EEPROMs, and the 557 datasheet
 * talks about the existance of 16 to 256 word EEPROMs.
 *
 * The only known sizes are 64 and 256, where the 256 version is used
 * by CardBus cards to store CIS information.
 *
 * The address is shifted in msb-to-lsb, and after the last
 * address-bit the EEPROM is supposed to output a `dummy zero' bit,
 * after which follows the actual data. We try to detect this zero, by
 * probing the data-out bit in the EEPROM control register just after
 * having shifted in a bit. If the bit is zero, we assume we've
 * shifted enough address bits. The data-out should be tri-state,
 * before this, which should translate to a logical one.
 *
 * Other ways to do this would be to try to read a register with known
 * contents with a varying number of address bits, but no such
 * register seem to be available. The high bits of register 10 are 01
 * on the 558 and 559, but apparently not on the 557.
 * 
 * The Linux driver computes a checksum on the EEPROM data, but the
 * value of this checksum is not very well documented.
 */
void
fxp_autosize_eeprom(sc)
	struct fxp_softc *sc;
{
	u_int16_t reg;
	int x;

	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);
	/*
	 * Shift in read opcode.
	 */
	for (x = 3; x > 0; x--) {
		if (FXP_EEPROM_OPC_READ & (1 << (x - 1))) {
			reg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;
		} else {
			reg = FXP_EEPROM_EECS;
		}
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,
		    reg | FXP_EEPROM_EESK);
		DELAY(1);
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);
		DELAY(1);
	}
	/*
	 * Shift in address.
	 * Wait for the dummy zero following a correct address shift.
	 */
	for (x = 1; x <= 8; x++) {
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,
			FXP_EEPROM_EECS | FXP_EEPROM_EESK);
		DELAY(1);
		if ((CSR_READ_2(sc, FXP_CSR_EEPROMCONTROL) & FXP_EEPROM_EEDO) == 0)
			break;
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);
		DELAY(1);
	}
	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);
	DELAY(1);
	sc->eeprom_size = x;
}
/*
 * Read from the serial EEPROM. Basically, you manually shift in
 * the read opcode (one bit at a time) and then shift in the address,
 * and then you shift out the data (all of this one bit at a time).
 * The word size is 16 bits, so you have to provide the address for
 * every 16 bits of data.
 */
void
fxp_read_eeprom(sc, data, offset, words)
	struct fxp_softc *sc;
	u_short *data;
	int offset;
	int words;
{
	u_int16_t reg;
	int i, x;

	for (i = 0; i < words; i++) {
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);
		/*
		 * Shift in read opcode.
		 */
		for (x = 3; x > 0; x--) {
			if (FXP_EEPROM_OPC_READ & (1 << (x - 1))) {
				reg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;
			} else {
				reg = FXP_EEPROM_EECS;
			}
			CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);
			CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,
			    reg | FXP_EEPROM_EESK);
			DELAY(1);
			CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);
			DELAY(1);
		}
		/*
		 * Shift in address.
		 */
		for (x = sc->eeprom_size; x > 0; x--) {
			if ((i + offset) & (1 << (x - 1))) {
				reg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;
			} else {
				reg = FXP_EEPROM_EECS;
			}
			CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);
			CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,
			    reg | FXP_EEPROM_EESK);
			DELAY(1);
			CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);
			DELAY(1);
		}
		reg = FXP_EEPROM_EECS;
		data[i] = 0;
		/*
		 * Shift out data.
		 */
		for (x = 16; x > 0; x--) {
			CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,
			    reg | FXP_EEPROM_EESK);
			DELAY(1);
			if (CSR_READ_2(sc, FXP_CSR_EEPROMCONTROL) &
			    FXP_EEPROM_EEDO)
				data[i] |= (1 << (x - 1));
			CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);
			DELAY(1);
		}
		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);
		DELAY(1);
	}
}

/*
 * Start packet transmission on the interface.
 */
void
fxp_start(ifp)
	struct ifnet *ifp;
{
	struct fxp_softc *sc = ifp->if_softc;
	struct fxp_cb_tx *txp;

	/*
	 * See if we need to suspend xmit until the multicast filter
	 * has been reprogrammed (which can only be done at the head
	 * of the command chain).
	 */
	if (sc->need_mcsetup)
		return;

	txp = NULL;

	/*
	 * We're finished if there is nothing more to add to the list or if
	 * we're all filled up with buffers to transmit.
	 * NOTE: One TxCB is reserved to guarantee that fxp_mc_setup() can add
	 *       a NOP command when needed.
	 */
	while (ifp->if_snd.ifq_head != NULL && sc->tx_queued < FXP_NTXCB - 1) {
		struct mbuf *m, *mb_head;
		int segment;

		/*
		 * Grab a packet to transmit.
		 */
		IF_DEQUEUE(&ifp->if_snd, mb_head);

		/*
		 * Get pointer to next available tx desc.
		 */
		txp = sc->cbl_last->next;

		/*
		 * Go through each of the mbufs in the chain and initialize
		 * the transmit buffer descriptors with the physical address
		 * and size of the mbuf.
		 */
tbdinit:
		for (m = mb_head, segment = 0; m != NULL; m = m->m_next) {
			if (m->m_len != 0) {
				if (segment == FXP_NTXSEG)
					break;
				txp->tbd[segment].tb_addr =
				    vtophys(mtod(m, vm_offset_t));
				txp->tbd[segment].tb_size = m->m_len;
				segment++;
			}
		}
		if (m != NULL) {
			struct mbuf *mn;

			/*
			 * We ran out of segments. We have to recopy this mbuf
			 * chain first. Bail out if we can't get the new buffers.
			 */
			MGETHDR(mn, M_DONTWAIT, MT_DATA);
			if (mn == NULL) {
				m_freem(mb_head);
				break;
			}
			if (mb_head->m_pkthdr.len > MHLEN) {
				MCLGET(mn, M_DONTWAIT);
				if ((mn->m_flags & M_EXT) == 0) {
					m_freem(mn);
					m_freem(mb_head);
					break;
				}
			}
			m_copydata(mb_head, 0, mb_head->m_pkthdr.len,
			    mtod(mn, caddr_t));
			mn->m_pkthdr.len = mn->m_len = mb_head->m_pkthdr.len;
			m_freem(mb_head);
			mb_head = mn;
			goto tbdinit;
		}

		txp->tbd_number = segment;
		txp->mb_head = mb_head;
		txp->cb_status = 0;
		if (sc->tx_queued != FXP_CXINT_THRESH - 1) {
			txp->cb_command =
			    FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF | FXP_CB_COMMAND_S;
		} else {
			txp->cb_command =
			    FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;
			/*
			 * Set a 5 second timer just in case we don't hear from the
			 * card again.
			 */
			ifp->if_timer = 5;
		}
		txp->tx_threshold = tx_threshold;
	
		/*
		 * Advance the end of list forward.
		 */
		sc->cbl_last->cb_command &= ~FXP_CB_COMMAND_S;
		sc->cbl_last = txp;

		/*
		 * Advance the beginning of the list forward if there are
		 * no other packets queued (when nothing is queued, cbl_first
		 * sits on the last TxCB that was sent out).
		 */
		if (sc->tx_queued == 0)
			sc->cbl_first = txp;

		sc->tx_queued++;

#if NBPFILTER > 0
		/*
		 * Pass packet to bpf if there is a listener.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, mb_head);
#endif
	}

	/*
	 * We're finished. If we added to the list, issue a RESUME to get DMA
	 * going again if suspended.
	 */
	if (txp != NULL) {
		fxp_scb_wait(sc);
		CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_RESUME);
	}
}

/*
 * Process interface interrupts.
 */
int
fxp_intr(arg)
	void *arg;
{
	struct fxp_softc *sc = arg;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	u_int8_t statack;
	int claimed = 0;

	/*
	 * If the interface isn't running, don't try to
	 * service the interrupt.. just ack it and bail.
	 */
	if ((ifp->if_flags & IFF_RUNNING) == 0) {
		statack = CSR_READ_1(sc, FXP_CSR_SCB_STATACK);
		if (statack) {
			claimed = 1;
			CSR_WRITE_1(sc, FXP_CSR_SCB_STATACK, statack);
		}
		return claimed;
	}

	while ((statack = CSR_READ_1(sc, FXP_CSR_SCB_STATACK)) != 0) {
		claimed = 1;
		/*
		 * First ACK all the interrupts in this pass.
		 */
		CSR_WRITE_1(sc, FXP_CSR_SCB_STATACK, statack);

		/*
		 * Free any finished transmit mbuf chains.
		 */
		if (statack & FXP_SCB_STATACK_CXTNO) {
			struct fxp_cb_tx *txp;

			for (txp = sc->cbl_first; sc->tx_queued &&
			    (txp->cb_status & FXP_CB_STATUS_C) != 0;
			    txp = txp->next) {
				if (txp->mb_head != NULL) {
					m_freem(txp->mb_head);
					txp->mb_head = NULL;
				}
				sc->tx_queued--;
			}
			sc->cbl_first = txp;
			ifp->if_timer = 0;
			if (sc->tx_queued == 0) {
				if (sc->need_mcsetup)
					fxp_mc_setup(sc);
			}
			/*
			 * Try to start more packets transmitting.
			 */
			if (ifp->if_snd.ifq_head != NULL)
				fxp_start(ifp);
		}
		/*
		 * Process receiver interrupts. If a no-resource (RNR)
		 * condition exists, get whatever packets we can and
		 * re-start the receiver.
		 */
		if (statack & (FXP_SCB_STATACK_FR | FXP_SCB_STATACK_RNR)) {
			struct mbuf *m;
			u_int8_t *rfap;
rcvloop:
			m = sc->rfa_headm;
			rfap = m->m_ext.ext_buf + RFA_ALIGNMENT_FUDGE;

			if (*(u_int16_t *)(rfap +
			    offsetof(struct fxp_rfa, rfa_status)) &
			    FXP_RFA_STATUS_C) {
				/*
				 * Remove first packet from the chain.
				 */
				sc->rfa_headm = m->m_next;
				m->m_next = NULL;

				/*
				 * Add a new buffer to the receive chain.
				 * If this fails, the old buffer is recycled
				 * instead.
				 */
				if (fxp_add_rfabuf(sc, m) == 0) {
					struct ether_header *eh;
					u_int16_t total_len;

					total_len = *(u_int16_t *)(rfap +
					    offsetof(struct fxp_rfa,
					    actual_size)) &
					    (MCLBYTES - 1);
					if (total_len <
					    sizeof(struct ether_header)) {
						m_freem(m);
						goto rcvloop;
					}
					m->m_pkthdr.rcvif = ifp;
					m->m_pkthdr.len = m->m_len =
					    total_len -
					    sizeof(struct ether_header);
					eh = mtod(m, struct ether_header *);
#if NBPFILTER > 0
					if (ifp->if_bpf)
						bpf_tap(ifp->if_bpf,
						    mtod(m, caddr_t),
						    total_len); 
#endif /* NBPFILTER > 0 */
					m->m_data +=
					    sizeof(struct ether_header);
					ether_input(ifp, eh, m);
				}
				goto rcvloop;
			}
			if (statack & FXP_SCB_STATACK_RNR) {
				fxp_scb_wait(sc);
				CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,
				    vtophys(sc->rfa_headm->m_ext.ext_buf) +
					RFA_ALIGNMENT_FUDGE);
				CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND,
				    FXP_SCB_COMMAND_RU_START);
			}
		}
	}
	return (claimed);
}

/*
 * Update packet in/out/collision statistics. The i82557 doesn't
 * allow you to access these counters without doing a fairly
 * expensive DMA to get _all_ of the statistics it maintains, so
 * we do this operation here only once per second. The statistics
 * counters in the kernel are updated from the previous dump-stats
 * DMA and then a new dump-stats DMA is started. The on-chip
 * counters are zeroed when the DMA completes. If we can't start
 * the DMA immediately, we don't wait - we just prepare to read
 * them again next time.
 */
void
fxp_stats_update(arg)
	void *arg;
{
	struct fxp_softc *sc = arg;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	struct fxp_stats *sp = sc->fxp_stats;
	int s;

	ifp->if_opackets += sp->tx_good;
	ifp->if_collisions += sp->tx_total_collisions;
	if (sp->rx_good) {
		ifp->if_ipackets += sp->rx_good;
		sc->rx_idle_secs = 0;
	} else {
		sc->rx_idle_secs++;
	}
	ifp->if_ierrors +=
	    sp->rx_crc_errors +
	    sp->rx_alignment_errors +
	    sp->rx_rnr_errors +
	    sp->rx_overrun_errors;
	/*
	 * If any transmit underruns occured, bump up the transmit
	 * threshold by another 512 bytes (64 * 8).
	 */
	if (sp->tx_underruns) {
		ifp->if_oerrors += sp->tx_underruns;
		if (tx_threshold < 192)
			tx_threshold += 64;
	}
	s = splimp();
	/*
	 * If we haven't received any packets in FXP_MAC_RX_IDLE seconds,
	 * then assume the receiver has locked up and attempt to clear
	 * the condition by reprogramming the multicast filter. This is
	 * a work-around for a bug in the 82557 where the receiver locks
	 * up if it gets certain types of garbage in the syncronization
	 * bits prior to the packet header. This bug is supposed to only
	 * occur in 10Mbps mode, but has been seen to occur in 100Mbps
	 * mode as well (perhaps due to a 10/100 speed transition).
	 */
	if (sc->rx_idle_secs > FXP_MAX_RX_IDLE) {
		sc->rx_idle_secs = 0;
		fxp_mc_setup(sc);
	}
	/*
	 * If there is no pending command, start another stats
	 * dump. Otherwise punt for now.
	 */
	if (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) == 0) {
		/*
		 * Start another stats dump.
		 */
		CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND,
		    FXP_SCB_COMMAND_CU_DUMPRESET);
	} else {
		/*
		 * A previous command is still waiting to be accepted.
		 * Just zero our copy of the stats and wait for the
		 * next timer event to update them.
		 */
		sp->tx_good = 0;
		sp->tx_underruns = 0;
		sp->tx_total_collisions = 0;

		sp->rx_good = 0;
		sp->rx_crc_errors = 0;
		sp->rx_alignment_errors = 0;
		sp->rx_rnr_errors = 0;
		sp->rx_overrun_errors = 0;
	}

	/* Tick the MII clock. */
	mii_tick(&sc->sc_mii);

	splx(s);
	/*
	 * Schedule another timeout one second from now.
	 */
	timeout(fxp_stats_update, sc, hz);
}

/*
 * Stop the interface. Cancels the statistics updater and resets
 * the interface.
 */
void
fxp_stop(sc, drain)
	struct fxp_softc *sc;
	int drain;
{
	struct ifnet *ifp = &sc->arpcom.ac_if;
	struct fxp_cb_tx *txp;
	int i;

	/*
	 * Turn down interface (done early to avoid bad interactions
	 * between panics, shutdown hooks, and the watchdog timer)
	 */
	ifp->if_timer = 0;
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);

	/*
	 * Cancel stats updater.
	 */
	untimeout(fxp_stats_update, sc);

	/*
	 * Issue software reset
	 */
	CSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);
	DELAY(10);

	/*
	 * Release any xmit buffers.
	 */
	for (txp = sc->cbl_first; txp != NULL && txp->mb_head != NULL;
	    txp = txp->next) {
		m_freem(txp->mb_head);
		txp->mb_head = NULL;
	}
	sc->tx_queued = 0;

	if (drain) {
		/*
		 * Free all the receive buffers then reallocate/reinitialize
		 */
		if (sc->rfa_headm != NULL)
			m_freem(sc->rfa_headm);
		sc->rfa_headm = NULL;
		sc->rfa_tailm = NULL;
		for (i = 0; i < FXP_NRFABUFS; i++) {
			if (fxp_add_rfabuf(sc, NULL) != 0) {
				/*
				 * This "can't happen" - we're at splimp()
				 * and we just freed all the buffers we need
				 * above.
				 */
				panic("fxp_stop: no buffers!");
			}
		}
	}

}

/*
 * Watchdog/transmission transmit timeout handler. Called when a
 * transmission is started on the interface, but no interrupt is
 * received before the timeout. This usually indicates that the
 * card has wedged for some reason.
 */
void
fxp_watchdog(ifp)
	struct ifnet *ifp;
{
	struct fxp_softc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	ifp->if_oerrors++;

	fxp_init(sc);
}

void
fxp_init(xsc)
	void *xsc;
{
	struct fxp_softc *sc = xsc;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	struct fxp_cb_config *cbp;
	struct fxp_cb_ias *cb_ias;
	struct fxp_cb_tx *txp;
	int i, s, prm;

	s = splimp();
	/*
	 * Cancel any pending I/O
	 */
	fxp_stop(sc, 0);

	prm = (ifp->if_flags & IFF_PROMISC) ? 1 : 0;

	/*
	 * Initialize base of CBL and RFA memory. Loading with zero
	 * sets it up for regular linear addressing.
	 */
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, 0);
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_BASE);

	fxp_scb_wait(sc);
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_BASE);

	/*
	 * Initialize base of dump-stats buffer.
	 */
	fxp_scb_wait(sc);
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(sc->fxp_stats));
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_DUMP_ADR);

	/*
	 * We temporarily use memory that contains the TxCB list to
	 * construct the config CB. The TxCB list memory is rebuilt
	 * later.
	 */
	cbp = (struct fxp_cb_config *) sc->cbl_base;

	/*
	 * This bcopy is kind of disgusting, but there are a bunch of must be
	 * zero and must be one bits in this structure and this is the easiest
	 * way to initialize them all to proper values.
	 */
	bcopy(fxp_cb_config_template, (void *)&cbp->cb_status,
		sizeof(fxp_cb_config_template));

	cbp->cb_status =	0;
	cbp->cb_command =	FXP_CB_COMMAND_CONFIG | FXP_CB_COMMAND_EL;
	cbp->link_addr =	-1;	/* (no) next command */
	cbp->byte_count =	22;	/* (22) bytes to config */
	cbp->rx_fifo_limit =	8;	/* rx fifo threshold (32 bytes) */
	cbp->tx_fifo_limit =	0;	/* tx fifo threshold (0 bytes) */
	cbp->adaptive_ifs =	0;	/* (no) adaptive interframe spacing */
	cbp->rx_dma_bytecount =	0;	/* (no) rx DMA max */
	cbp->tx_dma_bytecount =	0;	/* (no) tx DMA max */
	cbp->dma_bce =		0;	/* (disable) dma max counters */
	cbp->late_scb =		0;	/* (don't) defer SCB update */
	cbp->tno_int =		0;	/* (disable) tx not okay interrupt */
	cbp->ci_int =		1;	/* interrupt on CU idle */
	cbp->save_bf =		prm;	/* save bad frames */
	cbp->disc_short_rx =	!prm;	/* discard short packets */
	cbp->underrun_retry =	1;	/* retry mode (1) on DMA underrun */
	cbp->mediatype =	!sc->phy_10Mbps_only; /* interface mode */
	cbp->nsai =		1;	/* (don't) disable source addr insert */
	cbp->preamble_length =	2;	/* (7 byte) preamble */
	cbp->loopback =		0;	/* (don't) loopback */
	cbp->linear_priority =	0;	/* (normal CSMA/CD operation) */
	cbp->linear_pri_mode =	0;	/* (wait after xmit only) */
	cbp->interfrm_spacing =	6;	/* (96 bits of) interframe spacing */
	cbp->promiscuous =	prm;	/* promiscuous mode */
	cbp->bcast_disable =	0;	/* (don't) disable broadcasts */
	cbp->crscdt =		0;	/* (CRS only) */
	cbp->stripping =	!prm;	/* truncate rx packet to byte count */
	cbp->padding =		1;	/* (do) pad short tx packets */
	cbp->rcv_crc_xfer =	0;	/* (don't) xfer CRC to host */
	cbp->force_fdx =	0;	/* (don't) force full duplex */
	cbp->fdx_pin_en =	1;	/* (enable) FDX# pin */
	cbp->multi_ia =		0;	/* (don't) accept multiple IAs */
	cbp->mc_all =		sc->all_mcasts;/* accept all multicasts */

	/*
	 * Start the config command/DMA.
	 */
	fxp_scb_wait(sc);
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&cbp->cb_status));
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);
	/* ...and wait for it to complete. */
	while (!(cbp->cb_status & FXP_CB_STATUS_C));

	/*
	 * Now initialize the station address. Temporarily use the TxCB
	 * memory area like we did above for the config CB.
	 */
	cb_ias = (struct fxp_cb_ias *) sc->cbl_base;
	cb_ias->cb_status = 0;
	cb_ias->cb_command = FXP_CB_COMMAND_IAS | FXP_CB_COMMAND_EL;
	cb_ias->link_addr = -1;
	bcopy(sc->arpcom.ac_enaddr, (void *)cb_ias->macaddr,
	    sizeof(sc->arpcom.ac_enaddr));

	/*
	 * Start the IAS (Individual Address Setup) command/DMA.
	 */
	fxp_scb_wait(sc);
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);
	/* ...and wait for it to complete. */
	while (!(cb_ias->cb_status & FXP_CB_STATUS_C));

	/*
	 * Initialize transmit control block (TxCB) list.
	 */

	txp = sc->cbl_base;
	bzero(txp, sizeof(struct fxp_cb_tx) * FXP_NTXCB);
	for (i = 0; i < FXP_NTXCB; i++) {
		txp[i].cb_status = FXP_CB_STATUS_C | FXP_CB_STATUS_OK;
		txp[i].cb_command = FXP_CB_COMMAND_NOP;
		txp[i].link_addr = vtophys(&txp[(i + 1) & FXP_TXCB_MASK].cb_status);
		txp[i].tbd_array_addr = vtophys(&txp[i].tbd[0]);
		txp[i].next = &txp[(i + 1) & FXP_TXCB_MASK];
	}
	/*
	 * Set the suspend flag on the first TxCB and start the control
	 * unit. It will execute the NOP and then suspend.
	 */
	txp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S;
	sc->cbl_first = sc->cbl_last = txp;
	sc->tx_queued = 1;

	fxp_scb_wait(sc);
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);

	/*
	 * Initialize receiver buffer area - RFA.
	 */
	fxp_scb_wait(sc);
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,
	    vtophys(sc->rfa_headm->m_ext.ext_buf) + RFA_ALIGNMENT_FUDGE);
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_START);

	/*
	 * Set current media.
	 */
	mii_mediachg(&sc->sc_mii);

	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;
	splx(s);

	/*
	 * Start stats updater.
	 */
	timeout(fxp_stats_update, sc, hz);
}

/*
 * Change media according to request.
 */
int
fxp_mediachange(ifp)
	struct ifnet *ifp;
{

	if (ifp->if_flags & IFF_UP)
		fxp_init(ifp->if_softc);
	return (0);
}

/*
 * Notify the world which media we're using.
 */
void
fxp_mediastatus(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
{
	struct fxp_softc *sc = ifp->if_softc;

	mii_pollstat(&sc->sc_mii);
	ifmr->ifm_status = sc->sc_mii.mii_media_status;
	ifmr->ifm_active = sc->sc_mii.mii_media_active;
}

/*
 * Add a buffer to the end of the RFA buffer list.
 * Return 0 if successful, 1 for failure. A failure results in
 * adding the 'oldm' (if non-NULL) on to the end of the list -
 * tossing out its old contents and recycling it.
 * The RFA struct is stuck at the beginning of mbuf cluster and the
 * data pointer is fixed up to point just past it.
 */
int
fxp_add_rfabuf(sc, oldm)
	struct fxp_softc *sc;
	struct mbuf *oldm;
{
	u_int32_t v;
	struct mbuf *m;
	u_int8_t *rfap;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m != NULL) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			m_freem(m);
			if (oldm == NULL)
				return 1;
			m = oldm;
			m->m_data = m->m_ext.ext_buf;
		}
	} else {
		if (oldm == NULL)
			return 1;
		m = oldm;
		m->m_data = m->m_ext.ext_buf;
	}

	/*
	 * Move the data pointer up so that the incoming data packet
	 * will be 32-bit aligned.
	 */
	m->m_data += RFA_ALIGNMENT_FUDGE;

	/*
	 * Get a pointer to the base of the mbuf cluster and move
	 * data start past it.
	 */
	rfap = m->m_data;
	m->m_data += sizeof(struct fxp_rfa);
	*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, size)) =
	    MCLBYTES - sizeof(struct fxp_rfa) - RFA_ALIGNMENT_FUDGE;

	/*
	 * Initialize the rest of the RFA.  Note that since the RFA
	 * is misaligned, we cannot store values directly.  Instead,
	 * we use an optimized, inline copy.
	 */
	*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_status)) = 0;
	*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) =
	    FXP_RFA_CONTROL_EL;
	*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, actual_size)) = 0;

	v = -1;
	fxp_lwcopy(&v,
	    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));
	fxp_lwcopy(&v,
	    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, rbd_addr)));

	/*
	 * If there are other buffers already on the list, attach this
	 * one to the end by fixing up the tail to point to this one.
	 */
	if (sc->rfa_headm != NULL) {
		sc->rfa_tailm->m_next = m;
		v = vtophys(rfap);
		rfap = sc->rfa_tailm->m_ext.ext_buf + RFA_ALIGNMENT_FUDGE;
		fxp_lwcopy(&v,
		    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));
		*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) &=
		    ~FXP_RFA_CONTROL_EL;
	} else {
		sc->rfa_headm = m;
	}
	sc->rfa_tailm = m;

	return (m == oldm);
}

volatile int
fxp_mdi_read(self, phy, reg)
	struct device *self;
	int phy;
	int reg;
{
	struct fxp_softc *sc = (struct fxp_softc *)self;
	int count = 10000;
	int value;

	CSR_WRITE_4(sc, FXP_CSR_MDICONTROL,
	    (FXP_MDI_READ << 26) | (reg << 16) | (phy << 21));

	while (((value = CSR_READ_4(sc, FXP_CSR_MDICONTROL)) & 0x10000000) == 0
	    && count--)
		DELAY(10);

	if (count <= 0)
		printf("%s: fxp_mdi_read: timed out\n", sc->sc_dev.dv_xname);

	return (value & 0xffff);
}

void
fxp_statchg(self)
	struct device *self;
{

	/* XXX Update ifp->if_baudrate */
}

void
fxp_mdi_write(self, phy, reg, value)
	struct device *self;
	int phy;
	int reg;
	int value;
{
	struct fxp_softc *sc = (struct fxp_softc *)self;
	int count = 10000;

	CSR_WRITE_4(sc, FXP_CSR_MDICONTROL,
	    (FXP_MDI_WRITE << 26) | (reg << 16) | (phy << 21) |
	    (value & 0xffff));

	while((CSR_READ_4(sc, FXP_CSR_MDICONTROL) & 0x10000000) == 0 &&
	    count--)
		DELAY(10);

	if (count <= 0)
		printf("%s: fxp_mdi_write: timed out\n", sc->sc_dev.dv_xname);
}

int
fxp_ioctl(ifp, command, data)
	struct ifnet *ifp;
	u_long command;
	caddr_t data;
{
	struct fxp_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splimp();

	switch (command) {

	case SIOCSIFADDR:
	case SIOCGIFADDR:
	case SIOCSIFMTU:
		error = ether_ioctl(ifp, command, data);
		break;

	case SIOCSIFFLAGS:
		sc->all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;

		/*
		 * If interface is marked up and not running, then start it.
		 * If it is marked down and running, stop it.
		 * XXX If it's up then re-initialize it. This is so flags
		 * such as IFF_PROMISC are handled.
		 */
		if (ifp->if_flags & IFF_UP) {
			fxp_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				fxp_stop(sc, 1);
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		sc->all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);
		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (!sc->all_mcasts)
				fxp_mc_setup(sc);
			/*
			 * fxp_mc_setup() can turn on all_mcasts if we run
			 * out of space, so check it again rather than else {}.
			 */
			if (sc->all_mcasts)
				fxp_init(sc);
			error = 0;
		}
		break;

	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, command);
		break;

	default:
		error = EINVAL;
	}
	(void) splx(s);
	return (error);
}

/*
 * Program the multicast filter.
 *
 * We have an artificial restriction that the multicast setup command
 * must be the first command in the chain, so we take steps to ensure
 * this. By requiring this, it allows us to keep up the performance of
 * the pre-initialized command ring (esp. link pointers) by not actually
 * inserting the mcsetup command in the ring - i.e. its link pointer
 * points to the TxCB ring, but the mcsetup descriptor itself is not part
 * of it. We then can do 'CU_START' on the mcsetup descriptor and have it
 * lead into the regular TxCB ring when it completes.
 *
 * This function must be called at splimp.
 */
void
fxp_mc_setup(sc)
	struct fxp_softc *sc;
{
	struct fxp_cb_mcs *mcsp = sc->mcsp;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	struct ether_multistep step;
	struct ether_multi *enm;
	int nmcasts;

	/*
	 * If there are queued commands, we must wait until they are all
	 * completed. If we are already waiting, then add a NOP command
	 * with interrupt option so that we're notified when all commands
	 * have been completed - fxp_start() ensures that no additional
	 * TX commands will be added when need_mcsetup is true.
	 */
	if (sc->tx_queued) {
		struct fxp_cb_tx *txp;

		/*
		 * need_mcsetup will be true if we are already waiting for the
		 * NOP command to be completed (see below). In this case, bail.
		 */
		if (sc->need_mcsetup)
			return;
		sc->need_mcsetup = 1;

		/*
		 * Add a NOP command with interrupt so that we are notified when all
		 * TX commands have been processed.
		 */
		txp = sc->cbl_last->next;
		txp->mb_head = NULL;
		txp->cb_status = 0;
		txp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;
		/*
		 * Advance the end of list forward.
		 */
		sc->cbl_last->cb_command &= ~FXP_CB_COMMAND_S;
		sc->cbl_last = txp;
		sc->tx_queued++;
		/*
		 * Issue a resume in case the CU has just suspended.
		 */
		fxp_scb_wait(sc);
		CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_RESUME);
		/*
		 * Set a 5 second timer just in case we don't hear from the
		 * card again.
		 */
		ifp->if_timer = 5;

		return;
	}
	sc->need_mcsetup = 0;

	/*
	 * Initialize multicast setup descriptor.
	 */
	mcsp->next = sc->cbl_base;
	mcsp->mb_head = NULL;
	mcsp->cb_status = 0;
	mcsp->cb_command = FXP_CB_COMMAND_MCAS | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;
	mcsp->link_addr = vtophys(&sc->cbl_base->cb_status);

	nmcasts = 0;
	if (!sc->all_mcasts) {
		ETHER_FIRST_MULTI(step, &sc->arpcom, enm);
		while (enm != NULL) {
			if (nmcasts >= MAXMCADDR) {
				sc->all_mcasts = 1;
				nmcasts = 0;
				break;
			}

			/* Punt on ranges. */
			if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
			    sizeof(enm->enm_addrlo)) != 0) {
				sc->all_mcasts = 1;
				nmcasts = 0;
				break;
			}
			bcopy(enm->enm_addrlo,
			    (void *) &sc->mcsp->mc_addr[nmcasts][0], 6);
			nmcasts++;
			ETHER_NEXT_MULTI(step, enm);
		}
	}
	mcsp->mc_cnt = nmcasts * 6;
	sc->cbl_first = sc->cbl_last = (struct fxp_cb_tx *) mcsp;
	sc->tx_queued = 1;

	/*
	 * Wait until command unit is not active. This should never
	 * be the case when nothing is queued, but make sure anyway.
	 */
	while ((CSR_READ_1(sc, FXP_CSR_SCB_RUSCUS) >> 6) ==
	    FXP_SCB_CUS_ACTIVE) ;

	/*
	 * Start the multicast setup command.
	 */
	fxp_scb_wait(sc);
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&mcsp->cb_status));
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);

	ifp->if_timer = 2;
	return;
}
@


1.26
log
@remove #ifdef {free,net}bsd stuff
remove most of the statics
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.25 2000/03/30 02:49:35 jason Exp $	*/
@


1.25
log
@auto detect the size of the seeprom; from freebsd (from NetBSD (from Linux?))
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.24 2000/01/09 22:36:46 jason Exp $	*/
a76 2
#if defined(__NetBSD__) || defined(__OpenBSD__)

a80 6
#if defined(__NetBSD__)
#include <net/if_ether.h>
#include <netinet/if_inarp.h>
#endif

#if defined(__OpenBSD__)
a81 1
#endif
a103 17
#else /* __FreeBSD__ */

#include <sys/sockio.h>

#include <netinet/if_ether.h>

#include <vm/vm.h>		/* for vtophys */
#include <vm/vm_param.h>	/* for vtophys */
#include <vm/pmap.h>		/* for vtophys */
#include <machine/clock.h>	/* for DELAY */

#include <pci/pcivar.h>
#include <pci/if_fxpreg.h>
#include <pci/if_fxpvar.h>

#endif /* __NetBSD__ || __OpenBSD__ */

d173 2
a174 2
static int fxp_mediachange	__P((struct ifnet *));
static void fxp_mediastatus	__P((struct ifnet *, struct ifmediareq *));
d176 12
a187 13
static FXP_INTR_TYPE fxp_intr	__P((void *));
static void fxp_start		__P((struct ifnet *));
static int fxp_ioctl		__P((struct ifnet *,
				    FXP_IOCTLCMD_TYPE, caddr_t));
static void fxp_init		__P((void *));
static void fxp_stop		__P((struct fxp_softc *, int));
static void fxp_watchdog	__P((struct ifnet *));
static int fxp_add_rfabuf	__P((struct fxp_softc *, struct mbuf *));
static int fxp_mdi_read		__P((struct device *, int, int));
static void fxp_mdi_write	__P((struct device *, int, int, int));
static void fxp_autosize_eeprom	__P((struct fxp_softc *));
static void fxp_statchg		__P((struct device *));
static void fxp_read_eeprom	__P((struct fxp_softc *, u_int16_t *,
d189 1
a189 1
static int fxp_attach_common	__P((struct fxp_softc *, u_int8_t *));
d192 1
a192 1
void fxp_mc_setup	__P((struct fxp_softc *));
d253 2
a254 8
#if defined(__NetBSD__) || defined(__OpenBSD__)

#if defined(__BROKEN_INDIRECT_CONFIG) || defined(__OpenBSD__)
static int fxp_match __P((struct device *, void *, void *));
#else
static int fxp_match __P((struct device *, struct cfdata *, void *));
#endif
static void fxp_attach __P((struct device *, struct device *, void *));
d256 1
a256 1
static void	fxp_shutdown __P((void *));
d260 1
a260 2
static int	fxp_ether_ioctl __P((struct ifnet *,
				    FXP_IOCTLCMD_TYPE, caddr_t));
d274 1
a274 1
static int
a276 1
#if defined(__BROKEN_INDIRECT_CONFIG) || defined(__OpenBSD__)
a277 3
#else
	struct cfdata *match;
#endif
d294 1
a294 1
static void
a305 1
#ifdef __OpenBSD__
a308 1
#endif
a309 10
#ifndef __OpenBSD__
	/*
	 * Map control/status registers.
	 */
	if (pci_mapreg_map(pa, FXP_PCI_MMBA, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->sc_st, &sc->sc_sh, NULL, NULL)) {
		printf(": can't map registers\n");
		return;
	}
#else
a319 2
#endif

a330 1
#ifdef __OpenBSD__
a332 3
#else
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, fxp_intr, sc);
#endif
a347 1
#ifdef __OpenBSD__
a349 3
#else
	ifp = &sc->sc_ethercom.ec_if;
#endif
d374 2
a375 2
		printf(FXP_FORMAT ": no phy found, using manual mode\n",
		    FXP_ARGS(sc));
a393 3
#ifdef __NetBSD__
	ether_ifattach(ifp, enaddr);
#else
a394 1
#endif
a395 1
#ifdef __OpenBSD__
a397 4
#else
	bpfattach(&sc->sc_ethercom.ec_if.if_bpf, ifp, DLT_EN10MB,
	    sizeof(struct ether_header));
#endif
d418 1
a418 1
static void
d451 1
a451 1
static int
d454 1
a454 1
	FXP_IOCTLCMD_TYPE cmd;
a467 1
#ifdef __OpenBSD__
a468 3
#else
			arp_ifinit(ifp, ifa);
#endif
a499 132
#else /* __FreeBSD__ */

static u_long fxp_count;
static char *fxp_probe		__P((pcici_t, pcidi_t));
static void fxp_attach		__P((pcici_t, int));

static void fxp_shutdown	__P((int, void *));

static struct pci_device fxp_device = {
	"fxp",
	fxp_probe,
	fxp_attach,
	&fxp_count,
	NULL
};
DATA_SET(pcidevice_set, fxp_device);

/*
 * Return identification string if this is device is ours.
 */
static char *
fxp_probe(config_id, device_id)
	pcici_t config_id;
	pcidi_t device_id;
{
	if (((device_id & 0xffff) == FXP_VENDORID_INTEL) &&
	    ((device_id >> 16) & 0xffff) == FXP_DEVICEID_i82557)
		return ("Intel EtherExpress Pro 10/100B Ethernet");

	return NULL;
}

static void
fxp_attach(config_id, unit)
	pcici_t config_id;
	int unit;
{
	struct fxp_softc *sc;
	vm_offset_t pbase;
	struct ifnet *ifp;
	int s;

	sc = malloc(sizeof(struct fxp_softc), M_DEVBUF, M_NOWAIT);
	if (sc == NULL)
		return;
	bzero(sc, sizeof(struct fxp_softc));

	s = splimp();

	/*
	 * Map control/status registers.
	 */
	if (!pci_map_mem(config_id, FXP_PCI_MMBA,
	    (vm_offset_t *)&sc->csr, &pbase)) {
		printf("fxp%d: couldn't map memory\n", unit);
		goto fail;
	}

	/*
	 * Allocate our interrupt.
	 */
	if (!pci_map_int(config_id, fxp_intr, sc, &net_imask)) {
		printf("fxp%d: couldn't map interrupt\n", unit);
		goto fail;
	}

	/* Do generic parts of attach. */
	if (fxp_attach_common(sc, sc->arpcom.ac_enaddr)) {
		/* Failed! */
		(void) pci_unmap_int(config_id);
		goto fail;
	}

	printf("fxp%d: Ethernet address %6D%s\n", unit,
	    sc->arpcom.ac_enaddr, ":", sc->phy_10Mbps_only ? ", 10Mbps" : "");

	ifp = &sc->arpcom.ac_if;
	ifp->if_unit = unit;
	ifp->if_name = "fxp";
	ifp->if_output = ether_output;
	ifp->if_baudrate = 100000000;
	ifp->if_init = fxp_init;
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = fxp_ioctl;
	ifp->if_start = fxp_start;
	ifp->if_watchdog = fxp_watchdog;

	/*
	 * Attach the interface.
	 */
	if_attach(ifp);
	/*
	 * Let the system queue as many packets as we have available
	 * TX descriptors.
	 */
	ifp->if_snd.ifq_maxlen = FXP_NTXCB - 1;
	ether_ifattach(ifp);
#if NBPFILTER > 0
	bpfattach(ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif

	/*
	 * Add shutdown hook so that DMA is disabled prior to reboot. Not
	 * doing do could allow DMA to corrupt kernel memory during the
	 * reboot before the driver initializes.
	 */
	at_shutdown(fxp_shutdown, sc, SHUTDOWN_POST_SYNC);

	splx(s);
	return;

 fail:
	free(sc, M_DEVBUF);
	splx(s);
}

/*
 * Device shutdown routine. Called at system shutdown after sync. The
 * main purpose of this routine is to shut off receiver DMA so that
 * kernel memory doesn't get clobbered during warmboot.
 */
static void
fxp_shutdown(howto, sc)
	int howto;
	void *sc;
{
	fxp_stop((struct fxp_softc *) sc, 0);
}

#endif /* __NetBSD__ || __OpenBSD__ */

d507 1
a507 1
static int
d564 1
a564 1
	printf(FXP_FORMAT ": Failed to malloc memory\n", FXP_ARGS(sc));
d606 1
a606 1
static void
d655 1
a655 1
static void
d722 1
a722 1
static void
d841 1
a841 1
			bpf_mtap(FXP_BPFTAP_ARG(ifp), mb_head);
d858 1
a858 1
static FXP_INTR_TYPE
d863 1
a863 1
	struct ifnet *ifp = &sc->sc_if;
a864 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a878 1
#endif
a880 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a881 1
#endif
d960 1
a960 1
						bpf_tap(FXP_BPFTAP_ARG(ifp),
a979 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a980 1
#endif
d999 1
a999 1
	struct ifnet *ifp = &sc->sc_if;
d1086 1
a1086 1
	struct ifnet *ifp = &sc->sc_if;
d1152 1
a1152 1
	log(LOG_ERR, FXP_FORMAT ": device timeout\n", FXP_ARGS(sc));
d1163 1
a1163 1
	struct ifnet *ifp = &sc->sc_if;
a1259 3
#if defined(__NetBSD__)
	bcopy(LLADDR(ifp->if_sadl), (void *)cb_ias->macaddr, 6);
#else
a1261 1
#endif /* __NetBSD__ */
d1449 1
a1449 2
		printf(FXP_FORMAT ": fxp_mdi_read: timed out\n",
		    FXP_ARGS(sc));
d1454 1
a1454 1
static void
d1481 1
a1481 2
		printf(FXP_FORMAT ": fxp_mdi_write: timed out\n",
		    FXP_ARGS(sc));
d1487 1
a1487 1
	FXP_IOCTLCMD_TYPE command;
a1498 1
#if !(defined(__NetBSD__) || defined(__OpenBSD__))
a1500 1
#endif
a1523 2
#if defined(__NetBSD__) || defined(__OpenBSD__)
#if defined(__OpenBSD__)
a1526 6
#else
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_ethercom) :
		    ether_delmulti(ifr, &sc->sc_ethercom);
#endif

a1541 8
#else /* __FreeBSD__ */
		/*
		 * Multicast list has changed; set the hardware filter
		 * accordingly.
		 */
		fxp_init(sc);
		error = 0;
#endif /* __NetBSD__ || __OpenBSD__ */
d1575 1
a1575 2
	struct ifnet *ifp = &sc->sc_if;
#if defined(__OpenBSD__)
a1577 3
#else
	struct ifmultiaddr *ifma;
#endif
a1637 1
#if defined(__OpenBSD__)
a1657 15
#else
		for (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;
		    ifma = ifma->ifma_link.le_next) {
			if (ifma->ifma_addr->sa_family != AF_LINK)
				continue;
			if (nmcasts >= MAXMCADDR) {
				sc->all_mcasts = 1;
				nmcasts = 0;
				break;
			}
			bcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),
			    (void *) &sc->mcsp->mc_addr[nmcasts][0], 6);
			nmcasts++;
		}
#endif
@


1.24
log
@If no phy found, add IFM_MANUAL and then use it.  This is more accurate
than adding IFM_AUTO.  Also modify checks for which media are available
to try: IFM_MANUAL first, IFM_AUTO next, and finally IFM_10_T.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.23 2000/01/08 05:54:44 jason Exp $	*/
d212 1
d750 5
a760 1
	sc->phy_settings = 0;
d784 70
d891 1
a891 1
		for (x = 6; x > 0; x--) {
@


1.24.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.24 2000/01/09 22:36:46 jason Exp $	*/
@


1.23
log
@before setting IFM_AUTO, make sure it really exists.  If not, punt with
IFM_10_T.  Also remove long dead fxp_phyname()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.22 1999/11/11 16:23:19 provos Exp $	*/
d431 3
a433 2
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO, 0, NULL);
		printf(FXP_FORMAT ": no phy found, using auto mode\n",
d437 3
a439 1
	if (ifmedia_match(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO, 0))
@


1.22
log
@add a powerhook to disable DMA on suspend. okay jason@@

adapted from NetBSD Thu Oct 28 19:21:51 1999 UTC by sommerfeld:

Fix suspend/resume-related problems observed on fxp0 on Sony Z505S:

Symptoms: system would crash with "data modified on free list" pool
panic from the mbuf cluster pool shortly after a resume.  The cluster
in question contained a valid 82557 receive descriptor and an IP
packet.  Happened sporadically in normal use.  Easiest way for me to
reproduce it was to run tcpdump and a flood ping and do a
suspend/resume cycle or two.

Changes:
 - in interrupt handler, if the interface isn't in IFF_RUNNING state,
just ack interrupts and return; don't try to receive packets, queue
new descriptors, etc., etc.,
 - add power control hook to take interface down on suspend,
and restart it (if it was up) on resume.
 - tweaks to fxp_stop and fxp_shutdown to avoid recursive panics due
to the (now fixed) bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.21 1999/10/14 18:28:39 jason Exp $	*/
a200 3
#if 0
static const char *fxp_phyname	__P((int));
#endif
a434 1
	ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);
d436 4
a439 6
#if 0
	printf(FXP_FORMAT ": %s (%s) address %s\n", FXP_ARGS(sc),
	    fxp_phyname(sc->phy_primary_device),
	    sc->phy_10Mbps_only ? "10Mbps" : "10/100Mbps",
	    ether_sprintf(sc->arpcom.ac_enaddr));
#endif
a476 16

#if 0
static const char *
fxp_phyname(device)
	int device;
{
	static const char * const phynames[] = { "unknown", "82553A",
	    "82553C", "82503", "DP83840", "80C240", "80C24",
	    "82555/82558/82558B", "unknown", "unknown",
	    "DP83840A", "82555B" };

	if ((device < FXP_PHY_NONE) || (device > FXP_PHY_82555B))
		return(phynames[0]);
	return(phynames[device]);
}
#endif
@


1.21
log
@tick tock the mii clock during the stats update
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.20 1999/10/09 19:45:02 downsj Exp $	*/
d210 1
a210 1
static void fxp_stop		__P((struct fxp_softc *));
d292 1
d477 5
d509 27
a535 1
	fxp_stop((struct fxp_softc *) sc);
d718 1
a718 1
	fxp_stop((struct fxp_softc *) sc);
d1016 13
d1237 1
a1237 1
fxp_stop(sc)
d1239 1
d1246 7
d1273 17
a1289 15
	/*
	 * Free all the receive buffers then reallocate/reinitialize
	 */
	if (sc->rfa_headm != NULL)
		m_freem(sc->rfa_headm);
	sc->rfa_headm = NULL;
	sc->rfa_tailm = NULL;
	for (i = 0; i < FXP_NRFABUFS; i++) {
		if (fxp_add_rfabuf(sc, NULL) != 0) {
			/*
			 * This "can't happen" - we're at splimp()
			 * and we just freed all the buffers we need
			 * above.
			 */
			panic("fxp_stop: no buffers!");
a1292 2
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
	ifp->if_timer = 0;
d1328 1
a1328 1
	fxp_stop(sc);
d1680 1
a1680 1
				fxp_stop(sc);
@


1.20
log
@Attach to the new 82559 ID number as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.19 1999/02/26 17:05:53 jason Exp $	*/
d1176 4
@


1.19
log
@compensate for the fact that the check for ownership of a unicast packet
has moved to ether_input()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.18 1998/12/30 03:02:47 millert Exp $	*/
d326 1
@


1.18
log
@If no phy is probed, proceed in 'auto' mode.  This makes cards like my 10mb etherexpress pro+ combo that worked in 2.3 but not in 2.4.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.17 1998/09/22 18:58:03 deraadt Exp $	*/
d1066 1
a1066 1
					if (ifp->if_bpf) {
a1069 16
						/*
						 * Only pass this packet up
						 * if it is for us.
						 */
						if ((ifp->if_flags &
						    IFF_PROMISC) &&
						    (*(u_int16_t *)(rfap +
						    offsetof(struct fxp_rfa,
						    rfa_status)) &
						    FXP_RFA_STATUS_IAMATCH) &&
						    (eh->ether_dhost[0] & 1)
						    == 0) {
							m_freem(m);
							goto rcvloop;
						}
					}
@


1.17
log
@media support
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.16 1998/08/28 22:28:51 downsj Exp $	*/
d430 1
d432 5
a436 4
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE, 0, NULL);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);
	} else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);
@


1.16
log
@alpha alignment fixes, from niklas.  Tested on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.13 1998/07/02 21:15:45 downsj Exp $	*/
d52 1
d98 2
d191 11
d203 1
d213 3
a215 2
static int fxp_mdi_read		__P((struct fxp_softc *, int, int));
static void fxp_mdi_write	__P((struct fxp_softc *, int, int, int));
a402 1
	printf(": %s\n", intrstr);
d417 20
d441 1
d475 1
d489 1
d1278 1
a1278 1
	int i, s, prm, oldmdi;
a1417 51
	oldmdi = sc->phy_settings;

	/*
	 * Toggle a few bits in the PHY.
	 */
	switch (sc->phy_primary_device) {
	case FXP_PHY_DP83840:
	case FXP_PHY_DP83840A:
		fxp_mdi_write(sc, sc->phy_primary_addr, FXP_DP83840_PCR,
		    fxp_mdi_read(sc, sc->phy_primary_addr, FXP_DP83840_PCR) |
		    FXP_DP83840_PCR_LED4_MODE |	/* LED4 always indicates duplex */
		    FXP_DP83840_PCR_F_CONNECT |	/* force link disconnect bypass */
		    FXP_DP83840_PCR_BIT10);	/* XXX I have no idea */
		/* fallthrough */
	case FXP_PHY_82553A:
	case FXP_PHY_82553C:
	case FXP_PHY_82555:
	case FXP_PHY_82555B:
		/*
		 * If link0 is set, disable auto-negotiation and then:
		 *	If link1 is unset = 10Mbps
		 *	If link1 is set = 100Mbps
		 *	If link2 is unset = half duplex
		 *	If link2 is set = full duplex
		 * XXX THIS IS BEGGING FOR IF_MEDIA!
		 */
		if (ifp->if_flags & IFF_LINK0) {
			int flags;

			flags = (ifp->if_flags & IFF_LINK1) ?
			     FXP_PHY_BMCR_SPEED_100M : 0;
			flags |= (ifp->if_flags & IFF_LINK2) ?
			     FXP_PHY_BMCR_FULLDUPLEX : 0;
			fxp_mdi_write(sc, sc->phy_primary_addr,
			    FXP_PHY_BMCR,
			    (fxp_mdi_read(sc, sc->phy_primary_addr,
			    FXP_PHY_BMCR) &
			    ~(FXP_PHY_BMCR_AUTOEN |
			      FXP_PHY_BMCR_SPEED_100M |
			     FXP_PHY_BMCR_FULLDUPLEX)) | flags);
		} else {
			fxp_mdi_write(sc, sc->phy_primary_addr,
			    FXP_PHY_BMCR,
			    (fxp_mdi_read(sc, sc->phy_primary_addr,
			     FXP_PHY_BMCR) |
			    FXP_PHY_BMCR_AUTOEN));
		}

		sc->phy_settings = fxp_mdi_read(sc, sc->phy_primary_addr,
						FXP_PHY_BMCR);
		break;
d1419 1
a1419 2
	 * The Seeq 80c24 doesn't have a PHY programming interface, so do
	 * nothing.
d1421 1
a1421 19
	case FXP_PHY_80C24:
		break;
	default:
		printf(FXP_FORMAT
		    ": warning: unsupported PHY, type = %d, addr = %d\n",
		     FXP_ARGS(sc), sc->phy_primary_device,
		     sc->phy_primary_addr);
	}

	if (oldmdi != sc->phy_settings) {
		printf(FXP_FORMAT ": %s %s%s port\n",
		    FXP_ARGS(sc),
		    (sc->phy_settings & FXP_PHY_BMCR_AUTOEN) ?
		    		"autosensing" : "enabling",
		    (sc->phy_settings & FXP_PHY_BMCR_FULLDUPLEX) ?
		    		"full duplex " : "",
		    (sc->phy_settings & FXP_PHY_BMCR_SPEED_100M) ?
		    		"100baseTX" : "10baseT");
	}
d1434 28
d1547 2
a1548 2
fxp_mdi_read(sc, phy, reg)
	struct fxp_softc *sc;
d1552 1
d1570 8
d1579 2
a1580 2
fxp_mdi_write(sc, phy, reg, value)
	struct fxp_softc *sc;
d1585 1
d1608 1
a1643 3
	    {
		struct ifreq *ifr = (struct ifreq *) data;

a1668 1
	    }
d1677 5
@


1.15
log
@Be noisy about media settings.
@
text
@d127 2
d988 1
a988 1
			struct fxp_rfa *rfa;
d991 1
a991 2
			rfa = (struct fxp_rfa *)(m->m_ext.ext_buf +
			    RFA_ALIGNMENT_FUDGE);
d993 3
a995 1
			if (rfa->rfa_status & FXP_RFA_STATUS_C) {
d1011 3
a1013 1
					total_len = rfa->actual_size &
d1036 3
a1038 1
						    (rfa->rfa_status &
d1162 1
a1162 1
static void
d1219 1
a1219 1
static void
d1231 1
a1231 1
static void
d1473 1
a1473 1
static int
d1480 1
a1480 1
	struct fxp_rfa *rfa, *p_rfa;
d1509 1
a1509 1
	rfa = mtod(m, struct fxp_rfa *);
d1511 2
a1512 1
	rfa->size = MCLBYTES - sizeof(struct fxp_rfa) - RFA_ALIGNMENT_FUDGE;
d1519 4
a1522 3
	rfa->rfa_status = 0;
	rfa->rfa_control = FXP_RFA_CONTROL_EL;
	rfa->actual_size = 0;
d1525 4
a1528 2
	fxp_lwcopy(&v, &rfa->link_addr);
	fxp_lwcopy(&v, &rfa->rbd_addr);
a1534 2
		p_rfa = (struct fxp_rfa *) (sc->rfa_tailm->m_ext.ext_buf +
		    RFA_ALIGNMENT_FUDGE);
d1536 6
a1541 3
		v = vtophys(rfa);
		fxp_lwcopy(&v, &p_rfa->link_addr);
		p_rfa->rfa_control &= ~FXP_RFA_CONTROL_EL;
d1550 1
a1550 1
static volatile int
d1573 1
a1573 1
static void
d1595 1
a1595 1
static int
@


1.14
log
@Recent FreeBSD changes and a bug fix.
@
text
@d186 1
d385 1
a385 2
	printf(": address %s%s, %s\n", ether_sprintf(enaddr),
	    sc->phy_10Mbps_only ? ", 10Mbps" : "", intrstr);
d400 5
d437 14
d699 1
d1233 1
a1233 1
	int i, s, prm;
d1373 2
d1420 3
d1435 11
@


1.13
log
@Mostly sync with FreeBSD-current.  Needs more testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.12 1998/05/26 07:22:13 deraadt Exp $	*/
d33 1
a33 1
 *	Id: if_fxp.c,v 1.34 1997/04/23 01:44:30 davidg Exp
d219 9
d405 2
a406 1
	 * Let the system queue as many packets as we have TX descriptors.
d408 1
a408 1
	ifp->if_snd.ifq_maxlen = FXP_NTXCB;
d590 2
a591 1
	 * Let the system queue as many packets as we have TX descriptors.
d593 1
a593 1
	ifp->if_snd.ifq_maxlen = FXP_NTXCB;
d796 2
d799 1
a799 1
	while (ifp->if_snd.ifq_head != NULL && sc->tx_queued < FXP_NTXCB) {
d860 12
a871 2
		txp->cb_command =
		    FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF | FXP_CB_COMMAND_S;
a905 6

		/*
		 * Set a 5 second timer just in case we don't hear from the
		 * card again.
		 */
		ifp->if_timer = 5;
d933 27
a1034 27
		/*
		 * Free any finished transmit mbuf chains.
		 */
		if (statack & FXP_SCB_STATACK_CNA) {
			struct fxp_cb_tx *txp;

			for (txp = sc->cbl_first; sc->tx_queued &&
			    (txp->cb_status & FXP_CB_STATUS_C) != 0;
			    txp = txp->next) {
				if (txp->mb_head != NULL) {
					m_freem(txp->mb_head);
					txp->mb_head = NULL;
				}
				sc->tx_queued--;
			}
			sc->cbl_first = txp;
			if (sc->tx_queued == 0) {
				ifp->if_timer = 0;
				if (sc->need_mcsetup)
					fxp_mc_setup(sc);
			}
			/*
			 * Try to start more packets transmitting.
			 */
			if (ifp->if_snd.ifq_head != NULL)
				fxp_start(ifp);
		}
a1221 1
	sc->promisc_mode = prm;
d1267 1
a1267 1
	cbp->ci_int =		0;	/* interrupt on CU not active */
a1358 3
	case FXP_PHY_82553A:
	case FXP_PHY_82553C:
	case FXP_PHY_82555B:
d1365 2
d1368 1
d1640 1
a1640 1
 * that. By requiring this, it allows us to keep the performance of
d1663 7
d1671 8
d1680 26
d1716 1
a1716 1
	mcsp->cb_command = FXP_CB_COMMAND_MCAS | FXP_CB_COMMAND_S;
d1776 1
a1776 1
	ifp->if_timer = 5;
@


1.12
log
@of course an ethernet card has an ethernet address
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.11 1998/03/10 21:37:44 deraadt Exp $	*/
d183 1
a183 2
	0x5,	/* 21 */
	0x0, 0x0
d202 1
d224 2
a225 7
 * Number of DMA segments in a TxCB. Note that this is carefully
 * chosen to make the total struct size an even power of two. It's
 * critical that no TxCB be split across a page boundry since
 * no attempt is made to allocate physically contiguous memory.
 * 
 * XXX - don't forget to change the hard-coded constant in the
 * fxp_cb_tx struct (defined in if_fxpreg.h), too!
d227 1
a227 1
#define FXP_NTXSEG	29
d230 4
a233 2
 * Number of receive frame area buffers. These are large so chose
 * wisely.
d235 1
a235 1
#define FXP_NRFABUFS	32
d247 1
a247 2
	while ((CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) & FXP_SCB_COMMAND_MASK)
	    && --i);
d395 4
d579 4
d649 4
d682 2
a770 2
	struct mbuf *m, *mb_head;
	int segment, first = 1;
a771 1
txloop:
d773 3
a775 1
	 * See if we're all filled up with buffers to transmit.
d777 1
a777 1
	if (sc->tx_queued >= FXP_NTXCB)
d780 2
d783 2
a784 1
	 * Grab a packet to transmit.
d786 4
a789 2
	IF_DEQUEUE(&ifp->if_snd, mb_head);
	if (mb_head == NULL) {
d791 1
a791 1
		 * No more packets to send.
d793 1
a793 2
		return;
	}
d795 4
a798 4
	/*
	 * Get pointer to next available (unused) descriptor.
	 */
	txp = sc->cbl_last->next;
d800 5
a804 5
	/*
	 * Go through each of the mbufs in the chain and initialize
	 * the transmit buffers descriptors with the physical address
	 * and size of the mbuf.
	 */
d806 9
a814 8
	for (m = mb_head, segment = 0; m != NULL; m = m->m_next) {
		if (m->m_len != 0) {
			if (segment == FXP_NTXSEG)
				break;
			txp->tbd[segment].tb_addr =
			    vtophys(mtod(m, vm_offset_t));
			txp->tbd[segment].tb_size = m->m_len;
			segment++;
d816 2
a817 3
	}
	if (m != NULL) {
		struct mbuf *mn;
d819 6
a824 13
		/*
		 * We ran out of segments. We have to recopy this mbuf
		 * chain first.
		 */
		MGETHDR(mn, M_DONTWAIT, MT_DATA);
		if (mn == NULL) {
			m_freem(mb_head);
			return;
		}
		if (mb_head->m_pkthdr.len > MHLEN) {
			MCLGET(mn, M_DONTWAIT);
			if ((mn->m_flags & M_EXT) == 0) {
				m_freem(mn);
d826 9
a834 1
				return;
d836 6
a842 10
		m_copydata(mb_head, 0, mb_head->m_pkthdr.len,
		    mtod(mn, caddr_t));
		mn->m_pkthdr.len = mn->m_len = mb_head->m_pkthdr.len;
		m_freem(mb_head);
		mb_head = mn;
		goto tbdinit;
	}

	txp->tbd_number = segment;
	txp->mb_head = mb_head;
d844 6
a849 7
	/*
	 * Finish the initialization of this TxCB.
	 */
	txp->cb_status = 0;
	txp->cb_command =
	    FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF | FXP_CB_COMMAND_S;
	txp->tx_threshold = tx_threshold;
d851 5
a855 5
	/*
	 * Advance the end-of-list forward.
	 */
	sc->cbl_last->cb_command &= ~FXP_CB_COMMAND_S;
	sc->cbl_last = txp;
d857 7
a863 7
	/*
	 * Advance the beginning of the list forward if there are
	 * no other packets queued (when nothing is queued, cbl_first
	 * sits on the last TxCB that was sent out)..
	 */
	if (sc->tx_queued == 0)
		sc->cbl_first = txp;
d865 1
a865 1
	sc->tx_queued++;
d867 7
a873 6
	/*
	 * Only need to wait prior to the first resume command.
	 */
	if (first) {
		first--;
		fxp_scb_wait(sc);
d877 2
a878 1
	 * Resume transmission if suspended.
d880 3
a882 1
	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_RESUME);
d884 6
a889 14
#if NBPFILTER > 0
	/*
	 * Pass packet to bpf if there is a listener.
	 */
	if (ifp->if_bpf)
		bpf_mtap(FXP_BPFTAP_ARG(ifp), mb_head);
#endif
	/*
	 * Set a 5 second timer just in case we don't hear from the
	 * card again.
	 */
	ifp->if_timer = 5;

	goto txloop;
a915 26
		 * Free any finished transmit mbuf chains.
		 */
		if (statack & FXP_SCB_STATACK_CNA) {
			struct fxp_cb_tx *txp;

			for (txp = sc->cbl_first;
			    (txp->cb_status & FXP_CB_STATUS_C) != 0;
			    txp = txp->next) {
				if (txp->mb_head != NULL) {
					m_freem(txp->mb_head);
					txp->mb_head = NULL;
					sc->tx_queued--;
				}
				if (txp->cb_command & FXP_CB_COMMAND_S)
					break;
			}
			sc->cbl_first = txp;
			/*
			 * Clear watchdog timer. It may or may not be set
			 * again in fxp_start().
			 */
			ifp->if_timer = 0;
			if (ifp->if_snd.ifq_head != NULL)
				fxp_start(ifp);
		}
		/*
d991 27
d1042 1
d1046 6
a1051 1
	ifp->if_ipackets += sp->rx_good;
d1066 15
d1085 1
a1085 2
	if ((CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) &
	    FXP_SCB_COMMAND_MASK) == 0) {
d1087 1
a1087 3
		 * Start another stats dump. By waiting for it to be
		 * accepted, we avoid having to do splhigh locking when
		 * writing scb_command in other parts of the driver.
a1090 1
		fxp_scb_wait(sc);
d1107 1
d1196 1
a1196 1
	int i, s, mcast, prm;
a1205 6
	/*
	 * Sleeze out here and enable reception of all multicasts if
	 * multicasts are enabled. Ideally, we'd program the multicast
	 * address filter to only accept specific multicasts.
	 */
	mcast = (ifp->if_flags & (IFF_MULTICAST|IFF_ALLMULTI)) ? 1 : 0;
d1236 2
a1237 1
	bcopy(fxp_cb_config_template, cbp, sizeof(struct fxp_cb_config));
d1271 1
a1271 1
	cbp->mc_all =		mcast;	/* accept all multicasts */
d1277 1
a1277 1
	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(cbp));
d1314 1
a1314 1
		txp[i].link_addr = vtophys(&txp[(i + 1) & FXP_TXCB_MASK]);
d1319 1
a1319 1
	 * Set the stop flag on the first TxCB and start the control
d1324 1
a1324 1
	sc->tx_queued = 0;
d1410 1
a1410 1
 * tossing out it's old contents and recycling it.
d1553 1
d1571 1
d1591 8
a1598 1
			fxp_init(sc);
d1617 104
@


1.11
log
@Added support for the 82553 and 'B' 82555 PHY; dg@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.10 1998/01/11 13:43:03 deraadt Exp $	*/
d379 1
a379 1
	printf(": Ethernet address %s%s, %s\n", ether_sprintf(enaddr),
@


1.10
log
@pretty print
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.9 1998/01/07 11:03:29 deraadt Exp $	*/
d1324 3
@


1.9
log
@now this is really pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.8 1998/01/05 13:35:20 deraadt Exp $	*/
a371 1
	printf(": %s\n", intrstr);
@


1.8
log
@new style pci attach printing
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.7 1997/07/31 01:14:59 downsj Exp $	*/
a325 2
	printf("\n");

d348 1
d354 1
a354 1
		printf("%s: couldn't map interrupt\n", sc->sc_dev.dv_xname);
d357 1
d366 1
a366 2
		printf("%s: couldn't establish interrupt",
		    sc->sc_dev.dv_xname);
d372 1
a372 1
	printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname, intrstr);
d380 2
a381 2
	printf("%s: Ethernet address %s%s\n", sc->sc_dev.dv_xname,
	    ether_sprintf(enaddr), sc->phy_10Mbps_only ? ", 10Mbps" : "");
@


1.7
log
@Support for newer cards with i82555 PHY.  From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.6 1997/07/09 18:22:39 niklas Exp $	*/
d326 2
a348 2

	printf(": Intel EtherExpress Pro 10/100B Ethernet\n");
@


1.6
log
@Do not lose our ethernet address
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.5 1997/07/06 16:06:47 niklas Exp $	*/
d1321 1
a1321 1
	 * Toggle a few bits in the DP83840 PHY.
d1323 3
a1325 2
	if (sc->phy_primary_device == FXP_PHY_DP83840 ||
	     sc->phy_primary_device == FXP_PHY_DP83840A) {
d1331 2
d1345 1
a1345 1
			     FXP_DP83840_BMCR_SPEED_100M : 0;
d1347 1
a1347 1
			     FXP_DP83840_BMCR_FULLDUPLEX : 0;
d1349 1
a1349 1
			    FXP_DP83840_BMCR,
d1351 4
a1354 4
			    FXP_DP83840_BMCR) &
			    ~(FXP_DP83840_BMCR_AUTOEN |
			      FXP_DP83840_BMCR_SPEED_100M |
			     FXP_DP83840_BMCR_FULLDUPLEX)) | flags);
d1357 1
a1357 1
			    FXP_DP83840_BMCR,
d1359 2
a1360 2
			     FXP_DP83840_BMCR) |
			    FXP_DP83840_BMCR_AUTOEN));
d1362 8
a1369 1
	} else {
@


1.5
log
@Make compile (fxp now probes OK on alpha)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.4 1997/07/06 14:30:57 niklas Exp $	*/
d386 1
@


1.4
log
@OpenBSD tag + typo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp.c,v 1.2 1997/06/05 02:01:55 thorpej Exp $	*/
a358 1
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, fxp_intr, sc
d360 4
a363 1
	    , self->dv_xname
a364 1
	    );
@


1.3
log
@indent
@
text
@d1 1
d133 1
a133 1
 * alignes the packet after the Ethernet header at a 32-bit
@


1.2
log
@I doubt this fixes this driver, but what *was* there was *obviously* wrong;
at least if *this* is wrong, it matches the wrongness of the surrounding
block of code.
@
text
@d362 1
a362 1
	);
@


1.1
log
@Intel EtherExpress Pro/100B driver, still needs a fix or two
@
text
@d335 1
a335 2
	if (pci_io_find(pc, pa->pa_tag, PCI_MAPREG_TYPE_MEM,
	    &iobase, &iosize)) {
@

