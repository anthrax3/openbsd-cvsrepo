head	1.17;
access;
symbols
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14;
locks; strict;
comment	@ * @;


1.17
date	2007.04.05.16.25.25;	author mglocker;	state dead;
branches;
next	1.16;

1.16
date	2007.04.01.11.21.40;	author mglocker;	state Exp;
branches;
next	1.15;

1.15
date	2007.03.31.09.48.02;	author mglocker;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.04.11.04.18;	author mglocker;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.04.00.43.26;	author mglocker;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.26.14.36.11;	author mglocker;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.26.14.28.19;	author mglocker;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.26.14.14.02;	author mglocker;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.24.23.05.04;	author mglocker;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.03.10.01.34;	author mglocker;	state Exp;
branches;
next	1.7;

1.7
date	2006.12.08.01.28.40;	author mglocker;	state Exp;
branches;
next	1.6;

1.6
date	2006.12.06.19.21.45;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.29.21.34.06;	author mglocker;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.22.23.46.49;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.22.15.20.07;	author mglocker;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.21.11.41.14;	author mglocker;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.17.18.58.30;	author mglocker;	state Exp;
branches;
next	;


desc
@@


1.17
log
@After been attacked by Michael Buesch <mb@@bu3sch.de> because we initially
were using some of their routines in the bcw driver, I decided to stop
working on it.  To avoid any further license chit chat I plain drop the
driver.
@
text
@/*	$OpenBSD: if_bcw_pci.c,v 1.16 2007/04/01 11:21:40 mglocker Exp $ */

/*
 * Copyright (c) 2006 Jon Simola <jsimola@@gmail.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * PCI shim for Broadcom BCM43xx Wireless network chipsets (broadcom.com)
 * SiliconBackplane is technology from Sonics, Inc.(sonicsinc.com)
 */
 
/* standard includes, probably some extras */

#include <sys/cdefs.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/socket.h>

#include <machine/endian.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#ifdef INET
#include <netinet/in.h>
//#include <netinet/in_systm.h>
//#include <netinet/in_var.h>
//#include <netinet/ip.h>
#include <netinet/if_ether.h>
#endif
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_radiotap.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/ic/bcwreg.h>
#include <dev/ic/bcwvar.h>

#include <uvm/uvm_extern.h>

const struct pci_matchid bcw_pci_devices[]  = {
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4303 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4306 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4306_2 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4307 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4309 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4311 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4312 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4318 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4319 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM4322 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM43XG }
};

struct bcw_pci_softc {
	struct bcw_softc	 psc_bcw;		/* Real softc */
	void			*psc_ih;
	pci_chipset_tag_t	 psc_pc;		/* our PCI chipset */
	pcitag_t		 psc_pcitag;		/* our PCI tag */
};

int		bcw_pci_match(struct device *, void *, void *);
void		bcw_pci_attach(struct device *, struct device *, void *);
void		bcw_pci_conf_write(void *, uint32_t, uint32_t);
uint32_t	bcw_pci_conf_read(void *, uint32_t);

struct cfattach bcw_pci_ca = {
	sizeof(struct bcw_pci_softc), bcw_pci_match, bcw_pci_attach
};

int
bcw_pci_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, bcw_pci_devices,
	    sizeof(bcw_pci_devices) / sizeof(bcw_pci_devices[0])));
}

void
bcw_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct bcw_pci_softc *psc = (void *)self;
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	struct bcw_softc *sc = &psc->psc_bcw;
	pci_chipset_tag_t pc = pa->pa_pc;
	bus_size_t memsize;
	const char *intrstr = NULL;
	pci_intr_handle_t ih;
	int error;

	sc->sc_dmat = pa->pa_dmat;
	psc->psc_pc = pa->pa_pc;
	psc->psc_pcitag = pa->pa_tag;
	sc->sc_dev_softc = psc;
#if 0
	/* Get it out of power save mode if needed. */
	if (pci_get_capability(pc, pa->pa_tag, PCI_CAP_PWRMGMT, &pmreg, 0)) {
		pmode = pci_conf_read(pc, pa->pa_tag, pmreg + 4) & 0x3;
		if (pmode == 3) {
			/*
			 * The card has lost all configuration data in
			 * this state, so punt.
			 */
			printf("%s: unable to wake up from power state D3\n",
			    sc->sc_dev.dv_xname);
			return;
		}
		if (pmode != 0) {
			printf("%s: waking up from power state D%d\n",
			    sc->sc_dev.dv_xname, pmode);
			pci_conf_write(pc, pa->pa_tag, pmreg + 4, 0);
		}
	}
#endif
	/* map control / status registers */
	error = pci_mapreg_map(pa, BCW_PCI_BAR0,
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,
	    &sc->sc_iot, &sc->sc_ioh, NULL, &memsize, 0);
	if (error != 0) {
		printf(": could not map memory space\n");
		return;
	}

	/* map interrupt */
	if (pci_intr_map(pa, &ih) != 0) {
		printf(": couldn't map interrupt\n");
		return;
	}

	/* establish interrupt */
	intrstr = pci_intr_string(pc, ih);
	psc->psc_ih = pci_intr_establish(pc, ih, IPL_NET, bcw_intr, sc,
	    sc->sc_dev.dv_xname);
	if (psc->psc_ih == NULL) {
		printf("%s: couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s", intrstr);

	/* map function pointers which we need later in the device code */
	sc->sc_conf_write = bcw_pci_conf_write;
	sc->sc_conf_read = bcw_pci_conf_read;

	/*
	 * Get some PCI based info into the softc
	 */
	sc->sc_board_vendor = PCI_VENDOR(pa->pa_id);
	sc->sc_prodid = PCI_PRODUCT(pa->pa_id); /* XXX */
	sc->sc_board_type = sc->sc_prodid; /* XXX */
	sc->sc_board_rev = PCI_REVISION(pa->pa_class);

	/*
	 * Finish the attach
	 */
	bcw_attach(sc);
}

void
bcw_pci_conf_write(void *self, uint32_t reg, uint32_t val)
{
	struct bcw_pci_softc *psc = (struct bcw_pci_softc *)self;

	pci_conf_write(psc->psc_pc, psc->psc_pcitag, reg, val);
}

uint32_t
bcw_pci_conf_read(void *self, uint32_t reg)
{
	struct bcw_pci_softc *psc = (struct bcw_pci_softc *)self;

	return (pci_conf_read(psc->psc_pc, psc->psc_pcitag, reg));
}
@


1.16
log
@There is no need to keep the intrstr in the drivers softc struct.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_pci.c,v 1.15 2007/03/31 09:48:02 mglocker Exp $ */
@


1.15
log
@Enable interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_pci.c,v 1.14 2007/03/04 11:04:18 mglocker Exp $ */
d85 1
a85 2
	pci_intr_handle_t	 psc_ih;		/* interrupt handle */
	void			*psc_intrcookie;
d114 2
d152 1
a152 1
	if (pci_intr_map(pa, &psc->psc_ih) != 0) {
d158 4
a161 4
	sc->bcw_intrstr = pci_intr_string(pc, psc->psc_ih);
	psc->psc_intrcookie = pci_intr_establish(pc, psc->psc_ih, IPL_NET, 
	    bcw_intr, sc, sc->sc_dev.dv_xname);
	if (psc->psc_intrcookie == NULL) {
d163 2
a164 2
		if (sc->bcw_intrstr != NULL)
			printf(" at %s", sc->bcw_intrstr);
d168 1
a168 1
	printf(": %s", sc->bcw_intrstr);
@


1.14
log
@Fix strict alignment panic.  Makes my BCM4306 attach on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_pci.c,v 1.13 2007/03/04 00:43:26 mglocker Exp $ */
a113 2
	pcireg_t memtype;
	bus_addr_t memaddr;
d115 1
a115 2
	int pmreg;
	pcireg_t pmode;
d121 1
a121 1

d140 7
a146 15

	/*
	 * Map control/status registers.
	 */
	/* Copied from pre-abstraction, via if_bce.c */
	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, BCW_PCI_BAR0);
	switch (memtype) {
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
		if (pci_mapreg_map(pa, BCW_PCI_BAR0, memtype, 0, &sc->sc_iot,
		    &sc->sc_ioh, &memaddr, &memsize, 0) == 0)
			break;
	default:
		printf("%s: unable to find mem space\n",
		    sc->sc_dev.dv_xname);
d150 3
a152 4
	/* Map the PCI interrupt */
	if (pci_intr_map(pa, &psc->psc_ih)) {
		printf("%s: couldn't map interrupt\n",
		    sc->sc_dev.dv_xname);
d156 1
a157 1

a159 1

d161 1
a161 2
		printf("%s: couldn't establish interrupt",
		    sc->sc_dev.dv_xname);
a166 1

d169 1
a179 17

	/*
	 * Start the card up while we're in PCI land
	 */

	/* Turn the Crystal On */
	bcw_powercontrol_crystal_on(sc);

	/*
	 * Clear PCI_STATUS_TARGET_TARGET_ABORT, Docs and Linux call it 
	 * PCI_STATUS_SIG_TARGET_ABORT - should use pci_conf_read/write?
	 */
	pci_conf_write(pa->pa_pc, pa->pa_tag,
	    PCI_COMMAND_STATUS_REG,
	    pci_conf_read(pa->pa_pc, pa->pa_tag,
	    PCI_COMMAND_STATUS_REG)
	    & ~PCI_STATUS_TARGET_TARGET_ABORT);
@


1.13
log
@Kill a cardbus dependency which breaked kernel compilation e.g. for
sparc*.

OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_pci.c,v 1.12 2007/02/26 14:36:11 mglocker Exp $ */
d191 3
a193 3
	sc->sc_board_type = sc->sc_conf_read(sc, 0x2e); /* XXX right one? */
	sc->sc_board_rev = PCI_REVISION(pa->pa_class); /* XXX right one? */
	sc->sc_prodid = PCI_PRODUCT(pa->pa_id);
@


1.12
log
@Some KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_pci.c,v 1.11 2007/02/26 14:28:19 mglocker Exp $ */
a62 1
#include <dev/cardbus/cardbusvar.h>
d93 2
a94 2
void		bcw_pci_conf_write(struct bcw_softc *, uint32_t, uint32_t);
uint32_t	bcw_pci_conf_read(struct bcw_softc *, uint32_t);
d110 2
a111 1
	struct bcw_pci_softc *psc = (void *) self;
a112 1
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
d120 1
d123 1
a123 2
	sc->sc_pa.pa_pc = pa->pa_pc;
	sc->sc_pa.pa_tag = pa->pa_tag;
a160 2
	sc->sc_dmat = pa->pa_dmat;

d219 1
a219 1
bcw_pci_conf_write(struct bcw_softc *sc, uint32_t reg, uint32_t val)
d221 3
a223 1
	pci_conf_write(sc->sc_pa.pa_pc, sc->sc_pa.pa_tag, reg, val);
d227 1
a227 1
bcw_pci_conf_read(struct bcw_softc *sc, uint32_t reg)
d229 3
a231 1
	return (pci_conf_read(sc->sc_pa.pa_pc, sc->sc_pa.pa_tag, reg));
@


1.11
log
@Remove PCI powerhooks, bcw_pci_enable() and bcw_pci_disable().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_pci.c,v 1.10 2007/02/26 14:14:02 mglocker Exp $ */
a83 1

d85 2
a86 2
	struct bcw_softc	psc_bcw;	/* Real softc */
	pci_intr_handle_t	psc_ih;		/* interrupt handle */
d88 2
a89 2
	pci_chipset_tag_t	psc_pc;		/* our PCI chipset */
	pcitag_t		psc_pcitag;	/* our PCI tag */
d94 2
a95 2
void		bcw_pci_conf_write(struct bcw_softc *, u_int32_t, u_int32_t);
u_int32_t	bcw_pci_conf_read(struct bcw_softc *, u_int32_t);
a100 1

d104 2
a105 2
	return pci_matchbyid((struct pci_attach_args *)aux, bcw_pci_devices,
	    sizeof(bcw_pci_devices) / sizeof(bcw_pci_devices[0]));
d115 5
a119 5
	pcireg_t	memtype;
	bus_addr_t	memaddr;
	bus_size_t	memsize;
	int		pmreg;
	pcireg_t	pmode;
d212 1
a212 1
		PCI_COMMAND_STATUS_REG)
a217 1

d222 1
a222 1
bcw_pci_conf_write(struct bcw_softc *sc, u_int32_t reg, u_int32_t val)
d227 2
a228 2
u_int32_t
bcw_pci_conf_read(struct bcw_softc *sc, u_int32_t reg)
d230 1
a230 1
	return pci_conf_read(sc->sc_pa.pa_pc, sc->sc_pa.pa_tag, reg);
@


1.10
log
@We need to save some PCI infos in our softc struct for further decisions
in the driver code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_pci.c,v 1.9 2007/02/24 23:05:04 mglocker Exp $ */
a93 2
int		bcw_pci_enable(struct bcw_softc *sc);
void		bcw_pci_disable(struct bcw_softc *sc);
a109 27
int
bcw_pci_enable(struct bcw_softc *sc)
{
	struct bcw_pci_softc *psc = (void *)sc;
	
	/* Establish PCI interrupt */
	psc->psc_intrcookie = pci_intr_establish(psc->psc_pc, psc->psc_ih,
	    IPL_NET, bcw_intr, sc, sc->sc_dev.dv_xname);
	if(psc->psc_intrcookie == NULL) {
		printf("%s: unable to establish interrupt\n",
		    sc->sc_dev.dv_xname);
		return (1);
	}
	
	return (0);
}

void
bcw_pci_disable(struct bcw_softc *sc)
{
	struct bcw_pci_softc *psc = (void *)sc;
	
	/* Remove PCI interrupt */
	pci_intr_disestablish(psc->psc_pc, psc->psc_intrcookie);
	psc->psc_intrcookie = NULL;
}

a188 2
	sc->sc_enable = bcw_pci_enable;
	sc->sc_disable = bcw_pci_disable;
@


1.9
log
@Get correct chip revision and also get chip package.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_pci.c,v 1.8 2007/01/03 10:01:34 mglocker Exp $ */
d226 3
@


1.8
log
@Don't wrap line before printing MAC address.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_pci.c,v 1.7 2006/12/08 01:28:40 mglocker Exp $ */
a225 1
	sc->sc_chiprev = PCI_REVISION(pa->pa_class);
@


1.7
log
@From Jon Simola <simola@@mecha.com>:

Style and whitespace cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_pci.c,v 1.6 2006/12/06 19:21:45 mglocker Exp $ */
d216 1
a216 1
	printf(": %s\n", sc->bcw_intrstr);
@


1.6
log
@From Jon Simola <simola@@mecha.com>:

Add bus-specific config space read and write functions, this fixes the
attach for ian@@darwinsys.com and properly enumerates multiple cores.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_pci.c,v 1.5 2006/11/29 21:34:06 mglocker Exp $ */
a86 1

a88 1
	
d109 1
a109 1
	    sizeof (bcw_pci_devices) / sizeof (bcw_pci_devices[0]));
d146 5
a150 5
	pcireg_t        memtype;
	bus_addr_t      memaddr;
	bus_size_t      memsize;
	int             pmreg;
	pcireg_t        pmode;
d166 1
a166 1
			       sc->sc_dev.dv_xname);
d171 1
a171 1
			       sc->sc_dev.dv_xname, pmode);
a175 1

a194 1

d226 2
a227 2
	sc->sc_chiprev=PCI_REVISION(pa->pa_class);
	sc->sc_prodid=PCI_PRODUCT(pa->pa_id);
d243 1
a243 1
	        PCI_COMMAND_STATUS_REG)
a244 1
	
@


1.5
log
@From Jon Simola <simola@@mecha.com>:

New bcw_powercontrol_crystal_on() function, and fix the license for the
pci wrapper.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_pci.c,v 1.4 2006/11/22 23:46:49 brad Exp $ */
d63 1
d99 2
d156 2
d224 2
d244 1
a244 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh,
d246 1
a246 1
	    bus_space_read_4(sc->sc_iot, sc->sc_ioh,
d256 12
@


1.4
log
@add the BCM4312 PCI id.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_pci.c,v 1.3 2006/11/22 15:20:07 mglocker Exp $ */
a4 1
 * Copyright (c) 2003 Clifford Wright. All rights reserved.
d6 3
a8 10
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d10 7
a16 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d139 1
a139 3
bcw_pci_attach(parent, self, aux)
	struct device  *parent, *self;
	void           *aux;
a149 1
	u_int32_t	sbval;
d231 2
a232 12
	sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_GPIOI);
	if ((sbval & BCW_XTALPOWERUP) != BCW_XTALPOWERUP) {
	    sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_GPIOO);
	    sbval |= (BCW_XTALPOWERUP & BCW_PLLPOWERDOWN);
	    bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_GPIOO, sbval);
	    delay(1000);
	    sbval = bus_space_read_4(sc->sc_iot, sc->sc_ioh, BCW_GPIOO);
	    sbval &= ~BCW_PLLPOWERDOWN;
	    bus_space_write_4(sc->sc_iot, sc->sc_ioh, BCW_GPIOO, sbval);
	    delay(5000);
	}
	
@


1.3
log
@Some more minor cleanup in the PCI hookup.

From Jon Simola <jon@@mecha.ca>.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_pci.c,v 1.2 2006/11/21 11:41:14 mglocker Exp $ */
d88 1
@


1.2
log
@From Jon Simola <simola@@mecha.com>:

Lots of help from Jonathan Gray. bcw_regs has been removed,
and DMA/descriptor style changes that look more normal. Tested,
no loss in current unfunctionality.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bcw_pci.c,v 1.1 2006/11/17 18:58:30 mglocker Exp $ */
a157 4
//	const char     *intrstr = NULL;
//	caddr_t         kva;
//	bus_dma_segment_t seg;
//	int             rseg;
a160 3
//	bus_space_tag_t	memt;
//	bus_space_handle_t	memh;
//	int		ioh_valid, memh_valid;
a162 3

//	int             error;
//	int             i,j;
@


1.1
log
@This is a very initial import for a driver which supports the IEEE 802.11
Broadcom BCM43xx chipset.  Device attaches, but has no further
functionality yet.

The work has been done by Jon Simola <jsimola@@gmail.com>, based on the
existing bce(4) code.  He will continue to work on the driver and try
to make further progress.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d129 1
a129 1
	    IPL_NET, bcw_intr, sc, sc->bcw_dev.dv_xname);
d132 1
a132 1
		    sc->bcw_dev.dv_xname);
a155 1
	struct bcw_regs *regs = &sc->bcw_regs;
d187 1
a187 1
			       sc->bcw_dev.dv_xname);
d192 1
a192 1
			       sc->bcw_dev.dv_xname, pmode);
d206 2
a207 2
		if (pci_mapreg_map(pa, BCW_PCI_BAR0, memtype, 0, &sc->bcw_btag,
		    &sc->bcw_bhandle, &memaddr, &memsize, 0) == 0)
d211 1
a211 1
		    sc->bcw_dev.dv_xname);
a213 2
	regs->r_bt = sc->bcw_btag;
	regs->r_bh = sc->bcw_bhandle;
d215 1
a215 1
	sc->bcw_dmatag = pa->pa_dmat;
d221 1
a221 1
		    sc->bcw_dev.dv_xname);
d228 1
a228 1
	    bcw_intr, sc, sc->bcw_dev.dv_xname);
d232 1
a232 1
		    sc->bcw_dev.dv_xname);
d247 2
a248 2
	sc->bcw_chiprev=PCI_REVISION(pa->pa_class);
	sc->bcw_prodid=PCI_PRODUCT(pa->pa_id);
d255 1
a255 1
	sbval = bus_space_read_4(sc->bcw_btag, sc->bcw_bhandle, BCW_GPIOI);
d257 1
a257 1
	    sbval = bus_space_read_4(sc->bcw_btag, sc->bcw_bhandle, BCW_GPIOO);
d259 1
a259 1
	    bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_GPIOO, sbval);
d261 1
a261 1
	    sbval = bus_space_read_4(sc->bcw_btag, sc->bcw_bhandle, BCW_GPIOO);
d263 1
a263 1
	    bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle, BCW_GPIOO, sbval);
d271 1
a271 1
	bus_space_write_4(sc->bcw_btag, sc->bcw_bhandle,
d273 1
a273 1
	    bus_space_read_4(sc->bcw_btag, sc->bcw_bhandle,
@

