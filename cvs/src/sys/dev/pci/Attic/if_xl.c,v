head	1.39;
access;
symbols
	SMP_SYNC_A:1.39
	SMP_SYNC_B:1.39
	UBC_SYNC_A:1.39
	UBC_SYNC_B:1.39
	SMP:1.36.0.2
	SMP_BASE:1.36
	kame_19991208:1.33
	OPENBSD_2_6:1.31.0.2
	OPENBSD_2_6_BASE:1.31
	OPENBSD_2_5:1.23.0.2
	OPENBSD_2_5_BASE:1.23
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12;
locks; strict;
comment	@ * @;


1.39
date	2000.04.08.05.50.51;	author aaron;	state dead;
branches;
next	1.38;

1.38
date	2000.02.15.13.47.52;	author jason;	state Exp;
branches;
next	1.37;

1.37
date	2000.02.15.02.28.15;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	99.12.31.05.17.47;	author jason;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	99.12.16.22.15.45;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	99.12.16.21.53.03;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	99.12.07.20.23.19;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	99.12.07.20.19.36;	author jason;	state Exp;
branches;
next	1.31;

1.31
date	99.10.07.12.02.58;	author jason;	state Exp;
branches;
next	1.30;

1.30
date	99.09.26.17.50.07;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	99.09.16.16.27.31;	author jason;	state Exp;
branches;
next	1.28;

1.28
date	99.09.13.20.11.13;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	99.07.02.17.34.44;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	99.06.29.20.24.10;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	99.06.29.17.14.35;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	99.05.07.21.24.33;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	99.03.03.22.51.51;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	99.03.02.02.25.39;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	99.02.27.23.54.42;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	99.02.26.17.05.55;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	99.02.23.21.06.06;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	98.12.31.02.47.41;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	98.12.22.22.47.14;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	98.12.21.06.22.58;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	98.11.23.19.56.50;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	98.11.16.15.29.18;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	98.11.11.23.25.02;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	98.10.09.00.15.35;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.09.29.02.14.29;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	98.09.23.20.48.46;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	98.09.11.03.23.15;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	98.09.09.22.06.57;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	98.09.09.21.35.46;	author maja;	state Exp;
branches;
next	1.6;

1.6
date	98.09.08.03.02.57;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	98.09.04.12.58.12;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	98.09.03.06.24.19;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	98.09.02.06.04.47;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	98.09.02.04.49.12;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	98.09.02.03.01.05;	author jason;	state Exp;
branches;
next	;

1.36.2.1
date	2000.02.20.11.57.09;	author niklas;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2001.05.14.22.25.49;	author niklas;	state dead;
branches;
next	;


desc
@@


1.39
log
@Initial check-in for support of 32-bit CardBus PC Cards; from NetBSD. On many
machines, this code needs the new PCIBIOS* options enabled in the kernel config
file to work, but your mileage may vary. Included is a working 3c575 driver for
3Com 10/100 CardBus PC Card NICs (tested only with the 'C' revision). The 3c575
is the pccard version of the PCI EtherLink XL cards, and thus the xl driver has
been split into /sys/dev/ic.
@
text
@/*	$OpenBSD: if_xl.c,v 1.38 2000/02/15 13:47:52 jason Exp $	*/

/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: if_xl.c,v 1.72 2000/01/09 21:12:59 wpaul Exp $
 */

/*
 * 3Com 3c90x Etherlink XL PCI NIC driver
 *
 * Supports the 3Com "boomerang", "cyclone", and "hurricane" PCI
 * bus-master chips (3c90x cards and embedded controllers) including
 * the following:
 *
 * 3Com 3c900-TPO	10Mbps/RJ-45
 * 3Com 3c900-COMBO	10Mbps/RJ-45,AUI,BNC
 * 3Com 3c905-TX	10/100Mbps/RJ-45
 * 3Com 3c905-T4	10/100Mbps/RJ-45
 * 3Com 3c900B-TPO	10Mbps/RJ-45
 * 3Com 3c900B-COMBO	10Mbps/RJ-45,AUI,BNC
 * 3Com 3c900B-TPC	10Mbps/RJ-45,BNC
 * 3Com 3c900B-FL	10Mbps/Fiber-optic
 * 3Com 3c905B-COMBO	10/100Mbps/RJ-45,AUI,BNC
 * 3Com 3c905B-TX	10/100Mbps/RJ-45
 * 3Com 3c900-FL/FX	10/100Mbps/Fiber-optic
 * 3Com 3c905C-TX	10/100Mbps/RJ-45 (Tornado ASIC)
 * 3Com 3c450-TX	10/100Mbps/RJ-45 (Tornado ASIC)
 * 3Com 3c980-TX	10/100Mbps server adapter (Hurricane ASIC)
 * 3Com 3c980C-TX	10/100Mbps server adapter (Tornado ASIC)
 * 3Com 3cSOHO100-TX	10/100Mbps/RJ-45 (Hurricane ASIC)
 * Dell Optiplex GX1 on-board 3c918 10/100Mbps/RJ-45
 * Dell on-board 3c920	10/100Mbps/RJ-45
 * Dell Precision on-board 3c905B 10/100Mbps/RJ-45
 * Dell Latitude laptop docking station embedded 3c905-TX
 *
 * Written by Bill Paul <wpaul@@ctr.columbia.edu>
 * Electrical Engineering Department
 * Columbia University, New York City
 */

/*
 * The 3c90x series chips use a bus-master DMA interface for transfering
 * packets to and from the controller chip. Some of the "vortex" cards
 * (3c59x) also supported a bus master mode, however for those chips
 * you could only DMA packets to/from a contiguous memory buffer. For
 * transmission this would mean copying the contents of the queued mbuf
 * chain into a an mbuf cluster and then DMAing the cluster. This extra
 * copy would sort of defeat the purpose of the bus master support for
 * any packet that doesn't fit into a single mbuf.
 *
 * By contrast, the 3c90x cards support a fragment-based bus master
 * mode where mbuf chains can be encapsulated using TX descriptors.
 * This is similar to other PCI chips such as the Texas Instruments
 * ThunderLAN and the Intel 82557/82558.
 *
 * The "vortex" driver (if_vx.c) happens to work for the "boomerang"
 * bus master chips because they maintain the old PIO interface for
 * backwards compatibility, but starting with the 3c905B and the
 * "cyclone" chips, the compatibility interface has been dropped.
 * Since using bus master DMA is a big win, we use this driver to
 * support the PCI "boomerang" chips even though they work with the
 * "vortex" driver in order to obtain better performance.
 *
 * This driver is in the /sys/pci directory because it only supports
 * PCI-based NICs.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */
#include <sys/device.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/if_media.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#endif

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <vm/vm.h>              /* for vtophys */
#include <vm/pmap.h>            /* for vtophys */

/*
 * The following #define causes the code to use PIO to access the
 * chip's registers instead of memory mapped mode. The reason PIO mode
 * is on by default is that the Etherlink XL manual seems to indicate
 * that only the newer revision chips (3c905B) support both PIO and
 * memory mapped access. Since we want to be compatible with the older
 * bus master chips, we use PIO here. If you comment this out, the
 * driver will use memory mapped I/O, which may be faster but which
 * might not work on some devices.
 */
#define XL_USEIOSPACE

#include <dev/pci/if_xlreg.h>

int xl_probe		__P((struct device *, void *, void *));
void xl_attach		__P((struct device *, struct device *, void *));

int xl_newbuf		__P((struct xl_softc *, struct xl_chain_onefrag *));
void xl_stats_update	__P((void *));
int xl_encap		__P((struct xl_softc *, struct xl_chain *,
    struct mbuf * ));
int xl_encap_90xB	__P((struct xl_softc *, struct xl_chain *,
    struct mbuf * ));
void xl_rxeof		__P((struct xl_softc *));
int xl_rx_resync	__P((struct xl_softc *));
void xl_txeof		__P((struct xl_softc *));
void xl_txeof_90xB	__P((struct xl_softc *));
void xl_txeoc		__P((struct xl_softc *));
int xl_intr		__P((void *));
void xl_start		__P((struct ifnet *));
void xl_start_90xB	__P((struct ifnet *));
int xl_ioctl		__P((struct ifnet *, u_long, caddr_t));
void xl_init		__P((void *));
void xl_stop		__P((struct xl_softc *));
void xl_watchdog	__P((struct ifnet *));
void xl_shutdown	__P((void *));
int xl_ifmedia_upd	__P((struct ifnet *));
void xl_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));

int xl_eeprom_wait	__P((struct xl_softc *));
int xl_read_eeprom	__P((struct xl_softc *, caddr_t, int, int, int));
void xl_mii_sync	__P((struct xl_softc *));
void xl_mii_send	__P((struct xl_softc *, u_int32_t, int));
int xl_mii_readreg	__P((struct xl_softc *, struct xl_mii_frame *));
int xl_mii_writereg	__P((struct xl_softc *, struct xl_mii_frame *));

void xl_setcfg		__P((struct xl_softc *));
void xl_setmode		__P((struct xl_softc *, int));
u_int8_t xl_calchash	__P((caddr_t));
void xl_setmulti	__P((struct xl_softc *));
void xl_setmulti_hash	__P((struct xl_softc *));
void xl_reset		__P((struct xl_softc *, int));
int xl_list_rx_init	__P((struct xl_softc *));
int xl_list_tx_init	__P((struct xl_softc *));
int xl_list_tx_init_90xB	__P((struct xl_softc *));
void xl_wait		__P((struct xl_softc *));
void xl_mediacheck	__P((struct xl_softc *));
void xl_choose_xcvr	__P((struct xl_softc *, int));
#ifdef notdef
void xl_testpacket	__P((struct xl_softc *));
#endif

int xl_miibus_readreg	__P((struct device *, int, int));
void xl_miibus_writereg	__P((struct device *, int, int, int));
void xl_miibus_statchg	__P((struct device *));

/*
 * Murphy's law says that it's possible the chip can wedge and
 * the 'command in progress' bit may never clear. Hence, we wait
 * only a finite amount of time to avoid getting caught in an
 * infinite loop. Normally this delay routine would be a macro,
 * but it isn't called during normal operation so we can afford
 * to make it a function.
 */
void xl_wait(sc)
	struct xl_softc		*sc;
{
	register int		i;

	for (i = 0; i < XL_TIMEOUT; i++) {
		if (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))
			break;
	}

#ifdef DIAGNOSTIC
	if (i == XL_TIMEOUT)
		printf("xl%d: command never completed!\n", sc->xl_unit);
#endif

	return;
}

/*
 * MII access routines are provided for adapters with external
 * PHYs (3c905-TX, 3c905-T4, 3c905B-T4) and those with built-in
 * autoneg logic that's faked up to look like a PHY (3c905B-TX).
 * Note: if you don't perform the MDIO operations just right,
 * it's possible to end up with code that works correctly with
 * some chips/CPUs/processor speeds/bus speeds/etc but not
 * with others.
 */
#define MII_SET(x)					\
	CSR_WRITE_2(sc, XL_W4_PHY_MGMT,			\
		CSR_READ_2(sc, XL_W4_PHY_MGMT) | x)

#define MII_CLR(x)					\
	CSR_WRITE_2(sc, XL_W4_PHY_MGMT,			\
		CSR_READ_2(sc, XL_W4_PHY_MGMT) & ~x)

/*
 * Sync the PHYs by setting data bit and strobing the clock 32 times.
 */
void xl_mii_sync(sc)
	struct xl_softc		*sc;
{
	register int		i;

	XL_SEL_WIN(4);
	MII_SET(XL_MII_DIR|XL_MII_DATA);

	for (i = 0; i < 32; i++) {
		MII_SET(XL_MII_CLK);
		DELAY(1);
		MII_CLR(XL_MII_CLK);
		DELAY(1);
	}

	return;
}

/*
 * Clock a series of bits through the MII.
 */
void xl_mii_send(sc, bits, cnt)
	struct xl_softc		*sc;
	u_int32_t		bits;
	int			cnt;
{
	int			i;

	XL_SEL_WIN(4);
	MII_CLR(XL_MII_CLK);

	for (i = (0x1 << (cnt - 1)); i; i >>= 1) {
                if (bits & i) {
			MII_SET(XL_MII_DATA);
                } else {
			MII_CLR(XL_MII_DATA);
                }
		DELAY(1);
		MII_CLR(XL_MII_CLK);
		DELAY(1);
		MII_SET(XL_MII_CLK);
	}
}

/*
 * Read an PHY register through the MII.
 */
int xl_mii_readreg(sc, frame)
	struct xl_softc		*sc;
	struct xl_mii_frame	*frame;
	
{
	int			i, ack, s;

	s = splimp();

	/*
	 * Set up frame for RX.
	 */
	frame->mii_stdelim = XL_MII_STARTDELIM;
	frame->mii_opcode = XL_MII_READOP;
	frame->mii_turnaround = 0;
	frame->mii_data = 0;
	
	/*
	 * Select register window 4.
	 */

	XL_SEL_WIN(4);

	CSR_WRITE_2(sc, XL_W4_PHY_MGMT, 0);
	/*
 	 * Turn on data xmit.
	 */
	MII_SET(XL_MII_DIR);

	xl_mii_sync(sc);

	/*
	 * Send command/address info.
	 */
	xl_mii_send(sc, frame->mii_stdelim, 2);
	xl_mii_send(sc, frame->mii_opcode, 2);
	xl_mii_send(sc, frame->mii_phyaddr, 5);
	xl_mii_send(sc, frame->mii_regaddr, 5);

	/* Idle bit */
	MII_CLR((XL_MII_CLK|XL_MII_DATA));
	DELAY(1);
	MII_SET(XL_MII_CLK);
	DELAY(1);

	/* Turn off xmit. */
	MII_CLR(XL_MII_DIR);

	/* Check for ack */
	MII_CLR(XL_MII_CLK);
	DELAY(1);
	MII_SET(XL_MII_CLK);
	DELAY(1);
	ack = CSR_READ_2(sc, XL_W4_PHY_MGMT) & XL_MII_DATA;

	/*
	 * Now try reading data bits. If the ack failed, we still
	 * need to clock through 16 cycles to keep the PHY(s) in sync.
	 */
	if (ack) {
		for(i = 0; i < 16; i++) {
			MII_CLR(XL_MII_CLK);
			DELAY(1);
			MII_SET(XL_MII_CLK);
			DELAY(1);
		}
		goto fail;
	}

	for (i = 0x8000; i; i >>= 1) {
		MII_CLR(XL_MII_CLK);
		DELAY(1);
		if (!ack) {
			if (CSR_READ_2(sc, XL_W4_PHY_MGMT) & XL_MII_DATA)
				frame->mii_data |= i;
			DELAY(1);
		}
		MII_SET(XL_MII_CLK);
		DELAY(1);
	}

fail:

	MII_CLR(XL_MII_CLK);
	DELAY(1);
	MII_SET(XL_MII_CLK);
	DELAY(1);

	splx(s);

	if (ack)
		return(1);
	return(0);
}

/*
 * Write to a PHY register through the MII.
 */
int xl_mii_writereg(sc, frame)
	struct xl_softc		*sc;
	struct xl_mii_frame	*frame;
	
{
	int			s;

	s = splimp();
	/*
	 * Set up frame for TX.
	 */

	frame->mii_stdelim = XL_MII_STARTDELIM;
	frame->mii_opcode = XL_MII_WRITEOP;
	frame->mii_turnaround = XL_MII_TURNAROUND;
	
	/*
	 * Select the window 4.
	 */
	XL_SEL_WIN(4);

	/*
 	 * Turn on data output.
	 */
	MII_SET(XL_MII_DIR);

	xl_mii_sync(sc);

	xl_mii_send(sc, frame->mii_stdelim, 2);
	xl_mii_send(sc, frame->mii_opcode, 2);
	xl_mii_send(sc, frame->mii_phyaddr, 5);
	xl_mii_send(sc, frame->mii_regaddr, 5);
	xl_mii_send(sc, frame->mii_turnaround, 2);
	xl_mii_send(sc, frame->mii_data, 16);

	/* Idle bit. */
	MII_SET(XL_MII_CLK);
	DELAY(1);
	MII_CLR(XL_MII_CLK);
	DELAY(1);

	/*
	 * Turn off xmit.
	 */
	MII_CLR(XL_MII_DIR);

	splx(s);

	return(0);
}

int
xl_miibus_readreg(self, phy, reg)
	struct device *self;
	int phy, reg;
{
	struct xl_softc *sc = (struct xl_softc *)self;
	struct xl_mii_frame	frame;

	if (phy != 24)
		return (0);

	bzero((char *)&frame, sizeof(frame));

	frame.mii_phyaddr = phy;
	frame.mii_regaddr = reg;
	xl_mii_readreg(sc, &frame);

	return(frame.mii_data);
}

void
xl_miibus_writereg(self, phy, reg, data)
	struct device *self;
	int phy, reg, data;
{
	struct xl_softc *sc = (struct xl_softc *)self;
	struct xl_mii_frame	frame;

	if (phy != 24)
		return;

	bzero((char *)&frame, sizeof(frame));

	frame.mii_phyaddr = phy;
	frame.mii_regaddr = reg;
	frame.mii_data = data;

	xl_mii_writereg(sc, &frame);
}

void
xl_miibus_statchg(self)
	struct device *self;
{
	struct xl_softc *sc = (struct xl_softc *)self;

	xl_setcfg(sc);

	XL_SEL_WIN(3);
	if ((sc->sc_mii.mii_media_active & IFM_GMASK) == IFM_FDX)
		CSR_WRITE_1(sc, XL_W3_MAC_CTRL, XL_MACCTRL_DUPLEX);
	else
		CSR_WRITE_1(sc, XL_W3_MAC_CTRL,
		    (CSR_READ_1(sc, XL_W3_MAC_CTRL) & ~XL_MACCTRL_DUPLEX));
}

/*
 * The EEPROM is slow: give it time to come ready after issuing
 * it a command.
 */
int xl_eeprom_wait(sc)
	struct xl_softc		*sc;
{
	int			i;

	for (i = 0; i < 100; i++) {
		if (CSR_READ_2(sc, XL_W0_EE_CMD) & XL_EE_BUSY)
			DELAY(162);
		else
			break;
	}

	if (i == 100) {
		printf("xl%d: eeprom failed to come ready\n", sc->xl_unit);
		return(1);
	}

	return(0);
}

/*
 * Read a sequence of words from the EEPROM. Note that ethernet address
 * data is stored in the EEPROM in network byte order.
 */
int xl_read_eeprom(sc, dest, off, cnt, swap)
	struct xl_softc		*sc;
	caddr_t			dest;
	int			off;
	int			cnt;
	int			swap;
{
	int			err = 0, i;
	u_int16_t		word = 0, *ptr;

	XL_SEL_WIN(0);

	if (xl_eeprom_wait(sc))
		return(1);

	for (i = 0; i < cnt; i++) {
		CSR_WRITE_2(sc, XL_W0_EE_CMD, XL_EE_READ | (off + i));
		err = xl_eeprom_wait(sc);
		if (err)
			break;
		word = CSR_READ_2(sc, XL_W0_EE_DATA);
		ptr = (u_int16_t *)(dest + (i * 2));
		if (swap)
			*ptr = ntohs(word);
		else
			*ptr = word;	
	}

	return(err ? 1 : 0);
}

/*
 * This routine is taken from the 3Com Etherlink XL manual,
 * page 10-7. It calculates a CRC of the supplied multicast
 * group address and returns the lower 8 bits, which are used
 * as the multicast filter position.
 * Note: the 3c905B currently only supports a 64-bit hash table,
 * which means we really only need 6 bits, but the manual indicates
 * that future chip revisions will have a 256-bit hash table,
 * hence the routine is set up to calculate 8 bits of position
 * info in case we need it some day.
 * Note II, The Sequel: _CURRENT_ versions of the 3c905B have a
 * 256 bit hash table. This means we have to use all 8 bits regardless.
 * On older cards, the upper 2 bits will be ignored. Grrrr....
 */
u_int8_t xl_calchash(addr)
	caddr_t			addr;
{
	u_int32_t		crc, carry;
	int			i, j;
	u_int8_t		c;

	/* Compute CRC for the address value. */
	crc = 0xFFFFFFFF; /* initial value */

	for (i = 0; i < 6; i++) {
		c = *(addr + i);
		for (j = 0; j < 8; j++) {
			carry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);
			crc <<= 1;
			c >>= 1;
			if (carry)
				crc = (crc ^ 0x04c11db6) | carry;
		}
	}

	/* return the filter bit position */
	return(crc & 0x000000FF);
}

/*
 * NICs older than the 3c905B have only one multicast option, which
 * is to enable reception of all multicast frames.
 */
void xl_setmulti(sc)
	struct xl_softc		*sc;
{
	struct ifnet		*ifp;
	struct arpcom *ac = &sc->arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	u_int8_t		rxfilt;
	int			mcnt = 0;

	ifp = &sc->arpcom.ac_if;

	XL_SEL_WIN(5);
	rxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);

	if (ifp->if_flags & IFF_ALLMULTI) {
		rxfilt |= XL_RXFILTER_ALLMULTI;
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);
		return;
	}

	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		mcnt++;
		ETHER_NEXT_MULTI(step, enm);
	}

	if (mcnt)
		rxfilt |= XL_RXFILTER_ALLMULTI;
	else
		rxfilt &= ~XL_RXFILTER_ALLMULTI;

	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);

	return;
}

/*
 * 3c905B adapters have a hash filter that we can program.
 */
void xl_setmulti_hash(sc)
	struct xl_softc		*sc;
{
	struct ifnet		*ifp;
	int			h = 0, i;
	struct arpcom *ac = &sc->arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	u_int8_t		rxfilt;
	int			mcnt = 0;

	ifp = &sc->arpcom.ac_if;

	XL_SEL_WIN(5);
	rxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);

	if (ifp->if_flags & IFF_ALLMULTI) {
allmulti:
		rxfilt |= XL_RXFILTER_ALLMULTI;
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);
		return;
	} else
		rxfilt &= ~XL_RXFILTER_ALLMULTI;


	/* first, zot all the existing hash bits */
	for (i = 0; i < XL_HASHFILT_SIZE; i++)
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_HASH|i);

	/* now program new ones */
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}
		h = xl_calchash(enm->enm_addrlo);
		mcnt++;
		ETHER_NEXT_MULTI(step, enm);
	}

	if (mcnt)
		rxfilt |= XL_RXFILTER_MULTIHASH;
	else
		rxfilt &= ~XL_RXFILTER_MULTIHASH;

	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);

	return;
}

#ifdef notdef
void xl_testpacket(sc)
	struct xl_softc		*sc;
{
	struct mbuf		*m;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	MGETHDR(m, M_DONTWAIT, MT_DATA);

	if (m == NULL)
		return;

	bcopy(&sc->arpcom.ac_enaddr,
		mtod(m, struct ether_header *)->ether_dhost, ETHER_ADDR_LEN);
	bcopy(&sc->arpcom.ac_enaddr,
		mtod(m, struct ether_header *)->ether_shost, ETHER_ADDR_LEN);
	mtod(m, struct ether_header *)->ether_type = htons(3);
	mtod(m, unsigned char *)[14] = 0;
	mtod(m, unsigned char *)[15] = 0;
	mtod(m, unsigned char *)[16] = 0xE3;
	m->m_len = m->m_pkthdr.len = sizeof(struct ether_header) + 3;
	IF_ENQUEUE(&ifp->if_snd, m);
	xl_start(ifp);

	return;
}
#endif

void xl_setcfg(sc)
	struct xl_softc *sc;
{
	u_int32_t icfg;

	XL_SEL_WIN(3);
	icfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG);
	icfg &= ~XL_ICFG_CONNECTOR_MASK;
	if (sc->xl_media & XL_MEDIAOPT_MII ||
	    sc->xl_media & XL_MEDIAOPT_BT4)
		icfg |= (XL_XCVR_MII << XL_ICFG_CONNECTOR_BITS);
	if (sc->xl_media & XL_MEDIAOPT_BTX)
		icfg |= (XL_XCVR_AUTO << XL_ICFG_CONNECTOR_BITS);

	CSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);
	CSR_WRITE_4(sc, XL_COMMAND, XL_CMD_COAX_STOP);
}

void xl_setmode(sc, media)
	struct xl_softc *sc;
	int media;
{
	u_int32_t icfg;
	u_int16_t mediastat;

	printf("xl%d: selecting ", sc->xl_unit);

	XL_SEL_WIN(4);
	mediastat = CSR_READ_2(sc, XL_W4_MEDIA_STATUS);
	XL_SEL_WIN(3);
	icfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG);

	if (sc->xl_media & XL_MEDIAOPT_BT) {
		if (IFM_SUBTYPE(media) == IFM_10_T) {
			printf("10baseT transceiver, ");
			sc->xl_xcvr = XL_XCVR_10BT;
			icfg &= ~XL_ICFG_CONNECTOR_MASK;
			icfg |= (XL_XCVR_10BT << XL_ICFG_CONNECTOR_BITS);
			mediastat |= XL_MEDIASTAT_LINKBEAT|
					XL_MEDIASTAT_JABGUARD;
			mediastat &= ~XL_MEDIASTAT_SQEENB;
		}
	}

	if (sc->xl_media & XL_MEDIAOPT_BFX) {
		if (IFM_SUBTYPE(media) == IFM_100_FX) {
			printf("100baseFX port, ");
			sc->xl_xcvr = XL_XCVR_100BFX;
			icfg &= ~XL_ICFG_CONNECTOR_MASK;
			icfg |= (XL_XCVR_100BFX << XL_ICFG_CONNECTOR_BITS);
			mediastat |= XL_MEDIASTAT_LINKBEAT;
			mediastat &= ~XL_MEDIASTAT_SQEENB;
		}
	}

	if (sc->xl_media & (XL_MEDIAOPT_AUI|XL_MEDIAOPT_10FL)) {
		if (IFM_SUBTYPE(media) == IFM_10_5) {
			printf("AUI port, ");
			sc->xl_xcvr = XL_XCVR_AUI;
			icfg &= ~XL_ICFG_CONNECTOR_MASK;
			icfg |= (XL_XCVR_AUI << XL_ICFG_CONNECTOR_BITS);
			mediastat &= ~(XL_MEDIASTAT_LINKBEAT|
					XL_MEDIASTAT_JABGUARD);
			mediastat |= ~XL_MEDIASTAT_SQEENB;
		}
		if (IFM_SUBTYPE(media) == IFM_10_FL) {
			printf("10baseFL transceiver, ");
			sc->xl_xcvr = XL_XCVR_AUI;
			icfg &= ~XL_ICFG_CONNECTOR_MASK;
			icfg |= (XL_XCVR_AUI << XL_ICFG_CONNECTOR_BITS);
			mediastat &= ~(XL_MEDIASTAT_LINKBEAT|
					XL_MEDIASTAT_JABGUARD);
			mediastat |= ~XL_MEDIASTAT_SQEENB;
		}
	}

	if (sc->xl_media & XL_MEDIAOPT_BNC) {
		if (IFM_SUBTYPE(media) == IFM_10_2) {
			printf("BNC port, ");
			sc->xl_xcvr = XL_XCVR_COAX;
			icfg &= ~XL_ICFG_CONNECTOR_MASK;
			icfg |= (XL_XCVR_COAX << XL_ICFG_CONNECTOR_BITS);
			mediastat &= ~(XL_MEDIASTAT_LINKBEAT|
					XL_MEDIASTAT_JABGUARD|
					XL_MEDIASTAT_SQEENB);
		}
	}

	if ((media & IFM_GMASK) == IFM_FDX ||
			IFM_SUBTYPE(media) == IFM_100_FX) {
		printf("full duplex\n");
		XL_SEL_WIN(3);
		CSR_WRITE_1(sc, XL_W3_MAC_CTRL, XL_MACCTRL_DUPLEX);
	} else {
		printf("half duplex\n");
		XL_SEL_WIN(3);
		CSR_WRITE_1(sc, XL_W3_MAC_CTRL,
			(CSR_READ_1(sc, XL_W3_MAC_CTRL) & ~XL_MACCTRL_DUPLEX));
	}

	if (IFM_SUBTYPE(media) == IFM_10_2)
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_START);
	else
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);
	CSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);
	XL_SEL_WIN(4);
	CSR_WRITE_2(sc, XL_W4_MEDIA_STATUS, mediastat);
	DELAY(800);
	XL_SEL_WIN(7);
}

void xl_reset(sc, hard)
	struct xl_softc		*sc;
{
	register int		i;

	XL_SEL_WIN(0);
	if (hard)
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET);
	else
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET | 0x0010);
	xl_wait(sc);

	for (i = 0; i < XL_TIMEOUT; i++) {
		DELAY(10);
		if (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))
			break;
	}

	DELAY(100000);

	/* Reset TX and RX. */
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);
	xl_wait(sc);
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);
	xl_wait(sc);

	/* Wait a little while for the chip to get its brains in order. */
	DELAY(100000);
        return;
}

int
xl_probe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct pci_attach_args *pa = (struct pci_attach_args *) aux;

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_3COM)
		return (0);

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_3COM_3CSOHO100TX:
	case PCI_PRODUCT_3COM_3C900TPO:
	case PCI_PRODUCT_3COM_3C900COMBO:
	case PCI_PRODUCT_3COM_3C900B:
	case PCI_PRODUCT_3COM_3C900BCOMBO:
	case PCI_PRODUCT_3COM_3C900BTPC:
	case PCI_PRODUCT_3COM_3C900BFL:
	case PCI_PRODUCT_3COM_3C905TX:
	case PCI_PRODUCT_3COM_3C905T4:
	case PCI_PRODUCT_3COM_3C905BTX:
	case PCI_PRODUCT_3COM_3C905BT4:
	case PCI_PRODUCT_3COM_3C905BCOMBO:
	case PCI_PRODUCT_3COM_3C905BFX:
	case PCI_PRODUCT_3COM_3C980TX:
	case PCI_PRODUCT_3COM_3C980CTX:
	case PCI_PRODUCT_3COM_3C905CTX:
	case PCI_PRODUCT_3COM_3C450:
		return (1);
	}
					
	return (0);
}

/*
 * This routine is a kludge to work around possible hardware faults
 * or manufacturing defects that can cause the media options register
 * (or reset options register, as it's called for the first generation
 * 3c90x adapters) to return an incorrect result. I have encountered
 * one Dell Latitude laptop docking station with an integrated 3c905-TX
 * which doesn't have any of the 'mediaopt' bits set. This screws up
 * the attach routine pretty badly because it doesn't know what media
 * to look for. If we find ourselves in this predicament, this routine
 * will try to guess the media options values and warn the user of a
 * possible manufacturing defect with his adapter/system/whatever.
 */
void xl_mediacheck(sc)
	struct xl_softc		*sc;
{
	/*
	 * If some of the media options bits are set, assume they are
	 * correct. If not, try to figure it out down below.
	 * XXX I should check for 10baseFL, but I don't have an adapter
	 * to test with.
	 */
	if (sc->xl_media & (XL_MEDIAOPT_MASK & ~XL_MEDIAOPT_VCO)) {
		/*
	 	 * Check the XCVR value. If it's not in the normal range
	 	 * of values, we need to fake it up here.
	 	 */
		if (sc->xl_xcvr <= XL_XCVR_AUTO)
			return;
		else {
			printf("xl%d: bogus xcvr value "
			"in EEPROM (%x)\n", sc->xl_unit, sc->xl_xcvr);
			printf("xl%d: choosing new default based "
				"on card type\n", sc->xl_unit);
		}
	} else {
		if (sc->xl_type == XL_TYPE_905B &&
		    sc->xl_media & XL_MEDIAOPT_10FL)
			return;
		printf("xl%d: WARNING: no media options bits set in "
			"the media options register!!\n", sc->xl_unit);
		printf("xl%d: this could be a manufacturing defect in "
			"your adapter or system\n", sc->xl_unit);
		printf("xl%d: attempting to guess media type; you "
			"should probably consult your vendor\n", sc->xl_unit);
	}

	xl_choose_xcvr(sc, 1);
}

void xl_choose_xcvr(sc, verbose)
	struct xl_softc *sc;
	int verbose;
{
	u_int16_t devid;

	/*
	 * Read the device ID from the EEPROM.
	 * This is what's loaded into the PCI device ID register, so it has
	 * to be correct otherwise we wouldn't have gotten this far.
	 */
	xl_read_eeprom(sc, (caddr_t)&devid, XL_EE_PRODID, 1, 0);

	switch(devid) {
	case TC_DEVICEID_BOOMERANG_10BT:	/* 3c900-TPO */
	case TC_DEVICEID_KRAKATOA_10BT:		/* 3c900B-TPO */
		sc->xl_media = XL_MEDIAOPT_BT;
		sc->xl_xcvr = XL_XCVR_10BT;
		if (verbose)
			printf("xl%d: guessing 10BaseT transceiver\n",
			    sc->xl_unit);
		break;
	case TC_DEVICEID_BOOMERANG_10BT_COMBO:	/* 3c900-COMBO */
	case TC_DEVICEID_KRAKATOA_10BT_COMBO:	/* 3c900B-COMBO */
		sc->xl_media = XL_MEDIAOPT_BT|XL_MEDIAOPT_BNC|XL_MEDIAOPT_AUI;
		sc->xl_xcvr = XL_XCVR_10BT;
		if (verbose)
			printf("xl%d: guessing COMBO (AUI/BNC/TP)\n",
			    sc->xl_unit);
		break;
	case TC_DEVICEID_KRAKATOA_10BT_TPC:	/* 3c900B-TPC */
		sc->xl_media = XL_MEDIAOPT_BT|XL_MEDIAOPT_BNC;
		sc->xl_xcvr = XL_XCVR_10BT;
		if (verbose)
			printf("xl%d: guessing TPC (BNC/TP)\n", sc->xl_unit);
		break;
	case TC_DEVICEID_CYCLONE_10FL:		/* 3c900B-FL */
		sc->xl_media = XL_MEDIAOPT_10FL;
		sc->xl_xcvr = XL_XCVR_AUI;
		if (verbose)
			printf("xl%d: guessing 10baseFL\n", sc->xl_unit);
		break;
	case TC_DEVICEID_BOOMERANG_10_100BT:	/* 3c905-TX */
		sc->xl_media = XL_MEDIAOPT_MII;
		sc->xl_xcvr = XL_XCVR_MII;
		if (verbose)
			printf("xl%d: guessing MII\n", sc->xl_unit);
		break;
	case TC_DEVICEID_BOOMERANG_100BT4:	/* 3c905-T4 */
	case TC_DEVICEID_CYCLONE_10_100BT4:	/* 3c905B-T4 */
		sc->xl_media = XL_MEDIAOPT_BT4;
		sc->xl_xcvr = XL_XCVR_MII;
		if (verbose)
			printf("xl%d: guessing 100BaseT4/MII\n", sc->xl_unit);
		break;
	case TC_DEVICEID_HURRICANE_10_100BT:	/* 3c905B-TX */
	case TC_DEVICEID_HURRICANE_10_100BT_SERV:/* 3c980-TX */
	case TC_DEVICEID_TORNADO_10_100BT_SERV:	/* 3c980C-TX */
	case TC_DEVICEID_HURRICANE_SOHO100TX:	/* 3cSOHO100-TX */
	case TC_DEVICEID_TORNADO_10_100BT:	/* 3c905C-TX */
	case TC_DEVICEID_TORNADO_HOMECONNECT:	/* 3c450-TX */
		sc->xl_media = XL_MEDIAOPT_BTX;
		sc->xl_xcvr = XL_XCVR_AUTO;
		if (verbose)
			printf("xl%d: guessing 10/100 internal\n",
			    sc->xl_unit);
		break;
	case TC_DEVICEID_CYCLONE_10_100_COMBO:	/* 3c905B-COMBO */
		sc->xl_media = XL_MEDIAOPT_BTX|XL_MEDIAOPT_BNC|XL_MEDIAOPT_AUI;
		sc->xl_xcvr = XL_XCVR_AUTO;
		if (verbose)
			printf("xl%d: guessing 10/100 plus BNC/AUI\n",
			    sc->xl_unit);
		break;
	default:
		printf("xl%d: unknown device ID: %x -- "
			"defaulting to 10baseT\n", sc->xl_unit, devid);
		sc->xl_media = XL_MEDIAOPT_BT;
		break;
	}

	return;
}

/*
 * Initialize the transmit descriptors.
 */
int xl_list_tx_init(sc)
	struct xl_softc		*sc;
{
	struct xl_chain_data	*cd;
	struct xl_list_data	*ld;
	int			i;

	cd = &sc->xl_cdata;
	ld = sc->xl_ldata;
	for (i = 0; i < XL_TX_LIST_CNT; i++) {
		cd->xl_tx_chain[i].xl_ptr = &ld->xl_tx_list[i];
		if (i == (XL_TX_LIST_CNT - 1))
			cd->xl_tx_chain[i].xl_next = NULL;
		else
			cd->xl_tx_chain[i].xl_next = &cd->xl_tx_chain[i + 1];
	}

	cd->xl_tx_free = &cd->xl_tx_chain[0];
	cd->xl_tx_tail = cd->xl_tx_head = NULL;

	return(0);
}

/*
 * Initialize the transmit desriptors.
 */
int
xl_list_tx_init_90xB(sc)
	struct xl_softc *sc;
{
	struct xl_chain_data *cd;
	struct xl_list_data *ld;
	int i;

	cd = &sc->xl_cdata;
	ld = sc->xl_ldata;
	for (i = 0; i < XL_TX_LIST_CNT; i++) {
		cd->xl_tx_chain[i].xl_ptr = &ld->xl_tx_list[i];
		cd->xl_tx_chain[i].xl_phys = vtophys(&ld->xl_tx_list[i]);
		if (i == (XL_TX_LIST_CNT - 1))
			cd->xl_tx_chain[i].xl_next = &cd->xl_tx_chain[0];
		else
			cd->xl_tx_chain[i].xl_next = &cd->xl_tx_chain[i + 1];
		if (i == 0)
			cd->xl_tx_chain[i].xl_prev =
			    &cd->xl_tx_chain[XL_TX_LIST_CNT - 1];
		else
			cd->xl_tx_chain[i].xl_prev =
			    &cd->xl_tx_chain[i - 1];
	}

	bzero((char *)ld->xl_tx_list, sizeof(struct xl_list) * XL_TX_LIST_CNT);
	ld->xl_tx_list[0].xl_status = XL_TXSTAT_EMPTY;

	cd->xl_tx_prod = 1;
	cd->xl_tx_cons = 1;
	cd->xl_tx_cnt = 0;

	return (0);
}

/*
 * Initialize the RX descriptors and allocate mbufs for them. Note that
 * we arrange the descriptors in a closed ring, so that the last descriptor
 * points back to the first.
 */
int xl_list_rx_init(sc)
	struct xl_softc		*sc;
{
	struct xl_chain_data	*cd;
	struct xl_list_data	*ld;
	int			i;

	cd = &sc->xl_cdata;
	ld = sc->xl_ldata;

	for (i = 0; i < XL_RX_LIST_CNT; i++) {
		cd->xl_rx_chain[i].xl_ptr =
			(struct xl_list_onefrag *)&ld->xl_rx_list[i];
		if (xl_newbuf(sc, &cd->xl_rx_chain[i]) == ENOBUFS)
			return(ENOBUFS);
		if (i == (XL_RX_LIST_CNT - 1)) {
			cd->xl_rx_chain[i].xl_next = &cd->xl_rx_chain[0];
			ld->xl_rx_list[i].xl_next =
			    vtophys(&ld->xl_rx_list[0]);
		} else {
			cd->xl_rx_chain[i].xl_next = &cd->xl_rx_chain[i + 1];
			ld->xl_rx_list[i].xl_next =
			    vtophys(&ld->xl_rx_list[i + 1]);
		}
	}

	cd->xl_rx_head = &cd->xl_rx_chain[0];

	return(0);
}

/*
 * Initialize an RX descriptor and attach an MBUF cluster.
 */
int xl_newbuf(sc, c)
	struct xl_softc		*sc;
	struct xl_chain_onefrag	*c;
{
	struct mbuf		*m_new = NULL;

	MGETHDR(m_new, M_DONTWAIT, MT_DATA);
	if (m_new == NULL)
		return(ENOBUFS);

	MCLGET(m_new, M_DONTWAIT);
	if (!(m_new->m_flags & M_EXT)) {
		m_freem(m_new);
		return(ENOBUFS);
	}

	m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;

	/* Force longword alignment for packet payload. */
	m_adj(m_new, ETHER_ALIGN);

	c->xl_mbuf = m_new;
	c->xl_ptr->xl_frag.xl_addr = vtophys(mtod(m_new, caddr_t));
	c->xl_ptr->xl_frag.xl_len = MCLBYTES | XL_LAST_FRAG;
	c->xl_ptr->xl_status = 0;

	return(0);
}

int xl_rx_resync(sc)
	struct xl_softc *sc;
{
	struct xl_chain_onefrag *pos;
	int i;

	pos = sc->xl_cdata.xl_rx_head;

	for (i = 0; i < XL_RX_LIST_CNT; i++) {
		if (pos->xl_ptr->xl_status)
			break;
		pos = pos->xl_next;
	}

	if (i == XL_RX_LIST_CNT)
		return (0);

	sc->xl_cdata.xl_rx_head = pos;

	return (EAGAIN);
}

/*
 * A frame has been uploaded: pass the resulting mbuf chain up to
 * the higher level protocols.
 */
void xl_rxeof(sc)
	struct xl_softc		*sc;
{
        struct ether_header	*eh;
        struct mbuf		*m;
        struct ifnet		*ifp;
	struct xl_chain_onefrag	*cur_rx;
	int			total_len = 0;
	u_int16_t		rxstat;

	ifp = &sc->arpcom.ac_if;

again:

	while((rxstat = sc->xl_cdata.xl_rx_head->xl_ptr->xl_status)) {
		cur_rx = sc->xl_cdata.xl_rx_head;
		sc->xl_cdata.xl_rx_head = cur_rx->xl_next;

		/*
		 * If an error occurs, update stats, clear the
		 * status word and leave the mbuf cluster in place:
		 * it should simply get re-used next time this descriptor
	 	 * comes up in the ring.
		 */
		if (rxstat & XL_RXSTAT_UP_ERROR) {
			ifp->if_ierrors++;
			cur_rx->xl_ptr->xl_status = 0;
			continue;
		}

		/*
		 * If there error bit was not set, the upload complete
		 * bit should be set which means we have a valid packet.
		 * If not, something truly strange has happened.
		 */
		if (!(rxstat & XL_RXSTAT_UP_CMPLT)) {
			printf("xl%d: bad receive status -- "
			    "packet dropped", sc->xl_unit);
			ifp->if_ierrors++;
			cur_rx->xl_ptr->xl_status = 0;
			continue;
		}

		/* No errors; receive the packet. */	
		m = cur_rx->xl_mbuf;
		total_len = cur_rx->xl_ptr->xl_status & XL_RXSTAT_LENMASK;

		/*
		 * Try to conjure up a new mbuf cluster. If that
		 * fails, it means we have an out of memory condition and
		 * should leave the buffer in place and continue. This will
		 * result in a lost packet, but there's little else we
		 * can do in this situation.
		 */
		if (xl_newbuf(sc, cur_rx) == ENOBUFS) {
			ifp->if_ierrors++;
			cur_rx->xl_ptr->xl_status = 0;
			continue;
		}

		ifp->if_ipackets++;
		eh = mtod(m, struct ether_header *);
		m->m_pkthdr.rcvif = ifp;
#if NBPFILTER > 0
		/*
		 * Handle BPF listeners. Let the BPF user see the packet.
		 */
		if (ifp->if_bpf) {
			m->m_pkthdr.len = m->m_len = total_len;
			bpf_mtap(ifp->if_bpf, m);
		}
#endif
		/* Remove header from mbuf and pass it on. */
		m->m_pkthdr.len = m->m_len =
				total_len - sizeof(struct ether_header);
		m->m_data += sizeof(struct ether_header);
		ether_input(ifp, eh, m);
	}

	/*
	 * Handle the 'end of channel' condition. When the upload
	 * engine hits the end of the RX ring, it will stall. This
	 * is our cue to flush the RX ring, reload the uplist pointer
	 * register and unstall the engine.
	 * XXX This is actually a little goofy. With the ThunderLAN
	 * chip, you get an interrupt when the receiver hits the end
	 * of the receive ring, which tells you exactly when you
	 * you need to reload the ring pointer. Here we have to
	 * fake it. I'm mad at myself for not being clever enough
	 * to avoid the use of a goto here.
	 */
	if (CSR_READ_4(sc, XL_UPLIST_PTR) == 0 ||
		CSR_READ_4(sc, XL_UPLIST_STATUS) & XL_PKTSTAT_UP_STALLED) {
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);
		xl_wait(sc);
		CSR_WRITE_4(sc, XL_UPLIST_PTR,
			vtophys(&sc->xl_ldata->xl_rx_list[0]));
		sc->xl_cdata.xl_rx_head = &sc->xl_cdata.xl_rx_chain[0];
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);
		goto again;
	}

	return;
}

/*
 * A frame was downloaded to the chip. It's safe for us to clean up
 * the list buffers.
 */
void xl_txeof(sc)
	struct xl_softc		*sc;
{
	struct xl_chain		*cur_tx;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	/* Clear the timeout timer. */
	ifp->if_timer = 0;

	/*
	 * Go through our tx list and free mbufs for those
	 * frames that have been uploaded. Note: the 3c905B
	 * sets a special bit in the status word to let us
	 * know that a frame has been downloaded, but the
	 * original 3c900/3c905 adapters don't do that.
	 * Consequently, we have to use a different test if
	 * xl_type != XL_TYPE_905B.
	 */
	while(sc->xl_cdata.xl_tx_head != NULL) {
		cur_tx = sc->xl_cdata.xl_tx_head;

		if (CSR_READ_4(sc, XL_DOWNLIST_PTR))
			break;

		sc->xl_cdata.xl_tx_head = cur_tx->xl_next;
		m_freem(cur_tx->xl_mbuf);
		cur_tx->xl_mbuf = NULL;
		ifp->if_opackets++;

		cur_tx->xl_next = sc->xl_cdata.xl_tx_free;
		sc->xl_cdata.xl_tx_free = cur_tx;
	}

	if (sc->xl_cdata.xl_tx_head == NULL) {
		ifp->if_flags &= ~IFF_OACTIVE;
		sc->xl_cdata.xl_tx_tail = NULL;
	} else {
		if (CSR_READ_4(sc, XL_DMACTL) & XL_DMACTL_DOWN_STALLED ||
			!CSR_READ_4(sc, XL_DOWNLIST_PTR)) {
			CSR_WRITE_4(sc, XL_DOWNLIST_PTR,
				vtophys(sc->xl_cdata.xl_tx_head->xl_ptr));
			CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);
		}
	}

	return;
}

void
xl_txeof_90xB(sc)
	struct xl_softc *sc;
{
	struct xl_chain *cur_tx = NULL;
	struct ifnet *ifp;
	int idx;

	ifp = &sc->arpcom.ac_if;

	idx = sc->xl_cdata.xl_tx_cons;
	while(idx != sc->xl_cdata.xl_tx_prod) {

		cur_tx = &sc->xl_cdata.xl_tx_chain[idx];

		if (!(cur_tx->xl_ptr->xl_status & XL_TXSTAT_DL_COMPLETE))
			break;

		if (cur_tx->xl_mbuf != NULL) {
			m_freem(cur_tx->xl_mbuf);
			cur_tx->xl_mbuf = NULL;
		}

		ifp->if_opackets++;

		sc->xl_cdata.xl_tx_cnt--;
		XL_INC(idx, XL_TX_LIST_CNT);
		ifp->if_timer = 0;
	}

	sc->xl_cdata.xl_tx_cons = idx;

	if (cur_tx != NULL)
		ifp->if_flags &= ~IFF_OACTIVE;
}

/*
 * TX 'end of channel' interrupt handler. Actually, we should
 * only get a 'TX complete' interrupt if there's a transmit error,
 * so this is really TX error handler.
 */
void xl_txeoc(sc)
	struct xl_softc		*sc;
{
	u_int8_t		txstat;

	while((txstat = CSR_READ_1(sc, XL_TX_STATUS))) {
		if (txstat & XL_TXSTATUS_UNDERRUN ||
			txstat & XL_TXSTATUS_JABBER ||
			txstat & XL_TXSTATUS_RECLAIM) {
			printf("xl%d: transmission error: %x\n",
						sc->xl_unit, txstat);
			CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);
			xl_wait(sc);
			if (sc->xl_type == XL_TYPE_905B) {
				int i;
				struct xl_chain *c;
				i = sc->xl_cdata.xl_tx_cons;
				c = &sc->xl_cdata.xl_tx_chain[i];
				CSR_WRITE_4(sc, XL_DOWNLIST_PTR, c->xl_phys);
				CSR_WRITE_1(sc, XL_DOWN_POLL, 64);
			} else {
				if (sc->xl_cdata.xl_tx_head != NULL)
					CSR_WRITE_4(sc, XL_DOWNLIST_PTR,
					    vtophys(sc->xl_cdata.xl_tx_head->xl_ptr));
			}
			/*
			 * Remember to set this for the
			 * first generation 3c90X chips.
			 */
			CSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);
			if (txstat & XL_TXSTATUS_UNDERRUN &&
			    sc->xl_tx_thresh < XL_PACKET_SIZE) {
				sc->xl_tx_thresh += XL_MIN_FRAMELEN;
				printf("xl%d: tx underrun, increasing tx start"
				    " threshold to %d\n", sc->xl_unit,
				    sc->xl_tx_thresh);
			}
			CSR_WRITE_2(sc, XL_COMMAND,
			    XL_CMD_TX_SET_START|sc->xl_tx_thresh);
			if (sc->xl_type == XL_TYPE_905B) {
				CSR_WRITE_2(sc, XL_COMMAND,
				XL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));
			}
			CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);
			CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);
		} else {
			CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);
			CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);
		}
		/*
		 * Write an arbitrary byte to the TX_STATUS register
	 	 * to clear this interrupt/error and advance to the next.
		 */
		CSR_WRITE_1(sc, XL_TX_STATUS, 0x01);
	}

	return;
}

int xl_intr(arg)
	void			*arg;
{
	struct xl_softc		*sc;
	struct ifnet		*ifp;
	u_int16_t		status;
	int claimed = 0;

	sc = arg;
	ifp = &sc->arpcom.ac_if;

	while ((status = CSR_READ_2(sc, XL_STATUS)) & XL_INTRS) {

		claimed = 1;

		CSR_WRITE_2(sc, XL_COMMAND,
		    XL_CMD_INTR_ACK|(status & XL_INTRS));

		if (status & XL_STAT_UP_COMPLETE) {
			int curpkts;

			curpkts = ifp->if_ipackets;
			xl_rxeof(sc);
			if (curpkts == ifp->if_ipackets) {
				while (xl_rx_resync(sc))
					xl_rxeof(sc);
			}
		}

		if (status & XL_STAT_DOWN_COMPLETE) {
			if (sc->xl_type == XL_TYPE_905B)
				xl_txeof_90xB(sc);
			else
				xl_txeof(sc);
		}

		if (status & XL_STAT_TX_COMPLETE) {
			ifp->if_oerrors++;
			xl_txeoc(sc);
		}

		if (status & XL_STAT_ADFAIL) {
			xl_reset(sc, 0);
			xl_init(sc);
		}

		if (status & XL_STAT_STATSOFLOW) {
			sc->xl_stats_no_timeout = 1;
			xl_stats_update(sc);
			sc->xl_stats_no_timeout = 0;
		}
	}

	if (ifp->if_snd.ifq_head != NULL)
		(*ifp->if_start)(ifp);

	return (claimed);
}

void xl_stats_update(xsc)
	void			*xsc;
{
	struct xl_softc		*sc;
	struct ifnet		*ifp;
	struct xl_stats		xl_stats;
	u_int8_t		*p;
	int			i;
	struct mii_data		*mii = NULL;

	bzero((char *)&xl_stats, sizeof(struct xl_stats));

	sc = xsc;
	ifp = &sc->arpcom.ac_if;
	if (sc->xl_hasmii)
		mii = &sc->sc_mii;

	p = (u_int8_t *)&xl_stats;

	/* Read all the stats registers. */
	XL_SEL_WIN(6);

	for (i = 0; i < 16; i++)
		*p++ = CSR_READ_1(sc, XL_W6_CARRIER_LOST + i);

	ifp->if_ierrors += xl_stats.xl_rx_overrun;

	ifp->if_collisions += xl_stats.xl_tx_multi_collision +
				xl_stats.xl_tx_single_collision +
				xl_stats.xl_tx_late_collision;

	/*
	 * Boomerang and cyclone chips have an extra stats counter
	 * in window 4 (BadSSD). We have to read this too in order
	 * to clear out all the stats registers and avoid a statsoflow
	 * interrupt.
	 */
	XL_SEL_WIN(4);
	CSR_READ_1(sc, XL_W4_BADSSD);

	if (mii != NULL)
		mii_tick(mii);

	XL_SEL_WIN(7);

	if (!sc->xl_stats_no_timeout)
		timeout(xl_stats_update, sc, hz);

	return;
}

/*
 * Encapsulate an mbuf chain in a descriptor by coupling the mbuf data
 * pointers to the fragment pointers.
 */
int xl_encap(sc, c, m_head)
	struct xl_softc		*sc;
	struct xl_chain		*c;
	struct mbuf		*m_head;
{
	int			frag = 0;
	struct xl_frag		*f = NULL;
	int			total_len;
	struct mbuf		*m;

	/*
 	 * Start packing the mbufs in this chain into
	 * the fragment pointers. Stop when we run out
 	 * of fragments or hit the end of the mbuf chain.
	 */
	m = m_head;
	total_len = 0;

	for (m = m_head, frag = 0; m != NULL; m = m->m_next) {
		if (m->m_len != 0) {
			if (frag == XL_MAXFRAGS)
				break;
			total_len+= m->m_len;
			c->xl_ptr->xl_frag[frag].xl_addr =
					vtophys(mtod(m, vm_offset_t));
			c->xl_ptr->xl_frag[frag].xl_len = m->m_len;
			frag++;
		}
	}

	/*
	 * Handle special case: we used up all 63 fragments,
	 * but we have more mbufs left in the chain. Copy the
	 * data into an mbuf cluster. Note that we don't
	 * bother clearing the values in the other fragment
	 * pointers/counters; it wouldn't gain us anything,
	 * and would waste cycles.
	 */
	if (m != NULL) {
		struct mbuf		*m_new = NULL;

		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return(1);
		if (m_head->m_pkthdr.len > MHLEN) {
			MCLGET(m_new, M_DONTWAIT);
			if (!(m_new->m_flags & M_EXT)) {
				m_freem(m_new);
				return(1);
			}
		}
		m_copydata(m_head, 0, m_head->m_pkthdr.len,	
					mtod(m_new, caddr_t));
		m_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;
		m_freem(m_head);
		m_head = m_new;
		f = &c->xl_ptr->xl_frag[0];
		f->xl_addr = vtophys(mtod(m_new, caddr_t));
		f->xl_len = total_len = m_new->m_len;
		frag = 1;
	}

	c->xl_mbuf = m_head;
	c->xl_ptr->xl_frag[frag - 1].xl_len |=  XL_LAST_FRAG;
	c->xl_ptr->xl_status = total_len;
	c->xl_ptr->xl_next = 0;

	return(0);
}

/*
 * Main transmit routine. To avoid having to do mbuf copies, we put pointers
 * to the mbuf data regions directly in the transmit lists. We also save a
 * copy of the pointers since the transmit list fragment pointers are
 * physical addresses.
 */
void xl_start(ifp)
	struct ifnet		*ifp;
{
	struct xl_softc		*sc;
	struct mbuf		*m_head = NULL;
	struct xl_chain		*prev = NULL, *cur_tx = NULL, *start_tx;

	sc = ifp->if_softc;

	/*
	 * Check for an available queue slot. If there are none,
	 * punt.
	 */
	if (sc->xl_cdata.xl_tx_free == NULL) {
		xl_txeoc(sc);
		xl_txeof(sc);
		if (sc->xl_cdata.xl_tx_free == NULL) {
			ifp->if_flags |= IFF_OACTIVE;
			return;
		}
	}

	start_tx = sc->xl_cdata.xl_tx_free;

	while(sc->xl_cdata.xl_tx_free != NULL) {
		IF_DEQUEUE(&ifp->if_snd, m_head);
		if (m_head == NULL)
			break;

		/* Pick a descriptor off the free list. */
		cur_tx = sc->xl_cdata.xl_tx_free;
		sc->xl_cdata.xl_tx_free = cur_tx->xl_next;

		cur_tx->xl_next = NULL;

		/* Pack the data into the descriptor. */
		xl_encap(sc, cur_tx, m_head);

		/* Chain it together. */
		if (prev != NULL) {
			prev->xl_next = cur_tx;
			prev->xl_ptr->xl_next = vtophys(cur_tx->xl_ptr);
		}
		prev = cur_tx;

#if NBPFILTER > 0
		/*
		 * If there's a BPF listener, bounce a copy of this frame
		 * to him.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, cur_tx->xl_mbuf);
#endif
	}

	/*
	 * If there are no packets queued, bail.
	 */
	if (cur_tx == NULL)
		return;

	/*
	 * Place the request for the upload interrupt
	 * in the last descriptor in the chain. This way, if
	 * we're chaining several packets at once, we'll only
	 * get an interupt once for the whole chain rather than
	 * once for each packet.
	 */
	cur_tx->xl_ptr->xl_status |= XL_TXSTAT_DL_INTR;

	/*
	 * Queue the packets. If the TX channel is clear, update
	 * the downlist pointer register.
	 */
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_STALL);
	xl_wait(sc);

	if (sc->xl_cdata.xl_tx_head != NULL) {
		sc->xl_cdata.xl_tx_tail->xl_next = start_tx;
		sc->xl_cdata.xl_tx_tail->xl_ptr->xl_next =
					vtophys(start_tx->xl_ptr);
		sc->xl_cdata.xl_tx_tail->xl_ptr->xl_status &=
					~XL_TXSTAT_DL_INTR;
		sc->xl_cdata.xl_tx_tail = cur_tx;
	} else {
		sc->xl_cdata.xl_tx_head = start_tx;
		sc->xl_cdata.xl_tx_tail = cur_tx;
	}
	if (!CSR_READ_4(sc, XL_DOWNLIST_PTR))
		CSR_WRITE_4(sc, XL_DOWNLIST_PTR, vtophys(start_tx->xl_ptr));

	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);

	XL_SEL_WIN(7);

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;

	/*
	 * XXX Under certain conditions, usually on slower machines
	 * where interrupts may be dropped, it's possible for the
	 * adapter to chew up all the buffers in the receive ring
	 * and stall, without us being able to do anything about it.
	 * To guard against this, we need to make a pass over the
	 * RX queue to make sure there aren't any packets pending.
	 * Doing it here means we can flush the receive ring at the
	 * same time the chip is DMAing the transmit descriptors we
	 * just gave it.
 	 *
	 * 3Com goes to some lengths to emphasize the Parallel Tasking (tm)
	 * nature of their chips in all their marketing literature;
	 * we may as well take advantage of it. :)
	 */
	xl_rxeof(sc);

	return;
}

int xl_encap_90xB(sc, c, m_head)
	struct xl_softc *sc;
	struct xl_chain *c;
	struct mbuf *m_head;
{
	int frag = 0;
	struct xl_frag *f = NULL;
	struct mbuf *m;
	struct xl_list *d;

	/*
	 * Start packing the mbufs in this chain into
	 * the fragment pointers. Stop when we run out
	 * of fragments or hit the end of the mbuf chain.
	 */
	d = c->xl_ptr;
	d->xl_status = 0;
	d->xl_next = 0;

	for (m = m_head, frag = 0; m != NULL; m = m->m_next) {
		if (m->m_len != 0) {
			if (frag == XL_MAXFRAGS)
				break;
			f = &d->xl_frag[frag];
			f->xl_addr = vtophys(mtod(m, vm_offset_t));
			f->xl_len = m->m_len;
			frag++;
		}
	}

	c->xl_mbuf = m_head;
	c->xl_ptr->xl_frag[frag - 1].xl_len |= XL_LAST_FRAG;
	c->xl_ptr->xl_status = XL_TXSTAT_RND_DEFEAT;

	return(0);
}

void
xl_start_90xB(ifp)
	struct ifnet *ifp;
{
	struct xl_softc *sc;
	struct mbuf *m_head = NULL;
	struct xl_chain *prev = NULL, *cur_tx = NULL, *start_tx;
	int idx;

	sc = ifp->if_softc;

	if (ifp->if_flags & IFF_OACTIVE)
		return;

	idx = sc->xl_cdata.xl_tx_prod;
	start_tx = &sc->xl_cdata.xl_tx_chain[idx];

	while (sc->xl_cdata.xl_tx_chain[idx].xl_mbuf == NULL) {

		if ((XL_TX_LIST_CNT - sc->xl_cdata.xl_tx_cnt) < 3) {
			ifp->if_flags |= IFF_OACTIVE;
			break;
		}

		IF_DEQUEUE(&ifp->if_snd, m_head);
		if (m_head == NULL)
			break;

		cur_tx = &sc->xl_cdata.xl_tx_chain[idx];

		/* Pack the data into the descriptor. */
		xl_encap_90xB(sc, cur_tx, m_head);

		/* Chain it together. */
		if (prev != NULL)
			prev->xl_ptr->xl_next = cur_tx->xl_phys;
		prev = cur_tx;

#if NBPFILTER > 0
		/*
		 * If there's a BPF listener, bounce a copy of this frame
		 * to him.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, cur_tx->xl_mbuf);
#endif

		XL_INC(idx, XL_TX_LIST_CNT);
		sc->xl_cdata.xl_tx_cnt++;
	}

	/*
	 * If there are no packets queued, bail.
	 */
	if (cur_tx == NULL)
		return;

	/*
	 * Place the request for the upload interrupt
	 * in the last descriptor in the chain. This way, if
	 * we're chaining several packets at once, we'll only
	 * get an interupt once for the whole chain rather than
	 * once for each packet.
	 */
	cur_tx->xl_ptr->xl_status |= XL_TXSTAT_DL_INTR;

	/* Start transmission */
	sc->xl_cdata.xl_tx_prod = idx;
	start_tx->xl_prev->xl_ptr->xl_next = start_tx->xl_phys;

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;
}

void xl_init(xsc)
	void			*xsc;
{
	struct xl_softc		*sc = xsc;
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	int			s, i;
	u_int16_t		rxfilt = 0;
	struct mii_data		*mii = NULL;

	s = splimp();

	/*
	 * Cancel pending I/O and free all RX/TX buffers.
	 */
	xl_stop(sc);

	if (sc->xl_hasmii)
		mii = &sc->sc_mii;

	if (mii == NULL) {
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);
		xl_wait(sc);
	}
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);
	xl_wait(sc);
	DELAY(10000);


	/* Init our MAC address */
	XL_SEL_WIN(2);
	for (i = 0; i < ETHER_ADDR_LEN; i++) {
		CSR_WRITE_1(sc, XL_W2_STATION_ADDR_LO + i,
				sc->arpcom.ac_enaddr[i]);
	}

	/* Clear the station mask. */
	for (i = 0; i < 3; i++)
		CSR_WRITE_2(sc, XL_W2_STATION_MASK_LO + (i * 2), 0);
#ifdef notdef
	/* Reset TX and RX. */
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);
	xl_wait(sc);
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);
	xl_wait(sc);
#endif
	/* Init circular RX list. */
	if (xl_list_rx_init(sc) == ENOBUFS) {
		printf("xl%d: initialization failed: no "
			"memory for rx buffers\n", sc->xl_unit);
		xl_stop(sc);
		return;
	}

	/* Init TX descriptors. */
	if (sc->xl_type == XL_TYPE_905B)
		xl_list_tx_init_90xB(sc);
	else
		xl_list_tx_init(sc);

	/*
	 * Set the TX freethresh value.
	 * Note that this has no effect on 3c905B "cyclone"
	 * cards but is required for 3c900/3c905 "boomerang"
	 * cards in order to enable the download engine.
	 */
	CSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);

	/* Set the TX start threshold for best performance. */
	sc->xl_tx_thresh = XL_MIN_FRAMELEN;
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_SET_START|sc->xl_tx_thresh);

	/*
	 * If this is a 3c905B, also set the tx reclaim threshold.
	 * This helps cut down on the number of tx reclaim errors
	 * that could happen on a busy network. The chip multiplies
	 * the register value by 16 to obtain the actual threshold
	 * in bytes, so we divide by 16 when setting the value here.
	 * The existing threshold value can be examined by reading
	 * the register at offset 9 in window 5.
	 */
	if (sc->xl_type == XL_TYPE_905B) {
		CSR_WRITE_2(sc, XL_COMMAND,
		    XL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));
	}

	/* Set RX filter bits. */
	XL_SEL_WIN(5);
	rxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);

	/* Set the individual bit to receive frames for this host only. */
	rxfilt |= XL_RXFILTER_INDIVIDUAL;

	/* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC) {
		rxfilt |= XL_RXFILTER_ALLFRAMES;
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);
	} else {
		rxfilt &= ~XL_RXFILTER_ALLFRAMES;
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);
	}

	/*
	 * Set capture broadcast bit to capture broadcast frames.
	 */
	if (ifp->if_flags & IFF_BROADCAST) {
		rxfilt |= XL_RXFILTER_BROADCAST;
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);
	} else {
		rxfilt &= ~XL_RXFILTER_BROADCAST;
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);
	}

	/*
	 * Program the multicast filter, if necessary.
	 */
	if (sc->xl_type == XL_TYPE_905B)
		xl_setmulti_hash(sc);
	else
		xl_setmulti(sc);

	/*
	 * Load the address of the RX list. We have to
	 * stall the upload engine before we can manipulate
	 * the uplist pointer register, then unstall it when
	 * we're finished. We also have to wait for the
	 * stall command to complete before proceeding.
	 * Note that we have to do this after any RX resets
	 * have completed since the uplist register is cleared
	 * by a reset.
	 */
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);
	xl_wait(sc);
	CSR_WRITE_4(sc, XL_UPLIST_PTR, vtophys(&sc->xl_ldata->xl_rx_list[0]));
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);
	xl_wait(sc);

	if (sc->xl_type == XL_TYPE_905B) {
		/* Set polling interval */
		CSR_WRITE_1(sc, XL_DOWN_POLL, 64);
		/* Load the address of the TX list */
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_STALL);
		xl_wait(sc);
		CSR_WRITE_4(sc, XL_DOWNLIST_PTR,
		    vtophys(&sc->xl_ldata->xl_tx_list[0]));
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);
		xl_wait(sc);
	}

	/*
	 * If the coax transceiver is on, make sure to enable
	 * the DC-DC converter.
 	 */
	XL_SEL_WIN(3);
	if (sc->xl_xcvr == XL_XCVR_COAX)
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_START);
	else
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);

	/* Clear out the stats counters. */
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);
	sc->xl_stats_no_timeout = 1;
	xl_stats_update(sc);
	sc->xl_stats_no_timeout = 0;
	XL_SEL_WIN(4);
	CSR_WRITE_2(sc, XL_W4_NET_DIAG, XL_NETDIAG_UPPER_BYTES_ENABLE);
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_ENABLE);

	/*
	 * Enable interrupts.
	 */
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|0xFF);
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|XL_INTRS);
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|XL_INTRS);

	/* Set the RX early threshold */
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_THRESH|(XL_PACKET_SIZE >>2));
	CSR_WRITE_2(sc, XL_DMACTL, XL_DMACTL_UP_RX_EARLY);

	/* Enable receiver and transmitter. */
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);
	xl_wait(sc);
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_ENABLE);
	xl_wait(sc);

	/* Restore state of BMCR */
	if (mii != NULL)
		mii_mediachg(mii);

	/* Select window 7 for normal operations. */
	XL_SEL_WIN(7);

	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;

	(void)splx(s);

	timeout(xl_stats_update, sc, hz);

	return;
}

/*
 * Set media options.
 */
int xl_ifmedia_upd(ifp)
	struct ifnet		*ifp;
{
	struct xl_softc		*sc;
	struct ifmedia		*ifm = NULL;
	struct mii_data		*mii = NULL;

	sc = ifp->if_softc;

	if (sc->xl_hasmii)
		mii = &sc->sc_mii;
	if (mii == NULL)
		ifm = &sc->ifmedia;
	else
		ifm = &mii->mii_media;

	switch(IFM_SUBTYPE(ifm->ifm_media)) {
	case IFM_100_FX:
	case IFM_10_FL:
	case IFM_10_2:
	case IFM_10_5:
		xl_setmode(sc, ifm->ifm_media);
		return (0);
		break;
	default:
		break;
	}

	if (sc->xl_media & XL_MEDIAOPT_MII || sc->xl_media & XL_MEDIAOPT_BTX
		|| sc->xl_media & XL_MEDIAOPT_BT4) {
		xl_init(sc);
	} else {
		xl_setmode(sc, ifm->ifm_media);
	}

	return(0);
}

/*
 * Report current media status.
 */
void xl_ifmedia_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
{
	struct xl_softc		*sc;
	u_int32_t		icfg;
	struct mii_data		*mii = NULL;

	sc = ifp->if_softc;
	if (sc->xl_hasmii != 0)
		mii = &sc->sc_mii;

	XL_SEL_WIN(3);
	icfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG) & XL_ICFG_CONNECTOR_MASK;
	icfg >>= XL_ICFG_CONNECTOR_BITS;

	ifmr->ifm_active = IFM_ETHER;

	switch(icfg) {
	case XL_XCVR_10BT:
		ifmr->ifm_active = IFM_ETHER|IFM_10_T;
		if (CSR_READ_1(sc, XL_W3_MAC_CTRL) & XL_MACCTRL_DUPLEX)
			ifmr->ifm_active |= IFM_FDX;
		else
			ifmr->ifm_active |= IFM_HDX;
		break;
	case XL_XCVR_AUI:
		if (sc->xl_type == XL_TYPE_905B &&
		    sc->xl_media == XL_MEDIAOPT_10FL) {
			ifmr->ifm_active = IFM_ETHER|IFM_10_FL;
			if (CSR_READ_1(sc, XL_W3_MAC_CTRL) & XL_MACCTRL_DUPLEX)
				ifmr->ifm_active |= IFM_FDX;
			else
				ifmr->ifm_active |= IFM_FDX;
		} else
			ifmr->ifm_active = IFM_ETHER|IFM_10_5;
		break;
	case XL_XCVR_COAX:
		ifmr->ifm_active = IFM_ETHER|IFM_10_2;
		break;
	/*
	 * XXX MII and BTX/AUTO should be separate cases.
	 */

	case XL_XCVR_100BTX:
	case XL_XCVR_AUTO:
	case XL_XCVR_MII:
		if (mii != NULL) {
			mii_pollstat(mii);
			ifmr->ifm_active = mii->mii_media_active;
			ifmr->ifm_status = mii->mii_media_status;
		}
		break;
	case XL_XCVR_100BFX:
		ifmr->ifm_active = IFM_ETHER|IFM_100_FX;
		break;
	default:
		printf("xl%d: unknown XCVR type: %d\n", sc->xl_unit, icfg);
		break;
	}

	return;
}

int
xl_ioctl(ifp, command, data)
	struct ifnet *ifp;
	u_long command;
	caddr_t data;
{
	struct xl_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	struct ifaddr *ifa = (struct ifaddr *)data;
	int s, error = 0;
	struct mii_data *mii = NULL;
	u_int8_t rxfilt;

	s = splimp();

	if ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {
		splx(s);
		return error;
	}

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			xl_init(sc);
			arp_ifinit(&sc->arpcom, ifa);
			break;
#endif /* INET */
		default:
			xl_init(sc);
			break;
		}
		break;
	case SIOCSIFFLAGS:
		XL_SEL_WIN(5);
		rxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->xl_if_flags & IFF_PROMISC)) {
				rxfilt |= XL_RXFILTER_ALLFRAMES;
				CSR_WRITE_2(sc, XL_COMMAND,
				    XL_CMD_RX_SET_FILT|rxfilt);
				XL_SEL_WIN(7);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->xl_if_flags & IFF_PROMISC) {
				rxfilt &= ~XL_RXFILTER_ALLFRAMES;
				CSR_WRITE_2(sc, XL_COMMAND,
				    XL_CMD_RX_SET_FILT|rxfilt);
				XL_SEL_WIN(7);
			} else
				xl_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				xl_stop(sc);
		}
		sc->xl_if_flags = ifp->if_flags;
		error = 0;
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (sc->xl_type == XL_TYPE_905B)
				xl_setmulti_hash(sc);
			else
				xl_setmulti(sc);
			error = 0;
		}
		break;
	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		if (sc->xl_hasmii != 0)
			mii = &sc->sc_mii;
		if (mii == NULL)
			error = ifmedia_ioctl(ifp, ifr,
			    &sc->ifmedia, command);
		else
			error = ifmedia_ioctl(ifp, ifr,
			    &mii->mii_media, command);
		break;
	default:
		error = EINVAL;
		break;
	}

	(void)splx(s);

	return(error);
}

void xl_watchdog(ifp)
	struct ifnet		*ifp;
{
	struct xl_softc		*sc;
	u_int16_t		status = 0;

	sc = ifp->if_softc;

	ifp->if_oerrors++;
	XL_SEL_WIN(4);
	status = CSR_READ_2(sc, XL_W4_MEDIA_STATUS);
	printf("xl%d: watchdog timeout\n", sc->xl_unit);

	if (status & XL_MEDIASTAT_CARRIER)
		printf("xl%d: no carrier - transceiver cable problem?\n",
								sc->xl_unit);
	xl_txeoc(sc);
	xl_txeof(sc);
	xl_rxeof(sc);
	xl_reset(sc, 0);
	xl_init(sc);

	if (ifp->if_snd.ifq_head != NULL)
		(*ifp->if_start)(ifp);

	return;
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void xl_stop(sc)
	struct xl_softc *sc;
{
	int i;
	struct ifnet *ifp;

	ifp = &sc->arpcom.ac_if;
	ifp->if_timer = 0;

	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_DISABLE);
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB);
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_DISCARD);
	xl_wait(sc);
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_DISABLE);
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);
	DELAY(800);

#ifdef foo
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);
	xl_wait(sc);
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);
	xl_wait(sc);
#endif

	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|XL_STAT_INTLATCH);
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|0);
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|0);

	/* Stop the stats updater. */
	untimeout(xl_stats_update, sc);

	/*
	 * Free data in the RX lists.
	 */
	for (i = 0; i < XL_RX_LIST_CNT; i++) {
		if (sc->xl_cdata.xl_rx_chain[i].xl_mbuf != NULL) {
			m_freem(sc->xl_cdata.xl_rx_chain[i].xl_mbuf);
			sc->xl_cdata.xl_rx_chain[i].xl_mbuf = NULL;
		}
	}
	bzero((char *)&sc->xl_ldata->xl_rx_list,
		sizeof(sc->xl_ldata->xl_rx_list));
	/*
	 * Free the TX list buffers.
	 */
	for (i = 0; i < XL_TX_LIST_CNT; i++) {
		if (sc->xl_cdata.xl_tx_chain[i].xl_mbuf != NULL) {
			m_freem(sc->xl_cdata.xl_tx_chain[i].xl_mbuf);
			sc->xl_cdata.xl_tx_chain[i].xl_mbuf = NULL;
		}
	}
	bzero((char *)&sc->xl_ldata->xl_tx_list,
		sizeof(sc->xl_ldata->xl_tx_list));

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);

	return;
}

void
xl_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct xl_softc *sc = (struct xl_softc *)self;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
	u_int8_t enaddr[ETHER_ADDR_LEN];
	struct ifnet *ifp = &sc->arpcom.ac_if;
	bus_addr_t iobase;
	bus_size_t iosize;
	u_int32_t command;
	caddr_t roundptr;
	u_int round;
	int i, media = IFM_ETHER|IFM_100_TX|IFM_FDX;
	struct ifmedia *ifm;

	sc->xl_unit = sc->sc_dev.dv_unit;

	/*
	 * If this is a 3c905B, we have to check one extra thing.
	 * The 905B supports power management and may be placed in
	 * a low-power mode (D3 mode), typically by certain operating
	 * systems which shall not be named. The PCI BIOS is supposed
	 * to reset the NIC and bring it out of low-power mode, but  
	 * some do not. Consequently, we have to see if this chip    
	 * supports power management, and if so, make sure it's not  
	 * in low-power mode. If power management is available, the  
	 * capid byte will be 0x01.
	 * 
	 * I _think_ that what actually happens is that the chip
	 * loses its PCI configuration during the transition from
	 * D3 back to D0; this means that it should be possible for
	 * us to save the PCI iobase, membase and IRQ, put the chip
	 * back in the D0 state, then restore the PCI config ourselves.
	 */
	command = pci_conf_read(pc, pa->pa_tag, XL_PCI_CAPID) & 0xff;
	if (command == 0x01) {

		command = pci_conf_read(pc, pa->pa_tag,
		    XL_PCI_PWRMGMTCTRL);
		if (command & XL_PSTATE_MASK) {
			u_int32_t io, mem, irq;

			/* Save PCI config */
			io = pci_conf_read(pc, pa->pa_tag, XL_PCI_LOIO);
			mem = pci_conf_read(pc, pa->pa_tag, XL_PCI_LOMEM);
			irq = pci_conf_read(pc, pa->pa_tag, XL_PCI_INTLINE);

			/* Reset the power state. */
			printf("%s: chip is in D%d power mode "
			    "-- setting to D0\n",
			    sc->sc_dev.dv_xname, command & XL_PSTATE_MASK);
			command &= 0xFFFFFFFC;
			pci_conf_write(pc, pa->pa_tag,
			    XL_PCI_PWRMGMTCTRL, command);

			pci_conf_write(pc, pa->pa_tag, XL_PCI_LOIO, io);
			pci_conf_write(pc, pa->pa_tag, XL_PCI_LOMEM, mem);
			pci_conf_write(pc, pa->pa_tag, XL_PCI_INTLINE, irq);
		}
	}

	/*
	 * Map control/status registers.
	 */
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_IO_ENABLE |
		   PCI_COMMAND_MEM_ENABLE |
		   PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);

#ifdef XL_USEIOSPACE
	if (!(command & PCI_COMMAND_IO_ENABLE)) {
		printf("%s: failed to enable i/o ports\n",
		    sc->sc_dev.dv_xname);
		return;
	}
	/*
	 * Map control/status registers.
	 */
	if (pci_io_find(pc, pa->pa_tag, XL_PCI_LOIO, &iobase, &iosize)) {
		printf(": can't find i/o space\n");
		return;
	}
	if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->xl_bhandle)) {
		printf(": can't map i/o space\n");
		return;
	}
	sc->xl_btag = pa->pa_iot;
#else
	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf(": failed to enable memory mapping\n");
		return;
	}
	if (pci_mem_find(pc, pa->pa_tag, XL_PCI_LOMEM, &iobase, &iosize, NULL)){
		printf(": can't find mem space\n");
		return;
	}
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->xl_bhandle)) {
		printf(": can't map mem space\n");
		return;
	}
	sc->xl_btag = pa->pa_memt;
#endif

	/*
	 * Allocate our interrupt.
	 */
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
		printf(": couldn't map interrupt\n");
		return;
	}

	intrstr = pci_intr_string(pc, ih);
	sc->xl_intrhand = pci_intr_establish(pc, ih, IPL_NET, xl_intr, sc,
	    self->dv_xname);
	if (sc->xl_intrhand == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		return;
	}
	printf(": %s", intrstr);

	xl_reset(sc, 1);

	/*
	 * Get station address from the EEPROM.
	 */
	if (xl_read_eeprom(sc, (caddr_t)&enaddr, XL_EE_OEM_ADR0, 3, 1)) {
		printf("\n%s: failed to read station address\n",
		    sc->sc_dev.dv_xname);
		return;
	}
	bcopy(enaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);

	printf(" address %s\n", ether_sprintf(sc->arpcom.ac_enaddr));

	sc->xl_ldata_ptr = malloc(sizeof(struct xl_list_data) + 8,
	    M_DEVBUF, M_NOWAIT);
	if (sc->xl_ldata_ptr == NULL) {
		printf("%s: no memory for list buffers\n",sc->sc_dev.dv_xname);
		return;
	}

	sc->xl_ldata = (struct xl_list_data *)sc->xl_ldata_ptr;
#ifdef __alpha__
	round = (u_int64_t)sc->xl_ldata_ptr & 0xf;
#else
	round = (u_int32_t)sc->xl_ldata_ptr & 0xf;
#endif
	roundptr = sc->xl_ldata_ptr;
	for (i = 0; i < 8; i++) {
		if (round % 8) {
			round++;
			roundptr++;
		} else
			break;
	}
	sc->xl_ldata = (struct xl_list_data *)roundptr;
	bzero(sc->xl_ldata, sizeof(struct xl_list_data));

	/*
	 * Figure out the card type. 3c905B adapters have the
	 * 'supportsNoTxLength' bit set in the capabilities
	 * word in the EEPROM.
	 */
	xl_read_eeprom(sc, (caddr_t)&sc->xl_caps, XL_EE_CAPS, 1, 0);
	if (sc->xl_caps & XL_CAPS_NO_TXLENGTH)
		sc->xl_type = XL_TYPE_905B;
	else
		sc->xl_type = XL_TYPE_90X;

	ifp->if_softc = sc;
	ifp->if_mtu = ETHERMTU;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = xl_ioctl;
	ifp->if_output = ether_output;
	if (sc->xl_type == XL_TYPE_905B)
		ifp->if_start = xl_start_90xB;
	else
		ifp->if_start = xl_start;
	ifp->if_watchdog = xl_watchdog;
	ifp->if_baudrate = 10000000;
	ifp->if_snd.ifq_maxlen = XL_TX_LIST_CNT - 1;
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);

	XL_SEL_WIN(3);
	sc->xl_media = CSR_READ_2(sc, XL_W3_MEDIA_OPT);

	xl_read_eeprom(sc, (char *)&sc->xl_xcvr, XL_EE_ICFG_0, 2, 0);
	sc->xl_xcvr &= XL_ICFG_CONNECTOR_MASK;
	sc->xl_xcvr >>= XL_ICFG_CONNECTOR_BITS;

	xl_mediacheck(sc);

	if (sc->xl_media & XL_MEDIAOPT_MII || sc->xl_media & XL_MEDIAOPT_BTX
	    || sc->xl_media & XL_MEDIAOPT_BT4) {
		ifmedia_init(&sc->sc_mii.mii_media, 0,
		    xl_ifmedia_upd, xl_ifmedia_sts);
		sc->xl_hasmii = 1;
		sc->sc_mii.mii_ifp = ifp;
		sc->sc_mii.mii_readreg = xl_miibus_readreg;
		sc->sc_mii.mii_writereg = xl_miibus_writereg;
		sc->sc_mii.mii_statchg = xl_miibus_statchg;
		xl_setcfg(sc);
		mii_phy_probe(self, &sc->sc_mii, 0xffffffff);

		if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
			ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE,
			    0, NULL);
			ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);
		}
		else {
			ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);
		}
		ifm = &sc->sc_mii.mii_media;
	}
	else {
		ifmedia_init(&sc->ifmedia, 0, xl_ifmedia_upd, xl_ifmedia_sts);
		sc->xl_hasmii = 0;
		ifm = &sc->ifmedia;
	}

	/*
	 * Sanity check. If the user has selected "auto" and this isn't
	 * a 10/100 card of some kind, we need to force the transceiver
	 * type to something sane.
	 */
	if (sc->xl_xcvr == XL_XCVR_AUTO) {
		xl_choose_xcvr(sc, 0);
		xl_reset(sc, 0);
	}

	if (sc->xl_media & XL_MEDIAOPT_BT) {
		ifmedia_add(ifm, IFM_ETHER|IFM_10_T, 0, NULL);
		ifmedia_add(ifm, IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);
		if (sc->xl_caps & XL_CAPS_FULL_DUPLEX)
			ifmedia_add(&sc->ifmedia,
			    IFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);
	}

	if (sc->xl_media & (XL_MEDIAOPT_AUI|XL_MEDIAOPT_10FL)) {
		/*
		 * Check for a 10baseFL board in disguise.
		 */
		if (sc->xl_type == XL_TYPE_905B &&
		    sc->xl_media == XL_MEDIAOPT_10FL) {
			ifmedia_add(ifm, IFM_ETHER|IFM_10_FL, 0, NULL);
			ifmedia_add(ifm, IFM_ETHER|IFM_10_FL|IFM_HDX,
			    0, NULL);
			if (sc->xl_caps & XL_CAPS_FULL_DUPLEX)
				ifmedia_add(ifm,
				    IFM_ETHER|IFM_10_FL|IFM_FDX, 0, NULL);
		} else {
			ifmedia_add(ifm, IFM_ETHER|IFM_10_5, 0, NULL);
		}
	}

	if (sc->xl_media & XL_MEDIAOPT_BNC) {
		ifmedia_add(ifm, IFM_ETHER|IFM_10_2, 0, NULL);
	}

	if (sc->xl_media & XL_MEDIAOPT_BFX) {
		ifp->if_baudrate = 100000000;
		ifmedia_add(ifm, IFM_ETHER|IFM_100_FX, 0, NULL);
	}

	/* Choose a default media. */
	switch(sc->xl_xcvr) {
	case XL_XCVR_10BT:
		media = IFM_ETHER|IFM_10_T;
		xl_setmode(sc, media);
		break;
	case XL_XCVR_AUI:
		if (sc->xl_type == XL_TYPE_905B &&
		    sc->xl_media == XL_MEDIAOPT_10FL) {
			media = IFM_ETHER|IFM_10_FL;
			xl_setmode(sc, media);
		} else {
			media = IFM_ETHER|IFM_10_5;
			xl_setmode(sc, media);
		}
		break;
	case XL_XCVR_COAX:
		media = IFM_ETHER|IFM_10_2;
		xl_setmode(sc, media);
		break;
	case XL_XCVR_AUTO:
	case XL_XCVR_100BTX:
	case XL_XCVR_MII:
		/* Chosen by miibus */
		break;
	case XL_XCVR_100BFX:
		media = IFM_ETHER|IFM_100_FX;
		xl_setmode(sc, media);
		break;
	default:
		printf("xl%d: unknown XCVR type: %d\n", sc->xl_unit,
							sc->xl_xcvr);
		/*
		 * This will probably be wrong, but it prevents
		 * the ifmedia code from panicking.
		 */
		media = IFM_ETHER | IFM_10_T;
		break;
	}

	if (sc->xl_hasmii == 0)
		ifmedia_set(&sc->ifmedia, media);

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

#if NBPFILTER > 0
	bpfattach(&sc->arpcom.ac_if.if_bpf, ifp,
	    DLT_EN10MB, sizeof(struct ether_header));
#endif
	shutdownhook_establish(xl_shutdown, sc);
}

void
xl_shutdown(v)
	void *v;
{
	struct xl_softc	*sc = (struct xl_softc *)v;

	xl_reset(sc, 1);
	xl_stop(sc);
}

struct cfattach xl_ca = {
	sizeof(struct xl_softc), xl_probe, xl_attach,
};
      
struct cfdriver xl_cd = {
	0, "xl", DV_IFNET
};
@


1.38
log
@sync with FreeBSD:
o issue an RX reset in xl_init() for non-mii cards
o keep driver and receiver in sync
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.37 2000/02/15 02:28:15 jason Exp $	*/
@


1.37
log
@make sure to call ether_{add,del}multi() as appropriate in xxx_ioctl()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.36 1999/12/31 05:17:47 jason Exp $	*/
d34 1
a34 1
 * $FreeBSD: if_xl.c,v 1.57 1999/09/15 07:20:59 wpaul Exp $
d161 1
d1166 22
d1469 4
a1472 1
		if (status & XL_STAT_UP_COMPLETE)
d1474 5
d1890 7
a1900 2
	if (sc->xl_hasmii)
		mii = &sc->sc_mii;
d2190 1
a2190 1
	struct ifreq *ifr = (struct ifreq *) data;
@


1.36
log
@modify xl_reset to allow for a hard reset (with resets everything including
loading defaults from EEPROM) and a soft reset with resets everything
except loading defaults from EEPROM.  This fixes media selection for 3c900b
(icfg is reloaded during a hard reset)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.35 1999/12/16 22:15:45 deraadt Exp $	*/
d2211 15
a2225 5
		if (sc->xl_type == XL_TYPE_905B)
			xl_setmulti_hash(sc);
		else
			xl_setmulti(sc);
		error = 0;
@


1.36.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.38 2000/02/15 13:47:52 jason Exp $	*/
d34 1
a34 1
 * $FreeBSD: if_xl.c,v 1.72 2000/01/09 21:12:59 wpaul Exp $
a160 1
int xl_rx_resync	__P((struct xl_softc *));
a1164 22
int xl_rx_resync(sc)
	struct xl_softc *sc;
{
	struct xl_chain_onefrag *pos;
	int i;

	pos = sc->xl_cdata.xl_rx_head;

	for (i = 0; i < XL_RX_LIST_CNT; i++) {
		if (pos->xl_ptr->xl_status)
			break;
		pos = pos->xl_next;
	}

	if (i == XL_RX_LIST_CNT)
		return (0);

	sc->xl_cdata.xl_rx_head = pos;

	return (EAGAIN);
}

d1446 1
a1446 4
		if (status & XL_STAT_UP_COMPLETE) {
			int curpkts;

			curpkts = ifp->if_ipackets;
a1447 5
			if (curpkts == ifp->if_ipackets) {
				while (xl_rx_resync(sc))
					xl_rxeof(sc);
			}
		}
a1858 7
	if (sc->xl_hasmii)
		mii = &sc->sc_mii;

	if (mii == NULL) {
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);
		xl_wait(sc);
	}
d1863 2
d2154 1
a2154 1
	struct ifreq *ifr = (struct ifreq *)data;
d2211 5
a2215 15
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (sc->xl_type == XL_TYPE_905B)
				xl_setmulti_hash(sc);
			else
				xl_setmulti(sc);
			error = 0;
		}
@


1.36.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.36.2.1 2000/02/20 11:57:09 niklas Exp $	*/
@


1.35
log
@missed some
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.34 1999/12/16 21:53:03 deraadt Exp $	*/
d187 1
a187 1
void xl_reset		__P((struct xl_softc *));
d834 1
a834 1
void xl_reset(sc)
d840 4
a843 1
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET);
d1462 1
a1462 1
			xl_reset(sc);
d2257 1
a2257 1
	xl_reset(sc);
d2460 1
a2460 1
	xl_reset(sc);
d2567 1
a2567 1
		xl_reset(sc);
d2666 1
a2666 1
	xl_reset(sc);
@


1.34
log
@3c450-TX HomeConnect; wpaul
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.33 1999/12/07 20:23:19 jason Exp $	*/
d890 1
@


1.33
log
@quiet
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.32 1999/12/07 20:19:36 jason Exp $	*/
d55 2
a56 1
 * 3Com 3c905C-TX	10/100Mbs/RJ45 (Tornado ASIC)
d1005 1
@


1.32
log
@merge with freebsd:
o when setting/clearing promisc mode, just update filter
o call xl_init() in xl_media_upd() for handling media changes better on combo's
o alternate tx strategy for 3c90?[BC] cards
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.31 1999/10/07 12:02:58 jason Exp $	*/
d2560 1
a2560 1
		xl_choose_xcvr(sc, 1);
@


1.31
log
@fix mergo: xl_setcfg(): after modifying software state, inform hardware
merge in freebsd xl_choose_xcvr() for cards that report AUTO but have no phy
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.30 1999/09/26 17:50:07 jason Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997, 1998
d156 3
a158 1
						struct mbuf * ));
d161 1
d165 1
d189 1
d489 3
d1054 38
d1114 1
a1114 1
					vtophys(&ld->xl_rx_list[0]);
d1118 1
a1118 1
					vtophys(&ld->xl_rx_list[i + 1]);
d1146 2
d1149 1
a1149 1
	m_new->m_data += 2;
a1151 1
	c->xl_ptr->xl_status = 0;
d1154 1
d1199 2
a1200 2
			printf("xl%d: bad receive status -- packet dropped",
							sc->xl_unit);
d1294 2
a1295 3
		if ((sc->xl_type == XL_TYPE_905B &&
		!(cur_tx->xl_ptr->xl_status & XL_TXSTAT_DL_COMPLETE)) ||
			CSR_READ_4(sc, XL_DOWNLIST_PTR)) {
d1297 1
a1297 1
		}
d1322 36
d1376 12
a1387 3
			if (sc->xl_cdata.xl_tx_head != NULL)
				CSR_WRITE_4(sc, XL_DOWNLIST_PTR,
				vtophys(sc->xl_cdata.xl_tx_head->xl_ptr));
d1433 1
a1433 8
	/* Disable interrupts. */
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB);

	for (;;) {
		status = CSR_READ_2(sc, XL_STATUS);

		if ((status & XL_INTRS) == 0)
			break;
d1443 6
a1448 2
		if (status & XL_STAT_DOWN_COMPLETE)
			xl_txeof(sc);
a1466 5
	/* Re-enable interrupts. */
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|XL_INTRS);

	XL_SEL_WIN(7);

d1468 1
a1468 1
		xl_start(ifp);
d1470 1
a1470 1
	return claimed;
d1724 113
d1853 1
d1855 1
a1869 1

a1876 1

d1886 4
a1889 1
	xl_list_tx_init(sc);
d1914 1
a1914 1
			XL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));
d1966 13
d2011 2
d2014 1
a2014 1
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);
d2054 1
d2066 1
a2066 3
		xl_setcfg(sc);
		if (sc->xl_hasmii != 0)
			mii_mediachg(&sc->sc_mii);
d2141 5
a2145 4
int xl_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
d2147 2
a2148 2
	struct xl_softc		*sc = ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *) data;
d2150 3
a2152 2
	int			s, error = 0;
	struct mii_data		*mii = NULL;
d2177 2
d2180 16
a2195 1
			xl_init(sc);
d2200 1
d2255 1
a2255 1
		xl_start(ifp);
d2265 1
a2265 1
	struct xl_softc		*sc;
d2267 2
a2268 2
	register int		i;
	struct ifnet		*ifp;
d2281 2
a2282 1
#ifdef notdef
d2288 1
d2290 2
d2444 1
a2444 1
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, xl_intr, sc,
d2446 1
a2446 1
	if (sc->sc_ih == NULL) {
a2491 11
	ifp->if_softc = sc;
	ifp->if_mtu = ETHERMTU;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = xl_ioctl;
	ifp->if_output = ether_output;
	ifp->if_start = xl_start;
	ifp->if_watchdog = xl_watchdog;
	ifp->if_baudrate = 10000000;
	ifp->if_snd.ifq_maxlen = XL_TX_LIST_CNT - 1;
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);

d2503 14
d2559 4
a2562 2
	if (sc->xl_xcvr == XL_XCVR_AUTO)
		xl_choose_xcvr(sc, 0);
d2660 1
@


1.30
log
@use dev/mii for appropriate cards
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.29 1999/09/16 16:27:31 jason Exp $	*/
d187 1
d715 1
a715 1
	struct xl_softc		*sc;
d717 1
a717 1
	u_int32_t		icfg;
d727 3
d733 2
a734 2
	struct xl_softc		*sc;
	int			media;
d736 2
a737 2
	u_int32_t		icfg;
	u_int16_t		mediastat;
a822 2

	return;
a901 2
	u_int16_t		devid;

d933 8
d954 3
a956 1
		printf("xl%d: guessing 10BaseT transceiver\n", sc->xl_unit);
d962 3
a964 1
		printf("xl%d: guessing COMBO (AUI/BNC/TP)\n", sc->xl_unit);
d969 2
a970 1
		printf("xl%d: guessing TPC (BNC/TP)\n", sc->xl_unit);
d975 2
a976 1
		printf("xl%d: guessing 10baseFL\n", sc->xl_unit);
d981 2
a982 1
		printf("xl%d: guessing MII\n", sc->xl_unit);
d988 2
a989 1
		printf("xl%d: guessing 100BaseT4/MII\n", sc->xl_unit);
d998 3
a1000 1
		printf("xl%d: guessing 10/100 internal\n", sc->xl_unit);
d1005 3
a1007 1
		printf("xl%d: guessing 10/100 plus BNC/AUI\n", sc->xl_unit);
d2309 1
d2312 8
@


1.29
log
@match/attach 3c980c
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.28 1999/09/13 20:11:13 jason Exp $	*/
d34 1
a34 1
 * $FreeBSD: if_xl.c,v 1.50 1999/08/02 21:57:57 wpaul Exp $
d123 2
a147 20
/*
 * This #define controls the behavior of autonegotiation during the
 * bootstrap phase. It's possible to have the driver initiate an
 * autonegotiation session and then set a timeout which will cause the
 * autoneg results to be polled later, usually once the kernel has
 * finished booting. This is clever and all, but it can have bad side
 * effects in some cases, particularly where NFS is involved. For
 * example, if we're booting diskless with an NFS rootfs, the network
 * interface has to be up and running before we hit the mountroot()
 * code, otherwise mounting the rootfs will fail and we'll probably
 * panic.
 *
 * Consequently, the 'backgrounded' autoneg behavior is turned off
 * by default and we actually sit and wait 5 seconds for autonegotiation
 * to complete before proceeding with the other device probes. If you
 * choose to use the other behavior, you can uncomment this #define and
 * recompile.
 */
/* #define XL_BACKGROUND_AUTONEG */

a151 2
int xl_intr		__P((void *));
void xl_shutdown	__P((void *));
a156 1

d160 1
d166 2
a167 4
u_int8_t xl_calchash	__P((caddr_t));
void xl_mediacheck	__P((struct xl_softc *));
void xl_autoneg_mii	__P((struct xl_softc *, int, int));
void xl_setmode_mii	__P((struct xl_softc *, int));
a168 4
void xl_getmode_mii	__P((struct xl_softc *));
void xl_autoneg_xmit	__P((struct xl_softc *));
int xl_ifmedia_upd	__P((struct ifnet *));
void xl_setmode		__P((struct xl_softc *, int));
a175 2
void xl_phy_writereg	__P((struct xl_softc *, int, int));
u_int16_t xl_phy_readreg	__P((struct xl_softc *, int));
d177 3
d186 1
d191 4
d437 4
a440 3
u_int16_t xl_phy_readreg(sc, reg)
	struct xl_softc		*sc;
	int			reg;
d442 1
d445 3
d450 1
a450 1
	frame.mii_phyaddr = sc->xl_phy_addr;
d457 4
a460 4
void xl_phy_writereg(sc, reg, data)
	struct xl_softc		*sc;
	int			reg;
	int			data;
d462 1
d465 3
d470 1
a470 1
	frame.mii_phyaddr = sc->xl_phy_addr;
d475 1
d477 11
a487 1
	return;
d649 1
d664 4
d713 1
a713 4
/*
 * Initiate an autonegotiation session.
 */
void xl_autoneg_xmit(sc)
a715 1
	u_int16_t		phy_sts;
a717 1
	xl_reset(sc);
a725 325
	if (sc->xl_media & XL_MEDIAOPT_BFX)
		icfg |= (XL_XCVR_100BFX << XL_ICFG_CONNECTOR_BITS);
	CSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);

	xl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);
	DELAY(500);
	while(xl_phy_readreg(sc, XL_PHY_GENCTL)
			& PHY_BMCR_RESET);

	phy_sts = xl_phy_readreg(sc, PHY_BMCR);
	phy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;
	xl_phy_writereg(sc, PHY_BMCR, phy_sts);

	return;
}

/*
 * Invoke autonegotiation on a PHY. Also used with the 3Com internal
 * autoneg logic which is mapped onto the MII.
 */
void xl_autoneg_mii(sc, flag, verbose)
	struct xl_softc		*sc;
	int			flag;
	int			verbose;
{
	u_int16_t		phy_sts = 0, media, advert, ability;
	struct ifnet		*ifp;
	struct ifmedia		*ifm;

	ifm = &sc->ifmedia;
	ifp = &sc->arpcom.ac_if;

	ifm->ifm_media = IFM_ETHER | IFM_AUTO;

	/*
	 * The 100baseT4 PHY on the 3c905-T4 has the 'autoneg supported'
	 * bit cleared in the status register, but has the 'autoneg enabled'
	 * bit set in the control register. This is a contradiction, and
	 * I'm not sure how to handle it. If you want to force an attempt
	 * to autoneg for 100baseT4 PHYs, #define FORCE_AUTONEG_TFOUR
	 * and see what happens.
	 */
#ifndef FORCE_AUTONEG_TFOUR
	/*
	 * First, see if autoneg is supported. If not, there's
	 * no point in continuing.
	 */
	phy_sts = xl_phy_readreg(sc, PHY_BMSR);
	if (!(phy_sts & PHY_BMSR_CANAUTONEG)) {
		if (verbose)
			printf("xl%d: autonegotiation not supported\n",
							sc->xl_unit);
		ifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;	
		media = xl_phy_readreg(sc, PHY_BMCR);
		media &= ~PHY_BMCR_SPEEDSEL;
		media &= ~PHY_BMCR_DUPLEX;
		xl_phy_writereg(sc, PHY_BMCR, media);
		CSR_WRITE_1(sc, XL_W3_MAC_CTRL,
				(CSR_READ_1(sc, XL_W3_MAC_CTRL) &
						~XL_MACCTRL_DUPLEX));
		return;
	}
#endif

	switch (flag) {
	case XL_FLAG_FORCEDELAY:
		/*
	 	 * XXX Never use this option anywhere but in the probe
	 	 * routine: making the kernel stop dead in its tracks
 		 * for three whole seconds after we've gone multi-user
		 * is really bad manners.
	 	 */
		xl_autoneg_xmit(sc);
		DELAY(5000000);
		break;
	case XL_FLAG_SCHEDDELAY:
		/*
		 * Wait for the transmitter to go idle before starting
		 * an autoneg session, otherwise xl_start() may clobber
	 	 * our timeout, and we don't want to allow transmission
		 * during an autoneg session since that can screw it up.
	 	 */
		if (sc->xl_cdata.xl_tx_head != NULL) {
			sc->xl_want_auto = 1;
			return;
		}
		xl_autoneg_xmit(sc);
		ifp->if_timer = 5;
		sc->xl_autoneg = 1;
		sc->xl_want_auto = 0;
		return;
		break;
	case XL_FLAG_DELAYTIMEO:
		ifp->if_timer = 0;
		sc->xl_autoneg = 0;
		break;
	default:
		printf("xl%d: invalid autoneg flag: %d\n", sc->xl_unit, flag);
		return;
	}

	if (xl_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_AUTONEGCOMP) {
		if (verbose)
			printf("xl%d: autoneg complete, ", sc->xl_unit);
		phy_sts = xl_phy_readreg(sc, PHY_BMSR);
	} else {
		if (verbose)
			printf("xl%d: autoneg not complete, ", sc->xl_unit);
	}

	media = xl_phy_readreg(sc, PHY_BMCR);

	/* Link is good. Report modes and set duplex mode. */
	if (xl_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_LINKSTAT) {
		if (verbose)
			printf("link status good ");
		advert = xl_phy_readreg(sc, XL_PHY_ANAR);
		ability = xl_phy_readreg(sc, XL_PHY_LPAR);

		if (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {
			ifm->ifm_media = IFM_ETHER|IFM_100_T4;
			media |= PHY_BMCR_SPEEDSEL;
			media &= ~PHY_BMCR_DUPLEX;
			printf("(100baseT4)\n");
		} else if (advert & PHY_ANAR_100BTXFULL &&
			ability & PHY_ANAR_100BTXFULL) {
			ifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;
			media |= PHY_BMCR_SPEEDSEL;
			media |= PHY_BMCR_DUPLEX;
			printf("(full-duplex, 100Mbps)\n");
		} else if (advert & PHY_ANAR_100BTXHALF &&
			ability & PHY_ANAR_100BTXHALF) {
			ifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;
			media |= PHY_BMCR_SPEEDSEL;
			media &= ~PHY_BMCR_DUPLEX;
			printf("(half-duplex, 100Mbps)\n");
		} else if (advert & PHY_ANAR_10BTFULL &&
			ability & PHY_ANAR_10BTFULL) {
			ifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;
			media &= ~PHY_BMCR_SPEEDSEL;
			media |= PHY_BMCR_DUPLEX;
			printf("(full-duplex, 10Mbps)\n");
		} else if (advert & PHY_ANAR_10BTHALF &&
			ability & PHY_ANAR_10BTHALF) {
			ifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;
			media &= ~PHY_BMCR_SPEEDSEL;
			media &= ~PHY_BMCR_DUPLEX;
			printf("(half-duplex, 10Mbps)\n");
		}

		/* Set ASIC's duplex mode to match the PHY. */
		XL_SEL_WIN(3);
		if (media & PHY_BMCR_DUPLEX)
			CSR_WRITE_1(sc, XL_W3_MAC_CTRL, XL_MACCTRL_DUPLEX);
		else
			CSR_WRITE_1(sc, XL_W3_MAC_CTRL,
				(CSR_READ_1(sc, XL_W3_MAC_CTRL) &
						~XL_MACCTRL_DUPLEX));
		xl_phy_writereg(sc, PHY_BMCR, media);
	} else {
		if (verbose)
			printf("no carrier (forcing half-duplex, 10Mbps)\n");
		ifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;
		media &= ~PHY_BMCR_SPEEDSEL;
		media &= ~PHY_BMCR_DUPLEX;
		xl_phy_writereg(sc, PHY_BMCR, media);
		CSR_WRITE_1(sc, XL_W3_MAC_CTRL,
				(CSR_READ_1(sc, XL_W3_MAC_CTRL) &
						~XL_MACCTRL_DUPLEX));
	}

	xl_init(sc);

	if (sc->xl_tx_pend) {
		sc->xl_autoneg = 0;
		sc->xl_tx_pend = 0;
		xl_start(ifp);
	}

	return;
}

void xl_getmode_mii(sc)
	struct xl_softc		*sc;
{
	u_int16_t		bmsr;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	bmsr = xl_phy_readreg(sc, PHY_BMSR);

	/* fallback */
	sc->ifmedia.ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;

	if (bmsr & PHY_BMSR_10BTHALF) {
		ifmedia_add(&sc->ifmedia,
			IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);
	}

	if (bmsr & PHY_BMSR_10BTFULL) {
		ifmedia_add(&sc->ifmedia,
			IFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);
		sc->ifmedia.ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;
	}

	if (bmsr & PHY_BMSR_100BTXHALF) {
		ifp->if_baudrate = 100000000;
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_TX, 0, NULL);
		ifmedia_add(&sc->ifmedia,
			IFM_ETHER|IFM_100_TX|IFM_HDX, 0, NULL);
		sc->ifmedia.ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;
	}

	if (bmsr & PHY_BMSR_100BTXFULL) {
		ifp->if_baudrate = 100000000;
		ifmedia_add(&sc->ifmedia,
			IFM_ETHER|IFM_100_TX|IFM_FDX, 0, NULL);
		sc->ifmedia.ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;
	}

	/* Some also support 100BaseT4. */
	if (bmsr & PHY_BMSR_100BT4) {
		ifp->if_baudrate = 100000000;
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_T4, 0, NULL);
		sc->ifmedia.ifm_media = IFM_ETHER|IFM_100_T4;
#ifdef FORCE_AUTONEG_TFOUR
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);
		sc->ifmedia.ifm_media = IFM_ETHER|IFM_AUTO;
#endif
	}

	if (bmsr & PHY_BMSR_CANAUTONEG) {
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);
		sc->ifmedia.ifm_media = IFM_ETHER|IFM_AUTO;
	}

	return;
}

/*
 * Set speed and duplex mode.
 */
void xl_setmode_mii(sc, media)
	struct xl_softc		*sc;
	int			media;
{
	u_int16_t		bmcr;
	u_int32_t		icfg;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	/*
	 * If an autoneg session is in progress, stop it.
	 */
	if (sc->xl_autoneg) {
		printf("xl%d: canceling autoneg session\n", sc->xl_unit);
		ifp->if_timer = sc->xl_autoneg = sc->xl_want_auto = 0;
		bmcr = xl_phy_readreg(sc, PHY_BMCR);
		bmcr &= ~PHY_BMCR_AUTONEGENBL;
		xl_phy_writereg(sc, PHY_BMCR, bmcr);
	}

	printf("xl%d: selecting MII, ", sc->xl_unit);

	XL_SEL_WIN(3);
	icfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG);
	icfg &= ~XL_ICFG_CONNECTOR_MASK;
	if (sc->xl_media & XL_MEDIAOPT_MII || sc->xl_media & XL_MEDIAOPT_BT4)
		icfg |= (XL_XCVR_MII << XL_ICFG_CONNECTOR_BITS);
	if (sc->xl_media & XL_MEDIAOPT_BTX) {
		if (sc->xl_type == XL_TYPE_905B)
			icfg |= (XL_XCVR_AUTO << XL_ICFG_CONNECTOR_BITS);
		else
			icfg |= (XL_XCVR_MII << XL_ICFG_CONNECTOR_BITS);
	}
	CSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);

	if (IFM_SUBTYPE(media) == IFM_100_FX) {
		icfg |= (XL_XCVR_100BFX << XL_ICFG_CONNECTOR_BITS);
		CSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);
		return;
	}

	bmcr = xl_phy_readreg(sc, PHY_BMCR);

	bmcr &= ~(PHY_BMCR_AUTONEGENBL|PHY_BMCR_SPEEDSEL|
			PHY_BMCR_DUPLEX|PHY_BMCR_LOOPBK);

	if (IFM_SUBTYPE(media) == IFM_100_T4) {
		printf("100Mbps/T4, half-duplex\n");
		bmcr |= PHY_BMCR_SPEEDSEL;
		bmcr &= ~PHY_BMCR_DUPLEX;
	}

	if (IFM_SUBTYPE(media) == IFM_100_TX) {
		printf("100Mbps, ");
		bmcr |= PHY_BMCR_SPEEDSEL;
	}

	if (IFM_SUBTYPE(media) == IFM_10_T) {
		printf("10Mbps, ");
		bmcr &= ~PHY_BMCR_SPEEDSEL;
	}

	if ((media & IFM_GMASK) == IFM_FDX) {
		printf("full duplex\n");
		bmcr |= PHY_BMCR_DUPLEX;
		XL_SEL_WIN(3);
		CSR_WRITE_1(sc, XL_W3_MAC_CTRL, XL_MACCTRL_DUPLEX);
	} else {
		printf("half duplex\n");
		bmcr &= ~PHY_BMCR_DUPLEX;
		XL_SEL_WIN(3);
		CSR_WRITE_1(sc, XL_W3_MAC_CTRL,
			(CSR_READ_1(sc, XL_W3_MAC_CTRL) & ~XL_MACCTRL_DUPLEX));
	}

	xl_phy_writereg(sc, PHY_BMCR, bmcr);

	return;
d889 1
a889 1
 * 3cx90x adapters) to return an incorrect result. I have encountered
d1103 1
a1103 1
	u_int32_t		rxstat;
a1242 3
		if (sc->xl_want_auto)
			xl_autoneg_mii(sc, XL_FLAG_SCHEDDELAY, 1);

d1377 1
d1383 2
d1409 3
a1508 5
	if (sc->xl_autoneg) {
		sc->xl_tx_pend = 1;
		return;
	}

d1627 1
a1627 4
	u_int16_t		phy_bmcr = 0;

	if (sc->xl_autoneg)
		return;
a1631 9
	 * XXX Hack for the 3c905B: the built-in autoneg logic's state
	 * gets reset by xl_init() when we don't want it to. Try
	 * to preserve it. (For 3c905 cards with real external PHYs,
	 * the BMCR register doesn't change, but this doesn't hurt.)
	 */
	if (sc->xl_hasmii != 0)
		phy_bmcr = xl_phy_readreg(sc, PHY_BMCR);

	/*
d1638 3
d1782 2
a1783 2
	if (sc->xl_hasmii != 0)
		xl_phy_writereg(sc, PHY_BMCR, phy_bmcr);
d1805 2
a1806 1
	struct ifmedia		*ifm;
a1808 1
	ifm = &sc->ifmedia;
d1810 6
a1815 2
	if (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)
		return(EINVAL);
d1830 3
a1832 4
		if (IFM_SUBTYPE(ifm->ifm_media) == IFM_AUTO)
			xl_autoneg_mii(sc, XL_FLAG_SCHEDDELAY, 1);
		else
			xl_setmode_mii(sc, ifm->ifm_media);
a1847 1
	u_int16_t		advert = 0, ability = 0;
d1849 1
d1852 2
d1890 4
a1893 30
		if (!(xl_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_AUTONEGENBL)) {
			if (xl_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_SPEEDSEL)
				ifmr->ifm_active = IFM_ETHER|IFM_100_TX;
			else
				ifmr->ifm_active = IFM_ETHER|IFM_10_T;
			XL_SEL_WIN(3);
			if (CSR_READ_2(sc, XL_W3_MAC_CTRL) &
						XL_MACCTRL_DUPLEX)
				ifmr->ifm_active |= IFM_FDX;
			else
				ifmr->ifm_active |= IFM_HDX;
			break;
		}
		ability = xl_phy_readreg(sc, XL_PHY_LPAR);
		advert = xl_phy_readreg(sc, XL_PHY_ANAR);
		if (advert & PHY_ANAR_100BT4 &&
			ability & PHY_ANAR_100BT4) {
			ifmr->ifm_active = IFM_ETHER|IFM_100_T4;
		} else if (advert & PHY_ANAR_100BTXFULL &&
			ability & PHY_ANAR_100BTXFULL) {
			ifmr->ifm_active = IFM_ETHER|IFM_100_TX|IFM_FDX;
		} else if (advert & PHY_ANAR_100BTXHALF &&
			ability & PHY_ANAR_100BTXHALF) {
			ifmr->ifm_active = IFM_ETHER|IFM_100_TX|IFM_HDX;
		} else if (advert & PHY_ANAR_10BTFULL &&
			ability & PHY_ANAR_10BTFULL) {
			ifmr->ifm_active = IFM_ETHER|IFM_10_T|IFM_FDX;
		} else if (advert & PHY_ANAR_10BTHALF &&
			ability & PHY_ANAR_10BTHALF) {
			ifmr->ifm_active = IFM_ETHER|IFM_10_T|IFM_HDX;
d1916 1
d1959 8
a1966 1
		error = ifmedia_ioctl(ifp, ifr, &sc->ifmedia, command);
a1985 7
	if (sc->xl_autoneg) {
		xl_autoneg_mii(sc, XL_FLAG_DELAYTIMEO, 1);
		if (!(ifp->if_flags & IFF_UP))
			xl_stop(sc);
		return;
	}

a2080 1
	u_int16_t phy_sts, phy_vid, phy_did;
d2084 1
d2266 10
a2275 8
			|| sc->xl_media & XL_MEDIAOPT_BT4) {
		/*
		 * In theory I shouldn't need this, but... if this
		 * card supports an MII, either an external one or
		 * an internal fake one, select it in the internal
		 * config register before trying to probe it.
		 */
		u_int32_t		icfg;
d2277 4
a2280 25
		XL_SEL_WIN(3);
		icfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG);
		icfg &= ~XL_ICFG_CONNECTOR_MASK;
		if (sc->xl_media & XL_MEDIAOPT_MII ||
			sc->xl_media & XL_MEDIAOPT_BT4)
			icfg |= (XL_XCVR_MII << XL_ICFG_CONNECTOR_BITS);
		if (sc->xl_media & XL_MEDIAOPT_BTX)
			icfg |= (XL_XCVR_AUTO << XL_ICFG_CONNECTOR_BITS);
		if (sc->xl_media & XL_MEDIAOPT_BFX)
			icfg |= (XL_XCVR_100BFX << XL_ICFG_CONNECTOR_BITS);
		CSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);

		for (i = XL_PHYADDR_MIN; i < XL_PHYADDR_MAX + 1; i++) {
			sc->xl_phy_addr = i;
			xl_phy_writereg(sc, XL_PHY_GENCTL, PHY_BMCR_RESET);
			DELAY(500);
			while(xl_phy_readreg(sc, XL_PHY_GENCTL)
					& PHY_BMCR_RESET);
			if ((phy_sts = xl_phy_readreg(sc, XL_PHY_GENSTS)))
				break;
		}
		if (phy_sts) {
			phy_vid = xl_phy_readreg(sc, XL_PHY_VENID);
			phy_did = xl_phy_readreg(sc, XL_PHY_DEVID);
			sc->xl_hasmii = 1;
d2283 1
a2283 3
			printf("%s: MII without any phy!\n",
			    sc->sc_dev.dv_xname);
			return;
d2285 5
a2291 5
	/*
	 * Do ifmedia setup.
	 */
	ifmedia_init(&sc->ifmedia, 0, xl_ifmedia_upd, xl_ifmedia_sts);

d2293 2
a2294 2
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);
d2306 2
a2307 2
			ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_FL, 0, NULL);
			ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_FL|IFM_HDX,
d2310 1
a2310 1
				ifmedia_add(&sc->ifmedia,
d2313 1
a2313 1
			ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_5, 0, NULL);
d2318 1
a2318 19
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_2, 0, NULL);
	}

	/*
	 * Technically we could use xl_getmode_mii() to scan the
	 * modes, but the built-in BTX mode on the 3c905B implies
	 * 10/100 full/half duplex support anyway, so why not just
	 * do it and get it over with.
	 */
	if (sc->xl_media & XL_MEDIAOPT_BTX) {
		ifp->if_baudrate = 100000000;
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_TX, 0, NULL);
		ifmedia_add(&sc->ifmedia,
			IFM_ETHER|IFM_100_TX|IFM_HDX, 0, NULL);
		if (sc->xl_caps & XL_CAPS_FULL_DUPLEX)
			ifmedia_add(&sc->ifmedia,
				IFM_ETHER|IFM_100_TX|IFM_FDX, 0, NULL);
		if (sc->xl_hasmii != 0)
			ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);
d2323 1
a2323 9
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_FX, 0, NULL);
	}

	/*
	 * If there's an MII, we have to probe its modes
	 * separately.
	 */
	if (sc->xl_media & XL_MEDIAOPT_MII || sc->xl_media & XL_MEDIAOPT_BT4) {
		xl_getmode_mii(sc);
a2346 8
#ifdef XL_BACKGROUND_AUTONEG
		xl_autoneg_mii(sc, XL_FLAG_SCHEDDELAY, 1);
#else
		xl_autoneg_mii(sc, XL_FLAG_FORCEDELAY, 1);
		xl_stop(sc);
#endif
		media = sc->ifmedia.ifm_media;
		break;
d2349 1
a2349 7
#ifdef XL_BACKGROUND_AUTONEG
		xl_autoneg_mii(sc, XL_FLAG_SCHEDDELAY, 1);
#else
		xl_autoneg_mii(sc, XL_FLAG_FORCEDELAY, 1);
		xl_stop(sc);
#endif
		media = sc->ifmedia.ifm_media;
d2353 1
d2366 2
a2367 1
	ifmedia_set(&sc->ifmedia, media);
@


1.28
log
@OpenBSD-ify (Remove OS dependent #ifdef's)
Merge with FreeBSD:
perform rx reset & tx reset in xl_reset()
fix queuing race in xl_txeof
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.27 1999/07/02 17:34:44 jason Exp $	*/
d55 4
a58 3
 * 3Com 3c905C-TX	10/100Mbs/RJ45
 * 3Com 3c980-TX	10/100Mbps server adapter
 * 3Com 3cSOHO100-TX	10/100Mbps/RJ-45
d60 1
d1202 1
d1302 1
@


1.27
log
@freebsd merge:
dynamically set the tx threshold (missed in last merge)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.26 1999/06/29 20:24:10 jason Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_xl.c,v 1.41 1999/07/02 04:17:16 peter Exp $
a105 3
#if defined(__FreeBSD__)
#include <machine/clock.h>
#elif defined(__bsdi__) || defined(__NetBSD__) || defined(__OpenBSD__)
a106 10
#endif

#if defined(__FreeBSD__)

#include <net/if.h>
#include <net/if_arp.h>
#include <net/ethernet.h>
#include <net/if_dl.h>

#elif defined(__OpenBSD__)
d111 1
a124 4
#endif

#include <net/if_media.h>

a131 10
#ifdef __FreeBSD__
#include "opt_bdg.h"
#ifdef BRIDGE
#include <net/bridge.h>
#endif

#include <pci/pcireg.h>
#include <pci/pcivar.h>
#endif

a163 3
#if defined(__FreeBSD__)
#include <pci/if_xlreg.h>
#elif defined(__OpenBSD__)
a164 74
#endif

#if !defined(lint) && !defined(__OpenBSD__)
static const char rcsid[] =
	"$FreeBSD: if_xl.c,v 1.41 1999/07/02 04:17:16 peter Exp $";
#endif

#ifdef __FreeBSD__
/*
 * Various supported device vendors/types and their names.
 */
static struct xl_type xl_devs[] = {
	{ TC_VENDORID, TC_DEVICEID_BOOMERANG_10BT,
		"3Com 3c900-TPO Etherlink XL" },
	{ TC_VENDORID, TC_DEVICEID_BOOMERANG_10BT_COMBO,
		"3Com 3c900-COMBO Etherlink XL" },
	{ TC_VENDORID, TC_DEVICEID_BOOMERANG_10_100BT,
		"3Com 3c905-TX Fast Etherlink XL" },
	{ TC_VENDORID, TC_DEVICEID_BOOMERANG_100BT4,
		"3Com 3c905-T4 Fast Etherlink XL" },
	{ TC_VENDORID, TC_DEVICEID_KRAKATOA_10BT,
		"3Com 3c900B-TPO Etherlink XL" },
	{ TC_VENDORID, TC_DEVICEID_KRAKATOA_10BT_COMBO,
		"3Com 3c900B-COMBO Etherlink XL" },
	{ TC_VENDORID, TC_DEVICEID_KRAKATOA_10BT_TPC,
		"3Com 3c900B-TPC Etherlink XL" },
	{ TC_VENDORID, TC_DEVICEID_CYCLONE_10FL,
		"3Com 3c900B-FL Etherlink XL" },
	{ TC_VENDORID, TC_DEVICEID_HURRICANE_10_100BT,
		"3Com 3c905B-TX Fast Etherlink XL" },
	{ TC_VENDORID, TC_DEVICEID_CYCLONE_10_100BT4,
		"3Com 3c905B-T4 Fast Etherlink XL" },
	{ TC_VENDORID, TC_DEVICEID_CYCLONE_10_100FX,
		"3Com 3c905B-FX/SC Fast Etherlink XL" },
	{ TC_VENDORID, TC_DEVICEID_CYCLONE_10_100_COMBO,
		"3Com 3c905B-COMBO Fast Etherlink XL" },
	{ TC_VENDORID, TC_DEVICEID_TORNADO_10_100BT,
	        "3Com 3c905C-TX Fast Etherlink XL" },
	{ TC_VENDORID, TC_DEVICEID_HURRICANE_10_100BT_SERV,
		"3Com 3c980 Fast Etherlink XL" },
	{ TC_VENDORID, TC_DEVICEID_HURRICANE_SOHO100TX,
		"3Com 3cSOHO100-TX OfficeConnect" },
	{ 0, 0, NULL }
};

/*
 * Various supported PHY vendors/types and their names. Note that
 * this driver will work with pretty much any MII-compliant PHY,
 * so failure to positively identify the chip is not a fatal error.
 */

static struct xl_type xl_phys[] = {
	{ TI_PHY_VENDORID, TI_PHY_10BT, "<TI ThunderLAN 10BT (internal)>" },
	{ TI_PHY_VENDORID, TI_PHY_100VGPMI, "<TI TNETE211 100VG Any-LAN>" },
	{ NS_PHY_VENDORID, NS_PHY_83840A, "<National Semiconductor DP83840A>"},
	{ LEVEL1_PHY_VENDORID, LEVEL1_PHY_LXT970, "<Level 1 LXT970>" }, 
	{ INTEL_PHY_VENDORID, INTEL_PHY_82555, "<Intel 82555>" },
	{ SEEQ_PHY_VENDORID, SEEQ_PHY_80220, "<SEEQ 80220>" },
	{ 0, 0, "<MII-compliant physical interface>" }
};
#endif

#if defined(__FreeBSD__)
static unsigned long xl_count = 0;
static const char *xl_probe	__P((pcici_t, pcidi_t));
static void xl_attach		__P((pcici_t, int));
static void xl_intr		__P((void *));
static void xl_shutdown		__P((int, void *));
#elif defined(__OpenBSD__)
static int xl_probe	__P((struct device *, void *, void *));
static void xl_attach	__P((struct device *, struct device *, void *));
static int xl_intr		__P((void *));
static void xl_shutdown		__P((void *));
#endif
d166 8
a173 4
static int xl_newbuf		__P((struct xl_softc *,
						struct xl_chain_onefrag *));
static void xl_stats_update	__P((void *));
static int xl_encap		__P((struct xl_softc *, struct xl_chain *,
d176 33
a208 34
static void xl_rxeof		__P((struct xl_softc *));
static void xl_txeof		__P((struct xl_softc *));
static void xl_txeoc		__P((struct xl_softc *));
static void xl_start		__P((struct ifnet *));
static int xl_ioctl		__P((struct ifnet *, u_long, caddr_t));
static void xl_init		__P((void *));
static void xl_stop		__P((struct xl_softc *));
static void xl_watchdog		__P((struct ifnet *));
static u_int8_t xl_calchash	__P((caddr_t));
static void xl_mediacheck	__P((struct xl_softc *));
static void xl_autoneg_mii	__P((struct xl_softc *, int, int));
static void xl_setmode_mii	__P((struct xl_softc *, int));
static void xl_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));
static void xl_getmode_mii	__P((struct xl_softc *));
static void xl_autoneg_xmit	__P((struct xl_softc *));
static int xl_ifmedia_upd	__P((struct ifnet *));
static void xl_setmode		__P((struct xl_softc *, int));

static int xl_eeprom_wait	__P((struct xl_softc *));
static int xl_read_eeprom	__P((struct xl_softc *, caddr_t, int,
							int, int));
static void xl_mii_sync		__P((struct xl_softc *));
static void xl_mii_send		__P((struct xl_softc *, u_int32_t, int));
static int xl_mii_readreg	__P((struct xl_softc *, struct xl_mii_frame *));
static int xl_mii_writereg	__P((struct xl_softc *, struct xl_mii_frame *));
static u_int16_t xl_phy_readreg	__P((struct xl_softc *, int));
static void xl_phy_writereg	__P((struct xl_softc *, int, int));

static void xl_setmulti		__P((struct xl_softc *));
static void xl_setmulti_hash	__P((struct xl_softc *));
static void xl_reset		__P((struct xl_softc *));
static int xl_list_rx_init	__P((struct xl_softc *));
static int xl_list_tx_init	__P((struct xl_softc *));
static void xl_wait		__P((struct xl_softc *));
d210 1
a210 1
static void xl_testpacket	__P((struct xl_softc *));
d221 1
a221 1
static void xl_wait(sc)
a226 1
		DELAY(10);
d231 1
d234 1
d259 1
a259 1
static void xl_mii_sync(sc)
d280 1
a280 1
static void xl_mii_send(sc, bits, cnt)
d306 1
a306 1
static int xl_mii_readreg(sc, frame)
d404 1
a404 1
static int xl_mii_writereg(sc, frame)
d455 1
a455 1
static u_int16_t xl_phy_readreg(sc, reg)
d470 1
a470 1
static void xl_phy_writereg(sc, reg, data)
d492 1
a492 1
static int xl_eeprom_wait(sc)
d516 1
a516 1
static int xl_read_eeprom(sc, dest, off, cnt, swap)
d561 1
a561 1
static u_int8_t xl_calchash(addr)
d590 1
a590 1
static void xl_setmulti(sc)
a593 3
#ifdef __FreeBSD__
	struct ifmultiaddr	*ifma;
#else
a596 1
#endif
a610 5
#ifdef __FreeBSD__
	for (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;
				ifma = ifma->ifma_link.le_next)
		mcnt++;
#else
a615 1
#endif
d630 1
a630 1
static void xl_setmulti_hash(sc)
a634 3
#ifdef __FreeBSD__
	struct ifmultiaddr	*ifma;
#else
a637 1
#endif
a658 10
#ifdef __FreeBSD__
	for (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;
				ifma = ifma->ifma_link.le_next) {
		if (ifma->ifma_addr->sa_family != AF_LINK)
			continue;
		h = xl_calchash(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));
		CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_HASH|XL_HASH_SET|h);
		mcnt++;
	}
#else
a664 1
#endif
d677 1
a677 1
static void xl_testpacket(sc)
d709 1
a709 1
static void xl_autoneg_xmit(sc)
d745 1
a745 1
static void xl_autoneg_mii(sc, flag, verbose)
d907 1
a907 1
static void xl_getmode_mii(sc)
d969 1
a969 1
static void xl_setmode_mii(sc, media)
d1051 1
a1051 1
static void xl_setmode(sc, media)
d1146 1
a1146 1
static void xl_reset(sc)
d1161 8
d1170 1
a1170 1
	DELAY(1000);
d1174 5
a1178 9
#if defined(__FreeBSD__)
/*
 * Probe for a 3Com Etherlink XL chip. Check the PCI vendor and device
 * IDs against our list and return a device name if we find a match.
 */
static const char *
xl_probe(config_id, device_id)
	pcici_t			config_id;
	pcidi_t			device_id;
d1180 1
a1180 1
	struct xl_type		*t;
d1182 2
a1183 1
	t = xl_devs;
d1185 17
a1201 6
	while(t->xl_name != NULL) {
		if ((device_id & 0xFFFF) == t->xl_vid &&
		    ((device_id >> 16) & 0xFFFF) == t->xl_did) {
			return(t->xl_name);
		}
		t++;
d1203 2
a1204 2

	return(NULL);
a1205 1
#endif
d1219 1
a1219 1
static void xl_mediacheck(sc)
a1319 402
#if defined(__FreeBSD__)
/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
static void
xl_attach(config_id, unit)
	pcici_t			config_id;
	int			unit;
{
	int			s, i;
#ifndef XL_USEIOSPACE
	vm_offset_t		pbase, vbase;
#endif
	u_char			eaddr[ETHER_ADDR_LEN];
	u_int32_t		command;
	struct xl_softc		*sc;
	struct ifnet		*ifp;
	int			media = IFM_ETHER|IFM_100_TX|IFM_FDX;
	unsigned int		round;
	caddr_t			roundptr;
	struct xl_type		*p;
	u_int16_t		phy_vid, phy_did, phy_sts;

	s = splimp();

	sc = malloc(sizeof(struct xl_softc), M_DEVBUF, M_NOWAIT);
	if (sc == NULL) {
		printf("xl%d: no memory for softc struct!\n", unit);
		goto fail;
	}
	bzero(sc, sizeof(struct xl_softc));

	/*
	 * If this is a 3c905B, we have to check one extra thing.
	 * The 905B supports power management and may be placed in
	 * a low-power mode (D3 mode), typically by certain operating
	 * systems which shall not be named. The PCI BIOS is supposed
	 * to reset the NIC and bring it out of low-power mode, but
	 * some do not. Consequently, we have to see if this chip
	 * supports power management, and if so, make sure it's not
	 * in low-power mode. If power management is available, the
	 * capid byte will be 0x01.
	 *
	 * I _think_ that what actually happens is that the chip
	 * loses its PCI configuration during the transition from
	 * D3 back to D0; this means that it should be possible for
	 * us to save the PCI iobase, membase and IRQ, put the chip
	 * back in the D0 state, then restore the PCI config ourselves.
	 */

	command = pci_conf_read(config_id, XL_PCI_CAPID) & 0x000000FF;
	if (command == 0x01) {

		command = pci_conf_read(config_id, XL_PCI_PWRMGMTCTRL);
		if (command & XL_PSTATE_MASK) {
			u_int32_t		iobase, membase, irq;

			/* Save important PCI config data. */
			iobase = pci_conf_read(config_id, XL_PCI_LOIO);
			membase = pci_conf_read(config_id, XL_PCI_LOMEM);
			irq = pci_conf_read(config_id, XL_PCI_INTLINE);

			/* Reset the power state. */
			printf("xl%d: chip is in D%d power mode "
			"-- setting to D0\n", unit, command & XL_PSTATE_MASK);
			command &= 0xFFFFFFFC;
			pci_conf_write(config_id, XL_PCI_PWRMGMTCTRL, command);

			/* Restore PCI config data. */
			pci_conf_write(config_id, XL_PCI_LOIO, iobase);
			pci_conf_write(config_id, XL_PCI_LOMEM, membase);
			pci_conf_write(config_id, XL_PCI_INTLINE, irq);
		}
	}

	/*
	 * Map control/status registers.
	 */
	command = pci_conf_read(config_id, PCI_COMMAND_STATUS_REG);
	command |= (PCIM_CMD_PORTEN|PCIM_CMD_MEMEN|PCIM_CMD_BUSMASTEREN);
	pci_conf_write(config_id, PCI_COMMAND_STATUS_REG, command);
	command = pci_conf_read(config_id, PCI_COMMAND_STATUS_REG);

#ifdef XL_USEIOSPACE
	if (!(command & PCIM_CMD_PORTEN)) {
		printf("xl%d: failed to enable I/O ports!\n", unit);
		free(sc, M_DEVBUF);
		goto fail;
	}
	if (!pci_map_port(config_id, XL_PCI_LOIO,
				(pci_port_t *)&(sc->xl_bhandle))) {
		printf ("xl%d: couldn't map port\n", unit);
		printf ("xl%d: WARNING: check your BIOS and "
		    "set 'Plug & Play OS' to 'no'\n", unit);
		printf ("xl%d: attempting to map iobase manually\n", unit);
		sc->xl_bhandle =
		    pci_conf_read(config_id, XL_PCI_LOIO) & 0xFFFFFFE0;
		/*goto fail;*/
	}

#ifdef __i386__
	sc->xl_btag = I386_BUS_SPACE_IO;
#endif
#ifdef __alpha__
	sc->xl_btag = ALPHA_BUS_SPACE_IO;
#endif
#else
	if (!(command & PCIM_CMD_MEMEN)) {
		printf("xl%d: failed to enable memory mapping!\n", unit);
		goto fail;
	}

	if (!pci_map_mem(config_id, XL_PCI_LOMEM, &vbase, &pbase)) {
		printf ("xl%d: couldn't map memory\n", unit);
		goto fail;
	}
	sc->xl_bhandle = vbase;
#ifdef __i386__
	sc->btag = I386_BUS_SPACE_MEM;
#endif
#ifdef __alpha__
	sc->btag = ALPHA_BUS_SPACE_MEM;
#endif
#endif

	/* Allocate interrupt */
	if (!pci_map_int(config_id, xl_intr, sc, &net_imask)) {
		printf("xl%d: couldn't map interrupt\n", unit);
		goto fail;
	}

	/* Reset the adapter. */
	xl_reset(sc);

	/*
	 * Get station address from the EEPROM.
	 */
	if (xl_read_eeprom(sc, (caddr_t)&eaddr, XL_EE_OEM_ADR0, 3, 1)) {
		printf("xl%d: failed to read station address\n", sc->xl_unit);
		free(sc, M_DEVBUF);
		goto fail;
	}

	/*
	 * A 3Com chip was detected. Inform the world.
	 */
	printf("xl%d: Ethernet address: %6D\n", unit, eaddr, ":");

	sc->xl_unit = unit;
	callout_handle_init(&sc->xl_stat_ch);
	bcopy(eaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);

	sc->xl_ldata_ptr = malloc(sizeof(struct xl_list_data) + 8,
				M_DEVBUF, M_NOWAIT);
	if (sc->xl_ldata_ptr == NULL) {
		free(sc, M_DEVBUF);
		printf("xl%d: no memory for list buffers!\n", unit);
		goto fail;
	}

	sc->xl_ldata = (struct xl_list_data *)sc->xl_ldata_ptr;
	round = (uintptr_t)sc->xl_ldata_ptr & 0xF;
	roundptr = sc->xl_ldata_ptr;
	for (i = 0; i < 8; i++) {
		if (round % 8) {
			round++;
			roundptr++;
		} else
			break;
	}
	sc->xl_ldata = (struct xl_list_data *)roundptr;
	bzero(sc->xl_ldata, sizeof(struct xl_list_data));

	ifp = &sc->arpcom.ac_if;
	ifp->if_softc = sc;
	ifp->if_unit = unit;
	ifp->if_name = "xl";
	ifp->if_mtu = ETHERMTU;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = xl_ioctl;
	ifp->if_output = ether_output;
	ifp->if_start = xl_start;
	ifp->if_watchdog = xl_watchdog;
	ifp->if_init = xl_init;
	ifp->if_baudrate = 10000000;
	ifp->if_snd.ifq_maxlen = XL_TX_LIST_CNT - 1;

	/*
	 * Figure out the card type. 3c905B adapters have the
	 * 'supportsNoTxLength' bit set in the capabilities
	 * word in the EEPROM.
	 */
	xl_read_eeprom(sc, (caddr_t)&sc->xl_caps, XL_EE_CAPS, 1, 0);
	if (sc->xl_caps & XL_CAPS_NO_TXLENGTH)
		sc->xl_type = XL_TYPE_905B;
	else
		sc->xl_type = XL_TYPE_90X;

	/*
	 * Now we have to see what sort of media we have.
	 * This includes probing for an MII interace and a
	 * possible PHY.
	 */
	XL_SEL_WIN(3);
	sc->xl_media = CSR_READ_2(sc, XL_W3_MEDIA_OPT);

	xl_read_eeprom(sc, (char *)&sc->xl_xcvr, XL_EE_ICFG_0, 2, 0);
	sc->xl_xcvr &= XL_ICFG_CONNECTOR_MASK;
	sc->xl_xcvr >>= XL_ICFG_CONNECTOR_BITS;

	xl_mediacheck(sc);

	if (sc->xl_media & XL_MEDIAOPT_MII || sc->xl_media & XL_MEDIAOPT_BTX
			|| sc->xl_media & XL_MEDIAOPT_BT4) {
		/*
		 * In theory I shouldn't need this, but... if this
		 * card supports an MII, either an external one or
		 * an internal fake one, select it in the internal
		 * config register before trying to probe it.
		 */
		u_int32_t		icfg;

		XL_SEL_WIN(3);
		icfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG);
		icfg &= ~XL_ICFG_CONNECTOR_MASK;
		if (sc->xl_media & XL_MEDIAOPT_MII ||
			sc->xl_media & XL_MEDIAOPT_BT4)
			icfg |= (XL_XCVR_MII << XL_ICFG_CONNECTOR_BITS);
		if (sc->xl_media & XL_MEDIAOPT_BTX)
			icfg |= (XL_XCVR_AUTO << XL_ICFG_CONNECTOR_BITS);
		if (sc->xl_media & XL_MEDIAOPT_BFX)
			icfg |= (XL_XCVR_100BFX << XL_ICFG_CONNECTOR_BITS);
		CSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);

		for (i = XL_PHYADDR_MIN; i < XL_PHYADDR_MAX + 1; i++) {
			sc->xl_phy_addr = i;
			xl_phy_writereg(sc, XL_PHY_GENCTL, PHY_BMCR_RESET);
			DELAY(500);
			while(xl_phy_readreg(sc, XL_PHY_GENCTL)
					& PHY_BMCR_RESET);
			if ((phy_sts = xl_phy_readreg(sc, XL_PHY_GENSTS)))
				break;
		}
		if (phy_sts) {
			phy_vid = xl_phy_readreg(sc, XL_PHY_VENID);
			phy_did = xl_phy_readreg(sc, XL_PHY_DEVID);
			p = xl_phys;
			while(p->xl_vid) {
				if (phy_vid == p->xl_vid &&
					(phy_did | 0x000F) == p->xl_did) {
					sc->xl_pinfo = p;
					break;
				}
				p++;
			}
			if (sc->xl_pinfo == NULL)
				sc->xl_pinfo = &xl_phys[PHY_UNKNOWN];
		} else {
			printf("xl%d: MII without any phy!\n", sc->xl_unit);
		}
	}

	/*
	 * Do ifmedia setup.
	 */
	ifmedia_init(&sc->ifmedia, 0, xl_ifmedia_upd, xl_ifmedia_sts);

	if (sc->xl_media & XL_MEDIAOPT_BT) {
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);
		if (sc->xl_caps & XL_CAPS_FULL_DUPLEX)
			ifmedia_add(&sc->ifmedia,
			    IFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);
	}

	if (sc->xl_media & (XL_MEDIAOPT_AUI|XL_MEDIAOPT_10FL)) {
		/*
		 * Check for a 10baseFL board in disguise.
		 */
		if (sc->xl_type == XL_TYPE_905B &&
		    sc->xl_media == XL_MEDIAOPT_10FL) {
			if (bootverbose)
				printf("xl%d: found 10baseFL\n", sc->xl_unit);
			ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_FL, 0, NULL);
			ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_FL|IFM_HDX,
			    0, NULL);
			if (sc->xl_caps & XL_CAPS_FULL_DUPLEX)
				ifmedia_add(&sc->ifmedia,
				    IFM_ETHER|IFM_10_FL|IFM_FDX, 0, NULL);
		} else {
			if (bootverbose)
				printf("xl%d: found AUI\n", sc->xl_unit);
			ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_5, 0, NULL);
		}
	}

	if (sc->xl_media & XL_MEDIAOPT_BNC) {
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_2, 0, NULL);
	}

	/*
	 * Technically we could use xl_getmode_mii() to scan the
	 * modes, but the built-in BTX mode on the 3c905B implies
	 * 10/100 full/half duplex support anyway, so why not just
	 * do it and get it over with.
	 */
	if (sc->xl_media & XL_MEDIAOPT_BTX) {
		ifp->if_baudrate = 100000000;
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_TX, 0, NULL);
		ifmedia_add(&sc->ifmedia,
			IFM_ETHER|IFM_100_TX|IFM_HDX, 0, NULL);
		if (sc->xl_caps & XL_CAPS_FULL_DUPLEX)
			ifmedia_add(&sc->ifmedia,
				IFM_ETHER|IFM_100_TX|IFM_FDX, 0, NULL);
		if (sc->xl_hasmii != 0)
			ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);
	}

	if (sc->xl_media & XL_MEDIAOPT_BFX) {
		ifp->if_baudrate = 100000000;
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_FX, 0, NULL);
	}

	/*
	 * If there's an MII, we have to probe its modes
	 * separately.
	 */
	if (sc->xl_media & XL_MEDIAOPT_MII || sc->xl_media & XL_MEDIAOPT_BT4) {
		xl_getmode_mii(sc);
	}

	/* Choose a default media. */
	switch(sc->xl_xcvr) {
	case XL_XCVR_10BT:
		media = IFM_ETHER|IFM_10_T;
		xl_setmode(sc, media);
		break;
	case XL_XCVR_AUI:
		if (sc->xl_type == XL_TYPE_905B &&
		    sc->xl_media == XL_MEDIAOPT_10FL) {
			media = IFM_ETHER|IFM_10_FL;
			xl_setmode(sc, media);
		} else {
			media = IFM_ETHER|IFM_10_5;
			xl_setmode(sc, media);
		}
		break;
	case XL_XCVR_COAX:
		media = IFM_ETHER|IFM_10_2;
		xl_setmode(sc, media);
		break;
	case XL_XCVR_AUTO:
#ifdef XL_BACKGROUND_AUTONEG
		xl_autoneg_mii(sc, XL_FLAG_SCHEDDELAY, 1);
#else
		xl_autoneg_mii(sc, XL_FLAG_FORCEDELAY, 1);
#endif
		media = sc->ifmedia.ifm_media;
		break;
	case XL_XCVR_100BTX:
	case XL_XCVR_MII:
#ifdef XL_BACKGROUND_AUTONEG
		xl_autoneg_mii(sc, XL_FLAG_SCHEDDELAY, 1);
#else
		xl_autoneg_mii(sc, XL_FLAG_FORCEDELAY, 1);
#endif
		media = sc->ifmedia.ifm_media;
		break;
	case XL_XCVR_100BFX:
		media = IFM_ETHER|IFM_100_FX;
		break;
	default:
		printf("xl%d: unknown XCVR type: %d\n", sc->xl_unit,
							sc->xl_xcvr);
		/*
		 * This will probably be wrong, but it prevents
	 	 * the ifmedia code from panicking.
		 */
		media = IFM_ETHER|IFM_10_T;
		break;
	}

	ifmedia_set(&sc->ifmedia, media);

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

#if NBPFILTER > 0
	bpfattach(ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif
	at_shutdown(xl_shutdown, sc, SHUTDOWN_POST_SYNC);

fail:
	splx(s);
	return;
}
#endif

d1323 1
a1323 1
static int xl_list_tx_init(sc)
d1351 1
a1351 1
static int xl_list_rx_init(sc)
d1385 1
a1385 1
static int xl_newbuf(sc, c)
d1392 1
a1392 5
	if (m_new == NULL) {
#if defined(__FreeBSD__)
		printf("xl%d: no memory for rx list -- packet dropped!\n",
								sc->xl_unit);
#endif
a1393 1
	}
a1396 4
#if defined(__FreeBSD__)
		printf("xl%d: no memory for rx list -- packet dropped!\n",
								sc->xl_unit);
#endif
d1416 1
a1416 1
static void xl_rxeof(sc)
d1424 1
a1424 1
	u_int16_t		rxstat;
d1481 1
a1481 4
		 * Handle BPF listeners. Let the BPF user see the packet, but
		 * don't pass it up to the ether_input() layer unless it's
		 * a broadcast packet, multicast packet, matches our ethernet
		 * address or the interface is in promiscuous mode.
a1484 3
#ifdef __FreeBSD__
			bpf_mtap(ifp, m);
#else
a1485 1
#endif
d1525 1
a1525 1
static void xl_txeof(sc)
d1584 1
a1584 1
static void xl_txeoc(sc)
d1634 1
a1634 2
#ifdef __OpenBSD__
static int xl_intr(arg)
a1635 4
#else
static void xl_intr(arg)
	void			*arg;
#endif
a1639 1
#ifdef __OpenBSD__
d1641 1
a1641 1
#endif
a1653 1
#ifdef __OpenBSD__
a1654 1
#endif
a1689 1
#ifdef __OpenBSD__
a1690 3
#else
	return;
#endif
d1693 1
a1693 1
static void xl_stats_update(xsc)
a1732 3
#ifdef __FreeBSD__
		sc->xl_stat_ch = timeout(xl_stats_update, sc, hz);
#else
a1733 1
#endif
d1742 1
a1742 1
static int xl_encap(sc, c, m_head)
d1784 1
a1784 4
		if (m_new == NULL) {
#if defined(__FreeBSD__)
			printf("xl%d: no memory for tx list", sc->xl_unit);
#endif
a1785 1
		}
a1789 4
#if defined(__FreeBSD__)
				printf("xl%d: no memory for tx list",
						sc->xl_unit);
#endif
d1818 1
a1818 1
static void xl_start(ifp)
a1873 3
#ifdef __FreeBSD__
			bpf_mtap(ifp, cur_tx->xl_mbuf);
#else
a1875 2

#endif
d1900 1
a1900 1
	if (CSR_READ_4(sc, XL_DOWNLIST_PTR)) {
d1910 2
d1913 1
a1913 1
	}
d1943 1
a1943 1
static void xl_init(xsc)
a2124 3
#ifdef __FreeBSD__
	sc->xl_stat_ch = timeout(xl_stats_update, sc, hz);
#else
a2125 1
#endif
d2133 1
a2133 1
static int xl_ifmedia_upd(ifp)
d2172 1
a2172 1
static void xl_ifmedia_sts(ifp, ifmr)
d2260 1
a2260 1
static int xl_ioctl(ifp, command, data)
a2271 1
#ifdef __OpenBSD__
a2275 1
#endif
a2277 7
#ifdef __FreeBSD__
	case SIOCSIFADDR:
	case SIOCGIFADDR:
	case SIOCSIFMTU:
		error = ether_ioctl(ifp, command, data);
		break;
#else
a2291 1
#endif
d2323 1
a2323 1
static void xl_watchdog(ifp)
d2333 2
d2349 1
d2362 1
a2362 1
static void xl_stop(sc)
a2387 3
#ifdef __FreeBSD__
	untimeout(xl_stats_update, sc, sc->xl_stat_ch);
#else
a2388 1
#endif
d2418 1
a2418 61
#ifdef __FreeBSD__
/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
static void xl_shutdown(howto, arg)
	int			howto;
	void			*arg;
{
	struct xl_softc		*sc = (struct xl_softc *)arg;

	xl_stop(sc);

	return;
}

static struct pci_device xl_device = {
	"xl",
	xl_probe,
	xl_attach,
	&xl_count,
	NULL
};
COMPAT_PCI_DRIVER(xl, xl_device);
#endif

#ifdef __OpenBSD__
static int
xl_probe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct pci_attach_args *pa = (struct pci_attach_args *) aux;

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_3COM)
		return (0);

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_3COM_3CSOHO100TX:
	case PCI_PRODUCT_3COM_3C900TPO:
	case PCI_PRODUCT_3COM_3C900COMBO:
	case PCI_PRODUCT_3COM_3C900B:
	case PCI_PRODUCT_3COM_3C900BCOMBO:
	case PCI_PRODUCT_3COM_3C900BTPC:
	case PCI_PRODUCT_3COM_3C900BFL:
	case PCI_PRODUCT_3COM_3C905TX:
	case PCI_PRODUCT_3COM_3C905T4:
	case PCI_PRODUCT_3COM_3C905BTX:
	case PCI_PRODUCT_3COM_3C905BT4:
	case PCI_PRODUCT_3COM_3C905BCOMBO:
	case PCI_PRODUCT_3COM_3C905BFX:
	case PCI_PRODUCT_3COM_3C980TX:
	case PCI_PRODUCT_3COM_3C905CTX:
		return (1);
	}
					
	return (0);
}

static void
d2750 1
d2760 1
d2793 1
a2793 1
static void
a2808 2

#endif
@


1.26
log
@use FreeBSD's alpha stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.25 1999/06/29 17:14:35 jason Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_xl.c,v 1.40 1999/06/01 19:04:23 wpaul Exp $
d198 1
a198 1
	"$FreeBSD: if_xl.c,v 1.40 1999/06/01 19:04:23 wpaul Exp $";
d1520 1
a1520 1
				(u_short *)&(sc->xl_bhandle))) {
d2132 7
d2140 1
a2140 1
			    XL_CMD_TX_SET_START|XL_MIN_FRAMELEN);
d2566 2
a2567 1
	CSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_SET_START|XL_MIN_FRAMELEN);
@


1.25
log
@merge with FreeBSD:
support for 3c905C
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.24 1999/05/07 21:24:33 jason Exp $	*/
d52 1
d54 1
a54 1
 * 3Com 3c900-FL	10Mbps FL Fiber-optic
a56 1
 * 3Com 3c905B-FX	100Mbs FX Fiber-optic
a1900 3
#if defined(__alpha__) && defined(__OpenBSD__)
	int pad;
#endif
a1910 6
#if defined(__alpha__) && defined(__OpenBSD__)
	pad = ALIGN(sizeof(struct ether_header)) - sizeof(struct ether_header);
	m_new->m_data += pad;
	m_new->m_len -= pad;
#endif

d1921 2
a1922 5
#if defined(__alpha__) && defined(__OpenBSD__)
	pad = ALIGN(sizeof(struct ether_header)) - sizeof(struct ether_header);
	m_new->m_data += pad;
	m_new->m_len -= pad;
#endif
@


1.24
log
@Sync with freebsd, highlights:
o Dynamically increase TX start threshold if TX underruns are detected.
o Fix selection for the 3c900B-FL 10baseFL adapter.
o Set the TX start threshold register to get better performance.
o Increase the size of the RX and TX rings.
o Support for the 3cSOHO100-TX
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.23 1999/03/03 22:51:51 jason Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_xl.c,v 1.35 1999/05/04 20:52:30 wpaul Exp $
d54 1
a157 7
#ifdef __OpenBSD__
#ifdef __alpha__
#undef vtophys
#define vtophys(va)	alpha_XXX_dmamap((vm_offset_t)(va))
#endif
#endif

d198 1
a198 1
	"$FreeBSD: if_xl.c,v 1.35 1999/05/04 20:52:30 wpaul Exp $";
d230 2
d1408 2
a1409 1
	case TC_DEVICEID_HURRICANE_SOHO100TX:	/* 3c980-TX */
d1522 3
a1524 3
		printf ("xl%d: WARNING: this shouldn't happen! "
		    "Possible PCI support code bug!", unit);
		printf ("xl%d: attempting to map iobase manually", unit);
a3013 1
#ifdef COMPAT_PCI_DRIVER
a3014 3
#else
DATA_SET(pcidevice_set, xl_device);
#endif /* COMPAT_PCI_DRIVER */
d3044 1
@


1.23
log
@remove alot of verbosity
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.22 1999/03/02 02:25:39 jason Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_xl.c,v 1.25 1999/02/26 08:39:24 wpaul Exp $
d40 1
a40 1
 * Supports the 3Com "boomerang" and "cyclone" PCI
d50 2
d56 1
d148 5
d204 1
a204 1
	"$FreeBSD: if_xl.c,v 1.25 1999/02/26 08:39:24 wpaul Exp $";
d213 1
a213 1
		"3Com 3c900 Etherlink XL 10BaseT" },
d215 1
a215 1
		"3Com 3c900 Etherlink XL 10BaseT Combo" },
d217 1
a217 1
		"3Com 3c905 Fast Etherlink XL 10/100BaseTX" },
d219 11
a229 7
		"3Com 3c905 Fast Etherlink XL 10/100BaseT4" },
	{ TC_VENDORID, TC_DEVICEID_CYCLONE_10BT,
		"3Com 3c900B Etherlink XL 10BaseT" },
	{ TC_VENDORID, TC_DEVICEID_CYCLONE_10BT_COMBO,
		"3Com 3c900B Etherlink XL 10BaseT Combo" },
	{ TC_VENDORID, TC_DEVICEID_CYCLONE_10_100BT,
		"3Com 3c905B Fast Etherlink XL 10/100BaseTX" },
d231 1
a231 1
		"3Com 3c905B Fast Etherlink XL 10/100BaseT4" },
d233 7
a239 3
		"3Com 3c905B Fast Etherlink XL 10/100BaseFX/SC" },
	{ TC_VENDORID, TC_DEVICEID_CYCLONE_10_100BT_SERV,
		"3Com 3c980 Fast Etherlink XL 10/100BaseTX" },
d335 1
a513 2


d841 15
d1216 1
a1216 1
	if (sc->xl_media & XL_MEDIAOPT_AUI) {
d1226 9
d1277 2
d1283 6
d1345 3
a1347 3
	 	* Check the XCVR value. If it's not in the normal range
	 	* of values, we need to fake it up here.
	 	*/
d1357 3
d1377 2
a1378 2
	case TC_DEVICEID_BOOMERANG_10BT:	/* 3c900-TP */
	case TC_DEVICEID_CYCLONE_10BT:		/* 3c900B-TP */
d1384 1
a1384 1
	case TC_DEVICEID_CYCLONE_10BT_COMBO:	/* 3c900B-COMBO */
d1389 10
d1410 3
a1412 2
	case TC_DEVICEID_CYCLONE_10_100BT:	/* 3c905B-TX */
	case TC_DEVICEID_CYCLONE_10_100BT_SERV:	/* 3c980-TX */
d1417 5
d1461 1
a1461 1
		return;
d1522 10
d1533 6
a1538 1
	sc->iobase = pci_conf_read(config_id, XL_PCI_LOIO) & 0xFFFFFFE0;
d1549 7
a1555 1
	sc->csr = (volatile caddr_t)vbase;
d1590 1
a1590 1
		return;
d1594 1
a1594 1
	round = (unsigned int)sc->xl_ldata_ptr & 0xF;
d1705 1
a1705 1
				IFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);
d1708 19
a1726 2
	if (sc->xl_media & XL_MEDIAOPT_AUI) {
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_5, 0, NULL);
d1771 8
a1778 2
		media = IFM_ETHER|IFM_10_5;
		xl_setmode(sc, media);
d2011 1
a2094 1

d2097 1
d2147 2
a2189 1

d2199 4
a2202 1
		if (status & XL_STAT_UP_COMPLETE) {
a2203 3
			CSR_WRITE_2(sc, XL_COMMAND,
				XL_CMD_INTR_ACK|XL_STAT_UP_COMPLETE);
		}
d2205 1
a2205 1
		if (status & XL_STAT_DOWN_COMPLETE) {
a2206 3
			CSR_WRITE_2(sc, XL_COMMAND,
				XL_CMD_INTR_ACK|XL_STAT_DOWN_COMPLETE);
		}
a2210 2
			CSR_WRITE_2(sc, XL_COMMAND,
				XL_CMD_INTR_ACK|XL_STAT_TX_COMPLETE);
a2215 2
			CSR_WRITE_2(sc, XL_COMMAND,
				XL_CMD_INTR_ACK|XL_STAT_ADFAIL);
a2222 3

		CSR_WRITE_2(sc, XL_STATUS, XL_CMD_INTR_ACK|XL_STAT_INTREQ|
							XL_STAT_INTLATCH);
d2230 1
a2230 1
	if (ifp->if_snd.ifq_head != NULL) {
a2231 1
	}
a2261 3
	ifp->if_ipackets += xl_rx_goodframes(xl_stats);
	ifp->if_opackets += xl_tx_goodframes(xl_stats);

a2376 1

d2573 3
d2710 11
d2762 9
a2770 1
		ifmr->ifm_active = IFM_ETHER|IFM_10_5;
d3017 3
d3021 1
d3037 1
d3042 2
d3048 2
a3050 1
	case PCI_PRODUCT_3COM_3C905BFX:
d3146 1
a3146 1
	if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->sc_sh)) {
d3150 1
a3150 1
	sc->sc_st = pa->pa_iot;
d3160 1
a3160 1
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->sc_sh)) {
d3164 1
a3164 1
	sc->sc_st = pa->pa_memt;
d3309 1
a3309 1
				IFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);
d3312 15
a3326 2
	if (sc->xl_media & XL_MEDIAOPT_AUI) {
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_5, 0, NULL);
d3371 8
a3378 2
		media = IFM_ETHER|IFM_10_5;
		xl_setmode(sc, media);
@


1.22
log
@put the DELAY back into xl_wait()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.21 1999/02/27 23:54:42 jason Exp $	*/
a116 2
#define bootverbose 0

a225 1
#endif
d242 1
a1013 2
	if (bootverbose)
		printf("xl%d: PHY status word: %x\n", sc->xl_unit, bmsr);
a1018 3
		if (bootverbose)
			printf("xl%d: 10Mbps half-duplex mode supported\n",
								sc->xl_unit);
a1024 3
		if (bootverbose)
			printf("xl%d: 10Mbps full-duplex mode supported\n",
								sc->xl_unit);
a1030 3
		if (bootverbose)
			printf("xl%d: 100Mbps half-duplex mode supported\n",
								sc->xl_unit);
a1038 3
		if (bootverbose)
			printf("xl%d: 100Mbps full-duplex mode supported\n",
								sc->xl_unit);
a1046 2
		if (bootverbose)
			printf("xl%d: 100baseT4 mode supported\n", sc->xl_unit);
a1050 3
		if (bootverbose)
			printf("xl%d: forcing on autoneg support for BT4\n",
							 sc->xl_unit);
a1056 2
		if (bootverbose)
			printf("xl%d: autoneg supported\n", sc->xl_unit);
a1550 3
	if (bootverbose)
		printf("xl%d: media options word: %x\n", sc->xl_unit,
							 sc->xl_media);
a1579 2
		if (bootverbose)
			printf("xl%d: probing for a PHY\n", sc->xl_unit);
a1580 3
			if (bootverbose)
				printf("xl%d: checking address: %d\n",
							sc->xl_unit, i);
a1591 6
			if (bootverbose)
				printf("xl%d: found PHY at address %d, ",
						sc->xl_unit, sc->xl_phy_addr);
			if (bootverbose)
				printf("vendor id: %x device id: %x\n",
					phy_vid, phy_did);
a1602 3
			if (bootverbose)
				printf("xl%d: PHY type: %s\n",
					sc->xl_unit, sc->xl_pinfo->xl_name);
a1613 2
		if (bootverbose)
			printf("xl%d: found 10baseT\n", sc->xl_unit);
a1621 2
		if (bootverbose)
			printf("xl%d: found AUI\n", sc->xl_unit);
a1625 2
		if (bootverbose)
			printf("xl%d: found BNC\n", sc->xl_unit);
a1635 2
		if (bootverbose)
			printf("xl%d: found 100baseTX\n", sc->xl_unit);
d1643 1
a1643 1
		if (sc->xl_pinfo != NULL)
a1647 2
		if (bootverbose)
			printf("xl%d: found 100baseFX\n", sc->xl_unit);
a1656 2
		if (bootverbose)
			printf("xl%d: found MII\n", sc->xl_unit);
d2428 1
a2428 1
	if (sc->xl_pinfo != NULL)
d2575 1
a2575 1
	if (sc->xl_pinfo != NULL)
a2948 1
	struct xl_type *p;
a3121 3
	if (bootverbose)
		printf("xl%d: media options word: %x\n",
		    sc->xl_unit, sc->xl_media);
d3163 1
a3163 20
			if (bootverbose)
				printf("xl%d: found PHY at address %d, ",
						sc->xl_unit, sc->xl_phy_addr);
			if (bootverbose)
				printf("vendor id: %x device id: %x\n",
					phy_vid, phy_did);
			p = xl_phys;
			while(p->xl_vid) {
				if (phy_vid == p->xl_vid &&
					(phy_did | 0x000F) == p->xl_did) {
					sc->xl_pinfo = p;
					break;
				}
				p++;
			}
			if (sc->xl_pinfo == NULL)
				sc->xl_pinfo = &xl_phys[PHY_UNKNOWN];
			if (bootverbose)
				printf("xl%d: PHY type: %s\n",
					sc->xl_unit, sc->xl_pinfo->xl_name);
a3177 2
		if (bootverbose)
			printf("xl%d: found 10baseT\n", sc->xl_unit);
a3185 2
		if (bootverbose)
			printf("xl%d: found AUI\n", sc->xl_unit);
a3189 2
		if (bootverbose)
			printf("xl%d: found BNC\n", sc->xl_unit);
a3199 2
		if (bootverbose)
			printf("xl%d: found 100baseTX\n", sc->xl_unit);
d3207 1
a3207 1
		if (sc->xl_pinfo != NULL)
a3211 2
		if (bootverbose)
			printf("xl%d: found 100baseFX\n", sc->xl_unit);
a3220 2
		if (bootverbose)
			printf("xl%d: found MII\n", sc->xl_unit);
@


1.21
log
@sync with freebsd:
o remove call to DELAY from xl_wait()
o do not issue RX and TX resets in xl_stop() & xl_init()
o be sure that ifp->if_snd.ifq_maxlen is initialized
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.20 1999/02/26 17:05:55 jason Exp $	*/
d317 1
@


1.20
log
@compensate for the fact that the check for ownership of a unicast packet
has moved to ether_input()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.19 1999/02/23 21:06:06 jason Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_xl.c,v 1.22 1998/12/24 17:50:34 wpaul Exp $
d198 1
a198 1
	"$FreeBSD: if_xl.c,v 1.22 1998/12/24 17:50:34 wpaul Exp $";
a316 1
		DELAY(10);
d1553 1
d2500 1
d2506 1
d2883 1
d2888 1
d3158 1
@


1.19
log
@Do a better job of reinitializing it the xl is found in powered down state.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.18 1998/12/31 02:47:41 jason Exp $	*/
a1967 7
			if (ifp->if_flags & IFF_PROMISC &&
				(bcmp(eh->ether_dhost, sc->arpcom.ac_enaddr,
						ETHER_ADDR_LEN) &&
					(eh->ether_dhost[0] & 1) == 0)) {
				m_freem(m);
				continue;
			}
@


1.18
log
@make sure xl_tx_tail pointer gets updated; freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.17 1998/12/22 22:47:14 jason Exp $	*/
d3024 1
a3024 1
	command = pci_conf_read(pa->pa_pc, pa->pa_tag, XL_PCI_CAPID) & 0xff;
d3027 1
a3027 1
		command = pci_conf_read(pa->pa_pc, pa->pa_tag,
d3030 7
d3042 1
a3042 1
			pci_conf_write(pa->pa_pc, pa->pa_tag,
d3044 4
d3054 1
a3054 1
	command = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
d3058 2
a3059 2
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
	command = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
@


1.17
log
@sync with FreeBSD:
o minor fix for xl_txeof
o defensive code for for xl_start
o ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.16 1998/12/21 06:22:58 jason Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_xl.c,v 1.21 1998/12/14 06:32:57 dillon Exp $
d198 1
a198 1
	"$FreeBSD: if_xl.c,v 1.21 1998/12/14 06:32:57 dillon Exp $";
d2431 1
@


1.16
log
@If no mii found on a card that claims to support one, don't attach the
interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.15 1998/11/23 19:56:50 jason Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_xl.c,v 1.16 1998/10/22 16:46:26 wpaul Exp $
d197 2
a198 2
static char rcsid[] =
	"$FreeBSD: if_xl.c,v 1.16 1998/10/22 16:46:26 wpaul Exp $";
d248 1
a248 1
static char *xl_probe		__P((pcici_t, pcidi_t));
d273 1
a273 1
static u_int8_t xl_calchash	__P((u_int8_t *));
d291 1
a291 1
static void xl_phy_writereg	__P((struct xl_softc *, u_int16_t, u_int16_t));
d562 2
a563 2
	u_int16_t		reg;
	u_int16_t		data;
d652 1
a652 1
	u_int8_t		*addr;
d1275 1
a1275 1
static char *
a2047 2
		if (!cur_tx->xl_ptr->xl_next);
			break;
d2402 6
@


1.15
log
@clean up, make more quiet, and nuke unused 'csr' variable
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.14 1998/11/16 15:29:18 jason Exp $	*/
d3228 1
@


1.14
log
@fix up pointer alignment for buffers
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.13 1998/11/11 23:25:02 jason Exp $	*/
d1851 1
d1854 1
d1866 1
d1869 1
d2298 1
d2300 1
d2307 1
d2310 1
d3065 1
a3065 2
		printf("%s: failed to enable memory mapping\n",
		    sc->sc_dev.dv_xname);
a3075 1
	sc->csr = (volatile caddr_t)&iobase;
d3105 1
a3105 1
		printf("%s: failed to read station address\n",
@


1.13
log
@Merge with FreeBSD:
o Fix syntax errors inside #ifdef FORCE_AUTONEG_TFOUR.
o jack up the TX reclaim threshold for 3c90xB adapters
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.12 1998/10/09 00:15:35 deraadt Exp $	*/
d1536 1
a1536 1
		}
d3125 2
a3126 2
		}
		break;
@


1.12
log
@support 905B-FX cards
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.11 1998/09/29 02:14:29 jason Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_xl.c,v 1.12 1998/09/25 17:34:19 wpaul Exp $
d198 1
a198 1
	"$FreeBSD: if_xl.c,v 1.12 1998/09/25 17:34:19 wpaul Exp $";
d222 2
d1072 1
a1072 1
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0 NULL):
d2092 4
d2518 14
@


1.11
log
@Merge with FreeBSD: if_xlreg.h(1.5) & if_xl.c(1.12)
o workaround for ifmedia_set panic
o make sure tx isn't wedged if tx queue is full
o increase TX queue from 10 -> 16 descriptors
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.10 1998/09/23 20:48:46 jason Exp $	*/
d51 1
a51 1
 * 3Com 3c905B-FL/FX	10/100Mbps/Fiber-optic
d53 1
d2944 1
@


1.10
log
@Work around a bug in the newer revision chip sets.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.9 1998/09/11 03:23:15 jason Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_xl.c,v 1.11 1998/09/08 23:42:10 wpaul Exp $
d197 1
a197 1
	"$FreeBSD: if_xl.c,v 1.11 1998/09/08 23:42:10 wpaul Exp $";
d874 8
d983 8
a990 1
			printf("no carrier\n");
a1722 1
		media = IFM_ETHER|IFM_AUTO;
d1728 1
d2340 2
a2341 7
	 * If the OACTIVE flag is set, make sure the transmitter
	 * isn't wedged. Call the txeoc handler to make sure the
	 * transmitter is enabled and then call the txeof handler
	 * to see if any descriptors can be reclaimed and reload
	 * the downlist pointer register if necessary. If after
	 * that the OACTIVE flag is still set, return, otherwise
 	 * proceed and queue up some more frames.
d2343 1
a2343 1
	if (ifp->if_flags & IFF_OACTIVE) {
d2346 2
a2347 1
		if (ifp->if_flags & IFF_OACTIVE)
d2349 1
a2349 9
	}

	/*
	 * Check for an available queue slot. If there are none,
	 * punt.
	 */
	if (sc->xl_cdata.xl_tx_free == NULL) {
		ifp->if_flags |= IFF_OACTIVE;
		return;
d2823 6
a3281 1
		media = IFM_ETHER|IFM_AUTO;
d3287 1
@


1.9
log
@Merge with FreeBSD 1.11:
1. If oactive on entry to xl_start, see if tx is wedged, and try unwedging
   it if necessary.
2. Do a synchonous media negotiation at boot (max of 5 seconds)
3. Start and restart autonegotiation if we're setting the media manually
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.8 1998/09/09 22:06:57 jason Exp $	*/
d854 2
a1716 1
		media = sc->ifmedia.ifm_media;
d1722 1
a3281 1
		media = sc->ifmedia.ifm_media;
d3287 1
@


1.8
log
@o Fixed printing of intrstr and other typos
o Added support for memory mapped registers (#ifndef XL_USEIOSPACE)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.7 1998/09/09 21:35:46 maja Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_xl.c,v 1.10 1998/09/06 14:58:46 wpaul Exp $
a166 1
#if defined(__i386__)
d168 20
a187 1
#endif
d197 1
a197 1
	"$FreeBSD: if_xl.c,v 1.10 1998/09/06 14:58:46 wpaul Exp $";
d885 1
a885 1
		DELAY(3000000);
d1076 14
d1707 1
d1709 3
d1716 1
d1718 3
d1728 5
d2035 2
a2036 1
		if (CSR_READ_4(sc, XL_DMACTL) & XL_DMACTL_DOWN_STALLED) {
d2323 16
d3272 1
d3274 3
d3281 1
d3283 3
d3293 5
@


1.7
log
@Now working on alpha too... -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.6 1998/09/08 03:02:57 jason Exp $	*/
d167 1
d169 1
a2887 1
	bus_space_tag_t iot = pa->pa_iot;
d2942 1
a2947 1

d2955 1
a2955 1
	if (bus_space_map(iot, iobase, iosize, 0, &sc->sc_sh)) {
d2959 18
a2976 1
	sc->sc_st = iot;
d2996 1
@


1.6
log
@o Sync with FreeBSD (if_xl.c 1.10)
   better handling of memory, typos, 3c980 support
o Change tests for 3c980 to match the FreeBSD method in xl_mediacheck()
o Added matches for 3c900b and 3c900b-combo (support untested)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.5 1998/09/04 12:58:12 maja Exp $	*/
d150 6
d1778 3
d1789 6
d1803 6
d3001 3
d3005 1
@


1.5
log
@Add support for 3c980 (Server NIC) -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.4 1998/09/03 06:24:19 jason Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_xl.c,v 1.6 1998/08/30 22:24:18 wpaul Exp $
d48 2
d52 2
a53 1
 * Dell Optiplex GX1 on-board 3c905B 10/100Mbps/RJ-45
d171 1
a171 1
	"$Id: if_xl.c,v 1.4 1998/09/03 06:24:19 jason Exp $";
d188 1
a188 1
		"3Com 3c905B Etherlink XL 10BaseT" },
d190 1
a190 1
		"3Com 3c905B Etherlink XL 10BaseT Combo" },
d195 2
d1259 21
a1279 2
	if (sc->xl_media & (XL_MEDIAOPT_MASK & ~XL_MEDIAOPT_VCO))
		return;
a1280 6
	printf("xl%d: WARNING: no media options bits set in "
		"the media options register!!\n", sc->xl_unit);
	printf("xl%d: this could be a manufacturing defect in "
		"your adapter or system\n", sc->xl_unit);
	printf("xl%d: attempting to guess media type; you "
		"should probably consult your vendor\n", sc->xl_unit);
d1291 1
a1291 1
	case TC_DEVICEID_CYCLONE_10BT:		/* 3c905B-TP */
d1293 1
d1297 1
a1297 1
	case TC_DEVICEID_CYCLONE_10BT_COMBO:	/* 3c905B-COMBO */
d1299 1
d1304 1
d1310 1
a1312 3
#if defined(__OpenBSD__)
	case PCI_PRODUCT_3COM_3C980TX:		/* 3c980-TX */
#endif 
d1314 1
d1316 1
d1393 1
a1393 1
			printf("xl%d: chip is is in D%d power mode "
a1516 2
	xl_mediacheck(sc);

d1520 3
d1746 2
a1747 1
		xl_newbuf(sc, &cd->xl_rx_chain[i]);
d1775 2
a1776 2
		printf("xl%d: no memory for rx list",
				sc->xl_unit);
d1782 2
a1783 1
		printf("xl%d: no memory for rx list", sc->xl_unit);
d1816 2
a1826 1
			sc->xl_cdata.xl_rx_head = cur_rx->xl_next;
a1839 1
			sc->xl_cdata.xl_rx_head = cur_rx->xl_next;
a1843 1
		sc->xl_cdata.xl_rx_head = cur_rx->xl_next;
d1846 13
a1858 1
		xl_newbuf(sc, cur_rx);
d1995 2
a1996 1
			CSR_WRITE_4(sc, XL_DOWNLIST_PTR,
d2404 4
a2407 2
	if (xl_list_rx_init(sc)) {
		printf("xl%d: failed to set up rx lists\n", sc->xl_unit);
d2840 2
d2901 1
a2901 1
			printf("%s: chip is is in D%d power mode "
a3017 1
	xl_mediacheck(sc);
d3022 3
@


1.4
log
@o OpenBSD gets if_media support (from NetBSD)
o rework/simplify if_xl to use it
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.3 1998/09/02 06:04:47 jason Exp $	*/
d168 1
a168 1
	"$Id: if_xl.c,v 1.3 1998/09/02 06:04:47 jason Exp $";
d1291 3
d2806 1
@


1.3
log
@Maintain FreeBSD RCS id's
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.2 1998/09/02 04:49:12 jason Exp $	*/
a109 1
#include <net/if_media.h>
d113 2
d133 2
d168 1
a168 1
	"$Id: if_xl.c,v 1.2 1998/09/02 04:49:12 jason Exp $";
d194 1
a210 1
#endif
a215 5
static int xl_ifmedia_upd	__P((struct ifnet *));
static void xl_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));
static void xl_setmode_mii	__P((struct xl_softc *, int));
static void xl_getmode_mii	__P((struct xl_softc *));
static void xl_setmode		__P((struct xl_softc *, int));
d242 3
d246 2
a817 1
#ifndef __OpenBSD__
a820 1
#endif
a900 1
#ifndef __OpenBSD__
a901 1
#endif
a906 1
#ifndef __OpenBSD__
a907 1
#endif
a912 1
#ifndef __OpenBSD__
a913 1
#endif
a918 1
#ifndef __OpenBSD__
a919 1
#endif
a924 1
#ifndef __OpenBSD__
a925 1
#endif
a955 1
#ifdef __FreeBSD__
a1191 1
#endif
a2485 1
#ifdef __FreeBSD__
a2595 1
#endif
a2602 1
#if defined(__FreeBSD__)
a2603 1
#else
a2604 1
#endif
a2655 1
#ifdef __FreeBSD__
a2659 1
#endif
d2825 1
a2825 1
	u_int16_t phy_sts;
d2828 2
a2829 1
	int i;
d2833 17
a2913 17
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = xl_ioctl;
	ifp->if_start = xl_start;
	ifp->if_watchdog = xl_watchdog;

	printf(": %s\n", intrstr);

	if_attach(ifp);
	ether_ifattach(ifp);
#if NBPFILTER > 0
	bpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
		sizeof(struct ether_header));
#endif
	shutdownhook_establish(xl_shutdown, sc);

d2916 3
d2926 1
a2926 2
	printf(" address %s\n", sc->sc_dev.dv_xname,
	    ether_sprintf(sc->arpcom.ac_enaddr));
d2948 15
d2971 3
d3010 25
a3034 1
		if (!phy_sts) {
d3040 80
a3119 1
	if (sc->xl_xcvr == XL_XCVR_AUTO || sc->xl_xcvr == XL_XCVR_MII)
d3121 28
@


1.2
log
@KNF & printf formatting
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl.c,v 1.1 1998/09/02 03:01:05 jason Exp $	*/
d34 1
a34 1
 *	$Id: if_xl.c,v 1.1 1998/09/02 03:01:05 jason Exp $
d165 1
a165 1
	"$Id: if_xl.c,v 1.1 1998/09/02 03:01:05 jason Exp $";
@


1.1
log
@o new driver for the 3c900, 3c905, 3c905b ported from FreeBSD
o removed if_ep devices in favor of if_xl driver
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
 *	$Id: if_xl.c,v 1.6 1998/08/30 22:24:18 wpaul Exp $
d165 1
a165 1
	"$Id: if_xl.c,v 1.6 1998/08/30 22:24:18 wpaul Exp $";
d2815 6
a2820 6
	    case PCI_PRODUCT_3COM_3C900TPO:
	    case PCI_PRODUCT_3COM_3C900COMBO:
	    case PCI_PRODUCT_3COM_3C905TX:
	    case PCI_PRODUCT_3COM_3C905T4:
	    case PCI_PRODUCT_3COM_3C905BTX:
	    case PCI_PRODUCT_3COM_3C905BT4:
a2910 1
		printf("\n");
d2940 1
a2940 1
	printf("%s: address %s\n", sc->sc_dev.dv_xname,
@

