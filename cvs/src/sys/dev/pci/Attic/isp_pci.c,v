head	1.63;
access;
symbols
	OPENBSD_5_7:1.62.0.4
	OPENBSD_5_7_BASE:1.62
	OPENBSD_5_6:1.61.0.4
	OPENBSD_5_6_BASE:1.61
	OPENBSD_5_5:1.59.0.4
	OPENBSD_5_5_BASE:1.59
	OPENBSD_5_4:1.57.0.10
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.57.0.8
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.57.0.6
	OPENBSD_5_2_BASE:1.57
	OPENBSD_5_1_BASE:1.57
	OPENBSD_5_1:1.57.0.4
	OPENBSD_5_0:1.57.0.2
	OPENBSD_5_0_BASE:1.57
	OPENBSD_4_9:1.53.0.6
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.53.0.4
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.53.0.2
	OPENBSD_4_7_BASE:1.53
	OPENBSD_4_6:1.51.0.4
	OPENBSD_4_6_BASE:1.51
	OPENBSD_4_5:1.44.0.4
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.44.0.2
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.39.0.4
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.39.0.2
	OPENBSD_4_1_BASE:1.39
	OPENBSD_4_0:1.38.0.4
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.38.0.2
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.37.0.2
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.35.0.6
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.35.0.4
	OPENBSD_3_6_BASE:1.35
	SMP_SYNC_A:1.35
	SMP_SYNC_B:1.35
	OPENBSD_3_5:1.35.0.2
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.34.0.2
	OPENBSD_3_4_BASE:1.34
	UBC_SYNC_A:1.33
	OPENBSD_3_3:1.33.0.2
	OPENBSD_3_3_BASE:1.33
	OPENBSD_3_2:1.29.0.2
	OPENBSD_3_2_BASE:1.29
	OPENBSD_3_1:1.27.0.4
	OPENBSD_3_1_BASE:1.27
	UBC_SYNC_B:1.29
	UBC:1.27.0.2
	UBC_BASE:1.27
	OPENBSD_3_0:1.25.0.2
	OPENBSD_3_0_BASE:1.25
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	SMP:1.10.0.2
	SMP_BASE:1.10
	kame_19991208:1.9
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.63
date	2015.06.19.11.12.24;	author jmatthew;	state dead;
branches;
next	1.62;
commitid	I5HMIEQiHPSVn0jd;

1.62
date	2014.12.13.21.05.33;	author doug;	state Exp;
branches;
next	1.61;
commitid	20ZyHa9gTJxHxhwD;

1.61
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	JtO5uXxVcnZfhUkR;

1.60
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.59;
commitid	OBNa5kfxQ2UXoiIw;

1.59
date	2014.02.14.05.17.05;	author jmatthew;	state Exp;
branches;
next	1.58;

1.58
date	2014.02.10.22.41.27;	author jmatthew;	state Exp;
branches;
next	1.57;

1.57
date	2011.06.23.22.02.26;	author oga;	state Exp;
branches;
next	1.56;

1.56
date	2011.06.17.07.06.47;	author mk;	state Exp;
branches;
next	1.55;

1.55
date	2011.04.22.23.19.54;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2011.04.03.15.36.03;	author jasper;	state Exp;
branches;
next	1.53;

1.53
date	2009.11.07.14.49.02;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2009.08.09.09.55.03;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2009.06.29.18.53.38;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2009.06.29.18.53.01;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2009.06.28.01.35.27;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2009.06.24.11.38.40;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2009.06.24.11.00.53;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2009.05.31.17.42.13;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2009.05.08.18.39.01;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2008.06.01.15.49.25;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2008.05.28.18.46.56;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2008.04.13.15.31.33;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2008.01.21.20.00.33;	author sobrado;	state Exp;
branches;
next	1.40;

1.40
date	2007.09.22.16.03.23;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2007.02.28.19.40.38;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2005.09.11.18.17.08;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2005.08.09.04.10.13;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.08.02.07.49;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.06.14.40.33;	author grange;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.26.00.47.47;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2003.03.03.18.27.11;	author mjacob;	state Exp;
branches;
next	1.32;

1.32
date	2003.02.28.15.36.39;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2003.02.28.15.26.23;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2003.02.28.15.14.08;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2002.08.17.17.35.48;	author mjacob;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.17.01.22.38;	author mjacob;	state Exp;
branches;
next	1.27;

1.27
date	2001.12.14.00.20.55;	author mjacob;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2001.10.06.22.45.52;	author mjacob;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.29.01.23.54;	author mjacob;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.01.07.16.40;	author mjacob;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.26.03.32.22;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.25.14.52.57;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.16.12.51.49;	author ho;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.04.22.05.37;	author mjacob;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.09.17.39.12;	author nate;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.02.08.58.09;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.12.23.42.42;	author mjacob;	state Exp;
branches;
next	1.14;

1.14
date	2000.10.16.22.45.01;	author mjacob;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.16.01.01.58;	author mjacob;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.06.05.11.26;	author mjacob;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.20.21.16.35;	author mjacob;	state Exp;
branches;
next	1.10;

1.10
date	99.12.16.05.19.50;	author mjacob;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	99.11.22.12.52.46;	author mjacob;	state Exp;
branches;
next	1.8;

1.8
date	99.04.04.01.55.45;	author mjacob;	state Exp;
branches;
next	1.7;

1.7
date	99.04.04.01.17.02;	author mjacob;	state Exp;
branches;
next	1.6;

1.6
date	99.03.25.22.58.44;	author mjacob;	state Exp;
branches;
next	1.5;

1.5
date	99.03.17.12.53.29;	author mjacob;	state Exp;
branches;
next	1.4;

1.4
date	99.03.17.05.32.34;	author mjacob;	state Exp;
branches;
next	1.3;

1.3
date	99.01.11.01.51.58;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	98.03.24.04.08.53;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	98.03.24.03.26.49;	author deraadt;	state Exp;
branches;
next	;

1.10.2.1
date	2000.02.21.22.29.14;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.05.14.22.25.50;	author niklas;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2001.07.04.10.42.37;	author niklas;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.10.2.6;

1.10.2.6
date	2002.03.06.02.11.46;	author niklas;	state Exp;
branches;
next	1.10.2.7;

1.10.2.7
date	2003.03.28.00.38.23;	author niklas;	state Exp;
branches;
next	1.10.2.8;

1.10.2.8
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	;

1.27.2.1
date	2002.06.11.03.42.26;	author art;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2002.10.29.00.33.29;	author art;	state Exp;
branches;
next	1.27.2.3;

1.27.2.3
date	2003.05.19.22.18.01;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.63
log
@remove isp(4) now that the ql* family have replaced it
@
text
@/*	$OpenBSD: isp_pci.c,v 1.62 2014/12/13 21:05:33 doug Exp $	*/
/* $FreeBSD: src/sys/dev/isp/isp_pci.c,v 1.148 2007/06/26 23:08:57 mjacob Exp $*/
/*-
 * Copyright (c) 1997-2006 by Matthew Jacob
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * PCI specific probe and attach routines for Qlogic ISP SCSI adapters.
 * FreeBSD Version.
 */

#include <dev/ic/isp_openbsd.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#ifdef __sparc64__
#include <dev/ofw/openfirm.h>
#endif
#ifdef __sgi__
#include <machine/autoconf.h>
#include <mips64/archtype.h>
#endif

#ifndef ISP_NOFIRMWARE
#define	ISP_FIRMWARE_1040
#define	ISP_FIRMWARE_1080
#define	ISP_FIRMWARE_12160
#define	ISP_FIRMWARE_2100
#define	ISP_FIRMWARE_2200
#define	ISP_FIRMWARE_2300
#endif

#if	defined(ISP_FIRMWARE_1040)
#define	ISP_1040_RISC_CODE	(u_int16_t *) isp_1040_risc_code
#include <dev/microcode/isp/asm_1040.h>
#else
#define	ISP_1040_RISC_CODE	NULL
#endif

#if	defined(ISP_FIRMWARE_1080)
#define	ISP_1080_RISC_CODE	(u_int16_t *) isp_1080_risc_code
#include <dev/microcode/isp/asm_1080.h>
#else
#define	ISP_1080_RISC_CODE	NULL
#endif

#if	defined(ISP_FIRMWARE_12160)
#define	ISP_12160_RISC_CODE	(u_int16_t *) isp_12160_risc_code
#include <dev/microcode/isp/asm_12160.h>
#else
#define	ISP_12160_RISC_CODE	NULL
#endif

#if	defined(ISP_FIRMWARE_2100)
extern const u_int16_t isp_2100_risc_code[];
#define	ISP_2100_RISC_CODE	(u_int16_t *) isp_2100_risc_code
#else
#define	ISP_2100_RISC_CODE	NULL
#endif

#if	defined(ISP_FIRMWARE_2200)
extern const u_int16_t isp_2200_risc_code[];
#define	ISP_2200_RISC_CODE	(u_int16_t *) isp_2200_risc_code
#else
#define	ISP_2200_RISC_CODE	NULL
#endif

#if	defined(ISP_FIRMWARE_2300)
extern const u_int16_t isp_2300_risc_code[];
#define	ISP_2300_RISC_CODE	(u_int16_t *) isp_2300_risc_code
#else
#define	ISP_2300_RISC_CODE	NULL
#endif

#if	defined(ISP_FIRMWARE_2400)
#define	ISP_2400_RISC_CODE	(u_int16_t *) isp_2400_risc_code
#include <dev/microcode/isp/asm_2400.h>
#else
#define	ISP_2400_RISC_CODE	NULL
#endif

uint32_t isp_pci_rd_reg(ispsoftc_t *, int);
void isp_pci_wr_reg(ispsoftc_t *, int, uint32_t);
uint32_t isp_pci_rd_reg_1080(ispsoftc_t *, int);
void isp_pci_wr_reg_1080(ispsoftc_t *, int, uint32_t);
uint32_t isp_pci_rd_reg_2400(ispsoftc_t *, int);
void isp_pci_wr_reg_2400(ispsoftc_t *, int, uint32_t);
int isp_pci_rd_isr(ispsoftc_t *, uint32_t *, uint16_t *, uint16_t *);
int isp_pci_rd_isr_2300(ispsoftc_t *, uint32_t *, uint16_t *, uint16_t *);
int isp_pci_rd_isr_2400(ispsoftc_t *, uint32_t *, uint16_t *, uint16_t *);
int isp_pci_mbxdma(ispsoftc_t *);
int isp_pci_dmasetup(ispsoftc_t *, XS_T *, ispreq_t *, uint32_t *, uint32_t);
void isp_pci_reset0(ispsoftc_t *);
void isp_pci_reset1(ispsoftc_t *);
void isp_pci_dumpregs(ispsoftc_t *, const char *);
 

int isp_pci_rd_debounced(struct ispsoftc *, int, u_int16_t *);
int isp_pci_intr (void *);
void isp_pci_dmateardown(struct ispsoftc *, XS_T *, u_int32_t);

static struct ispmdvec mdvec = {
	isp_pci_rd_isr,
	isp_pci_rd_reg,
	isp_pci_wr_reg,
	isp_pci_mbxdma,
	isp_pci_dmasetup,
	isp_pci_dmateardown,
	isp_pci_reset0,
	isp_pci_reset1,
	isp_pci_dumpregs,
	ISP_1040_RISC_CODE,
	BIU_BURST_ENABLE|BIU_PCI_CONF1_FIFO_64
};

static struct ispmdvec mdvec_1080 = {
	isp_pci_rd_isr,
	isp_pci_rd_reg_1080,
	isp_pci_wr_reg_1080,
	isp_pci_mbxdma,
	isp_pci_dmasetup,
	isp_pci_dmateardown,
	isp_pci_reset0,
	isp_pci_reset1,
	isp_pci_dumpregs,
	ISP_1080_RISC_CODE,
	BIU_BURST_ENABLE|BIU_PCI_CONF1_FIFO_64
};

static struct ispmdvec mdvec_12160 = {
	isp_pci_rd_isr,
	isp_pci_rd_reg_1080,
	isp_pci_wr_reg_1080,
	isp_pci_mbxdma,
	isp_pci_dmasetup,
	isp_pci_dmateardown,
	isp_pci_reset0,
	isp_pci_reset1,
	isp_pci_dumpregs,
	ISP_12160_RISC_CODE,
	BIU_BURST_ENABLE|BIU_PCI_CONF1_FIFO_64
};

static struct ispmdvec mdvec_2100 = {
	isp_pci_rd_isr,
	isp_pci_rd_reg,
	isp_pci_wr_reg,
	isp_pci_mbxdma,
	isp_pci_dmasetup,
	isp_pci_dmateardown,
	isp_pci_reset0,
	isp_pci_reset1,
	isp_pci_dumpregs,
	ISP_2100_RISC_CODE
};

static struct ispmdvec mdvec_2200 = {
	isp_pci_rd_isr,
	isp_pci_rd_reg,
	isp_pci_wr_reg,
	isp_pci_mbxdma,
	isp_pci_dmasetup,
	isp_pci_dmateardown,
	isp_pci_reset0,
	isp_pci_reset1,
	isp_pci_dumpregs,
	ISP_2200_RISC_CODE
};

static struct ispmdvec mdvec_2300 = {
	isp_pci_rd_isr_2300,
	isp_pci_rd_reg,
	isp_pci_wr_reg,
	isp_pci_mbxdma,
	isp_pci_dmasetup,
	isp_pci_dmateardown,
	isp_pci_reset0,
	isp_pci_reset1,
	isp_pci_dumpregs,
	ISP_2300_RISC_CODE
};

#ifndef	PCIM_CMD_INVEN
#define	PCIM_CMD_INVEN			0x10
#endif
#ifndef	PCIM_CMD_BUSMASTEREN
#define	PCIM_CMD_BUSMASTEREN		0x0004
#endif
#ifndef	PCIM_CMD_PERRESPEN
#define	PCIM_CMD_PERRESPEN		0x0040
#endif
#ifndef	PCIM_CMD_SEREN
#define	PCIM_CMD_SEREN			0x0100
#endif
#ifndef	PCIM_CMD_INTX_DISABLE
#define	PCIM_CMD_INTX_DISABLE		0x0400
#endif

#ifndef	PCIR_COMMAND
#define	PCIR_COMMAND			0x04
#endif

#ifndef	PCIR_CACHELNSZ
#define	PCIR_CACHELNSZ			0x0c
#endif

#ifndef	PCIR_LATTIMER
#define	PCIR_LATTIMER			0x0d
#endif

#ifndef	PCIR_ROMADDR
#define	PCIR_ROMADDR			0x30
#endif

#ifndef	PCI_VENDOR_QLOGIC
#define	PCI_VENDOR_QLOGIC		0x1077
#endif

#ifndef	PCI_PRODUCT_QLOGIC_ISP1020
#define	PCI_PRODUCT_QLOGIC_ISP1020	0x1020
#endif

#ifndef	PCI_PRODUCT_QLOGIC_ISP1080
#define	PCI_PRODUCT_QLOGIC_ISP1080	0x1080
#endif

#ifndef	PCI_PRODUCT_QLOGIC_ISP10160
#define	PCI_PRODUCT_QLOGIC_ISP10160	0x1016
#endif

#ifndef	PCI_PRODUCT_QLOGIC_ISP12160
#define	PCI_PRODUCT_QLOGIC_ISP12160	0x1216
#endif

#ifndef	PCI_PRODUCT_QLOGIC_ISP1240
#define	PCI_PRODUCT_QLOGIC_ISP1240	0x1240
#endif

#ifndef	PCI_PRODUCT_QLOGIC_ISP1280
#define	PCI_PRODUCT_QLOGIC_ISP1280	0x1280
#endif

#ifndef	PCI_PRODUCT_QLOGIC_ISP2100
#define	PCI_PRODUCT_QLOGIC_ISP2100	0x2100
#endif

#ifndef	PCI_PRODUCT_QLOGIC_ISP2200
#define	PCI_PRODUCT_QLOGIC_ISP2200	0x2200
#endif

#ifndef	PCI_PRODUCT_QLOGIC_ISP2300
#define	PCI_PRODUCT_QLOGIC_ISP2300	0x2300
#endif

#ifndef	PCI_PRODUCT_QLOGIC_ISP2312
#define	PCI_PRODUCT_QLOGIC_ISP2312	0x2312
#endif

#ifndef	PCI_PRODUCT_QLOGIC_ISP2322
#define	PCI_PRODUCT_QLOGIC_ISP2322	0x2322
#endif

#ifndef	PCI_PRODUCT_QLOGIC_ISP6312
#define	PCI_PRODUCT_QLOGIC_ISP6312	0x6312
#endif

#ifndef	PCI_PRODUCT_QLOGIC_ISP6322
#define	PCI_PRODUCT_QLOGIC_ISP6322	0x6322
#endif


#define	PCI_QLOGIC_ISP1020	\
	((PCI_PRODUCT_QLOGIC_ISP1020 << 16) | PCI_VENDOR_QLOGIC)

#define	PCI_QLOGIC_ISP1080	\
	((PCI_PRODUCT_QLOGIC_ISP1080 << 16) | PCI_VENDOR_QLOGIC)

#define	PCI_QLOGIC_ISP10160	\
	((PCI_PRODUCT_QLOGIC_ISP10160 << 16) | PCI_VENDOR_QLOGIC)

#define	PCI_QLOGIC_ISP12160	\
	((PCI_PRODUCT_QLOGIC_ISP12160 << 16) | PCI_VENDOR_QLOGIC)

#define	PCI_QLOGIC_ISP1240	\
	((PCI_PRODUCT_QLOGIC_ISP1240 << 16) | PCI_VENDOR_QLOGIC)

#define	PCI_QLOGIC_ISP1280	\
	((PCI_PRODUCT_QLOGIC_ISP1280 << 16) | PCI_VENDOR_QLOGIC)

#define	PCI_QLOGIC_ISP2100	\
	((PCI_PRODUCT_QLOGIC_ISP2100 << 16) | PCI_VENDOR_QLOGIC)

#define	PCI_QLOGIC_ISP2200	\
	((PCI_PRODUCT_QLOGIC_ISP2200 << 16) | PCI_VENDOR_QLOGIC)

#define	PCI_QLOGIC_ISP2300	\
	((PCI_PRODUCT_QLOGIC_ISP2300 << 16) | PCI_VENDOR_QLOGIC)

#define	PCI_QLOGIC_ISP2312	\
	((PCI_PRODUCT_QLOGIC_ISP2312 << 16) | PCI_VENDOR_QLOGIC)

#define	PCI_QLOGIC_ISP2322	\
	((PCI_PRODUCT_QLOGIC_ISP2322 << 16) | PCI_VENDOR_QLOGIC)

#define	PCI_QLOGIC_ISP6312	\
	((PCI_PRODUCT_QLOGIC_ISP6312 << 16) | PCI_VENDOR_QLOGIC)

#define	PCI_QLOGIC_ISP6322	\
	((PCI_PRODUCT_QLOGIC_ISP6322 << 16) | PCI_VENDOR_QLOGIC)

/*
 * Odd case for some AMI raid cards... We need to *not* attach to this.
 */
#define	AMI_RAID_SUBVENDOR_ID	0x101e

#define	IO_MAP_REG	0x10
#define	MEM_MAP_REG	0x14

#define	PCI_DFLT_LTNCY	0x40
#define	PCI_DFLT_LNSZ	0x10

#ifndef SCSI_ISP_PREFER_MEM_MAP
#ifdef __alpha__
#define SCSI_ISP_PREFER_MEM_MAP 1
#else
#define SCSI_ISP_PREFER_MEM_MAP 0
#endif
#endif

#ifdef  DEBUG
const char vstring[] =
    "QLogic ISP Driver, OpenBSD (pci) Platform Version %d.%d Core Version %d.%d";
#endif

const struct pci_matchid ispdev[] = {
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP1020 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP1080 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP1240 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP1280 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP10160 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP12160 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2100 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2200 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2300 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2312 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2322 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP6312 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP6322 },
	{ 0, 0 }
};
 
int isp_pci_probe (struct device *, void *, void *);
void isp_pci_attach (struct device *, struct device *, void *);

#define	ISP_PCD(isp)	((struct isp_pcisoftc *)isp)->pci_dev
struct isp_pcisoftc {
	struct ispsoftc		pci_isp;
	pci_chipset_tag_t	pci_pc;
	pcitag_t		pci_tag;
	bus_space_tag_t		pci_st;
	bus_space_handle_t	pci_sh;
	bus_dmamap_t		*pci_xfer_dmap;
	void *			pci_ih;
	int16_t			pci_poff[_NREG_BLKS];
};

struct cfattach isp_pci_ca = {
	sizeof (struct isp_pcisoftc), isp_pci_probe, isp_pci_attach
};

int
isp_pci_probe(struct device *parent, void *match, void *aux)
{
        struct pci_attach_args *pa = aux;

#ifndef	ISP_DISABLE_12160_SUPPORT
	/*
	 * Sigh. Check for subvendor id match here. Too bad we
	 * can't give an exclude mask in matchbyid.
	 */
        if (pa->pa_id == PCI_QLOGIC_ISP12160) {
		pcireg_t subvid =
		    pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBVEND_0);
		if (PCI_VENDOR(subvid) == AMI_RAID_SUBVENDOR_ID) {
			return (0);
                }
	}
#endif
	return (pci_matchbyid(pa, ispdev, nitems(ispdev)));
}


void    
isp_pci_attach(struct device *parent, struct device *self, void *aux)
{
#ifdef	DEBUG
	static char oneshot = 1;
#endif
	static const char nomem[] = ": no mem for sdparam table\n";
	u_int32_t data, rev, linesz = PCI_DFLT_LNSZ;
	struct pci_attach_args *pa = aux;
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)self;
	struct ispsoftc *isp = &pcs->pci_isp;
	bus_space_tag_t st, iot, memt;
	bus_space_handle_t sh, ioh, memh;
	pci_intr_handle_t ih;
	const char *intrstr;
	int ioh_valid, memh_valid;
	bus_size_t iosize, msize;
	u_int32_t confopts = 0;
#ifdef __sparc64__
	int node, iid;
	u_int64_t wwn;
#endif

	DEFAULT_IID(isp) = 7;
#ifdef __sparc64__
	/*
	 * Walk up the Open Firmware device tree until we find a
	 * "scsi-initiator-id" property.
	 */
	node = PCITAG_NODE(pa->pa_tag);
	while (node) {
		if (OF_getprop(node, "scsi-initiator-id",
		    &iid, sizeof(iid)) == sizeof(iid)) {
			DEFAULT_IID(isp) = iid;
			confopts |= ISP_CFG_OWNLOOPID;
			break;
		}

		node = OF_parent(node);
	}

	node = PCITAG_NODE(pa->pa_tag);
	if (OF_getprop(node, "node-wwn", &wwn, sizeof(wwn)) == sizeof(wwn)) {
		DEFAULT_NODEWWN(isp) = wwn;
		confopts |= ISP_CFG_OWNWWNN;
	}
	if (OF_getprop(node, "port-wwn", &wwn, sizeof(wwn)) == sizeof(wwn)) {
		DEFAULT_PORTWWN(isp) = wwn;
		confopts |= ISP_CFG_OWNWWPN;
	}
#endif
#ifdef __sgi__
	/*
	 * The on-board isp controllers found on Octane, Origin 200 and
	 * Origin 300 families use id #0.
	 * XXX We'll need to be able to tell apart onboard isp from
	 * XXX other isp...
	 */
	if (sys_config.system_type == SGI_OCTANE ||
	    sys_config.system_type == SGI_IP27 ||
	    sys_config.system_type == SGI_IP35)
		DEFAULT_IID(isp) = 0;
#endif

	ioh_valid = memh_valid = 0;

#if	SCSI_ISP_PREFER_MEM_MAP == 1
	if (pci_mapreg_map(pa, MEM_MAP_REG, PCI_MAPREG_TYPE_MEM, 0,
	    &memt, &memh, NULL, &msize, 0)) {
		printf(": can't map mem space\n");
	} else  {
		st = memt;
		sh = memh;
		memh_valid = 1;
	}
	if (memh_valid == 0) {
		if (pci_mapreg_map(pa, IO_MAP_REG, PCI_MAPREG_TYPE_IO, 0,
		    &iot, &ioh, NULL, &iosize, 0)) {
		} else {
			st = iot;
			sh = ioh;
			ioh_valid = 1;
		}
	}
#else
	if (pci_mapreg_map(pa, IO_MAP_REG, PCI_MAPREG_TYPE_IO, 0,
	    &iot, &ioh, NULL, &iosize, 0)) {
		printf(": can't map i/o space\n");
	} else {
		st = iot;
		sh = ioh;
		ioh_valid = 1;
	}
	if (ioh_valid == 0) {
		if (pci_mapreg_map(pa, MEM_MAP_REG, PCI_MAPREG_TYPE_MEM, 0,
		    &memt, &memh, NULL, &msize, 0)) {
			printf(": can't map mem space\n");
		} else  {
			st = memt;
			sh = memh;
			memh_valid = 1;
		}
	}
#endif
	if (ioh_valid == 0 && memh_valid == 0) {
		printf(": unable to map device registers\n");
		return;
	}
#if 0
	printf("\n");
#endif

	pcs->pci_st = isp->isp_bus_tag = st;
	pcs->pci_sh = isp->isp_bus_handle = sh;
	pcs->pci_pc = pa->pa_pc;
	pcs->pci_tag = pa->pa_tag;
	pcs->pci_poff[BIU_BLOCK >> _BLK_REG_SHFT] = BIU_REGS_OFF;
	pcs->pci_poff[MBOX_BLOCK >> _BLK_REG_SHFT] = PCI_MBOX_REGS_OFF;
	pcs->pci_poff[SXP_BLOCK >> _BLK_REG_SHFT] = PCI_SXP_REGS_OFF;
	pcs->pci_poff[RISC_BLOCK >> _BLK_REG_SHFT] = PCI_RISC_REGS_OFF;
	pcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] = DMA_REGS_OFF;
	rev = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG) & 0xff;
	if (pa->pa_id == PCI_QLOGIC_ISP1020) {
		isp->isp_mdvec = &mdvec;
		isp->isp_type = ISP_HA_SCSI_UNKNOWN;
		isp->isp_param = malloc(sizeof(sdparam), M_DEVBUF,
		    M_NOWAIT | M_ZERO);
		if (isp->isp_param == NULL) {
			printf(nomem);
			return;
		}
	}
	if (pa->pa_id == PCI_QLOGIC_ISP1080) {
		isp->isp_mdvec = &mdvec_1080;
		isp->isp_type = ISP_HA_SCSI_1080;
		isp->isp_param = malloc(sizeof(sdparam), M_DEVBUF,
		    M_NOWAIT | M_ZERO);
		if (isp->isp_param == NULL) {
			printf(nomem);
			return;
		}
		pcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] =
		    ISP1080_DMA_REGS_OFF;
	}
	if (pa->pa_id == PCI_QLOGIC_ISP1240) {
		isp->isp_mdvec = &mdvec_1080;
		isp->isp_type = ISP_HA_SCSI_1240;
		isp->isp_param = mallocarray(2, sizeof(sdparam), M_DEVBUF,
		    M_NOWAIT | M_ZERO);
		if (isp->isp_param == NULL) {
			printf(nomem);
			return;
		}
		pcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] =
		    ISP1080_DMA_REGS_OFF;
	}
	if (pa->pa_id == PCI_QLOGIC_ISP1280) {
		isp->isp_mdvec = &mdvec_1080;
		isp->isp_type = ISP_HA_SCSI_1280;
		isp->isp_param = mallocarray(2, sizeof(sdparam),
		    M_DEVBUF, M_NOWAIT | M_ZERO);
		if (isp->isp_param == NULL) {
			printf(nomem);
			return;
		}
		pcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] =
		    ISP1080_DMA_REGS_OFF;
	}
	if (pa->pa_id == PCI_QLOGIC_ISP10160) {
		isp->isp_mdvec = &mdvec_12160;
		isp->isp_type = ISP_HA_SCSI_10160;
		isp->isp_param = malloc(sizeof(sdparam), M_DEVBUF,
		    M_NOWAIT | M_ZERO);
		if (isp->isp_param == NULL) {
			printf(nomem);
			return;
		}
		pcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] =
		    ISP1080_DMA_REGS_OFF;
	}
	if (pa->pa_id == PCI_QLOGIC_ISP12160) {
		isp->isp_mdvec = &mdvec_12160;
		isp->isp_type = ISP_HA_SCSI_12160;
		isp->isp_param = mallocarray(2, sizeof(sdparam),
		    M_DEVBUF, M_NOWAIT | M_ZERO);
		if (isp->isp_param == NULL) {
			printf(nomem);
			return;
		}
		pcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] =
		    ISP1080_DMA_REGS_OFF;
	}
	if (pa->pa_id == PCI_QLOGIC_ISP2100) {
		isp->isp_mdvec = &mdvec_2100;
		isp->isp_type = ISP_HA_FC_2100;
		isp->isp_param = malloc(sizeof(fcparam), M_DEVBUF,
		    M_NOWAIT | M_ZERO);
		if (isp->isp_param == NULL) {
			printf(nomem);
			return;
		}
		pcs->pci_poff[MBOX_BLOCK >> _BLK_REG_SHFT] =
		    PCI_MBOX_REGS2100_OFF;
		if (rev < 3) {
			/*
			 * XXX: Need to get the actual revision
			 * XXX: number of the 2100 FB. At any rate,
			 * XXX: lower cache line size for early revision
			 * XXX; boards.
			 */
			linesz = 1;
		}
	}
	if (pa->pa_id == PCI_QLOGIC_ISP2200) {
		isp->isp_mdvec = &mdvec_2200;
		isp->isp_type = ISP_HA_FC_2200;
		isp->isp_param = malloc(sizeof(fcparam), M_DEVBUF,
		    M_NOWAIT | M_ZERO);
		if (isp->isp_param == NULL) {
			printf(nomem);
			return;
		}
		pcs->pci_poff[MBOX_BLOCK >> _BLK_REG_SHFT] =
		    PCI_MBOX_REGS2100_OFF;
#ifdef __sparc64__
		{
			char name[32];

			bzero(name, sizeof(name));
			OF_getprop(PCITAG_NODE(pa->pa_tag),
			    "name", name, sizeof(name));
			if (strcmp(name, "SUNW,qlc") == 0)
				confopts |= ISP_CFG_NONVRAM;
		}
#endif
	}
	if (pa->pa_id == PCI_QLOGIC_ISP2300) {
		isp->isp_mdvec = &mdvec_2300;
		isp->isp_type = ISP_HA_FC_2300;
		isp->isp_param = malloc(sizeof(fcparam), M_DEVBUF,
		    M_NOWAIT | M_ZERO);
		if (isp->isp_param == NULL) {
			printf(nomem);
			return;
		}
		pcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] =
		    PCI_MBOX_REGS2300_OFF;
	}
	if (pa->pa_id == PCI_QLOGIC_ISP2312 ||
	    pa->pa_id == PCI_QLOGIC_ISP6312) {
		isp->isp_mdvec = &mdvec_2300;
		isp->isp_type = ISP_HA_FC_2312;
		isp->isp_port = pa->pa_function;
		isp->isp_param = malloc(sizeof(fcparam), M_DEVBUF,
		    M_NOWAIT | M_ZERO);
		if (isp->isp_param == NULL) {
			printf(nomem);
			return;
		}
		pcs->pci_poff[MBOX_BLOCK >> _BLK_REG_SHFT] =
		    PCI_MBOX_REGS2300_OFF;
	}
	if (pa->pa_id == PCI_QLOGIC_ISP2322 ||
	    pa->pa_id == PCI_QLOGIC_ISP6322) {
		isp->isp_mdvec = &mdvec_2300;
		isp->isp_type = ISP_HA_FC_2322;
		isp->isp_port = pa->pa_function;
		isp->isp_param = malloc(sizeof(fcparam), M_DEVBUF,
		    M_NOWAIT | M_ZERO);
		if (isp->isp_param == NULL) {
			printf(nomem);
			return;
		}
		pcs->pci_poff[MBOX_BLOCK >> _BLK_REG_SHFT] =
		    PCI_MBOX_REGS2300_OFF;
	}
	/*
	 * Set up logging levels.
	 */
#ifdef	ISP_LOGDEFAULT
	isp->isp_dblev = ISP_LOGDEFAULT;
#else
	isp->isp_dblev = ISP_LOGWARN|ISP_LOGERR;
#if 0
	isp->isp_dblev |= ISP_LOGDEBUG1|ISP_LOGDEBUG2;
#endif
#ifdef	DEBUG
	isp->isp_dblev |= ISP_LOGDEBUG0|ISP_LOGCONFIG|ISP_LOGINFO;
#endif
#endif

#ifdef	DEBUG
	if (oneshot) {
		oneshot = 0;
		isp_prt(isp, ISP_LOGCONFIG, vstring,
		    ISP_PLATFORM_VERSION_MAJOR, ISP_PLATFORM_VERSION_MINOR,
		    ISP_CORE_VERSION_MAJOR, ISP_CORE_VERSION_MINOR);
	}
#endif

	isp->isp_dmatag = pa->pa_dmat;
	isp->isp_revision = rev;

	/*
	 * Make sure that command register set sanely.
	 */
	data = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	if (IS_2300(isp)) {	/* per QLogic errata */
		data &= ~PCI_COMMAND_PARITY_ENABLE;
	}
	if (IS_23XX(isp)) {
		isp->isp_touched = 1;
	}
	data |= PCI_COMMAND_INVALIDATE_ENABLE;

	/*
	 * Not so sure about these- but I think it's important that they get
	 * enabled......
	 */
	data |= PCI_COMMAND_PARITY_ENABLE | PCI_COMMAND_SERR_ENABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, data);

	/*
	 * Make sure that the latency timer, cache line size,
	 * and ROM is disabled.
	 */
	data = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);
	data &= ~(PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT);
	data &= ~(PCI_CACHELINE_MASK << PCI_CACHELINE_SHIFT);
	data |= (0x40 << PCI_LATTIMER_SHIFT);
	data |= (0x10 << PCI_CACHELINE_SHIFT);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG, data);

	data = pci_conf_read(pa->pa_pc, pa->pa_tag, PCIR_ROMADDR);
	data &= ~1;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCIR_ROMADDR, data);

	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		free(isp->isp_param, M_DEVBUF, 0);
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	if (intrstr == NULL)
		intrstr = "<I dunno>";
	pcs->pci_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, isp_pci_intr,
	    isp, isp->isp_name);
	if (pcs->pci_ih == NULL) {
		printf(": couldn't establish interrupt at %s\n",
			intrstr);
		free(isp->isp_param, M_DEVBUF, 0);
		return;
	}

	printf(": %s\n", intrstr);

	if (IS_FC(isp)) {
		if (DEFAULT_NODEWWN(isp) == 0)
			DEFAULT_NODEWWN(isp) = 0x400000007F000003ULL;
		if (DEFAULT_PORTWWN(isp) == 0)
			DEFAULT_PORTWWN(isp) = 0x400000007F000003ULL;
	}

	isp->isp_confopts = confopts | self->dv_cfdata->cf_flags;
	isp->isp_role = ISP_DEFAULT_ROLES;
	ISP_LOCK(isp);
	isp->isp_osinfo.no_mbox_ints = 1;
	isp_reset(isp);
	if (isp->isp_state != ISP_RESETSTATE) {
		ISP_UNLOCK(isp);
		free(isp->isp_param, M_DEVBUF, 0);
		return;
	}
	ISP_ENABLE_INTS(isp);
	isp_init(isp);
	if (isp->isp_state != ISP_INITSTATE) {
		isp_uninit(isp);
		ISP_UNLOCK(isp);
		free(isp->isp_param, M_DEVBUF, 0);
		return;
	}
	/*
	 * Do Generic attach now.
	 */
	isp_attach(isp);
	if (isp->isp_state != ISP_RUNSTATE) {
		isp_uninit(isp);
		ISP_UNLOCK(isp);
		free(isp->isp_param, M_DEVBUF, 0);
	} else {
		ISP_UNLOCK(isp);
	}
}

#define	IspVirt2Off(a, x)	\
	(((struct isp_pcisoftc *)a)->pci_poff[((x) & _BLK_REG_MASK) >> \
	_BLK_REG_SHFT] + ((x) & 0xfff))

#define	BXR2(pcs, off)		\
	bus_space_read_2(pcs->pci_st, pcs->pci_sh, off)
#define	BXW2(pcs, off, v)	\
	bus_space_write_2(pcs->pci_st, pcs->pci_sh, off, v)
#define	BXR4(pcs, off)		\
	bus_space_read_4(pcs->pci_st, pcs->pci_sh, off)
#define	BXW4(pcs, off, v)	\
	bus_space_write_4(pcs->pci_st, pcs->pci_sh, off, v)

int
isp_pci_rd_debounced(struct ispsoftc *isp, int off, u_int16_t *rp)
{
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)isp;
	u_int32_t val0, val1;
	int i = 0;

	do {
		val0 = BXR2(pcs, IspVirt2Off(isp, off));
		val1 = BXR2(pcs, IspVirt2Off(isp, off));
	} while (val0 != val1 && ++i < 1000);
	if (val0 != val1) {
		return (1);
	}
	*rp = val0;
	return (0);
}

int
isp_pci_rd_isr(struct ispsoftc *isp, u_int32_t *isrp,
    u_int16_t *semap, u_int16_t *mbp)
{
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)isp;
	u_int16_t isr, sema;

	if (IS_2100(isp)) {
		if (isp_pci_rd_debounced(isp, BIU_ISR, &isr)) {
		    return (0);
		}
		if (isp_pci_rd_debounced(isp, BIU_SEMA, &sema)) {
		    return (0);
		}
	} else {
		isr = BXR2(pcs, IspVirt2Off(isp, BIU_ISR));
		sema = BXR2(pcs, IspVirt2Off(isp, BIU_SEMA));
	}
	isp_prt(isp, ISP_LOGDEBUG3, "ISR 0x%x SEMA 0x%x", isr, sema);
	isr &= INT_PENDING_MASK(isp);
	sema &= BIU_SEMA_LOCK;
	if (isr == 0 && sema == 0) {
		return (0);
	}
	*isrp = isr;
	if ((*semap = sema) != 0) {
		if (IS_2100(isp)) {
			if (isp_pci_rd_debounced(isp, OUTMAILBOX0, mbp)) {
				return (0);
			}
		} else {
			*mbp = BXR2(pcs, IspVirt2Off(isp, OUTMAILBOX0));
		}
	}
	return (1);
}

int
isp_pci_rd_isr_2300(struct ispsoftc *isp, u_int32_t *isrp,
    u_int16_t *semap, u_int16_t *mbox0p)
{
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)isp;
	u_int32_t hccr;
	u_int32_t r2hisr;

	if (!(BXR2(pcs, IspVirt2Off(isp, BIU_ISR)) & BIU2100_ISR_RISC_INT)) {
		*isrp = 0;
		return (0);
	}
	r2hisr = BXR4(pcs, IspVirt2Off(isp, BIU_R2HSTSLO));
	isp_prt(isp, ISP_LOGDEBUG3, "RISC2HOST ISR 0x%x", r2hisr);
	if ((r2hisr & BIU_R2HST_INTR) == 0) {
		*isrp = 0;
		return (0);
	}
	switch (r2hisr & BIU_R2HST_ISTAT_MASK) {
	case ISPR2HST_ROM_MBX_OK:
	case ISPR2HST_ROM_MBX_FAIL:
	case ISPR2HST_MBX_OK:
	case ISPR2HST_MBX_FAIL:
	case ISPR2HST_ASYNC_EVENT:
		*isrp = r2hisr & 0xffff;
		*mbox0p = (r2hisr >> 16);
		*semap = 1;
		return (1);
	case ISPR2HST_RIO_16:
		*isrp = r2hisr & 0xffff;
		*mbox0p = ASYNC_RIO1;
		*semap = 1;
		return (1);
	case ISPR2HST_FPOST:
		*isrp = r2hisr & 0xffff;
		*mbox0p = ASYNC_CMD_CMPLT;
		*semap = 1;
		return (1);
	case ISPR2HST_FPOST_CTIO:
		*isrp = r2hisr & 0xffff;
		*mbox0p = ASYNC_CTIO_DONE;
		*semap = 1;
		return (1);
	case ISPR2HST_RSPQ_UPDATE:
		*isrp = r2hisr & 0xffff;
		*mbox0p = 0;
		*semap = 0;
		return (1);
	default:
		hccr = ISP_READ(isp, HCCR);
		if (hccr & HCCR_PAUSE) {
			ISP_WRITE(isp, HCCR, HCCR_RESET);
			isp_prt(isp, ISP_LOGERR,
			    "RISC paused at interrupt (%x->%x)", hccr,
			    ISP_READ(isp, HCCR));
			ISP_WRITE(isp, BIU_ICR, 0);
		} else {
			isp_prt(isp, ISP_LOGERR, "unknown interrupt 0x%x\n",
			    r2hisr);
		}
		return (0);
	}
}

u_int32_t
isp_pci_rd_reg(struct ispsoftc *isp, int regoff)
{
	u_int16_t rv;
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)isp;
	int oldconf = 0;

	if ((regoff & _BLK_REG_MASK) == SXP_BLOCK) {
		/*
		 * We will assume that someone has paused the RISC processor.
		 */
		oldconf = BXR2(pcs, IspVirt2Off(isp, BIU_CONF1));
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1),
		    oldconf | BIU_PCI_CONF1_SXP);
		MEMORYBARRIER(isp, SYNC_REG, IspVirt2Off(isp, BIU_CONF1), 2);
	}
	rv = BXR2(pcs, IspVirt2Off(isp, regoff));
	if ((regoff & _BLK_REG_MASK) == SXP_BLOCK) {
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1), oldconf);
	}
	MEMORYBARRIER(isp, SYNC_REG, IspVirt2Off(isp, BIU_CONF1), 2);
	return (rv);
}

void
isp_pci_wr_reg(struct ispsoftc *isp, int regoff, u_int32_t val)
{
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)isp;
	int oldconf = 0;

	if ((regoff & _BLK_REG_MASK) == SXP_BLOCK) {
		/*
		 * We will assume that someone has paused the RISC processor.
		 */
		oldconf = BXR2(pcs, IspVirt2Off(isp, BIU_CONF1));
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1),
		    oldconf | BIU_PCI_CONF1_SXP);
		MEMORYBARRIER(isp, SYNC_REG, IspVirt2Off(isp, BIU_CONF1), 2);
	}
	BXW2(pcs, IspVirt2Off(isp, regoff), val);
	MEMORYBARRIER(isp, SYNC_REG, IspVirt2Off(isp, regoff), 2);
	if ((regoff & _BLK_REG_MASK) == SXP_BLOCK) {
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1), oldconf);
		MEMORYBARRIER(isp, SYNC_REG, IspVirt2Off(isp, BIU_CONF1), 2);
	}

}

u_int32_t
isp_pci_rd_reg_1080(struct ispsoftc *isp, int regoff)
{
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)isp;
	u_int32_t rv, oc = 0;

	if ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||
	    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {
		u_int32_t tc;
		/*
		 * We will assume that someone has paused the RISC processor.
		 */
		oc = BXR2(pcs, IspVirt2Off(isp, BIU_CONF1));
		tc = oc & ~BIU_PCI1080_CONF1_DMA;
		if (regoff & SXP_BANK1_SELECT)
			tc |= BIU_PCI1080_CONF1_SXP1;
		else
			tc |= BIU_PCI1080_CONF1_SXP0;
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1), tc);
		MEMORYBARRIER(isp, SYNC_REG, IspVirt2Off(isp, BIU_CONF1), 2);
	} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {
		oc = BXR2(pcs, IspVirt2Off(isp, BIU_CONF1));
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1), 
		    oc | BIU_PCI1080_CONF1_DMA);
		MEMORYBARRIER(isp, SYNC_REG, IspVirt2Off(isp, BIU_CONF1), 2);
	}
	rv = BXR2(pcs, IspVirt2Off(isp, regoff));
	if (oc) {
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1), oc);
		MEMORYBARRIER(isp, SYNC_REG, IspVirt2Off(isp, BIU_CONF1), 2);
	}
	return (rv);
}

void
isp_pci_wr_reg_1080(struct ispsoftc *isp, int regoff, u_int32_t val)
{
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)isp;
	int oc = 0;

	if ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||
	    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {
		u_int32_t tc;
		/*
		 * We will assume that someone has paused the RISC processor.
		 */
		oc = BXR2(pcs, IspVirt2Off(isp, BIU_CONF1));
		tc = oc & ~BIU_PCI1080_CONF1_DMA;
		if (regoff & SXP_BANK1_SELECT)
			tc |= BIU_PCI1080_CONF1_SXP1;
		else
			tc |= BIU_PCI1080_CONF1_SXP0;
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1), tc);
		MEMORYBARRIER(isp, SYNC_REG, IspVirt2Off(isp, BIU_CONF1), 2);
	} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {
		oc = BXR2(pcs, IspVirt2Off(isp, BIU_CONF1));
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1), 
		    oc | BIU_PCI1080_CONF1_DMA);
		MEMORYBARRIER(isp, SYNC_REG, IspVirt2Off(isp, BIU_CONF1), 2);
	}
	BXW2(pcs, IspVirt2Off(isp, regoff), val);
	MEMORYBARRIER(isp, SYNC_REG, IspVirt2Off(isp, regoff), 2);
	if (oc) {
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1), oc);
		MEMORYBARRIER(isp, SYNC_REG, IspVirt2Off(isp, BIU_CONF1), 2);
	}
}

struct imush {
	ispsoftc_t *isp;
	int error;
};


int
isp_pci_mbxdma(struct ispsoftc *isp)
{
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)isp;
	bus_dma_tag_t dmat = isp->isp_dmatag;
	bus_dma_segment_t sg;
	bus_addr_t addr;
	bus_size_t len;
	caddr_t base;
	int rs, i;

	if (isp->isp_rquest_dma)	/* been here before? */
		return (0);

	isp->isp_xflist = mallocarray(isp->isp_maxcmds, sizeof(XS_T *),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (isp->isp_xflist == NULL) {
		isp_prt(isp, ISP_LOGERR, "cannot malloc xflist array");
		return (1);
	}
	len = isp->isp_maxcmds * sizeof(XS_T *);

	pcs->pci_xfer_dmap = mallocarray(isp->isp_maxcmds, sizeof(bus_dmamap_t),
	    M_DEVBUF, M_NOWAIT);
	if (pcs->pci_xfer_dmap == NULL) {
		free(isp->isp_xflist, M_DEVBUF, 0);
		isp->isp_xflist = NULL;
		isp_prt(isp, ISP_LOGERR, "cannot malloc dma map array");
		return (1);
	}
	len = isp->isp_maxcmds * sizeof(bus_dmamap_t);

	for (i = 0; i < isp->isp_maxcmds; i++) {
		if (bus_dmamap_create(dmat, MAXPHYS, (MAXPHYS / NBPG) + 1,
		    MAXPHYS, 0, BUS_DMA_NOWAIT, &pcs->pci_xfer_dmap[i])) {
			isp_prt(isp, ISP_LOGERR, "cannot create dma maps");
			break;
		}
	}

	if (i < isp->isp_maxcmds) {
		while (--i >= 0) {
			bus_dmamap_destroy(dmat, pcs->pci_xfer_dmap[i]);
		}
		free(isp->isp_xflist, M_DEVBUF, 0);
		free(pcs->pci_xfer_dmap, M_DEVBUF, 0);
		isp->isp_xflist = NULL;
		pcs->pci_xfer_dmap = NULL;
		return (1);
	}

	/*
	 * Allocate and map the request, result queues, plus FC scratch area.
	 */
	len = ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp));
	len += ISP_QUEUE_SIZE(RESULT_QUEUE_LEN(isp));
	if (IS_FC(isp)) {
		len += ISP2100_SCRLEN;
	}

	if (bus_dmamem_alloc(dmat, len, PAGE_SIZE, 0, &sg, 1, &rs,
	    BUS_DMA_NOWAIT))
		goto dmafail;

	if (bus_dmamem_map(isp->isp_dmatag, &sg, rs, len, &base,
	    BUS_DMA_NOWAIT | BUS_DMA_COHERENT))
		goto dmafree;

	if (bus_dmamap_create(dmat, len, 1, len, 0, BUS_DMA_NOWAIT,
	    &isp->isp_cdmap))
		goto dmaunmap;

	if (bus_dmamap_load(dmat, isp->isp_cdmap, base, len, NULL,
	    BUS_DMA_NOWAIT))
		goto dmadestroy;

	addr = isp->isp_cdmap->dm_segs[0].ds_addr;
	isp->isp_rquest_dma = addr;
	addr += ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp));
	isp->isp_result_dma = addr;

	if (IS_FC(isp)) {
		addr += ISP_QUEUE_SIZE(RESULT_QUEUE_LEN(isp));
		FCPARAM(isp)->isp_scdma = addr;

	}

	isp->isp_rquest = base;
	base += ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp));
	isp->isp_result = base;
	if (IS_FC(isp)) {
		base += ISP_QUEUE_SIZE(RESULT_QUEUE_LEN(isp));
		FCPARAM(isp)->isp_scratch = base;
	}
	return (0);

dmadestroy:
	bus_dmamap_destroy(dmat, isp->isp_cdmap);
dmaunmap:
	bus_dmamem_unmap(dmat, base, len);
dmafree:
	bus_dmamem_free(dmat, &sg, rs);
dmafail:
	isp_prt(isp, ISP_LOGERR, "mailbox dma setup failure");
	for (i = 0; i < isp->isp_maxcmds; i++) {
		bus_dmamap_destroy(dmat, pcs->pci_xfer_dmap[i]);
	}
	free(isp->isp_xflist, M_DEVBUF, 0);
	free(pcs->pci_xfer_dmap, M_DEVBUF, 0);
	isp->isp_xflist = NULL;
	pcs->pci_xfer_dmap = NULL;
	return (1);
}

int
isp_pci_dmasetup(struct ispsoftc *isp, XS_T *xs, ispreq_t *rq,
    u_int32_t *nxtip, u_int32_t optr)
{
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)isp;
	bus_dmamap_t dmap;
	u_int16_t nxti = *nxtip;
	ispreq_t *qep;
	int segcnt, seg, error, ovseg, seglim, drq;

	qep = (ispreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, isp->isp_reqidx);
	dmap = pcs->pci_xfer_dmap[isp_handle_index(rq->req_handle)];
	if (xs->datalen == 0) {
		rq->req_seg_count = 1;
		goto mbxsync;
	}

	if (xs->flags & SCSI_DATA_IN) {
		drq = REQFLAG_DATA_IN;
	} else {
		drq = REQFLAG_DATA_OUT;
	}

	if (IS_FC(isp)) {
		seglim = ISP_RQDSEG_T2;
		((ispreqt2_t *)rq)->req_totalcnt = xs->datalen;
		((ispreqt2_t *)rq)->req_flags |= drq;
	} else {
		rq->req_flags |= drq;
		if (XS_CDBLEN(xs) > 12)
			seglim = 0;
		else
			seglim = ISP_RQDSEG;
	}
	error = bus_dmamap_load(isp->isp_dmatag, dmap, xs->data, xs->datalen,
	    NULL, (xs->flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
	if (error) {
		XS_SETERR(xs, HBA_BOTCH);
		return (CMD_COMPLETE);
	}

	segcnt = dmap->dm_nsegs;

	isp_prt(isp, ISP_LOGDEBUG2, "%d byte %s %p in %d segs",
	    xs->datalen, (xs->flags & SCSI_DATA_IN)? "read to" :
	    "write from", xs->data, segcnt);

	for (seg = 0, rq->req_seg_count = 0;
	     seg < segcnt && rq->req_seg_count < seglim;
	     seg++, rq->req_seg_count++) {
		if (isp->isp_type & ISP_HA_FC) {
			ispreqt2_t *rq2 = (ispreqt2_t *)rq;
			rq2->req_dataseg[rq2->req_seg_count].ds_count =
			    dmap->dm_segs[seg].ds_len;
			rq2->req_dataseg[rq2->req_seg_count].ds_base =
			    dmap->dm_segs[seg].ds_addr;
		} else {
			rq->req_dataseg[rq->req_seg_count].ds_count =
			    dmap->dm_segs[seg].ds_len;
			rq->req_dataseg[rq->req_seg_count].ds_base =
			    dmap->dm_segs[seg].ds_addr;
		}
		isp_prt(isp, ISP_LOGDEBUG2, "seg0.[%d]={0x%lx,%lu}",
		    rq->req_seg_count, (long) dmap->dm_segs[seg].ds_addr,
		    (unsigned long) dmap->dm_segs[seg].ds_len);
	}

	if (seg == segcnt) {
		goto dmasync;
	}

	do {
		u_int16_t onxti;
		ispcontreq_t *crq, *cqe, local;

		crq = &local;

		cqe = (ispcontreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, nxti);
		onxti = nxti;
		nxti = ISP_NXT_QENTRY(onxti, RQUEST_QUEUE_LEN(isp));
		if (nxti == optr) {
			isp_prt(isp, ISP_LOGDEBUG0, "Request Queue Overflow++");
			bus_dmamap_unload(isp->isp_dmatag, dmap);
			XS_SETERR(xs, HBA_BOTCH);
			return (CMD_EAGAIN);
		}
		rq->req_header.rqs_entry_count++;
		bzero((void *)crq, sizeof (*crq));
		crq->req_header.rqs_entry_count = 1;
		crq->req_header.rqs_entry_type = RQSTYPE_DATASEG;

		for (ovseg = 0; seg < segcnt && ovseg < ISP_CDSEG;
		    rq->req_seg_count++, seg++, ovseg++) {
			crq->req_dataseg[ovseg].ds_count =
			    dmap->dm_segs[seg].ds_len;
			crq->req_dataseg[ovseg].ds_base =
			    dmap->dm_segs[seg].ds_addr;
			isp_prt(isp, ISP_LOGDEBUG2, "seg%d.[%d]={0x%lx,%lu}",
			    rq->req_header.rqs_entry_count - 1,
			    rq->req_seg_count, (long)dmap->dm_segs[seg].ds_addr,
			    (unsigned long) dmap->dm_segs[seg].ds_len);
		}
		isp_put_cont_req(isp, crq, cqe);
		MEMORYBARRIER(isp, SYNC_REQUEST, onxti, QENTRY_LEN);
	} while (seg < segcnt);

dmasync:
	bus_dmamap_sync(isp->isp_dmatag, dmap, 0, dmap->dm_mapsize,
	    (xs->flags & SCSI_DATA_IN) ?  BUS_DMASYNC_PREREAD :
	    BUS_DMASYNC_PREWRITE);

mbxsync:
	switch (rq->req_header.rqs_entry_type) {
	case RQSTYPE_REQUEST:
		isp_put_request(isp, rq, qep);
		break;
	case RQSTYPE_CMDONLY:
		isp_put_extended_request(isp, (ispextreq_t *)rq,
		    (ispextreq_t *)qep);
		break;
	case RQSTYPE_T2RQS:
		if (FCPARAM(isp)->isp_2klogin) {
			isp_put_request_t2e(isp,
			    (ispreqt2e_t *) rq, (ispreqt2e_t *) qep);
		} else {
			isp_put_request_t2(isp,
			    (ispreqt2_t *) rq, (ispreqt2_t *) qep);
		}
		break;
	case RQSTYPE_T3RQS:
		if (FCPARAM(isp)->isp_2klogin) {
			isp_put_request_t3e(isp,
			    (ispreqt3e_t *) rq, (ispreqt3e_t *) qep);
			break;
		}
		/* FALLTHROUGH */
	case RQSTYPE_A64:
		isp_put_request_t3(isp, (ispreqt3_t *) rq, (ispreqt3_t *) qep);
		break;
	}
	*nxtip = nxti;
	return (CMD_QUEUED);
}

int
isp_pci_intr(void *arg)
{
	u_int32_t isr;
	u_int16_t sema, mbox;
	struct ispsoftc *isp = (struct ispsoftc *)arg;

	isp->isp_intcnt++;
	if (ISP_READ_ISR(isp, &isr, &sema, &mbox) == 0) {
		isp->isp_intbogus++;
		return (0);
	} else {
		isp->isp_osinfo.onintstack = 1;
		isp_intr(isp, isr, sema, mbox);
		isp->isp_osinfo.onintstack = 0;
		return (1);
	}
}

void
isp_pci_dmateardown(struct ispsoftc *isp, XS_T *xs, u_int32_t handle)
{
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)isp;
	bus_dmamap_t dmap = pcs->pci_xfer_dmap[isp_handle_index(handle)];
	bus_dmamap_sync(isp->isp_dmatag, dmap, 0, dmap->dm_mapsize,
	    (xs->flags & SCSI_DATA_IN)?
	    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(isp->isp_dmatag, dmap);
}

void
isp_pci_reset0(ispsoftc_t *isp)
{
	ISP_DISABLE_INTS(isp);
}

void
isp_pci_reset1(struct ispsoftc *isp)
{
	/* Make sure the BIOS is disabled */
	isp_pci_wr_reg(isp, HCCR, PCI_HCCR_CMD_BIOS);
	/* and enable interrupts */
	ISP_ENABLE_INTS(isp);
}

void
isp_pci_dumpregs(struct ispsoftc *isp, const char *msg)
{
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)isp;
	if (msg)
                isp_prt(isp, ISP_LOGERR, "%s", msg);
	if (IS_SCSI(isp))
		isp_prt(isp, ISP_LOGERR, "    biu_conf1=%x",
		    ISP_READ(isp, BIU_CONF1));
	else
		isp_prt(isp, ISP_LOGERR, "    biu_csr=%x",
		    ISP_READ(isp, BIU2100_CSR));
	isp_prt(isp, ISP_LOGERR, " biu_icr=%x biu_isr=%x biu_sema=%x ",
	    ISP_READ(isp, BIU_ICR), ISP_READ(isp, BIU_ISR),
	    ISP_READ(isp, BIU_SEMA));
	isp_prt(isp, ISP_LOGERR, "risc_hccr=%x\n", ISP_READ(isp, HCCR));
	isp_prt(isp, ISP_LOGERR, "PCI Status Command/Status=%x\n",
	    pci_conf_read(pcs->pci_pc, pcs->pci_tag, PCI_COMMAND_STATUS_REG));
}
@


1.62
log
@yet more mallocarray() changes.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.61 2014/07/13 23:10:23 deraadt Exp $	*/
@


1.61
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.60 2014/07/12 18:48:52 tedu Exp $	*/
d1078 2
a1079 2
	len = isp->isp_maxcmds * sizeof (XS_T *);
	isp->isp_xflist = malloc(len, M_DEVBUF, M_NOWAIT | M_ZERO);
d1084 4
a1087 2
	len = isp->isp_maxcmds * sizeof (bus_dmamap_t);
	pcs->pci_xfer_dmap = (bus_dmamap_t *) malloc(len, M_DEVBUF, M_NOWAIT);
d1094 1
@


1.60
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.59 2014/02/14 05:17:05 jmatthew Exp $	*/
d563 1
a563 1
		isp->isp_param = malloc(2 * sizeof(sdparam), M_DEVBUF,
d575 1
a575 1
		isp->isp_param = malloc(2 * sizeof(sdparam),
d599 1
a599 1
		isp->isp_param = malloc(2 * sizeof(sdparam),
@


1.59
log
@remove isp24xx-related code.  it doesn't work, qle(4) replaces it, and
we need the space in the i386 ramdisks.

ok dlg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.58 2014/02/10 22:41:27 jmatthew Exp $	*/
d755 1
a755 1
		free(isp->isp_param, M_DEVBUF);
d766 1
a766 1
		free(isp->isp_param, M_DEVBUF);
d786 1
a786 1
		free(isp->isp_param, M_DEVBUF);
d794 1
a794 1
		free(isp->isp_param, M_DEVBUF);
d804 1
a804 1
		free(isp->isp_param, M_DEVBUF);
d1087 1
a1087 1
		free(isp->isp_xflist, M_DEVBUF);
d1105 2
a1106 2
		free(isp->isp_xflist, M_DEVBUF);
		free(pcs->pci_xfer_dmap, M_DEVBUF);
d1168 2
a1169 2
	free(isp->isp_xflist, M_DEVBUF);
	free(pcs->pci_xfer_dmap, M_DEVBUF);
@


1.58
log
@Build isp2xxx firmware into separate object files so we only include
one copy when both isp(4) and qla(4) are enabled.  This is a temporary
measure until qla(4) takes over completely.

looked at by miod@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.57 2011/06/23 22:02:26 oga Exp $	*/
a205 13
static struct ispmdvec mdvec_2400 = {
	isp_pci_rd_isr_2400,
	isp_pci_rd_reg_2400,
	isp_pci_wr_reg_2400,
	isp_pci_mbxdma,
	isp_pci_dmasetup,
	isp_pci_dmateardown,
	isp_pci_reset0,
	isp_pci_reset1,
	NULL,
	ISP_2400_RISC_CODE
};

a285 8
#ifndef	PCI_PRODUCT_QLOGIC_ISP2422
#define	PCI_PRODUCT_QLOGIC_ISP2422	0x2422
#endif

#ifndef	PCI_PRODUCT_QLOGIC_ISP2432
#define	PCI_PRODUCT_QLOGIC_ISP2432	0x2432
#endif

a327 6
#define	PCI_QLOGIC_ISP2422	\
	((PCI_PRODUCT_QLOGIC_ISP2422 << 16) | PCI_VENDOR_QLOGIC)

#define	PCI_QLOGIC_ISP2432	\
	((PCI_PRODUCT_QLOGIC_ISP2432 << 16) | PCI_VENDOR_QLOGIC)

a369 2
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2422 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2432 },
a691 14
	if (pa->pa_id == PCI_QLOGIC_ISP2422 ||
	    pa->pa_id == PCI_QLOGIC_ISP2432) {
		isp->isp_mdvec = &mdvec_2400;
		isp->isp_type = ISP_HA_FC_2400;
		isp->isp_port = pa->pa_function;
		isp->isp_param = malloc(sizeof(fcparam), M_DEVBUF,
		    M_NOWAIT | M_ZERO);
		if (isp->isp_param == NULL) {
			printf(nomem);
			return;
		}
		pcs->pci_poff[MBOX_BLOCK >> _BLK_REG_SHFT] =
		    PCI_MBOX_REGS2400_OFF;
	}
a965 37
int
isp_pci_rd_isr_2400(ispsoftc_t *isp, uint32_t *isrp,
    uint16_t *semap, uint16_t *mbox0p)
{
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)isp;
	uint32_t r2hisr;

	r2hisr = BXR4(pcs, IspVirt2Off(isp, BIU2400_R2HSTSLO));
	isp_prt(isp, ISP_LOGDEBUG3, "RISC2HOST ISR 0x%x", r2hisr);
	if ((r2hisr & BIU2400_R2HST_INTR) == 0) {
		*isrp = 0;
		return (0);
	}
	switch (r2hisr & BIU2400_R2HST_ISTAT_MASK) {
	case ISP2400R2HST_ROM_MBX_OK:
	case ISP2400R2HST_ROM_MBX_FAIL:
	case ISP2400R2HST_MBX_OK:
	case ISP2400R2HST_MBX_FAIL:
	case ISP2400R2HST_ASYNC_EVENT:
		*isrp = r2hisr & 0xffff;
		*mbox0p = (r2hisr >> 16);
		*semap = 1;
		return (1);
	case ISP2400R2HST_RSPQ_UPDATE:
	case ISP2400R2HST_ATIO_RSPQ_UPDATE:
	case ISP2400R2HST_ATIO_RQST_UPDATE:
		*isrp = r2hisr & 0xffff;
		*mbox0p = 0;
		*semap = 0;
		return (1);
	default:
		ISP_WRITE(isp, BIU2400_HCCR, HCCR_2400_CMD_CLEAR_RISC_INT);
		isp_prt(isp, ISP_LOGERR, "unknown interrupt 0x%x\n", r2hisr);
		return (0);
	}
}

a1057 119
uint32_t
isp_pci_rd_reg_2400(ispsoftc_t *isp, int regoff)
{
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)isp;
	uint32_t rv;
	int block = regoff & _BLK_REG_MASK;

	switch (block) {
	case BIU_BLOCK:
		break;
	case MBOX_BLOCK:
		return (BXR2(pcs, IspVirt2Off(isp, regoff)));
	case SXP_BLOCK:
		isp_prt(isp, ISP_LOGWARN, "SXP_BLOCK read at 0x%x", regoff);
		return (0xffffffff);
	case RISC_BLOCK:
		isp_prt(isp, ISP_LOGWARN, "RISC_BLOCK read at 0x%x", regoff);
		return (0xffffffff);
	case DMA_BLOCK:
		isp_prt(isp, ISP_LOGWARN, "DMA_BLOCK read at 0x%x", regoff);
		return (0xffffffff);
	default:
		isp_prt(isp, ISP_LOGWARN, "unknown block read at 0x%x", regoff);
		return (0xffffffff);
	}


	switch (regoff) {
	case BIU2400_FLASH_ADDR:
	case BIU2400_FLASH_DATA:
	case BIU2400_ICR:
	case BIU2400_ISR:
	case BIU2400_CSR:
	case BIU2400_REQINP:
	case BIU2400_REQOUTP:
	case BIU2400_RSPINP:
	case BIU2400_RSPOUTP:
	case BIU2400_PRI_RQINP:
	case BIU2400_PRI_RSPINP:
	case BIU2400_ATIO_RSPINP:
	case BIU2400_ATIO_REQINP:
	case BIU2400_HCCR:
	case BIU2400_GPIOD:
	case BIU2400_GPIOE:
	case BIU2400_HSEMA:
		rv = BXR4(pcs, IspVirt2Off(isp, regoff));
		break;
	case BIU2400_R2HSTSLO:
		rv = BXR4(pcs, IspVirt2Off(isp, regoff));
		break;
	case BIU2400_R2HSTSHI:
		rv = BXR4(pcs, IspVirt2Off(isp, regoff)) >> 16;
		break;
	default:
		isp_prt(isp, ISP_LOGERR,
		    "isp_pci_rd_reg_2400: unknown offset %x", regoff);
		rv = 0xffffffff;
		break;
	}
	return (rv);
}

void
isp_pci_wr_reg_2400(ispsoftc_t *isp, int regoff, uint32_t val)
{
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)isp;
	int block = regoff & _BLK_REG_MASK;

	switch (block) {
	case BIU_BLOCK:
		break;
	case MBOX_BLOCK:
		BXW2(pcs, IspVirt2Off(isp, regoff), val);
		MEMORYBARRIER(isp, SYNC_REG, IspVirt2Off(isp, regoff), 2);
		return;
	case SXP_BLOCK:
		isp_prt(isp, ISP_LOGWARN, "SXP_BLOCK write at 0x%x", regoff);
		return;
	case RISC_BLOCK:
		isp_prt(isp, ISP_LOGWARN, "RISC_BLOCK write at 0x%x", regoff);
		return;
	case DMA_BLOCK:
		isp_prt(isp, ISP_LOGWARN, "DMA_BLOCK write at 0x%x", regoff);
		return;
	default:
		isp_prt(isp, ISP_LOGWARN, "unknown block write at 0x%x",
		    regoff);
		break;
	}

	switch (regoff) {
	case BIU2400_FLASH_ADDR:
	case BIU2400_FLASH_DATA:
	case BIU2400_ICR:
	case BIU2400_ISR:
	case BIU2400_CSR:
	case BIU2400_REQINP:
	case BIU2400_REQOUTP:
	case BIU2400_RSPINP:
	case BIU2400_RSPOUTP:
	case BIU2400_PRI_RQINP:
	case BIU2400_PRI_RSPINP:
	case BIU2400_ATIO_RSPINP:
	case BIU2400_ATIO_REQINP:
	case BIU2400_HCCR:
	case BIU2400_GPIOD:
	case BIU2400_GPIOE:
	case BIU2400_HSEMA:
		BXW4(pcs, IspVirt2Off(isp, regoff), val);
		MEMORYBARRIER(isp, SYNC_REG, IspVirt2Off(isp, regoff), 4);
		break;
	default:
		isp_prt(isp, ISP_LOGERR,
		    "isp_pci_wr_reg_2400: bad offset 0x%x", regoff);
		break;
	}
}


a1313 3
	case RQSTYPE_T7RQS:
		isp_put_request_t7(isp, (ispreqt7_t *) rq, (ispreqt7_t *) qep);
		break;
d1358 2
a1359 4
	if (!IS_24XX(isp)) {
		/* Make sure the BIOS is disabled */
		isp_pci_wr_reg(isp, HCCR, PCI_HCCR_CMD_BIOS);
	}
@


1.57
log
@make malloc calls in isp_pci_mbxdma NOWAIT to match the bus_dma calls that are
all nowait.

While here, plug a memory leak if one of the bus_dma calls near the
bottom of the function fails because it would fail to free the dmamap,
unmap the memory and free the memory. make that part of the code use the
standard list of goto labels for error handling that most callers of
bus_dmamem_alloc; bus_dmamem_map; bus_dmamap_creat; bus_dmamap_load()
use to clean up.


ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.56 2011/06/17 07:06:47 mk Exp $	*/
d78 1
a79 1
#include <dev/microcode/isp/asm_2100.h>
d85 1
a86 1
#include <dev/microcode/isp/asm_2200.h>
d92 1
a93 1
#include <dev/microcode/isp/asm_2300.h>
@


1.56
log
@M_WAITOK cleanup of two cases:

1) Allocating with M_WAITOK, checking for NULL, and calling panic() is
pointless (malloc() will panic if it can't allocate) so remove the check
and the call.

2) Allocating with M_WAITOK, checking for NULL, and then gracefully
handling failure to allocate is pointless.  Instead also pass M_CANFAIL
so malloc() doesn't panic so we can actually handle it gracefully.

1) was done using Coccinelle.

Input from oga.

ok miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.55 2011/04/22 23:19:54 deraadt Exp $	*/
d1278 1
a1278 2
	isp->isp_xflist = malloc(len, M_DEVBUF,
	    M_WAITOK | M_CANFAIL | M_ZERO);
d1284 1
a1284 2
	pcs->pci_xfer_dmap = (bus_dmamap_t *) malloc(len, M_DEVBUF,
	    M_WAITOK | M_CANFAIL);
d1321 1
a1321 3
			     BUS_DMA_NOWAIT) ||
	    bus_dmamem_map(isp->isp_dmatag, &sg, rs, len,
	    &base, BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) {
d1323 4
a1326 1
	}
d1329 6
a1334 5
	    &isp->isp_cdmap) || bus_dmamap_load(dmat, isp->isp_cdmap,
	    base, len, NULL,
	    BUS_DMA_NOWAIT)) {
		goto dmafail;
	}
d1356 6
@


1.55
log
@Turning on SCSIDEBUG (for debugging other drivers, of course) should
not make these drivers spew millions of lines of output.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.54 2011/04/03 15:36:03 jasper Exp $	*/
d1278 2
a1279 1
	isp->isp_xflist = malloc(len, M_DEVBUF, M_WAITOK | M_ZERO);
d1285 2
a1286 1
	pcs->pci_xfer_dmap = (bus_dmamap_t *) malloc(len, M_DEVBUF, M_WAITOK);
@


1.54
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.53 2009/11/07 14:49:02 miod Exp $	*/
d742 1
a742 1
#ifdef	SCSIDEBUG
@


1.53
log
@Change sgi system identification from a single system type list, to a smaller
system type list (which really is the system family) and a subsystem type.

No functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.52 2009/08/09 09:55:03 kettenis Exp $	*/
d441 1
a441 1
	return (pci_matchbyid(pa, ispdev, sizeof(ispdev)/sizeof(ispdev[0])));
@


1.52
log
@Get node and port WWN's from the Open Firmware tree on sparc64 if they are
provided.

ok dlg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.51 2009/06/29 18:53:38 deraadt Exp $	*/
d504 2
a505 2
	    sys_config.system_type == SGI_O200 ||
	    sys_config.system_type == SGI_O300)
@


1.51
log
@the data which is read is never used; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.50 2009/06/29 18:53:01 deraadt Exp $	*/
d465 1
d485 10
d816 4
a819 2
		DEFAULT_NODEWWN(isp) = 0x400000007F000003ULL;
		DEFAULT_PORTWWN(isp) = 0x400000007F000003ULL;
@


1.50
log
@since we link in the 24xx firmware, might as well point to it; ok krw kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.49 2009/06/28 01:35:27 krw Exp $	*/
a657 1
		data = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG);
a694 1
		data = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG);
a708 1
		data = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG);
@


1.49
log
@Restore lost string constant, make DEBUG kernels compile.

Noticed by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.48 2009/06/24 11:38:40 deraadt Exp $	*/
d215 2
a216 1
	NULL
@


1.48
log
@for the isp(4) driver, invert the meaning of the options which pull
firmwares into the smaller (and larger) media
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.46 2009/05/31 17:42:13 miod Exp $	*/
d377 5
@


1.47
log
@Major update to isp driver, mostly from mjacob via FreeBSD.

Everything that worked before should still work so in it goes. Newer
boards (2300, 2400) may now work but are still a work in progress.
Thanks to many testers but especially kettenis@@ for finding a show
stopper bug and stomping it.

ok deraadt@@
@
text
@d47 11
d59 6
d66 6
d73 6
d80 6
d87 6
d94 6
d101 3
a103 2

#define	BUS_PROBE_DEFAULT	0
d135 1
a135 1
	NULL,
d149 1
a149 1
	isp_1080_risc_code,
d163 1
a163 1
	isp_12160_risc_code,
d177 1
a177 1
	isp_2100_risc_code
d190 1
a190 1
	isp_2200_risc_code
d203 1
a203 1
	isp_2300_risc_code
@


1.46
log
@Remove BUS_DMAMEM_NOSYNC definition. Its name is not consistent with
other BUS_DMA_xxx flag names, and nothing uses it.

ok many@@
@
text
@d1 4
a4 7
/*	$OpenBSD: isp_pci.c,v 1.45 2009/05/08 18:39:01 miod Exp $	*/
/*
 * PCI specific probe and attach routines for QLogic ISP SCSI adapters.
 *
 *---------------------------------------
 * Copyright (c) 1997, 1998, 1999 by Matthew Jacob
 * NASA/Ames Research Center
a5 1
 *---------------------------------------
d13 1
a13 4
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
d27 4
a30 1
 *
a46 34
static u_int16_t isp_pci_rd_reg(struct ispsoftc *, int);
static void isp_pci_wr_reg(struct ispsoftc *, int, u_int16_t);
#if !(defined(ISP_DISABLE_1080_SUPPORT) && defined(ISP_DISABLE_12160_SUPPORT))
static u_int16_t isp_pci_rd_reg_1080(struct ispsoftc *, int);
static void isp_pci_wr_reg_1080(struct ispsoftc *, int, u_int16_t);
#endif
static int
isp_pci_rd_isr(struct ispsoftc *, u_int16_t *, u_int16_t *, u_int16_t *);
#ifndef	ISP_DISABLE_2300_SUPPORT
static int
isp_pci_rd_isr_2300(struct ispsoftc *, u_int16_t *, u_int16_t *, u_int16_t *);
#endif
static int isp_pci_mbxdma(struct ispsoftc *);
static int isp_pci_dmasetup(struct ispsoftc *, struct scsi_xfer *,
	ispreq_t *, u_int16_t *, u_int16_t);
static void
isp_pci_dmateardown (struct ispsoftc *, struct scsi_xfer *, u_int16_t);
static void isp_pci_reset1 (struct ispsoftc *);
static void isp_pci_dumpregs (struct ispsoftc *, const char *);
static int isp_pci_intr (void *);

#ifdef	ISP_COMPILE_FW
#define	ISP_COMPILE_1040_FW	1
#define	ISP_COMPILE_1080_FW	1
#define	ISP_COMPILE_12160_FW	1
#define	ISP_COMPILE_2100_FW	1
#define	ISP_COMPILE_2200_FW	1
#define	ISP_COMPILE_2300_FW	1
#endif

#if	defined(ISP_DISABLE_1040_SUPPORT) || !defined(ISP_COMPILE_1040_FW)
#define	ISP_1040_RISC_CODE	NULL
#else
#define	ISP_1040_RISC_CODE	(u_int16_t *) isp_1040_risc_code
a47 6
#endif

#if	defined(ISP_DISABLE_1080_SUPPORT) || !defined(ISP_COMPILE_1080_FW)
#define	ISP_1080_RISC_CODE	NULL
#else
#define	ISP_1080_RISC_CODE	(u_int16_t *) isp_1080_risc_code
a48 6
#endif

#if	defined(ISP_DISABLE_12160_SUPPORT) || !defined(ISP_COMPILE_12160_FW)
#define	ISP_12160_RISC_CODE	(u_int16_t *) NULL
#else
#define	ISP_12160_RISC_CODE	(u_int16_t *) isp_12160_risc_code
a49 6
#endif

#if	defined(ISP_DISABLE_2100_SUPPORT) || !defined(ISP_COMPILE_2100_FW)
#define	ISP_2100_RISC_CODE	NULL
#else
#define	ISP_2100_RISC_CODE	(u_int16_t *) isp_2100_risc_code
d51 3
a53 1
#endif
d55 1
a55 6
#if	defined(ISP_DISABLE_2200_SUPPORT) || !defined(ISP_COMPILE_2200_FW)
#define	ISP_2200_RISC_CODE	NULL
#else
#define	ISP_2200_RISC_CODE	(u_int16_t *) isp_2200_risc_code
#include <dev/microcode/isp/asm_2200.h>
#endif
d57 19
a75 6
#if	defined(ISP_DISABLE_2300_SUPPORT) || !defined(ISP_COMPILE_2300_FW)
#define	ISP_2300_RISC_CODE	NULL
#else
#define	ISP_2300_RISC_CODE	(u_int16_t *) isp_2300_risc_code
#include <dev/microcode/isp/asm_2300.h>
#endif
a76 1
#ifndef	ISP_DISABLE_1020_SUPPORT
d84 1
a84 1
	NULL,
d87 1
a87 1
	ISP_1040_RISC_CODE,
a89 1
#endif
a90 1
#ifndef	ISP_DISABLE_1080_SUPPORT
d98 1
a98 1
	NULL,
d101 1
a101 1
	ISP_1080_RISC_CODE,
a103 1
#endif
a104 1
#ifndef	ISP_DISABLE_12160_SUPPORT
d112 1
a112 1
	NULL,
d115 1
a115 1
	ISP_12160_RISC_CODE,
a117 1
#endif
a118 1
#ifndef	ISP_DISABLE_2100_SUPPORT
d126 1
a126 1
	NULL,
d129 1
a129 1
	ISP_2100_RISC_CODE
a130 1
#endif
a131 1
#ifndef	ISP_DISABLE_2200_SUPPORT
d139 1
a139 1
	NULL,
d142 1
a142 1
	ISP_2200_RISC_CODE
a143 1
#endif
a144 1
#ifndef	ISP_DISABLE_2300_SUPPORT
d152 1
a152 1
	NULL,
d155 13
a167 1
	ISP_2300_RISC_CODE
d169 31
d203 1
a203 1
#define	PCI_VENDOR_QLOGIC	0x1077
d214 8
a229 8
#ifndef	PCI_PRODUCT_QLOGIC_ISP10160
#define	PCI_PRODUCT_QLOGIC_ISP10160	0x1016
#endif

#ifndef	PCI_PRODUCT_QLOGIC_ISP12160
#define	PCI_PRODUCT_QLOGIC_ISP12160	0x1216
#endif

d246 12
d262 7
a268 1
#define	PCI_QLOGIC_ISP	((PCI_PRODUCT_QLOGIC_ISP1020 << 16) | PCI_VENDOR_QLOGIC)
d273 6
a284 6
#define	PCI_QLOGIC_ISP10160	\
	((PCI_PRODUCT_QLOGIC_ISP10160 << 16) | PCI_VENDOR_QLOGIC)

#define	PCI_QLOGIC_ISP12160	\
	((PCI_PRODUCT_QLOGIC_ISP12160 << 16) | PCI_VENDOR_QLOGIC)

d297 9
d309 3
d317 2
a318 4

#define IO_MAP_REG	0x10
#define MEM_MAP_REG	0x14
#define	PCIR_ROMADDR	0x30
d331 21
a351 2
static int isp_pci_probe (struct device *, void *, void *);
static void isp_pci_attach (struct device *, struct device *, void *);
d353 1
d369 1
a369 33
#ifdef  DEBUG
const char vstring[] =
    "QLogic ISP Driver, NetBSD (pci) Platform Version %d.%d Core Version %d.%d";
#endif

const struct pci_matchid ispdev[] = {
#ifndef	ISP_DISABLE_1020_SUPPORT
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP1020 },
#endif
#ifndef	ISP_DISABLE_1080_SUPPORT
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP1080 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP1240 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP1280 },
#endif
#ifndef	ISP_DISABLE_12160_SUPPORT
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP10160 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP12160 },
#endif
#ifndef	ISP_DISABLE_2100_SUPPORT
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2100 },
#endif
#ifndef	ISP_DISABLE_2200_SUPPORT
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2200 },
#endif
#ifndef	ISP_DISABLE_2300_SUPPORT
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2300 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2312 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP6312 },
#endif
	{ 0, 0 }
};

static int
d391 1
a391 1
static void    
d400 1
a400 1
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *) self;
d492 2
a493 2
	pcs->pci_st = st;
	pcs->pci_sh = sh;
d502 1
a502 2
#ifndef	ISP_DISABLE_1020_SUPPORT
	if (pa->pa_id == PCI_QLOGIC_ISP) {
a511 2
#endif
#ifndef	ISP_DISABLE_1080_SUPPORT
a547 2
#endif
#ifndef	ISP_DISABLE_12160_SUPPORT
a571 2
#endif
#ifndef	ISP_DISABLE_2100_SUPPORT
a592 2
#endif
#ifndef	ISP_DISABLE_2200_SUPPORT
d617 13
a629 4
#endif
#ifndef	ISP_DISABLE_2300_SUPPORT
	if (pa->pa_id == PCI_QLOGIC_ISP2300 ||
	    pa->pa_id == PCI_QLOGIC_ISP2312 ||
d632 7
a638 5
		if (pa->pa_id  == PCI_QLOGIC_ISP2300) {
			isp->isp_type = ISP_HA_FC_2300;
		} else {
			isp->isp_type = ISP_HA_FC_2312;
			isp->isp_port = pa->pa_function;
d640 9
d659 14
a672 1
#endif
d768 1
a768 1
	ENABLE_INTS(isp);
d791 1
a791 1
	_BLK_REG_SHFT] + ((x) & 0xff))
d797 4
d802 1
a802 2

static INLINE int
d805 2
a806 2
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;
	u_int16_t val0, val1;
d820 2
a821 2
static int
isp_pci_rd_isr(struct ispsoftc *isp, u_int16_t *isrp,
d824 1
a824 1
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;
d857 2
a858 3
#ifndef	ISP_DISABLE_2300_SUPPORT
static int
isp_pci_rd_isr_2300(struct ispsoftc *isp, u_int16_t *isrp,
d861 2
a862 1
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;
d869 1
a869 2
	r2hisr = bus_space_read_4(pcs->pci_st, pcs->pci_sh,
	    IspVirt2Off(pcs, BIU_R2HSTSLO));
d906 11
a919 1
#endif
d921 1
a921 1
static u_int16_t
d925 1
a925 1
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;
d935 1
d941 1
d945 3
a947 2
static void
isp_pci_wr_reg(struct ispsoftc *isp, int regoff, u_int16_t val)
d949 37
a985 1
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;
d995 1
d998 1
d1001 1
d1003 1
d1006 1
a1006 2
#if !(defined(ISP_DISABLE_1080_SUPPORT) && defined(ISP_DISABLE_12160_SUPPORT))
static u_int16_t
d1009 2
a1010 2
	u_int16_t rv, oc = 0;
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;
d1014 1
a1014 1
		u_int16_t tc;
d1025 1
d1030 1
d1035 1
d1040 2
a1041 2
static void
isp_pci_wr_reg_1080(struct ispsoftc *isp, int regoff, u_int16_t val)
d1043 1
a1043 1
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;
d1048 1
a1048 1
		u_int16_t tc;
d1059 1
d1064 1
d1067 1
d1070 62
d1133 1
a1134 1
#endif
d1136 64
a1199 1
static int
d1205 1
d1207 1
a1207 1
	fcparam *fcp;
d1248 1
a1248 1
	 * Allocate and map the request queue.
d1251 5
d1259 1
a1259 1
	    (caddr_t *)&isp->isp_rquest, BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) {
d1264 2
a1265 2
	    &isp->isp_rqdmap) || bus_dmamap_load(dmat, isp->isp_rqdmap,
	    (caddr_t)isp->isp_rquest, len, NULL,
a1268 1
	isp->isp_rquest_dma = isp->isp_rqdmap->dm_segs[0].ds_addr;
d1270 8
a1277 17
	/*
	 * Allocate and map the result queue.
	 */
	len = ISP_QUEUE_SIZE(RESULT_QUEUE_LEN(isp));
	if (bus_dmamem_alloc(dmat, len, PAGE_SIZE, 0, &sg, 1, &rs,
			     BUS_DMA_NOWAIT) ||
	    bus_dmamem_map(dmat, &sg, rs, len, (caddr_t *)&isp->isp_result,
	    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) {
		goto dmafail;
	}
	if (bus_dmamap_create(dmat, len, 1, len, 0, BUS_DMA_NOWAIT,
	    &isp->isp_rsdmap) || bus_dmamap_load(isp->isp_dmatag,
	    isp->isp_rsdmap, (caddr_t)isp->isp_result, len, NULL,
	    BUS_DMA_NOWAIT)) {
		goto dmafail;
	}
	isp->isp_result_dma = isp->isp_rsdmap->dm_segs[0].ds_addr;
a1278 2
	if (IS_SCSI(isp)) {
		return (0);
d1281 6
a1286 7
	fcp = isp->isp_param;
	len = ISP2100_SCRLEN;
	if (bus_dmamem_alloc(dmat, len, PAGE_SIZE, 0, &sg, 1, &rs,
			     BUS_DMA_NOWAIT) ||
	    bus_dmamem_map(dmat, &sg, rs, len, (caddr_t *)&fcp->isp_scratch,
	    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) {
		goto dmafail;
a1287 7
	if (bus_dmamap_create(dmat, len, 1, len, 0, BUS_DMA_NOWAIT,
	    &isp->isp_scdmap) || bus_dmamap_load(dmat,
	    isp->isp_scdmap, (caddr_t)fcp->isp_scratch, len, NULL,
	    BUS_DMA_NOWAIT)) {
		goto dmafail;
	}
	fcp->isp_scdma = isp->isp_scdmap->dm_segs[0].ds_addr;
d1289 1
d1302 1
a1302 1
static int
d1304 1
a1304 1
    u_int16_t *nxtip, u_int16_t optr)
d1308 1
a1308 1
	u_int16_t starti = isp->isp_reqidx, nxti = *nxtip;
d1312 1
a1312 1
	qep = (ispreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, starti);
d1423 20
a1442 1
		isp_put_request_t2(isp, (ispreqt2_t *) rq, (ispreqt2_t *) qep);
d1449 1
a1449 1
static int
d1452 2
a1453 1
	u_int16_t isr, sema, mbox;
d1468 2
a1469 2
static void
isp_pci_dmateardown(struct ispsoftc *isp, XS_T *xs, u_int16_t handle)
d1479 7
a1485 1
static void
d1488 3
a1490 4
	/* Make sure the BIOS is disabled */
	isp_pci_wr_reg(isp, HCCR, PCI_HCCR_CMD_BIOS);
	if (isp->isp_osinfo.no_mbox_ints == 0) {
		ENABLE_INTS(isp);
d1492 2
d1496 1
a1496 1
static void
d1502 10
@


1.45
log
@The default initiator value is 0 on sgi IP27, IP30 and IP35 systems. Since
they don't seem to have a valid NVRAM either, override the default value.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.44 2008/06/01 15:49:25 kettenis Exp $	*/
a314 4
#endif

#ifndef	BUS_DMA_COHERENT
#define	BUS_DMA_COHERENT	BUS_DMAMEM_NOSYNC
@


1.44
log
@Make SCSI isp(4) use the same SCSI initiator ID as the prom on sparc/sparc64.

ok marco@@, krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.43 2008/05/28 18:46:56 kettenis Exp $	*/
d46 4
d432 12
@


1.43
log
@Turns out I have an ISP 12160 myself, and it works fine on sparc64.  Since
a fix has been made that might make the 10160 work too, enable support again.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.42 2008/04/13 15:31:33 kettenis Exp $	*/
d407 22
@


1.42
log
@Disable ISP10160 and ISP12160.  They don't quite work yet, and people with
another (working) isp(4) get hurt by this.

ok krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.41 2008/01/21 20:00:33 sobrado Exp $	*/
a35 2

#define ISP_DISABLE_12160_SUPPORT	/* XXX Doesn't quite work yet. */
@


1.41
log
@use the right capitalization for `QLogic'

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.40 2007/09/22 16:03:23 krw Exp $	*/
d36 2
@


1.40
log
@Obvious M_ZERO/bzero() change. Note that isp_param is void *, so the
idiom 'malloc(sizeof(*isp_param) ...' is not possible.

May even fix a couple of bugs. In two places 2*n was malloc'd, but
only n was bzero'd.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.39 2007/02/28 19:40:38 kettenis Exp $	*/
d3 1
a3 1
 * PCI specific probe and attach routines for Qlogic ISP SCSI adapters.
d337 1
a337 1
    "Qlogic ISP Driver, NetBSD (pci) Platform Version %d.%d Core Version %d.%d";
@


1.39
log
@Set ISP_CFG_NOVRAM for Sun-branded ISP2200's that don't have an NVRAM fitted.
Avoids the "invalid NVRAM" message on the Blade 1000 and other machines with
onboard isp(4).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.38 2005/09/11 18:17:08 mickey Exp $	*/
d470 2
a471 1
		isp->isp_param = malloc(sizeof (sdparam), M_DEVBUF, M_NOWAIT);
a475 1
		bzero(isp->isp_param, sizeof (sdparam));
d482 2
a483 1
		isp->isp_param = malloc(sizeof (sdparam), M_DEVBUF, M_NOWAIT);
a487 1
		bzero(isp->isp_param, sizeof (sdparam));
d494 2
a495 2
		isp->isp_param = malloc(2 * sizeof (sdparam),
		    M_DEVBUF, M_NOWAIT);
a499 1
		bzero(isp->isp_param, sizeof (sdparam));
d506 2
a507 2
		isp->isp_param = malloc(2 * sizeof (sdparam),
		    M_DEVBUF, M_NOWAIT);
a511 1
		bzero(isp->isp_param, sizeof (sdparam));
d520 2
a521 1
		isp->isp_param = malloc(sizeof (sdparam), M_DEVBUF, M_NOWAIT);
a525 1
		bzero(isp->isp_param, sizeof (sdparam));
d532 2
a533 2
		isp->isp_param = malloc(2 * sizeof (sdparam),
		    M_DEVBUF, M_NOWAIT);
a537 1
		bzero(isp->isp_param, 2 * sizeof (sdparam));
d546 2
a547 1
		isp->isp_param = malloc(sizeof (fcparam), M_DEVBUF, M_NOWAIT);
a551 1
		bzero(isp->isp_param, sizeof (fcparam));
d569 2
a570 1
		isp->isp_param = malloc(sizeof (fcparam), M_DEVBUF, M_NOWAIT);
a574 1
		bzero(isp->isp_param, sizeof (fcparam));
d602 2
a603 1
		isp->isp_param = malloc(sizeof (fcparam), M_DEVBUF, M_NOWAIT);
a607 1
		bzero(isp->isp_param, sizeof (fcparam));
d968 1
a968 1
	isp->isp_xflist = (XS_T **) malloc(len, M_DEVBUF, M_WAITOK);
a972 1
	bzero(isp->isp_xflist, len);
@


1.38
log
@do not inline pci_mapreg_map() anymore as it is olrite now; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.37 2005/08/09 04:10:13 mickey Exp $	*/
d43 4
d406 1
d581 11
d701 1
a701 1
	isp->isp_confopts = self->dv_cfdata->cf_flags;
@


1.37
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.36 2005/04/08 02:07:49 brad Exp $	*/
a400 1
	bus_addr_t iobase, mbase;
d406 2
a407 4
	if (pci_mem_find(pa->pa_pc, pa->pa_tag, MEM_MAP_REG, &mbase, &msize,
	    NULL)) {
		printf(": can't find mem space\n");
	} else if (bus_space_map(pa->pa_memt, mbase, msize, 0, &memh)) {
a409 1
		memt = pa->pa_memt;
d415 2
a416 5
		if (pci_io_find(pa->pa_pc, pa->pa_tag, IO_MAP_REG, &iobase,
		    &iosize)) {
			printf(": can't find i/o space\n");
		} else if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &ioh)) {
			printf(": can't map i/o space\n");
a417 1
			iot = pa->pa_iot;
d424 2
a425 3
	if (pci_io_find(pa->pa_pc, pa->pa_tag, IO_MAP_REG, &iobase, &iosize)) {
		printf(": can't find i/o space\n");
	} else if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &ioh)) {
a427 1
		iot = pa->pa_iot;
d433 2
a434 4
		if (pci_mem_find(pa->pa_pc, pa->pa_tag, MEM_MAP_REG, &mbase,
		    &msize, NULL)) {
			printf(": can't find mem space\n");
		} else if (bus_space_map(pa->pa_memt, mbase, msize, 0, &memh)) {
a436 1
			memt = pa->pa_memt;
@


1.36
log
@recognize Dell OEM 2312 card.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.35 2003/12/06 14:40:33 grange Exp $	*/
d650 1
a650 1
	data |= PCI_COMMAND_MASTER_ENABLE | PCI_COMMAND_INVALIDATE_ENABLE;
@


1.35
log
@Mark u_int64_t constants with ULL to make gcc3 happy.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.34 2003/06/26 00:47:47 mickey Exp $	*/
d252 4
d284 4
d358 1
d593 2
a594 1
	    pa->pa_id == PCI_QLOGIC_ISP2312) {
@


1.34
log
@fix probing for ami raid owned hba properly; mjacob@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.33 2003/03/03 18:27:11 mjacob Exp $	*/
d684 2
a685 2
		DEFAULT_NODEWWN(isp) = 0x400000007F000003;
		DEFAULT_PORTWWN(isp) = 0x400000007F000003;
@


1.33
log
@Use new pci_matchbyid routine. Add (unable to test, no h/w) 10160 support.
Use correct size to zero sdparam area for 12160.

Compile tested: sparc64, sparc
run tested: sparc64 (2200, 1040), sparc (sbus isp)
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.32 2003/02/28 15:36:39 mickey Exp $	*/
d367 1
a367 1
		if (subvid == AMI_RAID_SUBVENDOR_ID) {
@


1.32
log
@take too. patch ahs to screw up once in a while
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.31 2003/02/28 15:26:23 mickey Exp $	*/
d228 4
d263 3
d328 1
a328 6
static int
isp_pci_probe(struct device *parent, void *match, void *aux)
{
        struct pci_attach_args *pa = aux;

        switch (pa->pa_id) {
d330 1
a330 2
	case PCI_QLOGIC_ISP:
		return (1);
d333 3
a335 4
	case PCI_QLOGIC_ISP1080:
	case PCI_QLOGIC_ISP1240:
	case PCI_QLOGIC_ISP1280:
		return (1);
d338 2
a339 9
	case PCI_QLOGIC_ISP12160:
	{
		pcireg_t subvid = 
			pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBVEND_0);
		if (subvid == AMI_RAID_SUBVENDOR_ID) {
			return (0);
                }
		return (1);
	}
d342 1
a342 2
	case PCI_QLOGIC_ISP2100:
		return (1);
d345 1
a345 2
	case PCI_QLOGIC_ISP2200:
		return (1);
d348 2
a349 3
	case PCI_QLOGIC_ISP2300:
	case PCI_QLOGIC_ISP2312:
		return (1);
d351 19
a369 2
	default:
		return (0);
d371 2
d518 12
d539 1
a539 1
		bzero(isp->isp_param, sizeof (sdparam));
@


1.31
log
@remove non-typo changes. sorry folks
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.29 2002/08/17 17:35:48 mjacob Exp $	*/
a325 5
	/* those are raid puppies */
	if (PCI_VENDOR(pci_conf_read(pa->pa_pc, pa->pa_tag,
	    PCI_SUBSYS_ID_REG)) == PCI_VENDOR_AMI)
		return (0);

a614 3
	}
	if (IS_23XX(isp)) {
		isp->isp_touched = 1;
@


1.30
log
@typo; from weissmanndude
@
text
@d624 3
@


1.29
log
@Set all 23XX cards as 'touched' (we have trouble, unpredictably, about
running ABOUT FIRMWARE with some that were started by BIOS downloads).

Fix the incorrect parsing of the Risc2Host isr. For RIO_16,
fast posting command completion, and fast post CTIO completion,
the upper half of Risc2Host is a copy of mailbox #1- *not*
mailbox #0.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.28 2002/05/17 01:22:38 mjacob Exp $	*/
d325 5
@


1.28
log
@Handle the removal of 'const' from structure definition.

Do not attach to AMI Raid Units (known via Sub Vendor ID) because they
really *aren't* quite a QLogic ISP device, now are they?

Split 2300 from 2312 types. Turn off pci parity for 2300s (per QLogic
errata).

Add missing ISPR2HST_RIO_16 case.

At isp_pci_reset1 time, turn on interrupts if we say it's okay to do so.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.27 2001/12/14 00:20:55 mjacob Exp $	*/
d616 3
d788 4
d793 4
d798 4
d804 1
a804 1
		*mbox0p = (r2hisr >> 16);
@


1.27
log
@Major restructuring for swizzling to the request queue and unswizzling from
the response queue. Instead of the ad hoc ISP_SWIZZLE_REQUEST, we now have
a complete set of inline functions in isp_inline.h. Each platform is
responsible for providing just one of a set of ISP_IOX_{GET,PUT}{8,16,32}
macros.

The reason this needs to be done is that we need to have a single set of
functions that will work correctly on multiple architectures for both little
and big endian machines. It also needs to work correctly in the case that
we have the request or response queues in memory that has to be treated
specially (e.g., have ddi_dma_sync called on it for Solaris after we update
it or before we read from it).

One thing that falls out of this is that we no longer build requests in the
request queue itself. Instead, we build the request locally (e.g., on the
stack) and then as part of the swizzling operation, copy it to the request
queue entry we've allocated. I thought long and hard about whether this was
too expensive a change to make as it in a lot of cases requires an extra
copy. On balance, the flexbility is worth it. With any luck, the entry that
we build locally stays in a processor writeback cache (after all, it's only
64 bytes) so that the cost of actually flushing it to the memory area that is
the shared queue with the PCI device is not all that expensive. We may examine
this again and try to get clever in the future to try and avoid copies.

Another change that falls out of this is that MEMORYBARRIER should be taken
a lot more seriously. The macro ISP_ADD_REQUEST does a MEMORYBARRIER on the
entry being added. But there had been many other places this had been missing.
It's now very important that it be done.

For OpenSD, it does a ddi_dmamap_sync as appropriate. This gets us out of
the explicit ddi_dmamap_sync on the whole response queue that we did for SBus
cards at each interrupt. Now, because SBus/sparc doesn't use bus_dma, some
shenanigans were done to support this. But Jason was nice enough to test the
SBus/sparcv9 changes for me, and they did the right thing as well.

Set things up so that platforms that cannot have an SBus don't get a lot of
the SBus code checks (dead coded out).

Additional changes:

Fix a longstanding buglet of sorts. When we get an entry via isp_getrqentry,
the iptr value that gets returned is the value we intend to eventually plug
into the ISP registers as the entry *one past* the last one we've written-
*not* the current entry we're updating. All along we've been calling sync
functions on the wrong index value. Argh. The 'fix' here is to rename all
'iptr' variables as 'nxti' to remember that this is the 'next' pointer-
not the current pointer.

Devote a single bit to mboxbsy- and set aside bits for output mbox registers
that we need to pick up- we can have at least one command which does not
have any defined output registers (MBOX_EXECUTE_FIRMWARE).

Explicitly decode GetAllNext SNS Response back *as* a GetAllNext response.
Otherwise, we won't unswizzle it correctly.

Nuke some additional __P macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.26 2001/11/05 17:25:58 art Exp $	*/
d76 1
a76 1
#define	ISP_1040_RISC_CODE	isp_1040_risc_code
d83 1
a83 1
#define	ISP_1080_RISC_CODE	isp_1080_risc_code
d88 1
a88 1
#define	ISP_12160_RISC_CODE	NULL
d90 1
a90 1
#define	ISP_12160_RISC_CODE	isp_12160_risc_code
d97 1
a97 1
#define	ISP_2100_RISC_CODE	isp_2100_risc_code
d104 1
a104 1
#define	ISP_2200_RISC_CODE	isp_2200_risc_code
d111 1
a111 1
#define	ISP_2300_RISC_CODE	isp_2300_risc_code
d273 5
d339 6
d346 1
d565 6
a570 1
		isp->isp_type = ISP_HA_FC_2300;
d613 3
d785 1
d1187 3
@


1.27.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.27 2001/12/14 00:20:55 mjacob Exp $	*/
d76 1
a76 1
#define	ISP_1040_RISC_CODE	(u_int16_t *) isp_1040_risc_code
d83 1
a83 1
#define	ISP_1080_RISC_CODE	(u_int16_t *) isp_1080_risc_code
d88 1
a88 1
#define	ISP_12160_RISC_CODE	(u_int16_t *) NULL
d90 1
a90 1
#define	ISP_12160_RISC_CODE	(u_int16_t *) isp_12160_risc_code
d97 1
a97 1
#define	ISP_2100_RISC_CODE	(u_int16_t *) isp_2100_risc_code
d104 1
a104 1
#define	ISP_2200_RISC_CODE	(u_int16_t *) isp_2200_risc_code
d111 1
a111 1
#define	ISP_2300_RISC_CODE	(u_int16_t *) isp_2300_risc_code
a272 5
/*
 * Odd case for some AMI raid cards... We need to *not* attach to this.
 */
#define	AMI_RAID_SUBVENDOR_ID	0x101e

a333 6
	{
		pcireg_t subvid = 
			pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBVEND_0);
		if (subvid == AMI_RAID_SUBVENDOR_ID) {
			return (0);
                }
a334 1
	}
d553 1
a553 6
		if (pa->pa_id  == PCI_QLOGIC_ISP2300) {
			isp->isp_type = ISP_HA_FC_2300;
		} else {
			isp->isp_type = ISP_HA_FC_2312;
			isp->isp_port = pa->pa_function;
		}
a595 3
	if (IS_2300(isp)) {	/* per QLogic errata */
		data &= ~PCI_COMMAND_PARITY_ENABLE;
	}
a764 1
	case ISPR2HST_RIO_16:
a1165 3
	if (isp->isp_osinfo.no_mbox_ints == 0) {
		ENABLE_INTS(isp);
	}
@


1.27.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.27.2.1 2002/06/11 03:42:26 art Exp $	*/
a615 3
	if (IS_23XX(isp)) {
		isp->isp_touched = 1;
	}
a784 4
		*isrp = r2hisr & 0xffff;
		*mbox0p = (r2hisr >> 16);
		*semap = 1;
		return (1);
a785 4
		*isrp = r2hisr & 0xffff;
		*mbox0p = ASYNC_RIO1;
		*semap = 1;
		return (1);
a786 4
		*isrp = r2hisr & 0xffff;
		*mbox0p = ASYNC_CMD_CMPLT;
		*semap = 1;
		return (1);
d789 1
a789 1
		*mbox0p = ASYNC_CTIO_DONE;
@


1.27.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a227 4
#ifndef	PCI_PRODUCT_QLOGIC_ISP10160
#define	PCI_PRODUCT_QLOGIC_ISP10160	0x1016
#endif

a258 3
#define	PCI_QLOGIC_ISP10160	\
	((PCI_PRODUCT_QLOGIC_ISP10160 << 16) | PCI_VENDOR_QLOGIC)

d321 6
a326 1
const struct pci_matchid ispdev[] = {
d328 2
a329 1
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP1020 },
d332 4
a335 3
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP1080 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP1240 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP1280 },
d338 9
a346 2
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP10160 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP12160 },
d349 2
a350 1
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2100 },
d353 2
a354 1
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2200 },
d357 3
a359 2
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2300 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2312 },
d361 2
a362 19
	{ 0, 0 }
};

static int
isp_pci_probe(struct device *parent, void *match, void *aux)
{
        struct pci_attach_args *pa = aux;

#ifndef	ISP_DISABLE_12160_SUPPORT
	/*
	 * Sigh. Check for subvendor id match here. Too bad we
	 * can't give an exclude mask in matchbyid.
	 */
        if (pa->pa_id == PCI_QLOGIC_ISP12160) {
		pcireg_t subvid =
		    pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBVEND_0);
		if (subvid == AMI_RAID_SUBVENDOR_ID) {
			return (0);
                }
a363 2
#endif
	return (pci_matchbyid(pa, ispdev, sizeof(ispdev)/sizeof(ispdev[0])));
a508 12
	if (pa->pa_id == PCI_QLOGIC_ISP10160) {
		isp->isp_mdvec = &mdvec_12160;
		isp->isp_type = ISP_HA_SCSI_10160;
		isp->isp_param = malloc(sizeof (sdparam), M_DEVBUF, M_NOWAIT);
		if (isp->isp_param == NULL) {
			printf(nomem);
			return;
		}
		bzero(isp->isp_param, sizeof (sdparam));
		pcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] =
		    ISP1080_DMA_REGS_OFF;
	}
d518 1
a518 1
		bzero(isp->isp_param, 2 * sizeof (sdparam));
@


1.26
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.25 2001/10/06 22:45:52 mjacob Exp $	*/
a301 4
	bus_dma_tag_t		pci_dmat;
	bus_dmamap_t		pci_scratch_dmap;	/* for fcp only */
	bus_dmamap_t		pci_rquest_dmap;
	bus_dmamap_t		pci_result_dmap;
d370 1
a370 1
	int ioh_valid, memh_valid, i;
a435 1
	pcs->pci_dmat = pa->pa_dmat;
d589 1
a661 17

	/*
	 * Create the DMA maps for the data transfers.
	 */
	for (i = 0; i < isp->isp_maxcmds; i++) {
		if (bus_dmamap_create(pcs->pci_dmat, MAXPHYS,
		    (MAXPHYS / NBPG) + 1, MAXPHYS, 0, BUS_DMA_NOWAIT,
		    &pcs->pci_xfer_dmap[i])) {
			printf("%s: can't create dma maps\n", isp->isp_name);
			isp_uninit(isp);
			ISP_UNLOCK(isp);
			free(isp->isp_param, M_DEVBUF);
			return;
		}
	}


d890 3
a892 2
	struct isp_pcisoftc *pci = (struct isp_pcisoftc *)isp;
	bus_dma_segment_t seg;
d895 1
a895 1
	int rseg;
d900 1
a900 1
	len = isp->isp_maxcmds * sizeof (XS_T);
d902 4
d908 26
a933 1
	pci->pci_xfer_dmap = (bus_dmamap_t *) malloc(len, M_DEVBUF, M_WAITOK);
d939 6
a944 9
	if (bus_dmamem_alloc(pci->pci_dmat, len, NBPG, 0, &seg, 1, &rseg,
	      BUS_DMA_NOWAIT) || bus_dmamem_map(pci->pci_dmat, &seg, rseg, len,
	      (caddr_t *)&isp->isp_rquest, BUS_DMA_NOWAIT|BUS_DMA_COHERENT))
		return (1);
	if (bus_dmamap_create(pci->pci_dmat, len, 1, len, 0, BUS_DMA_NOWAIT,
	      &pci->pci_rquest_dmap) ||
	    bus_dmamap_load(pci->pci_dmat, pci->pci_rquest_dmap,
	      (caddr_t)isp->isp_rquest, len, NULL, BUS_DMA_NOWAIT))
		return (1);
d946 7
a952 1
	isp->isp_rquest_dma = pci->pci_rquest_dmap->dm_segs[0].ds_addr;
d958 13
a970 10
	if (bus_dmamem_alloc(pci->pci_dmat, len, NBPG, 0, &seg, 1, &rseg,
	      BUS_DMA_NOWAIT) || bus_dmamem_map(pci->pci_dmat, &seg, rseg, len,
	      (caddr_t *)&isp->isp_result, BUS_DMA_NOWAIT|BUS_DMA_COHERENT))
		return (1);
	if (bus_dmamap_create(pci->pci_dmat, len, 1, len, 0, BUS_DMA_NOWAIT,
	      &pci->pci_result_dmap) ||
	    bus_dmamap_load(pci->pci_dmat, pci->pci_result_dmap,
	      (caddr_t)isp->isp_result, len, NULL, BUS_DMA_NOWAIT))
		return (1);
	isp->isp_result_dma = pci->pci_result_dmap->dm_segs[0].ds_addr;
d978 13
a990 10
	if (bus_dmamem_alloc(pci->pci_dmat, len, NBPG, 0, &seg, 1, &rseg,
	    BUS_DMA_NOWAIT) || bus_dmamem_map(pci->pci_dmat, &seg, rseg, len,
	      (caddr_t *)&fcp->isp_scratch, BUS_DMA_NOWAIT|BUS_DMA_COHERENT))
		return (1);
	if (bus_dmamap_create(pci->pci_dmat, len, 1, len, 0, BUS_DMA_NOWAIT,
	    &pci->pci_scratch_dmap) || bus_dmamap_load(pci->pci_dmat,
	    pci->pci_scratch_dmap, (caddr_t)fcp->isp_scratch, len, NULL,
	    BUS_DMA_NOWAIT))
		return (1);
	fcp->isp_scdma = pci->pci_scratch_dmap->dm_segs[0].ds_addr;
d992 10
d1005 2
a1006 2
isp_pci_dmasetup(struct ispsoftc *isp, XS_T *xs, ispreq_t *rq, u_int16_t *iptrp,
	u_int16_t optr)
d1008 1
a1008 1
	struct isp_pcisoftc *pci = (struct isp_pcisoftc *)isp;
d1010 2
a1011 1
	ispcontreq_t *crq;
d1014 2
a1015 2
	dmap = pci->pci_xfer_dmap[isp_handle_index(rq->req_handle)];

d1032 1
a1036 1
		rq->req_flags |= drq;
d1038 2
a1039 2
	error = bus_dmamap_load(pci->pci_dmat, dmap, xs->data, xs->datalen,
	    NULL, xs->flags & SCSI_NOSLEEP ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
d1047 4
d1066 3
d1071 1
a1071 1
	if (seg == segcnt)
d1073 1
d1076 9
a1084 3
		crq = (ispcontreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, *iptrp);
		*iptrp = ISP_NXT_QENTRY(*iptrp, RQUEST_QUEUE_LEN(isp));
		if (*iptrp == optr) {
d1086 1
a1086 1
			bus_dmamap_unload(pci->pci_dmat, dmap);
d1101 4
d1106 2
d1111 3
a1113 3
	bus_dmamap_sync(pci->pci_dmat, dmap, 0, dmap->dm_mapsize,
	    (xs->flags & SCSI_DATA_IN) ?
	    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
d1116 13
a1128 3
	ISP_SWIZZLE_REQUEST(isp, rq);
	bus_dmamap_sync(pci->pci_dmat, pci->pci_rquest_dmap, 0,
	    pci->pci_rquest_dmap->dm_mapsize, BUS_DMASYNC_PREWRITE);
a1136 1
	struct isp_pcisoftc *p = (struct isp_pcisoftc *)isp;
a1142 2
		bus_dmamap_sync(p->pci_dmat, p->pci_result_dmap, 0,
		    p->pci_result_dmap->dm_mapsize, BUS_DMASYNC_POSTREAD);
d1153 4
a1156 4
	struct isp_pcisoftc *pci = (struct isp_pcisoftc *)isp;
	bus_dmamap_t dmap = pci->pci_xfer_dmap[isp_handle_index(handle)];
	bus_dmamap_sync(pci->pci_dmat, dmap, 0, dmap->dm_mapsize,
	    xs->flags & SCSI_DATA_IN ?
d1158 1
a1158 1
	bus_dmamap_unload(pci->pci_dmat, dmap);
d1171 1
a1171 1
	struct isp_pcisoftc *pci = (struct isp_pcisoftc *)isp;
d1175 1
a1175 1
	    pci_conf_read(pci->pci_pc, pci->pci_tag, PCI_COMMAND_STATUS_REG));
@


1.25
log
@Fix various 2300 (2Gb) last minute errata. Keep up with the jones' for
the target mode code.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.24 2001/09/29 01:23:54 mjacob Exp $	*/
a292 8
#ifdef __HAS_NEW_BUS_DMAMAP_SYNC
#define	isp_bus_dmamap_sync(t, m, o, l, f) \
    bus_dmamap_sync((t), (m), (o), (l), (f))
#else
#define	isp_bus_dmamap_sync(t, m, o, l, f) \
    bus_dmamap_sync((t), (m), (f))
#endif

d1062 1
a1062 1
	isp_bus_dmamap_sync(pci->pci_dmat, dmap, 0, dmap->dm_mapsize,
d1068 1
a1068 1
	isp_bus_dmamap_sync(pci->pci_dmat, pci->pci_rquest_dmap, 0,
d1085 1
a1085 1
		isp_bus_dmamap_sync(p->pci_dmat, p->pci_result_dmap, 0,
d1099 1
a1099 1
	isp_bus_dmamap_sync(pci->pci_dmat, dmap, 0, dmap->dm_mapsize,
@


1.24
log
@If we field an interrupt, return to the caller that we did so. Otherwise,
on some platforms, after a while they'll think it's all spurious and
disconnect the interrupt routing. Thereupon Bad Things Happen (tm).

Approved by: Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.23 2001/09/01 07:16:40 mjacob Exp $	*/
d777 4
@


1.23
log
@Catch up with mainline of code development.

Add support for 2 Gigabit cards (2300/2312). This necessitated a change
in how interrupts are down- the 23XX has not only a different place to check
for an interrupt, but unlike all other QLogic cards, you have to read the
status as a 32 bit word- not 16 bit words. Rather than have device specific
functions as called from the core module (in isp_intr), it makes more sense
to have the platform/bus modules do the gruntwork of splitting out the
isr, semaphore register and the first outgoing mailbox register (if needed)
*prior* to calling isp_intr (if calling isp_intr is necessary at all).

Rearchitect how regular SCSI parameters are stored or used.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.22 2001/08/26 03:32:22 jason Exp $	*/
d1094 1
a1094 1
		return (0);
@


1.22
log
@Yup, I managed to fat finger all three of these while doing bus_dmamap_sync()
conversion (luckily only sparc64 uses the 5 arg form so far =)
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.21 2001/08/25 14:52:57 jason Exp $	*/
d49 6
d70 1
d108 7
d117 1
d133 1
d149 1
d165 1
d180 1
d193 15
d240 8
d268 6
d356 5
d562 16
d704 103
d812 1
a812 1
	int offset, oldconf = 0;
d818 5
a822 7
		oldconf = isp_pci_rd_reg(isp, BIU_CONF1);
		isp_pci_wr_reg(isp, BIU_CONF1, oldconf | BIU_PCI_CONF1_SXP);
		delay(250);
	}
	offset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];
	offset += (regoff & 0xff);
	rv = bus_space_read_2(pcs->pci_st, pcs->pci_sh, offset);
d824 1
a824 2
		isp_pci_wr_reg(isp, BIU_CONF1, oldconf);
		delay(250);
d833 1
a833 1
	int offset, oldconf = 0;
d839 5
a843 7
		oldconf = isp_pci_rd_reg(isp, BIU_CONF1);
		isp_pci_wr_reg(isp, BIU_CONF1, oldconf | BIU_PCI_CONF1_SXP);
		delay(250);
	}
	offset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];
	offset += (regoff & 0xff);
	bus_space_write_2(pcs->pci_st, pcs->pci_sh, offset, val);
d845 1
a845 2
		isp_pci_wr_reg(isp, BIU_CONF1, oldconf);
		delay(250);
a854 1
	int offset;
d862 5
a866 8
		oc = isp_pci_rd_reg(isp, BIU_CONF1);
		tc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);
		if (IS_12X0(isp)) {
			if (regoff & SXP_BANK1_SELECT)
				tc |= BIU_PCI1080_CONF1_SXP0;
			else
				tc |= BIU_PCI1080_CONF1_SXP1;
		} else {
d868 1
a868 3
		}
		isp_pci_wr_reg(isp, BIU_CONF1, tc);
		delay(250);
d870 5
a874 7
		oc = isp_pci_rd_reg(isp, BIU_CONF1);
		isp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);
		delay(250);
	}
	offset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];
	offset += (regoff & 0xff);
	rv = bus_space_read_2(pcs->pci_st, pcs->pci_sh, offset);
d876 1
a876 2
		isp_pci_wr_reg(isp, BIU_CONF1, oc);
		delay(250);
a883 1
	u_int16_t oc = 0;
d885 1
a885 1
	int offset;
d893 5
a897 8
		oc = isp_pci_rd_reg(isp, BIU_CONF1);
		tc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);
		if (IS_12X0(isp)) {
			if (regoff & SXP_BANK1_SELECT)
				tc |= BIU_PCI1080_CONF1_SXP0;
			else
				tc |= BIU_PCI1080_CONF1_SXP1;
		} else {
d899 1
a899 3
		}
		isp_pci_wr_reg(isp, BIU_CONF1, tc);
		delay(250);
d901 5
a905 7
		oc = isp_pci_rd_reg(isp, BIU_CONF1);
		isp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);
		delay(250);
	}
	offset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];
	offset += (regoff & 0xff);
	bus_space_write_2(pcs->pci_st, pcs->pci_sh, offset, val);
d907 1
a907 2
		isp_pci_wr_reg(isp, BIU_CONF1, oc);
		delay(250);
d1080 1
a1080 1
	int r;
d1084 12
a1095 7
	isp_bus_dmamap_sync(p->pci_dmat, p->pci_result_dmap, 0,
	    p->pci_result_dmap->dm_mapsize, BUS_DMASYNC_POSTREAD);

	isp->isp_osinfo.onintstack = 1;
	r = isp_intr(arg);
	isp->isp_osinfo.onintstack = 0;
	return (r);
@


1.21
log
@deal with 5 arg for of bus_dmamap_sync() if available
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.20 2001/08/25 10:13:29 art Exp $	*/
d925 1
a925 1
	    pci->pci_request_dmap->dm_mapsize, BUS_DMASYNC_PREWRITE);
d937 1
a937 1
	    pcs->pci_result_dmap->dm_mapsize, BUS_DMASYNC_POSTREAD);
@


1.20
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.19 2001/05/16 12:51:49 ho Exp $	*/
d245 7
d918 2
a919 1
	bus_dmamap_sync(pci->pci_dmat, dmap, (xs->flags & SCSI_DATA_IN) ?
d924 2
a925 2
	bus_dmamap_sync(pci->pci_dmat, pci->pci_rquest_dmap,
	    BUS_DMASYNC_PREWRITE);
d936 2
a937 1
	bus_dmamap_sync(p->pci_dmat, p->pci_result_dmap, BUS_DMASYNC_POSTREAD);
d950 2
a951 1
	bus_dmamap_sync(pci->pci_dmat, dmap, xs->flags & SCSI_DATA_IN ?
@


1.19
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.18 2001/04/04 22:05:37 mjacob Exp $	*/
d556 1
a556 2
	if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.18
log
@Ansify. Fix botch that kept ISP 1020 firmware from being compiled in.
Handles are 16 bits now.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.17 2001/03/09 17:39:12 nate Exp $	*/
a771 4
	if (isp->isp_xflist == NULL) {
		printf("%s: cannot malloc xflist array\n", isp->isp_name);
		return (1);
	}
a774 4
	if (pci->pci_xfer_dmap == NULL) {
		printf("%s: cannot dma xfer map array\n", isp->isp_name);
		return (1);
	}
@


1.17
log
@On alpha, we want to memory map.  ok mjacob@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.16 2001/03/02 08:58:09 deraadt Exp $	*/
d43 2
a44 2
static u_int16_t isp_pci_rd_reg __P((struct ispsoftc *, int));
static void isp_pci_wr_reg __P((struct ispsoftc *, int, u_int16_t));
d46 2
a47 2
static u_int16_t isp_pci_rd_reg_1080 __P((struct ispsoftc *, int));
static void isp_pci_wr_reg_1080 __P((struct ispsoftc *, int, u_int16_t));
d49 3
a51 3
static int isp_pci_mbxdma __P((struct ispsoftc *));
static int isp_pci_dmasetup __P((struct ispsoftc *, struct scsi_xfer *,
	ispreq_t *, u_int16_t *, u_int16_t));
d53 4
a56 4
isp_pci_dmateardown __P((struct ispsoftc *, struct scsi_xfer *, u_int32_t));
static void isp_pci_reset1 __P((struct ispsoftc *));
static void isp_pci_dumpregs __P((struct ispsoftc *, const char *));
static int isp_pci_intr __P((void *));
d66 1
a66 1
#if	defined(ISP_DISABLE_1020_SUPPORT) || !defined(ISP_COMPILE_1020_FW)
d246 2
a247 2
static int isp_pci_probe __P((struct device *, void *, void *));
static void isp_pci_attach __P((struct device *, struct device *, void *));
d274 1
a274 4
isp_pci_probe(parent, match, aux)
        struct device *parent;
        void *match;
	void *aux; 
d308 1
a308 3
isp_pci_attach(parent, self, aux)
        struct device *parent, *self;
        void *aux;
d630 1
a630 3
isp_pci_rd_reg(isp, regoff)
	struct ispsoftc *isp;
	int regoff;
d655 1
a655 4
isp_pci_wr_reg(isp, regoff, val)
	struct ispsoftc *isp;
	int regoff;
	u_int16_t val;
d679 1
a679 3
isp_pci_rd_reg_1080(isp, regoff)
	struct ispsoftc *isp;
	int regoff;
d719 1
a719 4
isp_pci_wr_reg_1080(isp, regoff, val)
	struct ispsoftc *isp;
	int regoff;
	u_int16_t val;
d759 1
a759 2
isp_pci_mbxdma(isp)
	struct ispsoftc *isp;
d835 2
a836 6
isp_pci_dmasetup(isp, xs, rq, iptrp, optr)
	struct ispsoftc *isp;
	struct scsi_xfer *xs;
	ispreq_t *rq;
	u_int16_t *iptrp;
	u_int16_t optr;
d900 1
a900 1
			printf("%s: Request Queue Overflow++\n", isp->isp_name);
d931 1
a931 2
isp_pci_intr(arg)
	void *arg;
d946 1
a946 4
isp_pci_dmateardown(isp, xs, handle)
	struct ispsoftc *isp;
	struct scsi_xfer *xs;
	u_int32_t handle;
d956 1
a956 2
isp_pci_reset1(isp)
	struct ispsoftc *isp;
d963 1
a963 3
isp_pci_dumpregs(isp, msg)
	struct ispsoftc *isp;
	const char *msg;
@


1.16
log
@print the interrupt, and pack to one line
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.15 2001/02/12 23:42:42 mjacob Exp $	*/
d234 3
d238 1
@


1.15
log
@Sync up with other platforms - use a common string to complain about
lack of parameter memory. Set logging defaults sanely. Set default node
&& port WWNs separate from other platforms. Make sure we set up HBA role
correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.14 2000/10/16 22:45:01 mjacob Exp $	*/
d314 1
a314 1
	static const char nomem[] = "%s: no mem for sdparam table\n";
d383 1
d385 1
d404 1
a404 1
			printf(nomem, isp->isp_name);
d416 1
a416 1
			printf(nomem, isp->isp_name);
d429 1
a429 1
			printf(nomem, isp->isp_name);
d442 1
a442 1
			printf(nomem, isp->isp_name);
d457 1
a457 1
			printf(nomem, isp->isp_name);
d471 1
a471 1
			printf(nomem, isp->isp_name);
d494 1
a494 1
			printf(nomem, isp->isp_name);
d559 1
a559 1
		printf("%s: couldn't map interrupt\n", isp->isp_name);
d569 2
a570 2
		printf("%s: couldn't establish interrupt at %s\n",
			isp->isp_name, intrstr);
d575 1
a575 1
/*	printf("%s: interrupting at %s\n", isp->isp_name, intrstr);*/
@


1.14
log
@quiet these puppies down- this OpenBSD, not some callow system like NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.13 2000/10/16 01:01:58 mjacob Exp $	*/
a57 4
#ifndef	ISP_CODE_ORG
#define	ISP_CODE_ORG		0x1000
#endif

d264 5
d314 1
d402 1
a402 2
			printf("%s: couldn't allocate sdparam table\n",
			       isp->isp_name);
d414 1
a414 2
			printf("%s: couldn't allocate sdparam table\n",
			       isp->isp_name);
d427 1
a427 2
			printf("%s: couldn't allocate sdparam table\n",
			       isp->isp_name);
d440 1
a440 2
			printf("%s: couldn't allocate sdparam table\n",
			       isp->isp_name);
d455 1
a455 2
			printf("%s: couldn't allocate sdparam table\n",
			       isp->isp_name);
d469 1
a469 2
			printf("%s: couldn't allocate fcparam table\n",
			       isp->isp_name);
a474 1

d492 1
a492 2
			printf("%s: couldn't allocate fcparam table\n",
			       isp->isp_name);
d501 24
a553 14
	/*
	 * Set up logging levels.
	 */
#ifdef	ISP_LOGDEFAULT
	isp->isp_dblev = ISP_LOGDEFAULT;
#else
	isp->isp_dblev = ISP_LOGWARN|ISP_LOGERR;
#ifdef	SCSIDEBUG
	isp->isp_dblev |= ISP_LOGDEBUG1|ISP_LOGDEBUG2;
#endif
#ifdef	DEBUG
	isp->isp_dblev |= ISP_LOGDEBUG0|ISP_LOGCONFIG|ISP_LOGINFO;
#endif
#endif
a554 9
#ifdef DEBUG
	if (oneshot) {
		oneshot = 0;
		printf("Qlogic ISP Driver, OpenBSD (pci) Platform Version "
		    "%d.%d Core Version %d.%d\n",
		    ISP_PLATFORM_VERSION_MAJOR, ISP_PLATFORM_VERSION_MINOR,
		    ISP_CORE_VERSION_MAJOR, ISP_CORE_VERSION_MINOR);
	}
#endif
d572 2
a573 1
	isp_prt(isp, ISP_LOGCONFIG, "interrupting at %s", intrstr);
d576 2
a577 2
		DEFAULT_NODEWWN(isp) = 0x400000007F000002;
		DEFAULT_PORTWWN(isp) = 0x400000007F000002;
d580 3
a583 1
	ISP_LOCK(isp);
d586 1
a587 1
		ISP_UNLOCK(isp);
@


1.13
log
@Update OpenBSD with respect to Solaris/FreeBSD/NetBSD/Linux versions.

Major rewrite of a lot of internals- far too many to list. Cleaner
locking, more paramaterization, an isp_prt logging function that
handles debugging as well as error printouts. We also should no
longer hang if there is no Loop for Fibre Channel when booting.

The file ispvar.h now contains a list of all platform required macros
and explanation as to what they're for. This should make maintenance
easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.12 2000/07/06 05:11:26 mjacob Exp $	*/
d542 1
a542 1
	isp->isp_dblev = ISP_LOGCONFIG|ISP_LOGWARN|ISP_LOGERR;
d547 1
a547 4
	isp->isp_dblev |= ISP_LOGDEBUG0;
#endif
#ifdef	DIAGNOSTIC
	isp->isp_dblev |= ISP_LOGINFO;
d577 1
a577 1
	printf("%s: interrupting at %s\n", isp->isp_name, intrstr);
@


1.12
log
@Use new isp_handle_index function. Pull in f/w from separate files.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.11 2000/02/20 21:16:35 mjacob Exp $	*/
d55 1
a55 1
static void isp_pci_dumpregs __P((struct ispsoftc *));
d115 1
a115 1
	ISP_1040_RISC_CODE, 0, ISP_CODE_ORG, 0,
d130 1
a130 1
	ISP_1080_RISC_CODE, 0, ISP_CODE_ORG, 0,
d145 1
a145 1
	ISP_12160_RISC_CODE, 0, ISP_CODE_ORG, 0,
d160 1
a160 1
	ISP_2100_RISC_CODE, 0, ISP_CODE_ORG
d174 1
a174 1
	ISP_2200_RISC_CODE, 0, ISP_CODE_ORG
d321 1
a321 1
	int ioh_valid, memh_valid, i, s;
d536 17
d583 2
a584 12
		long foo;
		/*
		 * This isn't very random, but it's the best we can do for
		 * the real edge case of cards that don't have WWNs.
		 */
		foo = (long) isp;
		foo >>= 4;
		foo &= 0x7;
		while (version[foo])
			isp->isp_osinfo.seed += (int) version[foo++];
		isp->isp_osinfo.seed <<= 8;
		isp->isp_osinfo.seed += (isp->isp_osinfo._dev.dv_unit + 1);
d587 2
a588 1
	s = splbio();
d592 1
a592 1
		(void) splx(s);
d595 1
d599 1
a600 1
		(void) splx(s);
d613 1
a614 1
			(void) splx(s);
a618 1
	ENABLE_INTS(isp);
d626 1
d628 2
a630 1
	(void) splx(s);
d785 2
a786 2
	len = isp->isp_maxcmds * sizeof (ISP_SCSI_XFER_T);
	isp->isp_xflist = (ISP_SCSI_XFER_T **) malloc(len, M_DEVBUF, M_WAITOK);
d802 1
a802 1
	len = ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN);
d818 1
a818 1
	len = ISP_QUEUE_SIZE(RESULT_QUEUE_LEN);
d917 1
a917 1
		*iptrp = ISP_NXT_QENTRY(*iptrp, RQUEST_QUEUE_LEN);
d953 10
a962 4
	struct isp_pcisoftc *pci = (struct isp_pcisoftc *)arg;
	bus_dmamap_sync(pci->pci_dmat, pci->pci_result_dmap,
	    BUS_DMASYNC_POSTREAD);
	return (isp_intr(arg));
d987 1
a987 1
isp_pci_dumpregs(isp)
d989 1
d992 3
a994 1
	printf("%s: PCI Status Command/Status=%x\n", pci->pci_isp.isp_name,
@


1.11
log
@Add 12160 (Ultra3) support. Handle case of Extended CMD CDBs (cdbs with
more than 12 byte) for parallel SCSI.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.10 1999/12/16 05:19:50 mjacob Exp $	*/
a37 1
#include <dev/microcode/isp/asm_pci.h>
d45 1
a45 1
#if !defined(ISP_DISABLE_1080_SUPPORT) && !defined(ISP_DISABLE_12160_SUPPORT)
d61 10
a70 1
#ifndef	ISP_1040_RISC_CODE
d72 3
d76 2
a77 1
#ifndef	ISP_1080_RISC_CODE
d79 3
d83 2
a84 1
#ifndef	ISP_12160_RISC_CODE
d86 3
d90 2
a91 1
#ifndef	ISP_2100_RISC_CODE
d93 3
d97 2
a98 1
#ifndef	ISP_2200_RISC_CODE
d100 3
a104 1

d610 2
d676 1
a676 1
#if !defined(ISP_DISABLE_1080_SUPPORT) && !defined(ISP_DISABLE_12160_SUPPORT)
d848 1
a848 1
	bus_dmamap_t dmap = pci->pci_xfer_dmap[rq->req_handle - 1];
d852 2
a857 1
	assert(rq->req_handle != 0 && rq->req_handle <= isp->isp_maxcmds);
d906 2
a907 3
		crq = (ispcontreq_t *)
			ISP_QUEUE_ENTRY(isp->isp_rquest, *iptrp);
		*iptrp = (*iptrp + 1) & (RQUEST_QUEUE_LEN - 1);
d912 1
a912 1
			return (CMD_COMPLETE);
d956 1
a956 3
	bus_dmamap_t dmap;
	assert(handle != 0 && handle <= isp->isp_maxcmds);
	dmap = pci->pci_xfer_dmap[handle-1];
@


1.10
log
@Add in Qlogic 1240 (Dual Ultra) and Qlogic 1280 (Dual Ultra 2) support.
Other than some extra cases, there's a bit of hoohah about reading the
second SXP's register bank on the 1280- not exactly well laid out
hardware. The delay(250) functions added to see if this helps in more
stable reads of SXP register bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.9 1999/11/22 12:52:46 mjacob Exp $	*/
d46 1
a46 1
#ifndef	ISP_DISABLE_1080_SUPPORT
d68 3
d109 15
d172 4
d195 3
d261 4
d424 16
d648 1
a648 1
#ifndef	ISP_DISABLE_1080_SUPPORT
d836 1
a836 1
	if (isp->isp_type & ISP_HA_FC) {
d841 4
a844 1
		seglim = ISP_RQDSEG;
@


1.10.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.11 2000/02/20 21:16:35 mjacob Exp $	*/
d46 1
a46 1
#if !defined(ISP_DISABLE_1080_SUPPORT) && !defined(ISP_DISABLE_12160_SUPPORT)
a67 3
#ifndef	ISP_12160_RISC_CODE
#define	ISP_12160_RISC_CODE	NULL
#endif
a105 15
#ifndef	ISP_DISABLE_12160_SUPPORT
static struct ispmdvec mdvec_12160 = {
	isp_pci_rd_reg_1080,
	isp_pci_wr_reg_1080,
	isp_pci_mbxdma,
	isp_pci_dmasetup,
	isp_pci_dmateardown,
	NULL,
	isp_pci_reset1,
	isp_pci_dumpregs,
	ISP_12160_RISC_CODE, 0, ISP_CODE_ORG, 0,
	BIU_BURST_ENABLE|BIU_PCI_CONF1_FIFO_64
};
#endif

a153 4
#ifndef	PCI_PRODUCT_QLOGIC_ISP12160
#define	PCI_PRODUCT_QLOGIC_ISP12160	0x1216
#endif

a172 3
#define	PCI_QLOGIC_ISP12160	\
	((PCI_PRODUCT_QLOGIC_ISP12160 << 16) | PCI_VENDOR_QLOGIC)

a235 4
#ifndef	ISP_DISABLE_12160_SUPPORT
	case PCI_QLOGIC_ISP12160:
		return (1);
#endif
a394 16
#ifndef	ISP_DISABLE_12160_SUPPORT
	if (pa->pa_id == PCI_QLOGIC_ISP12160) {
		isp->isp_mdvec = &mdvec_12160;
		isp->isp_type = ISP_HA_SCSI_12160;
		isp->isp_param = malloc(2 * sizeof (sdparam),
		    M_DEVBUF, M_NOWAIT);
		if (isp->isp_param == NULL) {
			printf("%s: couldn't allocate sdparam table\n",
			       isp->isp_name);
			return;
		}
		bzero(isp->isp_param, sizeof (sdparam));
		pcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] =
		    ISP1080_DMA_REGS_OFF;
	}
#endif
d603 1
a603 1
#if !defined(ISP_DISABLE_1080_SUPPORT) && !defined(ISP_DISABLE_12160_SUPPORT)
d791 1
a791 1
	if (IS_FC(isp)) {
d796 1
a796 4
		if (XS_CDBLEN(xs) > 12)
			seglim = 0;
		else
			seglim = ISP_RQDSEG;
@


1.10.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.18 2001/04/04 22:05:37 mjacob Exp $	*/
d38 1
d44 9
a52 9
static u_int16_t isp_pci_rd_reg(struct ispsoftc *, int);
static void isp_pci_wr_reg(struct ispsoftc *, int, u_int16_t);
#if !(defined(ISP_DISABLE_1080_SUPPORT) && defined(ISP_DISABLE_12160_SUPPORT))
static u_int16_t isp_pci_rd_reg_1080(struct ispsoftc *, int);
static void isp_pci_wr_reg_1080(struct ispsoftc *, int, u_int16_t);
#endif
static int isp_pci_mbxdma(struct ispsoftc *);
static int isp_pci_dmasetup(struct ispsoftc *, struct scsi_xfer *,
	ispreq_t *, u_int16_t *, u_int16_t);
d54 7
a60 11
isp_pci_dmateardown (struct ispsoftc *, struct scsi_xfer *, u_int16_t);
static void isp_pci_reset1 (struct ispsoftc *);
static void isp_pci_dumpregs (struct ispsoftc *, const char *);
static int isp_pci_intr (void *);

#ifdef	ISP_COMPILE_FW
#define	ISP_COMPILE_1040_FW	1
#define	ISP_COMPILE_1080_FW	1
#define	ISP_COMPILE_12160_FW	1
#define	ISP_COMPILE_2100_FW	1
#define	ISP_COMPILE_2200_FW	1
d62 1
a62 2

#if	defined(ISP_DISABLE_1040_SUPPORT) || !defined(ISP_COMPILE_1040_FW)
a63 3
#else
#define	ISP_1040_RISC_CODE	isp_1040_risc_code
#include <dev/microcode/isp/asm_1040.h>
d65 1
a65 2

#if	defined(ISP_DISABLE_1080_SUPPORT) || !defined(ISP_COMPILE_1080_FW)
a66 3
#else
#define	ISP_1080_RISC_CODE	isp_1080_risc_code
#include <dev/microcode/isp/asm_1080.h>
d68 1
a68 2

#if	defined(ISP_DISABLE_12160_SUPPORT) || !defined(ISP_COMPILE_12160_FW)
a69 3
#else
#define	ISP_12160_RISC_CODE	isp_12160_risc_code
#include <dev/microcode/isp/asm_12160.h>
d71 1
a71 2

#if	defined(ISP_DISABLE_2100_SUPPORT) || !defined(ISP_COMPILE_2100_FW)
a72 3
#else
#define	ISP_2100_RISC_CODE	isp_2100_risc_code
#include <dev/microcode/isp/asm_2100.h>
d74 1
a74 2

#if	defined(ISP_DISABLE_2200_SUPPORT) || !defined(ISP_COMPILE_2200_FW)
a75 3
#else
#define	ISP_2200_RISC_CODE	isp_2200_risc_code
#include <dev/microcode/isp/asm_2200.h>
d78 1
d89 1
a89 1
	ISP_1040_RISC_CODE,
d104 1
a104 1
	ISP_1080_RISC_CODE,
d119 1
a119 1
	ISP_12160_RISC_CODE,
d134 1
a134 1
	ISP_2100_RISC_CODE
d148 1
a148 1
	ISP_2200_RISC_CODE
a211 3
#ifdef __alpha__
#define SCSI_ISP_PREFER_MEM_MAP 1
#else
a213 1
#endif
d220 2
a221 2
static int isp_pci_probe (struct device *, void *, void *);
static void isp_pci_attach (struct device *, struct device *, void *);
a241 5
#ifdef  DEBUG
const char vstring[] =
    "Qlogic ISP Driver, NetBSD (pci) Platform Version %d.%d Core Version %d.%d";
#endif

d243 4
a246 1
isp_pci_probe(struct device *parent, void *match, void *aux)
d280 3
a282 1
isp_pci_attach(struct device *parent, struct device *self, void *aux)
a286 1
	static const char nomem[] = ": no mem for sdparam table\n";
d295 1
a295 1
	int ioh_valid, memh_valid, i;
a354 1
#if 0
a355 1
#endif
d374 2
a375 1
			printf(nomem);
d387 2
a388 1
			printf(nomem);
d401 2
a402 1
			printf(nomem);
d415 2
a416 1
			printf(nomem);
d431 2
a432 1
			printf(nomem);
d446 2
a447 1
			printf(nomem);
d453 1
d471 2
a472 1
			printf(nomem);
a480 24
	/*
	 * Set up logging levels.
	 */
#ifdef	ISP_LOGDEFAULT
	isp->isp_dblev = ISP_LOGDEFAULT;
#else
	isp->isp_dblev = ISP_LOGWARN|ISP_LOGERR;
#ifdef	SCSIDEBUG
	isp->isp_dblev |= ISP_LOGDEBUG1|ISP_LOGDEBUG2;
#endif
#ifdef	DEBUG
	isp->isp_dblev |= ISP_LOGDEBUG0|ISP_LOGCONFIG|ISP_LOGINFO;
#endif
#endif

#ifdef	DEBUG
	if (oneshot) {
		oneshot = 0;
		isp_prt(isp, ISP_LOGCONFIG, vstring,
		    ISP_PLATFORM_VERSION_MAJOR, ISP_PLATFORM_VERSION_MINOR,
		    ISP_CORE_VERSION_MAJOR, ISP_CORE_VERSION_MINOR);
	}
#endif

d511 9
d522 1
a522 1
		printf(": couldn't map interrupt\n");
d532 2
a533 2
		printf(": couldn't establish interrupt at %s\n",
			intrstr);
d537 1
a537 2

	printf(": %s\n", intrstr);
d540 12
a551 2
		DEFAULT_NODEWWN(isp) = 0x400000007F000003;
		DEFAULT_PORTWWN(isp) = 0x400000007F000003;
d554 1
a554 4
	isp->isp_confopts = self->dv_cfdata->cf_flags;
	isp->isp_role = ISP_DEFAULT_ROLES;
	ISP_LOCK(isp);
	isp->isp_osinfo.no_mbox_ints = 1;
a556 1
		ISP_UNLOCK(isp);
d558 1
a560 1
	ENABLE_INTS(isp);
a563 1
		ISP_UNLOCK(isp);
d565 1
a577 1
			ISP_UNLOCK(isp);
d579 1
a583 1

a589 1
		ISP_UNLOCK(isp);
a590 2
	} else {
		ISP_UNLOCK(isp);
d592 1
d596 3
a598 1
isp_pci_rd_reg(struct ispsoftc *isp, int regoff)
d623 4
a626 1
isp_pci_wr_reg(struct ispsoftc *isp, int regoff, u_int16_t val)
d648 1
a648 1
#if !(defined(ISP_DISABLE_1080_SUPPORT) && defined(ISP_DISABLE_12160_SUPPORT))
d650 3
a652 1
isp_pci_rd_reg_1080(struct ispsoftc *isp, int regoff)
d692 4
a695 1
isp_pci_wr_reg_1080(struct ispsoftc *isp, int regoff, u_int16_t val)
d735 2
a736 1
isp_pci_mbxdma(struct ispsoftc *isp)
d747 2
a748 2
	len = isp->isp_maxcmds * sizeof (XS_T);
	isp->isp_xflist = (XS_T **) malloc(len, M_DEVBUF, M_WAITOK);
d764 1
a764 1
	len = ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp));
d780 1
a780 1
	len = ISP_QUEUE_SIZE(RESULT_QUEUE_LEN(isp));
d812 6
a817 2
isp_pci_dmasetup(struct ispsoftc *isp, XS_T *xs, ispreq_t *rq, u_int16_t *iptrp,
	u_int16_t optr)
d820 1
a820 1
	bus_dmamap_t dmap;
a823 2
	dmap = pci->pci_xfer_dmap[isp_handle_index(rq->req_handle)];

d828 1
d877 3
a879 2
		crq = (ispcontreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, *iptrp);
		*iptrp = ISP_NXT_QENTRY(*iptrp, RQUEST_QUEUE_LEN(isp));
d881 1
a881 1
			isp_prt(isp, ISP_LOGDEBUG0, "Request Queue Overflow++");
d884 1
a884 1
			return (CMD_EAGAIN);
d912 2
a913 1
isp_pci_intr(void *arg)
d915 4
a918 10
	int r;
	struct ispsoftc *isp = (struct ispsoftc *)arg;
	struct isp_pcisoftc *p = (struct isp_pcisoftc *)isp;

	bus_dmamap_sync(p->pci_dmat, p->pci_result_dmap, BUS_DMASYNC_POSTREAD);

	isp->isp_osinfo.onintstack = 1;
	r = isp_intr(arg);
	isp->isp_osinfo.onintstack = 0;
	return (r);
d922 4
a925 1
isp_pci_dmateardown(struct ispsoftc *isp, XS_T *xs, u_int16_t handle)
d928 3
a930 1
	bus_dmamap_t dmap = pci->pci_xfer_dmap[isp_handle_index(handle)];
d937 2
a938 1
isp_pci_reset1(struct ispsoftc *isp)
d945 2
a946 1
isp_pci_dumpregs(struct ispsoftc *isp, const char *msg)
d949 1
a949 3
	if (msg)
                isp_prt(isp, ISP_LOGERR, "%s", msg);
	isp_prt(isp, ISP_LOGERR, "PCI Status Command/Status=%x\n",
@


1.10.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.10.2.2 2001/05/14 22:25:50 niklas Exp $	*/
d772 4
d779 4
@


1.10.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.10.2.3 2001/07/04 10:42:37 niklas Exp $	*/
a48 6
static int
isp_pci_rd_isr(struct ispsoftc *, u_int16_t *, u_int16_t *, u_int16_t *);
#ifndef	ISP_DISABLE_2300_SUPPORT
static int
isp_pci_rd_isr_2300(struct ispsoftc *, u_int16_t *, u_int16_t *, u_int16_t *);
#endif
a63 1
#define	ISP_COMPILE_2300_FW	1
a100 7
#if	defined(ISP_DISABLE_2300_SUPPORT) || !defined(ISP_COMPILE_2300_FW)
#define	ISP_2300_RISC_CODE	NULL
#else
#define	ISP_2300_RISC_CODE	isp_2300_risc_code
#include <dev/microcode/isp/asm_2300.h>
#endif

a102 1
	isp_pci_rd_isr,
a117 1
	isp_pci_rd_isr,
a132 1
	isp_pci_rd_isr,
a147 1
	isp_pci_rd_isr,
a161 1
	isp_pci_rd_isr,
a173 15
#ifndef	ISP_DISABLE_2300_SUPPORT
static struct ispmdvec mdvec_2300 = {
	isp_pci_rd_isr_2300,
	isp_pci_rd_reg,
	isp_pci_wr_reg,
	isp_pci_mbxdma,
	isp_pci_dmasetup,
	isp_pci_dmateardown,
	NULL,
	isp_pci_reset1,
	isp_pci_dumpregs,
	ISP_2300_RISC_CODE
};
#endif

a205 8
#ifndef	PCI_PRODUCT_QLOGIC_ISP2300
#define	PCI_PRODUCT_QLOGIC_ISP2300	0x2300
#endif

#ifndef	PCI_PRODUCT_QLOGIC_ISP2312
#define	PCI_PRODUCT_QLOGIC_ISP2312	0x2312
#endif

a225 6
#define	PCI_QLOGIC_ISP2300	\
	((PCI_PRODUCT_QLOGIC_ISP2300 << 16) | PCI_VENDOR_QLOGIC)

#define	PCI_QLOGIC_ISP2312	\
	((PCI_PRODUCT_QLOGIC_ISP2312 << 16) | PCI_VENDOR_QLOGIC)

a244 7
#ifdef __HAS_NEW_BUS_DMAMAP_SYNC
#define	isp_bus_dmamap_sync(t, m, o, l, f) \
    bus_dmamap_sync((t), (m), (o), (l), (f))
#else
#define	isp_bus_dmamap_sync(t, m, o, l, f) \
    bus_dmamap_sync((t), (m), (f))
#endif
a300 5
#ifndef	ISP_DISABLE_2300_SUPPORT
	case PCI_QLOGIC_ISP2300:
	case PCI_QLOGIC_ISP2312:
		return (1);
#endif
a501 16
#ifndef	ISP_DISABLE_2300_SUPPORT
	if (pa->pa_id == PCI_QLOGIC_ISP2300 ||
	    pa->pa_id == PCI_QLOGIC_ISP2312) {
		isp->isp_mdvec = &mdvec_2300;
		isp->isp_type = ISP_HA_FC_2300;
		isp->isp_param = malloc(sizeof (fcparam), M_DEVBUF, M_NOWAIT);
		if (isp->isp_param == NULL) {
			printf(nomem);
			return;
		}
		bzero(isp->isp_param, sizeof (fcparam));
		pcs->pci_poff[MBOX_BLOCK >> _BLK_REG_SHFT] =
		    PCI_MBOX_REGS2300_OFF;
		data = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG);
	}
#endif
d556 2
a557 1
	if (pci_intr_map(pa, &ih)) {
a628 107
#define	IspVirt2Off(a, x)	\
	(((struct isp_pcisoftc *)a)->pci_poff[((x) & _BLK_REG_MASK) >> \
	_BLK_REG_SHFT] + ((x) & 0xff))

#define	BXR2(pcs, off)		\
	bus_space_read_2(pcs->pci_st, pcs->pci_sh, off)
#define	BXW2(pcs, off, v)	\
	bus_space_write_2(pcs->pci_st, pcs->pci_sh, off, v)


static INLINE int
isp_pci_rd_debounced(struct ispsoftc *isp, int off, u_int16_t *rp)
{
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;
	u_int16_t val0, val1;
	int i = 0;

	do {
		val0 = BXR2(pcs, IspVirt2Off(isp, off));
		val1 = BXR2(pcs, IspVirt2Off(isp, off));
	} while (val0 != val1 && ++i < 1000);
	if (val0 != val1) {
		return (1);
	}
	*rp = val0;
	return (0);
}

static int
isp_pci_rd_isr(struct ispsoftc *isp, u_int16_t *isrp,
    u_int16_t *semap, u_int16_t *mbp)
{
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;
	u_int16_t isr, sema;

	if (IS_2100(isp)) {
		if (isp_pci_rd_debounced(isp, BIU_ISR, &isr)) {
		    return (0);
		}
		if (isp_pci_rd_debounced(isp, BIU_SEMA, &sema)) {
		    return (0);
		}
	} else {
		isr = BXR2(pcs, IspVirt2Off(isp, BIU_ISR));
		sema = BXR2(pcs, IspVirt2Off(isp, BIU_SEMA));
	}
	isp_prt(isp, ISP_LOGDEBUG3, "ISR 0x%x SEMA 0x%x", isr, sema);
	isr &= INT_PENDING_MASK(isp);
	sema &= BIU_SEMA_LOCK;
	if (isr == 0 && sema == 0) {
		return (0);
	}
	*isrp = isr;
	if ((*semap = sema) != 0) {
		if (IS_2100(isp)) {
			if (isp_pci_rd_debounced(isp, OUTMAILBOX0, mbp)) {
				return (0);
			}
		} else {
			*mbp = BXR2(pcs, IspVirt2Off(isp, OUTMAILBOX0));
		}
	}
	return (1);
}

#ifndef	ISP_DISABLE_2300_SUPPORT
static int
isp_pci_rd_isr_2300(struct ispsoftc *isp, u_int16_t *isrp,
    u_int16_t *semap, u_int16_t *mbox0p)
{
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;
	u_int32_t r2hisr;

	if (!(BXR2(pcs, IspVirt2Off(isp, BIU_ISR)) & BIU2100_ISR_RISC_INT)) {
		*isrp = 0;
		return (0);
	}
	r2hisr = bus_space_read_4(pcs->pci_st, pcs->pci_sh,
	    IspVirt2Off(pcs, BIU_R2HSTSLO));
	isp_prt(isp, ISP_LOGDEBUG3, "RISC2HOST ISR 0x%x", r2hisr);
	if ((r2hisr & BIU_R2HST_INTR) == 0) {
		*isrp = 0;
		return (0);
	}
	switch (r2hisr & BIU_R2HST_ISTAT_MASK) {
	case ISPR2HST_ROM_MBX_OK:
	case ISPR2HST_ROM_MBX_FAIL:
	case ISPR2HST_MBX_OK:
	case ISPR2HST_MBX_FAIL:
	case ISPR2HST_ASYNC_EVENT:
	case ISPR2HST_FPOST:
	case ISPR2HST_FPOST_CTIO:
		*isrp = r2hisr & 0xffff;
		*mbox0p = (r2hisr >> 16);
		*semap = 1;
		return (1);
	case ISPR2HST_RSPQ_UPDATE:
		*isrp = r2hisr & 0xffff;
		*mbox0p = 0;
		*semap = 0;
		return (1);
	default:
		return (0);
	}
}
#endif

d634 1
a634 1
	int oldconf = 0;
d640 7
a646 5
		oldconf = BXR2(pcs, IspVirt2Off(isp, BIU_CONF1));
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1),
		    oldconf | BIU_PCI_CONF1_SXP);
	}
	rv = BXR2(pcs, IspVirt2Off(isp, regoff));
d648 2
a649 1
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1), oldconf);
d658 1
a658 1
	int oldconf = 0;
d664 7
a670 5
		oldconf = BXR2(pcs, IspVirt2Off(isp, BIU_CONF1));
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1),
		    oldconf | BIU_PCI_CONF1_SXP);
	}
	BXW2(pcs, IspVirt2Off(isp, regoff), val);
d672 2
a673 1
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1), oldconf);
d683 1
d691 8
a698 5
		oc = BXR2(pcs, IspVirt2Off(isp, BIU_CONF1));
		tc = oc & ~BIU_PCI1080_CONF1_DMA;
		if (regoff & SXP_BANK1_SELECT)
			tc |= BIU_PCI1080_CONF1_SXP1;
		else
d700 3
a702 1
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1), tc);
d704 7
a710 5
		oc = BXR2(pcs, IspVirt2Off(isp, BIU_CONF1));
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1), 
		    oc | BIU_PCI1080_CONF1_DMA);
	}
	rv = BXR2(pcs, IspVirt2Off(isp, regoff));
d712 2
a713 1
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1), oc);
d721 1
d723 1
a723 1
	int oc = 0;
d731 8
a738 5
		oc = BXR2(pcs, IspVirt2Off(isp, BIU_CONF1));
		tc = oc & ~BIU_PCI1080_CONF1_DMA;
		if (regoff & SXP_BANK1_SELECT)
			tc |= BIU_PCI1080_CONF1_SXP1;
		else
d740 3
a742 1
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1), tc);
d744 7
a750 5
		oc = BXR2(pcs, IspVirt2Off(isp, BIU_CONF1));
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1), 
		    oc | BIU_PCI1080_CONF1_DMA);
	}
	BXW2(pcs, IspVirt2Off(isp, regoff), val);
d752 2
a753 1
		BXW2(pcs, IspVirt2Off(isp, BIU_CONF1), oc);
d912 1
a912 2
	isp_bus_dmamap_sync(pci->pci_dmat, dmap, 0, dmap->dm_mapsize,
	    (xs->flags & SCSI_DATA_IN) ?
d917 2
a918 2
	isp_bus_dmamap_sync(pci->pci_dmat, pci->pci_rquest_dmap, 0,
	    pci->pci_rquest_dmap->dm_mapsize, BUS_DMASYNC_PREWRITE);
d925 1
a925 1
	u_int16_t isr, sema, mbox;
d929 6
a934 12
	isp->isp_intcnt++;
	if (ISP_READ_ISR(isp, &isr, &sema, &mbox) == 0) {
		isp->isp_intbogus++;
		return (0);
	} else {
		isp_bus_dmamap_sync(p->pci_dmat, p->pci_result_dmap, 0,
		    p->pci_result_dmap->dm_mapsize, BUS_DMASYNC_POSTREAD);
		isp->isp_osinfo.onintstack = 1;
		isp_intr(isp, isr, sema, mbox);
		isp->isp_osinfo.onintstack = 0;
		return (1);
	}
d942 1
a942 2
	isp_bus_dmamap_sync(pci->pci_dmat, dmap, 0, dmap->dm_mapsize,
	    xs->flags & SCSI_DATA_IN ?
@


1.10.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d293 8
d1070 1
a1070 1
	bus_dmamap_sync(pci->pci_dmat, dmap, 0, dmap->dm_mapsize,
d1076 1
a1076 1
	bus_dmamap_sync(pci->pci_dmat, pci->pci_rquest_dmap, 0,
d1093 1
a1093 1
		bus_dmamap_sync(p->pci_dmat, p->pci_result_dmap, 0,
d1107 1
a1107 1
	bus_dmamap_sync(pci->pci_dmat, dmap, 0, dmap->dm_mapsize,
@


1.10.2.6
log
@Merge in trunk
@
text
@d302 4
d374 1
a374 1
	int ioh_valid, memh_valid;
d440 1
a593 1
	isp->isp_dmatag = pa->pa_dmat;
d666 17
d911 2
a912 3
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)isp;
	bus_dma_tag_t dmat = isp->isp_dmatag;
	bus_dma_segment_t sg;
d915 1
a915 1
	int rs, i;
d920 1
a920 1
	len = isp->isp_maxcmds * sizeof (XS_T *);
a921 4
	if (isp->isp_xflist == NULL) {
		isp_prt(isp, ISP_LOGERR, "cannot malloc xflist array");
		return (1);
	}
d924 1
a924 26
	pcs->pci_xfer_dmap = (bus_dmamap_t *) malloc(len, M_DEVBUF, M_WAITOK);
	if (pcs->pci_xfer_dmap == NULL) {
		free(isp->isp_xflist, M_DEVBUF);
		isp->isp_xflist = NULL;
		isp_prt(isp, ISP_LOGERR, "cannot malloc dma map array");
		return (1);
	}

	for (i = 0; i < isp->isp_maxcmds; i++) {
		if (bus_dmamap_create(dmat, MAXPHYS, (MAXPHYS / NBPG) + 1,
		    MAXPHYS, 0, BUS_DMA_NOWAIT, &pcs->pci_xfer_dmap[i])) {
			isp_prt(isp, ISP_LOGERR, "cannot create dma maps");
			break;
		}
	}

	if (i < isp->isp_maxcmds) {
		while (--i >= 0) {
			bus_dmamap_destroy(dmat, pcs->pci_xfer_dmap[i]);
		}
		free(isp->isp_xflist, M_DEVBUF);
		free(pcs->pci_xfer_dmap, M_DEVBUF);
		isp->isp_xflist = NULL;
		pcs->pci_xfer_dmap = NULL;
		return (1);
	}
d930 9
a938 6
	if (bus_dmamem_alloc(dmat, len, PAGE_SIZE, 0, &sg, 1, &rs,
			     BUS_DMA_NOWAIT) ||
	    bus_dmamem_map(isp->isp_dmatag, &sg, rs, len,
	    (caddr_t *)&isp->isp_rquest, BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) {
		goto dmafail;
	}
d940 1
a940 7
	if (bus_dmamap_create(dmat, len, 1, len, 0, BUS_DMA_NOWAIT,
	    &isp->isp_rqdmap) || bus_dmamap_load(dmat, isp->isp_rqdmap,
	    (caddr_t)isp->isp_rquest, len, NULL,
	    BUS_DMA_NOWAIT)) {
		goto dmafail;
	}
	isp->isp_rquest_dma = isp->isp_rqdmap->dm_segs[0].ds_addr;
d946 10
a955 13
	if (bus_dmamem_alloc(dmat, len, PAGE_SIZE, 0, &sg, 1, &rs,
			     BUS_DMA_NOWAIT) ||
	    bus_dmamem_map(dmat, &sg, rs, len, (caddr_t *)&isp->isp_result,
	    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) {
		goto dmafail;
	}
	if (bus_dmamap_create(dmat, len, 1, len, 0, BUS_DMA_NOWAIT,
	    &isp->isp_rsdmap) || bus_dmamap_load(isp->isp_dmatag,
	    isp->isp_rsdmap, (caddr_t)isp->isp_result, len, NULL,
	    BUS_DMA_NOWAIT)) {
		goto dmafail;
	}
	isp->isp_result_dma = isp->isp_rsdmap->dm_segs[0].ds_addr;
d963 10
a972 13
	if (bus_dmamem_alloc(dmat, len, PAGE_SIZE, 0, &sg, 1, &rs,
			     BUS_DMA_NOWAIT) ||
	    bus_dmamem_map(dmat, &sg, rs, len, (caddr_t *)&fcp->isp_scratch,
	    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) {
		goto dmafail;
	}
	if (bus_dmamap_create(dmat, len, 1, len, 0, BUS_DMA_NOWAIT,
	    &isp->isp_scdmap) || bus_dmamap_load(dmat,
	    isp->isp_scdmap, (caddr_t)fcp->isp_scratch, len, NULL,
	    BUS_DMA_NOWAIT)) {
		goto dmafail;
	}
	fcp->isp_scdma = isp->isp_scdmap->dm_segs[0].ds_addr;
a973 10
dmafail:
	isp_prt(isp, ISP_LOGERR, "mailbox dma setup failure");
	for (i = 0; i < isp->isp_maxcmds; i++) {
		bus_dmamap_destroy(dmat, pcs->pci_xfer_dmap[i]);
	}
	free(isp->isp_xflist, M_DEVBUF);
	free(pcs->pci_xfer_dmap, M_DEVBUF);
	isp->isp_xflist = NULL;
	pcs->pci_xfer_dmap = NULL;
	return (1);
d977 2
a978 2
isp_pci_dmasetup(struct ispsoftc *isp, XS_T *xs, ispreq_t *rq,
    u_int16_t *nxtip, u_int16_t optr)
d980 1
a980 1
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)isp;
d982 1
a982 2
	u_int16_t starti = isp->isp_reqidx, nxti = *nxtip;
	ispreq_t *qep;
d985 2
a986 2
	qep = (ispreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, starti);
	dmap = pcs->pci_xfer_dmap[isp_handle_index(rq->req_handle)];
a1002 1
		rq->req_flags |= drq;
d1007 1
d1009 2
a1010 2
	error = bus_dmamap_load(isp->isp_dmatag, dmap, xs->data, xs->datalen,
	    NULL, (xs->flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
a1017 4
	isp_prt(isp, ISP_LOGDEBUG2, "%d byte %s %p in %d segs",
	    xs->datalen, (xs->flags & SCSI_DATA_IN)? "read to" :
	    "write from", xs->data, segcnt);

a1032 3
		isp_prt(isp, ISP_LOGDEBUG2, "seg0.[%d]={0x%lx,%lu}",
		    rq->req_seg_count, (long) dmap->dm_segs[seg].ds_addr,
		    (unsigned long) dmap->dm_segs[seg].ds_len);
d1035 1
a1035 1
	if (seg == segcnt) {
a1036 1
	}
d1039 3
a1041 9
		u_int16_t onxti;
		ispcontreq_t *crq, *cqe, local;

		crq = &local;

		cqe = (ispcontreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, nxti);
		onxti = nxti;
		nxti = ISP_NXT_QENTRY(onxti, RQUEST_QUEUE_LEN(isp));
		if (nxti == optr) {
d1043 1
a1043 1
			bus_dmamap_unload(isp->isp_dmatag, dmap);
a1057 4
			isp_prt(isp, ISP_LOGDEBUG2, "seg%d.[%d]={0x%lx,%lu}",
			    rq->req_header.rqs_entry_count - 1,
			    rq->req_seg_count, (long)dmap->dm_segs[seg].ds_addr,
			    (unsigned long) dmap->dm_segs[seg].ds_len);
a1058 2
		isp_put_cont_req(isp, crq, cqe);
		MEMORYBARRIER(isp, SYNC_REQUEST, onxti, QENTRY_LEN);
d1062 3
a1064 3
	bus_dmamap_sync(isp->isp_dmatag, dmap, 0, dmap->dm_mapsize,
	    (xs->flags & SCSI_DATA_IN) ?  BUS_DMASYNC_PREREAD :
	    BUS_DMASYNC_PREWRITE);
d1067 3
a1069 13
	switch (rq->req_header.rqs_entry_type) {
	case RQSTYPE_REQUEST:
		isp_put_request(isp, rq, qep);
		break;
	case RQSTYPE_CMDONLY:
		isp_put_extended_request(isp, (ispextreq_t *)rq,
		    (ispextreq_t *)qep);
		break;
	case RQSTYPE_T2RQS:
		isp_put_request_t2(isp, (ispreqt2_t *) rq, (ispreqt2_t *) qep);
		break;
	}
	*nxtip = nxti;
d1078 1
d1085 2
d1097 4
a1100 4
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)isp;
	bus_dmamap_t dmap = pcs->pci_xfer_dmap[isp_handle_index(handle)];
	bus_dmamap_sync(isp->isp_dmatag, dmap, 0, dmap->dm_mapsize,
	    (xs->flags & SCSI_DATA_IN)?
d1102 1
a1102 1
	bus_dmamap_unload(isp->isp_dmatag, dmap);
d1115 1
a1115 1
	struct isp_pcisoftc *pcs = (struct isp_pcisoftc *)isp;
d1119 1
a1119 1
	    pci_conf_read(pcs->pci_pc, pcs->pci_tag, PCI_COMMAND_STATUS_REG));
@


1.10.2.7
log
@Sync the SMP branch with 3.3
@
text
@d76 1
a76 1
#define	ISP_1040_RISC_CODE	(u_int16_t *) isp_1040_risc_code
d83 1
a83 1
#define	ISP_1080_RISC_CODE	(u_int16_t *) isp_1080_risc_code
d88 1
a88 1
#define	ISP_12160_RISC_CODE	(u_int16_t *) NULL
d90 1
a90 1
#define	ISP_12160_RISC_CODE	(u_int16_t *) isp_12160_risc_code
d97 1
a97 1
#define	ISP_2100_RISC_CODE	(u_int16_t *) isp_2100_risc_code
d104 1
a104 1
#define	ISP_2200_RISC_CODE	(u_int16_t *) isp_2200_risc_code
d111 1
a111 1
#define	ISP_2300_RISC_CODE	(u_int16_t *) isp_2300_risc_code
a227 4
#ifndef	PCI_PRODUCT_QLOGIC_ISP10160
#define	PCI_PRODUCT_QLOGIC_ISP10160	0x1016
#endif

a258 3
#define	PCI_QLOGIC_ISP10160	\
	((PCI_PRODUCT_QLOGIC_ISP10160 << 16) | PCI_VENDOR_QLOGIC)

a272 5
/*
 * Odd case for some AMI raid cards... We need to *not* attach to this.
 */
#define	AMI_RAID_SUBVENDOR_ID	0x101e

d316 6
a321 1
const struct pci_matchid ispdev[] = {
d323 2
a324 1
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP1020 },
d327 4
a330 3
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP1080 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP1240 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP1280 },
d333 2
a334 2
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP10160 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP12160 },
d337 2
a338 1
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2100 },
d341 2
a342 1
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2200 },
d345 3
a347 2
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2300 },
	{ PCI_VENDOR_QLOGIC, PCI_PRODUCT_QLOGIC_ISP2312 },
d349 2
a350 19
	{ 0, 0 }
};

static int
isp_pci_probe(struct device *parent, void *match, void *aux)
{
        struct pci_attach_args *pa = aux;

#ifndef	ISP_DISABLE_12160_SUPPORT
	/*
	 * Sigh. Check for subvendor id match here. Too bad we
	 * can't give an exclude mask in matchbyid.
	 */
        if (pa->pa_id == PCI_QLOGIC_ISP12160) {
		pcireg_t subvid =
		    pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBVEND_0);
		if (subvid == AMI_RAID_SUBVENDOR_ID) {
			return (0);
                }
a351 2
#endif
	return (pci_matchbyid(pa, ispdev, sizeof(ispdev)/sizeof(ispdev[0])));
a496 12
	if (pa->pa_id == PCI_QLOGIC_ISP10160) {
		isp->isp_mdvec = &mdvec_12160;
		isp->isp_type = ISP_HA_SCSI_10160;
		isp->isp_param = malloc(sizeof (sdparam), M_DEVBUF, M_NOWAIT);
		if (isp->isp_param == NULL) {
			printf(nomem);
			return;
		}
		bzero(isp->isp_param, sizeof (sdparam));
		pcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] =
		    ISP1080_DMA_REGS_OFF;
	}
d506 1
a506 1
		bzero(isp->isp_param, 2 * sizeof (sdparam));
d553 1
a553 6
		if (pa->pa_id  == PCI_QLOGIC_ISP2300) {
			isp->isp_type = ISP_HA_FC_2300;
		} else {
			isp->isp_type = ISP_HA_FC_2312;
			isp->isp_port = pa->pa_function;
		}
a595 6
	if (IS_2300(isp)) {	/* per QLogic errata */
		data &= ~PCI_COMMAND_PARITY_ENABLE;
	}
	if (IS_23XX(isp)) {
		isp->isp_touched = 1;
	}
a764 9
		*isrp = r2hisr & 0xffff;
		*mbox0p = (r2hisr >> 16);
		*semap = 1;
		return (1);
	case ISPR2HST_RIO_16:
		*isrp = r2hisr & 0xffff;
		*mbox0p = ASYNC_RIO1;
		*semap = 1;
		return (1);
a765 4
		*isrp = r2hisr & 0xffff;
		*mbox0p = ASYNC_CMD_CMPLT;
		*semap = 1;
		return (1);
d768 1
a768 1
		*mbox0p = ASYNC_CTIO_DONE;
a1165 3
	if (isp->isp_osinfo.no_mbox_ints == 0) {
		ENABLE_INTS(isp);
	}
@


1.10.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d367 1
a367 1
		if (PCI_VENDOR(subvid) == AMI_RAID_SUBVENDOR_ID) {
d684 2
a685 2
		DEFAULT_NODEWWN(isp) = 0x400000007F000003ULL;
		DEFAULT_PORTWWN(isp) = 0x400000007F000003ULL;
@


1.9
log
@Far too many things to note- a complete new revision coming in including
FABRIC support...
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.8 1999/04/04 01:55:45 mjacob Exp $	*/
d150 4
d170 3
d232 2
a233 2
#if	0
	case PCI_QLOGIC_ISP1240:	/* 1240 not ready yet */
a235 1
#endif
d366 28
d565 1
d572 1
d592 1
d599 1
d609 1
a609 1
	u_int16_t rv;
d611 1
a611 1
	int offset, oc = 0;
d613 3
a615 1
	if ((regoff & _BLK_REG_MASK) == SXP_BLOCK) {
d620 11
a630 1
		isp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_SXP);
d634 1
d639 1
a639 2
	if ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||
	    ((regoff & _BLK_REG_MASK) == DMA_BLOCK)) {
d641 1
d652 1
d654 1
a654 1
	int offset, oc = 0;
d656 3
a658 1
	if ((regoff & _BLK_REG_MASK) == SXP_BLOCK) {
d663 11
a673 1
		isp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_SXP);
d677 1
d682 1
a682 2
	if ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||
	    ((regoff & _BLK_REG_MASK) == DMA_BLOCK)) {
d684 1
@


1.8
log
@Roll out changes because the tree is frozen.
@
text
@d1 1
a1 2
/*	$OpenBSD: isp_pci.c,v 1.7 1999/04/04 01:17:02 mjacob Exp $	*/
/* release_4_3_99 */
d52 1
a52 1
	ispreq_t *, u_int8_t *, u_int8_t));
d59 17
d86 2
a87 6
	ISP_RISC_CODE,
	ISP_CODE_LENGTH,
	ISP_CODE_ORG,
	ISP_CODE_VERSION,
	BIU_BURST_ENABLE|BIU_PCI_CONF1_FIFO_64,
	0
d101 2
a102 6
	ISP1080_RISC_CODE,
	ISP1080_CODE_LENGTH,
	ISP1080_CODE_ORG,
	ISP1080_CODE_VERSION,
	BIU_BURST_ENABLE|BIU_PCI_CONF1_FIFO_64,
	0
d116 15
a130 6
	ISP2100_RISC_CODE,
	ISP2100_CODE_LENGTH,
	ISP2100_CODE_ORG,
	ISP2100_CODE_VERSION,
	0,				/* Irrelevant to the 2100 */
	0
d154 4
d169 3
d174 4
a179 1
#ifdef  __alpha__
a180 3
#else
#define SCSI_ISP_PREFER_MEM_MAP 1
#endif
d201 1
a201 1
	bus_dmamap_t		pci_xfer_dmap[MAXISPREQUEST];
d234 4
d252 1
a252 1
	u_int32_t data;
d332 1
d374 26
d402 2
d418 2
a419 1
	 * Make sure that latency timer and cache line size is set sanely.
d428 4
a440 1

a446 1

d460 13
a472 11
	/*
	 * Create the DMA maps for the data transfers.
	 */
	for (i = 0; i < RQUEST_QUEUE_LEN; i++) {
		if (bus_dmamap_create(pcs->pci_dmat, MAXPHYS,
		    (MAXPHYS / NBPG) + 1, MAXPHYS, 0, BUS_DMA_NOWAIT,
		    &pcs->pci_xfer_dmap[i])) {
			printf("%s: can't create dma maps\n", isp->isp_name);
			free(isp->isp_param, M_DEVBUF);
			return;
		}
d475 1
a475 1
	s = splhigh();
d489 16
a623 1

d634 17
d656 1
a656 2
	      BUS_DMA_NOWAIT) ||
	    bus_dmamem_map(pci->pci_dmat, &seg, rseg, len,
d672 1
a672 2
	      BUS_DMA_NOWAIT) ||
	    bus_dmamem_map(pci->pci_dmat, &seg, rseg, len,
d682 1
a682 1
	if (isp->isp_type & ISP_HA_SCSI) {
d689 1
a689 2
		BUS_DMA_NOWAIT) ||
	    bus_dmamem_map(pci->pci_dmat, &seg, rseg, len,
d693 3
a695 3
	      &pci->pci_scratch_dmap) ||
	    bus_dmamap_load(pci->pci_dmat, pci->pci_scratch_dmap,
	      (caddr_t)fcp->isp_scratch, len, NULL, BUS_DMA_NOWAIT))
d706 2
a707 2
	u_int8_t *iptrp;
	u_int8_t optr;
d718 1
a718 6

	if (rq->req_handle > RQUEST_QUEUE_LEN || rq->req_handle < 1) {
		panic("%s: bad handle (%d) in isp_pci_dmasetup\n",
		    isp->isp_name, rq->req_handle);
		/* NOTREACHED */
	}
d768 1
a768 2
			printf("%s: Request Queue Overflow++\n",
			       isp->isp_name);
d792 1
a792 1

d815 3
a817 2
	bus_dmamap_t dmap = pci->pci_xfer_dmap[handle];

@


1.7
log
@Read the board revision and trim cache line size back from 16 to 1
for early revision 2100 boards. Make sure to turn ROM off for these
boards.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_pci.c,v 1.6 1999/03/25 22:58:44 mjacob Exp $	*/
a149 4
#define	PCIR_ROMADDR	0x30

#define	PCI_DFLT_LTNCY	0x40
#define	PCI_DFLT_LNSZ	0x10
d224 1
a224 1
	u_int32_t data, linesz = PCI_DFLT_LNSZ;
a344 11

		data = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG);
		if ((data & 0xff) < 3) {
			/*
			 * XXX: Need to get the actual revision
			 * XXX: number of the 2100 FB. At any rate,
			 * XXX: lower cache line size for early revision
			 * XXX; boards.
			 */
			linesz = 1;
		}
d361 1
a361 2
	 * Make sure that the latency timer, cache line size,
	 * and ROM is disabled.
a368 4

	data = pci_conf_read(pa->pa_pc, pa->pa_tag, PCIR_ROMADDR);
	data &= ~1;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCIR_ROMADDR, data);
@


1.6
log
@roll internal revision levels and enable 1080 support
@
text
@d1 2
a2 2
/*	$OpenBSD: isp_pci.c,v 1.5 1999/03/17 12:53:29 mjacob Exp $	*/
/* release_03_25_99 */
d150 4
d228 1
a228 1
	u_int32_t data;
d349 11
d376 2
a377 1
	 * Make sure that latency timer and cache line size is set sanely.
d385 4
@


1.5
log
@embarrassing typo botch. Thanks to
Federico G. Schwindt <fgsch@@cvs.openbsd.org>
for pointing it out. Fix OpenBSD header per his
suggestion also.
@
text
@d1 2
a2 2
/*	$OpenBSD: isp_pci.c,v 1.4 1999/03/17 05:32:34 mjacob Exp $	*/
/* release_03_16_99 */
@


1.4
log
@complete update of ISP driver- includes 2100 FC support
@
text
@d1 1
a1 1
/* $OpenBSD: $ */
d3 1
@


1.3
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 2
a2 3
/*	$NetBSD: isp_pci.c,v 1.13 1997/06/08 06:34:52 thorpej Exp $	*/

/*
d5 3
a7 2
 * Copyright (c) 1997 by Matthew Jacob 
 * NASA AMES Research Center
d9 1
d34 1
d37 3
a39 10
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/queue.h>
#include <sys/device.h>
#include <machine/bus.h>
#include <machine/intr.h>
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
a42 6
#include <vm/vm.h>

#include <dev/ic/ispreg.h>
#include <dev/ic/ispvar.h>
#include <dev/ic/ispmbox.h>
#include <dev/microcode/isp/asm_pci.h>
d46 4
d53 2
a54 3
static void isp_pci_dmateardown __P((struct ispsoftc *, struct scsi_xfer *,
	u_int32_t));

d56 2
d59 1
d68 1
d72 41
a112 2
	BIU_PCI_CONF1_FIFO_16 | BIU_BURST_ENABLE,
	60	/* MAGIC- all known PCI card implementations are 60MHz */
d114 9
d124 22
a145 2
#define	PCI_QLOGIC_ISP	\
	((PCI_PRODUCT_QLOGIC_ISP1020 << 16) | PCI_VENDOR_QLOGIC)
d150 12
d168 2
d173 1
d176 1
a176 1
	bus_dmamap_t		pci_xfer_dmap[RQUEST_QUEUE_LEN];
d178 1
d188 3
a190 2
        void *match, *aux; 
{       
d193 14
a206 1
	if (pa->pa_id == PCI_QLOGIC_ISP) {
d208 2
a209 1
	} else {
d220 4
d226 1
d231 31
a261 11
	int ioh_valid, memh_valid;
	int i;
#ifdef __OpenBSD__
	bus_addr_t iobase;
	bus_size_t iosize;
#endif

#if 0
	ioh_valid = (pci_mapreg_map(pa, IO_MAP_REG,
	    PCI_MAPREG_TYPE_IO, 0,
	    &iot, &ioh, NULL, NULL) == 0);
d265 7
a271 1
		return;
d273 12
a284 4

	if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &ioh)) {
		printf(": can't map i/o space\n");
		return;
a285 2
	iot = pa->pa_iot;
	ioh_valid = 1;
d287 1
a287 16

#if 0
	memh_valid = (pci_mapreg_map(pa, MEM_MAP_REG,
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,
	    &memt, &memh, NULL, NULL) == 0);
#else
	memh_valid = 0;
#endif

	if (memh_valid) {
		st = memt;
		sh = memh;
	} else if (ioh_valid) {
		st = iot;
		sh = ioh;
	} else {
d291 1
a291 2

	printf(": ");
d296 48
a343 4
	pcs->pci_isp.isp_mdvec = &mdvec;
	isp_reset(&pcs->pci_isp);
	if (pcs->pci_isp.isp_state != ISP_RESETSTATE) {
		return;
d345 31
a375 4
	isp_init(&pcs->pci_isp);
	if (pcs->pci_isp.isp_state != ISP_INITSTATE) {
		isp_uninit(&pcs->pci_isp);
		return;
d377 1
d380 3
a382 3
			 pa->pa_intrline, &ih)) {
		printf(" couldn't map interrupt\n");
		isp_uninit(&pcs->pci_isp);
d389 2
a390 8
#ifndef __OpenBSD__
	pcs->pci_ih =
	  pci_intr_establish(pa->pa_pc, ih, IPL_BIO, isp_intr, &pcs->pci_isp);
#else
	pcs->pci_ih =
	  pci_intr_establish(pa->pa_pc, ih, IPL_BIO, isp_intr, &pcs->pci_isp,
	  pcs->pci_isp.isp_dev.dv_xname);
#endif
d392 3
a394 2
		printf(" couldn't establish interrupt at %s\n");
		isp_uninit(&pcs->pci_isp);
d397 1
a397 1
	printf("%s\n", intrstr);
d406 2
a407 3
			printf("%s: can't create dma maps\n",
			    pcs->pci_isp.isp_name);
			isp_uninit(&pcs->pci_isp);
d412 14
d429 4
a432 3
	isp_attach(&pcs->pci_isp);
	if (pcs->pci_isp.isp_state != ISP_RUNSTATE) {
		isp_uninit(&pcs->pci_isp);
d434 1
a436 5
#define  PCI_BIU_REGS_OFF		0x00
#define	 PCI_MBOX_REGS_OFF		0x70
#define	 PCI_SXP_REGS_OFF		0x80
#define	 PCI_RISC_REGS_OFF		0x80

d442 1
d444 3
a446 7
	int offset;
	if ((regoff & BIU_BLOCK) != 0) {
		offset = PCI_BIU_REGS_OFF;
	} else if ((regoff & MBOX_BLOCK) != 0) {
		offset = PCI_MBOX_REGS_OFF;
	} else if ((regoff & SXP_BLOCK) != 0) {
		offset = PCI_SXP_REGS_OFF;
d448 1
a448 1
		 * XXX
d450 8
a457 3
		panic("SXP Registers not accessible yet!");
	} else {
		offset = PCI_RISC_REGS_OFF;
d459 1
a459 3
	regoff &= 0xff;
	offset += regoff;
	return bus_space_read_2(pcs->pci_st, pcs->pci_sh, offset);
d469 3
a471 7
	int offset;
	if ((regoff & BIU_BLOCK) != 0) {
		offset = PCI_BIU_REGS_OFF;
	} else if ((regoff & MBOX_BLOCK) != 0) {
		offset = PCI_MBOX_REGS_OFF;
	} else if ((regoff & SXP_BLOCK) != 0) {
		offset = PCI_SXP_REGS_OFF;
d473 1
a473 1
		 * XXX
d475 59
a533 3
		panic("SXP Registers not accessible yet!");
	} else {
		offset = PCI_RISC_REGS_OFF;
d535 2
a536 2
	regoff &= 0xff;
	offset += regoff;
d538 4
d543 2
d553 1
d563 1
a563 1
	      (caddr_t *)&isp->isp_rquest, BUS_DMA_NOWAIT|BUS_DMAMEM_NOSYNC))
d580 1
a580 1
	      (caddr_t *)&isp->isp_result, BUS_DMA_NOWAIT|BUS_DMAMEM_NOSYNC))
d587 1
d589 3
a591 1
	isp->isp_result_dma = pci->pci_result_dmap->dm_segs[0].ds_addr;
d593 13
d618 1
a618 1
	bus_dmamap_t dmap = pci->pci_xfer_dmap[rq->req_handle];
d620 1
a620 1
	int segcnt, seg, error, ovseg;
d624 1
a624 2
		rq->req_flags |= REQFLAG_DATA_IN;
		return (0);
d627 2
a628 2
	if (rq->req_handle >= RQUEST_QUEUE_LEN) {
		panic("%s: bad handle (%d) in isp_pci_dmasetup",
d634 1
a634 1
		rq->req_flags |= REQFLAG_DATA_IN;
d636 1
a636 1
		rq->req_flags |= REQFLAG_DATA_OUT;
d639 8
d649 4
a652 2
	if (error)
		return (error);
d657 14
a670 6
	    seg < segcnt && rq->req_seg_count < ISP_RQDSEG;
	    seg++, rq->req_seg_count++) {
		rq->req_dataseg[rq->req_seg_count].ds_count =
		    dmap->dm_segs[seg].ds_len;
		rq->req_dataseg[rq->req_seg_count].ds_base =
		    dmap->dm_segs[seg].ds_addr;
d674 1
a674 1
		goto mapsync;
d677 2
a678 2
		crq = (ispcontreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest,
		    *iptrp);
d684 2
a685 1
			return (EFBIG);
d701 2
a702 2
 mapsync:
	bus_dmamap_sync(pci->pci_dmat, dmap, xs->flags & SCSI_DATA_IN ?
d704 16
a719 1
	return (0);
a732 1

d742 9
@


1.2
log
@pretty
@
text
@d361 1
a361 1
		panic("%s: bad handle (%d) in isp_pci_dmasetup\n",
@


1.1
log
@add isp driver from netbsd, more munging needed
@
text
@d214 1
a214 1
	printf(" %s\n", intrstr);
@

