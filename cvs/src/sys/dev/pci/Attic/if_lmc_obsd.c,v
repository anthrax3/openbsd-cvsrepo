head	1.26;
access;
symbols
	OPENBSD_5_7:1.24.0.4
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.16
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.14
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.10
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.8
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.18
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.14
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.12
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.10
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.8
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.6
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.4
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.13.0.8
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.6
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.4
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.13
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.6
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.26
date	2015.04.09.18.58.22;	author deraadt;	state dead;
branches;
next	1.25;
commitid	cDamcqFPw3HffP51;

1.25
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.24;
commitid	p4LJxGKbi0BU2cG6;

1.24
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.23;
commitid	t9FBKDfc4VDxpEy2;

1.23
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.22;

1.22
date	2010.09.20.07.40.38;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.13.14.24.47;	author jasper;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.07.00.29.21;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.06.23.27.33;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.05.11.49.01;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.09.04.10.12;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.16.17.20.47;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.12.06.35.11;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.02.22.50.00;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.12.20.33.50;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.09.13.13.44;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.12.15.40.31;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.22.02.01.53;	author chris;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.01.18.01.41;	author chris;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.11.04.16.21.12;	author chris;	state Exp;
branches;
next	1.3;

1.3
date	99.10.26.23.47.15;	author chris;	state Exp;
branches;
next	1.2;

1.2
date	99.07.24.06.44.00;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.07.01.23.10.40;	author deraadt;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.14.22.25.45;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.07.04.10.42.16;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2004.06.05.23.12.50;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Send lmc(4) and san(4) to the HDLC framed bit bucket in the sky.
@
text
@/*	$OpenBSD: if_lmc_obsd.c,v 1.25 2015/03/14 03:38:48 jsg Exp $ */
/*	$NetBSD: if_lmc_nbsd.c,v 1.1 1999/03/25 03:32:43 explorer Exp $	*/

/*-
 * Copyright (c) 1997-1999 LAN Media Corporation (LMC)
 * All rights reserved.  www.lanmedia.com
 *
 * This code is written by Michael Graff <graff@@vix.com> for LMC.
 * The code is derived from permitted modifications to software created
 * by Matt Thomas (matt@@3am-software.com).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following disclaimer
 *    in the documentation and/or other materials provided with the
 *    distribution.
 * 3. All marketing or advertising materials mentioning features or
 *    use of this software must display the following acknowledgement:
 *      This product includes software developed by LAN Media Corporation
 *      and its contributors.
 * 4. Neither the name of LAN Media Corporation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY LAN MEDIA CORPORATION AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1994-1997 Matt Thomas (matt@@3am-software.com)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <dev/pci/pcidevs.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_types.h>
#include <net/if_dl.h>
#include <net/netisr.h>

#include <net/if_sppp.h>

#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/ic/dc21040reg.h>

#include <dev/pci/if_lmc_types.h>
#include <dev/pci/if_lmcioctl.h>
#include <dev/pci/if_lmcvar.h>

/*
 * This file is INCLUDED (gross, I know, but...)
 */

static int lmc_busdma_init(lmc_softc_t * const sc);
static int lmc_busdma_allocmem(lmc_softc_t * const sc, size_t size,
	bus_dmamap_t *map_p, lmc_desc_t **desc_p);

static int
lmc_pci_probe(struct device *parent,
	       void *match,
	       void *aux)
{
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	u_int32_t id;

	/*
	 * check first for the DEC chip we expect to find.  We expect
	 * 21140A, pass 2.2 or higher.
	 */
	if (PCI_VENDORID(pa->pa_id) != PCI_VENDOR_DEC)
		return 0;
	if (PCI_CHIPID(pa->pa_id) != PCI_PRODUCT_DEC_21140)
		return 0;
	id = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CFRV) & 0xff;
	if (id < 0x22)
		return 0;

	/*
	 * Next, check the subsystem ID and see if it matches what we
	 * expect.
	 */
	id = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SSID);
	if (PCI_VENDORID(id) != PCI_VENDOR_LMC)
		return 0;
	if ((PCI_CHIPID(id) != PCI_PRODUCT_LMC_HSSI)
	    && (PCI_CHIPID(id) != PCI_PRODUCT_LMC_HSSIC)
	    && (PCI_CHIPID(id) != PCI_PRODUCT_LMC_DS3)
	    && (PCI_CHIPID(id) != PCI_PRODUCT_LMC_SSI)
	    && (PCI_CHIPID(id) != PCI_PRODUCT_LMC_DS1))
		return 0;

	return 20; /* must be > than any other tulip driver */
}

static void  lmc_pci_attach(struct device * const parent,
			     struct device * const self, void * const aux);

struct cfattach lmc_ca = {
    sizeof(lmc_softc_t), lmc_pci_probe, lmc_pci_attach
};

struct cfdriver lmc_cd = {
	NULL, "lmc", DV_IFNET
};

static void
lmc_pci_attach(struct device * const parent,
		struct device * const self, void * const aux)
{
	u_int32_t revinfo, cfdainfo, id, ssid;
	pci_intr_handle_t intrhandle;
	const char *intrstr;
	unsigned csroffset = LMC_PCI_CSROFFSET;
	unsigned csrsize = LMC_PCI_CSRSIZE;
	lmc_csrptr_t csr_base;
	lmc_spl_t s;
	lmc_intrfunc_t (*intr_rtn)(void *) = lmc_intr_normal;
	lmc_softc_t * const sc = (lmc_softc_t *) self;
	struct pci_attach_args * const pa = (struct pci_attach_args *) aux;
	extern lmc_media_t lmc_hssi_media;
	extern lmc_media_t lmc_ds3_media;
	extern lmc_media_t lmc_t1_media;
	extern lmc_media_t lmc_ssi_media;

	revinfo  = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CFRV) & 0xFF;
	id       = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CFID);
	cfdainfo = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CFDA);
	ssid = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SSID);

	switch (PCI_CHIPID(ssid)) {
	case PCI_PRODUCT_LMC_HSSI:
		printf(": HSSI\n");
		sc->lmc_media = &lmc_hssi_media;
		break;
	case PCI_PRODUCT_LMC_HSSIC:
		printf(": HSSIc\n");
		sc->lmc_media = &lmc_hssi_media;
		break;
	case PCI_PRODUCT_LMC_DS3:
		printf(": DS3\n");
		sc->lmc_media = &lmc_ds3_media;
		break;
	case PCI_PRODUCT_LMC_SSI:
		printf(": SSI\n");
		sc->lmc_media = &lmc_ssi_media;
		break;
	case PCI_PRODUCT_LMC_DS1:
		printf(": T1\n");
		sc->lmc_media = &lmc_t1_media;
		break;
	}

        sc->lmc_pci_busno = parent;
        sc->lmc_pci_devno = pa->pa_device;

	sc->lmc_chipid = LMC_21140A;
	sc->lmc_features |= LMC_HAVE_STOREFWD;
	if (sc->lmc_chipid == LMC_21140A && revinfo <= 0x22)
		sc->lmc_features |= LMC_HAVE_RXBADOVRFLW;

	if (cfdainfo & (TULIP_CFDA_SLEEP | TULIP_CFDA_SNOOZE)) {
		cfdainfo &= ~(TULIP_CFDA_SLEEP | TULIP_CFDA_SNOOZE);
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_CFDA, cfdainfo);
		DELAY(11 * 1000);
	}

	bcopy(self->dv_xname, sc->lmc_if.if_xname, IFNAMSIZ);
	sc->lmc_if.if_softc = sc;
	sc->lmc_pc = pa->pa_pc;

	sc->lmc_revinfo = revinfo;
	sc->lmc_if.if_softc = sc;

	csr_base = 0;
	{
		bus_space_tag_t iot, memt;
		bus_space_handle_t ioh, memh;
		int ioh_valid, memh_valid;

		ioh_valid = (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO,
		    0, &iot, &ioh, NULL, NULL, 0) == 0);
		memh_valid = (pci_mapreg_map(pa, PCI_CBMA,
		    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0, &memt,
		    &memh, NULL, NULL, 0) == 0);

		if (memh_valid) {
			sc->lmc_bustag = memt;
			sc->lmc_bushandle = memh;
		} else if (ioh_valid) {
			sc->lmc_bustag = iot;
			sc->lmc_bushandle = ioh;
		} else {
			printf("%s: unable to map device registers\n",
			       sc->lmc_dev.dv_xname);
			return;
		}
	}

	sc->lmc_dmatag = pa->pa_dmat;
	if ((lmc_busdma_init(sc)) != 0) {
		printf("error initing bus_dma\n");
		return;
	}

	lmc_initcsrs(sc, csr_base + csroffset, csrsize);
	lmc_initring(sc, &sc->lmc_rxinfo, sc->lmc_rxdescs,
		       LMC_RXDESCS);
	lmc_initring(sc, &sc->lmc_txinfo, sc->lmc_txdescs,
		       LMC_TXDESCS);

	lmc_gpio_mkinput(sc, 0xff);
	sc->lmc_gpio = 0;  /* drive no signals yet */

	sc->lmc_media->defaults(sc);

	sc->lmc_media->set_link_status(sc, LMC_LINK_DOWN); /* down */

	/*
	 * Make sure there won't be any interrupts or such...
	 */
	LMC_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);

	/*
	 * Wait 10 microseconds (actually 50 PCI cycles but at 
	 * 33MHz that comes to two microseconds but wait a
	 * bit longer anyways)
	 */
	DELAY(100);

	lmc_read_macaddr(sc);

        if (pci_intr_map(pa, &intrhandle)) {
		 printf("%s: couldn't map interrupt\n",
			sc->lmc_dev.dv_xname);
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, intrhandle);

	sc->lmc_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_NET,
						intr_rtn, sc, self->dv_xname);

	if (sc->lmc_ih == NULL) {
		printf("%s: couldn't establish interrupt",
		       sc->lmc_dev.dv_xname);
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}

        printf("%s: pass %d.%d, serial " LMC_EADDR_FMT ", %s\n",
               sc->lmc_dev.dv_xname,
               (sc->lmc_revinfo & 0xF0) >> 4, sc->lmc_revinfo & 0x0F,
               LMC_EADDR_ARGS(sc->lmc_enaddr), intrstr);

	s = LMC_RAISESPL();
	lmc_dec_reset(sc);
	lmc_reset(sc);
	lmc_attach(sc);
	LMC_RESTORESPL(s);
}

static int
lmc_busdma_allocmem(
    lmc_softc_t * const sc,
    size_t size,
    bus_dmamap_t *map_p,
    lmc_desc_t **desc_p)
{
    bus_dma_segment_t segs[1];
    int nsegs, error;
    error = bus_dmamem_alloc(sc->lmc_dmatag, size, 1, NBPG,
			     segs, nitems(segs), &nsegs, BUS_DMA_NOWAIT);
    if (error == 0) {
	void *desc;
	error = bus_dmamem_map(sc->lmc_dmatag, segs, nsegs, size,
			       (void *) &desc, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);
	if (error == 0) {
	    bus_dmamap_t map;
	    error = bus_dmamap_create(sc->lmc_dmatag, size, 1, size, 0,
				      BUS_DMA_NOWAIT, &map);
	    if (error == 0) {
		error = bus_dmamap_load(sc->lmc_dmatag, map, desc,
					size, NULL, BUS_DMA_NOWAIT);
		if (error)
		    bus_dmamap_destroy(sc->lmc_dmatag, map);
		else
		    *map_p = map;
	    }
	    if (error)
		bus_dmamem_unmap(sc->lmc_dmatag, desc, size);
	}
	if (error)
	    bus_dmamem_free(sc->lmc_dmatag, segs, nsegs);
	else
	    *desc_p = desc;
    }
    return error;
}

static int
lmc_busdma_init(
    lmc_softc_t * const sc)
{
    int error = 0;

    /*
     * Allocate space and dmamap for transmit ring
     */
    if (error == 0) {
	error = lmc_busdma_allocmem(sc, sizeof(lmc_desc_t) * LMC_TXDESCS,
				      &sc->lmc_txdescmap,
				      &sc->lmc_txdescs);
    }

    /*
     * Allocate dmamaps for each transmit descriptors
     */
    if (error == 0) {
	while (error == 0 && sc->lmc_txmaps_free < LMC_TXDESCS) {
	    bus_dmamap_t map;
	    if ((error = LMC_TXMAP_CREATE(sc, &map)) == 0)
		sc->lmc_txmaps[sc->lmc_txmaps_free++] = map;
	}
	if (error) {
	    while (sc->lmc_txmaps_free > 0) 
		bus_dmamap_destroy(sc->lmc_dmatag,
				   sc->lmc_txmaps[--sc->lmc_txmaps_free]);
	}
    }

    /*
     * Allocate space and dmamap for receive ring
     */
    if (error == 0) {
	error = lmc_busdma_allocmem(sc, sizeof(lmc_desc_t) * LMC_RXDESCS,
				      &sc->lmc_rxdescmap,
				      &sc->lmc_rxdescs);
    }

    /*
     * Allocate dmamaps for each receive descriptors
     */
    if (error == 0) {
	while (error == 0 && sc->lmc_rxmaps_free < LMC_RXDESCS) {
	    bus_dmamap_t map;
	    if ((error = LMC_RXMAP_CREATE(sc, &map)) == 0)
		sc->lmc_rxmaps[sc->lmc_rxmaps_free++] = map;
	}
	if (error) {
	    while (sc->lmc_rxmaps_free > 0) 
		bus_dmamap_destroy(sc->lmc_dmatag,
				   sc->lmc_rxmaps[--sc->lmc_rxmaps_free]);
	}
    }

    return error;
}
@


1.25
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.24 2014/12/05 15:50:04 mpi Exp $ */
@


1.24
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.23 2011/04/03 15:36:02 jasper Exp $ */
a64 3

#include "bpfilter.h"

a81 4

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
@


1.23
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.22 2010/09/20 07:40:38 deraadt Exp $ */
d81 1
@


1.22
log
@Stop doing shutdown hooks in network drivers where possible.  We already
take all interfaces down, via their xxstop routines.  Claudio and I have
verified that none of the shutdown hooks do much extra beyond what xxstop
was already doing; it is largely a pile of junk.
ok claudio, some early comments by sthen; also read by matthew, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.21 2010/04/08 00:23:53 tedu Exp $ */
d324 1
a324 2
			     segs, sizeof(segs)/sizeof(segs[0]),
			     &nsegs, BUS_DMA_NOWAIT);
@


1.21
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.20 2009/08/13 14:24:47 jasper Exp $ */
a104 1
static void lmc_shutdown(void *arg);
a306 5
        sc->lmc_ats = shutdownhook_establish(lmc_shutdown, sc);
        if (sc->lmc_ats == NULL)
		printf("%s: warning: couldn't establish shutdown hook\n",
		       sc->lmc_xname);

a311 11
}

static void
lmc_shutdown(void *arg)
{
	lmc_softc_t * const sc = arg;
	LMC_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);
	DELAY(10);

	sc->lmc_miireg16 = 0;  /* deassert ready, and all others too */
	lmc_led_on(sc, LMC_MII16_LED_ALL);
@


1.20
log
@- consistify cfdriver for the ethernet drivers (0 -> NULL)

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.19 2005/11/07 00:29:21 brad Exp $ */
a75 1
#include <sys/proc.h>	/* only for declaration of wakeup() used by vm.h */
@


1.19
log
@first round of lmc(4) cleaning. removes a good portion of the ifdef
crud making this readable.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.18 2005/11/06 23:27:33 brad Exp $ */
d156 1
a156 1
	0, "lmc", DV_IFNET
@


1.18
log
@also attach on LMC cPCI HSSI cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.17 2005/11/05 11:49:01 brad Exp $ */
d66 2
a76 3
#if defined(__FreeBSD__)
#include <machine/clock.h>
#elif defined(__bsdi__) || defined(__NetBSD__) || defined(__OpenBSD__)
a77 9
#endif

#if defined(__NetBSD__)
#include <dev/pci/pcidevs.h>
#include "rnd.h"
#if NRND > 0
#include <sys/rnd.h>
#endif
#endif
a78 1
#if defined(__OpenBSD__)
a79 1
#endif
a85 1
#include "bpfilter.h"
a89 1
#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
a90 1
#endif
d92 1
a92 24
#if defined(__bsdi__)
#if INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#endif

#include <net/netisr.h>
#include <net/if.h>
#include <net/netisr.h>
#include <net/if_types.h>
#include <net/if_p2p.h>
#include <net/if_c_hdlc.h>
#endif

#if defined(__FreeBSD__)
#include <vm/pmap.h>
#include <pci.h>
#if NPCI > 0
#include <pci/pcivar.h>
#include <pci/dc21040reg.h>
#define INCLUDE_PATH_PREFIX "pci/"
#endif
#endif /* __FreeBSD__ */
a93 16
#if defined(__bsdi__)
#include <i386/pci/ic/dc21040.h>
#include <i386/isa/isa.h>
#include <i386/isa/icu.h>
#include <i386/isa/dma.h>
#include <i386/isa/isavar.h>
#include <i386/pci/pci.h>

#define	INCLUDE_PATH_PREFIX	"i386/pci/"
#endif /* __bsdi__ */

#if defined(__NetBSD__) || defined(__OpenBSD__)
#include <machine/bus.h>
#if defined(__alpha__) && defined(__NetBSD__)
#include <machine/intr.h>
#endif
a96 2
#define	INCLUDE_PATH_PREFIX	"dev/pci/"
#endif /* __NetBSD__ */
a97 9
/*
 * Sigh.  Every OS puts these in different places.  NetBSD and FreeBSD use
 * a C preprocessor that allows this hack, but BSDI does not.  Grr.
 */
#if defined(__NetBSD__) || defined(__FreeBSD__)
#include INCLUDE_PATH_PREFIX "if_lmc_types.h"
#include INCLUDE_PATH_PREFIX "if_lmcioctl.h"
#include INCLUDE_PATH_PREFIX "if_lmcvar.h"
#elif defined(__OpenBSD__)
a100 5
#else /* BSDI */
#include "i386/pci/if_lmctypes.h"
#include "i386/pci/if_lmcioctl.h"
#include "i386/pci/if_lmcvar.h"
#endif
a232 2
#if defined(__NetBSD__) || defined(__OpenBSD__)

a237 2
#endif

a291 1
#if defined(__OpenBSD__)
a293 4
#else
	sc->lmc_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_NET,
						intr_rtn, sc);
#endif
@


1.17
log
@add bus_dma and big endian support.

From NetBSD

Thanks to Jason Ackley for testing on i386/amd64/sparc64
with both T1 and T3 cards.

"looks ok" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.16 2005/08/09 04:10:12 mickey Exp $ */
d209 1
d256 4
@


1.16
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.15 2005/07/16 17:20:47 brad Exp $ */
a102 2
#include <uvm/uvm_extern.h>

d177 3
d214 1
a214 1
	return 10; /* must be > than any other tulip driver */
a234 3
#if 0
	vm_offset_t pa_csrs;
#endif
d321 6
d404 98
@


1.15
log
@remove __BROKEN_INDIRECT_CONFIG cruft
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.14 2004/05/12 06:35:11 tedu Exp $ */
a320 5
		/* Make sure bus mastering is enabled. */
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
			       pci_conf_read(pa->pa_pc, pa->pa_tag,
					     PCI_COMMAND_STATUS_REG) |
			       PCI_COMMAND_MASTER_ENABLE);
@


1.14
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.13 2002/06/02 22:50:00 deraadt Exp $ */
a181 1
#if defined (__BROKEN_INDIRECT_CONFIG) || defined(__OpenBSD__)
a182 3
#else
	       struct cfdata *match,
#endif
@


1.13
log
@withough -> without
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.12 2001/11/06 19:53:19 miod Exp $ */
a100 1
#include <net/bpfdesc.h>
@


1.12
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.11 2001/09/11 20:05:25 miod Exp $ */
d52 1
a52 1
 *    derived from this software withough specific prior written permission
@


1.12.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.12 2001/11/06 19:53:19 miod Exp $ */
d52 1
a52 1
 *    derived from this software without specific prior written permission
@


1.11
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.10 2001/08/25 10:13:29 art Exp $ */
d104 1
a104 1
#include <vm/vm.h>
@


1.10
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.9 2001/08/12 20:33:50 mickey Exp $ */
a104 1
#include <vm/vm_kern.h>
@


1.9
log
@absolutely no need to include vm_parm.h after vm.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.8 2001/07/09 13:13:44 espie Exp $ */
d361 1
a361 2
        if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
                         pa->pa_intrline, &intrhandle)) {
@


1.8
log
@Remove dubious #include MACRO "string" construct (non-ANSI)
and use the more correct #include <file.h> style.

From discussion with millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.7 2001/06/12 15:40:31 niklas Exp $ */
a104 1
#include <vm/vm_param.h>
@


1.7
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.6 2001/02/22 02:01:53 chris Exp $ */
d163 1
a163 1
#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)
d167 4
@


1.6
log
@slightly less verbose dmesg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.5 2000/02/01 18:01:41 chris Exp $ */
d306 1
a306 1
					    0, &iot, &ioh, NULL, NULL) == 0);
d308 2
a309 4
					     PCI_MAPREG_TYPE_MEM |
					     PCI_MAPREG_MEM_TYPE_32BIT,
					     0, &memt, &memh, NULL,
					     NULL) == 0);
@


1.5
log
@general cleanup (remove LMC_IOMAPPED crud entirely)
add correct rcs tags
sync w/lmc's lmc_media.c regarding watchdog support
(So, the LEDs on the T1/T3 cards [the ones with built-in CSU/DSUs], and also
the DS1 "SSI" card should now change according to various line conditions, as
ths manual says they do)
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d259 1
a259 1
		printf(": Lan Media Corporation HSSI\n");
d263 1
a263 1
		printf(": Lan Media Corporation DS3\n");
d267 1
a267 1
		printf(": Lan Media Corporation SSI\n");
d271 1
a271 1
		printf(": Lan Media Corporation T1\n");
@


1.5.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.6 2001/02/22 02:01:53 chris Exp $ */
d259 1
a259 1
		printf(": HSSI\n");
d263 1
a263 1
		printf(": DS3\n");
d267 1
a267 1
		printf(": SSI\n");
d271 1
a271 1
		printf(": T1\n");
@


1.5.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.5.2.1 2001/05/14 22:25:45 niklas Exp $ */
d306 1
a306 1
		    0, &iot, &ioh, NULL, NULL, 0) == 0);
d308 4
a311 2
		    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0, &memt,
		    &memh, NULL, NULL, 0) == 0);
@


1.5.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lmc_obsd.c,v 1.5.2.2 2001/07/04 10:42:16 niklas Exp $ */
d105 2
d163 1
a163 1
#if defined(__NetBSD__) || defined(__FreeBSD__)
a166 4
#elif defined(__OpenBSD__)
#include <dev/pci/if_lmc_types.h>
#include <dev/pci/if_lmcioctl.h>
#include <dev/pci/if_lmcvar.h>
d358 2
a359 1
        if (pci_intr_map(pa, &intrhandle)) {
@


1.5.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d104 1
a104 1
#include <uvm/uvm_extern.h>
@


1.5.2.5
log
@Sync the SMP branch with 3.3
@
text
@d52 1
a52 1
 *    derived from this software without specific prior written permission
@


1.5.2.6
log
@Merge with the trunk
@
text
@d101 1
@


1.4
log
@Make sure bus mastering is enabled, from freebsd if_de.c
@
text
@d1 1
a1 1
/*	$OpenBSD $ */
d237 1
a237 1
#if !defined(LMC_IOMAPPED)
d344 1
a344 1
	sc->lmc_media->set_link_status(sc, 0); /* down */
@


1.3
log
@Support LMC1200
Based on LMC's Linux code
@
text
@d326 5
@


1.2
log
@use pci_mapreg_map(); chris@@dqc.org
@
text
@d1 1
d212 2
a213 1
	    && (PCI_CHIPID(id) != PCI_PRODUCT_LMC_SSI))
d250 1
d268 4
a353 4
	printf("%s: pass %d.%d, serial " LMC_EADDR_FMT "\n",
	       sc->lmc_dev.dv_xname,
	       (sc->lmc_revinfo & 0xF0) >> 4, sc->lmc_revinfo & 0x0F,
	       LMC_EADDR_ARGS(sc->lmc_enaddr));
d379 5
a383 2
	printf("%s: interrupting at %s\n", sc->lmc_dev.dv_xname,
	       intrstr);
@


1.1
log
@lmc driver; ported by chris@@dqc.org
@
text
@d296 1
a296 8
#if defined(__OpenBSD__)
                pci_chipset_tag_t pc = pa->pa_pc;
		bus_addr_t lmcbase;
		bus_size_t lmcsize;
		int retval;
#endif

#if defined(__NetBSD__)
a304 20
#elif defined(__OpenBSD__)
		ioh_valid = 0;
		memh_valid = 0;
		csr_base = 0;

	        iot = pa->pa_iot;
		retval = pci_io_find(pc, pa->pa_tag, PCI_CBIO, &lmcbase, &lmcsize);

		if(!retval)
			retval = bus_space_map(pa->pa_iot, lmcbase, lmcsize, 0, &ioh);
		ioh_valid = (retval == 0);

		if(!ioh_valid) {	/* Can this if just be removed? */
			memt = pa->pa_memt;
			retval = pci_mem_find(pc, pa->pa_tag, PCI_CBMA, &lmcbase, &lmcsize, NULL);
			if(!retval)
				retval = bus_space_map(pa->pa_memt, lmcbase, lmcsize, 0, &memh);

			memh_valid = (retval == 0);
		}
@

