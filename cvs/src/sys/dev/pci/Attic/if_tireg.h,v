head	1.26;
access;
symbols
	OPENBSD_4_6:1.25.0.16
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.12
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.10
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.8
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.6
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.4
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.13.0.6
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.4
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.9.0.10
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.8
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.11
	UBC:1.9.0.6
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.4
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.26
date	2009.08.29.21.12.55;	author kettenis;	state dead;
branches;
next	1.25;

1.25
date	2006.08.16.02.37.00;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2006.07.18.01.24.46;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2006.05.28.00.20.21;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.16.02.23.53;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.16.01.47.39;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.09.20.07.32;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.09.19.41.11;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.03.02.04.15;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.27.00.15.21;	author pvalchev;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.02.21.18.48;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.08.05.19.57.17;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.19.11.37.00;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.26.19.02.50;	author nate;	state Exp;
branches;
next	1.12;

1.12
date	2002.12.04.17.32.30;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.04.01.25.21;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.03.23.50.07;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.21.03.50.48;	author jason;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	2000.06.07.05.35.03;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.15.03.56.49;	author todd;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.15.03.56.27;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.18.05.26.25;	author jason;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.10.25.19.39.19;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	99.10.03.13.06.30;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	99.09.26.03.22.40;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	99.07.25.16.51.55;	author jason;	state Exp;
branches;
next	;

1.5.2.1
date	2000.02.20.11.57.07;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2000.03.24.09.09.18;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2001.05.14.22.25.47;	author niklas;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2004.06.05.23.12.51;	author niklas;	state Exp;
branches;
next	;

1.9.6.1
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	1.9.6.2;

1.9.6.2
date	2003.05.19.22.18.01;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Split the ti(4) driver into mostly bus-agnostic code and PCI-specific
attachment.  Add SBus support to the bus-agnostic code.
@
text
@/*	$OpenBSD: if_tireg.h,v 1.25 2006/08/16 02:37:00 brad Exp $	*/

/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/pci/if_tireg.h,v 1.12 2000/01/18 00:26:29 wpaul Exp $
 */

/*
 * Tigon register offsets. These are memory mapped registers
 * which can be accessed with the CSR_READ_4()/CSR_WRITE_4() macros.
 * Each register must be accessed using 32 bit operations.
 *
 * All reegisters are accessed through a 16K shared memory block.
 * The first group of registers are actually copies of the PCI
 * configuration space registers.
 */

#define TI_PCI_ID			PCI_ID_REG /* PCI device/vendor ID */
#define TI_PCI_CMDSTAT			PCI_COMMAND_STATUS_REG
#define TI_PCI_CLASSCODE		PCI_CLASS_REG
#define TI_PCI_BIST			PCI_BHLC_REG
#define TI_PCI_LOMEM			PCI_MAPS /* Shared memory base address */
#define TI_PCI_SUBSYS			PCI_SUBVEND_0
#define TI_PCI_ROMBASE			0x030
#define TI_PCI_INT			PCI_INTLINE

/*
 * Tigon configuration and control registers.
 */
#define TI_MISC_HOST_CTL		0x040
#define TI_MISC_LOCAL_CTL		0x044
#define TI_SEM_AB			0x048 /* Tigon 2 only */
#define TI_MISC_CONF			0x050 /* Tigon 2 only */
#define TI_TIMER_BITS			0x054
#define TI_TIMERREF			0x058
#define TI_PCI_STATE			0x05C
#define TI_MAIN_EVENT_A			0x060
#define TI_MAILBOX_EVENT_A		0x064
#define TI_WINBASE			0x068
#define TI_WINDATA			0x06C
#define TI_MAIN_EVENT_B			0x070 /* Tigon 2 only */
#define TI_MAILBOX_EVENT_B		0x074 /* Tigon 2 only */
#define TI_TIMERREF_B			0x078 /* Tigon 2 only */
#define TI_SERIAL			0x07C

/*
 * Misc host control bits.
 */
#define TI_MHC_INTSTATE			0x00000001
#define TI_MHC_CLEARINT			0x00000002
#define TI_MHC_RESET			0x00000008
#define TI_MHC_BYTE_SWAP_ENB		0x00000010
#define TI_MHC_WORD_SWAP_ENB		0x00000020
#define TI_MHC_MASK_INTS		0x00000040
#define TI_MHC_CHIP_REV_MASK		0xF0000000

#define TI_MHC_BIGENDIAN_INIT	\
	(TI_MHC_BYTE_SWAP_ENB|TI_MHC_WORD_SWAP_ENB|TI_MHC_CLEARINT)

#define TI_MHC_LITTLEENDIAN_INIT	\
	(TI_MHC_WORD_SWAP_ENB|TI_MHC_CLEARINT)

/*
 * Tigon chip rev values. Rev 4 is the Tigon 1. Rev 6 is the Tigon 2.
 * Rev 5 is also the Tigon 2, but is a broken version which was never
 * used in any actual hardware, so we ignore it.
 */
#define TI_REV_TIGON_I			0x40000000
#define TI_REV_TIGON_II			0x60000000

/*
 * Firmware revision that we want.
 */
#define TI_FIRMWARE_MAJOR		0xc
#define TI_FIRMWARE_MINOR		0x4
#define TI_FIRMWARE_FIX			0xd

/*
 * Miscelaneous Local Control register.
 */
#define TI_MLC_EE_WRITE_ENB		0x00000010
#define TI_MLC_SRAM_BANK_SIZE		0x00000300 /* Tigon 2 only */
#define TI_MLC_LOCALADDR_21		0x00004000
#define TI_MLC_LOCALADDR_22		0x00008000
#define TI_MLC_SBUS_WRITEERR		0x00080000
#define TI_MLC_EE_CLK			0x00100000
#define TI_MLC_EE_TXEN			0x00200000
#define TI_MLC_EE_DOUT			0x00400000
#define TI_MLC_EE_DIN			0x00800000

/* Possible memory sizes. */
#define TI_MLC_SRAM_BANK_DISA		0x00000000
#define TI_MLC_SRAM_BANK_1024K		0x00000100
#define TI_MLC_SRAM_BANK_512K		0x00000200
#define TI_MLC_SRAM_BANK_256K		0x00000300

/*
 * Offset of MAC address inside EEPROM.
 */
#define TI_EE_MAC_OFFSET		0x8c

#define TI_DMA_ASSIST			0x11C
#define TI_CPU_STATE			0x140
#define TI_CPU_PROGRAM_COUNTER		0x144
#define TI_SRAM_ADDR			0x154
#define TI_SRAM_DATA			0x158
#define TI_GEN_0			0x180
#define TI_GEN_X			0x1FC
#define TI_MAC_TX_STATE			0x200
#define TI_MAC_RX_STATE			0x220
#define TI_CPU_CTL_B			0x240 /* Tigon 2 only */
#define TI_CPU_PROGRAM_COUNTER_B	0x244 /* Tigon 2 only */
#define TI_SRAM_ADDR_B			0x254 /* Tigon 2 only */
#define TI_SRAM_DATA_B			0x258 /* Tigon 2 only */
#define TI_GEN_B_0			0x280 /* Tigon 2 only */
#define TI_GEN_B_X			0x2FC /* Tigon 2 only */

/*
 * Misc config register.
 */
#define TI_MCR_SRAM_SYNCHRONOUS		0x00100000 /* Tigon 2 only */

/*
 * PCI state register.
 */
#define TI_PCISTATE_FORCE_RESET		0x00000001
#define TI_PCISTATE_PROVIDE_LEN		0x00000002
#define TI_PCISTATE_READ_MAXDMA		0x0000001C
#define TI_PCISTATE_WRITE_MAXDMA	0x000000E0
#define TI_PCISTATE_MINDMA		0x0000FF00
#define TI_PCISTATE_FIFO_RETRY_ENB	0x00010000
#define TI_PCISTATE_USE_MEM_RD_MULT	0x00020000
#define TI_PCISTATE_NO_SWAP_READ_DMA	0x00040000
#define TI_PCISTATE_NO_SWAP_WRITE_DMA	0x00080000
#define TI_PCISTATE_66MHZ_BUS		0x00080000 /* Tigon 2 only */
#define TI_PCISTATE_32BIT_BUS		0x00100000 /* Tigon 2 only */
#define TI_PCISTATE_ENB_BYTE_ENABLES	0x00800000 /* Tigon 2 only */
#define TI_PCISTATE_READ_CMD		0x0F000000
#define TI_PCISTATE_WRITE_CMD		0xF0000000

#define TI_PCI_READMAX_4		0x04
#define TI_PCI_READMAX_16		0x08
#define TI_PCI_READMAX_32		0x0C
#define TI_PCI_READMAX_64		0x10
#define TI_PCI_READMAX_128		0x14
#define TI_PCI_READMAX_256		0x18
#define TI_PCI_READMAX_1024		0x1C

#define TI_PCI_WRITEMAX_4		0x20
#define TI_PCI_WRITEMAX_16		0x40
#define TI_PCI_WRITEMAX_32		0x60
#define TI_PCI_WRITEMAX_64		0x80
#define TI_PCI_WRITEMAX_128		0xA0
#define TI_PCI_WRITEMAX_256		0xC0
#define TI_PCI_WRITEMAX_1024		0xE0

#define TI_PCI_READ_CMD			0x06000000
#define TI_PCI_WRITE_CMD		0x70000000

/*
 * DMA state register.
 */
#define TI_DMASTATE_ENABLE		0x00000001
#define TI_DMASTATE_PAUSE		0x00000002

/*
 * CPU state register.
 */
#define TI_CPUSTATE_RESET		0x00000001
#define TI_CPUSTATE_STEP		0x00000002
#define TI_CPUSTATE_ROMFAIL		0x00000010
#define TI_CPUSTATE_HALT		0x00010000
/*
 * MAC TX state register
 */
#define TI_TXSTATE_RESET		0x00000001
#define TI_TXSTATE_ENB			0x00000002
#define TI_TXSTATE_STOP			0x00000004

/*
 * MAC RX state register
 */
#define TI_RXSTATE_RESET		0x00000001
#define TI_RXSTATE_ENB			0x00000002
#define TI_RXSTATE_STOP			0x00000004

/*
 * Tigon 2 mailbox registers. The mailbox area consists of 256 bytes
 * split into 64 bit registers. Only the lower 32 bits of each mailbox
 * are used.
 */
#define TI_MB_HOSTINTR_HI		0x500
#define TI_MB_HOSTINTR_LO		0x504
#define TI_MB_HOSTINTR			TI_MB_HOSTINTR_LO
#define TI_MB_CMDPROD_IDX_HI		0x508
#define TI_MB_CMDPROD_IDX_LO		0x50C
#define TI_MB_CMDPROD_IDX		TI_MB_CMDPROD_IDX_LO
#define TI_MB_SENDPROD_IDX_HI		0x510
#define TI_MB_SENDPROD_IDX_LO		0x514
#define TI_MB_SENDPROD_IDX		TI_MB_SENDPROD_IDX_LO
#define TI_MB_STDRXPROD_IDX_HI		0x518 /* Tigon 2 only */
#define TI_MB_STDRXPROD_IDX_LO		0x51C /* Tigon 2 only */
#define TI_MB_STDRXPROD_IDX		TI_MB_STDRXPROD_IDX_LO
#define TI_MB_JUMBORXPROD_IDX_HI	0x520 /* Tigon 2 only */
#define TI_MB_JUMBORXPROD_IDX_LO	0x524 /* Tigon 2 only */
#define TI_MB_JUMBORXPROD_IDX		TI_MB_JUMBORXPROD_IDX_LO
#define TI_MB_MINIRXPROD_IDX_HI		0x528 /* Tigon 2 only */
#define TI_MB_MINIRXPROD_IDX_LO		0x52C /* Tigon 2 only */
#define TI_MB_MINIRXPROD_IDX		TI_MB_MINIRXPROD_IDX_LO
#define TI_MB_RSVD			0x530

/*
 * Tigon 2 general communication registers. These are 64 and 32 bit
 * registers which are only valid after the firmware has been
 * loaded and started. They actually exist in NIC memory but are
 * mapped into the host memory via the shared memory region.
 *
 * The NIC internally maps these registers starting at address 0,
 * so to determine the NIC address of any of these registers, we
 * subtract 0x600 (the address of the first register).
 */

#define TI_GCR_BASE			0x600
#define TI_GCR_MACADDR			0x600
#define TI_GCR_PAR0			0x600
#define TI_GCR_PAR1			0x604
#define TI_GCR_GENINFO_HI		0x608
#define TI_GCR_GENINFO_LO		0x60C
#define TI_GCR_MCASTADDR		0x610 /* obsolete */
#define TI_GCR_MAR0			0x610 /* obsolete */
#define TI_GCR_MAR1			0x614 /* obsolete */
#define TI_GCR_OPMODE			0x618
#define TI_GCR_DMA_READCFG		0x61C
#define TI_GCR_DMA_WRITECFG		0x620
#define TI_GCR_TX_BUFFER_RATIO		0x624
#define TI_GCR_EVENTCONS_IDX		0x628
#define TI_GCR_CMDCONS_IDX		0x62C
#define TI_GCR_TUNEPARMS		0x630
#define TI_GCR_RX_COAL_TICKS		0x630
#define TI_GCR_TX_COAL_TICKS		0x634
#define TI_GCR_STAT_TICKS		0x638
#define TI_GCR_TX_MAX_COAL_BD		0x63C
#define TI_GCR_RX_MAX_COAL_BD		0x640
#define TI_GCR_NIC_TRACING		0x644
#define TI_GCR_GLINK			0x648
#define TI_GCR_LINK			0x64C
#define TI_GCR_NICTRACE_PTR		0x650
#define TI_GCR_NICTRACE_START		0x654
#define TI_GCR_NICTRACE_LEN		0x658
#define TI_GCR_IFINDEX			0x65C
#define TI_GCR_IFMTU			0x660
#define TI_GCR_MASK_INTRS		0x664
#define TI_GCR_GLINK_STAT		0x668
#define TI_GCR_LINK_STAT		0x66C
#define TI_GCR_RXRETURNCONS_IDX		0x680
#define TI_GCR_CMDRING			0x700

#define TI_GCR_NIC_ADDR(x)		(x - TI_GCR_BASE)

/*
 * Local memory window. The local memory window is a 2K shared
 * memory region which can be used to access the NIC's internal
 * SRAM. The window can be mapped to a given 2K region using
 * the TI_WINDOW_BASE register.
 */
#define TI_WINDOW			0x800
#define TI_WINLEN			0x800

#define TI_TICKS_PER_SEC		1000000

/*
 * Operation mode register.
 */
#define TI_OPMODE_BYTESWAP_BD		0x00000002
#define TI_OPMODE_WORDSWAP_BD		0x00000004
#define TI_OPMODE_WARN_ENB		0x00000008 /* not yet implemented */
#define TI_OPMODE_BYTESWAP_DATA		0x00000010
#define TI_OPMODE_1_DMA_ACTIVE		0x00000040
#define TI_OPMODE_SBUS			0x00000100
#define TI_OPMODE_DONT_FRAG_JUMBO	0x00000200
#define TI_OPMODE_INCLUDE_CRC		0x00000400
#define TI_OPMODE_RX_BADFRAMES		0x00000800
#define TI_OPMODE_NO_EVENT_INTRS	0x00001000
#define TI_OPMODE_NO_TX_INTRS		0x00002000
#define TI_OPMODE_NO_RX_INTRS		0x00004000
#define TI_OPMODE_FATAL_ENB		0x40000000 /* not yet implemented */

#if BYTE_ORDER == BIG_ENDIAN
#define TI_DMA_SWAP_OPTIONS \
	TI_OPMODE_BYTESWAP_DATA| \
	TI_OPMODE_BYTESWAP_BD|TI_OPMODE_WORDSWAP_BD
#else
#define TI_DMA_SWAP_OPTIONS \
	TI_OPMODE_BYTESWAP_DATA
#endif

/*
 * DMA configuration thresholds.
 */
#define TI_DMA_STATE_THRESH_16W		0x00000100
#define TI_DMA_STATE_THRESH_8W		0x00000080
#define TI_DMA_STATE_THRESH_4W		0x00000040
#define TI_DMA_STATE_THRESH_2W		0x00000020
#define TI_DMA_STATE_THRESH_1W		0x00000010

#define TI_DMA_STATE_FORCE_32_BIT	0x00000008

/*
 * Gigabit link status bits.
 */
#define TI_GLNK_SENSE_NO_BEG		0x00002000
#define TI_GLNK_LOOPBACK		0x00004000
#define TI_GLNK_PREF			0x00008000
#define TI_GLNK_1000MB			0x00040000
#define TI_GLNK_FULL_DUPLEX		0x00080000
#define TI_GLNK_TX_FLOWCTL_Y		0x00200000 /* Tigon 2 only */
#define TI_GLNK_RX_FLOWCTL_Y		0x00800000
#define TI_GLNK_AUTONEGENB		0x20000000
#define TI_GLNK_ENB			0x40000000

/*
 * Link status bits.
 */
#define TI_LNK_LOOPBACK			0x00004000
#define TI_LNK_PREF			0x00008000
#define TI_LNK_10MB			0x00010000
#define TI_LNK_100MB			0x00020000
#define TI_LNK_1000MB			0x00040000
#define TI_LNK_FULL_DUPLEX		0x00080000
#define TI_LNK_HALF_DUPLEX		0x00100000
#define TI_LNK_TX_FLOWCTL_Y		0x00200000 /* Tigon 2 only */
#define TI_LNK_RX_FLOWCTL_Y		0x00800000
#define TI_LNK_AUTONEGENB		0x20000000
#define TI_LNK_ENB			0x40000000

/*
 * Ring size constants.
 */
#define TI_EVENT_RING_CNT	256
#define TI_CMD_RING_CNT		64
#define TI_STD_RX_RING_CNT	512
#define TI_JUMBO_RX_RING_CNT	256
#define TI_MINI_RX_RING_CNT	1024
#define TI_RETURN_RING_CNT	2048

/*
 * Possible TX ring sizes.
 */
#define TI_TX_RING_CNT_128	128
#define TI_TX_RING_BASE_128	0x3800

#define TI_TX_RING_CNT_256	256
#define TI_TX_RING_BASE_256	0x3000

#define TI_TX_RING_CNT_512	512
#define TI_TX_RING_BASE_512	0x2000

#define TI_TX_RING_CNT		TI_TX_RING_CNT_512
#define TI_TX_RING_BASE		TI_TX_RING_BASE_512

/*
 * The Tigon can have up to 8MB of external SRAM, however the Tigon 1
 * is limited to 2MB total, and in general I think most adapters have
 * around 1MB. We use this value for zeroing the NIC's SRAM, so to
 * be safe we use the largest possible value (zeroing memory that
 * isn't there doesn't hurt anything).
 */
#define TI_MEM_MAX		0x7FFFFF

/*
 * Even on the alpha, pci addresses are 32-bit quantities
 */

typedef struct {
	u_int32_t		ti_addr_hi;
	u_int32_t		ti_addr_lo;
} ti_hostaddr;
#define TI_HOSTADDR(x)	x.ti_addr_lo

/*
 * Ring control block structure. The rules for the max_len field
 * are as follows:
 * 
 * For the send ring, max_len indicates the number of entries in the
 * ring (128, 256 or 512).
 *
 * For the standard receive ring, max_len indicates the threshold
 * used to decide when a frame should be put in the jumbo receive ring
 * instead of the standard one.
 *
 * For the mini ring, max_len indicates the size of the buffers in the
 * ring. This is the value used to decide when a frame is small enough
 * to be placed in the mini ring.
 *
 * For the return receive ring, max_len indicates the number of entries
 * in the ring. It can be one of 2048, 1024 or 0 (which is the same as
 * 2048 for backwards compatibility). The value 1024 can only be used
 * if the mini ring is disabled.
 */
struct ti_rcb {
	ti_hostaddr		ti_hostaddr;
#if BYTE_ORDER == BIG_ENDIAN
	u_int16_t		ti_max_len;
	u_int16_t		ti_flags;
#else
	u_int16_t		ti_flags;
	u_int16_t		ti_max_len;
#endif
	u_int32_t		ti_unused;
};

#define TI_RCB_FLAG_TCP_UDP_CKSUM	0x00000001
#define TI_RCB_FLAG_IP_CKSUM		0x00000002
#define TI_RCB_FLAG_NO_PHDR_CKSUM	0x00000008
#define TI_RCB_FLAG_VLAN_ASSIST		0x00000010
#define TI_RCB_FLAG_COAL_UPD_ONLY	0x00000020
#define TI_RCB_FLAG_HOST_RING		0x00000040
#define TI_RCB_FLAG_IEEE_SNAP_CKSUM	0x00000080
#define TI_RCB_FLAG_USE_EXT_RX_BD	0x00000100
#define TI_RCB_FLAG_RING_DISABLED	0x00000200

struct ti_producer {
	u_int32_t		ti_idx;
	u_int32_t		ti_unused;
};

/*
 * Tigon statistics counters.
 */
struct ti_stats {
	/*
	 * MAC stats, taken from RFC 1643, ethernet-like MIB
	 */
	volatile u_int32_t dot3StatsAlignmentErrors;		/* 0 */
	volatile u_int32_t dot3StatsFCSErrors;			/* 1 */
	volatile u_int32_t dot3StatsSingleCollisionFrames;	/* 2 */
	volatile u_int32_t dot3StatsMultipleCollisionFrames;	/* 3 */
	volatile u_int32_t dot3StatsSQETestErrors;		/* 4 */
	volatile u_int32_t dot3StatsDeferredTransmissions;	/* 5 */
	volatile u_int32_t dot3StatsLateCollisions;		/* 6 */
	volatile u_int32_t dot3StatsExcessiveCollisions;	/* 7 */
	volatile u_int32_t dot3StatsInternalMacTransmitErrors;	/* 8 */
	volatile u_int32_t dot3StatsCarrierSenseErrors;		/* 9 */
	volatile u_int32_t dot3StatsFrameTooLongs;		/* 10 */
	volatile u_int32_t dot3StatsInternalMacReceiveErrors;	/* 11 */
	/*
	 * interface stats, taken from RFC 1213, MIB-II, interfaces group
	 */
	volatile u_int32_t ifIndex;				/* 12 */
	volatile u_int32_t ifType;				/* 13 */
	volatile u_int32_t ifMtu;				/* 14 */
	volatile u_int32_t ifSpeed;				/* 15 */
	volatile u_int32_t ifAdminStatus;			/* 16 */
#define IF_ADMIN_STATUS_UP      1
#define IF_ADMIN_STATUS_DOWN    2
#define IF_ADMIN_STATUS_TESTING 3
	volatile u_int32_t ifOperStatus;			/* 17 */
#define IF_OPER_STATUS_UP       1
#define IF_OPER_STATUS_DOWN     2
#define IF_OPER_STATUS_TESTING  3
#define IF_OPER_STATUS_UNKNOWN  4
#define IF_OPER_STATUS_DORMANT  5
	volatile u_int32_t ifLastChange;			/* 18 */
	volatile u_int32_t ifInDiscards;			/* 19 */
	volatile u_int32_t ifInErrors;				/* 20 */
	volatile u_int32_t ifInUnknownProtos;			/* 21 */
	volatile u_int32_t ifOutDiscards;			/* 22 */
	volatile u_int32_t ifOutErrors;				/* 23 */
	volatile u_int32_t ifOutQLen;     /* deprecated */	/* 24 */
	volatile u_int8_t  ifPhysAddress[8]; /* 8 bytes */	/* 25 - 26 */
	volatile u_int8_t  ifDescr[32];				/* 27 - 34 */
	u_int32_t alignIt;      /* align to 64 bit for u_int64_ts following */
	/*
	 * more interface stats, taken from RFC 1573, MIB-IIupdate,
	 * interfaces group
	 */
	volatile u_int64_t ifHCInOctets;			/* 36 - 37 */
	volatile u_int64_t ifHCInUcastPkts;			/* 38 - 39 */
	volatile u_int64_t ifHCInMulticastPkts;			/* 40 - 41 */
	volatile u_int64_t ifHCInBroadcastPkts;			/* 42 - 43 */
	volatile u_int64_t ifHCOutOctets;			/* 44 - 45 */
	volatile u_int64_t ifHCOutUcastPkts;			/* 46 - 47 */
	volatile u_int64_t ifHCOutMulticastPkts;		/* 48 - 49 */
	volatile u_int64_t ifHCOutBroadcastPkts;		/* 50 - 51 */
	volatile u_int32_t ifLinkUpDownTrapEnable;		/* 52 */
	volatile u_int32_t ifHighSpeed;				/* 53 */
	volatile u_int32_t ifPromiscuousMode; 			/* 54 */
	volatile u_int32_t ifConnectorPresent; /* follow link state 55 */
	/*
	 * Host Commands
	 */
	volatile u_int32_t nicCmdsHostState;			/* 56 */
	volatile u_int32_t nicCmdsFDRFiltering;			/* 57 */
	volatile u_int32_t nicCmdsSetRecvProdIndex;		/* 58 */
	volatile u_int32_t nicCmdsUpdateGencommStats;		/* 59 */
	volatile u_int32_t nicCmdsResetJumboRing;		/* 60 */
	volatile u_int32_t nicCmdsAddMCastAddr;			/* 61 */
	volatile u_int32_t nicCmdsDelMCastAddr;			/* 62 */
	volatile u_int32_t nicCmdsSetPromiscMode;		/* 63 */
	volatile u_int32_t nicCmdsLinkNegotiate;		/* 64 */
	volatile u_int32_t nicCmdsSetMACAddr;			/* 65 */
	volatile u_int32_t nicCmdsClearProfile;			/* 66 */
	volatile u_int32_t nicCmdsSetMulticastMode;		/* 67 */
	volatile u_int32_t nicCmdsClearStats;			/* 68 */
	volatile u_int32_t nicCmdsSetRecvJumboProdIndex;	/* 69 */
	volatile u_int32_t nicCmdsSetRecvMiniProdIndex;		/* 70 */
	volatile u_int32_t nicCmdsRefreshStats;			/* 71 */
	volatile u_int32_t nicCmdsUnknown;			/* 72 */
	/*
	 * NIC Events
	 */
	volatile u_int32_t nicEventsNICFirmwareOperational;	/* 73 */
	volatile u_int32_t nicEventsStatsUpdated;		/* 74 */
	volatile u_int32_t nicEventsLinkStateChanged;		/* 75 */
	volatile u_int32_t nicEventsError;			/* 76 */
	volatile u_int32_t nicEventsMCastListUpdated;		/* 77 */
	volatile u_int32_t nicEventsResetJumboRing;		/* 78 */
	/*
	 * Ring manipulation
	 */
	volatile u_int32_t nicRingSetSendProdIndex;		/* 79 */
	volatile u_int32_t nicRingSetSendConsIndex;		/* 80 */
	volatile u_int32_t nicRingSetRecvReturnProdIndex;	/* 81 */
	/*
	 * Interrupts
	 */
	volatile u_int32_t nicInterrupts;			/* 82 */
	volatile u_int32_t nicAvoidedInterrupts;		/* 83 */
	/*
	 * BD Coalessing Thresholds
	 */
	volatile u_int32_t nicEventThresholdHit;		/* 84 */
	volatile u_int32_t nicSendThresholdHit;			/* 85 */
	volatile u_int32_t nicRecvThresholdHit;			/* 86 */
	/*
	 * DMA Attentions
	 */
	volatile u_int32_t nicDmaRdOverrun;			/* 87 */
	volatile u_int32_t nicDmaRdUnderrun;			/* 88 */
	volatile u_int32_t nicDmaWrOverrun;			/* 89 */
	volatile u_int32_t nicDmaWrUnderrun;			/* 90 */
	volatile u_int32_t nicDmaWrMasterAborts;		/* 91 */
	volatile u_int32_t nicDmaRdMasterAborts;		/* 92 */
	/*
	 * NIC Resources
	 */
	volatile u_int32_t nicDmaWriteRingFull;			/* 93 */
	volatile u_int32_t nicDmaReadRingFull;			/* 94 */
	volatile u_int32_t nicEventRingFull;			/* 95 */
	volatile u_int32_t nicEventProducerRingFull;		/* 96 */
	volatile u_int32_t nicTxMacDescrRingFull;		/* 97 */
	volatile u_int32_t nicOutOfTxBufSpaceFrameRetry;	/* 98 */
	volatile u_int32_t nicNoMoreWrDMADescriptors;		/* 99 */
	volatile u_int32_t nicNoMoreRxBDs;			/* 100 */
	volatile u_int32_t nicNoSpaceInReturnRing;		/* 101 */
	volatile u_int32_t nicSendBDs;            /* current count 102 */
	volatile u_int32_t nicRecvBDs;            /* current count 103 */
	volatile u_int32_t nicJumboRecvBDs;       /* current count 104 */
	volatile u_int32_t nicMiniRecvBDs;        /* current count 105 */
	volatile u_int32_t nicTotalRecvBDs;       /* current count 106 */
	volatile u_int32_t nicTotalSendBDs;       /* current count 107 */
	volatile u_int32_t nicJumboSpillOver;			/* 108 */
	volatile u_int32_t nicSbusHangCleared;			/* 109 */
	volatile u_int32_t nicEnqEventDelayed;			/* 110 */
	/*
	 * Stats from MAC rx completion
	 */
	volatile u_int32_t nicMacRxLateColls;			/* 111 */
	volatile u_int32_t nicMacRxLinkLostDuringPkt;		/* 112 */
	volatile u_int32_t nicMacRxPhyDecodeErr;		/* 113 */
	volatile u_int32_t nicMacRxMacAbort;			/* 114 */
	volatile u_int32_t nicMacRxTruncNoResources;		/* 115 */
	/*
	 * Stats from the mac_stats area
	 */
	volatile u_int32_t nicMacRxDropUla;			/* 116 */
	volatile u_int32_t nicMacRxDropMcast;			/* 117 */
	volatile u_int32_t nicMacRxFlowControl;			/* 118 */
	volatile u_int32_t nicMacRxDropSpace;			/* 119 */
	volatile u_int32_t nicMacRxColls;			/* 120 */
	/*
 	 * MAC RX Attentions
	 */
	volatile u_int32_t nicMacRxTotalAttns;			/* 121 */
	volatile u_int32_t nicMacRxLinkAttns;			/* 122 */
	volatile u_int32_t nicMacRxSyncAttns;			/* 123 */
	volatile u_int32_t nicMacRxConfigAttns;			/* 124 */
	volatile u_int32_t nicMacReset;				/* 125 */
	volatile u_int32_t nicMacRxBufDescrAttns;		/* 126 */
	volatile u_int32_t nicMacRxBufAttns;			/* 127 */
	volatile u_int32_t nicMacRxZeroFrameCleanup;		/* 128 */
	volatile u_int32_t nicMacRxOneFrameCleanup;		/* 129 */
	volatile u_int32_t nicMacRxMultipleFrameCleanup;	/* 130 */
	volatile u_int32_t nicMacRxTimerCleanup;		/* 131 */
	volatile u_int32_t nicMacRxDmaCleanup;			/* 132 */
	/*
	 * Stats from the mac_stats area
	 */
	volatile u_int32_t nicMacTxCollisionHistogram[15];	/* 133 */
	/*
	 * MAC TX Attentions
	 */
	volatile u_int32_t nicMacTxTotalAttns;			/* 134 */
	/*
	 * NIC Profile
	 */
	volatile u_int32_t nicProfile[32];			/* 135 */
	/*
	 * Pat to 1024 bytes.
	 */
	u_int32_t		pad[75];
};
/*
 * Tigon general information block. This resides in host memory
 * and contains the status counters, ring control blocks and
 * producer pointers.
 */

struct ti_gib {
	struct ti_stats		ti_stats;
	struct ti_rcb		ti_ev_rcb;
	struct ti_rcb		ti_cmd_rcb;
	struct ti_rcb		ti_tx_rcb;
	struct ti_rcb		ti_std_rx_rcb;
	struct ti_rcb		ti_jumbo_rx_rcb;
	struct ti_rcb		ti_mini_rx_rcb;
	struct ti_rcb		ti_return_rcb;
	ti_hostaddr		ti_ev_prodidx_ptr;
	ti_hostaddr		ti_return_prodidx_ptr;
	ti_hostaddr		ti_tx_considx_ptr;
	ti_hostaddr		ti_refresh_stats_ptr;
};

/*
 * Buffer descriptor structures. There are basically three types
 * of structures: normal receive descriptors, extended receive
 * descriptors and transmit descriptors. The extended receive
 * descriptors are optionally used only for the jumbo receive ring.
 */

struct ti_rx_desc {
	ti_hostaddr		ti_addr;
#if BYTE_ORDER == BIG_ENDIAN
	u_int16_t		ti_idx;
	u_int16_t		ti_len;
#else
	u_int16_t		ti_len;
	u_int16_t		ti_idx;
#endif
#if BYTE_ORDER == BIG_ENDIAN
	u_int16_t		ti_type;
	u_int16_t		ti_flags;
#else
	u_int16_t		ti_flags;
	u_int16_t		ti_type;
#endif
#if BYTE_ORDER == BIG_ENDIAN
	u_int16_t		ti_ip_cksum;
	u_int16_t		ti_tcp_udp_cksum;
#else
	u_int16_t		ti_tcp_udp_cksum;
	u_int16_t		ti_ip_cksum;
#endif
#if BYTE_ORDER == BIG_ENDIAN
	u_int16_t		ti_error_flags;
	u_int16_t		ti_vlan_tag;
#else
	u_int16_t		ti_vlan_tag;
	u_int16_t		ti_error_flags;
#endif
	u_int32_t		ti_rsvd;
	u_int32_t		ti_opaque;
};

struct ti_rx_desc_ext {
	ti_hostaddr		ti_addr1;
	ti_hostaddr		ti_addr2;
	ti_hostaddr		ti_addr3;
#if BYTE_ORDER == BIG_ENDIAN
	u_int16_t		ti_len1;
	u_int16_t		ti_len2;
#else
	u_int16_t		ti_len2;
	u_int16_t		ti_len1;
#endif
#if BYTE_ORDER == BIG_ENDIAN
	u_int16_t		ti_len3;
	u_int16_t		ti_rsvd0;
#else
	u_int16_t		ti_rsvd0;
	u_int16_t		ti_len3;
#endif
	ti_hostaddr		ti_addr0;
#if BYTE_ORDER == BIG_ENDIAN
	u_int16_t		ti_idx;
	u_int16_t		ti_len0;
#else
	u_int16_t		ti_len0;
	u_int16_t		ti_idx;
#endif
#if BYTE_ORDER == BIG_ENDIAN
	u_int16_t		ti_type;
	u_int16_t		ti_flags;
#else
	u_int16_t		ti_flags;
	u_int16_t		ti_type;
#endif
#if BYTE_ORDER == BIG_ENDIAN
	u_int16_t		ti_ip_cksum;
	u_int16_t		ti_tcp_udp_cksum;
#else
	u_int16_t		ti_tcp_udp_cksum;
	u_int16_t		ti_ip_cksum;
#endif
#if BYTE_ORDER == BIG_ENDIAN
	u_int16_t		ti_error_flags;
	u_int16_t		ti_vlan_tag;
#else
	u_int16_t		ti_vlan_tag;
	u_int16_t		ti_error_flags;
#endif
	u_int32_t		ti_rsvd1;
	u_int32_t		ti_opaque;
};

/*
 * Transmit descriptors are, mercifully, very small.
 */
struct ti_tx_desc {
	ti_hostaddr		ti_addr;
#if BYTE_ORDER == BIG_ENDIAN
	u_int16_t		ti_len;
	u_int16_t		ti_flags;
#else
	u_int16_t		ti_flags;
	u_int16_t		ti_len;
#endif
#if BYTE_ORDER == BIG_ENDIAN
	u_int16_t		ti_rsvd;
	u_int16_t		ti_vlan_tag;
#else
	u_int16_t		ti_vlan_tag;
	u_int16_t		ti_rsvd;
#endif
};

/*
 * NOTE!  On the Alpha, we have an alignment constraint.
 * The first thing in the packet is a 14-byte Ethernet header.
 * This means that the packet is misaligned.  To compensate,
 * we actually offset the data 2 bytes into the cluster.  This
 * alignes the packet after the Ethernet header at a 32-bit
 * boundary.
 */

#define TI_JUMBO_FRAMELEN	9018
#define TI_JUMBO_MTU		(TI_JUMBO_FRAMELEN - ETHER_HDR_LEN - ETHER_CRC_LEN)
#define TI_PAGE_SIZE		PAGE_SIZE

/*
 * Buffer descriptor error flags.
 */
#define TI_BDERR_CRC			0x0001
#define TI_BDERR_COLLDETECT		0x0002
#define TI_BDERR_LINKLOST		0x0004
#define TI_BDERR_DECODE			0x0008
#define TI_BDERR_ODD_NIBBLES		0x0010
#define TI_BDERR_MAC_ABRT		0x0020
#define TI_BDERR_RUNT			0x0040
#define TI_BDERR_TRUNC			0x0080
#define TI_BDERR_GIANT			0x0100

/*
 * Buffer descriptor flags.
 */
#define TI_BDFLAG_TCP_UDP_CKSUM		0x0001
#define TI_BDFLAG_IP_CKSUM		0x0002
#define TI_BDFLAG_END			0x0004
#define TI_BDFLAG_MORE			0x0008
#define TI_BDFLAG_JUMBO_RING		0x0010
#define TI_BDFLAG_UCAST_PKT		0x0020
#define TI_BDFLAG_MCAST_PKT		0x0040
#define TI_BDFLAG_BCAST_PKT		0x0060
#define TI_BDFLAG_IP_FRAG		0x0080
#define TI_BDFLAG_IP_FRAG_END		0x0100
#define TI_BDFLAG_VLAN_TAG		0x0200
#define TI_BDFLAG_ERROR			0x0400
#define TI_BDFLAG_COAL_NOW		0x0800
#define	TI_BDFLAG_MINI_RING		0x1000

/*
 * Descriptor type flags. I think these only have meaning for
 * the Tigon 1. I had to extract them from the sample driver source
 * since they aren't in the manual.
 */
#define TI_BDTYPE_TYPE_NULL			0x0000
#define TI_BDTYPE_SEND_BD			0x0001
#define TI_BDTYPE_RECV_BD			0x0002
#define TI_BDTYPE_RECV_JUMBO_BD			0x0003
#define TI_BDTYPE_RECV_BD_LAST			0x0004
#define TI_BDTYPE_SEND_DATA			0x0005
#define TI_BDTYPE_SEND_DATA_LAST		0x0006
#define TI_BDTYPE_RECV_DATA			0x0007
#define TI_BDTYPE_RECV_DATA_LAST		0x000b
#define TI_BDTYPE_EVENT_RUPT			0x000c
#define TI_BDTYPE_EVENT_NO_RUPT			0x000d
#define TI_BDTYPE_ODD_START			0x000e
#define TI_BDTYPE_UPDATE_STATS			0x000f
#define TI_BDTYPE_SEND_DUMMY_DMA		0x0010
#define TI_BDTYPE_EVENT_PROD			0x0011
#define TI_BDTYPE_TX_CONS			0x0012
#define TI_BDTYPE_RX_PROD			0x0013
#define TI_BDTYPE_REFRESH_STATS			0x0014
#define TI_BDTYPE_SEND_DATA_LAST_VLAN		0x0015
#define TI_BDTYPE_SEND_DATA_COAL		0x0016
#define TI_BDTYPE_SEND_DATA_LAST_COAL		0x0017
#define TI_BDTYPE_SEND_DATA_LAST_VLAN_COAL	0x0018
#define TI_BDTYPE_TX_CONS_NO_INTR		0x0019

/*
 * Tigon command structure.
 */
struct ti_cmd_desc {
	u_int32_t		ti_cmdx;
};

#define TI_CMD_CMD(cmd) (((((cmd)->ti_cmdx)) >> 24) & 0xff)
#define TI_CMD_CODE(cmd) (((((cmd)->ti_cmdx)) >> 12) & 0xfff)
#define TI_CMD_IDX(cmd) ((((cmd)->ti_cmdx)) & 0xfff)

#define TI_CMD_HOST_STATE		0x01
#define TI_CMD_CODE_STACK_UP		0x01
#define TI_CMD_CODE_STACK_DOWN		0x02

/*
 * This command enables software address filtering. It's a workaround
 * for a bug in the Tigon 1 and not implemented for the Tigon 2.
 */
#define TI_CMD_FDR_FILTERING		0x02
#define TI_CMD_CODE_FILT_ENB		0x01
#define TI_CMD_CODE_FILT_DIS		0x02

#define TI_CMD_SET_RX_PROD_IDX		0x03 /* obsolete */
#define TI_CMD_UPDATE_GENCOM		0x04
#define TI_CMD_RESET_JUMBO_RING		0x05
#define TI_CMD_SET_PARTIAL_RX_CNT	0x06
#define TI_CMD_ADD_MCAST_ADDR		0x08 /* obsolete */
#define TI_CMD_DEL_MCAST_ADDR		0x09 /* obsolete */

#define TI_CMD_SET_PROMISC_MODE		0x0A
#define TI_CMD_CODE_PROMISC_ENB		0x01
#define TI_CMD_CODE_PROMISC_DIS		0x02

#define TI_CMD_LINK_NEGOTIATION		0x0B
#define TI_CMD_CODE_NEGOTIATE_BOTH	0x00
#define TI_CMD_CODE_NEGOTIATE_GIGABIT	0x01
#define TI_CMD_CODE_NEGOTIATE_10_100	0x02

#define TI_CMD_SET_MAC_ADDR		0x0C
#define TI_CMD_CLR_PROFILE		0x0D

#define TI_CMD_SET_ALLMULTI		0x0E
#define TI_CMD_CODE_ALLMULTI_ENB	0x01
#define TI_CMD_CODE_ALLMULTI_DIS	0x02

#define TI_CMD_CLR_STATS		0x0F
#define TI_CMD_SET_RX_JUMBO_PROD_IDX	0x10 /* obsolete */
#define TI_CMD_RFRSH_STATS		0x11

#define TI_CMD_EXT_ADD_MCAST		0x12
#define TI_CMD_EXT_DEL_MCAST		0x13

/*
 * Utility macros to make issuing commands a little simpler. Assumes
 * that 'sc' and 'cmd' are in local scope.
 */
#define TI_DO_CMD(x, y, z)		\
	cmd.ti_cmdx = (((x) << 24) | ((y) << 12) | ((z))); \
	ti_cmd(sc, &cmd);

#define TI_DO_CMD_EXT(x, y, z, v, w)	\
	cmd.ti_cmdx = (((x) << 24) | ((y) << 12) | ((z))); \
	ti_cmd_ext(sc, &cmd, v, w);

/*
 * Other utility macros.
 */
#define TI_INC(x, y)	(x) = (x + 1) % y

#define TI_UPDATE_JUMBOPROD(x, y)					\
	if (x->ti_hwrev == TI_HWREV_TIGON) {				\
		TI_DO_CMD(TI_CMD_SET_RX_JUMBO_PROD_IDX, 0, y);	\
	} else {							\
		CSR_WRITE_4(x, TI_MB_JUMBORXPROD_IDX, y);		\
	}

#define TI_UPDATE_MINIPROD(x, y)					\
		CSR_WRITE_4(x, TI_MB_MINIRXPROD_IDX, y);

#define TI_UPDATE_STDPROD(x, y)						\
	if (x->ti_hwrev == TI_HWREV_TIGON) {				\
		TI_DO_CMD(TI_CMD_SET_RX_PROD_IDX, 0, y);		\
	} else {							\
		CSR_WRITE_4(x, TI_MB_STDRXPROD_IDX, y);			\
	}


/*
 * Tigon event structure.
 */
struct ti_event_desc {
	u_int32_t		ti_eventx;
	u_int32_t		ti_rsvd;
};

#define TI_EVENT_EVENT(e) (((((e)->ti_eventx)) >> 24) & 0xff)
#define TI_EVENT_CODE(e) (((((e)->ti_eventx)) >> 12) & 0xfff)
#define TI_EVENT_IDX(e) (((((e)->ti_eventx))) & 0xfff)

/*
 * Tigon events.
 */
#define TI_EV_FIRMWARE_UP		0x01
#define TI_EV_STATS_UPDATED		0x04

#define TI_EV_LINKSTAT_CHANGED		0x06
#define TI_EV_CODE_GIG_LINK_UP		0x01
#define TI_EV_CODE_LINK_DOWN		0x02
#define TI_EV_CODE_LINK_UP		0x03

#define TI_EV_ERROR			0x07
#define TI_EV_CODE_ERR_INVAL_CMD	0x01
#define TI_EV_CODE_ERR_UNIMP_CMD	0x02
#define TI_EV_CODE_ERR_BADCFG		0x03

#define TI_EV_MCAST_UPDATED		0x08
#define TI_EV_CODE_MCAST_ADD		0x01
#define TI_EV_CODE_MCAST_DEL		0x02

#define TI_EV_RESET_JUMBO_RING		0x09
/*
 * Register access macros. The Tigon always uses memory mapped register
 * accesses and all registers must be accessed with 32 bit operations.
 */

#define CSR_WRITE_4(sc, reg, val)	\
	bus_space_write_4(sc->ti_btag, sc->ti_bhandle, (reg), (val))

#define CSR_READ_4(sc, reg)		\
	bus_space_read_4(sc->ti_btag, sc->ti_bhandle, (reg))

#define TI_SETBIT(sc, reg, x)	\
	CSR_WRITE_4(sc, (reg), (CSR_READ_4(sc, (reg)) | (x)))
#define TI_CLRBIT(sc, reg, x)	\
	CSR_WRITE_4(sc, (reg), (CSR_READ_4(sc, (reg)) & ~(x)))

/*
 * Memory management stuff. Note: the SSLOTS, MSLOTS and JSLOTS
 * values are tuneable. They control the actual amount of buffers
 * allocated for the standard, mini and jumbo receive rings.
 */

#define TI_SSLOTS	256
#define TI_MSLOTS	256
#define TI_JSLOTS	384

#define TI_JRAWLEN	(TI_JUMBO_FRAMELEN + ETHER_ALIGN)
#define TI_JLEN		(TI_JRAWLEN + (sizeof(u_int64_t) - \
       (TI_JRAWLEN % sizeof(u_int64_t))))
#define TI_JPAGESZ	PAGE_SIZE
#define TI_RESID	(TI_JPAGESZ - (TI_JLEN * TI_JSLOTS) % TI_JPAGESZ)
#define TI_JMEM		((TI_JLEN * TI_JSLOTS) + TI_RESID)

struct ti_jslot {
	caddr_t			ti_buf;
	int			ti_inuse;
};

/*
 * Ring structures. Most of these reside in host memory and we tell
 * the NIC where they are via the ring control blocks. The exceptions
 * are the tx and command rings, which live in NIC memory and which
 * we access via the shared memory window.
 */
struct ti_ring_data {
	struct ti_rx_desc	ti_rx_std_ring[TI_STD_RX_RING_CNT];
	struct ti_rx_desc	ti_rx_jumbo_ring[TI_JUMBO_RX_RING_CNT];
	struct ti_rx_desc	ti_rx_mini_ring[TI_MINI_RX_RING_CNT];
	struct ti_rx_desc	ti_rx_return_ring[TI_RETURN_RING_CNT];
	struct ti_event_desc	ti_event_ring[TI_EVENT_RING_CNT];
	struct ti_tx_desc	ti_tx_ring[TI_TX_RING_CNT];

	/*
	 * Make sure producer structures are aligned on 32-byte cache
	 * line boundaries.
	 */
	struct ti_producer	ti_ev_prodidx_r;
	u_int32_t		ti_pad0[6];
	struct ti_producer	ti_return_prodidx_r;
	u_int32_t		ti_pad1[6];
	struct ti_producer	ti_tx_considx_r;
	u_int32_t		ti_pad2[6];
	struct ti_gib		ti_info;
};

#define TI_RING_DMA_ADDR(sc, offset) \
	((sc)->ti_ring_map->dm_segs[0].ds_addr + \
	offsetof(struct ti_ring_data, offset))

#define TI_RING_DMASYNC(sc, offset, op) \
	bus_dmamap_sync((sc)->sc_dmatag, (sc)->ti_ring_map, \
			offsetof(struct ti_ring_data, offset), \
			sizeof(((struct ti_ring_data *)0)->offset), (op))

/*
 * Number of DMA segments in a TxCB. Note that this is carefully
 * chosen to make the total struct size an even power of two. It's
 * critical that no TxCB be split across a page boundry since
 * no attempt is made to allocate physically contiguous memory.
 * 
 */
#ifdef __LP64__
#define TI_NTXSEG      30
#else
#define TI_NTXSEG      31
#endif

struct ti_txmap_entry {
	bus_dmamap_t			dmamap;
	SLIST_ENTRY(ti_txmap_entry)	link;
};

/*
 * Mbuf pointers. We need these to keep track of the virtual addresses
 * of our mbuf chains since we can only convert from physical to virtual,
 * not the other way around.
 */
struct ti_chain_data {
	struct mbuf		*ti_tx_chain[TI_TX_RING_CNT];
	struct mbuf		*ti_rx_std_chain[TI_STD_RX_RING_CNT];
	struct mbuf		*ti_rx_jumbo_chain[TI_JUMBO_RX_RING_CNT];
	struct mbuf		*ti_rx_mini_chain[TI_MINI_RX_RING_CNT];

	struct ti_txmap_entry	*ti_tx_map[TI_TX_RING_CNT];
	bus_dmamap_t		ti_rx_std_map[TI_STD_RX_RING_CNT];
	bus_dmamap_t		ti_rx_jumbo_map;
	bus_dmamap_t		ti_rx_mini_map[TI_MINI_RX_RING_CNT];

	/* Stick the jumbo mem management stuff here too. */
	struct ti_jslot		ti_jslots[TI_JSLOTS];
	void			*ti_jumbo_buf;
};

#define TI_JUMBO_DMA_ADDR(sc, m) \
	((sc)->ti_cdata.ti_rx_jumbo_map->dm_segs[0].ds_addr + \
	 (mtod((m), char *) - (char *)(sc)->ti_cdata.ti_jumbo_buf))

struct ti_type {
	u_int16_t		ti_vid;
	u_int16_t		ti_did;
	char			*ti_name;
};

#define TI_HWREV_TIGON		0x01
#define TI_HWREV_TIGON_II	0x02
#define TI_TIMEOUT		1000
#define TI_TXCONS_UNSET		0xFFFF	/* impossible value */

struct ti_mc_entry {
	struct ether_addr		mc_addr;
	SLIST_ENTRY(ti_mc_entry)	mc_entries;
};

struct ti_jpool_entry {
	int                             slot;
	SLIST_ENTRY(ti_jpool_entry)	jpool_entries;
};

struct ti_softc {
	struct device		sc_dv;
	struct arpcom		arpcom;		/* interface info */
	bus_space_handle_t	ti_bhandle;
	bus_space_tag_t		ti_btag;
	void *			ti_intrhand;
	struct ifmedia		ifmedia;	/* media info */
	u_int8_t		ti_hwrev;	/* Tigon rev (1 or 2) */
	u_int8_t		ti_copper;	/* 1000baseTX card */
	u_int8_t		ti_linkstat;	/* Link state */
	bus_dma_tag_t		sc_dmatag;
	struct ti_ring_data	*ti_rdata;	/* rings */
	struct ti_chain_data	ti_cdata;	/* mbufs */
#define ti_ev_prodidx		ti_rdata->ti_ev_prodidx_r
#define ti_return_prodidx	ti_rdata->ti_return_prodidx_r
#define ti_tx_considx		ti_rdata->ti_tx_considx_r
	struct ti_tx_desc	*ti_tx_ring_nic;/* pointer to shared mem */
	bus_dmamap_t		ti_ring_map;
	u_int16_t		ti_tx_saved_prodidx;
	u_int16_t		ti_tx_saved_considx;
	u_int16_t		ti_rx_saved_considx;
	u_int16_t		ti_ev_saved_considx;
	u_int16_t		ti_cmd_saved_prodidx;
	u_int16_t		ti_std;		/* current std ring head */
	u_int16_t		ti_mini;	/* current mini ring head */
	u_int16_t		ti_jumbo;	/* current jumo ring head */
	SLIST_HEAD(__ti_mchead, ti_mc_entry)	ti_mc_listhead;
	SLIST_HEAD(__ti_jfreehead, ti_jpool_entry)	ti_jfree_listhead;
	SLIST_HEAD(__ti_jinusehead, ti_jpool_entry)	ti_jinuse_listhead;
	SLIST_HEAD(__ti_txmaphead, ti_txmap_entry)	ti_tx_map_listhead;
	u_int32_t		ti_stat_ticks;
	u_int32_t		ti_rx_coal_ticks;
	u_int32_t		ti_tx_coal_ticks;
	u_int32_t		ti_rx_max_coal_bds;
	u_int32_t		ti_tx_max_coal_bds;
	u_int32_t		ti_tx_buf_ratio;
	int			ti_if_flags;
	int			ti_txcnt;
};

/*
 * Microchip Technology 24Cxx EEPROM control bytes
 */
#define EEPROM_CTL_READ			0xA1	/* 0101 0001 */
#define EEPROM_CTL_WRITE		0xA0	/* 0101 0000 */

/*
 * Note that EEPROM_START leaves transmission enabled.
 */
#define EEPROM_START							\
	TI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK); /* Pull clock pin high */\
	TI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_DOUT); /* Set DATA bit to 1 */	\
	TI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN); /* Enable xmit to write bit */\
	TI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_DOUT); /* Pull DATA bit to 0 again */\
	TI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK); /* Pull clock low again */

/*
 * EEPROM_STOP ends access to the EEPROM and clears the ETXEN bit so
 * that no further data can be written to the EEPROM I/O pin.
 */
#define EEPROM_STOP							\
	TI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN); /* Disable xmit */	\
	TI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_DOUT); /* Pull DATA to 0 */	\
	TI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK); /* Pull clock high */	\
	TI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN); /* Enable xmit */	\
	TI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_DOUT); /* Toggle DATA to 1 */	\
	TI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN); /* Disable xmit. */	\
	TI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK); /* Pull clock low again */
@


1.25
log
@remove the sparc64 workarounds for the jumbo frame receive ring sizes now
that the iommu code has been fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.24 2006/07/18 01:24:46 brad Exp $	*/
@


1.24
log
@increase the number of Jumbo slots a little bit for sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.23 2006/05/28 00:20:21 brad Exp $	*/
a993 3
#ifdef __sparc64__
#define TI_JSLOTS	57
#else
a994 1
#endif
@


1.23
log
@- remove ETHER_MAX_LEN_JUMBO and ETHERMTU_JUMBO.
- use if_hardmtu for MTU ioctl handlers.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.22 2006/03/16 02:23:53 brad Exp $	*/
d786 1
a786 1
#define TI_JUMBO_MTU		(TI_JUMBO_FRAMELEN-ETHER_HDR_LEN-ETHER_CRC_LEN)
a787 1
#define TI_MIN_FRAMELEN		60
d995 1
a995 1
#define TI_JSLOTS	54
@


1.22
log
@tidy up a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.21 2006/01/16 01:47:39 brad Exp $	*/
d785 2
d1001 1
a1001 1
#define TI_JRAWLEN	(ETHER_MAX_LEN_JUMBO + ETHER_ALIGN)
@


1.21
log
@Cache the TX producer index instead of reading it every time ti_start is
called.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.20 2005/10/09 20:07:32 brad Exp $	*/
d316 9
@


1.20
log
@special case sparc64 for now and lower the Jumbo slots
down from 384 to 54.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.19 2005/10/09 19:41:11 brad Exp $	*/
d1120 1
@


1.19
log
@remove ETHER_CRC_LEN and ETHER_HDR_LEN
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.18 2005/07/03 02:04:15 brad Exp $	*/
d984 3
d988 1
@


1.18
log
@- when printing the "unsupported chip revision" message also print the
chip revision.
- allow VLAN-sized frames even when not using hardware VLAN support. From FreeBSD
- disestablish PCI interrupt on failure to attach.
- allow reception of Jumbo frames by default. Based on a diff sent to me a long time
ago by mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.17 2005/05/27 00:15:21 pvalchev Exp $	*/
a1164 8

#ifndef ETHER_CRC_LEN
#define ETHER_CRC_LEN	4
#endif

#ifndef ETHER_HDR_LEN
#define	ETHER_HDR_LEN	14
#endif
@


1.17
log
@remove vtophys hack (for alpha) which this driver no longer uses
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.16 2004/11/02 21:18:48 miod Exp $	*/
a110 1
#define TI_MLC_SRAM_BANK_256K		0x00000200
d119 6
@


1.16
log
@#ifdef __alpha__ -> #ifdef __LP64__
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.15 2004/08/05 19:57:17 brad Exp $	*/
a1159 5

#ifdef __alpha__
#undef vtophys
#define vtophys(va)	alpha_XXX_dmamap((vm_offset_t)va)
#endif
@


1.15
log
@remove some separate per driver constants and use
ETHER_MAX_LEN_JUMBO/ETHERMTU_JUMBO where appropriate.

ok mcbride@@ henning@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.14 2004/05/19 11:37:00 brad Exp $	*/
d1036 1
a1036 1
#ifdef __alpha__ /* XXX - should be conditional on pointer size */
@


1.14
log
@remove duplication, use ETHER_ALIGN from if_ether.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.13 2003/02/26 19:02:50 nate Exp $	*/
a770 3
#define TI_FRAMELEN		1518
#define TI_JUMBO_FRAMELEN	9018
#define TI_JUMBO_MTU		(TI_JUMBO_FRAMELEN-ETHER_HDR_LEN-ETHER_CRC_LEN)
d981 1
a981 1
#define TI_JRAWLEN	(TI_JUMBO_FRAMELEN + ETHER_ALIGN)
@


1.13
log
@don't do arithmetic on bus space handles.  Instead, use bus_space functions
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.12 2002/12/04 17:32:30 nate Exp $	*/
a769 2

#define ETHER_ALIGN 2
@


1.12
log
@Make ti(4) use busdma and add all of the necessary stuff to support both
endian modes.  This makes ti now work on macppc and sparc64.
While we're at ti, clean up a bit of the code:
  Use SLIST instead of LIST
  Remove register
  Use bus_space instead of bcopy/bzero
  Don't use bitfields since it makes dealing with endianness annoying.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.11 2002/10/04 01:25:21 jason Exp $	*/
a388 6
#ifdef __64_bit_pci_addressing__ 
typedef struct {
	u_int64_t		ti_addr;
} ti_hostaddr;
#define TI_HOSTADDR(x)	x.ti_addr
#else
a393 1
#endif
a1114 1
	struct ti_cmd_desc	*ti_cmd_ring;	/* pointer to shared mem */
@


1.11
log
@More OpenBSDism's (vs FreeBSDisms).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.10 2002/10/03 23:50:07 jason Exp $	*/
a56 33
 * Alteon AceNIC PCI vendor/device ID.
 */
#define ALT_VENDORID			0x12AE
#define ALT_DEVICEID_ACENIC		0x0001
#define ALT_DEVICEID_ACENIC_COPPER	0x0002

/*
 * 3Com 3c985 PCI vendor/device ID.
 */
#define TC_VENDORID			0x10B7
#define TC_DEVICEID_3C985		0x0001

/*
 * Netgear GA620 PCI vendor/device ID.
 */
#define NG_VENDORID			0x1385
#define NG_DEVICEID_GA620		0x620A
#define NG_DEVICEID_GA620T		0x630A

/*
 * SGI device/vendor ID.
 */
#define SGI_VENDORID			0x10A9
#define SGI_DEVICEID_TIGON		0x0009

/*
 * DEC vendor ID, Farallon device ID. Apparently, Farallon used
 * the DEC vendor ID in their cards by mistake.
 */
#define DEC_VENDORID			0x1011
#define DEC_DEVICEID_FARALLON_PN9000SX	0x001a

/*
d282 1
a282 1
#define TI_GCR_NIC_ADDR(x)		(x - TI_GCR_BASE);
d850 1
a850 9
#if BYTE_ORDER == BIG_ENDIAN
	u_int32_t		ti_cmd:8;
	u_int32_t		ti_code:12;
	u_int32_t		ti_idx:12;
#else
	u_int32_t		ti_idx:12;
	u_int32_t		ti_code:12;
	u_int32_t		ti_cmd:8;
#endif
d853 4
d904 1
a904 3
	cmd.ti_cmd = x;			\
	cmd.ti_code = y;		\
	cmd.ti_idx = z;			\
d908 1
a908 3
	cmd.ti_cmd = x;			\
	cmd.ti_code = y;		\
	cmd.ti_idx = z;			\
d938 1
a938 9
#if BYTE_ORDER == BIG_ENDIAN
	u_int32_t		ti_event:8;
	u_int32_t		ti_code:12;
	u_int32_t		ti_idx:12;
#else
	u_int32_t		ti_idx:12;
	u_int32_t		ti_code:12;
	u_int32_t		ti_event:8;
#endif
d942 4
d973 1
a973 1
	bus_space_write_4(sc->ti_btag, sc->ti_bhandle, reg, val)
d976 1
a976 1
	bus_space_read_4(sc->ti_btag, sc->ti_bhandle, reg)
d979 1
a979 1
	CSR_WRITE_4(sc, reg, (CSR_READ_4(sc, reg) | x))
d981 1
a981 1
	CSR_WRITE_4(sc, reg, (CSR_READ_4(sc, reg) & ~x))
d994 2
a995 1
#define TI_JLEN		TI_JRAWLEN
d1018 1
a1028 2
	struct ti_tx_desc	*ti_tx_ring_nic;/* pointer to shared mem */
	struct ti_cmd_desc	*ti_cmd_ring;	/* pointer to shared mem */
d1032 27
d1069 6
d1080 4
d1097 1
a1097 1
	LIST_ENTRY(ti_mc_entry)		mc_entries;
d1102 1
a1102 1
	LIST_ENTRY(ti_jpool_entry)	jpool_entries;
d1121 3
d1131 4
a1134 3
	LIST_HEAD(__ti_mchead, ti_mc_entry)	ti_mc_listhead;
	LIST_HEAD(__ti_jfreehead, ti_jpool_entry)	ti_jfree_listhead;
	LIST_HEAD(__ti_jinusehead, ti_jpool_entry)	ti_jinuse_listhead;
@


1.10
log
@Use our defn of pci command registers, not freebsd's
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.9 2000/11/21 03:50:48 jason Exp $	*/
d47 6
a52 6
#define TI_PCI_ID			0x000 /* PCI device/vendor ID */
#define TI_PCI_CMDSTAT			0x004
#define TI_PCI_CLASSCODE		0x008
#define TI_PCI_BIST			0x00C
#define TI_PCI_LOMEM			0x010 /* Shared memory base address */
#define TI_PCI_SUBSYS			0x02C
d54 1
a54 1
#define TI_PCI_INT			0x03C
@


1.9
log
@From FreeBSD:
add support for the acenic copper and netgear ga620t (untested).
This also updates the firmware to 12.4.13 for tigon 1, and
12.4.11+wpaul hacks for tigon 2
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.8 2000/06/07 05:35:03 jason Exp $	*/
a54 4

#ifndef PCIM_CMD_MWIEN
#define PCIM_CMD_MWIEN			0x0010
#endif
@


1.9.6.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.9 2000/11/21 03:50:48 jason Exp $	*/
d47 6
a52 6
#define TI_PCI_ID			PCI_ID_REG /* PCI device/vendor ID */
#define TI_PCI_CMDSTAT			PCI_COMMAND_STATUS_REG
#define TI_PCI_CLASSCODE		PCI_CLASS_REG
#define TI_PCI_BIST			PCI_BHLC_REG
#define TI_PCI_LOMEM			PCI_MAPS /* Shared memory base address */
#define TI_PCI_SUBSYS			PCI_SUBVEND_0
d54 5
a58 1
#define TI_PCI_INT			PCI_INTLINE
@


1.9.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 33
d315 1
a315 1
#define TI_GCR_NIC_ADDR(x)		(x - TI_GCR_BASE)
d422 6
d433 1
d883 9
a891 1
	u_int32_t		ti_cmdx;
a893 4
#define TI_CMD_CMD(cmd) (((((cmd)->ti_cmdx)) >> 24) & 0xff)
#define TI_CMD_CODE(cmd) (((((cmd)->ti_cmdx)) >> 12) & 0xfff)
#define TI_CMD_IDX(cmd) ((((cmd)->ti_cmdx)) & 0xfff)

d941 3
a943 1
	cmd.ti_cmdx = (((x) << 24) | ((y) << 12) | ((z))); \
d947 3
a949 1
	cmd.ti_cmdx = (((x) << 24) | ((y) << 12) | ((z))); \
d979 9
a987 1
	u_int32_t		ti_eventx;
a990 4
#define TI_EVENT_EVENT(e) (((((e)->ti_eventx)) >> 24) & 0xff)
#define TI_EVENT_CODE(e) (((((e)->ti_eventx)) >> 12) & 0xfff)
#define TI_EVENT_IDX(e) (((((e)->ti_eventx))) & 0xfff)

d1018 1
a1018 1
	bus_space_write_4(sc->ti_btag, sc->ti_bhandle, (reg), (val))
d1021 1
a1021 1
	bus_space_read_4(sc->ti_btag, sc->ti_bhandle, (reg))
d1024 1
a1024 1
	CSR_WRITE_4(sc, (reg), (CSR_READ_4(sc, (reg)) | (x)))
d1026 1
a1026 1
	CSR_WRITE_4(sc, (reg), (CSR_READ_4(sc, (reg)) & ~(x)))
d1039 1
a1039 2
#define TI_JLEN		(TI_JRAWLEN + (sizeof(u_int64_t) - \
       (TI_JRAWLEN % sizeof(u_int64_t))))
a1061 1

d1072 2
a1076 27
#define TI_RING_DMA_ADDR(sc, offset) \
	((sc)->ti_ring_map->dm_segs[0].ds_addr + \
	offsetof(struct ti_ring_data, offset))

#define TI_RING_DMASYNC(sc, offset, op) \
	bus_dmamap_sync((sc)->sc_dmatag, (sc)->ti_ring_map, \
			offsetof(struct ti_ring_data, offset), \
			sizeof(((struct ti_ring_data *)0)->offset), (op))

/*
 * Number of DMA segments in a TxCB. Note that this is carefully
 * chosen to make the total struct size an even power of two. It's
 * critical that no TxCB be split across a page boundry since
 * no attempt is made to allocate physically contiguous memory.
 * 
 */
#ifdef __alpha__ /* XXX - should be conditional on pointer size */
#define TI_NTXSEG      30
#else
#define TI_NTXSEG      31
#endif

struct ti_txmap_entry {
	bus_dmamap_t			dmamap;
	SLIST_ENTRY(ti_txmap_entry)	link;
};

a1086 6

	struct ti_txmap_entry	*ti_tx_map[TI_TX_RING_CNT];
	bus_dmamap_t		ti_rx_std_map[TI_STD_RX_RING_CNT];
	bus_dmamap_t		ti_rx_jumbo_map;
	bus_dmamap_t		ti_rx_mini_map[TI_MINI_RX_RING_CNT];

a1091 4
#define TI_JUMBO_DMA_ADDR(sc, m) \
	((sc)->ti_cdata.ti_rx_jumbo_map->dm_segs[0].ds_addr + \
	 (mtod((m), char *) - (char *)(sc)->ti_cdata.ti_jumbo_buf))

d1105 1
a1105 1
	SLIST_ENTRY(ti_mc_entry)	mc_entries;
d1110 1
a1110 1
	SLIST_ENTRY(ti_jpool_entry)	jpool_entries;
a1128 2
	struct ti_tx_desc	*ti_tx_ring_nic;/* pointer to shared mem */
	bus_dmamap_t		ti_ring_map;
d1136 3
a1138 4
	SLIST_HEAD(__ti_mchead, ti_mc_entry)	ti_mc_listhead;
	SLIST_HEAD(__ti_jfreehead, ti_jpool_entry)	ti_jfree_listhead;
	SLIST_HEAD(__ti_jinusehead, ti_jpool_entry)	ti_jinuse_listhead;
	SLIST_HEAD(__ti_txmaphead, ti_txmap_entry)	ti_tx_map_listhead;
@


1.8
log
@from freebsd(wpaul):
Update the Tigon firmware to 12.3.21. This fixes a few bugs and adds support
for cards with 2MB of on-board SRAM.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.7 2000/03/15 03:56:49 todd Exp $	*/
d65 1
d78 1
d141 2
a142 2
#define TI_FIRMWARE_MINOR		0x3
#define TI_FIRMWARE_FIX			0x15
d1040 1
a1040 1
#define TI_JSLOTS	256
d1125 1
@


1.7
log
@implimented -> implemented
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.6 2000/02/15 03:56:27 jason Exp $	*/
d140 1
a140 1
#define TI_FIRMWARE_FIX			0x12
@


1.6
log
@update ti firmware to 12.3.18
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.5 2000/01/18 05:26:25 jason Exp $	*/
d335 1
a335 1
#define TI_OPMODE_WARN_ENB		0x00000008 /* not yet implimented */
d345 1
a345 1
#define TI_OPMODE_FATAL_ENB		0x40000000 /* not yet implimented */
@


1.5
log
@sync with FreeBSD: add Farallon PN9000SX as a match
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.4 1999/10/25 19:39:19 jason Exp $	*/
d140 1
a140 1
#define TI_FIRMWARE_FIX			0xf
@


1.5.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.6 2000/02/15 03:56:27 jason Exp $	*/
d140 1
a140 1
#define TI_FIRMWARE_FIX			0x12
@


1.5.2.2
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d335 1
a335 1
#define TI_OPMODE_WARN_ENB		0x00000008 /* not yet implemented */
d345 1
a345 1
#define TI_OPMODE_FATAL_ENB		0x40000000 /* not yet implemented */
@


1.5.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.9 2000/11/21 03:50:48 jason Exp $	*/
a64 1
#define ALT_DEVICEID_ACENIC_COPPER	0x0002
a76 1
#define NG_DEVICEID_GA620T		0x630A
d139 2
a140 2
#define TI_FIRMWARE_MINOR		0x4
#define TI_FIRMWARE_FIX			0xd
d1038 1
a1038 1
#define TI_JSLOTS	384
a1122 1
	u_int8_t		ti_copper;	/* 1000baseTX card */
@


1.5.2.4
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 6
a52 6
#define TI_PCI_ID			PCI_ID_REG /* PCI device/vendor ID */
#define TI_PCI_CMDSTAT			PCI_COMMAND_STATUS_REG
#define TI_PCI_CLASSCODE		PCI_CLASS_REG
#define TI_PCI_BIST			PCI_BHLC_REG
#define TI_PCI_LOMEM			PCI_MAPS /* Shared memory base address */
#define TI_PCI_SUBSYS			PCI_SUBVEND_0
d54 38
a91 1
#define TI_PCI_INT			PCI_INTLINE
d319 1
a319 1
#define TI_GCR_NIC_ADDR(x)		(x - TI_GCR_BASE)
d426 6
d437 1
d887 9
a895 1
	u_int32_t		ti_cmdx;
a897 4
#define TI_CMD_CMD(cmd) (((((cmd)->ti_cmdx)) >> 24) & 0xff)
#define TI_CMD_CODE(cmd) (((((cmd)->ti_cmdx)) >> 12) & 0xfff)
#define TI_CMD_IDX(cmd) ((((cmd)->ti_cmdx)) & 0xfff)

d945 3
a947 1
	cmd.ti_cmdx = (((x) << 24) | ((y) << 12) | ((z))); \
d951 3
a953 1
	cmd.ti_cmdx = (((x) << 24) | ((y) << 12) | ((z))); \
d983 9
a991 1
	u_int32_t		ti_eventx;
a994 4
#define TI_EVENT_EVENT(e) (((((e)->ti_eventx)) >> 24) & 0xff)
#define TI_EVENT_CODE(e) (((((e)->ti_eventx)) >> 12) & 0xfff)
#define TI_EVENT_IDX(e) (((((e)->ti_eventx))) & 0xfff)

d1022 1
a1022 1
	bus_space_write_4(sc->ti_btag, sc->ti_bhandle, (reg), (val))
d1025 1
a1025 1
	bus_space_read_4(sc->ti_btag, sc->ti_bhandle, (reg))
d1028 1
a1028 1
	CSR_WRITE_4(sc, (reg), (CSR_READ_4(sc, (reg)) | (x)))
d1030 1
a1030 1
	CSR_WRITE_4(sc, (reg), (CSR_READ_4(sc, (reg)) & ~(x)))
d1043 1
a1043 2
#define TI_JLEN		(TI_JRAWLEN + (sizeof(u_int64_t) - \
       (TI_JRAWLEN % sizeof(u_int64_t))))
a1065 1

d1076 2
a1080 27
#define TI_RING_DMA_ADDR(sc, offset) \
	((sc)->ti_ring_map->dm_segs[0].ds_addr + \
	offsetof(struct ti_ring_data, offset))

#define TI_RING_DMASYNC(sc, offset, op) \
	bus_dmamap_sync((sc)->sc_dmatag, (sc)->ti_ring_map, \
			offsetof(struct ti_ring_data, offset), \
			sizeof(((struct ti_ring_data *)0)->offset), (op))

/*
 * Number of DMA segments in a TxCB. Note that this is carefully
 * chosen to make the total struct size an even power of two. It's
 * critical that no TxCB be split across a page boundry since
 * no attempt is made to allocate physically contiguous memory.
 * 
 */
#ifdef __alpha__ /* XXX - should be conditional on pointer size */
#define TI_NTXSEG      30
#else
#define TI_NTXSEG      31
#endif

struct ti_txmap_entry {
	bus_dmamap_t			dmamap;
	SLIST_ENTRY(ti_txmap_entry)	link;
};

a1090 6

	struct ti_txmap_entry	*ti_tx_map[TI_TX_RING_CNT];
	bus_dmamap_t		ti_rx_std_map[TI_STD_RX_RING_CNT];
	bus_dmamap_t		ti_rx_jumbo_map;
	bus_dmamap_t		ti_rx_mini_map[TI_MINI_RX_RING_CNT];

a1095 4
#define TI_JUMBO_DMA_ADDR(sc, m) \
	((sc)->ti_cdata.ti_rx_jumbo_map->dm_segs[0].ds_addr + \
	 (mtod((m), char *) - (char *)(sc)->ti_cdata.ti_jumbo_buf))

d1109 1
a1109 1
	SLIST_ENTRY(ti_mc_entry)	mc_entries;
d1114 1
a1114 1
	SLIST_ENTRY(ti_jpool_entry)	jpool_entries;
a1132 2
	struct ti_tx_desc	*ti_tx_ring_nic;/* pointer to shared mem */
	bus_dmamap_t		ti_ring_map;
d1140 3
a1142 4
	SLIST_HEAD(__ti_mchead, ti_mc_entry)	ti_mc_listhead;
	SLIST_HEAD(__ti_jfreehead, ti_jpool_entry)	ti_jfree_listhead;
	SLIST_HEAD(__ti_jinusehead, ti_jpool_entry)	ti_jinuse_listhead;
	SLIST_HEAD(__ti_txmaphead, ti_txmap_entry)	ti_tx_map_listhead;
@


1.5.2.5
log
@Merge with the trunk
@
text
@d771 2
@


1.4
log
@use bus_dma instead of [u]vm_page_alloc_contig
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.3 1999/10/03 13:06:30 jason Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_tireg.h,v 1.11 1999/09/22 06:43:16 wpaul Exp $
d83 7
@


1.3
log
@take advantage of m->m_ext.ext_handle for storing the softc
(instead of stashing it in the buffer)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.2 1999/09/26 03:22:40 jason Exp $	*/
d1117 1
@


1.2
log
@openbsd-ify: remove statics
merge with freebsd:
clean up buffer allocation
fix call to m_adj() in ti_newbuf_jumbo()
align on i386 & alpha
make sure mbufs have sane values
upgrade to latest firmware: 12.3.15
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tireg.h,v 1.1 1999/07/25 16:51:55 jason Exp $	*/
d1033 5
a1037 6
#define TI_JRAWLEN (TI_JUMBO_FRAMELEN + ETHER_ALIGN + sizeof(u_int64_t))
#define TI_JLEN (TI_JRAWLEN + (sizeof(u_int64_t) - \
	(TI_JRAWLEN % sizeof(u_int64_t))))
#define TI_JPAGESZ PAGE_SIZE
#define TI_RESID (TI_JPAGESZ - (TI_JLEN * TI_JSLOTS) % TI_JPAGESZ)
#define TI_JMEM ((TI_JLEN * TI_JSLOTS) + TI_RESID)
@


1.1
log
@driver for the Tigon I & Tigon II gigabit ethernet chipsets written by
Bill Paul <wpaul@@freebsd.org>
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
 *	$FreeBSD: if_tireg.h,v 1.5 1999/07/05 20:19:41 wpaul Exp $
d133 1
a133 1
#define TI_FIRMWARE_FIX			0xa
a805 1
#ifdef __alpha__
a806 6
#endif

#ifdef __i386__
#define ETHER_ALIGN 0
#endif

d809 1
a809 1
#define TI_JUMBO_FRAMELEN	9018 + ETHER_ALIGN
d1033 1
a1033 1
#define TI_JRAWLEN (TI_JUMBO_FRAMELEN + sizeof(u_int64_t))
a1110 1
	void *			sc_ih;
d1114 1
a1117 1
	caddr_t			ti_rdata_ptr;	/* Raw ring data */
d1174 1
a1174 2
#define vtophys(va)     (pmap_kextract(((vm_offset_t) (va))) \
                         + 1*1024*1024*1024)
@

