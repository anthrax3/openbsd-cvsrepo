head	1.19;
access;
symbols
	OPENBSD_5_7:1.17.0.4
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.6
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.4
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.24
	OPENBSD_5_0:1.12.0.22
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.20
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.18
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.14
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.16
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.12
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.10
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.8
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.19
date	2015.04.09.18.58.22;	author deraadt;	state dead;
branches;
next	1.18;
commitid	cDamcqFPw3HffP51;

1.18
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.17;
commitid	p4LJxGKbi0BU2cG6;

1.17
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.16;
commitid	t9FBKDfc4VDxpEy2;

1.16
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.15;
commitid	uzzBR7hz9ncd4O6G;

1.15
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.14;
commitid	TGHgrLxu6sxZoiFt;

1.14
date	2013.11.18.23.36.09;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2012.04.11.17.42.53;	author mikeb;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.13.19.04.30;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.25.22.41.45;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.13.05.56.22;	author canacar;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.01.21.42.36;	author canacar;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.02.15.39.47;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.01.18.37.07;	author mcbride;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.07.06.10.24;	author mcbride;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.28.23.39.45;	author canacar;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.16.15.11.45;	author alex;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.26.22.48.14;	author mcbride;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.26.20.17.23;	author mcbride;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.26.06.42.33;	author alex;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Send lmc(4) and san(4) to the HDLC framed bit bucket in the sky.
@
text
@/*	$OpenBSD: if_san_obsd.c,v 1.18 2015/03/14 03:38:48 jsg Exp $	*/

/*-
 * Copyright (c) 2001-2004 Sangoma Technologies (SAN)
 * All rights reserved.  www.sangoma.com
 *
 * This code is written by Alex Feldman <al.feldman@@sangoma.com> for SAN.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following disclaimer
 *    in the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name of Sangoma Technologies nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY SANGOMA TECHNOLOGIES AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/syslog.h>
#include <sys/ioccom.h>
#include <sys/conf.h>
#include <sys/malloc.h>
#include <sys/errno.h>
#include <sys/exec.h>
#include <sys/mbuf.h>
#include <sys/sockio.h>
#include <sys/socket.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/time.h>
#include <sys/timeout.h>

#include "bpfilter.h"
#if NBPFILTER > 0
# include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_var.h>
#include <net/if_media.h>
#include <net/if_sppp.h>

#include <netinet/udp.h>
#include <netinet/ip.h>

#include <dev/pci/if_san_common.h>
#include <dev/pci/if_san_obsd.h>


#ifdef	_DEBUG_
#define	STATIC
#else
#define	STATIC		static
#endif

#define PPP_HEADER_LEN 4		/* should be globaly defined by sppp */


static sdla_t *wanpipe_generic_getcard(struct ifnet *);
static int wanpipe_generic_ioctl(struct ifnet *, u_long, caddr_t);
static void wanpipe_generic_watchdog(struct ifnet*);
static void wanpipe_generic_start(struct ifnet *);


static sdla_t *
wanpipe_generic_getcard(struct ifnet *ifp)
{
	sdla_t*	card;

	if (ifp->if_softc == NULL) {
		log(LOG_INFO, "%s: Invalid device private structure pointer\n",
				ifp->if_xname);
		return (NULL);
	}
	card = ((sdla_t*)((wanpipe_common_t*)ifp->if_softc)->card);
	if (card == NULL) {
		log(LOG_INFO, "%s: Invalid Sangoma device card\n",
		    ifp->if_xname);
		return (NULL);
	}
	return (card);
}

int
wanpipe_generic_name(sdla_t *card, char *ifname, int len)
{
	static int	ifunit = 0;

	snprintf(ifname, len, "san%d", ifunit++);
	return (0);
}

int
wanpipe_generic_register(sdla_t *card, struct ifnet *ifp, char *ifname)
{
	wanpipe_common_t*	common = WAN_IFP_TO_COMMON(ifp);

	if (ifname == NULL || strlen(ifname) > IFNAMSIZ)
		return (EINVAL);
	else
		bcopy(ifname, ifp->if_xname, strlen(ifname));

	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
	IFQ_SET_READY(&ifp->if_snd);
	ifp->if_mtu = PP_MTU;
	ifp->if_flags = IFF_POINTOPOINT | IFF_MULTICAST;
	common->protocol = IF_PROTO_CISCO;

	((struct sppp *)ifp)->pp_flags |= PP_CISCO;
	((struct sppp *)ifp)->pp_flags |= PP_KEEPALIVE;
	((struct sppp *)ifp)->pp_framebytes = 3;

	ifp->if_ioctl = wanpipe_generic_ioctl;	/* Will set from new_if() */
	ifp->if_start = wanpipe_generic_start;
	ifp->if_watchdog = wanpipe_generic_watchdog;

	if_attach(ifp);
	if_alloc_sadl(ifp);
	sppp_attach(ifp);

#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_PPP, PPP_HEADER_LEN);
#endif /* NBPFILTER > 0 */

	return (0);
}

void
wanpipe_generic_unregister(struct ifnet *ifp)
{
	log(LOG_INFO, "%s: Unregister interface!\n", ifp->if_xname);

	sppp_detach(ifp);
	if_free_sadl(ifp);
	if_detach(ifp);
}

static void
wanpipe_generic_start(struct ifnet *ifp)
{
	sdla_t		*card;
	struct mbuf	*opkt;
	int		 err = 0;

	if ((card = wanpipe_generic_getcard(ifp)) == NULL)
		return;

	while (1) {
		if (sppp_isempty(ifp)) {
			/* No more packets in send queue */
			break;
		}

		if ((opkt = sppp_dequeue(ifp)) == NULL) {
			/* Should never happened, packet pointer is NULL */
			break;
		}
		if (card->iface_send == NULL) {
			m_freem(opkt);
			break;
		}
		/* report the packet to BPF if present and attached */
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, opkt, BPF_DIRECTION_OUT);
#endif /* NBPFILTER > 0 */

		if (wan_mbuf_to_buffer(&opkt)) {
			m_freem(opkt);
			break;
		}

		err = card->iface_send(opkt, ifp);
		if (err)
			break;
	}
}


static int
wanpipe_generic_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct proc		*p = curproc;
	struct ifreq		*ifr = (struct ifreq*)data;
	sdla_t			*card;
	wanpipe_common_t*	common = WAN_IFP_TO_COMMON(ifp);
	struct if_settings	ifsettings;
	unsigned long		ts_map;
	int			err = 0, s;

	if ((card = wanpipe_generic_getcard(ifp)) == NULL)
		return (EINVAL);

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		// XXX because sppp does an implicit setflags
		log(LOG_INFO, "%s: Bringing interface up.\n",
		    ifp->if_xname);
		if (card->iface_up)
			card->iface_up(ifp);
		wanpipe_generic_start(ifp);
		err = 1;
		break;

	case SIOCSIFMEDIA:
		/* You can't set new media type while card is running */
		if (card->state != WAN_DISCONNECTED) {
			log(LOG_INFO, "%s: Unable to change media type!\n",
			    ifp->if_xname);
			err = EINVAL;
		} else
			err = ifmedia_ioctl(ifp, ifr, &common->ifm, cmd);
		goto ioctl_out;

	case SIOCGIFMEDIA:
		err = ifmedia_ioctl(ifp, ifr, &common->ifm, cmd);
		goto ioctl_out;

	case SIOCSIFTIMESLOT:
		if ((err = suser(p, 0)) != 0)
			goto ioctl_out;
		if (card->state != WAN_DISCONNECTED) {
			log(LOG_INFO, "%s: Unable to change timeslot map!\n",
			    ifp->if_xname);
			err = EINVAL;
			goto ioctl_out;
		}

		err = copyin(ifr->ifr_data, &ts_map, sizeof(ts_map));
		if (err == 0)
			sdla_te_settimeslot(card, ts_map);

		goto ioctl_out;

	case SIOCGIFTIMESLOT:
		ts_map = sdla_te_gettimeslot(card);
		err = copyout(ifr->ifr_data, &ts_map, sizeof(ts_map));
		goto ioctl_out;

	case SIOCSIFFLAGS:
	    	/*
     		** If the interface is marked up - enable communications. 
	     	** If down - disable communications.  IFF_UP is taken 
		** care of before entering this function.
	     	*/
		err = 1;
		if ((ifp->if_flags & IFF_UP) == 0) {
			if ((ifp->if_flags & IFF_RUNNING) == 0)
				break;
			/* bring it down */
			log(LOG_INFO, "%s: Bringing interface down.\n",
			    ifp->if_xname);
			if (card->iface_down)
				card->iface_down(ifp);
		} else { /* bring it up */ 
			if (ifp->if_flags & IFF_RUNNING)
				break;
			log(LOG_INFO, "%s: Bringing interface up.\n",
			    ifp->if_xname);
			if (card->iface_up)
				card->iface_up(ifp);
			wanpipe_generic_start(ifp);
		}
		break;

	case SIOC_WANPIPE_DEVICE:
		err = copyin(ifr->ifr_data, &ifsettings,
		    sizeof(struct if_settings));

		if (err) {
			log(LOG_INFO, "%s: Failed to copy from user space!\n",
						card->devname);
			goto ioctl_out;
		}

		switch (ifsettings.type) {
		case IF_GET_PROTO:
			ifsettings.type = common->protocol;
			err = copyout(&ifsettings, ifr->ifr_data,
			    sizeof(struct if_settings));
			if (err)
				log(LOG_INFO,
				    "%s: Failed to copy to uspace!\n",
				    card->devname);
			break;

		case IF_PROTO_CISCO:
		case IF_PROTO_PPP:
			if ((err = suser(p, 0)) != 0)
				goto ioctl_out;
			err = wp_lite_set_proto(ifp, (struct ifreq*)data);
			break;

		case IF_IFACE_T1:
		case IF_IFACE_E1:
			if ((err = suser(p, 0)) != 0)
				goto ioctl_out;
			err = wp_lite_set_te1_cfg(ifp, (struct ifreq*)data);
			break;

		default:
			if (card->iface_ioctl)
				err = card->iface_ioctl(ifp, cmd,
				    (struct ifreq*)data);
			break;
		}
		goto ioctl_out;

	default:
		if (card->iface_ioctl) {
			/* Argument seqeunce is change for Linux order */
			err = card->iface_ioctl(ifp, cmd, (struct ifreq*)data);
		}
		break;
	}

	if (err)
		err = sppp_ioctl(ifp, cmd, data);

ioctl_out:
	splx(s);
	return (err);
}

static void
wanpipe_generic_watchdog(struct ifnet *ifp)
{
	return;
}

int
wanpipe_generic_open(struct ifnet *ifp)
{
	return (0);
}

int
wanpipe_generic_close(struct ifnet *ifp)
{
	return (0);
}

int
wanpipe_generic_input(struct ifnet *ifp, struct mbuf *m)
{
	sdla_t		*card;
#if NBPFILTER > 0
#endif /* NBPFILTER > 0 */

	if ((card = wanpipe_generic_getcard(ifp)) == NULL) {
		return (-EINVAL);
	}
	m->m_pkthdr.rcvif = ifp;
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif /* NBPFILTER > 0 */
	ifp->if_ipackets ++;
	sppp_input(ifp, m);
	return (0);
}

int
wp_lite_set_proto(struct ifnet *ifp, struct ifreq *ifr)
{
	wanpipe_common_t	*common;
	struct if_settings	*ifsettings;
	int			 err = 0;

	if ((common = ifp->if_softc) == NULL) {
		log(LOG_INFO, "%s: Private structure is null!\n",
				ifp->if_xname);
		return (EINVAL);
	}

	ifsettings = (struct if_settings*) ifr->ifr_data;
	
	switch (ifsettings->type) {
	case IF_PROTO_CISCO:
		if (common->protocol == IF_PROTO_CISCO)
			return 0;
		((struct sppp *)ifp)->pp_flags |= PP_CISCO;
		((struct sppp *)ifp)->pp_flags |= PP_KEEPALIVE;
		common->protocol = IF_PROTO_CISCO;
		break;
	case IF_PROTO_PPP:
		if (common->protocol == IF_PROTO_PPP)
			return 0;
		((struct sppp *)ifp)->pp_flags &= ~PP_CISCO;
		((struct sppp *)ifp)->pp_flags |= PP_KEEPALIVE;
		common->protocol = IF_PROTO_PPP;
		break;
	}

	err = sppp_ioctl(ifp, SIOCSIFFLAGS, ifr);
	return (err);
}

int
wp_lite_set_te1_cfg(struct ifnet *ifp, struct ifreq *ifr)
{
	sdla_t			*card;
	struct if_settings	*ifsettings;
	sdla_te_cfg_t		te_cfg;
	int			 err = 0;

	if ((card = wanpipe_generic_getcard(ifp)) == NULL)
		return (EINVAL);

	ifsettings = (struct if_settings*)ifr->ifr_data;
	err = copyin(ifsettings->ifs_te1, &te_cfg, sizeof(sdla_te_cfg_t));

	if (ifsettings->flags & SANCFG_CLOCK_FLAG)
		card->fe_te.te_cfg.te_clock = te_cfg.te_clock;

	switch (ifsettings->type) {
	case IF_IFACE_T1:
		if (ifsettings->flags & SANCFG_LBO_FLAG)
			card->fe_te.te_cfg.lbo = te_cfg.lbo;
		break;
	}

	return (err);
}
@


1.18
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_obsd.c,v 1.17 2014/12/05 15:50:04 mpi Exp $	*/
@


1.17
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_obsd.c,v 1.16 2014/09/14 14:17:25 jsg Exp $	*/
a58 1
#include <netinet/in.h>
@


1.16
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_obsd.c,v 1.15 2014/07/22 13:12:11 mpi Exp $	*/
d57 1
d59 1
a59 1
#include <net/netisr.h>
a60 1
#include <netinet/in.h>
@


1.15
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_obsd.c,v 1.14 2013/11/18 23:36:09 deraadt Exp $	*/
a37 1
#include <sys/proc.h>
@


1.14
log
@cleanse format string
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_obsd.c,v 1.13 2012/04/11 17:42:53 mikeb Exp $	*/
a60 1
#include <netinet/in_systm.h>
@


1.13
log
@fix all the suser calls which pass an incorrect p_acflag argument;
figured out by and ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_obsd.c,v 1.12 2006/05/13 19:04:30 brad Exp $	*/
a85 4
static char *san_ifname_format = "san%d";



d110 1
a110 1
	snprintf(ifname, len, san_ifname_format, ifunit++);
@


1.12
log
@add IFQ_SET_READY in wanpipe_generic_register() to notify the stack that this
driver is ALTQ ready.

ok canacar@@

Thanks to Peter Hessler for noticing the issue and testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_obsd.c,v 1.11 2006/03/25 22:41:45 djm Exp $	*/
d247 1
a247 1
		if ((err = suser(p, p->p_acflag)) != 0)
d316 1
a316 1
			if ((err = suser(p, p->p_acflag)) != 0)
d323 1
a323 1
			if ((err = suser(p, p->p_acflag)) != 0)
@


1.11
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_obsd.c,v 1.10 2005/12/13 05:56:22 canacar Exp $	*/
d129 1
@


1.10
log
@if_san_common.c
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_obsd.c,v 1.9 2005/04/01 21:42:36 canacar Exp $	*/
d189 1
a189 1
			bpf_mtap(ifp->if_bpf, opkt);
d382 1
a382 1
		bpf_mtap(ifp->if_bpf, m);
@


1.9
log
@Improve san(4) driver:

* Some KNF, fix return values (from -Exxx to Exxx)
* Some string handling paranoia.
* Use ifconfig media options to switch between ppp and cHDLC modes,
  based on patch from claudio@@
* tcpdump works, patch from claudio@@
* ppp mode now works.

Lots of testing & feedback by Greg Mortensen,
Additional testing Sean Knox
ok alex@@, go go go deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_obsd.c,v 1.8 2005/03/02 15:39:47 claudio Exp $	*/
a384 1
	ifp->if_ibytes += m->m_len;
@


1.8
log
@Only allow superuser to set timeslots and ppp modes.
Diff from mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_obsd.c,v 1.7 2005/03/01 18:37:07 mcbride Exp $	*/
d77 2
d110 1
a110 1
wanpipe_generic_name(sdla_t *card, char *ifname)
a112 2
#if 0
	char		if_name[IFNAMSIZ+1];
d114 1
a114 4
	snprintf(if_name, strlen(if_name), ifname_format, ifunit++);
	bcopy(if_name, ifname, strlen(if_name));
#endif
	snprintf(ifname, IFNAMSIZ+1, san_ifname_format, ifunit++);
d123 3
a125 3
	if (ifname == NULL || strlen(ifname) > IFNAMSIZ) {
		return (-EINVAL);
	} else {
d127 1
a127 1
	}
d132 1
d135 2
d144 1
d146 1
a146 1
	bpfattach(&ifp->if_bpf, ifp, DLT_NULL, 4);
d148 1
d155 2
a156 2
	log(LOG_INFO, "%s: Unregister interface!\n",
	    ifp->if_xname);
a167 6
#if NBPFILTER > 0
#if 0
	struct mbuf	m0;
	u_int32_t	af = AF_INET;
#endif
#endif /* NBPFILTER > 0 */
d169 1
a169 1
	if ((card = wanpipe_generic_getcard(ifp)) == NULL) {
d171 1
a171 1
	}
d188 1
a188 7
		if (ifp->if_bpf) {
#if 0
			m0.m_next = opkt;
			m0.m_len = 4;
			m0.m_data = (char*)&af;
			bpf_mtap(ifp->if_bpf, &m0);
#endif
a189 1
		}
d192 1
a192 1
		if (wan_mbuf_to_buffer(&opkt)){
d198 1
a198 1
		if (err) {
a199 1
		}
a200 1
	return;
d215 3
a217 3
	if ((card = wanpipe_generic_getcard(ifp)) == NULL) {
		return (-EINVAL);
	}
d219 1
d222 6
d236 4
a239 5
			err = -EINVAL;
			goto ioctl_out;
		}
		err = ifmedia_ioctl(ifp, ifr, &common->ifm, cmd);
		break;
d243 1
a243 1
		break;
d251 1
a251 1
			err = -EINVAL;
d254 1
d256 4
a259 4
		if (err)
			goto ioctl_out;
		sdla_te_settimeslot(card, ts_map);
		break;
d264 1
a264 3
		if (err)
			goto ioctl_out;
		break;
d272 1
d274 2
d279 1
a279 4
			if (!(((struct sppp *)ifp)->pp_flags & PP_CISCO)){
				((struct sppp*)ifp)->pp_down((struct sppp*)ifp);
			}
			if (card->iface_down) {
d281 3
a283 2
			}
		}else{ /* bring it up */ 
d286 1
a286 1
			if (card->iface_up) {
a287 4
			}
			if (!(((struct sppp *)ifp)->pp_flags & PP_CISCO)){
				((struct sppp*)ifp)->pp_up((struct sppp*)ifp);
			}
a289 1
		err = 1;
d293 3
a295 3
		err = copyin(ifr->ifr_data,
				&ifsettings,
				sizeof(struct if_settings));
d301 1
d307 3
a309 2
			if (err) {
				log(LOG_INFO, "%s: Failed to copy to uspace!\n",
a310 1
			}
d326 1
d328 1
a328 1
			if (card->iface_ioctl) {
a330 1
			}
d333 1
a333 1
		break;
d343 1
a343 1
	if (err) {
d345 1
a345 1
	}
a373 4
#if 0
	struct mbuf	m0;
	u_int32_t	af = AF_INET;
#endif
d381 1
a381 7
	if (ifp->if_bpf) {
#if 0
		m0.m_next = m;
		m0.m_len = 4;
		m0.m_data = (char*)&af;
		bpf_mtap(ifp->if_bpf, &m0);
#endif
a382 1
	}
d390 2
a391 1
int wp_lite_set_proto(struct ifnet *ifp, struct ifreq *ifr)
d400 1
a400 1
		return (-EINVAL);
d402 3
a404 1
	ifsettings = (struct if_settings*)ifr->ifr_data;
d407 2
d414 2
d417 1
a417 1
		((struct sppp *)ifp)->pp_flags &= ~PP_KEEPALIVE;
d421 1
d426 2
a427 1
int wp_lite_set_te1_cfg(struct ifnet *ifp, struct ifreq *ifr)
d434 3
a436 3
	if ((card = wanpipe_generic_getcard(ifp)) == NULL) {
		return (-EINVAL);
	}
d438 1
a438 3
	err = copyin(ifsettings->ifs_te1,
			&te_cfg,
			sizeof(sdla_te_cfg_t));
d440 1
a440 1
	if (ifsettings->flags & SANCFG_CLOCK_FLAG){
d442 1
a442 1
	}
d445 1
a445 1
		if (ifsettings->flags & SANCFG_LBO_FLAG){
a446 1
		}
d449 1
a451 1

@


1.7
log
@- make large packets work without hanging the interface
- make tcpdump attach correctly

by Alex Feldman prodded via Greg Mortensen <thevision@@pobox.com>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_obsd.c,v 1.6 2004/12/07 06:10:24 mcbride Exp $	*/
d38 1
d220 1
d253 2
d326 2
d333 2
@


1.6
log
@Cleanup. Rename some defines, add wp_lite_set_te1_cfg()
(used to change LBO and T1/E1 clock configurations)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_obsd.c,v 1.5 2004/11/28 23:39:45 canacar Exp $	*/
d35 16
a50 23
# include <sys/types.h>
# include <sys/param.h>
# include <sys/systm.h>
# include <sys/syslog.h>
# include <sys/ioccom.h>
# include <sys/conf.h>
# include <sys/malloc.h>
# include <sys/errno.h>
# include <sys/exec.h>
# include <sys/mbuf.h>
# include <sys/sockio.h>
# include <sys/socket.h>
# include <sys/kernel.h>
# include <sys/device.h>
# include <sys/time.h>
# include <sys/timeout.h>

# include <net/if.h>
# include <net/if_media.h>
# include <net/netisr.h>
# include <net/if_sppp.h>
# include <netinet/in_systm.h>
# include <netinet/in.h>
d52 13
a64 2
# include <netinet/udp.h>
# include <netinet/ip.h>
a135 1
	((struct sppp *)ifp)->pp_framebytes = 3;
d166 1
d169 1
d192 1
d197 2
d202 5
d280 3
d292 3
d297 1
d377 1
d380 1
d389 1
d394 2
@


1.5
log
@In kernel pppoe client, a simple IPv4 only implementation.
Initial porting from NetBSD by David Berghoff.
Modified/simplified to match our sppp implementation.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_obsd.c,v 1.4 2004/07/16 15:11:45 alex Exp $	*/
d119 2
d129 1
d305 4
d379 1
a379 2
int
wp_lite_set_proto(struct ifnet *ifp, struct ifreq *ifr)
d395 1
d400 1
d406 29
@


1.4
log
@Aft source update.
mcbride ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_obsd.c,v 1.3 2004/06/26 22:48:14 mcbride Exp $	*/
d129 1
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if_san_obsd.c,v 1.2 2004/06/26 20:17:23 mcbride Exp $	*/
a34 1
# include </usr/include/bitstring.h>
d117 1
a117 1
wanpipe_generic_register (sdla_t *card, struct ifnet *ifp, char *ifname)
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a65 1
/****** Defines & Macros ****************************************************/
a72 1
/****** Function Prototypes *************************************************/
d74 2
a75 2
static sdla_t* wanpipe_generic_getcard(struct ifnet*);
static int wanpipe_generic_ioctl(struct ifnet*, u_long, caddr_t);
d77 5
a81 1
static void wanpipe_generic_start(struct ifnet*);
a82 4
/****** Global Data **********************************************************
 * Note: All data must be explicitly initialized!!!
 */
static char* san_ifname_format = "san%d";
d84 2
a85 2
/******* WAN Device Driver Entry Points *************************************/
static sdla_t* wanpipe_generic_getcard(struct ifnet* ifp)
d89 1
a89 1
	if (ifp->if_softc == NULL){
d92 1
a92 1
		return NULL;
d95 1
a95 1
	if (card == NULL){
d97 2
a98 2
				ifp->if_xname);
		return NULL;
d100 1
a100 1
	return card;
d103 2
a104 1
int wanpipe_generic_name(sdla_t* card, char* ifname)
d114 1
a114 1
	return 0;
d117 2
a118 1
int wanpipe_generic_register (sdla_t* card, struct ifnet* ifp, char *ifname)
d120 3
a122 3
	if (ifname == NULL || strlen(ifname) > IFNAMSIZ){
		return -EINVAL;
	}else{
d137 1
a137 1
#if defined(NBPFILTER)
d139 2
a140 2
#endif
	return 0;
d143 2
a144 1
void wanpipe_generic_unregister (struct ifnet* ifp)
d147 1
a147 1
			ifp->if_xname);
d153 2
a154 2

static void wanpipe_generic_start(struct ifnet* ifp)
d156 1
a156 1
	sdla_t*		card;
d158 2
a159 2
	int		err = 0;
#if defined(NBPFILTER)
d162 1
a162 1
#endif
d164 1
a164 1
	if ((card = wanpipe_generic_getcard(ifp)) == NULL){
d167 2
a168 2
	while (1){
		if (sppp_isempty(ifp)){
d173 1
a173 1
		if ((opkt = sppp_dequeue(ifp)) == NULL){
d177 1
a177 1
		if (card->iface_send == NULL){
d182 2
a183 2
#if defined(NBPFILTER)
		if (ifp->if_bpf){
d189 1
a189 1
#endif
d192 1
a192 1
		if (err){
d200 2
a201 1
static int wanpipe_generic_ioctl(struct ifnet* ifp, u_long cmd, caddr_t data)
d210 2
a211 2
	if ((card = wanpipe_generic_getcard(ifp)) == NULL){
		return -EINVAL;
d214 1
a214 1
	switch (cmd){
d221 1
a221 1
		if (card->state != WAN_DISCONNECTED){
d223 1
a223 1
					ifp->if_xname);
d235 1
a235 1
		if (card->state != WAN_DISCONNECTED){
d237 1
a237 1
					ifp->if_xname);
d260 1
a260 1
		if ((ifp->if_flags & IFF_UP) == 0){
d263 2
a264 2
					ifp->if_xname);
			if (card->iface_down){
d269 2
a270 2
					ifp->if_xname);
			if (card->iface_up){
d281 1
a281 1
		if (err){
d286 1
a286 1
		switch (ifsettings.type){
d289 3
a291 4
			err = copyout(&ifsettings,
					ifr->ifr_data,
					sizeof(struct if_settings));
			if (err){
d293 1
a293 1
							card->devname);
d303 3
a305 5
			if (card->iface_ioctl){
				err = card->iface_ioctl(
						ifp,
						cmd,
						(struct ifreq*)data);
d312 1
a312 1
		if (card->iface_ioctl){
d319 1
a319 1
	if (err){
d324 1
a324 1
	return err;
d327 2
a328 1
static void wanpipe_generic_watchdog(struct ifnet* ifp)
d333 2
a334 1
int wanpipe_generic_open(struct ifnet* ifp)
d336 1
a336 1
	return 0;
d339 2
a340 1
int wanpipe_generic_close(struct ifnet* ifp)
d342 1
a342 1
	return 0;
d345 2
a346 1
int wanpipe_generic_input(struct ifnet* ifp, struct mbuf* m)
d349 1
a349 1
#if defined(NBPFILTER)
d352 1
a352 1
#endif
d354 2
a355 2
	if ((card = wanpipe_generic_getcard(ifp)) == NULL){
		return -EINVAL;
d358 2
a359 2
#if defined(NBPFILTER)
	if (ifp->if_bpf){
d365 1
a365 1
#endif
d369 1
a369 1
	return 0;
d372 2
a373 1
int wp_lite_set_proto(struct ifnet* ifp, struct ifreq* ifr)
d375 3
a377 3
	wanpipe_common_t*	common;
	struct if_settings*	ifsettings;
	int			err = 0;
d379 1
a379 1
	if ((common = ifp->if_softc) == NULL){
d382 1
a382 1
		return -EINVAL;
d396 1
a396 1
	return err;
a397 2

/************************************ END **********************************/
@


1.1
log
@Sangoma Network Device driver for AFT series card (initiali version).
ok mcbride@@
@
text
@d1 2
@

