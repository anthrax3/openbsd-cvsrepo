head	1.99;
access;
symbols
	OPENBSD_4_6:1.94.0.6
	OPENBSD_4_6_BASE:1.94
	OPENBSD_4_5:1.94.0.2
	OPENBSD_4_5_BASE:1.94
	OPENBSD_4_4:1.85.0.2
	OPENBSD_4_4_BASE:1.85
	OPENBSD_4_3:1.84.0.6
	OPENBSD_4_3_BASE:1.84
	OPENBSD_4_2:1.84.0.4
	OPENBSD_4_2_BASE:1.84
	OPENBSD_4_1:1.84.0.2
	OPENBSD_4_1_BASE:1.84
	OPENBSD_4_0:1.83.0.2
	OPENBSD_4_0_BASE:1.83
	OPENBSD_3_9:1.76.0.2
	OPENBSD_3_9_BASE:1.76
	OPENBSD_3_8:1.71.0.2
	OPENBSD_3_8_BASE:1.71
	OPENBSD_3_7:1.58.0.2
	OPENBSD_3_7_BASE:1.58
	OPENBSD_3_6:1.53.0.2
	OPENBSD_3_6_BASE:1.53
	SMP_SYNC_A:1.50
	SMP_SYNC_B:1.50
	OPENBSD_3_5:1.48.0.2
	OPENBSD_3_5_BASE:1.48
	OPENBSD_3_4:1.46.0.4
	OPENBSD_3_4_BASE:1.46
	UBC_SYNC_A:1.46
	OPENBSD_3_3:1.46.0.2
	OPENBSD_3_3_BASE:1.46
	OPENBSD_3_2:1.37.0.2
	OPENBSD_3_2_BASE:1.37
	OPENBSD_3_1:1.35.0.2
	OPENBSD_3_1_BASE:1.35
	UBC_SYNC_B:1.38
	UBC:1.32.0.2
	UBC_BASE:1.32
	OPENBSD_3_0:1.30.0.2
	OPENBSD_3_0_BASE:1.30
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	SMP:1.9.0.2
	SMP_BASE:1.9
	kame_19991208:1.8
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.99
date	2009.08.29.21.12.55;	author kettenis;	state dead;
branches;
next	1.98;

1.98
date	2009.08.13.14.24.47;	author jasper;	state Exp;
branches;
next	1.97;

1.97
date	2009.08.11.23.58.35;	author martynas;	state Exp;
branches;
next	1.96;

1.96
date	2009.08.08.15.58.14;	author naddy;	state Exp;
branches;
next	1.95;

1.95
date	2009.07.28.07.20.28;	author claudio;	state Exp;
branches;
next	1.94;

1.94
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.93;

1.93
date	2008.11.09.15.08.26;	author naddy;	state Exp;
branches;
next	1.92;

1.92
date	2008.10.20.01.02.52;	author brad;	state Exp;
branches;
next	1.91;

1.91
date	2008.10.19.21.38.01;	author brad;	state Exp;
branches;
next	1.90;

1.90
date	2008.10.16.19.18.03;	author naddy;	state Exp;
branches;
next	1.89;

1.89
date	2008.10.14.18.01.53;	author naddy;	state Exp;
branches;
next	1.88;

1.88
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.87;

1.87
date	2008.09.24.19.12.59;	author chl;	state Exp;
branches;
next	1.86;

1.86
date	2008.09.18.15.16.30;	author naddy;	state Exp;
branches;
next	1.85;

1.85
date	2008.06.07.19.03.13;	author brad;	state Exp;
branches;
next	1.84;

1.84
date	2006.11.20.22.49.32;	author brad;	state Exp;
branches;
next	1.83;

1.83
date	2006.05.28.00.20.21;	author brad;	state Exp;
branches;
next	1.82;

1.82
date	2006.05.28.00.04.24;	author jason;	state Exp;
branches;
next	1.81;

1.81
date	2006.05.27.10.03.15;	author brad;	state Exp;
branches;
next	1.80;

1.80
date	2006.05.20.03.47.56;	author brad;	state Exp;
branches;
next	1.79;

1.79
date	2006.03.25.22.41.45;	author djm;	state Exp;
branches;
next	1.78;

1.78
date	2006.03.16.02.32.37;	author brad;	state Exp;
branches;
next	1.77;

1.77
date	2006.03.16.02.23.53;	author brad;	state Exp;
branches;
next	1.76;

1.76
date	2006.02.16.20.45.37;	author brad;	state Exp;
branches;
next	1.75;

1.75
date	2006.02.16.20.16.30;	author brad;	state Exp;
branches;
next	1.74;

1.74
date	2006.01.16.01.47.39;	author brad;	state Exp;
branches;
next	1.73;

1.73
date	2005.10.10.20.54.23;	author brad;	state Exp;
branches;
next	1.72;

1.72
date	2005.10.09.05.38.00;	author brad;	state Exp;
branches;
next	1.71;

1.71
date	2005.07.30.04.25.00;	author brad;	state Exp;
branches;
next	1.70;

1.70
date	2005.07.25.00.49.43;	author brad;	state Exp;
branches;
next	1.69;

1.69
date	2005.07.25.00.41.24;	author brad;	state Exp;
branches;
next	1.68;

1.68
date	2005.07.18.06.29.54;	author camield;	state Exp;
branches;
next	1.67;

1.67
date	2005.07.08.01.49.51;	author brad;	state Exp;
branches;
next	1.66;

1.66
date	2005.07.08.01.09.14;	author brad;	state Exp;
branches;
next	1.65;

1.65
date	2005.07.07.17.49.43;	author brad;	state Exp;
branches;
next	1.64;

1.64
date	2005.07.03.02.25.13;	author brad;	state Exp;
branches;
next	1.63;

1.63
date	2005.07.03.02.17.51;	author brad;	state Exp;
branches;
next	1.62;

1.62
date	2005.07.03.02.04.15;	author brad;	state Exp;
branches;
next	1.61;

1.61
date	2005.07.02.23.10.11;	author brad;	state Exp;
branches;
next	1.60;

1.60
date	2005.04.25.17.55.51;	author brad;	state Exp;
branches;
next	1.59;

1.59
date	2005.04.18.00.04.11;	author brad;	state Exp;
branches;
next	1.58;

1.58
date	2004.12.08.07.04.12;	author jsg;	state Exp;
branches;
next	1.57;

1.57
date	2004.11.22.04.14.17;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.55;

1.55
date	2004.09.19.22.22.05;	author brad;	state Exp;
branches;
next	1.54;

1.54
date	2004.09.16.00.55.08;	author mcbride;	state Exp;
branches;
next	1.53;

1.53
date	2004.08.19.18.26.29;	author mcbride;	state Exp;
branches;
next	1.52;

1.52
date	2004.08.05.19.57.17;	author brad;	state Exp;
branches;
next	1.51;

1.51
date	2004.06.18.20.33.56;	author mcbride;	state Exp;
branches;
next	1.50;

1.50
date	2004.05.31.16.58.19;	author mcbride;	state Exp;
branches;
next	1.49;

1.49
date	2004.04.09.21.52.17;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2003.12.16.08.20.44;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2003.10.26.15.07.26;	author jmc;	state Exp;
branches;
next	1.46;

1.46
date	2003.03.06.23.07.27;	author jason;	state Exp;
branches;
next	1.45;

1.45
date	2003.03.05.20.24.04;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2003.02.26.19.07.32;	author nate;	state Exp;
branches;
next	1.43;

1.43
date	2003.02.26.19.02.50;	author nate;	state Exp;
branches;
next	1.42;

1.42
date	2003.02.20.18.08.43;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2002.12.04.17.32.30;	author nate;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.26.06.01.28;	author nate;	state Exp;
branches;
next	1.39;

1.39
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.38;

1.38
date	2002.10.03.23.50.07;	author jason;	state Exp;
branches;
next	1.37;

1.37
date	2002.07.05.13.48.11;	author aaron;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.01.16.15.49;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2002.02.15.20.45.31;	author nordin;	state Exp;
branches;
next	1.33;

1.33
date	2002.01.11.01.31.21;	author nordin;	state Exp;
branches;
next	1.32;

1.32
date	2001.12.13.23.52.15;	author niklas;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.12.20.03.49;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.03.03.32.11;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.03.02.43.16;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.27.06.34.49;	author kjc;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.27.05.44.55;	author nate;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.24.22.58.01;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.24.20.27.00;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.18.19.19.41;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.17.18.41.46;	author provos;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.07.18.48.31;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.28.04.11.34;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.22.16.30.13;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.14.20.11.39;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.20.19.39.43;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.21.03.50.48;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.19.08.44.46;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.26.19.05.28;	author chris;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.15.03.54.29;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.15.02.28.15;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.18.05.26.25;	author jason;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	99.10.28.03.26.33;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	99.10.25.19.39.18;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	99.10.04.12.37.17;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	99.10.03.13.06.30;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	99.10.01.02.02.20;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	99.09.26.03.22.40;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	99.08.03.00.55.44;	author ho;	state Exp;
branches;
next	1.1;

1.1
date	99.07.25.16.51.55;	author jason;	state Exp;
branches;
next	;

1.9.2.1
date	2000.02.20.11.57.06;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.05.14.22.25.47;	author niklas;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2001.07.04.10.42.23;	author niklas;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.9.2.7;

1.9.2.7
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.9.2.8;

1.9.2.8
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.9.2.9;

1.9.2.9
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	1.9.2.10;

1.9.2.10
date	2004.06.05.23.12.51;	author niklas;	state Exp;
branches;
next	;

1.32.2.1
date	2002.01.31.22.55.35;	author niklas;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.32.2.3;

1.32.2.3
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	1.32.2.4;

1.32.2.4
date	2003.05.19.22.18.01;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.99
log
@Split the ti(4) driver into mostly bus-agnostic code and PCI-specific
attachment.  Add SBus support to the bus-agnostic code.
@
text
@/*	$OpenBSD: if_ti.c,v 1.98 2009/08/13 14:24:47 jasper Exp $	*/

/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/pci/if_ti.c,v 1.25 2000/01/18 00:26:29 wpaul Exp $
 */

/*
 * Alteon Networks Tigon PCI gigabit ethernet driver for OpenBSD.
 *
 * Written by Bill Paul <wpaul@@ctr.columbia.edu>
 * Electrical Engineering Department
 * Columbia University, New York City
 */

/*
 * The Alteon Networks Tigon chip contains an embedded R4000 CPU,
 * gigabit MAC, dual DMA channels and a PCI interface unit. NICs
 * using the Tigon may have anywhere from 512K to 2MB of SRAM. The
 * Tigon supports hardware IP, TCP and UCP checksumming, multicast
 * filtering and jumbo (9014 byte) frames. The hardware is largely
 * controlled by firmware, which must be loaded into the NIC during
 * initialization.
 *
 * The Tigon 2 contains 2 R4000 CPUs and requires a newer firmware
 * revision, which supports new features such as extended commands,
 * extended jumbo receive ring desciptors and a mini receive ring.
 *
 * Alteon Networks is to be commended for releasing such a vast amount
 * of development material for the Tigon NIC without requiring an NDA
 * (although they really should have done it a long time ago). With
 * any luck, the other vendors will finally wise up and follow Alteon's
 * stellar example.
 *
 * The following people deserve special thanks:
 * - Terry Murphy of 3Com, for providing a 3c985 Tigon 1 board
 *   for testing
 * - Raymond Lee of Netgear, for providing a pair of Netgear
 *   GA620 Tigon 2 boards for testing
 * - Ulf Zimmermann, for bringing the GA260 to my attention and
 *   convincing me to write this driver.
 * - Andrew Gallatin for providing FreeBSD/Alpha support.
 */

#include "bpfilter.h"
#include "vlan.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#endif

#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#if NVLAN > 0
#include <net/if_types.h>
#include <net/if_vlan_var.h>
#endif

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/pci/if_tireg.h>
#include <dev/pci/if_tivar.h>

int ti_probe(struct device *, void *, void *);
void ti_attach(struct device *, struct device *, void *);

struct cfattach ti_ca = {
	sizeof(struct ti_softc), ti_probe, ti_attach
};

struct cfdriver ti_cd = {
	NULL, "ti", DV_IFNET
};

void ti_txeof_tigon1(struct ti_softc *);
void ti_txeof_tigon2(struct ti_softc *);
void ti_rxeof(struct ti_softc *);

void ti_stats_update(struct ti_softc *);
int ti_encap_tigon1(struct ti_softc *, struct mbuf *, u_int32_t *);
int ti_encap_tigon2(struct ti_softc *, struct mbuf *, u_int32_t *);

int ti_intr(void *);
void ti_start(struct ifnet *);
int ti_ioctl(struct ifnet *, u_long, caddr_t);
void ti_init(void *);
void ti_init2(struct ti_softc *);
void ti_stop(struct ti_softc *);
void ti_watchdog(struct ifnet *);
void ti_shutdown(void *);
int ti_ifmedia_upd(struct ifnet *);
void ti_ifmedia_sts(struct ifnet *, struct ifmediareq *);

u_int32_t ti_eeprom_putbyte(struct ti_softc *, int);
u_int8_t ti_eeprom_getbyte(struct ti_softc *, int, u_int8_t *);
int ti_read_eeprom(struct ti_softc *, caddr_t, int, int);

void ti_add_mcast(struct ti_softc *, struct ether_addr *);
void ti_del_mcast(struct ti_softc *, struct ether_addr *);
void ti_setmulti(struct ti_softc *);

void ti_mem_read(struct ti_softc *, u_int32_t, u_int32_t, void *);
void ti_mem_write(struct ti_softc *, u_int32_t, u_int32_t, const void*);
void ti_mem_set(struct ti_softc *, u_int32_t, u_int32_t);
void ti_loadfw(struct ti_softc *);
void ti_cmd(struct ti_softc *, struct ti_cmd_desc *);
void ti_cmd_ext(struct ti_softc *, struct ti_cmd_desc *,
    caddr_t, int);
void ti_handle_events(struct ti_softc *);
int ti_alloc_jumbo_mem(struct ti_softc *);
void *ti_jalloc(struct ti_softc *);
void ti_jfree(caddr_t, u_int, void *);
int ti_newbuf_std(struct ti_softc *, int, struct mbuf *, bus_dmamap_t);
int ti_newbuf_mini(struct ti_softc *, int, struct mbuf *, bus_dmamap_t);
int ti_newbuf_jumbo(struct ti_softc *, int, struct mbuf *);
int ti_init_rx_ring_std(struct ti_softc *);
void ti_free_rx_ring_std(struct ti_softc *);
int ti_init_rx_ring_jumbo(struct ti_softc *);
void ti_free_rx_ring_jumbo(struct ti_softc *);
int ti_init_rx_ring_mini(struct ti_softc *);
void ti_free_rx_ring_mini(struct ti_softc *);
void ti_free_tx_ring(struct ti_softc *);
int ti_init_tx_ring(struct ti_softc *);

int ti_64bitslot_war(struct ti_softc *);
int ti_chipinit(struct ti_softc *);
int ti_gibinit(struct ti_softc *);

const struct pci_matchid ti_devices[] = {
	{ PCI_VENDOR_NETGEAR, PCI_PRODUCT_NETGEAR_GA620 },
	{ PCI_VENDOR_NETGEAR, PCI_PRODUCT_NETGEAR_GA620T },
	{ PCI_VENDOR_ALTEON, PCI_PRODUCT_ALTEON_ACENIC },
	{ PCI_VENDOR_ALTEON, PCI_PRODUCT_ALTEON_ACENICT },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C985 },
	{ PCI_VENDOR_SGI, PCI_PRODUCT_SGI_TIGON },
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_PN9000SX }
};

/*
 * Send an instruction or address to the EEPROM, check for ACK.
 */
u_int32_t
ti_eeprom_putbyte(struct ti_softc *sc, int byte)
{
	int		i, ack = 0;

	/*
	 * Make sure we're in TX mode.
	 */
	TI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN);

	/*
	 * Feed in each bit and strobe the clock.
	 */
	for (i = 0x80; i; i >>= 1) {
		if (byte & i)
			TI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_DOUT);
		else
			TI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_DOUT);
		DELAY(1);
		TI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);
		DELAY(1);
		TI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);
	}

	/*
	 * Turn off TX mode.
	 */
	TI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN);

	/*
	 * Check for ack.
	 */
	TI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);
	ack = CSR_READ_4(sc, TI_MISC_LOCAL_CTL) & TI_MLC_EE_DIN;
	TI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);

	return (ack);
}

/*
 * Read a byte of data stored in the EEPROM at address 'addr.'
 * We have to send two address bytes since the EEPROM can hold
 * more than 256 bytes of data.
 */
u_int8_t
ti_eeprom_getbyte(struct ti_softc *sc, int addr, u_int8_t *dest)
{
	int		i;
	u_int8_t		byte = 0;

	EEPROM_START;

	/*
	 * Send write control code to EEPROM.
	 */
	if (ti_eeprom_putbyte(sc, EEPROM_CTL_WRITE)) {
		printf("%s: failed to send write command, status: %x\n",
		    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));
		return (1);
	}

	/*
	 * Send first byte of address of byte we want to read.
	 */
	if (ti_eeprom_putbyte(sc, (addr >> 8) & 0xFF)) {
		printf("%s: failed to send address, status: %x\n",
		    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));
		return (1);
	}
	/*
	 * Send second byte address of byte we want to read.
	 */
	if (ti_eeprom_putbyte(sc, addr & 0xFF)) {
		printf("%s: failed to send address, status: %x\n",
		    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));
		return (1);
	}

	EEPROM_STOP;
	EEPROM_START;
	/*
	 * Send read control code to EEPROM.
	 */
	if (ti_eeprom_putbyte(sc, EEPROM_CTL_READ)) {
		printf("%s: failed to send read command, status: %x\n",
		    sc->sc_dv.dv_xname, CSR_READ_4(sc, TI_MISC_LOCAL_CTL));
		return (1);
	}

	/*
	 * Start reading bits from EEPROM.
	 */
	TI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_TXEN);
	for (i = 0x80; i; i >>= 1) {
		TI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);
		DELAY(1);
		if (CSR_READ_4(sc, TI_MISC_LOCAL_CTL) & TI_MLC_EE_DIN)
			byte |= i;
		TI_CLRBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_EE_CLK);
		DELAY(1);
	}

	EEPROM_STOP;

	/*
	 * No ACK generated for read, so just return byte.
	 */

	*dest = byte;

	return (0);
}

/*
 * Read a sequence of bytes from the EEPROM.
 */
int
ti_read_eeprom(struct ti_softc *sc, caddr_t dest, int off, int cnt)
{
	int			err = 0, i;
	u_int8_t		byte = 0;

	for (i = 0; i < cnt; i++) {
		err = ti_eeprom_getbyte(sc, off + i, &byte);
		if (err)
			break;
		*(dest + i) = byte;
	}

	return (err ? 1 : 0);
}

/*
 * NIC memory read function.
 * Can be used to copy data from NIC local memory.
 */
void
ti_mem_read(struct ti_softc *sc, u_int32_t addr, u_int32_t len, void *buf)
{
	int			segptr, segsize, cnt;
	caddr_t			ptr;

	segptr = addr;
	cnt = len;
	ptr = buf;

	while(cnt) {
		if (cnt < TI_WINLEN)
			segsize = cnt;
		else
			segsize = TI_WINLEN - (segptr % TI_WINLEN);
		CSR_WRITE_4(sc, TI_WINBASE, (segptr & ~(TI_WINLEN - 1)));
		bus_space_read_region_4(sc->ti_btag, sc->ti_bhandle,
		    TI_WINDOW + (segptr & (TI_WINLEN - 1)), (u_int32_t *)ptr,
		    segsize / 4);
		ptr += segsize;
		segptr += segsize;
		cnt -= segsize;
	}
}

/*
 * NIC memory write function.
 * Can be used to copy data into  NIC local memory.
 */
void
ti_mem_write(struct ti_softc *sc, u_int32_t addr, u_int32_t len,
    const void *buf)
{
	int			segptr, segsize, cnt;
	const char		*ptr;

	segptr = addr;
	cnt = len;
	ptr = buf;

	while(cnt) {
		if (cnt < TI_WINLEN)
			segsize = cnt;
		else
			segsize = TI_WINLEN - (segptr % TI_WINLEN);
		CSR_WRITE_4(sc, TI_WINBASE, (segptr & ~(TI_WINLEN - 1)));
		bus_space_write_region_4(sc->ti_btag, sc->ti_bhandle,
		    TI_WINDOW + (segptr & (TI_WINLEN - 1)), (u_int32_t *)ptr,
		    segsize / 4);
		ptr += segsize;
		segptr += segsize;
		cnt -= segsize;
	}
}

/*
 * NIC memory write function.
 * Can be used to clear a section of NIC local memory.
 */
void
ti_mem_set(struct ti_softc *sc, u_int32_t addr, u_int32_t len)
{
	int			segptr, segsize, cnt;

	segptr = addr;
	cnt = len;

	while(cnt) {
		if (cnt < TI_WINLEN)
			segsize = cnt;
		else
			segsize = TI_WINLEN - (segptr % TI_WINLEN);
		CSR_WRITE_4(sc, TI_WINBASE, (segptr & ~(TI_WINLEN - 1)));
		bus_space_set_region_4(sc->ti_btag, sc->ti_bhandle,
		    TI_WINDOW + (segptr & (TI_WINLEN - 1)), 0, segsize / 4);
		segptr += segsize;
		cnt -= segsize;
	}
}

/*
 * Load firmware image into the NIC. Check that the firmware revision
 * is acceptable and see if we want the firmware for the Tigon 1 or
 * Tigon 2.
 */
void
ti_loadfw(struct ti_softc *sc)
{
	struct tigon_firmware *tf;
	u_char *buf = NULL;
	u_int32_t *b;
	size_t buflen, i, cnt;
	char *name;
	int error;

	switch(sc->ti_hwrev) {
	case TI_HWREV_TIGON:
		name = "tigon1";
		break;
	case TI_HWREV_TIGON_II:
		name = "tigon2";
		break;
	default:
		printf("%s: can't load firmware: unknown hardware rev\n",
		    sc->sc_dv.dv_xname);
		return;
	}
	
	error = loadfirmware(name, &buf, &buflen);
	if (error)
		return;
	/* convert firmware to host byte order */
	b = (u_int32_t *)buf;
	cnt = buflen / sizeof(u_int32_t);
	for (i = 0; i < cnt; i++) 
		b[i] = letoh32(b[i]);

	tf = (struct tigon_firmware *)buf;
	if (tf->FwReleaseMajor != TI_FIRMWARE_MAJOR ||
	    tf->FwReleaseMinor != TI_FIRMWARE_MINOR ||
	    tf->FwReleaseFix != TI_FIRMWARE_FIX) {
		printf("%s: firmware revision mismatch; want "
		    "%d.%d.%d, got %d.%d.%d\n", sc->sc_dv.dv_xname,
		    TI_FIRMWARE_MAJOR, TI_FIRMWARE_MINOR,
		    TI_FIRMWARE_FIX, tf->FwReleaseMajor,
		    tf->FwReleaseMinor, tf->FwReleaseFix);
		free(buf, M_DEVBUF);
		return;
	}
	ti_mem_write(sc, tf->FwTextAddr, tf->FwTextLen,
	    (caddr_t)&tf->data[tf->FwTextOffset]);
	ti_mem_write(sc, tf->FwRodataAddr, tf->FwRodataLen,
	    (caddr_t)&tf->data[tf->FwRodataOffset]);
	ti_mem_write(sc, tf->FwDataAddr, tf->FwDataLen,
	    (caddr_t)&tf->data[tf->FwDataOffset]);
	ti_mem_set(sc, tf->FwBssAddr, tf->FwBssLen);
	ti_mem_set(sc, tf->FwSbssAddr, tf->FwSbssLen);
	CSR_WRITE_4(sc, TI_CPU_PROGRAM_COUNTER, tf->FwStartAddr);
	free(buf, M_DEVBUF);
}

/*
 * Send the NIC a command via the command ring.
 */
void
ti_cmd(struct ti_softc *sc, struct ti_cmd_desc *cmd)
{
	u_int32_t		index;

	index = sc->ti_cmd_saved_prodidx;
	CSR_WRITE_4(sc, TI_GCR_CMDRING + (index * 4), *(u_int32_t *)(cmd));
	TI_INC(index, TI_CMD_RING_CNT);
	CSR_WRITE_4(sc, TI_MB_CMDPROD_IDX, index);
	sc->ti_cmd_saved_prodidx = index;
}

/*
 * Send the NIC an extended command. The 'len' parameter specifies the
 * number of command slots to include after the initial command.
 */
void
ti_cmd_ext(struct ti_softc *sc, struct ti_cmd_desc *cmd, caddr_t arg,
    int len)
{
	u_int32_t		index;
	int		i;

	index = sc->ti_cmd_saved_prodidx;
	CSR_WRITE_4(sc, TI_GCR_CMDRING + (index * 4), *(u_int32_t *)(cmd));
	TI_INC(index, TI_CMD_RING_CNT);
	for (i = 0; i < len; i++) {
		CSR_WRITE_4(sc, TI_GCR_CMDRING + (index * 4),
		    *(u_int32_t *)(&arg[i * 4]));
		TI_INC(index, TI_CMD_RING_CNT);
	}
	CSR_WRITE_4(sc, TI_MB_CMDPROD_IDX, index);
	sc->ti_cmd_saved_prodidx = index;
}

/*
 * Handle events that have triggered interrupts.
 */
void
ti_handle_events(struct ti_softc *sc)
{
	struct ti_event_desc	*e;
	struct ifnet		*ifp = &sc->arpcom.ac_if;

	if (sc->ti_rdata->ti_event_ring == NULL)
		return;

	while (sc->ti_ev_saved_considx != sc->ti_ev_prodidx.ti_idx) {
		e = &sc->ti_rdata->ti_event_ring[sc->ti_ev_saved_considx];
		switch (TI_EVENT_EVENT(e)) {
		case TI_EV_LINKSTAT_CHANGED:
			sc->ti_linkstat = TI_EVENT_CODE(e);
			switch (sc->ti_linkstat) {
			case TI_EV_CODE_LINK_UP:
			case TI_EV_CODE_GIG_LINK_UP:
			    {
				struct ifmediareq ifmr;

				bzero(&ifmr, sizeof(ifmr));
				ti_ifmedia_sts(ifp, &ifmr);
				if (ifmr.ifm_active & IFM_FDX) {
					ifp->if_link_state =
					    LINK_STATE_FULL_DUPLEX;
				} else {
					ifp->if_link_state =
					    LINK_STATE_HALF_DUPLEX;
				}
				if_link_state_change(ifp);
				ifp->if_baudrate =
				    ifmedia_baudrate(ifmr.ifm_active);
				break;
			    }
			case TI_EV_CODE_LINK_DOWN:
				ifp->if_link_state = LINK_STATE_DOWN;
				if_link_state_change(ifp);
				ifp->if_baudrate = 0;
				break;
			default:
				printf("%s: unknown link state code %d\n",
				    sc->sc_dv.dv_xname, sc->ti_linkstat);
			}
			break;
		case TI_EV_ERROR:
			if (TI_EVENT_CODE(e) == TI_EV_CODE_ERR_INVAL_CMD)
				printf("%s: invalid command\n",
				    sc->sc_dv.dv_xname);
			else if (TI_EVENT_CODE(e) == TI_EV_CODE_ERR_UNIMP_CMD)
				printf("%s: unknown command\n",
				    sc->sc_dv.dv_xname);
			else if (TI_EVENT_CODE(e) == TI_EV_CODE_ERR_BADCFG)
				printf("%s: bad config data\n",
				    sc->sc_dv.dv_xname);
			break;
		case TI_EV_FIRMWARE_UP:
			ti_init2(sc);
			break;
		case TI_EV_STATS_UPDATED:
			ti_stats_update(sc);
			break;
		case TI_EV_RESET_JUMBO_RING:
		case TI_EV_MCAST_UPDATED:
			/* Who cares. */
			break;
		default:
			printf("%s: unknown event: %d\n", sc->sc_dv.dv_xname,
			       TI_EVENT_EVENT(e));
			break;
		}
		/* Advance the consumer index. */
		TI_INC(sc->ti_ev_saved_considx, TI_EVENT_RING_CNT);
		CSR_WRITE_4(sc, TI_GCR_EVENTCONS_IDX, sc->ti_ev_saved_considx);
	}
}

/*
 * Memory management for the jumbo receive ring is a pain in the
 * butt. We need to allocate at least 9018 bytes of space per frame,
 * _and_ it has to be contiguous (unless you use the extended
 * jumbo descriptor format). Using malloc() all the time won't
 * work: malloc() allocates memory in powers of two, which means we
 * would end up wasting a considerable amount of space by allocating
 * 9K chunks. We don't have a jumbo mbuf cluster pool. Thus, we have
 * to do our own memory management.
 *
 * The driver needs to allocate a contiguous chunk of memory at boot
 * time. We then chop this up ourselves into 9K pieces and use them
 * as external mbuf storage.
 *
 * One issue here is how much memory to allocate. The jumbo ring has
 * 256 slots in it, but at 9K per slot than can consume over 2MB of
 * RAM. This is a bit much, especially considering we also need
 * RAM for the standard ring and mini ring (on the Tigon 2). To
 * save space, we only actually allocate enough memory for 64 slots
 * by default, which works out to between 500 and 600K. This can
 * be tuned by changing a #define in if_tireg.h.
 */

int
ti_alloc_jumbo_mem(struct ti_softc *sc)
{
	caddr_t ptr, kva;
	bus_dma_segment_t seg;
	int i, rseg, state, error;
	struct ti_jpool_entry *entry;

	state = error = 0;

	/* Grab a big chunk o' storage. */
	if (bus_dmamem_alloc(sc->sc_dmatag, TI_JMEM, PAGE_SIZE, 0,
	    &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
		printf("%s: can't alloc rx buffers\n", sc->sc_dv.dv_xname);
		return (ENOBUFS);
	}

	state = 1;
	if (bus_dmamem_map(sc->sc_dmatag, &seg, rseg, TI_JMEM, &kva,
	    BUS_DMA_NOWAIT)) {
		printf("%s: can't map dma buffers (%d bytes)\n",
		    sc->sc_dv.dv_xname, TI_JMEM);
		error = ENOBUFS;
		goto out;
	}

	state = 2;
	if (bus_dmamap_create(sc->sc_dmatag, TI_JMEM, 1, TI_JMEM, 0,
	    BUS_DMA_NOWAIT, &sc->ti_cdata.ti_rx_jumbo_map)) {
		printf("%s: can't create dma map\n", sc->sc_dv.dv_xname);
		error = ENOBUFS;
		goto out;
	}

	state = 3;
	if (bus_dmamap_load(sc->sc_dmatag, sc->ti_cdata.ti_rx_jumbo_map, kva,
	    TI_JMEM, NULL, BUS_DMA_NOWAIT)) {
		printf("%s: can't load dma map\n", sc->sc_dv.dv_xname);
		error = ENOBUFS;
		goto out;
	}

	state = 4;
	sc->ti_cdata.ti_jumbo_buf = (caddr_t)kva;

	SLIST_INIT(&sc->ti_jfree_listhead);
	SLIST_INIT(&sc->ti_jinuse_listhead);

	/*
	 * Now divide it up into 9K pieces and save the addresses
	 * in an array.
	 */
	ptr = sc->ti_cdata.ti_jumbo_buf;
	for (i = 0; i < TI_JSLOTS; i++) {
		sc->ti_cdata.ti_jslots[i].ti_buf = ptr;
		sc->ti_cdata.ti_jslots[i].ti_inuse = 0;
		ptr += TI_JLEN;
		entry = malloc(sizeof(struct ti_jpool_entry),
			       M_DEVBUF, M_NOWAIT);
		if (entry == NULL) {
			sc->ti_cdata.ti_jumbo_buf = NULL;
			printf("%s: no memory for jumbo buffer queue\n",
			    sc->sc_dv.dv_xname);
			error = ENOBUFS;
			goto out;
		}
		entry->slot = i;
		SLIST_INSERT_HEAD(&sc->ti_jfree_listhead, entry, jpool_entries);
	}
out:
	if (error != 0) {
		switch (state) {
		case 4:
			bus_dmamap_unload(sc->sc_dmatag,
			    sc->ti_cdata.ti_rx_jumbo_map);
		case 3:
			bus_dmamap_destroy(sc->sc_dmatag,
			    sc->ti_cdata.ti_rx_jumbo_map);
		case 2:
			bus_dmamem_unmap(sc->sc_dmatag, kva, TI_JMEM);
		case 1:
			bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
			break;
		default:
			break;
		}
	}

	return (error);
}

/*
 * Allocate a jumbo buffer.
 */
void *
ti_jalloc(struct ti_softc *sc)
{
	struct ti_jpool_entry   *entry;

	entry = SLIST_FIRST(&sc->ti_jfree_listhead);

	if (entry == NULL)
		return (NULL);

	SLIST_REMOVE_HEAD(&sc->ti_jfree_listhead, jpool_entries);
	SLIST_INSERT_HEAD(&sc->ti_jinuse_listhead, entry, jpool_entries);
	sc->ti_cdata.ti_jslots[entry->slot].ti_inuse = 1;
	return (sc->ti_cdata.ti_jslots[entry->slot].ti_buf);
}

/*
 * Release a jumbo buffer.
 */
void
ti_jfree(caddr_t buf, u_int size, void *arg)
{
	struct ti_softc		*sc;
	int			i;
	struct ti_jpool_entry	*entry;

	/* Extract the softc struct pointer. */
	sc = (struct ti_softc *)arg;

	if (sc == NULL)
		panic("ti_jfree: can't find softc pointer!");

	/* calculate the slot this buffer belongs to */
	i = ((vaddr_t)buf - (vaddr_t)sc->ti_cdata.ti_jumbo_buf) / TI_JLEN;

	if ((i < 0) || (i >= TI_JSLOTS))
		panic("ti_jfree: asked to free buffer that we don't manage!");
	else if (sc->ti_cdata.ti_jslots[i].ti_inuse == 0)
		panic("ti_jfree: buffer already free!");

	sc->ti_cdata.ti_jslots[i].ti_inuse--;
	if(sc->ti_cdata.ti_jslots[i].ti_inuse == 0) {
		entry = SLIST_FIRST(&sc->ti_jinuse_listhead);
		if (entry == NULL)
			panic("ti_jfree: buffer not in use!");
		entry->slot = i;
		SLIST_REMOVE_HEAD(&sc->ti_jinuse_listhead, jpool_entries);
		SLIST_INSERT_HEAD(&sc->ti_jfree_listhead,
				  entry, jpool_entries);
	}
}

/*
 * Intialize a standard receive ring descriptor.
 */
int
ti_newbuf_std(struct ti_softc *sc, int i, struct mbuf *m,
    bus_dmamap_t dmamap)
{
	struct mbuf		*m_new = NULL;
	struct ti_rx_desc	*r;

	if (dmamap == NULL) {
		/* if (m) panic() */

		if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, 1, MCLBYTES,
				      0, BUS_DMA_NOWAIT, &dmamap)) {
			printf("%s: can't create recv map\n",
			       sc->sc_dv.dv_xname);
			return (ENOMEM);
		}
	} else if (m == NULL)
		bus_dmamap_unload(sc->sc_dmatag, dmamap);

	sc->ti_cdata.ti_rx_std_map[i] = dmamap;

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return (ENOBUFS);

		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			m_freem(m_new);
			return (ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;

		m_adj(m_new, ETHER_ALIGN);

		if (bus_dmamap_load_mbuf(sc->sc_dmatag, dmamap, m_new,
					 BUS_DMA_NOWAIT))
			return (ENOBUFS);

	} else {
		/*
		 * We're re-using a previously allocated mbuf;
		 * be sure to re-init pointers and lengths to
		 * default values.
		 */
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
		m_adj(m_new, ETHER_ALIGN);
	}

	sc->ti_cdata.ti_rx_std_chain[i] = m_new;
	r = &sc->ti_rdata->ti_rx_std_ring[i];
	TI_HOSTADDR(r->ti_addr) = dmamap->dm_segs[0].ds_addr;
	r->ti_type = TI_BDTYPE_RECV_BD;
	r->ti_flags = TI_BDFLAG_IP_CKSUM;
	r->ti_len = dmamap->dm_segs[0].ds_len;
	r->ti_idx = i;

	if ((dmamap->dm_segs[0].ds_addr & ~(MCLBYTES - 1)) !=
	    ((dmamap->dm_segs[0].ds_addr + dmamap->dm_segs[0].ds_len - 1) & 
	     ~(MCLBYTES - 1)))
	    panic("%s: overwritten!!!", sc->sc_dv.dv_xname);

	return (0);
}

/*
 * Intialize a mini receive ring descriptor. This only applies to
 * the Tigon 2.
 */
int
ti_newbuf_mini(struct ti_softc *sc, int i, struct mbuf *m,
    bus_dmamap_t dmamap)
{
	struct mbuf		*m_new = NULL;
	struct ti_rx_desc	*r;

	if (dmamap == NULL) {
		/* if (m) panic() */

		if (bus_dmamap_create(sc->sc_dmatag, MHLEN, 1, MHLEN,
				      0, BUS_DMA_NOWAIT, &dmamap)) {
			printf("%s: can't create recv map\n",
			       sc->sc_dv.dv_xname);
			return (ENOMEM);
		}
	} else if (m == NULL)
		bus_dmamap_unload(sc->sc_dmatag, dmamap);

	sc->ti_cdata.ti_rx_mini_map[i] = dmamap;

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return (ENOBUFS);
		m_new->m_len = m_new->m_pkthdr.len = MHLEN;
		m_adj(m_new, ETHER_ALIGN);

		if (bus_dmamap_load_mbuf(sc->sc_dmatag, dmamap, m_new,
					 BUS_DMA_NOWAIT))
		return (ENOBUFS);

	} else {
		/*
		 * We're re-using a previously allocated mbuf;
		 * be sure to re-init pointers and lengths to
		 * default values.
		 */
		m_new = m;
		m_new->m_data = m_new->m_pktdat;
		m_new->m_len = m_new->m_pkthdr.len = MHLEN;
	}

	r = &sc->ti_rdata->ti_rx_mini_ring[i];
	sc->ti_cdata.ti_rx_mini_chain[i] = m_new;
	TI_HOSTADDR(r->ti_addr) = dmamap->dm_segs[0].ds_addr;
	r->ti_type = TI_BDTYPE_RECV_BD;
	r->ti_flags = TI_BDFLAG_MINI_RING | TI_BDFLAG_IP_CKSUM;
	r->ti_len = dmamap->dm_segs[0].ds_len;
	r->ti_idx = i;

	return (0);
}

/*
 * Initialize a jumbo receive ring descriptor. This allocates
 * a jumbo buffer from the pool managed internally by the driver.
 */
int
ti_newbuf_jumbo(struct ti_softc *sc, int i, struct mbuf *m)
{
	struct mbuf		*m_new = NULL;
	struct ti_rx_desc	*r;

	if (m == NULL) {
		caddr_t			buf = NULL;

		/* Allocate the mbuf. */
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return (ENOBUFS);

		/* Allocate the jumbo buffer */
		buf = ti_jalloc(sc);
		if (buf == NULL) {
			m_freem(m_new);
			return (ENOBUFS);
		}

		/* Attach the buffer to the mbuf. */
		m_new->m_len = m_new->m_pkthdr.len = TI_JUMBO_FRAMELEN;
		MEXTADD(m_new, buf, TI_JUMBO_FRAMELEN, 0, ti_jfree, sc);
	} else {
		/*
		 * We're re-using a previously allocated mbuf;
		 * be sure to re-init pointers and lengths to
		 * default values.
		 */
		m_new = m;
		m_new->m_data = m_new->m_ext.ext_buf;
		m_new->m_ext.ext_size = TI_JUMBO_FRAMELEN;
	}

	m_adj(m_new, ETHER_ALIGN);
	/* Set up the descriptor. */
	r = &sc->ti_rdata->ti_rx_jumbo_ring[i];
	sc->ti_cdata.ti_rx_jumbo_chain[i] = m_new;
	TI_HOSTADDR(r->ti_addr) = TI_JUMBO_DMA_ADDR(sc, m_new);
	r->ti_type = TI_BDTYPE_RECV_JUMBO_BD;
	r->ti_flags = TI_BDFLAG_JUMBO_RING | TI_BDFLAG_IP_CKSUM;
	r->ti_len = m_new->m_len;
	r->ti_idx = i;

	return (0);
}

/*
 * The standard receive ring has 512 entries in it. At 2K per mbuf cluster,
 * that's 1MB of memory, which is a lot. For now, we fill only the first
 * 256 ring entries and hope that our CPU is fast enough to keep up with
 * the NIC.
 */
int
ti_init_rx_ring_std(struct ti_softc *sc)
{
	int		i;
	struct ti_cmd_desc	cmd;

	for (i = 0; i < TI_SSLOTS; i++) {
		if (ti_newbuf_std(sc, i, NULL, 0) == ENOBUFS)
			return (ENOBUFS);
	}

	TI_UPDATE_STDPROD(sc, i - 1);
	sc->ti_std = i - 1;

	return (0);
}

void
ti_free_rx_ring_std(struct ti_softc *sc)
{
	int		i;

	for (i = 0; i < TI_STD_RX_RING_CNT; i++) {
		if (sc->ti_cdata.ti_rx_std_chain[i] != NULL) {
			m_freem(sc->ti_cdata.ti_rx_std_chain[i]);
			sc->ti_cdata.ti_rx_std_chain[i] = NULL;
			bus_dmamap_destroy(sc->sc_dmatag,
					   sc->ti_cdata.ti_rx_std_map[i]);
			sc->ti_cdata.ti_rx_std_map[i] = 0;
		}
		bzero((char *)&sc->ti_rdata->ti_rx_std_ring[i],
		    sizeof(struct ti_rx_desc));
	}
}

int
ti_init_rx_ring_jumbo(struct ti_softc *sc)
{
	int		i;
	struct ti_cmd_desc	cmd;

	for (i = 0; i < TI_JUMBO_RX_RING_CNT; i++) {
		if (ti_newbuf_jumbo(sc, i, NULL) == ENOBUFS)
			return (ENOBUFS);
	};

	TI_UPDATE_JUMBOPROD(sc, i - 1);
	sc->ti_jumbo = i - 1;

	return (0);
}

void
ti_free_rx_ring_jumbo(struct ti_softc *sc)
{
	int		i;

	for (i = 0; i < TI_JUMBO_RX_RING_CNT; i++) {
		if (sc->ti_cdata.ti_rx_jumbo_chain[i] != NULL) {
			m_freem(sc->ti_cdata.ti_rx_jumbo_chain[i]);
			sc->ti_cdata.ti_rx_jumbo_chain[i] = NULL;
		}
		bzero((char *)&sc->ti_rdata->ti_rx_jumbo_ring[i],
		    sizeof(struct ti_rx_desc));
	}
}

int
ti_init_rx_ring_mini(struct ti_softc *sc)
{
	int		i;

	for (i = 0; i < TI_MSLOTS; i++) {
		if (ti_newbuf_mini(sc, i, NULL, 0) == ENOBUFS)
			return (ENOBUFS);
	};

	TI_UPDATE_MINIPROD(sc, i - 1);
	sc->ti_mini = i - 1;

	return (0);
}

void
ti_free_rx_ring_mini(struct ti_softc *sc)
{
	int		i;

	for (i = 0; i < TI_MINI_RX_RING_CNT; i++) {
		if (sc->ti_cdata.ti_rx_mini_chain[i] != NULL) {
			m_freem(sc->ti_cdata.ti_rx_mini_chain[i]);
			sc->ti_cdata.ti_rx_mini_chain[i] = NULL;
			bus_dmamap_destroy(sc->sc_dmatag,
					   sc->ti_cdata.ti_rx_mini_map[i]);
			sc->ti_cdata.ti_rx_mini_map[i] = 0;
		}
		bzero((char *)&sc->ti_rdata->ti_rx_mini_ring[i],
		    sizeof(struct ti_rx_desc));
	}
}

void
ti_free_tx_ring(struct ti_softc *sc)
{
	int		i;
	struct ti_txmap_entry *entry;

	if (sc->ti_rdata->ti_tx_ring == NULL)
		return;

	for (i = 0; i < TI_TX_RING_CNT; i++) {
		if (sc->ti_cdata.ti_tx_chain[i] != NULL) {
			m_freem(sc->ti_cdata.ti_tx_chain[i]);
			sc->ti_cdata.ti_tx_chain[i] = NULL;
			SLIST_INSERT_HEAD(&sc->ti_tx_map_listhead,
					    sc->ti_cdata.ti_tx_map[i], link);
			sc->ti_cdata.ti_tx_map[i] = 0;
		}
		bzero((char *)&sc->ti_rdata->ti_tx_ring[i],
		    sizeof(struct ti_tx_desc));
	}

	while ((entry = SLIST_FIRST(&sc->ti_tx_map_listhead))) {
		SLIST_REMOVE_HEAD(&sc->ti_tx_map_listhead, link);
		bus_dmamap_destroy(sc->sc_dmatag, entry->dmamap);
		free(entry, M_DEVBUF);
	}
}

int
ti_init_tx_ring(struct ti_softc *sc)
{
	int i;
	bus_dmamap_t dmamap;
	struct ti_txmap_entry *entry;

	sc->ti_txcnt = 0;
	sc->ti_tx_saved_considx = 0;
	sc->ti_tx_saved_prodidx = 0;
	CSR_WRITE_4(sc, TI_MB_SENDPROD_IDX, 0);

	SLIST_INIT(&sc->ti_tx_map_listhead);
	for (i = 0; i < TI_TX_RING_CNT; i++) {
		if (bus_dmamap_create(sc->sc_dmatag, TI_JUMBO_FRAMELEN,
		    TI_NTXSEG, MCLBYTES, 0, BUS_DMA_NOWAIT, &dmamap))
			return (ENOBUFS);

		entry = malloc(sizeof(*entry), M_DEVBUF, M_NOWAIT);
		if (!entry) {
			bus_dmamap_destroy(sc->sc_dmatag, dmamap);
			return (ENOBUFS);
		}
		entry->dmamap = dmamap;
		SLIST_INSERT_HEAD(&sc->ti_tx_map_listhead, entry, link);
	}

	return (0);
}

/*
 * The Tigon 2 firmware has a new way to add/delete multicast addresses,
 * but we have to support the old way too so that Tigon 1 cards will
 * work.
 */
void
ti_add_mcast(struct ti_softc *sc, struct ether_addr *addr)
{
	struct ti_cmd_desc	cmd;
	u_int16_t		*m;
	u_int32_t		ext[2] = {0, 0};

	m = (u_int16_t *)&addr->ether_addr_octet[0];

	switch(sc->ti_hwrev) {
	case TI_HWREV_TIGON:
		CSR_WRITE_4(sc, TI_GCR_MAR0, htons(m[0]));
		CSR_WRITE_4(sc, TI_GCR_MAR1, (htons(m[1]) << 16) | htons(m[2]));
		TI_DO_CMD(TI_CMD_ADD_MCAST_ADDR, 0, 0);
		break;
	case TI_HWREV_TIGON_II:
		ext[0] = htons(m[0]);
		ext[1] = (htons(m[1]) << 16) | htons(m[2]);
		TI_DO_CMD_EXT(TI_CMD_EXT_ADD_MCAST, 0, 0, (caddr_t)&ext, 2);
		break;
	default:
		printf("%s: unknown hwrev\n", sc->sc_dv.dv_xname);
		break;
	}
}

void
ti_del_mcast(struct ti_softc *sc, struct ether_addr *addr)
{
	struct ti_cmd_desc	cmd;
	u_int16_t		*m;
	u_int32_t		ext[2] = {0, 0};

	m = (u_int16_t *)&addr->ether_addr_octet[0];

	switch(sc->ti_hwrev) {
	case TI_HWREV_TIGON:
		CSR_WRITE_4(sc, TI_GCR_MAR0, htons(m[0]));
		CSR_WRITE_4(sc, TI_GCR_MAR1, (htons(m[1]) << 16) | htons(m[2]));
		TI_DO_CMD(TI_CMD_DEL_MCAST_ADDR, 0, 0);
		break;
	case TI_HWREV_TIGON_II:
		ext[0] = htons(m[0]);
		ext[1] = (htons(m[1]) << 16) | htons(m[2]);
		TI_DO_CMD_EXT(TI_CMD_EXT_DEL_MCAST, 0, 0, (caddr_t)&ext, 2);
		break;
	default:
		printf("%s: unknown hwrev\n", sc->sc_dv.dv_xname);
		break;
	}
}

/*
 * Configure the Tigon's multicast address filter.
 *
 * The actual multicast table management is a bit of a pain, thanks to
 * slight brain damage on the part of both Alteon and us. With our
 * multicast code, we are only alerted when the multicast address table
 * changes and at that point we only have the current list of addresses:
 * we only know the current state, not the previous state, so we don't
 * actually know what addresses were removed or added. The firmware has
 * state, but we can't get our grubby mits on it, and there is no 'delete
 * all multicast addresses' command. Hence, we have to maintain our own
 * state so we know what addresses have been programmed into the NIC at
 * any given time.
 */
void
ti_setmulti(struct ti_softc *sc)
{
	struct ifnet		*ifp;
	struct arpcom		*ac = &sc->arpcom;
	struct ether_multi	*enm;
	struct ether_multistep	step;
	struct ti_cmd_desc	cmd;
	struct ti_mc_entry	*mc;
	u_int32_t		intrs;
 
	ifp = &sc->arpcom.ac_if;

allmulti:
	if (ifp->if_flags & IFF_ALLMULTI) {
		TI_DO_CMD(TI_CMD_SET_ALLMULTI, TI_CMD_CODE_ALLMULTI_ENB, 0);
		return;
	} else {
		TI_DO_CMD(TI_CMD_SET_ALLMULTI, TI_CMD_CODE_ALLMULTI_DIS, 0);
	}

	/* Disable interrupts. */
	intrs = CSR_READ_4(sc, TI_MB_HOSTINTR);
	CSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);

	/* First, zot all the existing filters. */
	while (SLIST_FIRST(&sc->ti_mc_listhead) != NULL) {
		mc = SLIST_FIRST(&sc->ti_mc_listhead);
		ti_del_mcast(sc, &mc->mc_addr);
		SLIST_REMOVE_HEAD(&sc->ti_mc_listhead, mc_entries);
		free(mc, M_DEVBUF);
	}

	/* Now program new ones. */
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			/* Re-enable interrupts. */
			CSR_WRITE_4(sc, TI_MB_HOSTINTR, intrs);

			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}
		mc = malloc(sizeof(struct ti_mc_entry), M_DEVBUF, M_NOWAIT);
		if (mc == NULL)
			panic("ti_setmulti");
		bcopy(enm->enm_addrlo, (char *)&mc->mc_addr, ETHER_ADDR_LEN);
		SLIST_INSERT_HEAD(&sc->ti_mc_listhead, mc, mc_entries);
		ti_add_mcast(sc, &mc->mc_addr);
		ETHER_NEXT_MULTI(step, enm);
	}

	/* Re-enable interrupts. */
	CSR_WRITE_4(sc, TI_MB_HOSTINTR, intrs);
}

/*
 * Check to see if the BIOS has configured us for a 64 bit slot when
 * we aren't actually in one. If we detect this condition, we can work
 * around it on the Tigon 2 by setting a bit in the PCI state register,
 * but for the Tigon 1 we must give up and abort the interface attach.
 */
int
ti_64bitslot_war(struct ti_softc *sc)
{
	if (!(CSR_READ_4(sc, TI_PCI_STATE) & TI_PCISTATE_32BIT_BUS)) {
		CSR_WRITE_4(sc, 0x600, 0);
		CSR_WRITE_4(sc, 0x604, 0);
		CSR_WRITE_4(sc, 0x600, 0x5555AAAA);
		if (CSR_READ_4(sc, 0x604) == 0x5555AAAA) {
			if (sc->ti_hwrev == TI_HWREV_TIGON)
				return (EINVAL);
			else {
				TI_SETBIT(sc, TI_PCI_STATE,
				    TI_PCISTATE_32BIT_BUS);
				return (0);
			}
		}
	}

	return (0);
}

/*
 * Do endian, PCI and DMA initialization. Also check the on-board ROM
 * self-test results.
 */
int
ti_chipinit(struct ti_softc *sc)
{
	u_int32_t		cacheline;
	u_int32_t		pci_writemax = 0;
	u_int32_t		chip_rev;

	/* Initialize link to down state. */
	sc->ti_linkstat = TI_EV_CODE_LINK_DOWN;

	/* Set endianness before we access any non-PCI registers. */
	CSR_WRITE_4(sc, TI_MISC_HOST_CTL,
	    TI_MHC_LITTLEENDIAN_INIT | (TI_MHC_LITTLEENDIAN_INIT << 24));

	/* Check the ROM failed bit to see if self-tests passed. */
	if (CSR_READ_4(sc, TI_CPU_STATE) & TI_CPUSTATE_ROMFAIL) {
		printf("%s: board self-diagnostics failed!\n",
		    sc->sc_dv.dv_xname);
		return (ENODEV);
	}

	/* Halt the CPU. */
	TI_SETBIT(sc, TI_CPU_STATE, TI_CPUSTATE_HALT);

	/* Figure out the hardware revision. */
	chip_rev = CSR_READ_4(sc, TI_MISC_HOST_CTL) & TI_MHC_CHIP_REV_MASK;
	switch(chip_rev) {
	case TI_REV_TIGON_I:
		sc->ti_hwrev = TI_HWREV_TIGON;
		break;
	case TI_REV_TIGON_II:
		sc->ti_hwrev = TI_HWREV_TIGON_II;
		break;
	default:
		printf("\n");
		printf("%s: unsupported chip revision: %x\n",
		    sc->sc_dv.dv_xname, chip_rev);
		return (ENODEV);
	}

	/* Do special setup for Tigon 2. */
	if (sc->ti_hwrev == TI_HWREV_TIGON_II) {
		TI_SETBIT(sc, TI_CPU_CTL_B, TI_CPUSTATE_HALT);
		TI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_SRAM_BANK_512K);
		TI_SETBIT(sc, TI_MISC_CONF, TI_MCR_SRAM_SYNCHRONOUS);
	}

	/* Set up the PCI state register. */
	CSR_WRITE_4(sc, TI_PCI_STATE, TI_PCI_READ_CMD|TI_PCI_WRITE_CMD);
	if (sc->ti_hwrev == TI_HWREV_TIGON_II)
		TI_SETBIT(sc, TI_PCI_STATE, TI_PCISTATE_USE_MEM_RD_MULT);

	/* Clear the read/write max DMA parameters. */
	TI_CLRBIT(sc, TI_PCI_STATE, (TI_PCISTATE_WRITE_MAXDMA|
	    TI_PCISTATE_READ_MAXDMA));

	/* Get cache line size. */
	cacheline = CSR_READ_4(sc, TI_PCI_BIST) & 0xFF;

	/*
	 * If the system has set enabled the PCI memory write
	 * and invalidate command in the command register, set
	 * the write max parameter accordingly. This is necessary
	 * to use MWI with the Tigon 2.
	 */
	if (CSR_READ_4(sc, TI_PCI_CMDSTAT) & PCI_COMMAND_INVALIDATE_ENABLE) {
		switch(cacheline) {
		case 1:
		case 4:
		case 8:
		case 16:
		case 32:
		case 64:
			break;
		default:
		/* Disable PCI memory write and invalidate. */
			CSR_WRITE_4(sc, TI_PCI_CMDSTAT, CSR_READ_4(sc,
			    TI_PCI_CMDSTAT) & ~PCI_COMMAND_INVALIDATE_ENABLE);
			break;
		}
	}

#ifdef __brokenalpha__
	/*
	 * From the Alteon sample driver:
	 * Must insure that we do not cross an 8K (bytes) boundary
	 * for DMA reads.  Our highest limit is 1K bytes.  This is a
	 * restriction on some ALPHA platforms with early revision
	 * 21174 PCI chipsets, such as the AlphaPC 164lx
	 */
	TI_SETBIT(sc, TI_PCI_STATE, pci_writemax|TI_PCI_READMAX_1024);
#else
	TI_SETBIT(sc, TI_PCI_STATE, pci_writemax);
#endif

	/* This sets the min dma param all the way up (0xff). */
	TI_SETBIT(sc, TI_PCI_STATE, TI_PCISTATE_MINDMA);

	/* Configure DMA variables. */
	CSR_WRITE_4(sc, TI_GCR_OPMODE, TI_DMA_SWAP_OPTIONS |
	    TI_OPMODE_WARN_ENB | TI_OPMODE_FATAL_ENB |
	    TI_OPMODE_DONT_FRAG_JUMBO);

	/* Recommended settings from Tigon manual. */
	CSR_WRITE_4(sc, TI_GCR_DMA_WRITECFG, TI_DMA_STATE_THRESH_8W);
	CSR_WRITE_4(sc, TI_GCR_DMA_READCFG, TI_DMA_STATE_THRESH_8W);

	if (ti_64bitslot_war(sc)) {
		printf("%s: bios thinks we're in a 64 bit slot, "
		    "but we aren't", sc->sc_dv.dv_xname);
		return (EINVAL);
	}

	return (0);
}

/*
 * Initialize the general information block and firmware, and
 * start the CPU(s) running.
 */
int
ti_gibinit(struct ti_softc *sc)
{
	struct ti_rcb		*rcb;
	int			i;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	/* Disable interrupts for now. */
	CSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);

	/*
	 * Tell the chip where to find the general information block.
	 * While this struct could go into >4GB memory, we allocate it in a
	 * single slab with the other descriptors, and those don't seem to
	 * support being located in a 64-bit region.
	 */
	CSR_WRITE_4(sc, TI_GCR_GENINFO_HI, 0);
	CSR_WRITE_4(sc, TI_GCR_GENINFO_LO,
		    TI_RING_DMA_ADDR(sc, ti_info) & 0xffffffff);

	/* Load the firmware into SRAM. */
	ti_loadfw(sc);

	/* Set up the contents of the general info and ring control blocks. */

	/* Set up the event ring and producer pointer. */
	rcb = &sc->ti_rdata->ti_info.ti_ev_rcb;

	TI_HOSTADDR(rcb->ti_hostaddr) = TI_RING_DMA_ADDR(sc, ti_event_ring);
	rcb->ti_flags = 0;
	TI_HOSTADDR(sc->ti_rdata->ti_info.ti_ev_prodidx_ptr) =
		TI_RING_DMA_ADDR(sc, ti_ev_prodidx_r);
	sc->ti_ev_prodidx.ti_idx = 0;
	CSR_WRITE_4(sc, TI_GCR_EVENTCONS_IDX, 0);
	sc->ti_ev_saved_considx = 0;

	/* Set up the command ring and producer mailbox. */
	rcb = &sc->ti_rdata->ti_info.ti_cmd_rcb;

	TI_HOSTADDR(rcb->ti_hostaddr) = TI_GCR_NIC_ADDR(TI_GCR_CMDRING);
	rcb->ti_flags = 0;
	rcb->ti_max_len = 0;
	for (i = 0; i < TI_CMD_RING_CNT; i++) {
		CSR_WRITE_4(sc, TI_GCR_CMDRING + (i * 4), 0);
	}
	CSR_WRITE_4(sc, TI_GCR_CMDCONS_IDX, 0);
	CSR_WRITE_4(sc, TI_MB_CMDPROD_IDX, 0);
	sc->ti_cmd_saved_prodidx = 0;

	/*
	 * Assign the address of the stats refresh buffer.
	 * We re-use the current stats buffer for this to
	 * conserve memory.
	 */
	TI_HOSTADDR(sc->ti_rdata->ti_info.ti_refresh_stats_ptr) =
		TI_RING_DMA_ADDR(sc, ti_info.ti_stats);

	/* Set up the standard receive ring. */
	rcb = &sc->ti_rdata->ti_info.ti_std_rx_rcb;
	TI_HOSTADDR(rcb->ti_hostaddr) =
		TI_RING_DMA_ADDR(sc, ti_rx_std_ring);
	rcb->ti_max_len = ETHER_MAX_LEN;
	rcb->ti_flags = 0;
	rcb->ti_flags |= TI_RCB_FLAG_IP_CKSUM | TI_RCB_FLAG_NO_PHDR_CKSUM;
#if NVLAN > 0
	if (ifp->if_capabilities & IFCAP_VLAN_HWTAGGING)
		rcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;
#endif

	/* Set up the jumbo receive ring. */
	rcb = &sc->ti_rdata->ti_info.ti_jumbo_rx_rcb;
	TI_HOSTADDR(rcb->ti_hostaddr) = TI_RING_DMA_ADDR(sc, ti_rx_jumbo_ring);
	rcb->ti_max_len = TI_JUMBO_FRAMELEN;
	rcb->ti_flags = 0;
	rcb->ti_flags |= TI_RCB_FLAG_IP_CKSUM | TI_RCB_FLAG_NO_PHDR_CKSUM;
#if NVLAN > 0
	if (ifp->if_capabilities & IFCAP_VLAN_HWTAGGING)
		rcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;
#endif

	/*
	 * Set up the mini ring. Only activated on the
	 * Tigon 2 but the slot in the config block is
	 * still there on the Tigon 1.
	 */
	rcb = &sc->ti_rdata->ti_info.ti_mini_rx_rcb;
	TI_HOSTADDR(rcb->ti_hostaddr) = TI_RING_DMA_ADDR(sc, ti_rx_mini_ring);
	rcb->ti_max_len = MHLEN - ETHER_ALIGN;
	if (sc->ti_hwrev == TI_HWREV_TIGON)
		rcb->ti_flags = TI_RCB_FLAG_RING_DISABLED;
	else
		rcb->ti_flags = 0;
	rcb->ti_flags |= TI_RCB_FLAG_IP_CKSUM | TI_RCB_FLAG_NO_PHDR_CKSUM;
#if NVLAN > 0
	if (ifp->if_capabilities & IFCAP_VLAN_HWTAGGING)
		rcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;
#endif

	/*
	 * Set up the receive return ring.
	 */
	rcb = &sc->ti_rdata->ti_info.ti_return_rcb;
	TI_HOSTADDR(rcb->ti_hostaddr) = TI_RING_DMA_ADDR(sc,ti_rx_return_ring);
	rcb->ti_flags = 0;
	rcb->ti_max_len = TI_RETURN_RING_CNT;
	TI_HOSTADDR(sc->ti_rdata->ti_info.ti_return_prodidx_ptr) =
	    TI_RING_DMA_ADDR(sc, ti_return_prodidx_r);

	/*
	 * Set up the tx ring. Note: for the Tigon 2, we have the option
	 * of putting the transmit ring in the host's address space and
	 * letting the chip DMA it instead of leaving the ring in the NIC's
	 * memory and accessing it through the shared memory region. We
	 * do this for the Tigon 2, but it doesn't work on the Tigon 1,
	 * so we have to revert to the shared memory scheme if we detect
	 * a Tigon 1 chip.
	 */
	CSR_WRITE_4(sc, TI_WINBASE, TI_TX_RING_BASE);
	bzero((char *)sc->ti_rdata->ti_tx_ring,
	    TI_TX_RING_CNT * sizeof(struct ti_tx_desc));
	rcb = &sc->ti_rdata->ti_info.ti_tx_rcb;
	if (sc->ti_hwrev == TI_HWREV_TIGON)
		rcb->ti_flags = 0;
	else
		rcb->ti_flags = TI_RCB_FLAG_HOST_RING;
	rcb->ti_flags |= TI_RCB_FLAG_IP_CKSUM | TI_RCB_FLAG_NO_PHDR_CKSUM;
#if NVLAN > 0
	if (ifp->if_capabilities & IFCAP_VLAN_HWTAGGING)
		rcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;
#endif
	rcb->ti_max_len = TI_TX_RING_CNT;
	if (sc->ti_hwrev == TI_HWREV_TIGON)
		TI_HOSTADDR(rcb->ti_hostaddr) = TI_TX_RING_BASE;
	else
		TI_HOSTADDR(rcb->ti_hostaddr) =
			TI_RING_DMA_ADDR(sc, ti_tx_ring);
	TI_HOSTADDR(sc->ti_rdata->ti_info.ti_tx_considx_ptr) =
		TI_RING_DMA_ADDR(sc, ti_tx_considx_r);

	TI_RING_DMASYNC(sc, ti_info, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

	/* Set up tuneables */
	CSR_WRITE_4(sc, TI_GCR_RX_COAL_TICKS, (sc->ti_rx_coal_ticks / 10));
	CSR_WRITE_4(sc, TI_GCR_TX_COAL_TICKS, sc->ti_tx_coal_ticks);
	CSR_WRITE_4(sc, TI_GCR_STAT_TICKS, sc->ti_stat_ticks);
	CSR_WRITE_4(sc, TI_GCR_RX_MAX_COAL_BD, sc->ti_rx_max_coal_bds);
	CSR_WRITE_4(sc, TI_GCR_TX_MAX_COAL_BD, sc->ti_tx_max_coal_bds);
	CSR_WRITE_4(sc, TI_GCR_TX_BUFFER_RATIO, sc->ti_tx_buf_ratio);

	/* Turn interrupts on. */
	CSR_WRITE_4(sc, TI_GCR_MASK_INTRS, 0);
	CSR_WRITE_4(sc, TI_MB_HOSTINTR, 0);

	/* Start CPU. */
	TI_CLRBIT(sc, TI_CPU_STATE, (TI_CPUSTATE_HALT|TI_CPUSTATE_STEP));

	return (0);
}

/*
 * Probe for a Tigon chip. Check the PCI vendor and device IDs
 * against our list and return its name if we find a match.
 */
int
ti_probe(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, ti_devices,
	    sizeof(ti_devices)/sizeof(ti_devices[0])));
}

void
ti_attach(struct device *parent, struct device *self, void *aux)
{
	struct ti_softc *sc = (struct ti_softc *)self;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
	bus_size_t size;
	bus_dma_segment_t seg;
	int rseg;
	struct ifnet *ifp;
	caddr_t kva;

	/*
	 * Map control/status registers.
	 */

	if (pci_mapreg_map(pa, TI_PCI_LOMEM,
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,
	    &sc->ti_btag, &sc->ti_bhandle, NULL, &size, 0)) {
 		printf(": can't map mem space\n");
		return;
 	}

	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		goto fail_1;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->ti_intrhand = pci_intr_establish(pc, ih, IPL_NET, ti_intr, sc,
	    self->dv_xname);
	if (sc->ti_intrhand == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail_1;
	}

	if (ti_chipinit(sc)) {
		printf("%s: chip initialization failed\n", sc->sc_dv.dv_xname);
		goto fail_2;
	}

	/* Zero out the NIC's on-board SRAM. */
	ti_mem_set(sc, 0x2000, 0x100000 - 0x2000);

	/* Init again -- zeroing memory may have clobbered some registers. */
	if (ti_chipinit(sc)) {
		printf("%s: chip initialization failed\n", sc->sc_dv.dv_xname);
		goto fail_2;
	}

	/*
	 * Get station address from the EEPROM. Note: the manual states
	 * that the MAC address is at offset 0x8c, however the data is
	 * stored as two longwords (since that's how it's loaded into
	 * the NIC). This means the MAC address is actually preceded
	 * by two zero bytes. We need to skip over those.
	 */
	if (ti_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
				TI_EE_MAC_OFFSET + 2, ETHER_ADDR_LEN)) {
		printf("%s: failed to read station address\n",
		    sc->sc_dv.dv_xname);
		free(sc, M_DEVBUF);
		goto fail_2;
	}

	/*
	 * A Tigon chip was detected. Inform the world.
	 */
	printf(": %s, address %s\n", intrstr,
	     ether_sprintf(sc->arpcom.ac_enaddr));

	/* Allocate the general information block and ring buffers. */
	sc->sc_dmatag = pa->pa_dmat;
	if (bus_dmamem_alloc(sc->sc_dmatag, sizeof(struct ti_ring_data),
	    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
		printf("%s: can't alloc rx buffers\n", sc->sc_dv.dv_xname);
		goto fail_2;
	}
	if (bus_dmamem_map(sc->sc_dmatag, &seg, rseg,
	    sizeof(struct ti_ring_data), &kva, BUS_DMA_NOWAIT)) {
		printf("%s: can't map dma buffers (%d bytes)\n",
		       sc->sc_dv.dv_xname, sizeof(struct ti_ring_data));
		goto fail_3;
	}
	if (bus_dmamap_create(sc->sc_dmatag, sizeof(struct ti_ring_data), 1,
	    sizeof(struct ti_ring_data), 0, BUS_DMA_NOWAIT,
	    &sc->ti_ring_map)) {
		printf("%s: can't create dma map\n", sc->sc_dv.dv_xname);
		goto fail_4;
	}
	if (bus_dmamap_load(sc->sc_dmatag, sc->ti_ring_map, kva,
	    sizeof(struct ti_ring_data), NULL, BUS_DMA_NOWAIT)) {
		goto fail_5;
	}
	sc->ti_rdata = (struct ti_ring_data *)kva;
	bzero(sc->ti_rdata, sizeof(struct ti_ring_data));

	/* Try to allocate memory for jumbo buffers. */
	if (ti_alloc_jumbo_mem(sc)) {
		printf("%s: jumbo buffer allocation failed\n",
		    sc->sc_dv.dv_xname);
		goto fail_5;
	}

	/*
	 * We really need a better way to tell a 1000baseTX card
	 * from a 1000baseSX one, since in theory there could be
	 * OEMed 1000baseTX cards from lame vendors who aren't
	 * clever enough to change the PCI ID. For the moment
	 * though, the AceNIC is the only copper card available.
	 */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ALTEON &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALTEON_ACENICT)
		sc->ti_copper = 1;
	/* Ok, it's not the only copper card available */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_NETGEAR &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETGEAR_GA620T)
		sc->ti_copper = 1;

	/* Set default tuneable values. */
	sc->ti_stat_ticks = 2 * TI_TICKS_PER_SEC;
	sc->ti_rx_coal_ticks = TI_TICKS_PER_SEC / 5000;
	sc->ti_tx_coal_ticks = TI_TICKS_PER_SEC / 500;
	sc->ti_rx_max_coal_bds = 64;
	sc->ti_tx_max_coal_bds = 128;
	sc->ti_tx_buf_ratio = 21;

	/* Set up ifnet structure */
	ifp = &sc->arpcom.ac_if;
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = ti_ioctl;
	ifp->if_start = ti_start;
	ifp->if_watchdog = ti_watchdog;
	ifp->if_hardmtu = TI_JUMBO_FRAMELEN - ETHER_HDR_LEN;
	IFQ_SET_MAXLEN(&ifp->if_snd, TI_TX_RING_CNT - 1);
	IFQ_SET_READY(&ifp->if_snd);
	bcopy(sc->sc_dv.dv_xname, ifp->if_xname, IFNAMSIZ);

	ifp->if_capabilities = IFCAP_VLAN_MTU;

#if NVLAN > 0
	ifp->if_capabilities |= IFCAP_VLAN_HWTAGGING;
#endif

	/* Set up ifmedia support. */
	ifmedia_init(&sc->ifmedia, IFM_IMASK, ti_ifmedia_upd, ti_ifmedia_sts);
	if (sc->ti_copper) {
		/*
		 * Copper cards allow manual 10/100 mode selection,
		 * but not manual 1000baseTX mode selection. Why?
		 * Because currently there's no way to specify the
		 * master/slave setting through the firmware interface,
		 * so Alteon decided to just bag it and handle it
		 * via autonegotiation.
		 */
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);
		ifmedia_add(&sc->ifmedia,
		    IFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_TX, 0, NULL);
		ifmedia_add(&sc->ifmedia,
		    IFM_ETHER|IFM_100_TX|IFM_FDX, 0, NULL);
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_1000_T, 0, NULL);
		ifmedia_add(&sc->ifmedia,
		    IFM_ETHER|IFM_1000_T|IFM_FDX, 0, NULL);
	} else {
		/* Fiber cards don't support 10/100 modes. */
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_1000_SX, 0, NULL);
		ifmedia_add(&sc->ifmedia,
		    IFM_ETHER|IFM_1000_SX|IFM_FDX, 0, NULL);
	}
	ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);
	ifmedia_set(&sc->ifmedia, IFM_ETHER|IFM_AUTO);

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

	shutdownhook_establish(ti_shutdown, sc);
	return;

fail_5:
	bus_dmamap_destroy(sc->sc_dmatag, sc->ti_ring_map);

fail_4:
	bus_dmamem_unmap(sc->sc_dmatag, kva,
	    sizeof(struct ti_ring_data));

fail_3:
	bus_dmamem_free(sc->sc_dmatag, &seg, rseg);

fail_2:
	pci_intr_disestablish(pc, sc->ti_intrhand);

fail_1:
	bus_space_unmap(sc->ti_btag, sc->ti_bhandle, size);
}

/*
 * Frame reception handling. This is called if there's a frame
 * on the receive return list.
 *
 * Note: we have to be able to handle three possibilities here:
 * 1) the frame is from the mini receive ring (can only happen)
 *    on Tigon 2 boards)
 * 2) the frame is from the jumbo receive ring
 * 3) the frame is from the standard receive ring
 */

void
ti_rxeof(struct ti_softc *sc)
{
	struct ifnet		*ifp;
	struct ti_cmd_desc	cmd;

	ifp = &sc->arpcom.ac_if;

	while(sc->ti_rx_saved_considx != sc->ti_return_prodidx.ti_idx) {
		struct ti_rx_desc	*cur_rx;
		u_int32_t		rxidx;
		struct mbuf		*m = NULL;
		bus_dmamap_t		dmamap;

		cur_rx =
		    &sc->ti_rdata->ti_rx_return_ring[sc->ti_rx_saved_considx];
		rxidx = cur_rx->ti_idx;
		TI_INC(sc->ti_rx_saved_considx, TI_RETURN_RING_CNT);

		if (cur_rx->ti_flags & TI_BDFLAG_JUMBO_RING) {
			TI_INC(sc->ti_jumbo, TI_JUMBO_RX_RING_CNT);
			m = sc->ti_cdata.ti_rx_jumbo_chain[rxidx];
			sc->ti_cdata.ti_rx_jumbo_chain[rxidx] = NULL;
			if (cur_rx->ti_flags & TI_BDFLAG_ERROR) {
				ifp->if_ierrors++;
				ti_newbuf_jumbo(sc, sc->ti_jumbo, m);
				continue;
			}
			if (ti_newbuf_jumbo(sc, sc->ti_jumbo, NULL)
			    == ENOBUFS) {
				struct mbuf             *m0;
				m0 = m_devget(mtod(m, char *), cur_rx->ti_len,
				    ETHER_ALIGN, ifp, NULL);
				ti_newbuf_jumbo(sc, sc->ti_jumbo, m);
				if (m0 == NULL) {
					ifp->if_ierrors++;
					continue;
				}
				m = m0;
			}
		} else if (cur_rx->ti_flags & TI_BDFLAG_MINI_RING) {
			TI_INC(sc->ti_mini, TI_MINI_RX_RING_CNT);
			m = sc->ti_cdata.ti_rx_mini_chain[rxidx];
			sc->ti_cdata.ti_rx_mini_chain[rxidx] = NULL;
			dmamap = sc->ti_cdata.ti_rx_mini_map[rxidx];
			sc->ti_cdata.ti_rx_mini_map[rxidx] = 0;
			if (cur_rx->ti_flags & TI_BDFLAG_ERROR) {
				ifp->if_ierrors++;
				ti_newbuf_mini(sc, sc->ti_mini, m, dmamap);
				continue;
			}
			if (ti_newbuf_mini(sc, sc->ti_mini, NULL, dmamap)
			    == ENOBUFS) {
				ifp->if_ierrors++;
				ti_newbuf_mini(sc, sc->ti_mini, m, dmamap);
				continue;
			}
		} else {
			TI_INC(sc->ti_std, TI_STD_RX_RING_CNT);
			m = sc->ti_cdata.ti_rx_std_chain[rxidx];
			sc->ti_cdata.ti_rx_std_chain[rxidx] = NULL;
			dmamap = sc->ti_cdata.ti_rx_std_map[rxidx];
			sc->ti_cdata.ti_rx_std_map[rxidx] = 0;
			if (cur_rx->ti_flags & TI_BDFLAG_ERROR) {
				ifp->if_ierrors++;
				ti_newbuf_std(sc, sc->ti_std, m, dmamap);
				continue;
			}
			if (ti_newbuf_std(sc, sc->ti_std, NULL, dmamap)
			    == ENOBUFS) {
				ifp->if_ierrors++;
				ti_newbuf_std(sc, sc->ti_std, m, dmamap);
				continue;
			}
		}

		if (m == NULL)
			panic("%s: couldn't get mbuf", sc->sc_dv.dv_xname);

		m->m_pkthdr.len = m->m_len = cur_rx->ti_len;
		ifp->if_ipackets++;
		m->m_pkthdr.rcvif = ifp;

#if NVLAN > 0
		if (cur_rx->ti_flags & TI_BDFLAG_VLAN_TAG) {
			m->m_pkthdr.ether_vtag = cur_rx->ti_vlan_tag;
			m->m_flags |= M_VLANTAG;
		}
#endif

#if NBPFILTER > 0
		/*
	 	 * Handle BPF listeners. Let the BPF user see the packet.
	 	 */
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

		if ((cur_rx->ti_ip_cksum ^ 0xffff) == 0)
			m->m_pkthdr.csum_flags |= M_IPV4_CSUM_IN_OK;

		ether_input_mbuf(ifp, m);
	}

	/* Only necessary on the Tigon 1. */
	if (sc->ti_hwrev == TI_HWREV_TIGON)
		CSR_WRITE_4(sc, TI_GCR_RXRETURNCONS_IDX,
		    sc->ti_rx_saved_considx);

	TI_UPDATE_STDPROD(sc, sc->ti_std);
	TI_UPDATE_MINIPROD(sc, sc->ti_mini);
	TI_UPDATE_JUMBOPROD(sc, sc->ti_jumbo);
}

void
ti_txeof_tigon1(struct ti_softc *sc)
{
	struct ifnet		*ifp;
	struct ti_txmap_entry	*entry;
	int			active = 1;

	ifp = &sc->arpcom.ac_if;

	/*
	 * Go through our tx ring and free mbufs for those
	 * frames that have been sent.
	 */
	while (sc->ti_tx_saved_considx != sc->ti_tx_considx.ti_idx) {
		u_int32_t		idx = 0;
		struct ti_tx_desc	txdesc;

		idx = sc->ti_tx_saved_considx;
		ti_mem_read(sc, TI_TX_RING_BASE + idx * sizeof(txdesc),
			    sizeof(txdesc), (caddr_t)&txdesc);

		if (txdesc.ti_flags & TI_BDFLAG_END)
			ifp->if_opackets++;

		if (sc->ti_cdata.ti_tx_chain[idx] != NULL) {
			m_freem(sc->ti_cdata.ti_tx_chain[idx]);
			sc->ti_cdata.ti_tx_chain[idx] = NULL;

			entry = sc->ti_cdata.ti_tx_map[idx];
			bus_dmamap_sync(sc->sc_dmatag, entry->dmamap, 0,
			    entry->dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);

			bus_dmamap_unload(sc->sc_dmatag, entry->dmamap);
			SLIST_INSERT_HEAD(&sc->ti_tx_map_listhead, entry,
			    link);
			sc->ti_cdata.ti_tx_map[idx] = NULL;

		}
		sc->ti_txcnt--;
		TI_INC(sc->ti_tx_saved_considx, TI_TX_RING_CNT);
		ifp->if_timer = 0;

		active = 0;
	}

	if (!active)
		ifp->if_flags &= ~IFF_OACTIVE;
}

void
ti_txeof_tigon2(struct ti_softc *sc)
{
	struct ti_tx_desc	*cur_tx = NULL;
	struct ifnet		*ifp;
	struct ti_txmap_entry	*entry;

	ifp = &sc->arpcom.ac_if;

	/*
	 * Go through our tx ring and free mbufs for those
	 * frames that have been sent.
	 */
	while (sc->ti_tx_saved_considx != sc->ti_tx_considx.ti_idx) {
		u_int32_t		idx = 0;

		idx = sc->ti_tx_saved_considx;
		cur_tx = &sc->ti_rdata->ti_tx_ring[idx];

		if (cur_tx->ti_flags & TI_BDFLAG_END)
			ifp->if_opackets++;
		if (sc->ti_cdata.ti_tx_chain[idx] != NULL) {
			m_freem(sc->ti_cdata.ti_tx_chain[idx]);
			sc->ti_cdata.ti_tx_chain[idx] = NULL;

			entry = sc->ti_cdata.ti_tx_map[idx];
			bus_dmamap_sync(sc->sc_dmatag, entry->dmamap, 0,
			    entry->dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);

			bus_dmamap_unload(sc->sc_dmatag, entry->dmamap);
			SLIST_INSERT_HEAD(&sc->ti_tx_map_listhead, entry,
			    link);
			sc->ti_cdata.ti_tx_map[idx] = NULL;

		}
		sc->ti_txcnt--;
		TI_INC(sc->ti_tx_saved_considx, TI_TX_RING_CNT);
		ifp->if_timer = 0;
	}

	if (cur_tx != NULL)
		ifp->if_flags &= ~IFF_OACTIVE;
}

int
ti_intr(void *xsc)
{
	struct ti_softc		*sc;
	struct ifnet		*ifp;

	sc = xsc;
	ifp = &sc->arpcom.ac_if;

	/* XXX checking this register is expensive. */
	/* Make sure this is really our interrupt. */
	if (!(CSR_READ_4(sc, TI_MISC_HOST_CTL) & TI_MHC_INTSTATE))
		return (0);

	/* Ack interrupt and stop others from occurring. */
	CSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);

	if (ifp->if_flags & IFF_RUNNING) {
		/* Check RX return ring producer/consumer */
		ti_rxeof(sc);

		/* Check TX ring producer/consumer */
		if (sc->ti_hwrev == TI_HWREV_TIGON)
			ti_txeof_tigon1(sc);
		else
			ti_txeof_tigon2(sc);
	}

	ti_handle_events(sc);

	/* Re-enable interrupts. */
	CSR_WRITE_4(sc, TI_MB_HOSTINTR, 0);

	if (ifp->if_flags & IFF_RUNNING && !IFQ_IS_EMPTY(&ifp->if_snd))
		ti_start(ifp);

	return (1);
}

void
ti_stats_update(struct ti_softc *sc)
{
	struct ifnet		*ifp;
	struct ti_stats		*stats = &sc->ti_rdata->ti_info.ti_stats;

	ifp = &sc->arpcom.ac_if;

	TI_RING_DMASYNC(sc, ti_info.ti_stats, BUS_DMASYNC_POSTREAD);

	ifp->if_collisions += stats->dot3StatsSingleCollisionFrames +
		stats->dot3StatsMultipleCollisionFrames +
		stats->dot3StatsExcessiveCollisions +
		stats->dot3StatsLateCollisions -
		ifp->if_collisions;

	TI_RING_DMASYNC(sc, ti_info.ti_stats, BUS_DMASYNC_PREREAD);
}

/*
 * Encapsulate an mbuf chain in the tx ring by coupling the mbuf data
 * pointers to descriptors.
 */
int
ti_encap_tigon1(struct ti_softc *sc, struct mbuf *m_head, u_int32_t *txidx)
{
	u_int32_t		frag, cur;
	struct ti_txmap_entry	*entry;
	bus_dmamap_t		txmap;
	struct ti_tx_desc	txdesc;
	int			i = 0;

	entry = SLIST_FIRST(&sc->ti_tx_map_listhead);
	if (entry == NULL)
		return (ENOBUFS);
	txmap = entry->dmamap;

	cur = frag = *txidx;

	/*
 	 * Start packing the mbufs in this chain into
	 * the fragment pointers. Stop when we run out
 	 * of fragments or hit the end of the mbuf chain.
	 */
	if (bus_dmamap_load_mbuf(sc->sc_dmatag, txmap, m_head,
	    BUS_DMA_NOWAIT))
		return (ENOBUFS);

	/*
	 * Sanity check: avoid coming within 16 descriptors
	 * of the end of the ring.
	 */
	if (txmap->dm_nsegs > (TI_TX_RING_CNT - sc->ti_txcnt - 16))
		goto fail_unload;

	for (i = 0; i < txmap->dm_nsegs; i++) {
		if (sc->ti_cdata.ti_tx_chain[frag] != NULL)
			break;

		memset(&txdesc, 0, sizeof(txdesc));

		TI_HOSTADDR(txdesc.ti_addr) = txmap->dm_segs[i].ds_addr;
		txdesc.ti_len = txmap->dm_segs[i].ds_len & 0xffff;
		txdesc.ti_flags = 0;
		txdesc.ti_vlan_tag = 0;

#if NVLAN > 0
		if (m_head->m_flags & M_VLANTAG) {
			txdesc.ti_flags |= TI_BDFLAG_VLAN_TAG;
			txdesc.ti_vlan_tag = m_head->m_pkthdr.ether_vtag;
		}
#endif

		ti_mem_write(sc, TI_TX_RING_BASE + frag * sizeof(txdesc),
			     sizeof(txdesc), (caddr_t)&txdesc);

		cur = frag;
		TI_INC(frag, TI_TX_RING_CNT);
	}

	if (frag == sc->ti_tx_saved_considx)
		goto fail_unload;

	txdesc.ti_flags |= TI_BDFLAG_END;
	ti_mem_write(sc, TI_TX_RING_BASE + cur * sizeof(txdesc),
		     sizeof(txdesc), (caddr_t)&txdesc);

	bus_dmamap_sync(sc->sc_dmatag, txmap, 0, txmap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	sc->ti_cdata.ti_tx_chain[cur] = m_head;
	SLIST_REMOVE_HEAD(&sc->ti_tx_map_listhead, link);
	sc->ti_cdata.ti_tx_map[cur] = entry;
	sc->ti_txcnt += txmap->dm_nsegs;

	*txidx = frag;

	return (0);

fail_unload:
	bus_dmamap_unload(sc->sc_dmatag, txmap);

	return (ENOBUFS);
}

/*
 * Encapsulate an mbuf chain in the tx ring by coupling the mbuf data
 * pointers to descriptors.
 */
int
ti_encap_tigon2(struct ti_softc *sc, struct mbuf *m_head, u_int32_t *txidx)
{
	struct ti_tx_desc	*f = NULL;
	u_int32_t		frag, cur;
	struct ti_txmap_entry	*entry;
	bus_dmamap_t		txmap;
	int			i = 0;

	entry = SLIST_FIRST(&sc->ti_tx_map_listhead);
	if (entry == NULL)
		return (ENOBUFS);
	txmap = entry->dmamap;

	cur = frag = *txidx;

	/*
 	 * Start packing the mbufs in this chain into
	 * the fragment pointers. Stop when we run out
 	 * of fragments or hit the end of the mbuf chain.
	 */
	if (bus_dmamap_load_mbuf(sc->sc_dmatag, txmap, m_head,
	    BUS_DMA_NOWAIT))
		return (ENOBUFS);

	/*
	 * Sanity check: avoid coming within 16 descriptors
	 * of the end of the ring.
	 */
	if (txmap->dm_nsegs > (TI_TX_RING_CNT - sc->ti_txcnt - 16))
		goto fail_unload;

	for (i = 0; i < txmap->dm_nsegs; i++) {
		f = &sc->ti_rdata->ti_tx_ring[frag];

		if (sc->ti_cdata.ti_tx_chain[frag] != NULL)
			break;

		TI_HOSTADDR(f->ti_addr) = txmap->dm_segs[i].ds_addr;
		f->ti_len = txmap->dm_segs[i].ds_len & 0xffff;
		f->ti_flags = 0;
		f->ti_vlan_tag = 0;

#if NVLAN > 0
		if (m_head->m_flags & M_VLANTAG) {
			f->ti_flags |= TI_BDFLAG_VLAN_TAG;
			f->ti_vlan_tag = m_head->m_pkthdr.ether_vtag;
		}
#endif

		cur = frag;
		TI_INC(frag, TI_TX_RING_CNT);
	}

	if (frag == sc->ti_tx_saved_considx)
		goto fail_unload;

	sc->ti_rdata->ti_tx_ring[cur].ti_flags |= TI_BDFLAG_END;

	bus_dmamap_sync(sc->sc_dmatag, txmap, 0, txmap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	TI_RING_DMASYNC(sc, ti_tx_ring[cur], BUS_DMASYNC_POSTREAD);

	sc->ti_cdata.ti_tx_chain[cur] = m_head;
	SLIST_REMOVE_HEAD(&sc->ti_tx_map_listhead, link);
	sc->ti_cdata.ti_tx_map[cur] = entry;
	sc->ti_txcnt += txmap->dm_nsegs;

	*txidx = frag;

	return (0);

fail_unload:
	bus_dmamap_unload(sc->sc_dmatag, txmap);

	return (ENOBUFS);
}

/*
 * Main transmit routine. To avoid having to do mbuf copies, we put pointers
 * to the mbuf data regions directly in the transmit descriptors.
 */
void
ti_start(struct ifnet *ifp)
{
	struct ti_softc		*sc;
	struct mbuf		*m_head = NULL;
	u_int32_t		prodidx;
	int			pkts = 0, error;

	sc = ifp->if_softc;

	prodidx = sc->ti_tx_saved_prodidx;

	while(sc->ti_cdata.ti_tx_chain[prodidx] == NULL) {
		IFQ_POLL(&ifp->if_snd, m_head);
		if (m_head == NULL)
			break;

		/*
		 * Pack the data into the transmit ring. If we
		 * don't have room, set the OACTIVE flag and wait
		 * for the NIC to drain the ring.
		 */
		if (sc->ti_hwrev == TI_HWREV_TIGON)
			error = ti_encap_tigon1(sc, m_head, &prodidx);
		else
			error = ti_encap_tigon2(sc, m_head, &prodidx);

		if (error) {
			ifp->if_flags |= IFF_OACTIVE;
			break;
		}

		/* now we are committed to transmit the packet */
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
		pkts++;

		/*
		 * If there's a BPF listener, bounce a copy of this frame
		 * to him.
		 */
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif
	}
	if (pkts == 0)
		return;

	/* Transmit */
	sc->ti_tx_saved_prodidx = prodidx;
	CSR_WRITE_4(sc, TI_MB_SENDPROD_IDX, prodidx);

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;
}

void
ti_init(void *xsc)
{
	struct ti_softc		*sc = xsc;
        int			s;

	s = splnet();

	/* Cancel pending I/O and flush buffers. */
	ti_stop(sc);

	/* Init the gen info block, ring control blocks and firmware. */
	if (ti_gibinit(sc)) {
		printf("%s: initialization failure\n", sc->sc_dv.dv_xname);
		splx(s);
		return;
	}

	splx(s);
}

void
ti_init2(struct ti_softc *sc)
{
	struct ti_cmd_desc	cmd;
	struct ifnet		*ifp;
	u_int16_t		*m;
	struct ifmedia		*ifm;
	int			tmp;

	ifp = &sc->arpcom.ac_if;

	/* Specify MTU and interface index. */
	CSR_WRITE_4(sc, TI_GCR_IFINDEX, sc->sc_dv.dv_unit);
	CSR_WRITE_4(sc, TI_GCR_IFMTU,
		TI_JUMBO_FRAMELEN + ETHER_VLAN_ENCAP_LEN);
	TI_DO_CMD(TI_CMD_UPDATE_GENCOM, 0, 0);

	/* Load our MAC address. */
	m = (u_int16_t *)&sc->arpcom.ac_enaddr[0];
	CSR_WRITE_4(sc, TI_GCR_PAR0, htons(m[0]));
	CSR_WRITE_4(sc, TI_GCR_PAR1, (htons(m[1]) << 16) | htons(m[2]));
	TI_DO_CMD(TI_CMD_SET_MAC_ADDR, 0, 0);

	/* Enable or disable promiscuous mode as needed. */
	if (ifp->if_flags & IFF_PROMISC) {
		TI_DO_CMD(TI_CMD_SET_PROMISC_MODE, TI_CMD_CODE_PROMISC_ENB, 0);
	} else {
		TI_DO_CMD(TI_CMD_SET_PROMISC_MODE, TI_CMD_CODE_PROMISC_DIS, 0);
	}

	/* Program multicast filter. */
	ti_setmulti(sc);

	/*
	 * If this is a Tigon 1, we should tell the
	 * firmware to use software packet filtering.
	 */
	if (sc->ti_hwrev == TI_HWREV_TIGON) {
		TI_DO_CMD(TI_CMD_FDR_FILTERING, TI_CMD_CODE_FILT_ENB, 0);
	}

	/* Init RX ring. */
	if (ti_init_rx_ring_std(sc) == ENOBUFS)
		panic("not enough mbufs for rx ring");

	/* Init jumbo RX ring. */
	ti_init_rx_ring_jumbo(sc);

	/*
	 * If this is a Tigon 2, we can also configure the
	 * mini ring.
	 */
	if (sc->ti_hwrev == TI_HWREV_TIGON_II)
		ti_init_rx_ring_mini(sc);

	CSR_WRITE_4(sc, TI_GCR_RXRETURNCONS_IDX, 0);
	sc->ti_rx_saved_considx = 0;

	/* Init TX ring. */
	ti_init_tx_ring(sc);

	/* Tell firmware we're alive. */
	TI_DO_CMD(TI_CMD_HOST_STATE, TI_CMD_CODE_STACK_UP, 0);

	/* Enable host interrupts. */
	CSR_WRITE_4(sc, TI_MB_HOSTINTR, 0);

	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;

	/*
	 * Make sure to set media properly. We have to do this
	 * here since we have to issue commands in order to set
	 * the link negotiation and we can't issue commands until
	 * the firmware is running.
	 */
	ifm = &sc->ifmedia;
	tmp = ifm->ifm_media;
	ifm->ifm_media = ifm->ifm_cur->ifm_media;
	ti_ifmedia_upd(ifp);
	ifm->ifm_media = tmp;
}

/*
 * Set media options.
 */
int
ti_ifmedia_upd(struct ifnet *ifp)
{
	struct ti_softc		*sc;
	struct ifmedia		*ifm;
	struct ti_cmd_desc	cmd;

	sc = ifp->if_softc;
	ifm = &sc->ifmedia;

	if (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)
		return(EINVAL);

	switch(IFM_SUBTYPE(ifm->ifm_media)) {
	case IFM_AUTO:
		CSR_WRITE_4(sc, TI_GCR_GLINK, TI_GLNK_PREF|TI_GLNK_1000MB|
		    TI_GLNK_FULL_DUPLEX|TI_GLNK_RX_FLOWCTL_Y|
		    TI_GLNK_AUTONEGENB|TI_GLNK_ENB);
		CSR_WRITE_4(sc, TI_GCR_LINK, TI_LNK_100MB|TI_LNK_10MB|
		    TI_LNK_FULL_DUPLEX|TI_LNK_HALF_DUPLEX|
		    TI_LNK_AUTONEGENB|TI_LNK_ENB);
		TI_DO_CMD(TI_CMD_LINK_NEGOTIATION,
		    TI_CMD_CODE_NEGOTIATE_BOTH, 0);
		break;
	case IFM_1000_SX:
	case IFM_1000_T:
		CSR_WRITE_4(sc, TI_GCR_GLINK, TI_GLNK_PREF|TI_GLNK_1000MB|
		    TI_GLNK_RX_FLOWCTL_Y|TI_GLNK_ENB);
		CSR_WRITE_4(sc, TI_GCR_LINK, 0);
		if ((ifm->ifm_media & IFM_GMASK) == IFM_FDX) {
			TI_SETBIT(sc, TI_GCR_GLINK, TI_GLNK_FULL_DUPLEX);
		}
		TI_DO_CMD(TI_CMD_LINK_NEGOTIATION,
		    TI_CMD_CODE_NEGOTIATE_GIGABIT, 0);
		break;
	case IFM_100_FX:
	case IFM_10_FL:
	case IFM_100_TX:
	case IFM_10_T:
		CSR_WRITE_4(sc, TI_GCR_GLINK, 0);
		CSR_WRITE_4(sc, TI_GCR_LINK, TI_LNK_ENB|TI_LNK_PREF);
		if (IFM_SUBTYPE(ifm->ifm_media) == IFM_100_FX ||
		    IFM_SUBTYPE(ifm->ifm_media) == IFM_100_TX) {
			TI_SETBIT(sc, TI_GCR_LINK, TI_LNK_100MB);
		} else {
			TI_SETBIT(sc, TI_GCR_LINK, TI_LNK_10MB);
		}
		if ((ifm->ifm_media & IFM_GMASK) == IFM_FDX) {
			TI_SETBIT(sc, TI_GCR_LINK, TI_LNK_FULL_DUPLEX);
		} else {
			TI_SETBIT(sc, TI_GCR_LINK, TI_LNK_HALF_DUPLEX);
		}
		TI_DO_CMD(TI_CMD_LINK_NEGOTIATION,
		    TI_CMD_CODE_NEGOTIATE_10_100, 0);
		break;
	}

	return (0);
}

/*
 * Report current media status.
 */
void
ti_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct ti_softc		*sc;
	u_int32_t		media = 0;

	sc = ifp->if_softc;

	ifmr->ifm_status = IFM_AVALID;
	ifmr->ifm_active = IFM_ETHER;

	if (sc->ti_linkstat == TI_EV_CODE_LINK_DOWN) {
		ifmr->ifm_active |= IFM_NONE;
		return;
	}

	ifmr->ifm_status |= IFM_ACTIVE;

	if (sc->ti_linkstat == TI_EV_CODE_GIG_LINK_UP) {
		media = CSR_READ_4(sc, TI_GCR_GLINK_STAT);
		if (sc->ti_copper)
			ifmr->ifm_active |= IFM_1000_T;
		else
			ifmr->ifm_active |= IFM_1000_SX;
		if (media & TI_GLNK_FULL_DUPLEX)
			ifmr->ifm_active |= IFM_FDX;
		else
			ifmr->ifm_active |= IFM_HDX;
	} else if (sc->ti_linkstat == TI_EV_CODE_LINK_UP) {
		media = CSR_READ_4(sc, TI_GCR_LINK_STAT);
		if (sc->ti_copper) {
			if (media & TI_LNK_100MB)
				ifmr->ifm_active |= IFM_100_TX;
			if (media & TI_LNK_10MB)
				ifmr->ifm_active |= IFM_10_T;
		} else {
			if (media & TI_LNK_100MB)
				ifmr->ifm_active |= IFM_100_FX;
			if (media & TI_LNK_10MB)
				ifmr->ifm_active |= IFM_10_FL;
		}
		if (media & TI_LNK_FULL_DUPLEX)
			ifmr->ifm_active |= IFM_FDX;
		if (media & TI_LNK_HALF_DUPLEX)
			ifmr->ifm_active |= IFM_HDX;
	}
}

int
ti_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct ti_softc		*sc = ifp->if_softc;
	struct ifaddr		*ifa = (struct ifaddr *)data;
	struct ifreq		*ifr = (struct ifreq *)data;
	int			s, error = 0;
	struct ti_cmd_desc	cmd;

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if ((ifp->if_flags & IFF_RUNNING) == 0)
			ti_init(sc);
#ifdef INET
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->arpcom, ifa);
#endif /* INET */
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			/*
			 * If only the state of the PROMISC flag changed,
			 * then just use the 'set promisc mode' command
			 * instead of reinitializing the entire NIC. Doing
			 * a full re-init means reloading the firmware and
			 * waiting for it to start up, which may take a
			 * second or two.
			 */
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->ti_if_flags & IFF_PROMISC)) {
				TI_DO_CMD(TI_CMD_SET_PROMISC_MODE,
				    TI_CMD_CODE_PROMISC_ENB, 0);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->ti_if_flags & IFF_PROMISC) {
				TI_DO_CMD(TI_CMD_SET_PROMISC_MODE,
				    TI_CMD_CODE_PROMISC_DIS, 0);
			} else {
				if ((ifp->if_flags & IFF_RUNNING) == 0)
					ti_init(sc);
			}
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				ti_stop(sc);
		}
		sc->ti_if_flags = ifp->if_flags;
		break;

	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->ifmedia, command);
		break;

	default:
		error = ether_ioctl(ifp, &sc->arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			ti_setmulti(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

void
ti_watchdog(struct ifnet *ifp)
{
	struct ti_softc		*sc;

	sc = ifp->if_softc;

	printf("%s: watchdog timeout -- resetting\n", sc->sc_dv.dv_xname);
	ti_stop(sc);
	ti_init(sc);

	ifp->if_oerrors++;
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void
ti_stop(struct ti_softc *sc)
{
	struct ifnet		*ifp;
	struct ti_cmd_desc	cmd;

	ifp = &sc->arpcom.ac_if;

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);

	/* Disable host interrupts. */
	CSR_WRITE_4(sc, TI_MB_HOSTINTR, 1);
	/*
	 * Tell firmware we're shutting down.
	 */
	TI_DO_CMD(TI_CMD_HOST_STATE, TI_CMD_CODE_STACK_DOWN, 0);

	/* Halt and reinitialize. */
	ti_chipinit(sc);
	ti_mem_set(sc, 0x2000, 0x100000 - 0x2000);
	ti_chipinit(sc);

	/* Free the RX lists. */
	ti_free_rx_ring_std(sc);

	/* Free jumbo RX list. */
	ti_free_rx_ring_jumbo(sc);

	/* Free mini RX list. */
	ti_free_rx_ring_mini(sc);

	/* Free TX buffers. */
	ti_free_tx_ring(sc);

	sc->ti_ev_prodidx.ti_idx = 0;
	sc->ti_return_prodidx.ti_idx = 0;
	sc->ti_tx_considx.ti_idx = 0;
	sc->ti_tx_saved_considx = TI_TXCONS_UNSET;
}

/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
void
ti_shutdown(void *xsc)
{
	struct ti_softc		*sc;

	sc = xsc;

	ti_chipinit(sc);
}
@


1.98
log
@- consistify cfdriver for the ethernet drivers (0 -> NULL)

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.97 2009/08/11 23:58:35 martynas Exp $	*/
@


1.97
log
@don't take chip revision as a pointer to the string;  swap it with xname
ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.96 2009/08/08 15:58:14 naddy Exp $	*/
d125 1
a125 1
	0, "ti", DV_IFNET
@


1.96
log
@bring comments in line with reality; from Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.95 2009/07/28 07:20:28 claudio Exp $	*/
d1297 1
a1297 1
		    chip_rev, sc->sc_dv.dv_xname);
@


1.95
log
@The firmware is an array of u_int32_t and differs between architectures.
From now on install the tigon firmware in little endian byte order and swap
it acordingly in the driver. Correctly calculate the length of the FW in the
build tool -- now my fiber cards no longer have issues to establish link on
bootup. Please put this in deraadt@@

On big endian archs (sparc64, macppc) the firmware file needs to be updated.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.94 2008/11/28 02:44:18 brad Exp $	*/
d38 1
a38 3
 * Alteon Networks Tigon PCI gigabit ethernet driver for FreeBSD.
 * Manuals, sample driver and firmware source kits are available
 * from http://www.alteon.com/support/openkits.
a62 7
 *
 * The firmware for the Tigon 1 and 2 NICs is compiled directly into
 * this driver by #including it as a C header file. This bloats the
 * driver somewhat, but it's the easiest method considering that the
 * driver code and firmware code need to be kept in sync. The source
 * for the firmware is not provided with the FreeBSD distribution since
 * compiling it requires a GNU toolchain targeted for mips-sgi-irix5.3.
@


1.94
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.93 2008/11/09 15:08:26 naddy Exp $	*/
d430 2
a431 1
	size_t buflen;
d451 6
@


1.93
log
@Introduce bpf_mtap_ether(), which for the benefit of bpf listeners
creates the VLAN encapsulation from the tag stored in the mbuf
header.  Idea from FreeBSD, input from claudio@@ and canacar@@.

Switch all hardware VLAN enabled drivers to the new function.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.92 2008/10/20 01:02:52 brad Exp $	*/
d2488 1
a2489 1
	struct ifaddr		*ifa = (struct ifaddr *)data;
d2505 1
a2505 6
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ifp->if_hardmtu)
			error = EINVAL;
		else if (ifp->if_mtu != ifr->ifr_mtu)
			ifp->if_mtu = ifr->ifr_mtu;
		break;
a2535 5
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);
a2536 6
		if (error == ENETRESET) {
			if (ifp->if_flags & IFF_RUNNING)
				ti_setmulti(sc);
			error = 0;
		}
		break;
d2541 1
d2544 6
@


1.92
log
@- Remove tmp variable sumflags in ti_rxeof() and just stick the csum
  Ok flag into the header field, like every other driver.
- Move the sanity checks in the packet encapsulation routines up above
  the for loop since the number of DMA segments is already known and
  there is no need to count the iterations through the loop.
- If the encapsulation routine fails after calling bus_dmamap_load_mbuf()
  then make sure to unload the DMA map.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.91 2008/10/19 21:38:01 brad Exp $	*/
d1865 1
a1865 1
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
d2250 1
a2250 1
			bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
@


1.91
log
@Re-add support for RX VLAN tag stripping.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.90 2008/10/16 19:18:03 naddy Exp $	*/
a1781 1
		u_int16_t		sumflags = 0;
d1869 1
a1869 2
			sumflags |= M_IPV4_CSUM_IN_OK;
		m->m_pkthdr.csum_flags = sumflags;
d2042 1
a2042 1
	u_int32_t		frag, cur, cnt = 0;
d2064 7
a2091 7
		/*
		 * Sanity check: avoid coming within 16 descriptors
		 * of the end of the ring.
		 */
		if ((TI_TX_RING_CNT - (sc->ti_txcnt + cnt)) < 16)
			return (ENOBUFS);

a2093 1
		cnt++;
d2097 1
a2097 1
		return (ENOBUFS);
d2109 1
a2109 1
	sc->ti_txcnt += cnt;
d2114 5
d2129 1
a2129 1
	u_int32_t		frag, cur, cnt = 0;
d2150 7
a2174 7
		/*
		 * Sanity check: avoid coming within 16 descriptors
		 * of the end of the ring.
		 */
		if ((TI_TX_RING_CNT - (sc->ti_txcnt + cnt)) < 16)
			return(ENOBUFS);

a2176 1
		cnt++;
d2180 1
a2180 1
		return(ENOBUFS);
d2192 1
a2192 1
	sc->ti_txcnt += cnt;
d2197 5
@


1.90
log
@Switch the existing TX VLAN hardware support over to having the
tag in the header.  Convert TX tagging in the drivers.

Help and ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.89 2008/10/14 18:01:53 naddy Exp $	*/
d1449 4
d1460 4
d1478 4
d1854 7
d2074 2
a2076 1
		txdesc.ti_flags = 0;
d2093 1
d2157 2
a2162 2
		} else {
			f->ti_vlan_tag = 0;
d2165 1
d2172 1
@


1.89
log
@Change m_devget()'s outdated and unused "offset" argument:  It is
now the offset into the first mbuf of the target chain before copying
the source data over.  From FreeBSD.

Convert drivers' use of m_devget().  Mostly from thib@@.

Update mbuf(9) man page.

ok claudio@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.88 2008/10/02 20:21:14 brad Exp $	*/
a2029 7
#if NVLAN > 0
	struct ifvlan		*ifv = NULL;

	if ((m_head->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&
	    m_head->m_pkthdr.rcvif != NULL)
		ifv = m_head->m_pkthdr.rcvif->if_softc;
#endif
d2058 1
a2058 1
		if (ifv != NULL) {
d2060 1
a2060 1
			txdesc.ti_vlan_tag = ifv->ifv_tag;
a2109 7
#if NVLAN > 0
	struct ifvlan		*ifv = NULL;

	if ((m_head->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&
	    m_head->m_pkthdr.rcvif != NULL)
		ifv = m_head->m_pkthdr.rcvif->if_softc;
#endif
d2137 1
a2137 1
		if (ifv != NULL) {
d2139 1
a2139 1
			f->ti_vlan_tag = ifv->ifv_tag;
@


1.88
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.87 2008/09/24 19:12:59 chl Exp $	*/
d1790 2
a1791 2
				m0 = m_devget(mtod(m, char *) - ETHER_ALIGN,
				    cur_rx->ti_len + ETHER_ALIGN, 0, ifp, NULL);
a1796 1
				m_adj(m0, ETHER_ALIGN);
@


1.87
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok henning@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.86 2008/09/18 15:16:30 naddy Exp $	*/
a2480 5
	if ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {
		splx(s);
		return (error);
	}

d2544 1
a2544 2
		error = ENOTTY;
		break;
@


1.86
log
@Introduce the infrastructure required to support hardware VLAN tag
stripping:  Add a field to the mbuf pkthdr to hold the tag and an
mbuf flag that tells if the tag is valid.  Inspired by FreeBSD.

Struct packing suggested by kettenis@@.   csum_flags is now 16 bits.
Adapt to this in the drivers.

ok reyk@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.85 2008/06/07 19:03:13 brad Exp $	*/
a1853 1
		sumflags = 0;
@


1.85
log
@Add link state/baudrate handling.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.84 2006/11/20 22:49:32 brad Exp $	*/
d1770 1
a1770 1
		int			sumflags = 0;
@


1.84
log
@Re-enable HW VLAN tagging.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.83 2006/05/28 00:20:21 brad Exp $	*/
d519 1
d529 29
@


1.83
log
@- remove ETHER_MAX_LEN_JUMBO and ETHERMTU_JUMBO.
- use if_hardmtu for MTU ioctl handlers.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.82 2006/05/28 00:04:24 jason Exp $	*/
a1657 1
#if TI_VLAN
a1659 1
#endif
@


1.82
log
@unknown ioctl is ENOTTY not EINVAL
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.81 2006/05/27 10:03:15 brad Exp $	*/
d884 2
a885 2
		m_new->m_len = m_new->m_pkthdr.len = ETHER_MAX_LEN_JUMBO;
		MEXTADD(m_new, buf, ETHER_MAX_LEN_JUMBO, 0, ti_jfree, sc);
d894 1
a894 1
		m_new->m_ext.ext_size = ETHER_MAX_LEN_JUMBO;
d1059 1
a1059 1
		if (bus_dmamap_create(sc->sc_dmatag, ETHER_MAX_LEN_JUMBO,
d1423 1
a1423 1
	rcb->ti_max_len = ETHER_MAX_LEN_JUMBO;
d1651 1
a1651 1
	ifp->if_hardmtu = ETHERMTU_JUMBO;
d2260 1
a2260 1
		ETHER_MAX_LEN_JUMBO + ETHER_VLAN_ENCAP_LEN);
d2470 1
a2470 1
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ETHERMTU_JUMBO)
@


1.81
log
@remove IFCAP_JUMBO_MTU interface capabilities flag and set if_hardmtu in a few
more drivers.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.80 2006/05/20 03:47:56 brad Exp $	*/
d2522 1
a2522 1
		error = EINVAL;
@


1.80
log
@set if_jumbo_mtu and the IFCAP_JUMBO_MTU capabilities flag where
appropriate.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.79 2006/03/25 22:41:45 djm Exp $	*/
d1651 1
d1656 1
a1656 1
	ifp->if_capabilities = IFCAP_VLAN_MTU | IFCAP_JUMBO_MTU;
@


1.79
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.78 2006/03/16 02:32:37 brad Exp $	*/
d1655 1
a1655 1
	ifp->if_capabilities = IFCAP_VLAN_MTU;
@


1.78
log
@if the link is down then show a media status of none.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.77 2006/03/16 02:23:53 brad Exp $	*/
d1819 1
a1819 1
			bpf_mtap(ifp->if_bpf, m);
d2208 1
a2208 1
			bpf_mtap(ifp->if_bpf, m_head);
@


1.77
log
@tidy up a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.76 2006/02/16 20:45:37 brad Exp $	*/
d2405 2
a2406 1
	if (sc->ti_linkstat == TI_EV_CODE_LINK_DOWN)
d2408 1
@


1.76
log
@Only set HW VLAN assist flag when IFCAP_VLAN_HWTAGGING is set.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.75 2006/02/16 20:16:30 brad Exp $	*/
d198 1
a198 1
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_PN9000SX },
d218 1
a218 1
		if (byte & i) {
d220 1
a220 1
		} else {
a221 1
		}
a1243 4
#if 0 && BYTE_ORDER == BIG_ENDIAN
	CSR_WRITE_4(sc, TI_MISC_HOST_CTL,
	    TI_MHC_BIGENDIAN_INIT | (TI_MHC_BIGENDIAN_INIT << 24));
#else
a1245 1
#endif
d1282 1
a1282 1
	if (sc->ti_hwrev == TI_HWREV_TIGON_II) {
a1283 1
	}
d1332 1
a1332 3
#if BYTE_ORDER == BIG_ENDIAN
	CSR_WRITE_4(sc, TI_GCR_OPMODE, TI_OPMODE_BYTESWAP_BD |
	    TI_OPMODE_BYTESWAP_DATA | TI_OPMODE_WORDSWAP_BD |
a1334 5
#else
	CSR_WRITE_4(sc, TI_GCR_OPMODE, TI_OPMODE_BYTESWAP_DATA|
	    TI_OPMODE_WORDSWAP_BD|TI_OPMODE_DONT_FRAG_JUMBO|
	    TI_OPMODE_WARN_ENB|TI_OPMODE_FATAL_ENB);
#endif
d2459 2
a2460 1
		switch (ifa->ifa_addr->sa_family) {
d2462 1
a2462 2
		case AF_INET:
			ti_init(sc);
a2463 1
			break;
a2464 4
		default:
			ti_init(sc);
			break;
		}
d2492 4
a2495 2
			} else
				ti_init(sc);
d2497 1
a2497 1
			if (ifp->if_flags & IFF_RUNNING) {
a2498 1
			}
@


1.75
log
@disable HW VLAN tagging.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.74 2006/01/16 01:47:39 brad Exp $	*/
d1484 2
a1485 1
	rcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;
@


1.74
log
@Cache the TX producer index instead of reading it every time ti_start is
called.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.73 2005/10/10 20:54:23 brad Exp $	*/
d1670 1
d1673 1
@


1.73
log
@- remove a unused piece of code from ti_chipinit().
- add comment from the FreeBSD driver to ti_gibinit()
  explaining where the general information blocking
  is being placed by the driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.72 2005/10/09 05:38:00 brad Exp $	*/
d1055 1
d2182 1
a2182 1
	u_int32_t		prodidx = 0;
d2187 1
a2187 1
	prodidx = CSR_READ_4(sc, TI_MB_SENDPROD_IDX);
d2226 1
@


1.72
log
@some code cleaning..
- function return value on separate line
- ANSI protos
- remove return at end of void function
- splimp -> splnet
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.71 2005/07/30 04:25:00 brad Exp $	*/
a1348 10
	/*
	 * Only allow 1 DMA channel to be active at a time.
	 * I don't think this is a good idea, but without it
	 * the firmware racks up lots of nicDmaReadRingFull
	 * errors.  This is not compatible with hardware checksums.
	 */
#if 0
	TI_SETBIT(sc, TI_GCR_OPMODE, TI_OPMODE_1_DMA_ACTIVE);
#endif

d1378 6
a1383 4
	/* Tell the chip where to find the general information block. */
#ifdef __64_bit_pci_addressing__ 
	CSR_WRITE_4(sc, TI_GCR_GENINFO_HI, TI_RING_DMA_ADDR(sc, ti_info)>>32);
#else
a1384 1
#endif
a1751 3
#ifdef TI_CSUM_OFFLOAD
		struct ip		*ip;
#endif
@


1.71
log
@sync nge/ti_alloc_jumbo_mem() to look like bge's bge_alloc_jumbo_mem()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.70 2005/07/25 00:49:43 brad Exp $	*/
d126 2
a127 3
#ifdef M_HWCKSUM
/*#define TI_CSUM_OFFLOAD*/
#endif
d129 3
a131 1
#define bootverbose	1
d133 3
a135 2
int ti_probe(struct device *, void *, void *);
void ti_attach(struct device *, struct device *, void *);
d191 10
d204 2
a205 3
u_int32_t ti_eeprom_putbyte(sc, byte)
	struct ti_softc		*sc;
	int			byte;
d241 1
a241 1
	return(ack);
d249 2
a250 4
u_int8_t ti_eeprom_getbyte(sc, addr, dest)
	struct ti_softc		*sc;
	int			addr;
	u_int8_t		*dest;
d263 1
a263 1
		return(1);
d272 1
a272 1
		return(1);
d280 1
a280 1
		return(1);
d291 1
a291 1
		return(1);
d315 1
a315 1
	return(0);
d321 2
a322 5
int ti_read_eeprom(sc, dest, off, cnt)
	struct ti_softc		*sc;
	caddr_t			dest;
	int			off;
	int			cnt;
d334 1
a334 1
	return(err ? 1 : 0);
d341 2
a342 4
void ti_mem_read(sc, addr, len, buf)
	struct ti_softc		*sc;
	u_int32_t		addr, len;
	void			*buf;
d370 3
a372 4
void ti_mem_write(sc, addr, len, buf)
	struct ti_softc		*sc;
	u_int32_t		addr, len;
	const void		*buf;
d400 2
a401 3
void ti_mem_set(sc, addr, len)
	struct ti_softc		*sc;
	u_int32_t		addr, len;
d426 2
a427 2
void ti_loadfw(sc)
	struct ti_softc		*sc;
d478 2
a479 3
void ti_cmd(sc, cmd)
	struct ti_softc		*sc;
	struct ti_cmd_desc	*cmd;
a487 2

	return;
d494 3
a496 5
void ti_cmd_ext(sc, cmd, arg, len)
	struct ti_softc		*sc;
	struct ti_cmd_desc	*cmd;
	caddr_t			arg;
	int			len;
a510 2

	return;
d516 2
a517 2
void ti_handle_events(sc)
	struct ti_softc		*sc;
a559 2

	return;
d585 2
a586 2
int ti_alloc_jumbo_mem(sc)
	struct ti_softc		*sc;
d672 1
a672 1
 
d679 2
a680 2
void *ti_jalloc(sc)
	struct ti_softc		*sc;
d692 1
a692 1
	return(sc->ti_cdata.ti_jslots[entry->slot].ti_buf);
d699 1
a699 4
ti_jfree(buf, size, arg)
	caddr_t			buf;
	u_int			size;
	void *arg;
d734 3
a736 5
int ti_newbuf_std(sc, i, m, dmamap)
	struct ti_softc		*sc;
	int			i;
	struct mbuf		*m;
	bus_dmamap_t		dmamap;
d748 1
a748 1
			return(ENOMEM);
d758 1
a758 1
			return(ENOBUFS);
d763 1
a763 1
			return(ENOBUFS);
d771 1
a771 1
			return(ENOBUFS);
d774 5
d796 1
a796 1
	    panic("overwritten!!!");
d798 1
a798 1
	return(0);
d805 3
a807 5
int ti_newbuf_mini(sc, i, m, dmamap)
	struct ti_softc		*sc;
	int			i;
	struct mbuf		*m;
	bus_dmamap_t		dmamap;
d819 1
a819 1
			return(ENOMEM);
d829 1
a829 1
			return(ENOBUFS);
d835 1
a835 1
		return(ENOBUFS);
d838 5
d856 1
a856 1
	return(0);
d863 2
a864 4
int ti_newbuf_jumbo(sc, i, m)
	struct ti_softc		*sc;
	int			i;
	struct mbuf		*m;
d875 1
a875 1
			return(ENOBUFS);
d881 1
a881 1
			return(ENOBUFS);
d888 5
d908 1
a908 1
	return(0);
d917 2
a918 2
int ti_init_rx_ring_std(sc)
	struct ti_softc		*sc;
d925 1
a925 1
			return(ENOBUFS);
d931 1
a931 1
	return(0);
d934 2
a935 2
void ti_free_rx_ring_std(sc)
	struct ti_softc		*sc;
a949 2

	return;
d952 2
a953 2
int ti_init_rx_ring_jumbo(sc)
	struct ti_softc		*sc;
d960 1
a960 1
			return(ENOBUFS);
d966 1
a966 1
	return(0);
d969 2
a970 2
void ti_free_rx_ring_jumbo(sc)
	struct ti_softc		*sc;
a981 2

	return;
d984 2
a985 2
int ti_init_rx_ring_mini(sc)
	struct ti_softc		*sc;
d991 1
a991 1
			return(ENOBUFS);
d997 1
a997 1
	return(0);
d1000 2
a1001 2
void ti_free_rx_ring_mini(sc)
	struct ti_softc		*sc;
a1015 2

	return;
d1018 2
a1019 2
void ti_free_tx_ring(sc)
	struct ti_softc		*sc;
a1043 2

	return;
d1046 2
a1047 2
int ti_init_tx_ring(sc)
	struct ti_softc		*sc;
d1060 2
a1061 2
		    TI_NTXSEG, ETHER_MAX_LEN_JUMBO, 0, BUS_DMA_NOWAIT, &dmamap))
			return(ENOBUFS);
d1072 1
a1072 1
	return(0);
d1080 2
a1081 3
void ti_add_mcast(sc, addr)
	struct ti_softc		*sc;
	struct ether_addr	*addr;
a1103 2

	return;
d1106 2
a1107 3
void ti_del_mcast(sc, addr)
	struct ti_softc		*sc;
	struct ether_addr	*addr;
a1129 2

	return;
d1146 2
a1147 2
void ti_setmulti(sc)
	struct ti_softc		*sc;
a1199 2

	return;
d1208 2
a1209 2
int ti_64bitslot_war(sc)
	struct ti_softc		*sc;
d1217 1
a1217 1
				return(EINVAL);
d1221 1
a1221 1
				return(0);
d1226 1
a1226 1
	return(0);
d1233 2
a1234 2
int ti_chipinit(sc)
	struct ti_softc		*sc;
d1256 1
a1256 1
		return(ENODEV);
d1275 1
a1275 1
		return(ENODEV);
a1314 4
			if (bootverbose)
				printf("%s: cache line size %d not "
				    "supported; disabling PCI MWI\n",
				    sc->sc_dv.dv_xname, cacheline);
d1366 1
a1366 1
		return(EINVAL);
d1369 1
a1369 1
	return(0);
d1376 2
a1377 2
int ti_gibinit(sc)
	struct ti_softc		*sc;
d1520 1
a1520 1
	return(0);
a1522 10
const struct pci_matchid ti_devices[] = {
	{ PCI_VENDOR_NETGEAR, PCI_PRODUCT_NETGEAR_GA620 },
	{ PCI_VENDOR_NETGEAR, PCI_PRODUCT_NETGEAR_GA620T },
	{ PCI_VENDOR_ALTEON, PCI_PRODUCT_ALTEON_ACENIC },
	{ PCI_VENDOR_ALTEON, PCI_PRODUCT_ALTEON_ACENICT },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C985 },
	{ PCI_VENDOR_SGI, PCI_PRODUCT_SGI_TIGON },
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_PN9000SX },
};

d1528 1
a1528 4
ti_probe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
a1533 1

d1535 1
a1535 3
ti_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d1542 1
d1544 1
a1544 2
	int s, rseg;
	u_int32_t command;
a1547 2
	s = splimp();

a1550 4
	command = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_MEM_ENABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
	command = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
d1552 3
a1554 2
	if (pci_mapreg_map(pa, TI_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->ti_btag, &sc->ti_bhandle, NULL, NULL, 0)) {
d1556 1
a1556 1
		goto fail_1;
d1576 1
a1576 1
		goto fail;
d1585 1
a1585 1
		goto fail;
d1600 1
a1600 1
		goto fail;
d1606 1
a1606 1
	printf(": %s address %s\n", intrstr,
d1614 1
a1614 1
		goto fail;
d1620 1
a1620 2
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		goto fail;
d1626 1
a1626 4
		bus_dmamem_unmap(sc->sc_dmatag, kva,
		    sizeof(struct ti_ring_data));
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		goto fail;
d1630 1
a1630 5
		bus_dmamap_destroy(sc->sc_dmatag, sc->ti_ring_map);
		bus_dmamem_unmap(sc->sc_dmatag, kva,
		    sizeof(struct ti_ring_data));
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		goto fail;
d1639 1
a1639 1
		goto fail;
d1720 11
a1730 1
fail:
d1734 1
a1734 1
	splx(s);
d1748 2
a1749 2
void ti_rxeof(sc)
	struct ti_softc		*sc;
a1859 2

	return;
d1862 2
a1863 2
void ti_txeof_tigon1(sc)
	struct ti_softc		*sc;
a1908 2

	return;
d1911 2
a1912 2
void ti_txeof_tigon2(sc)
	struct ti_softc		*sc;
a1952 2

	return;
d1955 2
a1956 2
int ti_intr(xsc)
	void			*xsc;
d1994 2
a1995 2
void ti_stats_update(sc)
	struct ti_softc		*sc;
d2014 1
a2014 1
 * Encapsulate an mbuf chain in the tx ring  by coupling the mbuf data
d2017 2
a2018 4
int ti_encap_tigon1(sc, m_head, txidx)
	struct ti_softc		*sc;
	struct mbuf		*m_head;
	u_int32_t		*txidx;
d2035 1
a2035 1
		return ENOBUFS;
d2047 1
a2047 1
		return(ENOBUFS);
d2074 1
a2074 1
			return(ENOBUFS);
d2081 1
a2081 1
		return(ENOBUFS);
d2097 1
a2097 1
	return(0);
d2101 1
a2101 1
 * Encapsulate an mbuf chain in the tx ring  by coupling the mbuf data
d2104 2
a2105 4
int ti_encap_tigon2(sc, m_head, txidx)
	struct ti_softc		*sc;
	struct mbuf		*m_head;
	u_int32_t		*txidx;
d2122 1
a2122 1
		return ENOBUFS;
d2134 1
a2134 1
		return(ENOBUFS);
d2181 1
a2181 1
	return(0);
d2188 2
a2189 2
void ti_start(ifp)
	struct ifnet		*ifp;
a2242 2

	return;
d2245 2
a2246 2
void ti_init(xsc)
	void			*xsc;
d2251 1
a2251 1
	s = splimp();
a2263 2

	return;
d2266 2
a2267 2
void ti_init2(sc)
	struct ti_softc		*sc;
a2346 2

	return;
d2352 2
a2353 2
int ti_ifmedia_upd(ifp)
	struct ifnet		*ifp;
d2409 1
a2409 1
	return(0);
d2415 2
a2416 3
void ti_ifmedia_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
a2458 2

	return;
d2461 2
a2462 4
int ti_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
d2470 1
a2470 1
	s = splimp();
a2525 1
		error = 0;
d2549 1
a2549 2

	return(error);
d2552 2
a2553 2
void ti_watchdog(ifp)
	struct ifnet		*ifp;
a2563 2

	return;
d2570 2
a2571 2
void ti_stop(sc)
	struct ti_softc		*sc;
a2607 2

	return;
d2614 2
a2615 2
void ti_shutdown(xsc)
	void			*xsc;
a2621 2

	return;
a2622 8

struct cfattach ti_ca = {
	sizeof(struct ti_softc), ti_probe, ti_attach
};

struct cfdriver ti_cd = {
	0, "ti", DV_IFNET
};
@


1.70
log
@don't bother with printf in *_jalloc()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.69 2005/07/25 00:41:24 brad Exp $	*/
d597 1
a597 1
	int i, rseg;
d600 2
d608 2
d614 2
a615 2
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		return (ENOBUFS);
d617 2
d622 2
a623 3
		bus_dmamem_unmap(sc->sc_dmatag, kva, TI_JMEM);
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		return (ENOBUFS);
d625 2
d630 2
a631 5
		bus_dmamap_destroy(sc->sc_dmatag,
				   sc->ti_cdata.ti_rx_jumbo_map);
		bus_dmamem_unmap(sc->sc_dmatag, kva, TI_JMEM);
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		return (ENOBUFS);
d633 2
a651 6
			bus_dmamap_unload(sc->sc_dmatag,
					  sc->ti_cdata.ti_rx_jumbo_map);
			bus_dmamap_destroy(sc->sc_dmatag,
					   sc->ti_cdata.ti_rx_jumbo_map);
			bus_dmamem_unmap(sc->sc_dmatag, kva, TI_JMEM);
			bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
d655 2
a656 1
			return(ENOBUFS);
d661 20
a680 2

	return(0);
@


1.69
log
@- mbuf external storage is of (caddr_t), not (caddr_t *).
- simplify code a bit and use MEXTADD macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.68 2005/07/18 06:29:54 camield Exp $	*/
d674 2
a675 6
	if (entry == NULL) {
#ifdef TI_VERBOSE
		printf("%s: no free jumbo buffers\n", sc->sc_dv.dv_xname);
#endif
		return(NULL);
	}
@


1.68
log
@disable hardware vlan tag stripping

tested by Janjaap Velthoven

ok brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.67 2005/07/08 01:49:51 brad Exp $	*/
d861 1
a861 1
		caddr_t			*buf = NULL;
d876 2
a877 7
		m_new->m_data = m_new->m_ext.ext_buf = (void *)buf;
		m_new->m_flags |= M_EXT;
		m_new->m_len = m_new->m_pkthdr.len =
		    m_new->m_ext.ext_size = ETHER_MAX_LEN_JUMBO;
		m_new->m_ext.ext_free = ti_jfree;
		m_new->m_ext.ext_arg = sc;
		MCLINITREFERENCE(m_new);
@


1.67
log
@- use ETHER_MAX_LEN_JUMBO in one more spot
- don't bother setting bad checksum flag, fallback on software
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.66 2005/07/08 01:09:14 brad Exp $	*/
a1451 3
#if NVLAN > 0
	rcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;
#endif
a1458 3
#if NVLAN > 0
	rcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;
#endif
a1472 3
#if NVLAN > 0
	rcb->ti_flags |= TI_RCB_FLAG_VLAN_ASSIST;
#endif
a1789 4
#if NVLAN > 0
		u_int16_t		vlan_tag = 0;
		int			have_tag = 0;
#endif
a1800 7
#if NVLAN > 0
		if (cur_rx->ti_flags & TI_BDFLAG_VLAN_TAG) {
			have_tag = 1;
			vlan_tag = cur_rx->ti_vlan_tag;
		}
#endif

a1878 12
#if NVLAN > 0
		/*
		 * If we received a packet with a vlan tag, pass it
		 * to vlan_input() instead of ether_input().
		 */
		if (have_tag) {
			if (vlan_input_tag(m, vlan_tag) < 0)
				ifp->if_data.ifi_noproto++;
			have_tag = vlan_tag = 0;
			continue;
		}
#endif
@


1.66
log
@add a return here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.65 2005/07/07 17:49:43 brad Exp $	*/
d1059 1
a1059 1
		    TI_NTXSEG, MCLBYTES, 0, BUS_DMA_NOWAIT, &dmamap))
a1895 2
		else
			sumflags |= M_IPV4_CSUM_IN_BAD;
@


1.65
log
@- the PCI layer enables bus mastering so don't bother again here.
- use pci_mapreg_map()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.64 2005/07/03 02:25:13 brad Exp $	*/
d1767 1
@


1.64
log
@ETHERMTU_JUMBO -> ETHER_MAX_LEN_JUMBO
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.63 2005/07/03 02:17:51 brad Exp $	*/
a1577 2
	bus_addr_t iobase;
	bus_size_t iosize;
d1590 1
a1590 1
	command |= PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_MASTER_ENABLE;
d1594 5
a1598 15
	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf("%s: failed to enable memory mapping!\n",
		    sc->sc_dv.dv_xname);
		free(sc, M_DEVBUF);
		goto fail;
	}
	if (pci_mem_find(pc, pa->pa_tag, TI_PCI_LOMEM, &iobase, &iosize, NULL)) {
		printf(": can't find mem space\n");
		goto fail;
	}
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->ti_bhandle)) {
		printf(": can't map mem space\n");
		goto fail;
	}
	sc->ti_btag = pa->pa_memt;
d1602 1
a1602 1
		goto fail;
d1612 1
a1612 1
		goto fail;
d1769 1
a1769 2
	if (sc->ti_intrhand != NULL)
		pci_intr_disestablish(pc, sc->ti_intrhand);
d1771 1
a1772 2

	return;
@


1.63
log
@adjust tuneable for Jumbo case
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.62 2005/07/03 02:04:15 brad Exp $	*/
d2370 2
a2371 1
	CSR_WRITE_4(sc, TI_GCR_IFMTU, ETHERMTU_JUMBO + ETHER_VLAN_ENCAP_LEN);
@


1.62
log
@- when printing the "unsupported chip revision" message also print the
chip revision.
- allow VLAN-sized frames even when not using hardware VLAN support. From FreeBSD
- disestablish PCI interrupt on failure to attach.
- allow reception of Jumbo frames by default. Based on a diff sent to me a long time
ago by mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.61 2005/07/02 23:10:11 brad Exp $	*/
d1526 1
a1526 5
	if (ifp->if_mtu > ETHER_MAX_LEN)
		CSR_WRITE_4(sc, TI_GCR_RX_COAL_TICKS,
		    (sc->ti_rx_coal_ticks / 10));
	else
		CSR_WRITE_4(sc, TI_GCR_RX_COAL_TICKS, sc->ti_rx_coal_ticks);
@


1.61
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.60 2005/04/25 17:55:51 brad Exp $	*/
d1245 1
d1270 2
a1271 1
	switch(CSR_READ_4(sc, TI_MISC_HOST_CTL) & TI_MHC_CHIP_REV_MASK) {
d1279 3
a1281 1
		printf("%s: unsupported chip revision\n", sc->sc_dv.dv_xname);
d1288 1
a1288 1
		TI_SETBIT(sc, TI_MISC_LOCAL_CTL, TI_MLC_SRAM_BANK_256K);
a1736 4
#if NVLAN >0
	ifp->if_capabilities |= IFCAP_VLAN_MTU | IFCAP_VLAN_HWTAGGING;
#endif

d1741 6
d1785 3
d2374 1
a2374 2
	CSR_WRITE_4(sc, TI_GCR_IFMTU, ifp->if_mtu +
	    ETHER_HDR_LEN + ETHER_CRC_LEN);
d2406 1
a2406 2
	if (ifp->if_mtu > ETHER_MAX_LEN)
		ti_init_rx_ring_jumbo(sc);
d2594 1
a2594 1
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ETHERMTU_JUMBO) {
d2596 1
a2596 1
		} else {
a2597 2
			ti_init(sc);
		}
@


1.60
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.59 2005/04/18 00:04:11 brad Exp $	*/
d2678 2
a2707 2

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.59
log
@- check for ETHERMIN with SIOCSIFMTU ioctl case
- don't need to trim off anything but the VLID bits in the driver anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.58 2004/12/08 07:04:12 jsg Exp $	*/
d1906 1
a1906 1
		m->m_pkthdr.csum = sumflags;
@


1.58
log
@use ETHER_MAX_LEN
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.57 2004/11/22 04:14:17 deraadt Exp $	*/
d1825 1
a1825 1
			vlan_tag = cur_rx->ti_vlan_tag & 0xfff;
d2142 1
a2142 1
			txdesc.ti_vlan_tag = ifv->ifv_tag & 0xfff;
d2230 1
a2230 1
			f->ti_vlan_tag = ifv->ifv_tag & 0xfff;
d2587 1
a2587 1
		if (ifr->ifr_mtu > ETHERMTU_JUMBO) {
@


1.57
log
@build a tigon firmware file. Saves 150KB or so in GENERIC kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.56 2004/09/23 17:45:16 brad Exp $	*/
d1522 1
a1522 1
	if (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))
d2398 1
a2398 1
	if (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))
@


1.56
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.55 2004/09/19 22:22:05 brad Exp $	*/
d124 1
a124 2
#include <dev/microcode/tigon/ti_fw.h>
#include <dev/microcode/tigon/ti_fw2.h>
d427 6
d435 1
a435 19
		if (tigonFwReleaseMajor != TI_FIRMWARE_MAJOR ||
		    tigonFwReleaseMinor != TI_FIRMWARE_MINOR ||
		    tigonFwReleaseFix != TI_FIRMWARE_FIX) {
			printf("%s: firmware revision mismatch; want "
			    "%d.%d.%d, got %d.%d.%d\n", sc->sc_dv.dv_xname,
			    TI_FIRMWARE_MAJOR, TI_FIRMWARE_MINOR,
			    TI_FIRMWARE_FIX, tigonFwReleaseMajor,
			    tigonFwReleaseMinor, tigonFwReleaseFix);
			return;
		}
		ti_mem_write(sc, tigonFwTextAddr, tigonFwTextLen,
		    (caddr_t)tigonFwText);
		ti_mem_write(sc, tigonFwDataAddr, tigonFwDataLen,
		    (caddr_t)tigonFwData);
		ti_mem_write(sc, tigonFwRodataAddr, tigonFwRodataLen,
		    (caddr_t)tigonFwRodata);
		ti_mem_set(sc, tigonFwBssAddr, tigonFwBssLen);
		ti_mem_set(sc, tigonFwSbssAddr, tigonFwSbssLen);
		CSR_WRITE_4(sc, TI_CPU_PROGRAM_COUNTER, tigonFwStartAddr);
d438 1
a438 19
		if (tigon2FwReleaseMajor != TI_FIRMWARE_MAJOR ||
		    tigon2FwReleaseMinor != TI_FIRMWARE_MINOR ||
		    tigon2FwReleaseFix != TI_FIRMWARE_FIX) {
			printf("%s: firmware revision mismatch; want "
			    "%d.%d.%d, got %d.%d.%d\n", sc->sc_dv.dv_xname,
			    TI_FIRMWARE_MAJOR, TI_FIRMWARE_MINOR,
			    TI_FIRMWARE_FIX, tigon2FwReleaseMajor,
			    tigon2FwReleaseMinor, tigon2FwReleaseFix);
			return;
		}
		ti_mem_write(sc, tigon2FwTextAddr, tigon2FwTextLen,
		    (caddr_t)tigon2FwText);
		ti_mem_write(sc, tigon2FwDataAddr, tigon2FwDataLen,
		    (caddr_t)tigon2FwData);
		ti_mem_write(sc, tigon2FwRodataAddr, tigon2FwRodataLen,
		    (caddr_t)tigon2FwRodata);
		ti_mem_set(sc, tigon2FwBssAddr, tigon2FwBssLen);
		ti_mem_set(sc, tigon2FwSbssAddr, tigon2FwSbssLen);
		CSR_WRITE_4(sc, TI_CPU_PROGRAM_COUNTER, tigon2FwStartAddr);
d443 1
a443 1
		break;
d445 26
a470 2

	return;
@


1.55
log
@typo, or -> of
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.54 2004/09/16 00:55:08 mcbride Exp $	*/
a1737 1
	ifp->if_output = ether_output;
a1739 1
	ifp->if_mtu = ETHERMTU;
@


1.54
log
@If we can't allocate new jumbo storage, try to copy the packet into a
new mbuf chain with m_devget() before recycling the jumbo storage.
Frome if_sk.c

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.53 2004/08/19 18:26:29 mcbride Exp $	*/
d911 1
a911 1
 * that's 1MB or memory, which is a lot. For now, we fill only the first
@


1.53
log
@#ifdef TI_VERBOSE around "no free jumbo buffers" printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.52 2004/08/05 19:57:17 brad Exp $	*/
d1847 5
a1851 2
			if (ti_newbuf_jumbo(sc, sc->ti_jumbo, NULL) == ENOBUFS) {
				ifp->if_ierrors++;
d1853 6
a1858 1
				continue;
@


1.52
log
@remove some separate per driver constants and use
ETHER_MAX_LEN_JUMBO/ETHERMTU_JUMBO where appropriate.

ok mcbride@@ henning@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.51 2004/06/18 20:33:56 mcbride Exp $	*/
d682 1
d684 1
@


1.51
log
@Fix jumbo frames.
- Implement SIOCSIFMTU ioctl.
- Remove from the free list instead of the inuse list when allocating
  jumbo buffers.
- Use TI_JUMBO_FRAMELEN as the size argument to bus_dmamap_create();
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.50 2004/05/31 16:58:19 mcbride Exp $	*/
d884 1
a884 1
		    m_new->m_ext.ext_size = TI_JUMBO_FRAMELEN;
d891 1
a891 1
		m_new->m_ext.ext_size = TI_JUMBO_FRAMELEN;
d1063 1
a1063 1
		if (bus_dmamap_create(sc->sc_dmatag, TI_JUMBO_FRAMELEN,
d1460 1
a1460 1
	rcb->ti_max_len = TI_JUMBO_FRAMELEN;
d2586 1
a2586 1
		if (ifr->ifr_mtu > TI_JUMBO_FRAMELEN - ETHER_HDR_LEN) {
@


1.50
log
@Enable all multicast if we encounter a range.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.49 2004/04/09 21:52:17 henning Exp $	*/
d686 1
a686 1
	SLIST_REMOVE_HEAD(&sc->ti_jinuse_listhead, jpool_entries);
d1063 2
a1064 2
		if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, TI_NTXSEG,
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &dmamap))
d2583 8
@


1.49
log
@do not whine if we cannot get mbufs. the countless printfd makes the machine
crawl under mbuf starvation, making the situationmuch worse, and don't make
sense in the first place.
ok tdeval@@ millert@@ beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.48 2003/12/16 08:20:44 deraadt Exp $	*/
d1169 1
d1192 7
@


1.48
log
@Becuase
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.47 2003/10/26 15:07:26 jmc Exp $	*/
d759 1
a759 3
		if (m_new == NULL) {
			printf("%s: mbuf allocation failed "
			    "-- packet dropped!\n", sc->sc_dv.dv_xname);
a760 1
		}
a763 2
			printf("%s: cluster allocation failed "
			    "-- packet dropped!\n", sc->sc_dv.dv_xname);
d827 1
a827 3
		if (m_new == NULL) {
			printf("%s: mbuf allocation failed "
			    "-- packet dropped!\n", sc->sc_dv.dv_xname);
a828 1
		}
d870 1
a870 3
		if (m_new == NULL) {
			printf("%s: mbuf allocation failed "
			    "-- packet dropped!\n", sc->sc_dv.dv_xname);
a871 1
		}
a876 2
			printf("%s: jumbo allocation failed "
			    "-- packet dropped!\n", sc->sc_dv.dv_xname);
@


1.47
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.46 2003/03/06 23:07:27 jason Exp $	*/
d1759 1
a1759 1
		 * Becuase currently there's no way to specify the
@


1.46
log
@add support for vlan tagging correctly; from Chris Pascoe
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.45 2003/03/05 20:24:04 deraadt Exp $	*/
d2051 1
a2051 1
	/* Ack interrupt and stop others from occuring. */
@


1.45
log
@no \n in panic(); rimshot@@pandora.be
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.44 2003/02/26 19:07:32 nate Exp $	*/
d84 1
d114 5
d1745 4
@


1.44
log
@split encap and txeof functions into ones for tigon1 and tigon2
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.43 2003/02/26 19:02:50 nate Exp $	*/
d1882 1
a1882 1
			panic("%s: couldn't get mbuf\n", sc->sc_dv.dv_xname);
@


1.43
log
@don't do arithmetic on bus space handles.  Instead, use bus_space functions
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.42 2003/02/20 18:08:43 henning Exp $	*/
d130 2
a131 1
void ti_txeof(struct ti_softc *);
d135 2
a136 1
int ti_encap(struct ti_softc *, struct mbuf *, u_int32_t *);
d1930 52
a1981 1
void ti_txeof(sc)
d1998 2
a1999 16
		if (sc->ti_hwrev == TI_HWREV_TIGON) {
			if (idx > 383)
				CSR_WRITE_4(sc, TI_WINBASE,
				    TI_TX_RING_BASE + 6144);
			else if (idx > 255)
				CSR_WRITE_4(sc, TI_WINBASE,
				    TI_TX_RING_BASE + 4096);
			else if (idx > 127)
				CSR_WRITE_4(sc, TI_WINBASE,
				    TI_TX_RING_BASE + 2048);
			else
				CSR_WRITE_4(sc, TI_WINBASE,
				    TI_TX_RING_BASE);
			cur_tx = &sc->ti_tx_ring_nic[idx % 128];
		} else
			cur_tx = &sc->ti_rdata->ti_tx_ring[idx];
d2011 2
a2012 1
			SLIST_INSERT_HEAD(&sc->ti_tx_map_listhead, entry, link);
d2049 4
a2052 1
		ti_txeof(sc);
d2089 90
a2178 1
int ti_encap(sc, m_head, txidx)
d2213 1
a2213 16
		if (sc->ti_hwrev == TI_HWREV_TIGON) {
			if (frag > 383)
				CSR_WRITE_4(sc, TI_WINBASE,
					    TI_TX_RING_BASE + 6144);
			else if (frag > 255)
				CSR_WRITE_4(sc, TI_WINBASE,
					    TI_TX_RING_BASE + 4096);
			else if (frag > 127)
				CSR_WRITE_4(sc, TI_WINBASE,
					    TI_TX_RING_BASE + 2048);
			else
				CSR_WRITE_4(sc, TI_WINBASE,
					    TI_TX_RING_BASE);
			f = &sc->ti_tx_ring_nic[frag % 128];
		} else
			f = &sc->ti_rdata->ti_tx_ring[frag];
d2243 1
a2243 4
	if (sc->ti_hwrev == TI_HWREV_TIGON)
		sc->ti_tx_ring_nic[cur % 128].ti_flags |= TI_BDFLAG_END;
	else
		sc->ti_rdata->ti_tx_ring[cur].ti_flags |= TI_BDFLAG_END;
d2248 1
a2248 3
	if (sc->ti_hwrev == TI_HWREV_TIGON_II)
		TI_RING_DMASYNC(sc, ti_tx_ring[cur], BUS_DMASYNC_POSTREAD);
	
d2270 1
a2270 1
	int			pkts = 0;
d2286 6
a2291 1
		if (ti_encap(sc, m_head, &prodidx)) {
@


1.42
log
@no trailing newline in panic(); PR 3103
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.41 2002/12/04 17:32:30 nate Exp $	*/
d155 3
a157 1
void ti_mem(struct ti_softc *, u_int32_t, u_int32_t, caddr_t);
d325 2
a326 2
 * NIC memory access function. Can be used to either clear a section
 * of NIC local memory or (if buf is non-NULL) copy data into it.
d328 1
a328 2
void
ti_mem(sc, addr, len, buf)
d331 1
a331 1
	caddr_t			buf;
d346 35
a380 10
		if (buf == NULL) {
			bus_space_set_region_4(sc->ti_btag, sc->ti_bhandle,
			    TI_WINDOW + (segptr & (TI_WINLEN - 1)), 0,
			    segsize / 4);
		} else {
			bus_space_write_region_4(sc->ti_btag, sc->ti_bhandle,
			    TI_WINDOW + (segptr & (TI_WINLEN - 1)),
			    (u_int32_t *)ptr, segsize / 4);
			ptr += segsize;
		}
d384 1
d386 24
a409 1
	return;
d432 1
a432 1
		ti_mem(sc, tigonFwTextAddr, tigonFwTextLen,
d434 1
a434 1
		ti_mem(sc, tigonFwDataAddr, tigonFwDataLen,
d436 1
a436 1
		ti_mem(sc, tigonFwRodataAddr, tigonFwRodataLen,
d438 2
a439 2
		ti_mem(sc, tigonFwBssAddr, tigonFwBssLen, NULL);
		ti_mem(sc, tigonFwSbssAddr, tigonFwSbssLen, NULL);
d453 1
a453 1
		ti_mem(sc, tigon2FwTextAddr, tigon2FwTextLen,
d455 1
a455 1
		ti_mem(sc, tigon2FwDataAddr, tigon2FwDataLen,
d457 1
a457 1
		ti_mem(sc, tigon2FwRodataAddr, tigon2FwRodataLen,
d459 2
a460 2
		ti_mem(sc, tigon2FwBssAddr, tigon2FwBssLen, NULL);
		ti_mem(sc, tigon2FwSbssAddr, tigon2FwSbssLen, NULL);
a480 3
	if (sc->ti_cmd_ring == NULL)
		return;

a502 3
	if (sc->ti_cmd_ring == NULL)
		return;

a1424 2
	sc->ti_cmd_ring =
	    (struct ti_cmd_desc *)(sc->ti_bhandle + TI_GCR_CMDRING);
a1500 4
	if (sc->ti_hwrev == TI_HWREV_TIGON) {
		sc->ti_tx_ring_nic =
		    (struct ti_tx_desc *)(sc->ti_bhandle + TI_WINDOW);
	}
d1635 1
a1635 1
	ti_mem(sc, 0x2000, 0x100000 - 0x2000,  NULL);
d1879 3
d2556 1
a2556 1
	ti_mem(sc, 0x2000, 0x100000 - 0x2000, NULL);
@


1.41
log
@Make ti(4) use busdma and add all of the necessary stuff to support both
endian modes.  This makes ti now work on macppc and sparc64.
While we're at ti, clean up a bit of the code:
  Use SLIST instead of LIST
  Remove register
  Use bus_space instead of bcopy/bzero
  Don't use bitfields since it makes dealing with endianness annoying.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.40 2002/11/26 06:01:28 nate Exp $	*/
d746 1
a746 1
	    panic("overwritten!!!\n");
@


1.40
log
@1000baseTX -> 1000baseT
- More technically correct
- Matches FreeBSD and NetBSD
- Preserved #define for 1000baseTX for backwards compatibility
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.39 2002/11/19 18:40:17 jason Exp $	*/
a112 3
#include <uvm/uvm_extern.h>              /* for vtophys */
#include <machine/bus.h>

d155 1
a155 1
void ti_mem(struct ti_softc *, u_int32_t, u_int32_t, const void *);
d164 2
a165 2
int ti_newbuf_std(struct ti_softc *, int, struct mbuf *);
int ti_newbuf_mini(struct ti_softc *, int, struct mbuf *);
d187 1
a187 1
	register int		i, ack = 0;
d234 1
a234 1
	register int		i;
d330 1
a330 1
	const void *		buf;
d333 1
a333 2
	caddr_t			ti_winbase;
	const void *		ptr;
a336 1
	ti_winbase = (caddr_t)(sc->ti_bhandle + TI_WINDOW);
d345 8
a352 6
		if (buf == NULL)
			bzero(ti_winbase + (segptr &
			    (TI_WINLEN - 1)), segsize);
		else {
			bcopy(ptr, (char *)ti_winbase +
			    (segptr & (TI_WINLEN - 1)), segsize);
d383 1
a383 1
		    tigonFwText);
d385 1
a385 1
		    tigonFwData);
d387 1
a387 1
		    tigonFwRodata);
d404 1
a404 1
		    tigon2FwText);
d406 1
a406 1
		    tigon2FwData);
d408 1
a408 1
		    tigon2FwRodata);
d431 1
a431 1
	if (sc->ti_rdata->ti_cmd_ring == NULL)
d454 1
a454 1
	register int		i;
d456 1
a456 1
	if (sc->ti_rdata->ti_cmd_ring == NULL)
d486 1
a486 1
		switch(e->ti_event) {
d488 1
a488 1
			sc->ti_linkstat = e->ti_code;
d491 1
a491 1
			if (e->ti_code == TI_EV_CODE_ERR_INVAL_CMD)
d494 1
a494 1
			else if (e->ti_code == TI_EV_CODE_ERR_UNIMP_CMD)
d497 1
a497 1
			else if (e->ti_code == TI_EV_CODE_ERR_BADCFG)
d512 2
a513 2
			printf("%s: unknown event: %d\n",
			    sc->sc_dv.dv_xname, e->ti_event);
a551 1
	bus_dmamap_t dmamap;
d568 2
a569 2
	if (bus_dmamap_create(sc->sc_dmatag, TI_JMEM, 1,
	    TI_JMEM, 0, BUS_DMA_NOWAIT, &dmamap)) {
d575 2
a576 2
	if (bus_dmamap_load(sc->sc_dmatag, dmamap, kva, TI_JMEM,
	    NULL, BUS_DMA_NOWAIT)) {
d578 2
a579 1
		bus_dmamap_destroy(sc->sc_dmatag, dmamap);
d586 2
a587 2
	LIST_INIT(&sc->ti_jfree_listhead);
	LIST_INIT(&sc->ti_jinuse_listhead);
d601 4
a604 2
			bus_dmamap_unload(sc->sc_dmatag, dmamap);
			bus_dmamap_destroy(sc->sc_dmatag, dmamap);
d613 1
a613 1
		LIST_INSERT_HEAD(&sc->ti_jfree_listhead, entry, jpool_entries);
d627 1
a627 1
	entry = LIST_FIRST(&sc->ti_jfree_listhead);
d634 2
a635 2
	LIST_REMOVE(entry, jpool_entries);
	LIST_INSERT_HEAD(&sc->ti_jinuse_listhead, entry, jpool_entries);
d649 3
a651 3
	struct ti_softc *sc;
	int i;
	struct ti_jpool_entry *entry;
d666 10
a675 11
	else {
		sc->ti_cdata.ti_jslots[i].ti_inuse--;
		if(sc->ti_cdata.ti_jslots[i].ti_inuse == 0) {
			entry = LIST_FIRST(&sc->ti_jinuse_listhead);
			if (entry == NULL)
				panic("ti_jfree: buffer not in use!");
			entry->slot = i;
			LIST_REMOVE(entry, jpool_entries);
			LIST_INSERT_HEAD(&sc->ti_jfree_listhead,
					  entry, jpool_entries);
		}
d682 1
a682 1
int ti_newbuf_std(sc, i, m)
d686 1
d691 14
d721 7
d732 1
a734 1
	m_adj(m_new, ETHER_ALIGN);
d737 1
a737 1
	TI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));
d740 1
a740 1
	r->ti_len = MCLBYTES;
d743 5
d755 1
a755 1
int ti_newbuf_mini(sc, i, m)
d759 1
d764 14
d786 6
a797 1
	m_adj(m_new, ETHER_ALIGN);
d800 1
a800 1
	TI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));
d803 1
a803 1
	r->ti_len = m_new->m_len;
d859 1
a859 1
	TI_HOSTADDR(r->ti_addr) = vtophys(mtod(m_new, caddr_t));
d877 1
a877 1
	register int		i;
d881 1
a881 1
		if (ti_newbuf_std(sc, i, NULL) == ENOBUFS)
d883 1
a883 1
	};
d894 1
a894 1
	register int		i;
d900 3
d914 1
a914 1
	register int		i;
d931 1
a931 1
	register int		i;
d948 1
a948 1
	register int		i;
d951 1
a951 1
		if (ti_newbuf_mini(sc, i, NULL) == ENOBUFS)
d964 1
a964 1
	register int		i;
d970 3
d984 2
a985 1
	register int		i;
d994 3
d1002 6
d1014 4
d1021 16
d1127 1
a1127 2
	struct ti_mc_entry *p;

d1142 2
a1143 3
	p = LIST_FIRST(&sc->ti_mc_listhead);
	while (p != NULL) {
		mc = p;
d1145 1
a1145 3
		p = LIST_FIRST(&sc->ti_mc_listhead);
		LIST_REMOVE(mc, mc_entries);
		p = LIST_NEXT(p, mc_entries);
d1156 1
a1156 1
		LIST_INSERT_HEAD(&sc->ti_mc_listhead, mc, mc_entries);
d1208 1
a1208 1
#if BYTE_ORDER == BIG_ENDIAN
d1354 3
d1358 3
a1360 1
	CSR_WRITE_4(sc, TI_GCR_GENINFO_LO, vtophys(&sc->ti_rdata->ti_info));
d1370 1
a1370 1
	TI_HOSTADDR(rcb->ti_hostaddr) = vtophys(&sc->ti_rdata->ti_event_ring);
d1373 1
a1373 1
	    vtophys(&sc->ti_ev_prodidx);
d1381 1
a1381 1
	sc->ti_rdata->ti_cmd_ring =
d1399 1
a1399 1
	    vtophys(&sc->ti_rdata->ti_info.ti_stats);
d1403 3
a1405 2
	TI_HOSTADDR(rcb->ti_hostaddr) = vtophys(&sc->ti_rdata->ti_rx_std_ring);
	rcb->ti_max_len = TI_FRAMELEN;
d1414 1
a1414 2
	TI_HOSTADDR(rcb->ti_hostaddr) =
	    vtophys(&sc->ti_rdata->ti_rx_jumbo_ring);
d1428 1
a1428 2
	TI_HOSTADDR(rcb->ti_hostaddr) =
	    vtophys(&sc->ti_rdata->ti_rx_mini_ring);
d1443 1
a1443 2
	TI_HOSTADDR(rcb->ti_hostaddr) =
	    vtophys(&sc->ti_rdata->ti_rx_return_ring);
d1447 1
a1447 1
	    vtophys(&sc->ti_return_prodidx);
d1460 1
a1460 1
		sc->ti_rdata->ti_tx_ring_nic =
d1479 1
a1479 1
		    vtophys(&sc->ti_rdata->ti_tx_ring);
d1481 3
a1483 1
	    vtophys(&sc->ti_tx_considx);
a1544 1
	bus_dmamap_t dmamap;
d1641 2
a1642 1
	    sizeof(struct ti_ring_data), 0, BUS_DMA_NOWAIT, &dmamap)) {
d1649 1
a1649 1
	if (bus_dmamap_load(sc->sc_dmatag, dmamap, kva,
d1651 1
a1651 1
		bus_dmamap_destroy(sc->sc_dmatag, dmamap);
d1777 1
d1809 2
d1813 1
a1813 1
				ti_newbuf_mini(sc, sc->ti_mini, m);
d1816 2
a1817 1
			if (ti_newbuf_mini(sc, sc->ti_mini, NULL) == ENOBUFS) {
d1819 1
a1819 1
				ti_newbuf_mini(sc, sc->ti_mini, m);
d1826 2
d1830 1
a1830 1
				ti_newbuf_std(sc, sc->ti_std, m);
d1833 2
a1834 1
			if (ti_newbuf_std(sc, sc->ti_std, NULL) == ENOBUFS) {
d1836 1
a1836 1
				ti_newbuf_std(sc, sc->ti_std, m);
d1892 1
d1917 1
a1917 1
			cur_tx = &sc->ti_rdata->ti_tx_ring_nic[idx % 128];
d1925 9
d1986 1
d1990 7
a1996 6
	ifp->if_collisions +=
	   (sc->ti_rdata->ti_info.ti_stats.dot3StatsSingleCollisionFrames +
	   sc->ti_rdata->ti_info.ti_stats.dot3StatsMultipleCollisionFrames +
	   sc->ti_rdata->ti_info.ti_stats.dot3StatsExcessiveCollisions +
	   sc->ti_rdata->ti_info.ti_stats.dot3StatsLateCollisions) -
	   ifp->if_collisions;
d1998 1
a1998 1
	return;
a2010 1
	struct mbuf		*m;
d2012 3
d2023 5
a2027 1
	m = m_head;
d2035 8
a2042 5
	for (m = m_head; m != NULL; m = m->m_next) {
		if (m->m_len != 0) {
			if (sc->ti_hwrev == TI_HWREV_TIGON) {
				if (frag > 383)
					CSR_WRITE_4(sc, TI_WINBASE,
d2044 2
a2045 2
				else if (frag > 255)
					CSR_WRITE_4(sc, TI_WINBASE,
d2047 2
a2048 2
				else if (frag > 127)
					CSR_WRITE_4(sc, TI_WINBASE,
d2050 2
a2051 2
				else
					CSR_WRITE_4(sc, TI_WINBASE,
d2053 10
a2062 8
				f = &sc->ti_rdata->ti_tx_ring_nic[frag % 128];
			} else
				f = &sc->ti_rdata->ti_tx_ring[frag];
			if (sc->ti_cdata.ti_tx_chain[frag] != NULL)
				break;
			TI_HOSTADDR(f->ti_addr) = vtophys(mtod(m, vm_offset_t));
			f->ti_len = m->m_len;
			f->ti_flags = 0;
d2064 6
a2069 6
			if (ifv != NULL) {
				f->ti_flags |= TI_BDFLAG_VLAN_TAG;
				f->ti_vlan_tag = ifv->ifv_tag & 0xfff;
			} else {
				f->ti_vlan_tag = 0;
			}
d2071 9
a2079 10
			/*
			 * Sanity check: avoid coming within 16 descriptors
			 * of the end of the ring.
			 */
			if ((TI_TX_RING_CNT - (sc->ti_txcnt + cnt)) < 16)
				return(ENOBUFS);
			cur = frag;
			TI_INC(frag, TI_TX_RING_CNT);
			cnt++;
		}
a2081 3
	if (m != NULL)
		return(ENOBUFS);

d2086 1
a2086 2
		sc->ti_rdata->ti_tx_ring_nic[cur % 128].ti_flags |=
		    TI_BDFLAG_END;
d2089 8
d2098 2
@


1.39
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.38 2002/10/03 23:50:07 jason Exp $	*/
d1638 1
a1638 1
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_1000_TX, 0, NULL);
d1640 1
a1640 1
		    IFM_ETHER|IFM_1000_TX|IFM_FDX, 0, NULL);
d2185 1
a2185 1
	case IFM_1000_TX:
d2243 1
a2243 1
			ifmr->ifm_active |= IFM_1000_TX;
@


1.38
log
@Use our defn of pci command registers, not freebsd's
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.37 2002/07/05 13:48:11 aaron Exp $	*/
d1425 10
d1445 2
a1446 26
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_NETGEAR &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETGEAR_GA620 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETGEAR_GA620T))
		return (1);

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ALTEON &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALTEON_ACENIC ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALTEON_ACENICT))
		return (1);

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_3COM &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_3COM_3C985)
		return (1);

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SGI &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SGI_TIGON)
		return (1);

	/* This is really a Farallon board, they used the wrong vendorid */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DEC &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_PN9000SX)
		return (1);

	return (0);
@


1.37
log
@Typo; stobe -> strobe
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.36 2002/05/01 16:15:49 mickey Exp $	*/
d1188 1
a1188 1
	if (CSR_READ_4(sc, TI_PCI_CMDSTAT) & PCIM_CMD_MWIEN) {
d1204 1
a1204 1
			    TI_PCI_CMDSTAT) & ~PCIM_CMD_MWIEN);
@


1.36
log
@make fw images const and fix ti for unneeded type casts; jason@@ testing ans ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.35 2002/03/14 01:26:59 millert Exp $	*/
d198 1
a198 1
	 * Feed in each bit and stobe the clock.
@


1.35
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.34 2002/02/15 20:45:31 nordin Exp $	*/
d158 1
a158 1
void ti_mem(struct ti_softc *, u_int32_t, u_int32_t, caddr_t);
d329 2
a330 1
void ti_mem(sc, addr, len, buf)
d333 1
a333 1
	caddr_t			buf;
d336 2
a337 1
	caddr_t			ti_winbase, ptr;
d351 1
a351 1
			bzero((char *)ti_winbase + (segptr &
d354 1
a354 1
			bcopy((char *)ptr, (char *)ti_winbase +
d386 1
a386 1
		    (caddr_t)tigonFwText);
d388 1
a388 1
		    (caddr_t)tigonFwData);
d390 1
a390 1
		    (caddr_t)tigonFwRodata);
d407 1
a407 1
		    (caddr_t)tigon2FwText);
d409 1
a409 1
		    (caddr_t)tigon2FwData);
d411 1
a411 1
		    (caddr_t)tigon2FwRodata);
@


1.34
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.33 2002/01/11 01:31:21 nordin Exp $	*/
d130 2
a131 2
int ti_probe		__P((struct device *, void *, void *));
void ti_attach		__P((struct device *, struct device *, void *));
d133 2
a134 2
void ti_txeof		__P((struct ti_softc *));
void ti_rxeof		__P((struct ti_softc *));
d136 2
a137 2
void ti_stats_update	__P((struct ti_softc *));
int ti_encap		__P((struct ti_softc *, struct mbuf *, u_int32_t *));
d139 43
a181 43
int ti_intr		__P((void *));
void ti_start		__P((struct ifnet *));
int ti_ioctl		__P((struct ifnet *, u_long, caddr_t));
void ti_init		__P((void *));
void ti_init2		__P((struct ti_softc *));
void ti_stop		__P((struct ti_softc *));
void ti_watchdog	__P((struct ifnet *));
void ti_shutdown	__P((void *));
int ti_ifmedia_upd	__P((struct ifnet *));
void ti_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));

u_int32_t ti_eeprom_putbyte	__P((struct ti_softc *, int));
u_int8_t ti_eeprom_getbyte	__P((struct ti_softc *, int, u_int8_t *));
int ti_read_eeprom	__P((struct ti_softc *, caddr_t, int, int));

void ti_add_mcast	__P((struct ti_softc *, struct ether_addr *));
void ti_del_mcast	__P((struct ti_softc *, struct ether_addr *));
void ti_setmulti	__P((struct ti_softc *));

void ti_mem		__P((struct ti_softc *, u_int32_t, u_int32_t, caddr_t));
void ti_loadfw		__P((struct ti_softc *));
void ti_cmd		__P((struct ti_softc *, struct ti_cmd_desc *));
void ti_cmd_ext		__P((struct ti_softc *, struct ti_cmd_desc *,
    caddr_t, int));
void ti_handle_events	__P((struct ti_softc *));
int ti_alloc_jumbo_mem	__P((struct ti_softc *));
void *ti_jalloc		__P((struct ti_softc *));
void ti_jfree		__P((caddr_t, u_int, void *));
int ti_newbuf_std		__P((struct ti_softc *, int, struct mbuf *));
int ti_newbuf_mini		__P((struct ti_softc *, int, struct mbuf *));
int ti_newbuf_jumbo		__P((struct ti_softc *, int, struct mbuf *));
int ti_init_rx_ring_std		__P((struct ti_softc *));
void ti_free_rx_ring_std	__P((struct ti_softc *));
int ti_init_rx_ring_jumbo	__P((struct ti_softc *));
void ti_free_rx_ring_jumbo	__P((struct ti_softc *));
int ti_init_rx_ring_mini	__P((struct ti_softc *));
void ti_free_rx_ring_mini	__P((struct ti_softc *));
void ti_free_tx_ring		__P((struct ti_softc *));
int ti_init_tx_ring		__P((struct ti_softc *));

int ti_64bitslot_war	__P((struct ti_softc *));
int ti_chipinit		__P((struct ti_softc *));
int ti_gibinit		__P((struct ti_softc *));
@


1.33
log
@Check result from malloc(9) when using M_NOWAIT. fgsch@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.32 2001/12/13 23:52:15 niklas Exp $	*/
d2368 1
a2368 1
	(void)splx(s);
@


1.32
log
@If initialization fails, panic right away, instead of
crashing randomly a little later.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.31 2001/11/06 19:53:19 miod Exp $	*/
d1074 2
@


1.32.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.33 2002/01/11 01:31:21 nordin Exp $	*/
a1073 2
		if (mc == NULL)
			panic("ti_setmulti");
@


1.32.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.32.2.1 2002/01/31 22:55:35 niklas Exp $	*/
d130 2
a131 2
int ti_probe(struct device *, void *, void *);
void ti_attach(struct device *, struct device *, void *);
d133 2
a134 2
void ti_txeof(struct ti_softc *);
void ti_rxeof(struct ti_softc *);
d136 2
a137 2
void ti_stats_update(struct ti_softc *);
int ti_encap(struct ti_softc *, struct mbuf *, u_int32_t *);
d139 43
a181 43
int ti_intr(void *);
void ti_start(struct ifnet *);
int ti_ioctl(struct ifnet *, u_long, caddr_t);
void ti_init(void *);
void ti_init2(struct ti_softc *);
void ti_stop(struct ti_softc *);
void ti_watchdog(struct ifnet *);
void ti_shutdown(void *);
int ti_ifmedia_upd(struct ifnet *);
void ti_ifmedia_sts(struct ifnet *, struct ifmediareq *);

u_int32_t ti_eeprom_putbyte(struct ti_softc *, int);
u_int8_t ti_eeprom_getbyte(struct ti_softc *, int, u_int8_t *);
int ti_read_eeprom(struct ti_softc *, caddr_t, int, int);

void ti_add_mcast(struct ti_softc *, struct ether_addr *);
void ti_del_mcast(struct ti_softc *, struct ether_addr *);
void ti_setmulti(struct ti_softc *);

void ti_mem(struct ti_softc *, u_int32_t, u_int32_t, const void *);
void ti_loadfw(struct ti_softc *);
void ti_cmd(struct ti_softc *, struct ti_cmd_desc *);
void ti_cmd_ext(struct ti_softc *, struct ti_cmd_desc *,
    caddr_t, int);
void ti_handle_events(struct ti_softc *);
int ti_alloc_jumbo_mem(struct ti_softc *);
void *ti_jalloc(struct ti_softc *);
void ti_jfree(caddr_t, u_int, void *);
int ti_newbuf_std(struct ti_softc *, int, struct mbuf *);
int ti_newbuf_mini(struct ti_softc *, int, struct mbuf *);
int ti_newbuf_jumbo(struct ti_softc *, int, struct mbuf *);
int ti_init_rx_ring_std(struct ti_softc *);
void ti_free_rx_ring_std(struct ti_softc *);
int ti_init_rx_ring_jumbo(struct ti_softc *);
void ti_free_rx_ring_jumbo(struct ti_softc *);
int ti_init_rx_ring_mini(struct ti_softc *);
void ti_free_rx_ring_mini(struct ti_softc *);
void ti_free_tx_ring(struct ti_softc *);
int ti_init_tx_ring(struct ti_softc *);

int ti_64bitslot_war(struct ti_softc *);
int ti_chipinit(struct ti_softc *);
int ti_gibinit(struct ti_softc *);
d329 1
a329 2
void
ti_mem(sc, addr, len, buf)
d332 1
a332 1
	const void *		buf;
d335 1
a335 2
	caddr_t			ti_winbase;
	const void *		ptr;
d349 1
a349 1
			bzero(ti_winbase + (segptr &
d352 1
a352 1
			bcopy(ptr, (char *)ti_winbase +
d384 1
a384 1
		    tigonFwText);
d386 1
a386 1
		    tigonFwData);
d388 1
a388 1
		    tigonFwRodata);
d405 1
a405 1
		    tigon2FwText);
d407 1
a407 1
		    tigon2FwData);
d409 1
a409 1
		    tigon2FwRodata);
d2368 1
a2368 1
	splx(s);
@


1.32.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.32.2.2 2002/06/11 03:42:25 art Exp $	*/
d198 1
a198 1
	 * Feed in each bit and strobe the clock.
d1188 1
a1188 1
	if (CSR_READ_4(sc, TI_PCI_CMDSTAT) & PCI_COMMAND_INVALIDATE_ENABLE) {
d1204 1
a1204 1
			    TI_PCI_CMDSTAT) & ~PCI_COMMAND_INVALIDATE_ENABLE);
@


1.32.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a83 1
#include "vlan.h"
d113 2
a114 4
#if NVLAN > 0
#include <net/if_types.h>
#include <net/if_vlan_var.h>
#endif
d133 1
a133 2
void ti_txeof_tigon1(struct ti_softc *);
void ti_txeof_tigon2(struct ti_softc *);
d137 1
a137 2
int ti_encap_tigon1(struct ti_softc *, struct mbuf *, u_int32_t *);
int ti_encap_tigon2(struct ti_softc *, struct mbuf *, u_int32_t *);
d158 1
a158 3
void ti_mem_read(struct ti_softc *, u_int32_t, u_int32_t, void *);
void ti_mem_write(struct ti_softc *, u_int32_t, u_int32_t, const void*);
void ti_mem_set(struct ti_softc *, u_int32_t, u_int32_t);
d167 2
a168 2
int ti_newbuf_std(struct ti_softc *, int, struct mbuf *, bus_dmamap_t);
int ti_newbuf_mini(struct ti_softc *, int, struct mbuf *, bus_dmamap_t);
d190 1
a190 1
	int		i, ack = 0;
d237 1
a237 1
	int		i;
d326 2
a327 2
 * NIC memory read function.
 * Can be used to copy data from NIC local memory.
d329 2
a330 1
void ti_mem_read(sc, addr, len, buf)
d333 1
a333 1
	void			*buf;
d336 2
a337 1
	caddr_t			ptr;
d341 1
d350 8
a357 4
		bus_space_read_region_4(sc->ti_btag, sc->ti_bhandle,
		    TI_WINDOW + (segptr & (TI_WINLEN - 1)), (u_int32_t *)ptr,
		    segsize / 4);
		ptr += segsize;
a360 1
}
d362 1
a362 55
/*
 * NIC memory write function.
 * Can be used to copy data into  NIC local memory.
 */
void ti_mem_write(sc, addr, len, buf)
	struct ti_softc		*sc;
	u_int32_t		addr, len;
	const void		*buf;
{
	int			segptr, segsize, cnt;
	const char		*ptr;

	segptr = addr;
	cnt = len;
	ptr = buf;

	while(cnt) {
		if (cnt < TI_WINLEN)
			segsize = cnt;
		else
			segsize = TI_WINLEN - (segptr % TI_WINLEN);
		CSR_WRITE_4(sc, TI_WINBASE, (segptr & ~(TI_WINLEN - 1)));
		bus_space_write_region_4(sc->ti_btag, sc->ti_bhandle,
		    TI_WINDOW + (segptr & (TI_WINLEN - 1)), (u_int32_t *)ptr,
		    segsize / 4);
		ptr += segsize;
		segptr += segsize;
		cnt -= segsize;
	}
}

/*
 * NIC memory write function.
 * Can be used to clear a section of NIC local memory.
 */
void ti_mem_set(sc, addr, len)
	struct ti_softc		*sc;
	u_int32_t		addr, len;
{
	int			segptr, segsize, cnt;

	segptr = addr;
	cnt = len;

	while(cnt) {
		if (cnt < TI_WINLEN)
			segsize = cnt;
		else
			segsize = TI_WINLEN - (segptr % TI_WINLEN);
		CSR_WRITE_4(sc, TI_WINBASE, (segptr & ~(TI_WINLEN - 1)));
		bus_space_set_region_4(sc->ti_btag, sc->ti_bhandle,
		    TI_WINDOW + (segptr & (TI_WINLEN - 1)), 0, segsize / 4);
		segptr += segsize;
		cnt -= segsize;
	}
d385 8
a392 8
		ti_mem_write(sc, tigonFwTextAddr, tigonFwTextLen,
		    (caddr_t)tigonFwText);
		ti_mem_write(sc, tigonFwDataAddr, tigonFwDataLen,
		    (caddr_t)tigonFwData);
		ti_mem_write(sc, tigonFwRodataAddr, tigonFwRodataLen,
		    (caddr_t)tigonFwRodata);
		ti_mem_set(sc, tigonFwBssAddr, tigonFwBssLen);
		ti_mem_set(sc, tigonFwSbssAddr, tigonFwSbssLen);
d406 8
a413 8
		ti_mem_write(sc, tigon2FwTextAddr, tigon2FwTextLen,
		    (caddr_t)tigon2FwText);
		ti_mem_write(sc, tigon2FwDataAddr, tigon2FwDataLen,
		    (caddr_t)tigon2FwData);
		ti_mem_write(sc, tigon2FwRodataAddr, tigon2FwRodataLen,
		    (caddr_t)tigon2FwRodata);
		ti_mem_set(sc, tigon2FwBssAddr, tigon2FwBssLen);
		ti_mem_set(sc, tigon2FwSbssAddr, tigon2FwSbssLen);
d434 3
d457 4
a460 1
	int		i;
d489 1
a489 1
		switch (TI_EVENT_EVENT(e)) {
d491 1
a491 1
			sc->ti_linkstat = TI_EVENT_CODE(e);
d494 1
a494 1
			if (TI_EVENT_CODE(e) == TI_EV_CODE_ERR_INVAL_CMD)
d497 1
a497 1
			else if (TI_EVENT_CODE(e) == TI_EV_CODE_ERR_UNIMP_CMD)
d500 1
a500 1
			else if (TI_EVENT_CODE(e) == TI_EV_CODE_ERR_BADCFG)
d515 2
a516 2
			printf("%s: unknown event: %d\n", sc->sc_dv.dv_xname,
			       TI_EVENT_EVENT(e));
d555 1
d572 2
a573 2
	if (bus_dmamap_create(sc->sc_dmatag, TI_JMEM, 1, TI_JMEM, 0,
	    BUS_DMA_NOWAIT, &sc->ti_cdata.ti_rx_jumbo_map)) {
d579 2
a580 2
	if (bus_dmamap_load(sc->sc_dmatag, sc->ti_cdata.ti_rx_jumbo_map, kva,
	    TI_JMEM, NULL, BUS_DMA_NOWAIT)) {
d582 1
a582 2
		bus_dmamap_destroy(sc->sc_dmatag,
				   sc->ti_cdata.ti_rx_jumbo_map);
d589 2
a590 2
	SLIST_INIT(&sc->ti_jfree_listhead);
	SLIST_INIT(&sc->ti_jinuse_listhead);
d604 2
a605 4
			bus_dmamap_unload(sc->sc_dmatag,
					  sc->ti_cdata.ti_rx_jumbo_map);
			bus_dmamap_destroy(sc->sc_dmatag,
					   sc->ti_cdata.ti_rx_jumbo_map);
d614 1
a614 1
		SLIST_INSERT_HEAD(&sc->ti_jfree_listhead, entry, jpool_entries);
d628 1
a628 1
	entry = SLIST_FIRST(&sc->ti_jfree_listhead);
d635 2
a636 2
	SLIST_REMOVE_HEAD(&sc->ti_jinuse_listhead, jpool_entries);
	SLIST_INSERT_HEAD(&sc->ti_jinuse_listhead, entry, jpool_entries);
d650 3
a652 3
	struct ti_softc		*sc;
	int			i;
	struct ti_jpool_entry	*entry;
d667 11
a677 10

	sc->ti_cdata.ti_jslots[i].ti_inuse--;
	if(sc->ti_cdata.ti_jslots[i].ti_inuse == 0) {
		entry = SLIST_FIRST(&sc->ti_jinuse_listhead);
		if (entry == NULL)
			panic("ti_jfree: buffer not in use!");
		entry->slot = i;
		SLIST_REMOVE_HEAD(&sc->ti_jinuse_listhead, jpool_entries);
		SLIST_INSERT_HEAD(&sc->ti_jfree_listhead,
				  entry, jpool_entries);
d684 1
a684 1
int ti_newbuf_std(sc, i, m, dmamap)
a687 1
	bus_dmamap_t		dmamap;
a691 14
	if (dmamap == NULL) {
		/* if (m) panic() */

		if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, 1, MCLBYTES,
				      0, BUS_DMA_NOWAIT, &dmamap)) {
			printf("%s: can't create recv map\n",
			       sc->sc_dv.dv_xname);
			return(ENOMEM);
		}
	} else if (m == NULL)
		bus_dmamap_unload(sc->sc_dmatag, dmamap);

	sc->ti_cdata.ti_rx_std_map[i] = dmamap;

a707 7

		m_adj(m_new, ETHER_ALIGN);

		if (bus_dmamap_load_mbuf(sc->sc_dmatag, dmamap, m_new,
					 BUS_DMA_NOWAIT))
			return(ENOBUFS);

a711 1
		m_adj(m_new, ETHER_ALIGN);
d714 1
d717 1
a717 1
	TI_HOSTADDR(r->ti_addr) = dmamap->dm_segs[0].ds_addr;
d720 1
a720 1
	r->ti_len = dmamap->dm_segs[0].ds_len;
a722 5
	if ((dmamap->dm_segs[0].ds_addr & ~(MCLBYTES - 1)) !=
	    ((dmamap->dm_segs[0].ds_addr + dmamap->dm_segs[0].ds_len - 1) & 
	     ~(MCLBYTES - 1)))
	    panic("overwritten!!!");

d730 1
a730 1
int ti_newbuf_mini(sc, i, m, dmamap)
a733 1
	bus_dmamap_t		dmamap;
a737 14
	if (dmamap == NULL) {
		/* if (m) panic() */

		if (bus_dmamap_create(sc->sc_dmatag, MHLEN, 1, MHLEN,
				      0, BUS_DMA_NOWAIT, &dmamap)) {
			printf("%s: can't create recv map\n",
			       sc->sc_dv.dv_xname);
			return(ENOMEM);
		}
	} else if (m == NULL)
		bus_dmamap_unload(sc->sc_dmatag, dmamap);

	sc->ti_cdata.ti_rx_mini_map[i] = dmamap;

a745 6
		m_adj(m_new, ETHER_ALIGN);

		if (bus_dmamap_load_mbuf(sc->sc_dmatag, dmamap, m_new,
					 BUS_DMA_NOWAIT))
		return(ENOBUFS);

d752 1
d755 1
a755 1
	TI_HOSTADDR(r->ti_addr) = dmamap->dm_segs[0].ds_addr;
d758 1
a758 1
	r->ti_len = dmamap->dm_segs[0].ds_len;
d814 1
a814 1
	TI_HOSTADDR(r->ti_addr) = TI_JUMBO_DMA_ADDR(sc, m_new);
d832 1
a832 1
	int		i;
d836 1
a836 1
		if (ti_newbuf_std(sc, i, NULL, 0) == ENOBUFS)
d838 1
a838 1
	}
d849 1
a849 1
	int		i;
a854 3
			bus_dmamap_destroy(sc->sc_dmatag,
					   sc->ti_cdata.ti_rx_std_map[i]);
			sc->ti_cdata.ti_rx_std_map[i] = 0;
d866 1
a866 1
	int		i;
d883 1
a883 1
	int		i;
d900 1
a900 1
	int		i;
d903 1
a903 1
		if (ti_newbuf_mini(sc, i, NULL, 0) == ENOBUFS)
d916 1
a916 1
	int		i;
a921 3
			bus_dmamap_destroy(sc->sc_dmatag,
					   sc->ti_cdata.ti_rx_mini_map[i]);
			sc->ti_cdata.ti_rx_mini_map[i] = 0;
d933 1
a933 2
	int		i;
	struct ti_txmap_entry *entry;
a941 3
			SLIST_INSERT_HEAD(&sc->ti_tx_map_listhead,
					    sc->ti_cdata.ti_tx_map[i], link);
			sc->ti_cdata.ti_tx_map[i] = 0;
a946 6
	while ((entry = SLIST_FIRST(&sc->ti_tx_map_listhead))) {
		SLIST_REMOVE_HEAD(&sc->ti_tx_map_listhead, link);
		bus_dmamap_destroy(sc->sc_dmatag, entry->dmamap);
		free(entry, M_DEVBUF);
	}

a952 4
	int i;
	bus_dmamap_t dmamap;
	struct ti_txmap_entry *entry;

a955 16

	SLIST_INIT(&sc->ti_tx_map_listhead);
	for (i = 0; i < TI_TX_RING_CNT; i++) {
		if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, TI_NTXSEG,
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &dmamap))
			return(ENOBUFS);

		entry = malloc(sizeof(*entry), M_DEVBUF, M_NOWAIT);
		if (!entry) {
			bus_dmamap_destroy(sc->sc_dmatag, dmamap);
			return (ENOBUFS);
		}
		entry->dmamap = dmamap;
		SLIST_INSERT_HEAD(&sc->ti_tx_map_listhead, entry, link);
	}

d1046 2
a1047 1
 
d1062 3
a1064 2
	while (SLIST_FIRST(&sc->ti_mc_listhead) != NULL) {
		mc = SLIST_FIRST(&sc->ti_mc_listhead);
d1066 3
a1068 1
		SLIST_REMOVE_HEAD(&sc->ti_mc_listhead, mc_entries);
d1079 1
a1079 1
		SLIST_INSERT_HEAD(&sc->ti_mc_listhead, mc, mc_entries);
d1131 1
a1131 1
#if 0 && BYTE_ORDER == BIG_ENDIAN
a1276 3
#ifdef __64_bit_pci_addressing__ 
	CSR_WRITE_4(sc, TI_GCR_GENINFO_HI, TI_RING_DMA_ADDR(sc, ti_info)>>32);
#else
d1278 1
a1278 3
#endif
	CSR_WRITE_4(sc, TI_GCR_GENINFO_LO,
		    TI_RING_DMA_ADDR(sc, ti_info) & 0xffffffff);
d1288 1
a1288 1
	TI_HOSTADDR(rcb->ti_hostaddr) = TI_RING_DMA_ADDR(sc, ti_event_ring);
d1291 1
a1291 1
		TI_RING_DMA_ADDR(sc, ti_ev_prodidx_r);
d1299 2
d1317 1
a1317 1
		TI_RING_DMA_ADDR(sc, ti_info.ti_stats);
d1321 2
a1322 3
	TI_HOSTADDR(rcb->ti_hostaddr) =
		TI_RING_DMA_ADDR(sc, ti_rx_std_ring);
	rcb->ti_max_len = ETHER_MAX_LEN;
d1331 2
a1332 1
	TI_HOSTADDR(rcb->ti_hostaddr) = TI_RING_DMA_ADDR(sc, ti_rx_jumbo_ring);
d1346 2
a1347 1
	TI_HOSTADDR(rcb->ti_hostaddr) = TI_RING_DMA_ADDR(sc, ti_rx_mini_ring);
d1362 2
a1363 1
	TI_HOSTADDR(rcb->ti_hostaddr) = TI_RING_DMA_ADDR(sc,ti_rx_return_ring);
d1367 1
a1367 1
	    TI_RING_DMA_ADDR(sc, ti_return_prodidx_r);
d1379 4
d1399 1
a1399 1
			TI_RING_DMA_ADDR(sc, ti_tx_ring);
d1401 1
a1401 3
		TI_RING_DMA_ADDR(sc, ti_tx_considx_r);

	TI_RING_DMASYNC(sc, ti_info, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
a1424 10
const struct pci_matchid ti_devices[] = {
	{ PCI_VENDOR_NETGEAR, PCI_PRODUCT_NETGEAR_GA620 },
	{ PCI_VENDOR_NETGEAR, PCI_PRODUCT_NETGEAR_GA620T },
	{ PCI_VENDOR_ALTEON, PCI_PRODUCT_ALTEON_ACENIC },
	{ PCI_VENDOR_ALTEON, PCI_PRODUCT_ALTEON_ACENICT },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C985 },
	{ PCI_VENDOR_SGI, PCI_PRODUCT_SGI_TIGON },
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_PN9000SX },
};

d1435 26
a1460 2
	return (pci_matchbyid((struct pci_attach_args *)aux, ti_devices,
	    sizeof(ti_devices)/sizeof(ti_devices[0])));
d1477 1
d1530 1
a1530 1
	ti_mem_set(sc, 0x2000, 0x100000 - 0x2000);
d1574 1
a1574 2
	    sizeof(struct ti_ring_data), 0, BUS_DMA_NOWAIT,
	    &sc->ti_ring_map)) {
d1581 1
a1581 1
	if (bus_dmamap_load(sc->sc_dmatag, sc->ti_ring_map, kva,
d1583 1
a1583 1
		bus_dmamap_destroy(sc->sc_dmatag, sc->ti_ring_map);
a1630 4
#if NVLAN >0
	ifp->if_capabilities |= IFCAP_VLAN_MTU | IFCAP_VLAN_HWTAGGING;
#endif

d1652 1
a1652 1
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_1000_T, 0, NULL);
d1654 1
a1654 1
		    IFM_ETHER|IFM_1000_T|IFM_FDX, 0, NULL);
a1708 1
		bus_dmamap_t		dmamap;
a1739 2
			dmamap = sc->ti_cdata.ti_rx_mini_map[rxidx];
			sc->ti_cdata.ti_rx_mini_map[rxidx] = 0;
d1742 1
a1742 1
				ti_newbuf_mini(sc, sc->ti_mini, m, dmamap);
d1745 1
a1745 2
			if (ti_newbuf_mini(sc, sc->ti_mini, NULL, dmamap)
			    == ENOBUFS) {
d1747 1
a1747 1
				ti_newbuf_mini(sc, sc->ti_mini, m, dmamap);
a1753 2
			dmamap = sc->ti_cdata.ti_rx_std_map[rxidx];
			sc->ti_cdata.ti_rx_std_map[rxidx] = 0;
d1756 1
a1756 1
				ti_newbuf_std(sc, sc->ti_std, m, dmamap);
d1759 1
a1759 2
			if (ti_newbuf_std(sc, sc->ti_std, NULL, dmamap)
			    == ENOBUFS) {
d1761 1
a1761 1
				ti_newbuf_std(sc, sc->ti_std, m, dmamap);
a1765 3
		if (m == NULL)
			panic("%s: couldn't get mbuf", sc->sc_dv.dv_xname);

d1812 1
a1812 52
void ti_txeof_tigon1(sc)
	struct ti_softc		*sc;
{
	struct ifnet		*ifp;
	struct ti_txmap_entry	*entry;
	int			active = 1;

	ifp = &sc->arpcom.ac_if;

	/*
	 * Go through our tx ring and free mbufs for those
	 * frames that have been sent.
	 */
	while (sc->ti_tx_saved_considx != sc->ti_tx_considx.ti_idx) {
		u_int32_t		idx = 0;
		struct ti_tx_desc	txdesc;

		idx = sc->ti_tx_saved_considx;
		ti_mem_read(sc, TI_TX_RING_BASE + idx * sizeof(txdesc),
			    sizeof(txdesc), (caddr_t)&txdesc);

		if (txdesc.ti_flags & TI_BDFLAG_END)
			ifp->if_opackets++;

		if (sc->ti_cdata.ti_tx_chain[idx] != NULL) {
			m_freem(sc->ti_cdata.ti_tx_chain[idx]);
			sc->ti_cdata.ti_tx_chain[idx] = NULL;

			entry = sc->ti_cdata.ti_tx_map[idx];
			bus_dmamap_sync(sc->sc_dmatag, entry->dmamap, 0,
			    entry->dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);

			bus_dmamap_unload(sc->sc_dmatag, entry->dmamap);
			SLIST_INSERT_HEAD(&sc->ti_tx_map_listhead, entry,
			    link);
			sc->ti_cdata.ti_tx_map[idx] = NULL;

		}
		sc->ti_txcnt--;
		TI_INC(sc->ti_tx_saved_considx, TI_TX_RING_CNT);
		ifp->if_timer = 0;

		active = 0;
	}

	if (!active)
		ifp->if_flags &= ~IFF_OACTIVE;

	return;
}

void ti_txeof_tigon2(sc)
a1816 1
	struct ti_txmap_entry	*entry;
d1828 16
a1843 2
		cur_tx = &sc->ti_rdata->ti_tx_ring[idx];

a1848 10

			entry = sc->ti_cdata.ti_tx_map[idx];
			bus_dmamap_sync(sc->sc_dmatag, entry->dmamap, 0,
			    entry->dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);

			bus_dmamap_unload(sc->sc_dmatag, entry->dmamap);
			SLIST_INSERT_HEAD(&sc->ti_tx_map_listhead, entry,
			    link);
			sc->ti_cdata.ti_tx_map[idx] = NULL;

d1883 1
a1883 4
		if (sc->ti_hwrev == TI_HWREV_TIGON)
			ti_txeof_tigon1(sc);
		else
			ti_txeof_tigon2(sc);
a1900 1
	struct ti_stats		*stats = &sc->ti_rdata->ti_info.ti_stats;
d1904 6
a1909 1
	TI_RING_DMASYNC(sc, ti_info.ti_stats, BUS_DMASYNC_POSTREAD);
d1911 1
a1911 7
	ifp->if_collisions += stats->dot3StatsSingleCollisionFrames +
		stats->dot3StatsMultipleCollisionFrames +
		stats->dot3StatsExcessiveCollisions +
		stats->dot3StatsLateCollisions -
		ifp->if_collisions;

	TI_RING_DMASYNC(sc, ti_info.ti_stats, BUS_DMASYNC_PREREAD);
d1918 1
a1918 1
int ti_encap_tigon1(sc, m_head, txidx)
d1923 2
a1925 4
	struct ti_txmap_entry	*entry;
	bus_dmamap_t		txmap;
	struct ti_tx_desc	txdesc;
	int			i = 0;
d1934 1
a1934 5
	entry = SLIST_FIRST(&sc->ti_tx_map_listhead);
	if (entry == NULL)
		return ENOBUFS;
	txmap = entry->dmamap;

d1942 23
a1964 14
	if (bus_dmamap_load_mbuf(sc->sc_dmatag, txmap, m_head,
	    BUS_DMA_NOWAIT))
		return(ENOBUFS);

	for (i = 0; i < txmap->dm_nsegs; i++) {
		if (sc->ti_cdata.ti_tx_chain[frag] != NULL)
			break;

		memset(&txdesc, 0, sizeof(txdesc));

		TI_HOSTADDR(txdesc.ti_addr) = txmap->dm_segs[i].ds_addr;
		txdesc.ti_len = txmap->dm_segs[i].ds_len & 0xffff;

		txdesc.ti_flags = 0;
d1966 16
a1981 3
		if (ifv != NULL) {
			txdesc.ti_flags |= TI_BDFLAG_VLAN_TAG;
			txdesc.ti_vlan_tag = ifv->ifv_tag & 0xfff;
a1982 14
#endif

		ti_mem_write(sc, TI_TX_RING_BASE + frag * sizeof(txdesc),
			     sizeof(txdesc), (caddr_t)&txdesc);

		/*
		 * Sanity check: avoid coming within 16 descriptors
		 * of the end of the ring.
		 */
		if ((TI_TX_RING_CNT - (sc->ti_txcnt + cnt)) < 16)
			return(ENOBUFS);
		cur = frag;
		TI_INC(frag, TI_TX_RING_CNT);
		cnt++;
d1985 1
a1985 56
	if (frag == sc->ti_tx_saved_considx)
		return(ENOBUFS);

	txdesc.ti_flags |= TI_BDFLAG_END;
	ti_mem_write(sc, TI_TX_RING_BASE + cur * sizeof(txdesc),
		     sizeof(txdesc), (caddr_t)&txdesc);

	bus_dmamap_sync(sc->sc_dmatag, txmap, 0, txmap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	sc->ti_cdata.ti_tx_chain[cur] = m_head;
	SLIST_REMOVE_HEAD(&sc->ti_tx_map_listhead, link);
	sc->ti_cdata.ti_tx_map[cur] = entry;
	sc->ti_txcnt += cnt;

	*txidx = frag;

	return(0);
}

/*
 * Encapsulate an mbuf chain in the tx ring  by coupling the mbuf data
 * pointers to descriptors.
 */
int ti_encap_tigon2(sc, m_head, txidx)
	struct ti_softc		*sc;
	struct mbuf		*m_head;
	u_int32_t		*txidx;
{
	struct ti_tx_desc	*f = NULL;
	u_int32_t		frag, cur, cnt = 0;
	struct ti_txmap_entry	*entry;
	bus_dmamap_t		txmap;
	int			i = 0;
#if NVLAN > 0
	struct ifvlan		*ifv = NULL;

	if ((m_head->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&
	    m_head->m_pkthdr.rcvif != NULL)
		ifv = m_head->m_pkthdr.rcvif->if_softc;
#endif

	entry = SLIST_FIRST(&sc->ti_tx_map_listhead);
	if (entry == NULL)
		return ENOBUFS;
	txmap = entry->dmamap;

	cur = frag = *txidx;

	/*
 	 * Start packing the mbufs in this chain into
	 * the fragment pointers. Stop when we run out
 	 * of fragments or hit the end of the mbuf chain.
	 */
	if (bus_dmamap_load_mbuf(sc->sc_dmatag, txmap, m_head,
	    BUS_DMA_NOWAIT))
a1987 28
	for (i = 0; i < txmap->dm_nsegs; i++) {
		f = &sc->ti_rdata->ti_tx_ring[frag];

		if (sc->ti_cdata.ti_tx_chain[frag] != NULL)
			break;

		TI_HOSTADDR(f->ti_addr) = txmap->dm_segs[i].ds_addr;
		f->ti_len = txmap->dm_segs[i].ds_len & 0xffff;
		f->ti_flags = 0;
#if NVLAN > 0
		if (ifv != NULL) {
			f->ti_flags |= TI_BDFLAG_VLAN_TAG;
			f->ti_vlan_tag = ifv->ifv_tag & 0xfff;
		} else {
			f->ti_vlan_tag = 0;
		}
#endif
		/*
		 * Sanity check: avoid coming within 16 descriptors
		 * of the end of the ring.
		 */
		if ((TI_TX_RING_CNT - (sc->ti_txcnt + cnt)) < 16)
			return(ENOBUFS);
		cur = frag;
		TI_INC(frag, TI_TX_RING_CNT);
		cnt++;
	}

d1991 5
a1995 7
	sc->ti_rdata->ti_tx_ring[cur].ti_flags |= TI_BDFLAG_END;

	bus_dmamap_sync(sc->sc_dmatag, txmap, 0, txmap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	TI_RING_DMASYNC(sc, ti_tx_ring[cur], BUS_DMASYNC_POSTREAD);

a1996 2
	SLIST_REMOVE_HEAD(&sc->ti_tx_map_listhead, link);
	sc->ti_cdata.ti_tx_map[cur] = entry;
d2014 1
a2014 1
	int			pkts = 0, error;
d2030 1
a2030 6
		if (sc->ti_hwrev == TI_HWREV_TIGON)
			error = ti_encap_tigon1(sc, m_head, &prodidx);
		else
			error = ti_encap_tigon2(sc, m_head, &prodidx);

		if (error) {
d2199 1
a2199 1
	case IFM_1000_T:
d2257 1
a2257 1
			ifmr->ifm_active |= IFM_1000_T;
d2412 1
a2412 1
	ti_mem_set(sc, 0x2000, 0x100000 - 0x2000);
@


1.31
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.30 2001/09/11 20:05:25 miod Exp $	*/
d2123 2
a2124 1
	ti_init_rx_ring_std(sc);
@


1.30
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.29 2001/08/25 10:13:29 art Exp $	*/
d113 1
a113 1
#include <vm/vm.h>              /* for vtophys */
@


1.29
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.28 2001/08/12 20:03:49 mickey Exp $	*/
a113 1
#include <vm/vm_kern.h>
@


1.28
log
@remove redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.27 2001/07/03 03:32:11 jason Exp $	*/
d1506 1
a1506 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.27
log
@enable rx ip checksum offload
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.26 2001/07/03 02:43:16 jason Exp $	*/
a113 1
#include <vm/pmap.h>            /* for vtophys */
a114 1
#include <vm/vm_extern.h>
@


1.26
log
@From FreeBSD:
mask off high order part of vlan tag (the non-tag parts)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.25 2001/06/27 06:34:49 kjc Exp $	*/
d720 1
a720 5
#ifdef TI_CSUM_OFFLOAD
	r->ti_flags = TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;
#else
	r->ti_flags = 0;
#endif
d758 1
a758 4
	r->ti_flags = TI_BDFLAG_MINI_RING;
#ifdef TI_CSUM_OFFLOAD
	r->ti_flags |= TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;
#endif
d817 1
a817 4
	r->ti_flags = TI_BDFLAG_JUMBO_RING;
#ifdef TI_CSUM_OFFLOAD
	r->ti_flags |= TI_BDFLAG_TCP_UDP_CKSUM|TI_BDFLAG_IP_CKSUM;
#endif
d1240 1
a1240 1
	 * errors.
d1242 1
a1242 1
#ifndef TI_CSUM_OFFLOAD
d1323 1
a1323 3
#ifdef TI_CSUM_OFFLOAD
	rcb->ti_flags |= TI_RCB_FLAG_TCP_UDP_CKSUM|TI_RCB_FLAG_IP_CKSUM;
#endif
d1334 1
a1334 3
#ifdef TI_CSUM_OFFLOAD
	rcb->ti_flags |= TI_RCB_FLAG_TCP_UDP_CKSUM|TI_RCB_FLAG_IP_CKSUM;
#endif
d1352 1
a1352 3
#ifdef TI_CSUM_OFFLOAD
	rcb->ti_flags |= TI_RCB_FLAG_TCP_UDP_CKSUM|TI_RCB_FLAG_IP_CKSUM;
#endif
d1389 1
d1705 1
d1778 6
a1783 6
#ifdef TI_CSUM_OFFLOAD
		ip = (struct ip *)(mtod(m, caddr_t) + ETHER_HDR_LEN);
		if (!(cur_rx->ti_tcp_udp_cksum ^ 0xFFFF) &&
		    !(ip->ip_off & htons(IP_MF | IP_OFFMASK | IP_RF)))
			m->m_flags |= M_HWCKSUM;
#endif
@


1.25
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.24 2001/06/27 05:44:55 nate Exp $	*/
d1732 1
a1732 1
			vlan_tag = cur_rx->ti_vlan_tag;
d1982 1
a1982 1
				f->ti_vlan_tag = ifv->ifv_tag;
@


1.24
log
@recieve -> receive
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.23 2001/06/24 22:58:01 fgsch Exp $	*/
d1646 2
a1647 1
	ifp->if_snd.ifq_maxlen = TI_TX_RING_CNT - 1;
d1905 1
a1905 1
	if (ifp->if_flags & IFF_RUNNING && ifp->if_snd.ifq_head != NULL)
d2028 1
d2035 1
a2035 1
		IF_DEQUEUE(&ifp->if_snd, m_head);
a2044 1
			IF_PREPEND(&ifp->if_snd, m_head);
d2049 4
d2062 2
@


1.23
log
@- vlan_input_tag() takes 2 args now.
- use ether_input_mbuf().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.22 2001/06/24 20:27:00 fgsch Exp $	*/
d1699 1
a1699 1
 * 2) the frame is from the jumbo recieve ring
@


1.22
log
@more ether_input_mbuf() conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.21 2001/06/18 19:19:41 deraadt Exp $	*/
a1790 3
		/* Remove header from mbuf and pass it on. */
		m_adj(m, sizeof(struct ether_header));

d1792 1
a1792 1
		ip = mtod(m, struct ip *);
d1804 1
a1804 4
			struct ether_header *eh;

			eh = mtod(m, struct ether_header *);
			if (vlan_input_tag(eh, m, vlan_tag) < 0)
@


1.21
log
@move microcode
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.20 2001/05/17 18:41:46 provos Exp $	*/
a1713 1
		struct ether_header	*eh;
a1780 1
		eh = mtod(m, struct ether_header *);
d1807 3
d1816 1
a1816 1
		ether_input(ifp, eh, m);
@


1.20
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.19 2001/05/07 18:48:31 jason Exp $	*/
d124 2
a125 2
#include <dev/pci/ti_fw.h>
#include <dev/pci/ti_fw2.h>
@


1.19
log
@Now that if_vlan switches types to match it's parent, checking if_type
to see if it's IFT_8021Q_VLAN is no longer valid ; change test to M_PROTO1
being set and rcvif not being null.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.18 2001/03/28 04:11:34 jason Exp $	*/
d169 1
a169 2
void ti_jfree		__P((struct mbuf *));
void ti_jref		__P((struct mbuf *));
a642 35
 * Adjust usage count on a jumbo buffer. In general this doesn't
 * get used much because our jumbo buffers don't get passed around
 * too much, but it's implemented for correctness.
 */
void
ti_jref(m)
	struct mbuf *m;
{
	caddr_t buf = m->m_ext.ext_buf;
	u_int size = m->m_ext.ext_size;
	struct ti_softc *sc;
	register int i;

	/* Extract the softc struct pointer. */
	sc = (struct ti_softc *)m->m_ext.ext_handle;

	if (sc == NULL)
		panic("ti_jref: can't find softc pointer!");

	if (size != TI_JUMBO_FRAMELEN)
		panic("ti_jref: adjusting refcount of buf of wrong size!");

	/* calculate the slot this buffer belongs to */
	i = ((vaddr_t)buf - (vaddr_t)sc->ti_cdata.ti_jumbo_buf) / TI_JLEN;

	if ((i < 0) || (i >= TI_JSLOTS))
		panic("ti_jref: asked to reference buffer "
		    "that we don't manage!");
	else if (sc->ti_cdata.ti_jslots[i].ti_inuse == 0)
		panic("ti_jref: buffer already free!");
	else
		sc->ti_cdata.ti_jslots[i].ti_inuse++;
}

/*
d646 4
a649 2
ti_jfree(m)
	struct mbuf *m;
a650 2
	caddr_t buf = m->m_ext.ext_buf;
	u_int size = m->m_ext.ext_size;
d656 1
a656 1
	sc = (struct ti_softc *)m->m_ext.ext_handle;
a660 3
	if (size != TI_JUMBO_FRAMELEN)
		panic("ti_jfree: freeing buffer of wrong size!");

d810 2
a811 1
		m_new->m_ext.ext_ref = ti_jref;
a816 2

	m_new->m_ext.ext_handle = sc;
@


1.18
log
@uncomment and use code to determine whether we interrupted or not
correct comment typo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.17 2001/03/22 16:30:13 niklas Exp $	*/
d1988 1
a1988 2
	    m_head->m_pkthdr.rcvif != NULL &&
	    m_head->m_pkthdr.rcvif->if_type == IFT_8021_VLAN)
@


1.17
log
@Longstanding multicast bug causing eternal looping, unveiled by a recent commit
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.16 2001/03/14 20:11:39 jason Exp $	*/
d1597 1
a1597 1
	 * the NIC). This means the MAC address is actually preceeded
a1923 1
	int			claimed = 0;
d1928 1
a1928 2
#ifdef notdef
	/* Avoid this for now -- checking this register is expensive. */
d1931 1
a1931 2
		return;
#endif
a1936 2
		claimed = 1;

d1952 1
a1952 1
	return (claimed);
@


1.16
log
@Follow openbsd model for multicast ioctl handling
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.15 2001/02/20 19:39:43 mickey Exp $	*/
d1130 1
@


1.15
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.14 2000/11/21 03:50:48 jason Exp $	*/
d2407 7
a2413 2
		if (ifp->if_flags & IFF_RUNNING) {
			ti_setmulti(sc);
@


1.14
log
@From FreeBSD:
add support for the acenic copper and netgear ga620t (untested).
This also updates the firmware to 12.4.13 for tigon 1, and
12.4.11+wpaul hacks for tigon 2
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.13 2000/09/19 08:44:46 niklas Exp $	*/
a1721 5

#if NBPFILTER > 0
	bpfattach(&sc->arpcom.ac_if.if_bpf, ifp,
	    DLT_EN10MB, sizeof(struct ether_header));
#endif
@


1.13
log
@trailing spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.12 2000/04/26 19:05:28 chris Exp $	*/
d920 1
a920 1
	for (i = 0; i < (TI_JSLOTS - 20); i++) {
d1491 2
a1492 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETGEAR_GA620)
d1496 2
a1497 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALTEON_ACENIC)
d1653 15
d1690 24
a1713 6
	ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_FL, 0, NULL);
	ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_FL|IFM_FDX, 0, NULL);
	ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_FX, 0, NULL);
	ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_FX|IFM_FDX, 0, NULL);
	ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_1000_SX, 0, NULL);
	ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_1000_SX|IFM_FDX, 0, NULL);
d2260 1
d2262 1
a2262 1
		    TI_GLNK_FULL_DUPLEX|TI_GLNK_RX_FLOWCTL_Y|TI_GLNK_ENB);
d2264 3
d2272 2
d2276 2
a2277 1
		if (IFM_SUBTYPE(ifm->ifm_media) == IFM_100_FX) {
d2303 1
d2315 11
a2325 4
	if (sc->ti_linkstat == TI_EV_CODE_GIG_LINK_UP)
		ifmr->ifm_active |= IFM_1000_SX|IFM_FDX;
	else if (sc->ti_linkstat == TI_EV_CODE_LINK_UP) {
		u_int32_t		media;
d2327 11
a2337 4
		if (media & TI_LNK_100MB)
			ifmr->ifm_active |= IFM_100_FX;
		if (media & TI_LNK_10MB)
			ifmr->ifm_active |= IFM_10_FL;
@


1.12
log
@Fix for if_vlan (FreeBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.11 2000/02/15 03:54:29 jason Exp $	*/
d41 1
a41 1
 * 
d603 1
a603 1
		entry = malloc(sizeof(struct ti_jpool_entry), 
d629 1
a629 1
	
d631 1
a631 1
	
d715 1
a715 1
			LIST_INSERT_HEAD(&sc->ti_jfree_listhead, 
d1261 3
a1263 3
	 * for DMA reads.  Our highest limit is 1K bytes.  This is a 
	 * restriction on some ALPHA platforms with early revision 
	 * 21174 PCI chipsets, such as the AlphaPC 164lx 
d2286 1
a2286 1
	
@


1.11
log
@undo previous, temporarily
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.10 2000/02/15 02:28:15 jason Exp $	*/
d1818 2
a1819 1
			vlan_input_tag(eh, m, vlan_tag);
@


1.10
log
@make sure to call ether_{add,del}multi() as appropriate in xxx_ioctl()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.9 2000/01/18 05:26:25 jason Exp $	*/
d2295 2
a2296 2
	struct ifreq		*ifr = (struct ifreq *) data;
	struct ifaddr		*ifa = (struct ifaddr *) data;
d2354 1
a2354 9
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
@


1.9
log
@sync with FreeBSD: add Farallon PN9000SX as a match
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.8 1999/10/28 03:26:33 jason Exp $	*/
d2354 9
a2362 1
		if (ifp->if_flags & IFF_RUNNING) {
@


1.9.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.11 2000/02/15 03:54:29 jason Exp $	*/
d2295 2
a2296 2
	struct ifreq		*ifr = (struct ifreq *)data;
	struct ifaddr		*ifa = (struct ifaddr *)data;
@


1.9.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.18 2001/03/28 04:11:34 jason Exp $	*/
d41 1
a41 1
 *
d603 1
a603 1
		entry = malloc(sizeof(struct ti_jpool_entry),
d629 1
a629 1

d631 1
a631 1

d715 1
a715 1
			LIST_INSERT_HEAD(&sc->ti_jfree_listhead,
d920 1
a920 1
	for (i = 0; i < TI_JUMBO_RX_RING_CNT; i++) {
a1129 1
		ETHER_NEXT_MULTI(step, enm);
d1261 3
a1263 3
	 * for DMA reads.  Our highest limit is 1K bytes.  This is a
	 * restriction on some ALPHA platforms with early revision
	 * 21174 PCI chipsets, such as the AlphaPC 164lx
d1491 1
a1491 2
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETGEAR_GA620 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETGEAR_GA620T))
d1495 1
a1495 2
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALTEON_ACENIC ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALTEON_ACENICT))
d1594 1
a1594 1
	 * the NIC). This means the MAC address is actually preceded
a1650 15
	/*
	 * We really need a better way to tell a 1000baseTX card
	 * from a 1000baseSX one, since in theory there could be
	 * OEMed 1000baseTX cards from lame vendors who aren't
	 * clever enough to change the PCI ID. For the moment
	 * though, the AceNIC is the only copper card available.
	 */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ALTEON &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALTEON_ACENICT)
		sc->ti_copper = 1;
	/* Ok, it's not the only copper card available */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_NETGEAR &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETGEAR_GA620T)
		sc->ti_copper = 1;

d1673 6
a1678 24
	if (sc->ti_copper) {
		/*
		 * Copper cards allow manual 10/100 mode selection,
		 * but not manual 1000baseTX mode selection. Why?
		 * Becuase currently there's no way to specify the
		 * master/slave setting through the firmware interface,
		 * so Alteon decided to just bag it and handle it
		 * via autonegotiation.
		 */
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);
		ifmedia_add(&sc->ifmedia,
		    IFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_TX, 0, NULL);
		ifmedia_add(&sc->ifmedia,
		    IFM_ETHER|IFM_100_TX|IFM_FDX, 0, NULL);
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_1000_TX, 0, NULL);
		ifmedia_add(&sc->ifmedia,
		    IFM_ETHER|IFM_1000_TX|IFM_FDX, 0, NULL);
	} else {
		/* Fiber cards don't support 10/100 modes. */
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_1000_SX, 0, NULL);
		ifmedia_add(&sc->ifmedia,
		    IFM_ETHER|IFM_1000_SX|IFM_FDX, 0, NULL);
	}
d1688 5
d1818 1
a1818 2
			if (vlan_input_tag(eh, m, vlan_tag) < 0)
				ifp->if_data.ifi_noproto++;
d1892 1
d1897 2
a1898 1
	/* XXX checking this register is expensive. */
d1901 2
a1902 1
		return (0);
d1908 2
d1925 1
a1925 1
	return (1);
a2223 1
	case IFM_1000_TX:
d2225 1
a2225 1
		    TI_GLNK_RX_FLOWCTL_Y|TI_GLNK_ENB);
a2226 3
		if ((ifm->ifm_media & IFM_GMASK) == IFM_FDX) {
			TI_SETBIT(sc, TI_GCR_GLINK, TI_GLNK_FULL_DUPLEX);
		}
a2231 2
	case IFM_100_TX:
	case IFM_10_T:
d2234 1
a2234 2
		if (IFM_SUBTYPE(ifm->ifm_media) == IFM_100_FX ||
		    IFM_SUBTYPE(ifm->ifm_media) == IFM_100_TX) {
a2259 1
	u_int32_t		media = 0;
d2271 4
a2274 11
	if (sc->ti_linkstat == TI_EV_CODE_GIG_LINK_UP) {
		media = CSR_READ_4(sc, TI_GCR_GLINK_STAT);
		if (sc->ti_copper)
			ifmr->ifm_active |= IFM_1000_TX;
		else
			ifmr->ifm_active |= IFM_1000_SX;
		if (media & TI_GLNK_FULL_DUPLEX)
			ifmr->ifm_active |= IFM_FDX;
		else
			ifmr->ifm_active |= IFM_HDX;
	} else if (sc->ti_linkstat == TI_EV_CODE_LINK_UP) {
d2276 4
a2279 11
		if (sc->ti_copper) {
			if (media & TI_LNK_100MB)
				ifmr->ifm_active |= IFM_100_TX;
			if (media & TI_LNK_10MB)
				ifmr->ifm_active |= IFM_10_T;
		} else {
			if (media & TI_LNK_100MB)
				ifmr->ifm_active |= IFM_100_FX;
			if (media & TI_LNK_10MB)
				ifmr->ifm_active |= IFM_10_FL;
		}
d2285 1
a2285 1

d2354 2
a2355 7
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			if (ifp->if_flags & IFF_RUNNING)
				ti_setmulti(sc);
@


1.9.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.9.2.2 2001/05/14 22:25:47 niklas Exp $	*/
d124 2
a125 2
#include <dev/microcode/tigon/ti_fw.h>
#include <dev/microcode/tigon/ti_fw2.h>
d169 2
a170 1
void ti_jfree		__P((caddr_t, u_int, void *));
d644 35
d682 2
a683 4
ti_jfree(buf, size, arg)
	caddr_t			buf;
	u_int			size;
	void *arg;
d685 2
d692 1
a692 1
	sc = (struct ti_softc *)arg;
d697 3
d849 1
a849 2
		m_new->m_ext.ext_arg = sc;
		MCLINITREFERENCE(m_new);
d856 2
d1686 1
a1686 2
	IFQ_SET_MAXLEN(&ifp->if_snd, TI_TX_RING_CNT - 1);
	IFQ_SET_READY(&ifp->if_snd);
d1739 1
a1739 1
 * 2) the frame is from the jumbo receive ring
d1754 1
d1822 1
d1833 3
d1837 1
a1837 1
		ip = (struct ip *)(mtod(m, caddr_t) + ETHER_HDR_LEN);
d1849 1
a1849 1
			if (vlan_input_tag(m, vlan_tag) < 0)
d1855 1
a1855 1
		ether_input_mbuf(ifp, m);
d1949 1
a1949 1
	if (ifp->if_flags & IFF_RUNNING && !IFQ_IS_EMPTY(&ifp->if_snd))
d1988 2
a1989 1
	    m_head->m_pkthdr.rcvif != NULL)
a2072 1
	int			pkts = 0;
d2079 1
a2079 1
		IFQ_POLL(&ifp->if_snd, m_head);
d2089 1
a2093 4
		/* now we are committed to transmit the packet */
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
		pkts++;

a2102 2
	if (pkts == 0)
		return;
@


1.9.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.9.2.3 2001/07/04 10:42:23 niklas Exp $	*/
d114 3
d720 5
a724 1
	r->ti_flags = TI_BDFLAG_IP_CKSUM;
d762 4
a765 1
	r->ti_flags = TI_BDFLAG_MINI_RING | TI_BDFLAG_IP_CKSUM;
d824 4
a827 1
	r->ti_flags = TI_BDFLAG_JUMBO_RING | TI_BDFLAG_IP_CKSUM;
d1250 1
a1250 1
	 * errors.  This is not compatible with hardware checksums.
d1252 1
a1252 1
#if 0
d1333 3
a1335 1
	rcb->ti_flags |= TI_RCB_FLAG_IP_CKSUM | TI_RCB_FLAG_NO_PHDR_CKSUM;
d1346 3
a1348 1
	rcb->ti_flags |= TI_RCB_FLAG_IP_CKSUM | TI_RCB_FLAG_NO_PHDR_CKSUM;
d1366 3
a1368 1
	rcb->ti_flags |= TI_RCB_FLAG_IP_CKSUM | TI_RCB_FLAG_NO_PHDR_CKSUM;
a1404 1
	rcb->ti_flags |= TI_RCB_FLAG_IP_CKSUM | TI_RCB_FLAG_NO_PHDR_CKSUM;
d1523 2
a1524 1
	if (pci_intr_map(pa, &ih)) {
a1719 1
		int			sumflags = 0;
d1732 1
a1732 1
			vlan_tag = cur_rx->ti_vlan_tag & 0xfff;
d1792 6
a1797 6
		if ((cur_rx->ti_ip_cksum ^ 0xffff) == 0)
			sumflags |= M_IPV4_CSUM_IN_OK;
		else
			sumflags |= M_IPV4_CSUM_IN_BAD;
		m->m_pkthdr.csum = sumflags;
		sumflags = 0;
d1982 1
a1982 1
				f->ti_vlan_tag = ifv->ifv_tag & 0xfff;
@


1.9.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d113 1
a113 1
#include <uvm/uvm_extern.h>              /* for vtophys */
@


1.9.2.6
log
@Merge in trunk
@
text
@a1073 2
		if (mc == NULL)
			panic("ti_setmulti");
d2123 1
a2123 2
	if (ti_init_rx_ring_std(sc) == ENOBUFS)
		panic("not enough mbufs for rx ring");
d2365 1
a2365 1
	splx(s);
@


1.9.2.7
log
@Merge in -current from roughly a week ago
@
text
@d130 2
a131 2
int ti_probe(struct device *, void *, void *);
void ti_attach(struct device *, struct device *, void *);
d133 2
a134 2
void ti_txeof(struct ti_softc *);
void ti_rxeof(struct ti_softc *);
d136 2
a137 2
void ti_stats_update(struct ti_softc *);
int ti_encap(struct ti_softc *, struct mbuf *, u_int32_t *);
d139 43
a181 43
int ti_intr(void *);
void ti_start(struct ifnet *);
int ti_ioctl(struct ifnet *, u_long, caddr_t);
void ti_init(void *);
void ti_init2(struct ti_softc *);
void ti_stop(struct ti_softc *);
void ti_watchdog(struct ifnet *);
void ti_shutdown(void *);
int ti_ifmedia_upd(struct ifnet *);
void ti_ifmedia_sts(struct ifnet *, struct ifmediareq *);

u_int32_t ti_eeprom_putbyte(struct ti_softc *, int);
u_int8_t ti_eeprom_getbyte(struct ti_softc *, int, u_int8_t *);
int ti_read_eeprom(struct ti_softc *, caddr_t, int, int);

void ti_add_mcast(struct ti_softc *, struct ether_addr *);
void ti_del_mcast(struct ti_softc *, struct ether_addr *);
void ti_setmulti(struct ti_softc *);

void ti_mem(struct ti_softc *, u_int32_t, u_int32_t, caddr_t);
void ti_loadfw(struct ti_softc *);
void ti_cmd(struct ti_softc *, struct ti_cmd_desc *);
void ti_cmd_ext(struct ti_softc *, struct ti_cmd_desc *,
    caddr_t, int);
void ti_handle_events(struct ti_softc *);
int ti_alloc_jumbo_mem(struct ti_softc *);
void *ti_jalloc(struct ti_softc *);
void ti_jfree(caddr_t, u_int, void *);
int ti_newbuf_std(struct ti_softc *, int, struct mbuf *);
int ti_newbuf_mini(struct ti_softc *, int, struct mbuf *);
int ti_newbuf_jumbo(struct ti_softc *, int, struct mbuf *);
int ti_init_rx_ring_std(struct ti_softc *);
void ti_free_rx_ring_std(struct ti_softc *);
int ti_init_rx_ring_jumbo(struct ti_softc *);
void ti_free_rx_ring_jumbo(struct ti_softc *);
int ti_init_rx_ring_mini(struct ti_softc *);
void ti_free_rx_ring_mini(struct ti_softc *);
void ti_free_tx_ring(struct ti_softc *);
int ti_init_tx_ring(struct ti_softc *);

int ti_64bitslot_war(struct ti_softc *);
int ti_chipinit(struct ti_softc *);
int ti_gibinit(struct ti_softc *);
@


1.9.2.8
log
@Sync the SMP branch with 3.3
@
text
@a83 1
#include "vlan.h"
d113 2
a114 4
#if NVLAN > 0
#include <net/if_types.h>
#include <net/if_vlan_var.h>
#endif
d133 1
a133 2
void ti_txeof_tigon1(struct ti_softc *);
void ti_txeof_tigon2(struct ti_softc *);
d137 1
a137 2
int ti_encap_tigon1(struct ti_softc *, struct mbuf *, u_int32_t *);
int ti_encap_tigon2(struct ti_softc *, struct mbuf *, u_int32_t *);
d158 1
a158 3
void ti_mem_read(struct ti_softc *, u_int32_t, u_int32_t, void *);
void ti_mem_write(struct ti_softc *, u_int32_t, u_int32_t, const void*);
void ti_mem_set(struct ti_softc *, u_int32_t, u_int32_t);
d167 2
a168 2
int ti_newbuf_std(struct ti_softc *, int, struct mbuf *, bus_dmamap_t);
int ti_newbuf_mini(struct ti_softc *, int, struct mbuf *, bus_dmamap_t);
d190 1
a190 1
	int		i, ack = 0;
d198 1
a198 1
	 * Feed in each bit and strobe the clock.
d237 1
a237 1
	int		i;
d326 2
a327 2
 * NIC memory read function.
 * Can be used to copy data from NIC local memory.
d329 1
a329 1
void ti_mem_read(sc, addr, len, buf)
d332 1
a332 1
	void			*buf;
d335 1
a335 1
	caddr_t			ptr;
d339 1
d348 8
a355 4
		bus_space_read_region_4(sc->ti_btag, sc->ti_bhandle,
		    TI_WINDOW + (segptr & (TI_WINLEN - 1)), (u_int32_t *)ptr,
		    segsize / 4);
		ptr += segsize;
a358 1
}
d360 1
a360 55
/*
 * NIC memory write function.
 * Can be used to copy data into  NIC local memory.
 */
void ti_mem_write(sc, addr, len, buf)
	struct ti_softc		*sc;
	u_int32_t		addr, len;
	const void		*buf;
{
	int			segptr, segsize, cnt;
	const char		*ptr;

	segptr = addr;
	cnt = len;
	ptr = buf;

	while(cnt) {
		if (cnt < TI_WINLEN)
			segsize = cnt;
		else
			segsize = TI_WINLEN - (segptr % TI_WINLEN);
		CSR_WRITE_4(sc, TI_WINBASE, (segptr & ~(TI_WINLEN - 1)));
		bus_space_write_region_4(sc->ti_btag, sc->ti_bhandle,
		    TI_WINDOW + (segptr & (TI_WINLEN - 1)), (u_int32_t *)ptr,
		    segsize / 4);
		ptr += segsize;
		segptr += segsize;
		cnt -= segsize;
	}
}

/*
 * NIC memory write function.
 * Can be used to clear a section of NIC local memory.
 */
void ti_mem_set(sc, addr, len)
	struct ti_softc		*sc;
	u_int32_t		addr, len;
{
	int			segptr, segsize, cnt;

	segptr = addr;
	cnt = len;

	while(cnt) {
		if (cnt < TI_WINLEN)
			segsize = cnt;
		else
			segsize = TI_WINLEN - (segptr % TI_WINLEN);
		CSR_WRITE_4(sc, TI_WINBASE, (segptr & ~(TI_WINLEN - 1)));
		bus_space_set_region_4(sc->ti_btag, sc->ti_bhandle,
		    TI_WINDOW + (segptr & (TI_WINLEN - 1)), 0, segsize / 4);
		segptr += segsize;
		cnt -= segsize;
	}
d383 1
a383 1
		ti_mem_write(sc, tigonFwTextAddr, tigonFwTextLen,
d385 1
a385 1
		ti_mem_write(sc, tigonFwDataAddr, tigonFwDataLen,
d387 1
a387 1
		ti_mem_write(sc, tigonFwRodataAddr, tigonFwRodataLen,
d389 2
a390 2
		ti_mem_set(sc, tigonFwBssAddr, tigonFwBssLen);
		ti_mem_set(sc, tigonFwSbssAddr, tigonFwSbssLen);
d404 1
a404 1
		ti_mem_write(sc, tigon2FwTextAddr, tigon2FwTextLen,
d406 1
a406 1
		ti_mem_write(sc, tigon2FwDataAddr, tigon2FwDataLen,
d408 1
a408 1
		ti_mem_write(sc, tigon2FwRodataAddr, tigon2FwRodataLen,
d410 2
a411 2
		ti_mem_set(sc, tigon2FwBssAddr, tigon2FwBssLen);
		ti_mem_set(sc, tigon2FwSbssAddr, tigon2FwSbssLen);
d432 3
d455 4
a458 1
	int		i;
d487 1
a487 1
		switch (TI_EVENT_EVENT(e)) {
d489 1
a489 1
			sc->ti_linkstat = TI_EVENT_CODE(e);
d492 1
a492 1
			if (TI_EVENT_CODE(e) == TI_EV_CODE_ERR_INVAL_CMD)
d495 1
a495 1
			else if (TI_EVENT_CODE(e) == TI_EV_CODE_ERR_UNIMP_CMD)
d498 1
a498 1
			else if (TI_EVENT_CODE(e) == TI_EV_CODE_ERR_BADCFG)
d513 2
a514 2
			printf("%s: unknown event: %d\n", sc->sc_dv.dv_xname,
			       TI_EVENT_EVENT(e));
d553 1
d570 2
a571 2
	if (bus_dmamap_create(sc->sc_dmatag, TI_JMEM, 1, TI_JMEM, 0,
	    BUS_DMA_NOWAIT, &sc->ti_cdata.ti_rx_jumbo_map)) {
d577 2
a578 2
	if (bus_dmamap_load(sc->sc_dmatag, sc->ti_cdata.ti_rx_jumbo_map, kva,
	    TI_JMEM, NULL, BUS_DMA_NOWAIT)) {
d580 1
a580 2
		bus_dmamap_destroy(sc->sc_dmatag,
				   sc->ti_cdata.ti_rx_jumbo_map);
d587 2
a588 2
	SLIST_INIT(&sc->ti_jfree_listhead);
	SLIST_INIT(&sc->ti_jinuse_listhead);
d602 2
a603 4
			bus_dmamap_unload(sc->sc_dmatag,
					  sc->ti_cdata.ti_rx_jumbo_map);
			bus_dmamap_destroy(sc->sc_dmatag,
					   sc->ti_cdata.ti_rx_jumbo_map);
d612 1
a612 1
		SLIST_INSERT_HEAD(&sc->ti_jfree_listhead, entry, jpool_entries);
d626 1
a626 1
	entry = SLIST_FIRST(&sc->ti_jfree_listhead);
d633 2
a634 2
	SLIST_REMOVE_HEAD(&sc->ti_jinuse_listhead, jpool_entries);
	SLIST_INSERT_HEAD(&sc->ti_jinuse_listhead, entry, jpool_entries);
d648 3
a650 3
	struct ti_softc		*sc;
	int			i;
	struct ti_jpool_entry	*entry;
d665 11
a675 10

	sc->ti_cdata.ti_jslots[i].ti_inuse--;
	if(sc->ti_cdata.ti_jslots[i].ti_inuse == 0) {
		entry = SLIST_FIRST(&sc->ti_jinuse_listhead);
		if (entry == NULL)
			panic("ti_jfree: buffer not in use!");
		entry->slot = i;
		SLIST_REMOVE_HEAD(&sc->ti_jinuse_listhead, jpool_entries);
		SLIST_INSERT_HEAD(&sc->ti_jfree_listhead,
				  entry, jpool_entries);
d682 1
a682 1
int ti_newbuf_std(sc, i, m, dmamap)
a685 1
	bus_dmamap_t		dmamap;
a689 14
	if (dmamap == NULL) {
		/* if (m) panic() */

		if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, 1, MCLBYTES,
				      0, BUS_DMA_NOWAIT, &dmamap)) {
			printf("%s: can't create recv map\n",
			       sc->sc_dv.dv_xname);
			return(ENOMEM);
		}
	} else if (m == NULL)
		bus_dmamap_unload(sc->sc_dmatag, dmamap);

	sc->ti_cdata.ti_rx_std_map[i] = dmamap;

a705 7

		m_adj(m_new, ETHER_ALIGN);

		if (bus_dmamap_load_mbuf(sc->sc_dmatag, dmamap, m_new,
					 BUS_DMA_NOWAIT))
			return(ENOBUFS);

a709 1
		m_adj(m_new, ETHER_ALIGN);
d712 1
d715 1
a715 1
	TI_HOSTADDR(r->ti_addr) = dmamap->dm_segs[0].ds_addr;
d718 1
a718 1
	r->ti_len = dmamap->dm_segs[0].ds_len;
a720 5
	if ((dmamap->dm_segs[0].ds_addr & ~(MCLBYTES - 1)) !=
	    ((dmamap->dm_segs[0].ds_addr + dmamap->dm_segs[0].ds_len - 1) & 
	     ~(MCLBYTES - 1)))
	    panic("overwritten!!!");

d728 1
a728 1
int ti_newbuf_mini(sc, i, m, dmamap)
a731 1
	bus_dmamap_t		dmamap;
a735 14
	if (dmamap == NULL) {
		/* if (m) panic() */

		if (bus_dmamap_create(sc->sc_dmatag, MHLEN, 1, MHLEN,
				      0, BUS_DMA_NOWAIT, &dmamap)) {
			printf("%s: can't create recv map\n",
			       sc->sc_dv.dv_xname);
			return(ENOMEM);
		}
	} else if (m == NULL)
		bus_dmamap_unload(sc->sc_dmatag, dmamap);

	sc->ti_cdata.ti_rx_mini_map[i] = dmamap;

a743 6
		m_adj(m_new, ETHER_ALIGN);

		if (bus_dmamap_load_mbuf(sc->sc_dmatag, dmamap, m_new,
					 BUS_DMA_NOWAIT))
		return(ENOBUFS);

d750 1
d753 1
a753 1
	TI_HOSTADDR(r->ti_addr) = dmamap->dm_segs[0].ds_addr;
d756 1
a756 1
	r->ti_len = dmamap->dm_segs[0].ds_len;
d812 1
a812 1
	TI_HOSTADDR(r->ti_addr) = TI_JUMBO_DMA_ADDR(sc, m_new);
d830 1
a830 1
	int		i;
d834 1
a834 1
		if (ti_newbuf_std(sc, i, NULL, 0) == ENOBUFS)
d836 1
a836 1
	}
d847 1
a847 1
	int		i;
a852 3
			bus_dmamap_destroy(sc->sc_dmatag,
					   sc->ti_cdata.ti_rx_std_map[i]);
			sc->ti_cdata.ti_rx_std_map[i] = 0;
d864 1
a864 1
	int		i;
d881 1
a881 1
	int		i;
d898 1
a898 1
	int		i;
d901 1
a901 1
		if (ti_newbuf_mini(sc, i, NULL, 0) == ENOBUFS)
d914 1
a914 1
	int		i;
a919 3
			bus_dmamap_destroy(sc->sc_dmatag,
					   sc->ti_cdata.ti_rx_mini_map[i]);
			sc->ti_cdata.ti_rx_mini_map[i] = 0;
d931 1
a931 2
	int		i;
	struct ti_txmap_entry *entry;
a939 3
			SLIST_INSERT_HEAD(&sc->ti_tx_map_listhead,
					    sc->ti_cdata.ti_tx_map[i], link);
			sc->ti_cdata.ti_tx_map[i] = 0;
a944 6
	while ((entry = SLIST_FIRST(&sc->ti_tx_map_listhead))) {
		SLIST_REMOVE_HEAD(&sc->ti_tx_map_listhead, link);
		bus_dmamap_destroy(sc->sc_dmatag, entry->dmamap);
		free(entry, M_DEVBUF);
	}

a950 4
	int i;
	bus_dmamap_t dmamap;
	struct ti_txmap_entry *entry;

a953 16

	SLIST_INIT(&sc->ti_tx_map_listhead);
	for (i = 0; i < TI_TX_RING_CNT; i++) {
		if (bus_dmamap_create(sc->sc_dmatag, MCLBYTES, TI_NTXSEG,
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &dmamap))
			return(ENOBUFS);

		entry = malloc(sizeof(*entry), M_DEVBUF, M_NOWAIT);
		if (!entry) {
			bus_dmamap_destroy(sc->sc_dmatag, dmamap);
			return (ENOBUFS);
		}
		entry->dmamap = dmamap;
		SLIST_INSERT_HEAD(&sc->ti_tx_map_listhead, entry, link);
	}

d1044 2
a1045 1
 
d1060 3
a1062 2
	while (SLIST_FIRST(&sc->ti_mc_listhead) != NULL) {
		mc = SLIST_FIRST(&sc->ti_mc_listhead);
d1064 3
a1066 1
		SLIST_REMOVE_HEAD(&sc->ti_mc_listhead, mc_entries);
d1077 1
a1077 1
		SLIST_INSERT_HEAD(&sc->ti_mc_listhead, mc, mc_entries);
d1129 1
a1129 1
#if 0 && BYTE_ORDER == BIG_ENDIAN
d1186 1
a1186 1
	if (CSR_READ_4(sc, TI_PCI_CMDSTAT) & PCI_COMMAND_INVALIDATE_ENABLE) {
d1202 1
a1202 1
			    TI_PCI_CMDSTAT) & ~PCI_COMMAND_INVALIDATE_ENABLE);
a1274 3
#ifdef __64_bit_pci_addressing__ 
	CSR_WRITE_4(sc, TI_GCR_GENINFO_HI, TI_RING_DMA_ADDR(sc, ti_info)>>32);
#else
d1276 1
a1276 3
#endif
	CSR_WRITE_4(sc, TI_GCR_GENINFO_LO,
		    TI_RING_DMA_ADDR(sc, ti_info) & 0xffffffff);
d1286 1
a1286 1
	TI_HOSTADDR(rcb->ti_hostaddr) = TI_RING_DMA_ADDR(sc, ti_event_ring);
d1289 1
a1289 1
		TI_RING_DMA_ADDR(sc, ti_ev_prodidx_r);
d1297 2
d1315 1
a1315 1
		TI_RING_DMA_ADDR(sc, ti_info.ti_stats);
d1319 2
a1320 3
	TI_HOSTADDR(rcb->ti_hostaddr) =
		TI_RING_DMA_ADDR(sc, ti_rx_std_ring);
	rcb->ti_max_len = ETHER_MAX_LEN;
d1329 2
a1330 1
	TI_HOSTADDR(rcb->ti_hostaddr) = TI_RING_DMA_ADDR(sc, ti_rx_jumbo_ring);
d1344 2
a1345 1
	TI_HOSTADDR(rcb->ti_hostaddr) = TI_RING_DMA_ADDR(sc, ti_rx_mini_ring);
d1360 2
a1361 1
	TI_HOSTADDR(rcb->ti_hostaddr) = TI_RING_DMA_ADDR(sc,ti_rx_return_ring);
d1365 1
a1365 1
	    TI_RING_DMA_ADDR(sc, ti_return_prodidx_r);
d1377 4
d1397 1
a1397 1
			TI_RING_DMA_ADDR(sc, ti_tx_ring);
d1399 1
a1399 3
		TI_RING_DMA_ADDR(sc, ti_tx_considx_r);

	TI_RING_DMASYNC(sc, ti_info, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
a1422 10
const struct pci_matchid ti_devices[] = {
	{ PCI_VENDOR_NETGEAR, PCI_PRODUCT_NETGEAR_GA620 },
	{ PCI_VENDOR_NETGEAR, PCI_PRODUCT_NETGEAR_GA620T },
	{ PCI_VENDOR_ALTEON, PCI_PRODUCT_ALTEON_ACENIC },
	{ PCI_VENDOR_ALTEON, PCI_PRODUCT_ALTEON_ACENICT },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C985 },
	{ PCI_VENDOR_SGI, PCI_PRODUCT_SGI_TIGON },
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_PN9000SX },
};

d1433 26
a1458 2
	return (pci_matchbyid((struct pci_attach_args *)aux, ti_devices,
	    sizeof(ti_devices)/sizeof(ti_devices[0])));
d1475 1
d1528 1
a1528 1
	ti_mem_set(sc, 0x2000, 0x100000 - 0x2000);
d1572 1
a1572 2
	    sizeof(struct ti_ring_data), 0, BUS_DMA_NOWAIT,
	    &sc->ti_ring_map)) {
d1579 1
a1579 1
	if (bus_dmamap_load(sc->sc_dmatag, sc->ti_ring_map, kva,
d1581 1
a1581 1
		bus_dmamap_destroy(sc->sc_dmatag, sc->ti_ring_map);
a1628 4
#if NVLAN >0
	ifp->if_capabilities |= IFCAP_VLAN_MTU | IFCAP_VLAN_HWTAGGING;
#endif

d1650 1
a1650 1
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_1000_T, 0, NULL);
d1652 1
a1652 1
		    IFM_ETHER|IFM_1000_T|IFM_FDX, 0, NULL);
a1706 1
		bus_dmamap_t		dmamap;
a1737 2
			dmamap = sc->ti_cdata.ti_rx_mini_map[rxidx];
			sc->ti_cdata.ti_rx_mini_map[rxidx] = 0;
d1740 1
a1740 1
				ti_newbuf_mini(sc, sc->ti_mini, m, dmamap);
d1743 1
a1743 2
			if (ti_newbuf_mini(sc, sc->ti_mini, NULL, dmamap)
			    == ENOBUFS) {
d1745 1
a1745 1
				ti_newbuf_mini(sc, sc->ti_mini, m, dmamap);
a1751 2
			dmamap = sc->ti_cdata.ti_rx_std_map[rxidx];
			sc->ti_cdata.ti_rx_std_map[rxidx] = 0;
d1754 1
a1754 1
				ti_newbuf_std(sc, sc->ti_std, m, dmamap);
d1757 1
a1757 2
			if (ti_newbuf_std(sc, sc->ti_std, NULL, dmamap)
			    == ENOBUFS) {
d1759 1
a1759 1
				ti_newbuf_std(sc, sc->ti_std, m, dmamap);
a1763 3
		if (m == NULL)
			panic("%s: couldn't get mbuf", sc->sc_dv.dv_xname);

d1810 1
a1810 52
void ti_txeof_tigon1(sc)
	struct ti_softc		*sc;
{
	struct ifnet		*ifp;
	struct ti_txmap_entry	*entry;
	int			active = 1;

	ifp = &sc->arpcom.ac_if;

	/*
	 * Go through our tx ring and free mbufs for those
	 * frames that have been sent.
	 */
	while (sc->ti_tx_saved_considx != sc->ti_tx_considx.ti_idx) {
		u_int32_t		idx = 0;
		struct ti_tx_desc	txdesc;

		idx = sc->ti_tx_saved_considx;
		ti_mem_read(sc, TI_TX_RING_BASE + idx * sizeof(txdesc),
			    sizeof(txdesc), (caddr_t)&txdesc);

		if (txdesc.ti_flags & TI_BDFLAG_END)
			ifp->if_opackets++;

		if (sc->ti_cdata.ti_tx_chain[idx] != NULL) {
			m_freem(sc->ti_cdata.ti_tx_chain[idx]);
			sc->ti_cdata.ti_tx_chain[idx] = NULL;

			entry = sc->ti_cdata.ti_tx_map[idx];
			bus_dmamap_sync(sc->sc_dmatag, entry->dmamap, 0,
			    entry->dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);

			bus_dmamap_unload(sc->sc_dmatag, entry->dmamap);
			SLIST_INSERT_HEAD(&sc->ti_tx_map_listhead, entry,
			    link);
			sc->ti_cdata.ti_tx_map[idx] = NULL;

		}
		sc->ti_txcnt--;
		TI_INC(sc->ti_tx_saved_considx, TI_TX_RING_CNT);
		ifp->if_timer = 0;

		active = 0;
	}

	if (!active)
		ifp->if_flags &= ~IFF_OACTIVE;

	return;
}

void ti_txeof_tigon2(sc)
a1814 1
	struct ti_txmap_entry	*entry;
d1826 16
a1841 2
		cur_tx = &sc->ti_rdata->ti_tx_ring[idx];

a1846 10

			entry = sc->ti_cdata.ti_tx_map[idx];
			bus_dmamap_sync(sc->sc_dmatag, entry->dmamap, 0,
			    entry->dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);

			bus_dmamap_unload(sc->sc_dmatag, entry->dmamap);
			SLIST_INSERT_HEAD(&sc->ti_tx_map_listhead, entry,
			    link);
			sc->ti_cdata.ti_tx_map[idx] = NULL;

d1881 1
a1881 4
		if (sc->ti_hwrev == TI_HWREV_TIGON)
			ti_txeof_tigon1(sc);
		else
			ti_txeof_tigon2(sc);
a1898 1
	struct ti_stats		*stats = &sc->ti_rdata->ti_info.ti_stats;
d1902 6
a1907 1
	TI_RING_DMASYNC(sc, ti_info.ti_stats, BUS_DMASYNC_POSTREAD);
d1909 1
a1909 7
	ifp->if_collisions += stats->dot3StatsSingleCollisionFrames +
		stats->dot3StatsMultipleCollisionFrames +
		stats->dot3StatsExcessiveCollisions +
		stats->dot3StatsLateCollisions -
		ifp->if_collisions;

	TI_RING_DMASYNC(sc, ti_info.ti_stats, BUS_DMASYNC_PREREAD);
d1916 1
a1916 1
int ti_encap_tigon1(sc, m_head, txidx)
d1921 2
a1923 4
	struct ti_txmap_entry	*entry;
	bus_dmamap_t		txmap;
	struct ti_tx_desc	txdesc;
	int			i = 0;
d1932 1
a1932 5
	entry = SLIST_FIRST(&sc->ti_tx_map_listhead);
	if (entry == NULL)
		return ENOBUFS;
	txmap = entry->dmamap;

d1940 23
a1962 14
	if (bus_dmamap_load_mbuf(sc->sc_dmatag, txmap, m_head,
	    BUS_DMA_NOWAIT))
		return(ENOBUFS);

	for (i = 0; i < txmap->dm_nsegs; i++) {
		if (sc->ti_cdata.ti_tx_chain[frag] != NULL)
			break;

		memset(&txdesc, 0, sizeof(txdesc));

		TI_HOSTADDR(txdesc.ti_addr) = txmap->dm_segs[i].ds_addr;
		txdesc.ti_len = txmap->dm_segs[i].ds_len & 0xffff;

		txdesc.ti_flags = 0;
d1964 16
a1979 3
		if (ifv != NULL) {
			txdesc.ti_flags |= TI_BDFLAG_VLAN_TAG;
			txdesc.ti_vlan_tag = ifv->ifv_tag & 0xfff;
a1980 14
#endif

		ti_mem_write(sc, TI_TX_RING_BASE + frag * sizeof(txdesc),
			     sizeof(txdesc), (caddr_t)&txdesc);

		/*
		 * Sanity check: avoid coming within 16 descriptors
		 * of the end of the ring.
		 */
		if ((TI_TX_RING_CNT - (sc->ti_txcnt + cnt)) < 16)
			return(ENOBUFS);
		cur = frag;
		TI_INC(frag, TI_TX_RING_CNT);
		cnt++;
d1983 1
a1983 56
	if (frag == sc->ti_tx_saved_considx)
		return(ENOBUFS);

	txdesc.ti_flags |= TI_BDFLAG_END;
	ti_mem_write(sc, TI_TX_RING_BASE + cur * sizeof(txdesc),
		     sizeof(txdesc), (caddr_t)&txdesc);

	bus_dmamap_sync(sc->sc_dmatag, txmap, 0, txmap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	sc->ti_cdata.ti_tx_chain[cur] = m_head;
	SLIST_REMOVE_HEAD(&sc->ti_tx_map_listhead, link);
	sc->ti_cdata.ti_tx_map[cur] = entry;
	sc->ti_txcnt += cnt;

	*txidx = frag;

	return(0);
}

/*
 * Encapsulate an mbuf chain in the tx ring  by coupling the mbuf data
 * pointers to descriptors.
 */
int ti_encap_tigon2(sc, m_head, txidx)
	struct ti_softc		*sc;
	struct mbuf		*m_head;
	u_int32_t		*txidx;
{
	struct ti_tx_desc	*f = NULL;
	u_int32_t		frag, cur, cnt = 0;
	struct ti_txmap_entry	*entry;
	bus_dmamap_t		txmap;
	int			i = 0;
#if NVLAN > 0
	struct ifvlan		*ifv = NULL;

	if ((m_head->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&
	    m_head->m_pkthdr.rcvif != NULL)
		ifv = m_head->m_pkthdr.rcvif->if_softc;
#endif

	entry = SLIST_FIRST(&sc->ti_tx_map_listhead);
	if (entry == NULL)
		return ENOBUFS;
	txmap = entry->dmamap;

	cur = frag = *txidx;

	/*
 	 * Start packing the mbufs in this chain into
	 * the fragment pointers. Stop when we run out
 	 * of fragments or hit the end of the mbuf chain.
	 */
	if (bus_dmamap_load_mbuf(sc->sc_dmatag, txmap, m_head,
	    BUS_DMA_NOWAIT))
a1985 28
	for (i = 0; i < txmap->dm_nsegs; i++) {
		f = &sc->ti_rdata->ti_tx_ring[frag];

		if (sc->ti_cdata.ti_tx_chain[frag] != NULL)
			break;

		TI_HOSTADDR(f->ti_addr) = txmap->dm_segs[i].ds_addr;
		f->ti_len = txmap->dm_segs[i].ds_len & 0xffff;
		f->ti_flags = 0;
#if NVLAN > 0
		if (ifv != NULL) {
			f->ti_flags |= TI_BDFLAG_VLAN_TAG;
			f->ti_vlan_tag = ifv->ifv_tag & 0xfff;
		} else {
			f->ti_vlan_tag = 0;
		}
#endif
		/*
		 * Sanity check: avoid coming within 16 descriptors
		 * of the end of the ring.
		 */
		if ((TI_TX_RING_CNT - (sc->ti_txcnt + cnt)) < 16)
			return(ENOBUFS);
		cur = frag;
		TI_INC(frag, TI_TX_RING_CNT);
		cnt++;
	}

d1989 5
a1993 7
	sc->ti_rdata->ti_tx_ring[cur].ti_flags |= TI_BDFLAG_END;

	bus_dmamap_sync(sc->sc_dmatag, txmap, 0, txmap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	TI_RING_DMASYNC(sc, ti_tx_ring[cur], BUS_DMASYNC_POSTREAD);

a1994 2
	SLIST_REMOVE_HEAD(&sc->ti_tx_map_listhead, link);
	sc->ti_cdata.ti_tx_map[cur] = entry;
d2012 1
a2012 1
	int			pkts = 0, error;
d2028 1
a2028 6
		if (sc->ti_hwrev == TI_HWREV_TIGON)
			error = ti_encap_tigon1(sc, m_head, &prodidx);
		else
			error = ti_encap_tigon2(sc, m_head, &prodidx);

		if (error) {
d2197 1
a2197 1
	case IFM_1000_T:
d2255 1
a2255 1
			ifmr->ifm_active |= IFM_1000_T;
d2410 1
a2410 1
	ti_mem_set(sc, 0x2000, 0x100000 - 0x2000);
@


1.9.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1759 1
a1759 1
		 * Because currently there's no way to specify the
d2051 1
a2051 1
	/* Ack interrupt and stop others from occurring. */
@


1.9.2.10
log
@Merge with the trunk
@
text
@d759 3
a761 1
		if (m_new == NULL)
d763 1
d767 2
d832 3
a834 1
		if (m_new == NULL)
d836 1
d878 3
a880 1
		if (m_new == NULL)
d882 1
d888 2
a1181 1
allmulti:
a1203 7
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			/* Re-enable interrupts. */
			CSR_WRITE_4(sc, TI_MB_HOSTINTR, intrs);

			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}
@


1.8
log
@hush up the link up/down messages
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.7 1999/10/25 19:39:18 jason Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_ti.c,v 1.24 1999/09/23 03:32:54 wpaul Exp $
d1504 5
@


1.7
log
@use bus_dma instead of [u]vm_page_alloc_contig
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.6 1999/10/04 12:37:17 jason Exp $	*/
a493 8
			if (e->ti_code == TI_EV_CODE_LINK_UP)
				printf("%s: 10/100 link up\n",
				    sc->sc_dv.dv_xname);
			else if (e->ti_code == TI_EV_CODE_GIG_LINK_UP)
				printf("%s: gigabit link up\n",
				    sc->sc_dv.dv_xname);
			else if (e->ti_code == TI_EV_CODE_LINK_DOWN)
				printf("%s: link down\n", sc->sc_dv.dv_xname);
@


1.6
log
@m_new is the new mbuf, not m
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.5 1999/10/03 13:06:30 jason Exp $	*/
d563 5
a567 3
	caddr_t			ptr;
	register int		i;
	struct ti_jpool_entry   *entry;
d570 26
a595 12
#ifndef UVM
	sc->ti_cdata.ti_jumbo_buf = (caddr_t) vm_page_alloc_contig(
	    TI_JMEM, 0x100000, 0xffffffff, PAGE_SIZE);
#else
	sc->ti_cdata.ti_jumbo_buf = (caddr_t) uvm_pagealloc_contig(
	    TI_JMEM, 0x100000, 0xffffffff, PAGE_SIZE);
#endif

	if (sc->ti_cdata.ti_jumbo_buf == NULL) {
		printf("%s: no memory for jumbo buffers!\n",
		    sc->sc_dv.dv_xname);
		return(ENOBUFS);
d597 1
d614 4
a617 1
			free(sc->ti_cdata.ti_jumbo_buf, M_DEVBUF);
d619 2
a620 2
			printf("%s: no memory for jumbo "
			    "buffer queue!\n", sc->sc_dv.dv_xname);
d1530 3
a1532 1
	int s;
d1535 1
d1615 27
a1641 10
#ifndef UVM
	sc->ti_rdata = (struct ti_ring_data *) vm_page_alloc_contig(
	    sizeof(struct ti_ring_data), 0x100000, 0xffffffff, PAGE_SIZE);
#else
	sc->ti_rdata = (struct ti_ring_data *) uvm_pagealloc_contig(
	    sizeof(struct ti_ring_data), 0x100000, 0xffffffff, PAGE_SIZE);
#endif

	if (sc->ti_rdata == NULL) {
		printf("%s: no memory for list buffers!\n", sc->sc_dv.dv_xname);
d1644 1
a1644 1

@


1.5
log
@take advantage of m->m_ext.ext_handle for storing the softc
(instead of stashing it in the buffer)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.4 1999/10/01 02:02:20 jason Exp $	*/
d844 1
a844 1
	m->m_ext.ext_handle = sc;
@


1.4
log
@use new mbuf external management for jumbo packet management
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.3 1999/09/26 03:22:40 jason Exp $	*/
d587 1
a587 5
	 * in an array. Note that we play an evil trick here by using
	 * the first few bytes in the buffer to hold the the address
	 * of the softc structure for this interface. This is because
	 * ti_jfree() needs it, but it is called by the mbuf management
	 * code which will not pass it to us explicitly.
a590 4
		u_int64_t		**aptr;
		aptr = (u_int64_t **)ptr;
		aptr[0] = (u_int64_t *)sc;
		ptr += sizeof(u_int64_t);
d593 1
a593 1
		ptr += (TI_JLEN - sizeof(u_int64_t));
a642 1
	u_int64_t **aptr;
d646 1
a646 2
	aptr = (u_int64_t **)(buf - sizeof(u_int64_t));
	sc = (struct ti_softc *)(aptr[0]);
d655 1
a655 3

	i = ((vm_offset_t)aptr 
	     - (vm_offset_t)sc->ti_cdata.ti_jumbo_buf) / TI_JLEN;
a663 2

	return;
a675 1
	u_int64_t **aptr;
d680 1
a680 2
	aptr = (u_int64_t **)(buf - sizeof(u_int64_t));
	sc = (struct ti_softc *)(aptr[0]);
d689 1
a689 3

	i = ((vm_offset_t)aptr 
	     - (vm_offset_t)sc->ti_cdata.ti_jumbo_buf) / TI_JLEN;
a706 2

	return;
d843 2
@


1.3
log
@openbsd-ify: remove statics
merge with freebsd:
clean up buffer allocation
fix call to m_adj() in ti_newbuf_jumbo()
align on i386 & alpha
make sure mbufs have sane values
upgrade to latest firmware: 12.3.15
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.2 1999/08/03 00:55:44 ho Exp $	*/
d169 2
a170 4
void ti_jfree		__P((caddr_t, u_int));
#if 0
void ti_jref		__P((caddr_t, u_int));
#endif
a638 1
#if 0
d644 9
a652 7
void ti_jref(buf, size)
	caddr_t			buf;
	u_int			size;
{
	struct ti_softc		*sc;
	u_int64_t		**aptr;
	register int		i;
a678 1
#endif
d683 10
a692 8
void ti_jfree(buf, size)
	caddr_t			buf;
	u_int			size;
{
	struct ti_softc		*sc;
	u_int64_t		**aptr;
	int		        i;
	struct ti_jpool_entry   *entry;
a728 1

a856 1
#if 0
a857 1
#endif
@


1.2
log
@Compile with UVM.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ti.c,v 1.1 1999/07/25 16:51:55 jason Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_ti.c,v 1.9 1999/07/06 19:23:29 des Exp $
d133 2
a134 2
static int ti_probe	__P((struct device *, void *, void *));
static void ti_attach	__P((struct device *, struct device *, void *));
d136 2
a137 2
static void ti_txeof		__P((struct ti_softc *));
static void ti_rxeof		__P((struct ti_softc *));
d139 31
a169 34
static void ti_stats_update	__P((struct ti_softc *));
static int ti_encap		__P((struct ti_softc *, struct mbuf *,
					u_int32_t *));

static int ti_intr		__P((void *));
static void ti_start		__P((struct ifnet *));
static int ti_ioctl		__P((struct ifnet *, u_long, caddr_t));
static void ti_init		__P((void *));
static void ti_init2		__P((struct ti_softc *));
static void ti_stop		__P((struct ti_softc *));
static void ti_watchdog		__P((struct ifnet *));
static void ti_shutdown		__P((void *));
static int ti_ifmedia_upd	__P((struct ifnet *));
static void ti_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));

static u_int32_t ti_eeprom_putbyte	__P((struct ti_softc *, int));
static u_int8_t	ti_eeprom_getbyte	__P((struct ti_softc *,
						int, u_int8_t *));
static int ti_read_eeprom	__P((struct ti_softc *, caddr_t, int, int));

static void ti_add_mcast	__P((struct ti_softc *, struct ether_addr *));
static void ti_del_mcast	__P((struct ti_softc *, struct ether_addr *));
static void ti_setmulti		__P((struct ti_softc *));

static void ti_mem		__P((struct ti_softc *, u_int32_t,
					u_int32_t, caddr_t));
static void ti_loadfw		__P((struct ti_softc *));
static void ti_cmd		__P((struct ti_softc *, struct ti_cmd_desc *));
static void ti_cmd_ext		__P((struct ti_softc *, struct ti_cmd_desc *,
					caddr_t, int));
static void ti_handle_events	__P((struct ti_softc *));
static int ti_alloc_jumbo_mem	__P((struct ti_softc *));
static void *ti_jalloc		__P((struct ti_softc *));
static void ti_jfree		__P((caddr_t, u_int));
d171 1
a171 1
static void ti_jref		__P((caddr_t, u_int));
d173 15
a187 15
static int ti_newbuf_std	__P((struct ti_softc *, int, struct mbuf *));
static int ti_newbuf_mini	__P((struct ti_softc *, int, struct mbuf *));
static int ti_newbuf_jumbo	__P((struct ti_softc *, int, struct mbuf *));
static int ti_init_rx_ring_std	__P((struct ti_softc *));
static void ti_free_rx_ring_std	__P((struct ti_softc *));
static int ti_init_rx_ring_jumbo	__P((struct ti_softc *));
static void ti_free_rx_ring_jumbo	__P((struct ti_softc *));
static int ti_init_rx_ring_mini	__P((struct ti_softc *));
static void ti_free_rx_ring_mini	__P((struct ti_softc *));
static void ti_free_tx_ring	__P((struct ti_softc *));
static int ti_init_tx_ring	__P((struct ti_softc *));

static int ti_64bitslot_war	__P((struct ti_softc *));
static int ti_chipinit		__P((struct ti_softc *));
static int ti_gibinit		__P((struct ti_softc *));
d192 1
a192 1
static u_int32_t ti_eeprom_putbyte(sc, byte)
d238 1
a238 1
static u_int8_t ti_eeprom_getbyte(sc, addr, dest)
d312 1
a312 1
static int ti_read_eeprom(sc, dest, off, cnt)
d335 1
a335 1
static void ti_mem(sc, addr, len, buf)
a344 1
#ifdef __i386__
a345 4
#endif
#ifdef __alpha__
	ti_winbase = (caddr_t)(sc->ti_vhandle + TI_WINDOW);
#endif
d374 1
a374 1
static void ti_loadfw(sc)
d432 1
a432 1
static void ti_cmd(sc, cmd)
d454 1
a454 1
static void ti_cmd_ext(sc, cmd, arg, len)
d483 1
a483 1
static void ti_handle_events(sc)
d562 1
a562 1
static int ti_alloc_jumbo_mem(sc)
d623 1
a623 1
static void *ti_jalloc(sc)
d647 1
a647 1
static void ti_jref(buf, size)
d662 1
a662 1
	if (size != TI_JUMBO_FRAMELEN - ETHER_ALIGN)
d685 1
a685 1
static void ti_jfree(buf, size)
d701 1
a701 1
	if (size != TI_JUMBO_FRAMELEN - ETHER_ALIGN)
d733 1
a733 1
static int ti_newbuf_std(sc, i, m)
d741 1
a741 3
	if (m != NULL) {
		m_new = m;
	} else {
d751 1
a751 1
			printf("sc->sc_dv.dv_xname: cluster allocation failed "
d756 5
d773 1
a773 1
	r->ti_len = MCLBYTES - ETHER_ALIGN;
d783 1
a783 1
static int ti_newbuf_mini(sc, i, m)
d791 1
a791 3
	if (m != NULL) {
		m_new = m;
	} else {
d798 5
d804 1
d814 1
a814 1
	r->ti_len = MHLEN - ETHER_ALIGN;
d824 1
a824 1
static int ti_newbuf_jumbo(sc, i, m)
d832 1
a832 3
	if (m != NULL) {
		m_new = m;
	} else {
a853 1
		m_new->m_data += ETHER_ALIGN;
d855 2
a856 1
		m_new->m_ext.ext_size = TI_JUMBO_FRAMELEN - ETHER_ALIGN;
d861 4
d867 1
d877 1
a877 1
	r->ti_len = TI_JUMBO_FRAMELEN - ETHER_ALIGN;
d889 1
a889 1
static int ti_init_rx_ring_std(sc)
d906 1
a906 1
static void ti_free_rx_ring_std(sc)
d923 1
a923 1
static int ti_init_rx_ring_jumbo(sc)
d940 1
a940 1
static void ti_free_rx_ring_jumbo(sc)
d957 1
a957 1
static int ti_init_rx_ring_mini(sc)
d973 1
a973 1
static void ti_free_rx_ring_mini(sc)
d990 1
a990 1
static void ti_free_tx_ring(sc)
d1010 1
a1010 1
static int ti_init_tx_ring(sc)
d1096 1
a1096 1
static void ti_setmulti(sc)
d1153 1
a1153 1
static int ti_64bitslot_war(sc)
d1178 1
a1178 1
static int ti_chipinit(sc)
d1321 1
a1321 1
static int ti_gibinit(sc)
a1355 1
#ifdef __i386__
a1357 5
#endif
#ifdef __alpha__
	sc->ti_rdata->ti_cmd_ring =
	    (struct ti_cmd_desc *)(sc->ti_vhandle + TI_GCR_CMDRING);
#endif
d1392 1
a1392 1
	rcb->ti_max_len = TI_JUMBO_FRAMELEN - ETHER_ALIGN;
d1409 1
a1409 1
	rcb->ti_max_len = MHLEN;
a1442 1
#ifdef __i386__
a1444 5
#endif
#ifdef __alpha__
		sc->ti_rdata->ti_tx_ring_nic =
		    (struct ti_tx_desc *)(sc->ti_vhandle + TI_WINDOW);
#endif
d1491 1
a1491 1
static int
d1519 1
a1519 1
static void
d1567 1
a1567 1
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, ti_intr, sc,
d1569 1
a1569 1
	if (sc->sc_ih == NULL) {
d1614 1
a1614 1
	sc->ti_rdata_ptr = (caddr_t) vm_page_alloc_contig(
d1617 1
a1617 1
	sc->ti_rdata_ptr = (caddr_t) uvm_pagealloc_contig(
d1621 1
a1621 1
	if (sc->ti_rdata_ptr == NULL) {
a1625 1
	sc->ti_rdata = (struct ti_ring_data *)sc->ti_rdata_ptr;
d1696 1
a1696 1
static void ti_rxeof(sc)
d1822 1
a1822 1
static void ti_txeof(sc)
d1871 1
a1871 1
static int ti_intr(xsc)
d1912 1
a1912 1
static void ti_stats_update(sc)
d1933 1
a1933 1
static int ti_encap(sc, m_head, txidx)
d2024 1
a2024 1
static void ti_start(ifp)
d2072 1
a2072 1
static void ti_init(xsc)
d2095 1
a2095 1
static void ti_init2(sc)
d2183 1
a2183 1
static int ti_ifmedia_upd(ifp)
d2239 1
a2239 1
static void ti_ifmedia_sts(ifp, ifmr)
d2273 1
a2273 1
static int ti_ioctl(ifp, command, data)
d2357 1
a2357 1
static void ti_watchdog(ifp)
d2377 1
a2377 1
static void ti_stop(sc)
d2423 1
a2423 1
static void ti_shutdown(xsc)
@


1.1
log
@driver for the Tigon I & Tigon II gigabit ethernet chipsets written by
Bill Paul <wpaul@@freebsd.org>
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d578 1
d581 4
d1623 1
d1626 4
@

