head	1.25;
access;
symbols
	OPENBSD_6_2:1.25.0.6
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.25.0.10
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.8
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.4
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.22.0.22
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.18
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.16
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.14
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.12
	OPENBSD_5_0:1.22.0.10
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.8
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.6
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.4
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.21.0.6
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.4
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.20.0.8
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.6
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.4
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.10
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.8
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.6
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.17
	UBC:1.13.0.4
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	SMP:1.2.0.2
	SMP_BASE:1.2;
locks; strict;
comment	@ * @;


1.25
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.24;
commitid	p4LJxGKbi0BU2cG6;

1.24
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.23;
commitid	LS2TNeCue5R9L67C;

1.23
date	2014.05.04.20.09.15;	author sf;	state Exp;
branches;
next	1.22;

1.22
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.17.02.51.39;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2006.02.24.00.04.27;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.06.21.08.06;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.03.20.49.29;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.11.14.41.35;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.11.03.05.53;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.06.19.33.00;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.25.10.13.29;	author art;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2001.07.30.01.28.56;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.12.15.40.30;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.07.19.43.14;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.10.09.42.15;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.19.08.43.37;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.05.18.49.30;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.03.21.33.12;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.03.21.29.39;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.01.00.18.37;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.01.22.38.51;	author niklas;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.02.13.10.59.06;	author niklas;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.02.07.00.33.03;	author niklas;	state Exp;
branches;
next	;

1.2.2.1
date	2000.03.02.07.04.38;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.05.14.22.25.41;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.07.04.10.42.05;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2003.03.28.00.38.21;	author niklas;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.2.2.8;

1.2.2.8
date	2004.02.19.10.56.26;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2000.10.20.18.01.36;	author jason;	state Exp;
branches;
next	;

1.13.4.1
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: gdt_pci.c,v 1.24 2014/12/19 22:44:58 guenther Exp $	*/

/*
 * Copyright (c) 1999, 2000 Niklas Hallqvist.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This driver would not have written if it was not for the hardware donations
 * from both ICP-Vortex and Öko.neT.  I want to thank them for their support.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <sys/endian.h>

#include <machine/bus.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

#include <dev/ic/gdtreg.h>
#include <dev/ic/gdtvar.h>

/* Product numbers for Fibre-Channel are greater than or equal to 0x200 */
#define GDT_PCI_PRODUCT_FC	0x200

#define GDT_DEVICE_ID_MIN	0x100
#define GDT_DEVICE_ID_MAX	0x2ff
#define GDT_DEVICE_ID_NEWRX	0x300
#define GDT_DEVICE_ID_NEWRX2	0x301

/* Mapping registers for various areas */
#define GDT_PCI_DPMEM		0x10
#define GDT_PCINEW_IOMEM	0x10
#define GDT_PCINEW_IO		0x14
#define GDT_PCINEW_DPMEM	0x18

/* PCI SRAM structure */
#define GDT_MAGIC	0x00	/* u_int32_t, controller ID from BIOS */
#define GDT_NEED_DEINIT	0x04	/* u_int16_t, switch between BIOS/driver */
#define GDT_SWITCH_SUPPORT 0x06	/* u_int8_t, see GDT_NEED_DEINIT */
#define GDT_OS_USED	0x10	/* u_int8_t [16], OS code per service */
#define GDT_FW_MAGIC	0x3c	/* u_int8_t, controller ID from firmware */
#define GDT_SRAM_SZ	0x40

/* DPRAM PCI controllers */
#define GDT_DPR_IF	0x00	/* interface area */
#define GDT_6SR		(0xff0 - GDT_SRAM_SZ)
#define GDT_SEMA1	0xff1	/* volatile u_int8_t, command semaphore */
#define GDT_IRQEN	0xff5	/* u_int8_t, board interrupts enable */
#define GDT_EVENT	0xff8	/* u_int8_t, release event */
#define GDT_IRQDEL	0xffc	/* u_int8_t, acknowledge board interrupt */
#define GDT_DPRAM_SZ	0x1000

/* PLX register structure (new PCI controllers) */
#define GDT_CFG_REG	0x00	/* u_int8_t, DPRAM cfg. (2: < 1MB, 0: any) */
#define GDT_SEMA0_REG	0x40	/* volatile u_int8_t, command semaphore */
#define GDT_SEMA1_REG	0x41	/* volatile u_int8_t, status semaphore */
#define GDT_PLX_STATUS	0x44	/* volatile u_int16_t, command status */
#define GDT_PLX_SERVICE	0x46	/* u_int16_t, service */
#define GDT_PLX_INFO	0x48	/* u_int32_t [2], additional info */
#define GDT_LDOOR_REG	0x60	/* u_int8_t, PCI to local doorbell */
#define GDT_EDOOR_REG	0x64	/* volatile u_int8_t, local to PCI doorbell */
#define GDT_CONTROL0	0x68	/* u_int8_t, control0 register (unused) */
#define GDT_CONTROL1	0x69	/* u_int8_t, board interrupts enable */
#define GDT_PLX_SZ	0x80

/* DPRAM new PCI controllers */
#define GDT_IC		0x00	/* interface */
#define GDT_PCINEW_6SR	(0x4000 - GDT_SRAM_SZ)
				/* SRAM structure */
#define GDT_PCINEW_SZ	0x4000

/* i960 register structure (PCI MPR controllers) */
#define GDT_MPR_SEMA0	0x10	/* volatile u_int8_t, command semaphore */
#define GDT_MPR_SEMA1	0x12	/* volatile u_int8_t, status semaphore */
#define GDT_MPR_STATUS	0x14	/* volatile u_int16_t, command status */
#define GDT_MPR_SERVICE	0x16	/* u_int16_t, service */
#define GDT_MPR_INFO	0x18	/* u_int32_t [2], additional info */
#define GDT_MPR_LDOOR	0x20	/* u_int8_t, PCI to local doorbell */
#define GDT_MPR_EDOOR	0x2c	/* volatile u_int8_t, locl to PCI doorbell */
#define GDT_EDOOR_EN	0x34	/* u_int8_t, board interrupts enable */
#define GDT_I960_SZ	0x1000

/* DPRAM PCI MPR controllers */
#define GDT_I960R	0x00	/* 4KB i960 registers */
#define GDT_MPR_IC	GDT_I960_SZ
				/* interface area */
#define GDT_MPR_6SR	(GDT_I960_SZ + 0x3000 - GDT_SRAM_SZ)
				/* SRAM structure */
#define GDT_MPR_SZ	0x4000

int	gdt_pci_probe(struct device *, void *, void *);
void	gdt_pci_attach(struct device *, struct device *, void *);
void	gdt_pci_enable_intr(struct gdt_softc *);

void	gdt_pci_copy_cmd(struct gdt_softc *, struct gdt_ccb *);
u_int8_t gdt_pci_get_status(struct gdt_softc *);
void	gdt_pci_intr(struct gdt_softc *, struct gdt_intr_ctx *);
void	gdt_pci_release_event(struct gdt_softc *, struct gdt_ccb *);
void	gdt_pci_set_sema0(struct gdt_softc *);
int	gdt_pci_test_busy(struct gdt_softc *);

void	gdt_pcinew_copy_cmd(struct gdt_softc *, struct gdt_ccb *);
u_int8_t gdt_pcinew_get_status(struct gdt_softc *);
void	gdt_pcinew_intr(struct gdt_softc *, struct gdt_intr_ctx *);
void	gdt_pcinew_release_event(struct gdt_softc *, struct gdt_ccb *);
void	gdt_pcinew_set_sema0(struct gdt_softc *);
int	gdt_pcinew_test_busy(struct gdt_softc *);

void	gdt_mpr_copy_cmd(struct gdt_softc *, struct gdt_ccb *);
u_int8_t gdt_mpr_get_status(struct gdt_softc *);
void	gdt_mpr_intr(struct gdt_softc *, struct gdt_intr_ctx *);
void	gdt_mpr_release_event(struct gdt_softc *, struct gdt_ccb *);
void	gdt_mpr_set_sema0(struct gdt_softc *);
int	gdt_mpr_test_busy(struct gdt_softc *);

struct cfattach gdt_pci_ca = {
	sizeof (struct gdt_softc), gdt_pci_probe, gdt_pci_attach
};

int
gdt_pci_probe(struct device *parent, void *match, void *aux)
{
        struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VORTEX &&
	    ((PCI_PRODUCT(pa->pa_id) >= GDT_DEVICE_ID_MIN &&
	    PCI_PRODUCT(pa->pa_id) <= GDT_DEVICE_ID_MAX) ||
	    PCI_PRODUCT(pa->pa_id) == GDT_DEVICE_ID_NEWRX ||
	    PCI_PRODUCT(pa->pa_id) == GDT_DEVICE_ID_NEWRX2))
		return (1);
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_GDT_RAID1 ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_GDT_RAID2))
		return (1);
	return (0);
}

void
gdt_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct pci_attach_args *pa = aux;
	struct gdt_softc *sc = (void *)self;
	bus_space_tag_t dpmemt, iomemt, iot;
	bus_space_handle_t dpmemh, iomemh, ioh;
	bus_addr_t dpmembase, iomembase, iobase;
	bus_size_t dpmemsize, iomemsize, iosize;
	u_int16_t prod;
	u_int32_t status = 0;
#define DPMEM_MAPPED		1
#define IOMEM_MAPPED		2
#define IO_MAPPED		4
#define INTR_ESTABLISHED	8
	int retries;
	u_int8_t protocol;
	pci_intr_handle_t ih;
	const char *intrstr;

	printf(": ");

	sc->sc_class = 0;
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VORTEX) {
		prod = PCI_PRODUCT(pa->pa_id);
		switch (prod) {
		case PCI_PRODUCT_VORTEX_GDT_60x0:
		case PCI_PRODUCT_VORTEX_GDT_6000B:
			sc->sc_class = GDT_PCI;
			break;

		case PCI_PRODUCT_VORTEX_GDT_6x10:
		case PCI_PRODUCT_VORTEX_GDT_6x20:
		case PCI_PRODUCT_VORTEX_GDT_6530:
		case PCI_PRODUCT_VORTEX_GDT_6550:
		case PCI_PRODUCT_VORTEX_GDT_6x17:
		case PCI_PRODUCT_VORTEX_GDT_6x27:
		case PCI_PRODUCT_VORTEX_GDT_6537:
		case PCI_PRODUCT_VORTEX_GDT_6557:
		case PCI_PRODUCT_VORTEX_GDT_6x15:
		case PCI_PRODUCT_VORTEX_GDT_6x25:
		case PCI_PRODUCT_VORTEX_GDT_6535:
		case PCI_PRODUCT_VORTEX_GDT_6555:
			sc->sc_class = GDT_PCINEW;
			break;

		case PCI_PRODUCT_VORTEX_GDT_6x17RP:
		case PCI_PRODUCT_VORTEX_GDT_6x27RP:
		case PCI_PRODUCT_VORTEX_GDT_6537RP:
		case PCI_PRODUCT_VORTEX_GDT_6557RP:
		case PCI_PRODUCT_VORTEX_GDT_6x11RP:
		case PCI_PRODUCT_VORTEX_GDT_6x21RP:
		case PCI_PRODUCT_VORTEX_GDT_6x17RD:
		case PCI_PRODUCT_VORTEX_GDT_6x27RD:
		case PCI_PRODUCT_VORTEX_GDT_6537RD:
		case PCI_PRODUCT_VORTEX_GDT_6557RD:
		case PCI_PRODUCT_VORTEX_GDT_6x11RD:
		case PCI_PRODUCT_VORTEX_GDT_6x21RD:
		case PCI_PRODUCT_VORTEX_GDT_6x18RD:
		case PCI_PRODUCT_VORTEX_GDT_6x28RD:
		case PCI_PRODUCT_VORTEX_GDT_6x38RD:
		case PCI_PRODUCT_VORTEX_GDT_6x58RD:
		case PCI_PRODUCT_VORTEX_GDT_6518RS:
		case PCI_PRODUCT_VORTEX_GDT_7x18RN:
		case PCI_PRODUCT_VORTEX_GDT_7x28RN:
		case PCI_PRODUCT_VORTEX_GDT_7x38RN:
		case PCI_PRODUCT_VORTEX_GDT_7x58RN:
		case PCI_PRODUCT_VORTEX_GDT_6x19RD:
		case PCI_PRODUCT_VORTEX_GDT_6x29RD:
		case PCI_PRODUCT_VORTEX_GDT_7x19RN:
		case PCI_PRODUCT_VORTEX_GDT_7x29RN:
		case PCI_PRODUCT_VORTEX_GDT_7x43RN:
			sc->sc_class = GDT_MPR;
		}

		/* If we don't recognize it, determine class heuristically.  */
		if (sc->sc_class == 0)
			sc->sc_class = prod < 0x100 ? GDT_PCINEW : GDT_MPR;

		if (prod >= GDT_PCI_PRODUCT_FC)
			sc->sc_class |= GDT_FC;

	} else if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL) {
		sc->sc_class = GDT_MPR;
	}

	if (pci_mapreg_map(pa,
	    GDT_CLASS(sc) == GDT_PCINEW ? GDT_PCINEW_DPMEM : GDT_PCI_DPMEM,
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0, &dpmemt,
	    &dpmemh, &dpmembase, &dpmemsize, 0)) {
		if (pci_mapreg_map(pa,
		    GDT_CLASS(sc) == GDT_PCINEW ? GDT_PCINEW_DPMEM :
		    GDT_PCI_DPMEM,
		    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT_1M, 0,
		    &dpmemt,&dpmemh, &dpmembase, &dpmemsize, 0)) {
			printf("cannot map DPMEM\n");
			goto bail_out;
		}
	}
	status |= DPMEM_MAPPED;
	sc->sc_dpmemt = dpmemt;
	sc->sc_dpmemh = dpmemh;
	sc->sc_dpmembase = dpmembase;
	sc->sc_dmat = pa->pa_dmat;

	/*
	 * The GDT_PCINEW series also has two other regions to map.
	 */
	if (GDT_CLASS(sc) == GDT_PCINEW) {
		if (pci_mapreg_map(pa, GDT_PCINEW_IOMEM, PCI_MAPREG_TYPE_MEM,
		    0, &iomemt, &iomemh, &iomembase, &iomemsize, 0)) {
			printf("can't map memory mapped i/o ports\n");
			goto bail_out;
		}
		status |= IOMEM_MAPPED;

		if (pci_mapreg_map(pa, GDT_PCINEW_IO, PCI_MAPREG_TYPE_IO, 0,
		    &iot, &ioh, &iobase, &iosize, 0)) {
			printf("can't map i/o space\n");
			goto bail_out;
		}
		status |= IO_MAPPED;
		sc->sc_iot = iot;
		sc->sc_ioh = ioh;
		sc->sc_iobase = iobase;
	}

	switch (GDT_CLASS(sc)) {
	case GDT_PCI:
		bus_space_set_region_4(dpmemt, dpmemh, 0, 0,
		    GDT_DPR_IF_SZ >> 2);
		if (bus_space_read_1(dpmemt, dpmemh, 0) != 0) {
			printf("can't write to DPMEM\n");
			goto bail_out;
		}

#if 0
		/* disable board interrupts, deinit services */
		gdth_writeb(0xff, &dp6_ptr->io.irqdel);
		gdth_writeb(0x00, &dp6_ptr->io.irqen);
		gdth_writeb(0x00, &dp6_ptr->u.ic.S_Status);
		gdth_writeb(0x00, &dp6_ptr->u.ic.Cmd_Index);

		gdth_writel(pcistr->dpmem, &dp6_ptr->u.ic.S_Info[0]);
		gdth_writeb(0xff, &dp6_ptr->u.ic.S_Cmd_Indx);
		gdth_writeb(0, &dp6_ptr->io.event);
		retries = INIT_RETRIES;
		gdth_delay(20);
		while (gdth_readb(&dp6_ptr->u.ic.S_Status) != 0xff) {
		  if (--retries == 0) {
		    printk("initialization error (DEINIT failed)\n");
		    gdth_munmap(ha->brd);
		    return 0;
		  }
		  gdth_delay(1);
		}
		prot_ver = (unchar)gdth_readl(&dp6_ptr->u.ic.S_Info[0]);
		gdth_writeb(0, &dp6_ptr->u.ic.S_Status);
		gdth_writeb(0xff, &dp6_ptr->io.irqdel);
		if (prot_ver != PROTOCOL_VERSION) {
		  printk("illegal protocol version\n");
		  gdth_munmap(ha->brd);
		  return 0;
		}

		ha->type = GDT_PCI;
		ha->ic_all_size = sizeof(dp6_ptr->u);

		/* special command to controller BIOS */
		gdth_writel(0x00, &dp6_ptr->u.ic.S_Info[0]);
		gdth_writel(0x00, &dp6_ptr->u.ic.S_Info[1]);
		gdth_writel(0x01, &dp6_ptr->u.ic.S_Info[2]);
		gdth_writel(0x00, &dp6_ptr->u.ic.S_Info[3]);
		gdth_writeb(0xfe, &dp6_ptr->u.ic.S_Cmd_Indx);
		gdth_writeb(0, &dp6_ptr->io.event);
		retries = INIT_RETRIES;
		gdth_delay(20);
		while (gdth_readb(&dp6_ptr->u.ic.S_Status) != 0xfe) {
		  if (--retries == 0) {
		    printk("initialization error\n");
		    gdth_munmap(ha->brd);
		    return 0;
		  }
		  gdth_delay(1);
		}
		gdth_writeb(0, &dp6_ptr->u.ic.S_Status);
		gdth_writeb(0xff, &dp6_ptr->io.irqdel);
#endif

		sc->sc_ic_all_size = GDT_DPRAM_SZ;

		sc->sc_copy_cmd = gdt_pci_copy_cmd;
		sc->sc_get_status = gdt_pci_get_status;
		sc->sc_intr = gdt_pci_intr;
		sc->sc_release_event = gdt_pci_release_event;
		sc->sc_set_sema0 = gdt_pci_set_sema0;
		sc->sc_test_busy = gdt_pci_test_busy;

		break;

	case GDT_PCINEW:
		bus_space_set_region_4(dpmemt, dpmemh, 0, 0,
		    GDT_DPR_IF_SZ >> 2);
		if (bus_space_read_1(dpmemt, dpmemh, 0) != 0) {
			printf("cannot write to DPMEM\n");
			goto bail_out;
		}

#if 0
		/* disable board interrupts, deinit services */
		outb(0x00,PTR2USHORT(&ha->plx->control1));
		outb(0xff,PTR2USHORT(&ha->plx->edoor_reg));

		gdth_writeb(0x00, &dp6c_ptr->u.ic.S_Status);
		gdth_writeb(0x00, &dp6c_ptr->u.ic.Cmd_Index);

		gdth_writel(pcistr->dpmem, &dp6c_ptr->u.ic.S_Info[0]);
		gdth_writeb(0xff, &dp6c_ptr->u.ic.S_Cmd_Indx);

		outb(1,PTR2USHORT(&ha->plx->ldoor_reg));

		retries = INIT_RETRIES;
		gdth_delay(20);
		while (gdth_readb(&dp6c_ptr->u.ic.S_Status) != 0xff) {
		  if (--retries == 0) {
		    printk("initialization error (DEINIT failed)\n");
		    gdth_munmap(ha->brd);
		    return 0;
		  }
		  gdth_delay(1);
		}
		prot_ver = (unchar)gdth_readl(&dp6c_ptr->u.ic.S_Info[0]);
		gdth_writeb(0, &dp6c_ptr->u.ic.Status);
		if (prot_ver != PROTOCOL_VERSION) {
		  printk("illegal protocol version\n");
		  gdth_munmap(ha->brd);
		  return 0;
		}

		ha->type = GDT_PCINEW;
		ha->ic_all_size = sizeof(dp6c_ptr->u);

		/* special command to controller BIOS */
		gdth_writel(0x00, &dp6c_ptr->u.ic.S_Info[0]);
		gdth_writel(0x00, &dp6c_ptr->u.ic.S_Info[1]);
		gdth_writel(0x01, &dp6c_ptr->u.ic.S_Info[2]);
		gdth_writel(0x00, &dp6c_ptr->u.ic.S_Info[3]);
		gdth_writeb(0xfe, &dp6c_ptr->u.ic.S_Cmd_Indx);

		outb(1,PTR2USHORT(&ha->plx->ldoor_reg));

		retries = INIT_RETRIES;
		gdth_delay(20);
		while (gdth_readb(&dp6c_ptr->u.ic.S_Status) != 0xfe) {
		  if (--retries == 0) {
		    printk("initialization error\n");
		    gdth_munmap(ha->brd);
		    return 0;
		  }
		  gdth_delay(1);
		}
		gdth_writeb(0, &dp6c_ptr->u.ic.S_Status);
#endif

		sc->sc_ic_all_size = GDT_PCINEW_SZ;

		sc->sc_copy_cmd = gdt_pcinew_copy_cmd;
		sc->sc_get_status = gdt_pcinew_get_status;
		sc->sc_intr = gdt_pcinew_intr;
		sc->sc_release_event = gdt_pcinew_release_event;
		sc->sc_set_sema0 = gdt_pcinew_set_sema0;
		sc->sc_test_busy = gdt_pcinew_test_busy;

		break;

	case GDT_MPR:
		bus_space_write_4(dpmemt, dpmemh, GDT_MPR_IC, GDT_MPR_MAGIC);
		if (bus_space_read_4(dpmemt, dpmemh, GDT_MPR_IC) !=
		    GDT_MPR_MAGIC) {
			printf("cannot access DPMEM at 0x%lx (shadowed?)\n",
			    dpmembase);
			goto bail_out;
		}

		/*
		 * XXX Here the Linux driver has a weird remapping logic I
		 * don't understand.  My controller does not need it, and I
		 * cannot see what purpose it serves, therefore I did not
		 * do anything similar.
		 */

		bus_space_set_region_4(dpmemt, dpmemh, GDT_I960_SZ, 0,
		    GDT_DPR_IF_SZ >> 2);

		/* Disable everything */
		bus_space_write_1(dpmemt, dpmemh, GDT_EDOOR_EN,
		    bus_space_read_1(dpmemt, dpmemh, GDT_EDOOR_EN) | 4);
		bus_space_write_1(dpmemt, dpmemh, GDT_MPR_EDOOR, 0xff);
		bus_space_write_1(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_STATUS,
		    0);
		bus_space_write_1(dpmemt, dpmemh, GDT_MPR_IC + GDT_CMD_INDEX,
		    0);

		bus_space_write_4(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_INFO,
		    dpmembase);
		bus_space_write_1(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_CMD_INDX,
		    0xff);
		bus_space_write_1(dpmemt, dpmemh, GDT_MPR_LDOOR, 1);

		DELAY(20);
		retries = GDT_RETRIES;
		while (bus_space_read_1(dpmemt, dpmemh,
		    GDT_MPR_IC + GDT_S_STATUS) != 0xff) {
			if (--retries == 0) {
				printf("DEINIT failed (status 0x%x)\n",
				    bus_space_read_1(dpmemt, dpmemh,
				    GDT_MPR_IC + GDT_S_STATUS));
				goto bail_out;
			}
			DELAY(1);
		}

		protocol = (u_int8_t)bus_space_read_4(dpmemt, dpmemh,
		    GDT_MPR_IC + GDT_S_INFO);
		bus_space_write_1(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_STATUS,
		    0);
		if (protocol != GDT_PROTOCOL_VERSION) {
		 	printf("unsupported protocol %d\n", protocol);
			goto bail_out;
		}

		/* special commnd to controller BIOS */
		bus_space_write_4(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_INFO, 0);
		bus_space_write_4(dpmemt, dpmemh,
		    GDT_MPR_IC + GDT_S_INFO + sizeof (u_int32_t), 0);
		bus_space_write_4(dpmemt, dpmemh,
		    GDT_MPR_IC + GDT_S_INFO + 2 * sizeof (u_int32_t), 1);
		bus_space_write_4(dpmemt, dpmemh,
		    GDT_MPR_IC + GDT_S_INFO + 3 * sizeof (u_int32_t), 0);
		bus_space_write_1(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_CMD_INDX,
		    0xfe);
		bus_space_write_1(dpmemt, dpmemh, GDT_MPR_LDOOR, 1);

		DELAY(20);
		retries = GDT_RETRIES;
		while (bus_space_read_1(dpmemt, dpmemh,
		    GDT_MPR_IC + GDT_S_STATUS) != 0xfe) {
			if (--retries == 0) {
				printf("initialization error\n");
				goto bail_out;
			}
			DELAY(1);
		}

		bus_space_write_1(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_STATUS,
		    0);

		sc->sc_ic_all_size = GDT_MPR_SZ;

		sc->sc_copy_cmd = gdt_mpr_copy_cmd;
		sc->sc_get_status = gdt_mpr_get_status;
		sc->sc_intr = gdt_mpr_intr;
		sc->sc_release_event = gdt_mpr_release_event;
		sc->sc_set_sema0 = gdt_mpr_set_sema0;
		sc->sc_test_busy = gdt_mpr_test_busy;
	}

	if (pci_intr_map(pa, &ih)) {
		printf("couldn't map interrupt\n");
		goto bail_out;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, gdt_intr, sc,
	    sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf("couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto bail_out;
	}
	status |= INTR_ESTABLISHED;
	if (intrstr != NULL)
		printf("%s ", intrstr);

	if (gdt_attach(sc))
		goto bail_out;

	gdt_pci_enable_intr(sc);

	return;

 bail_out:
	if (status & DPMEM_MAPPED)
		bus_space_unmap(dpmemt, dpmemh, dpmemsize);
	if (status & IOMEM_MAPPED)
		bus_space_unmap(iomemt, iomemh, iomembase);
	if (status & IO_MAPPED)
		bus_space_unmap(iot, ioh, iosize);
	if (status & INTR_ESTABLISHED)
		pci_intr_disestablish(pa->pa_pc, sc->sc_ih);
	return;
}

/* Enable interrupts */
void
gdt_pci_enable_intr(struct gdt_softc *sc)
{
	GDT_DPRINTF(GDT_D_INTR, ("gdt_pci_enable_intr(%p) ", sc));

	switch(GDT_CLASS(sc)) {
	case GDT_PCI:
		bus_space_write_1(sc->sc_dpmemt, sc->sc_dpmemh, GDT_IRQDEL,
		    1);
		bus_space_write_1(sc->sc_dpmemt, sc->sc_dpmemh,
		    GDT_CMD_INDEX, 0);
		bus_space_write_1(sc->sc_dpmemt, sc->sc_dpmemh, GDT_IRQEN,
		    1);
		break;

	case GDT_PCINEW:
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, GDT_EDOOR_REG,
		    0xff);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, GDT_CONTROL1, 3);
		break;

	case GDT_MPR:
		bus_space_write_1(sc->sc_dpmemt, sc->sc_dpmemh,
		    GDT_MPR_EDOOR, 0xff);
		bus_space_write_1(sc->sc_dpmemt, sc->sc_dpmemh, GDT_EDOOR_EN,
		    bus_space_read_1(sc->sc_dpmemt, sc->sc_dpmemh,
		    GDT_EDOOR_EN) & ~4);
		break;
	}
}

/*
 * "old" PCI controller-specific functions
 */

void
gdt_pci_copy_cmd(struct gdt_softc *sc, struct gdt_ccb *ccb)
{
	/* XXX Not yet implemented */
}

u_int8_t
gdt_pci_get_status(struct gdt_softc *sc)
{
	/* XXX Not yet implemented */
	return (0);
}

void
gdt_pci_intr(struct gdt_softc *sc, struct gdt_intr_ctx *ctx)
{
	/* XXX Not yet implemented */
}

void
gdt_pci_release_event(struct gdt_softc *sc, struct gdt_ccb *ccb)
{
	/* XXX Not yet implemented */
}

void
gdt_pci_set_sema0(struct gdt_softc *sc)
{
	bus_space_write_1(sc->sc_dpmemt, sc->sc_dpmemh, GDT_SEMA0, 1);
}

int
gdt_pci_test_busy(struct gdt_softc *sc)
{
	/* XXX Not yet implemented */
	return (0);
}

/*
 * "new" PCI controller-specific functions
 */

void
gdt_pcinew_copy_cmd(struct gdt_softc *sc, struct gdt_ccb *ccb)
{
	/* XXX Not yet implemented */
}

u_int8_t
gdt_pcinew_get_status(struct gdt_softc *sc)
{
	/* XXX Not yet implemented */
	return (0);
}

void
gdt_pcinew_intr(struct gdt_softc *sc, struct gdt_intr_ctx *ctx)
{
	/* XXX Not yet implemented */
}

void
gdt_pcinew_release_event(struct gdt_softc *sc, struct gdt_ccb *ccb)
{
	/* XXX Not yet implemented */
}

void
gdt_pcinew_set_sema0(struct gdt_softc *sc)
{
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, GDT_SEMA0_REG, 1);
}

int
gdt_pcinew_test_busy(struct gdt_softc *sc)
{
	/* XXX Not yet implemented */
	return (0);
}

/*
 * MPR PCI controller-specific functions
 */

void
gdt_mpr_copy_cmd(struct gdt_softc *sc, struct gdt_ccb *ccb)
{
	u_int16_t cp_count = roundup(sc->sc_cmd_len, sizeof (u_int32_t));
	u_int16_t dp_offset = sc->sc_cmd_off;
	u_int16_t cmd_no = sc->sc_cmd_cnt++;

	GDT_DPRINTF(GDT_D_CMD, ("gdt_mpr_copy_cmd(%p) ", sc));

	sc->sc_cmd_off += cp_count;

	bus_space_write_2(sc->sc_dpmemt, sc->sc_dpmemh,
	    GDT_MPR_IC + GDT_COMM_QUEUE + cmd_no * GDT_COMM_Q_SZ + GDT_OFFSET,
	    GDT_DPMEM_COMMAND_OFFSET + dp_offset);
	bus_space_write_2(sc->sc_dpmemt, sc->sc_dpmemh,
	    GDT_MPR_IC + GDT_COMM_QUEUE + cmd_no * GDT_COMM_Q_SZ + GDT_SERV_ID,
	    ccb->gc_service);
	bus_space_write_raw_region_4(sc->sc_dpmemt, sc->sc_dpmemh,
	    GDT_MPR_IC + GDT_DPR_CMD + dp_offset, sc->sc_cmd, cp_count);
}

u_int8_t
gdt_mpr_get_status(struct gdt_softc *sc)
{
	GDT_DPRINTF(GDT_D_MISC, ("gdt_mpr_get_status(%p) ", sc));

	return bus_space_read_1(sc->sc_dpmemt, sc->sc_dpmemh, GDT_MPR_EDOOR);
}

void
gdt_mpr_intr(struct gdt_softc *sc, struct gdt_intr_ctx *ctx)
{
	GDT_DPRINTF(GDT_D_INTR, ("gdt_mpr_intr(%p) ", sc));

	if (ctx->istatus & 0x80) {		/* error flag */
		ctx->istatus &= ~0x80;
		ctx->cmd_status = bus_space_read_2(sc->sc_dpmemt,
		    sc->sc_dpmemh, GDT_MPR_STATUS);
		if (ctx->istatus == GDT_ASYNCINDEX) {
			ctx->service = bus_space_read_2(sc->sc_dpmemt,
			    sc->sc_dpmemh, GDT_MPR_SERVICE);
			ctx->info2 = bus_space_read_4(sc->sc_dpmemt,
			    sc->sc_dpmemh, GDT_MPR_INFO + sizeof (u_int32_t));
		}
	} else					/* no error */
		ctx->cmd_status = GDT_S_OK;

	ctx->info =
	    bus_space_read_4(sc->sc_dpmemt, sc->sc_dpmemh, GDT_MPR_INFO);

	if (gdt_polling)			/* init. -> more info */
		ctx->info2 = bus_space_read_4(sc->sc_dpmemt, sc->sc_dpmemh,
		    GDT_MPR_INFO + sizeof (u_int32_t));
	bus_space_write_1(sc->sc_dpmemt, sc->sc_dpmemh, GDT_MPR_EDOOR, 0xff);
	bus_space_write_1(sc->sc_dpmemt, sc->sc_dpmemh, GDT_MPR_SEMA1, 0);
}

void
gdt_mpr_release_event(struct gdt_softc *sc, struct gdt_ccb *ccb)
{
	GDT_DPRINTF(GDT_D_MISC, ("gdt_mpr_release_event(%p) ", sc));

	if (gdt_dec16(sc->sc_cmd + GDT_CMD_OPCODE) == GDT_INIT)
		ccb->gc_service |= 0x80;
	bus_space_write_1(sc->sc_dpmemt, sc->sc_dpmemh, GDT_MPR_LDOOR, 1);
}

void
gdt_mpr_set_sema0(struct gdt_softc *sc)
{
	GDT_DPRINTF(GDT_D_MISC, ("gdt_mpr_set_sema0(%p) ", sc));

	bus_space_write_1(sc->sc_dpmemt, sc->sc_dpmemh, GDT_MPR_SEMA0, 1);
}

int
gdt_mpr_test_busy(struct gdt_softc *sc)
{
	GDT_DPRINTF(GDT_D_MISC, ("gdt_mpr_test_busy(%p) ", sc));

	return (bus_space_read_1(sc->sc_dpmemt, sc->sc_dpmemh,
	    GDT_MPR_SEMA0) & 1);
}
@


1.24
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.23 2014/05/04 20:09:15 sf Exp $	*/
a40 1
#include <machine/intr.h>
@


1.23
log
@format string fixes for bus_addr_t and bus_size_t

bus_addr_t and bus_size_t are u_long everywhere

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.22 2009/03/29 21:53:52 sthen Exp $	*/
d38 1
a40 1
#include <machine/endian.h>
@


1.22
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.21 2007/10/17 02:51:39 fgsch Exp $	*/
d448 1
a448 1
			printf("cannot access DPMEM at 0x%x (shadowed?)\n",
@


1.21
log
@use ansi declarations and rename gdt to sc to avoid shadows and follow
what other drivers do; no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.20 2006/02/24 00:04:27 brad Exp $	*/
d280 1
a280 1
			printf("cannot map memory mapped I/O ports\n");
d287 1
a287 1
			printf("cannot map I/O ports\n");
d301 1
a301 1
			printf("cannot write to DPMEM\n");
@


1.20
log
@use some define's for the PCI ids and add another ICP Vortex PCI id.

PCI id from the Linux gdth driver.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.19 2003/08/06 21:08:06 millert Exp $	*/
d152 1
a152 3
gdt_pci_probe(parent, match, aux)
        struct device *parent;
        void *match, *aux;
d170 1
a170 3
gdt_pci_attach(parent, self, aux)
        struct device *parent, *self;
        void *aux;
d173 1
a173 1
	struct gdt_softc *gdt = (void *)self;
d191 1
a191 1
	gdt->sc_class = 0;
d197 1
a197 1
			gdt->sc_class = GDT_PCI;
d212 1
a212 1
			gdt->sc_class = GDT_PCINEW;
d241 1
a241 1
			gdt->sc_class = GDT_MPR;
d245 2
a246 2
		if (gdt->sc_class == 0)
			gdt->sc_class = prod < 0x100 ? GDT_PCINEW : GDT_MPR;
d249 1
a249 1
			gdt->sc_class |= GDT_FC;
d252 1
a252 1
		gdt->sc_class = GDT_MPR;
d256 1
a256 1
	    GDT_CLASS(gdt) == GDT_PCINEW ? GDT_PCINEW_DPMEM : GDT_PCI_DPMEM,
d260 1
a260 1
		    GDT_CLASS(gdt) == GDT_PCINEW ? GDT_PCINEW_DPMEM :
d269 4
a272 4
	gdt->sc_dpmemt = dpmemt;
	gdt->sc_dpmemh = dpmemh;
	gdt->sc_dpmembase = dpmembase;
	gdt->sc_dmat = pa->pa_dmat;
d277 1
a277 1
	if (GDT_CLASS(gdt) == GDT_PCINEW) {
d291 3
a293 3
		gdt->sc_iot = iot;
		gdt->sc_ioh = ioh;
		gdt->sc_iobase = iobase;
d296 1
a296 1
	switch (GDT_CLASS(gdt)) {
d358 1
a358 1
		gdt->sc_ic_all_size = GDT_DPRAM_SZ;
d360 6
a365 6
		gdt->sc_copy_cmd = gdt_pci_copy_cmd;
		gdt->sc_get_status = gdt_pci_get_status;
		gdt->sc_intr = gdt_pci_intr;
		gdt->sc_release_event = gdt_pci_release_event;
		gdt->sc_set_sema0 = gdt_pci_set_sema0;
		gdt->sc_test_busy = gdt_pci_test_busy;
d433 1
a433 1
		gdt->sc_ic_all_size = GDT_PCINEW_SZ;
d435 6
a440 6
		gdt->sc_copy_cmd = gdt_pcinew_copy_cmd;
		gdt->sc_get_status = gdt_pcinew_get_status;
		gdt->sc_intr = gdt_pcinew_intr;
		gdt->sc_release_event = gdt_pcinew_release_event;
		gdt->sc_set_sema0 = gdt_pcinew_set_sema0;
		gdt->sc_test_busy = gdt_pcinew_test_busy;
d526 1
a526 1
		gdt->sc_ic_all_size = GDT_MPR_SZ;
d528 6
a533 6
		gdt->sc_copy_cmd = gdt_mpr_copy_cmd;
		gdt->sc_get_status = gdt_mpr_get_status;
		gdt->sc_intr = gdt_mpr_intr;
		gdt->sc_release_event = gdt_mpr_release_event;
		gdt->sc_set_sema0 = gdt_mpr_set_sema0;
		gdt->sc_test_busy = gdt_mpr_test_busy;
d541 3
a543 3
	gdt->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, gdt_intr, gdt,
	    gdt->sc_dev.dv_xname);
	if (gdt->sc_ih == NULL) {
d554 1
a554 1
	if (gdt_attach(gdt))
d557 1
a557 1
	gdt_pci_enable_intr(gdt);
d569 1
a569 1
		pci_intr_disestablish(pa->pa_pc, gdt->sc_ih);
d575 1
a575 2
gdt_pci_enable_intr(gdt)
	struct gdt_softc *gdt;
d577 1
a577 1
	GDT_DPRINTF(GDT_D_INTR, ("gdt_pci_enable_intr(%p) ", gdt));
d579 1
a579 1
	switch(GDT_CLASS(gdt)) {
d581 1
a581 1
		bus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_IRQDEL,
d583 1
a583 1
		bus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh,
d585 1
a585 1
		bus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_IRQEN,
d590 1
a590 1
		bus_space_write_1(gdt->sc_iot, gdt->sc_ioh, GDT_EDOOR_REG,
d592 1
a592 1
		bus_space_write_1(gdt->sc_iot, gdt->sc_ioh, GDT_CONTROL1, 3);
d596 1
a596 1
		bus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh,
d598 2
a599 2
		bus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_EDOOR_EN,
		    bus_space_read_1(gdt->sc_dpmemt, gdt->sc_dpmemh,
d610 1
a610 3
gdt_pci_copy_cmd(gdt, ccb)
	struct gdt_softc *gdt;
	struct gdt_ccb *ccb;
d616 1
a616 2
gdt_pci_get_status(gdt)
	struct gdt_softc *gdt;
d623 1
a623 3
gdt_pci_intr(gdt, ctx)
	struct gdt_softc *gdt;
	struct gdt_intr_ctx *ctx;
d629 1
a629 3
gdt_pci_release_event(gdt, ccb)
	struct gdt_softc *gdt;
	struct gdt_ccb *ccb;
d635 1
a635 2
gdt_pci_set_sema0(gdt)
	struct gdt_softc *gdt;
d637 1
a637 1
	bus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_SEMA0, 1);
d641 1
a641 2
gdt_pci_test_busy(gdt)
	struct gdt_softc *gdt;
d652 1
a652 3
gdt_pcinew_copy_cmd(gdt, ccb)
	struct gdt_softc *gdt;
	struct gdt_ccb *ccb;
d658 1
a658 2
gdt_pcinew_get_status(gdt)
	struct gdt_softc *gdt;
d665 1
a665 3
gdt_pcinew_intr(gdt, ctx)
	struct gdt_softc *gdt;
	struct gdt_intr_ctx *ctx;
d671 1
a671 3
gdt_pcinew_release_event(gdt, ccb)
	struct gdt_softc *gdt;
	struct gdt_ccb *ccb;
d677 1
a677 2
gdt_pcinew_set_sema0(gdt)
	struct gdt_softc *gdt;
d679 1
a679 1
	bus_space_write_1(gdt->sc_iot, gdt->sc_ioh, GDT_SEMA0_REG, 1);
d683 1
a683 2
gdt_pcinew_test_busy(gdt)
	struct gdt_softc *gdt;
d694 1
a694 3
gdt_mpr_copy_cmd(gdt, ccb)
	struct gdt_softc *gdt;
	struct gdt_ccb *ccb;
d696 3
a698 3
	u_int16_t cp_count = roundup(gdt->sc_cmd_len, sizeof (u_int32_t));
	u_int16_t dp_offset = gdt->sc_cmd_off;
	u_int16_t cmd_no = gdt->sc_cmd_cnt++;
d700 1
a700 1
	GDT_DPRINTF(GDT_D_CMD, ("gdt_mpr_copy_cmd(%p) ", gdt));
d702 1
a702 1
	gdt->sc_cmd_off += cp_count;
d704 1
a704 1
	bus_space_write_2(gdt->sc_dpmemt, gdt->sc_dpmemh,
d707 1
a707 1
	bus_space_write_2(gdt->sc_dpmemt, gdt->sc_dpmemh,
d710 2
a711 2
	bus_space_write_raw_region_4(gdt->sc_dpmemt, gdt->sc_dpmemh,
	    GDT_MPR_IC + GDT_DPR_CMD + dp_offset, gdt->sc_cmd, cp_count);
d715 1
a715 2
gdt_mpr_get_status(gdt)
	struct gdt_softc *gdt;
d717 1
a717 1
	GDT_DPRINTF(GDT_D_MISC, ("gdt_mpr_get_status(%p) ", gdt));
d719 1
a719 1
	return bus_space_read_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_MPR_EDOOR);
d723 1
a723 3
gdt_mpr_intr(gdt, ctx)
	struct gdt_softc *gdt;
	struct gdt_intr_ctx *ctx;
d725 1
a725 1
	GDT_DPRINTF(GDT_D_INTR, ("gdt_mpr_intr(%p) ", gdt));
d729 2
a730 2
		ctx->cmd_status = bus_space_read_2(gdt->sc_dpmemt,
		    gdt->sc_dpmemh, GDT_MPR_STATUS);
d732 4
a735 4
			ctx->service = bus_space_read_2(gdt->sc_dpmemt,
			    gdt->sc_dpmemh, GDT_MPR_SERVICE);
			ctx->info2 = bus_space_read_4(gdt->sc_dpmemt,
			    gdt->sc_dpmemh, GDT_MPR_INFO + sizeof (u_int32_t));
d741 1
a741 1
	    bus_space_read_4(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_MPR_INFO);
d744 1
a744 1
		ctx->info2 = bus_space_read_4(gdt->sc_dpmemt, gdt->sc_dpmemh,
d746 2
a747 2
	bus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_MPR_EDOOR, 0xff);
	bus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_MPR_SEMA1, 0);
d751 1
a751 3
gdt_mpr_release_event(gdt, ccb)
	struct gdt_softc *gdt;
	struct gdt_ccb *ccb;
d753 1
a753 1
	GDT_DPRINTF(GDT_D_MISC, ("gdt_mpr_release_event(%p) ", gdt));
d755 1
a755 1
	if (gdt_dec16(gdt->sc_cmd + GDT_CMD_OPCODE) == GDT_INIT)
d757 1
a757 1
	bus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_MPR_LDOOR, 1);
d761 1
a761 2
gdt_mpr_set_sema0(gdt)
	struct gdt_softc *gdt;
d763 1
a763 1
	GDT_DPRINTF(GDT_D_MISC, ("gdt_mpr_set_sema0(%p) ", gdt));
d765 1
a765 1
	bus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_MPR_SEMA0, 1);
d769 1
a769 2
gdt_mpr_test_busy(gdt)
	struct gdt_softc *gdt;
d771 1
a771 1
	GDT_DPRINTF(GDT_D_MISC, ("gdt_mpr_test_busy(%p) ", gdt));
d773 1
a773 1
	return (bus_space_read_1(gdt->sc_dpmemt, gdt->sc_dpmemh,
@


1.19
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.18 2003/06/03 20:49:29 deraadt Exp $	*/
d56 5
d159 4
a162 1
	    PCI_PRODUCT(pa->pa_id) >= 0x100 && PCI_PRODUCT(pa->pa_id) <= 0x300)
@


1.18
log
@fix various 3/4 licenses according to "terms" file
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.17 2002/06/11 14:41:35 niklas Exp $	*/
d304 1
a304 1
		gdth_writeb(0x00, &dp6_ptr->io.irqen);;
@


1.17
log
@more debugging info
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.16 2002/06/11 03:05:53 niklas Exp $	*/
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Niklas Hallqvist.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.16
log
@Remove redundant endianess conversions
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.15 2002/06/06 19:33:00 niklas Exp $	*/
d484 3
a486 1
				printf("DEINIT failed\n");
@


1.15
log
@match more cards
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.14 2002/03/14 01:26:58 millert Exp $	*/
d299 1
a299 1
		bus_space_set_region_4(dpmemt, dpmemh, 0, htole32(0),
d371 1
a371 1
		bus_space_set_region_4(dpmemt, dpmemh, 0, htole32(0),
d446 1
a446 2
		bus_space_write_4(dpmemt, dpmemh, GDT_MPR_IC,
		    htole32(GDT_MPR_MAGIC));
d448 1
a448 1
		    htole32(GDT_MPR_MAGIC)) {
d461 1
a461 1
		bus_space_set_region_4(dpmemt, dpmemh, GDT_I960_SZ, htole32(0),
d474 1
a474 1
		    htole32(dpmembase));
d490 2
a491 2
		protocol = (u_int8_t)letoh32(bus_space_read_4(dpmemt, dpmemh,
		    GDT_MPR_IC + GDT_S_INFO));
d500 1
a500 2
		bus_space_write_4(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_INFO,
		    htole32(0));
d502 1
a502 1
		    GDT_MPR_IC + GDT_S_INFO + sizeof (u_int32_t), htole32(0));
d504 1
a504 2
		    GDT_MPR_IC + GDT_S_INFO + 2 * sizeof (u_int32_t),
		    htole32(1));
d506 1
a506 2
		    GDT_MPR_IC + GDT_S_INFO + 3 * sizeof (u_int32_t),
		    htole32(0));
d726 1
a726 1
	    htole16(GDT_DPMEM_COMMAND_OFFSET + dp_offset));
d729 1
a729 1
	    htole16(ccb->gc_service));
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.13 2001/08/25 10:13:29 art Exp $	*/
d159 1
a159 1
	    PCI_PRODUCT(pa->pa_id) >= 0x100 && PCI_PRODUCT(pa->pa_id) <= 0x2ff)
d162 2
a163 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_GDT_RAID2)
@


1.13
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.12 2001/07/30 01:28:56 deraadt Exp $	*/
d122 24
a145 24
int	gdt_pci_probe __P((struct device *, void *, void *));
void	gdt_pci_attach __P((struct device *, struct device *, void *));
void	gdt_pci_enable_intr __P((struct gdt_softc *));

void	gdt_pci_copy_cmd __P((struct gdt_softc *, struct gdt_ccb *));
u_int8_t gdt_pci_get_status __P((struct gdt_softc *));
void	gdt_pci_intr __P((struct gdt_softc *, struct gdt_intr_ctx *));
void	gdt_pci_release_event __P((struct gdt_softc *, struct gdt_ccb *));
void	gdt_pci_set_sema0 __P((struct gdt_softc *));
int	gdt_pci_test_busy __P((struct gdt_softc *));

void	gdt_pcinew_copy_cmd __P((struct gdt_softc *, struct gdt_ccb *));
u_int8_t gdt_pcinew_get_status __P((struct gdt_softc *));
void	gdt_pcinew_intr __P((struct gdt_softc *, struct gdt_intr_ctx *));
void	gdt_pcinew_release_event __P((struct gdt_softc *, struct gdt_ccb *));
void	gdt_pcinew_set_sema0 __P((struct gdt_softc *));
int	gdt_pcinew_test_busy __P((struct gdt_softc *));

void	gdt_mpr_copy_cmd __P((struct gdt_softc *, struct gdt_ccb *));
u_int8_t gdt_mpr_get_status __P((struct gdt_softc *));
void	gdt_mpr_intr __P((struct gdt_softc *, struct gdt_intr_ctx *));
void	gdt_mpr_release_event __P((struct gdt_softc *, struct gdt_ccb *));
void	gdt_mpr_set_sema0 __P((struct gdt_softc *));
int	gdt_mpr_test_busy __P((struct gdt_softc *));
@


1.13.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.13 2001/08/25 10:13:29 art Exp $	*/
d122 24
a145 24
int	gdt_pci_probe(struct device *, void *, void *);
void	gdt_pci_attach(struct device *, struct device *, void *);
void	gdt_pci_enable_intr(struct gdt_softc *);

void	gdt_pci_copy_cmd(struct gdt_softc *, struct gdt_ccb *);
u_int8_t gdt_pci_get_status(struct gdt_softc *);
void	gdt_pci_intr(struct gdt_softc *, struct gdt_intr_ctx *);
void	gdt_pci_release_event(struct gdt_softc *, struct gdt_ccb *);
void	gdt_pci_set_sema0(struct gdt_softc *);
int	gdt_pci_test_busy(struct gdt_softc *);

void	gdt_pcinew_copy_cmd(struct gdt_softc *, struct gdt_ccb *);
u_int8_t gdt_pcinew_get_status(struct gdt_softc *);
void	gdt_pcinew_intr(struct gdt_softc *, struct gdt_intr_ctx *);
void	gdt_pcinew_release_event(struct gdt_softc *, struct gdt_ccb *);
void	gdt_pcinew_set_sema0(struct gdt_softc *);
int	gdt_pcinew_test_busy(struct gdt_softc *);

void	gdt_mpr_copy_cmd(struct gdt_softc *, struct gdt_ccb *);
u_int8_t gdt_mpr_get_status(struct gdt_softc *);
void	gdt_mpr_intr(struct gdt_softc *, struct gdt_intr_ctx *);
void	gdt_mpr_release_event(struct gdt_softc *, struct gdt_ccb *);
void	gdt_mpr_set_sema0(struct gdt_softc *);
int	gdt_mpr_test_busy(struct gdt_softc *);
d159 1
a159 1
	    PCI_PRODUCT(pa->pa_id) >= 0x100 && PCI_PRODUCT(pa->pa_id) <= 0x300)
d162 1
a162 2
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_GDT_RAID1 ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_GDT_RAID2))
@


1.13.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.13.4.1 2002/06/11 03:42:24 art Exp $	*/
d299 1
a299 1
		bus_space_set_region_4(dpmemt, dpmemh, 0, 0,
d371 1
a371 1
		bus_space_set_region_4(dpmemt, dpmemh, 0, 0,
d446 2
a447 1
		bus_space_write_4(dpmemt, dpmemh, GDT_MPR_IC, GDT_MPR_MAGIC);
d449 1
a449 1
		    GDT_MPR_MAGIC) {
d462 1
a462 1
		bus_space_set_region_4(dpmemt, dpmemh, GDT_I960_SZ, 0,
d475 1
a475 1
		    dpmembase);
d485 1
a485 3
				printf("DEINIT failed (status 0x%x)\n",
				    bus_space_read_1(dpmemt, dpmemh,
				    GDT_MPR_IC + GDT_S_STATUS));
d491 2
a492 2
		protocol = (u_int8_t)bus_space_read_4(dpmemt, dpmemh,
		    GDT_MPR_IC + GDT_S_INFO);
d501 2
a502 1
		bus_space_write_4(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_INFO, 0);
d504 1
a504 1
		    GDT_MPR_IC + GDT_S_INFO + sizeof (u_int32_t), 0);
d506 2
a507 1
		    GDT_MPR_IC + GDT_S_INFO + 2 * sizeof (u_int32_t), 1);
d509 2
a510 1
		    GDT_MPR_IC + GDT_S_INFO + 3 * sizeof (u_int32_t), 0);
d730 1
a730 1
	    GDT_DPMEM_COMMAND_OFFSET + dp_offset);
d733 1
a733 1
	    ccb->gc_service);
@


1.12
log
@attempt to match intel
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.11 2001/06/12 15:40:30 niklas Exp $	*/
d538 1
a538 2
	if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.11
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.10 2001/05/07 19:43:14 deraadt Exp $	*/
d161 3
d192 60
a251 48
	prod = PCI_PRODUCT(pa->pa_id);
	switch (prod) {
	case PCI_PRODUCT_VORTEX_GDT_60x0:
	case PCI_PRODUCT_VORTEX_GDT_6000B:
		gdt->sc_class = GDT_PCI;
		break;

	case PCI_PRODUCT_VORTEX_GDT_6x10:
	case PCI_PRODUCT_VORTEX_GDT_6x20:
	case PCI_PRODUCT_VORTEX_GDT_6530:
	case PCI_PRODUCT_VORTEX_GDT_6550:
	case PCI_PRODUCT_VORTEX_GDT_6x17:
	case PCI_PRODUCT_VORTEX_GDT_6x27:
	case PCI_PRODUCT_VORTEX_GDT_6537:
	case PCI_PRODUCT_VORTEX_GDT_6557:
	case PCI_PRODUCT_VORTEX_GDT_6x15:
	case PCI_PRODUCT_VORTEX_GDT_6x25:
	case PCI_PRODUCT_VORTEX_GDT_6535:
	case PCI_PRODUCT_VORTEX_GDT_6555:
		gdt->sc_class = GDT_PCINEW;
		break;

	case PCI_PRODUCT_VORTEX_GDT_6x17RP:
	case PCI_PRODUCT_VORTEX_GDT_6x27RP:
	case PCI_PRODUCT_VORTEX_GDT_6537RP:
	case PCI_PRODUCT_VORTEX_GDT_6557RP:
	case PCI_PRODUCT_VORTEX_GDT_6x11RP:
	case PCI_PRODUCT_VORTEX_GDT_6x21RP:
	case PCI_PRODUCT_VORTEX_GDT_6x17RD:
	case PCI_PRODUCT_VORTEX_GDT_6x27RD:
	case PCI_PRODUCT_VORTEX_GDT_6537RD:
	case PCI_PRODUCT_VORTEX_GDT_6557RD:
	case PCI_PRODUCT_VORTEX_GDT_6x11RD:
	case PCI_PRODUCT_VORTEX_GDT_6x21RD:
	case PCI_PRODUCT_VORTEX_GDT_6x18RD:
	case PCI_PRODUCT_VORTEX_GDT_6x28RD:
	case PCI_PRODUCT_VORTEX_GDT_6x38RD:
	case PCI_PRODUCT_VORTEX_GDT_6x58RD:
	case PCI_PRODUCT_VORTEX_GDT_6518RS:
	case PCI_PRODUCT_VORTEX_GDT_7x18RN:
	case PCI_PRODUCT_VORTEX_GDT_7x28RN:
	case PCI_PRODUCT_VORTEX_GDT_7x38RN:
	case PCI_PRODUCT_VORTEX_GDT_7x58RN:
	case PCI_PRODUCT_VORTEX_GDT_6x19RD:
	case PCI_PRODUCT_VORTEX_GDT_6x29RD:
	case PCI_PRODUCT_VORTEX_GDT_7x19RN:
	case PCI_PRODUCT_VORTEX_GDT_7x29RN:
	case PCI_PRODUCT_VORTEX_GDT_7x43RN:
a253 7

	/* If we don't recognize it, determine class heuristically.  */
	if (gdt->sc_class == 0)
		gdt->sc_class = prod < 0x100 ? GDT_PCINEW : GDT_MPR;

	if (prod >= GDT_PCI_PRODUCT_FC)
		gdt->sc_class |= GDT_FC;
@


1.10
log
@7x43RN are MPR
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.9 2000/11/10 09:42:15 niklas Exp $	*/
d250 1
a250 1
	    &dpmemh, &dpmembase, &dpmemsize)) {
d255 1
a255 1
		    &dpmemt,&dpmemh, &dpmembase, &dpmemsize)) {
d271 1
a271 1
		    0, &iomemt, &iomemh, &iomembase, &iomemsize)) {
d278 1
a278 1
		    &iot, &ioh, &iobase, &iosize)) {
@


1.9
log
@improved queue handling + some small bug fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.8 2000/09/19 08:43:37 niklas Exp $	*/
d236 1
@


1.8
log
@trailing spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.7 2000/08/05 18:49:30 niklas Exp $	*/
d310 1
a310 1
		    printk("GDT-PCI: Initialization error (DEINIT failed)\n");
d320 1
a320 1
		  printk("GDT-PCI: Illegal protocol version\n");
d339 1
a339 1
		    printk("GDT-PCI: Initialization error\n");
d385 1
a385 1
		    printk("GDT-PCI: Initialization error (DEINIT failed)\n");
d394 1
a394 1
		  printk("GDT-PCI: Illegal protocol version\n");
d415 1
a415 1
		    printk("GDT-PCI: Initialization error\n");
@


1.7
log
@Be more liberal about attaching products unknown to us (we have got ID
ranges from ICP-Vortex).  New GDT products are normally configured with
"Do not move DPMEM" as default, so try that mapping type first.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.6 2000/08/03 21:33:12 niklas Exp $	*/
d154 2
a155 2
        void *match, *aux; 
{       
d164 1
a164 1
void    
d327 1
a327 1
        
d372 1
a372 1
        
d408 1
a408 1
        
@


1.6
log
@(c) 2000
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.5 2000/08/03 21:29:39 niklas Exp $	*/
d158 3
a160 43
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VORTEX)
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_VORTEX_GDT_60x0:
		case PCI_PRODUCT_VORTEX_GDT_6000B:
		case PCI_PRODUCT_VORTEX_GDT_6x10:
		case PCI_PRODUCT_VORTEX_GDT_6x20:
		case PCI_PRODUCT_VORTEX_GDT_6530:
		case PCI_PRODUCT_VORTEX_GDT_6550:
		case PCI_PRODUCT_VORTEX_GDT_6x17:
		case PCI_PRODUCT_VORTEX_GDT_6x27:
		case PCI_PRODUCT_VORTEX_GDT_6537:
		case PCI_PRODUCT_VORTEX_GDT_6557:
		case PCI_PRODUCT_VORTEX_GDT_6x15:
		case PCI_PRODUCT_VORTEX_GDT_6x25:
		case PCI_PRODUCT_VORTEX_GDT_6535:
		case PCI_PRODUCT_VORTEX_GDT_6555:
		case PCI_PRODUCT_VORTEX_GDT_6x17RP:
		case PCI_PRODUCT_VORTEX_GDT_6x27RP:
		case PCI_PRODUCT_VORTEX_GDT_6537RP:
		case PCI_PRODUCT_VORTEX_GDT_6557RP:
		case PCI_PRODUCT_VORTEX_GDT_6x11RP:
		case PCI_PRODUCT_VORTEX_GDT_6x21RP:
		case PCI_PRODUCT_VORTEX_GDT_6x17RD:
		case PCI_PRODUCT_VORTEX_GDT_6x27RD:
		case PCI_PRODUCT_VORTEX_GDT_6537RD:
		case PCI_PRODUCT_VORTEX_GDT_6557RD:
		case PCI_PRODUCT_VORTEX_GDT_6x11RD:
		case PCI_PRODUCT_VORTEX_GDT_6x21RD:
		case PCI_PRODUCT_VORTEX_GDT_6x18RD:
		case PCI_PRODUCT_VORTEX_GDT_6x28RD:
		case PCI_PRODUCT_VORTEX_GDT_6x38RD:
		case PCI_PRODUCT_VORTEX_GDT_6x58RD:
		case PCI_PRODUCT_VORTEX_GDT_6518RS:
		case PCI_PRODUCT_VORTEX_GDT_7x18RN:
		case PCI_PRODUCT_VORTEX_GDT_7x28RN:
		case PCI_PRODUCT_VORTEX_GDT_7x38RN:
		case PCI_PRODUCT_VORTEX_GDT_7x58RN:
		case PCI_PRODUCT_VORTEX_GDT_6x19RD:
		case PCI_PRODUCT_VORTEX_GDT_6x29RD:
		case PCI_PRODUCT_VORTEX_GDT_7x19RN:
		case PCI_PRODUCT_VORTEX_GDT_7x29RN:
			return (1);
		}
d188 1
d238 5
d248 1
a248 1
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT_1M, 0, &dpmemt,
d253 1
a253 1
		    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,
@


1.5
log
@Support for GDT6518RS added.  Thanks Jeff!  Also fixed a few bogus prodids.
BTW, more RS controllers will need to be added, but I do not yet know the
prodids.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.4 2000/08/01 00:18:37 niklas Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999 Niklas Hallqvist.  All rights reserved.
@


1.4
log
@Make driver attach no matter the setting of jumper S4.
This solves the "cannot map DPMEM" problem some people have been seeing.
Still there is an ugly printout while configuring if S4 is out, I do not
know how to pretty that one just yet.  Howevr it is just a cosmetic thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.3 2000/03/01 22:38:51 niklas Exp $	*/
d190 1
d266 1
@


1.3
log
@Proper bus_dma usage, fixes cache incosistencies
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.2 2000/02/13 10:59:06 niklas Exp $	*/
d282 8
a289 2
		printf("cannot map DPMEM\n");
		goto bail_out;
@


1.3.2.1
log
@Pull in patches from current:
Fixes (niklas):
- Be more liberal about attaching products unknown to us (we have got ID
ranges from ICP-Vortex).  New GDT products are normally configured with
"Do not move DPMEM" as default, so try that mapping type first.
- (c) 2000
- Support for GDT6518RS added.  Thanks Jeff!  Also fixed a few bogus prodids.
BTW, more RS controllers will need to be added, but I do not yet know the
prodids.
- Make driver attach no matter the setting of jumper S4.
This solves the "cannot map DPMEM" problem some people have been seeing.
Still there is an ugly printout while configuring if S4 is out, I do not
know how to pretty that one just yet.  Howevr it is just a cosmetic thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.7 2000/08/05 18:49:30 niklas Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999, 2000 Niklas Hallqvist.  All rights reserved.
d158 42
a199 3
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VORTEX &&
	    PCI_PRODUCT(pa->pa_id) >= 0x100 && PCI_PRODUCT(pa->pa_id) <= 0x2ff)
		return (1);
a226 1
	gdt->sc_class = 0;
a264 1
	case PCI_PRODUCT_VORTEX_GDT_6518RS:
a274 5

	/* If we don't recognize it, determine class heuristically.  */
	if (gdt->sc_class == 0)
		gdt->sc_class = prod < 0x100 ? GDT_PCINEW : GDT_MPR;

d280 1
a280 1
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0, &dpmemt,
d282 2
a283 8
		if (pci_mapreg_map(pa,
		    GDT_CLASS(gdt) == GDT_PCINEW ? GDT_PCINEW_DPMEM :
		    GDT_PCI_DPMEM,
		    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT_1M, 0,
		    &dpmemt,&dpmemh, &dpmembase, &dpmemsize)) {
			printf("cannot map DPMEM\n");
			goto bail_out;
		}
@


1.2
log
@Stupid typo that made errors hang the driver
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.1 2000/02/07 00:33:03 niklas Exp $	*/
d289 1
@


1.2.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.2 2000/02/13 10:59:06 niklas Exp $	*/
a288 1
	gdt->sc_dmat = pa->pa_dmat;
@


1.2.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.9 2000/11/10 09:42:15 niklas Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999, 2000 Niklas Hallqvist.  All rights reserved.
d154 2
a155 2
        void *match, *aux;
{
d158 42
a199 3
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VORTEX &&
	    PCI_PRODUCT(pa->pa_id) >= 0x100 && PCI_PRODUCT(pa->pa_id) <= 0x2ff)
		return (1);
d203 1
a203 1
void
a226 1
	gdt->sc_class = 0;
a264 1
	case PCI_PRODUCT_VORTEX_GDT_6518RS:
a274 5

	/* If we don't recognize it, determine class heuristically.  */
	if (gdt->sc_class == 0)
		gdt->sc_class = prod < 0x100 ? GDT_PCINEW : GDT_MPR;

d280 1
a280 1
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0, &dpmemt,
d282 2
a283 8
		if (pci_mapreg_map(pa,
		    GDT_CLASS(gdt) == GDT_PCINEW ? GDT_PCINEW_DPMEM :
		    GDT_PCI_DPMEM,
		    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT_1M, 0,
		    &dpmemt,&dpmemh, &dpmembase, &dpmemsize)) {
			printf("cannot map DPMEM\n");
			goto bail_out;
		}
d336 1
a336 1
		    printk("initialization error (DEINIT failed)\n");
d346 1
a346 1
		  printk("illegal protocol version\n");
d353 1
a353 1

d365 1
a365 1
		    printk("initialization error\n");
d398 1
a398 1

d411 1
a411 1
		    printk("initialization error (DEINIT failed)\n");
d420 1
a420 1
		  printk("illegal protocol version\n");
d434 1
a434 1

d441 1
a441 1
		    printk("initialization error\n");
@


1.2.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.2.2.2 2001/05/14 22:25:41 niklas Exp $	*/
a235 1
	case PCI_PRODUCT_VORTEX_GDT_7x43RN:
d249 1
a249 1
	    &dpmemh, &dpmembase, &dpmemsize, 0)) {
d254 1
a254 1
		    &dpmemt,&dpmemh, &dpmembase, &dpmemsize, 0)) {
d270 1
a270 1
		    0, &iomemt, &iomemh, &iomembase, &iomemsize, 0)) {
d277 1
a277 1
		    &iot, &ioh, &iobase, &iosize, 0)) {
@


1.2.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.2.2.3 2001/07/04 10:42:05 niklas Exp $	*/
a160 3
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_GDT_RAID2)
		return (1);
d189 6
a194 55
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VORTEX) {
		prod = PCI_PRODUCT(pa->pa_id);
		switch (prod) {
		case PCI_PRODUCT_VORTEX_GDT_60x0:
		case PCI_PRODUCT_VORTEX_GDT_6000B:
			gdt->sc_class = GDT_PCI;
			break;

		case PCI_PRODUCT_VORTEX_GDT_6x10:
		case PCI_PRODUCT_VORTEX_GDT_6x20:
		case PCI_PRODUCT_VORTEX_GDT_6530:
		case PCI_PRODUCT_VORTEX_GDT_6550:
		case PCI_PRODUCT_VORTEX_GDT_6x17:
		case PCI_PRODUCT_VORTEX_GDT_6x27:
		case PCI_PRODUCT_VORTEX_GDT_6537:
		case PCI_PRODUCT_VORTEX_GDT_6557:
		case PCI_PRODUCT_VORTEX_GDT_6x15:
		case PCI_PRODUCT_VORTEX_GDT_6x25:
		case PCI_PRODUCT_VORTEX_GDT_6535:
		case PCI_PRODUCT_VORTEX_GDT_6555:
			gdt->sc_class = GDT_PCINEW;
			break;

		case PCI_PRODUCT_VORTEX_GDT_6x17RP:
		case PCI_PRODUCT_VORTEX_GDT_6x27RP:
		case PCI_PRODUCT_VORTEX_GDT_6537RP:
		case PCI_PRODUCT_VORTEX_GDT_6557RP:
		case PCI_PRODUCT_VORTEX_GDT_6x11RP:
		case PCI_PRODUCT_VORTEX_GDT_6x21RP:
		case PCI_PRODUCT_VORTEX_GDT_6x17RD:
		case PCI_PRODUCT_VORTEX_GDT_6x27RD:
		case PCI_PRODUCT_VORTEX_GDT_6537RD:
		case PCI_PRODUCT_VORTEX_GDT_6557RD:
		case PCI_PRODUCT_VORTEX_GDT_6x11RD:
		case PCI_PRODUCT_VORTEX_GDT_6x21RD:
		case PCI_PRODUCT_VORTEX_GDT_6x18RD:
		case PCI_PRODUCT_VORTEX_GDT_6x28RD:
		case PCI_PRODUCT_VORTEX_GDT_6x38RD:
		case PCI_PRODUCT_VORTEX_GDT_6x58RD:
		case PCI_PRODUCT_VORTEX_GDT_6518RS:
		case PCI_PRODUCT_VORTEX_GDT_7x18RN:
		case PCI_PRODUCT_VORTEX_GDT_7x28RN:
		case PCI_PRODUCT_VORTEX_GDT_7x38RN:
		case PCI_PRODUCT_VORTEX_GDT_7x58RN:
		case PCI_PRODUCT_VORTEX_GDT_6x19RD:
		case PCI_PRODUCT_VORTEX_GDT_6x29RD:
		case PCI_PRODUCT_VORTEX_GDT_7x19RN:
		case PCI_PRODUCT_VORTEX_GDT_7x29RN:
		case PCI_PRODUCT_VORTEX_GDT_7x43RN:
			gdt->sc_class = GDT_MPR;
		}

		/* If we don't recognize it, determine class heuristically.  */
		if (gdt->sc_class == 0)
			gdt->sc_class = prod < 0x100 ? GDT_PCINEW : GDT_MPR;
d196 14
a209 2
		if (prod >= GDT_PCI_PRODUCT_FC)
			gdt->sc_class |= GDT_FC;
d211 26
a236 1
	} else if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL) {
d240 7
d530 2
a531 1
	if (pci_intr_map(pa, &ih)) {
@


1.2.2.5
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d122 24
a145 24
int	gdt_pci_probe(struct device *, void *, void *);
void	gdt_pci_attach(struct device *, struct device *, void *);
void	gdt_pci_enable_intr(struct gdt_softc *);

void	gdt_pci_copy_cmd(struct gdt_softc *, struct gdt_ccb *);
u_int8_t gdt_pci_get_status(struct gdt_softc *);
void	gdt_pci_intr(struct gdt_softc *, struct gdt_intr_ctx *);
void	gdt_pci_release_event(struct gdt_softc *, struct gdt_ccb *);
void	gdt_pci_set_sema0(struct gdt_softc *);
int	gdt_pci_test_busy(struct gdt_softc *);

void	gdt_pcinew_copy_cmd(struct gdt_softc *, struct gdt_ccb *);
u_int8_t gdt_pcinew_get_status(struct gdt_softc *);
void	gdt_pcinew_intr(struct gdt_softc *, struct gdt_intr_ctx *);
void	gdt_pcinew_release_event(struct gdt_softc *, struct gdt_ccb *);
void	gdt_pcinew_set_sema0(struct gdt_softc *);
int	gdt_pcinew_test_busy(struct gdt_softc *);

void	gdt_mpr_copy_cmd(struct gdt_softc *, struct gdt_ccb *);
u_int8_t gdt_mpr_get_status(struct gdt_softc *);
void	gdt_mpr_intr(struct gdt_softc *, struct gdt_intr_ctx *);
void	gdt_mpr_release_event(struct gdt_softc *, struct gdt_ccb *);
void	gdt_mpr_set_sema0(struct gdt_softc *);
int	gdt_mpr_test_busy(struct gdt_softc *);
@


1.2.2.6
log
@Sync the SMP branch with 3.3
@
text
@d159 1
a159 1
	    PCI_PRODUCT(pa->pa_id) >= 0x100 && PCI_PRODUCT(pa->pa_id) <= 0x300)
d162 1
a162 2
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_GDT_RAID1 ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_GDT_RAID2))
d298 1
a298 1
		bus_space_set_region_4(dpmemt, dpmemh, 0, 0,
d370 1
a370 1
		bus_space_set_region_4(dpmemt, dpmemh, 0, 0,
d445 2
a446 1
		bus_space_write_4(dpmemt, dpmemh, GDT_MPR_IC, GDT_MPR_MAGIC);
d448 1
a448 1
		    GDT_MPR_MAGIC) {
d461 1
a461 1
		bus_space_set_region_4(dpmemt, dpmemh, GDT_I960_SZ, 0,
d474 1
a474 1
		    dpmembase);
d484 1
a484 3
				printf("DEINIT failed (status 0x%x)\n",
				    bus_space_read_1(dpmemt, dpmemh,
				    GDT_MPR_IC + GDT_S_STATUS));
d490 2
a491 2
		protocol = (u_int8_t)bus_space_read_4(dpmemt, dpmemh,
		    GDT_MPR_IC + GDT_S_INFO);
d500 2
a501 1
		bus_space_write_4(dpmemt, dpmemh, GDT_MPR_IC + GDT_S_INFO, 0);
d503 1
a503 1
		    GDT_MPR_IC + GDT_S_INFO + sizeof (u_int32_t), 0);
d505 2
a506 1
		    GDT_MPR_IC + GDT_S_INFO + 2 * sizeof (u_int32_t), 1);
d508 2
a509 1
		    GDT_MPR_IC + GDT_S_INFO + 3 * sizeof (u_int32_t), 0);
d729 1
a729 1
	    GDT_DPMEM_COMMAND_OFFSET + dp_offset);
d732 1
a732 1
	    ccb->gc_service);
@


1.2.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt_pci.c,v 1.2.2.6 2003/03/28 00:38:21 niklas Exp $	*/
d14 5
@


1.2.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d304 1
a304 1
		gdth_writeb(0x00, &dp6_ptr->io.irqen);
@


1.1
log
@Rough but working driver for ICP-Vortex RAID
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d771 1
a771 1
		ctx->istatus &= 0x80;
@

