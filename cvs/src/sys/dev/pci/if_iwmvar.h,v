head	1.30;
access;
symbols
	OPENBSD_6_1:1.25.0.4
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.18.0.4
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7;
locks; strict;
comment	@ * @;


1.30
date	2017.07.15.15.48.08;	author stsp;	state Exp;
branches;
next	1.29;
commitid	MP5Ks7EoGkEqeoeV;

1.29
date	2017.06.20.13.52.40;	author stsp;	state Exp;
branches;
next	1.28;
commitid	RNhHmUkhCrBEeyQG;

1.28
date	2017.06.14.16.56.04;	author stsp;	state Exp;
branches;
next	1.27;
commitid	NRw9Z32ri1vzeCx5;

1.27
date	2017.05.28.09.59.58;	author stsp;	state Exp;
branches;
next	1.26;
commitid	KTJUKcNYY5qydrq7;

1.26
date	2017.05.08.13.07.40;	author stsp;	state Exp;
branches;
next	1.25;
commitid	qMj7wIXpSojBsgVO;

1.25
date	2016.11.30.14.31.51;	author stsp;	state Exp;
branches;
next	1.24;
commitid	41nYmZo2nRz9hk2d;

1.24
date	2016.09.21.13.53.18;	author stsp;	state Exp;
branches;
next	1.23;
commitid	8kJwHj5e8qsEq6KP;

1.23
date	2016.09.12.10.18.26;	author stsp;	state Exp;
branches;
next	1.22;
commitid	x351v7nrBjOjDuVS;

1.22
date	2016.09.10.09.32.33;	author stsp;	state Exp;
branches;
next	1.21;
commitid	NKHIC0DBd0N53xAz;

1.21
date	2016.09.04.18.49.21;	author stsp;	state Exp;
branches;
next	1.20;
commitid	84hj2yWIdC9W7SOp;

1.20
date	2016.09.02.15.45.17;	author stsp;	state Exp;
branches;
next	1.19;
commitid	q5FN8k3BJi61yUKm;

1.19
date	2016.08.15.12.59.53;	author stsp;	state Exp;
branches;
next	1.18;
commitid	8Acg7y7uOkpSaDHq;

1.18
date	2016.05.28.08.13.16;	author stsp;	state Exp;
branches;
next	1.17;
commitid	8ebmrzpPys0pIFKZ;

1.17
date	2016.05.25.13.35.12;	author stsp;	state Exp;
branches;
next	1.16;
commitid	ysQyHXeMccnGD7MG;

1.16
date	2016.01.25.11.27.11;	author stsp;	state Exp;
branches;
next	1.15;
commitid	U9Unyh02TU5iq9jc;

1.15
date	2016.01.05.18.41.15;	author stsp;	state Exp;
branches;
next	1.14;
commitid	2QagMjdMhQhIaQgu;

1.14
date	2015.12.14.08.34.56;	author stsp;	state Exp;
branches;
next	1.13;
commitid	mtIXAZui9PFGh9js;

1.13
date	2015.12.08.17.10.02;	author stsp;	state Exp;
branches;
next	1.12;
commitid	Clk4iAZ9SlzENy0G;

1.12
date	2015.10.22.11.51.28;	author jsg;	state Exp;
branches;
next	1.11;
commitid	U6KV6y8BsWn3FLvO;

1.11
date	2015.10.11.10.22.28;	author stsp;	state Exp;
branches;
next	1.10;
commitid	jZzDd7EmNURq20EO;

1.10
date	2015.10.05.13.05.08;	author stsp;	state Exp;
branches;
next	1.9;
commitid	zsqg29ZtiouKEBwF;

1.9
date	2015.06.15.08.06.12;	author stsp;	state Exp;
branches;
next	1.8;
commitid	P5lq1LqvmbH1YXqx;

1.8
date	2015.06.15.07.50.44;	author stsp;	state Exp;
branches;
next	1.7;
commitid	cvCtAwT7RzWXQ17u;

1.7
date	2015.03.02.13.51.10;	author jsg;	state Exp;
branches;
next	1.6;
commitid	0yRGSOyukjSEkV3a;

1.6
date	2015.03.02.13.46.40;	author jsg;	state Exp;
branches;
next	1.5;
commitid	A6K73Jj1X8bEfnpe;

1.5
date	2015.02.23.10.25.20;	author stsp;	state Exp;
branches;
next	1.4;
commitid	vNdMmUgTW0pg077U;

1.4
date	2015.02.23.09.40.47;	author stsp;	state Exp;
branches;
next	1.3;
commitid	FBnvinGdxsuSvG7X;

1.3
date	2015.02.07.07.10.44;	author phessler;	state Exp;
branches;
next	1.2;
commitid	ZAFNJhanO1wXZOL4;

1.2
date	2015.02.06.23.52.23;	author stsp;	state Exp;
branches;
next	1.1;
commitid	ifyxab6WnCJwnPG4;

1.1
date	2015.02.06.19.49.29;	author stsp;	state Exp;
branches;
next	;
commitid	Uagadgn7Uonii0DS;


desc
@@


1.30
log
@Get rid of the device reset hack in iwm_newstate_task().

Instead, maintain firmware state in accordance to the current net80211
state by adding/updating/removing MAC config, PHY->MAC binding, and the
station in the firmare station table (we only add the AP to this table).
By eliminating the iwm_stop() call from iwm_newstate_task(), this change
prepares future work on fixing races between ioctls and tasks scheduled
by this driver.

There's a known new occasional fatal firmware error which results in
the message "iwm0: could not remove MAC context (error 35)"
I expect to fix this soon.

tested by tb@@ on 7265, by jcs@@ on 8265, and by myself on 7260/7265/8260
ok mpi@@ tb@@
@
text
@/*	$OpenBSD: if_iwmvar.h,v 1.29 2017/06/20 13:52:40 stsp Exp $	*/

/*
 * Copyright (c) 2014 genua mbh <info@@genua.de>
 * Copyright (c) 2014 Fixup Software Ltd.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*-
 * Based on BSD-licensed source modules in the Linux iwlwifi driver,
 * which were used as the reference documentation for this implementation.
 *
 * Driver version we are currently based off of is
 * Linux 3.14.3 (tag id a2df521e42b1d9a23f620ac79dbfe8655a8391dd)
 *
 ***********************************************************************
 *
 * This file is provided under a dual BSD/GPLv2 license.  When using or
 * redistributing this file, you may do so under either license.
 *
 * GPL LICENSE SUMMARY
 *
 * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,
 * USA
 *
 * The full GNU General Public License is included in this distribution
 * in the file called COPYING.
 *
 * Contact Information:
 *  Intel Linux Wireless <ilw@@linux.intel.com>
 * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
 *
 *
 * BSD LICENSE
 *
 * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *  * Neither the name Intel Corporation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 2007-2010 Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

struct iwm_rx_radiotap_header {
	struct ieee80211_radiotap_header wr_ihdr;
	uint64_t	wr_tsft;
	uint8_t		wr_flags;
	uint8_t		wr_rate;
	uint16_t	wr_chan_freq;
	uint16_t	wr_chan_flags;
	int8_t		wr_dbm_antsignal;
	int8_t		wr_dbm_antnoise;
} __packed;

#define IWM_RX_RADIOTAP_PRESENT						\
	((1 << IEEE80211_RADIOTAP_TSFT) |				\
	 (1 << IEEE80211_RADIOTAP_FLAGS) |				\
	 (1 << IEEE80211_RADIOTAP_RATE) |				\
	 (1 << IEEE80211_RADIOTAP_CHANNEL) |				\
	 (1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL) |			\
	 (1 << IEEE80211_RADIOTAP_DBM_ANTNOISE))

struct iwm_tx_radiotap_header {
	struct ieee80211_radiotap_header wt_ihdr;
	uint8_t		wt_flags;
	uint8_t		wt_rate;
	uint16_t	wt_chan_freq;
	uint16_t	wt_chan_flags;
	uint8_t		wt_hwqueue;
} __packed;

#define IWM_TX_RADIOTAP_PRESENT						\
	((1 << IEEE80211_RADIOTAP_FLAGS) |				\
	 (1 << IEEE80211_RADIOTAP_RATE) |				\
	 (1 << IEEE80211_RADIOTAP_CHANNEL) |				\
	 (1 << IEEE80211_RADIOTAP_HWQUEUE))

#define IWM_UCODE_SECT_MAX 16
#define IWM_FWDMASEGSZ (192*1024)
#define IWM_FWDMASEGSZ_8000 (320*1024)
/* sanity check value */
#define IWM_FWMAXSIZE (2*1024*1024)

/*
 * fw_status is used to determine if we've already parsed the firmware file
 *
 * In addition to the following, status < 0 ==> -error
 */
#define IWM_FW_STATUS_NONE		0
#define IWM_FW_STATUS_INPROGRESS	1
#define IWM_FW_STATUS_DONE		2

enum iwm_ucode_type {
	IWM_UCODE_TYPE_REGULAR,
	IWM_UCODE_TYPE_INIT,
	IWM_UCODE_TYPE_WOW,
	IWM_UCODE_TYPE_REGULAR_USNIFFER,
	IWM_UCODE_TYPE_MAX
};

struct iwm_fw_info {
	void *fw_rawdata;
	size_t fw_rawsize;
	int fw_status;

	struct iwm_fw_sects {
		struct iwm_fw_onesect {
			void *fws_data;
			uint32_t fws_len;
			uint32_t fws_devoff;
		} fw_sect[IWM_UCODE_SECT_MAX];
		size_t fw_totlen;
		int fw_count;
	} fw_sects[IWM_UCODE_TYPE_MAX];
};

struct iwm_nvm_data {
	int n_hw_addrs;
	uint8_t hw_addr[ETHER_ADDR_LEN];

	uint8_t calib_version;
	uint16_t calib_voltage;

	uint16_t raw_temperature;
	uint16_t kelvin_temperature;
	uint16_t kelvin_voltage;
	uint16_t xtal_calib[2];

	int sku_cap_band_24GHz_enable;
	int sku_cap_band_52GHz_enable;
	int sku_cap_11n_enable;
	int sku_cap_amt_enable;
	int sku_cap_ipan_enable;
	int sku_cap_mimo_disable;

	uint8_t radio_cfg_type;
	uint8_t radio_cfg_step;
	uint8_t radio_cfg_dash;
	uint8_t radio_cfg_pnum;
	uint8_t valid_tx_ant, valid_rx_ant;

	uint16_t nvm_version;
	uint8_t max_tx_pwr_half_dbm;
};

/* max bufs per tfd the driver will use */
#define IWM_MAX_CMD_TBS_PER_TFD 2

struct iwm_rx_packet;
struct iwm_host_cmd {
	const void *data[IWM_MAX_CMD_TBS_PER_TFD];
	struct iwm_rx_packet *resp_pkt;
	unsigned long _rx_page_addr;
	uint32_t _rx_page_order;
	int handler_status;

	uint32_t flags;
	uint16_t len[IWM_MAX_CMD_TBS_PER_TFD];
	uint8_t dataflags[IWM_MAX_CMD_TBS_PER_TFD];
	uint32_t id;
};

/*
 * DMA glue is from iwn
 */

struct iwm_dma_info {
	bus_dma_tag_t		tag;
	bus_dmamap_t		map;
	bus_dma_segment_t	seg;
	bus_addr_t		paddr;
	void 			*vaddr;
	bus_size_t		size;
};

#define IWM_TX_RING_COUNT	256
#define IWM_TX_RING_LOMARK	192
#define IWM_TX_RING_HIMARK	224

struct iwm_tx_data {
	bus_dmamap_t	map;
	bus_addr_t	cmd_paddr;
	bus_addr_t	scratch_paddr;
	struct mbuf	*m;
	struct iwm_node *in;
	int done;
};

struct iwm_tx_ring {
	struct iwm_dma_info	desc_dma;
	struct iwm_dma_info	cmd_dma;
	struct iwm_tfd		*desc;
	struct iwm_device_cmd	*cmd;
	struct iwm_tx_data	data[IWM_TX_RING_COUNT];
	int			qid;
	int			queued;
	int			cur;
};

#define IWM_RX_RING_COUNT	256
#define IWM_RBUF_COUNT		(IWM_RX_RING_COUNT + 32)
/* Linux driver optionally uses 8k buffer */
#define IWM_RBUF_SIZE		4096

struct iwm_rx_data {
	struct mbuf	*m;
	bus_dmamap_t	map;
};

struct iwm_rx_ring {
	struct iwm_dma_info	desc_dma;
	struct iwm_dma_info	stat_dma;
	struct iwm_dma_info	buf_dma;
	uint32_t		*desc;
	struct iwm_rb_status	*stat;
	struct iwm_rx_data	data[IWM_RX_RING_COUNT];
	int			cur;
};

#define IWM_FLAG_USE_ICT	0x01
#define IWM_FLAG_RFKILL		0x02
#define IWM_FLAG_SCANNING	0x04
#define IWM_FLAG_MAC_ACTIVE	0x08
#define IWM_FLAG_BINDING_ACTIVE	0x10
#define IWM_FLAG_STA_ACTIVE	0x20

struct iwm_ucode_status {
	uint32_t uc_error_event_table;
	uint32_t uc_umac_error_event_table;
	uint32_t uc_log_event_table;

	int uc_ok;
	int uc_intr;
};

/* sc_wantresp */
#define IWM_CMD_RESP_IDLE	-1

#define IWM_CMD_RESP_MAX PAGE_SIZE

/* lower blocks contain EEPROM image and calibration data */
#define IWM_OTP_LOW_IMAGE_SIZE_FAMILY_7000 	16384
#define IWM_OTP_LOW_IMAGE_SIZE_FAMILY_8000	32768

#define IWM_TE_SESSION_PROTECTION_MAX_TIME_MS 1000
#define IWM_TE_SESSION_PROTECTION_MIN_TIME_MS 400

enum IWM_CMD_MODE {
	IWM_CMD_ASYNC		= (1 << 0),
	IWM_CMD_WANT_SKB	= (1 << 1),
	IWM_CMD_SEND_IN_RFKILL	= (1 << 2),
};
enum iwm_hcmd_dataflag {
	IWM_HCMD_DFL_NOCOPY     = (1 << 0),
	IWM_HCMD_DFL_DUP        = (1 << 1),
};

#define IWM_NUM_PAPD_CH_GROUPS	9
#define IWM_NUM_TXP_CH_GROUPS	9

struct iwm_phy_db_entry {
	uint16_t size;
	uint8_t *data;
};

struct iwm_phy_db {
	struct iwm_phy_db_entry	cfg;
	struct iwm_phy_db_entry	calib_nch;
	struct iwm_phy_db_entry	calib_ch_group_papd[IWM_NUM_PAPD_CH_GROUPS];
	struct iwm_phy_db_entry	calib_ch_group_txp[IWM_NUM_TXP_CH_GROUPS];
};

struct iwm_phy_ctxt {
	uint16_t id;
	uint16_t color;
	uint32_t ref;
	struct ieee80211_channel *channel;
};

struct iwm_bf_data {
	int bf_enabled;		/* filtering	*/
	int ba_enabled;		/* abort	*/
	int ave_beacon_signal;
	int last_cqm_event;
};

struct iwm_softc {
	struct device sc_dev;
	struct ieee80211com sc_ic;
	int (*sc_newstate)(struct ieee80211com *, enum ieee80211_state, int);
	int sc_newstate_pending;

	struct ieee80211_amrr sc_amrr;
	struct timeout sc_calib_to;
	struct timeout sc_led_blink_to;

	struct task		init_task;
	struct task		newstate_task;
	struct task		setrates_task;
	enum ieee80211_state	ns_nstate;
	int			ns_arg;

	/* Task for firmware BlockAck setup/teardown and its arguments. */
	struct task		ba_task;
	int			ba_start;
	int			ba_tid;
	uint16_t		ba_ssn;

	/* Task for HT protection updates. */
	struct task		htprot_task;

	bus_space_tag_t sc_st;
	bus_space_handle_t sc_sh;
	bus_size_t sc_sz;
	bus_dma_tag_t sc_dmat;
	pci_chipset_tag_t sc_pct;
	pcitag_t sc_pcitag;
	const void *sc_ih;

	/* TX scheduler rings. */
	struct iwm_dma_info		sched_dma;
	uint32_t			sched_base;

	/* TX/RX rings. */
	struct iwm_tx_ring txq[IWM_MAX_QUEUES];
	struct iwm_rx_ring rxq;
	int qfullmsk;

	int sc_sf_state;

	/* ICT table. */
	struct iwm_dma_info	ict_dma;
	int			ict_cur;

	int sc_hw_rev;
#define IWM_SILICON_A_STEP	0
#define IWM_SILICON_B_STEP	1
#define IWM_SILICON_C_STEP	2
#define IWM_SILICON_D_STEP	3
	int sc_hw_id;
	int sc_device_family;
#define IWM_DEVICE_FAMILY_7000	1
#define IWM_DEVICE_FAMILY_8000	2

	struct iwm_dma_info kw_dma;
	struct iwm_dma_info fw_dma;

	int sc_fw_chunk_done;
	int sc_init_complete;
#define IWM_INIT_COMPLETE	0x01
#define IWM_CALIB_COMPLETE	0x02

	struct iwm_ucode_status sc_uc;
	enum iwm_ucode_type sc_uc_current;
	char sc_fwver[32];

	int sc_capaflags;
	int sc_capa_max_probe_len;
	int sc_capa_n_scan_channels;
	uint32_t sc_ucode_api;
	uint8_t sc_enabled_capa[howmany(IWM_NUM_UCODE_TLV_CAPA, NBBY)];
	char sc_fw_mcc[3];

	int sc_intmask;
	int sc_flags;

	/*
	 * So why do we need a separate stopped flag and a generation?
	 * the former protects the device from issueing commands when it's
	 * stopped (duh).  The latter protects against race from a very
	 * fast stop/unstop cycle where threads waiting for responses do
	 * not have a chance to run in between.  Notably: we want to stop
	 * the device from interrupt context when it craps out, so we
	 * don't have the luxury of waiting for quiescense.
	 */
	int sc_generation;

	struct rwlock ioctl_rwl;

	int sc_cap_off; /* PCIe caps */

	const char *sc_fwname;
	bus_size_t sc_fwdmasegsz;
	struct iwm_fw_info sc_fw;
	int sc_fw_phy_config;
	struct iwm_tlv_calib_ctrl sc_default_calib[IWM_UCODE_TYPE_MAX];

	struct iwm_nvm_data sc_nvm;
	struct iwm_phy_db sc_phy_db;

	struct iwm_bf_data sc_bf;

	int sc_tx_timer;
	int sc_rx_ba_sessions;

	int sc_scan_last_antenna;

	int sc_fixed_ridx;

	int sc_staid;
	int sc_nodecolor;

	uint8_t sc_cmd_resp[IWM_CMD_RESP_MAX];
	int sc_wantresp;
	int sc_nic_locks;

	struct taskq *sc_nswq, *sc_eswq;
	struct task sc_eswk;

	struct iwm_rx_phy_info sc_last_phy_info;
	int sc_ampdu_ref;

	/* phy contexts.  we only use the first one */
	struct iwm_phy_ctxt sc_phyctxt[IWM_NUM_PHY_CTX];

	struct iwm_notif_statistics sc_stats;
	int sc_noise;

	int host_interrupt_operation_mode;

#if NBPFILTER > 0
	caddr_t			sc_drvbpf;

	union {
		struct iwm_rx_radiotap_header th;
		uint8_t	pad[IEEE80211_RADIOTAP_HDRLEN];
	} sc_rxtapu;
#define sc_rxtap	sc_rxtapu.th
	int			sc_rxtap_len;

	union {
		struct iwm_tx_radiotap_header th;
		uint8_t	pad[IEEE80211_RADIOTAP_HDRLEN];
	} sc_txtapu;
#define sc_txtap	sc_txtapu.th
	int			sc_txtap_len;
#endif
};

struct iwm_node {
	struct ieee80211_node in_ni;
	struct iwm_phy_ctxt *in_phyctxt;

	uint16_t in_id;
	uint16_t in_color;

	struct iwm_lq_cmd in_lq;
	struct ieee80211_amrr_node in_amn;
	struct ieee80211_mira_node in_mn;
};
#define IWM_STATION_ID 0
#define IWM_AUX_STA_ID 1

#define IWM_ICT_SIZE		4096
#define IWM_ICT_COUNT		(IWM_ICT_SIZE / sizeof (uint32_t))
#define IWM_ICT_PADDR_SHIFT	12
@


1.29
log
@Remove the IWM_FLAG_HW_INITED flag from iwm(4). This flag was redundant.
The IFF_RUNNING flag in struct ifnet serves the same purpose.
ok mpi@@ kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.28 2017/06/14 16:56:04 stsp Exp $	*/
d285 3
@


1.28
log
@Make iwm(4) wait for the PHY calibration result notification during HW init.
Code inspection revealed that Linux does this, and so should we.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.27 2017/05/28 09:59:58 stsp Exp $	*/
d283 2
a284 3
#define IWM_FLAG_HW_INITED	0x02
#define IWM_FLAG_RFKILL		0x04
#define IWM_FLAG_SCANNING	0x08
@


1.27
log
@Remove unused flag IWM_FLAG_STOPPED.
ok tedu@@ of course
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.26 2017/05/08 13:07:40 stsp Exp $	*/
d410 2
@


1.26
log
@Unbreak the tree. I missed a header file change in my last iwm(4) commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.25 2016/11/30 14:31:51 stsp Exp $	*/
d284 2
a285 3
#define IWM_FLAG_STOPPED	0x04
#define IWM_FLAG_RFKILL		0x08
#define IWM_FLAG_SCANNING	0x10
@


1.25
log
@Switch the iwm(4) driver to mira rate adaptation in 11n mode.
Only the rate adaptation algorithm changes, available data rates do not (yet).
Please let me know about any regressions.

In 11a/b/g modes the driver still uses AMRR, so forcing one of these modes
with ifconfig's 'mode' subcommand will serve as a fallback if necessary.

ok tb@@ mpi@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.24 2016/09/21 13:53:18 stsp Exp $	*/
d464 1
@


1.24
log
@Properly support the mac context command in iwm. This was wrong in many ways.
This commit includes style fixes as well as actual bug fixes.

Remove the global in_assoc flag from the softc. We can just pass a fixed
argument to functions to indicate whether we're already associated.

Remove in_tfsid from the softc as well. It was implicitly set to zero
and never changed. A corresponding macro already exists so use it instead.

Always copy the BSSID into the mac context command, as the Linux driver does.
This helps the firmware during association.

Set the firmware state to 'associated' once we've moved to RUN state
and our assoc ID is known. Earlier versions of iwm used to set the
firmware to 'associated' but this was disabled in r1.91 since it
didn't work correctly due to bugs which are now fixed.

Use live DTIM information obtained from the AP, rather than using the
default DTIM period of our wireless stack.

Check return values of functions called after moving to RUN state.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.23 2016/09/12 10:18:26 stsp Exp $	*/
d507 1
@


1.23
log
@Simplify handling of the AUX STA in iwm(4). There is no good reason for
storing AUX STA data in the softc. Also, simplify error handling around
iwm_send_cmd_pdu_status(), and inline its iwm_add_int_sta_common() helper
along with fixing an uninitialized 'status' output parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.22 2016/09/10 09:32:33 stsp Exp $	*/
a503 4
	int in_tsfid;

	/* status "bits" */
	int in_assoc;
@


1.22
log
@iwm(4) inherited the 'MVM' prefix in many of its symbol names from iwlwifi.
Linux iwlwifi implements support for iwn(4) chips in the 'DVM' driver,
and support for iwm(4) chips in the 'MVM' driver.

In OpenBSD the 'MVM' prefix is redundant, so we can remove it to shorten
many lines and reduce noise: s/iwm_mvm_/iwm_/g
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.21 2016/09/04 18:49:21 stsp Exp $	*/
a333 5
struct iwm_int_sta {
	uint32_t sta_id;
	uint32_t tfd_queue_msk;
};

a469 2

	struct iwm_int_sta sc_aux_sta;
@


1.21
log
@Replace iwm's ioctl tsleep/wakeup BUSY flag dance with an rwlock.
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.20 2016/09/02 15:45:17 stsp Exp $	*/
d306 2
a307 2
#define IWM_MVM_TE_SESSION_PROTECTION_MAX_TIME_MS 1000
#define IWM_MVM_TE_SESSION_PROTECTION_MIN_TIME_MS 400
d339 1
a339 1
struct iwm_mvm_phy_ctxt {
d391 1
a391 1
	struct iwm_tx_ring txq[IWM_MVM_MAX_QUEUES];
d479 1
a479 1
	struct iwm_mvm_phy_ctxt sc_phyctxt[IWM_NUM_PHY_CTX];
d507 1
a507 1
	struct iwm_mvm_phy_ctxt *in_phyctxt;
@


1.20
log
@The struct iwm_rbuf definition, and the wantresp field in struct
iwm_rx_data aren't used anywhere and can be removed.
Patch by Imre Vadasz
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.19 2016/08/15 12:59:53 stsp Exp $	*/
d286 1
a286 2
#define IWM_FLAG_BUSY		0x10
#define IWM_FLAG_SCANNING	0x20
d441 2
@


1.19
log
@Remove IWM_CMD_SYNC, which expands to zero while all the other
IWM_CMD_* values are bit flags. The same was done 2 years ago
in Linux git commit a10229271946731959b2269370d0492d88cfab23.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.18 2016/05/28 08:13:16 stsp Exp $	*/
a266 7
struct iwm_softc;
struct iwm_rbuf {
	struct iwm_softc	*sc;
	void			*vaddr;
	bus_addr_t		paddr;
};

a269 1
	int		wantresp;
@


1.18
log
@Add support for Intel Wireless 8260 devices to iwm(4).

Firmware has been available in fw_update(1) for some time (thanks sthen!).
Tested by robert, reyk, Imre Vadasz, Bryan Vyhmeister.
Thank you, Emmanuel Grumbach, for helping me diagnose issues during development.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.17 2016/05/25 13:35:12 stsp Exp $	*/
a318 1
	IWM_CMD_SYNC		= 0,
@


1.17
log
@Update iwm(4) to firmware API 16 and enable RTS/CTS frame protection.

Requires new firmware! Which has been available in fw_update(1) for some time.

With helpful hints from Emmanuel Grumbach and contributions from Imre Vadasz.
Tested verbatim by phessler@@, jasper@@, gilles@@. Tested as part of a larger
diff by reyk@@, robert@@, Imre Vadasz, and Bryan Vyhmeister.
Earlier version tested by many. Also passed by kettenis@@ very early on.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.16 2016/01/25 11:27:11 stsp Exp $	*/
d142 1
d299 1
d313 1
d412 4
d417 3
@


1.16
log
@Keep track of HT protection settings in beacons and have 11n-capable
drivers update hardware configuration accordingly.
tested by myself, tb@@, deraadt@@, abieber@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.15 2016/01/05 18:41:15 stsp Exp $	*/
d140 1
a140 1
#define IWM_UCODE_SECT_MAX 6
d155 1
a156 1
	IWM_UCODE_TYPE_REGULAR,
d158 1
d221 1
a221 1
	uint8_t id;
d294 1
d309 2
a310 1
#define IWM_OTP_LOW_IMAGE_SIZE 2048
d326 1
a326 1
#define IWM_NUM_PAPD_CH_GROUPS	4
d419 1
a419 1
	int sc_fwver;
d423 4
a457 2
	struct iwm_scan_cmd *sc_scan_cmd;
	size_t sc_scan_cmd_len;
a458 1
	int sc_scanband;
d518 1
@


1.15
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.14 2015/12/14 08:34:56 stsp Exp $	*/
d378 3
@


1.14
log
@Add initial 802.11n support to the iwm(4) driver.

Adds support for HT MCS 0-7 (theoretical limit 65 Mbit/s) and the
reception of A-MSDU and A-MPDU aggregated frames.

None of the optional 11n features are supported for now.
MIMO, 40Mhz channels, short guard interval, etc. are left for future work.
And we're not sending A-MSDU or A-MPDU frames yet either.

Tested with various 11a/b/g/n access points. With some APs I'm seeing
a noticable increase in throughput, especially on 5Ghz.

Also, fix automatic rate selection by using the current Tx rate selected
by AMRR as the upper bound for the firmware's rate table and updating the
firmware's table whenever AMRR switches Tx rate, rather than setting the
table just once after association and ignoring AMRR updates.

ok mpi@@ krw@@ (earlier version), ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.13 2015/12/08 17:10:02 stsp Exp $	*/
a372 1
#ifndef IEEE80211_NO_HT
a377 1
#endif
a445 1
#ifndef IEEE80211_NO_HT
a446 1
#endif
@


1.13
log
@When iwm(4) moves to AUTH state it asks the firmware for a "time event" to
prevent it from moving off-channel during association. The firmware issues
interrupts at beginning and end of the time event. The driver tried detecting
the beginning with a tsleep() in the newstate task followed by a wakeup()
from the interrupt handler. However, sometimes the newstate task did not get
scheduled until the time event had already passed, and association was aborted.
In rare cases the newstate task would even sleep forever and the iwm(4)
interface would stop working until reboot.
Fix these issues by issuing the time event and continuing association without
checking for a "go" from the firmware. Our kernel does not provide the
scheduling guarantees required for such precise synchronization so
association is more likely to fail with the additional check than without.
ok mpi@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.12 2015/10/22 11:51:28 jsg Exp $	*/
d194 1
d369 1
d373 8
d448 3
a512 2

	uint8_t in_ridx[IEEE80211_RATE_MAXSIZE];
@


1.12
log
@remove some horrible iwm typedefs
ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.11 2015/10/11 10:22:28 stsp Exp $	*/
d308 1
a308 1
#define IWM_MVM_TE_SESSION_PROTECTION_MAX_TIME_MS 500
a442 2

	int sc_auth_prot;
@


1.11
log
@Add a symbolic name for the special '-1' value of iwm's sc_wantresp.
ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.10 2015/10/05 13:05:08 stsp Exp $	*/
a224 3

typedef caddr_t iwm_caddr_t;
typedef void *iwm_hookarg_t;
@


1.10
log
@Simplify iwm(4) newstate task by only queuing one state transition
at a time. The newstate task now always transitions to the most
recently requested state, rather than hopping along with every request.

This allows us get rid of the silly newstate generation counter, and
we can now task_del() a pending transition when the interface goes down.
While several issues with this driver remain, I believe this change
does not introduce new problems.

Tested by myself, jasper@@, and zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.9 2015/06/15 08:06:12 stsp Exp $	*/
d303 3
@


1.9
log
@Remove comments referring to Linux iwlwifi source filenames from iwm(4).
Linux is a moving target so these comments provide little value.
Discussed with kettenis and deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.8 2015/06/15 07:50:44 stsp Exp $	*/
d367 3
@


1.8
log
@Make the wifi LED work with iwm(4).

The bad news: Many laptops sold with iwm(4) cards don't have a wifi LED :-(
The good news: Laptops with LEDs and no wifi device white-list in BIOS
actually exist! Tested in one such machine.

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.7 2015/03/02 13:51:10 jsg Exp $	*/
a310 5
/*
 * Command headers are in iwl-trans.h, which is full of all
 * kinds of other junk, so we just replicate the structures here.
 * First the software bits:
 */
a320 4

/*
 * iwlwifi/iwl-phy-db
 */
@


1.7
log
@workaround for interrupt coalescing bug not needed on 7265
ok kettenis@@ stsp@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.6 2015/03/02 13:46:40 jsg Exp $	*/
d373 1
@


1.6
log
@load the correct firmware for 3160/7265
ok kettenis@@ stsp@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.5 2015/02/23 10:25:20 stsp Exp $	*/
d472 2
@


1.5
log
@More iwm(4) whitespace fixes from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.4 2015/02/23 09:40:47 stsp Exp $	*/
a140 1
#define IWM_FWNAME "iwm-7260-9"
@


1.4
log
@Make iwm(4) re-read the firmware image from disk on if down/up like other
drivers do. While here remove unused fields from struct iwm_fw_info.
test and ok brad@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.3 2015/02/07 07:10:44 phessler Exp $	*/
d171 1
a171 1
			uint32_t fws_devoff; 
d300 1
a300 1
	
d324 2
a325 2
        IWM_HCMD_DFL_NOCOPY     = (1 << 0),
        IWM_HCMD_DFL_DUP        = (1 << 1),
d389 1
a389 1
        /* TX/RX rings. */
d396 1
a396 1
        /* ICT table. */
@


1.3
log
@Handle suspend/resume for iwm(4) devices, by syncing with iwn(4)

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.2 2015/02/06 23:52:23 stsp Exp $	*/
a171 3

			void *fws_alloc;
			size_t fws_allocsize;
@


1.2
log
@Add bpf(4) support to iwm(4). Makes tcpdump -i iwm0 work. Based on iwn(4).
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_iwmvar.h,v 1.1 2015/02/06 19:49:29 stsp Exp $	*/
d298 1
d377 2
@


1.1
log
@Add iwm(4), a new driver for Intel 7260 wifi cards.

Based on iwn(4) and Linux iwlwifi (which is dual BSD/GPLv2 licenced).
Created by Fixup Software Ltd. for genua mbh, who then passed on the code
base to the OpenBSD project.

The genua version of this driver was written for OpenBSD 5.4; ported to
-current by myself, phessler@@, and deraadt@@. So far, we've done semantic
and stylistic cleanup without functional changes. The driver is functional
but has some known issues which will be worked on in-tree.

Requires iwm firmware which is available in ports thanks to sthen@@.

ok deraadt@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d106 34
d472 19
@

