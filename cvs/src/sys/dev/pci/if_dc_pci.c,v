head	1.76;
access;
symbols
	OPENBSD_6_2:1.76.0.2
	OPENBSD_6_2_BASE:1.76
	OPENBSD_6_1:1.74.0.8
	OPENBSD_6_1_BASE:1.74
	OPENBSD_6_0:1.74.0.6
	OPENBSD_6_0_BASE:1.74
	OPENBSD_5_9:1.74.0.2
	OPENBSD_5_9_BASE:1.74
	OPENBSD_5_8:1.72.0.4
	OPENBSD_5_8_BASE:1.72
	OPENBSD_5_7:1.71.0.4
	OPENBSD_5_7_BASE:1.71
	OPENBSD_5_6:1.70.0.4
	OPENBSD_5_6_BASE:1.70
	OPENBSD_5_5:1.69.0.4
	OPENBSD_5_5_BASE:1.69
	OPENBSD_5_4:1.68.0.4
	OPENBSD_5_4_BASE:1.68
	OPENBSD_5_3:1.68.0.2
	OPENBSD_5_3_BASE:1.68
	OPENBSD_5_2:1.67.0.8
	OPENBSD_5_2_BASE:1.67
	OPENBSD_5_1_BASE:1.67
	OPENBSD_5_1:1.67.0.6
	OPENBSD_5_0:1.67.0.4
	OPENBSD_5_0_BASE:1.67
	OPENBSD_4_9:1.67.0.2
	OPENBSD_4_9_BASE:1.67
	OPENBSD_4_8:1.66.0.2
	OPENBSD_4_8_BASE:1.66
	OPENBSD_4_7:1.65.0.2
	OPENBSD_4_7_BASE:1.65
	OPENBSD_4_6:1.64.0.4
	OPENBSD_4_6_BASE:1.64
	OPENBSD_4_5:1.61.0.2
	OPENBSD_4_5_BASE:1.61
	OPENBSD_4_4:1.59.0.4
	OPENBSD_4_4_BASE:1.59
	OPENBSD_4_3:1.59.0.2
	OPENBSD_4_3_BASE:1.59
	OPENBSD_4_2:1.58.0.2
	OPENBSD_4_2_BASE:1.58
	OPENBSD_4_1:1.56.0.2
	OPENBSD_4_1_BASE:1.56
	OPENBSD_4_0:1.55.0.2
	OPENBSD_4_0_BASE:1.55
	OPENBSD_3_9:1.52.0.2
	OPENBSD_3_9_BASE:1.52
	OPENBSD_3_8:1.51.0.2
	OPENBSD_3_8_BASE:1.51
	OPENBSD_3_7:1.49.0.2
	OPENBSD_3_7_BASE:1.49
	OPENBSD_3_6:1.44.0.2
	OPENBSD_3_6_BASE:1.44
	SMP_SYNC_A:1.42
	SMP_SYNC_B:1.42
	OPENBSD_3_5:1.42.0.2
	OPENBSD_3_5_BASE:1.42
	OPENBSD_3_4:1.39.0.2
	OPENBSD_3_4_BASE:1.39
	UBC_SYNC_A:1.37
	OPENBSD_3_3:1.34.0.2
	OPENBSD_3_3_BASE:1.34
	OPENBSD_3_2:1.33.0.2
	OPENBSD_3_2_BASE:1.33
	OPENBSD_3_1:1.30.0.2
	OPENBSD_3_1_BASE:1.30
	UBC_SYNC_B:1.34
	UBC:1.22.0.2
	UBC_BASE:1.22
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	SMP:1.13.0.4
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.76
date	2017.04.11.14.43.49;	author dhill;	state Exp;
branches;
next	1.75;
commitid	zztPc3QpQPdWwQ6h;

1.75
date	2017.04.09.18.16.00;	author dhill;	state Exp;
branches;
next	1.74;
commitid	o5m0faA70n3VZuQ8;

1.74
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.73;
commitid	5gdEnqVoJuTuwdTu;

1.73
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.72;
commitid	5DvsamK0GblTp8ww;

1.72
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.71;
commitid	p4LJxGKbi0BU2cG6;

1.71
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.70;
commitid	yM2VFFhpDTeFQlve;

1.70
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.69;
commitid	TGHgrLxu6sxZoiFt;

1.69
date	2013.08.07.01.06.34;	author bluhm;	state Exp;
branches;
next	1.68;

1.68
date	2012.10.18.21.44.21;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2010.08.27.19.54.03;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2010.08.05.07.57.05;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2009.10.15.17.54.56;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2009.06.26.16.58.45;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2009.06.02.15.39.35;	author jsg;	state Exp;
branches;
next	1.62;

1.62
date	2009.06.02.04.03.39;	author jsg;	state Exp;
branches;
next	1.61;

1.61
date	2008.09.11.06.49.14;	author brad;	state Exp;
branches;
next	1.60;

1.60
date	2008.09.11.05.39.51;	author brad;	state Exp;
branches;
next	1.59;

1.59
date	2007.11.26.17.45.14;	author brad;	state Exp;
branches;
next	1.58;

1.58
date	2007.08.01.16.30.03;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2007.02.13.10.38.00;	author jsg;	state Exp;
branches;
next	1.55;

1.55
date	2006.07.20.02.49.18;	author brad;	state Exp;
branches;
next	1.54;

1.54
date	2006.07.18.23.56.47;	author brad;	state Exp;
branches;
next	1.53;

1.53
date	2006.06.17.18.00.43;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2005.11.06.19.25.21;	author brad;	state Exp;
branches;
next	1.51;

1.51
date	2005.08.09.04.10.11;	author mickey;	state Exp;
branches;
next	1.50;

1.50
date	2005.03.26.15.49.09;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2005.01.16.20.47.44;	author brad;	state Exp;
branches;
next	1.48;

1.48
date	2005.01.16.19.46.00;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2005.01.14.15.04.52;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2005.01.08.06.02.59;	author brad;	state Exp;
branches;
next	1.45;

1.45
date	2004.09.28.16.58.56;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2004.08.04.15.02.29;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2004.06.28.12.34.20;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2003.10.21.21.48.07;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2003.10.07.14.11.04;	author fgsch;	state Exp;
branches;
next	1.40;

1.40
date	2003.09.29.18.53.58;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2003.08.16.14.42.19;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2003.06.26.00.46.14;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2003.05.17.01.55.29;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2003.04.29.21.39.34;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	2003.04.19.11.54.02;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2002.10.20.16.46.28;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.09.05.49.35;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.18.19.11.18;	author jason;	state Exp;
branches;
next	1.31;

1.31
date	2002.04.16.21.29.54;	author jason;	state Exp;
branches;
next	1.30;

1.30
date	2002.04.01.18.41.47;	author nate;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.22.05.37.48;	author jason;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.06.23.14.17;	author nate;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.04.22.39.35;	author nate;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.17.05.27.39;	author nate;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.17.05.12.56;	author nate;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.11.01.31.21;	author nordin;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.13.17.43.03;	author nate;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.12.06.20.12.00;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.06.05.42.12;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.06.14.37.48;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.22.16.38.38;	author aaron;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.14.16.19.01;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.12.20.03.49;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.06.17.14.14;	author aaron;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2001.02.09.02.23.36;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.16.01.25.45;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.30.18.20.18;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.27.18.20.02;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.27.18.13.44;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.16.17.08.08;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.13.00.29.35;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.02.19.01.07;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.12.16.23.22;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.26.13.58.28;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.26.03.28.57;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.18.19.35.31;	author jason;	state Exp;
branches;
next	;

1.13.4.1
date	2001.05.14.22.25.43;	author niklas;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.13.4.3;

1.13.4.3
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.13.4.4;

1.13.4.4
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.13.4.5;

1.13.4.5
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.13.4.6;

1.13.4.6
date	2003.03.28.00.38.21;	author niklas;	state Exp;
branches;
next	1.13.4.7;

1.13.4.7
date	2003.05.13.19.35.05;	author ho;	state Exp;
branches;
next	1.13.4.8;

1.13.4.8
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.13.4.9;

1.13.4.9
date	2004.02.19.10.56.26;	author niklas;	state Exp;
branches;
next	;

1.22.2.1
date	2002.01.31.22.55.35;	author niklas;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.76
log
@Partially revert previous mallocarray conversions that contain
constants.

The consensus is that if both operands are constant, we don't need
mallocarray.  Reminded by tedu@@

ok deraadt@@
@
text
@/*	$OpenBSD: if_dc_pci.c,v 1.75 2017/04/09 18:16:00 dhill Exp $	*/

/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ee.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/pci/if_dc.c,v 1.5 2000/01/12 22:24:05 wpaul Exp $
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <dev/mii/miivar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#ifdef __sparc64__
#include <dev/ofw/openfirm.h>
#endif

#ifndef __hppa__
#define DC_USEIOSPACE
#endif

#include <dev/ic/dcreg.h>

/*
 * Various supported device vendors/types and their names.
 */
struct dc_type dc_devs[] = {
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_21140 },
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_21142 },
	{ PCI_VENDOR_DAVICOM, PCI_PRODUCT_DAVICOM_DM9009 },
	{ PCI_VENDOR_DAVICOM, PCI_PRODUCT_DAVICOM_DM9100 },
	{ PCI_VENDOR_DAVICOM, PCI_PRODUCT_DAVICOM_DM9102 },
	{ PCI_VENDOR_ADMTEK, PCI_PRODUCT_ADMTEK_ADM9511 },
	{ PCI_VENDOR_ADMTEK, PCI_PRODUCT_ADMTEK_ADM9513 },
	{ PCI_VENDOR_ADMTEK, PCI_PRODUCT_ADMTEK_AL981 },
	{ PCI_VENDOR_ADMTEK, PCI_PRODUCT_ADMTEK_AN983 },
	{ PCI_VENDOR_ASIX, PCI_PRODUCT_ASIX_AX88140A },
	{ PCI_VENDOR_MACRONIX, PCI_PRODUCT_MACRONIX_MX98713 },
	{ PCI_VENDOR_MACRONIX, PCI_PRODUCT_MACRONIX_MX98715 },
	{ PCI_VENDOR_MACRONIX, PCI_PRODUCT_MACRONIX_MX98727 },
	{ PCI_VENDOR_COMPEX, PCI_PRODUCT_COMPEX_98713 },
	{ PCI_VENDOR_LITEON, PCI_PRODUCT_LITEON_PNIC },
	{ PCI_VENDOR_LITEON, PCI_PRODUCT_LITEON_PNICII },
	{ PCI_VENDOR_ACCTON, PCI_PRODUCT_ACCTON_EN1217 },
	{ PCI_VENDOR_ACCTON, PCI_PRODUCT_ACCTON_EN2242 },
	{ PCI_VENDOR_CONEXANT, PCI_PRODUCT_CONEXANT_RS7112 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_21145 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CSHO100BTX },
	{ PCI_VENDOR_MICROSOFT, PCI_PRODUCT_MICROSOFT_MN130 },
	{ PCI_VENDOR_XIRCOM, PCI_PRODUCT_XIRCOM_X3201_3_21143 },
	{ PCI_VENDOR_ADMTEK, PCI_PRODUCT_ADMTEK_AN985 },
	{ PCI_VENDOR_ABOCOM, PCI_PRODUCT_ABOCOM_FE2500 },
	{ PCI_VENDOR_ABOCOM, PCI_PRODUCT_ABOCOM_FE2500MX },
	{ PCI_VENDOR_ABOCOM, PCI_PRODUCT_ABOCOM_PCM200 },
	{ PCI_VENDOR_DLINK, PCI_PRODUCT_DLINK_DRP32TXD },
	{ PCI_VENDOR_LINKSYS, PCI_PRODUCT_LINKSYS_PCMPC200 },
	{ PCI_VENDOR_LINKSYS, PCI_PRODUCT_LINKSYS_PCM200 },
	{ PCI_VENDOR_HAWKING, PCI_PRODUCT_HAWKING_PN672TX },
	{ PCI_VENDOR_MICROSOFT, PCI_PRODUCT_MICROSOFT_MN120 },
	{ 0, 0 }
};

int dc_pci_match(struct device *, void *, void *);
void dc_pci_attach(struct device *, struct device *, void *);
int dc_pci_detach(struct device *, int);

struct dc_pci_softc {
	struct dc_softc		psc_softc;
	pci_chipset_tag_t	psc_pc;
	bus_size_t		psc_mapsize;
};

/*
 * Probe for a 21143 or clone chip. Check the PCI vendor and device
 * IDs against our list and return a device name if we find a match.
 */
int
dc_pci_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	struct dc_type *t;

	/*
	 * Support for the 21140 chip is experimental.  If it works for you,
	 * that's great.  By default, this chip will use de.
	 */
        if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DEC &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_21140)
		return (1);

	/*
	 * The following chip revision doesn't seem to work so well with dc,
	 * so let's have de handle it.  (de will return a match of 2)
	 */
        if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DEC &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_21142 &&
	    PCI_REVISION(pa->pa_class) == 0x21)
		return (1);

	for (t = dc_devs; t->dc_vid != 0; t++) {
		if ((PCI_VENDOR(pa->pa_id) == t->dc_vid) &&
		    (PCI_PRODUCT(pa->pa_id) == t->dc_did)) {
			return (3);
		}
	}

	return (0);
}

/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
void
dc_pci_attach(struct device *parent, struct device *self, void *aux)
{
	const char		*intrstr = NULL;
	pcireg_t		command;
	struct dc_pci_softc	*psc = (struct dc_pci_softc *)self;
	struct dc_softc		*sc = &psc->psc_softc;
	struct pci_attach_args	*pa = aux;
	pci_chipset_tag_t	pc = pa->pa_pc;
	pci_intr_handle_t	ih;
	int			found = 0;

	psc->psc_pc = pa->pa_pc;
	sc->sc_dmat = pa->pa_dmat;

	pci_set_powerstate(pa->pa_pc, pa->pa_tag, PCI_PMCSR_STATE_D0);

	sc->dc_csid = pci_conf_read(pc, pa->pa_tag, PCI_SUBSYS_ID_REG);

	/*
	 * Map control/status registers.
	 */
#ifdef DC_USEIOSPACE
	if (pci_mapreg_map(pa, DC_PCI_CFBIO,
	    PCI_MAPREG_TYPE_IO, 0,
	    &sc->dc_btag, &sc->dc_bhandle, NULL, &psc->psc_mapsize, 0)) {
		printf(": can't map i/o space\n");
		return;
	}
#else
	if (pci_mapreg_map(pa, DC_PCI_CFBMA,
	    PCI_MAPREG_TYPE_MEM|PCI_MAPREG_MEM_TYPE_32BIT, 0,
	    &sc->dc_btag, &sc->dc_bhandle, NULL, &psc->psc_mapsize, 0)) {
		printf(": can't map mem space\n");
		return;
	}
#endif

	/* Allocate interrupt */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		goto fail_1;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, dc_intr, sc,
	    self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail_1;
	}
	printf(": %s", intrstr);

	/* Need this info to decide on a chip type. */
	sc->dc_revision = PCI_REVISION(pa->pa_class);

	/* Get the eeprom width, if possible */
	if ((PCI_VENDOR(pa->pa_id) == PCI_VENDOR_LITEON &&
	      PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_LITEON_PNIC))
		;	/* PNIC has non-standard eeprom */
	else if ((PCI_VENDOR(pa->pa_id) == PCI_VENDOR_XIRCOM &&
	      PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_XIRCOM_X3201_3_21143))
		;	/* XIRCOM has non-standard eeprom */
	else
		dc_eeprom_width(sc);

	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_DEC:
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_21140 ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_21142) {
			found = 1;
			sc->dc_type = DC_TYPE_21143;
			sc->dc_flags |= DC_TX_POLL|DC_TX_USE_TX_INTR;
			sc->dc_flags |= DC_REDUCED_MII_POLL;
			dc_read_srom(sc, sc->dc_romwidth);
		}
		break;
	case PCI_VENDOR_INTEL:
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_21145) {
			found = 1;
			sc->dc_type = DC_TYPE_21145;
			sc->dc_flags |= DC_TX_POLL|DC_TX_USE_TX_INTR;
			sc->dc_flags |= DC_REDUCED_MII_POLL;
			dc_read_srom(sc, sc->dc_romwidth);
		}
		break;
	case PCI_VENDOR_DAVICOM:
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DAVICOM_DM9100 ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DAVICOM_DM9102 ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DAVICOM_DM9009) {
			found = 1;
			sc->dc_type = DC_TYPE_DM9102;
			sc->dc_flags |= DC_TX_COALESCE|DC_TX_INTR_ALWAYS;
			sc->dc_flags |= DC_REDUCED_MII_POLL|DC_TX_STORENFWD;
			sc->dc_flags |= DC_TX_ALIGN;
			sc->dc_pmode = DC_PMODE_MII;

			/* Increase the latency timer value. */
			command = pci_conf_read(pc, pa->pa_tag, DC_PCI_CFLT);
			command &= 0xFFFF00FF;
			command |= 0x00008000;
			pci_conf_write(pc, pa->pa_tag, DC_PCI_CFLT, command);
		}
		break;
	case PCI_VENDOR_ADMTEK:
	case PCI_VENDOR_3COM:
	case PCI_VENDOR_MICROSOFT:
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADMTEK_AL981) {
			found = 1;
			sc->dc_type = DC_TYPE_AL981;
			sc->dc_flags |= DC_TX_USE_TX_INTR;
			sc->dc_flags |= DC_TX_ADMTEK_WAR;
			sc->dc_pmode = DC_PMODE_MII;
			dc_read_srom(sc, sc->dc_romwidth);
		}
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADMTEK_ADM9511 ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADMTEK_ADM9513 ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADMTEK_AN983 ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_3COM_3CSHO100BTX ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_MICROSOFT_MN130) {
			found = 1;
			sc->dc_type = DC_TYPE_AN983;
			sc->dc_flags |= DC_TX_USE_TX_INTR;
			sc->dc_flags |= DC_TX_ADMTEK_WAR;
			sc->dc_flags |= DC_64BIT_HASH;
			sc->dc_pmode = DC_PMODE_MII;
			/* Don't read SROM for - auto-loaded on reset */
		}
		break;
	case PCI_VENDOR_MACRONIX:
	case PCI_VENDOR_ACCTON:
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ACCTON_EN2242) {
			found = 1;
			sc->dc_type = DC_TYPE_AN983;
			sc->dc_flags |= DC_TX_USE_TX_INTR;
			sc->dc_flags |= DC_TX_ADMTEK_WAR;
			sc->dc_flags |= DC_64BIT_HASH;
			sc->dc_pmode = DC_PMODE_MII;
			/* Don't read SROM for - auto-loaded on reset */
		}
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_MACRONIX_MX98713) {
			found = 1;
			if (sc->dc_revision < DC_REVISION_98713A)
				sc->dc_type = DC_TYPE_98713;
			if (sc->dc_revision >= DC_REVISION_98713A) {
				sc->dc_type = DC_TYPE_98713A;
				sc->dc_flags |= DC_21143_NWAY;
			}
			sc->dc_flags |= DC_REDUCED_MII_POLL;
			sc->dc_flags |= DC_TX_POLL|DC_TX_USE_TX_INTR;
		}
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_MACRONIX_MX98715 ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ACCTON_EN1217) {
			found = 1;
			if (sc->dc_revision >= DC_REVISION_98715AEC_C &&
			    sc->dc_revision < DC_REVISION_98725)
				sc->dc_flags |= DC_128BIT_HASH;
			sc->dc_type = DC_TYPE_987x5;
			sc->dc_flags |= DC_TX_POLL|DC_TX_USE_TX_INTR;
			sc->dc_flags |= DC_REDUCED_MII_POLL|DC_21143_NWAY;
		}
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_MACRONIX_MX98727) {
			found = 1;
			sc->dc_type = DC_TYPE_987x5;
			sc->dc_flags |= DC_TX_POLL|DC_TX_USE_TX_INTR;
			sc->dc_flags |= DC_REDUCED_MII_POLL|DC_21143_NWAY;
		}
		break;
	case PCI_VENDOR_COMPEX:
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_COMPEX_98713) {
			found = 1;
			if (sc->dc_revision < DC_REVISION_98713A) {
				sc->dc_type = DC_TYPE_98713;
				sc->dc_flags |= DC_REDUCED_MII_POLL;
			}
			if (sc->dc_revision >= DC_REVISION_98713A)
				sc->dc_type = DC_TYPE_98713A;
			sc->dc_flags |= DC_TX_POLL|DC_TX_USE_TX_INTR;
		}
		break;
	case PCI_VENDOR_LITEON:
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_LITEON_PNICII) {
			found = 1;
			sc->dc_type = DC_TYPE_PNICII;
			sc->dc_flags |= DC_TX_POLL|DC_TX_USE_TX_INTR;
			sc->dc_flags |= DC_REDUCED_MII_POLL|DC_21143_NWAY;
			sc->dc_flags |= DC_128BIT_HASH;
		}
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_LITEON_PNIC) {
			found = 1;
			sc->dc_type = DC_TYPE_PNIC;
			sc->dc_flags |= DC_TX_STORENFWD|DC_TX_INTR_ALWAYS;
			sc->dc_flags |= DC_PNIC_RX_BUG_WAR;
			sc->dc_pnic_rx_buf = malloc(ETHER_MAX_DIX_LEN * 5,
			    M_DEVBUF, M_NOWAIT);
			if (sc->dc_pnic_rx_buf == NULL)
				panic("dc_pci_attach");
			if (sc->dc_revision < DC_REVISION_82C169)
				sc->dc_pmode = DC_PMODE_SYM;
		}
		break;
	case PCI_VENDOR_ASIX:
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ASIX_AX88140A) {
			found = 1;
			sc->dc_type = DC_TYPE_ASIX;
			sc->dc_flags |= DC_TX_USE_TX_INTR|DC_TX_INTR_FIRSTFRAG;
			sc->dc_flags |= DC_REDUCED_MII_POLL;
			sc->dc_pmode = DC_PMODE_MII;
		}
		break;
	case PCI_VENDOR_CONEXANT:
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CONEXANT_RS7112) {
			found = 1;
			sc->dc_type = DC_TYPE_CONEXANT;
			sc->dc_flags |= DC_TX_INTR_ALWAYS;
			sc->dc_flags |= DC_REDUCED_MII_POLL;
			sc->dc_pmode = DC_PMODE_MII;
			dc_read_srom(sc, sc->dc_romwidth);
		}
		break;
	case PCI_VENDOR_XIRCOM:
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_XIRCOM_X3201_3_21143) {
			found = 1;
			sc->dc_type = DC_TYPE_XIRCOM;
			sc->dc_flags |= DC_TX_INTR_ALWAYS;
			sc->dc_flags |= DC_TX_COALESCE;
			sc->dc_flags |= DC_TX_ALIGN;
			sc->dc_pmode = DC_PMODE_MII;
		}
		break;
	}
	if (found == 0) {
		/* This shouldn't happen if probe has done its job... */
		printf(": unknown device: %x:%x\n",
		    PCI_VENDOR(pa->pa_id), PCI_PRODUCT(pa->pa_id));
		goto fail_2;
	}

	/* Save the cache line size. */
	if (DC_IS_DAVICOM(sc))
		sc->dc_cachesize = 0;
	else
		sc->dc_cachesize = pci_conf_read(pc, pa->pa_tag,
		    DC_PCI_CFLT) & 0xFF;

	/* Reset the adapter. */
	dc_reset(sc);

	/* Take 21143 out of snooze mode */
	if (DC_IS_INTEL(sc) || DC_IS_XIRCOM(sc)) {
		command = pci_conf_read(pc, pa->pa_tag, DC_PCI_CFDD);
		command &= ~(DC_CFDD_SNOOZE_MODE|DC_CFDD_SLEEP_MODE);
		pci_conf_write(pc, pa->pa_tag, DC_PCI_CFDD, command);
	}

	/*
	 * If we discover later (in dc_attach) that we have an
	 * MII with no PHY, we need to have the 21143 drive the LEDs.
	 * Except there are some systems like the NEC VersaPro NoteBook PC
	 * which have no LEDs, and twiddling these bits has adverse effects
	 * on them. (I.e. you suddenly can't get a link.)
	 *
	 * If mii_attach() returns an error, we leave the DC_TULIP_LEDS
	 * bit set, else we clear it. Since our dc(4) driver is split into
	 * bus-dependent and bus-independent parts, we must do set this bit
	 * here while we are able to do PCI configuration reads.
	 */
	if (DC_IS_INTEL(sc)) {
		if (pci_conf_read(pc, pa->pa_tag, DC_PCI_CSID) != 0x80281033)
			sc->dc_flags |= DC_TULIP_LEDS;
	}

	/*
	 * Try to learn something about the supported media.
	 * We know that ASIX and ADMtek and Davicom devices
	 * will *always* be using MII media, so that's a no-brainer.
	 * The tricky ones are the Macronix/PNIC II and the
	 * Intel 21143.
	 */
	if (DC_IS_INTEL(sc))
		dc_parse_21143_srom(sc);
	else if (DC_IS_MACRONIX(sc) || DC_IS_PNICII(sc)) {
		if (sc->dc_type == DC_TYPE_98713)
			sc->dc_pmode = DC_PMODE_MII;
		else
			sc->dc_pmode = DC_PMODE_SYM;
	} else if (!sc->dc_pmode)
		sc->dc_pmode = DC_PMODE_MII;

#ifdef __sparc64__
	{
		extern void myetheraddr(u_char *);

		if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
		    sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN) <= 0)
			myetheraddr(sc->sc_arpcom.ac_enaddr);
		if (sc->sc_arpcom.ac_enaddr[0] == 0x00 &&
		    sc->sc_arpcom.ac_enaddr[1] == 0x03 &&
		    sc->sc_arpcom.ac_enaddr[2] == 0xcc)
			sc->dc_flags |= DC_MOMENCO_BOTCH;
		sc->sc_hasmac = 1;
	}
#endif

#ifdef SRM_MEDIA
	sc->dc_srm_media = 0;

	/* Remember the SRM console media setting */
	if (DC_IS_INTEL(sc)) {
		command = pci_conf_read(pc, pa->pa_tag, DC_PCI_CFDD);
		command &= ~(DC_CFDD_SNOOZE_MODE|DC_CFDD_SLEEP_MODE);
		switch ((command >> 8) & 0xff) {
		case 3: 
			sc->dc_srm_media = IFM_10_T;
			break;
		case 4: 
			sc->dc_srm_media = IFM_10_T | IFM_FDX;
			break;
		case 5: 
			sc->dc_srm_media = IFM_100_TX;
			break;
		case 6: 
			sc->dc_srm_media = IFM_100_TX | IFM_FDX;
			break;
		}
		if (sc->dc_srm_media)
			sc->dc_srm_media |= IFM_ACTIVE | IFM_ETHER;
	}
#endif
	dc_attach(sc);

	return;

fail_2:
	pci_intr_disestablish(pc, sc->sc_ih);

fail_1:
	bus_space_unmap(sc->dc_btag, sc->dc_bhandle, psc->psc_mapsize);
}

int
dc_pci_detach(struct device *self, int flags)
{
	struct dc_pci_softc *psc = (void *)self;
	struct dc_softc *sc = &psc->psc_softc;

	if (sc->sc_ih != NULL)
		pci_intr_disestablish(psc->psc_pc, sc->sc_ih);	
	dc_detach(sc);
	bus_space_unmap(sc->dc_btag, sc->dc_bhandle, psc->psc_mapsize);

	return (0);
}

struct cfattach dc_pci_ca = {
	sizeof(struct dc_softc), dc_pci_match, dc_pci_attach, dc_pci_detach,
	dc_activate
};
@


1.75
log
@Convert some malloc(9) to mallocarray(9)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.74 2015/11/24 17:11:39 mpi Exp $	*/
d363 1
a363 1
			sc->dc_pnic_rx_buf = mallocarray(5, ETHER_MAX_DIX_LEN,
@


1.74
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.73 2015/11/24 13:33:17 mpi Exp $	*/
d363 2
a364 2
			sc->dc_pnic_rx_buf = malloc(ETHER_MAX_DIX_LEN * 5, M_DEVBUF,
			    M_NOWAIT);
@


1.73
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.72 2015/03/14 03:38:48 jsg Exp $	*/
a51 1
#include <net/if_dl.h>
@


1.72
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.71 2014/12/22 02:28:52 tedu Exp $	*/
a52 1
#include <net/if_types.h>
@


1.71
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.70 2014/07/22 13:12:11 mpi Exp $	*/
a63 1
#include <dev/mii/mii.h>
@


1.70
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.69 2013/08/07 01:06:34 bluhm Exp $	*/
a54 1
#ifdef INET
a56 1
#endif
@


1.69
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.68 2012/10/18 21:44:21 deraadt Exp $	*/
a56 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.68
log
@Convert a number of old private copies of code which predates
pci_set_powerstate() to using it instead.  Many of these chunks of code had
bugs in them, especially missing delay() calls.  Some of them were doing
things our PCI subsystem is now responsible for handling.  If you have
any of the affected devices, please keep an eye out for regressions.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.67 2010/08/27 19:54:03 deraadt Exp $	*/
a57 1
#include <netinet/in_var.h>
@


1.67
log
@Move the dc_pci_activate function to dc.c, and mangle it up with some of
the gunk in dc_powerhook.  Then make dc_powerhook just call it
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.66 2010/08/05 07:57:05 deraadt Exp $	*/
a127 1
void dc_pci_acpi(struct device *, void *);
a171 40
void
dc_pci_acpi(struct device *self, void *aux)
{
	struct dc_pci_softc	*psc = (struct dc_pci_softc *)self;
	struct dc_softc		*sc = &psc->psc_softc;
	struct pci_attach_args	*pa = (struct pci_attach_args *)aux;
	pci_chipset_tag_t	pc = pa->pa_pc;
	u_int32_t		r, cptr;

	/* Find the location of the capabilities block */
	cptr = pci_conf_read(pc, pa->pa_tag, DC_PCI_CCAP) & 0xFF;

	r = pci_conf_read(pc, pa->pa_tag, cptr) & 0xFF;
	if (r == 0x01) {

		r = pci_conf_read(pc, pa->pa_tag, cptr + PCI_PMCSR);
		if (r & DC_PSTATE_D3) {
			u_int32_t		iobase, membase, irq;

			/* Save important PCI config data. */
			iobase = pci_conf_read(pc, pa->pa_tag, DC_PCI_CFBIO);
			membase = pci_conf_read(pc, pa->pa_tag, DC_PCI_CFBMA);
			irq = pci_conf_read(pc, pa->pa_tag, DC_PCI_CFIT);

			/* Reset the power state. */
			printf("%s: chip is in D%d power mode "
			    "-- setting to D0\n", sc->sc_dev.dv_xname,
			    r & DC_PSTATE_D3);
			r &= 0xFFFFFFFC;
			pci_conf_write(pc, pa->pa_tag, cptr + PCI_PMCSR, r);

			/* Restore PCI config data. */
			pci_conf_write(pc, pa->pa_tag, DC_PCI_CFBIO, iobase);
			pci_conf_write(pc, pa->pa_tag, DC_PCI_CFBMA, membase);
			pci_conf_write(pc, pa->pa_tag, DC_PCI_CFIT, irq);
		}
	}
	return;
}

d191 1
a191 4
	/*
	 * Handle power management nonsense.
	 */
	dc_pci_acpi(self, aux);
@


1.66
log
@ca_activate function for suspend/resume; tested by mlarkin on a
Davicom DM9102.  (bit of noise on suspend or resume, but that can be
dealt with later)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.65 2009/10/15 17:54:56 deraadt Exp $	*/
a127 1
int dc_pci_activate(struct device *, int);
a575 22
int
dc_pci_activate(struct device *self, int act)
{
	struct dc_pci_softc *psc = (void *)self;
	struct dc_softc *sc = &psc->psc_softc;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			dc_stop(sc, 0);
		config_activate_children(self, act);
		break;
	case DVACT_RESUME:
		config_activate_children(self, act);
		if (ifp->if_flags & IFF_UP)
			dc_init(sc);
		break;
	}
	return (0);
}

d578 1
a578 1
	dc_pci_activate
@


1.65
log
@Add detach support to a few more drivers, and in others do the neccessary
operations in the detach function in the right order.  Also ensure that the
interrupt handlers not trust registers that go away.
read over very carefully by dms, tested by me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.64 2009/06/26 16:58:45 deraadt Exp $	*/
d128 1
d577 22
d600 2
a601 1
	sizeof(struct dc_softc), dc_pci_match, dc_pci_attach, dc_pci_detach
@


1.64
log
@Using information gleamed from the FreeBSD driver, change the MAC address
reading to use the eeprom instead of CIS, and then the Xircom Cardbus cards
can work in the expresscard adaptor, as pci devices.
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.63 2009/06/02 15:39:35 jsg Exp $	*/
a566 5
	int rv = 0;

	rv = dc_detach(sc);
	if (rv)
		return (rv);
d570 1
a570 1

d573 1
a573 1
	return (rv);
@


1.63
log
@make dc at pci detachable; untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.62 2009/06/02 04:03:39 jsg Exp $	*/
d114 1
d278 2
a279 2
	/* Get the eeprom width, but PNIC has no eeprom */
	if (!(PCI_VENDOR(pa->pa_id) == PCI_VENDOR_LITEON &&
d281 5
d442 10
d471 1
a471 1
	if (DC_IS_INTEL(sc)) {
@


1.62
log
@Add more CardBus ids to PCI attachments to cope with
things like the crazy ExpressCard->CardBus adapters which
make CardBus devices show as PCI devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.61 2008/09/11 06:49:14 brad Exp $	*/
d126 1
d129 6
d175 2
a176 1
	struct dc_softc		*sc = (struct dc_softc *)self;
d221 2
a222 1
	struct dc_softc		*sc = (struct dc_softc *)self;
a225 1
	bus_size_t		size;
d228 1
d244 1
a244 1
	    &sc->dc_btag, &sc->dc_bhandle, NULL, &size, 0)) {
d251 1
a251 1
	    &sc->dc_btag, &sc->dc_bhandle, NULL, &size, 0)) {
d543 20
a562 1
	bus_space_unmap(sc->dc_btag, sc->dc_bhandle, size);
d566 1
a566 1
	sizeof(struct dc_softc), dc_pci_match, dc_pci_attach
@


1.61
log
@ANSI function declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.60 2008/09/11 05:39:51 brad Exp $	*/
d112 9
@


1.60
log
@Remove the redundant local variable 'revision' from the PCI attach function.
The softc field dc_revision contains the PCI revision. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.59 2007/11/26 17:45:14 brad Exp $	*/
d124 1
a124 3
dc_pci_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d156 2
a157 3
void dc_pci_acpi(self, aux)
	struct device *self;
	void *aux;
d199 2
a200 3
void dc_pci_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
@


1.59
log
@print the comma before the MAC address string in dc_attach() instead of the
PCI front end attach function. This corrects the dmesg output for CardBus
adapters and ensures proper dmesg output if an error occurs in dc_attach().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.58 2007/08/01 16:30:03 miod Exp $	*/
a212 1
	u_int32_t		revision;
d261 1
a261 1
	sc->dc_revision = revision = PCI_REVISION(pa->pa_class);
d344 1
a344 1
			if (revision < DC_REVISION_98713A) {
d346 1
a346 2
			}
			if (revision >= DC_REVISION_98713A) {
d356 2
a357 2
			if (revision >= DC_REVISION_98715AEC_C &&
			    revision < DC_REVISION_98725)
d373 1
a373 1
			if (revision < DC_REVISION_98713A) {
d377 1
a377 1
			if (revision >= DC_REVISION_98713A)
d399 1
a399 1
			if (revision < DC_REVISION_82C169)
@


1.58
log
@Stop making de win over dc on alpha, and include both dc and de on all
installation media now - it fits.

THIS MEANS YOU NEED TO RENAME /etc/hostname.de0 TO /etc/hostname.dc0
BEFORE BOOTING A NEW KERNEL.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.57 2007/04/10 17:47:55 miod Exp $	*/
d259 1
a259 1
	printf(": %s,", intrstr);
@


1.57
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.56 2007/02/13 10:38:00 jsg Exp $	*/
a147 5
	/*
	 * Since dc doesn't fit on the alpha floppy, we want de to win by
	 * default on alpha so that RAMDISK* and GENERIC will use the same
	 * driver.
	 */
a150 3
#ifdef __alpha__
			return (1);
#else
a151 1
#endif
@


1.56
log
@Add missing break in attach code.
ok tom@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.55 2006/07/20 02:49:18 brad Exp $	*/
d435 1
a435 1
		/* This shouldn't happen if probe has done it's job... */
@


1.55
log
@update for the new ADMtek PCI ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.54 2006/07/18 23:56:47 brad Exp $	*/
d297 1
@


1.54
log
@attach to the ADMtek 983B chipset as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.53 2006/06/17 18:00:43 brad Exp $	*/
d95 2
a98 1
	{ PCI_VENDOR_ADMTEK, PCI_PRODUCT_ADMTEK_AN983B },
d326 3
a328 2
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADMTEK_AN983 ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADMTEK_AN983B ||
@


1.53
log
@add sys/timeout.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.52 2005/11/06 19:25:21 brad Exp $	*/
d97 1
d326 1
@


1.52
log
@- remove spl from attach
- de-allocate resources on failure to attach
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.51 2005/08/09 04:10:11 mickey Exp $	*/
d46 1
@


1.51
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.50 2005/03/26 15:49:09 mickey Exp $	*/
a211 1
	int			s;
d218 1
a218 1
	bus_size_t		iosize;
a221 1
	s = splimp();
d235 3
a237 2
	if (pci_mapreg_map(pa, DC_PCI_CFBIO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->dc_btag, &sc->dc_bhandle, NULL, &iosize, 0)) {
d242 3
a244 2
	if (pci_mapreg_map(pa, DC_PCI_CFBMA, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->dc_btag, &sc->dc_bhandle, NULL, &iosize, 0)) {
d253 1
a253 1
		goto fail;
d263 1
a263 1
		goto fail;
d432 1
a432 1
		goto fail;
d528 7
a534 2
fail:
	splx(s);
@


1.50
log
@simplify man! no need to outline pci_mapreg_map() anymore just use it
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.49 2005/01/16 20:47:44 brad Exp $	*/
d214 1
a214 1
	u_int32_t		command;
d231 2
a235 8
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	    PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);

	sc->dc_csid = pci_conf_read(pc, pa->pa_tag, PCI_SUBSYS_ID_REG);

@


1.49
log
@- recognize Microsoft PCI and CardBus adapters
- recognize Hawking CardBus adapter
- simplify 3Com switch case and fold in with ADMtek case
- use 64-bit multicast hash for all instances of ADMtek 983 chipset

Hawking CardBus adapter reported by Alec Berryman <alec at thened dot net>
Microsoft adapters from FreeBSD dc(4) driver
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.48 2005/01/16 19:46:00 brad Exp $	*/
a218 1
	bus_addr_t		iobase;
d243 4
a246 3
	if (!(command & PCI_COMMAND_IO_ENABLE)) {
		printf(": failed to enable I/O ports\n");
		goto fail;
a247 9
	if (pci_io_find(pc, pa->pa_tag, DC_PCI_CFBIO, &iobase, &iosize)) {
		printf(": can't find I/O space\n");
		goto fail;
	}
	if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->dc_bhandle)) {
		printf(": can't map I/O space\n");
		goto fail;
	}
	sc->dc_btag = pa->pa_iot;
d249 2
a250 9
	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf(": failed to enable memory mapping\n");
		goto fail;
	}
	if (pci_mem_find(pc, pa->pa_tag, DC_PCI_CFBMA, &iobase, &iosize, NULL)){
		printf(": can't find mem space\n");
		goto fail;
	}
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->dc_bhandle)) {
d252 1
a252 1
		goto fail;
a253 1
	sc->dc_btag = pa->pa_memt;
@


1.48
log
@get EEPROM width on all cards except for the original PNIC
or XIRCOM cards.

Based on the FreeBSD dc(4) driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.47 2005/01/14 15:04:52 brad Exp $	*/
d108 1
d335 1
d337 1
a337 10
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_3COM_3CSHO100BTX) {
			found = 1;
			sc->dc_type = DC_TYPE_AN983;
			sc->dc_flags |= DC_TX_USE_TX_INTR;
			sc->dc_flags |= DC_TX_ADMTEK_WAR;
			sc->dc_pmode = DC_PMODE_MII;
			/* Don't read SROM for - auto-loaded on reset */
		}
		break;
	case PCI_VENDOR_ADMTEK:
d346 3
a348 1
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADMTEK_AN983) {
d365 1
@


1.47
log
@rev 1.63

Avoid an unnecessary copy of a packet if it is already in a single mbuf.
Introduce an additional device flag for those NICs which require the
transmit buffers to be aligned to 32-bit boundaries.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.46 2005/01/08 06:02:59 brad Exp $	*/
d292 5
a304 1
			dc_eeprom_width(sc);
a313 1
			dc_eeprom_width(sc);
d341 1
a342 2
		dc_eeprom_width(sc);
		dc_read_srom(sc, sc->dc_romwidth);
a350 1
			dc_eeprom_width(sc);
a359 1
			dc_eeprom_width(sc);
d371 1
a371 3

			dc_eeprom_width(sc);
			dc_read_srom(sc, sc->dc_romwidth);
a450 1
			dc_eeprom_width(sc);
a552 1
	dc_eeprom_width(sc);
@


1.46
log
@rev 1.125

Don't read the MAC address from a copy of the EEPROM in the softc
that has been recorded earlier and overwrite it again later by
reading it directly from the EEPROM again.

Read the MAC address from the PAR0/PAR1 registers instead, which
are autoloaded on reboot.

From FreeBSD

Thanks to David Snyder <dasnyderx at yahoo dot com> for testing on
a AN983 based card which used to come up with a MAC address of
ff:ff:ff:ff:ff:ff.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.45 2004/09/28 16:58:56 brad Exp $	*/
d321 1
@


1.45
log
@Use ETHER_MIN_LEN/ETHER_MAX_DIX_LEN
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.44 2004/08/04 15:02:29 mickey Exp $	*/
d348 2
d358 2
a360 2
		dc_eeprom_width(sc);
		dc_read_srom(sc, sc->dc_romwidth);
@


1.44
log
@kill hppa quirk that is not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.43 2004/06/28 12:34:20 mickey Exp $	*/
d426 1
a426 1
			sc->dc_pnic_rx_buf = malloc(DC_RXLEN * 5, M_DEVBUF,
@


1.43
log
@do not force into io space on hppa as it's much slower
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.42 2003/10/21 21:48:07 deraadt Exp $	*/
d465 1
a465 1
	else {
a467 4
#ifdef __hppa__
		sc->dc_cachesize = 16;
#endif
	}
@


1.42
log
@a 3com tulip, wow; christoph.scheurer@@ch.tum.de
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.41 2003/10/07 14:11:04 fgsch Exp $	*/
d79 1
d81 1
@


1.41
log
@use PCI_PMCSR instead of some magic value.
ok krw@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.39 2003/08/16 14:42:19 henning Exp $	*/
d105 1
d327 11
@


1.40
log
@fix the dc_cacheline to 16 on hppa
@
text
@d175 1
a175 1
		r = pci_conf_read(pc, pa->pa_tag, cptr + 4);
d189 1
a189 1
			pci_conf_write(pc, pa->pa_tag, cptr + 4, r);
@


1.39
log
@AN983 needs 64BIT_HASH too, fixes multicast
From: jared r r spiegel <jrrs@@gateway.nodeless.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.38 2003/06/26 00:46:14 mickey Exp $	*/
d451 1
a451 1
	else
d454 4
@


1.38
log
@it's better w/ a comma between irq and address
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.37 2003/05/17 01:55:29 jason Exp $	*/
d340 1
@


1.37
log
@fix up the media handling for the intel based MACs.  Also hack around a
bug in the Momenco firmware on the Leopard-V, which now has one port
working.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.36 2003/04/29 21:39:34 jason Exp $	*/
d284 1
a284 1
	printf(": %s", intrstr);
@


1.36
log
@- remove last vestige of "old autoconf": dc_unit is dead, long live dv_xname
- remove a bunch of #if 0 stuff (most of which referred to dc_unit, grr)
- delay a bzero until necessary
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.35 2003/04/19 11:54:02 henning Exp $	*/
d505 4
@


1.35
log
@Davicom DM9009 support

tested by Lucas Reddinger <lucas at wlwdesigns.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.34 2002/10/20 16:46:28 henning Exp $	*/
a167 3
	int			unit;

	unit = sc->dc_unit;
d185 3
a187 2
			printf("dc%d: chip is in D%d power mode "
			    "-- setting to D0\n", unit, r & DC_PSTATE_D3);
a221 1
	sc->dc_unit = sc->sc_dev.dv_unit;
@


1.34
log
@add support for intel 21145
This chip is some strange abnormal 21143 variant. It really only works with
10 MBit/s halfduplex only and autonegotiation is totally broken in hardware.
Should also have a HomePNA phy, but we don't support that.
for now requires and explicit "media 10BaseT".
if anybody has such a chip please mail me.

nick@@ is the only one who has the hardware and did an incredible amount of
testing. Thanks for all the help, Nick!

some hints and ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.33 2002/06/09 05:49:35 art Exp $	*/
d89 1
d315 2
a316 1
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DAVICOM_DM9102) {
@


1.33
log
@unbreak sparc64 kernel builds after the arpcom change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.32 2002/04/18 19:11:18 jason Exp $	*/
d103 1
d303 9
@


1.32
log
@add support for Conexant LANfinity RS7112; based on patch from Maurice Nonnekes <maurice@@amaze.nl> based on FreeBSD (only minor surgery necessary)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.31 2002/04/16 21:29:54 jason Exp $	*/
d494 2
a495 2
		    sc->arpcom.ac_enaddr, ETHER_ADDR_LEN) <= 0)
			myetheraddr(sc->arpcom.ac_enaddr);
@


1.31
log
@move prototypes of dc_eeprom_width, dc_read_srom, and dc_parse_21143_srom to dcreg.h and out of the bus specific drivers
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.30 2002/04/01 18:41:47 nate Exp $	*/
d102 1
d417 11
@


1.30
log
@Don't have dc and de return the same match value in any case.
Comment the reasoning for the various return values in dc_pci_match.
dc is preferred over de on all archs except for alpha where de is used.
The main reason dc is not preferred on alpha is that it doesn't fit
on the floppy, so RAMDISK and GENERIC would have different drivers for
the same device which is rather confusing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.29 2002/03/22 05:37:48 jason Exp $	*/
a107 4

extern void dc_eeprom_width(struct dc_softc *);
extern void dc_read_srom(struct dc_softc *, int);
extern void dc_parse_21143_srom(struct dc_softc *);
@


1.29
log
@On sparc64, try local-mac-address before falling back to myetheraddr()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.28 2002/03/14 01:26:58 millert Exp $	*/
d125 4
d133 4
d142 5
d153 1
a153 1
			return (2);
@


1.28
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.27 2002/03/06 23:14:17 nate Exp $	*/
d75 4
d471 4
a474 1
		myetheraddr(sc->arpcom.ac_enaddr);
@


1.27
log
@remove unused #include
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.26 2002/03/04 22:39:35 nate Exp $	*/
d101 7
a107 7
int dc_pci_match		__P((struct device *, void *, void *));
void dc_pci_attach		__P((struct device *, struct device *, void *));
void dc_pci_acpi		__P((struct device *, void *));

extern void dc_eeprom_width	__P((struct dc_softc *));
extern void dc_read_srom	__P((struct dc_softc *, int));
extern void dc_parse_21143_srom	__P((struct dc_softc *));
d466 1
a466 1
		extern void myetheraddr __P((u_char *));
@


1.26
log
@21140 support for dc isn't reliable enough for it to win over dc.
dc doesn't fit on the alpha ramdisk, so let de win in all cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.25 2002/02/17 05:27:39 nate Exp $	*/
a66 2

#include <uvm/uvm_extern.h>              /* for vtophys */
@


1.25
log
@make dc win on alpha too
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.24 2002/02/17 05:12:56 nate Exp $	*/
d124 4
d135 3
d139 1
@


1.24
log
@Make dc match with higher priorit over de for 21142/3 chips
Also match on 21140
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.23 2002/01/11 01:31:21 nordin Exp $	*/
a130 3
#if defined(__alpha__)
			return (1);
#else
a131 1
#endif
@


1.23
log
@Check result from malloc(9) when using M_NOWAIT. fgsch@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.22 2001/12/13 17:43:03 nate Exp $	*/
d85 1
d123 5
d130 2
a131 1
		    (PCI_PRODUCT(pa->pa_id) == t->dc_did))
d133 4
d138 1
d276 2
a277 1
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_21142) {
@


1.22
log
@Fix old alpha bug recently triggered by conversion to busdma.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.21 2001/12/06 20:12:00 jason Exp $	*/
d375 2
@


1.22.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.23 2002/01/11 01:31:21 nordin Exp $	*/
a374 2
			if (sc->dc_pnic_rx_buf == NULL)
				panic("dc_pci_attach");
@


1.22.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.22.2.1 2002/01/31 22:55:35 niklas Exp $	*/
d68 2
a76 4
#ifdef __sparc64__
#include <dev/ofw/openfirm.h>
#endif

a84 1
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_21140 },
a98 1
	{ PCI_VENDOR_CONEXANT, PCI_PRODUCT_CONEXANT_RS7112 },
d102 7
a108 3
int dc_pci_match(struct device *, void *, void *);
void dc_pci_attach(struct device *, struct device *, void *);
void dc_pci_acpi(struct device *, void *);
a121 22
	/*
	 * Support for the 21140 chip is experimental.  If it works for you,
	 * that's great.  By default, this chip will use de.
	 */
        if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DEC &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_21140)
		return (1);

	/*
	 * The following chip revision doesn't seem to work so well with dc,
	 * so let's have de handle it.  (de will return a match of 2)
	 */
        if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DEC &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_21142 &&
	    PCI_REVISION(pa->pa_class) == 0x21)
		return (1);

	/*
	 * Since dc doesn't fit on the alpha floppy, we want de to win by
	 * default on alpha so that RAMDISK* and GENERIC will use the same
	 * driver.
	 */
d124 1
a124 2
		    (PCI_PRODUCT(pa->pa_id) == t->dc_did)) {
#ifdef __alpha__
a125 4
#else
			return (3);
#endif
		}
a126 1

d264 1
a264 2
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_21140 ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_21142) {
a389 11
	case PCI_VENDOR_CONEXANT:
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CONEXANT_RS7112) {
			found = 1;
			sc->dc_type = DC_TYPE_CONEXANT;
			sc->dc_flags |= DC_TX_INTR_ALWAYS;
			sc->dc_flags |= DC_REDUCED_MII_POLL;
			sc->dc_pmode = DC_PMODE_MII;
			dc_eeprom_width(sc);
			dc_read_srom(sc, sc->dc_romwidth);
		}
		break;
d451 2
a452 5
		extern void myetheraddr(u_char *);

		if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
		    sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN) <= 0)
			myetheraddr(sc->sc_arpcom.ac_enaddr);
@


1.22.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.22.2.2 2002/06/11 03:42:25 art Exp $	*/
a102 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_21145 },
a301 9
	case PCI_VENDOR_INTEL:
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_21145) {
			found = 1;
			sc->dc_type = DC_TYPE_21145;
			sc->dc_flags |= DC_TX_POLL|DC_TX_USE_TX_INTR;
			sc->dc_flags |= DC_REDUCED_MII_POLL;
			dc_eeprom_width(sc);
			dc_read_srom(sc, sc->dc_romwidth);
		}
@


1.22.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a88 1
	{ PCI_VENDOR_DAVICOM, PCI_PRODUCT_DAVICOM_DM9009 },
d167 3
d187 2
a188 3
			printf("%s: chip is in D%d power mode "
			    "-- setting to D0\n", sc->sc_dev.dv_xname,
			    r & DC_PSTATE_D3);
d223 1
d314 1
a314 2
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DAVICOM_DM9102 ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DAVICOM_DM9009) {
a505 4
		if (sc->sc_arpcom.ac_enaddr[0] == 0x00 &&
		    sc->sc_arpcom.ac_enaddr[1] == 0x03 &&
		    sc->sc_arpcom.ac_enaddr[2] == 0xcc)
			sc->dc_flags |= DC_MOMENCO_BOTCH;
@


1.21
log
@enough bus_dmamap_sync() and htole()/letoh() to get TX working on sparc64.
ALso, get the MAC address from myetheraddr() instead of trying to use the eeprom on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.20 2001/12/06 05:42:12 jason Exp $	*/
d460 1
a460 1
		command = pci_read_config(dev, DC_PCI_CFDD, 4);
@


1.20
log
@Checkpoint bus_dma work in progress:
- descriptor lists are now bus_dma allocated and manipulated
(for those keeping score: 6 vtophys dead, 4 to go)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.19 2001/11/06 19:53:19 miod Exp $	*/
d446 8
@


1.19
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.18 2001/10/06 14:37:48 aaron Exp $	*/
d193 1
@


1.18
log
@We must read the SROM ahead of time for all ADMtek-based PCI cards; based on
patch from ckuethe@@pyxis.cns.ualberta.ca in PR/2102. At some point after 3.0
I must de-cruftify the dc(4) matching code to avoid such errors. :(
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.17 2001/08/25 10:13:29 art Exp $	*/
d68 1
a68 1
#include <vm/vm.h>              /* for vtophys */
@


1.17
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.16 2001/08/22 16:38:38 aaron Exp $	*/
d314 3
@


1.16
log
@Support more dc(4) CardBus devices, including the AN985-based Linksys PCMPC200
10/100 CardBus Ethernet adapter (thanks to beck@@ for the donation).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.15 2001/08/14 16:19:01 aaron Exp $	*/
d242 1
a242 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin, pa->pa_intrline,
	    &ih)) {
@


1.15
log
@Call dc_read_srom with the correct width; patch from gluk@@. Fixes problems
with multiple 21143 interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.14 2001/08/12 20:03:49 mickey Exp $	*/
d304 2
@


1.14
log
@remove redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.13 2001/04/06 17:14:14 aaron Exp $	*/
d269 2
a270 1
			dc_read_srom(sc, 9);
@


1.13
log
@- For CardBus 21143 cards, parse the SROM. Makes my SMC EZ CardBus 10/100 work.
- General cleanup in the dc CardBus attachment.
- Split detach up into bus-dependent and bus-independent parts.
- Some function and variable renaming for consistency.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.12 2001/02/09 02:23:36 aaron Exp $	*/
a68 1
#include <vm/pmap.h>            /* for vtophys */
@


1.13.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.13 2001/04/06 17:14:14 aaron Exp $	*/
@


1.13.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.13.4.1 2001/05/14 22:25:43 niklas Exp $	*/
d69 1
d243 2
a244 1
	if (pci_intr_map(pa, &ih)) {
d270 1
a270 2
			dc_eeprom_width(sc);
			dc_read_srom(sc, sc->dc_romwidth);
a303 2
		dc_eeprom_width(sc);
		dc_read_srom(sc, sc->dc_romwidth);
a312 3

			dc_eeprom_width(sc);
			dc_read_srom(sc, sc->dc_romwidth);
@


1.13.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 1
a68 1
#include <uvm/uvm_extern.h>              /* for vtophys */
@


1.13.4.4
log
@Merge in trunk
@
text
@a84 1
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_21140 },
a121 9
        if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DEC &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_21140)
		return (1);

        if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DEC &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_21142 &&
	    PCI_REVISION(pa->pa_class) == 0x21)
		return (1);

d124 1
a124 2
		    (PCI_PRODUCT(pa->pa_id) == t->dc_did)) {
#ifdef __alpha__
a125 4
#else
			return (2);
#endif
		}
a126 1

a192 1
	sc->sc_dmat = pa->pa_dmat;
d263 1
a263 2
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_21140 ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DEC_21142) {
a373 2
			if (sc->dc_pnic_rx_buf == NULL)
				panic("dc_pci_attach");
a445 8
#ifdef __sparc64__
	{
		extern void myetheraddr __P((u_char *));
		myetheraddr(sc->arpcom.ac_enaddr);
		sc->sc_hasmac = 1;
	}
#endif

d451 1
a451 1
		command = pci_conf_read(pc, pa->pa_tag, DC_PCI_CFDD);
@


1.13.4.5
log
@Merge in -current from roughly a week ago
@
text
@d68 2
d103 7
a109 7
int dc_pci_match(struct device *, void *, void *);
void dc_pci_attach(struct device *, struct device *, void *);
void dc_pci_acpi(struct device *, void *);

extern void dc_eeprom_width(struct dc_softc *);
extern void dc_read_srom(struct dc_softc *, int);
extern void dc_parse_21143_srom(struct dc_softc *);
d468 1
a468 1
		extern void myetheraddr(u_char *);
@


1.13.4.6
log
@Sync the SMP branch with 3.3
@
text
@a74 4
#ifdef __sparc64__
#include <dev/ofw/openfirm.h>
#endif

a97 2
	{ PCI_VENDOR_CONEXANT, PCI_PRODUCT_CONEXANT_RS7112 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_21145 },
d105 4
a120 4
	/*
	 * Support for the 21140 chip is experimental.  If it works for you,
	 * that's great.  By default, this chip will use de.
	 */
a124 4
	/*
	 * The following chip revision doesn't seem to work so well with dc,
	 * so let's have de handle it.  (de will return a match of 2)
	 */
a129 5
	/*
	 * Since dc doesn't fit on the alpha floppy, we want de to win by
	 * default on alpha so that RAMDISK* and GENERIC will use the same
	 * driver.
	 */
d136 1
a136 1
			return (3);
a287 9
	case PCI_VENDOR_INTEL:
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_21145) {
			found = 1;
			sc->dc_type = DC_TYPE_21145;
			sc->dc_flags |= DC_TX_POLL|DC_TX_USE_TX_INTR;
			sc->dc_flags |= DC_REDUCED_MII_POLL;
			dc_eeprom_width(sc);
			dc_read_srom(sc, sc->dc_romwidth);
		}
a404 11
	case PCI_VENDOR_CONEXANT:
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CONEXANT_RS7112) {
			found = 1;
			sc->dc_type = DC_TYPE_CONEXANT;
			sc->dc_flags |= DC_TX_INTR_ALWAYS;
			sc->dc_flags |= DC_REDUCED_MII_POLL;
			sc->dc_pmode = DC_PMODE_MII;
			dc_eeprom_width(sc);
			dc_read_srom(sc, sc->dc_romwidth);
		}
		break;
d467 1
a467 4

		if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
		    sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN) <= 0)
			myetheraddr(sc->sc_arpcom.ac_enaddr);
@


1.13.4.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.13.4.6 2003/03/28 00:38:21 niklas Exp $	*/
a88 1
	{ PCI_VENDOR_DAVICOM, PCI_PRODUCT_DAVICOM_DM9009 },
d167 3
d187 2
a188 3
			printf("%s: chip is in D%d power mode "
			    "-- setting to D0\n", sc->sc_dev.dv_xname,
			    r & DC_PSTATE_D3);
d223 1
d314 1
a314 2
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DAVICOM_DM9102 ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DAVICOM_DM9009) {
@


1.13.4.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.13.4.7 2003/05/13 19:35:05 ho Exp $	*/
a504 4
		if (sc->sc_arpcom.ac_enaddr[0] == 0x00 &&
		    sc->sc_arpcom.ac_enaddr[1] == 0x03 &&
		    sc->sc_arpcom.ac_enaddr[2] == 0xcc)
			sc->dc_flags |= DC_MOMENCO_BOTCH;
@


1.13.4.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a104 1
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CSHO100BTX },
d175 1
a175 1
		r = pci_conf_read(pc, pa->pa_tag, cptr + PCI_PMCSR);
d189 1
a189 1
			pci_conf_write(pc, pa->pa_tag, cptr + PCI_PMCSR, r);
d284 1
a284 1
	printf(": %s,", intrstr);
a326 11
	case PCI_VENDOR_3COM:
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_3COM_3CSHO100BTX) {
			found = 1;
			sc->dc_type = DC_TYPE_AN983;
			sc->dc_flags |= DC_TX_USE_TX_INTR;
			sc->dc_flags |= DC_TX_ADMTEK_WAR;
			sc->dc_pmode = DC_PMODE_MII;
		}
		dc_eeprom_width(sc);
		dc_read_srom(sc, sc->dc_romwidth);
		break;
a339 1
			sc->dc_flags |= DC_64BIT_HASH;
d450 1
a450 1
	else {
a452 4
#ifdef __hppa__
		sc->dc_cachesize = 16;
#endif
	}
@


1.12
log
@Add support for parsing the media blocks from the SROM on the 21143 adapters.
These changes should make the driver work with the built-in Ethernet on the
Alpha Miata machines. From FreeBSD.

To make sure I didn't break anything (and as a general test), I tested the
modified driver with the following dc(4) variants: Macronix PMAC 98715,
Lite-On PNIC, Lite-On PNIC-II, ADMtek AL981, and ADMtek AN983.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.11 2000/11/16 01:25:45 aaron Exp $	*/
d103 3
a105 3
int dc_pci_probe	__P((struct device *, void *, void *));
void dc_pci_attach	__P((struct device *, struct device *, void *));
void dc_pci_acpi	__P((struct device *, void *));
d107 2
a108 2
extern void dc_read_eeprom	__P((struct dc_softc *, caddr_t, int, int,
				     int));
d116 1
a116 1
dc_pci_probe(parent, match, aux)
d270 1
a270 2
			/* Save EEPROM contents so we can parse them later. */
			dc_read_eeprom(sc, (caddr_t)&sc->dc_srom, 0, 512, 0);
d409 1
a409 1
	 * If we discover later (in dc_attach_common()) that we have an
d467 2
a468 2

	dc_attach_common(sc);
d475 1
a475 1
	sizeof(struct dc_softc), dc_pci_probe, dc_pci_attach
@


1.11
log
@Add support for Accton EN2242 MiniPCI adapters as found in HP OmniBook XE3
laptops; from FreeBSD. No special changes needed here, just the addition of
the EN2242's product ID since it is an ADMtek Centaur chip.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.10 2000/10/30 18:20:18 aaron Exp $	*/
d107 4
d270 2
d433 3
a435 26
	if (DC_IS_INTEL(sc)) {
		u_int32_t		media, cwuc;
		cwuc = pci_conf_read(pc, pa->pa_tag, DC_PCI_CWUC);
		cwuc |= DC_CWUC_FORCE_WUL;
		pci_conf_write(pc, pa->pa_tag, DC_PCI_CWUC, cwuc);
		DELAY(10000);
		media = pci_conf_read(pc, pa->pa_tag, DC_PCI_CWUC);
		cwuc &= ~DC_CWUC_FORCE_WUL;
		pci_conf_write(pc, pa->pa_tag, DC_PCI_CWUC, cwuc);
		DELAY(10000);
		if (media & DC_CWUC_MII_ABILITY)
			sc->dc_pmode = DC_PMODE_MII;
		if (media & DC_CWUC_SYM_ABILITY) {
			sc->dc_pmode = DC_PMODE_SYM;
			sc->dc_flags |= DC_21143_NWAY;
		}
		/*
		 * If none of the bits are set, then this NIC
		 * isn't meant to support 'wake up LAN' mode.
		 * This is usually only the case on multiport
		 * cards, and these cards almost always have
		 * MII transceivers.
		 */
		if (media == 0)
			sc->dc_pmode = DC_PMODE_MII;
	} else if (DC_IS_MACRONIX(sc) || DC_IS_PNICII(sc)) {
d442 26
@


1.10
log
@Match the Macronix 98727/98732 chips.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.9 2000/10/27 18:20:02 aaron Exp $	*/
d99 1
d302 7
@


1.9
log
@From FreeBSD:

Yet another bug fix/optimization for the Davicom DM9100/9102: increase the
PCI latency timer value to 0x80. Davicom's Linux driver does this, and it
drastically reduces the number of TX underruns in my tests. (Note: this is
done only for the Davicom chips. I'm not sure it's a good idea to do it
for all of them.)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.8 2000/10/27 18:13:44 aaron Exp $	*/
d94 1
d319 6
@


1.8
log
@From FreeBSD:

Set the DC_TX_INTR_ALWAYS and DC_TX_STORENFWD flags for the Davicom chips.
Do not set DC_TX_ONE. The DC_TX_USE_INTR flag causes dc_encap() to set the
'interrupt on TX completion' bit only once every 64 packets. This is an
attempt to reduce the number of interrupts generated by the chip. You're
supposed to get a 'no more TX buffers left' interrupt once you hit the last
packet whether you ask for one or not, however it seems the Davicom chip
doesn't generate this interrupt, or at least it doesn't generate it under
the same circumstances. The result is that if you transmit n packets, where
n is less than 64, and then wait 5 seconds, you'll get a watchdog timeout
whether you want one or not. The DC_TX_INTR_ALWAYS causes dc_encap() to
request an interrupt for every frame.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.7 2000/10/16 17:08:08 aaron Exp $	*/
d274 6
@


1.7
log
@Use mii_attach() directly instead of mii_phy_probe().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.6 2000/09/13 00:29:35 aaron Exp $	*/
d271 2
a272 2
			sc->dc_flags |= DC_TX_COALESCE|DC_TX_USE_TX_INTR;
			sc->dc_flags |= DC_REDUCED_MII_POLL;
@


1.6
log
@Sync with FreeBSD. Finally make the OpenBSD-specific changes necessary to make
non-MII 21143-based cards work. The sync just fixes the LED handling on these
kinds of adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.5 2000/08/02 19:01:07 aaron Exp $	*/
d389 1
a389 1
	 * If mii_phy_probe() returns an error, we leave the DC_TULIP_LEDS
@


1.5
log
@Sync with FreeBSD. Summary of changes:

- Add support for Accton EN1217 Ethernet adapters.
- Fix problems with LEDs on some cards when clearing the jabber disable bit.
- Handle new Macronix chips whose multicast hash tables are only 128 bits.
- Fix timing issues during autonegotiation with Macronix and PNIC II.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.4 2000/06/12 16:23:22 aaron Exp $	*/
d380 17
@


1.4
log
@Fix ADMtek identity crisis (whoops, missed this file); thanks mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.3 2000/04/26 13:58:28 mickey Exp $	*/
d97 1
d293 1
a297 1
				sc->dc_flags |= DC_REDUCED_MII_POLL;
d299 1
a299 1
			if (revision >= DC_REVISION_98713A)
d301 3
d306 2
a307 1
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_MACRONIX_MX98715) {
d309 3
d314 1
d334 2
d401 1
a401 1
		if (media & DC_CWUC_SYM_ABILITY)
d403 2
@


1.3
log
@we've done an oops
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.2 2000/04/26 03:28:57 mickey Exp $	*/
d90 1
a90 1
	{ PCI_VENDOR_ADMTEK, PCI_PRODUCT_ADMTEK_AN985 },
d283 1
a283 1
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADMTEK_AN985) {
d285 1
a285 1
			sc->dc_type = DC_TYPE_AN985;
@


1.2
log
@dc_csid ain't needed no more; jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_dc_pci.c,v 1.1 2000/04/18 19:35:31 jason Exp $	*/
d202 2
@


1.1
log
@split dc driver into bus dependent and bus independent (pci) parts
(cardbus to come later).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a201 2

	sc->dc_csid = pci_conf_read(pc, pa->pa_tag, PCI_SUBSYS_ID_REG);
@

