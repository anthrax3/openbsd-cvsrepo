head	1.23;
access;
symbols
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.4
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.14.0.10
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.4
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.4
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.6
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.3.0.8
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.4
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.23
date	2016.12.02.15.22.57;	author mikeb;	state Exp;
branches;
next	1.22;
commitid	HhscwhaelRtfhoK4;

1.22
date	2016.11.24.17.39.49;	author mikeb;	state Exp;
branches;
next	1.21;
commitid	CSMhgwhQh4b9XznH;

1.21
date	2016.11.21.17.08.56;	author mikeb;	state Exp;
branches;
next	1.20;
commitid	BUTazflQyG7Zabfo;

1.20
date	2016.11.21.12.37.35;	author mikeb;	state Exp;
branches;
next	1.19;
commitid	pbiH0RCeznqzU3NM;

1.19
date	2016.11.17.21.08.27;	author mikeb;	state Exp;
branches;
next	1.18;
commitid	nldMJuxfqfXVZAUt;

1.18
date	2016.11.17.20.44.04;	author mikeb;	state Exp;
branches;
next	1.17;
commitid	KOfaZlZSSU1u7i53;

1.17
date	2016.11.17.19.26.57;	author mikeb;	state Exp;
branches;
next	1.16;
commitid	s7sWiFVcUtMtUOpv;

1.16
date	2016.11.17.12.21.27;	author mikeb;	state Exp;
branches;
next	1.15;
commitid	rl7UKnhqgZzc9auT;

1.15
date	2016.11.16.23.19.29;	author mikeb;	state Exp;
branches;
next	1.14;
commitid	IZg2nJoFrsaft35v;

1.14
date	2014.11.26.17.03.52;	author kettenis;	state Exp;
branches;
next	1.13;
commitid	P466J07aIiHpN7VE;

1.13
date	2013.08.05.19.58.05;	author mikeb;	state Exp;
branches;
next	1.12;

1.12
date	2012.12.20.17.32.38;	author mikeb;	state Exp;
branches;
next	1.11;

1.11
date	2012.12.17.12.03.16;	author mikeb;	state Exp;
branches;
next	1.10;

1.10
date	2012.12.05.14.41.28;	author mikeb;	state Exp;
branches;
next	1.9;

1.9
date	2012.11.06.17.29.39;	author mikeb;	state Exp;
branches;
next	1.8;

1.8
date	2012.08.06.21.07.52;	author mikeb;	state Exp;
branches;
next	1.7;

1.7
date	2012.07.29.13.49.03;	author mikeb;	state Exp;
branches;
next	1.6;

1.6
date	2011.06.10.12.46.35;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.19.18.55.12;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2009.08.08.09.30.01;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.08.21.15.34;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.08.20.33.51;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.08.20.01.02;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Don't overwrite the selected flow control settings

procter@@ has noticed that flow control settings survive module change
when they should be forgotten.  It became clear that we're overwriting
the selected FC mode with the requested version instead of keeping
negotiated settings.  Tested by procter@@.
@
text
@/*	$OpenBSD: ixgbe.c,v 1.22 2016/11/24 17:39:49 mikeb Exp $	*/

/******************************************************************************

  Copyright (c) 2001-2015, Intel Corporation
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

   3. Neither the name of the Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

******************************************************************************/
/*$FreeBSD: head/sys/dev/ixgbe/ixgbe_common.c 299200 2016-05-06 22:54:56Z pfg $*/
/*$FreeBSD: head/sys/dev/ixgbe/ixgbe_mbx.c 299200 2016-05-06 22:54:56Z pfg $*/

#include <dev/pci/ixgbe.h>

#ifdef __sparc64__
#include <dev/ofw/openfirm.h>
#endif

void ixgbe_set_pci_config_data_generic(struct ixgbe_hw *hw,
				       uint16_t link_status);

int32_t ixgbe_acquire_eeprom(struct ixgbe_hw *hw);
int32_t ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw);
void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw);
int32_t ixgbe_ready_eeprom(struct ixgbe_hw *hw);
void ixgbe_standby_eeprom(struct ixgbe_hw *hw);
void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, uint16_t data,
				 uint16_t count);
uint16_t ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, uint16_t count);
void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw, uint32_t *eec);
void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw, uint32_t *eec);
void ixgbe_release_eeprom(struct ixgbe_hw *hw);

int32_t ixgbe_mta_vector(struct ixgbe_hw *hw, uint8_t *mc_addr);
int32_t ixgbe_fc_autoneg_fiber(struct ixgbe_hw *hw);
int32_t ixgbe_fc_autoneg_backplane(struct ixgbe_hw *hw);
int32_t ixgbe_fc_autoneg_copper(struct ixgbe_hw *hw);
bool ixgbe_device_supports_autoneg_fc(struct ixgbe_hw *hw);
int32_t ixgbe_negotiate_fc(struct ixgbe_hw *hw, uint32_t adv_reg,
			   uint32_t lp_reg, uint32_t adv_sym, uint32_t adv_asm,
			   uint32_t lp_sym, uint32_t lp_asm);

int32_t prot_autoc_read_generic(struct ixgbe_hw *, bool *, uint32_t *);
int32_t prot_autoc_write_generic(struct ixgbe_hw *, uint32_t, bool);

int32_t ixgbe_find_vlvf_slot(struct ixgbe_hw *hw, uint32_t vlan);

/* MBX */
int32_t ixgbe_poll_for_msg(struct ixgbe_hw *hw, uint16_t mbx_id);
int32_t ixgbe_poll_for_ack(struct ixgbe_hw *hw, uint16_t mbx_id);
uint32_t ixgbe_read_v2p_mailbox(struct ixgbe_hw *hw);
int32_t ixgbe_check_for_bit_pf(struct ixgbe_hw *hw, uint32_t mask,
			       int32_t index);
int32_t ixgbe_check_for_msg_pf(struct ixgbe_hw *hw, uint16_t vf_number);
int32_t ixgbe_check_for_ack_pf(struct ixgbe_hw *hw, uint16_t vf_number);
int32_t ixgbe_check_for_rst_pf(struct ixgbe_hw *hw, uint16_t vf_number);
int32_t ixgbe_obtain_mbx_lock_pf(struct ixgbe_hw *hw, uint16_t vf_number);
int32_t ixgbe_write_mbx_pf(struct ixgbe_hw *hw, uint32_t *msg, uint16_t size,
			   uint16_t vf_number);
int32_t ixgbe_read_mbx_pf(struct ixgbe_hw *hw, uint32_t *msg, uint16_t size,
			  uint16_t vf_number);


/**
 *  ixgbe_init_ops_generic - Inits function ptrs
 *  @@hw: pointer to the hardware structure
 *
 *  Initialize the function pointers.
 **/
int32_t ixgbe_init_ops_generic(struct ixgbe_hw *hw)
{
	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
	struct ixgbe_mac_info *mac = &hw->mac;
	uint32_t eec = IXGBE_READ_REG(hw, IXGBE_EEC);

	DEBUGFUNC("ixgbe_init_ops_generic");

	/* EEPROM */
	eeprom->ops.init_params = ixgbe_init_eeprom_params_generic;
	/* If EEPROM is valid (bit 8 = 1), use EERD otherwise use bit bang */
	if (eec & IXGBE_EEC_PRES)
		eeprom->ops.read = ixgbe_read_eerd_generic;
	else
		eeprom->ops.read = ixgbe_read_eeprom_bit_bang_generic;
	eeprom->ops.write = ixgbe_write_eeprom_generic;
	eeprom->ops.validate_checksum =
				      ixgbe_validate_eeprom_checksum_generic;
	eeprom->ops.update_checksum = ixgbe_update_eeprom_checksum_generic;
	eeprom->ops.calc_checksum = ixgbe_calc_eeprom_checksum_generic;

	/* MAC */
	mac->ops.init_hw = ixgbe_init_hw_generic;
	mac->ops.reset_hw = NULL;
	mac->ops.start_hw = ixgbe_start_hw_generic;
	mac->ops.clear_hw_cntrs = ixgbe_clear_hw_cntrs_generic;
	mac->ops.get_media_type = NULL;
	mac->ops.get_supported_physical_layer = NULL;
	mac->ops.enable_rx_dma = ixgbe_enable_rx_dma_generic;
	mac->ops.get_mac_addr = ixgbe_get_mac_addr_generic;
	mac->ops.stop_adapter = ixgbe_stop_adapter_generic;
	mac->ops.get_bus_info = ixgbe_get_bus_info_generic;
	mac->ops.set_lan_id = ixgbe_set_lan_id_multi_port_pcie;
	mac->ops.acquire_swfw_sync = ixgbe_acquire_swfw_sync;
	mac->ops.release_swfw_sync = ixgbe_release_swfw_sync;
	mac->ops.prot_autoc_read = prot_autoc_read_generic;
	mac->ops.prot_autoc_write = prot_autoc_write_generic;

	/* LEDs */
	mac->ops.led_on = ixgbe_led_on_generic;
	mac->ops.led_off = ixgbe_led_off_generic;
	mac->ops.blink_led_start = ixgbe_blink_led_start_generic;
	mac->ops.blink_led_stop = ixgbe_blink_led_stop_generic;

	/* RAR, Multicast, VLAN */
	mac->ops.set_rar = ixgbe_set_rar_generic;
	mac->ops.clear_rar = ixgbe_clear_rar_generic;
	mac->ops.insert_mac_addr = NULL;
	mac->ops.set_vmdq = NULL;
	mac->ops.clear_vmdq = NULL;
	mac->ops.init_rx_addrs = ixgbe_init_rx_addrs_generic;
	mac->ops.update_mc_addr_list = ixgbe_update_mc_addr_list_generic;
	mac->ops.enable_mc = ixgbe_enable_mc_generic;
	mac->ops.disable_mc = ixgbe_disable_mc_generic;
	mac->ops.clear_vfta = NULL;
	mac->ops.set_vfta = NULL;
	mac->ops.init_uta_tables = NULL;
	mac->ops.enable_rx = ixgbe_enable_rx_generic;
	mac->ops.disable_rx = ixgbe_disable_rx_generic;

	/* Flow Control */
	mac->ops.fc_enable = ixgbe_fc_enable_generic;
	mac->ops.setup_fc = ixgbe_setup_fc_generic;

	/* Link */
	mac->ops.get_link_capabilities = NULL;
	mac->ops.setup_link = NULL;
	mac->ops.check_link = NULL;

	return IXGBE_SUCCESS;
}

/**
 * ixgbe_device_supports_autoneg_fc - Check if device supports autonegotiation
 * of flow control
 * @@hw: pointer to hardware structure
 *
 * This function returns TRUE if the device supports flow control
 * autonegotiation, and FALSE if it does not.
 *
 **/
bool ixgbe_device_supports_autoneg_fc(struct ixgbe_hw *hw)
{
	bool supported = FALSE;
	ixgbe_link_speed speed;
	bool link_up;

	DEBUGFUNC("ixgbe_device_supports_autoneg_fc");

	switch (hw->phy.media_type) {
	case ixgbe_media_type_fiber_fixed:
	case ixgbe_media_type_fiber_qsfp:
	case ixgbe_media_type_fiber:
		hw->mac.ops.check_link(hw, &speed, &link_up, FALSE);
		/* if link is down, assume supported */
		if (link_up)
			supported = speed == IXGBE_LINK_SPEED_1GB_FULL ?
				TRUE : FALSE;
		else
			supported = TRUE;
		break;
	case ixgbe_media_type_backplane:
		supported = TRUE;
		break;
	case ixgbe_media_type_copper:
		/* only some copper devices support flow control autoneg */
		switch (hw->device_id) {
		case IXGBE_DEV_ID_82599_T3_LOM:
		case IXGBE_DEV_ID_X540T:
		case IXGBE_DEV_ID_X540T1:
		case IXGBE_DEV_ID_X540_BYPASS:
		case IXGBE_DEV_ID_X550T:
		case IXGBE_DEV_ID_X550T1:
		case IXGBE_DEV_ID_X550EM_X_10G_T:
			supported = TRUE;
			break;
		default:
			supported = FALSE;
		}
	default:
		break;
	}

	if (!supported) {
		ERROR_REPORT2(IXGBE_ERROR_UNSUPPORTED,
		      "Device %x does not support flow control autoneg",
		      hw->device_id);
	}

	return supported;
}

/**
 *  ixgbe_setup_fc_generic - Set up flow control
 *  @@hw: pointer to hardware structure
 *
 *  Called at init time to set up flow control.
 **/
int32_t ixgbe_setup_fc_generic(struct ixgbe_hw *hw)
{
	int32_t ret_val = IXGBE_SUCCESS;
	uint32_t reg = 0, reg_bp = 0;
	uint16_t reg_cu = 0;
	bool locked = FALSE;

	DEBUGFUNC("ixgbe_setup_fc");

	/* Validate the requested mode */
	if (hw->fc.strict_ieee && hw->fc.requested_mode == ixgbe_fc_rx_pause) {
		ERROR_REPORT1(IXGBE_ERROR_UNSUPPORTED,
			   "ixgbe_fc_rx_pause not valid in strict IEEE mode\n");
		ret_val = IXGBE_ERR_INVALID_LINK_SETTINGS;
		goto out;
	}

	/*
	 * 10gig parts do not have a word in the EEPROM to determine the
	 * default flow control setting, so we explicitly set it to full.
	 */
	if (hw->fc.requested_mode == ixgbe_fc_default)
		hw->fc.requested_mode = ixgbe_fc_full;

	/*
	 * Set up the 1G and 10G flow control advertisement registers so the
	 * HW will be able to do fc autoneg once the cable is plugged in.  If
	 * we link at 10G, the 1G advertisement is harmless and vice versa.
	 */
	switch (hw->phy.media_type) {
	case ixgbe_media_type_backplane:
		/* some MAC's need RMW protection on AUTOC */
		ret_val = hw->mac.ops.prot_autoc_read(hw, &locked, &reg_bp);
		if (ret_val != IXGBE_SUCCESS)
			goto out;

		/* only backplane uses autoc so fall though */
	case ixgbe_media_type_fiber_fixed:
	case ixgbe_media_type_fiber_qsfp:
	case ixgbe_media_type_fiber:
		reg = IXGBE_READ_REG(hw, IXGBE_PCS1GANA);

		break;
	case ixgbe_media_type_copper:
		hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_ADVT,
				     IXGBE_MDIO_AUTO_NEG_DEV_TYPE, &reg_cu);
		break;
	default:
		break;
	}

	/*
	 * The possible values of fc.requested_mode are:
	 * 0: Flow control is completely disabled
	 * 1: Rx flow control is enabled (we can receive pause frames,
	 *    but not send pause frames).
	 * 2: Tx flow control is enabled (we can send pause frames but
	 *    we do not support receiving pause frames).
	 * 3: Both Rx and Tx flow control (symmetric) are enabled.
	 * other: Invalid.
	 */
	switch (hw->fc.requested_mode) {
	case ixgbe_fc_none:
		/* Flow control completely disabled by software override. */
		reg &= ~(IXGBE_PCS1GANA_SYM_PAUSE | IXGBE_PCS1GANA_ASM_PAUSE);
		if (hw->phy.media_type == ixgbe_media_type_backplane)
			reg_bp &= ~(IXGBE_AUTOC_SYM_PAUSE |
				    IXGBE_AUTOC_ASM_PAUSE);
		else if (hw->phy.media_type == ixgbe_media_type_copper)
			reg_cu &= ~(IXGBE_TAF_SYM_PAUSE | IXGBE_TAF_ASM_PAUSE);
		break;
	case ixgbe_fc_tx_pause:
		/*
		 * Tx Flow control is enabled, and Rx Flow control is
		 * disabled by software override.
		 */
		reg |= IXGBE_PCS1GANA_ASM_PAUSE;
		reg &= ~IXGBE_PCS1GANA_SYM_PAUSE;
		if (hw->phy.media_type == ixgbe_media_type_backplane) {
			reg_bp |= IXGBE_AUTOC_ASM_PAUSE;
			reg_bp &= ~IXGBE_AUTOC_SYM_PAUSE;
		} else if (hw->phy.media_type == ixgbe_media_type_copper) {
			reg_cu |= IXGBE_TAF_ASM_PAUSE;
			reg_cu &= ~IXGBE_TAF_SYM_PAUSE;
		}
		break;
	case ixgbe_fc_rx_pause:
		/*
		 * Rx Flow control is enabled and Tx Flow control is
		 * disabled by software override. Since there really
		 * isn't a way to advertise that we are capable of RX
		 * Pause ONLY, we will advertise that we support both
		 * symmetric and asymmetric Rx PAUSE, as such we fall
		 * through to the fc_full statement.  Later, we will
		 * disable the adapter's ability to send PAUSE frames.
		 */
	case ixgbe_fc_full:
		/* Flow control (both Rx and Tx) is enabled by SW override. */
		reg |= IXGBE_PCS1GANA_SYM_PAUSE | IXGBE_PCS1GANA_ASM_PAUSE;
		if (hw->phy.media_type == ixgbe_media_type_backplane)
			reg_bp |= IXGBE_AUTOC_SYM_PAUSE |
				  IXGBE_AUTOC_ASM_PAUSE;
		else if (hw->phy.media_type == ixgbe_media_type_copper)
			reg_cu |= IXGBE_TAF_SYM_PAUSE | IXGBE_TAF_ASM_PAUSE;
		break;
	default:
		ERROR_REPORT1(IXGBE_ERROR_ARGUMENT,
			     "Flow control param set incorrectly\n");
		ret_val = IXGBE_ERR_CONFIG;
		goto out;
		break;
	}

	if (hw->mac.type < ixgbe_mac_X540) {
		/*
		 * Enable auto-negotiation between the MAC & PHY;
		 * the MAC will advertise clause 37 flow control.
		 */
		IXGBE_WRITE_REG(hw, IXGBE_PCS1GANA, reg);
		reg = IXGBE_READ_REG(hw, IXGBE_PCS1GLCTL);

		/* Disable AN timeout */
		if (hw->fc.strict_ieee)
			reg &= ~IXGBE_PCS1GLCTL_AN_1G_TIMEOUT_EN;

		IXGBE_WRITE_REG(hw, IXGBE_PCS1GLCTL, reg);
		DEBUGOUT1("Set up FC; PCS1GLCTL = 0x%08X\n", reg);
	}

	/*
	 * AUTOC restart handles negotiation of 1G and 10G on backplane
	 * and copper. There is no need to set the PCS1GCTL register.
	 *
	 */
	if (hw->phy.media_type == ixgbe_media_type_backplane) {
		reg_bp |= IXGBE_AUTOC_AN_RESTART;
		ret_val = hw->mac.ops.prot_autoc_write(hw, reg_bp, locked);
		if (ret_val)
			goto out;
	} else if ((hw->phy.media_type == ixgbe_media_type_copper) &&
		    (ixgbe_device_supports_autoneg_fc(hw))) {
		hw->phy.ops.write_reg(hw, IXGBE_MDIO_AUTO_NEG_ADVT,
				      IXGBE_MDIO_AUTO_NEG_DEV_TYPE, reg_cu);
	}

	DEBUGOUT1("Set up FC; PCS1GLCTL = 0x%08X\n", reg);
out:
	return ret_val;
}

/**
 *  ixgbe_start_hw_generic - Prepare hardware for Tx/Rx
 *  @@hw: pointer to hardware structure
 *
 *  Starts the hardware by filling the bus info structure and media type, clears
 *  all on chip counters, initializes receive address registers, multicast
 *  table, VLAN filter table, calls routine to set up link and flow control
 *  settings, and leaves transmit and receive units disabled and uninitialized
 **/
int32_t ixgbe_start_hw_generic(struct ixgbe_hw *hw)
{
	int32_t ret_val = IXGBE_SUCCESS;
	uint32_t ctrl_ext;

	DEBUGFUNC("ixgbe_start_hw_generic");

	/* Set the media type */
	hw->phy.media_type = hw->mac.ops.get_media_type(hw);

	/* PHY ops initialization must be done in reset_hw() */

	/* Clear the VLAN filter table */
	hw->mac.ops.clear_vfta(hw);

	/* Clear statistics registers */
	hw->mac.ops.clear_hw_cntrs(hw);

	/* Set No Snoop Disable */
	ctrl_ext = IXGBE_READ_REG(hw, IXGBE_CTRL_EXT);
	ctrl_ext |= IXGBE_CTRL_EXT_NS_DIS;
	IXGBE_WRITE_REG(hw, IXGBE_CTRL_EXT, ctrl_ext);
	IXGBE_WRITE_FLUSH(hw);

	/* Setup flow control */
	if (hw->mac.ops.setup_fc) {
		ret_val = hw->mac.ops.setup_fc(hw);
		if (ret_val != IXGBE_SUCCESS)
			goto out;
	}

	/* Clear adapter stopped flag */
	hw->adapter_stopped = FALSE;

out:
	return ret_val;
}

/**
 *  ixgbe_start_hw_gen2 - Init sequence for common device family
 *  @@hw: pointer to hw structure
 *
 * Performs the init sequence common to the second generation
 * of 10 GbE devices.
 * Devices in the second generation:
 *     82599
 *     X540
 **/
int32_t ixgbe_start_hw_gen2(struct ixgbe_hw *hw)
{
	uint32_t i;
	uint32_t regval;

	/* Clear the rate limiters */
	for (i = 0; i < hw->mac.max_tx_queues; i++) {
		IXGBE_WRITE_REG(hw, IXGBE_RTTDQSEL, i);
		IXGBE_WRITE_REG(hw, IXGBE_RTTBCNRC, 0);
	}
	IXGBE_WRITE_FLUSH(hw);

	/* Disable relaxed ordering */
	for (i = 0; i < hw->mac.max_tx_queues; i++) {
		regval = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL_82599(i));
		regval &= ~IXGBE_DCA_TXCTRL_DESC_WRO_EN;
		IXGBE_WRITE_REG(hw, IXGBE_DCA_TXCTRL_82599(i), regval);
	}

	for (i = 0; i < hw->mac.max_rx_queues; i++) {
		regval = IXGBE_READ_REG(hw, IXGBE_DCA_RXCTRL(i));
		regval &= ~(IXGBE_DCA_RXCTRL_DATA_WRO_EN |
			    IXGBE_DCA_RXCTRL_HEAD_WRO_EN);
		IXGBE_WRITE_REG(hw, IXGBE_DCA_RXCTRL(i), regval);
	}

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_init_hw_generic - Generic hardware initialization
 *  @@hw: pointer to hardware structure
 *
 *  Initialize the hardware by resetting the hardware, filling the bus info
 *  structure and media type, clears all on chip counters, initializes receive
 *  address registers, multicast table, VLAN filter table, calls routine to set
 *  up link and flow control settings, and leaves transmit and receive units
 *  disabled and uninitialized
 **/
int32_t ixgbe_init_hw_generic(struct ixgbe_hw *hw)
{
	int32_t status;

	DEBUGFUNC("ixgbe_init_hw_generic");

	/* Reset the hardware */
	status = hw->mac.ops.reset_hw(hw);

	if (status == IXGBE_SUCCESS) {
		/* Start the HW */
		status = hw->mac.ops.start_hw(hw);
	}

	return status;
}

/**
 *  ixgbe_clear_hw_cntrs_generic - Generic clear hardware counters
 *  @@hw: pointer to hardware structure
 *
 *  Clears all hardware statistics counters by reading them from the hardware
 *  Statistics counters are clear on read.
 **/
int32_t ixgbe_clear_hw_cntrs_generic(struct ixgbe_hw *hw)
{
	uint16_t i = 0;

	DEBUGFUNC("ixgbe_clear_hw_cntrs_generic");

	IXGBE_READ_REG(hw, IXGBE_CRCERRS);
	IXGBE_READ_REG(hw, IXGBE_ILLERRC);
	IXGBE_READ_REG(hw, IXGBE_ERRBC);
	IXGBE_READ_REG(hw, IXGBE_MSPDC);
	for (i = 0; i < 8; i++)
		IXGBE_READ_REG(hw, IXGBE_MPC(i));

	IXGBE_READ_REG(hw, IXGBE_MLFC);
	IXGBE_READ_REG(hw, IXGBE_MRFC);
	IXGBE_READ_REG(hw, IXGBE_RLEC);
	IXGBE_READ_REG(hw, IXGBE_LXONTXC);
	IXGBE_READ_REG(hw, IXGBE_LXOFFTXC);
	if (hw->mac.type >= ixgbe_mac_82599EB) {
		IXGBE_READ_REG(hw, IXGBE_LXONRXCNT);
		IXGBE_READ_REG(hw, IXGBE_LXOFFRXCNT);
	} else {
		IXGBE_READ_REG(hw, IXGBE_LXONRXC);
		IXGBE_READ_REG(hw, IXGBE_LXOFFRXC);
	}

	for (i = 0; i < 8; i++) {
		IXGBE_READ_REG(hw, IXGBE_PXONTXC(i));
		IXGBE_READ_REG(hw, IXGBE_PXOFFTXC(i));
		if (hw->mac.type >= ixgbe_mac_82599EB) {
			IXGBE_READ_REG(hw, IXGBE_PXONRXCNT(i));
			IXGBE_READ_REG(hw, IXGBE_PXOFFRXCNT(i));
		} else {
			IXGBE_READ_REG(hw, IXGBE_PXONRXC(i));
			IXGBE_READ_REG(hw, IXGBE_PXOFFRXC(i));
		}
	}
	if (hw->mac.type >= ixgbe_mac_82599EB)
		for (i = 0; i < 8; i++)
			IXGBE_READ_REG(hw, IXGBE_PXON2OFFCNT(i));
	IXGBE_READ_REG(hw, IXGBE_PRC64);
	IXGBE_READ_REG(hw, IXGBE_PRC127);
	IXGBE_READ_REG(hw, IXGBE_PRC255);
	IXGBE_READ_REG(hw, IXGBE_PRC511);
	IXGBE_READ_REG(hw, IXGBE_PRC1023);
	IXGBE_READ_REG(hw, IXGBE_PRC1522);
	IXGBE_READ_REG(hw, IXGBE_GPRC);
	IXGBE_READ_REG(hw, IXGBE_BPRC);
	IXGBE_READ_REG(hw, IXGBE_MPRC);
	IXGBE_READ_REG(hw, IXGBE_GPTC);
	IXGBE_READ_REG(hw, IXGBE_GORCL);
	IXGBE_READ_REG(hw, IXGBE_GORCH);
	IXGBE_READ_REG(hw, IXGBE_GOTCL);
	IXGBE_READ_REG(hw, IXGBE_GOTCH);
	if (hw->mac.type == ixgbe_mac_82598EB)
		for (i = 0; i < 8; i++)
			IXGBE_READ_REG(hw, IXGBE_RNBC(i));
	IXGBE_READ_REG(hw, IXGBE_RUC);
	IXGBE_READ_REG(hw, IXGBE_RFC);
	IXGBE_READ_REG(hw, IXGBE_ROC);
	IXGBE_READ_REG(hw, IXGBE_RJC);
	IXGBE_READ_REG(hw, IXGBE_MNGPRC);
	IXGBE_READ_REG(hw, IXGBE_MNGPDC);
	IXGBE_READ_REG(hw, IXGBE_MNGPTC);
	IXGBE_READ_REG(hw, IXGBE_TORL);
	IXGBE_READ_REG(hw, IXGBE_TORH);
	IXGBE_READ_REG(hw, IXGBE_TPR);
	IXGBE_READ_REG(hw, IXGBE_TPT);
	IXGBE_READ_REG(hw, IXGBE_PTC64);
	IXGBE_READ_REG(hw, IXGBE_PTC127);
	IXGBE_READ_REG(hw, IXGBE_PTC255);
	IXGBE_READ_REG(hw, IXGBE_PTC511);
	IXGBE_READ_REG(hw, IXGBE_PTC1023);
	IXGBE_READ_REG(hw, IXGBE_PTC1522);
	IXGBE_READ_REG(hw, IXGBE_MPTC);
	IXGBE_READ_REG(hw, IXGBE_BPTC);
	for (i = 0; i < 16; i++) {
		IXGBE_READ_REG(hw, IXGBE_QPRC(i));
		IXGBE_READ_REG(hw, IXGBE_QPTC(i));
		if (hw->mac.type >= ixgbe_mac_82599EB) {
			IXGBE_READ_REG(hw, IXGBE_QBRC_L(i));
			IXGBE_READ_REG(hw, IXGBE_QBRC_H(i));
			IXGBE_READ_REG(hw, IXGBE_QBTC_L(i));
			IXGBE_READ_REG(hw, IXGBE_QBTC_H(i));
			IXGBE_READ_REG(hw, IXGBE_QPRDC(i));
		} else {
			IXGBE_READ_REG(hw, IXGBE_QBRC(i));
			IXGBE_READ_REG(hw, IXGBE_QBTC(i));
		}
	}

	if (hw->mac.type == ixgbe_mac_X550 || hw->mac.type == ixgbe_mac_X540) {
		if (hw->phy.id == 0)
			ixgbe_identify_phy(hw);
		hw->phy.ops.read_reg(hw, IXGBE_PCRC8ECL,
				     IXGBE_MDIO_PCS_DEV_TYPE, &i);
		hw->phy.ops.read_reg(hw, IXGBE_PCRC8ECH,
				     IXGBE_MDIO_PCS_DEV_TYPE, &i);
		hw->phy.ops.read_reg(hw, IXGBE_LDPCECL,
				     IXGBE_MDIO_PCS_DEV_TYPE, &i);
		hw->phy.ops.read_reg(hw, IXGBE_LDPCECH,
				     IXGBE_MDIO_PCS_DEV_TYPE, &i);
	}

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_get_mac_addr_generic - Generic get MAC address
 *  @@hw: pointer to hardware structure
 *  @@mac_addr: Adapter MAC address
 *
 *  Reads the adapter's MAC address from first Receive Address Register (RAR0)
 *  A reset of the adapter must be performed prior to calling this function
 *  in order for the MAC address to have been loaded from the EEPROM into RAR0
 **/
int32_t ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw, uint8_t *mac_addr)
{
	uint32_t rar_high;
	uint32_t rar_low;
	uint16_t i;

	DEBUGFUNC("ixgbe_get_mac_addr_generic");

#ifdef __sparc64__
	struct ixgbe_osdep *os = hw->back;
 
	if (OF_getprop(PCITAG_NODE(os->os_pa.pa_tag), "local-mac-address",
	    mac_addr, ETHER_ADDR_LEN) == ETHER_ADDR_LEN)
		return IXGBE_SUCCESS;
#endif

	rar_high = IXGBE_READ_REG(hw, IXGBE_RAH(0));
	rar_low = IXGBE_READ_REG(hw, IXGBE_RAL(0));

	for (i = 0; i < 4; i++)
		mac_addr[i] = (uint8_t)(rar_low >> (i*8));

	for (i = 0; i < 2; i++)
		mac_addr[i+4] = (uint8_t)(rar_high >> (i*8));

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_set_pci_config_data_generic - Generic store PCI bus info
 *  @@hw: pointer to hardware structure
 *  @@link_status: the link status returned by the PCI config space
 *
 *  Stores the PCI bus info (speed, width, type) within the ixgbe_hw structure
 **/
void ixgbe_set_pci_config_data_generic(struct ixgbe_hw *hw,
				       uint16_t link_status)
{
	struct ixgbe_mac_info *mac = &hw->mac;

	hw->bus.type = ixgbe_bus_type_pci_express;

	switch (link_status & IXGBE_PCI_LINK_WIDTH) {
	case IXGBE_PCI_LINK_WIDTH_1:
		hw->bus.width = ixgbe_bus_width_pcie_x1;
		break;
	case IXGBE_PCI_LINK_WIDTH_2:
		hw->bus.width = ixgbe_bus_width_pcie_x2;
		break;
	case IXGBE_PCI_LINK_WIDTH_4:
		hw->bus.width = ixgbe_bus_width_pcie_x4;
		break;
	case IXGBE_PCI_LINK_WIDTH_8:
		hw->bus.width = ixgbe_bus_width_pcie_x8;
		break;
	default:
		hw->bus.width = ixgbe_bus_width_unknown;
		break;
	}

	switch (link_status & IXGBE_PCI_LINK_SPEED) {
	case IXGBE_PCI_LINK_SPEED_2500:
		hw->bus.speed = ixgbe_bus_speed_2500;
		break;
	case IXGBE_PCI_LINK_SPEED_5000:
		hw->bus.speed = ixgbe_bus_speed_5000;
		break;
	case IXGBE_PCI_LINK_SPEED_8000:
		hw->bus.speed = ixgbe_bus_speed_8000;
		break;
	default:
		hw->bus.speed = ixgbe_bus_speed_unknown;
		break;
	}

	mac->ops.set_lan_id(hw);
}

/**
 *  ixgbe_get_bus_info_generic - Generic set PCI bus info
 *  @@hw: pointer to hardware structure
 *
 *  Gets the PCI bus info (speed, width, type) then calls helper function to
 *  store this data within the ixgbe_hw structure.
 **/
int32_t ixgbe_get_bus_info_generic(struct ixgbe_hw *hw)
{
	uint16_t link_status;

	DEBUGFUNC("ixgbe_get_bus_info_generic");

	/* Get the negotiated link width and speed from PCI config space */
	link_status = IXGBE_READ_PCIE_WORD(hw, IXGBE_PCI_LINK_STATUS);

	ixgbe_set_pci_config_data_generic(hw, link_status);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_set_lan_id_multi_port_pcie - Set LAN id for PCIe multiple port devices
 *  @@hw: pointer to the HW structure
 *
 *  Determines the LAN function id by reading memory-mapped registers
 *  and swaps the port value if requested.
 **/
void ixgbe_set_lan_id_multi_port_pcie(struct ixgbe_hw *hw)
{
	struct ixgbe_bus_info *bus = &hw->bus;
	uint32_t reg;

	DEBUGFUNC("ixgbe_set_lan_id_multi_port_pcie");

	reg = IXGBE_READ_REG(hw, IXGBE_STATUS);
	bus->func = (reg & IXGBE_STATUS_LAN_ID) >> IXGBE_STATUS_LAN_ID_SHIFT;
	bus->lan_id = bus->func;

	/* check for a port swap */
	reg = IXGBE_READ_REG(hw, IXGBE_FACTPS);
	if (reg & IXGBE_FACTPS_LFS)
		bus->func ^= 0x1;
}

/**
 *  ixgbe_stop_adapter_generic - Generic stop Tx/Rx units
 *  @@hw: pointer to hardware structure
 *
 *  Sets the adapter_stopped flag within ixgbe_hw struct. Clears interrupts,
 *  disables transmit and receive units. The adapter_stopped flag is used by
 *  the shared code and drivers to determine if the adapter is in a stopped
 *  state and should not touch the hardware.
 **/
int32_t ixgbe_stop_adapter_generic(struct ixgbe_hw *hw)
{
	uint32_t reg_val;
	uint16_t i;

	DEBUGFUNC("ixgbe_stop_adapter_generic");

	/*
	 * Set the adapter_stopped flag so other driver functions stop touching
	 * the hardware
	 */
	hw->adapter_stopped = TRUE;

	/* Disable the receive unit */
	ixgbe_disable_rx(hw);

	/* Clear interrupt mask to stop interrupts from being generated */
	IXGBE_WRITE_REG(hw, IXGBE_EIMC, IXGBE_IRQ_CLEAR_MASK);

	/* Clear any pending interrupts, flush previous writes */
	IXGBE_READ_REG(hw, IXGBE_EICR);

	/* Disable the transmit unit.  Each queue must be disabled. */
	for (i = 0; i < hw->mac.max_tx_queues; i++)
		IXGBE_WRITE_REG(hw, IXGBE_TXDCTL(i), IXGBE_TXDCTL_SWFLSH);

	/* Disable the receive unit by stopping each queue */
	for (i = 0; i < hw->mac.max_rx_queues; i++) {
		reg_val = IXGBE_READ_REG(hw, IXGBE_RXDCTL(i));
		reg_val &= ~IXGBE_RXDCTL_ENABLE;
		reg_val |= IXGBE_RXDCTL_SWFLSH;
		IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(i), reg_val);
	}

	/* flush all queues disables */
	IXGBE_WRITE_FLUSH(hw);
	msec_delay(2);

	/*
	 * Prevent the PCI-E bus from hanging by disabling PCI-E master
	 * access and verify no pending requests
	 */
	return ixgbe_disable_pcie_master(hw);
}

/**
 *  ixgbe_led_on_generic - Turns on the software controllable LEDs.
 *  @@hw: pointer to hardware structure
 *  @@index: led number to turn on
 **/
int32_t ixgbe_led_on_generic(struct ixgbe_hw *hw, uint32_t index)
{
	uint32_t led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);

	DEBUGFUNC("ixgbe_led_on_generic");

	/* To turn on the LED, set mode to ON. */
	led_reg &= ~IXGBE_LED_MODE_MASK(index);
	led_reg |= IXGBE_LED_ON << IXGBE_LED_MODE_SHIFT(index);
	IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
	IXGBE_WRITE_FLUSH(hw);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_led_off_generic - Turns off the software controllable LEDs.
 *  @@hw: pointer to hardware structure
 *  @@index: led number to turn off
 **/
int32_t ixgbe_led_off_generic(struct ixgbe_hw *hw, uint32_t index)
{
	uint32_t led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);

	DEBUGFUNC("ixgbe_led_off_generic");

	/* To turn off the LED, set mode to OFF. */
	led_reg &= ~IXGBE_LED_MODE_MASK(index);
	led_reg |= IXGBE_LED_OFF << IXGBE_LED_MODE_SHIFT(index);
	IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
	IXGBE_WRITE_FLUSH(hw);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_init_eeprom_params_generic - Initialize EEPROM params
 *  @@hw: pointer to hardware structure
 *
 *  Initializes the EEPROM parameters ixgbe_eeprom_info within the
 *  ixgbe_hw struct in order to set up EEPROM access.
 **/
int32_t ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw)
{
	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
	uint32_t eec;
	uint16_t eeprom_size;

	DEBUGFUNC("ixgbe_init_eeprom_params_generic");

	if (eeprom->type == ixgbe_eeprom_uninitialized) {
		eeprom->type = ixgbe_eeprom_none;
		/* Set default semaphore delay to 10ms which is a well
		 * tested value */
		eeprom->semaphore_delay = 10;
		/* Clear EEPROM page size, it will be initialized as needed */
		eeprom->word_page_size = 0;

		/*
		 * Check for EEPROM present first.
		 * If not present leave as none
		 */
		eec = IXGBE_READ_REG(hw, IXGBE_EEC);
		if (eec & IXGBE_EEC_PRES) {
			eeprom->type = ixgbe_eeprom_spi;

			/*
			 * SPI EEPROM is assumed here.  This code would need to
			 * change if a future EEPROM is not SPI.
			 */
			eeprom_size = (uint16_t)((eec & IXGBE_EEC_SIZE) >>
					    IXGBE_EEC_SIZE_SHIFT);
			eeprom->word_size = 1 << (eeprom_size +
					     IXGBE_EEPROM_WORD_SIZE_SHIFT);
		}

		if (eec & IXGBE_EEC_ADDR_SIZE)
			eeprom->address_bits = 16;
		else
			eeprom->address_bits = 8;
		DEBUGOUT3("Eeprom params: type = %d, size = %d, address bits: "
			  "%d\n", eeprom->type, eeprom->word_size,
			  eeprom->address_bits);
	}

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_write_eeprom_buffer_bit_bang - Writes 16 bit word(s) to EEPROM
 *  @@hw: pointer to hardware structure
 *  @@offset: offset within the EEPROM to be written to
 *  @@words: number of word(s)
 *  @@data: 16 bit word(s) to be written to the EEPROM
 *
 *  If ixgbe_eeprom_update_checksum is not called after this function, the
 *  EEPROM will most likely contain an invalid checksum.
 **/
static int32_t ixgbe_write_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, uint16_t offset,
					      uint16_t words, uint16_t *data)
{
	int32_t status;
	uint16_t word;
	uint16_t page_size;
	uint16_t i;
	uint8_t write_opcode = IXGBE_EEPROM_WRITE_OPCODE_SPI;

	DEBUGFUNC("ixgbe_write_eeprom_buffer_bit_bang");

	/* Prepare the EEPROM for writing  */
	status = ixgbe_acquire_eeprom(hw);

	if (status == IXGBE_SUCCESS) {
		if (ixgbe_ready_eeprom(hw) != IXGBE_SUCCESS) {
			ixgbe_release_eeprom(hw);
			status = IXGBE_ERR_EEPROM;
		}
	}

	if (status == IXGBE_SUCCESS) {
		for (i = 0; i < words; i++) {
			ixgbe_standby_eeprom(hw);

			/*  Send the WRITE ENABLE command (8 bit opcode )  */
			ixgbe_shift_out_eeprom_bits(hw,
						   IXGBE_EEPROM_WREN_OPCODE_SPI,
						   IXGBE_EEPROM_OPCODE_BITS);

			ixgbe_standby_eeprom(hw);

			/*
			 * Some SPI eeproms use the 8th address bit embedded
			 * in the opcode
			 */
			if ((hw->eeprom.address_bits == 8) &&
			    ((offset + i) >= 128))
				write_opcode |= IXGBE_EEPROM_A8_OPCODE_SPI;

			/* Send the Write command (8-bit opcode + addr) */
			ixgbe_shift_out_eeprom_bits(hw, write_opcode,
						    IXGBE_EEPROM_OPCODE_BITS);
			ixgbe_shift_out_eeprom_bits(hw, (uint16_t)((offset + i) * 2),
						    hw->eeprom.address_bits);

			page_size = hw->eeprom.word_page_size;

			/* Send the data in burst via SPI*/
			do {
				word = data[i];
				word = (word >> 8) | (word << 8);
				ixgbe_shift_out_eeprom_bits(hw, word, 16);

				if (page_size == 0)
					break;

				/* do not wrap around page */
				if (((offset + i) & (page_size - 1)) ==
				    (page_size - 1))
					break;
			} while (++i < words);

			ixgbe_standby_eeprom(hw);
			msec_delay(10);
		}
		/* Done with writing - release the EEPROM */
		ixgbe_release_eeprom(hw);
	}

	return status;
}

/**
 *  ixgbe_write_eeprom_generic - Writes 16 bit value to EEPROM
 *  @@hw: pointer to hardware structure
 *  @@offset: offset within the EEPROM to be written to
 *  @@data: 16 bit word to be written to the EEPROM
 *
 *  If ixgbe_eeprom_update_checksum is not called after this function, the
 *  EEPROM will most likely contain an invalid checksum.
 **/
int32_t ixgbe_write_eeprom_generic(struct ixgbe_hw *hw, uint16_t offset, uint16_t data)
{
	int32_t status;

	DEBUGFUNC("ixgbe_write_eeprom_generic");

	hw->eeprom.ops.init_params(hw);

	if (offset >= hw->eeprom.word_size) {
		status = IXGBE_ERR_EEPROM;
		goto out;
	}

	status = ixgbe_write_eeprom_buffer_bit_bang(hw, offset, 1, &data);

out:
	return status;
}

/**
 *  ixgbe_read_eeprom_buffer_bit_bang - Read EEPROM using bit-bang
 *  @@hw: pointer to hardware structure
 *  @@offset: offset within the EEPROM to be read
 *  @@words: number of word(s)
 *  @@data: read 16 bit word(s) from EEPROM
 *
 *  Reads 16 bit word(s) from EEPROM through bit-bang method
 **/
static int32_t ixgbe_read_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, uint16_t offset,
					     uint16_t words, uint16_t *data)
{
	int32_t status;
	uint16_t word_in;
	uint8_t read_opcode = IXGBE_EEPROM_READ_OPCODE_SPI;
	uint16_t i;

	DEBUGFUNC("ixgbe_read_eeprom_buffer_bit_bang");

	/* Prepare the EEPROM for reading  */
	status = ixgbe_acquire_eeprom(hw);

	if (status == IXGBE_SUCCESS) {
		if (ixgbe_ready_eeprom(hw) != IXGBE_SUCCESS) {
			ixgbe_release_eeprom(hw);
			status = IXGBE_ERR_EEPROM;
		}
	}

	if (status == IXGBE_SUCCESS) {
		for (i = 0; i < words; i++) {
			ixgbe_standby_eeprom(hw);
			/*
			 * Some SPI eeproms use the 8th address bit embedded
			 * in the opcode
			 */
			if ((hw->eeprom.address_bits == 8) &&
			    ((offset + i) >= 128))
				read_opcode |= IXGBE_EEPROM_A8_OPCODE_SPI;

			/* Send the READ command (opcode + addr) */
			ixgbe_shift_out_eeprom_bits(hw, read_opcode,
						    IXGBE_EEPROM_OPCODE_BITS);
			ixgbe_shift_out_eeprom_bits(hw, (uint16_t)((offset + i) * 2),
						    hw->eeprom.address_bits);

			/* Read the data. */
			word_in = ixgbe_shift_in_eeprom_bits(hw, 16);
			data[i] = (word_in >> 8) | (word_in << 8);
		}

		/* End this read operation */
		ixgbe_release_eeprom(hw);
	}

	return status;
}

/**
 *  ixgbe_read_eeprom_bit_bang_generic - Read EEPROM word using bit-bang
 *  @@hw: pointer to hardware structure
 *  @@offset: offset within the EEPROM to be read
 *  @@data: read 16 bit value from EEPROM
 *
 *  Reads 16 bit value from EEPROM through bit-bang method
 **/
int32_t ixgbe_read_eeprom_bit_bang_generic(struct ixgbe_hw *hw, uint16_t offset,
				       uint16_t *data)
{
	int32_t status;

	DEBUGFUNC("ixgbe_read_eeprom_bit_bang_generic");

	hw->eeprom.ops.init_params(hw);

	if (offset >= hw->eeprom.word_size) {
		status = IXGBE_ERR_EEPROM;
		goto out;
	}

	status = ixgbe_read_eeprom_buffer_bit_bang(hw, offset, 1, data);

out:
	return status;
}

/**
 *  ixgbe_read_eerd_buffer_generic - Read EEPROM word(s) using EERD
 *  @@hw: pointer to hardware structure
 *  @@offset: offset of word in the EEPROM to read
 *  @@words: number of word(s)
 *  @@data: 16 bit word(s) from the EEPROM
 *
 *  Reads a 16 bit word(s) from the EEPROM using the EERD register.
 **/
int32_t ixgbe_read_eerd_buffer_generic(struct ixgbe_hw *hw, uint16_t offset,
				   uint16_t words, uint16_t *data)
{
	uint32_t eerd;
	int32_t status = IXGBE_SUCCESS;
	uint32_t i;

	DEBUGFUNC("ixgbe_read_eerd_buffer_generic");

	hw->eeprom.ops.init_params(hw);

	if (words == 0) {
		status = IXGBE_ERR_INVALID_ARGUMENT;
		ERROR_REPORT1(IXGBE_ERROR_ARGUMENT, "Invalid EEPROM words");
		goto out;
	}

	if (offset >= hw->eeprom.word_size) {
		status = IXGBE_ERR_EEPROM;
		ERROR_REPORT1(IXGBE_ERROR_ARGUMENT, "Invalid EEPROM offset");
		goto out;
	}

	for (i = 0; i < words; i++) {
		eerd = ((offset + i) << IXGBE_EEPROM_RW_ADDR_SHIFT) |
		       IXGBE_EEPROM_RW_REG_START;

		IXGBE_WRITE_REG(hw, IXGBE_EERD, eerd);
		status = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_READ);

		if (status == IXGBE_SUCCESS) {
			data[i] = (IXGBE_READ_REG(hw, IXGBE_EERD) >>
				   IXGBE_EEPROM_RW_REG_DATA);
		} else {
			DEBUGOUT("Eeprom read timed out\n");
			goto out;
		}
	}
out:
	return status;
}

/**
 *  ixgbe_read_eerd_generic - Read EEPROM word using EERD
 *  @@hw: pointer to hardware structure
 *  @@offset: offset of  word in the EEPROM to read
 *  @@data: word read from the EEPROM
 *
 *  Reads a 16 bit word from the EEPROM using the EERD register.
 **/
int32_t ixgbe_read_eerd_generic(struct ixgbe_hw *hw, uint16_t offset, uint16_t *data)
{
	return ixgbe_read_eerd_buffer_generic(hw, offset, 1, data);
}

/**
 *  ixgbe_write_eewr_buffer_generic - Write EEPROM word(s) using EEWR
 *  @@hw: pointer to hardware structure
 *  @@offset: offset of  word in the EEPROM to write
 *  @@words: number of word(s)
 *  @@data: word(s) write to the EEPROM
 *
 *  Write a 16 bit word(s) to the EEPROM using the EEWR register.
 **/
int32_t ixgbe_write_eewr_buffer_generic(struct ixgbe_hw *hw, uint16_t offset,
				    uint16_t words, uint16_t *data)
{
	uint32_t eewr;
	int32_t status = IXGBE_SUCCESS;
	uint16_t i;

	DEBUGFUNC("ixgbe_write_eewr_generic");

	hw->eeprom.ops.init_params(hw);

	if (words == 0) {
		status = IXGBE_ERR_INVALID_ARGUMENT;
		ERROR_REPORT1(IXGBE_ERROR_ARGUMENT, "Invalid EEPROM words");
		goto out;
	}

	if (offset >= hw->eeprom.word_size) {
		status = IXGBE_ERR_EEPROM;
		ERROR_REPORT1(IXGBE_ERROR_ARGUMENT, "Invalid EEPROM offset");
		goto out;
	}

	for (i = 0; i < words; i++) {
		eewr = ((offset + i) << IXGBE_EEPROM_RW_ADDR_SHIFT) |
			(data[i] << IXGBE_EEPROM_RW_REG_DATA) |
			IXGBE_EEPROM_RW_REG_START;

		status = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_WRITE);
		if (status != IXGBE_SUCCESS) {
			DEBUGOUT("Eeprom write EEWR timed out\n");
			goto out;
		}

		IXGBE_WRITE_REG(hw, IXGBE_EEWR, eewr);

		status = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_WRITE);
		if (status != IXGBE_SUCCESS) {
			DEBUGOUT("Eeprom write EEWR timed out\n");
			goto out;
		}
	}

out:
	return status;
}

/**
 *  ixgbe_write_eewr_generic - Write EEPROM word using EEWR
 *  @@hw: pointer to hardware structure
 *  @@offset: offset of  word in the EEPROM to write
 *  @@data: word write to the EEPROM
 *
 *  Write a 16 bit word to the EEPROM using the EEWR register.
 **/
int32_t ixgbe_write_eewr_generic(struct ixgbe_hw *hw, uint16_t offset, uint16_t data)
{
	return ixgbe_write_eewr_buffer_generic(hw, offset, 1, &data);
}

/**
 *  ixgbe_poll_eerd_eewr_done - Poll EERD read or EEWR write status
 *  @@hw: pointer to hardware structure
 *  @@ee_reg: EEPROM flag for polling
 *
 *  Polls the status bit (bit 1) of the EERD or EEWR to determine when the
 *  read or write is done respectively.
 **/
int32_t ixgbe_poll_eerd_eewr_done(struct ixgbe_hw *hw, uint32_t ee_reg)
{
	uint32_t i;
	uint32_t reg;
	int32_t status = IXGBE_ERR_EEPROM;

	DEBUGFUNC("ixgbe_poll_eerd_eewr_done");

	for (i = 0; i < IXGBE_EERD_EEWR_ATTEMPTS; i++) {
		if (ee_reg == IXGBE_NVM_POLL_READ)
			reg = IXGBE_READ_REG(hw, IXGBE_EERD);
		else
			reg = IXGBE_READ_REG(hw, IXGBE_EEWR);

		if (reg & IXGBE_EEPROM_RW_REG_DONE) {
			status = IXGBE_SUCCESS;
			break;
		}
		usec_delay(5);
	}

	if (i == IXGBE_EERD_EEWR_ATTEMPTS)
		ERROR_REPORT1(IXGBE_ERROR_POLLING,
			     "EEPROM read/write done polling timed out");

	return status;
}

/**
 *  ixgbe_acquire_eeprom - Acquire EEPROM using bit-bang
 *  @@hw: pointer to hardware structure
 *
 *  Prepares EEPROM for access using bit-bang method. This function should
 *  be called before issuing a command to the EEPROM.
 **/
int32_t ixgbe_acquire_eeprom(struct ixgbe_hw *hw)
{
	int32_t status = IXGBE_SUCCESS;
	uint32_t eec;
	uint32_t i;

	DEBUGFUNC("ixgbe_acquire_eeprom");

	if (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM)
	    != IXGBE_SUCCESS)
		status = IXGBE_ERR_SWFW_SYNC;

	if (status == IXGBE_SUCCESS) {
		eec = IXGBE_READ_REG(hw, IXGBE_EEC);

		/* Request EEPROM Access */
		eec |= IXGBE_EEC_REQ;
		IXGBE_WRITE_REG(hw, IXGBE_EEC, eec);

		for (i = 0; i < IXGBE_EEPROM_GRANT_ATTEMPTS; i++) {
			eec = IXGBE_READ_REG(hw, IXGBE_EEC);
			if (eec & IXGBE_EEC_GNT)
				break;
			usec_delay(5);
		}

		/* Release if grant not acquired */
		if (!(eec & IXGBE_EEC_GNT)) {
			eec &= ~IXGBE_EEC_REQ;
			IXGBE_WRITE_REG(hw, IXGBE_EEC, eec);
			DEBUGOUT("Could not acquire EEPROM grant\n");

			hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
			status = IXGBE_ERR_EEPROM;
		}

		/* Setup EEPROM for Read/Write */
		if (status == IXGBE_SUCCESS) {
			/* Clear CS and SK */
			eec &= ~(IXGBE_EEC_CS | IXGBE_EEC_SK);
			IXGBE_WRITE_REG(hw, IXGBE_EEC, eec);
			IXGBE_WRITE_FLUSH(hw);
			usec_delay(1);
		}
	}
	return status;
}

/**
 *  ixgbe_get_eeprom_semaphore - Get hardware semaphore
 *  @@hw: pointer to hardware structure
 *
 *  Sets the hardware semaphores so EEPROM access can occur for bit-bang method
 **/
int32_t ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw)
{
	int32_t status = IXGBE_ERR_EEPROM;
	uint32_t timeout = 2000;
	uint32_t i;
	uint32_t swsm;

	DEBUGFUNC("ixgbe_get_eeprom_semaphore");


	/* Get SMBI software semaphore between device drivers first */
	for (i = 0; i < timeout; i++) {
		/*
		 * If the SMBI bit is 0 when we read it, then the bit will be
		 * set and we have the semaphore
		 */
		swsm = IXGBE_READ_REG(hw, IXGBE_SWSM);
		if (!(swsm & IXGBE_SWSM_SMBI)) {
			status = IXGBE_SUCCESS;
			break;
		}
		usec_delay(50);
	}

	if (i == timeout) {
		DEBUGOUT("Driver can't access the Eeprom - SMBI Semaphore "
			 "not granted.\n");
		/*
		 * this release is particularly important because our attempts
		 * above to get the semaphore may have succeeded, and if there
		 * was a timeout, we should unconditionally clear the semaphore
		 * bits to free the driver to make progress
		 */
		ixgbe_release_eeprom_semaphore(hw);

		usec_delay(50);
		/*
		 * one last try
		 * If the SMBI bit is 0 when we read it, then the bit will be
		 * set and we have the semaphore
		 */
		swsm = IXGBE_READ_REG(hw, IXGBE_SWSM);
		if (!(swsm & IXGBE_SWSM_SMBI))
			status = IXGBE_SUCCESS;
	}

	/* Now get the semaphore between SW/FW through the SWESMBI bit */
	if (status == IXGBE_SUCCESS) {
		for (i = 0; i < timeout; i++) {
			swsm = IXGBE_READ_REG(hw, IXGBE_SWSM);

			/* Set the SW EEPROM semaphore bit to request access */
			swsm |= IXGBE_SWSM_SWESMBI;
			IXGBE_WRITE_REG(hw, IXGBE_SWSM, swsm);

			/*
			 * If we set the bit successfully then we got the
			 * semaphore.
			 */
			swsm = IXGBE_READ_REG(hw, IXGBE_SWSM);
			if (swsm & IXGBE_SWSM_SWESMBI)
				break;

			usec_delay(50);
		}

		/*
		 * Release semaphores and return error if SW EEPROM semaphore
		 * was not granted because we don't have access to the EEPROM
		 */
		if (i >= timeout) {
			ERROR_REPORT1(IXGBE_ERROR_POLLING,
			    "SWESMBI Software EEPROM semaphore not granted.\n");
			ixgbe_release_eeprom_semaphore(hw);
			status = IXGBE_ERR_EEPROM;
		}
	} else {
		ERROR_REPORT1(IXGBE_ERROR_POLLING,
			     "Software semaphore SMBI between device drivers "
			     "not granted.\n");
	}

	return status;
}

/**
 *  ixgbe_release_eeprom_semaphore - Release hardware semaphore
 *  @@hw: pointer to hardware structure
 *
 *  This function clears hardware semaphore bits.
 **/
void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw)
{
	uint32_t swsm;

	DEBUGFUNC("ixgbe_release_eeprom_semaphore");

	swsm = IXGBE_READ_REG(hw, IXGBE_SWSM);

	/* Release both semaphores by writing 0 to the bits SWESMBI and SMBI */
	swsm &= ~(IXGBE_SWSM_SWESMBI | IXGBE_SWSM_SMBI);
	IXGBE_WRITE_REG(hw, IXGBE_SWSM, swsm);
	IXGBE_WRITE_FLUSH(hw);
}

/**
 *  ixgbe_ready_eeprom - Polls for EEPROM ready
 *  @@hw: pointer to hardware structure
 **/
int32_t ixgbe_ready_eeprom(struct ixgbe_hw *hw)
{
	int32_t status = IXGBE_SUCCESS;
	uint16_t i;
	uint8_t spi_stat_reg;

	DEBUGFUNC("ixgbe_ready_eeprom");

	/*
	 * Read "Status Register" repeatedly until the LSB is cleared.  The
	 * EEPROM will signal that the command has been completed by clearing
	 * bit 0 of the internal status register.  If it's not cleared within
	 * 5 milliseconds, then error out.
	 */
	for (i = 0; i < IXGBE_EEPROM_MAX_RETRY_SPI; i += 5) {
		ixgbe_shift_out_eeprom_bits(hw, IXGBE_EEPROM_RDSR_OPCODE_SPI,
					    IXGBE_EEPROM_OPCODE_BITS);
		spi_stat_reg = (uint8_t)ixgbe_shift_in_eeprom_bits(hw, 8);
		if (!(spi_stat_reg & IXGBE_EEPROM_STATUS_RDY_SPI))
			break;

		usec_delay(5);
		ixgbe_standby_eeprom(hw);
	}

	/*
	 * On some parts, SPI write time could vary from 0-20mSec on 3.3V
	 * devices (and only 0-5mSec on 5V devices)
	 */
	if (i >= IXGBE_EEPROM_MAX_RETRY_SPI) {
		DEBUGOUT("SPI EEPROM Status error\n");
		status = IXGBE_ERR_EEPROM;
	}

	return status;
}

/**
 *  ixgbe_standby_eeprom - Returns EEPROM to a "standby" state
 *  @@hw: pointer to hardware structure
 **/
void ixgbe_standby_eeprom(struct ixgbe_hw *hw)
{
	uint32_t eec;

	DEBUGFUNC("ixgbe_standby_eeprom");

	eec = IXGBE_READ_REG(hw, IXGBE_EEC);

	/* Toggle CS to flush commands */
	eec |= IXGBE_EEC_CS;
	IXGBE_WRITE_REG(hw, IXGBE_EEC, eec);
	IXGBE_WRITE_FLUSH(hw);
	usec_delay(1);
	eec &= ~IXGBE_EEC_CS;
	IXGBE_WRITE_REG(hw, IXGBE_EEC, eec);
	IXGBE_WRITE_FLUSH(hw);
	usec_delay(1);
}

/**
 *  ixgbe_shift_out_eeprom_bits - Shift data bits out to the EEPROM.
 *  @@hw: pointer to hardware structure
 *  @@data: data to send to the EEPROM
 *  @@count: number of bits to shift out
 **/
void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, uint16_t data,
				 uint16_t count)
{
	uint32_t eec;
	uint32_t mask;
	uint32_t i;

	DEBUGFUNC("ixgbe_shift_out_eeprom_bits");

	eec = IXGBE_READ_REG(hw, IXGBE_EEC);

	/*
	 * Mask is used to shift "count" bits of "data" out to the EEPROM
	 * one bit at a time.  Determine the starting bit based on count
	 */
	mask = 0x01 << (count - 1);

	for (i = 0; i < count; i++) {
		/*
		 * A "1" is shifted out to the EEPROM by setting bit "DI" to a
		 * "1", and then raising and then lowering the clock (the SK
		 * bit controls the clock input to the EEPROM).  A "0" is
		 * shifted out to the EEPROM by setting "DI" to "0" and then
		 * raising and then lowering the clock.
		 */
		if (data & mask)
			eec |= IXGBE_EEC_DI;
		else
			eec &= ~IXGBE_EEC_DI;

		IXGBE_WRITE_REG(hw, IXGBE_EEC, eec);
		IXGBE_WRITE_FLUSH(hw);

		usec_delay(1);

		ixgbe_raise_eeprom_clk(hw, &eec);
		ixgbe_lower_eeprom_clk(hw, &eec);

		/*
		 * Shift mask to signify next bit of data to shift in to the
		 * EEPROM
		 */
		mask = mask >> 1;
	}

	/* We leave the "DI" bit set to "0" when we leave this routine. */
	eec &= ~IXGBE_EEC_DI;
	IXGBE_WRITE_REG(hw, IXGBE_EEC, eec);
	IXGBE_WRITE_FLUSH(hw);
}

/**
 *  ixgbe_shift_in_eeprom_bits - Shift data bits in from the EEPROM
 *  @@hw: pointer to hardware structure
 **/
uint16_t ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, uint16_t count)
{
	uint32_t eec;
	uint32_t i;
	uint16_t data = 0;

	DEBUGFUNC("ixgbe_shift_in_eeprom_bits");

	/*
	 * In order to read a register from the EEPROM, we need to shift
	 * 'count' bits in from the EEPROM. Bits are "shifted in" by raising
	 * the clock input to the EEPROM (setting the SK bit), and then reading
	 * the value of the "DO" bit.  During this "shifting in" process the
	 * "DI" bit should always be clear.
	 */
	eec = IXGBE_READ_REG(hw, IXGBE_EEC);

	eec &= ~(IXGBE_EEC_DO | IXGBE_EEC_DI);

	for (i = 0; i < count; i++) {
		data = data << 1;
		ixgbe_raise_eeprom_clk(hw, &eec);

		eec = IXGBE_READ_REG(hw, IXGBE_EEC);

		eec &= ~(IXGBE_EEC_DI);
		if (eec & IXGBE_EEC_DO)
			data |= 1;

		ixgbe_lower_eeprom_clk(hw, &eec);
	}

	return data;
}

/**
 *  ixgbe_raise_eeprom_clk - Raises the EEPROM's clock input.
 *  @@hw: pointer to hardware structure
 *  @@eec: EEC register's current value
 **/
void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw, uint32_t *eec)
{
	DEBUGFUNC("ixgbe_raise_eeprom_clk");

	/*
	 * Raise the clock input to the EEPROM
	 * (setting the SK bit), then delay
	 */
	*eec = *eec | IXGBE_EEC_SK;
	IXGBE_WRITE_REG(hw, IXGBE_EEC, *eec);
	IXGBE_WRITE_FLUSH(hw);
	usec_delay(1);
}

/**
 *  ixgbe_lower_eeprom_clk - Lowers the EEPROM's clock input.
 *  @@hw: pointer to hardware structure
 *  @@eecd: EECD's current value
 **/
void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw, uint32_t *eec)
{
	DEBUGFUNC("ixgbe_lower_eeprom_clk");

	/*
	 * Lower the clock input to the EEPROM (clearing the SK bit), then
	 * delay
	 */
	*eec = *eec & ~IXGBE_EEC_SK;
	IXGBE_WRITE_REG(hw, IXGBE_EEC, *eec);
	IXGBE_WRITE_FLUSH(hw);
	usec_delay(1);
}

/**
 *  ixgbe_release_eeprom - Release EEPROM, release semaphores
 *  @@hw: pointer to hardware structure
 **/
void ixgbe_release_eeprom(struct ixgbe_hw *hw)
{
	uint32_t eec;

	DEBUGFUNC("ixgbe_release_eeprom");

	eec = IXGBE_READ_REG(hw, IXGBE_EEC);

	eec |= IXGBE_EEC_CS;  /* Pull CS high */
	eec &= ~IXGBE_EEC_SK; /* Lower SCK */

	IXGBE_WRITE_REG(hw, IXGBE_EEC, eec);
	IXGBE_WRITE_FLUSH(hw);

	usec_delay(1);

	/* Stop requesting EEPROM access */
	eec &= ~IXGBE_EEC_REQ;
	IXGBE_WRITE_REG(hw, IXGBE_EEC, eec);

	hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);

	/* Delay before attempt to obtain semaphore again to allow FW access */
	msec_delay(hw->eeprom.semaphore_delay);
}

/**
 *  ixgbe_calc_eeprom_checksum_generic - Calculates and returns the checksum
 *  @@hw: pointer to hardware structure
 *
 *  Returns a negative error code on error, or the 16-bit checksum
 **/
int32_t ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw)
{
	uint16_t i;
	uint16_t j;
	uint16_t checksum = 0;
	uint16_t length = 0;
	uint16_t pointer = 0;
	uint16_t word = 0;

	DEBUGFUNC("ixgbe_calc_eeprom_checksum_generic");

	/* Include 0x0-0x3F in the checksum */
	for (i = 0; i < IXGBE_EEPROM_CHECKSUM; i++) {
		if (hw->eeprom.ops.read(hw, i, &word)) {
			DEBUGOUT("EEPROM read failed\n");
			return IXGBE_ERR_EEPROM;
		}
		checksum += word;
	}

	/* Include all data from pointers except for the fw pointer */
	for (i = IXGBE_PCIE_ANALOG_PTR; i < IXGBE_FW_PTR; i++) {
		if (hw->eeprom.ops.read(hw, i, &pointer)) {
			DEBUGOUT("EEPROM read failed\n");
			return IXGBE_ERR_EEPROM;
		}

		/* If the pointer seems invalid */
		if (pointer == 0xFFFF || pointer == 0)
			continue;

		if (hw->eeprom.ops.read(hw, pointer, &length)) {
			DEBUGOUT("EEPROM read failed\n");
			return IXGBE_ERR_EEPROM;
		}

		if (length == 0xFFFF || length == 0)
			continue;

		for (j = pointer + 1; j <= pointer + length; j++) {
			if (hw->eeprom.ops.read(hw, j, &word)) {
				DEBUGOUT("EEPROM read failed\n");
				return IXGBE_ERR_EEPROM;
			}
			checksum += word;
		}
	}

	checksum = (uint16_t)IXGBE_EEPROM_SUM - checksum;

	return (int32_t)checksum;
}

/**
 *  ixgbe_validate_eeprom_checksum_generic - Validate EEPROM checksum
 *  @@hw: pointer to hardware structure
 *  @@checksum_val: calculated checksum
 *
 *  Performs checksum calculation and validates the EEPROM checksum.  If the
 *  caller does not need checksum_val, the value can be NULL.
 **/
int32_t ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw,
					       uint16_t *checksum_val)
{
	int32_t status;
	uint16_t checksum;
	uint16_t read_checksum = 0;

	DEBUGFUNC("ixgbe_validate_eeprom_checksum_generic");

	/* Read the first word from the EEPROM. If this times out or fails, do
	 * not continue or we could be in for a very long wait while every
	 * EEPROM read fails
	 */
	status = hw->eeprom.ops.read(hw, 0, &checksum);
	if (status) {
		DEBUGOUT("EEPROM read failed\n");
		return status;
	}

	status = hw->eeprom.ops.calc_checksum(hw);
	if (status < 0)
		return status;

	checksum = (uint16_t)(status & 0xffff);

	status = hw->eeprom.ops.read(hw, IXGBE_EEPROM_CHECKSUM, &read_checksum);
	if (status) {
		DEBUGOUT("EEPROM read failed\n");
		return status;
	}

	/* Verify read checksum from EEPROM is the same as
	 * calculated checksum
	 */
	if (read_checksum != checksum)
		status = IXGBE_ERR_EEPROM_CHECKSUM;

	/* If the user cares, return the calculated checksum */
	if (checksum_val)
		*checksum_val = checksum;

	return status;
}

/**
 *  ixgbe_update_eeprom_checksum_generic - Updates the EEPROM checksum
 *  @@hw: pointer to hardware structure
 **/
int32_t ixgbe_update_eeprom_checksum_generic(struct ixgbe_hw *hw)
{
	int32_t status;
	uint16_t checksum;

	DEBUGFUNC("ixgbe_update_eeprom_checksum_generic");

	/* Read the first word from the EEPROM. If this times out or fails, do
	 * not continue or we could be in for a very long wait while every
	 * EEPROM read fails
	 */
	status = hw->eeprom.ops.read(hw, 0, &checksum);
	if (status) {
		DEBUGOUT("EEPROM read failed\n");
		return status;
	}

	status = hw->eeprom.ops.calc_checksum(hw);
	if (status < 0)
		return status;

	checksum = (uint16_t)(status & 0xffff);

	status = hw->eeprom.ops.write(hw, IXGBE_EEPROM_CHECKSUM, checksum);

	return status;
}

/**
 *  ixgbe_validate_mac_addr - Validate MAC address
 *  @@mac_addr: pointer to MAC address.
 *
 *  Tests a MAC address to ensure it is a valid Individual Address
 **/
int32_t ixgbe_validate_mac_addr(uint8_t *mac_addr)
{
	int32_t status = IXGBE_SUCCESS;

	DEBUGFUNC("ixgbe_validate_mac_addr");

	/* Make sure it is not a multicast address */
	if (IXGBE_IS_MULTICAST(mac_addr)) {
		DEBUGOUT("MAC address is multicast\n");
		status = IXGBE_ERR_INVALID_MAC_ADDR;
	/* Not a broadcast address */
	} else if (IXGBE_IS_BROADCAST(mac_addr)) {
		DEBUGOUT("MAC address is broadcast\n");
		status = IXGBE_ERR_INVALID_MAC_ADDR;
	/* Reject the zero address */
	} else if (mac_addr[0] == 0 && mac_addr[1] == 0 && mac_addr[2] == 0 &&
		   mac_addr[3] == 0 && mac_addr[4] == 0 && mac_addr[5] == 0) {
		DEBUGOUT("MAC address is all zeros\n");
		status = IXGBE_ERR_INVALID_MAC_ADDR;
	}
	return status;
}

/**
 *  ixgbe_set_rar_generic - Set Rx address register
 *  @@hw: pointer to hardware structure
 *  @@index: Receive address register to write
 *  @@addr: Address to put into receive address register
 *  @@vmdq: VMDq "set" or "pool" index
 *  @@enable_addr: set flag that address is active
 *
 *  Puts an ethernet address into a receive address register.
 **/
int32_t ixgbe_set_rar_generic(struct ixgbe_hw *hw, uint32_t index, uint8_t *addr,
			      uint32_t vmdq, uint32_t enable_addr)
{
	uint32_t rar_low, rar_high;
	uint32_t rar_entries = hw->mac.num_rar_entries;

	DEBUGFUNC("ixgbe_set_rar_generic");

	/* Make sure we are using a valid rar index range */
	if (index >= rar_entries) {
		ERROR_REPORT2(IXGBE_ERROR_ARGUMENT,
			     "RAR index %d is out of range.\n", index);
		return IXGBE_ERR_INVALID_ARGUMENT;
	}

	/* setup VMDq pool selection before this RAR gets enabled */
	hw->mac.ops.set_vmdq(hw, index, vmdq);

	/*
	 * HW expects these in little endian so we reverse the byte
	 * order from network order (big endian) to little endian
	 */
	rar_low = ((uint32_t)addr[0] |
		   ((uint32_t)addr[1] << 8) |
		   ((uint32_t)addr[2] << 16) |
		   ((uint32_t)addr[3] << 24));
	/*
	 * Some parts put the VMDq setting in the extra RAH bits,
	 * so save everything except the lower 16 bits that hold part
	 * of the address and the address valid bit.
	 */
	rar_high = IXGBE_READ_REG(hw, IXGBE_RAH(index));
	rar_high &= ~(0x0000FFFF | IXGBE_RAH_AV);
	rar_high |= ((uint32_t)addr[4] | ((uint32_t)addr[5] << 8));

	if (enable_addr != 0)
		rar_high |= IXGBE_RAH_AV;

	IXGBE_WRITE_REG(hw, IXGBE_RAL(index), rar_low);
	IXGBE_WRITE_REG(hw, IXGBE_RAH(index), rar_high);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_clear_rar_generic - Remove Rx address register
 *  @@hw: pointer to hardware structure
 *  @@index: Receive address register to write
 *
 *  Clears an ethernet address from a receive address register.
 **/
int32_t ixgbe_clear_rar_generic(struct ixgbe_hw *hw, uint32_t index)
{
	uint32_t rar_high;
	uint32_t rar_entries = hw->mac.num_rar_entries;

	DEBUGFUNC("ixgbe_clear_rar_generic");

	/* Make sure we are using a valid rar index range */
	if (index >= rar_entries) {
		ERROR_REPORT2(IXGBE_ERROR_ARGUMENT,
			     "RAR index %d is out of range.\n", index);
		return IXGBE_ERR_INVALID_ARGUMENT;
	}

	/*
	 * Some parts put the VMDq setting in the extra RAH bits,
	 * so save everything except the lower 16 bits that hold part
	 * of the address and the address valid bit.
	 */
	rar_high = IXGBE_READ_REG(hw, IXGBE_RAH(index));
	rar_high &= ~(0x0000FFFF | IXGBE_RAH_AV);

	IXGBE_WRITE_REG(hw, IXGBE_RAL(index), 0);
	IXGBE_WRITE_REG(hw, IXGBE_RAH(index), rar_high);

	/* clear VMDq pool/queue selection for this RAR */
	hw->mac.ops.clear_vmdq(hw, index, IXGBE_CLEAR_VMDQ_ALL);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_init_rx_addrs_generic - Initializes receive address filters.
 *  @@hw: pointer to hardware structure
 *
 *  Places the MAC address in receive address register 0 and clears the rest
 *  of the receive address registers. Clears the multicast table. Assumes
 *  the receiver is in reset when the routine is called.
 **/
int32_t ixgbe_init_rx_addrs_generic(struct ixgbe_hw *hw)
{
	uint32_t i;
	uint32_t rar_entries = hw->mac.num_rar_entries;

	DEBUGFUNC("ixgbe_init_rx_addrs_generic");

	/*
	 * If the current mac address is valid, assume it is a software override
	 * to the permanent address.
	 * Otherwise, use the permanent address from the eeprom.
	 */
	if (ixgbe_validate_mac_addr(hw->mac.addr) ==
	    IXGBE_ERR_INVALID_MAC_ADDR) {
		/* Get the MAC address from the RAR0 for later reference */
		hw->mac.ops.get_mac_addr(hw, hw->mac.addr);

		DEBUGOUT3(" Keeping Current RAR0 Addr =%.2X %.2X %.2X ",
			  hw->mac.addr[0], hw->mac.addr[1],
			  hw->mac.addr[2]);
		DEBUGOUT3("%.2X %.2X %.2X\n", hw->mac.addr[3],
			  hw->mac.addr[4], hw->mac.addr[5]);
	} else {
		/* Setup the receive address. */
		DEBUGOUT("Overriding MAC Address in RAR[0]\n");
		DEBUGOUT3(" New MAC Addr =%.2X %.2X %.2X ",
			  hw->mac.addr[0], hw->mac.addr[1],
			  hw->mac.addr[2]);
		DEBUGOUT3("%.2X %.2X %.2X\n", hw->mac.addr[3],
			  hw->mac.addr[4], hw->mac.addr[5]);

		hw->mac.ops.set_rar(hw, 0, hw->mac.addr, 0, IXGBE_RAH_AV);

		/* clear VMDq pool/queue selection for RAR 0 */
		hw->mac.ops.clear_vmdq(hw, 0, IXGBE_CLEAR_VMDQ_ALL);
	}
	hw->addr_ctrl.overflow_promisc = 0;

	hw->addr_ctrl.rar_used_count = 1;

	/* Zero out the other receive addresses. */
	DEBUGOUT1("Clearing RAR[1-%d]\n", rar_entries - 1);
	for (i = 1; i < rar_entries; i++) {
		IXGBE_WRITE_REG(hw, IXGBE_RAL(i), 0);
		IXGBE_WRITE_REG(hw, IXGBE_RAH(i), 0);
	}

	/* Clear the MTA */
	hw->addr_ctrl.mta_in_use = 0;
	IXGBE_WRITE_REG(hw, IXGBE_MCSTCTRL, hw->mac.mc_filter_type);

	DEBUGOUT(" Clearing MTA\n");
	for (i = 0; i < hw->mac.mcft_size; i++)
		IXGBE_WRITE_REG(hw, IXGBE_MTA(i), 0);

	ixgbe_init_uta_tables(hw);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_add_uc_addr - Adds a secondary unicast address.
 *  @@hw: pointer to hardware structure
 *  @@addr: new address
 *
 *  Adds it to unused receive address register or goes into promiscuous mode.
 **/
void ixgbe_add_uc_addr(struct ixgbe_hw *hw, uint8_t *addr, uint32_t vmdq)
{
	uint32_t rar_entries = hw->mac.num_rar_entries;
	uint32_t rar;

	DEBUGFUNC("ixgbe_add_uc_addr");

	DEBUGOUT6(" UC Addr = %.2X %.2X %.2X %.2X %.2X %.2X\n",
		  addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);

	/*
	 * Place this address in the RAR if there is room,
	 * else put the controller into promiscuous mode
	 */
	if (hw->addr_ctrl.rar_used_count < rar_entries) {
		rar = hw->addr_ctrl.rar_used_count;
		hw->mac.ops.set_rar(hw, rar, addr, vmdq, IXGBE_RAH_AV);
		DEBUGOUT1("Added a secondary address to RAR[%d]\n", rar);
		hw->addr_ctrl.rar_used_count++;
	} else {
		hw->addr_ctrl.overflow_promisc++;
	}

	DEBUGOUT("ixgbe_add_uc_addr Complete\n");
}

/**
 *  ixgbe_mta_vector - Determines bit-vector in multicast table to set
 *  @@hw: pointer to hardware structure
 *  @@mc_addr: the multicast address
 *
 *  Extracts the 12 bits, from a multicast address, to determine which
 *  bit-vector to set in the multicast table. The hardware uses 12 bits, from
 *  incoming rx multicast addresses, to determine the bit-vector to check in
 *  the MTA. Which of the 4 combination, of 12-bits, the hardware uses is set
 *  by the MO field of the MCSTCTRL. The MO field is set during initialization
 *  to mc_filter_type.
 **/
int32_t ixgbe_mta_vector(struct ixgbe_hw *hw, uint8_t *mc_addr)
{
	uint32_t vector = 0;

	DEBUGFUNC("ixgbe_mta_vector");

	switch (hw->mac.mc_filter_type) {
	case 0:   /* use bits [47:36] of the address */
		vector = ((mc_addr[4] >> 4) | (((uint16_t)mc_addr[5]) << 4));
		break;
	case 1:   /* use bits [46:35] of the address */
		vector = ((mc_addr[4] >> 3) | (((uint16_t)mc_addr[5]) << 5));
		break;
	case 2:   /* use bits [45:34] of the address */
		vector = ((mc_addr[4] >> 2) | (((uint16_t)mc_addr[5]) << 6));
		break;
	case 3:   /* use bits [43:32] of the address */
		vector = ((mc_addr[4]) | (((uint16_t)mc_addr[5]) << 8));
		break;
	default:  /* Invalid mc_filter_type */
		DEBUGOUT("MC filter type param set incorrectly\n");
		panic("incorrect multicast filter type");
		break;
	}

	/* vector can only be 12-bits or boundary will be exceeded */
	vector &= 0xFFF;
	return vector;
}

/**
 *  ixgbe_set_mta - Set bit-vector in multicast table
 *  @@hw: pointer to hardware structure
 *  @@hash_value: Multicast address hash value
 *
 *  Sets the bit-vector in the multicast table.
 **/
void ixgbe_set_mta(struct ixgbe_hw *hw, uint8_t *mc_addr)
{
	uint32_t vector;
	uint32_t vector_bit;
	uint32_t vector_reg;

	DEBUGFUNC("ixgbe_set_mta");

	hw->addr_ctrl.mta_in_use++;

	vector = ixgbe_mta_vector(hw, mc_addr);
	DEBUGOUT1(" bit-vector = 0x%03X\n", vector);

	/*
	 * The MTA is a register array of 128 32-bit registers. It is treated
	 * like an array of 4096 bits.  We want to set bit
	 * BitArray[vector_value]. So we figure out what register the bit is
	 * in, read it, OR in the new bit, then write back the new value.  The
	 * register is determined by the upper 7 bits of the vector value and
	 * the bit within that register are determined by the lower 5 bits of
	 * the value.
	 */
	vector_reg = (vector >> 5) & 0x7F;
	vector_bit = vector & 0x1F;
	hw->mac.mta_shadow[vector_reg] |= (1 << vector_bit);
}

/**
 *  ixgbe_update_mc_addr_list_generic - Updates MAC list of multicast addresses
 *  @@hw: pointer to hardware structure
 *  @@mc_addr_list: the list of new multicast addresses
 *  @@mc_addr_count: number of addresses
 *  @@next: iterator function to walk the multicast address list
 *  @@clear: flag, when set clears the table beforehand
 *
 *  When the clear flag is set, the given list replaces any existing list.
 *  Hashes the given addresses into the multicast table.
 **/
int32_t ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw, uint8_t *mc_addr_list,
					  uint32_t mc_addr_count, ixgbe_mc_addr_itr next,
					  bool clear)
{
	uint32_t i;
	uint32_t vmdq;

	DEBUGFUNC("ixgbe_update_mc_addr_list_generic");

	/*
	 * Set the new number of MC addresses that we are being requested to
	 * use.
	 */
	hw->addr_ctrl.num_mc_addrs = mc_addr_count;
	hw->addr_ctrl.mta_in_use = 0;

	/* Clear mta_shadow */
	if (clear) {
		DEBUGOUT(" Clearing MTA\n");
		memset(&hw->mac.mta_shadow, 0, sizeof(hw->mac.mta_shadow));
	}

	/* Update mta_shadow */
	for (i = 0; i < mc_addr_count; i++) {
		DEBUGOUT(" Adding the multicast addresses:\n");
		ixgbe_set_mta(hw, next(hw, &mc_addr_list, &vmdq));
	}

	/* Enable mta */
	for (i = 0; i < hw->mac.mcft_size; i++)
		IXGBE_WRITE_REG_ARRAY(hw, IXGBE_MTA(0), i,
				      hw->mac.mta_shadow[i]);

	if (hw->addr_ctrl.mta_in_use > 0)
		IXGBE_WRITE_REG(hw, IXGBE_MCSTCTRL,
				IXGBE_MCSTCTRL_MFE | hw->mac.mc_filter_type);

	DEBUGOUT("ixgbe_update_mc_addr_list_generic Complete\n");
	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_enable_mc_generic - Enable multicast address in RAR
 *  @@hw: pointer to hardware structure
 *
 *  Enables multicast address in RAR and the use of the multicast hash table.
 **/
int32_t ixgbe_enable_mc_generic(struct ixgbe_hw *hw)
{
	struct ixgbe_addr_filter_info *a = &hw->addr_ctrl;

	DEBUGFUNC("ixgbe_enable_mc_generic");

	if (a->mta_in_use > 0)
		IXGBE_WRITE_REG(hw, IXGBE_MCSTCTRL, IXGBE_MCSTCTRL_MFE |
				hw->mac.mc_filter_type);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_disable_mc_generic - Disable multicast address in RAR
 *  @@hw: pointer to hardware structure
 *
 *  Disables multicast address in RAR and the use of the multicast hash table.
 **/
int32_t ixgbe_disable_mc_generic(struct ixgbe_hw *hw)
{
	struct ixgbe_addr_filter_info *a = &hw->addr_ctrl;

	DEBUGFUNC("ixgbe_disable_mc_generic");

	if (a->mta_in_use > 0)
		IXGBE_WRITE_REG(hw, IXGBE_MCSTCTRL, hw->mac.mc_filter_type);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_fc_enable_generic - Enable flow control
 *  @@hw: pointer to hardware structure
 *
 *  Enable flow control according to the current settings.
 **/
int32_t ixgbe_fc_enable_generic(struct ixgbe_hw *hw)
{
	int32_t ret_val = IXGBE_SUCCESS;
	uint32_t mflcn_reg, fccfg_reg;
	uint32_t reg;
	uint32_t fcrtl, fcrth;
	int i;

	DEBUGFUNC("ixgbe_fc_enable_generic");

	/* Validate the water mark configuration */
	if (!hw->fc.pause_time) {
		ret_val = IXGBE_ERR_INVALID_LINK_SETTINGS;
		goto out;
	}

	/* Low water mark of zero causes XOFF floods */
	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
		if ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&
		    hw->fc.high_water[i]) {
			if (!hw->fc.low_water[i] ||
			    hw->fc.low_water[i] >= hw->fc.high_water[i]) {
				DEBUGOUT("Invalid water mark configuration\n");
				ret_val = IXGBE_ERR_INVALID_LINK_SETTINGS;
				goto out;
			}
		}
	}

	/* Negotiate the fc mode to use */
	ixgbe_fc_autoneg(hw);

	/* Disable any previous flow control settings */
	mflcn_reg = IXGBE_READ_REG(hw, IXGBE_MFLCN);
	mflcn_reg &= ~(IXGBE_MFLCN_RPFCE_MASK | IXGBE_MFLCN_RFCE);

	fccfg_reg = IXGBE_READ_REG(hw, IXGBE_FCCFG);
	fccfg_reg &= ~(IXGBE_FCCFG_TFCE_802_3X | IXGBE_FCCFG_TFCE_PRIORITY);

	/*
	 * The possible values of fc.current_mode are:
	 * 0: Flow control is completely disabled
	 * 1: Rx flow control is enabled (we can receive pause frames,
	 *    but not send pause frames).
	 * 2: Tx flow control is enabled (we can send pause frames but
	 *    we do not support receiving pause frames).
	 * 3: Both Rx and Tx flow control (symmetric) are enabled.
	 * other: Invalid.
	 */
	switch (hw->fc.current_mode) {
	case ixgbe_fc_none:
		/*
		 * Flow control is disabled by software override or autoneg.
		 * The code below will actually disable it in the HW.
		 */
		break;
	case ixgbe_fc_rx_pause:
		/*
		 * Rx Flow control is enabled and Tx Flow control is
		 * disabled by software override. Since there really
		 * isn't a way to advertise that we are capable of RX
		 * Pause ONLY, we will advertise that we support both
		 * symmetric and asymmetric Rx PAUSE.  Later, we will
		 * disable the adapter's ability to send PAUSE frames.
		 */
		mflcn_reg |= IXGBE_MFLCN_RFCE;
		break;
	case ixgbe_fc_tx_pause:
		/*
		 * Tx Flow control is enabled, and Rx Flow control is
		 * disabled by software override.
		 */
		fccfg_reg |= IXGBE_FCCFG_TFCE_802_3X;
		break;
	case ixgbe_fc_full:
		/* Flow control (both Rx and Tx) is enabled by SW override. */
		mflcn_reg |= IXGBE_MFLCN_RFCE;
		fccfg_reg |= IXGBE_FCCFG_TFCE_802_3X;
		break;
	default:
		ERROR_REPORT1(IXGBE_ERROR_ARGUMENT,
			     "Flow control param set incorrectly\n");
		ret_val = IXGBE_ERR_CONFIG;
		goto out;
		break;
	}

	/* Set 802.3x based flow control settings. */
	mflcn_reg |= IXGBE_MFLCN_DPF;
	IXGBE_WRITE_REG(hw, IXGBE_MFLCN, mflcn_reg);
	IXGBE_WRITE_REG(hw, IXGBE_FCCFG, fccfg_reg);


	/* Set up and enable Rx high/low water mark thresholds, enable XON. */
	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
		if ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&
		    hw->fc.high_water[i]) {
			fcrtl = (hw->fc.low_water[i] << 10) | IXGBE_FCRTL_XONE;
			IXGBE_WRITE_REG(hw, IXGBE_FCRTL_82599(i), fcrtl);
			fcrth = (hw->fc.high_water[i] << 10) | IXGBE_FCRTH_FCEN;
		} else {
			IXGBE_WRITE_REG(hw, IXGBE_FCRTL_82599(i), 0);
			/*
			 * In order to prevent Tx hangs when the internal Tx
			 * switch is enabled we must set the high water mark
			 * to the Rx packet buffer size - 24KB.  This allows
			 * the Tx switch to function even under heavy Rx
			 * workloads.
			 */
			fcrth = IXGBE_READ_REG(hw, IXGBE_RXPBSIZE(i)) - 0x6000;
		}

		IXGBE_WRITE_REG(hw, IXGBE_FCRTH_82599(i), fcrth);
	}

	/* Configure pause time (2 TCs per register) */
	reg = hw->fc.pause_time * 0x00010001;
	for (i = 0; i < (IXGBE_DCB_MAX_TRAFFIC_CLASS / 2); i++)
		IXGBE_WRITE_REG(hw, IXGBE_FCTTV(i), reg);

	/* Configure flow control refresh threshold value */
	IXGBE_WRITE_REG(hw, IXGBE_FCRTV, hw->fc.pause_time / 2);

out:
	return ret_val;
}

/**
 *  ixgbe_negotiate_fc - Negotiate flow control
 *  @@hw: pointer to hardware structure
 *  @@adv_reg: flow control advertised settings
 *  @@lp_reg: link partner's flow control settings
 *  @@adv_sym: symmetric pause bit in advertisement
 *  @@adv_asm: asymmetric pause bit in advertisement
 *  @@lp_sym: symmetric pause bit in link partner advertisement
 *  @@lp_asm: asymmetric pause bit in link partner advertisement
 *
 *  Find the intersection between advertised settings and link partner's
 *  advertised settings
 **/
int32_t ixgbe_negotiate_fc(struct ixgbe_hw *hw, uint32_t adv_reg,
			   uint32_t lp_reg, uint32_t adv_sym,
			   uint32_t adv_asm, uint32_t lp_sym,
			   uint32_t lp_asm)
{
	if ((!(adv_reg)) ||  (!(lp_reg))) {
		ERROR_REPORT3(IXGBE_ERROR_UNSUPPORTED,
			     "Local or link partner's advertised flow control "
			     "settings are NULL. Local: %x, link partner: %x\n",
			     adv_reg, lp_reg);
		return IXGBE_ERR_FC_NOT_NEGOTIATED;
	}

	if ((adv_reg & adv_sym) && (lp_reg & lp_sym)) {
		/*
		 * Now we need to check if the user selected Rx ONLY
		 * of pause frames.  In this case, we had to advertise
		 * FULL flow control because we could not advertise RX
		 * ONLY. Hence, we must now check to see if we need to
		 * turn OFF the TRANSMISSION of PAUSE frames.
		 */
		if (hw->fc.requested_mode == ixgbe_fc_full) {
			hw->fc.current_mode = ixgbe_fc_full;
			DEBUGOUT("Flow Control = FULL.\n");
		} else {
			hw->fc.current_mode = ixgbe_fc_rx_pause;
			DEBUGOUT("Flow Control=RX PAUSE frames only\n");
		}
	} else if (!(adv_reg & adv_sym) && (adv_reg & adv_asm) &&
		   (lp_reg & lp_sym) && (lp_reg & lp_asm)) {
		hw->fc.current_mode = ixgbe_fc_tx_pause;
		DEBUGOUT("Flow Control = TX PAUSE frames only.\n");
	} else if ((adv_reg & adv_sym) && (adv_reg & adv_asm) &&
		   !(lp_reg & lp_sym) && (lp_reg & lp_asm)) {
		hw->fc.current_mode = ixgbe_fc_rx_pause;
		DEBUGOUT("Flow Control = RX PAUSE frames only.\n");
	} else {
		hw->fc.current_mode = ixgbe_fc_none;
		DEBUGOUT("Flow Control = NONE.\n");
	}
	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_fc_autoneg_fiber - Enable flow control on 1 gig fiber
 *  @@hw: pointer to hardware structure
 *
 *  Enable flow control according on 1 gig fiber.
 **/
int32_t ixgbe_fc_autoneg_fiber(struct ixgbe_hw *hw)
{
	uint32_t pcs_anadv_reg, pcs_lpab_reg, linkstat;
	int32_t ret_val = IXGBE_ERR_FC_NOT_NEGOTIATED;

	/*
	 * On multispeed fiber at 1g, bail out if
	 * - link is up but AN did not complete, or if
	 * - link is up and AN completed but timed out
	 */

	linkstat = IXGBE_READ_REG(hw, IXGBE_PCS1GLSTA);
	if ((!!(linkstat & IXGBE_PCS1GLSTA_AN_COMPLETE) == 0) ||
	    (!!(linkstat & IXGBE_PCS1GLSTA_AN_TIMED_OUT) == 1)) {
		DEBUGOUT("Auto-Negotiation did not complete or timed out\n");
		goto out;
	}

	pcs_anadv_reg = IXGBE_READ_REG(hw, IXGBE_PCS1GANA);
	pcs_lpab_reg = IXGBE_READ_REG(hw, IXGBE_PCS1GANLP);

	ret_val =  ixgbe_negotiate_fc(hw, pcs_anadv_reg,
				      pcs_lpab_reg, IXGBE_PCS1GANA_SYM_PAUSE,
				      IXGBE_PCS1GANA_ASM_PAUSE,
				      IXGBE_PCS1GANA_SYM_PAUSE,
				      IXGBE_PCS1GANA_ASM_PAUSE);

out:
	return ret_val;
}

/**
 *  ixgbe_fc_autoneg_backplane - Enable flow control IEEE clause 37
 *  @@hw: pointer to hardware structure
 *
 *  Enable flow control according to IEEE clause 37.
 **/
int32_t ixgbe_fc_autoneg_backplane(struct ixgbe_hw *hw)
{
	uint32_t links2, anlp1_reg, autoc_reg, links;
	int32_t ret_val = IXGBE_ERR_FC_NOT_NEGOTIATED;

	/*
	 * On backplane, bail out if
	 * - backplane autoneg was not completed, or if
	 * - we are 82599 and link partner is not AN enabled
	 */
	links = IXGBE_READ_REG(hw, IXGBE_LINKS);
	if ((links & IXGBE_LINKS_KX_AN_COMP) == 0) {
		DEBUGOUT("Auto-Negotiation did not complete\n");
		goto out;
	}

	if (hw->mac.type == ixgbe_mac_82599EB) {
		links2 = IXGBE_READ_REG(hw, IXGBE_LINKS2);
		if ((links2 & IXGBE_LINKS2_AN_SUPPORTED) == 0) {
			DEBUGOUT("Link partner is not AN enabled\n");
			goto out;
		}
	}
	/*
	 * Read the 10g AN autoc and LP ability registers and resolve
	 * local flow control settings accordingly
	 */
	autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
	anlp1_reg = IXGBE_READ_REG(hw, IXGBE_ANLP1);

	ret_val = ixgbe_negotiate_fc(hw, autoc_reg,
		anlp1_reg, IXGBE_AUTOC_SYM_PAUSE, IXGBE_AUTOC_ASM_PAUSE,
		IXGBE_ANLP1_SYM_PAUSE, IXGBE_ANLP1_ASM_PAUSE);

out:
	return ret_val;
}

/**
 *  ixgbe_fc_autoneg_copper - Enable flow control IEEE clause 37
 *  @@hw: pointer to hardware structure
 *
 *  Enable flow control according to IEEE clause 37.
 **/
int32_t ixgbe_fc_autoneg_copper(struct ixgbe_hw *hw)
{
	uint16_t technology_ability_reg = 0;
	uint16_t lp_technology_ability_reg = 0;

	hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_ADVT,
			     IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
			     &technology_ability_reg);
	hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_LP,
			     IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
			     &lp_technology_ability_reg);

	return ixgbe_negotiate_fc(hw, (uint32_t)technology_ability_reg,
				  (uint32_t)lp_technology_ability_reg,
				  IXGBE_TAF_SYM_PAUSE, IXGBE_TAF_ASM_PAUSE,
				  IXGBE_TAF_SYM_PAUSE, IXGBE_TAF_ASM_PAUSE);
}

/**
 *  ixgbe_fc_autoneg - Configure flow control
 *  @@hw: pointer to hardware structure
 *
 *  Compares our advertised flow control capabilities to those advertised by
 *  our link partner, and determines the proper flow control mode to use.
 **/
void ixgbe_fc_autoneg(struct ixgbe_hw *hw)
{
	int32_t ret_val = IXGBE_ERR_FC_NOT_NEGOTIATED;
	ixgbe_link_speed speed;
	bool link_up;

	DEBUGFUNC("ixgbe_fc_autoneg");

	/*
	 * AN should have completed when the cable was plugged in.
	 * Look for reasons to bail out.  Bail out if:
	 * - FC autoneg is disabled, or if
	 * - link is not up.
	 */
	if (hw->fc.disable_fc_autoneg) {
		ERROR_REPORT1(IXGBE_ERROR_UNSUPPORTED,
			     "Flow control autoneg is disabled");
		goto out;
	}

	hw->mac.ops.check_link(hw, &speed, &link_up, FALSE);
	if (!link_up) {
		ERROR_REPORT1(IXGBE_ERROR_SOFTWARE, "The link is down");
		goto out;
	}

	switch (hw->phy.media_type) {
	/* Autoneg flow control on fiber adapters */
	case ixgbe_media_type_fiber_fixed:
	case ixgbe_media_type_fiber_qsfp:
	case ixgbe_media_type_fiber:
		if (speed == IXGBE_LINK_SPEED_1GB_FULL)
			ret_val = ixgbe_fc_autoneg_fiber(hw);
		break;

	/* Autoneg flow control on backplane adapters */
	case ixgbe_media_type_backplane:
		ret_val = ixgbe_fc_autoneg_backplane(hw);
		break;

	/* Autoneg flow control on copper adapters */
	case ixgbe_media_type_copper:
		if (ixgbe_device_supports_autoneg_fc(hw))
			ret_val = ixgbe_fc_autoneg_copper(hw);
		break;

	default:
		break;
	}

out:
	if (ret_val == IXGBE_SUCCESS) {
		hw->fc.fc_was_autonegged = TRUE;
	} else {
		hw->fc.fc_was_autonegged = FALSE;
		hw->fc.current_mode = hw->fc.requested_mode;
	}
}

/*
 * ixgbe_pcie_timeout_poll - Return number of times to poll for completion
 * @@hw: pointer to hardware structure
 *
 * System-wide timeout range is encoded in PCIe Device Control2 register.
 *
 * Add 10% to specified maximum and return the number of times to poll for
 * completion timeout, in units of 100 microsec.  Never return less than
 * 800 = 80 millisec.
 */
static uint32_t ixgbe_pcie_timeout_poll(struct ixgbe_hw *hw)
{
	int16_t devctl2;
	uint32_t pollcnt;

	devctl2 = IXGBE_READ_PCIE_WORD(hw, IXGBE_PCI_DEVICE_CONTROL2);
	devctl2 &= IXGBE_PCIDEVCTRL2_TIMEO_MASK;

	switch (devctl2) {
	case IXGBE_PCIDEVCTRL2_65_130ms:
		pollcnt = 1300;		/* 130 millisec */
		break;
	case IXGBE_PCIDEVCTRL2_260_520ms:
		pollcnt = 5200;		/* 520 millisec */
		break;
	case IXGBE_PCIDEVCTRL2_1_2s:
		pollcnt = 20000;	/* 2 sec */
		break;
	case IXGBE_PCIDEVCTRL2_4_8s:
		pollcnt = 80000;	/* 8 sec */
		break;
	case IXGBE_PCIDEVCTRL2_17_34s:
		pollcnt = 34000;	/* 34 sec */
		break;
	case IXGBE_PCIDEVCTRL2_50_100us:	/* 100 microsecs */
	case IXGBE_PCIDEVCTRL2_1_2ms:		/* 2 millisecs */
	case IXGBE_PCIDEVCTRL2_16_32ms:		/* 32 millisec */
	case IXGBE_PCIDEVCTRL2_16_32ms_def:	/* 32 millisec default */
	default:
		pollcnt = 800;		/* 80 millisec minimum */
		break;
	}

	/* add 10% to spec maximum */
	return (pollcnt * 11) / 10;
}

/**
 *  ixgbe_disable_pcie_master - Disable PCI-express master access
 *  @@hw: pointer to hardware structure
 *
 *  Disables PCI-Express master access and verifies there are no pending
 *  requests. IXGBE_ERR_MASTER_REQUESTS_PENDING is returned if master disable
 *  bit hasn't caused the master requests to be disabled, else IXGBE_SUCCESS
 *  is returned signifying master requests disabled.
 **/
int32_t ixgbe_disable_pcie_master(struct ixgbe_hw *hw)
{
	int32_t status = IXGBE_SUCCESS;
	uint32_t i, poll;

	DEBUGFUNC("ixgbe_disable_pcie_master");

	/* Always set this bit to ensure any future transactions are blocked */
	IXGBE_WRITE_REG(hw, IXGBE_CTRL, IXGBE_CTRL_GIO_DIS);

	/* Exit if master requests are blocked */
	if (!(IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_GIO))
		goto out;

	/* Poll for master request bit to clear */
	for (i = 0; i < IXGBE_PCI_MASTER_DISABLE_TIMEOUT; i++) {
		usec_delay(100);
		if (!(IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_GIO))
			goto out;
	}

	/*
	 * Two consecutive resets are required via CTRL.RST per datasheet
	 * 5.2.5.3.2 Master Disable.  We set a flag to inform the reset routine
	 * of this need.  The first reset prevents new master requests from
	 * being issued by our device.  We then must wait 1usec or more for any
	 * remaining completions from the PCIe bus to trickle in, and then reset
	 * again to clear out any effects they may have had on our device.
	 */
	DEBUGOUT("GIO Master Disable bit didn't clear - requesting resets\n");
	hw->mac.flags |= IXGBE_FLAGS_DOUBLE_RESET_REQUIRED;

	if (hw->mac.type >= ixgbe_mac_X550)
		goto out;

	/*
	 * Before proceeding, make sure that the PCIe block does not have
	 * transactions pending.
	 */
	poll = ixgbe_pcie_timeout_poll(hw);
	for (i = 0; i < poll; i++) {
		usec_delay(100);
		if (!(IXGBE_READ_PCIE_WORD(hw, IXGBE_PCI_DEVICE_STATUS) &
		    IXGBE_PCI_DEVICE_STATUS_TRANSACTION_PENDING))
			goto out;
	}

	ERROR_REPORT1(IXGBE_ERROR_POLLING,
		     "PCIe transaction pending bit also did not clear.\n");
	status = IXGBE_ERR_MASTER_REQUESTS_PENDING;

out:
	return status;
}

/**
 *  ixgbe_acquire_swfw_sync - Acquire SWFW semaphore
 *  @@hw: pointer to hardware structure
 *  @@mask: Mask to specify which semaphore to acquire
 *
 *  Acquires the SWFW semaphore through the GSSR register for the specified
 *  function (CSR, PHY0, PHY1, EEPROM, Flash)
 **/
int32_t ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw, uint32_t mask)
{
	uint32_t gssr = 0;
	uint32_t swmask = mask;
	uint32_t fwmask = mask << 5;
	uint32_t timeout = 200;
	uint32_t i;

	DEBUGFUNC("ixgbe_acquire_swfw_sync");

	for (i = 0; i < timeout; i++) {
		/*
		 * SW NVM semaphore bit is used for access to all
		 * SW_FW_SYNC bits (not just NVM)
		 */
		if (ixgbe_get_eeprom_semaphore(hw))
			return IXGBE_ERR_SWFW_SYNC;

		gssr = IXGBE_READ_REG(hw, IXGBE_GSSR);
		if (!(gssr & (fwmask | swmask))) {
			gssr |= swmask;
			IXGBE_WRITE_REG(hw, IXGBE_GSSR, gssr);
			ixgbe_release_eeprom_semaphore(hw);
			return IXGBE_SUCCESS;
		} else {
			/* Resource is currently in use by FW or SW */
			ixgbe_release_eeprom_semaphore(hw);
			msec_delay(5);
		}
	}

	/* If time expired clear the bits holding the lock and retry */
	if (gssr & (fwmask | swmask))
		ixgbe_release_swfw_sync(hw, gssr & (fwmask | swmask));

	msec_delay(5);
	return IXGBE_ERR_SWFW_SYNC;
}

/**
 *  ixgbe_release_swfw_sync - Release SWFW semaphore
 *  @@hw: pointer to hardware structure
 *  @@mask: Mask to specify which semaphore to release
 *
 *  Releases the SWFW semaphore through the GSSR register for the specified
 *  function (CSR, PHY0, PHY1, EEPROM, Flash)
 **/
void ixgbe_release_swfw_sync(struct ixgbe_hw *hw, uint32_t mask)
{
	uint32_t gssr;
	uint32_t swmask = mask;

	DEBUGFUNC("ixgbe_release_swfw_sync");

	ixgbe_get_eeprom_semaphore(hw);

	gssr = IXGBE_READ_REG(hw, IXGBE_GSSR);
	gssr &= ~swmask;
	IXGBE_WRITE_REG(hw, IXGBE_GSSR, gssr);

	ixgbe_release_eeprom_semaphore(hw);
}

/**
 *  ixgbe_disable_sec_rx_path_generic - Stops the receive data path
 *  @@hw: pointer to hardware structure
 *
 *  Stops the receive data path and waits for the HW to internally empty
 *  the Rx security block
 **/
int32_t ixgbe_disable_sec_rx_path_generic(struct ixgbe_hw *hw)
{
#define IXGBE_MAX_SECRX_POLL 40

	int i;
	int secrxreg;

	DEBUGFUNC("ixgbe_disable_sec_rx_path_generic");


	secrxreg = IXGBE_READ_REG(hw, IXGBE_SECRXCTRL);
	secrxreg |= IXGBE_SECRXCTRL_RX_DIS;
	IXGBE_WRITE_REG(hw, IXGBE_SECRXCTRL, secrxreg);
	for (i = 0; i < IXGBE_MAX_SECRX_POLL; i++) {
		secrxreg = IXGBE_READ_REG(hw, IXGBE_SECRXSTAT);
		if (secrxreg & IXGBE_SECRXSTAT_SECRX_RDY)
			break;
		else
			/* Use interrupt-safe sleep just in case */
			usec_delay(1000);
	}

	/* For informational purposes only */
	if (i >= IXGBE_MAX_SECRX_POLL)
		DEBUGOUT("Rx unit being enabled before security "
			 "path fully disabled.  Continuing with init.\n");

	return IXGBE_SUCCESS;
}

/**
 *  prot_autoc_read_generic - Hides MAC differences needed for AUTOC read
 *  @@hw: pointer to hardware structure
 *  @@reg_val: Value we read from AUTOC
 *
 *  The default case requires no protection so just to the register read.
 */
int32_t prot_autoc_read_generic(struct ixgbe_hw *hw, bool *locked,
				uint32_t *reg_val)
{
	*locked = FALSE;
	*reg_val = IXGBE_READ_REG(hw, IXGBE_AUTOC);
	return IXGBE_SUCCESS;
}

/**
 * prot_autoc_write_generic - Hides MAC differences needed for AUTOC write
 * @@hw: pointer to hardware structure
 * @@reg_val: value to write to AUTOC
 * @@locked: bool to indicate whether the SW/FW lock was already taken by
 *           previous read.
 *
 * The default case requires no protection so just to the register write.
 */
int32_t prot_autoc_write_generic(struct ixgbe_hw *hw, uint32_t reg_val,
				 bool locked)
{
	IXGBE_WRITE_REG(hw, IXGBE_AUTOC, reg_val);
	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_enable_sec_rx_path_generic - Enables the receive data path
 *  @@hw: pointer to hardware structure
 *
 *  Enables the receive data path.
 **/
int32_t ixgbe_enable_sec_rx_path_generic(struct ixgbe_hw *hw)
{
	int secrxreg;

	DEBUGFUNC("ixgbe_enable_sec_rx_path_generic");

	secrxreg = IXGBE_READ_REG(hw, IXGBE_SECRXCTRL);
	secrxreg &= ~IXGBE_SECRXCTRL_RX_DIS;
	IXGBE_WRITE_REG(hw, IXGBE_SECRXCTRL, secrxreg);
	IXGBE_WRITE_FLUSH(hw);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_enable_rx_dma_generic - Enable the Rx DMA unit
 *  @@hw: pointer to hardware structure
 *  @@regval: register value to write to RXCTRL
 *
 *  Enables the Rx DMA unit
 **/
int32_t ixgbe_enable_rx_dma_generic(struct ixgbe_hw *hw, uint32_t regval)
{
	DEBUGFUNC("ixgbe_enable_rx_dma_generic");

	if (regval & IXGBE_RXCTRL_RXEN)
		ixgbe_enable_rx(hw);
	else
		ixgbe_disable_rx(hw);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_blink_led_start_generic - Blink LED based on index.
 *  @@hw: pointer to hardware structure
 *  @@index: led number to blink
 **/
int32_t ixgbe_blink_led_start_generic(struct ixgbe_hw *hw, uint32_t index)
{
	ixgbe_link_speed speed = 0;
	bool link_up = 0;
	uint32_t autoc_reg = 0;
	uint32_t led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
	int32_t ret_val = IXGBE_SUCCESS;
	bool locked = FALSE;

	DEBUGFUNC("ixgbe_blink_led_start_generic");

	/*
	 * Link must be up to auto-blink the LEDs;
	 * Force it if link is down.
	 */
	hw->mac.ops.check_link(hw, &speed, &link_up, FALSE);

	if (!link_up) {
		ret_val = hw->mac.ops.prot_autoc_read(hw, &locked, &autoc_reg);
		if (ret_val != IXGBE_SUCCESS)
			goto out;

		autoc_reg |= IXGBE_AUTOC_AN_RESTART;
		autoc_reg |= IXGBE_AUTOC_FLU;

		ret_val = hw->mac.ops.prot_autoc_write(hw, autoc_reg, locked);
		if (ret_val != IXGBE_SUCCESS)
			goto out;

		IXGBE_WRITE_FLUSH(hw);
		msec_delay(10);
	}

	led_reg &= ~IXGBE_LED_MODE_MASK(index);
	led_reg |= IXGBE_LED_BLINK(index);
	IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
	IXGBE_WRITE_FLUSH(hw);

out:
	return ret_val;
}

/**
 *  ixgbe_blink_led_stop_generic - Stop blinking LED based on index.
 *  @@hw: pointer to hardware structure
 *  @@index: led number to stop blinking
 **/
int32_t ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw, uint32_t index)
{
	uint32_t autoc_reg = 0;
	uint32_t led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
	int32_t ret_val = IXGBE_SUCCESS;
	bool locked = FALSE;

	DEBUGFUNC("ixgbe_blink_led_stop_generic");

	ret_val = hw->mac.ops.prot_autoc_read(hw, &locked, &autoc_reg);
	if (ret_val != IXGBE_SUCCESS)
		goto out;

	autoc_reg &= ~IXGBE_AUTOC_FLU;
	autoc_reg |= IXGBE_AUTOC_AN_RESTART;

	ret_val = hw->mac.ops.prot_autoc_write(hw, autoc_reg, locked);
	if (ret_val != IXGBE_SUCCESS)
		goto out;

	led_reg &= ~IXGBE_LED_MODE_MASK(index);
	led_reg &= ~IXGBE_LED_BLINK(index);
	led_reg |= IXGBE_LED_LINK_ACTIVE << IXGBE_LED_MODE_SHIFT(index);
	IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
	IXGBE_WRITE_FLUSH(hw);

out:
	return ret_val;
}

/**
 *  ixgbe_get_pcie_msix_count_generic - Gets MSI-X vector count
 *  @@hw: pointer to hardware structure
 *
 *  Read PCIe configuration space, and get the MSI-X vector count from
 *  the capabilities table.
 **/
uint16_t ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw)
{
	uint16_t msix_count = 1;
	uint16_t max_msix_count;
	uint16_t pcie_offset;

	switch (hw->mac.type) {
	case ixgbe_mac_82598EB:
		pcie_offset = IXGBE_PCIE_MSIX_82598_CAPS;
		max_msix_count = IXGBE_MAX_MSIX_VECTORS_82598;
		break;
	case ixgbe_mac_82599EB:
	case ixgbe_mac_X540:
	case ixgbe_mac_X550:
	case ixgbe_mac_X550EM_x:
		pcie_offset = IXGBE_PCIE_MSIX_82599_CAPS;
		max_msix_count = IXGBE_MAX_MSIX_VECTORS_82599;
		break;
	default:
		return msix_count;
	}

	DEBUGFUNC("ixgbe_get_pcie_msix_count_generic");
	msix_count = IXGBE_READ_PCIE_WORD(hw, pcie_offset);
	msix_count &= IXGBE_PCIE_MSIX_TBL_SZ_MASK;

	/* MSI-X count is zero-based in HW */
	msix_count++;

	if (msix_count > max_msix_count)
		msix_count = max_msix_count;

	return msix_count;
}

/**
 *  ixgbe_insert_mac_addr_generic - Find a RAR for this mac address
 *  @@hw: pointer to hardware structure
 *  @@addr: Address to put into receive address register
 *  @@vmdq: VMDq pool to assign
 *
 *  Puts an ethernet address into a receive address register, or
 *  finds the rar that it is already in; adds to the pool list
 **/
int32_t ixgbe_insert_mac_addr_generic(struct ixgbe_hw *hw, uint8_t *addr, uint32_t vmdq)
{
	static const uint32_t NO_EMPTY_RAR_FOUND = 0xFFFFFFFF;
	uint32_t first_empty_rar = NO_EMPTY_RAR_FOUND;
	uint32_t rar;
	uint32_t rar_low, rar_high;
	uint32_t addr_low, addr_high;

	DEBUGFUNC("ixgbe_insert_mac_addr_generic");

	/* swap bytes for HW little endian */
	addr_low  = addr[0] | (addr[1] << 8)
			    | (addr[2] << 16)
			    | (addr[3] << 24);
	addr_high = addr[4] | (addr[5] << 8);

	/*
	 * Either find the mac_id in rar or find the first empty space.
	 * rar_highwater points to just after the highest currently used
	 * rar in order to shorten the search.  It grows when we add a new
	 * rar to the top.
	 */
	for (rar = 0; rar < hw->mac.rar_highwater; rar++) {
		rar_high = IXGBE_READ_REG(hw, IXGBE_RAH(rar));

		if (((IXGBE_RAH_AV & rar_high) == 0)
		    && first_empty_rar == NO_EMPTY_RAR_FOUND) {
			first_empty_rar = rar;
		} else if ((rar_high & 0xFFFF) == addr_high) {
			rar_low = IXGBE_READ_REG(hw, IXGBE_RAL(rar));
			if (rar_low == addr_low)
				break;    /* found it already in the rars */
		}
	}

	if (rar < hw->mac.rar_highwater) {
		/* already there so just add to the pool bits */
		ixgbe_set_vmdq(hw, rar, vmdq);
	} else if (first_empty_rar != NO_EMPTY_RAR_FOUND) {
		/* stick it into first empty RAR slot we found */
		rar = first_empty_rar;
		ixgbe_set_rar(hw, rar, addr, vmdq, IXGBE_RAH_AV);
	} else if (rar == hw->mac.rar_highwater) {
		/* add it to the top of the list and inc the highwater mark */
		ixgbe_set_rar(hw, rar, addr, vmdq, IXGBE_RAH_AV);
		hw->mac.rar_highwater++;
	} else if (rar >= hw->mac.num_rar_entries) {
		return IXGBE_ERR_INVALID_MAC_ADDR;
	}

	/*
	 * If we found rar[0], make sure the default pool bit (we use pool 0)
	 * remains cleared to be sure default pool packets will get delivered
	 */
	if (rar == 0)
		ixgbe_clear_vmdq(hw, rar, 0);

	return rar;
}

/**
 *  ixgbe_clear_vmdq_generic - Disassociate a VMDq pool index from a rx address
 *  @@hw: pointer to hardware struct
 *  @@rar: receive address register index to disassociate
 *  @@vmdq: VMDq pool index to remove from the rar
 **/
int32_t ixgbe_clear_vmdq_generic(struct ixgbe_hw *hw, uint32_t rar, uint32_t vmdq)
{
	uint32_t mpsar_lo, mpsar_hi;
	uint32_t rar_entries = hw->mac.num_rar_entries;

	DEBUGFUNC("ixgbe_clear_vmdq_generic");

	/* Make sure we are using a valid rar index range */
	if (rar >= rar_entries) {
		ERROR_REPORT2(IXGBE_ERROR_ARGUMENT,
			     "RAR index %d is out of range.\n", rar);
		return IXGBE_ERR_INVALID_ARGUMENT;
	}

	mpsar_lo = IXGBE_READ_REG(hw, IXGBE_MPSAR_LO(rar));
	mpsar_hi = IXGBE_READ_REG(hw, IXGBE_MPSAR_HI(rar));

	if (!mpsar_lo && !mpsar_hi)
		goto done;

	if (vmdq == IXGBE_CLEAR_VMDQ_ALL) {
		if (mpsar_lo) {
			IXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), 0);
			mpsar_lo = 0;
		}
		if (mpsar_hi) {
			IXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), 0);
			mpsar_hi = 0;
		}
	} else if (vmdq < 32) {
		mpsar_lo &= ~(1 << vmdq);
		IXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), mpsar_lo);
	} else {
		mpsar_hi &= ~(1 << (vmdq - 32));
		IXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), mpsar_hi);
	}

	/* was that the last pool using this rar? */
	if (mpsar_lo == 0 && mpsar_hi == 0 && rar != 0)
		hw->mac.ops.clear_rar(hw, rar);
done:
	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_set_vmdq_generic - Associate a VMDq pool index with a rx address
 *  @@hw: pointer to hardware struct
 *  @@rar: receive address register index to associate with a VMDq index
 *  @@vmdq: VMDq pool index
 **/
int32_t ixgbe_set_vmdq_generic(struct ixgbe_hw *hw, uint32_t rar, uint32_t vmdq)
{
	uint32_t mpsar;
	uint32_t rar_entries = hw->mac.num_rar_entries;

	DEBUGFUNC("ixgbe_set_vmdq_generic");

	/* Make sure we are using a valid rar index range */
	if (rar >= rar_entries) {
		ERROR_REPORT2(IXGBE_ERROR_ARGUMENT,
			     "RAR index %d is out of range.\n", rar);
		return IXGBE_ERR_INVALID_ARGUMENT;
	}

	if (vmdq < 32) {
		mpsar = IXGBE_READ_REG(hw, IXGBE_MPSAR_LO(rar));
		mpsar |= 1 << vmdq;
		IXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), mpsar);
	} else {
		mpsar = IXGBE_READ_REG(hw, IXGBE_MPSAR_HI(rar));
		mpsar |= 1 << (vmdq - 32);
		IXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), mpsar);
	}
	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_init_uta_tables_generic - Initialize the Unicast Table Array
 *  @@hw: pointer to hardware structure
 **/
int32_t ixgbe_init_uta_tables_generic(struct ixgbe_hw *hw)
{
	int i;

	DEBUGFUNC("ixgbe_init_uta_tables_generic");
	DEBUGOUT(" Clearing UTA\n");

	for (i = 0; i < 128; i++)
		IXGBE_WRITE_REG(hw, IXGBE_UTA(i), 0);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_find_vlvf_slot - find the vlanid or the first empty slot
 *  @@hw: pointer to hardware structure
 *  @@vlan: VLAN id to write to VLAN filter
 *
 *  return the VLVF index where this VLAN id should be placed
 *
 **/
int32_t ixgbe_find_vlvf_slot(struct ixgbe_hw *hw, uint32_t vlan)
{
	uint32_t bits = 0;
	uint32_t first_empty_slot = 0;
	int32_t regindex;

	/* short cut the special case */
	if (vlan == 0)
		return 0;

	/*
	  * Search for the vlan id in the VLVF entries. Save off the first empty
	  * slot found along the way
	  */
	for (regindex = 1; regindex < IXGBE_VLVF_ENTRIES; regindex++) {
		bits = IXGBE_READ_REG(hw, IXGBE_VLVF(regindex));
		if (!bits && !(first_empty_slot))
			first_empty_slot = regindex;
		else if ((bits & 0x0FFF) == vlan)
			break;
	}

	/*
	  * If regindex is less than IXGBE_VLVF_ENTRIES, then we found the vlan
	  * in the VLVF. Else use the first empty VLVF register for this
	  * vlan id.
	  */
	if (regindex >= IXGBE_VLVF_ENTRIES) {
		if (first_empty_slot)
			regindex = first_empty_slot;
		else {
			ERROR_REPORT1(IXGBE_ERROR_SOFTWARE,
				     "No space in VLVF.\n");
			regindex = IXGBE_ERR_NO_SPACE;
		}
	}

	return regindex;
}

/**
 *  ixgbe_set_vfta_generic - Set VLAN filter table
 *  @@hw: pointer to hardware structure
 *  @@vlan: VLAN id to write to VLAN filter
 *  @@vind: VMDq output index that maps queue to VLAN id in VFVFB
 *  @@vlan_on: boolean flag to turn on/off VLAN in VFVF
 *
 *  Turn on/off specified VLAN in the VLAN filter table.
 **/
int32_t ixgbe_set_vfta_generic(struct ixgbe_hw *hw, uint32_t vlan, uint32_t vind,
			       bool vlan_on)
{
	int32_t regindex;
	uint32_t bitindex;
	uint32_t vfta;
	uint32_t targetbit;
	int32_t ret_val = IXGBE_SUCCESS;
	bool vfta_changed = FALSE;

	DEBUGFUNC("ixgbe_set_vfta_generic");

	if (vlan > 4095)
		return IXGBE_ERR_PARAM;

	/*
	 * this is a 2 part operation - first the VFTA, then the
	 * VLVF and VLVFB if VT Mode is set
	 * We don't write the VFTA until we know the VLVF part succeeded.
	 */

	/* Part 1
	 * The VFTA is a bitstring made up of 128 32-bit registers
	 * that enable the particular VLAN id, much like the MTA:
	 *    bits[11-5]: which register
	 *    bits[4-0]:  which bit in the register
	 */
	regindex = (vlan >> 5) & 0x7F;
	bitindex = vlan & 0x1F;
	targetbit = (1 << bitindex);
	vfta = IXGBE_READ_REG(hw, IXGBE_VFTA(regindex));

	if (vlan_on) {
		if (!(vfta & targetbit)) {
			vfta |= targetbit;
			vfta_changed = TRUE;
		}
	} else {
		if ((vfta & targetbit)) {
			vfta &= ~targetbit;
			vfta_changed = TRUE;
		}
	}

	/* Part 2
	 * Call ixgbe_set_vlvf_generic to set VLVFB and VLVF
	 */
	ret_val = ixgbe_set_vlvf_generic(hw, vlan, vind, vlan_on,
					 &vfta_changed);
	if (ret_val != IXGBE_SUCCESS)
		return ret_val;

	if (vfta_changed)
		IXGBE_WRITE_REG(hw, IXGBE_VFTA(regindex), vfta);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_set_vlvf_generic - Set VLAN Pool Filter
 *  @@hw: pointer to hardware structure
 *  @@vlan: VLAN id to write to VLAN filter
 *  @@vind: VMDq output index that maps queue to VLAN id in VFVFB
 *  @@vlan_on: boolean flag to turn on/off VLAN in VFVF
 *  @@vfta_changed: pointer to boolean flag which indicates whether VFTA
 *                 should be changed
 *
 *  Turn on/off specified bit in VLVF table.
 **/
int32_t ixgbe_set_vlvf_generic(struct ixgbe_hw *hw, uint32_t vlan, uint32_t vind,
			       bool vlan_on, bool *vfta_changed)
{
	uint32_t vt;

	DEBUGFUNC("ixgbe_set_vlvf_generic");

	if (vlan > 4095)
		return IXGBE_ERR_PARAM;

	/* If VT Mode is set
	 *   Either vlan_on
	 *     make sure the vlan is in VLVF
	 *     set the vind bit in the matching VLVFB
	 *   Or !vlan_on
	 *     clear the pool bit and possibly the vind
	 */
	vt = IXGBE_READ_REG(hw, IXGBE_VT_CTL);
	if (vt & IXGBE_VT_CTL_VT_ENABLE) {
		int32_t vlvf_index;
		uint32_t bits;

		vlvf_index = ixgbe_find_vlvf_slot(hw, vlan);
		if (vlvf_index < 0)
			return vlvf_index;

		if (vlan_on) {
			/* set the pool bit */
			if (vind < 32) {
				bits = IXGBE_READ_REG(hw,
						IXGBE_VLVFB(vlvf_index * 2));
				bits |= (1 << vind);
				IXGBE_WRITE_REG(hw,
						IXGBE_VLVFB(vlvf_index * 2),
						bits);
			} else {
				bits = IXGBE_READ_REG(hw,
					IXGBE_VLVFB((vlvf_index * 2) + 1));
				bits |= (1 << (vind - 32));
				IXGBE_WRITE_REG(hw,
					IXGBE_VLVFB((vlvf_index * 2) + 1),
					bits);
			}
		} else {
			/* clear the pool bit */
			if (vind < 32) {
				bits = IXGBE_READ_REG(hw,
						IXGBE_VLVFB(vlvf_index * 2));
				bits &= ~(1 << vind);
				IXGBE_WRITE_REG(hw,
						IXGBE_VLVFB(vlvf_index * 2),
						bits);
				bits |= IXGBE_READ_REG(hw,
					IXGBE_VLVFB((vlvf_index * 2) + 1));
			} else {
				bits = IXGBE_READ_REG(hw,
					IXGBE_VLVFB((vlvf_index * 2) + 1));
				bits &= ~(1 << (vind - 32));
				IXGBE_WRITE_REG(hw,
					IXGBE_VLVFB((vlvf_index * 2) + 1),
					bits);
				bits |= IXGBE_READ_REG(hw,
						IXGBE_VLVFB(vlvf_index * 2));
			}
		}

		/*
		 * If there are still bits set in the VLVFB registers
		 * for the VLAN ID indicated we need to see if the
		 * caller is requesting that we clear the VFTA entry bit.
		 * If the caller has requested that we clear the VFTA
		 * entry bit but there are still pools/VFs using this VLAN
		 * ID entry then ignore the request.  We're not worried
		 * about the case where we're turning the VFTA VLAN ID
		 * entry bit on, only when requested to turn it off as
		 * there may be multiple pools and/or VFs using the
		 * VLAN ID entry.  In that case we cannot clear the
		 * VFTA bit until all pools/VFs using that VLAN ID have also
		 * been cleared.  This will be indicated by "bits" being
		 * zero.
		 */
		if (bits) {
			IXGBE_WRITE_REG(hw, IXGBE_VLVF(vlvf_index),
					(IXGBE_VLVF_VIEN | vlan));
			if ((!vlan_on) && (vfta_changed != NULL)) {
				/* someone wants to clear the vfta entry
				 * but some pools/VFs are still using it.
				 * Ignore it. */
				*vfta_changed = FALSE;
			}
		} else
			IXGBE_WRITE_REG(hw, IXGBE_VLVF(vlvf_index), 0);
	}

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_clear_vfta_generic - Clear VLAN filter table
 *  @@hw: pointer to hardware structure
 *
 *  Clears the VLAN filer table, and the VMDq index associated with the filter
 **/
int32_t ixgbe_clear_vfta_generic(struct ixgbe_hw *hw)
{
	uint32_t offset;

	DEBUGFUNC("ixgbe_clear_vfta_generic");

	for (offset = 0; offset < hw->mac.vft_size; offset++)
		IXGBE_WRITE_REG(hw, IXGBE_VFTA(offset), 0);

	for (offset = 0; offset < IXGBE_VLVF_ENTRIES; offset++) {
		IXGBE_WRITE_REG(hw, IXGBE_VLVF(offset), 0);
		IXGBE_WRITE_REG(hw, IXGBE_VLVFB(offset * 2), 0);
		IXGBE_WRITE_REG(hw, IXGBE_VLVFB((offset * 2) + 1), 0);
	}

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_check_mac_link_generic - Determine link and speed status
 *  @@hw: pointer to hardware structure
 *  @@speed: pointer to link speed
 *  @@link_up: TRUE when link is up
 *  @@link_up_wait_to_complete: bool used to wait for link up or not
 *
 *  Reads the links register to determine if link is up and the current speed
 **/
int32_t ixgbe_check_mac_link_generic(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
				     bool *link_up, bool link_up_wait_to_complete)
{
	uint32_t links_reg, links_orig;
	uint32_t i;

	DEBUGFUNC("ixgbe_check_mac_link_generic");

	/* clear the old state */
	links_orig = IXGBE_READ_REG(hw, IXGBE_LINKS);

	links_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);

	if (links_orig != links_reg) {
		DEBUGOUT2("LINKS changed from %08X to %08X\n",
			  links_orig, links_reg);
	}

	if (link_up_wait_to_complete) {
		for (i = 0; i < hw->mac.max_link_up_time; i++) {
			if (links_reg & IXGBE_LINKS_UP) {
				*link_up = TRUE;
				break;
			} else {
				*link_up = FALSE;
			}
			msec_delay(100);
			links_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);
		}
	} else {
		if (links_reg & IXGBE_LINKS_UP)
			*link_up = TRUE;
		else
			*link_up = FALSE;
	}

	switch (links_reg & IXGBE_LINKS_SPEED_82599) {
	case IXGBE_LINKS_SPEED_10G_82599:
		*speed = IXGBE_LINK_SPEED_10GB_FULL;
		if (hw->mac.type >= ixgbe_mac_X550) {
			if (links_reg & IXGBE_LINKS_SPEED_NON_STD)
				*speed = IXGBE_LINK_SPEED_2_5GB_FULL;
		}
		break;
	case IXGBE_LINKS_SPEED_1G_82599:
		*speed = IXGBE_LINK_SPEED_1GB_FULL;
		break;
	case IXGBE_LINKS_SPEED_100_82599:
		*speed = IXGBE_LINK_SPEED_100_FULL;
		if (hw->mac.type >= ixgbe_mac_X550) {
			if (links_reg & IXGBE_LINKS_SPEED_NON_STD)
				*speed = IXGBE_LINK_SPEED_5GB_FULL;
		}
		break;
	default:
		*speed = IXGBE_LINK_SPEED_UNKNOWN;
	}

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_get_device_caps_generic - Get additional device capabilities
 *  @@hw: pointer to hardware structure
 *  @@device_caps: the EEPROM word with the extra device capabilities
 *
 *  This function will read the EEPROM location for the device capabilities,
 *  and return the word through device_caps.
 **/
int32_t ixgbe_get_device_caps_generic(struct ixgbe_hw *hw, uint16_t *device_caps)
{
	DEBUGFUNC("ixgbe_get_device_caps_generic");

	hw->eeprom.ops.read(hw, IXGBE_DEVICE_CAPS, device_caps);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_host_interface_command - Issue command to manageability block
 *  @@hw: pointer to the HW structure
 *  @@buffer: contains the command to write and where the return status will
 *   be placed
 *  @@length: length of buffer, must be multiple of 4 bytes
 *  @@timeout: time in ms to wait for command completion
 *  @@return_data: read and return data from the buffer (TRUE) or not (FALSE)
 *   Needed because FW structures are big endian and decoding of
 *   these fields can be 8 bit or 16 bit based on command. Decoding
 *   is not easily understood without making a table of commands.
 *   So we will leave this up to the caller to read back the data
 *   in these cases.
 *
 *  Communicates with the manageability block.  On success return IXGBE_SUCCESS
 *  else return IXGBE_ERR_HOST_INTERFACE_COMMAND.
 **/
int32_t ixgbe_host_interface_command(struct ixgbe_hw *hw, uint32_t *buffer,
				     uint32_t length, uint32_t timeout,
				     bool return_data)
{
	uint32_t hicr, i, bi, fwsts;
	uint32_t hdr_size = sizeof(struct ixgbe_hic_hdr);
	uint16_t buf_len;
	uint16_t dword_len;

	DEBUGFUNC("ixgbe_host_interface_command");

	if (length == 0 || length > IXGBE_HI_MAX_BLOCK_BYTE_LENGTH) {
		DEBUGOUT1("Buffer length failure buffersize=%d.\n", length);
		return IXGBE_ERR_HOST_INTERFACE_COMMAND;
	}
	/* Set bit 9 of FWSTS clearing FW reset indication */
	fwsts = IXGBE_READ_REG(hw, IXGBE_FWSTS);
	IXGBE_WRITE_REG(hw, IXGBE_FWSTS, fwsts | IXGBE_FWSTS_FWRI);

	/* Check that the host interface is enabled. */
	hicr = IXGBE_READ_REG(hw, IXGBE_HICR);
	if ((hicr & IXGBE_HICR_EN) == 0) {
		DEBUGOUT("IXGBE_HOST_EN bit disabled.\n");
		return IXGBE_ERR_HOST_INTERFACE_COMMAND;
	}

	/* Calculate length in DWORDs. We must be DWORD aligned */
	if ((length % (sizeof(uint32_t))) != 0) {
		DEBUGOUT("Buffer length failure, not aligned to dword");
		return IXGBE_ERR_INVALID_ARGUMENT;
	}

	dword_len = length >> 2;

	/* The device driver writes the relevant command block
	 * into the ram area.
	 */
	for (i = 0; i < dword_len; i++)
		IXGBE_WRITE_REG_ARRAY(hw, IXGBE_FLEX_MNG,
				      i, htole32(buffer[i]));

	/* Setting this bit tells the ARC that a new command is pending. */
	IXGBE_WRITE_REG(hw, IXGBE_HICR, hicr | IXGBE_HICR_C);

	for (i = 0; i < timeout; i++) {
		hicr = IXGBE_READ_REG(hw, IXGBE_HICR);
		if (!(hicr & IXGBE_HICR_C))
			break;
		msec_delay(1);
	}

	/* Check command completion */
	if ((timeout != 0 && i == timeout) ||
	    !(IXGBE_READ_REG(hw, IXGBE_HICR) & IXGBE_HICR_SV)) {
		DEBUGOUT("Command has failed with no status valid.\n");
		return IXGBE_ERR_HOST_INTERFACE_COMMAND;
	}

	if (!return_data)
		return 0;

	/* Calculate length in DWORDs */
	dword_len = hdr_size >> 2;

	/* first pull in the header so we know the buffer length */
	for (bi = 0; bi < dword_len; bi++) {
		buffer[bi] = letoh32(IXGBE_READ_REG_ARRAY(hw,
		    IXGBE_FLEX_MNG, bi));
	}

	/* If there is any thing in data position pull it in */
	buf_len = ((struct ixgbe_hic_hdr *)buffer)->buf_len;
	if (buf_len == 0)
		return 0;

	if (length < buf_len + hdr_size) {
		DEBUGOUT("Buffer not large enough for reply message.\n");
		return IXGBE_ERR_HOST_INTERFACE_COMMAND;
	}

	/* Calculate length in DWORDs, add 3 for odd lengths */
	dword_len = (buf_len + 3) >> 2;

	/* Pull in the rest of the buffer (bi is where we left off) */
	for (; bi <= dword_len; bi++) {
		buffer[bi] = letoh32(IXGBE_READ_REG_ARRAY(hw,
		    IXGBE_FLEX_MNG, bi));
	}

	return 0;
}

/**
 * ixgbe_clear_tx_pending - Clear pending TX work from the PCIe fifo
 * @@hw: pointer to the hardware structure
 *
 * The 82599 and x540 MACs can experience issues if TX work is still pending
 * when a reset occurs.  This function prevents this by flushing the PCIe
 * buffers on the system.
 **/
void ixgbe_clear_tx_pending(struct ixgbe_hw *hw)
{
	uint32_t gcr_ext, hlreg0, i, poll;
	uint16_t value;

	/*
	 * If double reset is not requested then all transactions should
	 * already be clear and as such there is no work to do
	 */
	if (!(hw->mac.flags & IXGBE_FLAGS_DOUBLE_RESET_REQUIRED))
		return;

	/*
	 * Set loopback enable to prevent any transmits from being sent
	 * should the link come up.  This assumes that the RXCTRL.RXEN bit
	 * has already been cleared.
	 */
	hlreg0 = IXGBE_READ_REG(hw, IXGBE_HLREG0);
	IXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0 | IXGBE_HLREG0_LPBK);

	/* Wait for a last completion before clearing buffers */
	IXGBE_WRITE_FLUSH(hw);
	msec_delay(3);

	/*
	 * Before proceeding, make sure that the PCIe block does not have
	 * transactions pending.
	 */
	poll = ixgbe_pcie_timeout_poll(hw);
	for (i = 0; i < poll; i++) {
		usec_delay(100);
		value = IXGBE_READ_PCIE_WORD(hw, IXGBE_PCI_DEVICE_STATUS);
		if (!(value & IXGBE_PCI_DEVICE_STATUS_TRANSACTION_PENDING))
			goto out;
	}

out:
	/* initiate cleaning flow for buffers in the PCIe transaction layer */
	gcr_ext = IXGBE_READ_REG(hw, IXGBE_GCR_EXT);
	IXGBE_WRITE_REG(hw, IXGBE_GCR_EXT,
			gcr_ext | IXGBE_GCR_EXT_BUFFERS_CLEAR);

	/* Flush all writes and allow 20usec for all transactions to clear */
	IXGBE_WRITE_FLUSH(hw);
	usec_delay(20);

	/* restore previous register values */
	IXGBE_WRITE_REG(hw, IXGBE_GCR_EXT, gcr_ext);
	IXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0);
}

void ixgbe_disable_rx_generic(struct ixgbe_hw *hw)
{
	uint32_t rxctrl;

	rxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
	if (rxctrl & IXGBE_RXCTRL_RXEN) {
		rxctrl &= ~IXGBE_RXCTRL_RXEN;
		IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, rxctrl);
	}
}

void ixgbe_enable_rx_generic(struct ixgbe_hw *hw)
{
	uint32_t rxctrl;

	rxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
	IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, (rxctrl | IXGBE_RXCTRL_RXEN));
}

/**
 * ixgbe_mng_present - returns TRUE when management capability is present
 * @@hw: pointer to hardware structure
 */
bool ixgbe_mng_present(struct ixgbe_hw *hw)
{
	uint32_t fwsm;

	if (hw->mac.type < ixgbe_mac_82599EB)
		return FALSE;

	fwsm = IXGBE_READ_REG(hw, IXGBE_FWSM);
	fwsm &= IXGBE_FWSM_MODE_MASK;
	return fwsm == IXGBE_FWSM_FW_MODE_PT;
}

/**
 * ixgbe_mng_enabled - Is the manageability engine enabled?
 * @@hw: pointer to hardware structure
 *
 * Returns TRUE if the manageability engine is enabled.
 **/
bool ixgbe_mng_enabled(struct ixgbe_hw *hw)
{
	uint32_t fwsm, manc, factps;

	fwsm = IXGBE_READ_REG(hw, IXGBE_FWSM);
	if ((fwsm & IXGBE_FWSM_MODE_MASK) != IXGBE_FWSM_FW_MODE_PT)
		return FALSE;

	manc = IXGBE_READ_REG(hw, IXGBE_MANC);
	if (!(manc & IXGBE_MANC_RCV_TCO_EN))
		return FALSE;

	if (hw->mac.type <= ixgbe_mac_X540) {
		factps = IXGBE_READ_REG(hw, IXGBE_FACTPS);
		if (factps & IXGBE_FACTPS_MNGCG)
			return FALSE;
	}

	return TRUE;
}

/**
 *  ixgbe_setup_mac_link_multispeed_fiber - Set MAC link speed
 *  @@hw: pointer to hardware structure
 *  @@speed: new link speed
 *  @@autoneg_wait_to_complete: TRUE when waiting for completion is needed
 *
 *  Set the link speed in the MAC and/or PHY register and restarts link.
 **/
int32_t ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw,
					      ixgbe_link_speed speed,
					      bool autoneg_wait_to_complete)
{
	ixgbe_link_speed link_speed = IXGBE_LINK_SPEED_UNKNOWN;
	ixgbe_link_speed highest_link_speed = IXGBE_LINK_SPEED_UNKNOWN;
	int32_t status = IXGBE_SUCCESS;
	uint32_t speedcnt = 0;
	uint32_t i = 0;
	bool autoneg, link_up = FALSE;

	DEBUGFUNC("ixgbe_setup_mac_link_multispeed_fiber");

	/* Mask off requested but non-supported speeds */
	if (!hw->mac.ops.get_link_capabilities)
		return IXGBE_NOT_IMPLEMENTED;
	status = hw->mac.ops.get_link_capabilities(hw, &link_speed, &autoneg);
	if (status != IXGBE_SUCCESS)
		return status;

	speed &= link_speed;

	/* Try each speed one by one, highest priority first.  We do this in
	 * software because 10Gb fiber doesn't support speed autonegotiation.
	 */
	if (speed & IXGBE_LINK_SPEED_10GB_FULL) {
		speedcnt++;
		highest_link_speed = IXGBE_LINK_SPEED_10GB_FULL;

		/* If we already have link at this speed, just jump out */
		status = ixgbe_check_link(hw, &link_speed, &link_up, FALSE);
		if (status != IXGBE_SUCCESS)
			return status;

		if ((link_speed == IXGBE_LINK_SPEED_10GB_FULL) && link_up)
			goto out;

		/* Set the module link speed */
		switch (hw->phy.media_type) {
		case ixgbe_media_type_fiber_fixed:
		case ixgbe_media_type_fiber:
			if (hw->mac.ops.set_rate_select_speed)
				hw->mac.ops.set_rate_select_speed(hw,
				    IXGBE_LINK_SPEED_10GB_FULL);
			break;
		case ixgbe_media_type_fiber_qsfp:
			/* QSFP module automatically detects MAC link speed */
			break;
		default:
			DEBUGOUT("Unexpected media type.\n");
			break;
		}

		/* Allow module to change analog characteristics (1G->10G) */
		msec_delay(40);

		if (!hw->mac.ops.setup_mac_link)
			return IXGBE_NOT_IMPLEMENTED;
		status = hw->mac.ops.setup_mac_link(hw,
						    IXGBE_LINK_SPEED_10GB_FULL,
						    autoneg_wait_to_complete);
		if (status != IXGBE_SUCCESS)
			return status;

		/* Flap the Tx laser if it has not already been done */
		ixgbe_flap_tx_laser(hw);

		/* Wait for the controller to acquire link.  Per IEEE 802.3ap,
		 * Section 73.10.2, we may have to wait up to 500ms if KR is
		 * attempted.  82599 uses the same timing for 10g SFI.
		 */
		for (i = 0; i < 5; i++) {
			/* Wait for the link partner to also set speed */
			msec_delay(100);

			/* If we have link, just jump out */
			status = ixgbe_check_link(hw, &link_speed,
						  &link_up, FALSE);
			if (status != IXGBE_SUCCESS)
				return status;

			if (link_up)
				goto out;
		}
	}

	if (speed & IXGBE_LINK_SPEED_1GB_FULL) {
		speedcnt++;
		if (highest_link_speed == IXGBE_LINK_SPEED_UNKNOWN)
			highest_link_speed = IXGBE_LINK_SPEED_1GB_FULL;

		/* If we already have link at this speed, just jump out */
		status = ixgbe_check_link(hw, &link_speed, &link_up, FALSE);
		if (status != IXGBE_SUCCESS)
			return status;

		if ((link_speed == IXGBE_LINK_SPEED_1GB_FULL) && link_up)
			goto out;

		/* Set the module link speed */
		switch (hw->phy.media_type) {
		case ixgbe_media_type_fiber_fixed:
		case ixgbe_media_type_fiber:
			if (hw->mac.ops.set_rate_select_speed)
				hw->mac.ops.set_rate_select_speed(hw,
				    IXGBE_LINK_SPEED_1GB_FULL);
			break;
		case ixgbe_media_type_fiber_qsfp:
			/* QSFP module automatically detects link speed */
			break;
		default:
			DEBUGOUT("Unexpected media type.\n");
			break;
		}

		/* Allow module to change analog characteristics (10G->1G) */
		msec_delay(40);

		if (!hw->mac.ops.setup_mac_link)
			return IXGBE_NOT_IMPLEMENTED;
		status = hw->mac.ops.setup_mac_link(hw,
						    IXGBE_LINK_SPEED_1GB_FULL,
						    autoneg_wait_to_complete);
		if (status != IXGBE_SUCCESS)
			return status;

		/* Flap the Tx laser if it has not already been done */
		ixgbe_flap_tx_laser(hw);

		/* Wait for the link partner to also set speed */
		msec_delay(100);

		/* If we have link, just jump out */
		status = ixgbe_check_link(hw, &link_speed, &link_up, FALSE);
		if (status != IXGBE_SUCCESS)
			return status;

		if (link_up)
			goto out;
	}

	/* We didn't get link.  Configure back to the highest speed we tried,
	 * (if there was more than one).  We call ourselves back with just the
	 * single highest speed that the user requested.
	 */
	if (speedcnt > 1)
		status = ixgbe_setup_mac_link_multispeed_fiber(hw,
						      highest_link_speed,
						      autoneg_wait_to_complete);

out:
	/* Set autoneg_advertised value based on input link speed */
	hw->phy.autoneg_advertised = 0;

	if (speed & IXGBE_LINK_SPEED_10GB_FULL)
		hw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_10GB_FULL;

	if (speed & IXGBE_LINK_SPEED_1GB_FULL)
		hw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_1GB_FULL;

	return status;
}

/**
 *  ixgbe_set_soft_rate_select_speed - Set module link speed
 *  @@hw: pointer to hardware structure
 *  @@speed: link speed to set
 *
 *  Set module link speed via the soft rate select.
 */
void ixgbe_set_soft_rate_select_speed(struct ixgbe_hw *hw,
					ixgbe_link_speed speed)
{
	int32_t status;
	uint8_t rs, eeprom_data;

	switch (speed) {
	case IXGBE_LINK_SPEED_10GB_FULL:
		/* one bit mask same as setting on */
		rs = IXGBE_SFF_SOFT_RS_SELECT_10G;
		break;
	case IXGBE_LINK_SPEED_1GB_FULL:
		rs = IXGBE_SFF_SOFT_RS_SELECT_1G;
		break;
	default:
		DEBUGOUT("Invalid fixed module speed\n");
		return;
	}

	/* Set RS0 */
	status = hw->phy.ops.read_i2c_byte(hw, IXGBE_SFF_SFF_8472_OSCB,
					   IXGBE_I2C_EEPROM_DEV_ADDR2,
					   &eeprom_data);
	if (status) {
		DEBUGOUT("Failed to read Rx Rate Select RS0\n");
		goto out;
	}

	eeprom_data = (eeprom_data & ~IXGBE_SFF_SOFT_RS_SELECT_MASK) | rs;

	status = hw->phy.ops.write_i2c_byte(hw, IXGBE_SFF_SFF_8472_OSCB,
					    IXGBE_I2C_EEPROM_DEV_ADDR2,
					    eeprom_data);
	if (status) {
		DEBUGOUT("Failed to write Rx Rate Select RS0\n");
		goto out;
	}

	/* Set RS1 */
	status = hw->phy.ops.read_i2c_byte(hw, IXGBE_SFF_SFF_8472_ESCB,
					   IXGBE_I2C_EEPROM_DEV_ADDR2,
					   &eeprom_data);
	if (status) {
		DEBUGOUT("Failed to read Rx Rate Select RS1\n");
		goto out;
	}

	eeprom_data = (eeprom_data & ~IXGBE_SFF_SOFT_RS_SELECT_MASK) | rs;

	status = hw->phy.ops.write_i2c_byte(hw, IXGBE_SFF_SFF_8472_ESCB,
					    IXGBE_I2C_EEPROM_DEV_ADDR2,
					    eeprom_data);
	if (status) {
		DEBUGOUT("Failed to write Rx Rate Select RS1\n");
		goto out;
	}
out:
	return;
}

/* MAC Operations */

/**
 *  ixgbe_init_shared_code - Initialize the shared code
 *  @@hw: pointer to hardware structure
 *
 *  This will assign function pointers and assign the MAC type and PHY code.
 *  Does not touch the hardware. This function must be called prior to any
 *  other function in the shared code. The ixgbe_hw structure should be
 *  memset to 0 prior to calling this function.  The following fields in
 *  hw structure should be filled in prior to calling this function:
 *  hw_addr, back, device_id, vendor_id, subsystem_device_id,
 *  subsystem_vendor_id, and revision_id
 **/
int32_t ixgbe_init_shared_code(struct ixgbe_hw *hw)
{
	int32_t status;

	DEBUGFUNC("ixgbe_init_shared_code");

	/*
	 * Set the mac type
	 */
	ixgbe_set_mac_type(hw);

	switch (hw->mac.type) {
	case ixgbe_mac_82598EB:
		status = ixgbe_init_ops_82598(hw);
		break;
	case ixgbe_mac_82599EB:
		status = ixgbe_init_ops_82599(hw);
		break;
	case ixgbe_mac_X540:
		status = ixgbe_init_ops_X540(hw);
		break;
	case ixgbe_mac_X550:
		status = ixgbe_init_ops_X550(hw);
		break;
	case ixgbe_mac_X550EM_x:
		status = ixgbe_init_ops_X550EM(hw);
		break;
	default:
		status = IXGBE_ERR_DEVICE_NOT_SUPPORTED;
		break;
	}
	hw->mac.max_link_up_time = IXGBE_LINK_UP_TIME;

	return status;
}

/**
 *  ixgbe_set_mac_type - Sets MAC type
 *  @@hw: pointer to the HW structure
 *
 *  This function sets the mac type of the adapter based on the
 *  vendor ID and device ID stored in the hw structure.
 **/
int32_t ixgbe_set_mac_type(struct ixgbe_hw *hw)
{
	int32_t ret_val = IXGBE_SUCCESS;

	DEBUGFUNC("ixgbe_set_mac_type\n");

	if (hw->vendor_id != IXGBE_INTEL_VENDOR_ID)
		return IXGBE_ERR_DEVICE_NOT_SUPPORTED;

	switch (hw->device_id) {
	case IXGBE_DEV_ID_82598:
	case IXGBE_DEV_ID_82598_BX:
	case IXGBE_DEV_ID_82598AF_SINGLE_PORT:
	case IXGBE_DEV_ID_82598AF_DUAL_PORT:
	case IXGBE_DEV_ID_82598AT:
	case IXGBE_DEV_ID_82598AT2:
	case IXGBE_DEV_ID_82598AT_DUAL_PORT:
	case IXGBE_DEV_ID_82598EB_CX4:
	case IXGBE_DEV_ID_82598_CX4_DUAL_PORT:
	case IXGBE_DEV_ID_82598_DA_DUAL_PORT:
	case IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM:
	case IXGBE_DEV_ID_82598EB_XF_LR:
	case IXGBE_DEV_ID_82598EB_SFP_LOM:
		hw->mac.type = ixgbe_mac_82598EB;
		break;
	case IXGBE_DEV_ID_82599_KX4:
	case IXGBE_DEV_ID_82599_KX4_MEZZ:
	case IXGBE_DEV_ID_82599_XAUI_LOM:
	case IXGBE_DEV_ID_82599_COMBO_BACKPLANE:
	case IXGBE_DEV_ID_82599_KR:
	case IXGBE_DEV_ID_82599_SFP:
	case IXGBE_DEV_ID_82599_BACKPLANE_FCOE:
	case IXGBE_DEV_ID_82599_SFP_FCOE:
	case IXGBE_DEV_ID_82599_SFP_EM:
	case IXGBE_DEV_ID_82599_SFP_SF2:
	case IXGBE_DEV_ID_82599_SFP_SF_QP:
	case IXGBE_DEV_ID_82599_QSFP_SF_QP:
	case IXGBE_DEV_ID_82599EN_SFP:
	case IXGBE_DEV_ID_82599_CX4:
	case IXGBE_DEV_ID_82599_BYPASS:
	case IXGBE_DEV_ID_82599_T3_LOM:
		hw->mac.type = ixgbe_mac_82599EB;
		break;
	case IXGBE_DEV_ID_82599_VF:
	case IXGBE_DEV_ID_82599_VF_HV:
		hw->mac.type = ixgbe_mac_82599_vf;
		break;
	case IXGBE_DEV_ID_X540_VF:
	case IXGBE_DEV_ID_X540_VF_HV:
		hw->mac.type = ixgbe_mac_X540_vf;
		break;
	case IXGBE_DEV_ID_X540T:
	case IXGBE_DEV_ID_X540T1:
	case IXGBE_DEV_ID_X540_BYPASS:
		hw->mac.type = ixgbe_mac_X540;
		break;
	case IXGBE_DEV_ID_X550T:
	case IXGBE_DEV_ID_X550T1:
		hw->mac.type = ixgbe_mac_X550;
		break;
	case IXGBE_DEV_ID_X550EM_X_KX4:
	case IXGBE_DEV_ID_X550EM_X_KR:
	case IXGBE_DEV_ID_X550EM_X_10G_T:
	case IXGBE_DEV_ID_X550EM_X_1G_T:
	case IXGBE_DEV_ID_X550EM_X_SFP:
		hw->mac.type = ixgbe_mac_X550EM_x;
		break;
	case IXGBE_DEV_ID_X550_VF:
	case IXGBE_DEV_ID_X550_VF_HV:
		hw->mac.type = ixgbe_mac_X550_vf;
		break;
	case IXGBE_DEV_ID_X550EM_X_VF:
	case IXGBE_DEV_ID_X550EM_X_VF_HV:
		hw->mac.type = ixgbe_mac_X550EM_x_vf;
		break;
	default:
		ret_val = IXGBE_ERR_DEVICE_NOT_SUPPORTED;
		break;
	}

	return ret_val;
}

/**
 *  ixgbe_init_hw - Initialize the hardware
 *  @@hw: pointer to hardware structure
 *
 *  Initialize the hardware by resetting and then starting the hardware
 **/
int32_t ixgbe_init_hw(struct ixgbe_hw *hw)
{
	if (hw->mac.ops.init_hw)
		return hw->mac.ops.init_hw(hw);
	else
		return IXGBE_NOT_IMPLEMENTED;
}

/**
 *  ixgbe_get_media_type - Get media type
 *  @@hw: pointer to hardware structure
 *
 *  Returns the media type (fiber, copper, backplane)
 **/
enum ixgbe_media_type ixgbe_get_media_type(struct ixgbe_hw *hw)
{
	if (hw->mac.ops.get_media_type)
		return hw->mac.ops.get_media_type(hw);
	else
		return ixgbe_media_type_unknown;
}

/**
 *  ixgbe_identify_phy - Get PHY type
 *  @@hw: pointer to hardware structure
 *
 *  Determines the physical layer module found on the current adapter.
 **/
int32_t ixgbe_identify_phy(struct ixgbe_hw *hw)
{
	int32_t status = IXGBE_SUCCESS;

	if (hw->phy.type == ixgbe_phy_unknown) {
		if (hw->phy.ops.identify)
			status = hw->phy.ops.identify(hw);
		else
			status = IXGBE_NOT_IMPLEMENTED;
	}

	return status;
}

/**
 *  ixgbe_check_link - Get link and speed status
 *  @@hw: pointer to hardware structure
 *
 *  Reads the links register to determine if link is up and the current speed
 **/
int32_t ixgbe_check_link(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
			 bool *link_up, bool link_up_wait_to_complete)
{
	if (hw->mac.ops.check_link)
		return hw->mac.ops.check_link(hw, speed, link_up,
					      link_up_wait_to_complete);
	else
		return IXGBE_NOT_IMPLEMENTED;
}

/**
 *  ixgbe_flap_tx_laser - flap Tx laser to start autotry process
 *  @@hw: pointer to hardware structure
 *
 *  When the driver changes the link speeds that it can support then
 *  flap the tx laser to alert the link partner to start autotry
 *  process on its end.
 **/
void ixgbe_flap_tx_laser(struct ixgbe_hw *hw)
{
	if (hw->mac.ops.flap_tx_laser)
		hw->mac.ops.flap_tx_laser(hw);
}

/**
 *  ixgbe_set_rar - Set Rx address register
 *  @@hw: pointer to hardware structure
 *  @@index: Receive address register to write
 *  @@addr: Address to put into receive address register
 *  @@vmdq: VMDq "set"
 *  @@enable_addr: set flag that address is active
 *
 *  Puts an ethernet address into a receive address register.
 **/
int32_t ixgbe_set_rar(struct ixgbe_hw *hw, uint32_t index, uint8_t *addr,
		      uint32_t vmdq, uint32_t enable_addr)
{
	if (hw->mac.ops.set_rar)
		return hw->mac.ops.set_rar(hw, index, addr, vmdq, enable_addr);
	else
		return IXGBE_NOT_IMPLEMENTED;
}

/**
 *  ixgbe_set_vmdq - Associate a VMDq index with a receive address
 *  @@hw: pointer to hardware structure
 *  @@rar: receive address register index to associate with VMDq index
 *  @@vmdq: VMDq set or pool index
 **/
int32_t ixgbe_set_vmdq(struct ixgbe_hw *hw, uint32_t rar, uint32_t vmdq)
{
	if (hw->mac.ops.set_vmdq)
		return hw->mac.ops.set_vmdq(hw, rar, vmdq);
	else
		return IXGBE_NOT_IMPLEMENTED;
}

/**
 *  ixgbe_clear_vmdq - Disassociate a VMDq index from a receive address
 *  @@hw: pointer to hardware structure
 *  @@rar: receive address register index to disassociate with VMDq index
 *  @@vmdq: VMDq set or pool index
 **/
int32_t ixgbe_clear_vmdq(struct ixgbe_hw *hw, uint32_t rar, uint32_t vmdq)
{
	if (hw->mac.ops.clear_vmdq)
		return hw->mac.ops.clear_vmdq(hw, rar, vmdq);
	else
		return IXGBE_NOT_IMPLEMENTED;
}

/**
 *  ixgbe_init_uta_tables - Initializes Unicast Table Arrays.
 *  @@hw: pointer to hardware structure
 *
 *  Initializes the Unicast Table Arrays to zero on device load.  This
 *  is part of the Rx init addr execution path.
 **/
int32_t ixgbe_init_uta_tables(struct ixgbe_hw *hw)
{
	if (hw->mac.ops.init_uta_tables)
		return hw->mac.ops.init_uta_tables(hw);
	else
		return IXGBE_NOT_IMPLEMENTED;
}

void ixgbe_disable_rx(struct ixgbe_hw *hw)
{
	if (hw->mac.ops.disable_rx)
		hw->mac.ops.disable_rx(hw);
}

void ixgbe_enable_rx(struct ixgbe_hw *hw)
{
	if (hw->mac.ops.enable_rx)
		hw->mac.ops.enable_rx(hw);
}

/*
 * MBX: Mailbox handling
 */

/**
 *  ixgbe_read_mbx - Reads a message from the mailbox
 *  @@hw: pointer to the HW structure
 *  @@msg: The message buffer
 *  @@size: Length of buffer
 *  @@mbx_id: id of mailbox to read
 *
 *  returns SUCCESS if it successfully read message from buffer
 **/
int32_t ixgbe_read_mbx(struct ixgbe_hw *hw, uint32_t *msg, uint16_t size, uint16_t mbx_id)
{
	struct ixgbe_mbx_info *mbx = &hw->mbx;
	int32_t ret_val = IXGBE_ERR_MBX;

	DEBUGFUNC("ixgbe_read_mbx");

	/* limit read to size of mailbox */
	if (size > mbx->size)
		size = mbx->size;

	if (mbx->ops.read)
		ret_val = mbx->ops.read(hw, msg, size, mbx_id);

	return ret_val;
}

/**
 *  ixgbe_write_mbx - Write a message to the mailbox
 *  @@hw: pointer to the HW structure
 *  @@msg: The message buffer
 *  @@size: Length of buffer
 *  @@mbx_id: id of mailbox to write
 *
 *  returns SUCCESS if it successfully copied message into the buffer
 **/
int32_t ixgbe_write_mbx(struct ixgbe_hw *hw, uint32_t *msg, uint16_t size, uint16_t mbx_id)
{
	struct ixgbe_mbx_info *mbx = &hw->mbx;
	int32_t ret_val = IXGBE_SUCCESS;

	DEBUGFUNC("ixgbe_write_mbx");

	if (size > mbx->size)
		ret_val = IXGBE_ERR_MBX;

	else if (mbx->ops.write)
		ret_val = mbx->ops.write(hw, msg, size, mbx_id);

	return ret_val;
}

/**
 *  ixgbe_check_for_msg - checks to see if someone sent us mail
 *  @@hw: pointer to the HW structure
 *  @@mbx_id: id of mailbox to check
 *
 *  returns SUCCESS if the Status bit was found or else ERR_MBX
 **/
int32_t ixgbe_check_for_msg(struct ixgbe_hw *hw, uint16_t mbx_id)
{
	struct ixgbe_mbx_info *mbx = &hw->mbx;
	int32_t ret_val = IXGBE_ERR_MBX;

	DEBUGFUNC("ixgbe_check_for_msg");

	if (mbx->ops.check_for_msg)
		ret_val = mbx->ops.check_for_msg(hw, mbx_id);

	return ret_val;
}

/**
 *  ixgbe_check_for_ack - checks to see if someone sent us ACK
 *  @@hw: pointer to the HW structure
 *  @@mbx_id: id of mailbox to check
 *
 *  returns SUCCESS if the Status bit was found or else ERR_MBX
 **/
int32_t ixgbe_check_for_ack(struct ixgbe_hw *hw, uint16_t mbx_id)
{
	struct ixgbe_mbx_info *mbx = &hw->mbx;
	int32_t ret_val = IXGBE_ERR_MBX;

	DEBUGFUNC("ixgbe_check_for_ack");

	if (mbx->ops.check_for_ack)
		ret_val = mbx->ops.check_for_ack(hw, mbx_id);

	return ret_val;
}

/**
 *  ixgbe_check_for_rst - checks to see if other side has reset
 *  @@hw: pointer to the HW structure
 *  @@mbx_id: id of mailbox to check
 *
 *  returns SUCCESS if the Status bit was found or else ERR_MBX
 **/
int32_t ixgbe_check_for_rst(struct ixgbe_hw *hw, uint16_t mbx_id)
{
	struct ixgbe_mbx_info *mbx = &hw->mbx;
	int32_t ret_val = IXGBE_ERR_MBX;

	DEBUGFUNC("ixgbe_check_for_rst");

	if (mbx->ops.check_for_rst)
		ret_val = mbx->ops.check_for_rst(hw, mbx_id);

	return ret_val;
}

/**
 *  ixgbe_poll_for_msg - Wait for message notification
 *  @@hw: pointer to the HW structure
 *  @@mbx_id: id of mailbox to write
 *
 *  returns SUCCESS if it successfully received a message notification
 **/
int32_t ixgbe_poll_for_msg(struct ixgbe_hw *hw, uint16_t mbx_id)
{
	struct ixgbe_mbx_info *mbx = &hw->mbx;
	int countdown = mbx->timeout;

	DEBUGFUNC("ixgbe_poll_for_msg");

	if (!countdown || !mbx->ops.check_for_msg)
		goto out;

	while (countdown && mbx->ops.check_for_msg(hw, mbx_id)) {
		countdown--;
		if (!countdown)
			break;
		usec_delay(mbx->usec_delay);
	}

out:
	return countdown ? IXGBE_SUCCESS : IXGBE_ERR_MBX;
}

/**
 *  ixgbe_poll_for_ack - Wait for message acknowledgement
 *  @@hw: pointer to the HW structure
 *  @@mbx_id: id of mailbox to write
 *
 *  returns SUCCESS if it successfully received a message acknowledgement
 **/
int32_t ixgbe_poll_for_ack(struct ixgbe_hw *hw, uint16_t mbx_id)
{
	struct ixgbe_mbx_info *mbx = &hw->mbx;
	int countdown = mbx->timeout;

	DEBUGFUNC("ixgbe_poll_for_ack");

	if (!countdown || !mbx->ops.check_for_ack)
		goto out;

	while (countdown && mbx->ops.check_for_ack(hw, mbx_id)) {
		countdown--;
		if (!countdown)
			break;
		usec_delay(mbx->usec_delay);
	}

out:
	return countdown ? IXGBE_SUCCESS : IXGBE_ERR_MBX;
}

/**
 *  ixgbe_read_posted_mbx - Wait for message notification and receive message
 *  @@hw: pointer to the HW structure
 *  @@msg: The message buffer
 *  @@size: Length of buffer
 *  @@mbx_id: id of mailbox to write
 *
 *  returns SUCCESS if it successfully received a message notification and
 *  copied it into the receive buffer.
 **/
int32_t ixgbe_read_posted_mbx(struct ixgbe_hw *hw, uint32_t *msg, uint16_t size, uint16_t mbx_id)
{
	struct ixgbe_mbx_info *mbx = &hw->mbx;
	int32_t ret_val = IXGBE_ERR_MBX;

	DEBUGFUNC("ixgbe_read_posted_mbx");

	if (!mbx->ops.read)
		goto out;

	ret_val = ixgbe_poll_for_msg(hw, mbx_id);

	/* if ack received read message, otherwise we timed out */
	if (!ret_val)
		ret_val = mbx->ops.read(hw, msg, size, mbx_id);
out:
	return ret_val;
}

/**
 *  ixgbe_write_posted_mbx - Write a message to the mailbox, wait for ack
 *  @@hw: pointer to the HW structure
 *  @@msg: The message buffer
 *  @@size: Length of buffer
 *  @@mbx_id: id of mailbox to write
 *
 *  returns SUCCESS if it successfully copied message into the buffer and
 *  received an ack to that message within delay * timeout period
 **/
int32_t ixgbe_write_posted_mbx(struct ixgbe_hw *hw, uint32_t *msg, uint16_t size,
			   uint16_t mbx_id)
{
	struct ixgbe_mbx_info *mbx = &hw->mbx;
	int32_t ret_val = IXGBE_ERR_MBX;

	DEBUGFUNC("ixgbe_write_posted_mbx");

	/* exit if either we can't write or there isn't a defined timeout */
	if (!mbx->ops.write || !mbx->timeout)
		goto out;

	/* send msg */
	ret_val = mbx->ops.write(hw, msg, size, mbx_id);

	/* if msg sent wait until we receive an ack */
	if (!ret_val)
		ret_val = ixgbe_poll_for_ack(hw, mbx_id);
out:
	return ret_val;
}

/**
 *  ixgbe_init_mbx_ops_generic - Initialize MB function pointers
 *  @@hw: pointer to the HW structure
 *
 *  Setups up the mailbox read and write message function pointers
 **/
void ixgbe_init_mbx_ops_generic(struct ixgbe_hw *hw)
{
	struct ixgbe_mbx_info *mbx = &hw->mbx;

	mbx->ops.read_posted = ixgbe_read_posted_mbx;
	mbx->ops.write_posted = ixgbe_write_posted_mbx;
}

/**
 *  ixgbe_read_v2p_mailbox - read v2p mailbox
 *  @@hw: pointer to the HW structure
 *
 *  This function is used to read the v2p mailbox without losing the read to
 *  clear status bits.
 **/
uint32_t ixgbe_read_v2p_mailbox(struct ixgbe_hw *hw)
{
	uint32_t v2p_mailbox = IXGBE_READ_REG(hw, IXGBE_VFMAILBOX);

	v2p_mailbox |= hw->mbx.v2p_mailbox;
	hw->mbx.v2p_mailbox |= v2p_mailbox & IXGBE_VFMAILBOX_R2C_BITS;

	return v2p_mailbox;
}

int32_t ixgbe_check_for_bit_pf(struct ixgbe_hw *hw, uint32_t mask, int32_t index)
{
	uint32_t mbvficr = IXGBE_READ_REG(hw, IXGBE_MBVFICR(index));
	int32_t ret_val = IXGBE_ERR_MBX;

	if (mbvficr & mask) {
		ret_val = IXGBE_SUCCESS;
		IXGBE_WRITE_REG(hw, IXGBE_MBVFICR(index), mask);
	}

	return ret_val;
}

/**
 *  ixgbe_check_for_msg_pf - checks to see if the VF has sent mail
 *  @@hw: pointer to the HW structure
 *  @@vf_number: the VF index
 *
 *  returns SUCCESS if the VF has set the Status bit or else ERR_MBX
 **/
int32_t ixgbe_check_for_msg_pf(struct ixgbe_hw *hw, uint16_t vf_number)
{
	int32_t ret_val = IXGBE_ERR_MBX;
	int32_t index = IXGBE_MBVFICR_INDEX(vf_number);
	uint32_t vf_bit = vf_number % 16;

	DEBUGFUNC("ixgbe_check_for_msg_pf");

	if (!ixgbe_check_for_bit_pf(hw, IXGBE_MBVFICR_VFREQ_VF1 << vf_bit,
				    index)) {
		ret_val = IXGBE_SUCCESS;
		hw->mbx.stats.reqs++;
	}

	return ret_val;
}

/**
 *  ixgbe_check_for_ack_pf - checks to see if the VF has ACKed
 *  @@hw: pointer to the HW structure
 *  @@vf_number: the VF index
 *
 *  returns SUCCESS if the VF has set the Status bit or else ERR_MBX
 **/
int32_t ixgbe_check_for_ack_pf(struct ixgbe_hw *hw, uint16_t vf_number)
{
	int32_t ret_val = IXGBE_ERR_MBX;
	int32_t index = IXGBE_MBVFICR_INDEX(vf_number);
	uint32_t vf_bit = vf_number % 16;

	DEBUGFUNC("ixgbe_check_for_ack_pf");

	if (!ixgbe_check_for_bit_pf(hw, IXGBE_MBVFICR_VFACK_VF1 << vf_bit,
				    index)) {
		ret_val = IXGBE_SUCCESS;
		hw->mbx.stats.acks++;
	}

	return ret_val;
}

/**
 *  ixgbe_check_for_rst_pf - checks to see if the VF has reset
 *  @@hw: pointer to the HW structure
 *  @@vf_number: the VF index
 *
 *  returns SUCCESS if the VF has set the Status bit or else ERR_MBX
 **/
int32_t ixgbe_check_for_rst_pf(struct ixgbe_hw *hw, uint16_t vf_number)
{
	uint32_t reg_offset = (vf_number < 32) ? 0 : 1;
	uint32_t vf_shift = vf_number % 32;
	uint32_t vflre = 0;
	int32_t ret_val = IXGBE_ERR_MBX;

	DEBUGFUNC("ixgbe_check_for_rst_pf");

	switch (hw->mac.type) {
	case ixgbe_mac_82599EB:
		vflre = IXGBE_READ_REG(hw, IXGBE_VFLRE(reg_offset));
		break;
	case ixgbe_mac_X550:
	case ixgbe_mac_X550EM_x:
	case ixgbe_mac_X540:
		vflre = IXGBE_READ_REG(hw, IXGBE_VFLREC(reg_offset));
		break;
	default:
		break;
	}

	if (vflre & (1 << vf_shift)) {
		ret_val = IXGBE_SUCCESS;
		IXGBE_WRITE_REG(hw, IXGBE_VFLREC(reg_offset), (1 << vf_shift));
		hw->mbx.stats.rsts++;
	}

	return ret_val;
}

/**
 *  ixgbe_obtain_mbx_lock_pf - obtain mailbox lock
 *  @@hw: pointer to the HW structure
 *  @@vf_number: the VF index
 *
 *  return SUCCESS if we obtained the mailbox lock
 **/
int32_t ixgbe_obtain_mbx_lock_pf(struct ixgbe_hw *hw, uint16_t vf_number)
{
	int32_t ret_val = IXGBE_ERR_MBX;
	uint32_t p2v_mailbox;

	DEBUGFUNC("ixgbe_obtain_mbx_lock_pf");

	/* Take ownership of the buffer */
	IXGBE_WRITE_REG(hw, IXGBE_PFMAILBOX(vf_number), IXGBE_PFMAILBOX_PFU);

	/* reserve mailbox for vf use */
	p2v_mailbox = IXGBE_READ_REG(hw, IXGBE_PFMAILBOX(vf_number));
	if (p2v_mailbox & IXGBE_PFMAILBOX_PFU)
		ret_val = IXGBE_SUCCESS;

	return ret_val;
}

/**
 *  ixgbe_write_mbx_pf - Places a message in the mailbox
 *  @@hw: pointer to the HW structure
 *  @@msg: The message buffer
 *  @@size: Length of buffer
 *  @@vf_number: the VF index
 *
 *  returns SUCCESS if it successfully copied message into the buffer
 **/
int32_t ixgbe_write_mbx_pf(struct ixgbe_hw *hw, uint32_t *msg, uint16_t size,
			   uint16_t vf_number)
{
	int32_t ret_val;
	uint16_t i;

	DEBUGFUNC("ixgbe_write_mbx_pf");

	/* lock the mailbox to prevent pf/vf race condition */
	ret_val = ixgbe_obtain_mbx_lock_pf(hw, vf_number);
	if (ret_val)
		goto out_no_write;

	/* flush msg and acks as we are overwriting the message buffer */
	ixgbe_check_for_msg_pf(hw, vf_number);
	ixgbe_check_for_ack_pf(hw, vf_number);

	/* copy the caller specified message to the mailbox memory buffer */
	for (i = 0; i < size; i++)
		IXGBE_WRITE_REG_ARRAY(hw, IXGBE_PFMBMEM(vf_number), i, msg[i]);

	/* Interrupt VF to tell it a message has been sent and release buffer*/
	IXGBE_WRITE_REG(hw, IXGBE_PFMAILBOX(vf_number), IXGBE_PFMAILBOX_STS);

	/* update stats */
	hw->mbx.stats.msgs_tx++;

out_no_write:
	return ret_val;

}

/**
 *  ixgbe_read_mbx_pf - Read a message from the mailbox
 *  @@hw: pointer to the HW structure
 *  @@msg: The message buffer
 *  @@size: Length of buffer
 *  @@vf_number: the VF index
 *
 *  This function copies a message from the mailbox buffer to the caller's
 *  memory buffer.  The presumption is that the caller knows that there was
 *  a message due to a VF request so no polling for message is needed.
 **/
int32_t ixgbe_read_mbx_pf(struct ixgbe_hw *hw, uint32_t *msg, uint16_t size,
			  uint16_t vf_number)
{
	int32_t ret_val;
	uint16_t i;

	DEBUGFUNC("ixgbe_read_mbx_pf");

	/* lock the mailbox to prevent pf/vf race condition */
	ret_val = ixgbe_obtain_mbx_lock_pf(hw, vf_number);
	if (ret_val)
		goto out_no_read;

	/* copy the message to the mailbox memory buffer */
	for (i = 0; i < size; i++)
		msg[i] = IXGBE_READ_REG_ARRAY(hw, IXGBE_PFMBMEM(vf_number), i);

	/* Acknowledge the message and release buffer */
	IXGBE_WRITE_REG(hw, IXGBE_PFMAILBOX(vf_number), IXGBE_PFMAILBOX_ACK);

	/* update stats */
	hw->mbx.stats.msgs_rx++;

out_no_read:
	return ret_val;
}

/**
 *  ixgbe_init_mbx_params_pf - set initial values for pf mailbox
 *  @@hw: pointer to the HW structure
 *
 *  Initializes the hw->mbx struct to correct values for pf mailbox
 */
void ixgbe_init_mbx_params_pf(struct ixgbe_hw *hw)
{
	struct ixgbe_mbx_info *mbx = &hw->mbx;

	if (hw->mac.type != ixgbe_mac_82599EB &&
	    hw->mac.type != ixgbe_mac_X550 &&
	    hw->mac.type != ixgbe_mac_X550EM_x &&
	    hw->mac.type != ixgbe_mac_X540)
		return;

	mbx->timeout = 0;
	mbx->usec_delay = 0;

	mbx->size = IXGBE_VFMAILBOX_SIZE;

	mbx->ops.read = ixgbe_read_mbx_pf;
	mbx->ops.write = ixgbe_write_mbx_pf;
	mbx->ops.read_posted = ixgbe_read_posted_mbx;
	mbx->ops.write_posted = ixgbe_write_posted_mbx;
	mbx->ops.check_for_msg = ixgbe_check_for_msg_pf;
	mbx->ops.check_for_ack = ixgbe_check_for_ack_pf;
	mbx->ops.check_for_rst = ixgbe_check_for_rst_pf;

	mbx->stats.msgs_tx = 0;
	mbx->stats.msgs_rx = 0;
	mbx->stats.reqs = 0;
	mbx->stats.acks = 0;
	mbx->stats.rsts = 0;
}
@


1.22
log
@Enable support for the X550 family of 10 Gigabit controllers

Code was obtained from FreeBSD.  Make release testing by tb@@ on i386
and mikeb@@ on amd64 and sparc64.  X552 SFP tested by Hrvoje Popovski,
HUGE thanks!  X550T tested by mikeb@@ on amd64 and sparc64.

ok kettenis, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.21 2016/11/21 17:08:56 mikeb Exp $	*/
a2532 1
		hw->fc.current_mode = hw->fc.requested_mode;
d2535 1
@


1.21
log
@Fixup a PCIe transaction completion timeout issue

Mirrors the change 71bde60191a9fa44d33b582c5e3713ffe99b0fef in Linux;
taken as a part of the 280182 commit to FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.20 2016/11/21 12:37:35 mikeb Exp $	*/
d3956 6
@


1.20
log
@Correctly set the default value for the FCRTH

X540 datasheet specifies that Flow Control Receive Threshold High
should be set to the Rx Buffer Size minus the delay value which is
different for different modes of operation, however the minimum is
0x6000 (24576).

Mirrors the bc1fc64fd2d9093496e5b04c6d94d26bfa629c9c commit to the
Linux source code, but picked up from the 280182 commit to FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.19 2016/11/17 21:08:27 mikeb Exp $	*/
d3573 2
a3574 1
	uint32_t gcr_ext, hlreg0;
d3591 17
@


1.19
log
@Autoconfiguration and firmware semaphore refactoring
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.18 2016/11/17 20:44:04 mikeb Exp $	*/
d2290 3
a2292 2
			 * to the maximum FCRTH value.  This allows the Tx
			 * switch to function even under heavy Rx workloads.
d2294 1
a2294 1
			fcrth = IXGBE_READ_REG(hw, IXGBE_RXPBSIZE(i)) - 32;
@


1.18
log
@EEPROM code refactoring for X540
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.17 2016/11/17 19:26:57 mikeb Exp $	*/
d68 3
d130 2
d157 1
d228 1
a228 1
 *  ixgbe_setup_fc - Set up flow control
d233 1
a233 1
int32_t ixgbe_setup_fc(struct ixgbe_hw *hw)
d238 1
a238 1
	bool got_lock = FALSE;
d242 1
a242 4
	/*
	 * Validate the requested mode.  Strict IEEE mode does not allow
	 * ixgbe_fc_rx_pause because it will cause us to fail at UNH.
	 */
d263 7
a272 1
	case ixgbe_media_type_backplane:
d274 1
a274 1
		reg_bp = IXGBE_READ_REG(hw, IXGBE_AUTOC);
d369 3
a371 22
		/* Need the SW/FW semaphore around AUTOC writes if 82599 and
		 * LESM is on, likewise reset_pipeline requries the lock as
		 * it also writes AUTOC.
		 */
		if ((hw->mac.type == ixgbe_mac_82599EB) &&
		    ixgbe_verify_lesm_fw_enabled(hw)) {
			ret_val = hw->mac.ops.acquire_swfw_sync(hw,
							IXGBE_GSSR_MAC_CSR_SM);
			if (ret_val != IXGBE_SUCCESS) {
				ret_val = IXGBE_ERR_SWFW_SYNC;
				goto out;
			}
			got_lock = TRUE;
		}

		IXGBE_WRITE_REG(hw, IXGBE_AUTOC, reg_bp);
		if (hw->mac.type == ixgbe_mac_82599EB)
			ixgbe_reset_pipeline(hw);

		if (got_lock)
			hw->mac.ops.release_swfw_sync(hw,
						      IXGBE_GSSR_MAC_CSR_SM);
d378 1
a378 1
	DEBUGOUT1("Set up FC; IXGBE_AUTOC = 0x%08X\n", reg);
d394 1
a394 1
	int32_t ret_val;
d417 5
a421 3
	ret_val = ixgbe_setup_fc(hw);
	if (ret_val != IXGBE_SUCCESS)
		goto out;
d2387 1
a2387 2
		ERROR_REPORT1(IXGBE_ERROR_POLLING,
			     "Auto-Negotiation did not complete or timed out");
d2422 1
a2422 2
		ERROR_REPORT1(IXGBE_ERROR_POLLING,
			     "Auto-Negotiation did not complete");
d2429 1
a2429 2
			ERROR_REPORT1(IXGBE_ERROR_UNSUPPORTED,
				     "Link partner is not AN enabled");
d2657 1
a2657 1
int32_t ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw, uint16_t mask)
d2704 1
a2704 1
void ixgbe_release_swfw_sync(struct ixgbe_hw *hw, uint16_t mask)
d2758 31
d2836 1
a2836 1
	uint32_t autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
d2839 1
d2850 3
a2852 14
		/* Need the SW/FW semaphore around AUTOC writes if 82599 and
		 * LESM is on.
		 */
		bool got_lock = FALSE;
		if ((hw->mac.type == ixgbe_mac_82599EB) &&
		    ixgbe_verify_lesm_fw_enabled(hw)) {
			ret_val = hw->mac.ops.acquire_swfw_sync(hw,
							IXGBE_GSSR_MAC_CSR_SM);
			if (ret_val != IXGBE_SUCCESS) {
				ret_val = IXGBE_ERR_SWFW_SYNC;
				goto out;
			}
			got_lock = TRUE;
		}
d2856 5
a2860 1
		IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc_reg);
a2861 4

		if (got_lock)
			hw->mac.ops.release_swfw_sync(hw,
						      IXGBE_GSSR_MAC_CSR_SM);
d2881 1
a2881 1
	uint32_t autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
d2884 1
a2884 1
	bool got_lock = FALSE;
d2887 4
a2890 13
	/* Need the SW/FW semaphore around AUTOC writes if 82599 and
	 * LESM is on.
	 */
	if ((hw->mac.type == ixgbe_mac_82599EB) &&
	    ixgbe_verify_lesm_fw_enabled(hw)) {
		ret_val = hw->mac.ops.acquire_swfw_sync(hw,
						IXGBE_GSSR_MAC_CSR_SM);
		if (ret_val != IXGBE_SUCCESS) {
			ret_val = IXGBE_ERR_SWFW_SYNC;
			goto out;
		}
		got_lock = TRUE;
	}
a2893 1
	IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc_reg);
d2895 3
a2897 5
	if (hw->mac.type == ixgbe_mac_82599EB)
		ixgbe_reset_pipeline(hw);

	if (got_lock)
		hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);
a4172 16
	else
		return IXGBE_NOT_IMPLEMENTED;
}

bool ixgbe_verify_lesm_fw_enabled(struct ixgbe_hw *hw)
{
	if (hw->mac.ops.verify_lesm_fw_enabled)
		return hw->mac.ops.verify_lesm_fw_enabled(hw);
	else
		return IXGBE_NOT_IMPLEMENTED;
}

int32_t ixgbe_reset_pipeline(struct ixgbe_hw *hw)
{
	if (hw->mac.ops.reset_pipeline)
		return hw->mac.ops.reset_pipeline(hw);
@


1.17
log
@Bring in new PHY bits, some of the 82599 specific stuff becomes shared
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.16 2016/11/17 12:21:27 mikeb Exp $	*/
d898 1
a898 1
 *  ixgbe_write_eeprom_generic - Writes 16 bit value to EEPROM
d901 2
a902 1
 *  @@data: 16 bit word to be written to the EEPROM
d907 2
a908 1
int32_t ixgbe_write_eeprom_generic(struct ixgbe_hw *hw, uint16_t offset, uint16_t data)
d911 3
d916 1
a916 8
	DEBUGFUNC("ixgbe_write_eeprom_generic");

	hw->eeprom.ops.init_params(hw);

	if (offset >= hw->eeprom.word_size) {
		status = IXGBE_ERR_EEPROM;
		goto out;
	}
d929 2
a930 1
		ixgbe_standby_eeprom(hw);
d932 4
a935 3
		/*  Send the WRITE ENABLE command (8 bit opcode )  */
		ixgbe_shift_out_eeprom_bits(hw, IXGBE_EEPROM_WREN_OPCODE_SPI,
					    IXGBE_EEPROM_OPCODE_BITS);
d937 1
a937 1
		ixgbe_standby_eeprom(hw);
d939 30
a968 17
		/*
		 * Some SPI eeproms use the 8th address bit embedded in the
		 * opcode
		 */
		if ((hw->eeprom.address_bits == 8) && (offset >= 128))
			write_opcode |= IXGBE_EEPROM_A8_OPCODE_SPI;

		/* Send the Write command (8-bit opcode + addr) */
		ixgbe_shift_out_eeprom_bits(hw, write_opcode,
					    IXGBE_EEPROM_OPCODE_BITS);
		ixgbe_shift_out_eeprom_bits(hw, (uint16_t)(offset*2),
					    hw->eeprom.address_bits);

		/* Send the data */
		data = (data >> 8) | (data << 8);
		ixgbe_shift_out_eeprom_bits(hw, data, 16);
		ixgbe_standby_eeprom(hw);
d970 3
a976 1
out:
d981 1
a981 1
 *  ixgbe_read_eeprom_bit_bang_generic - Read EEPROM word using bit-bang
d983 2
a984 2
 *  @@offset: offset within the EEPROM to be read
 *  @@data: read 16 bit value from EEPROM
d986 2
a987 1
 *  Reads 16 bit value from EEPROM through bit-bang method
d989 1
a989 2
int32_t ixgbe_read_eeprom_bit_bang_generic(struct ixgbe_hw *hw, uint16_t offset,
				       uint16_t *data)
d992 2
a993 2
	uint16_t word_in;
	uint8_t read_opcode = IXGBE_EEPROM_READ_OPCODE_SPI;
d1002 25
d1038 27
a1064 1
		ixgbe_standby_eeprom(hw);
d1066 12
a1077 6
		/*
		 * Some SPI eeproms use the 8th address bit embedded in the
		 * opcode
		 */
		if ((hw->eeprom.address_bits == 8) && (offset >= 128))
			read_opcode |= IXGBE_EEPROM_A8_OPCODE_SPI;
d1079 1
a1079 5
		/* Send the READ command (opcode + addr) */
		ixgbe_shift_out_eeprom_bits(hw, read_opcode,
					    IXGBE_EEPROM_OPCODE_BITS);
		ixgbe_shift_out_eeprom_bits(hw, (uint16_t)(offset*2),
					    hw->eeprom.address_bits);
d1081 1
a1081 3
		/* Read the data. */
		word_in = ixgbe_shift_in_eeprom_bits(hw, 16);
		*data = (word_in >> 8) | (word_in << 8);
d1083 3
a1085 2
		/* End this read operation */
		ixgbe_release_eeprom(hw);
d1088 2
d1095 1
a1095 1
 *  ixgbe_read_eerd_generic - Read EEPROM word using EERD
d1097 3
a1099 2
 *  @@offset: offset of  word in the EEPROM to read
 *  @@data: word read from the EEPROM
d1101 1
a1101 1
 *  Reads a 16 bit word from the EEPROM using the EERD register.
d1103 2
a1104 1
int32_t ixgbe_read_eerd_generic(struct ixgbe_hw *hw, uint16_t offset, uint16_t *data)
d1107 4
a1110 1
	int32_t status;
d1114 6
d1122 1
d1126 3
a1128 2
	eerd = (offset << IXGBE_EEPROM_RW_ADDR_SHIFT) +
	       IXGBE_EEPROM_RW_REG_START;
d1130 2
a1131 8
	IXGBE_WRITE_REG(hw, IXGBE_EERD, eerd);
	status = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_READ);

	if (status == IXGBE_SUCCESS)
		*data = (IXGBE_READ_REG(hw, IXGBE_EERD) >>
			 IXGBE_EEPROM_RW_REG_DATA);
	else
		DEBUGOUT("Eeprom read timed out\n");
d1133 8
d1146 14
a1159 1
 *  ixgbe_write_eewr_generic - Write EEPROM word using EEWR
d1162 2
a1163 1
 *  @@data: word write to the EEPROM
d1165 1
a1165 1
 *  Write a 16 bit word to the EEPROM using the EEWR register.
d1167 2
a1168 1
int32_t ixgbe_write_eewr_generic(struct ixgbe_hw *hw, uint16_t offset, uint16_t data)
d1171 4
a1174 1
	int32_t status;
d1178 6
d1186 1
d1190 10
a1199 8
	eewr = (offset << IXGBE_EEPROM_RW_ADDR_SHIFT) |
	       (data << IXGBE_EEPROM_RW_REG_DATA) | IXGBE_EEPROM_RW_REG_START;

	status = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_WRITE);
	if (status != IXGBE_SUCCESS) {
		DEBUGOUT("Eeprom write EEWR timed out\n");
		goto out;
	}
d1201 1
a1201 1
	IXGBE_WRITE_REG(hw, IXGBE_EEWR, eewr);
d1203 5
a1207 4
	status = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_WRITE);
	if (status != IXGBE_SUCCESS) {
		DEBUGOUT("Eeprom write EEWR timed out\n");
		goto out;
d1215 13
d1500 1
a1500 1
					uint16_t count)
d1660 2
d1663 1
a1663 1
uint16_t ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw)
d1676 1
a1676 1
		if (hw->eeprom.ops.read(hw, i, &word) != IXGBE_SUCCESS) {
d1678 1
a1678 1
			break;
d1685 4
a1688 1
		hw->eeprom.ops.read(hw, i, &pointer);
d1690 16
a1705 9
		/* Make sure the pointer seems valid */
		if (pointer != 0xFFFF && pointer != 0) {
			hw->eeprom.ops.read(hw, pointer, &length);

			if (length != 0xFFFF && length != 0) {
				for (j = pointer+1; j <= pointer+length; j++) {
					hw->eeprom.ops.read(hw, j, &word);
					checksum += word;
				}
d1707 1
d1713 1
a1713 1
	return checksum;
d1738 4
d1743 3
a1745 4
	if (status == IXGBE_SUCCESS) {
		checksum = hw->eeprom.ops.calc_checksum(hw);

		hw->eeprom.ops.read(hw, IXGBE_EEPROM_CHECKSUM, &read_checksum);
d1747 1
a1747 6
		/*
		 * Verify read checksum from EEPROM is the same as
		 * calculated checksum
		 */
		if (read_checksum != checksum)
			status = IXGBE_ERR_EEPROM_CHECKSUM;
d1749 2
a1750 4
		/* If the user cares, return the calculated checksum */
		if (checksum_val)
			*checksum_val = checksum;
	} else {
d1752 1
d1755 10
d1784 1
a1784 6

	if (status == IXGBE_SUCCESS) {
		checksum = hw->eeprom.ops.calc_checksum(hw);
		status = hw->eeprom.ops.write(hw, IXGBE_EEPROM_CHECKSUM,
					      checksum);
	} else {
d1786 1
d1788 8
@


1.16
log
@Style and typo fixes; no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.15 2016/11/16 23:19:29 mikeb Exp $	*/
d5 1
a5 1
  Copyright (c) 2001-2013, Intel Corporation
d35 2
a36 2
/* FreeBSD: src/sys/dev/ixgbe/ixgbe_common.c 251964 Jun 18 21:28:19 2013 UTC */
/* FreeBSD: src/sys/dev/ixgbe/ixgbe_mbx.c 230775 Jan 30 16:42:02 2012 UTC */
d147 2
d180 1
d198 1
d200 3
d212 2
a213 1
	ERROR_REPORT2(IXGBE_ERROR_UNSUPPORTED,
d216 2
d261 1
d337 1
a337 1
	if (hw->mac.type != ixgbe_mac_X540) {
d602 1
a602 1
	if (hw->mac.type == ixgbe_mac_X540) {
d773 1
a773 1
	IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, 0);
d2370 1
d2488 3
d2650 4
a2653 1
	IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, regval);
d2782 2
d3247 1
a3247 1
		for (i = 0; i < IXGBE_LINK_UP_TIME; i++) {
d3264 2
a3265 2
	if ((links_reg & IXGBE_LINKS_SPEED_82599) ==
	    IXGBE_LINKS_SPEED_10G_82599)
d3267 6
a3272 2
	else if ((links_reg & IXGBE_LINKS_SPEED_82599) ==
		 IXGBE_LINKS_SPEED_1G_82599)
d3274 2
a3275 2
	else if ((links_reg & IXGBE_LINKS_SPEED_82599) ==
		 IXGBE_LINKS_SPEED_100_82599)
d3277 6
a3282 1
	else
d3284 1
d3307 109
d3456 300
d3776 5
d3795 1
d3801 90
d4046 12
d4402 2
d4535 2
@


1.15
log
@Remove unused bits; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.14 2014/11/26 17:03:52 kettenis Exp $	*/
d101 1
a101 1
	eeprom->ops.init_params = &ixgbe_init_eeprom_params_generic;
d104 1
a104 1
		eeprom->ops.read = &ixgbe_read_eerd_generic;
d106 2
a107 2
		eeprom->ops.read = &ixgbe_read_eeprom_bit_bang_generic;
	eeprom->ops.write = &ixgbe_write_eeprom_generic;
d109 3
a111 3
				      &ixgbe_validate_eeprom_checksum_generic;
	eeprom->ops.update_checksum = &ixgbe_update_eeprom_checksum_generic;
	eeprom->ops.calc_checksum = &ixgbe_calc_eeprom_checksum_generic;
d114 1
a114 1
	mac->ops.init_hw = &ixgbe_init_hw_generic;
d116 2
a117 2
	mac->ops.start_hw = &ixgbe_start_hw_generic;
	mac->ops.clear_hw_cntrs = &ixgbe_clear_hw_cntrs_generic;
d120 7
a126 7
	mac->ops.enable_rx_dma = &ixgbe_enable_rx_dma_generic;
	mac->ops.get_mac_addr = &ixgbe_get_mac_addr_generic;
	mac->ops.stop_adapter = &ixgbe_stop_adapter_generic;
	mac->ops.get_bus_info = &ixgbe_get_bus_info_generic;
	mac->ops.set_lan_id = &ixgbe_set_lan_id_multi_port_pcie;
	mac->ops.acquire_swfw_sync = &ixgbe_acquire_swfw_sync;
	mac->ops.release_swfw_sync = &ixgbe_release_swfw_sync;
d129 4
a132 4
	mac->ops.led_on = &ixgbe_led_on_generic;
	mac->ops.led_off = &ixgbe_led_off_generic;
	mac->ops.blink_led_start = &ixgbe_blink_led_start_generic;
	mac->ops.blink_led_stop = &ixgbe_blink_led_stop_generic;
d135 2
a136 2
	mac->ops.set_rar = &ixgbe_set_rar_generic;
	mac->ops.clear_rar = &ixgbe_clear_rar_generic;
d140 4
a143 4
	mac->ops.init_rx_addrs = &ixgbe_init_rx_addrs_generic;
	mac->ops.update_mc_addr_list = &ixgbe_update_mc_addr_list_generic;
	mac->ops.enable_mc = &ixgbe_enable_mc_generic;
	mac->ops.disable_mc = &ixgbe_disable_mc_generic;
d149 1
a149 1
	mac->ops.fc_enable = &ixgbe_fc_enable_generic;
d787 1
a787 1
	 * Prevent the PCI-E bus from from hanging by disabling PCI-E master
d1320 1
a1320 1
	};
d1406 1
a1406 1
	};
d1584 1
a1584 2
	/*
	 * Read the first word from the EEPROM. If this times out or fails, do
d1623 1
a1623 2
	/*
	 * Read the first word from the EEPROM. If this times out or fails, do
d2791 1
a2791 1
 *  finds the rar that it is aleady in; adds to the pool list
d3522 1
a3522 1
 *  returns SUCCESS if it successfuly read message from buffer
@


1.14
log
@The onboard ix(4) interfaces on the SPARC T5 machines don't have a valid MAC
address in their EEPROM.  Use the MAC address given by the "local-mac-address"
Open Firmware property instead.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.13 2013/08/05 19:58:05 mikeb Exp $	*/
a140 1
	mac->ops.update_uc_addr_list = &ixgbe_update_uc_addr_list_generic;
a1864 70
 *  ixgbe_update_uc_addr_list_generic - Updates MAC list of secondary addresses
 *  @@hw: pointer to hardware structure
 *  @@addr_list: the list of new addresses
 *  @@addr_count: number of addresses
 *  @@next: iterator function to walk the address list
 *
 *  The given list replaces any existing list.  Clears the secondary addrs from
 *  receive address registers.  Uses unused receive address registers for the
 *  first secondary addresses, and falls back to promiscuous mode as needed.
 *
 *  Drivers using secondary unicast addresses must set user_set_promisc when
 *  manually putting the device into promiscuous mode.
 **/
int32_t ixgbe_update_uc_addr_list_generic(struct ixgbe_hw *hw, uint8_t *addr_list,
					  uint32_t addr_count, ixgbe_mc_addr_itr next)
{
	uint8_t *addr;
	uint32_t i;
	uint32_t old_promisc_setting = hw->addr_ctrl.overflow_promisc;
	uint32_t uc_addr_in_use;
	uint32_t fctrl;
	uint32_t vmdq;

	DEBUGFUNC("ixgbe_update_uc_addr_list_generic");

	/*
	 * Clear accounting of old secondary address list,
	 * don't count RAR[0]
	 */
	uc_addr_in_use = hw->addr_ctrl.rar_used_count - 1;
	hw->addr_ctrl.rar_used_count -= uc_addr_in_use;
	hw->addr_ctrl.overflow_promisc = 0;

	/* Zero out the other receive addresses */
	DEBUGOUT1("Clearing RAR[1-%d]\n", uc_addr_in_use+1);
	for (i = 0; i < uc_addr_in_use; i++) {
		IXGBE_WRITE_REG(hw, IXGBE_RAL(1+i), 0);
		IXGBE_WRITE_REG(hw, IXGBE_RAH(1+i), 0);
	}

	/* Add the new addresses */
	for (i = 0; i < addr_count; i++) {
		DEBUGOUT(" Adding the secondary addresses:\n");
		addr = next(hw, &addr_list, &vmdq);
		ixgbe_add_uc_addr(hw, addr, vmdq);
	}

	if (hw->addr_ctrl.overflow_promisc) {
		/* enable promisc if not already in overflow or set by user */
		if (!old_promisc_setting && !hw->addr_ctrl.user_set_promisc) {
			DEBUGOUT(" Entering address overflow promisc mode\n");
			fctrl = IXGBE_READ_REG(hw, IXGBE_FCTRL);
			fctrl |= IXGBE_FCTRL_UPE;
			IXGBE_WRITE_REG(hw, IXGBE_FCTRL, fctrl);
		}
	} else {
		/* only disable if set by overflow, not by user */
		if (old_promisc_setting && !hw->addr_ctrl.user_set_promisc) {
			DEBUGOUT(" Leaving address overflow promisc mode\n");
			fctrl = IXGBE_READ_REG(hw, IXGBE_FCTRL);
			fctrl &= ~IXGBE_FCTRL_UPE;
			IXGBE_WRITE_REG(hw, IXGBE_FCTRL, fctrl);
		}
	}

	DEBUGOUT("ixgbe_update_uc_addr_list_generic Complete\n");
	return IXGBE_SUCCESS;
}

/**
a3275 28
}

/**
 *  ixgbe_enable_relaxed_ordering_gen2 - Enable relaxed ordering
 *  @@hw: pointer to hardware structure
 *
 **/
void ixgbe_enable_relaxed_ordering_gen2(struct ixgbe_hw *hw)
{
	uint32_t regval;
	uint32_t i;

	DEBUGFUNC("ixgbe_enable_relaxed_ordering_gen2");

	/* Enable relaxed ordering */
	for (i = 0; i < hw->mac.max_tx_queues; i++) {
		regval = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL_82599(i));
		regval |= IXGBE_DCA_TXCTRL_DESC_WRO_EN;
		IXGBE_WRITE_REG(hw, IXGBE_DCA_TXCTRL_82599(i), regval);
	}

	for (i = 0; i < hw->mac.max_rx_queues; i++) {
		regval = IXGBE_READ_REG(hw, IXGBE_DCA_RXCTRL(i));
		regval |= IXGBE_DCA_RXCTRL_DATA_WRO_EN |
			  IXGBE_DCA_RXCTRL_HEAD_WRO_EN;
		IXGBE_WRITE_REG(hw, IXGBE_DCA_RXCTRL(i), regval);
	}

@


1.13
log
@First stab at updating this monster to the Intel/FreeBSD current version.
This syncs PHY and chip dependent parts as well as brings support for the
flow control and additional (untested) bits for 1G fiber versions.

Tested by Hrvoje Popovski <hrvoje at srce ! hr> on 82599/SFP+DA, florian@@
and benno@@ on 82599/SFP+SR and on 82598/CX4-BP, 82599/SFP+DA and X540/RJ45
by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.12 2012/12/20 17:32:38 mikeb Exp $	*/
d40 4
d624 8
@


1.12
log
@correctly update the current flow control mode
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.11 2012/12/17 12:03:16 mikeb Exp $	*/
d5 1
a5 1
  Copyright (c) 2001-2009, Intel Corporation
d35 2
a36 1
/*$FreeBSD: src/sys/dev/ixgbe/ixgbe_common.c,v 1.9 2009/12/07 21:30:54 jfv Exp $*/
d40 3
d59 1
a59 1
int32_t ixgbe_device_supports_autoneg_fc(struct ixgbe_hw *hw);
a69 9
int32_t ixgbe_check_for_bit_vf(struct ixgbe_hw *hw, uint32_t mask);
int32_t ixgbe_check_for_msg_vf(struct ixgbe_hw *hw, uint16_t mbx_id);
int32_t ixgbe_check_for_ack_vf(struct ixgbe_hw *hw, uint16_t mbx_id);
int32_t ixgbe_check_for_rst_vf(struct ixgbe_hw *hw, uint16_t mbx_id);
int32_t ixgbe_obtain_mbx_lock_vf(struct ixgbe_hw *hw);
int32_t ixgbe_write_mbx_vf(struct ixgbe_hw *hw, uint32_t *msg, uint16_t size,
			   uint16_t mbx_id);
int32_t ixgbe_read_mbx_vf(struct ixgbe_hw *hw, uint32_t *msg, uint16_t size,
			  uint16_t mbx_id);
d94 2
d157 223
d390 1
d393 2
d413 3
a415 1
	ixgbe_setup_fc(hw, 0);
d420 2
a421 1
	return IXGBE_SUCCESS;
d449 1
a449 1
		regval &= ~IXGBE_DCA_TXCTRL_TX_WB_RO_EN;
d455 2
a456 2
		regval &= ~(IXGBE_DCA_RXCTRL_DESC_WRO_EN |
			    IXGBE_DCA_RXCTRL_DESC_HSRO_EN);
d475 3
a477 1
	int32_t status = IXGBE_SUCCESS;
d501 2
d551 3
a553 2
	for (i = 0; i < 8; i++)
		IXGBE_READ_REG(hw, IXGBE_RNBC(i));
d590 1
a590 1
			hw->phy.ops.identify(hw);
d619 2
d634 1
a634 1
 *  ixgbe_get_bus_info_generic - Generic set PCI bus info
d636 1
d638 1
a638 1
 *  Sets the PCI bus info (speed, width, type) within the ixgbe_hw structure
d640 2
a641 1
int32_t ixgbe_get_bus_info_generic(struct ixgbe_hw *hw)
a643 1
	uint16_t link_status;
a646 3
	/* Get the negotiated link width and speed from PCI config space */
	link_status = IXGBE_READ_PCIE_WORD(hw, IXGBE_PCI_LINK_STATUS);

d672 3
d681 19
d716 2
a738 1
	uint32_t number_of_queues;
d742 2
d751 1
a751 5
	reg_val = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
	reg_val &= ~(IXGBE_RXCTRL_RXEN);
	IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, reg_val);
	IXGBE_WRITE_FLUSH(hw);
	msec_delay(2);
d753 1
a753 1
	/* Clear interrupt mask to stop from interrupts being generated */
d756 1
a756 1
	/* Clear any pending interrupts */
d760 9
a768 7
	number_of_queues = hw->mac.max_tx_queues;
	for (i = 0; i < number_of_queues; i++) {
		reg_val = IXGBE_READ_REG(hw, IXGBE_TXDCTL(i));
		if (reg_val & IXGBE_TXDCTL_ENABLE) {
			reg_val &= ~IXGBE_TXDCTL_ENABLE;
			IXGBE_WRITE_REG(hw, IXGBE_TXDCTL(i), reg_val);
		}
d771 4
d779 1
a779 3
	ixgbe_disable_pcie_master(hw);

	return IXGBE_SUCCESS;
d791 2
d811 2
d835 2
d842 2
d860 1
a860 1
					     IXGBE_EEPROM_WORD_SIZE_BASE_SHIFT);
d889 2
d1094 2
d1108 5
d1129 2
d1184 3
d1201 22
d1248 2
a1249 2
			DEBUGOUT("SWESMBI Software EEPROM semaphore "
				 "not granted.\n");
d1254 3
a1256 2
		DEBUGOUT("Software semaphore SMBI between device drivers "
			 "not granted.\n");
d1272 2
d1292 2
d1331 2
d1359 2
d1413 2
d1449 2
d1468 2
d1488 2
d1523 2
d1565 1
a1565 1
					   uint16_t *checksum_val)
d1571 2
d1611 2
d1641 2
d1670 2
a1671 2
int32_t ixgbe_set_rar_generic(struct ixgbe_hw *hw, uint32_t index, uint8_t *addr, uint32_t vmdq,
			  uint32_t enable_addr)
d1676 2
d1680 2
a1681 1
		DEBUGOUT1("RAR index %d is out of range.\n", index);
a1687 1
	/* Make sure we are using a valid rar index range */
d1726 2
d1730 2
a1731 1
		DEBUGOUT1("RAR index %d is out of range.\n", index);
d1765 2
d1815 1
a1815 1
	ixgbe_hw0(hw, init_uta_tables);
d1832 2
d1868 1
a1868 1
				      uint32_t addr_count, ixgbe_mc_addr_itr next)
d1877 2
d1939 2
d1956 1
a1956 1
		panic("ixgbe");
d1978 2
d2005 1
d2007 2
a2008 4
 *  The given list replaces any existing list. Clears the MC addrs from receive
 *  address registers and the multicast table. Uses unused receive address
 *  registers for the first multicast addresses, and hashes the rest into the
 *  multicast table.
d2011 2
a2012 1
				      uint32_t mc_addr_count, ixgbe_mc_addr_itr next)
d2017 2
d2027 4
a2030 2
	DEBUGOUT(" Clearing MTA\n");
	memset(&hw->mac.mta_shadow, 0, sizeof(hw->mac.mta_shadow));
d2061 2
d2080 2
a2090 1
 *  @@packetbuf_num: packet buffer number (0-7)
d2094 1
a2094 1
int32_t ixgbe_fc_enable_generic(struct ixgbe_hw *hw, int32_t packetbuf_num)
a2098 1
	uint32_t rx_pba_size;
d2100 22
d2124 1
a2124 3
	ret_val = ixgbe_fc_autoneg(hw);
	if (ret_val == IXGBE_ERR_FLOW_CONTROL)
		goto out;
d2128 1
a2128 1
	mflcn_reg &= ~(IXGBE_MFLCN_RFCE | IXGBE_MFLCN_RPFCE);
d2174 2
a2175 1
		DEBUGOUT("Flow control param set incorrectly\n");
a2185 2
	rx_pba_size = IXGBE_READ_REG(hw, IXGBE_RXPBSIZE(packetbuf_num));
	rx_pba_size >>= IXGBE_RXPBSIZE_SHIFT;
d2187 17
a2203 2
	fcrth = (rx_pba_size - hw->fc.high_water) << 10;
	fcrtl = (rx_pba_size - hw->fc.low_water) << 10;
d2205 1
a2205 4
	if (hw->fc.current_mode & ixgbe_fc_tx_pause) {
		fcrth |= IXGBE_FCRTH_FCEN;
		if (hw->fc.send_xon)
			fcrtl |= IXGBE_FCRTL_XONE;
a2207 3
	IXGBE_WRITE_REG(hw, IXGBE_FCRTH_82599(packetbuf_num), fcrth);
	IXGBE_WRITE_REG(hw, IXGBE_FCRTL_82599(packetbuf_num), fcrtl);

d2209 3
a2211 6
	reg = IXGBE_READ_REG(hw, IXGBE_FCTTV(packetbuf_num / 2));
	if ((packetbuf_num & 1) == 0)
		reg = (reg & 0xFFFF0000) | hw->fc.pause_time;
	else
		reg = (reg & 0x0000FFFF) | (hw->fc.pause_time << 16);
	IXGBE_WRITE_REG(hw, IXGBE_FCTTV(packetbuf_num / 2), reg);
d2213 2
a2214 1
	IXGBE_WRITE_REG(hw, IXGBE_FCRTV, (hw->fc.pause_time >> 1));
d2221 1
a2221 1
 *  ixgbe_fc_autoneg - Configure flow control
d2223 6
d2230 2
a2231 2
 *  Compares our advertised flow control capabilities to those advertised by
 *  our link partner, and determines the proper flow control mode to use.
d2233 11
a2243 22
int32_t ixgbe_fc_autoneg(struct ixgbe_hw *hw)
{
	int32_t ret_val = IXGBE_SUCCESS;
	ixgbe_link_speed speed;
	int link_up;

	if (hw->fc.disable_fc_autoneg)
		goto out;

	/*
	 * AN should have completed when the cable was plugged in.
	 * Look for reasons to bail out.  Bail out if:
	 * - FC autoneg is disabled, or if
	 * - link is not up.
	 *
	 * Since we're being called from an LSC, link is already known to be up.
	 * So use link_up_wait_to_complete=FALSE.
	 */
	hw->mac.ops.check_link(hw, &speed, &link_up, FALSE);
	if (!link_up) {
		ret_val = IXGBE_ERR_FLOW_CONTROL;
		goto out;
d2246 23
a2268 26
	switch (hw->phy.media_type) {
	/* Autoneg flow control on fiber adapters */
	case ixgbe_media_type_fiber:
		if (speed == IXGBE_LINK_SPEED_1GB_FULL)
			ret_val = ixgbe_fc_autoneg_fiber(hw);
		break;

	/* Autoneg flow control on backplane adapters */
	case ixgbe_media_type_backplane:
		ret_val = ixgbe_fc_autoneg_backplane(hw);
		break;

	/* Autoneg flow control on copper adapters */
	case ixgbe_media_type_copper:
		if (ixgbe_device_supports_autoneg_fc(hw) == IXGBE_SUCCESS)
			ret_val = ixgbe_fc_autoneg_copper(hw);
		break;

	default:
		break;
	}

out:
	if (ret_val == IXGBE_SUCCESS) {
		hw->fc.current_mode = hw->fc.requested_mode;
		hw->fc.fc_was_autonegged = TRUE;
d2270 2
a2271 1
		hw->fc.fc_was_autonegged = FALSE;
d2273 1
a2273 1
	return ret_val;
a2278 2
 *  @@speed:
 *  @@link_up
d2285 1
a2285 1
	int32_t ret_val;
d2294 4
a2297 3
	if (((linkstat & IXGBE_PCS1GLSTA_AN_COMPLETE) == 0) ||
	    ((linkstat & IXGBE_PCS1GLSTA_AN_TIMED_OUT) == 1)) {
		ret_val = IXGBE_ERR_FC_NOT_NEGOTIATED;
d2305 4
a2308 4
			       pcs_lpab_reg, IXGBE_PCS1GANA_SYM_PAUSE,
			       IXGBE_PCS1GANA_ASM_PAUSE,
			       IXGBE_PCS1GANA_SYM_PAUSE,
			       IXGBE_PCS1GANA_ASM_PAUSE);
d2323 1
a2323 1
	int32_t ret_val;
d2332 2
a2333 3
		hw->fc.fc_was_autonegged = FALSE;
		hw->fc.current_mode = hw->fc.requested_mode;
		ret_val = IXGBE_ERR_FC_NOT_NEGOTIATED;
d2340 2
a2341 3
			hw->fc.fc_was_autonegged = FALSE;
			hw->fc.current_mode = hw->fc.requested_mode;
			ret_val = IXGBE_ERR_FC_NOT_NEGOTIATED;
d2385 1
a2385 1
 *  ixgbe_negotiate_fc - Negotiate flow control
a2386 6
 *  @@adv_reg: flow control advertised settings
 *  @@lp_reg: link partner's flow control settings
 *  @@adv_sym: symmetric pause bit in advertisement
 *  @@adv_asm: asymmetric pause bit in advertisement
 *  @@lp_sym: symmetric pause bit in link partner advertisement
 *  @@lp_asm: asymmetric pause bit in link partner advertisement
d2388 2
a2389 2
 *  Find the intersection between advertised settings and link partner's
 *  advertised settings
d2391 1
a2391 2
int32_t ixgbe_negotiate_fc(struct ixgbe_hw *hw, uint32_t adv_reg, uint32_t lp_reg,
			      uint32_t adv_sym, uint32_t adv_asm, uint32_t lp_sym, uint32_t lp_asm)
d2393 3
a2395 2
	if ((!(adv_reg)) ||  (!(lp_reg)))
		return IXGBE_ERR_FC_NOT_NEGOTIATED;
d2397 1
a2397 49
	if ((adv_reg & adv_sym) && (lp_reg & lp_sym)) {
		/*
		 * Now we need to check if the user selected Rx ONLY
		 * of pause frames.  In this case, we had to advertise
		 * FULL flow control because we could not advertise RX
		 * ONLY. Hence, we must now check to see if we need to
		 * turn OFF the TRANSMISSION of PAUSE frames.
		 */
		if (hw->fc.requested_mode == ixgbe_fc_full) {
			hw->fc.current_mode = ixgbe_fc_full;
			DEBUGOUT("Flow Control = FULL.\n");
		} else {
			hw->fc.current_mode = ixgbe_fc_rx_pause;
			DEBUGOUT("Flow Control=RX PAUSE frames only\n");
		}
	} else if (!(adv_reg & adv_sym) && (adv_reg & adv_asm) &&
		   (lp_reg & lp_sym) && (lp_reg & lp_asm)) {
		hw->fc.current_mode = ixgbe_fc_tx_pause;
		DEBUGOUT("Flow Control = TX PAUSE frames only.\n");
	} else if ((adv_reg & adv_sym) && (adv_reg & adv_asm) &&
		   !(lp_reg & lp_sym) && (lp_reg & lp_asm)) {
		hw->fc.current_mode = ixgbe_fc_rx_pause;
		DEBUGOUT("Flow Control = RX PAUSE frames only.\n");
	} else {
		hw->fc.current_mode = ixgbe_fc_none;
		DEBUGOUT("Flow Control = NONE.\n");
	}
	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_setup_fc - Set up flow control
 *  @@hw: pointer to hardware structure
 *
 *  Called at init time to set up flow control.
 **/
int32_t ixgbe_setup_fc(struct ixgbe_hw *hw, int32_t packetbuf_num)
{
	int32_t ret_val = IXGBE_SUCCESS;
	uint32_t reg = 0, reg_bp = 0;;
	uint16_t reg_cu = 0;

	/* Validate the packetbuf configuration */
	if (packetbuf_num < 0 || packetbuf_num > 7) {
		DEBUGOUT1("Invalid packet buffer number [%d], expected range is"
			  " 0-7\n", packetbuf_num);
		ret_val = IXGBE_ERR_INVALID_LINK_SETTINGS;
		goto out;
	}
d2400 4
a2403 2
	 * Validate the water mark configuration.  Zero water marks are invalid
	 * because it causes the controller to just blast out fc packets.
d2405 3
a2407 3
	if (!hw->fc.low_water || !hw->fc.high_water || !hw->fc.pause_time) {
		DEBUGOUT("Invalid water mark configuration\n");
		ret_val = IXGBE_ERR_INVALID_LINK_SETTINGS;
d2411 3
a2413 7
	/*
	 * Validate the requested mode.  Strict IEEE mode does not allow
	 * ixgbe_fc_rx_pause because it will cause us to fail at UNH.
	 */
	if (hw->fc.strict_ieee && hw->fc.requested_mode == ixgbe_fc_rx_pause) {
		DEBUGOUT("ixgbe_fc_rx_pause not valid in strict IEEE mode\n");
		ret_val = IXGBE_ERR_INVALID_LINK_SETTINGS;
a2416 12
	/*
	 * 10gig parts do not have a word in the EEPROM to determine the
	 * default flow control setting, so we explicitly set it to full.
	 */
	if (hw->fc.requested_mode == ixgbe_fc_default)
		hw->fc.requested_mode = ixgbe_fc_full;

	/*
	 * Set up the 1G and 10G flow control advertisement registers so the
	 * HW will be able to do fc autoneg once the cable is plugged in.  If
	 * we link at 10G, the 1G advertisement is harmless and vice versa.
	 */
d2418 2
d2421 5
d2427 1
a2427 2
		reg = IXGBE_READ_REG(hw, IXGBE_PCS1GANA);
		reg_bp = IXGBE_READ_REG(hw, IXGBE_AUTOC);
d2429 2
d2432 2
a2433 2
		hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_ADVT,
				     IXGBE_MDIO_AUTO_NEG_DEV_TYPE, &reg_cu);
d2435 1
d2440 33
a2472 19
	/*
	 * The possible values of fc.requested_mode are:
	 * 0: Flow control is completely disabled
	 * 1: Rx flow control is enabled (we can receive pause frames,
	 *    but not send pause frames).
	 * 2: Tx flow control is enabled (we can send pause frames but
	 *    we do not support receiving pause frames).
	 * 3: Both Rx and Tx flow control (symmetric) are enabled.
	 * other: Invalid.
	 */
	switch (hw->fc.requested_mode) {
	case ixgbe_fc_none:
		/* Flow control completely disabled by software override. */
		reg &= ~(IXGBE_PCS1GANA_SYM_PAUSE | IXGBE_PCS1GANA_ASM_PAUSE);
		if (hw->phy.media_type == ixgbe_media_type_backplane)
			reg_bp &= ~(IXGBE_AUTOC_SYM_PAUSE |
				    IXGBE_AUTOC_ASM_PAUSE);
		else if (hw->phy.media_type == ixgbe_media_type_copper)
			reg_cu &= ~(IXGBE_TAF_SYM_PAUSE | IXGBE_TAF_ASM_PAUSE);
d2474 2
a2475 15
	case ixgbe_fc_rx_pause:
		/*
		 * Rx Flow control is enabled and Tx Flow control is
		 * disabled by software override. Since there really
		 * isn't a way to advertise that we are capable of RX
		 * Pause ONLY, we will advertise that we support both
		 * symmetric and asymmetric Rx PAUSE.  Later, we will
		 * disable the adapter's ability to send PAUSE frames.
		 */
		reg |= (IXGBE_PCS1GANA_SYM_PAUSE | IXGBE_PCS1GANA_ASM_PAUSE);
		if (hw->phy.media_type == ixgbe_media_type_backplane)
			reg_bp |= (IXGBE_AUTOC_SYM_PAUSE |
				   IXGBE_AUTOC_ASM_PAUSE);
		else if (hw->phy.media_type == ixgbe_media_type_copper)
			reg_cu |= (IXGBE_TAF_SYM_PAUSE | IXGBE_TAF_ASM_PAUSE);
d2477 2
a2478 14
	case ixgbe_fc_tx_pause:
		/*
		 * Tx Flow control is enabled, and Rx Flow control is
		 * disabled by software override.
		 */
		reg |= (IXGBE_PCS1GANA_ASM_PAUSE);
		reg &= ~(IXGBE_PCS1GANA_SYM_PAUSE);
		if (hw->phy.media_type == ixgbe_media_type_backplane) {
			reg_bp |= (IXGBE_AUTOC_ASM_PAUSE);
			reg_bp &= ~(IXGBE_AUTOC_SYM_PAUSE);
		} else if (hw->phy.media_type == ixgbe_media_type_copper) {
			reg_cu |= (IXGBE_TAF_ASM_PAUSE);
			reg_cu &= ~(IXGBE_TAF_SYM_PAUSE);
		}
d2480 2
a2481 8
	case ixgbe_fc_full:
		/* Flow control (both Rx and Tx) is enabled by SW override. */
		reg |= (IXGBE_PCS1GANA_SYM_PAUSE | IXGBE_PCS1GANA_ASM_PAUSE);
		if (hw->phy.media_type == ixgbe_media_type_backplane)
			reg_bp |= (IXGBE_AUTOC_SYM_PAUSE |
				   IXGBE_AUTOC_ASM_PAUSE);
		else if (hw->phy.media_type == ixgbe_media_type_copper)
			reg_cu |= (IXGBE_TAF_SYM_PAUSE | IXGBE_TAF_ASM_PAUSE);
d2483 4
d2488 1
a2488 3
		DEBUGOUT("Flow control param set incorrectly\n");
		ret_val = IXGBE_ERR_CONFIG;
		goto out;
d2492 2
a2493 33
	if (hw->mac.type != ixgbe_mac_X540) {
		/*
		 * Enable auto-negotiation between the MAC & PHY;
		 * the MAC will advertise clause 37 flow control.
		 */
		IXGBE_WRITE_REG(hw, IXGBE_PCS1GANA, reg);
		reg = IXGBE_READ_REG(hw, IXGBE_PCS1GLCTL);

		/* Disable AN timeout */
		if (hw->fc.strict_ieee)
			reg &= ~IXGBE_PCS1GLCTL_AN_1G_TIMEOUT_EN;

		IXGBE_WRITE_REG(hw, IXGBE_PCS1GLCTL, reg);
		DEBUGOUT1("Set up FC; PCS1GLCTL = 0x%08X\n", reg);
	}

	/*
	 * AUTOC restart handles negotiation of 1G and 10G on backplane
	 * and copper. There is no need to set the PCS1GCTL register.
	 *
	 */
	if (hw->phy.media_type == ixgbe_media_type_backplane) {
		reg_bp |= IXGBE_AUTOC_AN_RESTART;
		IXGBE_WRITE_REG(hw, IXGBE_AUTOC, reg_bp);
	} else if ((hw->phy.media_type == ixgbe_media_type_copper) &&
		    (ixgbe_device_supports_autoneg_fc(hw) == IXGBE_SUCCESS)) {
		hw->phy.ops.write_reg(hw, IXGBE_MDIO_AUTO_NEG_ADVT,
				      IXGBE_MDIO_AUTO_NEG_DEV_TYPE, reg_cu);
	}

	DEBUGOUT1("Set up FC; IXGBE_AUTOC = 0x%08X\n", reg);
out:
	return ret_val;
d2507 7
a2513 4
	uint32_t i;
	uint32_t reg_val;
	uint32_t number_of_queues;
	int32_t status = IXGBE_ERR_MASTER_REQUESTS_PENDING;
d2515 1
a2515 1
	/* Just jump out if bus mastering is already disabled */
d2519 1
a2519 14
	/* Disable the receive unit by stopping each queue */
	number_of_queues = hw->mac.max_rx_queues;
	for (i = 0; i < number_of_queues; i++) {
		reg_val = IXGBE_READ_REG(hw, IXGBE_RXDCTL(i));
		if (reg_val & IXGBE_RXDCTL_ENABLE) {
			reg_val &= ~IXGBE_RXDCTL_ENABLE;
			IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(i), reg_val);
		}
	}

	reg_val = IXGBE_READ_REG(hw, IXGBE_CTRL);
	reg_val |= IXGBE_CTRL_GIO_DIS;
	IXGBE_WRITE_REG(hw, IXGBE_CTRL, reg_val);

d2521 1
d2523 1
a2523 2
			goto check_device_status;
		usec_delay(100);
d2526 8
d2535 1
a2535 1
	status = IXGBE_ERR_MASTER_REQUESTS_PENDING;
d2541 3
a2543 2
check_device_status:
	for (i = 0; i < IXGBE_PCI_MASTER_DISABLE_TIMEOUT; i++) {
d2545 2
a2546 3
			IXGBE_PCI_DEVICE_STATUS_TRANSACTION_PENDING))
			break;
		usec_delay(100);
d2549 3
a2551 14
	if (i == IXGBE_PCI_MASTER_DISABLE_TIMEOUT)
		DEBUGOUT("PCIe transaction pending bit also did not clear.\n");
	else
		goto out;

	/*
	 * Two consecutive resets are required via CTRL.RST per datasheet
	 * 5.2.5.3.2 Master Disable.  We set a flag to inform the reset routine
	 * of this need.  The first reset prevents new master requests from
	 * being issued by our device.  We then must wait 1usec for any
	 * remaining completions from the PCIe bus to trickle in, and then reset
	 * again to clear out any effects they may have had on our device.
	 */
	 hw->mac.flags |= IXGBE_FLAGS_DOUBLE_RESET_REQUIRED;
d2567 1
a2567 1
	uint32_t gssr;
d2570 4
a2573 1
	int32_t timeout = 200;
d2575 1
a2575 1
	while (timeout) {
d2577 2
a2578 2
		 * SW EEPROM semaphore bit is used for access to all
		 * SW_FW_SYNC/GSSR bits (not just EEPROM)
d2584 59
a2642 2
		if (!(gssr & (fwmask | swmask)))
			break;
a2643 8
		/*
		 * Firmware currently using resource (fwmask) or other software
		 * thread currently using resource (swmask)
		 */
		ixgbe_release_eeprom_semaphore(hw);
		msec_delay(5);
		timeout--;
	}
d2645 10
a2654 3
	if (!timeout) {
		DEBUGOUT("Driver can't access resource, SW_FW_SYNC timeout.\n");
		return IXGBE_ERR_SWFW_SYNC;
d2657 4
a2660 2
	gssr |= swmask;
	IXGBE_WRITE_REG(hw, IXGBE_GSSR, gssr);
a2661 1
	ixgbe_release_eeprom_semaphore(hw);
d2666 1
a2666 1
 *  ixgbe_release_swfw_sync - Release SWFW semaphore
a2667 1
 *  @@mask: Mask to specify which semaphore to release
d2669 1
a2669 2
 *  Releases the SWFW semaphore through the GSSR register for the specified
 *  function (CSR, PHY0, PHY1, EEPROM, Flash)
d2671 1
a2671 1
void ixgbe_release_swfw_sync(struct ixgbe_hw *hw, uint16_t mask)
d2673 1
a2673 2
	uint32_t gssr;
	uint32_t swmask = mask;
d2675 1
a2675 1
	ixgbe_get_eeprom_semaphore(hw);
d2677 4
a2680 3
	gssr = IXGBE_READ_REG(hw, IXGBE_GSSR);
	gssr &= ~swmask;
	IXGBE_WRITE_REG(hw, IXGBE_GSSR, gssr);
d2682 1
a2682 1
	ixgbe_release_eeprom_semaphore(hw);
d2694 2
d2709 1
a2709 1
	int link_up = 0;
d2712 3
d2723 15
d2741 5
d2754 2
a2755 1
	return IXGBE_SUCCESS;
d2767 17
d2789 6
d2801 2
a2802 1
	return IXGBE_SUCCESS;
d2812 1
a2812 1
uint32_t ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw)
d2814 3
a2816 1
	uint32_t msix_count = 64;
d2818 12
a2829 8
	if (hw->mac.msix_vectors_from_pcie) {
		msix_count = IXGBE_READ_PCIE_WORD(hw,
						  IXGBE_PCIE_MSIX_82599_CAPS);
		msix_count &= IXGBE_PCIE_MSIX_TBL_SZ_MASK;

		/* MSI-X count is zero-based in HW, so increment to give
		 * proper value */
		msix_count++;
d2832 10
d2862 2
d2891 1
a2891 1
		ixgbe_hw(hw, set_vmdq, rar, vmdq);
d2895 1
a2895 1
		ixgbe_hw(hw, set_rar, rar, addr, vmdq, IXGBE_RAH_AV);
d2898 1
a2898 1
		ixgbe_hw(hw, set_rar, rar, addr, vmdq, IXGBE_RAH_AV);
d2909 1
a2909 1
		ixgbe_hw(hw, clear_vmdq, rar, 0);
d2925 2
d2929 2
a2930 1
		DEBUGOUT1("RAR index %d is out of range.\n", rar);
d2975 2
d2979 2
a2980 1
		DEBUGOUT1("RAR index %d is out of range.\n", rar);
d3004 2
a3005 1
	DEBUGOUT("Clearing UTA\n");
d3052 2
a3053 1
			DEBUGOUT("No space in VLVF.\n");
d3071 1
a3071 1
			   int vlan_on)
a3075 2
	uint32_t bits;
	uint32_t vt;
d3077 4
a3080 1
	int vfta_changed = FALSE;
d3115 35
a3149 1
	 * If VT Mode is set
d3159 1
d3169 1
a3169 1
						IXGBE_VLVFB(vlvf_index*2));
d3172 1
a3172 1
						IXGBE_VLVFB(vlvf_index*2),
d3176 2
a3177 2
						IXGBE_VLVFB((vlvf_index*2)+1));
				bits |= (1 << (vind-32));
d3179 2
a3180 2
						IXGBE_VLVFB((vlvf_index*2)+1),
						bits);
d3186 1
a3186 1
						IXGBE_VLVFB(vlvf_index*2));
d3189 1
a3189 1
						IXGBE_VLVFB(vlvf_index*2),
d3192 1
a3192 1
						IXGBE_VLVFB((vlvf_index*2)+1));
d3195 2
a3196 2
						IXGBE_VLVFB((vlvf_index*2)+1));
				bits &= ~(1 << (vind-32));
d3198 2
a3199 2
						IXGBE_VLVFB((vlvf_index*2)+1),
						bits);
d3201 1
a3201 1
						IXGBE_VLVFB(vlvf_index*2));
d3223 1
a3223 1
			if (!vlan_on) {
d3227 67
a3293 1
				vfta_changed = FALSE;
d3295 2
d3298 3
d3302 1
a3302 1
			IXGBE_WRITE_REG(hw, IXGBE_VLVF(vlvf_index), 0);
d3305 28
a3332 2
	if (vfta_changed)
		IXGBE_WRITE_REG(hw, IXGBE_VFTA(regindex), vfta);
d3338 136
a3473 1
 *  ixgbe_clear_vfta_generic - Clear VLAN filter table
d3476 1
a3476 1
 *  Clears the VLAN filer table, and the VMDq index associated with the filter
d3478 1
a3478 1
int32_t ixgbe_clear_vfta_generic(struct ixgbe_hw *hw)
d3480 1
a3480 1
	uint32_t offset;
d3482 5
a3486 7
	for (offset = 0; offset < hw->mac.vft_size; offset++)
		IXGBE_WRITE_REG(hw, IXGBE_VFTA(offset), 0);

	for (offset = 0; offset < IXGBE_VLVF_ENTRIES; offset++) {
		IXGBE_WRITE_REG(hw, IXGBE_VLVF(offset), 0);
		IXGBE_WRITE_REG(hw, IXGBE_VLVFB(offset*2), 0);
		IXGBE_WRITE_REG(hw, IXGBE_VLVFB((offset*2)+1), 0);
d3489 1
a3489 1
	return IXGBE_SUCCESS;
d3493 1
a3493 1
 *  ixgbe_check_mac_link_generic - Determine link and speed status
a3494 3
 *  @@speed: pointer to link speed
 *  @@link_up: TRUE when link is up
 *  @@link_up_wait_to_complete: bool used to wait for link up or not
d3498 2
a3499 2
int32_t ixgbe_check_mac_link_generic(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
			       int *link_up, int link_up_wait_to_complete)
d3501 3
a3503 40
	uint32_t links_reg, links_orig;
	uint32_t i;

	/* clear the old state */
	links_orig = IXGBE_READ_REG(hw, IXGBE_LINKS);

	links_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);

	if (links_orig != links_reg) {
		DEBUGOUT2("LINKS changed from %08X to %08X\n",
			  links_orig, links_reg);
	}

	if (link_up_wait_to_complete) {
		for (i = 0; i < IXGBE_LINK_UP_TIME; i++) {
			if (links_reg & IXGBE_LINKS_UP) {
				*link_up = TRUE;
				break;
			} else {
				*link_up = FALSE;
			}
			msec_delay(100);
			links_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);
		}
	} else {
		if (links_reg & IXGBE_LINKS_UP)
			*link_up = TRUE;
		else
			*link_up = FALSE;
	}

	if ((links_reg & IXGBE_LINKS_SPEED_82599) ==
	    IXGBE_LINKS_SPEED_10G_82599)
		*speed = IXGBE_LINK_SPEED_10GB_FULL;
	else if ((links_reg & IXGBE_LINKS_SPEED_82599) ==
		 IXGBE_LINKS_SPEED_1G_82599)
		*speed = IXGBE_LINK_SPEED_1GB_FULL;
	else if ((links_reg & IXGBE_LINKS_SPEED_82599) ==
		 IXGBE_LINKS_SPEED_100_82599)
		*speed = IXGBE_LINK_SPEED_100_FULL;
d3505 2
a3506 1
		*speed = IXGBE_LINK_SPEED_UNKNOWN;
d3508 12
a3519 1
	return IXGBE_SUCCESS;
d3523 1
a3523 2
 *  ixgbe_device_supports_autoneg_fc - Check if phy supports autoneg flow
 *  control
d3525 4
d3530 1
a3530 3
 *  There are several phys that do not support autoneg flow control. This
 *  function check the device id to see if the associated phy supports
 *  autoneg flow control.
d3532 2
a3533 1
int32_t ixgbe_device_supports_autoneg_fc(struct ixgbe_hw *hw)
d3535 4
a3538 8
	switch (hw->device_id) {
	case IXGBE_DEV_ID_X540T:
		return IXGBE_SUCCESS;
	case IXGBE_DEV_ID_82599_T3_LOM:
		return IXGBE_SUCCESS;
	default:
		return IXGBE_ERR_FC_NOT_SUPPORTED;
	}
d3542 1
a3542 1
 *  ixgbe_get_device_caps_generic - Get additional device capabilities
d3544 2
a3545 4
 *  @@device_caps: the EEPROM word with the extra device capabilities
 *
 *  This function will read the EEPROM location for the device capabilities,
 *  and return the word through device_caps.
d3547 1
a3547 1
int32_t ixgbe_get_device_caps_generic(struct ixgbe_hw *hw, uint16_t *device_caps)
d3549 5
a3553 1
	hw->eeprom.ops.read(hw, IXGBE_DEVICE_CAPS, device_caps);
d3555 12
a3566 1
	return IXGBE_SUCCESS;
d3570 1
a3570 1
 *  ixgbe_enable_relaxed_ordering_gen2 - Enable relaxed ordering
d3573 2
d3576 1
a3576 1
void ixgbe_enable_relaxed_ordering_gen2(struct ixgbe_hw *hw)
d3578 5
a3582 2
	uint32_t regval;
	uint32_t i;
d3584 7
a3590 15
	DEBUGFUNC("ixgbe_enable_relaxed_ordering_gen2");

	/* Enable relaxed ordering */
	for (i = 0; i < hw->mac.max_tx_queues; i++) {
		regval = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL_82599(i));
		regval |= IXGBE_DCA_TXCTRL_TX_WB_RO_EN;
		IXGBE_WRITE_REG(hw, IXGBE_DCA_TXCTRL_82599(i), regval);
	}

	for (i = 0; i < hw->mac.max_rx_queues; i++) {
		regval = IXGBE_READ_REG(hw, IXGBE_DCA_RXCTRL(i));
		regval |= (IXGBE_DCA_RXCTRL_DESC_WRO_EN |
			   IXGBE_DCA_RXCTRL_DESC_HSRO_EN);
		IXGBE_WRITE_REG(hw, IXGBE_DCA_RXCTRL(i), regval);
	}
d3592 6
a3862 221
/**
 *  ixgbe_check_for_bit_vf - Determine if a status bit was set
 *  @@hw: pointer to the HW structure
 *  @@mask: bitmask for bits to be tested and cleared
 *
 *  This function is used to check for the read to clear bits within
 *  the V2P mailbox.
 **/
int32_t ixgbe_check_for_bit_vf(struct ixgbe_hw *hw, uint32_t mask)
{
	uint32_t v2p_mailbox = ixgbe_read_v2p_mailbox(hw);
	int32_t ret_val = IXGBE_ERR_MBX;

	if (v2p_mailbox & mask)
		ret_val = IXGBE_SUCCESS;

	hw->mbx.v2p_mailbox &= ~mask;

	return ret_val;
}

/**
 *  ixgbe_check_for_msg_vf - checks to see if the PF has sent mail
 *  @@hw: pointer to the HW structure
 *  @@mbx_id: id of mailbox to check
 *
 *  returns SUCCESS if the PF has set the Status bit or else ERR_MBX
 **/
int32_t ixgbe_check_for_msg_vf(struct ixgbe_hw *hw, uint16_t mbx_id)
{
	int32_t ret_val = IXGBE_ERR_MBX;

	UNREFERENCED_PARAMETER(mbx_id);
	DEBUGFUNC("ixgbe_check_for_msg_vf");

	if (!ixgbe_check_for_bit_vf(hw, IXGBE_VFMAILBOX_PFSTS)) {
		ret_val = IXGBE_SUCCESS;
		hw->mbx.stats.reqs++;
	}

	return ret_val;
}

/**
 *  ixgbe_check_for_ack_vf - checks to see if the PF has ACK'd
 *  @@hw: pointer to the HW structure
 *  @@mbx_id: id of mailbox to check
 *
 *  returns SUCCESS if the PF has set the ACK bit or else ERR_MBX
 **/
int32_t ixgbe_check_for_ack_vf(struct ixgbe_hw *hw, uint16_t mbx_id)
{
	int32_t ret_val = IXGBE_ERR_MBX;

	UNREFERENCED_PARAMETER(mbx_id);
	DEBUGFUNC("ixgbe_check_for_ack_vf");

	if (!ixgbe_check_for_bit_vf(hw, IXGBE_VFMAILBOX_PFACK)) {
		ret_val = IXGBE_SUCCESS;
		hw->mbx.stats.acks++;
	}

	return ret_val;
}

/**
 *  ixgbe_check_for_rst_vf - checks to see if the PF has reset
 *  @@hw: pointer to the HW structure
 *  @@mbx_id: id of mailbox to check
 *
 *  returns TRUE if the PF has set the reset done bit or else FALSE
 **/
int32_t ixgbe_check_for_rst_vf(struct ixgbe_hw *hw, uint16_t mbx_id)
{
	int32_t ret_val = IXGBE_ERR_MBX;

	UNREFERENCED_PARAMETER(mbx_id);
	DEBUGFUNC("ixgbe_check_for_rst_vf");

	if (!ixgbe_check_for_bit_vf(hw, (IXGBE_VFMAILBOX_RSTD |
					 IXGBE_VFMAILBOX_RSTI))) {
		ret_val = IXGBE_SUCCESS;
		hw->mbx.stats.rsts++;
	}

	return ret_val;
}

/**
 *  ixgbe_obtain_mbx_lock_vf - obtain mailbox lock
 *  @@hw: pointer to the HW structure
 *
 *  return SUCCESS if we obtained the mailbox lock
 **/
int32_t ixgbe_obtain_mbx_lock_vf(struct ixgbe_hw *hw)
{
	int32_t ret_val = IXGBE_ERR_MBX;

	DEBUGFUNC("ixgbe_obtain_mbx_lock_vf");

	/* Take ownership of the buffer */
	IXGBE_WRITE_REG(hw, IXGBE_VFMAILBOX, IXGBE_VFMAILBOX_VFU);

	/* reserve mailbox for vf use */
	if (ixgbe_read_v2p_mailbox(hw) & IXGBE_VFMAILBOX_VFU)
		ret_val = IXGBE_SUCCESS;

	return ret_val;
}

/**
 *  ixgbe_write_mbx_vf - Write a message to the mailbox
 *  @@hw: pointer to the HW structure
 *  @@msg: The message buffer
 *  @@size: Length of buffer
 *  @@mbx_id: id of mailbox to write
 *
 *  returns SUCCESS if it successfully copied message into the buffer
 **/
int32_t ixgbe_write_mbx_vf(struct ixgbe_hw *hw, uint32_t *msg, uint16_t size,
			      uint16_t mbx_id)
{
	int32_t ret_val;
	uint16_t i;

	UNREFERENCED_PARAMETER(mbx_id);

	DEBUGFUNC("ixgbe_write_mbx_vf");

	/* lock the mailbox to prevent pf/vf race condition */
	ret_val = ixgbe_obtain_mbx_lock_vf(hw);
	if (ret_val)
		goto out_no_write;

	/* flush msg and acks as we are overwriting the message buffer */
	ixgbe_check_for_msg_vf(hw, 0);
	ixgbe_check_for_ack_vf(hw, 0);

	/* copy the caller specified message to the mailbox memory buffer */
	for (i = 0; i < size; i++)
		IXGBE_WRITE_REG_ARRAY(hw, IXGBE_VFMBMEM, i, msg[i]);

	/* update stats */
	hw->mbx.stats.msgs_tx++;

	/* Drop VFU and interrupt the PF to tell it a message has been sent */
	IXGBE_WRITE_REG(hw, IXGBE_VFMAILBOX, IXGBE_VFMAILBOX_REQ);

out_no_write:
	return ret_val;
}

/**
 *  ixgbe_read_mbx_vf - Reads a message from the inbox intended for vf
 *  @@hw: pointer to the HW structure
 *  @@msg: The message buffer
 *  @@size: Length of buffer
 *  @@mbx_id: id of mailbox to read
 *
 *  returns SUCCESS if it successfuly read message from buffer
 **/
int32_t ixgbe_read_mbx_vf(struct ixgbe_hw *hw, uint32_t *msg, uint16_t size,
			     uint16_t mbx_id)
{
	int32_t ret_val = IXGBE_SUCCESS;
	uint16_t i;

	DEBUGFUNC("ixgbe_read_mbx_vf");
	UNREFERENCED_PARAMETER(mbx_id);

	/* lock the mailbox to prevent pf/vf race condition */
	ret_val = ixgbe_obtain_mbx_lock_vf(hw);
	if (ret_val)
		goto out_no_read;

	/* copy the message from the mailbox memory buffer */
	for (i = 0; i < size; i++)
		msg[i] = IXGBE_READ_REG_ARRAY(hw, IXGBE_VFMBMEM, i);

	/* Acknowledge receipt and release mailbox, then we're done */
	IXGBE_WRITE_REG(hw, IXGBE_VFMAILBOX, IXGBE_VFMAILBOX_ACK);

	/* update stats */
	hw->mbx.stats.msgs_rx++;

out_no_read:
	return ret_val;
}

/**
 *  ixgbe_init_mbx_params_vf - set initial values for vf mailbox
 *  @@hw: pointer to the HW structure
 *
 *  Initializes the hw->mbx struct to correct values for vf mailbox
 */
void ixgbe_init_mbx_params_vf(struct ixgbe_hw *hw)
{
	struct ixgbe_mbx_info *mbx = &hw->mbx;

	/* start mailbox as timed out and let the reset_hw call set the timeout
	 * value to begin communications */
	mbx->timeout = 0;
	mbx->usec_delay = IXGBE_VF_MBX_INIT_DELAY;

	mbx->size = IXGBE_VFMAILBOX_SIZE;

	mbx->ops.read = ixgbe_read_mbx_vf;
	mbx->ops.write = ixgbe_write_mbx_vf;
	mbx->ops.read_posted = ixgbe_read_posted_mbx;
	mbx->ops.write_posted = ixgbe_write_posted_mbx;
	mbx->ops.check_for_msg = ixgbe_check_for_msg_vf;
	mbx->ops.check_for_ack = ixgbe_check_for_ack_vf;
	mbx->ops.check_for_rst = ixgbe_check_for_rst_vf;

	mbx->stats.msgs_tx = 0;
	mbx->stats.msgs_rx = 0;
	mbx->stats.reqs = 0;
	mbx->stats.acks = 0;
	mbx->stats.rsts = 0;
}

d3995 1
a3995 1
			      uint16_t vf_number)
d4038 1
a4038 1
			     uint16_t vf_number)
@


1.11
log
@Fix a link autonegotiation bug on 10GbaseT controllers and improve
link information reporting in general.  Obtained for the most part
from FreeBSD, tested by mxb at alumni ! chalmers ! se on X540 and
me on 82598 (XAUI, KR4), 82599 (SFP+) and X540 (baseT); ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.10 2012/12/05 14:41:28 mikeb Exp $	*/
d1903 1
a1906 1
		hw->fc.current_mode = hw->fc.requested_mode;
@


1.10
log
@minor cleanup, whitespaces, mostly synced with freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.9 2012/11/06 17:29:39 mikeb Exp $	*/
a2901 6

	/* if link is down, zero out the current_mode */
	if (*link_up == FALSE) {
		hw->fc.current_mode = ixgbe_fc_none;
		hw->fc.fc_was_autonegged = FALSE;
	}
@


1.9
log
@Remove Flow Director code that is not used, is outdated and tends
to get in the way.  ok krw, brad
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.8 2012/08/06 21:07:52 mikeb Exp $	*/
d45 1
a45 1
					uint16_t count);
d56 3
a58 3
int32_t ixgbe_negotiate_fc(struct ixgbe_hw *hw, uint32_t adv_reg, uint32_t lp_reg,
			      uint32_t adv_sym, uint32_t adv_asm, uint32_t lp_sym, uint32_t lp_asm);

d72 1
a72 1
			      uint16_t mbx_id);
d74 3
a76 2
			      uint16_t mbx_id);
int32_t ixgbe_check_for_bit_pf(struct ixgbe_hw *hw, uint32_t mask, int32_t index);
d82 1
a82 1
			     uint16_t vf_number);
d84 1
a84 1
			     uint16_t vf_number);
d102 1
a102 1
	if (eec & (1 << 8))
d230 1
a230 1
					IXGBE_DCA_RXCTRL_DESC_HSRO_EN);
a2122 1

a2128 1

d2131 1
a2131 1
					IXGBE_MDIO_AUTO_NEG_DEV_TYPE, &reg_cu);
a2132 1

d2134 1
a2134 1
		;
@


1.8
log
@Add support for 10Gb ethernet cards based on the Intel X540 chipset.
The code was obtained from FreeBSD and tested on the hardware kindly
donated by Tony Sarendal <tony () polarcap ! org>.  Thanks a lot!

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.7 2012/07/29 13:49:03 mikeb Exp $	*/
a367 199

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_read_pba_string_generic - Reads part number string from EEPROM
 *  @@hw: pointer to hardware structure
 *  @@pba_num: stores the part number string from the EEPROM
 *  @@pba_num_size: part number string buffer length
 *
 *  Reads the part number string from the EEPROM.
 **/
int32_t ixgbe_read_pba_string_generic(struct ixgbe_hw *hw, uint8_t *pba_num,
				  uint32_t pba_num_size)
{
	int32_t ret_val;
	uint16_t data;
	uint16_t pba_ptr;
	uint16_t offset;
	uint16_t length;

	if (pba_num == NULL) {
		DEBUGOUT("PBA string buffer was null\n");
		return IXGBE_ERR_INVALID_ARGUMENT;
	}

	ret_val = hw->eeprom.ops.read(hw, IXGBE_PBANUM0_PTR, &data);
	if (ret_val) {
		DEBUGOUT("NVM Read Error\n");
		return ret_val;
	}

	ret_val = hw->eeprom.ops.read(hw, IXGBE_PBANUM1_PTR, &pba_ptr);
	if (ret_val) {
		DEBUGOUT("NVM Read Error\n");
		return ret_val;
	}

	/*
	 * if data is not ptr guard the PBA must be in legacy format which
	 * means pba_ptr is actually our second data word for the PBA number
	 * and we can decode it into an ascii string
	 */
	if (data != IXGBE_PBANUM_PTR_GUARD) {
		DEBUGOUT("NVM PBA number is not stored as string\n");

		/* we will need 11 characters to store the PBA */
		if (pba_num_size < 11) {
			DEBUGOUT("PBA string buffer too small\n");
			return IXGBE_ERR_NO_SPACE;
		}

		/* extract hex string from data and pba_ptr */
		pba_num[0] = (data >> 12) & 0xF;
		pba_num[1] = (data >> 8) & 0xF;
		pba_num[2] = (data >> 4) & 0xF;
		pba_num[3] = data & 0xF;
		pba_num[4] = (pba_ptr >> 12) & 0xF;
		pba_num[5] = (pba_ptr >> 8) & 0xF;
		pba_num[6] = '-';
		pba_num[7] = 0;
		pba_num[8] = (pba_ptr >> 4) & 0xF;
		pba_num[9] = pba_ptr & 0xF;

		/* put a null character on the end of our string */
		pba_num[10] = '\0';

		/* switch all the data but the '-' to hex char */
		for (offset = 0; offset < 10; offset++) {
			if (pba_num[offset] < 0xA)
				pba_num[offset] += '0';
			else if (pba_num[offset] < 0x10)
				pba_num[offset] += 'A' - 0xA;
		}

		return IXGBE_SUCCESS;
	}

	ret_val = hw->eeprom.ops.read(hw, pba_ptr, &length);
	if (ret_val) {
		DEBUGOUT("NVM Read Error\n");
		return ret_val;
	}

	if (length == 0xFFFF || length == 0) {
		DEBUGOUT("NVM PBA number section invalid length\n");
		return IXGBE_ERR_PBA_SECTION;
	}

	/* check if pba_num buffer is big enough */
	if (pba_num_size  < (((uint32_t)length * 2) - 1)) {
		DEBUGOUT("PBA string buffer too small\n");
		return IXGBE_ERR_NO_SPACE;
	}

	/* trim pba length from start of string */
	pba_ptr++;
	length--;

	for (offset = 0; offset < length; offset++) {
		ret_val = hw->eeprom.ops.read(hw, pba_ptr + offset, &data);
		if (ret_val) {
			DEBUGOUT("NVM Read Error\n");
			return ret_val;
		}
		pba_num[offset * 2] = (uint8_t)(data >> 8);
		pba_num[(offset * 2) + 1] = (uint8_t)(data & 0xFF);
	}
	pba_num[offset * 2] = '\0';

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_read_pba_length_generic - Reads part number length from EEPROM
 *  @@hw: pointer to hardware structure
 *  @@pba_num_size: part number string buffer length
 *
 *  Reads the part number length from the EEPROM.
 *  Returns expected buffer size in pba_num_size
 **/
int32_t ixgbe_read_pba_length_generic(struct ixgbe_hw *hw, uint32_t *pba_num_size)
{
	int32_t ret_val;
	uint16_t data;
	uint16_t pba_ptr;
	uint16_t length;

	if (pba_num_size == NULL) {
		DEBUGOUT("PBA buffer size was null\n");
		return IXGBE_ERR_INVALID_ARGUMENT;
	}

	ret_val = hw->eeprom.ops.read(hw, IXGBE_PBANUM0_PTR, &data);
	if (ret_val) {
		DEBUGOUT("NVM Read Error\n");
		return ret_val;
	}

	ret_val = hw->eeprom.ops.read(hw, IXGBE_PBANUM1_PTR, &pba_ptr);
	if (ret_val) {
		DEBUGOUT("NVM Read Error\n");
		return ret_val;
	}

	 /* if data is not ptr guard the PBA must be in legacy format */
	if (data != IXGBE_PBANUM_PTR_GUARD) {
		*pba_num_size = 11;
		return IXGBE_SUCCESS;
	}

	ret_val = hw->eeprom.ops.read(hw, pba_ptr, &length);
	if (ret_val) {
		DEBUGOUT("NVM Read Error\n");
		return ret_val;
	}

	if (length == 0xFFFF || length == 0) {
		DEBUGOUT("NVM PBA number section invalid length\n");
		return IXGBE_ERR_PBA_SECTION;
	}

	/*
	 * Convert from length in 16bit values to 8bit chars, add 1 for NULL,
	 * and subtract 2 because length field is included in length.
	 */
	*pba_num_size = ((uint32_t)length * 2) - 1;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_read_pba_num_generic - Reads part number from EEPROM
 *  @@hw: pointer to hardware structure
 *  @@pba_num: stores the part number from the EEPROM
 *
 *  Reads the part number from the EEPROM.
 **/
int32_t ixgbe_read_pba_num_generic(struct ixgbe_hw *hw, uint32_t *pba_num)
{
	int32_t ret_val;
	uint16_t data;

	ret_val = hw->eeprom.ops.read(hw, IXGBE_PBANUM0_PTR, &data);
	if (ret_val) {
		DEBUGOUT("NVM Read Error\n");
		return ret_val;
	} else if (data == IXGBE_PBANUM_PTR_GUARD) {
		DEBUGOUT("NVM Not supported\n");
		return IXGBE_NOT_IMPLEMENTED;
	}
	*pba_num = (uint32_t)(data << 16);

	ret_val = hw->eeprom.ops.read(hw, IXGBE_PBANUM1_PTR, &data);
	if (ret_val) {
		DEBUGOUT("NVM Read Error\n");
		return ret_val;
	}
	*pba_num |= data;
@


1.7
log
@whitespace cleanup, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.6 2011/06/10 12:46:35 claudio Exp $	*/
d356 13
d1054 2
a1055 1
	if (ixgbe_acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM) != IXGBE_SUCCESS)
d1078 1
a1078 1
			ixgbe_release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
d1385 1
a1385 1
	ixgbe_release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
d2405 7
a2411 6
	/*
	 * Enable auto-negotiation between the MAC & PHY;
	 * the MAC will advertise clause 37 flow control.
	 */
	IXGBE_WRITE_REG(hw, IXGBE_PCS1GANA, reg);
	reg = IXGBE_READ_REG(hw, IXGBE_PCS1GLCTL);
d2413 3
a2415 3
	/* Disable AN timeout */
	if (hw->fc.strict_ieee)
		reg &= ~IXGBE_PCS1GLCTL_AN_1G_TIMEOUT_EN;
d2417 3
a2419 2
	IXGBE_WRITE_REG(hw, IXGBE_PCS1GLCTL, reg);
	DEBUGOUT1("Set up FC; PCS1GLCTL = 0x%08X\n", reg);
a2513 1

d2519 1
a2519 1
 *  Acquires the SWFW semaphore thought the GSSR register for the specified
d2567 1
a2567 1
 *  Releases the SWFW semaphore thought the GSSR register for the specified
d3125 2
d3742 3
a3745 1
		goto out;
a3754 1
out:
d3872 2
a3873 1
	if (hw->mac.type != ixgbe_mac_82599EB)
@


1.6
log
@Monster update of ix(4). This brings ix(4) close to what is currently
in FreeBSD. This seems to fix a lot of problems on 82599 based cards
including the VLAN problems and the corrupted receives.
Putting this in now to work on it in tree since a few additional things
need to be merged. Tested by myself, deraadt@@ and jsg@@ on both 98er and
99er cards.
OK jsg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.5 2010/02/19 18:55:12 jsg Exp $	*/
d5 1
a5 1
  Copyright (c) 2001-2009, Intel Corporation 
d7 2
a8 2
  
  Redistribution and use in source and binary forms, with or without 
d10 2
a11 2
  
   1. Redistributions of source code must retain the above copyright notice, 
d13 3
a15 3
  
   2. Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
d17 3
a19 3
  
   3. Neither the name of the Intel Corporation nor the names of its 
      contributors may be used to endorse or promote products derived from 
d21 1
a21 1
  
d23 8
a30 8
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
d45 1
a45 1
                                        uint16_t count);
d57 1
a57 1
                              uint32_t adv_sym, uint32_t adv_asm, uint32_t lp_sym, uint32_t lp_asm);
d72 1
a72 1
                              uint16_t mbx_id);
d74 1
a74 1
                              uint16_t mbx_id);
d81 1
a81 1
                             uint16_t vf_number);
d83 1
a83 1
                             uint16_t vf_number);
d107 1
a107 1
	                              &ixgbe_validate_eeprom_checksum_generic;
d368 1
a368 1
                                  uint32_t pba_num_size)
d779 1
a779 1
			                    IXGBE_EEC_SIZE_SHIFT);
d781 1
a781 1
			                     IXGBE_EEPROM_WORD_SIZE_BASE_SHIFT);
d789 2
a790 2
		          "%d\n", eeprom->type, eeprom->word_size,
		          eeprom->address_bits);
d832 1
a832 1
		                            IXGBE_EEPROM_OPCODE_BITS);
d845 1
a845 1
		                            IXGBE_EEPROM_OPCODE_BITS);
d847 1
a847 1
		                            hw->eeprom.address_bits);
d871 1
a871 1
                                       uint16_t *data)
d906 1
a906 1
		                            IXGBE_EEPROM_OPCODE_BITS);
d908 1
a908 1
		                            hw->eeprom.address_bits);
d950 1
a950 1
		         IXGBE_EEPROM_RW_REG_DATA);
d1133 1
a1133 1
			         "not granted.\n");
d1139 1
a1139 1
		         "not granted.\n");
d1181 1
a1181 1
		                            IXGBE_EEPROM_OPCODE_BITS);
d1230 1
a1230 1
                                        uint16_t count)
d1430 1
a1430 1
                                           uint16_t *checksum_val)
d1484 1
a1484 1
		                              checksum);
d1512 1
a1512 1
	           mac_addr[3] == 0 && mac_addr[4] == 0 && mac_addr[5] == 0) {
d1530 1
a1530 1
                          uint32_t enable_addr)
d1550 3
a1552 3
	           ((uint32_t)addr[1] << 8) |
	           ((uint32_t)addr[2] << 16) |
	           ((uint32_t)addr[3] << 24));
d1630 2
a1631 2
		          hw->mac.addr[0], hw->mac.addr[1],
		          hw->mac.addr[2]);
d1633 1
a1633 1
		          hw->mac.addr[4], hw->mac.addr[5]);
d1638 2
a1639 2
		          hw->mac.addr[0], hw->mac.addr[1],
		          hw->mac.addr[2]);
d1641 1
a1641 1
		          hw->mac.addr[4], hw->mac.addr[5]);
d1685 1
a1685 1
	          addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
d1718 1
a1718 1
                                      uint32_t addr_count, ixgbe_mc_addr_itr next)
d1856 1
a1856 1
                                      uint32_t mc_addr_count, ixgbe_mc_addr_itr next)
d1885 1
a1885 1
		                IXGBE_MCSTCTRL_MFE | hw->mac.mc_filter_type);
d1903 1
a1903 1
		                hw->mac.mc_filter_type);
d2270 1
a2270 1
		          " 0-7\n", packetbuf_num);
d2652 1
a2652 1
		                                  IXGBE_PCIE_MSIX_82599_CAPS);
d2879 1
a2879 1
                           int vlan_on)
d3044 1
a3044 1
                               int *link_up, int link_up_wait_to_complete)
d3056 1
a3056 1
		          links_orig, links_reg);
d3081 1
a3081 1
	         IXGBE_LINKS_SPEED_1G_82599)
d3084 1
a3084 1
	         IXGBE_LINKS_SPEED_100_82599)
d3154 1
a3154 1
		           IXGBE_DCA_RXCTRL_DESC_HSRO_EN);
d3371 1
a3371 1
                           uint16_t mbx_id)
d3503 1
a3503 1
	                                 IXGBE_VFMAILBOX_RSTI))) {
d3543 1
a3543 1
                              uint16_t mbx_id)
d3585 1
a3585 1
                             uint16_t mbx_id)
d3673 1
a3673 1
	                            index)) {
d3697 1
a3697 1
	                            index)) {
d3775 1
a3775 1
                              uint16_t vf_number)
d3818 1
a3818 1
                             uint16_t vf_number)
a3875 1

@


1.5
log
@Partial sync to the latest version of ixgbe in FreeBSD leaving things
like if_ix.c mostly untouched for now.  This brings in support for
newer 82598 parts and adds several things that will be needed for 82599.

Initially from claudio with some additions by me.

Tested by claudio, dlg (earlier version) and myself on different cards
and media types.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.4 2009/08/08 09:30:01 jsg Exp $	*/
a49 1
uint16_t ixgbe_calc_eeprom_checksum(struct ixgbe_hw *hw);
d52 8
d62 24
a169 1
	int32_t ret_val = IXGBE_SUCCESS;
d194 40
a233 1
	return ret_val;
a342 1
		IXGBE_READ_REG(hw, IXGBE_QBRC(i));
d344 171
a514 1
		IXGBE_READ_REG(hw, IXGBE_QBTC(i));
d517 6
d542 3
d706 1
a706 2
	if (ixgbe_disable_pcie_master(hw) != IXGBE_SUCCESS)
		DEBUGOUT("PCI-E Master disable polling has failed.\n");
d959 41
a1066 1
	}
d1068 8
a1075 7
	/* Setup EEPROM for Read/Write */
	if (status == IXGBE_SUCCESS) {
		/* Clear CS and SK */
		eec &= ~(IXGBE_EEC_CS | IXGBE_EEC_SK);
		IXGBE_WRITE_REG(hw, IXGBE_EEC, eec);
		IXGBE_WRITE_FLUSH(hw);
		usec_delay(1);
d1535 6
d1545 16
a1560 17
	if (index < rar_entries) {
		/*
		 * HW expects these in little endian so we reverse the byte
		 * order from network order (big endian) to little endian
		 */
		rar_low = ((uint32_t)addr[0] |
		           ((uint32_t)addr[1] << 8) |
		           ((uint32_t)addr[2] << 16) |
		           ((uint32_t)addr[3] << 24));
		/*
		 * Some parts put the VMDq setting in the extra RAH bits,
		 * so save everything except the lower 16 bits that hold part
		 * of the address and the address valid bit.
		 */
		rar_high = IXGBE_READ_REG(hw, IXGBE_RAH(index));
		rar_high &= ~(0x0000FFFF | IXGBE_RAH_AV);
		rar_high |= ((uint32_t)addr[4] | ((uint32_t)addr[5] << 8));
d1562 2
a1563 2
		if (enable_addr != 0)
			rar_high |= IXGBE_RAH_AV;
d1565 2
a1566 5
		IXGBE_WRITE_REG(hw, IXGBE_RAL(index), rar_low);
		IXGBE_WRITE_REG(hw, IXGBE_RAH(index), rar_high);
	} else {
		DEBUGOUT1("RAR index %d is out of range.\n", index);
	}
d1584 1
a1584 12
	if (index < rar_entries) {
		/*
		 * Some parts put the VMDq setting in the extra RAH bits,
		 * so save everything except the lower 16 bits that hold part
		 * of the address and the address valid bit.
		 */
		rar_high = IXGBE_READ_REG(hw, IXGBE_RAH(index));
		rar_high &= ~(0x0000FFFF | IXGBE_RAH_AV);

		IXGBE_WRITE_REG(hw, IXGBE_RAL(index), 0);
		IXGBE_WRITE_REG(hw, IXGBE_RAH(index), rar_high);
	} else {
d1586 1
d1589 11
d1644 3
a1822 1
	uint32_t mta_reg;
d1840 1
a1840 3
	mta_reg = IXGBE_READ_REG(hw, IXGBE_MTA(vector_reg));
	mta_reg |= (1 << vector_bit);
	IXGBE_WRITE_REG(hw, IXGBE_MTA(vector_reg), mta_reg);
d1868 1
a1868 1
	/* Clear the MTA */
d1870 1
a1870 2
	for (i = 0; i < hw->mac.mcft_size; i++)
		IXGBE_WRITE_REG(hw, IXGBE_MTA(i), 0);
d1872 1
a1872 1
	/* Add the new addresses */
d1879 4
d1937 1
d1941 1
a1941 1
	if (ret_val)
d1963 2
a1964 1
		/* Flow control is disabled by software override or autoneg.
d2003 5
a2007 27
	reg = IXGBE_READ_REG(hw, IXGBE_MTQC);
	/* Thresholds are different for link flow control when in DCB mode */
	if (reg & IXGBE_MTQC_RT_ENA) {
		rx_pba_size = IXGBE_READ_REG(hw, IXGBE_RXPBSIZE(packetbuf_num));

		/* Always disable XON for LFC when in DCB mode */
		reg = (rx_pba_size >> 5) & 0xFFE0;
		IXGBE_WRITE_REG(hw, IXGBE_FCRTL_82599(packetbuf_num), reg);

		reg = (rx_pba_size >> 2) & 0xFFE0;
		if (hw->fc.current_mode & ixgbe_fc_tx_pause)
			reg |= IXGBE_FCRTH_FCEN;
		IXGBE_WRITE_REG(hw, IXGBE_FCRTH_82599(packetbuf_num), reg);
	} else {
		/* Set up and enable Rx high/low water mark thresholds,
		 * enable XON. */
		if (hw->fc.current_mode & ixgbe_fc_tx_pause) {
			if (hw->fc.send_xon) {
				IXGBE_WRITE_REG(hw,
				              IXGBE_FCRTL_82599(packetbuf_num),
				              (hw->fc.low_water |
				              IXGBE_FCRTL_XONE));
			} else {
				IXGBE_WRITE_REG(hw,
				              IXGBE_FCRTL_82599(packetbuf_num),
				              hw->fc.low_water);
			}
d2009 4
a2012 3
			IXGBE_WRITE_REG(hw, IXGBE_FCRTH_82599(packetbuf_num),
			               (hw->fc.high_water | IXGBE_FCRTH_FCEN));
		}
d2015 3
a2042 2
	uint32_t pcs_anadv_reg, pcs_lpab_reg, linkstat;
	uint32_t links2, anlp1_reg, autoc_reg, links;
d2045 3
d2058 26
d2085 4
a2088 1
	if (hw->fc.disable_fc_autoneg || (!link_up)) {
a2090 1
		goto out;
d2092 2
d2095 12
a2106 22
	/*
	 * On backplane, bail out if
	 * - backplane autoneg was not completed, or if
	 * - we are 82599 and link partner is not AN enabled
	 */
	if (hw->phy.media_type == ixgbe_media_type_backplane) {
		links = IXGBE_READ_REG(hw, IXGBE_LINKS);
		if ((links & IXGBE_LINKS_KX_AN_COMP) == 0) {
			hw->fc.fc_was_autonegged = FALSE;
			hw->fc.current_mode = hw->fc.requested_mode;
			goto out;
		}

		if (hw->mac.type == ixgbe_mac_82599EB) {
			links2 = IXGBE_READ_REG(hw, IXGBE_LINKS2);
			if ((links2 & IXGBE_LINKS2_AN_SUPPORTED) == 0) {
				hw->fc.fc_was_autonegged = FALSE;
				hw->fc.current_mode = hw->fc.requested_mode;
				goto out;
			}
		}
	}
a2112 9
	if (hw->phy.multispeed_fiber && (speed == IXGBE_LINK_SPEED_1GB_FULL)) {
		linkstat = IXGBE_READ_REG(hw, IXGBE_PCS1GLSTA);
		if (((linkstat & IXGBE_PCS1GLSTA_AN_COMPLETE) == 0) ||
		    ((linkstat & IXGBE_PCS1GLSTA_AN_TIMED_OUT) == 1)) {
			hw->fc.fc_was_autonegged = FALSE;
			hw->fc.current_mode = hw->fc.requested_mode;
			goto out;
		}
	}
d2114 4
a2117 11
	/*
	 * Bail out on
	 * - copper or CX4 adapters
	 * - fiber adapters running at 10gig
	 */
	if ((hw->phy.media_type == ixgbe_media_type_copper) ||
	     (hw->phy.media_type == ixgbe_media_type_cx4) ||
	     ((hw->phy.media_type == ixgbe_media_type_fiber) &&
	     (speed == IXGBE_LINK_SPEED_10GB_FULL))) {
		hw->fc.fc_was_autonegged = FALSE;
		hw->fc.current_mode = hw->fc.requested_mode;
d2121 2
a2122 49
	/*
	 * Read the AN advertisement and LP ability registers and resolve
	 * local flow control settings accordingly
	 */
	if ((speed == IXGBE_LINK_SPEED_1GB_FULL) &&
	    (hw->phy.media_type != ixgbe_media_type_backplane)) {
		pcs_anadv_reg = IXGBE_READ_REG(hw, IXGBE_PCS1GANA);
		pcs_lpab_reg = IXGBE_READ_REG(hw, IXGBE_PCS1GANLP);
		if ((pcs_anadv_reg & IXGBE_PCS1GANA_SYM_PAUSE) &&
		    (pcs_lpab_reg & IXGBE_PCS1GANA_SYM_PAUSE)) {
			/*
			 * Now we need to check if the user selected Rx ONLY
			 * of pause frames.  In this case, we had to advertise
			 * FULL flow control because we could not advertise RX
			 * ONLY. Hence, we must now check to see if we need to
			 * turn OFF the TRANSMISSION of PAUSE frames.
			 */
			if (hw->fc.requested_mode == ixgbe_fc_full) {
				hw->fc.current_mode = ixgbe_fc_full;
				DEBUGOUT("Flow Control = FULL.\n");
			} else {
				hw->fc.current_mode = ixgbe_fc_rx_pause;
				DEBUGOUT("Flow Control=RX PAUSE frames only\n");
			}
		} else if (!(pcs_anadv_reg & IXGBE_PCS1GANA_SYM_PAUSE) &&
			   (pcs_anadv_reg & IXGBE_PCS1GANA_ASM_PAUSE) &&
			   (pcs_lpab_reg & IXGBE_PCS1GANA_SYM_PAUSE) &&
			   (pcs_lpab_reg & IXGBE_PCS1GANA_ASM_PAUSE)) {
			hw->fc.current_mode = ixgbe_fc_tx_pause;
			DEBUGOUT("Flow Control = TX PAUSE frames only.\n");
		} else if ((pcs_anadv_reg & IXGBE_PCS1GANA_SYM_PAUSE) &&
			   (pcs_anadv_reg & IXGBE_PCS1GANA_ASM_PAUSE) &&
			   !(pcs_lpab_reg & IXGBE_PCS1GANA_SYM_PAUSE) &&
			   (pcs_lpab_reg & IXGBE_PCS1GANA_ASM_PAUSE)) {
			hw->fc.current_mode = ixgbe_fc_rx_pause;
			DEBUGOUT("Flow Control = RX PAUSE frames only.\n");
		} else {
			hw->fc.current_mode = ixgbe_fc_none;
			DEBUGOUT("Flow Control = NONE.\n");
		}
	}

	if (hw->phy.media_type == ixgbe_media_type_backplane) {
		/*
		 * Read the 10g AN autoc and LP ability registers and resolve
		 * local flow control settings accordingly
		 */
		autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
		anlp1_reg = IXGBE_READ_REG(hw, IXGBE_ANLP1);
d2124 5
a2128 35
		if ((autoc_reg & IXGBE_AUTOC_SYM_PAUSE) &&
		    (anlp1_reg & IXGBE_ANLP1_SYM_PAUSE)) {
			/*
			 * Now we need to check if the user selected Rx ONLY
			 * of pause frames.  In this case, we had to advertise
			 * FULL flow control because we could not advertise RX
			 * ONLY. Hence, we must now check to see if we need to
			 * turn OFF the TRANSMISSION of PAUSE frames.
			 */
			if (hw->fc.requested_mode == ixgbe_fc_full) {
				hw->fc.current_mode = ixgbe_fc_full;
				DEBUGOUT("Flow Control = FULL.\n");
			} else {
				hw->fc.current_mode = ixgbe_fc_rx_pause;
				DEBUGOUT("Flow Control=RX PAUSE frames only\n");
			}
		} else if (!(autoc_reg & IXGBE_AUTOC_SYM_PAUSE) &&
			   (autoc_reg & IXGBE_AUTOC_ASM_PAUSE) &&
			   (anlp1_reg & IXGBE_ANLP1_SYM_PAUSE) &&
			   (anlp1_reg & IXGBE_ANLP1_ASM_PAUSE)) {
			hw->fc.current_mode = ixgbe_fc_tx_pause;
			DEBUGOUT("Flow Control = TX PAUSE frames only.\n");
		} else if ((autoc_reg & IXGBE_AUTOC_SYM_PAUSE) &&
			   (autoc_reg & IXGBE_AUTOC_ASM_PAUSE) &&
			   !(anlp1_reg & IXGBE_ANLP1_SYM_PAUSE) &&
			   (anlp1_reg & IXGBE_ANLP1_ASM_PAUSE)) {
			hw->fc.current_mode = ixgbe_fc_rx_pause;
			DEBUGOUT("Flow Control = RX PAUSE frames only.\n");
		} else {
			hw->fc.current_mode = ixgbe_fc_none;
			DEBUGOUT("Flow Control = NONE.\n");
		}
	}
	/* Record that current_mode is the result of a successful autoneg */
	hw->fc.fc_was_autonegged = TRUE;
d2135 1
a2135 1
 *  ixgbe_setup_fc - Set up flow control
d2138 1
a2138 1
 *  Called at init time to set up flow control.
d2140 1
a2140 1
int32_t ixgbe_setup_fc(struct ixgbe_hw *hw, int32_t packetbuf_num)
d2142 124
a2265 2
	int32_t ret_val = IXGBE_SUCCESS;
	uint32_t reg;
d2303 3
a2305 3
	 * Set up the 1G flow control advertisement registers so the HW will be
	 * able to do fc autoneg once the cable is plugged in.  If we end up
	 * using 10g instead, this is harmless.
d2307 16
a2322 1
	reg = IXGBE_READ_REG(hw, IXGBE_PCS1GANA);
d2338 5
d2354 5
d2367 7
d2378 5
d2391 4
d2406 3
a2408 3
	 * Set up the 10G flow control advertisement registers so the HW
	 * can do fc autoneg once the cable is plugged in.  If we end up
	 * using 1g instead, this is harmless.
d2410 8
a2417 1
	reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
a2418 50
	/*
	 * The possible values of fc.requested_mode are:
	 * 0: Flow control is completely disabled
	 * 1: Rx flow control is enabled (we can receive pause frames,
	 *    but not send pause frames).
	 * 2: Tx flow control is enabled (we can send pause frames but
	 *    we do not support receiving pause frames).
	 * 3: Both Rx and Tx flow control (symmetric) are enabled.
	 * other: Invalid.
	 */
	switch (hw->fc.requested_mode) {
	case ixgbe_fc_none:
		/* Flow control completely disabled by software override. */
		reg &= ~(IXGBE_AUTOC_SYM_PAUSE | IXGBE_AUTOC_ASM_PAUSE);
		break;
	case ixgbe_fc_rx_pause:
		/*
		 * Rx Flow control is enabled and Tx Flow control is
		 * disabled by software override. Since there really
		 * isn't a way to advertise that we are capable of RX
		 * Pause ONLY, we will advertise that we support both
		 * symmetric and asymmetric Rx PAUSE.  Later, we will
		 * disable the adapter's ability to send PAUSE frames.
		 */
		reg |= (IXGBE_AUTOC_SYM_PAUSE | IXGBE_AUTOC_ASM_PAUSE);
		break;
	case ixgbe_fc_tx_pause:
		/*
		 * Tx Flow control is enabled, and Rx Flow control is
		 * disabled by software override.
		 */
		reg |= (IXGBE_AUTOC_ASM_PAUSE);
		reg &= ~(IXGBE_AUTOC_SYM_PAUSE);
		break;
	case ixgbe_fc_full:
		/* Flow control (both Rx and Tx) is enabled by SW override. */
		reg |= (IXGBE_AUTOC_SYM_PAUSE | IXGBE_AUTOC_ASM_PAUSE);
		break;
	default:
		DEBUGOUT("Flow control param set incorrectly\n");
		ret_val = IXGBE_ERR_CONFIG;
		goto out;
		break;
	}
	/*
	 * AUTOC restart handles negotiation of 1G and 10G. There is
	 * no need to set the PCS1GCTL register.
	 */
	reg |= IXGBE_AUTOC_AN_RESTART;
	IXGBE_WRITE_REG(hw, IXGBE_AUTOC, reg);
a2419 1

d2440 4
d2459 16
a2474 2
		if (!(IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_GIO)) {
			status = IXGBE_SUCCESS;
a2475 1
		}
d2479 16
a2601 1

d2741 20
a2760 22
	if (rar < rar_entries) {
		mpsar_lo = IXGBE_READ_REG(hw, IXGBE_MPSAR_LO(rar));
		mpsar_hi = IXGBE_READ_REG(hw, IXGBE_MPSAR_HI(rar));

		if (!mpsar_lo && !mpsar_hi)
			goto done;

		if (vmdq == IXGBE_CLEAR_VMDQ_ALL) {
			if (mpsar_lo) {
				IXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), 0);
				mpsar_lo = 0;
			}
			if (mpsar_hi) {
				IXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), 0);
				mpsar_hi = 0;
			}
		} else if (vmdq < 32) {
			mpsar_lo &= ~(1 << vmdq);
			IXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), mpsar_lo);
		} else {
			mpsar_hi &= ~(1 << (vmdq - 32));
			IXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), mpsar_hi);
d2762 3
a2764 4

		/* was that the last pool using this rar? */
		if (mpsar_lo == 0 && mpsar_hi == 0 && rar != 0)
			hw->mac.ops.clear_rar(hw, rar);
d2766 2
a2767 1
		DEBUGOUT1("RAR index %d is out of range.\n", rar);
d2770 3
d2788 10
a2797 10
	if (rar < rar_entries) {
		if (vmdq < 32) {
			mpsar = IXGBE_READ_REG(hw, IXGBE_MPSAR_LO(rar));
			mpsar |= 1 << vmdq;
			IXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), mpsar);
		} else {
			mpsar = IXGBE_READ_REG(hw, IXGBE_MPSAR_HI(rar));
			mpsar |= 1 << (vmdq - 32);
			IXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), mpsar);
		}
d2799 3
a2801 1
		DEBUGOUT1("RAR index %d is out of range.\n", rar);
d2836 4
d2862 1
a2862 1
			regindex = -1;
d2883 1
d2886 2
d2895 1
d2906 2
a2907 6
	bits = IXGBE_READ_REG(hw, IXGBE_VFTA(regindex));
	if (vlan_on)
		bits |= (1 << bitindex);
	else
		bits &= ~(1 << bitindex);
	IXGBE_WRITE_REG(hw, IXGBE_VFTA(regindex), bits);
d2909 11
d2931 5
a2935 7
		if (vlan == 0) {
			regindex = 0;
		} else {
			regindex = ixgbe_find_vlvf_slot(hw, vlan);
			if (regindex < 0)
				goto out;
		}
d2941 1
a2941 1
						IXGBE_VLVFB(regindex*2));
d2944 1
a2944 1
						IXGBE_VLVFB(regindex*2),
d2948 2
a2949 2
						IXGBE_VLVFB((regindex*2)+1));
				bits |= (1 << vind);
d2951 1
a2951 1
						IXGBE_VLVFB((regindex*2)+1),
d2958 1
a2958 1
						IXGBE_VLVFB(regindex*2));
d2961 1
a2961 1
						IXGBE_VLVFB(regindex*2),
d2964 1
a2964 1
						IXGBE_VLVFB((regindex*2)+1));
d2967 2
a2968 2
						IXGBE_VLVFB((regindex*2)+1));
				bits &= ~(1 << vind);
d2970 1
a2970 1
						IXGBE_VLVFB((regindex*2)+1),
d2973 1
a2973 1
						IXGBE_VLVFB(regindex*2));
d2977 17
a2993 2
		if (bits)
			IXGBE_WRITE_REG(hw, IXGBE_VLVF(regindex),
d2995 7
d3003 1
a3003 1
			IXGBE_WRITE_REG(hw, IXGBE_VLVF(regindex), 0);
d3005 4
a3008 1
out:
d3046 1
a3046 1
	uint32_t links_reg;
d3049 3
d3053 6
d3083 3
d3087 1
a3087 1
		*speed = IXGBE_LINK_SPEED_100_FULL;
d3097 780
@


1.4
log
@In ixgbe_acquire_swfw_sync don't return -IXGBE_ERR_SWFW_SYNC as this
works out to --16, which is nonsense.

No functional change as all callers only check if the return value
is or isn't equal to IXGBE_SUCCESS.
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.3 2008/06/08 21:15:34 reyk Exp $	*/
d5 1
a5 1
  Copyright (c) 2001-2008, Intel Corporation 
d35 1
a35 1
/*$FreeBSD: src/sys/dev/ixgbe/ixgbe_common.c,v 1.4 2008/05/16 18:46:30 jfv Exp $*/
d39 6
a44 7
static int32_t ixgbe_poll_eeprom_eerd_done(struct ixgbe_hw *hw);
static int32_t ixgbe_acquire_eeprom(struct ixgbe_hw *hw);
static int32_t ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw);
static void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw);
static int32_t ixgbe_ready_eeprom(struct ixgbe_hw *hw);
static void ixgbe_standby_eeprom(struct ixgbe_hw *hw);
static void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, uint16_t data,
d46 8
a53 11
static uint16_t ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, uint16_t count);
static void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw, uint32_t *eec);
static void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw, uint32_t *eec);
static void ixgbe_release_eeprom(struct ixgbe_hw *hw);
static uint16_t ixgbe_calc_eeprom_checksum(struct ixgbe_hw *hw);

static void ixgbe_enable_rar(struct ixgbe_hw *hw, uint32_t index);
static void ixgbe_disable_rar(struct ixgbe_hw *hw, uint32_t index);
static int32_t ixgbe_mta_vector(struct ixgbe_hw *hw, uint8_t *mc_addr);
void ixgbe_add_mc_addr(struct ixgbe_hw *hw, uint8_t *mc_addr);
void ixgbe_add_uc_addr(struct ixgbe_hw *hw, uint8_t *addr, uint32_t vmdq);
d71 1
a71 1
		eeprom->ops.read = &ixgbe_read_eeprom_generic;
d78 1
d86 2
d91 3
a93 2
	mac->ops.read_analog_reg8 = &ixgbe_read_analog_reg8_generic;
	mac->ops.write_analog_reg8 = &ixgbe_write_analog_reg8_generic;
d98 2
a99 2
	mac->ops.blink_led_start = NULL;
	mac->ops.blink_led_stop = NULL;
d103 2
d106 1
d112 3
a114 2
	mac->ops.clear_vfta = &ixgbe_clear_vfta_generic;
	mac->ops.set_vfta = &ixgbe_set_vfta_generic;
d117 1
a117 1
	mac->ops.setup_fc = NULL;
a121 1
	mac->ops.setup_link_speed = NULL;
d139 1
d144 1
a144 11
	/* Set bus info */
	hw->mac.ops.get_bus_info(hw);

	/* Identify the PHY */
	hw->phy.ops.identify(hw);

	/*
	 * Store MAC address from RAR0, clear receive address registers, and
	 * clear the multicast table
	 */
	hw->mac.ops.init_rx_addrs(hw);
a148 3
	/* Set up link */
	hw->mac.ops.setup_link(hw);

d158 3
d164 1
a164 1
	return IXGBE_SUCCESS;
d179 2
d182 1
a182 1
	hw->mac.ops.reset_hw(hw);
d184 4
a187 2
	/* Start the HW */
	hw->mac.ops.start_hw(hw);
d189 1
a189 1
	return IXGBE_SUCCESS;
a213 1
	IXGBE_READ_REG(hw, IXGBE_LXONRXC);
d215 7
a221 1
	IXGBE_READ_REG(hw, IXGBE_LXOFFRXC);
a224 1
		IXGBE_READ_REG(hw, IXGBE_PXONRXC(i));
d226 7
a232 1
		IXGBE_READ_REG(hw, IXGBE_PXOFFRXC(i));
d234 3
a236 1

d283 1
a283 1
 *  ixgbe_read_pba_num - Reads part number from EEPROM
a293 2
	DEBUGFUNC("ixgbe_read_pba_num_generic");

d346 1
d384 2
d390 22
d459 1
a459 1
	if (ixgbe_disable_pcie_master(hw) != IXGBE_SUCCESS) {
a460 1
	}
d516 3
d533 1
a533 1
					    IXGBE_EEC_SIZE_SHIFT);
d535 1
a535 1
						  IXGBE_EEPROM_WORD_SIZE_SHIFT);
d543 2
a544 2
			  "%d\n", eeprom->type, eeprom->word_size,
			  eeprom->address_bits);
a607 2
		msec_delay(10);

d677 1
a677 1
 *  ixgbe_read_eeprom_generic - Read EEPROM word using EERD
d684 1
a684 1
int32_t ixgbe_read_eeprom_generic(struct ixgbe_hw *hw, uint16_t offset, uint16_t *data)
d696 2
a697 2
	eerd = (offset << IXGBE_EEPROM_READ_ADDR_SHIFT) +
	       IXGBE_EEPROM_READ_REG_START;
d700 1
a700 1
	status = ixgbe_poll_eeprom_eerd_done(hw);
d704 1
a704 1
		         IXGBE_EEPROM_READ_REG_DATA);
d713 1
a713 1
 *  ixgbe_poll_eeprom_eerd_done - Poll EERD status
d715 1
d717 2
a718 1
 *  Polls the status bit (bit 1) of the EERD to determine when the read is done.
d720 1
a720 1
static int32_t ixgbe_poll_eeprom_eerd_done(struct ixgbe_hw *hw)
d726 7
a732 3
	for (i = 0; i < IXGBE_EERD_ATTEMPTS; i++) {
		reg = IXGBE_READ_REG(hw, IXGBE_EERD);
		if (reg & IXGBE_EEPROM_READ_REG_DONE) {
d748 1
a748 1
static int32_t ixgbe_acquire_eeprom(struct ixgbe_hw *hw)
d799 1
a799 1
static int32_t ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw)
d802 1
a802 1
	uint32_t timeout;
a805 3
	/* Set timeout value based on size of EEPROM */
	timeout = hw->eeprom.word_size + 1;

d817 1
a817 1
		msec_delay(1);
d845 1
a845 1
			DEBUGOUT("Driver can't access the Eeprom - Semaphore "
d850 3
d864 1
a864 1
static void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw)
d880 1
a880 1
static int32_t ixgbe_ready_eeprom(struct ixgbe_hw *hw)
d919 1
a919 1
static void ixgbe_standby_eeprom(struct ixgbe_hw *hw)
d942 1
a942 1
static void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, uint16_t data,
d995 1
a995 1
static uint16_t ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, uint16_t count)
d1033 1
a1033 1
static void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw, uint32_t *eec)
d1050 1
a1050 1
static void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw, uint32_t *eec)
d1066 1
a1066 1
static void ixgbe_release_eeprom(struct ixgbe_hw *hw)
d1085 3
d1091 1
a1091 1
 *  ixgbe_calc_eeprom_checksum - Calculates and returns the checksum
d1094 1
a1094 1
static uint16_t ixgbe_calc_eeprom_checksum(struct ixgbe_hw *hw)
d1157 1
a1157 1
		checksum = ixgbe_calc_eeprom_checksum(hw);
d1195 1
a1195 1
		checksum = ixgbe_calc_eeprom_checksum(hw);
d1197 1
a1197 1
		                            checksum);
d1276 1
a1276 1
		DEBUGOUT("Current RAR index is out of range.");
d1283 1
a1283 1
 *  ixgbe_enable_rar - Enable Rx address register
d1285 1
a1285 1
 *  @@index: index into the RAR table
d1287 1
a1287 1
 *  Enables the select receive address register.
d1289 1
a1289 1
static void ixgbe_enable_rar(struct ixgbe_hw *hw, uint32_t index)
d1292 1
d1294 15
a1308 4
	rar_high = IXGBE_READ_REG(hw, IXGBE_RAH(index));
	rar_high |= IXGBE_RAH_AV;
	IXGBE_WRITE_REG(hw, IXGBE_RAH(index), rar_high);
}
d1310 2
a1311 10
/**
 *  ixgbe_disable_rar - Disable Rx address register
 *  @@hw: pointer to hardware structure
 *  @@index: index into the RAR table
 *
 *  Disables the select receive address register.
 **/
static void ixgbe_disable_rar(struct ixgbe_hw *hw, uint32_t index)
{
	uint32_t rar_high;
d1313 1
a1313 3
	rar_high = IXGBE_READ_REG(hw, IXGBE_RAH(index));
	rar_high &= (~IXGBE_RAH_AV);
	IXGBE_WRITE_REG(hw, IXGBE_RAH(index), rar_high);
a1366 1
	hw->addr_ctrl.mc_addr_in_rar_count = 0;
d1374 2
d1399 1
a1399 2
		rar = hw->addr_ctrl.rar_used_count -
		      hw->addr_ctrl.mc_addr_in_rar_count;
d1438 1
a1438 2
	uc_addr_in_use = hw->addr_ctrl.rar_used_count -
	                 hw->addr_ctrl.mc_addr_in_rar_count - 1;
d1443 4
a1446 4
	DEBUGOUT1("Clearing RAR[1-%d]\n", uc_addr_in_use);
	for (i = 1; i <= uc_addr_in_use; i++) {
		IXGBE_WRITE_REG(hw, IXGBE_RAL(i), 0);
		IXGBE_WRITE_REG(hw, IXGBE_RAH(i), 0);
d1459 1
a1459 1
			DEBUGOUT( " Entering address overflow promisc mode\n");
d1490 1
a1490 1
static int32_t ixgbe_mta_vector(struct ixgbe_hw *hw, uint8_t *mc_addr)
a1553 34
 *  ixgbe_add_mc_addr - Adds a multicast address.
 *  @@hw: pointer to hardware structure
 *  @@mc_addr: new multicast address
 *
 *  Adds it to unused receive address register or to the multicast table.
 **/
void ixgbe_add_mc_addr(struct ixgbe_hw *hw, uint8_t *mc_addr)
{
	uint32_t rar_entries = hw->mac.num_rar_entries;
	uint32_t rar;

	DEBUGOUT6(" MC Addr =%.2X %.2X %.2X %.2X %.2X %.2X\n",
	          mc_addr[0], mc_addr[1], mc_addr[2],
	          mc_addr[3], mc_addr[4], mc_addr[5]);

	/*
	 * Place this multicast address in the RAR if there is room,
	 * else put it in the MTA
	 */
	if (hw->addr_ctrl.rar_used_count < rar_entries) {
		/* use RAR from the end up for multicast */
		rar = rar_entries - hw->addr_ctrl.mc_addr_in_rar_count - 1;
		hw->mac.ops.set_rar(hw, rar, mc_addr, 0, IXGBE_RAH_AV);
		DEBUGOUT1("Added a multicast address to RAR[%d]\n", rar);
		hw->addr_ctrl.rar_used_count++;
		hw->addr_ctrl.mc_addr_in_rar_count++;
	} else {
		ixgbe_set_mta(hw, mc_addr);
	}

	DEBUGOUT("ixgbe_add_mc_addr Complete\n");
}

/**
a1568 1
	uint32_t rar_entries = hw->mac.num_rar_entries;
a1575 2
	hw->addr_ctrl.rar_used_count -= hw->addr_ctrl.mc_addr_in_rar_count;
	hw->addr_ctrl.mc_addr_in_rar_count = 0;
a1577 8
	/* Zero out the other receive addresses. */
	DEBUGOUT2("Clearing RAR[%d-%d]\n", hw->addr_ctrl.rar_used_count,
	          rar_entries - 1);
	for (i = hw->addr_ctrl.rar_used_count; i < rar_entries; i++) {
		IXGBE_WRITE_REG(hw, IXGBE_RAL(i), 0);
		IXGBE_WRITE_REG(hw, IXGBE_RAH(i), 0);
	}

d1586 1
a1586 1
		ixgbe_add_mc_addr(hw, next(hw, &mc_addr_list, &vmdq));
a1605 2
	uint32_t i;
	uint32_t rar_entries = hw->mac.num_rar_entries;
a1607 5
	if (a->mc_addr_in_rar_count > 0)
		for (i = (rar_entries - a->mc_addr_in_rar_count);
		     i < rar_entries; i++)
			ixgbe_enable_rar(hw, i);

a1622 2
	uint32_t i;
	uint32_t rar_entries = hw->mac.num_rar_entries;
a1624 5
	if (a->mc_addr_in_rar_count > 0)
		for (i = (rar_entries - a->mc_addr_in_rar_count);
		     i < rar_entries; i++)
			ixgbe_disable_rar(hw, i);

d1632 125
a1756 1
 *  ixgbe_clear_vfta_generic - Clear VLAN filter table
d1759 2
a1760 1
 *  Clears the VLAN filer table, and the VMDq index associated with the filter
d1762 1
a1762 1
int32_t ixgbe_clear_vfta_generic(struct ixgbe_hw *hw)
d1764 116
a1879 2
	uint32_t offset;
	uint32_t vlanbyte;
d1881 7
a1887 2
	for (offset = 0; offset < hw->mac.vft_size; offset++)
		IXGBE_WRITE_REG(hw, IXGBE_VFTA(offset), 0);
d1889 35
a1923 4
	for (vlanbyte = 0; vlanbyte < 4; vlanbyte++)
		for (offset = 0; offset < hw->mac.vft_size; offset++)
			IXGBE_WRITE_REG(hw, IXGBE_VFTAVIND(vlanbyte, offset),
			                0);
d1925 2
a1926 1
	return IXGBE_SUCCESS;
d1930 1
a1930 1
 *  ixgbe_set_vfta_generic - Set VLAN filter table
a1931 3
 *  @@vlan: VLAN id to write to VLAN filter
 *  @@vind: VMDq output index that maps queue to VLAN id in VFTA
 *  @@vlan_on: intean flag to turn on/off VLAN in VFTA
d1933 1
a1933 1
 *  Turn on/off specified VLAN in the VLAN filter table.
d1935 1
a1935 2
int32_t ixgbe_set_vfta_generic(struct ixgbe_hw *hw, uint32_t vlan, uint32_t vind,
                           int vlan_on)
d1937 30
a1966 17
	uint32_t VftaIndex;
	uint32_t BitOffset;
	uint32_t VftaReg;
	uint32_t VftaByte;

	/* Determine 32-bit word position in array */
	VftaIndex = (vlan >> 5) & 0x7F;   /* upper seven bits */

	/* Determine the location of the (VMD) queue index */
	VftaByte =  ((vlan >> 3) & 0x03); /* bits (4:3) indicating byte array */
	BitOffset = (vlan & 0x7) << 2;    /* lower 3 bits indicate nibble */

	/* Set the nibble for VMD queue index */
	VftaReg = IXGBE_READ_REG(hw, IXGBE_VFTAVIND(VftaByte, VftaIndex));
	VftaReg &= (~(0x0F << BitOffset));
	VftaReg |= (vind << BitOffset);
	IXGBE_WRITE_REG(hw, IXGBE_VFTAVIND(VftaByte, VftaIndex), VftaReg);
d1968 58
a2025 2
	/* Determine the location of the bit for this VLAN id */
	BitOffset = vlan & 0x1F;   /* lower five bits */
d2027 68
a2094 8
	VftaReg = IXGBE_READ_REG(hw, IXGBE_VFTA(VftaIndex));
	if (vlan_on)
		/* Turn on this VLAN id */
		VftaReg |= (1 << BitOffset);
	else
		/* Turn off this VLAN id */
		VftaReg &= ~(1 << BitOffset);
	IXGBE_WRITE_REG(hw, IXGBE_VFTA(VftaIndex), VftaReg);
d2096 2
a2097 1
	return IXGBE_SUCCESS;
d2111 3
a2113 2
	uint32_t ctrl;
	int32_t i;
d2116 13
a2128 3
	ctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);
	ctrl |= IXGBE_CTRL_GIO_DIS;
	IXGBE_WRITE_REG(hw, IXGBE_CTRL, ctrl);
d2158 4
d2179 1
a2179 1
		DEBUGOUT("Driver can't access resource, GSSR timeout.\n");
d2213 1
a2213 1
 *  ixgbe_read_analog_reg8_generic - Reads 8 bit Atlas analog register
d2215 1
a2215 2
 *  @@reg: analog register to read
 *  @@val: read value
d2217 1
a2217 1
 *  Performs read operation to Atlas analog register specified.
d2219 1
a2219 1
int32_t ixgbe_read_analog_reg8_generic(struct ixgbe_hw *hw, uint32_t reg, uint8_t *val)
d2221 1
a2221 1
	uint32_t  atlas_ctl;
d2223 32
a2254 1
	IXGBE_WRITE_REG(hw, IXGBE_ATLASCTL, IXGBE_ATLASCTL_WRITE_CMD | (reg << 8));
a2255 3
	usec_delay(10);
	atlas_ctl = IXGBE_READ_REG(hw, IXGBE_ATLASCTL);
	*val = (uint8_t)atlas_ctl;
d2261 24
a2284 1
 *  ixgbe_write_analog_reg8_generic - Writes 8 bit Atlas analog register
a2285 2
 *  @@reg: atlas register to write
 *  @@val: value to write
d2287 92
a2378 1
 *  Performs write operation to Atlas analog register specified.
d2380 1
a2380 1
int32_t ixgbe_write_analog_reg8_generic(struct ixgbe_hw *hw, uint32_t reg, uint8_t val)
d2382 2
a2383 1
	uint32_t  atlas_ctl;
d2385 248
a2632 4
	atlas_ctl = (reg << 8) | val;
	IXGBE_WRITE_REG(hw, IXGBE_ATLASCTL, atlas_ctl);
	IXGBE_WRITE_FLUSH(hw);
	usec_delay(10);
d2637 51
@


1.3
log
@more cleanup, removed unused code. we don't do LRO/RSS yet, code can
be added later if we ever support it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.2 2008/06/08 20:33:51 reyk Exp $	*/
d1762 1
a1762 1
			return -IXGBE_ERR_SWFW_SYNC;
d1779 1
a1779 1
		return -IXGBE_ERR_SWFW_SYNC;
@


1.2
log
@replace strange Linux-style u8/u16/u32/u64/s32 integer types with the
standard C99 uint*_t/int*_t types (i don't get why these drivers
always use their own types when there is a well-defined standard).
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.c,v 1.1 2008/06/08 20:01:02 reyk Exp $	*/
d1466 1
a1466 1
		ASSERT(0);
@


1.1
log
@Import ix, a driver for the Intel 82598 PCI-Express 10 Gig Ethernet Adapter,
based on Intel's ixgbe driver.

Done on borrowed hardware since Intel was too poor to give us a card.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d39 3
a41 3
static s32 ixgbe_poll_eeprom_eerd_done(struct ixgbe_hw *hw);
static s32 ixgbe_acquire_eeprom(struct ixgbe_hw *hw);
static s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw);
d43 1
a43 1
static s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw);
d45 5
a49 5
static void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, u16 data,
                                        u16 count);
static u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, u16 count);
static void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw, u32 *eec);
static void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw, u32 *eec);
d51 1
a51 1
static u16 ixgbe_calc_eeprom_checksum(struct ixgbe_hw *hw);
d53 5
a57 5
static void ixgbe_enable_rar(struct ixgbe_hw *hw, u32 index);
static void ixgbe_disable_rar(struct ixgbe_hw *hw, u32 index);
static s32 ixgbe_mta_vector(struct ixgbe_hw *hw, u8 *mc_addr);
void ixgbe_add_mc_addr(struct ixgbe_hw *hw, u8 *mc_addr);
void ixgbe_add_uc_addr(struct ixgbe_hw *hw, u8 *addr, u32 vmdq);
d65 1
a65 1
s32 ixgbe_init_ops_generic(struct ixgbe_hw *hw)
d69 1
a69 1
	u32 eec = IXGBE_READ_REG(hw, IXGBE_EEC);
d133 1
a133 1
s32 ixgbe_start_hw_generic(struct ixgbe_hw *hw)
d135 1
a135 1
	u32 ctrl_ext;
d183 1
a183 1
s32 ixgbe_init_hw_generic(struct ixgbe_hw *hw)
d201 1
a201 1
s32 ixgbe_clear_hw_cntrs_generic(struct ixgbe_hw *hw)
d203 1
a203 1
	u16 i = 0;
d279 1
a279 1
s32 ixgbe_read_pba_num_generic(struct ixgbe_hw *hw, u32 *pba_num)
d281 2
a282 2
	s32 ret_val;
	u16 data;
d291 1
a291 1
	*pba_num = (u32)(data << 16);
d312 1
a312 1
s32 ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw, u8 *mac_addr)
d314 3
a316 3
	u32 rar_high;
	u32 rar_low;
	u16 i;
d322 1
a322 1
		mac_addr[i] = (u8)(rar_low >> (i*8));
d325 1
a325 1
		mac_addr[i+4] = (u8)(rar_high >> (i*8));
d336 1
a336 1
s32 ixgbe_get_bus_info_generic(struct ixgbe_hw *hw)
d338 1
a338 1
	u16 link_status;
d387 1
a387 1
s32 ixgbe_stop_adapter_generic(struct ixgbe_hw *hw)
d389 3
a391 3
	u32 number_of_queues;
	u32 reg_val;
	u16 i;
d438 1
a438 1
s32 ixgbe_led_on_generic(struct ixgbe_hw *hw, u32 index)
d440 1
a440 1
	u32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
d456 1
a456 1
s32 ixgbe_led_off_generic(struct ixgbe_hw *hw, u32 index)
d458 1
a458 1
	u32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
d476 1
a476 1
s32 ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw)
d479 2
a480 2
	u32 eec;
	u16 eeprom_size;
d497 1
a497 1
			eeprom_size = (u16)((eec & IXGBE_EEC_SIZE) >>
d524 1
a524 1
s32 ixgbe_write_eeprom_generic(struct ixgbe_hw *hw, u16 offset, u16 data)
d526 2
a527 2
	s32 status;
	u8 write_opcode = IXGBE_EEPROM_WRITE_OPCODE_SPI;
d565 1
a565 1
		ixgbe_shift_out_eeprom_bits(hw, (u16)(offset*2),
d591 2
a592 2
s32 ixgbe_read_eeprom_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,
                                       u16 *data)
d594 3
a596 3
	s32 status;
	u16 word_in;
	u8 read_opcode = IXGBE_EEPROM_READ_OPCODE_SPI;
d628 1
a628 1
		ixgbe_shift_out_eeprom_bits(hw, (u16)(offset*2),
d651 1
a651 1
s32 ixgbe_read_eeprom_generic(struct ixgbe_hw *hw, u16 offset, u16 *data)
d653 2
a654 2
	u32 eerd;
	s32 status;
d685 1
a685 1
static s32 ixgbe_poll_eeprom_eerd_done(struct ixgbe_hw *hw)
d687 3
a689 3
	u32 i;
	u32 reg;
	s32 status = IXGBE_ERR_EEPROM;
d709 1
a709 1
static s32 ixgbe_acquire_eeprom(struct ixgbe_hw *hw)
d711 3
a713 3
	s32 status = IXGBE_SUCCESS;
	u32 eec;
	u32 i;
d760 1
a760 1
static s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw)
d762 4
a765 4
	s32 status = IXGBE_ERR_EEPROM;
	u32 timeout;
	u32 i;
	u32 swsm;
d827 1
a827 1
	u32 swsm;
d841 1
a841 1
static s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw)
d843 3
a845 3
	s32 status = IXGBE_SUCCESS;
	u16 i;
	u8 spi_stat_reg;
d856 1
a856 1
		spi_stat_reg = (u8)ixgbe_shift_in_eeprom_bits(hw, 8);
d882 1
a882 1
	u32 eec;
d903 2
a904 2
static void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, u16 data,
                                        u16 count)
d906 3
a908 3
	u32 eec;
	u32 mask;
	u32 i;
d956 1
a956 1
static u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, u16 count)
d958 3
a960 3
	u32 eec;
	u32 i;
	u16 data = 0;
d994 1
a994 1
static void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw, u32 *eec)
d1011 1
a1011 1
static void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw, u32 *eec)
d1029 1
a1029 1
	u32 eec;
d1052 1
a1052 1
static u16 ixgbe_calc_eeprom_checksum(struct ixgbe_hw *hw)
d1054 6
a1059 6
	u16 i;
	u16 j;
	u16 checksum = 0;
	u16 length = 0;
	u16 pointer = 0;
	u16 word = 0;
d1087 1
a1087 1
	checksum = (u16)IXGBE_EEPROM_SUM - checksum;
d1100 2
a1101 2
s32 ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw,
                                           u16 *checksum_val)
d1103 3
a1105 3
	s32 status;
	u16 checksum;
	u16 read_checksum = 0;
d1140 1
a1140 1
s32 ixgbe_update_eeprom_checksum_generic(struct ixgbe_hw *hw)
d1142 2
a1143 2
	s32 status;
	u16 checksum;
d1169 1
a1169 1
s32 ixgbe_validate_mac_addr(u8 *mac_addr)
d1171 1
a1171 1
	s32 status = IXGBE_SUCCESS;
d1200 2
a1201 2
s32 ixgbe_set_rar_generic(struct ixgbe_hw *hw, u32 index, u8 *addr, u32 vmdq,
                          u32 enable_addr)
d1203 2
a1204 2
	u32 rar_low, rar_high;
	u32 rar_entries = hw->mac.num_rar_entries;
d1215 4
a1218 4
		rar_low = ((u32)addr[0] |
		           ((u32)addr[1] << 8) |
		           ((u32)addr[2] << 16) |
		           ((u32)addr[3] << 24));
d1226 1
a1226 1
		rar_high |= ((u32)addr[4] | ((u32)addr[5] << 8));
d1247 1
a1247 1
static void ixgbe_enable_rar(struct ixgbe_hw *hw, u32 index)
d1249 1
a1249 1
	u32 rar_high;
d1263 1
a1263 1
static void ixgbe_disable_rar(struct ixgbe_hw *hw, u32 index)
d1265 1
a1265 1
	u32 rar_high;
d1280 1
a1280 1
s32 ixgbe_init_rx_addrs_generic(struct ixgbe_hw *hw)
d1282 2
a1283 2
	u32 i;
	u32 rar_entries = hw->mac.num_rar_entries;
d1341 1
a1341 1
void ixgbe_add_uc_addr(struct ixgbe_hw *hw, u8 *addr, u32 vmdq)
d1343 2
a1344 2
	u32 rar_entries = hw->mac.num_rar_entries;
	u32 rar;
d1380 2
a1381 2
s32 ixgbe_update_uc_addr_list_generic(struct ixgbe_hw *hw, u8 *addr_list,
                                      u32 addr_count, ixgbe_mc_addr_itr next)
d1383 6
a1388 6
	u8 *addr;
	u32 i;
	u32 old_promisc_setting = hw->addr_ctrl.overflow_promisc;
	u32 uc_addr_in_use;
	u32 fctrl;
	u32 vmdq;
d1447 1
a1447 1
static s32 ixgbe_mta_vector(struct ixgbe_hw *hw, u8 *mc_addr)
d1449 1
a1449 1
	u32 vector = 0;
d1453 1
a1453 1
		vector = ((mc_addr[4] >> 4) | (((u16)mc_addr[5]) << 4));
d1456 1
a1456 1
		vector = ((mc_addr[4] >> 3) | (((u16)mc_addr[5]) << 5));
d1459 1
a1459 1
		vector = ((mc_addr[4] >> 2) | (((u16)mc_addr[5]) << 6));
d1462 1
a1462 1
		vector = ((mc_addr[4]) | (((u16)mc_addr[5]) << 8));
d1482 1
a1482 1
void ixgbe_set_mta(struct ixgbe_hw *hw, u8 *mc_addr)
d1484 4
a1487 4
	u32 vector;
	u32 vector_bit;
	u32 vector_reg;
	u32 mta_reg;
d1517 1
a1517 1
void ixgbe_add_mc_addr(struct ixgbe_hw *hw, u8 *mc_addr)
d1519 2
a1520 2
	u32 rar_entries = hw->mac.num_rar_entries;
	u32 rar;
d1556 2
a1557 2
s32 ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw, u8 *mc_addr_list,
                                      u32 mc_addr_count, ixgbe_mc_addr_itr next)
d1559 3
a1561 3
	u32 i;
	u32 rar_entries = hw->mac.num_rar_entries;
	u32 vmdq;
d1606 1
a1606 1
s32 ixgbe_enable_mc_generic(struct ixgbe_hw *hw)
d1608 2
a1609 2
	u32 i;
	u32 rar_entries = hw->mac.num_rar_entries;
d1630 1
a1630 1
s32 ixgbe_disable_mc_generic(struct ixgbe_hw *hw)
d1632 2
a1633 2
	u32 i;
	u32 rar_entries = hw->mac.num_rar_entries;
d1653 1
a1653 1
s32 ixgbe_clear_vfta_generic(struct ixgbe_hw *hw)
d1655 2
a1656 2
	u32 offset;
	u32 vlanbyte;
d1674 1
a1674 1
 *  @@vlan_on: boolean flag to turn on/off VLAN in VFTA
d1678 2
a1679 2
s32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw, u32 vlan, u32 vind,
                           bool vlan_on)
d1681 4
a1684 4
	u32 VftaIndex;
	u32 BitOffset;
	u32 VftaReg;
	u32 VftaByte;
d1723 1
a1723 1
s32 ixgbe_disable_pcie_master(struct ixgbe_hw *hw)
d1725 3
a1727 3
	u32 ctrl;
	s32 i;
	s32 status = IXGBE_ERR_MASTER_REQUESTS_PENDING;
d1753 1
a1753 1
s32 ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw, u16 mask)
d1755 4
a1758 4
	u32 gssr;
	u32 swmask = mask;
	u32 fwmask = mask << 5;
	s32 timeout = 200;
d1797 1
a1797 1
void ixgbe_release_swfw_sync(struct ixgbe_hw *hw, u16 mask)
d1799 2
a1800 2
	u32 gssr;
	u32 swmask = mask;
d1819 1
a1819 1
s32 ixgbe_read_analog_reg8_generic(struct ixgbe_hw *hw, u32 reg, u8 *val)
d1821 1
a1821 1
	u32  atlas_ctl;
d1827 1
a1827 1
	*val = (u8)atlas_ctl;
d1840 1
a1840 1
s32 ixgbe_write_analog_reg8_generic(struct ixgbe_hw *hw, u32 reg, u8 val)
d1842 1
a1842 1
	u32  atlas_ctl;
@

