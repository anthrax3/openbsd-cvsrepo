head	1.33;
access;
symbols
	OPENBSD_6_2:1.33.0.10
	OPENBSD_6_2_BASE:1.33
	OPENBSD_6_1:1.33.0.8
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.6
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.31.0.6
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.4
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.22.0.10
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.8
	OPENBSD_5_0:1.22.0.6
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.3.0.20
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.18
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.16
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.14
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.12
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.10
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	SMP:1.3.0.8
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	UBC:1.3.0.4
	UBC_SYNC_B:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3;
locks; strict;
comment	@ * @;


1.33
date	2015.12.19.16.07.20;	author kettenis;	state Exp;
branches;
next	1.32;
commitid	NDhUxvYB3Eg6RqfI;

1.32
date	2015.12.19.14.59.25;	author kettenis;	state Exp;
branches;
next	1.31;
commitid	hf2vaC9ougVCMkma;

1.31
date	2014.09.20.16.15.16;	author kettenis;	state Exp;
branches;
next	1.30;
commitid	6wfZPYqhJIzN4SFE;

1.30
date	2014.03.26.14.41.41;	author mpi;	state Exp;
branches;
next	1.29;

1.29
date	2013.12.09.19.52.11;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2013.12.07.10.57.06;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2013.04.14.19.04.37;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.18.12.02.56;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2013.03.18.11.14.44;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2013.03.17.21.49.00;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2012.12.06.15.05.21;	author mpi;	state Exp;
branches;
next	1.22;

1.22
date	2010.05.10.22.06.04;	author oga;	state Exp;
branches;
next	1.21;

1.21
date	2010.04.08.01.26.44;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.06.06.02.44;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2009.05.10.16.57.44;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2009.05.10.15.28.45;	author oga;	state Exp;
branches;
next	1.17;

1.17
date	2009.05.10.14.44.42;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2009.04.20.01.28.45;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2008.11.09.15.11.19;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2008.07.12.17.31.06;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2008.05.06.19.19.02;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2008.03.23.19.54.47;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2008.03.16.19.00.28;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2007.12.07.17.35.22;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2007.12.07.14.48.50;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2007.12.06.22.49.39;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.25.17.11.12;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2007.08.04.19.40.25;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.26.18.35.51;	author dim;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.10.21.52.02;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.25.23.31.04;	author fgsch;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2002.07.15.13.23.48;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2002.07.12.20.17.03;	author mickey;	state Exp;
branches;
next	;

1.3.4.1
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Remove code that has been unused ever since we removed the agp ioctl interface.

ok mpi@@
@
text
@/*	$OpenBSD: agpvar.h,v 1.32 2015/12/19 14:59:25 kettenis Exp $	*/
/*	$NetBSD: agpvar.h,v 1.4 2001/10/01 21:54:48 fvdl Exp $	*/

/*-
 * Copyright (c) 2000 Doug Rabson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$FreeBSD: src/sys/pci/agppriv.h,v 1.3 2000/07/12 10:13:04 dfr Exp $
 */

#ifndef _PCI_AGPVAR_H_
#define _PCI_AGPVAR_H_

/* #define	AGP_DEBUG */
#ifdef AGP_DEBUG
#define AGP_DPF(fmt, arg...) do { printf("agp: " fmt ,##arg); } while (0)
#else
#define AGP_DPF(fmt, arg...) do {} while (0)
#endif

#define AGPUNIT(x)	minor(x)

struct agp_attach_args {
	char			*aa_busname;
	struct pci_attach_args	*aa_pa;
};

struct agpbus_attach_args {
	char				*aa_busname; /*so pci doesn't conflict*/
        struct pci_attach_args		*aa_pa;
	const struct agp_methods	*aa_methods;
	bus_addr_t			 aa_apaddr;
	bus_size_t			 aa_apsize;
};

enum agp_acquire_state {
	AGP_ACQUIRE_FREE,
	AGP_ACQUIRE_USER,
	AGP_ACQUIRE_KERNEL
};

/*
 * This structure is used to query the state of the AGP system.
 */
struct agp_info {
	u_int32_t       ai_mode;
	bus_addr_t      ai_aperture_base;
	bus_size_t      ai_aperture_size;
	vsize_t         ai_memory_allowed;
	vsize_t         ai_memory_used;
	u_int32_t       ai_devid;
};

struct agp_memory_info {
        vsize_t         ami_size;       /* size in bytes */
        bus_addr_t      ami_physical;   /* bogus hack for i810 */
        off_t           ami_offset;     /* page offset if bound */
        int             ami_is_bound;   /* non-zero if bound */
};

struct agp_methods {
	void	(*bind_page)(void *, bus_addr_t, paddr_t, int);
	void	(*unbind_page)(void *, bus_addr_t);
	void	(*flush_tlb)(void *);
	int	(*enable)(void *, u_int32_t mode);
};

/*
 * All chipset drivers must have this at the start of their softc.
 */
struct agp_softc {
	struct device			 sc_dev;

	const struct agp_methods 	*sc_methods;	/* callbacks */
	void				*sc_chipc;	/* chipset softc */

	bus_dma_tag_t			 sc_dmat;
	bus_space_tag_t			 sc_memt;
	pci_chipset_tag_t		 sc_pc;
	pcitag_t			 sc_pcitag;
	bus_addr_t			 sc_apaddr;
	bus_size_t			 sc_apsize;
	uint32_t			 sc_stolen_entries;
	pcireg_t			 sc_id;

	int				 sc_opened;
	int				 sc_capoff;			
	int				 sc_nextid;	/* next mem block id */
	enum agp_acquire_state		 sc_state;

	u_int32_t			 sc_maxmem;	/* mem upper bound */
	u_int32_t			 sc_allocated;	/* amount allocated */
};

struct agp_gatt {
	u_int32_t	ag_entries;
	u_int32_t	*ag_virtual;
	bus_addr_t	ag_physical;
	bus_dmamap_t	ag_dmamap;
	bus_dma_segment_t ag_dmaseg;
	size_t		ag_size;
};

struct agp_map;

/*
 * Functions private to the AGP code.
 */
struct device	*agp_attach_bus(struct pci_attach_args *,
		     const struct agp_methods *, bus_addr_t, bus_size_t,
		     struct device *);
struct agp_gatt *
	agp_alloc_gatt(bus_dma_tag_t, u_int32_t);
void	agp_free_gatt(bus_dma_tag_t, struct agp_gatt *);
void	agp_flush_cache(void);
void	agp_flush_cache_range(vaddr_t, vsize_t);
int	agp_generic_enable(struct agp_softc *, u_int32_t);
int	agp_init_map(bus_space_tag_t, bus_addr_t, bus_size_t, int, struct
	    agp_map **);
void	agp_destroy_map(struct agp_map *);
int	agp_map_subregion(struct agp_map *, bus_size_t, bus_size_t,
	    bus_space_handle_t *);
void	agp_unmap_subregion(struct agp_map *, bus_space_handle_t,
	    bus_size_t);
void	agp_map_atomic(struct agp_map *, bus_size_t, bus_space_handle_t *);
void	agp_unmap_atomic(struct agp_map *, bus_space_handle_t);

int	agp_alloc_dmamem(bus_dma_tag_t, size_t, bus_dmamap_t *,
	    bus_addr_t *, bus_dma_segment_t *);
void	agp_free_dmamem(bus_dma_tag_t, size_t, bus_dmamap_t,
	    bus_dma_segment_t *);
int	agpdev_print(void *, const char *);
int	agpbus_probe(struct agp_attach_args *aa);

paddr_t	agp_mmap(struct agp_softc *, off_t, int);

/*
 * Kernel API
 */
/*
 * Find the AGP device and return it.
 */
void	*agp_find_device(int);

/*
 * Return the current owner of the AGP chipset.
 */
enum	 agp_acquire_state agp_state(void *);

/*
 * Query the state of the AGP system.
 */
void	 agp_get_info(void *, struct agp_info *);

/*
 * Acquire the AGP chipset for use by the kernel. Returns EBUSY if the
 * AGP chipset is already acquired by another user.
 */
int	 agp_acquire(void *);

/*
 * Release the AGP chipset.
 */
int	 agp_release(void *);

/*
 * Enable the agp hardware with the relavent mode. The mode bits are
 * defined in <dev/pci/agpreg.h>
 */
int	 agp_enable(void *, u_int32_t);

/*
 * Retrieve information about a memory block allocated with
 * agp_alloc_memory().
 */
void	 agp_memory_info(void *, void *, struct agp_memory_info *);

#endif /* !_PCI_AGPVAR_H_ */
@


1.32
log
@Move agp_generic_enable() prototype to agpvar.h to unbreak the build on
macppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.31 2014/09/20 16:15:16 kettenis Exp $	*/
a43 6
/* we can't use the BUS_DMA_NOCACHE here or it won't get mapped via the gtt */
#define BUS_DMA_GTT_NOCACHE		(1 << 30)
#define BUS_DMA_GTT_CACHE_LLC		(1 << 29)
#define BUS_DMA_GTT_CACHE_LLC_MLC	(1 << 28)
#define BUS_DMA_GTT_WRAPAROUND		(1 << 27)

a63 19
 * Data structure to describe an AGP memory allocation.
 */
TAILQ_HEAD(agp_memory_list, agp_memory);
struct agp_memory {
	TAILQ_ENTRY(agp_memory)	 am_link;	/* wiring for the tailq */
	bus_dmamap_t		 am_dmamap;
	bus_dma_segment_t	*am_dmaseg;
	bus_size_t		 am_size;	/* number of bytes allocated */
	bus_size_t		 am_offset;	/* page offset if bound */
	paddr_t			 am_physical;
	caddr_t			 am_kva;	/* kva if mapped */
	u_int32_t		 am_mapref;	/* mapping reference count */
	int			 am_id;		/* unique id for block */
	int			 am_is_bound;	/* non-zero if bound */
	int			 am_nseg;
	int			 am_type;	/* chipset specific type */
};

/*
a86 5
	struct agp_memory *
		(*alloc_memory)(void *, int, vsize_t);
	int	(*free_memory)(void *, struct agp_memory *);
	int	(*bind_memory)(void *, struct agp_memory *, bus_size_t);
	int	(*unbind_memory)(void *, struct agp_memory *);
a94 2
	struct agp_memory_list		 sc_memory; 	/* mem blocks */
	struct rwlock			 sc_lock;	/* GATT access lock */
a138 3
int	agp_generic_bind_memory(struct agp_softc *, struct agp_memory *,
	    bus_size_t);
int	agp_generic_unbind_memory(struct agp_softc *, struct agp_memory *);
a155 3
void	*agp_map(struct agp_softc *, bus_addr_t, bus_size_t,
	    bus_space_handle_t *);
void	agp_unmap(struct agp_softc *, void *, size_t, bus_space_handle_t);
a191 25

/*
 * Allocate physical memory suitable for mapping into the AGP
 * aperture.  The value returned is an opaque handle which can be
 * passed to agp_bind(), agp_unbind() or agp_deallocate().
 */
void	*agp_alloc_memory(void *, int, vsize_t);

/*
 * Free memory which was allocated with agp_allocate().
 */
void	 agp_free_memory(void *, void *);

/*
 * Bind memory allocated with agp_allocate() at a given offset within
 * the AGP aperture. Returns EINVAL if the memory is already bound or
 * the offset is not at an AGP page boundary.
 */
int	 agp_bind_memory(void *, void *, off_t);

/*
 * Unbind memory from the AGP aperture. Returns EINVAL if the memory
 * is not bound.
 */
int	 agp_unbind_memory(void *, void *);
@


1.31
log
@On i386, agp_map_subregion might sleep, which is not allowed in some of
the inteldrm code.  Fix this by adding new interfaces that can map a single
page without sleeping and use that in the execbuffer fast path that needs
this "atomic" behaviour.  Should fix the panic I've seen under memory pressure
on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.30 2014/03/26 14:41:41 mpi Exp $	*/
d170 1
@


1.30
log
@No need to include <sys/lock.h> when only <sys/rwlock.h> is needed,
so remove the former and include the latter instead of pulling it
in <dev/pci/agpvar.h>.  This header already requires various other
types anyway.  While here remove unneeded headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.29 2013/12/09 19:52:11 kettenis Exp $	*/
d180 2
@


1.29
log
@Remove MD intagp(4) code that is unused now that inteldrm(4) manages the GTT
all by itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.28 2013/12/07 10:57:06 kettenis Exp $	*/
a33 2

#include <sys/rwlock.h>
@


1.28
log
@Remove the agp-specific bus_dma code.  It is no longer used now that
inteldrm(4) manages the GTT by itself.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.27 2013/04/14 19:04:37 kettenis Exp $	*/
a112 2
	void	(*dma_sync)(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
		    bus_size_t, int);
@


1.27
log
@Take a different approach towards framebuffer accelartion.  Instead of using
the blitter, scroll by double-mapping the framebuffer and reprogramming the
registers that determine the first visible pixel, much in the same way as the
vga text console uses the 6845.  This makes scrolling very fast, and since we
no longer need to issue commands to any of the rings, we can enable this when
X is running and safely scroll when printing panic messages or if we've
entered ddb.

Testes by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.26 2013/03/18 12:02:56 jsg Exp $	*/
a190 7

int	agp_bus_dma_init(struct agp_softc *, bus_addr_t, bus_addr_t,
	    bus_dma_tag_t *);
void	agp_bus_dma_destroy(struct agp_softc *, bus_dma_tag_t);
void	agp_bus_dma_set_alignment(bus_dma_tag_t, bus_dmamap_t,
	    u_long);
void	agp_bus_dma_rebind(bus_dma_tag_t, bus_dmamap_t, int);
@


1.26
log
@Indirectly pass the cache level down to agp by abusing spare bus_dma bits.
Currently only used on gen6+, everything else keeps the old semantics.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.25 2013/03/18 11:14:44 jsg Exp $	*/
d50 1
@


1.25
log
@stash the number of stolen entries in the agp struct
will be used in a future commit
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.24 2013/03/17 21:49:00 kettenis Exp $	*/
d45 5
@


1.24
log
@Add an interface to rebind AGP DMA mappings.  To be used by the upcoming KMS
support to reload bindings after suspend/resume and to update cachability
flags in the address translation table entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.23 2012/12/06 15:05:21 mpi Exp $	*/
d134 1
@


1.23
log
@Rework how AGP memory regions are mapped and add support for AGP bridges
that do not support remapping for processor accesses.

Add new functions to map/unmap/mmap agp memory and let the agp layer
decides how these memory regions should be accessed. It's assumed here
that the bridge does not support remapping if its aperture address is 0.

This is the last diff required for having drm(4) on macppc using agp(4).

Joint work with and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.22 2010/05/10 22:06:04 oga Exp $	*/
d190 1
@


1.22
log
@Continue with the horrible habit of using agp_machdep.c for agp related MD
things that there really isn't a decent api for elsewhere.

Since on recent intel IGPs the gtt aperture is too big (256meg is not
uncommon) to be mapped on a kva-constrained arch like i386, introduce an agp
mapping api that does things depending on arch.

On amd64 which can afford the space (and will use the direct mapping
again soon)just do bus_space_map() on init, then parcels things out
using bus_space_subregion(), thus avoiding map/unmap overhead on every
call (this is how inteldrm does things right now).

On i386, we do bus_space_map() and bus_space_unmap as appropriate. Linux
has some tricks here involving ``atomic'' maps that are on only one cpu
and that you may not sleep with to avoid the ipi overhead for tlb
flushing. For now we don't go down that route but it is being
considered.

I am also considering if it is worth abstracting this a little more,
improving the api and making it a general MD interface.

Tested by myself on i386 and amd64 and by drahn@@ (who has one of the
machines with an aperture that is too big) on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.21 2010/04/08 01:26:44 oga Exp $	*/
d76 2
d129 1
a184 1

d190 6
@


1.21
log
@Fill in the bus_dma_sync for intagp to use clflush instead of wbinvd()
if supported.

When we do memory management on intel this would lead to a LOT of
wbinvd() to deal with gpu->cpu incoherency. no one wants that.

Needed for sanity of inteldrm memory management which is coming up next.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.20 2009/06/06 06:02:44 oga Exp $	*/
d151 2
d167 7
@


1.20
log
@add an interface to agp to create a bus_dma_tag over a range of the
aperture, which will take your memory, bind it to agp, and return you the
aperture address. It's essentially the same as iommu on amd64 in the way it
works.

This will be used by the upcoming (works but is slow and will not be
enabled at first) drm memory management code for intel igp chipsets.

Right now the sync function for intagp is really slow (doing a wbinvd()
on every sync), this is in the process of getting fixed, but the size of
the diffs in my trees was getting silly.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.19 2009/05/10 16:57:44 oga Exp $	*/
d161 1
@


1.19
log
@Change agp attach (again) so that the driver passes in the aperture size.

While the aperture size may change during attach, it never changes after
the end of the subdriver attach function, so getting this value with a
function is a waste of time. shrinks things slightly and makes the code
clearer.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.18 2009/05/10 15:28:45 oga Exp $	*/
d105 2
d173 5
@


1.18
log
@In preparation for using agp as a bus_dma backend for drm, convert the bind_page
and unbind_page callbacks from

int bind_page(void *, off_t, bus_addr_t)

to

void bind_page(void *, bus_addr_t, paddr_t, int)

We can make these function void by making sure that the agp code sanity
checks properly (it already mostly did), so by definition these
functions may not fail.  The flags field is currently unused (intagp at
least will have a use for it soon).

Been in my tree for ages.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.17 2009/05/10 14:44:42 oga Exp $	*/
d56 1
a101 1
	bus_size_t (*get_aperture)(void *);
a124 1
	bus_addr_t			 sc_apaddr;
d127 2
d153 1
a153 1
		     const struct agp_methods *, bus_addr_t,
@


1.17
log
@change agp driver attach so that the driver passes in the base address
of its aperture, instead of the BAR and memory type. This is a little
larger, but allows the driver to know it's aperture address. Needed for
some future stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.16 2009/04/20 01:28:45 oga Exp $	*/
d69 10
a78 10
	TAILQ_ENTRY(agp_memory) am_link;	/* wiring for the tailq */
	int		am_id;			/* unique id for block */
	vsize_t		am_size;		/* number of bytes allocated */
	int		am_type;		/* chipset specific type */
	off_t		am_offset;		/* page offset if bound */
	int		am_is_bound;		/* non-zero if bound */
	bus_addr_t	am_physical;
	bus_dmamap_t	am_dmamap;
	int		am_nseg;
	bus_dma_segment_t *am_dmaseg;
d102 2
a103 2
	int	(*bind_page)(void *, off_t, bus_addr_t);
	int	(*unbind_page)(void *, off_t);
d109 1
a109 1
	int	(*bind_memory)(void *, struct agp_memory *, off_t);
a153 2
int	agp_map_aperture(struct pci_attach_args *, 
	    struct agp_softc *, u_int32_t, u_int32_t);
d158 2
a159 1
int	agp_generic_bind_memory(struct agp_softc *, struct agp_memory *, off_t);
@


1.16
log
@Don't map all agp memory we allocate.

If we're just going to be making it available to userland (the X
server), just use load_raw and make sure it's zeroed with BUS_DMA_ZERO.
Should save $AMOUNT_BOUND_TO_GART kva. Most kernel users also write
through the gart, so no mapping there either.

tested by sthen and todd a while back.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.15 2008/11/09 15:11:19 oga Exp $	*/
d55 1
a55 2
	int				 aa_bar;
	pcireg_t			 aa_type;
d152 1
a152 1
		     const struct agp_methods *, int, pcireg_t,
@


1.15
log
@Rework that way that agp attaches.

previously, we had a static list of pcidevs and which agp driver would
be interanlly attached. Instead, split the agp drivers so they work like
audio(4), where we attach a driver, which sets up some callbacks and
initial state, then attaches the interface (agp(4)). Since this allows
us to attach different drivers in different places, and give them
/proper/ probe functions move most of the drivers back to attaching at
pchb, where they should, and intagp (formerly agp_i810) stays attaching
at vga, since it's part of the intel integrated graphics chips.

Diff shrinks the kernel slightly, gets rid of the annoying "no integrated
graphics" warning, and allows more cleanup later.

Tested by many. fix for alpha build (the only other vga_pci.c consumer)
suggested by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.14 2008/07/12 17:31:06 oga Exp $	*/
a76 1
	caddr_t		am_virtual;
d164 2
a165 2
int	agp_alloc_dmamem(bus_dma_tag_t, size_t, int, bus_dmamap_t *,
	    caddr_t *, bus_addr_t *, bus_dma_segment_t *, int, int *);
d167 1
a167 1
	    caddr_t, bus_dma_segment_t *, int nseg) ;
@


1.14
log
@Right now agp_generic_enable() is wrong. It has been since 2006. It
assumes that the display device and the agp bridge are the same device.
In almost all cases this is incorrect.

In order to correctly enable the agp device with the correct mode, we
need to set the AGP_COMMAND register on both the display and the bridge
with the right bits. Since agp is currently attaching at vga(4), due to
the problems with the intel integrated graphics (a problem that I still
need to solve, to be honest), for now just provide both pci_attach_args
to the agp init, and get what we need from there to do the enable.

This fixes the "agp bug" which i have been known to rant about, a lot.
So agp radeons now work with dri without needing to be forced to pci
mode.

This wasn't detected before, since the only non-drm consumer of agp is
the intel X driver, the i810 agp driver has its own enable function.

tested by many. ok kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.13 2008/05/06 19:19:02 oga Exp $	*/
d46 5
d52 5
a56 2
        struct pci_attach_args apa_pci_args;
        struct pci_attach_args apa_vga_args;
a101 2
struct agp_softc;

d103 5
a107 6
	u_int32_t (*get_aperture)(struct agp_softc *);
	int	(*set_aperture)(struct agp_softc *, u_int32_t);
	int	(*bind_page)(struct agp_softc *, off_t, bus_addr_t);
	int	(*unbind_page)(struct agp_softc *, off_t);
	void	(*flush_tlb)(struct agp_softc *);
	int	(*enable)(struct agp_softc *, u_int32_t mode);
d109 5
a113 17
		(*alloc_memory)(struct agp_softc *, int, vsize_t);
	int	(*free_memory)(struct agp_softc *, struct agp_memory *);
	int	(*bind_memory)(struct agp_softc *, struct agp_memory *,
		    off_t);
	int	(*unbind_memory)(struct agp_softc *, struct agp_memory *);
};

#define AGP_GET_APERTURE(sc)	 ((sc)->sc_methods->get_aperture(sc))
#define AGP_SET_APERTURE(sc,a)	 ((sc)->sc_methods->set_aperture((sc),(a)))
#define AGP_BIND_PAGE(sc,o,p)	 ((sc)->sc_methods->bind_page((sc),(o),(p)))
#define AGP_UNBIND_PAGE(sc,o)	 ((sc)->sc_methods->unbind_page((sc), (o)))
#define AGP_FLUSH_TLB(sc)	 ((sc)->sc_methods->flush_tlb(sc))
#define AGP_ENABLE(sc,m)	 ((sc)->sc_methods->enable((sc),(m)))
#define AGP_ALLOC_MEMORY(sc,t,s) ((sc)->sc_methods->alloc_memory((sc),(t),(s)))
#define AGP_FREE_MEMORY(sc,m)	 ((sc)->sc_methods->free_memory((sc),(m)))
#define AGP_BIND_MEMORY(sc,m,o)	 ((sc)->sc_methods->bind_memory((sc),(m),(o)))
#define AGP_UNBIND_MEMORY(sc,m)	 ((sc)->sc_methods->unbind_memory((sc),(m)))
d119 1
a119 1
	struct device sc_dev;
d121 15
a135 25
	bus_space_tag_t		sc_bt, sc_memt;
	bus_space_handle_t	sc_bh;
	bus_addr_t		sc_apaddr;
	bus_size_t		sc_apsize;
	bus_dma_tag_t		sc_dmat;
	struct rwlock		sc_lock;	/* lock for access to GATT */
	pcitag_t		sc_pcitag;	/* PCI tag, in case we need it. */
	pcireg_t		sc_id;
	pci_chipset_tag_t	sc_pc;

	pci_chipset_tag_t	sc_vgapc;
	pcitag_t		sc_vgapcitag;

	struct agp_methods 	*sc_methods;
	void			*sc_chipc;	/* chipset-dependent state */

	int			sc_opened;
	int			sc_capoff;			
	int			sc_apflags;
	int			sc_nextid;	/* next memory block id */

	u_int32_t		sc_maxmem;	/* allocation upper bound */
	u_int32_t		sc_allocated;	/* amount allocated */
	enum agp_acquire_state	sc_state;
	struct agp_memory_list	sc_memory;	/* list of allocated memory */
d137 2
a138 1
	struct vga_pci_softc	*vga_softc;	/* needed for shared mappings */
a149 17

struct agp_product {
	int	ap_vendor;
	int	ap_product;
	int	(*ap_attach)(struct agp_softc *,
		     struct pci_attach_args *);
};
/* MD-defined */
extern 	const struct agp_product agp_products[];

void	agp_attach(struct device *, struct device *, void *);
int	agp_probe(struct device *, void *, void *);
paddr_t	agpmmap(void *, off_t, int);
int	agpioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	agpopen(dev_t, int, int, struct proc *);
int	agpclose(dev_t, int, int , struct proc *);
void	agp_set_pchb(struct pci_attach_args*);
d153 3
a155 2

int	agp_find_caps(pci_chipset_tag_t, pcitag_t);
a157 2
u_int32_t agp_generic_get_aperture(struct agp_softc *);
int	agp_generic_set_aperture(struct agp_softc *, u_int32_t);
d159 2
a160 2
	agp_alloc_gatt(struct agp_softc *);
void	agp_free_gatt(struct agp_softc *, struct agp_gatt *);
d162 1
a162 8
int	agp_generic_attach(struct agp_softc *);
int	agp_generic_detach(struct agp_softc *);
int	agp_generic_enable(struct agp_softc *, u_int32_t);
struct agp_memory *
	agp_generic_alloc_memory(struct agp_softc *, int, vsize_t size);
int	agp_generic_free_memory(struct agp_softc *, struct agp_memory *);
int	agp_generic_bind_memory(struct agp_softc *, struct agp_memory *,
	    off_t);
a164 7
int	agp_ali_attach(struct agp_softc *, struct pci_attach_args *);
int	agp_amd_attach(struct agp_softc *, struct pci_attach_args *);
int	agp_i810_attach(struct agp_softc *, struct pci_attach_args *);
int	agp_intel_attach(struct agp_softc *, struct pci_attach_args *);
int	agp_via_attach(struct agp_softc *, struct pci_attach_args *);
int	agp_sis_attach(struct agp_softc *, struct pci_attach_args *);

d169 2
@


1.13
log
@currently agp_i810 needs to map the same BAR as inteldrm, this obviously
fails.

In order to allow this, implement an API so that drm and agp can share
mappings for the BARs. Now it works as it should.

tested by many.
ok kettenis, miod said he'd look at it when it's in tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.12 2008/03/23 19:54:47 oga Exp $	*/
d48 1
d137 3
@


1.12
log
@Sometimes the registers claiming the aperture size on 9XX chipsets lie.

So instead, use the size of the aperture BAR to determine the aperture
size for agp_i810, and don't let the 855 and above have the aperture
set. Next to nothing uses it anyway so no harm.

introduce generic_{get,set} aperture which has this behaviour so other
drivers may use it if useful.

Change inspired by what freebsd did after i noticed my aperture size was
wrong.

Tested by many, ok kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.11 2008/03/16 19:00:28 oga Exp $	*/
d149 2
@


1.11
log
@Make agp(4) attach at vga(4) instead of pchb(4). This is because sometimes
agp and drm need to use the same memory mapping, the best way to deal
with that is to allow them to share (that's coming later), for this to
work cleanly we move the attach point of agp.

Ideally most agp drivers would attach at pchb, with only agp_i810
(and any that work similarly) attaching at vga, but this will do for
now.

ok kettenis@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.10 2007/12/07 17:35:22 oga Exp $	*/
d184 2
@


1.10
log
@KNF, no binary change.

Looked over by a few people.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.7 2007/11/25 17:11:12 oga Exp $	*/
a46 1
        char    *apa_busname; 
d176 1
@


1.9
log
@Replace lockmgr with rwlock.

advice from thib. Comments and ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.8 2007/12/06 22:49:39 oga Exp $	*/
d128 17
a144 17
	bus_space_tag_t sc_bt, sc_memt;
	bus_space_handle_t sc_bh;
	bus_addr_t sc_apaddr;
	bus_size_t sc_apsize;
	bus_dma_tag_t sc_dmat;
	struct rwlock sc_lock;		/* lock for access to GATT */
	pcitag_t sc_pcitag;		/* PCI tag, in case we need it. */
	pcireg_t sc_id;
	pci_chipset_tag_t sc_pc;

	struct agp_methods *sc_methods;
	void	*sc_chipc;		/* chipset-dependent state */

	int sc_opened;
	int sc_capoff;			
	int sc_apflags;
	int sc_nextid;	/* next memory block id */
d169 1
a169 1
extern const struct agp_product agp_products[];
d171 6
a176 6
void agp_attach(struct device *, struct device *, void *);
int agp_probe(struct device *, void *, void *);
paddr_t agpmmap(void *, off_t, int);
int agpioctl(dev_t, u_long, caddr_t, int, struct proc *);
int agpopen(dev_t, int, int, struct proc *);
int agpclose(dev_t, int, int , struct proc *);
d182 2
a183 3
int
agp_map_aperture(struct pci_attach_args *, struct agp_softc *,
	    u_int32_t, u_int32_t);
d217 1
a217 1
void *agp_find_device(int);
d222 1
a222 1
enum agp_acquire_state agp_state(void *);
d227 1
a227 1
void agp_get_info(void *, struct agp_info *);
d233 1
a233 1
int agp_acquire(void *);
d238 1
a238 1
int agp_release(void *);
d244 1
a244 1
int agp_enable(void *, u_int32_t);
d251 1
a251 1
void *agp_alloc_memory(void *, int, vsize_t);
d256 1
a256 1
void agp_free_memory(void *, void *);
d263 1
a263 1
int agp_bind_memory(void *, void *, off_t);
d269 1
a269 1
int agp_unbind_memory(void *, void *);
d275 1
a275 1
void agp_memory_info(void *, void *, struct agp_memory_info *);
@


1.8
log
@Destatic functions in the agp subsystem.

KNF coming shortly.

ok marco, jsg and mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.7 2007/11/25 17:11:12 oga Exp $	*/
d35 1
a35 1
#include <sys/lock.h>
d133 1
a133 1
	struct lock sc_lock;		/* lock for access to GATT */
@


1.7
log
@Make agp attach as a device. This means that many more agp bridges
actually get detected and attached. Also adds a kernel api for
manipulating agp.

Enable this on i386 and amd64.

"I think you should commit it" deraadt@@, ok matthieu. Looked over by
several others.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.6 2007/08/04 19:40:25 reyk Exp $	*/
d172 1
@


1.6
log
@Add AGP support for the intel i965 chipset, this also extends the
internal AGP API to work with 64bit PCI-Express memory and
non-standard AGP aperture bases.

tested by many
ok matthieu@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.5 2006/11/26 18:35:51 dim Exp $	*/
a35 1
#include <dev/pci/vga_pcivar.h>
d46 50
d97 6
a102 6
	u_int32_t (*get_aperture)(struct vga_pci_softc *);
	int	(*set_aperture)(struct vga_pci_softc *, u_int32_t);
	int	(*bind_page)(struct vga_pci_softc *, off_t, bus_addr_t);
	int	(*unbind_page)(struct vga_pci_softc *, off_t);
	void	(*flush_tlb)(struct vga_pci_softc *);
	int	(*enable)(struct vga_pci_softc *, u_int32_t mode);
d104 3
a106 3
		(*alloc_memory)(struct vga_pci_softc *, int, vsize_t);
	int	(*free_memory)(struct vga_pci_softc *, struct agp_memory *);
	int	(*bind_memory)(struct vga_pci_softc *, struct agp_memory *,
d108 1
a108 1
	int	(*unbind_memory)(struct vga_pci_softc *, struct agp_memory *);
d125 26
d162 14
d181 3
a183 1
int	agp_map_aperture(struct vga_pci_softc *, u_int32_t, u_int32_t);
d185 2
a186 2
	agp_alloc_gatt(struct vga_pci_softc *);
void	agp_free_gatt(struct vga_pci_softc *, struct agp_gatt *);
d188 3
a190 3
int	agp_generic_attach(struct vga_pci_softc *);
int	agp_generic_detach(struct vga_pci_softc *);
int	agp_generic_enable(struct vga_pci_softc *, u_int32_t);
d192 3
a194 3
	agp_generic_alloc_memory(struct vga_pci_softc *, int, vsize_t size);
int	agp_generic_free_memory(struct vga_pci_softc *, struct agp_memory *);
int	agp_generic_bind_memory(struct vga_pci_softc *, struct agp_memory *,
d196 1
a196 1
int	agp_generic_unbind_memory(struct vga_pci_softc *, struct agp_memory *);
d198 6
a203 12
int	agp_ali_attach(struct vga_pci_softc *, struct pci_attach_args *,
	    struct pci_attach_args *);
int	agp_amd_attach(struct vga_pci_softc *, struct pci_attach_args *,
	    struct pci_attach_args *);
int	agp_i810_attach(struct vga_pci_softc *, struct pci_attach_args *,
	    struct pci_attach_args *);
int	agp_intel_attach(struct vga_pci_softc *, struct pci_attach_args *,
	    struct pci_attach_args *);
int	agp_via_attach(struct vga_pci_softc *, struct pci_attach_args *,
	    struct pci_attach_args *);
int	agp_sis_attach(struct vga_pci_softc *, struct pci_attach_args *,
	    struct pci_attach_args *);
d209 67
@


1.5
log
@Make sure AGP debug printfs actually compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.4 2006/03/10 21:52:02 matthieu Exp $	*/
d92 1
a92 1
int	agp_map_aperture(struct vga_pci_softc *);
@


1.4
log
@Clean up unused definitions. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.3 2002/07/25 23:31:04 fgsch Exp $	*/
d40 1
a40 4
#define AGP_DPF(x...) do {			\
    printf("agp: ");				\
    printf(##x);				\
} while (0)
d42 1
a42 1
#define AGP_DPF(x...) do {} while (0)
@


1.3
log
@- some KNF.
- comment out debugging printf for i810.
- remove checks for failure if malloc is used with M_WAITOK.

mickey@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.2 2002/07/15 13:23:48 mickey Exp $	*/
a36 19

/*
 * This structure is used to query the state of the AGP system.
 */
struct agp_info {
	u_int32_t	ai_mode;
	bus_addr_t	ai_aperture_base;
	bus_size_t	ai_aperture_size;
	vsize_t		ai_memory_allowed;
	vsize_t		ai_memory_used;
	u_int32_t	ai_devid;
};

struct agp_memory_info {
	vsize_t		ami_size;	/* size in bytes */
	bus_addr_t	ami_physical;	/* bogus hack for i810 */
	off_t		ami_offset;	/* page offset if bound */
	int		ami_is_bound;	/* non-zero if bound */
};
@


1.3.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2
log
@remove a bunch of debugging printfs and disable agp_debug; prompted by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agpvar.h,v 1.1 2002/07/12 20:17:03 mickey Exp $	*/
d71 11
a81 9
	int (*set_aperture)(struct vga_pci_softc *, u_int32_t);
	int (*bind_page)(struct vga_pci_softc *, off_t, bus_addr_t);
	int (*unbind_page)(struct vga_pci_softc *, off_t);
	void (*flush_tlb)(struct vga_pci_softc *);
	int (*enable)(struct vga_pci_softc *, u_int32_t mode);
	struct agp_memory *(*alloc_memory)(struct vga_pci_softc *, int, vsize_t);
	int (*free_memory)(struct vga_pci_softc *, struct agp_memory *);
	int (*bind_memory)(struct vga_pci_softc *, struct agp_memory *, off_t);
	int (*unbind_memory)(struct vga_pci_softc *, struct agp_memory *);
d113 33
a145 26
int agp_find_caps(pci_chipset_tag_t pct, pcitag_t pt);
int agp_map_aperture(struct vga_pci_softc *sc);
struct agp_gatt *agp_alloc_gatt(struct vga_pci_softc *sc);
void agp_free_gatt(struct vga_pci_softc *sc, struct agp_gatt *gatt);
void agp_flush_cache(void);
int agp_generic_attach(struct vga_pci_softc *sc);
int agp_generic_detach(struct vga_pci_softc *sc);
int agp_generic_enable(struct vga_pci_softc *sc, u_int32_t mode);
struct agp_memory *agp_generic_alloc_memory(struct vga_pci_softc *sc, int type,
						 vsize_t size);
int agp_generic_free_memory(struct vga_pci_softc *sc, struct agp_memory *mem);
int agp_generic_bind_memory(struct vga_pci_softc *sc, struct agp_memory *mem,
						off_t offset);
int agp_generic_unbind_memory(struct vga_pci_softc *sc, struct agp_memory *mem);

int agp_ali_attach(struct vga_pci_softc *sc, struct pci_attach_args *pa, struct pci_attach_args *p);
int agp_amd_attach(struct vga_pci_softc *sc, struct pci_attach_args *pa, struct pci_attach_args *p);
int agp_i810_attach(struct vga_pci_softc *sc, struct pci_attach_args *pa, struct pci_attach_args *p);
int agp_intel_attach(struct vga_pci_softc *sc, struct pci_attach_args *pa, struct pci_attach_args *p);
int agp_via_attach(struct vga_pci_softc *sc, struct pci_attach_args *pa, struct pci_attach_args *p);
int agp_sis_attach(struct vga_pci_softc *sc, struct pci_attach_args *pa, struct pci_attach_args *p);

int agp_alloc_dmamem(bus_dma_tag_t, size_t, int, bus_dmamap_t *, caddr_t *,
		     bus_addr_t *, bus_dma_segment_t *, int, int *);
void agp_free_dmamem(bus_dma_tag_t tag, size_t size, bus_dmamap_t map,
		     caddr_t vaddr, bus_dma_segment_t *seg, int nseg) ;
@


1.1
log
@support for the agp gart on various agp chipsets.
only i810 driver was tested though.
based on the netbsd's lkm, initially ported
by hunter@@dg.net.ua and later made into shape by mickey.
testing by art@@ and millert@@ .
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 6
a47 6
	u_int32_t	 ai_mode;
	bus_addr_t	  ai_aperture_base;
	bus_size_t	  ai_aperture_size;
	vsize_t		       ai_memory_allowed;
	vsize_t		       ai_memory_used;
	u_int32_t	 ai_devid;
d51 4
a54 4
	vsize_t		       ami_size;	/* size in bytes */
	bus_addr_t	  ami_physical;	       /* bogus hack for i810 */
	off_t		     ami_offset;	/* page offset if bound */
	int		   ami_is_bound;	/* non-zero if bound */
d57 1
a57 1
#define	AGP_DEBUG
@

