head	1.73;
access;
symbols
	OPENBSD_6_1_BASE:1.73
	OPENBSD_6_0:1.72.0.6
	OPENBSD_6_0_BASE:1.72
	OPENBSD_5_9:1.72.0.2
	OPENBSD_5_9_BASE:1.72
	OPENBSD_5_8:1.54.0.6
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.54.0.4
	OPENBSD_5_7_BASE:1.54
	OPENBSD_5_6:1.53.0.4
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.50.0.4
	OPENBSD_5_5_BASE:1.50
	OPENBSD_5_4:1.49.0.2
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.48.0.10
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.48.0.8
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.6
	OPENBSD_5_0:1.48.0.4
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.48.0.2
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.47.0.2
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.46.0.2
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.44.0.4
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.37.0.2
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.36.0.2
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.35.0.2
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.27.0.2
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.1
	SMP:1.1.0.8
	OPENBSD_3_3:1.1.0.6
	OPENBSD_3_3_BASE:1.1
	UBC:1.1.0.4
	UBC_SYNC_B:1.1
	OPENBSD_3_2:1.1.0.2
	OPENBSD_3_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.73
date	2016.10.27.03.06.53;	author dlg;	state Exp;
branches;
next	1.72;
commitid	tMxqIWVTjiRzeFoN;

1.72
date	2016.02.18.14.24.39;	author bluhm;	state Exp;
branches;
next	1.71;
commitid	byf6gliq76JeDmXn;

1.71
date	2016.01.11.01.31.53;	author dlg;	state Exp;
branches;
next	1.70;
commitid	thOCri5A37wAVmo3;

1.70
date	2016.01.07.11.19.54;	author dlg;	state Exp;
branches;
next	1.69;
commitid	wWgJmkazk961VJfi;

1.69
date	2016.01.07.07.18.07;	author dlg;	state Exp;
branches;
next	1.68;
commitid	ihMyfWHDTPiEzfbD;

1.68
date	2016.01.07.07.03.55;	author dlg;	state Exp;
branches;
next	1.67;
commitid	l4hf68jdiFFUPlBg;

1.67
date	2016.01.07.06.25.35;	author dlg;	state Exp;
branches;
next	1.66;
commitid	PWgk6EYyw1tl5DDn;

1.66
date	2016.01.07.05.34.11;	author dlg;	state Exp;
branches;
next	1.65;
commitid	lQMzNuMfiPEoy70A;

1.65
date	2016.01.07.04.37.53;	author dlg;	state Exp;
branches;
next	1.64;
commitid	tzVWqIOXQjQlBfSc;

1.64
date	2016.01.07.04.30.45;	author dlg;	state Exp;
branches;
next	1.63;
commitid	OXnjNH3hhKuBOevC;

1.63
date	2016.01.07.04.21.36;	author dlg;	state Exp;
branches;
next	1.62;
commitid	37DaaqmjJ4UFqRg1;

1.62
date	2016.01.07.03.56.03;	author dlg;	state Exp;
branches;
next	1.61;
commitid	ioMNsUl2QDhTGC3w;

1.61
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.60;
commitid	5gdEnqVoJuTuwdTu;

1.60
date	2015.11.20.14.32.33;	author mpi;	state Exp;
branches;
next	1.59;
commitid	RJjP3TXNlv2oGD0G;

1.59
date	2015.11.14.17.54.57;	author mpi;	state Exp;
branches;
next	1.58;
commitid	Waft2RDjXAxr4qZ9;

1.58
date	2015.09.30.11.25.08;	author kettenis;	state Exp;
branches;
next	1.57;
commitid	bsKIVU2MHH8EeBw9;

1.57
date	2015.09.19.12.48.26;	author kettenis;	state Exp;
branches;
next	1.56;
commitid	xW9tscJ44ApnBTFq;

1.56
date	2015.08.26.09.17.20;	author kettenis;	state Exp;
branches;
next	1.55;
commitid	ze8pXARkfnKEgh8n;

1.55
date	2015.08.21.09.16.06;	author kettenis;	state Exp;
branches;
next	1.54;
commitid	MPNQ3ZVIFZ5E3Uat;

1.54
date	2014.12.26.05.46.32;	author tedu;	state Exp;
branches;
next	1.53;
commitid	BEFV1zuqezFBud1r;

1.53
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.52;
commitid	TGHgrLxu6sxZoiFt;

1.52
date	2014.07.10.14.21.20;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	Jjzk0Y0KSLF2oro4;

1.51
date	2014.07.08.05.35.18;	author dlg;	state Exp;
branches;
next	1.50;
commitid	0QJleeeWqZmC5anF;

1.50
date	2013.08.07.01.06.34;	author bluhm;	state Exp;
branches;
next	1.49;

1.49
date	2013.04.16.22.21.32;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2010.09.07.16.21.44;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2009.11.25.13.28.13;	author dms;	state Exp;
branches;
next	1.45;

1.45
date	2009.08.10.19.41.05;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2009.06.05.16.27.40;	author naddy;	state Exp;
branches;
next	1.43;

1.43
date	2008.12.15.02.33.04;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2008.12.05.00.08.17;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2008.12.03.00.59.48;	author dlg;	state Exp;
branches;
next	1.40;

1.40
date	2008.11.29.10.23.29;	author sthen;	state Exp;
branches;
next	1.39;

1.39
date	2008.11.28.06.46.13;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2008.11.26.00.14.48;	author dlg;	state Exp;
branches;
next	1.37;

1.37
date	2008.07.22.11.20.10;	author martynas;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.21.03.49.54;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.30.06.29.17;	author ckuethe;	state Exp;
branches;
next	1.34;

1.34
date	2006.11.18.18.39.14;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2006.11.17.02.03.32;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2006.11.14.03.59.00;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2006.11.10.21.15.56;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2006.11.06.03.52.37;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2006.09.17.20.26.14;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2006.09.17.17.51.01;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2006.08.04.14.25.24;	author brad;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2006.07.07.02.56.18;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2006.07.05.01.15.30;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2006.07.03.20.55.55;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.05.19.55.10;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2006.02.22.06.02.09;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.10.18.41.50;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.10.04.01.36;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.18.18.13.29;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.13.03.48.08;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.24.21.42.34;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.21.02.10.34;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.15.14.43.37;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.16.19.05.36;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.16.17.08.02;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.02.06.15.44;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.04.02.33.31;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.27.16.38.13;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.08.15.41.46;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.16.14.39.14;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.18.20.42.35;	author mcbride;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.19.11.37.00;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.26.17.17.15;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.26.07.27.52;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.18.04.15.00;	author henric;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.13.19.21.21;	author henric;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.24.18.56.02;	author nate;	state Exp;
branches
	1.1.4.1
	1.1.8.1;
next	;

1.1.4.1
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	;

1.1.8.1
date	2004.02.19.10.56.26;	author niklas;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2004.06.05.23.12.49;	author niklas;	state Exp;
branches;
next	;

1.27.2.1
date	2006.11.07.20.51.07;	author brad;	state Exp;
branches;
next	;


desc
@@


1.73
log
@tell ix and em to use 2k+ETHER_ALIGN clusters for rx on all archs.

this means that the ethernet header and therefore its payload will
be aligned correctly for the stack. without this em and ix are
sufferring a 30 to 40 percent hit in forwarding performance because
the ethernet stack expects to be able to prepend 8 bytes for an
ethernet header so it can gaurantee its alignment. because em and
ix only had 6 bytes where the ethernet header was, it always prepends
an mbuf which turns out to be expensive. this way the prepend will
be cheap because the 8 byte space will exist.

2k+ETHER_ALIGN clusters will end up using the newly created mcl2k2
pool.

the regression was isolated and the fix tested by hrvoje popovski.
ok mikeb@@
@
text
@/**************************************************************************

Copyright (c) 2001-2003, Intel Corporation
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

 3. Neither the name of the Intel Corporation nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

***************************************************************************/

/* $FreeBSD: if_em.h,v 1.26 2004/09/01 23:22:41 pdeuskar Exp $ */
/* $OpenBSD: if_em.h,v 1.72 2016/02/18 14:24:39 bluhm Exp $ */

#ifndef _EM_H_DEFINED_
#define _EM_H_DEFINED_

#include "bpfilter.h"
#include "vlan.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/socket.h>
#include <sys/timeout.h>
#include <sys/atomic.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

typedef int	boolean_t;
#define TRUE	1
#define FALSE	0

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/pci/if_em_hw.h>

/* Tunables */

/*
 * EM_TXD: Maximum number of Transmit Descriptors
 * Valid Range: 80-256 for 82542 and 82543-based adapters
 *              80-4096 for others
 * Default Value: 256
 *   This value is the number of transmit descriptors allocated by the driver.
 *   Increasing this value allows the driver to queue more transmits. Each
 *   descriptor is 16 bytes.
 *   Since TDLEN should be multiple of 128bytes, the number of transmit
 *   descriptors should meet the following condition.
 *      (num_tx_desc * sizeof(struct em_tx_desc)) % 128 == 0
 */
#define EM_MAX_TXD_82543		256
#define EM_MAX_TXD			512

/*
 * EM_RXD - Maximum number of receive Descriptors
 * Valid Range: 80-256 for 82542 and 82543-based adapters
 *              80-4096 for others
 * Default Value: 256
 *   This value is the number of receive descriptors allocated by the driver.
 *   Increasing this value allows the driver to buffer more incoming packets.
 *   Each descriptor is 16 bytes.  A receive buffer is also allocated for each
 *   descriptor. The maximum MTU size is 16110.
 *   Since TDLEN should be multiple of 128bytes, the number of transmit
 *   descriptors should meet the following condition.
 *      (num_tx_desc * sizeof(struct em_tx_desc)) % 128 == 0
 */
#define EM_MAX_RXD_82543		256
#define EM_MAX_RXD			256

/*
 * MAX_INTS_PER_SEC (ITR - Interrupt Throttle Register)
 * The Interrupt Throttle Register (ITR) limits the delivery of interrupts
 * to a reasonable rate by providing a guaranteed inter-interrupt delay
 * between interrupts asserted by the Ethernet controller.
 */
#define MAX_INTS_PER_SEC	8000
#define DEFAULT_ITR		1000000000/(MAX_INTS_PER_SEC * 256)

/*
 * EM_TIDV - Transmit Interrupt Delay Value
 * Valid Range: 0-65535 (0=off)
 * Default Value: 64
 *   This value delays the generation of transmit interrupts in units of
 *   1.024 microseconds. Transmit interrupt reduction can improve CPU
 *   efficiency if properly tuned for specific network traffic. If the
 *   system is reporting dropped transmits, this value may be set too high
 *   causing the driver to run out of available transmit descriptors.
 */
#define EM_TIDV				64

/*
 * EM_TADV - Transmit Absolute Interrupt Delay Value
 * (Not valid for 82542/82543/82544)
 * Valid Range: 0-65535 (0=off)
 * Default Value: 64
 *   This value, in units of 1.024 microseconds, limits the delay in which a
 *   transmit interrupt is generated. Useful only if EM_TIDV is non-zero,
 *   this value ensures that an interrupt is generated after the initial
 *   packet is sent on the wire within the set amount of time.  Proper tuning,
 *   along with EM_TIDV, may improve traffic throughput in specific
 *   network conditions.
 */
#define EM_TADV				64

/*
 * EM_RDTR - Receive Interrupt Delay Timer (Packet Timer)
 * Valid Range: 0-65535 (0=off)
 * Default Value: 0
 *   This value delays the generation of receive interrupts in units of 1.024
 *   microseconds.  Receive interrupt reduction can improve CPU efficiency if
 *   properly tuned for specific network traffic. Increasing this value adds
 *   extra latency to frame reception and can end up decreasing the throughput
 *   of TCP traffic. If the system is reporting dropped receives, this value
 *   may be set too high, causing the driver to run out of available receive
 *   descriptors.
 *
 *   CAUTION: When setting EM_RDTR to a value other than 0, adapters
 *            may hang (stop transmitting) under certain network conditions.
 *            If this occurs a WATCHDOG message is logged in the system
 *            event log. In addition, the controller is automatically reset,
 *            restoring the network connection. To eliminate the potential
 *            for the hang ensure that EM_RDTR is set to 0.
 */
#define EM_RDTR				0

/*
 * Receive Interrupt Absolute Delay Timer (Not valid for 82542/82543/82544)
 * Valid Range: 0-65535 (0=off)
 * Default Value: 64
 *   This value, in units of 1.024 microseconds, limits the delay in which a
 *   receive interrupt is generated. Useful only if EM_RDTR is non-zero,
 *   this value ensures that an interrupt is generated after the initial
 *   packet is received within the set amount of time.  Proper tuning,
 *   along with EM_RDTR, may improve traffic throughput in specific network
 *   conditions.
 */
#define EM_RADV				64

/*
 * This parameter controls the duration of transmit watchdog timer.
 */
#define EM_TX_TIMEOUT			5	/* set to 5 seconds */

/*
 * Thise parameter controls the minimum number of available transmit
 * descriptors needed before we attempt transmission of a packet.
 */
#define EM_TX_OP_THRESHOLD		(sc->num_tx_desc / 32)

/*
 * This parameter controls whether or not autonegotiation is enabled.
 *              0 - Disable autonegotiation
 *              1 - Enable  autonegotiation
 */
#define DO_AUTO_NEG			1

/*
 * This parameter control whether or not the driver will wait for
 * autonegotiation to complete.
 *              1 - Wait for autonegotiation to complete
 *              0 - Don't wait for autonegotiation to complete
 */
#define WAIT_FOR_AUTO_NEG_DEFAULT	0

/*
 * EM_MASTER_SLAVE is only defined to enable a workaround for a known
 * compatibility issue with 82541/82547 devices and some switches.
 * See the "Known Limitations" section of the README file for a complete
 * description and a list of affected switches.
 *
 *              0 = Hardware default
 *              1 = Master mode
 *              2 = Slave mode
 *              3 = Auto master/slave
 */
/* #define EM_MASTER_SLAVE	2 */

/* Tunables -- End */

#define AUTONEG_ADV_DEFAULT	(ADVERTISE_10_HALF | ADVERTISE_10_FULL | \
				 ADVERTISE_100_HALF | ADVERTISE_100_FULL | \
				 ADVERTISE_1000_FULL)

#define EM_MMBA				0x0010 /* Mem base address */
#define EM_FLASH			0x0014 /* Flash memory on ICH8 */
#define EM_ROUNDUP(size, unit) (((size) + (unit) - 1) & ~((unit) - 1))

#define EM_SMARTSPEED_DOWNSHIFT		3
#define EM_SMARTSPEED_MAX		15

#define MAX_NUM_MULTICAST_ADDRESSES	128

#define PCICFG_DESC_RING_STATUS		0xe4
#define FLUSH_DESC_REQUIRED		0x100

/*
 * TDBA/RDBA should be aligned on 16 byte boundary. But TDLEN/RDLEN should be
 * multiple of 128 bytes. So we align TDBA/RDBA on 128 byte boundary. This will
 * also optimize cache line size effect. H/W supports up to cache line size 128.
 */
#define EM_DBA_ALIGN			128

#define SPEED_MODE_BIT (1<<21)		/* On PCI-E MACs only */

/* Defines for printing debug information */
#define DEBUG_INIT	0
#define DEBUG_IOCTL	0
#define DEBUG_HW	0

#define INIT_DEBUGOUT(S)		if (DEBUG_INIT)  printf(S "\n")
#define INIT_DEBUGOUT1(S, A)		if (DEBUG_INIT)  printf(S "\n", A)
#define INIT_DEBUGOUT2(S, A, B)		if (DEBUG_INIT)  printf(S "\n", A, B)
#define IOCTL_DEBUGOUT(S)		if (DEBUG_IOCTL) printf(S "\n")
#define IOCTL_DEBUGOUT1(S, A)		if (DEBUG_IOCTL) printf(S "\n", A)
#define IOCTL_DEBUGOUT2(S, A, B)	if (DEBUG_IOCTL) printf(S "\n", A, B)
#define HW_DEBUGOUT(S)			if (DEBUG_HW) printf(S "\n")
#define HW_DEBUGOUT1(S, A)		if (DEBUG_HW) printf(S "\n", A)
#define HW_DEBUGOUT2(S, A, B)		if (DEBUG_HW) printf(S "\n", A, B)

/* Supported RX Buffer Sizes */
#define EM_RXBUFFER_2048	2048
#define EM_RXBUFFER_4096	4096
#define EM_RXBUFFER_8192	8192
#define EM_RXBUFFER_16384	16384

#define EM_MCLBYTES		(EM_RXBUFFER_2048 + ETHER_ALIGN)

#define EM_MAX_SCATTER		64
#define EM_TSO_SIZE		65535

struct em_packet {
	int		 pkt_eop;	/* Index of the desc to watch */
	struct mbuf	*pkt_m;
	bus_dmamap_t	 pkt_map;	/* bus_dma map for packet */
};

/*
 * Bus dma allocation structure used by
 * em_dma_malloc and em_dma_free.
 */
struct em_dma_alloc {
	caddr_t			dma_vaddr;
	bus_dmamap_t		dma_map;
	bus_dma_segment_t	dma_seg;
	bus_size_t		dma_size;
	int			dma_nseg;
};

typedef enum _XSUM_CONTEXT_T {
	OFFLOAD_NONE,
	OFFLOAD_TCP_IP,
	OFFLOAD_UDP_IP
} XSUM_CONTEXT_T;

/* For 82544 PCI-X Workaround */
typedef struct _ADDRESS_LENGTH_PAIR
{
	u_int64_t	address;
	u_int32_t	length;
} ADDRESS_LENGTH_PAIR, *PADDRESS_LENGTH_PAIR;

typedef struct _DESCRIPTOR_PAIR
{
	ADDRESS_LENGTH_PAIR descriptor[4];
	u_int32_t	elements;
} DESC_ARRAY, *PDESC_ARRAY;

/* Our adapter structure */
struct em_softc {
	struct device	sc_dev;
	struct arpcom	sc_ac;

	bus_dma_tag_t	sc_dmat;

	struct em_hw	hw;

	/* OpenBSD operating-system-specific structures */
	struct em_osdep	osdep;
	struct ifmedia	media;
	int		io_rid;
	int		legacy_irq;

	void		*sc_intrhand;
	struct timeout	em_intr_enable;
	struct timeout	timer_handle;
	struct timeout	tx_fifo_timer_handle;

	/* Info about the board itself */
	u_int32_t	part_num;
	u_int8_t	link_active;
	u_int16_t	link_speed;
	u_int16_t	link_duplex;
	u_int32_t	smartspeed;
	u_int32_t	tx_int_delay;
	u_int32_t	tx_abs_int_delay;
	u_int32_t	rx_int_delay;
	u_int32_t	rx_abs_int_delay;

	XSUM_CONTEXT_T	active_checksum_context;

	/*
	 * Transmit definitions
	 *
	 * We have an array of num_tx_desc descriptors (handled
	 * by the controller) paired with an array of tx_buffers
	 * (at tx_buffer_area).
	 * The index of the next available descriptor is next_avail_tx_desc.
	 * The number of remaining tx_desc is num_tx_desc_avail.
	 */
	u_int			 sc_tx_slots;
	struct em_dma_alloc	 sc_tx_dma;	/* bus_dma glue for tx desc */
	struct em_tx_desc	*sc_tx_desc_ring;
	u_int			 sc_tx_desc_head;
	u_int			 sc_tx_desc_tail;
	struct em_packet	*sc_tx_pkts_ring;

	u_int32_t		 sc_txd_cmd;

	/*
	 * Receive definitions
	 *
	 * we have an array of num_rx_desc rx_desc (handled by the
	 * controller), and paired with an array of rx_buffers
	 * (at rx_buffer_area).
	 * The next pair to check on receive is at offset next_rx_desc_to_check
	 */
	u_int			 sc_rx_slots;
	struct if_rxring	 sc_rx_ring;
	struct em_dma_alloc	 sc_rx_dma;	/* bus_dma glue for rx desc */
	struct em_rx_desc	*sc_rx_desc_ring;
	u_int			 sc_rx_desc_head;
	u_int			 sc_rx_desc_tail;
	struct em_packet	*sc_rx_pkts_ring;

	u_int32_t		 sc_rx_buffer_len;

	/*
	 * First/last mbuf pointers, for
	 * collecting multisegment RX packets.
	 */
	struct mbuf		*fmp;
	struct mbuf		*lmp;

	/* Misc stats maintained by the driver */
	unsigned long		dropped_pkts;
	unsigned long		mbuf_alloc_failed;
	unsigned long		mbuf_cluster_failed;
	unsigned long		no_tx_desc_avail1;
	unsigned long		no_tx_desc_avail2;
	unsigned long		no_tx_map_avail;
	unsigned long		no_tx_dma_setup;
	unsigned long		watchdog_events;
	unsigned long		rx_overruns;

	/* Used in for 82547 10Mb Half workaround */
	#define EM_PBA_BYTES_SHIFT	0xA
	#define EM_TX_HEAD_ADDR_SHIFT	7
	#define EM_PBA_TX_MASK		0xFFFF0000
	#define EM_FIFO_HDR		0x10

	#define EM_82547_PKT_THRESH	0x3e0

	u_int32_t	tx_fifo_size;
	u_int32_t	tx_fifo_head;
	u_int32_t	tx_fifo_head_addr;
	u_int64_t	tx_fifo_reset_cnt;
	u_int64_t	tx_fifo_wrk_cnt;
	u_int32_t	tx_head_addr;

	/* For 82544 PCI-X Workaround */
	boolean_t	pcix_82544;
	struct em_hw_stats stats;
};

#define DEVNAME(_sc) ((_sc)->sc_dev.dv_xname)

#endif /* _EM_H_DEFINED_ */
@


1.72
log
@Add support for the Intel i219 network chip to the em(4) driver.
from Christian Ehrhardt; input jsg@@; OK deraadt@@ sthen@@ mpi@@ jsg@@
tested by sthen@@ jca@@ benno@@ bluhm@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.71 2016/01/11 01:31:53 dlg Exp $ */
a265 1
#ifdef __STRICT_ALIGNMENT
a266 3
#else
#define EM_MCLBYTES		EM_RXBUFFER_2048
#endif
@


1.71
log
@do further work on the em transmit path to simplify the code.

noone could understand how em_txeof worked, so i rewrote it.

this also gets rid of the sc_tx_desc_free var that needed atomic
ops. space to use in em_start and space to free in em_txeof is now
calculated from the producer and consumer.

testers have reported better responsiveness with this. somehow.
if em issues persist after this, im rolling back to pre-mpsafe changes.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.70 2016/01/07 11:19:54 dlg Exp $ */
d233 3
d325 1
@


1.70
log
@rename em_buffers to em_packets.

shorten a bunch of variable names while here.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.69 2016/01/07 07:18:07 dlg Exp $ */
a354 1
	u_int			 sc_tx_desc_free;
@


1.69
log
@rename the rx and tx ring softc vars.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.68 2016/01/07 07:03:55 dlg Exp $ */
d272 4
a275 4
struct em_buffer {
	int		next_eop;	/* Index of the desc to watch */
	struct mbuf	*m_head;
	bus_dmamap_t	map;		/* bus_dma map for packet */
d356 1
a356 1
	struct em_buffer	*sc_tx_buffers;
d374 1
a374 1
	struct em_buffer	*sc_rx_buffers;
@


1.68
log
@prefix the rx and tx ring softc members with sc_
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.67 2016/01/07 06:25:35 dlg Exp $ */
d350 8
a357 6
	struct em_dma_alloc	 sc_txdma;	/* bus_dma glue for tx desc */
	struct em_tx_desc	*sc_tx_desc_base;
	u_int32_t		 sc_next_avail_tx_desc;
	u_int32_t		 sc_next_tx_to_clean;
	volatile u_int32_t	 sc_num_tx_desc_avail;
	u_int32_t		 sc_num_tx_desc;
a358 1
	struct em_buffer	*sc_tx_buffer_area;
d368 1
a368 2
	struct em_dma_alloc	 sc_rxdma;	/* bus_dma glue for rx desc */
	struct em_rx_desc	*sc_rx_desc_base;
d370 6
a375 2
	u_int32_t		 sc_next_rx_desc_to_check;
	u_int32_t		 sc_last_rx_desc_filled;
a376 2
	u_int16_t		 sc_num_rx_desc;
	struct em_buffer	*sc_rx_buffer_area;
@


1.67
log
@dma_paddr in struct em_dma_alloc is unused, so gc it.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.66 2016/01/07 05:34:11 dlg Exp $ */
d350 8
a357 8
	struct em_dma_alloc	txdma;		/* bus_dma glue for tx desc */
	struct em_tx_desc	*tx_desc_base;
	u_int32_t		next_avail_tx_desc;
	u_int32_t		next_tx_to_clean;
	volatile u_int32_t	num_tx_desc_avail;
	u_int32_t		num_tx_desc;
	u_int32_t		txd_cmd;
	struct em_buffer	*tx_buffer_area;
d367 8
a374 8
	struct em_dma_alloc	rxdma;		/* bus_dma glue for rx desc */
	struct em_rx_desc	*rx_desc_base;
	struct if_rxring	rx_ring;
	u_int32_t		next_rx_desc_to_check;
	u_int32_t		last_rx_desc_filled;
	u_int32_t		rx_buffer_len;
	u_int16_t		num_rx_desc;
	struct em_buffer	*rx_buffer_area;
@


1.66
log
@unify the dma tag into sc_dmat in em_softc.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.65 2016/01/07 04:37:53 dlg Exp $ */
a282 1
	bus_addr_t		dma_paddr;
@


1.65
log
@sprinkle DEVNAME
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.64 2016/01/07 04:30:45 dlg Exp $ */
a284 1
	bus_dma_tag_t		dma_tag;
d314 3
a358 1
	bus_dma_tag_t		txtag;		/* dma tag for tx */
a375 1
	bus_dma_tag_t		rxtag;
@


1.64
log
@rename the struct arpcom interface_data in em_softc to sc_ac.

makes it more consistent with the rest of the tree.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.63 2016/01/07 04:21:36 dlg Exp $ */
d414 2
@


1.63
log
@rename em_softc sc_dv to sc_dev. like ALL OUR OTHER DRIVERS.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.62 2016/01/07 03:56:03 dlg Exp $ */
d314 1
a314 1
	struct arpcom	interface_data;
@


1.62
log
@tweak em to make it mpsafe, both for interrupts and if_start.

this is mostly work by kettenis and claudio, with further work from
me to make the transmit side from the stack mpsafe.

there's a watchdog issue that will be worked on in tree after this
change.

tested by hrvoje popovski and gregor best
ok mpi@@ claudio@@ deraadt@@ jmatthew@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.61 2015/11/24 17:11:39 mpi Exp $ */
d313 1
a313 1
	struct device	sc_dv;
@


1.61
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.60 2015/11/20 14:32:33 mpi Exp $ */
d52 1
d185 2
a186 2
 * These parameters control when the driver calls the routine to reclaim
 * transmit descriptors.
a187 1
#define EM_TX_CLEANUP_THRESHOLD		(sc->num_tx_desc / 8)
d353 2
a354 2
	volatile u_int16_t	num_tx_desc_avail;
	u_int16_t		num_tx_desc;
@


1.60
log
@Missed in previous, pointed by benoit@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.59 2015/11/14 17:54:57 mpi Exp $ */
a53 1
#include <net/if_dl.h>
@


1.59
log
@Do not include <net/if_vlan_var.h> when it's not necessary.

Because of the VLAN hacks in mpw(4) this file still contains the definition
of "struct ifvlan" which depends on <sys/refcnt.h> which in turns pull
<sys/atomic.h>...
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.58 2015/09/30 11:25:08 kettenis Exp $ */
d185 2
a186 2
 * Thise parameter controls the minimum number of available transmit
 * descriptors needed before we attempt transmission of a packet.
d188 1
d354 2
a355 2
	volatile u_int32_t	num_tx_desc_avail;
	u_int32_t		num_tx_desc;
@


1.58
log
@Run the tx completion path without the kernel held.  This makes the
"fast path" through the interrupt handler not grab the kernel lock anymore.
This removes the code that attempts to reclaim tx descriptors from em_start().
Keeping that code would have complicated the locking.  The need to reclaim
tx descriptors that way should have largely disappeared now that the interrupt
handler doesn't have to wait on the kernel lock.

ok mpi@@
tested by many
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.57 2015/09/19 12:48:26 kettenis Exp $ */
a61 5

#if NVLAN > 0
#include <net/if_types.h>
#include <net/if_vlan_var.h>
#endif
@


1.57
log
@Avoid using a mutex in the rx completion path.  Instead rely on
intr_barrier(9) to avoid having the interrupt handler touch the rx data
structures while we're brining down the interface.  This actually reverts
many of the changes in rev. 1.300.

ok mikeb@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.56 2015/08/26 09:17:20 kettenis Exp $ */
d190 2
a191 2
 * These parameters control when the driver calls the routine to reclaim
 * transmit descriptors.
a192 1
#define EM_TX_CLEANUP_THRESHOLD		(sc->num_tx_desc / 8)
d358 2
a359 2
	volatile u_int16_t	num_tx_desc_avail;
	u_int16_t		num_tx_desc;
@


1.56
log
@Get rid if em_align.  This approach used to make sense, but now that the
hardware rx mtu always gets set to the maximum supported value we will hit
it for every received packet.  Instead, use a larger mbuf cluster size on
strict alignment architectures such that we can always m_adj to make sure the
packets are properly aligned.  This wastes some memory but simplifies things
considerably.  Hopefully we can reduce the spillage in the near future by
taking advantage of recent improvements in the pool code.

ok mpi@@, mikeb@@, dlg@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.55 2015/08/21 09:16:06 kettenis Exp $ */
a375 1
	struct mutex		rx_mtx;
@


1.55
log
@Run the part of the interrupt handler that does rx completion without holding
the kernel lock.

ok mpi@@, dlg@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.54 2014/12/26 05:46:32 tedu Exp $ */
d269 6
a331 6

#ifdef __STRICT_ALIGNMENT
	/* Used for carrying forward alignment adjustments */
	unsigned char	align_buf[ETHER_ALIGN];	/* tail of unaligned packet */
	u_int8_t	align_buf_len;		/* bytes in tail */
#endif /* __STRICT_ALIGNMENT */
@


1.54
log
@unifdef INET. missed a few headers in previous rounds
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.53 2014/07/22 13:12:11 mpi Exp $ */
d376 1
@


1.53
log
@Fewer <netinet/in_systm.h>
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.52 2014/07/10 14:21:20 deraadt Exp $ */
a56 1
#ifdef INET
a61 1
#endif
@


1.52
log
@remove most of the boolean_t infection outside uvm/ddb/pmap; ok jsg
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.51 2014/07/08 05:35:18 dlg Exp $ */
a58 1
#include <netinet/in_systm.h>
@


1.51
log
@cut things that relied on mclgeti for rx ring accounting/restriction over
to using if_rxr.

cut the reporting systat did over to the rxr ioctl.

tested as much as i can on alpha, amd64, and sparc64.
mpi@@ has run it on macppc.
ok mpi@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.50 2013/08/07 01:06:34 bluhm Exp $ */
d75 3
a77 1
#include <uvm/uvm_extern.h>
@


1.50
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.49 2013/04/16 22:21:32 deraadt Exp $ */
d376 1
a378 1
	int			rx_ndescs;
@


1.49
log
@spelling errors; Diego Casati
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.48 2010/09/07 16:21:44 deraadt Exp $ */
a59 1
#include <netinet/in_var.h>
@


1.48
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.47 2010/04/20 22:05:43 tedu Exp $ */
d95 1
a95 1
 *   desscriptors should meet the following condition.
d111 1
a111 1
 *   desscriptors should meet the following condition.
@


1.47
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.46 2009/11/25 13:28:13 dms Exp $ */
a327 1
	void		*sc_powerhook;
@


1.46
log
@Add support for em(4) interfaces found on intel EP80579 SoC. The MAC part is
basicly 82545, but the PHY's are separated form the chip and they are accessed
through a special PCI device called GCU which has the MDIO interface. Since
there is no direct relationship between MAC and PHY, so for the moment they
are assigned to each other the way its done on Axiomtek NA-200, that was
danted to us by them.

This also adds a device driver for the GCU.

tested by me on Axiomtek board
reviewed by claudio@@, kettenis@@, deraadt@@
'commit that as is' deraadt@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.45 2009/08/10 19:41:05 deraadt Exp $ */
d51 1
@


1.45
log
@A few more simple cases of shutdown hooks which only call xxstop, when
we now know the interface has already been stopped
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.44 2009/06/05 16:27:40 naddy Exp $ */
a419 1

@


1.44
log
@tidy up promiscuous mode and multicast handling; from Brad; ok sthen@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.43 2008/12/15 02:33:04 brad Exp $ */
a327 1
	void		*sc_shutdownhook;
@


1.43
log
@revert 1.20 now that the new allocator is used to control the number of
RX buffers allocated.

ok dlg@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.42 2008/12/05 00:08:17 brad Exp $ */
a326 1
	int		if_flags;
@


1.42
log
@Garbage collect now unused field in the softc struct again.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.41 2008/12/03 00:59:48 dlg Exp $ */
a96 1
#define EM_MIN_TXD			12
a112 1
#define EM_MIN_RXD			12
@


1.41
log
@recommit the use of the new mbuf cluster allocator.

this starts em up with 4 mbufs on the rx ring, which will then grow as
usage demands. this also allows em to take advantage of the new livelock
mitigation code as well as freeing up a boatload of kernel memory.

this version of the diff makes sure we only ever post the last descriptor
we filled to the hardware, rather than the whole ring when bringing the
interface up. it has been tested by users who got panics with the previous
diff without trouble.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.37 2008/07/22 11:20:10 martynas Exp $ */
a387 1
	bus_dmamap_t		rx_sparemap;
@


1.40
log
@revert 1.197 if_em.c, 1.38/1.39 if_em.h, requested by dlg, until a bug
reported on misc@@ can be tracked down.

identical diff from jsing.
@
text
@d382 2
@


1.39
log
@Garbage collect now unused field in the softc struct.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.38 2008/11/26 00:14:48 dlg Exp $ */
a381 2
	u_int32_t		last_rx_desc_filled;
	int			rx_ndescs;
d386 1
@


1.38
log
@rework the filling of the rx ring. this switches us to having the cluster
allocation limited by per ifp statistics, ie, we're not guaranteed to have
mbufs in every slot on the rx ring.

instead of filling the ring with 256 mbufs all the time (about 512KB of
kva) when em is brought up, we give it 4. as demand grows we increase the
number of mbufs allowed on the ring. i will bet most users wont go above
50ish mbufs, so we're saving them 400KB of kva.

tested by many, including one on sparc64
ok claudio@@ deraadt@@ henning@@ krw@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.37 2008/07/22 11:20:10 martynas Exp $ */
a387 1
	bus_dmamap_t		rx_sparemap;
@


1.37
log
@more negotation -> negotiation;  ok sthen@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.36 2007/10/21 03:49:54 brad Exp $ */
d382 2
@


1.36
log
@Allow for the adjustment of the number of RX descriptors
for the newer generations of em(4) chipsets independently
from the first two generations (82542/82543). The first
two generations have hardware errata limiting the upper
maximum to 256 descriptors. The number of RX descriptors
has not been adjusted yet.

ok beck@@ henning@@ dlg@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.35 2007/05/30 06:29:17 ckuethe Exp $ */
d200 1
a200 1
 * This parameter controls whether or not autonegotation is enabled.
@


1.35
log
@Move the knob for the interrupt throttling register next to the knobs for
the other interrupt moderation schemes.
ok beck drahn
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.34 2006/11/18 18:39:14 brad Exp $ */
d115 1
@


1.34
log
@fix comments
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.33 2006/11/17 02:03:32 brad Exp $ */
d116 9
@


1.33
log
@Add a lower TX threshold value and use this when checking the number of
available TX descriptors in the case that em_encap() has tried to reclaim
descriptors.

From Jack Vogel@@Intel

Tested by brad@@, mk@@, Gabriel Kihlman <gk at stacken dot kth dot se>,
Johan Mson Lindman <tybollt at solace dot mh dot se>
Tested on amd64/i386/sparc64
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.32 2006/11/14 03:59:00 brad Exp $ */
d183 1
a183 1
 * These parameter controls when the driver calls the routine to reclaim
@


1.32
log
@Rework the transmit register handling. In em_encap() store the index of
the EOP descriptor in the first descriptor of the packet. In em_txeof()
search for the DD bit set only in the EOP descriptors, embedding the
cleanup of all packet's descriptors into the inner loop.

This change is important for future chips, where the DD bit is going
to be set only in the EOP descriptors.

From Jack Vogel@@Intel

Tested by brad@@, mk@@, reyk@@, Gabriel Kihlman <gk at stacken dot kth dot se>,
Johan Mson Lindman <tybollt at solace dot mh dot se>, Jason Dixon and a few
others.
Tested on i386/amd64/sparc64.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.31 2006/11/10 21:15:56 brad Exp $ */
d183 1
a183 1
 * This parameter controls when the driver calls the routine to reclaim
d187 1
@


1.31
log
@Pre-allocate the TX DMA maps intead of creating and destroying a DMA map
per packet sent.

Tested by brad@@, ckuethe@@, Gabriel Kihlman <gk at stacken dot kth dot se>
and Tim Wiess <tim at nop dot cx>.
Tested with amd64/i386/sparc64.

ok damien@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.30 2006/11/06 03:52:37 brad Exp $ */
d265 1
d353 1
a353 1
	u_int32_t		oldest_used_tx_desc;
@


1.30
log
@Sync up to Intel's latest FreeBSD em driver (6.2.9). Adds support
for a few newer Intel PCIe boards, some code removal and cleaning
and a few bug fixes.

From: Jack Vogel@@Intel

Tested by mk@@ wilfried@@ brad@@ dlg@@, Marc Winiger, Gabriel Kihlman,
Jason Dixon, Johan Mson Lindman, and a few other end users.

Tested with 82543, 82544, 82540, 82545, 82541, 82547, 82546 and 82573.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.29 2006/09/17 20:26:14 brad Exp $ */
a265 4
	bus_dmamap_t	map;		/* bus_dma map for packet */
};

struct em_q {
@


1.29
log
@Overhaul RX path to recover from mbuf cluster allocation failure.
- Create a spare DMA map for RX handler to recover from
  bus_dmamap_load() failure.
- Make sure to update status bit in RX descriptors even if we failed
  to allocate a new buffer.
- Don't blindly unload DMA map. Reuse loaded DMA map if received
  packet has errors.

From yongari@@FreeBSD
Tested by myself and a number of end-users on i386/amd64/sparc64
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.28 2006/09/17 17:51:01 brad Exp $ */
d130 2
a131 1
 * EM_TADV - Transmit Absolute Interrupt Delay Value (Not valid for 82542/82543/82544)
d157 4
a160 4
 *            If this occurs a WATCHDOG message is logged in the system event log.
 *            In addition, the controller is automatically reset, restoring the
 *            network connection. To eliminate the potential for the hang
 *            ensure that EM_RDTR is set to 0.
d204 4
a207 3
 * EM_MASTER_SLAVE is only defined to enable a workaround for a known compatibility issue
 * with 82541/82547 devices and some switches.  See the "Known Limitations" section of
 * the README file for a complete description and a list of affected switches.
d218 3
a220 3
#define AUTONEG_ADV_DEFAULT		(ADVERTISE_10_HALF | ADVERTISE_10_FULL | \
					 ADVERTISE_100_HALF | ADVERTISE_100_FULL | \
					 ADVERTISE_1000_FULL)
d231 9
d262 1
a361 1
	bus_dmamap_t		rx_sparemap;
d374 1
a375 1
	u_int32_t		rx_buffer_len;
d378 1
d380 4
a383 1
	/* Jumbo frame */
@


1.28
log
@revert revision 1.131, the code in question was later found to not ensure
the proper alignment requirement for the VLAN layer on strict alignment
architectures. This would result in Jumbo's working fine as long as VLANs
were not in use. If VLANs were in use and a packet comes in with a size
of 2046 bytes or larger, it would be corrupted as it came up through the
VLAN layer. Also check the hw max frame size, instead of the MTU, so the
alignment fixup is done as appropriate.

Fixes PR 5185.
Tested by Rui DeSousa with macppc and myself with alpha/sparc64.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.27 2006/08/04 14:25:24 brad Exp $ */
d350 1
@


1.27
log
@- merge em/ixgb_disable_promisc() into em/ixgb_set_promisc().
- rearrange interface flags ioctl handler.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.26 2006/07/07 02:56:18 brad Exp $ */
d312 6
@


1.27.2.1
log
@MFC:
Fix by brad@@

revert revision 1.131, the code in question was later found to not ensure
the proper alignment requirement for the VLAN layer on strict alignment
architectures. This would result in Jumbo's working fine as long as VLANs
were not in use. If VLANs were in use and a packet comes in with a size
of 2046 bytes or larger, it would be corrupted as it came up through the
VLAN layer. Also check the hw max frame size, instead of the MTU, so the
alignment fixup is done as appropriate.

Fixes PR 5185.
Tested by Rui DeSousa with macppc and myself with alpha/sparc64

Thanks to Ivan M Makarenko for pointing out that I missed commiting this
part of the fix.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.27 2006/08/04 14:25:24 brad Exp $ */
a311 6

#ifdef __STRICT_ALIGNMENT
	/* Used for carrying forward alignment adjustments */
	unsigned char	align_buf[ETHER_ALIGN];	/* tail of unaligned packet */
	u_int8_t	align_buf_len;		/* bytes in tail */
#endif /* __STRICT_ALIGNMENT */
@


1.26
log
@Sync up to Intel's latest FreeBSD em driver (6.0.5). Adds support
for new chipset revisions embedded in the ESB2 and ICH8 core logic
chipsets.

The previous attempt at commiting this included an unrelated change
to how the I/O base address was being set and this was the cause of
the breakage.

From: Intel's web-site
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.25 2006/07/05 01:15:30 brad Exp $ */
d309 1
@


1.25
log
@revert back to the older driver as this causes some breakage.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.23 2006/03/05 19:55:10 brad Exp $ */
d86 1
a86 1
 * EM_(MIN/MAX)_TXD: Maximum number of Transmit Descriptors
d93 3
d98 2
a99 2
#define EM_MAX_TXD			256
#define EM_MAX_TXD_82544		512
d102 1
a102 1
 * EM_(MIN/MAX)_RXD - Maximum number of receive Descriptors
d110 3
a112 1
 *
d221 1
a310 6

#ifdef __STRICT_ALIGNMENT
	/* Used for carrying forward alignment adjustments */
	unsigned char	align_buf[ETHER_ALIGN];	/* tail of unaligned packet */
	u_int8_t	align_buf_len;		/* bytes in tail */
#endif /* __STRICT_ALIGNMENT */
@


1.24
log
@Sync up to Intel's latest FreeBSD em driver (6.0.5). Adds support
for new chipset revisions embedded in the ESB2 and ICH8 core logic
chipsets.

From: Intel's web-site
@
text
@d86 1
a86 1
 * EM_TXD: Maximum number of Transmit Descriptors
a92 3
 *   Since TDLEN should be multiple of 128bytes, the number of transmit
 *   desscriptors should meet the following condition.
 *      (num_tx_desc * sizeof(struct em_tx_desc)) % 128 == 0
d95 2
a96 2
#define EM_MAX_TXD_82543		256
#define EM_MAX_TXD			512
d99 1
a99 1
 * EM_RXD - Maximum number of receive Descriptors
d107 1
a107 3
 *   Since TDLEN should be multiple of 128bytes, the number of transmit
 *   desscriptors should meet the following condition.
 *      (num_tx_desc * sizeof(struct em_tx_desc)) % 128 == 0
a215 1
#define EM_FLASH			0x0014 /* Flash memory on ICH8 */
d305 6
@


1.23
log
@Sprinkle some tabs and a little cleaning.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.22 2006/02/22 06:02:09 brad Exp $ */
d86 1
a86 1
 * EM_(MIN/MAX)_TXD: Maximum number of Transmit Descriptors
d93 3
d98 2
a99 2
#define EM_MAX_TXD			256
#define EM_MAX_TXD_82544		512
d102 1
a102 1
 * EM_(MIN/MAX)_RXD - Maximum number of receive Descriptors
d110 3
a112 1
 *
d221 1
a310 6

#ifdef __STRICT_ALIGNMENT
	/* Used for carrying forward alignment adjustments */
	unsigned char	align_buf[ETHER_ALIGN];	/* tail of unaligned packet */
	u_int8_t	align_buf_len;		/* bytes in tail */
#endif /* __STRICT_ALIGNMENT */
@


1.22
log
@For 82544 and newer chips increase the number of TX descriptors to 512.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.21 2005/12/10 18:41:50 brad Exp $ */
d94 3
a96 3
#define EM_MIN_TXD                      12
#define EM_MAX_TXD                      256
#define EM_MAX_TXD_82544                512
d109 2
a110 2
#define EM_MIN_RXD                      12
#define EM_MAX_RXD                      256
d122 1
a122 1
#define EM_TIDV                         64
d135 1
a135 1
#define EM_TADV                         64
d156 1
a156 1
#define EM_RDTR                         0
d169 1
a169 1
#define EM_RADV                         64
d174 1
a174 1
#define EM_TX_TIMEOUT                   5    /* set to 5 seconds */
d180 1
a180 1
#define EM_TX_CLEANUP_THRESHOLD         (sc->num_tx_desc / 8)
d187 1
a187 1
#define DO_AUTO_NEG                     1
d195 1
a195 1
#define WAIT_FOR_AUTO_NEG_DEFAULT       0
d207 1
a207 1
/* #define EM_MASTER_SLAVE      2 */
d211 3
a213 3
#define AUTONEG_ADV_DEFAULT             (ADVERTISE_10_HALF | ADVERTISE_10_FULL | \
                                         ADVERTISE_100_HALF | ADVERTISE_100_FULL | \
                                         ADVERTISE_1000_FULL)
d215 1
a215 1
#define EM_MMBA                         0x0010 /* Mem base address */
d218 2
a219 4
#define EM_JUMBO_PBA                    0x00000028
#define EM_DEFAULT_PBA                  0x00000030
#define EM_SMARTSPEED_DOWNSHIFT         3
#define EM_SMARTSPEED_MAX               15
d221 1
a221 1
#define MAX_NUM_MULTICAST_ADDRESSES     128
d224 13
a236 13
#define DEBUG_INIT  0
#define DEBUG_IOCTL 0
#define DEBUG_HW    0

#define INIT_DEBUGOUT(S)            if (DEBUG_INIT)  printf(S "\n")
#define INIT_DEBUGOUT1(S, A)        if (DEBUG_INIT)  printf(S "\n", A)
#define INIT_DEBUGOUT2(S, A, B)     if (DEBUG_INIT)  printf(S "\n", A, B)
#define IOCTL_DEBUGOUT(S)           if (DEBUG_IOCTL) printf(S "\n")
#define IOCTL_DEBUGOUT1(S, A)       if (DEBUG_IOCTL) printf(S "\n", A)
#define IOCTL_DEBUGOUT2(S, A, B)    if (DEBUG_IOCTL) printf(S "\n", A, B)
#define HW_DEBUGOUT(S)              if (DEBUG_HW) printf(S "\n")
#define HW_DEBUGOUT1(S, A)          if (DEBUG_HW) printf(S "\n", A)
#define HW_DEBUGOUT2(S, A, B)       if (DEBUG_HW) printf(S "\n", A, B)
d239 4
a242 4
#define EM_RXBUFFER_2048        2048
#define EM_RXBUFFER_4096        4096
#define EM_RXBUFFER_8192        8192
#define EM_RXBUFFER_16384      16384
d244 1
a244 1
#define EM_MAX_SCATTER            64
d247 1
a247 1
        struct mbuf    *m_head;
d252 1
a252 1
	bus_dmamap_t       map;         /* bus_dma map for packet */
d260 7
a266 7
	bus_addr_t              dma_paddr;
	caddr_t                 dma_vaddr;
	bus_dma_tag_t           dma_tag;
	bus_dmamap_t            dma_map;
	bus_dma_segment_t       dma_seg;
	bus_size_t              dma_size;
	int                     dma_nseg;
d278 2
a279 2
    u_int64_t   address;
    u_int32_t   length;
d284 2
a285 2
    ADDRESS_LENGTH_PAIR descriptor[4];
    u_int32_t   elements;
d292 1
a292 1
	struct em_hw    hw;
d295 3
a297 3
	struct em_osdep osdep;
	struct ifmedia  media;
	int             io_rid;
d299 1
a299 1
	void           *sc_intrhand;
d313 7
a319 7
	u_int32_t       part_num;
	u_int8_t        link_active;
	u_int16_t       link_speed;
	u_int16_t       link_duplex;
	u_int32_t       smartspeed;
	u_int32_t       tx_int_delay;
	u_int32_t       tx_abs_int_delay;
d323 1
a323 1
	XSUM_CONTEXT_T  active_checksum_context;
d325 9
a333 9
        /*
         * Transmit definitions
         *
         * We have an array of num_tx_desc descriptors (handled
         * by the controller) paired with an array of tx_buffers
         * (at tx_buffer_area).
         * The index of the next available descriptor is next_avail_tx_desc.
         * The number of remaining tx_desc is num_tx_desc_avail.
         */
d344 8
a351 8
        /*
         * Receive definitions
         *
         * we have an array of num_rx_desc rx_desc (handled by the
         * controller), and paired with an array of rx_buffers
         * (at rx_buffer_area).
         * The next pair to check on receive is at offset next_rx_desc_to_check
         */
d361 2
a362 2
	struct mbuf        *fmp;
	struct mbuf        *lmp;
d365 9
a373 9
	unsigned long   dropped_pkts;
	unsigned long   mbuf_alloc_failed;
	unsigned long   mbuf_cluster_failed;
	unsigned long   no_tx_desc_avail1;
	unsigned long   no_tx_desc_avail2;
	unsigned long   no_tx_map_avail;
	unsigned long   no_tx_dma_setup;
	unsigned long   watchdog_events;
	unsigned long	rx_overruns;
d379 1
a379 1
	#define EM_FIFO_HDR              0x10
d381 1
a381 1
	#define EM_82547_PKT_THRESH      0x3e0
d383 6
a388 6
	u_int32_t       tx_fifo_size;
	u_int32_t       tx_fifo_head;
	u_int32_t       tx_fifo_head_addr;
	u_int64_t       tx_fifo_reset_cnt;
	u_int64_t       tx_fifo_wrk_cnt;
	u_int32_t       tx_head_addr;
d390 2
a391 2
        /* For 82544 PCI-X Workaround */
        boolean_t       pcix_82544;
d396 1
a396 1
#endif                                                  /* _EM_H_DEFINED_ */
@


1.21
log
@add a shutdown function and register it with shutdownhook_establish().
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.20 2005/12/10 04:01:36 brad Exp $ */
d86 1
a86 1
 * EM_MAX_TXD: Maximum number of Transmit Descriptors
d96 1
d99 1
a99 1
 * EM_MAX_RXD - Maximum number of receive Descriptors
d180 1
a180 1
#define EM_TX_CLEANUP_THRESHOLD         EM_MAX_TXD / 8
@


1.20
log
@remove a bit of unused code.

Pointed out by Andrey Matveev <evol at online dot ptt dot ru> through noticing
a missing splx which pointed out the fact that code is unused to me.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.19 2005/11/18 18:13:29 brad Exp $ */
d305 1
@


1.19
log
@PCIX -> PCI-X in a few comments
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.18 2005/11/13 03:48:08 brad Exp $ */
a391 1
        boolean_t       in_detach;
@


1.18
log
@- Introduce two more stat counters, counting number of RX
  overruns and number of watchdog timeouts.
- Do not increase if->if_oerrors in em_watchdog(), since
  this leads to counter slipping back, when if->if_oerrors
  is recalculated in em_update_stats_counters(). Instead
  increase watchdog counter in em_watchdog() and take it
  into account in em_update_stats_counters().

From glebius FreeBSD

ok dlg@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.17 2005/10/24 21:42:34 brad Exp $ */
d276 1
a276 1
/* For 82544 PCIX  Workaround */
d390 1
a390 1
        /* For 82544 PCIX Workaround */
@


1.17
log
@Revamp interrupt handling in em(4) driver:

o Do not mask the RX overrun interrupt.

o Rewrite em_intr():
  - Axe EM_MAX_INTR.
  - Cycle acknowledging interrupts and processing
    packets until zero interrupt cause register is
    read.
  - If RX overrun comes in log this fact.

From glebius FreeBSD

ok krw@@ beck@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.16 2005/10/21 02:10:34 brad Exp $ */
d371 3
a373 1
        unsigned long   no_tx_dma_setup;
@


1.16
log
@Remove unused global adapter linked list.

From FreeBSD
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.15 2005/10/15 14:43:37 brad Exp $ */
a168 7

/*
 * This parameter controls the maximum no of times the driver will loop
 * in the isr.
 *           Minimum Value = 1
 */
#define EM_MAX_INTR                     3
@


1.15
log
@- put spl's right in the code and remove the macros
- remove splassert()'s
- remove empty bus_dma_tag_destroy macro from code and header
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.14 2005/07/16 19:05:36 brad Exp $ */
a299 2
	struct em_softc *next;
	struct em_softc *prev;
@


1.14
log
@move headers and remove some FreeBSD specific stuff.
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.13 2005/07/16 17:08:02 brad Exp $ */
a402 9

static inline int spl_use_arg(void *);
static inline int spl_use_arg(void *v) { return splnet(); }
#define EM_LOCK_INIT(_sc, _name)
#define EM_LOCK_DESTROY(_sc)
#define EM_LOCK_STATE()		int em_hidden_splnet_s
#define EM_LOCK(_sc)		em_hidden_splnet_s = spl_use_arg(_sc)
#define EM_UNLOCK(_sc)		splx(em_hidden_splnet_s)
#define EM_LOCK_ASSERT(_sc)	splassert(IPL_NET)
@


1.13
log
@fix support for interrupt mitigation.

ok nate@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.12 2005/07/02 06:15:44 deraadt Exp $ */
d40 41
a169 1

a177 5
 * Inform the stack about transmit checksum offload capabilities.
 */
#define EM_CHECKSUM_FEATURES            (CSUM_TCP | CSUM_UDP)

/*
a220 1
#define EM_VENDOR_ID                    0x8086
a229 1
#define PCI_ANY_ID                      (~0U)
@


1.12
log
@sync
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.11 2005/05/04 02:33:31 brad Exp $ */
a249 7
struct em_softc;
struct em_int_delay_info {
        struct em_softc *sc;    /* Back-pointer to the sc struct */
        int offset;                     /* Register offset to read/write */
        int value;                      /* Current value in usecs */
};

d294 4
a297 4
	struct em_int_delay_info tx_int_delay;
	struct em_int_delay_info tx_abs_int_delay;
	struct em_int_delay_info rx_int_delay;
	struct em_int_delay_info rx_abs_int_delay;
@


1.11
log
@remove #ifdef __OpenBSD__
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.10 2005/03/27 16:38:13 brad Exp $ */
a194 1

a212 1

a374 5
#ifdef DBG_STATS
	unsigned long   no_pkts_avail;
	unsigned long   clean_tx_interrupts;

#endif
@


1.10
log
@remove FreeBSD ifdef bloat.

ok krw@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.9 2004/12/08 15:41:46 markus Exp $ */
a273 1
#ifdef __OpenBSD__
a274 1
#endif
@


1.9
log
@powerhook: em_init on resume
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.8 2004/11/16 14:39:14 brad Exp $ */
a222 18
/* ******************************************************************************
 * vendor_info_array
 *
 * This array contains the list of Subvendor/Subdevice IDs on which the driver
 * should load.
 *
 * ******************************************************************************/
#ifdef __FreeBSD__
typedef struct _em_vendor_info_t {
        unsigned int vendor_id;
        unsigned int device_id;
        unsigned int subvendor_id;
        unsigned int subdevice_id;
        unsigned int index;
} em_vendor_info_t;
#endif /* __FreeBSD__ */


a229 4
#ifdef __FreeBSD__
	int                nsegs;       /* # of segments/descriptors */
	bus_dma_segment_t  segs[EM_MAX_SCATTER];
#endif /* __FreeBSD__ */
d282 1
a282 1
	/* FreeBSD operating-system-specific structures */
a283 7
#ifdef __FreeBSD__
        struct device   *dev;
        struct resource *res_memory;
        struct resource *res_ioport;
        struct resource *res_interrupt;
        void            *int_handler_tag;
#endif /* __FreeBSD__ */
a284 4
#ifdef __FreeBSD__
        struct callout  timer;
        struct callout  tx_fifo_timer;
#endif /* __FreeBSD__ */
a285 4
#ifdef __FreeBSD__
        u_int8_t        unit;
        struct mtx      mtx;
#endif /* __FreeBSD__ */
a286 1
#ifdef __OpenBSD__
a291 1
#endif /* __OpenBSD__ */
a350 5
#ifdef __FreeBSD__
        struct sysctl_ctx_list sysctl_ctx;
        struct sysctl_oid *sysctl_tree;
#endif /* __FreeBSD__ */

a386 10
#ifdef __FreeBSD__
#define EM_LOCK_INIT(_sc, _name) \
        mtx_init(&(_sc)->mtx, _name, MTX_NETWORK_LOCK, MTX_DEF)
#define EM_LOCK_DESTROY(_sc)    mtx_destroy(&(_sc)->mtx)
#define EM_LOCK(_sc)            mtx_lock(&(_sc)->mtx)
#define EM_UNLOCK(_sc)          mtx_unlock(&(_sc)->mtx)
#define EM_LOCK_ASSERT(_sc)     mtx_assert(&(_sc)->mtx, MA_OWNED)
#endif /* __FreeBSD__ */

#ifdef __OpenBSD__
a394 1
#endif /* __OpenBSD__ */
@


1.8
log
@- Added fix for 82547 which corrects an issue with Jumbo frames larger than 10k.
- Corrected TBI workaround.
- Corrected incorrect LED operation issues.

From FreeBSD

ok deraadt@@
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.7 2004/06/18 20:42:35 mcbride Exp $ */
d329 1
a329 1

@


1.7
log
@On architectures which have strict alignment, shift the entire mbuf chain by
ETHER_ALIGN bytes when jumbo packets are enabled (mtu > ETHERMTU).

ok henric@@ (slightly different diff)
@
text
@d34 2
a35 2
/*$FreeBSD: if_em.h,v 1.24 2003/11/14 18:02:24 pdeuskar Exp $*/
/* $OpenBSD: if_em.h,v 1.6 2004/05/19 11:37:00 brad Exp $ */
a389 2
	u_int16_t          tx_fifo_head;

d403 15
a417 2
	u_int64_t       tx_fifo_reset;
	u_int64_t       tx_fifo_wrk;
@


1.6
log
@remove duplication, use ETHER_ALIGN from if_ether.h
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.5 2004/04/26 17:17:15 deraadt Exp $ */
d329 1
d331 6
@


1.5
log
@oh we need to model check and not crank > 256 for older cards... do that later
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.4 2004/04/26 07:27:52 deraadt Exp $ */
a197 1
#define ETHER_ALIGN                     2
@


1.4
log
@this driver had 256 clusters for receive buffers.  move to 512, to increase
performance, if the interface is up.  at boot time, allocate only 12 though
... though we note that em_stop() frees them all.  perhaps some are used to
talk to other parts of the engine though at runtime... tested by mcbride and
beck
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.3 2004/04/18 04:15:00 henric Exp $ */
d54 1
a54 1
#define EM_MAX_TXD                      512
d68 1
a68 1
#define EM_MAX_RXD                      512
@


1.3
log
@Sync with FreeBSD's "em".
@
text
@d35 1
a35 1
/* $OpenBSD: if_em.h,v 1.2 2003/06/13 19:21:21 henric Exp $ */
d53 2
a54 1
#define EM_MAX_TXD                      256
d67 2
a68 1
#define EM_MAX_RXD                      256
@


1.2
log
@Sync with FreeBSD's "em".

ok deraadt@@
@
text
@d34 2
a35 2
/*$FreeBSD: if_em.h,v 1.16 2003/06/05 17:51:38 pdeuskar Exp $*/
/* $OpenBSD: $ */
d45 1
a45 1
 * TxDescriptors
d56 1
a56 1
 * RxDescriptors
d69 1
a69 1
 * TxIntDelay
d81 1
a81 1
 * TxAbsIntDelay (Not valid for 82542 and 82543)
d85 1
a85 1
 *   transmit interrupt is generated. Useful only if TxIntDelay is non-zero,
d88 1
a88 1
 *   along with TxIntDelay, may improve traffic throughput in specific
d94 1
a94 1
 * RxIntDelay
d105 1
a105 1
 *   CAUTION: When setting RxIntDelay to a value other than 0, adapters
d110 1
a110 1
 *            ensure that RxIntDelay is set to 0.
d115 1
a115 1
 * RxAbsIntDelay (Not valid for 82542 and 82543)
d119 1
a119 1
 *   receive interrupt is generated. Useful only if RxIntDelay is non-zero,
d122 1
a122 1
 *   along with RxIntDelay, may improve traffic throughput in specific network
d166 11
d180 3
a182 3
#define AUTONEG_ADV_DEFAULT      (ADVERTISE_10_HALF | ADVERTISE_10_FULL | \
                                  ADVERTISE_100_HALF | ADVERTISE_100_FULL | \
                                  ADVERTISE_1000_FULL)
a221 7
#ifdef __FreeBSD__
#ifdef __alpha__
       #undef vtophys
       #define vtophys(va)     alpha_XXX_dmamap((vm_offset_t)(va))
#endif /* __alpha__ */
#endif /* __FreeBSD__ */

d273 20
d295 1
d297 1
d305 17
d323 1
a323 1
	int             io_rid;
a324 2
	struct ifmedia  media;

d328 1
d336 4
a339 4
	u_int32_t       tx_int_delay;
	u_int32_t	tx_abs_int_delay;
	u_int32_t       rx_int_delay;
	u_int32_t	rx_abs_int_delay;
d384 5
d400 4
d411 20
@


1.1
log
@Driver for Intel PRO/1000 gigabit ethernet adapters.
This driver should work with all current models of gigabit ethernet adapters.

Driver written by Intel
Ported from FreeBSD by Henric Jungheim <henric@@attbi.com>
bus_dma and endian support by me.
@
text
@d3 1
a3 1
Copyright (c) 2001-2002 Intel Corporation
d6 9
a14 11
Redistribution and use in source and binary forms of the Software, with or
without modification, are permitted provided that the following conditions
are met:

 1. Redistributions of source code of the Software may retain the above
    copyright notice, this list of conditions and the following disclaimer.

 2. Redistributions in binary form of the Software may reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.
d17 2
a18 2
    contributors shall be used to endorse or promote products derived from
    this Software without specific prior written permission.
d23 8
a30 8
ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR ITS CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
d34 2
a35 1
/*$FreeBSD$*/
d43 95
a137 13
#define MAX_TXD                         256
#define MAX_RXD                         256
#define TX_CLEANUP_THRESHOLD            MAX_TXD / 8
#define TIDV                            128     
#define RIDV                            28      
#define DO_AUTO_NEG                     1       
#define WAIT_FOR_AUTO_NEG_DEFAULT       1       
#define AUTONEG_ADV_DEFAULT             (ADVERTISE_10_HALF |	\
					 ADVERTISE_10_FULL |	\
                                         ADVERTISE_100_HALF |	\
					 ADVERTISE_100_FULL |	\
                                         ADVERTISE_1000_FULL)
#define EM_REPORT_TX_EARLY              2
d139 4
a142 1
#define EM_MAX_INTR                     3
d145 27
d176 1
d179 3
a182 1
#define IOCTL_CMD_TYPE                  u_long
a185 1
#define QTAG_TYPE                       0x8100
d209 1
a209 6
struct em_tx_buffer {
	SIMPLEQ_ENTRY(em_tx_buffer) em_tx_entry;
	struct mbuf    *m_head;
	bus_dmamap_t	dmamap;
	u_int32_t       num_tx_desc_used;
};
d211 6
d219 5
a223 2
 * This structure stores information about the 2k aligned receive buffer
 * into which the E1000 DMA's frames. 
d225 36
a260 5
struct em_rx_buffer {
	SIMPLEQ_ENTRY(em_rx_buffer) em_rx_entry;
	struct mbuf    *m_head;
	bus_dmamap_t	dmamap;
	u_int64_t	buffer_addr;
d272 3
a274 1
	struct arpcom	arpcom;         /* interface info */
d281 1
a281 1
	void                    *sc_intrhand;
d283 4
a286 1
	struct timeout	em_timeout;
d293 1
d295 1
d297 1
d301 34
a334 22
	/* Transmit definitions */
	struct em_tx_desc *first_tx_desc;
	struct em_tx_desc *last_tx_desc;
	struct em_tx_desc *next_avail_tx_desc;
	struct em_tx_desc *oldest_used_tx_desc;
	struct em_tx_desc *tx_desc_base;
	volatile u_int16_t num_tx_desc_avail;
	u_int16_t       num_tx_desc;
	u_int32_t       txd_cmd;
	struct em_tx_buffer   *tx_buffer_area;
	SIMPLEQ_HEAD(__em_tx_buffer_free, em_tx_buffer)  free_tx_buffer_list;
	SIMPLEQ_HEAD(__em_tx_buffer_used, em_tx_buffer)  used_tx_buffer_list;

	/* Receive definitions */
	struct em_rx_desc *first_rx_desc;
	struct em_rx_desc *last_rx_desc;
	struct em_rx_desc *next_rx_desc_to_check;
	struct em_rx_desc *rx_desc_base;
	u_int16_t       num_rx_desc;
	u_int32_t       rx_buffer_len;
	struct em_rx_buffer   *rx_buffer_area;
	SIMPLEQ_HEAD(__em_rx_buffer, em_rx_buffer)  rx_buffer_list;
d337 4
a340 2
	struct mbuf     *fmp;
	struct mbuf     *lmp;
d346 7
a352 4
	unsigned long   xmit_pullup;
	unsigned long   no_tx_desc_avail;
	unsigned long   no_tx_buffer_avail1;
	unsigned long   no_tx_buffer_avail2;
a357 1

@


1.1.8.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d3 1
a3 1
Copyright (c) 2001-2003, Intel Corporation
d6 11
a16 9
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
d19 2
a20 2
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.
d25 8
a32 8
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
d36 1
a36 2
/*$FreeBSD: if_em.h,v 1.16 2003/06/05 17:51:38 pdeuskar Exp $*/
/* $OpenBSD$ */
d44 14
a57 90

/*
 * TxDescriptors
 * Valid Range: 80-256 for 82542 and 82543-based adapters
 *              80-4096 for others
 * Default Value: 256
 *   This value is the number of transmit descriptors allocated by the driver.
 *   Increasing this value allows the driver to queue more transmits. Each
 *   descriptor is 16 bytes.
 */
#define EM_MAX_TXD                      256

/*
 * RxDescriptors
 * Valid Range: 80-256 for 82542 and 82543-based adapters
 *              80-4096 for others
 * Default Value: 256
 *   This value is the number of receive descriptors allocated by the driver.
 *   Increasing this value allows the driver to buffer more incoming packets.
 *   Each descriptor is 16 bytes.  A receive buffer is also allocated for each
 *   descriptor. The maximum MTU size is 16110.
 *
 */
#define EM_MAX_RXD                      256

/*
 * TxIntDelay
 * Valid Range: 0-65535 (0=off)
 * Default Value: 64
 *   This value delays the generation of transmit interrupts in units of
 *   1.024 microseconds. Transmit interrupt reduction can improve CPU
 *   efficiency if properly tuned for specific network traffic. If the
 *   system is reporting dropped transmits, this value may be set too high
 *   causing the driver to run out of available transmit descriptors.
 */
#define EM_TIDV                         64

/*
 * TxAbsIntDelay (Not valid for 82542 and 82543)
 * Valid Range: 0-65535 (0=off)
 * Default Value: 64
 *   This value, in units of 1.024 microseconds, limits the delay in which a
 *   transmit interrupt is generated. Useful only if TxIntDelay is non-zero,
 *   this value ensures that an interrupt is generated after the initial
 *   packet is sent on the wire within the set amount of time.  Proper tuning,
 *   along with TxIntDelay, may improve traffic throughput in specific
 *   network conditions.
 */
#define EM_TADV                         64

/*
 * RxIntDelay
 * Valid Range: 0-65535 (0=off)
 * Default Value: 0
 *   This value delays the generation of receive interrupts in units of 1.024
 *   microseconds.  Receive interrupt reduction can improve CPU efficiency if
 *   properly tuned for specific network traffic. Increasing this value adds
 *   extra latency to frame reception and can end up decreasing the throughput
 *   of TCP traffic. If the system is reporting dropped receives, this value
 *   may be set too high, causing the driver to run out of available receive
 *   descriptors.
 *
 *   CAUTION: When setting RxIntDelay to a value other than 0, adapters
 *            may hang (stop transmitting) under certain network conditions.
 *            If this occurs a WATCHDOG message is logged in the system event log.
 *            In addition, the controller is automatically reset, restoring the
 *            network connection. To eliminate the potential for the hang
 *            ensure that RxIntDelay is set to 0.
 */
#define EM_RDTR                         0

/*
 * RxAbsIntDelay (Not valid for 82542 and 82543)
 * Valid Range: 0-65535 (0=off)
 * Default Value: 64
 *   This value, in units of 1.024 microseconds, limits the delay in which a
 *   receive interrupt is generated. Useful only if RxIntDelay is non-zero,
 *   this value ensures that an interrupt is generated after the initial
 *   packet is received within the set amount of time.  Proper tuning,
 *   along with RxIntDelay, may improve traffic throughput in specific network
 *   conditions.
 */
#define EM_RADV                         64


/*
 * This parameter controls the maximum no of times the driver will loop
 * in the isr.
 *           Minimum Value = 1
 */
a58 9

/*
 * Inform the stack about transmit checksum offload capabilities.
 */
#define EM_CHECKSUM_FEATURES            (CSUM_TCP | CSUM_UDP)

/*
 * This parameter controls the duration of transmit watchdog timer.
 */
a60 27
/*
 * This parameter controls when the driver calls the routine to reclaim
 * transmit descriptors.
 */
#define EM_TX_CLEANUP_THRESHOLD         EM_MAX_TXD / 8

/*
 * This parameter controls whether or not autonegotation is enabled.
 *              0 - Disable autonegotiation
 *              1 - Enable  autonegotiation
 */
#define DO_AUTO_NEG                     1

/*
 * This parameter control whether or not the driver will wait for
 * autonegotiation to complete.
 *              1 - Wait for autonegotiation to complete
 *              0 - Don't wait for autonegotiation to complete
 */
#define WAIT_FOR_AUTO_NEG_DEFAULT       0


/* Tunables -- End */

#define AUTONEG_ADV_DEFAULT      (ADVERTISE_10_HALF | ADVERTISE_10_FULL | \
                                  ADVERTISE_100_HALF | ADVERTISE_100_FULL | \
                                  ADVERTISE_1000_FULL)
a64 1

a66 3
#define EM_SMARTSPEED_DOWNSHIFT         3
#define EM_SMARTSPEED_MAX               15

d68 1
d72 1
d96 6
a101 1
#define EM_MAX_SCATTER            64
a102 6
#ifdef __FreeBSD__
#ifdef __alpha__
       #undef vtophys
       #define vtophys(va)     alpha_XXX_dmamap((vm_offset_t)(va))
#endif /* __alpha__ */
#endif /* __FreeBSD__ */
d105 2
a106 5
 * vendor_info_array
 *
 * This array contains the list of Subvendor/Subdevice IDs on which the driver
 * should load.
 *
d108 5
a112 36
#ifdef __FreeBSD__
typedef struct _em_vendor_info_t {
        unsigned int vendor_id;
        unsigned int device_id;
        unsigned int subvendor_id;
        unsigned int subdevice_id;
        unsigned int index;
} em_vendor_info_t;
#endif /* __FreeBSD__ */


struct em_buffer {
        struct mbuf    *m_head;
	bus_dmamap_t	map;		/* bus_dma map for packet */
};

struct em_q {
	bus_dmamap_t       map;         /* bus_dma map for packet */
#ifdef __FreeBSD__
	int                nsegs;       /* # of segments/descriptors */
	bus_dma_segment_t  segs[EM_MAX_SCATTER];
#endif /* __FreeBSD__ */
};

/*
 * Bus dma allocation structure used by
 * em_dma_malloc and em_dma_free.
 */
struct em_dma_alloc {
	bus_addr_t              dma_paddr;
	caddr_t                 dma_vaddr;
	bus_dma_tag_t           dma_tag;
	bus_dmamap_t            dma_map;
	bus_dma_segment_t       dma_seg;
	bus_size_t              dma_size;
	int                     dma_nseg;
d124 1
a124 3
	struct arpcom	interface_data;
	struct em_softc *next;
	struct em_softc *prev;
d131 1
a131 1
	void           *sc_intrhand;
d133 1
a133 4

	struct timeout	em_intr_enable;
	struct timeout	timer_handle;
	struct timeout	tx_fifo_timer_handle;
a139 1
	u_int32_t       smartspeed;
a140 1
	u_int32_t	tx_abs_int_delay;
a141 1
	u_int32_t	rx_abs_int_delay;
d145 22
a166 34
        /*
         * Transmit definitions
         *
         * We have an array of num_tx_desc descriptors (handled
         * by the controller) paired with an array of tx_buffers
         * (at tx_buffer_area).
         * The index of the next available descriptor is next_avail_tx_desc.
         * The number of remaining tx_desc is num_tx_desc_avail.
         */
	struct em_dma_alloc	txdma;		/* bus_dma glue for tx desc */
	struct em_tx_desc	*tx_desc_base;
	u_int32_t		next_avail_tx_desc;
	u_int32_t		oldest_used_tx_desc;
	volatile u_int16_t	num_tx_desc_avail;
	u_int16_t		num_tx_desc;
	u_int32_t		txd_cmd;
	struct em_buffer	*tx_buffer_area;
	bus_dma_tag_t		txtag;		/* dma tag for tx */

        /*
         * Receive definitions
         *
         * we have an array of num_rx_desc rx_desc (handled by the
         * controller), and paired with an array of rx_buffers
         * (at rx_buffer_area).
         * The next pair to check on receive is at offset next_rx_desc_to_check
         */
	struct em_dma_alloc	rxdma;		/* bus_dma glue for rx desc */
	struct em_rx_desc	*rx_desc_base;
	u_int32_t		next_rx_desc_to_check;
	u_int16_t		num_rx_desc;
	u_int32_t		rx_buffer_len;
	struct em_buffer	*rx_buffer_area;
	bus_dma_tag_t		rxtag;
d169 2
a170 4
	struct mbuf        *fmp;
	struct mbuf        *lmp;

	u_int16_t          tx_fifo_head;
d176 4
a179 7
	unsigned long   no_tx_desc_avail1;
	unsigned long   no_tx_desc_avail2;
	unsigned long   no_tx_map_avail;
        unsigned long   no_tx_dma_setup;
	u_int64_t       tx_fifo_reset;
	u_int64_t       tx_fifo_wrk;

d185 1
@


1.1.8.2
log
@Merge with the trunk
@
text
@d34 1
a34 1
/*$FreeBSD: if_em.h,v 1.24 2003/11/14 18:02:24 pdeuskar Exp $*/
d45 1
a45 1
 * EM_MAX_TXD: Maximum number of Transmit Descriptors
a52 1
#define EM_MIN_TXD                      12
d56 1
a56 1
 * EM_MAX_RXD - Maximum number of receive Descriptors
a65 1
#define EM_MIN_RXD                      12
d69 1
a69 1
 * EM_TIDV - Transmit Interrupt Delay Value
d81 1
a81 1
 * EM_TADV - Transmit Absolute Interrupt Delay Value (Not valid for 82542/82543/82544)
d85 1
a85 1
 *   transmit interrupt is generated. Useful only if EM_TIDV is non-zero,
d88 1
a88 1
 *   along with EM_TIDV, may improve traffic throughput in specific
d94 1
a94 1
 * EM_RDTR - Receive Interrupt Delay Timer (Packet Timer)
d105 1
a105 1
 *   CAUTION: When setting EM_RDTR to a value other than 0, adapters
d110 1
a110 1
 *            ensure that EM_RDTR is set to 0.
d115 1
a115 1
 * Receive Interrupt Absolute Delay Timer (Not valid for 82542/82543/82544)
d119 1
a119 1
 *   receive interrupt is generated. Useful only if EM_RDTR is non-zero,
d122 1
a122 1
 *   along with EM_RDTR, may improve traffic throughput in specific network
a165 11
/*
 * EM_MASTER_SLAVE is only defined to enable a workaround for a known compatibility issue
 * with 82541/82547 devices and some switches.  See the "Known Limitations" section of
 * the README file for a complete description and a list of affected switches.
 *
 *              0 = Hardware default
 *              1 = Master mode
 *              2 = Slave mode
 *              3 = Auto master/slave
 */
/* #define EM_MASTER_SLAVE      2 */
d169 3
a171 3
#define AUTONEG_ADV_DEFAULT             (ADVERTISE_10_HALF | ADVERTISE_10_FULL | \
                                         ADVERTISE_100_HALF | ADVERTISE_100_FULL | \
                                         ADVERTISE_1000_FULL)
d185 1
d211 7
a268 20
struct em_softc;
struct em_int_delay_info {
        struct em_softc *sc;    /* Back-pointer to the sc struct */
        int offset;                     /* Register offset to read/write */
        int value;                      /* Current value in usecs */
};

/* For 82544 PCIX  Workaround */
typedef struct _ADDRESS_LENGTH_PAIR
{
    u_int64_t   address;
    u_int32_t   length;
} ADDRESS_LENGTH_PAIR, *PADDRESS_LENGTH_PAIR;

typedef struct _DESCRIPTOR_PAIR
{
    ADDRESS_LENGTH_PAIR descriptor[4];
    u_int32_t   elements;
} DESC_ARRAY, *PDESC_ARRAY;

a270 1
#ifdef __OpenBSD__
a271 1
#endif
d279 3
a281 7
#ifdef __FreeBSD__
        struct device   *dev;
        struct resource *res_memory;
        struct resource *res_ioport;
        struct resource *res_interrupt;
        void            *int_handler_tag;
#endif /* __FreeBSD__ */
a282 9
#ifdef __FreeBSD__
        struct callout  timer;
        struct callout  tx_fifo_timer;
#endif /* __FreeBSD__ */
	int             io_rid;
#ifdef __FreeBSD__
        u_int8_t        unit;
        struct mtx      mtx;
#endif /* __FreeBSD__ */
a283 2
#ifdef __OpenBSD__
	void           *sc_intrhand;
a286 1
#endif /* __OpenBSD__ */
d294 4
a297 4
	struct em_int_delay_info tx_int_delay;
	struct em_int_delay_info tx_abs_int_delay;
	struct em_int_delay_info rx_int_delay;
	struct em_int_delay_info rx_abs_int_delay;
a341 5
#ifdef __FreeBSD__
        struct sysctl_ctx_list sysctl_ctx;
        struct sysctl_oid *sysctl_tree;
#endif /* __FreeBSD__ */

a352 4
        /* For 82544 PCIX Workaround */
        boolean_t       pcix_82544;
        boolean_t       in_detach;

a359 20

#ifdef __FreeBSD__
#define EM_LOCK_INIT(_sc, _name) \
        mtx_init(&(_sc)->mtx, _name, MTX_NETWORK_LOCK, MTX_DEF)
#define EM_LOCK_DESTROY(_sc)    mtx_destroy(&(_sc)->mtx)
#define EM_LOCK(_sc)            mtx_lock(&(_sc)->mtx)
#define EM_UNLOCK(_sc)          mtx_unlock(&(_sc)->mtx)
#define EM_LOCK_ASSERT(_sc)     mtx_assert(&(_sc)->mtx, MA_OWNED)
#endif /* __FreeBSD__ */

#ifdef __OpenBSD__
static inline int spl_use_arg(void *);
static inline int spl_use_arg(void *v) { return splnet(); }
#define EM_LOCK_INIT(_sc, _name)
#define EM_LOCK_DESTROY(_sc)
#define EM_LOCK_STATE()		int em_hidden_splnet_s
#define EM_LOCK(_sc)		em_hidden_splnet_s = spl_use_arg(_sc)
#define EM_UNLOCK(_sc)		splx(em_hidden_splnet_s)
#define EM_LOCK_ASSERT(_sc)	splassert(IPL_NET)
#endif /* __OpenBSD__ */
@


1.1.4.1
log
@sync to -current
@
text
@@

