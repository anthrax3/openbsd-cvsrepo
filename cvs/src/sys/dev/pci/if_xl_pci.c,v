head	1.46;
access;
symbols
	OPENBSD_6_2:1.46.0.10
	OPENBSD_6_2_BASE:1.46
	OPENBSD_6_1:1.46.0.8
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.46.0.6
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.43.0.4
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.41.0.4
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.40.0.4
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.40.0.2
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.38.0.4
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.2
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.22.0.12
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.10
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.8
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.6
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.4
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.21.0.4
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.20.0.4
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.12
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	SMP:1.7.0.6
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.46
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.45;
commitid	5gdEnqVoJuTuwdTu;

1.45
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.44;
commitid	5DvsamK0GblTp8ww;

1.44
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.43;
commitid	p4LJxGKbi0BU2cG6;

1.43
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.42;
commitid	yM2VFFhpDTeFQlve;

1.42
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.41;
commitid	TGHgrLxu6sxZoiFt;

1.41
date	2013.08.07.01.06.39;	author bluhm;	state Exp;
branches;
next	1.40;

1.40
date	2012.10.18.21.44.21;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2012.10.13.17.24.03;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2011.10.13.13.09.29;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2011.07.08.18.56.47;	author stsp;	state Exp;
branches;
next	1.36;

1.36
date	2011.04.17.20.52.43;	author stsp;	state Exp;
branches;
next	1.35;

1.35
date	2011.04.03.15.36.03;	author jasper;	state Exp;
branches;
next	1.34;

1.34
date	2010.09.19.09.22.58;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2010.09.04.19.38.16;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2010.08.27.15.43.42;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2010.08.12.14.21.55;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2010.08.06.02.45.54;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2010.01.11.23.21.24;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2010.01.10.04.04.13;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.15.17.54.56;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.02.05.29.47;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2009.06.02.05.07.00;	author jsg;	state Exp;
branches;
next	1.23;

1.23
date	2009.06.02.01.23.02;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2006.08.10.20.10.19;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.09.04.10.12;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.16.06.08.05;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.30.23.49.39;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.09.21.32.24;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.23.16.46.21;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.29.16.39.02;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.13.00.37.12;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.12.20.48.15;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.15.05.14.41;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.12.20.03.49;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.14.15.44.21;	author aaron;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	2000.10.13.14.55.23;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.29.05.28.29;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.16.21.42.17;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.01.03.19.15;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.18.03.52.36;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.08.05.50.51;	author aaron;	state Exp;
branches;
next	;

1.7.6.1
date	2001.05.14.22.25.49;	author niklas;	state Exp;
branches;
next	1.7.6.2;

1.7.6.2
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.7.6.3;

1.7.6.3
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.7.6.4;

1.7.6.4
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.7.6.5;

1.7.6.5
date	2003.03.28.00.38.23;	author niklas;	state Exp;
branches;
next	1.7.6.6;

1.7.6.6
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	1.7.6.7;

1.7.6.7
date	2004.06.05.23.12.51;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2002.06.11.03.42.26;	author art;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2002.10.29.00.33.29;	author art;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2003.05.19.22.18.01;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.46
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_xl_pci.c,v 1.45 2015/11/24 13:33:18 mpi Exp $	*/

/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: if_xl.c,v 1.72 2000/01/09 21:12:59 wpaul Exp $
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/mii/miivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

/*
 * The following #define causes the code to use PIO to access the
 * chip's registers instead of memory mapped mode. The reason PIO mode
 * is on by default is that the Etherlink XL manual seems to indicate
 * that only the newer revision chips (3c905B) support both PIO and
 * memory mapped access. Since we want to be compatible with the older
 * bus master chips, we use PIO here. If you comment this out, the
 * driver will use memory mapped I/O, which may be faster but which
 * might not work on some devices.
 */
#define XL_USEIOSPACE

#define XL_PCI_FUNCMEM		0x0018
#define XL_PCI_INTR		0x0004
#define XL_PCI_INTRACK		0x8000

#include <dev/ic/xlreg.h>

int xl_pci_match(struct device *, void *, void *);
void xl_pci_attach(struct device *, struct device *, void *);
int xl_pci_detach(struct device *, int);
void xl_pci_intr_ack(struct xl_softc *);
#ifndef SMALL_KERNEL
void xl_pci_wol_power(void *);
#endif

struct xl_pci_softc {
	struct xl_softc		psc_softc;
	pci_chipset_tag_t	psc_pc;
	pcitag_t		psc_tag;
	bus_size_t		psc_iosize;
	bus_size_t		psc_funsize;
};

struct cfattach xl_pci_ca = {
	sizeof(struct xl_pci_softc), xl_pci_match, xl_pci_attach,
	xl_pci_detach, xl_activate
};

const struct pci_matchid xl_pci_devices[] = {
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CSOHO100TX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C900TPO },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C900COMBO },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C900B },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C900BCOMBO },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C900BTPC },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C900BFL },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905TX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905T4 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905BTX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905BT4 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905BCOMBO },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905BFX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C980TX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C980CTX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905CTX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C450 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C555 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C556 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C556B },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C9201 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C920BEMBW },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C575 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CCFE575BT },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CCFE575CT },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CCFEM656 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CCFEM656B },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CCFEM656C },
};

int
xl_pci_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, xl_pci_devices,
	    nitems(xl_pci_devices)));
}

void
xl_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct xl_pci_softc *psc = (void *)self;
	struct xl_softc *sc = &psc->psc_softc;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
	bus_size_t iosize, funsize;
#ifndef SMALL_KERNEL
	u_int32_t command;
#endif

	psc->psc_pc = pc;
	psc->psc_tag = pa->pa_tag;
	sc->sc_dmat = pa->pa_dmat;

	sc->xl_flags = 0;
	sc->wol_power = sc->wol_power_arg = NULL;

	/* set required flags */
	switch (PCI_PRODUCT(pa->pa_id)) {
	case TC_DEVICEID_HURRICANE_555:
		sc->xl_flags |= XL_FLAG_EEPROM_OFFSET_30 | XL_FLAG_8BITROM;
		break;
	case TC_DEVICEID_HURRICANE_556:
		sc->xl_flags |= XL_FLAG_FUNCREG | XL_FLAG_PHYOK |
		    XL_FLAG_EEPROM_OFFSET_30 | XL_FLAG_WEIRDRESET;
		sc->xl_flags |= XL_FLAG_INVERT_LED_PWR|XL_FLAG_INVERT_MII_PWR;
		sc->xl_flags |= XL_FLAG_8BITROM;
		break;
	case TC_DEVICEID_HURRICANE_556B:
		sc->xl_flags |= XL_FLAG_FUNCREG | XL_FLAG_PHYOK |
		    XL_FLAG_EEPROM_OFFSET_30 | XL_FLAG_WEIRDRESET;
		sc->xl_flags |= XL_FLAG_INVERT_LED_PWR|XL_FLAG_INVERT_MII_PWR;
		break;
	case PCI_PRODUCT_3COM_3C9201:
	case PCI_PRODUCT_3COM_3C920BEMBW:
		sc->xl_flags |= XL_FLAG_PHYOK;
		break;
	case TC_DEVICEID_BOOMERANG_10_100BT:
		sc->xl_flags |= XL_FLAG_NO_MMIO;
		break;
	case PCI_PRODUCT_3COM_3C575:
		sc->xl_flags |= XL_FLAG_PHYOK | XL_FLAG_EEPROM_OFFSET_30 |
		   XL_FLAG_8BITROM;
		break;
	case PCI_PRODUCT_3COM_3CCFE575BT:
		sc->xl_flags = XL_FLAG_PHYOK | XL_FLAG_EEPROM_OFFSET_30 |
		    XL_FLAG_8BITROM | XL_FLAG_INVERT_LED_PWR;
		sc->xl_flags |= XL_FLAG_FUNCREG;
		break;
	case PCI_PRODUCT_3COM_3CCFE575CT:
		sc->xl_flags = XL_FLAG_PHYOK | XL_FLAG_EEPROM_OFFSET_30 |
		    XL_FLAG_8BITROM | XL_FLAG_INVERT_MII_PWR;
		sc->xl_flags |= XL_FLAG_FUNCREG;
		break;
	case PCI_PRODUCT_3COM_3CCFEM656:
		sc->xl_flags = XL_FLAG_PHYOK | XL_FLAG_EEPROM_OFFSET_30 |
		    XL_FLAG_8BITROM | XL_FLAG_INVERT_LED_PWR |
		    XL_FLAG_INVERT_MII_PWR;
		sc->xl_flags |= XL_FLAG_FUNCREG;
		break;
	case PCI_PRODUCT_3COM_3CCFEM656B:
		sc->xl_flags = XL_FLAG_PHYOK | XL_FLAG_EEPROM_OFFSET_30 |
		    XL_FLAG_8BITROM | XL_FLAG_INVERT_LED_PWR |
		    XL_FLAG_INVERT_MII_PWR;
		sc->xl_flags |= XL_FLAG_FUNCREG;
		break;
	case PCI_PRODUCT_3COM_3CCFEM656C:
		sc->xl_flags = XL_FLAG_PHYOK | XL_FLAG_EEPROM_OFFSET_30 |
		    XL_FLAG_8BITROM | XL_FLAG_INVERT_MII_PWR;
		sc->xl_flags |= XL_FLAG_FUNCREG;
		break;
	default:
		break;
	}

	pci_set_powerstate(pa->pa_pc, pa->pa_tag, PCI_PMCSR_STATE_D0);

#ifndef SMALL_KERNEL
	/*
	 * The card is WOL-capable if it supports PME# assertion
	 * from D3hot power state. Install a callback to configure
	 * PCI power state for WOL. It will be invoked when the
	 * interface stops and WOL was enabled.
	 */
	command = pci_conf_read(pc, pa->pa_tag, XL_PCI_CAPID);
	if ((command >> 16) & XL_PME_CAP_D3_HOT) {
		sc->wol_power = xl_pci_wol_power;
		sc->wol_power_arg = psc;
	}
#endif

	/*
	 * Map control/status registers.
	 */
#ifdef XL_USEIOSPACE
	if (pci_mapreg_map(pa, XL_PCI_LOIO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->xl_btag, &sc->xl_bhandle, NULL, &iosize, 0)) {
		printf(": can't map i/o space\n");
		return;
	}
#else
	if (pci_mapreg_map(pa, XL_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->xl_btag, &sc->xl_bhandle, NULL, &iosize, 0)) {
		printf(": can't map i/o space\n");
		return;
	}
#endif
	psc->psc_iosize = iosize;

	if (sc->xl_flags & XL_FLAG_FUNCREG) {
		if (pci_mapreg_map(pa, XL_PCI_FUNCMEM, PCI_MAPREG_TYPE_MEM, 0,
		    &sc->xl_funct, &sc->xl_funch, NULL, &funsize, 0)) {
			printf(": can't map i/o space\n");
			bus_space_unmap(sc->xl_btag, sc->xl_bhandle, iosize);
			return;
		}
		psc->psc_funsize = funsize;
		sc->intr_ack = xl_pci_intr_ack;
	}

	/*
	 * Allocate our interrupt.
	 */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		bus_space_unmap(sc->xl_btag, sc->xl_bhandle, iosize);
		if (sc->xl_flags & XL_FLAG_FUNCREG)
			bus_space_unmap(sc->xl_funct, sc->xl_funch, funsize);
		return;
	}

	intrstr = pci_intr_string(pc, ih);
	sc->xl_intrhand = pci_intr_establish(pc, ih, IPL_NET, xl_intr, sc,
	    self->dv_xname);
	if (sc->xl_intrhand == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		bus_space_unmap(sc->xl_btag, sc->xl_bhandle, iosize);
		if (sc->xl_flags & XL_FLAG_FUNCREG)
			bus_space_unmap(sc->xl_funct, sc->xl_funch, funsize);
		return;
	}
	printf(": %s", intrstr);

	xl_attach(sc);
}

int
xl_pci_detach(struct device *self, int flags)
{
	struct xl_pci_softc *psc = (void *)self;
	struct xl_softc *sc = &psc->psc_softc;

	if (sc->xl_intrhand != NULL) {
		pci_intr_disestablish(psc->psc_pc, sc->xl_intrhand);
		xl_detach(sc);
	}
	if (psc->psc_iosize > 0)
		bus_space_unmap(sc->xl_btag, sc->xl_bhandle, psc->psc_iosize);
	if (psc->psc_funsize > 0)
		bus_space_unmap(sc->xl_funct, sc->xl_funch, psc->psc_funsize);
	return (0);
}

void            
xl_pci_intr_ack(struct xl_softc *sc)
{
	bus_space_write_4(sc->xl_funct, sc->xl_funch, XL_PCI_INTR,
	    XL_PCI_INTRACK);
}

#ifndef SMALL_KERNEL
void
xl_pci_wol_power(void *ppsc)
{
	struct xl_pci_softc *psc = (struct xl_pci_softc*)ppsc;
	u_int32_t command;

	/* Make sure wake-up generation is enabled. */
	command = pci_conf_read(psc->psc_pc, psc->psc_tag, XL_PCI_PWRMGMTCTRL);
	command |= XL_PME_EN;
	pci_conf_write(psc->psc_pc, psc->psc_tag, XL_PCI_PWRMGMTCTRL, command);
}
#endif
@


1.45
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.44 2015/03/14 03:38:48 jsg Exp $	*/
a50 1
#include <net/if_dl.h>
@


1.44
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.43 2014/12/22 02:28:52 tedu Exp $	*/
a51 1
#include <net/if_types.h>
@


1.43
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.42 2014/07/22 13:12:11 mpi Exp $	*/
a57 1
#include <dev/mii/mii.h>
@


1.42
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.41 2013/08/07 01:06:39 bluhm Exp $	*/
a54 1
#ifdef INET
a56 1
#endif
@


1.41
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.40 2012/10/18 21:44:21 deraadt Exp $	*/
a56 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.40
log
@Convert a number of old private copies of code which predates
pci_set_powerstate() to using it instead.  Many of these chunks of code had
bugs in them, especially missing delay() calls.  Some of them were doing
things our PCI subsystem is now responsible for handling.  If you have
any of the affected devices, please keep an eye out for regressions.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.39 2012/10/13 17:24:03 deraadt Exp $	*/
a57 1
#include <netinet/in_var.h>
@


1.39
log
@This device should not put itself into D3 by itself when going to WOL;
allow the pci subsystem to do that based on BIOS information if it needs.
Tested by stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.38 2011/10/13 13:09:29 kettenis Exp $	*/
d160 1
d162 1
d229 3
d233 4
a236 15
	 * If this is a 3c905B, we have to check one extra thing.
	 * The 905B supports power management and may be placed in
	 * a low-power mode (D3 mode), typically by certain operating
	 * systems which shall not be named. The PCI BIOS is supposed
	 * to reset the NIC and bring it out of low-power mode, but  
	 * some do not. Consequently, we have to see if this chip    
	 * supports power management, and if so, make sure it's not  
	 * in low-power mode. If power management is available, the  
	 * capid byte will be 0x01.
	 * 
	 * I _think_ that what actually happens is that the chip
	 * loses its PCI configuration during the transition from
	 * D3 back to D0; this means that it should be possible for
	 * us to save the PCI iobase, membase and IRQ, put the chip
	 * back in the D0 state, then restore the PCI config ourselves.
d238 5
a242 38
	command = pci_conf_read(pc, pa->pa_tag, XL_PCI_CAPID) & 0xff;
	if (command == 0x01) {

		command = pci_conf_read(pc, pa->pa_tag,
		    XL_PCI_PWRMGMTCTRL);
		if (command & XL_PSTATE_MASK) {
			u_int32_t io, mem, irq;

			/* Save PCI config */
			io = pci_conf_read(pc, pa->pa_tag, XL_PCI_LOIO);
			mem = pci_conf_read(pc, pa->pa_tag, XL_PCI_LOMEM);
			irq = pci_conf_read(pc, pa->pa_tag, XL_PCI_INTLINE);

			/* Reset the power state. */
			printf("%s: chip is in D%d power mode "
			    "-- setting to D0\n",
			    sc->sc_dev.dv_xname, command & XL_PSTATE_MASK);
			command &= 0xFFFFFFFC;
			pci_conf_write(pc, pa->pa_tag,
			    XL_PCI_PWRMGMTCTRL, command);

			pci_conf_write(pc, pa->pa_tag, XL_PCI_LOIO, io);
			pci_conf_write(pc, pa->pa_tag, XL_PCI_LOMEM, mem);
			pci_conf_write(pc, pa->pa_tag, XL_PCI_INTLINE, irq);
		}

#ifndef SMALL_KERNEL
		/*
		 * The card is WOL-capable if it supports PME# assertion
		 * from D3hot power state. Install a callback to configure
		 * PCI power state for WOL. It will be invoked when the
		 * interface stops and WOL was enabled.
		 */
		command = pci_conf_read(pc, pa->pa_tag, XL_PCI_CAPID);
		if ((command >> 16) & XL_PME_CAP_D3_HOT) {
			sc->wol_power = xl_pci_wol_power;
			sc->wol_power_arg = psc;
		}
a243 1
	}
@


1.38
log
@Make WOL support do something that actually makes sense; effectively
reverting most of the previous commit.  Fixes unaligned read from PCI config
space as well.

ok & tested by stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.37 2011/07/08 18:56:47 stsp Exp $	*/
a376 2

	pci_set_powerstate(psc->psc_pc, psc->psc_tag, PCI_PMCSR_STATE_D3);
@


1.37
log
@Fix WoL support in xl(4). Now works with my hardware (3Com 3c905C).
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.36 2011/04/17 20:52:43 stsp Exp $	*/
d271 2
a272 1
		/* The card is WOL-capable if it supports PME# assertion
d275 3
a277 2
		 * interface stops and WOL was enabled. */
		command = pci_conf_read(pc, pa->pa_tag, XL_PCI_PWRMGMTCAP);
d280 1
a280 1
			sc->wol_power_arg = psc; 
d371 6
@


1.36
log
@Add wol support to xl(4). Not really tested, but hopefully someone will
test it now that it's in-tree. ok deraadt ("It causes no harm")
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.35 2011/04/03 15:36:03 jasper Exp $	*/
d276 1
a276 1
		if (command & XL_PME_CAP_D3_HOT) {
a367 1
	u_int32_t	command;
d370 1
a370 5
	/* Make sure power management is enabled, and set the card into
	 * D3hot power state so it stays active after system shutdown. */
	command = pci_conf_read(psc->psc_pc, psc->psc_tag, XL_PCI_PWRMGMTCTRL);
	command |= XL_PME_EN | XL_PSTATE_D3;
	pci_conf_write(psc->psc_pc, psc->psc_tag, XL_PCI_PWRMGMTCTRL, command);
@


1.35
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.34 2010/09/19 09:22:58 deraadt Exp $	*/
d95 3
d102 1
d163 1
d167 1
d269 12
d363 15
@


1.34
log
@wrap a long line
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.33 2010/09/04 19:38:16 kettenis Exp $	*/
d143 1
a143 1
	    sizeof(xl_pci_devices)/sizeof(xl_pci_devices[0])));
@


1.33
log
@Remove redundant prototype left behind by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.32 2010/08/27 15:43:42 deraadt Exp $	*/
d104 2
a105 2
	sizeof(struct xl_pci_softc), xl_pci_match, xl_pci_attach, xl_pci_detach,
	xl_activate
@


1.32
log
@Move the xl_pci_activate function into xl_activate so that it is in the
sub-driver, and then xl_powerhook can simply be a wrapper around it
ok kettenis; discussion about nested structure aliasing with miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.31 2010/08/12 14:21:55 kettenis Exp $	*/
a93 1
int xl_activate(struct device *, int);
@


1.31
log
@Reset the chip upon suspend, to make sure it stops DMA.  Reset it again upon
resume to make sure the chip is initialized the same way as upon attach.
Fixes memory corruption after resume on the Dell Inspirion 4150.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.30 2010/08/06 02:45:54 deraadt Exp $	*/
d94 1
a94 1
int xl_pci_activate(struct device *, int);
d106 1
a106 1
	xl_pci_activate
a336 25
	return (0);
}

int
xl_pci_activate(struct device *self, int act)
{
	struct xl_pci_softc *psc = (void *)self;
	struct xl_softc *sc = &psc->psc_softc;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING) {
			xl_reset(sc);
			xl_stop(sc);
		}
		config_activate_children(self, act);
		break;
	case DVACT_RESUME:
		xl_reset(sc);
		config_activate_children(self, act);
		if (ifp->if_flags & IFF_UP)
			xl_init(sc);
		break;
	}
@


1.30
log
@ca_activate function for suspend/resume
tested by mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.29 2010/04/08 00:23:53 tedu Exp $	*/
d349 2
a350 1
		if (ifp->if_flags & IFF_RUNNING)
d352 1
d356 1
@


1.29
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.28 2010/01/11 23:21:24 kettenis Exp $	*/
d94 1
d105 2
a106 1
	sizeof(struct xl_pci_softc), xl_pci_match, xl_pci_attach, xl_pci_detach
d337 22
@


1.28
log
@Make the detach function handle the case of a partial attach, and make sure
we also free the additional mapped BAR on "cyclone" chips.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.27 2010/01/10 04:04:13 kettenis Exp $	*/
a47 1
#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */
@


1.27
log
@Set XL_FLAG_FUNCREG for "cyclone" variants.  This makes them see interrupts
such that they actually work.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.26 2009/10/15 17:54:56 deraadt Exp $	*/
d101 1
d281 1
d290 1
a316 1
	psc->psc_iosize = iosize;
d328 8
a335 3
	pci_intr_disestablish(psc->psc_pc, sc->xl_intrhand);
	xl_detach(sc);
	bus_space_unmap(sc->xl_btag, sc->xl_bhandle, psc->psc_iosize);
@


1.26
log
@Add detach support to a few more drivers, and in others do the neccessary
operations in the detach function in the right order.  Also ensure that the
interrupt handlers not trust registers that go away.
read over very carefully by dms, tested by me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.25 2009/06/02 05:29:47 jsg Exp $	*/
d192 1
d197 1
d203 1
d209 1
d214 1
@


1.25
log
@make xl at pci detachable.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.24 2009/06/02 05:07:00 jsg Exp $	*/
a319 1
	int rv = 0;
d321 4
a324 7
	rv = xl_detach(sc);
	if (rv == 0) {
		pci_intr_disestablish(psc->psc_pc, sc->xl_intrhand);
		bus_space_unmap(sc->xl_btag, sc->xl_bhandle, psc->psc_iosize);
	}

	return (rv);
@


1.24
log
@Set flags on the recently added CardBus ids based on
product id.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.23 2009/06/02 01:23:02 jsg Exp $	*/
d94 1
d97 6
d104 1
a104 1
	sizeof(struct xl_softc), xl_pci_match, xl_pci_attach,
d148 2
a149 1
	struct xl_softc *sc = (struct xl_softc *)self;
d157 1
d309 1
d315 15
@


1.23
log
@Add CardBus devices to the match list.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.22 2006/08/10 20:10:19 brad Exp $	*/
d175 26
@


1.22
log
@- ANSI functions
- de-register
- remove return at the end of void functions
- some cosmetic tweaking
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.21 2005/08/09 04:10:12 mickey Exp $	*/
d123 6
@


1.21
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.20 2004/07/16 06:08:05 deraadt Exp $	*/
d126 1
a126 4
xl_pci_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d133 1
a133 3
xl_pci_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d275 1
a275 2
xl_pci_intr_ack(sc)
	struct xl_softc *sc;
@


1.20
log
@new xl variant (Asus P4R800-VM motherboards)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.19 2004/05/30 23:49:39 brad Exp $	*/
a225 4
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    PCI_COMMAND_MASTER_ENABLE |
	    pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG));

@


1.19
log
@a bit of syncing with the FreeBSD driver, namely...

- disable TX hardware checksumming since its buggy and slow

- re-enable the hardware multicast filter setup on 3c905B/C's

- enable reception of VLAN sized frames on 3c90x's (pre B/C)

- remove all DELAY(1) calls around MII operations in the xl driver.
according to the MII specification, the delay produced by our
reads alone are sufficient for correct operation.

this reduces the time mii_tick takes from 10ms to ~1ms here. that's
still a lot, but much better than before

- report media status for bitrate PHYs

- change the method used to detect older boomerang chips

- fix an issue with reading PHY regs over the i2c bus

- fix mbuf leaks in an error (rare) code path

- reuse the TX descriptor if xl_encap() failed instead of just picking the next one

- fix bug with 3c90xB cards and newer. We weren't trying to
copy the mbuf chain into an mbuf cluster when there is
more than 63 mbufs in the chain. we were trying with older
cards though

- add some magic bits necessary to turn the transmitter on for some
(newer) 556B chips

local change...

- use ether_crc32_be() instead of hand-rolled xl_calchash()

tested on i386/3c900 by beck@@, sparc64/3c905C by me, i386/3c905C by sturm@@, naddy@@ and a few others
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.18 2004/01/09 21:32:24 brad Exp $	*/
d122 1
d169 1
@


1.18
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.17 2003/12/23 16:46:21 mickey Exp $	*/
d151 1
a151 1
	/* set flags required for 3Com MiniPCI adapters */
d167 1
a167 1
	case  PCI_PRODUCT_3COM_3C9201:
d169 3
@


1.17
log
@use pci_mapreg_map and deallocate resources on attach failures
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.16 2003/06/29 16:39:02 jason Exp $	*/
a72 2

#include <uvm/uvm_extern.h>              /* for vtophys */
@


1.16
log
@remove usage of xl_unit
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.15 2003/01/13 00:37:12 henning Exp $	*/
d146 1
a146 2
	bus_addr_t iobase;
	bus_size_t iosize;
d223 3
a225 6
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_IO_ENABLE |
		   PCI_COMMAND_MEM_ENABLE |
		   PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
d228 2
a229 13
	if (!(command & PCI_COMMAND_IO_ENABLE)) {
		printf("%s: failed to enable i/o ports\n",
		    sc->sc_dev.dv_xname);
		return;
	}
	/*
	 * Map control/status registers.
	 */
	if (pci_io_find(pc, pa->pa_tag, XL_PCI_LOIO, &iobase, &iosize)) {
		printf(": can't find i/o space\n");
		return;
	}
	if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->xl_bhandle)) {
a232 1
	sc->xl_btag = pa->pa_iot;
d234 3
a236 6
	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf(": failed to enable memory mapping\n");
		return;
	}
	if (pci_mem_find(pc, pa->pa_tag, XL_PCI_LOMEM, &iobase, &iosize, NULL)){
		printf(": can't find mem space\n");
a238 5
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->xl_bhandle)) {
		printf(": can't map mem space\n");
		return;
	}
	sc->xl_btag = pa->pa_memt;
d242 4
a245 8
		if (pci_mem_find(pc, pa->pa_tag, XL_PCI_FUNCMEM, &iobase,
		    &iosize, NULL)) {
			printf(": can't find func space\n");
			return;
		}
		if (bus_space_map(pa->pa_memt, iobase, iosize, 0,
		    &sc->xl_funch)) {
			printf(": can't map func space\n");
a247 1
		sc->xl_funct = pa->pa_memt;
d256 3
d269 3
@


1.15
log
@make 3com 9201 really work - got the last success report a bit early.
tested by "Johan M:son Lindman" <tybollt at solace.mh.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.14 2003/01/12 20:48:15 henning Exp $	*/
a150 1
	sc->xl_unit = sc->sc_dev.dv_unit;
@


1.14
log
@support the 3com 9201 found on nForce2-based Asus A7N8X
tested by Johan M:son Lindman <tybollt at solace.mh.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.13 2002/11/19 18:40:17 jason Exp $	*/
d170 3
@


1.13
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.12 2002/06/15 05:14:41 aaron Exp $	*/
d123 1
@


1.12
log
@bus_dma'ify. Tested on 3c900(pci), 3c905b(pci), and 3c575c(cardbus). Thanks
to todd@@ and camiel@@ for trying it, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.11 2002/03/14 01:26:59 millert Exp $	*/
d102 23
d131 2
a132 30
	struct pci_attach_args *pa = (struct pci_attach_args *) aux;

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_3COM)
		return (0);

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_3COM_3CSOHO100TX:
	case PCI_PRODUCT_3COM_3C900TPO:
	case PCI_PRODUCT_3COM_3C900COMBO:
	case PCI_PRODUCT_3COM_3C900B:
	case PCI_PRODUCT_3COM_3C900BCOMBO:
	case PCI_PRODUCT_3COM_3C900BTPC:
	case PCI_PRODUCT_3COM_3C900BFL:
	case PCI_PRODUCT_3COM_3C905TX:
	case PCI_PRODUCT_3COM_3C905T4:
	case PCI_PRODUCT_3COM_3C905BTX:
	case PCI_PRODUCT_3COM_3C905BT4:
	case PCI_PRODUCT_3COM_3C905BCOMBO:
	case PCI_PRODUCT_3COM_3C905BFX:
	case PCI_PRODUCT_3COM_3C980TX:
	case PCI_PRODUCT_3COM_3C980CTX:
	case PCI_PRODUCT_3COM_3C905CTX:
	case PCI_PRODUCT_3COM_3C450:
	case PCI_PRODUCT_3COM_3C555:
	case PCI_PRODUCT_3COM_3C556:
	case PCI_PRODUCT_3COM_3C556B:
		return (1);
	}
					
	return (0);
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.10 2001/11/06 19:53:19 miod Exp $	*/
d154 1
@


1.10
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.9 2001/08/25 10:13:29 art Exp $	*/
d94 3
a96 3
int xl_pci_match	__P((struct device *, void *, void *));
void xl_pci_attach	__P((struct device *, struct device *, void *));
void xl_pci_intr_ack	__P((struct xl_softc *));
@


1.10.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.10 2001/11/06 19:53:19 miod Exp $	*/
d94 3
a96 3
int xl_pci_match(struct device *, void *, void *);
void xl_pci_attach(struct device *, struct device *, void *);
void xl_pci_intr_ack(struct xl_softc *);
@


1.10.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.10.2.1 2002/06/11 03:42:26 art Exp $	*/
a153 1
	sc->sc_dmat = pa->pa_dmat;
@


1.10.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a101 24
const struct pci_matchid xl_pci_devices[] = {
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CSOHO100TX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C900TPO },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C900COMBO },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C900B },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C900BCOMBO },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C900BTPC },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C900BFL },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905TX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905T4 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905BTX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905BT4 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905BCOMBO },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905BFX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C980TX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C980CTX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905CTX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C450 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C555 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C556 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C556B },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C9201 },
};

d108 30
a137 2
	return (pci_matchbyid((struct pci_attach_args *)aux, xl_pci_devices,
	    sizeof(xl_pci_devices)/sizeof(xl_pci_devices[0])));
a173 3
		break;
	case  PCI_PRODUCT_3COM_3C9201:
		sc->xl_flags |= XL_FLAG_PHYOK;
@


1.9
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.8 2001/08/12 20:03:49 mickey Exp $	*/
d74 1
a74 1
#include <vm/vm.h>              /* for vtophys */
@


1.8
log
@remove redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.7 2000/10/14 15:44:21 aaron Exp $	*/
d284 1
a284 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.7
log
@Repair memory mapping; from jason@@. Now the 3c556 MiniPCI adapter works.
Thanks to Richard_Koett@@squamish.net for testing on his HP OmniBook 6000.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.6 2000/10/13 14:55:23 aaron Exp $	*/
a74 1
#include <vm/pmap.h>            /* for vtophys */
@


1.7.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.7 2000/10/14 15:44:21 aaron Exp $	*/
@


1.7.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.7.6.1 2001/05/14 22:25:49 niklas Exp $	*/
d75 1
d285 2
a286 1
	if (pci_intr_map(pa, &ih)) {
@


1.7.6.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 1
a74 1
#include <uvm/uvm_extern.h>              /* for vtophys */
@


1.7.6.4
log
@Merge in -current from roughly a week ago
@
text
@d94 3
a96 3
int xl_pci_match(struct device *, void *, void *);
void xl_pci_attach(struct device *, struct device *, void *);
void xl_pci_intr_ack(struct xl_softc *);
@


1.7.6.5
log
@Sync the SMP branch with 3.3
@
text
@a101 24
const struct pci_matchid xl_pci_devices[] = {
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CSOHO100TX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C900TPO },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C900COMBO },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C900B },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C900BCOMBO },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C900BTPC },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C900BFL },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905TX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905T4 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905BTX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905BT4 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905BCOMBO },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905BFX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C980TX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C980CTX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C905CTX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C450 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C555 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C556 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C556B },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C9201 },
};

d108 30
a137 2
	return (pci_matchbyid((struct pci_attach_args *)aux, xl_pci_devices,
	    sizeof(xl_pci_devices)/sizeof(xl_pci_devices[0])));
a153 1
	sc->sc_dmat = pa->pa_dmat;
a172 3
		break;
	case  PCI_PRODUCT_3COM_3C9201:
		sc->xl_flags |= XL_FLAG_PHYOK;
@


1.7.6.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d74 2
d146 2
a147 1
	bus_size_t iosize, funsize;
d151 1
d225 6
a230 3
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    PCI_COMMAND_MASTER_ENABLE |
	    pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG));
d233 13
a245 2
	if (pci_mapreg_map(pa, XL_PCI_LOIO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->xl_btag, &sc->xl_bhandle, NULL, &iosize, 0)) {
d249 1
d251 10
a260 3
	if (pci_mapreg_map(pa, XL_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->xl_btag, &sc->xl_bhandle, NULL, &iosize, 0)) {
		printf(": can't map i/o space\n");
d263 1
d267 8
a274 4
		if (pci_mapreg_map(pa, XL_PCI_FUNCMEM, PCI_MAPREG_TYPE_MEM, 0,
		    &sc->xl_funct, &sc->xl_funch, NULL, &funsize, 0)) {
			printf(": can't map i/o space\n");
			bus_space_unmap(sc->xl_btag, sc->xl_bhandle, iosize);
d277 1
a285 3
		bus_space_unmap(sc->xl_btag, sc->xl_bhandle, iosize);
		if (sc->xl_flags & XL_FLAG_FUNCREG)
			bus_space_unmap(sc->xl_funct, sc->xl_funch, funsize);
a295 3
		bus_space_unmap(sc->xl_btag, sc->xl_bhandle, iosize);
		if (sc->xl_flags & XL_FLAG_FUNCREG)
			bus_space_unmap(sc->xl_funct, sc->xl_funch, funsize);
@


1.7.6.7
log
@Merge with the trunk
@
text
@d151 1
a151 1
	/* set required flags */
d167 1
a167 1
	case PCI_PRODUCT_3COM_3C9201:
a168 3
		break;
	case TC_DEVICEID_BOOMERANG_10_100BT:
		sc->xl_flags |= XL_FLAG_NO_MMIO;
@


1.6
log
@- A couple of the MiniPCI adapters need the special power inversion bits.
- Get rid of magic values and use meaningful names instead.
- My tester claims the 3c556 does not quite work 100% yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.5 2000/09/29 05:28:29 aaron Exp $	*/
a94 6
struct xl_pci_softc {
	struct xl_softc sc_xl;
	pci_chipset_tag_t sc_chiptag;
	pcitag_t sc_pcitag;
};

d99 4
a147 1
	struct xl_pci_softc *psc = (void *)self;
d268 11
a279 2
		psc->sc_chiptag = pa->pa_pc;
		psc->sc_pcitag = pa->pa_tag;
d310 2
a311 4
	struct xl_pci_softc *psc = (struct xl_pci_softc *)sc;

	pci_conf_write(psc->sc_chiptag, psc->sc_pcitag,
	    XL_PCI_FUNCMEM + XL_PCI_INTR, XL_PCI_INTRACK);
a312 4

struct cfattach xl_pci_ca = {
	sizeof(struct xl_pci_softc), xl_pci_match, xl_pci_attach,
};
@


1.5
log
@- Add support for 3Com 3C555 MiniPCI.
- Clean up configuration flags mess. The MiniPCI adapters share some properties
  with the CardBus adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.4 2000/09/16 21:42:17 aaron Exp $	*/
d90 1
d170 1
d176 1
d306 2
a307 2
	pci_conf_write(psc->sc_chiptag, psc->sc_pcitag, XL_PCI_FUNCMEM + 4,
	    XL_PCI_INTRACK);
@


1.4
log
@Add support for 3C556[B] MiniPCI Ethernet adapters, found on some laptops
(i.e., HP OmniBooks). I have sent these changes to a tester but I haven't
heard back yet. Assume for now the changes are OK since all of the other
variants I have still work.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.3 2000/07/01 03:19:15 aaron Exp $	*/
d89 3
d94 9
a102 2
int xl_pci_match __P((struct device *, void *, void *));
void xl_pci_attach __P((struct device *, struct device *, void *));
d133 1
d149 1
d159 1
a159 2
	sc->xl_bustype = XL_BUS_PCI;
	sc->xl_cb_flags = 0;
d161 6
a166 3
	sc->xl_flags = 0;
	if (PCI_PRODUCT(pa->pa_id) == TC_DEVICEID_HURRICANE_556 ||
	    PCI_PRODUCT(pa->pa_id) == TC_DEVICEID_HURRICANE_556B)
a168 1
	if (PCI_PRODUCT(pa->pa_id) == TC_DEVICEID_HURRICANE_556)
d170 9
a178 1
	
d268 3
a270 11
		if (pci_mem_find(pc, pa->pa_tag, XL_PCI_FUNCMEM, &iobase,
		    &iosize, NULL)) {
			printf(": can't find mem space\n");
			return;
		}
		if (bus_space_map(pa->pa_memt, iobase, iosize, 0,
		    &sc->xl_fhandle)) {
			printf(": can't map mem space\n");
			return;
		}
		sc->xl_ftag = pa->pa_memt;
d296 11
d308 1
a308 1
	sizeof(struct xl_softc), xl_pci_match, xl_pci_attach,
@


1.3
log
@- Make the 3CCFE575BT work.
- Add support for the 3CCFEM656C.
- Lots of code cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.2 2000/04/18 03:52:36 jason Exp $	*/
d123 2
d150 8
d245 14
@


1.2
log
@copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xl_pci.c,v 1.1 2000/04/08 05:50:51 aaron Exp $	*/
d144 3
@


1.1
log
@Initial check-in for support of 32-bit CardBus PC Cards; from NetBSD. On many
machines, this code needs the new PCIBIOS* options enabled in the kernel config
file to work, but your mileage may vary. Included is a working 3c575 driver for
3Com 10/100 CardBus PC Card NICs (tested only with the 'C' revision). The 3c575
is the pccard version of the PCI EtherLink XL cards, and thus the xl driver has
been split into /sys/dev/ic.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 33
@

