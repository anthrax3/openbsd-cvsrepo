head	1.120;
access;
symbols
	OPENBSD_6_1:1.120.0.4
	OPENBSD_6_1_BASE:1.120
	OPENBSD_6_0:1.115.0.4
	OPENBSD_6_0_BASE:1.115
	OPENBSD_5_9:1.114.0.2
	OPENBSD_5_9_BASE:1.114
	OPENBSD_5_8:1.108.0.4
	OPENBSD_5_8_BASE:1.108
	OPENBSD_5_7:1.107.0.4
	OPENBSD_5_7_BASE:1.107
	OPENBSD_5_6:1.101.0.4
	OPENBSD_5_6_BASE:1.101
	OPENBSD_5_5:1.98.0.4
	OPENBSD_5_5_BASE:1.98
	OPENBSD_5_4:1.95.0.10
	OPENBSD_5_4_BASE:1.95
	OPENBSD_5_3:1.95.0.8
	OPENBSD_5_3_BASE:1.95
	OPENBSD_5_2:1.95.0.6
	OPENBSD_5_2_BASE:1.95
	OPENBSD_5_1_BASE:1.95
	OPENBSD_5_1:1.95.0.4
	OPENBSD_5_0:1.95.0.2
	OPENBSD_5_0_BASE:1.95
	OPENBSD_4_9:1.94.0.2
	OPENBSD_4_9_BASE:1.94
	OPENBSD_4_8:1.88.0.2
	OPENBSD_4_8_BASE:1.88
	OPENBSD_4_7:1.85.0.2
	OPENBSD_4_7_BASE:1.85
	OPENBSD_4_6:1.85.0.4
	OPENBSD_4_6_BASE:1.85
	OPENBSD_4_5:1.84.0.2
	OPENBSD_4_5_BASE:1.84
	OPENBSD_4_4:1.73.0.2
	OPENBSD_4_4_BASE:1.73
	OPENBSD_4_3:1.71.0.2
	OPENBSD_4_3_BASE:1.71
	OPENBSD_4_2:1.67.0.2
	OPENBSD_4_2_BASE:1.67
	OPENBSD_4_1:1.66.0.2
	OPENBSD_4_1_BASE:1.66
	OPENBSD_4_0:1.62.0.2
	OPENBSD_4_0_BASE:1.62
	OPENBSD_3_9:1.55.0.2
	OPENBSD_3_9_BASE:1.55
	OPENBSD_3_8:1.50.0.2
	OPENBSD_3_8_BASE:1.50
	OPENBSD_3_7:1.44.0.2
	OPENBSD_3_7_BASE:1.44;
locks; strict;
comment	@ * @;


1.120
date	2017.03.08.12.02.41;	author mpi;	state Exp;
branches;
next	1.119;
commitid	okVP7pbbXG8IxGgU;

1.119
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.118;
commitid	VyLWTsbepAOk7VQM;

1.118
date	2016.09.05.10.17.30;	author tedu;	state Exp;
branches;
next	1.117;
commitid	v4TVMbg1eTRYG0ph;

1.117
date	2016.09.05.09.59.20;	author kettenis;	state Exp;
branches;
next	1.116;
commitid	uFP8u4jS9PVbGRb4;

1.116
date	2016.09.05.08.17.29;	author tedu;	state Exp;
branches;
next	1.115;
commitid	SzoxOYYWq3RWrWJ3;

1.115
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.114;
commitid	8YSL8ByWzGeIGBiJ;

1.114
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.113;
commitid	B0kwmVGiD5DVx4kv;

1.113
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.112;
commitid	FuSD2mFDJWATHIDx;

1.112
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.111;
commitid	5DvsamK0GblTp8ww;

1.111
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.110;
commitid	eYnPulzvLjDImPCa;

1.110
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.109;
commitid	hPF95ClMUQfeqQDX;

1.109
date	2015.09.01.07.09.55;	author deraadt;	state Exp;
branches;
next	1.108;
commitid	VvLv8PeakqoJLqr3;

1.108
date	2015.05.27.22.10.52;	author kettenis;	state Exp;
branches;
next	1.107;
commitid	lWmV3RdleHaEaZ4U;

1.107
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.106;
commitid	Hly9lJn6CNMylcFu;

1.106
date	2015.01.27.04.49.01;	author dlg;	state Exp;
branches;
next	1.105;
commitid	lUBS8ndkmNltyaHC;

1.105
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.104;
commitid	yM2VFFhpDTeFQlve;

1.104
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.103;
commitid	LS2TNeCue5R9L67C;

1.103
date	2014.12.19.15.46.22;	author krw;	state Exp;
branches;
next	1.102;
commitid	FOcfE6Oe64xmvuV2;

1.102
date	2014.12.19.15.19.47;	author krw;	state Exp;
branches;
next	1.101;
commitid	GR2mxyBhdCxTjnoN;

1.101
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.100;
commitid	TGHgrLxu6sxZoiFt;

1.100
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.99;
commitid	OBNa5kfxQ2UXoiIw;

1.99
date	2014.03.27.11.32.29;	author daniel;	state Exp;
branches;
next	1.98;

1.98
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2013.11.14.12.41.14;	author dlg;	state Exp;
branches;
next	1.96;

1.96
date	2013.08.07.01.06.35;	author bluhm;	state Exp;
branches;
next	1.95;

1.95
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.94;

1.94
date	2010.11.15.19.11.57;	author damien;	state Exp;
branches;
next	1.93;

1.93
date	2010.09.07.16.21.45;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2010.08.27.20.09.01;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.90;

1.90
date	2010.08.12.16.59.29;	author damien;	state Exp;
branches;
next	1.89;

1.89
date	2010.08.12.15.03.59;	author oga;	state Exp;
branches;
next	1.88;

1.88
date	2010.08.03.18.26.25;	author kettenis;	state Exp;
branches;
next	1.87;

1.87
date	2010.07.28.21.21.38;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.85;

1.85
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.84;

1.84
date	2009.01.26.19.09.41;	author damien;	state Exp;
branches;
next	1.83;

1.83
date	2008.12.22.18.20.47;	author damien;	state Exp;
branches;
next	1.82;

1.82
date	2008.12.21.18.19.58;	author damien;	state Exp;
branches;
next	1.81;

1.81
date	2008.11.25.21.43.57;	author damien;	state Exp;
branches;
next	1.80;

1.80
date	2008.09.03.19.43.59;	author damien;	state Exp;
branches;
next	1.79;

1.79
date	2008.08.28.16.02.14;	author damien;	state Exp;
branches;
next	1.78;

1.78
date	2008.08.28.16.00.21;	author damien;	state Exp;
branches;
next	1.77;

1.77
date	2008.08.28.15.08.38;	author damien;	state Exp;
branches;
next	1.76;

1.76
date	2008.08.28.14.40.44;	author damien;	state Exp;
branches;
next	1.75;

1.75
date	2008.08.27.09.28.38;	author damien;	state Exp;
branches;
next	1.74;

1.74
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.73;

1.73
date	2008.07.21.18.43.18;	author damien;	state Exp;
branches;
next	1.72;

1.72
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.71;

1.71
date	2008.02.23.20.38.08;	author hshoexer;	state Exp;
branches;
next	1.70;

1.70
date	2007.11.17.19.09.16;	author damien;	state Exp;
branches;
next	1.69;

1.69
date	2007.09.07.19.05.05;	author damien;	state Exp;
branches;
next	1.68;

1.68
date	2007.08.28.18.34.38;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2007.07.18.18.10.31;	author damien;	state Exp;
branches;
next	1.66;

1.66
date	2007.01.03.18.19.06;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2006.11.26.11.14.22;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2006.10.23.18.19.26;	author damien;	state Exp;
branches;
next	1.63;

1.63
date	2006.09.18.16.20.20;	author damien;	state Exp;
branches;
next	1.62;

1.62
date	2006.08.19.14.57.37;	author damien;	state Exp;
branches;
next	1.61;

1.61
date	2006.08.19.12.03.05;	author damien;	state Exp;
branches;
next	1.60;

1.60
date	2006.08.19.11.16.55;	author damien;	state Exp;
branches;
next	1.59;

1.59
date	2006.08.18.16.04.56;	author damien;	state Exp;
branches;
next	1.58;

1.58
date	2006.06.14.18.40.23;	author brad;	state Exp;
branches;
next	1.57;

1.57
date	2006.05.17.19.54.10;	author damien;	state Exp;
branches;
next	1.56;

1.56
date	2006.03.25.22.41.45;	author djm;	state Exp;
branches;
next	1.55;

1.55
date	2006.02.26.19.14.39;	author damien;	state Exp;
branches;
next	1.54;

1.54
date	2006.01.10.17.50.28;	author damien;	state Exp;
branches;
next	1.53;

1.53
date	2006.01.04.06.04.41;	author canacar;	state Exp;
branches;
next	1.52;

1.52
date	2005.11.23.21.29.05;	author damien;	state Exp;
branches;
next	1.51;

1.51
date	2005.11.23.21.15.29;	author damien;	state Exp;
branches;
next	1.50;

1.50
date	2005.08.09.04.10.12;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2005.07.30.18.04.41;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2005.07.02.23.10.11;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2005.04.17.13.41.46;	author damien;	state Exp;
branches;
next	1.46;

1.46
date	2005.04.04.16.32.42;	author damien;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.23.14.14.30;	author damien;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.17.20.08.13;	author damien;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.12.13.23.30;	author damien;	state Exp;
branches;
next	1.42;

1.42
date	2005.02.21.13.33.29;	author damien;	state Exp;
branches;
next	1.41;

1.41
date	2005.02.19.13.08.55;	author damien;	state Exp;
branches;
next	1.40;

1.40
date	2005.02.17.18.28.05;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2005.01.13.20.52.13;	author damien;	state Exp;
branches;
next	1.38;

1.38
date	2005.01.05.09.07.16;	author jsg;	state Exp;
branches;
next	1.37;

1.37
date	2004.12.21.17.29.53;	author damien;	state Exp;
branches;
next	1.36;

1.36
date	2004.12.10.21.25.52;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2004.12.06.20.27.15;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2004.12.05.20.19.30;	author damien;	state Exp;
branches;
next	1.33;

1.33
date	2004.12.05.20.00.38;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2004.12.05.19.54.03;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2004.12.05.19.39.22;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2004.12.05.17.46.07;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.05.17.13.52;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2004.11.24.21.27.50;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2004.11.24.20.50.55;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2004.11.20.16.28.31;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2004.11.18.21.02.42;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2004.11.03.17.14.31;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2004.11.03.17.12.28;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.03.17.11.14;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.03.17.10.03;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.03.17.07.10;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.02.06.06.21;	author marius;	state Exp;
branches;
next	1.18;

1.18
date	2004.10.28.23.06.10;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2004.10.28.17.05.41;	author jcs;	state Exp;
branches;
next	1.16;

1.16
date	2004.10.27.21.24.49;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.27.21.23.45;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.27.21.23.01;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2004.10.27.21.22.14;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2004.10.27.21.21.16;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.27.21.20.30;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.27.21.19.43;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.27.21.19.01;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.27.21.17.18;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.27.21.16.45;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.27.21.15.17;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.27.21.14.48;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2004.10.27.21.14.03;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2004.10.27.21.12.08;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2004.10.27.21.10.22;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2004.10.20.12.50.48;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.120
log
@Do not clear IFF_UP, even in the error path, clearing IFF_RUNNING
is enough.

This flag should only be set by the stack, drivers shouldn't mess
with it.

Discussed with dlg@@ and mikeb@@, ok mikeb@@, stsp@@
@
text
@/*	$OpenBSD: if_ipw.c,v 1.119 2017/01/22 10:17:38 dlg Exp $	*/

/*-
 * Copyright (c) 2004-2008
 *      Damien Bergamini <damien.bergamini@@free.fr>. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Driver for Intel PRO/Wireless 2100 802.11 network adapters.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/task.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/rwlock.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/pci/if_ipwreg.h>
#include <dev/pci/if_ipwvar.h>

int		ipw_match(struct device *, void *, void *);
void		ipw_attach(struct device *, struct device *, void *);
int		ipw_activate(struct device *, int);
void		ipw_wakeup(struct ipw_softc *);
int		ipw_dma_alloc(struct ipw_softc *);
void		ipw_release(struct ipw_softc *);
int		ipw_media_change(struct ifnet *);
void		ipw_media_status(struct ifnet *, struct ifmediareq *);
int		ipw_newstate(struct ieee80211com *, enum ieee80211_state, int);
uint16_t	ipw_read_prom_word(struct ipw_softc *, uint8_t);
void		ipw_command_intr(struct ipw_softc *, struct ipw_soft_buf *);
void		ipw_newstate_intr(struct ipw_softc *, struct ipw_soft_buf *);
void		ipw_data_intr(struct ipw_softc *, struct ipw_status *,
		    struct ipw_soft_bd *, struct ipw_soft_buf *);
void		ipw_notification_intr(struct ipw_softc *,
		    struct ipw_soft_buf *);
void		ipw_rx_intr(struct ipw_softc *);
void		ipw_release_sbd(struct ipw_softc *, struct ipw_soft_bd *);
void		ipw_tx_intr(struct ipw_softc *);
int		ipw_intr(void *);
int		ipw_cmd(struct ipw_softc *, uint32_t, void *, uint32_t);
int		ipw_send_mgmt(struct ieee80211com *, struct ieee80211_node *,
		    int, int, int);
int		ipw_tx_start(struct ifnet *, struct mbuf *,
		    struct ieee80211_node *);
void		ipw_start(struct ifnet *);
void		ipw_watchdog(struct ifnet *);
int		ipw_ioctl(struct ifnet *, u_long, caddr_t);
uint32_t	ipw_read_table1(struct ipw_softc *, uint32_t);
void		ipw_write_table1(struct ipw_softc *, uint32_t, uint32_t);
int		ipw_read_table2(struct ipw_softc *, uint32_t, void *,
		    uint32_t *);
void		ipw_stop_master(struct ipw_softc *);
int		ipw_reset(struct ipw_softc *);
int		ipw_load_ucode(struct ipw_softc *, u_char *, int);
int		ipw_load_firmware(struct ipw_softc *, u_char *, int);
int		ipw_read_firmware(struct ipw_softc *, struct ipw_firmware *);
void		ipw_scan(void *);
void		ipw_auth_and_assoc(void *);
int		ipw_config(struct ipw_softc *);
int		ipw_init(struct ifnet *);
void		ipw_stop(struct ifnet *, int);
void		ipw_read_mem_1(struct ipw_softc *, bus_size_t, uint8_t *,
		    bus_size_t);
void		ipw_write_mem_1(struct ipw_softc *, bus_size_t, uint8_t *,
		    bus_size_t);

static __inline uint8_t
MEM_READ_1(struct ipw_softc *sc, uint32_t addr)
{
	CSR_WRITE_4(sc, IPW_CSR_INDIRECT_ADDR, addr);
	return CSR_READ_1(sc, IPW_CSR_INDIRECT_DATA);
}

static __inline uint32_t
MEM_READ_4(struct ipw_softc *sc, uint32_t addr)
{
	CSR_WRITE_4(sc, IPW_CSR_INDIRECT_ADDR, addr);
	return CSR_READ_4(sc, IPW_CSR_INDIRECT_DATA);
}

#ifdef IPW_DEBUG
#define DPRINTF(x)	do { if (ipw_debug > 0) printf x; } while (0)
#define DPRINTFN(n, x)	do { if (ipw_debug >= (n)) printf x; } while (0)
int ipw_debug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n, x)
#endif

struct cfattach ipw_ca = {
	sizeof (struct ipw_softc), ipw_match, ipw_attach, NULL,
	ipw_activate
};

int
ipw_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR (pa->pa_id) == PCI_VENDOR_INTEL &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_PRO_WL_2100)
		return 1;

	return 0;
}

/* Base Address Register */
#define IPW_PCI_BAR0	0x10

void
ipw_attach(struct device *parent, struct device *self, void *aux)
{
	struct ipw_softc *sc = (struct ipw_softc *)self;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct pci_attach_args *pa = aux;
	const char *intrstr;
	bus_space_tag_t memt;
	bus_space_handle_t memh;
	bus_addr_t base;
	pci_intr_handle_t ih;
	pcireg_t data;
	uint16_t val;
	int error, i;

	sc->sc_pct = pa->pa_pc;
	sc->sc_pcitag = pa->pa_tag,

	/* clear device specific PCI configuration register 0x41 */
	data = pci_conf_read(sc->sc_pct, sc->sc_pcitag, 0x40);
	data &= ~0x0000ff00;
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0x40, data);

	/* map the register window */
	error = pci_mapreg_map(pa, IPW_PCI_BAR0, PCI_MAPREG_TYPE_MEM |
	    PCI_MAPREG_MEM_TYPE_32BIT, 0, &memt, &memh, &base, &sc->sc_sz, 0);
	if (error != 0) {
		printf(": can't map mem space\n");
		return;
	}

	sc->sc_st = memt;
	sc->sc_sh = memh;
	sc->sc_dmat = pa->pa_dmat;

	/* disable interrupts */
	CSR_WRITE_4(sc, IPW_CSR_INTR_MASK, 0);

	if (pci_intr_map(pa, &ih) != 0) {
		printf(": can't map interrupt\n");
		return;
	}

	intrstr = pci_intr_string(sc->sc_pct, ih);
	sc->sc_ih = pci_intr_establish(sc->sc_pct, ih, IPL_NET, ipw_intr, sc,
	    sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": can't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s", intrstr);

	rw_init(&sc->sc_rwlock, "ipwlock");
	task_set(&sc->sc_scantask, ipw_scan, sc);
	task_set(&sc->sc_authandassoctask, ipw_auth_and_assoc, sc);

	if (ipw_reset(sc) != 0) {
		printf(": could not reset adapter\n");
		return;
	}

	if (ipw_dma_alloc(sc) != 0) {
		printf(": failed to allocate DMA resources\n");
		return;
	}

	ic->ic_phytype = IEEE80211_T_DS;
	ic->ic_opmode = IEEE80211_M_STA;	/* default to BSS mode */
	ic->ic_state = IEEE80211_S_INIT;

	/* set device capabilities */
	ic->ic_caps =
#ifndef IEEE80211_STA_ONLY
	    IEEE80211_C_IBSS |		/* IBSS mode supported */
#endif
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
	    IEEE80211_C_TXPMGT |	/* tx power management */
	    IEEE80211_C_SHPREAMBLE |	/* short preamble supported */
	    IEEE80211_C_WEP |		/* s/w WEP */
	    IEEE80211_C_RSN |		/* WPA/RSN */
	    IEEE80211_C_SCANALL;	/* h/w scanning */

	/* read MAC address from EEPROM */
	val = ipw_read_prom_word(sc, IPW_EEPROM_MAC + 0);
	ic->ic_myaddr[0] = val >> 8;
	ic->ic_myaddr[1] = val & 0xff;
	val = ipw_read_prom_word(sc, IPW_EEPROM_MAC + 1);
	ic->ic_myaddr[2] = val >> 8;
	ic->ic_myaddr[3] = val & 0xff;
	val = ipw_read_prom_word(sc, IPW_EEPROM_MAC + 2);
	ic->ic_myaddr[4] = val >> 8;
	ic->ic_myaddr[5] = val & 0xff;

	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));

	/* set supported .11b rates */
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;

	/* set supported .11b channels (1 through 14) */
	for (i = 1; i <= 14; i++) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_B);
		ic->ic_channels[i].ic_flags = IEEE80211_CHAN_B;
	}

	/* IBSS channel undefined for now */
	ic->ic_ibss_chan = &ic->ic_channels[0];

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = ipw_ioctl;
	ifp->if_start = ipw_start;
	ifp->if_watchdog = ipw_watchdog;
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);

	if_attach(ifp);
	ieee80211_ifattach(ifp);
	/* override state transition machine */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = ipw_newstate;
	ic->ic_send_mgmt = ipw_send_mgmt;
	ieee80211_media_init(ifp, ipw_media_change, ipw_media_status);

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof (struct ieee80211_frame) + IEEE80211_RADIOTAP_HDRLEN);

	sc->sc_rxtap_len = sizeof sc->sc_rxtapu;
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(IPW_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof sc->sc_txtapu;
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(IPW_TX_RADIOTAP_PRESENT);
#endif
}

int
ipw_activate(struct device *self, int act)
{
	struct ipw_softc *sc = (struct ipw_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			ipw_stop(ifp, 0);
		break;
	case DVACT_WAKEUP:
		ipw_wakeup(sc);
		break;
	}

	return 0;
}

void
ipw_wakeup(struct ipw_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	pcireg_t data;
	int s;

	/* clear device specific PCI configuration register 0x41 */
	data = pci_conf_read(sc->sc_pct, sc->sc_pcitag, 0x40);
	data &= ~0x0000ff00;
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0x40, data);

	rw_enter_write(&sc->sc_rwlock);
	s = splnet();

	if (ifp->if_flags & IFF_UP)
		ipw_init(ifp);

	splx(s);
	rw_exit_write(&sc->sc_rwlock);
}

int
ipw_dma_alloc(struct ipw_softc *sc)
{
	struct ipw_soft_bd *sbd;
	struct ipw_soft_hdr *shdr;
	struct ipw_soft_buf *sbuf;
	int i, nsegs, error;

	/*
	 * Allocate and map tx ring.
	 */
	error = bus_dmamap_create(sc->sc_dmat, IPW_TBD_SZ, 1, IPW_TBD_SZ, 0,
	    BUS_DMA_NOWAIT, &sc->tbd_map);
	if (error != 0) {
		printf("%s: could not create tx ring DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat, IPW_TBD_SZ, PAGE_SIZE, 0,
	    &sc->tbd_seg, 1, &nsegs, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not allocate tx ring DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &sc->tbd_seg, nsegs, IPW_TBD_SZ,
	    (caddr_t *)&sc->tbd_list, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map tx ring DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, sc->tbd_map, sc->tbd_list,
	    IPW_TBD_SZ, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load tx ring DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/*
	 * Allocate and map rx ring.
	 */
	error = bus_dmamap_create(sc->sc_dmat, IPW_RBD_SZ, 1, IPW_RBD_SZ, 0,
	    BUS_DMA_NOWAIT, &sc->rbd_map);
	if (error != 0) {
		printf("%s: could not create rx ring DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat, IPW_RBD_SZ, PAGE_SIZE, 0,
	    &sc->rbd_seg, 1, &nsegs, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not allocate rx ring DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &sc->rbd_seg, nsegs, IPW_RBD_SZ,
	    (caddr_t *)&sc->rbd_list, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map rx ring DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, sc->rbd_map, sc->rbd_list,
	    IPW_RBD_SZ, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load tx ring DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/*
	 * Allocate and map status ring.
	 */
	error = bus_dmamap_create(sc->sc_dmat, IPW_STATUS_SZ, 1, IPW_STATUS_SZ,
	    0, BUS_DMA_NOWAIT, &sc->status_map);
	if (error != 0) {
		printf("%s: could not create status ring DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat, IPW_STATUS_SZ, PAGE_SIZE, 0,
	    &sc->status_seg, 1, &nsegs, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not allocate status ring DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &sc->status_seg, nsegs,
	    IPW_STATUS_SZ, (caddr_t *)&sc->status_list, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map status ring DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, sc->status_map, sc->status_list,
	    IPW_STATUS_SZ, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load status ring DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/*
	 * Allocate command DMA map.
	 */
	error = bus_dmamap_create(sc->sc_dmat, sizeof (struct ipw_cmd), 1,
	    sizeof (struct ipw_cmd), 0, BUS_DMA_NOWAIT, &sc->cmd_map);
	if (error != 0) {
		printf("%s: could not create command DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/*
	 * Allocate headers DMA maps.
	 */
	SLIST_INIT(&sc->free_shdr);
	for (i = 0; i < IPW_NDATA; i++) {
		shdr = &sc->shdr_list[i];
		error = bus_dmamap_create(sc->sc_dmat, sizeof (struct ipw_hdr),
		    1, sizeof (struct ipw_hdr), 0, BUS_DMA_NOWAIT, &shdr->map);
		if (error != 0) {
			printf("%s: could not create header DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
		SLIST_INSERT_HEAD(&sc->free_shdr, shdr, next);
	}

	/*
	 * Allocate tx buffers DMA maps.
	 */
	SLIST_INIT(&sc->free_sbuf);
	for (i = 0; i < IPW_NDATA; i++) {
		sbuf = &sc->tx_sbuf_list[i];
		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, IPW_MAX_NSEG,
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &sbuf->map);
		if (error != 0) {
			printf("%s: could not create tx DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
		SLIST_INSERT_HEAD(&sc->free_sbuf, sbuf, next);
	}

	/*
	 * Initialize tx ring.
	 */
	for (i = 0; i < IPW_NTBD; i++) {
		sbd = &sc->stbd_list[i];
		sbd->bd = &sc->tbd_list[i];
		sbd->type = IPW_SBD_TYPE_NOASSOC;
	}

	/*
	 * Pre-allocate rx buffers and DMA maps.
	 */
	for (i = 0; i < IPW_NRBD; i++) {
		sbd = &sc->srbd_list[i];
		sbuf = &sc->rx_sbuf_list[i];
		sbd->bd = &sc->rbd_list[i];

		MGETHDR(sbuf->m, M_DONTWAIT, MT_DATA);
		if (sbuf->m == NULL) {
			printf("%s: could not allocate rx mbuf\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		MCLGET(sbuf->m, M_DONTWAIT);
		if (!(sbuf->m->m_flags & M_EXT)) {
			m_freem(sbuf->m);
			printf("%s: could not allocate rx mbuf cluster\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT, &sbuf->map);
		if (error != 0) {
			printf("%s: could not create rx DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		error = bus_dmamap_load(sc->sc_dmat, sbuf->map,
		    mtod(sbuf->m, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
		if (error != 0) {
			printf("%s: can't map rx DMA memory\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		sbd->type = IPW_SBD_TYPE_DATA;
		sbd->priv = sbuf;
		sbd->bd->physaddr = htole32(sbuf->map->dm_segs[0].ds_addr);
		sbd->bd->len = htole32(MCLBYTES);
	}

	bus_dmamap_sync(sc->sc_dmat, sc->rbd_map, 0, IPW_RBD_SZ,
	    BUS_DMASYNC_PREWRITE);

	return 0;

fail:	ipw_release(sc);
	return error;
}

void
ipw_release(struct ipw_softc *sc)
{
	struct ipw_soft_buf *sbuf;
	int i;

	if (sc->tbd_map != NULL) {
		if (sc->tbd_list != NULL) {
			bus_dmamap_unload(sc->sc_dmat, sc->tbd_map);
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->tbd_list,
			    IPW_TBD_SZ);
			bus_dmamem_free(sc->sc_dmat, &sc->tbd_seg, 1);
		}
		bus_dmamap_destroy(sc->sc_dmat, sc->tbd_map);
	}

	if (sc->rbd_map != NULL) {
		if (sc->rbd_list != NULL) {
			bus_dmamap_unload(sc->sc_dmat, sc->rbd_map);
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->rbd_list,
			    IPW_RBD_SZ);
			bus_dmamem_free(sc->sc_dmat, &sc->rbd_seg, 1);
		}
		bus_dmamap_destroy(sc->sc_dmat, sc->rbd_map);
	}

	if (sc->status_map != NULL) {
		if (sc->status_list != NULL) {
			bus_dmamap_unload(sc->sc_dmat, sc->status_map);
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->status_list,
			    IPW_RBD_SZ);
			bus_dmamem_free(sc->sc_dmat, &sc->status_seg, 1);
		}
		bus_dmamap_destroy(sc->sc_dmat, sc->status_map);
	}

	if (sc->cmd_map != NULL)
		bus_dmamap_destroy(sc->sc_dmat, sc->cmd_map);

	for (i = 0; i < IPW_NDATA; i++)
		bus_dmamap_destroy(sc->sc_dmat, sc->shdr_list[i].map);

	for (i = 0; i < IPW_NDATA; i++)
		bus_dmamap_destroy(sc->sc_dmat, sc->tx_sbuf_list[i].map);

	for (i = 0; i < IPW_NRBD; i++) {
		sbuf = &sc->rx_sbuf_list[i];
		if (sbuf->map != NULL) {
			if (sbuf->m != NULL) {
				bus_dmamap_unload(sc->sc_dmat, sbuf->map);
				m_freem(sbuf->m);
			}
			bus_dmamap_destroy(sc->sc_dmat, sbuf->map);
		}
	}

	task_del(systq, &sc->sc_scantask);
	task_del(systq, &sc->sc_authandassoctask);
}

int
ipw_media_change(struct ifnet *ifp)
{
	int error;

	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return error;

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING))
		ipw_init(ifp);

	return 0;
}

void
ipw_media_status(struct ifnet *ifp, struct ifmediareq *imr)
{
	struct ipw_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	static const struct {
		uint32_t	val;
		int		rate;
	} rates[] = {
		{ IPW_RATE_DS1,   2 },
		{ IPW_RATE_DS2,   4 },
		{ IPW_RATE_DS5,  11 },
		{ IPW_RATE_DS11, 22 },
	};
	uint32_t val;
	int rate, i;

	imr->ifm_status = IFM_AVALID;
	imr->ifm_active = IFM_IEEE80211;
	if (ic->ic_state == IEEE80211_S_RUN)
		imr->ifm_status |= IFM_ACTIVE;

	/* read current transmission rate from adapter */
	val = ipw_read_table1(sc, IPW_INFO_CURRENT_TX_RATE);
	val &= 0xf;

	/* convert rate to 802.11 rate */
	for (i = 0; i < nitems(rates) && rates[i].val != val; i++);
	rate = (i < nitems(rates)) ? rates[i].rate : 0;

	imr->ifm_active |= IFM_IEEE80211_11B;
	imr->ifm_active |= ieee80211_rate2media(ic, rate, IEEE80211_MODE_11B);
	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_IBSS:
		imr->ifm_active |= IFM_IEEE80211_IBSS;
		break;
#endif
	case IEEE80211_M_MONITOR:
		imr->ifm_active |= IFM_IEEE80211_MONITOR;
		break;
	default:
		/* should not get there */
		break;
	}
}

int
ipw_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct ipw_softc *sc = ic->ic_softc;

	switch (nstate) {
	case IEEE80211_S_SCAN:
		task_add(systq, &sc->sc_scantask);
		break;

	case IEEE80211_S_AUTH:
		task_add(systq, &sc->sc_authandassoctask);
		break;

	case IEEE80211_S_RUN:
	case IEEE80211_S_INIT:
	case IEEE80211_S_ASSOC:
		/* nothing to do */
		break;
	}

	ic->ic_state = nstate;
	return 0;
}

/*
 * Read 16 bits at address 'addr' from the Microwire EEPROM.
 * DON'T PLAY WITH THIS CODE UNLESS YOU KNOW *EXACTLY* WHAT YOU'RE DOING!
 */
uint16_t
ipw_read_prom_word(struct ipw_softc *sc, uint8_t addr)
{
	uint32_t tmp;
	uint16_t val;
	int n;

	/* clock C once before the first command */
	IPW_EEPROM_CTL(sc, 0);
	IPW_EEPROM_CTL(sc, IPW_EEPROM_S);
	IPW_EEPROM_CTL(sc, IPW_EEPROM_S | IPW_EEPROM_C);
	IPW_EEPROM_CTL(sc, IPW_EEPROM_S);

	/* write start bit (1) */
	IPW_EEPROM_CTL(sc, IPW_EEPROM_S | IPW_EEPROM_D);
	IPW_EEPROM_CTL(sc, IPW_EEPROM_S | IPW_EEPROM_D | IPW_EEPROM_C);

	/* write READ opcode (10) */
	IPW_EEPROM_CTL(sc, IPW_EEPROM_S | IPW_EEPROM_D);
	IPW_EEPROM_CTL(sc, IPW_EEPROM_S | IPW_EEPROM_D | IPW_EEPROM_C);
	IPW_EEPROM_CTL(sc, IPW_EEPROM_S);
	IPW_EEPROM_CTL(sc, IPW_EEPROM_S | IPW_EEPROM_C);

	/* write address A7-A0 */
	for (n = 7; n >= 0; n--) {
		IPW_EEPROM_CTL(sc, IPW_EEPROM_S |
		    (((addr >> n) & 1) << IPW_EEPROM_SHIFT_D));
		IPW_EEPROM_CTL(sc, IPW_EEPROM_S |
		    (((addr >> n) & 1) << IPW_EEPROM_SHIFT_D) | IPW_EEPROM_C);
	}

	IPW_EEPROM_CTL(sc, IPW_EEPROM_S);

	/* read data Q15-Q0 */
	val = 0;
	for (n = 15; n >= 0; n--) {
		IPW_EEPROM_CTL(sc, IPW_EEPROM_S | IPW_EEPROM_C);
		IPW_EEPROM_CTL(sc, IPW_EEPROM_S);
		tmp = MEM_READ_4(sc, IPW_MEM_EEPROM_CTL);
		val |= ((tmp & IPW_EEPROM_Q) >> IPW_EEPROM_SHIFT_Q) << n;
	}

	IPW_EEPROM_CTL(sc, 0);

	/* clear Chip Select and clock C */
	IPW_EEPROM_CTL(sc, IPW_EEPROM_S);
	IPW_EEPROM_CTL(sc, 0);
	IPW_EEPROM_CTL(sc, IPW_EEPROM_C);

	return val;
}

void
ipw_command_intr(struct ipw_softc *sc, struct ipw_soft_buf *sbuf)
{
	struct ipw_cmd *cmd;

	bus_dmamap_sync(sc->sc_dmat, sbuf->map, 0, sizeof (struct ipw_cmd),
	    BUS_DMASYNC_POSTREAD);

	cmd = mtod(sbuf->m, struct ipw_cmd *);

	DPRINTFN(2, ("received command ack type=%u,status=%u\n",
	    letoh32(cmd->type), letoh32(cmd->status)));

	wakeup(&sc->cmd);
}

void
ipw_newstate_intr(struct ipw_softc *sc, struct ipw_soft_buf *sbuf)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	uint32_t state;

	bus_dmamap_sync(sc->sc_dmat, sbuf->map, 0, sizeof state,
	    BUS_DMASYNC_POSTREAD);

	state = letoh32(*mtod(sbuf->m, uint32_t *));

	DPRINTFN(2, ("firmware state changed to 0x%x\n", state));

	switch (state) {
	case IPW_STATE_ASSOCIATED:
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
		break;

	case IPW_STATE_SCANNING:
		if (ic->ic_state == IEEE80211_S_RUN)
			ieee80211_begin_scan(ifp);
		break;

	case IPW_STATE_SCAN_COMPLETE:
		if (ic->ic_state == IEEE80211_S_SCAN)
			ieee80211_end_scan(ifp);
		break;

	case IPW_STATE_ASSOCIATION_LOST:
		ieee80211_new_state(ic, IEEE80211_S_INIT, -1);
		break;

	case IPW_STATE_DISABLED:
		wakeup(sc);
		break;

	case IPW_STATE_RADIO_DISABLED:
		ipw_stop(&ic->ic_if, 1);
		break;
	}
}

void
ipw_data_intr(struct ipw_softc *sc, struct ipw_status *status,
    struct ipw_soft_bd *sbd, struct ipw_soft_buf *sbuf)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct mbuf *mnew, *m;
	struct ieee80211_frame *wh;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	int error;

	DPRINTFN(5, ("received data frame len=%u,rssi=%u\n",
	    letoh32(status->len), status->rssi));

	/*
	 * Try to allocate a new mbuf for this ring element and load it before
	 * processing the current mbuf.  If the ring element cannot be loaded,
	 * drop the received packet and reuse the old mbuf.  In the unlikely
	 * case that the old mbuf can't be reloaded either, explicitly panic.
	 */
	MGETHDR(mnew, M_DONTWAIT, MT_DATA);
	if (mnew == NULL) {
		ifp->if_ierrors++;
		return;
	}
	MCLGET(mnew, M_DONTWAIT);
	if (!(mnew->m_flags & M_EXT)) {
		m_freem(mnew);
		ifp->if_ierrors++;
		return;
	}

	bus_dmamap_sync(sc->sc_dmat, sbuf->map, 0, letoh32(status->len),
	    BUS_DMASYNC_POSTREAD);
	bus_dmamap_unload(sc->sc_dmat, sbuf->map);

	error = bus_dmamap_load(sc->sc_dmat, sbuf->map, mtod(mnew, void *),
	    MCLBYTES, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		m_freem(mnew);

		/* try to reload the old mbuf */
		error = bus_dmamap_load(sc->sc_dmat, sbuf->map,
		    mtod(sbuf->m, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
		if (error != 0) {
			/* very unlikely that it will fail... */
			panic("%s: could not load old rx mbuf",
			    sc->sc_dev.dv_xname);
		}
		sbd->bd->physaddr = htole32(sbuf->map->dm_segs[0].ds_addr);
		ifp->if_ierrors++;
		return;
	}

	m = sbuf->m;
	sbuf->m = mnew;	
	sbd->bd->physaddr = htole32(sbuf->map->dm_segs[0].ds_addr);

	/* finalize mbuf */
	m->m_pkthdr.len = m->m_len = letoh32(status->len);

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct ipw_rx_radiotap_header *tap = &sc->sc_rxtap;

		tap->wr_flags = 0;
		tap->wr_antsignal = status->rssi;
		tap->wr_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wr_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_rxtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
	}
#endif

	wh = mtod(m, struct ieee80211_frame *);
	ni = ieee80211_find_rxnode(ic, wh);

	/* send the frame to the upper layer */
	rxi.rxi_flags = 0;
	rxi.rxi_rssi = status->rssi;
	rxi.rxi_tstamp = 0;	/* unused */
	ieee80211_input(ifp, m, ni, &rxi);

	ieee80211_release_node(ic, ni);
}

void
ipw_notification_intr(struct ipw_softc *sc, struct ipw_soft_buf *sbuf)
{
	DPRINTFN(2, ("received notification\n"));
}

void
ipw_rx_intr(struct ipw_softc *sc)
{
	struct ipw_status *status;
	struct ipw_soft_bd *sbd;
	struct ipw_soft_buf *sbuf;
	uint32_t r, i;

	r = CSR_READ_4(sc, IPW_CSR_RX_READ_INDEX);

	for (i = (sc->rxcur + 1) % IPW_NRBD; i != r; i = (i + 1) % IPW_NRBD) {

		bus_dmamap_sync(sc->sc_dmat, sc->rbd_map,
		    i * sizeof (struct ipw_bd), sizeof (struct ipw_bd),
		    BUS_DMASYNC_POSTREAD);

		bus_dmamap_sync(sc->sc_dmat, sc->status_map,
		    i * sizeof (struct ipw_status), sizeof (struct ipw_status),
		    BUS_DMASYNC_POSTREAD);

		status = &sc->status_list[i];
		sbd = &sc->srbd_list[i];
		sbuf = sbd->priv;

		switch (letoh16(status->code) & 0xf) {
		case IPW_STATUS_CODE_COMMAND:
			ipw_command_intr(sc, sbuf);
			break;

		case IPW_STATUS_CODE_NEWSTATE:
			ipw_newstate_intr(sc, sbuf);
			break;

		case IPW_STATUS_CODE_DATA_802_3:
		case IPW_STATUS_CODE_DATA_802_11:
			ipw_data_intr(sc, status, sbd, sbuf);
			break;

		case IPW_STATUS_CODE_NOTIFICATION:
			ipw_notification_intr(sc, sbuf);
			break;

		default:
			printf("%s: unknown status code %u\n",
			    sc->sc_dev.dv_xname, letoh16(status->code));
		}
		sbd->bd->flags = 0;

		bus_dmamap_sync(sc->sc_dmat, sc->rbd_map,
		    i * sizeof (struct ipw_bd), sizeof (struct ipw_bd),
		    BUS_DMASYNC_PREWRITE);
	}

	/* tell the firmware what we have processed */
	sc->rxcur = (r == 0) ? IPW_NRBD - 1 : r - 1;
	CSR_WRITE_4(sc, IPW_CSR_RX_WRITE_INDEX, sc->rxcur);
}

void
ipw_release_sbd(struct ipw_softc *sc, struct ipw_soft_bd *sbd)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ipw_soft_hdr *shdr;
	struct ipw_soft_buf *sbuf;

	switch (sbd->type) {
	case IPW_SBD_TYPE_COMMAND:
		bus_dmamap_unload(sc->sc_dmat, sc->cmd_map);
		break;

	case IPW_SBD_TYPE_HEADER:
		shdr = sbd->priv;
		bus_dmamap_unload(sc->sc_dmat, shdr->map);
		SLIST_INSERT_HEAD(&sc->free_shdr, shdr, next);
		break;

	case IPW_SBD_TYPE_DATA:
		sbuf = sbd->priv;
		bus_dmamap_unload(sc->sc_dmat, sbuf->map);
		SLIST_INSERT_HEAD(&sc->free_sbuf, sbuf, next);

		m_freem(sbuf->m);

		if (sbuf->ni != NULL)
			ieee80211_release_node(ic, sbuf->ni);

		/* kill watchdog timer */
		sc->sc_tx_timer = 0;
		break;
	}
	sbd->type = IPW_SBD_TYPE_NOASSOC;
}

void
ipw_tx_intr(struct ipw_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	struct ipw_soft_bd *sbd;
	uint32_t r, i;

	r = CSR_READ_4(sc, IPW_CSR_TX_READ_INDEX);

	for (i = (sc->txold + 1) % IPW_NTBD; i != r; i = (i + 1) % IPW_NTBD) {
		sbd = &sc->stbd_list[i];

		ipw_release_sbd(sc, sbd);
		sc->txfree++;
	}

	/* remember what the firmware has processed */
	sc->txold = (r == 0) ? IPW_NTBD - 1 : r - 1;

	/* call start() since some buffer descriptors have been released */
	ifq_clr_oactive(&ifp->if_snd);
	(*ifp->if_start)(ifp);
}

int
ipw_intr(void *arg)
{
	struct ipw_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	uint32_t r;

	if ((r = CSR_READ_4(sc, IPW_CSR_INTR)) == 0 || r == 0xffffffff)
		return 0;

	/* disable interrupts */
	CSR_WRITE_4(sc, IPW_CSR_INTR_MASK, 0);

	if (r & (IPW_INTR_FATAL_ERROR | IPW_INTR_PARITY_ERROR)) {
		printf("%s: fatal firmware error\n", sc->sc_dev.dv_xname);
		ipw_stop(ifp, 1);
		return 1;
	}

	if (r & IPW_INTR_FW_INIT_DONE)
		wakeup(sc);

	if (r & IPW_INTR_RX_TRANSFER)
		ipw_rx_intr(sc);

	if (r & IPW_INTR_TX_TRANSFER)
		ipw_tx_intr(sc);

	/* acknowledge interrupts */
	CSR_WRITE_4(sc, IPW_CSR_INTR, r);

	/* re-enable interrupts */
	CSR_WRITE_4(sc, IPW_CSR_INTR_MASK, IPW_INTR_MASK);

	return 1;
}

int
ipw_cmd(struct ipw_softc *sc, uint32_t type, void *data, uint32_t len)
{
	struct ipw_soft_bd *sbd;
	int s, error;

	s = splnet();

	sc->cmd.type = htole32(type);
	sc->cmd.subtype = htole32(0);
	sc->cmd.len = htole32(len);
	sc->cmd.seq = htole32(0);
	if (data != NULL)
		bcopy(data, sc->cmd.data, len);

	error = bus_dmamap_load(sc->sc_dmat, sc->cmd_map, &sc->cmd,
	    sizeof (struct ipw_cmd), NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map command DMA memory\n",
		    sc->sc_dev.dv_xname);
		splx(s);
		return error;
	}

	sbd = &sc->stbd_list[sc->txcur];
	sbd->type = IPW_SBD_TYPE_COMMAND;
	sbd->bd->physaddr = htole32(sc->cmd_map->dm_segs[0].ds_addr);
	sbd->bd->len = htole32(sizeof (struct ipw_cmd));
	sbd->bd->nfrag = 1;
	sbd->bd->flags = IPW_BD_FLAG_TX_FRAME_COMMAND |
	    IPW_BD_FLAG_TX_LAST_FRAGMENT;

	bus_dmamap_sync(sc->sc_dmat, sc->cmd_map, 0, sizeof (struct ipw_cmd),
	    BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, sc->tbd_map,
	    sc->txcur * sizeof (struct ipw_bd), sizeof (struct ipw_bd),
	    BUS_DMASYNC_PREWRITE);

	sc->txcur = (sc->txcur + 1) % IPW_NTBD;
	sc->txfree--;
	CSR_WRITE_4(sc, IPW_CSR_TX_WRITE_INDEX, sc->txcur);

	DPRINTFN(2, ("sending command type=%u,len=%u\n", type, len));

	/* wait at most one second for command to complete */
	error = tsleep(&sc->cmd, 0, "ipwcmd", hz);
	splx(s);

	return error;
}

/* ARGSUSED */
int
ipw_send_mgmt(struct ieee80211com *ic, struct ieee80211_node *ni, int type,
    int arg1, int arg2)
{
	return EOPNOTSUPP;
}

int
ipw_tx_start(struct ifnet *ifp, struct mbuf *m, struct ieee80211_node *ni)
{
	struct ipw_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k;
	struct ipw_soft_bd *sbd;
	struct ipw_soft_hdr *shdr;
	struct ipw_soft_buf *sbuf;
	int error, i;

	wh = mtod(m, struct ieee80211_frame *);

	if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
		k = ieee80211_get_txkey(ic, wh, ni);

		if ((m = ieee80211_encrypt(ic, m, k)) == NULL)
			return ENOBUFS;

		/* packet header may have moved, reset our local pointer */
		wh = mtod(m, struct ieee80211_frame *);
	}

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct ipw_tx_radiotap_header *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	shdr = SLIST_FIRST(&sc->free_shdr);
	sbuf = SLIST_FIRST(&sc->free_sbuf);

	shdr->hdr.type = htole32(IPW_HDR_TYPE_SEND);
	shdr->hdr.subtype = htole32(0);
	shdr->hdr.encrypted = (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) ? 1 : 0;
	shdr->hdr.encrypt = 0;
	shdr->hdr.keyidx = 0;
	shdr->hdr.keysz = 0;
	shdr->hdr.fragmentsz = htole16(0);
	IEEE80211_ADDR_COPY(shdr->hdr.src_addr, wh->i_addr2);
	if (ic->ic_opmode == IEEE80211_M_STA)
		IEEE80211_ADDR_COPY(shdr->hdr.dst_addr, wh->i_addr3);
	else
		IEEE80211_ADDR_COPY(shdr->hdr.dst_addr, wh->i_addr1);

	/* trim IEEE802.11 header */
	m_adj(m, sizeof (struct ieee80211_frame));

	error = bus_dmamap_load_mbuf(sc->sc_dmat, sbuf->map, m, BUS_DMA_NOWAIT);
	if (error != 0 && error != EFBIG) {
		printf("%s: can't map mbuf (error %d)\n",
		    sc->sc_dev.dv_xname, error);
		m_freem(m);
		return error;
	}
	if (error != 0) {
		/* too many fragments, linearize */
		if (m_defrag(m, M_DONTWAIT)) {
			m_freem(m);
			return ENOBUFS;
		}
		error = bus_dmamap_load_mbuf(sc->sc_dmat, sbuf->map, m,
		    BUS_DMA_NOWAIT);
		if (error != 0) {
			printf("%s: can't map mbuf (error %d)\n",
			    sc->sc_dev.dv_xname, error);
			m_freem(m);
			return error;
		}
	}

	error = bus_dmamap_load(sc->sc_dmat, shdr->map, &shdr->hdr,
	    sizeof (struct ipw_hdr), NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can't map header DMA memory (error %d)\n",
		    sc->sc_dev.dv_xname, error);
		bus_dmamap_unload(sc->sc_dmat, sbuf->map);
		m_freem(m);
		return error;
	}

	SLIST_REMOVE_HEAD(&sc->free_sbuf, next);
	SLIST_REMOVE_HEAD(&sc->free_shdr, next);

	sbd = &sc->stbd_list[sc->txcur];
	sbd->type = IPW_SBD_TYPE_HEADER;
	sbd->priv = shdr;
	sbd->bd->physaddr = htole32(shdr->map->dm_segs[0].ds_addr);
	sbd->bd->len = htole32(sizeof (struct ipw_hdr));
	sbd->bd->nfrag = 1 + sbuf->map->dm_nsegs;
	sbd->bd->flags = IPW_BD_FLAG_TX_FRAME_802_3 |
	    IPW_BD_FLAG_TX_NOT_LAST_FRAGMENT;

	bus_dmamap_sync(sc->sc_dmat, sc->tbd_map,
	    sc->txcur * sizeof (struct ipw_bd),
	    sizeof (struct ipw_bd), BUS_DMASYNC_PREWRITE);

	sc->txcur = (sc->txcur + 1) % IPW_NTBD;
	sc->txfree--;

	sbuf->m = m;
	sbuf->ni = ni;

	for (i = 0; i < sbuf->map->dm_nsegs; i++) {
		sbd = &sc->stbd_list[sc->txcur];
		sbd->bd->physaddr = htole32(sbuf->map->dm_segs[i].ds_addr);
		sbd->bd->len = htole32(sbuf->map->dm_segs[i].ds_len);
		sbd->bd->nfrag = 0;	/* used only in first bd */
		sbd->bd->flags = IPW_BD_FLAG_TX_FRAME_802_3;
		if (i == sbuf->map->dm_nsegs - 1) {
			sbd->type = IPW_SBD_TYPE_DATA;
			sbd->priv = sbuf;
			sbd->bd->flags |= IPW_BD_FLAG_TX_LAST_FRAGMENT;
		} else {
			sbd->type = IPW_SBD_TYPE_NOASSOC;
			sbd->bd->flags |= IPW_BD_FLAG_TX_NOT_LAST_FRAGMENT;
		}

		bus_dmamap_sync(sc->sc_dmat, sc->tbd_map,
		    sc->txcur * sizeof (struct ipw_bd),
		    sizeof (struct ipw_bd), BUS_DMASYNC_PREWRITE);

		sc->txcur = (sc->txcur + 1) % IPW_NTBD;
		sc->txfree--;
	}

	bus_dmamap_sync(sc->sc_dmat, sbuf->map, 0, sbuf->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, shdr->map, 0, sizeof (struct ipw_hdr),
	    BUS_DMASYNC_PREWRITE);

	/* inform firmware about this new packet */
	CSR_WRITE_4(sc, IPW_CSR_TX_WRITE_INDEX, sc->txcur);

	return 0;
}

void
ipw_start(struct ifnet *ifp)
{
	struct ipw_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct mbuf *m;

	if (ic->ic_state != IEEE80211_S_RUN)
		return;

	for (;;) {
		if (sc->txfree < 1 + IPW_MAX_NSEG) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;

#if NBPFILTER > 0
		if (ifp->if_bpf != NULL)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		m = ieee80211_encap(ifp, m, &ni);
		if (m == NULL)
			continue;
#if NBPFILTER > 0
		if (ic->ic_rawbpf != NULL)
			bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_OUT);
#endif
		if (ipw_tx_start(ifp, m, ni) != 0) {
			if (ni != NULL)
				ieee80211_release_node(ic, ni);
			ifp->if_oerrors++;
			break;
		}

		/* start watchdog timer */
		sc->sc_tx_timer = 5;
		ifp->if_timer = 1;
	}
}

void
ipw_watchdog(struct ifnet *ifp)
{
	struct ipw_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;

	if (sc->sc_tx_timer > 0) {
		if (--sc->sc_tx_timer == 0) {
			printf("%s: device timeout\n", sc->sc_dev.dv_xname);
			ipw_stop(ifp, 1);
			ifp->if_oerrors++;
			return;
		}
		ifp->if_timer = 1;
	}

	ieee80211_watchdog(ifp);
}

int
ipw_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct ipw_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;

	error = rw_enter(&sc->sc_rwlock, RW_WRITE | RW_INTR);
	if (error)
		return error;
	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (!(ifp->if_flags & IFF_RUNNING))
				ipw_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				ipw_stop(ifp, 1);
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);

		if (error == ENETRESET)
			error = 0;
		break;

	case SIOCG80211TXPOWER:
		/*
		 * If the hardware radio transmitter switch is off, report a
		 * tx power of IEEE80211_TXPOWER_MIN to indicate that radio
		 * transmitter is killed.
		 */
		((struct ieee80211_txpower *)data)->i_val =
		    (CSR_READ_4(sc, IPW_CSR_IO) & IPW_IO_RADIO_DISABLED) ?
		    IEEE80211_TXPOWER_MIN : sc->sc_ic.ic_txpower;
		break;

	default:
		error = ieee80211_ioctl(ifp, cmd, data);
	}

	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
		    (IFF_UP | IFF_RUNNING))
			ipw_init(ifp);
		error = 0;
	}

	splx(s);
	rw_exit_write(&sc->sc_rwlock);
	return error;
}

uint32_t
ipw_read_table1(struct ipw_softc *sc, uint32_t off)
{
	return MEM_READ_4(sc, MEM_READ_4(sc, sc->table1_base + off));
}

void
ipw_write_table1(struct ipw_softc *sc, uint32_t off, uint32_t info)
{
	MEM_WRITE_4(sc, MEM_READ_4(sc, sc->table1_base + off), info);
}

int
ipw_read_table2(struct ipw_softc *sc, uint32_t off, void *buf, uint32_t *len)
{
	uint32_t addr, info;
	uint16_t count, size;
	uint32_t total;

	/* addr[4] + count[2] + size[2] */
	addr = MEM_READ_4(sc, sc->table2_base + off);
	info = MEM_READ_4(sc, sc->table2_base + off + 4);

	count = info >> 16;
	size  = info & 0xffff;
	total = count * size;

	if (total > *len) {
		*len = total;
		return EINVAL;
	}
	*len = total;
	ipw_read_mem_1(sc, addr, buf, total);

	return 0;
}

void
ipw_stop_master(struct ipw_softc *sc)
{
	uint32_t tmp;
	int ntries;

	/* disable interrupts */
	CSR_WRITE_4(sc, IPW_CSR_INTR_MASK, 0);

	CSR_WRITE_4(sc, IPW_CSR_RST, IPW_RST_STOP_MASTER);
	for (ntries = 0; ntries < 50; ntries++) {
		if (CSR_READ_4(sc, IPW_CSR_RST) & IPW_RST_MASTER_DISABLED)
			break;
		DELAY(10);
	}
	if (ntries == 50)
		printf("%s: timeout waiting for master\n",
		    sc->sc_dev.dv_xname);

	tmp = CSR_READ_4(sc, IPW_CSR_RST);
	CSR_WRITE_4(sc, IPW_CSR_RST, tmp | IPW_RST_PRINCETON_RESET);
}

int
ipw_reset(struct ipw_softc *sc)
{
	uint32_t tmp;
	int ntries;

	ipw_stop_master(sc);

	/* move adapter to D0 state */
	tmp = CSR_READ_4(sc, IPW_CSR_CTL);
	CSR_WRITE_4(sc, IPW_CSR_CTL, tmp | IPW_CTL_INIT);

	/* wait for clock stabilization */
	for (ntries = 0; ntries < 1000; ntries++) {
		if (CSR_READ_4(sc, IPW_CSR_CTL) & IPW_CTL_CLOCK_READY)
			break;
		DELAY(200);
	}
	if (ntries == 1000)
		return EIO;

	tmp = CSR_READ_4(sc, IPW_CSR_RST);
	CSR_WRITE_4(sc, IPW_CSR_RST, tmp | IPW_RST_SW_RESET);

	DELAY(10);

	tmp = CSR_READ_4(sc, IPW_CSR_CTL);
	CSR_WRITE_4(sc, IPW_CSR_CTL, tmp | IPW_CTL_INIT);

	return 0;
}

int
ipw_load_ucode(struct ipw_softc *sc, u_char *uc, int size)
{
	int ntries;

	/* voodoo from the Intel Linux driver */
	MEM_WRITE_4(sc, 0x3000e0, 0x80000000);
	CSR_WRITE_4(sc, IPW_CSR_RST, 0);

	MEM_WRITE_2(sc, 0x220000, 0x0703);
	MEM_WRITE_2(sc, 0x220000, 0x0707);

	MEM_WRITE_1(sc, 0x210014, 0x72);
	MEM_WRITE_1(sc, 0x210014, 0x72);

	MEM_WRITE_1(sc, 0x210000, 0x40);
	MEM_WRITE_1(sc, 0x210000, 0x00);
	MEM_WRITE_1(sc, 0x210000, 0x40);

	MEM_WRITE_MULTI_1(sc, 0x210010, uc, size);

	MEM_WRITE_1(sc, 0x210000, 0x00);
	MEM_WRITE_1(sc, 0x210000, 0x00);
	MEM_WRITE_1(sc, 0x210000, 0x80);

	MEM_WRITE_2(sc, 0x220000, 0x0703);
	MEM_WRITE_2(sc, 0x220000, 0x0707);

	MEM_WRITE_1(sc, 0x210014, 0x72);
	MEM_WRITE_1(sc, 0x210014, 0x72);

	MEM_WRITE_1(sc, 0x210000, 0x00);
	MEM_WRITE_1(sc, 0x210000, 0x80);

	for (ntries = 0; ntries < 100; ntries++) {
		if (MEM_READ_1(sc, 0x210000) & 1)
			break;
		DELAY(1000);
	}
	if (ntries == 100) {
		printf("%s: timeout waiting for ucode to initialize\n",
		    sc->sc_dev.dv_xname);
		return EIO;
	}

	MEM_WRITE_4(sc, 0x3000e0, 0);

	return 0;
}

/* set of macros to handle unaligned little endian data in firmware image */
#define GETLE32(p) ((p)[0] | (p)[1] << 8 | (p)[2] << 16 | (p)[3] << 24)
#define GETLE16(p) ((p)[0] | (p)[1] << 8)
int
ipw_load_firmware(struct ipw_softc *sc, u_char *fw, int size)
{
	u_char *p, *end;
	uint32_t tmp, dst;
	uint16_t len;
	int error;

	p = fw;
	end = fw + size;
	while (p < end) {
		if (p + 6 > end)
			return EINVAL;

		dst = GETLE32(p); p += 4;
		len = GETLE16(p); p += 2;

		if (p + len > end)
			return EINVAL;

		ipw_write_mem_1(sc, dst, p, len);
		p += len;
	}

	CSR_WRITE_4(sc, IPW_CSR_IO, IPW_IO_GPIO1_ENABLE | IPW_IO_GPIO3_MASK |
	    IPW_IO_LED_OFF);

	/* allow interrupts so we know when the firmware is inited */
	CSR_WRITE_4(sc, IPW_CSR_INTR_MASK, IPW_INTR_MASK);

	/* tell the adapter to initialize the firmware */
	CSR_WRITE_4(sc, IPW_CSR_RST, 0);
	tmp = CSR_READ_4(sc, IPW_CSR_CTL);
	CSR_WRITE_4(sc, IPW_CSR_CTL, tmp | IPW_CTL_ALLOW_STANDBY);

	/* wait at most one second for firmware initialization to complete */
	if ((error = tsleep(sc, 0, "ipwinit", hz)) != 0) {
		printf("%s: timeout waiting for firmware initialization to "
		    "complete\n", sc->sc_dev.dv_xname);
		return error;
	}

	tmp = CSR_READ_4(sc, IPW_CSR_IO);
	CSR_WRITE_4(sc, IPW_CSR_IO, tmp | IPW_IO_GPIO1_MASK |
	    IPW_IO_GPIO3_MASK);

	return 0;
}

int
ipw_read_firmware(struct ipw_softc *sc, struct ipw_firmware *fw)
{
	const struct ipw_firmware_hdr *hdr;
	const char *name;
	int error;

	switch (sc->sc_ic.ic_opmode) {
	case IEEE80211_M_STA:
		name = "ipw-bss";
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_IBSS:
		name = "ipw-ibss";
		break;
#endif
	case IEEE80211_M_MONITOR:
		name = "ipw-monitor";
		break;
	default:
		/* should not get there */
		return ENODEV;
	}
	if ((error = loadfirmware(name, &fw->data, &fw->size)) != 0)
		return error;

	if (fw->size < sizeof (*hdr)) {
		error = EINVAL;
		goto fail;
	}
	hdr = (const struct ipw_firmware_hdr *)fw->data;
	fw->main_size  = letoh32(hdr->main_size);
	fw->ucode_size = letoh32(hdr->ucode_size);

	if (fw->size < sizeof (*hdr) + fw->main_size + fw->ucode_size) {
		error = EINVAL;
		goto fail;
	}
	fw->main  = fw->data + sizeof (*hdr);
	fw->ucode = fw->main + fw->main_size;

	return 0;

fail:	free(fw->data, M_DEVBUF, fw->size);
	return error;
}

void
ipw_scan(void *arg1)
{
	struct ipw_softc *sc = arg1;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	struct ipw_scan_options scan;
	uint8_t ssid[IEEE80211_NWID_LEN];
	int error;

	/*
	 * Firmware has a bug and does not honour the ``do not associate
	 * after scan'' bit in the scan command.  To prevent the firmware
	 * from associating after the scan, we set the ESSID to something
	 * unlikely to be used by a real AP.
	 * XXX would setting the desired BSSID to a multicast address work?
	 */
	memset(ssid, '\r', sizeof ssid);
	error = ipw_cmd(sc, IPW_CMD_SET_ESSID, ssid, sizeof ssid);
	if (error != 0)
		goto fail;

	/* no mandatory BSSID */
	DPRINTF(("Setting mandatory BSSID to null\n"));
	error = ipw_cmd(sc, IPW_CMD_SET_MANDATORY_BSSID, NULL, 0);
	if (error != 0)
		goto fail;

	scan.flags = htole32(IPW_SCAN_DO_NOT_ASSOCIATE | IPW_SCAN_MIXED_CELL);
	scan.channels = htole32(0x3fff);	/* scan channels 1-14 */
	DPRINTF(("Setting scan options to 0x%x\n", letoh32(scan.flags)));
	error = ipw_cmd(sc, IPW_CMD_SET_SCAN_OPTIONS, &scan, sizeof scan);
	if (error != 0)
		goto fail;

	/* start scanning */
	DPRINTF(("Enabling adapter\n"));
	error = ipw_cmd(sc, IPW_CMD_ENABLE, NULL, 0);
	if (error != 0)
		goto fail;

	return;
fail:
	printf("%s: scan request failed (error=%d)\n", sc->sc_dev.dv_xname,
	    error);
	ieee80211_end_scan(ifp);
}

void
ipw_auth_and_assoc(void *arg1)
{
	struct ipw_softc *sc = arg1;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni = ic->ic_bss;
	struct ipw_scan_options scan;
	struct ipw_security security;
	struct ipw_assoc_req assoc;
	uint32_t data;
	uint8_t chan;
	int s, error;

	DPRINTF(("Disabling adapter\n"));
	error = ipw_cmd(sc, IPW_CMD_DISABLE, NULL, 0);
	if (error != 0)
		goto fail;
#if 1
	/* wait at most one second for card to be disabled */
	s = splnet();
	error = tsleep(sc, 0, "ipwdis", hz);
	splx(s);
	if (error != 0) {
		printf("%s: timeout waiting for disabled state\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
#else
	/* Intel's Linux driver polls for the DISABLED state instead.. */
	for (ntries = 0; ntries < 1000; ntries++) {
		if (ipw_read_table1(sc, IPW_INFO_CARD_DISABLED) == 1)
			break;
		DELAY(10);
	}
	if (ntries == 1000) {
		printf("%s: timeout waiting for disabled state\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
#endif

	bzero(&security, sizeof security);
	security.authmode = IPW_AUTH_OPEN;
	security.ciphers = htole32(IPW_CIPHER_NONE);
	DPRINTF(("Setting authmode to %u\n", security.authmode));
	error = ipw_cmd(sc, IPW_CMD_SET_SECURITY_INFORMATION, &security,
	    sizeof security);
	if (error != 0)
		goto fail;

#ifdef IPW_DEBUG
	if (ipw_debug > 0) {
		printf("Setting ESSID to ");
		ieee80211_print_essid(ni->ni_essid, ni->ni_esslen);
		printf("\n");
	}
#endif
	error = ipw_cmd(sc, IPW_CMD_SET_ESSID, ni->ni_essid, ni->ni_esslen);
	if (error != 0)
		goto fail;

	DPRINTF(("Setting BSSID to %s\n", ether_sprintf(ni->ni_bssid)));
	error = ipw_cmd(sc, IPW_CMD_SET_MANDATORY_BSSID, ni->ni_bssid,
	    IEEE80211_ADDR_LEN);
	if (error != 0)
		goto fail;

	data = htole32((ic->ic_flags & (IEEE80211_F_WEPON |
	    IEEE80211_F_RSNON)) ? IPW_PRIVACYON : 0);
	DPRINTF(("Setting privacy flags to 0x%x\n", letoh32(data)));
	error = ipw_cmd(sc, IPW_CMD_SET_PRIVACY_FLAGS, &data, sizeof data);
	if (error != 0)
		goto fail;

	/* let firmware set the capinfo, lintval, and bssid fixed fields */
	bzero(&assoc, sizeof assoc);
	if (ic->ic_flags & IEEE80211_F_RSNON) {
		uint8_t *frm = assoc.optie;

		/* tell firmware to add a WPA or RSN IE in (Re)Assoc req */
		if (ni->ni_rsnprotos & IEEE80211_PROTO_RSN)
			frm = ieee80211_add_rsn(frm, ic, ni);
		else if (ni->ni_rsnprotos & IEEE80211_PROTO_WPA)
			frm = ieee80211_add_wpa(frm, ic, ni);
		assoc.optie_len = htole32(frm - assoc.optie);
	}
	DPRINTF(("Preparing assocation request (optional IE length=%d)\n",
	    letoh32(assoc.optie_len)));
	error = ipw_cmd(sc, IPW_CMD_SET_ASSOC_REQ, &assoc, sizeof assoc);
	if (error != 0)
		goto fail;

	scan.flags = htole32(IPW_SCAN_MIXED_CELL);
	chan = ieee80211_chan2ieee(ic, ni->ni_chan);
	scan.channels = htole32(1 << (chan - 1));
	DPRINTF(("Setting scan options to 0x%x\n", letoh32(scan.flags)));
	error = ipw_cmd(sc, IPW_CMD_SET_SCAN_OPTIONS, &scan, sizeof scan);
	if (error != 0)
		goto fail;

	/* trigger scan+association */
	DPRINTF(("Enabling adapter\n"));
	error = ipw_cmd(sc, IPW_CMD_ENABLE, NULL, 0);
	if (error != 0)
		goto fail;

	return;
fail:
	printf("%s: association failed (error=%d)\n", sc->sc_dev.dv_xname,
	    error);
	ieee80211_begin_scan(&ic->ic_if);
}

int
ipw_config(struct ipw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ipw_configuration config;
	uint32_t data;
	int error;

	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		data = htole32(IPW_MODE_BSS);
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_IBSS:
		data = htole32(IPW_MODE_IBSS);
		break;
#endif
	case IEEE80211_M_MONITOR:
		data = htole32(IPW_MODE_MONITOR);
		break;
	default:
		/* should not get there */
		return ENODEV;
	}
	DPRINTF(("Setting mode to %u\n", letoh32(data)));
	error = ipw_cmd(sc, IPW_CMD_SET_MODE, &data, sizeof data);
	if (error != 0)
		return error;

	if (
#ifndef IEEE80211_STA_ONLY
	    ic->ic_opmode == IEEE80211_M_IBSS ||
#endif
	    ic->ic_opmode == IEEE80211_M_MONITOR) {
		data = htole32(ieee80211_chan2ieee(ic, ic->ic_ibss_chan));
		DPRINTF(("Setting channel to %u\n", letoh32(data)));
		error = ipw_cmd(sc, IPW_CMD_SET_CHANNEL, &data, sizeof data);
		if (error != 0)
			return error;
	}

	if (ic->ic_opmode == IEEE80211_M_MONITOR) {
		DPRINTF(("Enabling adapter\n"));
		return ipw_cmd(sc, IPW_CMD_ENABLE, NULL, 0);
	}

	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	DPRINTF(("Setting MAC address to %s\n", ether_sprintf(ic->ic_myaddr)));
	error = ipw_cmd(sc, IPW_CMD_SET_MAC_ADDRESS, ic->ic_myaddr,
	    IEEE80211_ADDR_LEN);
	if (error != 0)
		return error;

	config.flags = htole32(IPW_CFG_BSS_MASK | IPW_CFG_IBSS_MASK |
	    IPW_CFG_PREAMBLE_AUTO | IPW_CFG_802_1X_ENABLE);
#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_IBSS)
		config.flags |= htole32(IPW_CFG_IBSS_AUTO_START);
#endif
	if (ifp->if_flags & IFF_PROMISC)
		config.flags |= htole32(IPW_CFG_PROMISCUOUS);
	config.bss_chan = htole32(0x3fff);	/* channels 1-14 */
	config.ibss_chan = htole32(0x7ff);	/* channels 1-11 */
	DPRINTF(("Setting configuration 0x%x\n", config.flags));
	error = ipw_cmd(sc, IPW_CMD_SET_CONFIGURATION, &config, sizeof config);
	if (error != 0)
		return error;

	data = htole32(ic->ic_rtsthreshold);
	DPRINTF(("Setting RTS threshold to %u\n", letoh32(data)));
	error = ipw_cmd(sc, IPW_CMD_SET_RTS_THRESHOLD, &data, sizeof data);
	if (error != 0)
		return error;

	data = htole32(ic->ic_fragthreshold);
	DPRINTF(("Setting frag threshold to %u\n", letoh32(data)));
	error = ipw_cmd(sc, IPW_CMD_SET_FRAG_THRESHOLD, &data, sizeof data);
	if (error != 0)
		return error;

	data = htole32(0x3);	/* 1, 2 */
	DPRINTF(("Setting basic tx rates to 0x%x\n", letoh32(data)));
	error = ipw_cmd(sc, IPW_CMD_SET_BASIC_TX_RATES, &data, sizeof data);
	if (error != 0)
		return error;

	data = htole32(0xf);	/* 1, 2, 5.5, 11 */
	DPRINTF(("Setting tx rates to 0x%x\n", letoh32(data)));
	error = ipw_cmd(sc, IPW_CMD_SET_TX_RATES, &data, sizeof data);
	if (error != 0)
		return error;

	data = htole32(0xf);	/* 1, 2, 5.5, 11 */
	DPRINTF(("Setting MSDU tx rates to 0x%x\n", letoh32(data)));
	error = ipw_cmd(sc, IPW_CMD_SET_MSDU_TX_RATES, &data, sizeof data);
	if (error != 0)
		return error;

	data = htole32(IPW_POWER_MODE_CAM);
	DPRINTF(("Setting power mode to %u\n", letoh32(data)));
	error = ipw_cmd(sc, IPW_CMD_SET_POWER_MODE, &data, sizeof data);
	if (error != 0)
		return error;

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_IBSS) {
		data = htole32(32);	/* default value */
		DPRINTF(("Setting tx power index to %u\n", letoh32(data)));
		error = ipw_cmd(sc, IPW_CMD_SET_TX_POWER_INDEX, &data,
		    sizeof data);
		if (error != 0)
			return error;

		data = htole32(ic->ic_lintval);
		DPRINTF(("Setting beacon interval to %u\n", letoh32(data)));
		error = ipw_cmd(sc, IPW_CMD_SET_BEACON_INTERVAL, &data,
		    sizeof data);
		if (error != 0)
			return error;
	}
#endif
	return 0;
}

int
ipw_init(struct ifnet *ifp)
{
	struct ipw_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ipw_firmware fw;
	int error;

	ipw_stop(ifp, 0);

	if ((error = ipw_reset(sc)) != 0) {
		printf("%s: could not reset adapter\n", sc->sc_dev.dv_xname);
		goto fail1;
	}

	if ((error = ipw_read_firmware(sc, &fw)) != 0) {
		printf("%s: error %d, could not read firmware\n",
		    sc->sc_dev.dv_xname, error);
		goto fail1;
	}
	if ((error = ipw_load_ucode(sc, fw.ucode, fw.ucode_size)) != 0) {
		printf("%s: could not load microcode\n", sc->sc_dev.dv_xname);
		goto fail2;
	}

	ipw_stop_master(sc);

	/*
	 * Setup tx, rx and status rings.
	 */
	CSR_WRITE_4(sc, IPW_CSR_TX_BD_BASE, sc->tbd_map->dm_segs[0].ds_addr);
	CSR_WRITE_4(sc, IPW_CSR_TX_BD_SIZE, IPW_NTBD);
	CSR_WRITE_4(sc, IPW_CSR_TX_READ_INDEX, 0);
	CSR_WRITE_4(sc, IPW_CSR_TX_WRITE_INDEX, 0);
	sc->txold = IPW_NTBD - 1;	/* latest bd index ack by firmware */
	sc->txcur = 0; /* bd index to write to */
	sc->txfree = IPW_NTBD - 2;

	CSR_WRITE_4(sc, IPW_CSR_RX_BD_BASE, sc->rbd_map->dm_segs[0].ds_addr);
	CSR_WRITE_4(sc, IPW_CSR_RX_BD_SIZE, IPW_NRBD);
	CSR_WRITE_4(sc, IPW_CSR_RX_READ_INDEX, 0);
	CSR_WRITE_4(sc, IPW_CSR_RX_WRITE_INDEX, IPW_NRBD - 1);
	sc->rxcur = IPW_NRBD - 1;	/* latest bd index I've read */

	CSR_WRITE_4(sc, IPW_CSR_RX_STATUS_BASE,
	    sc->status_map->dm_segs[0].ds_addr);

	if ((error = ipw_load_firmware(sc, fw.main, fw.main_size)) != 0) {
		printf("%s: could not load firmware\n", sc->sc_dev.dv_xname);
		goto fail2;
	}
	free(fw.data, M_DEVBUF, fw.size);
	fw.data = NULL;

	/* retrieve information tables base addresses */
	sc->table1_base = CSR_READ_4(sc, IPW_CSR_TABLE1_BASE);
	sc->table2_base = CSR_READ_4(sc, IPW_CSR_TABLE2_BASE);

	ipw_write_table1(sc, IPW_INFO_LOCK, 0);

	if ((error = ipw_config(sc)) != 0) {
		printf("%s: device configuration failed\n",
		    sc->sc_dev.dv_xname);
		goto fail1;
	}

	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_flags |= IFF_RUNNING;

	if (ic->ic_opmode != IEEE80211_M_MONITOR)
		ieee80211_begin_scan(ifp);
	else
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);

	return 0;

fail2:	free(fw.data, M_DEVBUF, fw.size);
	fw.data = NULL;
fail1:	ipw_stop(ifp, 0);
	return error;
}

void
ipw_stop(struct ifnet *ifp, int disable)
{
	struct ipw_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	int i;

	ipw_stop_master(sc);
	CSR_WRITE_4(sc, IPW_CSR_RST, IPW_RST_SW_RESET);

	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/*
	 * Release tx buffers.
	 */
	for (i = 0; i < IPW_NTBD; i++)
		ipw_release_sbd(sc, &sc->stbd_list[i]);

	/* in case we were scanning, release the scan "lock" */
	ic->ic_scan_lock = IEEE80211_SCAN_UNLOCKED;

	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);
}

void
ipw_read_mem_1(struct ipw_softc *sc, bus_size_t offset, uint8_t *datap,
    bus_size_t count)
{
	for (; count > 0; offset++, datap++, count--) {
		CSR_WRITE_4(sc, IPW_CSR_INDIRECT_ADDR, offset & ~3);
		*datap = CSR_READ_1(sc, IPW_CSR_INDIRECT_DATA + (offset & 3));
	}
}

void
ipw_write_mem_1(struct ipw_softc *sc, bus_size_t offset, uint8_t *datap,
    bus_size_t count)
{
	for (; count > 0; offset++, datap++, count--) {
		CSR_WRITE_4(sc, IPW_CSR_INDIRECT_ADDR, offset & ~3);
		CSR_WRITE_1(sc, IPW_CSR_INDIRECT_DATA + (offset & 3), *datap);
	}
}

struct cfdriver ipw_cd = {
	NULL, "ipw", DV_IFNET
};
@


1.119
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.118 2016/09/05 10:17:30 tedu Exp $	*/
a811 1
		ifp->if_flags &= ~IFF_UP;
a1048 1
		ifp->if_flags &= ~IFF_UP;
a1336 1
			ifp->if_flags &= ~IFF_UP;
@


1.118
log
@redo rwlock conversion now that i've compiled it on i386
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.117 2016/09/05 09:59:20 kettenis Exp $	*/
a1021 3

		if (sbd->type == IPW_SBD_TYPE_DATA)
			ifp->if_opackets++;
@


1.117
log
@Backout previous commit; does not compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.116 2016/09/05 08:17:29 tedu Exp $	*/
d31 1
d207 1
d323 1
a324 3
	while (sc->sc_flags & IPW_FLAG_BUSY)
		tsleep(&sc->sc_flags, PZERO, "ipwpwr", 0);
	sc->sc_flags |= IPW_FLAG_BUSY;
a328 2
	sc->sc_flags &= ~IPW_FLAG_BUSY;
	wakeup(&sc->sc_flags);
d330 1
d1361 3
a1364 11
	/*
	 * Prevent processes from entering this function while another
	 * process is tsleep'ing in it.
	 */
	while ((sc->sc_flags & IPW_FLAG_BUSY) && error == 0)
		error = tsleep(&sc->sc_flags, PCATCH, "ipwioc", 0);
	if (error != 0) {
		splx(s);
		return error;
	}
	sc->sc_flags |= IPW_FLAG_BUSY;
a1412 2
	sc->sc_flags &= ~IPW_FLAG_BUSY;
	wakeup(&sc->sc_flags);
d1414 1
a1475 2

	sc->sc_flags &= ~IPW_FLAG_FW_INITED;
a1994 1
	sc->sc_flags |= IPW_FLAG_FW_INITED;
@


1.116
log
@convert busy flag and tsleep to rwlock as in iwm
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.115 2016/04/13 10:34:32 mpi Exp $	*/
a30 1
#include <sys/rwlock.h>
a205 1
	rw_init(&sc->sc_rwlock, "ipwlock");
a320 1
	rw_enter_write(&sc->sc_rwlock);
d322 3
d329 2
a331 1
	rw_exit_write(&sc->sc_rwlock);
d1362 9
a1370 2
	error = rw_enter(&sc->sc_rwlock, RW_ENTER | RW_INTR);
	if (error)
d1372 2
a1373 1
	s = splnet();
d1422 2
a1424 1
	rw_exit_write(&sc->sc_rwlock);
d1486 2
d2007 1
@


1.115
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.114 2015/11/25 03:09:59 dlg Exp $	*/
d31 1
d207 1
d323 1
a324 3
	while (sc->sc_flags & IPW_FLAG_BUSY)
		tsleep(&sc->sc_flags, PZERO, "ipwpwr", 0);
	sc->sc_flags |= IPW_FLAG_BUSY;
a328 2
	sc->sc_flags &= ~IPW_FLAG_BUSY;
	wakeup(&sc->sc_flags);
d330 1
d1361 3
a1364 11
	/*
	 * Prevent processes from entering this function while another
	 * process is tsleep'ing in it.
	 */
	while ((sc->sc_flags & IPW_FLAG_BUSY) && error == 0)
		error = tsleep(&sc->sc_flags, PCATCH, "ipwioc", 0);
	if (error != 0) {
		splx(s);
		return error;
	}
	sc->sc_flags |= IPW_FLAG_BUSY;
a1412 2
	sc->sc_flags &= ~IPW_FLAG_BUSY;
	wakeup(&sc->sc_flags);
d1414 1
a1475 2

	sc->sc_flags &= ~IPW_FLAG_FW_INITED;
a1994 1
	sc->sc_flags |= IPW_FLAG_FW_INITED;
@


1.114
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.113 2015/11/24 13:45:06 mpi Exp $	*/
a265 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.113
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.112 2015/11/24 13:33:17 mpi Exp $	*/
d1036 1
a1036 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1301 1
a1301 1
			ifp->if_flags |= IFF_OACTIVE;
d2024 1
a2024 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2051 2
a2052 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.112
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.111 2015/11/20 03:35:23 dlg Exp $	*/
a47 1
#include <net/if_arp.h>
@


1.111
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.110 2015/10/25 13:04:28 mpi Exp $	*/
a50 1
#include <net/if_types.h>
@


1.110
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.109 2015/09/01 07:09:55 deraadt Exp $	*/
a1301 4
		IFQ_POLL(&ifp->if_snd, m);
		if (m == NULL)
			break;

d1306 1
d1308 3
d1315 1
@


1.109
log
@sizes for free(), mostly related to firmwares.
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.108 2015/05/27 22:10:52 kettenis Exp $	*/
a1360 1
	struct ifaddr *ifa;
a1378 1
		ifa = (struct ifaddr *)data;
a1379 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.108
log
@Use m_defrag(9) instead of rolling our own inlined version.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.107 2015/02/10 23:25:46 mpi Exp $	*/
a1634 1
	size_t size;
d1653 1
a1653 1
	if ((error = loadfirmware(name, &fw->data, &size)) != 0)
d1656 1
a1656 1
	if (size < sizeof (*hdr)) {
d1664 1
a1664 1
	if (size < sizeof (*hdr) + fw->main_size + fw->ucode_size) {
d1673 1
a1673 1
fail:	free(fw->data, M_DEVBUF, 0);
d2014 1
a2014 1
	free(fw.data, M_DEVBUF, 0);
d2039 1
a2039 1
fail2:	free(fw.data, M_DEVBUF, 0);
@


1.107
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.106 2015/01/27 04:49:01 dlg Exp $	*/
a1145 1
	struct mbuf *m1;
d1210 1
a1210 2
		MGETHDR(m1, M_DONTWAIT, MT_DATA);
		if (m1 == NULL) {
a1213 13
		if (m->m_pkthdr.len > MHLEN) {
			MCLGET(m1, M_DONTWAIT);
			if (!(m1->m_flags & M_EXT)) {
				m_freem(m);
				m_freem(m1);
				return ENOBUFS;
			}
		}
		m_copydata(m, 0, m->m_pkthdr.len, mtod(m1, caddr_t));
		m1->m_pkthdr.len = m1->m_len = m->m_pkthdr.len;
		m_freem(m);
		m = m1;

@


1.106
log
@i forgot to fix ipw when i removed the second task argument.

poke from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.105 2014/12/22 02:28:52 tedu Exp $	*/
a881 1
	m->m_pkthdr.rcvif = ifp;
@


1.105
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.104 2014/12/19 22:44:58 guenther Exp $	*/
d99 2
a100 2
void		ipw_scan(void *, void *);
void		ipw_auth_and_assoc(void *, void *);
d208 2
a209 2
	task_set(&sc->sc_scantask, ipw_scan, sc, NULL);
	task_set(&sc->sc_authandassoctask, ipw_auth_and_assoc, sc, NULL);
d1695 1
a1695 1
ipw_scan(void *arg1, void *arg2)
d1742 1
a1742 1
ipw_auth_and_assoc(void *arg1, void *arg2)
@


1.104
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.103 2014/12/19 15:46:22 krw Exp $	*/
a1397 1
#ifdef INET
a1399 1
#endif
@


1.103
log
@Fix tree breakage due to unused variable after last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.102 2014/12/19 15:19:47 krw Exp $	*/
d35 1
a37 1
#include <machine/endian.h>
@


1.102
log
@Change scan and auth+assoc workq entries to taskq entries.

Identical diff originally and independently developed by blambert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.101 2014/07/22 13:12:11 mpi Exp $	*/
a684 1
	int error;
@


1.101
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.100 2014/07/12 18:48:51 tedu Exp $	*/
d28 1
a28 1
#include <sys/workq.h>
d208 3
d612 3
d689 1
a689 3
		error = workq_add_task(NULL, 0, ipw_scan, sc, NULL);
		if (error != 0)
			return error;
d693 1
a693 3
		error = workq_add_task(NULL, 0, ipw_auth_and_assoc, sc, NULL);
		if (error != 0)
			return error;
@


1.100
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.99 2014/03/27 11:32:29 daniel Exp $	*/
a53 1
#include <netinet/in_systm.h>
a54 1
#include <netinet/ip.h>
@


1.99
log
@fix a theoretical double free.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.98 2013/12/06 21:03:04 deraadt Exp $	*/
d1693 1
a1693 1
fail:	free(fw->data, M_DEVBUF);
d2034 1
a2034 1
	free(fw.data, M_DEVBUF);
d2059 1
a2059 1
fail2:	free(fw.data, M_DEVBUF);
@


1.98
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.97 2013/11/14 12:41:14 dlg Exp $	*/
d2035 1
d2046 1
a2046 1
		goto fail2;
d2060 1
@


1.97
log
@replace workqs with tasks for handling resume. state handling is
still in workqs.

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.96 2013/08/07 01:06:35 bluhm Exp $	*/
a27 1
#include <sys/task.h>
d67 1
a67 1
void		ipw_resume(void *, void *);
a172 2
	task_set(&sc->sc_resume_t, ipw_resume, sc, NULL);

d303 2
a304 2
	case DVACT_RESUME:
		task_add(systq, &sc->sc_resume_t);
d312 1
a312 1
ipw_resume(void *arg1, void *arg2)
a313 1
	struct ipw_softc *sc = arg1;
@


1.96
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.95 2011/04/07 15:30:16 miod Exp $	*/
d28 1
d174 2
d307 1
a307 2
		workq_queue_task(NULL, &sc->sc_resume_wqt, 0,
		    ipw_resume, sc, NULL);
@


1.95
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.94 2010/11/15 19:11:57 damien Exp $	*/
a54 1
#include <netinet/in_var.h>
@


1.94
log
@Reset ic_scan_lock in {ipw,iwi}_stop similarly to {wpi,iwn}_stop.

From Jeremy Chase.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.93 2010/09/07 16:21:45 deraadt Exp $	*/
d2000 1
a2000 1
	if ((error = ipw_read_firmware(sc, &fw)) != NULL) {
@


1.93
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.92 2010/08/27 20:09:01 deraadt Exp $	*/
d2084 3
@


1.92
log
@Move the guts of the powerhook function into the activate function and make
it stop calling the powerhook function; then make the powerhook function
call activate.  This basically inverts the whole goop.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.91 2010/08/27 17:08:00 jsg Exp $	*/
a68 1
void		ipw_powerhook(int, void *);
a278 2
	sc->powerhook = powerhook_establish(ipw_powerhook, sc);

a336 6
}

void
ipw_powerhook(int why, void *arg)
{
	ipw_activate(arg, why);
@


1.91
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.90 2010/08/12 16:59:29 damien Exp $	*/
d69 1
a69 1
void		ipw_power(int, void *);
d280 1
a280 1
	sc->powerhook = powerhook_establish(ipw_power, sc);
d319 1
a319 7
	ipw_power(PWR_RESUME, arg1);
}

void
ipw_power(int why, void *arg)
{
	struct ipw_softc *sc = arg;
a323 5
	if (why != PWR_RESUME) {
		ipw_stop(ifp, 0);
		return;
	}

d340 6
@


1.90
log
@homogeneous style.

no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.89 2010/08/12 15:03:59 oga Exp $	*/
a265 1
	ifp->if_init = ipw_init;
@


1.89
log
@Instead of returning EBUSY when the busy flag is set in the ioctl, sleep
until whoever has it is done with it.

This is kept as flag/sleep condvars instead of a rwlock because later we
may want to quiesce the handler before suspend to make sure nothing is
sleeping on a chip that is about to be whacked (doing so will change the
proc so rwlocks won't work).

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.88 2010/08/03 18:26:25 kettenis Exp $	*/
d314 1
a314 1
	return (0);
d1405 1
a1405 1
	while (sc->sc_flags & IPW_FLAG_BUSY && error == 0)
d1407 1
a1407 1
	if (error) {
@


1.88
log
@Bring the suspend/resume code of all the Intel wireless drivers in line with
iwn(4) again.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.87 2010/07/28 21:21:38 deraadt Exp $	*/
d342 2
d350 1
d1405 3
a1407 1
	if (sc->sc_flags & IPW_FLAG_BUSY) {
d1409 1
a1409 1
		return EBUSY;
d1466 1
@


1.87
log
@Make legacy xxpower() functions call xxstop() on suspend, and simplify their
resume paths.  For new-style suspend/resume, add a ca_activate function where
it is missing, and use a workq to resume because these drivers like to sleep.
ok damien
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.86 2010/04/20 22:05:43 tedu Exp $	*/
d329 1
d341 3
d346 3
d1398 9
d1460 1
d1524 1
a1524 1
	sc->flags &= ~IPW_FLAG_FW_INITED;
d2045 1
a2045 1
	sc->flags |= IPW_FLAG_FW_INITED;
@


1.86
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.85 2009/03/29 21:53:52 sthen Exp $	*/
d67 2
d137 2
a138 1
	sizeof (struct ipw_softc), ipw_match, ipw_attach
d297 26
d327 1
a327 1
	struct ifnet *ifp;
d330 2
a331 1
	if (why != PWR_RESUME)
d333 1
d340 2
a341 6
	ifp = &sc->sc_ic.ic_if;
	if (ifp->if_flags & IFF_UP) {
		ifp->if_init(ifp);
		if (ifp->if_flags & IFF_RUNNING)
			ifp->if_start(ifp);
	}
@


1.85
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.84 2009/01/26 19:09:41 damien Exp $	*/
a27 1
#include <sys/sysctl.h>
@


1.84
log
@Add some initial HT bits (not enabled yet) based on 802.11n Draft 7.01:
- implement A-MPDU frames buffering and reordering
- implement A-MSDU decapsulation
- process/send ADDBA Request, ADDBA Response and DELBA action frames
- process Block Ack Request control frames (including MTBAR)
- implement PBAC support (Protected Block Ack)
- add some incomplete HT Capabilities and HT Operation IEs parsing

Add more Management Frame Protection bits based on 802.11w Draft 7.0:
- implement SA Query procedure (both AP and STA)
- cleanup BIP

Fix some bugs:
- fix check for WEP key length that otherwise caused a stack smash in
  ieee80211_wep_encrypt (pointed out by Xavier Santolaria on macppc)
- properly stop EAPOL timeout: fixes a panic that occured in HostAP mode
  when turning the interface down while a 4-way handshake is in progress
  (pointed out by Doughertys)

Did some code cleanup too.

The HT bits are currently not compiled in (IEEE80211_NO_HT is defined)
because they won't be ready until after the next release and I didn't
want to grow the kernel or to inadvertently introduce new bugs.
They are here such that other people can look at the code.
Notice that I had to add an extra parameter to ic_send_mgmt() for
action frames, that is why there are small changes in drivers defining
their own ic_send_mgmt() handler.

Sorry for the not very incremental diff but this has been sitting in
my tree for too long now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.83 2008/12/22 18:20:47 damien Exp $	*/
d182 1
a182 1
		printf(": could not map memory space\n");
d194 1
a194 1
		printf(": could not map interrupt\n");
d202 1
a202 1
		printf(": could not establish interrupt");
d348 1
a348 1
		printf("%s: could not map tx ring DMA memory\n",
d383 1
a383 1
		printf("%s: could not map rx ring DMA memory\n",
d418 1
a418 1
		printf("%s: could not map status ring DMA memory\n",
d518 1
a518 1
			printf("%s: could not map rx DMA memory\n",
d1082 1
a1082 1
		printf("%s: could not map command DMA memory\n",
d1188 1
a1188 1
		printf("%s: could not map mbuf (error %d)\n",
d1216 1
a1216 1
			printf("%s: could not map mbuf (error %d)\n",
d1226 1
a1226 1
		printf("%s: could not map header DMA memory (error %d)\n",
@


1.83
log
@I swapped MGETHDR arguments in my m_defrag removal commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.82 2008/12/21 18:19:58 damien Exp $	*/
d87 1
a87 1
		    int, int);
d1118 1
a1118 1
    int arg)
@


1.82
log
@Undo m_defrag().

m_defrag() does not work.  It seems to assume that if the length of
the mbuf passed as parameter is less than MHLEN, then it is an mbuf
header and not a cluster (or something like that.)
It thus fails miserably in the bcopy path.
I don't have the time to investigate further into this.

Thanks to Okan Demirmen for reporting the issue on a ral(4) RT2560.
The RT2560 chipset does not support TX scatter and thus m_defrag()
was called much more often than in other drivers using m_defrag()
where it was less noticeable.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.81 2008/11/25 21:43:57 damien Exp $	*/
d1195 1
a1195 1
		MGETHDR(m1, MT_DATA, M_DONTWAIT);
@


1.81
log
@use shiny new m_defrag() and nitems() instead of rolling our own.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.80 2008/09/03 19:43:59 damien Exp $	*/
d1130 1
d1195 2
a1196 1
		if (m_defrag(m, M_DONTWAIT) != 0) {
d1198 9
a1206 1
			return ENOMEM;
d1208 5
@


1.80
log
@redefine ic_send_mgmt() as a no-op instead of calling IF_PURGE in
{ipw,iwi}_start which is wrong (node reference is not released).
from pgt(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.79 2008/08/28 16:02:14 damien Exp $	*/
a612 1
#define N(a)	(sizeof (a) / sizeof (a[0]))
d637 2
a638 2
	for (i = 0; i < N(rates) && rates[i].val != val; i++);
	rate = (i < N(rates)) ? rates[i].rate : 0;
a656 1
#undef N
a1132 1
	struct mbuf *mnew;
d1194 1
a1194 3

		MGETHDR(mnew, M_DONTWAIT, MT_DATA);
		if (mnew == NULL) {
a1197 14
		M_DUP_PKTHDR(mnew, m);
		if (m->m_pkthdr.len > MHLEN) {
			MCLGET(mnew, M_DONTWAIT);
			if (!(mnew->m_flags & M_EXT)) {
				m_freem(m);
				m_freem(mnew);
				return ENOMEM;
			}
		}
		m_copydata(m, 0, m->m_pkthdr.len, mtod(mnew, caddr_t));
		m_freem(m);
		mnew->m_len = mnew->m_pkthdr.len;
		m = mnew;

@


1.79
log
@indent IF_PURGE.  pointed out by brad@@

no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.78 2008/08/28 16:00:21 damien Exp $	*/
d86 2
d276 1
d1117 8
d1301 3
a1304 4
		IF_PURGE(&ic->ic_mgtq);

		if (ic->ic_state != IEEE80211_S_RUN)
			return;
@


1.78
log
@#undef IPW_DEBUG
fix a comment while i'm here.

pointed out by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.77 2008/08/28 15:08:38 damien Exp $	*/
d1291 1
a1291 1
                IF_PURGE(&ic->ic_mgtq);
@


1.77
log
@i've lost the IF_PURGE() bits in the process...
use license.template while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.76 2008/08/28 14:40:44 damien Exp $	*/
a123 2
#define IPW_DEBUG

d127 1
a127 1
int ipw_debug = 2;
d1674 1
a1674 1
	 * XXX would setting the BSSID to a multicast address work?
@


1.76
log
@WPA support for ipw(4).
Did a lot of cleanup while I was there.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.72 2008/04/16 18:32:15 damien Exp $	*/
d7 3
a9 9
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice unmodified, this list of conditions, and the following
 *    disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d11 7
a17 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d124 2
d129 1
a129 1
int ipw_debug = 0;
d781 5
d1292 2
a1293 2
	if (ic->ic_state != IEEE80211_S_RUN)
		return;
d1295 2
a1296 1
	for (;;) {
d1703 1
a1703 1
 fail:
d1816 1
a1816 1
 fail:
@


1.75
log
@the firmware is responsible for sending management frames, but
since we pass received management frames to net80211, net80211
may send replies (like deauth/disassoc), so we just call
IF_PURGE(&ic->ic_mgtq) in {ipw,iwi}_start just to be on the
safe side of things (so we don't leak mbufs).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.74 2008/08/27 09:05:03 damien Exp $	*/
d39 1
d110 2
d241 1
d672 1
a672 3
	struct ieee80211_node *ni;
	uint8_t macaddr[IEEE80211_ADDR_LEN];
	uint32_t len;
d675 5
a679 2
	case IEEE80211_S_RUN:
		DELAY(100);	/* firmware needs a short delay here */
d681 4
a684 9
		len = IEEE80211_ADDR_LEN;
		ipw_read_table2(sc, IPW_INFO_CURRENT_BSSID, macaddr, &len);

		ni = ieee80211_find_node(ic, macaddr);
		if (ni == NULL)
			break;

		(*ic->ic_node_copy)(ic, ic->ic_bss, ni);
		ieee80211_node_newstate(ni, IEEE80211_STA_BSS);
d687 1
a688 2
	case IEEE80211_S_SCAN:
	case IEEE80211_S_AUTH:
d690 1
d764 2
a765 3
	DPRINTFN(2, ("RX!CMD!%u!%u!%u!%u!%u\n",
	    letoh32(cmd->type), letoh32(cmd->subtype), letoh32(cmd->seq),
	    letoh32(cmd->len), letoh32(cmd->status)));
d767 1
a767 1
	wakeup(sc);
d782 1
a782 1
	DPRINTFN(2, ("RX!NEWSTATE!%u\n", state));
a788 8
	case IPW_STATE_SCANNING:
		/* don't leave run state on background scan */
		if (ic->ic_state != IEEE80211_S_RUN)
			ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);

		ic->ic_flags |= IEEE80211_F_ASCAN;
		break;

d790 2
a791 1
		ic->ic_flags &= ~IEEE80211_F_ASCAN;
d798 4
d821 2
a822 1
	DPRINTFN(5, ("RX!DATA!%u!%u\n", letoh32(status->len), status->rssi));
d907 1
a907 1
	DPRINTFN(2, ("RX!NOTIFICATION\n"));
a1042 2
	DPRINTFN(8, ("INTR!0x%08x\n", r));

d1072 3
a1074 1
	int error;
d1076 6
a1081 1
	sbd = &sc->stbd_list[sc->txcur];
d1088 1
d1092 1
a1092 7
	sc->cmd.type = htole32(type);
	sc->cmd.subtype = htole32(0);
	sc->cmd.len = htole32(len);
	sc->cmd.seq = htole32(0);
	if (data != NULL)
		bcopy(data, sc->cmd.data, len);

a1101 1

d1110 1
a1110 1
	DPRINTFN(2, ("TX!CMD!%u!%u!%u!%u\n", type, 0, 0, len));
d1113 4
a1116 1
	return tsleep(sc, 0, "ipwcmd", hz);
a1242 5
	DPRINTFN(5, ("TX!HDR!%u!%u!%u!%u", shdr->hdr.type, shdr->hdr.subtype,
	    shdr->hdr.encrypted, shdr->hdr.encrypt));
	DPRINTFN(5, ("!%s", ether_sprintf(shdr->hdr.src_addr)));
	DPRINTFN(5, ("!%s\n", ether_sprintf(shdr->hdr.dst_addr)));

a1267 3
		DPRINTFN(5, ("TX!FRAG!%d!%d\n", i,
		    sbuf->map->dm_segs[i].ds_len));

d1295 3
a1298 4
		IF_PURGE(&ic->ic_mgtq);

		if (ic->ic_state != IEEE80211_S_RUN)
			return;
d1664 160
a1828 4
	struct ipw_security security;
	struct ieee80211_key *k;
	struct ipw_wep_key wepkey;
	struct ipw_scan_options options;
d1831 1
a1831 1
	int error, i;
d1879 1
a1879 1
	    IPW_CFG_PREAMBLE_AUTO | IPW_CFG_802_1x_ENABLE);
d1893 12
d1917 6
a1936 82
	}
#endif

	data = htole32(ic->ic_rtsthreshold);
	DPRINTF(("Setting RTS threshold to %u\n", letoh32(data)));
	error = ipw_cmd(sc, IPW_CMD_SET_RTS_THRESHOLD, &data, sizeof data);
	if (error != 0)
		return error;

	data = htole32(ic->ic_fragthreshold);
	DPRINTF(("Setting frag threshold to %u\n", letoh32(data)));
	error = ipw_cmd(sc, IPW_CMD_SET_FRAG_THRESHOLD, &data, sizeof data);
	if (error != 0)
		return error;

#ifdef IPW_DEBUG
	if (ipw_debug > 0) {
		printf("Setting ESSID to ");
		ieee80211_print_essid(ic->ic_des_essid, ic->ic_des_esslen);
		printf("\n");
	}
#endif
	error = ipw_cmd(sc, IPW_CMD_SET_ESSID, ic->ic_des_essid,
	    ic->ic_des_esslen);
	if (error != 0)
		return error;

	/* no mandatory BSSID */
	DPRINTF(("Setting mandatory BSSID to null\n"));
	error = ipw_cmd(sc, IPW_CMD_SET_MANDATORY_BSSID, NULL, 0);
	if (error != 0)
		return error;

	if (ic->ic_flags & IEEE80211_F_DESBSSID) {
		DPRINTF(("Setting adapter BSSID to %s\n",
		    ether_sprintf(ic->ic_des_bssid)));
		error = ipw_cmd(sc, IPW_CMD_SET_DESIRED_BSSID,
		    ic->ic_des_bssid, IEEE80211_ADDR_LEN);
		if (error != 0)
			return error;
	}

	bzero(&security, sizeof security);
	security.authmode = IPW_AUTH_OPEN;	/* XXX shared mode */
	security.ciphers = htole32(IPW_CIPHER_NONE);
	DPRINTF(("Setting authmode to %u\n", security.authmode));
	error = ipw_cmd(sc, IPW_CMD_SET_SECURITY_INFORMATION, &security,
	    sizeof security);
	if (error != 0)
		return error;

	if (ic->ic_flags & IEEE80211_F_WEPON) {
		k = ic->ic_nw_keys;
		for (i = 0; i < IEEE80211_WEP_NKID; i++, k++) {
			if (k->k_len == 0)
				continue;

			wepkey.idx = i;
			wepkey.len = k->k_len;
			bzero(wepkey.key, sizeof wepkey.key);
			bcopy(k->k_key, wepkey.key, k->k_len);
			DPRINTF(("Setting wep key index %u len %u\n",
			    wepkey.idx, wepkey.len));
			error = ipw_cmd(sc, IPW_CMD_SET_WEP_KEY, &wepkey,
			    sizeof wepkey);
			if (error != 0)
				return error;
		}

		data = htole32(ic->ic_wep_txkey);
		DPRINTF(("Setting wep tx key index to %u\n", letoh32(data)));
		error = ipw_cmd(sc, IPW_CMD_SET_WEP_KEY_INDEX, &data,
		    sizeof data);
		if (error != 0)
			return error;
	}

	data = htole32((ic->ic_flags & IEEE80211_F_WEPON) ? IPW_WEPON : 0);
	DPRINTF(("Setting wep flags to 0x%x\n", letoh32(data)));
	error = ipw_cmd(sc, IPW_CMD_SET_WEP_FLAGS, &data, sizeof data);
	if (error != 0)
		return error;
a1937 3
#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_IBSS ||
	    ic->ic_opmode == IEEE80211_M_HOSTAP) {
d1946 1
a1946 11

	options.flags = htole32(0);
	options.channels = htole32(0x3fff);	/* scan channels 1-14 */
	DPRINTF(("Setting scan options to 0x%x\n", letoh32(options.flags)));
	error = ipw_cmd(sc, IPW_CMD_SET_SCAN_OPTIONS, &options, sizeof options);
	if (error != 0)
		return error;

	/* finally, enable adapter (start scanning for an access point) */
	DPRINTF(("Enabling adapter\n"));
	return ipw_cmd(sc, IPW_CMD_ENABLE, NULL, 0);
d1953 1
d2014 1
d2018 5
a2026 1

@


1.74
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.73 2008/07/21 18:43:18 damien Exp $	*/
d1304 2
a1305 2
	if (ic->ic_state != IEEE80211_S_RUN)
		return;
d1307 2
a1308 1
	for (;;) {
@


1.73
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.72 2008/04/16 18:32:15 damien Exp $	*/
d231 1
d233 1
d649 1
d653 1
d657 1
a657 2
	case IEEE80211_M_AHDEMO:
	case IEEE80211_M_HOSTAP:
d1637 1
d1641 1
d1690 1
d1694 1
d1707 4
a1710 1
	if (ic->ic_opmode == IEEE80211_M_IBSS ||
d1733 1
d1736 1
d1764 1
d1773 1
d1855 1
d1865 1
@


1.72
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.71 2008/02/23 20:38:08 hshoexer Exp $	*/
d818 1
d896 4
a899 1
	ieee80211_input(ifp, m, ni, status->rssi, 0);
@


1.71
log
@Do not leak memory claimed by firmware on "ifconfig down".

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.70 2007/11/17 19:09:16 damien Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004-2006
a498 1

a646 1

a649 1

a652 1

a833 1

a891 1

d1098 1
a1098 1
	
d1119 1
d1128 4
a1131 3
	if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
		m = ieee80211_wep_crypt(ifp, m, 1);
		if (m == NULL)
d1162 1
a1162 1
	shdr->hdr.encrypted = (wh->i_fc[1] & IEEE80211_FC1_WEP) ? 1 : 0;
a1190 1

a1199 1

d1294 1
a1295 1
	struct ieee80211_node *ni;
a1313 1

a1316 1

a1320 1

d1446 1
a1446 1
	size = info & 0xffff;
a1452 1

d1462 1
d1478 2
a1479 2
	CSR_WRITE_4(sc, IPW_CSR_RST, CSR_READ_4(sc, IPW_CSR_RST) |
	    IPW_RST_PRINCETON_RESET);
d1487 1
d1493 2
a1494 2
	CSR_WRITE_4(sc, IPW_CSR_CTL, CSR_READ_4(sc, IPW_CSR_CTL) |
	    IPW_CTL_INIT);
d1505 2
a1506 2
	CSR_WRITE_4(sc, IPW_CSR_RST, CSR_READ_4(sc, IPW_CSR_RST) |
	    IPW_RST_SW_RESET);
d1510 2
a1511 2
	CSR_WRITE_4(sc, IPW_CSR_CTL, CSR_READ_4(sc, IPW_CSR_CTL) |
	    IPW_CTL_INIT);
d1521 1
d1573 1
a1573 1
	uint32_t dst;
d1601 2
a1602 2
	CSR_WRITE_4(sc, IPW_CSR_CTL, CSR_READ_4(sc, IPW_CSR_CTL) |
	    IPW_CTL_ALLOW_STANDBY);
d1611 3
a1613 2
	CSR_WRITE_4(sc, IPW_CSR_IO, CSR_READ_4(sc, IPW_CSR_IO) |
	    IPW_IO_GPIO1_MASK | IPW_IO_GPIO3_MASK);
d1621 1
a1621 1
	struct ipw_firmware_hdr *hdr;
a1622 1
	u_char *p;
a1627 1
	case IEEE80211_M_HOSTAP:
a1629 1

a1630 1
	case IEEE80211_M_AHDEMO:
a1632 1

d1636 3
a1639 1

d1643 1
a1643 1
	if (size < sizeof (struct ipw_firmware_hdr)) {
d1647 2
a1648 4

	p = fw->data;
	hdr = (struct ipw_firmware_hdr *)p;
	fw->main_size = letoh32(hdr->main_size);
d1651 1
a1651 4
	p += sizeof (struct ipw_firmware_hdr);
	size -= sizeof (struct ipw_firmware_hdr);

	if (size < fw->main_size + fw->ucode_size) {
d1655 2
a1656 4

	fw->main = p;
	fw->ucode = p + fw->main_size;
	sc->fw_data = fw->data;
a1678 1
	case IEEE80211_M_HOSTAP:
a1680 1

a1681 1
	case IEEE80211_M_AHDEMO:
a1683 1

d1687 3
a1877 1

a1908 1

d1910 1
a1922 1

a1951 8

	/*
	 * Free memory claimed by firmware.
	 */
	if (sc->fw_data) {
		free(sc->fw_data, M_DEVBUF);
		sc->fw_data = NULL;
	}
@


1.70
log
@update the physical address of the RX buffer after bus_dmamap_load()
in the case where the old buffer is remapped.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.69 2007/09/07 19:05:05 damien Exp $	*/
d1672 1
d1971 8
@


1.69
log
@use new malloc M_ZERO flag to shrink kernel.
remove <malloc.h> from files where malloc is not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.68 2007/08/28 18:34:38 deraadt Exp $	*/
d863 1
@


1.68
log
@unify firmware load failure messages; ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.67 2007/07/18 18:10:31 damien Exp $	*/
a42 1
#include <sys/malloc.h>
@


1.67
log
@replace the ieee80211_wepkey structure with a more generic ieee80211_key
one that can be used with other ciphers than WEP.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.66 2007/01/03 18:19:06 claudio Exp $	*/
d1890 2
a1891 1
		printf("%s: could not read firmware\n", sc->sc_dev.dv_xname);
@


1.66
log
@M_DUP_PKTHDR() cleanup. On static mbufs M_DUP_PKTHDR() will leak mbuf tags.
See similar commit to dev/usb/if_rum.c for more info. With this commit
all drivers have been switched away from the incorrect M_DUP_PKTHDR() usage.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.65 2006/11/26 11:14:22 deraadt Exp $	*/
d1685 1
a1685 1
	struct ieee80211_wepkey *k;
d1824 1
a1824 1
			if (k->wk_len == 0)
d1828 1
a1828 1
			wepkey.len = k->wk_len;
d1830 1
a1830 1
			bcopy(k->wk_key, wepkey.key, k->wk_len);
@


1.65
log
@do not have each net80211 driver define its own rates structures.  if they use
the standard rates, use some defined by net80211 itself.  kernel shrinks a bit
ok jsg mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.64 2006/10/23 18:19:26 damien Exp $	*/
a885 1
		M_DUP_PKTHDR(&mb, m);
d889 3
a891 1
		mb.m_pkthdr.len += mb.m_len;
a1150 1
		M_DUP_PKTHDR(&mb, m);
d1154 3
a1156 1
		mb.m_pkthdr.len += mb.m_len;
@


1.64
log
@remove detach() function. this is not hotplug and this is dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.63 2006/09/18 16:20:20 damien Exp $	*/
a75 3
static const struct ieee80211_rateset ipw_rateset_11b =
	{ 4, { 2, 4, 11, 22 } };

d253 1
a253 1
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ipw_rateset_11b;
@


1.63
log
@don't use IF_PREPEND() on altq's.
use IFQ_POLL()/IFQ_DEQUEUE() logic instead as described in altq(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.62 2006/08/19 14:57:37 damien Exp $	*/
a80 1
int		ipw_detach(struct device *, int);
d145 1
a145 1
	sizeof (struct ipw_softc), ipw_match, ipw_attach, ipw_detach
a297 23
}

int
ipw_detach(struct device *self, int flags)
{
	struct ipw_softc *sc = (struct ipw_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	ipw_stop(ifp, 1);

	ieee80211_ifdetach(ifp);
	if_detach(ifp);

	ipw_release(sc);

	if (sc->sc_ih != NULL) {
		pci_intr_disestablish(sc->sc_pct, sc->sc_ih);
		sc->sc_ih = NULL;
	}

	bus_space_unmap(sc->sc_st, sc->sc_sh, sc->sc_sz);

	return 0;
@


1.62
log
@tweak dma sync ops
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.61 2006/08/19 12:03:05 damien Exp $	*/
d1332 1
a1332 1
		IF_DEQUEUE(&ifp->if_snd, m);
a1336 1
			IF_PREPEND(&ifp->if_snd, m);
d1340 1
a1340 1

@


1.61
log
@get rid of shared auth mode.
the ioctl is not supported by ifconfig and it has never worked anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.60 2006/08/19 11:16:55 damien Exp $	*/
d1266 1
a1266 1
			 IPW_BD_FLAG_TX_NOT_LAST_FRAGMENT;
d1309 2
a1311 3
	    BUS_DMASYNC_PREWRITE);

	bus_dmamap_sync(sc->sc_dmat, sbuf->map, 0, MCLBYTES,
@


1.60
log
@remove unused prototypes.
don't check for fatal errors on IPW_INTR_FW_INIT_DONE interrupts as it has
already been check beforehand.
cosmetic while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.59 2006/08/18 16:04:56 damien Exp $	*/
a265 3
	/* default to authmode OPEN */
	sc->authmode = IEEE80211_AUTH_OPEN;

d1126 1
a1126 1
			 IPW_BD_FLAG_TX_LAST_FRAGMENT;
a1442 12
	case SIOCG80211AUTH:
		((struct ieee80211_auth *)data)->i_authtype = sc->authmode;
		break;

	case SIOCS80211AUTH:
		/* only super-user can do that! */
		if ((error = suser(curproc, 0)) != 0)
			break;

		sc->authmode = ((struct ieee80211_auth *)data)->i_authtype;
		break;

d1840 1
a1840 2
	security.authmode = (sc->authmode == IEEE80211_AUTH_SHARED) ?
	    IPW_AUTH_SHARED : IPW_AUTH_OPEN;
@


1.59
log
@set of unrelated cosmetic tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.58 2006/06/14 18:40:23 brad Exp $	*/
a103 2
int		ipw_get_table1(struct ipw_softc *, uint32_t *);
int		ipw_get_radio(struct ipw_softc *, int *);
d292 1
a292 1
	    sizeof (struct ieee80211_frame) + 64);
d1079 1
a1079 1
		ipw_stop(&sc->sc_ic.ic_if, 1);
d1083 2
a1084 4
	if (r & IPW_INTR_FW_INIT_DONE) {
		if (!(r & (IPW_INTR_FATAL_ERROR | IPW_INTR_PARITY_ERROR)))
			wakeup(sc);
	}
@


1.58
log
@clear the IFF_UP interface flag before shutting down the interface.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.57 2006/05/17 19:54:10 damien Exp $	*/
d30 2
a31 3
/*-
 * Intel(R) PRO/Wireless 2100 MiniPCI driver
 * http://www.intel.com/network/connectivity/products/wireless/prowireless_mobile.htm
d233 1
a233 1
	ic->ic_opmode = IEEE80211_M_STA;
d237 7
a243 3
	ic->ic_caps = IEEE80211_C_IBSS | IEEE80211_C_MONITOR |
	    IEEE80211_C_PMGT | IEEE80211_C_TXPMGT | IEEE80211_C_WEP |
	    IEEE80211_C_SHPREAMBLE | IEEE80211_C_SCANALL;
d1164 3
a1166 1
	if (ic->ic_flags & IEEE80211_F_WEPON) {
d1170 3
a1192 2
	wh = mtod(m, struct ieee80211_frame *);

d2041 1
a2041 1
	0, "ipw", DV_IFNET
@


1.57
log
@sync handling of fatal firmware errors w/ wpi(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.56 2006/03/25 22:41:45 djm Exp $	*/
d304 1
a304 1
ipw_detach(struct device* self, int flags)
d806 1
d838 1
d1064 1
d1077 1
d1381 1
@


1.56
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.55 2006/02/26 19:14:39 damien Exp $	*/
d1073 1
a1073 1
		printf("%s: fatal error\n", sc->sc_dev.dv_xname);
d1075 1
@


1.55
log
@prettify + u_int{8,16,32}_t -> uint{8,16,32}_t
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.54 2006/01/10 17:50:28 damien Exp $	*/
d918 1
a918 1
		bpf_mtap(sc->sc_drvbpf, &mb);
d1176 1
a1176 1
		bpf_mtap(sc->sc_drvbpf, &mb);
d1341 1
a1341 1
			bpf_mtap(ifp->if_bpf, m);
d1350 1
a1350 1
			bpf_mtap(ic->ic_rawbpf, m);
@


1.54
log
@fix reading of EEPROM content on big endian arches.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.53 2006/01/04 06:04:41 canacar Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004, 2005
d80 44
a123 39
int ipw_match(struct device *, void *, void *);
void ipw_attach(struct device *, struct device *, void *);
int ipw_detach(struct device *, int);
void ipw_power(int, void *);
int ipw_dma_alloc(struct ipw_softc *);
void ipw_release(struct ipw_softc *);
int ipw_media_change(struct ifnet *);
void ipw_media_status(struct ifnet *, struct ifmediareq *);
int ipw_newstate(struct ieee80211com *, enum ieee80211_state, int);
u_int16_t ipw_read_prom_word(struct ipw_softc *, u_int8_t);
void ipw_command_intr(struct ipw_softc *, struct ipw_soft_buf *);
void ipw_newstate_intr(struct ipw_softc *, struct ipw_soft_buf *);
void ipw_data_intr(struct ipw_softc *, struct ipw_status *,
    struct ipw_soft_bd *, struct ipw_soft_buf *);
void ipw_notification_intr(struct ipw_softc *, struct ipw_soft_buf *);
void ipw_rx_intr(struct ipw_softc *);
void ipw_release_sbd(struct ipw_softc *, struct ipw_soft_bd *);
void ipw_tx_intr(struct ipw_softc *);
int ipw_intr(void *);
int ipw_cmd(struct ipw_softc *, u_int32_t, void *, u_int32_t);
int ipw_tx_start(struct ifnet *, struct mbuf *, struct ieee80211_node *);
void ipw_start(struct ifnet *);
void ipw_watchdog(struct ifnet *);
int ipw_get_table1(struct ipw_softc *, u_int32_t *);
int ipw_get_radio(struct ipw_softc *, int *);
int ipw_ioctl(struct ifnet *, u_long, caddr_t);
u_int32_t ipw_read_table1(struct ipw_softc *, u_int32_t);
void ipw_write_table1(struct ipw_softc *, u_int32_t, u_int32_t);
int ipw_read_table2(struct ipw_softc *, u_int32_t, void *, u_int32_t *);
void ipw_stop_master(struct ipw_softc *);
int ipw_reset(struct ipw_softc *);
int ipw_load_ucode(struct ipw_softc *, u_char *, int);
int ipw_load_firmware(struct ipw_softc *, u_char *, int);
int ipw_read_firmware(struct ipw_softc *, struct ipw_firmware *);
int ipw_config(struct ipw_softc *);
int ipw_init(struct ifnet *);
void ipw_stop(struct ifnet *, int);
void ipw_read_mem_1(struct ipw_softc *, bus_size_t, u_int8_t *, bus_size_t);
void ipw_write_mem_1(struct ipw_softc *, bus_size_t, u_int8_t *, bus_size_t);
d125 2
a126 1
static __inline u_int8_t MEM_READ_1(struct ipw_softc *sc, u_int32_t addr)
d132 2
a133 1
static __inline u_int32_t MEM_READ_4(struct ipw_softc *sc, u_int32_t addr)
d140 2
a141 2
#define DPRINTF(x)	if (ipw_debug > 0) printf x
#define DPRINTFN(n, x)	if (ipw_debug >= (n)) printf x
d180 1
a180 1
	u_int16_t val;
d358 1
a358 1
	 * Allocate and map tx ring
d393 1
a393 1
	 * Allocate and map rx ring
d428 1
a428 1
	 * Allocate and map status ring
d463 1
a463 1
	 * Allocate command DMA map
d474 1
a474 1
	 * Allocate headers DMA maps
d490 1
a490 1
	 * Allocate tx buffers DMA maps
d506 1
a506 1
	 * Initialize tx ring
d515 1
a515 1
	 * Pre-allocate rx buffers and DMA maps
d645 1
a647 1
#define N(a)	(sizeof (a) / sizeof (a[0]))
d649 1
a649 1
		u_int32_t	val;
d657 1
a657 1
	u_int32_t val;
d700 2
a701 2
	u_int8_t macaddr[IEEE80211_ADDR_LEN];
	u_int32_t len;
d705 1
a705 1
		DELAY(100); /* firmware needs a short delay here */
d733 2
a734 2
u_int16_t
ipw_read_prom_word(struct ipw_softc *sc, u_int8_t addr)
d736 2
a737 2
	u_int32_t tmp;
	u_int16_t val;
d740 1
a740 1
	/* Clock C once before the first command */
d746 1
a746 1
	/* Write start bit (1) */
d750 1
a750 1
	/* Write READ opcode (10) */
d756 1
a756 1
	/* Write address A7-A0 */
d766 1
a766 1
	/* Read data Q15-Q0 */
d777 1
a777 1
	/* Clear Chip Select and clock C */
d806 1
a806 1
	u_int32_t state;
d811 1
a811 1
	state = letoh32(*mtod(sbuf->m, u_int32_t *));
d899 1
a899 1
	/* Finalize mbuf */
d926 1
a926 1
	/* Send the frame to the upper layer */
d944 1
a944 1
	u_int32_t r, i;
d991 1
a991 1
	/* Tell the firmware what we have processed */
d1036 1
a1036 1
	u_int32_t r, i;
d1050 1
a1050 1
	/* Remember what the firmware has processed */
d1053 1
a1053 1
	/* Call start() since some buffer descriptors have been released */
d1062 1
a1062 1
	u_int32_t r;
d1067 1
a1067 1
	/* Disable interrupts */
d1088 1
a1088 1
	/* Acknowledge interrupts */
d1091 1
a1091 1
	/* Re-enable interrupts */
d1098 1
a1098 1
ipw_cmd(struct ipw_softc *sc, u_int32_t type, void *data, u_int32_t len)
d1140 1
a1140 1
	/* Wait at most one second for command to complete */
d1283 1
a1283 1
		sbd->bd->nfrag = 0; /* used only in first bd */
d1311 1
a1311 1
	/* Inform firmware about this new packet */
d1465 2
a1466 2
u_int32_t
ipw_read_table1(struct ipw_softc *sc, u_int32_t off)
d1472 1
a1472 1
ipw_write_table1(struct ipw_softc *sc, u_int32_t off, u_int32_t info)
d1478 1
a1478 1
ipw_read_table2(struct ipw_softc *sc, u_int32_t off, void *buf, u_int32_t *len)
d1480 3
a1482 3
	u_int32_t addr, info;
	u_int16_t count, size;
	u_int32_t total;
d1508 1
a1508 1
	/* Disable interrupts */
d1534 1
a1534 1
	/* Move adapter to D0 state */
d1538 1
a1538 1
	/* Wait for clock stabilization */
d1614 2
a1615 2
	u_int32_t dst;
	u_int16_t len;
d1637 1
a1637 1
	/* Allow interrupts so we know when the firmware is inited */
d1640 1
a1640 1
	/* Tell the adapter to initialize the firmware */
d1645 1
a1645 1
	/* Wait at most one second for firmware initialization to complete */
d1723 1
a1723 1
	u_int32_t data;
d1773 2
a1774 2
	config.bss_chan = htole32(0x3fff); /* channels 1-14 */
	config.ibss_chan = htole32(0x7ff); /* channels 1-11 */
d1780 1
a1780 1
	data = htole32(0x3); /* 1, 2 */
d1786 1
a1786 1
	data = htole32(0xf); /* 1, 2, 5.5, 11 */
d1799 1
a1799 1
		data = htole32(32); /* default value */
d1899 1
a1899 1
	options.channels = htole32(0x3fff); /* scan channels 1-14 */
d1937 1
a1937 1
	 * Setup tx, rx and status rings
d1943 1
a1943 1
	sc->txold = IPW_NTBD - 1; /* latest bd index ack'ed by firmware */
d1951 1
a1951 1
	sc->rxcur = IPW_NRBD - 1; /* latest bd index I've read */
d1963 1
a1963 1
	/* Retrieve information tables base addresses */
d2000 1
a2000 1
	 * Release tx buffers
d2009 1
a2009 1
ipw_read_mem_1(struct ipw_softc *sc, bus_size_t offset, u_int8_t *datap,
d2019 1
a2019 1
ipw_write_mem_1(struct ipw_softc *sc, bus_size_t offset, u_int8_t *datap,
@


1.53
log
@Remove redundant calls to bpfdetach.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.52 2005/11/23 21:29:05 damien Exp $	*/
d775 1
a775 1
	return letoh16(val);
@


1.52
log
@When defragmenting a mbuf chain before transmitting it, don't allocate a mbuf
cluster if the payload fits in the header.

From NetBSD (scw@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.51 2005/11/23 21:15:29 damien Exp $	*/
a303 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
@


1.51
log
@Be more robust when handling Rx interrupts.  If we can't allocate and DMA map
a new mbuf, just discard the received frame and reuse the old mbuf.

From NetBSD (joerg@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.50 2005/08/09 04:10:12 mickey Exp $	*/
d1214 7
a1220 5
		MCLGET(mnew, M_DONTWAIT);
		if (!(mnew->m_flags & M_EXT)) {
			m_freem(m);
			m_freem(mnew);
			return ENOMEM;
@


1.50
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.49 2005/07/30 18:04:41 claudio Exp $	*/
d844 1
a844 1
	struct mbuf *m;
d851 19
d872 18
d891 3
a893 1
	bus_dmamap_unload(sc->sc_dmat, sbuf->map);
a895 1
	m = sbuf->m;
a925 26

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL) {
		printf("%s: could not allocate rx mbuf\n",
		    sc->sc_dev.dv_xname);
		return;
	}
	MCLGET(m, M_DONTWAIT);
	if (!(m->m_flags & M_EXT)) {
		m_freem(m);
		printf("%s: could not allocate rx mbuf cluster\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	error = bus_dmamap_load(sc->sc_dmat, sbuf->map, mtod(m, void *),
	    MCLBYTES, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not map rx DMA memory\n",
		    sc->sc_dev.dv_xname);
		m_freem(m);
		return;
	}

	sbuf->m = m;
	sbd->bd->physaddr = htole32(sbuf->map->dm_segs[0].ds_addr);
@


1.49
log
@Use ic->ic_ibss_chan instead of ic->ic_bss->ni_chan when filling a
ipw_tx_radiotap_header struct. This fixes a panic I got when using
tcpdump -nvi ipw0 -y ieee802_11_radio.
OK reyk@@ damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.48 2005/07/02 23:10:11 brad Exp $	*/
a182 5

	/* enable bus-mastering */
	data = pci_conf_read(sc->sc_pct, sc->sc_pcitag, PCI_COMMAND_STATUS_REG);
	data |= PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, PCI_COMMAND_STATUS_REG, data);
@


1.48
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.47 2005/04/17 13:41:46 damien Exp $	*/
d873 2
a874 2
		tap->wr_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wr_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);
d1157 2
a1158 2
		tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);
@


1.47
log
@don't disassociate on SIOCSIFADDR if the interface is already up and running.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.46 2005/04/04 16:32:42 damien Exp $	*/
d1983 3
a1990 3

	ifp->if_timer = 0;
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.46
log
@fix ids. ok jsg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.45 2005/03/23 14:14:30 damien Exp $	*/
d1386 1
a1386 1
		ifa = (struct ifaddr *) data;
a1387 1
		switch (ifa->ifa_addr->sa_family) {
d1389 1
a1389 1
		case AF_INET:
a1390 2
			ipw_init(ifp);
			break;
d1392 1
a1392 5
		default:
			ipw_init(ifp);
		}
		break;

@


1.45
log
@do packet accounting (opackets/oerrors/ierrors).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.44 2005/03/17 20:08:13 damien Exp $	*/
d151 1
a151 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_PRO_2100_3B)
@


1.44
log
@support for ipv6.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.43 2005/03/12 13:23:30 damien Exp $	*/
d1024 1
d1030 6
a1035 1
		ipw_release_sbd(sc, &sc->stbd_list[i]);
d1343 1
d1364 1
@


1.43
log
@retrieve scan results from net80211 instead of reading NIC internal memory.
this fixes a bug with multiple AP's.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.42 2005/02/21 13:33:29 damien Exp $	*/
d1369 1
d1371 1
d1383 1
a1383 1
			arp_ifinit(&sc->sc_ic.ic_ac, ifa);
d1402 11
d1440 1
a1440 1
	if (error == ENETRESET && cmd != SIOCADDMULTI) {
@


1.42
log
@ipwcontrol and iwicontrol removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.41 2005/02/19 13:08:55 damien Exp $	*/
a89 1
void ipw_scan_result(struct ipw_softc *);
d238 1
a238 1
	    IEEE80211_C_SHPREAMBLE;
d700 2
a701 1
	struct ieee80211_node *ni = ic->ic_bss;
a702 1
	u_int8_t val;
d706 1
a706 3
		len = IEEE80211_NWID_LEN;
		ipw_read_table2(sc, IPW_INFO_CURRENT_SSID, ni->ni_essid, &len);
		ni->ni_esslen = len;
d708 2
a709 2
		val = ipw_read_table1(sc, IPW_INFO_CURRENT_CHANNEL);
		ni->ni_chan = &ic->ic_channels[val];
d711 3
a713 1
		DELAY(100); /* firmware needs a short delay here */
d715 2
a716 2
		len = IEEE80211_ADDR_LEN;
		ipw_read_table2(sc, IPW_INFO_CURRENT_BSSID, ni->ni_bssid, &len);
a786 51
ipw_scan_result(struct ipw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	u_int32_t i, cnt, off;
	struct ipw_node ap;

	/* flush previously seen access points */
	ieee80211_free_allnodes(ic);

	cnt = ipw_read_table1(sc, IPW_INFO_APS_CNT);
	off = ipw_read_table1(sc, IPW_INFO_APS_BASE);

	DPRINTF(("Found %u APs\n", cnt));

	for (i = 0; i < cnt; i++) {
		ipw_read_mem_1(sc, off, (u_int8_t *)&ap, sizeof ap);
		off += sizeof ap;

#ifdef IPW_DEBUG
		if (ipw_debug >= 2) {
			u_char *p = (u_char *)&ap;
			int j;

			printf("AP%u\n", i);
			for (j = 0; j < sizeof ap; j++)
				printf("%02x", *p++);
			printf("\n");
		}
#endif

		ni = ieee80211_lookup_node(ic, ap.bssid,
		    &ic->ic_channels[ap.chan]);
		if (ni != NULL)
			continue;

		ni = ieee80211_alloc_node(ic, ap.bssid);
		if (ni == NULL)
			return;

		IEEE80211_ADDR_COPY(ni->ni_bssid, ap.bssid);
		ni->ni_rssi = ap.rssi;
		ni->ni_intval = letoh16(ap.intval);
		ni->ni_capinfo = letoh16(ap.capinfo);
		ni->ni_chan = &ic->ic_channels[ap.chan];
		ni->ni_esslen = ap.esslen;
		bcopy(ap.essid, ni->ni_essid, IEEE80211_NWID_LEN);
	}
}

void
d825 2
d830 1
a830 1
		ipw_scan_result(sc);
@


1.41
log
@fix setting of the MAC address.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.40 2005/02/17 18:28:05 reyk Exp $	*/
a1415 28
ipw_get_table1(struct ipw_softc *sc, u_int32_t *tbl)
{
	u_int32_t i, size, buf[256];

	if (!(sc->flags & IPW_FLAG_FW_INITED)) {
		bzero(buf, sizeof buf);
		return copyout(buf, tbl, sizeof buf);
	}

	CSR_WRITE_4(sc, IPW_CSR_AUTOINC_ADDR, sc->table1_base);

	size = min(CSR_READ_4(sc, IPW_CSR_AUTOINC_DATA), 256);
	for (i = 1; i < size; i++)
		buf[i] = MEM_READ_4(sc, CSR_READ_4(sc, IPW_CSR_AUTOINC_DATA));

	return copyout(buf, tbl, sizeof buf);
}

int
ipw_get_radio(struct ipw_softc *sc, int *ret)
{
	int val;

	val = (CSR_READ_4(sc, IPW_CSR_IO) & IPW_IO_RADIO_DISABLED) ? 0 : 1;
	return copyout(&val, ret, sizeof val);
}

int
a1418 1
	struct ifreq *ifr;
d1450 9
a1458 8
	case SIOCGTABLE1:
		ifr = (struct ifreq *)data;
		error = ipw_get_table1(sc, (u_int32_t *)ifr->ifr_data);
		break;

	case SIOCGRADIO:
		ifr = (struct ifreq *)data;
		error = ipw_get_radio(sc, (int *)ifr->ifr_data);
@


1.40
log
@derived from NetBSD:

---
Make the node table into an LRU cache: least-recently used nodes
are at the end of the node queue.  Change the reference-counting
discipline: ni->ni_refcnt indicates how many times net80211 has
granted ni to the driver.  Every node in the table with ni_refcnt=0
is eligible to be garbage-collected.  The mere presence of a node
in the table does not any longer indicate its auth/assoc state;
nodes have a ni_state variable, now.

While I am here, patch ieee80211_find_node_for_beacon to do a "best
match" by bssid/ssid/channel, not a "perfect match."  This keeps
net80211 from caching duplicate nodes in the table.
---

ok deraadt@@ dlg@@, looks good jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.39 2005/01/13 20:52:13 damien Exp $	*/
d1811 1
a1811 2
	IEEE80211_ADDR_COPY(((struct arpcom *)ifp)->ac_enaddr, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(LLADDR(ifp->if_sadl), ic->ic_myaddr);
@


1.39
log
@fix a critical bug that made the kernel crash under heavy upstream traffic
load. pointed out by jcs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ipw.c,v 1.38 2005/01/05 09:07:16 jsg Exp $	*/
d942 1
a942 4
	if (ni == ic->ic_bss)
		ieee80211_unref_node(&ni);
	else
		ieee80211_free_node(ic, ni);
d1060 2
a1061 2
		if (sbuf->ni != NULL && sbuf->ni != ic->ic_bss)
			ieee80211_free_node(ic, sbuf->ni);
d1385 2
a1386 2
			if (ni != NULL && ni != ic->ic_bss)
				ieee80211_free_node(ic, ni);
@


1.38
log
@Use $OpenBSD$ instead of $Id$. ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 2004
d1090 2
a1091 4
	if (sc->txfree >= 1 + IPW_MAX_NSEG) {
		ifp->if_flags &= ~IFF_OACTIVE;
		(*ifp->if_start)(ifp);
	}
a1347 3
	if (sc->txfree < 1 + IPW_MAX_NSEG)
		ifp->if_flags |= IFF_OACTIVE;

d1366 6
@


1.37
log
@add powerhooks
OK claudio@@ kevlo@@ deraadt@@
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.36 2004/12/10 21:25:52 damien Exp $  */
@


1.36
log
@fix mbuf defragmentation
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.35 2004/12/06 20:27:15 damien Exp $  */
d83 1
d178 1
d180 2
a181 1
	data = pci_conf_read(sc->sc_pct, pa->pa_tag, 0x40);
d183 1
a183 1
	pci_conf_write(sc->sc_pct, pa->pa_tag, 0x40, data);
d186 1
a186 1
	data = pci_conf_read(sc->sc_pct, pa->pa_tag, PCI_COMMAND_STATUS_REG);
d188 1
a188 1
	pci_conf_write(sc->sc_pct, pa->pa_tag, PCI_COMMAND_STATUS_REG, data);
d286 2
d326 23
@


1.35
log
@add mbuf linearization code when the number of fragments exceeds what is
supported by the hardware
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.34 2004/12/05 20:19:30 damien Exp $  */
d1237 1
a1237 1
		m->m_len = m->m_pkthdr.len;
@


1.34
log
@fix printf's in ipw_dma_alloc()
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.33 2004/12/05 20:00:38 damien Exp $  */
d1163 1
d1212 1
a1212 1
	if (error != 0) {
d1217 31
@


1.33
log
@add IEEE80211_C_SHPREAMBLE capability flag and reorder interrupt handlers
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.32 2004/12/05 19:54:03 damien Exp $  */
d337 2
a338 1
		printf("%s: could not create tx ring DMA map\n");
d345 2
a346 1
		printf("%s: could not allocate tx ring DMA memory\n");
d353 2
a354 1
		printf("%s: could not map tx ring DMA memory\n");
d361 2
a362 1
		printf("%s: could not load tx ring DMA map\n");
d372 2
a373 1
		printf("%s: could not create rx ring DMA map\n");
d380 2
a381 1
		printf("%s: could not allocate rx ring DMA memory\n");
d388 2
a389 1
		printf("%s: could not map rx ring DMA memory\n");
d396 2
a397 1
		printf("%s: could not load tx ring DMA map\n");
d407 2
a408 1
		printf("%s: could not create status ring DMA map\n");
d415 2
a416 1
		printf("%s: could not allocate status ring DMA memory\n");
d423 2
a424 1
		printf("%s: could not map status ring DMA memory\n");
d431 2
a432 1
		printf("%s: could not load status ring DMA map\n");
d442 2
a443 1
		printf("%s: could not create command DMA map\n");
d456 2
a457 1
			printf("%s: could not create header DMA map\n");
d472 2
a473 1
			printf("%s: could not create tx DMA map\n");
d498 2
a499 1
			printf("%s: could not allocate rx mbuf\n");
d507 2
a508 1
			printf("%s: could not allocate rx mbuf cluster\n");
d516 2
a517 1
			printf("%s: could not create rx DMA map\n");
d524 2
a525 1
			printf("%s: could not map rx DMA memory\n");
@


1.32
log
@update net80211 AP list after scanning
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.31 2004/12/05 19:39:22 damien Exp $  */
d234 3
a236 2
	ic->ic_caps =  IEEE80211_C_IBSS | IEEE80211_C_MONITOR |
	    IEEE80211_C_PMGT | IEEE80211_C_TXPMGT | IEEE80211_C_WEP;
d655 2
a656 1
	u_int32_t val, len;
d1063 4
a1066 5
	if (r & IPW_INTR_RX_TRANSFER)
		ipw_rx_intr(sc);

	if (r & IPW_INTR_TX_TRANSFER)
		ipw_tx_intr(sc);
d1073 5
a1077 4
	if (r & (IPW_INTR_FATAL_ERROR | IPW_INTR_PARITY_ERROR)) {
		printf("%s: fatal error\n", sc->sc_dev.dv_xname);
		ipw_stop(&sc->sc_ic.ic_if, 1);
	}
@


1.31
log
@mostly cosmetic changes
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.30 2004/12/05 17:46:07 damien Exp $  */
d89 1
d739 51
d828 4
@


1.30
log
@Clean Tx/Rx rings allocation and management.
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.29 2004/12/05 17:13:52 damien Exp $  */
d834 1
a834 1
	/* Send it up to the upper layer */
d859 1
a859 1
		printf("%s: could not map rxbuf dma memory\n",
d1041 1
a1041 1
		printf("%s: could not map cmd dma memory\n",
a1132 4
	/*
	 * We need to map the mbuf first to know how many buffer descriptors
	 * are needed for this transfer.
	 */
d1144 1
a1144 1
		printf("%s: could not map header (error %d)\n",
d1292 1
a1292 1
	size = CSR_READ_4(sc, IPW_CSR_AUTOINC_DATA);
d1296 1
a1296 1
	return copyout(buf, tbl, size * sizeof (u_int32_t));
d1657 1
a1657 1
	DPRINTF(("Setting adapter mode to %u\n", data));
d1665 1
a1665 1
		DPRINTF(("Setting adapter channel to %u\n", data));
a1675 1
	DPRINTF(("Setting adapter MAC to %s\n", ether_sprintf(ic->ic_myaddr)));
d1678 1
d1685 1
a1685 1
			       IPW_CFG_PREAMBLE_LEN | IPW_CFG_802_1x_ENABLE);
d1690 3
a1692 3
	config.channels = htole32(0x3fff); /* channels 1-14 */
	config.ibss_chan = htole32(0x7ff);
	DPRINTF(("Setting adapter configuration 0x%08x\n", config.flags));
d1698 1
a1698 1
	DPRINTF(("Setting adapter basic tx rates to 0x%x\n", data));
d1704 1
a1704 1
	DPRINTF(("Setting adapter tx rates to 0x%x\n", data));
d1710 1
a1710 1
	DPRINTF(("Setting adapter power mode to %u\n", data));
d1716 2
a1717 2
		data = htole32(ic->ic_txpower);
		DPRINTF(("Setting adapter tx power index to %u\n", data));
d1725 1
a1725 1
	DPRINTF(("Setting adapter RTS threshold to %u\n", data));
d1731 1
a1731 1
	DPRINTF(("Setting adapter frag threshold to %u\n", data));
d1738 1
a1738 1
		printf("Setting adapter ESSID to ");
d1749 1
d1755 1
a1755 1
		DPRINTF(("Setting adapter desired BSSID to %s\n",
d1763 1
d1767 1
a1767 4
	security.version = htole16(0);
	security.replay_counters_number = 0;
	security.unicast_using_group = 0;
	DPRINTF(("Setting adapter authmode to %u\n", security.authmode));
d1783 1
a1783 1
			DPRINTF(("Setting wep key index %d len %d\n",
d1792 1
a1792 1
		DPRINTF(("Setting adapter tx key index to %u\n", data));
d1799 2
a1800 2
	data = htole32((sc->sc_ic.ic_flags & IEEE80211_F_WEPON) ? 0x8 : 0);
	DPRINTF(("Setting adapter wep flags to 0x%x\n", data));
d1808 1
a1808 1
		DPRINTF(("Setting adapter beacon interval to %u\n", data));
d1817 1
@


1.29
log
@wait longer for master initialization
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.28 2004/11/24 21:27:50 damien Exp $  */
d83 2
a107 6
int ipw_dmamem_init(struct ipw_softc *);
void ipw_dmamem_stop(struct ipw_softc *);
int ipw_tx_init(struct ipw_softc *);
void ipw_tx_stop(struct ipw_softc *);
int ipw_rx_init(struct ipw_softc *);
void ipw_rx_stop(struct ipw_softc *);
d223 2
a224 3
	/* set up dma memory */
	if (ipw_dmamem_init(sc) != 0) {
		printf(": failed to initialize DMA memory\n");
a301 1
	ipw_dmamem_stop(sc);
d309 2
d322 259
d936 1
a936 1
	struct ieee80211com *ic;
d948 1
a948 1
		TAILQ_INSERT_TAIL(&sc->sc_free_shdr, shdr, next);
a951 1
		ic = &sc->sc_ic;
d954 2
d957 1
d960 1
a962 1
		TAILQ_INSERT_TAIL(&sc->sc_free_sbuf, sbuf, next);
d976 1
a976 1
	for (i = (sc->txold + 1) % IPW_NTBD; i != r; i = (i + 1) % IPW_NTBD)
d978 2
d985 4
a988 2
	ifp->if_flags &= ~IFF_OACTIVE;
	(*ifp->if_start)(ifp);
d1038 1
a1038 1
	error = bus_dmamap_load(sc->sc_dmat, sc->cmd_map, sc->cmd,
d1046 4
a1049 4
	sc->cmd->type = htole32(type);
	sc->cmd->subtype = htole32(0);
	sc->cmd->len = htole32(len);
	sc->cmd->seq = htole32(0);
d1051 1
a1051 1
		bcopy(data, sc->cmd->data, len);
d1068 1
d1114 2
a1115 2
	shdr = TAILQ_FIRST(&sc->sc_free_shdr);
	sbuf = TAILQ_FIRST(&sc->sc_free_sbuf);
d1155 2
a1156 2
	TAILQ_REMOVE(&sc->sc_free_sbuf, sbuf, next);
	TAILQ_REMOVE(&sc->sc_free_shdr, shdr, next);
d1177 1
d1205 1
d1217 3
a1422 409
/*
 * Allocate and map DMAble memory.  Do not call in interrupt context.
 */
int
ipw_dmamem_init(struct ipw_softc *sc)
{
	int error, nsegs;
	char *errmsg;

	error = bus_dmamem_alloc(sc->sc_dmat, IPW_TBD_SZ, PAGE_SIZE, 0,
	    &sc->tbd_seg, 1, &nsegs, BUS_DMA_NOWAIT);
	if (error != 0) {
		errmsg = "could not allocate tbd dma memory";
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &sc->tbd_seg, nsegs, IPW_TBD_SZ,
	    (caddr_t *)&sc->tbd_list, BUS_DMA_NOWAIT);
	if (error != 0) {
		errmsg = "could not map tbd dma memory";
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat, sizeof (struct ipw_cmd),
	    PAGE_SIZE, 0, &sc->cmd_seg, 1, &nsegs, BUS_DMA_NOWAIT);
	if (error != 0) {
		errmsg = "could not allocate cmd dma memory";
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &sc->cmd_seg, nsegs,
	    sizeof (struct ipw_cmd), (caddr_t *)&sc->cmd, BUS_DMA_NOWAIT);
	if (error != 0) {
		errmsg = "could not map cmd dma memory";
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat, IPW_RBD_SZ, PAGE_SIZE, 0,
	    &sc->rbd_seg, 1, &nsegs, BUS_DMA_NOWAIT);
	if (error != 0) {
		errmsg = "could not allocate rbd dma memory";
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &sc->rbd_seg, nsegs, IPW_RBD_SZ,
	    (caddr_t *)&sc->rbd_list, BUS_DMA_NOWAIT);
	if (error != 0) {
		errmsg = "could not map rbd dma memory";
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat, IPW_STATUS_SZ, PAGE_SIZE, 0,
	    &sc->status_seg, 1, &nsegs, BUS_DMA_NOWAIT);
	if (error != 0) {
		errmsg = "could not allocate status dma memory";
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &sc->status_seg, nsegs,
	    IPW_STATUS_SZ, (caddr_t *)&sc->status_list, BUS_DMA_NOWAIT);
	if (error != 0) {
		errmsg = "could not map status dma memory";
		goto fail;
	}

	return 0;

fail:	printf("%s: %s", sc->sc_dev.dv_xname, errmsg);
	ipw_dmamem_stop(sc);

	return error;
}

/*
 * Unmap and free DMAble memory.
 */
void
ipw_dmamem_stop(struct ipw_softc *sc)
{
	if (sc->tbd_list != NULL) {
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->tbd_list,
		    IPW_TBD_SZ);
		bus_dmamem_free(sc->sc_dmat, &sc->tbd_seg, 1);
		sc->tbd_list = NULL;
	}

	if (sc->cmd != NULL) {
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->cmd,
		    sizeof (struct ipw_cmd));
		bus_dmamem_free(sc->sc_dmat, &sc->cmd_seg, 1);
		sc->cmd = NULL;
	}

	if (sc->rbd_list != NULL) {
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->rbd_list,
		    IPW_RBD_SZ);
		bus_dmamem_free(sc->sc_dmat, &sc->rbd_seg, 1);
		sc->rbd_list = NULL;
	}

	if (sc->status_list != NULL) {
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->status_list,
		    IPW_STATUS_SZ);
		bus_dmamem_free(sc->sc_dmat, &sc->status_seg, 1);
		sc->status_list = NULL;
	}
}

int
ipw_tx_init(struct ipw_softc *sc)
{
	char *errmsg;
	struct ipw_bd *bd;
	struct ipw_soft_bd *sbd;
	struct ipw_soft_hdr *shdr;
	struct ipw_soft_buf *sbuf;
	int error, i;

	/* Allocate transmission buffer descriptors */
	error = bus_dmamap_create(sc->sc_dmat, IPW_TBD_SZ, 1, IPW_TBD_SZ, 0,
	    BUS_DMA_NOWAIT, &sc->tbd_map);
	if (error != 0) {
		errmsg = "could not create tbd dma map";
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, sc->tbd_map, sc->tbd_list,
	    IPW_TBD_SZ, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		errmsg = "could not load tbd dma memory";
		goto fail;
	}

	sc->stbd_list = malloc(IPW_NTBD * sizeof (struct ipw_soft_bd),
	    M_DEVBUF, M_NOWAIT);
	if (sc->stbd_list == NULL) {
		errmsg = "could not allocate soft tbd";
		error = ENOMEM;
		goto fail;
	}
	sbd = sc->stbd_list;
	bd = sc->tbd_list;
	for (i = 0; i < IPW_NTBD; i++, sbd++, bd++) {
		sbd->type = IPW_SBD_TYPE_NOASSOC;
		sbd->bd = bd;
	}

	CSR_WRITE_4(sc, IPW_CSR_TX_BD_BASE, sc->tbd_map->dm_segs[0].ds_addr);
	CSR_WRITE_4(sc, IPW_CSR_TX_BD_SIZE, IPW_NTBD);
	CSR_WRITE_4(sc, IPW_CSR_TX_READ_INDEX, 0);
	CSR_WRITE_4(sc, IPW_CSR_TX_WRITE_INDEX, 0);
	sc->txold = IPW_NTBD - 1; /* latest bd index ack'ed by firmware */
	sc->txcur = 0; /* bd index to write to */

	/* Allocate a DMA-able command */
	error = bus_dmamap_create(sc->sc_dmat, sizeof (struct ipw_cmd), 1,
	    sizeof (struct ipw_cmd), 0, BUS_DMA_NOWAIT, &sc->cmd_map);
	if (error != 0) {
		errmsg = "could not create cmd dma map";
		goto fail;
	}

	/* Allocate a pool of DMA-able headers */
	sc->shdr_list = malloc(IPW_NDATA * sizeof (struct ipw_soft_hdr),
	    M_DEVBUF, M_NOWAIT);
	if (sc->shdr_list == NULL) {
		errmsg = "could not allocate soft hdr";
		error = ENOMEM;
		goto fail;
	}
	TAILQ_INIT(&sc->sc_free_shdr);
	for (i = 0, shdr = sc->shdr_list; i < IPW_NDATA; i++, shdr++) {
		error = bus_dmamap_create(sc->sc_dmat,
		    sizeof (struct ipw_soft_hdr), 1,
	 	    sizeof (struct ipw_soft_hdr), 0, BUS_DMA_NOWAIT,
		    &shdr->map);
		if (error != 0) {
			errmsg = "could not create hdr dma map";
			goto fail;
		}
		TAILQ_INSERT_TAIL(&sc->sc_free_shdr, shdr, next);
	}

	/* Allocate a pool of DMA-able buffers */
	sc->tx_sbuf_list = malloc(IPW_NDATA * sizeof (struct ipw_soft_buf),
	    M_DEVBUF, M_NOWAIT);
	if (sc->tx_sbuf_list == NULL) {
		errmsg = "could not allocate soft txbuf";
		error = ENOMEM;
		goto fail;
	}
	TAILQ_INIT(&sc->sc_free_sbuf);
	for (i = 0, sbuf = sc->tx_sbuf_list; i < IPW_NDATA; i++, sbuf++) {
		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, IPW_NDATA,
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &sbuf->map);
		if (error != 0) {
			errmsg = "could not create txbuf dma map";
			goto fail;
		}
		TAILQ_INSERT_TAIL(&sc->sc_free_sbuf, sbuf, next);
	}

	return 0;

fail:	printf("%s: %s\n", sc->sc_dev.dv_xname, errmsg);
	ipw_tx_stop(sc);

	return error;
}

void
ipw_tx_stop(struct ipw_softc *sc)
{
	struct ipw_soft_hdr *shdr;
	struct ipw_soft_buf *sbuf;
	int i;

	if (sc->tbd_map != NULL) {
		if (sc->tbd_list != NULL)
			bus_dmamap_unload(sc->sc_dmat, sc->tbd_map);
		bus_dmamap_destroy(sc->sc_dmat, sc->tbd_map);
		sc->tbd_map = NULL;
	}

	if (sc->stbd_list != NULL) {
		for (i = 0; i < IPW_NTBD; i++)
			ipw_release_sbd(sc, &sc->stbd_list[i]);
		free(sc->stbd_list, M_DEVBUF);
		sc->stbd_list = NULL;
	}

	if (sc->cmd_map != NULL) {
		bus_dmamap_destroy(sc->sc_dmat, sc->cmd_map);
		sc->cmd_map = NULL;
	}

	if (sc->shdr_list != NULL) {
		TAILQ_FOREACH(shdr, &sc->sc_free_shdr, next)
			bus_dmamap_destroy(sc->sc_dmat, shdr->map);
		free(sc->shdr_list, M_DEVBUF);
		sc->shdr_list = NULL;
	}

	if (sc->tx_sbuf_list != NULL) {
		TAILQ_FOREACH(sbuf, &sc->sc_free_sbuf, next)
			bus_dmamap_destroy(sc->sc_dmat, sbuf->map);
		free(sc->tx_sbuf_list, M_DEVBUF);
		sc->tx_sbuf_list = NULL;
	}
}

int
ipw_rx_init(struct ipw_softc *sc)
{
	char *errmsg;
	struct ipw_bd *bd;
	struct ipw_soft_bd *sbd;
	struct ipw_soft_buf *sbuf;
	int error, i;

	/* Allocate reception buffer descriptors */
	error = bus_dmamap_create(sc->sc_dmat, IPW_RBD_SZ, 1, IPW_RBD_SZ, 0,
	    BUS_DMA_NOWAIT, &sc->rbd_map);
	if (error != 0) {
		errmsg = "could not create rbd dma map";
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, sc->rbd_map, sc->rbd_list,
	    IPW_RBD_SZ, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		errmsg = "could not load rbd dma memory";
		goto fail;
	}

	sc->srbd_list = malloc(IPW_NRBD * sizeof (struct ipw_soft_bd),
	    M_DEVBUF, M_NOWAIT);
	if (sc->srbd_list == NULL) {
		errmsg = "could not allocate soft rbd";
		error = ENOMEM;
		goto fail;
	}
	sbd = sc->srbd_list;
	bd = sc->rbd_list;
	for (i = 0; i < IPW_NRBD; i++, sbd++, bd++) {
		sbd->type = IPW_SBD_TYPE_NOASSOC;
		sbd->bd = bd;
	}

	CSR_WRITE_4(sc, IPW_CSR_RX_BD_BASE, sc->rbd_map->dm_segs[0].ds_addr);
	CSR_WRITE_4(sc, IPW_CSR_RX_BD_SIZE, IPW_NRBD);
	CSR_WRITE_4(sc, IPW_CSR_RX_READ_INDEX, 0);
	CSR_WRITE_4(sc, IPW_CSR_RX_WRITE_INDEX, IPW_NRBD - 1);
	sc->rxcur = IPW_NRBD - 1; /* latest bd index I've read */

	/* Allocate status descriptors */
	error = bus_dmamap_create(sc->sc_dmat, IPW_STATUS_SZ, 1, IPW_STATUS_SZ,
	    0, BUS_DMA_NOWAIT, &sc->status_map);
	if (error != 0) {
		errmsg = "could not create status dma map";
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, sc->status_map, sc->status_list,
	    IPW_STATUS_SZ, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		errmsg = "could not load status dma memory";
		goto fail;
	}

	CSR_WRITE_4(sc, IPW_CSR_RX_STATUS_BASE,
	    sc->status_map->dm_segs[0].ds_addr);

	sc->rx_sbuf_list = malloc(IPW_NRBD * sizeof (struct ipw_soft_buf),
	    M_DEVBUF, M_NOWAIT);
	if (sc->rx_sbuf_list == NULL) {
		errmsg = "could not allocate soft rxbuf";
		error = ENOMEM;
		goto fail;
	}

	sbuf = sc->rx_sbuf_list;
	sbd = sc->srbd_list;
	for (i = 0; i < IPW_NRBD; i++, sbuf++, sbd++) {

		MGETHDR(sbuf->m, M_DONTWAIT, MT_DATA);
		if (sbuf->m == NULL) {
			errmsg = "could not allocate rx mbuf";
			error = ENOMEM;
			goto fail;
		}
		MCLGET(sbuf->m, M_DONTWAIT);
		if (!(sbuf->m->m_flags & M_EXT)) {
			m_freem(sbuf->m);
			errmsg = "could not allocate rx mbuf cluster";
			error = ENOMEM;
			goto fail;
		}

		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT, &sbuf->map);
		if (error != 0) {
			m_freem(sbuf->m);
			errmsg = "could not create rxbuf dma map";
			goto fail;
		}
		error = bus_dmamap_load(sc->sc_dmat, sbuf->map,
		    mtod(sbuf->m, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
		if (error != 0) {
			bus_dmamap_destroy(sc->sc_dmat, sbuf->map);
			m_freem(sbuf->m);
			errmsg = "could not map rxbuf dma memory";
			goto fail;
		}
		sbd->type = IPW_SBD_TYPE_DATA;
		sbd->priv = sbuf;
		sbd->bd->physaddr = htole32(sbuf->map->dm_segs[0].ds_addr);
		sbd->bd->len = htole32(MCLBYTES);
	}

	return 0;

fail:	printf("%s: %s\n", sc->sc_dev.dv_xname, errmsg);
	ipw_rx_stop(sc);

	return error;
}

void
ipw_rx_stop(struct ipw_softc *sc)
{
	struct ipw_soft_bd *sbd;
	struct ipw_soft_buf *sbuf;
	int i;

	if (sc->rbd_map != NULL) {
		if (sc->rbd_list != NULL)
			bus_dmamap_unload(sc->sc_dmat, sc->rbd_map);
		bus_dmamap_destroy(sc->sc_dmat, sc->rbd_map);
		sc->rbd_map = NULL;
	}

	if (sc->status_map != NULL) {
		if (sc->status_list != NULL)
			bus_dmamap_unload(sc->sc_dmat, sc->status_map);
		bus_dmamap_destroy(sc->sc_dmat, sc->status_map);
		sc->status_map = NULL;
	}

	if (sc->srbd_list != NULL) {
		for (i = 0, sbd = sc->srbd_list; i < IPW_NRBD; i++, sbd++) {
			if (sbd->type == IPW_SBD_TYPE_NOASSOC)
				continue;

			sbuf = sbd->priv;
			bus_dmamap_unload(sc->sc_dmat, sbuf->map);
			bus_dmamap_destroy(sc->sc_dmat, sbuf->map);
			m_freem(sbuf->m);
		}
		free(sc->srbd_list, M_DEVBUF);
		sc->srbd_list = NULL;
	}

	if (sc->rx_sbuf_list != NULL) {
		free(sc->rx_sbuf_list, M_DEVBUF);
		sc->rx_sbuf_list = NULL;
	}
}

d1857 16
a1872 5
	if ((error = ipw_rx_init(sc)) != 0) {
		printf("%s: could not initialize rx queue\n",
		    sc->sc_dev.dv_xname);
		goto fail2;
	}
d1874 2
a1875 5
	if ((error = ipw_tx_init(sc)) != 0) {
		printf("%s: could not initialize tx queue\n",
		    sc->sc_dev.dv_xname);
		goto fail2;
	}
d1912 1
d1917 5
a1921 2
	ipw_tx_stop(sc);
	ipw_rx_stop(sc);
@


1.28
log
@don't leave run state on background scan
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.27 2004/11/24 20:50:55 damien Exp $  */
d1574 1
a1574 1
	for (ntries = 0; ntries < 5; ntries++) {
d1579 1
a1579 1
	if (ntries == 5)
@


1.27
log
@clear register 0x41, not 0x43 (endianness)
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.26 2004/11/20 16:28:31 damien Exp $  */
d518 3
a520 1
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
@


1.26
log
@forgot to remove a call to free() in my previous commit.
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.25 2004/11/18 21:02:42 damien Exp $  */
d182 1
a182 1
	data &= ~0x00ff0000;
@


1.25
log
@use the filesystem based firmware loader; deraadt ok
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.24 2004/11/03 17:14:31 damien Exp $  */
a1649 2

	free(uc, M_DEVBUF);
@


1.24
log
@Call ipw_stop() at the beginning of ipw_init(): this fixes a memory leak
when ipw_init() is called on ENETRESET.
Call ipw_stop() when the radio transmitter is turned off.

ok claudio@@
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.23 2004/11/03 17:12:28 damien Exp $  */
d46 1
d116 1
a116 2
int ipw_cache_firmware(struct ipw_softc *, void *);
void ipw_free_firmware(struct ipw_softc *);
a307 1
	ipw_free_firmware(sc);
a1088 18
	case SIOCSLOADFW:
		/* only super-user can do that! */
		if ((error = suser(curproc, 0)) != 0)
			break;

		ifr = (struct ifreq *)data;
		error = ipw_cache_firmware(sc, ifr->ifr_data);
		break;

	case SIOCSKILLFW:
		/* only super-user can do that! */
		if ((error = suser(curproc, 0)) != 0)
			break;

		ipw_stop(ifp, 1);
		ipw_free_firmware(sc);
		break;

d1651 2
a1719 4
/*
 * Store firmware into kernel memory so we can download it when we need to,
 * e.g when the adapter wakes up from suspend mode.
 */
d1721 1
a1721 1
ipw_cache_firmware(struct ipw_softc *sc, void *data)
d1723 4
a1726 3
	struct ipw_firmware *fw = &sc->fw;
	struct ipw_firmware_hdr hdr;
	u_char *p = data;
d1729 5
a1733 1
	ipw_free_firmware(sc);
d1735 4
a1738 2
	if ((error = copyin(data, &hdr, sizeof hdr)) != 0)
		goto fail1;
d1740 4
a1743 3
	fw->main_size  = letoh32(hdr.main_size);
	fw->ucode_size = letoh32(hdr.ucode_size);
	p += sizeof hdr;
d1745 2
a1746 5
	fw->main = malloc(fw->main_size, M_DEVBUF, M_NOWAIT);
	if (fw->main == NULL) {
		error = ENOMEM;
		goto fail1;
	}
d1748 3
a1750 4
	fw->ucode = malloc(fw->ucode_size, M_DEVBUF, M_NOWAIT);
	if (fw->ucode == NULL) {
		error = ENOMEM;
		goto fail2;
d1753 4
a1756 2
	if ((error = copyin(p, fw->main, fw->main_size)) != 0)
		goto fail3;
d1758 2
a1759 3
	p += fw->main_size;
	if ((error = copyin(p, fw->ucode, fw->ucode_size)) != 0)
		goto fail3;
d1761 4
a1764 2
	DPRINTF(("Firmware cached: main %u, ucode %u\n", fw->main_size,
	    fw->ucode_size));
d1766 2
a1767 1
	sc->flags |= IPW_FLAG_FW_CACHED;
d1771 2
a1772 15
fail3:	free(fw->ucode, M_DEVBUF);
fail2:	free(fw->main, M_DEVBUF);
fail1:	return error;
}

void
ipw_free_firmware(struct ipw_softc *sc)
{
	if (!(sc->flags & IPW_FLAG_FW_CACHED))
		return;

	free(sc->fw.main, M_DEVBUF);
	free(sc->fw.ucode, M_DEVBUF);

	sc->flags &= ~IPW_FLAG_FW_CACHED;
d1977 1
a1977 1
	struct ipw_firmware *fw = &sc->fw;
a1979 6
	/* exit immediately if firmware has not been ioctl'd */
	if (!(sc->flags & IPW_FLAG_FW_CACHED)) {
		ifp->if_flags &= ~IFF_UP;
		return EIO;
	}

d1984 6
a1989 1
		goto fail;
d1992 1
a1992 1
	if ((error = ipw_load_ucode(sc, fw->ucode, fw->ucode_size)) != 0) {
d1994 1
a1994 1
		goto fail;
d2002 1
a2002 1
		goto fail;
d2008 1
a2008 1
		goto fail;
d2011 1
a2011 1
	if ((error = ipw_load_firmware(sc, fw->main, fw->main_size)) != 0) {
d2013 1
a2013 1
		goto fail;
d2027 1
a2027 1
		goto fail;
d2035 2
a2036 1
fail:	ipw_stop(ifp, 0);
@


1.23
log
@Return 1 instead of 0 in ipw_intr() if the interrupt is handled by us.
Ignore invalid 0xffffffff interrupts.

ok claudio@@
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.22 2004/11/03 17:11:14 damien Exp $  */
d527 1
a527 1
		/* XXX should turn the interface down */
d2011 2
@


1.22
log
@IFM_IEEE80211_ADHOC -> IFM_IEEE80211_IBSS in ipw_media_status().

ok claudio@@ aaron@@
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.21 2004/11/03 17:10:03 damien Exp $  */
d735 1
a735 1
	if ((r = CSR_READ_4(sc, IPW_CSR_INTR)) == 0)
d765 1
a765 1
	return 0;
@


1.21
log
@Calling ipwcontrol -k without downloading the firmware first lead to a
panic. Fix the ipw_free_firmware() function itself instead of fixing the
callers.

ok claudio@@
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.20 2004/11/03 17:07:10 damien Exp $  */
d379 1
a379 1
		imr->ifm_active |= IFM_IEEE80211_ADHOC;
@


1.20
log
@Fix calls to bus_dmamap_create().
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.19 2004/11/02 06:06:21 marius Exp $  */
d308 1
a308 3

	if (sc->flags & IPW_FLAG_FW_CACHED)
		ipw_free_firmware(sc);
d1749 1
a1749 2
	if (sc->flags & IPW_FLAG_FW_CACHED)
		ipw_free_firmware(sc);
d1792 3
@


1.19
log
@factor out the dma memory allocation, mapping, freeing and unmapping
functionality and call them only on attach and detach.  these were
being called in interrupt context and were causing a panic on device
timeout.

ok damien@@
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.18 2004/10/28 23:06:10 brad Exp $  */
d1368 2
a1369 2
		error = bus_dmamap_create(sc->sc_dmat, IPW_NDATA * MCLBYTES,
		    IPW_NDATA, MCLBYTES, 0, BUS_DMA_NOWAIT, &sbuf->map);
d1514 2
a1515 2
		error = bus_dmamap_create(sc->sc_dmat, IPW_NRBD * MCLBYTES,
		    IPW_NRBD, MCLBYTES, 0, BUS_DMA_NOWAIT, &sbuf->map);
@


1.18
log
@the URL in if_iwi is no longer valid.

ok damien@@
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.17 2004/10/28 17:05:41 jcs Exp $  */
d105 2
d227 6
d307 1
d1175 3
d1179 1
a1179 1
ipw_tx_init(struct ipw_softc *sc)
d1181 1
a1182 13
	struct ipw_bd *bd;
	struct ipw_soft_bd *sbd;
	struct ipw_soft_hdr *shdr;
	struct ipw_soft_buf *sbuf;
	int error, i, nsegs;

	/* Allocate transmission buffer descriptors */
	error = bus_dmamap_create(sc->sc_dmat, IPW_TBD_SZ, 1, IPW_TBD_SZ, 0,
	    BUS_DMA_NOWAIT, &sc->tbd_map);
	if (error != 0) {
		errmsg = "could not create tbd dma map";
		goto fail;
	}
d1198 103
a1336 14
	error = bus_dmamem_alloc(sc->sc_dmat, sizeof (struct ipw_cmd),
	    PAGE_SIZE, 0, &sc->cmd_seg, 1, &nsegs, BUS_DMA_NOWAIT);
	if (error != 0) {
		errmsg = "could not allocate cmd dma memory";
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &sc->cmd_seg, nsegs,
	    sizeof (struct ipw_cmd), (caddr_t *)&sc->cmd, BUS_DMA_NOWAIT);
	if (error != 0) {
		errmsg = "could not map cmd dma memory";
		goto fail;
	}

d1393 1
a1393 1
		if (sc->tbd_list != NULL) {
a1394 5
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->tbd_list,
			    IPW_TBD_SZ);
			bus_dmamem_free(sc->sc_dmat, &sc->tbd_seg, 1);
			sc->tbd_list = NULL;
		}
a1406 6
		if (sc->cmd != NULL) {
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->cmd,
			    sizeof (struct ipw_cmd));
			bus_dmamem_free(sc->sc_dmat, &sc->cmd_seg, 1);
			sc->cmd = NULL;
		}
a1417 1

d1433 1
a1433 1
	int error, i, nsegs;
a1442 14
	error = bus_dmamem_alloc(sc->sc_dmat, IPW_RBD_SZ, PAGE_SIZE, 0,
	    &sc->rbd_seg, 1, &nsegs, BUS_DMA_NOWAIT);
	if (error != 0) {
		errmsg = "could not allocate rbd dma memory";
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &sc->rbd_seg, nsegs, IPW_RBD_SZ,
	    (caddr_t *)&sc->rbd_list, BUS_DMA_NOWAIT);
	if (error != 0) {
		errmsg = "could not map rbd dma memory";
		goto fail;
	}

a1477 14
	error = bus_dmamem_alloc(sc->sc_dmat, IPW_STATUS_SZ, PAGE_SIZE, 0,
	    &sc->status_seg, 1, &nsegs, BUS_DMA_NOWAIT);
	if (error != 0) {
		errmsg = "could not allocate status dma memory";
		goto fail;
	}

	error = bus_dmamem_map(sc->sc_dmat, &sc->status_seg, nsegs,
	    IPW_STATUS_SZ, (caddr_t *)&sc->status_list, BUS_DMA_NOWAIT);
	if (error != 0) {
		errmsg = "could not map status dma memory";
		goto fail;
	}

d1551 1
a1551 1
		if (sc->rbd_list != NULL) {
a1552 5
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->rbd_list,
			    IPW_RBD_SZ);
			bus_dmamem_free(sc->sc_dmat, &sc->rbd_seg, 1);
			sc->rbd_list = NULL;
		}
d1558 1
a1558 1
		if (sc->status_list != NULL) {
a1559 5
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->status_list,
			    IPW_STATUS_SZ);
			bus_dmamem_free(sc->sc_dmat, &sc->status_seg, 1);
			sc->status_list = NULL;
		}
@


1.17
log
@print our ether address when attaching like other drivers
ok damien@@
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.16 2004/10/27 21:24:49 damien Exp $  */
d32 1
a32 1
 * www.intel.com/network/connectivity/products/wireless/prowireless_mobile.htm
@


1.16
log
@Minor consistency tweaks (imported from iwi).
Wait longer for microcode initialization to complete.
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.15 2004/10/27 21:23:45 damien Exp $  */
d218 1
a218 1
	printf(": %s\n", intrstr);
d243 2
@


1.15
log
@Check that we are associated before sending anything. Call ipw_stop()
from ipw_watchdog().
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.14 2004/10/27 21:23:01 damien Exp $  */
d1603 1
a1603 1
	MEM_WRITE_4(sc, 0x003000e0, 0x80000000);
d1631 1
a1631 1
	for (ntries = 0; ntries < 10; ntries++) {
d1634 1
a1634 1
		DELAY(10);
d1636 3
a1638 1
	if (ntries == 10)
d1640 1
d1642 1
a1642 1
	MEM_WRITE_4(sc, 0x003000e0, 0);
@


1.14
log
@Handle fatal errors from firmware (imported from iwi).
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.13 2004/10/27 21:22:14 damien Exp $  */
d954 3
d998 1
a998 3
#ifdef notyet
			ipw_init(ifp);
#endif
@


1.13
log
@Read MAC address from EEPROM in ipw_attach(). The address is now known
before the firmware has been sent. Imported from iwi.
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.12 2004/10/27 21:21:16 damien Exp $  */
d743 5
@


1.12
log
@Cache firmware into kernel memory instead of sending it directly. The
firmware is now sent only when the interface is turned up.
This paves the way for proper suspend/resume support.
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.11 2004/10/27 21:20:30 damien Exp $  */
d85 1
d174 1
d220 5
d233 11
d418 56
a1952 1
	struct ieee80211com *ic = &sc->sc_ic;
d1954 1
a1954 1
	int error, len;
a1997 6

	/* Retrieve adapter MAC address */
	len = IEEE80211_ADDR_LEN;
	ipw_read_table2(sc, IPW_INFO_ADAPTER_MAC, ic->ic_myaddr, &len);

	IEEE80211_ADDR_COPY(LLADDR(ifp->if_sadl), ic->ic_myaddr);
@


1.11
log
@Change firmware initialization sequence to be more consistent with iwi.
Remove ipw_zero_mem_4() and add ipw_stop_master().
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.10 2004/10/27 21:19:43 damien Exp $  */
d109 1
a109 2
void ipw_reset(struct ipw_softc *);
int ipw_clock_sync(struct ipw_softc *);
d112 2
a113 1
int ipw_firmware_init(struct ipw_softc *, u_char *);
d278 4
a281 1
	ipw_reset(sc);
d414 1
a414 8
	/*
	 * Wake up processes waiting for command ack. In the case of the
	 * IPW_CMD_DISABLE command, wake up the process only when the adapter
	 * enters the IPW_STATE_DISABLED state. This is notified in
	 * ipw_newstate_intr().
	 */
	if (letoh32(cmd->type) != IPW_CMD_DISABLE)
		wakeup(sc);
a442 4
	case IPW_STATE_DISABLED:
		wakeup(sc->cmd);
		break;

d932 4
a935 2
	if (!(sc->flags & IPW_FLAG_FW_INITED))
		return ENOTTY;
a950 3
	if (!(sc->flags & IPW_FLAG_FW_INITED))
		return ENOTTY;

d1007 1
a1007 1
		error = ipw_firmware_init(sc, (u_char *)ifr->ifr_data);
d1015 2
a1016 1
		ipw_reset(sc);
d1487 1
a1487 1
void
a1489 1
	struct ifnet *ifp = &sc->sc_ic.ic_if;
d1492 1
a1492 32
	ipw_stop(ifp, 1);

	if (sc->flags & IPW_FLAG_FW_INITED) {
		ipw_cmd(sc, IPW_CMD_DISABLE_PHY, NULL, 0);
		ipw_cmd(sc, IPW_CMD_PREPARE_POWER_DOWN, NULL, 0);

		sc->flags &= ~IPW_FLAG_FW_INITED;
	}

	/* Disable interrupts */
	CSR_WRITE_4(sc, IPW_CSR_INTR_MASK, 0);

	CSR_WRITE_4(sc, IPW_CSR_RST, IPW_RST_STOP_MASTER);
	for (ntries = 0; ntries < 5; ntries++) {
		if (CSR_READ_4(sc, IPW_CSR_RST) & IPW_RST_MASTER_DISABLED)
			break;
		DELAY(10);
	}

	CSR_WRITE_4(sc, IPW_CSR_RST, IPW_RST_SW_RESET);

	ipw_rx_stop(sc);
	ipw_tx_stop(sc);

	ifp->if_flags &= ~IFF_UP;
}

int
ipw_clock_sync(struct ipw_softc *sc)
{
	int ntries;
	u_int32_t r;
d1494 3
a1496 8
	CSR_WRITE_4(sc, IPW_CSR_RST, IPW_RST_SW_RESET);
	for (ntries = 0; ntries < 1000; ntries++) {
		if (CSR_READ_4(sc, IPW_CSR_RST) & IPW_RST_PRINCETON_RESET)
			break;
		DELAY(10);
	}
	if (ntries == 1000)
		return EIO;
d1498 1
a1498 1
	CSR_WRITE_4(sc, IPW_CSR_CTL, IPW_CTL_INIT);
d1500 1
a1500 1
		if ((r = CSR_READ_4(sc, IPW_CSR_CTL)) & IPW_CTL_CLOCK_READY)
d1507 7
a1513 1
	CSR_WRITE_4(sc, IPW_CSR_CTL, r | IPW_CTL_ALLOW_STANDBY);
d1599 2
d1615 4
d1620 1
a1620 1
ipw_firmware_init(struct ipw_softc *sc, u_char *data)
d1622 3
a1624 5
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ipw_fw_hdr hdr;
	u_int32_t len, fw_size, uc_size;
	u_char *fw, *uc;
d1627 2
a1628 1
	ipw_reset(sc);
d1633 3
a1635 3
	fw_size = letoh32(hdr.fw_size);
	uc_size = letoh32(hdr.uc_size);
	data += sizeof hdr;
d1637 2
a1638 1
	if ((fw = malloc(fw_size, M_DEVBUF, M_NOWAIT)) == NULL) {
d1643 2
a1644 6
	if ((error = copyin(data, fw, fw_size)) != 0)
		goto fail2;

	data += fw_size;

	if ((uc = malloc(uc_size, M_DEVBUF, M_NOWAIT)) == NULL) {
d1649 1
a1649 1
	if ((error = copyin(data, uc, uc_size)) != 0)
d1652 2
a1653 3
	if ((error = ipw_clock_sync(sc)) != 0) {
		printf("%s: clock synchronization failed\n",
		    sc->sc_dev.dv_xname);
a1654 1
	}
d1656 2
a1657 4
	if ((error = ipw_load_ucode(sc, uc, uc_size)) != 0) {
		printf("%s: could not load microcode\n", sc->sc_dev.dv_xname);
		goto fail3;
	}
d1659 1
a1659 1
	ipw_stop_master(sc);
d1661 1
a1661 5
	if ((error = ipw_rx_init(sc)) != 0) {
		printf("%s: could not initialize rx queue\n",
		    sc->sc_dev.dv_xname);
		goto fail3;
	}
d1663 4
a1666 5
	if ((error = ipw_tx_init(sc)) != 0) {
		printf("%s: could not initialize tx queue\n",
		    sc->sc_dev.dv_xname);
		goto fail3;
	}
d1668 5
a1672 24
	if ((error = ipw_load_firmware(sc, fw, fw_size))) {
		printf("%s: could not load firmware\n", sc->sc_dev.dv_xname);
		goto fail3;
	}

	/* Firmware initialization completed */
	sc->flags |= IPW_FLAG_FW_INITED;

	free(uc, M_DEVBUF);
	free(fw, M_DEVBUF);

	/* Retrieve information tables base addresses */
	sc->table1_base = CSR_READ_4(sc, IPW_CSR_TABLE1_BASE);
	sc->table2_base = CSR_READ_4(sc, IPW_CSR_TABLE2_BASE);

	ipw_write_table1(sc, IPW_INFO_LOCK, 0);

	/* Retrieve adapter MAC address */
	len = IEEE80211_ADDR_LEN;
	ipw_read_table2(sc, IPW_INFO_ADAPTER_MAC, ic->ic_myaddr, &len);

	IEEE80211_ADDR_COPY(LLADDR(ifp->if_sadl), ic->ic_myaddr);

	return 0;
d1674 1
a1674 5
fail3:	free(uc, M_DEVBUF);
fail2:	free(fw, M_DEVBUF);
fail1:	ipw_reset(sc);

	return error;
d1879 3
d1884 1
a1884 1
	if (!(sc->flags & IPW_FLAG_FW_INITED)) {
d1889 40
a1928 1
	ipw_stop(ifp, 0);
d1930 3
a1932 1
	if (ipw_config(sc) != 0) {
d1945 1
a1945 1
	return EIO;
d1954 5
a1958 4
	if (ifp->if_flags & IFF_RUNNING) {
		DPRINTF(("Disabling adapter\n"));
		ipw_cmd(sc, IPW_CMD_DISABLE, NULL, 0);
	}
@


1.10
log
@Add ipw_media_status() to report the current Tx rate properly.
This was imported from iwi.
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.9 2004/10/27 21:19:01 damien Exp $  */
d108 1
a118 1
void ipw_zero_mem_4(struct ipw_softc *, bus_size_t, bus_size_t);
d418 1
a418 1
		wakeup(sc->cmd);
d731 1
a731 1
	return tsleep(sc->cmd, 0, "ipwcmd", hz);
d1472 24
d1562 3
d1598 2
d1612 1
d1629 20
d1658 1
a1658 1
	u_int32_t r, len, fw_size, uc_size;
a1694 4
	MEM_WRITE_4(sc, 0x003000e0, 0x80000000);

	CSR_WRITE_4(sc, IPW_CSR_RST, 0);

d1700 1
a1700 18
	MEM_WRITE_4(sc, 0x003000e0, 0);

	if ((error = ipw_clock_sync(sc)) != 0) {
		printf("%s: clock synchronization failed\n",
		    sc->sc_dev.dv_xname);
		goto fail3;
	}

	if ((error = ipw_load_firmware(sc, fw, fw_size))) {
		printf("%s: could not load firmware\n", sc->sc_dev.dv_xname);
		goto fail3;
	}

	ipw_zero_mem_4(sc, 0x0002f200, 196);
	ipw_zero_mem_4(sc, 0x0002f610, 8);
	ipw_zero_mem_4(sc, 0x0002fa00, 8);
	ipw_zero_mem_4(sc, 0x0002fc00, 4);
	ipw_zero_mem_4(sc, 0x0002ff80, 32);
d1714 2
a1715 13
	CSR_WRITE_4(sc, IPW_CSR_IO, IPW_IO_GPIO1_ENABLE | IPW_IO_GPIO3_MASK |
	    IPW_IO_LED_OFF);

	/* Allow interrupts so we know when the firmware is inited */
	CSR_WRITE_4(sc, IPW_CSR_INTR_MASK, IPW_INTR_MASK);

	/* Tell the adapter to initialize the firmware */
	CSR_WRITE_4(sc, IPW_CSR_RST, 0);

	/* Wait at most one second for firmware initialization to complete */
	if ((error = tsleep(sc, 0, "ipwinit", hz)) != 0) {
		printf("%s: timeout waiting for firmware initialization to "
		    "complete\n", sc->sc_dev.dv_xname);
a1724 3
	r = CSR_READ_4(sc, IPW_CSR_IO);
	CSR_WRITE_4(sc, IPW_CSR_IO, r | IPW_IO_GPIO1_MASK | IPW_IO_GPIO3_MASK);

a2007 8
}

void
ipw_zero_mem_4(struct ipw_softc *sc, bus_size_t offset, bus_size_t count)
{
	CSR_WRITE_4(sc, IPW_CSR_AUTOINC_ADDR, offset);
	while (count-- > 0)
		CSR_WRITE_4(sc, IPW_CSR_AUTOINC_DATA, 0);
@


1.9
log
@Configure the adapter properly to avoid Tx retries from interfering with
CPU C3 state (imported from iwi).
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.8 2004/10/27 21:17:18 damien Exp $  */
d83 1
d256 1
a256 1
	ieee80211_media_init(ifp, ipw_media_change, ieee80211_media_status);
d309 53
@


1.8
log
@Add authmode support (imported from iwi).
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.7 2004/10/27 21:16:45 damien Exp $  */
d171 1
a171 1
	u_int32_t data;
d175 4
@


1.7
log
@Import ipw_get_table() and ipw_get_radio() functions from iwi.
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.6 2004/10/27 21:15:17 damien Exp $  */
d231 3
d969 12
d983 1
a983 2
		if (error != ENETRESET)
			break;
d985 1
d1806 2
a1807 1
	security.authmode = IPW_AUTH_OPEN;
@


1.6
log
@Remove unuseful initialization of ic->ic_bss->ni_chan in ipw_init().
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.5 2004/10/27 21:14:48 damien Exp $  */
d877 1
a877 1
	u_int32_t addr, data, size, i;
d885 2
a886 2
	if (copyout(&size, tbl, sizeof size) != 0)
		return EFAULT;
d888 1
a888 7
	for (i = 1, ++tbl; i < size; i++, tbl++) {
		addr = CSR_READ_4(sc, IPW_CSR_AUTOINC_DATA);
		data = MEM_READ_4(sc, addr);
		if (copyout(&data, tbl, sizeof data) != 0)
			return EFAULT;
	}
	return 0;
a893 1
	u_int32_t addr;
d899 2
a900 15
	addr = ipw_read_table1(sc, IPW_INFO_EEPROM_ADDRESS);
	if ((MEM_READ_4(sc, addr + 32) >> 24) & 1) {
		val = -1;
		copyout(&val, ret, sizeof val);
		return 0;
	}

	if (CSR_READ_4(sc, IPW_CSR_IO) & IPW_IO_RADIO_DISABLED)
		val = 0;
	else
		val = 1;
		
	copyout(&val, ret, sizeof val);

	return 0;
@


1.5
log
@Change the way supported rates set is initialized (to be consistent with
iwi).
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.4 2004/10/27 21:14:03 damien Exp $  */
a1878 1
	struct ieee80211com *ic = &sc->sc_ic;
a1895 2

	ic->ic_bss->ni_chan = ic->ic_channels;
@


1.4
log
@Reduce timeout from two seconds to one second for command ack and from five
seconds to one second for firmware notification.
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.3 2004/10/27 21:12:08 damien Exp $  */
d76 3
a164 1
	struct ieee80211_rateset *rs;
d222 1
a222 6
	rs = &ic->ic_sup_rates[IEEE80211_MODE_11B];
	rs->rs_nrates = 4;
	rs->rs_rates[0] = 2;	/* 1Mbps */
	rs->rs_rates[1] = 4;	/* 2Mbps */
	rs->rs_rates[2] = 11;	/* 5.5Mbps */
	rs->rs_rates[3] = 22; 	/* 11Mbps */
@


1.3
log
@Remove static for all non-inline functions.
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.2 2004/10/27 21:10:22 damien Exp $  */
d672 2
a673 2
	/* Wait at most two seconds for command to complete */
	return tsleep(sc->cmd, 0, "ipwcmd", 2 * hz);
d1644 2
a1645 2
	/* Wait at most 5 seconds for firmware initialization to complete */
	if ((error = tsleep(sc, 0, "ipwinit", 5 * hz)) != 0) {
@


1.2
log
@Mostly cosmetic changes to be consistent with iwi:
- update web url
- sed s/ *$//
- get if_ipwreg.h and if_ipwvar.h from dev/pci
- remove unused function MEM_READ_2()
- inline -> __inline
- 11.b -> .11b
- addition of comments
- sort registers by their addresses
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.1 2004/10/20 12:50:48 deraadt Exp $  */
d76 8
a83 8
static int ipw_match(struct device *, void *, void *);
static void ipw_attach(struct device *, struct device *, void *);
static int ipw_detach(struct device *, int);
static int ipw_media_change(struct ifnet *);
static int ipw_newstate(struct ieee80211com *, enum ieee80211_state, int);
static void ipw_command_intr(struct ipw_softc *, struct ipw_soft_buf *);
static void ipw_newstate_intr(struct ipw_softc *, struct ipw_soft_buf *);
static void ipw_data_intr(struct ipw_softc *, struct ipw_status *,
d85 30
a114 32
static void ipw_notification_intr(struct ipw_softc *, struct ipw_soft_buf *);
static void ipw_rx_intr(struct ipw_softc *);
static void ipw_release_sbd(struct ipw_softc *, struct ipw_soft_bd *);
static void ipw_tx_intr(struct ipw_softc *);
static int ipw_intr(void *);
static int ipw_cmd(struct ipw_softc *, u_int32_t, void *, u_int32_t);
static int ipw_tx_start(struct ifnet *, struct mbuf *, struct ieee80211_node *);
static void ipw_start(struct ifnet *);
static void ipw_watchdog(struct ifnet *);
static int ipw_get_table1(struct ipw_softc *, u_int32_t *);
static int ipw_get_radio(struct ipw_softc *, int *);
static int ipw_ioctl(struct ifnet *, u_long, caddr_t);
static u_int32_t ipw_read_table1(struct ipw_softc *, u_int32_t);
static void ipw_write_table1(struct ipw_softc *, u_int32_t, u_int32_t);
static int ipw_read_table2(struct ipw_softc *, u_int32_t, void *, u_int32_t *);
static int ipw_tx_init(struct ipw_softc *);
static void ipw_tx_stop(struct ipw_softc *);
static int ipw_rx_init(struct ipw_softc *);
static void ipw_rx_stop(struct ipw_softc *);
static void ipw_reset(struct ipw_softc *);
static int ipw_clock_sync(struct ipw_softc *);
static int ipw_load_ucode(struct ipw_softc *, u_char *, int);
static int ipw_load_firmware(struct ipw_softc *, u_char *, int);
static int ipw_firmware_init(struct ipw_softc *, u_char *);
static int ipw_config(struct ipw_softc *);
static int ipw_init(struct ifnet *);
static void ipw_stop(struct ifnet *, int);
static void ipw_read_mem_1(struct ipw_softc *, bus_size_t, u_int8_t *,
    bus_size_t);
static void ipw_write_mem_1(struct ipw_softc *, bus_size_t, u_int8_t *,
    bus_size_t);
static void ipw_zero_mem_4(struct ipw_softc *, bus_size_t, bus_size_t);
d141 1
a141 1
static int
d156 1
a156 1
static void
d267 1
a267 1
static int
d291 1
a291 1
static int
d306 1
a306 1
static int
d339 1
a339 1
static void
d363 1
a363 1
static void
d399 1
a399 1
static void
d480 1
a480 1
static void
d486 1
a486 1
static void
d544 1
a544 1
static void
d577 1
a577 1
static void
d596 1
a596 1
static int
d630 1
a630 1
static int
d676 1
a676 1
static int
d817 1
a817 1
static void
d856 1
a856 1
static void
d877 1
a877 1
static int
d900 1
a900 1
static int
d926 1
a926 1
static int
d1004 1
a1004 1
static u_int32_t
d1010 1
a1010 1
static void
d1016 1
a1016 1
static int
d1042 1
a1042 1
static int
d1172 1
a1172 1
static void
d1225 1
a1225 1
static int
d1370 1
a1370 1
static void
d1421 1
a1421 1
static void
d1454 1
a1454 1
static int
d1483 1
a1483 1
static int
d1527 1
a1527 1
static int
d1552 1
a1552 1
static int
d1681 1
a1681 1
static int
d1878 1
a1878 1
static int
d1910 1
a1910 1
static void
d1927 1
a1927 1
static void
d1937 1
a1937 1
static void
d1947 1
a1947 1
static void
@


1.1
log
@support for Intel 2100/2200BG/2915ABG wireless devices written by
damien.bergamini@@free.fr. This gets imported even though there is no
firmware in the tree.  This is a ridiculous situation: everything is
free, everything works, except Intel will not let us put a little
dinky firmware flat file into OpenBSD.  So OpenBSD is ready for Intel
whenever they are.

Are you a consumer?  Do you want to see this changed -- contact
jketreno@@linux.intel.com and tell him how you feel about this.  He is
likely someone who cannot do anything about it, though.  If anyone can
work up or down the chain around his department and get me contact
information for various people, I will compile and later publish such
a list.  Go do it people -- this is how things will change.  Get me
email addresses and phone numbers.
@
text
@d1 1
a1 1
/*	$Id: if_ipw.c,v 1.8 2004/09/05 14:53:06 damien Exp $  */
d32 1
a32 1
 * http://www.intel.com/products/mobiletechnology/prowireless.htm
d73 2
a74 2
#include "if_ipwreg.h"
#include "if_ipwvar.h"
d83 1
a83 1
static void ipw_data_intr(struct ipw_softc *, struct ipw_status *, 
d112 1
a112 1
static void ipw_read_mem_1(struct ipw_softc *, bus_size_t, u_int8_t *, 
d114 1
a114 1
static void ipw_write_mem_1(struct ipw_softc *, bus_size_t, u_int8_t *, 
d118 1
a118 1
static inline u_int8_t MEM_READ_1(struct ipw_softc *sc, u_int32_t addr)
d124 1
a124 7
static inline u_int16_t MEM_READ_2(struct ipw_softc *sc, u_int32_t addr)
{
	CSR_WRITE_4(sc, IPW_CSR_INDIRECT_ADDR, addr);
	return CSR_READ_2(sc, IPW_CSR_INDIRECT_DATA);
}

static inline u_int32_t MEM_READ_4(struct ipw_softc *sc, u_int32_t addr)
d148 1
a148 1
	if (PCI_VENDOR (pa->pa_id) == PCI_VENDOR_INTEL && 
d156 1
a156 1
#define IPW_PCI_BAR0 0x10
d172 1
a172 1
	int i, error;
d182 1
a182 1
	error = pci_mapreg_map(pa, IPW_PCI_BAR0, PCI_MAPREG_TYPE_MEM | 
d218 1
a218 1
	ic->ic_caps =  IEEE80211_C_IBSS | IEEE80211_C_MONITOR | 
d221 1
a221 1
	/* set supported 11.b rates */
d229 1
a229 1
	/* set supported 11.b channels (1 through 14) */
d231 1
a231 1
		ic->ic_channels[i].ic_freq = 
d236 1
a252 1

d256 1
a256 1
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO, 
d311 1
a311 2
	struct ifnet *ifp = &ic->ic_if;
	struct ipw_softc *sc = ifp->if_softc;
a315 3
	case IEEE80211_S_INIT:
		break;

d330 1
d351 1
a351 1
	DPRINTFN(2, ("RX!CMD!%u!%u!%u!%u!%u\n", 
d355 2
a356 2
	/* 
	 * Wake up processes waiting for command ack. In the case of the 
d402 1
a402 1
ipw_data_intr(struct ipw_softc *sc, struct ipw_status *status, 
d448 1
a448 1
	ieee80211_input(ifp, m, ni, status->rssi, 0/*rstamp*/);
d457 1
a457 1
		printf("%s: could not allocate rx mbuf\n", 
d464 1
a464 1
		printf("%s: could not allocate rx mbuf cluster\n", 
d469 1
a469 1
	error = bus_dmamap_load(sc->sc_dmat, sbuf->map, mtod(m, void *), 
d472 1
a472 1
		printf("%s: could not map rxbuf dma memory\n", 
d500 2
a501 2
		bus_dmamap_sync(sc->sc_dmat, sc->rbd_map, 
		    i * sizeof (struct ipw_bd), sizeof (struct ipw_bd), 
d504 2
a505 2
		bus_dmamap_sync(sc->sc_dmat, sc->status_map, 
		    i * sizeof (struct ipw_status), sizeof (struct ipw_status), 
d531 1
a531 1
			printf("%s: unknown status code %u\n", 
d536 2
a537 2
		bus_dmamap_sync(sc->sc_dmat, sc->rbd_map, 
		    i * sizeof (struct ipw_bd), sizeof (struct ipw_bd), 
d640 1
a640 1
	error = bus_dmamap_load(sc->sc_dmat, sc->cmd_map, sc->cmd, 
d643 1
a643 1
		printf("%s: could not map cmd dma memory\n", 
d659 1
a659 1
	sbd->bd->flags = IPW_BD_FLAG_TX_FRAME_COMMAND | 
d665 1
a665 1
	bus_dmamap_sync(sc->sc_dmat, sc->tbd_map, 
d735 1
a735 1
	 * We need to map the mbuf first to know how many buffer descriptors  
d740 1
a740 1
		printf("%s: could not map mbuf (error %d)\n", 
d749 1
a749 1
		printf("%s: could not map header (error %d)\n", 
d768 3
a770 3
	DPRINTFN(5, ("TX!HDR!%u!%u!%u!%u\n", shdr->hdr.type, shdr->hdr.subtype, 
	    shdr->hdr.encrypted, shdr->hdr.encrypt)); 
	DPRINTFN(5, ("!%s", ether_sprintf(shdr->hdr.src_addr))); 
d773 2
a774 2
	bus_dmamap_sync(sc->sc_dmat, sc->tbd_map, 
	    sc->txcur * sizeof (struct ipw_bd), 
d797 1
a797 1
		DPRINTFN(5, ("TX!FRAG!%d!%d\n", i, 
d800 2
a801 2
		bus_dmamap_sync(sc->sc_dmat, sc->tbd_map, 
		    sc->txcur * sizeof (struct ipw_bd), 
d807 1
a807 1
	bus_dmamap_sync(sc->sc_dmat, shdr->map, 0, sizeof (struct ipw_hdr), 
d810 1
a810 1
	bus_dmamap_sync(sc->sc_dmat, sbuf->map, 0, MCLBYTES, 
d996 1
a996 1
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == 
d1055 1
a1055 1
	error = bus_dmamap_create(sc->sc_dmat, IPW_TBD_SZ, 1, IPW_TBD_SZ, 0, 
d1062 1
a1062 1
	error = bus_dmamem_alloc(sc->sc_dmat, IPW_TBD_SZ, PAGE_SIZE, 0, 
d1069 1
a1069 1
	error = bus_dmamem_map(sc->sc_dmat, &sc->tbd_seg, nsegs, IPW_TBD_SZ, 
d1076 1
a1076 1
	error = bus_dmamap_load(sc->sc_dmat, sc->tbd_map, sc->tbd_list, 
d1083 1
a1083 1
	sc->stbd_list = malloc(IPW_NTBD * sizeof (struct ipw_soft_bd), 
d1105 1
a1105 1
	error = bus_dmamap_create(sc->sc_dmat, sizeof (struct ipw_cmd), 1, 
d1112 1
a1112 1
	error = bus_dmamem_alloc(sc->sc_dmat, sizeof (struct ipw_cmd), 
d1119 1
a1119 1
	error = bus_dmamem_map(sc->sc_dmat, &sc->cmd_seg, nsegs, 
d1136 3
a1138 3
		error = bus_dmamap_create(sc->sc_dmat, 
		    sizeof (struct ipw_soft_hdr), 1, 
	 	    sizeof (struct ipw_soft_hdr), 0, BUS_DMA_NOWAIT, 
d1157 1
a1157 1
		error = bus_dmamap_create(sc->sc_dmat, IPW_NDATA * MCLBYTES, 
d1184 1
a1184 1
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->tbd_list, 
d1202 1
a1202 1
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->cmd, 
d1237 1
a1237 1
	error = bus_dmamap_create(sc->sc_dmat, IPW_RBD_SZ, 1, IPW_RBD_SZ, 0, 
d1244 1
a1244 1
	error = bus_dmamem_alloc(sc->sc_dmat, IPW_RBD_SZ, PAGE_SIZE, 0, 
d1251 1
a1251 1
	error = bus_dmamem_map(sc->sc_dmat, &sc->rbd_seg, nsegs, IPW_RBD_SZ, 
d1258 1
a1258 1
	error = bus_dmamap_load(sc->sc_dmat, sc->rbd_map, sc->rbd_list, 
d1265 1
a1265 1
	sc->srbd_list = malloc(IPW_NRBD * sizeof (struct ipw_soft_bd), 
d1286 1
a1286 1
	error = bus_dmamap_create(sc->sc_dmat, IPW_STATUS_SZ, 1, IPW_STATUS_SZ, 
d1293 1
a1293 1
	error = bus_dmamem_alloc(sc->sc_dmat, IPW_STATUS_SZ, PAGE_SIZE, 0, 
d1300 1
a1300 1
	error = bus_dmamem_map(sc->sc_dmat, &sc->status_seg, nsegs, 
d1307 1
a1307 1
	error = bus_dmamap_load(sc->sc_dmat, sc->status_map, sc->status_list, 
d1314 1
a1314 1
	CSR_WRITE_4(sc, IPW_CSR_RX_STATUS_BASE, 
d1343 1
a1343 1
		error = bus_dmamap_create(sc->sc_dmat, IPW_NRBD * MCLBYTES, 
d1350 1
a1350 1
		error = bus_dmamap_load(sc->sc_dmat, sbuf->map, 
d1382 1
a1382 1
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->rbd_list, 
d1394 1
a1394 1
			bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->status_list, 
d1471 1
a1471 1
	CSR_WRITE_4(sc, IPW_CSR_CTL, IPW_CTL_INIT_DONE);
d1533 1
a1533 1
	u_int32_t addr;
d1542 2
a1543 4
		addr = GETLE32(p);
		p += 4;
		len = GETLE16(p);
		p += 2;
d1548 1
a1548 1
		ipw_write_mem_1(sc, addr, p, len);
d1592 1
a1592 1
		printf("%s: clock synchronization failed\n", 
d1609 1
a1609 1
		printf("%s: clock synchronization failed\n", 
d1626 1
a1626 1
		printf("%s: could not initialize rx queue\n", 
d1637 1
a1637 1
	CSR_WRITE_4(sc, IPW_CSR_IO, IPW_IO_GPIO1_ENABLE | IPW_IO_GPIO3_MASK | 
d1640 1
a1640 1
	/* Enable interrupts */
d1643 1
a1643 1
	/* Let's go! */
d1716 1
a1716 1
	if (ic->ic_opmode == IEEE80211_M_IBSS || 
d1733 1
a1733 1
	error = ipw_cmd(sc, IPW_CMD_SET_MAC_ADDRESS, ic->ic_myaddr, 
d1738 1
a1738 1
	config.flags = htole32(IPW_CFG_BSS_MASK | IPW_CFG_IBSS_MASK | 
d1772 1
a1772 1
		error = ipw_cmd(sc, IPW_CMD_SET_TX_POWER_INDEX, &data, 
d1797 1
a1797 1
	error = ipw_cmd(sc, IPW_CMD_SET_ESSID, ic->ic_des_essid, 
d1808 1
a1808 1
		DPRINTF(("Setting adapter desired BSSID to %s\n", 
d1810 1
a1810 1
		error = ipw_cmd(sc, IPW_CMD_SET_DESIRED_BSSID, 
d1822 1
a1822 1
	error = ipw_cmd(sc, IPW_CMD_SET_SECURITY_INFORMATION, &security, 
d1837 1
a1837 1
			DPRINTF(("Setting wep key index %d len %d\n", 
d1839 1
a1839 1
			error = ipw_cmd(sc, IPW_CMD_SET_WEP_KEY, &wepkey, 
d1847 1
a1847 1
		error = ipw_cmd(sc, IPW_CMD_SET_WEP_KEY_INDEX, &data, 
d1859 1
a1859 1
	if (ic->ic_opmode == IEEE80211_M_IBSS || 
d1863 1
a1863 1
		error = ipw_cmd(sc, IPW_CMD_SET_BEACON_INTERVAL, &data, 
d1877 1
a1877 5
	error = ipw_cmd(sc, IPW_CMD_ENABLE, NULL, 0);
	if (error != 0)
		return error;

	return 0;
d1880 1
a1880 1
static int 
d1895 1
a1895 1
		printf("%s: device configuration failed\n", 
d1930 1
a1930 1
ipw_read_mem_1(struct ipw_softc *sc, bus_size_t offset, u_int8_t *datap, 
d1940 1
a1940 1
ipw_write_mem_1(struct ipw_softc *sc, bus_size_t offset, u_int8_t *datap, 
@

