head	1.9;
access;
symbols
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.10
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.8.0.22
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.20
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.18
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.14
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.12
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.10
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.8
	OPENBSD_5_0:1.8.0.6
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.4
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.7.0.6
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.8
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.6.0.4
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6;
locks; strict;
comment	@ * @;


1.9
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.8;
commitid	p4LJxGKbi0BU2cG6;

1.8
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2008.03.27.09.21.59;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2007.07.03.01.08.36;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2007.07.02.23.50.15;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2007.07.02.14.10.13;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2007.07.02.14.01.14;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2007.07.02.07.17.34;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2007.07.02.01.14.36;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: jmb.c,v 1.8 2010/04/08 00:23:53 tedu Exp $ */

/*
 * Copyright (c) 2007 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/queue.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

/* JMicron registers */
#define JM_PCI_CTL0		0x40 /* control register 0 */
#define  JM_PCI_CTL0_ROM_EN		(1<<31)	/* External Option ROM */
#define  JM_PCI_CTL0_IDWR_EN		(1<<30) /* Device ID Write */
#define  JM_PCI_CTL0_MSI64_EN		(1<<25) /* 64bit MSI Addr Mode */
#define  JM_PCI_CTL0_MSI_EN		(1<<24) /* MSI Addr Mode */
#define  JM_PCI_CTL0_IDEDMA_CFG		(1<<23) /* PCIIDE DMA Chan Cfg */
#define  JM_PCI_CTL0_PCIIDE_CS		(1<<22) /* PCIIDE channels Swap */
#define  JM_PCI_CTL0_SATA_PS		(1<<21) /* SATA channel M/S swap */
#define  JM_PCI_CTL0_AHCI_PS		(1<<20) /* SATA AHCI ports swap */
#define  JM_PCI_CTL0_F1_SUBCLASS_M	0xc0000 /* subclass for func 1 */
#define  JM_PCI_CTL0_F0_SUBCLASS_M	0x30000 /* subclass for func 0 */
#define  JM_PCI_CTL0_SUBCLASS_IDE	0x0 /* IDE Controller */
#define  JM_PCI_CTL0_SUBCLASS_RAID	0x1 /* RAID Controller */
#define  JM_PCI_CTL0_SUBCLASS_AHCI	0x2 /* AHCI Controller */
#define  JM_PCI_CTL0_SUBCLASS_OTHER	0x3 /* Other Mass Storage */
#define  JM_PCI_CTL0_F1_SUBCLASS(_m)	((_m)<<18) /* subclass for func 1 */
#define  JM_PCI_CTL0_F0_SUBCLASS(_m)	((_m)<<16) /* subclass for func 0 */
#define  JM_PCI_CTL0_SATA1_AHCI		(1<<15) /* SATA port 1 AHCI enable */
#define  JM_PCI_CTL0_SATA1_IDE		(1<<14) /* SATA port 1 IDE enable */
#define  JM_PCI_CTL0_SATA0_AHCI		(1<<13) /* SATA port 0 AHCI enable */
#define  JM_PCI_CTL0_SATA0_IDE		(1<<12) /* SATA port 0 PCIIDE enable */
#define  JM_PCI_CTL0_AHCI_F1		(1<<9) /* AHCI on function 1 */
#define  JM_PCI_CTL0_AHCI_EN		(1<<8) /* ACHI enable */
#define  JM_PCI_CTL0_PATA0_RST		(1<<6) /* PATA port 0 reset */
#define  JM_PCI_CTL0_PATA0_EN		(1<<5) /* PATA port 0 enable */
#define  JM_PCI_CTL0_PATA0_SEC		(1<<4) /* PATA 0 enable on 2nd chan */
#define  JM_PCI_CTL0_PATA0_40P		(1<<3) /* PATA 0 40pin cable */
#define  JM_PCI_CTL0_PCIIDE_F1		(1<<1) /* PCIIDE on function 1 */
#define  JM_PCI_CTL0_PATA0_PRI		(1<<0) /* PATA 0 enable on 1st chan */

#define JM_PCI_CTL5		0x80 /* control register 8 */
#define  JM_PCI_CTL5_PATA1_PRI		(1<<24) /* force PATA 1 on chan0 */

int		jmb_match(struct device *, void *, void *);
void		jmb_attach(struct device *, struct device *, void *);
int		jmb_print(void *, const char *);

struct jmb_softc {
	struct device		sc_dev;
};

struct cfattach jmb_ca = {
	sizeof(struct jmb_softc),
	jmb_match,
	jmb_attach,
	config_detach_children
};

struct cfdriver jmb_cd = {
	NULL, "jmb", DV_DULL
};

static const struct pci_matchid jmb_devices[] = {
	{ PCI_VENDOR_JMICRON,	PCI_PRODUCT_JMICRON_JMB360 },
	{ PCI_VENDOR_JMICRON,	PCI_PRODUCT_JMICRON_JMB361 },
	{ PCI_VENDOR_JMICRON,	PCI_PRODUCT_JMICRON_JMB362 },
	{ PCI_VENDOR_JMICRON,	PCI_PRODUCT_JMICRON_JMB363 },
	{ PCI_VENDOR_JMICRON,	PCI_PRODUCT_JMICRON_JMB365 },
	{ PCI_VENDOR_JMICRON,	PCI_PRODUCT_JMICRON_JMB366 },
	{ PCI_VENDOR_JMICRON,	PCI_PRODUCT_JMICRON_JMB368 }
};

int
jmb_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args		*pa = aux;

	return (pci_matchbyid(pa, jmb_devices,
	    sizeof(jmb_devices) / sizeof(jmb_devices[0])) * 3);
}

void
jmb_attach(struct device *parent, struct device *self, void *aux)
{
	struct pci_attach_args		*pa = aux, jpa;
	u_int32_t			ctl0, ctl5;
	int				sata = 0, pata = 0;

	ctl0 = pci_conf_read(pa->pa_pc, pa->pa_tag, JM_PCI_CTL0);
	ctl5 = pci_conf_read(pa->pa_pc, pa->pa_tag, JM_PCI_CTL5);

	/* configure sata bits if it is on this function */
	if (pa->pa_function == (ISSET(ctl0, JM_PCI_CTL0_AHCI_F1) ? 1 : 0)) {
		ctl0 &= ~(JM_PCI_CTL0_AHCI_EN | JM_PCI_CTL0_SATA0_IDE |
		    JM_PCI_CTL0_SATA0_AHCI | JM_PCI_CTL0_SATA1_IDE |
		    JM_PCI_CTL0_SATA1_AHCI);

		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_JMICRON_JMB360:
		case PCI_PRODUCT_JMICRON_JMB361:
		case PCI_PRODUCT_JMICRON_JMB362:
		case PCI_PRODUCT_JMICRON_JMB363:
		case PCI_PRODUCT_JMICRON_JMB365:
		case PCI_PRODUCT_JMICRON_JMB366:
			/* enable AHCI */
			ctl0 |= JM_PCI_CTL0_AHCI_EN | JM_PCI_CTL0_SATA0_AHCI |
			    JM_PCI_CTL0_SATA1_AHCI;
			sata = 1;
			break;
		}
	}

	/* configure pata bits if it is on this function */
	if (pa->pa_function == (ISSET(ctl0, JM_PCI_CTL0_PCIIDE_F1) ? 1 : 0)) {
		ctl0 &= ~(JM_PCI_CTL0_PCIIDE_CS | JM_PCI_CTL0_IDEDMA_CFG);
		ctl5 &= ~JM_PCI_CTL5_PATA1_PRI;

		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_JMICRON_JMB366:
		case PCI_PRODUCT_JMICRON_JMB365:
			/* wire the second PATA port in the right place */
			ctl5 |= JM_PCI_CTL5_PATA1_PRI;
			/* FALLTHROUGH */
		case PCI_PRODUCT_JMICRON_JMB363:
		case PCI_PRODUCT_JMICRON_JMB361:
		case PCI_PRODUCT_JMICRON_JMB368:
			ctl0 |= JM_PCI_CTL0_PCIIDE_CS | JM_PCI_CTL0_IDEDMA_CFG;
			pata = 1;
			break;
		}
	}

	pci_conf_write(pa->pa_pc, pa->pa_tag, JM_PCI_CTL0, ctl0);
	pci_conf_write(pa->pa_pc, pa->pa_tag, JM_PCI_CTL5, ctl5);

	printf("\n");

	jpa = *pa;

	if (sata) {
		/* tweak the class to look like ahci, then try to attach it */
		jpa.pa_class = (PCI_CLASS_MASS_STORAGE << PCI_CLASS_SHIFT) |
		    (PCI_SUBCLASS_MASS_STORAGE_SATA << PCI_SUBCLASS_SHIFT) |
		    (0x01 << PCI_INTERFACE_SHIFT); /* AHCI_PCI_INTERFACE */
		config_found(self, &jpa, jmb_print);
	}

	if (pata) {
		/* set things up for pciide */
		jpa.pa_class = (PCI_CLASS_MASS_STORAGE << PCI_CLASS_SHIFT) |
		    (PCI_SUBCLASS_MASS_STORAGE_IDE << PCI_SUBCLASS_SHIFT) |
		    (0x85 << PCI_INTERFACE_SHIFT);
		config_found(self, &jpa, jmb_print);
	}
}

int
jmb_print(void *aux, const char *pnp)
{
	struct pci_attach_args		*pa = aux;
	char				devinfo[256];

	if (pnp != NULL) {
		pci_devinfo(pa->pa_id, pa->pa_class, 1, devinfo,
		    sizeof(devinfo));
		printf("%s at %s", devinfo, pnp);
	}

	return (UNCONF);
}
@


1.8
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: jmb.c,v 1.7 2008/03/27 09:21:59 dlg Exp $ */
a25 2

#include <machine/bus.h>
@


1.7
log
@add detach support. this has to be the easiest diff for hotplug ever, go
read it :)

ok kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: jmb.c,v 1.5 2007/07/02 23:50:15 dlg Exp $ */
a24 1
#include <sys/proc.h>
@


1.6
log
@do not blindly configure everything to sit on function 0. jmicron tell me
that some vendors will ship their chip with two functions enabled, so now
the code will only configure the functionality that is enabled on the
current function. two function setups will now work as the oem intended.

requested by kettenis@@
@
text
@d77 4
a80 1
	sizeof(struct jmb_softc), jmb_match, jmb_attach
@


1.5
log
@the jmb362 should work fine
@
text
@d1 1
a1 1
/*	$OpenBSD: jmb.c,v 1.4 2007/07/02 14:10:13 dlg Exp $ */
a110 7
	ctl0 &= ~(JM_PCI_CTL0_PCIIDE_F1 | JM_PCI_CTL0_AHCI_EN | 
	    JM_PCI_CTL0_AHCI_F1 | JM_PCI_CTL0_SATA0_IDE |
	    JM_PCI_CTL0_SATA0_AHCI | JM_PCI_CTL0_SATA1_IDE |
	    JM_PCI_CTL0_SATA1_AHCI | JM_PCI_CTL0_F1_SUBCLASS_M |
	    JM_PCI_CTL0_F0_SUBCLASS_M | JM_PCI_CTL0_PCIIDE_CS |
	    JM_PCI_CTL0_IDEDMA_CFG);

a111 1
	ctl5 &= ~JM_PCI_CTL5_PATA1_PRI;
d113 39
a151 28
	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_JMICRON_JMB360:
	case PCI_PRODUCT_JMICRON_JMB362:
		/* set to single function AHCI mode */
		ctl0 |= JM_PCI_CTL0_AHCI_EN | JM_PCI_CTL0_SATA0_AHCI |
		    JM_PCI_CTL0_SATA1_AHCI |
		    JM_PCI_CTL0_F0_SUBCLASS(JM_PCI_CTL0_SUBCLASS_IDE);
		sata = 1;
		break;

	case PCI_PRODUCT_JMICRON_JMB366:
	case PCI_PRODUCT_JMICRON_JMB365:
		/* wire the second PATA port in the right place */
		ctl5 |= JM_PCI_CTL5_PATA1_PRI;
		/* FALLTHROUGH */
	case PCI_PRODUCT_JMICRON_JMB363:
	case PCI_PRODUCT_JMICRON_JMB361:
		/* enable AHCI */
		ctl0 |= JM_PCI_CTL0_AHCI_EN |
		    JM_PCI_CTL0_SATA0_AHCI | JM_PCI_CTL0_SATA1_AHCI |
		    JM_PCI_CTL0_PCIIDE_CS | JM_PCI_CTL0_IDEDMA_CFG |
		    JM_PCI_CTL0_F0_SUBCLASS(JM_PCI_CTL0_SUBCLASS_AHCI);
		sata = pata = 1;
		break;
	case PCI_PRODUCT_JMICRON_JMB368:
		ctl0 |= JM_PCI_CTL0_PCIIDE_CS | JM_PCI_CTL0_IDEDMA_CFG;
		pata = 1;
		break;
@


1.4
log
@only attach ahci or pciide if the chip can actually support them. deal with
the JMB368 while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: jmb.c,v 1.3 2007/07/02 14:01:14 dlg Exp $ */
d87 1
d123 1
@


1.3
log
@kettenis suggested that i can use pci_intr_map twice on the same device
safely, so i tried it and it worked great. i can reuse the pci_attach_args
to attach ahci and now pciide to jmb without really modifying either of
them. lots of code shrinks.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: jmb.c,v 1.2 2007/07/02 07:17:34 dlg Exp $ */
d107 1
d126 1
d141 6
a146 1
                break;
d156 15
a170 11
	/* tweak the class to look like ahci, then try to attach it */
	jpa.pa_class = (PCI_CLASS_MASS_STORAGE << PCI_CLASS_SHIFT) |
	    (PCI_SUBCLASS_MASS_STORAGE_SATA << PCI_SUBCLASS_SHIFT) |
	    (0x01 << PCI_INTERFACE_SHIFT); /* AHCI_PCI_INTERFACE */
	config_found(self, &jpa, jmb_print);

	/* set things up for pciide */
	jpa.pa_class = (PCI_CLASS_MASS_STORAGE << PCI_CLASS_SHIFT) |
	    (PCI_SUBCLASS_MASS_STORAGE_IDE << PCI_SUBCLASS_SHIFT) |
	    (0x85 << PCI_INTERFACE_SHIFT);
	config_found(self, &jpa, jmb_print);
@


1.2
log
@dont enable the second pci function for pciide support. we're going to
solve this problem a different way now.
@
text
@d1 1
a1 1
/*	$OpenBSD: jmb.c,v 1.1 2007/07/02 01:14:36 dlg Exp $ */
a33 4
#include <dev/ata/atascsi.h>

#include <dev/pci/ahcivar.h>

a83 10

struct jmb_attach_args {
	enum {
		JMB_DEV_AHCI,
		JMB_DEV_IDE
	}			ja_dev;
	struct pci_attach_args	*ja_pa;
	pci_intr_handle_t	ja_ih;
};

d89 2
a90 1
	{ PCI_VENDOR_JMICRON,	PCI_PRODUCT_JMICRON_JMB366 }
d99 1
a99 1
	    sizeof(jmb_devices) / sizeof(jmb_devices[0])));
d105 1
a105 2
	struct pci_attach_args		*pa = aux;
	struct jmb_attach_args		ja;
d124 1
a124 1
		    JM_PCI_CTL0_F0_SUBCLASS(JM_PCI_CTL0_SUBCLASS_AHCI);
d137 2
a138 1
		    JM_PCI_CTL0_PCIIDE_CS | JM_PCI_CTL0_IDEDMA_CFG;
d145 1
a145 8
	bzero(&ja, sizeof(ja));
	ja.ja_pa = pa;

	if (pci_intr_map(pa, &ja.ja_ih) != 0) {
		printf(": unable to map interrupt\n");
		return;
	}
	printf(": %s\n", pci_intr_string(pa->pa_pc, ja.ja_ih));
d147 1
a147 2
	ja.ja_dev = JMB_DEV_AHCI;
	config_found(self, &ja, jmb_print);
d149 11
a159 2
	ja.ja_dev = JMB_DEV_IDE;
	config_found(self, &ja, jmb_print);
d165 2
a166 1
	struct jmb_attach_args		*ja = aux;
d169 3
a171 2
		printf("\"%s\" at %s",
		    (ja->ja_dev == JMB_DEV_AHCI) ? "sata" : "pata", pnp);
a174 31
}


int			ahci_jmb_match(struct device *, void *, void *);
void			ahci_jmb_attach(struct device *, struct device *,
			    void *);

struct cfattach ahci_jmb_ca = {
	sizeof(struct ahci_softc), ahci_jmb_match, ahci_jmb_attach
};

int
ahci_jmb_match(struct device *parent, void *match, void *aux)
{
	struct jmb_attach_args		*ja = aux;

	if (ja->ja_dev == JMB_DEV_AHCI)
		return (1);

	return (0);
}

void
ahci_jmb_attach(struct device *parent, struct device *self, void *aux)
{
	struct ahci_softc		*sc = (struct ahci_softc *)self;
	struct jmb_attach_args		*ja = aux;

	printf(":");

	ahci_attach(sc, ja->ja_pa, ja->ja_ih);
@


1.1
log
@jmicron controllers are strange cos they provide both ide and sata support
on the same pci function. they can be configured to put the different
support on different pci functions after booting, but that is unreliable
since the kernel doesnt know enough to be able to configure the interrupts
properly on this new pci function.

this adds a "nexus" driver called jmb that will allow two drivers to attach
to the one pci device. this code already fixes things so ahci can attach to
the sata stuff. this is more reliable than switch functions on since the
interrupts on function 0 are configured by the firmware/bios/whatever.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d148 2
a149 2
		/* enable AHCI and put IDE on the second function */
		ctl0 |= JM_PCI_CTL0_PCIIDE_F1 | JM_PCI_CTL0_AHCI_EN |
a150 2
		    JM_PCI_CTL0_F0_SUBCLASS(JM_PCI_CTL0_SUBCLASS_AHCI) |
		    JM_PCI_CTL0_F1_SUBCLASS(JM_PCI_CTL0_SUBCLASS_IDE) |
@

