head	1.42;
access;
symbols
	OPENBSD_6_2:1.42.0.2
	OPENBSD_6_2_BASE:1.42
	OPENBSD_6_1:1.42.0.4
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.40.0.8
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.37.0.6
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.33.0.8
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.6
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.4
	OPENBSD_5_0:1.33.0.2
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.4
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.14.0.6
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.8
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.5.0.2
	UBC_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	SMP:1.1.0.8
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.6
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.42
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.41;
commitid	qGgYgJTgEFuAoGj4;

1.41
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.40;
commitid	pi1a9KN0itEngOc4;

1.40
date	2015.06.18.20.02.57;	author naddy;	state Exp;
branches;
next	1.39;
commitid	GDbPdzWHCNtCh6q0;

1.39
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.38;
commitid	RaOGL5SyOGOZylwx;

1.38
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.37;
commitid	p4LJxGKbi0BU2cG6;

1.37
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.36;
commitid	OBNa5kfxQ2UXoiIw;

1.36
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.34;

1.34
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.33;

1.33
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	2011.06.29.19.51.12;	author naddy;	state Exp;
branches;
next	1.31;

1.31
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.30;

1.30
date	2010.10.09.09.11.13;	author jakemsr;	state Exp;
branches;
next	1.29;

1.29
date	2010.10.08.14.01.07;	author jakemsr;	state Exp;
branches;
next	1.28;

1.28
date	2010.09.12.03.17.34;	author jakemsr;	state Exp;
branches;
next	1.27;

1.27
date	2010.09.12.02.06.54;	author jakemsr;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.25;

1.25
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2009.05.06.23.13.29;	author jakemsr;	state Exp;
branches;
next	1.23;

1.23
date	2009.05.06.22.25.57;	author jakemsr;	state Exp;
branches;
next	1.22;

1.22
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.21;

1.21
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.20;

1.20
date	2008.05.29.07.20.15;	author jakemsr;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.13.02.24.08;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2008.04.21.00.32.43;	author jakemsr;	state Exp;
branches;
next	1.17;

1.17
date	2008.01.09.02.17.52;	author jakemsr;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.13.16.51.19;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.03.08.52.03;	author jakemsr;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.27.00.45.59;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.14.12.42.16;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.09.03.42.19;	author kevlo;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.05.23.53.54;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.31.11.00.24;	author art;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.10.03.18.20.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.12.15.40.30;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.27.02.19.41;	author millert;	state Exp;
branches
	1.1.8.1;
next	;

1.1.8.1
date	2001.05.14.22.25.35;	author niklas;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2001.07.04.10.41.56;	author niklas;	state Exp;
branches;
next	1.1.8.3;

1.1.8.3
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.1.8.4;

1.1.8.4
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.1.8.5;

1.1.8.5
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.1.8.6;

1.1.8.6
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.1.8.7;

1.1.8.7
date	2003.03.28.00.38.20;	author niklas;	state Exp;
branches;
next	1.1.8.8;

1.1.8.8
date	2003.05.13.19.35.04;	author ho;	state Exp;
branches;
next	1.1.8.9;

1.1.8.9
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.1.8.10;

1.1.8.10
date	2004.02.19.10.56.25;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2002.01.31.22.55.34;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Remove unused getdev() audio driver functions.
@
text
@/*	$OpenBSD: cmpci.c,v 1.41 2016/09/14 06:12:19 ratchov Exp $	*/
/*	$NetBSD: cmpci.c,v 1.25 2004/10/26 06:32:20 xtraeme Exp $	*/

/*
 * Copyright (c) 2000, 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Takuya SHIOZAKI <tshiozak@@NetBSD.org> .
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by ITOH Yasufumi.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * C-Media CMI8x38, CMI8768 Audio Chip Support.
 *
 * TODO:
 *   - Joystick support.
 *
 */

#if defined(AUDIO_DEBUG) || defined(DEBUG)
#define DPRINTF(x) if (cmpcidebug) printf x
int cmpcidebug = 0;
#else
#define DPRINTF(x)
#endif

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>
#include <dev/midi_if.h>

#include <dev/pci/cmpcireg.h>
#include <dev/pci/cmpcivar.h>

#include <machine/bus.h>
#include <machine/intr.h>

/*
 * Low-level HW interface
 */
uint8_t cmpci_mixerreg_read(struct cmpci_softc *, uint8_t);
void cmpci_mixerreg_write(struct cmpci_softc *, uint8_t, uint8_t);
void cmpci_reg_partial_write_1(struct cmpci_softc *, int, int,
						    unsigned, unsigned);
void cmpci_reg_partial_write_4(struct cmpci_softc *, int, int,
						    uint32_t, uint32_t);
void cmpci_reg_set_1(struct cmpci_softc *, int, uint8_t);
void cmpci_reg_clear_1(struct cmpci_softc *, int, uint8_t);
void cmpci_reg_set_4(struct cmpci_softc *, int, uint32_t);
void cmpci_reg_clear_4(struct cmpci_softc *, int, uint32_t);
void cmpci_reg_set_reg_misc(struct cmpci_softc *, uint32_t);
void cmpci_reg_clear_reg_misc(struct cmpci_softc *, uint32_t);
int cmpci_rate_to_index(int);
int cmpci_index_to_rate(int);
int cmpci_index_to_divider(int);

int cmpci_adjust(int, int);
void cmpci_set_mixer_gain(struct cmpci_softc *, int);
void cmpci_set_out_ports(struct cmpci_softc *);
int cmpci_set_in_ports(struct cmpci_softc *);

int cmpci_resume(struct cmpci_softc *);

/*
 * autoconf interface
 */
int cmpci_match(struct device *, void *, void *);
void cmpci_attach(struct device *, struct device *, void *);
int cmpci_activate(struct device *, int);

struct cfdriver cmpci_cd = {
	NULL, "cmpci", DV_DULL
};

struct cfattach cmpci_ca = {
	sizeof (struct cmpci_softc), cmpci_match, cmpci_attach, NULL,
	cmpci_activate
};

/* interrupt */
int cmpci_intr(void *);

/*
 * DMA stuff
 */
int cmpci_alloc_dmamem(struct cmpci_softc *,
				   size_t, int,
				   int, caddr_t *);
int cmpci_free_dmamem(struct cmpci_softc *, caddr_t,
				  int);
struct cmpci_dmanode * cmpci_find_dmamem(struct cmpci_softc *,
						     caddr_t);

/*
 * Interface to machine independent layer
 */
int cmpci_open(void *, int);
void cmpci_close(void *);
int cmpci_set_params(void *, int, int,
				 struct audio_params *,
				 struct audio_params *);
int cmpci_round_blocksize(void *, int);
int cmpci_halt_output(void *);
int cmpci_halt_input(void *);
int cmpci_set_port(void *, mixer_ctrl_t *);
int cmpci_get_port(void *, mixer_ctrl_t *);
int cmpci_query_devinfo(void *, mixer_devinfo_t *);
void *cmpci_malloc(void *, int, size_t, int, int);
void cmpci_free(void *, void *, int);
size_t cmpci_round_buffersize(void *, int, size_t);
int cmpci_get_props(void *);
int cmpci_trigger_output(void *, void *, void *, int,
				     void (*)(void *), void *,
				     struct audio_params *);
int cmpci_trigger_input(void *, void *, void *, int,
				    void (*)(void *), void *,
				    struct audio_params *);

struct audio_hw_if cmpci_hw_if = {
	cmpci_open,		/* open */
	cmpci_close,		/* close */
	cmpci_set_params,	/* set_params */
	cmpci_round_blocksize,	/* round_blocksize */
	NULL,			/* commit_settings */
	NULL,			/* init_output */
	NULL,			/* init_input */
	NULL,			/* start_output */
	NULL,			/* start_input */
	cmpci_halt_output,	/* halt_output */
	cmpci_halt_input,	/* halt_input */
	NULL,			/* speaker_ctl */
	NULL,			/* setfd */
	cmpci_set_port,		/* set_port */
	cmpci_get_port,		/* get_port */
	cmpci_query_devinfo,	/* query_devinfo */
	cmpci_malloc,		/* malloc */
	cmpci_free,		/* free */
	cmpci_round_buffersize,/* round_buffersize */
	cmpci_get_props,	/* get_props */
	cmpci_trigger_output,	/* trigger_output */
	cmpci_trigger_input	/* trigger_input */
};

/*
 * Low-level HW interface
 */

/* mixer register read/write */
uint8_t
cmpci_mixerreg_read(struct cmpci_softc *sc, uint8_t no)
{
	uint8_t ret;

	bus_space_write_1(sc->sc_iot, sc->sc_ioh, CMPCI_REG_SBADDR, no);
	delay(10);
	ret = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CMPCI_REG_SBDATA);
	delay(10);
	return ret;
}

void
cmpci_mixerreg_write(struct cmpci_softc *sc, uint8_t no, uint8_t val)
{
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, CMPCI_REG_SBADDR, no);
	delay(10);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, CMPCI_REG_SBDATA, val);
	delay(10);
}

/* register partial write */
void
cmpci_reg_partial_write_1(struct cmpci_softc *sc, int no, int shift,
    unsigned mask, unsigned val)
{
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, no,
	    (val<<shift) |
	    (bus_space_read_1(sc->sc_iot, sc->sc_ioh, no) & ~(mask<<shift)));
	delay(10);
}

void
cmpci_reg_partial_write_4(struct cmpci_softc *sc, int no, int shift,
    uint32_t mask, uint32_t val)
{
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, no,
	    (val<<shift) |
	    (bus_space_read_4(sc->sc_iot, sc->sc_ioh, no) & ~(mask<<shift)));
	delay(10);
}

/* register set/clear bit */
void
cmpci_reg_set_1(struct cmpci_softc *sc, int no, uint8_t mask)
{
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, no,
	    (bus_space_read_1(sc->sc_iot, sc->sc_ioh, no) | mask));
	delay(10);
}

void
cmpci_reg_clear_1(struct cmpci_softc *sc, int no, uint8_t mask)
{
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, no,
	    (bus_space_read_1(sc->sc_iot, sc->sc_ioh, no) & ~mask));
	delay(10);
}

void
cmpci_reg_set_4(struct cmpci_softc *sc, int no, uint32_t mask)
{
	/* use cmpci_reg_set_reg_misc() for CMPCI_REG_MISC */
	KDASSERT(no != CMPCI_REG_MISC);

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, no,
	    (bus_space_read_4(sc->sc_iot, sc->sc_ioh, no) | mask));
	delay(10);
}

void
cmpci_reg_clear_4(struct cmpci_softc *sc, int no, uint32_t mask)
{
	/* use cmpci_reg_clear_reg_misc() for CMPCI_REG_MISC */
	KDASSERT(no != CMPCI_REG_MISC);

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, no,
	    (bus_space_read_4(sc->sc_iot, sc->sc_ioh, no) & ~mask));
	delay(10);
}

/*
 * The CMPCI_REG_MISC register needs special handling, since one of
 * its bits has different read/write values.
 */
void
cmpci_reg_set_reg_misc(struct cmpci_softc *sc, uint32_t mask)
{
	sc->sc_reg_misc |= mask;
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, CMPCI_REG_MISC,
	    sc->sc_reg_misc);
	delay(10);
}

void
cmpci_reg_clear_reg_misc(struct cmpci_softc *sc, uint32_t mask)
{
	sc->sc_reg_misc &= ~mask;
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, CMPCI_REG_MISC,
	    sc->sc_reg_misc);
	delay(10);
}

/* rate */
static const struct {
	int rate;
	int divider;
} cmpci_rate_table[CMPCI_REG_NUMRATE] = {
#define _RATE(n) { n, CMPCI_REG_RATE_ ## n }
	_RATE(5512),
	_RATE(8000),
	_RATE(11025),
	_RATE(16000),
	_RATE(22050),
	_RATE(32000),
	_RATE(44100),
	_RATE(48000)
#undef	_RATE
};

int
cmpci_rate_to_index(int rate)
{
	int i;

	for (i = 0; i < CMPCI_REG_NUMRATE - 1; i++)
		if (rate <=
		    (cmpci_rate_table[i].rate + cmpci_rate_table[i+1].rate) / 2)
			return i;
	return i;  /* 48000 */
}

int
cmpci_index_to_rate(int index)
{
	return cmpci_rate_table[index].rate;
}

int
cmpci_index_to_divider(int index)
{
	return cmpci_rate_table[index].divider;
}

const struct pci_matchid cmpci_devices[] = {
	{ PCI_VENDOR_CMI, PCI_PRODUCT_CMI_CMI8338A },
	{ PCI_VENDOR_CMI, PCI_PRODUCT_CMI_CMI8338B },
	{ PCI_VENDOR_CMI, PCI_PRODUCT_CMI_CMI8738 },
	{ PCI_VENDOR_CMI, PCI_PRODUCT_CMI_CMI8738B }
};

/*
 * interface to configure the device.
 */

int
cmpci_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, cmpci_devices,
	    nitems(cmpci_devices)));
}

void
cmpci_attach(struct device *parent, struct device *self, void *aux)
{
	struct cmpci_softc *sc = (struct cmpci_softc *)self;
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	struct audio_attach_args aa;
	pci_intr_handle_t ih;
	char const *intrstr;
	int i, v, d;

	sc->sc_id = pa->pa_id;
	sc->sc_class = pa->pa_class;
	switch (PCI_PRODUCT(sc->sc_id)) {
	case PCI_PRODUCT_CMI_CMI8338A:
		/*FALLTHROUGH*/
	case PCI_PRODUCT_CMI_CMI8338B:
		sc->sc_capable = CMPCI_CAP_CMI8338;
		break;
	case PCI_PRODUCT_CMI_CMI8738:
		/*FALLTHROUGH*/
	case PCI_PRODUCT_CMI_CMI8738B:
		sc->sc_capable = CMPCI_CAP_CMI8738;
		break;
	}

	/* map I/O space */
	if (pci_mapreg_map(pa, CMPCI_PCI_IOBASEREG, PCI_MAPREG_TYPE_IO, 0,
			   &sc->sc_iot, &sc->sc_ioh, NULL, NULL, 0)) {
		printf(": can't map i/o space\n");
		return;
	}

	/* interrupt */
	if (pci_intr_map(pa, &ih)) {
		printf(": can't map interrupt\n");
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_AUDIO | IPL_MPSAFE,
	    cmpci_intr, sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": can't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s\n", intrstr);

	sc->sc_dmat = pa->pa_dmat;

	audio_attach_mi(&cmpci_hw_if, sc, &sc->sc_dev);

	/* attach OPL device */
	aa.type = AUDIODEV_TYPE_OPL;
	aa.hwif = NULL;
	aa.hdl = NULL;
	(void)config_found(&sc->sc_dev, &aa, audioprint);

	/* attach MPU-401 device */
	aa.type = AUDIODEV_TYPE_MPU;
	aa.hwif = NULL;
	aa.hdl = NULL;
	if (bus_space_subregion(sc->sc_iot, sc->sc_ioh,
	    CMPCI_REG_MPU_BASE, CMPCI_REG_MPU_SIZE, &sc->sc_mpu_ioh) == 0)
		sc->sc_mpudev = config_found(&sc->sc_dev, &aa, audioprint);

	/* get initial value (this is 0 and may be omitted but just in case) */
	sc->sc_reg_misc = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
	    CMPCI_REG_MISC) & ~CMPCI_REG_SPDIF48K;

	/* extra capabilitites check */
	d = bus_space_read_4(sc->sc_iot, sc->sc_ioh, CMPCI_REG_INTR_CTRL) &
	    CMPCI_REG_CHIP_MASK2;
	if (d) {
		if (d & CMPCI_REG_CHIP_8768) {
			sc->sc_version = 68;
			sc->sc_capable |= CMPCI_CAP_4CH | CMPCI_CAP_6CH |
			    CMPCI_CAP_8CH;
		} else if (d & CMPCI_REG_CHIP_055) {
			sc->sc_version = 55;
			sc->sc_capable |= CMPCI_CAP_4CH | CMPCI_CAP_6CH;
		} else if (d & CMPCI_REG_CHIP_039) {
			sc->sc_version = 39;
			sc->sc_capable |= CMPCI_CAP_4CH |
			    ((d & CMPCI_REG_CHIP_039_6CH) ? CMPCI_CAP_6CH : 0);
		} else {
			/* unknown version */
			sc->sc_version = 0;
		}
	} else {
		d = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    CMPCI_REG_CHANNEL_FORMAT) & CMPCI_REG_CHIP_MASK1;
		if (d)
			sc->sc_version = 37;
		else
			sc->sc_version = 33;
	}

	cmpci_mixerreg_write(sc, CMPCI_SB16_MIXER_RESET, 0);
	cmpci_mixerreg_write(sc, CMPCI_SB16_MIXER_ADCMIX_L, 0);
	cmpci_mixerreg_write(sc, CMPCI_SB16_MIXER_ADCMIX_R, 0);
	cmpci_mixerreg_write(sc, CMPCI_SB16_MIXER_OUTMIX,
	    CMPCI_SB16_SW_CD|CMPCI_SB16_SW_MIC|CMPCI_SB16_SW_LINE);
	for (i = 0; i < CMPCI_NDEVS; i++) {
		switch(i) {
		/*
		 * CMI8738 defaults are
		 *  master:	0xe0	(0x00 - 0xf8)
		 *  FM, DAC:	0xc0	(0x00 - 0xf8)
		 *  PC speaker:	0x80	(0x00 - 0xc0)
		 *  others:	0
		 */
		/* volume */
		case CMPCI_MASTER_VOL:
			v = 128;	/* 224 */
			break;
		case CMPCI_FM_VOL:
		case CMPCI_DAC_VOL:
			v = 192;
			break;
		case CMPCI_PCSPEAKER:
			v = 128;
			break;

		/* booleans, set to true */
		case CMPCI_CD_MUTE:
		case CMPCI_MIC_MUTE:
		case CMPCI_LINE_IN_MUTE:
		case CMPCI_AUX_IN_MUTE:
			v = 1;
			break;

		/* volume with inital value 0 */
		case CMPCI_CD_VOL:
		case CMPCI_LINE_IN_VOL:
		case CMPCI_AUX_IN_VOL:
		case CMPCI_MIC_VOL:
		case CMPCI_MIC_RECVOL:
			/* FALLTHROUGH */

		/* others are cleared */
		case CMPCI_MIC_PREAMP:
		case CMPCI_RECORD_SOURCE:
		case CMPCI_PLAYBACK_MODE:
		case CMPCI_SPDIF_IN_SELECT:
		case CMPCI_SPDIF_IN_PHASE:
		case CMPCI_SPDIF_LOOP:
		case CMPCI_SPDIF_OUT_PLAYBACK:
		case CMPCI_SPDIF_OUT_VOLTAGE:
		case CMPCI_MONITOR_DAC:
		case CMPCI_REAR:
		case CMPCI_INDIVIDUAL:
		case CMPCI_REVERSE:
		case CMPCI_SURROUND:
		default:
			v = 0;
			break;
		}
		sc->sc_gain[i][CMPCI_LEFT] = sc->sc_gain[i][CMPCI_RIGHT] = v;
		cmpci_set_mixer_gain(sc, i);
	}

	sc->sc_play_channel = 0;
}

int
cmpci_activate(struct device *self, int act)
{
	struct cmpci_softc *sc = (struct cmpci_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_RESUME:
		cmpci_resume(sc);
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

int
cmpci_resume(struct cmpci_softc *sc)
{
	int i;

	cmpci_mixerreg_write(sc, CMPCI_SB16_MIXER_RESET, 0);
	for (i = 0; i < CMPCI_NDEVS; i++)
		cmpci_set_mixer_gain(sc, i);

	return 0;
}

int
cmpci_intr(void *handle)
{
	struct cmpci_softc *sc = handle;
	struct cmpci_channel *chan;
	uint32_t intrstat;
	uint16_t hwpos;

	mtx_enter(&audio_lock);
	intrstat = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
	    CMPCI_REG_INTR_STATUS);

	if (!(intrstat & CMPCI_REG_ANY_INTR)) {
		mtx_leave(&audio_lock);
		return 0;
	}

	delay(10);

	/* disable and reset intr */
	if (intrstat & CMPCI_REG_CH0_INTR)
		cmpci_reg_clear_4(sc, CMPCI_REG_INTR_CTRL,
		   CMPCI_REG_CH0_INTR_ENABLE);
	if (intrstat & CMPCI_REG_CH1_INTR)
		cmpci_reg_clear_4(sc, CMPCI_REG_INTR_CTRL,
		    CMPCI_REG_CH1_INTR_ENABLE);

	if (intrstat & CMPCI_REG_CH0_INTR) {
		chan = &sc->sc_ch0;
		if (chan->intr != NULL) {
			hwpos = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
			    CMPCI_REG_DMA0_BYTES);
			hwpos = hwpos * chan->bps / chan->blksize;
			hwpos = chan->nblocks - hwpos - 1;
			while (chan->swpos != hwpos) {
				(*chan->intr)(chan->intr_arg);
				chan->swpos++;
				if (chan->swpos >= chan->nblocks)
					chan->swpos = 0;
				if (chan->swpos != hwpos) {
					DPRINTF(("%s: DMA0 hwpos=%d swpos=%d\n",
					    __func__, hwpos, chan->swpos));
				}
			}
		}
	}
	if (intrstat & CMPCI_REG_CH1_INTR) {
		chan = &sc->sc_ch1;
		if (chan->intr != NULL) {
			hwpos = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
			    CMPCI_REG_DMA1_BYTES);
			hwpos = hwpos * chan->bps / chan->blksize;
			hwpos = chan->nblocks - hwpos - 1;
			while (chan->swpos != hwpos) {
				(*chan->intr)(chan->intr_arg);
				chan->swpos++;
				if (chan->swpos >= chan->nblocks)
					chan->swpos = 0;
				if (chan->swpos != hwpos) {
					DPRINTF(("%s: DMA1 hwpos=%d swpos=%d\n",
					    __func__, hwpos, chan->swpos));
				}
			}
		}
	}

	/* enable intr */
	if (intrstat & CMPCI_REG_CH0_INTR)
		cmpci_reg_set_4(sc, CMPCI_REG_INTR_CTRL,
		    CMPCI_REG_CH0_INTR_ENABLE);
	if (intrstat & CMPCI_REG_CH1_INTR)
		cmpci_reg_set_4(sc, CMPCI_REG_INTR_CTRL,
		    CMPCI_REG_CH1_INTR_ENABLE);

#if 0
	if (intrstat & CMPCI_REG_UART_INTR && sc->sc_mpudev != NULL)
		mpu_intr(sc->sc_mpudev);
#endif

	mtx_leave(&audio_lock);
	return 1;
}

/* open/close */
int
cmpci_open(void *handle, int flags)
{
	return 0;
}

void
cmpci_close(void *handle)
{
}

int
cmpci_set_params(void *handle, int setmode, int usemode,
    struct audio_params *play, struct audio_params *rec)
{
	int i;
	struct cmpci_softc *sc = handle;

	for (i = 0; i < 2; i++) {
		int md_format;
		int md_divide;
		int md_index;
		int mode;
		struct audio_params *p;

		switch (i) {
		case 0:
			mode = AUMODE_PLAY;
			p = play;
			break;
		case 1:
			mode = AUMODE_RECORD;
			p = rec;
			break;
		default:
			return EINVAL;
		}

		if (!(setmode & mode))
			continue;

		if (setmode & AUMODE_RECORD) {
			if (p->channels > 2)
				p->channels = 2;
			sc->sc_play_channel = 0;
			cmpci_reg_clear_reg_misc(sc, CMPCI_REG_ENDBDAC);
			cmpci_reg_clear_reg_misc(sc, CMPCI_REG_XCHGDAC);
		} else {
			sc->sc_play_channel = 1;
			cmpci_reg_set_reg_misc(sc, CMPCI_REG_ENDBDAC);
			cmpci_reg_set_reg_misc(sc, CMPCI_REG_XCHGDAC);
		}

		cmpci_reg_clear_4(sc, CMPCI_REG_LEGACY_CTRL,
		    CMPCI_REG_NXCHG);
		if (sc->sc_capable & CMPCI_CAP_4CH)
			cmpci_reg_clear_4(sc, CMPCI_REG_CHANNEL_FORMAT,
			    CMPCI_REG_CHB3D);
		if (sc->sc_capable & CMPCI_CAP_6CH) {
			cmpci_reg_clear_4(sc, CMPCI_REG_CHANNEL_FORMAT,
			    CMPCI_REG_CHB3D5C);
			cmpci_reg_clear_4(sc, CMPCI_REG_LEGACY_CTRL,
		    	    CMPCI_REG_CHB3D6C);
			cmpci_reg_clear_reg_misc(sc, CMPCI_REG_ENCENTER);
		}
		if (sc->sc_capable & CMPCI_CAP_8CH)
			cmpci_reg_clear_4(sc, CMPCI_REG_8768_MISC,
			    CMPCI_REG_CHB3D8C);

		/* format */
		switch (p->channels) {
		case 1:
			md_format = CMPCI_REG_FORMAT_MONO;
			break;
		case 2:
			md_format = CMPCI_REG_FORMAT_STEREO;
			break;
		case 4:
			if (mode & AUMODE_PLAY) {
				if (sc->sc_capable & CMPCI_CAP_4CH) {
					cmpci_reg_clear_reg_misc(sc,
					    CMPCI_REG_N4SPK3D);
					cmpci_reg_set_4(sc,
					    CMPCI_REG_CHANNEL_FORMAT,
					    CMPCI_REG_CHB3D);
					cmpci_reg_set_4(sc,
					    CMPCI_REG_LEGACY_CTRL,
					    CMPCI_REG_NXCHG);
				} else
					p->channels = 2;
			}
			md_format = CMPCI_REG_FORMAT_STEREO;
			break;
		case 6:
			if (mode & AUMODE_PLAY) {
				if (sc->sc_capable & CMPCI_CAP_6CH) {
					cmpci_reg_clear_reg_misc(sc,
					    CMPCI_REG_N4SPK3D);
					cmpci_reg_set_4(sc,
					    CMPCI_REG_CHANNEL_FORMAT,
					    CMPCI_REG_CHB3D5C);
					cmpci_reg_set_4(sc,
					    CMPCI_REG_LEGACY_CTRL,
					    CMPCI_REG_CHB3D6C);
					cmpci_reg_set_reg_misc(sc,
					    CMPCI_REG_ENCENTER);
					cmpci_reg_set_4(sc,
					    CMPCI_REG_LEGACY_CTRL,
					    CMPCI_REG_NXCHG);
				} else
					p->channels = 2;
			}
			md_format = CMPCI_REG_FORMAT_STEREO;
			break;
		case 8:
			if (mode & AUMODE_PLAY) {
				if (sc->sc_capable & CMPCI_CAP_8CH) {
					cmpci_reg_clear_reg_misc(sc,
					    CMPCI_REG_N4SPK3D);
					cmpci_reg_set_4(sc,
					    CMPCI_REG_CHANNEL_FORMAT,
					    CMPCI_REG_CHB3D5C);
					cmpci_reg_set_4(sc,
					    CMPCI_REG_LEGACY_CTRL,
					    CMPCI_REG_CHB3D6C);
					cmpci_reg_set_reg_misc(sc,
					    CMPCI_REG_ENCENTER);
					cmpci_reg_set_4(sc,
					    CMPCI_REG_8768_MISC,
					    CMPCI_REG_CHB3D8C);
					cmpci_reg_set_4(sc,
					    CMPCI_REG_LEGACY_CTRL,
					    CMPCI_REG_NXCHG);
				} else
					p->channels = 2;
			}
			md_format = CMPCI_REG_FORMAT_STEREO;
			break;
		default:
			return (EINVAL);
		}
		if (p->precision >= 16) {
			p->precision = 16;
			p->encoding = AUDIO_ENCODING_SLINEAR_LE;
			md_format |= CMPCI_REG_FORMAT_16BIT;
		} else {
			p->precision = 8;
			p->encoding = AUDIO_ENCODING_ULINEAR_LE;
			md_format |= CMPCI_REG_FORMAT_8BIT;
		}
		p->bps = AUDIO_BPS(p->precision);
		p->msb = 1;
		if (mode & AUMODE_PLAY) {
			if (sc->sc_play_channel == 1) {
				cmpci_reg_partial_write_4(sc,
				   CMPCI_REG_CHANNEL_FORMAT,
				   CMPCI_REG_CH1_FORMAT_SHIFT,
				   CMPCI_REG_CH1_FORMAT_MASK, md_format);
			} else {
				cmpci_reg_partial_write_4(sc,
				   CMPCI_REG_CHANNEL_FORMAT,
				   CMPCI_REG_CH0_FORMAT_SHIFT,
				   CMPCI_REG_CH0_FORMAT_MASK, md_format);
			}
		} else {
			cmpci_reg_partial_write_4(sc,
			   CMPCI_REG_CHANNEL_FORMAT,
			   CMPCI_REG_CH1_FORMAT_SHIFT,
			   CMPCI_REG_CH1_FORMAT_MASK, md_format);
		}
		/* sample rate */
		md_index = cmpci_rate_to_index(p->sample_rate);
		md_divide = cmpci_index_to_divider(md_index);
		p->sample_rate = cmpci_index_to_rate(md_index);
		DPRINTF(("%s: sample:%d, divider=%d\n",
			 sc->sc_dev.dv_xname, (int)p->sample_rate, md_divide));
		if (mode & AUMODE_PLAY) {
			if (sc->sc_play_channel == 1) {
				cmpci_reg_partial_write_4(sc,
				    CMPCI_REG_FUNC_1, CMPCI_REG_ADC_FS_SHIFT,
				    CMPCI_REG_ADC_FS_MASK, md_divide);
				sc->sc_ch1.md_divide = md_divide;
			} else {
				cmpci_reg_partial_write_4(sc,
				    CMPCI_REG_FUNC_1, CMPCI_REG_DAC_FS_SHIFT,
				    CMPCI_REG_DAC_FS_MASK, md_divide);
				sc->sc_ch0.md_divide = md_divide;
			}
		} else {
			cmpci_reg_partial_write_4(sc,
			    CMPCI_REG_FUNC_1, CMPCI_REG_ADC_FS_SHIFT,
			    CMPCI_REG_ADC_FS_MASK, md_divide);
			sc->sc_ch1.md_divide = md_divide;
		}
	}

	return 0;
}

/* ARGSUSED */
int
cmpci_round_blocksize(void *handle, int block)
{
	return ((block + 3) & -4);
}

int
cmpci_halt_output(void *handle)
{
	struct cmpci_softc *sc = handle;
	uint32_t reg_intr, reg_enable, reg_reset;

	mtx_enter(&audio_lock);
	if (sc->sc_play_channel == 1) {
		sc->sc_ch1.intr = NULL;
		reg_intr = CMPCI_REG_CH1_INTR_ENABLE;
		reg_enable = CMPCI_REG_CH1_ENABLE;
		reg_reset = CMPCI_REG_CH1_RESET;
	} else {
		sc->sc_ch0.intr = NULL;
		reg_intr = CMPCI_REG_CH0_INTR_ENABLE;
		reg_enable = CMPCI_REG_CH0_ENABLE;
		reg_reset = CMPCI_REG_CH0_RESET;
	}
	cmpci_reg_clear_4(sc, CMPCI_REG_INTR_CTRL, reg_intr);
	cmpci_reg_clear_4(sc, CMPCI_REG_FUNC_0, reg_enable);
	/* wait for reset DMA */
	cmpci_reg_set_4(sc, CMPCI_REG_FUNC_0, reg_reset);
	delay(10);
	cmpci_reg_clear_4(sc, CMPCI_REG_FUNC_0, reg_reset);
	mtx_leave(&audio_lock);
	return 0;
}

int
cmpci_halt_input(void *handle)
{
	struct cmpci_softc *sc = handle;

	mtx_enter(&audio_lock);
	sc->sc_ch1.intr = NULL;
	cmpci_reg_clear_4(sc, CMPCI_REG_INTR_CTRL, CMPCI_REG_CH1_INTR_ENABLE);
	cmpci_reg_clear_4(sc, CMPCI_REG_FUNC_0, CMPCI_REG_CH1_ENABLE);
	/* wait for reset DMA */
	cmpci_reg_set_4(sc, CMPCI_REG_FUNC_0, CMPCI_REG_CH1_RESET);
	delay(10);
	cmpci_reg_clear_4(sc, CMPCI_REG_FUNC_0, CMPCI_REG_CH1_RESET);
	mtx_leave(&audio_lock);
	return 0;
}

/* mixer device information */
int
cmpci_query_devinfo(void *handle, mixer_devinfo_t *dip)
{
	static const char *const mixer_port_names[] = {
		AudioNdac, AudioNfmsynth, AudioNcd, AudioNline, AudioNaux,
		AudioNmicrophone
	};
	static const char *const mixer_classes[] = {
		AudioCinputs, AudioCoutputs, AudioCrecord, CmpciCplayback,
		CmpciCspdif
	};
	struct cmpci_softc *sc = handle;
	int i;

	dip->prev = dip->next = AUDIO_MIXER_LAST;

	switch (dip->index) {
	case CMPCI_INPUT_CLASS:
	case CMPCI_OUTPUT_CLASS:
	case CMPCI_RECORD_CLASS:
	case CMPCI_PLAYBACK_CLASS:
	case CMPCI_SPDIF_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = dip->index;
		strlcpy(dip->label.name,
		    mixer_classes[dip->index - CMPCI_INPUT_CLASS],
		    sizeof dip->label.name);
		return 0;

	case CMPCI_AUX_IN_VOL:
		dip->un.v.delta = 1 << (8 - CMPCI_REG_AUX_VALBITS);
		goto vol1;
	case CMPCI_DAC_VOL:
	case CMPCI_FM_VOL:
	case CMPCI_CD_VOL:
	case CMPCI_LINE_IN_VOL:
	case CMPCI_MIC_VOL:
		dip->un.v.delta = 1 << (8 - CMPCI_SB16_MIXER_VALBITS);
	vol1:	dip->mixer_class = CMPCI_INPUT_CLASS;
		dip->next = dip->index + 6;	/* CMPCI_xxx_MUTE */
		strlcpy(dip->label.name, mixer_port_names[dip->index],
		    sizeof dip->label.name);
		dip->un.v.num_channels = (dip->index == CMPCI_MIC_VOL ? 1 : 2);
	vol:
		dip->type = AUDIO_MIXER_VALUE;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return 0;

	case CMPCI_MIC_MUTE:
		dip->next = CMPCI_MIC_PREAMP;
		/* FALLTHROUGH */
	case CMPCI_DAC_MUTE:
	case CMPCI_FM_MUTE:
	case CMPCI_CD_MUTE:
	case CMPCI_LINE_IN_MUTE:
	case CMPCI_AUX_IN_MUTE:
		dip->prev = dip->index - 6;	/* CMPCI_xxx_VOL */
		dip->mixer_class = CMPCI_INPUT_CLASS;
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
		goto on_off;
	on_off:
		dip->type = AUDIO_MIXER_ENUM;
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = 1;
		return 0;

	case CMPCI_MIC_PREAMP:
		dip->mixer_class = CMPCI_INPUT_CLASS;
		dip->prev = CMPCI_MIC_MUTE;
		strlcpy(dip->label.name, AudioNpreamp, sizeof dip->label.name);
		goto on_off;
	case CMPCI_PCSPEAKER:
		dip->mixer_class = CMPCI_INPUT_CLASS;
		strlcpy(dip->label.name, AudioNspeaker, sizeof dip->label.name);
		dip->un.v.num_channels = 1;
		dip->un.v.delta = 1 << (8 - CMPCI_SB16_MIXER_SPEAKER_VALBITS);
		goto vol;
	case CMPCI_RECORD_SOURCE:
		dip->mixer_class = CMPCI_RECORD_CLASS;
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_SET;
		dip->un.s.num_mem = 7;
		strlcpy(dip->un.s.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.s.member[0].label.name);
		dip->un.s.member[0].mask = CMPCI_RECORD_SOURCE_MIC;
		strlcpy(dip->un.s.member[1].label.name, AudioNcd,
		    sizeof dip->un.s.member[1].label.name);
		dip->un.s.member[1].mask = CMPCI_RECORD_SOURCE_CD;
		strlcpy(dip->un.s.member[2].label.name, AudioNline,
		    sizeof dip->un.s.member[2].label.name);
		dip->un.s.member[2].mask = CMPCI_RECORD_SOURCE_LINE_IN;
		strlcpy(dip->un.s.member[3].label.name, AudioNaux,
		    sizeof dip->un.s.member[3].label.name);
		dip->un.s.member[3].mask = CMPCI_RECORD_SOURCE_AUX_IN;
		strlcpy(dip->un.s.member[4].label.name, AudioNwave,
		    sizeof dip->un.s.member[4].label.name);
		dip->un.s.member[4].mask = CMPCI_RECORD_SOURCE_WAVE;
		strlcpy(dip->un.s.member[5].label.name, AudioNfmsynth,
		    sizeof dip->un.s.member[5].label.name);
		dip->un.s.member[5].mask = CMPCI_RECORD_SOURCE_FM;
		strlcpy(dip->un.s.member[6].label.name, CmpciNspdif,
		    sizeof dip->un.s.member[6].label.name);
		dip->un.s.member[6].mask = CMPCI_RECORD_SOURCE_SPDIF;
		return 0;
	case CMPCI_MIC_RECVOL:
		dip->mixer_class = CMPCI_RECORD_CLASS;
		strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
		dip->un.v.num_channels = 1;
		dip->un.v.delta = 1 << (8 - CMPCI_REG_ADMIC_VALBITS);
		goto vol;

	case CMPCI_PLAYBACK_MODE:
		dip->mixer_class = CMPCI_PLAYBACK_CLASS;
		dip->type = AUDIO_MIXER_ENUM;
		strlcpy(dip->label.name, AudioNmode, sizeof dip->label.name);
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNdac,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = CMPCI_PLAYBACK_MODE_WAVE;
		strlcpy(dip->un.e.member[1].label.name, CmpciNspdif,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = CMPCI_PLAYBACK_MODE_SPDIF;
		return 0;
	case CMPCI_SPDIF_IN_SELECT:
		dip->mixer_class = CMPCI_SPDIF_CLASS;
		dip->type = AUDIO_MIXER_ENUM;
		dip->next = CMPCI_SPDIF_IN_PHASE;
		strlcpy(dip->label.name, AudioNinput, sizeof dip->label.name);
		i = 0;
		strlcpy(dip->un.e.member[i].label.name, CmpciNspdin1,
		    sizeof dip->un.e.member[i].label.name);
		dip->un.e.member[i++].ord = CMPCI_SPDIF_IN_SPDIN1;
		if (CMPCI_ISCAP(sc, 2ND_SPDIN)) {
			strlcpy(dip->un.e.member[i].label.name, CmpciNspdin2,
			    sizeof dip->un.e.member[i].label.name);
			dip->un.e.member[i++].ord = CMPCI_SPDIF_IN_SPDIN2;
		}
		strlcpy(dip->un.e.member[i].label.name, CmpciNspdout,
		    sizeof dip->un.e.member[i].label.name);
		dip->un.e.member[i++].ord = CMPCI_SPDIF_IN_SPDOUT;
		dip->un.e.num_mem = i;
		return 0;
	case CMPCI_SPDIF_IN_PHASE:
		dip->mixer_class = CMPCI_SPDIF_CLASS;
		dip->prev = CMPCI_SPDIF_IN_SELECT;
		strlcpy(dip->label.name, CmpciNphase, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_ENUM;
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, CmpciNpositive,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = CMPCI_SPDIF_IN_PHASE_POSITIVE;
		strlcpy(dip->un.e.member[1].label.name, CmpciNnegative,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = CMPCI_SPDIF_IN_PHASE_NEGATIVE;
		return 0;
	case CMPCI_SPDIF_LOOP:
		dip->mixer_class = CMPCI_SPDIF_CLASS;
		dip->next = CMPCI_SPDIF_OUT_PLAYBACK;
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_ENUM;
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, CmpciNplayback,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = CMPCI_SPDIF_LOOP_OFF;
		strlcpy(dip->un.e.member[1].label.name, CmpciNspdin,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = CMPCI_SPDIF_LOOP_ON;
		return 0;
	case CMPCI_SPDIF_OUT_PLAYBACK:
		dip->mixer_class = CMPCI_SPDIF_CLASS;
		dip->prev = CMPCI_SPDIF_LOOP;
		dip->next = CMPCI_SPDIF_OUT_VOLTAGE;
		strlcpy(dip->label.name, CmpciNplayback, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_ENUM;
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNwave,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = CMPCI_SPDIF_OUT_PLAYBACK_WAVE;
		strlcpy(dip->un.e.member[1].label.name, CmpciNlegacy,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = CMPCI_SPDIF_OUT_PLAYBACK_LEGACY;
		return 0;
	case CMPCI_SPDIF_OUT_VOLTAGE:
		dip->mixer_class = CMPCI_SPDIF_CLASS;
		dip->prev = CMPCI_SPDIF_OUT_PLAYBACK;
		strlcpy(dip->label.name, CmpciNvoltage, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_ENUM;
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, CmpciNhigh_v,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = CMPCI_SPDIF_OUT_VOLTAGE_HIGH;
		strlcpy(dip->un.e.member[1].label.name, CmpciNlow_v,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = CMPCI_SPDIF_OUT_VOLTAGE_LOW;
		return 0;
	case CMPCI_MONITOR_DAC:
		dip->mixer_class = CMPCI_SPDIF_CLASS;
		strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_ENUM;
		dip->un.e.num_mem = 3;
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = CMPCI_MONITOR_DAC_OFF;
		strlcpy(dip->un.e.member[1].label.name, CmpciNspdin,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = CMPCI_MONITOR_DAC_SPDIN;
		strlcpy(dip->un.e.member[2].label.name, CmpciNspdout,
		    sizeof dip->un.e.member[2].label.name);
		dip->un.e.member[2].ord = CMPCI_MONITOR_DAC_SPDOUT;
		return 0;

	case CMPCI_MASTER_VOL:
		dip->mixer_class = CMPCI_OUTPUT_CLASS;
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		dip->un.v.delta = 1 << (8 - CMPCI_SB16_MIXER_VALBITS);
		goto vol;
	case CMPCI_REAR:
		dip->mixer_class = CMPCI_OUTPUT_CLASS;
		dip->next = CMPCI_INDIVIDUAL;
		strlcpy(dip->label.name, CmpciNrear, sizeof dip->label.name);
		goto on_off;
	case CMPCI_INDIVIDUAL:
		dip->mixer_class = CMPCI_OUTPUT_CLASS;
		dip->prev = CMPCI_REAR;
		dip->next = CMPCI_REVERSE;
		strlcpy(dip->label.name, CmpciNindividual, sizeof dip->label.name);
		goto on_off;
	case CMPCI_REVERSE:
		dip->mixer_class = CMPCI_OUTPUT_CLASS;
		dip->prev = CMPCI_INDIVIDUAL;
		strlcpy(dip->label.name, CmpciNreverse, sizeof dip->label.name);
		goto on_off;
	case CMPCI_SURROUND:
		dip->mixer_class = CMPCI_OUTPUT_CLASS;
		strlcpy(dip->label.name, CmpciNsurround, sizeof dip->label.name);
		goto on_off;
	}

	return ENXIO;
}

int
cmpci_alloc_dmamem(struct cmpci_softc *sc, size_t size, int type, int flags,
    caddr_t *r_addr)
{
	int error = 0;
	struct cmpci_dmanode *n;
	int w;

	n = malloc(sizeof(struct cmpci_dmanode), type, flags);
	if (n == NULL) {
		error = ENOMEM;
		goto quit;
	}

	w = (flags & M_NOWAIT) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK;
#define CMPCI_DMABUF_ALIGN    0x4
#define CMPCI_DMABUF_BOUNDARY 0x0
	n->cd_tag = sc->sc_dmat;
	n->cd_size = size;
	error = bus_dmamem_alloc(n->cd_tag, n->cd_size,
	    CMPCI_DMABUF_ALIGN, CMPCI_DMABUF_BOUNDARY, n->cd_segs,
	    nitems(n->cd_segs), &n->cd_nsegs, w);
	if (error)
		goto mfree;
	error = bus_dmamem_map(n->cd_tag, n->cd_segs, n->cd_nsegs, n->cd_size,
	    &n->cd_addr, w | BUS_DMA_COHERENT);
	if (error)
		goto dmafree;
	error = bus_dmamap_create(n->cd_tag, n->cd_size, 1, n->cd_size, 0,
	    w, &n->cd_map);
	if (error)
		goto unmap;
	error = bus_dmamap_load(n->cd_tag, n->cd_map, n->cd_addr, n->cd_size,
	    NULL, w);
	if (error)
		goto destroy;

	n->cd_next = sc->sc_dmap;
	sc->sc_dmap = n;
	*r_addr = KVADDR(n);
	return 0;

 destroy:
	bus_dmamap_destroy(n->cd_tag, n->cd_map);
 unmap:
	bus_dmamem_unmap(n->cd_tag, n->cd_addr, n->cd_size);
 dmafree:
	bus_dmamem_free(n->cd_tag,
			n->cd_segs, nitems(n->cd_segs));
 mfree:
	free(n, type, 0);
 quit:
	return error;
}

int
cmpci_free_dmamem(struct cmpci_softc *sc, caddr_t addr, int type)
{
	struct cmpci_dmanode **nnp;

	for (nnp = &sc->sc_dmap; *nnp; nnp = &(*nnp)->cd_next) {
		if ((*nnp)->cd_addr == addr) {
			struct cmpci_dmanode *n = *nnp;
			bus_dmamap_unload(n->cd_tag, n->cd_map);
			bus_dmamap_destroy(n->cd_tag, n->cd_map);
			bus_dmamem_unmap(n->cd_tag, n->cd_addr, n->cd_size);
			bus_dmamem_free(n->cd_tag, n->cd_segs,
			    nitems(n->cd_segs));
			free(n, type, 0);
			return 0;
		}
	}
	return -1;
}

struct cmpci_dmanode *
cmpci_find_dmamem(struct cmpci_softc *sc, caddr_t addr)
{
	struct cmpci_dmanode *p;

	for (p = sc->sc_dmap; p; p = p->cd_next) {
		if (KVADDR(p) == (void *)addr)
			break;
	}
	return p;
}

#if 0
void cmpci_print_dmamem(struct cmpci_dmanode *p);

void
cmpci_print_dmamem(struct cmpci_dmanode *p)
{
	DPRINTF(("DMA at virt:%p, dmaseg:%p, mapseg:%p, size:%p\n",
		 (void *)p->cd_addr, (void *)p->cd_segs[0].ds_addr,
		 (void *)DMAADDR(p), (void *)p->cd_size));
}
#endif /* DEBUG */

void *
cmpci_malloc(void *handle, int direction, size_t size, int type,
    int flags)
{
	caddr_t addr;

	if (cmpci_alloc_dmamem(handle, size, type, flags, &addr))
		return NULL;
	return addr;
}

void
cmpci_free(void *handle, void *addr, int type)
{
	cmpci_free_dmamem(handle, addr, type);
}

#define MAXVAL 256
int
cmpci_adjust(int val, int mask)
{
	val += (MAXVAL - mask) >> 1;
	if (val >= MAXVAL)
		val = MAXVAL-1;
	return val & mask;
}

void
cmpci_set_mixer_gain(struct cmpci_softc *sc, int port)
{
	int src;
	int bits, mask;

	switch (port) {
	case CMPCI_MIC_VOL:
		cmpci_mixerreg_write(sc, CMPCI_SB16_MIXER_MIC,
		    CMPCI_ADJUST_MIC_GAIN(sc, sc->sc_gain[port][CMPCI_LR]));
		return;
	case CMPCI_MASTER_VOL:
		src = CMPCI_SB16_MIXER_MASTER_L;
		break;
	case CMPCI_LINE_IN_VOL:
		src = CMPCI_SB16_MIXER_LINE_L;
		break;
	case CMPCI_AUX_IN_VOL:
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, CMPCI_REG_MIXER_AUX,
		    CMPCI_ADJUST_AUX_GAIN(sc, sc->sc_gain[port][CMPCI_LEFT],
					      sc->sc_gain[port][CMPCI_RIGHT]));
		return;
	case CMPCI_MIC_RECVOL:
		cmpci_reg_partial_write_1(sc, CMPCI_REG_MIXER25,
		    CMPCI_REG_ADMIC_SHIFT, CMPCI_REG_ADMIC_MASK,
		    CMPCI_ADJUST_ADMIC_GAIN(sc, sc->sc_gain[port][CMPCI_LR]));
		return;
	case CMPCI_DAC_VOL:
		src = CMPCI_SB16_MIXER_VOICE_L;
		break;
	case CMPCI_FM_VOL:
		src = CMPCI_SB16_MIXER_FM_L;
		break;
	case CMPCI_CD_VOL:
		src = CMPCI_SB16_MIXER_CDDA_L;
		break;
	case CMPCI_PCSPEAKER:
		cmpci_mixerreg_write(sc, CMPCI_SB16_MIXER_SPEAKER,
		    CMPCI_ADJUST_2_GAIN(sc, sc->sc_gain[port][CMPCI_LR]));
		return;
	case CMPCI_MIC_PREAMP:
		if (sc->sc_gain[port][CMPCI_LR])
			cmpci_reg_clear_1(sc, CMPCI_REG_MIXER25,
			    CMPCI_REG_MICGAINZ);
		else
			cmpci_reg_set_1(sc, CMPCI_REG_MIXER25,
			    CMPCI_REG_MICGAINZ);
		return;

	case CMPCI_DAC_MUTE:
		if (sc->sc_gain[port][CMPCI_LR])
			cmpci_reg_set_1(sc, CMPCI_REG_MIXER24,
			    CMPCI_REG_WSMUTE);
		else
			cmpci_reg_clear_1(sc, CMPCI_REG_MIXER24,
			    CMPCI_REG_WSMUTE);
		return;
	case CMPCI_FM_MUTE:
		if (sc->sc_gain[port][CMPCI_LR])
			cmpci_reg_set_1(sc, CMPCI_REG_MIXER24,
			    CMPCI_REG_FMMUTE);
		else
			cmpci_reg_clear_1(sc, CMPCI_REG_MIXER24,
			    CMPCI_REG_FMMUTE);
		return;
	case CMPCI_AUX_IN_MUTE:
		if (sc->sc_gain[port][CMPCI_LR])
			cmpci_reg_clear_1(sc, CMPCI_REG_MIXER25,
			    CMPCI_REG_VAUXRM|CMPCI_REG_VAUXLM);
		else
			cmpci_reg_set_1(sc, CMPCI_REG_MIXER25,
			    CMPCI_REG_VAUXRM|CMPCI_REG_VAUXLM);
		return;
	case CMPCI_CD_MUTE:
		mask = CMPCI_SB16_SW_CD;
		goto sbmute;
	case CMPCI_MIC_MUTE:
		mask = CMPCI_SB16_SW_MIC;
		goto sbmute;
	case CMPCI_LINE_IN_MUTE:
		mask = CMPCI_SB16_SW_LINE;
	sbmute:
		bits = cmpci_mixerreg_read(sc, CMPCI_SB16_MIXER_OUTMIX);
		if (sc->sc_gain[port][CMPCI_LR])
			bits = bits & ~mask;
		else
			bits = bits | mask;
		cmpci_mixerreg_write(sc, CMPCI_SB16_MIXER_OUTMIX, bits);
		return;

	case CMPCI_SPDIF_IN_SELECT:
	case CMPCI_MONITOR_DAC:
	case CMPCI_PLAYBACK_MODE:
	case CMPCI_SPDIF_LOOP:
	case CMPCI_SPDIF_OUT_PLAYBACK:
		cmpci_set_out_ports(sc);
		return;
	case CMPCI_SPDIF_OUT_VOLTAGE:
		if (CMPCI_ISCAP(sc, SPDOUT_VOLTAGE)) {
			if (sc->sc_gain[CMPCI_SPDIF_OUT_VOLTAGE][CMPCI_LR]
			    == CMPCI_SPDIF_OUT_VOLTAGE_HIGH)
				cmpci_reg_clear_reg_misc(sc, CMPCI_REG_5V);
			else
				cmpci_reg_set_reg_misc(sc, CMPCI_REG_5V);
		}
		return;
	case CMPCI_SURROUND:
		if (CMPCI_ISCAP(sc, SURROUND)) {
			if (sc->sc_gain[CMPCI_SURROUND][CMPCI_LR])
				cmpci_reg_set_1(sc, CMPCI_REG_MIXER24,
						CMPCI_REG_SURROUND);
			else
				cmpci_reg_clear_1(sc, CMPCI_REG_MIXER24,
						  CMPCI_REG_SURROUND);
		}
		return;
	case CMPCI_REAR:
		if (CMPCI_ISCAP(sc, REAR)) {
			if (sc->sc_gain[CMPCI_REAR][CMPCI_LR])
				cmpci_reg_set_reg_misc(sc, CMPCI_REG_N4SPK3D);
			else
				cmpci_reg_clear_reg_misc(sc, CMPCI_REG_N4SPK3D);
		}
		return;
	case CMPCI_INDIVIDUAL:
		if (CMPCI_ISCAP(sc, INDIVIDUAL_REAR)) {
			if (sc->sc_gain[CMPCI_REAR][CMPCI_LR])
				cmpci_reg_set_1(sc, CMPCI_REG_MIXER24,
						CMPCI_REG_INDIVIDUAL);
			else
				cmpci_reg_clear_1(sc, CMPCI_REG_MIXER24,
						  CMPCI_REG_INDIVIDUAL);
		}
		return;
	case CMPCI_REVERSE:
		if (CMPCI_ISCAP(sc, REVERSE_FR)) {
			if (sc->sc_gain[CMPCI_REVERSE][CMPCI_LR])
				cmpci_reg_set_1(sc, CMPCI_REG_MIXER24,
						CMPCI_REG_REVERSE_FR);
			else
				cmpci_reg_clear_1(sc, CMPCI_REG_MIXER24,
						  CMPCI_REG_REVERSE_FR);
		}
		return;
	case CMPCI_SPDIF_IN_PHASE:
		if (CMPCI_ISCAP(sc, SPDIN_PHASE)) {
			if (sc->sc_gain[CMPCI_SPDIF_IN_PHASE][CMPCI_LR]
			    == CMPCI_SPDIF_IN_PHASE_POSITIVE)
				cmpci_reg_clear_1(sc, CMPCI_REG_CHANNEL_FORMAT,
						  CMPCI_REG_SPDIN_PHASE);
			else
				cmpci_reg_set_1(sc, CMPCI_REG_CHANNEL_FORMAT,
						CMPCI_REG_SPDIN_PHASE);
		}
		return;
	default:
		return;
	}

	cmpci_mixerreg_write(sc, src,
	    CMPCI_ADJUST_GAIN(sc, sc->sc_gain[port][CMPCI_LEFT]));
	cmpci_mixerreg_write(sc, CMPCI_SB16_MIXER_L_TO_R(src),
	    CMPCI_ADJUST_GAIN(sc, sc->sc_gain[port][CMPCI_RIGHT]));
}

void
cmpci_set_out_ports(struct cmpci_softc *sc)
{
	struct cmpci_channel *chan;
	u_int8_t v;
	int enspdout = 0;

	if (!CMPCI_ISCAP(sc, SPDLOOP))
		return;

	/* SPDIF/out select */
	if (sc->sc_gain[CMPCI_SPDIF_LOOP][CMPCI_LR] == CMPCI_SPDIF_LOOP_OFF) {
		/* playback */
		cmpci_reg_clear_4(sc, CMPCI_REG_FUNC_1, CMPCI_REG_SPDIF_LOOP);
	} else {
		/* monitor SPDIF/in */
		cmpci_reg_set_4(sc, CMPCI_REG_FUNC_1, CMPCI_REG_SPDIF_LOOP);
	}

	/* SPDIF in select */
	v = sc->sc_gain[CMPCI_SPDIF_IN_SELECT][CMPCI_LR];
	if (v & CMPCI_SPDIFIN_SPDIFIN2)
		cmpci_reg_set_reg_misc(sc, CMPCI_REG_2ND_SPDIFIN);
	else
		cmpci_reg_clear_reg_misc(sc, CMPCI_REG_2ND_SPDIFIN);
	if (v & CMPCI_SPDIFIN_SPDIFOUT)
		cmpci_reg_set_reg_misc(sc, CMPCI_REG_SPDFLOOPI);
	else
		cmpci_reg_clear_reg_misc(sc, CMPCI_REG_SPDFLOOPI);

	if (sc->sc_play_channel == 1)
		chan = &sc->sc_ch1;
	else
		chan = &sc->sc_ch0;

	/* disable ac3 and 24 and 32 bit s/pdif modes */
	cmpci_reg_clear_4(sc, CMPCI_REG_CHANNEL_FORMAT, CMPCI_REG_AC3EN1);
	cmpci_reg_clear_reg_misc(sc, CMPCI_REG_AC3EN2);
	cmpci_reg_clear_reg_misc(sc, CMPCI_REG_SPD32SEL);
	cmpci_reg_clear_4(sc, CMPCI_REG_CHANNEL_FORMAT, CMPCI_REG_SPDIF_24);

	/* playback to ... */
	if (CMPCI_ISCAP(sc, SPDOUT) &&
	    sc->sc_gain[CMPCI_PLAYBACK_MODE][CMPCI_LR]
		== CMPCI_PLAYBACK_MODE_SPDIF &&
	    (chan->md_divide == CMPCI_REG_RATE_44100 ||
		(CMPCI_ISCAP(sc, SPDOUT_48K) &&
		    chan->md_divide == CMPCI_REG_RATE_48000))) {
		/* playback to SPDIF */
		if (sc->sc_play_channel == 0)
			cmpci_reg_set_4(sc, CMPCI_REG_FUNC_1,
			    CMPCI_REG_SPDIF0_ENABLE);
		else
			cmpci_reg_set_4(sc, CMPCI_REG_FUNC_1,
			    CMPCI_REG_SPDIF1_ENABLE);
		enspdout = 1;
		if (chan->md_divide == CMPCI_REG_RATE_48000)
			cmpci_reg_set_reg_misc(sc,
				CMPCI_REG_SPDIFOUT_48K | CMPCI_REG_SPDIF48K);
		else
			cmpci_reg_clear_reg_misc(sc,
				CMPCI_REG_SPDIFOUT_48K | CMPCI_REG_SPDIF48K);
		/* XXX assume sample rate <= 48kHz */
		cmpci_reg_clear_4(sc, CMPCI_REG_CHANNEL_FORMAT,
		    CMPCI_REG_DBL_SPD_RATE);
	} else {
		/* playback to DAC */
		if (sc->sc_play_channel == 0)
			cmpci_reg_clear_4(sc, CMPCI_REG_FUNC_1,
			    CMPCI_REG_SPDIF0_ENABLE);
		else
			cmpci_reg_clear_4(sc, CMPCI_REG_FUNC_1,
			    CMPCI_REG_SPDIF1_ENABLE);
		if (CMPCI_ISCAP(sc, SPDOUT_48K))
			cmpci_reg_clear_reg_misc(sc,
				CMPCI_REG_SPDIFOUT_48K | CMPCI_REG_SPDIF48K);
	}

	/* legacy to SPDIF/out or not */
	if (CMPCI_ISCAP(sc, SPDLEGACY)) {
		if (sc->sc_gain[CMPCI_SPDIF_OUT_PLAYBACK][CMPCI_LR]
		    == CMPCI_SPDIF_OUT_PLAYBACK_WAVE)
			cmpci_reg_clear_4(sc, CMPCI_REG_LEGACY_CTRL,
					CMPCI_REG_LEGACY_SPDIF_ENABLE);
		else {
			cmpci_reg_set_4(sc, CMPCI_REG_LEGACY_CTRL,
					CMPCI_REG_LEGACY_SPDIF_ENABLE);
			enspdout = 1;
		}
	}

	/* enable/disable SPDIF/out */
	if (CMPCI_ISCAP(sc, XSPDOUT) && enspdout)
		cmpci_reg_set_4(sc, CMPCI_REG_LEGACY_CTRL,
				CMPCI_REG_XSPDIF_ENABLE);
	else
		cmpci_reg_clear_4(sc, CMPCI_REG_LEGACY_CTRL,
				CMPCI_REG_XSPDIF_ENABLE);

	/* SPDIF monitor (digital to analog output) */
	if (CMPCI_ISCAP(sc, SPDIN_MONITOR)) {
		v = sc->sc_gain[CMPCI_MONITOR_DAC][CMPCI_LR];
		if (!(v & CMPCI_MONDAC_ENABLE))
			cmpci_reg_clear_1(sc, CMPCI_REG_MIXER24,
					CMPCI_REG_SPDIN_MONITOR);
		if (v & CMPCI_MONDAC_SPDOUT)
			cmpci_reg_set_4(sc, CMPCI_REG_FUNC_1,
					CMPCI_REG_SPDIFOUT_DAC);
		else
			cmpci_reg_clear_4(sc, CMPCI_REG_FUNC_1,
					CMPCI_REG_SPDIFOUT_DAC);
		if (v & CMPCI_MONDAC_ENABLE)
			cmpci_reg_set_1(sc, CMPCI_REG_MIXER24,
					CMPCI_REG_SPDIN_MONITOR);
	}
}

int
cmpci_set_in_ports(struct cmpci_softc *sc)
{
	int mask;
	int bitsl, bitsr;

	mask = sc->sc_in_mask;

	/*
	 * Note CMPCI_RECORD_SOURCE_CD, CMPCI_RECORD_SOURCE_LINE_IN and
	 * CMPCI_RECORD_SOURCE_FM are defined to the corresponding bit
	 * of the mixer register.
	 */
	bitsr = mask & (CMPCI_RECORD_SOURCE_CD | CMPCI_RECORD_SOURCE_LINE_IN |
	    CMPCI_RECORD_SOURCE_FM);

	bitsl = CMPCI_SB16_MIXER_SRC_R_TO_L(bitsr);
	if (mask & CMPCI_RECORD_SOURCE_MIC) {
		bitsl |= CMPCI_SB16_MIXER_MIC_SRC;
		bitsr |= CMPCI_SB16_MIXER_MIC_SRC;
	}
	cmpci_mixerreg_write(sc, CMPCI_SB16_MIXER_ADCMIX_L, bitsl);
	cmpci_mixerreg_write(sc, CMPCI_SB16_MIXER_ADCMIX_R, bitsr);

	if (mask & CMPCI_RECORD_SOURCE_AUX_IN)
		cmpci_reg_set_1(sc, CMPCI_REG_MIXER25,
		    CMPCI_REG_RAUXREN | CMPCI_REG_RAUXLEN);
	else
		cmpci_reg_clear_1(sc, CMPCI_REG_MIXER25,
		    CMPCI_REG_RAUXREN | CMPCI_REG_RAUXLEN);

	if (mask & CMPCI_RECORD_SOURCE_WAVE)
		cmpci_reg_set_1(sc, CMPCI_REG_MIXER24,
		    CMPCI_REG_WAVEINL | CMPCI_REG_WAVEINR);
	else
		cmpci_reg_clear_1(sc, CMPCI_REG_MIXER24,
		    CMPCI_REG_WAVEINL | CMPCI_REG_WAVEINR);

	if (CMPCI_ISCAP(sc, SPDIN) &&
	    (sc->sc_ch1.md_divide == CMPCI_REG_RATE_44100 ||
		(CMPCI_ISCAP(sc, SPDOUT_48K) &&
		    sc->sc_ch1.md_divide == CMPCI_REG_RATE_48000/* XXX? */))) {
		if (mask & CMPCI_RECORD_SOURCE_SPDIF) {
			/* enable SPDIF/in */
			cmpci_reg_set_4(sc,
					CMPCI_REG_FUNC_1,
					CMPCI_REG_SPDIF1_ENABLE);
		} else {
			cmpci_reg_clear_4(sc,
					CMPCI_REG_FUNC_1,
					CMPCI_REG_SPDIF1_ENABLE);
		}
	}

	return 0;
}

int
cmpci_set_port(void *handle, mixer_ctrl_t *cp)
{
	struct cmpci_softc *sc = handle;
	int lgain, rgain;

	switch (cp->dev) {
	case CMPCI_MIC_VOL:
	case CMPCI_PCSPEAKER:
	case CMPCI_MIC_RECVOL:
		if (cp->un.value.num_channels != 1)
			return EINVAL;
		/* FALLTHROUGH */
	case CMPCI_DAC_VOL:
	case CMPCI_FM_VOL:
	case CMPCI_CD_VOL:
	case CMPCI_LINE_IN_VOL:
	case CMPCI_AUX_IN_VOL:
	case CMPCI_MASTER_VOL:
		if (cp->type != AUDIO_MIXER_VALUE)
			return EINVAL;
		switch (cp->un.value.num_channels) {
		case 1:
			lgain = rgain =
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
			break;
		case 2:
			lgain = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
			rgain = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
			break;
		default:
			return EINVAL;
		}
		sc->sc_gain[cp->dev][CMPCI_LEFT]  = lgain;
		sc->sc_gain[cp->dev][CMPCI_RIGHT] = rgain;

		cmpci_set_mixer_gain(sc, cp->dev);
		break;

	case CMPCI_RECORD_SOURCE:
		if (cp->type != AUDIO_MIXER_SET)
			return EINVAL;

		if (cp->un.mask & ~(CMPCI_RECORD_SOURCE_MIC |
		    CMPCI_RECORD_SOURCE_CD | CMPCI_RECORD_SOURCE_LINE_IN |
		    CMPCI_RECORD_SOURCE_AUX_IN | CMPCI_RECORD_SOURCE_WAVE |
		    CMPCI_RECORD_SOURCE_FM | CMPCI_RECORD_SOURCE_SPDIF))
			return EINVAL;

		if (cp->un.mask & CMPCI_RECORD_SOURCE_SPDIF)
			cp->un.mask = CMPCI_RECORD_SOURCE_SPDIF;

		sc->sc_in_mask = cp->un.mask;
		return cmpci_set_in_ports(sc);

	/* boolean */
	case CMPCI_DAC_MUTE:
	case CMPCI_FM_MUTE:
	case CMPCI_CD_MUTE:
	case CMPCI_LINE_IN_MUTE:
	case CMPCI_AUX_IN_MUTE:
	case CMPCI_MIC_MUTE:
	case CMPCI_MIC_PREAMP:
	case CMPCI_PLAYBACK_MODE:
	case CMPCI_SPDIF_IN_PHASE:
	case CMPCI_SPDIF_LOOP:
	case CMPCI_SPDIF_OUT_PLAYBACK:
	case CMPCI_SPDIF_OUT_VOLTAGE:
	case CMPCI_REAR:
	case CMPCI_INDIVIDUAL:
	case CMPCI_REVERSE:
	case CMPCI_SURROUND:
		if (cp->type != AUDIO_MIXER_ENUM)
			return EINVAL;
		sc->sc_gain[cp->dev][CMPCI_LR] = cp->un.ord != 0;
		cmpci_set_mixer_gain(sc, cp->dev);
		break;

	case CMPCI_SPDIF_IN_SELECT:
		switch (cp->un.ord) {
		case CMPCI_SPDIF_IN_SPDIN1:
		case CMPCI_SPDIF_IN_SPDIN2:
		case CMPCI_SPDIF_IN_SPDOUT:
			break;
		default:
			return EINVAL;
		}
		goto xenum;
	case CMPCI_MONITOR_DAC:
		switch (cp->un.ord) {
		case CMPCI_MONITOR_DAC_OFF:
		case CMPCI_MONITOR_DAC_SPDIN:
		case CMPCI_MONITOR_DAC_SPDOUT:
			break;
		default:
			return EINVAL;
		}
	xenum:
		if (cp->type != AUDIO_MIXER_ENUM)
			return EINVAL;
		sc->sc_gain[cp->dev][CMPCI_LR] = cp->un.ord;
		cmpci_set_mixer_gain(sc, cp->dev);
		break;

	default:
	    return EINVAL;
	}

	return 0;
}

int
cmpci_get_port(void *handle, mixer_ctrl_t *cp)
{
	struct cmpci_softc *sc = handle;

	switch (cp->dev) {
	case CMPCI_MIC_VOL:
	case CMPCI_PCSPEAKER:
	case CMPCI_MIC_RECVOL:
		if (cp->un.value.num_channels != 1)
			return EINVAL;
		/*FALLTHROUGH*/
	case CMPCI_DAC_VOL:
	case CMPCI_FM_VOL:
	case CMPCI_CD_VOL:
	case CMPCI_LINE_IN_VOL:
	case CMPCI_AUX_IN_VOL:
	case CMPCI_MASTER_VOL:
		switch (cp->un.value.num_channels) {
		case 1:
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
				sc->sc_gain[cp->dev][CMPCI_LEFT];
			break;
		case 2:
			cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
				sc->sc_gain[cp->dev][CMPCI_LEFT];
			cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
				sc->sc_gain[cp->dev][CMPCI_RIGHT];
			break;
		default:
			return EINVAL;
		}
		break;

	case CMPCI_RECORD_SOURCE:
		cp->un.mask = sc->sc_in_mask;
		break;

	case CMPCI_DAC_MUTE:
	case CMPCI_FM_MUTE:
	case CMPCI_CD_MUTE:
	case CMPCI_LINE_IN_MUTE:
	case CMPCI_AUX_IN_MUTE:
	case CMPCI_MIC_MUTE:
	case CMPCI_MIC_PREAMP:
	case CMPCI_PLAYBACK_MODE:
	case CMPCI_SPDIF_IN_SELECT:
	case CMPCI_SPDIF_IN_PHASE:
	case CMPCI_SPDIF_LOOP:
	case CMPCI_SPDIF_OUT_PLAYBACK:
	case CMPCI_SPDIF_OUT_VOLTAGE:
	case CMPCI_MONITOR_DAC:
	case CMPCI_REAR:
	case CMPCI_INDIVIDUAL:
	case CMPCI_REVERSE:
	case CMPCI_SURROUND:
		cp->un.ord = sc->sc_gain[cp->dev][CMPCI_LR];
		break;

	default:
		return EINVAL;
	}

	return 0;
}

/* ARGSUSED */
size_t
cmpci_round_buffersize(void *handle, int direction, size_t bufsize)
{
	if (bufsize > 0x10000)
		bufsize = 0x10000;

	return bufsize;
}

/* ARGSUSED */
int
cmpci_get_props(void *handle)
{
	return AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT | AUDIO_PROP_FULLDUPLEX;
}

int
cmpci_trigger_output(void *handle, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct cmpci_softc *sc = handle;
	struct cmpci_dmanode *p;
	struct cmpci_channel *chan;
	uint32_t reg_dma_base, reg_dma_bytes, reg_dma_samples, reg_dir,
	    reg_intr_enable, reg_enable;
	uint32_t length;
	size_t buffer_size = (caddr_t)end - (caddr_t)start;

	cmpci_set_out_ports(sc);

	if (sc->sc_play_channel == 1) {
		chan = &sc->sc_ch1;
		reg_dma_base = CMPCI_REG_DMA1_BASE;
		reg_dma_bytes = CMPCI_REG_DMA1_BYTES;
		reg_dma_samples = CMPCI_REG_DMA1_SAMPLES;
		reg_dir = CMPCI_REG_CH1_DIR;
		reg_intr_enable = CMPCI_REG_CH1_INTR_ENABLE;
		reg_enable = CMPCI_REG_CH1_ENABLE;
	} else {
		chan = &sc->sc_ch0;
		reg_dma_base = CMPCI_REG_DMA0_BASE;
		reg_dma_bytes = CMPCI_REG_DMA0_BYTES;
		reg_dma_samples = CMPCI_REG_DMA0_SAMPLES;
		reg_dir = CMPCI_REG_CH0_DIR;
		reg_intr_enable = CMPCI_REG_CH0_INTR_ENABLE;
		reg_enable = CMPCI_REG_CH0_ENABLE;
	}

	chan->bps = (param->channels > 1 ? 2 : 1) * param->bps;
	if (!chan->bps)
		return EINVAL;

	chan->intr = intr;
	chan->intr_arg = arg;
	chan->blksize = blksize;
	chan->nblocks = buffer_size / chan->blksize;
	chan->swpos = 0;

	/* set DMA frame */
	if (!(p = cmpci_find_dmamem(sc, start)))
		return EINVAL;
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, reg_dma_base,
	    DMAADDR(p));
	delay(10);
	length = (buffer_size + 1) / chan->bps - 1;
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, reg_dma_bytes, length);
	delay(10);

	/* set interrupt count */
	length = (chan->blksize + chan->bps - 1) / chan->bps - 1;
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, reg_dma_samples, length);
	delay(10);

	/* start DMA */
	mtx_enter(&audio_lock);
	cmpci_reg_clear_4(sc, CMPCI_REG_FUNC_0, reg_dir); /* PLAY */
	cmpci_reg_set_4(sc, CMPCI_REG_INTR_CTRL, reg_intr_enable);
	cmpci_reg_set_4(sc, CMPCI_REG_FUNC_0, reg_enable);
	mtx_leave(&audio_lock);
	return 0;
}

int
cmpci_trigger_input(void *handle, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct cmpci_softc *sc = handle;
	struct cmpci_dmanode *p;
	struct cmpci_channel *chan = &sc->sc_ch1;
	size_t buffer_size = (caddr_t)end - (caddr_t)start;

	cmpci_set_in_ports(sc);

	chan->bps = param->channels * param->bps;
	if (!chan->bps)
		return EINVAL;

	chan->intr = intr;
	chan->intr_arg = arg;
	chan->blksize = blksize;
	chan->nblocks = buffer_size / chan->blksize;
	chan->swpos = 0;

	/* set DMA frame */
	if (!(p = cmpci_find_dmamem(sc, start)))
		return EINVAL;
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, CMPCI_REG_DMA1_BASE,
	    DMAADDR(p));
	delay(10);
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, CMPCI_REG_DMA1_BYTES,
	    (buffer_size + 1) / chan->bps - 1);
	delay(10);

	/* set interrupt count */
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, CMPCI_REG_DMA1_SAMPLES,
	    (chan->blksize + chan->bps - 1) / chan->bps - 1);
	delay(10);

	/* start DMA */
	mtx_enter(&audio_lock);
	cmpci_reg_set_4(sc, CMPCI_REG_FUNC_0, CMPCI_REG_CH1_DIR); /* REC */
	cmpci_reg_set_4(sc, CMPCI_REG_INTR_CTRL, CMPCI_REG_CH1_INTR_ENABLE);
	cmpci_reg_set_4(sc, CMPCI_REG_FUNC_0, CMPCI_REG_CH1_ENABLE);
	mtx_leave(&audio_lock);
	return 0;
}

/* end of file */
@


1.41
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.39 2015/05/11 06:46:21 ratchov Exp $	*/
a137 1
int cmpci_getdev(void *, struct audio_device *);
a164 1
	cmpci_getdev,		/* getdev */
a871 29
	return 0;
}

/* get audio device information */
int
cmpci_getdev(void *handle, struct audio_device *ad)
{
	struct cmpci_softc *sc = handle;

	strncpy(ad->name, "CMI PCI Audio", sizeof(ad->name));
	snprintf(ad->version, sizeof(ad->version), "0x%02x (%d)",
		 PCI_REVISION(sc->sc_class), sc->sc_version);
	switch (PCI_PRODUCT(sc->sc_id)) {
	case PCI_PRODUCT_CMI_CMI8338A:
		strncpy(ad->config, "CMI8338A", sizeof(ad->config));
		break;
	case PCI_PRODUCT_CMI_CMI8338B:
		strncpy(ad->config, "CMI8338B", sizeof(ad->config));
		break;
	case PCI_PRODUCT_CMI_CMI8738:
		strncpy(ad->config, "CMI8738", sizeof(ad->config));
		break;
	case PCI_PRODUCT_CMI_CMI8738B:
		strncpy(ad->config, "CMI8738B", sizeof(ad->config));
		break;
	default:
		strncpy(ad->config, "unknown", sizeof(ad->config));
	}

@


1.40
log
@For unsupported sample formats, don't return EINVAL but set the closest
available format.  ok ratchov@@
@
text
@a131 1
int cmpci_query_encoding(void *, struct audio_encoding *);
a134 1
void cmpci_get_default_params(void *, int, struct audio_params*);
a144 1
paddr_t cmpci_mappage(void *, void *, off_t, int);
a155 2
	NULL,			/* drain */
	cmpci_query_encoding,	/* query_encoding */
a173 1
	cmpci_mappage,		/* mappage */
d176 1
a176 2
	cmpci_trigger_input,	/* trigger_input */
	cmpci_get_default_params
a637 36
cmpci_query_encoding(void *handle, struct audio_encoding *fp)
{
	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 1:
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	default:
		return EINVAL;
	}
	fp->bps = AUDIO_BPS(fp->precision);
	fp->msb = 1;

	return 0;
}

void
cmpci_get_default_params(void *addr, int mode, struct audio_params *params)
{
	params->sample_rate = 48000;
	params->encoding = AUDIO_ENCODING_SLINEAR_LE;
	params->precision = 16;
	params->bps = 2;
	params->msb = 1;
	params->channels = 2;
}

int
a1804 13
}

paddr_t
cmpci_mappage(void *handle, void *addr, off_t offset, int prot)
{
	struct cmpci_softc *sc = handle;
	struct cmpci_dmanode *p;

	if (offset < 0 || NULL == (p = cmpci_find_dmamem(sc, addr)))
		return -1;

	return bus_dmamem_mmap(p->cd_tag, p->cd_segs,
		   nitems(p->cd_segs), offset, prot, BUS_DMA_WAITOK);
@


1.39
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.38 2015/03/14 03:38:48 jsg Exp $	*/
a738 2
		if (p->precision > 16)
			p->precision = 16;
d810 3
a812 4
		switch (p->encoding) {
		case AUDIO_ENCODING_SLINEAR_LE:
			if (p->precision != 16)
				return (EINVAL);
d814 3
a816 5
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
		case AUDIO_ENCODING_ULINEAR_BE:
			if (p->precision != 8)
				return (EINVAL);
a817 3
			break;
		default:
			return (EINVAL);
@


1.38
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.37 2014/07/12 18:48:51 tedu Exp $	*/
a64 2
#include <dev/mulaw.h>
#include <dev/auconv.h>
a654 18
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 2:
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 3:
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 4:
a659 18
	case 5:
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 6:
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
a677 2
	params->sw_code = NULL;
	params->factor = 1;
a740 1
		p->sw_code = NULL;
a812 20
		case AUDIO_ENCODING_ULAW:
			if (mode & AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = mulaw_to_slinear16_le;
				md_format |= CMPCI_REG_FORMAT_16BIT;
			} else {
				p->sw_code = ulinear8_to_mulaw;
				md_format |= CMPCI_REG_FORMAT_8BIT;
			}
			break;
		case AUDIO_ENCODING_ALAW:
			if (mode & AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = alaw_to_slinear16_le;
				md_format |= CMPCI_REG_FORMAT_16BIT;
			} else {
				p->sw_code = ulinear8_to_alaw;
				md_format |= CMPCI_REG_FORMAT_8BIT;
			}
			break;
d814 1
a814 23
			switch (p->precision) {
			case 8:
				p->sw_code = change_sign8;
				md_format |= CMPCI_REG_FORMAT_8BIT;
				break;
			case 16:
				md_format |= CMPCI_REG_FORMAT_16BIT;
				break;
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_SLINEAR_BE:
			switch (p->precision) {
			case 8:
				md_format |= CMPCI_REG_FORMAT_8BIT;
				p->sw_code = change_sign8;
				break;
			case 16:
				md_format |= CMPCI_REG_FORMAT_16BIT;
				p->sw_code = swap_bytes;
				break;
			default:
d816 1
a816 1
			}
a818 12
			switch (p->precision) {
			case 8:
				md_format |= CMPCI_REG_FORMAT_8BIT;
				break;
			case 16:
				md_format |= CMPCI_REG_FORMAT_16BIT;
				p->sw_code = change_sign16_le;
				break;
			default:
				return (EINVAL);
			}
			break;
d820 1
a820 14
			switch (p->precision) {
			case 8:
				md_format |= CMPCI_REG_FORMAT_8BIT;
				break;
			case 16:
				md_format |= CMPCI_REG_FORMAT_16BIT;
				if (mode & AUMODE_PLAY)
					p->sw_code =
					    swap_bytes_change_sign16_le;
				else
					p->sw_code =
					    change_sign16_swap_bytes_le;
				break;
			default:
d822 1
a822 1
			}
d1910 1
a1910 1
	chan->bps = (param->channels > 1 ? 2 : 1) * param->bps * param->factor;
d1955 1
a1955 1
	chan->bps = param->channels * param->bps * param->factor;
@


1.37
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.36 2013/12/06 21:03:03 deraadt Exp $	*/
a69 1
#include <dev/ic/mpuvar.h>
@


1.36
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.35 2013/05/24 07:58:46 ratchov Exp $	*/
d1365 1
a1365 1
	free(n, type);
d1383 1
a1383 1
			free(n, type);
@


1.35
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.34 2013/05/15 08:29:24 ratchov Exp $	*/
a528 5
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
	case DVACT_SUSPEND:
		break;
d533 2
a534 1
	case DVACT_DEACTIVATE:
@


1.34
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.33 2011/07/03 15:47:17 matthew Exp $	*/
d394 2
a395 2
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_AUDIO, cmpci_intr, sc,
	    sc->sc_dev.dv_xname);
@


1.33
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.32 2011/06/29 19:51:12 naddy Exp $	*/
d564 1
d568 2
a569 1
	if (!(intrstat & CMPCI_REG_ANY_INTR))
d571 1
d635 1
a1000 1
	int s;
d1002 1
a1002 1
	s = splaudio();
d1020 1
a1020 2
	splx(s);

a1027 1
	int s;
d1029 1
a1029 1
	s = splaudio();
d1037 1
a1037 2
	splx(s);

d2049 1
d2053 1
a2053 1

d2094 1
d2098 1
a2098 1

@


1.32
log
@mark S8 encoding as emulated; only S16LE and U8 are natively supported
ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.31 2011/04/03 15:36:02 jasper Exp $	*/
a528 2
	case DVACT_ACTIVATE:
		break;
@


1.31
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.30 2010/10/09 09:11:13 jakemsr Exp $	*/
d675 1
a675 1
		fp->flags = 0;
@


1.30
log
@only print out of sync messages when compiled for debugging
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.29 2010/10/08 14:01:07 jakemsr Exp $	*/
d353 1
a353 1
	    sizeof(cmpci_devices)/sizeof(cmpci_devices[0])));
d1342 1
a1342 1
	    sizeof(n->cd_segs)/sizeof(n->cd_segs[0]), &n->cd_nsegs, w);
d1369 1
a1369 1
			n->cd_segs, sizeof(n->cd_segs)/sizeof(n->cd_segs[0]));
d1388 1
a1388 1
			    sizeof(n->cd_segs)/sizeof(n->cd_segs[0]));
d1983 1
a1983 2
		   sizeof(p->cd_segs)/sizeof(p->cd_segs[0]),
		   offset, prot, BUS_DMA_WAITOK);
@


1.29
log
@check current hardware position in interrupt handler.  it's possible
more than one block was used since the last time the interrupt handler
was run.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.28 2010/09/12 03:17:34 jakemsr Exp $	*/
d595 2
a596 2
					printf("%s: DMA0 hwpos=%d swpos=%d\n",
					    __func__, hwpos, chan->swpos);
d614 2
a615 2
					printf("%s: DMA1 hwpos=%d swpos=%d\n",
					    __func__, hwpos, chan->swpos);
@


1.28
log
@silly me.  use the switch() variable, not the case value.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.27 2010/09/12 02:06:54 jakemsr Exp $	*/
d562 1
d564 1
d583 17
a599 2
		if (sc->sc_ch0.intr != NULL)
			(*sc->sc_ch0.intr)(sc->sc_ch0.intr_arg);
d602 17
a618 2
		if (sc->sc_ch1.intr != NULL)
			(*sc->sc_ch1.intr)(sc->sc_ch1.intr_arg);
d2004 1
a2004 1
	int bps;
d2026 4
d2032 3
a2034 4
	bps = (param->channels > 1 ? 2 : 1) * param->precision *
	    param->factor / 8;
	if (!bps)
		return EINVAL;
d2042 1
a2042 1
	length = ((caddr_t)end - (caddr_t)start + 1) / bps - 1;
d2047 1
a2047 1
	length = (blksize + bps - 1) / bps - 1;
d2065 2
a2066 1
	int bps;
d2070 2
a2071 4
	sc->sc_ch1.intr = intr;
	sc->sc_ch1.intr_arg = arg;
	bps = param->channels*param->precision*param->factor/8;
	if (!bps)
d2074 6
d2087 1
a2087 1
	    ((caddr_t)end - (caddr_t)start + 1) / bps - 1);
d2092 1
a2092 1
	    (blksize + bps - 1) / bps - 1);
@


1.27
log
@autoconf activate suspend/resume for cmpci(4).  uses audio(4)
DVACT_{QUIESCE,RESUME}.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.26 2010/07/15 03:43:11 jakemsr Exp $	*/
d532 1
a532 1
		rv = config_activate_children(self, DVACT_QUIESCE);
d538 1
a538 1
		rv = config_activate_children(self, DVACT_RESUME);
@


1.26
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.25 2010/04/08 00:23:53 tedu Exp $	*/
d98 2
d105 1
d112 2
a113 1
	sizeof (struct cmpci_softc), cmpci_match, cmpci_attach
d520 36
@


1.25
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.24 2009/05/06 23:13:29 jakemsr Exp $	*/
d632 3
d644 2
d866 2
@


1.24
log
@configure the input and output ports in trigger_{input,output} instead
of set_params so they only get configured when necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.23 2009/05/06 22:25:57 jakemsr Exp $	*/
a56 1
#include <sys/proc.h>
@


1.23
log
@- explicitely disable some s/pdif features (ac3 passthrough, 24 and 32-bit
  modes, "double speed")
- connect s/pdif output to the correct controller channels

fixes s/pdif output, which I partly broke when adding multichannel
support.  problem reported and patches tested by Antti Harri, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.22 2009/03/29 21:53:52 sthen Exp $	*/
a903 2
		cmpci_set_out_ports(sc);
		cmpci_set_in_ports(sc);
d905 1
d1928 2
d1985 2
@


1.22
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.21 2008/10/25 22:30:43 jakemsr Exp $	*/
d1570 6
d1582 1
a1582 1
		    chan->md_divide==CMPCI_REG_RATE_48000))) {
d1584 6
a1589 1
		cmpci_reg_set_4(sc, CMPCI_REG_FUNC_1, CMPCI_REG_SPDIF0_ENABLE);
d1591 1
a1591 1
		if (chan->md_divide==CMPCI_REG_RATE_48000)
d1597 3
d1602 6
a1607 2
		cmpci_reg_clear_4(sc, CMPCI_REG_FUNC_1,
				  CMPCI_REG_SPDIF0_ENABLE);
@


1.21
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.20 2008/05/29 07:20:15 jakemsr Exp $	*/
d381 1
a381 1
		printf(": failed to map I/O space\n");
d387 1
a387 1
		printf(": failed to map interrupt\n");
d394 1
a394 1
		printf(": failed to establish interrupt");
@


1.20
log
@
specify alternate default audio parameters to make the default expansion
factor 1

also obsoletes a XXX workaround in azalia

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.19 2008/05/13 02:24:08 brad Exp $	*/
d679 1
a679 1
				return (EINVAL);
d706 2
d728 1
a728 1
						return (EINVAL);
d749 1
a749 1
					return (EINVAL);
d773 1
a773 1
					return (EINVAL);
a781 2
			if (p->precision != 8)
				return (EINVAL);
a791 2
			if (p->precision != 8)
				return (EINVAL);
@


1.19
log
@Remove commented out NetBSD __KERNEL_RCSID macro usage.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.18 2008/04/21 00:32:43 jakemsr Exp $	*/
d136 1
d183 1
a183 1
	NULL
d634 11
@


1.18
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.17 2008/01/09 02:17:52 jakemsr Exp $	*/
a43 5

#if 0
#include <sys/cdefs.h>
__KERNEL_RCSID(0, "$NetBSD: cmpci.c,v 1.25 2004/10/26 06:32:20 xtraeme Exp $");
#endif
@


1.17
log
@- add support for 4, 6, and 8 channel playback
- print chip version in `audioctl version'
- advertise some features of supported hardware in the man page
- CMI8768 now working properly

yes! ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.16 2007/09/13 16:51:19 brad Exp $	*/
d187 1
@


1.16
log
@spacing nit.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.15 2007/09/03 08:52:03 jakemsr Exp $	*/
d38 1
a38 1
 * C-Media CMI8x38 Audio Chip Support.
a40 1
 *   - 4ch / 6ch support.
d364 1
a364 1
	int i, v;
d427 28
d518 2
d545 2
a546 2
		if (sc->sc_play.intr != NULL)
			(*sc->sc_play.intr)(sc->sc_play.intr_arg);
d549 2
a550 2
		if (sc->sc_rec.intr != NULL)
			(*sc->sc_rec.intr)(sc->sc_rec.intr_arg);
d669 28
d706 61
d856 13
a868 6
		if (mode & AUMODE_PLAY)
			cmpci_reg_partial_write_4(sc,
			   CMPCI_REG_CHANNEL_FORMAT,
			   CMPCI_REG_CH0_FORMAT_SHIFT,
			   CMPCI_REG_CH0_FORMAT_MASK, md_format);
		else
d873 1
d881 11
a891 4
			cmpci_reg_partial_write_4(sc,
			    CMPCI_REG_FUNC_1, CMPCI_REG_DAC_FS_SHIFT,
			    CMPCI_REG_DAC_FS_MASK, md_divide);
			sc->sc_play.md_divide = md_divide;
d896 1
a896 1
			sc->sc_rec.md_divide = md_divide;
d915 1
d919 13
a931 3
	sc->sc_play.intr = NULL;
	cmpci_reg_clear_4(sc, CMPCI_REG_INTR_CTRL, CMPCI_REG_CH0_INTR_ENABLE);
	cmpci_reg_clear_4(sc, CMPCI_REG_FUNC_0, CMPCI_REG_CH0_ENABLE);
d933 1
a933 1
	cmpci_reg_set_4(sc, CMPCI_REG_FUNC_0, CMPCI_REG_CH0_RESET);
d935 1
a935 1
	cmpci_reg_clear_4(sc, CMPCI_REG_FUNC_0, CMPCI_REG_CH0_RESET);
d948 1
a948 1
	sc->sc_rec.intr = NULL;
d967 2
a968 2
	snprintf(ad->version, sizeof(ad->version), "0x%02x",
		 PCI_REVISION(sc->sc_class));
d1532 1
d1559 5
d1568 1
a1568 1
	    (sc->sc_play.md_divide == CMPCI_REG_RATE_44100 ||
d1570 1
a1570 1
		    sc->sc_play.md_divide==CMPCI_REG_RATE_48000))) {
d1574 1
a1574 1
		if (sc->sc_play.md_divide==CMPCI_REG_RATE_48000)
d1667 1
a1667 1
	    (sc->sc_rec.md_divide == CMPCI_REG_RATE_44100 ||
d1669 1
a1669 1
		    sc->sc_rec.md_divide == CMPCI_REG_RATE_48000/* XXX? */))) {
d1899 4
d1905 22
a1926 3
	sc->sc_play.intr = intr;
	sc->sc_play.intr_arg = arg;
	bps = param->channels * param->precision * param->factor / 8;
d1933 1
a1933 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, CMPCI_REG_DMA0_BASE,
d1936 2
a1937 2
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, CMPCI_REG_DMA0_BYTES,
	    ((caddr_t)end - (caddr_t)start + 1) / bps - 1);
d1941 2
a1942 2
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, CMPCI_REG_DMA0_SAMPLES,
			  (blksize + bps - 1) / bps - 1);
d1946 3
a1948 3
	cmpci_reg_clear_4(sc, CMPCI_REG_FUNC_0, CMPCI_REG_CH0_DIR); /* PLAY */
	cmpci_reg_set_4(sc, CMPCI_REG_INTR_CTRL, CMPCI_REG_CH0_INTR_ENABLE);
	cmpci_reg_set_4(sc, CMPCI_REG_FUNC_0, CMPCI_REG_CH0_ENABLE);
d1961 2
a1962 2
	sc->sc_rec.intr = intr;
	sc->sc_rec.intr_arg = arg;
@


1.15
log
@__inline removal

tested on my amd64

from bret.lambert@@gmail.com via art@@, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.14 2006/07/27 00:45:59 brad Exp $	*/
d395 1
a395 1
	sc->sc_ih=pci_intr_establish(pa->pa_pc, ih, IPL_AUDIO, cmpci_intr, sc,
@


1.14
log
@Newer cmcpci(4) sound driver, which adds S/PDIF, OPL and MPU support, some
fixes for 48KHz sound and adds the C-Media CMI8738B PCI id.

By ITOH Yasufumi
From NetBSD

Thanks to kurt@@ for providing me with a CMI8738 board.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.13 2005/04/14 12:42:16 mickey Exp $	*/
d84 3
a86 6
__inline uint8_t cmpci_mixerreg_read(struct cmpci_softc *,
						 uint8_t);
__inline void cmpci_mixerreg_write(struct cmpci_softc *,
					       uint8_t, uint8_t);
__inline void cmpci_reg_partial_write_1(struct cmpci_softc *,
						    int, int,
d88 1
a88 2
__inline void cmpci_reg_partial_write_4(struct cmpci_softc *,
						    int, int,
d90 6
a95 12
__inline void cmpci_reg_set_1(struct cmpci_softc *,
					  int, uint8_t);
__inline void cmpci_reg_clear_1(struct cmpci_softc *,
					    int, uint8_t);
__inline void cmpci_reg_set_4(struct cmpci_softc *,
					  int, uint32_t);
__inline void cmpci_reg_clear_4(struct cmpci_softc *,
					    int, uint32_t);
__inline void cmpci_reg_set_reg_misc(struct cmpci_softc *,
						 uint32_t);
__inline void cmpci_reg_clear_reg_misc(struct cmpci_softc *,
						   uint32_t);
d97 2
a98 2
__inline int cmpci_index_to_rate(int);
__inline int cmpci_index_to_divider(int);
d195 1
a195 1
__inline uint8_t
d207 1
a207 1
__inline void
d217 1
a217 1
__inline void
d227 1
a227 1
__inline void
d238 1
a238 1
__inline void
d246 1
a246 1
__inline void
d254 1
a254 1
__inline void
d265 1
a265 1
__inline void
d280 1
a280 1
__inline void
d289 1
a289 1
__inline void
d327 1
a327 1
__inline int
d333 1
a333 1
__inline int
@


1.13
log
@make sure round_blocksize does not produce 0 after alignment
@
text
@d1 2
a2 1
/*	$OpenBSD: cmpci.c,v 1.12 2003/09/09 03:42:19 kevlo Exp $	*/
d5 1
a5 1
 * Copyright (c) 2000 Takuya SHIOZAKI
d8 6
d41 2
a42 2
 *   - Legacy MPU, OPL and Joystick support (but, I have no interest...)
 *   - SPDIF support
d46 4
a49 1
#undef CMPCI_SPDIF_SUPPORT  /* XXX: not working */
d52 2
a53 1
#define DPRINTF(x) printf x
d70 2
a73 1

d77 1
d84 30
a113 19
static __inline uint8_t cmpci_mixerreg_read(struct cmpci_softc *,
                                                 uint8_t);
static __inline void cmpci_mixerreg_write(struct cmpci_softc *,
                                               uint8_t, uint8_t);
static __inline void cmpci_reg_partial_write_4(struct cmpci_softc *,
                                                    int, int,
                                                    uint32_t, uint32_t);
static __inline void cmpci_reg_set_4(struct cmpci_softc *,
                                          int, uint32_t);
static __inline void cmpci_reg_clear_4(struct cmpci_softc *,
                                            int, uint32_t);
static int cmpci_rate_to_index(int);
static __inline int cmpci_index_to_rate(int);
static __inline int cmpci_index_to_divider(int);

static int cmpci_adjust(int, int);
static void cmpci_set_mixer_gain(struct cmpci_softc *, int);
static int cmpci_set_in_ports(struct cmpci_softc *, int);

a128 6
struct audio_device cmpci_device = {
	"CMI PCI Audio",
	"",
	"cmpci"
};

a131 1

d136 4
a139 2
                            size_t, int, int, caddr_t *);
int cmpci_free_dmamem(struct cmpci_softc *, caddr_t, int);
d141 1
a141 1
                                                     caddr_t);
d150 2
a151 2
                          struct audio_params *,
                          struct audio_params *);
d165 2
a166 2
                         void (*)(void *), void *,
                         struct audio_params *);
d168 2
a169 2
                        void (*)(void *), void *,
                        struct audio_params *);
d172 26
a197 26
	cmpci_open,			/* open */
	cmpci_close,			/* close */
	NULL,				/* drain */
	cmpci_query_encoding,		/* query_encoding */
	cmpci_set_params,		/* set_params */
	cmpci_round_blocksize,		/* round_blocksize */
	NULL,				/* commit_settings */
	NULL,				/* init_output */
	NULL,				/* init_input */
	NULL,				/* start_output */
	NULL,				/* start_input */
	cmpci_halt_output,		/* halt_output */
	cmpci_halt_input,		/* halt_input */
	NULL,				/* speaker_ctl */
	cmpci_getdev,			/* getdev */
	NULL,				/* setfd */
	cmpci_set_port,			/* set_port */
	cmpci_get_port,			/* get_port */
	cmpci_query_devinfo,		/* query_devinfo */
	cmpci_malloc,			/* malloc */
	cmpci_free,			/* free */
	cmpci_round_buffersize,		/* round_buffersize */
	cmpci_mappage,			/* mappage */
	cmpci_get_props,		/* get_props */
	cmpci_trigger_output,		/* trigger_output */
	cmpci_trigger_input		/* trigger_input */
a199 1

d205 2
a206 4
static __inline uint8_t
cmpci_mixerreg_read(sc, no)
	struct cmpci_softc *sc;
	uint8_t no;
d209 1
d217 2
a218 4
static __inline void
cmpci_mixerreg_write(sc, no, val)
	struct cmpci_softc *sc;
	uint8_t no, val;
d227 13
a239 5
static __inline void
cmpci_reg_partial_write_4(sc, no, shift, mask, val)
	struct cmpci_softc *sc;
	int no, shift;
	uint32_t mask, val;
d248 18
a265 5
static __inline void
cmpci_reg_set_4(sc, no, mask)
	struct cmpci_softc *sc;
	int no;
	uint32_t mask;
d267 3
d275 2
a276 5
static __inline void
cmpci_reg_clear_4(sc, no, mask)
	struct cmpci_softc *sc;
	int no;
	uint32_t mask;
d278 3
d286 21
d309 3
a311 3
struct {
      int rate;
      int divider;
d322 1
a322 1
#undef  _RATE
d326 1
a326 2
cmpci_rate_to_index(rate)
	int rate;
d329 2
a330 1
	for (i=0; i<CMPCI_REG_NUMRATE-2; i++)
d337 2
a338 3
static __inline int
cmpci_index_to_rate(index)
	int index;
a339 1

d343 2
a344 3
static __inline int
cmpci_index_to_divider(index)
	int index;
d353 1
d359 1
d361 1
a361 4
cmpci_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d368 1
a368 3
cmpci_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d372 1
d377 15
d395 1
a395 1
		printf("\n%s: failed to map I/O space\n", sc->sc_dev.dv_xname);
d401 1
a401 1
		printf("\n%s: failed to map interrupt\n", sc->sc_dev.dv_xname);
d405 2
a406 3
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_AUDIO, cmpci_intr,
				       sc, sc->sc_dev.dv_xname);

d408 2
a409 3
		printf("\n%s: couldn't establish interrupt",
		    sc->sc_dev.dv_xname);
		if (intrstr)
d420 18
d442 1
a442 2
			     CMPCI_SB16_SW_CD|CMPCI_SB16_SW_MIC|
			     CMPCI_SB16_SW_LINE);
d445 14
a458 3
		case CMPCI_MIC_VOL:
		case CMPCI_LINE_IN_VOL:
			v = 0;
d460 2
a461 3
		case CMPCI_BASS:
		case CMPCI_TREBLE:
			v = CMPCI_ADJUST_GAIN(sc, AUDIO_MAX_GAIN / 2);
d463 4
a466 2
		case CMPCI_CD_IN_MUTE:
		case CMPCI_MIC_IN_MUTE:
d468 1
a468 10
		case CMPCI_FM_IN_MUTE:
		case CMPCI_CD_SWAP:
		case CMPCI_MIC_SWAP:
		case CMPCI_LINE_SWAP:
		case CMPCI_FM_SWAP:
			v = 0;
			break;
		case CMPCI_CD_OUT_MUTE:
		case CMPCI_MIC_OUT_MUTE:
		case CMPCI_LINE_OUT_MUTE:
d471 23
d495 2
a496 1
			v = CMPCI_ADJUST_GAIN(sc, AUDIO_MAX_GAIN / 2);
d498 1
a498 1
		sc->gain[i][CMPCI_LEFT] = sc->gain[i][CMPCI_RIGHT] = v;
d504 1
a504 2
cmpci_intr(handle)
	void *handle;
a507 1
	int s;
a510 1
	delay(10);
d515 2
a517 1
	s = splaudio();
d520 2
a521 2
		    CMPCI_REG_CH0_INTR_ENABLE);
	if (intrstat&CMPCI_REG_CH1_INTR)
a523 1
	splx(s);
d526 1
a526 1
		if (sc->sc_play.intr)
d530 2
a531 2
	    if (sc->sc_rec.intr)
		    (*sc->sc_rec.intr)(sc->sc_rec.intr_arg);
d535 1
a535 2
	s = splaudio();
	if ( intrstat & CMPCI_REG_CH0_INTR )
d541 5
a545 1
	splx(s);
d552 1
a552 3
cmpci_open(handle, flags)
	void *handle;
	int flags;
a553 4
	struct cmpci_softc *sc = handle;
	(void)sc;
	(void)flags;
	
d558 1
a558 2
cmpci_close(handle)
	void *handle;
a559 1
	(void)handle;
d563 1
a563 3
cmpci_query_encoding(handle, fp)
	void *handle;
	struct audio_encoding *fp;
a564 3
	struct cmpci_softc *sc = handle;
	(void)sc;
	
a619 1

d621 2
a622 4
cmpci_set_params(handle, setmode, usemode, play, rec)
	void *handle;
	int setmode, usemode;
	struct audio_params *play, *rec;
d627 1
a627 1
	for (i=0; i<2; i++) {
d643 2
d668 1
a668 1
				p->sw_code = mulaw_to_slinear16;
d670 1
a670 1
			} else
d672 2
a673 1
			md_format |= CMPCI_REG_FORMAT_8BIT;
d680 1
a680 1
				p->sw_code = alaw_to_slinear16;
d682 1
a682 1
			} else
d684 2
a685 1
			md_format |= CMPCI_REG_FORMAT_8BIT;
d715 1
a715 1
			switch ( p->precision ) {
d721 1
a721 1
				p->sw_code = change_sign16;
d734 3
a736 2
				if ( mode&AUMODE_PLAY )
					p->sw_code = swap_bytes_change_sign16;
d738 2
a739 1
					p->sw_code = change_sign16_swap_bytes;
d750 3
a752 4
						  CMPCI_REG_CHANNEL_FORMAT,
						  CMPCI_REG_CH0_FORMAT_SHIFT,
						  CMPCI_REG_CH0_FORMAT_MASK,
						  md_format);
d755 3
a757 4
						  CMPCI_REG_CHANNEL_FORMAT,
						  CMPCI_REG_CH1_FORMAT_SHIFT,
						  CMPCI_REG_CH1_FORMAT_MASK,
						  md_format);
a761 1
#if 0
a763 1
#endif
d766 3
a768 29
						  CMPCI_REG_FUNC_1,
						  CMPCI_REG_DAC_FS_SHIFT,
						  CMPCI_REG_DAC_FS_MASK,
						  md_divide);
#ifdef CMPCI_SPDIF_SUPPORT
			switch (md_divide) {
			case CMPCI_REG_RATE_44100:
				cmpci_reg_clear_4(sc, CMPCI_REG_MISC,
						  CMPCI_REG_SPDIF_48K);
				cmpci_reg_clear_4(sc, CMPCI_REG_FUNC_1,
						  CMPCI_REG_SPDIF_LOOP);
				cmpci_reg_set_4(sc, CMPCI_REG_FUNC_1,
						CMPCI_REG_SPDIF0_ENABLE);
				break;
			case CMPCI_REG_RATE_48000:
				cmpci_reg_set_4(sc, CMPCI_REG_MISC,
						CMPCI_REG_SPDIF_48K);
				cmpci_reg_clear_4(sc, CMPCI_REG_FUNC_1,
						  CMPCI_REG_SPDIF_LOOP);
				cmpci_reg_set_4(sc, CMPCI_REG_FUNC_1,
						CMPCI_REG_SPDIF0_ENABLE);
				break;
			default:
				cmpci_reg_clear_4(sc, CMPCI_REG_FUNC_1,
						  CMPCI_REG_SPDIF0_ENABLE);
			    cmpci_reg_set_4(sc, CMPCI_REG_FUNC_1,
					    CMPCI_REG_SPDIF_LOOP);
			}
#endif
d771 3
a773 18
						  CMPCI_REG_FUNC_1,
						  CMPCI_REG_ADC_FS_SHIFT,
						  CMPCI_REG_ADC_FS_MASK,
						  md_divide);
#ifdef CMPCI_SPDIF_SUPPORT
			if ( sc->in_mask&CMPCI_SPDIF_IN) {
				switch (md_divide) {
				case CMPCI_REG_RATE_44100:
					cmpci_reg_set_4(sc, CMPCI_REG_FUNC_1,
							CMPCI_REG_SPDIF1_ENABLE);
					break;
				default:
					return EINVAL;
				}
			} else
				cmpci_reg_clear_4(sc, CMPCI_REG_FUNC_1,
						  CMPCI_REG_SPDIF1_ENABLE);
#endif
d775 2
d783 1
a783 3
cmpci_round_blocksize(handle, block)
	void *handle;
	int block;
d789 1
a789 2
cmpci_halt_output(handle)
	void *handle;
d808 1
a808 2
cmpci_halt_input(handle)
	void *handle;
d822 1
a822 1
	
d826 1
d828 1
a828 3
cmpci_getdev(handle, retp)
        void *handle;
        struct audio_device *retp;
d830 22
a851 1
	*retp = cmpci_device;
a854 1

d857 1
a857 3
cmpci_query_devinfo(handle, dip)
	void *handle;
	mixer_devinfo_t *dip;
d859 8
d868 3
a870 1
	(void)sc;
d873 1
a873 40
	case CMPCI_MASTER_VOL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = CMPCI_OUTPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return 0;
	case CMPCI_FM_VOL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = CMPCI_INPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = CMPCI_FM_IN_MUTE;
		strlcpy(dip->label.name, AudioNfmsynth,
		    sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return 0;
	case CMPCI_CD_VOL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = CMPCI_INPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = CMPCI_CD_IN_MUTE;
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return 0;
	case CMPCI_VOICE_VOL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = CMPCI_OUTPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return 0;
d875 3
d879 3
a881 3
		dip->mixer_class = CMPCI_OUTPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCoutputs,
d884 8
d893 7
a900 6
		dip->mixer_class = CMPCI_INPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = CMPCI_MIC_IN_MUTE;
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
		dip->un.v.num_channels = 1;
d904 10
a913 2
	case CMPCI_LINE_IN_VOL:
		dip->type = AUDIO_MIXER_VALUE;
d915 11
a925 6
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = CMPCI_LINE_IN_MUTE;
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d927 12
a940 1
		dip->prev = dip->next = AUDIO_MIXER_LAST;
d943 1
a943 5
#ifdef CMPCI_SPDIF_SUPPORT
		dip->un.s.num_mem = 5;
#else
		dip->un.s.num_mem = 4;
#endif
d946 1
a946 1
		dip->un.s.member[0].mask = 1 << CMPCI_MIC_VOL;
d949 1
a949 1
		dip->un.s.member[1].mask = 1 << CMPCI_CD_VOL;
d952 2
a953 2
		dip->un.s.member[2].mask = 1 << CMPCI_LINE_IN_VOL;
		strlcpy(dip->un.s.member[3].label.name, AudioNfmsynth,
d955 2
a956 3
		dip->un.s.member[3].mask = 1 << CMPCI_FM_VOL;
#ifdef CMPCI_SPDIF_SUPPORT
		strlcpy(dip->un.s.member[4].label.name, CmpciNspdif,
d958 7
a964 11
		dip->un.s.member[4].mask = 1 << CMPCI_SPDIF_IN;
#endif
		return 0;
	case CMPCI_BASS:
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNbass, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = CMPCI_EQUALIZATION_CLASS;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNbass,
		    sizeof dip->un.v.units.name);
d966 1
a966 11
	case CMPCI_TREBLE:
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNtreble, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = CMPCI_EQUALIZATION_CLASS;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNtreble,
		    sizeof dip->un.v.units.name);
		return 0;
	case CMPCI_RECORD_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
d968 16
a983 3
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCrecord,
		    sizeof dip->label.name);
d985 18
a1002 6
	case CMPCI_INPUT_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = CMPCI_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCinputs,
		    sizeof dip->label.name);
d1004 12
a1015 8
	case CMPCI_PCSPEAKER:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = CMPCI_INPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, "pc_speaker", sizeof dip->label.name);
		dip->un.v.num_channels = 1;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1017 3
a1019 14
	case CMPCI_INPUT_GAIN:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = CMPCI_INPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNinput,
		    sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return 0;
	case CMPCI_OUTPUT_GAIN:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = CMPCI_OUTPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
d1021 8
a1028 3
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1030 5
a1034 1
	case CMPCI_AGC:
a1035 3
		dip->mixer_class = CMPCI_INPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, "agc", sizeof dip->label.name);
d1037 1
a1037 1
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
d1039 2
a1040 2
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
d1042 1
a1042 1
		dip->un.e.member[1].ord = 1;
d1044 12
a1055 6
	case CMPCI_EQUALIZATION_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = CMPCI_EQUALIZATION_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCequalization,
		    sizeof dip->label.name);
d1057 3
a1059 56
	case CMPCI_CD_IN_MUTE:
		dip->prev = CMPCI_CD_VOL;
		dip->next = CMPCI_CD_SWAP;
		dip->mixer_class = CMPCI_INPUT_CLASS;
		goto mute;
	case CMPCI_MIC_IN_MUTE:
		dip->prev = CMPCI_MIC_VOL;
		dip->next = CMPCI_MIC_SWAP;
		dip->mixer_class = CMPCI_INPUT_CLASS;
		goto mute;
	case CMPCI_LINE_IN_MUTE:
		dip->prev = CMPCI_LINE_IN_VOL;
		dip->next = CMPCI_LINE_SWAP;
		dip->mixer_class = CMPCI_INPUT_CLASS;
		goto mute;
	case CMPCI_FM_IN_MUTE:
		dip->prev = CMPCI_FM_VOL;
		dip->next = CMPCI_FM_SWAP;
		dip->mixer_class = CMPCI_INPUT_CLASS;
		goto mute;
	case CMPCI_CD_SWAP:
		dip->prev = CMPCI_CD_IN_MUTE;
		dip->next = CMPCI_CD_OUT_MUTE;
		goto swap;
	case CMPCI_MIC_SWAP:
		dip->prev = CMPCI_MIC_IN_MUTE;
		dip->next = CMPCI_MIC_OUT_MUTE;
		goto swap;
	case CMPCI_LINE_SWAP:
		dip->prev = CMPCI_LINE_IN_MUTE;
		dip->next = CMPCI_LINE_OUT_MUTE;
		goto swap;
	case CMPCI_FM_SWAP:
		dip->prev = CMPCI_FM_IN_MUTE;
		dip->next = AUDIO_MIXER_LAST;
	swap:
		dip->mixer_class = CMPCI_INPUT_CLASS;
		strlcpy(dip->label.name, AudioNswap, sizeof dip->label.name);
		goto mute1;
	case CMPCI_CD_OUT_MUTE:
		dip->prev = CMPCI_CD_SWAP;
		dip->next = AUDIO_MIXER_LAST;
		dip->mixer_class = CMPCI_OUTPUT_CLASS;
		goto mute;
	case CMPCI_MIC_OUT_MUTE:
		dip->prev = CMPCI_MIC_SWAP;
		dip->next = AUDIO_MIXER_LAST;
		dip->mixer_class = CMPCI_OUTPUT_CLASS;
		goto mute;
	case CMPCI_LINE_OUT_MUTE:
		dip->prev = CMPCI_LINE_SWAP;
		dip->next = AUDIO_MIXER_LAST;
		dip->mixer_class = CMPCI_OUTPUT_CLASS;
	mute:
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
	mute1:
d1061 1
a1061 1
		dip->un.e.num_mem = 2;
d1064 2
a1065 2
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
d1067 4
a1070 1
		dip->un.e.member[1].ord = 1;
d1072 27
d1105 2
a1106 5
cmpci_alloc_dmamem(sc, size, type, flags, r_addr)
	struct cmpci_softc *sc;
	size_t size;
	int type, flags;
	caddr_t *r_addr;
d1108 1
a1108 1
	int ret = 0;
d1111 4
a1114 3
	
	if ( NULL == (n=malloc(sizeof(struct cmpci_dmanode), type, flags)) ) {
		ret = ENOMEM;
d1123 4
a1126 5
	if ( (ret=bus_dmamem_alloc(n->cd_tag, n->cd_size,
				   CMPCI_DMABUF_ALIGN, CMPCI_DMABUF_BOUNDARY,
				   n->cd_segs,
				   sizeof(n->cd_segs)/sizeof(n->cd_segs[0]),
				   &n->cd_nsegs, w)) )
d1128 3
a1130 2
	if ( (ret=bus_dmamem_map(n->cd_tag, n->cd_segs, n->cd_nsegs, n->cd_size,
				 &n->cd_addr, w | BUS_DMA_COHERENT)) )
d1132 3
a1134 2
	if ( (ret=bus_dmamap_create(n->cd_tag, n->cd_size, 1, n->cd_size, 0,
				    w, &n->cd_map)) )
d1136 3
a1138 2
	if ( (ret=bus_dmamap_load(n->cd_tag, n->cd_map, n->cd_addr, n->cd_size,
				  NULL, w)) )
d1145 2
a1146 2
	
destroy:
d1148 1
a1148 1
unmap:
d1150 1
a1150 1
dmafree:
d1153 1
a1153 1
mfree:
d1155 2
a1156 2
quit:
	return ret;
d1160 1
a1160 4
cmpci_free_dmamem(sc, addr, type)
	struct cmpci_softc *sc;
	caddr_t addr;
	int type;
d1162 1
a1162 1
    struct cmpci_dmanode **nnp;
a1166 1

d1180 1
a1180 3
cmpci_find_dmamem(sc, addr)
	struct cmpci_softc *sc;
	caddr_t addr;
d1183 1
d1192 2
d1195 1
a1195 4
cmpci_print_dmamem(struct cmpci_dmanode *p);
void
cmpci_print_dmamem(p)
	struct cmpci_dmanode *p;
d1204 2
a1205 5
cmpci_malloc(handle, direction, size, type, flags)
	void  *handle;
	int direction;
	size_t size;
	int    type, flags;
a1206 1
	struct cmpci_softc *sc = handle;
d1208 2
a1209 2
	
	if ( cmpci_alloc_dmamem(sc, size, type, flags, &addr) )
d1215 1
a1215 4
cmpci_free(handle, addr, type)
	void    *handle;
	void    *addr;
	int     type;
d1217 1
a1217 3
	struct cmpci_softc *sc = handle;
	
	cmpci_free_dmamem(sc, addr, type);
d1222 1
a1222 2
cmpci_adjust(val, mask)
    int val, mask;
d1231 1
a1231 3
cmpci_set_mixer_gain(sc, port)
	struct cmpci_softc *sc;
	int port;
d1234 1
d1238 3
a1240 2
		src = CMPCI_SB16_MIXER_MIC;
		break;
d1247 11
a1257 1
	case CMPCI_VOICE_VOL:
a1265 12
	case CMPCI_INPUT_GAIN:
		src = CMPCI_SB16_MIXER_INGAIN_L;
		break;
	case CMPCI_OUTPUT_GAIN:
		src = CMPCI_SB16_MIXER_OUTGAIN_L;
		break;
	case CMPCI_TREBLE:
		src = CMPCI_SB16_MIXER_TREBLE_L;
		break;
	case CMPCI_BASS:
		src = CMPCI_SB16_MIXER_BASS_L;
		break;
d1268 116
a1383 1
				     sc->gain[port][CMPCI_LEFT]);
d1388 3
a1390 1
	cmpci_mixerreg_write(sc, src, sc->gain[port][CMPCI_LEFT]);
d1392 94
a1485 1
			     sc->gain[port][CMPCI_RIGHT]);
d1489 2
a1490 2
cmpci_set_in_ports(sc, mask)
	struct cmpci_softc *sc;
a1491 1
{
d1494 10
a1503 14
	if (mask & ~((1<<CMPCI_FM_VOL) | (1<<CMPCI_LINE_IN_VOL) |
		     (1<<CMPCI_CD_VOL) | (1<<CMPCI_MIC_VOL)
#ifdef CMPCI_SPDIF_SUPPORT
		     | (1<<CMPCI_SPDIF_IN)
#endif
		     ))
		return EINVAL;
	bitsr = 0;
	if (mask & (1<<CMPCI_FM_VOL))
		bitsr |= CMPCI_SB16_MIXER_FM_SRC_R;
	if (mask & (1<<CMPCI_LINE_IN_VOL))
		bitsr |= CMPCI_SB16_MIXER_LINE_SRC_R;
	if (mask & (1<<CMPCI_CD_VOL))
		bitsr |= CMPCI_SB16_MIXER_CD_SRC_R;
d1505 1
a1505 1
	if (mask & (1<<CMPCI_MIC_VOL)) {
d1512 29
a1540 1
	sc->in_mask = mask;
d1546 1
a1546 3
cmpci_set_port(handle, cp)
	void *handle;
	mixer_ctrl_t *cp;
d1550 1
a1550 4
	int mask, bits;
	int lmask, rmask, lbits, rbits;
	int mute, swap;
	
d1552 1
a1552 2
	case CMPCI_TREBLE:
	case CMPCI_BASS:
d1554 5
a1558 5
	case CMPCI_INPUT_GAIN:
	case CMPCI_OUTPUT_GAIN:
	case CMPCI_MIC_VOL:
	case CMPCI_LINE_IN_VOL:
	case CMPCI_VOICE_VOL:
d1561 2
d1566 4
a1569 7
		switch (cp->dev) {
		case CMPCI_MIC_VOL:
			if (cp->un.value.num_channels != 1)
				return EINVAL;

			lgain = rgain = CMPCI_ADJUST_MIC_GAIN(sc, 
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);
d1571 3
a1573 8
		case CMPCI_PCSPEAKER:
			if (cp->un.value.num_channels != 1)
			    return EINVAL;
			/* FALLTHROUGH */
		case CMPCI_INPUT_GAIN:
		case CMPCI_OUTPUT_GAIN:
			lgain = rgain = CMPCI_ADJUST_2_GAIN(sc, 
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);
d1576 1
a1576 15
			switch (cp->un.value.num_channels) {
			case 1:
				lgain = rgain = CMPCI_ADJUST_GAIN(sc, 
				    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);
				break;
			case 2:
				lgain = CMPCI_ADJUST_GAIN(sc, 
				    cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]);
				rgain = CMPCI_ADJUST_GAIN(sc, 
				    cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT]);
				break;
			default:
				return EINVAL;
			}
			break;
d1578 2
a1579 2
		sc->gain[cp->dev][CMPCI_LEFT]  = lgain;
		sc->gain[cp->dev][CMPCI_RIGHT] = rgain;
a1586 5
#ifdef CMPCI_SPDIF_SUPPORT
		if ( cp->un.mask&(1<<CMPCI_SPDIF_IN) )
			cp->un.mask = 1<<CMPCI_SPDIF_IN;
#endif
		return cmpci_set_in_ports(sc, cp->un.mask);
d1588 29
a1616 12
	case CMPCI_AGC:
		cmpci_mixerreg_write(sc, CMPCI_SB16_MIXER_AGC, cp->un.ord & 1);
		break;
	case CMPCI_CD_OUT_MUTE:
		mask = CMPCI_SB16_SW_CD;
		goto omute;
	case CMPCI_MIC_OUT_MUTE:
		mask = CMPCI_SB16_SW_MIC;
		goto omute;
	case CMPCI_LINE_OUT_MUTE:
		mask = CMPCI_SB16_SW_LINE;
	omute:
d1619 2
a1620 7
		bits = cmpci_mixerreg_read(sc, CMPCI_SB16_MIXER_OUTMIX);
		sc->gain[cp->dev][CMPCI_LR] = cp->un.ord != 0;
		if (cp->un.ord)
			bits = bits & ~mask;
		else
			bits = bits | mask;
		cmpci_mixerreg_write(sc, CMPCI_SB16_MIXER_OUTMIX, bits);
d1623 7
a1629 20
	case CMPCI_MIC_IN_MUTE:
	case CMPCI_MIC_SWAP:
		lmask = rmask = CMPCI_SB16_SW_MIC;
		goto imute;
	case CMPCI_CD_IN_MUTE:
	case CMPCI_CD_SWAP:
		lmask = CMPCI_SB16_SW_CD_L;
		rmask = CMPCI_SB16_SW_CD_R;
		goto imute;
	case CMPCI_LINE_IN_MUTE:
	case CMPCI_LINE_SWAP:
		lmask = CMPCI_SB16_SW_LINE_L;
		rmask = CMPCI_SB16_SW_LINE_R;
		goto imute;
	case CMPCI_FM_IN_MUTE:
	case CMPCI_FM_SWAP:
		lmask = CMPCI_SB16_SW_FM_L;
		rmask = CMPCI_SB16_SW_FM_R;
	imute:
		if (cp->type != AUDIO_MIXER_ENUM)
a1630 12
		mask = lmask | rmask;
		lbits = cmpci_mixerreg_read(sc, CMPCI_SB16_MIXER_ADCMIX_L)
		    & ~mask;
		rbits = cmpci_mixerreg_read(sc, CMPCI_SB16_MIXER_ADCMIX_R)
		    & ~mask;
		sc->gain[cp->dev][CMPCI_LR] = cp->un.ord != 0;
		if (CMPCI_IS_IN_MUTE(cp->dev)) {
			mute = cp->dev;
			swap = mute - CMPCI_CD_IN_MUTE + CMPCI_CD_SWAP;
		} else {
			swap = cp->dev;
			mute = swap + CMPCI_CD_IN_MUTE - CMPCI_CD_SWAP;
d1632 9
a1640 4
		if (sc->gain[swap][CMPCI_LR]) {
			mask = lmask;
			lmask = rmask;
			rmask = mask;
d1642 5
a1646 6
		if (!sc->gain[mute][CMPCI_LR]) {
			lbits = lbits | lmask;
			rbits = rbits | rmask;
		}
		cmpci_mixerreg_write(sc, CMPCI_SB16_MIXER_ADCMIX_L, lbits);
		cmpci_mixerreg_write(sc, CMPCI_SB16_MIXER_ADCMIX_R, rbits);
d1650 1
a1650 1
		return EINVAL;
d1657 1
a1657 3
cmpci_get_port(handle, cp)
	void *handle;
	mixer_ctrl_t *cp;
d1660 1
a1660 1
	
d1663 2
a1664 1
	case CMPCI_LINE_IN_VOL:
d1666 3
a1668 8
		    return EINVAL;
		/* FALLTHROUGH */
	case CMPCI_TREBLE:
	case CMPCI_BASS:
	case CMPCI_PCSPEAKER:
	case CMPCI_INPUT_GAIN:
	case CMPCI_OUTPUT_GAIN:
	case CMPCI_VOICE_VOL:
d1671 2
d1676 2
a1677 2
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = 
			    sc->gain[cp->dev][CMPCI_LEFT];
d1680 4
a1683 4
			cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = 
			    sc->gain[cp->dev][CMPCI_LEFT];
			cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = 
			    sc->gain[cp->dev][CMPCI_RIGHT];
d1691 1
a1691 5
		cp->un.mask = sc->in_mask;
		break;

	case CMPCI_AGC:
		cp->un.ord = cmpci_mixerreg_read(sc, CMPCI_SB16_MIXER_AGC);
d1694 3
a1696 2
	case CMPCI_CD_IN_MUTE:
	case CMPCI_MIC_IN_MUTE:
d1698 15
a1712 9
	case CMPCI_FM_IN_MUTE:
	case CMPCI_CD_SWAP:
	case CMPCI_MIC_SWAP:
	case CMPCI_LINE_SWAP:
	case CMPCI_FM_SWAP:
	case CMPCI_CD_OUT_MUTE:
	case CMPCI_MIC_OUT_MUTE:
	case CMPCI_LINE_OUT_MUTE:
		cp->un.ord = sc->gain[cp->dev][CMPCI_LR];
d1724 1
a1724 4
cmpci_round_buffersize(handle, direction, bufsize)
	void *handle;
	int direction;
	size_t bufsize;
d1727 2
a1728 2
	    bufsize = 0x10000;
    
d1733 1
a1733 5
cmpci_mappage(handle, addr, offset, prot)
	void *handle;
	void *addr;
	off_t offset;
	int   prot;
d1738 1
a1738 1
	if ( offset < 0 || (p = cmpci_find_dmamem(sc, addr)) == NULL)
d1742 2
a1743 2
			       sizeof(p->cd_segs)/sizeof(p->cd_segs[0]),
			       offset, prot, BUS_DMA_WAITOK);
d1748 1
a1748 2
cmpci_get_props(handle)
	void *handle;
a1752 1

d1754 2
a1755 7
cmpci_trigger_output(handle, start, end, blksize, intr, arg, param)
        void *handle;
        void *start, *end;
        int blksize;
        void (*intr)(void *);
        void *arg;
        struct audio_params *param;
d1771 1
a1771 1
			  DMAADDR(p));
d1774 1
a1774 1
			  ((caddr_t)end-(caddr_t)start+1)/bps-1);
d1779 1
a1779 1
			  (blksize+bps-1)/bps-1);
d1786 1
a1786 1
	
d1791 2
a1792 7
cmpci_trigger_input(handle, start, end, blksize, intr, arg, param)
        void *handle;
        void *start, *end;
        int blksize;
        void (*intr)(void *);
        void *arg;
        struct audio_params *param;
d1808 1
a1808 1
			  DMAADDR(p));
d1811 1
a1811 1
			  ((caddr_t)end-(caddr_t)start+1)/bps-1);
d1816 1
a1816 1
			  (blksize+bps-1)/bps-1);
d1823 1
a1823 1
	
d1826 2
@


1.12
log
@CMI can do mu-law encoding, don't use software emulation mode.
deraadt@@, jason@@, mickey@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.11 2003/06/05 23:53:54 fgsch Exp $	*/
d728 1
a728 1
	return (block & -4);
@


1.11
log
@untils this is sync'ed, correctly set mixer_class for CMPCI_OUTPUT_CLASS.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.10 2003/04/27 11:22:53 ho Exp $	*/
d471 1
a471 1
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
@


1.10
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.9 2002/11/19 18:40:17 jason Exp $	*/
d833 1
a833 1
		dip->mixer_class = CMPCI_INPUT_CLASS;
@


1.9
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.8 2002/03/14 03:16:06 millert Exp $	*/
d468 1
a468 1
		strcpy(fp->name, AudioEulinear);
d474 1
a474 1
		strcpy(fp->name, AudioEmulaw);
d480 1
a480 1
		strcpy(fp->name, AudioEalaw);
d486 1
a486 1
		strcpy(fp->name, AudioEslinear);
d492 1
a492 1
		strcpy(fp->name, AudioEslinear_le);
d498 1
a498 1
		strcpy(fp->name, AudioEulinear_le);
d504 1
a504 1
		strcpy(fp->name, AudioEslinear_be);
d510 1
a510 1
		strcpy(fp->name, AudioEulinear_be);
d795 1
a795 1
		strcpy(dip->label.name, AudioNmaster);
d797 2
a798 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d805 2
a806 1
		strcpy(dip->label.name, AudioNfmsynth);
d808 2
a809 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d816 1
a816 1
		strcpy(dip->label.name, AudioNcd);
d818 2
a819 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d826 1
a826 1
		strcpy(dip->label.name, AudioNdac);
d828 2
a829 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d835 2
a836 1
		strcpy(dip->label.name, AudioCoutputs);
d843 2
a844 1
		strcpy(dip->label.name, AudioNmicrophone);
d846 2
a847 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d854 1
a854 1
		strcpy(dip->label.name, AudioNline);
d856 2
a857 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d862 1
a862 1
		strcpy(dip->label.name, AudioNsource);
d869 2
a870 1
		strcpy(dip->un.s.member[0].label.name, AudioNmicrophone);
d872 2
a873 1
		strcpy(dip->un.s.member[1].label.name, AudioNcd);
d875 2
a876 1
		strcpy(dip->un.s.member[2].label.name, AudioNline);
d878 2
a879 1
		strcpy(dip->un.s.member[3].label.name, AudioNfmsynth);
d882 2
a883 1
		strcpy(dip->un.s.member[4].label.name, CmpciNspdif);
d889 1
a889 1
		strcpy(dip->label.name, AudioNbass);
d893 2
a894 1
		strcpy(dip->un.v.units.name, AudioNbass);
d898 1
a898 1
		strcpy(dip->label.name, AudioNtreble);
d902 2
a903 1
		strcpy(dip->un.v.units.name, AudioNtreble);
d909 2
a910 1
		strcpy(dip->label.name, AudioCrecord);
d916 2
a917 1
		strcpy(dip->label.name, AudioCinputs);
d923 1
a923 1
		strcpy(dip->label.name, "pc_speaker");
d925 2
a926 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d932 2
a933 1
		strcpy(dip->label.name, AudioNinput);
d935 2
a936 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d942 1
a942 1
		strcpy(dip->label.name, AudioNoutput);
d944 2
a945 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d951 1
a951 1
		strcpy(dip->label.name, "agc");
d953 2
a954 1
		strcpy(dip->un.e.member[0].label.name, AudioNoff);
d956 2
a957 1
		strcpy(dip->un.e.member[1].label.name, AudioNon);
d964 2
a965 1
		strcpy(dip->label.name, AudioCequalization);
d1004 1
a1004 1
		strcpy(dip->label.name, AudioNswap);
d1021 1
a1021 1
		strcpy(dip->label.name, AudioNmute);
d1025 2
a1026 1
		strcpy(dip->un.e.member[0].label.name, AudioNoff);
d1028 2
a1029 1
		strcpy(dip->un.e.member[1].label.name, AudioNon);
@


1.8
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.7 2002/03/14 01:26:58 millert Exp $	*/
d292 5
d307 2
a308 9
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_CMI &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CMI_CMI8338A ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CMI_CMI8338B ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CMI_CMI8738))
		return 1;

	return 0;
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.6 2002/01/20 19:56:53 ericj Exp $	*/
d145 6
a150 6
int cmpci_trigger_output __P((void *, void *, void *, int,
                              void (*)(void *), void *,
                              struct audio_params *));
int cmpci_trigger_input __P((void *, void *, void *, int,
                             void (*)(void *), void *,
                             struct audio_params *));
@


1.6
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.5 2001/10/31 11:00:24 art Exp $	*/
d71 5
a75 5
static __inline uint8_t cmpci_mixerreg_read __P((struct cmpci_softc *,
                                                 uint8_t));
static __inline void cmpci_mixerreg_write __P((struct cmpci_softc *,
                                               uint8_t, uint8_t));
static __inline void cmpci_reg_partial_write_4 __P((struct cmpci_softc *,
d77 12
a88 12
                                                    uint32_t, uint32_t));
static __inline void cmpci_reg_set_4 __P((struct cmpci_softc *,
                                          int, uint32_t));
static __inline void cmpci_reg_clear_4 __P((struct cmpci_softc *,
                                            int, uint32_t));
static int cmpci_rate_to_index __P((int));
static __inline int cmpci_index_to_rate __P((int));
static __inline int cmpci_index_to_divider __P((int));

static int cmpci_adjust __P((int, int));
static void cmpci_set_mixer_gain __P((struct cmpci_softc *, int));
static int cmpci_set_in_ports __P((struct cmpci_softc *, int));
d94 2
a95 2
int cmpci_match __P((struct device *, void *, void *));
void cmpci_attach __P((struct device *, struct device *, void *));
d112 1
a112 1
int cmpci_intr __P((void *));
d118 5
a122 5
int cmpci_alloc_dmamem __P((struct cmpci_softc *,
                            size_t, int, int, caddr_t *));
int cmpci_free_dmamem __P((struct cmpci_softc *, caddr_t, int));
struct cmpci_dmanode * cmpci_find_dmamem __P((struct cmpci_softc *,
                                                     caddr_t));
d127 4
a130 4
int cmpci_open __P((void *, int));
void cmpci_close __P((void *));
int cmpci_query_encoding __P((void *, struct audio_encoding *));
int cmpci_set_params __P((void *, int, int,
d132 13
a144 13
                          struct audio_params *));
int cmpci_round_blocksize __P((void *, int));
int cmpci_halt_output __P((void *));
int cmpci_halt_input __P((void *));
int cmpci_getdev __P((void *, struct audio_device *));
int cmpci_set_port __P((void *, mixer_ctrl_t *));
int cmpci_get_port __P((void *, mixer_ctrl_t *));
int cmpci_query_devinfo __P((void *, mixer_devinfo_t *));
void *cmpci_malloc __P((void *, int, size_t, int, int));
void cmpci_free __P((void *, void *, int));
size_t cmpci_round_buffersize __P((void *, int, size_t));
paddr_t cmpci_mappage __P((void *, void *, off_t, int));
int cmpci_get_props __P((void *));
d1106 1
a1106 1
cmpci_print_dmamem __P((struct cmpci_dmanode *p));
d1501 1
a1501 1
        void (*intr) __P((void *));
d1543 1
a1543 1
        void (*intr) __P((void *));
@


1.5
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.4 2001/10/03 18:20:12 deraadt Exp $	*/
d140 1
a140 1
void *cmpci_malloc __P((void *, u_long, int, int));
d142 1
a142 1
u_long cmpci_round_buffersize __P((void *, u_long));
d1118 1
a1118 1
cmpci_malloc(handle, size, type, flags)
d1120 2
a1121 1
	u_long size;
d1457 2
a1458 2
u_long
cmpci_round_buffersize(handle, bufsize)
d1460 2
a1461 1
	u_long bufsize;
@


1.5.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.6 2002/01/20 19:56:53 ericj Exp $	*/
d140 1
a140 1
void *cmpci_malloc __P((void *, int, size_t, int, int));
d142 1
a142 1
size_t cmpci_round_buffersize __P((void *, int, size_t));
d1118 1
a1118 1
cmpci_malloc(handle, direction, size, type, flags)
d1120 1
a1120 2
	int direction;
	size_t size;
d1456 2
a1457 2
size_t
cmpci_round_buffersize(handle, direction, bufsize)
d1459 1
a1459 2
	int direction;
	size_t bufsize;
@


1.5.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.5.2.1 2002/01/31 22:55:34 niklas Exp $	*/
d71 5
a75 5
static __inline uint8_t cmpci_mixerreg_read(struct cmpci_softc *,
                                                 uint8_t);
static __inline void cmpci_mixerreg_write(struct cmpci_softc *,
                                               uint8_t, uint8_t);
static __inline void cmpci_reg_partial_write_4(struct cmpci_softc *,
d77 12
a88 12
                                                    uint32_t, uint32_t);
static __inline void cmpci_reg_set_4(struct cmpci_softc *,
                                          int, uint32_t);
static __inline void cmpci_reg_clear_4(struct cmpci_softc *,
                                            int, uint32_t);
static int cmpci_rate_to_index(int);
static __inline int cmpci_index_to_rate(int);
static __inline int cmpci_index_to_divider(int);

static int cmpci_adjust(int, int);
static void cmpci_set_mixer_gain(struct cmpci_softc *, int);
static int cmpci_set_in_ports(struct cmpci_softc *, int);
d94 2
a95 2
int cmpci_match(struct device *, void *, void *);
void cmpci_attach(struct device *, struct device *, void *);
d112 1
a112 1
int cmpci_intr(void *);
d118 5
a122 5
int cmpci_alloc_dmamem(struct cmpci_softc *,
                            size_t, int, int, caddr_t *);
int cmpci_free_dmamem(struct cmpci_softc *, caddr_t, int);
struct cmpci_dmanode * cmpci_find_dmamem(struct cmpci_softc *,
                                                     caddr_t);
d127 4
a130 4
int cmpci_open(void *, int);
void cmpci_close(void *);
int cmpci_query_encoding(void *, struct audio_encoding *);
int cmpci_set_params(void *, int, int,
d132 19
a150 19
                          struct audio_params *);
int cmpci_round_blocksize(void *, int);
int cmpci_halt_output(void *);
int cmpci_halt_input(void *);
int cmpci_getdev(void *, struct audio_device *);
int cmpci_set_port(void *, mixer_ctrl_t *);
int cmpci_get_port(void *, mixer_ctrl_t *);
int cmpci_query_devinfo(void *, mixer_devinfo_t *);
void *cmpci_malloc(void *, int, size_t, int, int);
void cmpci_free(void *, void *, int);
size_t cmpci_round_buffersize(void *, int, size_t);
paddr_t cmpci_mappage(void *, void *, off_t, int);
int cmpci_get_props(void *);
int cmpci_trigger_output(void *, void *, void *, int,
                         void (*)(void *), void *,
                         struct audio_params *);
int cmpci_trigger_input(void *, void *, void *, int,
                        void (*)(void *), void *,
                        struct audio_params *);
d1106 1
a1106 1
cmpci_print_dmamem(struct cmpci_dmanode *p);
d1501 1
a1501 1
        void (*intr)(void *);
d1543 1
a1543 1
        void (*intr)(void *);
@


1.5.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a291 5
const struct pci_matchid cmpci_devices[] = {
	{ PCI_VENDOR_CMI, PCI_PRODUCT_CMI_CMI8338A },
	{ PCI_VENDOR_CMI, PCI_PRODUCT_CMI_CMI8338B },
	{ PCI_VENDOR_CMI, PCI_PRODUCT_CMI_CMI8738 },
};
d302 9
a310 2
	return (pci_matchbyid((struct pci_attach_args *)aux, cmpci_devices,
	    sizeof(cmpci_devices)/sizeof(cmpci_devices[0])));
d470 1
a470 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d476 1
a476 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d482 1
a482 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d488 1
a488 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d494 1
a494 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d500 1
a500 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d506 1
a506 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d512 1
a512 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d797 1
a797 1
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d799 1
a799 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d806 1
a806 2
		strlcpy(dip->label.name, AudioNfmsynth,
		    sizeof dip->label.name);
d808 1
a808 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d815 1
a815 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d817 1
a817 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d824 1
a824 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d826 1
a826 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d832 1
a832 2
		strlcpy(dip->label.name, AudioCoutputs,
		    sizeof dip->label.name);
d839 1
a839 2
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
d841 1
a841 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d848 1
a848 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d850 1
a850 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d855 1
a855 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d862 1
a862 2
		strlcpy(dip->un.s.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.s.member[0].label.name);
d864 1
a864 2
		strlcpy(dip->un.s.member[1].label.name, AudioNcd,
		    sizeof dip->un.s.member[1].label.name);
d866 1
a866 2
		strlcpy(dip->un.s.member[2].label.name, AudioNline,
		    sizeof dip->un.s.member[2].label.name);
d868 1
a868 2
		strlcpy(dip->un.s.member[3].label.name, AudioNfmsynth,
		    sizeof dip->un.s.member[3].label.name);
d871 1
a871 2
		strlcpy(dip->un.s.member[4].label.name, CmpciNspdif,
		    sizeof dip->un.s.member[4].label.name);
d877 1
a877 1
		strlcpy(dip->label.name, AudioNbass, sizeof dip->label.name);
d881 1
a881 2
		strlcpy(dip->un.v.units.name, AudioNbass,
		    sizeof dip->un.v.units.name);
d885 1
a885 1
		strlcpy(dip->label.name, AudioNtreble, sizeof dip->label.name);
d889 1
a889 2
		strlcpy(dip->un.v.units.name, AudioNtreble,
		    sizeof dip->un.v.units.name);
d895 1
a895 2
		strlcpy(dip->label.name, AudioCrecord,
		    sizeof dip->label.name);
d901 1
a901 2
		strlcpy(dip->label.name, AudioCinputs,
		    sizeof dip->label.name);
d907 1
a907 1
		strlcpy(dip->label.name, "pc_speaker", sizeof dip->label.name);
d909 1
a909 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d915 1
a915 2
		strlcpy(dip->label.name, AudioNinput,
		    sizeof dip->label.name);
d917 1
a917 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d923 1
a923 1
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
d925 1
a925 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d931 1
a931 1
		strlcpy(dip->label.name, "agc", sizeof dip->label.name);
d933 1
a933 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d935 1
a935 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d942 1
a942 2
		strlcpy(dip->label.name, AudioCequalization,
		    sizeof dip->label.name);
d981 1
a981 1
		strlcpy(dip->label.name, AudioNswap, sizeof dip->label.name);
d998 1
a998 1
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d1002 1
a1002 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d1004 1
a1004 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
@


1.4
log
@return 1 from interrupt handled; kevlo
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.3 2001/08/25 10:13:29 art Exp $	*/
d143 1
a143 1
int cmpci_mappage __P((void *, void *, int, int));
d1467 1
a1467 1
int
d1471 1
a1471 1
	int   offset;
@


1.3
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.2 2001/06/12 15:40:30 niklas Exp $	*/
d437 1
a437 1
	return 0;
@


1.2
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.1 2000/04/27 02:19:41 millert Exp $	*/
d332 1
a332 2
	if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
			  pa->pa_intrline, &ih)) {
@


1.1
log
@Driver for C-Media CMI8x38 Audio Chip present on several all-in-one
motherboards (ie: bultin audio + video).  Written by Takuya SHIOZAKI.
@
text
@d1 1
a1 1
/*	$OpenBSD: $	*/
d326 1
a326 1
			   &sc->sc_iot, &sc->sc_ioh, NULL, NULL)) {
@


1.1.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.1 2000/04/27 02:19:41 millert Exp $	*/
@


1.1.8.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.1.8.1 2001/05/14 22:25:35 niklas Exp $	*/
d326 1
a326 1
			   &sc->sc_iot, &sc->sc_ioh, NULL, NULL, 0)) {
@


1.1.8.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.1.8.2 2001/07/04 10:41:56 niklas Exp $	*/
d332 2
a333 1
	if (pci_intr_map(pa, &ih)) {
d438 1
a438 1
	return 1;
@


1.1.8.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d143 1
a143 1
paddr_t cmpci_mappage __P((void *, void *, off_t, int));
d1467 1
a1467 1
paddr_t
d1471 1
a1471 1
	off_t offset;
@


1.1.8.5
log
@Merge in trunk
@
text
@d140 1
a140 1
void *cmpci_malloc __P((void *, int, size_t, int, int));
d142 1
a142 1
size_t cmpci_round_buffersize __P((void *, int, size_t));
d1118 1
a1118 1
cmpci_malloc(handle, direction, size, type, flags)
d1120 1
a1120 2
	int direction;
	size_t size;
d1456 2
a1457 2
size_t
cmpci_round_buffersize(handle, direction, bufsize)
d1459 1
a1459 2
	int direction;
	size_t bufsize;
@


1.1.8.6
log
@Merge in -current from roughly a week ago
@
text
@d71 5
a75 5
static __inline uint8_t cmpci_mixerreg_read(struct cmpci_softc *,
                                                 uint8_t);
static __inline void cmpci_mixerreg_write(struct cmpci_softc *,
                                               uint8_t, uint8_t);
static __inline void cmpci_reg_partial_write_4(struct cmpci_softc *,
d77 12
a88 12
                                                    uint32_t, uint32_t);
static __inline void cmpci_reg_set_4(struct cmpci_softc *,
                                          int, uint32_t);
static __inline void cmpci_reg_clear_4(struct cmpci_softc *,
                                            int, uint32_t);
static int cmpci_rate_to_index(int);
static __inline int cmpci_index_to_rate(int);
static __inline int cmpci_index_to_divider(int);

static int cmpci_adjust(int, int);
static void cmpci_set_mixer_gain(struct cmpci_softc *, int);
static int cmpci_set_in_ports(struct cmpci_softc *, int);
d94 2
a95 2
int cmpci_match(struct device *, void *, void *);
void cmpci_attach(struct device *, struct device *, void *);
d112 1
a112 1
int cmpci_intr(void *);
d118 5
a122 5
int cmpci_alloc_dmamem(struct cmpci_softc *,
                            size_t, int, int, caddr_t *);
int cmpci_free_dmamem(struct cmpci_softc *, caddr_t, int);
struct cmpci_dmanode * cmpci_find_dmamem(struct cmpci_softc *,
                                                     caddr_t);
d127 4
a130 4
int cmpci_open(void *, int);
void cmpci_close(void *);
int cmpci_query_encoding(void *, struct audio_encoding *);
int cmpci_set_params(void *, int, int,
d132 19
a150 19
                          struct audio_params *);
int cmpci_round_blocksize(void *, int);
int cmpci_halt_output(void *);
int cmpci_halt_input(void *);
int cmpci_getdev(void *, struct audio_device *);
int cmpci_set_port(void *, mixer_ctrl_t *);
int cmpci_get_port(void *, mixer_ctrl_t *);
int cmpci_query_devinfo(void *, mixer_devinfo_t *);
void *cmpci_malloc(void *, int, size_t, int, int);
void cmpci_free(void *, void *, int);
size_t cmpci_round_buffersize(void *, int, size_t);
paddr_t cmpci_mappage(void *, void *, off_t, int);
int cmpci_get_props(void *);
int cmpci_trigger_output(void *, void *, void *, int,
                         void (*)(void *), void *,
                         struct audio_params *);
int cmpci_trigger_input(void *, void *, void *, int,
                        void (*)(void *), void *,
                        struct audio_params *);
d1106 1
a1106 1
cmpci_print_dmamem(struct cmpci_dmanode *p);
d1501 1
a1501 1
        void (*intr)(void *);
d1543 1
a1543 1
        void (*intr)(void *);
@


1.1.8.7
log
@Sync the SMP branch with 3.3
@
text
@a291 5
const struct pci_matchid cmpci_devices[] = {
	{ PCI_VENDOR_CMI, PCI_PRODUCT_CMI_CMI8338A },
	{ PCI_VENDOR_CMI, PCI_PRODUCT_CMI_CMI8338B },
	{ PCI_VENDOR_CMI, PCI_PRODUCT_CMI_CMI8738 },
};
d302 9
a310 2
	return (pci_matchbyid((struct pci_attach_args *)aux, cmpci_devices,
	    sizeof(cmpci_devices)/sizeof(cmpci_devices[0])));
@


1.1.8.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.1.8.7 2003/03/28 00:38:20 niklas Exp $	*/
d468 1
a468 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d474 1
a474 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d480 1
a480 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d486 1
a486 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d492 1
a492 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d498 1
a498 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d504 1
a504 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d510 1
a510 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d795 1
a795 1
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d797 1
a797 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d804 1
a804 2
		strlcpy(dip->label.name, AudioNfmsynth,
		    sizeof dip->label.name);
d806 1
a806 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d813 1
a813 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d815 1
a815 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d822 1
a822 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d824 1
a824 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d830 1
a830 2
		strlcpy(dip->label.name, AudioCoutputs,
		    sizeof dip->label.name);
d837 1
a837 2
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
d839 1
a839 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d846 1
a846 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d848 1
a848 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d853 1
a853 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d860 1
a860 2
		strlcpy(dip->un.s.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.s.member[0].label.name);
d862 1
a862 2
		strlcpy(dip->un.s.member[1].label.name, AudioNcd,
		    sizeof dip->un.s.member[1].label.name);
d864 1
a864 2
		strlcpy(dip->un.s.member[2].label.name, AudioNline,
		    sizeof dip->un.s.member[2].label.name);
d866 1
a866 2
		strlcpy(dip->un.s.member[3].label.name, AudioNfmsynth,
		    sizeof dip->un.s.member[3].label.name);
d869 1
a869 2
		strlcpy(dip->un.s.member[4].label.name, CmpciNspdif,
		    sizeof dip->un.s.member[4].label.name);
d875 1
a875 1
		strlcpy(dip->label.name, AudioNbass, sizeof dip->label.name);
d879 1
a879 2
		strlcpy(dip->un.v.units.name, AudioNbass,
		    sizeof dip->un.v.units.name);
d883 1
a883 1
		strlcpy(dip->label.name, AudioNtreble, sizeof dip->label.name);
d887 1
a887 2
		strlcpy(dip->un.v.units.name, AudioNtreble,
		    sizeof dip->un.v.units.name);
d893 1
a893 2
		strlcpy(dip->label.name, AudioCrecord,
		    sizeof dip->label.name);
d899 1
a899 2
		strlcpy(dip->label.name, AudioCinputs,
		    sizeof dip->label.name);
d905 1
a905 1
		strlcpy(dip->label.name, "pc_speaker", sizeof dip->label.name);
d907 1
a907 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d913 1
a913 2
		strlcpy(dip->label.name, AudioNinput,
		    sizeof dip->label.name);
d915 1
a915 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d921 1
a921 1
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
d923 1
a923 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d929 1
a929 1
		strlcpy(dip->label.name, "agc", sizeof dip->label.name);
d931 1
a931 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d933 1
a933 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d940 1
a940 2
		strlcpy(dip->label.name, AudioCequalization,
		    sizeof dip->label.name);
d979 1
a979 1
		strlcpy(dip->label.name, AudioNswap, sizeof dip->label.name);
d996 1
a996 1
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d1000 1
a1000 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d1002 1
a1002 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
@


1.1.8.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cmpci.c,v 1.1.8.8 2003/05/13 19:35:04 ho Exp $	*/
d833 1
a833 1
		dip->mixer_class = CMPCI_OUTPUT_CLASS;
@


1.1.8.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d471 1
a471 1
		fp->flags = 0;
@


