head	1.70;
access;
symbols
	OPENBSD_6_0:1.66.0.6
	OPENBSD_6_0_BASE:1.66
	OPENBSD_5_9:1.66.0.2
	OPENBSD_5_9_BASE:1.66
	OPENBSD_5_8:1.61.0.4
	OPENBSD_5_8_BASE:1.61
	OPENBSD_5_7:1.58.0.6
	OPENBSD_5_7_BASE:1.58
	OPENBSD_5_6:1.58.0.4
	OPENBSD_5_6_BASE:1.58
	OPENBSD_5_5:1.56.0.6
	OPENBSD_5_5_BASE:1.56
	OPENBSD_5_4:1.56.0.2
	OPENBSD_5_4_BASE:1.56
	OPENBSD_5_3:1.52.0.2
	OPENBSD_5_3_BASE:1.52
	OPENBSD_5_2:1.51.0.2
	OPENBSD_5_2_BASE:1.51
	OPENBSD_5_1_BASE:1.50
	OPENBSD_5_1:1.50.0.4
	OPENBSD_5_0:1.50.0.2
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.49.0.2
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.40.0.2
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.28.0.4
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7;
locks; strict;
comment	@ * @;


1.70
date	2017.03.28.05.23.15;	author ratchov;	state Exp;
branches;
next	1.69;
commitid	75EBnrlyZYJN8yvG;

1.69
date	2017.02.10.08.05.14;	author ratchov;	state Exp;
branches;
next	1.68;
commitid	LF6V2oghiQEuSAkj;

1.68
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.67;
commitid	qGgYgJTgEFuAoGj4;

1.67
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.66;
commitid	pi1a9KN0itEngOc4;

1.66
date	2015.08.30.08.52.26;	author ratchov;	state Exp;
branches;
next	1.65;
commitid	ZppKSHZA1jgaqGj5;

1.65
date	2015.08.28.16.21.41;	author ratchov;	state Exp;
branches;
next	1.64;
commitid	MFVuBMqgzZvWHCab;

1.64
date	2015.08.28.16.15.39;	author ratchov;	state Exp;
branches;
next	1.63;
commitid	2zy4uhBsjf6VrduT;

1.63
date	2015.08.28.15.50.18;	author ratchov;	state Exp;
branches;
next	1.62;
commitid	dXG2uH0XRa39yv2d;

1.62
date	2015.08.28.13.51.22;	author ratchov;	state Exp;
branches;
next	1.61;
commitid	bj83AyR8I4KqjXvi;

1.61
date	2015.07.29.21.10.50;	author ratchov;	state Exp;
branches;
next	1.60;
commitid	TOIqvQTfhhpEIp7d;

1.60
date	2015.06.25.06.43.46;	author ratchov;	state Exp;
branches;
next	1.59;
commitid	EA6IpjJSgQH2WTCf;

1.59
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.58;
commitid	p4LJxGKbi0BU2cG6;

1.58
date	2014.05.29.20.40.26;	author ratchov;	state Exp;
branches;
next	1.57;

1.57
date	2014.05.17.12.23.46;	author ratchov;	state Exp;
branches;
next	1.56;

1.56
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.55;

1.55
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.54;

1.54
date	2013.04.22.15.10.55;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2013.03.14.08.14.47;	author ratchov;	state Exp;
branches;
next	1.52;

1.52
date	2013.02.15.14.26.24;	author ratchov;	state Exp;
branches;
next	1.51;

1.51
date	2012.03.30.08.18.19;	author ratchov;	state Exp;
branches;
next	1.50;

1.50
date	2011.04.27.07.01.33;	author ratchov;	state Exp;
branches;
next	1.49;

1.49
date	2010.12.22.09.54.27;	author jakemsr;	state Exp;
branches;
next	1.48;

1.48
date	2010.10.30.21.16.58;	author ratchov;	state Exp;
branches;
next	1.47;

1.47
date	2010.10.08.19.26.32;	author ratchov;	state Exp;
branches;
next	1.46;

1.46
date	2010.10.08.18.54.03;	author ratchov;	state Exp;
branches;
next	1.45;

1.45
date	2010.10.08.18.46.42;	author ratchov;	state Exp;
branches;
next	1.44;

1.44
date	2010.10.07.07.15.30;	author ratchov;	state Exp;
branches;
next	1.43;

1.43
date	2010.10.06.21.02.59;	author ratchov;	state Exp;
branches;
next	1.42;

1.42
date	2010.10.04.09.32.43;	author ratchov;	state Exp;
branches;
next	1.41;

1.41
date	2010.09.08.20.34.11;	author stsp;	state Exp;
branches;
next	1.40;

1.40
date	2010.07.31.16.52.37;	author ratchov;	state Exp;
branches;
next	1.39;

1.39
date	2010.07.21.07.49.48;	author ratchov;	state Exp;
branches;
next	1.38;

1.38
date	2010.07.21.07.11.55;	author ratchov;	state Exp;
branches;
next	1.37;

1.37
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.36;

1.36
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2010.03.07.18.55.45;	author ratchov;	state Exp;
branches;
next	1.34;

1.34
date	2010.02.25.21.25.03;	author ratchov;	state Exp;
branches;
next	1.33;

1.33
date	2010.02.25.21.19.37;	author ratchov;	state Exp;
branches;
next	1.32;

1.32
date	2010.02.20.16.45.28;	author ratchov;	state Exp;
branches;
next	1.31;

1.31
date	2009.11.02.05.54.16;	author ratchov;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.24.09.13.35;	author ratchov;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.11.12.59.29;	author ratchov;	state Exp;
branches;
next	1.28;

1.28
date	2009.05.18.20.10.12;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2009.05.08.17.52.18;	author ratchov;	state Exp;
branches;
next	1.26;

1.26
date	2009.05.08.16.53.45;	author ratchov;	state Exp;
branches;
next	1.25;

1.25
date	2009.05.08.16.12.23;	author ratchov;	state Exp;
branches;
next	1.24;

1.24
date	2009.05.08.16.07.26;	author ratchov;	state Exp;
branches;
next	1.23;

1.23
date	2009.05.08.15.31.16;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2009.05.08.15.17.41;	author ratchov;	state Exp;
branches;
next	1.21;

1.21
date	2009.05.08.14.56.03;	author ratchov;	state Exp;
branches;
next	1.20;

1.20
date	2009.05.08.13.35.55;	author ratchov;	state Exp;
branches;
next	1.19;

1.19
date	2009.05.04.04.49.50;	author ratchov;	state Exp;
branches;
next	1.18;

1.18
date	2009.05.03.20.55.44;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2009.04.25.12.15.10;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2009.04.25.12.10.19;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2009.03.04.17.54.14;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.17.18.29.55;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.09.22.49.59;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.29.18.32.18;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.9;

1.9
date	2008.04.30.17.31.26;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2008.04.21.00.32.43;	author jakemsr;	state Exp;
branches;
next	1.7;

1.7
date	2008.02.21.01.41.04;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2008.02.21.01.37.55;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.14.01.23.53;	author jakemsr;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.08.10.01.28;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.08.09.59.33;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.28.18.25.21;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.28.13.42.31;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.70
log
@Make set_params() return the rate the device is using. Fixes
a wrong rate being reported when a unsupported rate was requested.
@
text
@/*	$OpenBSD: envy.c,v 1.69 2017/02/10 08:05:14 ratchov Exp $	*/
/*
 * Copyright (c) 2007 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * TODO:
 *
 * - add nspdin, nspdout, to struct envy_card
 *
 * - use eeprom version rather isht flag
 *
 * - implement HT mixer, midi uart, spdif, init ADC/DACs for >48kHz modes
 *
 */

#include "midi.h"
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/audioio.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <dev/audio_if.h>
#include <dev/midi_if.h>
#include <dev/ic/ac97.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/envyvar.h>
#include <dev/pci/envyreg.h>
#include <machine/bus.h>
#include <uvm/uvm.h>

#ifdef ENVY_DEBUG
#define DPRINTF(...) do { if (envydebug) printf(__VA_ARGS__); } while(0)
#define DPRINTFN(n, ...) do { if (envydebug > (n)) printf(__VA_ARGS__); } while(0)
int envydebug = 1;
#else
#define DPRINTF(...) do {} while(0)
#define DPRINTFN(n, ...) do {} while(0)
#endif
#define DEVNAME(sc) ((sc)->dev.dv_xname)

int  envymatch(struct device *, void *, void *);
void envyattach(struct device *, struct device *, void *);
int  envydetach(struct device *, int);

int  envy_ccs_read(struct envy_softc *, int);
void envy_ccs_write(struct envy_softc *, int, int);
int  envy_mt_read_1(struct envy_softc *, int);
void envy_mt_write_1(struct envy_softc *, int, int);
int  envy_mt_read_2(struct envy_softc *, int);
void envy_mt_write_2(struct envy_softc *, int, int);
int  envy_mt_read_4(struct envy_softc *, int);
void envy_mt_write_4(struct envy_softc *, int, int);
int  envy_cci_read(struct envy_softc *, int);
void envy_cci_write(struct envy_softc *, int, int);
void envy_i2c_wait(struct envy_softc *);
int  envy_i2c_read(struct envy_softc *, int, int);
void envy_i2c_write(struct envy_softc *, int, int, int);
int  envy_gpio_getstate(struct envy_softc *);
void envy_gpio_setstate(struct envy_softc *, int);
int  envy_gpio_getmask(struct envy_softc *);
void envy_gpio_setmask(struct envy_softc *, int);
int  envy_gpio_getdir(struct envy_softc *);
void envy_gpio_setdir(struct envy_softc *, int);
void envy_gpio_i2c_start_bit(struct envy_softc *, int, int);
void envy_gpio_i2c_stop_bit(struct envy_softc *, int, int);
void envy_gpio_i2c_byte_out(struct envy_softc *, int, int, int);
int  envy_eeprom_gpioxxx(struct envy_softc *, int);
void envy_midi_wait(struct envy_softc *);
void envy_reset(struct envy_softc *);
int  envy_codec_read(struct envy_softc *, int, int);
void envy_codec_write(struct envy_softc *, int, int, int);
void envy_pintr(struct envy_softc *);
int  envy_intr(void *);

int envy_lineout_getsrc(struct envy_softc *, int);
void envy_lineout_setsrc(struct envy_softc *, int, int);
int envy_spdout_getsrc(struct envy_softc *, int);
void envy_spdout_setsrc(struct envy_softc *, int, int);
void envy_mon_getvol(struct envy_softc *, int, int, int *);
void envy_mon_setvol(struct envy_softc *, int, int, int);

int envy_open(void *, int);
void envy_close(void *);
void *envy_allocm(void *, int, size_t, int, int);
void envy_freem(void *, void *, int);
int envy_set_params(void *, int, int, struct audio_params *,
    struct audio_params *);
int envy_round_blocksize(void *, int);
size_t envy_round_buffersize(void *, int, size_t);
int envy_trigger_output(void *, void *, void *, int,
    void (*)(void *), void *, struct audio_params *);
int envy_trigger_input(void *, void *, void *, int,
    void (*)(void *), void *, struct audio_params *);
int envy_halt_output(void *);
int envy_halt_input(void *);
int envy_query_devinfo(void *, struct mixer_devinfo *);
int envy_get_port(void *, struct mixer_ctrl *);
int envy_set_port(void *, struct mixer_ctrl *);
int envy_get_props(void *);
#if NMIDI > 0
int envy_midi_open(void *, int, void (*)(void *, int),
    void (*)(void *), void *);
void envy_midi_close(void *);
int envy_midi_output(void *, int);
void envy_midi_getinfo(void *, struct midi_info *);
#endif

int  envy_ac97_wait(struct envy_softc *);
int  envy_ac97_attach_codec(void *, struct ac97_codec_if *);
int  envy_ac97_read_codec(void *, u_int8_t, u_int16_t *);
int  envy_ac97_write_codec(void *, u_int8_t, u_int16_t);
void envy_ac97_reset_codec(void *);
enum ac97_host_flags envy_ac97_flags_codec(void *);

void delta_init(struct envy_softc *);
void delta_codec_write(struct envy_softc *, int, int, int);

void ap192k_init(struct envy_softc *);
void ap192k_codec_write(struct envy_softc *, int, int, int);

void ewx_codec_write(struct envy_softc *, int, int, int);

void revo51_init(struct envy_softc *);
void revo51_codec_write(struct envy_softc *, int, int, int);

void envy_ac97_init(struct envy_softc *);
void dynex_sc51_init(struct envy_softc *);

void julia_init(struct envy_softc *);
void julia_codec_write(struct envy_softc *, int, int, int);

void unkenvy_init(struct envy_softc *);
void unkenvy_codec_write(struct envy_softc *, int, int, int);
int unkenvy_codec_ndev(struct envy_softc *);

int ak4524_dac_ndev(struct envy_softc *);
void ak4524_dac_devinfo(struct envy_softc *, struct mixer_devinfo *, int);
void ak4524_dac_get(struct envy_softc *, struct mixer_ctrl *, int);
int ak4524_dac_set(struct envy_softc *, struct mixer_ctrl *, int);
int ak4524_adc_ndev(struct envy_softc *);
void ak4524_adc_devinfo(struct envy_softc *, struct mixer_devinfo *, int);
void ak4524_adc_get(struct envy_softc *, struct mixer_ctrl *, int);
int ak4524_adc_set(struct envy_softc *, struct mixer_ctrl *, int);

int ak4358_dac_ndev(struct envy_softc *);
void ak4358_dac_devinfo(struct envy_softc *, struct mixer_devinfo *, int);
void ak4358_dac_get(struct envy_softc *, struct mixer_ctrl *, int);
int ak4358_dac_set(struct envy_softc *, struct mixer_ctrl *, int);

int ak5365_adc_ndev(struct envy_softc *);
void ak5365_adc_devinfo(struct envy_softc *, struct mixer_devinfo *, int);
void ak5365_adc_get(struct envy_softc *, struct mixer_ctrl *, int);
int ak5365_adc_set(struct envy_softc *, struct mixer_ctrl *, int);

struct cfattach envy_ca = {
	sizeof(struct envy_softc), envymatch, envyattach, envydetach
};

struct cfdriver envy_cd = {
	NULL, "envy", DV_DULL
};

struct audio_hw_if envy_hw_if = {
	envy_open,		/* open */
	envy_close,		/* close */
	envy_set_params,	/* set_params */
	envy_round_blocksize,	/* round_blocksize */
	NULL,			/* commit_settings */
	NULL,			/* init_output */
	NULL,			/* init_input */
	NULL,			/* start_output */
	NULL,			/* start_input */
	envy_halt_output,	/* halt_output */
	envy_halt_input,	/* halt_input */
	NULL,			/* speaker_ctl */
	NULL,			/* setfd */
	envy_set_port,		/* set_port */
	envy_get_port,		/* get_port */
	envy_query_devinfo,	/* query_devinfo */
	envy_allocm,		/* malloc */
	envy_freem,		/* free */
	envy_round_buffersize,	/* round_buffersize */
	envy_get_props,		/* get_props */
	envy_trigger_output,	/* trigger_output */
	envy_trigger_input	/* trigger_input */
};

#if NMIDI > 0
struct midi_hw_if envy_midi_hw_if = {
	envy_midi_open,
	envy_midi_close,
	envy_midi_output,
	NULL,				/* flush */
	envy_midi_getinfo,
	NULL				/* ioctl */
};
#endif

struct pci_matchid envy_matchids[] = {
	{ PCI_VENDOR_ICENSEMBLE, PCI_PRODUCT_ICENSEMBLE_ICE1712 },
	{ PCI_VENDOR_ICENSEMBLE, PCI_PRODUCT_ICENSEMBLE_VT172x }
};

/*
 * correspondence between rates (in frames per second)
 * and values of rate register
 */
struct {
	int rate, reg;
} envy_rates[] = {
	{ 8000, 0x6}, { 9600, 0x3}, {11025, 0xa}, {12000, 2}, {16000, 5},
	{22050, 0x9}, {24000, 0x1}, {32000, 0x4}, {44100, 8}, {48000, 0},
	{64000, 0xf}, {88200, 0xb}, {96000, 0x7}, {-1, -1}
};

/*
 * ESI Julia cards don't have EEPROM, use this copy
 */
static unsigned char julia_eeprom[ENVY_EEPROM_MAXSZ] = {
	/* gpio mask/dir/state is from linux */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x80, 0xf8, 0xc3,
	0x9f, 0xff, 0x7f,
	0x90, 0xff, 0x7f,
	0x66, 0x00, 0x00
};

struct envy_codec ak4524_dac = {
	"ak4524 dac", ak4524_dac_ndev, ak4524_dac_devinfo, ak4524_dac_get, ak4524_dac_set
}, ak4524_adc = {
	"ak4524 adc", ak4524_adc_ndev, ak4524_adc_devinfo, ak4524_adc_get, ak4524_adc_set
}, ak4358_dac = {
	"ak4358 dac", ak4358_dac_ndev, ak4358_dac_devinfo, ak4358_dac_get, ak4358_dac_set
}, ak5365_adc = {
	"ak5365 adc", ak5365_adc_ndev, ak5365_adc_devinfo, ak5365_adc_get, ak5365_adc_set
}, unkenvy_codec = {
	"unknown codec", unkenvy_codec_ndev, NULL, NULL, NULL
};

/*
 * array with vendor/product sub-IDs to card info
 */
struct envy_card envy_cards[] = {
	{
		PCI_ID_CODE(0x1412, 0xd630),
		"M-Audio Delta 1010",
		8, &ak4524_adc, 8, &ak4524_dac, 1,
		delta_init,
		delta_codec_write,
		NULL
	}, {
		PCI_ID_CODE(0x1412, 0xd632),
		"M-Audio Delta 66",
		4, &ak4524_adc, 4, &ak4524_dac, 0,
		delta_init,
		delta_codec_write,
		NULL
	}, {
#define ENVY_SUBID_DELTA44	(PCI_ID_CODE(0x1412, 0xd633))
		PCI_ID_CODE(0x1412, 0xd633),
		"M-Audio Delta 44",
		4, &ak4524_adc, 4, &ak4524_dac, 0,
		delta_init,
		delta_codec_write,
		NULL
	}, {
		PCI_ID_CODE(0x1412, 0xd63b),
		"M-Audio Delta 1010LT",
		8, &ak4524_adc, 8, &ak4524_dac, 1,
		delta_init,
		delta_codec_write,
		NULL
	}, {
		PCI_ID_CODE(0x1412, 0xd634),
		"M-Audio Audiophile 2496",
		2, &ak4524_adc, 2, &ak4524_dac, 1,
		delta_init,
		delta_codec_write,
		NULL
	}, {
		PCI_ID_CODE(0x153b, 0x1130),
		"Terratec EWX 24/96",
		2, &ak4524_adc, 2, &ak4524_dac, 1,
		delta_init,
		ewx_codec_write,
		NULL
	}, {
		0,
		"unknown 1712-based card",
		8, &unkenvy_codec, 8, &unkenvy_codec, 1,
		unkenvy_init,
		unkenvy_codec_write
	}
}, envy_cards_ht[] = {
	{
		PCI_ID_CODE(0x3031, 0x4553),
		"ESI Julia",
		2, &unkenvy_codec, 2, &ak4358_dac, 1,
		julia_init,
		julia_codec_write,
		julia_eeprom
	}, {
		PCI_ID_CODE(0x1412, 0x3632),
		"M-Audio Audiophile 192k",
		2, &unkenvy_codec, 2, &ak4358_dac, 1,
		ap192k_init,
		ap192k_codec_write
	}, {
		PCI_ID_CODE(0x1412, 0x3631),
		"M-Audio Revolution 5.1",
		2, &ak5365_adc, 6, &ak4358_dac, 1,
		revo51_init,
		revo51_codec_write
	}, {
		PCI_ID_CODE(0x1412, 0x2403),
		"VIA Tremor 5.1",
		2, &unkenvy_codec, 6, &unkenvy_codec, 1,
		envy_ac97_init,
		unkenvy_codec_write
	}, {
		PCI_ID_CODE(0x14c3, 0x1705),
		"Dynex DX-SC51",
		2, &unkenvy_codec, 6, &unkenvy_codec, 0,
		dynex_sc51_init,
		unkenvy_codec_write
	}, {
		0,
		"unknown 1724-based card",
		2, &unkenvy_codec, 8, &unkenvy_codec, 1,
		unkenvy_init,
		unkenvy_codec_write
	}
};


/*
 * M-Audio Delta specific code
 */

void
delta_init(struct envy_softc *sc)
{
	int dev;

	for (dev = 0; dev < sc->card->noch / 2; dev++) {
		envy_codec_write(sc, dev, AK4524_RST, 0x0);
		delay(300);
		envy_codec_write(sc, dev, AK4524_RST,
		    AK4524_RST_AD | AK4524_RST_DA);
		envy_codec_write(sc, dev, AK4524_FMT,
		    AK4524_FMT_IIS24);
		sc->shadow[dev][AK4524_DEEMVOL] = AK4524_DEEM_OFF;
		sc->shadow[dev][AK4524_ADC_GAIN0] = 0x7f;
		sc->shadow[dev][AK4524_ADC_GAIN1] = 0x7f;
		sc->shadow[dev][AK4524_DAC_GAIN0] = 0x7f;
		sc->shadow[dev][AK4524_DAC_GAIN1] = 0x7f;
	}
}

void
delta_codec_write(struct envy_softc *sc, int dev, int addr, int data)
{
	int bits, i, reg;
	int clk, dout, csmask, cs;

	/*
	 * GPIO pin numbers
	 */
	if (sc->card->subid == ENVY_SUBID_DELTA44) {
		clk = 0x20;
		dout = 0x10;
		csmask = 0xc0;
		cs = dev ? 0x40 : 0x80;
	} else {
		clk = 0x2;
		dout = 0x8;
		csmask = 0x70;
		cs = dev << 4;
	}

	reg = envy_gpio_getstate(sc);
	reg &= ~csmask;
	reg |= cs;
	envy_gpio_setstate(sc, reg);
	delay(1);

	bits  = 0xa000 | (addr << 8) | data;
	for (i = 0; i < 16; i++) {
		reg &= ~(clk | dout);
		reg |= (bits & 0x8000) ? dout : 0;
		envy_gpio_setstate(sc, reg);
		delay(1);

		reg |= clk;
		envy_gpio_setstate(sc, reg);
		delay(1);
		bits <<= 1;
	}

	reg |= csmask;
	envy_gpio_setstate(sc, reg);
	delay(1);
}

/*
 * M-Audio Audiophile 192 specific code
 */

/*
 * GPIO pin numbers
 */
#define AP192K_GPIO_CLK		0x2
#define AP192K_GPIO_DOUT	0x8
#define AP192K_GPIO_CSMASK	0x30
#define AP192K_GPIO_CS(dev)	((dev) << 4)
#define AP192K_GPIO_ADC_PWR	0x800
#define AP192K_GPIO_ADC_DFSMASK	(3 << 9)
#define AP192K_GPIO_ADC_DFS(v)	((v) << 9)
#define AP192K_GPIO_MUTE	0x400000

void
ap192k_init(struct envy_softc *sc)
{
	int i, reg;

	/* AK4358 */
	envy_codec_write(sc, 0, 0, 0);	/* reset */
	delay(300);
	envy_codec_write(sc, 0, 0, 0x87);	/* i2s mode */
	delay(1);
	for (i = 0; i < sc->card->noch; i++) {
		sc->shadow[0][AK4358_ATT(i)] = 0xff;
	}

	/* AK5385 */
	delay(1);
	reg = envy_gpio_getstate(sc);
	reg &= ~(AP192K_GPIO_ADC_PWR | AP192K_GPIO_ADC_DFSMASK);
	reg |= AP192K_GPIO_ADC_DFS(0);
	envy_gpio_setstate(sc, reg);
	reg |= AP192K_GPIO_ADC_PWR;
	envy_gpio_setstate(sc, reg);
}

void
ap192k_codec_write(struct envy_softc *sc, int dev, int addr, int data)
{
	int bits, i, reg;

	reg = envy_gpio_getstate(sc);
	reg &= ~AP192K_GPIO_CSMASK;
	reg |=  AP192K_GPIO_CS(dev);
	envy_gpio_setstate(sc, reg);
	delay(1);

	bits  = 0xa000 | (addr << 8) | data;
	for (i = 0; i < 16; i++) {
		reg &= ~(AP192K_GPIO_CLK | AP192K_GPIO_DOUT);
		reg |= (bits & 0x8000) ? AP192K_GPIO_DOUT : 0;
		envy_gpio_setstate(sc, reg);
		delay(1);

		reg |= AP192K_GPIO_CLK;
		envy_gpio_setstate(sc, reg);
		delay(1);
		bits <<= 1;
	}

	reg |= AP192K_GPIO_CSMASK;
	envy_gpio_setstate(sc, reg);
	delay(1);
}

/*
 * Terratec EWX specific code
 */

/*
 * GPIO pin numbers
 */
#define EWX_GPIO_CSMASK		0x01
#define EWX_GPIO_DOUT		0x10
#define EWX_GPIO_CLK		0x20

void
ewx_codec_write(struct envy_softc *sc, int dev, int addr, int data)
{
	int bits, i, reg;

	reg = envy_gpio_getstate(sc);
	reg |= (EWX_GPIO_CSMASK | EWX_GPIO_CLK);
	envy_gpio_setstate(sc, reg);
	delay(1);

	bits = 0xa000 | (addr << 8) | data;
	for (i = 0; i < 16; i++) {
		reg &= ~(EWX_GPIO_CLK | EWX_GPIO_DOUT);
		reg |= (bits & 0x8000) ? EWX_GPIO_DOUT : 0;
		envy_gpio_setstate(sc, reg);
		delay(1);

		reg |= EWX_GPIO_CLK;
		envy_gpio_setstate(sc, reg);
		delay(1);
		bits <<= 1;
	}

	reg &= ~EWX_GPIO_CSMASK;
	envy_gpio_setstate(sc, reg);
	delay(1);

	reg |= EWX_GPIO_CSMASK;
	envy_gpio_setstate(sc, reg);
	delay(1);
}


/*
 * M-Audio Revolution 5.1 specific code
 */

#define REVO51_GPIO_CLK		0x2
#define REVO51_GPIO_DOUT	0x8
#define REVO51_GPIO_CSMASK	0x30
#define REVO51_GPIO_CS(dev)	((dev) ? 0x10 : 0x20)
#define REVO51_MUTE		0x400000
#define REVO51_PT2258S_SDA	0x40
#define REVO51_PT2258S_SCL	0x80
#define REVO51_PT2258S_ADDR	0x80
#define REVO51_PT2258S_MUTE	6

void
revo51_init(struct envy_softc *sc)
{
	int i, reg;

	/* AK4358 */
	envy_codec_write(sc, 0, 0, 0);	/* reset */
	delay(300);
	envy_codec_write(sc, 0, 0, 0x87);	/* i2s mode */
	for (i = 0; i < sc->card->noch; i++) {
		sc->shadow[0][AK4358_ATT(i)] = 0xff;
	}

	/* AK5365 */
	envy_codec_write(sc, 1, AK5365_RST, 0);	/* reset */
	delay(300);
	envy_codec_write(sc, 1, AK5365_CTRL, AK5365_CTRL_I2S);	/* i2s mode */
	envy_codec_write(sc, 1, AK5365_RST , AK5365_RST_NORM);
	sc->shadow[1][AK5365_ATT(0)] = 0x7f;
	sc->shadow[1][AK5365_ATT(1)] = 0x7f;

	/* PT2258S */
	envy_codec_write(sc, 2, REVO51_PT2258S_MUTE, 0xc0);	/* reset */
	envy_codec_write(sc, 2, REVO51_PT2258S_MUTE, 0xf9);	/* mute */

	reg = envy_gpio_getstate(sc);
	reg |= REVO51_MUTE;
	envy_gpio_setstate(sc, reg);
}

void
revo51_codec_write(struct envy_softc *sc, int dev, int addr, int data)
{
	int attn, bits, mask, reg;
	int xlat[6] = {0x90, 0x50, 0x10, 0x30, 0x70, 0xb0};

	/* AK4358 & AK5365 */
	if (dev < 2) {
		reg = envy_gpio_getstate(sc);
		reg &= ~REVO51_GPIO_CSMASK;
		reg |=  REVO51_GPIO_CS(dev);
		envy_gpio_setstate(sc, reg);
		delay(1);

		bits  = 0xa000 | (addr << 8) | data;
		for (mask = 0x8000; mask != 0; mask >>= 1) {
			reg &= ~(REVO51_GPIO_CLK | REVO51_GPIO_DOUT);
			reg |= (bits & mask) ? REVO51_GPIO_DOUT : 0;
			envy_gpio_setstate(sc, reg);
			delay(1);

			reg |= REVO51_GPIO_CLK;
			envy_gpio_setstate(sc, reg);
			delay(1);
		}

		reg |= REVO51_GPIO_CSMASK;
		envy_gpio_setstate(sc, reg);
		delay(1);
		return;
	}

	/* PT2258S */
	envy_gpio_i2c_start_bit(sc, REVO51_PT2258S_SDA, REVO51_PT2258S_SCL);
	envy_gpio_i2c_byte_out(sc, REVO51_PT2258S_SDA, REVO51_PT2258S_SCL,
	    REVO51_PT2258S_ADDR);

	if (addr == REVO51_PT2258S_MUTE) {
		envy_gpio_i2c_byte_out(sc, REVO51_PT2258S_SDA,
		    REVO51_PT2258S_SCL, data);
	} else {
		/* 1's digit */
		attn = data % 10;
		attn += xlat[addr];
		envy_gpio_i2c_byte_out(sc, REVO51_PT2258S_SDA,
		    REVO51_PT2258S_SCL, attn);

		/* 10's digit */
		attn = data / 10;
		attn += xlat[addr] - 0x10;
		envy_gpio_i2c_byte_out(sc, REVO51_PT2258S_SDA,
		    REVO51_PT2258S_SCL, attn);
	}

	envy_gpio_i2c_stop_bit(sc, REVO51_PT2258S_SDA, REVO51_PT2258S_SCL);
}

/*
 * Generic AC'97 initialization
 */

void
envy_ac97_init(struct envy_softc *sc)
{
	sc->isac97 = 1;
	sc->host_if.arg = sc;
	sc->host_if.attach = envy_ac97_attach_codec;
	sc->host_if.read = envy_ac97_read_codec;
	sc->host_if.write = envy_ac97_write_codec;
	sc->host_if.reset = envy_ac97_reset_codec;
	sc->host_if.flags = envy_ac97_flags_codec;

	if (ac97_attach(&sc->host_if) != 0)
		printf("%s: can't attach ac97\n", DEVNAME(sc));
}

/*
 * Dynex
 */

void
dynex_sc51_init(struct envy_softc *sc)
{
	sc->codec_flags |= AC97_HOST_VT1616_DYNEX;
	envy_ac97_init(sc);
}

/*
 * ESI Julia specific code
 */

void
julia_init(struct envy_softc *sc)
{
	int i;

	envy_codec_write(sc, 0, 0, 0);	/* reset */
	delay(300);
	envy_codec_write(sc, 0, 0, 0x87);	/* i2s mode */
	for (i = 0; i < sc->card->noch; i++) {
		sc->shadow[0][AK4358_ATT(i)] = 0xff;
	}
}

void
julia_codec_write(struct envy_softc *sc, int dev, int addr, int data)
{
#define JULIA_AK4358_ADDR	0x11
	envy_i2c_write(sc, JULIA_AK4358_ADDR, addr, data);
}

/*
 * unknown card, ignore codecs setup and hope it works with the power on
 * settings
 */

void
unkenvy_init(struct envy_softc *sc)
{
}

void
unkenvy_codec_write(struct envy_softc *sc, int dev, int addr, int data)
{
}

int
unkenvy_codec_ndev(struct envy_softc *sc)
{
	return 0;
}

/*
 * AK 4358 DAC specific code
 */
int
ak4358_dac_ndev(struct envy_softc *sc)
{
	/* 1 volume knob per channel */
	return sc->card->noch;
}

void
ak4358_dac_devinfo(struct envy_softc *sc, struct mixer_devinfo *dev, int idx)
{
	dev->type = AUDIO_MIXER_VALUE;
	dev->mixer_class = ENVY_MIX_CLASSOUT;
	dev->un.v.delta = 2;
	dev->un.v.num_channels = 1;
	snprintf(dev->label.name, MAX_AUDIO_DEV_LEN,
	    AudioNline "-%d", idx);
	strlcpy(dev->un.v.units.name, AudioNvolume,
	    MAX_AUDIO_DEV_LEN);
}

void
ak4358_dac_get(struct envy_softc *sc, struct mixer_ctrl *ctl, int idx)
{
	int val;

	val = envy_codec_read(sc, 0, AK4358_ATT(idx)) & ~AK4358_ATT_EN;
	ctl->un.value.num_channels = 1;
	ctl->un.value.level[0] = 2 * val;
}

int
ak4358_dac_set(struct envy_softc *sc, struct mixer_ctrl *ctl, int idx)
{
	int val;

	if (ctl->un.value.num_channels != 1)
		return EINVAL;
	val = ctl->un.value.level[0] / 2;
	envy_codec_write(sc, 0, AK4358_ATT(idx), val | AK4358_ATT_EN);
	return 0;
}

/*
 * AK 4524 DAC specific code
 */
int
ak4524_dac_ndev(struct envy_softc *sc)
{
	/* 1 mute + 2 volume knobs per channel pair */
	return 3 * (sc->card->noch / 2);
}

void
ak4524_dac_devinfo(struct envy_softc *sc, struct mixer_devinfo *dev, int idx)
{
	int ndev;

	ndev = sc->card->noch;
	if (idx < ndev) {
		dev->type = AUDIO_MIXER_VALUE;
		dev->mixer_class = ENVY_MIX_CLASSOUT;
		dev->un.v.delta = 2;
		dev->un.v.num_channels = 1;
		snprintf(dev->label.name, MAX_AUDIO_DEV_LEN,
		    AudioNline "-%d", idx);
		strlcpy(dev->un.v.units.name, AudioNvolume,
		    MAX_AUDIO_DEV_LEN);
	} else {
		idx -= ndev;
		dev->type = AUDIO_MIXER_ENUM;
		dev->mixer_class = ENVY_MIX_CLASSOUT;
		dev->un.e.member[0].ord = 0;
		strlcpy(dev->un.e.member[0].label.name, AudioNoff,
		    MAX_AUDIO_DEV_LEN);
		dev->un.e.member[1].ord = 1;
		strlcpy(dev->un.e.member[1].label.name, AudioNon,
		   MAX_AUDIO_DEV_LEN);
		dev->un.e.num_mem = 2;
		snprintf(dev->label.name, MAX_AUDIO_DEV_LEN,
		    AudioNline "-%d:%d_" AudioNmute, 2 * idx, 2 * idx + 1);
	}
}

void
ak4524_dac_get(struct envy_softc *sc, struct mixer_ctrl *ctl, int idx)
{
	int val, ndev;

	ndev = sc->card->noch;
	if (idx < ndev) {
		val = envy_codec_read(sc, idx / 2,
		    (idx % 2) + AK4524_DAC_GAIN0);
		ctl->un.value.num_channels = 1;
		ctl->un.value.level[0] = 2 * val;
	} else {
		idx -= ndev;
		val = envy_codec_read(sc, idx, AK4524_DEEMVOL);
		ctl->un.ord = (val & AK4524_MUTE) ? 1 : 0;
	}
}

int
ak4524_dac_set(struct envy_softc *sc, struct mixer_ctrl *ctl, int idx)
{
	int val, ndev;

	ndev = sc->card->noch;
	if (idx < ndev) {
		if (ctl->un.value.num_channels != 1)
			return EINVAL;
		val = ctl->un.value.level[0] / 2;
		envy_codec_write(sc, idx / 2,
		    (idx % 2) + AK4524_DAC_GAIN0, val);
	} else {
		idx -= ndev;
		if (ctl->un.ord >= 2)
			return EINVAL;
		val = AK4524_DEEM_OFF | (ctl->un.ord ? AK4524_MUTE : 0);
		envy_codec_write(sc, idx, AK4524_DEEMVOL, val);
	}
	return 0;
}

/*
 * AK 4524 ADC specific code
 */
int
ak4524_adc_ndev(struct envy_softc *sc)
{
	/* one volume per channel */
	return sc->card->nich;
}

void
ak4524_adc_devinfo(struct envy_softc *sc, struct mixer_devinfo *dev, int idx)
{
	dev->type = AUDIO_MIXER_VALUE;
	dev->mixer_class = ENVY_MIX_CLASSIN;
	dev->un.v.delta = 2;
	dev->un.v.num_channels = 1;
	snprintf(dev->label.name, MAX_AUDIO_DEV_LEN, AudioNline "-%d", idx);
	strlcpy(dev->un.v.units.name, AudioNvolume, MAX_AUDIO_DEV_LEN);
}

void
ak4524_adc_get(struct envy_softc *sc, struct mixer_ctrl *ctl, int idx)
{
	int val;

	val = envy_codec_read(sc, idx / 2, (idx % 2) + AK4524_ADC_GAIN0);
	ctl->un.value.num_channels = 1;
	ctl->un.value.level[0] = 2 * val;
}

int
ak4524_adc_set(struct envy_softc *sc, struct mixer_ctrl *ctl, int idx)
{
	int val;

	if (ctl->un.value.num_channels != 1)
		return EINVAL;
	val = ctl->un.value.level[0] / 2;
	envy_codec_write(sc, idx / 2, (idx % 2) + AK4524_ADC_GAIN0, val);
	return 0;
}

/*
 * AK 5365 ADC specific code
 */
int
ak5365_adc_ndev(struct envy_softc *sc)
{
	/* 1 source + 2 volume knobs per channel pair */
	return (sc->card->nich + 1);
}

void
ak5365_adc_devinfo(struct envy_softc *sc, struct mixer_devinfo *dev, int idx)
{
	int ndev, i;

	ndev = sc->card->nich;
	if (idx < ndev) {
		dev->type = AUDIO_MIXER_VALUE;
		dev->mixer_class = ENVY_MIX_CLASSIN;
		dev->un.v.delta = 2;
		dev->un.v.num_channels = 1;
		snprintf(dev->label.name, MAX_AUDIO_DEV_LEN,
		    AudioNline "-%d", idx);
		strlcpy(dev->un.v.units.name, AudioNvolume,
		    MAX_AUDIO_DEV_LEN);
	} else {
		dev->type = AUDIO_MIXER_ENUM;
		dev->mixer_class = ENVY_MIX_CLASSIN;
		for (i = 0; i < 5; i++) {
			dev->un.e.member[i].ord = i;
			snprintf(dev->un.e.member[i].label.name,
			    MAX_AUDIO_DEV_LEN, AudioNline "-%d", i);
		}
		dev->un.e.num_mem = 5;
		strlcpy(dev->label.name, AudioNsource,
		    MAX_AUDIO_DEV_LEN);
	}
}

void
ak5365_adc_get(struct envy_softc *sc, struct mixer_ctrl *ctl, int idx)
{
	int val, ndev;

	ndev = sc->card->nich;
	if (idx < ndev) {
		val = envy_codec_read(sc, 1, AK5365_ATT(idx));
		ctl->un.value.num_channels = 1;
		ctl->un.value.level[0] = 2 * val;
	} else {
		ctl->un.ord = envy_codec_read(sc, 1, AK5365_SRC);
	}
}

int
ak5365_adc_set(struct envy_softc *sc, struct mixer_ctrl *ctl, int idx)
{
	int val, ndev;

	ndev = sc->card->nich;
	if (idx < ndev) {
		if (ctl->un.value.num_channels != 1)
			return EINVAL;
		val = ctl->un.value.level[0] / 2;
		envy_codec_write(sc, 1, AK5365_ATT(idx), val);
	} else {
		if (ctl->un.ord >= 5)
			return EINVAL;
		val = ctl->un.ord & AK5365_SRC_MASK;
		envy_codec_write(sc, 1, AK5365_SRC, val);
	}
	return 0;
}

/*
 * generic Envy24 and Envy24HT code, common to all cards
 */

int
envy_ccs_read(struct envy_softc *sc, int reg)
{
	int val;

	val = bus_space_read_1(sc->ccs_iot, sc->ccs_ioh, reg);
	bus_space_barrier(sc->ccs_iot, sc->ccs_ioh, 0, sc->ccs_iosz,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
	return val;
}

void
envy_ccs_write(struct envy_softc *sc, int reg, int val)
{
	bus_space_write_1(sc->ccs_iot, sc->ccs_ioh, reg, val);
	bus_space_barrier(sc->ccs_iot, sc->ccs_ioh, 0, sc->ccs_iosz,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
}

int
envy_mt_read_1(struct envy_softc *sc, int reg)
{
	int val;

	val = bus_space_read_1(sc->mt_iot, sc->mt_ioh, reg);
	bus_space_barrier(sc->mt_iot, sc->mt_ioh, 0, sc->mt_iosz,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
	return val;
}

void
envy_mt_write_1(struct envy_softc *sc, int reg, int val)
{
	bus_space_write_1(sc->mt_iot, sc->mt_ioh, reg, val);
	bus_space_barrier(sc->mt_iot, sc->mt_ioh, 0, sc->mt_iosz,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
}

int
envy_mt_read_2(struct envy_softc *sc, int reg)
{
	int val;

	val = bus_space_read_2(sc->mt_iot, sc->mt_ioh, reg);
	bus_space_barrier(sc->mt_iot, sc->mt_ioh, 0, sc->mt_iosz,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
	return val;
}

void
envy_mt_write_2(struct envy_softc *sc, int reg, int val)
{
	bus_space_write_2(sc->mt_iot, sc->mt_ioh, reg, val);
	bus_space_barrier(sc->mt_iot, sc->mt_ioh, 0, sc->mt_iosz,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
}

int
envy_mt_read_4(struct envy_softc *sc, int reg)
{
	int val;

	val = bus_space_read_4(sc->mt_iot, sc->mt_ioh, reg);
	bus_space_barrier(sc->mt_iot, sc->mt_ioh, 0, sc->mt_iosz,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
	return val;
}

void
envy_mt_write_4(struct envy_softc *sc, int reg, int val)
{
	bus_space_write_4(sc->mt_iot, sc->mt_ioh, reg, val);
	bus_space_barrier(sc->mt_iot, sc->mt_ioh, 0, sc->mt_iosz,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
}

int
envy_cci_read(struct envy_softc *sc, int index)
{
	envy_ccs_write(sc, ENVY_CCI_INDEX, index);
	return (envy_ccs_read(sc, ENVY_CCI_DATA));
}

void
envy_cci_write(struct envy_softc *sc, int index, int data)
{
	envy_ccs_write(sc, ENVY_CCI_INDEX, index);
	envy_ccs_write(sc, ENVY_CCI_DATA, data);
}

int
envy_gpio_getstate(struct envy_softc *sc)
{
	if (sc->isht) {
		return envy_ccs_read(sc, ENVY_CCS_GPIODATA0) |
		    (envy_ccs_read(sc, ENVY_CCS_GPIODATA1) << 8) |
		    (envy_ccs_read(sc, ENVY_CCS_GPIODATA2) << 16);
	} else
		return envy_cci_read(sc, ENVY_CCI_GPIODATA);
}

void
envy_gpio_setstate(struct envy_softc *sc, int reg)
{
	if (sc->isht) {
		envy_ccs_write(sc, ENVY_CCS_GPIODATA0, reg & 0xff);
		envy_ccs_write(sc, ENVY_CCS_GPIODATA1, (reg >> 8) & 0xff);
		envy_ccs_write(sc, ENVY_CCS_GPIODATA2, (reg >> 16) & 0xff);
	} else
		envy_cci_write(sc, ENVY_CCI_GPIODATA, reg);
}

int
envy_gpio_getmask(struct envy_softc *sc)
{
	if (sc->isht) {
		return envy_ccs_read(sc, ENVY_CCS_GPIOMASK0) |
		    (envy_ccs_read(sc, ENVY_CCS_GPIOMASK1) << 8) |
		    (envy_ccs_read(sc, ENVY_CCS_GPIOMASK2) << 16);
	} else
		return envy_cci_read(sc, ENVY_CCI_GPIOMASK);
}

void
envy_gpio_setmask(struct envy_softc *sc, int mask)
{
	if (sc->isht) {
		envy_ccs_write(sc, ENVY_CCS_GPIOMASK0, mask & 0xff);
		envy_ccs_write(sc, ENVY_CCS_GPIOMASK1, (mask >> 8) & 0xff);
		envy_ccs_write(sc, ENVY_CCS_GPIOMASK2, (mask >> 16) & 0xff);
	} else
		envy_cci_write(sc, ENVY_CCI_GPIOMASK, mask);
}

int
envy_gpio_getdir(struct envy_softc *sc)
{
	if (sc->isht) {
		return envy_ccs_read(sc, ENVY_CCS_GPIODIR0) |
		    (envy_ccs_read(sc, ENVY_CCS_GPIODIR1) << 8) |
		    (envy_ccs_read(sc, ENVY_CCS_GPIODIR2) << 16);
	} else
		return envy_cci_read(sc, ENVY_CCI_GPIODIR);
}

void
envy_gpio_setdir(struct envy_softc *sc, int dir)
{
	if (sc->isht) {
		envy_ccs_write(sc, ENVY_CCS_GPIODIR0, dir & 0xff);
		envy_ccs_write(sc, ENVY_CCS_GPIODIR1, (dir >> 8) & 0xff);
		envy_ccs_write(sc, ENVY_CCS_GPIODIR2, (dir >> 16) & 0xff);
	} else
		envy_cci_write(sc, ENVY_CCI_GPIODIR, dir);
}

void
envy_gpio_i2c_start_bit(struct envy_softc *sc, int sda, int scl)
{
	int reg;

	reg = envy_gpio_getstate(sc);
	reg |= (sda | scl);
	envy_gpio_setstate(sc, reg);
	delay(5);
	reg &= ~sda;
	envy_gpio_setstate(sc, reg);
	delay(4);
	reg &= ~scl;
	envy_gpio_setstate(sc, reg);
	delay(5);
}

void
envy_gpio_i2c_stop_bit(struct envy_softc *sc, int sda, int scl)
{
	int reg;

	reg = envy_gpio_getstate(sc);
	reg &= ~sda;
	reg |= scl;
	envy_gpio_setstate(sc, reg);
	delay(4);
	reg |= sda;
	envy_gpio_setstate(sc, reg);
}

void
envy_gpio_i2c_byte_out(struct envy_softc *sc, int sda, int scl, int val)
{
	int mask, reg;

	reg = envy_gpio_getstate(sc);

	for (mask = 0x80; mask != 0; mask >>= 1) {
		reg &= ~sda;
		reg |= (val & mask) ? sda : 0;
		envy_gpio_setstate(sc, reg);
		delay(1);
		reg |= scl;
		envy_gpio_setstate(sc, reg);
		delay(4);
		reg &= ~scl;
		envy_gpio_setstate(sc, reg);
		delay(5);
	}

	reg |= scl;
	envy_gpio_setstate(sc, reg);
	delay(4);
	reg &= ~scl;
	envy_gpio_setstate(sc, reg);
	delay(5);
}

void
envy_i2c_wait(struct envy_softc *sc)
{
	int timeout = 50, st;

	for (;;) {
		st = envy_ccs_read(sc, ENVY_I2C_CTL);
		if (!(st & ENVY_I2C_CTL_BUSY))
			break;
		if (timeout == 0) {
			printf("%s: i2c busy timeout\n", DEVNAME(sc));
			break;
		}
		delay(50);
		timeout--;
	}
}

int
envy_i2c_read(struct envy_softc *sc, int dev, int addr)
{
	envy_i2c_wait(sc);
	envy_ccs_write(sc, ENVY_I2C_ADDR, addr);
	envy_i2c_wait(sc);
	envy_ccs_write(sc, ENVY_I2C_DEV, dev << 1);
	envy_i2c_wait(sc);
	return envy_ccs_read(sc, ENVY_I2C_DATA);
}

void
envy_i2c_write(struct envy_softc *sc, int dev, int addr, int data)
{
	if (dev == 0x50) {
		printf("%s: writing on eeprom is evil...\n", DEVNAME(sc));
		return;
	}
	envy_i2c_wait(sc);
	envy_ccs_write(sc, ENVY_I2C_ADDR, addr);
	envy_i2c_wait(sc);
	envy_ccs_write(sc, ENVY_I2C_DATA, data);
	envy_i2c_wait(sc);
	envy_ccs_write(sc, ENVY_I2C_DEV, (dev << 1) | 1);
}

int
envy_codec_read(struct envy_softc *sc, int dev, int addr) {
	return sc->shadow[dev][addr];
}

void
envy_codec_write(struct envy_softc *sc, int dev, int addr, int data)
{
	DPRINTFN(2, "envy_codec_write: %d, %d, 0x%x\n", dev, addr, data);
	sc->shadow[dev][addr] = data;
	sc->card->codec_write(sc, dev, addr, data);
}

int
envy_eeprom_gpioxxx(struct envy_softc *sc, int addr)
{
	int val;

	val = sc->eeprom[addr];
	if (sc->isht) {
		val |= sc->eeprom[++addr] << 8;
		val |= sc->eeprom[++addr] << 16;
	}
	return val;
}

int
envy_ac97_wait(struct envy_softc *sc)
{
	int timeout = 50, st;

	for (;;) {
		st = envy_mt_read_1(sc, ENVY_MT_AC97_CMD);
		if ((st & ENVY_MT_AC97_READY) && !(st & ENVY_MT_AC97_CMD_MASK)) {
			st = 0;
			break;
		}
		if (timeout == 0) {
			st = -1;
			break;
		}
		delay(50);
		timeout--;
	}

	return (st);
}

int
envy_ac97_attach_codec(void *hdl, struct ac97_codec_if *codec_if)
{
	struct envy_softc *sc = hdl;

	sc->codec_if = codec_if;

	return (0);
}

int
envy_ac97_read_codec(void *hdl, u_int8_t reg, u_int16_t *result)
{
	struct envy_softc *sc = hdl;

	if (envy_ac97_wait(sc)) {
		printf("%s: envy_ac97_read_codec: timed out\n", DEVNAME(sc));
		return (-1);
	}

	envy_mt_write_1(sc, ENVY_MT_AC97_IDX, reg & 0x7f);
	envy_mt_write_1(sc, ENVY_MT_AC97_CMD,
	    ENVY_MT_AC97_CMD_RD);
	delay(50);

	if (envy_ac97_wait(sc)) {
		printf("%s: envy_ac97_read_codec: timed out\n", DEVNAME(sc));
		return (-1);
	}

	*result = envy_mt_read_2(sc, ENVY_MT_AC97_DATA);

	return (0);
}

int
envy_ac97_write_codec(void *hdl, u_int8_t reg, u_int16_t data)
{
	struct envy_softc *sc = hdl;

	if (envy_ac97_wait(sc)) {
		printf("%s: envy_ac97_write_codec: timed out\n", DEVNAME(sc));
		return (-1);
	}

	envy_mt_write_1(sc, ENVY_MT_AC97_IDX, reg & 0x7f);
	envy_mt_write_2(sc, ENVY_MT_AC97_DATA, data);
	envy_mt_write_1(sc, ENVY_MT_AC97_CMD,
	    ENVY_MT_AC97_CMD_WR);
	delay(50);

	return (0);
}

void
envy_ac97_reset_codec(void *hdl)
{
	struct envy_softc *sc = hdl;

	envy_mt_write_1(sc, ENVY_MT_AC97_CMD, ENVY_MT_AC97_CMD_RST);
	delay(50);
	envy_mt_write_1(sc, ENVY_MT_AC97_CMD, 0);
	delay(50);

	if (envy_ac97_wait(sc)) {
		printf("%s: envy_ac97_reset_codec: timed out\n", DEVNAME(sc));
	}

	return;
}

enum ac97_host_flags
envy_ac97_flags_codec(void *hdl)
{
	struct envy_softc *sc = hdl;

	return (sc->codec_flags);
}

void
envy_midi_wait(struct envy_softc *sc)
{
	int i, st;
	
	for (i = 100;; i--) {
		st = envy_ccs_read(sc, ENVY_CCS_MIDISTAT0);
		if (!(st & ENVY_MIDISTAT_OBUSY(sc)))
			break;
		if (i == 0) {
			printf("%s: midi wait timeout\n", DEVNAME(sc));
			break;
		}
		delay(10);
	}
}

void
envy_reset(struct envy_softc *sc)
{
	int i, reg;

	/*
	 * full reset
	 */
	envy_ccs_write(sc, ENVY_CTL, ENVY_CTL_RESET | ENVY_CTL_NATIVE);
	delay(200);
	envy_ccs_write(sc, ENVY_CTL, ENVY_CTL_NATIVE);
	delay(200);

	/*
	 * read EEPROM using i2c device or from a static array
	 */
	if (sc->card->eeprom == NULL) {
		for (i = 0; i < ENVY_EEPROM_MAXSZ; i++) {
			sc->eeprom[i] = envy_i2c_read(sc, ENVY_I2C_DEV_EEPROM, i);
		}
#ifdef ENVY_DEBUG
		printf("%s: eeprom: ", DEVNAME(sc));
		for (i = 0; i < ENVY_EEPROM_MAXSZ; i++) {
			printf(" %02x", (unsigned)sc->eeprom[i]);
		}
		printf("\n");
#endif
	} else
		memcpy(sc->eeprom, sc->card->eeprom, ENVY_EEPROM_MAXSZ);

	/*
	 * write EEPROM values to corresponding registers
	 */
	if (sc->isht) {
		envy_ccs_write(sc, ENVY_CCS_CONF,
		    sc->eeprom[ENVY_EEPROM_CONF]);
		envy_ccs_write(sc, ENVY_CCS_ACLINK,
		    sc->eeprom[ENVY_EEPROM_ACLINK]);
		envy_ccs_write(sc, ENVY_CCS_I2S,
		    sc->eeprom[ENVY_EEPROM_I2S]);
		envy_ccs_write(sc, ENVY_CCS_SPDIF,
		    sc->eeprom[ENVY_EEPROM_SPDIF]);
	} else {
		pci_conf_write(sc->pci_pc, sc->pci_tag, ENVY_CONF,
		    sc->eeprom[ENVY_EEPROM_CONF] |
		    (sc->eeprom[ENVY_EEPROM_ACLINK] << 8) |
		    (sc->eeprom[ENVY_EEPROM_I2S] << 16) |
		    (sc->eeprom[ENVY_EEPROM_SPDIF] << 24));
	}

	envy_gpio_setmask(sc, envy_eeprom_gpioxxx(sc, ENVY_EEPROM_GPIOMASK(sc)));
	envy_gpio_setdir(sc, envy_eeprom_gpioxxx(sc, ENVY_EEPROM_GPIODIR(sc)));
	envy_gpio_setstate(sc, envy_eeprom_gpioxxx(sc, ENVY_EEPROM_GPIOST(sc)));

	DPRINTF("%s: gpio_mask = %02x\n", DEVNAME(sc),
		envy_gpio_getmask(sc));
	DPRINTF("%s: gpio_dir = %02x\n", DEVNAME(sc),
		envy_gpio_getdir(sc));
	DPRINTF("%s: gpio_state = %02x\n", DEVNAME(sc),
		envy_gpio_getstate(sc));

	if (sc->isht) {
		/*
		 * set water marks so we get an interrupt for each byte
		 */
		envy_ccs_write(sc, ENVY_CCS_MIDIWAT, 1);
		envy_ccs_write(sc, ENVY_CCS_MIDIWAT, 1 | ENVY_CCS_MIDIWAT_RX);
	}

	/*
	 * switch to UART mode
	 */
	envy_ccs_write(sc, ENVY_CCS_MIDISTAT0, 0xff);
	envy_midi_wait(sc);
	envy_ccs_write(sc, ENVY_CCS_MIDISTAT0, ENVY_MIDISTAT_UART);
	envy_midi_wait(sc);
	if (!sc->isht)
		(void)envy_ccs_read(sc, ENVY_CCS_MIDIDATA0);

	/*
	 * clear all interrupts and unmask used ones
	 */
	envy_ccs_write(sc, ENVY_CCS_INTSTAT, 0xff);
	reg = ~ENVY_CCS_INT_MT;
	if (sc->midi_isopen)
		reg &= ~ENVY_CCS_INT_MIDI0;
	envy_ccs_write(sc, ENVY_CCS_INTMASK, ~ENVY_CCS_INT_MT);
	if (sc->isht) {
		envy_mt_write_1(sc, ENVY_MT_NSTREAM, 4 - sc->card->noch / 2);
		envy_mt_write_1(sc, ENVY_MT_IMASK, ~(ENVY_MT_IMASK_PDMA0 |
		    ENVY_MT_IMASK_RDMA0 | ENVY_MT_IMASK_ERR));
	}
	sc->iactive = 0;
	sc->oactive = 0;
	sc->card->init(sc);
}

int
envy_lineout_getsrc(struct envy_softc *sc, int out)
{
	int reg, shift, src;

	if (sc->isht) {
		reg = envy_mt_read_4(sc, ENVY_MT_HTSRC);
		DPRINTF("%s: outsrc=%x\n", DEVNAME(sc), reg);
		shift = 3 * (out / 2) + ((out & 1) ? 20 : 8);
		src = (reg >> shift) & ENVY_MT_HTSRC_MASK;
		if (src == ENVY_MT_HTSRC_DMA) {
			return ENVY_MIX_OUTSRC_DMA;
		} else {
			src -= ENVY_MT_HTSRC_LINE;
			return ENVY_MIX_OUTSRC_LINEIN + src;
		}
	}

	reg = envy_mt_read_2(sc, ENVY_MT_OUTSRC);
	DPRINTF("%s: outsrc=%x\n", DEVNAME(sc), reg);
	shift = (out  & 1) ? (out & ~1) + 8 : out;
	src = (reg >> shift) & 3;
	if (src == ENVY_MT_OUTSRC_DMA) {
		return ENVY_MIX_OUTSRC_DMA;
	} else if (src == ENVY_MT_OUTSRC_MON) {
		return ENVY_MIX_OUTSRC_MON;
	}
	reg = envy_mt_read_4(sc, ENVY_MT_INSEL);
	DPRINTF("%s: insel=%x\n", DEVNAME(sc), reg);
	reg = (reg >> (out * 4)) & 0xf;
	if (src == ENVY_MT_OUTSRC_LINE)
		return ENVY_MIX_OUTSRC_LINEIN + (reg & 7);
	else
		return ENVY_MIX_OUTSRC_SPDIN + (reg >> 3);
}

void
envy_lineout_setsrc(struct envy_softc *sc, int out, int src)
{
	int reg, shift, mask, sel;

	if (sc->isht) {
		if (src < ENVY_MIX_OUTSRC_SPDIN) {
			sel = ENVY_MT_HTSRC_LINE;
			sel += src;
		} else if (src < ENVY_MIX_OUTSRC_DMA) {
			sel = ENVY_MT_HTSRC_SPD;
			sel += src - ENVY_MIX_OUTSRC_SPDIN;
		} else {
			sel = ENVY_MT_HTSRC_DMA;
		}
		shift = 3 * (out / 2) + ((out & 1) ? 20 : 8);
		mask = ENVY_MT_HTSRC_MASK << shift;
		reg = envy_mt_read_4(sc, ENVY_MT_HTSRC);
		reg = (reg & ~mask) | (sel << shift);
		envy_mt_write_4(sc, ENVY_MT_HTSRC, reg);
		DPRINTF("%s: outsrc <- %x\n", DEVNAME(sc), reg);
		return;
	}

	if (src < ENVY_MIX_OUTSRC_DMA) {
		/*
		 * linein and spdin are used as output source so we
		 * must select the input source channel number
		 */
		if (src < ENVY_MIX_OUTSRC_SPDIN)
			sel = src - ENVY_MIX_OUTSRC_LINEIN;
		else
			sel = (src - ENVY_MIX_OUTSRC_SPDIN) << 3;

		shift = out * ENVY_MT_INSEL_BITS;
		mask = ENVY_MT_INSEL_MASK << shift;
		reg = envy_mt_read_4(sc, ENVY_MT_INSEL);
		reg = (reg & ~mask) | (sel << shift);
		envy_mt_write_4(sc, ENVY_MT_INSEL, reg);
		DPRINTF("%s: insel <- %x\n", DEVNAME(sc), reg);
	}

	/*
	 * set the lineout route register
	 */
	if (src < ENVY_MIX_OUTSRC_SPDIN) {
		sel = ENVY_MT_OUTSRC_LINE;
	} else if (src < ENVY_MIX_OUTSRC_DMA) {
		sel = ENVY_MT_OUTSRC_SPD;
	} else if (src == ENVY_MIX_OUTSRC_DMA) {
		sel = ENVY_MT_OUTSRC_DMA;
	} else {
		sel = ENVY_MT_OUTSRC_MON;
	}
	shift = (out  & 1) ? (out & ~1) + 8 : out;
	mask = ENVY_MT_OUTSRC_MASK << shift;
	reg = envy_mt_read_2(sc, ENVY_MT_OUTSRC);
	reg = (reg & ~mask) | (sel << shift);
	envy_mt_write_2(sc, ENVY_MT_OUTSRC, reg);
	DPRINTF("%s: outsrc <- %x\n", DEVNAME(sc), reg);
}


int
envy_spdout_getsrc(struct envy_softc *sc, int out)
{
	int reg, src, sel;

	reg = envy_mt_read_2(sc, ENVY_MT_SPDROUTE);
	DPRINTF("%s: spdroute=%x\n", DEVNAME(sc), reg);
	src = (out == 0) ? reg : reg >> 2;
	src &= ENVY_MT_SPDSRC_MASK;
	if (src == ENVY_MT_SPDSRC_DMA) {
		return ENVY_MIX_OUTSRC_DMA;
	} else if (src == ENVY_MT_SPDSRC_MON) {
		return ENVY_MIX_OUTSRC_MON;
	}

	sel = (out == 0) ? reg >> 8 : reg >> 12;
	sel &= ENVY_MT_SPDSEL_MASK;
	if (src == ENVY_MT_SPDSRC_LINE)
		return ENVY_MIX_OUTSRC_LINEIN + (sel & 7);
	else
		return ENVY_MIX_OUTSRC_SPDIN + (sel >> 3);
}

void
envy_spdout_setsrc(struct envy_softc *sc, int out, int src)
{
	int reg, shift, mask, sel;

	reg = envy_mt_read_2(sc, ENVY_MT_SPDROUTE);
	if (src < ENVY_MIX_OUTSRC_DMA) {
		/*
		 * linein and spdin are used as output source so we
		 * must select the input source channel number
		 */
		if (src < ENVY_MIX_OUTSRC_SPDIN)
			sel = src - ENVY_MIX_OUTSRC_LINEIN;
		else
			sel = (src - ENVY_MIX_OUTSRC_SPDIN) << 3;

		shift = 8 + out * ENVY_MT_SPDSEL_BITS;
		mask = ENVY_MT_SPDSEL_MASK << shift;
		reg = (reg & ~mask) | (sel << shift);
	}

	/*
	 * set the lineout route register
	 */
	if (src < ENVY_MIX_OUTSRC_SPDIN) {
		sel = ENVY_MT_OUTSRC_LINE;
	} else if (src < ENVY_MIX_OUTSRC_DMA) {
		sel = ENVY_MT_OUTSRC_SPD;
	} else if (src == ENVY_MIX_OUTSRC_DMA) {
		sel = ENVY_MT_OUTSRC_DMA;
	} else {
		sel = ENVY_MT_OUTSRC_MON;
	}
	shift = out * 2;
	mask = ENVY_MT_SPDSRC_MASK << shift;
	reg = (reg & ~mask) | (sel << shift);
	envy_mt_write_2(sc, ENVY_MT_SPDROUTE, reg);
	DPRINTF("%s: spdroute <- %x\n", DEVNAME(sc), reg);
}

void
envy_mon_getvol(struct envy_softc *sc, int idx, int ch, int *val)
{
	int reg;

	envy_mt_write_2(sc, ENVY_MT_MONIDX, idx);
	reg = envy_mt_read_1(sc, ENVY_MT_MONDATA + ch);
	*val = 0x7f - (reg & 0x7f);
}

void
envy_mon_setvol(struct envy_softc *sc, int idx, int ch, int val)
{
	int reg;

	envy_mt_write_2(sc, ENVY_MT_MONIDX, idx);
	reg = 0x7f - val;
	DPRINTF("%s: mon=%d/%d <- %d\n", DEVNAME(sc), reg, ch, val);
	envy_mt_write_1(sc, ENVY_MT_MONDATA + ch, reg);
}

int
envymatch(struct device *parent, void *match, void *aux)
{
	return pci_matchbyid((struct pci_attach_args *)aux, envy_matchids,
	    sizeof(envy_matchids) / sizeof(envy_matchids[0]));
}

void
envyattach(struct device *parent, struct device *self, void *aux)
{
	struct envy_softc *sc = (struct envy_softc *)self;
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	pci_intr_handle_t ih;
	const char *intrstr;
	int subid;

#if NMIDI > 0
	sc->midi_isopen = 0;
#endif
	sc->pci_tag = pa->pa_tag;
	sc->pci_pc = pa->pa_pc;
	sc->pci_dmat = pa->pa_dmat;
	sc->pci_ih = NULL;
	sc->ibuf.addr = sc->obuf.addr = NULL;
	sc->ccs_iosz = 0;
	sc->mt_iosz = 0;
	sc->isht = (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ICENSEMBLE_VT172x);

	if (pci_mapreg_map(pa, ENVY_CTL_BAR, PCI_MAPREG_TYPE_IO, 0,
		&sc->ccs_iot, &sc->ccs_ioh, NULL, &sc->ccs_iosz, 0)) {
		printf(": can't map ctl i/o space\n");
		sc->ccs_iosz = 0;
		return;
	}
	if (pci_mapreg_map(pa, ENVY_MT_BAR(sc->isht), PCI_MAPREG_TYPE_IO, 0,
		&sc->mt_iot, &sc->mt_ioh, NULL, &sc->mt_iosz, 0)) {
		printf(": can't map mt i/o space\n");
		sc->mt_iosz = 0;
		return;
	}
	if (pci_intr_map(pa, &ih)) {
		printf(": can't map interrupt\n");
	}
	intrstr = pci_intr_string(sc->pci_pc, ih);
	sc->pci_ih = pci_intr_establish(sc->pci_pc, ih, IPL_AUDIO | IPL_MPSAFE,
	    envy_intr, sc, sc->dev.dv_xname);
	if (sc->pci_ih == NULL) {
		printf(": can't establish interrupt");
		if (intrstr)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s\n", intrstr);
	subid = pci_conf_read(sc->pci_pc, sc->pci_tag, PCI_SUBVEND_0);
	sc->card = sc->isht ? envy_cards_ht : envy_cards;
	while (sc->card->subid != subid) {
		if (sc->card->subid == 0)
			break;
		sc->card++;
	}
	printf("%s: %s, %u inputs, %u outputs\n", DEVNAME(sc),
	    sc->card->name, sc->card->nich, sc->card->noch);
	envy_reset(sc);
	sc->audio = audio_attach_mi(&envy_hw_if, sc, &sc->dev);
#if NMIDI > 0
	if (sc->card->nmidi > 0 && (!sc->isht ||
		sc->eeprom[ENVY_EEPROM_CONF] & ENVY_CONF_MIDI)) {
		sc->midi = midi_attach_mi(&envy_midi_hw_if, sc, &sc->dev);
	}
#endif
}

int
envydetach(struct device *self, int flags)
{
	struct envy_softc *sc = (struct envy_softc *)self;

	if (sc->pci_ih != NULL) {
		pci_intr_disestablish(sc->pci_pc, sc->pci_ih);
		sc->pci_ih = NULL;
	}
	if (sc->ccs_iosz) {
		bus_space_unmap(sc->ccs_iot, sc->ccs_ioh, sc->ccs_iosz);
	}
	if (sc->mt_iosz) {
		bus_space_unmap(sc->mt_iot, sc->mt_ioh, sc->mt_iosz);
	}
	return 0;
}

int
envy_open(void *self, int flags)
{
	return 0;
}

void
envy_close(void *self)
{
}

void *
envy_allocm(void *self, int dir, size_t size, int type, int flags)
{
	struct envy_softc *sc = (struct envy_softc *)self;
	int err, basereg, wait;
	struct envy_buf *buf;
	bus_addr_t dma_addr;

	if (dir == AUMODE_RECORD) {
		buf = &sc->ibuf;
		basereg = ENVY_MT_RADDR;
	} else {
		buf = &sc->obuf;
		basereg = ENVY_MT_PADDR;
	}
	if (buf->addr != NULL) {
		DPRINTF("%s: multiple alloc, dir = %d\n", DEVNAME(sc), dir);
		return NULL;
	}
	buf->size = size;
	wait = (flags & M_NOWAIT) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK;

#define ENVY_ALIGN	4
#define ENVY_MAXADDR	((1 << 28) - 1)

	buf->addr = (caddr_t)uvm_km_kmemalloc_pla(kernel_map,
	    uvm.kernel_object, buf->size, 0, UVM_KMF_NOWAIT, 0,
	    (paddr_t)ENVY_MAXADDR, 0, 0, 1);
	if (buf->addr == NULL) {
		DPRINTF("%s: unable to alloc dma segment\n", DEVNAME(sc));
		goto err_ret;
	}
	err = bus_dmamap_create(sc->pci_dmat, buf->size, 1, buf->size, 0,
	    wait, &buf->map);
	if (err) {
		DPRINTF("%s: dmamap_create: failed %d\n", DEVNAME(sc), err);
		goto err_unmap;
	}
	err = bus_dmamap_load(sc->pci_dmat, buf->map, buf->addr,
	    buf->size, NULL, wait);
	if (err) {
		DPRINTF("%s: dmamap_load: failed %d\n", DEVNAME(sc), err);
		goto err_destroy;
	}
	dma_addr = buf->map->dm_segs[0].ds_addr;
	DPRINTF("%s: allocated %zd bytes dir=%d, ka=%p, da=%lx\n", DEVNAME(sc),
	    buf->size, dir, buf->addr, dma_addr);
	if (!sc->isht && (dma_addr & ~ENVY_MAXADDR)) {
		printf("%s: DMA address beyond 0x10000000\n", DEVNAME(sc));
		goto err_unload;
	}
	envy_mt_write_4(sc, basereg, dma_addr);
	return buf->addr;
 err_unload:
	bus_dmamap_unload(sc->pci_dmat, buf->map);
 err_destroy:
	bus_dmamap_destroy(sc->pci_dmat, buf->map);
 err_unmap:
	uvm_km_free(kernel_map, (vaddr_t)buf->addr, buf->size);
 err_ret:
	return NULL;
}

void
envy_freem(void *self, void *addr, int type)
{
	struct envy_buf *buf;
	struct envy_softc *sc = (struct envy_softc *)self;
	int dir;

	if (sc->ibuf.addr == addr) {
		buf = &sc->ibuf;
		dir = AUMODE_RECORD;
	} else if (sc->obuf.addr == addr) {
		buf = &sc->obuf;
		dir = AUMODE_PLAY;
	} else {
		DPRINTF("%s: no buf to free\n", DEVNAME(sc));
		return;
	}
	bus_dmamap_unload(sc->pci_dmat, buf->map);
	bus_dmamap_destroy(sc->pci_dmat, buf->map);
	uvm_km_free(kernel_map, (vaddr_t)&buf->addr, buf->size);
	buf->addr = NULL;
	DPRINTF("%s: freed buffer (mode=%d)\n", DEVNAME(sc), dir);
}

int
envy_set_params(void *self, int setmode, int usemode,
    struct audio_params *p, struct audio_params *r)
{
	struct envy_softc *sc = (struct envy_softc *)self;
	int i, rate, reg;

	if (setmode == 0)
		return 0;
	if (setmode == (AUMODE_PLAY | AUMODE_RECORD) &&
	    p->sample_rate != r->sample_rate) {
		DPRINTF("%s: play/rec rates mismatch\n", DEVNAME(sc));
		r->sample_rate = p->sample_rate;
	}
	rate = (setmode & AUMODE_PLAY) ? p->sample_rate : r->sample_rate;
	for (i = 0; envy_rates[i].rate < rate; i++) {
		if (envy_rates[i].rate == -1) {
			i--;
			DPRINTF("%s: rate: %d -> %d\n", DEVNAME(sc), rate, i);
			break;
		}
	}
	reg = envy_mt_read_1(sc, ENVY_MT_RATE);
	reg &= ~ENVY_MT_RATEMASK;
	reg |= envy_rates[i].reg;
	envy_mt_write_1(sc, ENVY_MT_RATE, reg);
	if (setmode & AUMODE_PLAY) {
		p->sample_rate = envy_rates[i].rate;
		p->encoding = AUDIO_ENCODING_SLINEAR_LE;
		p->precision = 24;
		p->bps = 4;
		p->msb = 1;
		p->channels = sc->isht ? sc->card->noch : ENVY_PCHANS;
	}
	if (setmode & AUMODE_RECORD) {
		r->sample_rate = envy_rates[i].rate;
		r->encoding = AUDIO_ENCODING_SLINEAR_LE;
		r->precision = 24;
		r->bps = 4;
		r->msb = 1;
		r->channels = sc->isht ? sc->card->nich : ENVY_RCHANS;
	}
	return 0;
}

int
envy_round_blocksize(void *self, int blksz)
{
	return (blksz + 0x1f) & ~0x1f;
}

size_t
envy_round_buffersize(void *self, int dir, size_t bufsz)
{
	return bufsz;
}

#ifdef ENVY_DEBUG
void
envy_pintr(struct envy_softc *sc)
{
	int i;

	if (sc->spurious > 0 || envydebug >= 2) {
		printf("%s: spurious = %u, start = %lld.%ld\n", 
			DEVNAME(sc), sc->spurious,
			(long long)sc->start_ts.tv_sec, sc->start_ts.tv_nsec);
		for (i = 0; i < sc->nintr; i++) {
			printf("%lld.%09ld: "
			    "active=%d/%d pos=%d/%d st=%x/%x, ctl=%x\n",
			    (long long)sc->intrs[i].ts.tv_sec,
			    sc->intrs[i].ts.tv_nsec,
			    sc->intrs[i].iactive,
			    sc->intrs[i].oactive,
			    sc->intrs[i].ipos,
			    sc->intrs[i].opos,
			    sc->intrs[i].st,
			    sc->intrs[i].mask,
			    sc->intrs[i].ctl);
		}
	}
}
#endif

int
envy_intr(void *self)
{
	struct envy_softc *sc = (struct envy_softc *)self;
	unsigned int reg, hwpos, cnt;
	int mintr, mstat, mdata;
	int st, err, ctl;
	int max;

	mtx_enter(&audio_lock);
	st = envy_mt_read_1(sc, ENVY_MT_INTR);
	mintr = envy_ccs_read(sc, ENVY_CCS_INTSTAT);
	if (!(st & ENVY_MT_INTR_ALL) && !(mintr & ENVY_CCS_INT_MIDI0)) {
		mtx_leave(&audio_lock);
		return 0;
	}
	if (st & ENVY_MT_INTR_ERR) {
		err = envy_mt_read_1(sc, ENVY_MT_ERR);
		envy_mt_write_1(sc, ENVY_MT_ERR, err);
	}
	envy_mt_write_1(sc, ENVY_MT_INTR, st);
	envy_ccs_write(sc, ENVY_CCS_INTSTAT, mintr);

#ifdef ENVY_DEBUG
	if (sc->nintr < ENVY_NINTR) {
		sc->intrs[sc->nintr].iactive = sc->iactive;
		sc->intrs[sc->nintr].oactive = sc->oactive;
		sc->intrs[sc->nintr].st = st;
		sc->intrs[sc->nintr].ipos = envy_mt_read_2(sc, ENVY_MT_RBUFSZ);
		sc->intrs[sc->nintr].opos = envy_mt_read_2(sc, ENVY_MT_PBUFSZ);
		sc->intrs[sc->nintr].ctl = envy_mt_read_1(sc, ENVY_MT_CTL);
		sc->intrs[sc->nintr].mask = envy_mt_read_1(sc, ENVY_MT_IMASK);
		nanouptime(&sc->intrs[sc->nintr].ts);
		sc->nintr++;
	}
#endif
	if (mintr & ENVY_CCS_INT_MIDI0) {
		for (max = 128; max > 0; max--) {
			mstat = envy_ccs_read(sc, ENVY_CCS_MIDISTAT0);
			if (mstat & ENVY_MIDISTAT_IEMPTY(sc))
				break;
			mdata = envy_ccs_read(sc, ENVY_CCS_MIDIDATA0);
#if NMIDI > 0
			if (sc->midi_in)
				sc->midi_in(sc->midi_arg, mdata);
#endif
		}
	}
	if (st & ENVY_MT_INTR_PACK) {
		if (sc->oactive) {
			reg = envy_mt_read_2(sc, ENVY_MT_PBUFSZ);
			hwpos = sc->obuf.bufsz - 4 * (reg + 1);
			if (hwpos >= sc->obuf.bufsz)
				hwpos -= sc->obuf.bufsz;
			DPRINTFN(2, "%s: play: reg = %u, pos: %u -> %u\n",
			    DEVNAME(sc), reg, sc->obuf.swpos, hwpos);
			cnt = 0;
			while (hwpos - sc->obuf.swpos >= sc->obuf.blksz) {
				sc->ointr(sc->oarg);
				sc->obuf.swpos += sc->obuf.blksz;
				if (sc->obuf.swpos == sc->obuf.bufsz)
					sc->obuf.swpos = 0;
				cnt++;
			}
			if (cnt != 1) {
				DPRINTFN(2, "%s: play: %u intrs\n",
				    DEVNAME(sc), cnt);
			}
		} else {
			ctl = envy_mt_read_1(sc, ENVY_MT_CTL);
			if (ctl & ENVY_MT_CTL_PSTART) {
				envy_mt_write_1(sc,
				    ENVY_MT_CTL, ctl & ~ENVY_MT_CTL_PSTART);
				st &= ~ENVY_MT_INTR_PACK;
				sc->obusy = 0;
				wakeup(&sc->obusy);
			}
#ifdef ENVY_DEBUG
			else
				sc->spurious++;
#endif
		}
	}
	if (st & ENVY_MT_INTR_RACK) {
		if (sc->iactive) {
			reg = envy_mt_read_2(sc, ENVY_MT_RBUFSZ);
			hwpos = sc->ibuf.bufsz - 4 * (reg + 1);
			if (hwpos >= sc->ibuf.bufsz)
				hwpos -= sc->ibuf.bufsz;
			DPRINTFN(2, "%s: rec: reg = %u, pos: %u -> %u\n",
			    DEVNAME(sc), reg, sc->ibuf.swpos, hwpos);
			cnt = 0;
			while (hwpos - sc->ibuf.swpos >= sc->ibuf.blksz) {
				sc->iintr(sc->iarg);
				sc->ibuf.swpos += sc->ibuf.blksz;
				if (sc->ibuf.swpos == sc->ibuf.bufsz)
					sc->ibuf.swpos = 0;
				cnt++;
			}
			if (cnt != 1) {
				DPRINTFN(2, "%s: rec: %u intrs\n",
				    DEVNAME(sc), cnt);
			}
		} else {
			ctl = envy_mt_read_1(sc, ENVY_MT_CTL);
			if (ctl & ENVY_MT_CTL_RSTART(sc)) {
				envy_mt_write_1(sc,
				    ENVY_MT_CTL, ctl & ~ENVY_MT_CTL_RSTART(sc));
				st &= ~ENVY_MT_INTR_RACK;
				sc->ibusy = 0;
				wakeup(&sc->ibusy);
			}
#ifdef ENVY_DEBUG
			else
				sc->spurious++;
#endif
		}
	}
	mtx_leave(&audio_lock);
	return 1;
}

int
envy_trigger_output(void *self, void *start, void *end, int blksz,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct envy_softc *sc = (struct envy_softc *)self;
	size_t bufsz;
	int st;

	bufsz = (char *)end - (char *)start;
#ifdef ENVY_DEBUG
	if (blksz % (sc->isht ? sc->card->noch * 4 : ENVY_PFRAME_SIZE) != 0) {
		printf("%s: %d: bad output blksz\n", DEVNAME(sc), blksz);
		return EINVAL;
	}
	if (bufsz % blksz) {
		printf("%s: %ld: bad output bufsz\n", DEVNAME(sc), bufsz);
		return EINVAL;
	}
#endif
	mtx_enter(&audio_lock);
	envy_mt_write_2(sc, ENVY_MT_PBUFSZ, bufsz / 4 - 1);
	envy_mt_write_2(sc, ENVY_MT_PBLKSZ(sc), blksz / 4 - 1);

#ifdef ENVY_DEBUG
	if (!sc->iactive) {
		sc->nintr = 0;
		sc->spurious = 0;
		nanouptime(&sc->start_ts);
	}
#endif
	sc->obuf.bufsz = bufsz;
	sc->obuf.blksz = blksz;
	sc->obuf.swpos = 0;
	sc->ointr = intr;
	sc->oarg = arg;
	sc->oactive = 1;
	sc->obusy = 1;
	st = ENVY_MT_INTR_PACK;
	envy_mt_write_1(sc, ENVY_MT_INTR, st);
	st = envy_mt_read_1(sc, ENVY_MT_CTL);
	st |= ENVY_MT_CTL_PSTART;
	envy_mt_write_1(sc, ENVY_MT_CTL, st);
	mtx_leave(&audio_lock);
	return 0;
}

int
envy_trigger_input(void *self, void *start, void *end, int blksz,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct envy_softc *sc = (struct envy_softc *)self;
	size_t bufsz;
	int st;

	bufsz = (char *)end - (char *)start;
#ifdef ENVY_DEBUG
	if (blksz % (sc->isht ? sc->card->nich * 4 : ENVY_RFRAME_SIZE) != 0) {
		printf("%s: %d: bad input blksz\n", DEVNAME(sc), blksz);
		return EINVAL;
	}
	if (bufsz % blksz != 0) {
		printf("%s: %ld: bad input bufsz\n", DEVNAME(sc), bufsz);
		return EINVAL;
	}
#endif
	mtx_enter(&audio_lock);
	envy_mt_write_2(sc, ENVY_MT_RBUFSZ, bufsz / 4 - 1);
	envy_mt_write_2(sc, ENVY_MT_RBLKSZ, blksz / 4 - 1);

#ifdef ENVY_DEBUG
	if (!sc->oactive) {
		sc->nintr = 0;
		sc->spurious = 0;
		nanouptime(&sc->start_ts);
	}
#endif
	sc->ibuf.bufsz = bufsz;
	sc->ibuf.blksz = blksz;
	sc->ibuf.swpos = 0;
	sc->iintr = intr;
	sc->iarg = arg;
	sc->iactive = 1;
	sc->ibusy = 1;
	st = ENVY_MT_INTR_RACK;
	envy_mt_write_1(sc, ENVY_MT_INTR, st);
	st = envy_mt_read_1(sc, ENVY_MT_CTL);
	st |= ENVY_MT_CTL_RSTART(sc);
	envy_mt_write_1(sc, ENVY_MT_CTL, st);
	mtx_leave(&audio_lock);
	return 0;
}

int
envy_halt_output(void *self)
{
	struct envy_softc *sc = (struct envy_softc *)self;
	int err;

	mtx_enter(&audio_lock);
	sc->oactive = 0;
	if (sc->obusy) {
		err = msleep(&sc->obusy, &audio_lock, PWAIT, "envyobus", 4 * hz);
		if (err)
			printf("%s: output DMA halt timeout\n", DEVNAME(sc));
	}
#ifdef ENVY_DEBUG
	if (!sc->iactive)
		envy_pintr(sc);
#endif
	mtx_leave(&audio_lock);
	return 0;
}

int
envy_halt_input(void *self)
{
	struct envy_softc *sc = (struct envy_softc *)self;
	int err;

	mtx_enter(&audio_lock);
	sc->iactive = 0;
	if (sc->ibusy) {
		err = msleep(&sc->ibusy, &audio_lock, PWAIT, "envyibus", 4 * hz); 
		if (err)
			printf("%s: input DMA halt timeout\n", DEVNAME(sc));
	}
#ifdef ENVY_DEBUG
	if (!sc->oactive)
		envy_pintr(sc);
#endif
	mtx_leave(&audio_lock);
	return 0;
}

int
envy_query_devinfo(void *self, struct mixer_devinfo *dev)
{
	struct envy_softc *sc = (struct envy_softc *)self;
	int i, n, idx, ndev;
	char *classes[] = {
		AudioCinputs, AudioCoutputs, AudioCmonitor
	};

	if (sc->isac97)
		return (sc->codec_if->vtbl->query_devinfo(sc->codec_if, dev));

	if (dev->index < 0)
		return ENXIO;

	idx = dev->index;
	ndev = ENVY_MIX_NCLASS;
	dev->prev = dev->next = AUDIO_MIXER_LAST;

	/*
	 * classes
	 */
	if (idx < ndev) {
		dev->type = AUDIO_MIXER_CLASS;
		dev->mixer_class = idx;
		strlcpy(dev->label.name, classes[idx], MAX_AUDIO_DEV_LEN);
		return 0;
	}
	idx -= ndev;

	/*
	 * output.lineX_source
	 */
	ndev = sc->card->noch;
	if (idx < ndev) {
		n = 0;
		dev->type = AUDIO_MIXER_ENUM;
		dev->mixer_class = ENVY_MIX_CLASSOUT;
		for (i = 0; i < sc->card->nich; i++) {
			dev->un.e.member[n].ord = n;
			snprintf(dev->un.e.member[n++].label.name,
			    MAX_AUDIO_DEV_LEN, AudioNline "-%d", i);
		}
		dev->un.e.member[n].ord = n;
		snprintf(dev->un.e.member[n++].label.name,
			 MAX_AUDIO_DEV_LEN, "play-%d", idx);
		if (!sc->isht && idx < 2) {
			dev->un.e.member[n].ord = n;
			snprintf(dev->un.e.member[n++].label.name,
			    MAX_AUDIO_DEV_LEN, "mon-%d", idx);
		}
		snprintf(dev->label.name, MAX_AUDIO_DEV_LEN,
		    AudioNline "-%d_" AudioNsource, idx);
		dev->un.s.num_mem = n;
		return 0;
	}
	idx -= ndev;

	/*
	 * envy monitor level
	 */
	ndev = sc->isht ? 0 : ENVY_MIX_NMONITOR;
	if (idx < ndev) {
		dev->type = AUDIO_MIXER_VALUE;
		dev->mixer_class = ENVY_MIX_CLASSMON;
		dev->un.v.delta = 2;
		dev->un.v.num_channels = 1;
		snprintf(dev->label.name, MAX_AUDIO_DEV_LEN,
			 "%s-%d", idx < 10 ? "play" : "rec", idx % 10);
		strlcpy(dev->un.v.units.name, AudioNvolume, MAX_AUDIO_DEV_LEN);
		return 0;
	}
	idx -= ndev;

	/*
	 * inputs.xxx
	 */
	ndev = sc->card->adc->ndev(sc);
	if (idx < ndev) {
		sc->card->adc->devinfo(sc, dev, idx);
		return 0;
	}
	idx -= ndev;

	/*
	 * outputs.xxx
	 */
	ndev = sc->card->dac->ndev(sc);
	if (idx < ndev) {
		sc->card->dac->devinfo(sc, dev, idx);
		return 0;
	}
	return ENXIO;
}

int
envy_get_port(void *self, struct mixer_ctrl *ctl)
{
	struct envy_softc *sc = (struct envy_softc *)self;
	int val, idx, ndev;

	if (sc->isac97)
		return (sc->codec_if->vtbl->mixer_get_port(sc->codec_if, ctl));

	if (ctl->dev < ENVY_MIX_NCLASS) {
		return EINVAL;
	}

	idx = ctl->dev - ENVY_MIX_NCLASS;
	ndev = sc->card->noch;
	if (idx < ndev) {
		ctl->un.ord = envy_lineout_getsrc(sc, idx);
		if (ctl->un.ord >= ENVY_MIX_NOUTSRC)
			ctl->un.ord -= ENVY_MIX_NOUTSRC - sc->card->nich;
		return 0;
	}
	idx -= ndev;
	ndev = sc->isht ? 0 : ENVY_MIX_NMONITOR;
	if (idx < ndev) {
		envy_mon_getvol(sc, idx / 2, idx % 2, &val);
		ctl->un.value.num_channels = 1;
		ctl->un.value.level[0] = 2 * val;
		return 0;
	}
	idx -= ndev;
	ndev = sc->card->adc->ndev(sc);
	if (idx < ndev) {
		sc->card->adc->get(sc, ctl, idx);
		return 0;
	}
	idx -= ndev;
	ndev = sc->card->dac->ndev(sc);
	if (idx < ndev) {
		sc->card->dac->get(sc, ctl, idx);
		return 0;
	}
	return ENXIO;
}

int
envy_set_port(void *self, struct mixer_ctrl *ctl)
{
	struct envy_softc *sc = (struct envy_softc *)self;
	int maxsrc, val, idx, ndev;

	if (sc->isac97)
		return (sc->codec_if->vtbl->mixer_set_port(sc->codec_if, ctl));

	if (ctl->dev < ENVY_MIX_NCLASS) {
		return EINVAL;
	}

	idx = ctl->dev - ENVY_MIX_NCLASS;
	ndev = sc->card->noch;
	if (idx < ndev) {
		maxsrc = sc->card->nich + 1;
		if (idx < 2)
			maxsrc++;
		if (ctl->un.ord < 0 || ctl->un.ord >= maxsrc)
			return EINVAL;
		if (ctl->un.ord >= sc->card->nich)
			ctl->un.ord += ENVY_MIX_NOUTSRC - sc->card->nich;
		envy_lineout_setsrc(sc, idx, ctl->un.ord);
		return 0;
	}
	idx -= ndev;
	ndev = sc->isht ? 0 : ENVY_MIX_NMONITOR;
	if (idx < ndev) {
		if (ctl->un.value.num_channels != 1) {
			return EINVAL;
		}
		val = ctl->un.value.level[0] / 2;
		envy_mon_setvol(sc, idx / 2, idx % 2, val);
		return 0;
	}
	idx -= ndev;
	ndev = sc->card->adc->ndev(sc);
	if (idx < ndev)
		return sc->card->adc->set(sc, ctl, idx);
	idx -= ndev;
	ndev = sc->card->dac->ndev(sc);
	if (idx < ndev)
		return sc->card->dac->set(sc, ctl, idx);
	return ENXIO;
}

int
envy_get_props(void *self)
{
	return AUDIO_PROP_FULLDUPLEX | AUDIO_PROP_INDEPENDENT;
}

#if NMIDI > 0
int
envy_midi_open(void *self, int flags,
    void (*in)(void *, int),
    void (*out)(void *),
    void *arg)
{
	struct envy_softc *sc = (struct envy_softc *)self;
	unsigned int i, reg;

	/* discard pending data */
	for (i = 0; i < 128; i++) {
		reg = envy_ccs_read(sc, ENVY_CCS_MIDISTAT0);
		if (reg & ENVY_MIDISTAT_IEMPTY(sc))
			break;
		(void)envy_ccs_read(sc, ENVY_CCS_MIDIDATA0);
	}
#ifdef ENVY_DEBUG
	if (i > 0)
		DPRINTF("%s: midi: discarded %u bytes\n", DEVNAME(sc), i);
#endif

	/* clear pending midi interrupt */
	envy_ccs_write(sc, ENVY_CCS_INTSTAT, ENVY_CCS_INT_MIDI0);

	/* interrupts are disabled, it safe to manipulate these */
	sc->midi_in = in;
	sc->midi_out = out;
	sc->midi_arg = arg;
	sc->midi_isopen = 1;

	/* enable interrupts */
	reg = envy_ccs_read(sc, ENVY_CCS_INTMASK);
	reg &= ~ENVY_CCS_INT_MIDI0;
	envy_ccs_write(sc, ENVY_CCS_INTMASK, reg);
	return 0;
}

void
envy_midi_close(void *self)
{
	struct envy_softc *sc = (struct envy_softc *)self;
	unsigned int reg;

	/* wait for output fifo to drain */
	tsleep(sc, PWAIT, "envymid", hz / 10);

	/* disable interrupts */
	reg = envy_ccs_read(sc, ENVY_CCS_INTMASK);
	reg |= ENVY_CCS_INT_MIDI0;
	envy_ccs_write(sc, ENVY_CCS_INTMASK, reg);

	/* interrupts are disabled, it safe to manipulate these */
	sc->midi_in = NULL;
	sc->midi_out = NULL;
	sc->midi_isopen = 0;
}

int
envy_midi_output(void *self, int data)
{
	struct envy_softc *sc = (struct envy_softc *)self;
	int st;
	
	st = envy_ccs_read(sc, ENVY_CCS_MIDISTAT0);
	if (st & ENVY_MIDISTAT_OBUSY(sc))
		return 0;
	envy_ccs_write(sc, ENVY_CCS_MIDIDATA0, data);
	return 1;
}

void
envy_midi_getinfo(void *self, struct midi_info *mi)
{
	mi->props = MIDI_PROP_CAN_INPUT;
	mi->name = "Envy24 MIDI UART";
}
#endif
@


1.69
log
@Remove unused variable. From Michael W. Bombardieri <mb at ii.net>.
Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.68 2016/09/19 06:46:44 ratchov Exp $	*/
d1855 1
d1863 1
@


1.68
log
@Remove unused getdev() audio driver functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.67 2016/09/14 06:12:19 ratchov Exp $	*/
a1034 2
	int val;

d1036 1
a1036 2
	val = envy_ccs_read(sc, ENVY_CCI_DATA);
	return val;
@


1.67
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.65 2015/08/28 16:21:41 ratchov Exp $	*/
a110 1
int envy_getdev(void *, struct audio_device *);
a190 1
	envy_getdev,		/* getdev */
a2165 11
	return 0;
}

int
envy_getdev(void *self, struct audio_device *dev)
{
	struct envy_softc *sc = (struct envy_softc *)self;

	strlcpy(dev->name, sc->isht ? "Envy24HT" : "Envy24", MAX_AUDIO_DEV_LEN);
	strlcpy(dev->version, "-", MAX_AUDIO_DEV_LEN);
	strlcpy(dev->config, sc->card->name, MAX_AUDIO_DEV_LEN);
@


1.66
log
@Add the number of midi ports to the card description, and use it to
prevent cards with no midi connectors from attaching midi(4) devices.
@
text
@a100 1
int envy_query_encoding(void *, struct audio_encoding *);
a181 2
	NULL,			/* drain */
	envy_query_encoding,	/* query_encoding */
a199 1
	NULL,			/* mappage */
d202 1
a202 2
	envy_trigger_input,	/* trigger_input */
	NULL
a1830 15
}

int
envy_query_encoding(void *self, struct audio_encoding *enc)
{
	if (enc->index == 0) {
		strlcpy(enc->name, AudioEslinear_le, sizeof(enc->name));
		enc->encoding = AUDIO_ENCODING_SLINEAR_LE;
		enc->precision = 24;
		enc->bps = 4;
		enc->msb = 1;
		enc->flags = 0;
		return 0;
	}
	return EINVAL;
@


1.65
log
@Set the midi_isopen flag to zero before the chip is reset, as the flag
is used to determine the interrupt mask. Currently this doesn't matter,
but once suspend/resume works, this will matter.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.64 2015/08/28 16:15:39 ratchov Exp $	*/
d269 1
a269 1
		8, &ak4524_adc, 8, &ak4524_dac,
d276 1
a276 1
		4, &ak4524_adc, 4, &ak4524_dac,
d284 1
a284 1
		4, &ak4524_adc, 4, &ak4524_dac,
d291 1
a291 1
		8, &ak4524_adc, 8, &ak4524_dac,
d298 1
a298 1
		2, &ak4524_adc, 2, &ak4524_dac,
d305 1
a305 1
		2, &ak4524_adc, 2, &ak4524_dac,
d312 1
a312 1
		8, &unkenvy_codec, 8, &unkenvy_codec,
d320 1
a320 1
		2, &unkenvy_codec, 2, &ak4358_dac,
d327 1
a327 1
		2, &unkenvy_codec, 2, &ak4358_dac,
d333 1
a333 1
		2, &ak5365_adc, 6, &ak4358_dac,
d339 1
a339 1
		2, &unkenvy_codec, 6, &unkenvy_codec,
d345 1
a345 1
		2, &unkenvy_codec, 6, &unkenvy_codec,
d351 1
a351 1
		2, &unkenvy_codec, 8, &unkenvy_codec,
d1715 2
a1716 1
	if (!sc->isht || sc->eeprom[ENVY_EEPROM_CONF] & ENVY_CONF_MIDI) {
@


1.64
log
@remove forgotten debug printf in envy_midi_close
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.63 2015/08/28 15:50:18 ratchov Exp $	*/
d1665 3
a1714 1
	sc->midi_isopen = 0;
@


1.63
log
@Disable interrupts while the midi uart is not in use. Avoids generating
unused interrupts when a chatty peripheral is connected but is not
used.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.62 2015/08/28 13:51:22 ratchov Exp $	*/
a2446 1
	printf("envy: midi closed\n");
@


1.62
log
@Fix support of M-Audio Delta 44 cards that use different GPIO pins,
than other Delta cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.61 2015/07/29 21:10:50 ratchov Exp $	*/
d1372 1
a1372 1
	int i;
d1452 4
a1455 2
	envy_ccs_write(sc, ENVY_CCS_INTMASK,
	    ~(ENVY_CCS_INT_MT | ENVY_CCS_INT_MIDI0));
d1712 2
a1713 1
	if (!sc->isht || sc->eeprom[ENVY_EEPROM_CONF] & ENVY_CONF_MIDI)
d1715 1
a1716 1

d2399 16
d2416 1
a2416 1
	mtx_enter(&audio_lock);
d2420 6
a2425 1
	mtx_leave(&audio_lock);
d2433 1
d2435 1
d2437 7
a2443 1
	mtx_enter(&audio_lock);
d2446 2
a2447 1
	mtx_leave(&audio_lock);
@


1.61
log
@Use DMA pointer determine the number of times the audio(4) layer has
to advance in time. This is needed to properly recover, when
interrupts are blocked for too long. Fixes permanent distortion on MP
systems.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.60 2015/06/25 06:43:46 ratchov Exp $	*/
d281 1
a361 8
/*
 * GPIO pin numbers
 */
#define DELTA_GPIO_CLK		0x2
#define DELTA_GPIO_DOUT		0x8
#define DELTA_GPIO_CSMASK	0x70
#define DELTA_GPIO_CS(dev)	((dev) << 4)

d386 16
d404 2
a405 2
	reg &= ~DELTA_GPIO_CSMASK;
	reg |=  DELTA_GPIO_CS(dev);
d411 2
a412 2
		reg &= ~(DELTA_GPIO_CLK | DELTA_GPIO_DOUT);
		reg |= (bits & 0x8000) ? DELTA_GPIO_DOUT : 0;
d416 1
a416 1
		reg |= DELTA_GPIO_CLK;
d422 1
a422 1
	reg |= DELTA_GPIO_CSMASK;
@


1.60
log
@Reimplement the audio driver in a simpler way, removing unused/unusable
functionality. Same API and ABI except for the removed bits and no
behaviour change for programs using libsndio. With help from armani@@
and mpi@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.59 2015/03/14 03:38:48 jsg Exp $	*/
d1924 1
d1969 20
a1988 3
		if (sc->oactive)
			sc->ointr(sc->oarg);
		else {
d2004 20
a2023 3
		if (sc->iactive)
			sc->iintr(sc->iarg);
		else {
d2072 3
d2118 3
@


1.59
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.58 2014/05/29 20:40:26 ratchov Exp $	*/
d1884 1
a1884 21
	struct envy_softc *sc = (struct envy_softc *)self;
	int mul, pmult, rmult;

	/*
	 * XXX: audio(4) layer doesn't round to the sample size
	 * until it's fixed, roll our own rounding
	 */

	pmult = (sc->isht ? sc->card->noch : ENVY_PCHANS);
	if (pmult == 0)
		pmult = 1;
	rmult = (sc->isht ? sc->card->nich : ENVY_RCHANS);
	if (rmult == 0)
		rmult = 1;
	mul = pmult * rmult;
	while ((mul & 0x1f) != 0)
		mul <<= 1;
	blksz -= blksz % mul;
	if (blksz == 0)
		blksz = mul;
	return blksz;
@


1.58
log
@Use the same convention for mixer control names as azalia.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.57 2014/05/17 12:23:46 ratchov Exp $	*/
a32 1
#include <sys/ioctl.h>
@


1.57
log
@unbreak build with AUDIO_DEBUG: use %lx for bus_addr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.56 2013/05/24 07:58:46 ratchov Exp $	*/
d726 1
a726 1
	    AudioNline "%d", idx);
d775 1
a775 1
		    AudioNline "%d", idx);
d790 1
a790 1
		    AudioNmute "%d-%d", 2 * idx, 2 * idx + 1);
d851 1
a851 1
	snprintf(dev->label.name, MAX_AUDIO_DEV_LEN, AudioNline "%d", idx);
d899 1
a899 1
		    AudioNline "%d", idx);
d908 1
a908 1
			    MAX_AUDIO_DEV_LEN, AudioNline "%d", i);
d2208 1
a2208 1
			    MAX_AUDIO_DEV_LEN, AudioNline "%d", i);
d2212 1
a2212 1
			 MAX_AUDIO_DEV_LEN, "play%d", idx);
d2216 1
a2216 1
			    MAX_AUDIO_DEV_LEN, "mon%d", idx);
d2219 1
a2219 1
		    "line%u_" AudioNsource, idx);
d2235 1
a2235 1
			 "%s%d", idx < 10 ? "play" : "rec", idx % 10);
@


1.56
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.55 2013/05/15 08:29:24 ratchov Exp $	*/
d1782 1
a1782 1
	DPRINTF("%s: allocated %zd bytes dir=%d, ka=%p, da=%p\n", DEVNAME(sc),
@


1.55
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.54 2013/04/22 15:10:55 deraadt Exp $	*/
d1680 1
a1680 1
	sc->pci_ih = pci_intr_establish(sc->pci_pc, ih, IPL_AUDIO,
@


1.54
log
@handle long long time_t in debug code
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.53 2013/03/14 08:14:47 ratchov Exp $	*/
d1949 1
d1952 2
a1953 1
	if (!(st & ENVY_MT_INTR_ALL) && !(mintr & ENVY_CCS_INT_MIDI0))
d1955 1
d2024 1
d2034 1
a2034 1
	int s, st;
d2047 1
a2047 1
	s = splaudio();
d2067 1
a2067 1
	splx(s);
d2077 1
a2077 1
	int s, st;
d2090 1
a2090 1
	s = splaudio();
d2110 1
a2110 1
	splx(s);
d2118 1
a2118 1
	int s, err;
d2120 1
a2120 1
	s = splaudio();
d2123 1
a2123 1
		err = tsleep(&sc->obusy, PWAIT, "envyobus", 4 * hz); 
a2126 1
	splx(s);
d2131 1
d2139 1
a2139 1
	int s, err;
d2141 1
a2141 1
	s = splaudio();
d2144 1
a2144 1
		err = tsleep(&sc->ibusy, PWAIT, "envyibus", 4 * hz); 
d2152 1
a2152 1
	splx(s);
a2366 1
	int s;
d2368 1
a2368 1
	s = splaudio();
d2372 1
a2372 1
	splx(s);
a2379 1
	int s;
d2382 1
a2382 1
	s = splaudio();
d2385 1
a2385 1
	splx(s);
@


1.53
log
@add macros for ap192k cards, no behavior change
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.52 2013/02/15 14:26:24 ratchov Exp $	*/
d1921 1
a1921 1
		printf("%s: spurious = %u, start = %u.%ld\n", 
d1923 1
a1923 1
			sc->start_ts.tv_sec, sc->start_ts.tv_nsec);
d1925 1
a1925 1
			printf("%u.%09ld: "
d1927 1
a1927 1
			    sc->intrs[i].ts.tv_sec,
@


1.52
log
@Use uvm_km_kmemalloc_pla() to allocate dma memory below 2^28 limit,
allowing ice1712-based cards to work on amd64.
With help from kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.51 2012/03/30 08:18:19 ratchov Exp $	*/
d431 2
d434 1
d449 1
a449 1
	/* ADC */
d452 2
a453 1
	reg &= ~AP192K_GPIO_ADC_PWR;
@


1.51
log
@If the MIDI UART is not ready for output, don't spin at IPL_CLOCK;
just return and make the midi(4) driver retry later. UART buffers
are large enough for this, except eap(4) which uses interrupts for
output.
help from and ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.50 2011/04/27 07:01:33 ratchov Exp $	*/
d45 1
d1737 1
a1737 1
	int err, rsegs, basereg, wait;
d1756 1
a1756 1
#define ENVY_BOUNDARY	(1 << 28)
d1758 5
a1762 4
	err = bus_dmamem_alloc(sc->pci_dmat, buf->size, ENVY_ALIGN,
	    sc->isht ? 0 : ENVY_BOUNDARY, &buf->seg, 1, &rsegs, wait);
	if (err) {
		DPRINTF("%s: dmamem_alloc: failed %d\n", DEVNAME(sc), err);
a1764 6
	err = bus_dmamem_map(sc->pci_dmat, &buf->seg, rsegs, buf->size,
	    &buf->addr, wait | BUS_DMA_COHERENT);
	if (err) {
		DPRINTF("%s: dmamem_map: failed %d\n", DEVNAME(sc), err);
		goto err_free;
	}
d1780 1
a1780 1
	if (!sc->isht && (dma_addr & ~(ENVY_BOUNDARY - 1))) {
d1791 1
a1791 3
	bus_dmamem_unmap(sc->pci_dmat, buf->addr, buf->size);
 err_free:
	bus_dmamem_free(sc->pci_dmat, &buf->seg, 1);
d1815 1
a1815 2
	bus_dmamem_unmap(sc->pci_dmat, buf->addr, buf->size);
	bus_dmamem_free(sc->pci_dmat, &buf->seg, 1);
@


1.50
log
@fix the interrupt handler in the case when the interrupt is shared
with other pci devices. Ignore the interrupt (and return 0) if neither
of the events that make the handler do actual work are set.

hints from jakemsr and dlg, explained by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.49 2010/12/22 09:54:27 jakemsr Exp $	*/
d2393 1
d2395 3
a2397 1
	envy_midi_wait(sc);
d2399 1
a2399 1
	return 0;
@


1.49
log
@* recognize/support the Dynex DX-SC51 in envy(4)
* allow ac97(4) flags to be set in envy(4), if there is an ac97 codec
* configure the vt1616 codec on the Dynex DX-SC51 for multi-channel
  operation

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.48 2010/10/30 21:16:58 ratchov Exp $	*/
d1954 1
a1954 1
	if (st == 0 && mintr == 0)
d1956 6
a1975 1
	envy_ccs_write(sc, ENVY_CCS_INTSTAT, mintr);
a1994 2
				    ENVY_MT_INTR, ENVY_MT_INTR_PACK);
				envy_mt_write_1(sc,
a2012 2
				    ENVY_MT_INTR, ENVY_MT_INTR_RACK);
				envy_mt_write_1(sc,
a2023 5
	if (sc->isht && (st & ENVY_MT_INTR_ERR)) {
		err = envy_mt_read_1(sc, ENVY_MT_ERR);
		envy_mt_write_1(sc, ENVY_MT_ERR, err);
	}
	envy_mt_write_1(sc, ENVY_MT_INTR, st);
@


1.48
log
@tweak gpio pins of julia cards to select the correct multiplier for
the ADC frequency. Fixes high frequencies being removed (probably
ADC running at half the frequency and samples being duplicated).
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.47 2010/10/08 19:26:32 ratchov Exp $	*/
d143 2
a144 1
void tremor51_init(struct envy_softc *);
d339 7
a345 1
		tremor51_init,
d629 1
a629 1
 * VIA Tremor 5.1 specific code
d633 1
a633 1
tremor51_init(struct envy_softc *sc)
a641 1
	sc->codec_flags = 0;
d645 11
@


1.47
log
@Call bus_space_barrier() after each read and write, since this
driver was developed with the assumption that all operations are
ordered.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.42 2010/10/04 09:32:43 ratchov Exp $	*/
d245 2
a246 2
	0x9f, 0xff, 0x7f,
	0x60, 0x00, 0x00
@


1.46
log
@encoding of envy is little endian, not native endian, probably fixes envy
on big endian archs
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.45 2010/10/08 18:46:42 ratchov Exp $	*/
d936 6
a941 1
	return bus_space_read_1(sc->ccs_iot, sc->ccs_ioh, reg);
d948 2
d955 6
a960 1
	return bus_space_read_1(sc->mt_iot, sc->mt_ioh, reg);
d967 2
d974 6
a979 1
	return bus_space_read_2(sc->mt_iot, sc->mt_ioh, reg);
d986 2
d993 6
a998 1
	return bus_space_read_4(sc->mt_iot, sc->mt_ioh, reg);
d1005 2
@


1.45
log
@put all calls bus_space_xxx() into functions, makes the code smaller
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.42 2010/10/04 09:32:43 ratchov Exp $	*/
d1824 1
a1824 1
		p->encoding = AUDIO_ENCODING_SLINEAR;
d1831 1
a1831 1
		r->encoding = AUDIO_ENCODING_SLINEAR;
@


1.44
log
@If the card model is not ``HT/PT'', then check that the DMA physical
address is 28-bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.43 2010/10/06 21:02:59 ratchov Exp $	*/
d62 6
d946 36
d985 1
d1199 1
a1199 1
		st = bus_space_read_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_AC97_CMD);
d1235 2
a1236 2
	bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_AC97_IDX, reg & 0x7f);
	bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_AC97_CMD,
d1245 1
a1245 1
	*result = bus_space_read_2(sc->mt_iot, sc->mt_ioh, ENVY_MT_AC97_DATA);
d1260 3
a1262 3
	bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_AC97_IDX, reg & 0x7f);
	bus_space_write_2(sc->mt_iot, sc->mt_ioh, ENVY_MT_AC97_DATA, data);
	bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_AC97_CMD,
d1274 1
a1274 2
	bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_AC97_CMD,
	    ENVY_MT_AC97_CMD_RST);
d1276 1
a1276 1
	bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_AC97_CMD, 0);
d1397 2
a1398 4
		bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_NSTREAM,
		    4 - sc->card->noch / 2);
		bus_space_write_1(sc->mt_iot, sc->mt_ioh,
		    ENVY_MT_IMASK, ~(ENVY_MT_IMASK_PDMA0 |
d1412 1
a1412 1
		reg = bus_space_read_4(sc->mt_iot, sc->mt_ioh, ENVY_MT_HTSRC);
d1424 1
a1424 1
	reg = bus_space_read_2(sc->mt_iot, sc->mt_ioh, ENVY_MT_OUTSRC);
d1433 1
a1433 1
	reg = bus_space_read_4(sc->mt_iot, sc->mt_ioh, ENVY_MT_INSEL);
d1459 1
a1459 1
		reg = bus_space_read_4(sc->mt_iot, sc->mt_ioh, ENVY_MT_HTSRC);
d1461 1
a1461 1
		bus_space_write_4(sc->mt_iot, sc->mt_ioh, ENVY_MT_HTSRC, reg);
d1478 1
a1478 1
		reg = bus_space_read_4(sc->mt_iot, sc->mt_ioh, ENVY_MT_INSEL);
d1480 1
a1480 1
		bus_space_write_4(sc->mt_iot, sc->mt_ioh, ENVY_MT_INSEL, reg);
d1498 1
a1498 1
	reg = bus_space_read_2(sc->mt_iot, sc->mt_ioh, ENVY_MT_OUTSRC);
d1500 1
a1500 1
	bus_space_write_2(sc->mt_iot, sc->mt_ioh, ENVY_MT_OUTSRC, reg);
d1510 1
a1510 1
	reg = bus_space_read_2(sc->mt_iot, sc->mt_ioh, ENVY_MT_SPDROUTE);
d1533 1
a1533 1
	reg = bus_space_read_2(sc->mt_iot, sc->mt_ioh, ENVY_MT_SPDROUTE);
d1564 1
a1564 1
	bus_space_write_2(sc->mt_iot, sc->mt_ioh, ENVY_MT_SPDROUTE, reg);
d1573 2
a1574 2
	bus_space_write_2(sc->mt_iot, sc->mt_ioh, ENVY_MT_MONIDX, idx);
	reg = bus_space_read_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_MONDATA + ch);
d1583 1
a1583 1
	bus_space_write_2(sc->mt_iot, sc->mt_ioh, ENVY_MT_MONIDX, idx);
d1586 1
a1586 1
	bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_MONDATA + ch, reg);
d1743 1
a1743 1
	bus_space_write_4(sc->mt_iot, sc->mt_ioh, basereg, dma_addr);
d1819 1
a1819 1
	reg = bus_space_read_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_RATE);
d1822 1
a1822 1
	bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_RATE, reg);
d1907 1
a1907 1
	st = bus_space_read_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_INTR);
d1917 4
a1920 8
		sc->intrs[sc->nintr].ipos = 
		    bus_space_read_2(sc->mt_iot, sc->mt_ioh, ENVY_MT_RBUFSZ);
		sc->intrs[sc->nintr].opos = 
		    bus_space_read_2(sc->mt_iot, sc->mt_ioh, ENVY_MT_PBUFSZ);
		sc->intrs[sc->nintr].ctl = 
		    bus_space_read_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_CTL);
		sc->intrs[sc->nintr].mask = 
		    bus_space_read_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_IMASK);
d1942 1
a1942 1
			ctl = bus_space_read_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_CTL);
d1944 1
a1944 1
				bus_space_write_1(sc->mt_iot, sc->mt_ioh,
d1946 1
a1946 1
				bus_space_write_1(sc->mt_iot, sc->mt_ioh,
d1962 1
a1962 1
			ctl = bus_space_read_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_CTL);
d1964 1
a1964 1
				bus_space_write_1(sc->mt_iot, sc->mt_ioh,
d1966 1
a1966 1
				bus_space_write_1(sc->mt_iot, sc->mt_ioh,
d1979 2
a1980 2
		err = bus_space_read_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_ERR);
		bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_ERR, err);
d1982 1
a1982 1
	bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_INTR, st);
d2006 2
a2007 4
	bus_space_write_2(sc->mt_iot, sc->mt_ioh,
	    ENVY_MT_PBUFSZ, bufsz / 4 - 1);
	bus_space_write_2(sc->mt_iot, sc->mt_ioh,
	    ENVY_MT_PBLKSZ(sc), blksz / 4 - 1);
d2021 2
a2022 2
	bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_INTR, st);
	st = bus_space_read_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_CTL);
d2024 1
a2024 1
	bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_CTL, st);
d2049 2
a2050 4
	bus_space_write_2(sc->mt_iot, sc->mt_ioh,
	    ENVY_MT_RBUFSZ, bufsz / 4 - 1);
	bus_space_write_2(sc->mt_iot, sc->mt_ioh,
	    ENVY_MT_RBLKSZ, blksz / 4 - 1);
d2064 2
a2065 2
	bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_INTR, st);
	st = bus_space_read_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_CTL);
d2067 1
a2067 1
	bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_CTL, st);
@


1.43
log
@Give the device the physical address obtained from the DMA mapping
instead of the actual physical address of the DMA-safe memory.
On i386 the driver used to work because both addresses are the
same.

spotted by damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.42 2010/10/04 09:32:43 ratchov Exp $	*/
d1653 1
d1670 1
a1670 1
#define ENVY_BOUNDARY	0
d1673 1
a1673 1
	    ENVY_BOUNDARY, &buf->seg, 1, &rsegs, wait);
d1696 1
a1696 2
	bus_space_write_4(sc->mt_iot, sc->mt_ioh, basereg,
	    buf->map->dm_segs[0].ds_addr);
d1698 6
a1703 1
	    buf->size, dir, buf->addr, (void *)buf->map->dm_segs[0].ds_addr);
d1705 2
a1706 1

d1734 1
@


1.42
log
@add support for midi(4) ports to envy(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.41 2010/09/08 20:34:11 stsp Exp $	*/
a1676 1

a1682 1

a1688 1

d1695 4
a1698 3
	bus_space_write_4(sc->mt_iot, sc->mt_ioh, basereg, buf->seg.ds_addr);
	DPRINTF("%s: allocated %ld bytes dir=%d, ka=%p, da=%p\n",
		DEVNAME(sc), buf->size, dir, buf->addr, (void *)buf->seg.ds_addr);
@


1.41
log
@Add support for Terratec EWX 24/96 based on initial diff from ratchov@@.
ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.40 2010/07/31 16:52:37 ratchov Exp $	*/
d29 1
d38 1
d77 1
d111 7
d203 11
d1253 17
d1330 18
d1352 2
a1353 1
	envy_ccs_write(sc, ENVY_CCS_INTMASK, ~ENVY_CCS_INT_MT);
d1611 5
d1858 1
d1860 1
a1860 1

d1863 2
a1864 1
	if (st == 0)
d1866 1
d1884 13
d2279 49
@


1.40
log
@add support for M-audio Audiophile 192k
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.39 2010/07/21 07:49:48 ratchov Exp $	*/
d122 2
d274 7
d448 44
@


1.39
log
@remove duplicate AP192K_GPIO_XXX macros,
from Alexandr Shadchin, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.38 2010/07/21 07:11:55 ratchov Exp $	*/
d384 1
a384 1
#define AP192K_GPIO_CSMASK	0x70
d386 2
a387 1

d391 1
a391 1
	int i;
d393 1
d397 1
d401 8
@


1.38
log
@make ENVY_GPIO_XXX macros card specific, add stub for audiophile 192k
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.37 2010/07/15 03:43:11 jakemsr Exp $	*/
a381 5
#define AP192K_GPIO_CLK		0x2
#define AP192K_GPIO_DOUT	0x8
#define AP192K_GPIO_CSMASK	0x70
#define AP192K_GPIO_CS(dev)	((dev) << 4)

@


1.37
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.36 2010/04/08 00:23:53 tedu Exp $	*/
d119 3
d287 6
d318 8
d352 61
a412 2
	reg &= ~ENVY_GPIO_CSMASK;
	reg |=  ENVY_GPIO_CS(dev);
d418 2
a419 2
		reg &= ~(ENVY_GPIO_CLK | ENVY_GPIO_DOUT);
		reg |= (bits & 0x8000) ? ENVY_GPIO_DOUT : 0;
d423 1
a423 1
		reg |= ENVY_GPIO_CLK;
d429 1
a429 1
	reg |= ENVY_GPIO_CSMASK;
d438 2
d494 2
a495 2
			reg &= ~(ENVY_GPIO_CLK | ENVY_GPIO_DOUT);
			reg |= (bits & mask) ? ENVY_GPIO_DOUT : 0;
d499 1
a499 1
			reg |= ENVY_GPIO_CLK;
@


1.36
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.35 2010/03/07 18:55:45 ratchov Exp $	*/
d1545 2
d1582 2
d1589 2
@


1.35
log
@Don't stop DMA in envy_halt_intput() and/or envy_halt_output().
Instead wait for the next interrupt and stop DMA in the interrupt
handler. This prevents the chip from entering a unstable state
in which DMA doesn't start cleanly.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.34 2010/02/25 21:25:03 ratchov Exp $	*/
a34 1
#include <sys/proc.h>
@


1.34
log
@Fix up some of the comments to use the correct
capitilization for names.
from brad, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.33 2010/02/25 21:19:37 ratchov Exp $	*/
d35 2
d79 1
d1164 3
a1166 2
		bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_IMASK,
		    ~(ENVY_MT_IMASK_PDMA0 | ENVY_MT_IMASK_RDMA0));
d1168 2
a1173 23
envy_intr(void *self)
{
	struct envy_softc *sc = (struct envy_softc *)self;
	int st;

	st = bus_space_read_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_INTR);
	if (!(st & (ENVY_MT_INTR_PACK | ENVY_MT_INTR_RACK))) {
		return 0;
	}
	if (st & ENVY_MT_INTR_PACK) {
		st = ENVY_MT_INTR_PACK;
		bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_INTR, st);
		sc->ointr(sc->oarg);
	}
	if (st & ENVY_MT_INTR_RACK) {
		st = ENVY_MT_INTR_RACK;
		bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_INTR, st);
		sc->iintr(sc->iarg);
	}
	return 1;
}

int
d1559 1
a1559 2
	if (setmode == 0) {
		DPRINTF("%s: no params to set\n", DEVNAME(sc));
a1560 1
	}
d1623 102
d1731 1
a1731 1
	int st;
d1744 1
d1750 7
d1759 2
a1760 1

a1762 1

d1766 1
d1776 1
a1776 1
	int st;
d1789 1
d1795 7
d1804 2
a1805 1

a1807 1

d1811 1
d1819 1
a1819 1
	int st;
d1821 12
a1832 3
	st = bus_space_read_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_CTL);
	st &= ~ENVY_MT_CTL_PSTART;
	bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_CTL, st);
d1840 1
a1840 1
	int st;
d1842 12
a1853 3
	st = bus_space_read_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_CTL);
	st &= ~ENVY_MT_CTL_RSTART(sc);
	bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_CTL, st);
@


1.33
log
@Remove trailing spaces,
from Alexandr Shadchin <alexandr.shadchin at gmail.com>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.32 2010/02/20 16:45:28 ratchov Exp $	*/
d204 1
a204 1
 * ESI julia cards don't have EEPROM, use this copy
d304 1
a304 1
 * m-audio delta specific code
d357 1
a357 1
 * m-audio revolution 5.1 specific code
d456 1
a456 1
 * via tremor 5.1 specific code
d476 1
a476 1
 * esi julia specific code
d1106 1
a1106 1
	 * read eeprom using i2c device or from a static array
d1123 1
a1123 1
	 * write eeprom values to corresponding registers
@


1.32
log
@Add necessary bits to support AC97 codecs in envy and add support
for the VIA Tremor 5.1 card.

From Alexandr Shadchin <alexandr.shadchin at gmail.com>, thanks!

help from oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.31 2009/11/02 05:54:16 ratchov Exp $	*/
d91 1
a91 1
int envy_set_params(void *, int, int, struct audio_params *, 
d208 3
a210 3
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x20, 0x80, 0xf8, 0xc3, 
	0x9f, 0xff, 0x7f, 
d360 1
a360 1
#define REVO51_GPIO_CSMASK	0x30 
d768 1
a768 1
envy_ccs_read(struct envy_softc *sc, int reg) 
d801 1
a801 1
		    (envy_ccs_read(sc, ENVY_CCS_GPIODATA2) << 16); 
d823 1
a823 1
		    (envy_ccs_read(sc, ENVY_CCS_GPIOMASK2) << 16); 
d845 1
a845 1
		    (envy_ccs_read(sc, ENVY_CCS_GPIODIR2) << 16); 
d925 1
a925 1
        for (;;) {
d927 1
a927 1
		if (!(st & ENVY_I2C_CTL_BUSY)) 
d995 1
a995 1
        for (;;) {
d1119 1
a1119 1
	} else 
d1135 1
a1135 1
		pci_conf_write(sc->pci_pc, sc->pci_tag, ENVY_CONF, 
d1146 1
a1146 1
	DPRINTF("%s: gpio_mask = %02x\n", DEVNAME(sc), 
d1148 1
a1148 1
	DPRINTF("%s: gpio_dir = %02x\n", DEVNAME(sc), 
d1150 1
a1150 1
	DPRINTF("%s: gpio_state = %02x\n", DEVNAME(sc), 
d1155 1
a1155 1
	 */ 
d1230 1
a1230 1
	
d1251 1
a1251 1
		/* 
d1316 1
a1316 1
	
d1319 1
a1319 1
		/* 
d1398 1
a1398 1
	if (pci_mapreg_map(pa, ENVY_CTL_BAR, PCI_MAPREG_TYPE_IO, 0, 
d1403 1
a1403 1
        }
d1409 1
a1409 1
        }
d1490 1
a1490 1
	err = bus_dmamem_alloc(sc->pci_dmat, buf->size, ENVY_ALIGN, 
d1497 2
a1498 2
	err = bus_dmamem_map(sc->pci_dmat, &buf->seg, rsegs, buf->size, 
            &buf->addr, wait | BUS_DMA_COHERENT);
d1503 1
a1503 1
	
d1510 3
a1512 3
	
	err = bus_dmamap_load(sc->pci_dmat, buf->map, buf->addr, 
            buf->size, NULL, wait);
d1518 1
a1518 1
	DPRINTF("%s: allocated %ld bytes dir=%d, ka=%p, da=%p\n", 
d1523 1
a1523 1
	bus_dmamap_destroy(sc->pci_dmat, buf->map);	
d1529 1
a1529 1
	return NULL;	
d1549 1
a1549 1
	bus_dmamap_destroy(sc->pci_dmat, buf->map);	
d1661 1
a1661 1
	bus_space_write_2(sc->mt_iot, sc->mt_ioh, 
d1663 1
a1663 1
	bus_space_write_2(sc->mt_iot, sc->mt_ioh, 
d1685 1
a1685 1
	
d1697 1
a1697 1
	bus_space_write_2(sc->mt_iot, sc->mt_ioh, 
d1699 1
a1699 1
	bus_space_write_2(sc->mt_iot, sc->mt_ioh, 
d1754 2
a1755 2
	char *classes[] = { 
		AudioCinputs, AudioCoutputs, AudioCmonitor 
d1793 1
a1793 1
		snprintf(dev->un.e.member[n++].label.name, 
d1797 1
a1797 1
			snprintf(dev->un.e.member[n++].label.name, 
d1800 1
a1800 1
		snprintf(dev->label.name, MAX_AUDIO_DEV_LEN, 
d1816 1
a1816 1
		snprintf(dev->label.name, MAX_AUDIO_DEV_LEN, 
d1900 1
a1900 1
	
d1905 1
a1905 1
		if (idx < 2) 
@


1.31
log
@Add support for ``M-Audio Revolution 5.1'' cards, based on envy24HT.
From Alexandr Shadchin <ShadchinAV _at_ mail.ru>
Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.30 2009/10/24 09:13:35 ratchov Exp $	*/
d35 2
a40 1
#include <dev/audio_if.h>
d107 7
d120 2
d288 6
d456 20
d990 102
d1758 3
d1850 3
d1893 3
@


1.30
log
@add the subvendor ID of ``M-Audio Audiophile 2496'' and add it to
the list of supported cards
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.29 2009/10/11 12:59:29 ratchov Exp $	*/
d69 3
d109 3
d133 5
d211 2
d272 6
d340 98
a493 1

d654 74
d826 59
d1003 1
a1003 1
	    
@


1.29
log
@At initialization of HT chips, write configuration on the corresponding
control registers rather than on the PCI configuration space (which is
ok for non-HT chips only). Also fix the offset GPIO mask/dir are read
from EEPROM, old ones are working by accident.

both fixes are from Alexandr Shadchin <ShadchinAV _at_ mail.ru>
Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.28 2009/05/18 20:10:12 ratchov Exp $	*/
d233 7
@


1.28
log
@the block size must be multiple of the pci burst size (overwise
dma pointers can overrun)
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.27 2009/05/08 17:52:18 ratchov Exp $	*/
d191 1
a191 1
	0x16, 0x80, 0x00
a415 1

d441 1
a441 1
		dev->un.s.num_mem = 2;
d731 18
a748 7
	pci_conf_write(sc->pci_pc, sc->pci_tag, ENVY_CONF, 
	    sc->eeprom[ENVY_EEPROM_CONF] |
	    (sc->eeprom[ENVY_EEPROM_ACLINK] << 8) |
	    (sc->eeprom[ENVY_EEPROM_I2S] << 16) |
	    (sc->eeprom[ENVY_EEPROM_SPDIF] << 24));

	envy_gpio_setmask(sc, envy_eeprom_gpioxxx(sc, ENVY_EEPROM_GPIOMASK));
@


1.27
log
@add support HT mixer knobs (ie routing control). Allow monitoring
analog inputs
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.26 2009/05/08 16:53:45 ratchov Exp $	*/
d1217 1
a1217 1
	pmult = (sc->isht ? sc->card->noch / 2 : ENVY_PCHANS / 2);
d1220 1
a1220 1
	rmult = (sc->isht ? sc->card->nich / 2 : ENVY_RCHANS / 2);
d1224 1
a1224 5
	if ((mul & 1) != 0)
		mul <<= 1;
	if ((mul & 3) != 0)
		mul <<= 1;
	if ((mul & 7) != 0)
d1246 1
a1246 1
	bufsz = end - start;
d1282 1
a1282 1
	bufsz = end - start;
@


1.26
log
@add support for the ak4358 DAC used in ESI Julia cards. There are
two mono line0 and line1 knobs rather than a single stereo knob
because that's how the routing control (not exposed for ht chips yet)
works.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.25 2009/05/08 16:12:23 ratchov Exp $	*/
d791 13
d827 19
d1379 1
a1379 1
	ndev = sc->isht ? 0 : sc->card->noch;
d1392 1
a1392 1
		if (idx < 2) {
d1452 1
a1452 1
	ndev = sc->isht ? 0 : sc->card->noch;
d1493 1
a1493 1
	ndev = sc->isht ? 0 : sc->card->noch;
@


1.25
log
@print card model, the number of inputs and the number of outputs
when the device attaches
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.24 2009/05/08 16:07:26 ratchov Exp $	*/
d122 5
d198 2
d247 1
a247 1
		2, &unkenvy_codec, 2, &unkenvy_codec,
d277 5
a281 5
		sc->ak[dev].reg[AK4524_DEEMVOL] = AK4524_DEEM_OFF;
		sc->ak[dev].reg[AK4524_ADC_GAIN0] = 0x7f;
		sc->ak[dev].reg[AK4524_ADC_GAIN1] = 0x7f;
		sc->ak[dev].reg[AK4524_DAC_GAIN0] = 0x7f;
		sc->ak[dev].reg[AK4524_DAC_GAIN1] = 0x7f;
d322 2
d327 3
d361 46
d675 1
a675 1
	return sc->ak[dev].reg[addr];
d682 1
a682 1
	sc->ak[dev].reg[addr] = data;
@


1.24
log
@add support for m-audio delta 1010, delta 66 and delta 44 since
they are the same as the delta 1010lt card, only the number of
implemented codecs change
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.23 2009/05/08 15:31:16 ratchov Exp $	*/
d933 1
a933 2
		if (sc->card->subid == 0) {
			printf("%s: unknown card\n", DEVNAME(sc));
a934 1
		}
d937 2
a938 1
	DPRINTF("%s: type=%s\n", DEVNAME(sc), sc->card->name);
@


1.23
log
@rename few functions and macros, fix style
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.22 2009/05/08 15:17:41 ratchov Exp $	*/
d202 21
d224 1
a224 1
		"delta",
d231 1
a231 1
		"unkenvy",
d239 1
a239 1
		"julia",
d246 1
a246 1
		"unkenvy",
d263 1
a263 1
	for (dev = 0; dev < 4 /* XXX */; dev++) {
@


1.22
log
@expose HT mixer; since neither the digital mixer nor codec
sub-mixers are implemented, it's empty.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.21 2009/05/08 14:56:03 ratchov Exp $	*/
a26 1
 * - rename s/ak/spi/g
d71 2
a72 2
int  envy_ak_read(struct envy_softc *, int, int);
void envy_ak_write(struct envy_softc *, int, int, int);
d104 1
a104 1
void delta_ak_write(struct envy_softc *, int, int, int);
d107 1
a107 1
void julia_ak_write(struct envy_softc *, int, int, int);
d110 1
a110 1
void unkenvy_ak_write(struct envy_softc *, int, int, int);
d206 1
a206 1
		delta_ak_write,
d213 1
a213 1
		unkenvy_ak_write
d221 1
a221 1
		julia_ak_write,
d228 1
a228 1
		unkenvy_ak_write
d243 1
a243 1
		envy_ak_write(sc, dev, AK_RST, 0x0);
d245 9
a253 7
		envy_ak_write(sc, dev, AK_RST, AK_RST_AD | AK_RST_DA);
		envy_ak_write(sc, dev, AK_FMT, AK_FMT_IIS24);
		sc->ak[dev].reg[AK_DEEMVOL] = AK_DEEM_OFF;
		sc->ak[dev].reg[AK_ADC_GAIN0] = 0x7f;
		sc->ak[dev].reg[AK_ADC_GAIN1] = 0x7f;
		sc->ak[dev].reg[AK_DAC_GAIN0] = 0x7f;
		sc->ak[dev].reg[AK_DAC_GAIN1] = 0x7f;
d258 1
a258 1
delta_ak_write(struct envy_softc *sc, int dev, int addr, int data)
d294 1
a294 1
	envy_ak_write(sc, 0, 0, 0);	/* reset */
d296 1
a296 1
	envy_ak_write(sc, 0, 0, 0x87);	/* i2s mode */
d300 1
a300 1
julia_ak_write(struct envy_softc *sc, int dev, int addr, int data)
d317 1
a317 1
unkenvy_ak_write(struct envy_softc *sc, int dev, int addr, int data)
d376 2
a377 1
		val = envy_ak_read(sc, idx / 2, (idx % 2) + AK_DAC_GAIN0);
d382 2
a383 2
		val = envy_ak_read(sc, idx, AK_DEEMVOL);
		ctl->un.ord = (val & AK_MUTE) ? 1 : 0;
d397 2
a398 1
		envy_ak_write(sc, idx / 2, (idx % 2) + AK_DAC_GAIN0, val);
d403 2
a404 2
		val = AK_DEEM_OFF | (ctl->un.ord ? AK_MUTE : 0);
		envy_ak_write(sc, idx, AK_DEEMVOL, val);
d435 1
a435 1
	val = envy_ak_read(sc, idx / 2, (idx % 2) + AK_ADC_GAIN0);
d448 1
a448 1
	envy_ak_write(sc, idx / 2, (idx % 2) + AK_ADC_GAIN0, val);
d595 1
a595 1
envy_ak_read(struct envy_softc *sc, int dev, int addr) {
d600 1
a600 1
envy_ak_write(struct envy_softc *sc, int dev, int addr, int data)
d602 1
a602 1
	DPRINTFN(2, "envy_ak_write: %d, %d, 0x%x\n", dev, addr, data);
d604 1
a604 1
	sc->card->ak_write(sc, dev, addr, data);
d708 2
a709 1
envy_lineout_getsrc(struct envy_softc *sc, int out) {
d731 2
a732 1
envy_lineout_setsrc(struct envy_softc *sc, int out, int src) {
d775 2
a776 1
envy_spdout_getsrc(struct envy_softc *sc, int out) {
d798 2
a799 1
envy_spdout_setsrc(struct envy_softc *sc, int out, int src) {
d838 2
a839 1
envy_mon_getvol(struct envy_softc *sc, int idx, int ch, int *val) {
d848 2
a849 1
envy_mon_setvol(struct envy_softc *sc, int idx, int ch, int val) {
d859 2
a860 1
envymatch(struct device *parent, void *match, void *aux) {
@


1.21
log
@use the number of channels rather than the number of stereo dacs/adcs,
because there will support for non-stereo dacs/adcs soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.20 2009/05/08 13:35:55 ratchov Exp $	*/
d112 1
d195 1
a195 1
	"unknown codec", 0, NULL, NULL, NULL
d320 6
a1237 2
	if (sc->isht)		/* no mixer yet */
		return ENXIO;
d1259 1
a1259 1
	ndev = sc->card->noch;
d1287 1
a1287 1
	ndev = ENVY_MIX_NMONITOR;
a1326 2
	if (sc->isht)	/* no mixer yet */
		return EINVAL;
d1332 1
a1332 1
	ndev = sc->card->noch;
d1340 1
a1340 1
	ndev = ENVY_MIX_NMONITOR;
a1367 2
	if (sc->isht)	/* no mixer yet */
		return EINVAL;
d1373 1
a1373 1
	ndev = sc->card->noch;
d1386 1
a1386 1
	ndev = ENVY_MIX_NMONITOR;
@


1.20
log
@hide controls corresponding to missing dacs, adcs or spdifs.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.19 2009/05/04 04:49:50 ratchov Exp $	*/
d113 1
d117 1
d190 1
a190 1
	"ak4524 dac", 3, ak4524_dac_devinfo, ak4524_dac_get, ak4524_dac_set
d192 1
a192 1
	"ak4524 adc", 2, ak4524_adc_devinfo, ak4524_adc_get, ak4524_adc_set
d204 1
a204 1
		4, &ak4524_adc, 4, &ak4524_dac,
d211 1
a211 1
		4, &unkenvy_codec, 4, &unkenvy_codec,
d219 1
a219 1
		1, &unkenvy_codec, 1, &unkenvy_codec,
d226 1
a226 1
		1, &unkenvy_codec, 4, &unkenvy_codec,
d322 8
d335 1
a335 1
	ndev = sc->card->ndac * 2;
d366 1
a366 1
	ndev = sc->card->ndac * 2;
d383 1
a383 1
	ndev = sc->card->ndac * 2;
d402 7
d667 1
a667 1
		    4 - sc->card->ndac);
d1069 1
a1069 1
		p->channels = sc->isht ? 2 * sc->card->ndac : ENVY_PCHANS;
d1074 1
a1074 1
		r->channels = sc->isht ? 2 * sc->card->nadc : ENVY_RCHANS;
d1090 1
a1090 1
	pmult = (sc->isht ? sc->card->ndac : ENVY_PCHANS / 2);
d1093 1
a1093 1
	rmult = (sc->isht ? sc->card->nadc : ENVY_RCHANS / 2);
d1125 1
a1125 1
	if (blksz % (sc->isht ? sc->card->ndac * 8 : ENVY_PFRAME_SIZE) != 0) {
d1161 1
a1161 1
	if (blksz % (sc->isht ? sc->card->nadc * 8 : ENVY_RFRAME_SIZE) != 0) {
d1254 1
a1254 1
	ndev = sc->card->ndac * 2;
d1259 1
a1259 1
		for (i = 0; i < sc->card->nadc * 2; i++) {
d1298 1
a1298 1
	ndev = sc->card->nadc * sc->card->adc->ndev;
d1308 1
a1308 1
	ndev = sc->card->ndac * sc->card->dac->ndev;
d1329 1
a1329 1
	ndev = sc->card->ndac * 2;
d1333 1
a1333 1
			ctl->un.ord -= ENVY_MIX_NOUTSRC - sc->card->nadc * 2;
d1345 1
a1345 1
	ndev = sc->card->nadc * sc->card->adc->ndev;
d1351 1
a1351 1
	ndev = sc->card->ndac * sc->card->dac->ndev;
d1372 1
a1372 1
	ndev = sc->card->ndac * 2;
d1374 1
a1374 1
		maxsrc = sc->card->nadc * 2 + 1;
d1379 2
a1380 2
		if (ctl->un.ord >= sc->card->nadc * 2)
			ctl->un.ord += ENVY_MIX_NOUTSRC - sc->card->nadc * 2;
d1395 1
a1395 1
	ndev = sc->card->nadc * sc->card->adc->ndev;
d1399 1
a1399 1
	ndev = sc->card->ndac * sc->card->dac->ndev;
@


1.19
log
@put codec-specific mixer bits in their own routines and
reference the code in global envy_card structures. Allows the same
mixer code to be shared across differents cards. Will ease adding
codec-specific knobs when adding support for new cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.18 2009/05/03 20:55:44 ratchov Exp $	*/
d21 1
a21 4
 * - add ndac, nadc, nspdin, nspdout, to struct envy_card
 *
 * - split mixer in 3 parts: envy-specific, codec-specific, and card-specific
 * (gpio knobs) and put codec/card specific parts into envy_card structure
d1235 1
a1235 1
	 * envy output source
d1237 1
a1237 1
	ndev = ENVY_MIX_NOUTSRC;
d1242 1
a1242 1
		for (i = 0; i < 10; i++) {
d1312 1
a1312 1
	ndev = 8; /* XXX: use ndacs */
d1315 2
a1316 6
		return 0;
	}
	idx -= ndev;
	ndev = ENVY_MIX_NOUTSRC - 8;
	if (idx < ndev) {
		ctl->un.ord = envy_spdout_getsrc(sc, idx);
d1355 1
a1355 1
	ndev = 8; /* XXX: use ndacs */
d1357 3
a1359 1
		maxsrc = (idx < 2 || idx >= 8) ? 12 : 11;
d1362 2
a1364 8
		return 0;
	}
	idx -= ndev;
	ndev = ENVY_MIX_NOUTSRC - 8;
	if (idx < ndev) {
		if (ctl->un.ord < 0 || ctl->un.ord >= 12)
			return EINVAL;
		envy_spdout_setsrc(sc, idx, ctl->un.ord);
@


1.18
log
@reorganize mixer bits to allow, supporting codec-dependent mixer
controls later. Also stop using ``next'' and ``prev'' pointers,
since they make impossible exposing ``source'' knobs for streams
that do not have ``gain'' knobs. This implies renaming ``xxx.source''
knobs to ``xxx_source''. Besides that, no behaviour change.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.17 2009/04/25 12:15:10 ratchov Exp $	*/
d116 7
d190 8
d205 1
a205 1
		4, 4,
d212 1
a212 1
		4, 4,
d216 1
a216 2
};
struct envy_card envy_cards_ht[] = {
d220 1
a220 1
		1, 1,
d227 1
a227 1
		1, 4,
d321 108
d1282 1
a1282 17
	 * inputs.line
	 */
	ndev = sc->card->nadc * ENVY_MIX_NILVL;
	if (idx < ndev) {
		dev->type = AUDIO_MIXER_VALUE;
		dev->mixer_class = ENVY_MIX_CLASSIN;
		dev->un.v.delta = 2;
		dev->un.v.num_channels = 1;
		snprintf(dev->label.name, MAX_AUDIO_DEV_LEN, 
		    AudioNline "%d", idx);
		strlcpy(dev->un.v.units.name, AudioNvolume, MAX_AUDIO_DEV_LEN);
		return 0;
	}
	idx -= ndev;

	/*
	 * outputs.line
d1284 1
a1284 1
	ndev = sc->card->ndac * ENVY_MIX_NOLVL;
d1286 1
a1286 7
		dev->type = AUDIO_MIXER_VALUE;
		dev->mixer_class = ENVY_MIX_CLASSOUT;
		dev->un.v.delta = 2;
		dev->un.v.num_channels = 1;
		snprintf(dev->label.name, MAX_AUDIO_DEV_LEN,
		    AudioNline "%d", idx);
		strlcpy(dev->un.v.units.name, AudioNvolume, MAX_AUDIO_DEV_LEN);
d1292 1
a1292 1
	 * outputs.mute
d1294 1
a1294 1
	ndev = sc->card->ndac * ENVY_MIX_NOMUTE;
d1296 1
a1296 11
		dev->type = AUDIO_MIXER_ENUM;
		dev->mixer_class = ENVY_MIX_CLASSOUT;
		dev->un.e.member[0].ord = 0;
		strlcpy(dev->un.e.member[0].label.name, AudioNoff,
		    MAX_AUDIO_DEV_LEN);
		dev->un.e.member[1].ord = 1;
		strlcpy(dev->un.e.member[1].label.name, AudioNon,
		    MAX_AUDIO_DEV_LEN);
		dev->un.s.num_mem = 2;
		snprintf(dev->label.name, MAX_AUDIO_DEV_LEN,
		    AudioNmute "%d-%d", 2 * idx, 2 * idx + 1);
a1328 1
		idx = idx;
d1335 1
a1335 10
	ndev = sc->card->nadc * ENVY_MIX_NILVL;
	if (idx < ndev) {
		idx = idx;
		val = envy_ak_read(sc, idx / 2, (idx % 2) + AK_ADC_GAIN0);
		ctl->un.value.num_channels = 1;
		ctl->un.value.level[0] = 2 * val;
		return 0;
	}
	idx -= ndev;
	ndev = sc->card->ndac * ENVY_MIX_NOLVL;
d1337 1
a1337 4
		idx = idx;
		val = envy_ak_read(sc, idx / 2, (idx % 2) + AK_DAC_GAIN0);
		ctl->un.value.num_channels = 1;
		ctl->un.value.level[0] = 2 * val;
d1341 1
a1341 1
	ndev = sc->card->ndac * ENVY_MIX_NOMUTE;
d1343 1
a1343 3
		idx = idx;
		val = envy_ak_read(sc, idx, AK_DEEMVOL);
		ctl->un.ord = (val & AK_MUTE) ? 1 : 0;
a1363 1
		idx = idx;
a1372 1
		idx = idx;
a1380 1
		idx = idx;
d1389 3
a1391 19
	ndev = sc->card->nadc * ENVY_MIX_NILVL;
	if (idx < ndev) {
		if (ctl->un.value.num_channels != 1)
			return EINVAL;
		idx = idx;
		val = ctl->un.value.level[0] / 2;
		envy_ak_write(sc, idx / 2, (idx % 2) + AK_ADC_GAIN0, val);
		return 0;
	}
	idx -= ndev;
	ndev = sc->card->ndac * ENVY_MIX_NOLVL;
	if (idx < ndev) {
		if (ctl->un.value.num_channels != 1)
			return EINVAL;
		idx = idx;
		val = ctl->un.value.level[0] / 2;
		envy_ak_write(sc, idx / 2, (idx % 2) + AK_DAC_GAIN0, val);
		return 0;
	}
d1393 3
a1395 9
	ndev = sc->card->ndac * ENVY_MIX_NOMUTE;
	if (idx < ndev) {
		if (ctl->un.ord >= 2)
			return EINVAL;
		idx = idx;
		val = AK_DEEM_OFF | (ctl->un.ord ? AK_MUTE : 0);
		envy_ak_write(sc, idx, AK_DEEMVOL, val);
		return 0;
	}
@


1.17
log
@add basic support for Envy24HT chips and for ``ESI Juli@@''
cards using it. No mixer yet.

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.15 2009/03/29 21:53:52 sthen Exp $	*/
d1090 1
a1090 1
	int i, n, out;
d1100 2
d1103 5
a1107 1
	if (dev->index < ENVY_MIX_OUTSRC) {
d1109 2
a1110 3
		dev->mixer_class = dev->index - ENVY_MIX_CLASSIN;
		strlcpy(dev->label.name, 
		    classes[dev->index - ENVY_MIX_CLASSIN], MAX_AUDIO_DEV_LEN);
d1113 7
a1119 1
	if (dev->index < ENVY_MIX_MONITOR) {
a1120 1
		out = dev->index - ENVY_MIX_OUTSRC;
a1122 1
		dev->prev = ENVY_MIX_OLVL(4) + out;
d1130 2
a1131 2
			 MAX_AUDIO_DEV_LEN, "play%d", out);
		if (out < 2) {
d1134 1
a1134 1
			    MAX_AUDIO_DEV_LEN, "mon%d", out);
d1137 1
a1137 1
		    AudioNsource, out);
d1141 7
a1147 2
	if (dev->index < ENVY_MIX_ILVL(4)) {
		out = dev->index - ENVY_MIX_MONITOR;
d1153 1
a1153 1
			 "%s%d", out < 10 ? "play" : "rec", out % 10);
d1157 7
a1163 2
	if (dev->index < ENVY_MIX_OLVL(4)) {	/* inputs.line */
		out = dev->index - ENVY_MIX_ILVL(4);
d1169 1
a1169 1
		    AudioNline "%d", out);
d1173 7
a1179 2
	if (dev->index < ENVY_MIX_OMUTE(4)) {	/* outputs.line */
		out = dev->index - ENVY_MIX_OLVL(4);
a1181 1
		dev->next = ENVY_MIX_OUTSRC + out;
d1185 1
a1185 1
		    AudioNline "%d", out);
d1189 7
a1195 2
	if (dev->index < ENVY_MIX_INVAL(4)) {	/* outputs.mute */
		out = dev->index - ENVY_MIX_OMUTE(4);
d1206 1
a1206 1
		    AudioNmute "%d-%d", 2 * out, 2 * out + 1);
d1216 1
a1216 1
	int out, val;
d1220 1
a1220 1
	if (ctl->dev < ENVY_MIX_OUTSRC) {
d1223 5
a1227 3
	if (ctl->dev <  ENVY_MIX_OUTSRC + 8) {
		out = ctl->dev - ENVY_MIX_OUTSRC;
		ctl->un.ord = envy_lineout_getsrc(sc, out);
d1230 4
a1233 3
	if (ctl->dev <  ENVY_MIX_MONITOR) {
		out = ctl->dev - (ENVY_MIX_OUTSRC + 8);
		ctl->un.ord = envy_spdout_getsrc(sc, out);
d1236 5
a1240 3
	if (ctl->dev <  ENVY_MIX_ILVL(4)) {
		out = ctl->dev - ENVY_MIX_MONITOR;
		envy_mon_getvol(sc, out / 2, out % 2, &val);
d1245 5
a1249 3
	if (ctl->dev < ENVY_MIX_OLVL(4)) {
		out = ctl->dev - ENVY_MIX_ILVL(4);
		val = envy_ak_read(sc, out / 2, (out % 2) + AK_ADC_GAIN0);
d1254 5
a1258 3
	if (ctl->dev < ENVY_MIX_OMUTE(4)) {
		out = ctl->dev - ENVY_MIX_OLVL(4);
		val = envy_ak_read(sc, out / 2, (out % 2) + AK_DAC_GAIN0);
d1263 5
a1267 3
	if (ctl->dev < ENVY_MIX_INVAL(4)) {
		out = ctl->dev - ENVY_MIX_OMUTE(4);
		val = envy_ak_read(sc, out, AK_DEEMVOL);
d1278 1
a1278 1
	int out, maxsrc, val;
d1282 1
a1282 1
	if (ctl->dev < ENVY_MIX_OUTSRC) {
d1285 6
a1290 3
	if (ctl->dev < ENVY_MIX_OUTSRC + 8) {
		out = ctl->dev - ENVY_MIX_OUTSRC;
		maxsrc = (out < 2 || out >= 8) ? 12 : 11;
d1293 1
a1293 1
		envy_lineout_setsrc(sc, out, ctl->un.ord);
d1296 4
a1299 2
	if (ctl->dev <  ENVY_MIX_MONITOR) {
		out = ctl->dev - (ENVY_MIX_OUTSRC + 8);
d1302 1
a1302 1
		envy_spdout_setsrc(sc, out, ctl->un.ord);
d1305 4
a1308 2
	if (ctl->dev <  ENVY_MIX_ILVL(4)) {
		out = ctl->dev - ENVY_MIX_MONITOR;
d1313 1
a1313 1
		envy_mon_setvol(sc, out / 2, out % 2, val);
d1316 3
a1318 1
	if (ctl->dev < ENVY_MIX_OLVL(4)) {
d1321 1
a1321 1
		out = ctl->dev - ENVY_MIX_ILVL(4);
d1323 1
a1323 1
		envy_ak_write(sc, out / 2, (out % 2) + AK_ADC_GAIN0, val);
d1326 3
a1328 1
	if (ctl->dev < ENVY_MIX_OMUTE(4)) {
d1331 1
a1331 1
		out = ctl->dev - ENVY_MIX_OLVL(4);
d1333 1
a1333 1
		envy_ak_write(sc, out / 2, (out % 2) + AK_DAC_GAIN0, val);
d1336 3
a1338 1
	if (ctl->dev < ENVY_MIX_INVAL(4)) {
d1341 1
a1341 1
		out = ctl->dev - ENVY_MIX_OMUTE(4);
d1343 1
a1343 1
		envy_ak_write(sc, out, AK_DEEMVOL, val);
@


1.16
log
@start splitting the driver in two parts: one specific to the
generic Envy24 chip common to all cards and another part specific
to the cards. This will ease adding support for other card models.

ok jakemsr@@
@
text
@d28 2
d110 3
d156 1
d172 12
d202 17
d271 20
d341 6
a346 1
	return envy_cci_read(sc, ENVY_CCI_GPIODATA);
d352 6
a357 1
	envy_cci_write(sc, ENVY_CCI_GPIODATA, reg);
d363 6
a368 1
	return envy_cci_read(sc, ENVY_CCI_GPIOMASK);
d374 6
a379 1
	envy_cci_write(sc, ENVY_CCI_GPIOMASK, mask);
d385 6
a390 1
	return envy_cci_read(sc, ENVY_CCI_GPIODIR);
d396 6
a401 1
	envy_cci_write(sc, ENVY_CCI_GPIODIR, dir);
d461 13
d513 3
a515 3
	envy_gpio_setmask(sc, sc->eeprom[ENVY_EEPROM_GPIOMASK]);
	envy_gpio_setdir(sc, sc->eeprom[ENVY_EEPROM_GPIODIR]);
	envy_gpio_setstate(sc, sc->eeprom[ENVY_EEPROM_GPIOST]);
d529 6
d728 1
d736 1
a736 1
	if (pci_mapreg_map(pa, ENVY_MT_BAR, PCI_MAPREG_TYPE_IO, 0,
d757 1
a757 1
	sc->card = envy_cards;
d933 1
a933 1
		p->channels = ENVY_PCHANS;
d938 1
a938 1
		r->channels = ENVY_RCHANS;
d946 22
a967 2
#define ENVY_MUL (6 * 5 * 4)
	blksz -= blksz % ENVY_MUL;
d969 1
a969 1
		blksz = ENVY_MUL;
d989 1
a989 1
	if (blksz % ENVY_PFRAME_SIZE != 0) {
d1001 1
a1001 1
	    ENVY_MT_PBLKSZ, blksz / 4 - 1);
d1025 1
a1025 1
	if (blksz % ENVY_RFRAME_SIZE != 0) {
d1046 1
a1046 1
	st |= ENVY_MT_CTL_RSTART;
d1070 1
a1070 1
	st &= ~ENVY_MT_CTL_RSTART;
d1080 1
a1080 1
	strlcpy(dev->name, "Envy24", MAX_AUDIO_DEV_LEN);
d1089 1
d1095 2
d1190 2
d1241 2
@


1.15
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.14 2009/03/04 17:54:14 ratchov Exp $	*/
d18 13
d65 7
a71 3
int  envy_gpio_read(struct envy_softc *);
void envy_gpio_write(struct envy_softc *, int);
void envy_eeprom_read(struct envy_softc *, unsigned char *);
d105 6
d149 4
d165 90
d283 36
a362 17
void
envy_eeprom_read(struct envy_softc *sc, unsigned char *eeprom)
{
	int i;

	for (i = 0; i < ENVY_EEPROM_MAXSZ; i++) {
		eeprom[i] = envy_i2c_read(sc, ENVY_I2C_DEV_EEPROM, i);
	}
#ifdef ENVY_DEBUG
	printf("%s: eeprom: ", DEVNAME(sc));
	for (i = 0; i < ENVY_EEPROM_MAXSZ; i++) {
		printf(" %02x", (unsigned)eeprom[i]);
	}
	printf("\n");
#endif
}

a370 2
	int bits, i, reg;

d373 1
a373 23

	reg = envy_cci_read(sc, ENVY_GPIO_DATA);
	reg &= ~ENVY_GPIO_CSMASK;
	reg |=  ENVY_GPIO_CS(dev);
	envy_cci_write(sc, ENVY_GPIO_DATA, reg);
	delay(1);

	bits  = 0xa000 | (addr << 8) | data;
	for (i = 0; i < 16; i++) {
		reg &= ~(ENVY_GPIO_CLK | ENVY_GPIO_DOUT);
		reg |= (bits & 0x8000) ? ENVY_GPIO_DOUT : 0;
		envy_cci_write(sc, ENVY_GPIO_DATA, reg);
		delay(1);

		reg |= ENVY_GPIO_CLK;
		envy_cci_write(sc, ENVY_GPIO_DATA, reg);
		delay(1);
		bits <<= 1;
	}

	reg |= ENVY_GPIO_CSMASK;
	envy_cci_write(sc, ENVY_GPIO_DATA, reg);
	delay(1);
d379 1
a379 2
	char eeprom[ENVY_EEPROM_MAXSZ];
	int dev;
d390 18
a407 1
	 * read config from eprom and write it to registers
a408 1
	envy_eeprom_read(sc, eeprom);
d410 8
a417 7
	    eeprom[ENVY_EEPROM_CONF] |
	    (eeprom[ENVY_EEPROM_ACLINK] << 8) |
	    (eeprom[ENVY_EEPROM_I2S] << 16) |
	    (eeprom[ENVY_EEPROM_SPDIF] << 24));
	envy_cci_write(sc, ENVY_GPIO_MASK, eeprom[ENVY_EEPROM_GPIOMASK]);
	envy_cci_write(sc, ENVY_GPIO_DIR,  eeprom[ENVY_EEPROM_GPIODIR]);
	envy_cci_write(sc, ENVY_GPIO_DATA, eeprom[ENVY_EEPROM_GPIOST]);
d420 1
a420 1
		envy_cci_read(sc, ENVY_GPIO_MASK));
d422 1
a422 1
		envy_cci_read(sc, ENVY_GPIO_DIR));
d424 1
a424 16
		envy_cci_read(sc, ENVY_GPIO_DATA));
	
	/*
	 * reset ak4524 codecs
	 */
	for (dev = 0; dev < 4; dev++) {
		envy_ak_write(sc, dev, AK_RST, 0x0);
		delay(300);
		envy_ak_write(sc, dev, AK_RST, AK_RST_AD | AK_RST_DA);
		envy_ak_write(sc, dev, AK_FMT, AK_FMT_IIS24);
		sc->ak[dev].reg[AK_DEEMVOL] = AK_DEEM_OFF;
		sc->ak[dev].reg[AK_ADC_GAIN0] = 0x7f;
		sc->ak[dev].reg[AK_ADC_GAIN1] = 0x7f;
		sc->ak[dev].reg[AK_DAC_GAIN0] = 0x7f;
		sc->ak[dev].reg[AK_DAC_GAIN1] = 0x7f;
	}
d431 1
d604 2
a605 7
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ICENSEMBLE &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ICENSEMBLE_ICE1712) {
		return 1;
	}
	return 0;
d615 1
d626 1
a626 1
			   &sc->ccs_iot, &sc->ccs_ioh, NULL, &sc->ccs_iosz, 0)) {
d631 2
a632 2
	if (pci_mapreg_map(pa, ENVY_MT_BAR, PCI_MAPREG_TYPE_IO, 0, 
			   &sc->mt_iot, &sc->mt_ioh, NULL, &sc->mt_iosz, 0)) {
d651 10
d746 2
a747 2
	DPRINTF("%s: allocated %d bytes dir=%d, ka=%p, da=%p\n", 
		DEVNAME(sc), buf->size, dir, buf->addr, buf->seg.ds_addr);
d841 5
a845 8
	/*
	 * XXX: sizes depend on the mode but we don't have 
	 * access to the mode here; So we use the greatest 
	 * common divisor of input and output blocksizes, until 
	 * upper layer is fixed
	 */
#define ENVY_GCD (6 * 5 * 4)
	return (blksz / ENVY_GCD) * ENVY_GCD;
d851 1
a851 4
	/*
	 * XXX: same remark as above
	 */
	return (bufsz / ENVY_GCD) * ENVY_GCD;
d863 3
a865 2
	if (bufsz % (ENVY_PCHANS * 4) != 0) {
		DPRINTF("%s: %d: bad output bufsz\n", DEVNAME(sc), bufsz);
d868 2
a869 2
	if (blksz % (ENVY_PCHANS * 4) != 0) {
		DPRINTF("%s: %d: bad output blksz\n", DEVNAME(sc), blksz);
d872 1
d899 3
a901 2
	if (bufsz % (ENVY_RCHANS * 4) != 0) {
		DPRINTF("%s: %d: bad input bufsz\n", DEVNAME(sc), bufsz);
d904 2
a905 2
	if (blksz % (ENVY_RCHANS * 4) != 0) {
		DPRINTF("%s: %d: bad input blksz\n", DEVNAME(sc), blksz);
d908 1
d953 2
d956 2
a957 2
	strlcpy(dev->version, "-", MAX_AUDIO_DEV_LEN);	/* XXX eeprom version */
	strlcpy(dev->config, "envy", MAX_AUDIO_DEV_LEN);
@


1.14
log
@don't bus_space_unmap() sc->mt_ioh with the wrong bus tag
from Alexandr Shadchin <ShadchinAV(at)mail.ru>, Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.13 2009/01/17 18:29:55 ratchov Exp $	*/
d517 1
a517 1
		printf(": failed to map ctl i/o space\n");
d523 1
a523 1
		printf(": failed to map mt i/o space\n");
@


1.13
log
@use 24-bit precision (encoded in 32-bit words) rather than
fake 32-bit precision. Allowed by recent audio(4) changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.12 2008/12/09 22:49:59 ratchov Exp $	*/
d558 1
a558 1
		bus_space_unmap(sc->ccs_iot, sc->mt_ioh, sc->mt_iosz);
@


1.12
log
@Non soundblaster-like devices must set AUDIO_PROP_INDEPENDENT
flag even if playback and record are not independent; otherwise
AUDIO_GETINFO ioctl may return false parameters on devices like
envy(4) that don't use the same number of channels for playback
and recording.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.11 2008/11/29 18:32:18 ratchov Exp $	*/
d670 1
a670 1
		enc->precision = 32;
d707 1
a707 1
		p->precision = 32;
d712 1
a712 1
		r->precision = 32;
@


1.11
log
@use the the correct register mask. Fixes certain mixer settings
being unreachable.
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.10 2008/10/25 22:30:43 jakemsr Exp $	*/
d1048 1
a1048 1
	return AUDIO_PROP_FULLDUPLEX;
@


1.10
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.9 2008/04/30 17:31:26 ratchov Exp $	*/
d400 1
a400 1
	mask = ENVY_MT_INSEL_MASK << shift;
@


1.9
log
@don't stop both play and record in envy_halt_input() ad envy_halt_output()

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.8 2008/04/21 00:32:43 jakemsr Exp $	*/
d691 1
a691 1
		return EINVAL;
@


1.8
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.7 2008/02/21 01:41:04 ratchov Exp $	*/
d816 1
a816 1
	bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_CTL, 0);
d828 1
a828 1
	bus_space_write_1(sc->mt_iot, sc->mt_ioh, ENVY_MT_CTL, 0);
@


1.7
log
@since now we have volume knobs, use next/prev pointers to attach
outputs.lineN.source to them. Rename various labels to use "standard" names,
ie AudioNxxx macros.

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.6 2008/02/21 01:37:55 ratchov Exp $	*/
d123 1
@


1.6
log
@implement AK4524 input and output volume knobs and output mute switches.
There are 8 gain knobs but only 4 mute switches because each codec has two
channels but only one mute switch.

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.5 2008/01/14 01:23:53 jakemsr Exp $	*/
d845 1
a845 1
		AudioCinputs, AudioCoutputs, "source", AudioCmonitor 
a846 1
	/* XXX: define AudioCsource */
d863 2
a864 1
		dev->mixer_class = ENVY_MIX_CLASSMIX;
d868 1
a868 1
			    MAX_AUDIO_DEV_LEN, "in%d", i);
d878 2
a879 1
		snprintf(dev->label.name, MAX_AUDIO_DEV_LEN, "out%d", out);
d900 2
a901 1
		snprintf(dev->label.name, MAX_AUDIO_DEV_LEN, "line%d", out);
d909 1
d912 2
a913 1
		snprintf(dev->label.name, MAX_AUDIO_DEV_LEN, "line%d", out);
d922 1
a922 1
		strlcpy(dev->un.e.member[0].label.name, "off", 
d925 1
a925 1
		strlcpy(dev->un.e.member[1].label.name, "on", 
d929 1
a929 1
		    "mute%u-%u", 2 * out, 2 * out + 1);
@


1.5
log
@protect against an invalid device index possibly leading to kernel
crash.  inspired by deanna's similar bug fix in ac97.

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.4 2007/12/08 10:01:28 ratchov Exp $	*/
d236 1
d305 5
d474 1
a474 1
	*val = 0x7f - ((reg) & 0x7f);
d882 1
a882 1
	if (dev->index < ENVY_MIX_INVAL) {
d893 35
d950 1
a950 1
	if (ctl->dev <  ENVY_MIX_INVAL) {
d957 20
d1004 1
a1004 1
	if (ctl->dev <  ENVY_MIX_INVAL) {
d1011 24
@


1.4
log
@there should be 10 stereo or 20 mono knobs (but not 20 stereo!).
Fix this by changing monitor knobs to be mono (as all other knobs are).
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.3 2007/12/08 09:59:33 ratchov Exp $	*/
d842 3
@


1.3
log
@mixer_devinfo->type is uninitialized for classes
@
text
@d1 1
a1 1
/*	$OpenBSD: envy.c,v 1.2 2007/10/28 18:25:21 fgsch Exp $	*/
d64 1
a64 1
void envy_mon_getvol(struct envy_softc *, int, int *, int *);
d463 1
a463 1
envy_mon_getvol(struct envy_softc *sc, int idx, int *l, int *r) {
d467 2
a468 3
	reg = bus_space_read_2(sc->mt_iot, sc->mt_ioh, ENVY_MT_MONDATA);
	*l = 0x7f - ((reg) & 0x7f);
	*r = 0x7f - ((reg >> 8) & 0x7f);
d472 1
a472 1
envy_mon_setvol(struct envy_softc *sc, int idx, int l, int r) {
d476 3
a478 3
	reg = (0x7f - l) | ((0x7f - r) << 8);
	DPRINTF("%s: mon=%d <- %d,%d\n", DEVNAME(sc), reg, l, r);
	bus_space_write_2(sc->mt_iot, sc->mt_ioh, ENVY_MT_MONDATA, reg);
d878 1
a878 1
		dev->un.v.num_channels = 2;
d891 1
a891 1
	int out, l, r;
d908 3
a910 4
		envy_mon_getvol(sc, out, &l, &r);
		ctl->un.value.num_channels = 2;
		ctl->un.value.level[0] = 2 * l;
		ctl->un.value.level[1] = 2 * r;
d920 1
a920 1
	int out, maxsrc, l, r;
d942 1
a942 1
		if (ctl->un.value.num_channels != 2) {
d945 2
a946 3
		l = ctl->un.value.level[0] / 2;
		r = ctl->un.value.level[1] / 2;
		envy_mon_setvol(sc, out, l, r);
@


1.2
log
@id tags.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d846 1
@


1.1
log
@add new envy(4) driver for ICE1712 (aka VIA Envy24) audio devices. The
device uses 32bit samples, up to 96kHz sample rate, 12 input channels and 10
output channels. Currently AK4524 codecs are supported, so M-Audio Delta
cards should work. Playback and capture work, but the mixer is still
incomplete.

ok jakemsr@@
@
text
@d1 1
@

