head	1.53;
access;
symbols
	OPENBSD_6_1:1.53.0.24
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.53.0.26
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.53.0.14
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.53.0.22
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.53.0.20
	OPENBSD_5_7_BASE:1.53
	OPENBSD_5_6:1.53.0.18
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.53.0.16
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.53.0.12
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.53.0.10
	OPENBSD_5_3_BASE:1.53
	OPENBSD_5_2:1.53.0.8
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.6
	OPENBSD_5_0:1.53.0.4
	OPENBSD_5_0_BASE:1.53
	OPENBSD_4_9:1.53.0.2
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.52.0.28
	OPENBSD_4_8_BASE:1.52
	OPENBSD_4_7:1.52.0.24
	OPENBSD_4_7_BASE:1.52
	OPENBSD_4_6:1.52.0.26
	OPENBSD_4_6_BASE:1.52
	OPENBSD_4_5:1.52.0.22
	OPENBSD_4_5_BASE:1.52
	OPENBSD_4_4:1.52.0.20
	OPENBSD_4_4_BASE:1.52
	OPENBSD_4_3:1.52.0.18
	OPENBSD_4_3_BASE:1.52
	OPENBSD_4_2:1.52.0.16
	OPENBSD_4_2_BASE:1.52
	OPENBSD_4_1:1.52.0.14
	OPENBSD_4_1_BASE:1.52
	OPENBSD_4_0:1.52.0.12
	OPENBSD_4_0_BASE:1.52
	OPENBSD_3_9:1.52.0.10
	OPENBSD_3_9_BASE:1.52
	OPENBSD_3_8:1.52.0.8
	OPENBSD_3_8_BASE:1.52
	OPENBSD_3_7:1.52.0.6
	OPENBSD_3_7_BASE:1.52
	OPENBSD_3_6:1.52.0.4
	OPENBSD_3_6_BASE:1.52
	SMP_SYNC_A:1.52
	SMP_SYNC_B:1.52
	OPENBSD_3_5:1.52.0.2
	OPENBSD_3_5_BASE:1.52
	OPENBSD_3_4:1.50.0.2
	OPENBSD_3_4_BASE:1.50
	UBC_SYNC_A:1.49
	OPENBSD_3_3:1.48.0.2
	OPENBSD_3_3_BASE:1.48
	OPENBSD_3_2:1.45.0.2
	OPENBSD_3_2_BASE:1.45
	OPENBSD_3_1:1.42.0.2
	OPENBSD_3_1_BASE:1.42
	UBC_SYNC_B:1.45
	UBC:1.40.0.2
	UBC_BASE:1.40
	OPENBSD_3_0:1.37.0.2
	OPENBSD_3_0_BASE:1.37
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.4
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.17.0.2
	OPENBSD_2_7_BASE:1.17
	SMP:1.3.0.6
	SMP_BASE:1.3
	kame_19991208:1.3;
locks; strict;
comment	@ * @;


1.53
date	2010.12.15.23.34.23;	author mikeb;	state Exp;
branches;
next	1.52;

1.52
date	2004.01.20.21.01.55;	author jason;	state Exp;
branches
	1.52.24.1
	1.52.28.1;
next	1.51;

1.51
date	2003.10.09.03.47.20;	author jason;	state Exp;
branches;
next	1.50;

1.50
date	2003.06.02.15.58.42;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2003.05.13.18.55.23;	author jmc;	state Exp;
branches;
next	1.48;

1.48
date	2003.02.24.20.36.02;	author jason;	state Exp;
branches;
next	1.47;

1.47
date	2003.02.17.16.48.22;	author jason;	state Exp;
branches;
next	1.46;

1.46
date	2003.01.05.20.07.44;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2002.07.23.17.50.33;	author jason;	state Exp;
branches;
next	1.44;

1.44
date	2002.07.21.19.55.33;	author jason;	state Exp;
branches;
next	1.43;

1.43
date	2002.07.21.19.08.26;	author jason;	state Exp;
branches;
next	1.42;

1.42
date	2002.04.08.17.49.42;	author jason;	state Exp;
branches;
next	1.41;

1.41
date	2002.01.08.23.17.24;	author jason;	state Exp;
branches;
next	1.40;

1.40
date	2001.11.12.18.04.06;	author jason;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2001.11.04.18.31.42;	author jason;	state Exp;
branches;
next	1.37;

1.37
date	2001.08.28.21.40.54;	author jason;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2001.08.28.18.52.16;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	2001.08.27.21.57.52;	author jason;	state Exp;
branches;
next	1.34;

1.34
date	2001.08.22.16.34.47;	author jason;	state Exp;
branches;
next	1.33;

1.33
date	2001.08.17.17.37.12;	author ben;	state Exp;
branches;
next	1.32;

1.32
date	2001.08.11.06.40.35;	author jason;	state Exp;
branches;
next	1.31;

1.31
date	2001.08.08.03.46.44;	author jason;	state Exp;
branches;
next	1.30;

1.30
date	2001.08.08.03.11.47;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2001.07.21.03.08.57;	author jason;	state Exp;
branches;
next	1.28;

1.28
date	2001.07.08.18.05.42;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.27.03.33.53;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.26.03.43.26;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.24.19.31.50;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.24.17.43.29;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.23.00.25.38;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.22.23.53.52;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.14.02.45.19;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.13.23.39.54;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.13.15.39.27;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.02.22.36.45;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2000.05.08.17.21.46;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.14.13.59.51;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.13.22.38.09;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.13.22.34.09;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.13.20.55.34;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.11.19.59.06;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.10.18.40.47;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.04.20.16.33;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.29.22.39.39;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.29.21.03.11;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.29.20.54.59;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.22.15.49.51;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.22.03.57.57;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.16.20.33.48;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.02.24.06.09.45;	author deraadt;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	99.02.21.00.05.15;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.02.19.02.52.20;	author deraadt;	state Exp;
branches;
next	;

1.3.6.1
date	2000.03.24.09.09.17;	author niklas;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2001.05.14.22.25.42;	author niklas;	state Exp;
branches;
next	1.3.6.3;

1.3.6.3
date	2001.07.04.10.42.08;	author niklas;	state Exp;
branches;
next	1.3.6.4;

1.3.6.4
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.3.6.5;

1.3.6.5
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.3.6.6;

1.3.6.6
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.3.6.7;

1.3.6.7
date	2003.03.28.00.38.21;	author niklas;	state Exp;
branches;
next	1.3.6.8;

1.3.6.8
date	2003.05.16.00.29.41;	author niklas;	state Exp;
branches;
next	1.3.6.9;

1.3.6.9
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.3.6.10;

1.3.6.10
date	2004.02.19.10.56.26;	author niklas;	state Exp;
branches;
next	;

1.37.2.1
date	2001.11.13.17.23.55;	author jason;	state Exp;
branches;
next	;

1.40.2.1
date	2002.01.31.22.55.35;	author niklas;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.40.2.3;

1.40.2.3
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	1.40.2.4;

1.40.2.4
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;

1.52.24.1
date	2010.12.20.14.08.40;	author jasper;	state Exp;
branches;
next	;

1.52.28.1
date	2010.12.17.16.25.14;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.53
log
@Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.

Original commit message by angelos:

Don't keep the last blocksize-bytes of ciphertext for use as the next
plaintext's IV, in CBC mode. Use arc4random() to acquire fresh IVs per
message.

with and ok deraadt, ok markus, djm
@
text
@/*	$OpenBSD: hifn7751var.h,v 1.52 2004/01/20 21:01:55 jason Exp $	*/

/*
 * Invertex AEON / Hifn 7751 driver
 * Copyright (c) 1999 Invertex Inc. All rights reserved.
 * Copyright (c) 1999 Theo de Raadt
 * Copyright (c) 2000-2001 Network Security Technologies, Inc.
 *			http://www.netsec.net
 *
 * Please send any comments, feedback, bug-fixes, or feature requests to
 * software@@invertex.com.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

#ifndef __HIFN7751VAR_H__
#define __HIFN7751VAR_H__

#ifdef _KERNEL

/*
 *  Some configurable values for the driver
 */
#define	HIFN_D_CMD_RSIZE	24	/* command descriptors */
#define	HIFN_D_SRC_RSIZE	80	/* source descriptors */
#define	HIFN_D_DST_RSIZE	80	/* destination descriptors */
#define	HIFN_D_RES_RSIZE	24	/* result descriptors */

/*
 *  Length values for cryptography
 */
#define HIFN_DES_KEY_LENGTH		8
#define HIFN_3DES_KEY_LENGTH		24
#define HIFN_MAX_CRYPT_KEY_LENGTH	HIFN_3DES_KEY_LENGTH
#define HIFN_IV_LENGTH			8
#define HIFN_AES_IV_LENGTH		16
#define	HIFN_MAX_IV_LENGTH		HIFN_AES_IV_LENGTH

/*
 *  Length values for authentication
 */
#define HIFN_MAC_KEY_LENGTH		64
#define HIFN_MD5_LENGTH			16
#define HIFN_SHA1_LENGTH		20
#define HIFN_MAC_TRUNC_LENGTH		12

#define MAX_SCATTER 64

/*
 * Data structure to hold all 4 rings and any other ring related data.
 */
struct hifn_dma {
	/*
	 *  Descriptor rings.  We add +1 to the size to accommodate the
	 *  jump descriptor.
	 */
	struct hifn_desc	cmdr[HIFN_D_CMD_RSIZE+1];
	struct hifn_desc	srcr[HIFN_D_SRC_RSIZE+1];
	struct hifn_desc	dstr[HIFN_D_DST_RSIZE+1];
	struct hifn_desc	resr[HIFN_D_RES_RSIZE+1];

	struct hifn_command	*hifn_commands[HIFN_D_RES_RSIZE];

	u_char			command_bufs[HIFN_D_CMD_RSIZE][HIFN_MAX_COMMAND];
	u_char			result_bufs[HIFN_D_CMD_RSIZE][HIFN_MAX_RESULT];
	u_int32_t		slop[HIFN_D_CMD_RSIZE];

	u_int64_t		test_src, test_dst;

	/*
	 *  Our current positions for insertion and removal from the descriptor
	 *  rings. 
	 */
	int			cmdi, srci, dsti, resi;
	volatile int		cmdu, srcu, dstu, resu;
	int			cmdk, srck, dstk, resk;
};

struct hifn_session {
	int hs_used;
};

#define	HIFN_RING_SYNC(sc, r, i, f)					\
	bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_dmamap,		\
	    offsetof(struct hifn_dma, r[i]), sizeof(struct hifn_desc), (f))

#define	HIFN_CMDR_SYNC(sc, i, f)	HIFN_RING_SYNC((sc), cmdr, (i), (f))
#define	HIFN_RESR_SYNC(sc, i, f)	HIFN_RING_SYNC((sc), resr, (i), (f))
#define	HIFN_SRCR_SYNC(sc, i, f)	HIFN_RING_SYNC((sc), srcr, (i), (f))
#define	HIFN_DSTR_SYNC(sc, i, f)	HIFN_RING_SYNC((sc), dstr, (i), (f))

#define	HIFN_CMD_SYNC(sc, i, f)						\
	bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_dmamap,		\
	    offsetof(struct hifn_dma, command_bufs[(i)][0]),		\
	    HIFN_MAX_COMMAND, (f))

#define	HIFN_RES_SYNC(sc, i, f)						\
	bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_dmamap,		\
	    offsetof(struct hifn_dma, result_bufs[(i)][0]),		\
	    HIFN_MAX_RESULT, (f))

/*
 * Holds data specific to a single HIFN board.
 */
struct hifn_softc {
	struct device	sc_dv;		/* generic device */
	void *		sc_ih;		/* interrupt handler cookie */
	u_int32_t	sc_dmaier;
	u_int32_t	sc_drammodel;	/* 1=dram, 0=sram */

	bus_space_handle_t	sc_sh0, sc_sh1;
	bus_space_tag_t		sc_st0, sc_st1;
	bus_dma_tag_t		sc_dmat;

	struct hifn_dma *sc_dma;
	bus_dmamap_t sc_dmamap;
	bus_dma_segment_t sc_dmasegs[1];
	int sc_dmansegs;
	int32_t sc_cid;
	int sc_maxses;
	int sc_nsessions;
	int sc_ramsize;
	int sc_flags;
#define	HIFN_HAS_RNG		0x01	/* includes random number generator */
#define	HIFN_HAS_PUBLIC		0x02	/* includes public key support */
#define	HIFN_IS_7811		0x04	/* Hifn 7811 part */
#define	HIFN_NO_BURSTWRITE	0x08	/* can't handle PCI burst writes */
#define	HIFN_HAS_LEDS		0x10	/* Has LEDs to blink */
#define	HIFN_HAS_AES		0x20	/* includes AES support */
#define	HIFN_IS_7956		0x40	/* Hifn 7955/7956 part */
	struct timeout sc_rngto, sc_tickto;
	int sc_rngfirst;
	int sc_rnghz;
	int sc_c_busy, sc_s_busy, sc_d_busy, sc_r_busy, sc_active;
	struct hifn_session *sc_sessions;
	pci_chipset_tag_t sc_pci_pc;
	pcitag_t sc_pci_tag;
	bus_size_t sc_waw_lastreg;
	int sc_waw_lastgroup;
};

#define WRITE_REG_0(sc,reg,val)		hifn_write_4((sc), 0, (reg), (val))
#define WRITE_REG_1(sc,reg,val)		hifn_write_4((sc), 1, (reg), (val))
#define	READ_REG_0(sc,reg)		hifn_read_4((sc), 0, (reg))
#define	READ_REG_1(sc,reg)		hifn_read_4((sc), 1, (reg))

#define	SET_LED(sc,v)							\
	if (sc->sc_flags & HIFN_HAS_LEDS)				\
		WRITE_REG_1(sc, HIFN_1_7811_MIPSRST,			\
		    READ_REG_1(sc, HIFN_1_7811_MIPSRST) | (v))
#define	CLR_LED(sc,v)							\
	if (sc->sc_flags & HIFN_HAS_LEDS)				\
		WRITE_REG_1(sc, HIFN_1_7811_MIPSRST,			\
		    READ_REG_1(sc, HIFN_1_7811_MIPSRST) & ~(v))

/*
 *  struct hifn_command
 *
 *  This is the control structure used to pass commands to hifn_encrypt().
 *
 *  flags
 *  -----
 *  Flags is the bitwise "or" values for command configuration.  A single
 *  encrypt direction needs to be set:
 *
 *	HIFN_ENCODE or HIFN_DECODE
 *
 *  To use cryptography, a single crypto algorithm must be included:
 *
 *	HIFN_CRYPT_3DES or HIFN_CRYPT_DES
 *
 *  To use authentication, a single MAC algorithm must be included:
 *
 *	HIFN_MAC_MD5 or HIFN_MAC_SHA1
 *
 *  By default MD5 uses a 16 byte hash and SHA-1 uses a 20 byte hash.
 *  If the value below is set, hash values are truncated or assumed
 *  truncated to 12 bytes:
 *
 *	HIFN_MAC_TRUNC
 *
 *  Keys for encryption and authentication can be sent as part of a command,
 *  or the last key value used with a particular session can be retrieved
 *  and used again if either of these flags are not specified.
 *
 *	HIFN_CRYPT_NEW_KEY, HIFN_MAC_NEW_KEY
 *
 *  session_num
 *  -----------
 *  A number between 0 and 2048 (for DRAM models) or a number between 
 *  0 and 768 (for SRAM models).  Those who don't want to use session
 *  numbers should leave value at zero and send a new crypt key and/or
 *  new MAC key on every command.  If you use session numbers and
 *  don't send a key with a command, the last key sent for that same
 *  session number will be used.
 *
 *  Warning:  Using session numbers and multiboard at the same time
 *            is currently broken.
 *
 *  mbuf
 *  ----
 *  Either fill in the mbuf pointer and npa=0 or
 *	 fill packp[] and packl[] and set npa to > 0
 * 
 *  mac_header_skip
 *  ---------------
 *  The number of bytes of the source_buf that are skipped over before
 *  authentication begins.  This must be a number between 0 and 2^16-1
 *  and can be used by IPsec implementers to skip over IP headers.
 *  *** Value ignored if authentication not used ***
 *
 *  crypt_header_skip
 *  -----------------
 *  The number of bytes of the source_buf that are skipped over before
 *  the cryptographic operation begins.  This must be a number between 0
 *  and 2^16-1.  For IPsec, this number will always be 8 bytes larger
 *  than the auth_header_skip (to skip over the ESP header).
 *  *** Value ignored if cryptography not used ***
 *
 */
struct hifn_command {
	u_int16_t session_num;
	u_int16_t base_masks, cry_masks, mac_masks, comp_masks;
	u_int8_t iv[HIFN_MAX_IV_LENGTH], *ck, mac[HIFN_MAC_KEY_LENGTH];
	int cklen;
	int sloplen, slopidx;

	union {
		struct mbuf *src_m;
		struct uio *src_io;
	} srcu;
	bus_dmamap_t src_map;

	union {
		struct mbuf *dst_m;
		struct uio *dst_io;
	} dstu;
	bus_dmamap_t dst_map;

	struct hifn_softc *softc;
	struct cryptop *crp;
	struct cryptodesc *enccrd, *maccrd, *compcrd;
	void (*cmd_callback)(struct hifn_softc *, struct hifn_command *,
	    u_int8_t *);
};

/*
 *  Return values for hifn_crypto()
 */
#define HIFN_CRYPTO_SUCCESS	0
#define HIFN_CRYPTO_BAD_INPUT	(-1)
#define HIFN_CRYPTO_RINGS_FULL	(-2)

/**************************************************************************
 *
 *  Function:  hifn_crypto
 *
 *  Purpose:   Called by external drivers to begin an encryption on the
 *             HIFN board.
 *
 *  Blocking/Non-blocking Issues
 *  ============================
 *  The driver cannot block in hifn_crypto (no calls to tsleep) currently.
 *  hifn_crypto() returns HIFN_CRYPTO_RINGS_FULL if there is not enough
 *  room in any of the rings for the request to proceed.
 *
 *  Return Values
 *  =============
 *  0 for success, negative values on error
 *
 *  Defines for negative error codes are:
 *  
 *    HIFN_CRYPTO_BAD_INPUT  :  The passed in command had invalid settings.
 *    HIFN_CRYPTO_RINGS_FULL :  All DMA rings were full and non-blocking
 *                              behaviour was requested.
 *
 *************************************************************************/

/*
 * Convert back and forth from 'sid' to 'card' and 'session'
 */
#define HIFN_CARD(sid)		(((sid) & 0xf0000000) >> 28)
#define HIFN_SESSION(sid)	((sid) & 0x000007ff)
#define HIFN_SID(crd,ses)	(((crd) << 28) | ((ses) & 0x7ff))

#endif /* _KERNEL */

struct hifn_stats {
	u_int64_t hst_ibytes;
	u_int64_t hst_obytes;
	u_int32_t hst_ipackets;
	u_int32_t hst_opackets;
	u_int32_t hst_invalid;
	u_int32_t hst_nomem;
	u_int32_t hst_abort;
};

#endif /* __HIFN7751VAR_H__ */
@


1.52
log
@don't limit the number of sessions to the onboard ram (always upload the
key and IV data).  This kinda sucks for HMAC, but the alternative is
a cache manager and I just don't want to go there.  Tested by sturm@@ (thanks!)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.51 2003/10/09 03:47:20 jason Exp $	*/
a106 1
	u_int8_t hs_iv[HIFN_MAX_IV_LENGTH];
@


1.52.24.1
log
@Backport from -current, original commit by mikeb@@:
------
Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.
------
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.52 2004/01/20 21:01:55 jason Exp $	*/
d107 1
@


1.52.28.1
log
@Backport from -current, original commit by mikeb@@:
------
Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.
------

ok deraadt@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.52 2004/01/20 21:01:55 jason Exp $	*/
d107 1
@


1.51
log
@- from freebsd: 795[56] AES support
- don't bother with the master/mmio enable stuff (it's done in pci.c for us)
based on suggestion from mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.50 2003/06/02 15:58:42 deraadt Exp $	*/
d106 1
a106 2
	int hs_state;
	int hs_prev_op; /* XXX collapse into hs_flags? */
a109 5
/* We use a state machine on sessions */
#define	HS_STATE_FREE	0		/* unused session entry */
#define	HS_STATE_USED	1		/* allocated, but key not on card */
#define	HS_STATE_KEY	2		/* allocated and key is on card */

d148 1
d162 1
a162 1
	struct hifn_session sc_sessions[2048];
@


1.50
log
@licence cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.49 2003/05/13 18:55:23 jmc Exp $	*/
d62 2
d108 1
a108 1
	u_int8_t hs_iv[HIFN_IV_LENGTH];
d156 7
a162 5
#define	HIFN_HAS_RNG		1
#define	HIFN_HAS_PUBLIC		2
#define	HIFN_IS_7811		4
#define	HIFN_NO_BURSTWRITE	8
#define	HIFN_HAS_LEDS		16
d256 1
a256 1
	u_int8_t iv[HIFN_IV_LENGTH], *ck, mac[HIFN_MAC_KEY_LENGTH];
@


1.49
log
@typos from Jean-Francois Brousseau;
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.48 2003/02/24 20:36:02 jason Exp $	*/
a23 1
 *
@


1.48
log
@Add support for LZS compression (only usable by ipcomp at the moment)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.47 2003/02/17 16:48:22 jason Exp $	*/
d79 1
a79 1
	 *  Descriptor rings.  We add +1 to the size to accomidate the
d201 1
a201 1
 *  To use authentication is used, a single MAC algorithm must be included:
@


1.47
log
@whitespace, typos, and compression structure defns
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.46 2003/01/05 20:07:44 deraadt Exp $	*/
d186 1
a186 1
 *  hifn_command_t
d252 1
a252 1
	u_int16_t base_masks, cry_masks, mac_masks;
d271 3
a273 1
	struct cryptodesc *enccrd, *maccrd;
@


1.46
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.45 2002/07/23 17:50:33 jason Exp $	*/
d110 5
a132 5

/* We use a state machine to on sessions */
#define	HS_STATE_FREE	0		/* unused session entry */
#define	HS_STATE_USED	1		/* allocated, but key not on card */
#define	HS_STATE_KEY	2		/* allocated and key is on card */
@


1.45
log
@Turn READ/WRITE into function calls (driver was getting too bloated with
inline macro's; if hifn wanted to make it possible to write a very efficient
driver they would have fixed the bugs in the chips).  Also, invalidate the
burst write checks when a read is executed.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.44 2002/07/21 19:55:33 jason Exp $	*/
d96 1
a96 1
	 *  Our current positions for insertion and removal from the desriptor
@


1.44
log
@Flip on the LEDs on a 7811 when each of the rings is active (and turn them
off when not), I should really get a life.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.43 2002/07/21 19:08:26 jason Exp $	*/
d171 4
a174 22
#define WRITE_REG_0(sc,reg,val)						\
	do {								\
		if (sc->sc_flags & HIFN_NO_BURSTWRITE)			\
			hifn_write_waw_4((sc), 0, (reg), (val));	\
		else							\
			bus_space_write_4((sc)->sc_st0, (sc)->sc_sh0,	\
			    (reg), (val));				\
	} while (0)

#define WRITE_REG_1(sc,reg,val)						\
	do {								\
		if (sc->sc_flags & HIFN_NO_BURSTWRITE)			\
			hifn_write_waw_4((sc), 1, (reg), (val));	\
		else							\
			bus_space_write_4((sc)->sc_st1, (sc)->sc_sh1,	\
			    (reg), (val));				\
	} while (0)

#define	READ_REG_0(sc,reg) \
    bus_space_read_4((sc)->sc_st0, (sc)->sc_sh0, reg)
#define	READ_REG_1(sc,reg) \
    bus_space_read_4((sc)->sc_st1, (sc)->sc_sh1, reg)
@


1.43
log
@Deal with the fact that one of the 7811 revisions cannot correctly handle
burst writes (bridges may coalesce sequential writes into a burst) by
inserting a read (I know, icky!) in between sequential writes.  Thanks
to sam@@errno.com, GTGI, and Hifn for helping track this one down.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.42 2002/04/08 17:49:42 jason Exp $	*/
d159 1
d193 9
@


1.42
log
@Credit DARPA/USAF appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.41 2002/01/08 23:17:24 jason Exp $	*/
d158 1
d166 2
d170 18
a187 2
#define	WRITE_REG_0(sc,reg,val) \
    bus_space_write_4((sc)->sc_st0, (sc)->sc_sh0, reg, val)
d190 2
@


1.41
log
@Add support for the Hifn 7811 (Thanks to GTGI for donating the card).
While here, avoid resetting the card so often during the ram probe [speeds up autoconf and simplifies the driver a bit].
Also, add a missing argument to a debugging printf() (no longer ever called because the abort timers are disabled =)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.40 2001/11/12 18:04:06 jason Exp $	*/
d36 4
@


1.40
log
@Don't abuse bus_dma(9) API by using dmamap->dm_* to hold results from
bus_dmamem_* operations; instead, store them in softc.  This allows
the driver to get through autoconf on sparc64 (ok, well it fails the
ram test because of endian issues... but it's a start).
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.39 2001/11/05 17:25:58 art Exp $	*/
d153 1
@


1.40.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.41 2002/01/08 23:17:24 jason Exp $	*/
a152 1
#define	HIFN_IS_7811		4
@


1.40.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.40.2.1 2002/01/31 22:55:35 niklas Exp $	*/
a35 4
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
@


1.40.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.40.2.2 2002/06/11 03:42:25 art Exp $	*/
a157 2
#define	HIFN_NO_BURSTWRITE	8
#define	HIFN_HAS_LEDS		16
a164 2
	bus_size_t sc_waw_lastreg;
	int sc_waw_lastgroup;
d167 4
a170 13
#define WRITE_REG_0(sc,reg,val)		hifn_write_4((sc), 0, (reg), (val))
#define WRITE_REG_1(sc,reg,val)		hifn_write_4((sc), 1, (reg), (val))
#define	READ_REG_0(sc,reg)		hifn_read_4((sc), 0, (reg))
#define	READ_REG_1(sc,reg)		hifn_read_4((sc), 1, (reg))

#define	SET_LED(sc,v)							\
	if (sc->sc_flags & HIFN_HAS_LEDS)				\
		WRITE_REG_1(sc, HIFN_1_7811_MIPSRST,			\
		    READ_REG_1(sc, HIFN_1_7811_MIPSRST) | (v))
#define	CLR_LED(sc,v)							\
	if (sc->sc_flags & HIFN_HAS_LEDS)				\
		WRITE_REG_1(sc, HIFN_1_7811_MIPSRST,			\
		    READ_REG_1(sc, HIFN_1_7811_MIPSRST) & ~(v))
@


1.40.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d79 1
a79 1
	 *  Descriptor rings.  We add +1 to the size to accommodate the
d96 1
a96 1
	 *  Our current positions for insertion and removal from the descriptor
a109 5
/* We use a state machine on sessions */
#define	HS_STATE_FREE	0		/* unused session entry */
#define	HS_STATE_USED	1		/* allocated, but key not on card */
#define	HS_STATE_KEY	2		/* allocated and key is on card */

d129 5
d186 1
a186 1
 *  struct hifn_command
d201 1
a201 1
 *  To use authentication, a single MAC algorithm must be included:
d252 1
a252 1
	u_int16_t base_masks, cry_masks, mac_masks, comp_masks;
d271 1
a271 3
	struct cryptodesc *enccrd, *maccrd, *compcrd;
	void (*cmd_callback)(struct hifn_softc *, struct hifn_command *,
	    u_int8_t *);
@


1.39
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.38 2001/11/04 18:31:42 jason Exp $	*/
d145 2
@


1.38
log
@7751 has two registers in config space (0x40 - RETRY_TIMEOUT and 0x41,
TRDY_TIMEOUT).  These registers must be initialized to zero to disable
these timers or 7751 will get PCI aborts on its descriptor rings on
certain chipsets.  These timers were removed because they were unneeded
in the 7951.  I'm not sure how I missed this in the datasheet, but there
it is plain as day on page 24.  Thanks go to Hifn for pointing this out.

Upshot: PCI abort problem on 7751 appears to be solved.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.37 2001/08/28 21:40:54 jason Exp $	*/
d107 1
a107 1
	hifn_bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_dmamap,		\
d116 1
a116 1
	hifn_bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_dmamap,		\
d121 1
a121 1
	hifn_bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_dmamap,		\
@


1.37
log
@an attempt at deuglification of the previous commit (It's still ugly, tho)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.36 2001/08/28 18:52:16 jason Exp $	*/
d156 2
@


1.37.2.1
log
@Pull in patch from current:
7751 has two registers in config space (0x40 - RETRY_TIMEOUT and 0x41,
TRDY_TIMEOUT).  These registers must be initialized to zero to disable
these timers or 7751 will get PCI aborts on its descriptor rings on
certain chipsets.  These timers were removed because they were unneeded
in the 7951.  I'm not sure how I missed this in the datasheet, but there
it is plain as day on page 24.  Thanks go to Hifn for pointing this out.

Upshot: PCI abort problem on 7751 appears to be solved.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.37 2001/08/28 21:40:54 jason Exp $	*/
a155 2
	pci_chipset_tag_t sc_pci_pc;
	pcitag_t sc_pci_tag;
@


1.36
log
@Relax restriction on buffer length being % 4 = 0 for the last entry in the
chain.  This allows us to avoid mbuf copies (and EINVAL on iov's) for
packets of non "nice" length.  Do this by adding a pad u_int32_t to
catch the (possible) overflow and detecting when it's necessary.  Also,
do a bit of cleaning that ben pointed out.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.35 2001/08/27 21:57:52 jason Exp $	*/
d233 1
a233 2
	int sloplen;		/* length of end buffer */
	caddr_t slop;		/* pointer to end buffer */
@


1.35
log
@Deal with __HAS_NEW_BUS_DMAMAP_SYNC and try to sync partial maps when possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.34 2001/08/22 16:34:47 jason Exp $	*/
d85 3
a87 2
	u_char	command_bufs[HIFN_D_CMD_RSIZE][HIFN_MAX_COMMAND];
	u_char	result_bufs[HIFN_D_CMD_RSIZE][HIFN_MAX_RESULT];
d89 1
a89 1
	u_int64_t	test_src, test_dst;
d95 3
a97 3
	int		cmdi, srci, dsti, resi;
	volatile int	cmdu, srcu, dstu, resu;
	int		cmdk, srck, dstk, resk;
d233 2
@


1.34
log
@rename hs_flags -> hs_state and use #defines for the state names.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.33 2001/08/17 17:37:12 ben Exp $	*/
d104 19
@


1.33
log
@Add RC4 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.32 2001/08/11 06:40:35 jason Exp $	*/
d100 1
a100 1
	int hs_flags;
d104 5
@


1.32
log
@move hifn_stats definition to header
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.31 2001/08/08 03:46:44 jason Exp $	*/
d101 1
@


1.31
log
@leave the dma engines polling for a bit after the last descriptor has been
passed through.  After a few seconds (5 currently) of no activity, stop them
completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.30 2001/08/08 03:11:47 jason Exp $	*/
d42 2
a231 2
#ifdef _KERNEL

d265 10
@


1.30
log
@Initial support for RC4 operations (This probably won't work yet as
the caller of *_process() doesn't seem to initialize crd_klen correctly;
it has a zero value... still debugging...).
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.29 2001/07/21 03:08:57 jason Exp $	*/
d123 1
a123 1
	struct timeout sc_rngto;
d126 1
a126 1
	int sc_c_busy, sc_s_busy, sc_d_busy, sc_r_busy;
@


1.29
log
@- Clear all interrupts during initialization (shouldn't be necessary, but
doesn't hurt).
- Turn the dma queues on and off as needed.  This results in fewer PCI
aborts on 7751.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.28 2001/07/08 18:05:42 brad Exp $	*/
d204 1
@


1.28
log
@Hifn has changed its company name, make the name consistent throughout
the tree. Hi/fn, Hi/Fn and HiFn -> Hifn.
--
Ok'd by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.27 2001/06/27 03:33:53 angelos Exp $	*/
d126 1
@


1.27
log
@"IPsec" capitalization (jsyn@@nthought.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.26 2001/06/26 03:43:26 jason Exp $	*/
d4 1
a4 1
 * Invertex AEON / Hi/fn 7751 driver
@


1.26
log
@move bus access to var where it belongs
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.25 2001/06/24 19:31:50 jason Exp $	*/
d187 1
a187 1
 *  and can be used by IPSec implementers to skip over IP headers.
d194 1
a194 1
 *  and 2^16-1.  For IPSec, this number will always be 8 bytes larger
@


1.25
log
@Remove some redundent copies of the total length/skip values and use the
descriptors passed in instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.24 2001/06/24 17:43:29 jason Exp $	*/
d128 5
@


1.24
log
@reflect reality more closely and remove more invertex stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.23 2001/06/23 00:25:38 jason Exp $	*/
a210 3
	u_int16_t crypt_header_skip, mac_header_skip;
	u_int32_t crypt_process_len, mac_process_len;

d213 1
@


1.23
log
@- put hw defines in *reg, software defines in *var, etc
- clean up pub/rng initialization call
- attempt to remove more intertex vestiges
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.22 2001/06/22 23:53:52 jason Exp $	*/
a160 13
 *  result_flags
 *  ------------
 *  result_flags is a bitwise "or" of result values.  The result_flags
 *  values should not be considered valid until:
 *
 *	callback routine NULL:  hifn_crypto() returns
 *	callback routine set:   callback routine called
 *
 *  Right now there is only one result flag:  HIFN_MAC_BAD
 *  It's bit is set on decode operations using authentication when a
 *  hash result does not match the input hash value.
 *  The HIFN_MAC_OK(r) macro can be used to help inspect this flag.
 *
a192 30
 *  source_length
 *  -------------
 *  Length of input data including all skipped headers.  On decode
 *  operations using authentication, the length must also include the
 *  the appended MAC hash (12, 16, or 20 bytes depending on algorithm
 *  and truncation settings).
 *
 *  If encryption is used, the encryption payload must be a non-zero
 *  multiple of 8.  On encode operations, the encryption payload size
 *  is (source_length - crypt_header_skip - (MAC hash size)).  On
 *  decode operations, the encryption payload is
 *  (source_length - crypt_header_skip).
 *
 *  dest_length
 *  -----------
 *  Length of the dest buffer.  It must be at least as large as the
 *  source buffer when authentication is not used.  When authentication
 *  is used on an encode operation, it must be at least as long as the
 *  source length plus an extra 12, 16, or 20 bytes to hold the MAC
 *  value (length of mac value varies with algorithm used).  When
 *  authentication is used on decode operations, it must be at least
 *  as long as the source buffer minus 12, 16, or 20 bytes for the MAC
 *  value which is not included in the dest data.  Unlike source_length,
 *  the dest_length does not have to be exact, values larger than required
 *  are fine.
 *
 *  private_data
 *  ------------
 *  An unsigned long quantity (i.e. large enough to hold a pointer), that
 *  can be used by the callback routine if desired.
d194 2
a195 4
typedef struct hifn_command {
	volatile u_int result_flags;

	u_short	session_num;
d197 1
d199 4
a202 4
	u_char	iv[HIFN_IV_LENGTH], *ck, mac[HIFN_MAC_KEY_LENGTH];

	struct mbuf *src_m;
	struct uio *src_io;
d205 4
a208 2
	struct mbuf *dst_m;
	struct uio *dst_io;
a213 1
	u_long private_data;
d216 1
a216 1
} hifn_command_t;
a223 6

/*
 *  Defines for the "result_flags" parameter of hifn_command_t.
 */
#define HIFN_MAC_BAD		1
#define HIFN_MAC_OK(r)		(!((r) & HIFN_MAC_BAD))
@


1.22
log
@Fix lotsa bugs:
- Hi/Fn length fields in command structures are 18 bits (feature!), but
descriptor lengths are 16 bits.
- define dmamap maximum lengths correctly (2^18 for total length, 2^16
for segments).
- Make the defines more consistent, and add other modes
- split source_count in command descriptors into a 16 bit length, and 16bit reserved part
upshot: blocks as large as 2^18 - 8 work now for userland crypto
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.21 2001/05/14 02:45:19 deraadt Exp $	*/
d7 1
a7 1
 * Copyright (c) 2000 Network Security Technologies, Inc.
d43 8
d69 61
a236 2
struct hifn_softc;

@


1.21
log
@use real uio
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.20 2001/05/13 23:39:54 jason Exp $	*/
d186 2
a187 2
	u_short mac_header_skip, mac_process_len;
	u_short crypt_header_skip, crypt_process_len;
@


1.20
log
@First try at bus_dma(9)-ifying hifn7751 driver... advantages:
- vtophys is dead
- now builds on alpha
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.19 2001/05/13 15:39:27 deraadt Exp $	*/
d179 1
a179 1
	struct criov *src_io;
d183 1
a183 1
	struct criov *dst_io;
@


1.19
log
@initial cut at /dev/crypto support.  takes original mbuf "try, and discard
if we fail" semantics and extends to two varients of data movement: mbuf,
or an iovec style block.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.18 2000/06/02 22:36:45 deraadt Exp $	*/
d180 1
a180 4
	long	src_packp[MAX_SCATTER];
	int	src_packl[MAX_SCATTER];
	int	src_npa;
	int	src_l;
d184 1
a184 4
	long	dst_packp[MAX_SCATTER];
	int	dst_packl[MAX_SCATTER];
	int	dst_npa;
	int	dst_l;
@


1.18
log
@callback is always static
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.17 2000/05/08 17:21:46 jason Exp $	*/
d179 1
d186 1
d197 1
@


1.17
log
@crank MAX_SCATTER to handle large chain lengths; deraadt ok'd.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.16 2000/04/14 13:59:51 jason Exp $	*/
a162 10
 *  dest_ready_callback
 *  -------------------
 *  Callback routine called from HIFN's interrupt handler.  The routine
 *  must be quick and non-blocking.  The callback routine is passed a
 *  pointer to the same hifn_command_t structure used to initiate the
 *  command.
 *
 *  If this value is null, the hifn_crypto() routine will block until the
 *  dest data is ready.
 *
a192 1
	void (*dest_ready_callback)(struct hifn_softc *, struct hifn_command *, u_int8_t *);
@


1.16
log
@not EXPORT
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.15 2000/04/13 22:38:09 jason Exp $	*/
d58 1
a58 1
#define MAX_SCATTER 10
@


1.15
log
@remove bit definitions and associated macros for hifn_command.flags since it
doesn't exist anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.14 2000/04/13 22:34:09 jason Exp $	*/
d39 2
a40 2
#ifndef __HIFN_EXPORT_H__
#define __HIFN_EXPORT_H__
d257 1
a257 1
#endif /* __HIFN_EXPORT_H__ */
@


1.14
log
@- let hifn_process() compute the mask bits for the command descriptors
(falls under the category of compute it once and use it).
- just copy the computed masks in hifn_write_command()
- remove the now unnecessary flags field from hifn_command
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.13 2000/04/13 20:55:34 jason Exp $	*/
a213 17


/*
 *  Defines for the "config" parameter of hifn_command_t
 */
#define HIFN_ENCODE		0x0001
#define HIFN_DECODE		0x0002
#define HIFN_CRYPT_3DES		0x0004
#define HIFN_CRYPT_DES		0x0008
#define HIFN_MAC_MD5		0x0010
#define HIFN_MAC_SHA1		0x0020
#define HIFN_MAC_TRUNC		0x0040
#define HIFN_CRYPT_NEW_KEY	0x0080
#define HIFN_MAC_NEW_KEY	0x0100

#define HIFN_USING_CRYPT(f)	((f) & (HIFN_CRYPT_3DES|HIFN_CRYPT_DES))
#define HIFN_USING_MAC(f)	((f) & (HIFN_MAC_MD5|HIFN_MAC_SHA1))
@


1.13
log
@remove unnecessary variable
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.12 2000/04/11 19:59:06 jason Exp $	*/
a180 1
	u_int	flags;
d184 1
@


1.12
log
@- add support for buffers that are not aligned (or end on a non 4byte boundary)
- recompute destination length from destination descriptors and reclaim the
  destination ring there.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.11 2000/04/10 18:40:47 jason Exp $	*/
a186 1
	int	ck_len;
@


1.11
log
@- Add back code from the original aeon driver to handle missed interrupts by
enabling interrupts when the command queue has more than one entry.
- fix comment on hifn_newsession to reflect reality
- allocate session structure in softc
- compute a random IV when a session is created and try to chain from a
software kept IV for subsequent packets
- add handling of CRD_F_EXPLICIT
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.10 2000/04/04 20:16:33 jason Exp $	*/
d178 2
d204 1
a204 1
	void (*dest_ready_callback)(struct hifn_command *, u_int8_t *);
@


1.10
log
@add mac result pointer to the callback routine
register as supporting MD5_HMAC96 and SHA1_HMAC96
use the correct bit (HIFN_MAC_CMD_NEW_KEY) when checking the mac_cmd mask
don't append the mac result to the dest buffer, add it to the result buffer
remove incorrect source count calculation involving mac length
add order checking to hifn_process so that we can verify the request is
	possible given the ordering of processing units within the hifn.
correct hifn_callback()'s handling of mac checking and copy the computed
	mac into the right place in the mbuf.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.9 2000/03/29 22:39:39 jason Exp $	*/
d204 1
@


1.9
log
@- update copyrights
- remove all ability to block (no more tsleep/wakeup)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.8 2000/03/29 21:03:11 jason Exp $	*/
d184 2
a185 2
	u_char	iv[HIFN_IV_LENGTH], *ck, *mac;
	int	ck_len, mac_len;
d202 1
a202 1
	void (*dest_ready_callback)(struct hifn_command *);
@


1.8
log
@remove round-robin use of the boards.  We're depending on the upper layer
being more intelligent about allocation in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.7 2000/03/29 20:54:59 jason Exp $	*/
d4 5
a8 2
 *  Invertex AEON / Hi/fn 7751 driver
 *  Copyright (c) 1999 Invertex Inc. All rights reserved.
d10 2
a11 2
 *  Please send any comments, feedback, bug-fixes, or feature requests to
 *  software@@invertex.com.
a91 8
 *  Whether we block or not waiting for the dest data to be ready is
 *  determined by whether a callback function is given.  The other
 *  place we could block is when all the DMA rings are full.  If 
 *  it is not okay to block while waiting for an open slot in the
 *  rings, include in the following value:
 *
 *	HIFN_DMA_FULL_NOBLOCK
 *
a225 1
#define HIFN_DMA_FULL_NOBLOCK	0x0200
d247 3
a249 10
 *  If the dest_ready_callback field of the hifn_command structure
 *  is NULL, hifn_encrypt will block until the dest_data is ready --
 *  otherwise hifn_encrypt() will return immediately and the 
 *  dest_ready_callback routine will be called when the dest data is
 *  ready.
 *
 *  The routine can also block when waiting for an open slot when all
 *  DMA rings are full.  You can avoid this behaviour by sending the
 *  HIFN_DMA_FULL_NOBLOCK as part of the command flags.  This will
 *  make hifn_crypt() return immediately when the rings are full.
@


1.7
log
@Long over due checkpoint:
o register the hifn as handling DES and 3DES (no md5 or sha1 yet) depending
	on whether the board is unlocked (none, half, or full)
o Fix many KNF nits
o print the amount of memory correctly and don't print the number of sessions
o set command and result buffer sizes correctly
o reclaim the descriptor rings so new commands and buffers can be added
o remove some bogus checks on the command buffer
o add new variables mac_process_len and crypt_process_len to hifn_command_t
o fix calculation in hifn_mbuf to generate the pa/len array for src/dst
o simplify the code for setting up the jump descriptor
o rework the hifn_intr routine to interrupt at IPL_IMP and simplify it's
	results processing
o more to come...
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.6 2000/03/22 15:49:51 jason Exp $	*/
a274 1
int hifn_crypto __P((hifn_command_t *command));
@


1.6
log
@eissed another renamning of result_status -> result_flags
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.5 2000/03/22 03:57:57 jason Exp $	*/
d189 2
a190 2
	u_char	*iv, *ck, *mac;
	int	iv_len, ck_len, mac_len;
d204 2
a205 2
	u_short mac_header_skip;
	u_short crypt_header_skip;
@


1.5
log
@convert some spaces to tabs and make variable names the same as the
surrounding comments
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.4 2000/03/16 20:33:48 deraadt Exp $	*/
d237 1
a237 1
 *  Defines for the "result_status" parameter of hifn_command_t.
@


1.4
log
@move aeon to hifn7751
@
text
@d1 1
a1 1
/*	$OpenBSD: aeonvar.h,v 1.3 1999/02/24 06:09:45 deraadt Exp $	*/
d42 4
a45 4
#define HIFN_DES_KEY_LENGTH         8
#define HIFN_3DES_KEY_LENGTH       24
#define HIFN_MAX_CRYPT_KEY_LENGTH  HIFN_3DES_KEY_LENGTH
#define HIFN_IV_LENGTH              8
d50 4
a53 4
#define HIFN_MAC_KEY_LENGTH   64
#define HIFN_MD5_LENGTH       16
#define HIFN_SHA1_LENGTH      20
#define HIFN_MAC_TRUNC_LENGTH 12
d67 1
a67 1
 *      HIFN_ENCODE or HIFN_DECODE
d71 1
a71 1
 *      HIFN_CRYPT_3DES or HIFN_CRYPT_DES
d75 1
a75 1
 *      HIFN_MAC_MD5 or HIFN_MAC_SHA1
d81 1
a81 1
 *      HIFN_MAC_TRUNC
d87 1
a87 1
 *  HIFN_CRYPT_NEW_KEY, HIFN_MAC_NEW_KEY
d95 1
a95 1
 *      HIFN_DMA_FULL_NOBLOCK
d102 2
a103 2
 *       callback routine NULL:  hifn_crypto() returns
 *       callback routine set:   callback routine called
d122 3
a124 1
 * mbuf: either fill in the mbuf pointer and npa=0 or
d185 1
a185 1
	volatile u_int result_status;
d214 3
a216 3
#define HIFN_CRYPTO_SUCCESS      0
#define HIFN_CRYPTO_BAD_INPUT   -1
#define HIFN_CRYPTO_RINGS_FULL  -2
d222 10
a231 10
#define HIFN_ENCODE           1
#define HIFN_DECODE           2
#define HIFN_CRYPT_3DES       4
#define HIFN_CRYPT_DES        8
#define HIFN_MAC_MD5          16
#define HIFN_MAC_SHA1         32
#define HIFN_MAC_TRUNC        64
#define HIFN_CRYPT_NEW_KEY    128
#define HIFN_MAC_NEW_KEY      256
#define HIFN_DMA_FULL_NOBLOCK 512
d233 2
a234 2
#define HIFN_USING_CRYPT(f) ((f) & (HIFN_CRYPT_3DES|HIFN_CRYPT_DES))
#define HIFN_USING_MAC(f)   ((f) & (HIFN_MAC_MD5|HIFN_MAC_SHA1))
d239 2
a240 2
#define HIFN_MAC_BAD       1
#define HIFN_MAC_OK(r)     !((r) & HIFN_MAC_BAD)
d276 7
@


1.3
log
@handle scatter-gather, seperate src/dst mbuf, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: aeonvar.h,v 1.2 1999/02/21 00:05:15 deraadt Exp $	*/
d4 1
a4 1
 *  Invertex AEON driver
d36 2
a37 2
#ifndef __AEON_EXPORT_H__
#define __AEON_EXPORT_H__
d42 4
a45 4
#define AEON_DES_KEY_LENGTH         8
#define AEON_3DES_KEY_LENGTH       24
#define AEON_MAX_CRYPT_KEY_LENGTH  AEON_3DES_KEY_LENGTH
#define AEON_IV_LENGTH              8
d50 4
a53 4
#define AEON_MAC_KEY_LENGTH   64
#define AEON_MD5_LENGTH       16
#define AEON_SHA1_LENGTH      20
#define AEON_MAC_TRUNC_LENGTH 12
d58 1
a58 1
 *  aeon_command_t
d60 1
a60 1
 *  This is the control structure used to pass commands to aeon_encrypt().
d67 1
a67 1
 *      AEON_ENCODE or AEON_DECODE
d71 1
a71 1
 *      AEON_CRYPT_3DES or AEON_CRYPT_DES
d75 1
a75 1
 *      AEON_MAC_MD5 or AEON_MAC_SHA1
d81 1
a81 1
 *      AEON_MAC_TRUNC
d87 1
a87 1
 *  AEON_CRYPT_NEW_KEY, AEON_MAC_NEW_KEY
d95 1
a95 1
 *      AEON_DMA_FULL_NOBLOCK
d102 1
a102 1
 *       callback routine NULL:  aeon_crypto() returns
d105 1
a105 1
 *  Right now there is only one result flag:  AEON_MAC_BAD
d108 1
a108 1
 *  The AEON_MAC_OK(r) macro can be used to help inspect this flag.
d168 1
a168 1
 *  Callback routine called from AEON's interrupt handler.  The routine
d170 1
a170 1
 *  pointer to the same aeon_command_t structure used to initiate the
d173 1
a173 1
 *  If this value is null, the aeon_crypto() routine will block until the
d181 1
a181 1
typedef struct aeon_command {
d205 1
a205 1
	void (*dest_ready_callback)(struct aeon_command *);
d207 1
a207 1
} aeon_command_t;
d210 1
a210 1
 *  Return values for aeon_crypto()
d212 3
a214 3
#define AEON_CRYPTO_SUCCESS      0
#define AEON_CRYPTO_BAD_INPUT   -1
#define AEON_CRYPTO_RINGS_FULL  -2
d218 1
a218 1
 *  Defines for the "config" parameter of aeon_command_t
d220 10
a229 10
#define AEON_ENCODE           1
#define AEON_DECODE           2
#define AEON_CRYPT_3DES       4
#define AEON_CRYPT_DES        8
#define AEON_MAC_MD5          16
#define AEON_MAC_SHA1         32
#define AEON_MAC_TRUNC        64
#define AEON_CRYPT_NEW_KEY    128
#define AEON_MAC_NEW_KEY      256
#define AEON_DMA_FULL_NOBLOCK 512
d231 2
a232 2
#define AEON_USING_CRYPT(f) ((f) & (AEON_CRYPT_3DES|AEON_CRYPT_DES))
#define AEON_USING_MAC(f)   ((f) & (AEON_MAC_MD5|AEON_MAC_SHA1))
d235 1
a235 1
 *  Defines for the "result_status" parameter of aeon_command_t.
d237 2
a238 2
#define AEON_MAC_BAD       1
#define AEON_MAC_OK(r)     !((r) & AEON_MAC_BAD)
d244 1
a244 1
 *  Function:  aeon_crypto
d247 1
a247 1
 *             AEON board.
d251 3
a253 3
 *  If the dest_ready_callback field of the aeon_command structure
 *  is NULL, aeon_encrypt will block until the dest_data is ready --
 *  otherwise aeon_encrypt() will return immediately and the 
d259 2
a260 2
 *  AEON_DMA_FULL_NOBLOCK as part of the command flags.  This will
 *  make aeon_crypt() return immediately when the rings are full.
d268 2
a269 2
 *    AEON_CRYPTO_BAD_INPUT  :  The passed in command had invalid settings.
 *    AEON_CRYPTO_RINGS_FULL :  All DMA rings were full and non-blocking
d273 1
a273 1
int aeon_crypto __P((aeon_command_t *command));
d277 1
a277 1
#endif /* __AEON_EXPORT_H__ */
@


1.3.6.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 *  Invertex AEON / Hi/fn 7751 driver
d36 2
a37 2
#ifndef __HIFN_EXPORT_H__
#define __HIFN_EXPORT_H__
d42 4
a45 4
#define HIFN_DES_KEY_LENGTH		8
#define HIFN_3DES_KEY_LENGTH		24
#define HIFN_MAX_CRYPT_KEY_LENGTH	HIFN_3DES_KEY_LENGTH
#define HIFN_IV_LENGTH			8
d50 4
a53 4
#define HIFN_MAC_KEY_LENGTH		64
#define HIFN_MD5_LENGTH			16
#define HIFN_SHA1_LENGTH		20
#define HIFN_MAC_TRUNC_LENGTH		12
d58 1
a58 1
 *  hifn_command_t
d60 1
a60 1
 *  This is the control structure used to pass commands to hifn_encrypt().
d67 1
a67 1
 *	HIFN_ENCODE or HIFN_DECODE
d71 1
a71 1
 *	HIFN_CRYPT_3DES or HIFN_CRYPT_DES
d75 1
a75 1
 *	HIFN_MAC_MD5 or HIFN_MAC_SHA1
d81 1
a81 1
 *	HIFN_MAC_TRUNC
d87 1
a87 1
 *	HIFN_CRYPT_NEW_KEY, HIFN_MAC_NEW_KEY
d95 1
a95 1
 *	HIFN_DMA_FULL_NOBLOCK
d102 2
a103 2
 *	callback routine NULL:  hifn_crypto() returns
 *	callback routine set:   callback routine called
d105 1
a105 1
 *  Right now there is only one result flag:  HIFN_MAC_BAD
d108 1
a108 1
 *  The HIFN_MAC_OK(r) macro can be used to help inspect this flag.
d122 1
a122 3
 *  mbuf
 *  ----
 *  Either fill in the mbuf pointer and npa=0 or
d168 1
a168 1
 *  Callback routine called from HIFN's interrupt handler.  The routine
d170 1
a170 1
 *  pointer to the same hifn_command_t structure used to initiate the
d173 1
a173 1
 *  If this value is null, the hifn_crypto() routine will block until the
d181 1
a181 1
typedef struct hifn_command {
d183 1
a183 1
	volatile u_int result_flags;
d205 1
a205 1
	void (*dest_ready_callback)(struct hifn_command *);
d207 1
a207 1
} hifn_command_t;
d210 1
a210 1
 *  Return values for hifn_crypto()
d212 3
a214 3
#define HIFN_CRYPTO_SUCCESS	0
#define HIFN_CRYPTO_BAD_INPUT	(-1)
#define HIFN_CRYPTO_RINGS_FULL	(-2)
d218 1
a218 1
 *  Defines for the "config" parameter of hifn_command_t
d220 10
a229 10
#define HIFN_ENCODE		0x0001
#define HIFN_DECODE		0x0002
#define HIFN_CRYPT_3DES		0x0004
#define HIFN_CRYPT_DES		0x0008
#define HIFN_MAC_MD5		0x0010
#define HIFN_MAC_SHA1		0x0020
#define HIFN_MAC_TRUNC		0x0040
#define HIFN_CRYPT_NEW_KEY	0x0080
#define HIFN_MAC_NEW_KEY	0x0100
#define HIFN_DMA_FULL_NOBLOCK	0x0200
d231 2
a232 2
#define HIFN_USING_CRYPT(f)	((f) & (HIFN_CRYPT_3DES|HIFN_CRYPT_DES))
#define HIFN_USING_MAC(f)	((f) & (HIFN_MAC_MD5|HIFN_MAC_SHA1))
d235 1
a235 1
 *  Defines for the "result_flags" parameter of hifn_command_t.
d237 2
a238 2
#define HIFN_MAC_BAD		1
#define HIFN_MAC_OK(r)		(!((r) & HIFN_MAC_BAD))
d244 1
a244 1
 *  Function:  hifn_crypto
d247 1
a247 1
 *             HIFN board.
d251 3
a253 3
 *  If the dest_ready_callback field of the hifn_command structure
 *  is NULL, hifn_encrypt will block until the dest_data is ready --
 *  otherwise hifn_encrypt() will return immediately and the 
d259 2
a260 2
 *  HIFN_DMA_FULL_NOBLOCK as part of the command flags.  This will
 *  make hifn_crypt() return immediately when the rings are full.
d268 2
a269 2
 *    HIFN_CRYPTO_BAD_INPUT  :  The passed in command had invalid settings.
 *    HIFN_CRYPTO_RINGS_FULL :  All DMA rings were full and non-blocking
d273 1
a273 8
int hifn_crypto __P((hifn_command_t *command));

/*
 * Convert back and forth from 'sid' to 'card' and 'session'
 */
#define HIFN_CARD(sid)		(((sid) & 0xf0000000) >> 28)
#define HIFN_SESSION(sid)	((sid) & 0x000007ff)
#define HIFN_SID(crd,ses)	(((crd) << 28) | ((ses) & 0x7ff))
d277 1
a277 1
#endif /* __HIFN_EXPORT_H__ */
@


1.3.6.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.18 2000/06/02 22:36:45 deraadt Exp $	*/
d4 2
a5 5
 * Invertex AEON / Hi/fn 7751 driver
 * Copyright (c) 1999 Invertex Inc. All rights reserved.
 * Copyright (c) 1999 Theo de Raadt
 * Copyright (c) 2000 Network Security Technologies, Inc.
 *			http://www.netsec.net
d7 2
a8 2
 * Please send any comments, feedback, bug-fixes, or feature requests to
 * software@@invertex.com.
d36 2
a37 2
#ifndef __HIFN7751VAR_H__
#define __HIFN7751VAR_H__
d55 1
a55 1
#define MAX_SCATTER 64
d89 8
d168 10
a182 2
struct hifn_softc;

d184 1
a187 1
	u_int16_t base_masks, cry_masks, mac_masks;
d189 2
a190 1
	u_char	iv[HIFN_IV_LENGTH], *ck, mac[HIFN_MAC_KEY_LENGTH];
d204 2
a205 2
	u_short mac_header_skip, mac_process_len;
	u_short crypt_header_skip, crypt_process_len;
d207 1
a208 1
	struct hifn_softc *softc;
d218 18
d253 10
a262 3
 *  The driver cannot block in hifn_crypto (no calls to tsleep) currently.
 *  hifn_crypto() returns HIFN_CRYPTO_RINGS_FULL if there is not enough
 *  room in any of the rings for the request to proceed.
d275 1
d286 1
a286 1
#endif /* __HIFN7751VAR_H__ */
@


1.3.6.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.3.6.2 2001/05/14 22:25:42 niklas Exp $	*/
d7 1
a7 1
 * Copyright (c) 2000-2001 Network Security Technologies, Inc.
a42 8
 *  Some configurable values for the driver
 */
#define	HIFN_D_CMD_RSIZE	24	/* command descriptors */
#define	HIFN_D_SRC_RSIZE	80	/* source descriptors */
#define	HIFN_D_DST_RSIZE	80	/* destination descriptors */
#define	HIFN_D_RES_RSIZE	24	/* result descriptors */

/*
a60 66
 * Data structure to hold all 4 rings and any other ring related data.
 */
struct hifn_dma {
	/*
	 *  Descriptor rings.  We add +1 to the size to accomidate the
	 *  jump descriptor.
	 */
	struct hifn_desc	cmdr[HIFN_D_CMD_RSIZE+1];
	struct hifn_desc	srcr[HIFN_D_SRC_RSIZE+1];
	struct hifn_desc	dstr[HIFN_D_DST_RSIZE+1];
	struct hifn_desc	resr[HIFN_D_RES_RSIZE+1];

	struct hifn_command	*hifn_commands[HIFN_D_RES_RSIZE];

	u_char	command_bufs[HIFN_D_CMD_RSIZE][HIFN_MAX_COMMAND];
	u_char	result_bufs[HIFN_D_CMD_RSIZE][HIFN_MAX_RESULT];

	u_int64_t	test_src, test_dst;

	/*
	 *  Our current positions for insertion and removal from the desriptor
	 *  rings. 
	 */
	int		cmdi, srci, dsti, resi;
	volatile int	cmdu, srcu, dstu, resu;
	int		cmdk, srck, dstk, resk;
};

struct hifn_session {
	int hs_flags;
	u_int8_t hs_iv[HIFN_IV_LENGTH];
};

/*
 * Holds data specific to a single HIFN board.
 */
struct hifn_softc {
	struct device	sc_dv;		/* generic device */
	void *		sc_ih;		/* interrupt handler cookie */
	u_int32_t	sc_dmaier;
	u_int32_t	sc_drammodel;	/* 1=dram, 0=sram */

	bus_space_handle_t	sc_sh0, sc_sh1;
	bus_space_tag_t		sc_st0, sc_st1;
	bus_dma_tag_t		sc_dmat;

	struct hifn_dma *sc_dma;
	bus_dmamap_t sc_dmamap;
	int32_t sc_cid;
	int sc_maxses;
	int sc_ramsize;
	int sc_flags;
#define	HIFN_HAS_RNG		1
#define	HIFN_HAS_PUBLIC		2
	struct timeout sc_rngto;
	int sc_rngfirst;
	int sc_rnghz;
	struct hifn_session sc_sessions[2048];
};

#define	WRITE_REG_0(sc,reg,val) \
    bus_space_write_4((sc)->sc_st0, (sc)->sc_sh0, reg, val)
#define	READ_REG_0(sc,reg) \
    bus_space_read_4((sc)->sc_st0, (sc)->sc_sh0, reg)

/*
d92 13
d126 1
a126 1
 *  and can be used by IPsec implementers to skip over IP headers.
d133 1
a133 1
 *  and 2^16-1.  For IPsec, this number will always be 8 bytes larger
d137 30
d168 6
a173 2
struct hifn_command {
	u_int16_t session_num;
a174 1
	u_int8_t iv[HIFN_IV_LENGTH], *ck, mac[HIFN_MAC_KEY_LENGTH];
d176 13
a188 11
	union {
		struct mbuf *src_m;
		struct uio *src_io;
	} srcu;
	bus_dmamap_t src_map;

	union {
		struct mbuf *dst_m;
		struct uio *dst_io;
	} dstu;
	bus_dmamap_t dst_map;
d190 4
d195 1
a195 3
	struct cryptop *crp;
	struct cryptodesc *enccrd, *maccrd;
};
d203 6
@


1.3.6.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.3.6.3 2001/07/04 10:42:08 niklas Exp $	*/
d4 1
a4 1
 * Invertex AEON / Hifn 7751 driver
a41 2
#ifdef _KERNEL

d83 2
a84 3
	u_char			command_bufs[HIFN_D_CMD_RSIZE][HIFN_MAX_COMMAND];
	u_char			result_bufs[HIFN_D_CMD_RSIZE][HIFN_MAX_RESULT];
	u_int32_t		slop[HIFN_D_CMD_RSIZE];
d86 1
a86 1
	u_int64_t		test_src, test_dst;
d92 3
a94 3
	int			cmdi, srci, dsti, resi;
	volatile int		cmdu, srcu, dstu, resu;
	int			cmdk, srck, dstk, resk;
d98 1
a98 2
	int hs_state;
	int hs_prev_op; /* XXX collapse into hs_flags? */
a101 24
#define	HIFN_RING_SYNC(sc, r, i, f)					\
	hifn_bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_dmamap,		\
	    offsetof(struct hifn_dma, r[i]), sizeof(struct hifn_desc), (f))

#define	HIFN_CMDR_SYNC(sc, i, f)	HIFN_RING_SYNC((sc), cmdr, (i), (f))
#define	HIFN_RESR_SYNC(sc, i, f)	HIFN_RING_SYNC((sc), resr, (i), (f))
#define	HIFN_SRCR_SYNC(sc, i, f)	HIFN_RING_SYNC((sc), srcr, (i), (f))
#define	HIFN_DSTR_SYNC(sc, i, f)	HIFN_RING_SYNC((sc), dstr, (i), (f))

#define	HIFN_CMD_SYNC(sc, i, f)						\
	hifn_bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_dmamap,		\
	    offsetof(struct hifn_dma, command_bufs[(i)][0]),		\
	    HIFN_MAX_COMMAND, (f))

#define	HIFN_RES_SYNC(sc, i, f)						\
	hifn_bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_dmamap,		\
	    offsetof(struct hifn_dma, result_bufs[(i)][0]),		\
	    HIFN_MAX_RESULT, (f))

/* We use a state machine to on sessions */
#define	HS_STATE_FREE	0		/* unused session entry */
#define	HS_STATE_USED	1		/* allocated, but key not on card */
#define	HS_STATE_KEY	2		/* allocated and key is on card */

d123 1
a123 1
	struct timeout sc_rngto, sc_tickto;
a125 1
	int sc_c_busy, sc_s_busy, sc_d_busy, sc_r_busy, sc_active;
a202 2
	int cklen;
	int sloplen, slopidx;
d228 2
a262 10

struct hifn_stats {
	u_int64_t hst_ibytes;
	u_int64_t hst_obytes;
	u_int32_t hst_ipackets;
	u_int32_t hst_opackets;
	u_int32_t hst_invalid;
	u_int32_t hst_nomem;
	u_int32_t hst_abort;
};
@


1.3.6.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d107 1
a107 1
	bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_dmamap,		\
d116 1
a116 1
	bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_dmamap,		\
d121 1
a121 1
	bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_dmamap,		\
a144 2
	bus_dma_segment_t sc_dmasegs[1];
	int sc_dmansegs;
a155 2
	pci_chipset_tag_t sc_pci_pc;
	pcitag_t sc_pci_tag;
@


1.3.6.6
log
@Merge in trunk
@
text
@a152 1
#define	HIFN_IS_7811		4
@


1.3.6.7
log
@Sync the SMP branch with 3.3
@
text
@a36 4
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d92 1
a92 1
	 *  Our current positions for insertion and removal from the descriptor
a105 5
/* We use a state machine on sessions */
#define	HS_STATE_FREE	0		/* unused session entry */
#define	HS_STATE_USED	1		/* allocated, but key not on card */
#define	HS_STATE_KEY	2		/* allocated and key is on card */

d125 5
a153 2
#define	HIFN_NO_BURSTWRITE	8
#define	HIFN_HAS_LEDS		16
a160 2
	bus_size_t sc_waw_lastreg;
	int sc_waw_lastgroup;
d163 4
a166 13
#define WRITE_REG_0(sc,reg,val)		hifn_write_4((sc), 0, (reg), (val))
#define WRITE_REG_1(sc,reg,val)		hifn_write_4((sc), 1, (reg), (val))
#define	READ_REG_0(sc,reg)		hifn_read_4((sc), 0, (reg))
#define	READ_REG_1(sc,reg)		hifn_read_4((sc), 1, (reg))

#define	SET_LED(sc,v)							\
	if (sc->sc_flags & HIFN_HAS_LEDS)				\
		WRITE_REG_1(sc, HIFN_1_7811_MIPSRST,			\
		    READ_REG_1(sc, HIFN_1_7811_MIPSRST) | (v))
#define	CLR_LED(sc,v)							\
	if (sc->sc_flags & HIFN_HAS_LEDS)				\
		WRITE_REG_1(sc, HIFN_1_7811_MIPSRST,			\
		    READ_REG_1(sc, HIFN_1_7811_MIPSRST) & ~(v))
d169 1
a169 1
 *  struct hifn_command
d235 1
a235 1
	u_int16_t base_masks, cry_masks, mac_masks, comp_masks;
d254 1
a254 3
	struct cryptodesc *enccrd, *maccrd, *compcrd;
	void (*cmd_callback)(struct hifn_softc *, struct hifn_command *,
	    u_int8_t *);
@


1.3.6.8
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d79 1
a79 1
	 *  Descriptor rings.  We add +1 to the size to accommodate the
d201 1
a201 1
 *  To use authentication, a single MAC algorithm must be included:
@


1.3.6.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751var.h,v 1.3.6.8 2003/05/16 00:29:41 niklas Exp $	*/
d24 1
@


1.3.6.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a61 2
#define HIFN_AES_IV_LENGTH		16
#define	HIFN_MAX_IV_LENGTH		HIFN_AES_IV_LENGTH
d104 3
a106 2
	int hs_used;
	u_int8_t hs_iv[HIFN_MAX_IV_LENGTH];
d109 5
a151 1
	int sc_nsessions;
d154 5
a158 7
#define	HIFN_HAS_RNG		0x01	/* includes random number generator */
#define	HIFN_HAS_PUBLIC		0x02	/* includes public key support */
#define	HIFN_IS_7811		0x04	/* Hifn 7811 part */
#define	HIFN_NO_BURSTWRITE	0x08	/* can't handle PCI burst writes */
#define	HIFN_HAS_LEDS		0x10	/* Has LEDs to blink */
#define	HIFN_HAS_AES		0x20	/* includes AES support */
#define	HIFN_IS_7956		0x40	/* Hifn 7955/7956 part */
d163 1
a163 1
	struct hifn_session *sc_sessions;
d252 1
a252 1
	u_int8_t iv[HIFN_MAX_IV_LENGTH], *ck, mac[HIFN_MAC_KEY_LENGTH];
@


1.2
log
@use src/dst descriptor chaining out of an mbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: aeonvar.h,v 1.1 1999/02/19 02:52:20 deraadt Exp $	*/
d55 2
d122 3
a124 17
 *  source_buf
 *  ----------
 *  The source buffer is used for DMA -- it must be a 4-byte aligned
 *  address to physically contiguous memory where encode / decode
 *  input is read from.  In a decode operation using authentication,
 *  the final bytes of the buffer should contain the appropriate hash
 *  data.
 *  
 *  dest_buf
 *  --------
 *  The dest buffer is used for DMA -- it must be a 4-byte aligned
 *  address to physically contiguous memory where encoded / decoded
 *  output is written to.  If desired, this buffer can be the same
 *  as the source buffer with no performance penalty.  If 
 *  authentication is used, the final bytes will always consist of
 *  the hashed value (even on decode operations).
 *  
a186 4
	/*
	 *  You should be able to convert any of these arrays into pointers
	 *  (if desired) without modifying code in aeon.c.
	 */
d190 11
a200 1
	struct mbuf *m;
a203 2
	u_short source_length;
	u_short dest_length;
d273 1
a273 1
int aeon_crypto(aeon_command_t *command);
@


1.1
log
@invertex aeon driver base
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d194 1
a194 1
	u_int flags;
d197 1
a197 1
	u_short session_num;
d203 2
a204 3
	u_char initial_vector[AEON_IV_LENGTH];
	u_char crypt_key[AEON_MAX_CRYPT_KEY_LENGTH]; 
	u_char mac_key[AEON_MAC_KEY_LENGTH]; 
d206 1
a206 2
	void *source_buf;
	void *dest_buf;
@

