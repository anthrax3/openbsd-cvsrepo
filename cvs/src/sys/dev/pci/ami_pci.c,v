head	1.43;
access;
symbols
	OPENBSD_6_0:1.43.0.34
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.22
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.43.0.30
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.43.0.28
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.43.0.26
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.43.0.24
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.43.0.20
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.18
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.16
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.14
	OPENBSD_5_0:1.43.0.12
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.10
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.43.0.8
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.43.0.4
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.43.0.6
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.42.0.8
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.42.0.6
	OPENBSD_4_3_BASE:1.42
	OPENBSD_4_2:1.42.0.4
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.42.0.2
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.41.0.2
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.35.0.2
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.19.0.4
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.12
	UBC:1.8.0.4
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	SMP:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2;
locks; strict;
comment	@ * @;


1.43
date	2008.10.28.11.43.10;	author marco;	state Exp;
branches;
next	1.42;

1.42
date	2007.01.27.05.09.51;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2006.08.06.04.40.08;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2006.07.14.13.05.13;	author dlg;	state Exp;
branches;
next	1.39;

1.39
date	2006.07.14.08.30.27;	author dlg;	state Exp;
branches;
next	1.38;

1.38
date	2006.05.21.00.56.23;	author dlg;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.13.22.11.23;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.04.05.21.22;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.13.12.13.59;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2005.12.13.11.32.27;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.12.09.39.29;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.05.16.02.55;	author marco;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.15.11.08.46;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2005.08.24.19.21.40;	author marco;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2005.08.15.23.22.46;	author marco;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.09.04.10.10;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.18.02.43.27;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.05.23.34.00;	author marco;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.27.20.39.30;	author marco;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.09.19.50.48;	author marco;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.16.17.21.12;	author marco;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.26.00.35.42;	author marco;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.26.00.11.24;	author marco;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.22.21.09.18;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.28.02.03.34;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.02.19.24.22;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2003.05.24.08.45.05;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.28.15.26.23;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.28.15.14.08;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.12.10.23.13.59;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2002.10.04.16.10.36;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.03.23.59.43;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.30.09.33.51;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.25.10.13.29;	author art;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.06.23.21.43.07;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.23.21.24.58;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.19.16.09.24;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.12.15.40.30;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.16.03.18.18;	author deraadt;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.03.27.19.17.14;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.09.11.14.22;	author mickey;	state Exp;
branches;
next	;

1.3.4.1
date	2001.05.14.22.25.32;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.07.04.10.41.52;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.03.28.00.38.20;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2003.05.13.19.35.04;	author ho;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.3.4.8;

1.3.4.8
date	2004.06.05.23.12.48;	author niklas;	state Exp;
branches;
next	;

1.8.4.1
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2003.05.19.22.17.59;	author tedu;	state Exp;
branches;
next	;

1.30.2.1
date	2005.12.07.22.30.30;	author brad;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2005.12.23.05.06.13;	author brad;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Major overhaul of bio.
Fix set hotspare that didn't always work.
Fix several very subtle bugs because of firmware lies
Fix disk size that sometimes was incorrect
Only poke drives if something changed so it makes bio way faster on subsequent calls

Tested by several folks, thanks
Ok dlg
@
text
@/*	$OpenBSD: ami_pci.c,v 1.42 2007/01/27 05:09:51 dlg Exp $	*/

/*
 * Copyright (c) 2001 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/rwlock.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>

#include <machine/bus.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>

#include <dev/biovar.h>
#include <dev/ic/amireg.h>
#include <dev/ic/amivar.h>

#define	AMI_BAR		PCI_MAPREG_START
#define	AMI_PCI_MEMSIZE	0x1000

/* "Quartz" i960 Config space */
#define	AMI_PCI_INIT	0x9c
#define		AMI_INITSTAT(i)	(((i) >>  8) & 0xff)
#define		AMI_INITTARG(i)	(((i) >> 16) & 0xff)
#define		AMI_INITCHAN(i)	(((i) >> 24) & 0xff)
#define	AMI_PCI_SIG	0xa0
#define		AMI_SIGNATURE_1	0xcccc		/* older adapters */
#define		AMI_SIGNATURE_2	0x3344		/* newer adapters */
#define	AMI_PCI_SGL	0xa4
#define		AMI_SGL_LHC	0x00000299
#define		AMI_SGL_HLC	0x00000199

int	ami_pci_find_device(void *);
int	ami_pci_match(struct device *, void *, void *);
void	ami_pci_attach(struct device *, struct device *, void *);

struct cfattach ami_pci_ca = {
	sizeof(struct ami_softc), ami_pci_match, ami_pci_attach
};

static const
struct	ami_pci_device {
	int	vendor;
	int	product;
	int	flags;
} ami_pci_devices[] = {
	{ PCI_VENDOR_AMI,	PCI_PRODUCT_AMI_MEGARAID,	0 },
	{ PCI_VENDOR_AMI,	PCI_PRODUCT_AMI_MEGARAID428,	AMI_BROKEN },
	{ PCI_VENDOR_AMI,	PCI_PRODUCT_AMI_MEGARAID434,	AMI_BROKEN },
	{ PCI_VENDOR_DELL,	PCI_PRODUCT_DELL_PERC_4DI,	0 },
	{ PCI_VENDOR_DELL,	PCI_PRODUCT_DELL_PERC_4DI_2,	0 },
	{ PCI_VENDOR_DELL,	PCI_PRODUCT_DELL_PERC_4EDI,	0 },	
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_80960RP_ATU,
	    AMI_CHECK_SIGN | AMI_BROKEN },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_MEGARAID,		0 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_MEGARAID_320,	0 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_MEGARAID_3202E,	0 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_MEGARAID_SATA,	0 },
	{ 0 }
};

static const
struct	ami_pci_subsys {
	pcireg_t	id;
	const char	*name;
	int		flags;
} ami_pci_subsys[] = {
	/* only those of a special name or quirk are listed here */
	{ 0x004d1025,	"ACER MegaRAID ROMB-2E", 0},
	{ 0x0511101e,	"AMI MegaRAID i4", AMI_BROKEN },
	{ 0x04931028,	"Dell PERC3/DC", 0 },
	{ 0x05181028,	"Dell PERC4/DC", 0 },
	{ 0x09a0101e,	"Dell 466v1", 0 },
	{ 0x11111111,	"Dell 466v2", 0 },
	{ 0x11121111,	"Dell 438", 0 },
	{ 0x11111028,	"Dell 466v3", 0 },
	{ 0x10651734,	"FSC MegaRAID PCI Express ROMB", 0 },
	{ 0x10c6103c,	"HP 438", 0 },
	{ 0x10c7103c,	"HP T5/T6", 0 },
	{ 0x10cc103c,	"HP T7", 0 },
	{ 0x10cd103c,	"HP 466", 0 },
	{ 0x45231000,	"LSI 523", 0 },
	{ 0x05328086,	"Intel RAID SRCU42X", 0 },
	{ 0x05238086,	"Intel RAID SRCS16", 0 },
	{ 0x00028086,	"Intel RAID SRCU42E", 0 },
	{ 0x05308086,	"Intel RAID SRCZCRX", 0 },
	{ 0x30088086,	"Intel RAID SRCS28X", 0 },
	{ 0x34318086,	"Intel RAID SROMBU42E", 0 },
	{ 0x34998086,	"Intel RAID SROMBU42E", 0 },
	{ 0x05208086,	"Intel RAID SRCU51L", 0 },
	{ 0x82871033,	"NEC MegaRAID PCI Express ROMB", 0 },
	{ 0, NULL, 0 }
};

static const
struct ami_pci_vendor {
	u_int16_t id;
	char name[8];
} ami_pci_vendors[] = {
	{ 0x101e, "AMI" },
	{ 0x1028, "Dell" },
	{ 0x103c, "HP" },
	{ 0x1000, "LSI" },
	{ 0x8086, "Intel" },
	{ 0 }
};

int
ami_pci_find_device(void *aux)
{
	struct pci_attach_args *pa = aux;
	int i;

	for (i = 0; ami_pci_devices[i].vendor; i++) {
		if (ami_pci_devices[i].vendor == PCI_VENDOR(pa->pa_id) &&
		    ami_pci_devices[i].product == PCI_PRODUCT(pa->pa_id)) {
#ifdef AMI_DEBUG
		    	printf(" apfd %i ", i);
#endif /* AMI_DEBUG */
			return (i);
		}
	}

	return (-1);
}

int
ami_pci_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;
	pcireg_t sig;
	int i;

	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_I2O)
		return (0);

	if ((i = ami_pci_find_device(aux)) != -1) {
#ifdef AMI_DEBUG
		printf("\nvendor: %04x  product: %04x\n",
			ami_pci_devices[i].vendor,
			ami_pci_devices[i].product);
#endif /* AMI_DEBUG */

		if (!(ami_pci_devices[i].flags & AMI_CHECK_SIGN))
			return (1);
		/* some cards have 0x11223344, but some only 16bit */
		sig = pci_conf_read(pa->pa_pc, pa->pa_tag,
		    AMI_PCI_SIG) & 0xffff;
		if (sig == AMI_SIGNATURE_1 ||
		    sig == AMI_SIGNATURE_2)
			return (1);
	}

	return (0);
}

void
ami_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct ami_softc *sc = (struct ami_softc *)self;
	struct pci_attach_args *pa = aux;
	pci_intr_handle_t ih;
	const char *intrstr, *model = NULL, *lhc;
	const struct ami_pci_subsys *ssp;
	bus_size_t size;
	pcireg_t csr;
	int i;

	csr = pci_mapreg_type(pa->pa_pc, pa->pa_tag, AMI_BAR);
	if (pci_mapreg_map(pa, AMI_BAR, csr, 0,
	    &sc->sc_iot, &sc->sc_ioh, NULL, &size, AMI_PCI_MEMSIZE)) {
		printf(": can't map controller pci space\n");
		return;
	}

	if (PCI_MAPREG_TYPE(csr) == PCI_MAPREG_TYPE_IO) {
		sc->sc_init = ami_schwartz_init;
		sc->sc_exec = ami_schwartz_exec;
		sc->sc_done = ami_schwartz_done;
		sc->sc_poll = ami_schwartz_poll;
	} else {
		sc->sc_init = ami_quartz_init;
		sc->sc_exec = ami_quartz_exec;
		sc->sc_done = ami_quartz_done;
		sc->sc_poll = ami_quartz_poll;
		sc->sc_flags |= AMI_QUARTZ;
	}
	sc->sc_dmat = pa->pa_dmat;

	if (pci_intr_map(pa, &ih)) {
		printf(": can't map interrupt\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, size);
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, ami_intr, sc,
	    sc->sc_dev.dv_xname);
	if (!sc->sc_ih) {
		printf(": can't establish interrupt");
		if (intrstr)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, size);
		return;
	}

	printf(": %s\n", intrstr);

	csr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);
	for (ssp = ami_pci_subsys; ssp->id; ssp++) {
		if (ssp->id == csr) {
			model = ssp->name;
			sc->sc_flags |= ssp->flags;
			break;
		}
	}

	if (!model && PCI_VENDOR(pa->pa_id) == PCI_VENDOR_AMI) {
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_AMI_MEGARAID428:
			model = "AMI 428";
			break;
		case PCI_PRODUCT_AMI_MEGARAID434:
			model = "AMI 434";
			break;
		}
	}

	/*
	 * XXX 438 is netraid 3si for hp cards, but we get to know
	 * they are hp too late in md code
	 */
	if (!model) {
		const struct ami_pci_vendor *vp;
		static char modelbuf[32];

		for (vp = ami_pci_vendors;
		     vp->id && vp->id != (csr & 0xffff); vp++);
		if (vp->id)
			snprintf(modelbuf, sizeof(modelbuf), "%s %x", vp->name,
			    (csr >> 16) & 0xffff);
		else
			snprintf(modelbuf, sizeof(modelbuf), "unknown 0x%08x",
			    csr);
		model = modelbuf;
	}

	switch (pci_conf_read(pa->pa_pc, pa->pa_tag, AMI_PCI_SGL)) {
	case AMI_SGL_LHC:	lhc = "64b/lhc";	break;
	case AMI_SGL_HLC:	lhc = "64b/hlc";	break;
	default:		lhc = "32b";
	}

	if ((i = ami_pci_find_device(aux)) != -1) {
		if (ami_pci_devices[i].flags & AMI_BROKEN)
			sc->sc_flags |= AMI_BROKEN;
	} else {
		/* this device existed at _match() should never happen */
		panic("ami device dissapeared between match() and attach()");
	}

	printf("%s: %s, %s", sc->sc_dev.dv_xname, model, lhc);

	if (ami_attach(sc)) {
		pci_intr_disestablish(pa->pa_pc, sc->sc_ih);
		sc->sc_ih = NULL;
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, size);
	}
}
@


1.42
log
@convert to our locks to rwlocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.41 2006/08/06 04:40:08 brad Exp $	*/
d45 1
@


1.41
log
@sync PCI ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.40 2006/07/14 13:05:13 dlg Exp $	*/
d34 1
@


1.40
log
@clean up a few defines and apply some knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.39 2006/07/14 08:30:27 dlg Exp $	*/
d87 1
a87 1
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SATA8,		0 },
@


1.39
log
@dont pretend to configure the BAR to only use 32bit addressing, and make
sure we compare the right bits when we figure out what type of memory we're
talking to.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.38 2006/05/21 00:56:23 dlg Exp $	*/
d47 1
a47 1
#define	AMI_BAR		0x10
a48 3
#define	AMI_SUBSYSID	0x2c
#define	PCI_EBCR	0x40
#define	AMI_WAKEUP	0x64
d138 3
a140 1
ami_pci_find_device(void *aux) {
a141 1
	struct pci_attach_args *pa = aux;
d160 1
a161 1
	pcireg_t sig;
@


1.38
log
@recognise the perc4/dc firmware
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.37 2006/03/13 22:11:23 brad Exp $	*/
d199 1
a199 6
#if 0
	/* reset */
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_EBCR,
	    pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_EBCR) | 0x20);
	pci_conf_write(pa->pa_pc, pa->pa_tag, AMI_WAKEUP, 0);
#endif
a200 1
	csr |= PCI_MAPREG_MEM_TYPE_32BIT;
d207 1
a207 1
	if (csr == PCI_MAPREG_TYPE_IO) {
@


1.37
log
@make the dmseg printing look a little nicer.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.36 2006/03/04 05:21:22 brad Exp $	*/
d104 1
@


1.36
log
@add PCI sub-ids for ACER, FSC, Intel and NEC products.

ok marco@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.35 2005/12/13 12:13:59 dlg Exp $	*/
d243 1
a243 1
	printf(": %s", intrstr);
d298 1
a298 1
	printf(" %s %s\n%s", model, lhc, sc->sc_dev.dv_xname);
@


1.35
log
@use consistent naming for members of the softc struct
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.34 2005/12/13 11:32:27 dlg Exp $	*/
d101 1
d104 1
a104 1
	{ 0x09A0101E,	"Dell 466v1", 0 },
d108 1
d114 9
a122 1
	{ 0x05328086,	"Intel SRCU42X", 0 },
@


1.34
log
@the megaraid i4 and my dell perc 3/dc share the same vendor and product
ids, but the i4 is considered broken while my perc is definately working
fine. so instead of marking all the devices with this vendor and product
id as broken, we use the pci subsys ids to determine if the device needs
a quirk.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.33 2005/12/12 09:39:29 dlg Exp $	*/
d197 1
a197 1
	    &sc->iot, &sc->ioh, NULL, &size, AMI_PCI_MEMSIZE)) {
d214 1
a214 1
	sc->dmat = pa->pa_dmat;
d218 1
a218 1
		bus_space_unmap(sc->iot, sc->ioh, size);
d229 1
a229 1
		bus_space_unmap(sc->iot, sc->ioh, size);
d293 1
a293 1
		bus_space_unmap(sc->iot, sc->ioh, size);
@


1.33
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.32 2005/12/05 16:02:55 marco Exp $	*/
d79 1
a79 1
	{ PCI_VENDOR_AMI,	PCI_PRODUCT_AMI_MEGARAID,	AMI_BROKEN },
d96 3
a98 2
	pcireg_t id;
	char	name[14];
d100 14
a113 12
	/* only those of a special name are listed here */
	{ 0x09A0101E,	"Dell 466v1" },
	{ 0x11111111,	"Dell 466v2" },
	{ 0x11121111,	"Dell 438" },
	{ 0x11111028,	"Dell 466v3" },
	{ 0x10c6103c,	"HP 438" },
	{ 0x10c7103c,	"HP T5/T6" },
	{ 0x10cc103c,	"HP T7" },
	{ 0x10cd103c,	"HP 466" },
	{ 0x45231000,	"LSI 523" },
	{ 0x05328086,	"Intel SRCU42X" },
	{ 0 }
d236 1
a236 1
	for (ssp = ami_pci_subsys; ssp->id; ssp++)
d239 1
d242 1
d288 1
a288 1
	printf(" %s/%s\n%s", model, lhc, sc->sc_dev.dv_xname);
@


1.32
log
@Add older card to quirk table.  This fixes the ccb timeout as reported by
J.C. Roberts <unknown at abac dot com> on misc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.31 2005/11/15 11:08:46 mickey Exp $	*/
a77 1
#define	AMI_CHECK_SIGN	0x001
d126 2
a127 3
int ami_pci_find_device(aux)
	void *aux;
{
d145 1
a145 4
ami_pci_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d175 1
a175 3
ami_pci_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d239 1
a239 1
	if (!model && PCI_VENDOR(pa->pa_id) == PCI_VENDOR_AMI)
d248 1
d250 4
a253 3
	/* XXX 438 is netraid 3si for hp cards, but we get to know
	   they are hp too late in md code */

d261 1
a261 1
			snprintf(modelbuf, sizeof modelbuf, "%s %x", vp->name,
d264 1
a264 1
			snprintf(modelbuf, sizeof modelbuf, "unknown 0x%08x",
d278 1
a278 2
	}
	else {
@


1.31
log
@missing return upon intr_establish failure
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.30 2005/08/24 19:21:40 marco Exp $	*/
d80 1
a80 1
	{ PCI_VENDOR_AMI,	PCI_PRODUCT_AMI_MEGARAID,	0 },
@


1.30
log
@Add MegaRAID 320E.

"Hell, put it in now." deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.29 2005/08/15 23:22:46 marco Exp $	*/
d234 1
@


1.30.2.1
log
@MFC:
Fixes by marco@@

ic/ami.c - rev 1.100

Prevent scsi pass-through busses from attaching when a board is marked
broken.

pci/ami_pci.c - rev 1.32

Add older card to quirk table.  This fixes the ccb timeout as reported by
J.C. Roberts <unknown at abac dot com> on misc@@.

ok deraadt@@ marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.30 2005/08/24 19:21:40 marco Exp $	*/
d80 1
a80 1
	{ PCI_VENDOR_AMI,	PCI_PRODUCT_AMI_MEGARAID,	AMI_BROKEN },
@


1.30.2.2
log
@MFC:
Fix by dlg@@

the megaraid i4 and my dell perc 3/dc share the same vendor and product
ids, but the i4 is considered broken while my perc is definately working
fine. so instead of marking all the devices with this vendor and product
id as broken, we use the pci subsys ids to determine if the device needs
a quirk.

ok deraadt@@ marco@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.30.2.1 2005/12/07 22:30:30 brad Exp $	*/
d80 1
a80 1
	{ PCI_VENDOR_AMI,	PCI_PRODUCT_AMI_MEGARAID,	0 },
d97 2
a98 3
	pcireg_t	id;
	const char	*name;
	int		flags;
d100 12
a111 14
	/* only those of a special name or quirk are listed here */
	{ 0x0511101e,	"AMI MegaRAID i4", AMI_BROKEN },
	{ 0x04931028,	"Dell PERC3/DC", 0 },
	{ 0x09A0101E,	"Dell 466v1", 0 },
	{ 0x11111111,	"Dell 466v2", 0 },
	{ 0x11121111,	"Dell 438", 0 },
	{ 0x11111028,	"Dell 466v3", 0 },
	{ 0x10c6103c,	"HP 438", 0 },
	{ 0x10c7103c,	"HP T5/T6", 0 },
	{ 0x10cc103c,	"HP T7", 0 },
	{ 0x10cd103c,	"HP 466", 0 },
	{ 0x45231000,	"LSI 523", 0 },
	{ 0x05328086,	"Intel SRCU42X", 0 },
	{ 0, NULL, 0 }
d239 1
a239 1
	for (ssp = ami_pci_subsys; ssp->id; ssp++) {
a241 1
			sc->sc_flags |= ssp->flags;
a243 1
	}
d288 1
a288 1
	printf(" %s %s\n%s", model, lhc, sc->sc_dev.dv_xname);
@


1.29
log
@Add global hot spare support.
Add flag to determine controller type.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.28 2005/08/09 04:10:10 mickey Exp $	*/
d90 1
@


1.28
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.27 2005/07/18 02:43:27 fgsch Exp $	*/
d215 1
d280 1
a280 3
			sc->sc_flags = AMI_BROKEN;
		else
			sc->sc_flags = 0x0000;
@


1.27
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.26 2005/06/05 23:34:00 marco Exp $	*/
a216 5

	/* enable bus mastering (should not it be mi?) */
	csr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    csr | PCI_COMMAND_MASTER_ENABLE);
@


1.26
log
@Add megaraid 320 from Alexey E. Suslikov <cruel at texnika dot com dot ua>
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.25 2005/05/27 20:39:30 marco Exp $	*/
d290 1
a290 1
		panic("ami device dissapeared between match() and attach()\n");
@


1.25
log
@step 1 in fixing bioctl commands intermixed with regular io.

- Added the magical sequence for polling IO
- Created new polling function per hardware generation

Lots and lots of constructive yelling mickey@@
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.24 2005/05/09 19:50:48 marco Exp $	*/
d88 3
a90 2
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_MEGARAID,	0 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SATA8,	0 },
d97 1
a97 1
	char	name[12];
d109 1
d122 1
@


1.24
log
@replace sc_quirk with sc_flags, spotted and ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.23 2005/04/16 17:21:12 marco Exp $	*/
d206 1
d211 1
@


1.23
log
@Add SATA 8 channel.

Requested, help and tested by Travis Gillitzer, tgillitzer at gmail dot com.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.22 2004/12/26 00:35:42 marco Exp $	*/
d279 1
a279 1
			sc->sc_quirks = AMI_BROKEN;
d281 1
a281 1
			sc->sc_quirks = 0x0000;
@


1.22
log
@Make debug less verbose.  Prompted by mickey@@

And for the archives:
* Peruse the handshake mechanism between driver and firmware from the Linux
  driver which is maintained by LSI.
* Copy only the first 16 bytes of the mailbox (under heavy IO overwriting the
  17th byte could cause the firmware to crash).
* Limit ULTRA HBAs (a.k.a. schwartz) to one single LD (Logical Drive) because
  for some reason having more than 1 ccb causes the firmware to hang.  Whenever
  the driver limits the LDs it issues a warning in dmesg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.21 2004/12/26 00:11:24 marco Exp $	*/
d89 1
@


1.21
log
@This should fix long outstanding issues with ami(4).  The reported
symptoms that were fixed are:
* Very slow throughput
* ccb timeout (i.e. ami0: timeout ccb 1)
* All IO to ami devices hangs
* Only 1 LD (Logical Drive) can be accessed at the same time
* System hangs/freezes when running IO to ami cards.

Issues it doesn't fix:
* Really old ULTRA-2 controllers still crash whenever more than 1 LD are
  accessed at the same time therefore the driver limits the maximum LDs to 1.

Tested by several folks and ok beck@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.20 2004/11/22 21:09:18 deraadt Exp $	*/
d132 1
a132 1
		    	printf(" ami_pci_find_device() %i ", i);
@


1.20
log
@support PCI-Express PERC4e/Di; j@@pureftpd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.19 2004/02/28 02:03:34 mickey Exp $	*/
d65 1
d81 2
a82 2
	{ PCI_VENDOR_AMI,	PCI_PRODUCT_AMI_MEGARAID428,	0 },
	{ PCI_VENDOR_AMI,	PCI_PRODUCT_AMI_MEGARAID434,	0 },
d86 2
a87 1
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_80960RP_ATU, AMI_CHECK_SIGN },
d122 19
d148 1
a148 1
	const struct ami_pci_device *pami;
d154 15
a168 12
	for (pami = ami_pci_devices; pami->vendor; pami++) {
		if (pami->vendor == PCI_VENDOR(pa->pa_id) &&
		    pami->product == PCI_PRODUCT(pa->pa_id)) {
			if (!(pami->flags & AMI_CHECK_SIGN))
				return (1);
			/* some cards have 0x11223344, but some only 16bit */
			sig = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    AMI_PCI_SIG) & 0xffff;
			if (sig == AMI_SIGNATURE_1 ||
			    sig == AMI_SIGNATURE_2)
				return (1);
		}
d170 1
d186 1
d274 11
@


1.19
log
@dig lsi/symbios sata boards; reported and tesing by pailloncy@@ifrance.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.18 2003/06/02 19:24:22 mickey Exp $	*/
d84 1
@


1.18
log
@kill the caluses three and four on some of my code
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.17 2003/05/24 08:45:05 markus Exp $	*/
d85 1
d103 1
d115 1
d230 1
a230 1
		static char modelbuf[12];
@


1.17
log
@support Perc 4/Di (e.g. in Dell PowerEdge 2600); ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.16 2003/04/27 11:22:53 ho Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.16
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.15 2003/02/28 15:26:23 mickey Exp $	*/
d87 2
@


1.15
log
@remove non-typo changes. sorry folks
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.13 2002/12/10 23:13:59 miod Exp $	*/
d235 1
a235 1
			sprintf(modelbuf, "%s %x", vp->name,
d238 2
a239 1
			sprintf(modelbuf, "unknown 0x%08x", csr);
@


1.14
log
@typo; from weissmanndude
@
text
@d206 1
a206 1
	printf(": %s\n", intrstr);
d248 1
a248 1
	sprintf(sc->sc_raidconfig.rc_name, "%s/%s", model, lhc);
@


1.13
log
@Translate mickeyspeak into english.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.12 2002/10/04 16:10:36 mickey Exp $	*/
d206 1
a206 1
	printf(": %s", intrstr);
d248 1
a248 1
	printf(" %s/%s\n%s", model, lhc, sc->sc_dev.dv_xname);
@


1.12
log
@as i said, only check the class; add a comment on signature checking
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.11 2002/10/03 23:59:43 jason Exp $	*/
d137 1
a137 1
			/* some cards have 0x11223344, but somee only 16bit */
@


1.11
log
@Fix check for I2O based AMI cards (we don't want to match them here); me
also match the signature of the PERC 2/Sc cards; deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.10 2002/03/30 09:33:51 mickey Exp $	*/
d129 1
a129 2
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_I2O &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_I2O_STANDARD)
d137 1
@


1.10
log
@map only first page of whatever is given to us in the bar,
apparetnyl sometimes we get whole lots of space there.
also map it 32bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.9 2002/03/14 01:26:58 millert Exp $	*/
d64 2
a65 1
#define		AMI_SIGNATURE	0x3344
d127 1
d129 2
a130 1
	if (PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_I2O_STANDARD)
d135 9
a143 5
		    pami->product == PCI_PRODUCT(pa->pa_id) &&
		    (!pami->flags & AMI_CHECK_SIGN ||
		     (pci_conf_read(pa->pa_pc, pa->pa_tag, AMI_PCI_SIG) &
			  0xffff) == AMI_SIGNATURE))
			return (1);
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.8 2001/08/25 10:13:29 art Exp $	*/
d53 1
d160 1
d162 1
a162 1
	    &sc->iot, &sc->ioh, NULL, &size, 0)) {
@


1.8
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.7 2001/06/23 21:43:07 mickey Exp $	*/
d68 2
a69 2
int	ami_pci_match __P((struct device *, void *, void *));
void	ami_pci_attach __P((struct device *, struct device *, void *));
@


1.8.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.8 2001/08/25 10:13:29 art Exp $	*/
a52 1
#define	AMI_PCI_MEMSIZE	0x1000
d68 2
a69 2
int	ami_pci_match(struct device *, void *, void *);
void	ami_pci_attach(struct device *, struct device *, void *);
a158 1
	csr |= PCI_MAPREG_MEM_TYPE_32BIT;
d160 1
a160 1
	    &sc->iot, &sc->ioh, NULL, &size, AMI_PCI_MEMSIZE)) {
@


1.8.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.8.4.1 2002/06/11 03:42:24 art Exp $	*/
d64 1
a64 2
#define		AMI_SIGNATURE_1	0xcccc		/* older adapters */
#define		AMI_SIGNATURE_2	0x3344		/* newer adapters */
a125 1
	pcireg_t sig;
d127 1
a127 1
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_I2O)
d132 5
a136 10
		    pami->product == PCI_PRODUCT(pa->pa_id)) {
			if (!(pami->flags & AMI_CHECK_SIGN))
				return (1);
			/* some cards have 0x11223344, but somee only 16bit */
			sig = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    AMI_PCI_SIG) & 0xffff;
			if (sig == AMI_SIGNATURE_1 ||
			    sig == AMI_SIGNATURE_2)
				return (1);
		}
@


1.8.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d137 1
a137 1
			/* some cards have 0x11223344, but some only 16bit */
d235 1
a235 1
			snprintf(modelbuf, sizeof modelbuf, "%s %x", vp->name,
d238 1
a238 2
			snprintf(modelbuf, sizeof modelbuf, "unknown 0x%08x",
			    csr);
@


1.7
log
@remove debug printf
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.6 2001/06/23 21:24:58 mickey Exp $	*/
d181 1
a181 2
	if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.6
log
@under some circumstances, such as on ppc, signature does not read all 32 bits, check low 16 only
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.5 2001/06/19 16:09:24 mickey Exp $	*/
a129 1
		printf("%lx %lx\n", pci_conf_read(pa->pa_pc, pa->pa_tag, AMI_PCI_SIG) & 0xffff, AMI_SIGNATURE);
@


1.5
log
@do not attach at i2o-configured adapter; pointed out by ad@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.4 2001/06/12 15:40:30 niklas Exp $	*/
d63 1
a63 1
#define		AMI_SIGNATURE	0x11223344
d130 1
d134 2
a135 2
		     pci_conf_read(pa->pa_pc, pa->pa_tag, AMI_PCI_SIG) ==
		     AMI_SIGNATURE))
@


1.4
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.3 2001/04/16 03:18:18 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000 Michael Shalayeff
d126 3
d216 3
@


1.3
log
@dmesg cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.2 2001/03/27 19:17:14 mickey Exp $	*/
d157 1
a157 1
	    &sc->iot, &sc->ioh, NULL, &size)) {
@


1.3.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.3 2001/04/16 03:18:18 deraadt Exp $	*/
@


1.3.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.3.4.1 2001/05/14 22:25:32 niklas Exp $	*/
d4 1
a4 1
 * Copyright (c) 2001 Michael Shalayeff
d63 1
a63 1
#define		AMI_SIGNATURE	0x3344
a125 3
	if (PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_I2O_STANDARD)
		return (0);

d130 2
a131 2
		     (pci_conf_read(pa->pa_pc, pa->pa_tag, AMI_PCI_SIG) &
			  0xffff) == AMI_SIGNATURE))
d157 1
a157 1
	    &sc->iot, &sc->ioh, NULL, &size, 0)) {
a212 3

	/* XXX 438 is netraid 3si for hp cards, but we get to know
	   they are hp too late in md code */
@


1.3.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.3.4.2 2001/07/04 10:41:52 niklas Exp $	*/
d181 2
a182 1
	if (pci_intr_map(pa, &ih)) {
@


1.3.4.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 2
a69 2
int	ami_pci_match(struct device *, void *, void *);
void	ami_pci_attach(struct device *, struct device *, void *);
@


1.3.4.5
log
@Sync the SMP branch with 3.3
@
text
@a52 1
#define	AMI_PCI_MEMSIZE	0x1000
d63 1
a63 2
#define		AMI_SIGNATURE_1	0xcccc		/* older adapters */
#define		AMI_SIGNATURE_2	0x3344		/* newer adapters */
a124 1
	pcireg_t sig;
d126 1
a126 1
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_I2O)
d131 5
a135 10
		    pami->product == PCI_PRODUCT(pa->pa_id)) {
			if (!(pami->flags & AMI_CHECK_SIGN))
				return (1);
			/* some cards have 0x11223344, but some only 16bit */
			sig = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    AMI_PCI_SIG) & 0xffff;
			if (sig == AMI_SIGNATURE_1 ||
			    sig == AMI_SIGNATURE_2)
				return (1);
		}
a158 1
	csr |= PCI_MAPREG_MEM_TYPE_32BIT;
d160 1
a160 1
	    &sc->iot, &sc->ioh, NULL, &size, AMI_PCI_MEMSIZE)) {
@


1.3.4.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.3.4.5 2003/03/28 00:38:20 niklas Exp $	*/
d235 1
a235 1
			snprintf(modelbuf, sizeof modelbuf, "%s %x", vp->name,
d238 1
a238 2
			snprintf(modelbuf, sizeof modelbuf, "unknown 0x%08x",
			    csr);
@


1.3.4.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.3.4.6 2003/05/13 19:35:04 ho Exp $	*/
d15 5
a86 2
	{ PCI_VENDOR_DELL,	PCI_PRODUCT_DELL_PERC_4DI,	0 },
	{ PCI_VENDOR_DELL,	PCI_PRODUCT_DELL_PERC_4DI_2,	0 },
@


1.3.4.8
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a84 1
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_MEGARAID,	0 },
a101 1
	{ 0x45231000,	"LSI 523" },
a112 1
	{ 0x1000, "LSI" },
d227 1
a227 1
		static char modelbuf[32];
@


1.2
log
@avoid a mapreg type mismatch warning when mapping card's io space
@
text
@d1 1
a1 1
/*	$OpenBSD: ami_pci.c,v 1.1 2001/03/09 11:14:22 mickey Exp $	*/
d195 1
a195 1
	printf(" %s", intrstr);
d234 1
a234 1
	printf(": %s/%s\n%s", model, lhc, sc->sc_dev.dv_xname);
@


1.1
log
@seems to work; rush because of cvs's battery at 73% now
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d155 2
a156 1
	if (!pci_mapreg_map(pa, AMI_BAR, PCI_MAPREG_TYPE_IO, 0,
d158 3
d162 1
d166 1
a166 4

	} else if (!pci_mapreg_map(pa, AMI_BAR, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->iot, &sc->ioh, NULL, &size)) {

a169 4

	} else {
		printf(": can't map controller pci space\n");
		return;
@

