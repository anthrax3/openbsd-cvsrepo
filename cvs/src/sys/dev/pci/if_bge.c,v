head	1.386;
access;
symbols
	OPENBSD_6_2:1.386.0.2
	OPENBSD_6_2_BASE:1.386
	OPENBSD_6_1:1.385.0.4
	OPENBSD_6_1_BASE:1.385
	OPENBSD_6_0:1.382.0.4
	OPENBSD_6_0_BASE:1.382
	OPENBSD_5_9:1.381.0.2
	OPENBSD_5_9_BASE:1.381
	OPENBSD_5_8:1.369.0.4
	OPENBSD_5_8_BASE:1.369
	OPENBSD_5_7:1.365.0.4
	OPENBSD_5_7_BASE:1.365
	OPENBSD_5_6:1.358.0.4
	OPENBSD_5_6_BASE:1.358
	OPENBSD_5_5:1.353.0.4
	OPENBSD_5_5_BASE:1.353
	OPENBSD_5_4:1.338.0.2
	OPENBSD_5_4_BASE:1.338
	OPENBSD_5_3:1.319.0.2
	OPENBSD_5_3_BASE:1.319
	OPENBSD_5_2:1.311.0.2
	OPENBSD_5_2_BASE:1.311
	OPENBSD_5_1_BASE:1.307
	OPENBSD_5_1:1.307.0.4
	OPENBSD_5_0:1.307.0.2
	OPENBSD_5_0_BASE:1.307
	OPENBSD_4_9:1.305.0.2
	OPENBSD_4_9_BASE:1.305
	OPENBSD_4_8:1.298.0.2
	OPENBSD_4_8_BASE:1.298
	OPENBSD_4_7:1.291.0.2
	OPENBSD_4_7_BASE:1.291
	OPENBSD_4_6:1.276.0.4
	OPENBSD_4_6_BASE:1.276
	OPENBSD_4_5:1.261.0.2
	OPENBSD_4_5_BASE:1.261
	OPENBSD_4_4:1.238.0.2
	OPENBSD_4_4_BASE:1.238
	OPENBSD_4_3:1.222.0.2
	OPENBSD_4_3_BASE:1.222
	OPENBSD_4_2:1.213.0.2
	OPENBSD_4_2_BASE:1.213
	OPENBSD_4_1:1.207.0.2
	OPENBSD_4_1_BASE:1.207
	OPENBSD_4_0:1.176.0.2
	OPENBSD_4_0_BASE:1.176
	OPENBSD_3_9:1.135.0.2
	OPENBSD_3_9_BASE:1.135
	OPENBSD_3_8:1.81.0.2
	OPENBSD_3_8_BASE:1.81
	OPENBSD_3_7:1.54.0.2
	OPENBSD_3_7_BASE:1.54
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.14
	UBC:1.3.0.6
	UBC_BASE:1.3
	SMP:1.3.0.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.386
date	2017.08.17.12.28.34;	author jsg;	state Exp;
branches;
next	1.385;
commitid	7hXdQHCXMklLL7dz;

1.385
date	2017.02.13.00.56.32;	author dlg;	state Exp;
branches;
next	1.384;
commitid	sAjSTFFAMV02glgn;

1.384
date	2017.01.24.03.57.34;	author dlg;	state Exp;
branches;
next	1.383;
commitid	PERtGPXCvlLRRBr8;

1.383
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.382;
commitid	VyLWTsbepAOk7VQM;

1.382
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.381;
commitid	8YSL8ByWzGeIGBiJ;

1.381
date	2015.12.29.12.47.22;	author dlg;	state Exp;
branches;
next	1.380;
commitid	sUn1OeI6l7o7FJQa;

1.380
date	2015.11.29.20.19.35;	author kettenis;	state Exp;
branches;
next	1.379;
commitid	4zVL5LtA6Fa4yP4J;

1.379
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.378;
commitid	B0kwmVGiD5DVx4kv;

1.378
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.377;
commitid	5gdEnqVoJuTuwdTu;

1.377
date	2015.11.23.10.52.43;	author mpi;	state Exp;
branches;
next	1.376;
commitid	UywgOyMnPH4kBv9g;

1.376
date	2015.11.17.12.30.42;	author jmatthew;	state Exp;
branches;
next	1.375;
commitid	LppActNJsA2EdqKP;

1.375
date	2015.11.17.01.47.08;	author dlg;	state Exp;
branches;
next	1.374;
commitid	YkLYUV2QVi5PNDSw;

1.374
date	2015.11.14.17.54.57;	author mpi;	state Exp;
branches;
next	1.373;
commitid	Waft2RDjXAxr4qZ9;

1.373
date	2015.11.12.19.55.48;	author miod;	state Exp;
branches;
next	1.372;
commitid	FWipLCJfxkumIvl2;

1.372
date	2015.11.10.20.23.50;	author miod;	state Exp;
branches;
next	1.371;
commitid	Ud1TIxshPXuha0yj;

1.371
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.370;
commitid	hPF95ClMUQfeqQDX;

1.370
date	2015.10.19.05.31.25;	author jmatthew;	state Exp;
branches;
next	1.369;
commitid	xd7z4vq95x3HWhpC;

1.369
date	2015.07.19.06.28.12;	author yuo;	state Exp;
branches;
next	1.368;
commitid	vzHDNxGG1slGlZhk;

1.368
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.367;
commitid	MVWrtktB46JRxFWT;

1.367
date	2015.05.19.12.50.53;	author mikeb;	state Exp;
branches;
next	1.366;
commitid	hsY44V5GAPPQaT64;

1.366
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.365;
commitid	p4LJxGKbi0BU2cG6;

1.365
date	2015.02.09.09.51.16;	author dlg;	state Exp;
branches;
next	1.364;
commitid	ecsRYfqGwuDCztWG;

1.364
date	2015.02.09.03.09.57;	author dlg;	state Exp;
branches;
next	1.363;
commitid	fE9MPAUoNdw8sZYO;

1.363
date	2015.01.24.02.36.03;	author brad;	state Exp;
branches;
next	1.362;
commitid	4IjQyeY4sFUM2Hn4;

1.362
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.361;
commitid	yM2VFFhpDTeFQlve;

1.361
date	2014.09.02.10.14.55;	author brad;	state Exp;
branches;
next	1.360;
commitid	cBxS2Zdkcm4wMwIx;

1.360
date	2014.08.26.11.01.21;	author mikeb;	state Exp;
branches;
next	1.359;
commitid	NTysWaOWh0v3MRJC;

1.359
date	2014.08.21.14.30.21;	author brad;	state Exp;
branches;
next	1.358;
commitid	jj9iBwex2GMfzWbp;

1.358
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches
	1.358.4.1;
next	1.357;
commitid	TGHgrLxu6sxZoiFt;

1.357
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.356;
commitid	OBNa5kfxQ2UXoiIw;

1.356
date	2014.07.08.05.35.18;	author dlg;	state Exp;
branches;
next	1.355;
commitid	0QJleeeWqZmC5anF;

1.355
date	2014.07.03.13.26.05;	author dlg;	state Exp;
branches;
next	1.354;
commitid	a049z4yJxaXfzkbW;

1.354
date	2014.04.22.11.54.46;	author naddy;	state Exp;
branches;
next	1.353;

1.353
date	2014.02.24.20.00.48;	author brad;	state Exp;
branches;
next	1.352;

1.352
date	2014.02.05.05.59.42;	author brad;	state Exp;
branches;
next	1.351;

1.351
date	2014.02.04.05.20.47;	author brad;	state Exp;
branches;
next	1.350;

1.350
date	2014.02.01.01.51.27;	author brad;	state Exp;
branches;
next	1.349;

1.349
date	2014.01.31.01.16.10;	author brad;	state Exp;
branches;
next	1.348;

1.348
date	2014.01.28.21.50.57;	author naddy;	state Exp;
branches;
next	1.347;

1.347
date	2014.01.28.00.39.22;	author brad;	state Exp;
branches;
next	1.346;

1.346
date	2013.12.30.18.47.45;	author brad;	state Exp;
branches;
next	1.345;

1.345
date	2013.12.28.03.34.54;	author deraadt;	state Exp;
branches;
next	1.344;

1.344
date	2013.12.22.20.39.23;	author kettenis;	state Exp;
branches;
next	1.343;

1.343
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.342;

1.342
date	2013.11.26.20.35.36;	author deraadt;	state Exp;
branches;
next	1.341;

1.341
date	2013.10.23.20.38.23;	author brad;	state Exp;
branches;
next	1.340;

1.340
date	2013.08.25.18.34.21;	author mikeb;	state Exp;
branches;
next	1.339;

1.339
date	2013.08.07.01.06.33;	author bluhm;	state Exp;
branches;
next	1.338;

1.338
date	2013.07.11.11.25.42;	author mikeb;	state Exp;
branches;
next	1.337;

1.337
date	2013.06.28.11.59.42;	author mikeb;	state Exp;
branches;
next	1.336;

1.336
date	2013.06.25.10.08.04;	author mikeb;	state Exp;
branches;
next	1.335;

1.335
date	2013.06.10.13.38.47;	author mikeb;	state Exp;
branches;
next	1.334;

1.334
date	2013.06.06.00.05.30;	author dlg;	state Exp;
branches;
next	1.333;

1.333
date	2013.06.04.09.47.25;	author mikeb;	state Exp;
branches;
next	1.332;

1.332
date	2013.06.04.09.41.50;	author mikeb;	state Exp;
branches;
next	1.331;

1.331
date	2013.06.04.09.36.20;	author mikeb;	state Exp;
branches;
next	1.330;

1.330
date	2013.05.31.14.27.20;	author mikeb;	state Exp;
branches;
next	1.329;

1.329
date	2013.05.29.17.04.46;	author mikeb;	state Exp;
branches;
next	1.328;

1.328
date	2013.05.22.16.02.31;	author mikeb;	state Exp;
branches;
next	1.327;

1.327
date	2013.04.07.03.22.05;	author dlg;	state Exp;
branches;
next	1.326;

1.326
date	2013.04.03.18.07.07;	author brad;	state Exp;
branches;
next	1.325;

1.325
date	2013.03.20.02.46.33;	author brad;	state Exp;
branches;
next	1.324;

1.324
date	2013.03.17.10.17.54;	author brad;	state Exp;
branches;
next	1.323;

1.323
date	2013.03.11.01.12.40;	author dlg;	state Exp;
branches;
next	1.322;

1.322
date	2013.03.07.21.35.19;	author brad;	state Exp;
branches;
next	1.321;

1.321
date	2013.03.07.19.30.52;	author brad;	state Exp;
branches;
next	1.320;

1.320
date	2013.03.04.01.33.18;	author dlg;	state Exp;
branches;
next	1.319;

1.319
date	2013.02.22.01.26.55;	author dlg;	state Exp;
branches;
next	1.318;

1.318
date	2013.02.09.23.39.37;	author brad;	state Exp;
branches;
next	1.317;

1.317
date	2013.01.30.11.15.06;	author dlg;	state Exp;
branches;
next	1.316;

1.316
date	2013.01.29.00.41.02;	author dlg;	state Exp;
branches;
next	1.315;

1.315
date	2013.01.15.05.11.47;	author claudio;	state Exp;
branches;
next	1.314;

1.314
date	2013.01.10.01.17.00;	author dlg;	state Exp;
branches;
next	1.313;

1.313
date	2013.01.10.01.02.12;	author dlg;	state Exp;
branches;
next	1.312;

1.312
date	2012.09.13.04.15.18;	author dlg;	state Exp;
branches;
next	1.311;

1.311
date	2012.07.04.13.24.41;	author kettenis;	state Exp;
branches;
next	1.310;

1.310
date	2012.07.04.08.06.33;	author kettenis;	state Exp;
branches;
next	1.309;

1.309
date	2012.06.28.11.52.15;	author mikeb;	state Exp;
branches;
next	1.308;

1.308
date	2012.06.09.09.45.14;	author dlg;	state Exp;
branches;
next	1.307;

1.307
date	2011.06.22.16.44.27;	author tedu;	state Exp;
branches;
next	1.306;

1.306
date	2011.04.05.18.01.21;	author henning;	state Exp;
branches;
next	1.305;

1.305
date	2011.02.22.18.00.44;	author robert;	state Exp;
branches;
next	1.304;

1.304
date	2011.02.15.19.49.47;	author robert;	state Exp;
branches;
next	1.303;

1.303
date	2010.09.20.07.40.38;	author deraadt;	state Exp;
branches;
next	1.302;

1.302
date	2010.09.07.16.21.44;	author deraadt;	state Exp;
branches;
next	1.301;

1.301
date	2010.08.31.17.13.44;	author deraadt;	state Exp;
branches;
next	1.300;

1.300
date	2010.08.31.16.27.36;	author deraadt;	state Exp;
branches;
next	1.299;

1.299
date	2010.08.27.19.48.14;	author deraadt;	state Exp;
branches;
next	1.298;

1.298
date	2010.08.07.03.50.02;	author krw;	state Exp;
branches;
next	1.297;

1.297
date	2010.08.02.19.36.13;	author kettenis;	state Exp;
branches;
next	1.296;

1.296
date	2010.07.27.21.56.11;	author todd;	state Exp;
branches;
next	1.295;

1.295
date	2010.07.27.19.38.18;	author kettenis;	state Exp;
branches;
next	1.294;

1.294
date	2010.07.09.00.04.42;	author sthen;	state Exp;
branches;
next	1.293;

1.293
date	2010.04.06.15.27.51;	author naddy;	state Exp;
branches;
next	1.292;

1.292
date	2010.03.30.14.24.03;	author naddy;	state Exp;
branches;
next	1.291;

1.291
date	2010.01.10.00.07.40;	author naddy;	state Exp;
branches;
next	1.290;

1.290
date	2010.01.09.06.19.01;	author naddy;	state Exp;
branches;
next	1.289;

1.289
date	2009.12.17.00.55.19;	author sthen;	state Exp;
branches;
next	1.288;

1.288
date	2009.12.09.17.13.02;	author naddy;	state Exp;
branches;
next	1.287;

1.287
date	2009.11.30.19.08.01;	author kettenis;	state Exp;
branches;
next	1.286;

1.286
date	2009.10.11.16.53.13;	author sthen;	state Exp;
branches;
next	1.285;

1.285
date	2009.10.11.10.36.31;	author sthen;	state Exp;
branches;
next	1.284;

1.284
date	2009.10.07.22.05.51;	author sthen;	state Exp;
branches;
next	1.283;

1.283
date	2009.10.02.18.32.40;	author sthen;	state Exp;
branches;
next	1.282;

1.282
date	2009.09.30.19.20.52;	author sthen;	state Exp;
branches;
next	1.281;

1.281
date	2009.08.13.14.24.47;	author jasper;	state Exp;
branches;
next	1.280;

1.280
date	2009.08.09.11.40.56;	author deraadt;	state Exp;
branches;
next	1.279;

1.279
date	2009.08.08.15.58.14;	author naddy;	state Exp;
branches;
next	1.278;

1.278
date	2009.08.06.10.42.54;	author sthen;	state Exp;
branches;
next	1.277;

1.277
date	2009.07.21.13.09.41;	author naddy;	state Exp;
branches;
next	1.276;

1.276
date	2009.06.19.21.31.54;	author naddy;	state Exp;
branches
	1.276.4.1;
next	1.275;

1.275
date	2009.06.11.23.11.27;	author sthen;	state Exp;
branches;
next	1.274;

1.274
date	2009.06.11.22.44.14;	author sthen;	state Exp;
branches;
next	1.273;

1.273
date	2009.06.06.14.25.38;	author sthen;	state Exp;
branches;
next	1.272;

1.272
date	2009.06.05.03.57.32;	author ray;	state Exp;
branches;
next	1.271;

1.271
date	2009.06.04.04.09.02;	author naddy;	state Exp;
branches;
next	1.270;

1.270
date	2009.06.04.00.59.21;	author naddy;	state Exp;
branches;
next	1.269;

1.269
date	2009.06.03.20.54.45;	author naddy;	state Exp;
branches;
next	1.268;

1.268
date	2009.06.03.05.55.15;	author naddy;	state Exp;
branches;
next	1.267;

1.267
date	2009.06.03.05.19.21;	author naddy;	state Exp;
branches;
next	1.266;

1.266
date	2009.06.02.03.58.17;	author naddy;	state Exp;
branches;
next	1.265;

1.265
date	2009.06.02.02.16.41;	author sthen;	state Exp;
branches;
next	1.264;

1.264
date	2009.05.24.14.11.35;	author naddy;	state Exp;
branches;
next	1.263;

1.263
date	2009.05.21.23.04.20;	author sthen;	state Exp;
branches;
next	1.262;

1.262
date	2009.04.23.19.15.07;	author kettenis;	state Exp;
branches;
next	1.261;

1.261
date	2009.01.27.09.17.51;	author dlg;	state Exp;
branches;
next	1.260;

1.260
date	2008.12.23.00.14.18;	author dlg;	state Exp;
branches;
next	1.259;

1.259
date	2008.12.23.00.12.22;	author dlg;	state Exp;
branches;
next	1.258;

1.258
date	2008.12.03.23.51.52;	author dlg;	state Exp;
branches;
next	1.257;

1.257
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.256;

1.256
date	2008.11.22.18.16.55;	author dlg;	state Exp;
branches;
next	1.255;

1.255
date	2008.11.09.15.08.26;	author naddy;	state Exp;
branches;
next	1.254;

1.254
date	2008.11.08.07.37.07;	author deraadt;	state Exp;
branches;
next	1.253;

1.253
date	2008.11.08.07.13.02;	author deraadt;	state Exp;
branches;
next	1.252;

1.252
date	2008.11.08.07.10.13;	author brad;	state Exp;
branches;
next	1.251;

1.251
date	2008.11.08.07.00.52;	author brad;	state Exp;
branches;
next	1.250;

1.250
date	2008.11.07.22.52.15;	author brad;	state Exp;
branches;
next	1.249;

1.249
date	2008.10.19.08.13.01;	author brad;	state Exp;
branches;
next	1.248;

1.248
date	2008.10.16.19.18.03;	author naddy;	state Exp;
branches;
next	1.247;

1.247
date	2008.10.14.18.01.53;	author naddy;	state Exp;
branches;
next	1.246;

1.246
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.245;

1.245
date	2008.09.23.00.27.18;	author brad;	state Exp;
branches;
next	1.244;

1.244
date	2008.09.18.15.16.30;	author naddy;	state Exp;
branches;
next	1.243;

1.243
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.242;

1.242
date	2008.09.08.08.10.54;	author brad;	state Exp;
branches;
next	1.241;

1.241
date	2008.08.26.19.43.05;	author kettenis;	state Exp;
branches;
next	1.240;

1.240
date	2008.08.24.20.24.43;	author deraadt;	state Exp;
branches;
next	1.239;

1.239
date	2008.08.24.16.30.18;	author deraadt;	state Exp;
branches;
next	1.238;

1.238
date	2008.07.17.19.59.44;	author brad;	state Exp;
branches;
next	1.237;

1.237
date	2008.07.16.03.56.25;	author brad;	state Exp;
branches;
next	1.236;

1.236
date	2008.06.07.19.05.11;	author brad;	state Exp;
branches;
next	1.235;

1.235
date	2008.05.24.02.21.50;	author brad;	state Exp;
branches;
next	1.234;

1.234
date	2008.05.23.22.50.06;	author kettenis;	state Exp;
branches;
next	1.233;

1.233
date	2008.05.23.08.49.27;	author brad;	state Exp;
branches;
next	1.232;

1.232
date	2008.05.21.22.27.01;	author kettenis;	state Exp;
branches;
next	1.231;

1.231
date	2008.05.14.03.52.34;	author brad;	state Exp;
branches;
next	1.230;

1.230
date	2008.05.12.03.50.55;	author brad;	state Exp;
branches;
next	1.229;

1.229
date	2008.05.11.09.56.11;	author brad;	state Exp;
branches;
next	1.228;

1.228
date	2008.05.11.05.12.56;	author brad;	state Exp;
branches;
next	1.227;

1.227
date	2008.05.09.06.30.40;	author krw;	state Exp;
branches;
next	1.226;

1.226
date	2008.04.20.01.37.35;	author brad;	state Exp;
branches;
next	1.225;

1.225
date	2008.04.20.01.32.43;	author brad;	state Exp;
branches;
next	1.224;

1.224
date	2008.04.03.22.50.24;	author brad;	state Exp;
branches;
next	1.223;

1.223
date	2008.03.21.21.11.04;	author brad;	state Exp;
branches;
next	1.222;

1.222
date	2008.02.20.12.17.25;	author brad;	state Exp;
branches
	1.222.2.1;
next	1.221;

1.221
date	2008.02.20.10.26.53;	author sthen;	state Exp;
branches;
next	1.220;

1.220
date	2008.02.18.09.40.11;	author brad;	state Exp;
branches;
next	1.219;

1.219
date	2008.02.17.06.39.16;	author brad;	state Exp;
branches;
next	1.218;

1.218
date	2008.02.02.04.03.33;	author brad;	state Exp;
branches;
next	1.217;

1.217
date	2008.01.31.03.43.00;	author brad;	state Exp;
branches;
next	1.216;

1.216
date	2007.11.17.13.55.27;	author brad;	state Exp;
branches;
next	1.215;

1.215
date	2007.10.13.16.29.52;	author kettenis;	state Exp;
branches;
next	1.214;

1.214
date	2007.10.09.05.43.37;	author ray;	state Exp;
branches;
next	1.213;

1.213
date	2007.06.21.01.11.50;	author dlg;	state Exp;
branches;
next	1.212;

1.212
date	2007.05.03.10.11.25;	author tom;	state Exp;
branches;
next	1.211;

1.211
date	2007.05.02.10.03.42;	author dlg;	state Exp;
branches;
next	1.210;

1.210
date	2007.05.02.09.13.21;	author dlg;	state Exp;
branches;
next	1.209;

1.209
date	2007.04.03.22.12.59;	author kettenis;	state Exp;
branches;
next	1.208;

1.208
date	2007.03.19.02.27.40;	author krw;	state Exp;
branches;
next	1.207;

1.207
date	2007.02.16.01.25.50;	author krw;	state Exp;
branches;
next	1.206;

1.206
date	2007.02.10.01.23.19;	author krw;	state Exp;
branches;
next	1.205;

1.205
date	2007.01.30.02.35.16;	author krw;	state Exp;
branches;
next	1.204;

1.204
date	2007.01.19.01.16.14;	author krw;	state Exp;
branches;
next	1.203;

1.203
date	2007.01.10.23.04.53;	author kettenis;	state Exp;
branches;
next	1.202;

1.202
date	2006.12.22.17.37.50;	author krw;	state Exp;
branches;
next	1.201;

1.201
date	2006.12.17.06.04.11;	author krw;	state Exp;
branches;
next	1.200;

1.200
date	2006.12.08.02.13.36;	author gwk;	state Exp;
branches;
next	1.199;

1.199
date	2006.12.04.14.35.20;	author reyk;	state Exp;
branches;
next	1.198;

1.198
date	2006.11.26.19.13.39;	author brad;	state Exp;
branches;
next	1.197;

1.197
date	2006.11.26.11.14.21;	author deraadt;	state Exp;
branches;
next	1.196;

1.196
date	2006.11.20.22.40.39;	author brad;	state Exp;
branches;
next	1.195;

1.195
date	2006.10.28.22.14.47;	author brad;	state Exp;
branches;
next	1.194;

1.194
date	2006.10.26.22.57.17;	author brad;	state Exp;
branches;
next	1.193;

1.193
date	2006.10.26.22.41.10;	author brad;	state Exp;
branches;
next	1.192;

1.192
date	2006.10.25.02.37.50;	author brad;	state Exp;
branches;
next	1.191;

1.191
date	2006.10.22.21.45.36;	author brad;	state Exp;
branches;
next	1.190;

1.190
date	2006.10.17.22.28.07;	author brad;	state Exp;
branches;
next	1.189;

1.189
date	2006.10.15.06.49.19;	author brad;	state Exp;
branches;
next	1.188;

1.188
date	2006.10.10.21.04.14;	author brad;	state Exp;
branches;
next	1.187;

1.187
date	2006.10.09.18.46.44;	author deraadt;	state Exp;
branches;
next	1.186;

1.186
date	2006.10.07.23.08.50;	author brad;	state Exp;
branches;
next	1.185;

1.185
date	2006.10.07.20.28.48;	author brad;	state Exp;
branches;
next	1.184;

1.184
date	2006.10.01.17.29.48;	author brad;	state Exp;
branches;
next	1.183;

1.183
date	2006.10.01.00.34.07;	author brad;	state Exp;
branches;
next	1.182;

1.182
date	2006.09.26.23.57.16;	author brad;	state Exp;
branches;
next	1.181;

1.181
date	2006.09.26.13.10.44;	author mickey;	state Exp;
branches;
next	1.180;

1.180
date	2006.09.17.23.31.07;	author brad;	state Exp;
branches;
next	1.179;

1.179
date	2006.09.17.22.19.37;	author brad;	state Exp;
branches;
next	1.178;

1.178
date	2006.09.17.17.20.42;	author brad;	state Exp;
branches;
next	1.177;

1.177
date	2006.09.17.16.45.22;	author brad;	state Exp;
branches;
next	1.176;

1.176
date	2006.09.16.12.24.33;	author kettenis;	state Exp;
branches;
next	1.175;

1.175
date	2006.08.30.21.28.06;	author kettenis;	state Exp;
branches;
next	1.174;

1.174
date	2006.08.29.17.44.16;	author kettenis;	state Exp;
branches;
next	1.173;

1.173
date	2006.08.28.07.58.51;	author kettenis;	state Exp;
branches;
next	1.172;

1.172
date	2006.08.28.03.06.47;	author brad;	state Exp;
branches;
next	1.171;

1.171
date	2006.08.28.01.12.17;	author brad;	state Exp;
branches;
next	1.170;

1.170
date	2006.08.28.00.49.47;	author brad;	state Exp;
branches;
next	1.169;

1.169
date	2006.08.27.21.42.13;	author brad;	state Exp;
branches;
next	1.168;

1.168
date	2006.08.27.21.06.16;	author brad;	state Exp;
branches;
next	1.167;

1.167
date	2006.08.04.15.22.41;	author brad;	state Exp;
branches;
next	1.166;

1.166
date	2006.07.01.06.26.51;	author brad;	state Exp;
branches;
next	1.165;

1.165
date	2006.06.29.01.43.34;	author brad;	state Exp;
branches;
next	1.164;

1.164
date	2006.06.27.16.46.24;	author brad;	state Exp;
branches;
next	1.163;

1.163
date	2006.06.27.16.40.11;	author brad;	state Exp;
branches;
next	1.162;

1.162
date	2006.06.22.04.15.47;	author brad;	state Exp;
branches;
next	1.161;

1.161
date	2006.06.21.19.11.01;	author brad;	state Exp;
branches;
next	1.160;

1.160
date	2006.06.21.17.21.41;	author brad;	state Exp;
branches;
next	1.159;

1.159
date	2006.06.20.07.04.32;	author brad;	state Exp;
branches;
next	1.158;

1.158
date	2006.06.20.06.54.56;	author brad;	state Exp;
branches;
next	1.157;

1.157
date	2006.06.20.03.45.22;	author brad;	state Exp;
branches;
next	1.156;

1.156
date	2006.06.19.05.15.23;	author brad;	state Exp;
branches;
next	1.155;

1.155
date	2006.06.19.05.11.56;	author brad;	state Exp;
branches;
next	1.154;

1.154
date	2006.06.17.18.00.43;	author brad;	state Exp;
branches;
next	1.153;

1.153
date	2006.06.15.20.34.41;	author brad;	state Exp;
branches;
next	1.152;

1.152
date	2006.06.11.00.31.57;	author brad;	state Exp;
branches;
next	1.151;

1.151
date	2006.06.02.05.58.24;	author beck;	state Exp;
branches;
next	1.150;

1.150
date	2006.05.31.23.40.08;	author brad;	state Exp;
branches;
next	1.149;

1.149
date	2006.05.28.00.20.21;	author brad;	state Exp;
branches;
next	1.148;

1.148
date	2006.05.28.00.04.24;	author jason;	state Exp;
branches;
next	1.147;

1.147
date	2006.05.27.10.03.15;	author brad;	state Exp;
branches;
next	1.146;

1.146
date	2006.05.20.04.18.51;	author brad;	state Exp;
branches;
next	1.145;

1.145
date	2006.05.20.03.47.56;	author brad;	state Exp;
branches;
next	1.144;

1.144
date	2006.05.08.20.08.02;	author brad;	state Exp;
branches;
next	1.143;

1.143
date	2006.04.30.05.42.31;	author brad;	state Exp;
branches;
next	1.142;

1.142
date	2006.04.24.00.00.21;	author brad;	state Exp;
branches;
next	1.141;

1.141
date	2006.04.21.03.22.18;	author brad;	state Exp;
branches;
next	1.140;

1.140
date	2006.04.05.01.47.38;	author brad;	state Exp;
branches;
next	1.139;

1.139
date	2006.03.29.02.23.25;	author brad;	state Exp;
branches;
next	1.138;

1.138
date	2006.03.25.22.41.44;	author djm;	state Exp;
branches;
next	1.137;

1.137
date	2006.03.16.02.40.16;	author brad;	state Exp;
branches;
next	1.136;

1.136
date	2006.03.10.21.39.01;	author brad;	state Exp;
branches;
next	1.135;

1.135
date	2006.02.21.01.45.47;	author brad;	state Exp;
branches;
next	1.134;

1.134
date	2006.02.13.00.57.10;	author brad;	state Exp;
branches;
next	1.133;

1.133
date	2006.02.13.00.44.52;	author brad;	state Exp;
branches;
next	1.132;

1.132
date	2006.02.11.09.01.30;	author brad;	state Exp;
branches;
next	1.131;

1.131
date	2006.02.09.03.31.44;	author brad;	state Exp;
branches;
next	1.130;

1.130
date	2006.02.09.01.17.24;	author brad;	state Exp;
branches;
next	1.129;

1.129
date	2006.02.08.22.09.20;	author brad;	state Exp;
branches;
next	1.128;

1.128
date	2006.02.06.04.59.30;	author brad;	state Exp;
branches;
next	1.127;

1.127
date	2006.02.02.21.31.10;	author brad;	state Exp;
branches;
next	1.126;

1.126
date	2006.02.02.20.35.55;	author brad;	state Exp;
branches;
next	1.125;

1.125
date	2006.02.02.07.15.37;	author brad;	state Exp;
branches;
next	1.124;

1.124
date	2006.02.01.02.02.49;	author brad;	state Exp;
branches;
next	1.123;

1.123
date	2006.02.01.01.53.32;	author brad;	state Exp;
branches;
next	1.122;

1.122
date	2006.02.01.01.31.43;	author brad;	state Exp;
branches;
next	1.121;

1.121
date	2006.01.25.21.01.24;	author brad;	state Exp;
branches;
next	1.120;

1.120
date	2005.12.28.22.02.44;	author brad;	state Exp;
branches;
next	1.119;

1.119
date	2005.12.28.21.55.53;	author brad;	state Exp;
branches;
next	1.118;

1.118
date	2005.12.28.20.46.15;	author brad;	state Exp;
branches;
next	1.117;

1.117
date	2005.12.28.20.27.38;	author brad;	state Exp;
branches;
next	1.116;

1.116
date	2005.12.12.05.25.07;	author brad;	state Exp;
branches;
next	1.115;

1.115
date	2005.12.11.01.37.21;	author brad;	state Exp;
branches;
next	1.114;

1.114
date	2005.12.10.18.40.45;	author brad;	state Exp;
branches;
next	1.113;

1.113
date	2005.12.09.21.35.44;	author brad;	state Exp;
branches;
next	1.112;

1.112
date	2005.12.09.21.06.45;	author brad;	state Exp;
branches;
next	1.111;

1.111
date	2005.12.08.03.53.38;	author brad;	state Exp;
branches;
next	1.110;

1.110
date	2005.12.08.03.27.18;	author brad;	state Exp;
branches;
next	1.109;

1.109
date	2005.12.08.02.32.21;	author brad;	state Exp;
branches;
next	1.108;

1.108
date	2005.12.08.01.00.46;	author brad;	state Exp;
branches;
next	1.107;

1.107
date	2005.11.29.20.35.58;	author brad;	state Exp;
branches;
next	1.106;

1.106
date	2005.11.28.20.26.04;	author brad;	state Exp;
branches;
next	1.105;

1.105
date	2005.11.27.01.20.41;	author brad;	state Exp;
branches;
next	1.104;

1.104
date	2005.11.27.00.26.36;	author brad;	state Exp;
branches;
next	1.103;

1.103
date	2005.11.25.03.42.35;	author brad;	state Exp;
branches;
next	1.102;

1.102
date	2005.11.25.03.02.14;	author brad;	state Exp;
branches;
next	1.101;

1.101
date	2005.11.25.02.08.54;	author brad;	state Exp;
branches;
next	1.100;

1.100
date	2005.11.25.02.05.24;	author brad;	state Exp;
branches;
next	1.99;

1.99
date	2005.11.25.01.21.44;	author brad;	state Exp;
branches;
next	1.98;

1.98
date	2005.11.25.00.37.59;	author brad;	state Exp;
branches;
next	1.97;

1.97
date	2005.11.25.00.14.59;	author brad;	state Exp;
branches;
next	1.96;

1.96
date	2005.11.25.00.09.05;	author brad;	state Exp;
branches;
next	1.95;

1.95
date	2005.11.24.23.48.29;	author brad;	state Exp;
branches;
next	1.94;

1.94
date	2005.11.24.12.25.07;	author fgsch;	state Exp;
branches;
next	1.93;

1.93
date	2005.11.19.23.04.48;	author brad;	state Exp;
branches;
next	1.92;

1.92
date	2005.11.14.13.11.40;	author mickey;	state Exp;
branches;
next	1.91;

1.91
date	2005.10.21.22.27.07;	author brad;	state Exp;
branches;
next	1.90;

1.90
date	2005.10.14.03.34.09;	author brad;	state Exp;
branches;
next	1.89;

1.89
date	2005.10.14.03.29.12;	author brad;	state Exp;
branches;
next	1.88;

1.88
date	2005.10.14.01.38.09;	author brad;	state Exp;
branches;
next	1.87;

1.87
date	2005.10.10.00.10.29;	author brad;	state Exp;
branches;
next	1.86;

1.86
date	2005.10.09.23.41.55;	author brad;	state Exp;
branches;
next	1.85;

1.85
date	2005.10.09.20.55.41;	author brad;	state Exp;
branches;
next	1.84;

1.84
date	2005.10.06.06.01.05;	author brad;	state Exp;
branches;
next	1.83;

1.83
date	2005.10.06.03.39.16;	author brad;	state Exp;
branches;
next	1.82;

1.82
date	2005.09.08.19.19.50;	author brad;	state Exp;
branches;
next	1.81;

1.81
date	2005.08.30.03.18.30;	author brad;	state Exp;
branches;
next	1.80;

1.80
date	2005.08.27.14.12.36;	author brad;	state Exp;
branches;
next	1.79;

1.79
date	2005.08.09.04.10.11;	author mickey;	state Exp;
branches;
next	1.78;

1.78
date	2005.07.25.00.49.43;	author brad;	state Exp;
branches;
next	1.77;

1.77
date	2005.07.20.01.22.25;	author brad;	state Exp;
branches;
next	1.76;

1.76
date	2005.07.16.17.37.18;	author brad;	state Exp;
branches;
next	1.75;

1.75
date	2005.07.14.05.54.48;	author jsg;	state Exp;
branches;
next	1.74;

1.74
date	2005.07.09.22.22.41;	author brad;	state Exp;
branches;
next	1.73;

1.73
date	2005.07.07.21.28.10;	author brad;	state Exp;
branches;
next	1.72;

1.72
date	2005.07.06.00.56.33;	author brad;	state Exp;
branches;
next	1.71;

1.71
date	2005.07.02.00.34.29;	author brad;	state Exp;
branches;
next	1.70;

1.70
date	2005.07.01.20.47.50;	author brad;	state Exp;
branches;
next	1.69;

1.69
date	2005.06.29.04.25.10;	author brad;	state Exp;
branches;
next	1.68;

1.68
date	2005.06.29.04.03.42;	author brad;	state Exp;
branches;
next	1.67;

1.67
date	2005.06.29.03.36.06;	author brad;	state Exp;
branches;
next	1.66;

1.66
date	2005.06.26.06.06.17;	author brad;	state Exp;
branches;
next	1.65;

1.65
date	2005.06.26.03.17.55;	author brad;	state Exp;
branches;
next	1.64;

1.64
date	2005.06.17.15.15.43;	author brad;	state Exp;
branches;
next	1.63;

1.63
date	2005.06.15.16.30.34;	author camield;	state Exp;
branches;
next	1.62;

1.62
date	2005.06.07.20.39.07;	author brad;	state Exp;
branches;
next	1.61;

1.61
date	2005.06.07.20.24.20;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2005.06.07.17.38.54;	author brad;	state Exp;
branches;
next	1.59;

1.59
date	2005.05.21.17.24.50;	author brad;	state Exp;
branches;
next	1.58;

1.58
date	2005.04.25.17.55.51;	author brad;	state Exp;
branches;
next	1.57;

1.57
date	2005.04.04.22.22.07;	author beck;	state Exp;
branches;
next	1.56;

1.56
date	2005.04.01.02.49.03;	author brad;	state Exp;
branches;
next	1.55;

1.55
date	2005.03.27.16.14.43;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2005.03.07.18.59.11;	author brad;	state Exp;
branches;
next	1.53;

1.53
date	2005.03.07.13.31.40;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2005.03.04.00.55.44;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2005.01.17.03.00.27;	author brad;	state Exp;
branches;
next	1.50;

1.50
date	2005.01.01.20.45.46;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2004.12.30.05.44.15;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2004.12.26.02.10.22;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2004.12.24.23.44.10;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.24.23.29.14;	author brad;	state Exp;
branches;
next	1.45;

1.45
date	2004.12.17.03.13.59;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2004.12.16.14.30.31;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2004.12.12.19.11.26;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2004.12.12.05.03.05;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2004.12.11.05.57.04;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2004.12.10.05.04.23;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2004.12.10.02.49.18;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2004.12.10.02.36.38;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2004.11.24.03.21.28;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2004.11.16.14.27.43;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2004.11.11.18.35.41;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2004.10.31.06.59.25;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2004.09.28.04.37.32;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2004.09.16.00.55.09;	author mcbride;	state Exp;
branches;
next	1.30;

1.30
date	2004.08.19.17.00.03;	author mcbride;	state Exp;
branches;
next	1.29;

1.29
date	2004.08.17.18.23.49;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2004.08.05.19.57.17;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.29.23.07.48;	author naddy;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.25.04.59.10;	author mcbride;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.12.06.56.42;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.09.21.52.16;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.27.16.03.06;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.26.15.07.25;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.13.16.18.56;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.03.21.24.28;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.11.19.20.27;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.15.06.31.24;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.26.06.01.28;	author nate;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.26.05.09.36;	author nate;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.26.04.38.40;	author nate;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.23.14.49.21;	author nate;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.14.21.34.59;	author todd;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.29.15.25.38;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.26.18.45.17;	author nate;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.26.18.42.49;	author nate;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.08.21.46.23;	author nate;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.12.09.51.20;	author kjc;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.15.20.45.31;	author nordin;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.11.01.31.21;	author nordin;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.24.18.30.43;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.09.21.16.20;	author nate;	state Exp;
branches
	1.3.4.1
	1.3.6.1;
next	1.2;

1.2
date	2001.10.09.20.34.54;	author nate;	state Exp;
branches;
next	1.1;

1.1
date	2001.10.05.18.57.28;	author nate;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2003.03.28.00.38.21;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2004.02.19.10.56.26;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2004.06.05.23.12.49;	author niklas;	state Exp;
branches;
next	;

1.3.6.1
date	2002.01.31.22.55.35;	author niklas;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.3.6.3;

1.3.6.3
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	1.3.6.4;

1.3.6.4
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;

1.222.2.1
date	2008.07.15.17.34.01;	author brad;	state Exp;
branches;
next	;

1.276.4.1
date	2009.10.23.00.38.00;	author william;	state Exp;
branches;
next	;

1.358.4.1
date	2014.09.07.03.15.42;	author jsg;	state Exp;
branches;
next	;
commitid	WD5M7v5ollO6mSXH;


desc
@@


1.386
log
@Fix asic test.  Coverity CID 990792.
ok mpi@@ tom@@ mikeb@@
@
text
@/*	$OpenBSD: if_bge.c,v 1.385 2017/02/13 00:56:32 dlg Exp $	*/

/*
 * Copyright (c) 2001 Wind River Systems
 * Copyright (c) 1997, 1998, 1999, 2001
 *	Bill Paul <wpaul@@windriver.com>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: if_bge.c,v 1.25 2002/11/14 23:54:49 sam Exp $
 */

/*
 * Broadcom BCM57xx/BCM590x family ethernet driver for OpenBSD.
 *
 * Written by Bill Paul <wpaul@@windriver.com>
 * Senior Engineer, Wind River Systems
 */

/*
 * The Broadcom BCM5700 is based on technology originally developed by
 * Alteon Networks as part of the Tigon I and Tigon II gigabit ethernet
 * MAC chips. The BCM5700, sometimes referred to as the Tigon III, has
 * two on-board MIPS R4000 CPUs and can have as much as 16MB of external
 * SSRAM. The BCM5700 supports TCP, UDP and IP checksum offload, jumbo
 * frames, highly configurable RX filtering, and 16 RX and TX queues
 * (which, along with RX filter rules, can be used for QOS applications).
 * Other features, such as TCP segmentation, may be available as part
 * of value-added firmware updates. Unlike the Tigon I and Tigon II,
 * firmware images can be stored in hardware and need not be compiled
 * into the driver.
 *
 * The BCM5700 supports the PCI v2.2 and PCI-X v1.0 standards, and will
 * function in a 32-bit/64-bit 33/66MHz bus, or a 64-bit/133MHz bus.
 *
 * The BCM5701 is a single-chip solution incorporating both the BCM5700
 * MAC and a BCM5401 10/100/1000 PHY. Unlike the BCM5700, the BCM5701
 * does not support external SSRAM.
 *
 * Broadcom also produces a variation of the BCM5700 under the "Altima"
 * brand name, which is functionally similar but lacks PCI-X support.
 *
 * Without external SSRAM, you can only have at most 4 TX rings,
 * and the use of the mini RX ring is disabled. This seems to imply
 * that these features are simply not available on the BCM5701. As a
 * result, this driver does not implement any support for the mini RX
 * ring.
 */

#include "bpfilter.h"
#include "vlan.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/socket.h>
#include <sys/atomic.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#ifdef __sparc64__
#include <sparc64/autoconf.h>
#include <dev/ofw/openfirm.h>
#endif

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/miidevs.h>
#include <dev/mii/brgphyreg.h>

#include <dev/pci/if_bgereg.h>

#define ETHER_MIN_NOPAD		(ETHER_MIN_LEN - ETHER_CRC_LEN) /* i.e., 60 */

const struct bge_revision * bge_lookup_rev(u_int32_t);
int bge_can_use_msi(struct bge_softc *);
int bge_probe(struct device *, void *, void *);
void bge_attach(struct device *, struct device *, void *);
int bge_detach(struct device *, int);
int bge_activate(struct device *, int);

struct cfattach bge_ca = {
	sizeof(struct bge_softc), bge_probe, bge_attach, bge_detach,
	bge_activate
};

struct cfdriver bge_cd = {
	NULL, "bge", DV_IFNET
};

void bge_txeof(struct bge_softc *);
void bge_rxcsum(struct bge_softc *, struct bge_rx_bd *, struct mbuf *);
void bge_rxeof(struct bge_softc *);

void bge_tick(void *);
void bge_stats_update(struct bge_softc *);
void bge_stats_update_regs(struct bge_softc *);
int bge_cksum_pad(struct mbuf *);
int bge_encap(struct bge_softc *, struct mbuf *, int *);
int bge_compact_dma_runt(struct mbuf *);

int bge_intr(void *);
void bge_start(struct ifqueue *);
int bge_ioctl(struct ifnet *, u_long, caddr_t);
int bge_rxrinfo(struct bge_softc *, struct if_rxrinfo *);
void bge_init(void *);
void bge_stop_block(struct bge_softc *, bus_size_t, u_int32_t);
void bge_stop(struct bge_softc *, int);
void bge_watchdog(struct ifnet *);
int bge_ifmedia_upd(struct ifnet *);
void bge_ifmedia_sts(struct ifnet *, struct ifmediareq *);

u_int8_t bge_nvram_getbyte(struct bge_softc *, int, u_int8_t *);
int bge_read_nvram(struct bge_softc *, caddr_t, int, int);
u_int8_t bge_eeprom_getbyte(struct bge_softc *, int, u_int8_t *);
int bge_read_eeprom(struct bge_softc *, caddr_t, int, int);

void bge_iff(struct bge_softc *);

int bge_newbuf_jumbo(struct bge_softc *, int);
int bge_init_rx_ring_jumbo(struct bge_softc *);
void bge_fill_rx_ring_jumbo(struct bge_softc *);
void bge_free_rx_ring_jumbo(struct bge_softc *);

int bge_newbuf(struct bge_softc *, int);
int bge_init_rx_ring_std(struct bge_softc *);
void bge_rxtick(void *);
void bge_fill_rx_ring_std(struct bge_softc *);
void bge_free_rx_ring_std(struct bge_softc *);

void bge_free_tx_ring(struct bge_softc *);
int bge_init_tx_ring(struct bge_softc *);

void bge_chipinit(struct bge_softc *);
int bge_blockinit(struct bge_softc *);
u_int32_t bge_dma_swap_options(struct bge_softc *);
int bge_phy_addr(struct bge_softc *);

u_int32_t bge_readmem_ind(struct bge_softc *, int);
void bge_writemem_ind(struct bge_softc *, int, int);
void bge_writereg_ind(struct bge_softc *, int, int);
void bge_writembx(struct bge_softc *, int, int);

int bge_miibus_readreg(struct device *, int, int);
void bge_miibus_writereg(struct device *, int, int, int);
void bge_miibus_statchg(struct device *);

#define BGE_RESET_SHUTDOWN	0
#define BGE_RESET_START		1
#define BGE_RESET_SUSPEND	2
void bge_sig_post_reset(struct bge_softc *, int);
void bge_sig_legacy(struct bge_softc *, int);
void bge_sig_pre_reset(struct bge_softc *, int);
void bge_stop_fw(struct bge_softc *, int);
void bge_reset(struct bge_softc *);
void bge_link_upd(struct bge_softc *);

void bge_ape_lock_init(struct bge_softc *);
void bge_ape_read_fw_ver(struct bge_softc *);
int bge_ape_lock(struct bge_softc *, int);
void bge_ape_unlock(struct bge_softc *, int);
void bge_ape_send_event(struct bge_softc *, uint32_t);
void bge_ape_driver_state_change(struct bge_softc *, int);

#ifdef BGE_DEBUG
#define DPRINTF(x)	do { if (bgedebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (bgedebug >= (n)) printf x; } while (0)
int	bgedebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

/*
 * Various supported device vendors/types and their names. Note: the
 * spec seems to indicate that the hardware still has Alteon's vendor
 * ID burned into it, though it will always be overridden by the vendor
 * ID in the EEPROM. Just to be safe, we cover all possibilities.
 */
const struct pci_matchid bge_devices[] = {
	{ PCI_VENDOR_ALTEON, PCI_PRODUCT_ALTEON_BCM5700 },
	{ PCI_VENDOR_ALTEON, PCI_PRODUCT_ALTEON_BCM5701 },

	{ PCI_VENDOR_ALTIMA, PCI_PRODUCT_ALTIMA_AC1000 },
	{ PCI_VENDOR_ALTIMA, PCI_PRODUCT_ALTIMA_AC1001 },
	{ PCI_VENDOR_ALTIMA, PCI_PRODUCT_ALTIMA_AC1003 },
	{ PCI_VENDOR_ALTIMA, PCI_PRODUCT_ALTIMA_AC9100 },

	{ PCI_VENDOR_APPLE, PCI_PRODUCT_APPLE_BCM5701 },

	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5700 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5701 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5702 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5702_ALT },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5702X },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5703 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5703_ALT },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5703X },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5704C },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5704S },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5704S_ALT },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5705 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5705F },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5705K },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5705M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5705M_ALT },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5714 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5714S },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5715 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5715S },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5717 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5717C },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5718 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5719 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5720 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5721 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5722 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5723 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5725 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5727 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5751 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5751F },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5751M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5752 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5752M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5753 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5753F },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5753M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5754 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5754M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5755 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5755M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5756 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5761 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5761E },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5761S },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5761SE },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5762 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5764 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5780 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5780S },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5781 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5782 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5784 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5785F },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5785G },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5786 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5787 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5787F },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5787M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5788 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5789 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5901 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5901A2 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5903M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5906 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5906M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57760 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57761 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57762 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57764 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57765 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57766 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57767 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57780 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57781 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57782 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57785 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57786 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57787 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57788 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57790 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57791 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57795 },

	{ PCI_VENDOR_FUJITSU, PCI_PRODUCT_FUJITSU_PW008GE4 },
	{ PCI_VENDOR_FUJITSU, PCI_PRODUCT_FUJITSU_PW008GE5 },
	{ PCI_VENDOR_FUJITSU, PCI_PRODUCT_FUJITSU_PP250_450_LAN },

	{ PCI_VENDOR_SCHNEIDERKOCH, PCI_PRODUCT_SCHNEIDERKOCH_SK9D21 },

	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C996 }
};

#define BGE_IS_JUMBO_CAPABLE(sc)	((sc)->bge_flags & BGE_JUMBO_CAPABLE)
#define BGE_IS_5700_FAMILY(sc)		((sc)->bge_flags & BGE_5700_FAMILY)
#define BGE_IS_5705_PLUS(sc)		((sc)->bge_flags & BGE_5705_PLUS)
#define BGE_IS_5714_FAMILY(sc)		((sc)->bge_flags & BGE_5714_FAMILY)
#define BGE_IS_575X_PLUS(sc)		((sc)->bge_flags & BGE_575X_PLUS)
#define BGE_IS_5755_PLUS(sc)		((sc)->bge_flags & BGE_5755_PLUS)
#define BGE_IS_5717_PLUS(sc)		((sc)->bge_flags & BGE_5717_PLUS)
#define BGE_IS_57765_PLUS(sc)		((sc)->bge_flags & BGE_57765_PLUS)

static const struct bge_revision {
	u_int32_t		br_chipid;
	const char		*br_name;
} bge_revisions[] = {
	{ BGE_CHIPID_BCM5700_A0, "BCM5700 A0" },
	{ BGE_CHIPID_BCM5700_A1, "BCM5700 A1" },
	{ BGE_CHIPID_BCM5700_B0, "BCM5700 B0" },
	{ BGE_CHIPID_BCM5700_B1, "BCM5700 B1" },
	{ BGE_CHIPID_BCM5700_B2, "BCM5700 B2" },
	{ BGE_CHIPID_BCM5700_B3, "BCM5700 B3" },
	{ BGE_CHIPID_BCM5700_ALTIMA, "BCM5700 Altima" },
	{ BGE_CHIPID_BCM5700_C0, "BCM5700 C0" },
	{ BGE_CHIPID_BCM5701_A0, "BCM5701 A0" },
	{ BGE_CHIPID_BCM5701_B0, "BCM5701 B0" },
	{ BGE_CHIPID_BCM5701_B2, "BCM5701 B2" },
	{ BGE_CHIPID_BCM5701_B5, "BCM5701 B5" },
	/* the 5702 and 5703 share the same ASIC ID */
	{ BGE_CHIPID_BCM5703_A0, "BCM5702/5703 A0" },
	{ BGE_CHIPID_BCM5703_A1, "BCM5702/5703 A1" },
	{ BGE_CHIPID_BCM5703_A2, "BCM5702/5703 A2" },
	{ BGE_CHIPID_BCM5703_A3, "BCM5702/5703 A3" },
	{ BGE_CHIPID_BCM5703_B0, "BCM5702/5703 B0" },
	{ BGE_CHIPID_BCM5704_A0, "BCM5704 A0" },
	{ BGE_CHIPID_BCM5704_A1, "BCM5704 A1" },
	{ BGE_CHIPID_BCM5704_A2, "BCM5704 A2" },
	{ BGE_CHIPID_BCM5704_A3, "BCM5704 A3" },
	{ BGE_CHIPID_BCM5704_B0, "BCM5704 B0" },
	{ BGE_CHIPID_BCM5705_A0, "BCM5705 A0" },
	{ BGE_CHIPID_BCM5705_A1, "BCM5705 A1" },
	{ BGE_CHIPID_BCM5705_A2, "BCM5705 A2" },
	{ BGE_CHIPID_BCM5705_A3, "BCM5705 A3" },
	{ BGE_CHIPID_BCM5750_A0, "BCM5750 A0" },
	{ BGE_CHIPID_BCM5750_A1, "BCM5750 A1" },
	{ BGE_CHIPID_BCM5750_A3, "BCM5750 A3" },
	{ BGE_CHIPID_BCM5750_B0, "BCM5750 B0" },
	{ BGE_CHIPID_BCM5750_B1, "BCM5750 B1" },
	{ BGE_CHIPID_BCM5750_C0, "BCM5750 C0" },
	{ BGE_CHIPID_BCM5750_C1, "BCM5750 C1" },
	{ BGE_CHIPID_BCM5750_C2, "BCM5750 C2" },
	{ BGE_CHIPID_BCM5714_A0, "BCM5714 A0" },
	{ BGE_CHIPID_BCM5752_A0, "BCM5752 A0" },
	{ BGE_CHIPID_BCM5752_A1, "BCM5752 A1" },
	{ BGE_CHIPID_BCM5752_A2, "BCM5752 A2" },
	{ BGE_CHIPID_BCM5714_B0, "BCM5714 B0" },
	{ BGE_CHIPID_BCM5714_B3, "BCM5714 B3" },
	{ BGE_CHIPID_BCM5715_A0, "BCM5715 A0" },
	{ BGE_CHIPID_BCM5715_A1, "BCM5715 A1" },
	{ BGE_CHIPID_BCM5715_A3, "BCM5715 A3" },
	{ BGE_CHIPID_BCM5717_A0, "BCM5717 A0" },
	{ BGE_CHIPID_BCM5717_B0, "BCM5717 B0" },
	{ BGE_CHIPID_BCM5719_A0, "BCM5719 A0" },
	{ BGE_CHIPID_BCM5720_A0, "BCM5720 A0" },
	{ BGE_CHIPID_BCM5755_A0, "BCM5755 A0" },
	{ BGE_CHIPID_BCM5755_A1, "BCM5755 A1" },
	{ BGE_CHIPID_BCM5755_A2, "BCM5755 A2" },
	{ BGE_CHIPID_BCM5755_C0, "BCM5755 C0" },
	{ BGE_CHIPID_BCM5761_A0, "BCM5761 A0" },
	{ BGE_CHIPID_BCM5761_A1, "BCM5761 A1" },
	{ BGE_CHIPID_BCM5762_A0, "BCM5762 A0" },
	{ BGE_CHIPID_BCM5784_A0, "BCM5784 A0" },
	{ BGE_CHIPID_BCM5784_A1, "BCM5784 A1" },
	/* the 5754 and 5787 share the same ASIC ID */
	{ BGE_CHIPID_BCM5787_A0, "BCM5754/5787 A0" },
	{ BGE_CHIPID_BCM5787_A1, "BCM5754/5787 A1" },
	{ BGE_CHIPID_BCM5787_A2, "BCM5754/5787 A2" },
	{ BGE_CHIPID_BCM5906_A1, "BCM5906 A1" },
	{ BGE_CHIPID_BCM5906_A2, "BCM5906 A2" },
	{ BGE_CHIPID_BCM57765_A0, "BCM57765 A0" },
	{ BGE_CHIPID_BCM57765_B0, "BCM57765 B0" },
	{ BGE_CHIPID_BCM57780_A0, "BCM57780 A0" },
	{ BGE_CHIPID_BCM57780_A1, "BCM57780 A1" },

	{ 0, NULL }
};

/*
 * Some defaults for major revisions, so that newer steppings
 * that we don't know about have a shot at working.
 */
static const struct bge_revision bge_majorrevs[] = {
	{ BGE_ASICREV_BCM5700, "unknown BCM5700" },
	{ BGE_ASICREV_BCM5701, "unknown BCM5701" },
	/* 5702 and 5703 share the same ASIC ID */
	{ BGE_ASICREV_BCM5703, "unknown BCM5703" },
	{ BGE_ASICREV_BCM5704, "unknown BCM5704" },
	{ BGE_ASICREV_BCM5705, "unknown BCM5705" },
	{ BGE_ASICREV_BCM5750, "unknown BCM5750" },
	{ BGE_ASICREV_BCM5714, "unknown BCM5714" },
	{ BGE_ASICREV_BCM5714_A0, "unknown BCM5714" },
	{ BGE_ASICREV_BCM5752, "unknown BCM5752" },
	{ BGE_ASICREV_BCM5780, "unknown BCM5780" },
	{ BGE_ASICREV_BCM5755, "unknown BCM5755" },
	{ BGE_ASICREV_BCM5761, "unknown BCM5761" },
	{ BGE_ASICREV_BCM5784, "unknown BCM5784" },
	{ BGE_ASICREV_BCM5785, "unknown BCM5785" },
	/* 5754 and 5787 share the same ASIC ID */
	{ BGE_ASICREV_BCM5787, "unknown BCM5754/5787" },
	{ BGE_ASICREV_BCM5906, "unknown BCM5906" },
	{ BGE_ASICREV_BCM57765, "unknown BCM57765" },
	{ BGE_ASICREV_BCM57766, "unknown BCM57766" },
	{ BGE_ASICREV_BCM57780, "unknown BCM57780" },
	{ BGE_ASICREV_BCM5717, "unknown BCM5717" },
	{ BGE_ASICREV_BCM5719, "unknown BCM5719" },
	{ BGE_ASICREV_BCM5720, "unknown BCM5720" },
	{ BGE_ASICREV_BCM5762, "unknown BCM5762" },

	{ 0, NULL }
};

u_int32_t
bge_readmem_ind(struct bge_softc *sc, int off)
{
	struct pci_attach_args	*pa = &(sc->bge_pa);
	u_int32_t val;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906 &&
	    off >= BGE_STATS_BLOCK && off < BGE_SEND_RING_1_TO_4)
		return (0);

	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MEMWIN_BASEADDR, off);
	val = pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_MEMWIN_DATA);
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MEMWIN_BASEADDR, 0);
	return (val);
}

void
bge_writemem_ind(struct bge_softc *sc, int off, int val)
{
	struct pci_attach_args	*pa = &(sc->bge_pa);

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906 &&
	    off >= BGE_STATS_BLOCK && off < BGE_SEND_RING_1_TO_4)
		return;

	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MEMWIN_BASEADDR, off);
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MEMWIN_DATA, val);
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MEMWIN_BASEADDR, 0);
}

void
bge_writereg_ind(struct bge_softc *sc, int off, int val)
{
	struct pci_attach_args	*pa = &(sc->bge_pa);

	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_REG_BASEADDR, off);
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_REG_DATA, val);
}

void
bge_writembx(struct bge_softc *sc, int off, int val)
{
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906)
		off += BGE_LPMBX_IRQ0_HI - BGE_MBX_IRQ0_HI;

	CSR_WRITE_4(sc, off, val);
}

/*
 * Clear all stale locks and select the lock for this driver instance.
 */
void
bge_ape_lock_init(struct bge_softc *sc)
{
	struct pci_attach_args *pa = &(sc->bge_pa);
	uint32_t bit, regbase;
	int i;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761)
		regbase = BGE_APE_LOCK_GRANT;
	else
		regbase = BGE_APE_PER_LOCK_GRANT;

	/* Clear any stale locks. */
	for (i = BGE_APE_LOCK_PHY0; i <= BGE_APE_LOCK_GPIO; i++) {
		switch (i) {
		case BGE_APE_LOCK_PHY0:
		case BGE_APE_LOCK_PHY1:
		case BGE_APE_LOCK_PHY2:
		case BGE_APE_LOCK_PHY3:
			bit = BGE_APE_LOCK_GRANT_DRIVER0;
			break;
		default:
			if (pa->pa_function == 0)
				bit = BGE_APE_LOCK_GRANT_DRIVER0;
			else
				bit = (1 << pa->pa_function);
		}
		APE_WRITE_4(sc, regbase + 4 * i, bit);
	}

	/* Select the PHY lock based on the device's function number. */
	switch (pa->pa_function) {
	case 0:
		sc->bge_phy_ape_lock = BGE_APE_LOCK_PHY0;
		break;
	case 1:
		sc->bge_phy_ape_lock = BGE_APE_LOCK_PHY1;
		break;
	case 2:
		sc->bge_phy_ape_lock = BGE_APE_LOCK_PHY2;
		break;
	case 3:
		sc->bge_phy_ape_lock = BGE_APE_LOCK_PHY3;
		break;
	default:
		printf("%s: PHY lock not supported on function %d\n",
		    sc->bge_dev.dv_xname, pa->pa_function);
		break;
	}
}

/*
 * Check for APE firmware, set flags, and print version info.
 */
void
bge_ape_read_fw_ver(struct bge_softc *sc)
{
	const char *fwtype;
	uint32_t apedata, features;

	/* Check for a valid APE signature in shared memory. */
	apedata = APE_READ_4(sc, BGE_APE_SEG_SIG);
	if (apedata != BGE_APE_SEG_SIG_MAGIC) {
		sc->bge_mfw_flags &= ~ BGE_MFW_ON_APE;
		return;
	}

	/* Check if APE firmware is running. */
	apedata = APE_READ_4(sc, BGE_APE_FW_STATUS);
	if ((apedata & BGE_APE_FW_STATUS_READY) == 0) {
		printf("%s: APE signature found but FW status not ready! "
		    "0x%08x\n", sc->bge_dev.dv_xname, apedata);
		return;
	}

	sc->bge_mfw_flags |= BGE_MFW_ON_APE;

	/* Fetch the APE firwmare type and version. */
	apedata = APE_READ_4(sc, BGE_APE_FW_VERSION);
	features = APE_READ_4(sc, BGE_APE_FW_FEATURES);
	if ((features & BGE_APE_FW_FEATURE_NCSI) != 0) {
		sc->bge_mfw_flags |= BGE_MFW_TYPE_NCSI;
		fwtype = "NCSI";
	} else if ((features & BGE_APE_FW_FEATURE_DASH) != 0) {
		sc->bge_mfw_flags |= BGE_MFW_TYPE_DASH;
		fwtype = "DASH";
	} else
		fwtype = "UNKN";

	/* Print the APE firmware version. */
	printf(", APE firmware %s %d.%d.%d.%d", fwtype,
	    (apedata & BGE_APE_FW_VERSION_MAJMSK) >> BGE_APE_FW_VERSION_MAJSFT,
	    (apedata & BGE_APE_FW_VERSION_MINMSK) >> BGE_APE_FW_VERSION_MINSFT,
	    (apedata & BGE_APE_FW_VERSION_REVMSK) >> BGE_APE_FW_VERSION_REVSFT,
	    (apedata & BGE_APE_FW_VERSION_BLDMSK));
}

int
bge_ape_lock(struct bge_softc *sc, int locknum)
{
	struct pci_attach_args *pa = &(sc->bge_pa);
	uint32_t bit, gnt, req, status;
	int i, off;

	if ((sc->bge_mfw_flags & BGE_MFW_ON_APE) == 0)
		return (0);

	/* Lock request/grant registers have different bases. */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761) {
		req = BGE_APE_LOCK_REQ;
		gnt = BGE_APE_LOCK_GRANT;
	} else {
		req = BGE_APE_PER_LOCK_REQ;
		gnt = BGE_APE_PER_LOCK_GRANT;
	}

	off = 4 * locknum;

	switch (locknum) {
	case BGE_APE_LOCK_GPIO:
		/* Lock required when using GPIO. */
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761)
			return (0);
		if (pa->pa_function == 0)
			bit = BGE_APE_LOCK_REQ_DRIVER0;
		else
			bit = (1 << pa->pa_function);
		break;
	case BGE_APE_LOCK_GRC:
		/* Lock required to reset the device. */
		if (pa->pa_function == 0)
			bit = BGE_APE_LOCK_REQ_DRIVER0;
		else
			bit = (1 << pa->pa_function);
		break;
	case BGE_APE_LOCK_MEM:
		/* Lock required when accessing certain APE memory. */
		if (pa->pa_function == 0)
			bit = BGE_APE_LOCK_REQ_DRIVER0;
		else
			bit = (1 << pa->pa_function);
		break;
	case BGE_APE_LOCK_PHY0:
	case BGE_APE_LOCK_PHY1:
	case BGE_APE_LOCK_PHY2:
	case BGE_APE_LOCK_PHY3:
		/* Lock required when accessing PHYs. */
		bit = BGE_APE_LOCK_REQ_DRIVER0;
		break;
	default:
		return (EINVAL);
	}

	/* Request a lock. */
	APE_WRITE_4(sc, req + off, bit);

	/* Wait up to 1 second to acquire lock. */
	for (i = 0; i < 20000; i++) {
		status = APE_READ_4(sc, gnt + off);
		if (status == bit)
			break;
		DELAY(50);
	}

	/* Handle any errors. */
	if (status != bit) {
		printf("%s: APE lock %d request failed! "
		    "request = 0x%04x[0x%04x], status = 0x%04x[0x%04x]\n",
		    sc->bge_dev.dv_xname,
		    locknum, req + off, bit & 0xFFFF, gnt + off,
		    status & 0xFFFF);
		/* Revoke the lock request. */
		APE_WRITE_4(sc, gnt + off, bit);
		return (EBUSY);
	}

	return (0);
}

void
bge_ape_unlock(struct bge_softc *sc, int locknum)
{
	struct pci_attach_args *pa = &(sc->bge_pa);
	uint32_t bit, gnt;
	int off;

	if ((sc->bge_mfw_flags & BGE_MFW_ON_APE) == 0)
		return;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761)
		gnt = BGE_APE_LOCK_GRANT;
	else
		gnt = BGE_APE_PER_LOCK_GRANT;

	off = 4 * locknum;

	switch (locknum) {
	case BGE_APE_LOCK_GPIO:
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761)
			return;
		if (pa->pa_function == 0)
			bit = BGE_APE_LOCK_GRANT_DRIVER0;
		else
			bit = (1 << pa->pa_function);
		break;
	case BGE_APE_LOCK_GRC:
		if (pa->pa_function == 0)
			bit = BGE_APE_LOCK_GRANT_DRIVER0;
		else
			bit = (1 << pa->pa_function);
		break;
	case BGE_APE_LOCK_MEM:
		if (pa->pa_function == 0)
			bit = BGE_APE_LOCK_GRANT_DRIVER0;
		else
			bit = (1 << pa->pa_function);
		break;
	case BGE_APE_LOCK_PHY0:
	case BGE_APE_LOCK_PHY1:
	case BGE_APE_LOCK_PHY2:
	case BGE_APE_LOCK_PHY3:
		bit = BGE_APE_LOCK_GRANT_DRIVER0;
		break;
	default:
		return;
	}

	APE_WRITE_4(sc, gnt + off, bit);
}

/*
 * Send an event to the APE firmware.
 */
void
bge_ape_send_event(struct bge_softc *sc, uint32_t event)
{
	uint32_t apedata;
	int i;

	/* NCSI does not support APE events. */
	if ((sc->bge_mfw_flags & BGE_MFW_ON_APE) == 0)
		return;

	/* Wait up to 1ms for APE to service previous event. */
	for (i = 10; i > 0; i--) {
		if (bge_ape_lock(sc, BGE_APE_LOCK_MEM) != 0)
			break;
		apedata = APE_READ_4(sc, BGE_APE_EVENT_STATUS);
		if ((apedata & BGE_APE_EVENT_STATUS_EVENT_PENDING) == 0) {
			APE_WRITE_4(sc, BGE_APE_EVENT_STATUS, event |
			    BGE_APE_EVENT_STATUS_EVENT_PENDING);
			bge_ape_unlock(sc, BGE_APE_LOCK_MEM);
			APE_WRITE_4(sc, BGE_APE_EVENT, BGE_APE_EVENT_1);
			break;
		}
		bge_ape_unlock(sc, BGE_APE_LOCK_MEM);
		DELAY(100);
	}
	if (i == 0) {
		printf("%s: APE event 0x%08x send timed out\n",
		    sc->bge_dev.dv_xname, event);
	}
}

void
bge_ape_driver_state_change(struct bge_softc *sc, int kind)
{
	uint32_t apedata, event;

	if ((sc->bge_mfw_flags & BGE_MFW_ON_APE) == 0)
		return;

	switch (kind) {
	case BGE_RESET_START:
		/* If this is the first load, clear the load counter. */
		apedata = APE_READ_4(sc, BGE_APE_HOST_SEG_SIG);
		if (apedata != BGE_APE_HOST_SEG_SIG_MAGIC)
			APE_WRITE_4(sc, BGE_APE_HOST_INIT_COUNT, 0);
		else {
			apedata = APE_READ_4(sc, BGE_APE_HOST_INIT_COUNT);
			APE_WRITE_4(sc, BGE_APE_HOST_INIT_COUNT, ++apedata);
		}
		APE_WRITE_4(sc, BGE_APE_HOST_SEG_SIG,
		    BGE_APE_HOST_SEG_SIG_MAGIC);
		APE_WRITE_4(sc, BGE_APE_HOST_SEG_LEN,
		    BGE_APE_HOST_SEG_LEN_MAGIC);

		/* Add some version info if bge(4) supports it. */
		APE_WRITE_4(sc, BGE_APE_HOST_DRIVER_ID,
		    BGE_APE_HOST_DRIVER_ID_MAGIC(1, 0));
		APE_WRITE_4(sc, BGE_APE_HOST_BEHAVIOR,
		    BGE_APE_HOST_BEHAV_NO_PHYLOCK);
		APE_WRITE_4(sc, BGE_APE_HOST_HEARTBEAT_INT_MS,
		    BGE_APE_HOST_HEARTBEAT_INT_DISABLE);
		APE_WRITE_4(sc, BGE_APE_HOST_DRVR_STATE,
		    BGE_APE_HOST_DRVR_STATE_START);
		event = BGE_APE_EVENT_STATUS_STATE_START;
		break;
	case BGE_RESET_SHUTDOWN:
		APE_WRITE_4(sc, BGE_APE_HOST_DRVR_STATE,
		    BGE_APE_HOST_DRVR_STATE_UNLOAD);
		event = BGE_APE_EVENT_STATUS_STATE_UNLOAD;
		break;
	case BGE_RESET_SUSPEND:
		event = BGE_APE_EVENT_STATUS_STATE_SUSPEND;
		break;
	default:
		return;
	}

	bge_ape_send_event(sc, event | BGE_APE_EVENT_STATUS_DRIVER_EVNT |
	    BGE_APE_EVENT_STATUS_STATE_CHNGE);
}


u_int8_t
bge_nvram_getbyte(struct bge_softc *sc, int addr, u_int8_t *dest)
{
	u_int32_t access, byte = 0;
	int i;

	/* Lock. */
	CSR_WRITE_4(sc, BGE_NVRAM_SWARB, BGE_NVRAMSWARB_SET1);
	for (i = 0; i < 8000; i++) {
		if (CSR_READ_4(sc, BGE_NVRAM_SWARB) & BGE_NVRAMSWARB_GNT1)
			break;
		DELAY(20);
	}
	if (i == 8000)
		return (1);

	/* Enable access. */
	access = CSR_READ_4(sc, BGE_NVRAM_ACCESS);
	CSR_WRITE_4(sc, BGE_NVRAM_ACCESS, access | BGE_NVRAMACC_ENABLE);

	CSR_WRITE_4(sc, BGE_NVRAM_ADDR, addr & 0xfffffffc);
	CSR_WRITE_4(sc, BGE_NVRAM_CMD, BGE_NVRAM_READCMD);
	for (i = 0; i < BGE_TIMEOUT * 10; i++) {
		DELAY(10);
		if (CSR_READ_4(sc, BGE_NVRAM_CMD) & BGE_NVRAMCMD_DONE) {
			DELAY(10);
			break;
		}
	}

	if (i == BGE_TIMEOUT * 10) {
		printf("%s: nvram read timed out\n", sc->bge_dev.dv_xname);
		return (1);
	}

	/* Get result. */
	byte = CSR_READ_4(sc, BGE_NVRAM_RDDATA);

	*dest = (swap32(byte) >> ((addr % 4) * 8)) & 0xFF;

	/* Disable access. */
	CSR_WRITE_4(sc, BGE_NVRAM_ACCESS, access);

	/* Unlock. */
	CSR_WRITE_4(sc, BGE_NVRAM_SWARB, BGE_NVRAMSWARB_CLR1);
	CSR_READ_4(sc, BGE_NVRAM_SWARB);

	return (0);
}

/*
 * Read a sequence of bytes from NVRAM.
 */

int
bge_read_nvram(struct bge_softc *sc, caddr_t dest, int off, int cnt)
{
	int err = 0, i;
	u_int8_t byte = 0;

	if (BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5906)
		return (1);

	for (i = 0; i < cnt; i++) {
		err = bge_nvram_getbyte(sc, off + i, &byte);
		if (err)
			break;
		*(dest + i) = byte;
	}

	return (err ? 1 : 0);
}

/*
 * Read a byte of data stored in the EEPROM at address 'addr.' The
 * BCM570x supports both the traditional bitbang interface and an
 * auto access interface for reading the EEPROM. We use the auto
 * access method.
 */
u_int8_t
bge_eeprom_getbyte(struct bge_softc *sc, int addr, u_int8_t *dest)
{
	int i;
	u_int32_t byte = 0;

	/*
	 * Enable use of auto EEPROM access so we can avoid
	 * having to use the bitbang method.
	 */
	BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_AUTO_EEPROM);

	/* Reset the EEPROM, load the clock period. */
	CSR_WRITE_4(sc, BGE_EE_ADDR,
	    BGE_EEADDR_RESET|BGE_EEHALFCLK(BGE_HALFCLK_384SCL));
	DELAY(20);

	/* Issue the read EEPROM command. */
	CSR_WRITE_4(sc, BGE_EE_ADDR, BGE_EE_READCMD | addr);

	/* Wait for completion */
	for(i = 0; i < BGE_TIMEOUT * 10; i++) {
		DELAY(10);
		if (CSR_READ_4(sc, BGE_EE_ADDR) & BGE_EEADDR_DONE)
			break;
	}

	if (i == BGE_TIMEOUT * 10) {
		printf("%s: eeprom read timed out\n", sc->bge_dev.dv_xname);
		return (1);
	}

	/* Get result. */
	byte = CSR_READ_4(sc, BGE_EE_DATA);

	*dest = (byte >> ((addr % 4) * 8)) & 0xFF;

	return (0);
}

/*
 * Read a sequence of bytes from the EEPROM.
 */
int
bge_read_eeprom(struct bge_softc *sc, caddr_t dest, int off, int cnt)
{
	int i, error = 0;
	u_int8_t byte = 0;

	for (i = 0; i < cnt; i++) {
		error = bge_eeprom_getbyte(sc, off + i, &byte);
		if (error)
			break;
		*(dest + i) = byte;
	}

	return (error ? 1 : 0);
}

int
bge_miibus_readreg(struct device *dev, int phy, int reg)
{
	struct bge_softc *sc = (struct bge_softc *)dev;
	u_int32_t val, autopoll;
	int i;

	if (bge_ape_lock(sc, sc->bge_phy_ape_lock) != 0)
		return (0);

	/* Reading with autopolling on may trigger PCI errors */
	autopoll = CSR_READ_4(sc, BGE_MI_MODE);
	if (autopoll & BGE_MIMODE_AUTOPOLL) {
		BGE_STS_CLRBIT(sc, BGE_STS_AUTOPOLL);
		BGE_CLRBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
		DELAY(80);
	}

	CSR_WRITE_4(sc, BGE_MI_COMM, BGE_MICMD_READ|BGE_MICOMM_BUSY|
	    BGE_MIPHY(phy)|BGE_MIREG(reg));
	CSR_READ_4(sc, BGE_MI_COMM); /* force write */

	for (i = 0; i < 200; i++) {
		delay(1);
		val = CSR_READ_4(sc, BGE_MI_COMM);
		if (!(val & BGE_MICOMM_BUSY))
			break;
		delay(10);
	}

	if (i == 200) {
		printf("%s: PHY read timed out\n", sc->bge_dev.dv_xname);
		val = 0;
		goto done;
	}

	val = CSR_READ_4(sc, BGE_MI_COMM);

done:
	if (autopoll & BGE_MIMODE_AUTOPOLL) {
		BGE_STS_SETBIT(sc, BGE_STS_AUTOPOLL);
		BGE_SETBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
		DELAY(80);
	}

	bge_ape_unlock(sc, sc->bge_phy_ape_lock);

	if (val & BGE_MICOMM_READFAIL)
		return (0);

	return (val & 0xFFFF);
}

void
bge_miibus_writereg(struct device *dev, int phy, int reg, int val)
{
	struct bge_softc *sc = (struct bge_softc *)dev;
	u_int32_t autopoll;
	int i;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906 &&
	    (reg == MII_100T2CR || reg == BRGPHY_MII_AUXCTL))
		return;

	if (bge_ape_lock(sc, sc->bge_phy_ape_lock) != 0)
		return;

	/* Reading with autopolling on may trigger PCI errors */
	autopoll = CSR_READ_4(sc, BGE_MI_MODE);
	if (autopoll & BGE_MIMODE_AUTOPOLL) {
		DELAY(40);
		BGE_STS_CLRBIT(sc, BGE_STS_AUTOPOLL);
		BGE_CLRBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
		DELAY(40); /* 40 usec is supposed to be adequate */
	}

	CSR_WRITE_4(sc, BGE_MI_COMM, BGE_MICMD_WRITE|BGE_MICOMM_BUSY|
	    BGE_MIPHY(phy)|BGE_MIREG(reg)|val);
	CSR_READ_4(sc, BGE_MI_COMM); /* force write */

	for (i = 0; i < 200; i++) {
		delay(1);
		if (!(CSR_READ_4(sc, BGE_MI_COMM) & BGE_MICOMM_BUSY))
			break;
		delay(10);
	}

	if (autopoll & BGE_MIMODE_AUTOPOLL) {
		BGE_STS_SETBIT(sc, BGE_STS_AUTOPOLL);
		BGE_SETBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
		DELAY(40);
	}

	bge_ape_unlock(sc, sc->bge_phy_ape_lock);

	if (i == 200) {
		printf("%s: PHY read timed out\n", sc->bge_dev.dv_xname);
	}
}

void
bge_miibus_statchg(struct device *dev)
{
	struct bge_softc *sc = (struct bge_softc *)dev;
	struct mii_data *mii = &sc->bge_mii;
	u_int32_t mac_mode, rx_mode, tx_mode;

	/*
	 * Get flow control negotiation result.
	 */
	if (IFM_SUBTYPE(mii->mii_media.ifm_cur->ifm_media) == IFM_AUTO &&
	    (mii->mii_media_active & IFM_ETH_FMASK) != sc->bge_flowflags)
		sc->bge_flowflags = mii->mii_media_active & IFM_ETH_FMASK;

	if (!BGE_STS_BIT(sc, BGE_STS_LINK) &&
	    mii->mii_media_status & IFM_ACTIVE &&
	    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE)
		BGE_STS_SETBIT(sc, BGE_STS_LINK);
	else if (BGE_STS_BIT(sc, BGE_STS_LINK) &&
	    (!(mii->mii_media_status & IFM_ACTIVE) ||
	    IFM_SUBTYPE(mii->mii_media_active) == IFM_NONE))
		BGE_STS_CLRBIT(sc, BGE_STS_LINK);

	if (!BGE_STS_BIT(sc, BGE_STS_LINK))
		return;

	/* Set the port mode (MII/GMII) to match the link speed. */
	mac_mode = CSR_READ_4(sc, BGE_MAC_MODE) &
	    ~(BGE_MACMODE_PORTMODE | BGE_MACMODE_HALF_DUPLEX);
	tx_mode = CSR_READ_4(sc, BGE_TX_MODE);
	rx_mode = CSR_READ_4(sc, BGE_RX_MODE);

	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T ||
	    IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_SX)
		mac_mode |= BGE_PORTMODE_GMII;
	else
		mac_mode |= BGE_PORTMODE_MII;

	/* Set MAC flow control behavior to match link flow control settings. */
	tx_mode &= ~BGE_TXMODE_FLOWCTL_ENABLE;
	rx_mode &= ~BGE_RXMODE_FLOWCTL_ENABLE;
	if (mii->mii_media_active & IFM_FDX) {
		if (sc->bge_flowflags & IFM_ETH_TXPAUSE)
			tx_mode |= BGE_TXMODE_FLOWCTL_ENABLE;
		if (sc->bge_flowflags & IFM_ETH_RXPAUSE)
			rx_mode |= BGE_RXMODE_FLOWCTL_ENABLE;
	} else
		mac_mode |= BGE_MACMODE_HALF_DUPLEX;

	CSR_WRITE_4(sc, BGE_MAC_MODE, mac_mode);
	DELAY(40);
	CSR_WRITE_4(sc, BGE_TX_MODE, tx_mode);
	CSR_WRITE_4(sc, BGE_RX_MODE, rx_mode);
}

/*
 * Intialize a standard receive ring descriptor.
 */
int
bge_newbuf(struct bge_softc *sc, int i)
{
	bus_dmamap_t		dmap = sc->bge_cdata.bge_rx_std_map[i];
	struct bge_rx_bd	*r = &sc->bge_rdata->bge_rx_std_ring[i];
	struct mbuf		*m;
	int			error;

	m = MCLGETI(NULL, M_DONTWAIT, NULL, sc->bge_rx_std_len);
	if (!m)
		return (ENOBUFS);
	m->m_len = m->m_pkthdr.len = sc->bge_rx_std_len;
	if (!(sc->bge_flags & BGE_RX_ALIGNBUG))
	    m_adj(m, ETHER_ALIGN);

	error = bus_dmamap_load_mbuf(sc->bge_dmatag, dmap, m,
	    BUS_DMA_READ|BUS_DMA_NOWAIT);
	if (error) {
		m_freem(m);
		return (ENOBUFS);
	}

	bus_dmamap_sync(sc->bge_dmatag, dmap, 0, dmap->dm_mapsize,
	    BUS_DMASYNC_PREREAD);
	sc->bge_cdata.bge_rx_std_chain[i] = m;

	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_rx_std_ring) +
		i * sizeof (struct bge_rx_bd),
	    sizeof (struct bge_rx_bd),
	    BUS_DMASYNC_POSTWRITE);

	BGE_HOSTADDR(r->bge_addr, dmap->dm_segs[0].ds_addr);
	r->bge_flags = BGE_RXBDFLAG_END;
	r->bge_len = m->m_len;
	r->bge_idx = i;

	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_rx_std_ring) +
		i * sizeof (struct bge_rx_bd),
	    sizeof (struct bge_rx_bd),
	    BUS_DMASYNC_PREWRITE);

	return (0);
}

/*
 * Initialize a Jumbo receive ring descriptor.
 */
int
bge_newbuf_jumbo(struct bge_softc *sc, int i)
{
	bus_dmamap_t		dmap = sc->bge_cdata.bge_rx_jumbo_map[i];
	struct bge_ext_rx_bd	*r = &sc->bge_rdata->bge_rx_jumbo_ring[i];
	struct mbuf		*m;
	int			error;

	m = MCLGETI(NULL, M_DONTWAIT, NULL, BGE_JLEN);
	if (!m)
		return (ENOBUFS);
	m->m_len = m->m_pkthdr.len = BGE_JUMBO_FRAMELEN;
	if (!(sc->bge_flags & BGE_RX_ALIGNBUG))
	    m_adj(m, ETHER_ALIGN);

	error = bus_dmamap_load_mbuf(sc->bge_dmatag, dmap, m,
	    BUS_DMA_READ|BUS_DMA_NOWAIT);
	if (error) {
		m_freem(m);
		return (ENOBUFS);
	}

	bus_dmamap_sync(sc->bge_dmatag, dmap, 0, dmap->dm_mapsize,
	    BUS_DMASYNC_PREREAD);
	sc->bge_cdata.bge_rx_jumbo_chain[i] = m;

	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_rx_jumbo_ring) +
		i * sizeof (struct bge_ext_rx_bd),
	    sizeof (struct bge_ext_rx_bd),
	    BUS_DMASYNC_POSTWRITE);

	/*
	 * Fill in the extended RX buffer descriptor.
	 */
	r->bge_bd.bge_flags = BGE_RXBDFLAG_JUMBO_RING | BGE_RXBDFLAG_END;
	r->bge_bd.bge_idx = i;
	r->bge_len3 = r->bge_len2 = r->bge_len1 = 0;
	switch (dmap->dm_nsegs) {
	case 4:
		BGE_HOSTADDR(r->bge_addr3, dmap->dm_segs[3].ds_addr);
		r->bge_len3 = dmap->dm_segs[3].ds_len;
		/* FALLTHROUGH */
	case 3:
		BGE_HOSTADDR(r->bge_addr2, dmap->dm_segs[2].ds_addr);
		r->bge_len2 = dmap->dm_segs[2].ds_len;
		/* FALLTHROUGH */
	case 2:
		BGE_HOSTADDR(r->bge_addr1, dmap->dm_segs[1].ds_addr);
		r->bge_len1 = dmap->dm_segs[1].ds_len;
		/* FALLTHROUGH */
	case 1:
		BGE_HOSTADDR(r->bge_bd.bge_addr, dmap->dm_segs[0].ds_addr);
		r->bge_bd.bge_len = dmap->dm_segs[0].ds_len;
		break;
	default:
		panic("%s: %d segments", __func__, dmap->dm_nsegs);
	}

	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_rx_jumbo_ring) +
		i * sizeof (struct bge_ext_rx_bd),
	    sizeof (struct bge_ext_rx_bd),
	    BUS_DMASYNC_PREWRITE);

	return (0);
}

int
bge_init_rx_ring_std(struct bge_softc *sc)
{
	int i;

	if (ISSET(sc->bge_flags, BGE_RXRING_VALID))
		return (0);

	for (i = 0; i < BGE_STD_RX_RING_CNT; i++) {
		if (bus_dmamap_create(sc->bge_dmatag, sc->bge_rx_std_len, 1,
		    sc->bge_rx_std_len, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
		    &sc->bge_cdata.bge_rx_std_map[i]) != 0) {
			printf("%s: unable to create dmamap for slot %d\n",
			    sc->bge_dev.dv_xname, i);
			goto uncreate;
		}
		bzero(&sc->bge_rdata->bge_rx_std_ring[i],
		    sizeof(struct bge_rx_bd));
	}

	sc->bge_std = BGE_STD_RX_RING_CNT - 1;

	/* lwm must be greater than the replenish threshold */
	if_rxr_init(&sc->bge_std_ring, 17, BGE_STD_RX_RING_CNT);
	bge_fill_rx_ring_std(sc);

	SET(sc->bge_flags, BGE_RXRING_VALID);

	return (0);

uncreate:
	while (--i) {
		bus_dmamap_destroy(sc->bge_dmatag,
		    sc->bge_cdata.bge_rx_std_map[i]);
	}
	return (1);
}

/*
 * When the refill timeout for a ring is active, that ring is so empty
 * that no more packets can be received on it, so the interrupt handler
 * will not attempt to refill it, meaning we don't need to protect against
 * interrupts here.
 */

void
bge_rxtick(void *arg)
{
	struct bge_softc *sc = arg;

	if (ISSET(sc->bge_flags, BGE_RXRING_VALID) &&
	    if_rxr_inuse(&sc->bge_std_ring) <= 8)
		bge_fill_rx_ring_std(sc);
}

void
bge_rxtick_jumbo(void *arg)
{
	struct bge_softc *sc = arg;

	if (ISSET(sc->bge_flags, BGE_JUMBO_RXRING_VALID) &&
	    if_rxr_inuse(&sc->bge_jumbo_ring) <= 8)
		bge_fill_rx_ring_jumbo(sc);
}

void
bge_fill_rx_ring_std(struct bge_softc *sc)
{
	int i;
	int post = 0;
	u_int slots;

	i = sc->bge_std;
	for (slots = if_rxr_get(&sc->bge_std_ring, BGE_STD_RX_RING_CNT);
	    slots > 0; slots--) {
		BGE_INC(i, BGE_STD_RX_RING_CNT);

		if (bge_newbuf(sc, i) != 0)
			break;

		sc->bge_std = i;
		post = 1;
	}
	if_rxr_put(&sc->bge_std_ring, slots);

	if (post)
		bge_writembx(sc, BGE_MBX_RX_STD_PROD_LO, sc->bge_std);

	/*
	 * bge always needs more than 8 packets on the ring. if we cant do
	 * that now, then try again later.
	 */
	if (if_rxr_inuse(&sc->bge_std_ring) <= 8)
		timeout_add(&sc->bge_rxtimeout, 1);
}

void
bge_free_rx_ring_std(struct bge_softc *sc)
{
	bus_dmamap_t dmap;
	struct mbuf *m;
	int i;

	if (!ISSET(sc->bge_flags, BGE_RXRING_VALID))
		return;

	for (i = 0; i < BGE_STD_RX_RING_CNT; i++) {
		dmap = sc->bge_cdata.bge_rx_std_map[i];
		m = sc->bge_cdata.bge_rx_std_chain[i];
		if (m != NULL) {
			bus_dmamap_sync(sc->bge_dmatag, dmap, 0,
			    dmap->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->bge_dmatag, dmap);
			m_freem(m);
			sc->bge_cdata.bge_rx_std_chain[i] = NULL;
		}
		bus_dmamap_destroy(sc->bge_dmatag, dmap);
		sc->bge_cdata.bge_rx_std_map[i] = NULL;
		bzero(&sc->bge_rdata->bge_rx_std_ring[i],
		    sizeof(struct bge_rx_bd));
	}

	CLR(sc->bge_flags, BGE_RXRING_VALID);
}

int
bge_init_rx_ring_jumbo(struct bge_softc *sc)
{
	volatile struct bge_rcb *rcb;
	int i;

	if (ISSET(sc->bge_flags, BGE_JUMBO_RXRING_VALID))
		return (0);

	for (i = 0; i < BGE_JUMBO_RX_RING_CNT; i++) {
		if (bus_dmamap_create(sc->bge_dmatag, BGE_JLEN, 4, BGE_JLEN, 0,
		    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
		    &sc->bge_cdata.bge_rx_jumbo_map[i]) != 0) {
			printf("%s: unable to create dmamap for slot %d\n",
			    sc->bge_dev.dv_xname, i);
			goto uncreate;
		}
		bzero(&sc->bge_rdata->bge_rx_jumbo_ring[i],
		    sizeof(struct bge_ext_rx_bd));
	}

	sc->bge_jumbo = BGE_JUMBO_RX_RING_CNT - 1;

	/* lwm must be greater than the replenish threshold */
	if_rxr_init(&sc->bge_jumbo_ring, 17, BGE_JUMBO_RX_RING_CNT);
	bge_fill_rx_ring_jumbo(sc);

	SET(sc->bge_flags, BGE_JUMBO_RXRING_VALID);

	rcb = &sc->bge_rdata->bge_info.bge_jumbo_rx_rcb;
	rcb->bge_maxlen_flags =
	    BGE_RCB_MAXLEN_FLAGS(0, BGE_RCB_FLAG_USE_EXT_RX_BD);
	CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_MAXLEN_FLAGS, rcb->bge_maxlen_flags);

	return (0);

uncreate:
	while (--i) {
		bus_dmamap_destroy(sc->bge_dmatag,
		    sc->bge_cdata.bge_rx_jumbo_map[i]);
	}
	return (1);
}

void
bge_fill_rx_ring_jumbo(struct bge_softc *sc)
{
	int i;
	int post = 0;
	u_int slots;

	i = sc->bge_jumbo;
	for (slots = if_rxr_get(&sc->bge_jumbo_ring, BGE_JUMBO_RX_RING_CNT);
	    slots > 0; slots--) {
		BGE_INC(i, BGE_JUMBO_RX_RING_CNT);

		if (bge_newbuf_jumbo(sc, i) != 0)
			break;

		sc->bge_jumbo = i;
		post = 1;
	}
	if_rxr_put(&sc->bge_jumbo_ring, slots);

	if (post)
		bge_writembx(sc, BGE_MBX_RX_JUMBO_PROD_LO, sc->bge_jumbo);

	/*
	 * bge always needs more than 8 packets on the ring. if we cant do
	 * that now, then try again later.
	 */
	if (if_rxr_inuse(&sc->bge_jumbo_ring) <= 8)
		timeout_add(&sc->bge_rxtimeout_jumbo, 1);
}

void
bge_free_rx_ring_jumbo(struct bge_softc *sc)
{
	bus_dmamap_t dmap;
	struct mbuf *m;
	int i;

	if (!ISSET(sc->bge_flags, BGE_JUMBO_RXRING_VALID))
		return;

	for (i = 0; i < BGE_JUMBO_RX_RING_CNT; i++) {
		dmap = sc->bge_cdata.bge_rx_jumbo_map[i];
		m = sc->bge_cdata.bge_rx_jumbo_chain[i];
		if (m != NULL) {
			bus_dmamap_sync(sc->bge_dmatag, dmap, 0,
			    dmap->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->bge_dmatag, dmap);
			m_freem(m);
			sc->bge_cdata.bge_rx_jumbo_chain[i] = NULL;
		}
		bus_dmamap_destroy(sc->bge_dmatag, dmap);
		sc->bge_cdata.bge_rx_jumbo_map[i] = NULL;
		bzero(&sc->bge_rdata->bge_rx_jumbo_ring[i],
		    sizeof(struct bge_ext_rx_bd));
	}

	CLR(sc->bge_flags, BGE_JUMBO_RXRING_VALID);
}

void
bge_free_tx_ring(struct bge_softc *sc)
{
	int i;

	if (!(sc->bge_flags & BGE_TXRING_VALID))
		return;

	for (i = 0; i < BGE_TX_RING_CNT; i++) {
		if (sc->bge_cdata.bge_tx_chain[i] != NULL) {
			m_freem(sc->bge_cdata.bge_tx_chain[i]);
			sc->bge_cdata.bge_tx_chain[i] = NULL;
			sc->bge_cdata.bge_tx_map[i] = NULL;
		}
		bzero(&sc->bge_rdata->bge_tx_ring[i],
		    sizeof(struct bge_tx_bd));

		bus_dmamap_destroy(sc->bge_dmatag, sc->bge_txdma[i]);
	}

	sc->bge_flags &= ~BGE_TXRING_VALID;
}

int
bge_init_tx_ring(struct bge_softc *sc)
{
	int i;
	bus_size_t txsegsz, txmaxsegsz;

	if (sc->bge_flags & BGE_TXRING_VALID)
		return (0);

	sc->bge_txcnt = 0;
	sc->bge_tx_saved_considx = 0;

	/* Initialize transmit producer index for host-memory send ring. */
	sc->bge_tx_prodidx = 0;
	bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, sc->bge_tx_prodidx);
	if (BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5700_BX)
		bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, sc->bge_tx_prodidx);

	/* NIC-memory send ring not used; initialize to zero. */
	bge_writembx(sc, BGE_MBX_TX_NIC_PROD0_LO, 0);
	if (BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5700_BX)
		bge_writembx(sc, BGE_MBX_TX_NIC_PROD0_LO, 0);

	if (BGE_IS_JUMBO_CAPABLE(sc)) {
		txsegsz = 4096;
		txmaxsegsz = BGE_JLEN;
	} else {
		txsegsz = MCLBYTES;
		txmaxsegsz = MCLBYTES;
	}

	for (i = 0; i < BGE_TX_RING_CNT; i++) {
		if (bus_dmamap_create(sc->bge_dmatag, txmaxsegsz,
		    BGE_NTXSEG, txsegsz, 0, BUS_DMA_NOWAIT, &sc->bge_txdma[i]))
			return (ENOBUFS);
	}

	sc->bge_flags |= BGE_TXRING_VALID;

	return (0);
}

void
bge_iff(struct bge_softc *sc)
{
	struct arpcom		*ac = &sc->arpcom;
	struct ifnet		*ifp = &ac->ac_if;
	struct ether_multi	*enm;
	struct ether_multistep  step;
	u_int8_t		hashes[16];
	u_int32_t		h, rxmode;

	/* First, zot all the existing filters. */
	rxmode = CSR_READ_4(sc, BGE_RX_MODE) & ~BGE_RXMODE_RX_PROMISC;
	ifp->if_flags &= ~IFF_ALLMULTI;
	memset(hashes, 0x00, sizeof(hashes));

	if (ifp->if_flags & IFF_PROMISC) {
		ifp->if_flags |= IFF_ALLMULTI;
		rxmode |= BGE_RXMODE_RX_PROMISC;
	} else if (ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		memset(hashes, 0xff, sizeof(hashes));
	} else {
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN);

			setbit(hashes, h & 0x7F);

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	bus_space_write_raw_region_4(sc->bge_btag, sc->bge_bhandle, BGE_MAR0,
	    hashes, sizeof(hashes));
	CSR_WRITE_4(sc, BGE_RX_MODE, rxmode);
}

void
bge_sig_pre_reset(struct bge_softc *sc, int type)
{
	/* no bge_asf_mode. */

	if (type == BGE_RESET_START || type == BGE_RESET_SUSPEND)
		bge_ape_driver_state_change(sc, type);
}

void
bge_sig_post_reset(struct bge_softc *sc, int type)
{
	/* no bge_asf_mode. */

	if (type == BGE_RESET_SHUTDOWN)
		bge_ape_driver_state_change(sc, type);
}

void
bge_sig_legacy(struct bge_softc *sc, int type)
{
	/* no bge_asf_mode. */
}

void
bge_stop_fw(struct bge_softc *sc, int type)
{
	/* no bge_asf_mode. */
}

u_int32_t
bge_dma_swap_options(struct bge_softc *sc)
{
	u_int32_t dma_options = BGE_DMA_SWAP_OPTIONS;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720) {
		dma_options |= BGE_MODECTL_BYTESWAP_B2HRX_DATA |
		    BGE_MODECTL_WORDSWAP_B2HRX_DATA | BGE_MODECTL_B2HRX_ENABLE |
		    BGE_MODECTL_HTX2B_ENABLE;
	}

	return (dma_options);
}

int
bge_phy_addr(struct bge_softc *sc)
{
	struct pci_attach_args *pa = &(sc->bge_pa);
	int phy_addr = 1;

	switch (BGE_ASICREV(sc->bge_chipid)) {
	case BGE_ASICREV_BCM5717:
	case BGE_ASICREV_BCM5719:
	case BGE_ASICREV_BCM5720:
		phy_addr = pa->pa_function;
		if (sc->bge_chipid != BGE_CHIPID_BCM5717_A0) {
			phy_addr += (CSR_READ_4(sc, BGE_SGDIG_STS) &
			    BGE_SGDIGSTS_IS_SERDES) ? 8 : 1;
		} else {
			phy_addr += (CSR_READ_4(sc, BGE_CPMU_PHY_STRAP) &
			    BGE_CPMU_PHY_STRAP_IS_SERDES) ? 8 : 1;
		}
	}

	return (phy_addr);
}

/*
 * Do endian, PCI and DMA initialization.
 */
void
bge_chipinit(struct bge_softc *sc)
{
	struct pci_attach_args	*pa = &(sc->bge_pa);
	u_int32_t dma_rw_ctl, misc_ctl, mode_ctl;
	int i;

	/* Set endianness before we access any non-PCI registers. */
	misc_ctl = BGE_INIT;
	if (sc->bge_flags & BGE_TAGGED_STATUS)
		misc_ctl |= BGE_PCIMISCCTL_TAGGED_STATUS;
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MISC_CTL,
	    misc_ctl);

	/*
	 * Clear the MAC statistics block in the NIC's
	 * internal memory.
	 */
	for (i = BGE_STATS_BLOCK;
	    i < BGE_STATS_BLOCK_END + 1; i += sizeof(u_int32_t))
		BGE_MEMWIN_WRITE(pa->pa_pc, pa->pa_tag, i, 0);

	for (i = BGE_STATUS_BLOCK;
	    i < BGE_STATUS_BLOCK_END + 1; i += sizeof(u_int32_t))
		BGE_MEMWIN_WRITE(pa->pa_pc, pa->pa_tag, i, 0);

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57766) {
		/*
		 * For the 57766 and non Ax versions of 57765, bootcode
		 * needs to setup the PCIE Fast Training Sequence (FTS)
		 * value to prevent transmit hangs.
		 */
		if (BGE_CHIPREV(sc->bge_chipid) != BGE_CHIPREV_57765_AX) {
		    CSR_WRITE_4(sc, BGE_CPMU_PADRNG_CTL,
			CSR_READ_4(sc, BGE_CPMU_PADRNG_CTL) |
			BGE_CPMU_PADRNG_CTL_RDIV2);
		}
	}

	/*
	 * Set up the PCI DMA control register.
	 */
	dma_rw_ctl = BGE_PCIDMARWCTL_RD_CMD_SHIFT(6) |
	    BGE_PCIDMARWCTL_WR_CMD_SHIFT(7);

	if (sc->bge_flags & BGE_PCIE) {
		if (sc->bge_mps >= 256)
			dma_rw_ctl |= BGE_PCIDMARWCTL_WR_WAT_SHIFT(7);
		else
			dma_rw_ctl |= BGE_PCIDMARWCTL_WR_WAT_SHIFT(3);
	} else if (sc->bge_flags & BGE_PCIX) {
		/* PCI-X bus */
		if (BGE_IS_5714_FAMILY(sc)) {
			/* 256 bytes for read and write. */
			dma_rw_ctl |= BGE_PCIDMARWCTL_RD_WAT_SHIFT(2) |
			    BGE_PCIDMARWCTL_WR_WAT_SHIFT(2);

			if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5780)
				dma_rw_ctl |= BGE_PCIDMARWCTL_ONEDMA_ATONCE_GLOBAL;
			else
				dma_rw_ctl |= BGE_PCIDMARWCTL_ONEDMA_ATONCE_LOCAL;
		} else if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704) {
			/* 1536 bytes for read, 384 bytes for write. */
			dma_rw_ctl |= BGE_PCIDMARWCTL_RD_WAT_SHIFT(7) |
			    BGE_PCIDMARWCTL_WR_WAT_SHIFT(3);
		} else {
			/* 384 bytes for read and write. */
			dma_rw_ctl |= BGE_PCIDMARWCTL_RD_WAT_SHIFT(3) |
			    BGE_PCIDMARWCTL_WR_WAT_SHIFT(3) |
			    (0x0F);
		}

		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5703 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704) {
			u_int32_t tmp;

			/* Set ONEDMA_ATONCE for hardware workaround. */
			tmp = CSR_READ_4(sc, BGE_PCI_CLKCTL) & 0x1f;
			if (tmp == 6 || tmp == 7)
				dma_rw_ctl |=
				    BGE_PCIDMARWCTL_ONEDMA_ATONCE_GLOBAL;

			/* Set PCI-X DMA write workaround. */
			dma_rw_ctl |= BGE_PCIDMARWCTL_ASRT_ALL_BE;
		}
	} else {
		/* Conventional PCI bus: 256 bytes for read and write. */
		dma_rw_ctl |= BGE_PCIDMARWCTL_RD_WAT_SHIFT(7) |
		    BGE_PCIDMARWCTL_WR_WAT_SHIFT(7);

		if (BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5705 &&
		    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5750)
			dma_rw_ctl |= 0x0F;
	}

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701)
		dma_rw_ctl |= BGE_PCIDMARWCTL_USE_MRM |
		    BGE_PCIDMARWCTL_ASRT_ALL_BE;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5703 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704)
		dma_rw_ctl &= ~BGE_PCIDMARWCTL_MINDMA;

	if (BGE_IS_5717_PLUS(sc)) {
		dma_rw_ctl &= ~BGE_PCIDMARWCTL_DIS_CACHE_ALIGNMENT;
		if (sc->bge_chipid == BGE_CHIPID_BCM57765_A0)
			dma_rw_ctl &= ~BGE_PCIDMARWCTL_CRDRDR_RDMA_MRRS_MSK;

		/*
		 * Enable HW workaround for controllers that misinterpret
		 * a status tag update and leave interrupts permanently
		 * disabled.
		 */
		if (!BGE_IS_57765_PLUS(sc) &&
		    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5717 &&
		    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5762)
			dma_rw_ctl |= BGE_PCIDMARWCTL_TAGGED_STATUS_WA;
	}

	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL, dma_rw_ctl);

	/*
	 * Set up general mode register.
	 */
	mode_ctl = bge_dma_swap_options(sc);
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5762) {
		/* Retain Host-2-BMC settings written by APE firmware. */
		mode_ctl |= CSR_READ_4(sc, BGE_MODE_CTL) &
		    (BGE_MODECTL_BYTESWAP_B2HRX_DATA |
		    BGE_MODECTL_WORDSWAP_B2HRX_DATA |
		    BGE_MODECTL_B2HRX_ENABLE | BGE_MODECTL_HTX2B_ENABLE);
	}
	mode_ctl |= BGE_MODECTL_MAC_ATTN_INTR | BGE_MODECTL_HOST_SEND_BDS |
	    BGE_MODECTL_TX_NO_PHDR_CSUM;

	/*
	 * BCM5701 B5 have a bug causing data corruption when using
	 * 64-bit DMA reads, which can be terminated early and then
	 * completed later as 32-bit accesses, in combination with
	 * certain bridges.
	 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701 &&
	    sc->bge_chipid == BGE_CHIPID_BCM5701_B5)
		mode_ctl |= BGE_MODECTL_FORCE_PCI32;

	CSR_WRITE_4(sc, BGE_MODE_CTL, mode_ctl);

	/*
	 * Disable memory write invalidate.  Apparently it is not supported
	 * properly by these devices.
	 */
	PCI_CLRBIT(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    PCI_COMMAND_INVALIDATE_ENABLE);

#ifdef __brokenalpha__
	/*
	 * Must ensure that we do not cross an 8K (bytes) boundary
	 * for DMA reads.  Our highest limit is 1K bytes.  This is a
	 * restriction on some ALPHA platforms with early revision
	 * 21174 PCI chipsets, such as the AlphaPC 164lx
	 */
	PCI_SETBIT(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL,
	    BGE_PCI_READ_BNDRY_1024);
#endif

	/* Set the timer prescaler (always 66MHz) */
	CSR_WRITE_4(sc, BGE_MISC_CFG, BGE_32BITTIME_66MHZ);

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906) {
		DELAY(40);	/* XXX */

		/* Put PHY into ready state */
		BGE_CLRBIT(sc, BGE_MISC_CFG, BGE_MISCCFG_EPHY_IDDQ);
		CSR_READ_4(sc, BGE_MISC_CFG); /* Flush */
		DELAY(40);
	}
}

int
bge_blockinit(struct bge_softc *sc)
{
	volatile struct bge_rcb		*rcb;
	vaddr_t			rcb_addr;
	bge_hostaddr		taddr;
	u_int32_t		dmactl, rdmareg, mimode, val;
	int			i, limit;

	/*
	 * Initialize the memory window pointer register so that
	 * we can access the first 32K of internal NIC RAM. This will
	 * allow us to set up the TX send ring RCBs and the RX return
	 * ring RCBs, plus other things which live in NIC memory.
	 */
	CSR_WRITE_4(sc, BGE_PCI_MEMWIN_BASEADDR, 0);

	/* Configure mbuf memory pool */
	if (!BGE_IS_5705_PLUS(sc)) {
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_BASEADDR,
		    BGE_BUFFPOOL_1);

		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704)
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_LEN, 0x10000);
		else
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_LEN, 0x18000);

		/* Configure DMA resource pool */
		CSR_WRITE_4(sc, BGE_BMAN_DMA_DESCPOOL_BASEADDR,
		    BGE_DMA_DESCRIPTORS);
		CSR_WRITE_4(sc, BGE_BMAN_DMA_DESCPOOL_LEN, 0x2000);
	}

	/* Configure mbuf pool watermarks */
	/* new Broadcom docs strongly recommend these: */
	if (BGE_IS_5717_PLUS(sc)) {
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x0);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x2a);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0xa0);
	} else if (BGE_IS_5705_PLUS(sc)) {
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x0);

		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906) {
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x04);
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x10);
		} else {
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x10);
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x60);
		}
	} else {
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x50);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x20);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x60);
	}

	/* Configure DMA resource watermarks */
	CSR_WRITE_4(sc, BGE_BMAN_DMA_DESCPOOL_LOWAT, 5);
	CSR_WRITE_4(sc, BGE_BMAN_DMA_DESCPOOL_HIWAT, 10);

	/* Enable buffer manager */
	val = BGE_BMANMODE_ENABLE | BGE_BMANMODE_LOMBUF_ATTN;
	/*
	 * Change the arbitration algorithm of TXMBUF read request to
	 * round-robin instead of priority based for BCM5719.  When
	 * TXFIFO is almost empty, RDMA will hold its request until
	 * TXFIFO is not almost empty.
	 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719)
		val |= BGE_BMANMODE_NO_TX_UNDERRUN;
	CSR_WRITE_4(sc, BGE_BMAN_MODE, val);

	/* Poll for buffer manager start indication */
	for (i = 0; i < 2000; i++) {
		if (CSR_READ_4(sc, BGE_BMAN_MODE) & BGE_BMANMODE_ENABLE)
			break;
		DELAY(10);
	}

	if (i == 2000) {
		printf("%s: buffer manager failed to start\n",
		    sc->bge_dev.dv_xname);
		return (ENXIO);
	}

	/* Enable flow-through queues */
	CSR_WRITE_4(sc, BGE_FTQ_RESET, 0xFFFFFFFF);
	CSR_WRITE_4(sc, BGE_FTQ_RESET, 0);

	/* Wait until queue initialization is complete */
	for (i = 0; i < 2000; i++) {
		if (CSR_READ_4(sc, BGE_FTQ_RESET) == 0)
			break;
		DELAY(10);
	}

	if (i == 2000) {
		printf("%s: flow-through queue init failed\n",
		    sc->bge_dev.dv_xname);
		return (ENXIO);
	}

	/*
	 * Summary of rings supported by the controller:
	 *
	 * Standard Receive Producer Ring
	 * - This ring is used to feed receive buffers for "standard"
	 *   sized frames (typically 1536 bytes) to the controller.
	 *
	 * Jumbo Receive Producer Ring
	 * - This ring is used to feed receive buffers for jumbo sized
	 *   frames (i.e. anything bigger than the "standard" frames)
	 *   to the controller.
	 *
	 * Mini Receive Producer Ring
	 * - This ring is used to feed receive buffers for "mini"
	 *   sized frames to the controller.
	 * - This feature required external memory for the controller
	 *   but was never used in a production system.  Should always
	 *   be disabled.
	 *
	 * Receive Return Ring
	 * - After the controller has placed an incoming frame into a
	 *   receive buffer that buffer is moved into a receive return
	 *   ring.  The driver is then responsible to passing the
	 *   buffer up to the stack.  Many versions of the controller
	 *   support multiple RR rings.
	 *
	 * Send Ring
	 * - This ring is used for outgoing frames.  Many versions of
	 *   the controller support multiple send rings.
	 */

	/* Initialize the standard RX ring control block */
	rcb = &sc->bge_rdata->bge_info.bge_std_rx_rcb;
	BGE_HOSTADDR(rcb->bge_hostaddr, BGE_RING_DMA_ADDR(sc, bge_rx_std_ring));
	if (BGE_IS_5717_PLUS(sc)) {
		/*
		 * Bits 31-16: Programmable ring size (2048, 1024, 512, .., 32)
		 * Bits 15-2 : Maximum RX frame size
		 * Bit 1     : 1 = Ring Disabled, 0 = Ring ENabled
		 * Bit 0     : Reserved
		 */
		rcb->bge_maxlen_flags =
		    BGE_RCB_MAXLEN_FLAGS(512, ETHER_MAX_DIX_LEN << 2);
	} else if (BGE_IS_5705_PLUS(sc)) {
		/*
		 * Bits 31-16: Programmable ring size (512, 256, 128, 64, 32)
		 * Bits 15-2 : Reserved (should be 0)
		 * Bit 1     : 1 = Ring Disabled, 0 = Ring Enabled
		 * Bit 0     : Reserved
		 */
		rcb->bge_maxlen_flags = BGE_RCB_MAXLEN_FLAGS(512, 0);
	} else {
		/*
		 * Ring size is always XXX entries
		 * Bits 31-16: Maximum RX frame size
		 * Bits 15-2 : Reserved (should be 0)
		 * Bit 1     : 1 = Ring Disabled, 0 = Ring Enabled
		 * Bit 0     : Reserved
		 */
		rcb->bge_maxlen_flags =
		    BGE_RCB_MAXLEN_FLAGS(ETHER_MAX_DIX_LEN, 0);
	}
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720)
		rcb->bge_nicaddr = BGE_STD_RX_RINGS_5717;
	else
		rcb->bge_nicaddr = BGE_STD_RX_RINGS;
	/* Write the standard receive producer ring control block. */
	CSR_WRITE_4(sc, BGE_RX_STD_RCB_HADDR_HI, rcb->bge_hostaddr.bge_addr_hi);
	CSR_WRITE_4(sc, BGE_RX_STD_RCB_HADDR_LO, rcb->bge_hostaddr.bge_addr_lo);
	CSR_WRITE_4(sc, BGE_RX_STD_RCB_MAXLEN_FLAGS, rcb->bge_maxlen_flags);
	CSR_WRITE_4(sc, BGE_RX_STD_RCB_NICADDR, rcb->bge_nicaddr);

	/* Reset the standard receive producer ring producer index. */
	bge_writembx(sc, BGE_MBX_RX_STD_PROD_LO, 0);

	/*
	 * Initialize the Jumbo RX ring control block
	 * We set the 'ring disabled' bit in the flags
	 * field until we're actually ready to start
	 * using this ring (i.e. once we set the MTU
	 * high enough to require it).
	 */
	if (sc->bge_flags & BGE_JUMBO_RING) {
		rcb = &sc->bge_rdata->bge_info.bge_jumbo_rx_rcb;
		BGE_HOSTADDR(rcb->bge_hostaddr,
		    BGE_RING_DMA_ADDR(sc, bge_rx_jumbo_ring));
		rcb->bge_maxlen_flags = BGE_RCB_MAXLEN_FLAGS(0,
		    BGE_RCB_FLAG_USE_EXT_RX_BD | BGE_RCB_FLAG_RING_DISABLED);
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720)
			rcb->bge_nicaddr = BGE_JUMBO_RX_RINGS_5717;
		else
			rcb->bge_nicaddr = BGE_JUMBO_RX_RINGS;
		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_HADDR_HI,
		    rcb->bge_hostaddr.bge_addr_hi);
		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_HADDR_LO,
		    rcb->bge_hostaddr.bge_addr_lo);
		/* Program the jumbo receive producer ring RCB parameters. */
		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_MAXLEN_FLAGS,
		    rcb->bge_maxlen_flags);
		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_NICADDR, rcb->bge_nicaddr);
		/* Reset the jumbo receive producer ring producer index. */
		bge_writembx(sc, BGE_MBX_RX_JUMBO_PROD_LO, 0);
	}

	/* Disable the mini receive producer ring RCB. */
	if (BGE_IS_5700_FAMILY(sc)) {
		/* Set up dummy disabled mini ring RCB */
		rcb = &sc->bge_rdata->bge_info.bge_mini_rx_rcb;
		rcb->bge_maxlen_flags =
		    BGE_RCB_MAXLEN_FLAGS(0, BGE_RCB_FLAG_RING_DISABLED);
		CSR_WRITE_4(sc, BGE_RX_MINI_RCB_MAXLEN_FLAGS,
		    rcb->bge_maxlen_flags);
		/* Reset the mini receive producer ring producer index. */
		bge_writembx(sc, BGE_MBX_RX_MINI_PROD_LO, 0);

		/* XXX why? */
		bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
		    offsetof(struct bge_ring_data, bge_info),
		    sizeof (struct bge_gib),
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	}

	/* Choose de-pipeline mode for BCM5906 A0, A1 and A2. */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906) {
		if (sc->bge_chipid == BGE_CHIPID_BCM5906_A0 ||
		    sc->bge_chipid == BGE_CHIPID_BCM5906_A1 ||
		    sc->bge_chipid == BGE_CHIPID_BCM5906_A2)
			CSR_WRITE_4(sc, BGE_ISO_PKT_TX,
			    (CSR_READ_4(sc, BGE_ISO_PKT_TX) & ~3) | 2);
	}
	/*
	 * The BD ring replenish thresholds control how often the
	 * hardware fetches new BD's from the producer rings in host
	 * memory.  Setting the value too low on a busy system can
	 * starve the hardware and recue the throughpout.
	 *
	 * Set the BD ring replenish thresholds. The recommended
	 * values are 1/8th the number of descriptors allocated to
	 * each ring, but since we try to avoid filling the entire
	 * ring we set these to the minimal value of 8.  This needs to
	 * be done on several of the supported chip revisions anyway,
	 * to work around HW bugs.
	 */
	CSR_WRITE_4(sc, BGE_RBDI_STD_REPL_THRESH, 8);
	if (sc->bge_flags & BGE_JUMBO_RING)
		CSR_WRITE_4(sc, BGE_RBDI_JUMBO_REPL_THRESH, 8);

	if (BGE_IS_5717_PLUS(sc)) {
		CSR_WRITE_4(sc, BGE_STD_REPL_LWM, 4);
		CSR_WRITE_4(sc, BGE_JUMBO_REPL_LWM, 4);
	}

	/*
	 * Disable all send rings by setting the 'ring disabled' bit
	 * in the flags field of all the TX send ring control blocks,
	 * located in NIC memory.
	 */
	if (BGE_IS_5700_FAMILY(sc)) {
		/* 5700 to 5704 had 16 send rings. */
		limit = BGE_TX_RINGS_EXTSSRAM_MAX;
	} else if (BGE_IS_57765_PLUS(sc) ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5762)
		limit = 2;
	else if (BGE_IS_5717_PLUS(sc))
		limit = 4;
	else
		limit = 1;
	rcb_addr = BGE_MEMWIN_START + BGE_SEND_RING_RCB;
	for (i = 0; i < limit; i++) {
		RCB_WRITE_4(sc, rcb_addr, bge_maxlen_flags,
		    BGE_RCB_MAXLEN_FLAGS(0, BGE_RCB_FLAG_RING_DISABLED));
		RCB_WRITE_4(sc, rcb_addr, bge_nicaddr, 0);
		rcb_addr += sizeof(struct bge_rcb);
	}

	/* Configure send ring RCB 0 (we use only the first ring) */
	rcb_addr = BGE_MEMWIN_START + BGE_SEND_RING_RCB;
	BGE_HOSTADDR(taddr, BGE_RING_DMA_ADDR(sc, bge_tx_ring));
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_hi, taddr.bge_addr_hi);
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_lo, taddr.bge_addr_lo);
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720)
		RCB_WRITE_4(sc, rcb_addr, bge_nicaddr, BGE_SEND_RING_5717);
	else
		RCB_WRITE_4(sc, rcb_addr, bge_nicaddr,
		    BGE_NIC_TXRING_ADDR(0, BGE_TX_RING_CNT));
	RCB_WRITE_4(sc, rcb_addr, bge_maxlen_flags,
	    BGE_RCB_MAXLEN_FLAGS(BGE_TX_RING_CNT, 0));

	/*
	 * Disable all receive return rings by setting the
	 * 'ring diabled' bit in the flags field of all the receive
	 * return ring control blocks, located in NIC memory.
	 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720) {
		/* Should be 17, use 16 until we get an SRAM map. */
		limit = 16;
	} else if (BGE_IS_5700_FAMILY(sc))
		limit = BGE_RX_RINGS_MAX;
	else if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5755 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5762 ||
	    BGE_IS_57765_PLUS(sc))
		limit = 4;
	else
		limit = 1;
	/* Disable all receive return rings */
	rcb_addr = BGE_MEMWIN_START + BGE_RX_RETURN_RING_RCB;
	for (i = 0; i < limit; i++) {
		RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_hi, 0);
		RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_lo, 0);
		RCB_WRITE_4(sc, rcb_addr, bge_maxlen_flags,
		    BGE_RCB_MAXLEN_FLAGS(sc->bge_return_ring_cnt,
			BGE_RCB_FLAG_RING_DISABLED));
		RCB_WRITE_4(sc, rcb_addr, bge_nicaddr, 0);
		bge_writembx(sc, BGE_MBX_RX_CONS0_LO +
		    (i * (sizeof(u_int64_t))), 0);
		rcb_addr += sizeof(struct bge_rcb);
	}

	/*
	 * Set up receive return ring 0.  Note that the NIC address
	 * for RX return rings is 0x0.  The return rings live entirely
	 * within the host, so the nicaddr field in the RCB isn't used.
	 */
	rcb_addr = BGE_MEMWIN_START + BGE_RX_RETURN_RING_RCB;
	BGE_HOSTADDR(taddr, BGE_RING_DMA_ADDR(sc, bge_rx_return_ring));
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_hi, taddr.bge_addr_hi);
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_lo, taddr.bge_addr_lo);
	RCB_WRITE_4(sc, rcb_addr, bge_nicaddr, 0x00000000);
	RCB_WRITE_4(sc, rcb_addr, bge_maxlen_flags,
	    BGE_RCB_MAXLEN_FLAGS(sc->bge_return_ring_cnt, 0));

	/* Set random backoff seed for TX */
	CSR_WRITE_4(sc, BGE_TX_RANDOM_BACKOFF,
	    (sc->arpcom.ac_enaddr[0] + sc->arpcom.ac_enaddr[1] +
	     sc->arpcom.ac_enaddr[2] + sc->arpcom.ac_enaddr[3] +
	     sc->arpcom.ac_enaddr[4] + sc->arpcom.ac_enaddr[5]) &
	    BGE_TX_BACKOFF_SEED_MASK);

	/* Set inter-packet gap */
	val = 0x2620;
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5762)
		val |= CSR_READ_4(sc, BGE_TX_LENGTHS) &
		    (BGE_TXLEN_JMB_FRM_LEN_MSK | BGE_TXLEN_CNT_DN_VAL_MSK);
	CSR_WRITE_4(sc, BGE_TX_LENGTHS, val);

	/*
	 * Specify which ring to use for packets that don't match
	 * any RX rules.
	 */
	CSR_WRITE_4(sc, BGE_RX_RULES_CFG, 0x08);

	/*
	 * Configure number of RX lists. One interrupt distribution
	 * list, sixteen active lists, one bad frames class.
	 */
	CSR_WRITE_4(sc, BGE_RXLP_CFG, 0x181);

	/* Inialize RX list placement stats mask. */
	CSR_WRITE_4(sc, BGE_RXLP_STATS_ENABLE_MASK, 0x007BFFFF);
	CSR_WRITE_4(sc, BGE_RXLP_STATS_CTL, 0x1);

	/* Disable host coalescing until we get it set up */
	CSR_WRITE_4(sc, BGE_HCC_MODE, 0x00000000);

	/* Poll to make sure it's shut down. */
	for (i = 0; i < 2000; i++) {
		if (!(CSR_READ_4(sc, BGE_HCC_MODE) & BGE_HCCMODE_ENABLE))
			break;
		DELAY(10);
	}

	if (i == 2000) {
		printf("%s: host coalescing engine failed to idle\n",
		    sc->bge_dev.dv_xname);
		return (ENXIO);
	}

	/* Set up host coalescing defaults */
	CSR_WRITE_4(sc, BGE_HCC_RX_COAL_TICKS, sc->bge_rx_coal_ticks);
	CSR_WRITE_4(sc, BGE_HCC_TX_COAL_TICKS, sc->bge_tx_coal_ticks);
	CSR_WRITE_4(sc, BGE_HCC_RX_MAX_COAL_BDS, sc->bge_rx_max_coal_bds);
	CSR_WRITE_4(sc, BGE_HCC_TX_MAX_COAL_BDS, sc->bge_tx_max_coal_bds);
	if (!(BGE_IS_5705_PLUS(sc))) {
		CSR_WRITE_4(sc, BGE_HCC_RX_COAL_TICKS_INT, 0);
		CSR_WRITE_4(sc, BGE_HCC_TX_COAL_TICKS_INT, 0);
	}
	CSR_WRITE_4(sc, BGE_HCC_RX_MAX_COAL_BDS_INT, 0);
	CSR_WRITE_4(sc, BGE_HCC_TX_MAX_COAL_BDS_INT, 0);

	/* Set up address of statistics block */
	if (!(BGE_IS_5705_PLUS(sc))) {
		BGE_HOSTADDR(taddr, BGE_RING_DMA_ADDR(sc, bge_info.bge_stats));
		CSR_WRITE_4(sc, BGE_HCC_STATS_ADDR_HI, taddr.bge_addr_hi);
		CSR_WRITE_4(sc, BGE_HCC_STATS_ADDR_LO, taddr.bge_addr_lo);

		CSR_WRITE_4(sc, BGE_HCC_STATS_BASEADDR, BGE_STATS_BLOCK);
		CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_BASEADDR, BGE_STATUS_BLOCK);
		CSR_WRITE_4(sc, BGE_HCC_STATS_TICKS, sc->bge_stat_ticks);
	}

	/* Set up address of status block */
	BGE_HOSTADDR(taddr, BGE_RING_DMA_ADDR(sc, bge_status_block));
	CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_ADDR_HI, taddr.bge_addr_hi);
	CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_ADDR_LO, taddr.bge_addr_lo);

	sc->bge_rdata->bge_status_block.bge_idx[0].bge_rx_prod_idx = 0;
	sc->bge_rdata->bge_status_block.bge_idx[0].bge_tx_cons_idx = 0;

	/* Set up status block size. */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 &&
	    sc->bge_chipid != BGE_CHIPID_BCM5700_C0) {
		val = BGE_STATBLKSZ_FULL;
		bzero(&sc->bge_rdata->bge_status_block, BGE_STATUS_BLK_SZ);
	} else {
		val = BGE_STATBLKSZ_32BYTE;
		bzero(&sc->bge_rdata->bge_status_block, 32);
	}

	/* Turn on host coalescing state machine */
	CSR_WRITE_4(sc, BGE_HCC_MODE, val | BGE_HCCMODE_ENABLE);

	/* Turn on RX BD completion state machine and enable attentions */
	CSR_WRITE_4(sc, BGE_RBDC_MODE,
	    BGE_RBDCMODE_ENABLE|BGE_RBDCMODE_ATTN);

	/* Turn on RX list placement state machine */
	CSR_WRITE_4(sc, BGE_RXLP_MODE, BGE_RXLPMODE_ENABLE);

	/* Turn on RX list selector state machine. */
	if (!(BGE_IS_5705_PLUS(sc)))
		CSR_WRITE_4(sc, BGE_RXLS_MODE, BGE_RXLSMODE_ENABLE);

	val = BGE_MACMODE_TXDMA_ENB | BGE_MACMODE_RXDMA_ENB |
	    BGE_MACMODE_RX_STATS_CLEAR | BGE_MACMODE_TX_STATS_CLEAR |
	    BGE_MACMODE_RX_STATS_ENB | BGE_MACMODE_TX_STATS_ENB |
	    BGE_MACMODE_FRMHDR_DMA_ENB;

	if (sc->bge_flags & BGE_FIBER_TBI)
	    val |= BGE_PORTMODE_TBI;
	else if (sc->bge_flags & BGE_FIBER_MII)
	    val |= BGE_PORTMODE_GMII;
	else
	    val |= BGE_PORTMODE_MII;

	/* Allow APE to send/receive frames. */
	if ((sc->bge_mfw_flags & BGE_MFW_ON_APE) != 0)
		val |= BGE_MACMODE_APE_RX_EN | BGE_MACMODE_APE_TX_EN;

	/* Turn on DMA, clear stats */
	CSR_WRITE_4(sc, BGE_MAC_MODE, val);
	DELAY(40);

	/* Set misc. local control, enable interrupts on attentions */
	BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_INTR_ONATTN);

#ifdef notdef
	/* Assert GPIO pins for PHY reset */
	BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_MISCIO_OUT0|
	    BGE_MLC_MISCIO_OUT1|BGE_MLC_MISCIO_OUT2);
	BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_MISCIO_OUTEN0|
	    BGE_MLC_MISCIO_OUTEN1|BGE_MLC_MISCIO_OUTEN2);
#endif

	/* Turn on DMA completion state machine */
	if (!(BGE_IS_5705_PLUS(sc)))
		CSR_WRITE_4(sc, BGE_DMAC_MODE, BGE_DMACMODE_ENABLE);

	val = BGE_WDMAMODE_ENABLE|BGE_WDMAMODE_ALL_ATTNS;

	/* Enable host coalescing bug fix. */
	if (BGE_IS_5755_PLUS(sc))
		val |= BGE_WDMAMODE_STATUS_TAG_FIX;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5785)
		val |= BGE_WDMAMODE_BURST_ALL_DATA;

	/* Turn on write DMA state machine */
	CSR_WRITE_4(sc, BGE_WDMA_MODE, val);
	DELAY(40);

	val = BGE_RDMAMODE_ENABLE|BGE_RDMAMODE_ALL_ATTNS;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717)
		val |= BGE_RDMAMODE_MULT_DMA_RD_DIS;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5785 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57780)
		val |= BGE_RDMAMODE_BD_SBD_CRPT_ATTN |
		       BGE_RDMAMODE_MBUF_RBD_CRPT_ATTN |
		       BGE_RDMAMODE_MBUF_SBD_CRPT_ATTN;

	if (sc->bge_flags & BGE_PCIE)
		val |= BGE_RDMAMODE_FIFO_LONG_BURST;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5762) {
		val |= CSR_READ_4(sc, BGE_RDMA_MODE) &
		    BGE_RDMAMODE_H2BNC_VLAN_DET;
		/*
		 * Allow multiple outstanding read requests from
		 * non-LSO read DMA engine.
		 */
		val &= ~BGE_RDMAMODE_MULT_DMA_RD_DIS;
	}

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5785 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57780 ||
	    BGE_IS_5717_PLUS(sc) || BGE_IS_57765_PLUS(sc)) {
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5762)
			rdmareg = BGE_RDMA_RSRVCTRL_REG2;
		else
			rdmareg = BGE_RDMA_RSRVCTRL;
		dmactl = CSR_READ_4(sc, rdmareg);
		/*
		 * Adjust tx margin to prevent TX data corruption and
		 * fix internal FIFO overflow.
		 */
		if (sc->bge_chipid == BGE_CHIPID_BCM5719_A0 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5762) {
			dmactl &= ~(BGE_RDMA_RSRVCTRL_FIFO_LWM_MASK |
			    BGE_RDMA_RSRVCTRL_FIFO_HWM_MASK |
			    BGE_RDMA_RSRVCTRL_TXMRGN_MASK);
			dmactl |= BGE_RDMA_RSRVCTRL_FIFO_LWM_1_5K |
			    BGE_RDMA_RSRVCTRL_FIFO_HWM_1_5K |
			    BGE_RDMA_RSRVCTRL_TXMRGN_320B;
		}
		/*
		 * Enable fix for read DMA FIFO overruns.
		 * The fix is to limit the number of RX BDs
		 * the hardware would fetch at a fime.
		 */
		CSR_WRITE_4(sc, rdmareg, dmactl |
		    BGE_RDMA_RSRVCTRL_FIFO_OFLW_FIX);
	}

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719) {
		CSR_WRITE_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL,
		    CSR_READ_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL) |
		    BGE_RDMA_LSO_CRPTEN_CTRL_BLEN_BD_4K |
		    BGE_RDMA_LSO_CRPTEN_CTRL_BLEN_LSO_4K);
	} else if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720) {
		/*
		 * Allow 4KB burst length reads for non-LSO frames.
		 * Enable 512B burst length reads for buffer descriptors.
		 */
		CSR_WRITE_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL,
		    CSR_READ_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL) |
		    BGE_RDMA_LSO_CRPTEN_CTRL_BLEN_BD_512 |
		    BGE_RDMA_LSO_CRPTEN_CTRL_BLEN_LSO_4K);
	} else if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5762) {
		CSR_WRITE_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL_REG2,
		    CSR_READ_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL_REG2) |
		    BGE_RDMA_LSO_CRPTEN_CTRL_BLEN_BD_4K |
		    BGE_RDMA_LSO_CRPTEN_CTRL_BLEN_LSO_4K);
	}

	CSR_WRITE_4(sc, BGE_RDMA_MODE, val);
	DELAY(40);

	if (sc->bge_flags & BGE_RDMA_BUG) {
		for (i = 0; i < BGE_NUM_RDMA_CHANNELS / 2; i++) {
			val = CSR_READ_4(sc, BGE_RDMA_LENGTH + i * 4);
			if ((val & 0xFFFF) > ETHER_MAX_LEN)
				break;
			if (((val >> 16) & 0xFFFF) > ETHER_MAX_LEN)
				break;
		}
		if (i != BGE_NUM_RDMA_CHANNELS / 2) {
			val = CSR_READ_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL);
			if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719)
				val |= BGE_RDMA_TX_LENGTH_WA_5719;
			else
				val |= BGE_RDMA_TX_LENGTH_WA_5720;
			CSR_WRITE_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL, val);
		}
	}

	/* Turn on RX data completion state machine */
	CSR_WRITE_4(sc, BGE_RDC_MODE, BGE_RDCMODE_ENABLE);

	/* Turn on RX BD initiator state machine */
	CSR_WRITE_4(sc, BGE_RBDI_MODE, BGE_RBDIMODE_ENABLE);

	/* Turn on RX data and RX BD initiator state machine */
	CSR_WRITE_4(sc, BGE_RDBDI_MODE, BGE_RDBDIMODE_ENABLE);

	/* Turn on Mbuf cluster free state machine */
	if (!BGE_IS_5705_PLUS(sc))
		CSR_WRITE_4(sc, BGE_MBCF_MODE, BGE_MBCFMODE_ENABLE);

	/* Turn on send BD completion state machine */
	CSR_WRITE_4(sc, BGE_SBDC_MODE, BGE_SBDCMODE_ENABLE);

	/* Turn on send data completion state machine */
	val = BGE_SDCMODE_ENABLE;
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761)
		val |= BGE_SDCMODE_CDELAY;
	CSR_WRITE_4(sc, BGE_SDC_MODE, val);

	/* Turn on send data initiator state machine */
	CSR_WRITE_4(sc, BGE_SDI_MODE, BGE_SDIMODE_ENABLE);

	/* Turn on send BD initiator state machine */
	CSR_WRITE_4(sc, BGE_SBDI_MODE, BGE_SBDIMODE_ENABLE);

	/* Turn on send BD selector state machine */
	CSR_WRITE_4(sc, BGE_SRS_MODE, BGE_SRSMODE_ENABLE);

	CSR_WRITE_4(sc, BGE_SDI_STATS_ENABLE_MASK, 0x007BFFFF);
	CSR_WRITE_4(sc, BGE_SDI_STATS_CTL,
	    BGE_SDISTATSCTL_ENABLE|BGE_SDISTATSCTL_FASTER);

	/* ack/clear link change events */
	CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED |
	    BGE_MACSTAT_CFG_CHANGED | BGE_MACSTAT_MI_COMPLETE |
	    BGE_MACSTAT_LINK_CHANGED);

	/* Enable PHY auto polling (for MII/GMII only) */
	if (sc->bge_flags & BGE_FIBER_TBI) {
		CSR_WRITE_4(sc, BGE_MI_STS, BGE_MISTS_LINK);
 	} else {
		if ((sc->bge_flags & BGE_CPMU_PRESENT) != 0)
			mimode = BGE_MIMODE_500KHZ_CONST;
		else
			mimode = BGE_MIMODE_BASE;
		if (BGE_IS_5700_FAMILY(sc) ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5705) {
			mimode |= BGE_MIMODE_AUTOPOLL;
			BGE_STS_SETBIT(sc, BGE_STS_AUTOPOLL);
		}
		mimode |= BGE_MIMODE_PHYADDR(sc->bge_phy_addr);
		CSR_WRITE_4(sc, BGE_MI_MODE, mimode);
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700)
			CSR_WRITE_4(sc, BGE_MAC_EVT_ENB,
			    BGE_EVTENB_MI_INTERRUPT);
	}

	/*
	 * Clear any pending link state attention.
	 * Otherwise some link state change events may be lost until attention
	 * is cleared by bge_intr() -> bge_link_upd() sequence.
	 * It's not necessary on newer BCM chips - perhaps enabling link
	 * state change attentions implies clearing pending attention.
	 */
	CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED|
	    BGE_MACSTAT_CFG_CHANGED|BGE_MACSTAT_MI_COMPLETE|
	    BGE_MACSTAT_LINK_CHANGED);

	/* Enable link state change attentions. */
	BGE_SETBIT(sc, BGE_MAC_EVT_ENB, BGE_EVTENB_LINK_CHANGED);

	return (0);
}

const struct bge_revision *
bge_lookup_rev(u_int32_t chipid)
{
	const struct bge_revision *br;

	for (br = bge_revisions; br->br_name != NULL; br++) {
		if (br->br_chipid == chipid)
			return (br);
	}

	for (br = bge_majorrevs; br->br_name != NULL; br++) {
		if (br->br_chipid == BGE_ASICREV(chipid))
			return (br);
	}

	return (NULL);
}

int
bge_can_use_msi(struct bge_softc *sc)
{
	int can_use_msi = 0;

	switch (BGE_ASICREV(sc->bge_chipid)) {
	case BGE_ASICREV_BCM5714_A0:
	case BGE_ASICREV_BCM5714:
		/*
		 * Apparently, MSI doesn't work when these chips are
		 * configured in single-port mode.
		 */
		break;
	case BGE_ASICREV_BCM5750:
		if (BGE_CHIPREV(sc->bge_chipid) != BGE_CHIPREV_5750_AX &&
		    BGE_CHIPREV(sc->bge_chipid) != BGE_CHIPREV_5750_BX)
			can_use_msi = 1;
		break;
	default:
		if (BGE_IS_575X_PLUS(sc))
			can_use_msi = 1;
	}

	return (can_use_msi);
}

/*
 * Probe for a Broadcom chip. Check the PCI vendor and device IDs
 * against our list and return its name if we find a match. Note
 * that since the Broadcom controller contains VPD support, we
 * can get the device name string from the controller itself instead
 * of the compiled-in string. This is a little slow, but it guarantees
 * we'll always announce the right product name.
 */
int
bge_probe(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid(aux, bge_devices, nitems(bge_devices)));
}

void
bge_attach(struct device *parent, struct device *self, void *aux)
{
	struct bge_softc	*sc = (struct bge_softc *)self;
	struct pci_attach_args	*pa = aux;
	pci_chipset_tag_t	pc = pa->pa_pc;
	const struct bge_revision *br;
	pcireg_t		pm_ctl, memtype, subid, reg;
	pci_intr_handle_t	ih;
	const char		*intrstr = NULL;
	int			gotenaddr = 0;
	u_int32_t		hwcfg = 0;
	u_int32_t		mac_addr = 0;
	u_int32_t		misccfg;
	struct ifnet		*ifp;
	caddr_t			kva;
#ifdef __sparc64__
	char			name[32];
#endif

	sc->bge_pa = *pa;

	subid = pci_conf_read(pc, pa->pa_tag, PCI_SUBSYS_ID_REG);

	/*
	 * Map control/status registers.
	 */
	DPRINTFN(5, ("Map control/status regs\n"));

	DPRINTFN(5, ("pci_mapreg_map\n"));
	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, BGE_PCI_BAR0);
	if (pci_mapreg_map(pa, BGE_PCI_BAR0, memtype, 0, &sc->bge_btag,
	    &sc->bge_bhandle, NULL, &sc->bge_bsize, 0)) {
		printf(": can't find mem space\n");
		return;
	}

	/*
	 * Kludge for 5700 Bx bug: a hardware bug (PCIX byte enable?)
	 * can clobber the chip's PCI config-space power control registers,
	 * leaving the card in D3 powersave state.
	 * We do not have memory-mapped registers in this state,
	 * so force device into D0 state before starting initialization.
	 */
	pm_ctl = pci_conf_read(pc, pa->pa_tag, BGE_PCI_PWRMGMT_CMD);
	pm_ctl &= ~(PCI_PWR_D0|PCI_PWR_D1|PCI_PWR_D2|PCI_PWR_D3);
	pm_ctl |= (1 << 8) | PCI_PWR_D0 ; /* D0 state */
	pci_conf_write(pc, pa->pa_tag, BGE_PCI_PWRMGMT_CMD, pm_ctl);
	DELAY(1000);	/* 27 usec is allegedly sufficent */

	/*
	 * Save ASIC rev.
	 */
	sc->bge_chipid =
	     (pci_conf_read(pc, pa->pa_tag, BGE_PCI_MISC_CTL)
	      >> BGE_PCIMISCCTL_ASICREV_SHIFT);

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_USE_PRODID_REG) {
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_BROADCOM_BCM5717:
		case PCI_PRODUCT_BROADCOM_BCM5718:
		case PCI_PRODUCT_BROADCOM_BCM5719:
		case PCI_PRODUCT_BROADCOM_BCM5720:
		case PCI_PRODUCT_BROADCOM_BCM5725:
		case PCI_PRODUCT_BROADCOM_BCM5727:
		case PCI_PRODUCT_BROADCOM_BCM5762:
		case PCI_PRODUCT_BROADCOM_BCM57764:
		case PCI_PRODUCT_BROADCOM_BCM57767:
		case PCI_PRODUCT_BROADCOM_BCM57787:
			sc->bge_chipid = pci_conf_read(pc, pa->pa_tag,
			    BGE_PCI_GEN2_PRODID_ASICREV);
			break;
		case PCI_PRODUCT_BROADCOM_BCM57761:
		case PCI_PRODUCT_BROADCOM_BCM57762:
		case PCI_PRODUCT_BROADCOM_BCM57765:
		case PCI_PRODUCT_BROADCOM_BCM57766:
		case PCI_PRODUCT_BROADCOM_BCM57781:
		case PCI_PRODUCT_BROADCOM_BCM57782:
		case PCI_PRODUCT_BROADCOM_BCM57785:
		case PCI_PRODUCT_BROADCOM_BCM57786:
		case PCI_PRODUCT_BROADCOM_BCM57791:
		case PCI_PRODUCT_BROADCOM_BCM57795:
			sc->bge_chipid = pci_conf_read(pc, pa->pa_tag,
			    BGE_PCI_GEN15_PRODID_ASICREV);
			break;
		default:
			sc->bge_chipid = pci_conf_read(pc, pa->pa_tag,
			    BGE_PCI_PRODID_ASICREV);
			break;
		}
	}

	sc->bge_phy_addr = bge_phy_addr(sc);

	printf(", ");
	br = bge_lookup_rev(sc->bge_chipid);
	if (br == NULL)
		printf("unknown ASIC (0x%x)", sc->bge_chipid);
	else
		printf("%s (0x%x)", br->br_name, sc->bge_chipid);

	/*
	 * PCI Express or PCI-X controller check.
	 */
	if (pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_PCIEXPRESS,
	    &sc->bge_expcap, NULL) != 0) {
		/* Extract supported maximum payload size. */
		reg = pci_conf_read(pa->pa_pc, pa->pa_tag, sc->bge_expcap +
		    PCI_PCIE_DCAP);
		sc->bge_mps = 128 << (reg & 0x7);
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720)
			sc->bge_expmrq = (fls(2048) - 8) << 12;
		else
			sc->bge_expmrq = (fls(4096) - 8) << 12;
		/* Disable PCIe Active State Power Management (ASPM). */
		reg = pci_conf_read(pa->pa_pc, pa->pa_tag,
		    sc->bge_expcap + PCI_PCIE_LCSR);
		reg &= ~(PCI_PCIE_LCSR_ASPM_L0S | PCI_PCIE_LCSR_ASPM_L1);
		pci_conf_write(pa->pa_pc, pa->pa_tag,
		    sc->bge_expcap + PCI_PCIE_LCSR, reg);
		sc->bge_flags |= BGE_PCIE;
	} else {
		if ((pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE) &
		    BGE_PCISTATE_PCI_BUSMODE) == 0)
			sc->bge_flags |= BGE_PCIX;
	}

	/*
	 * SEEPROM check.
	 */
#ifdef __sparc64__
	/*
	 * Onboard interfaces on UltraSPARC systems generally don't
	 * have a SEEPROM fitted.  These interfaces, and cards that
	 * have FCode, are named "network" by the PROM, whereas cards
	 * without FCode show up as "ethernet".  Since we don't really
	 * need the information from the SEEPROM on cards that have
	 * FCode it's fine to pretend they don't have one.
	 */
	if (OF_getprop(PCITAG_NODE(pa->pa_tag), "name", name,
	    sizeof(name)) > 0 && strcmp(name, "network") == 0)
		sc->bge_flags |= BGE_NO_EEPROM;
#endif

	/* Save chipset family. */
	switch (BGE_ASICREV(sc->bge_chipid)) {
	case BGE_ASICREV_BCM5762:
	case BGE_ASICREV_BCM57765:
	case BGE_ASICREV_BCM57766:
		sc->bge_flags |= BGE_57765_PLUS;
		/* FALLTHROUGH */
	case BGE_ASICREV_BCM5717:
	case BGE_ASICREV_BCM5719:
	case BGE_ASICREV_BCM5720:
		sc->bge_flags |= BGE_5717_PLUS | BGE_5755_PLUS | BGE_575X_PLUS |
		    BGE_5705_PLUS | BGE_JUMBO_CAPABLE | BGE_JUMBO_RING |
		    BGE_JUMBO_FRAME;
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720) {
			/*
			 * Enable work around for DMA engine miscalculation
			 * of TXMBUF available space.
			 */
			sc->bge_flags |= BGE_RDMA_BUG;

			if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719 &&
			    sc->bge_chipid == BGE_CHIPID_BCM5719_A0) {
				/* Jumbo frame on BCM5719 A0 does not work. */
				sc->bge_flags &= ~(BGE_JUMBO_CAPABLE |
				    BGE_JUMBO_RING | BGE_JUMBO_FRAME);
			}
		}
		break;
	case BGE_ASICREV_BCM5755:
	case BGE_ASICREV_BCM5761:
	case BGE_ASICREV_BCM5784:
	case BGE_ASICREV_BCM5785:
	case BGE_ASICREV_BCM5787:
	case BGE_ASICREV_BCM57780:
		sc->bge_flags |= BGE_5755_PLUS | BGE_575X_PLUS | BGE_5705_PLUS;
		break;
	case BGE_ASICREV_BCM5700:
	case BGE_ASICREV_BCM5701:
	case BGE_ASICREV_BCM5703:
	case BGE_ASICREV_BCM5704:
		sc->bge_flags |= BGE_5700_FAMILY | BGE_JUMBO_CAPABLE | BGE_JUMBO_RING;
		break;
	case BGE_ASICREV_BCM5714_A0:
	case BGE_ASICREV_BCM5780:
	case BGE_ASICREV_BCM5714:
		sc->bge_flags |= BGE_5714_FAMILY | BGE_JUMBO_CAPABLE | BGE_JUMBO_STD;
		/* FALLTHROUGH */
	case BGE_ASICREV_BCM5750:
	case BGE_ASICREV_BCM5752:
	case BGE_ASICREV_BCM5906:
		sc->bge_flags |= BGE_575X_PLUS;
		/* FALLTHROUGH */
	case BGE_ASICREV_BCM5705:
		sc->bge_flags |= BGE_5705_PLUS;
		break;
	}

	if (sc->bge_flags & BGE_JUMBO_STD)
		sc->bge_rx_std_len = BGE_JLEN;
	else
		sc->bge_rx_std_len = MCLBYTES;

	/*
	 * When using the BCM5701 in PCI-X mode, data corruption has
	 * been observed in the first few bytes of some received packets.
	 * Aligning the packet buffer in memory eliminates the corruption.
	 * Unfortunately, this misaligns the packet payloads.  On platforms
	 * which do not support unaligned accesses, we will realign the
	 * payloads by copying the received packets.
	 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701 &&
	    sc->bge_flags & BGE_PCIX)
		sc->bge_flags |= BGE_RX_ALIGNBUG;

	if ((BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701) &&
	    PCI_VENDOR(subid) == DELL_VENDORID)
		sc->bge_phy_flags |= BGE_PHY_NO_3LED;

	misccfg = CSR_READ_4(sc, BGE_MISC_CFG);
	misccfg &= BGE_MISCCFG_BOARD_ID_MASK;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5705 &&
	    (misccfg == BGE_MISCCFG_BOARD_ID_5788 ||
	     misccfg == BGE_MISCCFG_BOARD_ID_5788M))
		sc->bge_flags |= BGE_IS_5788;

	if ((BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5703 &&
	     (misccfg == 0x4000 || misccfg == 0x8000)) ||
	    (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5705 &&
	     PCI_VENDOR(pa->pa_id) == PCI_VENDOR_BROADCOM &&
	     (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5901 ||
	      PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5901A2 ||
	      PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5705F)) ||
	    (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_BROADCOM &&
	     (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5751F ||
	      PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5753F ||
	      PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5787F)) ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57790 ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57791 ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57795 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906)
		sc->bge_phy_flags |= BGE_PHY_10_100_ONLY;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
	    (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5705 &&
	     (sc->bge_chipid != BGE_CHIPID_BCM5705_A0 &&
	      sc->bge_chipid != BGE_CHIPID_BCM5705_A1)) ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906)
		sc->bge_phy_flags |= BGE_PHY_NO_WIRESPEED;

	if (sc->bge_chipid == BGE_CHIPID_BCM5701_A0 ||
	    sc->bge_chipid == BGE_CHIPID_BCM5701_B0)
		sc->bge_phy_flags |= BGE_PHY_CRC_BUG;
	if (BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5703_AX ||
	    BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5704_AX)
		sc->bge_phy_flags |= BGE_PHY_ADC_BUG;
	if (sc->bge_chipid == BGE_CHIPID_BCM5704_A0)
		sc->bge_phy_flags |= BGE_PHY_5704_A0_BUG;

	if ((BGE_IS_5705_PLUS(sc)) &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5906 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5785 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM57780 &&
	    !BGE_IS_5717_PLUS(sc)) {
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5755 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5787) {
			if (PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_BROADCOM_BCM5722 &&
			    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_BROADCOM_BCM5756)
				sc->bge_phy_flags |= BGE_PHY_JITTER_BUG;
			if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5755M)
				sc->bge_phy_flags |= BGE_PHY_ADJUST_TRIM;
		} else
			sc->bge_phy_flags |= BGE_PHY_BER_BUG;
	}

	/* Identify chips with APE processor. */
	switch (BGE_ASICREV(sc->bge_chipid)) {
	case BGE_ASICREV_BCM5717:
	case BGE_ASICREV_BCM5719:
	case BGE_ASICREV_BCM5720:
	case BGE_ASICREV_BCM5761:
	case BGE_ASICREV_BCM5762:
		sc->bge_flags |= BGE_APE;
		break;
	}

	/* Chips with APE need BAR2 access for APE registers/memory. */
	if ((sc->bge_flags & BGE_APE) != 0) {
		memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, BGE_PCI_BAR2);
		if (pci_mapreg_map(pa, BGE_PCI_BAR2, memtype, 0,
		    &sc->bge_apetag, &sc->bge_apehandle, NULL,
		    &sc->bge_apesize, 0)) {
			printf(": couldn't map BAR2 memory\n");
			goto fail_1;
		}

		/* Enable APE register/memory access by host driver. */
		reg = pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE);
		reg |= BGE_PCISTATE_ALLOW_APE_CTLSPC_WR |
		    BGE_PCISTATE_ALLOW_APE_SHMEM_WR |
		    BGE_PCISTATE_ALLOW_APE_PSPACE_WR;
		pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE, reg);

		bge_ape_lock_init(sc);
		bge_ape_read_fw_ver(sc);
	}

	/* Identify the chips that use an CPMU. */
	if (BGE_IS_5717_PLUS(sc) ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5785 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57780)
		sc->bge_flags |= BGE_CPMU_PRESENT;

	if (pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_MSI,
	    &sc->bge_msicap, NULL)) {
		if (bge_can_use_msi(sc) == 0)
			pa->pa_flags &= ~PCI_FLAGS_MSI_ENABLED;
	}

	DPRINTFN(5, ("pci_intr_map\n"));
	if (pci_intr_map_msi(pa, &ih) == 0)
		sc->bge_flags |= BGE_MSI;
	else if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		goto fail_1;
	}

	/*
	 * All controllers except BCM5700 supports tagged status but
	 * we use tagged status only for MSI case on BCM5717. Otherwise
	 * MSI on BCM5717 does not work.
	 */
	if (BGE_IS_5717_PLUS(sc) && sc->bge_flags & BGE_MSI)
		sc->bge_flags |= BGE_TAGGED_STATUS;

	DPRINTFN(5, ("pci_intr_string\n"));
	intrstr = pci_intr_string(pc, ih);

	/* Try to reset the chip. */
	DPRINTFN(5, ("bge_reset\n"));
	bge_sig_pre_reset(sc, BGE_RESET_START);
	bge_reset(sc);

	bge_sig_legacy(sc, BGE_RESET_START);
	bge_sig_post_reset(sc, BGE_RESET_START);

	bge_chipinit(sc);

#ifdef __sparc64__
	if (!gotenaddr) {
		if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
		    sc->arpcom.ac_enaddr, ETHER_ADDR_LEN) == ETHER_ADDR_LEN)
			gotenaddr = 1;
	}
#endif

	/*
	 * Get station address from the EEPROM.
	 */
	if (!gotenaddr) {
		mac_addr = bge_readmem_ind(sc, 0x0c14);
		if ((mac_addr >> 16) == 0x484b) {
			sc->arpcom.ac_enaddr[0] = (u_char)(mac_addr >> 8);
			sc->arpcom.ac_enaddr[1] = (u_char)mac_addr;
			mac_addr = bge_readmem_ind(sc, 0x0c18);
			sc->arpcom.ac_enaddr[2] = (u_char)(mac_addr >> 24);
			sc->arpcom.ac_enaddr[3] = (u_char)(mac_addr >> 16);
			sc->arpcom.ac_enaddr[4] = (u_char)(mac_addr >> 8);
			sc->arpcom.ac_enaddr[5] = (u_char)mac_addr;
			gotenaddr = 1;
		}
	}
	if (!gotenaddr) {
		int mac_offset = BGE_EE_MAC_OFFSET;

		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906)
			mac_offset = BGE_EE_MAC_OFFSET_5906;

		if (bge_read_nvram(sc, (caddr_t)&sc->arpcom.ac_enaddr,
		    mac_offset + 2, ETHER_ADDR_LEN) == 0)
			gotenaddr = 1;
	}
	if (!gotenaddr && (!(sc->bge_flags & BGE_NO_EEPROM))) {
		if (bge_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
		    BGE_EE_MAC_OFFSET + 2, ETHER_ADDR_LEN) == 0)
			gotenaddr = 1;
	}

#ifdef __sparc64__
	if (!gotenaddr) {
		extern void myetheraddr(u_char *);

		myetheraddr(sc->arpcom.ac_enaddr);
		gotenaddr = 1;
	}
#endif

	if (!gotenaddr) {
		printf(": failed to read station address\n");
		goto fail_2;
	}

	/* Allocate the general information block and ring buffers. */
	sc->bge_dmatag = pa->pa_dmat;
	DPRINTFN(5, ("bus_dmamem_alloc\n"));
	if (bus_dmamem_alloc(sc->bge_dmatag, sizeof(struct bge_ring_data),
	    PAGE_SIZE, 0, &sc->bge_ring_seg, 1, &sc->bge_ring_nseg,
	    BUS_DMA_NOWAIT)) {
		printf(": can't alloc rx buffers\n");
		goto fail_2;
	}
	DPRINTFN(5, ("bus_dmamem_map\n"));
	if (bus_dmamem_map(sc->bge_dmatag, &sc->bge_ring_seg,
	    sc->bge_ring_nseg, sizeof(struct bge_ring_data), &kva,
	    BUS_DMA_NOWAIT)) {
		printf(": can't map dma buffers (%lu bytes)\n",
		    sizeof(struct bge_ring_data));
		goto fail_3;
	}
	DPRINTFN(5, ("bus_dmamem_create\n"));
	if (bus_dmamap_create(sc->bge_dmatag, sizeof(struct bge_ring_data), 1,
	    sizeof(struct bge_ring_data), 0,
	    BUS_DMA_NOWAIT, &sc->bge_ring_map)) {
		printf(": can't create dma map\n");
		goto fail_4;
	}
	DPRINTFN(5, ("bus_dmamem_load\n"));
	if (bus_dmamap_load(sc->bge_dmatag, sc->bge_ring_map, kva,
			    sizeof(struct bge_ring_data), NULL,
			    BUS_DMA_NOWAIT)) {
		goto fail_5;
	}

	DPRINTFN(5, ("bzero\n"));
	sc->bge_rdata = (struct bge_ring_data *)kva;

	bzero(sc->bge_rdata, sizeof(struct bge_ring_data));

	/* Set default tuneable values. */
	sc->bge_stat_ticks = BGE_TICKS_PER_SEC;
	sc->bge_rx_coal_ticks = 150;
	sc->bge_rx_max_coal_bds = 64;
	sc->bge_tx_coal_ticks = 300;
	sc->bge_tx_max_coal_bds = 400;

	/* 5705 limits RX return ring to 512 entries. */
	if (BGE_IS_5700_FAMILY(sc) || BGE_IS_5717_PLUS(sc))
		sc->bge_return_ring_cnt = BGE_RETURN_RING_CNT;
	else
		sc->bge_return_ring_cnt = BGE_RETURN_RING_CNT_5705;

	/* Set up ifnet structure */
	ifp = &sc->arpcom.ac_if;
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_xflags = IFXF_MPSAFE;
	ifp->if_ioctl = bge_ioctl;
	ifp->if_qstart = bge_start;
	ifp->if_watchdog = bge_watchdog;
	IFQ_SET_MAXLEN(&ifp->if_snd, BGE_TX_RING_CNT - 1);

	DPRINTFN(5, ("bcopy\n"));
	bcopy(sc->bge_dev.dv_xname, ifp->if_xname, IFNAMSIZ);

	ifp->if_capabilities = IFCAP_VLAN_MTU;

#if NVLAN > 0
	ifp->if_capabilities |= IFCAP_VLAN_HWTAGGING;
#endif

	/*
	 * 5700 B0 chips do not support checksumming correctly due
	 * to hardware bugs.
	 *
	 * It seems all controllers have a bug that can generate UDP
	 * datagrams with a checksum value 0 when TX UDP checksum     
	 * offloading is enabled. Generating UDP checksum value 0 is
	 * a violation of RFC 768.
	 */
	if (sc->bge_chipid != BGE_CHIPID_BCM5700_B0)
		ifp->if_capabilities |= IFCAP_CSUM_IPv4 | IFCAP_CSUM_TCPv4;

	if (BGE_IS_JUMBO_CAPABLE(sc))
		ifp->if_hardmtu = BGE_JUMBO_MTU;

	/*
	 * Do MII setup.
	 */
	DPRINTFN(5, ("mii setup\n"));
	sc->bge_mii.mii_ifp = ifp;
	sc->bge_mii.mii_readreg = bge_miibus_readreg;
	sc->bge_mii.mii_writereg = bge_miibus_writereg;
	sc->bge_mii.mii_statchg = bge_miibus_statchg;

	/*
	 * Figure out what sort of media we have by checking the hardware
	 * config word in the first 32K of internal NIC memory, or fall back to
	 * examining the EEPROM if necessary.  Note: on some BCM5700 cards,
	 * this value seems to be unset. If that's the case, we have to rely on
	 * identifying the NIC by its PCI subsystem ID, as we do below for the
	 * SysKonnect SK-9D41.
	 */
	if (bge_readmem_ind(sc, BGE_SOFTWARE_GENCOMM_SIG) == BGE_MAGIC_NUMBER)
		hwcfg = bge_readmem_ind(sc, BGE_SOFTWARE_GENCOMM_NICCFG);
	else if (!(sc->bge_flags & BGE_NO_EEPROM)) {
		if (bge_read_eeprom(sc, (caddr_t)&hwcfg, BGE_EE_HWCFG_OFFSET,
		    sizeof(hwcfg))) {
			printf(": failed to read media type\n");
			goto fail_6;
		}
		hwcfg = ntohl(hwcfg);
	}

	/* The SysKonnect SK-9D41 is a 1000baseSX card. */
	if (PCI_PRODUCT(subid) == SK_SUBSYSID_9D41 ||
	    (hwcfg & BGE_HWCFG_MEDIA) == BGE_MEDIA_FIBER) {
		if (BGE_IS_5700_FAMILY(sc))
		    sc->bge_flags |= BGE_FIBER_TBI;
		else
		    sc->bge_flags |= BGE_FIBER_MII;
	}

	/* Take advantage of single-shot MSI. */
	if (BGE_IS_5755_PLUS(sc) && sc->bge_flags & BGE_MSI)
		CSR_WRITE_4(sc, BGE_MSI_MODE, CSR_READ_4(sc, BGE_MSI_MODE) &
		    ~BGE_MSIMODE_ONE_SHOT_DISABLE);

	/* Hookup IRQ last. */
	DPRINTFN(5, ("pci_intr_establish\n"));
	sc->bge_intrhand = pci_intr_establish(pc, ih, IPL_NET | IPL_MPSAFE,
	    bge_intr, sc, sc->bge_dev.dv_xname);
	if (sc->bge_intrhand == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail_6;
	}

	/*
	 * A Broadcom chip was detected. Inform the world.
	 */
	printf(": %s, address %s\n", intrstr,
	    ether_sprintf(sc->arpcom.ac_enaddr));

	if (sc->bge_flags & BGE_FIBER_TBI) {
		ifmedia_init(&sc->bge_ifmedia, IFM_IMASK, bge_ifmedia_upd,
		    bge_ifmedia_sts);
		ifmedia_add(&sc->bge_ifmedia, IFM_ETHER|IFM_1000_SX, 0, NULL);
		ifmedia_add(&sc->bge_ifmedia, IFM_ETHER|IFM_1000_SX|IFM_FDX,
			    0, NULL);
		ifmedia_add(&sc->bge_ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);
		ifmedia_set(&sc->bge_ifmedia, IFM_ETHER|IFM_AUTO);
		sc->bge_ifmedia.ifm_media = sc->bge_ifmedia.ifm_cur->ifm_media;
	} else {
		int mii_flags;

		/*
		 * Do transceiver setup.
		 */
		ifmedia_init(&sc->bge_mii.mii_media, 0, bge_ifmedia_upd,
			     bge_ifmedia_sts);
		mii_flags = MIIF_DOPAUSE;
		if (sc->bge_flags & BGE_FIBER_MII)
			mii_flags |= MIIF_HAVEFIBER;
		mii_attach(&sc->bge_dev, &sc->bge_mii, 0xffffffff,
		    sc->bge_phy_addr, MII_OFFSET_ANY, mii_flags);

		if (LIST_FIRST(&sc->bge_mii.mii_phys) == NULL) {
			printf("%s: no PHY found!\n", sc->bge_dev.dv_xname);
			ifmedia_add(&sc->bge_mii.mii_media,
				    IFM_ETHER|IFM_MANUAL, 0, NULL);
			ifmedia_set(&sc->bge_mii.mii_media,
				    IFM_ETHER|IFM_MANUAL);
		} else
			ifmedia_set(&sc->bge_mii.mii_media,
				    IFM_ETHER|IFM_AUTO);
	}

	/*
	 * Call MI attach routine.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

	timeout_set(&sc->bge_timeout, bge_tick, sc);
	timeout_set(&sc->bge_rxtimeout, bge_rxtick, sc);
	timeout_set(&sc->bge_rxtimeout_jumbo, bge_rxtick_jumbo, sc);
	return;

fail_6:
	bus_dmamap_unload(sc->bge_dmatag, sc->bge_ring_map);

fail_5:
	bus_dmamap_destroy(sc->bge_dmatag, sc->bge_ring_map);

fail_4:
	bus_dmamem_unmap(sc->bge_dmatag, (caddr_t)sc->bge_rdata,
	    sizeof(struct bge_ring_data));

fail_3:
	bus_dmamem_free(sc->bge_dmatag, &sc->bge_ring_seg, sc->bge_ring_nseg);

fail_2:
	if ((sc->bge_flags & BGE_APE) != 0)
		bus_space_unmap(sc->bge_apetag, sc->bge_apehandle,
		    sc->bge_apesize);

fail_1:
	bus_space_unmap(sc->bge_btag, sc->bge_bhandle, sc->bge_bsize);
}

int
bge_detach(struct device *self, int flags)
{
	struct bge_softc *sc = (struct bge_softc *)self;
	struct ifnet *ifp = &sc->arpcom.ac_if;

	if (sc->bge_intrhand)
		pci_intr_disestablish(sc->bge_pa.pa_pc, sc->bge_intrhand);

	bge_stop(sc, 1);

	/* Detach any PHYs we might have. */
	if (LIST_FIRST(&sc->bge_mii.mii_phys) != NULL)
		mii_detach(&sc->bge_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	/* Delete any remaining media. */
	ifmedia_delete_instance(&sc->bge_mii.mii_media, IFM_INST_ANY);

	ether_ifdetach(ifp);
	if_detach(ifp);

	bus_dmamap_unload(sc->bge_dmatag, sc->bge_ring_map);
	bus_dmamap_destroy(sc->bge_dmatag, sc->bge_ring_map);
	bus_dmamem_unmap(sc->bge_dmatag, (caddr_t)sc->bge_rdata,
	    sizeof(struct bge_ring_data));
	bus_dmamem_free(sc->bge_dmatag, &sc->bge_ring_seg, sc->bge_ring_nseg);

	if ((sc->bge_flags & BGE_APE) != 0)
		bus_space_unmap(sc->bge_apetag, sc->bge_apehandle,
		    sc->bge_apesize);

	bus_space_unmap(sc->bge_btag, sc->bge_bhandle, sc->bge_bsize);
	return (0);
}

int
bge_activate(struct device *self, int act)
{
	struct bge_softc *sc = (struct bge_softc *)self;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	int rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);
		if (ifp->if_flags & IFF_RUNNING)
			bge_stop(sc, 0);
		break;
	case DVACT_RESUME:
		if (ifp->if_flags & IFF_UP)
			bge_init(sc);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

void
bge_reset(struct bge_softc *sc)
{
	struct pci_attach_args *pa = &sc->bge_pa;
	pcireg_t cachesize, command, devctl;
	u_int32_t reset, mac_mode, mac_mode_mask, val;
	void (*write_op)(struct bge_softc *, int, int);
	int i;

	mac_mode_mask = BGE_MACMODE_HALF_DUPLEX | BGE_MACMODE_PORTMODE;
	if ((sc->bge_mfw_flags & BGE_MFW_ON_APE) != 0)
		mac_mode_mask |= BGE_MACMODE_APE_RX_EN | BGE_MACMODE_APE_TX_EN;
	mac_mode = CSR_READ_4(sc, BGE_MAC_MODE) & mac_mode_mask;

	if (BGE_IS_575X_PLUS(sc) && !BGE_IS_5714_FAMILY(sc) &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5906) {
		if (sc->bge_flags & BGE_PCIE)
			write_op = bge_writembx;
		else
			write_op = bge_writemem_ind;
	} else
		write_op = bge_writereg_ind;

	/* Take APE lock when performing reset. */
	bge_ape_lock(sc, BGE_APE_LOCK_GRC);

	/* Save some important PCI state. */
	cachesize = pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_CACHESZ);
	command = pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_CMD);

	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MISC_CTL,
	    BGE_PCIMISCCTL_INDIRECT_ACCESS | BGE_PCIMISCCTL_MASK_PCI_INTR |
	    BGE_PCIMISCCTL_ENDIAN_WORDSWAP | BGE_PCIMISCCTL_PCISTATE_RW);

	/* Disable fastboot on controllers that support it. */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5752 ||
	    BGE_IS_5755_PLUS(sc))
		CSR_WRITE_4(sc, BGE_FASTBOOT_PC, 0);

	/*
	 * Write the magic number to SRAM at offset 0xB50.
	 * When firmware finishes its initialization it will
	 * write ~BGE_SRAM_FW_MB_MAGIC to the same location.
	 */
	bge_writemem_ind(sc, BGE_SOFTWARE_GENCOMM, BGE_MAGIC_NUMBER);

	reset = BGE_MISCCFG_RESET_CORE_CLOCKS | BGE_32BITTIME_66MHZ;

	if (sc->bge_flags & BGE_PCIE) {
		if (BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5785 &&
		    !BGE_IS_5717_PLUS(sc)) {
			if (CSR_READ_4(sc, 0x7e2c) == 0x60) {
				/* PCI Express 1.0 system */
				CSR_WRITE_4(sc, 0x7e2c, 0x20);
			}
		}
		if (sc->bge_chipid != BGE_CHIPID_BCM5750_A0) {
			/*
			 * Prevent PCI Express link training
			 * during global reset.
			 */
			CSR_WRITE_4(sc, BGE_MISC_CFG, (1<<29));
			reset |= (1<<29);
		}
	}

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906) {
		val = CSR_READ_4(sc, BGE_VCPU_STATUS);
		CSR_WRITE_4(sc, BGE_VCPU_STATUS,
		    val | BGE_VCPU_STATUS_DRV_RESET);
                val = CSR_READ_4(sc, BGE_VCPU_EXT_CTRL);
                CSR_WRITE_4(sc, BGE_VCPU_EXT_CTRL,
                    val & ~BGE_VCPU_EXT_CTRL_HALT_CPU);

                sc->bge_flags |= BGE_NO_EEPROM;
        }

	/*
	 * Set GPHY Power Down Override to leave GPHY
	 * powered up in D0 uninitialized.
	 */
	if (BGE_IS_5705_PLUS(sc) &&
	    (sc->bge_flags & BGE_CPMU_PRESENT) == 0)
		reset |= BGE_MISCCFG_KEEP_GPHY_POWER;

	/* Issue global reset */
	write_op(sc, BGE_MISC_CFG, reset);

	if (sc->bge_flags & BGE_PCIE)
		DELAY(100 * 1000);
	else
		DELAY(1000);

	if (sc->bge_flags & BGE_PCIE) {
		if (sc->bge_chipid == BGE_CHIPID_BCM5750_A0) {
			pcireg_t v;

			DELAY(500000); /* wait for link training to complete */
			v = pci_conf_read(pa->pa_pc, pa->pa_tag, 0xc4);
			pci_conf_write(pa->pa_pc, pa->pa_tag, 0xc4, v | (1<<15));
		}

		devctl = pci_conf_read(pa->pa_pc, pa->pa_tag, sc->bge_expcap +
		    PCI_PCIE_DCSR);
		/* Clear enable no snoop and disable relaxed ordering. */
		devctl &= ~(PCI_PCIE_DCSR_ERO | PCI_PCIE_DCSR_ENS);
		/* Set PCI Express max payload size. */
		devctl = (devctl & ~PCI_PCIE_DCSR_MPS) | sc->bge_expmrq;
		/* Clear error status. */
		devctl |= PCI_PCIE_DCSR_CEE | PCI_PCIE_DCSR_NFE |
		    PCI_PCIE_DCSR_FEE | PCI_PCIE_DCSR_URE;
		pci_conf_write(pa->pa_pc, pa->pa_tag, sc->bge_expcap +
		    PCI_PCIE_DCSR, devctl);
	}

	/* Reset some of the PCI state that got zapped by reset */
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MISC_CTL,
	    BGE_PCIMISCCTL_INDIRECT_ACCESS | BGE_PCIMISCCTL_MASK_PCI_INTR |
	    BGE_PCIMISCCTL_ENDIAN_WORDSWAP | BGE_PCIMISCCTL_PCISTATE_RW);
	val = BGE_PCISTATE_ROM_ENABLE | BGE_PCISTATE_ROM_RETRY_ENABLE;
	if (sc->bge_chipid == BGE_CHIPID_BCM5704_A0 &&
	    (sc->bge_flags & BGE_PCIX) != 0)
		val |= BGE_PCISTATE_RETRY_SAME_DMA;
	if ((sc->bge_mfw_flags & BGE_MFW_ON_APE) != 0)
		val |= BGE_PCISTATE_ALLOW_APE_CTLSPC_WR |
		    BGE_PCISTATE_ALLOW_APE_SHMEM_WR |
		    BGE_PCISTATE_ALLOW_APE_PSPACE_WR;
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE, val);
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_CACHESZ, cachesize);
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_CMD, command);

	/* Re-enable MSI, if necessary, and enable memory arbiter. */
	if (BGE_IS_5714_FAMILY(sc)) {
		/* This chip disables MSI on reset. */
		if (sc->bge_flags & BGE_MSI) {
			val = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    sc->bge_msicap + PCI_MSI_MC);
			pci_conf_write(pa->pa_pc, pa->pa_tag,
			    sc->bge_msicap + PCI_MSI_MC,
			    val | PCI_MSI_MC_MSIE);
			val = CSR_READ_4(sc, BGE_MSI_MODE);
			CSR_WRITE_4(sc, BGE_MSI_MODE,
			    val | BGE_MSIMODE_ENABLE);
		}
		val = CSR_READ_4(sc, BGE_MARB_MODE);
		CSR_WRITE_4(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE | val);
	} else
		CSR_WRITE_4(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE);

	/* Fix up byte swapping */
	CSR_WRITE_4(sc, BGE_MODE_CTL, bge_dma_swap_options(sc));

	val = CSR_READ_4(sc, BGE_MAC_MODE);
	val = (val & ~mac_mode_mask) | mac_mode;
	CSR_WRITE_4(sc, BGE_MAC_MODE, val);
	DELAY(40);

	bge_ape_unlock(sc, BGE_APE_LOCK_GRC);

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906) {
		for (i = 0; i < BGE_TIMEOUT; i++) {
			val = CSR_READ_4(sc, BGE_VCPU_STATUS);
			if (val & BGE_VCPU_STATUS_INIT_DONE)
				break;
			DELAY(100);
		}

		if (i >= BGE_TIMEOUT)
			printf("%s: reset timed out\n", sc->bge_dev.dv_xname);
	} else {
		/*
		 * Poll until we see 1's complement of the magic number.
		 * This indicates that the firmware initialization
		 * is complete.  We expect this to fail if no SEEPROM
		 * is fitted.
		 */
		for (i = 0; i < BGE_TIMEOUT * 10; i++) {
			val = bge_readmem_ind(sc, BGE_SOFTWARE_GENCOMM);
			if (val == ~BGE_MAGIC_NUMBER)
				break;
			DELAY(10);
		}

		if ((i >= BGE_TIMEOUT * 10) &&
		    (!(sc->bge_flags & BGE_NO_EEPROM)))
			printf("%s: firmware handshake timed out\n",
			   sc->bge_dev.dv_xname);
		/* BCM57765 A0 needs additional time before accessing. */
		if (sc->bge_chipid == BGE_CHIPID_BCM57765_A0)
			DELAY(10 * 1000);       /* XXX */
	}

	/*
	 * The 5704 in TBI mode apparently needs some special
	 * adjustment to ensure the SERDES drive level is set
	 * to 1.2V.
	 */
	if (sc->bge_flags & BGE_FIBER_TBI &&
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704) {
		val = CSR_READ_4(sc, BGE_SERDES_CFG);
		val = (val & ~0xFFF) | 0x880;
		CSR_WRITE_4(sc, BGE_SERDES_CFG, val);
	}

	if (sc->bge_flags & BGE_PCIE &&
	    !BGE_IS_5717_PLUS(sc) &&
	    sc->bge_chipid != BGE_CHIPID_BCM5750_A0 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5785) {
		/* Enable Data FIFO protection. */
		val = CSR_READ_4(sc, 0x7c00);
		CSR_WRITE_4(sc, 0x7c00, val | (1<<25));
	}

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720)
		BGE_CLRBIT(sc, BGE_CPMU_CLCK_ORIDE,
		    CPMU_CLCK_ORIDE_MAC_ORIDE_EN);
}

/*
 * Frame reception handling. This is called if there's a frame
 * on the receive return list.
 *
 * Note: we have to be able to handle two possibilities here:
 * 1) the frame is from the jumbo receive ring
 * 2) the frame is from the standard receive ring
 */

void
bge_rxeof(struct bge_softc *sc)
{
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct ifnet *ifp;
	uint16_t rx_prod, rx_cons;
	int stdcnt = 0, jumbocnt = 0;
	bus_dmamap_t dmamap;
	bus_addr_t offset, toff;
	bus_size_t tlen;
	int tosync;

	rx_cons = sc->bge_rx_saved_considx;
	rx_prod = sc->bge_rdata->bge_status_block.bge_idx[0].bge_rx_prod_idx;

	/* Nothing to do */
	if (rx_cons == rx_prod)
		return;

	ifp = &sc->arpcom.ac_if;

	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_status_block),
	    sizeof (struct bge_status_block),
	    BUS_DMASYNC_POSTREAD);

	offset = offsetof(struct bge_ring_data, bge_rx_return_ring);
	tosync = rx_prod - rx_cons;

	toff = offset + (rx_cons * sizeof (struct bge_rx_bd));

	if (tosync < 0) {
		tlen = (sc->bge_return_ring_cnt - rx_cons) *
		    sizeof (struct bge_rx_bd);
		bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
		    toff, tlen, BUS_DMASYNC_POSTREAD);
		tosync = -tosync;
	}

	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offset, tosync * sizeof (struct bge_rx_bd),
	    BUS_DMASYNC_POSTREAD);

	while (rx_cons != rx_prod) {
		struct bge_rx_bd	*cur_rx;
		u_int32_t		rxidx;
		struct mbuf		*m = NULL;

		cur_rx = &sc->bge_rdata->bge_rx_return_ring[rx_cons];

		rxidx = cur_rx->bge_idx;
		BGE_INC(rx_cons, sc->bge_return_ring_cnt);

		if (cur_rx->bge_flags & BGE_RXBDFLAG_JUMBO_RING) {
			m = sc->bge_cdata.bge_rx_jumbo_chain[rxidx];
			sc->bge_cdata.bge_rx_jumbo_chain[rxidx] = NULL;

			jumbocnt++;

			dmamap = sc->bge_cdata.bge_rx_jumbo_map[rxidx];
			bus_dmamap_sync(sc->bge_dmatag, dmamap, 0,
			    dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->bge_dmatag, dmamap);

			if (cur_rx->bge_flags & BGE_RXBDFLAG_ERROR) {
				m_freem(m);
				continue;
			}
		} else {
			m = sc->bge_cdata.bge_rx_std_chain[rxidx];
			sc->bge_cdata.bge_rx_std_chain[rxidx] = NULL;

			stdcnt++;

			dmamap = sc->bge_cdata.bge_rx_std_map[rxidx];
			bus_dmamap_sync(sc->bge_dmatag, dmamap, 0,
			    dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->bge_dmatag, dmamap);

			if (cur_rx->bge_flags & BGE_RXBDFLAG_ERROR) {
				m_freem(m);
				continue;
			}
		}

#ifdef __STRICT_ALIGNMENT
		/*
		 * The i386 allows unaligned accesses, but for other
		 * platforms we must make sure the payload is aligned.
		 */
		if (sc->bge_flags & BGE_RX_ALIGNBUG) {
			bcopy(m->m_data, m->m_data + ETHER_ALIGN,
			    cur_rx->bge_len);
			m->m_data += ETHER_ALIGN;
		}
#endif
		m->m_pkthdr.len = m->m_len = cur_rx->bge_len - ETHER_CRC_LEN;

		bge_rxcsum(sc, cur_rx, m);

#if NVLAN > 0
		if (ifp->if_capabilities & IFCAP_VLAN_HWTAGGING &&
		    cur_rx->bge_flags & BGE_RXBDFLAG_VLAN_TAG) {
			m->m_pkthdr.ether_vtag = cur_rx->bge_vlan_tag;
			m->m_flags |= M_VLANTAG;
		}
#endif

		ml_enqueue(&ml, m);
	}

	sc->bge_rx_saved_considx = rx_cons;
	bge_writembx(sc, BGE_MBX_RX_CONS0_LO, sc->bge_rx_saved_considx);
	if (stdcnt) {
		if_rxr_put(&sc->bge_std_ring, stdcnt);
		bge_fill_rx_ring_std(sc);
	}
	if (jumbocnt) {
		if_rxr_put(&sc->bge_jumbo_ring, jumbocnt);
		bge_fill_rx_ring_jumbo(sc);
	}

	if_input(ifp, &ml);
}

void
bge_rxcsum(struct bge_softc *sc, struct bge_rx_bd *cur_rx, struct mbuf *m)
{
	if (sc->bge_chipid == BGE_CHIPID_BCM5700_B0) {
		/*
		 * 5700 B0 chips do not support checksumming correctly due
		 * to hardware bugs.
		 */
		return;
	} else if (BGE_IS_5717_PLUS(sc)) {
		if ((cur_rx->bge_flags & BGE_RXBDFLAG_IPV6) == 0) {
			if (cur_rx->bge_flags & BGE_RXBDFLAG_IP_CSUM &&
			    (cur_rx->bge_error_flag &
			    BGE_RXERRFLAG_IP_CSUM_NOK) == 0)
				m->m_pkthdr.csum_flags |= M_IPV4_CSUM_IN_OK;

			if (cur_rx->bge_flags & BGE_RXBDFLAG_TCP_UDP_CSUM) {
				m->m_pkthdr.csum_flags |=
				    M_TCP_CSUM_IN_OK|M_UDP_CSUM_IN_OK;
                        }
                }
        } else {
		if (cur_rx->bge_flags & BGE_RXBDFLAG_IP_CSUM &&
		    cur_rx->bge_ip_csum == 0xFFFF)
			m->m_pkthdr.csum_flags |= M_IPV4_CSUM_IN_OK;

		if (cur_rx->bge_flags & BGE_RXBDFLAG_TCP_UDP_CSUM &&
		    m->m_pkthdr.len >= ETHER_MIN_NOPAD &&
		    cur_rx->bge_tcp_udp_csum == 0xFFFF) {
			m->m_pkthdr.csum_flags |=
			    M_TCP_CSUM_IN_OK|M_UDP_CSUM_IN_OK;
		}
	}
}

void
bge_txeof(struct bge_softc *sc)
{
	struct bge_tx_bd *cur_tx = NULL;
	struct ifnet *ifp;
	bus_dmamap_t dmamap;
	bus_addr_t offset, toff;
	bus_size_t tlen;
	int tosync, freed, txcnt;
	u_int32_t cons, newcons;
	struct mbuf *m;

	/* Nothing to do */
	cons = sc->bge_tx_saved_considx; 
	newcons = sc->bge_rdata->bge_status_block.bge_idx[0].bge_tx_cons_idx;
	if (cons == newcons)
		return;

	ifp = &sc->arpcom.ac_if;

	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_status_block),
	    sizeof (struct bge_status_block),
	    BUS_DMASYNC_POSTREAD);

	offset = offsetof(struct bge_ring_data, bge_tx_ring);
	tosync = newcons - cons;

	toff = offset + (cons * sizeof (struct bge_tx_bd));

	if (tosync < 0) {
		tlen = (BGE_TX_RING_CNT - cons) * sizeof (struct bge_tx_bd);
		bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
		    toff, tlen, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
		tosync = -tosync;
	}

	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offset, tosync * sizeof (struct bge_tx_bd),
	    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);

	/*
	 * Go through our tx ring and free mbufs for those
	 * frames that have been sent.
	 */
	freed = 0;
	while (cons != newcons) {
		cur_tx = &sc->bge_rdata->bge_tx_ring[cons];
		m = sc->bge_cdata.bge_tx_chain[cons];
		if (m != NULL) {
			dmamap = sc->bge_cdata.bge_tx_map[cons];

			sc->bge_cdata.bge_tx_chain[cons] = NULL;
			sc->bge_cdata.bge_tx_map[cons] = NULL;
			bus_dmamap_sync(sc->bge_dmatag, dmamap, 0,
			    dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->bge_dmatag, dmamap);

			m_freem(m);
		}
		freed++;
		BGE_INC(cons, BGE_TX_RING_CNT);
	}

	txcnt = atomic_sub_int_nv(&sc->bge_txcnt, freed);

	sc->bge_tx_saved_considx = cons;

	if (ifq_is_oactive(&ifp->if_snd))
		ifq_restart(&ifp->if_snd);
	else if (txcnt == 0)
		ifp->if_timer = 0;
}

int
bge_intr(void *xsc)
{
	struct bge_softc *sc;
	struct ifnet *ifp;
	u_int32_t statusword, statustag;

	sc = xsc;
	ifp = &sc->arpcom.ac_if;

	/* read status word from status block */
	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_status_block),
	    sizeof (struct bge_status_block),
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

	statusword = sc->bge_rdata->bge_status_block.bge_status;
	statustag = sc->bge_rdata->bge_status_block.bge_status_tag << 24;

	if (sc->bge_flags & BGE_TAGGED_STATUS) {
		if (sc->bge_lasttag == statustag &&
		    (CSR_READ_4(sc, BGE_PCI_PCISTATE) &
		     BGE_PCISTATE_INTR_NOT_ACTIVE))
			return (0);
		sc->bge_lasttag = statustag;
	} else {
		if (!(statusword & BGE_STATFLAG_UPDATED) &&
		    (CSR_READ_4(sc, BGE_PCI_PCISTATE) &
		     BGE_PCISTATE_INTR_NOT_ACTIVE))
			return (0);
		/* Ack interrupt and stop others from occurring. */
		bge_writembx(sc, BGE_MBX_IRQ0_LO, 1);
		statustag = 0;
	}

	/* clear status word */
	sc->bge_rdata->bge_status_block.bge_status = 0;

	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_status_block),
	    sizeof (struct bge_status_block),
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
	    statusword & BGE_STATFLAG_LINKSTATE_CHANGED ||
	    BGE_STS_BIT(sc, BGE_STS_LINK_EVT)) {
		KERNEL_LOCK();
		bge_link_upd(sc);
		KERNEL_UNLOCK();
	}

	/* Re-enable interrupts. */
	bge_writembx(sc, BGE_MBX_IRQ0_LO, statustag);

	if (ifp->if_flags & IFF_RUNNING) {
		/* Check RX return ring producer/consumer */
		bge_rxeof(sc);

		/* Check TX ring producer/consumer */
		bge_txeof(sc);
	}

	return (1);
}

void
bge_tick(void *xsc)
{
	struct bge_softc *sc = xsc;
	struct mii_data *mii = &sc->bge_mii;
	int s;

	s = splnet();

	if (BGE_IS_5705_PLUS(sc))
		bge_stats_update_regs(sc);
	else
		bge_stats_update(sc);

	if (sc->bge_flags & BGE_FIBER_TBI) {
		/*
		 * Since in TBI mode auto-polling can't be used we should poll
		 * link status manually. Here we register pending link event
		 * and trigger interrupt.
		 */
		BGE_STS_SETBIT(sc, BGE_STS_LINK_EVT);
		BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_INTR_SET);
	} else {
		/*
		 * Do not touch PHY if we have link up. This could break
		 * IPMI/ASF mode or produce extra input errors.
		 * (extra input errors was reported for bcm5701 & bcm5704).
		 */
		if (!BGE_STS_BIT(sc, BGE_STS_LINK))
			mii_tick(mii);
	}

	timeout_add_sec(&sc->bge_timeout, 1);

	splx(s);
}

void
bge_stats_update_regs(struct bge_softc *sc)
{
	struct ifnet *ifp = &sc->arpcom.ac_if;

	sc->bge_tx_collisions += CSR_READ_4(sc, BGE_MAC_STATS +
	    offsetof(struct bge_mac_stats_regs, etherStatsCollisions));

	sc->bge_rx_overruns += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_OUT_OF_BDS);

	/*
	 * XXX
	 * Unlike other controllers, the BGE_RXLP_LOCSTAT_IFIN_DROPS counter
	 * of the BCM5717, BCM5718, BCM5762, BCM5719 A0 and BCM5720 A0
	 * controllers includes the number of unwanted multicast frames.
	 * This comes from a silicon bug and known workaround to get rough
	 * (not exact) counter is to enable interrupt on MBUF low watermark
	 * attention. This can be accomplished by setting BGE_HCCMODE_ATTN
	 * bit of BGE_HDD_MODE, BGE_BMANMODE_LOMBUF_ATTN bit of BGE_BMAN_MODE
	 * and BGE_MODECTL_FLOWCTL_ATTN_INTR bit of BGE_MODE_CTL. However
	 * that change would generate more interrupts and there are still
	 * possibilities of losing multiple frames during 
	 * BGE_MODECTL_FLOWCTL_ATTN_INTR interrupt handling. Given that
	 * the workaround still would not get correct counter I don't think
	 * it's worth to implement it. So ignore reading the counter on
	 * controllers that have the silicon bug.
	 */
	if (BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5717 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5762 &&
	    sc->bge_chipid != BGE_CHIPID_BCM5719_A0 &&
	    sc->bge_chipid != BGE_CHIPID_BCM5720_A0)
		sc->bge_rx_discards += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_IFIN_DROPS);

	sc->bge_rx_inerrors += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_IFIN_ERRORS);

	ifp->if_collisions = sc->bge_tx_collisions;
	ifp->if_ierrors = sc->bge_rx_discards + sc->bge_rx_inerrors;

	if (sc->bge_flags & BGE_RDMA_BUG) {
		u_int32_t val, ucast, mcast, bcast;

		ucast = CSR_READ_4(sc, BGE_MAC_STATS +
		    offsetof(struct bge_mac_stats_regs, ifHCOutUcastPkts));
		mcast = CSR_READ_4(sc, BGE_MAC_STATS +
		    offsetof(struct bge_mac_stats_regs, ifHCOutMulticastPkts));
		bcast = CSR_READ_4(sc, BGE_MAC_STATS +
		    offsetof(struct bge_mac_stats_regs, ifHCOutBroadcastPkts));

		/*
		 * If controller transmitted more than BGE_NUM_RDMA_CHANNELS
		 * frames, it's safe to disable workaround for DMA engine's
		 * miscalculation of TXMBUF space.
		 */
		if (ucast + mcast + bcast > BGE_NUM_RDMA_CHANNELS) {
			val = CSR_READ_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL);
			if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719)
				val &= ~BGE_RDMA_TX_LENGTH_WA_5719;
			else
				val &= ~BGE_RDMA_TX_LENGTH_WA_5720;
			CSR_WRITE_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL, val);
			sc->bge_flags &= ~BGE_RDMA_BUG;
		}
	}
}

void
bge_stats_update(struct bge_softc *sc)
{
	struct ifnet *ifp = &sc->arpcom.ac_if;
	bus_size_t stats = BGE_MEMWIN_START + BGE_STATS_BLOCK;
	u_int32_t cnt;

#define READ_STAT(sc, stats, stat) \
	  CSR_READ_4(sc, stats + offsetof(struct bge_stats, stat))

	cnt = READ_STAT(sc, stats, txstats.etherStatsCollisions.bge_addr_lo);
	ifp->if_collisions += (u_int32_t)(cnt - sc->bge_tx_collisions);
	sc->bge_tx_collisions = cnt;

	cnt = READ_STAT(sc, stats, nicNoMoreRxBDs.bge_addr_lo);
	sc->bge_rx_overruns = cnt;
	cnt = READ_STAT(sc, stats, ifInErrors.bge_addr_lo);
	ifp->if_ierrors += (uint32_t)(cnt - sc->bge_rx_inerrors);
	sc->bge_rx_inerrors = cnt;
	cnt = READ_STAT(sc, stats, ifInDiscards.bge_addr_lo);
	ifp->if_ierrors += (u_int32_t)(cnt - sc->bge_rx_discards);
	sc->bge_rx_discards = cnt;

	cnt = READ_STAT(sc, stats, txstats.ifOutDiscards.bge_addr_lo);
	ifp->if_oerrors += (u_int32_t)(cnt - sc->bge_tx_discards);
	sc->bge_tx_discards = cnt;

#undef READ_STAT
}

/*
 * Compact outbound packets to avoid bug with DMA segments less than 8 bytes.
 */
int
bge_compact_dma_runt(struct mbuf *pkt)
{
	struct mbuf	*m, *prev, *n = NULL;
	int 		totlen, newprevlen;

	prev = NULL;
	totlen = 0;

	for (m = pkt; m != NULL; prev = m,m = m->m_next) {
		int mlen = m->m_len;
		int shortfall = 8 - mlen ;

		totlen += mlen;
		if (mlen == 0)
			continue;
		if (mlen >= 8)
			continue;

		/* If we get here, mbuf data is too small for DMA engine.
		 * Try to fix by shuffling data to prev or next in chain.
		 * If that fails, do a compacting deep-copy of the whole chain.
		 */

		/* Internal frag. If fits in prev, copy it there. */
		if (prev && M_TRAILINGSPACE(prev) >= m->m_len) {
			bcopy(m->m_data, prev->m_data+prev->m_len, mlen);
			prev->m_len += mlen;
			m->m_len = 0;
			/* XXX stitch chain */
			prev->m_next = m_free(m);
			m = prev;
			continue;
		} else if (m->m_next != NULL &&
			   M_TRAILINGSPACE(m) >= shortfall &&
			   m->m_next->m_len >= (8 + shortfall)) {
			/* m is writable and have enough data in next, pull up. */

			bcopy(m->m_next->m_data, m->m_data+m->m_len, shortfall);
			m->m_len += shortfall;
			m->m_next->m_len -= shortfall;
			m->m_next->m_data += shortfall;
		} else if (m->m_next == NULL || 1) {
			/* Got a runt at the very end of the packet.
			 * borrow data from the tail of the preceding mbuf and
			 * update its length in-place. (The original data is still
			 * valid, so we can do this even if prev is not writable.)
			 */

			/* if we'd make prev a runt, just move all of its data. */
#ifdef DEBUG
			KASSERT(prev != NULL /*, ("runt but null PREV")*/);
			KASSERT(prev->m_len >= 8 /*, ("runt prev")*/);
#endif
			if ((prev->m_len - shortfall) < 8)
				shortfall = prev->m_len;

			newprevlen = prev->m_len - shortfall;

			MGET(n, M_NOWAIT, MT_DATA);
			if (n == NULL)
				return (ENOBUFS);
			KASSERT(m->m_len + shortfall < MLEN
				/*,
				  ("runt %d +prev %d too big\n", m->m_len, shortfall)*/);

			/* first copy the data we're stealing from prev */
			bcopy(prev->m_data + newprevlen, n->m_data, shortfall);

			/* update prev->m_len accordingly */
			prev->m_len -= shortfall;

			/* copy data from runt m */
			bcopy(m->m_data, n->m_data + shortfall, m->m_len);

			/* n holds what we stole from prev, plus m */
			n->m_len = shortfall + m->m_len;

			/* stitch n into chain and free m */
			n->m_next = m->m_next;
			prev->m_next = n;
			/* KASSERT(m->m_next == NULL); */
			m->m_next = NULL;
			m_free(m);
			m = n;	/* for continuing loop */
		}
	}
	return (0);
}

/*
 * Pad outbound frame to ETHER_MIN_NOPAD for an unusual reason.
 * The bge hardware will pad out Tx runts to ETHER_MIN_NOPAD,
 * but when such padded frames employ the bge IP/TCP checksum offload,
 * the hardware checksum assist gives incorrect results (possibly
 * from incorporating its own padding into the UDP/TCP checksum; who knows).
 * If we pad such runts with zeros, the onboard checksum comes out correct.
 */
int
bge_cksum_pad(struct mbuf *m)
{
	int padlen = ETHER_MIN_NOPAD - m->m_pkthdr.len;
	struct mbuf *last;

	/* If there's only the packet-header and we can pad there, use it. */
	if (m->m_pkthdr.len == m->m_len && M_TRAILINGSPACE(m) >= padlen) {
		last = m;
	} else {
		/*
		 * Walk packet chain to find last mbuf. We will either
		 * pad there, or append a new mbuf and pad it.
		 */
		for (last = m; last->m_next != NULL; last = last->m_next);
		if (M_TRAILINGSPACE(last) < padlen) {
			/* Allocate new empty mbuf, pad it. Compact later. */
			struct mbuf *n;

			MGET(n, M_DONTWAIT, MT_DATA);
			if (n == NULL)
				return (ENOBUFS);
			n->m_len = 0;
			last->m_next = n;
			last = n;
		}
	}
	
	/* Now zero the pad area, to avoid the bge cksum-assist bug. */
	memset(mtod(last, caddr_t) + last->m_len, 0, padlen);
	last->m_len += padlen;
	m->m_pkthdr.len += padlen;

	return (0);
}

/*
 * Encapsulate an mbuf chain in the tx ring by coupling the mbuf data
 * pointers to descriptors.
 */
int
bge_encap(struct bge_softc *sc, struct mbuf *m, int *txinc)
{
	struct bge_tx_bd	*f = NULL;
	u_int32_t		frag, cur;
	u_int16_t		csum_flags = 0;
	bus_dmamap_t		dmamap;
	int			i = 0;

	cur = frag = (sc->bge_tx_prodidx + *txinc) % BGE_TX_RING_CNT;

	if (m->m_pkthdr.csum_flags) {
		if (m->m_pkthdr.csum_flags & M_IPV4_CSUM_OUT)
			csum_flags |= BGE_TXBDFLAG_IP_CSUM;
		if (m->m_pkthdr.csum_flags &
		    (M_TCP_CSUM_OUT | M_UDP_CSUM_OUT)) {
			csum_flags |= BGE_TXBDFLAG_TCP_UDP_CSUM;
			if (m->m_pkthdr.len < ETHER_MIN_NOPAD &&
			    bge_cksum_pad(m) != 0)
				return (ENOBUFS);
		}
	}

	if (sc->bge_flags & BGE_JUMBO_FRAME && 
	    m->m_pkthdr.len > ETHER_MAX_LEN)
		csum_flags |= BGE_TXBDFLAG_JUMBO_FRAME;

	if (!(BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5700_BX))
		goto doit;

	/*
	 * bcm5700 Revision B silicon cannot handle DMA descriptors with
	 * less than eight bytes.  If we encounter a teeny mbuf
	 * at the end of a chain, we can pad.  Otherwise, copy.
	 */
	if (bge_compact_dma_runt(m) != 0)
		return (ENOBUFS);

doit:
	dmamap = sc->bge_txdma[cur];

	/*
	 * Start packing the mbufs in this chain into
	 * the fragment pointers. Stop when we run out
	 * of fragments or hit the end of the mbuf chain.
	 */
	switch (bus_dmamap_load_mbuf(sc->bge_dmatag, dmamap, m,
	    BUS_DMA_NOWAIT)) {
	case 0:
		break;
	case EFBIG:
		if (m_defrag(m, M_DONTWAIT) == 0 &&
		    bus_dmamap_load_mbuf(sc->bge_dmatag, dmamap, m,
		     BUS_DMA_NOWAIT) == 0)
			break;

		/* FALLTHROUGH */
	default:
		return (ENOBUFS);
	}

	for (i = 0; i < dmamap->dm_nsegs; i++) {
		f = &sc->bge_rdata->bge_tx_ring[frag];
		if (sc->bge_cdata.bge_tx_chain[frag] != NULL)
			break;
		BGE_HOSTADDR(f->bge_addr, dmamap->dm_segs[i].ds_addr);
		f->bge_len = dmamap->dm_segs[i].ds_len;
		f->bge_flags = csum_flags;
		f->bge_vlan_tag = 0;
#if NVLAN > 0
		if (m->m_flags & M_VLANTAG) {
			f->bge_flags |= BGE_TXBDFLAG_VLAN_TAG;
			f->bge_vlan_tag = m->m_pkthdr.ether_vtag;
		}
#endif
		cur = frag;
		BGE_INC(frag, BGE_TX_RING_CNT);
	}

	if (i < dmamap->dm_nsegs)
		goto fail_unload;

	if (frag == sc->bge_tx_saved_considx)
		goto fail_unload;

	bus_dmamap_sync(sc->bge_dmatag, dmamap, 0, dmamap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	sc->bge_rdata->bge_tx_ring[cur].bge_flags |= BGE_TXBDFLAG_END;
	sc->bge_cdata.bge_tx_chain[cur] = m;
	sc->bge_cdata.bge_tx_map[cur] = dmamap;
	
	*txinc += dmamap->dm_nsegs;

	return (0);

fail_unload:
	bus_dmamap_unload(sc->bge_dmatag, dmamap);

	return (ENOBUFS);
}

/*
 * Main transmit routine. To avoid having to do mbuf copies, we put pointers
 * to the mbuf data regions directly in the transmit descriptors.
 */
void
bge_start(struct ifqueue *ifq)
{
	struct ifnet *ifp = ifq->ifq_if;
	struct bge_softc *sc = ifp->if_softc;
	struct mbuf *m;
	int txinc;

	if (!BGE_STS_BIT(sc, BGE_STS_LINK)) {
		ifq_purge(ifq);
		return;
	}

	txinc = 0;
	while (1) {
		/* Check if we have enough free send BDs. */
		if (sc->bge_txcnt + txinc + BGE_NTXSEG + 16 >=
		    BGE_TX_RING_CNT) {
			ifq_set_oactive(ifq);
			break;
		}

		m = ifq_dequeue(ifq);
		if (m == NULL)
			break;

		if (bge_encap(sc, m, &txinc) != 0) {
			m_freem(m);
			continue;
		}

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
	}

	if (txinc != 0) {
		/* Transmit */
		sc->bge_tx_prodidx = (sc->bge_tx_prodidx + txinc) %
		    BGE_TX_RING_CNT;
		bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, sc->bge_tx_prodidx);
		if (BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5700_BX)
			bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO,
			    sc->bge_tx_prodidx);

		atomic_add_int(&sc->bge_txcnt, txinc);

		/*
		 * Set a timeout in case the chip goes out to lunch.
		 */
		ifp->if_timer = 5;
	}
}

void
bge_init(void *xsc)
{
	struct bge_softc *sc = xsc;
	struct ifnet *ifp;
	u_int16_t *m;
	u_int32_t mode;
	int s;

	s = splnet();

	ifp = &sc->arpcom.ac_if;

	/* Cancel pending I/O and flush buffers. */
	bge_stop(sc, 0);
	bge_sig_pre_reset(sc, BGE_RESET_START);
	bge_reset(sc);
	bge_sig_legacy(sc, BGE_RESET_START);
	bge_sig_post_reset(sc, BGE_RESET_START);

	bge_chipinit(sc);

	/*
	 * Init the various state machines, ring
	 * control blocks and firmware.
	 */
	if (bge_blockinit(sc)) {
		printf("%s: initialization failure\n", sc->bge_dev.dv_xname);
		splx(s);
		return;
	}

	/* Specify MRU. */
	if (BGE_IS_JUMBO_CAPABLE(sc))
		CSR_WRITE_4(sc, BGE_RX_MTU,
			BGE_JUMBO_FRAMELEN + ETHER_VLAN_ENCAP_LEN);
	else
		CSR_WRITE_4(sc, BGE_RX_MTU,
			ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN);

	/* Load our MAC address. */
	m = (u_int16_t *)&sc->arpcom.ac_enaddr[0];
	CSR_WRITE_4(sc, BGE_MAC_ADDR1_LO, htons(m[0]));
	CSR_WRITE_4(sc, BGE_MAC_ADDR1_HI, (htons(m[1]) << 16) | htons(m[2]));

	if (!(ifp->if_capabilities & IFCAP_VLAN_HWTAGGING)) {
		/* Disable hardware decapsulation of VLAN frames. */
		BGE_SETBIT(sc, BGE_RX_MODE, BGE_RXMODE_RX_KEEP_VLAN_DIAG);
	}

	/* Program promiscuous mode and multicast filters. */
	bge_iff(sc);

	/* Init RX ring. */
	bge_init_rx_ring_std(sc);

	/*
	 * Workaround for a bug in 5705 ASIC rev A0. Poll the NIC's
	 * memory to ensure that the chip has in fact read the first
	 * entry of the ring.
	 */
	if (sc->bge_chipid == BGE_CHIPID_BCM5705_A0) {
		u_int32_t		v, i;
		for (i = 0; i < 10; i++) {
			DELAY(20);
			v = bge_readmem_ind(sc, BGE_STD_RX_RINGS + 8);
			if (v == (MCLBYTES - ETHER_ALIGN))
				break;
		}
		if (i == 10)
			printf("%s: 5705 A0 chip failed to load RX ring\n",
			    sc->bge_dev.dv_xname);
	}

	/* Init Jumbo RX ring. */
	if (sc->bge_flags & BGE_JUMBO_RING)
		bge_init_rx_ring_jumbo(sc);

	/* Init our RX return ring index */
	sc->bge_rx_saved_considx = 0;

	/* Init our RX/TX stat counters. */
	sc->bge_tx_collisions = 0;
	sc->bge_rx_discards = 0;
	sc->bge_rx_inerrors = 0;
	sc->bge_rx_overruns = 0;
	sc->bge_tx_discards = 0;

	/* Init TX ring. */
	bge_init_tx_ring(sc);

	/* Enable TX MAC state machine lockup fix. */
	mode = CSR_READ_4(sc, BGE_TX_MODE);
	if (BGE_IS_5755_PLUS(sc) ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906)
		mode |= BGE_TXMODE_MBUF_LOCKUP_FIX;
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5762) {
		mode &= ~(BGE_TXMODE_JMB_FRM_LEN | BGE_TXMODE_CNT_DN_MODE);
		mode |= CSR_READ_4(sc, BGE_TX_MODE) &
		    (BGE_TXMODE_JMB_FRM_LEN | BGE_TXMODE_CNT_DN_MODE);
	}

	/* Turn on transmitter */
	CSR_WRITE_4(sc, BGE_TX_MODE, mode | BGE_TXMODE_ENABLE);
	DELAY(100);

	mode = CSR_READ_4(sc, BGE_RX_MODE);
	if (BGE_IS_5755_PLUS(sc))
		mode |= BGE_RXMODE_IPV6_ENABLE;
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5762)
		mode |= BGE_RXMODE_IPV4_FRAG_FIX;

	/* Turn on receiver */
	CSR_WRITE_4(sc, BGE_RX_MODE, mode | BGE_RXMODE_ENABLE);
	DELAY(10);

	/*
	 * Set the number of good frames to receive after RX MBUF
	 * Low Watermark has been reached. After the RX MAC receives
	 * this number of frames, it will drop subsequent incoming
	 * frames until the MBUF High Watermark is reached.
	 */
	if (BGE_IS_57765_PLUS(sc))
		CSR_WRITE_4(sc, BGE_MAX_RX_FRAME_LOWAT, 1);
	else
		CSR_WRITE_4(sc, BGE_MAX_RX_FRAME_LOWAT, 2);

	/* Tell firmware we're alive. */
	BGE_SETBIT(sc, BGE_MODE_CTL, BGE_MODECTL_STACKUP);

	/* Enable host interrupts. */
	BGE_SETBIT(sc, BGE_PCI_MISC_CTL, BGE_PCIMISCCTL_CLEAR_INTA);
	BGE_CLRBIT(sc, BGE_PCI_MISC_CTL, BGE_PCIMISCCTL_MASK_PCI_INTR);
	bge_writembx(sc, BGE_MBX_IRQ0_LO, 0);

	bge_ifmedia_upd(ifp);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);

	timeout_add_sec(&sc->bge_timeout, 1);
}

/*
 * Set media options.
 */
int
bge_ifmedia_upd(struct ifnet *ifp)
{
	struct bge_softc *sc = ifp->if_softc;
	struct mii_data *mii = &sc->bge_mii;
	struct ifmedia *ifm = &sc->bge_ifmedia;

	/* If this is a 1000baseX NIC, enable the TBI port. */
	if (sc->bge_flags & BGE_FIBER_TBI) {
		if (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)
			return (EINVAL);
		switch(IFM_SUBTYPE(ifm->ifm_media)) {
		case IFM_AUTO:
			/*
			 * The BCM5704 ASIC appears to have a special
			 * mechanism for programming the autoneg
			 * advertisement registers in TBI mode.
			 */
			if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704) {
				u_int32_t sgdig;
				sgdig = CSR_READ_4(sc, BGE_SGDIG_STS);
				if (sgdig & BGE_SGDIGSTS_DONE) {
					CSR_WRITE_4(sc, BGE_TX_TBI_AUTONEG, 0);
					sgdig = CSR_READ_4(sc, BGE_SGDIG_CFG);
					sgdig |= BGE_SGDIGCFG_AUTO |
					    BGE_SGDIGCFG_PAUSE_CAP |
					    BGE_SGDIGCFG_ASYM_PAUSE;
					CSR_WRITE_4(sc, BGE_SGDIG_CFG,
					    sgdig | BGE_SGDIGCFG_SEND);
					DELAY(5);
					CSR_WRITE_4(sc, BGE_SGDIG_CFG, sgdig);
				}
			}
			break;
		case IFM_1000_SX:
			if ((ifm->ifm_media & IFM_GMASK) == IFM_FDX) {
				BGE_CLRBIT(sc, BGE_MAC_MODE,
				    BGE_MACMODE_HALF_DUPLEX);
			} else {
				BGE_SETBIT(sc, BGE_MAC_MODE,
				    BGE_MACMODE_HALF_DUPLEX);
			}
			DELAY(40);
			break;
		default:
			return (EINVAL);
		}
		/* XXX 802.3x flow control for 1000BASE-SX */
		return (0);
	}

	BGE_STS_SETBIT(sc, BGE_STS_LINK_EVT);
	if (mii->mii_instance) {
		struct mii_softc *miisc;
		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
			mii_phy_reset(miisc);
	}
	mii_mediachg(mii);

	/*
	 * Force an interrupt so that we will call bge_link_upd
	 * if needed and clear any pending link state attention.
	 * Without this we are not getting any further interrupts
	 * for link state changes and thus will not UP the link and
	 * not be able to send in bge_start. The only way to get
	 * things working was to receive a packet and get a RX intr.
	 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
	    sc->bge_flags & BGE_IS_5788)
		BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_INTR_SET);
	else
		BGE_SETBIT(sc, BGE_HCC_MODE, BGE_HCCMODE_COAL_NOW);

	return (0);
}

/*
 * Report current media status.
 */
void
bge_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct bge_softc *sc = ifp->if_softc;
	struct mii_data *mii = &sc->bge_mii;

	if (sc->bge_flags & BGE_FIBER_TBI) {
		ifmr->ifm_status = IFM_AVALID;
		ifmr->ifm_active = IFM_ETHER;
		if (CSR_READ_4(sc, BGE_MAC_STS) &
		    BGE_MACSTAT_TBI_PCS_SYNCHED) {
			ifmr->ifm_status |= IFM_ACTIVE;
		} else {
			ifmr->ifm_active |= IFM_NONE;
			return;
		}
		ifmr->ifm_active |= IFM_1000_SX;
		if (CSR_READ_4(sc, BGE_MAC_MODE) & BGE_MACMODE_HALF_DUPLEX)
			ifmr->ifm_active |= IFM_HDX;
		else
			ifmr->ifm_active |= IFM_FDX;
		return;
	}

	mii_pollstat(mii);
	ifmr->ifm_status = mii->mii_media_status;
	ifmr->ifm_active = (mii->mii_media_active & ~IFM_ETH_FMASK) |
	    sc->bge_flowflags;
}

int
bge_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct bge_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *) data;
	int s, error = 0;
	struct mii_data *mii;

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			bge_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				bge_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				bge_stop(sc, 0);
		}
		break;

	case SIOCSIFMEDIA:
		/* XXX Flow control is not supported for 1000BASE-SX */
		if (sc->bge_flags & BGE_FIBER_TBI) {
			ifr->ifr_media &= ~IFM_ETH_FMASK;
			sc->bge_flowflags = 0;
		}

		/* Flow control requires full-duplex mode. */
		if (IFM_SUBTYPE(ifr->ifr_media) == IFM_AUTO ||
		    (ifr->ifr_media & IFM_FDX) == 0) {
		    	ifr->ifr_media &= ~IFM_ETH_FMASK;
		}
		if (IFM_SUBTYPE(ifr->ifr_media) != IFM_AUTO) {
			if ((ifr->ifr_media & IFM_ETH_FMASK) == IFM_FLOW) {
				/* We can do both TXPAUSE and RXPAUSE. */
				ifr->ifr_media |=
				    IFM_ETH_TXPAUSE | IFM_ETH_RXPAUSE;
			}
			sc->bge_flowflags = ifr->ifr_media & IFM_ETH_FMASK;
		}
		/* FALLTHROUGH */
	case SIOCGIFMEDIA:
		if (sc->bge_flags & BGE_FIBER_TBI) {
			error = ifmedia_ioctl(ifp, ifr, &sc->bge_ifmedia,
			    command);
		} else {
			mii = &sc->bge_mii;
			error = ifmedia_ioctl(ifp, ifr, &mii->mii_media,
			    command);
		}
		break;

	case SIOCGIFRXR:
		error = bge_rxrinfo(sc, (struct if_rxrinfo *)ifr->ifr_data);
		break;

	default:
		error = ether_ioctl(ifp, &sc->arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			bge_iff(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

int
bge_rxrinfo(struct bge_softc *sc, struct if_rxrinfo *ifri)
{
	struct if_rxring_info ifr[2];
	u_int n = 0;

	memset(ifr, 0, sizeof(ifr));

	if (ISSET(sc->bge_flags, BGE_RXRING_VALID)) {
		ifr[n].ifr_size = sc->bge_rx_std_len;
		strlcpy(ifr[n].ifr_name, "std", sizeof(ifr[n].ifr_name));
		ifr[n].ifr_info = sc->bge_std_ring;

		n++;
	}

	if (ISSET(sc->bge_flags, BGE_JUMBO_RXRING_VALID)) {
		ifr[n].ifr_size = BGE_JLEN;
		strlcpy(ifr[n].ifr_name, "jumbo", sizeof(ifr[n].ifr_name));
		ifr[n].ifr_info = sc->bge_jumbo_ring;

		n++;
	}

	return (if_rxr_info_ioctl(ifri, n, ifr));
}

void
bge_watchdog(struct ifnet *ifp)
{
	struct bge_softc *sc;

	sc = ifp->if_softc;

	printf("%s: watchdog timeout -- resetting\n", sc->bge_dev.dv_xname);

	bge_init(sc);

	ifp->if_oerrors++;
}

void
bge_stop_block(struct bge_softc *sc, bus_size_t reg, u_int32_t bit)
{
	int i;

	BGE_CLRBIT(sc, reg, bit);

	for (i = 0; i < BGE_TIMEOUT; i++) {
		if ((CSR_READ_4(sc, reg) & bit) == 0)
			return;
		delay(100);
	}

	DPRINTFN(5, ("%s: block failed to stop: reg 0x%lx, bit 0x%08x\n",
	    sc->bge_dev.dv_xname, (u_long) reg, bit));
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void
bge_stop(struct bge_softc *sc, int softonly)
{
	struct ifnet *ifp = &sc->arpcom.ac_if;
	struct ifmedia_entry *ifm;
	struct mii_data *mii;
	int mtmp, itmp;

	timeout_del(&sc->bge_timeout);
	timeout_del(&sc->bge_rxtimeout);
	timeout_del(&sc->bge_rxtimeout_jumbo);

	ifp->if_flags &= ~IFF_RUNNING;
	ifp->if_timer = 0;

	if (!softonly) {
		/*
		 * Tell firmware we're shutting down.
		 */
		/* bge_stop_fw(sc); */
		bge_sig_pre_reset(sc, BGE_RESET_SHUTDOWN);

		/*
		 * Disable all of the receiver blocks
		 */
		bge_stop_block(sc, BGE_RX_MODE, BGE_RXMODE_ENABLE);
		bge_stop_block(sc, BGE_RBDI_MODE, BGE_RBDIMODE_ENABLE);
		bge_stop_block(sc, BGE_RXLP_MODE, BGE_RXLPMODE_ENABLE);
		if (BGE_IS_5700_FAMILY(sc))
			bge_stop_block(sc, BGE_RXLS_MODE, BGE_RXLSMODE_ENABLE);
		bge_stop_block(sc, BGE_RDBDI_MODE, BGE_RBDIMODE_ENABLE);
		bge_stop_block(sc, BGE_RDC_MODE, BGE_RDCMODE_ENABLE);
		bge_stop_block(sc, BGE_RBDC_MODE, BGE_RBDCMODE_ENABLE);

		/*
		 * Disable all of the transmit blocks
		 */
		bge_stop_block(sc, BGE_SRS_MODE, BGE_SRSMODE_ENABLE);
		bge_stop_block(sc, BGE_SBDI_MODE, BGE_SBDIMODE_ENABLE);
		bge_stop_block(sc, BGE_SDI_MODE, BGE_SDIMODE_ENABLE);
		bge_stop_block(sc, BGE_RDMA_MODE, BGE_RDMAMODE_ENABLE);
		bge_stop_block(sc, BGE_SDC_MODE, BGE_SDCMODE_ENABLE);
		if (BGE_IS_5700_FAMILY(sc))
			bge_stop_block(sc, BGE_DMAC_MODE, BGE_DMACMODE_ENABLE);
		bge_stop_block(sc, BGE_SBDC_MODE, BGE_SBDCMODE_ENABLE);

		/*
		 * Shut down all of the memory managers and related
		 * state machines.
		 */
		bge_stop_block(sc, BGE_HCC_MODE, BGE_HCCMODE_ENABLE);
		bge_stop_block(sc, BGE_WDMA_MODE, BGE_WDMAMODE_ENABLE);
		if (BGE_IS_5700_FAMILY(sc))
			bge_stop_block(sc, BGE_MBCF_MODE, BGE_MBCFMODE_ENABLE);

		CSR_WRITE_4(sc, BGE_FTQ_RESET, 0xFFFFFFFF);
		CSR_WRITE_4(sc, BGE_FTQ_RESET, 0);

		if (!BGE_IS_5705_PLUS(sc)) {
			bge_stop_block(sc, BGE_BMAN_MODE, BGE_BMANMODE_ENABLE);
			bge_stop_block(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE);
		}

		bge_reset(sc);
		bge_sig_legacy(sc, BGE_RESET_SHUTDOWN);
		bge_sig_post_reset(sc, BGE_RESET_SHUTDOWN);

		/*
		 * Tell firmware we're shutting down.
		 */
		BGE_CLRBIT(sc, BGE_MODE_CTL, BGE_MODECTL_STACKUP);
	}

	intr_barrier(sc->bge_intrhand);
	ifq_barrier(&ifp->if_snd);

	ifq_clr_oactive(&ifp->if_snd);

	/* Free the RX lists. */
	bge_free_rx_ring_std(sc);

	/* Free jumbo RX list. */
	if (sc->bge_flags & BGE_JUMBO_RING)
		bge_free_rx_ring_jumbo(sc);

	/* Free TX buffers. */
	bge_free_tx_ring(sc);

	/*
	 * Isolate/power down the PHY, but leave the media selection
	 * unchanged so that things will be put back to normal when
	 * we bring the interface back up.
	 */
	if (!(sc->bge_flags & BGE_FIBER_TBI)) {
		mii = &sc->bge_mii;
		itmp = ifp->if_flags;
		ifp->if_flags |= IFF_UP;
		ifm = mii->mii_media.ifm_cur;
		mtmp = ifm->ifm_media;
		ifm->ifm_media = IFM_ETHER|IFM_NONE;
		mii_mediachg(mii);
		ifm->ifm_media = mtmp;
		ifp->if_flags = itmp;
	}

	sc->bge_tx_saved_considx = BGE_TXCONS_UNSET;

	if (!softonly) {
		/* Clear MAC's link state (PHY may still have link UP). */
		BGE_STS_CLRBIT(sc, BGE_STS_LINK);
	}
}

void
bge_link_upd(struct bge_softc *sc)
{
	struct ifnet *ifp = &sc->arpcom.ac_if;
	struct mii_data *mii = &sc->bge_mii;
	u_int32_t status;
	int link;

	/* Clear 'pending link event' flag */
	BGE_STS_CLRBIT(sc, BGE_STS_LINK_EVT);

	/*
	 * Process link state changes.
	 * Grrr. The link status word in the status block does
	 * not work correctly on the BCM5700 rev AX and BX chips,
	 * according to all available information. Hence, we have
	 * to enable MII interrupts in order to properly obtain
	 * async link changes. Unfortunately, this also means that
	 * we have to read the MAC status register to detect link
	 * changes, thereby adding an additional register access to
	 * the interrupt handler.
	 *
	 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700) {
		status = CSR_READ_4(sc, BGE_MAC_STS);
		if (status & BGE_MACSTAT_MI_INTERRUPT) {
			mii_pollstat(mii);

			if (!BGE_STS_BIT(sc, BGE_STS_LINK) &&
			    mii->mii_media_status & IFM_ACTIVE &&
			    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE)
				BGE_STS_SETBIT(sc, BGE_STS_LINK);
			else if (BGE_STS_BIT(sc, BGE_STS_LINK) &&
			    (!(mii->mii_media_status & IFM_ACTIVE) ||
			    IFM_SUBTYPE(mii->mii_media_active) == IFM_NONE))
				BGE_STS_CLRBIT(sc, BGE_STS_LINK);

			/* Clear the interrupt */
			CSR_WRITE_4(sc, BGE_MAC_EVT_ENB,
			    BGE_EVTENB_MI_INTERRUPT);
			bge_miibus_readreg(&sc->bge_dev, sc->bge_phy_addr,
			    BRGPHY_MII_ISR);
			bge_miibus_writereg(&sc->bge_dev, sc->bge_phy_addr,
			    BRGPHY_MII_IMR, BRGPHY_INTRS);
		}
		return;
	}

	if (sc->bge_flags & BGE_FIBER_TBI) {
		status = CSR_READ_4(sc, BGE_MAC_STS);
		if (status & BGE_MACSTAT_TBI_PCS_SYNCHED) {
			if (!BGE_STS_BIT(sc, BGE_STS_LINK)) {
				BGE_STS_SETBIT(sc, BGE_STS_LINK);
				if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704)
					BGE_CLRBIT(sc, BGE_MAC_MODE,
					    BGE_MACMODE_TBI_SEND_CFGS);
				CSR_WRITE_4(sc, BGE_MAC_STS, 0xFFFFFFFF);
				status = CSR_READ_4(sc, BGE_MAC_MODE);
				link = (status & BGE_MACMODE_HALF_DUPLEX) ?
				    LINK_STATE_HALF_DUPLEX :
				    LINK_STATE_FULL_DUPLEX;
				ifp->if_baudrate = IF_Gbps(1);
				if (ifp->if_link_state != link) {
					ifp->if_link_state = link;
					if_link_state_change(ifp);
				}
			}
		} else if (BGE_STS_BIT(sc, BGE_STS_LINK)) {
			BGE_STS_CLRBIT(sc, BGE_STS_LINK);
			link = LINK_STATE_DOWN;
			ifp->if_baudrate = 0;
			if (ifp->if_link_state != link) {
				ifp->if_link_state = link;
				if_link_state_change(ifp);
			}
		}
	} else if (BGE_STS_BIT(sc, BGE_STS_AUTOPOLL)) {
		/*
		 * Some broken BCM chips have BGE_STATFLAG_LINKSTATE_CHANGED bit
		 * in status word always set. Workaround this bug by reading
		 * PHY link status directly.
		 */
		link = (CSR_READ_4(sc, BGE_MI_STS) & BGE_MISTS_LINK)?
		    BGE_STS_LINK : 0;

		if (BGE_STS_BIT(sc, BGE_STS_LINK) != link) {
			mii_pollstat(mii);

			if (!BGE_STS_BIT(sc, BGE_STS_LINK) &&
			    mii->mii_media_status & IFM_ACTIVE &&
			    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE)
				BGE_STS_SETBIT(sc, BGE_STS_LINK);
			else if (BGE_STS_BIT(sc, BGE_STS_LINK) &&
			    (!(mii->mii_media_status & IFM_ACTIVE) ||
			    IFM_SUBTYPE(mii->mii_media_active) == IFM_NONE))
				BGE_STS_CLRBIT(sc, BGE_STS_LINK);
		}
	} else {
		/*
		 * For controllers that call mii_tick, we have to poll
		 * link status.
		 */
		mii_pollstat(mii);
	}

	/* Clear the attention */
	CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED|
	    BGE_MACSTAT_CFG_CHANGED|BGE_MACSTAT_MI_COMPLETE|
	    BGE_MACSTAT_LINK_CHANGED);
}
@


1.385
log
@properly set BGE_HCC_STATS_ADDR_HI by using BGE_HOSTADDR.

this makes it consistent with the rest of the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.384 2017/01/24 03:57:34 dlg Exp $	*/
d3262 1
a3262 1
		if (BGE_ASICREV(sc->bge_chipid != BGE_ASICREV_BCM5785) &&
@


1.384
log
@add support for multiple transmit ifqueues per network interface.

an ifq to transmit a packet is picked by the current traffic
conditioner (ie, priq or hfsc) by providing an index into an array
of ifqs. by default interfaces get a single ifq but can ask for
more using if_attach_queues().

the vast majority of our drivers still think there's a 1:1 mapping
between interfaces and transmit queues, so their if_start routines
take an ifnet pointer instead of a pointer to the ifqueue struct.
instead of changing all the drivers in the tree, drivers can opt
into using an if_qstart routine and setting the IFXF_MPSAFE flag.
the stack provides a compatability wrapper from the new if_qstart
handler to the previous if_start handlers if IFXF_MPSAFE isnt set.

enabling hfsc on an interface configures it to transmit everything
through the first ifq. any other ifqs are left configured as priq,
but unused, when hfsc is enabled.

getting this in now so everyone can kick the tyres.

ok mpi@@ visa@@ (who provided some tweaks for cnmac).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.383 2017/01/22 10:17:38 dlg Exp $	*/
d2207 3
a2209 3
		CSR_WRITE_4(sc, BGE_HCC_STATS_ADDR_HI, 0);
		CSR_WRITE_4(sc, BGE_HCC_STATS_ADDR_LO,
			    BGE_RING_DMA_ADDR(sc, bge_info.bge_stats));
@


1.383
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.382 2016/04/13 10:34:32 mpi Exp $	*/
d145 1
a145 1
void bge_start(struct ifnet *);
d2999 1
a2999 1
	ifp->if_start = bge_start;
d4119 1
a4119 1
bge_start(struct ifnet *ifp)
d4121 1
d4127 1
a4127 1
		IFQ_PURGE(&ifp->if_snd);
d4136 1
a4136 1
			ifq_set_oactive(&ifp->if_snd);
d4140 1
a4140 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.382
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.381 2015/12/29 12:47:22 dlg Exp $	*/
a3647 2
		if (cur_tx->bge_flags & BGE_TXBDFLAG_END)
			ifp->if_opackets++;
@


1.381
log
@shuffle tx code slightly and mark bge_start as mpsafe.

reviewed by jmatthew@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.380 2015/11/29 20:19:35 kettenis Exp $	*/
a3001 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.380
log
@Make it possible to detach bge(4).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.379 2015/11/25 03:09:59 dlg Exp $	*/
d2997 1
d3669 5
a3673 3
	if (txcnt < BGE_TX_RING_CNT - 16)
		ifq_clr_oactive(&ifp->if_snd);
	if (txcnt == 0)
a3674 2

	sc->bge_tx_saved_considx = cons;
a3736 6

		if (!IFQ_IS_EMPTY(&ifp->if_snd)) {
			KERNEL_LOCK();
			bge_start(ifp);
			KERNEL_UNLOCK();
		}
d4097 3
a4102 3
	if (frag == sc->bge_tx_saved_considx)
		goto fail_unload;

d4124 1
a4124 1
	struct bge_softc *sc;
d4128 2
a4129 5
	sc = ifp->if_softc;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;
	if (!BGE_STS_BIT(sc, BGE_STS_LINK))
d4131 1
a4586 1
	ifq_clr_oactive(&ifp->if_snd);
d4648 3
@


1.379
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.378 2015/11/24 17:11:39 mpi Exp $	*/
d121 1
d125 2
a126 1
	sizeof(struct bge_softc), bge_probe, bge_attach, NULL, bge_activate
d150 1
a150 1
void bge_stop(struct bge_softc *);
d2541 1
a2541 3
	bus_size_t		size, apesize;
	bus_dma_segment_t	seg;
	int			rseg, gotenaddr = 0;
d2563 1
a2563 1
	    &sc->bge_bhandle, NULL, &size, 0)) {
d2830 2
a2831 1
		    &sc->bge_apetag, &sc->bge_apehandle, NULL, &apesize, 0)) {
d2948 2
a2949 1
			     PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
d2954 3
a2956 3
	if (bus_dmamem_map(sc->bge_dmatag, &seg, rseg,
			   sizeof(struct bge_ring_data), &kva,
			   BUS_DMA_NOWAIT)) {
d3139 1
a3139 1
	bus_dmamem_unmap(sc->bge_dmatag, kva,
d3143 1
a3143 1
	bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
d3147 2
a3148 1
		bus_space_unmap(sc->bge_apetag, sc->bge_apehandle, apesize);
d3151 36
a3186 1
	bus_space_unmap(sc->bge_btag, sc->bge_bhandle, size);
d3200 1
a3200 1
			bge_stop(sc);
d4196 1
a4196 1
	bge_stop(sc);
d4465 1
a4465 1
				bge_stop(sc);
d4582 1
a4582 1
bge_stop(struct bge_softc *sc)
d4597 18
a4614 5
	/*
	 * Tell firmware we're shutting down.
	 */
	/* bge_stop_fw(sc); */
	bge_sig_pre_reset(sc, BGE_RESET_SHUTDOWN);
d4616 11
d4628 8
a4635 11
	/*
	 * Disable all of the receiver blocks
	 */
	bge_stop_block(sc, BGE_RX_MODE, BGE_RXMODE_ENABLE);
	bge_stop_block(sc, BGE_RBDI_MODE, BGE_RBDIMODE_ENABLE);
	bge_stop_block(sc, BGE_RXLP_MODE, BGE_RXLPMODE_ENABLE);
	if (BGE_IS_5700_FAMILY(sc))
		bge_stop_block(sc, BGE_RXLS_MODE, BGE_RXLSMODE_ENABLE);
	bge_stop_block(sc, BGE_RDBDI_MODE, BGE_RBDIMODE_ENABLE);
	bge_stop_block(sc, BGE_RDC_MODE, BGE_RDCMODE_ENABLE);
	bge_stop_block(sc, BGE_RBDC_MODE, BGE_RBDCMODE_ENABLE);
d4637 2
a4638 11
	/*
	 * Disable all of the transmit blocks
	 */
	bge_stop_block(sc, BGE_SRS_MODE, BGE_SRSMODE_ENABLE);
	bge_stop_block(sc, BGE_SBDI_MODE, BGE_SBDIMODE_ENABLE);
	bge_stop_block(sc, BGE_SDI_MODE, BGE_SDIMODE_ENABLE);
	bge_stop_block(sc, BGE_RDMA_MODE, BGE_RDMAMODE_ENABLE);
	bge_stop_block(sc, BGE_SDC_MODE, BGE_SDCMODE_ENABLE);
	if (BGE_IS_5700_FAMILY(sc))
		bge_stop_block(sc, BGE_DMAC_MODE, BGE_DMACMODE_ENABLE);
	bge_stop_block(sc, BGE_SBDC_MODE, BGE_SBDCMODE_ENABLE);
d4640 4
a4643 8
	/*
	 * Shut down all of the memory managers and related
	 * state machines.
	 */
	bge_stop_block(sc, BGE_HCC_MODE, BGE_HCCMODE_ENABLE);
	bge_stop_block(sc, BGE_WDMA_MODE, BGE_WDMAMODE_ENABLE);
	if (BGE_IS_5700_FAMILY(sc))
		bge_stop_block(sc, BGE_MBCF_MODE, BGE_MBCFMODE_ENABLE);
d4645 3
a4647 2
	CSR_WRITE_4(sc, BGE_FTQ_RESET, 0xFFFFFFFF);
	CSR_WRITE_4(sc, BGE_FTQ_RESET, 0);
d4649 4
a4652 3
	if (!BGE_IS_5705_PLUS(sc)) {
		bge_stop_block(sc, BGE_BMAN_MODE, BGE_BMANMODE_ENABLE);
		bge_stop_block(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE);
a4654 9
	bge_reset(sc);
	bge_sig_legacy(sc, BGE_RESET_SHUTDOWN);
	bge_sig_post_reset(sc, BGE_RESET_SHUTDOWN);

	/*
	 * Tell firmware we're shutting down.
	 */
	BGE_CLRBIT(sc, BGE_MODE_CTL, BGE_MODECTL_STACKUP);

d4686 4
a4689 2
	/* Clear MAC's link state (PHY may still have link UP). */
	BGE_STS_CLRBIT(sc, BGE_STS_LINK);
@


1.378
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.377 2015/11/23 10:52:43 mpi Exp $	*/
d3631 1
a3631 1
		ifp->if_flags &= ~IFF_OACTIVE;
d4097 1
a4097 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d4107 1
a4107 1
			ifp->if_flags |= IFF_OACTIVE;
d4283 1
a4283 1
	ifp->if_flags &= ~IFF_OACTIVE;
d4555 2
a4556 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.377
log
@Include <sys/atomic.h> when atomic operations are used.

This has been masked because <sys/srp.h> is pulled unconditionally.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.376 2015/11/17 12:30:42 jmatthew Exp $	*/
a89 1
#include <net/if_dl.h>
@


1.376
log
@Clear if_timer when shutting down the interface so the watchdog timer
doesn't fire a few seconds later.

problem reported by Hrvoje Popovski, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.375 2015/11/17 01:47:08 dlg Exp $	*/
d87 1
@


1.375
log
@shuffle transmit to avoid IFQ_POLL.

basically make sure there's enough space in the ring before dequeueing a
packet for it.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.374 2015/11/14 17:54:57 mpi Exp $	*/
d4556 1
@


1.374
log
@Do not include <net/if_vlan_var.h> when it's not necessary.

Because of the VLAN hacks in mpw(4) this file still contains the definition
of "struct ifvlan" which depends on <sys/refcnt.h> which in turns pull
<sys/atomic.h>...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.373 2015/11/12 19:55:48 miod Exp $	*/
d3983 1
a3983 1
bge_encap(struct bge_softc *sc, struct mbuf *m_head, int *txinc)
d3993 2
a3994 2
	if (m_head->m_pkthdr.csum_flags) {
		if (m_head->m_pkthdr.csum_flags & M_IPV4_CSUM_OUT)
d3996 2
a3997 2
		if (m_head->m_pkthdr.csum_flags & (M_TCP_CSUM_OUT |
		    M_UDP_CSUM_OUT)) {
d3999 2
a4000 2
			if (m_head->m_pkthdr.len < ETHER_MIN_NOPAD &&
			    bge_cksum_pad(m_head) != 0)
d4006 1
a4006 1
	    m_head->m_pkthdr.len > ETHER_MAX_LEN)
d4017 1
a4017 1
	if (bge_compact_dma_runt(m_head) != 0)
d4028 1
a4028 1
	switch (bus_dmamap_load_mbuf(sc->bge_dmatag, dmamap, m_head,
d4033 2
a4034 2
		if (m_defrag(m_head, M_DONTWAIT) == 0 &&
		    bus_dmamap_load_mbuf(sc->bge_dmatag, dmamap, m_head,
a4042 4
	/* Check if we have enough free send BDs. */
	if (sc->bge_txcnt + *txinc + dmamap->dm_nsegs >= BGE_TX_RING_CNT)
		goto fail_unload;

d4052 1
a4052 1
		if (m_head->m_flags & M_VLANTAG) {
d4054 1
a4054 1
			f->bge_vlan_tag = m_head->m_pkthdr.ether_vtag;
d4071 1
a4071 1
	sc->bge_cdata.bge_tx_chain[cur] = m_head;
d4092 1
a4092 1
	struct mbuf *m_head;
d4104 4
a4107 2
		IFQ_POLL(&ifp->if_snd, m_head);
		if (m_head == NULL)
d4109 1
d4111 2
a4112 1
		if (bge_encap(sc, m_head, &txinc))
d4115 4
a4118 2
		/* now we are committed to transmit the packet */
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
d4122 1
a4122 1
			bpf_mtap_ether(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
a4126 2
		int txcnt;

d4135 1
a4135 3
		txcnt = atomic_add_int_nv(&sc->bge_txcnt, txinc);
		if (txcnt > BGE_TX_RING_CNT - 16)
			ifp->if_flags |= IFF_OACTIVE;
@


1.373
log
@Revert 1.372, reported to cause regressions on some models.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.371 2015/10/25 13:04:28 mpi Exp $	*/
a93 5

#if NVLAN > 0
#include <net/if_types.h>
#include <net/if_vlan_var.h>
#endif
@


1.372
log
@In bge_reset(), after figuring out which register access routines to use
depending upon the chip capabilities, use it everywhere instead of hardcoding
one call to bge_writemem_ind() by mistake; this unbreaks the BCM5704 A3 found
on some xserve G5 (RackMac3,1).

Also tested on a few other bge(4) chip models by jmatthew@@ (5703X, 5714),
mpi@@ (5780), naddy@@ (5761) and me (5701).

ok dlg@@
@
text
@d3224 1
a3224 1
	write_op(sc, BGE_SOFTWARE_GENCOMM, BGE_MAGIC_NUMBER);
@


1.371
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.370 2015/10/19 05:31:25 jmatthew Exp $	*/
d3224 1
a3224 1
	bge_writemem_ind(sc, BGE_SOFTWARE_GENCOMM, BGE_MAGIC_NUMBER);
@


1.370
log
@Move bge rxeof and txeof outside the kernel lock.
To make rxeof safe, use a separate ring refill timeout for each ring.
We activate the refill timeout for a ring when it's too empty to receive
packets, which ensures we won't attempt to refill it from interrupt context.

To make txeof safe, remove the list of dma maps and just allocate maps based on
the ring slots occupied by the packet, and use atomic operations to adjust
bge_txcnt.  Rework some parts of the txeof and start loops so that we only
adjust bge_txcnt after exiting the loop, and only take actions such as setting
or clearing OACTIVE based on the final value.

tested on 5703, 5714, 5721 by me, 5753 by semarie@@, 5761 by naddy@@, and
also in snapshots for a while
ok mpi@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.369 2015/07/19 06:28:12 yuo Exp $	*/
a4412 1
	struct ifaddr *ifa = (struct ifaddr *) data;
a4423 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->arpcom, ifa);
@


1.369
log
@use standardized register definition in mii.h rather than each
specific driver definition.

no logical change.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.368 2015/06/24 09:40:54 mpi Exp $	*/
d144 1
a144 1
int bge_encap(struct bge_softc *, struct mbuf *, u_int32_t *);
d1265 7
a1275 1
	int s;
a1276 1
	s = splnet();
d1280 7
a1289 1
	splx(s);
d1424 1
a1424 1
		timeout_add(&sc->bge_rxtimeout, 1);
a1459 1
	struct txdmamap_pool_entry *dma;
d1468 1
a1468 3
			SLIST_INSERT_HEAD(&sc->txdma_list, sc->txdma[i],
					    link);
			sc->txdma[i] = 0;
a1471 1
	}
d1473 1
a1473 4
	while ((dma = SLIST_FIRST(&sc->txdma_list))) {
		SLIST_REMOVE_HEAD(&sc->txdma_list, link);
		bus_dmamap_destroy(sc->bge_dmatag, dma->dmamap);
		free(dma, M_DEVBUF, 0);
a1482 1
	bus_dmamap_t dmamap;
a1483 1
	struct txdmamap_pool_entry *dma;
a1509 1
	SLIST_INIT(&sc->txdma_list);
d1512 1
a1512 1
		    BGE_NTXSEG, txsegsz, 0, BUS_DMA_NOWAIT, &dmamap))
a1513 11
		if (dmamap == NULL)
			panic("dmamap NULL in bge_init_tx_ring");
		dma = malloc(sizeof(*dma), M_DEVBUF, M_NOWAIT);
		if (dma == NULL) {
			printf("%s: can't alloc txdmamap_pool_entry\n",
			    sc->bge_dev.dv_xname);
			bus_dmamap_destroy(sc->bge_dmatag, dmamap);
			return (ENOMEM);
		}
		dma->dmamap = dmamap;
		SLIST_INSERT_HEAD(&sc->txdma_list, dma, link);
d3074 2
a3075 2
	sc->bge_intrhand = pci_intr_establish(pc, ih, IPL_NET, bge_intr, sc,
	    sc->bge_dev.dv_xname);
d3132 1
d3572 1
a3572 1
	struct txdmamap_pool_entry *dma;
d3575 2
a3576 1
	int tosync;
d3580 3
a3582 2
	if (sc->bge_tx_saved_considx ==
	    sc->bge_rdata->bge_status_block.bge_idx[0].bge_tx_cons_idx)
d3593 1
a3593 2
	tosync = sc->bge_rdata->bge_status_block.bge_idx[0].bge_tx_cons_idx -
	    sc->bge_tx_saved_considx;
d3595 1
a3595 1
	toff = offset + (sc->bge_tx_saved_considx * sizeof (struct bge_tx_bd));
d3598 1
a3598 2
		tlen = (BGE_TX_RING_CNT - sc->bge_tx_saved_considx) *
		    sizeof (struct bge_tx_bd);
d3612 3
a3614 6
	while (sc->bge_tx_saved_considx !=
	    sc->bge_rdata->bge_status_block.bge_idx[0].bge_tx_cons_idx) {
		u_int32_t		idx = 0;

		idx = sc->bge_tx_saved_considx;
		cur_tx = &sc->bge_rdata->bge_tx_ring[idx];
d3617 1
a3617 1
		m = sc->bge_cdata.bge_tx_chain[idx];
d3619 7
a3625 7
			sc->bge_cdata.bge_tx_chain[idx] = NULL;
			dma = sc->txdma[idx];
			bus_dmamap_sync(sc->bge_dmatag, dma->dmamap, 0,
			    dma->dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->bge_dmatag, dma->dmamap);
			SLIST_INSERT_HEAD(&sc->txdma_list, dma, link);
			sc->txdma[idx] = NULL;
d3629 2
a3630 2
		sc->bge_txcnt--;
		BGE_INC(sc->bge_tx_saved_considx, BGE_TX_RING_CNT);
d3633 3
a3635 1
	if (sc->bge_txcnt < BGE_TX_RING_CNT - 16)
d3637 1
a3637 1
	if (sc->bge_txcnt == 0)
d3639 2
d3688 2
a3689 1
	    BGE_STS_BIT(sc, BGE_STS_LINK_EVT))
d3691 2
d3704 2
a3705 1
		if (!IFQ_IS_EMPTY(&ifp->if_snd))
d3707 2
d3988 1
a3988 1
bge_encap(struct bge_softc *sc, struct mbuf *m_head, u_int32_t *txidx)
d3993 1
a3993 2
	struct txdmamap_pool_entry *dma;
	bus_dmamap_t dmamap;
d3996 1
a3996 1
	cur = frag = *txidx;
d4026 1
a4026 4
	dma = SLIST_FIRST(&sc->txdma_list);
	if (dma == NULL)
		return (ENOBUFS);
	dmamap = dma->dmamap;
d4049 1
a4049 1
	if (sc->bge_txcnt + dmamap->dm_nsegs >= BGE_TX_RING_CNT)
d4081 3
a4083 5
	SLIST_REMOVE_HEAD(&sc->txdma_list, link);
	sc->txdma[cur] = dma;
	sc->bge_txcnt += dmamap->dm_nsegs;

	*txidx = frag;
d4102 1
a4102 2
	u_int32_t prodidx;
	int pkts;
d4111 2
a4112 8
	prodidx = sc->bge_tx_prodidx;

	for (pkts = 0; !IFQ_IS_EMPTY(&ifp->if_snd);) {
		if (sc->bge_txcnt > BGE_TX_RING_CNT - 16) {
			ifp->if_flags |= IFF_OACTIVE;
			break;
		}

d4117 1
a4117 7
		/*
		 * Pack the data into the transmit ring. If we
		 * don't have room, set the OACTIVE flag and wait
		 * for the NIC to drain the ring.
		 */
		if (bge_encap(sc, m_head, &prodidx)) {
			ifp->if_flags |= IFF_OACTIVE;
a4118 1
		}
a4121 1
		pkts++;
a4123 4
		/*
		 * If there's a BPF listener, bounce a copy of this frame
		 * to him.
		 */
a4127 2
	if (pkts == 0)
		return;
d4129 10
a4138 4
	/* Transmit */
	bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, prodidx);
	if (BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5700_BX)
		bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, prodidx);
d4140 3
a4142 1
	sc->bge_tx_prodidx = prodidx;
d4144 5
a4148 4
	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;
d4563 1
d4623 2
@


1.368
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.367 2015/05/19 12:50:53 mikeb Exp $	*/
d113 1
d1013 1
a1013 1
	    (reg == BRGPHY_MII_1000CTL || reg == BRGPHY_MII_AUXCTL))
@


1.367
log
@Increase a maximum firmware handshake timeout to 10s

BCM5718 Programmers Guide in chapter 7 "Device Control", section
"Device Reset Procedure" states that SEEPROM chips need a larger
timeout than Flash ones.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.366 2015/03/14 03:38:48 jsg Exp $	*/
a3499 1
		ifp->if_ipackets++;
@


1.366
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.365 2015/02/09 09:51:16 dlg Exp $	*/
d3364 1
a3364 1
		for (i = 0; i < BGE_TIMEOUT; i++) {
d3371 2
a3372 1
		if (i >= BGE_TIMEOUT && (!(sc->bge_flags & BGE_NO_EEPROM)))
@


1.365
log
@if_input sets m->m_pkthdr.rcvif so we dont have to.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.364 2015/02/09 03:09:57 dlg Exp $	*/
a112 1
#include <dev/mii/mii.h>
@


1.364
log
@tweak the new if_input function so it takes an mbuf_list instead
of a single mbuf. this forces us to batch work between the hardware
rx handlers and the stack.

this includes a converstion of bge from ether_input to if_input.

ok claudio@@ pelikan@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.363 2015/01/24 02:36:03 brad Exp $	*/
a3512 1
		m->m_pkthdr.rcvif = ifp;
@


1.363
log
@Remove a comment that is no longer true with MCLGETI and jumbos on
some revisions of the chipsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.362 2014/12/22 02:28:51 tedu Exp $	*/
d3418 1
d3525 1
a3525 9
#if NBPFILTER > 0
		/*
		 * Handle BPF listeners. Let the BPF user see the packet.
		 */
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

		ether_input_mbuf(ifp, m);
d3538 2
@


1.362
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.361 2014/09/02 10:14:55 brad Exp $	*/
a1226 6
/*
 * The standard receive ring has 512 entries in it. At 2K per mbuf cluster,
 * that's 1MB or memory, which is a lot. For now, we fill only the first
 * 256 ring entries and hope that our CPU is fast enough to keep up with
 * the NIC.
 */
@


1.361
log
@Add Jumbo support for BCM5714 / BCM5780 and BCM5717 / BCM5719 / BCM5720 / BCM57765 / BCM57766
chipsets.

ok mikeb@@ "i think it should go in" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.360 2014/08/26 11:01:21 mikeb Exp $	*/
a91 1
#ifdef INET
a93 1
#endif
a4456 1
#ifdef INET
a4458 1
#endif /* INET */
@


1.360
log
@Revert part of the if_rxr diff that incorrectly moves RX ring tail
index update code from the buf_get success path to the do it all
the time code path.  Tested by millert;  ok dlg, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.359 2014/08/21 14:30:21 brad Exp $	*/
d1120 1
a1120 1
	m = MCLGETI(NULL, M_DONTWAIT, NULL, MCLBYTES);
d1123 1
a1123 1
	m->m_len = m->m_pkthdr.len = MCLBYTES;
d1244 2
a1245 2
		if (bus_dmamap_create(sc->bge_dmatag, MCLBYTES, 1, MCLBYTES, 0,
		    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
d1488 1
d1508 8
d1518 2
a1519 3
		if (bus_dmamap_create(sc->bge_dmatag, BGE_JLEN,
		    BGE_NTXSEG, BGE_JLEN, 0, BUS_DMA_NOWAIT,
		    &dmamap))
d2012 1
a2012 1
	if (BGE_IS_JUMBO_CAPABLE(sc)) {
d2076 1
a2076 1
	if (BGE_IS_JUMBO_CAPABLE(sc))
d2710 2
a2711 1
		    BGE_5705_PLUS;
d2719 7
d2740 1
a2740 1
		sc->bge_flags |= BGE_5700_FAMILY | BGE_JUMBO_CAPABLE;
d2745 1
a2745 1
		sc->bge_flags |= BGE_5714_FAMILY;
d2757 5
d4027 4
d4260 1
a4260 1
	if (BGE_IS_JUMBO_CAPABLE(sc))
d4536 1
a4536 1
		ifr[n].ifr_size = MCLBYTES;
d4663 1
a4663 1
	if (BGE_IS_JUMBO_CAPABLE(sc))
@


1.359
log
@Fix a copy and pasto with the standard ring setup with calling if_rxr_init()
to use BGE_STD_RX_RING_CNT instead of BGE_JUMBO_RX_RING_CNT.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.358 2014/07/22 13:12:11 mpi Exp $	*/
d1304 1
a1308 2
	sc->bge_std = i;

d1408 1
a1411 2

	sc->bge_jumbo = i;
@


1.358
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.357 2014/07/12 18:48:51 tedu Exp $	*/
d1258 1
a1258 1
	if_rxr_init(&sc->bge_std_ring, 17, BGE_JUMBO_RX_RING_CNT);
@


1.358.4.1
log
@OpenBSD 5.6 errata 1: Incorrect RX ring computation leads to panics
under load with bge(4), em(4) and ix(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.358 2014/07/22 13:12:11 mpi Exp $	*/
a1303 1
		sc->bge_std = i;
d1308 2
a1408 1
		sc->bge_jumbo = i;
d1412 2
@


1.357
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.356 2014/07/08 05:35:18 dlg Exp $	*/
a93 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.356
log
@cut things that relied on mclgeti for rx ring accounting/restriction over
to using if_rxr.

cut the reporting systat did over to the rxr ioctl.

tested as much as i can on alpha, amd64, and sparc64.
mpi@@ has run it on macppc.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.355 2014/07/03 13:26:05 dlg Exp $	*/
d1481 1
a1481 1
		free(dma, M_DEVBUF);
@


1.355
log
@sending a heavily fragmented packet will cause the bus_dmamap_load
in bge_encap to fail because the dmamap lacks space, not necessarily
because the ring is full. however, bge_encap failure sets the OACTIVE
flag on the interface and keeps the packet at the start of the send
queue.

the next time we try to fill the tx ring we'll try to load the same
packet and fail. an empty tx ring means bge_txeof hasnt got anything
which is where the OACTIVE condition is cleared.

this diff adds handling of fragmented packets via m_defrag.

this might fix the issues landry@@ has been complaining about on his
bulk build machines. i can reproduce the above problem in contrived
circumstances here and this diff fixes it, so its going in so landry@@
is forced to test it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.354 2014/04/22 11:54:46 naddy Exp $	*/
d154 1
d1122 1
a1122 1
	m = MCLGETI(NULL, M_DONTWAIT, &sc->arpcom.ac_if, MCLBYTES);
a1156 2
	sc->bge_std_cnt++;

d1171 1
a1171 1
	m = MCLGETI(NULL, M_DONTWAIT, &sc->arpcom.ac_if, BGE_JLEN);
a1227 2
	sc->bge_jumbo_cnt++;

d1258 3
a1260 1
	sc->bge_std_cnt = 0;
d1283 1
a1283 1
	    sc->bge_std_cnt <= 8)
d1286 1
a1286 1
	    sc->bge_jumbo_cnt <= 8)
d1296 1
d1299 2
a1300 1
	while (sc->bge_std_cnt < BGE_STD_RX_RING_CNT) {
a1305 1
		sc->bge_std = i;
d1308 3
d1319 1
a1319 1
	if (sc->bge_std_cnt <= 8)
d1374 3
a1376 1
	sc->bge_jumbo_cnt = 0;
d1401 1
d1404 2
a1405 1
	while (sc->bge_jumbo_cnt < BGE_JUMBO_RX_RING_CNT) {
a1410 1
		sc->bge_jumbo = i;
d1413 3
d1424 1
a1424 1
	if (sc->bge_jumbo_cnt <= 8)
a3006 4
	/* lwm must be greater than the replenish threshold */
	m_clsetwms(ifp, MCLBYTES, 17, BGE_STD_RX_RING_CNT);
	m_clsetwms(ifp, BGE_JLEN, 17, BGE_JUMBO_RX_RING_CNT);

a3462 1
			sc->bge_jumbo_cnt--;
a3477 1
			sc->bge_std_cnt--;
d3528 2
a3529 1
	if (stdcnt)
d3531 3
a3533 1
	if (jumbocnt)
d3535 1
d4488 4
d4504 27
@


1.354
log
@If VLAN_HWTAGGING is disabled, we tell the chip not to strip the
tag from the received frame.  Do not add the tag from the receive
descriptor in this case so that the packet isn't tagged twice.
Matches FreeBSD.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.353 2014/02/24 20:00:48 brad Exp $	*/
d4025 12
a4036 2
	if (bus_dmamap_load_mbuf(sc->bge_dmatag, dmamap, m_head,
	    BUS_DMA_NOWAIT))
d4038 1
@


1.353
log
@Revert rev 1.348 and disable IPv6 TCP checksum offload for the time being.
It has been reported that the offload support is not working properly with
some of the newer ASICs, specifically BCM57780 and BCM57765. It is unknown
what the issue is whether it could be hw, the driver or the stack; so to
be on the safe side it is being disabled all together until the issue
can be investigated further.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.352 2014/02/05 05:59:42 brad Exp $	*/
d3505 2
a3506 1
		if (cur_rx->bge_flags & BGE_RXBDFLAG_VLAN_TAG) {
@


1.352
log
@- Recognize BCM5762 A0 chipset.

- Have the BGE_RXLP_LOCSTAT_IFIN_DROPS workaround cover for the BCM5762 ASIC.
From Linux

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.351 2014/02/04 05:20:47 brad Exp $	*/
a3021 2
	if (BGE_IS_5755_PLUS(sc))
		ifp->if_capabilities |= IFCAP_CSUM_TCPv6;
@


1.351
log
@Revert part of rev 1.329 that involved bringing in some code from FreeBSD
and part of it touched upon the link state handling for the BCM5700 B2
revision of chipset. The special casing of the BCM5700 B2 chipset for
link state handling is wrong and doesn't work. This special casing was
removed in rev 1.229.

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.350 2014/02/01 01:51:27 brad Exp $	*/
d400 1
d3756 14
a3769 16
	 * Unlike other controllers, BGE_RXLP_LOCSTAT_IFIN_DROPS
	 * counter of BCM5717, BCM5718, BCM5719 A0 and BCM5720 A0
	 * includes number of unwanted multicast frames. This comes
	 * from silicon bug and known workaround to get rough(not
	 * exact) counter is to enable interrupt on MBUF low water
	 * attention. This can be accomplished by setting
	 * BGE_HCCMODE_ATTN bit of BGE_HCC_MODE,
	 * BGE_BMANMODE_LOMBUF_ATTN bit of BGE_BMAN_MODE and
	 * BGE_MODECTL_FLOWCTL_ATTN_INTR bit of BGE_MODE_CTL.
	 * However that change would generate more interrupts and
	 * there are still possibilities of losing multiple frames
	 * during BGE_MODECTL_FLOWCTL_ATTN_INTR interrupt handling.
	 * Given that the workaround still would not get correct
	 * counter I don't think it's worth to implement it. So
	 * ignore reading the counter on controllers that have the
	 * silicon bug.
d3772 1
@


1.350
log
@Split bge(4)'s feature flags into bge_flags and bge_phy_flags.

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.349 2014/01/31 01:16:10 brad Exp $	*/
d2458 1
a2458 2
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 &&
		    sc->bge_chipid != BGE_CHIPID_BCM5700_B2)
@


1.349
log
@Fix a long standing VCPU reset sequence bug on BCM5906. The VCPU (Virtual CPU)
of BCM5906 is used to provide a mechanism to control the bootcode execution and
to pick up configuration data stored inside the EEPROM. The bootcode of BCM5906
will check the BGE_VCPU_STATUS_DRV_RESET bit to decide which boot procedure to
choose. Datasheet indicates the VCPU of BCM5906 should set BGE_VCPU_STATUS_DRV_RESET
bit before VCPU reset or global reset.

From FreeBSD

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.348 2014/01/28 21:50:57 naddy Exp $	*/
d2260 1
a2260 1
	if (sc->bge_flags & BGE_PHY_FIBER_TBI)
d2262 1
a2262 1
	else if (sc->bge_flags & BGE_PHY_FIBER_MII)
d2444 1
a2444 1
	if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
d2751 1
a2751 1
		sc->bge_flags |= BGE_NO_3LED;
d2776 1
a2776 1
		sc->bge_flags |= BGE_10_100_ONLY;
d2783 1
a2783 1
		sc->bge_flags |= BGE_NO_ETH_WIRE_SPEED;
d2787 1
a2787 1
		sc->bge_flags |= BGE_PHY_CRC_BUG;
d2790 1
a2790 1
		sc->bge_flags |= BGE_PHY_ADC_BUG;
d2792 1
a2792 1
		sc->bge_flags |= BGE_PHY_5704_A0_BUG;
d2805 1
a2805 1
				sc->bge_flags |= BGE_PHY_JITTER_BUG;
d2807 1
a2807 1
				sc->bge_flags |= BGE_PHY_ADJUST_TRIM;
d2809 1
a2809 1
			sc->bge_flags |= BGE_PHY_BER_BUG;
d3060 1
a3060 1
		    sc->bge_flags |= BGE_PHY_FIBER_TBI;
d3062 1
a3062 1
		    sc->bge_flags |= BGE_PHY_FIBER_MII;
d3088 1
a3088 1
	if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
d3106 1
a3106 1
		if (sc->bge_flags & BGE_PHY_FIBER_MII)
d3373 1
a3373 1
	if (sc->bge_flags & BGE_PHY_FIBER_TBI &&
d3721 1
a3721 1
	if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
d4305 1
a4305 1
	if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
d4382 1
a4382 1
	if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
d4442 1
a4442 1
		if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
d4462 1
a4462 1
		if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
d4606 1
a4606 1
	if (!(sc->bge_flags & BGE_PHY_FIBER_TBI)) {
d4672 1
a4672 1
	if (sc->bge_flags & BGE_PHY_FIBER_TBI) {
@


1.348
log
@Enable IPv6 TCP checksum offload; ok brad@@
(UDP is broken over both IPv4 and IPv6, verified on BCM5761.)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.347 2014/01/28 00:39:22 brad Exp $	*/
d3243 11
a3268 13

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906) {
		u_int32_t status, ctrl;

		status = CSR_READ_4(sc, BGE_VCPU_STATUS);
		CSR_WRITE_4(sc, BGE_VCPU_STATUS,
		    status | BGE_VCPU_STATUS_DRV_RESET);
		ctrl = CSR_READ_4(sc, BGE_VCPU_EXT_CTRL);
		CSR_WRITE_4(sc, BGE_VCPU_EXT_CTRL,
		    ctrl & ~BGE_VCPU_EXT_CTRL_HALT_CPU);

		sc->bge_flags |= BGE_NO_EEPROM;
	}
@


1.347
log
@- Bring in some fixes/workarounds for BCM5719 / BCM5720 / BCM57765 and BCM57766
  chipsets
- Add support for the new BCM5762 ASIC (BCM5725 / BCM5727 / BCM57767)
- Add all of the newer PCI ids

Tested with BCM5719 / BCM5720 and BCM57765 / BCM57766 and a bunch of older
chipsets.

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.346 2013/12/30 18:47:45 brad Exp $	*/
d3022 2
@


1.346
log
@Expand the MSI support to cover most of the remaining bge(4) chipsets with the
exception being the BCM5714 family for now.

Tested on a variety of newer chipsets.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.345 2013/12/28 03:34:54 deraadt Exp $	*/
d260 1
d267 2
d286 1
d309 1
d312 1
d315 1
d318 1
d445 1
d1658 14
d1747 3
a1749 2
		if (BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5717 &&
		    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM57765)
d1759 2
a1760 1
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720) {
d1801 1
a1801 1
	CSR_WRITE_4(sc, BGE_MISC_CFG, 65 << 1/*BGE_32BITTIME_66MHZ*/);
d1819 1
a1819 1
	u_int32_t		dmactl, mimode, val;
d2078 6
a2083 1
	} else
d2121 1
d2162 2
a2163 1
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720)
d2318 2
a2319 1
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720) {
d2333 6
a2338 2
	    BGE_IS_5717_PLUS(sc)) {
		dmactl = CSR_READ_4(sc, BGE_RDMA_RSRVCTRL);
d2343 2
a2344 2
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719 ||
		    sc->bge_chipid == BGE_CHIPID_BCM5719_A0) {
d2357 1
a2357 1
		CSR_WRITE_4(sc, BGE_RDMA_RSRVCTRL, dmactl |
d2375 5
d2385 18
d2604 6
d2618 1
d2688 1
d2698 8
d2818 1
d2983 1
a2983 1
	if (BGE_IS_5717_PLUS(sc))
d2985 1
a2985 1
	else if (BGE_IS_5705_PLUS(sc))
a2986 2
	else
		sc->bge_return_ring_cnt = BGE_RETURN_RING_CNT;
d3782 26
d4244 2
a4245 1
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720) {
d4258 2
d4265 10
a4274 1
	CSR_WRITE_4(sc, BGE_MAX_RX_FRAME_LOWAT, 2);
@


1.345
log
@The few network drivers that called their children's (ie. mii PHY
drivers) activate functions at DVACT_RESUME time do not need to do
so, since their PHYs are repaired by IFF_UP.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.344 2013/12/22 20:39:23 kettenis Exp $	*/
d127 1
d2439 26
d2774 6
d2781 2
a2782 2
	if (BGE_IS_5717_PLUS(sc) && pci_intr_map_msi(pa, &ih) == 0)
		sc->bge_flags |= BGE_TAGGED_STATUS;
d2788 8
d2989 3
a2991 6
	if ((BGE_IS_5717_PLUS(sc) && sc->bge_flags & BGE_TAGGED_STATUS)) {
		reg = CSR_READ_4(sc, BGE_MSI_MODE);
		reg &= ~BGE_MSIMODE_ONE_SHOT_DISABLE;
		reg |= BGE_MSIMODE_ENABLE;
		CSR_WRITE_4(sc, BGE_MSI_MODE, reg);
	}
d3233 1
a3233 1
	/* Enable memory arbiter. */
d3235 11
@


1.344
log
@Add support for BCM57786,which seems to be almost indistinguishable from the
BCM57785.

Tested by Mark Rowland.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.343 2013/12/06 21:03:03 deraadt Exp $	*/
a3053 1
		rv = config_activate_children(self, act);
@


1.343
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.342 2013/11/26 20:35:36 deraadt Exp $	*/
d309 1
d2526 1
@


1.342
log
@spelling; Kent R. Spillner
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.341 2013/10/23 20:38:23 brad Exp $	*/
a3043 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
d3052 3
@


1.341
log
@Enable TX checksum offload.

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.340 2013/08/25 18:34:21 mikeb Exp $	*/
d1764 1
a1764 1
	 * Must insure that we do not cross an 8K (bytes) boundary
d3245 1
a3245 1
	 * adjustment to insure the SERDES drive level is set
d4055 1
a4055 1
	 * memory to insure that the chip has in fact read the first
@


1.340
log
@call if_link_state_change when link state actually changes;  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.339 2013/08/07 01:06:33 bluhm Exp $	*/
d2896 5
d2903 1
a2903 4
		ifp->if_capabilities |= IFCAP_CSUM_IPv4;
#if 0	/* TCP/UDP checksum offload breaks with pf(4) */
		ifp->if_capabilities |= IFCAP_CSUM_TCPv4|IFCAP_CSUM_UDPv4;
#endif
@


1.339
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.338 2013/07/11 11:25:42 mikeb Exp $	*/
d4517 1
a4517 2
				ifp->if_link_state =
				    (status & BGE_MACMODE_HALF_DUPLEX) ?
a4519 1
				if_link_state_change(ifp);
d4521 4
d4528 1
a4528 2
			ifp->if_link_state = LINK_STATE_DOWN;
			if_link_state_change(ifp);
d4530 4
@


1.338
log
@use fls as initially intended
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.337 2013/06/28 11:59:42 mikeb Exp $	*/
a94 1
#include <netinet/in_var.h>
@


1.337
log
@Turns out that BGE_STATFLAG_UPDATED bit in the status block doesn't get
properly updated by the newer hardware (seen in the TX completion case).
This leads to very poor transmit performance in the beginning of a TCP
connection.   Linux and FreeBSD don't rely on BGE_STATFLAG_UPDATED bit
since they enable MSI and tagged status for 5717+.  Doing the same does
indeed fix an issue.

Change was tested by David Imhoff on 5719, 5720 and 5721/5750, Hrvoje
Popovski on 5704 B0, sthen@@ on 5723/5784, benno@@ on 5704 A3, and
me on 5719, 5720 adn 5714/5715.  No objections from kettenis@@ and dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.336 2013/06/25 10:08:04 mikeb Exp $	*/
d2558 1
a2558 1
			sc->bge_expmrq = 0x4000; /* (fls(2048) - 8) << 12 */
d2560 1
a2560 1
			sc->bge_expmrq = 0x5000; /* (fls(4096) - 8) << 12 */
@


1.336
log
@Repair flow control broken in the rev1.329 and make sure that a simple
ifconfig done by a user won't alter our negotiated flow control settings.
Both problems were identified by David Imhoff <dimhoff_devel @@ xs4all !nl>
Tested by David on 5719, 5720, 5721, Hrvoje Popovski on 5704 B0, sthen@@ on
5723/5784, naddy@@ and jmatthew@@ on 5702/5703, benno@@ on 5704 A3 and me on
5715 and 5719.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.335 2013/06/10 13:38:47 mikeb Exp $	*/
d1626 1
a1626 1
	u_int32_t dma_rw_ctl, mode_ctl;
d1630 3
d1634 1
a1634 1
	    BGE_INIT);
a2490 9
	DPRINTFN(5, ("pci_intr_map\n"));
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		goto fail_1;
	}

	DPRINTFN(5, ("pci_intr_string\n"));
	intrstr = pci_intr_string(pc, ih);

d2746 11
d2944 8
d3521 1
a3521 2
	u_int32_t statusword;
	u_int32_t intrmask = BGE_PCISTATE_INTR_NOT_ACTIVE;
a3525 9
	if (BGE_IS_5717_PLUS(sc))
		intrmask = 0;

	/* It is possible for the interrupt to arrive before
	 * the status block is updated prior to the interrupt.
	 * Reading the PCI State register will confirm whether the
	 * interrupt is ours and will flush the status block.
	 */

d3533 1
d3535 11
a3545 3
	if ((statusword & BGE_STATFLAG_UPDATED) ||
	    (~CSR_READ_4(sc, BGE_PCI_PCISTATE) & intrmask)) {

d3548 2
a3549 3
			
		/* clear status word */
		sc->bge_rdata->bge_status_block.bge_status = 0;
d3551 2
a3552 4
		bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
		    offsetof(struct bge_ring_data, bge_status_block),
		    sizeof (struct bge_status_block),
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d3554 4
a3557 4
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
		    statusword & BGE_STATFLAG_LINKSTATE_CHANGED ||
		    BGE_STS_BIT(sc, BGE_STS_LINK_EVT))
			bge_link_upd(sc);
d3559 11
a3569 3
		if (ifp->if_flags & IFF_RUNNING) {
			/* Check RX return ring producer/consumer */
			bge_rxeof(sc);
d3571 2
a3572 3
			/* Check TX ring producer/consumer */
			bge_txeof(sc);
		}
d3574 3
a3576 2
		/* Re-enable interrupts. */
		bge_writembx(sc, BGE_MBX_IRQ0_LO, 0);
d3578 1
a3578 5
		bge_start(ifp);

		return (1);
	} else
		return (0);
@


1.335
log
@A couple of changes from Masanobu SAITOH <msaitoh@@netbsd.org>:

 - fixup the Random Backoff Register value masking;

 - keep the GPIO settings when modifying the Misc Local Control
   register value.

Tested by Rob Sessink on 5719, David Imhoff on 5719, 5720, 5721,
me on 5719 and 5715;  ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.334 2013/06/06 00:05:30 dlg Exp $	*/
d1055 1
a1055 1
	    (mii->mii_media_active & IFM_ETH_FMASK) != sc->bge_flowflags) {
a1056 2
		mii->mii_media_active &= ~IFM_ETH_FMASK;
	}
d1085 1
a1085 1
	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX) {
a4544 1
		bge_miibus_statchg(&sc->bge_dev);
@


1.334
log
@dont count rx ring overruns as input errors. with MCLGETI controlling the
ring we expect to run out of rx descriptors as a matter of course, its not
an error.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.333 2013/06/04 09:47:25 mikeb Exp $	*/
d2122 3
a2124 3
	    sc->arpcom.ac_enaddr[0] + sc->arpcom.ac_enaddr[1] +
	    sc->arpcom.ac_enaddr[2] + sc->arpcom.ac_enaddr[3] +
	    sc->arpcom.ac_enaddr[4] + sc->arpcom.ac_enaddr[5] +
d2242 1
a2242 1
	CSR_WRITE_4(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_INTR_ONATTN);
@


1.333
log
@A couple of style/comment fixes from FreeBSD, with input from
David Imhoff.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.332 2013/06/04 09:41:50 mikeb Exp $	*/
d3644 1
a3644 2
	ifp->if_ierrors = sc->bge_rx_discards + sc->bge_rx_inerrors +
	    sc->bge_rx_overruns;
a3661 1
	ifp->if_ierrors += (uint32_t)(cnt - sc->bge_rx_overruns);
@


1.332
log
@Substitute a couple of magic numbers with newly added PCIE
DCTL flag defines.  Now with the right defines, doh!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.331 2013/06/04 09:36:20 mikeb Exp $	*/
a2358 1

a2360 2

	/* Turn on send data completion state machine */
d3238 3
a3240 5
		u_int32_t serdescfg;

		serdescfg = CSR_READ_4(sc, BGE_SERDES_CFG);
		serdescfg = (serdescfg & ~0xFFF) | 0x880;
		CSR_WRITE_4(sc, BGE_SERDES_CFG, serdescfg);
d3247 3
a3249 5
		u_int32_t v;

		/* Enable PCI Express bug fix */
		v = CSR_READ_4(sc, 0x7c00);
		CSR_WRITE_4(sc, 0x7c00, v | (1<<25));
@


1.331
log
@Substitute a couple of magic numbers with newly added PCIE
DCTL flag defines.  No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.330 2013/05/31 14:27:20 mikeb Exp $	*/
d3163 2
a3164 2
		devctl |= PCI_PCIE_DCSR_CED | PCI_PCIE_DCSR_NED |
		    PCI_PCIE_DCSR_FED | PCI_PCIE_DCSR_URD;
@


1.330
log
@New logic to accommodate the E5/C600 and 5719/5720 changes in PCI-E
maximum payload size handling from FreeBSD.  Fixes RX path on 5719
found in newer machines such as HP DL3[68]0 G8 and Dell R320.

Tested by dlg@@ on 5714, 5719 (Sun V445) and 5720, 5721 (Dell R420);
David Imhoff on 5719, 5720, 5721 (various Dell servers);
Rob Sessnik on 5719 (HP DL360p G8); mikeb@@ on 5719 (HP DL380p G8).

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.329 2013/05/29 17:04:46 mikeb Exp $	*/
d3159 1
a3159 1
		devctl &= ~(0x10 | 0x800);
d3161 1
a3161 2
		devctl &= ~0x7000;
		devctl |= sc->bge_expmrq;
d3163 2
a3164 1
		devctl |= 0xf0000;
@


1.329
log
@PHY auto-polling mode should not be used for anything newer than BCM5705.
Figured out by David Imhoff, checked against FreeBSD, Linux and official
documentation.  Fixes up link negotiation on BCM5719.

Original diff by David, tweaked by me; tested on BCM5702X and BCM5761 by
naddy@@; BCM5714, BCM5719, BCM5720 and BCM5721 by dlg@@, BCM5721 and
BCM5719 by David and BCM5719 by me.  ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.328 2013/05/22 16:02:31 mikeb Exp $	*/
d1654 4
a1657 2
		/* Read watermark not used, 128 bytes for write. */
		dma_rw_ctl |= BGE_PCIDMARWCTL_WR_WAT_SHIFT(3);
d2466 1
a2466 1
	int			rseg, gotenaddr = 0, aspm_off;
d2562 10
a2571 1
	    &aspm_off, NULL) != 0) {
d2574 1
a2574 1
		    aspm_off + PCI_PCIE_LCSR);
d2577 1
a2577 1
		    aspm_off + PCI_PCIE_LCSR, reg);
d3056 1
a3056 1
	pcireg_t cachesize, command;
d3156 11
a3166 6
		/*
		 * Set PCI Express max payload size to 128 bytes
		 * and clear error status.
		 */
		pci_conf_write(pa->pa_pc, pa->pa_tag,
		    BGE_PCI_CONF_DEV_CTRL, 0xf5000);
@


1.328
log
@BUS_DMA_WAITOK can't be used in the bge_init path since it
might be called from a timeout(9); ok kettenis, dlg, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.327 2013/04/07 03:22:05 dlg Exp $	*/
d1060 12
d1790 1
a1790 1
	u_int32_t		dmactl, val;
d2386 13
a2398 3
		BGE_STS_SETBIT(sc, BGE_STS_AUTOPOLL);
		BGE_SETBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL|10<<16);
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700)
a2745 3
	if ((sc->bge_flags & BGE_CPMU_PRESENT) != 0)
		BGE_SETBIT(sc, BGE_MI_MODE, BGE_MIMODE_500KHZ_CONST);

a4512 5
	/*
	 * Discard link events for MII/GMII cards if MI auto-polling disabled.
	 * This should not happen since mii callouts are locked now, but
	 * we keep this check for debug.
	 */
d4534 7
@


1.327
log
@check BGE_SGDIG_STS when the chip is NOT a 5717 A0, like freebsd.

found by david imhoff.
tested by david on a 5719 and by me on a 5720 and 5721
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.326 2013/04/03 18:07:07 brad Exp $	*/
d1229 1
a1229 1
		    BUS_DMA_WAITOK | BUS_DMA_ALLOCNOW,
d1339 1
a1339 1
		    BUS_DMA_WAITOK | BUS_DMA_ALLOCNOW,
@


1.326
log
@Fix a typo in the bge_ape_lock_init() function.

From David Imhoff.

ok dlg@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.325 2013/03/20 02:46:33 brad Exp $	*/
d1597 1
a1597 1
		if (sc->bge_chipid == BGE_CHIPID_BCM5717_A0) {
@


1.325
log
@- Sync the ring setup code closer to FreeBSD's driver
- Do not touch the jumbo replenish threshold register on chips that do not have jumbo support
- Add/sync some of the comments

From FreeBSD

Tested by dlg@@ sthen@@ naddy@@ and OK dlg@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.324 2013/03/17 10:17:54 brad Exp $	*/
d513 1
a513 1
			if (pa->pa_function != 0)
@


1.324
log
@- Sync some of the stats counter code to be closer to the FreeBSD code,
  but no functional change.
- Add a workaround for BCM5717 / BCM5718 / BCM5719 A0 and BCM5720 A0 chipsets
  to not count the interface input drops counter for input errors due to HW
  errata.

From FreeBSD

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.323 2013/03/11 01:12:40 dlg Exp $	*/
a1776 1
	int			i;
d1779 1
d1873 31
d1907 16
a1922 4
	if (BGE_IS_5717_PLUS(sc))
		rcb->bge_maxlen_flags = (BGE_RCB_MAXLEN_FLAGS(512, 0) |
					(ETHER_MAX_DIX_LEN << 2));
	else if (BGE_IS_5705_PLUS(sc))
d1924 8
a1931 1
	else
d1934 1
d1941 1
a1941 1

d1947 3
a1968 1

a1996 1

d2008 5
d2021 2
a2022 1
	CSR_WRITE_4(sc, BGE_RBDI_JUMBO_REPL_THRESH, 8);
d2030 3
a2032 3
	 * Disable all unused send rings by setting the 'ring disabled'
	 * bit in the flags field of all the TX send ring control blocks.
	 * These are located in NIC memory.
d2034 5
d2040 1
a2040 1
	for (i = 0; i < BGE_TX_RINGS_EXTSSRAM_MAX; i++) {
d2047 1
a2047 1
	/* Configure TX RCB 0 (we use only the first ring) */
d2059 2
a2060 3
	if (BGE_IS_5700_FAMILY(sc))
		RCB_WRITE_4(sc, rcb_addr, bge_maxlen_flags,
		    BGE_RCB_MAXLEN_FLAGS(BGE_TX_RING_CNT, 0));
d2062 18
a2079 1
	/* Disable all unused RX return rings */
d2081 1
a2081 1
	for (i = 0; i < BGE_RX_RINGS_MAX; i++) {
d2094 3
a2096 4
	 * Set up RX return ring 0
	 * Note that the NIC address for RX return rings is 0x00000000.
	 * The return rings live entirely within the host, so the
	 * nicaddr field in the RCB isn't used.
@


1.323
log
@flush writes to BGE_MI_COMM by doing a read straight after. helps avoid
"APE lock request failed!" errors with HP 331T (5719) and 332T (5720)
cards.

found and fixed by masanobu saitoh
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.322 2013/03/07 21:35:19 brad Exp $	*/
d3506 1
a3506 1
	ifp->if_collisions += CSR_READ_4(sc, BGE_MAC_STATS +
d3509 26
a3534 1
	sc->bge_rx_discards += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_IFIN_DROPS);
a3535 1
	sc->bge_rx_overruns += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_OUT_OF_BDS);
d3537 1
d3556 6
a3564 8

	cnt = READ_STAT(sc, stats, ifInErrors.bge_addr_lo);
	ifp->if_ierrors += (u_int32_t)(cnt - sc->bge_rx_inerrors);
	sc->bge_rx_inerrors = cnt;

	cnt = READ_STAT(sc, stats, nicNoMoreRxBDs.bge_addr_lo);
	ifp->if_ierrors += (u_int32_t)(cnt - sc->bge_rx_overruns);
	sc->bge_rx_overruns = cnt;
@


1.322
log
@Add the PCI ids for the BCM57762 and BCM57766 chipsets.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.321 2013/03/07 19:30:52 brad Exp $	*/
d964 1
d1022 1
@


1.321
log
@Correct the location of a DELAY() that was mismerged from FreeBSD in rev 1.319
within the ifmedia update function. It is supposed to come after the BGE_MAC_MODE
register write.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.320 2013/03/04 01:33:18 dlg Exp $	*/
d304 1
d306 1
@


1.320
log
@fix format string issue when printing an error our on bge's with APE and
more than 4 pci functions.

pointed out by masanobu saitoh
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.319 2013/02/22 01:26:55 dlg Exp $	*/
a4023 1
			DELAY(40);
d4033 1
@


1.319
log
@bring back 5718/5719/5720 support again. deraadt pointed out that
the problems i had on the xserve g5 are mostly likely specific to
that machine and im inclined to agree. we're going to see a lot
more machines with the new chips than people with xserve g5s.

this also includes fixes for ip checksum handling compared to the
code i put in before.

tested by various people again.
sthen@@ and claudio@@ have agreed to babysit this. they can back it
out if im not around.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.318 2013/02/09 23:39:37 brad Exp $	*/
d535 1
a535 1
		    sc->bge_dev.dv_xname);
@


1.318
log
@- Use a switch statement for setting the chipset flags
- Add some macros for working with the various newer generations of chipsets
- Make use of the 5717 macro in a few places
- Add some bits for identifying and supporting some of the newer chipsets

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.317 2013/01/30 11:15:06 dlg Exp $	*/
d141 1
d184 1
d196 7
d206 7
d261 2
d442 5
d449 3
a451 1
	return (pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_MEMWIN_DATA));
d459 4
d465 1
d486 318
d949 3
d957 1
a957 1
		DELAY(40);
d983 1
a983 1
		DELAY(40);
d986 2
d1001 7
d1014 1
a1014 1
		DELAY(10); /* 40 usec is supposed to be adequate */
d1033 2
d1045 1
d1056 6
a1061 1
	BGE_CLRBIT(sc, BGE_MAC_MODE, BGE_MACMODE_PORTMODE);
d1064 1
a1064 1
		BGE_SETBIT(sc, BGE_MAC_MODE, BGE_PORTMODE_GMII);
d1066 1
a1066 1
		BGE_SETBIT(sc, BGE_MAC_MODE, BGE_PORTMODE_MII);
d1068 10
a1077 12
	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX)
		BGE_CLRBIT(sc, BGE_MAC_MODE, BGE_MACMODE_HALF_DUPLEX);
	else
		BGE_SETBIT(sc, BGE_MAC_MODE, BGE_MACMODE_HALF_DUPLEX);

	/*
	 * 802.3x flow control
	 */
	if (sc->bge_flowflags & IFM_ETH_RXPAUSE)
		BGE_SETBIT(sc, BGE_RX_MODE, BGE_RXMODE_FLOWCTL_ENABLE);
	else
		BGE_CLRBIT(sc, BGE_RX_MODE, BGE_RXMODE_FLOWCTL_ENABLE);
d1079 4
a1082 4
	if (sc->bge_flowflags & IFM_ETH_TXPAUSE)
		BGE_SETBIT(sc, BGE_TX_MODE, BGE_TXMODE_FLOWCTL_ENABLE);
	else
		BGE_CLRBIT(sc, BGE_TX_MODE, BGE_TXMODE_FLOWCTL_ENABLE);
d1538 44
d1612 1
a1612 1
	u_int32_t dma_rw_ctl;
a1618 3
	/* Clear the MAC control register */
	CSR_WRITE_4(sc, BGE_MAC_MODE, 0);

d1689 1
a1689 1
 
d1694 15
d1714 10
a1723 3
	CSR_WRITE_4(sc, BGE_MODE_CTL, BGE_DMA_SWAP_OPTIONS|
		    BGE_MODECTL_MAC_ATTN_INTR|BGE_MODECTL_HOST_SEND_BDS|
		    BGE_MODECTL_TX_NO_PHDR_CSUM);
d1733 3
a1735 1
		BGE_SETBIT(sc, BGE_MODE_CTL, BGE_MODECTL_FORCE_PCI32);
d1775 1
a1775 1
	u_int32_t		val;
d1786 1
a1786 1
	if (BGE_IS_5700_FAMILY(sc)) {
d1828 10
a1837 2
	CSR_WRITE_4(sc, BGE_BMAN_MODE,
	    BGE_BMANMODE_ENABLE|BGE_BMANMODE_LOMBUF_ATTN);
d1880 7
a1886 1
	rcb->bge_nicaddr = BGE_STD_RX_RINGS;
d1905 6
a1910 1
		rcb->bge_nicaddr = BGE_JUMBO_RX_RINGS;
d1916 1
d1919 4
a1922 2
		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_NICADDR,
		    rcb->bge_nicaddr);
d1924 2
d1932 2
d1935 1
d1940 1
d1985 6
a1990 1
	RCB_WRITE_4(sc, rcb_addr, bge_nicaddr,
a2009 5
	/* Initialize RX ring indexes */
	bge_writembx(sc, BGE_MBX_RX_STD_PROD_LO, 0);
	bge_writembx(sc, BGE_MBX_RX_JUMBO_PROD_LO, 0);
	bge_writembx(sc, BGE_MBX_RX_MINI_PROD_LO, 0);

d2032 5
a2036 1
	CSR_WRITE_4(sc, BGE_TX_LENGTHS, 0x2620);
d2051 1
a2051 1
	CSR_WRITE_4(sc, BGE_RXLP_STATS_ENABLE_MASK, 0x007FFFFF);
d2075 1
a2075 1
	if (BGE_IS_5700_FAMILY(sc)) {
d2083 1
a2083 1
	if (BGE_IS_5700_FAMILY(sc)) {
d2101 10
d2112 1
a2112 1
	CSR_WRITE_4(sc, BGE_HCC_MODE, BGE_HCCMODE_ENABLE);
d2122 1
a2122 1
	if (BGE_IS_5700_FAMILY(sc))
d2137 4
d2143 1
d2157 1
a2157 1
	if (BGE_IS_5700_FAMILY(sc))
d2171 1
d2188 54
a2241 1
	/* Turn on read DMA state machine */
d2243 1
d2255 1
a2255 1
	if (BGE_IS_5700_FAMILY(sc))
d2261 1
d2279 1
a2279 1
	CSR_WRITE_4(sc, BGE_SDI_STATS_ENABLE_MASK, 0x007FFFFF);
d2284 2
a2285 2
	CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED|
	    BGE_MACSTAT_CFG_CHANGED|BGE_MACSTAT_MI_COMPLETE|
d2358 1
a2358 1
	bus_size_t		size;
a2527 18
	/* Identify chips with APE processor. */
	switch (BGE_ASICREV(sc->bge_chipid)) {
	case BGE_ASICREV_BCM5717:
	case BGE_ASICREV_BCM5719:
	case BGE_ASICREV_BCM5720:
	case BGE_ASICREV_BCM5761:
		sc->bge_flags |= BGE_APE;
		break;
	}

	/* Identify the chips that use an CPMU. */
	if (BGE_IS_5717_PLUS(sc) ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5785 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57780)
		sc->bge_flags |= BGE_CPMU_PRESENT;

d2604 41
d2647 1
d2650 3
d2706 1
a2706 1
		goto fail_1;
d2715 1
a2715 1
		goto fail_1;
d2723 1
a2723 1
		goto fail_2;
d2730 1
a2730 1
		goto fail_3;
d2736 1
a2736 1
		goto fail_4;
d2751 2
a2752 2
	/* BCM5705+ limits RX return ring to 512 entries. */
	if (BGE_IS_5700_FAMILY(sc) || BGE_IS_5717_PLUS(sc))
d2754 2
d2757 1
a2757 1
		sc->bge_return_ring_cnt = BGE_RETURN_RING_CNT_5705;
d2818 1
a2818 1
			goto fail_5;
d2841 1
a2841 1
		goto fail_5;
d2894 1
a2894 1
fail_5:
d2897 1
a2897 1
fail_4:
d2900 1
a2900 1
fail_3:
d2904 3
d2908 2
a2909 1
	bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
d2944 21
a2964 3
	pcireg_t cachesize, command, pcistate, new_pcistate;
	u_int32_t reset;
	int i, val = 0;
a2968 1
	pcistate = pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE);
d2971 2
a2972 2
	    BGE_PCIMISCCTL_INDIRECT_ACCESS|BGE_PCIMISCCTL_MASK_PCI_INTR|
	    BGE_PCIMISCCTL_ENDIAN_WORDSWAP|BGE_PCIMISCCTL_PCISTATE_RW);
d2979 8
a2986 1
	reset = BGE_MISCCFG_RESET_CORE_CLOCKS|(65<<1);
d2989 6
a2994 3
		if (CSR_READ_4(sc, 0x7e2c) == 0x60) {
			/* PCI Express 1.0 system */
			CSR_WRITE_4(sc, 0x7e2c, 0x20);
d3010 2
a3011 1
	if (BGE_IS_5705_PLUS(sc))
d3015 6
a3020 1
	bge_writereg_ind(sc, BGE_MISC_CFG, reset);
a3034 2
	DELAY(1000);

d3054 11
a3064 2
	    BGE_PCIMISCCTL_INDIRECT_ACCESS|BGE_PCIMISCCTL_MASK_PCI_INTR|
	    BGE_PCIMISCCTL_ENDIAN_WORDSWAP|BGE_PCIMISCCTL_PCISTATE_RW);
a3066 1
	bge_writereg_ind(sc, BGE_MISC_CFG, (65 << 1));
a3069 2
		u_int32_t val;

d3075 9
a3083 5
 	/*
	 * Prevent PXE restart: write a magic number to the
	 * general communications memory at 0xB50.
	 */
	bge_writemem_ind(sc, BGE_SOFTWARE_GENCOMM, BGE_MAGIC_NUMBER);
d3112 3
a3117 27
	 * XXX Wait for the value of the PCISTATE register to
	 * return to its original pre-reset state. This is a
	 * fairly good indicator of reset completion. If we don't
	 * wait for the reset to fully complete, trying to read
	 * from the device's non-PCI registers may yield garbage
	 * results.
	 */
	for (i = 0; i < BGE_TIMEOUT; i++) {
		new_pcistate = pci_conf_read(pa->pa_pc, pa->pa_tag,
		    BGE_PCI_PCISTATE);
		if ((new_pcistate & ~BGE_PCISTATE_RESERVED) ==
		    (pcistate & ~BGE_PCISTATE_RESERVED))
			break;
		DELAY(10);
	}
	if ((new_pcistate & ~BGE_PCISTATE_RESERVED) != 
	    (pcistate & ~BGE_PCISTATE_RESERVED)) {
		DPRINTFN(5, ("%s: pcistate failed to revert\n",
		    sc->bge_dev.dv_xname));
	}

	/* Fix up byte swapping */
	CSR_WRITE_4(sc, BGE_MODE_CTL, BGE_DMA_SWAP_OPTIONS);

	CSR_WRITE_4(sc, BGE_MAC_MODE, 0);

	/*
d3141 4
a3144 1
	DELAY(10000);
d3254 1
a3254 1
		m->m_pkthdr.len = m->m_len = cur_rx->bge_len - ETHER_CRC_LEN; 
d3257 1
a3257 20
		/*
		 * 5700 B0 chips do not support checksumming correctly due
		 * to hardware bugs.
		 */
		if (sc->bge_chipid != BGE_CHIPID_BCM5700_B0) {
			if (cur_rx->bge_flags & BGE_RXBDFLAG_IP_CSUM) {
				if (cur_rx->bge_ip_csum == 0xFFFF)
					m->m_pkthdr.csum_flags |=
					    M_IPV4_CSUM_IN_OK;
				else
					m->m_pkthdr.csum_flags |=
					    M_IPV4_CSUM_IN_BAD;
			}
			if (cur_rx->bge_flags & BGE_RXBDFLAG_TCP_UDP_CSUM &&
			    m->m_pkthdr.len >= ETHER_MIN_NOPAD) {
				if (cur_rx->bge_tcp_udp_csum == 0xFFFF)
					m->m_pkthdr.csum_flags |=
					    M_TCP_CSUM_IN_OK|M_UDP_CSUM_IN_OK;
			}
		}
d3286 35
d3401 1
d3406 3
d3416 5
d3424 1
a3424 1
	    (!(CSR_READ_4(sc, BGE_PCI_PCISTATE) & BGE_PCISTATE_INTR_NOT_ACTIVE))) {
d3432 5
d3490 1
a3490 1
	}       
d3505 3
a3507 3
	ifp->if_ierrors += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_IFIN_DROPS);

	ifp->if_ierrors += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_IFIN_ERRORS);
d3509 2
a3510 1
	ifp->if_ierrors += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_OUT_OF_BDS);
d3860 1
a3860 1
	u_int32_t rxmode;
d3869 1
d3871 3
d3945 11
d3957 2
a3958 3
	BGE_SETBIT(sc, BGE_TX_MODE, BGE_TXMODE_ENABLE);

	rxmode = BGE_RXMODE_ENABLE;
d3960 1
d3962 1
a3962 1
		rxmode |= BGE_RXMODE_RX_IPV6_CSUM_ENABLE;
d3965 2
a3966 1
	BGE_SETBIT(sc, BGE_RX_MODE, rxmode);
d4024 1
d4229 7
d4271 1
a4271 1
	if (BGE_IS_5700_FAMILY(sc)) {
d4276 3
a4278 3
	/* Disable host interrupts. */
	BGE_SETBIT(sc, BGE_PCI_MISC_CTL, BGE_PCIMISCCTL_MASK_PCI_INTR);
	bge_writembx(sc, BGE_MBX_IRQ0_LO, 1);
d4364 1
a4364 1
	} 
d4389 1
a4389 1
        /*
d4395 1
a4395 1
		/* 
@


1.317
log
@backout 5718/5719/5720 support. the diff breaks the 5704C on my xserve g5
and i cant fix it without breaking a 5721 in another box.

sthen@@ agrees it is sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.315 2013/01/15 05:11:47 claudio Exp $	*/
d304 2
d307 2
a308 1
#define BGE_IS_5750_PLUS(sc)		((sc)->bge_flags & BGE_5750_PLUS)
d310 2
a311 3
#define BGE_IS_5700_FAMILY(sc)		((sc)->bge_flags & BGE_5700_FAMILY)
#define BGE_IS_5714_FAMILY(sc)		((sc)->bge_flags & BGE_5714_FAMILY)
#define BGE_IS_JUMBO_CAPABLE(sc)	((sc)->bge_flags & BGE_JUMBO_CAPABLE)
d361 4
d379 2
d399 1
a402 1
	{ BGE_ASICREV_BCM5714, "unknown BCM5714" },
d410 2
d414 2
a415 1
	{ BGE_ASICREV_BCM57765, "unknown BCM57765" },
d1372 1
a1372 2
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765) {
d1433 1
a1433 2
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765)
d1503 1
a1503 2
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765) {
d1886 2
d1892 1
d1894 1
a1951 5
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5703 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704)
		sc->bge_flags |= BGE_5700_FAMILY;
d1953 29
a1981 3
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714_A0 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5780 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714)
d1983 20
d2004 3
a2006 3
	/* Intentionally exclude BGE_ASICREV_BCM5906 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5755 ||
a2007 1
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784 ||
a2008 2
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5787 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765 ||
d2010 1
a2010 12
		sc->bge_flags |= BGE_5755_PLUS;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5750 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5752 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906 ||
	    BGE_IS_5755_PLUS(sc) ||
	    BGE_IS_5714_FAMILY(sc))
		sc->bge_flags |= BGE_5750_PLUS;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5705 ||
	    BGE_IS_5750_PLUS(sc))
		sc->bge_flags |= BGE_5705_PLUS;
a2023 3
	if (BGE_IS_5700_FAMILY(sc))
		sc->bge_flags |= BGE_JUMBO_CAPABLE;

a2071 1
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5717 &&
d2073 2
a2074 2
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM57765 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM57780) {
d2190 2
a2191 4
	/* 5705 limits RX return ring to 512 entries. */
	if (BGE_IS_5700_FAMILY(sc) ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765)
d2548 1
d2550 1
a2550 3
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5717 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5785 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM57765) {
@


1.316
log
@big pullup of bge to support the 5718 family of chips including the
5719 and 5720 chips that have popped up in a lot of new machines.

this diff is largely a merge of the freebsd code. thanks to srebrenko
sehic for providing me hardware to do the work on. also, a huge
thanks to claudio for trawling through the diff to fix merge issues,
understand the changes, and actually make it work.

tested by sthen@@ naddy@@ jmatthew@@ claudio@@ jj@@ and me

tested chips include:

bge0 at pci2 dev 3 function 0 "Broadcom BCM5704C" rev 0x10, BCM5704 B0 (0x2100): apic 2 int 8, address 00:30:48:59:52:44
brgphy0 at bge0 phy 1: BCM5704 10/100/1000baseT PHY, rev. 0

bge0 at pci3 dev 0 function 0 "Broadcom BCM5723" rev 0x10, BCM5784 A1 (0x5784100): apic 2 int 18, address e4:11:5b:12:bd:d6
brgphy0 at bge0 phy 1: BCM5784 10/100/1000baseT PHY, rev. 4

bge0 at pci3 dev 4 function 0 "Broadcom BCM5714" rev 0xa3, BCM5715 A3 (0x9003): ivec 0x795, address 00:14:4f:a9:34:90
brgphy0 at bge0 phy 1: BCM5714 10/100/1000baseT/SX PHY, rev. 0

bge0 at pci2 dev 0 function 0 "Broadcom BCM5761" rev 0x10, BCM5761 A1 (0x5761100): apic 2 int 18, address 00:10:18:4b:23:b4
brgphy0 at bge0 phy 1: BCM5761 10/100/1000baseT PHY, rev. 0

bge0 at pci0 dev 5 function 0 "Broadcom BCM5702X" rev 0x02, BCM5702/5703 A2 (0x1002): eb164 irq 2, address 00:10:18:00:98:e9
brgphy0 at bge0 phy 1: BCM5703 10/100/1000baseT PHY, rev. 2

bge0 at pci2 dev 2 function 0 "Broadcom BCM5703" rev 0x00, BCM5702/5703 A2 (0x1002): ivec 0x7dc, address 00:14:4f:16:a0:23

and of course:
bge1 at pci5 dev 0 function 0 "Broadcom BCM5720" rev 0x00, BCM5720 A0 (0x5720000), APE firmware NCSI 1.0.85.0: apic 0 int 16, address d4:ae:52:a7:05:38
brgphy1 at bge1 phy 1: BCM5720C 10/100/1000baseT PHY, rev. 0
bge2 at pci5 dev 0 function 1 "Broadcom BCM5720" rev 0x00, BCM5720 A0 (0x5720000), APE firmware NCSI 1.0.85.0: apic 0 int 17, address d4:ae:52:a7:05:39
brgphy2 at bge2 phy 2: BCM5720C 10/100/1000baseT PHY, rev. 0

either sthen@@ or i will be around to handle any issues after this commit.
@
text
@a182 1
u_int32_t bge_dma_swap_options(struct bge_softc *);
a193 7
#define BGE_RESET_SHUTDOWN	0
#define BGE_RESET_START		1
#define BGE_RESET_SUSPEND	2
void bge_sig_post_reset(struct bge_softc *, int);
void bge_sig_legacy(struct bge_softc *, int);
void bge_sig_pre_reset(struct bge_softc *, int);
void bge_stop_fw(struct bge_softc *, int);
a196 7
void bge_ape_lock_init(struct bge_softc *);
void bge_ape_read_fw_ver(struct bge_softc *);
int bge_ape_lock(struct bge_softc *, int);
void bge_ape_unlock(struct bge_softc *, int);
void bge_ape_send_event(struct bge_softc *, uint32_t);
void bge_ape_driver_state_change(struct bge_softc *, int);

a244 2
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5719 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5720 },
a308 2
#define BGE_IS_5717_PLUS(sc)		((sc)->bge_flags & BGE_5717_PLUS)
#define BGE_IS_575X_PLUS(sc)		((sc)->bge_flags & BGE_575X_PLUS)
a358 1
	{ BGE_CHIPID_BCM5720_A0, "BCM5720 A0" },
a403 2
	{ BGE_ASICREV_BCM5719, "unknown BCM5719" },
	{ BGE_ASICREV_BCM5720, "unknown BCM5720" },
a412 5
	u_int32_t val;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906 &&
	    off >= BGE_STATS_BLOCK && off < BGE_SEND_RING_1_TO_4)
		return (0);
d415 1
a415 3
	val = pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_MEMWIN_DATA);
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MEMWIN_BASEADDR, 0);
	return (val);
a422 4
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906 &&
	    off >= BGE_STATS_BLOCK && off < BGE_SEND_RING_1_TO_4)
		return;

a424 1
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MEMWIN_BASEADDR, 0);
a444 318
/*
 * Clear all stale locks and select the lock for this driver instance.
 */
void
bge_ape_lock_init(struct bge_softc *sc)
{
	struct pci_attach_args *pa = &(sc->bge_pa);
	uint32_t bit, regbase;
	int i;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761)
		regbase = BGE_APE_LOCK_GRANT;
	else
		regbase = BGE_APE_PER_LOCK_GRANT;

	/* Clear any stale locks. */
	for (i = BGE_APE_LOCK_PHY0; i <= BGE_APE_LOCK_GPIO; i++) {
		switch (i) {
		case BGE_APE_LOCK_PHY0:
		case BGE_APE_LOCK_PHY1:
		case BGE_APE_LOCK_PHY2:
		case BGE_APE_LOCK_PHY3:
			bit = BGE_APE_LOCK_GRANT_DRIVER0;
			break;
		default:
			if (pa->pa_function != 0)
				bit = BGE_APE_LOCK_GRANT_DRIVER0;
			else
				bit = (1 << pa->pa_function);
		}
		APE_WRITE_4(sc, regbase + 4 * i, bit);
	}

	/* Select the PHY lock based on the device's function number. */
	switch (pa->pa_function) {
	case 0:
		sc->bge_phy_ape_lock = BGE_APE_LOCK_PHY0;
		break;
	case 1:
		sc->bge_phy_ape_lock = BGE_APE_LOCK_PHY1;
		break;
	case 2:
		sc->bge_phy_ape_lock = BGE_APE_LOCK_PHY2;
		break;
	case 3:
		sc->bge_phy_ape_lock = BGE_APE_LOCK_PHY3;
		break;
	default:
		printf("%s: PHY lock not supported on function %d\n",
		    sc->bge_dev.dv_xname);
		break;
	}
}

/*
 * Check for APE firmware, set flags, and print version info.
 */
void
bge_ape_read_fw_ver(struct bge_softc *sc)
{
	const char *fwtype;
	uint32_t apedata, features;

	/* Check for a valid APE signature in shared memory. */
	apedata = APE_READ_4(sc, BGE_APE_SEG_SIG);
	if (apedata != BGE_APE_SEG_SIG_MAGIC) {
		sc->bge_mfw_flags &= ~ BGE_MFW_ON_APE;
		return;
	}

	/* Check if APE firmware is running. */
	apedata = APE_READ_4(sc, BGE_APE_FW_STATUS);
	if ((apedata & BGE_APE_FW_STATUS_READY) == 0) {
		printf("%s: APE signature found but FW status not ready! "
		    "0x%08x\n", sc->bge_dev.dv_xname, apedata);
		return;
	}

	sc->bge_mfw_flags |= BGE_MFW_ON_APE;

	/* Fetch the APE firwmare type and version. */
	apedata = APE_READ_4(sc, BGE_APE_FW_VERSION);
	features = APE_READ_4(sc, BGE_APE_FW_FEATURES);
	if ((features & BGE_APE_FW_FEATURE_NCSI) != 0) {
		sc->bge_mfw_flags |= BGE_MFW_TYPE_NCSI;
		fwtype = "NCSI";
	} else if ((features & BGE_APE_FW_FEATURE_DASH) != 0) {
		sc->bge_mfw_flags |= BGE_MFW_TYPE_DASH;
		fwtype = "DASH";
	} else
		fwtype = "UNKN";

	/* Print the APE firmware version. */
	printf(", APE firmware %s %d.%d.%d.%d", fwtype,
	    (apedata & BGE_APE_FW_VERSION_MAJMSK) >> BGE_APE_FW_VERSION_MAJSFT,
	    (apedata & BGE_APE_FW_VERSION_MINMSK) >> BGE_APE_FW_VERSION_MINSFT,
	    (apedata & BGE_APE_FW_VERSION_REVMSK) >> BGE_APE_FW_VERSION_REVSFT,
	    (apedata & BGE_APE_FW_VERSION_BLDMSK));
}

int
bge_ape_lock(struct bge_softc *sc, int locknum)
{
	struct pci_attach_args *pa = &(sc->bge_pa);
	uint32_t bit, gnt, req, status;
	int i, off;

	if ((sc->bge_mfw_flags & BGE_MFW_ON_APE) == 0)
		return (0);

	/* Lock request/grant registers have different bases. */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761) {
		req = BGE_APE_LOCK_REQ;
		gnt = BGE_APE_LOCK_GRANT;
	} else {
		req = BGE_APE_PER_LOCK_REQ;
		gnt = BGE_APE_PER_LOCK_GRANT;
	}

	off = 4 * locknum;

	switch (locknum) {
	case BGE_APE_LOCK_GPIO:
		/* Lock required when using GPIO. */
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761)
			return (0);
		if (pa->pa_function == 0)
			bit = BGE_APE_LOCK_REQ_DRIVER0;
		else
			bit = (1 << pa->pa_function);
		break;
	case BGE_APE_LOCK_GRC:
		/* Lock required to reset the device. */
		if (pa->pa_function == 0)
			bit = BGE_APE_LOCK_REQ_DRIVER0;
		else
			bit = (1 << pa->pa_function);
		break;
	case BGE_APE_LOCK_MEM:
		/* Lock required when accessing certain APE memory. */
		if (pa->pa_function == 0)
			bit = BGE_APE_LOCK_REQ_DRIVER0;
		else
			bit = (1 << pa->pa_function);
		break;
	case BGE_APE_LOCK_PHY0:
	case BGE_APE_LOCK_PHY1:
	case BGE_APE_LOCK_PHY2:
	case BGE_APE_LOCK_PHY3:
		/* Lock required when accessing PHYs. */
		bit = BGE_APE_LOCK_REQ_DRIVER0;
		break;
	default:
		return (EINVAL);
	}

	/* Request a lock. */
	APE_WRITE_4(sc, req + off, bit);

	/* Wait up to 1 second to acquire lock. */
	for (i = 0; i < 20000; i++) {
		status = APE_READ_4(sc, gnt + off);
		if (status == bit)
			break;
		DELAY(50);
	}

	/* Handle any errors. */
	if (status != bit) {
		printf("%s: APE lock %d request failed! "
		    "request = 0x%04x[0x%04x], status = 0x%04x[0x%04x]\n",
		    sc->bge_dev.dv_xname,
		    locknum, req + off, bit & 0xFFFF, gnt + off,
		    status & 0xFFFF);
		/* Revoke the lock request. */
		APE_WRITE_4(sc, gnt + off, bit);
		return (EBUSY);
	}

	return (0);
}

void
bge_ape_unlock(struct bge_softc *sc, int locknum)
{
	struct pci_attach_args *pa = &(sc->bge_pa);
	uint32_t bit, gnt;
	int off;

	if ((sc->bge_mfw_flags & BGE_MFW_ON_APE) == 0)
		return;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761)
		gnt = BGE_APE_LOCK_GRANT;
	else
		gnt = BGE_APE_PER_LOCK_GRANT;

	off = 4 * locknum;

	switch (locknum) {
	case BGE_APE_LOCK_GPIO:
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761)
			return;
		if (pa->pa_function == 0)
			bit = BGE_APE_LOCK_GRANT_DRIVER0;
		else
			bit = (1 << pa->pa_function);
		break;
	case BGE_APE_LOCK_GRC:
		if (pa->pa_function == 0)
			bit = BGE_APE_LOCK_GRANT_DRIVER0;
		else
			bit = (1 << pa->pa_function);
		break;
	case BGE_APE_LOCK_MEM:
		if (pa->pa_function == 0)
			bit = BGE_APE_LOCK_GRANT_DRIVER0;
		else
			bit = (1 << pa->pa_function);
		break;
	case BGE_APE_LOCK_PHY0:
	case BGE_APE_LOCK_PHY1:
	case BGE_APE_LOCK_PHY2:
	case BGE_APE_LOCK_PHY3:
		bit = BGE_APE_LOCK_GRANT_DRIVER0;
		break;
	default:
		return;
	}

	APE_WRITE_4(sc, gnt + off, bit);
}

/*
 * Send an event to the APE firmware.
 */
void
bge_ape_send_event(struct bge_softc *sc, uint32_t event)
{
	uint32_t apedata;
	int i;

	/* NCSI does not support APE events. */
	if ((sc->bge_mfw_flags & BGE_MFW_ON_APE) == 0)
		return;

	/* Wait up to 1ms for APE to service previous event. */
	for (i = 10; i > 0; i--) {
		if (bge_ape_lock(sc, BGE_APE_LOCK_MEM) != 0)
			break;
		apedata = APE_READ_4(sc, BGE_APE_EVENT_STATUS);
		if ((apedata & BGE_APE_EVENT_STATUS_EVENT_PENDING) == 0) {
			APE_WRITE_4(sc, BGE_APE_EVENT_STATUS, event |
			    BGE_APE_EVENT_STATUS_EVENT_PENDING);
			bge_ape_unlock(sc, BGE_APE_LOCK_MEM);
			APE_WRITE_4(sc, BGE_APE_EVENT, BGE_APE_EVENT_1);
			break;
		}
		bge_ape_unlock(sc, BGE_APE_LOCK_MEM);
		DELAY(100);
	}
	if (i == 0) {
		printf("%s: APE event 0x%08x send timed out\n",
		    sc->bge_dev.dv_xname, event);
	}
}

void
bge_ape_driver_state_change(struct bge_softc *sc, int kind)
{
	uint32_t apedata, event;

	if ((sc->bge_mfw_flags & BGE_MFW_ON_APE) == 0)
		return;

	switch (kind) {
	case BGE_RESET_START:
		/* If this is the first load, clear the load counter. */
		apedata = APE_READ_4(sc, BGE_APE_HOST_SEG_SIG);
		if (apedata != BGE_APE_HOST_SEG_SIG_MAGIC)
			APE_WRITE_4(sc, BGE_APE_HOST_INIT_COUNT, 0);
		else {
			apedata = APE_READ_4(sc, BGE_APE_HOST_INIT_COUNT);
			APE_WRITE_4(sc, BGE_APE_HOST_INIT_COUNT, ++apedata);
		}
		APE_WRITE_4(sc, BGE_APE_HOST_SEG_SIG,
		    BGE_APE_HOST_SEG_SIG_MAGIC);
		APE_WRITE_4(sc, BGE_APE_HOST_SEG_LEN,
		    BGE_APE_HOST_SEG_LEN_MAGIC);

		/* Add some version info if bge(4) supports it. */
		APE_WRITE_4(sc, BGE_APE_HOST_DRIVER_ID,
		    BGE_APE_HOST_DRIVER_ID_MAGIC(1, 0));
		APE_WRITE_4(sc, BGE_APE_HOST_BEHAVIOR,
		    BGE_APE_HOST_BEHAV_NO_PHYLOCK);
		APE_WRITE_4(sc, BGE_APE_HOST_HEARTBEAT_INT_MS,
		    BGE_APE_HOST_HEARTBEAT_INT_DISABLE);
		APE_WRITE_4(sc, BGE_APE_HOST_DRVR_STATE,
		    BGE_APE_HOST_DRVR_STATE_START);
		event = BGE_APE_EVENT_STATUS_STATE_START;
		break;
	case BGE_RESET_SHUTDOWN:
		APE_WRITE_4(sc, BGE_APE_HOST_DRVR_STATE,
		    BGE_APE_HOST_DRVR_STATE_UNLOAD);
		event = BGE_APE_EVENT_STATUS_STATE_UNLOAD;
		break;
	case BGE_RESET_SUSPEND:
		event = BGE_APE_EVENT_STATUS_STATE_SUSPEND;
		break;
	default:
		return;
	}

	bge_ape_send_event(sc, event | BGE_APE_EVENT_STATUS_DRIVER_EVNT |
	    BGE_APE_EVENT_STATUS_STATE_CHNGE);
}


a589 3
	if (bge_ape_lock(sc, sc->bge_phy_ape_lock) != 0)
		return (0);

d595 1
a595 1
		DELAY(80);
d621 1
a621 1
		DELAY(80);
a623 2
	bge_ape_unlock(sc, sc->bge_phy_ape_lock);

a636 7
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906 &&
	    (reg == BRGPHY_MII_1000CTL || reg == BRGPHY_MII_AUXCTL))
		return;

	if (bge_ape_lock(sc, sc->bge_phy_ape_lock) != 0)
		return;

d643 1
a643 1
		DELAY(40); /* 40 usec is supposed to be adequate */
a661 2
	bge_ape_unlock(sc, sc->bge_phy_ape_lock);

a671 1
	u_int32_t mac_mode, rx_mode, tx_mode;
d682 1
a682 6
	/* Set the port mode (MII/GMII) to match the link speed. */
	mac_mode = CSR_READ_4(sc, BGE_MAC_MODE) &
	    ~(BGE_MACMODE_PORTMODE | BGE_MACMODE_HALF_DUPLEX);
	tx_mode = CSR_READ_4(sc, BGE_TX_MODE);
	rx_mode = CSR_READ_4(sc, BGE_RX_MODE);

d685 1
a685 1
		mac_mode |= BGE_PORTMODE_GMII;
d687 1
a687 1
		mac_mode |= BGE_PORTMODE_MII;
d689 12
a700 10
	/* Set MAC flow control behavior to match link flow control settings. */
	tx_mode &= ~BGE_TXMODE_FLOWCTL_ENABLE;
	rx_mode &= ~BGE_RXMODE_FLOWCTL_ENABLE;
	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX) {
		if (sc->bge_flowflags & IFM_ETH_TXPAUSE)
			tx_mode |= BGE_TXMODE_FLOWCTL_ENABLE;
		if (sc->bge_flowflags & IFM_ETH_RXPAUSE)
			rx_mode |= BGE_RXMODE_FLOWCTL_ENABLE;
	} else
		mac_mode |= BGE_MACMODE_HALF_DUPLEX;
d702 4
a705 4
	CSR_WRITE_4(sc, BGE_MAC_MODE, mac_mode);
	DELAY(40);
	CSR_WRITE_4(sc, BGE_TX_MODE, tx_mode);
	CSR_WRITE_4(sc, BGE_RX_MODE, rx_mode);
a1160 44
void
bge_sig_pre_reset(struct bge_softc *sc, int type)
{
	/* no bge_asf_mode. */

	if (type == BGE_RESET_START || type == BGE_RESET_SUSPEND)
		bge_ape_driver_state_change(sc, type);
}

void
bge_sig_post_reset(struct bge_softc *sc, int type)
{
	/* no bge_asf_mode. */

	if (type == BGE_RESET_SHUTDOWN)
		bge_ape_driver_state_change(sc, type);
}

void
bge_sig_legacy(struct bge_softc *sc, int type)
{
	/* no bge_asf_mode. */
}

void
bge_stop_fw(struct bge_softc *sc, int type)
{
	/* no bge_asf_mode. */
}

u_int32_t
bge_dma_swap_options(struct bge_softc *sc)
{
	u_int32_t dma_options = BGE_DMA_SWAP_OPTIONS;

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720) {
		dma_options |= BGE_MODECTL_BYTESWAP_B2HRX_DATA |
		    BGE_MODECTL_WORDSWAP_B2HRX_DATA | BGE_MODECTL_B2HRX_ENABLE |
		    BGE_MODECTL_HTX2B_ENABLE;
	}

	return (dma_options);
}

d1191 1
a1191 1
	u_int32_t dma_rw_ctl, mode_ctl;
d1198 3
d1271 1
a1271 1

a1275 15
	if (BGE_IS_5717_PLUS(sc)) {
		dma_rw_ctl &= ~BGE_PCIDMARWCTL_DIS_CACHE_ALIGNMENT;
		if (sc->bge_chipid == BGE_CHIPID_BCM57765_A0)
			dma_rw_ctl &= ~BGE_PCIDMARWCTL_CRDRDR_RDMA_MRRS_MSK;

		/*
		 * Enable HW workaround for controllers that misinterpret
		 * a status tag update and leave interrupts permanently
		 * disabled.
		 */
		if (BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5717 &&
		    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM57765)
			dma_rw_ctl |= BGE_PCIDMARWCTL_TAGGED_STATUS_WA;
	}

d1281 3
a1283 10
	mode_ctl = bge_dma_swap_options(sc);
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720) {
		/* Retain Host-2-BMC settings written by APE firmware. */
		mode_ctl |= CSR_READ_4(sc, BGE_MODE_CTL) &
		    (BGE_MODECTL_BYTESWAP_B2HRX_DATA |
		    BGE_MODECTL_WORDSWAP_B2HRX_DATA |
		    BGE_MODECTL_B2HRX_ENABLE | BGE_MODECTL_HTX2B_ENABLE);
	}
	mode_ctl |= BGE_MODECTL_MAC_ATTN_INTR | BGE_MODECTL_HOST_SEND_BDS |
	    BGE_MODECTL_TX_NO_PHDR_CSUM;
d1293 1
a1293 3
		mode_ctl |= BGE_MODECTL_FORCE_PCI32;

	CSR_WRITE_4(sc, BGE_MODE_CTL, mode_ctl);
d1333 1
a1333 1
	u_int32_t		dmactl, val;
d1344 1
a1344 1
	if (!BGE_IS_5705_PLUS(sc)) {
d1361 2
a1362 1
	if (BGE_IS_5717_PLUS(sc)) {
d1387 2
a1388 10
	val = BGE_BMANMODE_ENABLE | BGE_BMANMODE_LOMBUF_ATTN;
	/*
	 * Change the arbitration algorithm of TXMBUF read request to
	 * round-robin instead of priority based for BCM5719.  When
	 * TXFIFO is almost empty, RDMA will hold its request until
	 * TXFIFO is not almost empty.
	 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719)
		val |= BGE_BMANMODE_NO_TX_UNDERRUN;
	CSR_WRITE_4(sc, BGE_BMAN_MODE, val);
d1423 4
a1426 3
	if (BGE_IS_5717_PLUS(sc))
		rcb->bge_maxlen_flags = BGE_RCB_MAXLEN_FLAGS(512,
		    (ETHER_MAX_DIX_LEN << 2));
d1432 1
a1432 7
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720)
		rcb->bge_nicaddr = BGE_STD_RX_RINGS_5717;
	else
		rcb->bge_nicaddr = BGE_STD_RX_RINGS;

a1437 3
	/* Reset the standard receive producer ring producer index. */
	bge_writembx(sc, BGE_MBX_RX_STD_PROD_LO, 0);

d1451 1
a1451 6
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719 ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720)
			rcb->bge_nicaddr = BGE_JUMBO_RX_RINGS_5717;
		else
			rcb->bge_nicaddr = BGE_JUMBO_RX_RINGS;
a1456 1
		/* Program the jumbo receive producer ring RCB parameters. */
d1459 2
a1460 4
		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_NICADDR, rcb->bge_nicaddr);
		/* Reset the jumbo receive producer ring producer index. */
		bge_writembx(sc, BGE_MBX_RX_JUMBO_PROD_LO, 0);
	}
a1461 2
	/* Disable the mini receive producer ring RCB. */
	if (BGE_IS_5700_FAMILY(sc)) {
a1467 2
		/* Reset the mini receive producer ring producer index. */
		bge_writembx(sc, BGE_MBX_RX_MINI_PROD_LO, 0);
a1468 1
		/* XXX why? */
a1472 1

d1494 2
a1495 1
	if (BGE_IS_5717_PLUS(sc)) {
d1518 1
a1518 6
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720)
		RCB_WRITE_4(sc, rcb_addr, bge_nicaddr, BGE_SEND_RING_5717);
	else
		RCB_WRITE_4(sc, rcb_addr, bge_nicaddr,
d1538 5
d1565 1
a1565 5
	val = 0x2620;
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720)
		val |= CSR_READ_4(sc, BGE_TX_LENGTHS) &
		    (BGE_TXLEN_JMB_FRM_LEN_MSK | BGE_TXLEN_CNT_DN_VAL_MSK);
	CSR_WRITE_4(sc, BGE_TX_LENGTHS, val);
d1580 1
a1580 1
	CSR_WRITE_4(sc, BGE_RXLP_STATS_ENABLE_MASK, 0x007BFFFF);
d1604 1
a1604 1
	if (!(BGE_IS_5705_PLUS(sc))) {
d1612 1
a1612 1
	if (!(BGE_IS_5705_PLUS(sc))) {
a1629 10
	/* Set up status block size. */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 &&
	    sc->bge_chipid != BGE_CHIPID_BCM5700_C0) {
		val = BGE_STATBLKSZ_FULL;
		bzero(&sc->bge_rdata->bge_status_block, BGE_STATUS_BLK_SZ);
	} else {
		val = BGE_STATBLKSZ_32BYTE;
		bzero(&sc->bge_rdata->bge_status_block, 32);
	}

d1631 1
a1631 1
	CSR_WRITE_4(sc, BGE_HCC_MODE, val | BGE_HCCMODE_ENABLE);
d1641 1
a1641 1
	if (!(BGE_IS_5705_PLUS(sc)))
a1655 4
	/* Allow APE to send/receive frames. */
	if ((sc->bge_mfw_flags & BGE_MFW_ON_APE) != 0)
		val |= BGE_MACMODE_APE_RX_EN | BGE_MACMODE_APE_TX_EN;

a1657 1
	DELAY(40);
d1671 1
a1671 1
	if (!(BGE_IS_5705_PLUS(sc)))
a1684 1
	DELAY(40);
d1701 1
a1701 54
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720) {
		val |= CSR_READ_4(sc, BGE_RDMA_MODE) &
		    BGE_RDMAMODE_H2BNC_VLAN_DET;
		/*
		 * Allow multiple outstanding read requests from
		 * non-LSO read DMA engine.
		 */
		val &= ~BGE_RDMAMODE_MULT_DMA_RD_DIS;
	}

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5785 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57780 ||
	    BGE_IS_5717_PLUS(sc)) {
		dmactl = CSR_READ_4(sc, BGE_RDMA_RSRVCTRL);
		/*
		 * Adjust tx margin to prevent TX data corruption and
		 * fix internal FIFO overflow.
		 */
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719 ||
		    sc->bge_chipid == BGE_CHIPID_BCM5719_A0) {
			dmactl &= ~(BGE_RDMA_RSRVCTRL_FIFO_LWM_MASK |
			    BGE_RDMA_RSRVCTRL_FIFO_HWM_MASK |
			    BGE_RDMA_RSRVCTRL_TXMRGN_MASK);
			dmactl |= BGE_RDMA_RSRVCTRL_FIFO_LWM_1_5K |
			    BGE_RDMA_RSRVCTRL_FIFO_HWM_1_5K |
			    BGE_RDMA_RSRVCTRL_TXMRGN_320B;
		}
		/*
		 * Enable fix for read DMA FIFO overruns.
		 * The fix is to limit the number of RX BDs
		 * the hardware would fetch at a fime.
		 */
		CSR_WRITE_4(sc, BGE_RDMA_RSRVCTRL, dmactl |
		    BGE_RDMA_RSRVCTRL_FIFO_OFLW_FIX);
	}

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719) {
		CSR_WRITE_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL,
		    CSR_READ_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL) |
		    BGE_RDMA_LSO_CRPTEN_CTRL_BLEN_BD_4K |
		    BGE_RDMA_LSO_CRPTEN_CTRL_BLEN_LSO_4K);
	} else if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720) {
		/*
		 * Allow 4KB burst length reads for non-LSO frames.
		 * Enable 512B burst length reads for buffer descriptors.
		 */
		CSR_WRITE_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL,
		    CSR_READ_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL) |
		    BGE_RDMA_LSO_CRPTEN_CTRL_BLEN_BD_512 |
		    BGE_RDMA_LSO_CRPTEN_CTRL_BLEN_LSO_4K);
	}

a1702 1
	DELAY(40);
d1714 1
a1714 1
	if (!BGE_IS_5705_PLUS(sc))
a1719 1
	/* Turn on send data completion state machine */
d1737 1
a1737 1
	CSR_WRITE_4(sc, BGE_SDI_STATS_ENABLE_MASK, 0x007BFFFF);
d1742 2
a1743 2
	CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED |
	    BGE_MACSTAT_CFG_CHANGED | BGE_MACSTAT_MI_COMPLETE |
d1816 1
a1816 1
	bus_size_t		size, apesize;
a1877 2
		case PCI_PRODUCT_BROADCOM_BCM5719:
		case PCI_PRODUCT_BROADCOM_BCM5720:
a1939 6
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5719 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765)
		sc->bge_flags |= BGE_5717_PLUS | BGE_575X_PLUS;;

d1952 2
a1953 1
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5755 ||
d1958 2
a1959 2
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57780 ||
	    BGE_IS_5717_PLUS(sc))
a2052 41
	/* Identify chips with APE processor. */
	switch (BGE_ASICREV(sc->bge_chipid)) {
	case BGE_ASICREV_BCM5717:
	case BGE_ASICREV_BCM5719:
	case BGE_ASICREV_BCM5720:
	case BGE_ASICREV_BCM5761:
		sc->bge_flags |= BGE_APE;
		break;
	}

	/* Chips with APE need BAR2 access for APE registers/memory. */
	if ((sc->bge_flags & BGE_APE) != 0) {
		memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, BGE_PCI_BAR2);
		if (pci_mapreg_map(pa, BGE_PCI_BAR2, memtype, 0,
		    &sc->bge_apetag, &sc->bge_apehandle, NULL, &apesize, 0)) {
			printf(": couldn't map BAR2 memory\n");
			goto fail_1;
		}

		/* Enable APE register/memory access by host driver. */
		reg = pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE);
		reg |= BGE_PCISTATE_ALLOW_APE_CTLSPC_WR |
		    BGE_PCISTATE_ALLOW_APE_SHMEM_WR |
		    BGE_PCISTATE_ALLOW_APE_PSPACE_WR;
		pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE, reg);

		bge_ape_lock_init(sc);
		bge_ape_read_fw_ver(sc);
	}

	/* Identify the chips that use an CPMU. */
	if (BGE_IS_5717_PLUS(sc) ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5785 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57780)
		sc->bge_flags |= BGE_CPMU_PRESENT;

	if ((sc->bge_flags & BGE_CPMU_PRESENT) != 0)
		BGE_SETBIT(sc, BGE_MI_MODE, BGE_MIMODE_500KHZ_CONST);

a2054 1
	bge_sig_pre_reset(sc, BGE_RESET_START);
a2056 3
	bge_sig_legacy(sc, BGE_RESET_START);
	bge_sig_post_reset(sc, BGE_RESET_START);

d2110 1
a2110 1
		goto fail_2;
d2119 1
a2119 1
		goto fail_2;
d2127 1
a2127 1
		goto fail_3;
d2134 1
a2134 1
		goto fail_4;
d2140 1
a2140 1
		goto fail_5;
d2156 3
a2158 1
	if (BGE_IS_5717_PLUS(sc))
d2160 1
a2160 1
	else if (BGE_IS_5705_PLUS(sc))
a2161 2
	else
		sc->bge_return_ring_cnt = BGE_RETURN_RING_CNT;
d2222 1
a2222 1
			goto fail_6;
d2245 1
a2245 1
		goto fail_6;
d2298 1
a2298 1
fail_6:
d2301 1
a2301 1
fail_5:
d2304 1
a2304 1
fail_4:
d2308 1
a2308 1
fail_3:
a2310 4
fail_2:
	if ((sc->bge_flags & BGE_APE) != 0)
		bus_space_unmap(sc->bge_apetag, sc->bge_apehandle, apesize);

d2344 3
a2346 21
	pcireg_t cachesize, command;
	u_int32_t reset, mac_mode, mac_mode_mask, val;
	void (*write_op)(struct bge_softc *, int, int);
	int i;

	mac_mode_mask = BGE_MACMODE_HALF_DUPLEX | BGE_MACMODE_PORTMODE;
	if ((sc->bge_mfw_flags & BGE_MFW_ON_APE) != 0)
		mac_mode_mask |= BGE_MACMODE_APE_RX_EN | BGE_MACMODE_APE_TX_EN;
	mac_mode = CSR_READ_4(sc, BGE_MAC_MODE) & mac_mode_mask;

	if (BGE_IS_575X_PLUS(sc) && !BGE_IS_5714_FAMILY(sc) &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5906) {
		if (sc->bge_flags & BGE_PCIE)
			write_op = bge_writembx;
		else
			write_op = bge_writemem_ind;
	} else
		write_op = bge_writereg_ind;

	/* Take APE lock when performing reset. */
	bge_ape_lock(sc, BGE_APE_LOCK_GRC);
d2351 1
d2354 2
a2355 2
	    BGE_PCIMISCCTL_INDIRECT_ACCESS | BGE_PCIMISCCTL_MASK_PCI_INTR |
	    BGE_PCIMISCCTL_ENDIAN_WORDSWAP | BGE_PCIMISCCTL_PCISTATE_RW);
d2362 1
a2362 8
	/*
	 * Write the magic number to SRAM at offset 0xB50.
	 * When firmware finishes its initialization it will
	 * write ~BGE_SRAM_FW_MB_MAGIC to the same location.
	 */
	bge_writemem_ind(sc, BGE_SOFTWARE_GENCOMM, BGE_MAGIC_NUMBER);

	reset = BGE_MISCCFG_RESET_CORE_CLOCKS | BGE_32BITTIME_66MHZ;
d2365 3
a2367 6
		if (BGE_ASICREV(sc->bge_chipid != BGE_ASICREV_BCM5785) &&
		    !BGE_IS_5717_PLUS(sc)) {
			if (CSR_READ_4(sc, 0x7e2c) == 0x60) {
				/* PCI Express 1.0 system */
				CSR_WRITE_4(sc, 0x7e2c, 0x20);
			}
d2383 1
a2383 2
	if (BGE_IS_5705_PLUS(sc) &&
	    (sc->bge_flags & BGE_CPMU_PRESENT) == 0)
d2387 1
a2387 6
	write_op(sc, BGE_MISC_CFG, reset);

	if (sc->bge_flags & BGE_PCIE)
		DELAY(100 * 1000);
	else
		DELAY(1000);
d2402 2
d2423 2
a2424 11
	    BGE_PCIMISCCTL_INDIRECT_ACCESS | BGE_PCIMISCCTL_MASK_PCI_INTR |
	    BGE_PCIMISCCTL_ENDIAN_WORDSWAP | BGE_PCIMISCCTL_PCISTATE_RW);
	val = BGE_PCISTATE_ROM_ENABLE | BGE_PCISTATE_ROM_RETRY_ENABLE;
	if (sc->bge_chipid == BGE_CHIPID_BCM5704_A0 &&
	    (sc->bge_flags & BGE_PCIX) != 0)
		val |= BGE_PCISTATE_RETRY_SAME_DMA;
	if ((sc->bge_mfw_flags & BGE_MFW_ON_APE) != 0)
		val |= BGE_PCISTATE_ALLOW_APE_CTLSPC_WR |
		    BGE_PCISTATE_ALLOW_APE_SHMEM_WR |
		    BGE_PCISTATE_ALLOW_APE_PSPACE_WR;
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE, val);
d2427 1
d2431 2
d2438 5
a2442 9
	/* Fix up byte swapping */
	CSR_WRITE_4(sc, BGE_MODE_CTL, bge_dma_swap_options(sc));

	val = CSR_READ_4(sc, BGE_MAC_MODE);
	val = (val & ~mac_mode_mask) | mac_mode;
	CSR_WRITE_4(sc, BGE_MAC_MODE, val);
	DELAY(40);

	bge_ape_unlock(sc, BGE_APE_LOCK_GRC);
a2470 3
		/* BCM57765 A0 needs additional time before accessing. */
		if (sc->bge_chipid == BGE_CHIPID_BCM57765_A0)
			DELAY(10 * 1000);       /* XXX */
d2474 27
a2514 1
	    !BGE_IS_5717_PLUS(sc) &&
d2516 3
a2518 1
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5785) {
d2525 1
a2525 4

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720)
		BGE_CLRBIT(sc, BGE_CPMU_CLCK_ORIDE,
		    CPMU_CLCK_ORIDE_MAC_ORIDE_EN);
d2635 1
a2635 1
		m->m_pkthdr.len = m->m_len = cur_rx->bge_len - ETHER_CRC_LEN;
a2765 1
	u_int32_t intrmask = BGE_PCISTATE_INTR_NOT_ACTIVE;
a2769 3
	if (BGE_IS_5717_PLUS(sc))
		intrmask = 0;

a2776 5
	bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
	    offsetof(struct bge_ring_data, bge_status_block),
	    sizeof (struct bge_status_block),
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

d2780 1
a2780 1
	    (~CSR_READ_4(sc, BGE_PCI_PCISTATE) & intrmask)) {
a2787 5
		bus_dmamap_sync(sc->bge_dmatag, sc->bge_ring_map,
		    offsetof(struct bge_ring_data, bge_status_block),
		    sizeof (struct bge_status_block),
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

d2841 1
a2841 1
	}
d2856 3
a2858 3
	sc->bge_rx_discards += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_IFIN_DROPS);
	sc->bge_rx_inerrors += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_IFIN_ERRORS);
	sc->bge_rx_overruns += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_OUT_OF_BDS);
d2860 1
a2860 2
	ifp->if_ierrors = sc->bge_rx_discards + sc->bge_rx_inerrors +
	    sc->bge_rx_overruns;
d3210 1
a3210 1
	u_int32_t mode;
a3218 1
	bge_sig_pre_reset(sc, BGE_RESET_START);
a3219 3
	bge_sig_legacy(sc, BGE_RESET_START);
	bge_sig_post_reset(sc, BGE_RESET_START);

d3291 2
a3292 10
	/* Enable TX MAC state machine lockup fix. */
	mode = CSR_READ_4(sc, BGE_TX_MODE);
	if (BGE_IS_5755_PLUS(sc) ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906)
		mode |= BGE_TXMODE_MBUF_LOCKUP_FIX;
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5720) {
		mode &= ~(BGE_TXMODE_JMB_FRM_LEN | BGE_TXMODE_CNT_DN_MODE);
		mode |= CSR_READ_4(sc, BGE_TX_MODE) &
		    (BGE_TXMODE_JMB_FRM_LEN | BGE_TXMODE_CNT_DN_MODE);
	}
d3294 1
a3294 3
	/* Turn on transmitter */
	CSR_WRITE_4(sc, BGE_TX_MODE, mode | BGE_TXMODE_ENABLE);
	DELAY(100);
a3295 1
	mode = CSR_READ_4(sc, BGE_RX_MODE);
d3297 1
a3297 1
		mode |= BGE_RXMODE_IPV6_ENABLE;
d3300 1
a3300 2
	CSR_WRITE_4(sc, BGE_RX_MODE, mode | BGE_RXMODE_ENABLE);
	DELAY(10);
a3357 1
			DELAY(40);
a3561 7
	 * Tell firmware we're shutting down.
	 */
	/* bge_stop_fw(sc); */
	bge_sig_pre_reset(sc, BGE_RESET_SHUTDOWN);


	/*
d3597 1
a3597 1
	if (!BGE_IS_5705_PLUS(sc)) {
d3602 3
a3604 3
	bge_reset(sc);
	bge_sig_legacy(sc, BGE_RESET_SHUTDOWN);
	bge_sig_post_reset(sc, BGE_RESET_SHUTDOWN);
d3690 1
a3690 1
	}
d3715 1
a3715 1
	/*
d3721 1
a3721 1
		/*
@


1.315
log
@Fix typos in comments and change the syntactic sugar of a function to
reduce the diff between Fx and Ox. OK gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.314 2013/01/10 01:17:00 dlg Exp $	*/
d183 1
d195 7
d205 7
d260 2
d326 2
d378 1
d424 2
d435 5
d442 3
a444 1
	return (pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_MEMWIN_DATA));
d452 4
d458 1
d479 318
d942 3
d950 1
a950 1
		DELAY(40);
d976 1
a976 1
		DELAY(40);
d979 2
d994 7
d1007 1
a1007 1
		DELAY(10); /* 40 usec is supposed to be adequate */
d1026 2
d1038 1
d1049 6
a1054 1
	BGE_CLRBIT(sc, BGE_MAC_MODE, BGE_MACMODE_PORTMODE);
d1057 1
a1057 1
		BGE_SETBIT(sc, BGE_MAC_MODE, BGE_PORTMODE_GMII);
d1059 1
a1059 1
		BGE_SETBIT(sc, BGE_MAC_MODE, BGE_PORTMODE_MII);
d1061 10
a1070 12
	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX)
		BGE_CLRBIT(sc, BGE_MAC_MODE, BGE_MACMODE_HALF_DUPLEX);
	else
		BGE_SETBIT(sc, BGE_MAC_MODE, BGE_MACMODE_HALF_DUPLEX);

	/*
	 * 802.3x flow control
	 */
	if (sc->bge_flowflags & IFM_ETH_RXPAUSE)
		BGE_SETBIT(sc, BGE_RX_MODE, BGE_RXMODE_FLOWCTL_ENABLE);
	else
		BGE_CLRBIT(sc, BGE_RX_MODE, BGE_RXMODE_FLOWCTL_ENABLE);
d1072 4
a1075 4
	if (sc->bge_flowflags & IFM_ETH_TXPAUSE)
		BGE_SETBIT(sc, BGE_TX_MODE, BGE_TXMODE_FLOWCTL_ENABLE);
	else
		BGE_CLRBIT(sc, BGE_TX_MODE, BGE_TXMODE_FLOWCTL_ENABLE);
d1531 44
d1605 1
a1605 1
	u_int32_t dma_rw_ctl;
a1611 3
	/* Clear the MAC control register */
	CSR_WRITE_4(sc, BGE_MAC_MODE, 0);

d1682 1
a1682 1
 
d1687 15
d1707 10
a1716 3
	CSR_WRITE_4(sc, BGE_MODE_CTL, BGE_DMA_SWAP_OPTIONS|
		    BGE_MODECTL_MAC_ATTN_INTR|BGE_MODECTL_HOST_SEND_BDS|
		    BGE_MODECTL_TX_NO_PHDR_CSUM);
d1726 3
a1728 1
		BGE_SETBIT(sc, BGE_MODE_CTL, BGE_MODECTL_FORCE_PCI32);
d1768 1
a1768 1
	u_int32_t		val;
d1779 1
a1779 1
	if (BGE_IS_5700_FAMILY(sc)) {
d1796 1
a1796 2
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765) {
d1821 10
a1830 2
	CSR_WRITE_4(sc, BGE_BMAN_MODE,
	    BGE_BMANMODE_ENABLE|BGE_BMANMODE_LOMBUF_ATTN);
d1865 3
a1867 4
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765)
		rcb->bge_maxlen_flags = (BGE_RCB_MAXLEN_FLAGS(512, 0) |
					(ETHER_MAX_DIX_LEN << 2));
d1873 7
a1879 1
	rcb->bge_nicaddr = BGE_STD_RX_RINGS;
d1885 3
d1901 6
a1906 1
		rcb->bge_nicaddr = BGE_JUMBO_RX_RINGS;
d1912 1
d1915 4
a1918 2
		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_NICADDR,
		    rcb->bge_nicaddr);
d1920 2
d1928 2
d1931 1
d1936 1
d1958 1
a1958 2
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765) {
d1981 6
a1986 1
	RCB_WRITE_4(sc, rcb_addr, bge_nicaddr,
a2005 5
	/* Initialize RX ring indexes */
	bge_writembx(sc, BGE_MBX_RX_STD_PROD_LO, 0);
	bge_writembx(sc, BGE_MBX_RX_JUMBO_PROD_LO, 0);
	bge_writembx(sc, BGE_MBX_RX_MINI_PROD_LO, 0);

d2028 5
a2032 1
	CSR_WRITE_4(sc, BGE_TX_LENGTHS, 0x2620);
d2047 1
a2047 1
	CSR_WRITE_4(sc, BGE_RXLP_STATS_ENABLE_MASK, 0x007FFFFF);
d2071 1
a2071 1
	if (BGE_IS_5700_FAMILY(sc)) {
d2079 1
a2079 1
	if (BGE_IS_5700_FAMILY(sc)) {
d2097 10
d2108 1
a2108 1
	CSR_WRITE_4(sc, BGE_HCC_MODE, BGE_HCCMODE_ENABLE);
d2118 1
a2118 1
	if (BGE_IS_5700_FAMILY(sc))
d2133 4
d2139 1
d2153 1
a2153 1
	if (BGE_IS_5700_FAMILY(sc))
d2167 1
d2184 54
a2237 1
	/* Turn on read DMA state machine */
d2239 1
d2251 1
a2251 1
	if (BGE_IS_5700_FAMILY(sc))
d2257 1
d2275 1
a2275 1
	CSR_WRITE_4(sc, BGE_SDI_STATS_ENABLE_MASK, 0x007FFFFF);
d2280 2
a2281 2
	CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED|
	    BGE_MACSTAT_CFG_CHANGED|BGE_MACSTAT_MI_COMPLETE|
d2354 1
a2354 1
	bus_size_t		size;
d2416 2
d2480 6
d2498 1
a2498 2
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5755 ||
d2503 2
a2504 2
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57780)
d2598 41
d2641 1
d2644 3
d2700 1
a2700 1
		goto fail_1;
d2709 1
a2709 1
		goto fail_1;
d2717 1
a2717 1
		goto fail_2;
d2724 1
a2724 1
		goto fail_3;
d2730 1
a2730 1
		goto fail_4;
d2746 1
a2746 3
	if (BGE_IS_5700_FAMILY(sc) ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57765)
d2748 2
d2751 1
a2751 1
		sc->bge_return_ring_cnt = BGE_RETURN_RING_CNT_5705;
d2812 1
a2812 1
			goto fail_5;
d2835 1
a2835 1
		goto fail_5;
d2888 1
a2888 1
fail_5:
d2891 1
a2891 1
fail_4:
d2894 1
a2894 1
fail_3:
d2898 3
d2902 2
a2903 1
	bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
d2938 21
a2958 3
	pcireg_t cachesize, command, pcistate, new_pcistate;
	u_int32_t reset;
	int i, val = 0;
a2962 1
	pcistate = pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE);
d2965 2
a2966 2
	    BGE_PCIMISCCTL_INDIRECT_ACCESS|BGE_PCIMISCCTL_MASK_PCI_INTR|
	    BGE_PCIMISCCTL_ENDIAN_WORDSWAP|BGE_PCIMISCCTL_PCISTATE_RW);
d2973 8
a2980 1
	reset = BGE_MISCCFG_RESET_CORE_CLOCKS|(65<<1);
d2983 6
a2988 3
		if (CSR_READ_4(sc, 0x7e2c) == 0x60) {
			/* PCI Express 1.0 system */
			CSR_WRITE_4(sc, 0x7e2c, 0x20);
d3004 2
a3005 1
	if (BGE_IS_5705_PLUS(sc))
d3009 6
a3014 1
	bge_writereg_ind(sc, BGE_MISC_CFG, reset);
a3028 2
	DELAY(1000);

d3048 11
a3058 2
	    BGE_PCIMISCCTL_INDIRECT_ACCESS|BGE_PCIMISCCTL_MASK_PCI_INTR|
	    BGE_PCIMISCCTL_ENDIAN_WORDSWAP|BGE_PCIMISCCTL_PCISTATE_RW);
a3060 1
	bge_writereg_ind(sc, BGE_MISC_CFG, (65 << 1));
a3063 2
		u_int32_t val;

d3069 9
a3077 5
 	/*
	 * Prevent PXE restart: write a magic number to the
	 * general communications memory at 0xB50.
	 */
	bge_writemem_ind(sc, BGE_SOFTWARE_GENCOMM, BGE_MAGIC_NUMBER);
d3106 3
a3111 27
	 * XXX Wait for the value of the PCISTATE register to
	 * return to its original pre-reset state. This is a
	 * fairly good indicator of reset completion. If we don't
	 * wait for the reset to fully complete, trying to read
	 * from the device's non-PCI registers may yield garbage
	 * results.
	 */
	for (i = 0; i < BGE_TIMEOUT; i++) {
		new_pcistate = pci_conf_read(pa->pa_pc, pa->pa_tag,
		    BGE_PCI_PCISTATE);
		if ((new_pcistate & ~BGE_PCISTATE_RESERVED) ==
		    (pcistate & ~BGE_PCISTATE_RESERVED))
			break;
		DELAY(10);
	}
	if ((new_pcistate & ~BGE_PCISTATE_RESERVED) != 
	    (pcistate & ~BGE_PCISTATE_RESERVED)) {
		DPRINTFN(5, ("%s: pcistate failed to revert\n",
		    sc->bge_dev.dv_xname));
	}

	/* Fix up byte swapping */
	CSR_WRITE_4(sc, BGE_MODE_CTL, BGE_DMA_SWAP_OPTIONS);

	CSR_WRITE_4(sc, BGE_MAC_MODE, 0);

	/*
d3126 1
d3128 1
a3128 3
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5717 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5785 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM57765) {
d3135 4
a3138 1
	DELAY(10000);
d3248 1
a3248 1
		m->m_pkthdr.len = m->m_len = cur_rx->bge_len - ETHER_CRC_LEN; 
d3379 1
d3384 3
d3394 5
d3402 1
a3402 1
	    (!(CSR_READ_4(sc, BGE_PCI_PCISTATE) & BGE_PCISTATE_INTR_NOT_ACTIVE))) {
d3410 5
d3468 1
a3468 1
	}       
d3483 3
a3485 3
	ifp->if_ierrors += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_IFIN_DROPS);

	ifp->if_ierrors += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_IFIN_ERRORS);
d3487 2
a3488 1
	ifp->if_ierrors += CSR_READ_4(sc, BGE_RXLP_LOCSTAT_OUT_OF_BDS);
d3838 1
a3838 1
	u_int32_t rxmode;
d3847 1
d3849 3
d3923 11
d3935 2
a3936 3
	BGE_SETBIT(sc, BGE_TX_MODE, BGE_TXMODE_ENABLE);

	rxmode = BGE_RXMODE_ENABLE;
d3938 1
d3940 1
a3940 1
		rxmode |= BGE_RXMODE_RX_IPV6_CSUM_ENABLE;
d3943 2
a3944 1
	BGE_SETBIT(sc, BGE_RX_MODE, rxmode);
d4002 1
d4207 7
d4249 1
a4249 1
	if (BGE_IS_5700_FAMILY(sc)) {
d4254 3
a4256 3
	/* Disable host interrupts. */
	BGE_SETBIT(sc, BGE_PCI_MISC_CTL, BGE_PCIMISCCTL_MASK_PCI_INTR);
	bge_writembx(sc, BGE_MBX_IRQ0_LO, 1);
d4342 1
a4342 1
	} 
d4367 1
a4367 1
        /*
d4373 1
a4373 1
		/* 
@


1.314
log
@dont hardcode the phy address at 1. the 5718 family of chips can have
phys as 1, 2, 8, or 9 depending on which pci function its on and whether
its serdes.

this tells every other bge that the phy is still at 1, so they still work.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.313 2013/01/10 01:02:12 dlg Exp $	*/
d48 1
a48 1
 * MAC chips. The BCM5700, sometimes refered to as the Tigon III, has
d50 1
a50 1
 * SSRAM. The BCM5700 supports TCP, UDP and IP checksum offload, Jumbo
d570 1
a570 1
	int err = 0, i;
d574 2
a575 2
		err = bge_eeprom_getbyte(sc, off + i, &byte);
		if (err)
d580 1
a580 1
	return (err ? 1 : 0);
@


1.313
log
@oh hey guys, ive got this cool new thing called a "switch statement". your
if (thing == foo || thing == bar || thing == baz) is ugly.

no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.312 2012/09/13 04:15:18 dlg Exp $	*/
d183 1
d1161 23
d1897 2
d2275 1
a2275 1
		    1, MII_OFFSET_ANY, mii_flags);
d3684 4
a3687 3
			bge_miibus_readreg(&sc->bge_dev, 1, BRGPHY_MII_ISR);
			bge_miibus_writereg(&sc->bge_dev, 1, BRGPHY_MII_IMR,
			    BRGPHY_INTRS);
@


1.312
log
@tell mii_attach where the phy is on the chip, rather than asking it to
probe every address and have bge_miibus_read fail at the wrong address.

needed to support recent chips which have phys in locations other than
phy address 1 (and removes a conditional in an io path).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.311 2012/07/04 13:24:41 kettenis Exp $	*/
d1851 3
a1853 2
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5717 ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5718)
d1856 7
a1862 6
		else if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57761 ||
			 PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57765 ||
			 PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57781 ||
			 PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57785 ||
			 PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57791 ||
			 PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM57795)
d1865 2
a1866 1
		else
d1869 2
@


1.311
log
@Invert the logic for detecting fibre interface media adapters.
Only the BCM5700-BCM5704 adapters had TBI interfaces for fibre
and anyting newer uses the MII interface.

From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.310 2012/07/04 08:06:33 kettenis Exp $	*/
a588 12
	/*
	 * Broadcom's own driver always assumes the internal
	 * PHY is at GMII address 1. On some chips, the PHY responds
	 * to accesses at all addresses, which could cause us to
	 * bogusly attach the PHY 32 times at probe type. Always
	 * restricting the lookup to address 1 is simpler than
	 * trying to figure out which chips revisions should be
	 * special-cased.
	 */
	if (phy != 1)
		return (0);

d2244 2
a2245 2
			   MII_PHY_ANY, MII_OFFSET_ANY, mii_flags);
		
@


1.310
log
@Set the 10_100_ONLY flag for the BCM57791/BCM57795 chipsets
as they're FastE chipsets. So ifconfig media doesn't list
GigE for FastE-only capable PHY.

From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.309 2012/06/28 11:52:15 mikeb Exp $	*/
d2211 3
a2213 2
		if (BGE_IS_5714_FAMILY(sc) ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717)
a2214 2
		else
		    sc->bge_flags |= BGE_PHY_FIBER_TBI;
@


1.309
log
@Devices with BCM5724 BCM5750 and BCM5750M PCI IDs were never released
to the public; from broadcom/linux via brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.308 2012/06/09 09:45:14 dlg Exp $	*/
d1994 2
@


1.308
log
@we dont support the BCM5720. the macro wasnt even referring to the products
actual id.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.307 2011/06/22 16:44:27 tedu Exp $	*/
a246 3
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5724 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5750 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5750M },
d1864 1
a1864 2
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5718 ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5724)
@


1.307
log
@kill a few more casts that aren't helpful.  ok krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.306 2011/04/05 18:01:21 henning Exp $	*/
a243 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5720 },
@


1.306
log
@mechanic rename M_{TCP|UDP}V4_CSUM_OUT -> M_{TCP|UDP}_CSUM_OUT
ok claudio krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.305 2011/02/22 18:00:44 robert Exp $	*/
d869 1
a869 1
		bzero((char *)&sc->bge_rdata->bge_rx_std_ring[i],
d955 1
a955 1
		bzero((char *)&sc->bge_rdata->bge_rx_std_ring[i],
d979 1
a979 1
		bzero((char *)&sc->bge_rdata->bge_rx_jumbo_ring[i],
d1054 1
a1054 1
		bzero((char *)&sc->bge_rdata->bge_rx_jumbo_ring[i],
d1078 1
a1078 1
		bzero((char *)&sc->bge_rdata->bge_tx_ring[i],
d2910 1
a2910 3
			bcopy(m->m_data,
			      prev->m_data+prev->m_len,
			      mlen);
d2922 1
a2922 3
			bcopy(m->m_next->m_data,
			      m->m_data+m->m_len,
			      shortfall);
@


1.305
log
@Disable PCIe Active State Power Management (ASPM) to avoid bge(4) randomly
detaching from the bus on some of the machines.
tested by many, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.304 2011/02/15 19:49:47 robert Exp $	*/
d3041 2
a3042 2
		if (m_head->m_pkthdr.csum_flags & (M_TCPV4_CSUM_OUT |
		    M_UDPV4_CSUM_OUT)) {
@


1.304
log
@Add workaround for BCM5906 A0/1/2 controller silicon bug. When
auto-negotiation results in half-duplex operation, excess collision
on the ethernet link may cause internal chip delays that may result
in subsequent valid frames being dropped due to insufficient
receive buffer resources. The workaround is to choose de-pipeline
method as a flow control decision for SDI. De-pipeline method
allows only 1 data in TxMbuf at a time such that a request to RDMA
from SDI is made only when TxMbuf is empty.
From FreeBSD; ok miod@@; ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.303 2010/09/20 07:40:38 deraadt Exp $	*/
d1805 1
a1805 1
	pcireg_t		pm_ctl, memtype, subid;
d1810 1
a1810 1
	int			rseg, gotenaddr = 0;
d1896 7
a1902 1
	    NULL, NULL) != 0) {
@


1.303
log
@Stop doing shutdown hooks in network drivers where possible.  We already
take all interfaces down, via their xxstop routines.  Claudio and I have
verified that none of the shutdown hooks do much extra beyond what xxstop
was already doing; it is largely a pile of junk.
ok claudio, some early comments by sthen; also read by matthew, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.302 2010/09/07 16:21:44 deraadt Exp $	*/
d1467 8
@


1.302
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.301 2010/08/31 17:13:44 deraadt Exp $	*/
a156 1
void bge_shutdown(void *);
a2264 2
	sc->sc_shutdownhook = shutdownhook_establish(bge_shutdown, sc);
	
a3616 13
}

/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
void
bge_shutdown(void *xsc)
{
	struct bge_softc *sc = (struct bge_softc *)xsc;

	bge_stop(sc);
	bge_reset(sc);
@


1.301
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.300 2010/08/31 16:27:36 deraadt Exp $	*/
a153 1
void bge_powerhook(int, void *);
a2266 1
	sc->sc_powerhook = powerhook_establish(bge_powerhook, sc);
a3736 6
}

void
bge_powerhook(int why, void *arg)
{
	bge_activate(arg, why);
@


1.300
log
@activate function should return result of config_activate_children
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.299 2010/08/27 19:48:14 deraadt Exp $	*/
d2299 3
@


1.299
log
@The powerhook only did stuff at resume; but suspend matters too!
Instead of fixing it, make it call the activate function which does
the full job
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.298 2010/08/07 03:50:02 krw Exp $	*/
d2296 1
d2300 1
a2300 1
		config_activate_children(self, act);
d2307 1
a2307 1
		config_activate_children(self, act);
d2310 1
a2310 1
	return (0);
@


1.298
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.297 2010/08/02 19:36:13 kettenis Exp $	*/
d154 1
a154 1
void bge_power(int, void *);
d2268 1
a2268 1
	sc->sc_powerhook = powerhook_establish(bge_power, sc);	
d2299 1
d2304 3
a2306 1
		bge_power(PWR_RESUME, self);
a2308 1

d3738 1
a3738 1
bge_power(int why, void *xsc)
d3740 1
a3740 8
	struct bge_softc *sc = (struct bge_softc *)xsc;
	struct ifnet *ifp;

	if (why == PWR_RESUME) {
		ifp = &sc->arpcom.ac_if;
		if (ifp->if_flags & IFF_UP)
			bge_init(xsc);
	}
@


1.297
log
@There is no reason to call the start function upon resume; the network stack
is perfectly capable to get things going again all by itself.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.296 2010/07/27 21:56:11 todd Exp $	*/
d835 1
a835 1
		panic("%s: %d segments\n", __func__, dmap->dm_nsegs);
@


1.296
log
@spacing; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.295 2010/07/27 19:38:18 kettenis Exp $	*/
d3743 1
a3743 1
		if (ifp->if_flags & IFF_UP) {
a3744 2
			bge_start(ifp);
		}
@


1.295
log
@Make sure we stop DMA before we suspend.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.294 2010/07/09 00:04:42 sthen Exp $	*/
d2297 1
a2297 1
	switch(act) {
@


1.294
log
@- Setup proper mbuf pool watermarks for BCM5717 / BCM57765 chipsets.
- Disable initiation of multiple DMA reads for BCM5717 chipset
  to workaround errata.
- Performance tweak for BCM5785 chipset.
- Correct the return ring count used for BCM5717 / BCM57765 chipsets.
- Fix fiber media detection for BCM5717 chipsets as they use a MII-based
  fiber PHY.

From Brad, based on info gleaned from the Linux tg3 driver.
Should only affect the new chipsets, but tested for regressions
anyway (on BCM5701, BCM5703, BCM5704C, BCM5705M Alt, BCM5722, BCM5751,
BCM5751M, BCM5780) by Brad, weerd@@, myself and Denis Doroshenko.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.293 2010/04/06 15:27:51 naddy Exp $	*/
d2294 3
d2299 2
@


1.293
log
@A fix for the PCI-X check so that this is only tested on controllers
that could be PCI-X. This bit is not valid for PCIe controllers.
From Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.292 2010/03/30 14:24:03 naddy Exp $	*/
d1355 6
a1360 3
	if (BGE_IS_5705_PLUS(sc) &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5717 &&
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM57765) {
d1666 3
d1674 3
d2128 5
a2132 1
	if (BGE_IS_5705_PLUS(sc))
a2133 2
	else
		sc->bge_return_ring_cnt = BGE_RETURN_RING_CNT;
d2202 2
a2203 1
		if (BGE_IS_5714_FAMILY(sc))
@


1.292
log
@Have bge_start check if there are less than 16 free send BDs and if not
set IFF_OACTIVE and try again later. Previously bge(4) reserved 16 send
BDs after loading DMA maps but the hardware only requires one reserved
send BD.

From FreeBSD, via Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.291 2010/01/10 00:07:40 naddy Exp $	*/
d1878 1
a1878 1
	 * PCI Express check.
d1881 1
a1881 1
	    NULL, NULL) != 0)
d1883 5
a1887 7

	/*
	 * PCI-X check.
	 */
	if ((pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE) &
	    BGE_PCISTATE_PCI_BUSMODE) == 0)
		sc->bge_flags |= BGE_PCIX;
@


1.291
log
@Do not try to reevaluate the current RX production index on each
loop iteration as it can be updated by the card while we process
the RX ring, forcing us to process RX descriptors for which DMA
synchronisation has not been performed. This fixes a bug where
bge(4) will drop packets packets under heavy load.

Adapted from FreeBSD by Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.290 2010/01/09 06:19:01 naddy Exp $	*/
d3046 2
a3047 5
	/*
	 * Sanity check: avoid coming within 16 descriptors
	 * of the end of the ring.
	 */
	if (dmamap->dm_nsegs > (BGE_TX_RING_CNT - sc->bge_txcnt - 16))
d3101 1
a3101 1
	struct mbuf *m_head = NULL;
d3103 1
a3103 1
	int pkts = 0;
a3110 2
	if (IFQ_IS_EMPTY(&ifp->if_snd))
		return;
d3114 6
a3119 1
	while (sc->bge_cdata.bge_tx_chain[prodidx] == NULL) {
@


1.290
log
@Add support for the Broadcom BCM57765 ASIC and newer Broadcom
BCM577xx chipsets.  From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.289 2009/12/17 00:55:19 sthen Exp $	*/
d2496 1
d2503 3
d2507 1
a2507 2
	if (sc->bge_rx_saved_considx ==
	    sc->bge_rdata->bge_status_block.bge_idx[0].bge_rx_prod_idx)
d2518 1
a2518 2
	tosync = sc->bge_rdata->bge_status_block.bge_idx[0].bge_rx_prod_idx -
	    sc->bge_rx_saved_considx;
d2520 1
a2520 1
	toff = offset + (sc->bge_rx_saved_considx * sizeof (struct bge_rx_bd));
d2523 1
a2523 1
		tlen = (sc->bge_return_ring_cnt - sc->bge_rx_saved_considx) *
d2534 1
a2534 2
	while(sc->bge_rx_saved_considx !=
	    sc->bge_rdata->bge_status_block.bge_idx[0].bge_rx_prod_idx) {
d2539 1
a2539 2
		cur_rx = &sc->bge_rdata->
			bge_rx_return_ring[sc->bge_rx_saved_considx];
d2542 1
a2542 1
		BGE_INC(sc->bge_rx_saved_considx, sc->bge_return_ring_cnt);
d2632 1
@


1.289
log
@- correct the PCI ids for the BCM5717 and BCM5718 chipsets
- add BCM5724 chipset

from Linux driver via Brad.

- sort by device-id
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.288 2009/12/09 17:13:02 naddy Exp $	*/
d290 2
d293 2
d297 2
d409 1
d1356 2
a1357 1
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5717) {
d1414 2
a1415 1
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717)
d1477 2
a1478 1
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5717) {
d1857 8
d1925 1
d2003 1
d2472 2
a2473 1
	    BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5785) {
@


1.288
log
@Do not count input errors twice. We always read input errors from
the MAC in bge_tick(). Previously this would result in bge(4) claiming
a greater number of input errors than what has actually occurred.

From FreeBSD via Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.287 2009/11/30 19:08:01 kettenis Exp $	*/
d244 2
a245 4
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5717C },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5717S },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5718C },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5718S },
d250 1
d1842 3
a1844 4
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5717C ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5717S ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5718C ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5718S)
@


1.287
log
@Re-initialise the interface upon resume.

ok deraadt@@, pirofti@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.286 2009/10/11 16:53:13 sthen Exp $	*/
a2538 1
				ifp->if_ierrors++;
a2554 1
				ifp->if_ierrors++;
@


1.286
log
@Correct a copy-and-pasto (check for the same device type twice in
an if statement) in the last commit. From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.285 2009/10/11 10:36:31 sthen Exp $	*/
d130 1
d133 1
a133 1
	sizeof(struct bge_softc), bge_probe, bge_attach
d2261 14
@


1.285
log
@Add support for the Broadcom BCM5717 ASIC and the BCM5717 / BCM5718 chipsets.
Based on info gleaned from the Linux tg3 driver. From Brad, ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.284 2009/10/07 22:05:51 sthen Exp $	*/
d1844 2
a1845 2
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5717C ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5717S)
@


1.284
log
@The BCM5703 ASIC ID is actually shared with the BCM5702 ASIC so
indicate so in the text strings. From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.283 2009/10/02 18:32:40 sthen Exp $	*/
d243 4
d402 1
d1348 2
a1349 1
	if (BGE_IS_5705_PLUS(sc)) {
d1406 4
a1409 1
	if (BGE_IS_5705_PLUS(sc))
d1468 5
d1842 9
a1850 2
		sc->bge_chipid = pci_conf_read(pc, pa->pa_tag,
		    BGE_PCI_PRODID_ASICREV);
d1902 2
a1903 1
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5755 ||
d1983 1
d2437 3
a2439 1
	    sc->bge_chipid != BGE_CHIPID_BCM5750_A0) {
@


1.283
log
@Remove BCM57720 as it's not going to be released. From a Broadcom
commit to the Linux driver via Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.282 2009/09/30 19:20:52 sthen Exp $	*/
d322 6
a327 5
	{ BGE_CHIPID_BCM5703_A0, "BCM5703 A0" },
	{ BGE_CHIPID_BCM5703_A1, "BCM5703 A1" },
	{ BGE_CHIPID_BCM5703_A2, "BCM5703 A2" },
	{ BGE_CHIPID_BCM5703_A3, "BCM5703 A3" },
	{ BGE_CHIPID_BCM5703_B0, "BCM5703 B0" },
@


1.282
log
@- Sync the BCM5785G PCI id for bge(4) and add BCM5785F / BCM57788.

PCI ids from the Linux tg3 driver via Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.281 2009/08/13 14:24:47 jasper Exp $	*/
a284 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM57720 },
@


1.281
log
@- consistify cfdriver for the ethernet drivers (0 -> NULL)

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.280 2009/08/09 11:40:56 deraadt Exp $	*/
d272 2
a273 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5785 },
d288 1
@


1.280
log
@MCLGETI() will now allocate a mbuf header if it is not provided, thus
reducing the amount of splnet/splx dancing required.. especially in the
worst case (of m_cldrop)
ok dlg kettenis damien
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.279 2009/08/08 15:58:14 naddy Exp $	*/
d136 1
a136 1
	0, "bge", DV_IFNET
@


1.279
log
@bring comments in line with reality; from Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.278 2009/08/06 10:42:54 sthen Exp $	*/
d722 2
a723 2
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
a724 6

	MCLGETI(m, M_DONTWAIT, &sc->arpcom.ac_if, MCLBYTES);
	if (!(m->m_flags & M_EXT)) {
		m_freem(m);
		return (ENOBUFS);
	}
d773 2
a774 2
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
a775 6

	MCLGETI(m, M_DONTWAIT, &sc->arpcom.ac_if, BGE_JLEN);
	if (!(m->m_flags & M_EXT)) {
		m_freem(m);
		return (ENOBUFS);
	}
@


1.278
log
@Backout r1.274, william@@ has tracked down watchdog timeouts with
his BCM5703 A2 to this commit.

Original commit message was: "Set the DMA read watermark to 4 on the
BCM5703 chipset in PCI-X mode. This is needed to prevent some TX
timeouts.  From Brad. Tested by myself on BCM5703 B0 on PCI-X 64/66".
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.277 2009/07/21 13:09:41 naddy Exp $	*/
d39 1
a39 1
 * Broadcom BCM570x family gigabit ethernet driver for FreeBSD.
@


1.277
log
@Add a family flag for the original 5700 series chipsets. Idea from FreeBSD.
But also use the flag where it makes sense.  From Brad; ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.276 2009/06/19 21:31:54 naddy Exp $	*/
a1227 4
			    BGE_PCIDMARWCTL_WR_WAT_SHIFT(3);
		} else if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5703) {
			/* 512 bytes for read, 384 bytes for write. */
			dma_rw_ctl |= BGE_PCIDMARWCTL_RD_WAT_SHIFT(4) |
@


1.276
log
@Allow bge(4) to recognize the revisions of the 57780 ASICs.  From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.275 2009/06/11 23:11:27 sthen Exp $	*/
d301 1
d1340 1
a1340 1
	if (!(BGE_IS_5705_PLUS(sc))) {
d1493 1
a1493 1
	if (!(BGE_IS_5705_PLUS(sc)))
d1577 1
a1577 1
	if (!(BGE_IS_5705_PLUS(sc))) {
d1585 1
a1585 1
	if (!(BGE_IS_5705_PLUS(sc))) {
d1614 1
a1614 1
	if (!(BGE_IS_5705_PLUS(sc)))
d1644 1
a1644 1
	if (!(BGE_IS_5705_PLUS(sc)))
d1681 1
a1681 1
	if (!(BGE_IS_5705_PLUS(sc)))
d1883 5
d1926 1
a1926 1
	if (!(BGE_IS_5705_PLUS(sc)))
d3482 1
a3482 1
	if (!(BGE_IS_5705_PLUS(sc)))
d3496 1
a3496 1
	if (!(BGE_IS_5705_PLUS(sc)))
d3506 1
a3506 1
	if (!(BGE_IS_5705_PLUS(sc)))
d3512 1
a3512 1
	if (!(BGE_IS_5705_PLUS(sc))) {
@


1.276.4.1
log
@MFC:

Backout r1.274, william@@ has tracked down watchdog timeouts with
his BCM5703 A2 to this commit.

Original commit message was: "Set the DMA read watermark to 4 on the
BCM5703 chipset in PCI-X mode. This is needed to prevent some TX
timeouts.  From Brad. Tested by myself on BCM5703 B0 on PCI-X 64/66".

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.276 2009/06/19 21:31:54 naddy Exp $	*/
d1227 4
@


1.275
log
@Limit the BCM5701 B5 chipset to 32-bit mode as a workaround for a
bug which causes data corruption in combination with certain
bridges.  Tested on BCM5701 B5 (0x105).

From FreeBSD via Brad. http://www.freebsd.org/cgi/query-pr.cgi?pr=128833
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.274 2009/06/11 22:44:14 sthen Exp $	*/
d365 2
@


1.274
log
@Set the DMA read watermark to 4 on the BCM5703 chipset in PCI-X mode.
This is needed to prevent some TX timeouts. From Brad. Tested by myself
on BCM5703 B0 on PCI-X 64/66
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.273 2009/06/06 14:25:38 sthen Exp $	*/
d1277 10
@


1.273
log
@remove unused variable prevlen and a second initialization of ifp.
adjusted from a diff from chl@@; ok naddy, Brad agrees.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.272 2009/06/05 03:57:32 ray Exp $	*/
d1225 4
@


1.272
log
@%zu is not meant for size_t in the kernel. Change to %lu.

OK miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.271 2009/06/04 04:09:02 naddy Exp $	*/
d2792 1
a2792 1
	int 		totlen, prevlen, newprevlen;
a2795 1
	prevlen = -1;
a2877 1
		prevlen = m->m_len;
a3123 2

	ifp = &sc->arpcom.ac_if;
@


1.271
log
@enable IPv6 receive TCP/UDP checksum offload for the 5755 and later chips;
from Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.270 2009/06/04 00:59:21 naddy Exp $	*/
d2040 1
a2040 1
		printf(": can't map dma buffers (%zu bytes)\n",
@


1.270
log
@replace the cumbersome macros that check for chip revisions with quirk flags
set at attach; from Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.269 2009/06/03 20:54:45 naddy Exp $	*/
d3105 1
d3191 5
d3197 1
a3197 1
	BGE_SETBIT(sc, BGE_RX_MODE, BGE_RXMODE_ENABLE);
@


1.269
log
@rename some macros for more consistent naming; from Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.268 2009/06/03 05:55:15 naddy Exp $	*/
d298 5
a302 49
#define BGE_IS_5705_PLUS(sc)  \
	(BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5705    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5750    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714_A0 || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5780    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5752    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5755    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5785    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5787    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57780)

#define BGE_IS_5750_PLUS(sc)  \
	(BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5750    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714_A0 || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5780    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5752    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5755    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5785    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5787    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57780)

/* Intentionally exlcude BGE_ASICREV_BCM5906 */
#define BGE_IS_5755_PLUS(sc)  \
	(BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5755    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5785    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5787    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57780)

#define BGE_IS_5714_FAMILY(sc)  \
	(BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714_A0 || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5780    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714)

#define BGE_IS_JUMBO_CAPABLE(sc)  \
	(BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5703    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704)

d1867 25
d1904 2
a1905 2
	if (BGE_IS_JUMBO_CAPABLE(sc))
		sc->bge_flags |= BGE_JUMBO_CAP;
@


1.268
log
@set IFF_ALLMULTI properly also when in promiscuous mode and some
cosmetic tweaking; from Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.267 2009/06/03 05:19:21 naddy Exp $	*/
d298 1
a298 1
#define BGE_IS_5705_OR_BEYOND(sc)  \
d313 1
a313 1
#define BGE_IS_575X_PLUS(sc)  \
d1367 1
a1367 1
	if (!(BGE_IS_5705_OR_BEYOND(sc))) {
d1384 1
a1384 1
	if (BGE_IS_5705_OR_BEYOND(sc)) {
d1441 1
a1441 1
	if (BGE_IS_5705_OR_BEYOND(sc))
d1520 1
a1520 1
	if (!(BGE_IS_5705_OR_BEYOND(sc)))
d1604 1
a1604 1
	if (!(BGE_IS_5705_OR_BEYOND(sc))) {
d1612 1
a1612 1
	if (!(BGE_IS_5705_OR_BEYOND(sc))) {
d1641 1
a1641 1
	if (!(BGE_IS_5705_OR_BEYOND(sc)))
d1671 1
a1671 1
	if (!(BGE_IS_5705_OR_BEYOND(sc)))
d1708 1
a1708 1
	if (!(BGE_IS_5705_OR_BEYOND(sc)))
d1970 1
a1970 1
	if ((BGE_IS_5705_OR_BEYOND(sc)) &&
d2090 1
a2090 1
	if (BGE_IS_5705_OR_BEYOND(sc))
d2293 1
a2293 1
	if (BGE_IS_5705_OR_BEYOND(sc))
d2728 1
a2728 1
	if (BGE_IS_5705_OR_BEYOND(sc))
d3477 1
a3477 1
	if (!(BGE_IS_5705_OR_BEYOND(sc)))
d3491 1
a3491 1
	if (!(BGE_IS_5705_OR_BEYOND(sc)))
d3501 1
a3501 1
	if (!(BGE_IS_5705_OR_BEYOND(sc)))
d3507 1
a3507 1
	if (!(BGE_IS_5705_OR_BEYOND(sc))) {
@


1.267
log
@register bit definitions instead of magic numbers;
gleaned from the Linux tg3 driver; from Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.266 2009/06/02 03:58:17 naddy Exp $	*/
d1195 2
a1196 1
	if (ifp->if_flags & IFF_PROMISC)
d1198 1
a1198 1
	else if (ac->ac_multirangecnt > 0) {
d1205 1
d1207 1
a1213 1

@


1.266
log
@minor tidying; from Brad; ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.265 2009/06/02 02:16:41 sthen Exp $	*/
d1676 1
a1676 1
		val |= (1 << 29);
@


1.265
log
@"Add a macro to define the newer generation of bge(4) chipsets. Simplifies
things a bit a and helps with adding support for more newer chipsets
with the same common features.

From the Linux tg3 driver."

From Brad; binaries are not identical; the if statement is changed
slightly, but no functional change. Looks fine to naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.264 2009/05/24 14:11:35 naddy Exp $	*/
d3366 1
a3366 1
				bge_iff(sc);
a3372 1
		sc->bge_if_flags = ifp->if_flags;
@


1.264
log
@Support hardware checksumming, from FreeBSD.
Enable for IP/UDP/TCP receipt and IP transmit.
Keep disabled for UDP/TCP transmit because it breaks with pf(4) rdr.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.263 2009/05/21 23:04:20 sthen Exp $	*/
d327 9
d1675 1
a1675 6
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5755 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5785 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5787 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57780)
d2267 1
a2267 6
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5755 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5761 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5784 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5785 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5787 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM57780)
@


1.263
log
@add support for BCM576x, 577xx, and some new 572x/578x devices.
from Brad; testing by phessler, naddy, myself and others on a range
of older and newer devices. ok dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.262 2009/04/23 19:15:07 kettenis Exp $	*/
d125 2
d145 1
d147 1
a147 1
int bge_compact_dma_runt(struct mbuf *pkt);
a1302 1
#ifndef BGE_CHECKSUM
d1305 1
a1305 5
		    BGE_MODECTL_TX_NO_PHDR_CSUM|BGE_MODECTL_RX_NO_PHDR_CSUM);
#else
	CSR_WRITE_4(sc, BGE_MODE_CTL, BGE_DMA_SWAP_OPTIONS|
		    BGE_MODECTL_MAC_ATTN_INTR|BGE_MODECTL_HOST_SEND_BDS);
#endif
d2112 10
a2487 3
#ifdef BGE_CHECKSUM
		u_int16_t		sumflags = 0;
#endif
d2546 21
a2581 15
#ifdef BGE_CHECKSUM
		if ((cur_rx->bge_ip_csum ^ 0xffff) == 0)
			sumflags |= M_IPV4_CSUM_IN_OK;
		else
			sumflags |= M_IPV4_CSUM_IN_BAD;

		if (cur_rx->bge_flags & BGE_RXBDFLAG_TCP_UDP_CSUM) {
			m->m_pkthdr.csum_data =
				cur_rx->bge_tcp_udp_csum;
			m->m_pkthdr.csum_flags |= CSUM_DATA_VALID;
		}

		m->m_pkthdr.csum_flags = sumflags;
		sumflags = 0;
#endif
d2903 44
a2961 1
#ifdef BGE_CHECKSUM
d2966 1
a2966 1
					     M_UDPV4_CSUM_OUT))
d2968 4
a2971 6
#ifdef fake
		if (m_head->m_flags & M_LASTFRAG)
			csum_flags |= BGE_TXBDFLAG_IP_FRAG_END;
		else if (m_head->m_flags & M_FRAG)
			csum_flags |= BGE_TXBDFLAG_IP_FRAG;
#endif
d2973 1
a2973 1
#endif
@


1.262
log
@Start using extended buffer descriptors on the jumbo ring and use MCLGETI to
allocate mbufs for it.  Another jumbo allocator bites the dust!

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.261 2009/01/27 09:17:51 dlg Exp $	*/
d243 1
d259 5
d268 2
d281 4
d303 3
d307 2
a308 1
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906)
d317 3
d321 2
a322 1
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906)
d387 4
d418 3
d424 1
d1669 5
a1673 1
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5787)
d1681 7
d1710 5
d1716 1
a1716 1
	CSR_WRITE_4(sc, BGE_SDC_MODE, BGE_SDCMODE_ENABLE);
d1860 3
d1864 4
a1867 3
	sc->bge_chipid =
            pci_conf_read(pc, pa->pa_tag, BGE_PCI_MISC_CTL) &
            BGE_PCIMISCCTL_ASICREV;
d1872 1
a1872 1
		printf("unknown ASIC (0x%04x)", sc->bge_chipid >> 16);
d1874 1
a1874 1
		printf("%s (0x%04x)", br->br_name, sc->bge_chipid >> 16);
d1946 1
d1966 4
a1969 1
	if (BGE_IS_5705_OR_BEYOND(sc)) {
d1971 2
d1979 1
a1979 1
		} else if (BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5906)
d2256 5
a2260 1
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5787)
@


1.261
log
@make drivers tell the mclgeti allocator what their maximum ring size is
to prevent the hwm growing beyond that. this allows the livelock mitigation
to do something where the hwm used to grow beyond twice the rx rings size.

ok kettenis@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.260 2008/12/23 00:14:18 dlg Exp $	*/
d165 1
a165 4
int bge_alloc_jumbo_mem(struct bge_softc *);
void *bge_jalloc(struct bge_softc *);
void bge_jfree(caddr_t, u_int, void *);
int bge_newbuf_jumbo(struct bge_softc *, int, struct mbuf *);
d167 1
a712 146
 * Memory management for Jumbo frames.
 */

int
bge_alloc_jumbo_mem(struct bge_softc *sc)
{
	caddr_t			ptr, kva;
	bus_dma_segment_t	seg;
	int		i, rseg, state, error;
	struct bge_jpool_entry   *entry;

	state = error = 0;

	/* Grab a big chunk o' storage. */
	if (bus_dmamem_alloc(sc->bge_dmatag, BGE_JMEM, PAGE_SIZE, 0,
			     &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
		printf("%s: can't alloc rx buffers\n", sc->bge_dev.dv_xname);
		return (ENOBUFS);
	}

	state = 1;
	if (bus_dmamem_map(sc->bge_dmatag, &seg, rseg, BGE_JMEM, &kva,
			   BUS_DMA_NOWAIT)) {
		printf("%s: can't map dma buffers (%d bytes)\n",
		    sc->bge_dev.dv_xname, BGE_JMEM);
		error = ENOBUFS;
		goto out;
	}

	state = 2;
	if (bus_dmamap_create(sc->bge_dmatag, BGE_JMEM, 1, BGE_JMEM, 0,
	    BUS_DMA_NOWAIT, &sc->bge_cdata.bge_rx_jumbo_map)) {
		printf("%s: can't create dma map\n", sc->bge_dev.dv_xname);
		error = ENOBUFS;
		goto out;
	}

	state = 3;
	if (bus_dmamap_load(sc->bge_dmatag, sc->bge_cdata.bge_rx_jumbo_map,
			    kva, BGE_JMEM, NULL, BUS_DMA_NOWAIT)) {
		printf("%s: can't load dma map\n", sc->bge_dev.dv_xname);
		error = ENOBUFS;
		goto out;
	}

	state = 4;
	sc->bge_cdata.bge_jumbo_buf = (caddr_t)kva;
	DPRINTFN(1,("bge_jumbo_buf = 0x%08X\n", sc->bge_cdata.bge_jumbo_buf));

	SLIST_INIT(&sc->bge_jfree_listhead);
	SLIST_INIT(&sc->bge_jinuse_listhead);

	/*
	 * Now divide it up into 9K pieces and save the addresses
	 * in an array.
	 */
	ptr = sc->bge_cdata.bge_jumbo_buf;
	for (i = 0; i < BGE_JSLOTS; i++) {
		sc->bge_cdata.bge_jslots[i] = ptr;
		ptr += BGE_JLEN;
		entry = malloc(sizeof(struct bge_jpool_entry),
		    M_DEVBUF, M_NOWAIT);
		if (entry == NULL) {
			printf("%s: no memory for jumbo buffer queue!\n",
			    sc->bge_dev.dv_xname);
			error = ENOBUFS;
			goto out;
		}
		entry->slot = i;
		SLIST_INSERT_HEAD(&sc->bge_jfree_listhead,
				 entry, jpool_entries);
	}
out:
	if (error != 0) {
		switch (state) {
		case 4:
			bus_dmamap_unload(sc->bge_dmatag,
			    sc->bge_cdata.bge_rx_jumbo_map);
		case 3:
			bus_dmamap_destroy(sc->bge_dmatag,
			    sc->bge_cdata.bge_rx_jumbo_map);
		case 2:
			bus_dmamem_unmap(sc->bge_dmatag, kva, BGE_JMEM);
		case 1:
			bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
			break;
		default:
			break;
		}
	}

	return (error);
}

/*
 * Allocate a Jumbo buffer.
 */
void *
bge_jalloc(struct bge_softc *sc)
{
	struct bge_jpool_entry   *entry;

	entry = SLIST_FIRST(&sc->bge_jfree_listhead);

	if (entry == NULL)
		return (NULL);

	SLIST_REMOVE_HEAD(&sc->bge_jfree_listhead, jpool_entries);
	SLIST_INSERT_HEAD(&sc->bge_jinuse_listhead, entry, jpool_entries);
	return (sc->bge_cdata.bge_jslots[entry->slot]);
}

/*
 * Release a Jumbo buffer.
 */
void
bge_jfree(caddr_t buf, u_int size, void *arg)
{
	struct bge_jpool_entry *entry;
	struct bge_softc *sc;
	int i;

	/* Extract the softc struct pointer. */
	sc = (struct bge_softc *)arg;

	if (sc == NULL)
		panic("bge_jfree: can't find softc pointer!");

	/* calculate the slot this buffer belongs to */

	i = ((vaddr_t)buf
	     - (vaddr_t)sc->bge_cdata.bge_jumbo_buf) / BGE_JLEN;

	if ((i < 0) || (i >= BGE_JSLOTS))
		panic("bge_jfree: asked to free buffer that we don't manage!");

	entry = SLIST_FIRST(&sc->bge_jinuse_listhead);
	if (entry == NULL)
		panic("bge_jfree: buffer not in use!");
	entry->slot = i;
	SLIST_REMOVE_HEAD(&sc->bge_jinuse_listhead, jpool_entries);
	SLIST_INSERT_HEAD(&sc->bge_jfree_listhead, entry, jpool_entries);
}


/*
d770 1
a770 2
 * Initialize a Jumbo receive ring descriptor. This allocates
 * a Jumbo buffer from the pool managed internally by the driver.
d773 1
a773 1
bge_newbuf_jumbo(struct bge_softc *sc, int i, struct mbuf *m)
d775 8
a782 2
	struct mbuf *m_new = NULL;
	struct bge_rx_bd *r;
d784 15
a798 2
	if (m == NULL) {
		caddr_t			buf = NULL;
d800 3
a802 4
		/* Allocate the mbuf. */
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return (ENOBUFS);
d804 5
a808 6
		/* Allocate the Jumbo buffer */
		buf = bge_jalloc(sc);
		if (buf == NULL) {
			m_freem(m_new);
			return (ENOBUFS);
		}
d810 25
a834 12
		/* Attach the buffer to the mbuf. */
		m_new->m_len = m_new->m_pkthdr.len = BGE_JUMBO_FRAMELEN;
		MEXTADD(m_new, buf, BGE_JUMBO_FRAMELEN, 0, bge_jfree, sc);
	} else {
		/*
		 * We're re-using a previously allocated mbuf;
		 * be sure to re-init pointers and lengths to
		 * default values.
		 */
		m_new = m;
		m_new->m_data = m_new->m_ext.ext_buf;
		m_new->m_ext.ext_size = BGE_JUMBO_FRAMELEN;
a836 10
	if (!(sc->bge_flags & BGE_RX_ALIGNBUG))
		m_adj(m_new, ETHER_ALIGN);
	/* Set up the descriptor. */
	r = &sc->bge_rdata->bge_rx_jumbo_ring[i];
	sc->bge_cdata.bge_rx_jumbo_chain[i] = m_new;
	BGE_HOSTADDR(r->bge_addr, BGE_JUMBO_DMA_ADDR(sc, m_new));
	r->bge_flags = BGE_RXBDFLAG_END|BGE_RXBDFLAG_JUMBO_RING;
	r->bge_len = m_new->m_len;
	r->bge_idx = i;

d839 5
a843 3
		i * sizeof (struct bge_rx_bd),
	    sizeof (struct bge_rx_bd),
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
d897 6
a902 1
	bge_fill_rx_ring_std(sc);
d966 1
a967 1
	volatile struct bge_rcb *rcb;
d969 1
a969 1
	if (sc->bge_flags & BGE_JUMBO_RXRING_VALID)
d973 14
a986 3
		if (bge_newbuf_jumbo(sc, i, NULL) == ENOBUFS)
			return (ENOBUFS);
	};
d988 1
a988 2
	sc->bge_jumbo = i - 1;
	sc->bge_flags |= BGE_JUMBO_RXRING_VALID;
d991 2
a992 1
	rcb->bge_maxlen_flags = BGE_RCB_MAXLEN_FLAGS(0, 0);
d995 1
a995 1
	bge_writembx(sc, BGE_MBX_RX_JUMBO_PROD_LO, sc->bge_jumbo);
d997 34
a1030 1
	return (0);
d1036 2
d1040 1
a1040 1
	if (!(sc->bge_flags & BGE_JUMBO_RXRING_VALID))
d1044 7
a1050 2
		if (sc->bge_cdata.bge_rx_jumbo_chain[i] != NULL) {
			m_freem(sc->bge_cdata.bge_rx_jumbo_chain[i]);
d1053 2
d1056 1
a1056 1
		    sizeof(struct bge_rx_bd));
d1059 1
a1059 1
	sc->bge_flags &= ~BGE_JUMBO_RXRING_VALID;
d1426 2
a1427 3
		rcb->bge_maxlen_flags =
		    BGE_RCB_MAXLEN_FLAGS(BGE_JUMBO_FRAMELEN,
		        BGE_RCB_FLAG_RING_DISABLED);
a1451 1
#if 0
d1455 4
a1458 1
	 * each ring.
d1460 2
a1461 17
	i = BGE_STD_RX_RING_CNT / 8;

	/*
	 * Use a value of 8 for the following chips to workaround HW errata.
	 * Some of these chips have been added based on empirical
	 * evidence (they don't work unless this is done).
	 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5750 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5752 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5755 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5787 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906)
#endif
		i = 8;

	CSR_WRITE_4(sc, BGE_RBDI_STD_REPL_THRESH, i);
	CSR_WRITE_4(sc, BGE_RBDI_JUMBO_REPL_THRESH, BGE_JUMBO_RX_RING_CNT / 8);
a2023 10
	/*
	 * Try to allocate memory for Jumbo buffers.
	 */
	if (BGE_IS_JUMBO_CAPABLE(sc)) {
		if (bge_alloc_jumbo_mem(sc)) {
			printf(": jumbo buffer allocation failed\n");
			goto fail_5;
		}
	}

d2049 1
d2373 1
a2373 1
 * 1) the frame is from the Jumbo receive ring
a2432 1
			BGE_INC(sc->bge_jumbo, BGE_JUMBO_RX_RING_CNT);
d2435 1
d2437 7
d2445 1
a2446 1
				bge_newbuf_jumbo(sc, sc->bge_jumbo, m);
a2448 13
			if (bge_newbuf_jumbo(sc, sc->bge_jumbo, NULL)
			    == ENOBUFS) {
				struct mbuf             *m0;
				m0 = m_devget(mtod(m, char *),
				    cur_rx->bge_len - ETHER_CRC_LEN,
				    ETHER_ALIGN, ifp, NULL);
				bge_newbuf_jumbo(sc, sc->bge_jumbo, m);
				if (m0 == NULL) {
					ifp->if_ierrors++;
					continue;
				}
				m = m0;
			}
d2520 1
a2520 1
		bge_writembx(sc, BGE_MBX_RX_JUMBO_PROD_LO, sc->bge_jumbo);
@


1.260
log
@sizeof(bge_devices) / sizeof(bge_devices[0]) -> nitems(bge_devices)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.259 2008/12/23 00:12:22 dlg Exp $	*/
d2139 4
a2142 1
	m_clsetlwm(ifp, MCLBYTES, 17); /* must be > replenish threshold */
@


1.259
log
@if we cant put enough packets on the rx ring then schedule a timeout to
try again later.

tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.256 2008/11/22 18:16:55 dlg Exp $	*/
d1832 1
a1832 2
	return (pci_matchbyid((struct pci_attach_args *)aux, bge_devices,
	    sizeof(bge_devices)/sizeof(bge_devices[0])));
@


1.258
log
@switch bge over to using MCLGETI when allocating mbufs for the rx ring.

tested by many including henning@@ sthen@@ naddy@@ krw@@ robert@@ jmc@@ jsg@@
weerd@@ and ingo schwarze on a variety of machines include i386, amd64,
alpha, and sparc64.
@
text
@d174 1
d1018 11
d1047 7
d2252 1
d3453 1
@


1.257
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@a167 1
int bge_newbuf_std(struct bge_softc *, int, struct mbuf *, bus_dmamap_t);
d169 4
d174 1
d176 1
a176 2
int bge_init_rx_ring_jumbo(struct bge_softc *);
void bge_free_rx_ring_jumbo(struct bge_softc *);
d863 1
a863 2
bge_newbuf_std(struct bge_softc *sc, int i, struct mbuf *m,
    bus_dmamap_t dmamap)
d865 3
a867 2
	struct mbuf		*m_new = NULL;
	struct bge_rx_bd	*r;
d870 3
a872 6
	if (dmamap == NULL) {
		error = bus_dmamap_create(sc->bge_dmatag, MCLBYTES, 1,
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &dmamap);
		if (error != 0)
			return (error);
	}
d874 4
a877 22
	sc->bge_cdata.bge_rx_std_map[i] = dmamap;

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return (ENOBUFS);

		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			m_freem(m_new);
			return (ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
	} else {
		/*
		 * We're re-using a previously allocated mbuf;
		 * be sure to re-init pointers and lengths to
		 * default values.
		 */
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
d879 1
a879 1

d881 1
a881 1
	    m_adj(m_new, ETHER_ALIGN);
d883 1
a883 1
	error = bus_dmamap_load_mbuf(sc->bge_dmatag, dmamap, m_new,
d886 1
a886 4
		if (m == NULL) {
			m_freem(m_new);
			sc->bge_cdata.bge_rx_std_chain[i] = NULL;
		}
d890 11
a900 3
	sc->bge_cdata.bge_rx_std_chain[i] = m_new;
	r = &sc->bge_rdata->bge_rx_std_ring[i];
	BGE_HOSTADDR(r->bge_addr, dmamap->dm_segs[0].ds_addr);
d902 1
a902 1
	r->bge_len = m_new->m_len;
a904 3
	bus_dmamap_sync(sc->bge_dmatag, dmamap, 0, dmamap->dm_mapsize,
	    BUS_DMASYNC_PREREAD);

d909 3
a911 1
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
d985 1
a985 1
	if (sc->bge_flags & BGE_RXRING_VALID)
d988 10
a997 3
	for (i = 0; i < BGE_SSLOTS; i++) {
		if (bge_newbuf_std(sc, i, NULL, 0) == ENOBUFS)
			return (ENOBUFS);
d1000 3
a1002 2
	sc->bge_std = i - 1;
	bge_writembx(sc, BGE_MBX_RX_STD_PROD_LO, sc->bge_std);
d1004 1
a1004 1
	sc->bge_flags |= BGE_RXRING_VALID;
d1007 28
d1040 2
d1044 1
a1044 1
	if (!(sc->bge_flags & BGE_RXRING_VALID))
d1048 7
a1054 2
		if (sc->bge_cdata.bge_rx_std_chain[i] != NULL) {
			m_freem(sc->bge_cdata.bge_rx_std_chain[i]);
a1055 2
			bus_dmamap_destroy(sc->bge_dmatag,
			    sc->bge_cdata.bge_rx_std_map[i]);
d1057 2
d1063 1
a1063 1
	sc->bge_flags &= ~BGE_RXRING_VALID;
d1503 1
d1521 1
d2121 1
a2525 1
			BGE_INC(sc->bge_std, BGE_STD_RX_RING_CNT);
d2528 1
d2530 2
a2532 1
			sc->bge_cdata.bge_rx_std_map[rxidx] = 0;
d2536 1
d2538 1
a2539 7
				bge_newbuf_std(sc, sc->bge_std, m, dmamap);
				continue;
			}
			if (bge_newbuf_std(sc, sc->bge_std,
			    NULL, dmamap) == ENOBUFS) {
				ifp->if_ierrors++;
				bge_newbuf_std(sc, sc->bge_std, m, dmamap);
d2594 1
a2594 1
		bge_writembx(sc, BGE_MBX_RX_STD_PROD_LO, sc->bge_std);
@


1.256
log
@perform bus_dmamap_syncs on the rx mbufs. this is obviously maintained by
monkeys.

found by toby's bounce buffers.
ok krw deraadt uwe fwk matthieu, drahn, mbalmer, robert, yuo, ratchov,
claudio, rainer, art.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.255 2008/11/09 15:08:26 naddy Exp $	*/
d3284 1
a3285 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d3301 1
a3301 6
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ifp->if_hardmtu)
			error = EINVAL;
		else if (ifp->if_mtu != ifr->ifr_mtu)
			ifp->if_mtu = ifr->ifr_mtu;
		break;
a3313 5
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI)
			? ether_addmulti(ifr, &sc->arpcom)
			: ether_delmulti(ifr, &sc->arpcom);
a3314 6
		if (error == ENETRESET) {
			if (ifp->if_flags & IFF_RUNNING)
				bge_iff(sc);
			error = 0;
		}
		break;
d3346 1
d3349 6
@


1.255
log
@Introduce bpf_mtap_ether(), which for the benefit of bpf listeners
creates the VLAN encapsulation from the tag stored in the mbuf
header.  Idea from FreeBSD, input from claudio@@ and canacar@@.

Switch all hardware VLAN enabled drivers to the new function.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.254 2008/11/08 07:37:07 deraadt Exp $	*/
d918 3
d2500 2
@


1.254
log
@brad, noone said you could go making changes like that (doubling the
amount of memory and interrupt time each bge uses) without discussing
it with other people.  lots of people are complaining about the lack
of communication in your process, and you are going to have to change
that.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.250 2008/11/07 22:52:15 brad Exp $	*/
d2538 1
a2538 1
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
d3031 1
a3031 1
			bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
@


1.253
log
@When initializing the standard RX ring, do not allocate mbufs clusters for the
whole ring.
@
text
@d985 6
d2718 1
a2718 1
		 * (extra input errors was reported for BCM5701 & BCM5704).
d3580 2
@


1.252
log
@Clean up some of the comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.251 2008/11/08 07:00:52 brad Exp $	*/
d993 1
a993 1
	for (i = 0; i < BGE_STD_RX_RING_CNT; i++) {
@


1.251
log
@When initializing the standard RX ring, allocate mbufs clusters for the
whole ring.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.250 2008/11/07 22:52:15 brad Exp $	*/
a984 6
/*
 * The standard receive ring has 512 entries in it. At 2K per mbuf cluster,
 * that's 1MB or memory, which is a lot. For now, we fill only the first
 * 256 ring entries and hope that our CPU is fast enough to keep up with
 * the NIC.
 */
d2712 1
a2712 1
		 * (extra input errors was reported for bcm5701 & bcm5704).
a3573 2
	 * This should not happen since mii callouts are locked now, but
	 * we keep this check for debug.
@


1.250
log
@When initializing the MAC put the PHY into ready state for BCM5906
chipsets.

From the Linux tg3 driver via FreeBSD.

Tested by Jordi Creix <jbcreix dot mail at gmail dot com>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.249 2008/10/19 08:13:01 brad Exp $	*/
d999 1
a999 1
	for (i = 0; i < BGE_SSLOTS; i++) {
@


1.249
log
@Re-add support for RX VLAN tag stripping.

Tested by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.248 2008/10/16 19:18:03 naddy Exp $	*/
d1319 9
@


1.248
log
@Switch the existing TX VLAN hardware support over to having the
tag in the header.  Convert TX tagging in the drivers.

Help and ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.247 2008/10/14 18:01:53 naddy Exp $	*/
d2517 7
d2938 1
a2942 2
		} else {
			f->bge_vlan_tag = 0;
d3083 4
a3086 2
	/* Disable hardware decapsulation of vlan frames. */
	BGE_SETBIT(sc, BGE_RX_MODE, BGE_RXMODE_RX_KEEP_VLAN_DIAG);
@


1.247
log
@Change m_devget()'s outdated and unused "offset" argument:  It is
now the offset into the first mbuf of the target chain before copying
the source data over.  From FreeBSD.

Convert drivers' use of m_devget().  Mostly from thib@@.

Update mbuf(9) man page.

ok claudio@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.246 2008/10/02 20:21:14 brad Exp $	*/
a2872 7
#if NVLAN > 0
	struct ifvlan		*ifv = NULL;

	if ((m_head->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&
	    m_head->m_pkthdr.rcvif != NULL)
		ifv = m_head->m_pkthdr.rcvif->if_softc;
#endif
d2932 1
a2932 1
		if (ifv != NULL) {
d2934 1
a2934 1
			f->bge_vlan_tag = ifv->ifv_tag;
@


1.246
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.245 2008/09/23 00:27:18 brad Exp $	*/
d2471 3
a2473 3
				m0 = m_devget(mtod(m, char *) - ETHER_ALIGN,
				    cur_rx->bge_len - ETHER_CRC_LEN +
				    ETHER_ALIGN, 0, ifp, NULL);
a2478 1
				m_adj(m0, ETHER_ALIGN);
@


1.245
log
@Rewrite two small sections of code in bge_blockinit() to simplify the
code. No functional change.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.244 2008/09/18 15:16:30 naddy Exp $	*/
a3276 5
	if ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {
		splx(s);
		return (error);
	}

d3349 1
a3349 2
		error = ENOTTY;
		break;
a3352 1

@


1.244
log
@Introduce the infrastructure required to support hardware VLAN tag
stripping:  Add a field to the mbuf pkthdr to hold the tag and an
mbuf flag that tells if the tag is valid.  Inspired by FreeBSD.

Struct packing suggested by kettenis@@.   csum_flags is now 16 bits.
Adapt to this in the drivers.

ok reyk@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.243 2008/09/10 14:01:22 blambert Exp $	*/
d1356 11
a1366 1
	if (!(BGE_IS_5705_OR_BEYOND(sc))) {
a1369 8
	} else if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5906) {
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x0);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x04);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x10);
	} else {
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x0);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x10);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x60);
d1668 1
a1668 3
	/* Turn on read DMA state machine */
	{
		uint32_t dma_read_modebits;
d1670 2
a1671 2
		dma_read_modebits =
		  BGE_RDMAMODE_ENABLE | BGE_RDMAMODE_ALL_ATTNS;
d1673 2
a1674 5
		if (sc->bge_flags & BGE_PCIE)
			dma_read_modebits |= BGE_RDMAMODE_FIFO_LONG_BURST;

		CSR_WRITE_4(sc, BGE_RDMA_MODE, dma_read_modebits);
	}
@


1.243
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.242 2008/09/08 08:10:54 brad Exp $	*/
d2452 1
a2452 1
		int			sumflags = 0;
@


1.242
log
@Fix a link state issue reported by reyk@@

In some situations we were not clearing pending link state attentions.
Because of this we were not getting further interrupts for link state
changes, thus never went into iface UP state.

Force an interrupt at the end of bge_ifmedia_upd so we will call
bge_link_upd, clear the link state attention and get further
interrupts.

From FreeBSD

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.241 2008/08/26 19:43:05 kettenis Exp $	*/
d2712 1
a2712 1
	timeout_add(&sc->bge_timeout, hz);
d3155 1
a3155 1
	timeout_add(&sc->bge_timeout, hz);
@


1.241
log
@Better strategy to single out onboard bge(4)'s on sparc64 machines.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.240 2008/08/24 20:24:43 deraadt Exp $	*/
d3218 14
@


1.240
log
@Tadpole Viper onboard ethernet has no eeprom either, but the PROM entry
has subsystem ids set to the same as the regular ids, so the heuristic does
not work.  So look for the TAD,Viper machine name.  When we get our hand on
a Bullfrog (with a PCI slot) we will need to revisit this.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.239 2008/08/24 16:30:18 deraadt Exp $	*/
d1796 1
a1796 2
	char			namebuf[32];
	int			subvendor;
d1871 10
a1880 7
	if (OF_getprop(PCITAG_NODE(pa->pa_tag), "subsystem-vendor-id",
	    &subvendor, sizeof(subvendor)) == sizeof(subvendor)) {
		if (subvendor == PCI_VENDOR_SUN)
			sc->bge_flags |= BGE_NO_EEPROM;
	}
	if (OF_getprop(findroot(), "name", namebuf, sizeof(namebuf)) > 0 &&
	    strcmp(namebuf, "TAD,Viper") == 0)
@


1.239
log
@proper indent
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.238 2008/07/17 19:59:44 brad Exp $	*/
d110 1
d1796 1
d1877 3
@


1.238
log
@Add a flag and allow the driver to identify the BCM5788 chipsets. They're
slightly different from the other chipsets using the BCM5705 ASIC.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.237 2008/07/16 03:56:25 brad Exp $	*/
d1873 1
a1873 1
		sc->bge_flags |= BGE_NO_EEPROM;
@


1.237
log
@Enable the read DMA engine's PCI read request burst length long burst
mode (4KB) for PCIe chips. This resolves the poor TX performance for
the PCIe chips. The result being a bit under double the TX performance
on a Gig connection (roughly 495 Mb/s -> 940 Mb/s).

Tested by reyk@@, sthen@@, brad@@ and a few end users.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.236 2008/06/07 19:05:11 brad Exp $	*/
d1899 5
@


1.236
log
@Add baudrate handling for fiber boards using the TBI interface.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.235 2008/05/24 02:21:50 brad Exp $	*/
d1672 2
a1673 2
		if (sc->bge_flags & BGE_PCIE && 0)
			dma_read_modebits |= BGE_RDMA_MODE_FIFO_LONG_BURST;
@


1.235
log
@And another Fujitsu Gigabit Etherenet card that is a bge(4) in disguise.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.234 2008/05/23 22:50:06 kettenis Exp $	*/
a2066 1
	ifp->if_baudrate = 1000000000;
d3545 1
d3551 1
@


1.234
log
@Another Fujitsu Gigabit Etherenet card that is a bge(4) in disguise.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.233 2008/05/23 08:49:27 brad Exp $	*/
d271 1
d277 1
a277 1
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C996 },
@


1.233
log
@Simplify the combination use of pci_mapreg_type()/pci_mapreg_map() as
suggested by dlg@@ awhile ago.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.232 2008/05/21 22:27:01 kettenis Exp $	*/
d271 1
@


1.232
log
@Fujitsu PRIMEPOWER250/450 secondary LAN is a BCM5703C in disguise.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.231 2008/05/14 03:52:34 brad Exp $	*/
d1807 2
a1808 8
 	switch (memtype) {
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
		if (pci_mapreg_map(pa, BGE_PCI_BAR0,
		    memtype, 0, &sc->bge_btag, &sc->bge_bhandle,
		    NULL, &size, 0) == 0)
			break;
	default:
@


1.231
log
@Add the Altima AC1003 PCI id.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.230 2008/05/12 03:50:55 brad Exp $	*/
d270 2
@


1.230
log
@Call mii_pollstat() instead of bge_tick() in bge_link_upd() so that link
state transitions are noticed and the appropriate routing socket messages
are generated.

ok kettenis@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.229 2008/05/11 09:56:11 brad Exp $	*/
d212 1
@


1.229
log
@Remove special casing of the BCM5700 B2 chipset so that this revision also
uses MII interrupts to detect link state transitions as is done for all of
the other BCM5700 revisions, without this change link state transitions
are not being detected at all.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.228 2008/05/11 05:12:56 brad Exp $	*/
d3468 1
a3468 6
	/*
	 * We can't just call bge_link_upd() cause chip is almost stopped so
	 * bge_link_upd -> bge_tick_locked -> bge_stats_update sequence may
	 * lead to hardware deadlock. So we just clearing MAC's link state
	 * (PHY may still have link UP).
	 */
d3511 1
a3511 2
			timeout_del(&sc->bge_timeout);
			bge_tick(sc);
d3568 1
a3568 2
			timeout_del(&sc->bge_timeout);
			bge_tick(sc);
@


1.228
log
@Revert the last commit as this is not the proper way of fixing the issue.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.227 2008/05/09 06:30:40 krw Exp $	*/
d1716 1
a1716 2
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 &&
		    sc->bge_chipid != BGE_CHIPID_BCM5700_B2)
d2647 1
a2647 2
		if ((BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 &&
		    sc->bge_chipid != BGE_CHIPID_BCM5700_B2) ||
a3511 2
	 * XXX: perhaps link state detection procedure used for
	 * BGE_CHIPID_BCM5700_B2 can be used for other BCM5700 revisions.
d3513 1
a3513 3

	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 &&
	    sc->bge_chipid != BGE_CHIPID_BCM5700_B2) {
d3573 1
a3573 2
		if (BGE_STS_BIT(sc, BGE_STS_LINK) != link ||
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700) {
@


1.227
log
@Attempt to fix link status change handling so that the proper RTM_IFINFO
messages are generated when links go down or come up. Works on available
devices, put in tree to encourage wide testing. Enables latest dhclient
changes to work their magic on bge.

Feedback from brad@@

ok deraadt@@ beck@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.226 2008/04/20 01:37:35 brad Exp $	*/
d3525 1
a3525 4
			if (BGE_STS_BIT(sc, BGE_STS_LINK))
				BGE_STS_CLRBIT(sc, BGE_STS_LINK);

			else if (!BGE_STS_BIT(sc, BGE_STS_LINK) &&
d3527 1
a3527 2
			    (IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) &&
			    (IFM_SUBTYPE(mii->mii_media_active) != (IFM_ETHER|IFM_NONE)))
d3529 4
d3584 1
a3584 4
			if (BGE_STS_BIT(sc, BGE_STS_LINK))
				BGE_STS_CLRBIT(sc, BGE_STS_LINK);

			else if (!BGE_STS_BIT(sc, BGE_STS_LINK) &&
d3586 1
a3586 2
			    (IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) &&
			    (IFM_SUBTYPE(mii->mii_media_active) != (IFM_ETHER|IFM_NONE)))
d3588 4
@


1.226
log
@rev 1.35 added special register settings for BCM5704 chipsets when
in TBI mode for fiber adapters which causes problems for some systems.
Add code to detect when the special settings are necessary which helps
with some blade systems.

From FreeBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.225 2008/04/20 01:32:43 brad Exp $	*/
d3525 4
a3528 1
			if (!BGE_STS_BIT(sc, BGE_STS_LINK) &&
d3530 2
a3531 1
			    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
a3532 5
			} else if (BGE_STS_BIT(sc, BGE_STS_LINK) &&
			    (!(mii->mii_media_status & IFM_ACTIVE) ||
			    IFM_SUBTYPE(mii->mii_media_active) == IFM_NONE)) {
				BGE_STS_CLRBIT(sc, BGE_STS_LINK);
			}
d3584 4
a3587 1
			if (!BGE_STS_BIT(sc, BGE_STS_LINK) &&
d3589 2
a3590 1
			    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE)
a3591 4
			else if (BGE_STS_BIT(sc, BGE_STS_LINK) &&
			    (!(mii->mii_media_status & IFM_ACTIVE) ||
			    IFM_SUBTYPE(mii->mii_media_active) == IFM_NONE))
				BGE_STS_CLRBIT(sc, BGE_STS_LINK);
@


1.225
log
@Add a workaround for a CRC bug errata with BCM5701 A0 and B0 chipset
revisions.

From Linux via FreeBSD.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.224 2008/04/03 22:50:24 brad Exp $	*/
d3173 12
a3184 9
				CSR_WRITE_4(sc, BGE_TX_TBI_AUTONEG, 0);
				sgdig = CSR_READ_4(sc, BGE_SGDIG_CFG);
				sgdig |= BGE_SGDIGCFG_AUTO|
				    BGE_SGDIGCFG_PAUSE_CAP|
				    BGE_SGDIGCFG_ASYM_PAUSE;
				CSR_WRITE_4(sc, BGE_SGDIG_CFG,
				    sgdig|BGE_SGDIGCFG_SEND);
				DELAY(5);
				CSR_WRITE_4(sc, BGE_SGDIG_CFG, sgdig);
@


1.224
log
@Clean up the DMA read/write control register setup code and add some
comments.

Tested by a number of users with a variety of chipsets.

From FreeBSD

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.223 2008/03/21 21:11:04 brad Exp $	*/
d1923 3
@


1.223
log
@Pass the MIIF_HAVEFIBER flag along to mii_attach() for MII based fiber
adapters.

Tested by brad@@ and johan@@ to ensure flow control is still working for
copper adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.222 2008/02/20 12:17:25 brad Exp $	*/
d1216 6
a1221 1
	/* Set up the PCI DMA control register. */
d1223 2
a1224 22
		/* PCI Express bus */
		u_int32_t device_ctl;

		/* alternative from Linux driver */
#define DMA_CTRL_WRITE_PCIE_H20MARK_128		0x00180000
#define DMA_CTRL_WRITE_PCIE_H20MARK_256		0x00380000

		dma_rw_ctl = 0x76000000; /* XXX XXX XXX */;
		device_ctl = pci_conf_read(pa->pa_pc, pa->pa_tag,
					   BGE_PCI_CONF_DEV_CTRL);

		if ((device_ctl & 0x00e0) && 0) {
			/*
			 * This clause is exactly what the Broadcom-supplied
			 * Linux does; but given overall register programming
			 * by bge(4), this larger DMA-write watermark
			 * value causes BCM5721 chips to totally wedge.
			 */
			dma_rw_ctl |= BGE_PCIDMA_RWCTL_PCIE_WRITE_WATRMARK_256;
		} else {
			dma_rw_ctl |= BGE_PCIDMA_RWCTL_PCIE_WRITE_WATRMARK_128;
		}
d1228 4
a1231 3
			dma_rw_ctl = BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD;
			dma_rw_ctl &= ~BGE_PCIDMARWCTL_ONEDMA_ATONCE; /* XXX */
			/* XXX magic values, Broadcom-supplied Linux driver */
d1233 1
a1233 2
				dma_rw_ctl |= (1 << 20) | (1 << 18) |
				    BGE_PCIDMARWCTL_ONEDMA_ATONCE;
d1235 9
a1243 13
				dma_rw_ctl |= (1<<20) | (1<<18) | (1 << 15);
		} else if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704)
			/*
			 * The 5704 uses a different encoding of read/write
			 * watermarks.
			 */
			dma_rw_ctl = BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD |
			    (0x7 << BGE_PCIDMARWCTL_RD_WAT_SHIFT) |
			    (0x3 << BGE_PCIDMARWCTL_WR_WAT_SHIFT);
		else
			dma_rw_ctl = BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD |
			    (0x3 << BGE_PCIDMARWCTL_RD_WAT_SHIFT) |
			    (0x3 << BGE_PCIDMARWCTL_WR_WAT_SHIFT) |
d1245 1
a1246 4
		/*
		 * 5703 and 5704 need ONEDMA_AT_ONCE as a workaround
		 * for hardware bugs.
		 */
d1251 1
d1253 6
a1258 2
			if (tmp == 0x6 || tmp == 0x7)
				dma_rw_ctl |= BGE_PCIDMARWCTL_ONEDMA_ATONCE;
d1260 8
a1267 6
 	} else {
		/* Conventional PCI bus */
		dma_rw_ctl = BGE_PCI_READ_CMD | BGE_PCI_WRITE_CMD |
		    (0x7 << BGE_PCIDMARWCTL_RD_WAT_SHIFT) |
		    (0x7 << BGE_PCIDMARWCTL_WR_WAT_SHIFT) |
		    (0x0f);
d1269 5
d1276 1
a1276 2
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5705)
@


1.222
log
@When collecting the hardware statistics add the interfaces input errors
counter and out of receive buffer descriptors counter to the network stacks
input errors counter.

Based on a diff from mickey@@ though updated for -current and added support
for BCM5705 or newer chipsets from brad@@.

Tested it with BCM5704 on i386/amd64, BCM5700 on sparc64, BCM5701/BCM5751M
on i386 and BCM5721/BCM5780 on amd64.

ok krw@@ sthen@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.221 2008/02/20 10:26:53 sthen Exp $	*/
d2157 2
d2164 3
d2168 1
a2168 1
			   MII_PHY_ANY, MII_OFFSET_ANY, MIIF_DOPAUSE);
@


1.222.2.1
log
@Call mii_pollstat() instead of bge_tick() in bge_link_upd() so that link
state transitions are noticed and the appropriate routing socket messages
are generated.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.222 2008/02/20 12:17:25 brad Exp $	*/
d3470 6
a3475 1
	/* Clear MAC's link state (PHY may still have link UP). */
d3522 2
a3523 1
			mii_pollstat(mii);
d3582 2
a3583 1
			mii_pollstat(mii);
@


1.221
log
@when bge has link, use autopolling for link status, not direct mii polls.
fixes input errors on BCM5701/5702X/5704 and may avoid firmware hangs on
some cards if asf/ipmi support is added.

original diff from Oleg Bulyzhin in a freebsd-net post and ported by
mickey; included stats counter changes which don't apply to -current
so they are split out and not included here. "The rest of the diff
looks ok" brad.

tested on 5701/5702X/5703X/5704C/5721 by mpf naddy okan beck sthen

ok beck (before splitting out stats changes), krw, henning.
closes kernel/5699
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.220 2008/02/18 09:40:11 brad Exp $	*/
d2721 4
d2745 8
d3118 5
a3122 1
	sc->bge_rx_discards = sc->bge_tx_discards = sc->bge_tx_collisions = 0;
@


1.220
log
@Add initial bits for fiber support with the BCM5714/BCM5715/BCM5780 chipsets.

Tested by brad@@, chl@@, sthen@@, Johan Mson Lindman and Ian Lindsay <iml04@@hampshire.edu>

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.219 2008/02/17 06:39:16 brad Exp $	*/
d589 1
d615 1
d637 1
d653 1
d1725 1
d2654 1
a2654 1
		    sc->bge_link_evt)
d2695 1
a2695 1
		sc->bge_link_evt++;
d2697 9
a2705 2
	} else
		mii_tick(mii);
d2978 1
a2978 1
	if (!sc->bge_link)
d3187 1
a3187 1
	sc->bge_link_evt++;
d3460 1
a3460 1
	sc->bge_link = 0;
d3481 2
a3482 1
	u_int32_t link, status;
d3485 1
a3485 1
	sc->bge_link_evt = 0;
d3509 1
a3509 1
			if (!sc->bge_link &&
d3512 2
a3513 2
				sc->bge_link++;
			} else if (sc->bge_link &&
d3516 1
a3516 1
				sc->bge_link = 0;
d3532 2
a3533 2
			if (!sc->bge_link) {
				sc->bge_link++;
d3545 2
a3546 2
		} else if (sc->bge_link) {
			sc->bge_link = 0;
d3550 6
a3555 2
	/* Discard link events for MII/GMII cards if MI auto-polling disabled */
	} else if (CSR_READ_4(sc, BGE_MI_MODE) & BGE_MIMODE_AUTOPOLL) {
d3561 2
a3562 1
		link = (CSR_READ_4(sc, BGE_MI_STS) & BGE_MISTS_LINK) ? 1 : 0;
d3564 1
a3564 1
		if (link != sc->bge_link ||
d3569 1
a3569 1
			if (!sc->bge_link &&
d3572 2
a3573 2
				sc->bge_link++;
			else if (sc->bge_link &&
d3576 1
a3576 1
				sc->bge_link = 0;
@


1.219
log
@- Correct clearing of the IFF_OACTIVE flag by ensuring the flag is
only cleared if there is enough slack space since bge_encap() will
return anyway and IFF_OACTIVE will be set again.
- Only reset the watchdog timer when all packets have been processed.
- Have bge_start() do a fast return if the adapter is not running or
the IFF_OACTIVE flag is set.

Tested by brad@@, chl@@, krw@@, landry@@, sthen@@ and Johan Mson Lindman.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.218 2008/02/02 04:03:33 brad Exp $	*/
d675 2
a676 1
	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T)
d1627 12
d1640 1
a1640 5
	CSR_WRITE_4(sc, BGE_MAC_MODE, BGE_MACMODE_TXDMA_ENB|
	    BGE_MACMODE_RXDMA_ENB|BGE_MACMODE_RX_STATS_CLEAR|
	    BGE_MACMODE_TX_STATS_CLEAR|BGE_MACMODE_RX_STATS_ENB|
	    BGE_MACMODE_TX_STATS_ENB|BGE_MACMODE_FRMHDR_DMA_ENB|
	    (sc->bge_flags & BGE_PHY_FIBER_TBI ? BGE_PORTMODE_TBI : BGE_PORTMODE_MII));
a2114 3
	if ((hwcfg & BGE_HWCFG_MEDIA) == BGE_MEDIA_FIBER)	    
		sc->bge_flags |= BGE_PHY_FIBER_TBI;

d2116 7
a2122 2
	if (PCI_PRODUCT(subid) == SK_SUBSYSID_9D41)
		sc->bge_flags |= BGE_PHY_FIBER_TBI;
@


1.218
log
@- Simplify statistics updates and remove redundant register reads.
- Add discarded RX packets to input errors for the BCM5705 or newer
  chipsets. Unfortunately output errors cannot be added because the
  equivalent to the ifOutDiscards register does not exist.
- Replace misleading and wrong BGE_RX_STATS/BGE_TX_STATS with
  BGE_MAC_STATS. They were reversed but just happened to work.

From FreeBSD

Tested by chl@@, landy@@, sthen@@, krw@@, okan@@ and brad@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.217 2008/01/31 03:43:00 brad Exp $	*/
a2598 1
		ifp->if_timer = 0;
d2601 1
a2601 1
	if (cur_tx != NULL)
d2603 2
d2652 1
a2652 2
		if (ifp->if_flags & IFF_RUNNING && !IFQ_IS_EMPTY(&ifp->if_snd))
			bge_start(ifp);
d2953 5
a2957 1
	if (!sc->bge_link || IFQ_IS_EMPTY(&ifp->if_snd))
d3567 1
a3567 2
			if (ifp->if_flags & IFF_RUNNING)
				bge_start(ifp);
@


1.217
log
@recognize the BCM5755 C0 ASIC revision.

tested by Rodolfo Gouveia and marco@@

ok kettenis@@ marco@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.216 2007/11/17 13:55:27 brad Exp $	*/
d2692 1
a2692 7
	struct ifnet *ifp;
	struct bge_mac_stats_regs stats;
	u_int32_t *s;
	u_long cnt;
	int i;

	ifp = &sc->arpcom.ac_if;
d2694 2
a2695 5
	s = (u_int32_t *)&stats;
	for (i = 0; i < sizeof(struct bge_mac_stats_regs); i += 4) {
		*s = CSR_READ_4(sc, BGE_RX_STATS + i);
		s++;
	}
d2697 1
a2697 7
	cnt = stats.dot3StatsSingleCollisionFrames +
	    stats.dot3StatsMultipleCollisionFrames +
	    stats.dot3StatsExcessiveCollisions +
	    stats.dot3StatsLateCollisions;
	ifp->if_collisions += cnt >= sc->bge_tx_collisions ?
	    cnt - sc->bge_tx_collisions : cnt;
	sc->bge_tx_collisions = cnt;
d2705 1
a2705 1
	u_long cnt;
d2710 2
a2711 10
	cnt = READ_STAT(sc, stats,
	    txstats.dot3StatsSingleCollisionFrames.bge_addr_lo);
	cnt += READ_STAT(sc, stats,
	    txstats.dot3StatsMultipleCollisionFrames.bge_addr_lo);
	cnt += READ_STAT(sc, stats,
	    txstats.dot3StatsExcessiveCollisions.bge_addr_lo);
	cnt += READ_STAT(sc, stats,
		txstats.dot3StatsLateCollisions.bge_addr_lo);
	ifp->if_collisions += cnt >= sc->bge_tx_collisions ?
	    cnt - sc->bge_tx_collisions : cnt;
d2715 1
a2715 2
	ifp->if_ierrors += cnt >= sc->bge_rx_discards ?
	    cnt - sc->bge_rx_discards : cnt;
d2719 1
a2719 2
	ifp->if_oerrors += cnt >= sc->bge_tx_discards ?
	    cnt - sc->bge_tx_discards : cnt;
d3077 3
@


1.216
log
@Rename fiber TBI flag from BGE_TBI to BGE_PHY_FIBER_TBI. No functional change.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.215 2007/10/13 16:29:52 kettenis Exp $	*/
d358 1
@


1.215
log
@Add support for BCM5906.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.214 2007/10/09 05:43:37 ray Exp $	*/
d1630 1
a1630 1
	    (sc->bge_flags & BGE_TBI ? BGE_PORTMODE_TBI : BGE_PORTMODE_MII));
d1708 1
a1708 1
	if (sc->bge_flags & BGE_TBI) {
d2106 1
a2106 1
		sc->bge_flags |= BGE_TBI;
d2110 1
a2110 1
		sc->bge_flags |= BGE_TBI;
d2130 1
a2130 1
	if (sc->bge_flags & BGE_TBI) {
d2354 1
a2354 1
	if (sc->bge_flags & BGE_TBI &&
d2672 1
a2672 1
	if (sc->bge_flags & BGE_TBI) {
d3142 1
a3142 1
	if (sc->bge_flags & BGE_TBI) {
d3201 1
a3201 1
	if (sc->bge_flags & BGE_TBI) {
d3283 1
a3283 1
		if (sc->bge_flags & BGE_TBI) {
d3303 1
a3303 1
		if (sc->bge_flags & BGE_TBI) {
d3434 1
a3434 1
	if (!(sc->bge_flags & BGE_TBI)) {
d3522 1
a3522 1
	if (sc->bge_flags & BGE_TBI) {
@


1.214
log
@Use %zu for printing size_t values.

OK dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.213 2007/06/21 01:11:50 dlg Exp $	*/
d157 2
d182 1
a266 1
#if 0
a268 1
#endif
d363 1
d419 82
d993 1
a993 1
	CSR_WRITE_4(sc, BGE_MBX_RX_STD_PROD_LO, sc->bge_std);
d1043 1
a1043 1
	CSR_WRITE_4(sc, BGE_MBX_RX_JUMBO_PROD_LO, sc->bge_jumbo);
d1113 1
a1113 1
	CSR_WRITE_4(sc, BGE_MBX_TX_HOST_PROD0_LO, sc->bge_tx_prodidx);
d1115 1
a1115 1
		CSR_WRITE_4(sc, BGE_MBX_TX_HOST_PROD0_LO, sc->bge_tx_prodidx);
d1118 1
a1118 1
	CSR_WRITE_4(sc, BGE_MBX_TX_NIC_PROD0_LO, 0);
d1120 1
a1120 1
		CSR_WRITE_4(sc, BGE_MBX_TX_NIC_PROD0_LO, 0);
d1359 4
d1474 2
a1475 1
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5787)
d1514 1
a1514 1
		CSR_WRITE_4(sc, BGE_MBX_RX_CONS0_LO +
d1520 3
a1522 3
	CSR_WRITE_4(sc, BGE_MBX_RX_STD_PROD_LO, 0);
	CSR_WRITE_4(sc, BGE_MBX_RX_JUMBO_PROD_LO, 0);
	CSR_WRITE_4(sc, BGE_MBX_RX_MINI_PROD_LO, 0);
d1967 10
d2238 13
d2293 27
a2319 11
	/*
	 * Poll until we see 1's complement of the magic number.
	 * This indicates that the firmware initialization
	 * is complete.  We expect this to fail if no SEEPROM
	 * is fitted.
	 */
	for (i = 0; i < BGE_TIMEOUT; i++) {
		val = bge_readmem_ind(sc, BGE_SOFTWARE_GENCOMM);
		if (val == ~BGE_MAGIC_NUMBER)
			break;
		DELAY(10);
a2321 4
	if (i >= BGE_TIMEOUT && (!(sc->bge_flags & BGE_NO_EEPROM)))
		printf("%s: firmware handshake timed out\n",
		    sc->bge_dev.dv_xname);

d2524 1
a2524 1
	CSR_WRITE_4(sc, BGE_MBX_RX_CONS0_LO, sc->bge_rx_saved_considx);
d2526 1
a2526 1
		CSR_WRITE_4(sc, BGE_MBX_RX_STD_PROD_LO, sc->bge_std);
d2528 1
a2528 1
		CSR_WRITE_4(sc, BGE_MBX_RX_JUMBO_PROD_LO, sc->bge_jumbo);
d2628 1
a2628 1
		CSR_WRITE_4(sc, BGE_MBX_IRQ0_LO, 1);
d2648 1
a2648 1
		CSR_WRITE_4(sc, BGE_MBX_IRQ0_LO, 0);
d3014 1
a3014 1
	CSR_WRITE_4(sc, BGE_MBX_TX_HOST_PROD0_LO, prodidx);
d3016 1
a3016 1
		CSR_WRITE_4(sc, BGE_MBX_TX_HOST_PROD0_LO, prodidx);
d3119 1
a3119 1
	CSR_WRITE_4(sc, BGE_MBX_IRQ0_LO, 0);
d3412 1
a3412 1
	CSR_WRITE_4(sc, BGE_MBX_IRQ0_LO, 1);
@


1.213
log
@rework how the IFF_PROMISC and IFF_ALLMULTI flags are dealt with, and how
the multicast filter is programmed.

IFF_ALLMULTI is for use by the driver and only the driver, meaning that we
have to clear it when its not needed anymore.

now that the ethernet layer counts the number of multicast address ranges
we can check that early to determine if ALLMULTI is needed, rather than
doing the stupid goto allmulti dance as we iterate over the multicast
address list.

the imperfect multicast filter is a 16 byte wide bitfield, so we can use
the "setbit" macro to build it in memory, and then write it to the hardware
as a bus_space region. this simplifies the code a lot and avoids confusing
bitshifts on u_int32_ts to get the bits in the right place.

tested by krw on amd64, naddy on alpha, deraadt on sparc64, and beck on
various bits.
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.212 2007/05/03 10:11:25 tom Exp $	*/
d1910 1
a1910 1
		printf(": can't map dma buffers (%d bytes)\n",
@


1.212
log
@The ring replenish threshold change needed to work around a hardware
problem also appears to be required on the BCM5754/5787 in the Dell
PowerEdge SC440 and OptiPlex GX745.  dlg identified the problem and
came up with the fix.

Tested by dlg@@, ckuethe@@, reyk@@; thanks.

ok dlg@@ beck@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.211 2007/05/02 10:03:42 dlg Exp $	*/
d160 1
a160 2
void bge_setmulti(struct bge_softc *);
void bge_setpromisc(struct bge_softc *);
d1063 1
a1063 1
bge_setmulti(struct bge_softc *sc)
d1069 2
a1070 3
	u_int32_t		hashes[4] = { 0, 0, 0, 0 };
	u_int32_t		h;
	int			i;
d1073 3
a1075 2
	for (i = 0; i < 4; i++)
		CSR_WRITE_4(sc, BGE_MAR0 + (i * 4), 0);
d1077 12
a1088 6
	/* Now program new ones. */
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
allmulti:
		for (i = 0; i < 4; i++)
			CSR_WRITE_4(sc, BGE_MAR0 + (i * 4), 0xFFFFFFFF);
		return;
d1091 2
a1092 19
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}
		h = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN) & 0x7F;
		hashes[(h & 0x60) >> 5] |= 1 << (h & 0x1F);
		ETHER_NEXT_MULTI(step, enm);
	}

	for (i = 0; i < 4; i++)
		CSR_WRITE_4(sc, BGE_MAR0 + (i * 4), hashes[i]);
}

void
bge_setpromisc(struct bge_softc *sc)
{
	struct ifnet	*ifp = &sc->arpcom.ac_if;
d1094 1
a1094 4
	if (ifp->if_flags & IFF_PROMISC)
		BGE_SETBIT(sc, BGE_RX_MODE, BGE_RXMODE_RX_PROMISC);
	else
		BGE_CLRBIT(sc, BGE_RX_MODE, BGE_RXMODE_RX_PROMISC);
a2943 3
	/* Enable or disable promiscuous mode as needed. */
	bge_setpromisc(sc);

d2947 2
a2948 2
	/* Program multicast filter. */
	bge_setmulti(sc);
d3135 4
a3138 20
			/*
			 * If only the state of the PROMISC flag changed,
			 * then just use the 'set promisc mode' command
			 * instead of reinitializing the entire NIC. Doing
			 * a full re-init means reloading the firmware and
			 * waiting for it to start up, which may take a
			 * second or two.  Similarly for ALLMULTI.
			 */
			if (ifp->if_flags & IFF_RUNNING &&
			    ((ifp->if_flags ^ sc->bge_if_flags) &
			     IFF_PROMISC)) {
				bge_setpromisc(sc);
				bge_setmulti(sc);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    (ifp->if_flags ^ sc->bge_if_flags) & IFF_ALLMULTI) {
				bge_setmulti(sc);
			} else {
				if (!(ifp->if_flags & IFF_RUNNING))
					bge_init(sc);
			}
d3153 1
a3153 1
				bge_setmulti(sc);
@


1.211
log
@the 5754 and 5787 share the same ASIC ID, make the crazy strings list both
so its obvious to people working on the code
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.210 2007/05/02 09:13:21 dlg Exp $	*/
d1387 1
a1387 1
	 * Set the BD ring replentish thresholds. The recommended
d1393 5
a1397 1
	/* Use a value of 8 for these chips to workaround HW errata */
d1400 2
a1401 1
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5755)
@


1.210
log
@do { } while (0) for the debug macros
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.209 2007/04/03 22:12:59 kettenis Exp $	*/
d358 4
a361 3
	{ BGE_CHIPID_BCM5787_A0, "BCM5787 A0" },
	{ BGE_CHIPID_BCM5787_A1, "BCM5787 A1" },
	{ BGE_CHIPID_BCM5787_A2, "BCM5787 A2" },
d385 1
a385 1
	{ BGE_ASICREV_BCM5787, "unknown BCM5787" },
@


1.209
log
@On sparc64, prefer the local-mac-address provided by the PROM.  Makes sure the
MAC address on the builtin ports of the Sun Fire V215 match what is used by
the PROM.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.208 2007/03/19 02:27:40 krw Exp $	*/
d190 2
a191 2
#define DPRINTF(x)	if (bgedebug) printf x
#define DPRINTFN(n,x)	if (bgedebug >= (n)) printf x
@


1.208
log
@Fix some code relative to chips that don't currently work (BCM5722 &
BCM5756).  They still don't work but when they do they won't use an
inappropriate Jitter bug workaround. No effect on other chips.

From Michael Chan of Broadcom, via Linux tg3 via Brad.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.207 2007/02/16 01:25:50 krw Exp $	*/
d1863 8
d1874 12
a1885 10
	mac_addr = bge_readmem_ind(sc, 0x0c14);
	if ((mac_addr >> 16) == 0x484b) {
		sc->arpcom.ac_enaddr[0] = (u_char)(mac_addr >> 8);
		sc->arpcom.ac_enaddr[1] = (u_char)mac_addr;
		mac_addr = bge_readmem_ind(sc, 0x0c18);
		sc->arpcom.ac_enaddr[2] = (u_char)(mac_addr >> 24);
		sc->arpcom.ac_enaddr[3] = (u_char)(mac_addr >> 16);
		sc->arpcom.ac_enaddr[4] = (u_char)(mac_addr >> 8);
		sc->arpcom.ac_enaddr[5] = (u_char)mac_addr;
		gotenaddr = 1;
a1893 5
	if (!gotenaddr) {
		if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
		    sc->arpcom.ac_enaddr, ETHER_ADDR_LEN) == ETHER_ADDR_LEN)
			gotenaddr = 1;
	}
@


1.207
log
@bge_newbuf_std() should return ENOBUFS on failure, as that's what
callers check for. One return accidentally changed to ENOMEM when
r1.133 reverted r1.85.  Nuke superfluous blank line.

From brad@@, tested by myself and Johan M:son Lindman.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.206 2007/02/10 01:23:19 krw Exp $	*/
d1847 4
a1850 2
		    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5787)
			sc->bge_flags |= BGE_PHY_JITTER_BUG;
d1853 1
a1853 1
		else if (BGE_ASICREV(sc->bge_chipid) != BGE_ASICREV_BCM5906)
@


1.206
log
@Add more chipset revision ids.

From scottl via FreeBSD and brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.205 2007/01/30 02:35:16 krw Exp $	*/
d812 1
a812 2
		return (ENOMEM);

@


1.205
log
@Rough in more support for 5787/5755 chips so far known to not work or
unreported in the wild. In this case add a PHY workaround for an eventual
mobile version of the chipset. No change to existing functionality.

From Michael Chan (mchan@@broadcom), via Linux tg3 and brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.204 2007/01/19 01:16:14 krw Exp $	*/
d355 5
d373 1
d383 1
@


1.204
log
@Workarounds for DMA HW errata on pci express chips. Based on FreeBSD
changes but with the more conservative (i.e. specific) chip matching
logic of Linux's tg3. No change except to pci express chips.

From Brad.

Tested by brad & thib@@ (BCM5750) and pedro la peu (BCM5752).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.203 2007/01/10 23:04:53 kettenis Exp $	*/
d1843 2
@


1.203
log
@Flow control support for bge(4)/brgphy(4).  From brad@@ based on code from
NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.202 2006/12/22 17:37:50 krw Exp $	*/
d1251 1
d1384 10
a1393 2
	CSR_WRITE_4(sc, BGE_RBDI_STD_REPL_THRESH, BGE_STD_RX_RING_CNT/8);
	CSR_WRITE_4(sc, BGE_RBDI_JUMBO_REPL_THRESH, BGE_JUMBO_RX_RING_CNT/8);
d1561 7
d1569 1
a1569 2
	CSR_WRITE_4(sc, BGE_WDMA_MODE,
	    BGE_WDMAMODE_ENABLE|BGE_WDMAMODE_ALL_ATTNS);
@


1.202
log
@Remove never used code for a BCM5700 feature (BGE_EXTRAM) that didn't
survive past 1st gen silicon.

From brad. Tested by wilfried@@ and Johan Mason Lindman.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.201 2006/12/17 06:04:11 krw Exp $	*/
d573 9
d592 13
d2026 1
a2026 1
			   MII_PHY_ANY, MII_OFFSET_ANY, 0);
d3035 1
a3077 1
	ifmr->ifm_active = mii->mii_media_active;
d3079 2
d3156 20
@


1.201
log
@Add/modify some comments. From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.200 2006/12/08 02:13:36 gwk Exp $	*/
d1240 2
a1241 6
		if (sc->bge_flags & BGE_EXTRAM)
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_BASEADDR,
			    BGE_EXT_SSRAM);
		else
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_BASEADDR,
			    BGE_BUFFPOOL_1);
d1312 1
a1312 4
	if (sc->bge_flags & BGE_EXTRAM)
		rcb->bge_nicaddr = BGE_EXT_STD_RX_RINGS;
	else
		rcb->bge_nicaddr = BGE_STD_RX_RINGS;
d1332 1
a1332 4
		if (sc->bge_flags & BGE_EXTRAM)
			rcb->bge_nicaddr = BGE_EXT_JUMBO_RX_RINGS;
		else
			rcb->bge_nicaddr = BGE_JUMBO_RX_RINGS;
@


1.200
log
@Add the Broadcom BCM5787F PCI id.
Add D-Link DGE-560SX and another Marvell Yukon (unknown model) PCI ids.
From the Linux sky2 driver via brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.199 2006/12/04 14:35:20 reyk Exp $	*/
d2073 1
d2096 4
d2116 5
a2120 1
		/* Set PCI Express max payload size and clear error status. */
d2149 1
a2149 2
	 * Poll the value location we just wrote until
	 * we see the 1's complement of the magic number.
@


1.199
log
@report full/half duplex state for non-MII interfaces

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.198 2006/11/26 19:13:39 brad Exp $	*/
d258 1
d1794 2
a1795 1
	      PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5753F)) ||
@


1.198
log
@revert the Jumbo diff that was commited as part of a wireles drivers commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.196 2006/11/20 22:40:39 brad Exp $	*/
d3361 5
a3365 1
				ifp->if_link_state = LINK_STATE_UP;
@


1.197
log
@do not have each net80211 driver define its own rates structures.  if they use
the standard rates, use some defined by net80211 itself.  kernel shrinks a bit
ok jsg mglocker
@
text
@a595 4
	/* Check to see if Jumbo memory is already allocated */
	if (sc->bge_cdata.bge_jumbo_buf)
		return (0);

a647 1
			sc->bge_cdata.bge_jumbo_buf = NULL;
a1224 1
	struct ifnet		*ifp = &sc->arpcom.ac_if;
d1260 3
a1262 10
		if (ifp->if_mtu > ETHER_MAX_LEN) {
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x50);
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x20);
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x60);
		} else {
			/* Values from Linux driver... */
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 304);
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 152);
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 380);
		}
d1898 10
a2876 11
	 * Try to allocate memory for Jumbo buffers.
	 */
	if (BGE_IS_JUMBO_CAPABLE(sc) && ifp->if_mtu > ETHERMTU &&
	    bge_alloc_jumbo_mem(sc)) {
		printf("%s: jumbo buffer allocation failed\n",
		    sc->bge_dev.dv_xname);
		splx(s);
		return;
	}

	/*
d2889 6
a2894 2
	CSR_WRITE_4(sc, BGE_RX_MTU, ifp->if_mtu +
	    ETHER_HDR_LEN + ETHER_CRC_LEN + ETHER_VLAN_ENCAP_LEN);
d2932 1
a2932 1
	if (BGE_IS_JUMBO_CAPABLE(sc) && ifp->if_mtu > ETHERMTU)
d3088 1
a3088 1
		else if (ifp->if_mtu != ifr->ifr_mtu) {
a3089 2
			bge_init(sc);
		}
@


1.196
log
@set the IFCAP_VLAN_HWTAGGING capabilities flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.195 2006/10/28 22:14:47 brad Exp $	*/
d596 4
d652 1
d1230 1
d1266 10
a1275 3
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x50);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x20);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x60);
a1910 10
	/*
	 * Try to allocate memory for Jumbo buffers.
	 */
	if (BGE_IS_JUMBO_CAPABLE(sc)) {
		if (bge_alloc_jumbo_mem(sc)) {
			printf(": jumbo buffer allocation failed\n");
			goto fail_5;
		}
	}

d2880 11
d2903 2
a2904 6
	if (BGE_IS_JUMBO_CAPABLE(sc))
		CSR_WRITE_4(sc, BGE_RX_MTU,
			BGE_JUMBO_FRAMELEN + ETHER_VLAN_ENCAP_LEN);
	else
		CSR_WRITE_4(sc, BGE_RX_MTU,
			ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN);
d2942 1
a2942 1
	if (BGE_IS_JUMBO_CAPABLE(sc))
d3098 1
a3098 1
		else if (ifp->if_mtu != ifr->ifr_mtu)
d3100 2
@


1.195
log
@M_TRAILINGSPACE(m) returns 0 if M_READONLY(m) is true,
so no need to call both.

From tsutsui@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.194 2006/10/26 22:57:17 brad Exp $	*/
d1935 4
@


1.194
log
@Fix this by commiting the proper revision of the bge_encap() diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.193 2006/10/26 22:41:10 brad Exp $	*/
d2607 1
a2607 2
		if (prev && !M_READONLY(prev) &&
		    M_TRAILINGSPACE(prev) >= m->m_len) {
d2617 1
a2617 1
		} else if (m->m_next != NULL && !M_READONLY(m) &&
@


1.193
log
@bge_encap():
- Move TX ring full sanity check further up and check the number of DMA
segments from the DMA map, instead of counting the DMA segments in the
for loop and breaking out later.
- Unload the DMA map if encountering an error condition.

Tested by brad@@ sturm@@ wilfried@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.192 2006/10/25 02:37:50 brad Exp $	*/
d2686 1
a2686 1
	u_int32_t		frag, cur, cnt = 0;
d2742 7
a2763 6
		/*
		 * Sanity check: avoid coming within 16 descriptors
		 * of the end of the ring.
		 */
		if ((BGE_TX_RING_CNT - (sc->bge_txcnt + cnt)) < 16)
			goto fail_unload;
a2765 1
		cnt++;
d2781 1
a2781 1
	sc->bge_txcnt += cnt;
@


1.192
log
@replace a few more instances of hand rolled code with the
LIST_FOREACH macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.191 2006/10/22 21:45:36 brad Exp $	*/
d2718 1
d2726 1
d2762 1
a2762 1
			return (ENOBUFS);
d2769 1
a2769 1
		return (ENOBUFS);
d2775 1
a2775 1
		return (ENOBUFS);
d2786 5
@


1.191
log
@recognize the BCM5715 A3 chipset.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.190 2006/10/17 22:28:07 brad Exp $	*/
d3009 1
a3009 2
		for (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;
		    miisc = LIST_NEXT(miisc, mii_list))
@


1.190
log
@disable the firmware fastboot feature on 5752/5755 and 5787 ASICs,
eliminates firmware timeouts.

Tested by pedro la peu <pedro at am-gen dot org> with a 5752 ASIC and
Benjamin Black <ben at layer8 dot net> with a 5787 ASIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.189 2006/10/15 06:49:19 brad Exp $	*/
d353 1
@


1.189
log
@recognize the BCM5787 A2 chipset.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.188 2006/10/10 21:04:14 brad Exp $	*/
d2065 5
@


1.188
log
@revert the firmware synchronization change in rev 1.178, this is the cause
of the first port of a dual port MAC to not work.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.187 2006/10/09 18:46:44 deraadt Exp $	*/
d353 1
@


1.187
log
@The mickey (/brad) jumbo allocation avoidance patch triggers the same
ami bug "on a particular machine" as the uvm anon change that needed
to be backed out on jul 13.

at least now you are getting close to knowing whether this is a uvm
bug or an ami bug or somewhere else; something starves or cuts memory
up badly enough to cause a big problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.180 2006/09/17 23:31:07 brad Exp $	*/
a2084 6
	/*
	 * Write the magic number to the firmware mailbox at 0xb50
	 * so that the driver can synchronize with the firmware.
	 */
	bge_writemem_ind(sc, BGE_SOFTWARE_GENCOMM, BGE_MAGIC_NUMBER);

d2119 6
@


1.186
log
@add a no Ethernet@@Wirespeed flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.185 2006/10/07 20:28:48 brad Exp $	*/
a593 4
	/* Check to see if Jumbo memory is already allocated */
	if (sc->bge_cdata.bge_jumbo_buf)
		return (0);

a645 1
			sc->bge_cdata.bge_jumbo_buf = NULL;
a1222 1
	struct ifnet		*ifp = &sc->arpcom.ac_if;
d1258 3
a1260 10
		if (ifp->if_mtu > ETHER_MAX_LEN) {
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x50);
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x20);
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x60);
		} else {
			/* Values from Linux driver... */
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 304);
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 152);
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 380);
		}
d1896 10
a2859 11
	 * Try to allocate memory for Jumbo buffers.
	 */
	if (BGE_IS_JUMBO_CAPABLE(sc) && ifp->if_mtu > ETHERMTU &&
	    bge_alloc_jumbo_mem(sc)) {
		printf("%s: jumbo buffer allocation failed\n",
		    sc->bge_dev.dv_xname);
		splx(s);
		return;
	}

	/*
d2872 6
a2877 2
	CSR_WRITE_4(sc, BGE_RX_MTU, ifp->if_mtu +
	    ETHER_HDR_LEN + ETHER_CRC_LEN + ETHER_VLAN_ENCAP_LEN);
d3072 1
a3072 1
		else if (ifp->if_mtu != ifr->ifr_mtu) {
a3073 2
			bge_init(sc);
		}
@


1.185
log
@add and set PHY workaround flags depending on the ASIC revision
or chip id.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.184 2006/10/01 17:29:48 brad Exp $	*/
d1807 7
@


1.184
log
@pack several boolean fields into the existing bge_flags field.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.183 2006/10/01 00:34:07 brad Exp $	*/
d282 2
a283 1
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5787)
d292 2
a293 1
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5787)
d1807 14
@


1.183
log
@add the PCI ids for the BCM5722, BCM5756, BCM5906 and BCM5906M chipsets.
the BCM5906/BCM5906M ids are not enabled for now; these chips are quite
a bit different from the others and are currently unsupported.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.182 2006/09/26 23:57:16 brad Exp $	*/
d773 1
a773 1
	if (!sc->bge_rx_alignment_bug)
d842 1
a842 1
	if (!sc->bge_rx_alignment_bug)
d1113 1
a1113 1
	if (sc->bge_pcie) {
d1136 1
a1136 1
	} else if (sc->bge_pcix) {
d1241 1
a1241 1
		if (sc->bge_extram)
d1324 1
a1324 1
	if (sc->bge_extram)
d1347 1
a1347 1
		if (sc->bge_extram)
d1531 1
a1531 1
	    (sc->bge_tbi ? BGE_PORTMODE_TBI : BGE_PORTMODE_MII));
d1559 1
a1559 1
		if (sc->bge_pcie && 0)
d1603 1
a1603 1
	if (sc->bge_tbi) {
a1747 1
	sc->bge_pcie = 0;
d1750 1
a1750 1
		sc->bge_pcie = 1;
a1754 1
	sc->bge_pcix = 0;
d1757 1
a1757 1
		sc->bge_pcix = 1;
a1761 1
	sc->bge_eeprom = 1;
d1766 1
a1766 1
			sc->bge_eeprom = 0;
d1778 3
a1780 3
	sc->bge_rx_alignment_bug = 0;
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701 && sc->bge_pcix)
		sc->bge_rx_alignment_bug = 1;
a1781 1
	sc->bge_jumbo_cap = 0;
d1783 1
a1783 1
		sc->bge_jumbo_cap = 1;
a1784 1
	sc->bge_no_3_led = 0;
d1788 1
a1788 1
		sc->bge_no_3_led = 1;
a1792 1
	sc->bge_10_100_only = 0;
d1802 3
a1804 2
	      PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5753F)))
		sc->bge_10_100_only = 1;
d1826 1
a1826 1
	if (!gotenaddr && sc->bge_eeprom) {
d1936 1
a1936 1
	else if (sc->bge_eeprom) {
a1944 1
	sc->bge_tbi = 0;
d1946 1
a1946 1
		sc->bge_tbi = 1;
d1950 1
a1950 1
		sc->bge_tbi = 1;
d1970 1
a1970 1
	if (sc->bge_tbi) {
d2047 3
a2049 2
	if (sc->bge_pcie) {
		if (CSR_READ_4(sc, 0x7e2c) == 0x60)	/* PCI-E 1.0 system */
d2051 1
d2053 4
a2056 1
			/* Prevent PCI-E link training during global reset */
d2076 1
a2076 1
	if (sc->bge_pcie) {
d2084 1
a2084 1
		/* Set PCI-E max payload size and clear error status. */
d2120 1
a2120 1
	if (sc->bge_eeprom && i >= BGE_TIMEOUT)
d2156 2
a2157 1
	if (sc->bge_tbi && BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704) {
d2165 2
a2166 1
	if (sc->bge_pcie && sc->bge_chipid != BGE_CHIPID_BCM5750_A0) {
d2169 1
a2169 1
		/* Enable PCI-E bug fix */
d2291 1
a2291 1
		if (sc->bge_rx_alignment_bug) {
d2474 1
a2474 3
	if (!sc->bge_tbi) {
		mii_tick(mii);
	} else {
d2482 2
a2483 1
	}
d2948 1
a2948 1
	if (sc->bge_tbi) {
d3007 1
a3007 1
	if (sc->bge_tbi) {
d3106 1
a3106 1
		if (sc->bge_tbi) {
d3237 1
a3237 1
	if (!sc->bge_tbi) {
d3325 1
a3325 1
	if (sc->bge_tbi) {
@


1.182
log
@update the comment for bge_chipinit().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.181 2006/09/26 13:10:44 mickey Exp $	*/
d236 1
d251 1
d264 4
d351 1
d373 1
@


1.181
log
@do not alloc jumbo buffers (3.5m per iface) and also do not allow card to receive large frames until mtu is set to higher value (later piece from brad); brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.180 2006/09/17 23:31:07 brad Exp $	*/
d1076 1
a1076 2
 * Do endian, PCI and DMA initialization. Also check the on-board ROM
 * self-test results.
@


1.180
log
@add a flag to indicate which boards are only capable of 10/100 modes of
operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.179 2006/09/17 22:19:37 brad Exp $	*/
d584 4
d640 1
d1219 1
d1255 10
a1264 3
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x50);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x20);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x60);
a1883 10
	/*
	 * Try to allocate memory for Jumbo buffers.
	 */
	if (BGE_IS_JUMBO_CAPABLE(sc)) {
		if (bge_alloc_jumbo_mem(sc)) {
			printf(": jumbo buffer allocation failed\n");
			goto fail_5;
		}
	}

d2833 11
d2856 2
a2857 6
	if (BGE_IS_JUMBO_CAPABLE(sc))
		CSR_WRITE_4(sc, BGE_RX_MTU,
			BGE_JUMBO_FRAMELEN + ETHER_VLAN_ENCAP_LEN);
	else
		CSR_WRITE_4(sc, BGE_RX_MTU,
			ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN);
d3052 1
a3052 1
		else if (ifp->if_mtu != ifr->ifr_mtu)
d3054 2
@


1.179
log
@Readd the Dell PHY LED setup workaround and the Jumbo capability flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.178 2006/09/17 17:20:42 brad Exp $	*/
d1658 1
d1774 16
@


1.178
log
@- correct the firmware synchronization in bge_reset(), this
  eliminates firmware timeouts for the BCM5752 as the hw
  firmware was coming up too fast for the driver.
- remove the redundant firmware check in bge_chipinit().

Tested by pedro la peu <pedro at am-gen dot org> on an IBM ThinksPpad Z61m
with a BCM5752, as well as the 5700/5703/5704 and 5750.

The initial diff for bge_reset() and other information from
David Christensen <davidch at broadcom dot com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.177 2006/09/17 16:45:22 brad Exp $	*/
d1650 1
a1650 1
	pcireg_t		pm_ctl, memtype;
d1666 2
d1752 22
d1922 2
a1923 1
	
d1928 1
a1928 2
	if ((pci_conf_read(pc, pa->pa_tag, BGE_PCI_SUBSYS) >> 16) ==
	    SK_SUBSYSID_9D41)
a1976 11

	/*
	 * When using the BCM5701 in PCI-X mode, data corruption has
	 * been observed in the first few bytes of some received packets.
	 * Aligning the packet buffer in memory eliminates the corruption.
	 * Unfortunately, this misaligns the packet payloads.  On platforms
	 * which do not support unaligned accesses, we will realign the
	 * payloads by copying the received packets.
	 */
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701 && sc->bge_pcix)
		sc->bge_rx_alignment_bug = 1;
@


1.177
log
@defer establishing the interrupt until later during attach, to let the
driver finish initializing. fixes a panic in bge_intr() upon bootup on
some systems running non-MP kernels.

Issue reported/fix tested by jolan@@, also mentioned in PR 5114 though the
issue is intermisttent on the IBM e326m.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.176 2006/09/16 12:24:33 kettenis Exp $	*/
d175 1
a175 1
int bge_chipinit(struct bge_softc *);
d1074 1
a1074 1
int
a1084 12
	/*
	 * Check the 'ROM failed' bit on the RX CPU to see if
	 * self-tests passed.  Skip this check when there's no SEEPROM
	 * fitted, since in that case it will always fail.
	 */
	if (sc->bge_eeprom &&
	    CSR_READ_4(sc, BGE_RXCPU_MODE) & BGE_RXCPUMODE_ROMFAIL) {
		printf("%s: RX CPU self-diagnostics failed!\n",
		    sc->bge_dev.dv_xname);
		return (ENODEV);
	}

a1207 2

	return (0);
d1754 1
a1754 4
	if (bge_chipinit(sc)) {
		printf(": chip initialization failed\n");
		goto fail_1;
	}
d2023 9
a2065 6

	/*
	 * Prevent PXE restart: write a magic number to the
	 * general communications memory at 0xB50.
	 */
	bge_writemem_ind(sc, BGE_SOFTWARE_GENCOMM, BGE_MAGIC_NUMBER);
@


1.176
log
@Get subvendor from the PROM instead of the PCI configuration space, since the
latter gets reset if you netboot from an interface.
ok miod@@, brad@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.175 2006/08/30 21:28:06 kettenis Exp $	*/
a1707 11
	DPRINTFN(5, ("pci_intr_establish\n"));
	sc->bge_intrhand = pci_intr_establish(pc, ih, IPL_NET, bge_intr, sc,
	    sc->bge_dev.dv_xname);
	if (sc->bge_intrhand == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail_1;
	}

a1735 2
	printf(": %s", intrstr);

d1770 1
a1770 1
		goto fail_2;
d1809 1
a1809 1
		goto fail_2;
a1811 6
	/*
	 * A Broadcom chip was detected. Inform the world.
	 */
	printf(", address %s\n",
	    ether_sprintf(sc->arpcom.ac_enaddr));

d1818 1
a1818 1
		goto fail_2;
d1826 1
a1826 1
		goto fail_3;
d1833 1
a1833 1
		goto fail_4;
d1839 1
a1839 1
		goto fail_5;
d1924 18
d1995 3
d2000 1
a2000 1
fail_4:
d2004 1
a2004 1
fail_3:
a2005 3

fail_2:
	pci_intr_disestablish(pc, sc->bge_intrhand);
@


1.175
log
@Try to read station address from the chip first, then try the EEPROM (if we
think it is there).  On sparc64 try to read the local-mac-address property
from Open Firmware and as a last resort use the idprom property.
Hopefully fixes reading the station address on the Blade 1500.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.174 2006/08/29 17:44:16 kettenis Exp $	*/
d1674 3
d1769 7
a1775 3
	if ((pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_SUBSYS) & 0xffff) ==
	    PCI_VENDOR_SUN)
		sc->bge_eeprom = 0;
@


1.174
log
@Add support for onboard bge(4)'s on Sun UltraSPARC hardware that apparently
come without an attached SEEPROM.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.173 2006/08/28 07:58:51 kettenis Exp $	*/
d1782 16
a1799 5
	if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
	    sc->arpcom.ac_enaddr, ETHER_ADDR_LEN) == ETHER_ADDR_LEN)
		gotenaddr = 1;
#endif

d1801 2
a1802 9
		mac_addr = bge_readmem_ind(sc, 0x0c14);
		if ((mac_addr >> 16) == 0x484b) {
			sc->arpcom.ac_enaddr[0] = (u_char)(mac_addr >> 8);
			sc->arpcom.ac_enaddr[1] = (u_char)mac_addr;
			mac_addr = bge_readmem_ind(sc, 0x0c18);
			sc->arpcom.ac_enaddr[2] = (u_char)(mac_addr >> 24);
			sc->arpcom.ac_enaddr[3] = (u_char)(mac_addr >> 16);
			sc->arpcom.ac_enaddr[4] = (u_char)(mac_addr >> 8);
			sc->arpcom.ac_enaddr[5] = (u_char)mac_addr;
a1803 1
		}
d1805 7
d1814 2
a1815 5
		if (bge_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
		    BGE_EE_MAC_OFFSET + 2, ETHER_ADDR_LEN)) {
			printf(": failed to read station address\n");
			goto fail_2;
		}
@


1.173
log
@Get MAC address from the OpenFirmware local-mac-address property on sparc64.
Needed to support onboard bge(4)'s on Sun machines which don't seem to be
fitted with the EEPROM that normally contains the MAC address.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.172 2006/08/28 03:06:47 brad Exp $	*/
d1087 2
a1088 1
	 * self-tests passed.
d1090 2
a1091 1
	if (CSR_READ_4(sc, BGE_RXCPU_MODE) & BGE_RXCPUMODE_ROMFAIL) {
d1762 8
d1912 1
a1912 1
	else {
d2072 2
a2073 1
	 * is complete.
d2082 1
a2082 1
	if (i >= BGE_TIMEOUT)
@


1.172
log
@revert flags usage commits. too close to release. will go in post release instead.

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.167 2006/08/04 15:22:41 brad Exp $	*/
d109 4
d1667 1
a1667 1
	int			rseg;
d1772 27
a1798 13
	mac_addr = bge_readmem_ind(sc, 0x0c14);
	if ((mac_addr >> 16) == 0x484b) {
		sc->arpcom.ac_enaddr[0] = (u_char)(mac_addr >> 8);
		sc->arpcom.ac_enaddr[1] = (u_char)mac_addr;
		mac_addr = bge_readmem_ind(sc, 0x0c18);
		sc->arpcom.ac_enaddr[2] = (u_char)(mac_addr >> 24);
		sc->arpcom.ac_enaddr[3] = (u_char)(mac_addr >> 16);
		sc->arpcom.ac_enaddr[4] = (u_char)(mac_addr >> 8);
		sc->arpcom.ac_enaddr[5] = (u_char)mac_addr;
	} else if (bge_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
	    BGE_EE_MAC_OFFSET + 2, ETHER_ADDR_LEN)) {
		printf(": failed to read station address\n");
		goto fail_2;
@


1.171
log
@add a BGE_JUMBO flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.170 2006/08/28 00:49:47 brad Exp $	*/
d756 1
a756 1
	if (!(sc->bge_flags & BGE_RX_ALIGNBUG))
d825 1
a825 1
	if (!(sc->bge_flags & BGE_RX_ALIGNBUG))
d1107 1
a1107 1
	if (sc->bge_flags & BGE_PCIE) {
d1130 1
a1130 1
	} else if (sc->bge_flags & BGE_PCIX) {
d1236 1
a1236 1
		if (sc->bge_flags & BGE_EXTRAM)
d1312 1
a1312 1
	if (sc->bge_flags & BGE_EXTRAM)
d1335 1
a1335 1
		if (sc->bge_flags & BGE_EXTRAM)
d1519 1
a1519 2
	    ((sc->bge_flags & BGE_TBI) ?
	    BGE_PORTMODE_TBI : BGE_PORTMODE_MII));
d1547 1
a1547 1
		if (sc->bge_flags & BGE_PCIE && 0)
d1591 1
a1591 1
	if (sc->bge_flags & BGE_TBI) {
d1658 1
a1658 1
	pcireg_t		pm_ctl, memtype, subid;
a1670 2
	subid = pci_conf_read(pc, pa->pa_tag, PCI_SUBSYS_ID_REG);

d1743 1
d1746 1
a1746 1
		sc->bge_flags |= BGE_PCIE;
d1751 1
d1754 1
a1754 1
		sc->bge_flags |= BGE_PCIX;
d1862 1
a1862 1
	if (BGE_IS_JUMBO_CAPABLE(sc)) {
a1863 2
		sc->bge_flags |= BGE_JUMBO;
	}
d1894 1
a1894 1
		sc->bge_flags |= BGE_TBI;
d1897 3
a1899 2
	if (PCI_PRODUCT(subid) == SK_SUBSYSID_9D41)
		sc->bge_flags |= BGE_TBI;
d1901 1
a1901 6
	if ((BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701) &&
	    PCI_VENDOR(subid) == DELL_VENDORID)
		sc->bge_flags |= BGE_NO3LED;

	if (sc->bge_flags & BGE_TBI) {
d1938 2
a1939 3
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701 &&
	    sc->bge_flags & BGE_PCIX)
		sc->bge_flags |= BGE_RX_ALIGNBUG;
d1989 2
a1990 3
	if (sc->bge_flags & BGE_PCIE) {
		if (CSR_READ_4(sc, 0x7e2c) == 0x60) {
			/* PCI Express 1.0 system */
a1991 1
		}
d1993 1
a1993 4
			/*
			 * Prevent PCI Express link training
			 * during global reset.
			 */
d2004 1
a2004 1
	if (sc->bge_flags & BGE_PCIE) {
d2012 1
a2012 1
		/* Set PCI Express max payload size and clear error status. */
d2089 1
a2089 2
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704 &&
	    sc->bge_flags & BGE_TBI) {
d2097 1
a2097 2
	if (sc->bge_flags & BGE_PCIE &&
	    sc->bge_chipid != BGE_CHIPID_BCM5750_A0) {
d2100 1
a2100 1
		/* Enable PCI Express bug fix */
d2222 1
a2222 1
		if (sc->bge_flags & BGE_RX_ALIGNBUG) {
d2405 3
a2407 1
	if (sc->bge_flags & BGE_TBI) {
d2415 1
a2415 2
	} else
		mii_tick(mii);
d2873 1
a2873 1
	if (sc->bge_flags & BGE_TBI) {
d2932 1
a2932 1
	if (sc->bge_flags & BGE_TBI) {
d3029 1
a3029 1
		if (sc->bge_flags & BGE_TBI) {
d3160 1
a3160 1
	if (!(sc->bge_flags & BGE_TBI)) {
d3248 1
a3248 1
	if (sc->bge_flags & BGE_TBI) {
@


1.170
log
@Set the BGE_NO3LED flag to properly adjust the PHY LED mode if attaching
to either a BCM5700 or BCM5701 chip and have the Dell PCI vendor subid.
The appropriate code has been in brgphy for 2 years, now the bge(4) driver
will use it.

Also found in the Broadcom bcm5700 and Linux tg3 drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.169 2006/08/27 21:42:13 brad Exp $	*/
d1863 1
a1863 1
	if (BGE_IS_JUMBO_CAPABLE(sc))
d1865 2
@


1.169
log
@it works a little better like this.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.168 2006/08/27 21:06:16 brad Exp $	*/
d1659 1
a1659 1
	pcireg_t		pm_ctl, memtype;
d1672 2
d1898 1
a1898 2
	if ((pci_conf_read(pc, pa->pa_tag, BGE_PCI_SUBSYS) >> 16) ==
	    SK_SUBSYSID_9D41)
d1900 5
@


1.168
log
@pack several boolean fields into the existing bge_flags field.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.167 2006/08/04 15:22:41 brad Exp $	*/
d2103 2
a2104 2
	if (sc->bge_chipid != BGE_CHIPID_BCM5750_A0 &&
	if (sc->bge_flags & BGE_PCIE) {
@


1.167
log
@move the promiscuous mode handling code into bge_setpromisc() and simplify
the interface flags ioctl handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.166 2006/07/01 06:26:51 brad Exp $	*/
d756 1
a756 1
	if (!sc->bge_rx_alignment_bug)
d825 1
a825 1
	if (!sc->bge_rx_alignment_bug)
d1107 1
a1107 1
	if (sc->bge_pcie) {
d1130 1
a1130 1
	} else if (sc->bge_pcix) {
d1236 1
a1236 1
		if (sc->bge_extram)
d1312 1
a1312 1
	if (sc->bge_extram)
d1335 1
a1335 1
		if (sc->bge_extram)
d1519 2
a1520 1
	    (sc->bge_tbi ? BGE_PORTMODE_TBI : BGE_PORTMODE_MII));
d1548 1
a1548 1
		if (sc->bge_pcie && 0)
d1592 1
a1592 1
	if (sc->bge_tbi) {
a1743 1
	sc->bge_pcie = 0;
d1746 1
a1746 1
		sc->bge_pcie = 1;
a1750 1
	sc->bge_pcix = 0;
d1753 1
a1753 1
		sc->bge_pcix = 1;
d1893 1
a1893 1
		sc->bge_tbi = 1;
d1898 1
a1898 1
		sc->bge_tbi = 1;
d1900 1
a1900 1
	if (sc->bge_tbi) {
d1937 3
a1939 2
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701 && sc->bge_pcix)
		sc->bge_rx_alignment_bug = 1;
d1989 3
a1991 2
	if (sc->bge_pcie) {
		if (CSR_READ_4(sc, 0x7e2c) == 0x60)	/* PCI-E 1.0 system */
d1993 1
d1995 4
a1998 1
			/* Prevent PCI-E link training during global reset */
d2009 1
a2009 1
	if (sc->bge_pcie) {
d2017 1
a2017 1
		/* Set PCI-E max payload size and clear error status. */
d2094 2
a2095 1
	if (sc->bge_tbi && BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704) {
d2103 2
a2104 1
	if (sc->bge_pcie && sc->bge_chipid != BGE_CHIPID_BCM5750_A0) {
d2107 1
a2107 1
		/* Enable PCI-E bug fix */
d2229 1
a2229 1
		if (sc->bge_rx_alignment_bug) {
d2412 1
a2412 3
	if (!sc->bge_tbi) {
		mii_tick(mii);
	} else {
d2420 2
a2421 1
	}
d2879 1
a2879 1
	if (sc->bge_tbi) {
d2938 1
a2938 1
	if (sc->bge_tbi) {
d3035 1
a3035 1
		if (sc->bge_tbi) {
d3166 1
a3166 1
	if (!sc->bge_tbi) {
d3254 1
a3254 1
	if (sc->bge_tbi) {
@


1.166
log
@recognize the 5750 C2.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.165 2006/06/29 01:43:34 brad Exp $	*/
d157 1
d1055 11
d2797 1
a2797 4
	if (ifp->if_flags & IFF_PROMISC)
		BGE_SETBIT(sc, BGE_RX_MODE, BGE_RXMODE_RX_PROMISC);
	else
		BGE_CLRBIT(sc, BGE_RX_MODE, BGE_RXMODE_RX_PROMISC);
d2998 3
a3000 10
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->bge_if_flags & IFF_PROMISC)) {
				BGE_SETBIT(sc, BGE_RX_MODE,
				    BGE_RXMODE_RX_PROMISC);
				bge_setmulti(sc);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->bge_if_flags & IFF_PROMISC) {
				BGE_CLRBIT(sc, BGE_RX_MODE,
				    BGE_RXMODE_RX_PROMISC);
@


1.165
log
@do not return from the reset function if there was a timeout
with the firmware.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.164 2006/06/27 16:46:24 brad Exp $	*/
d331 1
@


1.164
log
@don't set BGE_DEBUG by default, reduces the bloat a bit. noticed by deraadt.
no one noticed this has been here since rev 1.1.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.163 2006/06/27 16:40:11 brad Exp $	*/
d2040 1
a2040 1
	if (i >= BGE_TIMEOUT) {
a2042 2
		return;
	}
@


1.163
log
@Disable Jumbos on the 5714 family of chips for now. The bge driver assumes
that all chips which have Jumbo capability have a separate Jumbo receive ring.
It seems as if the 5714 family has done away with the separate receive ring,
according to the Linux driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.162 2006/06/22 04:15:47 brad Exp $	*/
a183 1
#define BGE_DEBUG
@


1.162
log
@recognize the BCM5703 B0.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.161 2006/06/21 19:11:01 brad Exp $	*/
a291 3
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714_A0 || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5780    || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714    || \
@


1.161
log
@remove some unused code.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.160 2006/06/21 17:21:41 brad Exp $	*/
d318 1
@


1.160
log
@add the BCM5786 PCI id.

From the Linux tg3 driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.159 2006/06/20 07:04:32 brad Exp $	*/
d2236 1
a2236 1
#if 0
d2242 1
a2242 1
#endif
d2481 2
a2482 2
	struct mbuf	*m, *prev;
	int 		totlen, prevlen;
d2541 28
a2568 43
#ifdef notyet	/* just do the safe slow thing for now */
			if (!M_READONLY(m)) {
				if (M_LEADINGSPACE(m) < shorfall) {
					void *m_dat;

					m_dat = (m->m_flags & M_PKTHDR) ?
					    m->m_pktdat : m->dat;
					memmove(m_dat, mtod(m, void*), m->m_len);
					m->m_data = m_dat;
				}
			} else
#endif	/* just do the safe slow thing */
			{
				struct mbuf * n = NULL;
				int newprevlen = prev->m_len - shortfall;

				MGET(n, M_NOWAIT, MT_DATA);
				if (n == NULL)
					return (ENOBUFS);
				KASSERT(m->m_len + shortfall < MLEN
					/*,
					  ("runt %d +prev %d too big\n", m->m_len, shortfall)*/);

				/* first copy the data we're stealing from prev */
				bcopy(prev->m_data + newprevlen, n->m_data, shortfall);

				/* update prev->m_len accordingly */
				prev->m_len -= shortfall;

				/* copy data from runt m */
				bcopy(m->m_data, n->m_data + shortfall, m->m_len);

				/* n holds what we stole from prev, plus m */
				n->m_len = shortfall + m->m_len;

				/* stitch n into chain and free m */
				n->m_next = m->m_next;
				prev->m_next = n;
				/* KASSERT(m->m_next == NULL); */
				m->m_next = NULL;
				m_free(m);
				m = n;	/* for continuing loop */
			}
a2705 19

		/*
		 * XXX
		 * safety overkill.  If this is a fragmented packet chain
		 * with delayed TCP/UDP checksums, then only encapsulate
		 * it if we have enough descriptors to handle the entire
		 * chain at once.
		 * (paranoia -- may not actually be needed)
		 */
#ifdef fake
		if (m_head->m_flags & M_FIRSTFRAG &&
		    m_head->m_pkthdr.csum_flags & (CSUM_DELAY_DATA)) {
			if ((BGE_TX_RING_CNT - sc->bge_txcnt) <
			    m_head->m_pkthdr.csum_data + 16) {
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}
		}
#endif
@


1.159
log
@have bge_start() check for an empty send queue instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.158 2006/06/20 06:54:56 brad Exp $	*/
d250 1
@


1.158
log
@- check for revision B2 intead of B1 in one more spot.
- fix no link check in bge_start().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.157 2006/06/20 03:45:22 brad Exp $	*/
d2711 1
a2711 1
	if (!sc->bge_link || ifp->if_snd.ifq_len < 10)
@


1.157
log
@add the BCM5755 and BCM5787 ASICs to the appropriate macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.156 2006/06/19 05:15:23 brad Exp $	*/
d1585 1
a1585 1
		    sc->bge_chipid != BGE_CHIPID_BCM5700_B1)
d2711 1
a2711 1
	if (!sc->bge_link && ifp->if_snd.ifq_len < 10)
@


1.156
log
@add the new ASIC revs to the bge_majorrevs table.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.155 2006/06/19 05:11:56 brad Exp $	*/
d269 3
a271 1
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5752)
d278 3
a280 1
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5752)
@


1.155
log
@add new PCI ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.154 2006/06/17 18:00:43 brad Exp $	*/
d356 2
@


1.154
log
@add sys/timeout.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.153 2006/06/15 20:34:41 brad Exp $	*/
d242 4
d250 2
@


1.153
log
@make these tables look a little bit nicer.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.152 2006/06/11 00:31:57 brad Exp $	*/
d85 1
@


1.152
log
@the link state detection code should be checking for revision B2 instead
of B1 to account for the differences with the revision defines used in
OpenBSD's if_bgereg.h vs FreeBSD's.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.151 2006/06/02 05:58:24 beck Exp $	*/
d290 40
a329 2
	{ BGE_CHIPID_BCM5700_A0,
	  "BCM5700 A0" },
d331 1
a331 120
	{ BGE_CHIPID_BCM5700_A1,
	  "BCM5700 A1" },

	{ BGE_CHIPID_BCM5700_B0,
	  "BCM5700 B0" },

	{ BGE_CHIPID_BCM5700_B1,
	  "BCM5700 B1" },

	{ BGE_CHIPID_BCM5700_B2,
	  "BCM5700 B2" },

	{ BGE_CHIPID_BCM5700_B3,
	  "BCM5700 B3" },

	/* This is treated like a BCM5700 Bx */
	{ BGE_CHIPID_BCM5700_ALTIMA,
	  "BCM5700 Altima" },

	{ BGE_CHIPID_BCM5700_C0,
	  "BCM5700 C0" },

	{ BGE_CHIPID_BCM5701_A0,
	  "BCM5701 A0" },

	{ BGE_CHIPID_BCM5701_B0,
	  "BCM5701 B0" },

	{ BGE_CHIPID_BCM5701_B2,
	  "BCM5701 B2" },

	{ BGE_CHIPID_BCM5701_B5,
	  "BCM5701 B5" },

	{ BGE_CHIPID_BCM5703_A0,
	  "BCM5703 A0" },

	{ BGE_CHIPID_BCM5703_A1,
	  "BCM5703 A1" },

	{ BGE_CHIPID_BCM5703_A2,
	  "BCM5703 A2" },

	{ BGE_CHIPID_BCM5703_A3,
	  "BCM5703 A3" },

	{ BGE_CHIPID_BCM5704_A0,
	  "BCM5704 A0" },

	{ BGE_CHIPID_BCM5704_A1,
	  "BCM5704 A1" },

	{ BGE_CHIPID_BCM5704_A2,
	  "BCM5704 A2" },

	{ BGE_CHIPID_BCM5704_A3,
	  "BCM5704 A3" },

	{ BGE_CHIPID_BCM5704_B0,
	  "BCM5704 B0" },

	{ BGE_CHIPID_BCM5705_A0,
	  "BCM5705 A0" },

	{ BGE_CHIPID_BCM5705_A1,
	  "BCM5705 A1" },

	{ BGE_CHIPID_BCM5705_A2,
	  "BCM5705 A2" },

	{ BGE_CHIPID_BCM5705_A3,
	  "BCM5705 A3" },

	{ BGE_CHIPID_BCM5750_A0,
	  "BCM5750 A0" },

	{ BGE_CHIPID_BCM5750_A1,
	  "BCM5750 A1" },

	{ BGE_CHIPID_BCM5750_A3,
	  "BCM5750 A3" },

	{ BGE_CHIPID_BCM5750_B0,
	  "BCM5750 B0" },

	{ BGE_CHIPID_BCM5750_B1,
	  "BCM5750 B1" },

	{ BGE_CHIPID_BCM5750_C0,
	  "BCM5750 C0" },

	{ BGE_CHIPID_BCM5750_C1,
	  "BCM5750 C1" },

	{ BGE_CHIPID_BCM5714_A0,
	  "BCM5714 A0" },

	{ BGE_CHIPID_BCM5752_A0,
	  "BCM5752 A0" },

	{ BGE_CHIPID_BCM5752_A1,
	  "BCM5752 A1" },

	{ BGE_CHIPID_BCM5752_A2,
	  "BCM5752 A2" },

	{ BGE_CHIPID_BCM5714_B0,
	  "BCM5714 B0" },

	{ BGE_CHIPID_BCM5714_B3,
	  "BCM5714 B3" },

	{ BGE_CHIPID_BCM5715_A0,
	  "BCM5715 A0" },

	{ BGE_CHIPID_BCM5715_A1,
	  "BCM5715 A1" },

	{ 0,
	  NULL }
d339 10
a348 29
	{ BGE_ASICREV_BCM5700,
	  "unknown BCM5700" },

	{ BGE_ASICREV_BCM5701,
	  "unknown BCM5701" },

	{ BGE_ASICREV_BCM5703,
	  "unknown BCM5703" },

	{ BGE_ASICREV_BCM5704,
	  "unknown BCM5704" },

	{ BGE_ASICREV_BCM5705,
	  "unknown BCM5705" },

	{ BGE_ASICREV_BCM5750,
	  "unknown BCM5750" },

	{ BGE_ASICREV_BCM5714_A0,
	  "unknown BCM5714" },

	{ BGE_ASICREV_BCM5752,
	  "unknown BCM5752" },

	{ BGE_ASICREV_BCM5780,
	  "unknown BCM5780" },

	{ BGE_ASICREV_BCM5714,
	  "unknown BCM5714" },
d350 1
a350 2
	{ 0,
	  NULL }
@


1.151
log
@
Deja-vu - again I make bge stop claiming all interrupts for it's own.

This appears to have been due to driver changes and the fact that
the status word seems to not be cleared. linux may have the same bug.
freebsd does clear the status word with and atomic read and clear
ops. we instead do best effort here to check for the interrupt being
ours by reading the status from the status block to a local copy,
then clearing the status word once we enter the interrupt handler
and using the local copy for checking link status

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.150 2006/05/31 23:40:08 brad Exp $	*/
d2446 1
a2446 1
		    sc->bge_chipid != BGE_CHIPID_BCM5700_B1) ||
d3341 1
a3341 1
	 * BGE_CHIPID_BCM5700_B1 can be used for other BCM5700 revisions.
d3345 1
a3345 1
	    sc->bge_chipid != BGE_CHIPID_BCM5700_B1) {
@


1.150
log
@xcs -> xsc
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.149 2006/05/28 00:20:21 brad Exp $	*/
d2422 1
d2432 5
a2436 2
	if ((sc->bge_rdata->bge_status_block.bge_status &
	    BGE_STATFLAG_UPDATED) ||
d2441 3
d2447 1
a2447 2
		    sc->bge_rdata->bge_status_block.bge_status &
		    BGE_STATFLAG_LINKSTATE_CHANGED ||
@


1.149
log
@- remove ETHER_MAX_LEN_JUMBO and ETHERMTU_JUMBO.
- use if_hardmtu for MTU ioctl handlers.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.148 2006/05/28 00:04:24 jason Exp $	*/
d3414 1
a3414 1
bge_power(int why, void *xcs)
d3416 1
a3416 1
	struct bge_softc *sc = (struct bge_softc *)xcs;
d3422 1
a3422 1
			bge_init(xcs);
@


1.148
log
@unknown ioctl is ENOTTY not EINVAL
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.147 2006/05/27 10:03:15 brad Exp $	*/
d900 2
a901 2
		m_new->m_len = m_new->m_pkthdr.len = ETHER_MAX_LEN_JUMBO;
		MEXTADD(m_new, buf, ETHER_MAX_LEN_JUMBO, 0, bge_jfree, sc);
d910 1
a910 1
		m_new->m_ext.ext_size = ETHER_MAX_LEN_JUMBO;
d1410 1
a1410 1
		    BGE_RCB_MAXLEN_FLAGS(ETHER_MAX_LEN_JUMBO,
d1940 1
a1940 1
		ifp->if_hardmtu = ETHERMTU_JUMBO;
d2893 1
a2893 1
			ETHER_MAX_LEN_JUMBO + ETHER_VLAN_ENCAP_LEN);
d3092 1
a3092 5
		if (ifr->ifr_mtu < ETHERMIN ||
		    ((BGE_IS_JUMBO_CAPABLE(sc)) &&
		    ifr->ifr_mtu > ETHERMTU_JUMBO) ||
		    ((!BGE_IS_JUMBO_CAPABLE(sc)) &&
		    ifr->ifr_mtu > ETHERMTU))
@


1.147
log
@remove IFCAP_JUMBO_MTU interface capabilities flag and set if_hardmtu in a few
more drivers.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.146 2006/05/20 04:18:51 brad Exp $	*/
d3160 1
a3160 1
		error = EINVAL;
@


1.146
log
@remove commented out and unused capabilities flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.145 2006/05/20 03:47:56 brad Exp $	*/
d1940 1
a1940 1
		ifp->if_capabilities |= IFCAP_JUMBO_MTU;
@


1.145
log
@set if_jumbo_mtu and the IFCAP_JUMBO_MTU capabilities flag where
appropriate.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.144 2006/05/08 20:08:02 brad Exp $	*/
a1152 5

#ifdef BGE_CHECKSUM
	sc->arpcom.ac_if.if_capabilities =
	  IFCAP_CSUM_IPv4 | IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4;
#endif
@


1.144
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.143 2006/04/30 05:42:31 brad Exp $	*/
d1944 3
d2895 1
a2895 1
	/* Specify MTU. */
@


1.143
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.142 2006/04/24 00:00:21 brad Exp $	*/
d854 1
a854 1
		return(ENOMEM);
d2576 1
a2576 1
		if (mlen == 0) {
a2577 1
		}
d2588 2
a2589 2
		      M_TRAILINGSPACE(prev) >= m->m_len) {
		  	bcopy(m->m_data,
d2598 4
a2601 5
		}
		else if (m->m_next != NULL && !M_READONLY(m) &&
			     M_TRAILINGSPACE(m) >= shortfall &&
			     m->m_next->m_len >= (8 + shortfall)) {
		    /* m is writable and have enough data in next, pull up. */
d2603 1
a2603 1
		  	bcopy(m->m_next->m_data,
d2609 2
a2610 3
		}
		else if (m->m_next == NULL || 1) {
		  	/* Got a runt at the very end of the packet.
d2628 1
d2630 1
a2630 1
					  m->m_pktdat : m->dat;
d2633 1
a2633 1
				    }
d2642 1
a2642 1
				   return ENOBUFS;
d2674 1
a2674 1
 * Encapsulate an mbuf chain in the tx ring  by coupling the mbuf data
d2719 1
a2719 1
		return ENOBUFS;
d2723 1
a2723 1
		return ENOBUFS;
d2762 1
a2762 1
		return ENOBUFS;
d2800 1
a2800 1
	while(sc->bge_cdata.bge_tx_chain[prodidx] == NULL) {
d2906 1
a2906 1
	if (ifp->if_flags & IFF_PROMISC) {
d2908 1
a2908 1
	} else {
a2909 1
	}
@


1.142
log
@add a missing return here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.141 2006/04/21 03:22:18 brad Exp $	*/
d3089 1
a3089 1
		if ((ifp->if_flags & IFF_RUNNING) == 0)
d3094 1
a3094 1
#endif
d3132 1
a3132 1
				if ((ifp->if_flags & IFF_RUNNING) == 0)
@


1.141
log
@recognize the BCM5752 A2
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.140 2006/04/05 01:47:38 brad Exp $	*/
d3055 1
@


1.140
log
@add a power hook for bge(4).

From Thordur I. Bjornsson <thib at mi dot is>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.139 2006/03/29 02:23:25 brad Exp $	*/
d395 3
@


1.139
log
@check for IFF_RUNNING being set before calling bge_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.138 2006/03/25 22:41:44 djm Exp $	*/
d144 1
d2023 3
a2025 2
	shutdownhook_establish(bge_shutdown, sc);

d3416 16
@


1.138
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.137 2006/03/16 02:40:16 brad Exp $	*/
a2871 5
	if (ifp->if_flags & IFF_RUNNING) {
		splx(s);
		return;
	}

d3083 2
a3084 2
		bge_init(sc);
		switch (ifa->ifa_addr->sa_family) {
d3086 1
a3086 1
		case AF_INET:
d3088 1
a3088 5
			break;
#endif /* INET */
		default:
			break;
		}
d3123 1
a3123 1
			    (ifp->if_flags ^ sc->bge_if_flags) & IFF_ALLMULTI)
d3125 4
a3128 2
			else
				bge_init(sc);
a3176 1
	ifp->if_flags &= ~IFF_RUNNING;
@


1.137
log
@if the link is down with a card using a fibre interface then show a
media status of none.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.136 2006/03/10 21:39:01 brad Exp $	*/
d2312 1
a2312 1
			bpf_mtap(ifp->if_bpf, m);
d2841 1
a2841 1
			bpf_mtap(ifp->if_bpf, m_head);
@


1.136
log
@in bge_intr() also check the PCI State register to see if there
are really any interrupts to service.

Based on the Linux tg3 driver though the Broadcom bcm5700 driver
does the same thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.135 2006/02/21 01:45:47 brad Exp $	*/
d3051 1
a3051 1
		    BGE_MACSTAT_TBI_PCS_SYNCHED)
d3053 3
@


1.135
log
@- Overhaul link state detection code.
- Make use of if_link_state_change() so CARP will now see link state
changes for fibre cards.

revs 1.102, 1.104, 1.113, 1.120, and 1.124.

From FreeBSD

Tested with 5700/5701/5703/5704/5750 and a 5752.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.134 2006/02/13 00:57:10 brad Exp $	*/
d2423 22
a2444 4
	/* Make sure this is really our interrupt. */
	if (!(sc->bge_rdata->bge_status_block.bge_status &
	    BGE_STATFLAG_UPDATED))
		return (0);
d2446 3
a2448 2
	/* Ack interrupt and stop others from occurring. */
	CSR_WRITE_4(sc, BGE_MBX_IRQ0_LO, 1);
d2450 2
a2451 5
	if ((BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 &&
	    sc->bge_chipid != BGE_CHIPID_BCM5700_B1) ||
	    sc->bge_rdata->bge_status_block.bge_status & BGE_STATFLAG_LINKSTATE_CHANGED ||
	    sc->bge_link_evt)
		bge_link_upd(sc);
d2453 2
a2454 3
	if (ifp->if_flags & IFF_RUNNING) {
		/* Check RX return ring producer/consumer */
		bge_rxeof(sc);
d2456 3
a2458 11
		/* Check TX ring producer/consumer */
		bge_txeof(sc);
	}

	/* Re-enable interrupts. */
	CSR_WRITE_4(sc, BGE_MBX_IRQ0_LO, 0);

	if (ifp->if_flags & IFF_RUNNING && !IFQ_IS_EMPTY(&ifp->if_snd))
		bge_start(ifp);

	return (1);
@


1.134
log
@Due to an oversight on my part I forgot to remove clearing of the
BGE_PCIDMARWCTL_MINDMA flag from the PCI DMA control register
on newer bge chipsets when I put in the new PCI DMA control register
settings.

Thanks to Daniel Ouellet for testing with a BCM5780 and to Dimitry Andric
for testing with a BCM5750.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.133 2006/02/13 00:44:52 brad Exp $	*/
d180 1
d1673 2
a1674 2
		if (BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5700_AX ||
		    BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5700_BX)
d1679 11
a2418 1
	u_int32_t status, mimode;
d2431 5
a2435 70
	/*
	 * Process link state changes.
	 * Grrr. The link status word in the status block does
	 * not work correctly on the BCM5700 rev AX and BX chips,
	 * according to all available information. Hence, we have
	 * to enable MII interrupts in order to properly obtain
	 * async link changes. Unfortunately, this also means that
	 * we have to read the MAC status register to detect link
	 * changes, thereby adding an additional register access to
	 * the interrupt handler.
	 */
	if (BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5700_AX ||
	    BGE_CHIPREV(sc->bge_chipid) == BGE_CHIPREV_5700_BX) {
		status = CSR_READ_4(sc, BGE_MAC_STS);
		if (status & BGE_MACSTAT_MI_INTERRUPT) {
			sc->bge_link = 0;
			timeout_del(&sc->bge_timeout);
			bge_tick(sc);
			/* Clear the interrupt */
			CSR_WRITE_4(sc, BGE_MAC_EVT_ENB,
			    BGE_EVTENB_MI_INTERRUPT);
			bge_miibus_readreg(&sc->bge_dev, 1, BRGPHY_MII_ISR);
			bge_miibus_writereg(&sc->bge_dev, 1, BRGPHY_MII_IMR,
			    BRGPHY_INTRS);
		}
	} else {
		if ((sc->bge_rdata->bge_status_block.bge_status &
		    BGE_STATFLAG_UPDATED) &&
		    (sc->bge_rdata->bge_status_block.bge_status &
		    BGE_STATFLAG_LINKSTATE_CHANGED)) {
			sc->bge_rdata->bge_status_block.bge_status &=
			    ~(BGE_STATFLAG_UPDATED | 
				BGE_STATFLAG_LINKSTATE_CHANGED);
			/*
			 * Sometimes PCS encoding errors are detected in
			 * TBI mode (on fiber NICs), and for some reason
			 * the chip will signal them as link changes.
			 * If we get a link change event, but the 'PCS 
			 * encoding bit' in the MAC status register
			 * is set, don't bother doing a link check.
			 * This avoids spurious "gigabit link up" messages
			 * that sometimes appear on fiber NICs during
			 * periods of heavy traffic. (There should be no
			 * effect on copper NICs).
			 *
			 * If we do have a copper NIC (bge_tbi == 0) then
			 * check that the AUTOPOLL bit is set before
			 * processing the event as a real link change.
			 * Turning AUTOPOLL on and off in the MII read/write
			 * functions will often trigger a link status
			 * interrupt for no reason.
			 */
			status = CSR_READ_4(sc, BGE_MAC_STS);
			mimode = CSR_READ_4(sc, BGE_MI_MODE);
			if (!(status & (BGE_MACSTAT_PORT_DECODE_ERROR | 
			    BGE_MACSTAT_MI_COMPLETE)) && (!sc->bge_tbi &&
			    (mimode & BGE_MIMODE_AUTOPOLL))) {
				sc->bge_link = 0;
				timeout_del(&sc->bge_timeout);
				bge_tick(sc);
			}
			/* Clear the interrupt */
			CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED|
			    BGE_MACSTAT_CFG_CHANGED|BGE_MACSTAT_MI_COMPLETE|
			    BGE_MACSTAT_LINK_CHANGED);

			/* Force flush the status block cached by PCI bridge */
			CSR_READ_4(sc, BGE_MBX_IRQ0_LO);	
		}
	}
a2458 2
	struct ifmedia *ifm = NULL;
	struct ifnet *ifp = &sc->arpcom.ac_if;
a2466 5
	timeout_add(&sc->bge_timeout, hz);
	if (sc->bge_link) {
		splx(s);
		return;
	}
d2468 10
a2477 14
	if (sc->bge_tbi) {
		ifm = &sc->bge_ifmedia;
		if (CSR_READ_4(sc, BGE_MAC_STS) &
		    BGE_MACSTAT_TBI_PCS_SYNCHED) {
			sc->bge_link++;
			if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704)
				BGE_CLRBIT(sc, BGE_MAC_MODE,
				    BGE_MACMODE_TBI_SEND_CFGS);
			CSR_WRITE_4(sc, BGE_MAC_STS, 0xFFFFFFFF);
			if (!IFQ_IS_EMPTY(&ifp->if_snd))
				bge_start(ifp);
		}
		splx(s);
		return;
d2480 1
a2480 8
	mii_tick(mii);

	if (!sc->bge_link && mii->mii_media_status & IFM_ACTIVE &&
	    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
		sc->bge_link++;
		if (!IFQ_IS_EMPTY(&ifp->if_snd))
			bge_start(ifp);
	}
d3019 1
a3019 1
	sc->bge_link = 0;
d3290 8
a3298 2

	sc->bge_tx_saved_considx = BGE_TXCONS_UNSET;
d3312 100
@


1.133
log
@revert rev 1.85. The mbuf needs to be re-mapped in the case of an error.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.132 2006/02/11 09:01:30 brad Exp $	*/
d1254 1
a1254 4
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5705 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5750 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5780 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5752)
@


1.132
log
@recognize another 5714 family chipset.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.131 2006/02/09 03:31:44 brad Exp $	*/
a827 6
		if (!sc->bge_rx_alignment_bug)
		    m_adj(m_new, ETHER_ALIGN);

		if (bus_dmamap_load_mbuf(sc->bge_dmatag, dmamap, m_new,
		    BUS_DMA_READ|BUS_DMA_NOWAIT))
			return (ENOBUFS);
d837 14
a850 2
		if (!sc->bge_rx_alignment_bug)
		    m_adj(m_new, ETHER_ALIGN);
@


1.131
log
@cleaning.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.130 2006/02/09 01:17:24 brad Exp $	*/
d393 6
@


1.130
log
@adjust timeouts a bit.

Based on the Broadcom Linux driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.129 2006/02/08 22:09:20 brad Exp $	*/
d634 1
a634 1
	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T) {
d636 1
a636 1
	} else {
a637 1
	}
d639 1
a639 1
	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX) {
d641 1
a641 1
	} else {
a642 1
	}
@


1.129
log
@fix MTU check.

From damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.128 2006/02/06 04:59:30 brad Exp $	*/
d564 2
a565 1
	for (i = 0; i < BGE_TIMEOUT; i++) {
d572 1
a572 1
	if (i == BGE_TIMEOUT) {
d610 2
a611 1
	for (i = 0; i < BGE_TIMEOUT; i++) {
d622 1
a622 1
	if (i == BGE_TIMEOUT) {
d1345 1
a1345 1
	for (i = 0; i < BGE_TIMEOUT; i++) {
d1351 1
a1351 1
	if (i == BGE_TIMEOUT) {
d1362 1
a1362 1
	for (i = 0; i < BGE_TIMEOUT; i++) {
d1368 1
a1368 1
	if (i == BGE_TIMEOUT) {
d1527 1
a1527 1
	for (i = 0; i < BGE_TIMEOUT; i++) {
d1533 1
a1533 1
	if (i == BGE_TIMEOUT) {
d2108 1
a2108 1
	if (i == BGE_TIMEOUT) {
@


1.128
log
@Make sure to call bge_setmulti() as we're enabling or disabling promiscuous
mode so as to receive all multicast packets too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.127 2006/02/02 21:31:10 brad Exp $	*/
d3155 3
a3157 1
		    ifr->ifr_mtu > ETHERMTU_JUMBO) || ifr->ifr_mtu > ETHERMTU)
@


1.127
log
@Call bge_setmulti() if IFF_ALLMULTI is set.

From ru FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.126 2006/02/02 20:35:55 brad Exp $	*/
d1104 1
a1105 1
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
d3141 1
a3144 1
			bge_init(sc);
a3148 1
			bge_init(sc);
d3175 1
d3181 1
d3183 1
a3183 1
			    (ifp->if_flags ^ sc->bge_if_flags) & IFF_ALLMULTI) {
d3185 1
a3185 2
			} else {
				ifp->if_flags &= ~IFF_RUNNING;
a3186 1
			}
d3188 1
a3188 1
			if (ifp->if_flags & IFF_RUNNING) {
a3189 1
			}
a3191 1
		error = 0;
@


1.126
log
@Optimize bge_rxeof() & bge_txeof(): return immediately if there are no packets
to process.

From oleg FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.125 2006/02/02 07:15:37 brad Exp $	*/
d3169 1
a3169 1
			 * second or two.
d3181 3
@


1.125
log
@Use alternate PCI DMA control register settings for PCI Express-based
Broadcom Gigabit Ethernet interfaces.

From jonathan NetBSD and based on the Broadcom Linux driver.

Tested by a few end-users.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.124 2006/02/01 02:02:49 brad Exp $	*/
d2181 5
d2329 5
@


1.124
log
@rearrange code section for enabling the read DMA state machine
to allow enabling the long burst FIFO on PCI Express cards though
its currently disabled at the moment.

From jonathan NetBSD and based on the Broadcom Linux driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.123 2006/02/01 01:53:32 brad Exp $	*/
d1174 21
a1194 3
		dma_rw_ctl = BGE_PCI_READ_CMD | BGE_PCI_WRITE_CMD |
		    (0xf << BGE_PCIDMARWCTL_RD_WAT_SHIFT) |
		    (0x2 << BGE_PCIDMARWCTL_WR_WAT_SHIFT);
@


1.123
log
@one less magic value.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.122 2006/02/01 01:31:43 brad Exp $	*/
d1591 11
a1601 2
	CSR_WRITE_4(sc, BGE_RDMA_MODE,
	    BGE_RDMAMODE_ENABLE|BGE_RDMAMODE_ALL_ATTNS);
@


1.122
log
@Set up the PCI DMA control register properly for the 5714 family,
only tested on the BCM5780 so far as found in the ServerWorks
HT-2000 chipset. bge goes from slow throughput and constant
watchdog resets to no watchdog's and decent throughput and what
appears to be stable operation.

From jonathan NetBSD and based on the Broadcom Linux driver.

Thanks to Daniel Ouellet for testing on an IBM e326m
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.121 2006/01/25 21:01:24 brad Exp $	*/
d2039 2
a2040 1
		pci_conf_write(pa->pa_pc, pa->pa_tag, 0xd8, 0xf5000);
@


1.121
log
@- Count packets discarded by RX/TX MAC (cause of FIFO overflow, etc)
  as input/output interface errors.
- Keep values of rx/tx discards & tx collisions inside struct bge_softc.
  So we can keep statistic across ifconfig down/up runs (cause bringing
  bge up will reset chip).

From oleg FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.120 2005/12/28 22:02:44 brad Exp $	*/
d1179 14
a1192 5
		/*
		 * The 5704 uses a different encoding of read/write
		 * watermarks.
		 */
		if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704)
@


1.120
log
@clear IFF_RUNNING here to get a full re-init.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.119 2005/12/28 21:55:53 brad Exp $	*/
d2507 1
d2518 7
a2524 6
	ifp->if_collisions +=
	   (stats.dot3StatsSingleCollisionFrames +
	   stats.dot3StatsMultipleCollisionFrames +
	   stats.dot3StatsExcessiveCollisions +
	   stats.dot3StatsLateCollisions) -
	   ifp->if_collisions;
d2532 1
d2537 21
a2557 10
	ifp->if_collisions +=
	  (READ_STAT(sc, stats,
	       txstats.dot3StatsSingleCollisionFrames.bge_addr_lo) +
	   READ_STAT(sc, stats,
	       txstats.dot3StatsMultipleCollisionFrames.bge_addr_lo) +
	   READ_STAT(sc, stats,
	       txstats.dot3StatsExcessiveCollisions.bge_addr_lo) +
	   READ_STAT(sc, stats,
	       txstats.dot3StatsLateCollisions.bge_addr_lo)) -
	  ifp->if_collisions;
a2559 9

#ifdef notdef
	ifp->if_collisions +=
	   (sc->bge_rdata->bge_info.bge_stats.dot3StatsSingleCollisionFrames +
	   sc->bge_rdata->bge_info.bge_stats.dot3StatsMultipleCollisionFrames +
	   sc->bge_rdata->bge_info.bge_stats.dot3StatsExcessiveCollisions +
	   sc->bge_rdata->bge_info.bge_stats.dot3StatsLateCollisions) -
	   ifp->if_collisions;
#endif
@


1.119
log
@using the PCI capability register to check for PCI-X mode doesn't get the expected
result as this is set whether the board is in a PCI-X slot or not. The chip
can tell us if we're on a conventional PCI bus.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.118 2005/12/28 20:46:15 brad Exp $	*/
d3129 2
a3130 1
			} else
d3132 1
@


1.118
log
@Fix bge_eeprom_getbyte() to return 1 when timeout happens.
Previously it always returned 0 which means success regardless of
EEPROM status.

While here, add a check whether EEPROM read is successful.

From yongari FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.117 2005/12/28 20:27:38 brad Exp $	*/
d1173 1
d1177 1
a1177 8
	} else if (pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE) &
	    BGE_PCISTATE_PCI_BUSMODE) {
		/* Conventional PCI bus */
		dma_rw_ctl = BGE_PCI_READ_CMD | BGE_PCI_WRITE_CMD |
		    (0x7 << BGE_PCIDMARWCTL_RD_WAT_SHIFT) |
		    (0x7 << BGE_PCIDMARWCTL_WR_WAT_SHIFT) |
		    (0x0f);
	} else {
d1205 7
a1211 1
 	}
d1773 2
a1774 2
	if (pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_PCIX,
	    NULL, NULL) != 0)
d1956 1
a1956 5
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701) {
		/* If in PCI-X mode, work around the alignment bug. */
		if ((pci_conf_read(pc, pa->pa_tag, BGE_PCI_PCISTATE) &
		    (BGE_PCISTATE_PCI_BUSMODE | BGE_PCISTATE_PCI_BUSSPEED)) ==
			BGE_PCISTATE_PCI_BUSSPEED)
a1957 1
	}
@


1.117
log
@eliminate the last few quirk flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.116 2005/12/12 05:25:07 brad Exp $	*/
d505 1
a505 1
		return (0);
d1903 5
a1907 2
		bge_read_eeprom(sc, (caddr_t)&hwcfg, BGE_EE_HWCFG_OFFSET,
		    sizeof(hwcfg));
@


1.116
log
@If a PCI-X card is detected then set bge_pcix.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.115 2005/12/11 01:37:21 brad Exp $	*/
a253 13
/* Various chip quirks. */
#define	BGE_QUIRK_LINK_STATE_BROKEN	0x00000001
#define	BGE_QUIRK_CSUM_BROKEN		0x00000002
#define	BGE_QUIRK_5700_SMALLDMA		0x00000004
#define	BGE_QUIRK_5700_PCIX_REG_BUG	0x00000008
#define	BGE_QUIRK_PRODUCER_BUG		0x00000010
#define	BGE_QUIRK_PCIX_DMA_ALIGN_BUG	0x00000020

/* following bugs are common to bcm5700 rev B, all flavours */
#define BGE_QUIRK_5700_COMMON \
	(BGE_QUIRK_5700_SMALLDMA|BGE_QUIRK_PRODUCER_BUG)


a285 1
	u_int32_t		br_quirks;
a288 1
	  BGE_QUIRK_LINK_STATE_BROKEN,
a291 1
	  BGE_QUIRK_LINK_STATE_BROKEN,
a294 1
	  BGE_QUIRK_LINK_STATE_BROKEN|BGE_QUIRK_CSUM_BROKEN|BGE_QUIRK_5700_COMMON,
a297 1
	  BGE_QUIRK_LINK_STATE_BROKEN|BGE_QUIRK_5700_COMMON,
a300 1
	  BGE_QUIRK_LINK_STATE_BROKEN|BGE_QUIRK_5700_COMMON,
a303 1
	  BGE_QUIRK_LINK_STATE_BROKEN|BGE_QUIRK_5700_COMMON,
a307 1
	  BGE_QUIRK_LINK_STATE_BROKEN|BGE_QUIRK_5700_COMMON,
a310 1
	  0,
a313 1
	  BGE_QUIRK_PCIX_DMA_ALIGN_BUG,
a316 1
	  BGE_QUIRK_PCIX_DMA_ALIGN_BUG,
a319 1
	  BGE_QUIRK_PCIX_DMA_ALIGN_BUG,
a322 1
	  BGE_QUIRK_PCIX_DMA_ALIGN_BUG,
a325 1
	  0,
a328 1
	  0,
a331 1
	  0,
a334 1
	  0,
a337 1
	  0,
a340 1
	  0,
a343 1
	  0,
a346 1
	  0,
a349 1
	  0,
a352 1
	  0,
a355 1
	  0,
a358 1
	  0,
a361 1
	  0,
a364 1
	  0,
a367 1
	  0,
a370 1
	  0,
a373 1
	  0,
a376 1
	  0,
a379 1
	  0,
a382 1
	  0,
a385 1
	  0,
a388 1
	  0,
a391 1
	  0,
a394 1
	  0,
a397 1
	  0,
d400 2
a401 1
	{ 0, 0, NULL }
a409 1
	  BGE_QUIRK_LINK_STATE_BROKEN,
a412 1
	  BGE_QUIRK_PCIX_DMA_ALIGN_BUG,
a415 1
	  0,
a418 1
	  0,
a421 1
	  0,
a424 1
	  0,
a427 1
	  0,
a430 1
	  0,
a433 1
	  0,
a436 1
	  0,
a439 1
	  0,
d1056 1
a1056 1
	if (sc->bge_quirks & BGE_QUIRK_PRODUCER_BUG)
d1061 1
a1061 1
	if (sc->bge_quirks & BGE_QUIRK_PRODUCER_BUG)
d1627 2
a1628 1
		if (sc->bge_quirks & BGE_QUIRK_LINK_STATE_BROKEN)
d1745 1
a1745 2
	 * Save ASIC rev.  Look up any quirks
	 * associated with this ASIC.
d1754 1
a1754 1
	if (br == NULL) {
d1756 1
a1756 2
		sc->bge_quirks = 0;
	} else {
a1757 2
		sc->bge_quirks |= br->br_quirks;
	}
d1953 1
a1953 1
	if (sc->bge_quirks & BGE_QUIRK_PCIX_DMA_ALIGN_BUG) {
d2377 2
a2378 2

	if (sc->bge_quirks & BGE_QUIRK_LINK_STATE_BROKEN) {
d2714 1
a2714 1
	if (!(sc->bge_quirks & BGE_QUIRK_5700_SMALLDMA))
d2855 1
a2855 1
	if (sc->bge_quirks & BGE_QUIRK_PRODUCER_BUG)
@


1.115
log
@recognize BCM5750 C1 on Ted's Fujitsu Lifebook S7000
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.114 2005/12/10 18:40:45 brad Exp $	*/
d1832 8
@


1.114
log
@re-add bge_shutdown() but also register the function with
shutdownhook_establish().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.113 2005/12/09 21:35:44 brad Exp $	*/
d426 4
@


1.113
log
@remove unused function bge_shutdown().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.112 2005/12/09 21:06:45 brad Exp $	*/
d147 1
d2019 2
d3354 13
@


1.112
log
@some cleaning and fixing of comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.111 2005/12/08 03:53:38 brad Exp $	*/
a146 1
void bge_shutdown(void *);
a3350 13
}

/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
void
bge_shutdown(void *xsc)
{
	struct bge_softc *sc = (struct bge_softc *)xsc;

	bge_stop(sc);
	bge_reset(sc);
@


1.111
log
@- Enable the buffer manager on 5705 and newer ASICs.
- Enable the memory arbiter on 5705 and newer ASICs with 5714 family
specific trick from Broadcom's Linux driver.

Tested by Chuck McCollum and Ray Kohler on 575x ASICs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.110 2005/12/08 03:27:18 brad Exp $	*/
d119 1
a119 1
const struct bge_revision * bge_lookup_rev(uint32_t);
d144 1
a144 1
void bge_stop_block(struct bge_softc *, bus_size_t, uint32_t);
d298 2
a299 2
	uint32_t		br_chipid;
	uint32_t		br_quirks;
d1696 1
a1696 1
bge_lookup_rev(uint32_t chipid)
a2057 1
	/* XXX: Broadcom Linux driver. */
d2059 1
a2059 1
		if (CSR_READ_4(sc, 0x7e2c) == 0x60)	/* PCI-E 1.0 */
a2072 1
	/* XXX: Broadcom Linux driver. */
d2159 3
a2161 2
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704 && sc->bge_tbi) {
		uint32_t serdescfg;
a2166 1
	/* XXX: Broadcom Linux driver. */
d2168 3
a2170 1
		uint32_t v;
d3055 1
a3055 1
				uint32_t sgdig;
d3240 1
a3240 1
bge_stop_block(struct bge_softc *sc, bus_size_t reg, uint32_t bit)
@


1.110
log
@This makes bge(4) only look for a PHY at id 1 as done by Broadcom's
Linux driver and FreeBSD. This reverts a change I made based on
NetBSD's bge(4) driver when adding the quirk table flags. Eliminate
the BGE_QUIRK_ONLY_PHY_1 quirk flag.

ok dlg@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.109 2005/12/08 02:32:21 brad Exp $	*/
d277 1
a277 1
	 BGE_ASICREV(sc->bge_chipid) == BGE_AISCREV_BCM5714_A0 || \
d283 1
a283 1
	(BGE_ASICREV(sc->bge_chipid) == BGE_AISCREV_BCM5714_A0 || \
d285 1
a285 1
	 BGE_ASICREV(sc->bge_chipid) == BGE_AISCREV_BCM5714)
d1369 2
a1370 3
	if (!(BGE_IS_5705_OR_BEYOND(sc))) {
		CSR_WRITE_4(sc, BGE_BMAN_MODE,
		    BGE_BMANMODE_ENABLE|BGE_BMANMODE_LOMBUF_ATTN);
d1372 6
a1377 6
		/* Poll for buffer manager start indication */
		for (i = 0; i < BGE_TIMEOUT; i++) {
			if (CSR_READ_4(sc, BGE_BMAN_MODE) & BGE_BMANMODE_ENABLE)
				break;
			DELAY(10);
		}
d1379 4
a1382 5
		if (i == BGE_TIMEOUT) {
			printf("%s: buffer manager failed to start\n",
			    sc->bge_dev.dv_xname);
			return (ENXIO);
		}
d2096 6
a2101 1
	if (!(BGE_IS_5705_OR_BEYOND(sc)))
@


1.109
log
@eliminate the BGE_QUIRK_FEWER_MBUFS quirk flag and assume lower mbufs on
all 5704's. also remove a bit of code duplication in this section of code.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.108 2005/12/08 01:00:46 brad Exp $	*/
d257 4
a260 5
#define	BGE_QUIRK_ONLY_PHY_1		0x00000004
#define	BGE_QUIRK_5700_SMALLDMA		0x00000008
#define	BGE_QUIRK_5700_PCIX_REG_BUG	0x00000010
#define	BGE_QUIRK_PRODUCER_BUG		0x00000020
#define	BGE_QUIRK_PCIX_DMA_ALIGN_BUG	0x00000040
d344 1
a344 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_PCIX_DMA_ALIGN_BUG,
d348 1
a348 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_PCIX_DMA_ALIGN_BUG,
d360 1
a360 1
	  BGE_QUIRK_ONLY_PHY_1,
d364 1
a364 1
	  BGE_QUIRK_ONLY_PHY_1,
d368 1
a368 1
	  BGE_QUIRK_ONLY_PHY_1,
d372 1
a372 1
	  BGE_QUIRK_ONLY_PHY_1,
d376 1
a376 1
	  BGE_QUIRK_ONLY_PHY_1,
d380 1
a380 1
	  BGE_QUIRK_ONLY_PHY_1,
d384 1
a384 1
	  BGE_QUIRK_ONLY_PHY_1,
d388 1
a388 1
	  BGE_QUIRK_ONLY_PHY_1,
d392 1
a392 1
	  BGE_QUIRK_ONLY_PHY_1,
d396 1
a396 1
	  BGE_QUIRK_ONLY_PHY_1,
d400 1
a400 1
	  BGE_QUIRK_ONLY_PHY_1,
d404 1
a404 1
	  BGE_QUIRK_ONLY_PHY_1,
d408 1
a408 1
	  BGE_QUIRK_ONLY_PHY_1,
d412 1
a412 1
	  BGE_QUIRK_ONLY_PHY_1,
d416 1
a416 1
	  BGE_QUIRK_ONLY_PHY_1,
d420 1
a420 1
	  BGE_QUIRK_ONLY_PHY_1,
d424 1
a424 1
	  BGE_QUIRK_ONLY_PHY_1,
d428 1
a428 1
	  BGE_QUIRK_ONLY_PHY_1,
d432 1
a432 1
	  BGE_QUIRK_ONLY_PHY_1,
d436 1
a436 1
	  BGE_QUIRK_ONLY_PHY_1,
d440 1
a440 1
	  BGE_QUIRK_ONLY_PHY_1,
d444 1
a444 1
	  BGE_QUIRK_ONLY_PHY_1,
d468 1
a468 1
	  BGE_QUIRK_ONLY_PHY_1,
d472 1
a472 1
	  BGE_QUIRK_ONLY_PHY_1,
d476 1
a476 1
	  BGE_QUIRK_ONLY_PHY_1,
d480 1
a480 1
	  BGE_QUIRK_ONLY_PHY_1,
d484 1
a484 1
	  BGE_QUIRK_ONLY_PHY_1,
d488 1
a488 1
	  BGE_QUIRK_ONLY_PHY_1,
d492 1
a492 1
	  BGE_QUIRK_ONLY_PHY_1,
d600 7
a606 2
	 * Several chips with builtin PHYs will incorrectly answer to
	 * other PHY instances than the builtin PHY at id 1.
d608 1
a608 1
	if (phy != 1 && (sc->bge_quirks & BGE_QUIRK_ONLY_PHY_1))
@


1.108
log
@add BCM5903M PCI id and recognize BCM5714 and BCM5715 ASICs.

From Broadcom's Linux driver
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.107 2005/11/29 20:35:58 brad Exp $	*/
a261 1
#define	BGE_QUIRK_FEWER_MBUFS		0x00000080
d369 1
a369 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_FEWER_MBUFS,
d373 1
a373 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_FEWER_MBUFS,
d377 1
a377 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_FEWER_MBUFS,
d381 1
a381 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_FEWER_MBUFS,
d385 1
a385 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_FEWER_MBUFS,
d469 1
a469 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_FEWER_MBUFS,
d1330 1
a1330 1
		if (sc->bge_extram) {
d1333 1
a1333 5
			if ((sc->bge_quirks & BGE_QUIRK_FEWER_MBUFS) == 0)
				CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_LEN, 0x18000);
			else
				CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_LEN, 0x10000);
		} else {
d1336 5
a1340 5
			if ((sc->bge_quirks & BGE_QUIRK_FEWER_MBUFS) == 0)
				CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_LEN, 0x18000);
			else
				CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_LEN, 0x10000);
		}
@


1.107
log
@Put this back in...

Use pci_get_capability() to check if were on a PCI Express card or not.

Tested by deraadt@@, marco@@ and a few end-users who reported issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.106 2005/11/28 20:26:04 brad Exp $	*/
d247 1
d270 5
a274 3
	(BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5705 || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5750 || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5780 || \
d278 4
a281 2
	(BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5750 || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5780 || \
d285 3
a287 1
	(BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5780)
d290 6
a295 4
	(BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5700 || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5701 || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5703 || \
	 BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5780 || \
d441 8
d481 1
a481 1
	{ BGE_ASICREV_BCM5714,
d492 4
@


1.106
log
@back out the last 2 commits to bge(4) for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.103 2005/11/25 03:42:35 brad Exp $	*/
d1804 1
a1804 2
	 * XXX: Broadcom Linux driver.  Not in specs or eratta.
	 * PCI Express.
d1806 4
a1809 10
	if (BGE_IS_575X_PLUS(sc)) {
		u_int32_t v;

		v = pci_conf_read(pc, pa->pa_tag, BGE_PCI_MSI_CAPID);
		if (((v >> 8) & 0xff) == BGE_PCIE_CAPID_REG) {
			v = pci_conf_read(pc, pa->pa_tag, BGE_PCIE_CAPID_REG);
			if ((v & 0xff) == BGE_PCIE_CAPID)
				sc->bge_pcie = 1;
		}
	}
@


1.105
log
@Use pci_get_capability() to check if were on a PCI Express card or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.104 2005/11/27 00:26:36 brad Exp $	*/
a178 6
#define BGE_RESET_START 1
#define BGE_RESET_STOP  2
void bge_sig_pre_reset(struct bge_softc *, int);
void bge_sig_post_reset(struct bge_softc *, int);
void bge_sig_legacy(struct bge_softc *, int);
void bge_stop_fw(struct bge_softc *);
a1266 1
	BGE_SETBIT(sc, BGE_MODE_CTL, BGE_MODECTL_STACKUP);
d1804 2
a1805 1
	 * PCI Express check.
d1807 8
a1814 19
	sc->bge_pcie = 0;
	if (pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_PCIEXPRESS,
	    NULL, NULL) != 0)
		sc->bge_pcie = 1;

	/*
	 * ASF check.
	 */
	sc->bge_asf_mode = 0;
	if (bge_readmem_ind(sc, BGE_SOFTWARE_GENCOMM_SIG) == BGE_MAGIC_NUMBER) {
		if (bge_readmem_ind(sc, BGE_SOFTWARE_GENCOMM_NICCFG) 
		    & BGE_HWCFG_ASF) {
			sc->bge_asf_mode |= ASF_ENABLE;

			if (CSR_READ_4(sc, BGE_MODE_CTL)
			    & BGE_MODECTL_STACKUP)
				sc->bge_asf_mode |= ASF_STACKUP;
			if (BGE_IS_575X_PLUS(sc))
				sc->bge_asf_mode |= ASF_NEW_HANDSHAKE;
d1819 1
a1819 2
	bge_stop_fw(sc);
	bge_sig_pre_reset(sc, BGE_RESET_STOP);
a1820 2
	bge_sig_legacy(sc, BGE_RESET_STOP);
	bge_sig_post_reset(sc, BGE_RESET_STOP);
a2028 64
bge_sig_pre_reset(struct bge_softc *sc, int type)
{
	bge_writemem_ind(sc, BGE_SOFTWARE_GENCOMM, BGE_MAGIC_NUMBER);

	if (sc->bge_asf_mode & ASF_NEW_HANDSHAKE) {
		switch (type) {
		case BGE_RESET_START:
			bge_writemem_ind(sc, BGE_SDI_STATUS, 0x1); /* START */
			break;
		case BGE_RESET_STOP:
			bge_writemem_ind(sc, BGE_SDI_STATUS, 0x2); /* UNLOAD */
			break;
		}
	}
}

void
bge_sig_post_reset(struct bge_softc *sc, int type)
{
	if (sc->bge_asf_mode & ASF_NEW_HANDSHAKE) {
		switch (type) {
		case BGE_RESET_START:
			bge_writemem_ind(sc, BGE_SDI_STATUS, 0x80000001); 
			/* START DONE */
			break;
		case BGE_RESET_STOP:
			bge_writemem_ind(sc, BGE_SDI_STATUS, 0x80000002); 
			break;
		}
	}
}

void
bge_sig_legacy(struct bge_softc *sc, int type)
{
	if (sc->bge_asf_mode) {
		switch (type) {
		case BGE_RESET_START:
			bge_writemem_ind(sc, BGE_SDI_STATUS, 0x1); /* START */
			break;
		case BGE_RESET_STOP:
			bge_writemem_ind(sc, BGE_SDI_STATUS, 0x2); /* UNLOAD */
			break;
		}
	}
}

void
bge_stop_fw(struct bge_softc *sc)
{
	int i;

	if (sc->bge_asf_mode) {
		bge_writemem_ind(sc, BGE_SOFTWARE_GENCOMM_FW, BGE_FW_PAUSE);

		for (i = 0; i < 100; i++ ) {
			if (!(CSR_READ_4(sc, BGE_CPU_EVENT) & (1 << 14)))
				break;
			DELAY(10);
		}
	}
}

void
d2089 6
a2136 2
	if (sc->bge_asf_mode & ASF_STACKUP)
		BGE_SETBIT(sc, BGE_MODE_CTL, BGE_MODECTL_STACKUP);
a2918 3

	bge_stop_fw(sc);
	bge_sig_pre_reset(sc, BGE_RESET_START);
a2919 3
	bge_sig_legacy(sc, BGE_RESET_START);
	bge_sig_post_reset(sc, BGE_RESET_START);

d3304 1
a3304 9
	bge_stop_fw(sc);
	bge_sig_pre_reset(sc, BGE_RESET_STOP);
	bge_reset(sc);
	bge_sig_legacy(sc, BGE_RESET_STOP);
	bge_sig_post_reset(sc, BGE_RESET_STOP);
	if (sc->bge_asf_mode & ASF_STACKUP)
		BGE_SETBIT(sc, BGE_MODE_CTL, BGE_MODECTL_STACKUP);
	else
		BGE_CLRBIT(sc, BGE_MODE_CTL, BGE_MODECTL_STACKUP);
@


1.104
log
@add initial support for  ASF.
this should allow IPMI BMC pass-through to work once the OS is running.

From Doug Ambrisko on the FreeBSD net list. Based on the Linux tg3 driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.103 2005/11/25 03:42:35 brad Exp $	*/
d1811 1
a1811 2
	 * XXX: Broadcom Linux driver.  Not in specs or eratta.
	 * PCI Express.
d1813 4
a1816 10
	if (BGE_IS_575X_PLUS(sc)) {
		u_int32_t v;

		v = pci_conf_read(pc, pa->pa_tag, BGE_PCI_MSI_CAPID);
		if (((v >> 8) & 0xff) == BGE_PCIE_CAPID_REG) {
			v = pci_conf_read(pc, pa->pa_tag, BGE_PCIE_CAPID_REG);
			if ((v & 0xff) == BGE_PCIE_CAPID)
				sc->bge_pcie = 1;
		}
	}
d1818 3
@


1.103
log
@fix BCM5714 PCI id name and add 5714S, 5715 and 5715S.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.102 2005/11/25 03:02:14 brad Exp $	*/
d179 6
d1273 1
d1825 14
d1840 2
a1841 1
	DPRINTFN(5, ("bge_reset\n"));
d1843 2
d2053 64
a2176 6
	 * Prevent PXE restart: write a magic number to the
	 * general communications memory at 0xB50.
	 */
	bge_writemem_ind(sc, BGE_SOFTWARE_GENCOMM, BGE_MAGIC_NUMBER);

	/*
d2219 2
d3003 3
d3007 3
d3394 9
a3402 1
	BGE_CLRBIT(sc, BGE_MODE_CTL, BGE_MODECTL_STACKUP);
@


1.102
log
@Use BGE_IS_5705_OR_BEYOND macro to check for the existence or non-existence
of 5705 or derived ASICs and remove the BGE_QUIRK_5705_CORE flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.101 2005/11/25 02:08:54 brad Exp $	*/
d223 4
a226 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5714C },
@


1.101
log
@remove prototype for a non-existent function bge_free_jumbo_mem.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.100 2005/11/25 02:05:24 brad Exp $	*/
d258 1
a258 2
#define	BGE_QUIRK_5705_CORE		0x00000080
#define	BGE_QUIRK_FEWER_MBUFS		0x00000100
d378 1
a378 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
d382 1
a382 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
d386 1
a386 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
d390 1
a390 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
d394 1
a394 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
d398 1
a398 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
d402 1
a402 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
d406 1
a406 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
d410 1
a410 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
d414 1
a414 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
d418 1
a418 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
d422 1
a422 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
d426 1
a426 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
d454 1
a454 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
d458 1
a458 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
d462 1
a462 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
d466 1
a466 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
d470 1
a470 1
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
d1306 1
a1306 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0) {
d1331 1
a1331 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0) {
d1346 1
a1346 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0) {
d1384 3
a1386 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0)
a1388 2
	else
		rcb->bge_maxlen_flags = BGE_RCB_MAXLEN_FLAGS(512, 0);
d1467 1
a1467 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0)
d1551 1
a1551 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0) {
d1559 1
a1559 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0) {
d1588 1
a1588 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0)
d1610 1
a1610 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0)
d1631 1
a1631 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0)
d1901 3
a1903 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0)
a1904 2
	else
		sc->bge_return_ring_cnt = BGE_RETURN_RING_CNT_5705;
d2082 1
a2082 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0)
d2496 3
a2498 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0)
a2499 2
	else
		bge_stats_update_regs(sc);
d3259 1
a3259 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0)
d3273 1
a3273 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0)
d3283 1
a3283 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0)
d3289 1
a3289 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0) {
@


1.100
log
@Use BGE_IS_JUMBO_CAPABLE in one more spot.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.99 2005/11/25 01:21:44 brad Exp $	*/
a156 1
void bge_free_jumbo_mem(struct bge_softc *);
@


1.99
log
@use 5780 here instead of 5714.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.98 2005/11/25 00:37:59 brad Exp $	*/
d3309 1
a3309 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0)
@


1.98
log
@don't bother setting error in bge_attach() when its not actually
being used for anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.97 2005/11/25 00:14:59 brad Exp $	*/
d1249 1
a1249 1
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714 ||
@


1.97
log
@Use BGE_IS_575X_PLUS macro when checking whether to use the PCI Express test or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.96 2005/11/25 00:09:05 brad Exp $	*/
a1724 1
	int			error = 0;
a1822 1
		error = ENXIO;
a1840 1
		error = ENXIO;
a1890 1
			error = ENXIO;
@


1.96
log
@Use BGE_IS_JUMBO_CAPABLE macro to figure out whether we
want Jumbos or not. Instead of just assuming that all 5705
derived cores do not support Jumbos. All of Broadcom's new
Gig chips do not support Jumbos with the exception of the
BCM5714 found embedded in the ServerWorks HT-2000 chipset
using the BCM5780 ASIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.95 2005/11/24 23:48:29 brad Exp $	*/
d1805 1
a1805 1
	 * PCI-Express?
d1807 1
a1807 3
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5750 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5752) {
d2052 1
a2052 1
		if (CSR_READ_4(sc, 0x7e2c) == 0x60)	/* PCIE 1.0 */
d2055 1
a2055 1
			/* Prevent PCIE link training during global reset */
d2075 1
a2075 1
		/* Set PCIE max payload size and clear error status. */
@


1.95
log
@add a few macros allowing selection of certain generations of
the Broadcom ASICs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.94 2005/11/24 12:25:07 fgsch Exp $	*/
d50 1
a50 1
 * SSRAM. The BCM5700 supports TCP, UDP and IP checksum offload, jumbo
d678 1
a678 1
 * Memory management for jumbo frames.
d773 1
a773 1
 * Allocate a jumbo buffer.
d791 1
a791 1
 * Release a jumbo buffer.
d890 2
a891 2
 * Initialize a jumbo receive ring descriptor. This allocates
 * a jumbo buffer from the pool managed internally by the driver.
d907 1
a907 1
		/* Allocate the jumbo buffer */
d1401 1
a1401 1
	 * Initialize the jumbo RX ring control block
d1407 1
a1407 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0) {
d1891 1
a1891 2
	 * Try to allocate memory for jumbo buffers.
	 * The 5705 does not appear to support jumbo frames.
d1893 1
a1893 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0) {
a2009 1
	DPRINTFN(5, ("if_attach\n"));
a2010 1
	DPRINTFN(5, ("ether_ifattach\n"));
d2012 1
a2012 1
	DPRINTFN(5, ("timeout_set\n"));
d2171 1
a2171 1
 * 1) the frame is from the jumbo receive ring
d2940 1
a2940 1
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0)
d2986 2
a2987 2
	/* Init jumbo RX ring. */
	if ((sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0)
a3142 1
		/* Disallow jumbo frames on 5705. */
d3144 2
a3145 2
		    (((sc->bge_quirks & BGE_QUIRK_5705_CORE) != 0) &&
		    ifr->ifr_mtu > ETHERMTU) || ifr->ifr_mtu > ETHERMTU_JUMBO)
@


1.94
log
@don't redefine BGE_PCIMISCCTL_ENDIAN_WORDSWAP and lower the delay while
waiting for the firmware. tested and ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.93 2005/11/19 23:04:48 brad Exp $	*/
d265 23
@


1.93
log
@Correct a performance bug from Bill Paul's original FreeBSD bge(4) driver:

Each call to the FreeBSD bge_start() routine the transmit producer
pointer index from the chip mailbox register BGE_MBX_TX_HOST_PROD0_LO.
The local copy of that value is then updated by bge_encap() as
bge_encap() encapsulates packets in the Tx ring. If bge_encap()
succeds in encpuslating one or more packets, bge_start() tells the
chip to start sending the newly-encinitiates writes the new value back
to the chip mailbox register.

However, comparison of the Linux drivers (Broadcom-supplied and
open-source tg3.c) and to the OpenSolaris driver confirms that
register BGE_MBX_TX_HOST_PROD0_LO is write-only to software.
Thus, we can just keep a copy in the softc, and eliminate the
(expensive) PCI register write on each call to bge_start().

From jonathan NetBSD

tested by krw@@, sturm@@ and I on a few different bge NICs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.92 2005/11/14 13:11:40 mickey Exp $	*/
d2028 1
a2028 1
	    BGE_HIF_SWAP_OPTIONS|BGE_PCIMISCCTL_PCISTATE_RW);
d2064 1
a2064 1
	    BGE_HIF_SWAP_OPTIONS|BGE_PCIMISCCTL_PCISTATE_RW);
d2089 1
a2089 1
		DELAY(1000);
@


1.92
log
@bus_size_t is a more proper type for a register offset [against bh]
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.91 2005/10/21 22:27:07 brad Exp $	*/
d1061 4
a1064 1
	CSR_WRITE_4(sc, BGE_MBX_TX_HOST_PROD0_LO, 0);
d1066 1
a1066 1
		CSR_WRITE_4(sc, BGE_MBX_TX_HOST_PROD0_LO, 0);
d1068 1
d2812 1
a2812 1
	u_int32_t prodidx = 0;
d2820 1
a2820 1
	prodidx = CSR_READ_4(sc, BGE_MBX_TX_HOST_PROD0_LO);
d2876 2
@


1.91
log
@tidy up dmesg printing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.90 2005/10/14 03:34:09 brad Exp $	*/
d144 1
a144 1
void bge_stop_block(struct bge_softc *, bus_addr_t, uint32_t);
d3204 1
a3204 1
bge_stop_block(struct bge_softc *sc, bus_addr_t reg, uint32_t bit)
@


1.90
log
@only print warning message in bge_stop_block() if debug is enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.89 2005/10/14 03:29:12 brad Exp $	*/
d1698 1
a1698 1
	int			unit, error = 0;
d1798 1
a1798 2
		printf("%s: chip initialization failed\n",
		    sc->bge_dev.dv_xname);
d1817 1
a1817 1
		printf("bge%d: failed to read station address\n", unit);
d1825 1
a1825 1
	printf(" address %s\n",
d1833 1
a1833 1
		printf("%s: can't alloc rx buffers\n", sc->bge_dev.dv_xname);
d1840 2
a1841 2
		printf("%s: can't map dma buffers (%d bytes)\n",
		    sc->bge_dev.dv_xname, sizeof(struct bge_ring_data));
d1848 1
a1848 1
		printf("%s: can't create dma map\n", sc->bge_dev.dv_xname);
d1869 1
a1869 2
			printf("%s: jumbo buffer allocation failed\n",
			    sc->bge_dev.dv_xname);
@


1.89
log
@sprinkle some ANSI and KNF and remove an empty useless function.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.88 2005/10/14 01:38:09 brad Exp $	*/
d3218 2
a3219 2
	printf("%s: block failed to stop: reg 0x%lx, bit 0x%08x\n",
	    sc->bge_dev.dv_xname, (u_long) reg, bit);
@


1.88
log
@shuffle these structs up to the top.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.87 2005/10/10 00:10:29 brad Exp $	*/
a155 1
void bge_handle_events(struct bge_softc *);
d458 1
a458 3
bge_readmem_ind(sc, off)
	struct bge_softc *sc;
	int off;
d467 1
a467 3
bge_writemem_ind(sc, off, val)
	struct bge_softc *sc;
	int off, val;
d476 1
a476 3
bge_writereg_ind(sc, off, val)
	struct bge_softc *sc;
	int off, val;
d491 1
a491 4
bge_eeprom_getbyte(sc, addr, dest)
	struct bge_softc *sc;
	int addr;
	u_int8_t *dest;
d519 1
a519 1
		return(0);
d527 1
a527 1
	return(0);
d534 1
a534 5
bge_read_eeprom(sc, dest, off, cnt)
	struct bge_softc *sc;
	caddr_t dest;
	int off;
	int cnt;
d546 1
a546 1
	return(err ? 1 : 0);
d550 1
a550 3
bge_miibus_readreg(dev, phy, reg)
	struct device *dev;
	int phy, reg;
d561 1
a561 1
		return(0);
d595 1
a595 1
		return(0);
d597 1
a597 1
	return(val & 0xFFFF);
d601 1
a601 3
bge_miibus_writereg(dev, phy, reg, val)
	struct device *dev;
	int phy, reg, val;
d635 1
a635 2
bge_miibus_statchg(dev)
	struct device *dev;
a654 11
 * Handle events that have triggered interrupts.
 */
void
bge_handle_events(sc)
	struct bge_softc		*sc;
{

	return;
}

/*
d659 1
a659 2
bge_alloc_jumbo_mem(sc)
	struct bge_softc		*sc;
d753 1
a753 2
bge_jalloc(sc)
	struct bge_softc		*sc;
d764 1
a764 1
	return(sc->bge_cdata.bge_jslots[entry->slot]);
d771 1
a771 4
bge_jfree(buf, size, arg)
	caddr_t		buf;
	u_int		size;
	void		*arg;
d804 2
a805 5
bge_newbuf_std(sc, i, m, dmamap)
	struct bge_softc	*sc;
	int			i;
	struct mbuf		*m;
	bus_dmamap_t		dmamap;
d815 1
a815 1
			return error;
d823 1
a823 1
			return(ENOBUFS);
d828 1
a828 1
			return(ENOBUFS);
d836 1
a836 1
			return(ENOBUFS);
d863 1
a863 1
	return(0);
d871 1
a871 4
bge_newbuf_jumbo(sc, i, m)
	struct bge_softc *sc;
	int i;
	struct mbuf *m;
d882 1
a882 1
			return(ENOBUFS);
d888 1
a888 1
			return(ENOBUFS);
d921 1
a921 1
	return(0);
d931 1
a931 2
bge_init_rx_ring_std(sc)
	struct bge_softc *sc;
d936 1
a936 1
		return 0;
d940 1
a940 1
			return(ENOBUFS);
d948 1
a948 1
	return(0);
d952 1
a952 2
bge_free_rx_ring_std(sc)
	struct bge_softc *sc;
d974 1
a974 2
bge_init_rx_ring_jumbo(sc)
	struct bge_softc *sc;
d980 1
a980 1
		return 0;
d984 1
a984 1
			return(ENOBUFS);
d996 1
a996 1
	return(0);
d1000 1
a1000 2
bge_free_rx_ring_jumbo(sc)
	struct bge_softc *sc;
d1020 1
a1020 2
bge_free_tx_ring(sc)
	struct bge_softc *sc;
d1050 1
a1050 2
bge_init_tx_ring(sc)
	struct bge_softc *sc;
d1057 1
a1057 1
		return 0;
d1074 1
a1074 1
			return(ENOBUFS);
d1090 1
a1090 1
	return(0);
d1094 1
a1094 2
bge_setmulti(sc)
	struct bge_softc *sc;
d1136 1
a1136 2
bge_chipinit(sc)
	struct bge_softc *sc;
d1158 1
a1158 1
		return(ENODEV);
d1261 1
a1261 1
	return(0);
d1265 1
a1265 2
bge_blockinit(sc)
	struct bge_softc *sc;
d1335 1
a1335 1
			return(ENXIO);
d1353 1
a1353 1
		return(ENXIO);
d1518 1
a1518 1
		return(ENXIO);
d1646 1
a1646 1
	return(0);
d1676 1
a1676 4
bge_probe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d1683 1
a1683 3
bge_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
a1991 1

d2012 1
a2012 2
bge_reset(sc)
	struct bge_softc *sc;
d2154 1
a2154 2
bge_rxeof(sc)
	struct bge_softc *sc;
d2297 1
a2297 2
bge_txeof(sc)
	struct bge_softc *sc;
d2366 1
a2366 2
bge_intr(xsc)
	void *xsc;
d2378 1
a2378 1
		return(0);
a2461 2
	bge_handle_events(sc);

d2472 1
a2472 2
bge_tick(xsc)
	void *xsc;
d2521 1
a2521 2
bge_stats_update_regs(sc)
	struct bge_softc *sc;
a2541 2

	return;
d2545 1
a2545 2
bge_stats_update(sc)
	struct bge_softc *sc;
d2690 1
a2690 1
	return 0;
d2698 1
a2698 4
bge_encap(sc, m_head, txidx)
	struct bge_softc *sc;
	struct mbuf *m_head;
	u_int32_t *txidx;
d2753 1
a2753 1
		return(ENOBUFS);
d2775 1
a2775 1
			return(ENOBUFS);
d2788 1
a2788 1
		return(ENOBUFS);
d2798 1
a2798 1
	return(0);
d2806 1
a2806 2
bge_start(ifp)
	struct ifnet *ifp;
d2882 1
a2882 2
bge_init(xsc)
	void *xsc;
d3002 1
a3002 2
bge_ifmedia_upd(ifp)
	struct ifnet *ifp;
d3011 1
a3011 1
			return(EINVAL);
d3042 1
a3042 1
			return(EINVAL);
d3044 1
a3044 1
		return(0);
d3056 1
a3056 1
	return(0);
d3063 1
a3063 3
bge_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
d3088 1
a3088 4
bge_ioctl(ifp, command, data)
	struct ifnet *ifp;
	u_long command;
	caddr_t data;
d3187 1
a3187 1
	return(error);
d3191 1
a3191 2
bge_watchdog(ifp)
	struct ifnet *ifp;
d3227 1
a3227 2
bge_stop(sc)
	struct bge_softc *sc;
d3325 1
a3325 2
bge_shutdown(xsc)
	void *xsc;
@


1.87
log
@splimp -> splnet
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.86 2005/10/09 23:41:55 brad Exp $	*/
d122 9
d267 191
a1698 191
static const struct bge_revision {
	uint32_t		br_chipid;
	uint32_t		br_quirks;
	const char		*br_name;
} bge_revisions[] = {
	{ BGE_CHIPID_BCM5700_A0,
	  BGE_QUIRK_LINK_STATE_BROKEN,
	  "BCM5700 A0" },

	{ BGE_CHIPID_BCM5700_A1,
	  BGE_QUIRK_LINK_STATE_BROKEN,
	  "BCM5700 A1" },

	{ BGE_CHIPID_BCM5700_B0,
	  BGE_QUIRK_LINK_STATE_BROKEN|BGE_QUIRK_CSUM_BROKEN|BGE_QUIRK_5700_COMMON,
	  "BCM5700 B0" },

	{ BGE_CHIPID_BCM5700_B1,
	  BGE_QUIRK_LINK_STATE_BROKEN|BGE_QUIRK_5700_COMMON,
	  "BCM5700 B1" },

	{ BGE_CHIPID_BCM5700_B2,
	  BGE_QUIRK_LINK_STATE_BROKEN|BGE_QUIRK_5700_COMMON,
	  "BCM5700 B2" },

	{ BGE_CHIPID_BCM5700_B3,
	  BGE_QUIRK_LINK_STATE_BROKEN|BGE_QUIRK_5700_COMMON,
	  "BCM5700 B3" },

	/* This is treated like a BCM5700 Bx */
	{ BGE_CHIPID_BCM5700_ALTIMA,
	  BGE_QUIRK_LINK_STATE_BROKEN|BGE_QUIRK_5700_COMMON,
	  "BCM5700 Altima" },

	{ BGE_CHIPID_BCM5700_C0,
	  0,
	  "BCM5700 C0" },

	{ BGE_CHIPID_BCM5701_A0,
	  BGE_QUIRK_PCIX_DMA_ALIGN_BUG,
	  "BCM5701 A0" },

	{ BGE_CHIPID_BCM5701_B0,
	  BGE_QUIRK_PCIX_DMA_ALIGN_BUG,
	  "BCM5701 B0" },

	{ BGE_CHIPID_BCM5701_B2,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_PCIX_DMA_ALIGN_BUG,
	  "BCM5701 B2" },

	{ BGE_CHIPID_BCM5701_B5,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_PCIX_DMA_ALIGN_BUG,
	  "BCM5701 B5" },

	{ BGE_CHIPID_BCM5703_A0,
	  0,
	  "BCM5703 A0" },

	{ BGE_CHIPID_BCM5703_A1,
	  0,
	  "BCM5703 A1" },

	{ BGE_CHIPID_BCM5703_A2,
	  BGE_QUIRK_ONLY_PHY_1,
	  "BCM5703 A2" },

	{ BGE_CHIPID_BCM5703_A3,
	  BGE_QUIRK_ONLY_PHY_1,
	  "BCM5703 A3" },

	{ BGE_CHIPID_BCM5704_A0,
  	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_FEWER_MBUFS,
	  "BCM5704 A0" },

	{ BGE_CHIPID_BCM5704_A1,
  	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_FEWER_MBUFS,
	  "BCM5704 A1" },

	{ BGE_CHIPID_BCM5704_A2,
  	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_FEWER_MBUFS,
	  "BCM5704 A2" },

	{ BGE_CHIPID_BCM5704_A3,
  	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_FEWER_MBUFS,
	  "BCM5704 A3" },

	{ BGE_CHIPID_BCM5704_B0,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_FEWER_MBUFS,
	  "BCM5704 B0" },

	{ BGE_CHIPID_BCM5705_A0,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "BCM5705 A0" },

	{ BGE_CHIPID_BCM5705_A1,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "BCM5705 A1" },

	{ BGE_CHIPID_BCM5705_A2,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "BCM5705 A2" },

	{ BGE_CHIPID_BCM5705_A3,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "BCM5705 A3" },

	{ BGE_CHIPID_BCM5750_A0,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "BCM5750 A0" },

	{ BGE_CHIPID_BCM5750_A1,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "BCM5750 A1" },

	{ BGE_CHIPID_BCM5750_A3,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "BCM5750 A3" },

	{ BGE_CHIPID_BCM5750_B0,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "BCM5750 B0" },

	{ BGE_CHIPID_BCM5750_B1,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "BCM5750 B1" },

	{ BGE_CHIPID_BCM5750_C0,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "BCM5750 C0" },

	{ BGE_CHIPID_BCM5714_A0,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "BCM5714 A0" },

	{ BGE_CHIPID_BCM5752_A0,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "BCM5752 A0" },

	{ BGE_CHIPID_BCM5752_A1,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "BCM5752 A1" },

	{ 0, 0, NULL }
};

/*
 * Some defaults for major revisions, so that newer steppings
 * that we don't know about have a shot at working.
 */
static const struct bge_revision bge_majorrevs[] = {
	{ BGE_ASICREV_BCM5700,
	  BGE_QUIRK_LINK_STATE_BROKEN,
	  "unknown BCM5700" },

	{ BGE_ASICREV_BCM5701,
	  BGE_QUIRK_PCIX_DMA_ALIGN_BUG,
	  "unknown BCM5701" },

	{ BGE_ASICREV_BCM5703,
	  0,
	  "unknown BCM5703" },

	{ BGE_ASICREV_BCM5704,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_FEWER_MBUFS,
	  "unknown BCM5704" },

	{ BGE_ASICREV_BCM5705,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "unknown BCM5705" },

	{ BGE_ASICREV_BCM5750,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "unknown BCM5750" },

	{ BGE_ASICREV_BCM5714,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "unknown BCM5714" },

	{ BGE_ASICREV_BCM5752,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "unknown BCM5752" },

	{ BGE_ASICREV_BCM5780,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "unknown BCM5780" },

	{ 0,
	  0,
	  NULL }
};

a3412 8

struct cfattach bge_ca = {
	sizeof(struct bge_softc), bge_probe, bge_attach
};

struct cfdriver bge_cd = {
	0, "bge", DV_IFNET
};
@


1.86
log
@BGE_RSLOTS is only used in one spot, BGE_TX_RING_CNT
should be used instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.85 2005/10/09 20:55:41 brad Exp $	*/
d2534 1
a2534 1
	s = splimp();
d2952 1
a2952 1
	s = splimp();
d3165 1
a3165 1
	s = splimp();
@


1.85
log
@- move bus_dmamap_load_mbuf() to where it should be in bge_newbuf_std()
- add comments mentioning where we're re-using mbufs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.84 2005/10/06 06:01:05 brad Exp $	*/
d917 1
a917 1
	for (i = 0; i < BGE_RSLOTS; i++) {
@


1.84
log
@change "pcistate failed to revert" test message to a debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.83 2005/10/06 03:39:16 brad Exp $	*/
d669 6
d676 5
d684 2
a685 10
	}

	if (!sc->bge_rx_alignment_bug)
		m_adj(m_new, ETHER_ALIGN);

	if (bus_dmamap_load_mbuf(sc->bge_dmatag, dmamap, m_new,
	    BUS_DMA_READ|BUS_DMA_NOWAIT)) {
		if (m == NULL)
			m_freem(m_new);
		return(ENOBUFS);
d736 5
@


1.83
log
@add Apple BCM5701
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.82 2005/09/08 19:19:50 brad Exp $	*/
d2154 2
a2155 2
		printf("%s: pcistate failed to revert\n",
		    sc->bge_dev.dv_xname);
@


1.82
log
@- Removes spl durring attach
- Use pci_mapreg_map()
- Ensure bge_attach() always cleans up properly upon failure

ok krw@@ sturm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.81 2005/08/30 03:18:30 brad Exp $	*/
d197 2
@


1.81
log
@- add BCM5780 PCI ids
- recognize BCM5704 B0
- recognize BCM5780 which is supposedly part of the BCM5714 family
according to the Linux driver but there is a BCM5714 core too. huh?

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.80 2005/08/27 14:12:36 brad Exp $	*/
d1725 1
d1728 1
a1728 2
	bus_addr_t		iobase;
	bus_size_t		iosize;
d1730 1
a1730 1
	int			s, rseg;
a1732 1
	u_int32_t		pm_ctl;
a1736 2
	s = splimp();

d1742 12
a1753 3
	DPRINTFN(5, ("pci_mem_find\n"));
	if (pci_mem_find(pc, pa->pa_tag, BGE_PCI_BAR0, &iobase,
			 &iosize, NULL)) {
d1755 1
a1755 1
		goto fail;
a1757 8
	DPRINTFN(5, ("bus_space_map\n"));
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->bge_bhandle)) {
		printf(": can't map mem space\n");
		goto fail;
	}

	sc->bge_btag = pa->pa_memt;

d1761 1
a1761 1
		goto fail;
a1769 1

d1775 1
a1775 1
		goto fail;
d1837 1
a1837 1
		goto fail;
d1856 1
a1856 1
		goto fail;
d1871 1
a1871 1
		goto fail;
d1879 1
a1879 2
		bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
		goto fail;
d1886 1
a1886 4
		bus_dmamem_unmap(sc->bge_dmatag, kva,
				 sizeof(struct bge_ring_data));
		bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
		goto fail;
d1892 1
a1892 5
		bus_dmamap_destroy(sc->bge_dmatag, sc->bge_ring_map);
		bus_dmamem_unmap(sc->bge_dmatag, kva,
				 sizeof(struct bge_ring_data));
		bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
		goto fail;
d1909 1
a1909 1
			goto fail;
d2028 18
a2045 2
fail:
	splx(s);
d2053 2
a2054 1
	u_int32_t cachesize, command, pcistate, new_pcistate, reset;
d2087 1
a2087 1
			uint32_t v;
@


1.80
log
@recognize 5752 A1 ASIC rev.

Noticed by niklas@@ on some newer hardware

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.79 2005/08/09 04:10:11 mickey Exp $	*/
d227 2
d1575 4
d1670 4
@


1.79
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.78 2005/07/25 00:49:43 brad Exp $	*/
d1620 4
@


1.78
log
@don't bother with printf in *_jalloc()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.77 2005/07/20 01:22:25 brad Exp $	*/
a1718 1
	u_int32_t		command;
a1730 13
	DPRINTFN(5, ("Map control/status regs\n"));
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);

	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf("%s: failed to enable memory mapping!\n",
		    sc->bge_dev.dv_xname);
		error = ENXIO;
		goto fail;
	}

@


1.77
log
@remove some unused code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.76 2005/07/16 17:37:18 brad Exp $	*/
d587 2
a588 5
	if (entry == NULL) {
		DPRINTFN(1,("%s: no free jumbo buffers\n",
		    sc->bge_dev.dv_xname));
		return(NULL);
	}
@


1.76
log
@remove braces here too
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.75 2005/07/14 05:54:48 jsg Exp $	*/
a118 2
/* #define BGE_CHECKSUM */

a121 1
void bge_release_resources(struct bge_softc *);
a163 6
#ifdef notdef
u_int8_t bge_vpd_readbyte(struct bge_softc *, int);
void bge_vpd_read_res(struct bge_softc *, struct vpd_res *, int);
void bge_vpd_read(struct bge_softc *);
#endif

a165 3
#ifdef notdef
u_int32_t bge_readreg_ind(struct bge_softc *, int);
#endif
a275 13
#ifdef notdef
u_int32_t
bge_readreg_ind(sc, off)
	struct bge_softc *sc;
	int off;
{
	struct pci_attach_args	*pa = &(sc->bge_pa);

	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_REG_BASEADDR, off);
	return(pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_REG_DATA));
}
#endif

a286 90
#ifdef notdef
u_int8_t
bge_vpd_readbyte(sc, addr)
	struct bge_softc *sc;
	int addr;
{
	int i;
	u_int32_t val;
	struct pci_attach_args	*pa = &(sc->bge_pa);

	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_VPD_ADDR, addr);
	for (i = 0; i < BGE_TIMEOUT * 10; i++) {
		DELAY(10);
		if (pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_VPD_ADDR) &
		    BGE_VPD_FLAG)
			break;
	}

	if (i == BGE_TIMEOUT * 10) {
		printf("%s: VPD read timed out\n", sc->bge_dev.dv_xname);
		return(0);
	}

	val = pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_VPD_DATA);

	return((val >> ((addr % 4) * 8)) & 0xFF);
}

void
bge_vpd_read_res(sc, res, addr)
	struct bge_softc *sc;
	struct vpd_res *res;
	int addr;
{
	int i;
	u_int8_t *ptr;

	ptr = (u_int8_t *)res;
	for (i = 0; i < sizeof(struct vpd_res); i++)
		ptr[i] = bge_vpd_readbyte(sc, i + addr);
}

void
bge_vpd_read(sc)
	struct bge_softc *sc;
{
	int pos = 0, i;
	struct vpd_res res;

	if (sc->bge_vpd_prodname != NULL)
		free(sc->bge_vpd_prodname, M_DEVBUF);
	if (sc->bge_vpd_readonly != NULL)
		free(sc->bge_vpd_readonly, M_DEVBUF);
	sc->bge_vpd_prodname = NULL;
	sc->bge_vpd_readonly = NULL;

	bge_vpd_read_res(sc, &res, pos);

	if (res.vr_id != VPD_RES_ID) {
		printf("%s: bad VPD resource id: expected %x got %x\n",
			sc->bge_dev.dv_xname, VPD_RES_ID, res.vr_id);
		return;
	}

	pos += sizeof(res);
	sc->bge_vpd_prodname = malloc(res.vr_len + 1, M_DEVBUF, M_NOWAIT);
	if (sc->bge_vpd_prodname == NULL)
		panic("bge_vpd_read");
	for (i = 0; i < res.vr_len; i++)
		sc->bge_vpd_prodname[i] = bge_vpd_readbyte(sc, i + pos);
	sc->bge_vpd_prodname[i] = '\0';
	pos += i;

	bge_vpd_read_res(sc, &res, pos);

	if (res.vr_id != VPD_RES_READ) {
		printf("%s: bad VPD resource id: expected %x got %x\n",
		    sc->bge_dev.dv_xname, VPD_RES_READ, res.vr_id);
		return;
	}

	pos += sizeof(res);
	sc->bge_vpd_readonly = malloc(res.vr_len, M_DEVBUF, M_NOWAIT);
	if (sc->bge_vpd_readonly == NULL)
		panic("bge_vpd_read");
	for (i = 0; i < res.vr_len + 1; i++)
		sc->bge_vpd_readonly[i] = bge_vpd_readbyte(sc, i + pos);
}
#endif

a1841 1
		bge_release_resources(sc);
a1860 1
		bge_release_resources(sc);
a2043 11
}

void
bge_release_resources(sc)
	struct bge_softc *sc;
{
	if (sc->bge_vpd_prodname != NULL)
		free(sc->bge_vpd_prodname, M_DEVBUF);

	if (sc->bge_vpd_readonly != NULL)
		free(sc->bge_vpd_readonly, M_DEVBUF);
@


1.75
log
@More bge ids, found in Broadcom's Linux driver. ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.74 2005/07/09 22:22:41 brad Exp $	*/
d833 1
a833 1
		if (m_new == NULL) {
a834 1
		}
@


1.74
log
@remove braces here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.73 2005/07/07 21:28:10 brad Exp $	*/
d234 6
@


1.73
log
@check ETHERMIN and stop calling em_init_locked() from SIOCSIFMTU ioctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.72 2005/07/06 00:56:33 brad Exp $	*/
d768 1
a768 1
		if (m_new == NULL) {
a769 1
		}
@


1.72
log
@allow bge(4) to receive Jumbos by default.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.71 2005/07/02 00:34:29 brad Exp $	*/
d3300 2
a3301 1
		if ((((sc->bge_quirks & BGE_QUIRK_5705_CORE) != 0) &&
@


1.71
log
@add support for PCI-E 5752 core and recognize a few additional
5750 revisions.

Info from the Broadcom Linux driver
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.70 2005/07/01 20:47:50 brad Exp $	*/
a1219 1
	struct ifnet		*ifp = &sc->arpcom.ac_if;
d1259 3
a1261 10
		if (ifp->if_mtu > ETHER_MAX_LEN) {
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x50);
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x20);
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x60);
		} else {
			/* Values from Linux driver... */
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 304);
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 152);
			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 380);
		}
d3090 6
a3095 2
	CSR_WRITE_4(sc, BGE_RX_MTU, ifp->if_mtu +
	    ETHER_HDR_LEN + ETHER_CRC_LEN + ETHER_VLAN_ENCAP_LEN);
d3303 1
a3303 1
		else {
a3304 3
			ifp->if_flags &= ~IFF_RUNNING;
			bge_init(sc);
		}
@


1.70
log
@revert rev 1.59
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.69 2005/06/29 04:25:10 brad Exp $	*/
d1172 1
d1174 1
a1174 1
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5750)
d1634 4
d1719 8
d1731 4
d1739 4
d1779 4
d1941 3
a1943 2
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5750) {
@


1.69
log
@volatile here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.68 2005/06/29 04:03:42 brad Exp $	*/
d3167 17
@


1.68
log
@rev 1.25

* Add workaround for revision Bx bcm5700: chip bugs in decoding
  of PCI register writes may leave the hardware in (partial) powersave state,
  such that writes to "indirect" registers do not work.
  Explicitly force chip into D0 state at attach time.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.67 2005/06/29 03:36:06 brad Exp $	*/
d1218 1
a1218 1
	struct bge_rcb		*rcb;
@


1.67
log
@- sync bus_dma ops and add bus_dmamap_sync()'s

and

rev 1.25

*  bcm5700 chips rev Bx wedge up if given DMA descriptors of
   eight bytes or less. Once hit, only reovery is a watchdog timeout/reset.
   If the offending packet is retransmitted, the chip will wedge again...
   Check for teeny fragments in a Tx request, and either fold the
   teeny chunk residue into an adjacent mbuf, or m_dup the entire buffer.

From NetBSD

Tested on alpha/amd64/macppc by krw@@ and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.66 2005/06/26 06:06:17 brad Exp $	*/
a1816 1
#if 0
a1817 1
#endif
a1877 1
#if 0
a1889 1
#endif
@


1.66
log
@remove unused code in bge_intr()
@
text
@d1 2
a2 1
/*	$OpenBSD: if_bge.c,v 1.65 2005/06/26 03:17:55 brad Exp $	*/
d132 1
d155 1
a155 1
int bge_newbuf_std(struct bge_softc *, int, struct mbuf *);
d533 1
d535 1
a535 1
		DELAY(40);
d599 1
a599 1
	int		i, rseg;
d602 2
d610 2
d616 2
a617 2
		bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
		return (ENOBUFS);
d619 2
d624 2
a625 3
		bus_dmamem_unmap(sc->bge_dmatag, kva, BGE_JMEM);
		bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
		return (ENOBUFS);
d627 2
d632 2
a633 5
		bus_dmamap_destroy(sc->bge_dmatag,
				   sc->bge_cdata.bge_rx_jumbo_map);
		bus_dmamem_unmap(sc->bge_dmatag, kva, BGE_JMEM);
		bus_dmamem_free(sc->bge_dmatag, &seg, rseg);
		return (ENOBUFS);
d635 2
d640 2
a641 2
	LIST_INIT(&sc->bge_jfree_listhead);
	LIST_INIT(&sc->bge_jinuse_listhead);
d654 13
d668 2
a669 1
					  sc->bge_cdata.bge_rx_jumbo_map);
d671 2
a672 1
					   sc->bge_cdata.bge_rx_jumbo_map);
d674 1
d676 3
a678 4
			sc->bge_cdata.bge_jumbo_buf = NULL;
			printf("%s: no memory for jumbo buffer queue!\n",
			    sc->bge_dev.dv_xname);
			return(ENOBUFS);
a679 3
		entry->slot = i;
		LIST_INSERT_HEAD(&sc->bge_jfree_listhead,
				 entry, jpool_entries);
d682 1
a682 1
	return(0);
d694 1
a694 1
	entry = LIST_FIRST(&sc->bge_jfree_listhead);
d702 2
a703 2
	LIST_REMOVE(entry, jpool_entries);
	LIST_INSERT_HEAD(&sc->bge_jinuse_listhead, entry, jpool_entries);
d734 1
a734 1
	entry = LIST_FIRST(&sc->bge_jinuse_listhead);
d738 2
a739 2
	LIST_REMOVE(entry, jpool_entries);
	LIST_INSERT_HEAD(&sc->bge_jfree_listhead, entry, jpool_entries);
d747 1
a747 1
bge_newbuf_std(sc, i, m)
d751 1
d755 10
a764 1
	bus_dmamap_t		rxmap = sc->bge_cdata.bge_rx_std_map[i];
d787 2
a788 2
	if (bus_dmamap_load_mbuf(sc->bge_dmatag, rxmap, m_new,
	    BUS_DMA_NOWAIT)) { 
d790 1
a790 1
			m_freem(m_new); 	
d793 1
a793 1
	
d796 1
a796 1
	BGE_HOSTADDR(r->bge_addr, rxmap->dm_segs[0].ds_addr);
d801 6
d824 1
a824 1
		caddr_t			*buf = NULL;
d858 6
d879 2
a880 5
	for (i = 0; i < BGE_STD_RX_RING_CNT; i++) {
		if (bus_dmamap_create(sc->bge_dmatag, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT, &sc->bge_cdata.bge_rx_std_map[i]))
			return(ENOBUFS);
	}
d883 1
a883 1
		if (bge_newbuf_std(sc, i, NULL) == ENOBUFS)
d890 2
d901 3
d908 2
a909 2
			bus_dmamap_unload(sc->bge_dmatag,
					  sc->bge_cdata.bge_rx_std_map[i]);
d914 2
d923 4
a926 1
	struct bge_rcb *rcb;
d934 1
d951 3
d962 2
d971 1
d973 1
a973 1
	if (sc->bge_rdata->bge_tx_ring == NULL)
d980 3
a982 2
			bus_dmamap_unload(sc->bge_dmatag,
					  sc->bge_cdata.bge_tx_map[i]);
d987 8
d1002 5
a1009 1

d1018 5
a1022 3
	for (i = 0; i < BGE_TX_RING_CNT; i++) {
		if (bus_dmamap_create(sc->bge_dmatag, BGE_JLEN, BGE_NTXSEG,
		    BGE_JLEN, 0, BUS_DMA_NOWAIT, &sc->bge_cdata.bge_tx_map[i]))
d1024 11
d1037 2
a1223 1

d1257 1
a1257 1
	/* new broadcom docs strongly recommend these: */
d1366 5
d1817 3
d1880 15
d2232 1
a2232 1
		DELAY(10);
d2304 4
d2311 23
a2376 2
			bus_dmamap_unload(sc->bge_dmatag,
					  sc->bge_cdata.bge_rx_std_map[rxidx]);
d2378 3
d2383 1
a2383 1
				bge_newbuf_std(sc, sc->bge_std, m);
d2387 1
a2387 1
			    NULL) == ENOBUFS) {
d2389 1
a2389 1
				bge_newbuf_std(sc, sc->bge_std, m);
d2448 5
d2456 23
d2491 2
a2492 2
		if (sc->bge_cdata.bge_tx_chain[idx] != NULL) {
			m_freem(sc->bge_cdata.bge_tx_chain[idx]);
d2494 8
a2501 2
			bus_dmamap_unload(sc->bge_dmatag,
					  sc->bge_cdata.bge_tx_map[idx]);
d2732 117
d2861 2
a2862 1
	bus_dmamap_t		txmap;
d2889 14
d2909 1
a2909 2
	txmap = sc->bge_cdata.bge_tx_map[frag];
	if (bus_dmamap_load_mbuf(sc->bge_dmatag, txmap, m_head,
d2913 1
a2913 1
	for (i = 0; i < txmap->dm_nsegs; i++) {
d2917 2
a2918 2
		BGE_HOSTADDR(f->bge_addr, txmap->dm_segs[i].ds_addr);
		f->bge_len = txmap->dm_segs[i].ds_len;
d2939 6
a2947 7
	/*
	 * Put the dmamap for this transmission at the same array index as the
	 * last descriptor in this chain. That's where bge_txeof() expects to
	 * find it.
	 */
	sc->bge_cdata.bge_tx_map[*txidx] = sc->bge_cdata.bge_tx_map[cur];
	sc->bge_cdata.bge_tx_map[cur] = txmap;
d2950 2
@


1.65
log
@- clear IFF_RUNNING & IFF_OACTIVE in dc_stop() before de-allocating resources.
- remove unused FreeBSD specific code
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.64 2005/06/17 15:15:43 brad Exp $	*/
a2353 2
#ifdef notdef
	/* Avoid this for now -- checking this register is expensive. */
a2354 3
	if (!(CSR_READ_4(sc, BGE_MISC_LOCAL_CTL) & BGE_MLC_INTR_STATE))
		return (0);
#endif
d2356 1
a2356 1
	    BGE_STATFLAG_UPDATED)) /* shared interrupt */
@


1.64
log
@- fix description for BCM5750 A0, A1 -> A0
- recognize BCM5750 B1
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.63 2005/06/15 16:30:34 camield Exp $	*/
a1616 4
	{ BGE_CHIPID_BCM5714_A0,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "BCM5714 A0" },

d1629 4
d1661 4
a1668 4
	{ BGE_ASICREV_BCM5750,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "unknown BCM5750" },

a2046 16

#ifdef fake
	if (sc->bge_intrhand != NULL)
		bus_teardown_intr(dev, sc->bge_irq, sc->bge_intrhand);

	if (sc->bge_irq != NULL)
		bus_release_resource(dev, SYS_RES_IRQ, 0, sc->bge_irq);

	if (sc->bge_res != NULL)
		bus_release_resource(dev, SYS_RES_MEMORY,
		    BGE_PCI_BAR0, sc->bge_res);

	if (sc->bge_rdata != NULL)
		contigfree(sc->bge_rdata,
		    sizeof(struct bge_ring_data), M_DEVBUF);
#endif
d3089 2
a3170 2

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.63
log
@Disable hardware vlan decapsulation.

ok brad henning jason
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.62 2005/06/07 20:39:07 brad Exp $	*/
d1623 1
a1623 1
	  "BCM5750 A1" },
d1628 4
@


1.62
log
@put the whole thing in this time.

add support for the BCM5714.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.60 2005/06/07 17:38:54 brad Exp $	*/
a2216 4
#if NVLAN > 0
		u_int16_t		vlan_tag = 0;
		int			have_tag = 0;
#endif
a2226 7
#if NVLAN > 0
		if (cur_rx->bge_flags & BGE_RXBDFLAG_VLAN_TAG) {
			have_tag = 1;
			vlan_tag = cur_rx->bge_vlan_tag;
		}
#endif

a2308 12

#if NVLAN > 0
		/*
		 * If we received a packet with a vlan tag, pass it
		 * to vlan_input() instead of ether_input().
		 */
		if (have_tag) {
			vlan_input_tag(m, vlan_tag);
			have_tag = vlan_tag = 0;
			continue;
		}
#endif
d2806 3
@


1.61
log
@undo busted diff.  why AGAIN brad????
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.59 2005/05/21 17:24:50 brad Exp $	*/
d224 1
d1087 1
d1617 4
d1657 4
d1809 2
a1810 1
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5750) {
@


1.60
log
@add support for the BCM5714.

From FreeBSD
@
text
@a223 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5714C },
a1085 1
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714 ||
a1614 4
	{ BGE_CHIPID_BCM5714_A0,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "BCM5714 A0" },

a1650 4
	{ BGE_ASICREV_BCM5714,
	  BGE_QUIRK_ONLY_PHY_1|BGE_QUIRK_5705_CORE,
	  "unknown BCM5714" },

d1799 1
a1799 2
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5714 ||
	    BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5750) {
@


1.59
log
@backout part of rev 1.35, which breaks some 5704-based fibre interfaces on
some IBM/Intel blade servers.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.58 2005/04/25 17:55:51 brad Exp $	*/
d224 1
d1087 1
d1617 4
d1657 4
d1809 2
a1810 1
	if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5750) {
@


1.58
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.57 2005/04/04 22:22:07 beck Exp $	*/
a2895 17
			/*
			 * The BCM5704 ASIC appears to have a special
			 * mechanism for programming the autoneg
			 * advertisement registers in TBI mode.
			 */
			if (BGE_ASICREV(sc->bge_chipid) == BGE_ASICREV_BCM5704) {
				uint32_t sgdig;
				CSR_WRITE_4(sc, BGE_TX_TBI_AUTONEG, 0);
				sgdig = CSR_READ_4(sc, BGE_SGDIG_CFG);
				sgdig |= BGE_SGDIGCFG_AUTO|
				    BGE_SGDIGCFG_PAUSE_CAP|
				    BGE_SGDIGCFG_ASYM_PAUSE;
				CSR_WRITE_4(sc, BGE_SGDIG_CFG,
				    sgdig|BGE_SGDIGCFG_SEND);
				DELAY(5);
				CSR_WRITE_4(sc, BGE_SGDIG_CFG, sgdig);
			}
@


1.57
log
@Fix interrupt sharing on bge, by checking the same way the linux
driver does. ok deraadt@@, testing and ok krw@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.56 2005/04/01 02:49:03 brad Exp $	*/
d2306 1
a2306 1
		m->m_pkthdr.csum = sumflags;
d2617 2
a2618 2
	if (m_head->m_pkthdr.csum) {
		if (m_head->m_pkthdr.csum & M_IPV4_CSUM_OUT)
d2620 1
a2620 1
		if (m_head->m_pkthdr.csum & (M_TCPV4_CSUM_OUT |
@


1.56
log
@0 -> prodidx. breakage for 5700 Bx workaround introduced in rev 1.21

Noticed/tested by aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.55 2005/03/27 16:14:43 krw Exp $	*/
d2384 4
@


1.55
log
@Fix possible double alignment, and a memory leak in error path. Mostly
from FreeBSD.

ok brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.54 2005/03/07 18:59:11 brad Exp $	*/
d940 1
a940 1
	if (sc->bge_quirks & BGE_QUIRK_PRODUCER_BUG)	/* 5700 b2 errata */
d944 1
a944 1
	if (sc->bge_quirks & BGE_QUIRK_PRODUCER_BUG)	/* 5700 b2 errata */
d2755 2
a2756 2
	if (sc->bge_quirks & BGE_QUIRK_PRODUCER_BUG)	/* 5700 b2 errata */
		CSR_WRITE_4(sc, BGE_MBX_TX_HOST_PROD0_LO, 0);
@


1.54
log
@print ASIC ID in hex too incase only the "superclass" of the ASIC is
recognized.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.53 2005/03/07 13:31:40 krw Exp $	*/
a751 3
	if (bus_dmamap_load_mbuf(sc->bge_dmatag, rxmap, m_new, BUS_DMA_NOWAIT))
		return(ENOBUFS);

d754 8
d764 1
a764 2
	BGE_HOSTADDR(r->bge_addr, rxmap->dm_segs[0].ds_addr +
	    (sc->bge_rx_alignment_bug ? 0 : ETHER_ALIGN));
@


1.53
log
@Enable basic big-endian operation. i.e. now works on some big-endian
machines (macppc) but not others (sparc64). No-op for little-endian
architectures.

Diff from NetBSD with tweaks by drahn@@.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.52 2005/03/04 00:55:44 krw Exp $	*/
d1782 1
a1782 1
		printf("unknown ASIC 0x%08x", sc->bge_chipid);
d1785 2
a1786 2
		printf("%s", br->br_name);
		sc->bge_quirks = br->br_quirks;
@


1.52
log
@Put the dmamap for a transmission at the correct array index. Fixes a
crash on sparc64. From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.51 2005/01/17 03:00:27 brad Exp $	*/
a1008 1
#if BYTE_ORDER == BIG_ENDIAN
d1010 1
a1010 5
	    BGE_BIGENDIAN_INIT);
#else
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_MISC_CTL,
	    BGE_LITTLEENDIAN_INIT);
#endif
d1091 1
a1091 2
	CSR_WRITE_4(sc, BGE_MODE_CTL, BGE_MODECTL_WORDSWAP_NONFRAME|
		    BGE_MODECTL_BYTESWAP_DATA|BGE_MODECTL_WORDSWAP_DATA|
d1095 1
a1095 2
	CSR_WRITE_4(sc, BGE_MODE_CTL, BGE_MODECTL_WORDSWAP_NONFRAME|
		    BGE_MODECTL_BYTESWAP_DATA|BGE_MODECTL_WORDSWAP_DATA|
d1131 2
d1301 3
a1303 3
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_hi, 0);
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_lo,
		    BGE_RING_DMA_ADDR(sc, bge_tx_ring));
d1336 3
a1338 3
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_hi, 0);
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_lo,
		    BGE_RING_DMA_ADDR(sc, bge_rx_return_ring));
d1409 3
a1411 3
	CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_ADDR_HI, 0);
	CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_ADDR_LO,
		    BGE_RING_DMA_ADDR(sc, bge_status_block));
d2061 1
a2061 1
	    BGE_PCIMISCCTL_ENDIAN_WORDSWAP|BGE_PCIMISCCTL_PCISTATE_RW);
d2097 1
a2097 1
	    BGE_PCIMISCCTL_ENDIAN_WORDSWAP|BGE_PCIMISCCTL_PCISTATE_RW);
d2154 1
a2154 2
	CSR_WRITE_4(sc, BGE_MODE_CTL, BGE_MODECTL_BYTESWAP_NONFRAME|
	    BGE_MODECTL_BYTESWAP_DATA);
@


1.51
log
@add BGE_QUIRK_FEWER_MBUFS to 5704 fallback case.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.50 2005/01/01 20:45:46 krw Exp $	*/
d2669 7
@


1.50
log
@Add BGE_QUIRK_ONLY_PHY_1 to BCM5701_B2. From NetBSD PR #23778, as
pointed out by Theo 2003/12/13.

ok brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.49 2004/12/30 05:44:15 krw Exp $	*/
d1645 1
a1645 1
	  BGE_QUIRK_ONLY_PHY_1,
@


1.49
log
@Don't zero error value, return it.

ok brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.48 2004/12/26 02:10:22 brad Exp $	*/
d1561 1
a1561 1
	  BGE_QUIRK_PCIX_DMA_ALIGN_BUG,
@


1.48
log
@add BGE_QUIRK_PCIX_DMA_ALIGN_BUG for BCM5701 A0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.47 2004/12/24 23:44:10 deraadt Exp $	*/
a3058 1
		error = 0;
@


1.47
log
@brad should compile before commiting
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.46 2004/12/24 23:29:14 brad Exp $	*/
d1553 1
a1553 1
	  0, /*XXX really, just not known */
@


1.46
log
@init Jumbo RX ring by default.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.45 2004/12/17 03:13:59 brad Exp $	*/
d2835 1
a2835 1
	if (sc->bge_quirks & BGE_QUIRK_5705_CORE) == 0)
@


1.45
log
@rev 1.62

Possibloe fix for some bge chip revisions taking a long time to reset
(e.g., polling for a half-second or more at splnet(), blocking most
interrupts, durin an ifconfig down/ifconfig up).

Appears to help for a 5704C rev A3, which is the only chip I've
ever seen that had even a mild version of the reported problem.

rev 1.61

Check for BGE_PCI_PCISTATE register failing to revert on reset.
if it occurs, print a message indicating why the reset took so long.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.44 2004/12/16 14:30:31 brad Exp $	*/
d2835 1
a2835 1
	if (ifp->if_mtu > ETHER_MAX_LEN)
@


1.44
log
@rev 1.71

* Set buffer management high water marks for MTU > 1514.

* Set BGE_MAX_RX_FRAME_LOWAT (from Linux driver).

rev 1.25

* Update onchip buffer tunables to recommended values from Linux drivers.

* Increase Tx interrupt-coalescing thresholds, to reduce Tx-done interrupts.

From NetBSD

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.43 2004/12/12 19:11:26 brad Exp $	*/
d2056 1
a2056 1
	u_int32_t cachesize, command, pcistate, reset;
d2116 1
d2145 4
a2148 2
		if (pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE) ==
		    pcistate)
d2151 5
@


1.43
log
@use quirk flags where appropriate.

Based on NetBSD driver

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.42 2004/12/12 05:03:05 brad Exp $	*/
d1135 1
d1172 1
d1174 10
a1183 2
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x50);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x20);
d1187 1
a1188 1
	CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x60);
a1907 1
	sc->bge_tx_coal_ticks = 150;
d1909 2
a1910 1
	sc->bge_tx_max_coal_bds = 128;
d2841 2
@


1.42
log
@add quirk lookup table, isn't used for anything at the moment
except printing the ASIC model and rev in dmesg. will be used
instead of checking ASIC revs all over the place.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.41 2004/12/11 05:57:04 brad Exp $	*/
d475 2
a476 7
	 * Broadcom's own driver always assumes the internal
	 * PHY is at GMII address 1. On some chips, the PHY responds
	 * to accesses at all addresses, which could cause us to
	 * bogusly attach the PHY 32 times at probe type. Always
	 * restricting the lookup to address 1 is simpler than
	 * trying to figure out which chips revisions should be
	 * special-cased.
d478 1
a478 1
	if (phy != 1)
d936 1
a936 2
	/* 5700 b2 errata */
	if (sc->bge_chiprev == BGE_CHIPREV_5700_BX)
d940 1
a940 2
	/* 5700 b2 errata */
	if (sc->bge_chiprev == BGE_CHIPREV_5700_BX)
d1060 1
a1060 1
		if (BGE_ASICREV(sc->bge_asicrev) == BGE_ASICREV_BCM5704)
d1074 2
a1075 2
		if (sc->bge_asicrev == BGE_ASICREV_BCM5703 ||
		    sc->bge_asicrev == BGE_ASICREV_BCM5704) {
d1084 4
a1087 4
	if (sc->bge_asicrev == BGE_ASICREV_BCM5703 ||
	    sc->bge_asicrev == BGE_ASICREV_BCM5704 ||
	    sc->bge_asicrev == BGE_ASICREV_BCM5705 ||
	    sc->bge_asicrev == BGE_ASICREV_BCM5750)
d1146 17
a1162 1
	/* Note: the BCM5704 has a smaller bmuf space than the other chips */
a1163 8
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750) {
		/* Configure mbuf memory pool */
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_BASEADDR,
		    (sc->bge_extram) ? BGE_EXT_SSRAM : BGE_BUFFPOOL_1);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_LEN,
		    (sc->bge_asicrev == BGE_ASICREV_BCM5704) ? 0x10000:0x18000);
 
d1171 4
a1174 2
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705 ||
	    sc->bge_asicrev == BGE_ASICREV_BCM5750) {
a1176 3
	} else {
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x50);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x20);
d1185 1
a1185 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750) {
d1223 1
a1223 4
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705 ||
	    sc->bge_asicrev == BGE_ASICREV_BCM5750)
		rcb->bge_maxlen_flags = BGE_RCB_MAXLEN_FLAGS(512, 0);
	else
d1226 2
d1244 1
a1244 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750) {
d1301 1
a1301 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750)
d1385 1
a1385 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750) {
d1393 1
a1393 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750) {
d1422 1
a1422 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750)
d1444 1
a1444 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750)
d1465 1
a1465 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750)
d1497 1
a1497 1
		if (sc->bge_asicrev == BGE_ASICREV_BCM5700)
a1772 2
        sc->bge_asicrev = BGE_ASICREV(sc->bge_chipid);
        sc->bge_chiprev = BGE_CHIPREV(sc->bge_chipid);
d1790 1
a1790 1
	if (sc->bge_asicrev == BGE_ASICREV_BCM5750) {
d1886 1
a1886 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750) {
d1903 3
a1905 2
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705 ||
	    sc->bge_asicrev == BGE_ASICREV_BCM5750)
a1906 2
	else
		sc->bge_return_ring_cnt = BGE_RETURN_RING_CNT;
d1993 1
a1993 5
	switch (sc->bge_chipid) {
	case BGE_CHIPID_BCM5701_A0:
	case BGE_CHIPID_BCM5701_B0:
	case BGE_CHIPID_BCM5701_B2:
	case BGE_CHIPID_BCM5701_B5:
d1997 2
a1998 3
		    BGE_PCISTATE_PCI_BUSSPEED)
			sc->bge_rx_alignment_bug = 1;
		break;
d2098 1
a2098 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750)
d2151 1
a2151 1
	if (sc->bge_asicrev == BGE_ASICREV_BCM5704 && sc->bge_tbi) {
d2383 1
a2383 1
	if (sc->bge_asicrev == BGE_ASICREV_BCM5700) {
d2473 3
a2475 2
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705 ||
	    sc->bge_asicrev == BGE_ASICREV_BCM5750)
a2476 2
	else
		bge_stats_update(sc);
d2488 1
a2488 1
			if (sc->bge_asicrev == BGE_ASICREV_BCM5704)
d2732 1
a2732 2
	/* 5700 b2 errata */
	if (sc->bge_chiprev == BGE_CHIPREV_5700_BX)
d2872 1
a2872 1
			if (sc->bge_asicrev == BGE_ASICREV_BCM5704) {
d2978 1
a2978 2
		if (((sc->bge_asicrev == BGE_ASICREV_BCM5705 ||
		      sc->bge_asicrev == BGE_ASICREV_BCM5750) &&
d3105 1
a3105 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750)
d3119 1
a3119 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750)
d3129 1
a3129 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750)
d3135 1
a3135 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750) {
d3153 1
a3153 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705 &&
	    sc->bge_asicrev != BGE_ASICREV_BCM5750)
@


1.41
log
@rev 1.11

When stopping the various functional blocks of the chip, clear the
bit and then read it back in a loop (with appropriate delays) waiting
for it to read back clear.

This fixes a problem where the bus would hang when bringing down
the interface or changing interface flags on a system with a
sufficiently fast CPU (e.g. 2GHz P4 Xeon).

From NetBSD

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.40 2004/12/10 05:04:23 brad Exp $	*/
d120 1
d242 15
d1517 161
d1704 1
a1772 1
	printf(": %s", intrstr);
d1774 4
a1777 1
	/* Save ASIC rev. */
d1784 12
@


1.40
log
@rev 1.5

Put some delay in the loops that poll for MII transaction
completion.  Without this, reading the PHY can hang the bus
on a sufficiently fast CPU.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.39 2004/12/10 02:49:18 krw Exp $	*/
d135 1
d2897 17
d2932 3
a2934 3
	BGE_CLRBIT(sc, BGE_RX_MODE, BGE_RXMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_RBDI_MODE, BGE_RBDIMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_RXLP_MODE, BGE_RXLPMODE_ENABLE);
d2937 4
a2940 4
		BGE_CLRBIT(sc, BGE_RXLS_MODE, BGE_RXLSMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_RDBDI_MODE, BGE_RBDIMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_RDC_MODE, BGE_RDCMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_RBDC_MODE, BGE_RBDCMODE_ENABLE);
d2945 5
a2949 5
	BGE_CLRBIT(sc, BGE_SRS_MODE, BGE_SRSMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_SBDI_MODE, BGE_SBDIMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_SDI_MODE, BGE_SDIMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_RDMA_MODE, BGE_RDMAMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_SDC_MODE, BGE_SDCMODE_ENABLE);
d2952 2
a2953 2
		BGE_CLRBIT(sc, BGE_DMAC_MODE, BGE_DMACMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_SBDC_MODE, BGE_SBDCMODE_ENABLE);
d2959 2
a2960 2
	BGE_CLRBIT(sc, BGE_HCC_MODE, BGE_HCCMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_WDMA_MODE, BGE_WDMAMODE_ENABLE);
d2963 2
a2964 1
		BGE_CLRBIT(sc, BGE_MBCF_MODE, BGE_MBCFMODE_ENABLE);
d2967 1
d2970 2
a2971 2
		BGE_CLRBIT(sc, BGE_BMAN_MODE, BGE_BMANMODE_ENABLE);
		BGE_CLRBIT(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE);
@


1.39
log
@1) Don't manually fiddle with dma address of jumbo buffer after m_adj().

2) Create tx_map's large enough to map jumbo buffers.

3) Set length of jumbo frame to BGE_JLEN rather than ETHER_MAX_DIX_LEN.

4) Activate jumbo rx ring when MTU changed. (From FreeBSD).

Makes jumbo frames work on bge.

ok brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.38 2004/12/10 02:36:38 brad Exp $	*/
d483 1
d528 1
@


1.38
log
@more Broadcom ids taken from the Linux driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.37 2004/11/24 03:21:28 brad Exp $	*/
d797 1
a797 2
	BGE_HOSTADDR(r->bge_addr, BGE_JUMBO_DMA_ADDR(sc, m_new) +
	    (sc->bge_rx_alignment_bug ? 0 : ETHER_ALIGN));
d932 2
a933 2
		if (bus_dmamap_create(sc->bge_dmatag, MCLBYTES, BGE_NTXSEG,
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &sc->bge_cdata.bge_tx_map[i]))
d1233 1
a1233 1
		    BGE_RCB_MAXLEN_FLAGS(ETHER_MAX_DIX_LEN,
d2808 1
a2808 1
		else
d2810 3
@


1.37
log
@use ETHER_MAX_LEN
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.36 2004/11/16 14:27:43 brad Exp $	*/
d209 1
d212 1
d216 1
d218 1
d222 2
d227 2
d231 1
@


1.36
log
@allow for the reception of VLAN sized frames.

From FreeBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.35 2004/11/11 18:35:41 brad Exp $	*/
d2635 1
a2635 1
	if (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))
@


1.35
log
@rev 1.71

Add some special case code to fix a problem with the BCM5704 in TBI (fiber)
mode. The 5704 apparently has some s00p3r s33kr1t registers for setting
the advertisement of pause frame ability (i.e flow control) when in
autoneg mode. If we don't set these registers correctly, we may not
be able to negotiate a proper link with some switches. (Symptom is that
the NIC reports the link as up (PCS synched) but no traffic can be
exchanged.)

rev 1.73

Commit patch to supress spurious link change events. Apparently, with
copper NICs, a link change event is posted whenever MII autopolling is
toggled off and on, which happens whenever someone calls
bge_miibus_readreg() or bge_miibus_writereg() to access the PHY
registers. This means anytime someone called the SIOCGIFMEDIA ioctl
on a bge interface, the link would reset. Even a simple "ifconfig bge0"
would do it, though other apps like dhclient or the PPPoE daemon could
trigger it as well. An obvious symptom of this problem is lots of
"bgeX: gigabit link up" messages appearing on the console for no
apparent reason.

Through experimentation, I determined that when a real link change
event occurs, the BGE_MIMODE_AUTOPOLL in the BGE_MI_MODE register
is always set, so now if we have a copper NIC and an link change
event occurs and the BGE_MIMODE_AUTOPOLL bit is clear, we ignore
the event.

Note that this does not apply to the original BCM5700 chip since we
use a different method for sensing link changes with that chip (the
status block method was broken), nor to fiber optic NICs since they
don't use the GMII PHY access registers.

From FreeBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.34 2004/10/31 06:59:25 brad Exp $	*/
d1731 2
d2596 1
a2596 1
	    ETHER_HDR_LEN + ETHER_CRC_LEN);
@


1.34
log
@rev 1.68

Add support for BCM5705K

rev 1.74

Add support for the BCM5750/5751.  Unfortunately the documentation
I have from Broadcom does not give much information on these devices,
so the Broadcom Linux driver was used for clues to what these chips
support.  It turns out they are similar to the 5705 with the 5751
being the PCI-Express version and needing special work-arounds and
settings.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.33 2004/09/28 04:37:32 brad Exp $	*/
d1772 1
d1960 12
d2171 1
a2171 1
	u_int32_t status;
d2229 7
d2238 1
d2240 2
a2241 1
			    BGE_MACSTAT_MI_COMPLETE))) {
d2303 3
d2683 17
@


1.33
log
@Use ETHER_MAX_DIX_LEN/ETHER_MIN_LEN
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.32 2004/09/23 17:45:16 brad Exp $	*/
d215 1
d218 3
d1023 5
a1027 1
	if (pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE) &
d1066 2
a1067 1
	    sc->bge_asicrev == BGE_ASICREV_BCM5705)
d1128 2
a1129 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
d1143 2
a1144 1
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705) {
d1158 2
a1159 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
d1197 2
a1198 1
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705)
d1219 2
a1220 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
d1277 2
a1278 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d1362 2
a1363 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
d1371 2
a1372 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
d1401 2
a1402 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d1424 2
a1425 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d1446 2
a1447 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d1586 23
a1689 8
	/* Save ASIC rev. */

	sc->bge_chipid =
	    pci_conf_read(pc, pa->pa_tag, BGE_PCI_MISC_CTL) &
	    BGE_PCIMISCCTL_ASICREV;
	sc->bge_asicrev = BGE_ASICREV(sc->bge_chipid);
	sc->bge_chiprev = BGE_CHIPREV(sc->bge_chipid);

d1694 2
a1695 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
d1712 2
a1713 1
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705)
d1858 1
a1858 1
	u_int32_t cachesize, command, pcistate;
d1870 13
d1884 1
a1884 2
	bge_writereg_ind(sc, BGE_MISC_CFG,
	    BGE_MISCCFG_RESET_CORE_CLOCKS|(65<<1));
d1888 13
d1910 2
a1911 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d1959 6
d2265 2
a2266 1
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705)
d2752 2
a2753 1
		if ((sc->bge_asicrev == BGE_ASICREV_BCM5705 &&
d2860 2
a2861 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d2875 2
a2876 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d2886 2
a2887 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
d2891 2
a2892 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
d2910 2
a2911 1
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
@


1.32
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.31 2004/09/16 00:55:09 mcbride Exp $	*/
d1189 1
a1189 1
		    BGE_RCB_MAXLEN_FLAGS(BGE_MAX_FRAMELEN, 0);
d1211 1
a1211 1
		    BGE_RCB_MAXLEN_FLAGS(BGE_MAX_FRAMELEN,
@


1.31
log
@If we can't allocate new jumbo storage, try to copy the packet into a
new mbuf chain with m_devget() before recycling the jumbo storage.
Frome if_sk.c

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.30 2004/08/19 17:00:03 mcbride Exp $	*/
a1685 1
	ifp->if_output = ether_output;
a1688 1
	ifp->if_mtu = ETHERMTU;
@


1.30
log
@Don't complain about lack of available jumbo buffers when processing incoming
packets unless we're debugging.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.29 2004/08/17 18:23:49 deraadt Exp $	*/
d1955 6
a1960 3
			if (bge_newbuf_jumbo(sc, sc->bge_jumbo,
					     NULL)== ENOBUFS) {
				ifp->if_ierrors++;
d1962 6
a1967 1
				continue;
@


1.29
log
@printf repair
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.28 2004/08/05 19:57:17 brad Exp $	*/
d648 2
a649 1
		printf("%s: no free jumbo buffers\n", sc->bge_dev.dv_xname);
@


1.28
log
@remove some separate per driver constants and use
ETHER_MAX_LEN_JUMBO/ETHERMTU_JUMBO where appropriate.

ok mcbride@@ henning@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.27 2004/05/29 23:07:48 naddy Exp $	*/
d1600 1
a1600 1
	printf(": address: %s\n",
@


1.27
log
@- Properly support multicast reception.
- Use ether_crc32_le() instead of equivalent hand-rolled CRC routine.

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.26 2004/05/25 04:59:10 mcbride Exp $	*/
d770 2
a771 2
		m_new->m_len = m_new->m_pkthdr.len = BGE_JUMBO_FRAMELEN;
		MEXTADD(m_new, buf, BGE_JUMBO_FRAMELEN, 0, bge_jfree, sc);
d775 1
a775 1
		m_new->m_ext.ext_size = BGE_JUMBO_FRAMELEN;
d2676 1
a2676 1
		    ifr->ifr_mtu > ETHERMTU) || ifr->ifr_mtu > BGE_JUMBO_MTU)
@


1.26
log
@Use the correct value when checking whether a loop timed out.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.25 2004/04/12 06:56:42 brad Exp $	*/
a143 1
u_int32_t bge_crc(caddr_t);
a926 19
#define BGE_POLY	0xEDB88320

u_int32_t
bge_crc(addr)
	caddr_t addr;
{
	u_int32_t idx, bit, data, crc;

	/* Compute CRC for the address value. */
	crc = 0xFFFFFFFF; /* initial value */

	for (idx = 0; idx < 6; idx++) {
		for (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)
			crc = (crc >> 1) ^ (((crc ^ data) & 1) ? BGE_POLY : 0);
	}

	return(crc & 0x7F);
}

d939 6
a950 5
	/* First, zot all the existing filters. */
	for (i = 0; i < 4; i++)
		CSR_WRITE_4(sc, BGE_MAR0 + (i * 4), 0);

	/* Now program new ones. */
d953 5
a957 1
		h = bge_crc(LLADDR((struct sockaddr_dl *)enm->enm_addrlo));
d2713 7
a2719 2
		if (ifp->if_flags & IFF_RUNNING) {
			bge_setmulti(sc);
@


1.25
log
@Enable the memory arbiter before turning off the PXE restart.  This
prevents NMI's from happening when resetting the chip on some
hardware.

From: FreeBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.24 2004/04/09 21:52:16 henning Exp $	*/
d292 1
a292 1
	if (i == BGE_TIMEOUT) {
d400 1
a400 1
	if (i == BGE_TIMEOUT) {
@


1.24
log
@do not whine if we cannot get mbufs. the countless printfd makes the machine
crawl under mbuf starvation, making the situationmuch worse, and don't make
sense in the first place.
ok tdeval@@ millert@@ beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.23 2004/02/27 16:03:06 niklas Exp $	*/
d1088 1
a1088 4
		    BGE_MODECTL_MAC_ATTN_INTR|BGE_MODECTL_HOST_SEND_BDS
/*		    |BGE_MODECTL_TX_NO_PHDR_CSUM| */
/*		    BGE_MODECTL_RX_NO_PHDR_CSUM */
);
d1863 4
a1904 4

	/* Enable memory arbiter. */
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
		CSR_WRITE_4(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE);
@


1.23
log
@Add support for BCM5788
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.22 2003/10/26 15:07:25 jmc Exp $	*/
a766 2
			printf("%s: jumbo allocation failed "
			    "-- packet dropped!\n", sc->bge_dev.dv_xname);
@


1.22
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.21 2003/10/13 16:18:56 krw Exp $	*/
d219 1
@


1.21
log
@Bring bge and brgphy more up to date with changes from FreeBSD and NetBSD.

Some bug fixes, support for new hardware like the 5704 and 5705.

Testing by deraadt@@, danh@@, and drahn@@ amoung others.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.20 2003/09/03 21:24:28 jason Exp $	*/
d2112 1
a2112 1
	/* Ack interrupt and stop others from occuring. */
d2119 1
a2119 1
	 * according to all avaibable information. Hence, we have
@


1.20
log
@match a bunch more bge devices.  May not work completely, but they're no
more broken than before; ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.19 2003/02/11 19:20:27 mickey Exp $	*/
d128 1
a181 1
void bge_phy_hack(struct bge_softc *);
d196 1
a196 1
 * ID burned into it, though it will always be overriden by the vendor
d215 1
d217 4
d441 1
a441 2
	struct ifnet *ifp;
	u_int32_t val;
d444 11
a454 1
	ifp = &sc->arpcom.ac_if;
d456 6
a461 11
	if (phy != 1)
		switch(sc->bge_asicrev) {
		case BGE_ASICREV_BCM5701_B5:
		case BGE_ASICREV_BCM5703_A2:
		case BGE_ASICREV_BCM5704_A0:
		case BGE_ASICREV_BCM5704_A1:
		case BGE_ASICREV_BCM5704_A2:
		case BGE_ASICREV_BCM5704_A3:
		case BGE_ASICREV_BCM5705_A1:
			return(0);
		}
d474 2
a475 1
		return(0);
d480 6
d498 1
d501 7
d516 5
a544 2

	bge_phy_hack(sc);
d731 2
a732 2
	BGE_HOSTADDR(r->bge_addr) = rxmap->dm_segs[0].ds_addr +
	    (!sc->bge_rx_alignment_bug ? ETHER_ALIGN : 0);
d785 2
a786 2
	BGE_HOSTADDR(r->bge_addr) = BGE_JUMBO_DMA_ADDR(sc, m_new) +
	    (!sc->bge_rx_alignment_bug ? ETHER_ALIGN : 0);
a846 1
	struct bge_rcb_opaque *rcbo;
d856 2
a857 3
	rcbo = (struct bge_rcb_opaque *)rcb;
	rcb->bge_flags = 0;
	CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_MAXLEN_FLAGS, rcbo->bge_reg2);
d909 1
d911 4
d916 3
a989 1
	int			i;
d991 2
d1037 4
a1040 2
		pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL,
		    BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD|0x3F000F);
d1043 34
a1076 3
		pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL,
		    BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD|0x1B000F);
	}
d1085 1
a1085 1
		    BGE_MODECTL_NO_RX_CRC);
d1089 1
a1089 2
		    BGE_MODECTL_MAC_ATTN_INTR|BGE_MODECTL_HOST_SEND_BDS|
		    BGE_MODECTL_NO_RX_CRC
a1123 1
	struct bge_rcb_opaque	*rcbo;
d1135 13
a1147 7
	/* Configure mbuf memory pool */
	if (sc->bge_extram) {
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_BASEADDR, BGE_EXT_SSRAM);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_LEN, 0x18000);
	} else {
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_BASEADDR, BGE_BUFFPOOL_1);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_LEN, 0x18000);
a1149 4
	/* Configure DMA resource pool */
	CSR_WRITE_4(sc, BGE_BMAN_DMA_DESCPOOL_BASEADDR, BGE_DMA_DESCRIPTORS);
	CSR_WRITE_4(sc, BGE_BMAN_DMA_DESCPOOL_LEN, 0x2000);

d1151 8
a1158 3
	CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 24);
	CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 24);
	CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 48);
d1165 10
a1174 2
	CSR_WRITE_4(sc, BGE_BMAN_MODE,
	    BGE_BMANMODE_ENABLE|BGE_BMANMODE_LOMBUF_ATTN);
d1176 5
a1180 11
	/* Poll for buffer manager start indication */
	for (i = 0; i < BGE_TIMEOUT; i++) {
		if (CSR_READ_4(sc, BGE_BMAN_MODE) & BGE_BMANMODE_ENABLE)
			break;
		DELAY(10);
	}

	if (i == BGE_TIMEOUT) {
		printf("%s: buffer manager failed to start\n",
		    sc->bge_dev.dv_xname);
		return(ENXIO);
d1202 6
a1207 3
	BGE_HOSTADDR(rcb->bge_hostaddr) =
		BGE_RING_DMA_ADDR(sc, bge_rx_std_ring);
	rcb->bge_max_len = BGE_MAX_FRAMELEN;
d1212 4
a1215 6
	rcb->bge_flags = 0;
	rcbo = (struct bge_rcb_opaque *)rcb;
	CSR_WRITE_4(sc, BGE_RX_STD_RCB_HADDR_HI, rcbo->bge_reg0);
	CSR_WRITE_4(sc, BGE_RX_STD_RCB_HADDR_LO, rcbo->bge_reg1);
	CSR_WRITE_4(sc, BGE_RX_STD_RCB_MAXLEN_FLAGS, rcbo->bge_reg2);
	CSR_WRITE_4(sc, BGE_RX_STD_RCB_NICADDR, rcbo->bge_reg3);
d1224 11
a1234 9
	rcb = &sc->bge_rdata->bge_info.bge_jumbo_rx_rcb;
	BGE_HOSTADDR(rcb->bge_hostaddr) =
		BGE_RING_DMA_ADDR(sc, bge_rx_jumbo_ring);
	rcb->bge_max_len = BGE_MAX_FRAMELEN;
	if (sc->bge_extram)
		rcb->bge_nicaddr = BGE_EXT_JUMBO_RX_RINGS;
	else
		rcb->bge_nicaddr = BGE_JUMBO_RX_RINGS;
	rcb->bge_flags = BGE_RCB_FLAG_RING_DISABLED;
d1236 16
a1251 11
	rcbo = (struct bge_rcb_opaque *)rcb;
	CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_HADDR_HI, rcbo->bge_reg0);
	CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_HADDR_LO, rcbo->bge_reg1);
	CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_MAXLEN_FLAGS, rcbo->bge_reg2);
	CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_NICADDR, rcbo->bge_reg3);

	/* Set up dummy disabled mini ring RCB */
	rcb = &sc->bge_rdata->bge_info.bge_mini_rx_rcb;
	rcb->bge_flags = BGE_RCB_FLAG_RING_DISABLED;
	rcbo = (struct bge_rcb_opaque *)rcb;
	CSR_WRITE_4(sc, BGE_RX_MINI_RCB_MAXLEN_FLAGS, rcbo->bge_reg2);
d1268 2
a1269 3
		RCB_WRITE_2(sc, rcb_addr, bge_flags,
			    BGE_RCB_FLAG_RING_DISABLED);
		RCB_WRITE_2(sc, rcb_addr, bge_max_len, 0);
d1277 1
a1277 1
	RCB_WRITE_4(sc, rcb_addr, BGE_HOSTADDR(bge_hostaddr),
d1281 3
a1283 2
	RCB_WRITE_2(sc, rcb_addr, bge_max_len, BGE_TX_RING_CNT);
	RCB_WRITE_2(sc, rcb_addr, bge_flags, 0);
d1290 3
a1292 3
		RCB_WRITE_2(sc, rcb_addr, bge_flags,
			    BGE_RCB_FLAG_RING_DISABLED);
		RCB_WRITE_2(sc, rcb_addr, bge_max_len, BGE_RETURN_RING_CNT);
d1312 1
a1312 1
	RCB_WRITE_4(sc, rcb_addr, BGE_HOSTADDR(bge_hostaddr),
d1315 2
a1316 2
	RCB_WRITE_2(sc, rcb_addr, bge_max_len, BGE_RETURN_RING_CNT);
	RCB_WRITE_2(sc, rcb_addr, bge_flags, 0);
d1365 4
a1368 2
	CSR_WRITE_4(sc, BGE_HCC_RX_COAL_TICKS_INT, 0);
	CSR_WRITE_4(sc, BGE_HCC_TX_COAL_TICKS_INT, 0);
a1370 1
	CSR_WRITE_4(sc, BGE_HCC_STATS_TICKS, sc->bge_stat_ticks);
d1373 9
a1381 4
	CSR_WRITE_4(sc, BGE_HCC_STATS_BASEADDR, BGE_STATS_BLOCK);
	CSR_WRITE_4(sc, BGE_HCC_STATS_ADDR_HI, 0);
	CSR_WRITE_4(sc, BGE_HCC_STATS_ADDR_LO,
		    BGE_RING_DMA_ADDR(sc, bge_info.bge_stats));
a1383 1
	CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_BASEADDR, BGE_STATUS_BLOCK);
d1387 1
d1402 2
a1403 1
	CSR_WRITE_4(sc, BGE_RXLS_MODE, BGE_RXLSMODE_ENABLE);
d1424 2
a1425 1
	CSR_WRITE_4(sc, BGE_DMAC_MODE, BGE_DMACMODE_ENABLE);
d1445 2
a1446 1
	CSR_WRITE_4(sc, BGE_MBCF_MODE, BGE_MBCFMODE_ENABLE);
a1466 3
	/* init LED register */
	CSR_WRITE_4(sc, BGE_MAC_LED_CTL, 0x00000000);

d1469 2
a1470 2
	    BGE_MACSTAT_CFG_CHANGED);
	CSR_WRITE_4(sc, BGE_MI_STS, 0);
d1589 1
a1589 1
		printf("%s: chip initializatino failed\n",
d1665 19
a1683 6
	/* Try to allocate memory for jumbo buffers. */
	if (bge_alloc_jumbo_mem(sc)) {
		printf("%s: jumbo buffer allocation failed\n",
		    sc->bge_dev.dv_xname);
		error = ENXIO;
		goto fail;
d1693 6
a1722 10
	/* Save ASIC rev. */

	sc->bge_asicrev =
	    pci_conf_read(pc, pa->pa_tag, BGE_PCI_MISC_CTL) &
	    BGE_PCIMISCCTL_ASICREV;

	/* Pretend all 5700s are the same */
	if ((sc->bge_asicrev & 0xFF000000) == BGE_ASICREV_BCM5700)
		sc->bge_asicrev = BGE_ASICREV_BCM5700;

d1724 16
a1739 9
	 * Figure out what sort of media we have by checking the
	 * hardware config word in the EEPROM. Note: on some BCM5700
	 * cards, this value appears to be unset. If that's the
	 * case, we have to rely on identifying the NIC by its PCI
	 * subsystem ID, as we do below for the SysKonnect SK-9D41.
	 */
	bge_read_eeprom(sc, (caddr_t)&hwcfg,
		    BGE_EE_HWCFG_OFFSET, sizeof(hwcfg));
	if ((ntohl(hwcfg) & BGE_HWCFG_MEDIA) == BGE_MEDIA_FIBER)
d1783 5
a1787 5
	switch (sc->bge_asicrev) {
	case BGE_ASICREV_BCM5701_A0:
	case BGE_ASICREV_BCM5701_B0:
	case BGE_ASICREV_BCM5701_B2:
	case BGE_ASICREV_BCM5701_B5:
d1907 2
a1908 1
	CSR_WRITE_4(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE);
d1954 1
a1954 1
		BGE_INC(sc->bge_rx_saved_considx, BGE_RETURN_RING_CNT);
d2011 1
a2011 1
		m->m_pkthdr.len = m->m_len = cur_rx->bge_len;
d2101 1
a2127 2
		u_int32_t		status;

d2141 26
a2166 5
		if (sc->bge_rdata->bge_status_block.bge_status &
		    BGE_STATFLAG_LINKSTATE_CHANGED) {
			sc->bge_link = 0;
			timeout_del(&sc->bge_timeout);
			bge_tick(sc);
d2169 5
a2173 1
			    BGE_MACSTAT_CFG_CHANGED);
d2208 4
a2211 1
	bge_stats_update(sc);
d2244 27
d2281 8
a2288 4
	  (READ_STAT(sc, stats, dot3StatsSingleCollisionFrames.bge_addr_lo) +
	   READ_STAT(sc, stats, dot3StatsMultipleCollisionFrames.bge_addr_lo) +
	   READ_STAT(sc, stats, dot3StatsExcessiveCollisions.bge_addr_lo) +
	   READ_STAT(sc, stats, dot3StatsLateCollisions.bge_addr_lo)) -
d2358 1
a2358 1
		BGE_HOSTADDR(f->bge_addr) = txmap->dm_segs[i].ds_addr;
d2464 3
a2473 40
/*
 * If we have a BCM5400 or BCM5401 PHY, we need to properly
 * program its internal DSP. Failing to do this can result in
 * massive packet loss at 1Gb speeds.
 */
void
bge_phy_hack(sc)
	struct bge_softc *sc;
{
	struct bge_bcom_hack bhack[] = {
	{ BRGPHY_MII_AUXCTL, 0x4C20 },
	{ BRGPHY_MII_DSP_ADDR_REG, 0x0012 },
	{ BRGPHY_MII_DSP_RW_PORT, 0x1804 },
	{ BRGPHY_MII_DSP_ADDR_REG, 0x0013 },
	{ BRGPHY_MII_DSP_RW_PORT, 0x1204 },
	{ BRGPHY_MII_DSP_ADDR_REG, 0x8006 },
	{ BRGPHY_MII_DSP_RW_PORT, 0x0132 },
	{ BRGPHY_MII_DSP_ADDR_REG, 0x8006 },
	{ BRGPHY_MII_DSP_RW_PORT, 0x0232 },
	{ BRGPHY_MII_DSP_ADDR_REG, 0x201F },
	{ BRGPHY_MII_DSP_RW_PORT, 0x0A20 },
	{ 0, 0 } };
	u_int16_t vid, did;
	int i;

	vid = bge_miibus_readreg(&sc->bge_dev, 1, MII_PHYIDR1);
	did = bge_miibus_readreg(&sc->bge_dev, 1, MII_PHYIDR2);

	if (MII_OUI(vid, did) == MII_OUI_xxBROADCOM &&
	    (MII_MODEL(did) == MII_MODEL_xxBROADCOM_BCM5400 ||
	     MII_MODEL(did) == MII_MODEL_xxBROADCOM_BCM5401)) {
		i = 0;
		while (bhack[i].reg) {
			bge_miibus_writereg(&sc->bge_dev, 1, bhack[i].reg,
					    bhack[i].val);
			i++;
		}
	}
}

d2531 18
a2622 1
	bge_phy_hack(sc);
d2693 3
a2695 1
		if (ifr->ifr_mtu > BGE_JUMBO_MTU)
d2796 2
a2797 1
	BGE_CLRBIT(sc, BGE_RXLS_MODE, BGE_RXLSMODE_ENABLE);
d2810 2
a2811 1
	BGE_CLRBIT(sc, BGE_DMAC_MODE, BGE_DMACMODE_ENABLE);
d2820 2
a2821 1
	BGE_CLRBIT(sc, BGE_MBCF_MODE, BGE_MBCFMODE_ENABLE);
d2824 4
a2827 2
	BGE_CLRBIT(sc, BGE_BMAN_MODE, BGE_BMANMODE_ENABLE);
	BGE_CLRBIT(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE);
d2842 2
a2843 1
	bge_free_rx_ring_jumbo(sc);
@


1.19
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.18 2003/01/15 06:31:24 art Exp $	*/
d203 2
a204 1
	{ PCI_VENDOR_ALTIMA, PCI_PRODUCT_ALTIMA_AC100X },
d210 1
a211 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5702X },
d213 3
d446 5
@


1.18
log
@Get rid of the remaining vm_offset_t in pci drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.17 2002/11/26 06:01:28 nate Exp $	*/
d58 1
a58 1
 * function in a 32-bit/64-bit 33/66Mhz bus, or a 64-bit/133Mhz bus.
d1038 1
a1038 1
	/* Set the timer prescaler (always 66Mhz) */
@


1.17
log
@1000baseTX -> 1000baseT
- More technically correct
- Matches FreeBSD and NetBSD
- Preserved #define for 1000baseTX for backwards compatibility
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.16 2002/11/26 05:09:36 nate Exp $	*/
d642 2
a643 2
	i = ((vm_offset_t)buf
	     - (vm_offset_t)sc->bge_cdata.bge_jumbo_buf) / BGE_JLEN;
d1050 1
a1050 1
	vm_offset_t		rcb_addr;
@


1.16
log
@use pci_matchbyid
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.15 2002/11/26 04:38:40 nate Exp $	*/
d496 1
a496 1
	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_TX) {
@


1.15
log
@Numerous bug fixes from freebsd and a few from me.
- Add support for the BCM5702X and BCM5703X chips
- Take care of an alignment bug in the PCI-X implementation of a couple revs
  of the chip
- Disable memory write invalidate.  (Supposedly doesn't always work)
- Add missing splx(s)
- Fix some typos
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.14 2002/09/23 14:49:21 nate Exp $	*/
d193 25
d1405 2
a1406 38
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;

	/*
	 * Various supported device vendors/types and their
	 * names. Note: the spec seems to indicate that the hardware
	 * still has Alteon's vendor ID burned into it, though it will
	 * always be overriden by the vendor ID in the EEPROM. Just to
	 * be safe, we cover all possibilities.
	 */

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ALTEON &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALTEON_BCM5700 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALTEON_BCM5701))
		return (1);

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ALTIMA &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALTIMA_AC100X ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALTIMA_AC9100))
		return (1);

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_BROADCOM &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5700 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5701 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5702 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5703 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5702X ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5703X))
		return (1);

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SCHNEIDERKOCH &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SCHNEIDERKOCH_SK9D21)
		return (1);

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_3COM &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_3COM_3C996)
		return (1);

	return (0);
@


1.14
log
@Don't print extra junk to the console
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.13 2002/06/14 21:34:59 todd Exp $	*/
d34 1
a34 1
 * $FreeBSD: if_bge.c,v 1.11 2002/04/04 06:01:31 wpaul Exp $
d61 1
a61 1
 * MAC and a BCM5401 10/100/1000 PHY. Unlike the BCM5700, the BCM5700
d143 1
a143 1
u_int32_t bge_crc(struct bge_softc *, caddr_t);
d413 6
a418 2
	if (sc->bge_asicrev == BGE_ASICREV_BCM5701_B5 && phy != 1)
		return(0);
d666 2
a667 1
	m_adj(m_new, ETHER_ALIGN);
d670 2
a671 1
	BGE_HOSTADDR(r->bge_addr) = rxmap->dm_segs[0].ds_addr + ETHER_ALIGN;
d719 2
a720 1
	m_adj(m_new, ETHER_ALIGN);
d724 2
a725 2
	BGE_HOSTADDR(r->bge_addr) =
		BGE_JUMBO_DMA_ADDR(sc, m_new) + ETHER_ALIGN;
d865 1
a865 2
bge_crc(sc, addr)
	struct bge_softc *sc;
d906 1
a906 1
		h = bge_crc(sc, LLADDR((struct sockaddr_dl *)enm->enm_addrlo));
a922 1
	u_int32_t		cachesize;
d966 10
a975 2
	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL,
	    BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD|0x0F);
a994 3
	/* Get cache line size. */
	cachesize = pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_CACHESZ);

d996 2
a997 1
	 * Avoid violating PCI spec on certain chip revs.
d999 2
a1000 44
	if (pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_CMD) &
	    PCIM_CMD_MWIEN) {
		switch(cachesize) {
		case 1:
			PCI_SETBIT(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL,
				   BGE_PCI_WRITE_BNDRY_16BYTES);
			break;
		case 2:
			PCI_SETBIT(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL,
				   BGE_PCI_WRITE_BNDRY_32BYTES);
			break;
		case 4:
			PCI_SETBIT(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL,
				   BGE_PCI_WRITE_BNDRY_64BYTES);
			break;
		case 8:
			PCI_SETBIT(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL,
				   BGE_PCI_WRITE_BNDRY_128BYTES);
			break;
		case 16:
			PCI_SETBIT(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL,
				   BGE_PCI_WRITE_BNDRY_256BYTES);
			break;
		case 32:
			PCI_SETBIT(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL,
				   BGE_PCI_WRITE_BNDRY_512BYTES);
			break;
		case 64:
			PCI_SETBIT(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL,
				   BGE_PCI_WRITE_BNDRY_1024BYTES);
			break;
		default:
		/* Disable PCI memory write and invalidate. */
#if 0
			if (bootverbose)
				printf("%s: cache line size %d not "
				    "supported; disabling PCI MWI\n",
				    sc->bge_dev.dv_xname, cachesize);
#endif
			PCI_CLRBIT(pa->pa_pc, pa->pa_tag, BGE_PCI_CMD,
			    PCIM_CMD_MWIEN);
			break;
		}
	}
d1009 2
a1010 1
	PCI_SETBIT(sc, BGE_PCI_DMA_RW_CTL, BGE_PCI_READ_BNDRY_1024, 4);
d1396 2
a1397 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALTIMA_AC100X)
d1402 5
a1406 1
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_BROADCOM_BCM5701))
d1435 1
d1513 10
a1522 1
	if (bge_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
d1621 1
a1621 1
	    pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_MISC_CTL) &
d1641 1
a1641 1
	if ((pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_SUBSYS) >> 16) ==
d1674 21
d1897 11
d2363 2
a2364 1
	if (ifp->if_flags & IFF_RUNNING)
d2366 1
@


1.13
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.12 2002/04/29 15:25:38 nate Exp $	*/
a2076 1
			printf("%s: gigabit link up\n", sc->bge_dev.dv_xname);
a2088 3
		if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_TX ||
		    IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_SX)
			printf("%s: gigabit link up\n", sc->bge_dev.dv_xname);
@


1.12
log
@re-do the way the bus_dma is done for transmit.
Loop over the dm_segs instead of looping over the mbuf chain.
This fixes some problems seen where IP fragments can contain bogus data
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.11 2002/04/26 18:45:17 nate Exp $	*/
d1815 1
a1815 1
 * 1) the frame is from the jumbo recieve ring
@


1.11
log
@be more terse with output
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.10 2002/04/26 18:42:49 nate Exp $	*/
a2139 1
	struct mbuf		*m;
a2151 1
	m = m_head;
d2176 2
a2177 2
	if (bus_dmamap_load_mbuf(sc->bge_dmatag, txmap, m,
				 BUS_DMA_NOWAIT))
d2180 7
a2186 9
	for (m = m_head; m != NULL; m = m->m_next) {
		if (m->m_len != 0) {
			f = &sc->bge_rdata->bge_tx_ring[frag];
			if (sc->bge_cdata.bge_tx_chain[frag] != NULL)
				break;
			BGE_HOSTADDR(f->bge_addr) =
				txmap->dm_segs[i++].ds_addr;
			f->bge_len = m->m_len;
			f->bge_flags = csum_flags;
d2188 6
a2193 6
			if (ifv != NULL) {
				f->bge_flags |= BGE_TXBDFLAG_VLAN_TAG;
				f->bge_vlan_tag = ifv->ifv_tag;
			} else {
				f->bge_vlan_tag = 0;
			}
d2195 9
a2203 10
			/*
			 * Sanity check: avoid coming within 16 descriptors
			 * of the end of the ring.
			 */
			if ((BGE_TX_RING_CNT - (sc->bge_txcnt + cnt)) < 16)
				return(ENOBUFS);
			cur = frag;
			BGE_INC(frag, BGE_TX_RING_CNT);
			cnt++;
		}
a2204 3

	if (m != NULL)
		return(ENOBUFS);
@


1.10
log
@Only call bpf_mtap if we have bpf in the kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.9 2002/04/08 21:46:23 nate Exp $	*/
d1548 1
a1548 1
	printf(": Ethernet address: %s\n",
@


1.9
log
@Make fiber cards work (3com 3c996-SX)
Make the BCM5701 chips work.  (3com 3c996B-T)
From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.8 2002/03/14 01:26:58 millert Exp $	*/
d2284 1
d2291 1
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.7 2002/03/12 09:51:20 kjc Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/dev/bge/if_bge.c,v 1.2 2001/09/28 18:56:57 wpaul Exp $
d140 1
a140 2
u_int8_t	bge_eeprom_getbyte(struct bge_softc *,
					     int, u_int8_t *);
d163 1
d167 1
d239 1
d327 1
d413 2
a414 2
	if (ifp->if_flags & IFF_RUNNING)
		BGE_CLRBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
a431 3
	if (ifp->if_flags & IFF_RUNNING)
		BGE_SETBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);

a643 2
			printf("%s: mbuf allocation failed "
			    "-- packet dropped!\n", sc->bge_dev.dv_xname);
a648 2
			printf("%s: cluster allocation failed "
			    "-- packet dropped!\n", sc->bge_dev.dv_xname);
a691 2
			printf("%s: mbuf allocation failed "
			    "-- packet dropped!\n", sc->bge_dev.dv_xname);
d1383 1
a1383 1
	} else
d1385 4
d1425 4
d1459 1
d1633 22
d1660 5
a1664 11
	/*
	 * Do transceiver setup.
	 */
	ifmedia_init(&sc->bge_mii.mii_media, 0, bge_ifmedia_upd,
		     bge_ifmedia_sts);
	mii_attach(&sc->bge_dev, &sc->bge_mii, 0xffffffff,
		   MII_PHY_ANY, MII_OFFSET_ANY, 0);

	if (LIST_FIRST(&sc->bge_mii.mii_phys) == NULL) {
		printf("%s: no PHY found!\n", sc->bge_dev.dv_xname);
		ifmedia_add(&sc->bge_mii.mii_media, IFM_ETHER|IFM_MANUAL,
d1666 21
a1686 3
		ifmedia_set(&sc->bge_mii.mii_media, IFM_ETHER|IFM_MANUAL);
	} else
		ifmedia_set(&sc->bge_mii.mii_media, IFM_ETHER|IFM_AUTO);
d1994 37
a2030 10
	/* Process link state changes. */
	if (sc->bge_rdata->bge_status_block.bge_status &
	    BGE_STATFLAG_LINKSTATE_CHANGED) {
		sc->bge_link = 0;
		timeout_del(&sc->bge_timeout);
		bge_tick(sc);
		/* ack the event to clear/reset it */
		CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED|
		    BGE_MACSTAT_CFG_CHANGED);
		CSR_WRITE_4(sc, BGE_MI_STS, 0);
@


1.7
log
@sync with KAME
ALTQify more drivers.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.6 2002/02/15 20:45:31 nordin Exp $	*/
d120 47
a166 47
int bge_probe		__P((struct device *, void *, void *));
void bge_attach		__P((struct device *, struct device *, void *));
void bge_release_resources	__P((struct bge_softc *));
void bge_txeof		__P((struct bge_softc *));
void bge_rxeof		__P((struct bge_softc *));

void bge_tick		__P((void *));
void bge_stats_update	__P((struct bge_softc *));
int bge_encap		__P((struct bge_softc *, struct mbuf *, u_int32_t *));

int bge_intr		__P((void *));
void bge_start		__P((struct ifnet *));
int bge_ioctl		__P((struct ifnet *, u_long, caddr_t));
void bge_init		__P((void *));
void bge_stop		__P((struct bge_softc *));
void bge_watchdog	__P((struct ifnet *));
void bge_shutdown	__P((void *));
int bge_ifmedia_upd	__P((struct ifnet *));
void bge_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));

u_int8_t	bge_eeprom_getbyte	__P((struct bge_softc *,
					     int, u_int8_t *));
int bge_read_eeprom	__P((struct bge_softc *, caddr_t, int, int));

u_int32_t bge_crc	__P((struct bge_softc *, caddr_t));
void bge_setmulti	__P((struct bge_softc *));

void bge_handle_events	__P((struct bge_softc *));
int bge_alloc_jumbo_mem	__P((struct bge_softc *));
void bge_free_jumbo_mem	__P((struct bge_softc *));
void *bge_jalloc	__P((struct bge_softc *));
void bge_jfree		__P((caddr_t, u_int, void *));
int bge_newbuf_std	__P((struct bge_softc *, int, struct mbuf *));
int bge_newbuf_jumbo	__P((struct bge_softc *, int, struct mbuf *));
int bge_init_rx_ring_std	__P((struct bge_softc *));
void bge_free_rx_ring_std	__P((struct bge_softc *));
int bge_init_rx_ring_jumbo	__P((struct bge_softc *));
void bge_free_rx_ring_jumbo	__P((struct bge_softc *));
void bge_free_tx_ring	__P((struct bge_softc *));
int bge_init_tx_ring	__P((struct bge_softc *));

int bge_chipinit	__P((struct bge_softc *));
int bge_blockinit	__P((struct bge_softc *));

u_int8_t bge_vpd_readbyte	__P((struct bge_softc *, int));
void bge_vpd_read_res	__P((struct bge_softc *, struct vpd_res *, int));
void bge_vpd_read	__P((struct bge_softc *));
d168 2
a169 2
u_int32_t bge_readmem_ind	__P((struct bge_softc *, int));
void bge_writemem_ind	__P((struct bge_softc *, int, int));
d171 1
a171 1
u_int32_t bge_readreg_ind	__P((struct bge_softc *, int));
d173 1
a173 1
void bge_writereg_ind	__P((struct bge_softc *, int, int));
d175 3
a177 3
int bge_miibus_readreg	__P((struct device *, int, int));
void bge_miibus_writereg	__P((struct device *, int, int, int));
void bge_miibus_statchg	__P((struct device *));
d179 2
a180 2
void bge_reset		__P((struct bge_softc *));
void bge_phy_hack	__P((struct bge_softc *));
@


1.6
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.5 2002/01/11 01:31:21 nordin Exp $	*/
d1616 2
a1617 1
	ifp->if_snd.ifq_maxlen = BGE_TX_RING_CNT - 1;
d1982 1
a1982 1
	if (ifp->if_flags & IFF_RUNNING && ifp->if_snd.ifq_head != NULL)
d2014 1
a2014 1
			if (ifp->if_snd.ifq_head != NULL)
d2029 1
a2029 1
		if (ifp->if_snd.ifq_head != NULL)
d2173 1
d2183 1
a2183 1
		IF_DEQUEUE(&ifp->if_snd, m_head);
a2199 1
				IF_PREPEND(&ifp->if_snd, m_head);
a2211 1
			IF_PREPEND(&ifp->if_snd, m_head);
d2216 4
d2227 2
@


1.5
log
@Check result from malloc(9) when using M_NOWAIT. fgsch@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.4 2001/12/24 18:30:43 mickey Exp $	*/
d2532 1
a2532 1
	(void)splx(s);
@


1.4
log
@fix // comment, kill some dangling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.3 2001/10/09 21:16:20 nate Exp $	*/
d303 2
d320 2
@


1.3
log
@Make bge use busdma
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.2 2001/10/09 20:34:54 nate Exp $	*/
d39 1
a39 1
 * 
d59 1
a59 1
 * 
d298 2
a299 2
                return;
        }
d312 1
a312 1
		       sc->bge_dev.dv_xname, VPD_RES_READ, res.vr_id);
d366 1
a366 1
        *dest = (byte >> ((addr % 4) * 8)) & 0xFF;
d511 1
a511 1
		       sc->bge_dev.dv_xname, BGE_JMEM);
d516 1
a516 1
			      BUS_DMA_NOWAIT, &sc->bge_cdata.bge_rx_jumbo_map)) {
d530 1
a530 1
        }
d545 2
a546 2
		entry = malloc(sizeof(struct bge_jpool_entry), 
			       M_DEVBUF, M_NOWAIT);
d556 1
a556 1
			       sc->bge_dev.dv_xname);
d575 1
a575 1
	
d577 1
a577 1
	
d641 1
a641 1
			       "-- packet dropped!\n", sc->bge_dev.dv_xname);
d648 1
a648 1
			       "-- packet dropped!\n", sc->bge_dev.dv_xname);
d693 1
a693 1
			       "-- packet dropped!\n", sc->bge_dev.dv_xname);
d702 1
a702 1
			       "-- packet dropped!\n", sc->bge_dev.dv_xname);
d741 2
a742 3
		if (bus_dmamap_create(sc->bge_dmatag, MCLBYTES, 1,
				      MCLBYTES, 0, BUS_DMA_NOWAIT,
				      &sc->bge_cdata.bge_rx_std_map[i]))
d782 1
a782 1
	
d850 1
a850 2
				      MCLBYTES, 0, BUS_DMA_NOWAIT,
				      &sc->bge_cdata.bge_tx_map[i]))
d883 1
a883 1
	struct ether_multi      *enm;
d931 1
a931 1
		       BGE_BIGENDIAN_INIT);
d934 1
a934 1
		       BGE_LITTLEENDIAN_INIT);
d943 1
a943 1
		       sc->bge_dev.dv_xname);
d964 1
a964 1
		       BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD|0x0F);
d979 2
a980 2
//		    |BGE_MODECTL_TX_NO_PHDR_CSUM|
//		    BGE_MODECTL_RX_NO_PHDR_CSUM
d1026 2
a1027 2
				       "supported; disabling PCI MWI\n",
				       sc->bge_dev.dv_xname, cachesize);
d1038 3
a1040 3
	 * for DMA reads.  Our highest limit is 1K bytes.  This is a 
	 * restriction on some ALPHA platforms with early revision 
	 * 21174 PCI chipsets, such as the AlphaPC 164lx 
d1103 1
a1103 1
		       sc->bge_dev.dv_xname);
d1120 1
a1120 1
		       sc->bge_dev.dv_xname);
d1190 1
a1190 1
	
d1338 1
a1338 1
	
d1473 1
a1473 1
		       sc->bge_dev.dv_xname);
d1490 1
a1490 1
	
d1504 1
a1504 1
					      sc->bge_dev.dv_xname);
d1521 1
a1521 1
		       sc->bge_dev.dv_xname);
d1542 1
a1542 1
	       ether_sprintf(sc->arpcom.ac_enaddr));
d1557 1
a1557 1
		       sc->bge_dev.dv_xname, sizeof(struct bge_ring_data));
d1563 2
a1564 2
			      sizeof(struct bge_ring_data), 0,
			      BUS_DMA_NOWAIT, &sc->bge_ring_map)) {
d1590 1
a1590 1
		       sc->bge_dev.dv_xname);
d1637 1
a1637 1
		
d1670 2
a1671 2
        if (sc->bge_intrhand != NULL)
                bus_teardown_intr(dev, sc->bge_irq, sc->bge_intrhand);
d1673 1
a1673 1
        if (sc->bge_irq != NULL)
d1676 1
a1676 1
        if (sc->bge_res != NULL)
d1680 1
a1680 1
        if (sc->bge_rdata != NULL)
d1700 2
a1701 2
	       BGE_PCIMISCCTL_INDIRECT_ACCESS|BGE_PCIMISCCTL_MASK_PCI_INTR|
	       BGE_PCIMISCCTL_ENDIAN_WORDSWAP|BGE_PCIMISCCTL_PCISTATE_RW);
d1734 1
a1734 1
	
d1737 1
a1737 1
		       sc->bge_dev.dv_xname);
d1796 1
a1796 1
		int                     sumflags = 0;
d1854 2
a1855 2
	 	 * Handle BPF listeners. Let the BPF user see the packet.
	 	 */
d2017 1
a2017 1
 
d2023 1
a2023 2
			printf("%s: gigabit link up\n",
			       sc->bge_dev.dv_xname);
d2044 1
a2044 1
	   READ_STAT(sc, stats, dot3StatsExcessiveCollisions.bge_addr_lo) + 
d2104 1
a2104 1
 	 * Start packing the mbufs in this chain into
d2106 1
a2106 1
 	 * of fragments or hit the end of the mbuf chain.
d2276 1
a2276 1
        int s;
d2423 1
a2423 1
			ifmr->ifm_active |= IFM_HDX;	
d2466 1
a2466 1
                }
d2515 1
a2515 1
					      command);
d2519 1
a2519 1
					      command);
d2650 1
a2650 1
	bge_stop(sc); 
@


1.3.6.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.5 2002/01/11 01:31:21 nordin Exp $	*/
d39 1
a39 1
 *
d59 1
a59 1
 *
d298 2
a299 2
		return;
	}
a302 2
	if (sc->bge_vpd_prodname == NULL)
		panic("bge_vpd_read");
d312 1
a312 1
		    sc->bge_dev.dv_xname, VPD_RES_READ, res.vr_id);
a317 2
	if (sc->bge_vpd_readonly == NULL)
		panic("bge_vpd_read");
d366 1
a366 1
	*dest = (byte >> ((addr % 4) * 8)) & 0xFF;
d511 1
a511 1
		    sc->bge_dev.dv_xname, BGE_JMEM);
d516 1
a516 1
	    BUS_DMA_NOWAIT, &sc->bge_cdata.bge_rx_jumbo_map)) {
d530 1
a530 1
	}
d545 2
a546 2
		entry = malloc(sizeof(struct bge_jpool_entry),
		    M_DEVBUF, M_NOWAIT);
d556 1
a556 1
			    sc->bge_dev.dv_xname);
d575 1
a575 1

d577 1
a577 1

d641 1
a641 1
			    "-- packet dropped!\n", sc->bge_dev.dv_xname);
d648 1
a648 1
			    "-- packet dropped!\n", sc->bge_dev.dv_xname);
d693 1
a693 1
			    "-- packet dropped!\n", sc->bge_dev.dv_xname);
d702 1
a702 1
			    "-- packet dropped!\n", sc->bge_dev.dv_xname);
d741 3
a743 2
		if (bus_dmamap_create(sc->bge_dmatag, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT, &sc->bge_cdata.bge_rx_std_map[i]))
d783 1
a783 1

d851 2
a852 1
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &sc->bge_cdata.bge_tx_map[i]))
d885 1
a885 1
	struct ether_multi	*enm;
d933 1
a933 1
	    BGE_BIGENDIAN_INIT);
d936 1
a936 1
	    BGE_LITTLEENDIAN_INIT);
d945 1
a945 1
		    sc->bge_dev.dv_xname);
d966 1
a966 1
	    BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD|0x0F);
d981 2
a982 2
/*		    |BGE_MODECTL_TX_NO_PHDR_CSUM| */
/*		    BGE_MODECTL_RX_NO_PHDR_CSUM */
d1028 2
a1029 2
				    "supported; disabling PCI MWI\n",
				    sc->bge_dev.dv_xname, cachesize);
d1040 3
a1042 3
	 * for DMA reads.  Our highest limit is 1K bytes.  This is a
	 * restriction on some ALPHA platforms with early revision
	 * 21174 PCI chipsets, such as the AlphaPC 164lx
d1105 1
a1105 1
		    sc->bge_dev.dv_xname);
d1122 1
a1122 1
		    sc->bge_dev.dv_xname);
d1192 1
a1192 1

d1340 1
a1340 1

d1475 1
a1475 1
		    sc->bge_dev.dv_xname);
d1492 1
a1492 1

d1506 1
a1506 1
	    sc->bge_dev.dv_xname);
d1523 1
a1523 1
		    sc->bge_dev.dv_xname);
d1544 1
a1544 1
	    ether_sprintf(sc->arpcom.ac_enaddr));
d1559 1
a1559 1
		    sc->bge_dev.dv_xname, sizeof(struct bge_ring_data));
d1565 2
a1566 2
	    sizeof(struct bge_ring_data), 0,
	    BUS_DMA_NOWAIT, &sc->bge_ring_map)) {
d1592 1
a1592 1
		    sc->bge_dev.dv_xname);
d1639 1
a1639 1

d1672 2
a1673 2
	if (sc->bge_intrhand != NULL)
		bus_teardown_intr(dev, sc->bge_irq, sc->bge_intrhand);
d1675 1
a1675 1
	if (sc->bge_irq != NULL)
d1678 1
a1678 1
	if (sc->bge_res != NULL)
d1682 1
a1682 1
	if (sc->bge_rdata != NULL)
d1702 2
a1703 2
	    BGE_PCIMISCCTL_INDIRECT_ACCESS|BGE_PCIMISCCTL_MASK_PCI_INTR|
	    BGE_PCIMISCCTL_ENDIAN_WORDSWAP|BGE_PCIMISCCTL_PCISTATE_RW);
d1736 1
a1736 1

d1739 1
a1739 1
		    sc->bge_dev.dv_xname);
d1798 1
a1798 1
		int			sumflags = 0;
d1856 2
a1857 2
		 * Handle BPF listeners. Let the BPF user see the packet.
		 */
d2019 1
a2019 1

d2025 2
a2026 1
			printf("%s: gigabit link up\n", sc->bge_dev.dv_xname);
d2047 1
a2047 1
	   READ_STAT(sc, stats, dot3StatsExcessiveCollisions.bge_addr_lo) +
d2107 1
a2107 1
	 * Start packing the mbufs in this chain into
d2109 1
a2109 1
	 * of fragments or hit the end of the mbuf chain.
d2279 1
a2279 1
	int s;
d2426 1
a2426 1
			ifmr->ifm_active |= IFM_HDX;
d2469 1
a2469 1
		}
d2518 1
a2518 1
			    command);
d2522 1
a2522 1
			    command);
d2653 1
a2653 1
	bge_stop(sc);
@


1.3.6.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.3.6.1 2002/01/31 22:55:35 niklas Exp $	*/
d34 1
a34 1
 * $FreeBSD: if_bge.c,v 1.11 2002/04/04 06:01:31 wpaul Exp $
d120 47
a166 39
int bge_probe(struct device *, void *, void *);
void bge_attach(struct device *, struct device *, void *);
void bge_release_resources(struct bge_softc *);
void bge_txeof(struct bge_softc *);
void bge_rxeof(struct bge_softc *);

void bge_tick(void *);
void bge_stats_update(struct bge_softc *);
int bge_encap(struct bge_softc *, struct mbuf *, u_int32_t *);

int bge_intr(void *);
void bge_start(struct ifnet *);
int bge_ioctl(struct ifnet *, u_long, caddr_t);
void bge_init(void *);
void bge_stop(struct bge_softc *);
void bge_watchdog(struct ifnet *);
void bge_shutdown(void *);
int bge_ifmedia_upd(struct ifnet *);
void bge_ifmedia_sts(struct ifnet *, struct ifmediareq *);

u_int8_t bge_eeprom_getbyte(struct bge_softc *, int, u_int8_t *);
int bge_read_eeprom(struct bge_softc *, caddr_t, int, int);

u_int32_t bge_crc(struct bge_softc *, caddr_t);
void bge_setmulti(struct bge_softc *);

void bge_handle_events(struct bge_softc *);
int bge_alloc_jumbo_mem(struct bge_softc *);
void bge_free_jumbo_mem(struct bge_softc *);
void *bge_jalloc(struct bge_softc *);
void bge_jfree(caddr_t, u_int, void *);
int bge_newbuf_std(struct bge_softc *, int, struct mbuf *);
int bge_newbuf_jumbo(struct bge_softc *, int, struct mbuf *);
int bge_init_rx_ring_std(struct bge_softc *);
void bge_free_rx_ring_std(struct bge_softc *);
int bge_init_rx_ring_jumbo(struct bge_softc *);
void bge_free_rx_ring_jumbo(struct bge_softc *);
void bge_free_tx_ring(struct bge_softc *);
int bge_init_tx_ring(struct bge_softc *);
d168 2
a169 11
int bge_chipinit(struct bge_softc *);
int bge_blockinit(struct bge_softc *);

#ifdef notdef
u_int8_t bge_vpd_readbyte(struct bge_softc *, int);
void bge_vpd_read_res(struct bge_softc *, struct vpd_res *, int);
void bge_vpd_read(struct bge_softc *);
#endif

u_int32_t bge_readmem_ind(struct bge_softc *, int);
void bge_writemem_ind(struct bge_softc *, int, int);
d171 1
a171 1
u_int32_t bge_readreg_ind(struct bge_softc *, int);
d173 1
a173 1
void bge_writereg_ind(struct bge_softc *, int, int);
d175 3
a177 3
int bge_miibus_readreg(struct device *, int, int);
void bge_miibus_writereg(struct device *, int, int, int);
void bge_miibus_statchg(struct device *);
d179 2
a180 2
void bge_reset(struct bge_softc *);
void bge_phy_hack(struct bge_softc *);
a237 1
#ifdef notdef
a324 1
#endif
d410 2
a411 2
	if (sc->bge_asicrev == BGE_ASICREV_BCM5701_B5 && phy != 1)
		return(0);
d429 3
d644 2
d651 2
d696 2
d1389 1
a1389 1
 	} else {
a1390 4
		if (sc->bge_asicrev == BGE_ASICREV_BCM5700)
			CSR_WRITE_4(sc, BGE_MAC_EVT_ENB,
			    BGE_EVTENB_MI_INTERRUPT);
	}
a1426 4
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ALTIMA &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ALTIMA_AC100X)
		return (1);

a1456 1
	u_int32_t		hwcfg = 0;
d1545 1
a1545 1
	printf(": address: %s\n",
d1616 1
a1616 2
	IFQ_SET_MAXLEN(&ifp->if_snd, BGE_TX_RING_CNT - 1);
	IFQ_SET_READY(&ifp->if_snd);
a1628 22
	/* Save ASIC rev. */

	sc->bge_asicrev =
	    pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_MISC_CTL) &
	    BGE_PCIMISCCTL_ASICREV;

	/* Pretend all 5700s are the same */
	if ((sc->bge_asicrev & 0xFF000000) == BGE_ASICREV_BCM5700)
		sc->bge_asicrev = BGE_ASICREV_BCM5700;

	/*
	 * Figure out what sort of media we have by checking the
	 * hardware config word in the EEPROM. Note: on some BCM5700
	 * cards, this value appears to be unset. If that's the
	 * case, we have to rely on identifying the NIC by its PCI
	 * subsystem ID, as we do below for the SysKonnect SK-9D41.
	 */
	bge_read_eeprom(sc, (caddr_t)&hwcfg,
		    BGE_EE_HWCFG_OFFSET, sizeof(hwcfg));
	if ((ntohl(hwcfg) & BGE_HWCFG_MEDIA) == BGE_MEDIA_FIBER)
		sc->bge_tbi = 1;

d1634 11
a1644 5
	if (sc->bge_tbi) {
		ifmedia_init(&sc->bge_ifmedia, IFM_IMASK, bge_ifmedia_upd,
		    bge_ifmedia_sts);
		ifmedia_add(&sc->bge_ifmedia, IFM_ETHER|IFM_1000_SX, 0, NULL);
		ifmedia_add(&sc->bge_ifmedia, IFM_ETHER|IFM_1000_SX|IFM_FDX,
d1646 3
a1648 21
		ifmedia_add(&sc->bge_ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);
		ifmedia_set(&sc->bge_ifmedia, IFM_ETHER|IFM_AUTO);
	} else {
		/*
		 * Do transceiver setup.
		 */
		ifmedia_init(&sc->bge_mii.mii_media, 0, bge_ifmedia_upd,
			     bge_ifmedia_sts);
		mii_attach(&sc->bge_dev, &sc->bge_mii, 0xffffffff,
			   MII_PHY_ANY, MII_OFFSET_ANY, 0);
		
		if (LIST_FIRST(&sc->bge_mii.mii_phys) == NULL) {
			printf("%s: no PHY found!\n", sc->bge_dev.dv_xname);
			ifmedia_add(&sc->bge_mii.mii_media,
				    IFM_ETHER|IFM_MANUAL, 0, NULL);
			ifmedia_set(&sc->bge_mii.mii_media,
				    IFM_ETHER|IFM_MANUAL);
		} else
			ifmedia_set(&sc->bge_mii.mii_media,
				    IFM_ETHER|IFM_AUTO);
	}
d1956 10
a1965 37
	/*
	 * Process link state changes.
	 * Grrr. The link status word in the status block does
	 * not work correctly on the BCM5700 rev AX and BX chips,
	 * according to all avaibable information. Hence, we have
	 * to enable MII interrupts in order to properly obtain
	 * async link changes. Unfortunately, this also means that
	 * we have to read the MAC status register to detect link
	 * changes, thereby adding an additional register access to
	 * the interrupt handler.
	 */

	if (sc->bge_asicrev == BGE_ASICREV_BCM5700) {
		u_int32_t		status;

		status = CSR_READ_4(sc, BGE_MAC_STS);
		if (status & BGE_MACSTAT_MI_INTERRUPT) {
			sc->bge_link = 0;
			timeout_del(&sc->bge_timeout);
			bge_tick(sc);
			/* Clear the interrupt */
			CSR_WRITE_4(sc, BGE_MAC_EVT_ENB,
			    BGE_EVTENB_MI_INTERRUPT);
			bge_miibus_readreg(&sc->bge_dev, 1, BRGPHY_MII_ISR);
			bge_miibus_writereg(&sc->bge_dev, 1, BRGPHY_MII_IMR,
			    BRGPHY_INTRS);
		}
	} else {
		if (sc->bge_rdata->bge_status_block.bge_status &
		    BGE_STATFLAG_LINKSTATE_CHANGED) {
			sc->bge_link = 0;
			timeout_del(&sc->bge_timeout);
			bge_tick(sc);
			/* Clear the interrupt */
			CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED|
			    BGE_MACSTAT_CFG_CHANGED);
		}
d1981 1
a1981 1
	if (ifp->if_flags & IFF_RUNNING && !IFQ_IS_EMPTY(&ifp->if_snd))
d2013 1
a2013 1
			if (!IFQ_IS_EMPTY(&ifp->if_snd))
d2028 1
a2028 1
		if (!IFQ_IS_EMPTY(&ifp->if_snd))
d2075 1
d2088 1
d2113 2
a2114 2
	if (bus_dmamap_load_mbuf(sc->bge_dmatag, txmap, m_head,
	    BUS_DMA_NOWAIT))
d2117 9
a2125 7
	for (i = 0; i < txmap->dm_nsegs; i++) {
		f = &sc->bge_rdata->bge_tx_ring[frag];
		if (sc->bge_cdata.bge_tx_chain[frag] != NULL)
			break;
		BGE_HOSTADDR(f->bge_addr) = txmap->dm_segs[i].ds_addr;
		f->bge_len = txmap->dm_segs[i].ds_len;
		f->bge_flags = csum_flags;
d2127 16
a2142 5
		if (ifv != NULL) {
			f->bge_flags |= BGE_TXBDFLAG_VLAN_TAG;
			f->bge_vlan_tag = ifv->ifv_tag;
		} else {
			f->bge_vlan_tag = 0;
a2143 10
#endif
		/*
		 * Sanity check: avoid coming within 16 descriptors
		 * of the end of the ring.
		 */
		if ((BGE_TX_RING_CNT - (sc->bge_txcnt + cnt)) < 16)
			return(ENOBUFS);
		cur = frag;
		BGE_INC(frag, BGE_TX_RING_CNT);
		cnt++;
d2146 3
a2171 1
	int pkts = 0;
d2181 1
a2181 1
		IFQ_POLL(&ifp->if_snd, m_head);
d2198 1
d2211 1
a2215 5
		/* now we are committed to transmit the packet */
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
		pkts++;

#if NBPFILTER > 0
a2221 1
#endif
a2222 2
	if (pkts == 0)
		return;
d2532 1
a2532 1
	splx(s);
@


1.3.6.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.3.6.2 2002/06/11 03:42:25 art Exp $	*/
d1815 1
a1815 1
 * 1) the frame is from the jumbo receive ring
d2077 1
d2090 3
@


1.3.6.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
 * $FreeBSD: if_bge.c,v 1.25 2002/11/14 23:54:49 sam Exp $
d58 1
a58 1
 * function in a 32-bit/64-bit 33/66MHz bus, or a 64-bit/133MHz bus.
d61 1
a61 1
 * MAC and a BCM5401 10/100/1000 PHY. Unlike the BCM5700, the BCM5701
d143 1
a143 1
u_int32_t bge_crc(caddr_t);
a192 25
/*
 * Various supported device vendors/types and their names. Note: the
 * spec seems to indicate that the hardware still has Alteon's vendor
 * ID burned into it, though it will always be overriden by the vendor
 * ID in the EEPROM. Just to be safe, we cover all possibilities.
 */
const struct pci_matchid bge_devices[] = {
	{ PCI_VENDOR_ALTEON, PCI_PRODUCT_ALTEON_BCM5700 },
	{ PCI_VENDOR_ALTEON, PCI_PRODUCT_ALTEON_BCM5701 },

	{ PCI_VENDOR_ALTIMA, PCI_PRODUCT_ALTIMA_AC100X },
	{ PCI_VENDOR_ALTIMA, PCI_PRODUCT_ALTIMA_AC9100 },

	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5700 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5701 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5702 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5703 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5702X },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5703X },

	{ PCI_VENDOR_SCHNEIDERKOCH, PCI_PRODUCT_SCHNEIDERKOCH_SK9D21 },

	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C996 },
};

d413 2
a414 6
	if (phy != 1)
		switch(sc->bge_asicrev) {
		case BGE_ASICREV_BCM5701_B5:
		case BGE_ASICREV_BCM5703_A2:
			return(0);
		}
d467 1
a467 1
	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T) {
d613 2
a614 2
	i = ((vaddr_t)buf
	     - (vaddr_t)sc->bge_cdata.bge_jumbo_buf) / BGE_JLEN;
d662 1
a662 2
	if (!sc->bge_rx_alignment_bug)
		m_adj(m_new, ETHER_ALIGN);
d665 1
a665 2
	BGE_HOSTADDR(r->bge_addr) = rxmap->dm_segs[0].ds_addr +
	    (!sc->bge_rx_alignment_bug ? ETHER_ALIGN : 0);
d713 1
a713 2
	if (!sc->bge_rx_alignment_bug)
		m_adj(m_new, ETHER_ALIGN);
d717 2
a718 2
	BGE_HOSTADDR(r->bge_addr) = BGE_JUMBO_DMA_ADDR(sc, m_new) +
	    (!sc->bge_rx_alignment_bug ? ETHER_ALIGN : 0);
d858 2
a859 1
bge_crc(addr)
d900 1
a900 1
		h = bge_crc(LLADDR((struct sockaddr_dl *)enm->enm_addrlo));
d917 1
d961 2
a962 10
	if (pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE) &
	    BGE_PCISTATE_PCI_BUSMODE) {
		/* Conventional PCI bus */
		pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL,
		    BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD|0x3F000F);
	} else {
		/* PCI-X bus */
		pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL,
		    BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD|0x1B000F);
	}
d982 3
d986 1
a986 2
	 * Disable memory write invalidate.  Apparently it is not supported
	 * properly by these devices.
d988 44
a1031 2
	PCI_CLRBIT(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    PCI_COMMAND_INVALIDATE_ENABLE);
d1040 1
a1040 2
	PCI_SETBIT(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL,
	    BGE_PCI_READ_BNDRY_1024);
d1043 1
a1043 1
	/* Set the timer prescaler (always 66MHz) */
d1055 1
a1055 1
	vaddr_t			rcb_addr;
d1410 33
a1442 2
	return (pci_matchbyid((struct pci_attach_args *)aux, bge_devices,
	    sizeof(bge_devices)/sizeof(bge_devices[0])));
a1459 1
	u_int32_t		mac_addr = 0;
d1537 1
a1537 10
	mac_addr = bge_readmem_ind(sc, 0x0c14);
	if ((mac_addr >> 16) == 0x484b) {
		sc->arpcom.ac_enaddr[0] = (u_char)(mac_addr >> 8);
		sc->arpcom.ac_enaddr[1] = (u_char)mac_addr;
		mac_addr = bge_readmem_ind(sc, 0x0c18);
		sc->arpcom.ac_enaddr[2] = (u_char)(mac_addr >> 24);
		sc->arpcom.ac_enaddr[3] = (u_char)(mac_addr >> 16);
		sc->arpcom.ac_enaddr[4] = (u_char)(mac_addr >> 8);
		sc->arpcom.ac_enaddr[5] = (u_char)mac_addr;
	} else if (bge_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
d1636 1
a1636 1
	    pci_conf_read(pc, pa->pa_tag, BGE_PCI_MISC_CTL) &
d1656 1
a1656 1
	if ((pci_conf_read(pc, pa->pa_tag, BGE_PCI_SUBSYS) >> 16) ==
a1688 21
	 * When using the BCM5701 in PCI-X mode, data corruption has
	 * been observed in the first few bytes of some received packets.
	 * Aligning the packet buffer in memory eliminates the corruption.
	 * Unfortunately, this misaligns the packet payloads.  On platforms
	 * which do not support unaligned accesses, we will realign the
	 * payloads by copying the received packets.
	 */
	switch (sc->bge_asicrev) {
	case BGE_ASICREV_BCM5701_A0:
	case BGE_ASICREV_BCM5701_B0:
	case BGE_ASICREV_BCM5701_B2:
	case BGE_ASICREV_BCM5701_B5:
		/* If in PCI-X mode, work around the alignment bug. */
		if ((pci_conf_read(pc, pa->pa_tag, BGE_PCI_PCISTATE) &
		    (BGE_PCISTATE_PCI_BUSMODE | BGE_PCISTATE_PCI_BUSSPEED)) ==
		    BGE_PCISTATE_PCI_BUSSPEED)
			sc->bge_rx_alignment_bug = 1;
		break;
	}

	/*
a1890 11
#ifdef __STRICT_ALIGNMENT
		/*
		 * The i386 allows unaligned accesses, but for other
		 * platforms we must make sure the payload is aligned.
		 */
		if (sc->bge_rx_alignment_bug) {
			bcopy(m->m_data, m->m_data + ETHER_ALIGN,
			    cur_rx->bge_len);
			m->m_data += ETHER_ALIGN;
		}
#endif
d2346 1
a2346 2
	if (ifp->if_flags & IFF_RUNNING) {
		splx(s);
a2347 1
	}
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@Merge in trunk
@
text
@d39 1
a39 1
 *
d59 1
a59 1
 *
d298 2
a299 2
		return;
	}
a302 2
	if (sc->bge_vpd_prodname == NULL)
		panic("bge_vpd_read");
d312 1
a312 1
		    sc->bge_dev.dv_xname, VPD_RES_READ, res.vr_id);
a317 2
	if (sc->bge_vpd_readonly == NULL)
		panic("bge_vpd_read");
d366 1
a366 1
	*dest = (byte >> ((addr % 4) * 8)) & 0xFF;
d511 1
a511 1
		    sc->bge_dev.dv_xname, BGE_JMEM);
d516 1
a516 1
	    BUS_DMA_NOWAIT, &sc->bge_cdata.bge_rx_jumbo_map)) {
d530 1
a530 1
	}
d545 2
a546 2
		entry = malloc(sizeof(struct bge_jpool_entry),
		    M_DEVBUF, M_NOWAIT);
d556 1
a556 1
			    sc->bge_dev.dv_xname);
d575 1
a575 1

d577 1
a577 1

d641 1
a641 1
			    "-- packet dropped!\n", sc->bge_dev.dv_xname);
d648 1
a648 1
			    "-- packet dropped!\n", sc->bge_dev.dv_xname);
d693 1
a693 1
			    "-- packet dropped!\n", sc->bge_dev.dv_xname);
d702 1
a702 1
			    "-- packet dropped!\n", sc->bge_dev.dv_xname);
d741 3
a743 2
		if (bus_dmamap_create(sc->bge_dmatag, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT, &sc->bge_cdata.bge_rx_std_map[i]))
d783 1
a783 1

d851 2
a852 1
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &sc->bge_cdata.bge_tx_map[i]))
d885 1
a885 1
	struct ether_multi	*enm;
d933 1
a933 1
	    BGE_BIGENDIAN_INIT);
d936 1
a936 1
	    BGE_LITTLEENDIAN_INIT);
d945 1
a945 1
		    sc->bge_dev.dv_xname);
d966 1
a966 1
	    BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD|0x0F);
d981 2
a982 2
/*		    |BGE_MODECTL_TX_NO_PHDR_CSUM| */
/*		    BGE_MODECTL_RX_NO_PHDR_CSUM */
d1028 2
a1029 2
				    "supported; disabling PCI MWI\n",
				    sc->bge_dev.dv_xname, cachesize);
d1040 3
a1042 3
	 * for DMA reads.  Our highest limit is 1K bytes.  This is a
	 * restriction on some ALPHA platforms with early revision
	 * 21174 PCI chipsets, such as the AlphaPC 164lx
d1105 1
a1105 1
		    sc->bge_dev.dv_xname);
d1122 1
a1122 1
		    sc->bge_dev.dv_xname);
d1192 1
a1192 1

d1340 1
a1340 1

d1475 1
a1475 1
		    sc->bge_dev.dv_xname);
d1492 1
a1492 1

d1506 1
a1506 1
	    sc->bge_dev.dv_xname);
d1523 1
a1523 1
		    sc->bge_dev.dv_xname);
d1544 1
a1544 1
	    ether_sprintf(sc->arpcom.ac_enaddr));
d1559 1
a1559 1
		    sc->bge_dev.dv_xname, sizeof(struct bge_ring_data));
d1565 2
a1566 2
	    sizeof(struct bge_ring_data), 0,
	    BUS_DMA_NOWAIT, &sc->bge_ring_map)) {
d1592 1
a1592 1
		    sc->bge_dev.dv_xname);
d1639 1
a1639 1

d1672 2
a1673 2
	if (sc->bge_intrhand != NULL)
		bus_teardown_intr(dev, sc->bge_irq, sc->bge_intrhand);
d1675 1
a1675 1
	if (sc->bge_irq != NULL)
d1678 1
a1678 1
	if (sc->bge_res != NULL)
d1682 1
a1682 1
	if (sc->bge_rdata != NULL)
d1702 2
a1703 2
	    BGE_PCIMISCCTL_INDIRECT_ACCESS|BGE_PCIMISCCTL_MASK_PCI_INTR|
	    BGE_PCIMISCCTL_ENDIAN_WORDSWAP|BGE_PCIMISCCTL_PCISTATE_RW);
d1736 1
a1736 1

d1739 1
a1739 1
		    sc->bge_dev.dv_xname);
d1798 1
a1798 1
		int			sumflags = 0;
d1856 2
a1857 2
		 * Handle BPF listeners. Let the BPF user see the packet.
		 */
d2019 1
a2019 1

d2025 2
a2026 1
			printf("%s: gigabit link up\n", sc->bge_dev.dv_xname);
d2047 1
a2047 1
	   READ_STAT(sc, stats, dot3StatsExcessiveCollisions.bge_addr_lo) +
d2107 1
a2107 1
	 * Start packing the mbufs in this chain into
d2109 1
a2109 1
	 * of fragments or hit the end of the mbuf chain.
d2279 1
a2279 1
	int s;
d2426 1
a2426 1
			ifmr->ifm_active |= IFM_HDX;
d2469 1
a2469 1
		}
d2518 1
a2518 1
			    command);
d2522 1
a2522 1
			    command);
d2531 1
a2531 1
	splx(s);
d2653 1
a2653 1
	bge_stop(sc);
@


1.3.4.3
log
@Merge in -current from roughly a week ago
@
text
@d120 47
a166 47
int bge_probe(struct device *, void *, void *);
void bge_attach(struct device *, struct device *, void *);
void bge_release_resources(struct bge_softc *);
void bge_txeof(struct bge_softc *);
void bge_rxeof(struct bge_softc *);

void bge_tick(void *);
void bge_stats_update(struct bge_softc *);
int bge_encap(struct bge_softc *, struct mbuf *, u_int32_t *);

int bge_intr(void *);
void bge_start(struct ifnet *);
int bge_ioctl(struct ifnet *, u_long, caddr_t);
void bge_init(void *);
void bge_stop(struct bge_softc *);
void bge_watchdog(struct ifnet *);
void bge_shutdown(void *);
int bge_ifmedia_upd(struct ifnet *);
void bge_ifmedia_sts(struct ifnet *, struct ifmediareq *);

u_int8_t	bge_eeprom_getbyte(struct bge_softc *,
					     int, u_int8_t *);
int bge_read_eeprom(struct bge_softc *, caddr_t, int, int);

u_int32_t bge_crc(struct bge_softc *, caddr_t);
void bge_setmulti(struct bge_softc *);

void bge_handle_events(struct bge_softc *);
int bge_alloc_jumbo_mem(struct bge_softc *);
void bge_free_jumbo_mem(struct bge_softc *);
void *bge_jalloc(struct bge_softc *);
void bge_jfree(caddr_t, u_int, void *);
int bge_newbuf_std(struct bge_softc *, int, struct mbuf *);
int bge_newbuf_jumbo(struct bge_softc *, int, struct mbuf *);
int bge_init_rx_ring_std(struct bge_softc *);
void bge_free_rx_ring_std(struct bge_softc *);
int bge_init_rx_ring_jumbo(struct bge_softc *);
void bge_free_rx_ring_jumbo(struct bge_softc *);
void bge_free_tx_ring(struct bge_softc *);
int bge_init_tx_ring(struct bge_softc *);

int bge_chipinit(struct bge_softc *);
int bge_blockinit(struct bge_softc *);

u_int8_t bge_vpd_readbyte(struct bge_softc *, int);
void bge_vpd_read_res(struct bge_softc *, struct vpd_res *, int);
void bge_vpd_read(struct bge_softc *);
d168 2
a169 2
u_int32_t bge_readmem_ind(struct bge_softc *, int);
void bge_writemem_ind(struct bge_softc *, int, int);
d171 1
a171 1
u_int32_t bge_readreg_ind(struct bge_softc *, int);
d173 1
a173 1
void bge_writereg_ind(struct bge_softc *, int, int);
d175 3
a177 3
int bge_miibus_readreg(struct device *, int, int);
void bge_miibus_writereg(struct device *, int, int, int);
void bge_miibus_statchg(struct device *);
d179 2
a180 2
void bge_reset(struct bge_softc *);
void bge_phy_hack(struct bge_softc *);
d1616 1
a1616 2
	IFQ_SET_MAXLEN(&ifp->if_snd, BGE_TX_RING_CNT - 1);
	IFQ_SET_READY(&ifp->if_snd);
d1981 1
a1981 1
	if (ifp->if_flags & IFF_RUNNING && !IFQ_IS_EMPTY(&ifp->if_snd))
d2013 1
a2013 1
			if (!IFQ_IS_EMPTY(&ifp->if_snd))
d2028 1
a2028 1
		if (!IFQ_IS_EMPTY(&ifp->if_snd))
a2171 1
	int pkts = 0;
d2181 1
a2181 1
		IFQ_POLL(&ifp->if_snd, m_head);
d2198 1
d2211 1
a2215 4
		/* now we are committed to transmit the packet */
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
		pkts++;

a2222 2
	if (pkts == 0)
		return;
@


1.3.4.4
log
@Sync the SMP branch with 3.3
@
text
@d34 1
a34 1
 * $FreeBSD: if_bge.c,v 1.25 2002/11/14 23:54:49 sam Exp $
d58 1
a58 1
 * function in a 32-bit/64-bit 33/66MHz bus, or a 64-bit/133MHz bus.
d61 1
a61 1
 * MAC and a BCM5401 10/100/1000 PHY. Unlike the BCM5700, the BCM5701
d140 2
a141 1
u_int8_t bge_eeprom_getbyte(struct bge_softc *, int, u_int8_t *);
d144 1
a144 1
u_int32_t bge_crc(caddr_t);
a163 1
#ifdef notdef
a166 1
#endif
a191 25
/*
 * Various supported device vendors/types and their names. Note: the
 * spec seems to indicate that the hardware still has Alteon's vendor
 * ID burned into it, though it will always be overriden by the vendor
 * ID in the EEPROM. Just to be safe, we cover all possibilities.
 */
const struct pci_matchid bge_devices[] = {
	{ PCI_VENDOR_ALTEON, PCI_PRODUCT_ALTEON_BCM5700 },
	{ PCI_VENDOR_ALTEON, PCI_PRODUCT_ALTEON_BCM5701 },

	{ PCI_VENDOR_ALTIMA, PCI_PRODUCT_ALTIMA_AC100X },
	{ PCI_VENDOR_ALTIMA, PCI_PRODUCT_ALTIMA_AC9100 },

	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5700 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5701 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5702 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5703 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5702X },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5703X },

	{ PCI_VENDOR_SCHNEIDERKOCH, PCI_PRODUCT_SCHNEIDERKOCH_SK9D21 },

	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C996 },
};

a237 1
#ifdef notdef
a324 1
#endif
d410 2
a411 6
	if (phy != 1)
		switch(sc->bge_asicrev) {
		case BGE_ASICREV_BCM5701_B5:
		case BGE_ASICREV_BCM5703_A2:
			return(0);
		}
d429 3
d467 1
a467 1
	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T) {
d613 2
a614 2
	i = ((vaddr_t)buf
	     - (vaddr_t)sc->bge_cdata.bge_jumbo_buf) / BGE_JLEN;
d644 2
d651 2
d666 1
a666 2
	if (!sc->bge_rx_alignment_bug)
		m_adj(m_new, ETHER_ALIGN);
d669 1
a669 2
	BGE_HOSTADDR(r->bge_addr) = rxmap->dm_segs[0].ds_addr +
	    (!sc->bge_rx_alignment_bug ? ETHER_ALIGN : 0);
d696 2
d719 1
a719 2
	if (!sc->bge_rx_alignment_bug)
		m_adj(m_new, ETHER_ALIGN);
d723 2
a724 2
	BGE_HOSTADDR(r->bge_addr) = BGE_JUMBO_DMA_ADDR(sc, m_new) +
	    (!sc->bge_rx_alignment_bug ? ETHER_ALIGN : 0);
d864 2
a865 1
bge_crc(addr)
d906 1
a906 1
		h = bge_crc(LLADDR((struct sockaddr_dl *)enm->enm_addrlo));
d923 1
d967 2
a968 10
	if (pci_conf_read(pa->pa_pc, pa->pa_tag, BGE_PCI_PCISTATE) &
	    BGE_PCISTATE_PCI_BUSMODE) {
		/* Conventional PCI bus */
		pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL,
		    BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD|0x3F000F);
	} else {
		/* PCI-X bus */
		pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL,
		    BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD|0x1B000F);
	}
d988 3
d992 1
a992 2
	 * Disable memory write invalidate.  Apparently it is not supported
	 * properly by these devices.
d994 44
a1037 2
	PCI_CLRBIT(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    PCI_COMMAND_INVALIDATE_ENABLE);
d1046 1
a1046 2
	PCI_SETBIT(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL,
	    BGE_PCI_READ_BNDRY_1024);
d1049 1
a1049 1
	/* Set the timer prescaler (always 66MHz) */
d1061 1
a1061 1
	vaddr_t			rcb_addr;
d1389 1
a1389 1
 	} else {
a1390 4
		if (sc->bge_asicrev == BGE_ASICREV_BCM5700)
			CSR_WRITE_4(sc, BGE_MAC_EVT_ENB,
			    BGE_EVTENB_MI_INTERRUPT);
	}
d1412 29
a1440 2
	return (pci_matchbyid((struct pci_attach_args *)aux, bge_devices,
	    sizeof(bge_devices)/sizeof(bge_devices[0])));
a1456 2
	u_int32_t		hwcfg = 0;
	u_int32_t		mac_addr = 0;
d1534 1
a1534 10
	mac_addr = bge_readmem_ind(sc, 0x0c14);
	if ((mac_addr >> 16) == 0x484b) {
		sc->arpcom.ac_enaddr[0] = (u_char)(mac_addr >> 8);
		sc->arpcom.ac_enaddr[1] = (u_char)mac_addr;
		mac_addr = bge_readmem_ind(sc, 0x0c18);
		sc->arpcom.ac_enaddr[2] = (u_char)(mac_addr >> 24);
		sc->arpcom.ac_enaddr[3] = (u_char)(mac_addr >> 16);
		sc->arpcom.ac_enaddr[4] = (u_char)(mac_addr >> 8);
		sc->arpcom.ac_enaddr[5] = (u_char)mac_addr;
	} else if (bge_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
d1545 1
a1545 1
	printf(": address: %s\n",
a1629 22
	/* Save ASIC rev. */

	sc->bge_asicrev =
	    pci_conf_read(pc, pa->pa_tag, BGE_PCI_MISC_CTL) &
	    BGE_PCIMISCCTL_ASICREV;

	/* Pretend all 5700s are the same */
	if ((sc->bge_asicrev & 0xFF000000) == BGE_ASICREV_BCM5700)
		sc->bge_asicrev = BGE_ASICREV_BCM5700;

	/*
	 * Figure out what sort of media we have by checking the
	 * hardware config word in the EEPROM. Note: on some BCM5700
	 * cards, this value appears to be unset. If that's the
	 * case, we have to rely on identifying the NIC by its PCI
	 * subsystem ID, as we do below for the SysKonnect SK-9D41.
	 */
	bge_read_eeprom(sc, (caddr_t)&hwcfg,
		    BGE_EE_HWCFG_OFFSET, sizeof(hwcfg));
	if ((ntohl(hwcfg) & BGE_HWCFG_MEDIA) == BGE_MEDIA_FIBER)
		sc->bge_tbi = 1;

d1631 1
a1631 1
	if ((pci_conf_read(pc, pa->pa_tag, BGE_PCI_SUBSYS) >> 16) ==
d1635 11
a1645 5
	if (sc->bge_tbi) {
		ifmedia_init(&sc->bge_ifmedia, IFM_IMASK, bge_ifmedia_upd,
		    bge_ifmedia_sts);
		ifmedia_add(&sc->bge_ifmedia, IFM_ETHER|IFM_1000_SX, 0, NULL);
		ifmedia_add(&sc->bge_ifmedia, IFM_ETHER|IFM_1000_SX|IFM_FDX,
d1647 3
a1649 42
		ifmedia_add(&sc->bge_ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);
		ifmedia_set(&sc->bge_ifmedia, IFM_ETHER|IFM_AUTO);
	} else {
		/*
		 * Do transceiver setup.
		 */
		ifmedia_init(&sc->bge_mii.mii_media, 0, bge_ifmedia_upd,
			     bge_ifmedia_sts);
		mii_attach(&sc->bge_dev, &sc->bge_mii, 0xffffffff,
			   MII_PHY_ANY, MII_OFFSET_ANY, 0);
		
		if (LIST_FIRST(&sc->bge_mii.mii_phys) == NULL) {
			printf("%s: no PHY found!\n", sc->bge_dev.dv_xname);
			ifmedia_add(&sc->bge_mii.mii_media,
				    IFM_ETHER|IFM_MANUAL, 0, NULL);
			ifmedia_set(&sc->bge_mii.mii_media,
				    IFM_ETHER|IFM_MANUAL);
		} else
			ifmedia_set(&sc->bge_mii.mii_media,
				    IFM_ETHER|IFM_AUTO);
	}

	/*
	 * When using the BCM5701 in PCI-X mode, data corruption has
	 * been observed in the first few bytes of some received packets.
	 * Aligning the packet buffer in memory eliminates the corruption.
	 * Unfortunately, this misaligns the packet payloads.  On platforms
	 * which do not support unaligned accesses, we will realign the
	 * payloads by copying the received packets.
	 */
	switch (sc->bge_asicrev) {
	case BGE_ASICREV_BCM5701_A0:
	case BGE_ASICREV_BCM5701_B0:
	case BGE_ASICREV_BCM5701_B2:
	case BGE_ASICREV_BCM5701_B5:
		/* If in PCI-X mode, work around the alignment bug. */
		if ((pci_conf_read(pc, pa->pa_tag, BGE_PCI_PCISTATE) &
		    (BGE_PCISTATE_PCI_BUSMODE | BGE_PCISTATE_PCI_BUSSPEED)) ==
		    BGE_PCISTATE_PCI_BUSSPEED)
			sc->bge_rx_alignment_bug = 1;
		break;
	}
d1778 1
a1778 1
 * 1) the frame is from the jumbo receive ring
a1853 11
#ifdef __STRICT_ALIGNMENT
		/*
		 * The i386 allows unaligned accesses, but for other
		 * platforms we must make sure the payload is aligned.
		 */
		if (sc->bge_rx_alignment_bug) {
			bcopy(m->m_data, m->m_data + ETHER_ALIGN,
			    cur_rx->bge_len);
			m->m_data += ETHER_ALIGN;
		}
#endif
d1957 10
a1966 37
	/*
	 * Process link state changes.
	 * Grrr. The link status word in the status block does
	 * not work correctly on the BCM5700 rev AX and BX chips,
	 * according to all avaibable information. Hence, we have
	 * to enable MII interrupts in order to properly obtain
	 * async link changes. Unfortunately, this also means that
	 * we have to read the MAC status register to detect link
	 * changes, thereby adding an additional register access to
	 * the interrupt handler.
	 */

	if (sc->bge_asicrev == BGE_ASICREV_BCM5700) {
		u_int32_t		status;

		status = CSR_READ_4(sc, BGE_MAC_STS);
		if (status & BGE_MACSTAT_MI_INTERRUPT) {
			sc->bge_link = 0;
			timeout_del(&sc->bge_timeout);
			bge_tick(sc);
			/* Clear the interrupt */
			CSR_WRITE_4(sc, BGE_MAC_EVT_ENB,
			    BGE_EVTENB_MI_INTERRUPT);
			bge_miibus_readreg(&sc->bge_dev, 1, BRGPHY_MII_ISR);
			bge_miibus_writereg(&sc->bge_dev, 1, BRGPHY_MII_IMR,
			    BRGPHY_INTRS);
		}
	} else {
		if (sc->bge_rdata->bge_status_block.bge_status &
		    BGE_STATFLAG_LINKSTATE_CHANGED) {
			sc->bge_link = 0;
			timeout_del(&sc->bge_timeout);
			bge_tick(sc);
			/* Clear the interrupt */
			CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED|
			    BGE_MACSTAT_CFG_CHANGED);
		}
d2013 1
d2026 3
d2076 1
d2089 1
d2114 2
a2115 2
	if (bus_dmamap_load_mbuf(sc->bge_dmatag, txmap, m_head,
	    BUS_DMA_NOWAIT))
d2118 9
a2126 7
	for (i = 0; i < txmap->dm_nsegs; i++) {
		f = &sc->bge_rdata->bge_tx_ring[frag];
		if (sc->bge_cdata.bge_tx_chain[frag] != NULL)
			break;
		BGE_HOSTADDR(f->bge_addr) = txmap->dm_segs[i].ds_addr;
		f->bge_len = txmap->dm_segs[i].ds_len;
		f->bge_flags = csum_flags;
d2128 16
a2143 5
		if (ifv != NULL) {
			f->bge_flags |= BGE_TXBDFLAG_VLAN_TAG;
			f->bge_vlan_tag = ifv->ifv_tag;
		} else {
			f->bge_vlan_tag = 0;
a2144 10
#endif
		/*
		 * Sanity check: avoid coming within 16 descriptors
		 * of the end of the ring.
		 */
		if ((BGE_TX_RING_CNT - (sc->bge_txcnt + cnt)) < 16)
			return(ENOBUFS);
		cur = frag;
		BGE_INC(frag, BGE_TX_RING_CNT);
		cnt++;
d2147 3
a2219 1
#if NBPFILTER > 0
a2225 1
#endif
d2292 1
a2292 2
	if (ifp->if_flags & IFF_RUNNING) {
		splx(s);
a2293 1
	}
@


1.3.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a127 1
void bge_stats_update_regs(struct bge_softc *);
d181 1
d196 1
a196 1
 * ID burned into it, though it will always be overridden by the vendor
d203 1
a203 2
	{ PCI_VENDOR_ALTIMA, PCI_PRODUCT_ALTIMA_AC1000 },
	{ PCI_VENDOR_ALTIMA, PCI_PRODUCT_ALTIMA_AC1001 },
d209 1
a210 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5703 },
a211 8
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5704C },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5704S },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5705 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5705M },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5705M_ALT },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5782 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5901 },
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5901A2 },
d432 2
a433 1
	u_int32_t val, autopoll;
d436 2
a437 9
	/*
	 * Broadcom's own driver always assumes the internal
	 * PHY is at GMII address 1. On some chips, the PHY responds
	 * to accesses at all addresses, which could cause us to
	 * bogusly attach the PHY 32 times at probe type. Always
	 * restricting the lookup to address 1 is simpler than
	 * trying to figure out which chips revisions should be
	 * special-cased.
	 */
d439 5
a443 8
		return(0);

	/* Reading with autopolling on may trigger PCI errors */
	autopoll = CSR_READ_4(sc, BGE_MI_MODE);
	if (autopoll & BGE_MIMODE_AUTOPOLL) {
		BGE_CLRBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
		DELAY(40);
	}
d456 1
a456 2
		val = 0;
		goto done;
a460 6
done:
	if (autopoll & BGE_MIMODE_AUTOPOLL) {
		BGE_SETBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
		DELAY(40);
	}

a472 1
	u_int32_t autopoll;
a474 7
	/* Reading with autopolling on may trigger PCI errors */
	autopoll = CSR_READ_4(sc, BGE_MI_MODE);
	if (autopoll & BGE_MIMODE_AUTOPOLL) {
		BGE_CLRBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
		DELAY(40);
	}

a482 5
	if (autopoll & BGE_MIMODE_AUTOPOLL) {
		BGE_SETBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
		DELAY(40);
	}

d507 2
d695 2
a696 2
	BGE_HOSTADDR(r->bge_addr, rxmap->dm_segs[0].ds_addr +
	    (sc->bge_rx_alignment_bug ? 0 : ETHER_ALIGN));
d749 2
a750 2
	BGE_HOSTADDR(r->bge_addr, BGE_JUMBO_DMA_ADDR(sc, m_new) +
	    (sc->bge_rx_alignment_bug ? 0 : ETHER_ALIGN));
d811 1
d821 3
a823 2
	rcb->bge_maxlen_flags = BGE_RCB_MAXLEN_FLAGS(0, 0);
	CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_MAXLEN_FLAGS, rcb->bge_maxlen_flags);
a874 1

a875 4
	/* 5700 b2 errata */
	if (sc->bge_chiprev == BGE_CHIPREV_5700_BX)
		CSR_WRITE_4(sc, BGE_MBX_TX_HOST_PROD0_LO, 0);

a876 3
	/* 5700 b2 errata */
	if (sc->bge_chiprev == BGE_CHIPREV_5700_BX)
		CSR_WRITE_4(sc, BGE_MBX_TX_NIC_PROD0_LO, 0);
d948 1
a949 2
	u_int32_t dma_rw_ctl;
	int i;
d994 2
a995 4
		dma_rw_ctl = BGE_PCI_READ_CMD | BGE_PCI_WRITE_CMD |
		    (0x7 << BGE_PCIDMARWCTL_RD_WAT_SHIFT) |
		    (0x7 << BGE_PCIDMARWCTL_WR_WAT_SHIFT) |
		    (0x0f);
d998 3
a1000 34
		/*
		 * The 5704 uses a different encoding of read/write
		 * watermarks.
		 */
		if (BGE_ASICREV(sc->bge_asicrev) == BGE_ASICREV_BCM5704)
			dma_rw_ctl = BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD |
			    (0x7 << BGE_PCIDMARWCTL_RD_WAT_SHIFT) |
			    (0x3 << BGE_PCIDMARWCTL_WR_WAT_SHIFT);
		else
			dma_rw_ctl = BGE_PCI_READ_CMD|BGE_PCI_WRITE_CMD |
			    (0x3 << BGE_PCIDMARWCTL_RD_WAT_SHIFT) |
			    (0x3 << BGE_PCIDMARWCTL_WR_WAT_SHIFT) |
			    (0x0F);

		/*
		 * 5703 and 5704 need ONEDMA_AT_ONCE as a workaround
		 * for hardware bugs.
		 */
		if (sc->bge_asicrev == BGE_ASICREV_BCM5703 ||
		    sc->bge_asicrev == BGE_ASICREV_BCM5704) {
			u_int32_t tmp;

			tmp = CSR_READ_4(sc, BGE_PCI_CLKCTL) & 0x1f;
			if (tmp == 0x6 || tmp == 0x7)
				dma_rw_ctl |= BGE_PCIDMARWCTL_ONEDMA_ATONCE;
		}
 	}
 
	if (sc->bge_asicrev == BGE_ASICREV_BCM5703 ||
	    sc->bge_asicrev == BGE_ASICREV_BCM5704 ||
	    sc->bge_asicrev == BGE_ASICREV_BCM5705)
		dma_rw_ctl &= ~BGE_PCIDMARWCTL_MINDMA;

	pci_conf_write(pa->pa_pc, pa->pa_tag, BGE_PCI_DMA_RW_CTL, dma_rw_ctl);
d1009 1
a1009 1
		    BGE_MODECTL_TX_NO_PHDR_CSUM|BGE_MODECTL_RX_NO_PHDR_CSUM);
d1013 2
a1014 1
		    BGE_MODECTL_MAC_ATTN_INTR|BGE_MODECTL_HOST_SEND_BDS
d1049 1
d1061 8
a1068 1
	/* Note: the BCM5704 has a smaller bmuf space than the other chips */
d1070 3
a1072 12
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
		/* Configure mbuf memory pool */
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_BASEADDR,
		    (sc->bge_extram) ? BGE_EXT_SSRAM : BGE_BUFFPOOL_1);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_LEN,
		    (sc->bge_asicrev == BGE_ASICREV_BCM5704) ? 0x10000:0x18000);
 
		/* Configure DMA resource pool */
		CSR_WRITE_4(sc, BGE_BMAN_DMA_DESCPOOL_BASEADDR,
		    BGE_DMA_DESCRIPTORS);
		CSR_WRITE_4(sc, BGE_BMAN_DMA_DESCPOOL_LEN, 0x2000);
	}
d1075 3
a1077 8
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705) {
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x0);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x10);
	} else {
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x50);
		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x20);
	}
	CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x60);
d1084 9
a1092 10
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
		CSR_WRITE_4(sc, BGE_BMAN_MODE,
		    BGE_BMANMODE_ENABLE|BGE_BMANMODE_LOMBUF_ATTN);

		/* Poll for buffer manager start indication */
		for (i = 0; i < BGE_TIMEOUT; i++) {
			if (CSR_READ_4(sc, BGE_BMAN_MODE) & BGE_BMANMODE_ENABLE)
				break;
			DELAY(10);
		}
d1094 4
a1097 5
		if (i == BGE_TIMEOUT) {
			printf("%s: buffer manager failed to start\n",
			    sc->bge_dev.dv_xname);
			return(ENXIO);
		}
d1119 3
a1121 6
	BGE_HOSTADDR(rcb->bge_hostaddr, BGE_RING_DMA_ADDR(sc, bge_rx_std_ring));
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705)
		rcb->bge_maxlen_flags = BGE_RCB_MAXLEN_FLAGS(512, 0);
	else
		rcb->bge_maxlen_flags =
		    BGE_RCB_MAXLEN_FLAGS(BGE_MAX_FRAMELEN, 0);
d1126 6
a1131 4
	CSR_WRITE_4(sc, BGE_RX_STD_RCB_HADDR_HI, rcb->bge_hostaddr.bge_addr_hi);
	CSR_WRITE_4(sc, BGE_RX_STD_RCB_HADDR_LO, rcb->bge_hostaddr.bge_addr_lo);
	CSR_WRITE_4(sc, BGE_RX_STD_RCB_MAXLEN_FLAGS, rcb->bge_maxlen_flags);
	CSR_WRITE_4(sc, BGE_RX_STD_RCB_NICADDR, rcb->bge_nicaddr);
d1140 9
a1148 11
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
		rcb = &sc->bge_rdata->bge_info.bge_jumbo_rx_rcb;
		BGE_HOSTADDR(rcb->bge_hostaddr,
		    BGE_RING_DMA_ADDR(sc, bge_rx_jumbo_ring));
		rcb->bge_maxlen_flags =
		    BGE_RCB_MAXLEN_FLAGS(BGE_MAX_FRAMELEN,
		        BGE_RCB_FLAG_RING_DISABLED);
		if (sc->bge_extram)
			rcb->bge_nicaddr = BGE_EXT_JUMBO_RX_RINGS;
		else
			rcb->bge_nicaddr = BGE_JUMBO_RX_RINGS;
d1150 11
a1160 16
		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_HADDR_HI,
		    rcb->bge_hostaddr.bge_addr_hi);
		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_HADDR_LO,
		    rcb->bge_hostaddr.bge_addr_lo);
		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_MAXLEN_FLAGS,
		    rcb->bge_maxlen_flags);
		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_NICADDR,
		    rcb->bge_nicaddr);

		/* Set up dummy disabled mini ring RCB */
		rcb = &sc->bge_rdata->bge_info.bge_mini_rx_rcb;
		rcb->bge_maxlen_flags =
		    BGE_RCB_MAXLEN_FLAGS(0, BGE_RCB_FLAG_RING_DISABLED);
		CSR_WRITE_4(sc, BGE_RX_MINI_RCB_MAXLEN_FLAGS,
		    rcb->bge_maxlen_flags);
	}
d1177 3
a1179 2
		RCB_WRITE_4(sc, rcb_addr, bge_maxlen_flags,
		    BGE_RCB_MAXLEN_FLAGS(0, BGE_RCB_FLAG_RING_DISABLED));
d1187 1
a1187 1
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_lo,
d1191 2
a1192 3
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
		RCB_WRITE_4(sc, rcb_addr, bge_maxlen_flags,
		    BGE_RCB_MAXLEN_FLAGS(BGE_TX_RING_CNT, 0));
d1199 3
a1201 3
		RCB_WRITE_4(sc, rcb_addr, bge_maxlen_flags,
		    BGE_RCB_MAXLEN_FLAGS(sc->bge_return_ring_cnt,
			BGE_RCB_FLAG_RING_DISABLED));
d1221 1
a1221 1
	RCB_WRITE_4(sc, rcb_addr, bge_hostaddr.bge_addr_lo,
d1224 2
a1225 2
	RCB_WRITE_4(sc, rcb_addr, bge_maxlen_flags,
	    BGE_RCB_MAXLEN_FLAGS(sc->bge_return_ring_cnt, 0));
d1274 2
a1275 4
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
		CSR_WRITE_4(sc, BGE_HCC_RX_COAL_TICKS_INT, 0);
		CSR_WRITE_4(sc, BGE_HCC_TX_COAL_TICKS_INT, 0);
	}
d1278 1
d1281 4
a1284 9
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
		CSR_WRITE_4(sc, BGE_HCC_STATS_ADDR_HI, 0);
		CSR_WRITE_4(sc, BGE_HCC_STATS_ADDR_LO,
			    BGE_RING_DMA_ADDR(sc, bge_info.bge_stats));

		CSR_WRITE_4(sc, BGE_HCC_STATS_BASEADDR, BGE_STATS_BLOCK);
		CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_BASEADDR, BGE_STATUS_BLOCK);
		CSR_WRITE_4(sc, BGE_HCC_STATS_TICKS, sc->bge_stat_ticks);
	}
d1287 1
a1290 1

d1305 1
a1305 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
		CSR_WRITE_4(sc, BGE_RXLS_MODE, BGE_RXLSMODE_ENABLE);
d1326 1
a1326 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
		CSR_WRITE_4(sc, BGE_DMAC_MODE, BGE_DMACMODE_ENABLE);
d1346 1
a1346 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
		CSR_WRITE_4(sc, BGE_MBCF_MODE, BGE_MBCFMODE_ENABLE);
d1367 3
d1372 2
a1373 2
	    BGE_MACSTAT_CFG_CHANGED|BGE_MACSTAT_MI_COMPLETE|
	    BGE_MACSTAT_LINK_CHANGED);
d1492 1
a1492 1
		printf("%s: chip initialization failed\n",
d1568 6
a1573 19
	/* Save ASIC rev. */

	sc->bge_chipid =
	    pci_conf_read(pc, pa->pa_tag, BGE_PCI_MISC_CTL) &
	    BGE_PCIMISCCTL_ASICREV;
	sc->bge_asicrev = BGE_ASICREV(sc->bge_chipid);
	sc->bge_chiprev = BGE_CHIPREV(sc->bge_chipid);

	/*
	 * Try to allocate memory for jumbo buffers.
	 * The 5705 does not appear to support jumbo frames.
	 */
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
		if (bge_alloc_jumbo_mem(sc)) {
			printf("%s: jumbo buffer allocation failed\n",
			    sc->bge_dev.dv_xname);
			error = ENXIO;
			goto fail;
		}
a1582 6
	/* 5705 limits RX return ring to 512 entries. */
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705)
		sc->bge_return_ring_cnt = BGE_RETURN_RING_CNT_5705;
	else
		sc->bge_return_ring_cnt = BGE_RETURN_RING_CNT;

d1607 10
d1618 9
a1626 16
	 * Figure out what sort of media we have by checking the hardware
	 * config word in the first 32K of internal NIC memory, or fall back to
	 * examining the EEPROM if necessary.  Note: on some BCM5700 cards,
	 * this value seems to be unset. If that's the case, we have to rely on
	 * identifying the NIC by its PCI subsystem ID, as we do below for the
	 * SysKonnect SK-9D41.
	 */
	if (bge_readmem_ind(sc, BGE_SOFTWARE_GENCOMM_SIG) == BGE_MAGIC_NUMBER)
		hwcfg = bge_readmem_ind(sc, BGE_SOFTWARE_GENCOMM_NICCFG);
	else {
		bge_read_eeprom(sc, (caddr_t)&hwcfg, BGE_EE_HWCFG_OFFSET,
		    sizeof(hwcfg));
		hwcfg = ntohl(hwcfg);
	}
	
	if ((hwcfg & BGE_HWCFG_MEDIA) == BGE_MEDIA_FIBER)	    
d1670 5
a1674 5
	switch (sc->bge_chipid) {
	case BGE_CHIPID_BCM5701_A0:
	case BGE_CHIPID_BCM5701_B0:
	case BGE_CHIPID_BCM5701_B2:
	case BGE_CHIPID_BCM5701_B5:
d1794 1
a1794 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
		CSR_WRITE_4(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE);
d1840 1
a1840 1
		BGE_INC(sc->bge_rx_saved_considx, sc->bge_return_ring_cnt);
d1897 1
a1897 1
		m->m_pkthdr.len = m->m_len = cur_rx->bge_len - ETHER_CRC_LEN; 
a1986 1
	u_int32_t status;
d1997 1
a1997 1
	/* Ack interrupt and stop others from occurring. */
d2004 1
a2004 1
	 * according to all available information. Hence, we have
d2013 2
d2028 5
a2032 26
		if ((sc->bge_rdata->bge_status_block.bge_status &
		    BGE_STATFLAG_UPDATED) &&
		    (sc->bge_rdata->bge_status_block.bge_status &
		    BGE_STATFLAG_LINKSTATE_CHANGED)) {
			sc->bge_rdata->bge_status_block.bge_status &=
			    ~(BGE_STATFLAG_UPDATED | 
				BGE_STATFLAG_LINKSTATE_CHANGED);
			/*
			 * Sometimes PCS encoding errors are detected in
			 * TBI mode (on fiber NICs), and for some reason
			 * the chip will signal them as link changes.
			 * If we get a link change event, but the 'PCS 
			 * encoding bit' in the MAC status register
			 * is set, don't bother doing a link check.
			 * This avoids spurious "gigabit link up" messages
			 * that sometimes appear on fiber NICs during
			 * periods of heavy traffic. (There should be no
			 * effect on copper NICs).
			 */
			status = CSR_READ_4(sc, BGE_MAC_STS);
			if (!(status & (BGE_MACSTAT_PORT_DECODE_ERROR | 
			    BGE_MACSTAT_MI_COMPLETE))) {
				sc->bge_link = 0;
				timeout_del(&sc->bge_timeout);
				bge_tick(sc);
			}
d2035 1
a2035 5
			    BGE_MACSTAT_CFG_CHANGED|BGE_MACSTAT_MI_COMPLETE|
			    BGE_MACSTAT_LINK_CHANGED);

			/* Force flush the status block cached by PCI bridge */
			CSR_READ_4(sc, BGE_MBX_IRQ0_LO);	
d2070 1
a2070 4
	if (sc->bge_asicrev == BGE_ASICREV_BCM5705)
		bge_stats_update_regs(sc);
	else
		bge_stats_update(sc);
a2102 27
bge_stats_update_regs(sc)
	struct bge_softc *sc;
{
	struct ifnet *ifp;
	struct bge_mac_stats_regs stats;
	u_int32_t *s;
	int i;

	ifp = &sc->arpcom.ac_if;

	s = (u_int32_t *)&stats;
	for (i = 0; i < sizeof(struct bge_mac_stats_regs); i += 4) {
		*s = CSR_READ_4(sc, BGE_RX_STATS + i);
		s++;
	}

	ifp->if_collisions +=
	   (stats.dot3StatsSingleCollisionFrames +
	   stats.dot3StatsMultipleCollisionFrames +
	   stats.dot3StatsExcessiveCollisions +
	   stats.dot3StatsLateCollisions) -
	   ifp->if_collisions;

	return;
}

void
d2113 4
a2116 8
	  (READ_STAT(sc, stats,
	       txstats.dot3StatsSingleCollisionFrames.bge_addr_lo) +
	   READ_STAT(sc, stats,
	       txstats.dot3StatsMultipleCollisionFrames.bge_addr_lo) +
	   READ_STAT(sc, stats,
	       txstats.dot3StatsExcessiveCollisions.bge_addr_lo) +
	   READ_STAT(sc, stats,
	       txstats.dot3StatsLateCollisions.bge_addr_lo)) -
d2186 1
a2186 1
		BGE_HOSTADDR(f->bge_addr, txmap->dm_segs[i].ds_addr);
a2291 3
	/* 5700 b2 errata */
	if (sc->bge_chiprev == BGE_CHIPREV_5700_BX)
		CSR_WRITE_4(sc, BGE_MBX_TX_HOST_PROD0_LO, 0);
d2299 40
a2395 18
	/*
	 * Workaround for a bug in 5705 ASIC rev A0. Poll the NIC's
	 * memory to insure that the chip has in fact read the first
	 * entry of the ring.
	 */
	if (sc->bge_chipid == BGE_CHIPID_BCM5705_A0) {
		u_int32_t		v, i;
		for (i = 0; i < 10; i++) {
			DELAY(20);
			v = bge_readmem_ind(sc, BGE_STD_RX_RINGS + 8);
			if (v == (MCLBYTES - ETHER_ALIGN))
				break;
		}
		if (i == 10)
			printf("%s: 5705 A0 chip failed to load RX ring\n",
			    sc->bge_dev.dv_xname);
	}

d2470 1
d2541 1
a2541 3
		/* Disallow jumbo frames on 5705. */
		if ((sc->bge_asicrev == BGE_ASICREV_BCM5705 &&
		    ifr->ifr_mtu > ETHERMTU) || ifr->ifr_mtu > BGE_JUMBO_MTU)
d2642 1
a2642 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
		BGE_CLRBIT(sc, BGE_RXLS_MODE, BGE_RXLSMODE_ENABLE);
d2655 1
a2655 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
		BGE_CLRBIT(sc, BGE_DMAC_MODE, BGE_DMACMODE_ENABLE);
d2664 1
a2664 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
		BGE_CLRBIT(sc, BGE_MBCF_MODE, BGE_MBCFMODE_ENABLE);
d2667 2
a2668 4
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705) {
		BGE_CLRBIT(sc, BGE_BMAN_MODE, BGE_BMANMODE_ENABLE);
		BGE_CLRBIT(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE);
	}
d2683 1
a2683 2
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
		bge_free_rx_ring_jumbo(sc);
@


1.3.4.6
log
@Merge with the trunk
@
text
@d144 1
a218 1
	{ PCI_VENDOR_BROADCOM, PCI_PRODUCT_BROADCOM_BCM5788 },
d291 1
a291 1
	if (i == BGE_TIMEOUT * 10) {
d399 1
a399 1
	if (i == BGE_TIMEOUT * 10) {
d766 2
d929 19
a959 6
	/* First, zot all the existing filters. */
	for (i = 0; i < 4; i++)
		CSR_WRITE_4(sc, BGE_MAR0 + (i * 4), 0);

	/* Now program new ones. */
allmulti:
d966 5
d973 1
a973 5
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}
		h = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN) & 0x7F;
d1089 4
a1092 1
		    BGE_MODECTL_MAC_ATTN_INTR|BGE_MODECTL_HOST_SEND_BDS);
a1866 4
	/* Enable memory arbiter. */
	if (sc->bge_asicrev != BGE_ASICREV_BCM5705)
		CSR_WRITE_4(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE);

d1906 4
d2732 2
a2733 7
		error = (command == SIOCADDMULTI)
			? ether_addmulti(ifr, &sc->arpcom)
			: ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			if (ifp->if_flags & IFF_RUNNING)
				bge_setmulti(sc);
@


1.2
log
@Don't enable BGE_CHECKSUM yet, since it doesn't work.
It shouldn't have been enabled in the first place.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bge.c,v 1.1 2001/10/05 18:57:28 nate Exp $	*/
a106 2
#include <vm/vm.h>              /* for vtophys */

a498 1
	bus_dmamap_t		dmamap;
d515 2
a516 2
	if (bus_dmamap_create(sc->bge_dmatag, BGE_JMEM, 1,
			      BGE_JMEM, 0, BUS_DMA_NOWAIT, &dmamap)) {
d522 2
a523 2
	if (bus_dmamap_load(sc->bge_dmatag, dmamap, kva, BGE_JMEM,
			    NULL, BUS_DMA_NOWAIT)) {
d525 2
a526 1
		bus_dmamap_destroy(sc->bge_dmatag, dmamap);
d539 1
a539 5
	 * in an array. Note that we play an evil trick here by using
	 * the first few bytes in the buffer to hold the the address
	 * of the softc structure for this interface. This is because
	 * bge_jfree() needs it, but it is called by the mbuf management
	 * code which will not pass it to us explicitly.
d548 4
a551 2
			bus_dmamap_unload(sc->bge_dmatag, dmamap);
			bus_dmamap_destroy(sc->bge_dmatag, dmamap);
d635 1
d659 3
d665 1
a665 1
	BGE_HOSTADDR(r->bge_addr) = vtophys(mtod(m_new, caddr_t));
a706 9
		m_new->m_data = m_new->m_ext.ext_buf = (void *)buf;
		m_new->m_flags |= M_EXT;
		m_new->m_len = m_new->m_pkthdr.len =
		    m_new->m_ext.ext_size = BGE_JUMBO_FRAMELEN;
		m_new->m_ext.ext_free = bge_jfree;
		m_new->m_ext.ext_arg = sc;
		MCLINITREFERENCE(m_new);
#if 0
		m_new->m_data = (void *) buf;
d708 1
a708 3
		MEXTADD(m_new, buf, BGE_JUMBO_FRAMELEN, bge_jfree,
		    (struct bge_softc *)sc, 0, EXT_NET_DRV);
#endif
d719 2
a720 1
	BGE_HOSTADDR(r->bge_addr) = vtophys(mtod(m_new, caddr_t));
d740 7
d750 1
a750 1
	};
d768 2
d783 1
a783 1

d830 2
d842 2
d849 7
d1129 1
a1129 1
	    vtophys(&sc->bge_rdata->bge_rx_std_ring);
d1151 1
a1151 1
	    vtophys(&sc->bge_rdata->bge_rx_jumbo_ring);
d1192 1
a1192 1

d1197 1
a1197 1
		    vtophys(&sc->bge_rdata->bge_tx_ring));
d1231 1
a1231 1
		    vtophys(&sc->bge_rdata->bge_rx_return_ring));
d1293 1
a1293 1
	    vtophys(&sc->bge_rdata->bge_info.bge_stats));
d1299 1
a1299 1
	    vtophys(&sc->bge_rdata->bge_status_block));
a1453 1
	bus_dmamap_t		dmamap;
d1566 1
a1566 1
			      BUS_DMA_NOWAIT, &dmamap)) {
d1574 1
a1574 1
	if (bus_dmamap_load(sc->bge_dmatag, dmamap, kva,
d1577 1
a1577 1
		bus_dmamap_destroy(sc->bge_dmatag, dmamap);
d1824 2
a1825 2
			if (bge_newbuf_jumbo(sc,
			    sc->bge_jumbo, NULL) == ENOBUFS) {
d1834 2
d1923 2
d2077 2
d2111 5
d2122 1
a2122 1
			   vtophys(mtod(m, vm_offset_t));
@


1.1
log
@Add a driver for the Broadcom BCM570x chips. (a.k.a. Tigon3).
This driver supports the following cards:
    3Com 3c996-T (10/100/1000baseTX)
    Dell PowerEdge 2550 integrated BCM5700 NIC (10/100/1000baseTX)
    SysKonnect SK-9D21 (10/100/1000baseTX)
    SysKonnect SK-9D41 (1000baseSX)

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d120 1
a120 1
#define BGE_CHECKSUM
@

