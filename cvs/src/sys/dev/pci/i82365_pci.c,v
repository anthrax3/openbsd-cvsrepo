head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.28
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.26
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.14
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.22
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.20
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.18
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.16
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.12
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.18
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.20
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.16
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.14
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.12
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.10
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.8
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.6
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.7.0.8
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.6
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.5.0.4
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	SMP:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.11
date	2010.09.07.16.21.44;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.02.04.23.15;	author blambert;	state Exp;
branches;
next	1.9;

1.9
date	2005.08.09.04.10.11;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.27.17.03.23;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.21.17.55.43;	author miod;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.06.12.15.40.31;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.04.17.07.52;	author mickey;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	2000.08.03.14.06.39;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.08.01.07.55.39;	author aaron;	state Exp;
branches;
next	;

1.3.6.1
date	2001.05.14.22.25.42;	author niklas;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2001.07.04.10.42.09;	author niklas;	state Exp;
branches;
next	1.3.6.3;

1.3.6.3
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.3.6.4;

1.3.6.4
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.3.6.5;

1.3.6.5
date	2003.03.28.00.38.21;	author niklas;	state Exp;
branches;
next	;

1.5.4.1
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@/*	$OpenBSD: i82365_pci.c,v 1.10 2010/07/02 04:23:15 blambert Exp $ */
/*	$NetBSD: i82365_pci.c,v 1.11 2000/02/24 03:42:44 itohy Exp $	*/

/*
 * Copyright (c) 1997 Marc Horowitz.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Marc Horowitz.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * XXX this driver frontend is *very* i386 dependent and should be relocated
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <dev/ic/i82365reg.h>
#include <dev/ic/i82365var.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/i82365_pcivar.h>

#include <dev/isa/isavar.h>
#include <dev/isa/i82365_isavar.h>

/*
 * PCI constants.
 * XXX These should be in a common file!
 */
#define	PCI_CBIO		0x10	/* Configuration Base IO Address */

int	pcic_pci_match(struct device *, void *, void *);
void	pcic_pci_attach(struct device *, struct device *, void *);

struct cfattach pcic_pci_ca = {
	sizeof(struct pcic_pci_softc), pcic_pci_match, pcic_pci_attach
};

static struct pcmcia_chip_functions pcic_pci_functions = {
	pcic_chip_mem_alloc,
	pcic_chip_mem_free,
	pcic_chip_mem_map,
	pcic_chip_mem_unmap,

	pcic_chip_io_alloc,
	pcic_chip_io_free,
	pcic_chip_io_map,
	pcic_chip_io_unmap,

	/* XXX */
	pcic_isa_chip_intr_establish,
	pcic_isa_chip_intr_disestablish,
	pcic_isa_chip_intr_string,

	pcic_chip_socket_enable,
	pcic_chip_socket_disable,
};

int
pcic_pci_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct pci_attach_args *pa = (struct pci_attach_args *) aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_CIRRUS &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CIRRUS_CL_PD6729)
		return (1);
	return (0);
}

void pcic_isa_config_interrupts(struct device *);

void
pcic_pci_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pcic_softc *sc = (void *) self;
	struct pcic_pci_softc *psc = (void *) self;
	struct pcic_handle *h;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	bus_space_tag_t memt = pa->pa_memt;
	bus_space_handle_t memh;
	bus_size_t size;
	int irq, i;

	if (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->iot, &sc->ioh, NULL, &size, 0)) {
		printf(": can't map i/o space\n");
		return;
	}

	/*
	 * XXX need some memory for mapping pcmcia cards into. Ideally, this
	 * would be completely dynamic.  Practically this doesn't work,
	 * because the extent mapper doesn't know about all the devices all
	 * the time.  With ISA we could finesse the issue by specifying the
	 * memory region in the config line.  We can't do that here, so we
	 * cheat for now. Jason Thorpe, you are my Savior, come up with a fix
	 * :-)
	 */

	/* Map mem space. */
	if (bus_space_map(memt, 0xd0000, 0x10000, 0, &memh)) {
		printf(": can't map mem space");
		bus_space_unmap(sc->iot, sc->ioh, size);
		return;
	}

	sc->membase = 0xd0000;
	sc->subregionmask = (1 << (0x10000 / PCIC_MEM_PAGESIZE)) - 1;

	/* same deal for io allocation */

	sc->iobase = 0x400;
	sc->iosize = 0xbff;

	/* end XXX */

	sc->pct = (pcmcia_chipset_tag_t) & pcic_pci_functions;

	sc->memt = memt;
	sc->memh = memh;

	printf("\n");
	pcic_attach(sc);
	pcic_attach_sockets(sc);

	/*
	 * Check to see if we're using PCI or ISA interrupts. I don't
	 * know of any i386 systems that use the 6729 in PCI interrupt
	 * mode, but maybe when the PCMCIA code runs on other platforms
	 * we'll need to fix this.
	 */
	pcic_write(&sc->handle[0], PCIC_CIRRUS_EXTENDED_INDEX,
		   PCIC_CIRRUS_EXT_CONTROL_1);
	if ((pcic_read(&sc->handle[0], PCIC_CIRRUS_EXTENDED_DATA) &
	    PCIC_CIRRUS_EXT_CONTROL_1_PCI_INTR_MASK)) {
		printf("%s: PCI interrupts not supported\n",
		       sc->dev.dv_xname);
		return;
	}

	psc->intr_est = pcic_pci_machdep_intr_est(pc);

	irq = pcic_intr_find(sc, IST_EDGE);

	/* Map and establish the interrupt. */
	if (irq) {
		sc->ih = pcic_pci_machdep_pcic_intr_establish(sc, pcic_intr);
		if (sc->ih == NULL) {
			printf("%s: couldnt map interrupt\n", sc->dev.dv_xname);
			bus_space_unmap(memt, memh, 0x10000);
			bus_space_unmap(sc->iot, sc->ioh, size);
			return;
		}
	}
	sc->irq = irq;

	if (irq) {
                printf("%s: irq %d, ", sc->dev.dv_xname, irq);

                /* Set up the pcic to interrupt on card detect. */
                for (i = 0; i < PCIC_NSLOTS; i++) {
                        h = &sc->handle[i];
                        if (h->flags & PCIC_FLAG_SOCKETP) {
                                pcic_write(h, PCIC_CSC_INTR,
                                    (sc->irq << PCIC_CSC_INTR_IRQ_SHIFT) |
                                    PCIC_CSC_INTR_CD_ENABLE);
                        }
                }
        } else
                printf("%s: no irq, ", sc->dev.dv_xname);

        printf("polling enabled\n");
        if (sc->poll_established == 0) {
                timeout_set(&sc->poll_timeout, pcic_poll_intr, sc);
                timeout_add_msec(&sc->poll_timeout, 500);
                sc->poll_established = 1;
        }
}
@


1.10
log
@timeout_add -> timeout_add_msec
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_pci.c,v 1.9 2005/08/09 04:10:11 mickey Exp $ */
a200 1
                                powerhook_establish(pcic_power, h);
@


1.9
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_pci.c,v 1.8 2005/01/27 17:03:23 millert Exp $ */
d210 1
a210 1
                timeout_add(&sc->poll_timeout, hz / 2);
@


1.8
log
@Add pcmcia_intr_string() to format the intr string for pcmcia attach
routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_pci.c,v 1.7 2002/11/19 18:40:17 jason Exp $ */
a154 5

	/* Enable the card. */
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG) |
	    PCI_COMMAND_MASTER_ENABLE);
@


1.7
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_pci.c,v 1.6 2002/03/14 01:26:58 millert Exp $ */
d81 1
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_pci.c,v 1.5 2001/09/21 17:55:43 miod Exp $ */
d94 4
a97 13
	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_CIRRUS:
		switch(PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_CIRRUS_CL_PD6729:
			break;
		default:
			return (0);
		}
		break;
	default:
		return (0);
	}
	return (1);
@


1.5
log
@Correct some pryntf() usage: get the correct number of arguments in the
correct order.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_pci.c,v 1.4 2001/06/12 15:40:31 niklas Exp $ */
d60 2
a61 2
int	pcic_pci_match __P((struct device *, void *, void *));
void	pcic_pci_attach __P((struct device *, struct device *, void *));
d109 1
a109 1
void pcic_isa_config_interrupts __P((struct device *));
@


1.5.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_pci.c,v 1.5 2001/09/21 17:55:43 miod Exp $ */
d60 2
a61 2
int	pcic_pci_match(struct device *, void *, void *);
void	pcic_pci_attach(struct device *, struct device *, void *);
d109 1
a109 1
void pcic_isa_config_interrupts(struct device *);
@


1.5.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d94 13
a106 4
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_CIRRUS &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CIRRUS_CL_PD6729)
		return (1);
	return (0);
@


1.4
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_pci.c,v 1.3 2000/09/04 17:07:52 mickey Exp $ */
d220 1
a220 1
        printf("polling enabled\n", sc->dev.dv_xname);
@


1.3
log
@match pcic at isa memory config, free resources on failure (-1 panic); aaron@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_pci.c,v 1.2 2000/08/03 14:06:39 aaron Exp $ */
d127 1
a127 1
	    &sc->iot, &sc->ioh, NULL, &size)) {
@


1.3.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_pci.c,v 1.3 2000/09/04 17:07:52 mickey Exp $ */
@


1.3.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_pci.c,v 1.3.6.1 2001/05/14 22:25:42 niklas Exp $ */
d127 1
a127 1
	    &sc->iot, &sc->ioh, NULL, &size, 0)) {
@


1.3.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_pci.c,v 1.3.6.2 2001/07/04 10:42:09 niklas Exp $ */
d220 1
a220 1
        printf("polling enabled\n");
@


1.3.6.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d60 2
a61 2
int	pcic_pci_match(struct device *, void *, void *);
void	pcic_pci_attach(struct device *, struct device *, void *);
d109 1
a109 1
void pcic_isa_config_interrupts(struct device *);
@


1.3.6.5
log
@Sync the SMP branch with 3.3
@
text
@d94 13
a106 4
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_CIRRUS &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CIRRUS_CL_PD6729)
		return (1);
	return (0);
@


1.2
log
@Don't print out the name of the controller twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_pci.c,v 1.1 2000/08/01 07:55:39 aaron Exp $ */
d123 1
d127 1
a127 1
	    &sc->iot, &sc->ioh, NULL, NULL)) {
d143 5
a147 2
	if (bus_space_map(memt, 0xd0000, 0x4000, 0, &memh))
		panic("pcic_pci_attach: can't map mem space");
d150 1
a150 1
	sc->subregionmask = (1 << (0x4000 / PCIC_MEM_PAGESIZE)) - 1;
d169 1
d197 2
@


1.1
log
@Add PCI attachment for i82365-compatible PCMCIA controllers. Needed for
the Cirrus Logic CL-PD6729 controller found on some laptops, i.e., the
Gateway 2000 Solo 2100. Thanks to JDempsey@@iss.net for testing and initiallly
prodding me to get PC Cards to work in his laptop.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a122 1
	char *model;
a158 11

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_CIRRUS_CL_PD6729:
		model = "Cirrus Logic PD6729 PCMCIA controller";
		break;
	default:
		model = "Model unknown";
		break;
	}

	printf(": %s\n", model);
@

