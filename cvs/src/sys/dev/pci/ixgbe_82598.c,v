head	1.15;
access;
symbols
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.11.0.14
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.10
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.8
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.6
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.4
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.6
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.4
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.15
date	2016.11.17.19.26.57;	author mikeb;	state Exp;
branches;
next	1.14;
commitid	s7sWiFVcUtMtUOpv;

1.14
date	2016.11.17.13.12.03;	author mikeb;	state Exp;
branches;
next	1.13;
commitid	DQVdY942nzePqvpn;

1.13
date	2016.11.17.12.21.27;	author mikeb;	state Exp;
branches;
next	1.12;
commitid	rl7UKnhqgZzc9auT;

1.12
date	2016.11.16.23.19.29;	author mikeb;	state Exp;
branches;
next	1.11;
commitid	IZg2nJoFrsaft35v;

1.11
date	2013.08.05.19.58.06;	author mikeb;	state Exp;
branches;
next	1.10;

1.10
date	2012.12.17.12.03.16;	author mikeb;	state Exp;
branches;
next	1.9;

1.9
date	2012.12.07.13.03.31;	author mikeb;	state Exp;
branches;
next	1.8;

1.8
date	2012.12.05.14.41.28;	author mikeb;	state Exp;
branches;
next	1.7;

1.7
date	2012.07.29.13.49.03;	author mikeb;	state Exp;
branches;
next	1.6;

1.6
date	2011.06.10.12.46.35;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.19.18.55.12;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.07.13.24.57;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.08.21.15.34;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.08.20.33.51;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.08.20.01.02;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Bring in new PHY bits, some of the 82599 specific stuff becomes shared
@
text
@/*	$OpenBSD: ixgbe_82598.c,v 1.14 2016/11/17 13:12:03 mikeb Exp $	*/

/******************************************************************************

  Copyright (c) 2001-2015, Intel Corporation
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

   3. Neither the name of the Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

******************************************************************************/
/*$FreeBSD: head/sys/dev/ixgbe/ixgbe_82598.c 292674 2015-12-23 22:45:17Z sbruno $*/

#include <dev/pci/ixgbe.h>
#include <dev/pci/ixgbe_type.h>

#define IXGBE_82598_MAX_TX_QUEUES 32
#define IXGBE_82598_MAX_RX_QUEUES 64
#define IXGBE_82598_RAR_ENTRIES   16
#define IXGBE_82598_MC_TBL_SIZE  128
#define IXGBE_82598_VFT_TBL_SIZE 128
#define IXGBE_82598_RX_PB_SIZE   512

uint32_t ixgbe_get_pcie_msix_count_82598(struct ixgbe_hw *hw);
int32_t ixgbe_get_link_capabilities_82598(struct ixgbe_hw *hw,
					  ixgbe_link_speed *speed,
					  bool *autoneg);
enum ixgbe_media_type ixgbe_get_media_type_82598(struct ixgbe_hw *hw);
int32_t ixgbe_fc_enable_82598(struct ixgbe_hw *hw);
int32_t ixgbe_start_mac_link_82598(struct ixgbe_hw *hw,
				   bool autoneg_wait_to_complete);
int32_t ixgbe_validate_link_ready(struct ixgbe_hw *hw);
int32_t ixgbe_check_mac_link_82598(struct ixgbe_hw *hw,
				   ixgbe_link_speed *speed, bool *link_up,
				   bool link_up_wait_to_complete);
int32_t ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw,
				   ixgbe_link_speed speed,
				   bool autoneg_wait_to_complete);
int32_t ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw,
				      ixgbe_link_speed speed,
				      bool autoneg_wait_to_complete);
int32_t ixgbe_reset_hw_82598(struct ixgbe_hw *hw);
int32_t ixgbe_start_hw_82598(struct ixgbe_hw *hw);
void ixgbe_enable_relaxed_ordering_82598(struct ixgbe_hw *hw);
int32_t ixgbe_set_vmdq_82598(struct ixgbe_hw *hw, uint32_t rar, uint32_t vmdq);
int32_t ixgbe_clear_vmdq_82598(struct ixgbe_hw *hw, uint32_t rar, uint32_t vmdq);
int32_t ixgbe_set_vfta_82598(struct ixgbe_hw *hw, uint32_t vlan,
			     uint32_t vind, bool vlan_on);
int32_t ixgbe_clear_vfta_82598(struct ixgbe_hw *hw);
int32_t ixgbe_read_analog_reg8_82598(struct ixgbe_hw *hw, uint32_t reg, uint8_t *val);
int32_t ixgbe_write_analog_reg8_82598(struct ixgbe_hw *hw, uint32_t reg, uint8_t val);
int32_t ixgbe_read_i2c_phy_82598(struct ixgbe_hw *hw, uint8_t dev_addr,
				 uint8_t byte_offset, uint8_t *eeprom_data);
int32_t ixgbe_read_i2c_eeprom_82598(struct ixgbe_hw *hw, uint8_t byte_offset,
				    uint8_t *eeprom_data);
uint32_t ixgbe_get_supported_physical_layer_82598(struct ixgbe_hw *hw);
int32_t ixgbe_init_phy_ops_82598(struct ixgbe_hw *hw);
void ixgbe_set_lan_id_multi_port_pcie_82598(struct ixgbe_hw *hw);
void ixgbe_set_pcie_completion_timeout(struct ixgbe_hw *hw);
int32_t ixgbe_enable_rx_dma_82598(struct ixgbe_hw *hw, uint32_t regval);

/**
 *  ixgbe_set_pcie_completion_timeout - set pci-e completion timeout
 *  @@hw: pointer to the HW structure
 *
 *  The defaults for 82598 should be in the range of 50us to 50ms,
 *  however the hardware default for these parts is 500us to 1ms which is less
 *  than the 10ms recommended by the pci-e spec.  To address this we need to
 *  increase the value to either 10ms to 250ms for capability version 1 config,
 *  or 16ms to 55ms for version 2.
 **/
void ixgbe_set_pcie_completion_timeout(struct ixgbe_hw *hw)
{
	uint32_t gcr = IXGBE_READ_REG(hw, IXGBE_GCR);
	uint16_t pcie_devctl2;

	/* only take action if timeout value is defaulted to 0 */
	if (gcr & IXGBE_GCR_CMPL_TMOUT_MASK)
		goto out;

	/*
	 * if capababilities version is type 1 we can write the
	 * timeout of 10ms to 250ms through the GCR register
	 */
	if (!(gcr & IXGBE_GCR_CAP_VER2)) {
		gcr |= IXGBE_GCR_CMPL_TMOUT_10ms;
		goto out;
	}

	/*
	 * for version 2 capabilities we need to write the config space
	 * directly in order to set the completion timeout value for
	 * 16ms to 55ms
	 */
	pcie_devctl2 = IXGBE_READ_PCIE_WORD(hw, IXGBE_PCI_DEVICE_CONTROL2);
	pcie_devctl2 |= IXGBE_PCI_DEVICE_CONTROL2_16ms;
	IXGBE_WRITE_PCIE_WORD(hw, IXGBE_PCI_DEVICE_CONTROL2, pcie_devctl2);
out:
	/* disable completion timeout resend */
	gcr &= ~IXGBE_GCR_CMPL_TMOUT_RESEND;
	IXGBE_WRITE_REG(hw, IXGBE_GCR, gcr);
}

/**
 *  ixgbe_init_ops_82598 - Inits func ptrs and MAC type
 *  @@hw: pointer to hardware structure
 *
 *  Initialize the function pointers and assign the MAC type for 82598.
 *  Does not touch the hardware.
 **/
int32_t ixgbe_init_ops_82598(struct ixgbe_hw *hw)
{
	struct ixgbe_mac_info *mac = &hw->mac;
	struct ixgbe_phy_info *phy = &hw->phy;
	int32_t ret_val;

	DEBUGFUNC("ixgbe_init_ops_82598");

	ret_val = ixgbe_init_phy_ops_generic(hw);
	ret_val = ixgbe_init_ops_generic(hw);

	/* PHY */
	phy->ops.init = ixgbe_init_phy_ops_82598;

	/* MAC */
	mac->ops.start_hw = ixgbe_start_hw_82598;
	mac->ops.reset_hw = ixgbe_reset_hw_82598;
	mac->ops.get_media_type = ixgbe_get_media_type_82598;
	mac->ops.get_supported_physical_layer =
				ixgbe_get_supported_physical_layer_82598;
	mac->ops.read_analog_reg8 = ixgbe_read_analog_reg8_82598;
	mac->ops.write_analog_reg8 = ixgbe_write_analog_reg8_82598;
	mac->ops.set_lan_id = ixgbe_set_lan_id_multi_port_pcie_82598;
	mac->ops.enable_rx_dma = ixgbe_enable_rx_dma_82598;

	/* RAR, Multicast, VLAN */
	mac->ops.set_vmdq = ixgbe_set_vmdq_82598;
	mac->ops.clear_vmdq = ixgbe_clear_vmdq_82598;
	mac->ops.set_vfta = ixgbe_set_vfta_82598;
	mac->ops.clear_vfta = ixgbe_clear_vfta_82598;

	/* Flow Control */
	mac->ops.fc_enable = ixgbe_fc_enable_82598;

	mac->mcft_size		= IXGBE_82598_MC_TBL_SIZE;
	mac->vft_size		= IXGBE_82598_VFT_TBL_SIZE;
	mac->num_rar_entries	= IXGBE_82598_RAR_ENTRIES;
	mac->rx_pb_size		= IXGBE_82598_RX_PB_SIZE;
	mac->max_rx_queues	= IXGBE_82598_MAX_RX_QUEUES;
	mac->max_tx_queues	= IXGBE_82598_MAX_TX_QUEUES;
	mac->max_msix_vectors	= ixgbe_get_pcie_msix_count_generic(hw);

	/* SFP+ Module */
	phy->ops.read_i2c_eeprom = ixgbe_read_i2c_eeprom_82598;

	/* Link */
	mac->ops.check_link = ixgbe_check_mac_link_82598;
	mac->ops.setup_link = ixgbe_setup_mac_link_82598;
	mac->ops.flap_tx_laser = NULL;
	mac->ops.get_link_capabilities = ixgbe_get_link_capabilities_82598;

	return ret_val;
}

/**
 *  ixgbe_init_phy_ops_82598 - PHY/SFP specific init
 *  @@hw: pointer to hardware structure
 *
 *  Initialize any function pointers that were not able to be
 *  set during init_shared_code because the PHY/SFP type was
 *  not known.  Perform the SFP init if necessary.
 *
 **/
int32_t ixgbe_init_phy_ops_82598(struct ixgbe_hw *hw)
{
	struct ixgbe_mac_info *mac = &hw->mac;
	struct ixgbe_phy_info *phy = &hw->phy;
	int32_t ret_val = IXGBE_SUCCESS;
	uint16_t list_offset, data_offset;

	DEBUGFUNC("ixgbe_init_phy_ops_82598");

	/* Identify the PHY */
	phy->ops.identify(hw);

	/* Overwrite the link function pointers if copper PHY */
	if (mac->ops.get_media_type(hw) == ixgbe_media_type_copper) {
		mac->ops.setup_link = ixgbe_setup_copper_link_82598;
		mac->ops.get_link_capabilities =
				ixgbe_get_copper_link_capabilities_generic;
	}

	switch (hw->phy.type) {
	case ixgbe_phy_tn:
		phy->ops.setup_link = ixgbe_setup_phy_link_tnx;
		phy->ops.check_link = ixgbe_check_phy_link_tnx;
		phy->ops.get_firmware_version =
					ixgbe_get_phy_firmware_version_tnx;
		break;
	case ixgbe_phy_nl:
		phy->ops.reset = ixgbe_reset_phy_nl;

		/* Call SFP+ identify routine to get the SFP+ module type */
		ret_val = phy->ops.identify_sfp(hw);
		if (ret_val != IXGBE_SUCCESS)
			goto out;
		else if (hw->phy.sfp_type == ixgbe_sfp_type_unknown) {
			ret_val = IXGBE_ERR_SFP_NOT_SUPPORTED;
			goto out;
		}

		/* Check to see if SFP+ module is supported */
		ret_val = ixgbe_get_sfp_init_sequence_offsets(hw,
							      &list_offset,
							      &data_offset);
		if (ret_val != IXGBE_SUCCESS) {
			ret_val = IXGBE_ERR_SFP_NOT_SUPPORTED;
			goto out;
		}
		break;
	default:
		break;
	}

out:
	return ret_val;
}

/**
 *  ixgbe_start_hw_82598 - Prepare hardware for Tx/Rx
 *  @@hw: pointer to hardware structure
 *
 *  Starts the hardware using the generic start_hw function.
 *  Disables relaxed ordering, then set pcie completion timeout
 *
 **/
int32_t ixgbe_start_hw_82598(struct ixgbe_hw *hw)
{
	uint32_t regval;
	uint32_t i;
	int32_t ret_val = IXGBE_SUCCESS;

	DEBUGFUNC("ixgbe_start_hw_82598");

	ret_val = ixgbe_start_hw_generic(hw);
	if (ret_val)
		return ret_val;

	/* Disable relaxed ordering */
	for (i = 0; ((i < hw->mac.max_tx_queues) &&
	     (i < IXGBE_DCA_MAX_QUEUES_82598)); i++) {
		regval = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL(i));
		regval &= ~IXGBE_DCA_TXCTRL_DESC_WRO_EN;
		IXGBE_WRITE_REG(hw, IXGBE_DCA_TXCTRL(i), regval);
	}

	for (i = 0; ((i < hw->mac.max_rx_queues) &&
	     (i < IXGBE_DCA_MAX_QUEUES_82598)); i++) {
		regval = IXGBE_READ_REG(hw, IXGBE_DCA_RXCTRL(i));
		regval &= ~(IXGBE_DCA_RXCTRL_DATA_WRO_EN |
			    IXGBE_DCA_RXCTRL_HEAD_WRO_EN);
		IXGBE_WRITE_REG(hw, IXGBE_DCA_RXCTRL(i), regval);
	}

	/* set the completion timeout for interface */
	ixgbe_set_pcie_completion_timeout(hw);

	return ret_val;
}

/**
 *  ixgbe_get_link_capabilities_82598 - Determines link capabilities
 *  @@hw: pointer to hardware structure
 *  @@speed: pointer to link speed
 *  @@autoneg: boolean auto-negotiation value
 *
 *  Determines the link capabilities by reading the AUTOC register.
 **/
int32_t ixgbe_get_link_capabilities_82598(struct ixgbe_hw *hw,
					  ixgbe_link_speed *speed,
					  bool *autoneg)
{
	int32_t status = IXGBE_SUCCESS;
	uint32_t autoc = 0;

	DEBUGFUNC("ixgbe_get_link_capabilities_82598");

	/*
	 * Determine link capabilities based on the stored value of AUTOC,
	 * which represents EEPROM defaults.  If AUTOC value has not been
	 * stored, use the current register value.
	 */
	if (hw->mac.orig_link_settings_stored)
		autoc = hw->mac.orig_autoc;
	else
		autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);

	switch (autoc & IXGBE_AUTOC_LMS_MASK) {
	case IXGBE_AUTOC_LMS_1G_LINK_NO_AN:
		*speed = IXGBE_LINK_SPEED_1GB_FULL;
		*autoneg = FALSE;
		break;

	case IXGBE_AUTOC_LMS_10G_LINK_NO_AN:
		*speed = IXGBE_LINK_SPEED_10GB_FULL;
		*autoneg = FALSE;
		break;

	case IXGBE_AUTOC_LMS_1G_AN:
		*speed = IXGBE_LINK_SPEED_1GB_FULL;
		*autoneg = TRUE;
		break;

	case IXGBE_AUTOC_LMS_KX4_AN:
	case IXGBE_AUTOC_LMS_KX4_AN_1G_AN:
		*speed = IXGBE_LINK_SPEED_UNKNOWN;
		if (autoc & IXGBE_AUTOC_KX4_SUPP)
			*speed |= IXGBE_LINK_SPEED_10GB_FULL;
		if (autoc & IXGBE_AUTOC_KX_SUPP)
			*speed |= IXGBE_LINK_SPEED_1GB_FULL;
		*autoneg = TRUE;
		break;

	default:
		status = IXGBE_ERR_LINK_SETUP;
		break;
	}

	return status;
}

/**
 *  ixgbe_get_media_type_82598 - Determines media type
 *  @@hw: pointer to hardware structure
 *
 *  Returns the media type (fiber, copper, backplane)
 **/
enum ixgbe_media_type ixgbe_get_media_type_82598(struct ixgbe_hw *hw)
{
	enum ixgbe_media_type media_type;

	DEBUGFUNC("ixgbe_get_media_type_82598");

	/* Detect if there is a copper PHY attached. */
	switch (hw->phy.type) {
	case ixgbe_phy_cu_unknown:
	case ixgbe_phy_tn:
		media_type = ixgbe_media_type_copper;
		goto out;
	default:
		break;
	}

	/* Media type for I82598 is based on device ID */
	switch (hw->device_id) {
	case IXGBE_DEV_ID_82598:
	case IXGBE_DEV_ID_82598_BX:
		/* Default device ID is mezzanine card KX/KX4 */
		media_type = ixgbe_media_type_backplane;
		break;
	case IXGBE_DEV_ID_82598AF_DUAL_PORT:
	case IXGBE_DEV_ID_82598AF_SINGLE_PORT:
	case IXGBE_DEV_ID_82598_DA_DUAL_PORT:
	case IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM:
	case IXGBE_DEV_ID_82598EB_XF_LR:
	case IXGBE_DEV_ID_82598EB_SFP_LOM:
		media_type = ixgbe_media_type_fiber;
		break;
	case IXGBE_DEV_ID_82598EB_CX4:
	case IXGBE_DEV_ID_82598_CX4_DUAL_PORT:
		media_type = ixgbe_media_type_cx4;
		break;
	case IXGBE_DEV_ID_82598AT:
	case IXGBE_DEV_ID_82598AT2:
		media_type = ixgbe_media_type_copper;
		break;
	default:
		media_type = ixgbe_media_type_unknown;
		break;
	}
out:
	return media_type;
}

/**
 *  ixgbe_fc_enable_82598 - Enable flow control
 *  @@hw: pointer to hardware structure
 *
 *  Enable flow control according to the current settings.
 **/
int32_t ixgbe_fc_enable_82598(struct ixgbe_hw *hw)
{
	int32_t ret_val = IXGBE_SUCCESS;
	uint32_t fctrl_reg;
	uint32_t rmcs_reg;
	uint32_t reg;
	uint32_t fcrtl, fcrth;
	uint32_t link_speed = 0;
	int i;
	bool link_up;

	DEBUGFUNC("ixgbe_fc_enable_82598");

	/* Validate the water mark configuration */
	if (!hw->fc.pause_time) {
		ret_val = IXGBE_ERR_INVALID_LINK_SETTINGS;
		goto out;
	}

	/* Low water mark of zero causes XOFF floods */
	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
		if ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&
		    hw->fc.high_water[i]) {
			if (!hw->fc.low_water[i] ||
			    hw->fc.low_water[i] >= hw->fc.high_water[i]) {
				DEBUGOUT("Invalid water mark configuration\n");
				ret_val = IXGBE_ERR_INVALID_LINK_SETTINGS;
				goto out;
			}
		}
	}

	/*
	 * On 82598 having Rx FC on causes resets while doing 1G
	 * so if it's on turn it off once we know link_speed. For
	 * more details see 82598 Specification update.
	 */
	hw->mac.ops.check_link(hw, &link_speed, &link_up, FALSE);
	if (link_up && link_speed == IXGBE_LINK_SPEED_1GB_FULL) {
		switch (hw->fc.requested_mode) {
		case ixgbe_fc_full:
			hw->fc.requested_mode = ixgbe_fc_tx_pause;
			break;
		case ixgbe_fc_rx_pause:
			hw->fc.requested_mode = ixgbe_fc_none;
			break;
		default:
			/* no change */
			break;
		}
	}

	/* Negotiate the fc mode to use */
	ixgbe_fc_autoneg(hw);

	/* Disable any previous flow control settings */
	fctrl_reg = IXGBE_READ_REG(hw, IXGBE_FCTRL);
	fctrl_reg &= ~(IXGBE_FCTRL_RFCE | IXGBE_FCTRL_RPFCE);

	rmcs_reg = IXGBE_READ_REG(hw, IXGBE_RMCS);
	rmcs_reg &= ~(IXGBE_RMCS_TFCE_PRIORITY | IXGBE_RMCS_TFCE_802_3X);

	/*
	 * The possible values of fc.current_mode are:
	 * 0: Flow control is completely disabled
	 * 1: Rx flow control is enabled (we can receive pause frames,
	 *    but not send pause frames).
	 * 2: Tx flow control is enabled (we can send pause frames but
	 *     we do not support receiving pause frames).
	 * 3: Both Rx and Tx flow control (symmetric) are enabled.
	 * other: Invalid.
	 */
	switch (hw->fc.current_mode) {
	case ixgbe_fc_none:
		/*
		 * Flow control is disabled by software override or autoneg.
		 * The code below will actually disable it in the HW.
		 */
		break;
	case ixgbe_fc_rx_pause:
		/*
		 * Rx Flow control is enabled and Tx Flow control is
		 * disabled by software override. Since there really
		 * isn't a way to advertise that we are capable of RX
		 * Pause ONLY, we will advertise that we support both
		 * symmetric and asymmetric Rx PAUSE.  Later, we will
		 * disable the adapter's ability to send PAUSE frames.
		 */
		fctrl_reg |= IXGBE_FCTRL_RFCE;
		break;
	case ixgbe_fc_tx_pause:
		/*
		 * Tx Flow control is enabled, and Rx Flow control is
		 * disabled by software override.
		 */
		rmcs_reg |= IXGBE_RMCS_TFCE_802_3X;
		break;
	case ixgbe_fc_full:
		/* Flow control (both Rx and Tx) is enabled by SW override. */
		fctrl_reg |= IXGBE_FCTRL_RFCE;
		rmcs_reg |= IXGBE_RMCS_TFCE_802_3X;
		break;
	default:
		DEBUGOUT("Flow control param set incorrectly\n");
		ret_val = IXGBE_ERR_CONFIG;
		goto out;
		break;
	}

	/* Set 802.3x based flow control settings. */
	fctrl_reg |= IXGBE_FCTRL_DPF;
	IXGBE_WRITE_REG(hw, IXGBE_FCTRL, fctrl_reg);
	IXGBE_WRITE_REG(hw, IXGBE_RMCS, rmcs_reg);

	/* Set up and enable Rx high/low water mark thresholds, enable XON. */
	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
		if ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&
		    hw->fc.high_water[i]) {
			fcrtl = (hw->fc.low_water[i] << 10) | IXGBE_FCRTL_XONE;
			fcrth = (hw->fc.high_water[i] << 10) | IXGBE_FCRTH_FCEN;
			IXGBE_WRITE_REG(hw, IXGBE_FCRTL(i), fcrtl);
			IXGBE_WRITE_REG(hw, IXGBE_FCRTH(i), fcrth);
		} else {
			IXGBE_WRITE_REG(hw, IXGBE_FCRTL(i), 0);
			IXGBE_WRITE_REG(hw, IXGBE_FCRTH(i), 0);
		}

	}

	/* Configure pause time (2 TCs per register) */
	reg = hw->fc.pause_time * 0x00010001;
	for (i = 0; i < (IXGBE_DCB_MAX_TRAFFIC_CLASS / 2); i++)
		IXGBE_WRITE_REG(hw, IXGBE_FCTTV(i), reg);

	/* Configure flow control refresh threshold value */
	IXGBE_WRITE_REG(hw, IXGBE_FCRTV, hw->fc.pause_time / 2);

out:
	return ret_val;
}

/**
 *  ixgbe_start_mac_link_82598 - Configures MAC link settings
 *  @@hw: pointer to hardware structure
 *
 *  Configures link settings based on values in the ixgbe_hw struct.
 *  Restarts the link.  Performs autonegotiation if needed.
 **/
int32_t ixgbe_start_mac_link_82598(struct ixgbe_hw *hw,
				   bool autoneg_wait_to_complete)
{
	uint32_t autoc_reg;
	uint32_t links_reg;
	uint32_t i;
	int32_t status = IXGBE_SUCCESS;

	DEBUGFUNC("ixgbe_start_mac_link_82598");

	/* Restart link */
	autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
	autoc_reg |= IXGBE_AUTOC_AN_RESTART;
	IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc_reg);

	/* Only poll for autoneg to complete if specified to do so */
	if (autoneg_wait_to_complete) {
		if ((autoc_reg & IXGBE_AUTOC_LMS_MASK) ==
		     IXGBE_AUTOC_LMS_KX4_AN ||
		    (autoc_reg & IXGBE_AUTOC_LMS_MASK) ==
		     IXGBE_AUTOC_LMS_KX4_AN_1G_AN) {
			links_reg = 0; /* Just in case Autoneg time = 0 */
			for (i = 0; i < IXGBE_AUTO_NEG_TIME; i++) {
				links_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);
				if (links_reg & IXGBE_LINKS_KX_AN_COMP)
					break;
				msec_delay(100);
			}
			if (!(links_reg & IXGBE_LINKS_KX_AN_COMP)) {
				status = IXGBE_ERR_AUTONEG_NOT_COMPLETE;
				DEBUGOUT("Autonegotiation did not complete.\n");
			}
		}
	}

	/* Add delay to filter out noises during initial link setup */
	msec_delay(50);

	return status;
}

/**
 *  ixgbe_validate_link_ready - Function looks for phy link
 *  @@hw: pointer to hardware structure
 *
 *  Function indicates success when phy link is available. If phy is not ready
 *  within 5 seconds of MAC indicating link, the function returns error.
 **/
int32_t ixgbe_validate_link_ready(struct ixgbe_hw *hw)
{
	uint32_t timeout;
	uint16_t an_reg;

	if (hw->device_id != IXGBE_DEV_ID_82598AT2)
		return IXGBE_SUCCESS;

	for (timeout = 0;
	     timeout < IXGBE_VALIDATE_LINK_READY_TIMEOUT; timeout++) {
		hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_STATUS,
				     IXGBE_MDIO_AUTO_NEG_DEV_TYPE, &an_reg);

		if ((an_reg & IXGBE_MII_AUTONEG_COMPLETE) &&
		    (an_reg & IXGBE_MII_AUTONEG_LINK_UP))
			break;

		msec_delay(100);
	}

	if (timeout == IXGBE_VALIDATE_LINK_READY_TIMEOUT) {
		DEBUGOUT("Link was indicated but link is down\n");
		return IXGBE_ERR_LINK_SETUP;
	}

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_check_mac_link_82598 - Get link/speed status
 *  @@hw: pointer to hardware structure
 *  @@speed: pointer to link speed
 *  @@link_up: TRUE is link is up, FALSE otherwise
 *  @@link_up_wait_to_complete: bool used to wait for link up or not
 *
 *  Reads the links register to determine if link is up and the current speed
 **/
int32_t ixgbe_check_mac_link_82598(struct ixgbe_hw *hw,
				   ixgbe_link_speed *speed, bool *link_up,
				   bool link_up_wait_to_complete)
{
	uint32_t links_reg;
	uint32_t i;
	uint16_t link_reg, adapt_comp_reg;

	DEBUGFUNC("ixgbe_check_mac_link_82598");

	/*
	 * SERDES PHY requires us to read link status from undocumented
	 * register 0xC79F.  Bit 0 set indicates link is up/ready; clear
	 * indicates link down.  OxC00C is read to check that the XAUI lanes
	 * are active.  Bit 0 clear indicates active; set indicates inactive.
	 */
	if (hw->phy.type == ixgbe_phy_nl) {
		hw->phy.ops.read_reg(hw, 0xC79F, IXGBE_TWINAX_DEV, &link_reg);
		hw->phy.ops.read_reg(hw, 0xC79F, IXGBE_TWINAX_DEV, &link_reg);
		hw->phy.ops.read_reg(hw, 0xC00C, IXGBE_TWINAX_DEV,
				     &adapt_comp_reg);
		if (link_up_wait_to_complete) {
			for (i = 0; i < hw->mac.max_link_up_time; i++) {
				if ((link_reg & 1) &&
				    ((adapt_comp_reg & 1) == 0)) {
					*link_up = TRUE;
					break;
				} else {
					*link_up = FALSE;
				}
				msec_delay(100);
				hw->phy.ops.read_reg(hw, 0xC79F,
						     IXGBE_TWINAX_DEV,
						     &link_reg);
				hw->phy.ops.read_reg(hw, 0xC00C,
						     IXGBE_TWINAX_DEV,
						     &adapt_comp_reg);
			}
		} else {
			if ((link_reg & 1) && ((adapt_comp_reg & 1) == 0))
				*link_up = TRUE;
			else
				*link_up = FALSE;
		}

		if (*link_up == FALSE)
			goto out;
	}

	links_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);
	if (link_up_wait_to_complete) {
		for (i = 0; i < hw->mac.max_link_up_time; i++) {
			if (links_reg & IXGBE_LINKS_UP) {
				*link_up = TRUE;
				break;
			} else {
				*link_up = FALSE;
			}
			msec_delay(100);
			links_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);
		}
	} else {
		if (links_reg & IXGBE_LINKS_UP)
			*link_up = TRUE;
		else
			*link_up = FALSE;
	}

	if (links_reg & IXGBE_LINKS_SPEED)
		*speed = IXGBE_LINK_SPEED_10GB_FULL;
	else
		*speed = IXGBE_LINK_SPEED_1GB_FULL;

	if ((hw->device_id == IXGBE_DEV_ID_82598AT2) && (*link_up == TRUE) &&
	    (ixgbe_validate_link_ready(hw) != IXGBE_SUCCESS))
		*link_up = FALSE;

out:
	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_setup_mac_link_82598 - Set MAC link speed
 *  @@hw: pointer to hardware structure
 *  @@speed: new link speed
 *  @@autoneg_wait_to_complete: TRUE when waiting for completion is needed
 *
 *  Set the link speed in the AUTOC register and restarts link.
 **/
int32_t ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw,
				   ixgbe_link_speed speed,
				   bool autoneg_wait_to_complete)
{
	bool autoneg = FALSE;
	int32_t status = IXGBE_SUCCESS;
	ixgbe_link_speed link_capabilities = IXGBE_LINK_SPEED_UNKNOWN;
	uint32_t curr_autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);
	uint32_t autoc = curr_autoc;
	uint32_t link_mode = autoc & IXGBE_AUTOC_LMS_MASK;

	DEBUGFUNC("ixgbe_setup_mac_link_82598");

	/* Check to see if speed passed in is supported. */
	ixgbe_get_link_capabilities_82598(hw, &link_capabilities, &autoneg);
	speed &= link_capabilities;

	if (speed == IXGBE_LINK_SPEED_UNKNOWN)
		status = IXGBE_ERR_LINK_SETUP;

	/* Set KX4/KX support according to speed requested */
	else if (link_mode == IXGBE_AUTOC_LMS_KX4_AN ||
		 link_mode == IXGBE_AUTOC_LMS_KX4_AN_1G_AN) {
		autoc &= ~IXGBE_AUTOC_KX4_KX_SUPP_MASK;
		if (speed & IXGBE_LINK_SPEED_10GB_FULL)
			autoc |= IXGBE_AUTOC_KX4_SUPP;
		if (speed & IXGBE_LINK_SPEED_1GB_FULL)
			autoc |= IXGBE_AUTOC_KX_SUPP;
		if (autoc != curr_autoc)
			IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc);
	}

	if (status == IXGBE_SUCCESS) {
		/*
		 * Setup and restart the link based on the new values in
		 * ixgbe_hw This will write the AUTOC register based on the new
		 * stored values
		 */
		status = ixgbe_start_mac_link_82598(hw,
						    autoneg_wait_to_complete);
	}

	return status;
}


/**
 *  ixgbe_setup_copper_link_82598 - Set the PHY autoneg advertised field
 *  @@hw: pointer to hardware structure
 *  @@speed: new link speed
 *  @@autoneg_wait_to_complete: TRUE if waiting is needed to complete
 *
 *  Sets the link speed in the AUTOC register in the MAC and restarts link.
 **/
int32_t ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw,
				      ixgbe_link_speed speed,
				      bool autoneg_wait_to_complete)
{
	int32_t status;

	DEBUGFUNC("ixgbe_setup_copper_link_82598");

	/* Setup the PHY according to input speed */
	status = hw->phy.ops.setup_link_speed(hw, speed,
					      autoneg_wait_to_complete);
	/* Set up MAC */
	ixgbe_start_mac_link_82598(hw, autoneg_wait_to_complete);

	return status;
}

/**
 *  ixgbe_reset_hw_82598 - Performs hardware reset
 *  @@hw: pointer to hardware structure
 *
 *  Resets the hardware by resetting the transmit and receive units, masks and
 *  clears all interrupts, performing a PHY reset, and performing a link (MAC)
 *  reset.
 **/
int32_t ixgbe_reset_hw_82598(struct ixgbe_hw *hw)
{
	int32_t status = IXGBE_SUCCESS;
	int32_t phy_status = IXGBE_SUCCESS;
	uint32_t ctrl;
	uint32_t gheccr;
	uint32_t i;
	uint32_t autoc;
	uint8_t  analog_val;

	DEBUGFUNC("ixgbe_reset_hw_82598");

	/* Call adapter stop to disable tx/rx and clear interrupts */
	status = hw->mac.ops.stop_adapter(hw);
	if (status != IXGBE_SUCCESS)
		goto reset_hw_out;

	/*
	 * Power up the Atlas Tx lanes if they are currently powered down.
	 * Atlas Tx lanes are powered down for MAC loopback tests, but
	 * they are not automatically restored on reset.
	 */
	hw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK, &analog_val);
	if (analog_val & IXGBE_ATLAS_PDN_TX_REG_EN) {
		/* Enable Tx Atlas so packets can be transmitted again */
		hw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK,
					     &analog_val);
		analog_val &= ~IXGBE_ATLAS_PDN_TX_REG_EN;
		hw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK,
					      analog_val);

		hw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_10G,
					     &analog_val);
		analog_val &= ~IXGBE_ATLAS_PDN_TX_10G_QL_ALL;
		hw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_10G,
					      analog_val);

		hw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_1G,
					     &analog_val);
		analog_val &= ~IXGBE_ATLAS_PDN_TX_1G_QL_ALL;
		hw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_1G,
					      analog_val);

		hw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_AN,
					     &analog_val);
		analog_val &= ~IXGBE_ATLAS_PDN_TX_AN_QL_ALL;
		hw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_AN,
					      analog_val);
	}

	/* Reset PHY */
	if (hw->phy.reset_disable == FALSE) {
		/* PHY ops must be identified and initialized prior to reset */

		/* Init PHY and function pointers, perform SFP setup */
		phy_status = hw->phy.ops.init(hw);
		if (phy_status == IXGBE_ERR_SFP_NOT_SUPPORTED)
			goto reset_hw_out;
		if (phy_status == IXGBE_ERR_SFP_NOT_PRESENT)
			goto mac_reset_top;

		hw->phy.ops.reset(hw);
	}

mac_reset_top:
	/*
	 * Issue global reset to the MAC.  This needs to be a SW reset.
	 * If link reset is used, it might reset the MAC when mng is using it
	 */
	ctrl = IXGBE_READ_REG(hw, IXGBE_CTRL) | IXGBE_CTRL_RST;
	IXGBE_WRITE_REG(hw, IXGBE_CTRL, ctrl);
	IXGBE_WRITE_FLUSH(hw);

	/* Poll for reset bit to self-clear indicating reset is complete */
	for (i = 0; i < 10; i++) {
		usec_delay(1);
		ctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);
		if (!(ctrl & IXGBE_CTRL_RST))
			break;
	}
	if (ctrl & IXGBE_CTRL_RST) {
		status = IXGBE_ERR_RESET_FAILED;
		DEBUGOUT("Reset polling failed to complete.\n");
	}

	msec_delay(50);

	/*
	 * Double resets are required for recovery from certain error
	 * conditions.  Between resets, it is necessary to stall to allow time
	 * for any pending HW events to complete.
	 */
	if (hw->mac.flags & IXGBE_FLAGS_DOUBLE_RESET_REQUIRED) {
		hw->mac.flags &= ~IXGBE_FLAGS_DOUBLE_RESET_REQUIRED;
		goto mac_reset_top;
	}

	gheccr = IXGBE_READ_REG(hw, IXGBE_GHECCR);
	gheccr &= ~((1 << 21) | (1 << 18) | (1 << 9) | (1 << 6));
	IXGBE_WRITE_REG(hw, IXGBE_GHECCR, gheccr);

	/*
	 * Store the original AUTOC value if it has not been
	 * stored off yet.  Otherwise restore the stored original
	 * AUTOC value since the reset operation sets back to deaults.
	 */
	autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);
	if (hw->mac.orig_link_settings_stored == FALSE) {
		hw->mac.orig_autoc = autoc;
		hw->mac.orig_link_settings_stored = TRUE;
	} else if (autoc != hw->mac.orig_autoc) {
		IXGBE_WRITE_REG(hw, IXGBE_AUTOC, hw->mac.orig_autoc);
	}

	/* Store the permanent mac address */
	hw->mac.ops.get_mac_addr(hw, hw->mac.perm_addr);

	/*
	 * Store MAC address from RAR0, clear receive address registers, and
	 * clear the multicast table
	 */
	hw->mac.ops.init_rx_addrs(hw);

reset_hw_out:
	if (phy_status != IXGBE_SUCCESS)
		status = phy_status;

	return status;
}

/**
 *  ixgbe_set_vmdq_82598 - Associate a VMDq set index with a rx address
 *  @@hw: pointer to hardware struct
 *  @@rar: receive address register index to associate with a VMDq index
 *  @@vmdq: VMDq set index
 **/
int32_t ixgbe_set_vmdq_82598(struct ixgbe_hw *hw, uint32_t rar, uint32_t vmdq)
{
	uint32_t rar_high;
	uint32_t rar_entries = hw->mac.num_rar_entries;

	DEBUGFUNC("ixgbe_set_vmdq_82598");

	/* Make sure we are using a valid rar index range */
	if (rar >= rar_entries) {
		DEBUGOUT1("RAR index %d is out of range.\n", rar);
		return IXGBE_ERR_INVALID_ARGUMENT;
	}

	rar_high = IXGBE_READ_REG(hw, IXGBE_RAH(rar));
	rar_high &= ~IXGBE_RAH_VIND_MASK;
	rar_high |= ((vmdq << IXGBE_RAH_VIND_SHIFT) & IXGBE_RAH_VIND_MASK);
	IXGBE_WRITE_REG(hw, IXGBE_RAH(rar), rar_high);
	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_clear_vmdq_82598 - Disassociate a VMDq set index from an rx address
 *  @@hw: pointer to hardware struct
 *  @@rar: receive address register index to associate with a VMDq index
 *  @@vmdq: VMDq clear index (not used in 82598, but elsewhere)
 **/
int32_t ixgbe_clear_vmdq_82598(struct ixgbe_hw *hw, uint32_t rar, uint32_t vmdq)
{
	uint32_t rar_high;
	uint32_t rar_entries = hw->mac.num_rar_entries;

	/* Make sure we are using a valid rar index range */
	if (rar >= rar_entries) {
		DEBUGOUT1("RAR index %d is out of range.\n", rar);
		return IXGBE_ERR_INVALID_ARGUMENT;
	}

	rar_high = IXGBE_READ_REG(hw, IXGBE_RAH(rar));
	if (rar_high & IXGBE_RAH_VIND_MASK) {
		rar_high &= ~IXGBE_RAH_VIND_MASK;
		IXGBE_WRITE_REG(hw, IXGBE_RAH(rar), rar_high);
	}

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_set_vfta_82598 - Set VLAN filter table
 *  @@hw: pointer to hardware structure
 *  @@vlan: VLAN id to write to VLAN filter
 *  @@vind: VMDq output index that maps queue to VLAN id in VFTA
 *  @@vlan_on: boolean flag to turn on/off VLAN in VFTA
 *
 *  Turn on/off specified VLAN in the VLAN filter table.
 **/
int32_t ixgbe_set_vfta_82598(struct ixgbe_hw *hw, uint32_t vlan, uint32_t vind,
			     bool vlan_on)
{
	uint32_t regindex;
	uint32_t bitindex;
	uint32_t bits;
	uint32_t vftabyte;

	DEBUGFUNC("ixgbe_set_vfta_82598");

	if (vlan > 4095)
		return IXGBE_ERR_PARAM;

	/* Determine 32-bit word position in array */
	regindex = (vlan >> 5) & 0x7F;   /* upper seven bits */

	/* Determine the location of the (VMD) queue index */
	vftabyte =  ((vlan >> 3) & 0x03); /* bits (4:3) indicating byte array */
	bitindex = (vlan & 0x7) << 2;    /* lower 3 bits indicate nibble */

	/* Set the nibble for VMD queue index */
	bits = IXGBE_READ_REG(hw, IXGBE_VFTAVIND(vftabyte, regindex));
	bits &= (~(0x0F << bitindex));
	bits |= (vind << bitindex);
	IXGBE_WRITE_REG(hw, IXGBE_VFTAVIND(vftabyte, regindex), bits);

	/* Determine the location of the bit for this VLAN id */
	bitindex = vlan & 0x1F;   /* lower five bits */

	bits = IXGBE_READ_REG(hw, IXGBE_VFTA(regindex));
	if (vlan_on)
		/* Turn on this VLAN id */
		bits |= (1 << bitindex);
	else
		/* Turn off this VLAN id */
		bits &= ~(1 << bitindex);
	IXGBE_WRITE_REG(hw, IXGBE_VFTA(regindex), bits);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_clear_vfta_82598 - Clear VLAN filter table
 *  @@hw: pointer to hardware structure
 *
 *  Clears the VLAN filer table, and the VMDq index associated with the filter
 **/
int32_t ixgbe_clear_vfta_82598(struct ixgbe_hw *hw)
{
	uint32_t offset;
	uint32_t vlanbyte;

	DEBUGFUNC("ixgbe_clear_vfta_82598");

	for (offset = 0; offset < hw->mac.vft_size; offset++)
		IXGBE_WRITE_REG(hw, IXGBE_VFTA(offset), 0);

	for (vlanbyte = 0; vlanbyte < 4; vlanbyte++)
		for (offset = 0; offset < hw->mac.vft_size; offset++)
			IXGBE_WRITE_REG(hw, IXGBE_VFTAVIND(vlanbyte, offset),
					0);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_read_analog_reg8_82598 - Reads 8 bit Atlas analog register
 *  @@hw: pointer to hardware structure
 *  @@reg: analog register to read
 *  @@val: read value
 *
 *  Performs read operation to Atlas analog register specified.
 **/
int32_t ixgbe_read_analog_reg8_82598(struct ixgbe_hw *hw, uint32_t reg, uint8_t *val)
{
	uint32_t  atlas_ctl;

	DEBUGFUNC("ixgbe_read_analog_reg8_82598");

	IXGBE_WRITE_REG(hw, IXGBE_ATLASCTL,
			IXGBE_ATLASCTL_WRITE_CMD | (reg << 8));
	IXGBE_WRITE_FLUSH(hw);
	usec_delay(10);
	atlas_ctl = IXGBE_READ_REG(hw, IXGBE_ATLASCTL);
	*val = (uint8_t)atlas_ctl;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_write_analog_reg8_82598 - Writes 8 bit Atlas analog register
 *  @@hw: pointer to hardware structure
 *  @@reg: atlas register to write
 *  @@val: value to write
 *
 *  Performs write operation to Atlas analog register specified.
 **/
int32_t ixgbe_write_analog_reg8_82598(struct ixgbe_hw *hw, uint32_t reg, uint8_t val)
{
	uint32_t  atlas_ctl;

	DEBUGFUNC("ixgbe_write_analog_reg8_82598");

	atlas_ctl = (reg << 8) | val;
	IXGBE_WRITE_REG(hw, IXGBE_ATLASCTL, atlas_ctl);
	IXGBE_WRITE_FLUSH(hw);
	usec_delay(10);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_read_i2c_phy_82598 - Reads 8 bit word over I2C interface.
 *  @@hw: pointer to hardware structure
 *  @@dev_addr: address to read from
 *  @@byte_offset: byte offset to read from dev_addr
 *  @@eeprom_data: value read
 *
 *  Performs 8 byte read operation to SFP module's EEPROM over I2C interface.
 **/
int32_t ixgbe_read_i2c_phy_82598(struct ixgbe_hw *hw, uint8_t dev_addr,
				 uint8_t byte_offset, uint8_t *eeprom_data)
{
	int32_t status = IXGBE_SUCCESS;
	uint16_t sfp_addr = 0;
	uint16_t sfp_data = 0;
	uint16_t sfp_stat = 0;
	uint16_t gssr;
	uint32_t i;

	DEBUGFUNC("ixgbe_read_i2c_phy_82598");

	if (IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_LAN_ID_1)
		gssr = IXGBE_GSSR_PHY1_SM;
	else
		gssr = IXGBE_GSSR_PHY0_SM;

	if (hw->mac.ops.acquire_swfw_sync(hw, gssr) != IXGBE_SUCCESS)
		return IXGBE_ERR_SWFW_SYNC;

	if (hw->phy.type == ixgbe_phy_nl) {
		/*
		 * NetLogic phy SDA/SCL registers are at addresses 0xC30A to
		 * 0xC30D. These registers are used to talk to the SFP+
		 * module's EEPROM through the SDA/SCL (I2C) interface.
		 */
		sfp_addr = (dev_addr << 8) + byte_offset;
		sfp_addr = (sfp_addr | IXGBE_I2C_EEPROM_READ_MASK);
		hw->phy.ops.write_reg_mdi(hw,
					  IXGBE_MDIO_PMA_PMD_SDA_SCL_ADDR,
					  IXGBE_MDIO_PMA_PMD_DEV_TYPE,
					  sfp_addr);

		/* Poll status */
		for (i = 0; i < 100; i++) {
			hw->phy.ops.read_reg_mdi(hw,
						IXGBE_MDIO_PMA_PMD_SDA_SCL_STAT,
						IXGBE_MDIO_PMA_PMD_DEV_TYPE,
						&sfp_stat);
			sfp_stat = sfp_stat & IXGBE_I2C_EEPROM_STATUS_MASK;
			if (sfp_stat != IXGBE_I2C_EEPROM_STATUS_IN_PROGRESS)
				break;
			msec_delay(10);
		}

		if (sfp_stat != IXGBE_I2C_EEPROM_STATUS_PASS) {
			DEBUGOUT("EEPROM read did not pass.\n");
			status = IXGBE_ERR_SFP_NOT_PRESENT;
			goto out;
		}

		/* Read data */
		hw->phy.ops.read_reg_mdi(hw, IXGBE_MDIO_PMA_PMD_SDA_SCL_DATA,
					IXGBE_MDIO_PMA_PMD_DEV_TYPE, &sfp_data);

		*eeprom_data = (uint8_t)(sfp_data >> 8);
	} else {
		status = IXGBE_ERR_PHY;
	}

out:
	hw->mac.ops.release_swfw_sync(hw, gssr);
	return status;
}

/**
 *  ixgbe_read_i2c_eeprom_82598 - Reads 8 bit word over I2C interface.
 *  @@hw: pointer to hardware structure
 *  @@byte_offset: EEPROM byte offset to read
 *  @@eeprom_data: value read
 *
 *  Performs 8 byte read operation to SFP module's EEPROM over I2C interface.
 **/
int32_t ixgbe_read_i2c_eeprom_82598(struct ixgbe_hw *hw, uint8_t byte_offset,
				    uint8_t *eeprom_data)
{
	return ixgbe_read_i2c_phy_82598(hw, IXGBE_I2C_EEPROM_DEV_ADDR,
					byte_offset, eeprom_data);
}

/**
 *  ixgbe_get_supported_physical_layer_82598 - Returns physical layer type
 *  @@hw: pointer to hardware structure
 *
 *  Determines physical layer capabilities of the current configuration.
 **/
uint32_t ixgbe_get_supported_physical_layer_82598(struct ixgbe_hw *hw)
{
	uint32_t physical_layer = IXGBE_PHYSICAL_LAYER_UNKNOWN;
	uint32_t autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);
	uint32_t pma_pmd_10g = autoc & IXGBE_AUTOC_10G_PMA_PMD_MASK;
	uint32_t pma_pmd_1g = autoc & IXGBE_AUTOC_1G_PMA_PMD_MASK;
	uint16_t ext_ability = 0;

	DEBUGFUNC("ixgbe_get_supported_physical_layer_82598");

	hw->phy.ops.identify(hw);

	/* Copper PHY must be checked before AUTOC LMS to determine correct
	 * physical layer because 10GBase-T PHYs use LMS = KX4/KX */
	switch (hw->phy.type) {
	case ixgbe_phy_tn:
	case ixgbe_phy_cu_unknown:
		hw->phy.ops.read_reg(hw, IXGBE_MDIO_PHY_EXT_ABILITY,
		IXGBE_MDIO_PMA_PMD_DEV_TYPE, &ext_ability);
		if (ext_ability & IXGBE_MDIO_PHY_10GBASET_ABILITY)
			physical_layer |= IXGBE_PHYSICAL_LAYER_10GBASE_T;
		if (ext_ability & IXGBE_MDIO_PHY_1000BASET_ABILITY)
			physical_layer |= IXGBE_PHYSICAL_LAYER_1000BASE_T;
		if (ext_ability & IXGBE_MDIO_PHY_100BASETX_ABILITY)
			physical_layer |= IXGBE_PHYSICAL_LAYER_100BASE_TX;
		goto out;
	default:
		break;
	}

	switch (autoc & IXGBE_AUTOC_LMS_MASK) {
	case IXGBE_AUTOC_LMS_1G_AN:
	case IXGBE_AUTOC_LMS_1G_LINK_NO_AN:
		if (pma_pmd_1g == IXGBE_AUTOC_1G_KX)
			physical_layer = IXGBE_PHYSICAL_LAYER_1000BASE_KX;
		else
			physical_layer = IXGBE_PHYSICAL_LAYER_1000BASE_BX;
		break;
	case IXGBE_AUTOC_LMS_10G_LINK_NO_AN:
		if (pma_pmd_10g == IXGBE_AUTOC_10G_CX4)
			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_CX4;
		else if (pma_pmd_10g == IXGBE_AUTOC_10G_KX4)
			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_KX4;
		else { /* XAUI */
			if (autoc & IXGBE_AUTOC_KX_SUPP)
				physical_layer |=
				    IXGBE_PHYSICAL_LAYER_1000BASE_KX;
			if (autoc & IXGBE_AUTOC_KX4_SUPP)
				physical_layer |=
				    IXGBE_PHYSICAL_LAYER_10GBASE_KX4;
		}
		break;
	case IXGBE_AUTOC_LMS_KX4_AN:
	case IXGBE_AUTOC_LMS_KX4_AN_1G_AN:
		if (autoc & IXGBE_AUTOC_KX_SUPP)
			physical_layer |= IXGBE_PHYSICAL_LAYER_1000BASE_KX;
		if (autoc & IXGBE_AUTOC_KX4_SUPP)
			physical_layer |= IXGBE_PHYSICAL_LAYER_10GBASE_KX4;
		break;
	default:
		break;
	}

	if (hw->phy.type == ixgbe_phy_nl) {
		hw->phy.ops.identify_sfp(hw);

		switch (hw->phy.sfp_type) {
		case ixgbe_sfp_type_da_cu:
			physical_layer = IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU;
			break;
		case ixgbe_sfp_type_sr:
			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_SR;
			break;
		case ixgbe_sfp_type_lr:
			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_LR;
			break;
		default:
			physical_layer = IXGBE_PHYSICAL_LAYER_UNKNOWN;
			break;
		}
	}

	switch (hw->device_id) {
	case IXGBE_DEV_ID_82598_DA_DUAL_PORT:
		physical_layer = IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU;
		break;
	case IXGBE_DEV_ID_82598AF_DUAL_PORT:
	case IXGBE_DEV_ID_82598AF_SINGLE_PORT:
	case IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM:
		physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_SR;
		break;
	case IXGBE_DEV_ID_82598EB_XF_LR:
		physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_LR;
		break;
	default:
		break;
	}

out:
	return physical_layer;
}

/**
 *  ixgbe_set_lan_id_multi_port_pcie_82598 - Set LAN id for PCIe multiple
 *  port devices.
 *  @@hw: pointer to the HW structure
 *
 *  Calls common function and corrects issue with some single port devices
 *  that enable LAN1 but not LAN0.
 **/
void ixgbe_set_lan_id_multi_port_pcie_82598(struct ixgbe_hw *hw)
{
	struct ixgbe_bus_info *bus = &hw->bus;
	uint16_t pci_gen = 0;
	uint16_t pci_ctrl2 = 0;

	DEBUGFUNC("ixgbe_set_lan_id_multi_port_pcie_82598");

	ixgbe_set_lan_id_multi_port_pcie(hw);

	/* check if LAN0 is disabled */
	hw->eeprom.ops.read(hw, IXGBE_PCIE_GENERAL_PTR, &pci_gen);
	if ((pci_gen != 0) && (pci_gen != 0xFFFF)) {

		hw->eeprom.ops.read(hw, pci_gen + IXGBE_PCIE_CTRL2, &pci_ctrl2);

		/* if LAN0 is completely disabled force function to 0 */
		if ((pci_ctrl2 & IXGBE_PCIE_CTRL2_LAN_DISABLE) &&
		    !(pci_ctrl2 & IXGBE_PCIE_CTRL2_DISABLE_SELECT) &&
		    !(pci_ctrl2 & IXGBE_PCIE_CTRL2_DUMMY_ENABLE)) {

			bus->func = 0;
		}
	}
}

/**
 *  ixgbe_enable_rx_dma_82598 - Enable the Rx DMA unit
 *  @@hw: pointer to hardware structure
 *  @@regval: register value to write to RXCTRL
 *
 *  Enables the Rx DMA unit
 **/
int32_t ixgbe_enable_rx_dma_82598(struct ixgbe_hw *hw, uint32_t regval)
{
	DEBUGFUNC("ixgbe_enable_rx_dma_82598");

	IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, regval);

	return IXGBE_SUCCESS;
}
@


1.14
log
@Update 82598 specific module

A custom method to enable RX DMA is introduced because of the
upcoming API change in the common code.  Otherwise it's just
a copy of the ixgbe_enable_rx_dma_generic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82598.c,v 1.13 2016/11/17 12:21:27 mikeb Exp $	*/
d669 1
a669 1
			for (i = 0; i < IXGBE_LINK_UP_TIME; i++) {
d698 1
a698 1
		for (i = 0; i < IXGBE_LINK_UP_TIME; i++) {
@


1.13
log
@Style and typo fixes; no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82598.c,v 1.12 2016/11/16 23:19:29 mikeb Exp $	*/
d5 1
a5 1
  Copyright (c) 2001-2013, Intel Corporation
d35 1
a35 1
/* FreeBSD: src/sys/dev/ixgbe/ixgbe_82598.c 251964 Jun 18 21:28:19 2013 UTC */
d83 1
d157 1
d172 1
a173 1
	mac->max_rx_queues	= IXGBE_82598_MAX_RX_QUEUES;
d269 2
d289 1
a289 2
	if (ret_val == IXGBE_SUCCESS)
		ixgbe_set_pcie_completion_timeout(hw);
d1346 16
@


1.12
log
@Remove unused bits; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82598.c,v 1.11 2013/08/05 19:58:06 mikeb Exp $	*/
d40 7
d145 1
a145 1
	phy->ops.init = &ixgbe_init_phy_ops_82598;
d148 3
a150 3
	mac->ops.start_hw = &ixgbe_start_hw_82598;
	mac->ops.reset_hw = &ixgbe_reset_hw_82598;
	mac->ops.get_media_type = &ixgbe_get_media_type_82598;
d152 4
a155 4
				&ixgbe_get_supported_physical_layer_82598;
	mac->ops.read_analog_reg8 = &ixgbe_read_analog_reg8_82598;
	mac->ops.write_analog_reg8 = &ixgbe_write_analog_reg8_82598;
	mac->ops.set_lan_id = &ixgbe_set_lan_id_multi_port_pcie_82598;
d158 4
a161 4
	mac->ops.set_vmdq = &ixgbe_set_vmdq_82598;
	mac->ops.clear_vmdq = &ixgbe_clear_vmdq_82598;
	mac->ops.set_vfta = &ixgbe_set_vfta_82598;
	mac->ops.clear_vfta = &ixgbe_clear_vfta_82598;
d164 1
a164 1
	mac->ops.fc_enable = &ixgbe_fc_enable_82598;
d166 6
a171 6
	mac->mcft_size		= 128;
	mac->vft_size		= 128;
	mac->num_rar_entries	= 16;
	mac->rx_pb_size		= 512;
	mac->max_tx_queues	= 32;
	mac->max_rx_queues	= 64;
d175 1
a175 1
	phy->ops.read_i2c_eeprom = &ixgbe_read_i2c_eeprom_82598;
d178 2
a179 2
	mac->ops.check_link = &ixgbe_check_mac_link_82598;
	mac->ops.setup_link = &ixgbe_setup_mac_link_82598;
d181 1
a181 1
	mac->ops.get_link_capabilities = &ixgbe_get_link_capabilities_82598;
d209 1
a209 1
		mac->ops.setup_link = &ixgbe_setup_copper_link_82598;
d211 1
a211 1
				&ixgbe_get_copper_link_capabilities_generic;
d216 2
a217 2
		phy->ops.setup_link = &ixgbe_setup_phy_link_tnx;
		phy->ops.check_link = &ixgbe_check_phy_link_tnx;
d219 1
a219 1
					&ixgbe_get_phy_firmware_version_tnx;
d222 1
a222 1
		phy->ops.reset = &ixgbe_reset_phy_nl;
@


1.11
log
@First stab at updating this monster to the Intel/FreeBSD current version.
This syncs PHY and chip dependent parts as well as brings support for the
flow control and additional (untested) bits for 1G fiber versions.

Tested by Hrvoje Popovski <hrvoje at srce ! hr> on 82599/SFP+DA, florian@@
and benno@@ on 82599/SFP+SR and on 82598/CX4-BP, 82599/SFP+DA and X540/RJ45
by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82598.c,v 1.10 2012/12/17 12:03:16 mikeb Exp $	*/
a141 1
	mac->ops.enable_relaxed_ordering = &ixgbe_enable_relaxed_ordering_82598;
a1335 30
}

/**
 *  ixgbe_enable_relaxed_ordering_82598 - enable relaxed ordering
 *  @@hw: pointer to hardware structure
 *
 **/
void ixgbe_enable_relaxed_ordering_82598(struct ixgbe_hw *hw)
{
	uint32_t regval;
	uint32_t i;

	DEBUGFUNC("ixgbe_enable_relaxed_ordering_82598");

	/* Enable relaxed ordering */
	for (i = 0; ((i < hw->mac.max_tx_queues) &&
	     (i < IXGBE_DCA_MAX_QUEUES_82598)); i++) {
		regval = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL(i));
		regval |= IXGBE_DCA_TXCTRL_DESC_WRO_EN;
		IXGBE_WRITE_REG(hw, IXGBE_DCA_TXCTRL(i), regval);
	}

	for (i = 0; ((i < hw->mac.max_rx_queues) &&
	     (i < IXGBE_DCA_MAX_QUEUES_82598)); i++) {
		regval = IXGBE_READ_REG(hw, IXGBE_DCA_RXCTRL(i));
		regval |= IXGBE_DCA_RXCTRL_DATA_WRO_EN |
			  IXGBE_DCA_RXCTRL_HEAD_WRO_EN;
		IXGBE_WRITE_REG(hw, IXGBE_DCA_RXCTRL(i), regval);
	}

@


1.10
log
@Fix a link autonegotiation bug on 10GbaseT controllers and improve
link information reporting in general.  Obtained for the most part
from FreeBSD, tested by mxb at alumni ! chalmers ! se on X540 and
me on 82598 (XAUI, KR4), 82599 (SFP+) and X540 (baseT); ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82598.c,v 1.9 2012/12/07 13:03:31 mikeb Exp $	*/
d5 1
a5 1
  Copyright (c) 2001-2009, Intel Corporation
d35 1
a35 1
/*$FreeBSD: src/sys/dev/ixgbe/ixgbe_82598.c,v 1.9 2009/12/07 21:30:54 jfv Exp $*/
a40 1
int32_t ixgbe_init_ops_82598(struct ixgbe_hw *hw);
d42 2
a43 2
				      ixgbe_link_speed *speed,
				      int *autoneg);
d45 1
a45 1
int32_t ixgbe_fc_enable_82598(struct ixgbe_hw *hw, int32_t packetbuf_num);
d47 1
a47 1
			       int autoneg_wait_to_complete);
d50 2
a51 2
			       ixgbe_link_speed *speed,
			       int *link_up, int link_up_wait_to_complete);
d53 2
a54 3
				     ixgbe_link_speed speed,
				     int autoneg,
				     int autoneg_wait_to_complete);
d56 2
a57 3
					ixgbe_link_speed speed,
					int autoneg,
					int autoneg_wait_to_complete);
d64 1
a64 1
			 uint32_t vind, int vlan_on);
d68 2
d71 1
a71 1
				uint8_t *eeprom_data);
a119 23
 *  ixgbe_get_pcie_msix_count_82598 - Gets MSI-X vector count
 *  @@hw: pointer to hardware structure
 *
 *  Read PCIe configuration space, and get the MSI-X vector count from
 *  the capabilities table.
 **/
uint32_t ixgbe_get_pcie_msix_count_82598(struct ixgbe_hw *hw)
{
	uint32_t msix_count = 18;

	if (hw->mac.msix_vectors_from_pcie) {
		msix_count = IXGBE_READ_PCIE_WORD(hw,
						  IXGBE_PCIE_MSIX_82598_CAPS);
		msix_count &= IXGBE_PCIE_MSIX_TBL_SZ_MASK;

		/* MSI-X count is zero-based in HW, so increment to give
		 * proper value */
		msix_count++;
	}
	return msix_count;
}

/**
d132 2
d146 1
a146 1
				    &ixgbe_get_supported_physical_layer_82598;
d160 7
a166 7
	mac->mcft_size       = 128;
	mac->vft_size        = 128;
	mac->num_rar_entries = 16;
	mac->rx_pb_size      = 512;
	mac->max_tx_queues   = 32;
	mac->max_rx_queues   = 64;
	mac->max_msix_vectors = ixgbe_get_pcie_msix_count_82598(hw);
d175 1
a175 2
	mac->ops.get_link_capabilities =
			       &ixgbe_get_link_capabilities_82598;
d196 2
d205 1
a205 1
				  &ixgbe_get_copper_link_capabilities_generic;
d213 1
a213 1
			     &ixgbe_get_phy_firmware_version_tnx;
d229 2
a230 2
							    &list_offset,
							    &data_offset);
d249 2
a250 1
 *  Then set pcie completion timeout
d258 2
d266 1
a266 1
		regval &= ~IXGBE_DCA_TXCTRL_TX_WB_RO_EN;
d273 2
a274 2
		regval &= ~(IXGBE_DCA_RXCTRL_DESC_WRO_EN |
			    IXGBE_DCA_RXCTRL_DESC_HSRO_EN);
d294 2
a295 2
				      ixgbe_link_speed *speed,
				      int *autoneg)
d300 2
d356 2
a401 1
 *  @@packetbuf_num: packet buffer number (0-7)
d405 1
a405 1
int32_t ixgbe_fc_enable_82598(struct ixgbe_hw *hw, int32_t packetbuf_num)
d411 1
a411 1
	uint32_t rx_pba_size;
d413 23
a435 1
	int link_up;
d458 1
a458 3
	ret_val = ixgbe_fc_autoneg(hw);
	if (ret_val == IXGBE_ERR_FLOW_CONTROL)
		goto out;
d520 11
a530 3
	if (hw->fc.current_mode & ixgbe_fc_tx_pause) {
		rx_pba_size = IXGBE_READ_REG(hw, IXGBE_RXPBSIZE(packetbuf_num));
		rx_pba_size >>= IXGBE_RXPBSIZE_SHIFT;
a531 10
		reg = (rx_pba_size - hw->fc.low_water) << 6;
		if (hw->fc.send_xon)
			reg |= IXGBE_FCRTL_XONE;

		IXGBE_WRITE_REG(hw, IXGBE_FCRTL(packetbuf_num), reg);

		reg = (rx_pba_size - hw->fc.high_water) << 6;
		reg |= IXGBE_FCRTH_FCEN;

		IXGBE_WRITE_REG(hw, IXGBE_FCRTH(packetbuf_num), reg);
d535 3
a537 6
	reg = IXGBE_READ_REG(hw, IXGBE_FCTTV(packetbuf_num / 2));
	if ((packetbuf_num & 1) == 0)
		reg = (reg & 0xFFFF0000) | hw->fc.pause_time;
	else
		reg = (reg & 0x0000FFFF) | (hw->fc.pause_time << 16);
	IXGBE_WRITE_REG(hw, IXGBE_FCTTV(packetbuf_num / 2), reg);
d539 2
a540 1
	IXGBE_WRITE_REG(hw, IXGBE_FCRTV, (hw->fc.pause_time >> 1));
d554 1
a554 1
				       int autoneg_wait_to_complete)
d561 2
d638 3
a640 2
int32_t ixgbe_check_mac_link_82598(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
			       int *link_up, int link_up_wait_to_complete)
d646 2
a722 1
 *  @@autoneg: TRUE if autonegotiation enabled
d728 2
a729 2
				     ixgbe_link_speed speed, int autoneg,
				     int autoneg_wait_to_complete)
d731 2
a732 1
	int32_t          status            = IXGBE_SUCCESS;
d734 5
a738 3
	uint32_t         curr_autoc        = IXGBE_READ_REG(hw, IXGBE_AUTOC);
	uint32_t         autoc             = curr_autoc;
	uint32_t         link_mode         = autoc & IXGBE_AUTOC_LMS_MASK;
d741 1
a741 1
	ixgbe_hw(hw, get_link_capabilities, &link_capabilities, &autoneg);
a776 1
 *  @@autoneg: TRUE if autonegotiation enabled
d782 2
a783 3
					ixgbe_link_speed speed,
					int autoneg,
					int autoneg_wait_to_complete)
d787 2
d790 1
a790 1
	status = hw->phy.ops.setup_link_speed(hw, speed, autoneg,
d816 2
d819 3
a821 1
	hw->mac.ops.stop_adapter(hw);
d864 2
a865 2
		else if (phy_status == IXGBE_ERR_SFP_NOT_PRESENT)
			goto no_phy_reset;
a869 7
no_phy_reset:
	/*
	 * Prevent the PCI-E bus from from hanging by disabling PCI-E master
	 * access and verify no pending requests before reset
	 */
	ixgbe_disable_pcie_master(hw);

d875 2
a876 2
	ctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);
	IXGBE_WRITE_REG(hw, IXGBE_CTRL, (ctrl | IXGBE_CTRL_RST));
d947 2
a972 2
	UNREFERENCED_PARAMETER(vmdq);

d998 1
a998 1
						      int vlan_on)
d1005 2
d1049 2
d1074 2
d1098 2
d1109 1
a1109 1
 *  ixgbe_read_i2c_eeprom_82598 - Reads 8 bit word over I2C interface.
d1111 2
a1112 1
 *  @@byte_offset: EEPROM byte offset to read
d1117 2
a1118 2
int32_t ixgbe_read_i2c_eeprom_82598(struct ixgbe_hw *hw, uint8_t byte_offset,
				uint8_t *eeprom_data)
d1124 1
d1127 10
d1143 1
a1143 1
		sfp_addr = (IXGBE_I2C_EEPROM_DEV_ADDR << 8) + byte_offset;
d1145 4
a1148 4
		hw->phy.ops.write_reg(hw,
				      IXGBE_MDIO_PMA_PMD_SDA_SCL_ADDR,
				      IXGBE_MDIO_PMA_PMD_DEV_TYPE,
				      sfp_addr);
d1152 4
a1155 4
			hw->phy.ops.read_reg(hw,
					     IXGBE_MDIO_PMA_PMD_SDA_SCL_STAT,
					     IXGBE_MDIO_PMA_PMD_DEV_TYPE,
					     &sfp_stat);
d1169 2
a1170 2
		hw->phy.ops.read_reg(hw, IXGBE_MDIO_PMA_PMD_SDA_SCL_DATA,
				     IXGBE_MDIO_PMA_PMD_DEV_TYPE, &sfp_data);
a1174 1
		goto out;
d1178 1
d1183 15
d1211 2
d1316 4
a1319 1
	uint16_t pci_gen, pci_ctrl2;
d1355 1
a1355 1
		regval |= IXGBE_DCA_TXCTRL_TX_WB_RO_EN;
d1362 2
a1363 2
		regval |= (IXGBE_DCA_RXCTRL_DESC_WRO_EN |
			   IXGBE_DCA_RXCTRL_DESC_HSRO_EN);
@


1.9
log
@ixgbe_phy_aq is an x540 so kill stale references in the 82598 module
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82598.c,v 1.8 2012/12/05 14:41:28 mikeb Exp $	*/
a708 5
	/* if link is down, zero out the current_mode */
	if (*link_up == FALSE) {
		hw->fc.current_mode = ixgbe_fc_none;
		hw->fc.fc_was_autonegged = FALSE;
	}
d1204 8
a1211 2
		else /* XAUI */
			physical_layer = IXGBE_PHYSICAL_LAYER_UNKNOWN;
@


1.8
log
@minor cleanup, whitespaces, mostly synced with freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82598.c,v 1.7 2012/07/29 13:49:03 mikeb Exp $	*/
a235 4
	case ixgbe_phy_aq:
		phy->ops.get_firmware_version =
			     &ixgbe_get_phy_firmware_version_generic;
		break;
a375 1
	case ixgbe_phy_aq:
a1181 1
	case ixgbe_phy_aq:
@


1.7
log
@whitespace cleanup, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82598.c,v 1.6 2011/06/10 12:46:35 claudio Exp $	*/
d896 2
d901 1
a901 3
	 * for any pending HW events to complete.  We use 1usec since that is
	 * what is needed for ixgbe_disable_pcie_master().  The second reset
	 * then clears out any effects of those events.
a904 1
		usec_delay(1);
a906 2

	msec_delay(50);
@


1.6
log
@Monster update of ix(4). This brings ix(4) close to what is currently
in FreeBSD. This seems to fix a lot of problems on 82599 based cards
including the VLAN problems and the corrupted receives.
Putting this in now to work on it in tree since a few additional things
need to be merged. Tested by myself, deraadt@@ and jsg@@ on both 98er and
99er cards.
OK jsg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82598.c,v 1.5 2010/02/19 18:55:12 jsg Exp $	*/
d5 1
a5 1
  Copyright (c) 2001-2009, Intel Corporation 
d7 2
a8 2
  
  Redistribution and use in source and binary forms, with or without 
d10 2
a11 2
  
   1. Redistributions of source code must retain the above copyright notice, 
d13 3
a15 3
  
   2. Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
d17 3
a19 3
  
   3. Neither the name of the Intel Corporation nor the names of its 
      contributors may be used to endorse or promote products derived from 
d21 1
a21 1
  
d23 8
a30 8
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
d43 2
a44 2
                                      ixgbe_link_speed *speed,
                                      int *autoneg);
d48 1
a48 1
                               int autoneg_wait_to_complete);
d51 2
a52 2
                               ixgbe_link_speed *speed,
                               int *link_up, int link_up_wait_to_complete);
d54 3
a56 3
                                     ixgbe_link_speed speed,
                                     int autoneg,
                                     int autoneg_wait_to_complete);
d58 3
a60 3
                                        ixgbe_link_speed speed,
                                        int autoneg,
                                        int autoneg_wait_to_complete);
d67 1
a67 1
                         uint32_t vind, int vlan_on);
d72 1
a72 1
                                uint8_t *eeprom_data);
d133 1
a133 1
		                                  IXGBE_PCIE_MSIX_82598_CAPS);
d168 1
a168 1
	                            &ixgbe_get_supported_physical_layer_82598;
d198 1
a198 1
	                       &ixgbe_get_link_capabilities_82598;
d226 1
a226 1
		                  &ixgbe_get_copper_link_capabilities_generic;
d234 1
a234 1
		             &ixgbe_get_phy_firmware_version_tnx;
d238 1
a238 1
		             &ixgbe_get_phy_firmware_version_generic;
d254 2
a255 2
		                                            &list_offset,
		                                            &data_offset);
d296 1
a296 1
		            IXGBE_DCA_RXCTRL_DESC_HSRO_EN);
d316 2
a317 2
                                      ixgbe_link_speed *speed,
                                      int *autoneg)
d558 1
a558 1
	                               int autoneg_wait_to_complete)
d614 1
a614 1
		                     IXGBE_MDIO_AUTO_NEG_DEV_TYPE, &an_reg);
d641 1
a641 1
                               int *link_up, int link_up_wait_to_complete)
d657 1
a657 1
		                     &adapt_comp_reg);
d669 2
a670 2
				                     IXGBE_TWINAX_DEV,
				                     &link_reg);
d672 2
a673 2
				                     IXGBE_TWINAX_DEV,
				                     &adapt_comp_reg);
d733 2
a734 2
                                     ixgbe_link_speed speed, int autoneg,
                                     int autoneg_wait_to_complete)
d751 1
a751 1
	         link_mode == IXGBE_AUTOC_LMS_KX4_AN_1G_AN) {
d768 1
a768 1
		                                    autoneg_wait_to_complete);
d785 3
a787 3
                                        ixgbe_link_speed speed,
                                        int autoneg,
                                        int autoneg_wait_to_complete)
d793 1
a793 1
	                                      autoneg_wait_to_complete);
d830 1
a830 1
		                             &analog_val);
d833 1
a833 1
		                              analog_val);
d836 1
a836 1
		                             &analog_val);
d839 1
a839 1
		                              analog_val);
d842 1
a842 1
		                             &analog_val);
d845 1
a845 1
		                              analog_val);
d848 1
a848 1
		                             &analog_val);
d851 1
a851 1
		                              analog_val);
d1006 1
a1006 1
	                                              int vlan_on)
d1061 1
a1061 1
			                0);
d1079 1
a1079 1
	                IXGBE_ATLASCTL_WRITE_CMD | (reg << 8));
d1117 1
a1117 1
                                uint8_t *eeprom_data)
d1134 3
a1136 3
		                      IXGBE_MDIO_PMA_PMD_SDA_SCL_ADDR,
		                      IXGBE_MDIO_PMA_PMD_DEV_TYPE,
		                      sfp_addr);
d1141 3
a1143 3
			                     IXGBE_MDIO_PMA_PMD_SDA_SCL_STAT,
			                     IXGBE_MDIO_PMA_PMD_DEV_TYPE,
			                     &sfp_stat);
d1158 1
a1158 1
		                     IXGBE_MDIO_PMA_PMD_DEV_TYPE, &sfp_data);
d1326 1
a1326 1
		           IXGBE_DCA_RXCTRL_DESC_HSRO_EN);
@


1.5
log
@Partial sync to the latest version of ixgbe in FreeBSD leaving things
like if_ix.c mostly untouched for now.  This brings in support for
newer 82598 parts and adds several things that will be needed for 82599.

Initially from claudio with some additions by me.

Tested by claudio, dlg (earlier version) and myself on different cards
and media types.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82598.c,v 1.4 2009/06/07 13:24:57 jsg Exp $	*/
d49 1
d63 1
a76 1
int32_t ixgbe_validate_link_ready(struct ixgbe_hw *hw);
d164 1
d185 1
d196 1
d286 1
a286 1
		     (i < IXGBE_DCA_MAX_QUEUES_82598)); i++) {
d293 1
a293 1
		     (i < IXGBE_DCA_MAX_QUEUES_82598)); i++) {
d296 1
a296 1
			    IXGBE_DCA_RXCTRL_DESC_HSRO_EN);
d377 4
a380 3
	if (hw->phy.type == ixgbe_phy_cu_unknown ||
	    hw->phy.type == ixgbe_phy_tn ||
	    hw->phy.type == ixgbe_phy_aq) {
d383 2
d431 1
d436 3
a438 2
	 * On 82598 backplane having FC on causes resets while doing
	 * KX, so turn off here.
d441 12
a452 5
	if (link_up &&
	    link_speed == IXGBE_LINK_SPEED_1GB_FULL &&
	    hw->mac.ops.get_media_type(hw) == ixgbe_media_type_backplane) {
		hw->fc.disable_fc_autoneg = TRUE;
		hw->fc.requested_mode = ixgbe_fc_none;
d457 1
a457 1
	if (ret_val)
d479 2
a480 1
		/* Flow control is disabled by software override or autoneg.
d521 11
a531 7
		if (hw->fc.send_xon) {
			IXGBE_WRITE_REG(hw, IXGBE_FCRTL(packetbuf_num),
			                (hw->fc.low_water | IXGBE_FCRTL_XONE));
		} else {
			IXGBE_WRITE_REG(hw, IXGBE_FCRTL(packetbuf_num),
			                hw->fc.low_water);
		}
d533 1
a533 2
		IXGBE_WRITE_REG(hw, IXGBE_FCRTH(packetbuf_num),
		                (hw->fc.high_water | IXGBE_FCRTH_FCEN));
d597 35
d676 1
a676 2
			if ((link_reg & 1) &&
			    ((adapt_comp_reg & 1) == 0))
d711 1
a711 1
	     (ixgbe_validate_link_ready(hw) != IXGBE_SUCCESS))
a718 1

d774 1
d873 1
a873 5
	status = ixgbe_disable_pcie_master(hw);
	if (status != IXGBE_SUCCESS) {
		status = IXGBE_ERR_MASTER_REQUESTS_PENDING;
		DEBUGOUT("PCI-E Master disable polling has failed.\n");
	}
d875 1
d896 13
d924 1
a924 1
	} else if (autoc != hw->mac.orig_autoc)
d926 1
a936 2


d940 1
d953 7
d981 2
a982 7
	if (rar < rar_entries) {
		rar_high = IXGBE_READ_REG(hw, IXGBE_RAH(rar));
		if (rar_high & IXGBE_RAH_VIND_MASK) {
			rar_high &= ~IXGBE_RAH_VIND_MASK;
			IXGBE_WRITE_REG(hw, IXGBE_RAH(rar), rar_high);
		}
	} else {
d984 7
d1188 4
a1191 2
	if (hw->phy.type == ixgbe_phy_tn ||
	    hw->phy.type == ixgbe_phy_cu_unknown) {
d1201 2
d1303 1
a1303 1
 *  ixgbe_validate_link_ready - Function looks for phy link
a1305 2
 *  Function indicates success when phy link is available. If phy is not ready
 *  within 5 seconds of MAC indicating link, the function returns error.
d1307 1
a1307 1
int32_t ixgbe_validate_link_ready(struct ixgbe_hw *hw)
d1309 2
a1310 2
	uint32_t timeout;
	uint16_t an_reg;
d1312 1
a1312 2
	if (hw->device_id != IXGBE_DEV_ID_82598AT2)
		return IXGBE_SUCCESS;
d1314 6
a1319 10
	for (timeout = 0;
	     timeout < IXGBE_VALIDATE_LINK_READY_TIMEOUT; timeout++) {
		hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_STATUS,
		                     IXGBE_MDIO_AUTO_NEG_DEV_TYPE, &an_reg);

		if ((an_reg & IXGBE_MII_AUTONEG_COMPLETE) &&
		    (an_reg & IXGBE_MII_AUTONEG_LINK_UP))
			break;

		msec_delay(100);
d1322 6
a1327 3
	if (timeout == IXGBE_VALIDATE_LINK_READY_TIMEOUT) {
		DEBUGOUT("Link was indicated but link is down\n");
		return IXGBE_ERR_LINK_SETUP;
a1329 1
	return IXGBE_SUCCESS;
@


1.4
log
@don't prefix the usage of a define that has a - with a -
no binary change and consistent with other usage of the macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82598.c,v 1.3 2008/06/08 21:15:34 reyk Exp $	*/
d5 1
a5 1
  Copyright (c) 2001-2008, Intel Corporation 
d35 1
a35 1
/*$FreeBSD: src/sys/dev/ixgbe/ixgbe_82598.c,v 1.4 2008/05/16 18:46:30 jfv Exp $*/
d40 1
a44 3
int32_t ixgbe_get_copper_link_capabilities_82598(struct ixgbe_hw *hw,
                                             ixgbe_link_speed *speed,
                                             int *autoneg);
d46 3
a48 2
int32_t ixgbe_setup_fc_82598(struct ixgbe_hw *hw, int32_t packetbuf_num);
int32_t ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw);
d52 1
a52 1
int32_t ixgbe_setup_mac_link_speed_82598(struct ixgbe_hw *hw,
d56 1
a56 2
int32_t ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw);
int32_t ixgbe_setup_copper_link_speed_82598(struct ixgbe_hw *hw,
a59 3
#ifndef NO_82598_A0_SUPPORT
int32_t ixgbe_reset_hw_rev_0_82598(struct ixgbe_hw *hw);
#endif
d61 1
a61 2
int32_t ixgbe_configure_fiber_serdes_fc_82598(struct ixgbe_hw *hw);
int32_t ixgbe_setup_fiber_serdes_link_82598(struct ixgbe_hw *hw);
d63 78
a140 2
int32_t ixgbe_blink_led_stop_82598(struct ixgbe_hw *hw, uint32_t index);
int32_t ixgbe_blink_led_start_82598(struct ixgbe_hw *hw, uint32_t index);
d158 3
d162 1
a162 6
#ifndef NO_82598_A0_SUPPORT
	if (hw->revision_id == 0)
		mac->ops.reset_hw = &ixgbe_reset_hw_rev_0_82598;
	else
		mac->ops.reset_hw = &ixgbe_reset_hw_82598;
#else
a163 1
#endif
d165 5
a169 4

	/* LEDs */
	mac->ops.blink_led_start = &ixgbe_blink_led_start_82598;
	mac->ops.blink_led_stop = &ixgbe_blink_led_stop_82598;
d173 3
d178 1
a178 1
	mac->ops.setup_fc = &ixgbe_setup_fc_82598;
d180 36
a215 1
	/* Call PHY identify routine to get the phy type */
d218 7
a224 1
	/* PHY Init */
d227 1
d232 4
d238 18
d261 18
a278 14
	/* Link */
	mac->ops.check_link = &ixgbe_check_mac_link_82598;
	if (mac->ops.get_media_type(hw) == ixgbe_media_type_copper) {
		mac->ops.setup_link = &ixgbe_setup_copper_link_82598;
		mac->ops.setup_link_speed =
		                     &ixgbe_setup_copper_link_speed_82598;
		mac->ops.get_link_capabilities =
		                     &ixgbe_get_copper_link_capabilities_82598;
	} else {
		mac->ops.setup_link = &ixgbe_setup_mac_link_82598;
		mac->ops.setup_link_speed = &ixgbe_setup_mac_link_speed_82598;
		mac->ops.get_link_capabilities =
		                       &ixgbe_get_link_capabilities_82598;
	}
d280 19
a298 5
	mac->mcft_size       = 128;
	mac->vft_size        = 128;
	mac->num_rar_entries = 16;
	mac->max_tx_queues   = 32;
	mac->max_rx_queues   = 64;
d300 1
a300 1
	return IXGBE_SUCCESS;
d307 1
a307 1
 *  @@autoneg: intean auto-negotiation value
d316 1
a316 1
	int32_t autoc_reg;
d318 9
a326 8
	autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);

	if (hw->mac.link_settings_loaded) {
		autoc_reg &= ~IXGBE_AUTOC_LMS_ATTACH_TYPE;
		autoc_reg &= ~IXGBE_AUTOC_LMS_MASK;
		autoc_reg |= hw->mac.link_attach_type;
		autoc_reg |= hw->mac.link_mode_select;
	}
d328 1
a328 1
	switch (autoc_reg & IXGBE_AUTOC_LMS_MASK) {
d347 1
a347 1
		if (autoc_reg & IXGBE_AUTOC_KX4_SUPP)
d349 1
a349 1
		if (autoc_reg & IXGBE_AUTOC_KX_SUPP)
a362 32
 *  ixgbe_get_copper_link_capabilities_82598 - Determines link capabilities
 *  @@hw: pointer to hardware structure
 *  @@speed: pointer to link speed
 *  @@autoneg: intean auto-negotiation value
 *
 *  Determines the link capabilities by reading the AUTOC register.
 **/
int32_t ixgbe_get_copper_link_capabilities_82598(struct ixgbe_hw *hw,
                                             ixgbe_link_speed *speed,
                                             int *autoneg)
{
	int32_t status = IXGBE_ERR_LINK_SETUP;
	uint16_t speed_ability;

	*speed = 0;
	*autoneg = TRUE;

	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_PHY_SPEED_ABILITY,
	                            IXGBE_MDIO_PMA_PMD_DEV_TYPE,
	                            &speed_ability);

	if (status == IXGBE_SUCCESS) {
		if (speed_ability & IXGBE_MDIO_PHY_SPEED_10G)
			*speed |= IXGBE_LINK_SPEED_10GB_FULL;
		if (speed_ability & IXGBE_MDIO_PHY_SPEED_1G)
			*speed |= IXGBE_LINK_SPEED_1GB_FULL;
	}

	return status;
}

/**
d372 8
d382 5
a388 2
	case IXGBE_DEV_ID_82598EB_CX4:
	case IXGBE_DEV_ID_82598_CX4_DUAL_PORT:
d392 1
d395 4
d400 1
a400 3
		media_type = ixgbe_media_type_copper;
		break;
	case IXGBE_DEV_ID_82598AT_DUAL_PORT:
d407 1
a407 1

d412 1
a412 1
 *  ixgbe_setup_fc_82598 - Configure flow control settings
d416 1
a416 2
 *  Configures the flow control settings based on SW configuration.  This
 *  function is used for 802.3x flow control configuration only.
d418 1
a418 1
int32_t ixgbe_setup_fc_82598(struct ixgbe_hw *hw, int32_t packetbuf_num)
d420 2
a421 1
	uint32_t frctl_reg;
d423 3
d427 10
a436 4
	if (packetbuf_num < 0 || packetbuf_num > 7) {
		DEBUGOUT1("Invalid packet buffer number [%d], expected range is"
		          " 0-7\n", packetbuf_num);
		panic("ixgbe");
d439 8
a446 2
	frctl_reg = IXGBE_READ_REG(hw, IXGBE_FCTRL);
	frctl_reg &= ~(IXGBE_FCTRL_RFCE | IXGBE_FCTRL_RPFCE);
d452 1
a452 15
	 * 10 gig parts do not have a word in the EEPROM to determine the
	 * default flow control setting, so we explicitly set it to full.
	 */
	if (hw->fc.type == ixgbe_fc_default)
		hw->fc.type = ixgbe_fc_full;

	/*
	 * We want to save off the original Flow Control configuration just in
	 * case we get disconnected and then reconnected into a different hub
	 * or switch with different Flow Control capabilities.
	 */
	hw->fc.original_type = hw->fc.type;

	/*
	 * The possible values of the "flow_control" parameter are:
d454 4
a457 4
	 * 1: Rx flow control is enabled (we can receive pause frames but not
	 *    send pause frames).
	 * 2: Tx flow control is enabled (we can send pause frames but we do not
	 *    support receiving pause frames)
d461 1
a461 1
	switch (hw->fc.type) {
d463 3
d469 6
a474 2
		 * Rx Flow control is enabled,
		 * and Tx Flow control is disabled.
d476 1
a476 1
		frctl_reg |= IXGBE_FCTRL_RFCE;
d480 2
a481 2
		 * Tx Flow control is enabled, and Rx Flow control is disabled,
		 * by a software over-ride.
d486 2
a487 5
		/*
		 * Flow control (both Rx and Tx) is enabled by a software
		 * over-ride.
		 */
		frctl_reg |= IXGBE_FCTRL_RFCE;
a490 1
		/* We should never get here.  The value should be 0-3. */
d492 2
a493 1
		panic("ixgbe");
d497 3
a499 2
	/* Enable 802.3x based flow control settings. */
	IXGBE_WRITE_REG(hw, IXGBE_FCTRL, frctl_reg);
d502 2
a503 16
	/*
	 * Check for invalid software configuration, zeros are completely
	 * invalid for all parameters used past this point, and if we enable
	 * flow control with zero water marks, we blast flow control packets.
	 */
	if (!hw->fc.low_water || !hw->fc.high_water || !hw->fc.pause_time) {
		DEBUGOUT("Flow control structure initialized incorrectly\n");
		return IXGBE_ERR_INVALID_LINK_SETTINGS;
	}

	/*
	 * We need to set up the Receive Threshold high and low water
	 * marks as well as (optionally) enabling the transmission of
	 * XON frames.
	 */
	if (hw->fc.type & ixgbe_fc_tx_pause) {
d511 1
d513 1
a513 1
		                (hw->fc.high_water)|IXGBE_FCRTH_FCEN);
d516 8
a523 1
	IXGBE_WRITE_REG(hw, IXGBE_FCTTV(0), hw->fc.pause_time);
d526 2
a527 1
	return IXGBE_SUCCESS;
d531 1
a531 1
 *  ixgbe_setup_mac_link_82598 - Configures MAC link settings
d537 2
a538 1
int32_t ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw)
a539 2
	ixgbe_link_speed speed;
	int link_up;
d545 1
a546 13

	if (hw->mac.link_settings_loaded) {
		autoc_reg &= ~IXGBE_AUTOC_LMS_ATTACH_TYPE;
		autoc_reg &= ~IXGBE_AUTOC_LMS_MASK;
		autoc_reg |= hw->mac.link_attach_type;
		autoc_reg |= hw->mac.link_mode_select;

		IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc_reg);
		IXGBE_WRITE_FLUSH(hw);
		msec_delay(50);
	}

	/* Restart link */
d551 5
a555 3
	if (hw->phy.autoneg_wait_to_complete) {
		if (hw->mac.link_mode_select == IXGBE_AUTOC_LMS_KX4_AN ||
		    hw->mac.link_mode_select == IXGBE_AUTOC_LMS_KX4_AN_1G_AN) {
a569 16
	/*
	 * We want to save off the original Flow Control configuration just in
	 * case we get disconnected and then reconnected into a different hub
	 * or switch with different Flow Control capabilities.
	 */
	hw->fc.original_type = hw->fc.type;
	/*
	 * Set up the SerDes link if in 1Gb mode, otherwise just set up
	 * 10Gb flow control.
	 */
	hw->mac.ops.check_link(hw, &speed, &link_up, FALSE);
	if (speed == IXGBE_LINK_SPEED_1GB_FULL)
		status = ixgbe_setup_fiber_serdes_link_82598(hw);
	else
		ixgbe_setup_fc_82598(hw, 0);

d581 1
a581 1
 *  @@link_up_wait_to_complete: int used to wait for link up or not
d592 6
d599 2
a600 2
		hw->phy.ops.read_reg(hw, 1, IXGBE_TWINAX_DEV, &link_reg);
		hw->phy.ops.read_reg(hw, 1, IXGBE_TWINAX_DEV, &link_reg);
d605 1
a605 1
				if ((link_reg & (1 << 2)) &&
d613 2
a614 1
				hw->phy.ops.read_reg(hw, 1, IXGBE_TWINAX_DEV,
d621 1
a621 1
			if ((link_reg & (1 << 2)) &&
d656 8
a663 90
out:
	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_configure_fiber_serdes_fc_82598 - Configure fiber flow control
 *  @@hw: pointer to hardware structure
 *
 *  Reads PCS registers and sets flow control settings, based on
 *  link-partner's abilities.
 **/
int32_t ixgbe_configure_fiber_serdes_fc_82598(struct ixgbe_hw *hw)
{
	int32_t ret_val = IXGBE_SUCCESS;
	uint32_t pcs_anadv_reg, pcs_lpab_reg, pcs_lstat_reg, i;
	DEBUGFUNC("ixgbe_configure_fiber_serdes_fc_82598");

	/* Check that autonegotiation has completed */
	for (i = 0; i < FIBER_LINK_UP_LIMIT; i++) {
		msec_delay(10);
		pcs_lstat_reg = IXGBE_READ_REG(hw, IXGBE_PCS1GLSTA);
		if (pcs_lstat_reg & IXGBE_PCS1GLSTA_LINK_OK) {
			if (pcs_lstat_reg & IXGBE_PCS1GLSTA_AN_COMPLETE) {
				if (!(pcs_lstat_reg &
				    (IXGBE_PCS1GLSTA_AN_TIMED_OUT)))
					hw->mac.autoneg_failed = 0;
				else
					hw->mac.autoneg_failed = 1;
				break;
			} else {
				hw->mac.autoneg_failed = 1;
				break;
			}
		}
	}

	if (hw->mac.autoneg_failed) {
		/*
		 * AutoNeg failed to achieve a link, so we will turn
		 * flow control off.
		 */
		hw->fc.type = ixgbe_fc_none;
		DEBUGOUT("Flow Control = NONE.\n");
		ret_val = ixgbe_setup_fc_82598(hw, 0);
		goto out;
	}

	/*
	 * Read the AN advertisement and LP ability registers and resolve
	 * local flow control settings accordingly
	 */
	pcs_anadv_reg = IXGBE_READ_REG(hw, IXGBE_PCS1GANA);
	pcs_lpab_reg = IXGBE_READ_REG(hw, IXGBE_PCS1GANLP);
	if ((pcs_anadv_reg & IXGBE_PCS1GANA_SYM_PAUSE) &&
		(pcs_lpab_reg & IXGBE_PCS1GANA_SYM_PAUSE)) {
		/*
		 * Now we need to check if the user selected Rx ONLY
		 * of pause frames.  In this case, we had to advertise
		 * FULL flow control because we could not advertise RX
		 * ONLY. Hence, we must now check to see if we need to
		 * turn OFF  the TRANSMISSION of PAUSE frames.
		 */
		if (hw->fc.original_type == ixgbe_fc_full) {
			hw->fc.type = ixgbe_fc_full;
			DEBUGOUT("Flow Control = FULL.\n");
		} else {
			hw->fc.type = ixgbe_fc_rx_pause;
			DEBUGOUT("Flow Control = RX PAUSE frames only.\n");
		}
	} else if (!(pcs_anadv_reg & IXGBE_PCS1GANA_SYM_PAUSE) &&
		   (pcs_anadv_reg & IXGBE_PCS1GANA_ASM_PAUSE) &&
		   (pcs_lpab_reg & IXGBE_PCS1GANA_SYM_PAUSE) &&
		   (pcs_lpab_reg & IXGBE_PCS1GANA_ASM_PAUSE)) {
		hw->fc.type = ixgbe_fc_tx_pause;
		DEBUGOUT("Flow Control = TX PAUSE frames only.\n");
	} else if ((pcs_anadv_reg & IXGBE_PCS1GANA_SYM_PAUSE) &&
		   (pcs_anadv_reg & IXGBE_PCS1GANA_ASM_PAUSE) &&
		   !(pcs_lpab_reg & IXGBE_PCS1GANA_SYM_PAUSE) &&
		   (pcs_lpab_reg & IXGBE_PCS1GANA_ASM_PAUSE)) {
		hw->fc.type = ixgbe_fc_rx_pause;
		DEBUGOUT("Flow Control = RX PAUSE frames only.\n");
	} else {
		hw->fc.type = ixgbe_fc_none;
		DEBUGOUT("Flow Control = NONE.\n");
	}

	ret_val = ixgbe_setup_fc_82598(hw, 0);
	if (ret_val) {
		DEBUGOUT("Error forcing flow control settings\n");
		goto out;
a666 98
	return ret_val;
}

/**
 *  ixgbe_setup_fiber_serdes_link_82598 - Configure fiber serdes link
 *  @@hw: pointer to hardware structure
 *
 *  Sets up PCS registers and sets flow control settings, based on
 *  link-partner's abilities.
 **/
int32_t ixgbe_setup_fiber_serdes_link_82598(struct ixgbe_hw *hw)
{
	uint32_t reg;
	int32_t ret_val;

	DEBUGFUNC("ixgbe_setup_fiber_serdes_link_82598");

	/*
	 * 10 gig parts do not have a word in the EEPROM to determine the
	 * default flow control setting, so we explicitly set it to full.
	 */
	if (hw->fc.type == ixgbe_fc_default)
		hw->fc.type = ixgbe_fc_full;

	/*
	 * 82598 fiber/serdes devices require that flow control be resolved in
	 * software.
	 */
	reg = IXGBE_READ_REG(hw, IXGBE_PCS1GANA);

	/*
	 * The possible values of the "fc" parameter are:
	 * 0:  Flow control is completely disabled
	 * 1:  Rx flow control is enabled (we can receive pause frames,
	 *     but not send pause frames).
	 * 2:  Tx flow control is enabled (we can send pause frames but
	 *     we do not support receiving pause frames).
	 * 3:  Both Rx and Tx flow control (symmetric) are enabled.
	 */
	switch (hw->fc.type) {
	case ixgbe_fc_none:
		/*
		 * Flow control completely disabled by a software
		 * over-ride.
		 */
		reg &= ~(IXGBE_PCS1GANA_SYM_PAUSE | IXGBE_PCS1GANA_ASM_PAUSE);
		break;
		case ixgbe_fc_rx_pause:
		/*
		 * Rx Flow control is enabled and Tx Flow control is
		 * disabled by a software over-ride. Since there really
		 * isn't a way to advertise that we are capable of RX
		 * Pause ONLY, we will advertise that we support both
		 * symmetric and asymmetric Rx PAUSE.  Later, we will
		 * disable the adapter's ability to send PAUSE frames.
		 */
		reg |= (IXGBE_PCS1GANA_SYM_PAUSE | IXGBE_PCS1GANA_ASM_PAUSE);
		break;
	case ixgbe_fc_tx_pause:
		/*
		 * Tx Flow control is enabled, and Rx Flow control is
		 * disabled, by a software over-ride.
		 */
		reg |= (IXGBE_PCS1GANA_ASM_PAUSE);
		reg &= ~(IXGBE_PCS1GANA_SYM_PAUSE);
		break;
	case ixgbe_fc_full:
		/*
		 * Flow control (both Rx and Tx) is enabled by a
		 * software over-ride.
		 */
		reg |= (IXGBE_PCS1GANA_SYM_PAUSE | IXGBE_PCS1GANA_ASM_PAUSE);
		break;
	default:
		DEBUGOUT("Flow control param set incorrectly\n");
		ret_val = IXGBE_ERR_CONFIG;
		goto out;
		break;
	}

	IXGBE_WRITE_REG(hw, IXGBE_PCS1GANA, reg);
	reg = IXGBE_READ_REG(hw, IXGBE_PCS1GLCTL);

	/* Set PCS register for autoneg */
	/* Enable and restart autoneg */
	reg |= IXGBE_PCS1GLCTL_AN_ENABLE | IXGBE_PCS1GLCTL_AN_RESTART;

	reg &= ~IXGBE_PCS1GLCTL_AN_1G_TIMEOUT_EN; /* Disable AN timeout */
	DEBUGOUT1("Configuring Autoneg; PCS_LCTL = 0x%08X\n", reg);
	IXGBE_WRITE_REG(hw, IXGBE_PCS1GLCTL, reg);

	/*
	 * Configure flow control. If we aren't auto-negotiating,
	 * just setup the flow control and do not worry about PCS autoneg.
	 */
	ixgbe_configure_fiber_serdes_fc_82598(hw);

out:
d671 1
a671 1
 *  ixgbe_setup_mac_link_speed_82598 - Set MAC link speed
d674 2
a675 2
 *  @@autoneg: TRUE if auto-negotiation enabled
 *  @@autoneg_wait_to_complete: TRUE if waiting is needed to complete
d679 1
a679 1
int32_t ixgbe_setup_mac_link_speed_82598(struct ixgbe_hw *hw,
d683 9
a691 1
	int32_t status = IXGBE_SUCCESS;
d693 1
a693 13
	/* If speed is 10G, then check for CX4 or XAUI. */
	if ((speed == IXGBE_LINK_SPEED_10GB_FULL) &&
	    (!(hw->mac.link_attach_type & IXGBE_AUTOC_10G_KX4))) {
		hw->mac.link_mode_select = IXGBE_AUTOC_LMS_10G_LINK_NO_AN;
	} else if ((speed == IXGBE_LINK_SPEED_1GB_FULL) && (!autoneg)) {
		hw->mac.link_mode_select = IXGBE_AUTOC_LMS_1G_LINK_NO_AN;
	} else if (autoneg) {
		/* BX mode - Autonegotiate 1G */
		if (!(hw->mac.link_attach_type & IXGBE_AUTOC_1G_PMA_PMD))
			hw->mac.link_mode_select = IXGBE_AUTOC_LMS_1G_AN;
		else /* KX/KX4 mode */
			hw->mac.link_mode_select = IXGBE_AUTOC_LMS_KX4_AN_1G_AN;
	} else {
d695 11
a708 3
		hw->phy.autoneg_wait_to_complete = autoneg_wait_to_complete;

		hw->mac.link_settings_loaded = TRUE;
d714 2
a715 1
		ixgbe_setup_mac_link_82598(hw);
a720 27

/**
 *  ixgbe_setup_copper_link_82598 - Setup copper link settings
 *  @@hw: pointer to hardware structure
 *
 *  Configures link settings based on values in the ixgbe_hw struct.
 *  Restarts the link.  Performs autonegotiation if needed.  Restart
 *  phy and wait for autonegotiate to finish.  Then synchronize the
 *  MAC and PHY.
 **/
int32_t ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw)
{
	int32_t status;

	/* Restart autonegotiation on PHY */
	status = hw->phy.ops.setup_link(hw);

	/* Set MAC to KX/KX4 autoneg, which defaults to Parallel detection */
	hw->mac.link_attach_type = (IXGBE_AUTOC_10G_KX4 | IXGBE_AUTOC_1G_KX);
	hw->mac.link_mode_select = IXGBE_AUTOC_LMS_KX4_AN;

	/* Set up MAC */
	ixgbe_setup_mac_link_82598(hw);

	return status;
}

d722 1
a722 1
 *  ixgbe_setup_copper_link_speed_82598 - Set the PHY autoneg advertised field
d730 1
a730 1
int32_t ixgbe_setup_copper_link_speed_82598(struct ixgbe_hw *hw,
d739 1
a739 6
	                                    autoneg_wait_to_complete);

	/* Set MAC to KX/KX4 autoneg, which defaults to Parallel detection */
	hw->mac.link_attach_type = (IXGBE_AUTOC_10G_KX4 | IXGBE_AUTOC_1G_KX);
	hw->mac.link_mode_select = IXGBE_AUTOC_LMS_KX4_AN;

d741 1
a741 93
	ixgbe_setup_mac_link_82598(hw);

	return status;
}

#ifndef NO_82598_A0_SUPPORT
/**
 *  ixgbe_reset_hw_rev_0_82598 - Performs hardware reset
 *  @@hw: pointer to hardware structure
 *
 *  Resets the hardware by resetting the transmit and receive units, masks and
 *  clears all interrupts, performing a PHY reset, and performing a link (MAC)
 *  reset.
 **/
int32_t ixgbe_reset_hw_rev_0_82598(struct ixgbe_hw *hw)
{
	int32_t status = IXGBE_SUCCESS;
	uint32_t ctrl;
	uint32_t gheccr;
	uint32_t autoc;
	uint32_t i;
	uint32_t resets;

	/* Call adapter stop to disable tx/rx and clear interrupts */
	hw->mac.ops.stop_adapter(hw);

	/* Reset PHY */
	hw->phy.ops.reset(hw);

	for (resets = 0; resets < 10; resets++) {
		/*
		 * Prevent the PCI-E bus from from hanging by disabling PCI-E
		 * master access and verify no pending requests before reset
		 */
		if (ixgbe_disable_pcie_master(hw) != IXGBE_SUCCESS) {
			status = IXGBE_ERR_MASTER_REQUESTS_PENDING;
			DEBUGOUT("PCI-E Master disable polling has failed.\n");
		}

		/*
		 * Issue global reset to the MAC.  This needs to be a SW reset.
		 * If link reset is used, it might reset the MAC when mng is
		 * using it.
		 */
		ctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);
		IXGBE_WRITE_REG(hw, IXGBE_CTRL, (ctrl | IXGBE_CTRL_RST));
		IXGBE_WRITE_FLUSH(hw);

		/*
		 * Poll for reset bit to self-clear indicating reset is
		 * complete
		 */
		for (i = 0; i < 10; i++) {
			usec_delay(1);
			ctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);
			if (!(ctrl & IXGBE_CTRL_RST))
				break;
		}
		if (ctrl & IXGBE_CTRL_RST) {
			status = IXGBE_ERR_RESET_FAILED;
			DEBUGOUT("Reset polling failed to complete.\n");
		}
	}

	msec_delay(50);

	gheccr = IXGBE_READ_REG(hw, IXGBE_GHECCR);
	gheccr &= ~((1 << 21) | (1 << 18) | (1 << 9) | (1 << 6));
	IXGBE_WRITE_REG(hw, IXGBE_GHECCR, gheccr);

	/*
	 * AUTOC register which stores link settings gets cleared
	 * and reloaded from EEPROM after reset. We need to restore
	 * our stored value from init in case SW changed the attach
	 * type or speed.  If this is the first time and link settings
	 * have not been stored, store default settings from AUTOC.
	 */
	autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);
	if (hw->mac.link_settings_loaded) {
		autoc &= ~(IXGBE_AUTOC_LMS_ATTACH_TYPE);
		autoc &= ~(IXGBE_AUTOC_LMS_MASK);
		autoc |= hw->mac.link_attach_type;
		autoc |= hw->mac.link_mode_select;
		IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc);
	} else {
		hw->mac.link_attach_type =
		                         (autoc & IXGBE_AUTOC_LMS_ATTACH_TYPE);
		hw->mac.link_mode_select = (autoc & IXGBE_AUTOC_LMS_MASK);
		hw->mac.link_settings_loaded = TRUE;
	}

	/* Store the permanent mac address */
	hw->mac.ops.get_mac_addr(hw, hw->mac.perm_addr);
a745 1
#endif /* NO_A0_SUPPORT */
d757 1
d783 1
a783 1
		analog_val &= ~ IXGBE_ATLAS_PDN_TX_10G_QL_ALL;
d801 10
a810 1
	if (hw->phy.reset_disable == FALSE)
d812 1
d814 1
d819 2
a820 1
	if (ixgbe_disable_pcie_master(hw) != IXGBE_SUCCESS) {
d852 3
a854 5
	 * AUTOC register which stores link settings gets cleared
	 * and reloaded from EEPROM after reset. We need to restore
	 * our stored value from init in case SW changed the attach
	 * type or speed.  If this is the first time and link settings
	 * have not been stored, store default settings from AUTOC.
d857 5
a861 12
	if (hw->mac.link_settings_loaded) {
		autoc &= ~(IXGBE_AUTOC_LMS_ATTACH_TYPE);
		autoc &= ~(IXGBE_AUTOC_LMS_MASK);
		autoc |= hw->mac.link_attach_type;
		autoc |= hw->mac.link_mode_select;
		IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc);
	} else {
		hw->mac.link_attach_type =
		                         (autoc & IXGBE_AUTOC_LMS_ATTACH_TYPE);
		hw->mac.link_mode_select = (autoc & IXGBE_AUTOC_LMS_MASK);
		hw->mac.link_settings_loaded = TRUE;
	}
d866 11
d898 75
a972 1
 *  ixgbe_blink_led_start_82598 - Blink LED based on index.
d974 2
a975 1
 *  @@index: led number to blink
d977 1
a977 1
int32_t ixgbe_blink_led_start_82598(struct ixgbe_hw *hw, uint32_t index)
d979 5
a983 4
	ixgbe_link_speed speed = 0;
	int link_up = 0;
	uint32_t autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
	uint32_t led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
d985 29
a1013 5
	/*
	 * Link must be up to auto-blink the LEDs on the 82598EB MAC;
	 * force it if link is down.
	 */
	hw->mac.ops.check_link(hw, &speed, &link_up, FALSE);
d1015 11
a1025 5
	if (!link_up) {
		autoc_reg |= IXGBE_AUTOC_FLU;
		IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc_reg);
		msec_delay(10);
	}
d1027 2
a1028 3
	led_reg &= ~IXGBE_LED_MODE_MASK(index);
	led_reg |= IXGBE_LED_BLINK(index);
	IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
d1030 1
d1036 191
a1226 1
 *  ixgbe_blink_led_stop_82598 - Stop blinking LED based on index.
d1228 3
a1230 1
 *  @@index: led number to stop blinking
d1232 1
a1232 1
int32_t ixgbe_blink_led_stop_82598(struct ixgbe_hw *hw, uint32_t index)
d1234 5
a1238 2
	uint32_t autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
	uint32_t led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
d1240 11
a1250 2
	autoc_reg &= ~IXGBE_AUTOC_FLU;
	IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc_reg);
d1252 4
a1255 4
	led_reg &= ~IXGBE_LED_MODE_MASK(index);
	led_reg &= ~IXGBE_LED_BLINK(index);
	IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
	IXGBE_WRITE_FLUSH(hw);
@


1.3
log
@more cleanup, removed unused code. we don't do LRO/RSS yet, code can
be added later if we ever support it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82598.c,v 1.2 2008/06/08 20:33:51 reyk Exp $	*/
d707 1
a707 1
		ret_val = -IXGBE_ERR_CONFIG;
@


1.2
log
@replace strange Linux-style u8/u16/u32/u64/s32 integer types with the
standard C99 uint*_t/int*_t types (i don't get why these drivers
always use their own types when there is a well-defined standard).
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82598.c,v 1.1 2008/06/08 20:01:02 reyk Exp $	*/
d291 1
a291 1
		ASSERT(0);
d352 1
a352 1
		ASSERT(0);
@


1.1
log
@Import ix, a driver for the Intel 82598 PCI-Express 10 Gig Ethernet Adapter,
based on Intel's ixgbe driver.

Done on borrowed hardware since Intel was too poor to give us a card.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 2
a41 2
s32 ixgbe_init_ops_82598(struct ixgbe_hw *hw);
s32 ixgbe_get_link_capabilities_82598(struct ixgbe_hw *hw,
d43 2
a44 2
                                      bool *autoneg);
s32 ixgbe_get_copper_link_capabilities_82598(struct ixgbe_hw *hw,
d46 1
a46 1
                                             bool *autoneg);
d48 3
a50 3
s32 ixgbe_setup_fc_82598(struct ixgbe_hw *hw, s32 packetbuf_num);
s32 ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw);
s32 ixgbe_check_mac_link_82598(struct ixgbe_hw *hw,
d52 2
a53 2
                               bool *link_up, bool link_up_wait_to_complete);
s32 ixgbe_setup_mac_link_speed_82598(struct ixgbe_hw *hw,
d55 4
a58 4
                                     bool autoneg,
                                     bool autoneg_wait_to_complete);
s32 ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw);
s32 ixgbe_setup_copper_link_speed_82598(struct ixgbe_hw *hw,
d60 2
a61 2
                                        bool autoneg,
                                        bool autoneg_wait_to_complete);
d63 1
a63 1
s32 ixgbe_reset_hw_rev_0_82598(struct ixgbe_hw *hw);
d65 6
a70 6
s32 ixgbe_reset_hw_82598(struct ixgbe_hw *hw);
s32 ixgbe_configure_fiber_serdes_fc_82598(struct ixgbe_hw *hw);
s32 ixgbe_setup_fiber_serdes_link_82598(struct ixgbe_hw *hw);
s32 ixgbe_set_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq);
s32 ixgbe_blink_led_stop_82598(struct ixgbe_hw *hw, u32 index);
s32 ixgbe_blink_led_start_82598(struct ixgbe_hw *hw, u32 index);
d79 1
a79 1
s32 ixgbe_init_ops_82598(struct ixgbe_hw *hw)
d83 1
a83 1
	s32 ret_val;
d154 1
a154 1
 *  @@autoneg: boolean auto-negotiation value
d158 1
a158 1
s32 ixgbe_get_link_capabilities_82598(struct ixgbe_hw *hw,
d160 1
a160 1
                                      bool *autoneg)
d162 2
a163 2
	s32 status = IXGBE_SUCCESS;
	s32 autoc_reg;
d212 1
a212 1
 *  @@autoneg: boolean auto-negotiation value
d216 1
a216 1
s32 ixgbe_get_copper_link_capabilities_82598(struct ixgbe_hw *hw,
d218 1
a218 1
                                             bool *autoneg)
d220 2
a221 2
	s32 status = IXGBE_ERR_LINK_SETUP;
	u16 speed_ability;
d283 1
a283 1
s32 ixgbe_setup_fc_82598(struct ixgbe_hw *hw, s32 packetbuf_num)
d285 2
a286 2
	u32 frctl_reg;
	u32 rmcs_reg;
d400 1
a400 1
s32 ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw)
d403 5
a407 5
	bool link_up;
	u32 autoc_reg;
	u32 links_reg;
	u32 i;
	s32 status = IXGBE_SUCCESS;
d471 1
a471 1
 *  @@link_up_wait_to_complete: bool used to wait for link up or not
d475 2
a476 2
s32 ixgbe_check_mac_link_82598(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
                               bool *link_up, bool link_up_wait_to_complete)
d478 3
a480 3
	u32 links_reg;
	u32 i;
	u16 link_reg, adapt_comp_reg;
d550 1
a550 1
s32 ixgbe_configure_fiber_serdes_fc_82598(struct ixgbe_hw *hw)
d552 2
a553 2
	s32 ret_val = IXGBE_SUCCESS;
	u32 pcs_anadv_reg, pcs_lpab_reg, pcs_lstat_reg, i;
d642 1
a642 1
s32 ixgbe_setup_fiber_serdes_link_82598(struct ixgbe_hw *hw)
d644 2
a645 2
	u32 reg;
	s32 ret_val;
d742 3
a744 3
s32 ixgbe_setup_mac_link_speed_82598(struct ixgbe_hw *hw,
                                     ixgbe_link_speed speed, bool autoneg,
                                     bool autoneg_wait_to_complete)
d746 1
a746 1
	s32 status = IXGBE_SUCCESS;
d789 1
a789 1
s32 ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw)
d791 1
a791 1
	s32 status;
d815 1
a815 1
s32 ixgbe_setup_copper_link_speed_82598(struct ixgbe_hw *hw,
d817 2
a818 2
                                        bool autoneg,
                                        bool autoneg_wait_to_complete)
d820 1
a820 1
	s32 status;
d845 1
a845 1
s32 ixgbe_reset_hw_rev_0_82598(struct ixgbe_hw *hw)
d847 6
a852 6
	s32 status = IXGBE_SUCCESS;
	u32 ctrl;
	u32 gheccr;
	u32 autoc;
	u32 i;
	u32 resets;
d937 1
a937 1
s32 ixgbe_reset_hw_82598(struct ixgbe_hw *hw)
d939 6
a944 6
	s32 status = IXGBE_SUCCESS;
	u32 ctrl;
	u32 gheccr;
	u32 i;
	u32 autoc;
	u8  analog_val;
d1054 1
a1054 1
s32 ixgbe_set_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
d1056 1
a1056 1
	u32 rar_high;
d1070 1
a1070 1
s32 ixgbe_blink_led_start_82598(struct ixgbe_hw *hw, u32 index)
d1073 3
a1075 3
	bool link_up = 0;
	u32 autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
	u32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
d1102 1
a1102 1
s32 ixgbe_blink_led_stop_82598(struct ixgbe_hw *hw, u32 index)
d1104 2
a1105 2
	u32 autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
	u32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
@

