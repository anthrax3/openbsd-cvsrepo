head	1.28;
access;
symbols
	OPENBSD_6_0:1.28.0.14
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.10
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.8
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.16
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.14
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.12
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.10
	OPENBSD_5_0:1.27.0.8
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.6
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.4
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11;
locks; strict;
comment	@ * @;


1.28
date	2013.11.26.20.33.17;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.24.20.17.17;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.24.18.21.05;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2009.05.29.08.25.45;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2009.05.24.18.51.12;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2008.11.25.18.49.49;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2008.11.09.10.00.17;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.08.11.02.09;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.11.18.52.32;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.10.20.53.22;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.10.20.34.43;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2007.07.24.16.07.47;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2007.07.10.18.29.38;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.16.14.15.37;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.09.09.50.00;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.05.19.49.40;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.13.20.06.38;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2006.08.28.19.47.43;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.01.12.43.56;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.17.19.07.19;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.16.18.54.09;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.05.16.42.21;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.25.09.26.58;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.20.15.31.30;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.20.13.24.02;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.20.12.44.47;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.20.11.47.29;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.14.19.00.48;	author damien;	state Exp;
branches;
next	;


desc
@@


1.28
log
@1 << 31 cleanup.  Eitan Adler pointed out that there has been a
resurrection of the bad idiom in the tree.
sufficient review by miod, kettenis, tedu
@
text
@/*	$OpenBSD: if_wpireg.h,v 1.27 2009/10/24 20:17:17 damien Exp $	*/

/*-
 * Copyright (c) 2006-2008
 *	Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#define WPI_TX_RING_COUNT	256
#define WPI_TX_RING_LOMARK	192
#define WPI_TX_RING_HIMARK	224
#define WPI_RX_RING_COUNT_LOG	6
#define WPI_RX_RING_COUNT	(1 << WPI_RX_RING_COUNT_LOG)

#define WPI_NTXQUEUES		8
#define WPI_NDMACHNLS		6

/* Maximum scatter/gather. */
#define WPI_MAX_SCATTER	4

/* Maximum RX buffer size (larger than MCLBYTES.) */
#define WPI_RBUF_SIZE	(3 * 1024)

/* Base Address Register. */
#define WPI_PCI_BAR0	PCI_MAPREG_START

/*
 * Control and status registers.
 */
#define WPI_HW_IF_CONFIG	0x000
#define WPI_INT			0x008
#define WPI_MASK		0x00c
#define WPI_FH_INT		0x010
#define WPI_GPIO_IN		0x018
#define WPI_RESET		0x020
#define WPI_GP_CNTRL		0x024
#define WPI_EEPROM		0x02c
#define WPI_EEPROM_GP		0x030
#define WPI_UCODE_GP1_CLR	0x05c
#define WPI_UCODE_GP2		0x060
#define WPI_GIO_CHICKEN		0x100
#define WPI_ANA_PLL		0x20c
#define WPI_MEM_RADDR		0x40c
#define WPI_MEM_WADDR		0x410
#define WPI_MEM_WDATA		0x418
#define WPI_MEM_RDATA		0x41c
#define WPI_PRPH_WADDR		0x444
#define WPI_PRPH_RADDR		0x448
#define WPI_PRPH_WDATA		0x44c
#define WPI_PRPH_RDATA		0x450
#define WPI_HBUS_TARG_WRPTR	0x460
#define WPI_FH_CBBC_CTRL(qid)	(0x940 + (qid) * 8)
#define WPI_FH_CBBC_BASE(qid)	(0x944 + (qid) * 8)
#define WPI_FH_RX_CONFIG	0xc00
#define WPI_FH_RX_BASE		0xc04
#define WPI_FH_RX_WPTR		0xc20
#define WPI_FH_RX_RPTR_ADDR	0xc24
#define WPI_FH_RSSR_TBL		0xcc0
#define WPI_FH_RX_STATUS	0xcc4
#define WPI_FH_TX_CONFIG(qid)	(0xd00 + (qid) * 32)
#define WPI_FH_TX_BASE		0xe80
#define WPI_FH_MSG_CONFIG	0xe88
#define WPI_FH_TX_STATUS	0xe90


/*
 * NIC internal memory offsets.
 */
#define WPI_ALM_SCHED_MODE		0x2e00
#define WPI_ALM_SCHED_ARASTAT		0x2e04
#define WPI_ALM_SCHED_TXFACT		0x2e10
#define WPI_ALM_SCHED_TXF4MF		0x2e14
#define WPI_ALM_SCHED_TXF5MF		0x2e20
#define WPI_ALM_SCHED_SBYPASS_MODE1	0x2e2c
#define WPI_ALM_SCHED_SBYPASS_MODE2	0x2e30
#define WPI_APMG_CLK_ENA		0x3004
#define WPI_APMG_CLK_DIS		0x3008
#define WPI_APMG_RFKILL			0x3014
#define WPI_APMG_PS			0x300c
#define WPI_APMG_PCI_STT		0x3010
#define WPI_BSM_WR_CTRL			0x3400
#define WPI_BSM_WR_MEM_SRC		0x3404
#define WPI_BSM_WR_MEM_DST		0x3408
#define WPI_BSM_WR_DWCOUNT		0x340c
#define WPI_BSM_SRAM_BASE		0x3800
#define WPI_BSM_DRAM_TEXT_ADDR		0x3490
#define WPI_BSM_DRAM_TEXT_SIZE		0x3494
#define WPI_BSM_DRAM_DATA_ADDR		0x3498
#define WPI_BSM_DRAM_DATA_SIZE		0x349c


/* Possible flags for register WPI_HW_IF_CONFIG. */
#define WPI_HW_IF_CONFIG_ALM_MB		(1 << 8)
#define WPI_HW_IF_CONFIG_ALM_MM		(1 << 9)
#define WPI_HW_IF_CONFIG_SKU_MRC	(1 << 10)
#define WPI_HW_IF_CONFIG_REV_D		(1 << 11)
#define WPI_HW_IF_CONFIG_TYPE_B		(1 << 12)

/* Possible flags for registers WPI_PRPH_RADDR/WPI_PRPH_WADDR. */
#define WPI_PRPH_DWORD	((sizeof (uint32_t) - 1) << 24)

/* Possible values for WPI_BSM_WR_MEM_DST. */
#define WPI_FW_TEXT_BASE	0x00000000
#define WPI_FW_DATA_BASE	0x00800000

/* Possible flags for WPI_GPIO_IN. */
#define WPI_GPIO_IN_VMAIN	(1 << 9)

/* Possible flags for register WPI_RESET. */
#define WPI_RESET_NEVO			(1 << 0)
#define WPI_RESET_SW			(1 << 7)
#define WPI_RESET_MASTER_DISABLED	(1 << 8)
#define WPI_RESET_STOP_MASTER		(1 << 9)

/* Possible flags for register WPI_GP_CNTRL. */
#define WPI_GP_CNTRL_MAC_CLOCK_READY	(1 <<  0)
#define WPI_GP_CNTRL_MAC_ACCESS_ENA	(1 <<  0)
#define WPI_GP_CNTRL_INIT_DONE		(1 <<  2)
#define WPI_GP_CNTRL_MAC_ACCESS_REQ	(1 <<  3)
#define WPI_GP_CNTRL_SLEEP		(1 <<  4)
#define WPI_GP_CNTRL_PS_MASK		(7 << 24)
#define WPI_GP_CNTRL_MAC_PS		(4 << 24)
#define WPI_GP_CNTRL_RFKILL		(1 << 27)

/* Possible flags for register WPI_GIO_CHICKEN. */
#define WPI_GIO_CHICKEN_L1A_NO_L0S_RX	(1 << 23)

/* Possible flags for register WPI_FH_RX_CONFIG. */
#define WPI_FH_RX_CONFIG_DMA_ENA		(1U << 31)
#define WPI_FH_RX_CONFIG_RDRBD_ENA		(1U << 29)
#define WPI_FH_RX_CONFIG_WRSTATUS_ENA		(1U << 27)
#define WPI_FH_RX_CONFIG_MAXFRAG		(1U << 24)
#define WPI_FH_RX_CONFIG_NRBD(x)		((x) << 20)
#define WPI_FH_RX_CONFIG_IRQ_DST_HOST		(1U << 12)
#define WPI_FH_RX_CONFIG_IRQ_RBTH(x)		((x) << 4)

/* Possible flags for register WPI_ANA_PLL. */
#define WPI_ANA_PLL_INIT	(1 << 24)

/* Possible flags for register WPI_UCODE_GP1_CLR. */
#define WPI_UCODE_GP1_RFKILL		(1 << 1)
#define WPI_UCODE_GP1_CMD_BLOCKED	(1 << 2)

/* Possible flags for WPI_FH_RX_STATUS. */
#define	WPI_FH_RX_STATUS_IDLE	(1 << 24)

/* Possible flags for register WPI_BSM_WR_CTRL. */
#define WPI_BSM_WR_CTRL_START_EN	(1U << 30)
#define WPI_BSM_WR_CTRL_START		(1U << 31)

/* Possible flags for register WPI_INT. */
#define WPI_INT_ALIVE		(1U <<  0)
#define WPI_INT_WAKEUP		(1U <<  1)
#define WPI_INT_SW_RX		(1U <<  3)
#define WPI_INT_RF_TOGGLED	(1U <<  7)
#define WPI_INT_SW_ERR		(1U << 25)
#define WPI_INT_FH_TX		(1U << 27)
#define WPI_INT_HW_ERR		(1U << 29)
#define WPI_INT_FH_RX		(1U << 31)

/* Shortcut. */
#define WPI_INT_MASK							\
	(WPI_INT_SW_ERR | WPI_INT_HW_ERR | WPI_INT_FH_TX | 		\
	 WPI_INT_FH_RX | WPI_INT_ALIVE | WPI_INT_WAKEUP |		\
	 WPI_INT_SW_RX | WPI_INT_RF_TOGGLED)

/* Possible flags for register WPI_FH_INT. */
#define WPI_FH_INT_RX_CHNL(x)	(1 << ((x) + 16))
#define WPI_FH_INT_HI_PRIOR	(1 << 30)
/* Shortcuts for the above. */
#define WPI_FH_INT_RX			\
	(WPI_FH_INT_RX_CHNL(0) |	\
	 WPI_FH_INT_RX_CHNL(1) |	\
	 WPI_FH_INT_RX_CHNL(2) |	\
	 WPI_FH_INT_HI_PRIOR)

/* Possible flags for register WPI_FH_TX_STATUS. */
#define WPI_FH_TX_STATUS_IDLE(qid)	\
	(1 << ((qid) + 24) | 1 << ((qid) + 16))

/* Possible flags for register WPI_EEPROM. */
#define WPI_EEPROM_READ_VALID	(1 << 0)
#define WPI_EEPROM_CMD		(1 << 1)

/* Possible flags for register WPI_EEPROM_GP. */
#define WPI_EEPROM_GP_IF_OWNER	0x00000180

/* Possible flags for register WPI_APMG_PS. */
#define WPI_APMG_PS_PWR_SRC_MASK	(3 << 24)

/* Possible flags for register WPI_APMG_CLK_ENA/WPI_APMG_CLK_DIS. */
#define WPI_APMG_CLK_DMA_CLK_RQT	(1 <<  9)
#define WPI_APMG_CLK_BSM_CLK_RQT	(1 << 11)

/* Possible flags for register WPI_APMG_PCI_STT. */
#define WPI_APMG_PCI_STT_L1A_DIS	(1 << 11)

struct wpi_shared {
	uint32_t	txbase[8];
	uint32_t	next;
	uint32_t	reserved[2];
} __packed;

#define WPI_MAX_SEG_LEN	65520
struct wpi_tx_desc {
	uint32_t	flags;
#define WPI_PAD32(x)	((((x) + 3) & ~3) - (x))

	struct {
		uint32_t	addr;
		uint32_t	len;
	} __packed	segs[WPI_MAX_SCATTER];
	uint8_t		reserved[28];
} __packed;

struct wpi_tx_stat {
	uint8_t		nrts;
	uint8_t		retrycnt;
	uint8_t		nkill;
	uint8_t		rate;
	uint32_t	duration;
	uint32_t	status;
} __packed;

struct wpi_rx_desc {
	uint32_t	len;
	uint8_t		type;
#define WPI_UC_READY		  1
#define WPI_ADD_NODE_DONE	 24
#define WPI_RX_DONE		 27
#define WPI_TX_DONE		 28
#define WPI_START_SCAN		130
#define WPI_STOP_SCAN		132
#define WPI_STATE_CHANGED	161

	uint8_t		flags;
	uint8_t		idx;
	uint8_t		qid;
} __packed;

struct wpi_tx_cmd {
	uint8_t	code;
#define WPI_CMD_RXON		 16
#define WPI_CMD_ASSOCIATE	 17
#define WPI_CMD_EDCA_PARAMS	 19
#define WPI_CMD_TIMING		 20
#define WPI_CMD_ADD_NODE	 24
#define WPI_CMD_TX_DATA		 28
#define WPI_CMD_MRR_SETUP	 71
#define WPI_CMD_SET_LED		 72
#define WPI_CMD_SET_POWER_MODE	119
#define WPI_CMD_SCAN		128
#define WPI_CMD_TXPOWER		151
#define WPI_CMD_BT_COEX		155

	uint8_t	flags;
	uint8_t	idx;
	uint8_t	qid;
	uint8_t	data[124];
} __packed;

/* Structure for command WPI_CMD_RXON. */
struct wpi_rxon {
	uint8_t		myaddr[IEEE80211_ADDR_LEN];
	uint16_t	reserved1;
	uint8_t		bssid[IEEE80211_ADDR_LEN];
	uint16_t	reserved2;
	uint32_t	reserved3[2];
	uint8_t		mode;
#define WPI_MODE_HOSTAP		1
#define WPI_MODE_STA		3
#define WPI_MODE_IBSS		4
#define WPI_MODE_MONITOR	6

	uint8_t		reserved4[3];
	uint8_t		ofdm_mask;
	uint8_t		cck_mask;
	uint16_t	associd;
	uint32_t	flags;
#define WPI_RXON_24GHZ		(1 <<  0)
#define WPI_RXON_CCK		(1 <<  1)
#define WPI_RXON_AUTO		(1 <<  2)
#define WPI_RXON_SHSLOT		(1 <<  4)
#define WPI_RXON_SHPREAMBLE	(1 <<  5)
#define WPI_RXON_NODIVERSITY	(1 <<  7)
#define WPI_RXON_ANT_A		(1 <<  8)
#define WPI_RXON_ANT_B		(1 <<  9)
#define WPI_RXON_TSF		(1 << 15)

	uint32_t	filter;
#define WPI_FILTER_PROMISC	(1 << 0)
#define WPI_FILTER_CTL		(1 << 1)
#define WPI_FILTER_MULTICAST	(1 << 2)
#define WPI_FILTER_NODECRYPT	(1 << 3)
#define WPI_FILTER_BSS		(1 << 5)

	uint8_t		chan;
	uint8_t		reserved6[3];
} __packed;

/* Structure for command WPI_CMD_ASSOCIATE. */
struct wpi_assoc {
	uint32_t	flags;
	uint32_t	filter;
	uint8_t		ofdm_mask;
	uint8_t		cck_mask;
	uint16_t	reserved;
} __packed;

/* Structure for command WPI_CMD_EDCA_PARAMS. */
struct wpi_edca_params {
	uint32_t	flags;
#define WPI_EDCA_UPDATE	(1 << 0)
#define WPI_EDCA_TXOP	(1 << 4)

	struct {
		uint16_t	cwmin;
		uint16_t	cwmax;
		uint8_t		aifsn;
		uint8_t		reserved;
		uint16_t	txoplimit;
	} __packed	ac[EDCA_NUM_AC];
} __packed;

/* Structure for command WPI_CMD_TIMING. */
struct wpi_cmd_timing {
	uint64_t	tstamp;
	uint16_t	bintval;
	uint16_t	atim;
	uint32_t	binitval;
	uint16_t	lintval;
	uint16_t	reserved;
} __packed;

/* Structure for command WPI_CMD_ADD_NODE. */
struct wpi_node_info {
	uint8_t		control;
#define WPI_NODE_UPDATE		(1 << 0)

	uint8_t		reserved1[3];
	uint8_t		macaddr[IEEE80211_ADDR_LEN];
	uint16_t	reserved2;
	uint8_t		id;
#define WPI_ID_BSS		0
#define WPI_ID_BROADCAST	24

	uint8_t		flags;
#define WPI_FLAG_SET_KEY	(1 << 0)

	uint16_t	reserved3;
	uint16_t	kflags;
#define WPI_KFLAG_CCMP		(1 <<  1)
#define WPI_KFLAG_KID(kid)	((kid) << 8)

	uint8_t		tsc2;
	uint8_t		reserved4;
	uint16_t	ttak[5];
	uint16_t	reserved5;
	uint8_t		key[16];

	uint32_t	action;
#define WPI_ACTION_SET_RATE	(1 << 2)

	uint32_t	mask;
	uint16_t	tid;
	uint8_t		plcp;
	uint8_t		antenna;
#define WPI_ANTENNA_A		(1 << 6)
#define WPI_ANTENNA_B		(1 << 7)
#define WPI_ANTENNA_BOTH	(WPI_ANTENNA_A | WPI_ANTENNA_B)

	uint8_t		add_imm;
	uint8_t		del_imm;
	uint16_t	add_imm_start;
} __packed;

/* Structure for command WPI_CMD_TX_DATA. */
struct wpi_cmd_data {
	uint16_t	len;
	uint16_t	lnext;
	uint32_t	flags;
#define WPI_TX_NEED_RTS		(1 <<  1)
#define WPI_TX_NEED_CTS		(1 <<  2)
#define WPI_TX_NEED_ACK		(1 <<  3)
#define WPI_TX_FULL_TXOP	(1 <<  7)
#define WPI_TX_BT_DISABLE	(1 << 12)	/* bluetooth coexistence */
#define WPI_TX_AUTO_SEQ		(1 << 13)
#define WPI_TX_INSERT_TSTAMP	(1 << 16)

	uint8_t		plcp;
	uint8_t		id;
	uint8_t		tid;
	uint8_t		security;
#define WPI_CIPHER_WEP40	1
#define WPI_CIPHER_CCMP		2
#define WPI_CIPHER_TKIP		3
#define WPI_CIPHER_WEP104	9

	uint8_t		key[IEEE80211_KEYBUF_SIZE];
	uint8_t		tkip[IEEE80211_TKIP_MICLEN];
	uint32_t	fnext;
	uint32_t	lifetime;
#define WPI_LIFETIME_INFINITE	0xffffffff

	uint8_t		ofdm_mask;
	uint8_t		cck_mask;
	uint8_t		rts_ntries;
	uint8_t		data_ntries;
	uint16_t	timeout;
	uint16_t	txop;
} __packed;

/* Structure for command WPI_CMD_MRR_SETUP. */
#define WPI_RIDX_MAX	11
struct wpi_mrr_setup {
	uint32_t	which;
#define WPI_MRR_CTL	0
#define WPI_MRR_DATA	1

	struct {
		uint8_t	plcp;
		uint8_t	flags;
		uint8_t	ntries;
		uint8_t	next;
	} __packed	rates[WPI_RIDX_MAX + 1];
} __packed;

/* Structure for command WPI_CMD_SET_LED. */
struct wpi_cmd_led {
	uint32_t	unit;	/* multiplier (in usecs) */
	uint8_t		which;
#define WPI_LED_ACTIVITY	1
#define WPI_LED_LINK		2

	uint8_t		off;
	uint8_t		on;
	uint8_t		reserved;
} __packed;

/* Structure for command WPI_CMD_SET_POWER_MODE. */
struct wpi_pmgt_cmd {
	uint32_t	flags;
#define WPI_PS_ALLOW_SLEEP	(1 << 0)
#define WPI_PS_SLEEP_OVER_DTIM	(1 << 2)
#define WPI_PS_PCI_PMGT		(1 << 3)

	uint32_t	rxtimeout;
	uint32_t	txtimeout;
	uint32_t	intval[5];
} __packed;

/* Structures for command WPI_CMD_SCAN. */
struct wpi_scan_essid {
	uint8_t	id;
	uint8_t	len;
	uint8_t	data[IEEE80211_NWID_LEN];
} __packed;

struct wpi_scan_hdr {
	uint16_t	len;
	uint8_t		reserved1;
	uint8_t		nchan;
	uint16_t	quiet_time;
	uint16_t	quiet_threshold;
	uint16_t	crc_threshold;
	uint16_t	reserved2;
	uint32_t	max_svc;	/* background scans */
	uint32_t	pause_svc;	/* background scans */
	uint32_t	flags;
	uint32_t	filter;

	/* Followed by a struct wpi_cmd_data. */
	/* Followed by an array of 4 structq wpi_scan_essid. */
	/* Followed by probe request body. */
	/* Followed by an array of ``nchan'' structs wpi_scan_chan. */
} __packed;

struct wpi_scan_chan {
	uint8_t		flags;
#define WPI_CHAN_ACTIVE		(1 << 0)
#define WPI_CHAN_NPBREQS(x)	(((1 << (x)) - 1) << 1)

	uint8_t		chan;
	uint8_t		rf_gain;
	uint8_t		dsp_gain;
	uint16_t	active;		/* msecs */
	uint16_t	passive;	/* msecs */
} __packed;

/* Maximum size of a scan command. */
#define WPI_SCAN_MAXSZ	(MCLBYTES - 4)

/* Structure for command WPI_CMD_TXPOWER. */
struct wpi_cmd_txpower {
	uint8_t		band;
#define WPI_BAND_5GHZ	0
#define WPI_BAND_2GHZ	1

	uint8_t		reserved;
	uint16_t	chan;
	struct {
		uint8_t	plcp;
		uint8_t	rf_gain;
		uint8_t	dsp_gain;
		uint8_t	reserved;
	} __packed	rates[WPI_RIDX_MAX + 1];
} __packed;

/* Structure for command WPI_CMD_BT_COEX. */
struct wpi_bluetooth {
	uint8_t		flags;
#define WPI_BT_COEX_DISABLE	0
#define WPI_BT_COEX_MODE_2WIRE	1
#define WPI_BT_COEX_MODE_3WIRE	2
#define WPI_BT_COEX_MODE_4WIRE	3

	uint8_t		lead_time;
#define WPI_BT_LEAD_TIME_DEF	30

	uint8_t		max_kill;
#define WPI_BT_MAX_KILL_DEF	5

	uint8_t		reserved;
	uint32_t	kill_ack;
	uint32_t	kill_cts;
} __packed;

/* Structures for WPI_RX_DONE notification. */
struct wpi_rx_stat {
	uint8_t		len;
#define WPI_STAT_MAXLEN	20

	uint8_t		id;
	uint8_t		rssi;	/* received signal strength */
#define WPI_RSSI_OFFSET	95

	uint8_t		agc;	/* access gain control */
	uint16_t	signal;
	uint16_t	noise;
} __packed;

struct wpi_rx_head {
	uint16_t	chan;
	uint16_t	flags;
	uint8_t		reserved;
	uint8_t		rate;
	uint16_t	len;
} __packed;

struct wpi_rx_tail {
	uint32_t	flags;
#define WPI_RX_NO_CRC_ERR	(1 <<  0)
#define WPI_RX_NO_OVFL_ERR	(1 <<  1)
/* Shortcut for the above. */
#define WPI_RX_NOERROR		(WPI_RX_NO_CRC_ERR | WPI_RX_NO_OVFL_ERR)
#define WPI_RX_CIPHER_MASK	(7 <<  8)
#define WPI_RX_CIPHER_CCMP	(2 <<  8)
#define WPI_RX_DECRYPT_MASK	(3 << 11)
#define WPI_RX_DECRYPT_OK	(3 << 11)

	uint64_t	tstamp;
	uint32_t	tbeacon;
} __packed;

/* Structure for WPI_UC_READY notification. */
struct wpi_ucode_info {
	uint32_t	version;
	uint8_t		revision[8];
	uint8_t		type;
	uint8_t		subtype;
#define WPI_UCODE_INIT	9

	uint16_t	reserved;
	uint32_t	logptr;
	uint32_t	errptr;
	uint32_t	timestamp;
	uint32_t	valid;
} __packed;

/* Structure for WPI_START_SCAN notification. */
struct wpi_start_scan {
	uint64_t	tstamp;
	uint32_t	tbeacon;
	uint8_t		chan;
	uint8_t		band;
	uint16_t	reserved;
	uint32_t	status;
} __packed;

/* Structure for WPI_STOP_SCAN notification. */
struct wpi_stop_scan {
	uint8_t		nchan;
	uint8_t		status;
	uint8_t		reserved;
	uint8_t		chan;
	uint64_t	tsf;
} __packed;


/* Firmware error dump entry. */
struct wpi_fwdump {
	uint32_t	desc;
	uint32_t	time;
	uint32_t	blink[2];
	uint32_t	ilink[2];
	uint32_t	data;
} __packed;

/* Firmware image file header. */
struct wpi_firmware_hdr {
	uint32_t	version;
	uint32_t	main_textsz;
	uint32_t	main_datasz;
	uint32_t	init_textsz;
	uint32_t	init_datasz;
	uint32_t	boot_textsz;
} __packed;

#define WPI_FW_TEXT_MAXSZ	(80 * 1024)
#define WPI_FW_DATA_MAXSZ	(32 * 1024)
#define WPI_FW_BOOT_TEXT_MAXSZ	1024

#define WPI_FW_UPDATED	(1U << 31)

/*
 * Offsets into EEPROM.
 */
#define WPI_EEPROM_MAC		0x015
#define WPI_EEPROM_REVISION	0x035
#define WPI_EEPROM_CAPABILITIES	0x045
#define WPI_EEPROM_TYPE		0x04a
#define WPI_EEPROM_DOMAIN	0x060
#define WPI_EEPROM_BAND1	0x063
#define WPI_EEPROM_BAND2	0x072
#define WPI_EEPROM_BAND3	0x080
#define WPI_EEPROM_BAND4	0x08d
#define WPI_EEPROM_BAND5	0x099
#define WPI_EEPROM_POWER_GRP	0x100

struct wpi_eeprom_chan {
	uint8_t	flags;
#define WPI_EEPROM_CHAN_VALID	(1 << 0)
#define WPI_EEPROM_CHAN_IBSS	(1 << 1)
#define WPI_EEPROM_CHAN_ACTIVE	(1 << 3)
#define WPI_EEPROM_CHAN_RADAR	(1 << 4)

	int8_t	maxpwr;
} __packed;

struct wpi_eeprom_sample {
	uint8_t		index;
	int8_t		power;
	uint16_t	volt;
} __packed;

#define WPI_POWER_GROUPS_COUNT	5
struct wpi_eeprom_group {
	struct		wpi_eeprom_sample samples[5];
	int32_t		coef[5];
	int32_t		corr[5];
	int8_t		maxpwr;
	uint8_t		chan;
	int16_t		temp;
} __packed;

#define WPI_CHAN_BANDS_COUNT	5
#define WPI_MAX_CHAN_PER_BAND	14
static const struct wpi_chan_band {
	uint32_t	addr;	/* offset in EEPROM */
	uint8_t		nchan;
	uint8_t		chan[WPI_MAX_CHAN_PER_BAND];
} wpi_bands[5] = {
	{ WPI_EEPROM_BAND1, 14,
	    { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 } },
	{ WPI_EEPROM_BAND2, 13,
	    { 183, 184, 185, 187, 188, 189, 192, 196, 7, 8, 11, 12, 16 } },
	{ WPI_EEPROM_BAND3, 12,
	    { 34, 36, 38, 40, 42, 44, 46, 48, 52, 56, 60, 64 } },
	{ WPI_EEPROM_BAND4, 11,
	    { 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140 } },
	{ WPI_EEPROM_BAND5, 6,
	    { 145, 149, 153, 157, 161, 165 } }
};

/* HW rate indices. */
#define WPI_RIDX_OFDM6	 0
#define WPI_RIDX_OFDM36	 5
#define WPI_RIDX_OFDM48	 6
#define WPI_RIDX_OFDM54	 7
#define WPI_RIDX_CCK1	 8
#define WPI_RIDX_CCK2	 9
#define WPI_RIDX_CCK11	11

static const struct wpi_rate {
	uint8_t	rate;
	uint8_t	plcp;
} wpi_rates[WPI_RIDX_MAX + 1] = {
	{  12, 0xd },
	{  18, 0xf },
	{  24, 0x5 },
	{  36, 0x7 },
	{  48, 0x9 },
	{  72, 0xb },
	{  96, 0x1 },
	{ 108, 0x3 },
	{   2,  10 },
	{   4,  20 },
	{  11,  55 },
	{  22, 110 }
};

#define WPI_MAX_PWR_INDEX	77
/*
 * RF Tx gain values from highest to lowest power (values obtained from
 * the reference driver.)
 */
static const uint8_t wpi_rf_gain_2ghz[WPI_MAX_PWR_INDEX + 1] = {
	0xfb, 0xfb, 0xfb, 0xfb, 0xfb, 0xfb, 0xfb, 0xfb, 0xbb, 0xbb, 0xbb,
	0xbb, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xd3, 0xd3, 0xb3, 0xb3, 0xb3,
	0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x73, 0xeb, 0xeb, 0xeb,
	0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xab, 0xab, 0xab, 0x8b,
	0xe3, 0xe3, 0xe3, 0xe3, 0xe3, 0xe3, 0xc3, 0xc3, 0xc3, 0xc3, 0xa3,
	0xa3, 0xa3, 0xa3, 0x83, 0x83, 0x83, 0x83, 0x63, 0x63, 0x63, 0x63,
	0x43, 0x43, 0x43, 0x43, 0x23, 0x23, 0x23, 0x23, 0x03, 0x03, 0x03,
	0x03
};

static const uint8_t wpi_rf_gain_5ghz[WPI_MAX_PWR_INDEX + 1] = {
	0xfb, 0xfb, 0xfb, 0xdb, 0xdb, 0xbb, 0xbb, 0x9b, 0x9b, 0x7b, 0x7b,
	0x7b, 0x7b, 0x5b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b, 0x1b, 0x1b,
	0x1b, 0x73, 0x73, 0x73, 0x53, 0x53, 0x53, 0x53, 0x53, 0x33, 0x33,
	0x33, 0x33, 0x13, 0x13, 0x13, 0x13, 0x13, 0xab, 0xab, 0xab, 0x8b,
	0x8b, 0x8b, 0x8b, 0x6b, 0x6b, 0x6b, 0x6b, 0x4b, 0x4b, 0x4b, 0x4b,
	0x2b, 0x2b, 0x2b, 0x2b, 0x0b, 0x0b, 0x0b, 0x0b, 0x83, 0x83, 0x63,
	0x63, 0x63, 0x63, 0x43, 0x43, 0x43, 0x43, 0x23, 0x23, 0x23, 0x23,
	0x03
};

/*
 * DSP pre-DAC gain values from highest to lowest power (values obtained
 * from the reference driver.)
 */
static const uint8_t wpi_dsp_gain_2ghz[WPI_MAX_PWR_INDEX + 1] = {
	0x7f, 0x7f, 0x7f, 0x7f, 0x7d, 0x6e, 0x69, 0x62, 0x7d, 0x73, 0x6c,
	0x63, 0x77, 0x6f, 0x69, 0x61, 0x5c, 0x6a, 0x64, 0x78, 0x71, 0x6b,
	0x7d, 0x77, 0x70, 0x6a, 0x65, 0x61, 0x5b, 0x6b, 0x79, 0x73, 0x6d,
	0x7f, 0x79, 0x73, 0x6c, 0x66, 0x60, 0x5c, 0x6e, 0x68, 0x62, 0x74,
	0x7d, 0x77, 0x71, 0x6b, 0x65, 0x60, 0x71, 0x6a, 0x66, 0x5f, 0x71,
	0x6a, 0x66, 0x5f, 0x71, 0x6a, 0x66, 0x5f, 0x71, 0x6a, 0x66, 0x5f,
	0x71, 0x6a, 0x66, 0x5f, 0x71, 0x6a, 0x66, 0x5f, 0x71, 0x6a, 0x66,
	0x5f
};

static const uint8_t wpi_dsp_gain_5ghz[WPI_MAX_PWR_INDEX + 1] = {
	0x7f, 0x78, 0x72, 0x77, 0x65, 0x71, 0x66, 0x72, 0x67, 0x75, 0x6b,
	0x63, 0x5c, 0x6c, 0x7d, 0x76, 0x6d, 0x66, 0x60, 0x5a, 0x68, 0x62,
	0x5c, 0x76, 0x6f, 0x68, 0x7e, 0x79, 0x71, 0x69, 0x63, 0x76, 0x6f,
	0x68, 0x62, 0x74, 0x6d, 0x66, 0x62, 0x5d, 0x71, 0x6b, 0x63, 0x78,
	0x71, 0x6b, 0x63, 0x78, 0x71, 0x6b, 0x63, 0x78, 0x71, 0x6b, 0x63,
	0x78, 0x71, 0x6b, 0x63, 0x78, 0x71, 0x6b, 0x63, 0x6b, 0x63, 0x78,
	0x71, 0x6b, 0x63, 0x78, 0x71, 0x6b, 0x63, 0x78, 0x71, 0x6b, 0x63,
	0x78
};

/*
 * Power saving settings (values obtained from the reference driver.)
 */
#define WPI_NDTIMRANGES		2
#define WPI_NPOWERLEVELS	6
static const struct wpi_pmgt {
	uint32_t	rxtimeout;
	uint32_t	txtimeout;
	uint32_t	intval[5];
	int		skip_dtim;
} wpi_pmgt[WPI_NDTIMRANGES][WPI_NPOWERLEVELS] = {
	/* DTIM <= 10 */
	{
	{   0,   0, {  0,  0,  0,  0,  0 }, 0 },	/* CAM */
	{ 200, 500, {  1,  2,  3,  4,  4 }, 0 },	/* PS level 1 */
	{ 200, 300, {  2,  4,  6,  7,  7 }, 0 },	/* PS level 2 */
	{  50, 100, {  2,  6,  9,  9, 10 }, 0 },	/* PS level 3 */
	{  50,  25, {  2,  7,  9,  9, 10 }, 1 },	/* PS level 4 */
	{  25,  25, {  4,  7, 10, 10, 10 }, 1 }		/* PS level 5 */
	},
	/* DTIM >= 11 */
	{
	{   0,   0, {  0,  0,  0,  0,  0 }, 0 },	/* CAM */
	{ 200, 500, {  1,  2,  3,  4, -1 }, 0 },	/* PS level 1 */
	{ 200, 300, {  2,  4,  6,  7, -1 }, 0 },	/* PS level 2 */
	{  50, 100, {  2,  6,  9,  9, -1 }, 0 },	/* PS level 3 */
	{  50,  25, {  2,  7,  9,  9, -1 }, 0 },	/* PS level 4 */
	{  25,  25, {  4,  7, 10, 10, -1 }, 0 }		/* PS level 5 */
	}
};

/* Firmware errors. */
static const char * const wpi_fw_errmsg[] = {
	"OK",
	"FAIL",
	"BAD_PARAM",
	"BAD_CHECKSUM",
	"NMI_INTERRUPT",
	"SYSASSERT",
	"FATAL_ERROR"
};

#define WPI_READ(sc, reg)						\
	bus_space_read_4((sc)->sc_st, (sc)->sc_sh, (reg))

#define WPI_WRITE(sc, reg, val)						\
	bus_space_write_4((sc)->sc_st, (sc)->sc_sh, (reg), (val))

#define WPI_WRITE_REGION_4(sc, offset, datap, count)			\
	bus_space_write_region_4((sc)->sc_st, (sc)->sc_sh, (offset),	\
	    (datap), (count))

#define WPI_SETBITS(sc, reg, mask)					\
	WPI_WRITE(sc, reg, WPI_READ(sc, reg) | (mask))
 
#define WPI_CLRBITS(sc, reg, mask)					\
	WPI_WRITE(sc, reg, WPI_READ(sc, reg) & ~(mask))

#define WPI_BARRIER_WRITE(sc)						\
	bus_space_barrier((sc)->sc_st, (sc)->sc_sh, 0, (sc)->sc_sz,	\
	    BUS_SPACE_BARRIER_WRITE)

#define WPI_BARRIER_READ_WRITE(sc)					\
	bus_space_barrier((sc)->sc_st, (sc)->sc_sh, 0, (sc)->sc_sz,	\
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE)
@


1.27
log
@add explicit barriers for read/write accesses to prph and internal memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.26 2009/10/24 18:21:05 damien Exp $	*/
d140 4
a143 4
#define WPI_FH_RX_CONFIG_DMA_ENA		(1 << 31)
#define WPI_FH_RX_CONFIG_RDRBD_ENA		(1 << 29)
#define WPI_FH_RX_CONFIG_WRSTATUS_ENA		(1 << 27)
#define WPI_FH_RX_CONFIG_MAXFRAG		(1 << 24)
d145 1
a145 1
#define WPI_FH_RX_CONFIG_IRQ_DST_HOST		(1 << 12)
d159 2
a160 2
#define WPI_BSM_WR_CTRL_START_EN	(1 << 30)
#define WPI_BSM_WR_CTRL_START		(1 << 31)
d163 8
a170 8
#define WPI_INT_ALIVE		(1 <<  0)
#define WPI_INT_WAKEUP		(1 <<  1)
#define WPI_INT_SW_RX		(1 <<  3)
#define WPI_INT_RF_TOGGLED	(1 <<  7)
#define WPI_INT_SW_ERR		(1 << 25)
#define WPI_INT_FH_TX		(1 << 27)
#define WPI_INT_HW_ERR		(1 << 29)
#define WPI_INT_FH_RX		(1 << 31)
d634 1
a634 1
#define WPI_FW_UPDATED	(1 << 31)
@


1.26
log
@oops i forgot the if_wpireg.h file in last my commit
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.25 2009/05/29 08:25:45 damien Exp $	*/
d834 7
@


1.25
log
@fix confusion between number of DMA channels and number of Tx queues.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.24 2009/05/24 18:51:12 damien Exp $	*/
d254 1
a254 1
#define WPI_CMD_CONFIGURE	 16
d273 1
a273 1
/* Structure for command WPI_CMD_CONFIGURE. */
d523 11
a533 2
	uint8_t		lead;
	uint8_t		kill;
d535 2
a536 2
	uint32_t	ack;
	uint32_t	cts;
a537 1

@


1.24
log
@reduce Rx ring size from 256 to 64 slots.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.23 2008/11/25 18:49:49 damien Exp $	*/
d26 2
a27 1
#define WPI_NTXQUEUES		16
@


1.23
log
@move some generic PCIe register flags used in wpi(4) and iwn(4)
into common pcireg.h

ok deraadt@@, kettenis@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.22 2008/11/09 10:00:17 damien Exp $	*/
d23 1
a23 1
#define WPI_RX_RING_COUNT_LOG	8
@


1.22
log
@rework the rate coding code to get rid of the ugly {wpi,iwn}_plcp_signal()
function.  will be required for future MCS support in iwn.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.21 2008/11/08 11:02:09 damien Exp $	*/
a35 3

/* Possible flags for PCIe Link Control Register (see PCIe 7.8.7) */
#define PCI_PCIE_LCSR_ASPM_L0S	(1 << 0)
@


1.21
log
@major wpi(4) overhaul.
wpi(4) and iwn(4) used to be in sync but with the latest iwn(4)
changes, this was no longer the case.  that commit repair this.
it brings HW CCMP encryption/decryption among other things.

requires an update of the wpi-firmware package.
please report any regression you might see.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.20 2007/09/11 18:52:32 damien Exp $	*/
d379 1
a379 1
	uint8_t		rate;
d403 1
a403 1
	uint8_t		rate;
d427 1
d438 1
a438 7
#define WPI_OFDM6	0
#define WPI_OFDM54	7
#define WPI_CCK1	8
#define WPI_CCK2	9
#define WPI_CCK11	11

	} __packed	rates[WPI_CCK11 + 1];
d519 1
a519 1
	} __packed	rates[WPI_CCK11 + 1];
d690 25
a714 10
/* Convert rate index (device view) into rate in 500Kbps unit. */
static const uint8_t wpi_ridx_to_rate[] = {
	12, 18, 24, 36, 48, 72, 96, 108, /* OFDM */
	2, 4, 11, 22 /* CCK */
};

/* Convert rate index (device view) into PLCP code. */
static const uint8_t wpi_ridx_to_plcp[] = {
	0xd, 0xf, 0x5, 0x7, 0x9, 0xb, 0x1, 0x3, /* OFDM R1-R4 */
	10, 20, 55, 110 /* CCK */
@


1.20
log
@- add callbacks for setting EDCA parameters and pairwise crypto keys.
- tweaks to make it look more like iwn(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.19 2007/09/10 20:53:22 damien Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006, 2007
d21 4
a24 1
#define WPI_RX_RING_COUNT	64
d28 5
a32 4
/*
 * Rings must be aligned on a 16K boundary.
 */
#define WPI_RING_DMA_ALIGN	0x4000
d34 2
a35 2
/* maximum scatter/gather */
#define WPI_MAX_SCATTER	4
d37 2
a38 2
/* maximum Rx buffer size (larger than MCLBYTES) */
#define WPI_RBUF_SIZE	(3 * 1024)	/* XXX 3000 but must be aligned! */
d43 2
a44 2
#define WPI_HWCONFIG		0x000
#define WPI_INTR		0x008
d46 2
a47 2
#define WPI_INTR_STATUS		0x010
#define WPI_GPIO_STATUS		0x018
d49 28
a76 27
#define WPI_GPIO_CTL		0x024
#define WPI_EEPROM_CTL		0x02c
#define WPI_EEPROM_STATUS	0x030
#define WPI_UCODE_CLR		0x05c
#define WPI_TEMPERATURE		0x060
#define WPI_CHICKEN		0x100
#define WPI_PLL_CTL		0x20c
#define WPI_WRITE_MEM_ADDR  	0x444
#define WPI_READ_MEM_ADDR   	0x448
#define WPI_WRITE_MEM_DATA  	0x44c
#define WPI_READ_MEM_DATA   	0x450
#define WPI_TX_WIDX		0x460
#define WPI_TX_CTL(qid)		(0x940 + (qid) * 8)
#define WPI_TX_BASE(qid)	(0x944 + (qid) * 8)
#define WPI_TX_DESC(qid)	(0x980 + (qid) * 80)
#define WPI_RX_CONFIG		0xc00
#define WPI_RX_BASE		0xc04
#define WPI_RX_WIDX		0xc20
#define WPI_RX_RIDX_PTR		0xc24
#define WPI_RX_CTL		0xcc0
#define WPI_RX_STATUS		0xcc4
#define WPI_TX_CONFIG(qid)	(0xd00 + (qid) * 32)
#define WPI_TX_CREDIT(qid)	(0xd04 + (qid) * 32)
#define WPI_TX_STATE(qid)	(0xd08 + (qid) * 32)
#define WPI_TX_BASE_PTR		0xe80
#define WPI_MSG_CONFIG		0xe88
#define WPI_TX_STATUS		0xe90
d82 125
a206 92
#define WPI_MEM_MODE		0x2e00
#define WPI_MEM_RA		0x2e04
#define WPI_MEM_TXCFG		0x2e10
#define WPI_MEM_MAGIC4		0x2e14
#define WPI_MEM_MAGIC5		0x2e20
#define WPI_MEM_BYPASS1		0x2e2c
#define WPI_MEM_BYPASS2		0x2e30
#define WPI_MEM_CLOCK1		0x3004
#define WPI_MEM_CLOCK2		0x3008
#define WPI_MEM_RFKILL		0x3014
#define WPI_MEM_POWER		0x300c
#define WPI_MEM_PCIDEV		0x3010
#define WPI_MEM_UCODE_CTL	0x3400
#define WPI_MEM_UCODE_SRC	0x3404
#define WPI_MEM_UCODE_DST	0x3408
#define WPI_MEM_UCODE_SIZE	0x340c
#define WPI_MEM_UCODE_BASE	0x3800

#define WPI_MEM_TEXT_BASE	0x3490
#define WPI_MEM_TEXT_SIZE	0x3494
#define WPI_MEM_DATA_BASE	0x3498
#define WPI_MEM_DATA_SIZE	0x349c


/* possible flags for register WPI_HWCONFIG */
#define WPI_HW_ALM_MB	(1 << 8)
#define WPI_HW_ALM_MM	(1 << 9)
#define WPI_HW_SKU_MRC	(1 << 10)
#define WPI_HW_REV_D	(1 << 11)
#define WPI_HW_TYPE_B	(1 << 12)

/* possible flags for registers WPI_READ_MEM_ADDR/WPI_WRITE_MEM_ADDR */
#define WPI_MEM_4	((sizeof (uint32_t) - 1) << 24)

/* possible values for WPI_MEM_UCODE_DST */
#define WPI_FW_TEXT	0x00000000

/* possible flags for WPI_GPIO_STATUS */
#define WPI_POWERED		(1 << 9)

/* possible flags for register WPI_RESET */
#define WPI_NEVO_RESET		(1 << 0)
#define WPI_SW_RESET		(1 << 7)
#define WPI_MASTER_DISABLED	(1 << 8)
#define WPI_STOP_MASTER		(1 << 9)

/* possible flags for register WPI_GPIO_CTL */
#define WPI_GPIO_CLOCK		(1 << 0)
#define WPI_GPIO_INIT		(1 << 2)
#define WPI_GPIO_MAC		(1 << 3)
#define WPI_GPIO_SLEEP		(1 << 4)
#define WPI_GPIO_PWR_STATUS	0x07000000
#define WPI_GPIO_PWR_SLEEP	(4 << 24)

/* possible flags for register WPI_CHICKEN */
#define WPI_CHICKEN_RXNOLOS	(1 << 23)

/* possible flags for register WPI_PLL_CTL */
#define WPI_PLL_INIT		(1 << 24)

/* possible flags for register WPI_UCODE_CLR */
#define WPI_RADIO_OFF		(1 << 1)
#define WPI_DISABLE_CMD		(1 << 2)

/* possible flags for WPI_RX_STATUS */
#define	WPI_RX_IDLE	(1 << 24)

/* possible flags for register WPI_UC_CTL */
#define WPI_UC_ENABLE	(1 << 30)
#define WPI_UC_RUN	(1 << 31)

/* possible flags for register WPI_INTR_CSR */
#define WPI_ALIVE_INTR	(1 << 0)
#define WPI_WAKEUP_INTR	(1 << 1)
#define WPI_SW_ERROR	(1 << 25)
#define WPI_TX_INTR	(1 << 27)
#define WPI_HW_ERROR	(1 << 29)
#define WPI_RX_INTR	(1 << 31)

#define WPI_INTR_MASK							\
	(WPI_SW_ERROR | WPI_HW_ERROR | WPI_TX_INTR | WPI_RX_INTR |	\
	 WPI_ALIVE_INTR | WPI_WAKEUP_INTR)

/* possible flags for register WPI_TX_STATUS */
#define WPI_TX_IDLE(qid)	(1 << ((qid) + 24) | 1 << ((qid) + 16))

/* possible flags for register WPI_EEPROM_CTL */
#define WPI_EEPROM_READY	(1 << 0)

/* possible flags for register WPI_EEPROM_STATUS */
#define WPI_EEPROM_VERSION	0x00000007
#define WPI_EEPROM_LOCKED	0x00000180
d208 2
d231 1
a231 1
	uint8_t		ntries;
d259 1
a259 1
#define WPI_CMD_TSF		 20
d267 1
a267 1
#define WPI_CMD_BLUETOOTH	155
d275 2
a276 2
/* structure for command WPI_CMD_CONFIGURE */
struct wpi_config {
d293 9
a301 9
#define WPI_CONFIG_24GHZ	(1 << 0)
#define WPI_CONFIG_CCK		(1 << 1)
#define WPI_CONFIG_AUTO		(1 << 2)
#define WPI_CONFIG_SHSLOT	(1 << 4)
#define WPI_CONFIG_SHPREAMBLE	(1 << 5)
#define WPI_CONFIG_NODIVERSITY	(1 << 7)
#define WPI_CONFIG_ANTENNA_A	(1 << 8)
#define WPI_CONFIG_ANTENNA_B	(1 << 9)
#define WPI_CONFIG_TSF		(1 << 15)
d314 1
a314 1
/* structure for command WPI_CMD_ASSOCIATE */
d323 1
a323 1
/* structure for command WPI_CMD_EDCA_PARAMS */
d338 2
a339 2
/* structure for command WPI_CMD_TSF */
struct wpi_cmd_tsf {
d348 1
a348 1
/* structure for command WPI_CMD_ADD_NODE */
d364 5
a368 2
	uint16_t	security;
	uint8_t		tkip;
d372 2
a373 1
	uint8_t		key[IEEE80211_KEYBUF_SIZE];
d390 1
a390 1
/* structure for command WPI_CMD_TX_DATA */
d413 1
a413 1
	uint8_t		tkip[IEEE80211_WEP_MICLEN];
d426 1
a426 1
/* structure for command WPI_CMD_MRR_SETUP */
d446 1
a446 1
/* structure for command WPI_CMD_SET_LED */
d458 2
a459 2
/* structure for command WPI_CMD_SET_POWER_MODE */
struct wpi_power {
d461 3
a463 1
#define WPI_POWER_CAM	0	/* constantly awake mode */
d465 3
a467 3
	uint32_t	rx_timeout;
	uint32_t	tx_timeout;
	uint32_t	sleep[5];
d470 1
a470 1
/* structures for command WPI_CMD_SCAN */
d481 2
a482 2
	uint16_t	quiet;
	uint16_t	plcp_threshold;
d490 4
a493 4
	/* followed by a struct wpi_cmd_data */
	/* followed by an array of 4x struct wpi_scan_essid */
	/* followed by probe request body */
	/* followed by nchan x wpi_scan_chan */
d498 2
a499 2
#define WPI_CHAN_ACTIVE	(1 << 0)
#define WPI_CHAN_DIRECT	(1 << 1)
d508 4
a511 1
/* structure for command WPI_CMD_TXPOWER */
d527 1
a527 1
/* structure for command WPI_CMD_BLUETOOTH */
d538 1
a538 1
/* structures for WPI_RX_DONE notification */
d562 3
a564 3
#define WPI_RX_NO_CRC_ERR	(1 << 0)
#define WPI_RX_NO_OVFL_ERR	(1 << 1)
/* shortcut for the above */
d566 4
d575 1
a575 1
/* structure for WPI_UC_READY notification */
d581 2
d585 1
a585 1
	uint32_t	errorptr;
d590 1
a590 1
/* structure for WPI_START_SCAN notification */
d600 1
a600 1
/* structure for WPI_STOP_SCAN notification */
d610 10
a619 1
/* firmware image header */
d629 2
a630 4
#define WPI_FW_MAIN_TEXT_MAXSZ	(80 * 1024)
#define WPI_FW_MAIN_DATA_MAXSZ	(32 * 1024)
#define WPI_FW_INIT_TEXT_MAXSZ	(80 * 1024)
#define WPI_FW_INIT_DATA_MAXSZ	(32 * 1024)
d695 1
a695 1
/* convert rate index (device view) into rate in 500Kbps unit */
d701 1
a701 1
/* convert rate index (device view) into PLCP code */
d760 42
d811 7
@


1.19
log
@fix boot code maximum size.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.18 2007/09/10 20:34:43 damien Exp $	*/
a20 1
#define WPI_CMD_RING_COUNT	256
d23 2
a26 1
 * I had a hard time figuring this out.
a213 32
struct wpi_rx_stat {
	uint8_t		len;
#define WPI_STAT_MAXLEN	20

	uint8_t		id;
	uint8_t		rssi;	/* received signal strength */
#define WPI_RSSI_OFFSET	95

	uint8_t		agc;	/* access gain control */
	uint16_t	signal;
	uint16_t	noise;
} __packed;

struct wpi_rx_head {
	uint16_t	chan;
	uint16_t	flags;
	uint8_t		reserved;
	uint8_t		rate;
	uint16_t	len;
} __packed;

struct wpi_rx_tail {
	uint32_t	flags;
#define WPI_RX_NO_CRC_ERR	(1 << 0)
#define WPI_RX_NO_OVFL_ERR	(1 << 1)
/* shortcut for the above */
#define WPI_RX_NOERROR		(WPI_RX_NO_CRC_ERR | WPI_RX_NO_OVFL_ERR)

	uint64_t	tstamp;
	uint32_t	tbeacon;
} __packed;

d218 1
a225 1
#define WPI_CMD_SET_BEACON	145
d235 1
a235 1
/* structure for WPI_CMD_CONFIGURE */
d283 15
d308 1
a308 1
/* structure for WPI_CMD_ADD_NODE */
d314 1
a314 1
	uint8_t		bssid[IEEE80211_ADDR_LEN];
d382 1
a382 19
/* structure for command WPI_CMD_SET_BEACON */
struct wpi_cmd_beacon {
	uint16_t	len;
	uint16_t	reserved1;
	uint32_t	flags;	/* same as wpi_cmd_data */
	uint8_t		rate;
	uint8_t		id;
	uint8_t		reserved2[30];
	uint32_t	lifetime;
	uint8_t		ofdm_mask;
	uint8_t		cck_mask;
	uint16_t	reserved3[3];
	uint16_t	tim;
	uint8_t		timsz;
	uint8_t		reserved4;
	struct		ieee80211_frame wh;
} __packed;

/* structure for WPI_CMD_MRR_SETUP */
d402 1
a402 1
/* structure for WPI_CMD_SET_LED */
d414 1
a414 1
/* structure for WPI_CMD_SET_POWER_MODE */
d462 1
a462 1
/* structure for WPI_CMD_TXPOWER */
d478 1
a478 1
/* structure for WPI_CMD_BLUETOOTH */
d488 33
@


1.18
log
@- add support for 802.11 headers with various sizes (will be required
  for EDCA support).
- remove an unused function.
- fix scan command.
- detect if the hardware radio switch is on instead of failing in the
  calibration of the thermal sensor with an obscure message.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.17 2007/07/24 16:07:47 damien Exp $	*/
d571 1
a571 1
#define WPI_FW_BOOT_TEXT_MAXSZ	(80 * 1024)
@


1.17
log
@hardware WEP in the TX path.
make sure to clear the SCAN lock in case the scan is interrupted.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.16 2007/07/10 18:29:38 damien Exp $	*/
d86 1
a396 1
	struct		ieee80211_frame wh;
d479 2
a480 21
	/* wpi_cmd_data structure */
	uint16_t	paylen;
	uint16_t	lnext;
	uint32_t	txflags;
	uint8_t		rate;
	uint8_t		id;
	uint8_t		tid;
	uint8_t		security;
	uint8_t		key[IEEE80211_KEYBUF_SIZE];
	uint8_t		tkip[IEEE80211_WEP_MICLEN];
	uint32_t	fnext;
	uint32_t	lifetime;
	uint8_t		ofdm_mask;
	uint8_t		cck_mask;
	uint8_t		rts_ntries;
	uint8_t		data_ntries;
	uint16_t	timeout;
	uint16_t	txop;

	struct		wpi_scan_essid essid[4];

@


1.16
log
@change firmware loading code to adopt the new 2.14.4 firmware layout.
while i'm here, fix allocation of the Rx ring descriptors so we don't
waste memory.

IMPORTANT: you must upgrade your wpi-firmware package to rev. 2.14.4
or the driver will stop working.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.15 2007/06/16 14:15:37 damien Exp $	*/
d201 1
d327 1
a327 1
#define WPI_NODE_UPDATE	(1 << 0)
d337 2
d340 1
a340 1
	uint16_t	key_flags;
d347 1
a347 1
#define WPI_ACTION_SET_RATE	4
d379 5
@


1.15
log
@do not allocate ring descriptors for the service queue.
this queue is used to load the firmware and the descriptors are written
differently (in wpi_load_segment()).
so the DMA descriptors were actually unused.

saves 16KB of memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.14 2007/06/09 09:50:00 damien Exp $	*/
a51 1
#define WPI_FW_TARGET		0x410
d94 4
a97 4
#define WPI_MEM_MAIN_TEXT_BASE	0x3490
#define WPI_MEM_MAIN_TEXT_SIZE	0x3494
#define WPI_MEM_MAIN_DATA_BASE	0x3498
#define WPI_MEM_MAIN_DATA_SIZE	0x349c
d110 1
a110 1
/* possible values for WPI_FW_TARGET */
a111 1
#define WPI_FW_DATA	0x00800000
d144 2
a145 1
#define WPI_UC_RUN	(1 << 30)
d573 2
a575 1
	uint32_t	boot_datasz;
d580 2
d583 2
a584 1
#define WPI_FW_BOOT_DATA_MAXSZ	(32 * 1024)
@


1.14
log
@print regulatory domain in dmesg output.
fix typo in a comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.13 2007/06/05 19:49:40 damien Exp $	*/
a20 1
#define WPI_SVC_RING_COUNT	256
@


1.13
log
@Major wpi(4) update:

1/ Update the driver to use the new firmware images from Intel (2.14.3.)
2/ Read the list of supported channels from the EEPROM instead of having
   it hard-coded in the driver.
3/ Limit output power to what is specified in EEPROM.
4/ Decrease output power for highest OFDM rates to reduce distortion.
5/ Automatically adjust output power to temperature changes for increased
   throughput and range.
6/ Attach the adapter's onboard thermal sensor to the sensor framework.
7/ Replace 'magic' fields in structures with their correct definitions.

NOTE1: you must upgrade your wpi-firmware package to rev 2.14.3 or the
driver will stop working.

NOTE2: if you are using a channel not allowed by the regulatory domain
of your adapter, you will no longer be able to associate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.12 2006/11/13 20:06:38 damien Exp $	*/
d591 1
@


1.12
log
@first round of commits for proper 11b/g protection support:
- use the newly introduced ieee80211_get_rts() and
  ieee80211_get_cts_to_self() functions.
- use CTS-to-self instead of RTS/CTS to protect OFDM frames in
  a mixed 11b/g BSS.
- make sure multicast frames are sent using CCK modulation.

remove support for 5GHz radios in ral(4) RT2560 and ural(4).
i'm not aware of any such adapters on the market and 11a code
is known to be broken.

some cleanup while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.11 2006/08/28 19:47:43 damien Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006
d26 1
a26 1
 * Rings must be aligned on a four 4K-pages boundary.
d34 1
a34 1
/* maximum Rx buffer size */
d96 5
d258 1
a259 1
#define WPI_CMD_TXPOWER		176
d283 1
a283 3
	uint16_t	state;
#define WPI_STATE_ASSOCIATED	4

d337 1
a337 1
	uint8_t		sta_mask;
d345 3
a347 1
	uint32_t	flags;
d351 5
a355 1
	uint8_t		reserved6;
d370 1
d382 2
d446 2
d453 7
a459 1
/* structure for command WPI_CMD_SCAN */
d461 1
a461 2
	uint8_t		len;
	uint8_t		first;
d465 5
a469 5
	uint16_t	threshold;
	uint16_t	band;
#define WPI_SCAN_5GHZ	1

	uint16_t	reserved2[5];
d472 5
a476 3
	uint16_t	length;
	uint16_t	reserved4;
	uint32_t	magic1;
d479 14
a492 7
	uint16_t	reserved5;
	uint32_t	reserved6[7];
	uint32_t	mask;
	uint32_t	reserved7[2];
	uint8_t		reserved8;
	uint8_t		esslen;
	uint8_t		essid[134];
d500 2
a501 1
#define WPI_CHAN_ACTIVE	3
d504 2
a505 1
	uint16_t	magic;		/* XXX */
d510 16
a535 17
/* structure for command WPI_CMD_TXPOWER */
struct wpi_txpower {
	uint32_t	reserved1;
	uint16_t	pwr1[14];
	uint32_t	reserved2[2];
	uint16_t	pwr2[14];
	uint32_t	reserved3[2];
} __packed;


/* firmware image header */
struct wpi_firmware_hdr {
	uint32_t	version;
	uint32_t	textsz;
	uint32_t	datasz;
	uint32_t	bootsz;
} __packed;
d569 18
d591 116
a706 2
#define WPI_EEPROM_PWR1		0x1ae
#define WPI_EEPROM_PWR2		0x1bc
@


1.11
log
@Completely rework the allocation/management of Rx buffers.
The firmware expects 3KB Rx buffers so we can't just map mbuf clusters
which are only 2KB.  Also it seems that Rx buffers must be aligned on
a 1KB boundary which is not necessary the case with mbuf clusters.
We want to make damn sure the firmware will not DMA anything outside the
mapped Rx buffers.  The size of the Rx buffers is probably configurable
but Intel will refuse to answer to any question regarding the
programmation of the chipset, and a dump of the device registers led to
nowhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.10 2006/08/01 12:43:56 damien Exp $	*/
d358 1
@


1.10
log
@- improve scan code to support scanning of 802.11a channels
- fix protection mode
- fix association to APs hiding their SSID
+ various cosmetic tweaks while i'm here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.9 2006/06/17 19:07:19 damien Exp $	*/
d33 3
@


1.9
log
@Move AMRR rate control algorithm out of wpi(4) and ural(4), into net80211.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.8 2006/06/16 18:54:09 damien Exp $	*/
d443 5
a447 1
	uint32_t	reserved2[3];
a448 1
	uint32_t	reserved3;
d468 2
d472 2
a473 2
	uint16_t	active;		/* dwell time */
	uint16_t	passive;	/* dwell time */
d527 8
@


1.8
log
@- fix reassociations (the firmware was crashing because the configuration
  was not properly reset) -- tested by Jean-Baptiste Campesato
- load the firmware block by block to avoid allocating a large amount of
  contiguous memory, which may not be possible at the time the interface
  is turned up.
- rename WPI_CONFIG_ASSOCIATED into WPI_STATE_ASSOCIATED
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.7 2006/06/05 16:42:21 damien Exp $	*/
d320 1
a320 1
struct wpi_node {
@


1.7
log
@- discard Rx frames with a bad CRC early
- don't start AMRR if we have set a fixed rate
- fix TSF synchronization
- remove a x2 prototype + ;; (pointed out by Jean-Baptiste Campesato)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.6 2006/05/25 09:26:58 damien Exp $	*/
d276 1
a276 1
#define WPI_CONFIG_ASSOCIATED	4
@


1.6
log
@automatic rate control (AMRR) + cosmetic and small fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.5 2006/05/20 15:31:30 damien Exp $	*/
d229 5
d294 1
a294 1
#define WPI_FILTER_BSSID	(1 << 5)
d328 1
a328 1
#define WPI_ID_BSSID		0
@


1.5
log
@more rx radiotap stats
@
text
@d1 1
a1 2
/*	$OpenBSD: if_wpireg.h,v 1.4 2006/05/20 13:24:02 damien Exp $	*/

d176 1
a176 1
		uint32_t	physaddr;
d351 1
d367 1
a367 1
	uint16_t	duration;
d381 3
a383 1
	uint32_t	reserved3[2];
d404 1
@


1.4
log
@- fix monitor mode
- cosmetic in wpi_dma_contig_alloc()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.3 2006/05/20 12:44:47 damien Exp $	*/
d278 1
a278 1
#define WPI_CONFIG_SHORT_SLOT	(1 << 4)
@


1.3
log
@- fix CCK mask for 802.11b/only
- add beacon command for future IBSS or HostAP mode support
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.2 2006/05/20 11:47:29 damien Exp $	*/
d263 4
a266 1
#define WPI_MODE_STA	3
d350 1
@


1.2
log
@- fix short slot time and short preamble settings
- fix basic rates setting
- fix check for WEP encryption (authreq frames might require encryption
  in shared mode)
- cleanup a few things while i'm here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpireg.h,v 1.1 2006/05/14 19:00:48 damien Exp $	*/
d245 1
d365 16
@


1.1
log
@Initial import of wpi(4), a blob-free driver for Intel PRO/Wireless 3945ABG
802.11 adapters as found in Centrino Duo laptops.
More to come but works well enough for me to commit this over a wpi(4).

go for it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d455 1
a455 1
	uint16_t	calib1[14];
d457 1
a457 1
	uint16_t	calib2[14];
d498 2
a499 2
#define WPI_EEPROM_CALIB1	0x1ae
#define WPI_EEPROM_CALIB2	0x1bc
@

