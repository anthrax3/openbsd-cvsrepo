head	1.65;
access;
symbols
	OPENBSD_6_1:1.65.0.8
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.65.0.6
	OPENBSD_6_0_BASE:1.65
	OPENBSD_5_9:1.65.0.2
	OPENBSD_5_9_BASE:1.65
	OPENBSD_5_8:1.62.0.4
	OPENBSD_5_8_BASE:1.62
	OPENBSD_5_7:1.61.0.4
	OPENBSD_5_7_BASE:1.61
	OPENBSD_5_6:1.58.0.4
	OPENBSD_5_6_BASE:1.58
	OPENBSD_5_5:1.57.0.4
	OPENBSD_5_5_BASE:1.57
	OPENBSD_5_4:1.55.0.4
	OPENBSD_5_4_BASE:1.55
	OPENBSD_5_3:1.55.0.2
	OPENBSD_5_3_BASE:1.55
	OPENBSD_5_2:1.53.0.4
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.2
	OPENBSD_5_0:1.52.0.2
	OPENBSD_5_0_BASE:1.52
	OPENBSD_4_9:1.47.0.2
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.43.0.2
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.34.0.4
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.28.0.2
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.26.0.4
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.11.0.16
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.14
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.12
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.10
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.8
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.12
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.10
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.8
	OPENBSD_2_8:1.10.0.6
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.2
	SMP_BASE:1.10
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.8
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.65
date	2015.12.01.21.02.04;	author kettenis;	state Exp;
branches;
next	1.64;
commitid	OJ1V3IZMr7rNfo4u;

1.64
date	2015.10.19.19.24.54;	author kettenis;	state Exp;
branches;
next	1.63;
commitid	F61kQhOppxMfhLAP;

1.63
date	2015.09.10.10.36.04;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	rKR7fNtQZgcyGGnQ;

1.62
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.61;
commitid	p4LJxGKbi0BU2cG6;

1.61
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.60;
commitid	MyKPm9Q3dQu92BiX;

1.60
date	2014.11.24.13.48.49;	author kettenis;	state Exp;
branches;
next	1.59;
commitid	2oVxM2atfRPONWr2;

1.59
date	2014.09.15.14.22.07;	author kettenis;	state Exp;
branches;
next	1.58;
commitid	MCijoCrM1r77JJFP;

1.58
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.57;
commitid	OBNa5kfxQ2UXoiIw;

1.57
date	2014.01.29.18.30.39;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2012.09.07.19.26.48;	author kettenis;	state Exp;
branches;
next	1.53;

1.53
date	2011.10.31.21.44.54;	author mikeb;	state Exp;
branches;
next	1.52;

1.52
date	2011.06.26.23.00.28;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2011.06.05.22.14.22;	author kettenis;	state Exp;
branches;
next	1.50;

1.50
date	2011.05.30.22.16.29;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2011.05.14.13.23.38;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2011.04.18.04.18.36;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2010.12.30.00.58.22;	author kettenis;	state Exp;
branches;
next	1.46;

1.46
date	2010.09.25.19.23.39;	author mlarkin;	state Exp;
branches;
next	1.45;

1.45
date	2010.08.31.17.13.44;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2010.08.17.19.14.52;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2010.08.02.03.22.26;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.30.05.14.39;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2010.04.06.22.28.07;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2009.12.27.20.03.52;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.24.00.52.07;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2009.11.23.22.49.58;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.23.16.53.55;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2009.11.19.20.46.16;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2009.09.24.21.26.25;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2009.05.30.18.46.06;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2009.05.15.21.51.58;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2009.05.05.14.16.17;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2009.04.24.20.03.55;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2009.04.22.20.45.57;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2009.04.01.19.51.10;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2008.12.28.23.08.06;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.26;

1.26
date	2007.12.31.19.13.36;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2007.12.04.17.33.13;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2007.11.30.16.21.38;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2007.11.30.15.54.12;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2007.11.25.16.42.21;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.25.10.52.09;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.24.21.33.58;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.21.22.10.45;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2007.02.13.18.35.32;	author tom;	state Exp;
branches;
next	1.17;

1.17
date	2006.12.14.17.36.12;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.04.18.26.30;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.19.21.57.55;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.13.20.10.49;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.27.02.05.19;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.05.14.39.23;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.15.08.16.24;	author deraadt;	state Exp;
branches
	1.10.2.1
	1.10.12.1;
next	1.9;

1.9
date	98.03.10.08.40.39;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.03.10.08.31.56;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.01.20.18.40.36;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	98.01.05.13.35.26;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.11.28.23.28.14;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.21.47.06;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.05.07.07.38.51;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.22.25.53;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.04.18.23.48.09;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2002.03.28.15.35.59;	author niklas;	state Exp;
branches;
next	;

1.10.12.1
date	2002.06.11.03.42.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.65
log
@Teach ppb(4) how to allocate PCI bus numbers such that it can properly
condigure bridges left unconfigured by the system firmware.  Not perfect yet,
but good enough to make the Apple Thunderbolt Giabit Ethernet adapter work
when inserted at boot time.

ok deraadt@@
@
text
@/*	$OpenBSD: ppb.c,v 1.64 2015/10/19 19:24:54 kettenis Exp $	*/
/*	$NetBSD: ppb.c,v 1.16 1997/06/06 23:48:05 thorpej Exp $	*/

/*
 * Copyright (c) 1996 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/task.h>
#include <sys/timeout.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/ppbreg.h>

#ifndef PCI_IO_START
#define PCI_IO_START	0
#endif

#ifndef PCI_IO_END
#define PCI_IO_END	0xffffffff
#endif

#ifndef PCI_MEM_START
#define PCI_MEM_START	0
#endif

#ifndef PCI_MEM_END
#define PCI_MEM_END	0xffffffff
#endif

#define PPB_EXNAMLEN	32

struct ppb_softc {
	struct device sc_dev;		/* generic device glue */
	pci_chipset_tag_t sc_pc;	/* our PCI chipset... */
	pcitag_t sc_tag;		/* ...and tag. */
	pci_intr_handle_t sc_ih[4];
	void *sc_intrhand;
	struct extent *sc_busex;
	struct extent *sc_ioex;
	struct extent *sc_memex;
	struct extent *sc_pmemex;
	struct device *sc_psc;
	int sc_cap_off;
	struct task sc_insert_task;
	struct task sc_rescan_task;
	struct task sc_remove_task;
	struct timeout sc_to;

	bus_addr_t sc_iobase, sc_iolimit;
	bus_addr_t sc_membase, sc_memlimit;
	bus_addr_t sc_pmembase, sc_pmemlimit;

	pcireg_t sc_csr;
	pcireg_t sc_bhlcr;
	pcireg_t sc_bir;
	pcireg_t sc_bcr;
	pcireg_t sc_int;
	pcireg_t sc_slcsr;
	pcireg_t sc_msi_mc;
	pcireg_t sc_msi_ma;
	pcireg_t sc_msi_mau32;
	pcireg_t sc_msi_md;
	int sc_pmcsr_state;
};

int	ppbmatch(struct device *, void *, void *);
void	ppbattach(struct device *, struct device *, void *);
int	ppbdetach(struct device *self, int flags);
int	ppbactivate(struct device *self, int act);

struct cfattach ppb_ca = {
	sizeof(struct ppb_softc), ppbmatch, ppbattach, ppbdetach, ppbactivate
};

struct cfdriver ppb_cd = {
	NULL, "ppb", DV_DULL
};

void	ppb_alloc_busrange(struct ppb_softc *, struct pci_attach_args *,
	    pcireg_t *);
void	ppb_alloc_resources(struct ppb_softc *, struct pci_attach_args *);
int	ppb_intr(void *);
void	ppb_hotplug_insert(void *);
void	ppb_hotplug_insert_finish(void *);
int	ppb_hotplug_fixup(struct pci_attach_args *);
int	ppb_hotplug_fixup_type0(pci_chipset_tag_t, pcitag_t, pcitag_t);
int	ppb_hotplug_fixup_type1(pci_chipset_tag_t, pcitag_t, pcitag_t);
void	ppb_hotplug_rescan(void *);
void	ppb_hotplug_remove(void *);
int	ppbprint(void *, const char *pnp);

int
ppbmatch(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	/*
	 * This device is mislabeled.  It is not a PCI bridge.
	 */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VIATECH &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VT82C586_PWR)
		return (0);
	/*
	 * Check the ID register to see that it's a PCI bridge.
	 * If it is, we assume that we can deal with it; it _should_
	 * work in a standardized way...
	 */
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_BRIDGE &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_BRIDGE_PCI)
		return (1);

	return (0);
}

void
ppbattach(struct device *parent, struct device *self, void *aux)
{
	struct ppb_softc *sc = (struct ppb_softc *)self;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	struct pcibus_attach_args pba;
	pci_interface_t interface;
	pci_intr_handle_t ih;
	pcireg_t busdata, reg, blr;
	char *name;
	int sec, sub;
	int pin;

	sc->sc_pc = pc;
	sc->sc_tag = pa->pa_tag;

	busdata = pci_conf_read(pc, pa->pa_tag, PPB_REG_BUSINFO);

	/*
	 * When the bus number isn't configured, try to allocate one
	 * ourselves.
	 */
	if (busdata  == 0 && pa->pa_busex)
		ppb_alloc_busrange(sc, pa, &busdata);

	/*
	 * When the bus number still isn't set correctly, give up.
	 */
	if (PPB_BUSINFO_SECONDARY(busdata) == 0) {
		printf(": not configured by system firmware\n");
		return;
	}

#if 0
	/*
	 * XXX can't do this, because we're not given our bus number
	 * (we shouldn't need it), and because we've no way to
	 * decompose our tag.
	 */
	/* sanity check. */
	if (pa->pa_bus != PPB_BUSINFO_PRIMARY(busdata))
		panic("ppbattach: bus in tag (%d) != bus in reg (%d)",
		    pa->pa_bus, PPB_BUSINFO_PRIMARY(busdata));
#endif

	sec = PPB_BUSINFO_SECONDARY(busdata);
	sub = PPB_BUSINFO_SUBORDINATE(busdata);
	if (sub > sec) {
		name = malloc(PPB_EXNAMLEN, M_DEVBUF, M_NOWAIT);
		if (name) {
			snprintf(name, PPB_EXNAMLEN, "%s pcibus", sc->sc_dev.dv_xname);
			sc->sc_busex = extent_create(name, 0, 0xff,
			    M_DEVBUF, NULL, 0, EX_NOWAIT | EX_FILLED);
			extent_free(sc->sc_busex, sec + 1,
			    sub - sec, EX_NOWAIT);
		}
	}

	/* Check for PCI Express capabilities and setup hotplug support. */
	if (pci_get_capability(pc, pa->pa_tag, PCI_CAP_PCIEXPRESS,
	    &sc->sc_cap_off, &reg) && (reg & PCI_PCIE_XCAP_SI)) {
		task_set(&sc->sc_insert_task, ppb_hotplug_insert, sc);
		task_set(&sc->sc_rescan_task, ppb_hotplug_rescan, sc);
		task_set(&sc->sc_remove_task, ppb_hotplug_remove, sc);
		timeout_set(&sc->sc_to, ppb_hotplug_insert_finish, sc);

#ifdef __i386__
		if (pci_intr_map(pa, &ih) == 0)
			sc->sc_intrhand = pci_intr_establish(pc, ih, IPL_BIO,
			    ppb_intr, sc, self->dv_xname);
#else
		if (pci_intr_map_msi(pa, &ih) == 0 ||
		    pci_intr_map(pa, &ih) == 0)
			sc->sc_intrhand = pci_intr_establish(pc, ih, IPL_BIO,
			    ppb_intr, sc, self->dv_xname);
#endif

		if (sc->sc_intrhand) {
			printf(": %s", pci_intr_string(pc, ih));

			/* Enable hotplug interrupt. */
			reg = pci_conf_read(pc, pa->pa_tag,
			    sc->sc_cap_off + PCI_PCIE_SLCSR);
			reg |= (PCI_PCIE_SLCSR_HPE | PCI_PCIE_SLCSR_PDE);
			pci_conf_write(pc, pa->pa_tag,
			    sc->sc_cap_off + PCI_PCIE_SLCSR, reg);
		}
	}

	printf("\n");

	interface = PCI_INTERFACE(pa->pa_class);

	/*
	 * The Intel 82801BAM Hub-to-PCI can decode subtractively but
	 * doesn't advertise itself as such.
	 */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801BA_HPB ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801BAM_HPB))
		interface = PPB_INTERFACE_SUBTRACTIVE;

	if (interface != PPB_INTERFACE_SUBTRACTIVE)
		ppb_alloc_resources(sc, pa);

	for (pin = PCI_INTERRUPT_PIN_A; pin <= PCI_INTERRUPT_PIN_D; pin++) {
		pa->pa_intrpin = pa->pa_rawintrpin = pin;
		pa->pa_intrline = 0;
		pci_intr_map(pa, &sc->sc_ih[pin - PCI_INTERRUPT_PIN_A]);
	}

	/*
	 * The UltraSPARC-IIi APB doesn't implement the standard
	 * address range registers.
	 */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SUN &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SUN_SIMBA)
		goto attach;

	/* Figure out the I/O address range of the bridge. */
	blr = pci_conf_read(pc, pa->pa_tag, PPB_REG_IOSTATUS);
	sc->sc_iobase = (blr & 0x000000f0) << 8;
	sc->sc_iolimit = (blr & 0x000f000) | 0x00000fff;
	blr = pci_conf_read(pc, pa->pa_tag, PPB_REG_IO_HI);
	sc->sc_iobase |= (blr & 0x0000ffff) << 16;
	sc->sc_iolimit |= (blr & 0xffff0000);
	if (sc->sc_iolimit > sc->sc_iobase) {
		name = malloc(PPB_EXNAMLEN, M_DEVBUF, M_NOWAIT);
		if (name) {
			snprintf(name, PPB_EXNAMLEN, "%s pciio", sc->sc_dev.dv_xname);
			sc->sc_ioex = extent_create(name, 0, 0xffffffff,
			    M_DEVBUF, NULL, 0, EX_NOWAIT | EX_FILLED);
			extent_free(sc->sc_ioex, sc->sc_iobase,
			    sc->sc_iolimit - sc->sc_iobase + 1, EX_NOWAIT);
		}
	}

	/* Figure out the memory mapped I/O address range of the bridge. */
	blr = pci_conf_read(pc, pa->pa_tag, PPB_REG_MEM);
	sc->sc_membase = (blr & 0x0000fff0) << 16;
	sc->sc_memlimit = (blr & 0xfff00000) | 0x000fffff;
	if (sc->sc_memlimit > sc->sc_membase) {
		name = malloc(PPB_EXNAMLEN, M_DEVBUF, M_NOWAIT);
		if (name) {
			snprintf(name, PPB_EXNAMLEN, "%s pcimem", sc->sc_dev.dv_xname);
			sc->sc_memex = extent_create(name, 0, (u_long)-1L,
			    M_DEVBUF, NULL, 0, EX_NOWAIT | EX_FILLED);
			extent_free(sc->sc_memex, sc->sc_membase,
			    sc->sc_memlimit - sc->sc_membase + 1,
			    EX_NOWAIT);
		}
	}

	/* Figure out the prefetchable MMI/O address range of the bridge. */
	blr = pci_conf_read(pc, pa->pa_tag, PPB_REG_PREFMEM);
	sc->sc_pmembase = (blr & 0x0000fff0) << 16;
	sc->sc_pmemlimit = (blr & 0xfff00000) | 0x000fffff;
#ifdef __LP64__
	blr = pci_conf_read(pc, pa->pa_tag, PPB_REG_PREFBASE_HI32);
	sc->sc_pmembase |= ((uint64_t)blr) << 32;
	blr = pci_conf_read(pc, pa->pa_tag, PPB_REG_PREFLIM_HI32);
	sc->sc_pmemlimit |= ((uint64_t)blr) << 32;
#endif
	if (sc->sc_pmemlimit > sc->sc_pmembase) {
		name = malloc(PPB_EXNAMLEN, M_DEVBUF, M_NOWAIT);
		if (name) {
			snprintf(name, PPB_EXNAMLEN, "%s pcipmem", sc->sc_dev.dv_xname);
			sc->sc_pmemex = extent_create(name, 0, (u_long)-1L,
			    M_DEVBUF, NULL, 0, EX_NOWAIT | EX_FILLED);
			extent_free(sc->sc_pmemex, sc->sc_pmembase,
			    sc->sc_pmemlimit - sc->sc_pmembase + 1,
			    EX_NOWAIT);
		}
	}

	if (interface == PPB_INTERFACE_SUBTRACTIVE) {
		if (sc->sc_ioex == NULL)
			sc->sc_ioex = pa->pa_ioex;
		if (sc->sc_memex == NULL)
			sc->sc_memex = pa->pa_memex;
	}

 attach:
	/*
	 * Attach the PCI bus that hangs off of it.
	 *
	 * XXX Don't pass-through Memory Read Multiple.  Should we?
	 * XXX Consult the spec...
	 */
	bzero(&pba, sizeof(pba));
	pba.pba_busname = "pci";
	pba.pba_iot = pa->pa_iot;
	pba.pba_memt = pa->pa_memt;
	pba.pba_dmat = pa->pa_dmat;
	pba.pba_pc = pc;
	pba.pba_flags = pa->pa_flags & ~PCI_FLAGS_MRM_OKAY;
	pba.pba_busex = sc->sc_busex;
	pba.pba_ioex = sc->sc_ioex;
	pba.pba_memex = sc->sc_memex;
	pba.pba_pmemex = sc->sc_pmemex;
	pba.pba_domain = pa->pa_domain;
	pba.pba_bus = PPB_BUSINFO_SECONDARY(busdata);
	pba.pba_bridgeih = sc->sc_ih;
	pba.pba_bridgetag = &sc->sc_tag;
	pba.pba_intrswiz = pa->pa_intrswiz;
	pba.pba_intrtag = pa->pa_intrtag;

	sc->sc_psc = config_found(self, &pba, ppbprint);
}

int
ppbdetach(struct device *self, int flags)
{
	struct ppb_softc *sc = (struct ppb_softc *)self;
	char *name;
	int rv;

	if (sc->sc_intrhand)
		pci_intr_disestablish(sc->sc_pc, sc->sc_intrhand);

	rv = config_detach_children(self, flags);

	if (sc->sc_busex) {
		name = sc->sc_busex->ex_name;
		extent_destroy(sc->sc_busex);
		free(name, M_DEVBUF, PPB_EXNAMLEN);
	}

	if (sc->sc_ioex) {
		name = sc->sc_ioex->ex_name;
		extent_destroy(sc->sc_ioex);
		free(name, M_DEVBUF, PPB_EXNAMLEN);
	}

	if (sc->sc_memex) {
		name = sc->sc_memex->ex_name;
		extent_destroy(sc->sc_memex);
		free(name, M_DEVBUF, PPB_EXNAMLEN);
	}

	if (sc->sc_pmemex) {
		name = sc->sc_pmemex->ex_name;
		extent_destroy(sc->sc_pmemex);
		free(name, M_DEVBUF, PPB_EXNAMLEN);
	}

	return (rv);
}

int
ppbactivate(struct device *self, int act)
{
	struct ppb_softc *sc = (void *)self;
	pci_chipset_tag_t pc = sc->sc_pc;
	pcitag_t tag = sc->sc_tag;
	pcireg_t blr, reg;
	int off, rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);

		/* Save registers that may get lost. */
		sc->sc_csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
		sc->sc_bhlcr = pci_conf_read(pc, tag, PCI_BHLC_REG);
		sc->sc_bir = pci_conf_read(pc, tag, PPB_REG_BUSINFO);
		sc->sc_bcr = pci_conf_read(pc, tag, PPB_REG_BRIDGECONTROL);
		sc->sc_int = pci_conf_read(pc, tag, PCI_INTERRUPT_REG);
		if (sc->sc_cap_off)
			sc->sc_slcsr = pci_conf_read(pc, tag,
			    sc->sc_cap_off + PCI_PCIE_SLCSR);

		if (pci_get_capability(pc, tag, PCI_CAP_MSI, &off, &reg)) {
			sc->sc_msi_ma = pci_conf_read(pc, tag,
			    off + PCI_MSI_MA);
			if (reg & PCI_MSI_MC_C64) {
				sc->sc_msi_mau32 = pci_conf_read(pc, tag,
				    off + PCI_MSI_MAU32);
				sc->sc_msi_md = pci_conf_read(pc, tag,
				    off + PCI_MSI_MD64);
			} else {
				sc->sc_msi_md = pci_conf_read(pc, tag,
				    off + PCI_MSI_MD32);
			}
			sc->sc_msi_mc = reg;
		}
		break;
	case DVACT_RESUME:
		if (pci_dopm) {
			/* Restore power. */
			pci_set_powerstate(pc, tag, sc->sc_pmcsr_state);
		}

		/* Restore the registers saved above. */
		pci_conf_write(pc, tag, PCI_BHLC_REG, sc->sc_bhlcr);
		pci_conf_write(pc, tag, PPB_REG_BUSINFO, sc->sc_bir);
		pci_conf_write(pc, tag, PPB_REG_BRIDGECONTROL, sc->sc_bcr);
		pci_conf_write(pc, tag, PCI_INTERRUPT_REG, sc->sc_int);
		if (sc->sc_cap_off)
			pci_conf_write(pc, tag,
			    sc->sc_cap_off + PCI_PCIE_SLCSR, sc->sc_slcsr);

		/* Restore I/O window. */
		blr = pci_conf_read(pc, tag, PPB_REG_IOSTATUS);
		blr &= 0xffff0000;
		blr |= sc->sc_iolimit & PPB_IO_MASK;
		blr |= (sc->sc_iobase >> PPB_IO_SHIFT);
		pci_conf_write(pc, tag, PPB_REG_IOSTATUS, blr);
		blr = (sc->sc_iobase & 0xffff0000) >> 16;
		blr |= sc->sc_iolimit & 0xffff0000;
		pci_conf_write(pc, tag, PPB_REG_IO_HI, blr);

		/* Restore memory mapped I/O window. */
		blr = sc->sc_memlimit & PPB_MEM_MASK;
		blr |= (sc->sc_membase >> PPB_MEM_SHIFT);
		pci_conf_write(pc, tag, PPB_REG_MEM, blr);

		/* Restore prefetchable MMI/O window. */
		blr = sc->sc_pmemlimit & PPB_MEM_MASK;
		blr |= ((sc->sc_pmembase & PPB_MEM_MASK) >> PPB_MEM_SHIFT);
		pci_conf_write(pc, tag, PPB_REG_PREFMEM, blr);
#ifdef __LP64__
		pci_conf_write(pc, tag, PPB_REG_PREFBASE_HI32,
		    sc->sc_pmembase >> 32);
		pci_conf_write(pc, tag, PPB_REG_PREFLIM_HI32,
		    sc->sc_pmemlimit >> 32);
#endif

		if (pci_get_capability(pc, tag, PCI_CAP_MSI, &off, &reg)) {
			pci_conf_write(pc, tag, off + PCI_MSI_MA,
			    sc->sc_msi_ma);
			if (reg & PCI_MSI_MC_C64) {
				pci_conf_write(pc, tag, off + PCI_MSI_MAU32,
				    sc->sc_msi_mau32);
				pci_conf_write(pc, tag, off + PCI_MSI_MD64,
				    sc->sc_msi_md);
			} else {
				pci_conf_write(pc, tag, off + PCI_MSI_MD32,
				    sc->sc_msi_md);
			}
			pci_conf_write(pc, tag, off + PCI_MSI_MC,
			    sc->sc_msi_mc);
		}

		/*
		 * Restore command register last to avoid exposing
		 * uninitialised windows.
		 */
		reg = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
		pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG,
		    (reg & 0xffff0000) | (sc->sc_csr & 0x0000ffff));

		rv = config_activate_children(self, act);
		break;
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		
		if (pci_dopm) {	
			/*
			 * Place the bridge into the lowest possible
			 * power state.
			 */
			sc->sc_pmcsr_state = pci_get_powerstate(pc, tag);
			pci_set_powerstate(pc, tag,
			    pci_min_powerstate(pc, tag));
		}
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

void
ppb_alloc_busrange(struct ppb_softc *sc, struct pci_attach_args *pa,
    pcireg_t *busdata)
{
	pci_chipset_tag_t pc = sc->sc_pc;
	u_long busnum, busrange;

	for (busrange = 16; busrange > 0; busrange >>= 1) {
		if (extent_alloc(pa->pa_busex, busrange, 1, 0, 0, 
		    EX_NOWAIT, &busnum))
			continue;
		*busdata |= pa->pa_bus;
		*busdata |= (busnum << 8);
		*busdata |= ((busnum + busrange - 1) << 16);
		pci_conf_write(pc, pa->pa_tag, PPB_REG_BUSINFO, *busdata);
		return;
	}
}

void
ppb_alloc_resources(struct ppb_softc *sc, struct pci_attach_args *pa)
{
	pci_chipset_tag_t pc = sc->sc_pc;
	pcireg_t id, busdata, blr, bhlcr, type, csr;
	pcireg_t addr, mask;
	pcitag_t tag;
	int bus, dev;
	int reg, reg_start, reg_end, reg_rom;
	int io_count = 0;
	int mem_count = 0;
	bus_addr_t start, end;
	u_long base, size;

	if (pa->pa_memex == NULL)
		return;

	busdata = pci_conf_read(pc, sc->sc_tag, PPB_REG_BUSINFO);
	bus = PPB_BUSINFO_SECONDARY(busdata);
	if (bus == 0)
		return;

	/*
	 * Count number of devices.  If there are no devices behind
	 * this bridge, there's no point in allocating any address
	 * space.
	 */
	for (dev = 0; dev < pci_bus_maxdevs(pc, bus); dev++) {
		tag = pci_make_tag(pc, bus, dev, 0);
		id = pci_conf_read(pc, tag, PCI_ID_REG);

		if (PCI_VENDOR(id) == PCI_VENDOR_INVALID ||
		    PCI_VENDOR(id) == 0)
			continue;

		bhlcr = pci_conf_read(pc, tag, PCI_BHLC_REG);
		switch (PCI_HDRTYPE_TYPE(bhlcr)) {
		case 0:
			reg_start = PCI_MAPREG_START;
			reg_end = PCI_MAPREG_END;
			reg_rom = PCI_ROM_REG;
			break;
		case 1:	/* PCI-PCI bridge */
			reg_start = PCI_MAPREG_START;
			reg_end = PCI_MAPREG_PPB_END;
			reg_rom = 0;	/* 0x38 */
			io_count++;
			mem_count++;
			break;
		case 2:	/* PCI-Cardbus bridge */
			reg_start = PCI_MAPREG_START;
			reg_end = PCI_MAPREG_PCB_END;
			reg_rom = 0;
			io_count++;
			mem_count++;
			break;
		default:
			return;
		}

		for (reg = reg_start; reg < reg_end; reg += 4) {
			if (pci_mapreg_probe(pc, tag, reg, &type) == 0)
				continue;

			if (type == PCI_MAPREG_TYPE_IO)
				io_count++;
			else
				mem_count++;
		}

		if (reg_rom != 0) {
			addr = pci_conf_read(pc, tag, reg_rom);
			pci_conf_write(pc, tag, reg_rom, ~PCI_ROM_ENABLE);
			mask = pci_conf_read(pc, tag, reg_rom);
			pci_conf_write(pc, tag, reg_rom, addr);
			if (PCI_ROM_SIZE(mask))
				mem_count++;
		}
	}

	csr = pci_conf_read(pc, sc->sc_tag, PCI_COMMAND_STATUS_REG);

	/*
	 * Get the bridge in a consistent state.  If memory mapped I/O
	 * is disabled, disabled the associated windows as well.  
	 */
	if ((csr & PCI_COMMAND_MEM_ENABLE) == 0) {
		pci_conf_write(pc, sc->sc_tag, PPB_REG_MEM, 0x0000ffff);
		pci_conf_write(pc, sc->sc_tag, PPB_REG_PREFMEM, 0x0000ffff);
		pci_conf_write(pc, sc->sc_tag, PPB_REG_PREFBASE_HI32, 0);
		pci_conf_write(pc, sc->sc_tag, PPB_REG_PREFLIM_HI32, 0);
	}

	/* Allocate I/O address space if necessary. */
	if (io_count > 0 && pa->pa_ioex) {
		blr = pci_conf_read(pc, sc->sc_tag, PPB_REG_IOSTATUS);
		sc->sc_iobase = (blr << PPB_IO_SHIFT) & PPB_IO_MASK;
		sc->sc_iolimit = (blr & PPB_IO_MASK) | 0x00000fff;
		blr = pci_conf_read(pc, sc->sc_tag, PPB_REG_IO_HI);
		sc->sc_iobase |= (blr & 0x0000ffff) << 16;
		sc->sc_iolimit |= (blr & 0xffff0000);
		if (sc->sc_iolimit < sc->sc_iobase || sc->sc_iobase == 0) {
			start = max(PCI_IO_START, pa->pa_ioex->ex_start);
			end = min(PCI_IO_END, pa->pa_ioex->ex_end);
			for (size = 0x2000; size >= PPB_IO_MIN; size >>= 1)
				if (extent_alloc_subregion(pa->pa_ioex, start,
				    end, size, size, 0, 0, 0, &base) == 0)
					break;
			if (size >= PPB_IO_MIN) {
				sc->sc_iobase = base;
				sc->sc_iolimit = base + size - 1;
				blr = pci_conf_read(pc, sc->sc_tag,
				    PPB_REG_IOSTATUS);
				blr &= 0xffff0000;
				blr |= sc->sc_iolimit & PPB_IO_MASK;
				blr |= (sc->sc_iobase >> PPB_IO_SHIFT);
				pci_conf_write(pc, sc->sc_tag,
				    PPB_REG_IOSTATUS, blr);
				blr = (sc->sc_iobase & 0xffff0000) >> 16;
				blr |= sc->sc_iolimit & 0xffff0000;
				pci_conf_write(pc, sc->sc_tag,
				    PPB_REG_IO_HI, blr);

				csr |= PCI_COMMAND_IO_ENABLE;
			}
		}
	}

	/* Allocate memory mapped I/O address space if necessary. */
	if (mem_count > 0 && pa->pa_memex) {
		blr = pci_conf_read(pc, sc->sc_tag, PPB_REG_MEM);
		sc->sc_membase = (blr << PPB_MEM_SHIFT) & PPB_MEM_MASK;
		sc->sc_memlimit = (blr & PPB_MEM_MASK) | 0x000fffff;
		if (sc->sc_memlimit < sc->sc_membase || sc->sc_membase == 0) {
			start = max(PCI_MEM_START, pa->pa_memex->ex_start);
			end = min(PCI_MEM_END, pa->pa_memex->ex_end);
			for (size = 0x2000000; size >= PPB_MEM_MIN; size >>= 1)
				if (extent_alloc_subregion(pa->pa_memex, start,
				    end, size, size, 0, 0, 0, &base) == 0)
					break;
			if (size >= PPB_MEM_MIN) {
				sc->sc_membase = base;
				sc->sc_memlimit = base + size - 1;
				blr = sc->sc_memlimit & PPB_MEM_MASK;
				blr |= (sc->sc_membase >> PPB_MEM_SHIFT);
				pci_conf_write(pc, sc->sc_tag,
				    PPB_REG_MEM, blr);

				csr |= PCI_COMMAND_MEM_ENABLE;
			}
		}
	}

	/* Enable bus master. */
	csr |= PCI_COMMAND_MASTER_ENABLE;

	pci_conf_write(pc, sc->sc_tag, PCI_COMMAND_STATUS_REG, csr);
}

int
ppb_intr(void *arg)
{
	struct ppb_softc *sc = arg;
	pcireg_t reg;

	/*
	 * XXX ignore hotplug events while in autoconf.  On some
	 * machines with onboard re(4), we get a bogus hotplug remove
	 * event when we reset that device.  Ignoring that event makes
	 * sure we will not try to forcibly detach re(4) when it isn't
	 * ready to deal with that.
	 */
	if (cold)
		return (0);

	reg = pci_conf_read(sc->sc_pc, sc->sc_tag,
	    sc->sc_cap_off + PCI_PCIE_SLCSR);
	if (reg & PCI_PCIE_SLCSR_PDC) {
		if (reg & PCI_PCIE_SLCSR_PDS)
			task_add(systq, &sc->sc_insert_task);
		else
			task_add(systq, &sc->sc_remove_task);

		/* Clear interrupts. */
		pci_conf_write(sc->sc_pc, sc->sc_tag,
		    sc->sc_cap_off + PCI_PCIE_SLCSR, reg);
		return (1);
	}

	return (0);
}

#ifdef PCI_MACHDEP_ENUMERATE_BUS
#define pci_enumerate_bus PCI_MACHDEP_ENUMERATE_BUS
#else
extern int pci_enumerate_bus(struct pci_softc *,
    int (*)(struct pci_attach_args *), struct pci_attach_args *);
#endif

void
ppb_hotplug_insert(void *xsc)
{
	struct ppb_softc *sc = xsc;
	struct pci_softc *psc = (struct pci_softc *)sc->sc_psc;

	if (!LIST_EMPTY(&psc->sc_devs))
		return;

	/* XXX Powerup the card. */

	/* XXX Turn on LEDs. */

	/* Wait a second for things to settle. */
	timeout_add_sec(&sc->sc_to, 1);
}

void
ppb_hotplug_insert_finish(void *arg)
{
	struct ppb_softc *sc = arg;

	task_add(systq, &sc->sc_rescan_task);
}

int
ppb_hotplug_fixup(struct pci_attach_args *pa)
{
	pcireg_t bhlcr;

	bhlcr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);
	switch (PCI_HDRTYPE_TYPE(bhlcr)) {
	case 0:
		return ppb_hotplug_fixup_type0(pa->pa_pc,
		    pa->pa_tag, *pa->pa_bridgetag);
	case 1:
		return ppb_hotplug_fixup_type1(pa->pa_pc,
		    pa->pa_tag, *pa->pa_bridgetag);
	default:
		return (0);
	}
}

int
ppb_hotplug_fixup_type0(pci_chipset_tag_t pc, pcitag_t tag, pcitag_t bridgetag)
{
	pcireg_t intr;
	int line;

	/*
	 * Fill in the interrupt line for platforms that need it.
	 *
	 * XXX We assume that the interrupt line matches the line used
	 * by the PCI Express bridge.  This may not be true.
	 */
	intr = pci_conf_read(pc, tag, PCI_INTERRUPT_REG);
	if (PCI_INTERRUPT_PIN(intr) != PCI_INTERRUPT_PIN_NONE &&
	    PCI_INTERRUPT_LINE(intr) == 0) {
		/* Get the interrupt line from our parent. */
		intr = pci_conf_read(pc, bridgetag, PCI_INTERRUPT_REG);
		line = PCI_INTERRUPT_LINE(intr);

		intr = pci_conf_read(pc, tag, PCI_INTERRUPT_REG);
		intr &= ~(PCI_INTERRUPT_LINE_MASK << PCI_INTERRUPT_LINE_SHIFT);
		intr |= line << PCI_INTERRUPT_LINE_SHIFT;
		pci_conf_write(pc, tag, PCI_INTERRUPT_REG, intr);
	}

	return (0);
}

int
ppb_hotplug_fixup_type1(pci_chipset_tag_t pc, pcitag_t tag, pcitag_t bridgetag)
{
	pcireg_t bhlcr, bir, csr, val;
	int bus, dev, reg;

	bir = pci_conf_read(pc, bridgetag, PPB_REG_BUSINFO);
	if (PPB_BUSINFO_SUBORDINATE(bir) <= PPB_BUSINFO_SECONDARY(bir))
		return (0);

	bus = PPB_BUSINFO_SECONDARY(bir);
	bir = pci_conf_read(pc, tag, PPB_REG_BUSINFO);
	bir &= (0xff << 24);
	bir |= bus++;
	bir |= (bus << 8);
	bir |= (bus << 16);
	pci_conf_write(pc, tag, PPB_REG_BUSINFO, bir);

	for (reg = PPB_REG_IOSTATUS; reg < PPB_REG_BRIDGECONTROL; reg += 4) {
		val = pci_conf_read(pc, bridgetag, reg);
		pci_conf_write(pc, tag, reg, val);
	}

	csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	csr |= PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE;
	csr |= PCI_COMMAND_MASTER_ENABLE;
	csr |= PCI_COMMAND_INVALIDATE_ENABLE;
	csr |= PCI_COMMAND_SERR_ENABLE;
	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, csr);

	for (dev = 0; dev < pci_bus_maxdevs(pc, bus); dev++) {
		tag = pci_make_tag(pc, bus, dev, 0);

		bhlcr = pci_conf_read(pc, tag, PCI_BHLC_REG);
		if (PCI_HDRTYPE_TYPE(bhlcr) != 0)
			continue;

		ppb_hotplug_fixup_type0(pc, tag, bridgetag);
	}

	return (0);
}

void
ppb_hotplug_rescan(void *xsc)
{
	struct ppb_softc *sc = xsc;
	struct pci_softc *psc = (struct pci_softc *)sc->sc_psc;

	if (psc) {
		/* Assign resources. */
		pci_enumerate_bus(psc, ppb_hotplug_fixup, NULL);

		/* Attach devices. */
		pci_enumerate_bus(psc, NULL, NULL);
	}
}

void
ppb_hotplug_remove(void *xsc)
{
	struct ppb_softc *sc = xsc;
	struct pci_softc *psc = (struct pci_softc *)sc->sc_psc;

	if (psc) {
		pci_detach_devices(psc, DETACH_FORCE);

		/*
		 * XXX Allocate the entire window with EX_CONFLICTOK
		 * such that we can easily free it.
		 */
		if (sc->sc_ioex != NULL) {
			extent_alloc_region(sc->sc_ioex, sc->sc_iobase,
			    sc->sc_iolimit - sc->sc_iobase + 1,
			    EX_NOWAIT | EX_CONFLICTOK);
			extent_free(sc->sc_ioex, sc->sc_iobase,
			    sc->sc_iolimit - sc->sc_iobase + 1, EX_NOWAIT);
		}

		if (sc->sc_memex != NULL) {
			extent_alloc_region(sc->sc_memex, sc->sc_membase,
			    sc->sc_memlimit - sc->sc_membase + 1,
			    EX_NOWAIT | EX_CONFLICTOK);
			extent_free(sc->sc_memex, sc->sc_membase,
			    sc->sc_memlimit - sc->sc_membase + 1, EX_NOWAIT);
		}

		if (sc->sc_pmemex != NULL) {
			extent_alloc_region(sc->sc_pmemex, sc->sc_pmembase,
			    sc->sc_pmemlimit - sc->sc_pmembase + 1,
			    EX_NOWAIT | EX_CONFLICTOK);
			extent_free(sc->sc_pmemex, sc->sc_pmembase,
			    sc->sc_pmemlimit - sc->sc_pmembase + 1, EX_NOWAIT);
		}
	}
}

int
ppbprint(void *aux, const char *pnp)
{
	struct pcibus_attach_args *pba = aux;

	/* only PCIs can attach to PPBs; easy. */
	if (pnp)
		printf("pci at %s", pnp);
	printf(" bus %d", pba->pba_bus);
	return (UNCONF);
}
@


1.64
log
@Properly restore the prefetchable memory window upon resume.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.63 2015/09/10 10:36:04 deraadt Exp $	*/
d69 1
d110 2
d157 1
d165 10
d192 13
d343 1
d369 6
d522 19
d586 2
d593 2
d692 3
@


1.63
log
@PPB_EXNAMLEN for the extent name; now easier to pass as a size for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.62 2015/03/14 03:38:48 jsg Exp $	*/
d432 1
a432 1
		blr |= (sc->sc_pmembase >> PPB_MEM_SHIFT);
@


1.62
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.61 2015/01/27 03:17:36 dlg Exp $	*/
d61 2
d247 1
a247 1
		name = malloc(32, M_DEVBUF, M_NOWAIT);
d249 1
a249 1
			snprintf(name, 32, "%s pciio", sc->sc_dev.dv_xname);
d262 1
a262 1
		name = malloc(32, M_DEVBUF, M_NOWAIT);
d264 1
a264 1
			snprintf(name, 32, "%s pcimem", sc->sc_dev.dv_xname);
d284 1
a284 1
		name = malloc(32, M_DEVBUF, M_NOWAIT);
d286 1
a286 1
			snprintf(name, 32, "%s pcipmem", sc->sc_dev.dv_xname);
d344 1
a344 1
		free(name, M_DEVBUF, 0);
d350 1
a350 1
		free(name, M_DEVBUF, 0);
d356 1
a356 1
		free(name, M_DEVBUF, 0);
@


1.61
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.60 2014/11/24 13:48:49 kettenis Exp $	*/
a35 1
#include <sys/kernel.h>
@


1.60
log
@Fix some issues with 64-bit BARs behind PCI-PCI bridges.
Actual BARs that have the upper 32-bits set seen in the wild now on a
SPARC T5-2 system.

Tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.59 2014/09/15 14:22:07 kettenis Exp $	*/
d110 1
a110 1
void	ppb_hotplug_insert(void *, void *);
d115 2
a116 2
void	ppb_hotplug_rescan(void *, void *);
void	ppb_hotplug_remove(void *, void *);
d180 3
a182 3
		task_set(&sc->sc_insert_task, ppb_hotplug_insert, sc, NULL);
		task_set(&sc->sc_rescan_task, ppb_hotplug_rescan, sc, NULL);
		task_set(&sc->sc_remove_task, ppb_hotplug_remove, sc, NULL);
d679 1
a679 1
ppb_hotplug_insert(void *arg1, void *arg2)
d681 1
a681 1
	struct ppb_softc *sc = arg1;
d793 1
a793 1
ppb_hotplug_rescan(void *arg1, void *arg2)
d795 1
a795 1
	struct ppb_softc *sc = arg1;
d808 1
a808 1
ppb_hotplug_remove(void *arg1, void *arg2)
d810 1
a810 1
	struct ppb_softc *sc = arg1;
@


1.59
log
@Add generic support for bridges that support subtractive decoding.
Fixes issues with pcmcia behind a ATI SB400 PCI bridge reported by Thierry
Deval.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.58 2014/07/12 18:48:52 tedu Exp $	*/
d264 1
a264 1
			sc->sc_memex = extent_create(name, 0, 0xffffffff,
d276 1
a276 1
#ifdef __LP64__	/* XXX because extents use long... */
@


1.58
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.57 2014/01/29 18:30:39 kettenis Exp $	*/
d149 1
d210 12
a221 3
	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_INTEL ||
	    (PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_INTEL_82801BA_HPB &&
	    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_INTEL_82801BAM_HPB))
d294 1
a294 8
	/*
	 * The Intel 82801BAM Hub-to-PCI can decode subtractively.
	 * XXX We probably should handle subtractive decode bridges
	 * in general.
	 */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801BA_HPB ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801BAM_HPB)) {
@


1.57
log
@Switch to task queues.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.56 2013/12/06 21:03:04 deraadt Exp $	*/
d340 1
a340 1
		free(name, M_DEVBUF);
d346 1
a346 1
		free(name, M_DEVBUF);
d352 1
a352 1
		free(name, M_DEVBUF);
@


1.56
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.55 2012/10/08 21:47:50 deraadt Exp $	*/
d38 1
a39 1
#include <sys/workq.h>
d73 3
d179 5
a203 2

			timeout_set(&sc->sc_to, ppb_hotplug_insert_finish, sc);
d655 1
a655 1
			workq_add_task(NULL, 0, ppb_hotplug_insert, sc, NULL);
d657 1
a657 1
			workq_add_task(NULL, 0, ppb_hotplug_remove, sc, NULL);
d695 3
a697 1
	workq_add_task(NULL, 0, ppb_hotplug_rescan, arg, NULL);
@


1.55
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.54 2012/09/07 19:26:48 kettenis Exp $	*/
a361 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
a389 13
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		
		if (pci_dopm) {	
			/*
			 * Place the bridge into the lowest possible
			 * power state.
			 */
			sc->sc_pmcsr_state = pci_get_powerstate(pc, tag);
			pci_set_powerstate(pc, tag,
			    pci_min_powerstate(pc, tag));
		}
		break;
d455 16
@


1.54
log
@Call pci_min_powerstate() to determine the lowest possible powerstate instead
of hardcoding it to D3.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.53 2011/10/31 21:44:54 mikeb Exp $	*/
d392 4
a395 1

@


1.53
log
@Save and restore MSI configuration on PCI-Express bridges during
the suspend/resume cycle the same way it's done in pci_suspend
and pci_resume.  Fixes high interrupt load caused by the unhandled
unmapped legacy ppb interrupts on resume.  Figured out the hard way
with lots of testing done by Alexander Polakov, thanks!
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.52 2011/06/26 23:00:28 deraadt Exp $	*/
d394 4
a397 1
			/* Place the bridge into D3. */
d399 2
a400 1
			pci_set_powerstate(pc, tag, PCI_PMCSR_STATE_D3);
@


1.52
log
@There are some problems with ppb msi interrupts.  For instance, i386 in
some situations can run out of vectors.  On amd64, there is at least one
machine that fails to resume.  Yes, those problems need to be fixed.  But
other problems should be found, too.  If we leave ppb msi off, we won't
learn anything new.  So use an #ifdef to enable ppb msi for non-i386,
temporarily.
Kind of discussed this with kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.50 2011/05/30 22:16:29 kettenis Exp $	*/
d85 4
d359 1
a359 1
	int rv = 0;
d378 15
d439 16
@


1.51
log
@Revert previous commit; it makes us run out of interrupt slots too fast on
amd64, and fixing things is going to take some time.

ok deraadt@@
@
text
@d172 1
d176 6
@


1.50
log
@Enable MSI.

tested by weerd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.49 2011/05/14 13:23:38 kettenis Exp $	*/
d172 1
a172 2
		if (pci_intr_map_msi(pa, &ih) == 0 ||
		    pci_intr_map(pa, &ih) == 0)
@


1.49
log
@Pass flags down the PCI bus hierarchy.  Soon to be used to selectively enable
Message Signalled Interrupts.

ok krw@@ with a fix pointed out by many
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.48 2011/04/18 04:18:36 deraadt Exp $	*/
d172 2
a173 1
		if (pci_intr_map(pa, &ih) == 0)
@


1.48
log
@since the pciide driver's interrupt handler can return -1 during hotplug
eject events, then the ppb's interrupt handler can be run at IPL_BIO.
This makes a huge difference on modern server with mpi/bge/bnx.
In snapshots for about 2 weeks now...
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.47 2010/12/30 00:58:22 kettenis Exp $	*/
d294 1
a297 3
#if 0
	pba.pba_flags = pa->pa_flags & ~PCI_FLAGS_MRM_OKAY;
#endif
@


1.47
log
@Only disable I/O and memory space and bus mastering if we're actually going
to put the device into D3.  Fixes PCI power management issues that prevented
acpi (and perhaps apm) suspend on some machines.

tested by & ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.46 2010/09/25 19:23:39 mlarkin Exp $	*/
d173 1
a173 1
			sc->sc_intrhand = pci_intr_establish(pc, ih, IPL_TTY,
@


1.46
log
@

ppb(4) should respect pci_dopm, like pci(4) does, and not try to poweroff
the bridge if pci_dopm=0.

Fixes Gateway LT3103u and Lenovo Thinkpad 100e netbooks, allowing them to
suspend again (if pci_dopm is set to 0 in acpi.c). Tested by myself and
deraadt on a variety of hardware.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.45 2010/08/31 17:13:44 deraadt Exp $	*/
d349 1
a349 1
	pcireg_t blr, csr, reg;
d370 1
a370 11
			/*
		 	 * Place the bridge into D3.  The PCI Power
			 * Management spec says we should disable I/O
			 * and memory space as well as bus mastering
			 * before we do so.
		 	 */
			csr = sc->sc_csr;
			csr &= ~PCI_COMMAND_IO_ENABLE;
			csr &= ~PCI_COMMAND_MEM_ENABLE;
			csr &= ~PCI_COMMAND_MASTER_ENABLE;
			pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, csr);
@


1.45
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.44 2010/08/17 19:14:52 kettenis Exp $	*/
d369 15
a383 12
		/*
		 * Place the bridge into D3.  The PCI Power Management
		 * spec says we should disable I/O and memory space as
		 * well as bus mastering before we do so.
		 */
		csr = sc->sc_csr;
		csr &= ~PCI_COMMAND_IO_ENABLE;
		csr &= ~PCI_COMMAND_MEM_ENABLE;
		csr &= ~PCI_COMMAND_MASTER_ENABLE;
		pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, csr);
		sc->sc_pmcsr_state = pci_get_powerstate(pc, tag);
		pci_set_powerstate(pc, tag, PCI_PMCSR_STATE_D3);
d386 4
a389 2
		/* Restore power. */
		pci_set_powerstate(pc, tag, sc->sc_pmcsr_state);
@


1.44
log
@Power management for PCI devices.  For now just put everything in the D3
(deepest sleep) state upon suspend, and restore power upon resume.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.43 2010/08/02 03:22:26 deraadt Exp $	*/
d353 3
@


1.43
log
@spellin
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.42 2010/06/30 05:14:39 kettenis Exp $	*/
a83 1

d85 1
d349 1
a349 1
	pcireg_t blr;
d365 13
d380 3
d422 3
a424 1
		pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, sc->sc_csr);
@


1.42
log
@If the device has the PCI Express capability, save the slot control and status
register upon suspend and restore it upon resume.  Makes ExpressCard
hotplug work on my Dell after a suspend/resume cycle.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.41 2010/04/06 22:28:07 tedu Exp $	*/
d574 1
a574 1
	 * machines with onboard re(4), we gat a bogus hotplug remove
@


1.41
log
@update a random sampling of drivers after the proc.h -> systm.h move
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.40 2009/12/27 20:03:52 kettenis Exp $	*/
d84 2
d362 3
d372 3
@


1.40
log
@Don't allocate resources on the Intel Hub-to-PCI bridges.  Doing so breaks
some machines (in particular the IBM eServer x206).  And since the bridge is
subtractively decoding the PCI address space anyway, we shouldn't need to
allocate any resources.  Make sure we treat the mobile version of the bridge
the same as the non-mobile version.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.39 2009/11/24 00:52:07 kettenis Exp $	*/
d38 1
a38 1
#include <sys/proc.h>
@


1.39
log
@Save state on suspend and restore that state and the bridge windows on resume
such that devices behind bridges get a chance to work after resume.

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.38 2009/11/23 22:49:58 deraadt Exp $	*/
d46 16
d190 4
a193 1
	ppb_alloc_resources(sc, pa);
d271 2
a272 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801BAM_HPB) {
d417 1
d504 2
d507 2
a508 2
				if (extent_alloc(pa->pa_ioex, size, size,
				    0, 0, 0, &base) == 0)
d536 2
d539 2
a540 2
				if (extent_alloc(pa->pa_memex, size, size,
				    0, 0, 0, &base) == 0)
@


1.38
log
@must return result of config_activate_children
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.37 2009/11/23 16:53:55 deraadt Exp $	*/
d62 6
d324 4
d333 7
a339 1
		/* XXX should power down the ppb */
d342 38
a379 1
		/* XXX should power up the ppb */
@


1.37
log
@Later on this will do much more work on suspend/resume, but for now
it must call it's children.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.36 2009/11/19 20:46:16 kettenis Exp $	*/
d322 1
a322 1
		config_activate_children(self, act);
d327 1
a327 1
		config_activate_children(self, act);
@


1.36
log
@Add code to set up windows on PCI-PCI bridges left unconfigured by the
firmware.  Fixes some (laptop) machines with ethernet and/or wiireless
behind a bridge.  Some help from miod@@.  Tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.35 2009/09/24 21:26:25 miod Exp $	*/
d67 1
d70 1
a70 1
	sizeof(struct ppb_softc), ppbmatch, ppbattach, ppbdetach
d312 18
@


1.35
log
@Handle the upper 32 bits of the prefetchable memory range when setting up
the ppb resource extents, on LP64 systems. Found the hard way on an alpha.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.34 2009/05/30 18:46:06 jsg Exp $	*/
d76 1
d167 2
d312 147
@


1.34
log
@Check the extents exist before trying to do things
with them in ppb_hotplug_remove().
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.33 2009/05/15 21:51:58 kettenis Exp $	*/
d218 6
d228 1
a228 1
			sc->sc_pmemex = extent_create(name, 0, 0xffffffff,
@


1.33
log
@On the Intel 82801BAM Hub-to-PCI, pass the main PCI io and mmio extents if
there are no windows enabled.  Restores CardBus functionality on some
machines with Intel chipsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.32 2009/05/05 14:16:17 kettenis Exp $	*/
d485 23
a507 17
		extent_alloc_region(sc->sc_ioex, sc->sc_iobase,
		    sc->sc_iolimit - sc->sc_iobase + 1,
		    EX_NOWAIT | EX_CONFLICTOK);
		extent_free(sc->sc_ioex, sc->sc_iobase,
		    sc->sc_iolimit - sc->sc_iobase + 1, EX_NOWAIT);

		extent_alloc_region(sc->sc_memex, sc->sc_membase,
		    sc->sc_memlimit - sc->sc_membase + 1,
		    EX_NOWAIT | EX_CONFLICTOK);
		extent_free(sc->sc_memex, sc->sc_membase,
		    sc->sc_memlimit - sc->sc_membase + 1, EX_NOWAIT);

		extent_alloc_region(sc->sc_pmemex, sc->sc_pmembase,
		    sc->sc_pmemlimit - sc->sc_pmembase + 1,
		    EX_NOWAIT | EX_CONFLICTOK);
		extent_free(sc->sc_pmemex, sc->sc_pmembase,
		    sc->sc_pmemlimit - sc->sc_pmembase + 1, EX_NOWAIT);
@


1.32
log
@Add extents for prefetchable memory mapped I/O.  Should remove conflict
messages for devices using prefetchable memory sitting behind bridges.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.31 2009/04/24 20:03:55 kettenis Exp $	*/
d228 13
@


1.31
log
@Fix two issues with resource accounting:
1. Simba, the UltraSPARC-IIi Advanced PCI Bridge doesn't support the standard
   address range registers.  Skip resource accounting on these devices for now.
2. Some machines (for example sparc64) actually implement a 32-bit I/O space,
   so start parsing the registers that gives us the upper 16 bits and make
   sure the extent covers the entire 32-bit address range.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.30 2009/04/22 20:45:57 kettenis Exp $	*/
d54 1
d61 1
d214 16
d245 1
d283 6
d483 6
@


1.30
log
@Start doing resource accounting on non-root PCI busses by populating the
extents based on address range forwarded by the bridge as indicated by
the limit registers.  Remove the now redundant BAR initialization code
for type 0 devices.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.29 2009/04/01 19:51:10 kettenis Exp $	*/
d170 8
d182 3
d189 1
a189 1
			sc->sc_ioex = extent_create(name, 0, 0xffff,
d212 1
@


1.29
log
@bzero pci attach args
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.28 2008/12/28 23:08:06 kettenis Exp $	*/
d52 2
d57 3
d115 2
a116 1
	pcireg_t busdata, reg;
d170 31
d213 2
d232 2
d238 15
a252 1
	return config_detach_children(self, flags);
d339 2
a340 67
	pcireg_t blr, type, intr;
	int reg, line;
	bus_addr_t base, io_base, io_limit, mem_base, mem_limit;
	bus_size_t size, io_size, mem_size;

	/*
	 * The code below assumes that the address ranges on our
	 * parent PCI Express bridge are really available and don't
	 * overlap with other devices in the system.
	 */

	/* Figure out the I/O address range of the bridge. */
	blr = pci_conf_read(pc, bridgetag, PPB_REG_IOSTATUS);
	io_base = (blr & 0x000000f0) << 8;
	io_limit = (blr & 0x000f000) | 0x00000fff;
	if (io_limit > io_base)
		io_size = (io_limit - io_base + 1);
	else
		io_size = 0;

	/* Figure out the memory mapped I/O address range of the bridge. */
	blr = pci_conf_read(pc, bridgetag, PPB_REG_MEM);
	mem_base = (blr & 0x0000fff0) << 16;
	mem_limit = (blr & 0xffff0000) | 0x000fffff;
	if (mem_limit > mem_base)
		mem_size = (mem_limit - mem_base + 1);
	else
		mem_size = 0;

	/* Assign resources to the Base Address Registers. */
	for (reg = PCI_MAPREG_START; reg < PCI_MAPREG_END; reg += 4) {
		if (!pci_mapreg_probe(pc, tag, reg, &type))
			continue;

		if (pci_mapreg_info(pc, tag, reg, type, &base, &size, NULL))
			continue;

		if (base != 0)
			continue;

		switch (type) {
		case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
		case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
			base = roundup(mem_base, size);
			size += base - mem_base;
			if (size > mem_size)
				continue;
			pci_conf_write(pc, tag, reg, base);
			mem_base += size;
			mem_size -= size;
			break;
		case PCI_MAPREG_TYPE_IO:
			base = roundup(io_base, size);
			size += base - io_base;
			if (size > io_size)
				continue;
			pci_conf_write(pc, tag, reg, base);
			io_base += size;
			io_size -= size;
			break;
		default:
			break;
		}

		if (type & PCI_MAPREG_MEM_TYPE_64BIT)
			reg += 4;
	}
d428 1
a428 1
	if (psc)
d430 17
@


1.28
log
@Ignore hotploug events while still in autoconf.  Fixes problems with some
machines that get a spurious hotplug reove event when resetting their
onboard re(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.27 2008/09/10 14:01:23 blambert Exp $	*/
d170 1
@


1.27
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.26 2007/12/31 19:13:36 kettenis Exp $	*/
d204 10
@


1.26
log
@On some machines we get hotplug interrupts when they're resumed, so don't
rescan the pci bus if it already has devices attached to it.  Make sure we
clear the list of attached devices when we receive a surprise removal
interrupt.  Fixes kurt@@'s T43.

ok miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.25 2007/12/04 17:33:13 kettenis Exp $	*/
d243 1
a243 1
	timeout_add(&sc->sc_to, 1 * hz);
@


1.25
log
@Some ExpressCard cards have old PCI devices and a PCIe-PCI bridge.
In that case, configure the bridge and all devices behind it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.24 2007/11/30 16:21:38 kettenis Exp $	*/
d233 4
d425 1
d427 2
a428 2
	if (sc->sc_psc)
		config_detach_children(sc->sc_psc, DETACH_FORCE);
@


1.24
log
@Disestablish interrupts upon detach,
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.23 2007/11/30 15:54:12 kettenis Exp $	*/
d73 2
d251 19
a269 4
	pci_chipset_tag_t pc = pa->pa_pc;
	pcitag_t tag = pa->pa_tag;
	pcitag_t bridgetag = *pa->pa_bridgetag;
	pcireg_t bhlcr, blr, type, intr;
a273 4
	bhlcr = pci_conf_read(pc, tag, PCI_BHLC_REG);
	if (PCI_HDRTYPE_TYPE(bhlcr) != 0)
		return (0);

d343 3
a345 1
	if (pa->pa_intrpin != PCI_INTERRUPT_PIN_NONE && pa->pa_intrline == 0) {
d354 43
@


1.23
log
@Make ppb(4) detachable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.22 2007/11/25 16:42:21 kettenis Exp $	*/
d51 1
d103 1
a103 1
	struct ppb_softc *sc = (void *) self;
d136 5
a140 3
		if (pci_intr_map(pa, &ih) == 0 &&
		    pci_intr_establish(pc, ih, IPL_TTY, ppb_intr, sc,
		    self->dv_xname)) {
d189 5
@


1.22
log
@When plugging a device, assign BARs and set interrupt lines.
Makes ExpresCard hotplugging fully functional at least on laptops with an
Intel chipset.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.21 2007/11/25 10:52:09 kettenis Exp $	*/
d58 1
d61 1
a61 1
	sizeof(struct ppb_softc), ppbmatch, ppbattach
d181 6
@


1.21
log
@Map the interrupt pins used for swizzling *after* mapping the PCI Express
hotplug interrupt such that we don't thrash the information necessary to do
that.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.20 2007/11/24 21:33:58 kettenis Exp $	*/
d70 1
d231 98
d333 1
d335 7
a341 2
	if (sc->sc_psc)
		pci_enumerate_bus((struct pci_softc *)sc->sc_psc, NULL, NULL);
@


1.20
log
@First step towards PCI Express/ExpressCard hotplug.  Unplug should work on
detachable drivers.

"put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.19 2007/05/21 22:10:45 kettenis Exp $	*/
a117 6
	for (pin = PCI_INTERRUPT_PIN_A; pin <= PCI_INTERRUPT_PIN_D; pin++) {
		pa->pa_intrpin = pa->pa_rawintrpin = pin;
		pa->pa_intrline = 0;
		pci_intr_map(pa, &sc->sc_ih[pin - PCI_INTERRUPT_PIN_A]);
	}

d150 6
@


1.19
log
@Implement deep interrupt swizzling by mapping all four PCI interrupt pins
for PCI-PCI bridges and passing the mapping to the attached bus device.
MD code can use these when mapping PCI device interrupts.  This diff adds
such code for amd64 and i386.  This fixes interrupt mapping for devices that
sit behind two PCI-PCI bridges where the firmware only provides a mapping
for the first PCI-PCI bridge.

tested by sturm@@, krw@@, and a few others, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.18 2007/02/13 18:35:32 tom Exp $	*/
d38 2
d51 3
d67 5
d104 2
a105 1
	pcireg_t busdata;
a107 2
	printf("\n");

d114 1
a114 2
		printf("%s: not configured by system firmware\n",
		    self->dv_xname);
d136 21
d178 68
a245 1
	config_found(self, &pba, ppbprint);
@


1.18
log
@Fix typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.17 2006/12/14 17:36:12 kettenis Exp $	*/
d48 1
d95 1
d110 6
d144 1
@


1.17
log
@Make pci subsystem aware of domains.  Each host bridge gets assigned a unique
domain number such that we can distinguish between busses with the same bus
number that are behind different host bridges.  Domains can be accessed by
using different device nodes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.16 2006/07/04 18:26:30 kettenis Exp $	*/
d121 1
a121 1
	 * Attach the PCI bus than hangs off of it.
@


1.16
log
@Back out the workaround committed in rev 1.13 now that we no longer blindly
enable io and mem space on all matched PCI devices.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.15 2006/03/19 21:57:55 brad Exp $	*/
d134 1
@


1.15
log
@ANSI and fix comments
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.14 2006/03/13 20:10:49 brad Exp $	*/
d69 1
a69 1
	 * These devices are mislabeled.  They are not PCI bridges.
d71 2
a72 5
	if ((PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VIATECH &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VT82C586_PWR) ||
	    (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ATI && 
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ATI_RS480_PCIE_2 ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ATI_RS480_PCIE_3)))
@


1.14
log
@* Add "pcitag_t *pba_bridgetag" to pci_attach_args.  This is set to
  NULL for root PCI busses.  For busses behind a bridge, it points to
  a persistent copy of the bridge's pcitag_t.  This can be very useful
  for machine-dependent PCI bus enumeration code.

From NetBSD

ok grange@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.13 2006/02/27 02:05:19 drahn Exp $	*/
a33 9
/*
 * XXX NOTE:
 * XXX PROPER OPERATION OF DEVICES BEHIND PPB'S WHICH USE INTERRUPTS
 * XXX ON SYSTEMS OTHER THAN THE i386 IS NOT POSSIBLE AT THIS TIME.
 * XXX There needs to be some support for 'swizzling' the interrupt
 * XXX pin.  In general, pci_intr_map() has to have a different
 * XXX interface.
 */

d64 1
a64 3
ppbmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d90 1
a90 3
ppbattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d125 3
d134 3
d146 1
a146 3
ppbprint(aux, pnp)
	void *aux;
	const char *pnp;
@


1.13
log
@Workaround for bridge attachment where nothing lives behind these 'rare'
bridges and attaching them causes the machine to hang.
A better fix needs to be found after release.
ok brad@@ kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.12 2005/12/05 14:39:23 mickey Exp $	*/
d53 6
d63 1
a63 1
	sizeof(struct device), ppbmatch, ppbattach
d105 1
d113 3
d145 1
@


1.12
log
@fix func name in the comments
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.11 2002/03/14 01:26:59 millert Exp $	*/
d74 1
a74 1
	 * This device is mislabeled.  It is not a PCI bridge.
d76 5
a80 2
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VIATECH &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VT82C586_PWR)
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.10 2000/01/15 08:16:24 deraadt Exp $	*/
d39 1
a39 1
 * XXX pin.  In general, pci_map_int() has to have a different
@


1.10
log
@special case one mislabeled device which is not a pci bridge at all
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.9 1998/03/10 08:40:39 deraadt Exp $	*/
d53 2
a54 2
int	ppbmatch __P((struct device *, void *, void *));
void	ppbattach __P((struct device *, struct device *, void *));
d64 1
a64 1
int	ppbprint __P((void *, const char *pnp));
@


1.10.12.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.10 2000/01/15 08:16:24 deraadt Exp $	*/
d53 2
a54 2
int	ppbmatch(struct device *, void *, void *);
void	ppbattach(struct device *, struct device *, void *);
d64 1
a64 1
int	ppbprint(void *, const char *pnp);
@


1.10.2.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 2
a54 2
int	ppbmatch(struct device *, void *, void *);
void	ppbattach(struct device *, struct device *, void *);
d64 1
a64 1
int	ppbprint(void *, const char *pnp);
@


1.9
log
@not yet
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.7 1998/01/20 18:40:36 niklas Exp $	*/
d73 6
@


1.8
log
@propogate pci flags
@
text
@a124 1
	pba.pba_flags = pa->pa_flags;
@


1.7
log
@Merge bus_dma support from NetBSD, mostly by Jason Thorpe.  Only i386 uses it
 so far, the other archs gets placeholders for now.  I wrote a compatibility
layer for OpenBSD's old isadma code so we can still use our old
driver sources.  They will however get changed to native bus_dma use,
on a case by case basis.   Oh yes, I almost forgot, I kept our notion
of isadma being a device so DMA-less ISA-busses still work
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.6 1998/01/05 13:35:26 deraadt Exp $	*/
d125 1
@


1.6
log
@new style pci attach printing
@
text
@d1 2
a2 2
/*	$OpenBSD: ppb.c,v 1.5 1996/11/28 23:28:14 niklas Exp $	*/
/*	$NetBSD: ppb.c,v 1.12 1996/10/21 22:57:00 thorpej Exp $	*/
d123 1
@


1.5
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ppb.c,v 1.4 1996/11/23 21:47:06 kstailey Exp $	*/
a93 1
	char devinfo[256];
d95 1
a95 2
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
	printf(": %s (rev. 0x%02x)\n", devinfo, PCI_REVISION(pa->pa_class));
@


1.4
log
@added const to second parameter of cfprint_t routines
@
text
@d1 2
a2 2
/*	$OpenBSD: ppb.c,v 1.2 1996/04/21 22:25:53 deraadt Exp $	*/
/*	$NetBSD: ppb.c,v 1.8 1996/05/03 17:33:51 christos Exp $	*/
d123 2
a124 1
	pba.pba_bc = pa->pa_bc;
@


1.3
log
@sync with 0504 -- prototypes and bus.h
@
text
@d64 1
a64 1
int	ppbprint __P((void *, char *pnp));
d135 1
a135 1
	char *pnp;
@


1.2
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: ppb.c,v 1.1 1996/04/18 23:48:09 niklas Exp $	*/
/*	$NetBSD: ppb.c,v 1.7 1996/03/27 04:08:34 cgd Exp $	*/
a70 1
	struct cfdata *cf = match;
@


1.1
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ppb.c,v 1.4 1996/03/14 04:03:03 cgd Exp $	*/
d56 2
a57 2
struct cfdriver ppbcd = {
	NULL, "ppb", ppbmatch, ppbattach, DV_DULL, sizeof(struct device)
d60 5
a64 1
static int	ppbprint __P((void *, char *pnp));
d92 1
d94 1
a94 1
	pcireg_t data;
d100 1
a100 1
	data = pci_conf_read(pa->pa_tag, PPB_REG_BUSINFO);
d102 1
a102 1
	if (PPB_BUSINFO_SECONDARY(data) == 0) {
d111 2
a112 1
	 * (we shouldn't need it) and we can't decompose our tag.
a113 1

d115 1
a115 1
	if (pa->pa_bus != PPB_BUSINFO_PRIMARY(data))
d117 1
a117 1
		    pa->pa_bus, PPB_BUSINFO_PRIMARY(data));
d124 5
a128 1
	pba.pba_bus = PPB_BUSINFO_SECONDARY(data);
d133 1
a133 1
static int
d144 1
a144 1
        return (UNCONF);
@

