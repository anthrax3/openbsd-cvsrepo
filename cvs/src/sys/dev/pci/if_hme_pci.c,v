head	1.21;
access;
symbols
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.6
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.4
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.16
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.12.0.8
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.6
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.8.0.12
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.10
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.8
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.6
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.4.0.2
	UBC_BASE:1.4
	SMP:1.3.0.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.21
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.20;
commitid	5gdEnqVoJuTuwdTu;

1.20
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.19;
commitid	p4LJxGKbi0BU2cG6;

1.19
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.18;
commitid	yM2VFFhpDTeFQlve;

1.18
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.17;
commitid	TGHgrLxu6sxZoiFt;

1.17
date	2013.08.07.01.06.35;	author bluhm;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.15.17.54.56;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.28.16.50.02;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.28.11.32.37;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.21.22.13.36;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.15.14.46.13;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.27.03.43.30;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.21.22.10.56;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.14.21.05.12;	author henric;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.10.22.31.01;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.13.21.02.54;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.14.01.25.29;	author drahn;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.08.25.10.13.29;	author art;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.08.23.03.44.46;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.22.21.49.39;	author jason;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.21
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_hme_pci.c,v 1.20 2015/03/14 03:38:48 jsg Exp $	*/
/*	$NetBSD: if_hme_pci.c,v 1.3 2000/12/28 22:59:13 sommerfeld Exp $	*/

/*
 * Copyright (c) 2000 Matthew R. Green
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * PCI front-end device driver for the HME ethernet device.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/mii/miivar.h>

#ifdef __sparc64__
#include <machine/autoconf.h>
#include <dev/ofw/openfirm.h>
#endif
#include <machine/cpu.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <dev/ic/hmevar.h>

struct hme_pci_softc {
	struct	hme_softc	hsc_hme;	/* HME device */
	bus_space_tag_t		hsc_memt;
	bus_space_handle_t	hsc_memh;
	bus_size_t		hsc_memsize;
	void			*hsc_ih;
	pci_chipset_tag_t	hsc_pc;
};

int	hmematch_pci(struct device *, void *, void *);
void	hmeattach_pci(struct device *, struct device *, void *);
int	hmedetach_pci(struct device *, int);
int	hme_pci_enaddr(struct hme_softc *, struct pci_attach_args *);

struct cfattach hme_pci_ca = {
	sizeof(struct hme_pci_softc), hmematch_pci, hmeattach_pci, hmedetach_pci
};

int
hmematch_pci(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void *aux;
{
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SUN && 
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SUN_HME)
		return (1);

	return (0);
}

#define	PCI_EBUS2_BOOTROM	0x10
#define	PCI_EBUS2_BOOTROM_SIZE	0x20000
#define	PROMHDR_PTR_DATA	0x18
#define	PROMDATA_PTR_VPD	0x08
#define	PROMDATA_LENGTH		0x0a
#define	PROMDATA_REVISION	0x0c
#define	PROMDATA_SUBCLASS	0x0e
#define	PROMDATA_CLASS		0x0f

static const u_int8_t hme_promhdr[] = { 0x55, 0xaa };
static const u_int8_t hme_promdat[] = {
	'P', 'C', 'I', 'R',
	PCI_VENDOR_SUN & 0xff, PCI_VENDOR_SUN >> 8,
	PCI_PRODUCT_SUN_HME & 0xff, PCI_PRODUCT_SUN_HME >> 8
};

int
hme_pci_enaddr(struct hme_softc *sc, struct pci_attach_args *hpa)
{
	struct pci_attach_args epa;
	struct pci_vpd *vpd;
	pcireg_t cl, id;
	bus_space_handle_t romh;
	bus_space_tag_t romt;
	bus_size_t romsize = 0;
	u_int8_t buf[32];
	int dataoff, vpdoff, length;

	/*
	 * Dig out VPD (vital product data) and acquire Ethernet address.
	 * The VPD of hme resides in the Boot PROM (PCI FCode) attached
	 * to the EBus interface.
	 * ``Writing FCode 3.x Programs'' (newer ones, dated 1997 and later)
	 * chapter 2 describes the data structure.
	 */

	/* get a PCI tag for the EBus bridge (function 0 of the same device) */
	epa = *hpa;
	epa.pa_tag = pci_make_tag(hpa->pa_pc, hpa->pa_bus, hpa->pa_device, 0);
	cl = pci_conf_read(epa.pa_pc, epa.pa_tag, PCI_CLASS_REG);
	id = pci_conf_read(epa.pa_pc, epa.pa_tag, PCI_ID_REG);

	if (PCI_CLASS(cl) != PCI_CLASS_BRIDGE ||
	    PCI_PRODUCT(id) != PCI_PRODUCT_SUN_EBUS)
		goto fail;

	if (pci_mapreg_map(&epa, PCI_EBUS2_BOOTROM, PCI_MAPREG_TYPE_MEM, 0,
	    &romt, &romh, 0, &romsize, PCI_EBUS2_BOOTROM_SIZE))
		goto fail;

	bus_space_read_region_1(romt, romh, 0, buf, sizeof(buf));
	if (bcmp(buf, hme_promhdr, sizeof(hme_promhdr)))
		goto fail;

	dataoff = buf[PROMHDR_PTR_DATA] | (buf[PROMHDR_PTR_DATA + 1] << 8);
	if (dataoff < 0x1c)
		goto fail;

	bus_space_read_region_1(romt, romh, dataoff, buf, sizeof(buf));
	if (bcmp(buf, hme_promdat, sizeof(hme_promdat)))
		goto fail;

	/*
	 * Don't check the interface part of the class code, since
	 * some cards have a bogus value there.
	 */
	length = buf[PROMDATA_LENGTH] | (buf[PROMDATA_LENGTH + 1] << 8);
	if (length != 0x18 || buf[PROMDATA_REVISION] != 0x00 ||
	    buf[PROMDATA_SUBCLASS] != PCI_SUBCLASS_NETWORK_ETHERNET ||
	    buf[PROMDATA_CLASS] != PCI_CLASS_NETWORK)
		goto fail;

	vpdoff = buf[PROMDATA_PTR_VPD] | (buf[PROMDATA_PTR_VPD + 1] << 8);
	if (vpdoff < 0x1c)
		goto fail;

	/*
	 * The VPD of hme is not in PCI 2.2 standard format.  The length
	 * in the resource header is in big endian, and resources are not
	 * properly terminated (only one resource and no end tag).
	 */
	bus_space_read_region_1(romt, romh, vpdoff, buf, sizeof(buf));

	/* XXX TODO: Get the data from VPD */
	vpd = (struct pci_vpd *)(buf + 3);
	if (!PCI_VPDRES_ISLARGE(buf[0]) ||
	    PCI_VPDRES_LARGE_NAME(buf[0]) != PCI_VPDRES_TYPE_VPD)
		goto fail;
	if (vpd->vpd_key0 != 'N' || vpd->vpd_key1 != 'A')
		goto fail;

	bcopy(buf + 6, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
	sc->sc_arpcom.ac_enaddr[5] += hpa->pa_device;
	bus_space_unmap(romt, romh, romsize);
	return (0);

fail:
	if (romsize != 0)
		bus_space_unmap(romt, romh, romsize);
	return (-1);
}

void
hmeattach_pci(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pci_attach_args *pa = aux;
	struct hme_pci_softc *hsc = (void *)self;
	struct hme_softc *sc = &hsc->hsc_hme;
	pci_intr_handle_t ih;
	/* XXX the following declarations should be elsewhere */
	extern void myetheraddr(u_char *);
	pcireg_t csr;
	const char *intrstr = NULL;
	int type, gotenaddr = 0;

	hsc->hsc_pc = pa->pa_pc;

	/*
	 * enable io/memory-space accesses.  this is kinda of gross; but
	 * the hme comes up with neither IO space enabled, or memory space.
	 */
	if (pa->pa_memt)
		pa->pa_flags |= PCI_FLAGS_MEM_ENABLED;
	if (pa->pa_iot)
		pa->pa_flags |= PCI_FLAGS_IO_ENABLED;
	csr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	if (pa->pa_memt) {
		type = PCI_MAPREG_TYPE_MEM;
		csr |= PCI_COMMAND_MEM_ENABLE;
		sc->sc_bustag = pa->pa_memt;
	} else {
		type = PCI_MAPREG_TYPE_IO;
		csr |= PCI_COMMAND_IO_ENABLE;
		sc->sc_bustag = pa->pa_iot;
	}
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    csr | PCI_COMMAND_MEM_ENABLE);

	sc->sc_dmatag = pa->pa_dmat;

	sc->sc_pci = 1; /* XXXXX should all be done in bus_dma. */
	/*
	 * Map five register banks:
	 *
	 *	bank 0: HME SEB registers:	+0x0000
	 *	bank 1: HME ETX registers:	+0x2000
	 *	bank 2: HME ERX registers:	+0x4000
	 *	bank 3: HME MAC registers:	+0x6000
	 *	bank 4: HME MIF registers:	+0x7000
	 *
	 */

#define PCI_HME_BASEADDR	0x10
	if (pci_mapreg_map(pa, PCI_HME_BASEADDR, type, 0,
	    &hsc->hsc_memt, &hsc->hsc_memh, NULL, &hsc->hsc_memsize, 0) != 0) {
		printf(": can't map registers\n");
		return;
	}
	sc->sc_seb = hsc->hsc_memh;
	bus_space_subregion(sc->sc_bustag, hsc->hsc_memh, 0x2000, 0x2000,
	    &sc->sc_etx);
	bus_space_subregion(sc->sc_bustag, hsc->hsc_memh, 0x4000, 0x2000,
	    &sc->sc_erx);
	bus_space_subregion(sc->sc_bustag, hsc->hsc_memh, 0x6000, 0x1000,
	    &sc->sc_mac);
	bus_space_subregion(sc->sc_bustag, hsc->hsc_memh, 0x7000, 0x1000,
	    &sc->sc_mif);

	if (hme_pci_enaddr(sc, pa) == 0)
		gotenaddr = 1;

#ifdef __sparc64__
	if (!gotenaddr) {
		if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
		    sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN) <= 0)
			myetheraddr(sc->sc_arpcom.ac_enaddr);
		gotenaddr = 1;
	}
#endif
#ifdef __powerpc__
	if (!gotenaddr) {
		pci_ether_hw_addr(pa->pa_pc, sc->sc_arpcom.ac_enaddr);
		gotenaddr = 1;
	}
#endif

	sc->sc_burst = 16;	/* XXX */

	if (pci_intr_map(pa, &ih) != 0) {
		printf(": couldn't map interrupt\n");
		bus_space_unmap(hsc->hsc_memt, hsc->hsc_memh, hsc->hsc_memsize);
		return;
	}	
	intrstr = pci_intr_string(pa->pa_pc, ih);
	hsc->hsc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_NET,
	    hme_intr, sc, self->dv_xname);
	if (hsc->hsc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(hsc->hsc_memt, hsc->hsc_memh, hsc->hsc_memsize);
		return;
	}

	printf(": %s", intrstr);

	/*
	 * call the main configure
	 */
	hme_config(sc);
}

int
hmedetach_pci(struct device *self, int flags)
{
	struct hme_pci_softc *hsc = (void *)self;
	struct hme_softc *sc = &hsc->hsc_hme;

	timeout_del(&sc->sc_tick_ch);
	pci_intr_disestablish(hsc->hsc_pc, hsc->hsc_ih);

	hme_unconfig(sc);
	bus_space_unmap(hsc->hsc_memt, hsc->hsc_memh, hsc->hsc_memsize);
	return (0);
}
@


1.20
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.19 2014/12/22 02:28:52 tedu Exp $	*/
a43 1
#include <net/if_dl.h>
@


1.19
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.18 2014/07/22 13:12:11 mpi Exp $	*/
a49 1
#include <dev/mii/mii.h>
@


1.18
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.17 2013/08/07 01:06:35 bluhm Exp $	*/
a46 1
#ifdef INET
a48 1
#endif
@


1.17
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.16 2009/10/15 17:54:56 deraadt Exp $	*/
a48 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.16
log
@Add detach support to a few more drivers, and in others do the neccessary
operations in the detach function in the right order.  Also ensure that the
interrupt handlers not trust registers that go away.
read over very carefully by dms, tested by me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.15 2009/03/29 21:53:52 sthen Exp $	*/
a49 1
#include <netinet/in_var.h>
@


1.15
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.14 2009/01/28 16:50:02 kettenis Exp $	*/
d74 1
d76 1
d81 1
d85 1
a85 1
	sizeof(struct hme_pci_softc), hmematch_pci, hmeattach_pci
a217 1
	bus_size_t size;
d220 2
d259 1
a259 1
	    &hsc->hsc_memt, &hsc->hsc_memh, NULL, &size, 0) != 0) {
d295 1
a295 1
		bus_space_unmap(hsc->hsc_memt, hsc->hsc_memh, size);
d306 1
a306 1
		bus_space_unmap(hsc->hsc_memt, hsc->hsc_memh, size);
d316 14
@


1.14
log
@Be a little more tolerant about matching ROMs.  Makes todd@@'s quad hme(4) get
proper MAC addresses even if you plug it into an i386 machine.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.13 2009/01/28 11:32:37 kettenis Exp $	*/
d256 1
a256 1
		printf(": could not map hme registers\n");
@


1.13
log
@Don't map the full 16 MB PROM to prevent running out of kva.  We're only
interested in the first few KB.

ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.12 2006/12/21 22:13:36 jason Exp $	*/
d104 4
a107 1
#define	PROMDATA_DATA2		0x0a
a114 7
static const u_int8_t hme_promdat2[] = {
	0x18, 0x00,			/* structure length */
	0x00,				/* structure revision */
	0x00,				/* interface revision */
	PCI_SUBCLASS_NETWORK_ETHERNET,	/* subclass code */
	PCI_CLASS_NETWORK		/* class code */
};
d126 1
a126 1
	int dataoff, vpdoff;
d159 11
a169 2
	if (bcmp(buf, hme_promdat, sizeof(hme_promdat)) ||
	    bcmp(buf + PROMDATA_DATA2, hme_promdat2, sizeof(hme_promdat2)))
@


1.12
log
@betetr yet, just nuke sc_enaddr all together, just fill in arpcom and
everybody is happy
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.11 2006/10/15 14:46:13 kettenis Exp $	*/
d101 1
d151 1
a151 1
	    &romt, &romh, 0, &romsize, 0))
@


1.11
log
@Fix indentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.10 2005/10/27 03:43:30 brad Exp $	*/
d185 2
a186 2
	bcopy(buf + 6, sc->sc_enaddr, ETHER_ADDR_LEN);
	sc->sc_enaddr[5] += hpa->pa_device;
d269 2
a270 2
		    sc->sc_enaddr, ETHER_ADDR_LEN) <= 0)
			myetheraddr(sc->sc_enaddr);
d276 1
a276 1
		pci_ether_hw_addr(pa->pa_pc, sc->sc_enaddr);
@


1.10
log
@- __sparc__ -> __sparc64__
- unmap resources allocated by pci_mapreg_map() on failure to attach
- fixup PCI interrupt string printing and surrounding code to be more
  consistent with other drivers
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.9 2005/10/21 22:10:56 brad Exp $	*/
d270 1
a270 1
		myetheraddr(sc->sc_enaddr);
@


1.9
log
@tidy up dmesg printing a bit, makes PCI hme only take 2 lines
per interface instead of 3.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.8 2003/02/14 21:05:12 henric Exp $	*/
d204 1
a204 1
	pci_intr_handle_t intrhandle;
d208 2
a209 1
	const char *intrstr;
d249 1
a249 1
	    &hsc->hsc_memt, &hsc->hsc_memh, NULL, NULL, 0) != 0) {
d266 1
a266 1
#ifdef __sparc__
a280 1

d283 1
a283 1
	if (pci_intr_map(pa, &intrhandle) != 0) {
d285 2
a286 1
		return;	/* bus_unmap ? */
d288 2
a289 2
	intrstr = pci_intr_string(pa->pa_pc, intrhandle);
	hsc->hsc_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_NET,
d291 1
a291 3
	if (hsc->hsc_ih != NULL) {
		printf(": %s", intrstr ? intrstr : "unknown interrupt");
	} else {
d296 2
a297 1
		return;	/* bus_unmap ? */
d299 2
@


1.8
log
@Do not do arithmetic on bus_space_handle_t.

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.7 2003/02/10 22:31:01 jason Exp $	*/
a282 5
	/*
	 * call the main configure
	 */
	hme_config(sc);

d284 1
a284 2
		printf("%s: couldn't map interrupt\n",
		    sc->sc_dev.dv_xname);
d291 1
a291 3
		printf("%s: using %s for interrupt\n",
		    sc->sc_dev.dv_xname,
		    intrstr ? intrstr : "unknown interrupt");
d293 1
a293 2
		printf("%s: couldn't establish interrupt",
		    sc->sc_dev.dv_xname);
d299 5
@


1.7
log
@Try to fetch MAC address from ebus bridge; based on NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.6 2002/03/14 01:26:58 millert Exp $	*/
d253 8
a260 4
	sc->sc_etx = hsc->hsc_memh + 0x2000;
	sc->sc_erx = hsc->hsc_memh + 0x4000;
	sc->sc_mac = hsc->hsc_memh + 0x6000;
	sc->sc_mif = hsc->hsc_memh + 0x7000;
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.5 2002/03/13 21:02:54 jason Exp $	*/
d79 1
d100 96
d209 1
a209 1
	int type;
d248 1
a248 2
	    &hsc->hsc_memt, &hsc->hsc_memh, NULL, NULL, 0) != 0)
	{
d258 3
d262 3
a264 2
	if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
	    sc->sc_enaddr, ETHER_ADDR_LEN) <= 0)
d266 2
d270 4
a273 1
	pci_ether_hw_addr(pa->pa_pc, sc->sc_enaddr);
@


1.5
log
@Fetch mac address from local-mac-address property, and use myetheraddr() only
if it fails.  (The right thing to do is have myetheraddr() do this, but
that will come later).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.4 2001/12/14 01:25:29 drahn Exp $	*/
d77 2
a78 2
int	hmematch_pci __P((struct device *, void *, void *));
void	hmeattach_pci __P((struct device *, struct device *, void *));
d109 1
a109 1
	extern void myetheraddr __P((u_char *));
@


1.4
log
@Hmm, too bad the interrupts do not configure. need pci_intr_fixup().
'commit that' jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.3 2001/08/25 10:13:29 art Exp $	*/
d60 1
d163 3
a165 1
        myetheraddr(sc->sc_enaddr);
@


1.4.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.4 2001/12/14 01:25:29 drahn Exp $	*/
a59 1
#include <dev/ofw/openfirm.h>
d76 2
a77 2
int	hmematch_pci(struct device *, void *, void *);
void	hmeattach_pci(struct device *, struct device *, void *);
d108 1
a108 1
	extern void myetheraddr(u_char *);
d162 1
a162 3
	if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
	    sc->sc_enaddr, ETHER_ADDR_LEN) <= 0)
		myetheraddr(sc->sc_enaddr);
@


1.4.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a78 1
int	hme_pci_enaddr(struct hme_softc *, struct pci_attach_args *);
a98 96
#define	PCI_EBUS2_BOOTROM	0x10
#define	PROMHDR_PTR_DATA	0x18
#define	PROMDATA_PTR_VPD	0x08
#define	PROMDATA_DATA2		0x0a

static const u_int8_t hme_promhdr[] = { 0x55, 0xaa };
static const u_int8_t hme_promdat[] = {
	'P', 'C', 'I', 'R',
	PCI_VENDOR_SUN & 0xff, PCI_VENDOR_SUN >> 8,
	PCI_PRODUCT_SUN_HME & 0xff, PCI_PRODUCT_SUN_HME >> 8
};
static const u_int8_t hme_promdat2[] = {
	0x18, 0x00,			/* structure length */
	0x00,				/* structure revision */
	0x00,				/* interface revision */
	PCI_SUBCLASS_NETWORK_ETHERNET,	/* subclass code */
	PCI_CLASS_NETWORK		/* class code */
};

int
hme_pci_enaddr(struct hme_softc *sc, struct pci_attach_args *hpa)
{
	struct pci_attach_args epa;
	struct pci_vpd *vpd;
	pcireg_t cl, id;
	bus_space_handle_t romh;
	bus_space_tag_t romt;
	bus_size_t romsize = 0;
	u_int8_t buf[32];
	int dataoff, vpdoff;

	/*
	 * Dig out VPD (vital product data) and acquire Ethernet address.
	 * The VPD of hme resides in the Boot PROM (PCI FCode) attached
	 * to the EBus interface.
	 * ``Writing FCode 3.x Programs'' (newer ones, dated 1997 and later)
	 * chapter 2 describes the data structure.
	 */

	/* get a PCI tag for the EBus bridge (function 0 of the same device) */
	epa = *hpa;
	epa.pa_tag = pci_make_tag(hpa->pa_pc, hpa->pa_bus, hpa->pa_device, 0);
	cl = pci_conf_read(epa.pa_pc, epa.pa_tag, PCI_CLASS_REG);
	id = pci_conf_read(epa.pa_pc, epa.pa_tag, PCI_ID_REG);

	if (PCI_CLASS(cl) != PCI_CLASS_BRIDGE ||
	    PCI_PRODUCT(id) != PCI_PRODUCT_SUN_EBUS)
		goto fail;

	if (pci_mapreg_map(&epa, PCI_EBUS2_BOOTROM, PCI_MAPREG_TYPE_MEM, 0,
	    &romt, &romh, 0, &romsize, 0))
		goto fail;

	bus_space_read_region_1(romt, romh, 0, buf, sizeof(buf));
	if (bcmp(buf, hme_promhdr, sizeof(hme_promhdr)))
		goto fail;

	dataoff = buf[PROMHDR_PTR_DATA] | (buf[PROMHDR_PTR_DATA + 1] << 8);
	if (dataoff < 0x1c)
		goto fail;

	bus_space_read_region_1(romt, romh, dataoff, buf, sizeof(buf));
	if (bcmp(buf, hme_promdat, sizeof(hme_promdat)) ||
	    bcmp(buf + PROMDATA_DATA2, hme_promdat2, sizeof(hme_promdat2)))
		goto fail;

	vpdoff = buf[PROMDATA_PTR_VPD] | (buf[PROMDATA_PTR_VPD + 1] << 8);
	if (vpdoff < 0x1c)
		goto fail;

	/*
	 * The VPD of hme is not in PCI 2.2 standard format.  The length
	 * in the resource header is in big endian, and resources are not
	 * properly terminated (only one resource and no end tag).
	 */
	bus_space_read_region_1(romt, romh, vpdoff, buf, sizeof(buf));

	/* XXX TODO: Get the data from VPD */
	vpd = (struct pci_vpd *)(buf + 3);
	if (!PCI_VPDRES_ISLARGE(buf[0]) ||
	    PCI_VPDRES_LARGE_NAME(buf[0]) != PCI_VPDRES_TYPE_VPD)
		goto fail;
	if (vpd->vpd_key0 != 'N' || vpd->vpd_key1 != 'A')
		goto fail;

	bcopy(buf + 6, sc->sc_enaddr, ETHER_ADDR_LEN);
	sc->sc_enaddr[5] += hpa->pa_device;
	bus_space_unmap(romt, romh, romsize);
	return (0);

fail:
	if (romsize != 0)
		bus_space_unmap(romt, romh, romsize);
	return (-1);
}

d112 1
a112 1
	int type, gotenaddr = 0;
d151 2
a152 1
	    &hsc->hsc_memt, &hsc->hsc_memh, NULL, NULL, 0) != 0) {
d157 4
a160 11
	bus_space_subregion(sc->sc_bustag, hsc->hsc_memh, 0x2000, 0x2000,
	    &sc->sc_etx);
	bus_space_subregion(sc->sc_bustag, hsc->hsc_memh, 0x4000, 0x2000,
	    &sc->sc_erx);
	bus_space_subregion(sc->sc_bustag, hsc->hsc_memh, 0x6000, 0x1000,
	    &sc->sc_mac);
	bus_space_subregion(sc->sc_bustag, hsc->hsc_memh, 0x7000, 0x1000,
	    &sc->sc_mif);

	if (hme_pci_enaddr(sc, pa) == 0)
		gotenaddr = 1;
d163 2
a164 3
	if (!gotenaddr) {
		if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
		    sc->sc_enaddr, ETHER_ADDR_LEN) <= 0)
a165 2
		gotenaddr = 1;
	}
d168 1
a168 4
	if (!gotenaddr) {
		pci_ether_hw_addr(pa->pa_pc, sc->sc_enaddr);
		gotenaddr = 1;
	}
@


1.3
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.2 2001/08/23 03:44:46 jason Exp $	*/
d161 7
a167 1
	myetheraddr(sc->sc_enaddr);
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@Merge in trunk
@
text
@d161 1
a161 7
#ifdef __sparc__
        myetheraddr(sc->sc_enaddr);
#endif
#ifdef __powerpc__
	pci_ether_hw_addr(pa->pa_pc, sc->sc_enaddr);
#endif

@


1.3.4.3
log
@Merge in -current from roughly a week ago
@
text
@a59 1
#include <dev/ofw/openfirm.h>
d76 2
a77 2
int	hmematch_pci(struct device *, void *, void *);
void	hmeattach_pci(struct device *, struct device *, void *);
d108 1
a108 1
	extern void myetheraddr(u_char *);
d162 1
a162 3
	if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
	    sc->sc_enaddr, ETHER_ADDR_LEN) <= 0)
		myetheraddr(sc->sc_enaddr);
@


1.3.4.4
log
@Sync the SMP branch with 3.3
@
text
@a78 1
int	hme_pci_enaddr(struct hme_softc *, struct pci_attach_args *);
a98 96
#define	PCI_EBUS2_BOOTROM	0x10
#define	PROMHDR_PTR_DATA	0x18
#define	PROMDATA_PTR_VPD	0x08
#define	PROMDATA_DATA2		0x0a

static const u_int8_t hme_promhdr[] = { 0x55, 0xaa };
static const u_int8_t hme_promdat[] = {
	'P', 'C', 'I', 'R',
	PCI_VENDOR_SUN & 0xff, PCI_VENDOR_SUN >> 8,
	PCI_PRODUCT_SUN_HME & 0xff, PCI_PRODUCT_SUN_HME >> 8
};
static const u_int8_t hme_promdat2[] = {
	0x18, 0x00,			/* structure length */
	0x00,				/* structure revision */
	0x00,				/* interface revision */
	PCI_SUBCLASS_NETWORK_ETHERNET,	/* subclass code */
	PCI_CLASS_NETWORK		/* class code */
};

int
hme_pci_enaddr(struct hme_softc *sc, struct pci_attach_args *hpa)
{
	struct pci_attach_args epa;
	struct pci_vpd *vpd;
	pcireg_t cl, id;
	bus_space_handle_t romh;
	bus_space_tag_t romt;
	bus_size_t romsize = 0;
	u_int8_t buf[32];
	int dataoff, vpdoff;

	/*
	 * Dig out VPD (vital product data) and acquire Ethernet address.
	 * The VPD of hme resides in the Boot PROM (PCI FCode) attached
	 * to the EBus interface.
	 * ``Writing FCode 3.x Programs'' (newer ones, dated 1997 and later)
	 * chapter 2 describes the data structure.
	 */

	/* get a PCI tag for the EBus bridge (function 0 of the same device) */
	epa = *hpa;
	epa.pa_tag = pci_make_tag(hpa->pa_pc, hpa->pa_bus, hpa->pa_device, 0);
	cl = pci_conf_read(epa.pa_pc, epa.pa_tag, PCI_CLASS_REG);
	id = pci_conf_read(epa.pa_pc, epa.pa_tag, PCI_ID_REG);

	if (PCI_CLASS(cl) != PCI_CLASS_BRIDGE ||
	    PCI_PRODUCT(id) != PCI_PRODUCT_SUN_EBUS)
		goto fail;

	if (pci_mapreg_map(&epa, PCI_EBUS2_BOOTROM, PCI_MAPREG_TYPE_MEM, 0,
	    &romt, &romh, 0, &romsize, 0))
		goto fail;

	bus_space_read_region_1(romt, romh, 0, buf, sizeof(buf));
	if (bcmp(buf, hme_promhdr, sizeof(hme_promhdr)))
		goto fail;

	dataoff = buf[PROMHDR_PTR_DATA] | (buf[PROMHDR_PTR_DATA + 1] << 8);
	if (dataoff < 0x1c)
		goto fail;

	bus_space_read_region_1(romt, romh, dataoff, buf, sizeof(buf));
	if (bcmp(buf, hme_promdat, sizeof(hme_promdat)) ||
	    bcmp(buf + PROMDATA_DATA2, hme_promdat2, sizeof(hme_promdat2)))
		goto fail;

	vpdoff = buf[PROMDATA_PTR_VPD] | (buf[PROMDATA_PTR_VPD + 1] << 8);
	if (vpdoff < 0x1c)
		goto fail;

	/*
	 * The VPD of hme is not in PCI 2.2 standard format.  The length
	 * in the resource header is in big endian, and resources are not
	 * properly terminated (only one resource and no end tag).
	 */
	bus_space_read_region_1(romt, romh, vpdoff, buf, sizeof(buf));

	/* XXX TODO: Get the data from VPD */
	vpd = (struct pci_vpd *)(buf + 3);
	if (!PCI_VPDRES_ISLARGE(buf[0]) ||
	    PCI_VPDRES_LARGE_NAME(buf[0]) != PCI_VPDRES_TYPE_VPD)
		goto fail;
	if (vpd->vpd_key0 != 'N' || vpd->vpd_key1 != 'A')
		goto fail;

	bcopy(buf + 6, sc->sc_enaddr, ETHER_ADDR_LEN);
	sc->sc_enaddr[5] += hpa->pa_device;
	bus_space_unmap(romt, romh, romsize);
	return (0);

fail:
	if (romsize != 0)
		bus_space_unmap(romt, romh, romsize);
	return (-1);
}

d112 1
a112 1
	int type, gotenaddr = 0;
d151 2
a152 1
	    &hsc->hsc_memt, &hsc->hsc_memh, NULL, NULL, 0) != 0) {
d157 4
a160 11
	bus_space_subregion(sc->sc_bustag, hsc->hsc_memh, 0x2000, 0x2000,
	    &sc->sc_etx);
	bus_space_subregion(sc->sc_bustag, hsc->hsc_memh, 0x4000, 0x2000,
	    &sc->sc_erx);
	bus_space_subregion(sc->sc_bustag, hsc->hsc_memh, 0x6000, 0x1000,
	    &sc->sc_mac);
	bus_space_subregion(sc->sc_bustag, hsc->hsc_memh, 0x7000, 0x1000,
	    &sc->sc_mif);

	if (hme_pci_enaddr(sc, pa) == 0)
		gotenaddr = 1;
d163 2
a164 3
	if (!gotenaddr) {
		if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
		    sc->sc_enaddr, ETHER_ADDR_LEN) <= 0)
a165 2
		gotenaddr = 1;
	}
d168 1
a168 4
	if (!gotenaddr) {
		pci_ether_hw_addr(pa->pa_pc, sc->sc_enaddr);
		gotenaddr = 1;
	}
@


1.2
log
@only include <machine/autoconf.h> on sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_pci.c,v 1.1 2001/08/22 21:49:39 jason Exp $	*/
d170 1
a170 2
	if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &intrhandle) != 0) {
@


1.1
log
@pci bus frontend for hme from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 1
d60 1
@

