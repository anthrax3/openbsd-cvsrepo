head	1.135;
access;
symbols
	OPENBSD_6_2:1.135.0.2
	OPENBSD_6_2_BASE:1.135
	OPENBSD_6_1:1.135.0.4
	OPENBSD_6_1_BASE:1.135
	OPENBSD_6_0:1.134.0.4
	OPENBSD_6_0_BASE:1.134
	OPENBSD_5_9:1.133.0.2
	OPENBSD_5_9_BASE:1.133
	OPENBSD_5_8:1.127.0.4
	OPENBSD_5_8_BASE:1.127
	OPENBSD_5_7:1.123.0.4
	OPENBSD_5_7_BASE:1.123
	OPENBSD_5_6:1.117.0.4
	OPENBSD_5_6_BASE:1.117
	OPENBSD_5_5:1.115.0.4
	OPENBSD_5_5_BASE:1.115
	OPENBSD_5_4:1.111.0.2
	OPENBSD_5_4_BASE:1.111
	OPENBSD_5_3:1.108.0.2
	OPENBSD_5_3_BASE:1.108
	OPENBSD_5_2:1.105.0.6
	OPENBSD_5_2_BASE:1.105
	OPENBSD_5_1_BASE:1.105
	OPENBSD_5_1:1.105.0.4
	OPENBSD_5_0:1.105.0.2
	OPENBSD_5_0_BASE:1.105
	OPENBSD_4_9:1.102.0.2
	OPENBSD_4_9_BASE:1.102
	OPENBSD_4_8:1.99.0.2
	OPENBSD_4_8_BASE:1.99
	OPENBSD_4_7:1.97.0.2
	OPENBSD_4_7_BASE:1.97
	OPENBSD_4_6:1.93.0.4
	OPENBSD_4_6_BASE:1.93
	OPENBSD_4_5:1.87.0.2
	OPENBSD_4_5_BASE:1.87
	OPENBSD_4_4:1.80.0.2
	OPENBSD_4_4_BASE:1.80
	OPENBSD_4_3:1.77.0.4
	OPENBSD_4_3_BASE:1.77
	OPENBSD_4_2:1.77.0.2
	OPENBSD_4_2_BASE:1.77
	OPENBSD_4_1:1.76.0.2
	OPENBSD_4_1_BASE:1.76
	OPENBSD_4_0:1.73.0.2
	OPENBSD_4_0_BASE:1.73
	OPENBSD_3_9:1.61.0.2
	OPENBSD_3_9_BASE:1.61
	OPENBSD_3_8:1.51.0.2
	OPENBSD_3_8_BASE:1.51
	OPENBSD_3_7:1.43.0.2
	OPENBSD_3_7_BASE:1.43
	OPENBSD_3_6:1.40.0.2
	OPENBSD_3_6_BASE:1.40
	SMP_SYNC_A:1.39
	SMP_SYNC_B:1.39
	OPENBSD_3_5:1.36.0.2
	OPENBSD_3_5_BASE:1.36
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	UBC_SYNC_A:1.31
	OPENBSD_3_3:1.31.0.2
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.27.0.2
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.27
	UBC:1.19.0.2
	UBC_BASE:1.19
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	SMP:1.2.0.2
	SMP_BASE:1.2
	kame_19991208:1.2;
locks; strict;
comment	@ * @;


1.135
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.134;
commitid	VyLWTsbepAOk7VQM;

1.134
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.133;
commitid	8YSL8ByWzGeIGBiJ;

1.133
date	2016.01.08.11.23.30;	author mpi;	state Exp;
branches;
next	1.132;
commitid	AVcDPpPujUhJtHVl;

1.132
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.131;
commitid	B0kwmVGiD5DVx4kv;

1.131
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.130;
commitid	5gdEnqVoJuTuwdTu;

1.130
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.129;
commitid	5DvsamK0GblTp8ww;

1.129
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.128;
commitid	eYnPulzvLjDImPCa;

1.128
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.127;
commitid	hPF95ClMUQfeqQDX;

1.127
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.126;
commitid	MVWrtktB46JRxFWT;

1.126
date	2015.04.13.08.45.48;	author mpi;	state Exp;
branches;
next	1.125;
commitid	aiRvgNOa4qke9vft;

1.125
date	2015.03.30.10.01.21;	author mpi;	state Exp;
branches;
next	1.124;
commitid	BnFFSV1y56JmF3rn;

1.124
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.123;
commitid	p4LJxGKbi0BU2cG6;

1.123
date	2015.02.11.21.36.02;	author brad;	state Exp;
branches;
next	1.122;
commitid	IWQwoXPPKg2rjfrU;

1.122
date	2015.01.06.04.05.43;	author brad;	state Exp;
branches;
next	1.121;
commitid	cDY65x7POb2QNyY7;

1.121
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.120;
commitid	yM2VFFhpDTeFQlve;

1.120
date	2014.12.17.03.50.53;	author brad;	state Exp;
branches;
next	1.119;
commitid	appOHeecjnJqa2ZE;

1.119
date	2014.12.08.10.58.45;	author brad;	state Exp;
branches;
next	1.118;
commitid	2lOR2VAGPukFfE5p;

1.118
date	2014.11.24.10.33.37;	author brad;	state Exp;
branches;
next	1.117;
commitid	n3mk3gi6o2NDYPpC;

1.117
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.116;
commitid	TGHgrLxu6sxZoiFt;

1.116
date	2014.07.08.05.35.18;	author dlg;	state Exp;
branches;
next	1.115;
commitid	0QJleeeWqZmC5anF;

1.115
date	2013.12.28.03.34.54;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.113;

1.113
date	2013.08.21.05.21.44;	author dlg;	state Exp;
branches;
next	1.112;

1.112
date	2013.08.07.01.06.37;	author bluhm;	state Exp;
branches;
next	1.111;

1.111
date	2013.06.28.03.24.18;	author brad;	state Exp;
branches;
next	1.110;

1.110
date	2013.03.17.00.29.16;	author brad;	state Exp;
branches;
next	1.109;

1.109
date	2013.03.07.06.19.07;	author brad;	state Exp;
branches;
next	1.108;

1.108
date	2013.02.09.19.15.18;	author sthen;	state Exp;
branches;
next	1.107;

1.107
date	2012.11.29.21.10.32;	author brad;	state Exp;
branches;
next	1.106;

1.106
date	2012.10.18.21.44.21;	author deraadt;	state Exp;
branches;
next	1.105;

1.105
date	2011.06.22.16.44.27;	author tedu;	state Exp;
branches;
next	1.104;

1.104
date	2011.04.14.06.27.52;	author dlg;	state Exp;
branches;
next	1.103;

1.103
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.102;

1.102
date	2011.02.15.19.10.19;	author kettenis;	state Exp;
branches;
next	1.101;

1.101
date	2010.08.31.17.13.44;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2010.08.31.16.26.19;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2010.08.06.05.24.16;	author deraadt;	state Exp;
branches
	1.99.2.1;
next	1.98;

1.98
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.97;

1.97
date	2009.08.13.14.24.47;	author jasper;	state Exp;
branches;
next	1.96;

1.96
date	2009.08.10.19.41.05;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2009.08.09.11.40.56;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2009.07.22.21.32.50;	author miod;	state Exp;
branches;
next	1.93;

1.93
date	2009.06.22.22.14.21;	author claudio;	state Exp;
branches;
next	1.92;

1.92
date	2009.06.18.18.49.34;	author claudio;	state Exp;
branches;
next	1.91;

1.91
date	2009.06.12.21.55.50;	author claudio;	state Exp;
branches;
next	1.90;

1.90
date	2009.06.04.20.01.02;	author sthen;	state Exp;
branches;
next	1.89;

1.89
date	2009.06.04.18.12.56;	author sthen;	state Exp;
branches;
next	1.88;

1.88
date	2009.04.14.19.06.49;	author claudio;	state Exp;
branches;
next	1.87;

1.87
date	2009.02.24.21.10.14;	author claudio;	state Exp;
branches;
next	1.86;

1.86
date	2008.12.04.23.05.32;	author oga;	state Exp;
branches;
next	1.85;

1.85
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.84;

1.84
date	2008.11.10.07.23.43;	author cnst;	state Exp;
branches;
next	1.83;

1.83
date	2008.10.14.18.01.53;	author naddy;	state Exp;
branches;
next	1.82;

1.82
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.81;

1.81
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.80;

1.80
date	2008.07.15.12.10.48;	author thib;	state Exp;
branches;
next	1.79;

1.79
date	2008.07.10.18.14.59;	author thib;	state Exp;
branches;
next	1.78;

1.78
date	2008.07.07.12.53.43;	author thib;	state Exp;
branches;
next	1.77;

1.77
date	2007.05.04.12.12.53;	author art;	state Exp;
branches;
next	1.76;

1.76
date	2006.12.03.16.23.41;	author grange;	state Exp;
branches;
next	1.75;

1.75
date	2006.12.03.16.12.22;	author grange;	state Exp;
branches;
next	1.74;

1.74
date	2006.10.18.20.00.21;	author brad;	state Exp;
branches;
next	1.73;

1.73
date	2006.08.10.17.45.16;	author brad;	state Exp;
branches;
next	1.72;

1.72
date	2006.07.10.03.06.28;	author brad;	state Exp;
branches;
next	1.71;

1.71
date	2006.05.28.00.04.24;	author jason;	state Exp;
branches;
next	1.70;

1.70
date	2006.05.27.21.48.22;	author brad;	state Exp;
branches;
next	1.69;

1.69
date	2006.04.28.17.18.13;	author brad;	state Exp;
branches;
next	1.68;

1.68
date	2006.04.28.10.17.34;	author martin;	state Exp;
branches;
next	1.67;

1.67
date	2006.04.28.06.14.46;	author brad;	state Exp;
branches;
next	1.66;

1.66
date	2006.03.25.22.41.45;	author djm;	state Exp;
branches;
next	1.65;

1.65
date	2006.03.25.20.09.17;	author brad;	state Exp;
branches;
next	1.64;

1.64
date	2006.03.25.05.00.28;	author brad;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.25.03.21.56;	author brad;	state Exp;
branches;
next	1.62;

1.62
date	2006.03.20.16.15.03;	author brad;	state Exp;
branches;
next	1.61;

1.61
date	2005.11.04.16.59.45;	author brad;	state Exp;
branches;
next	1.60;

1.60
date	2005.10.30.00.38.28;	author brad;	state Exp;
branches;
next	1.59;

1.59
date	2005.10.20.21.47.56;	author brad;	state Exp;
branches;
next	1.58;

1.58
date	2005.10.18.01.01.27;	author brad;	state Exp;
branches;
next	1.57;

1.57
date	2005.10.18.00.44.23;	author brad;	state Exp;
branches;
next	1.56;

1.56
date	2005.10.18.00.12.09;	author brad;	state Exp;
branches;
next	1.55;

1.55
date	2005.10.17.05.02.50;	author brad;	state Exp;
branches;
next	1.54;

1.54
date	2005.10.14.22.59.38;	author brad;	state Exp;
branches;
next	1.53;

1.53
date	2005.10.13.01.44.33;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2005.10.12.21.14.37;	author brad;	state Exp;
branches;
next	1.51;

1.51
date	2005.08.09.04.10.12;	author mickey;	state Exp;
branches;
next	1.50;

1.50
date	2005.07.28.18.39.32;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2005.07.21.16.08.21;	author fgsch;	state Exp;
branches;
next	1.48;

1.48
date	2005.07.02.23.10.11;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2005.06.12.21.38.14;	author fgsch;	state Exp;
branches;
next	1.46;

1.46
date	2005.05.27.04.52.24;	author brad;	state Exp;
branches;
next	1.45;

1.45
date	2005.05.22.05.40.52;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2005.04.05.00.13.57;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2004.09.28.04.37.33;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2004.07.04.22.57.20;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2004.06.06.04.34.33;	author mcbride;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.26.05.16.41;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.09.21.52.17;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.01.11.44.49;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.11.07.41.19;	author chris;	state Exp;
branches;
next	1.34;

1.34
date	2003.10.30.22.10.25;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.09.02.09.08;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.30.02.52.09;	author avsm;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.10.12.13.23;	author mcbride;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.22.10.38.48;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.20.15.19.33;	author fgsch;	state Exp;
branches;
next	1.28;

1.28
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.31.16.58.20;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.05.13.48.11;	author aaron;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.03.02.30.56;	author aaron;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.02.16.44.25;	author aaron;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.25.20.28.06;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.15.20.45.31;	author nordin;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.08.04.43.24;	author chris;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.09.23.22.41.25;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.12.20.03.49;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.27.06.34.48;	author kjc;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.24.20.27.00;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.10.23.34.01;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.14.15.17.31;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.12.05.51.18;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.20.19.39.45;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.20.19.15.19;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.06.15.48.28;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.16.17.08.08;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.25.17.39.25;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.06.23.25.17;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.06.19.12.12;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.15.02.28.14;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	99.12.08.00.38.08;	author aaron;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.12.04.20.27.36;	author aaron;	state Exp;
branches;
next	;

1.2.2.1
date	2000.02.20.11.57.05;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.05.14.22.25.46;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.07.04.10.42.19;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.2.2.8;

1.2.2.8
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.2.2.9;

1.2.2.9
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	1.2.2.10;

1.2.2.10
date	2004.06.05.23.12.51;	author niklas;	state Exp;
branches;
next	1.2.2.11;

1.2.2.11
date	2004.06.07.20.41.25;	author niklas;	state Exp;
branches;
next	;

1.19.2.1
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;

1.99.2.1
date	2011.02.16.20.05.43;	author jasper;	state Exp;
branches;
next	1.99.2.2;

1.99.2.2
date	2011.02.17.00.53.48;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.135
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_sis.c,v 1.134 2016/04/13 10:34:32 mpi Exp $ */
/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/pci/if_sis.c,v 1.30 2001/02/06 10:11:47 phk Exp $
 */

/*
 * SiS 900/SiS 7016 fast ethernet PCI NIC driver. Datasheets are
 * available from http://www.sis.com.tw.
 *
 * This driver also supports the NatSemi DP83815. Datasheets are
 * available from http://www.national.com.
 *
 * Written by Bill Paul <wpaul@@ee.columbia.edu>
 * Electrical Engineering Department
 * Columbia University, New York City
 */

/*
 * The SiS 900 is a fairly simple chip. It uses bus master DMA with
 * simple TX and RX descriptors of 3 longwords in size. The receiver
 * has a single perfect filter entry for the station address and a
 * 128-bit multicast hash table. The SiS 900 has a built-in MII-based
 * transceiver while the 7016 requires an external transceiver chip.
 * Both chips offer the standard bit-bang MII interface as well as
 * an enchanced PHY interface which simplifies accessing MII registers.
 *
 * The only downside to this chipset is that RX descriptors must be
 * longword aligned.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/timeout.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <sys/device.h>

#include <dev/mii/miivar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#define SIS_USEIOSPACE

#include <dev/pci/if_sisreg.h>

int sis_probe(struct device *, void *, void *);
void sis_attach(struct device *, struct device *, void *);
int sis_activate(struct device *, int);

struct cfattach sis_ca = {
	sizeof(struct sis_softc), sis_probe, sis_attach, NULL,
	sis_activate
};

struct cfdriver sis_cd = {
	NULL, "sis", DV_IFNET
};

int sis_intr(void *);
void sis_fill_rx_ring(struct sis_softc *);
int sis_newbuf(struct sis_softc *, struct sis_desc *);
int sis_encap(struct sis_softc *, struct mbuf *, u_int32_t *);
void sis_rxeof(struct sis_softc *);
void sis_txeof(struct sis_softc *);
void sis_tick(void *);
void sis_start(struct ifnet *);
int sis_ioctl(struct ifnet *, u_long, caddr_t);
void sis_init(void *);
void sis_stop(struct sis_softc *);
void sis_watchdog(struct ifnet *);
int sis_ifmedia_upd(struct ifnet *);
void sis_ifmedia_sts(struct ifnet *, struct ifmediareq *);

u_int16_t sis_reverse(u_int16_t);
void sis_delay(struct sis_softc *);
void sis_eeprom_idle(struct sis_softc *);
void sis_eeprom_putbyte(struct sis_softc *, int);
void sis_eeprom_getword(struct sis_softc *, int, u_int16_t *);
#if defined(__amd64__) || defined(__i386__)
void sis_read_cmos(struct sis_softc *, struct pci_attach_args *, caddr_t, int, int);
#endif
void sis_read_mac(struct sis_softc *, struct pci_attach_args *);
void sis_read_eeprom(struct sis_softc *, caddr_t, int, int, int);
void sis_read96x_mac(struct sis_softc *);

void sis_mii_sync(struct sis_softc *);
void sis_mii_send(struct sis_softc *, u_int32_t, int);
int sis_mii_readreg(struct sis_softc *, struct sis_mii_frame *);
int sis_mii_writereg(struct sis_softc *, struct sis_mii_frame *);
int sis_miibus_readreg(struct device *, int, int);
void sis_miibus_writereg(struct device *, int, int, int);
void sis_miibus_statchg(struct device *);

u_int32_t sis_mchash(struct sis_softc *, const uint8_t *);
void sis_iff(struct sis_softc *);
void sis_iff_ns(struct sis_softc *);
void sis_iff_sis(struct sis_softc *);
void sis_reset(struct sis_softc *);
int sis_ring_init(struct sis_softc *);

#define SIS_SETBIT(sc, reg, x)				\
	CSR_WRITE_4(sc, reg,				\
		CSR_READ_4(sc, reg) | (x))

#define SIS_CLRBIT(sc, reg, x)				\
	CSR_WRITE_4(sc, reg,				\
		CSR_READ_4(sc, reg) & ~(x))

#define SIO_SET(x)					\
	CSR_WRITE_4(sc, SIS_EECTL, CSR_READ_4(sc, SIS_EECTL) | x)

#define SIO_CLR(x)					\
	CSR_WRITE_4(sc, SIS_EECTL, CSR_READ_4(sc, SIS_EECTL) & ~x)

const struct pci_matchid sis_devices[] = {
	{ PCI_VENDOR_SIS, PCI_PRODUCT_SIS_900 },
	{ PCI_VENDOR_SIS, PCI_PRODUCT_SIS_7016 },
	{ PCI_VENDOR_NS, PCI_PRODUCT_NS_DP83815 }
};

/*
 * Routine to reverse the bits in a word. Stolen almost
 * verbatim from /usr/games/fortune.
 */
u_int16_t
sis_reverse(u_int16_t n)
{
	n = ((n >>  1) & 0x5555) | ((n <<  1) & 0xaaaa);
	n = ((n >>  2) & 0x3333) | ((n <<  2) & 0xcccc);
	n = ((n >>  4) & 0x0f0f) | ((n <<  4) & 0xf0f0);
	n = ((n >>  8) & 0x00ff) | ((n <<  8) & 0xff00);

	return (n);
}

void
sis_delay(struct sis_softc *sc)
{
	int			idx;

	for (idx = (300 / 33) + 1; idx > 0; idx--)
		CSR_READ_4(sc, SIS_CSR);
}

void
sis_eeprom_idle(struct sis_softc *sc)
{
	int			i;

	SIO_SET(SIS_EECTL_CSEL);
	sis_delay(sc);
	SIO_SET(SIS_EECTL_CLK);
	sis_delay(sc);

	for (i = 0; i < 25; i++) {
		SIO_CLR(SIS_EECTL_CLK);
		sis_delay(sc);
		SIO_SET(SIS_EECTL_CLK);
		sis_delay(sc);
	}

	SIO_CLR(SIS_EECTL_CLK);
	sis_delay(sc);
	SIO_CLR(SIS_EECTL_CSEL);
	sis_delay(sc);
	CSR_WRITE_4(sc, SIS_EECTL, 0x00000000);
}

/*
 * Send a read command and address to the EEPROM, check for ACK.
 */
void
sis_eeprom_putbyte(struct sis_softc *sc, int addr)
{
	int			d, i;

	d = addr | SIS_EECMD_READ;

	/*
	 * Feed in each bit and strobe the clock.
	 */
	for (i = 0x400; i; i >>= 1) {
		if (d & i)
			SIO_SET(SIS_EECTL_DIN);
		else
			SIO_CLR(SIS_EECTL_DIN);
		sis_delay(sc);
		SIO_SET(SIS_EECTL_CLK);
		sis_delay(sc);
		SIO_CLR(SIS_EECTL_CLK);
		sis_delay(sc);
	}
}

/*
 * Read a word of data stored in the EEPROM at address 'addr.'
 */
void
sis_eeprom_getword(struct sis_softc *sc, int addr, u_int16_t *dest)
{
	int			i;
	u_int16_t		word = 0;

	/* Force EEPROM to idle state. */
	sis_eeprom_idle(sc);

	/* Enter EEPROM access mode. */
	sis_delay(sc);
	SIO_CLR(SIS_EECTL_CLK);
	sis_delay(sc);
	SIO_SET(SIS_EECTL_CSEL);
	sis_delay(sc);

	/*
	 * Send address of word we want to read.
	 */
	sis_eeprom_putbyte(sc, addr);

	/*
	 * Start reading bits from EEPROM.
	 */
	for (i = 0x8000; i; i >>= 1) {
		SIO_SET(SIS_EECTL_CLK);
		sis_delay(sc);
		if (CSR_READ_4(sc, SIS_EECTL) & SIS_EECTL_DOUT)
			word |= i;
		sis_delay(sc);
		SIO_CLR(SIS_EECTL_CLK);
		sis_delay(sc);
	}

	/* Turn off EEPROM access mode. */
	sis_eeprom_idle(sc);

	*dest = word;
}

/*
 * Read a sequence of words from the EEPROM.
 */
void
sis_read_eeprom(struct sis_softc *sc, caddr_t dest,
    int off, int cnt, int swap)
{
	int			i;
	u_int16_t		word = 0, *ptr;

	for (i = 0; i < cnt; i++) {
		sis_eeprom_getword(sc, off + i, &word);
		ptr = (u_int16_t *)(dest + (i * 2));
		if (swap)
			*ptr = letoh16(word);
		else
			*ptr = word;
	}
}

#if defined(__amd64__) || defined(__i386__)
void
sis_read_cmos(struct sis_softc *sc, struct pci_attach_args *pa,
    caddr_t dest, int off, int cnt)
{
	u_int32_t reg;
	int i;

	reg = pci_conf_read(pa->pa_pc, pa->pa_tag, 0x48);
	pci_conf_write(pa->pa_pc, pa->pa_tag, 0x48, reg | 0x40);

	for (i = 0; i < cnt; i++) {
		bus_space_write_1(pa->pa_iot, 0x0, 0x70, i + off);
		*(dest + i) = bus_space_read_1(pa->pa_iot, 0x0, 0x71);
	}

	pci_conf_write(pa->pa_pc, pa->pa_tag, 0x48, reg & ~0x40);
}
#endif

void
sis_read_mac(struct sis_softc *sc, struct pci_attach_args *pa)
{
	uint32_t rxfilt, csrsave;
	u_int16_t *enaddr = (u_int16_t *) &sc->arpcom.ac_enaddr;

	rxfilt = CSR_READ_4(sc, SIS_RXFILT_CTL);
	csrsave = CSR_READ_4(sc, SIS_CSR);

	CSR_WRITE_4(sc, SIS_CSR, SIS_CSR_RELOAD | csrsave);
	CSR_WRITE_4(sc, SIS_CSR, 0);

	CSR_WRITE_4(sc, SIS_RXFILT_CTL, rxfilt & ~SIS_RXFILTCTL_ENABLE);

	CSR_WRITE_4(sc, SIS_RXFILT_CTL, SIS_FILTADDR_PAR0);
	enaddr[0] = letoh16(CSR_READ_4(sc, SIS_RXFILT_DATA) & 0xffff);
	CSR_WRITE_4(sc, SIS_RXFILT_CTL, SIS_FILTADDR_PAR1);
	enaddr[1] = letoh16(CSR_READ_4(sc, SIS_RXFILT_DATA) & 0xffff);
	CSR_WRITE_4(sc, SIS_RXFILT_CTL, SIS_FILTADDR_PAR2);
	enaddr[2] = letoh16(CSR_READ_4(sc, SIS_RXFILT_DATA) & 0xffff);

	CSR_WRITE_4(sc, SIS_RXFILT_CTL, rxfilt);
	CSR_WRITE_4(sc, SIS_CSR, csrsave);
}

void
sis_read96x_mac(struct sis_softc *sc)
{
	int i;

	SIO_SET(SIS96x_EECTL_REQ);

	for (i = 0; i < 2000; i++) {
		if ((CSR_READ_4(sc, SIS_EECTL) & SIS96x_EECTL_GNT)) {
			sis_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
			    SIS_EE_NODEADDR, 3, 1);
			break;
		} else
			DELAY(1);
	}

	SIO_SET(SIS96x_EECTL_DONE);
}

/*
 * Sync the PHYs by setting data bit and strobing the clock 32 times.
 */
void
sis_mii_sync(struct sis_softc *sc)
{
	int			i;
 
 	SIO_SET(SIS_MII_DIR|SIS_MII_DATA);
 
 	for (i = 0; i < 32; i++) {
 		SIO_SET(SIS_MII_CLK);
 		DELAY(1);
 		SIO_CLR(SIS_MII_CLK);
 		DELAY(1);
 	}
}
 
/*
 * Clock a series of bits through the MII.
 */
void
sis_mii_send(struct sis_softc *sc, u_int32_t bits, int cnt)
{
	int			i;
 
	SIO_CLR(SIS_MII_CLK);
 
	for (i = (0x1 << (cnt - 1)); i; i >>= 1) {
		if (bits & i)
			SIO_SET(SIS_MII_DATA);
		else
			SIO_CLR(SIS_MII_DATA);
		DELAY(1);
		SIO_CLR(SIS_MII_CLK);
		DELAY(1);
		SIO_SET(SIS_MII_CLK);
	}
}
 
/*
 * Read an PHY register through the MII.
 */
int
sis_mii_readreg(struct sis_softc *sc, struct sis_mii_frame *frame)
{
	int			i, ack, s;
 
	s = splnet();
 
	/*
	 * Set up frame for RX.
	 */
	frame->mii_stdelim = SIS_MII_STARTDELIM;
	frame->mii_opcode = SIS_MII_READOP;
	frame->mii_turnaround = 0;
	frame->mii_data = 0;
 	
	/*
 	 * Turn on data xmit.
	 */
	SIO_SET(SIS_MII_DIR);

	sis_mii_sync(sc);
 
	/*
	 * Send command/address info.
	 */
	sis_mii_send(sc, frame->mii_stdelim, 2);
	sis_mii_send(sc, frame->mii_opcode, 2);
	sis_mii_send(sc, frame->mii_phyaddr, 5);
	sis_mii_send(sc, frame->mii_regaddr, 5);
 
	/* Idle bit */
	SIO_CLR((SIS_MII_CLK|SIS_MII_DATA));
	DELAY(1);
	SIO_SET(SIS_MII_CLK);
	DELAY(1);
 
	/* Turn off xmit. */
	SIO_CLR(SIS_MII_DIR);
 
	/* Check for ack */
	SIO_CLR(SIS_MII_CLK);
	DELAY(1);
	ack = CSR_READ_4(sc, SIS_EECTL) & SIS_MII_DATA;
	SIO_SET(SIS_MII_CLK);
	DELAY(1);
 
	/*
	 * Now try reading data bits. If the ack failed, we still
	 * need to clock through 16 cycles to keep the PHY(s) in sync.
	 */
	if (ack) {
		for(i = 0; i < 16; i++) {
			SIO_CLR(SIS_MII_CLK);
			DELAY(1);
			SIO_SET(SIS_MII_CLK);
			DELAY(1);
		}
		goto fail;
	}
 
	for (i = 0x8000; i; i >>= 1) {
		SIO_CLR(SIS_MII_CLK);
		DELAY(1);
		if (!ack) {
			if (CSR_READ_4(sc, SIS_EECTL) & SIS_MII_DATA)
				frame->mii_data |= i;
			DELAY(1);
		}
		SIO_SET(SIS_MII_CLK);
		DELAY(1);
	}

fail:

	SIO_CLR(SIS_MII_CLK);
	DELAY(1);
	SIO_SET(SIS_MII_CLK);
	DELAY(1);

	splx(s);

	if (ack)
		return (1);
	return (0);
}
 
/*
 * Write to a PHY register through the MII.
 */
int
sis_mii_writereg(struct sis_softc *sc, struct sis_mii_frame *frame)
{
	int			s;
 
	s = splnet();
 	/*
 	 * Set up frame for TX.
 	 */
 
 	frame->mii_stdelim = SIS_MII_STARTDELIM;
 	frame->mii_opcode = SIS_MII_WRITEOP;
 	frame->mii_turnaround = SIS_MII_TURNAROUND;
 	
 	/*
  	 * Turn on data output.
 	 */
 	SIO_SET(SIS_MII_DIR);
 
 	sis_mii_sync(sc);
 
 	sis_mii_send(sc, frame->mii_stdelim, 2);
 	sis_mii_send(sc, frame->mii_opcode, 2);
 	sis_mii_send(sc, frame->mii_phyaddr, 5);
 	sis_mii_send(sc, frame->mii_regaddr, 5);
 	sis_mii_send(sc, frame->mii_turnaround, 2);
 	sis_mii_send(sc, frame->mii_data, 16);
 
 	/* Idle bit. */
 	SIO_SET(SIS_MII_CLK);
 	DELAY(1);
 	SIO_CLR(SIS_MII_CLK);
 	DELAY(1);
 
 	/*
 	 * Turn off xmit.
 	 */
 	SIO_CLR(SIS_MII_DIR);
 
 	splx(s);
 
 	return (0);
}

int
sis_miibus_readreg(struct device *self, int phy, int reg)
{
	struct sis_softc	*sc = (struct sis_softc *)self;
	struct sis_mii_frame    frame;

	if (sc->sis_type == SIS_TYPE_83815) {
		if (phy != 0)
			return (0);
		/*
		 * The NatSemi chip can take a while after
		 * a reset to come ready, during which the BMSR
		 * returns a value of 0. This is *never* supposed
		 * to happen: some of the BMSR bits are meant to
		 * be hardwired in the on position, and this can
		 * confuse the miibus code a bit during the probe
		 * and attach phase. So we make an effort to check
		 * for this condition and wait for it to clear.
		 */
		if (!CSR_READ_4(sc, NS_BMSR))
			DELAY(1000);
		return CSR_READ_4(sc, NS_BMCR + (reg * 4));
	}

	/*
	 * Chipsets < SIS_635 seem not to be able to read/write
	 * through mdio. Use the enhanced PHY access register
	 * again for them.
	 */
	if (sc->sis_type == SIS_TYPE_900 &&
	    sc->sis_rev < SIS_REV_635) {
		int i, val = 0;

		if (phy != 0)
			return (0);

		CSR_WRITE_4(sc, SIS_PHYCTL,
		    (phy << 11) | (reg << 6) | SIS_PHYOP_READ);
		SIS_SETBIT(sc, SIS_PHYCTL, SIS_PHYCTL_ACCESS);

		for (i = 0; i < SIS_TIMEOUT; i++) {
			if (!(CSR_READ_4(sc, SIS_PHYCTL) & SIS_PHYCTL_ACCESS))
				break;
		}

		if (i == SIS_TIMEOUT) {
			printf("%s: PHY failed to come ready\n",
			    sc->sc_dev.dv_xname);
			return (0);
		}

		val = (CSR_READ_4(sc, SIS_PHYCTL) >> 16) & 0xFFFF;

		if (val == 0xFFFF)
			return (0);

		return (val);
	} else {
		bzero(&frame, sizeof(frame));

		frame.mii_phyaddr = phy;
		frame.mii_regaddr = reg;
		sis_mii_readreg(sc, &frame);

		return (frame.mii_data);
	}
}

void
sis_miibus_writereg(struct device *self, int phy, int reg, int data)
{
	struct sis_softc	*sc = (struct sis_softc *)self;
	struct sis_mii_frame	frame;

	if (sc->sis_type == SIS_TYPE_83815) {
		if (phy != 0)
			return;
		CSR_WRITE_4(sc, NS_BMCR + (reg * 4), data);
		return;
	}

	/*
	 * Chipsets < SIS_635 seem not to be able to read/write
	 * through mdio. Use the enhanced PHY access register
	 * again for them.
	 */
	if (sc->sis_type == SIS_TYPE_900 &&
	    sc->sis_rev < SIS_REV_635) {
		int i;

		if (phy != 0)
			return;

		CSR_WRITE_4(sc, SIS_PHYCTL, (data << 16) | (phy << 11) |
		    (reg << 6) | SIS_PHYOP_WRITE);
		SIS_SETBIT(sc, SIS_PHYCTL, SIS_PHYCTL_ACCESS);

		for (i = 0; i < SIS_TIMEOUT; i++) {
			if (!(CSR_READ_4(sc, SIS_PHYCTL) & SIS_PHYCTL_ACCESS))
				break;
		}

		if (i == SIS_TIMEOUT)
			printf("%s: PHY failed to come ready\n",
			    sc->sc_dev.dv_xname);
	} else {
		bzero(&frame, sizeof(frame));

		frame.mii_phyaddr = phy;
		frame.mii_regaddr = reg;
		frame.mii_data = data;
		sis_mii_writereg(sc, &frame);
	}
}

void
sis_miibus_statchg(struct device *self)
{
	struct sis_softc	*sc = (struct sis_softc *)self;
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	struct mii_data		*mii = &sc->sc_mii;

	if ((ifp->if_flags & IFF_RUNNING) == 0)
		return;

	sc->sis_link = 0;
	if ((mii->mii_media_status & (IFM_ACTIVE | IFM_AVALID)) ==
	    (IFM_ACTIVE | IFM_AVALID)) {
		switch (IFM_SUBTYPE(mii->mii_media_active)) {
		case IFM_10_T:
			CSR_WRITE_4(sc, SIS_TX_CFG, SIS_TXCFG_10);
			sc->sis_link++;
			break;
		case IFM_100_TX:
			CSR_WRITE_4(sc, SIS_TX_CFG, SIS_TXCFG_100);
			sc->sis_link++;
			break;
		default:
			break;
		}
	}

	if (!sc->sis_link) {
		/*
		 * Stopping MACs seem to reset SIS_TX_LISTPTR and
		 * SIS_RX_LISTPTR which in turn requires resetting
		 * TX/RX buffers.  So just don't do anything for
		 * lost link.
		 */
		return;
	}

	/* Set full/half duplex mode. */
	if ((IFM_OPTIONS(mii->mii_media_active) & IFM_FDX) != 0) {
		SIS_SETBIT(sc, SIS_TX_CFG,
		    (SIS_TXCFG_IGN_HBEAT | SIS_TXCFG_IGN_CARR));
		SIS_SETBIT(sc, SIS_RX_CFG, SIS_RXCFG_RX_TXPKTS);
	} else {
		SIS_CLRBIT(sc, SIS_TX_CFG,
		    (SIS_TXCFG_IGN_HBEAT | SIS_TXCFG_IGN_CARR));
		SIS_CLRBIT(sc, SIS_RX_CFG, SIS_RXCFG_RX_TXPKTS);
	}

	if (sc->sis_type == SIS_TYPE_83815 && sc->sis_srr >= NS_SRR_16A) {
		/*
		 * MPII03.D: Half Duplex Excessive Collisions.
		 * Also page 49 in 83816 manual
		 */
		SIS_SETBIT(sc, SIS_TX_CFG, SIS_TXCFG_MPII03D);
	}

	/*
	 * Some DP83815s experience problems when used with short
	 * (< 30m/100ft) Ethernet cables in 100baseTX mode.  This
	 * sequence adjusts the DSP's signal attenuation to fix the
	 * problem.
	 */
	if (sc->sis_type == SIS_TYPE_83815 && sc->sis_srr < NS_SRR_16A &&
	    IFM_SUBTYPE(mii->mii_media_active) == IFM_100_TX) {
		uint32_t reg;

		CSR_WRITE_4(sc, NS_PHY_PAGE, 0x0001);
		reg = CSR_READ_4(sc, NS_PHY_DSPCFG) & 0xfff;
		CSR_WRITE_4(sc, NS_PHY_DSPCFG, reg | 0x1000);
		DELAY(100);
		reg = CSR_READ_4(sc, NS_PHY_TDATA) & 0xff;
		if ((reg & 0x0080) == 0 || (reg > 0xd8 && reg <= 0xff)) {
#ifdef DEBUG
			printf("%s: Applying short cable fix (reg=%x)\n",
			    sc->sc_dev.dv_xname, reg);
#endif
			CSR_WRITE_4(sc, NS_PHY_TDATA, 0x00e8);
			SIS_SETBIT(sc, NS_PHY_DSPCFG, 0x20);
		}
		CSR_WRITE_4(sc, NS_PHY_PAGE, 0);
	}
	/* Enable TX/RX MACs. */
	SIS_CLRBIT(sc, SIS_CSR, SIS_CSR_TX_DISABLE | SIS_CSR_RX_DISABLE);
	SIS_SETBIT(sc, SIS_CSR, SIS_CSR_TX_ENABLE | SIS_CSR_RX_ENABLE);
}

u_int32_t
sis_mchash(struct sis_softc *sc, const uint8_t *addr)
{
	uint32_t		crc;

	/* Compute CRC for the address value. */
	crc = ether_crc32_be(addr, ETHER_ADDR_LEN);

	/*
	 * return the filter bit position
	 *
	 * The NatSemi chip has a 512-bit filter, which is
	 * different than the SiS, so we special-case it.
	 */
	if (sc->sis_type == SIS_TYPE_83815)
		return (crc >> 23);
	else if (sc->sis_rev >= SIS_REV_635 ||
	    sc->sis_rev == SIS_REV_900B)
		return (crc >> 24);
	else
		return (crc >> 25);
}

void
sis_iff(struct sis_softc *sc)
{
	if (sc->sis_type == SIS_TYPE_83815)
		sis_iff_ns(sc);
	else
		sis_iff_sis(sc);
}

void
sis_iff_ns(struct sis_softc *sc)
{
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	struct arpcom		*ac = &sc->arpcom;
	struct ether_multi	*enm;
	struct ether_multistep  step;
	u_int32_t		h = 0, i, rxfilt;
	int			bit, index;

	rxfilt = CSR_READ_4(sc, SIS_RXFILT_CTL);
	if (rxfilt & SIS_RXFILTCTL_ENABLE) {
		/*
		 * Filter should be disabled to program other bits.
		 */
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, rxfilt & ~SIS_RXFILTCTL_ENABLE);
		CSR_READ_4(sc, SIS_RXFILT_CTL);
	}
	rxfilt &= ~(SIS_RXFILTCTL_ALLMULTI | SIS_RXFILTCTL_ALLPHYS |
	    NS_RXFILTCTL_ARP | SIS_RXFILTCTL_BROAD | NS_RXFILTCTL_MCHASH |
	    NS_RXFILTCTL_PERFECT);
	ifp->if_flags &= ~IFF_ALLMULTI;

	/*
	 * Always accept ARP frames.
	 * Always accept broadcast frames.
	 * Always accept frames destined to our station address.
	 */
	rxfilt |= NS_RXFILTCTL_ARP | SIS_RXFILTCTL_BROAD |
	    NS_RXFILTCTL_PERFECT;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		rxfilt |= SIS_RXFILTCTL_ALLMULTI;
		if (ifp->if_flags & IFF_PROMISC)
			rxfilt |= SIS_RXFILTCTL_ALLPHYS;
	} else {
		/*
		 * We have to explicitly enable the multicast hash table
		 * on the NatSemi chip if we want to use it, which we do.
		 */
		rxfilt |= NS_RXFILTCTL_MCHASH;

		/* first, zot all the existing hash bits */
		for (i = 0; i < 32; i++) {
			CSR_WRITE_4(sc, SIS_RXFILT_CTL, NS_FILTADDR_FMEM_LO + (i * 2));
			CSR_WRITE_4(sc, SIS_RXFILT_DATA, 0);
		}

		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = sis_mchash(sc, enm->enm_addrlo);

			index = h >> 3;
			bit = h & 0x1F;

			CSR_WRITE_4(sc, SIS_RXFILT_CTL, NS_FILTADDR_FMEM_LO + index);

			if (bit > 0xF)
				bit -= 0x10;

			SIS_SETBIT(sc, SIS_RXFILT_DATA, (1 << bit));

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	CSR_WRITE_4(sc, SIS_RXFILT_CTL, rxfilt);
	/* Turn the receive filter on. */
	CSR_WRITE_4(sc, SIS_RXFILT_CTL, rxfilt | SIS_RXFILTCTL_ENABLE);
	CSR_READ_4(sc, SIS_RXFILT_CTL);
}

void
sis_iff_sis(struct sis_softc *sc)
{
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	struct arpcom		*ac = &sc->arpcom;
	struct ether_multi	*enm;
	struct ether_multistep	step;
	u_int32_t		h, i, maxmulti, rxfilt;
	u_int16_t		hashes[16];

	/* hash table size */
	if (sc->sis_rev >= SIS_REV_635 ||
	    sc->sis_rev == SIS_REV_900B)
		maxmulti = 16;
	else
		maxmulti = 8;

	rxfilt = CSR_READ_4(sc, SIS_RXFILT_CTL);
	if (rxfilt & SIS_RXFILTCTL_ENABLE) {
		/*
		 * Filter should be disabled to program other bits.
		 */
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, rxfilt & ~SIS_RXFILTCTL_ENABLE);
		CSR_READ_4(sc, SIS_RXFILT_CTL);
	}
	rxfilt &= ~(SIS_RXFILTCTL_ALLMULTI | SIS_RXFILTCTL_ALLPHYS |
	    SIS_RXFILTCTL_BROAD);
	ifp->if_flags &= ~IFF_ALLMULTI;

	/*
	 * Always accept broadcast frames.
	 */
	rxfilt |= SIS_RXFILTCTL_BROAD;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0 ||
	    ac->ac_multicnt > maxmulti) {
		ifp->if_flags |= IFF_ALLMULTI;
		rxfilt |= SIS_RXFILTCTL_ALLMULTI;
		if (ifp->if_flags & IFF_PROMISC)
			rxfilt |= SIS_RXFILTCTL_ALLPHYS;

		for (i = 0; i < maxmulti; i++)
			hashes[i] = ~0;
	} else {
		for (i = 0; i < maxmulti; i++)
			hashes[i] = 0;

		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = sis_mchash(sc, enm->enm_addrlo);

			hashes[h >> 4] |= 1 << (h & 0xf);

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	for (i = 0; i < maxmulti; i++) {
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, (4 + i) << 16);
		CSR_WRITE_4(sc, SIS_RXFILT_DATA, hashes[i]);
	}

	CSR_WRITE_4(sc, SIS_RXFILT_CTL, rxfilt);
	/* Turn the receive filter on. */
	CSR_WRITE_4(sc, SIS_RXFILT_CTL, rxfilt | SIS_RXFILTCTL_ENABLE);
	CSR_READ_4(sc, SIS_RXFILT_CTL);
}

void
sis_reset(struct sis_softc *sc)
{
	int			i;

	SIS_SETBIT(sc, SIS_CSR, SIS_CSR_RESET);

	for (i = 0; i < SIS_TIMEOUT; i++) {
		if (!(CSR_READ_4(sc, SIS_CSR) & SIS_CSR_RESET))
			break;
	}

	if (i == SIS_TIMEOUT)
		printf("%s: reset never completed\n", sc->sc_dev.dv_xname);

	/* Wait a little while for the chip to get its brains in order. */
	DELAY(1000);

	/*
	 * If this is a NetSemi chip, make sure to clear
	 * PME mode.
	 */
	if (sc->sis_type == SIS_TYPE_83815) {
		CSR_WRITE_4(sc, NS_CLKRUN, NS_CLKRUN_PMESTS);
		CSR_WRITE_4(sc, NS_CLKRUN, 0);
	}
}

/*
 * Probe for an SiS chip. Check the PCI vendor and device
 * IDs against our list and return a device name if we find a match.
 */
int
sis_probe(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, sis_devices,
	    nitems(sis_devices)));
}

/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
void
sis_attach(struct device *parent, struct device *self, void *aux)
{
	int			i;
	const char		*intrstr = NULL;
	struct sis_softc	*sc = (struct sis_softc *)self;
	struct pci_attach_args	*pa = aux;
	pci_chipset_tag_t	pc = pa->pa_pc;
	pci_intr_handle_t	ih;
	struct ifnet		*ifp;
	bus_size_t		size;

	sc->sis_stopped = 1;

	pci_set_powerstate(pa->pa_pc, pa->pa_tag, PCI_PMCSR_STATE_D0);

	/*
	 * Map control/status registers.
	 */

#ifdef SIS_USEIOSPACE
	if (pci_mapreg_map(pa, SIS_PCI_LOIO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->sis_btag, &sc->sis_bhandle, NULL, &size, 0)) {
		printf(": can't map i/o space\n");
		return;
 	}
#else
	if (pci_mapreg_map(pa, SIS_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->sis_btag, &sc->sis_bhandle, NULL, &size, 0)) {
 		printf(": can't map mem space\n");
		return;
 	}
#endif

	/* Allocate interrupt */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		goto fail_1;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, sis_intr, sc,
	    self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail_1;
	}

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_SIS_900:
		sc->sis_type = SIS_TYPE_900;
		break;
	case PCI_PRODUCT_SIS_7016:
		sc->sis_type = SIS_TYPE_7016;
		break;
	case PCI_PRODUCT_NS_DP83815:
		sc->sis_type = SIS_TYPE_83815;
		break;
	default:
		break;
	}
	sc->sis_rev = PCI_REVISION(pa->pa_class);

	/* Reset the adapter. */
	sis_reset(sc);

	if (sc->sis_type == SIS_TYPE_900 &&
	   (sc->sis_rev == SIS_REV_635 ||
	    sc->sis_rev == SIS_REV_900B)) {
		SIO_SET(SIS_CFG_RND_CNT);
		SIO_SET(SIS_CFG_PERR_DETECT);
	}

	/*
	 * Get station address from the EEPROM.
	 */
	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_NS:
		sc->sis_srr = CSR_READ_4(sc, NS_SRR);

		if (sc->sis_srr == NS_SRR_15C)
			printf(", DP83815C");
		else if (sc->sis_srr == NS_SRR_15D)
			printf(", DP83815D");
		else if (sc->sis_srr == NS_SRR_16A)
			printf(", DP83816A");
		else
			printf(", srr %x", sc->sis_srr);

		/*
		 * Reading the MAC address out of the EEPROM on
		 * the NatSemi chip takes a bit more work than
		 * you'd expect. The address spans 4 16-bit words,
		 * with the first word containing only a single bit.
		 * You have to shift everything over one bit to
		 * get it aligned properly. Also, the bits are
		 * stored backwards (the LSB is really the MSB,
		 * and so on) so you have to reverse them in order
		 * to get the MAC address into the form we want.
		 * Why? Who the hell knows.
		 */
		{
			u_int16_t		tmp[4];

			sis_read_eeprom(sc, (caddr_t)&tmp, NS_EE_NODEADDR,
			    4, 0);

			/* Shift everything over one bit. */
			tmp[3] = tmp[3] >> 1;
			tmp[3] |= tmp[2] << 15;
			tmp[2] = tmp[2] >> 1;
			tmp[2] |= tmp[1] << 15;
			tmp[1] = tmp[1] >> 1;
			tmp[1] |= tmp[0] << 15;

			/* Now reverse all the bits. */
			tmp[3] = letoh16(sis_reverse(tmp[3]));
			tmp[2] = letoh16(sis_reverse(tmp[2]));
			tmp[1] = letoh16(sis_reverse(tmp[1]));

			bcopy(&tmp[1], sc->arpcom.ac_enaddr,
			    ETHER_ADDR_LEN);
		}
		break;
	case PCI_VENDOR_SIS:
	default:
#if defined(__amd64__) || defined(__i386__)
		/*
		 * If this is a SiS 630E chipset with an embedded
		 * SiS 900 controller, we have to read the MAC address
		 * from the APC CMOS RAM. Our method for doing this
		 * is very ugly since we have to reach out and grab
		 * ahold of hardware for which we cannot properly
		 * allocate resources. This code is only compiled on
		 * the i386 architecture since the SiS 630E chipset
		 * is for x86 motherboards only. Note that there are
		 * a lot of magic numbers in this hack. These are
		 * taken from SiS's Linux driver. I'd like to replace
		 * them with proper symbolic definitions, but that
		 * requires some datasheets that I don't have access
		 * to at the moment.
		 */
		if (sc->sis_rev == SIS_REV_630S ||
		    sc->sis_rev == SIS_REV_630E)
			sis_read_cmos(sc, pa, (caddr_t)&sc->arpcom.ac_enaddr,
			    0x9, 6);
		else
#endif
		if (sc->sis_rev == SIS_REV_96x)
			sis_read96x_mac(sc);
		else if (sc->sis_rev == SIS_REV_635 ||
		    sc->sis_rev == SIS_REV_630ET ||
		    sc->sis_rev == SIS_REV_630EA1)
			sis_read_mac(sc, pa);
		else
			sis_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
			    SIS_EE_NODEADDR, 3, 1);
		break;
	}

	printf(": %s, address %s\n", intrstr,
	    ether_sprintf(sc->arpcom.ac_enaddr));

	sc->sc_dmat = pa->pa_dmat;

	if (bus_dmamem_alloc(sc->sc_dmat, sizeof(struct sis_list_data),
	    PAGE_SIZE, 0, sc->sc_listseg, 1, &sc->sc_listnseg,
	    BUS_DMA_NOWAIT | BUS_DMA_ZERO) != 0) {
		printf(": can't alloc list mem\n");
		goto fail_2;
	}
	if (bus_dmamem_map(sc->sc_dmat, sc->sc_listseg, sc->sc_listnseg,
	    sizeof(struct sis_list_data), &sc->sc_listkva,
	    BUS_DMA_NOWAIT) != 0) {
		printf(": can't map list mem\n");
		goto fail_2;
	}
	if (bus_dmamap_create(sc->sc_dmat, sizeof(struct sis_list_data), 1,
	    sizeof(struct sis_list_data), 0, BUS_DMA_NOWAIT,
	    &sc->sc_listmap) != 0) {
		printf(": can't alloc list map\n");
		goto fail_2;
	}
	if (bus_dmamap_load(sc->sc_dmat, sc->sc_listmap, sc->sc_listkva,
	    sizeof(struct sis_list_data), NULL, BUS_DMA_NOWAIT) != 0) {
		printf(": can't load list map\n");
		goto fail_2;
	}
	sc->sis_ldata = (struct sis_list_data *)sc->sc_listkva;

	for (i = 0; i < SIS_RX_LIST_CNT; i++) {
		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES, 0,
		    BUS_DMA_NOWAIT, &sc->sis_ldata->sis_rx_list[i].map) != 0) {
			printf(": can't create rx map\n");
			goto fail_2;
		}
	}

	for (i = 0; i < SIS_TX_LIST_CNT; i++) {
		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    SIS_MAXTXSEGS, MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &sc->sis_ldata->sis_tx_list[i].map) != 0) {
			printf(": can't create tx map\n");
			goto fail_2;
		}
	}
	if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, SIS_MAXTXSEGS,
	    MCLBYTES, 0, BUS_DMA_NOWAIT, &sc->sc_tx_sparemap) != 0) {
		printf(": can't create tx spare map\n");
		goto fail_2;
	}

	timeout_set(&sc->sis_timeout, sis_tick, sc);

	ifp = &sc->arpcom.ac_if;
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = sis_ioctl;
	ifp->if_start = sis_start;
	ifp->if_watchdog = sis_watchdog;
	IFQ_SET_MAXLEN(&ifp->if_snd, SIS_TX_LIST_CNT - 1);
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_hardmtu = 1518; /* determined experimentally on DP83815 */

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = sis_miibus_readreg;
	sc->sc_mii.mii_writereg = sis_miibus_writereg;
	sc->sc_mii.mii_statchg = sis_miibus_statchg;
	ifmedia_init(&sc->sc_mii.mii_media, 0, sis_ifmedia_upd,sis_ifmedia_sts);
	mii_attach(self, &sc->sc_mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY,
	    0);
	if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE, 0, NULL);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);
	} else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);
	return;

fail_2:
	pci_intr_disestablish(pc, sc->sc_ih);

fail_1:
	bus_space_unmap(sc->sis_btag, sc->sis_bhandle, size);
}

int
sis_activate(struct device *self, int act)
{
	struct sis_softc *sc = (struct sis_softc *)self;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	int rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			sis_stop(sc);
		rv = config_activate_children(self, act);
		break;
	case DVACT_RESUME:
		if (ifp->if_flags & IFF_UP)
			sis_init(sc);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

/*
 * Initialize the TX and RX descriptors and allocate mbufs for them. Note that
 * we arrange the descriptors in a closed ring, so that the last descriptor
 * points back to the first.
 */
int
sis_ring_init(struct sis_softc *sc)
{
	struct sis_list_data	*ld;
	struct sis_ring_data	*cd;
	int			i, nexti;

	cd = &sc->sis_cdata;
	ld = sc->sis_ldata;

	for (i = 0; i < SIS_TX_LIST_CNT; i++) {
		if (i == (SIS_TX_LIST_CNT - 1))
			nexti = 0;
		else
			nexti = i + 1;
		ld->sis_tx_list[i].sis_nextdesc = &ld->sis_tx_list[nexti];
		ld->sis_tx_list[i].sis_next =
		    htole32(sc->sc_listmap->dm_segs[0].ds_addr +
		      offsetof(struct sis_list_data, sis_tx_list[nexti]));
		ld->sis_tx_list[i].sis_mbuf = NULL;
		ld->sis_tx_list[i].sis_ptr = 0;
		ld->sis_tx_list[i].sis_ctl = 0;
	}

	cd->sis_tx_prod = cd->sis_tx_cons = cd->sis_tx_cnt = 0;

	for (i = 0; i < SIS_RX_LIST_CNT; i++) {
		if (i == SIS_RX_LIST_CNT - 1)
			nexti = 0;
		else
			nexti = i + 1;
		ld->sis_rx_list[i].sis_nextdesc = &ld->sis_rx_list[nexti];
		ld->sis_rx_list[i].sis_next =
		    htole32(sc->sc_listmap->dm_segs[0].ds_addr +
		      offsetof(struct sis_list_data, sis_rx_list[nexti]));
		ld->sis_rx_list[i].sis_ctl = 0;
	}

	cd->sis_rx_prod = cd->sis_rx_cons;
	if_rxr_init(&cd->sis_rx_ring, 2, SIS_RX_LIST_CNT - 1);
	sis_fill_rx_ring(sc);

	return (0);
}

void
sis_fill_rx_ring(struct sis_softc *sc)
{
	struct sis_list_data    *ld;
	struct sis_ring_data    *cd;
	u_int			slots;

	cd = &sc->sis_cdata;
	ld = sc->sis_ldata;

	for (slots = if_rxr_get(&cd->sis_rx_ring, SIS_RX_LIST_CNT);
	    slots > 0; slots--) {
		if (sis_newbuf(sc, &ld->sis_rx_list[cd->sis_rx_prod]))
			break;

		SIS_INC(cd->sis_rx_prod, SIS_RX_LIST_CNT);
	}
	if_rxr_put(&cd->sis_rx_ring, slots);
}

/*
 * Initialize an RX descriptor and attach an MBUF cluster.
 */
int
sis_newbuf(struct sis_softc *sc, struct sis_desc *c)
{
	struct mbuf		*m_new = NULL;

	if (c == NULL)
		return (EINVAL);

	m_new = MCLGETI(NULL, M_DONTWAIT, NULL, MCLBYTES);
	if (!m_new)
		return (ENOBUFS);

	m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;

	if (bus_dmamap_load_mbuf(sc->sc_dmat, c->map, m_new,
	    BUS_DMA_NOWAIT)) {
		m_free(m_new);
		return (ENOBUFS);
	}

	bus_dmamap_sync(sc->sc_dmat, c->map, 0, c->map->dm_mapsize,
	    BUS_DMASYNC_PREREAD);

	c->sis_mbuf = m_new;
	c->sis_ptr = htole32(c->map->dm_segs[0].ds_addr);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    ((caddr_t)c - sc->sc_listkva), sizeof(struct sis_desc),
	    BUS_DMASYNC_PREWRITE);

	c->sis_ctl = htole32(ETHER_MAX_DIX_LEN);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    ((caddr_t)c - sc->sc_listkva), sizeof(struct sis_desc),
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	return (0);
}

/*
 * A frame has been uploaded: pass the resulting mbuf chain up to
 * the higher level protocols.
 */
void
sis_rxeof(struct sis_softc *sc)
{
	struct mbuf_list	ml = MBUF_LIST_INITIALIZER();
	struct mbuf		*m;
	struct ifnet		*ifp;
	struct sis_desc		*cur_rx;
	int			total_len = 0;
	u_int32_t		rxstat;

	ifp = &sc->arpcom.ac_if;

	while (if_rxr_inuse(&sc->sis_cdata.sis_rx_ring) > 0) {
		cur_rx = &sc->sis_ldata->sis_rx_list[sc->sis_cdata.sis_rx_cons];
		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
		    ((caddr_t)cur_rx - sc->sc_listkva),
		    sizeof(struct sis_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		if (!SIS_OWNDESC(cur_rx))
			break;

		rxstat = letoh32(cur_rx->sis_rxstat);
		m = cur_rx->sis_mbuf;
		cur_rx->sis_mbuf = NULL;
		total_len = SIS_RXBYTES(cur_rx);
		/* from here on the buffer is consumed */
		SIS_INC(sc->sis_cdata.sis_rx_cons, SIS_RX_LIST_CNT);
		if_rxr_put(&sc->sis_cdata.sis_rx_ring, 1);

		/*
		 * DP83816A sometimes produces zero-length packets
		 * shortly after initialisation.
		 */
		if (total_len == 0) {
			m_freem(m);
			continue;
		}

		/* The ethernet CRC is always included */
		total_len -= ETHER_CRC_LEN;

		/*
		 * If an error occurs, update stats, clear the
		 * status word and leave the mbuf cluster in place:
		 * it should simply get re-used next time this descriptor
	 	 * comes up in the ring. However, don't report long
		 * frames as errors since they could be VLANs.
		 */
		if (rxstat & SIS_RXSTAT_GIANT &&
		    total_len <= (ETHER_MAX_DIX_LEN - ETHER_CRC_LEN))
			rxstat &= ~SIS_RXSTAT_GIANT;
		if (SIS_RXSTAT_ERROR(rxstat)) {
			ifp->if_ierrors++;
			if (rxstat & SIS_RXSTAT_COLL)
				ifp->if_collisions++;
			m_freem(m);
			continue;
		}

		/* No errors; receive the packet. */
		bus_dmamap_sync(sc->sc_dmat, cur_rx->map, 0,
		    cur_rx->map->dm_mapsize, BUS_DMASYNC_POSTREAD);
#ifdef __STRICT_ALIGNMENT
		/*
		 * On some architectures, we do not have alignment problems,
		 * so try to allocate a new buffer for the receive ring, and
		 * pass up the one where the packet is already, saving the
		 * expensive copy done in m_devget().
		 * If we are on an architecture with alignment problems, or
		 * if the allocation fails, then use m_devget and leave the
		 * existing buffer in the receive ring.
		 */
		{
			struct mbuf *m0;
			m0 = m_devget(mtod(m, char *), total_len, ETHER_ALIGN);
			m_freem(m);
			if (m0 == NULL) {
				ifp->if_ierrors++;
				continue;
			}
			m = m0;
		}
#else
		m->m_pkthdr.len = m->m_len = total_len;
#endif

		ml_enqueue(&ml, m);
	}

	if_input(ifp, &ml);

	sis_fill_rx_ring(sc);
}

/*
 * A frame was downloaded to the chip. It's safe for us to clean up
 * the list buffers.
 */

void
sis_txeof(struct sis_softc *sc)
{
	struct ifnet		*ifp;
	u_int32_t		idx, ctl, txstat;

	ifp = &sc->arpcom.ac_if;

	/*
	 * Go through our tx list and free mbufs for those
	 * frames that have been transmitted.
	 */
	for (idx = sc->sis_cdata.sis_tx_cons; sc->sis_cdata.sis_tx_cnt > 0;
	    sc->sis_cdata.sis_tx_cnt--, SIS_INC(idx, SIS_TX_LIST_CNT)) {
		struct sis_desc *cur_tx = &sc->sis_ldata->sis_tx_list[idx];

		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
		    ((caddr_t)cur_tx - sc->sc_listkva),
		    sizeof(struct sis_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

		if (SIS_OWNDESC(cur_tx))
			break;

		ctl = letoh32(cur_tx->sis_ctl);

		if (ctl & SIS_CMDSTS_MORE)
			continue;

		txstat = letoh32(cur_tx->sis_txstat);

		if (!(ctl & SIS_CMDSTS_PKT_OK)) {
			ifp->if_oerrors++;
			if (txstat & SIS_TXSTAT_EXCESSCOLLS)
				ifp->if_collisions++;
			if (txstat & SIS_TXSTAT_OUTOFWINCOLL)
				ifp->if_collisions++;
		}

		ifp->if_collisions += (txstat & SIS_TXSTAT_COLLCNT) >> 16;

		if (cur_tx->map->dm_nsegs != 0) {
			bus_dmamap_t map = cur_tx->map;

			bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, map);
		}
		if (cur_tx->sis_mbuf != NULL) {
			m_freem(cur_tx->sis_mbuf);
			cur_tx->sis_mbuf = NULL;
		}
	}

	if (idx != sc->sis_cdata.sis_tx_cons) {
		/* we freed up some buffers */
		sc->sis_cdata.sis_tx_cons = idx;
		ifq_clr_oactive(&ifp->if_snd);
	}

	ifp->if_timer = (sc->sis_cdata.sis_tx_cnt == 0) ? 0 : 5;
}

void
sis_tick(void *xsc)
{
	struct sis_softc	*sc = (struct sis_softc *)xsc;
	struct mii_data		*mii;
	int			s;

	s = splnet();

	mii = &sc->sc_mii;
	mii_tick(mii);

	if (!sc->sis_link)
		sis_miibus_statchg(&sc->sc_dev);
	
	timeout_add_sec(&sc->sis_timeout, 1);

	splx(s);
}

int
sis_intr(void *arg)
{
	struct sis_softc	*sc = arg;
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	u_int32_t		status;

	if (sc->sis_stopped)	/* Most likely shared interrupt */
		return (0);

	/* Reading the ISR register clears all interrupts. */
	status = CSR_READ_4(sc, SIS_ISR);
	if ((status & SIS_INTRS) == 0)
		return (0);

	if (status &
	    (SIS_ISR_TX_DESC_OK | SIS_ISR_TX_ERR |
	     SIS_ISR_TX_OK | SIS_ISR_TX_IDLE))
		sis_txeof(sc);

	if (status &
	    (SIS_ISR_RX_DESC_OK | SIS_ISR_RX_OK |
	     SIS_ISR_RX_ERR | SIS_ISR_RX_IDLE))
		sis_rxeof(sc);

	if (status & (SIS_ISR_RX_IDLE)) {
		/* consume what's there so that sis_rx_cons points
		 * to the first HW owned descriptor. */
		sis_rxeof(sc);
		/* reprogram the RX listptr */
		CSR_WRITE_4(sc, SIS_RX_LISTPTR,
		    sc->sc_listmap->dm_segs[0].ds_addr +
		    offsetof(struct sis_list_data,
		    sis_rx_list[sc->sis_cdata.sis_rx_cons]));
	}

	if (status & SIS_ISR_SYSERR)
		sis_init(sc);

	/*
	 * XXX: Re-enable RX engine every time otherwise it occasionally
	 * stops under unknown circumstances.
	 */
	SIS_SETBIT(sc, SIS_CSR, SIS_CSR_RX_ENABLE);

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		sis_start(ifp);

	return (1);
}

/*
 * Encapsulate an mbuf chain in a descriptor by coupling the mbuf data
 * pointers to the fragment pointers.
 */
int
sis_encap(struct sis_softc *sc, struct mbuf *m_head, u_int32_t *txidx)
{
	struct sis_desc		*f = NULL;
	bus_dmamap_t		map;
	int			frag, cur, i, error;

	map = sc->sc_tx_sparemap;

	error = bus_dmamap_load_mbuf(sc->sc_dmat, map, m_head,
	    BUS_DMA_NOWAIT);
	switch (error) {
	case 0:
		break;

	case EFBIG:
		if (m_defrag(m_head, M_DONTWAIT) == 0 &&
		    bus_dmamap_load_mbuf(sc->sc_dmat, map, m_head,
		    BUS_DMA_NOWAIT) == 0)
			break;

		/* FALLTHROUGH */
	default:
		return (ENOBUFS);
	}

	if ((SIS_TX_LIST_CNT - (sc->sis_cdata.sis_tx_cnt + map->dm_nsegs)) < 2) {
		bus_dmamap_unload(sc->sc_dmat, map);
		return (ENOBUFS);
	}

	/*
 	 * Start packing the mbufs in this chain into
	 * the fragment pointers. Stop when we run out
 	 * of fragments or hit the end of the mbuf chain.
	 */
	cur = frag = *txidx;

	for (i = 0; i < map->dm_nsegs; i++) {
		f = &sc->sis_ldata->sis_tx_list[frag];
		f->sis_ctl = htole32(SIS_CMDSTS_MORE | map->dm_segs[i].ds_len);
		f->sis_ptr = htole32(map->dm_segs[i].ds_addr);
		if (i != 0)
			f->sis_ctl |= htole32(SIS_CMDSTS_OWN);
		cur = frag;
		SIS_INC(frag, SIS_TX_LIST_CNT);
	}

	bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	sc->sis_ldata->sis_tx_list[cur].sis_mbuf = m_head;
	sc->sis_ldata->sis_tx_list[cur].sis_ctl &= ~htole32(SIS_CMDSTS_MORE);
	sc->sis_ldata->sis_tx_list[*txidx].sis_ctl |= htole32(SIS_CMDSTS_OWN);
	sc->sis_cdata.sis_tx_cnt += map->dm_nsegs;
	*txidx = frag;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    offsetof(struct sis_list_data, sis_tx_list[0]),
	    sizeof(struct sis_desc) * SIS_TX_LIST_CNT,  
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	return (0);
}

/*
 * Main transmit routine. To avoid having to do mbuf copies, we put pointers
 * to the mbuf data regions directly in the transmit lists. We also save a
 * copy of the pointers since the transmit list fragment pointers are
 * physical addresses.
 */

void
sis_start(struct ifnet *ifp)
{
	struct sis_softc	*sc;
	struct mbuf		*m_head = NULL;
	u_int32_t		idx, queued = 0;

	sc = ifp->if_softc;

	if (!sc->sis_link)
		return;

	idx = sc->sis_cdata.sis_tx_prod;

	if (ifq_is_oactive(&ifp->if_snd))
		return;

	while(sc->sis_ldata->sis_tx_list[idx].sis_mbuf == NULL) {
		m_head = ifq_deq_begin(&ifp->if_snd);
		if (m_head == NULL)
			break;

		if (sis_encap(sc, m_head, &idx)) {
			ifq_deq_rollback(&ifp->if_snd, m_head);
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		/* now we are committed to transmit the packet */
		ifq_deq_commit(&ifp->if_snd, m_head);

		queued++;

		/*
		 * If there's a BPF listener, bounce a copy of this frame
		 * to him.
		 */
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif
	}

	if (queued) {
		/* Transmit */
		sc->sis_cdata.sis_tx_prod = idx;
		SIS_SETBIT(sc, SIS_CSR, SIS_CSR_TX_ENABLE);

		/*
		 * Set a timeout in case the chip goes out to lunch.
		 */
		ifp->if_timer = 5;
	}
}

void
sis_init(void *xsc)
{
	struct sis_softc	*sc = (struct sis_softc *)xsc;
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	struct mii_data		*mii;
	int			s;

	s = splnet();

	/*
	 * Cancel pending I/O and free all RX/TX buffers.
	 */
	sis_stop(sc);

	/*
	 * Reset the chip to a known state.
	 */
	sis_reset(sc);

#if NS_IHR_DELAY > 0
	/* Configure interrupt holdoff register. */
	if (sc->sis_type == SIS_TYPE_83815 && sc->sis_srr == NS_SRR_16A)
		CSR_WRITE_4(sc, NS_IHR, NS_IHR_VALUE);
#endif

	mii = &sc->sc_mii;

	/* Set MAC address */
	if (sc->sis_type == SIS_TYPE_83815) {
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, NS_FILTADDR_PAR0);
		CSR_WRITE_4(sc, SIS_RXFILT_DATA,
		    htole16(((u_int16_t *)sc->arpcom.ac_enaddr)[0]));
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, NS_FILTADDR_PAR1);
		CSR_WRITE_4(sc, SIS_RXFILT_DATA,
		    htole16(((u_int16_t *)sc->arpcom.ac_enaddr)[1]));
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, NS_FILTADDR_PAR2);
		CSR_WRITE_4(sc, SIS_RXFILT_DATA,
		    htole16(((u_int16_t *)sc->arpcom.ac_enaddr)[2]));
	} else {
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, SIS_FILTADDR_PAR0);
		CSR_WRITE_4(sc, SIS_RXFILT_DATA,
		    htole16(((u_int16_t *)sc->arpcom.ac_enaddr)[0]));
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, SIS_FILTADDR_PAR1);
		CSR_WRITE_4(sc, SIS_RXFILT_DATA,
		    htole16(((u_int16_t *)sc->arpcom.ac_enaddr)[1]));
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, SIS_FILTADDR_PAR2);
		CSR_WRITE_4(sc, SIS_RXFILT_DATA,
		    htole16(((u_int16_t *)sc->arpcom.ac_enaddr)[2]));
	}

	/* Init circular TX/RX lists. */
	if (sis_ring_init(sc) != 0) {
		printf("%s: initialization failed: no memory for rx buffers\n",
		    sc->sc_dev.dv_xname);
		sis_stop(sc);
		splx(s);
		return;
	}

        /*
	 * Page 78 of the DP83815 data sheet (september 2002 version)
	 * recommends the following register settings "for optimum
	 * performance." for rev 15C.  The driver from NS also sets
	 * the PHY_CR register for later versions.
	 *
	 * This resolves an issue with tons of errors in AcceptPerfectMatch
	 * (non-IFF_PROMISC) mode.
	 */
	 if (sc->sis_type == SIS_TYPE_83815 && sc->sis_srr <= NS_SRR_15D) {
		CSR_WRITE_4(sc, NS_PHY_PAGE, 0x0001);
		CSR_WRITE_4(sc, NS_PHY_CR, 0x189C);
		/* set val for c2 */
		CSR_WRITE_4(sc, NS_PHY_TDATA, 0x0000);
		/* load/kill c2 */
		CSR_WRITE_4(sc, NS_PHY_DSPCFG, 0x5040);
		/* raise SD off, from 4 to c */
		CSR_WRITE_4(sc, NS_PHY_SDCFG, 0x008C);
		CSR_WRITE_4(sc, NS_PHY_PAGE, 0);
	}

	/*
	 * Program promiscuous mode and multicast filters.
	 */
	sis_iff(sc);

	/*
	 * Load the address of the RX and TX lists.
	 */
	CSR_WRITE_4(sc, SIS_RX_LISTPTR, sc->sc_listmap->dm_segs[0].ds_addr +
	    offsetof(struct sis_list_data, sis_rx_list[0]));
	CSR_WRITE_4(sc, SIS_TX_LISTPTR, sc->sc_listmap->dm_segs[0].ds_addr +
	    offsetof(struct sis_list_data, sis_tx_list[0]));

	/* SIS_CFG_EDB_MASTER_EN indicates the EDB bus is used instead of
	 * the PCI bus. When this bit is set, the Max DMA Burst Size
	 * for TX/RX DMA should be no larger than 16 double words.
	 */
	if (CSR_READ_4(sc, SIS_CFG) & SIS_CFG_EDB_MASTER_EN)
		CSR_WRITE_4(sc, SIS_RX_CFG, SIS_RXCFG64);
	else
		CSR_WRITE_4(sc, SIS_RX_CFG, SIS_RXCFG256);

	/* Accept Long Packets for VLAN support */
	SIS_SETBIT(sc, SIS_RX_CFG, SIS_RXCFG_RX_JABBER);

	/*
	 * Assume 100Mbps link, actual MAC configuration is done
	 * after getting a valid link.
	 */
	CSR_WRITE_4(sc, SIS_TX_CFG, SIS_TXCFG_100);

	/*
	 * Enable interrupts.
	 */
	CSR_WRITE_4(sc, SIS_IMR, SIS_INTRS);
	CSR_WRITE_4(sc, SIS_IER, 1);

	/* Clear MAC disable. */
	SIS_CLRBIT(sc, SIS_CSR, SIS_CSR_TX_DISABLE | SIS_CSR_RX_DISABLE);

	sc->sis_link = 0;
	mii_mediachg(mii);

	sc->sis_stopped = 0;
	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);

	timeout_add_sec(&sc->sis_timeout, 1);
}

/*
 * Set media options.
 */
int
sis_ifmedia_upd(struct ifnet *ifp)
{
	struct sis_softc	*sc;
	struct mii_data		*mii;

	sc = ifp->if_softc;

	mii = &sc->sc_mii;
	if (mii->mii_instance) {
		struct mii_softc	*miisc;
		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
			mii_phy_reset(miisc);
	}
	mii_mediachg(mii);

	return (0);
}

/*
 * Report current media status.
 */
void
sis_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct sis_softc	*sc;
	struct mii_data		*mii;

	sc = ifp->if_softc;

	mii = &sc->sc_mii;
	mii_pollstat(mii);
	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;
}

int
sis_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct sis_softc	*sc = ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *) data;
	struct mii_data		*mii;
	int			s, error = 0;

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			sis_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				sis_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				sis_stop(sc);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		mii = &sc->sc_mii;
		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);
		break;

	case SIOCGIFRXR:
		error = if_rxr_ioctl((struct if_rxrinfo *)ifr->ifr_data,
		    NULL, MCLBYTES, &sc->sis_cdata.sis_rx_ring);
		break;

	default:
		error = ether_ioctl(ifp, &sc->arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			sis_iff(sc);
		error = 0;
	}

	splx(s);
	return(error);
}

void
sis_watchdog(struct ifnet *ifp)
{
	struct sis_softc	*sc;
	int			s;

	sc = ifp->if_softc;

	if (sc->sis_stopped)
		return;

	ifp->if_oerrors++;
	printf("%s: watchdog timeout\n", sc->sc_dev.dv_xname);

	s = splnet();
	sis_init(sc);

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		sis_start(ifp);

	splx(s);
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void
sis_stop(struct sis_softc *sc)
{
	int			i;
	struct ifnet		*ifp;

	if (sc->sis_stopped)
		return;

	ifp = &sc->arpcom.ac_if;
	ifp->if_timer = 0;

	timeout_del(&sc->sis_timeout);

	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	sc->sis_stopped = 1;

	CSR_WRITE_4(sc, SIS_IER, 0);
	CSR_WRITE_4(sc, SIS_IMR, 0);
	CSR_READ_4(sc, SIS_ISR); /* clear any interrupts already pending */
	SIS_SETBIT(sc, SIS_CSR, SIS_CSR_TX_DISABLE | SIS_CSR_RX_DISABLE);
	DELAY(1000);
	CSR_WRITE_4(sc, SIS_TX_LISTPTR, 0);
	CSR_WRITE_4(sc, SIS_RX_LISTPTR, 0);

	sc->sis_link = 0;

	/*
	 * Free data in the RX lists.
	 */
	for (i = 0; i < SIS_RX_LIST_CNT; i++) {
		if (sc->sis_ldata->sis_rx_list[i].map->dm_nsegs != 0) {
			bus_dmamap_t map = sc->sis_ldata->sis_rx_list[i].map;

			bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
			    BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->sc_dmat, map);
		}
		if (sc->sis_ldata->sis_rx_list[i].sis_mbuf != NULL) {
			m_freem(sc->sis_ldata->sis_rx_list[i].sis_mbuf);
			sc->sis_ldata->sis_rx_list[i].sis_mbuf = NULL;
		}
		bzero(&sc->sis_ldata->sis_rx_list[i],
		    sizeof(struct sis_desc) - sizeof(bus_dmamap_t));
	}

	/*
	 * Free the TX list buffers.
	 */
	for (i = 0; i < SIS_TX_LIST_CNT; i++) {
		if (sc->sis_ldata->sis_tx_list[i].map->dm_nsegs != 0) {
			bus_dmamap_t map = sc->sis_ldata->sis_tx_list[i].map;

			bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, map);
		}
		if (sc->sis_ldata->sis_tx_list[i].sis_mbuf != NULL) {
			m_freem(sc->sis_ldata->sis_tx_list[i].sis_mbuf);
			sc->sis_ldata->sis_tx_list[i].sis_mbuf = NULL;
		}
		bzero(&sc->sis_ldata->sis_tx_list[i],
		    sizeof(struct sis_desc) - sizeof(bus_dmamap_t));
	}
}
@


1.134
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.133 2016/01/08 11:23:30 mpi Exp $ */
a1500 1
		ifp->if_opackets++;
@


1.133
log
@Work around buggy zero-length packets produced by the DP83816A.

From Nathanael Rensen, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.132 2015/11/25 03:09:59 dlg Exp $ */
a1188 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.132
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.131 2015/11/24 17:11:39 mpi Exp $ */
d1390 12
@


1.131
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.130 2015/11/24 13:33:17 mpi Exp $ */
d1507 1
a1507 1
		ifp->if_flags &= ~IFF_OACTIVE;
d1674 1
a1674 1
	if (ifp->if_flags & IFF_OACTIVE)
d1684 1
a1684 1
			ifp->if_flags |= IFF_OACTIVE;
d1841 1
a1841 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1982 2
a1983 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.130
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.129 2015/11/20 03:35:23 dlg Exp $ */
a74 1
#include <net/if_dl.h>
@


1.129
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.128 2015/10/25 13:04:28 mpi Exp $ */
a75 1
#include <net/if_types.h>
@


1.128
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.127 2015/06/24 09:40:54 mpi Exp $ */
d1680 1
a1680 1
		IFQ_POLL(&ifp->if_snd, m_head);
d1685 1
d1691 1
a1691 1
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.127
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.126 2015/04/13 08:45:48 mpi Exp $ */
a1891 1
	struct ifaddr		*ifa = (struct ifaddr *) data;
a1902 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->arpcom, ifa);
@


1.126
log
@Now that if_input() set the receiving interface pointer on mbufs for us
there's no need to do it in m_devget(9).

Stop passing an ``ifp'' will help for upcoming interface pointer -> index
conversion.

While here remove unused ``ifp'' argument from m_clget(9) and kill two
birds^W layer violations in one commit.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.125 2015/03/30 10:01:21 mpi Exp $ */
a1436 1
		ifp->if_ipackets++;
@


1.125
log
@Convert to if_input().

Tested by sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.124 2015/03/14 03:38:48 jsg Exp $ */
d1426 1
a1426 2
			m0 = m_devget(mtod(m, char *), total_len, ETHER_ALIGN,
			    ifp);
@


1.124
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.123 2015/02/11 21:36:02 brad Exp $ */
d1367 1
a1435 1
		m->m_pkthdr.rcvif = ifp;
d1440 2
a1441 4
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
d1443 1
a1443 3
		/* pass it on. */
		ether_input_mbuf(ifp, m);
	}
@


1.123
log
@- Make use of m_defrag().
- Lower the max # of TX DMA segments from close to the whole ring down
  to a more sensible value. From FreeBSD
- Move the TX ring full check out of and above the for loop.
- Use dm_nsegs to provide the total # of DMA segments instead of the
  value from the for loop.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.122 2015/01/06 04:05:43 brad Exp $ */
a88 1
#include <dev/mii/mii.h>
@


1.122
log
@Always enable the receive filter. It was being enabled via sis_init()
but not if calling sis_iff() via sis_ioctl().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.121 2014/12/22 02:28:52 tedu Exp $ */
d1171 1
a1171 1
		    SIS_TX_LIST_CNT - 3, MCLBYTES, 0, BUS_DMA_NOWAIT,
d1177 1
a1177 1
	if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, SIS_TX_LIST_CNT - 3,
a1600 1
	int			frag, cur, i;
d1602 1
d1605 15
a1619 2
	if (bus_dmamap_load_mbuf(sc->sc_dmat, map,
	    m_head, BUS_DMA_NOWAIT) != 0)
d1621 6
a1635 2
		if ((SIS_TX_LIST_CNT - (sc->sis_cdata.sis_tx_cnt + i)) < 2)
			return(ENOBUFS);
d1651 1
a1651 1
	sc->sis_cdata.sis_tx_cnt += i;
@


1.121
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.120 2014/12/17 03:50:53 brad Exp $ */
d853 2
d921 2
a1790 3

	/* Turn the receive filter on */
	SIS_SETBIT(sc, SIS_RXFILT_CTL, SIS_RXFILTCTL_ENABLE);
@


1.120
log
@Do as the datasheet recommends and disable the RX filter before adjusting
the RX filter.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.119 2014/12/08 10:58:45 brad Exp $ */
a77 1
#ifdef INET
a79 1
#endif
a1892 1
#ifdef INET
a1894 1
#endif
@


1.119
log
@Have foo_init() call foo_reset() to reset the chip to a known state
as is the case for a lot of the other drivers. Remove some redundant
calls to foo_stop() and foo_reset() before foo_init().

Tested with DP83815, 3c905C, 8139 and ST201.
Mostly from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.118 2014/11/24 10:33:37 brad Exp $ */
d337 1
d340 5
a344 2
	SIS_SETBIT(sc, SIS_CSR, SIS_CSR_RELOAD);
	SIS_CLRBIT(sc, SIS_CSR, SIS_CSR_RELOAD);
d346 1
a346 1
	SIS_CLRBIT(sc, SIS_RXFILT_CTL, SIS_RXFILTCTL_ENABLE);
d355 2
a356 1
	SIS_SETBIT(sc, SIS_RXFILT_CTL, SIS_RXFILTCTL_ENABLE);
d798 7
d832 1
a832 1
			CSR_WRITE_4(sc, SIS_RXFILT_CTL, NS_FILTADDR_FMEM_LO + (i*2));
d855 1
d876 7
d921 1
@


1.118
log
@rxr ioctl handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.117 2014/07/22 13:12:11 mpi Exp $ */
d1555 1
a1555 2
	if (status & SIS_ISR_SYSERR) {
		sis_reset(sc);
a1556 1
	}
d1698 5
a1931 2
	sis_stop(sc);
	sis_reset(sc);
@


1.117
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.116 2014/07/08 05:35:18 dlg Exp $ */
d1893 5
@


1.116
log
@cut things that relied on mclgeti for rx ring accounting/restriction over
to using if_rxr.

cut the reporting systat did over to the rxr ioctl.

tested as much as i can on alpha, amd64, and sparc64.
mpi@@ has run it on macppc.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.115 2013/12/28 03:34:54 deraadt Exp $ */
a79 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.115
log
@The few network drivers that called their children's (ie. mii PHY
drivers) activate functions at DVACT_RESUME time do not need to do
so, since their PHYs are repaired by IFF_UP.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.114 2013/12/06 21:03:04 deraadt Exp $ */
a1176 2
	m_clsetwms(ifp, MCLBYTES, 2, SIS_RX_LIST_CNT - 1);

d1271 2
a1272 1
	cd->sis_rx_prod = cd->sis_rx_cons = cd->sis_rx_cnt = 0;
d1283 1
d1288 2
a1289 1
	while (cd->sis_rx_cnt < SIS_RX_LIST_CNT) {
d1292 1
a1293 1
		cd->sis_rx_cnt++;
d1295 1
d1309 1
a1309 1
	m_new = MCLGETI(NULL, M_DONTWAIT, &sc->arpcom.ac_if, MCLBYTES);
d1355 1
a1355 1
	while(sc->sis_cdata.sis_rx_cnt > 0) {
d1370 1
a1370 1
		sc->sis_cdata.sis_rx_cnt--;
@


1.114
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.113 2013/08/21 05:21:44 dlg Exp $ */
a1219 1
		rv = config_activate_children(self, act);
@


1.113
log
@get rid of the copy argument in m_devget that let you provide an
alternative to bcopy since noone uses it.

while there use memcpy instead of bcopy because we know the memory cannot
overlap.

ok henning@@ matthew@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.112 2013/08/07 01:06:37 bluhm Exp $ */
a1213 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
d1223 3
@


1.112
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.111 2013/06/28 03:24:18 brad Exp $ */
d1405 1
a1405 1
			    ifp, NULL);
@


1.111
log
@Rewrite the media / link state handling and have it
handled within sis_miibus_statchg() instead of calling
sis_init().

Based on the FreeBSD sis(4) driver.

ok mikeb@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.110 2013/03/17 00:29:16 brad Exp $ */
a80 1
#include <netinet/in_var.h>
@


1.110
log
@- Apply the AcceptPerfectMatch workaround for DP83815 chipsets to the 15D
  revision as well.
- Sync the short cable workaround a bit closer to FreeBSD. No functional change.

From FreeBSD

- Add some comments.

From NetBSD

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.109 2013/03/07 06:19:07 brad Exp $ */
d671 61
d733 18
a750 1
	sis_init(sc);
a1505 1
	struct ifnet		*ifp;
a1509 2
	ifp = &sc->arpcom.ac_if;

d1513 3
a1515 6
	if (!sc->sis_link && mii->mii_media_status & IFM_ACTIVE &&
	    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
		sc->sis_link++;
		if (!IFQ_IS_EMPTY(&ifp->if_snd))
			sis_start(ifp);
	}
a1790 25
	/* Set TX configuration */
	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_10_T)
		CSR_WRITE_4(sc, SIS_TX_CFG, SIS_TXCFG_10);
	else
		CSR_WRITE_4(sc, SIS_TX_CFG, SIS_TXCFG_100);

	/* Set full/half duplex mode. */
	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX) {
		SIS_SETBIT(sc, SIS_TX_CFG,
		    (SIS_TXCFG_IGN_HBEAT|SIS_TXCFG_IGN_CARR));
		SIS_SETBIT(sc, SIS_RX_CFG, SIS_RXCFG_RX_TXPKTS);
	} else {
		SIS_CLRBIT(sc, SIS_TX_CFG,
		    (SIS_TXCFG_IGN_HBEAT|SIS_TXCFG_IGN_CARR));
		SIS_CLRBIT(sc, SIS_RX_CFG, SIS_RXCFG_RX_TXPKTS);
	}

	if (sc->sis_type == SIS_TYPE_83815 && sc->sis_srr >= NS_SRR_16A) {
		/*
		 * MPII03.D: Half Duplex Excessive Collisions.
		 * Also page 49 in 83816 manual
		 */
		SIS_SETBIT(sc, SIS_TX_CFG, SIS_TXCFG_MPII03D);
 	}

d1792 2
a1793 4
	 * Some DP83815s experience problems when used with short
	 * (< 30m/100ft) Ethernet cables in 100baseTX mode.  This
	 * sequence adjusts the DSP's signal attenuation to fix the
	 * problem.
d1795 1
a1795 19
	if (sc->sis_type == SIS_TYPE_83815 && sc->sis_srr < NS_SRR_16A &&
	    IFM_SUBTYPE(mii->mii_media_active) == IFM_100_TX) {
		uint32_t reg;

		CSR_WRITE_4(sc, NS_PHY_PAGE, 0x0001);
		reg = CSR_READ_4(sc, NS_PHY_DSPCFG) & 0xfff;
		CSR_WRITE_4(sc, NS_PHY_DSPCFG, reg | 0x1000);
		DELAY(100);
		reg = CSR_READ_4(sc, NS_PHY_TDATA) & 0xff;
		if ((reg & 0x0080) == 0 || (reg > 0xd8 && reg <= 0xff)) {
#ifdef DEBUG
			printf("%s: Applying short cable fix (reg=%x)\n",
			    sc->sc_dev.dv_xname, reg);
#endif
			CSR_WRITE_4(sc, NS_PHY_TDATA, 0x00e8);
			SIS_SETBIT(sc, NS_PHY_DSPCFG, 0x20);
		}
		CSR_WRITE_4(sc, NS_PHY_PAGE, 0);
	}
d1803 2
a1804 3
	/* Enable receiver and transmitter. */
	SIS_CLRBIT(sc, SIS_CSR, SIS_CSR_TX_DISABLE|SIS_CSR_RX_DISABLE);
	SIS_SETBIT(sc, SIS_CSR, SIS_CSR_RX_ENABLE);
d1806 1
a1806 1
#ifdef notdef
a1807 1
#endif
a1829 1
	sc->sis_link = 0;
d1960 1
a1960 1
	SIS_SETBIT(sc, SIS_CSR, SIS_CSR_TX_DISABLE|SIS_CSR_RX_DISABLE);
@


1.109
log
@Correct the delay when programming the short cable fix. It should be
100us, not 100ms.

From FreeBSD

ok chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.108 2013/02/09 19:15:18 sthen Exp $ */
d1671 1
a1671 2
	 * Short Cable Receive Errors (MP21.E)
	 * also: Page 78 of the DP83815 data sheet (september 2002 version)
d1673 1
a1673 1
	 * performance." for rev 15C.  The driver from NS also sets  
d1675 3
d1682 6
a1687 8
		if (sc->sis_srr == NS_SRR_15C) {  
			/* set val for c2 */
			CSR_WRITE_4(sc, NS_PHY_TDATA, 0x0000);
			/* load/kill c2 */ 
			CSR_WRITE_4(sc, NS_PHY_DSPCFG, 0x5040);
			/* rais SD off, from 4 to c */
			CSR_WRITE_4(sc, NS_PHY_SDCFG, 0x008C);
		}
d1744 6
d1751 1
a1751 1
	     IFM_SUBTYPE(mii->mii_media_active) == IFM_100_TX) {
a1753 3
		/*
		 * Short Cable Receive Errors (MP21.E)
		 */
d1765 1
a1765 2
			reg = CSR_READ_4(sc, NS_PHY_DSPCFG);
			SIS_SETBIT(sc, NS_PHY_DSPCFG, reg | 0x20);
@


1.108
log
@Allow the user to configure an MTU of up to 1518, which does not require
any additional chip reprogramming, and is tested to work fine on DP83815.
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.107 2012/11/29 21:10:32 brad Exp $ */
d1754 1
a1754 1
		DELAY(100000);
@


1.107
log
@Remove setting an initial assumed baudrate upon driver attach which is not
necessarily correct, there might not even be a link when attaching.

ok mikeb@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.106 2012/10/18 21:44:21 deraadt Exp $ */
d1096 1
@


1.106
log
@Convert a number of old private copies of code which predates
pci_set_powerstate() to using it instead.  Many of these chunks of code had
bugs in them, especially missing delay() calls.  Some of them were doing
things our PCI subsystem is now responsible for handling.  If you have
any of the affected devices, please keep an eye out for regressions.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.105 2011/06/22 16:44:27 tedu Exp $ */
a1092 1
	ifp->if_baudrate = 10000000;
@


1.105
log
@kill a few more casts that aren't helpful.  ok krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.104 2011/04/14 06:27:52 dlg Exp $ */
a875 1
	pcireg_t		command;
d885 1
a885 27
	/*
	 * Handle power management nonsense.
	 */
	command = pci_conf_read(pc, pa->pa_tag, SIS_PCI_CAPID) & 0x000000FF;
	if (command == 0x01) {

		command = pci_conf_read(pc, pa->pa_tag, SIS_PCI_PWRMGMTCTRL);
		if (command & SIS_PSTATE_MASK) {
			u_int32_t		iobase, membase, irq;

			/* Save important PCI config data. */
			iobase = pci_conf_read(pc, pa->pa_tag, SIS_PCI_LOIO);
			membase = pci_conf_read(pc, pa->pa_tag, SIS_PCI_LOMEM);
			irq = pci_conf_read(pc, pa->pa_tag, SIS_PCI_INTLINE);

			/* Reset the power state. */
			printf("%s: chip is in D%d power mode -- setting to D0\n",
			    sc->sc_dev.dv_xname, command & SIS_PSTATE_MASK);
			command &= 0xFFFFFFFC;
			pci_conf_write(pc, pa->pa_tag, SIS_PCI_PWRMGMTCTRL, command);

			/* Restore PCI config data. */
			pci_conf_write(pc, pa->pa_tag, SIS_PCI_LOIO, iobase);
			pci_conf_write(pc, pa->pa_tag, SIS_PCI_LOMEM, membase);
			pci_conf_write(pc, pa->pa_tag, SIS_PCI_INTLINE, irq);
		}
	}
@


1.104
log
@do not disable interrupts in the isr and then enable them again
when leaving. when you're handling an interrupt it is masked.
whacking the chip is work for no gain.

modify the interrupt handler so it only processes the rings once,
rather than looping over them until it runs out of work to do.

looping in the isr is bad for several reasons:

firstly, the chip does interrupt mitigation so you have a
decent/predictable amount of work to do in the isr. your first loop
will do that chunk of work (ie, it pulls off 50ish packets), and
then the successive looping aggressively pull one or two packets
off the rx ring. these extra loops work against the benefit that
interrupt mitigation provides.

bus space reads are slow. we should avoid doing them where possible
(but we should always do them when necessary).

doing the loop 5 times per isr works against the mclgeti semantics.
it knows a nic is busy and therefore needs more rx descriptors by
watching to see when the nic uses all of its descriptors between
interrupts. if we're aggressively pulling packets off by looping
in the isr then we're skewing this check.

ok henning@@ krw@@
testing by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.103 2011/04/03 15:36:02 jasper Exp $ */
d610 1
a610 1
		bzero((char *)&frame, sizeof(frame));
d658 1
a658 1
		bzero((char *)&frame, sizeof(frame));
d1020 1
a1020 1
			bcopy((char *)&tmp[1], sc->arpcom.ac_enaddr,
d1983 1
a1983 1
		bzero((char *)&sc->sis_ldata->sis_rx_list[i],
d2002 1
a2002 1
		bzero((char *)&sc->sis_ldata->sis_tx_list[i],
@


1.103
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.102 2011/02/15 19:10:19 kettenis Exp $ */
d1479 2
a1480 2
	struct sis_softc	*sc;
	struct ifnet		*ifp;
a1481 4
	int			claimed = 0;

	sc = arg;
	ifp = &sc->arpcom.ac_if;
d1484 1
a1484 34
		return (claimed);

	/* Disable interrupts. */
	CSR_WRITE_4(sc, SIS_IER, 0);

	for (;;) {
		/* Reading the ISR register clears all interrupts. */
		status = CSR_READ_4(sc, SIS_ISR);

		if ((status & SIS_INTRS) == 0)
			break;

		claimed = 1;

		if (status &
		    (SIS_ISR_TX_DESC_OK | SIS_ISR_TX_ERR |
		     SIS_ISR_TX_OK | SIS_ISR_TX_IDLE))
			sis_txeof(sc);

		if (status &
		    (SIS_ISR_RX_DESC_OK | SIS_ISR_RX_OK |
		     SIS_ISR_RX_ERR | SIS_ISR_RX_IDLE))
			sis_rxeof(sc);

		if (status & (SIS_ISR_RX_IDLE)) {
			/* consume what's there so that sis_rx_cons points
			 * to the first HW owned descriptor. */
			sis_rxeof(sc);
			/* reprogram the RX listptr */
			CSR_WRITE_4(sc, SIS_RX_LISTPTR,
			    sc->sc_listmap->dm_segs[0].ds_addr +
			    offsetof(struct sis_list_data,
			    sis_rx_list[sc->sis_cdata.sis_rx_cons]));
		}
d1486 29
a1514 4
		if (status & SIS_ISR_SYSERR) {
			sis_reset(sc);
			sis_init(sc);
		}
a1516 3
	/* Re-enable interrupts. */
	CSR_WRITE_4(sc, SIS_IER, 1);

d1526 1
a1526 1
	return (claimed);
@


1.102
log
@bus_dmamap_sync() freshly initialized Rx descriptors before flipping the bit
that hands them over to the hardware.  This prevents the hardware from seeing
stale contents if the compiler decides to re-order stores or if the hardware
does store-reordering.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.101 2010/08/31 17:13:44 deraadt Exp $ */
d864 1
a864 1
	    sizeof(sis_devices)/sizeof(sis_devices[0])));
@


1.101
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.100 2010/08/31 16:26:19 deraadt Exp $ */
d1275 5
@


1.100
log
@activate function should return result of config_activate_children
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.99 2010/08/06 05:24:16 deraadt Exp $ */
d1164 3
@


1.99
log
@ca_activate function for suspend/resume; tested by mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.98 2010/05/19 15:27:35 oga Exp $ */
d1161 1
d1167 1
a1167 1
		config_activate_children(self, act);
d1170 1
a1170 1
		config_activate_children(self, act);
d1175 1
a1175 1
	return (0);
@


1.99.2.1
log
@MFC, original by kettenis@@.

----
bus_dmamap_sync() freshly initialized Rx descriptors before flipping the bit
that hands them over to the hardware.  This prevents the hardware from seeing
stale contents if the compiler decides to re-order stores or if the hardware
does store-reordering.
----

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.99 2010/08/06 05:24:16 deraadt Exp $ */
a1270 5

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    ((caddr_t)c - sc->sc_listkva), sizeof(struct sis_desc),
	    BUS_DMASYNC_PREWRITE)

@


1.99.2.2
log
@missing semicolon; pointed out by Stan Schwarz
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.99.2.1 2011/02/16 20:05:43 jasper Exp $ */
d1274 1
a1274 1
	    BUS_DMASYNC_PREWRITE);
@


1.98
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.97 2009/08/13 14:24:47 jasper Exp $ */
d107 1
d110 2
a111 1
	sizeof(struct sis_softc), sis_probe, sis_attach
d1154 21
@


1.97
log
@- consistify cfdriver for the ethernet drivers (0 -> NULL)

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.96 2009/08/10 19:41:05 deraadt Exp $ */
d1065 1
a1065 1
	    BUS_DMA_NOWAIT) != 0) {
a1086 1
	bzero(sc->sis_ldata, sizeof(struct sis_list_data));
@


1.96
log
@A few more simple cases of shutdown hooks which only call xxstop, when
we now know the interface has already been stopped
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.95 2009/08/09 11:40:56 deraadt Exp $ */
d113 1
a113 1
	0, "sis", DV_IFNET
@


1.95
log
@MCLGETI() will now allocate a mbuf header if it is not provided, thus
reducing the amount of splnet/splx dancing required.. especially in the
worst case (of m_cldrop)
ok dlg kettenis damien
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.94 2009/07/22 21:32:50 miod Exp $ */
a116 1
void sis_shutdown(void *);
a1145 2

	shutdownhook_establish(sis_shutdown, sc);
a1988 12
}

/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
void
sis_shutdown(void *v)
{
	struct sis_softc	*sc = (struct sis_softc *)v;

	sis_stop(sc);
@


1.94
log
@Add big-endian platform support to sis(4). Tested to not break anything on
sokeris by mk@@, and to work on sparc64 by brad@@ and on sgi by yours truly.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.93 2009/06/22 22:14:21 claudio Exp $ */
d1235 2
a1236 2
	MGETHDR(m_new, M_DONTWAIT, MT_DATA);
	if (m_new == NULL)
a1237 6

	MCLGETI(m_new, M_DONTWAIT, &sc->arpcom.ac_if, MCLBYTES);
	if (!(m_new->m_flags & M_EXT)) {
		m_free(m_new);
		return (ENOBUFS);
	}
@


1.93
log
@Sync the strict alignment with vr(4). Remove the if (1) and replace it with
an #ifdef #else #endif dance. Reminded by Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.92 2009/06/18 18:49:34 claudio Exp $ */
d310 1
a310 1
			*ptr = ntohs(word);
d347 1
a347 1
	enaddr[0] = CSR_READ_4(sc, SIS_RXFILT_DATA) & 0xffff;
d349 1
a349 1
	enaddr[1] = CSR_READ_4(sc, SIS_RXFILT_DATA) & 0xffff;
d351 1
a351 1
	enaddr[2] = CSR_READ_4(sc, SIS_RXFILT_DATA) & 0xffff;
d366 1
a366 1
			    SIS_EE_NODEADDR, 3, 0);
d1003 2
a1004 1
			sis_read_eeprom(sc, (caddr_t)&tmp, NS_EE_NODEADDR,4,0);
d1015 3
a1017 3
			tmp[3] = sis_reverse(tmp[3]);
			tmp[2] = sis_reverse(tmp[2]);
			tmp[1] = sis_reverse(tmp[1]);
d1055 1
a1055 1
			    SIS_EE_NODEADDR, 3, 0);
d1180 2
a1181 2
		    sc->sc_listmap->dm_segs[0].ds_addr +
		    offsetof(struct sis_list_data, sis_tx_list[nexti]);
d1196 2
a1197 2
		    sc->sc_listmap->dm_segs[0].ds_addr +
		    offsetof(struct sis_list_data, sis_rx_list[nexti]);
d1257 2
a1258 2
	c->sis_ptr = c->map->dm_segs[0].ds_addr;
	c->sis_ctl = ETHER_MAX_DIX_LEN;
d1291 1
a1291 1
		rxstat = cur_rx->sis_rxstat;
d1368 1
a1368 1
	u_int32_t		idx;
d1388 3
a1390 1
		if (cur_tx->sis_ctl & SIS_CMDSTS_MORE)
d1393 3
a1395 1
		if (!(cur_tx->sis_ctl & SIS_CMDSTS_PKT_OK)) {
d1397 1
a1397 1
			if (cur_tx->sis_txstat & SIS_TXSTAT_EXCESSCOLLS)
d1399 1
a1399 1
			if (cur_tx->sis_txstat & SIS_TXSTAT_OUTOFWINCOLL)
d1403 1
a1403 2
		ifp->if_collisions +=
		    (cur_tx->sis_txstat & SIS_TXSTAT_COLLCNT) >> 16;
d1549 2
a1550 2
		f->sis_ctl = SIS_CMDSTS_MORE | map->dm_segs[i].ds_len;
		f->sis_ptr = map->dm_segs[i].ds_addr;
d1552 1
a1552 1
			f->sis_ctl |= SIS_CMDSTS_OWN;
d1561 2
a1562 2
	sc->sis_ldata->sis_tx_list[cur].sis_ctl &= ~SIS_CMDSTS_MORE;
	sc->sis_ldata->sis_tx_list[*txidx].sis_ctl |= SIS_CMDSTS_OWN;
d1662 1
a1662 1
		    ((u_int16_t *)sc->arpcom.ac_enaddr)[0]);
d1665 1
a1665 1
		    ((u_int16_t *)sc->arpcom.ac_enaddr)[1]);
d1668 1
a1668 1
		    ((u_int16_t *)sc->arpcom.ac_enaddr)[2]);
d1672 1
a1672 1
		    ((u_int16_t *)sc->arpcom.ac_enaddr)[0]);
d1675 1
a1675 1
		    ((u_int16_t *)sc->arpcom.ac_enaddr)[1]);
d1678 1
a1678 1
		    ((u_int16_t *)sc->arpcom.ac_enaddr)[2]);
@


1.92
log
@First sync the descriptor then check if the owner of the descriptor.
While there switch some m_freem() to m_free() where only a single mbuf is
involved.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.91 2009/06/12 21:55:50 claudio Exp $ */
d1329 1
a1329 1
		if (1) {
d1339 4
a1342 1
		} else
a1343 4
		{
			m->m_pkthdr.rcvif = ifp;
			m->m_pkthdr.len = m->m_len = total_len;
		}
@


1.91
log
@Remove #if 0 code that is of no use at all. Ring overflows will actually
happen with MCLGETI and nothing serious at all.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.90 2009/06/04 20:01:02 sthen Exp $ */
d1240 1
a1240 1
		m_freem(m_new);
d1248 1
a1248 1
		m_freem(m_new);
a1282 2
		if (!SIS_OWNDESC(cur_rx))
			break;
d1287 2
@


1.90
log
@merge some individual SIS_SETBIT (done for natsemi chips only)
into sis_iff_ns() (called only for natsemi). from Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.89 2009/06/04 18:12:56 sthen Exp $ */
a121 3
#if 0
void sis_rxeoc(struct sis_softc *);
#endif
a1358 9
#if 0
void
sis_rxeoc(struct sis_softc *sc)
{
	sis_rxeof(sc);
	sis_init(sc);
}
#endif

a1486 4
#if 0
		if (status & SIS_ISR_RX_OFLOW)
			sis_rxeoc(sc);
#endif
@


1.89
log
@- Rewrite ioctl handling code and receive filter handling to clean
  up the code a bit.
- Remove unused sc_if_flags field.

from Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.88 2009/04/14 19:06:49 claudio Exp $ */
d721 2
a722 1
	    SIS_RXFILTCTL_BROAD | NS_RXFILTCTL_MCHASH);
d726 1
d728 1
d730 2
a731 1
	rxfilt |= SIS_RXFILTCTL_BROAD;
a1721 11
	}

	/*
	 * For the NatSemi chip, we have to explicitly enable the
	 * reception of ARP frames, as well as turn on the 'perfect
	 * match' filter where we store the station address, otherwise
	 * we won't receive unicasts meant for this host.
	 */
	if (sc->sis_type == SIS_TYPE_83815) {
		SIS_SETBIT(sc, SIS_RXFILT_CTL, NS_RXFILTCTL_ARP);
		SIS_SETBIT(sc, SIS_RXFILT_CTL, NS_RXFILTCTL_PERFECT);
@


1.88
log
@Convert sis(4) to MCLGETI() and make soekris suck much less. With this the
little green slug does not block userland even when hammered with twice as
much traffic it can handle. Almost the same code I came up during h2k8 but
now with two other bugs fixed that where exposed by MCLGETI().
Tested and OK dlg@@ sthen@@ and a lot of pushing by Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.87 2009/02/24 21:10:14 claudio Exp $ */
d156 3
a158 4
void sis_setmulti(struct sis_softc *);
void sis_setmulti_sis(struct sis_softc *);
void sis_setmulti_ns(struct sis_softc *);
void sis_setpromisc(struct sis_softc *);
d701 1
a701 1
sis_setmulti(struct sis_softc *sc)
d704 1
a704 1
		sis_setmulti_ns(sc);
d706 1
a706 1
		sis_setmulti_sis(sc);
d710 1
a710 1
sis_setmulti_ns(struct sis_softc *sc)
d712 1
a712 1
	struct ifnet		*ifp;
d716 1
a716 1
	u_int32_t		h = 0, i, filtsave;
d719 9
a727 1
	ifp = &sc->arpcom.ac_if;
d729 11
a739 6
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
allmulti:
		SIS_CLRBIT(sc, SIS_RXFILT_CTL, NS_RXFILTCTL_MCHASH);
		SIS_SETBIT(sc, SIS_RXFILT_CTL, SIS_RXFILTCTL_ALLMULTI);
		return;
	}
d741 4
a744 5
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
a745 2
		ETHER_NEXT_MULTI(step, enm);
	}
d747 8
a754 6
	/*
	 * We have to explicitly enable the multicast hash table
	 * on the NatSemi chip if we want to use it, which we do.
	 */
	SIS_SETBIT(sc, SIS_RXFILT_CTL, NS_RXFILTCTL_MCHASH);
	SIS_CLRBIT(sc, SIS_RXFILT_CTL, SIS_RXFILTCTL_ALLMULTI);
d756 2
a757 1
	filtsave = CSR_READ_4(sc, SIS_RXFILT_CTL);
d759 1
a759 5
	/* first, zot all the existing hash bits */
	for (i = 0; i < 32; i++) {
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, NS_FILTADDR_FMEM_LO + (i*2));
		CSR_WRITE_4(sc, SIS_RXFILT_DATA, 0);
	}
d761 2
a762 10
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		h = sis_mchash(sc, enm->enm_addrlo);
		index = h >> 3;
		bit = h & 0x1F;
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, NS_FILTADDR_FMEM_LO + index);
		if (bit > 0xF)
			bit -= 0x10;
		SIS_SETBIT(sc, SIS_RXFILT_DATA, (1 << bit));
		ETHER_NEXT_MULTI(step, enm);
d765 1
a765 1
	CSR_WRITE_4(sc, SIS_RXFILT_CTL, filtsave);
d769 1
a769 1
sis_setmulti_sis(struct sis_softc *sc)
d771 1
a771 1
	struct ifnet		*ifp;
d775 1
a775 1
	u_int32_t		h, i, n, ctl;
a777 2
	ifp = &sc->arpcom.ac_if;

d781 1
a781 1
		n = 16;
d783 1
a783 1
		n = 8;
d785 4
a788 1
	ctl = CSR_READ_4(sc, SIS_RXFILT_CTL) & SIS_RXFILTCTL_ENABLE;
d790 4
a793 2
	if (ifp->if_flags & IFF_BROADCAST)
		ctl |= SIS_RXFILTCTL_BROAD;
d795 4
a798 3
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
allmulti:
		ctl |= SIS_RXFILTCTL_ALLMULTI;
d800 3
a802 2
			ctl |= SIS_RXFILTCTL_BROAD|SIS_RXFILTCTL_ALLPHYS;
		for (i = 0; i < n; i++)
d805 1
a805 1
		for (i = 0; i < n; i++)
d807 1
a807 1
		i = 0;
d810 1
a810 4
			if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
				ifp->if_flags |= IFF_ALLMULTI;
				goto allmulti;
			}
a811 1
			h = sis_mchash(sc, enm->enm_addrlo);
d813 1
a813 1
			i++;
a815 5
		if (i > n) {
			ctl |= SIS_RXFILTCTL_ALLMULTI;
			for (i = 0; i < n; i++)
				hashes[i] = ~0;
		}
d818 1
a818 1
	for (i = 0; i < n; i++) {
d823 1
a823 13
	CSR_WRITE_4(sc, SIS_RXFILT_CTL, ctl);
}

void
sis_setpromisc(struct sis_softc *sc)
{
	struct ifnet	*ifp = &sc->arpcom.ac_if;

	/* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC)
		SIS_SETBIT(sc, SIS_RXFILT_CTL, SIS_RXFILTCTL_ALLPHYS);
	else
		SIS_CLRBIT(sc, SIS_RXFILT_CTL, SIS_RXFILTCTL_ALLPHYS);
d1732 1
a1732 12
	 * Set the capture broadcast bit to capture broadcast frames.
	 */
	if (ifp->if_flags & IFF_BROADCAST)
		SIS_SETBIT(sc, SIS_RXFILT_CTL, SIS_RXFILTCTL_BROAD);
	else
		SIS_CLRBIT(sc, SIS_RXFILT_CTL, SIS_RXFILTCTL_BROAD);

	/* Set promiscuous mode. */
	sis_setpromisc(sc);

	/*
	 * Load the multicast filter.
d1734 1
a1734 1
	sis_setmulti(sc);
d1895 4
a1898 13
			if (ifp->if_flags & IFF_RUNNING &&
			    (ifp->if_flags ^ sc->sc_if_flags) &
			     IFF_PROMISC) {
				sis_setpromisc(sc);
				sis_setmulti(sc);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    (ifp->if_flags ^ sc->sc_if_flags) &
			     IFF_ALLMULTI) {
				sis_setmulti(sc);
			} else {
				if (!(ifp->if_flags & IFF_RUNNING))
					sis_init(sc);
			}
a1902 1
		sc->sc_if_flags = ifp->if_flags;
d1917 1
a1917 1
			sis_setmulti(sc);
@


1.87
log
@The original SiS chips seem to have an bug that marks VLAN tagged packets
with an rx error (SIS_RXSTAT_GIANT) eventhough everything is fine.
Change code to clear this error on RX if the size of the packet is smaller
then 1532 bytes.
From FreeBSD via Brad. Tested on the more common National chips by me.
Ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.86 2008/12/04 23:05:32 oga Exp $ */
d118 2
a119 1
int sis_newbuf(struct sis_softc *, struct sis_desc *, struct mbuf *);
d122 1
d124 1
d1104 1
a1104 1
	for (i = 0; i < SIS_RX_LIST_CNT_MAX; i++) {
a1110 5
	if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES, 0,
	    BUS_DMA_NOWAIT, &sc->sc_rx_sparemap) != 0) {
		printf(": can't create rx spare map\n");
		goto fail_2;
	}
d1141 2
d1182 1
a1182 1
	int			i, error, nexti;
d1193 3
a1195 2
		ld->sis_tx_list[i].sis_next = sc->sc_listmap->dm_segs[0].ds_addr +
			offsetof(struct sis_list_data, sis_tx_list[nexti]);
d1203 2
a1204 10
	if (sc->arpcom.ac_if.if_flags & IFF_UP)
		sc->sc_rxbufs = SIS_RX_LIST_CNT_MAX;
	else
		sc->sc_rxbufs = SIS_RX_LIST_CNT_MIN;

	for (i = 0; i < sc->sc_rxbufs; i++) {
		error = sis_newbuf(sc, &ld->sis_rx_list[i], NULL);
		if (error)
			return (error);
		if (i == (sc->sc_rxbufs - 1))
d1209 4
a1212 2
		ld->sis_rx_list[i].sis_next = sc->sc_listmap->dm_segs[0].ds_addr +
			offsetof(struct sis_list_data, sis_rx_list[nexti]);
d1215 2
a1216 1
	cd->sis_rx_pdsc = &ld->sis_rx_list[0];
d1221 17
d1242 1
a1242 1
sis_newbuf(struct sis_softc *sc, struct sis_desc *c, struct mbuf *m)
a1244 1
	bus_dmamap_t		map;
d1249 8
a1256 13
	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return (ENOBUFS);

		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			m_freem(m_new);
			return (ENOBUFS);
		}
	} else {
		m_new = m;
		m_new->m_data = m_new->m_ext.ext_buf;
d1261 1
a1261 1
	if (bus_dmamap_load_mbuf(sc->sc_dmat, sc->sc_rx_sparemap, m_new,
a1266 4
	map = c->map;
	c->map = sc->sc_rx_sparemap;
	sc->sc_rx_sparemap = map;

d1296 4
a1299 3
	for(cur_rx = sc->sis_cdata.sis_rx_pdsc; SIS_OWNDESC(cur_rx);
	    cur_rx = cur_rx->sis_nextdesc) {

d1309 3
d1327 1
a1327 1
			sis_newbuf(sc, cur_rx, m);
d1334 1
a1334 1
#ifndef __STRICT_ALIGNMENT
d1344 1
a1344 6
		if (sis_newbuf(sc, cur_rx, NULL) == 0) {
			m->m_pkthdr.rcvif = ifp;
			m->m_pkthdr.len = m->m_len = total_len;
		} else
#endif
		{
d1348 1
a1348 1
			sis_newbuf(sc, cur_rx, m);
d1354 5
a1359 1

d1371 1
a1371 1
	sc->sis_cdata.sis_rx_pdsc = cur_rx;
d1374 1
d1381 1
d1511 1
a1513 4

#if 0
		if (status & (SIS_ISR_RX_IDLE))
			SIS_SETBIT(sc, SIS_CSR, SIS_CSR_RX_ENABLE);
d1515 10
d2021 1
a2021 1
	for (i = 0; i < SIS_RX_LIST_CNT_MAX; i++) {
@


1.86
log
@Don't hardcode the bus_space_tag to use, grab if from pci_attach_args
like you're supposed to. Makes this file slightly less horrible.

ok kettenis@@, "yes" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.85 2008/11/28 02:44:18 brad Exp $ */
d1310 2
a1311 1
	 	 * comes up in the ring.
d1313 4
a1316 1
		if (!(rxstat & SIS_CMDSTS_PKT_OK)) {
d1500 1
a1500 1
		     SIS_ISR_RX_IDLE))
d1503 1
a1503 1
		if (status & (SIS_ISR_RX_ERR | SIS_ISR_RX_OFLOW))
@


1.85
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.84 2008/11/10 07:23:43 cnst Exp $ */
a321 1
	bus_space_tag_t btag;
a327 6
#if defined(__amd64__)
	btag = X86_BUS_SPACE_IO;
#elif defined(__i386__)
	btag = I386_BUS_SPACE_IO;
#endif

d329 2
a330 2
		bus_space_write_1(btag, 0x0, 0x70, i + off);
		*(dest + i) = bus_space_read_1(btag, 0x0, 0x71);
@


1.84
log
@don't assign ifp to ifp;  llvm/clang;  ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.83 2008/10/14 18:01:53 naddy Exp $ */
d1890 1
a1891 1
	struct ifaddr		*ifa = (struct ifaddr *)data;
d1907 1
d1929 1
a1929 22
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ETHERMTU)
			error = EINVAL;
		else if (ifp->if_mtu != ifr->ifr_mtu)
			ifp->if_mtu = ifr->ifr_mtu;
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				sis_setmulti(sc);
			error = 0;
		}
		break;
d1935 1
d1938 6
@


1.83
log
@Change m_devget()'s outdated and unused "offset" argument:  It is
now the offset into the first mbuf of the target chain before copying
the source data over.  From FreeBSD.

Convert drivers' use of m_devget().  Mostly from thib@@.

Update mbuf(9) man page.

ok claudio@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.82 2008/10/02 20:21:14 brad Exp $ */
d837 1
a837 1
	struct ifnet	*ifp = ifp = &sc->arpcom.ac_if;
@


1.82
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.81 2008/09/10 14:01:22 blambert Exp $ */
d1347 2
a1348 2
			m0 = m_devget(mtod(m, char *) - ETHER_ALIGN,
			    total_len + ETHER_ALIGN, 0, ifp, NULL);
a1353 1
			m_adj(m0, ETHER_ALIGN);
@


1.81
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.80 2008/07/15 12:10:48 thib Exp $ */
a1897 5
	if ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {
		splx(s);
		return error;
	}

d1957 1
a1957 2
		error = ENOTTY;
		break;
a1960 1

@


1.80
log
@theres no need too m_adj() the mbuf by 8bytes (u_int64_t) in
sis_newbuf(), so remove the call.

ok and lots of prodding dlg@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.79 2008/07/10 18:14:59 thib Exp $ */
d1466 1
a1466 1
	timeout_add(&sc->sis_timeout, hz);
d1844 1
a1844 1
	timeout_add(&sc->sis_timeout, hz);
@


1.79
log
@
move a common statement out of if/else;
adjust the mbuf before loading it, with bus_dmamap_load_mbuf(),
that way we dont have to fiddle with ds_addr;

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.78 2008/07/07 12:53:43 thib Exp $ */
a1259 2

	m_adj(m_new, sizeof(u_int64_t));
@


1.78
log
@
Use bus_dmamap_load_mbuf() instead of bus_dmamap_load() when
we want too load an mbuf; remove a printf that fires in case
we can't load the mbuf (We do error handling and recovery).

ok brad@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.77 2007/05/04 12:12:53 art Exp $ */
a1253 1
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
a1255 1
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
d1259 4
a1275 2
	m_adj(m_new, sizeof(u_int64_t));

d1277 1
a1277 1
	c->sis_ptr = c->map->dm_segs[0].ds_addr + sizeof(u_int64_t);
@


1.77
log
@Initialize the sis_timeout early in attach instead of sis_init.
Sometimes we can can call timeout_del on it before we call sis_init.

From mickey. art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.76 2006/12/03 16:23:41 grange Exp $ */
d1261 2
a1262 3
	if (bus_dmamap_load(sc->sc_dmat, sc->sc_rx_sparemap,
	    mtod(m_new, caddr_t), MCLBYTES, NULL, BUS_DMA_NOWAIT) != 0) {
		printf("%s: rx load failed\n", sc->sc_dev.dv_xname);
d1266 1
@


1.76
log
@Re-enable RX engine every time otherwise it occasionally
stops under unknown circumstances.

Tested by many people, ok brad a long time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.75 2006/12/03 16:12:22 grange Exp $ */
d1135 2
a1845 1
	timeout_set(&sc->sis_timeout, sis_tick, sc);
@


1.75
log
@Set sis_stopped=1 early on attach and reset it later in sis_init().
With mickey's help.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.74 2006/10/18 20:00:21 brad Exp $ */
d1510 1
d1513 1
d1523 6
@


1.74
log
@Simplify the logic of the for loops in the sis_ring_init() function.

tested by ckuethe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.73 2006/08/10 17:45:16 brad Exp $ */
d902 2
a1654 1
	sc->sis_stopped = 0;
d1830 1
@


1.73
log
@move the promiscuous mode handling code to sis_setpromisc() and simplify
the ioctl handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.72 2006/07/10 03:06:28 brad Exp $ */
d1185 1
a1185 2
	int			i, error;
	bus_addr_t		next;
d1191 7
a1197 13
		next = sc->sc_listmap->dm_segs[0].ds_addr;
		if (i == (SIS_TX_LIST_CNT - 1)) {
			ld->sis_tx_list[i].sis_nextdesc =
			    &ld->sis_tx_list[0];
			next +=
			    offsetof(struct sis_list_data, sis_tx_list[0]);
		} else {
			ld->sis_tx_list[i].sis_nextdesc =
			    &ld->sis_tx_list[i+1];
			next +=
			    offsetof(struct sis_list_data, sis_tx_list[i+1]);
		}
		ld->sis_tx_list[i].sis_next = next;
d1214 7
a1220 11
		next = sc->sc_listmap->dm_segs[0].ds_addr;
		if (i == (sc->sc_rxbufs - 1)) {
			ld->sis_rx_list[i].sis_nextdesc = &ld->sis_rx_list[0];
			next +=
			    offsetof(struct sis_list_data, sis_rx_list[0]);
		} else {
			ld->sis_rx_list[i].sis_nextdesc = &ld->sis_rx_list[i+1];
			next +=
			    offsetof(struct sis_list_data, sis_rx_list[i+1]);
		}
		ld->sis_rx_list[i].sis_next = next;
@


1.72
log
@add code for the interrupt holdoff support. bump NS_IHR_DELAY above 0 to
enable the support.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.71 2006/05/28 00:04:24 jason Exp $ */
d156 1
d835 12
a1737 6
	 /* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC)
		SIS_SETBIT(sc, SIS_RXFILT_CTL, SIS_RXFILTCTL_ALLPHYS);
	else
		SIS_CLRBIT(sc, SIS_RXFILT_CTL, SIS_RXFILTCTL_ALLPHYS);

d1746 3
d1918 3
a1920 10
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->sc_if_flags & IFF_PROMISC)) {
				SIS_SETBIT(sc, SIS_RXFILT_CTL,
				    SIS_RXFILTCTL_ALLPHYS);
				sis_setmulti(sc);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->sc_if_flags & IFF_PROMISC) {
				SIS_CLRBIT(sc, SIS_RXFILT_CTL,
				    SIS_RXFILTCTL_ALLPHYS);
d1923 2
a1924 1
			    (ifp->if_flags ^ sc->sc_if_flags) & IFF_ALLMULTI) {
@


1.71
log
@unknown ioctl is ENOTTY not EINVAL
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.70 2006/05/27 21:48:22 brad Exp $ */
d1652 6
@


1.70
log
@With the National variants of the sis(4) chip make sure to
check for multicast ranges and then switch into allmulti
mode, before touching the receive filter. This fixes an
issue noticed by a few devlopers where sis(4) will stop
receiving traffic when switched into allmulti mode.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.69 2006/04/28 17:18:13 brad Exp $ */
d1954 1
a1954 1
		error = EINVAL;
@


1.69
log
@and store a copy of the current interface flags in the softc.
this time without mixing in another diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.68 2006/04/28 10:17:34 martin Exp $ */
d732 9
a757 5
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}

@


1.68
log
@backout previous, Brad probably forgot to commit some bits here

found by dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.67 2006/04/28 06:14:46 brad Exp $ */
d1888 1
a1888 1
		if ((ifp->if_flags & IFF_RUNNING) == 0)
d1913 1
a1913 1
				if ((ifp->if_flags & IFF_RUNNING) == 0)
d1920 1
@


1.67
log
@and store a copy of the current interface flags in the softc.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.66 2006/03/25 22:41:45 djm Exp $ */
a1648 4
	/* Configure interrupt holdoff register. */
	if (sc->sis_type == SIS_TYPE_83815 && sc->sis_srr == NS_SRR_16A)
		CSR_WRITE_4(sc, NS_IHR, NS_IHR_VALUE); 

d1888 1
a1888 1
		if (!(ifp->if_flags & IFF_RUNNING))
d1913 1
a1913 1
				if (!(ifp->if_flags & IFF_RUNNING))
a1919 1
		sc->sc_if_flags = ifp->if_flags;
@


1.66
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.65 2006/03/25 20:09:17 brad Exp $ */
d1649 4
d1892 1
a1892 1
		if ((ifp->if_flags & IFF_RUNNING) == 0)
d1917 1
a1917 1
				if ((ifp->if_flags & IFF_RUNNING) == 0)
d1924 1
@


1.65
log
@tidy up a bit.

From Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.64 2006/03/25 05:00:28 brad Exp $ */
d1354 1
a1354 1
			bpf_mtap(ifp->if_bpf, m);
d1617 1
a1617 1
			bpf_mtap(ifp->if_bpf, m_head);
@


1.64
log
@ANSI and KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.63 2006/03/25 03:21:56 brad Exp $ */
d118 1
a118 2
int sis_newbuf(struct sis_softc *, struct sis_desc *,
				struct mbuf *);
d1226 1
a1226 1
sis_newbuf(struct sis_softc *sc, struct sis_desc*c, struct mbuf *m)
@


1.63
log
@set/clear the all frames bit in the receive filter when
enabling/disabling promisc mode instead of calling sis_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.62 2006/03/20 16:15:03 brad Exp $ */
a61 1
#include "vlan.h"
d107 9
d174 6
d184 2
a185 2
u_int16_t sis_reverse(n)
	u_int16_t		n;
d192 1
a192 1
	return(n);
d195 2
a196 2
void sis_delay(sc)
	struct sis_softc	*sc;
a201 2

	return;
d204 2
a205 2
void sis_eeprom_idle(sc)
	struct sis_softc	*sc;
a225 2

	return;
d231 2
a232 3
void sis_eeprom_putbyte(sc, addr)
	struct sis_softc	*sc;
	int			addr;
d242 1
a242 1
		if (d & i) {
d244 1
a244 1
		} else {
a245 1
		}
a251 2

	return;
d257 2
a258 4
void sis_eeprom_getword(sc, addr, dest)
	struct sis_softc	*sc;
	int			addr;
	u_int16_t		*dest;
a294 2

	return;
d300 3
a302 6
void sis_read_eeprom(sc, dest, off, cnt, swap)
	struct sis_softc	*sc;
	caddr_t			dest;
	int			off;
	int			cnt;
	int			swap;
a314 2

	return;
d318 3
a320 5
void sis_read_cmos(sc, pa, dest, off, cnt)
	struct sis_softc *sc;
	struct pci_attach_args *pa;
	caddr_t dest;
	int off, cnt;
d344 2
a345 3
void sis_read_mac(sc, pa)
	struct sis_softc *sc;
	struct pci_attach_args *pa;
d364 2
a365 2
void sis_read96x_mac(sc)
	struct sis_softc *sc;
d386 2
a387 2
void sis_mii_sync(sc)
	struct sis_softc	*sc;
a398 2
 
 	return;
d404 2
a405 4
void sis_mii_send(sc, bits, cnt)
	struct sis_softc	*sc;
	u_int32_t		bits;
	int			cnt;
d412 1
a412 1
		if (bits & i) {
d414 1
a414 1
		} else {
a415 1
		}
d426 2
a427 4
int sis_mii_readreg(sc, frame)
	struct sis_softc	*sc;
	struct sis_mii_frame	*frame;
 	
d508 2
a509 2
		return(1);
	return(0);
d515 2
a516 4
int sis_mii_writereg(sc, frame)
	struct sis_softc	*sc;
	struct sis_mii_frame	*frame;
	
d556 1
a556 1
 	return(0);
d559 2
a560 3
int sis_miibus_readreg(self, phy, reg)
	struct device		*self;
	int			phy, reg;
d567 1
a567 1
			return(0);
d593 1
a593 1
			return(0);
d607 1
a607 1
			return(0);
d613 1
a613 1
			return(0);
d615 1
a615 1
		return(val);
d623 1
a623 1
		return(frame.mii_data);
d627 2
a628 4

void sis_miibus_writereg(self, phy, reg, data)
	struct device		*self;
	int			phy, reg, data;
a671 1
	return;
d675 1
a675 2
sis_miibus_statchg(self)
	struct device		*self;
a679 2

	return;
d830 2
a831 2
void sis_reset(sc)
	struct sis_softc	*sc;
a855 2

	return;
a857 6
const struct pci_matchid sis_devices[] = {
	{ PCI_VENDOR_SIS, PCI_PRODUCT_SIS_900 },
	{ PCI_VENDOR_SIS, PCI_PRODUCT_SIS_7016 },
	{ PCI_VENDOR_NS, PCI_PRODUCT_NS_DP83815 },
};

d862 2
a863 4
int sis_probe(parent, match, aux)
	struct device		*parent;
	void			*match;
	void			*aux;
d873 2
a874 3
void sis_attach(parent, self, aux)
	struct device		*parent, *self;
	void			*aux;
d1128 1
a1128 1
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
d1164 2
a1165 2
int sis_ring_init(sc)
	struct sis_softc	*sc;
d1226 2
a1227 4
int sis_newbuf(sc, c, m)
	struct sis_softc	*sc;
	struct sis_desc		*c;
	struct mbuf		*m;
d1282 2
a1283 2
void sis_rxeof(sc)
	struct sis_softc	*sc;
d1365 2
a1366 2
void sis_rxeoc(sc)
	struct sis_softc	*sc;
a1369 1
	return;
d1377 2
a1378 2
void sis_txeof(sc)
	struct sis_softc	*sc;
d1438 2
a1439 2
void sis_tick(xsc)
	void			*xsc;
a1461 2

	return;
d1464 2
a1465 2
int sis_intr(arg)
	void			*arg;
d1476 1
a1476 1
		return claimed;
d1518 1
a1518 1
	return claimed;
d1525 2
a1526 4
int sis_encap(sc, m_head, txidx)
	struct sis_softc	*sc;
	struct mbuf		*m_head;
	u_int32_t		*txidx;
d1570 1
a1570 1
	return(0);
d1580 2
a1581 2
void sis_start(ifp)
	struct ifnet		*ifp;
a1631 2

	return;
d1634 2
a1635 2
void sis_init(xsc)
	void			*xsc;
d1717 1
a1717 1
	if (ifp->if_flags & IFF_PROMISC) {
d1719 1
a1719 1
	} else {
a1720 1
	}
d1725 1
a1725 1
	if (ifp->if_flags & IFF_BROADCAST) {
d1727 1
a1727 1
	} else {
a1728 1
	}
d1750 1
a1750 1
	if (CSR_READ_4(sc, SIS_CFG) & SIS_CFG_EDB_MASTER_EN) {
d1752 1
a1752 1
	} else {
a1753 1
	}
a1827 2

	return;
d1833 2
a1834 2
int sis_ifmedia_upd(ifp)
	struct ifnet		*ifp;
d1850 1
a1850 1
	return(0);
d1856 2
a1857 3
void sis_ifmedia_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
a1867 2

	return;
d1870 2
a1871 4
int sis_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
d1959 2
a1960 2
void sis_watchdog(ifp)
	struct ifnet		*ifp;
d1967 1
a1967 1
	if (sc->sis_stopped) {
a1968 1
	}
a1981 1
	return;
d1988 2
a1989 2
void sis_stop(sc)
	struct sis_softc	*sc;
d2058 2
a2059 2
void sis_shutdown(v)
	void			*v;
a2064 9

struct cfattach sis_ca = {
	sizeof(struct sis_softc), sis_probe, sis_attach
};

struct cfdriver sis_cd = {
	0, "sis", DV_IFNET
};

@


1.62
log
@de-register.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.61 2005/11/04 16:59:45 brad Exp $ */
d146 1
d728 9
d748 1
a749 1
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
d814 1
a815 1
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
d1777 1
a1777 4
	if (sc->sis_type == SIS_TYPE_83815)
		sis_setmulti_ns(sc);
	else
		sis_setmulti_sis(sc);
d1941 1
a1941 2
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
d1943 2
d1946 1
a1946 5
			break;
		default:
			sis_init(sc);
			break;
		}
d1950 19
a1968 1
			sis_init(sc);
a1972 1
		error = 0;
d1991 2
a1992 6
			if (ifp->if_flags & IFF_RUNNING) {
				if (sc->sis_type == SIS_TYPE_83815)
					sis_setmulti_ns(sc);
				else
					sis_setmulti_sis(sc);
			}
@


1.61
log
@- splimp -> splnet
- remove spl's from attach
- fix dmesg printing
- de-allocate resources on failure to attach
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.60 2005/10/30 00:38:28 brad Exp $ */
d194 1
a194 1
	register int		i;
d224 1
a224 1
	register int		d, i;
d255 1
a255 1
	register int		i;
d394 1
a394 1
	register int		i;
d845 1
a845 1
	register int		i;
d2028 1
a2028 1
	register int		i;
@


1.60
log
@Simplify sis(4) TX/RX ring initialization.

Thanks to Ben <ben@@tilderoot.com> for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.59 2005/10/20 21:47:56 brad Exp $ */
d443 1
a443 1
	s = splimp();
d534 1
a534 1
	s = splimp();
d899 1
a899 1
	int			i, s;
d907 1
a907 17
	bus_size_t		iosize;

	s = splnet();

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_SIS_900:
		sc->sis_type = SIS_TYPE_900;
		break;
	case PCI_PRODUCT_SIS_7016:
		sc->sis_type = SIS_TYPE_7016;
		break;
	case PCI_PRODUCT_NS_DP83815:
		sc->sis_type = SIS_TYPE_83815;
		break;
	default:
		break;
	}
a939 1
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
d943 1
a943 1
	    &sc->sis_btag, &sc->sis_bhandle, NULL, &iosize, 0)) {
d949 1
a949 1
	    &sc->sis_btag, &sc->sis_bhandle, NULL, &iosize, 0)) {
d958 1
a958 1
		goto fail;
d968 1
a968 1
		goto fail;
d971 13
a995 2
	printf(":");

d1004 1
a1004 1
			printf(" DP83815C,");
d1006 1
a1006 1
			printf(" DP83815D,");
d1008 1
a1008 1
			printf(" DP83816A,");
d1010 1
a1010 1
			printf(" srr %x,", sc->sis_srr);
d1082 1
a1082 1
	printf(" %s, address %s\n", intrstr,
d1091 1
a1091 1
		return;
d1097 1
a1097 1
		return;
d1103 1
a1103 1
		return;
d1108 1
a1108 1
		return;
d1117 1
a1117 1
			return;
d1123 1
a1123 1
		return;
d1131 1
a1131 1
			return;
d1137 1
a1137 1
		return;
d1173 4
d1178 2
a1179 3
fail:
	splx(s);
	return;
@


1.59
log
@Instead of keeping track of the index into the receive ring use the already
implemented "sis_nextdesc" pointer to keep a pointer instead.

From phk FreeBSD

Tested by a few developers
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.58 2005/10/18 01:01:27 brad Exp $ */
d149 1
a149 2
int sis_list_rx_init(struct sis_softc *);
int sis_list_tx_init(struct sis_softc *);
d1186 3
a1188 1
 * Initialize the transmit descriptors.
d1190 1
a1190 1
int sis_list_tx_init(sc)
d1195 1
a1195 1
	int			i;
a1221 20
	return(0);
}


/*
 * Initialize the RX descriptors and allocate mbufs for them. Note that
 * we arrange the descriptors in a closed ring, so that the last descriptor
 * points back to the first.
 */
int sis_list_rx_init(sc)
	struct sis_softc	*sc;
{
	struct sis_list_data	*ld;
	struct sis_ring_data	*cd;
	bus_addr_t		next;
	int			i;

	ld = sc->sis_ldata;
	cd = &sc->sis_cdata;

d1228 3
a1230 2
		if (sis_newbuf(sc, &ld->sis_rx_list[i], NULL) == ENOBUFS)
			return(ENOBUFS);
d1246 1
a1246 1
	return(0);
d1260 3
d1266 1
a1266 1
			return(ENOBUFS);
d1271 1
a1271 1
			return(ENOBUFS);
d1303 1
a1303 1
	return(0);
d1710 2
a1711 2
	/* Init circular RX list. */
	if (sis_list_rx_init(sc) == ENOBUFS) {
a1717 5

	/*
	 * Init tx descriptors.
	 */
	sis_list_tx_init(sc);
@


1.58
log
@Put rev 1.56 back in and make sure to include the header so
it actually compiles this time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.57 2005/10/18 00:44:23 brad Exp $ */
d1262 1
a1262 1
	cd->sis_rx_prod = 0;
d1331 1
a1331 1
	int			i, total_len = 0;
a1334 1
	i = sc->sis_cdata.sis_rx_prod;
d1336 2
a1337 1
	while(SIS_OWNDESC(&sc->sis_ldata->sis_rx_list[i])) {
a1338 1
		cur_rx = &sc->sis_ldata->sis_rx_list[i];
a1347 1
		SIS_INC(i, sc->sc_rxbufs);
d1405 1
a1405 3
	sc->sis_cdata.sis_rx_prod = i;

	return;
@


1.57
log
@revert last commit for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.55 2005/10/17 05:02:50 brad Exp $ */
a1427 1
	struct sis_desc		*cur_tx = NULL;
a1432 3
	/* Clear the timeout timer. */
	ifp->if_timer = 0;

d1437 3
a1439 3
	idx = sc->sis_cdata.sis_tx_cons;
	while (idx != sc->sis_cdata.sis_tx_prod) {
		cur_tx = &sc->sis_ldata->sis_tx_list[idx];
d1449 1
a1449 3
		if (cur_tx->sis_ctl & SIS_CMDSTS_MORE) {
			sc->sis_cdata.sis_tx_cnt--;
			SIS_INC(idx, SIS_TX_LIST_CNT);
a1450 1
		}
a1474 4

		sc->sis_cdata.sis_tx_cnt--;
		SIS_INC(idx, SIS_TX_LIST_CNT);
		ifp->if_timer = 0;
d1477 3
a1479 3
	sc->sis_cdata.sis_tx_cons = idx;

	if (cur_tx != NULL)
d1481 1
d1483 1
a1483 1
	return;
@


1.56
log
@Make sure that if_timer does not get reset if there are packets
still queued for transmission. This should solve the problem of
the device stalling on transmissions if some link event prevents
transmission.

From luigi FreeBSD

ok pedro@@ hshoexer@@
@
text
@d1428 1
d1434 3
d1441 3
a1443 3
	for (idx = sc->sis_cdata.sis_tx_cons; sc->sis_cdata.sis_tx_cnt > 0;
	    sc->sis_cdata.sis_tx_cnt--, SIS_INC(idx, SIS_TX_LIST_CNT)) {
		struct sis_desc *cur_tx = &sc->sis_ldata->sis_tx_list[idx];
d1453 3
a1455 1
		if (cur_tx->sis_ctl & SIS_CMDSTS_MORE)
d1457 1
d1482 4
d1488 3
a1490 3
	if (idx != sc->sis_cdata.sis_tx_cons) {
		/* we freed up some buffers */
		sc->sis_cdata.sis_tx_cons = idx;
a1491 1
	}
d1493 1
a1493 1
	ifp->if_timer = (sc->sis_cdata.sis_tx_cnt == 0) ? 0 : 5;
@


1.55
log
@Enable APC CMOS RAM reading code on amd64 for some embedded sis(4) chips.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.54 2005/10/14 22:59:38 brad Exp $ */
a1427 1
	struct sis_desc		*cur_tx = NULL;
a1432 3
	/* Clear the timeout timer. */
	ifp->if_timer = 0;

d1437 3
a1439 3
	idx = sc->sis_cdata.sis_tx_cons;
	while (idx != sc->sis_cdata.sis_tx_prod) {
		cur_tx = &sc->sis_ldata->sis_tx_list[idx];
d1449 1
a1449 3
		if (cur_tx->sis_ctl & SIS_CMDSTS_MORE) {
			sc->sis_cdata.sis_tx_cnt--;
			SIS_INC(idx, SIS_TX_LIST_CNT);
a1450 1
		}
a1474 4

		sc->sis_cdata.sis_tx_cnt--;
		SIS_INC(idx, SIS_TX_LIST_CNT);
		ifp->if_timer = 0;
d1477 3
a1479 3
	sc->sis_cdata.sis_tx_cons = idx;

	if (cur_tx != NULL)
d1481 1
d1483 1
a1483 1
	return;
@


1.54
log
@no functional change here, just moving the stripping of the
FCS into the SIS_RXBYTES() macro. As done in the FreeBSD sis driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.53 2005/10/13 01:44:33 brad Exp $ */
d130 1
a130 1
#ifdef __i386__
d320 1
a320 1
#ifdef __i386__
d334 3
d338 1
d1055 1
a1055 1
#ifdef __i386__
@


1.53
log
@sync multicast code with the FreeBSD sis driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.52 2005/10/12 21:14:37 brad Exp $ */
d1361 1
a1361 6
		/*
		 * No errors; receive the packet.  Note, the chip
		 * includes the CRC with every packet.
		 */
		total_len -= ETHER_CRC_LEN;

@


1.52
log
@have sis strip off the Ethernet FCS before passing it to bpf.

ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.51 2005/08/09 04:10:12 mickey Exp $ */
d145 1
d700 25
a724 2
void sis_setmulti_ns(sc)
	struct sis_softc	*sc;
d764 1
a764 1
		h = ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 23;
a774 2

	return;
d777 2
a778 2
void sis_setmulti_sis(sc)
	struct sis_softc	*sc;
d784 2
a785 1
	u_int32_t		h = 0, i, filtsave;
d789 6
a794 5
allmulti:
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
		SIS_SETBIT(sc, SIS_RXFILT_CTL, SIS_RXFILTCTL_ALLMULTI);
		return;
	}
d796 1
a796 1
	SIS_CLRBIT(sc, SIS_RXFILT_CTL, SIS_RXFILTCTL_ALLMULTI);
d798 2
a799 1
	filtsave = CSR_READ_4(sc, SIS_RXFILT_CTL);
d801 28
a828 4
	/* first, zot all the existing hash bits */
	for (i = 0; i < 8; i++) {
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, (4 + ((i * 16) >> 4)) << 16);
		CSR_WRITE_4(sc, SIS_RXFILT_DATA, 0);
d831 3
a833 13
	/* now program new ones */
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}

		h = (ether_crc32_be(enm->enm_addrlo,
		    ETHER_ADDR_LEN) >> 25) & 0x0000007F;
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, (4 + (h >> 4)) << 16);
		SIS_SETBIT(sc, SIS_RXFILT_DATA, (1 << (h & 0xF)));
		ETHER_NEXT_MULTI(step, enm);
d836 1
a836 3
	CSR_WRITE_4(sc, SIS_RXFILT_CTL, filtsave);

	return;
@


1.51
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.50 2005/07/28 18:39:32 brad Exp $ */
a1309 1

d1324 6
a1329 1
		/* No errors; receive the packet. */	
@


1.50
log
@clear IFF_RUNNING & IFF_OACTIVE in sis_stop() before de-allocating resources,
also move setting of sis_stopped further up in sis_stop().

ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.49 2005/07/21 16:08:21 fgsch Exp $ */
d861 1
a861 1
	u_int32_t		command;
a915 4
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	    PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
@


1.49
log
@rollback r1.48 since it caused several panics here; brad@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.47 2005/06/12 21:38:14 fgsch Exp $ */
d2039 4
a2089 5

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
	sc->sis_stopped = 1;

	return;
@


1.48
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@a2038 3

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);

d2087 1
@


1.47
log
@use pci_mapreg_map() instead of pci_[io|mem]_find and bus_space_map;
originally from brad@@. working reports by uwe@@, hshoexer@@ and myself..
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.46 2005/05/27 04:52:24 brad Exp $ */
d2039 3
a2089 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.46
log
@handle SIOCSIFMTU ioctl
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.45 2005/05/22 05:40:52 brad Exp $ */
a866 1
	bus_addr_t		iobase;
d923 5
a927 13
	if (!(command & PCI_COMMAND_IO_ENABLE)) {
		printf(": failed to enable I/O ports\n");
		goto fail;
	}
	if (pci_io_find(pc, pa->pa_tag, SIS_PCI_LOIO, &iobase, &iosize)) {
		printf(": can't find I/O space\n");
		goto fail;
	}
	if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->sis_bhandle)) {
		printf(": can't map I/O space\n");
		goto fail;
	}
	sc->sis_btag = pa->pa_iot;
d929 5
a933 13
	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf(": failed to enable memory mapping\n");
		goto fail;
	}
	if (pci_mem_find(pc, pa->pa_tag, SIS_PCI_LOMEM, &iobase, &iosize,NULL)){
		printf(": can't find mem space\n");
		goto fail;
	}
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->sis_bhandle)) {
		printf(": can't map mem space\n");
		goto fail;
	}
	sc->sis_btag = pa->pa_memt;
@


1.45
log
@- Enable parity error detection on 900B and 635(A).

- SIS_CFG_EDB_MASTER_EN indicates the EDB bus is used instead of
  the PCI bus. When this bit is set, the Max DMA Burst Size
  for TX/RX DMA should be no larger than 64 bytes.

- Do not call mii_pollstat() from within device tick routines; the status
  information is updated by mii_tick().

From FreeBSD

Testing by uwe@@, mpf@@ and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.44 2005/04/05 00:13:57 brad Exp $ */
d1970 6
@


1.44
log
@- Fix for an issue with excessive collisions in half duplex mode.
- Nail the short cable problem the exact way National says it should be.
- Make sure to clear any pending interrupts when we stop the interface.
- Do not tell the hardware to send when there were no packets enqueued.
- Close a theoretical race:  By the time the watchdog comes around
the interface may have been stopped, so we should not restart it.

From FreeBSD

Tested by ho@@ on a few Soekris boxes and martin@@ on a 900
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.43 2005/01/15 05:24:11 brad Exp $ */
d530 1
a530 1
	 s = splimp();
d974 7
d1492 5
a1496 7
	if (!sc->sis_link) {
		mii_pollstat(mii);
		if (mii->mii_media_status & IFM_ACTIVE &&
		    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE)
			sc->sis_link++;
			if (!IFQ_IS_EMPTY(&ifp->if_snd))
				sis_start(ifp);
d1801 9
a1809 2
	/* Set RX configuration */
	CSR_WRITE_4(sc, SIS_RX_CFG, SIS_RXCFG);
@


1.43
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.42 2004/09/28 04:37:33 brad Exp $ */
d1511 1
a1511 3
	/* Supress unwanted interrupts */
	if (!(ifp->if_flags & IFF_UP)) {
		sis_stop(sc);
a1512 1
	}
d1623 1
a1623 1
	u_int32_t		idx;
d1648 2
a1658 2
	if (idx == sc->sis_cdata.sis_tx_prod)
		return;
d1660 4
a1663 3
	/* Transmit */
	sc->sis_cdata.sis_tx_prod = idx;
	SIS_SETBIT(sc, SIS_CSR, SIS_CSR_TX_ENABLE);
d1665 5
a1669 4
	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;
d1730 2
a1731 1
	 * Page 78 of the DP83815 data sheet (september 2002 version)
d1736 1
a1736 1
	 if (sc->sis_type == SIS_TYPE_83815) {
a1737 1
		/* DC speed = 01 */
d1819 8
d1832 1
a1832 4
		 * Some DP83815s experience problems when used with short
		 * (< 30m/100ft) Ethernet cables in 100BaseTX mode.  This
		 * sequence adjusts the DSP's signal attenuation to fix the
		 * problem.
d1835 5
a1839 8

		reg = CSR_READ_4(sc, NS_PHY_DSPCFG);
		/* Allow coefficient to be read */
		CSR_WRITE_4(sc, NS_PHY_DSPCFG, (reg & 0xfff) | 0x1000);
		DELAY(100);
		reg = CSR_READ_4(sc, NS_PHY_TDATA);
		if ((reg & 0x0080) == 0 ||
		    (reg > 0xd8 && reg <= 0xff)) {
d1845 2
a1846 2
			/* Adjust coefficient and prevent change */
			SIS_SETBIT(sc, NS_PHY_DSPCFG, 0x20);
d2002 4
d2040 1
@


1.42
log
@Use ETHER_MAX_DIX_LEN/ETHER_MIN_LEN
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.41 2004/09/23 17:45:16 brad Exp $ */
d1969 6
a1974 4
			if (sc->sis_type == SIS_TYPE_83815)
				sis_setmulti_ns(sc);
			else
				sis_setmulti_sis(sc);
@


1.41
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.40 2004/07/04 22:57:20 deraadt Exp $ */
a1130 1
#if NVLAN > 0
a1131 1
#endif
d1285 1
a1285 1
	c->sis_ctl = SIS_RXLEN;
@


1.40
log
@sis rev 0x91 seeprom support to get eaddr; from fgsch
we supplied 10 soekris boxes to 10 openbsd developers, and these all
have some variety or other of sis ethernet.  not ONE of them commented
about this diff when it was mailed out.  how very sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.39 2004/06/06 04:34:33 mcbride Exp $ */
a1121 1
	ifp->if_mtu = ETHERMTU;
a1123 1
	ifp->if_output = ether_output;
@


1.39
log
@- replace hand-rolled crc32 with ether_crc32_be()
- make multicast ranges work
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.38 2004/04/26 05:16:41 deraadt Exp $ */
d135 1
d365 19
d974 1
a974 1
	printf(": ");
d984 1
a984 1
			printf("DP83815C,");
d986 1
a986 1
			printf("DP83815D,");
d988 1
a988 1
			printf("DP83816A,");
d990 1
a990 1
			printf("srr %x,", sc->sis_srr);
d1050 3
a1052 1
		if (sc->sis_rev == SIS_REV_635 ||
@


1.38
log
@start with minimum recieve rings.  when we ifconfig up, allocate more.
this reduces mbuf clusters sitting around unused.  from mcbride, fixed
by me, tested by frantzen
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.37 2004/04/09 21:52:17 henning Exp $ */
a145 1
u_int32_t sis_crc(struct sis_softc *, caddr_t);
a678 34
u_int32_t sis_crc(sc, addr)
	struct sis_softc	*sc;
	caddr_t			addr;
{
	u_int32_t		crc, carry; 
	int			i, j;
	u_int8_t		c;

	/* Compute CRC for the address value. */
	crc = 0xFFFFFFFF; /* initial value */

	for (i = 0; i < 6; i++) {
		c = *(addr + i);
		for (j = 0; j < 8; j++) {
			carry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);
			crc <<= 1;
			c >>= 1;
			if (carry)
				crc = (crc ^ 0x04c11db6) | carry;
		}
	}

	/*
	 * return the filter bit position
	 *
	 * The NatSemi chip has a 512-bit filter, which is
	 * different than the SiS, so we special-case it.
	 */
	if (sc->sis_type == SIS_TYPE_83815)
		return((crc >> 23) & 0x1FF);

	return((crc >> 25) & 0x0000007F);
}

d691 1
d715 6
a720 1
		h = sis_crc(sc, enm->enm_addrlo);
d746 1
d765 7
a771 1
		h = sis_crc(sc, enm->enm_addrlo);
@


1.37
log
@do not whine if we cannot get mbufs. the countless printfd makes the machine
crawl under mbuf starvation, making the situationmuch worse, and don't make
sense in the first place.
ok tdeval@@ millert@@ beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.36 2004/01/01 11:44:49 markus Exp $ */
d1093 1
a1093 1
	for (i = 0; i < SIS_RX_LIST_CNT; i++) {
d1212 1
a1213 1
	bus_addr_t		next;
d1218 6
a1223 1
	for (i = 0; i < SIS_RX_LIST_CNT; i++) {
d1227 1
a1227 1
		if (i == (SIS_RX_LIST_CNT - 1)) {
d1326 1
a1326 1
		SIS_INC(i, SIS_RX_LIST_CNT);
d2047 1
a2047 1
	for (i = 0; i < SIS_RX_LIST_CNT; i++) {
@


1.36
log
@avoid redundant calls to sis_stop() for shared irqs; from freebsd; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.35 2003/12/11 07:41:19 chris Exp $ */
d1252 1
a1252 3
		if (m_new == NULL) {
			printf("%s: no memory for rx list -- packet dropped!\n",
			    sc->sc_dev.dv_xname);
a1253 1
		}
a1256 2
			printf("%s: no memory for rx list -- packet dropped!\n",
			    sc->sc_dev.dv_xname);
@


1.35
log
@Check DP83815/6 silicon revision register and apply current fixes documented
in National Semiconductor's datasheets and linux driver, depending on the
revision.  This fixes the short cable issues more reliably than the
fix from rev 1.31 (no long cable issue created), and also fixes lockups
on some chips under load.  From Poul-Henning Kamp / FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.34 2003/10/30 22:10:25 deraadt Exp $ */
d1693 1
d2028 3
d2083 1
@


1.34
log
@correct mac address fetching; pr 3532, jerry@@dunmire.org
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.33 2003/07/09 02:09:08 krw Exp $ */
a969 1
	printf(": %s", intrstr);
d976 2
d983 11
d1062 2
a1063 1
	printf(" address %s\n", ether_sprintf(sc->arpcom.ac_enaddr));
a1685 1
	int                     tmp;
d1733 21
d1823 30
a1865 39

	/*
	 * Page 75 of the DP83815 manual recommends the
	 * following register settings "for optimum
	 * performance." Note however that at least three
	 * of the registers are listed as "reserved" in
	 * the register map, so who knows what they do.
	 */
	if (sc->sis_type == SIS_TYPE_83815) {
		CSR_WRITE_4(sc, NS_PHY_PAGE, 0x0001);
		CSR_WRITE_4(sc, NS_PHY_CR, 0x189C);
		CSR_WRITE_4(sc, NS_PHY_TDATA, 0x0000);
		CSR_WRITE_4(sc, NS_PHY_DSPCFG, 0x5040);
		CSR_WRITE_4(sc, NS_PHY_SDCFG, 0x008C);
		
		/* 
		 * A small number of DP83815's will have excessive receive
		 * errors when using short cables (<30m/100feet) in 100Base-TX
		 * mode. This patch was taken from the National Semiconductor
		 * linux driver and (supposedly - no mention of this in any NS
		 * docs) modifies the dsp's signal attenuation.
		 */
		if (IFM_SUBTYPE(mii->mii_media_active) != IFM_10_T) {
			CSR_WRITE_4(sc, NS_PHY_PAGE, 0x0001);
			tmp = CSR_READ_4(sc, NS_PHY_DSPCFG);
			tmp &= 0xFFF;
			CSR_WRITE_4(sc, NS_PHY_DSPCFG, (tmp | 0x1000));
			DELAY(100);
			tmp = CSR_READ_4(sc, NS_PHY_TDATA);
			tmp &= 0xFF;
			if (!(tmp & 0x80) || (tmp >= 0xD8)) {
				CSR_WRITE_4(sc, NS_PHY_TDATA, 0xE8);
				tmp = CSR_READ_4(sc, NS_PHY_DSPCFG);
				CSR_WRITE_4(sc, NS_PHY_DSPCFG, (tmp | 0x20));
			} else {
				CSR_WRITE_4(sc, NS_PHY_PAGE, 0);
			}
		}
	}
@


1.33
log
@Fix problems with ICS1893 PHY and some sis chipsets.

Partial re-sync with FreeBSD, from Jeorg Sonnenberger.

Tested by Jeorg, Henning@@, Paul de Weerd, Otto@@, and myself.

ok henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.32 2003/06/30 02:52:09 avsm Exp $ */
d1035 1
a1035 2
		    sc->sis_rev == SIS_REV_630E ||
		    sc->sis_rev == SIS_REV_630EA1)
d1041 2
a1042 1
		    sc->sis_rev == SIS_REV_630ET) 	
@


1.32
log
@remove the use of sis_unit
jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.31 2003/03/10 12:13:23 mcbride Exp $ */
d136 4
d365 185
d555 1
a555 1
	int			i, val = 0;
d572 1
a572 2
		val = CSR_READ_4(sc, NS_BMCR + (reg * 4));
		return(val);
d575 5
d581 2
a582 2
	    sc->sis_rev < SIS_REV_635 && phy != 0)
		return(0);
d584 17
a600 2
	CSR_WRITE_4(sc, SIS_PHYCTL, (phy << 11) | (reg << 6) | SIS_PHYOP_READ);
	SIS_SETBIT(sc, SIS_PHYCTL, SIS_PHYCTL_ACCESS);
d602 1
a602 4
	for (i = 0; i < SIS_TIMEOUT; i++) {
		if (!(CSR_READ_4(sc, SIS_PHYCTL) & SIS_PHYCTL_ACCESS))
			break;
	}
d604 2
a605 4
	if (i == SIS_TIMEOUT) {
		printf("%s: PHY failed to come ready\n", sc->sc_dev.dv_xname);
		return(0);
	}
d607 3
a609 1
	val = (CSR_READ_4(sc, SIS_PHYCTL) >> 16) & 0xFFFF;
d611 3
a613 2
	if (val == 0xFFFF)
		return(0);
d615 2
a616 1
	return(val);
d619 1
d625 1
a625 1
	int			i;
d634 8
a641 2
	if (sc->sis_type == SIS_TYPE_900 && phy != 0)
		return;
d643 2
a644 3
	CSR_WRITE_4(sc, SIS_PHYCTL, (data << 16) | (phy << 11) |
	    (reg << 6) | SIS_PHYOP_WRITE);
	SIS_SETBIT(sc, SIS_PHYCTL, SIS_PHYCTL_ACCESS);
d646 8
a653 4
	for (i = 0; i < SIS_TIMEOUT; i++) {
		if (!(CSR_READ_4(sc, SIS_PHYCTL) & SIS_PHYCTL_ACCESS))
			break;
	}
d655 5
a659 2
	if (i == SIS_TIMEOUT)
		printf("%s: PHY failed to come ready\n", sc->sc_dev.dv_xname);
d661 5
d669 2
a670 1
void sis_miibus_statchg(self)
d905 1
a905 1
				sc->sc_dev.dv_xname, command & SIS_PSTATE_MASK);
d1241 1
a1241 1
				sc->sc_dev.dv_xname);
d1248 1
a1248 1
				sc->sc_dev.dv_xname);
d1710 1
a1710 1
			sc->sc_dev.dv_xname);
@


1.31
log
@Fix for the "short cable bug" in sis:

A small number of DP83815's will have excessive receive
errors when using short cables (<30m/100feet) in 100Base-TX
mode. This patch was taken from the National Semiconductor
linux driver and (supposedly - no mention of this in any NS
docs) modifies the dsp's signal attenuation.

ok jason@@ deraadt@@ markus@@

From Willem Dijkstra  wpd at xs4all dot nl
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.30 2002/11/22 10:38:48 markus Exp $ */
d400 1
a400 1
		printf("sis%d: PHY failed to come ready\n", sc->sis_unit);
d439 1
a439 1
		printf("sis%d: PHY failed to come ready\n", sc->sis_unit);
d591 1
a591 1
		printf("sis%d: reset never completed\n", sc->sis_unit);
a646 1
	sc->sis_unit = sc->sc_dev.dv_unit;
d678 2
a679 2
			printf("sis%d: chip is in D%d power mode "
			"-- setting to D0\n", sc->sis_unit, command & SIS_PSTATE_MASK);
d1014 2
a1015 2
			printf("sis%d: no memory for rx list "
			    "-- packet dropped!\n", sc->sis_unit);
d1021 2
a1022 2
			printf("sis%d: no memory for rx list "
			    "-- packet dropped!\n", sc->sis_unit);
d1483 2
a1484 2
		printf("sis%d: initialization failed: no "
			"memory for rx buffers\n", sc->sis_unit);
d1753 1
a1753 1
	printf("sis%d: watchdog timeout\n", sc->sis_unit);
@


1.30
log
@off by one for sis_tx_cnt, can lead to corrupt sis_tx_list; ok fgs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.29 2002/11/20 15:19:33 fgsch Exp $ */
d1448 1
d1592 24
@


1.29
log
@Read mac address correctly on rev 0x90; tested by Alexander, patch
provided from FreeBSD via Gabriel Gonzalez.
jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.27 2002/07/31 16:58:20 jason Exp $ */
d1369 1
a1369 1
	sc->sis_cdata.sis_tx_cnt += i - 1;
@


1.28
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d133 1
a133 1
void sis_read_630ea1_enaddr(struct sis_softc *, struct pci_attach_args *);
d340 1
a340 1
void sis_read_630ea1_enaddr(sc, pa)
d387 2
a388 1
	if (sc->sis_type == SIS_TYPE_900 && phy != 0)
d747 2
d809 3
a811 4
		command = pci_conf_read(pc, pa->pa_tag,
		    PCI_CLASS_REG) & 0x000000ff;
		if (command == SIS_REV_630S ||
		    command == SIS_REV_630E)
d816 3
a818 3
		if (command == SIS_REV_630EA1 ||
		    command == SIS_REV_630ET)
			sis_read_630ea1_enaddr(sc, pa);
@


1.27
log
@aaron: sync THEN access =)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.26 2002/07/05 13:48:11 aaron Exp $ */
d607 6
d622 2
a623 15
	struct pci_attach_args	*pa = (struct pci_attach_args *)aux;

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_SIS &&
	    PCI_VENDOR(pa->pa_id) != PCI_VENDOR_NS)
		return(0);

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_SIS_900:
	case PCI_PRODUCT_SIS_7016:
	case PCI_PRODUCT_NS_DP83815:
		return(1);
	}

	return(0);

@


1.26
log
@Typo; stobe -> strobe
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.25 2002/07/03 02:30:56 aaron Exp $ */
d1084 5
a1094 4
		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
		    ((caddr_t)cur_rx - sc->sc_listkva),
		    sizeof(struct sis_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
@


1.25
log
@Fix some major brain damage where I was performing arithmetic on a
physical address with a virtual address; thanks art@@. Now sis(4) compiles
and works on alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.24 2002/07/02 16:44:25 aaron Exp $ */
d225 1
a225 1
	 * Feed in each bit and stobe the clock.
@


1.24
log
@bus_dma'ify, works on an SiS900 and a Netgear FA411. Thanks to wilfried@@ for
testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.23 2002/03/25 20:28:06 mickey Exp $ */
d1059 1
a1059 1
	    ((caddr_t)c->sis_ptr - sc->sc_listkva), sizeof(struct sis_desc),
d1091 1
a1091 1
		    ((caddr_t)cur_rx->sis_ptr - sc->sc_listkva),
d1190 1
a1190 1
		    ((caddr_t)cur_tx->sis_ptr - sc->sc_listkva),
@


1.23
log
@support 630ETi; from wyllie@@dilex.net
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.22 2002/03/14 01:26:59 millert Exp $ */
a92 2
#include <uvm/uvm_extern.h>		/* for vtophys */

d641 1
a641 1
	int			s;
d832 39
a870 5
	sc->sis_ldata_ptr = malloc(sizeof(struct sis_list_data) + 8,
				M_DEVBUF, M_NOWAIT);
	if (sc->sis_ldata_ptr == NULL) {
		printf("%s: no memory for list buffers!\n", sc->sis_unit);
		goto fail;
d873 13
a885 2
	sc->sis_ldata = (struct sis_list_data *)sc->sis_ldata_ptr;
	bzero(sc->sis_ldata, sizeof(struct sis_list_data));
d938 2
a939 1
	int			i, nexti;
d945 13
a957 5
		nexti = (i == (SIS_TX_LIST_CNT - 1)) ? 0 : i+1;
		ld->sis_tx_list[i].sis_nextdesc =
		    &ld->sis_tx_list[nexti];
		ld->sis_tx_list[i].sis_next =
		    vtophys(&ld->sis_tx_list[nexti]);
d979 2
a980 1
	int			i, nexti;
d988 11
a998 5
		nexti = (i == (SIS_RX_LIST_CNT - 1)) ? 0 : i+1;
		ld->sis_rx_list[i].sis_nextdesc =
		    &ld->sis_rx_list[nexti];
		ld->sis_rx_list[i].sis_next =
		    vtophys(&ld->sis_rx_list[nexti]);
d1015 1
d1039 13
d1055 1
a1055 1
	c->sis_ptr = vtophys(mtod(m_new, caddr_t));
d1058 4
d1090 5
d1110 2
d1189 5
d1215 7
d1340 7
a1346 2
	struct mbuf		*m;
	int			frag, cur, cnt = 0;
a1352 1
	m = m_head;
d1355 10
a1364 14
	for (m = m_head; m != NULL; m = m->m_next) {
		if (m->m_len != 0) {
			if ((SIS_TX_LIST_CNT -
			    (sc->sis_cdata.sis_tx_cnt + cnt)) < 2)
				return(ENOBUFS);
			f = &sc->sis_ldata->sis_tx_list[frag];
			f->sis_ctl = SIS_CMDSTS_MORE | m->m_len;
			f->sis_ptr = vtophys(mtod(m, vm_offset_t));
			if (cnt != 0)
				f->sis_ctl |= SIS_CMDSTS_OWN;
			cur = frag;
			SIS_INC(frag, SIS_TX_LIST_CNT);
			cnt++;
		}
d1367 2
a1368 2
	if (m != NULL)
		return(ENOBUFS);
d1373 1
a1373 1
	sc->sis_cdata.sis_tx_cnt += cnt;
d1376 5
d1540 4
a1543 4
	CSR_WRITE_4(sc, SIS_RX_LISTPTR,
	    vtophys(&sc->sis_ldata->sis_rx_list[0]));
	CSR_WRITE_4(sc, SIS_TX_LISTPTR,
	    vtophys(&sc->sis_ldata->sis_tx_list[0]));
d1774 7
d1785 2
a1787 2
	bzero((char *)&sc->sis_ldata->sis_rx_list,
		sizeof(sc->sis_ldata->sis_rx_list));
d1793 7
d1804 2
a1806 3

	bzero((char *)&sc->sis_ldata->sis_tx_list,
		sizeof(sc->sis_ldata->sis_tx_list));
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.21 2002/02/15 20:45:31 nordin Exp $ */
d823 2
a824 1
		if (command == SIS_REV_630EA1)
@


1.21
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.20 2002/02/08 04:43:24 chris Exp $ */
d108 24
a131 24
int sis_probe		__P((struct device *, void *, void *));
void sis_attach		__P((struct device *, struct device *, void *));
int sis_intr		__P((void *));
void sis_shutdown	__P((void *));
int sis_newbuf		__P((struct sis_softc *, struct sis_desc *,
				struct mbuf *));
int sis_encap		__P((struct sis_softc *, struct mbuf *, u_int32_t *));
void sis_rxeof		__P((struct sis_softc *));
void sis_rxeoc		__P((struct sis_softc *));
void sis_txeof		__P((struct sis_softc *));
void sis_tick		__P((void *));
void sis_start		__P((struct ifnet *));
int sis_ioctl		__P((struct ifnet *, u_long, caddr_t));
void sis_init		__P((void *));
void sis_stop		__P((struct sis_softc *));
void sis_watchdog	__P((struct ifnet *));
int sis_ifmedia_upd	__P((struct ifnet *));
void sis_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));

u_int16_t sis_reverse	__P((u_int16_t));
void sis_delay		__P((struct sis_softc *));
void sis_eeprom_idle	__P((struct sis_softc *));
void sis_eeprom_putbyte	__P((struct sis_softc *, int));
void sis_eeprom_getword	__P((struct sis_softc *, int, u_int16_t *));
d133 1
a133 1
void sis_read_cmos	__P((struct sis_softc *, struct pci_attach_args *, caddr_t, int, int));
d135 2
a136 2
void sis_read_630ea1_enaddr    __P((struct sis_softc *, struct pci_attach_args *));
void sis_read_eeprom	__P((struct sis_softc *, caddr_t, int, int, int));
d138 10
a147 10
int sis_miibus_readreg	__P((struct device *, int, int));
void sis_miibus_writereg	__P((struct device *, int, int, int));
void sis_miibus_statchg	__P((struct device *));

void sis_setmulti_sis	__P((struct sis_softc *));
void sis_setmulti_ns	__P((struct sis_softc *));
u_int32_t sis_crc	__P((struct sis_softc *, caddr_t));
void sis_reset		__P((struct sis_softc *));
int sis_list_rx_init	__P((struct sis_softc *));
int sis_list_tx_init	__P((struct sis_softc *));
@


1.20
log
@Partial sync with FreeBSD, mostly bugfixes from Luigi Rizzo (ok jason@@)

-Remove m_devget on non-STRICT_ALIGNMENT architectures, supposedly a 50-70%
 performance increase for peak packet forwarding on the Soekris 486/133 on fbsd

-Fix a bug in the driver -- under load, the receive unit could become
 idle and the driver would not detect the event, requiring userland
 to cycle the interface to bring it up again.

 The fix consists in adding SIS_IMR_RX_IDLE to the interrupt mask and
 add a command in sis_intr() to restart the receiver when this happens.

-While at it, make the test of status bits more efficient

-Slightly simplify the code to initialize the ring buffers

-Add VLAN support (Accept Long Packets)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.19 2001/11/06 19:53:19 miod Exp $ */
d1388 1
a1388 1
		(void)splx(s);
d1498 1
a1498 1
	(void)splx(s);
d1617 1
a1617 1
	(void)splx(s);
@


1.19
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.18 2001/09/23 22:41:25 aaron Exp $ */
d62 1
d856 4
d894 1
a894 1
	int			i;
d900 5
a904 11
		if (i == (SIS_TX_LIST_CNT - 1)) {
			ld->sis_tx_list[i].sis_nextdesc =
			    &ld->sis_tx_list[0];
			ld->sis_tx_list[i].sis_next =
			    vtophys(&ld->sis_tx_list[0]);
		} else {
			ld->sis_tx_list[i].sis_nextdesc =
			    &ld->sis_tx_list[i + 1];
			ld->sis_tx_list[i].sis_next =
			    vtophys(&ld->sis_tx_list[i + 1]);
		}
d926 1
a926 1
	int			i;
d934 5
a938 11
		if (i == (SIS_RX_LIST_CNT - 1)) {
			ld->sis_rx_list[i].sis_nextdesc =
			    &ld->sis_rx_list[0];
			ld->sis_rx_list[i].sis_next =
			    vtophys(&ld->sis_rx_list[0]);
		} else {
			ld->sis_rx_list[i].sis_nextdesc =
			    &ld->sis_rx_list[i + 1];
			ld->sis_rx_list[i].sis_next =
			    vtophys(&ld->sis_rx_list[i + 1]);
		}
a1003 1
		struct mbuf		*m0 = NULL;
d1027 26
a1052 6
		m0 = m_devget(mtod(m, char *) - ETHER_ALIGN,
		    total_len + ETHER_ALIGN, 0, ifp, NULL);
		sis_newbuf(sc, cur_rx, m);
		if (m0 == NULL) {
			ifp->if_ierrors++;
			continue;
a1053 2
		m_adj(m0, ETHER_ALIGN);
		m = m0;
d1202 3
a1204 4
		if ((status & SIS_ISR_TX_DESC_OK) ||
		    (status & SIS_ISR_TX_ERR) ||
		    (status & SIS_ISR_TX_OK) ||
		    (status & SIS_ISR_TX_IDLE))
d1207 3
a1209 2
		if ((status & SIS_ISR_RX_DESC_OK) ||
		    (status & SIS_ISR_RX_OK))
d1212 1
a1212 2
		if ((status & SIS_ISR_RX_ERR) ||
		    (status & SIS_ISR_RX_OFLOW)) {
d1214 3
a1216 1
		}
d1445 3
@


1.19.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.19 2001/11/06 19:53:19 miod Exp $ */
a61 1
#include "vlan.h"
d107 24
a130 24
int sis_probe(struct device *, void *, void *);
void sis_attach(struct device *, struct device *, void *);
int sis_intr(void *);
void sis_shutdown(void *);
int sis_newbuf(struct sis_softc *, struct sis_desc *,
				struct mbuf *);
int sis_encap(struct sis_softc *, struct mbuf *, u_int32_t *);
void sis_rxeof(struct sis_softc *);
void sis_rxeoc(struct sis_softc *);
void sis_txeof(struct sis_softc *);
void sis_tick(void *);
void sis_start(struct ifnet *);
int sis_ioctl(struct ifnet *, u_long, caddr_t);
void sis_init(void *);
void sis_stop(struct sis_softc *);
void sis_watchdog(struct ifnet *);
int sis_ifmedia_upd(struct ifnet *);
void sis_ifmedia_sts(struct ifnet *, struct ifmediareq *);

u_int16_t sis_reverse(u_int16_t);
void sis_delay(struct sis_softc *);
void sis_eeprom_idle(struct sis_softc *);
void sis_eeprom_putbyte(struct sis_softc *, int);
void sis_eeprom_getword(struct sis_softc *, int, u_int16_t *);
d132 1
a132 1
void sis_read_cmos(struct sis_softc *, struct pci_attach_args *, caddr_t, int, int);
d134 2
a135 2
void sis_read_630ea1_enaddr(struct sis_softc *, struct pci_attach_args *);
void sis_read_eeprom(struct sis_softc *, caddr_t, int, int, int);
d137 10
a146 10
int sis_miibus_readreg(struct device *, int, int);
void sis_miibus_writereg(struct device *, int, int, int);
void sis_miibus_statchg(struct device *);

void sis_setmulti_sis(struct sis_softc *);
void sis_setmulti_ns(struct sis_softc *);
u_int32_t sis_crc(struct sis_softc *, caddr_t);
void sis_reset(struct sis_softc *);
int sis_list_rx_init(struct sis_softc *);
int sis_list_tx_init(struct sis_softc *);
d822 1
a822 2
		if (command == SIS_REV_630EA1 ||
		    command == SIS_REV_630ET)
a854 4
#if NVLAN > 0
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
#endif

d889 1
a889 1
	int			i, nexti;
d895 11
a905 5
		nexti = (i == (SIS_TX_LIST_CNT - 1)) ? 0 : i+1;
		ld->sis_tx_list[i].sis_nextdesc =
		    &ld->sis_tx_list[nexti];
		ld->sis_tx_list[i].sis_next =
		    vtophys(&ld->sis_tx_list[nexti]);
d927 1
a927 1
	int			i, nexti;
d935 11
a945 5
		nexti = (i == (SIS_RX_LIST_CNT - 1)) ? 0 : i+1;
		ld->sis_rx_list[i].sis_nextdesc =
		    &ld->sis_rx_list[nexti];
		ld->sis_rx_list[i].sis_next =
		    vtophys(&ld->sis_rx_list[nexti]);
d1011 1
d1035 6
a1040 26
#ifndef __STRICT_ALIGNMENT
		/*
		 * On some architectures, we do not have alignment problems,
		 * so try to allocate a new buffer for the receive ring, and
		 * pass up the one where the packet is already, saving the
		 * expensive copy done in m_devget().
		 * If we are on an architecture with alignment problems, or
		 * if the allocation fails, then use m_devget and leave the
		 * existing buffer in the receive ring.
		 */
		if (sis_newbuf(sc, cur_rx, NULL) == 0) {
			m->m_pkthdr.rcvif = ifp;
			m->m_pkthdr.len = m->m_len = total_len;
		} else
#endif
		{
			struct mbuf *m0;
			m0 = m_devget(mtod(m, char *) - ETHER_ALIGN,
			    total_len + ETHER_ALIGN, 0, ifp, NULL);
			sis_newbuf(sc, cur_rx, m);
			if (m0 == NULL) {
				ifp->if_ierrors++;
				continue;
			}
			m_adj(m0, ETHER_ALIGN);
			m = m0;
d1042 2
d1192 4
a1195 3
		if (status &
		    (SIS_ISR_TX_DESC_OK | SIS_ISR_TX_ERR |
		     SIS_ISR_TX_OK | SIS_ISR_TX_IDLE))
d1198 2
a1199 3
		if (status &
		    (SIS_ISR_RX_DESC_OK | SIS_ISR_RX_OK |
		     SIS_ISR_RX_IDLE))
d1202 2
a1203 1
		if (status & (SIS_ISR_RX_ERR | SIS_ISR_RX_OFLOW))
d1205 1
a1205 3

		if (status & (SIS_ISR_RX_IDLE))
			SIS_SETBIT(sc, SIS_CSR, SIS_CSR_RX_ENABLE);
d1377 1
a1377 1
		splx(s);
a1434 3
	/* Accept Long Packets for VLAN support */
	SIS_SETBIT(sc, SIS_RX_CFG, SIS_RXCFG_RX_JABBER);

d1484 1
a1484 1
	splx(s);
d1603 1
a1603 1
	splx(s);
@


1.19.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.19.2.1 2002/06/11 03:42:25 art Exp $ */
d93 2
d227 1
a227 1
	 * Feed in each bit and strobe the clock.
d643 1
a643 1
	int			i, s;
d834 6
a839 1
	sc->sc_dmat = pa->pa_dmat;
d841 1
a841 24
	if (bus_dmamem_alloc(sc->sc_dmat, sizeof(struct sis_list_data),
	    PAGE_SIZE, 0, sc->sc_listseg, 1, &sc->sc_listnseg,
	    BUS_DMA_NOWAIT) != 0) {
		printf(": can't alloc list mem\n");
		return;
	}
	if (bus_dmamem_map(sc->sc_dmat, sc->sc_listseg, sc->sc_listnseg,
	    sizeof(struct sis_list_data), &sc->sc_listkva,
	    BUS_DMA_NOWAIT) != 0) {
		printf(": can't map list mem\n");
		return;
	}
	if (bus_dmamap_create(sc->sc_dmat, sizeof(struct sis_list_data), 1,
	    sizeof(struct sis_list_data), 0, BUS_DMA_NOWAIT,
	    &sc->sc_listmap) != 0) {
		printf(": can't alloc list map\n");
		return;
	}
	if (bus_dmamap_load(sc->sc_dmat, sc->sc_listmap, sc->sc_listkva,
	    sizeof(struct sis_list_data), NULL, BUS_DMA_NOWAIT) != 0) {
		printf(": can't load list map\n");
		return;
	}
	sc->sis_ldata = (struct sis_list_data *)sc->sc_listkva;
a843 27
	for (i = 0; i < SIS_RX_LIST_CNT; i++) {
		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES, 0,
		    BUS_DMA_NOWAIT, &sc->sis_ldata->sis_rx_list[i].map) != 0) {
			printf(": can't create rx map\n");
			return;
		}
	}
	if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES, 0,
	    BUS_DMA_NOWAIT, &sc->sc_rx_sparemap) != 0) {
		printf(": can't create rx spare map\n");
		return;
	}

	for (i = 0; i < SIS_TX_LIST_CNT; i++) {
		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    SIS_TX_LIST_CNT - 3, MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &sc->sis_ldata->sis_tx_list[i].map) != 0) {
			printf(": can't create tx map\n");
			return;
		}
	}
	if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, SIS_TX_LIST_CNT - 3,
	    MCLBYTES, 0, BUS_DMA_NOWAIT, &sc->sc_tx_sparemap) != 0) {
		printf(": can't create tx spare map\n");
		return;
	}

d895 1
a895 2
	int			i;
	bus_addr_t		next;
d901 5
a905 13
		next = sc->sc_listmap->dm_segs[0].ds_addr;
		if (i == (SIS_TX_LIST_CNT - 1)) {
			ld->sis_tx_list[i].sis_nextdesc =
			    &ld->sis_tx_list[0];
			next +=
			    offsetof(struct sis_list_data, sis_tx_list[0]);
		} else {
			ld->sis_tx_list[i].sis_nextdesc =
			    &ld->sis_tx_list[i+1];
			next +=
			    offsetof(struct sis_list_data, sis_tx_list[i+1]);
		}
		ld->sis_tx_list[i].sis_next = next;
d927 1
a927 2
	int			i;
	bus_addr_t		next;
d935 5
a939 11
		next = sc->sc_listmap->dm_segs[0].ds_addr;
		if (i == (SIS_RX_LIST_CNT - 1)) {
			ld->sis_rx_list[i].sis_nextdesc = &ld->sis_rx_list[0];
			next +=
			    offsetof(struct sis_list_data, sis_rx_list[0]);
		} else {
			ld->sis_rx_list[i].sis_nextdesc = &ld->sis_rx_list[i+1];
			next +=
			    offsetof(struct sis_list_data, sis_rx_list[i+1]);
		}
		ld->sis_rx_list[i].sis_next = next;
a955 1
	bus_dmamap_t		map;
a978 13
	if (bus_dmamap_load(sc->sc_dmat, sc->sc_rx_sparemap,
	    mtod(m_new, caddr_t), MCLBYTES, NULL, BUS_DMA_NOWAIT) != 0) {
		printf("%s: rx load failed\n", sc->sc_dev.dv_xname);
		m_freem(m_new);
		return (ENOBUFS);
	}
	map = c->map;
	c->map = sc->sc_rx_sparemap;
	sc->sc_rx_sparemap = map;

	bus_dmamap_sync(sc->sc_dmat, c->map, 0, c->map->dm_mapsize,
	    BUS_DMASYNC_PREREAD);

d982 1
a982 1
	c->sis_ptr = c->map->dm_segs[0].ds_addr + sizeof(u_int64_t);
a984 4
	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    ((caddr_t)c - sc->sc_listkva), sizeof(struct sis_desc),
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

a1006 5
		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
		    ((caddr_t)cur_rx - sc->sc_listkva),
		    sizeof(struct sis_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

a1012 1

a1027 2
		bus_dmamap_sync(sc->sc_dmat, cur_rx->map, 0,
		    cur_rx->map->dm_mapsize, BUS_DMASYNC_POSTREAD);
a1104 5
		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
		    ((caddr_t)cur_tx - sc->sc_listkva),
		    sizeof(struct sis_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

a1125 7
		if (cur_tx->map->dm_nsegs != 0) {
			bus_dmamap_t map = cur_tx->map;

			bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, map);
		}
d1244 2
a1245 7
	int			frag, cur, i;
	bus_dmamap_t		map;

	map = sc->sc_tx_sparemap;
	if (bus_dmamap_load_mbuf(sc->sc_dmat, map,
	    m_head, BUS_DMA_NOWAIT) != 0)
		return (ENOBUFS);
d1252 1
d1255 14
a1268 10
	for (i = 0; i < map->dm_nsegs; i++) {
		if ((SIS_TX_LIST_CNT - (sc->sis_cdata.sis_tx_cnt + i)) < 2)
			return(ENOBUFS);
		f = &sc->sis_ldata->sis_tx_list[frag];
		f->sis_ctl = SIS_CMDSTS_MORE | map->dm_segs[i].ds_len;
		f->sis_ptr = map->dm_segs[i].ds_addr;
		if (i != 0)
			f->sis_ctl |= SIS_CMDSTS_OWN;
		cur = frag;
		SIS_INC(frag, SIS_TX_LIST_CNT);
d1271 2
a1272 2
	bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
d1277 1
a1277 1
	sc->sis_cdata.sis_tx_cnt += i - 1;
a1279 5
	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    offsetof(struct sis_list_data, sis_tx_list[0]),
	    sizeof(struct sis_desc) * SIS_TX_LIST_CNT,  
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

d1439 4
a1442 4
	CSR_WRITE_4(sc, SIS_RX_LISTPTR, sc->sc_listmap->dm_segs[0].ds_addr +
	    offsetof(struct sis_list_data, sis_rx_list[0]));
	CSR_WRITE_4(sc, SIS_TX_LISTPTR, sc->sc_listmap->dm_segs[0].ds_addr +
	    offsetof(struct sis_list_data, sis_tx_list[0]));
a1672 7
		if (sc->sis_ldata->sis_rx_list[i].map->dm_nsegs != 0) {
			bus_dmamap_t map = sc->sis_ldata->sis_rx_list[i].map;

			bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
			    BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->sc_dmat, map);
		}
a1676 2
		bzero((char *)&sc->sis_ldata->sis_rx_list[i],
		    sizeof(struct sis_desc) - sizeof(bus_dmamap_t));
d1678 2
a1684 7
		if (sc->sis_ldata->sis_tx_list[i].map->dm_nsegs != 0) {
			bus_dmamap_t map = sc->sis_ldata->sis_tx_list[i].map;

			bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, map);
		}
a1688 2
		bzero((char *)&sc->sis_ldata->sis_tx_list[i],
		    sizeof(struct sis_desc) - sizeof(bus_dmamap_t));
d1690 3
@


1.19.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d133 1
a133 1
void sis_read_mac(struct sis_softc *, struct pci_attach_args *);
d340 1
a340 1
void sis_read_mac(sc, pa)
d387 1
a387 2
	if (sc->sis_type == SIS_TYPE_900 &&
	    sc->sis_rev < SIS_REV_635 && phy != 0)
a606 6
const struct pci_matchid sis_devices[] = {
	{ PCI_VENDOR_SIS, PCI_PRODUCT_SIS_900 },
	{ PCI_VENDOR_SIS, PCI_PRODUCT_SIS_7016 },
	{ PCI_VENDOR_NS, PCI_PRODUCT_NS_DP83815 },
};

d616 15
a630 2
	return (pci_matchbyid((struct pci_attach_args *)aux, sis_devices,
	    sizeof(sis_devices)/sizeof(sis_devices[0])));
a752 2
	sc->sis_rev = PCI_REVISION(pa->pa_class);

d813 4
a816 3
		if (sc->sis_rev == SIS_REV_630S ||
		    sc->sis_rev == SIS_REV_630E ||
		    sc->sis_rev == SIS_REV_630EA1)
d821 3
a823 3
		if (sc->sis_rev == SIS_REV_635 ||
		    sc->sis_rev == SIS_REV_630ET) 	
			sis_read_mac(sc, pa);
d1374 1
a1374 1
	sc->sis_cdata.sis_tx_cnt += i;
a1452 1
	int                     tmp;
a1595 24
		
		/* 
		 * A small number of DP83815's will have excessive receive
		 * errors when using short cables (<30m/100feet) in 100Base-TX
		 * mode. This patch was taken from the National Semiconductor
		 * linux driver and (supposedly - no mention of this in any NS
		 * docs) modifies the dsp's signal attenuation.
		 */
		if (IFM_SUBTYPE(mii->mii_media_active) != IFM_10_T) {
			CSR_WRITE_4(sc, NS_PHY_PAGE, 0x0001);
			tmp = CSR_READ_4(sc, NS_PHY_DSPCFG);
			tmp &= 0xFFF;
			CSR_WRITE_4(sc, NS_PHY_DSPCFG, (tmp | 0x1000));
			DELAY(100);
			tmp = CSR_READ_4(sc, NS_PHY_TDATA);
			tmp &= 0xFF;
			if (!(tmp & 0x80) || (tmp >= 0xD8)) {
				CSR_WRITE_4(sc, NS_PHY_TDATA, 0xE8);
				tmp = CSR_READ_4(sc, NS_PHY_DSPCFG);
				CSR_WRITE_4(sc, NS_PHY_DSPCFG, (tmp | 0x20));
			} else {
				CSR_WRITE_4(sc, NS_PHY_PAGE, 0);
			}
		}
@


1.18
log
@Read the MAC address correctly from 630EA1-based sis(4) devices. Should fix
problems people have been reporting of this nature with the SiS network
devices found on some motherboards; fixes pr#2085. Patch by peter@@, jason@@ ok
Also, some space vs tab fixes while we're here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.17 2001/08/25 10:13:29 art Exp $ */
d92 1
a92 1
#include <vm/vm.h>		/* for vtophys */
@


1.17
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.16 2001/08/12 20:03:49 mickey Exp $ */
d92 1
a92 1
#include <vm/vm.h>              /* for vtophys */
d134 1
d341 21
d491 4
a494 4
        struct ifnet            *ifp;
        struct arpcom           *ac = &sc->arpcom;
        struct ether_multi      *enm;
        struct ether_multistep  step;
d521 2
a522 2
        ETHER_FIRST_MULTI(step, ac, enm);
        while (enm != NULL) {
d605 1
a605 1
        return;
d817 2
a818 3
		    command == SIS_REV_630E ||
		    command == SIS_REV_630EA1)
		        sis_read_cmos(sc, pa, (caddr_t)&sc->arpcom.ac_enaddr,
d822 3
d831 1
a831 1
        
d1001 2
a1002 2
        struct mbuf		*m;
        struct ifnet		*ifp;
@


1.16
log
@remove redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.15 2001/06/27 06:34:48 kjc Exp $ */
d716 1
a716 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin, pa->pa_intrline,
	    &ih)) {
@


1.15
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.14 2001/06/24 20:27:00 fgsch Exp $ */
a92 1
#include <vm/pmap.h>            /* for vtophys */
@


1.14
log
@more ether_input_mbuf() conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.13 2001/05/10 23:34:01 aaron Exp $ */
d829 2
a830 1
	ifp->if_snd.ifq_maxlen = SIS_TX_LIST_CNT - 1;
d1131 1
a1131 1
			if (ifp->if_snd.ifq_head != NULL)
d1194 1
a1194 1
	if (ifp->if_snd.ifq_head != NULL)
a1261 1
	int			s;
d1274 1
a1274 3
		s = splimp();
		IF_DEQUEUE(&ifp->if_snd, m_head);
		splx(s);
a1278 3
			s = splimp();
			IF_PREPEND(&ifp->if_snd, m_head);
			splx(s);
d1283 3
d1295 2
d1602 1
a1602 1
	if (ifp->if_snd.ifq_head != NULL)
@


1.13
log
@Simplify probe routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.12 2001/03/14 15:17:31 aaron Exp $ */
a977 1
        struct ether_header	*eh;
a1022 1
		eh = mtod(m, struct ether_header *);
d1029 2
a1030 3
		/* Remove header from mbuf and pass it on. */
		m_adj(m, sizeof(struct ether_header));
		ether_input(ifp, eh, m);
@


1.12
log
@Disable PME mode in sis_reset() to fix a problem with the DP83815 chip on
some motherboards; from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.11 2001/03/12 05:51:18 aaron Exp $ */
a603 1
		return(1);
a604 1
		return(1);
@


1.11
log
@Add support for reading the MAC address from the APC CMOS RAM in the
integrated Ethernet controller on the SiS630E-based chipsets; from FreeBSD,
this patch mostly by jason@@. With these changes, my SiS900 card still works
fine, but the new functionality is actually untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.10 2001/02/20 19:39:45 mickey Exp $ */
d574 10
@


1.10
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.9 2001/02/20 19:15:19 jason Exp $ */
d132 3
d316 25
d770 27
a796 2
		sis_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
		    SIS_EE_NODEADDR, 3, 0);
@


1.9
log
@sync with freebsd:
use LIST_FOREACH construct instead of homebrew loop
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.8 2000/12/06 15:48:28 mickey Exp $ */
a789 4
#if NBPFILTER > 0
	bpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
		  sizeof(struct ether_header));
#endif
@


1.8
log
@new timeouts, proper spl()s; aaron@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.7 2000/10/16 17:08:08 aaron Exp $ */
d33 1
a33 1
 * $FreeBSD: src/sys/pci/if_sis.c,v 1.21 2000/08/22 23:26:51 wpaul Exp $
d1431 1
a1431 2
		for (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;
		    miisc = LIST_NEXT(miisc, mii_list))
@


1.7
log
@Use mii_attach() directly instead of mii_phy_probe().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.6 2000/08/25 17:39:25 aaron Exp $ */
d72 1
d596 1
a596 1
	s = splimp();
d1064 1
a1064 1
	s = splimp();
d1079 1
a1079 1
	timeout(sis_tick, sc, hz);
d1207 1
d1220 1
d1222 1
d1227 1
d1229 1
d1264 1
a1264 1
	s = splimp();
d1410 2
a1411 1
	timeout(sis_tick, sc, hz);
d1471 1
a1471 1
	s = splimp();
d1537 1
d1544 1
d1552 1
d1569 1
a1569 1
	untimeout(sis_tick, sc);
@


1.6
log
@Sync with FreeBSD. Summary of changes:

- Modify to poll link state and positively set MAC's duplex as needed.
- Program some DP83815 registers that are recommended for optimum performance.
- Select the TX DMA burst size correctly for 10 and 100Mbps modes, especially
  improving the performance of the DP83815 at 10Mbps.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.5 2000/07/06 23:25:17 aaron Exp $ */
d775 2
a776 1
	mii_phy_probe(self, &sc->sc_mii, 0xffffffff);
@


1.5
log
@Fix a minor bug in the MAC address unscrambling code. From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.4 2000/07/06 19:12:12 aaron Exp $ */
d33 1
a33 1
 * $FreeBSD: src/sys/pci/if_sis.c,v 1.18 2000/07/06 19:21:07 wpaul Exp $
d40 3
a397 1
	struct mii_data		*mii;
d399 1
a399 11
	mii = &sc->sc_mii;

	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX) {
		SIS_SETBIT(sc, SIS_TX_CFG,
		    (SIS_TXCFG_IGN_HBEAT|SIS_TXCFG_IGN_CARR));
		SIS_SETBIT(sc, SIS_RX_CFG, SIS_RXCFG_RX_TXPKTS);
	} else {
		SIS_CLRBIT(sc, SIS_TX_CFG,
		    (SIS_TXCFG_IGN_HBEAT|SIS_TXCFG_IGN_CARR));
		SIS_CLRBIT(sc, SIS_RX_CFG, SIS_RXCFG_RX_TXPKTS);
	}
d1059 1
d1064 2
d1068 9
d1113 1
a1113 1
		if ((status & SIS_ISR_TX_OK) ||
d1115 1
d1119 2
a1120 1
		if (status & SIS_ISR_RX_OK)
d1208 3
d1351 1
d1353 15
a1367 1
	CSR_WRITE_4(sc, SIS_TX_CFG, SIS_TXCFG);
d1379 1
d1381 16
d1415 1
d1419 9
a1427 2
	if (ifp->if_flags & IFF_UP)
		sis_init(sc);
d1565 2
@


1.4
log
@Add support for the National Semiconductor DP83815 Fast Ethernet chip.
This chip is currently being used on the NetGear FA312-TX adapter, which is
presumably a replacement for the PNIC-based FA310-TX. From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.3 2000/02/15 02:28:14 jason Exp $ */
d33 1
a33 1
 * $FreeBSD: src/sys/pci/if_sis.c,v 1.17 2000/07/06 06:02:04 wpaul Exp $
d732 1
a732 1
			tmp[3] |= tmp[2] >> 15;
d734 1
a734 1
			tmp[2] |= tmp[1] >> 15;
d736 1
a736 1
			tmp[1] |= tmp[0] >> 15;
@


1.3
log
@make sure to call ether_{add,del}multi() as appropriate in xxx_ioctl()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.2 1999/12/08 00:38:08 aaron Exp $ */
d33 1
a33 1
 * $FreeBSD: src/sys/pci/if_sis.c,v 1.13 1999/09/25 17:29:01 wpaul Exp $
d123 1
d134 3
a136 2
void sis_setmulti	__P((struct sis_softc *));
u_int32_t sis_calchash	__P((caddr_t));
d155 15
d253 2
a256 2
	SIO_SET(SIS_EECTL_CLK);
	sis_delay(sc);
d314 20
a333 1
	int			i, val;
d366 7
d412 2
a413 1
u_int32_t sis_calchash(addr)
d434 9
a442 1
	/* return the filter bit position */
d446 51
a496 1
void sis_setmulti(sc)
d525 1
a525 1
		h = sis_calchash(enm->enm_addrlo);
d567 2
a568 1
	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_SIS)
d576 2
d605 14
a618 1
	sc->sis_type = SIS_TYPE_900;
d711 42
a752 1
	sis_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr, SIS_EE_NODEADDR,3,0);
d755 1
a755 1

d1258 21
a1278 9
	CSR_WRITE_4(sc, SIS_RXFILT_CTL, SIS_FILTADDR_PAR0);
	CSR_WRITE_4(sc, SIS_RXFILT_DATA,
	    ((u_int16_t *)sc->arpcom.ac_enaddr)[0]);
	CSR_WRITE_4(sc, SIS_RXFILT_CTL, SIS_FILTADDR_PAR1);
	CSR_WRITE_4(sc, SIS_RXFILT_DATA,
	    ((u_int16_t *)sc->arpcom.ac_enaddr)[1]);
	CSR_WRITE_4(sc, SIS_RXFILT_CTL, SIS_FILTADDR_PAR2);
	CSR_WRITE_4(sc, SIS_RXFILT_DATA,
	    ((u_int16_t *)sc->arpcom.ac_enaddr)[2]);
d1294 11
d1324 4
a1327 1
	sis_setmulti(sc);
d1454 4
a1457 1
			sis_setmulti(sc);
@


1.2
log
@Remove unused #define cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.1 1999/12/04 20:27:36 aaron Exp $ */
d1260 12
a1271 2
		sis_setmulti(sc);
		error = 0;
@


1.2.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.3 2000/02/15 02:28:14 jason Exp $ */
d1260 2
a1261 12
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			sis_setmulti(sc);
			error = 0;
		}
@


1.2.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.12 2001/03/14 15:17:31 aaron Exp $ */
d33 1
a33 1
 * $FreeBSD: src/sys/pci/if_sis.c,v 1.30 2001/02/06 10:11:47 phk Exp $
a39 3
 * This driver also supports the NatSemi DP83815. Datasheets are
 * available from http://www.national.com.
 *
a68 1
#include <sys/timeout.h>
a122 1
u_int16_t sis_reverse	__P((u_int16_t));
a126 3
#ifdef __i386__
void sis_read_cmos	__P((struct sis_softc *, struct pci_attach_args *, caddr_t, int, int));
#endif
d133 2
a134 3
void sis_setmulti_sis	__P((struct sis_softc *));
void sis_setmulti_ns	__P((struct sis_softc *));
u_int32_t sis_crc	__P((struct sis_softc *, caddr_t));
a152 15
/*
 * Routine to reverse the bits in a word. Stolen almost
 * verbatim from /usr/games/fortune.
 */
u_int16_t sis_reverse(n)
	u_int16_t		n;
{
	n = ((n >>  1) & 0x5555) | ((n <<  1) & 0xaaaa);
	n = ((n >>  2) & 0x3333) | ((n <<  2) & 0xcccc);
	n = ((n >>  4) & 0x0f0f) | ((n <<  4) & 0xf0f0);
	n = ((n >>  8) & 0x00ff) | ((n <<  8) & 0xff00);

	return(n);
}

d236 1
a236 1
	SIO_CLR(SIS_EECTL_CLK);
d238 1
a238 1
	SIO_SET(SIS_EECTL_CSEL);
a291 25
#ifdef __i386__
void sis_read_cmos(sc, pa, dest, off, cnt)
	struct sis_softc *sc;
	struct pci_attach_args *pa;
	caddr_t dest;
	int off, cnt;
{
	bus_space_tag_t btag;
	u_int32_t reg;
	int i;

	reg = pci_conf_read(pa->pa_pc, pa->pa_tag, 0x48);
	pci_conf_write(pa->pa_pc, pa->pa_tag, 0x48, reg | 0x40);

	btag = I386_BUS_SPACE_IO;

	for (i = 0; i < cnt; i++) {
		bus_space_write_1(btag, 0x0, 0x70, i + off);
		*(dest + i) = bus_space_read_1(btag, 0x0, 0x71);
	}

	pci_conf_write(pa->pa_pc, pa->pa_tag, 0x48, reg & ~0x40);
}
#endif

d297 1
a297 20
	int			i, val = 0;

	if (sc->sis_type == SIS_TYPE_83815) {
		if (phy != 0)
			return(0);
		/*
		 * The NatSemi chip can take a while after
		 * a reset to come ready, during which the BMSR
		 * returns a value of 0. This is *never* supposed
		 * to happen: some of the BMSR bits are meant to
		 * be hardwired in the on position, and this can
		 * confuse the miibus code a bit during the probe
		 * and attach phase. So we make an effort to check
		 * for this condition and wait for it to clear.
		 */
		if (!CSR_READ_4(sc, NS_BMSR))
			DELAY(1000);
		val = CSR_READ_4(sc, NS_BMCR + (reg * 4));
		return(val);
	}
a329 7
	if (sc->sis_type == SIS_TYPE_83815) {
		if (phy != 0)
			return;
		CSR_WRITE_4(sc, NS_BMCR + (reg * 4), data);
		return;
	}

d352 3
d356 9
a364 1
	sis_init(sc);
d369 1
a369 2
u_int32_t sis_crc(sc, addr)
	struct sis_softc	*sc;
d390 1
a390 9
	/*
	 * return the filter bit position
	 *
	 * The NatSemi chip has a 512-bit filter, which is
	 * different than the SiS, so we special-case it.
	 */
	if (sc->sis_type == SIS_TYPE_83815)
		return((crc >> 23) & 0x1FF);

d394 1
a394 51
void sis_setmulti_ns(sc)
	struct sis_softc	*sc;
{
        struct ifnet            *ifp;
        struct arpcom           *ac = &sc->arpcom;
        struct ether_multi      *enm;
        struct ether_multistep  step;
	u_int32_t		h = 0, i, filtsave;
	int			bit, index;

	ifp = &sc->arpcom.ac_if;

	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
		SIS_CLRBIT(sc, SIS_RXFILT_CTL, NS_RXFILTCTL_MCHASH);
		SIS_SETBIT(sc, SIS_RXFILT_CTL, SIS_RXFILTCTL_ALLMULTI);
		return;
	}

	/*
	 * We have to explicitly enable the multicast hash table
	 * on the NatSemi chip if we want to use it, which we do.
	 */
	SIS_SETBIT(sc, SIS_RXFILT_CTL, NS_RXFILTCTL_MCHASH);
	SIS_CLRBIT(sc, SIS_RXFILT_CTL, SIS_RXFILTCTL_ALLMULTI);

	filtsave = CSR_READ_4(sc, SIS_RXFILT_CTL);

	/* first, zot all the existing hash bits */
	for (i = 0; i < 32; i++) {
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, NS_FILTADDR_FMEM_LO + (i*2));
		CSR_WRITE_4(sc, SIS_RXFILT_DATA, 0);
	}

        ETHER_FIRST_MULTI(step, ac, enm);
        while (enm != NULL) {
		h = sis_crc(sc, enm->enm_addrlo);
		index = h >> 3;
		bit = h & 0x1F;
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, NS_FILTADDR_FMEM_LO + index);
		if (bit > 0xF)
			bit -= 0x10;
		SIS_SETBIT(sc, SIS_RXFILT_DATA, (1 << bit));
		ETHER_NEXT_MULTI(step, enm);
	}

	CSR_WRITE_4(sc, SIS_RXFILT_CTL, filtsave);

	return;
}

void sis_setmulti_sis(sc)
d423 1
a423 1
		h = sis_crc(sc, enm->enm_addrlo);
a450 10

	/*
	 * If this is a NetSemi chip, make sure to clear
	 * PME mode.
	 */
	if (sc->sis_type == SIS_TYPE_83815) {
		CSR_WRITE_4(sc, NS_CLKRUN, NS_CLKRUN_PMESTS);
		CSR_WRITE_4(sc, NS_CLKRUN, 0);
	}

d465 1
a465 2
	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_SIS &&
	    PCI_VENDOR(pa->pa_id) != PCI_VENDOR_NS)
a472 2
	case PCI_PRODUCT_NS_DP83815:
		return(1);
d498 1
a498 1
	s = splnet();
d500 1
a500 14

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_SIS_900:
		sc->sis_type = SIS_TYPE_900;
		break;
	case PCI_PRODUCT_SIS_7016:
		sc->sis_type = SIS_TYPE_7016;
		break;
	case PCI_PRODUCT_NS_DP83815:
		sc->sis_type = SIS_TYPE_83815;
		break;
	default:
		break;
	}
d593 1
a593 16
	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_NS:
		/*
		 * Reading the MAC address out of the EEPROM on
		 * the NatSemi chip takes a bit more work than
		 * you'd expect. The address spans 4 16-bit words,
		 * with the first word containing only a single bit.
		 * You have to shift everything over one bit to
		 * get it aligned properly. Also, the bits are
		 * stored backwards (the LSB is really the MSB,
		 * and so on) so you have to reverse them in order
		 * to get the MAC address into the form we want.
		 * Why? Who the hell knows.
		 */
		{
			u_int16_t		tmp[4];
d595 1
a595 50
			sis_read_eeprom(sc, (caddr_t)&tmp, NS_EE_NODEADDR,4,0);

			/* Shift everything over one bit. */
			tmp[3] = tmp[3] >> 1;
			tmp[3] |= tmp[2] << 15;
			tmp[2] = tmp[2] >> 1;
			tmp[2] |= tmp[1] << 15;
			tmp[1] = tmp[1] >> 1;
			tmp[1] |= tmp[0] << 15;

			/* Now reverse all the bits. */
			tmp[3] = sis_reverse(tmp[3]);
			tmp[2] = sis_reverse(tmp[2]);
			tmp[1] = sis_reverse(tmp[1]);

			bcopy((char *)&tmp[1], sc->arpcom.ac_enaddr,
			    ETHER_ADDR_LEN);
		}
		break;
	case PCI_VENDOR_SIS:
	default:
#ifdef __i386__
		/*
		 * If this is a SiS 630E chipset with an embedded
		 * SiS 900 controller, we have to read the MAC address
		 * from the APC CMOS RAM. Our method for doing this
		 * is very ugly since we have to reach out and grab
		 * ahold of hardware for which we cannot properly
		 * allocate resources. This code is only compiled on
		 * the i386 architecture since the SiS 630E chipset
		 * is for x86 motherboards only. Note that there are
		 * a lot of magic numbers in this hack. These are
		 * taken from SiS's Linux driver. I'd like to replace
		 * them with proper symbolic definitions, but that
		 * requires some datasheets that I don't have access
		 * to at the moment.
		 */
		command = pci_conf_read(pc, pa->pa_tag,
		    PCI_CLASS_REG) & 0x000000ff;
		if (command == SIS_REV_630S ||
		    command == SIS_REV_630E ||
		    command == SIS_REV_630EA1)
		        sis_read_cmos(sc, pa, (caddr_t)&sc->arpcom.ac_enaddr,
			    0x9, 6);
		else
#endif
			sis_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
			    SIS_EE_NODEADDR, 3, 0);
		break;
	}
a596 2
	printf(" address %s\n", ether_sprintf(sc->arpcom.ac_enaddr));
        
d624 1
a624 2
	mii_attach(self, &sc->sc_mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY,
	    0);
d637 4
a907 1
	struct ifnet		*ifp;
d910 1
a910 3
	s = splnet();

	ifp = &sc->arpcom.ac_if;
d914 1
a914 10

	if (!sc->sis_link) {
		mii_pollstat(mii);
		if (mii->mii_media_status & IFM_ACTIVE &&
		    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE)
			sc->sis_link++;
			if (ifp->if_snd.ifq_head != NULL)
				sis_start(ifp);
	}
	timeout_add(&sc->sis_timeout, hz);
d950 1
a950 1
		if ((status & SIS_ISR_TX_DESC_OK) ||
a951 1
		    (status & SIS_ISR_TX_OK) ||
d955 1
a955 2
		if ((status & SIS_ISR_RX_DESC_OK) ||
		    (status & SIS_ISR_RX_OK))
a1039 1
	int			s;
a1042 3
	if (!sc->sis_link)
		return;

a1048 1
		s = splimp();
a1049 1
		splx(s);
a1053 1
			s = splimp();
a1054 1
			splx(s);
d1089 1
a1089 1
	s = splnet();
d1099 9
a1107 21
	if (sc->sis_type == SIS_TYPE_83815) {
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, NS_FILTADDR_PAR0);
		CSR_WRITE_4(sc, SIS_RXFILT_DATA,
		    ((u_int16_t *)sc->arpcom.ac_enaddr)[0]);
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, NS_FILTADDR_PAR1);
		CSR_WRITE_4(sc, SIS_RXFILT_DATA,
		    ((u_int16_t *)sc->arpcom.ac_enaddr)[1]);
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, NS_FILTADDR_PAR2);
		CSR_WRITE_4(sc, SIS_RXFILT_DATA,
		    ((u_int16_t *)sc->arpcom.ac_enaddr)[2]);
	} else {
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, SIS_FILTADDR_PAR0);
		CSR_WRITE_4(sc, SIS_RXFILT_DATA,
		    ((u_int16_t *)sc->arpcom.ac_enaddr)[0]);
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, SIS_FILTADDR_PAR1);
		CSR_WRITE_4(sc, SIS_RXFILT_DATA,
		    ((u_int16_t *)sc->arpcom.ac_enaddr)[1]);
		CSR_WRITE_4(sc, SIS_RXFILT_CTL, SIS_FILTADDR_PAR2);
		CSR_WRITE_4(sc, SIS_RXFILT_DATA,
		    ((u_int16_t *)sc->arpcom.ac_enaddr)[2]);
	}
a1122 11
	/*
	 * For the NatSemi chip, we have to explicitly enable the
	 * reception of ARP frames, as well as turn on the 'perfect
	 * match' filter where we store the station address, otherwise
	 * we won't receive unicasts meant for this host.
	 */
	if (sc->sis_type == SIS_TYPE_83815) {
		SIS_SETBIT(sc, SIS_RXFILT_CTL, NS_RXFILTCTL_ARP);
		SIS_SETBIT(sc, SIS_RXFILT_CTL, NS_RXFILTCTL_PERFECT);
	}

d1142 1
a1142 4
	if (sc->sis_type == SIS_TYPE_83815)
		sis_setmulti_ns(sc);
	else
		sis_setmulti_sis(sc);
a1156 1

d1158 1
a1158 15
	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_10_T)
		CSR_WRITE_4(sc, SIS_TX_CFG, SIS_TXCFG_10);
	else
		CSR_WRITE_4(sc, SIS_TX_CFG, SIS_TXCFG_100);

	/* Set full/half duplex mode. */
	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX) {
		SIS_SETBIT(sc, SIS_TX_CFG,
		    (SIS_TXCFG_IGN_HBEAT|SIS_TXCFG_IGN_CARR));
		SIS_SETBIT(sc, SIS_RX_CFG, SIS_RXCFG_RX_TXPKTS);
	} else {
		SIS_CLRBIT(sc, SIS_TX_CFG,
		    (SIS_TXCFG_IGN_HBEAT|SIS_TXCFG_IGN_CARR));
		SIS_CLRBIT(sc, SIS_RX_CFG, SIS_RXCFG_RX_TXPKTS);
	}
a1169 1
#ifdef notdef
a1170 16
#endif

	/*
	 * Page 75 of the DP83815 manual recommends the
	 * following register settings "for optimum
	 * performance." Note however that at least three
	 * of the registers are listed as "reserved" in
	 * the register map, so who knows what they do.
	 */
	if (sc->sis_type == SIS_TYPE_83815) {
		CSR_WRITE_4(sc, NS_PHY_PAGE, 0x0001);
		CSR_WRITE_4(sc, NS_PHY_CR, 0x189C);
		CSR_WRITE_4(sc, NS_PHY_TDATA, 0x0000);
		CSR_WRITE_4(sc, NS_PHY_DSPCFG, 0x5040);
		CSR_WRITE_4(sc, NS_PHY_SDCFG, 0x008C);
	}
d1177 1
a1177 2
	timeout_set(&sc->sis_timeout, sis_tick, sc);
	timeout_add(&sc->sis_timeout, hz);
a1188 1
	struct mii_data		*mii;
d1192 2
a1193 8
	mii = &sc->sc_mii;
	sc->sis_link = 0;
	if (mii->mii_instance) {
		struct mii_softc	*miisc;
		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
			mii_phy_reset(miisc);
	}
	mii_mediachg(mii);
d1229 1
a1229 1
	s = splnet();
d1269 1
a1269 4
			if (sc->sis_type == SIS_TYPE_83815)
				sis_setmulti_ns(sc);
			else
				sis_setmulti_sis(sc);
a1291 1
	int			s;
a1297 1
	s = splnet();
a1304 1
	splx(s);
d1321 1
a1321 1
	timeout_del(&sc->sis_timeout);
a1327 2

	sc->sis_link = 0;
@


1.2.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.2.2.2 2001/05/14 22:25:46 niklas Exp $ */
d604 1
d606 1
d831 1
a831 2
	IFQ_SET_MAXLEN(&ifp->if_snd, SIS_TX_LIST_CNT - 1);
	IFQ_SET_READY(&ifp->if_snd);
d980 1
d1026 1
d1033 3
a1035 2
		/* pass it on. */
		ether_input_mbuf(ifp, m);
d1135 1
a1135 1
			if (!IFQ_IS_EMPTY(&ifp->if_snd))
d1198 1
a1198 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd))
d1266 1
d1279 3
a1281 1
		IFQ_POLL(&ifp->if_snd, m_head);
d1286 3
a1292 3
		/* now we are committed to transmit the packet */
		IFQ_DEQUEUE(&ifp->if_snd, m_head);

a1301 2
	if (idx == sc->sis_cdata.sis_tx_prod)
		return;
d1607 1
a1607 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd))
@


1.2.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sis.c,v 1.2.2.3 2001/07/04 10:42:19 niklas Exp $ */
d92 2
a93 1
#include <vm/vm.h>		/* for vtophys */
a134 1
void sis_read_630ea1_enaddr    __P((struct sis_softc *, struct pci_attach_args *));
a340 21
void sis_read_630ea1_enaddr(sc, pa)
	struct sis_softc *sc;
	struct pci_attach_args *pa;
{
	u_int16_t *enaddr = (u_int16_t *) &sc->arpcom.ac_enaddr;

	SIS_SETBIT(sc, SIS_CSR, SIS_CSR_RELOAD);
	SIS_CLRBIT(sc, SIS_CSR, SIS_CSR_RELOAD);

	SIS_CLRBIT(sc, SIS_RXFILT_CTL, SIS_RXFILTCTL_ENABLE);

	CSR_WRITE_4(sc, SIS_RXFILT_CTL, SIS_FILTADDR_PAR0);
	enaddr[0] = CSR_READ_4(sc, SIS_RXFILT_DATA) & 0xffff;
	CSR_WRITE_4(sc, SIS_RXFILT_CTL, SIS_FILTADDR_PAR1);
	enaddr[1] = CSR_READ_4(sc, SIS_RXFILT_DATA) & 0xffff;
	CSR_WRITE_4(sc, SIS_RXFILT_CTL, SIS_FILTADDR_PAR2);
	enaddr[2] = CSR_READ_4(sc, SIS_RXFILT_DATA) & 0xffff;

	SIS_SETBIT(sc, SIS_RXFILT_CTL, SIS_RXFILTCTL_ENABLE);
}

d470 4
a473 4
	struct ifnet		*ifp;
	struct arpcom		*ac = &sc->arpcom;
	struct ether_multi	*enm;
	struct ether_multistep  step;
d500 2
a501 2
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
d584 1
a584 1
	return;
d717 2
a718 1
	if (pci_intr_map(pa, &ih)) {
d797 3
a799 2
		    command == SIS_REV_630E)
			sis_read_cmos(sc, pa, (caddr_t)&sc->arpcom.ac_enaddr,
a802 3
		if (command == SIS_REV_630EA1)
			sis_read_630ea1_enaddr(sc, pa);
		else
d809 1
a809 1

d979 2
a980 2
	struct mbuf		*m;
	struct ifnet		*ifp;
@


1.2.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d92 1
a92 1
#include <uvm/uvm_extern.h>		/* for vtophys */
@


1.2.2.6
log
@Merge in trunk
@
text
@a61 1
#include "vlan.h"
a854 4
#if NVLAN > 0
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
#endif

d889 1
a889 1
	int			i, nexti;
d895 11
a905 5
		nexti = (i == (SIS_TX_LIST_CNT - 1)) ? 0 : i+1;
		ld->sis_tx_list[i].sis_nextdesc =
		    &ld->sis_tx_list[nexti];
		ld->sis_tx_list[i].sis_next =
		    vtophys(&ld->sis_tx_list[nexti]);
d927 1
a927 1
	int			i, nexti;
d935 11
a945 5
		nexti = (i == (SIS_RX_LIST_CNT - 1)) ? 0 : i+1;
		ld->sis_rx_list[i].sis_nextdesc =
		    &ld->sis_rx_list[nexti];
		ld->sis_rx_list[i].sis_next =
		    vtophys(&ld->sis_rx_list[nexti]);
d1011 1
d1035 6
a1040 26
#ifndef __STRICT_ALIGNMENT
		/*
		 * On some architectures, we do not have alignment problems,
		 * so try to allocate a new buffer for the receive ring, and
		 * pass up the one where the packet is already, saving the
		 * expensive copy done in m_devget().
		 * If we are on an architecture with alignment problems, or
		 * if the allocation fails, then use m_devget and leave the
		 * existing buffer in the receive ring.
		 */
		if (sis_newbuf(sc, cur_rx, NULL) == 0) {
			m->m_pkthdr.rcvif = ifp;
			m->m_pkthdr.len = m->m_len = total_len;
		} else
#endif
		{
			struct mbuf *m0;
			m0 = m_devget(mtod(m, char *) - ETHER_ALIGN,
			    total_len + ETHER_ALIGN, 0, ifp, NULL);
			sis_newbuf(sc, cur_rx, m);
			if (m0 == NULL) {
				ifp->if_ierrors++;
				continue;
			}
			m_adj(m0, ETHER_ALIGN);
			m = m0;
d1042 2
d1192 4
a1195 3
		if (status &
		    (SIS_ISR_TX_DESC_OK | SIS_ISR_TX_ERR |
		     SIS_ISR_TX_OK | SIS_ISR_TX_IDLE))
d1198 2
a1199 3
		if (status &
		    (SIS_ISR_RX_DESC_OK | SIS_ISR_RX_OK |
		     SIS_ISR_RX_IDLE))
d1202 2
a1203 1
		if (status & (SIS_ISR_RX_ERR | SIS_ISR_RX_OFLOW))
d1205 1
a1205 3

		if (status & (SIS_ISR_RX_IDLE))
			SIS_SETBIT(sc, SIS_CSR, SIS_CSR_RX_ENABLE);
d1377 1
a1377 1
		splx(s);
a1434 3
	/* Accept Long Packets for VLAN support */
	SIS_SETBIT(sc, SIS_RX_CFG, SIS_RXCFG_RX_JABBER);

d1484 1
a1484 1
	splx(s);
d1603 1
a1603 1
	splx(s);
@


1.2.2.7
log
@Merge in -current from roughly a week ago
@
text
@d108 18
a125 18
int sis_probe(struct device *, void *, void *);
void sis_attach(struct device *, struct device *, void *);
int sis_intr(void *);
void sis_shutdown(void *);
int sis_newbuf(struct sis_softc *, struct sis_desc *,
				struct mbuf *);
int sis_encap(struct sis_softc *, struct mbuf *, u_int32_t *);
void sis_rxeof(struct sis_softc *);
void sis_rxeoc(struct sis_softc *);
void sis_txeof(struct sis_softc *);
void sis_tick(void *);
void sis_start(struct ifnet *);
int sis_ioctl(struct ifnet *, u_long, caddr_t);
void sis_init(void *);
void sis_stop(struct sis_softc *);
void sis_watchdog(struct ifnet *);
int sis_ifmedia_upd(struct ifnet *);
void sis_ifmedia_sts(struct ifnet *, struct ifmediareq *);
d127 5
a131 5
u_int16_t sis_reverse(u_int16_t);
void sis_delay(struct sis_softc *);
void sis_eeprom_idle(struct sis_softc *);
void sis_eeprom_putbyte(struct sis_softc *, int);
void sis_eeprom_getword(struct sis_softc *, int, u_int16_t *);
d133 1
a133 1
void sis_read_cmos(struct sis_softc *, struct pci_attach_args *, caddr_t, int, int);
d135 2
a136 2
void sis_read_630ea1_enaddr(struct sis_softc *, struct pci_attach_args *);
void sis_read_eeprom(struct sis_softc *, caddr_t, int, int, int);
d138 3
a140 3
int sis_miibus_readreg(struct device *, int, int);
void sis_miibus_writereg(struct device *, int, int, int);
void sis_miibus_statchg(struct device *);
d142 6
a147 6
void sis_setmulti_sis(struct sis_softc *);
void sis_setmulti_ns(struct sis_softc *);
u_int32_t sis_crc(struct sis_softc *, caddr_t);
void sis_reset(struct sis_softc *);
int sis_list_rx_init(struct sis_softc *);
int sis_list_tx_init(struct sis_softc *);
@


1.2.2.8
log
@Sync the SMP branch with 3.3
@
text
@d93 2
d135 1
a135 1
void sis_read_mac(struct sis_softc *, struct pci_attach_args *);
d227 1
a227 1
	 * Feed in each bit and strobe the clock.
d342 1
a342 1
void sis_read_mac(sc, pa)
d389 1
a389 2
	if (sc->sis_type == SIS_TYPE_900 &&
	    sc->sis_rev < SIS_REV_635 && phy != 0)
a608 6
const struct pci_matchid sis_devices[] = {
	{ PCI_VENDOR_SIS, PCI_PRODUCT_SIS_900 },
	{ PCI_VENDOR_SIS, PCI_PRODUCT_SIS_7016 },
	{ PCI_VENDOR_NS, PCI_PRODUCT_NS_DP83815 },
};

d618 15
a632 2
	return (pci_matchbyid((struct pci_attach_args *)aux, sis_devices,
	    sizeof(sis_devices)/sizeof(sis_devices[0])));
d643 1
a643 1
	int			i, s;
a754 2
	sc->sis_rev = PCI_REVISION(pa->pa_class);

d815 4
a818 3
		if (sc->sis_rev == SIS_REV_630S ||
		    sc->sis_rev == SIS_REV_630E ||
		    sc->sis_rev == SIS_REV_630EA1)
d823 2
a824 3
		if (sc->sis_rev == SIS_REV_635 ||
		    sc->sis_rev == SIS_REV_630ET) 	
			sis_read_mac(sc, pa);
d833 6
a838 1
	sc->sc_dmat = pa->pa_dmat;
d840 1
a840 24
	if (bus_dmamem_alloc(sc->sc_dmat, sizeof(struct sis_list_data),
	    PAGE_SIZE, 0, sc->sc_listseg, 1, &sc->sc_listnseg,
	    BUS_DMA_NOWAIT) != 0) {
		printf(": can't alloc list mem\n");
		return;
	}
	if (bus_dmamem_map(sc->sc_dmat, sc->sc_listseg, sc->sc_listnseg,
	    sizeof(struct sis_list_data), &sc->sc_listkva,
	    BUS_DMA_NOWAIT) != 0) {
		printf(": can't map list mem\n");
		return;
	}
	if (bus_dmamap_create(sc->sc_dmat, sizeof(struct sis_list_data), 1,
	    sizeof(struct sis_list_data), 0, BUS_DMA_NOWAIT,
	    &sc->sc_listmap) != 0) {
		printf(": can't alloc list map\n");
		return;
	}
	if (bus_dmamap_load(sc->sc_dmat, sc->sc_listmap, sc->sc_listkva,
	    sizeof(struct sis_list_data), NULL, BUS_DMA_NOWAIT) != 0) {
		printf(": can't load list map\n");
		return;
	}
	sc->sis_ldata = (struct sis_list_data *)sc->sc_listkva;
a842 27
	for (i = 0; i < SIS_RX_LIST_CNT; i++) {
		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES, 0,
		    BUS_DMA_NOWAIT, &sc->sis_ldata->sis_rx_list[i].map) != 0) {
			printf(": can't create rx map\n");
			return;
		}
	}
	if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES, 0,
	    BUS_DMA_NOWAIT, &sc->sc_rx_sparemap) != 0) {
		printf(": can't create rx spare map\n");
		return;
	}

	for (i = 0; i < SIS_TX_LIST_CNT; i++) {
		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    SIS_TX_LIST_CNT - 3, MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &sc->sis_ldata->sis_tx_list[i].map) != 0) {
			printf(": can't create tx map\n");
			return;
		}
	}
	if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, SIS_TX_LIST_CNT - 3,
	    MCLBYTES, 0, BUS_DMA_NOWAIT, &sc->sc_tx_sparemap) != 0) {
		printf(": can't create tx spare map\n");
		return;
	}

d894 1
a894 2
	int			i;
	bus_addr_t		next;
d900 5
a904 13
		next = sc->sc_listmap->dm_segs[0].ds_addr;
		if (i == (SIS_TX_LIST_CNT - 1)) {
			ld->sis_tx_list[i].sis_nextdesc =
			    &ld->sis_tx_list[0];
			next +=
			    offsetof(struct sis_list_data, sis_tx_list[0]);
		} else {
			ld->sis_tx_list[i].sis_nextdesc =
			    &ld->sis_tx_list[i+1];
			next +=
			    offsetof(struct sis_list_data, sis_tx_list[i+1]);
		}
		ld->sis_tx_list[i].sis_next = next;
d926 1
a926 2
	int			i;
	bus_addr_t		next;
d934 5
a938 11
		next = sc->sc_listmap->dm_segs[0].ds_addr;
		if (i == (SIS_RX_LIST_CNT - 1)) {
			ld->sis_rx_list[i].sis_nextdesc = &ld->sis_rx_list[0];
			next +=
			    offsetof(struct sis_list_data, sis_rx_list[0]);
		} else {
			ld->sis_rx_list[i].sis_nextdesc = &ld->sis_rx_list[i+1];
			next +=
			    offsetof(struct sis_list_data, sis_rx_list[i+1]);
		}
		ld->sis_rx_list[i].sis_next = next;
a954 1
	bus_dmamap_t		map;
a977 13
	if (bus_dmamap_load(sc->sc_dmat, sc->sc_rx_sparemap,
	    mtod(m_new, caddr_t), MCLBYTES, NULL, BUS_DMA_NOWAIT) != 0) {
		printf("%s: rx load failed\n", sc->sc_dev.dv_xname);
		m_freem(m_new);
		return (ENOBUFS);
	}
	map = c->map;
	c->map = sc->sc_rx_sparemap;
	sc->sc_rx_sparemap = map;

	bus_dmamap_sync(sc->sc_dmat, c->map, 0, c->map->dm_mapsize,
	    BUS_DMASYNC_PREREAD);

d981 1
a981 1
	c->sis_ptr = c->map->dm_segs[0].ds_addr + sizeof(u_int64_t);
a983 4
	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    ((caddr_t)c - sc->sc_listkva), sizeof(struct sis_desc),
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

a1005 5
		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
		    ((caddr_t)cur_rx - sc->sc_listkva),
		    sizeof(struct sis_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

a1011 1

a1026 2
		bus_dmamap_sync(sc->sc_dmat, cur_rx->map, 0,
		    cur_rx->map->dm_mapsize, BUS_DMASYNC_POSTREAD);
a1103 5
		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
		    ((caddr_t)cur_tx - sc->sc_listkva),
		    sizeof(struct sis_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

a1124 7
		if (cur_tx->map->dm_nsegs != 0) {
			bus_dmamap_t map = cur_tx->map;

			bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, map);
		}
d1243 2
a1244 7
	int			frag, cur, i;
	bus_dmamap_t		map;

	map = sc->sc_tx_sparemap;
	if (bus_dmamap_load_mbuf(sc->sc_dmat, map,
	    m_head, BUS_DMA_NOWAIT) != 0)
		return (ENOBUFS);
d1251 1
d1254 14
a1267 10
	for (i = 0; i < map->dm_nsegs; i++) {
		if ((SIS_TX_LIST_CNT - (sc->sis_cdata.sis_tx_cnt + i)) < 2)
			return(ENOBUFS);
		f = &sc->sis_ldata->sis_tx_list[frag];
		f->sis_ctl = SIS_CMDSTS_MORE | map->dm_segs[i].ds_len;
		f->sis_ptr = map->dm_segs[i].ds_addr;
		if (i != 0)
			f->sis_ctl |= SIS_CMDSTS_OWN;
		cur = frag;
		SIS_INC(frag, SIS_TX_LIST_CNT);
d1270 2
a1271 2
	bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
d1276 1
a1276 1
	sc->sis_cdata.sis_tx_cnt += i;
a1278 5
	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    offsetof(struct sis_list_data, sis_tx_list[0]),
	    sizeof(struct sis_desc) * SIS_TX_LIST_CNT,  
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

a1349 1
	int                     tmp;
d1438 4
a1441 4
	CSR_WRITE_4(sc, SIS_RX_LISTPTR, sc->sc_listmap->dm_segs[0].ds_addr +
	    offsetof(struct sis_list_data, sis_rx_list[0]));
	CSR_WRITE_4(sc, SIS_TX_LISTPTR, sc->sc_listmap->dm_segs[0].ds_addr +
	    offsetof(struct sis_list_data, sis_tx_list[0]));
a1492 24
		
		/* 
		 * A small number of DP83815's will have excessive receive
		 * errors when using short cables (<30m/100feet) in 100Base-TX
		 * mode. This patch was taken from the National Semiconductor
		 * linux driver and (supposedly - no mention of this in any NS
		 * docs) modifies the dsp's signal attenuation.
		 */
		if (IFM_SUBTYPE(mii->mii_media_active) != IFM_10_T) {
			CSR_WRITE_4(sc, NS_PHY_PAGE, 0x0001);
			tmp = CSR_READ_4(sc, NS_PHY_DSPCFG);
			tmp &= 0xFFF;
			CSR_WRITE_4(sc, NS_PHY_DSPCFG, (tmp | 0x1000));
			DELAY(100);
			tmp = CSR_READ_4(sc, NS_PHY_TDATA);
			tmp &= 0xFF;
			if (!(tmp & 0x80) || (tmp >= 0xD8)) {
				CSR_WRITE_4(sc, NS_PHY_TDATA, 0xE8);
				tmp = CSR_READ_4(sc, NS_PHY_DSPCFG);
				CSR_WRITE_4(sc, NS_PHY_DSPCFG, (tmp | 0x20));
			} else {
				CSR_WRITE_4(sc, NS_PHY_PAGE, 0);
			}
		}
a1671 7
		if (sc->sis_ldata->sis_rx_list[i].map->dm_nsegs != 0) {
			bus_dmamap_t map = sc->sis_ldata->sis_rx_list[i].map;

			bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
			    BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->sc_dmat, map);
		}
a1675 2
		bzero((char *)&sc->sis_ldata->sis_rx_list[i],
		    sizeof(struct sis_desc) - sizeof(bus_dmamap_t));
d1677 2
a1683 7
		if (sc->sis_ldata->sis_tx_list[i].map->dm_nsegs != 0) {
			bus_dmamap_t map = sc->sis_ldata->sis_tx_list[i].map;

			bus_dmamap_sync(sc->sc_dmat, map, 0, map->dm_mapsize,
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, map);
		}
a1687 2
		bzero((char *)&sc->sis_ldata->sis_tx_list[i],
		    sizeof(struct sis_desc) - sizeof(bus_dmamap_t));
d1689 3
@


1.2.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a135 4
void sis_mii_sync(struct sis_softc *);
void sis_mii_send(struct sis_softc *, u_int32_t, int);
int sis_mii_readreg(struct sis_softc *, struct sis_mii_frame *);
int sis_mii_writereg(struct sis_softc *, struct sis_mii_frame *);
a360 185
/*
 * Sync the PHYs by setting data bit and strobing the clock 32 times.
 */
void sis_mii_sync(sc)
	struct sis_softc	*sc;
{
	register int		i;
 
 	SIO_SET(SIS_MII_DIR|SIS_MII_DATA);
 
 	for (i = 0; i < 32; i++) {
 		SIO_SET(SIS_MII_CLK);
 		DELAY(1);
 		SIO_CLR(SIS_MII_CLK);
 		DELAY(1);
 	}
 
 	return;
}
 
/*
 * Clock a series of bits through the MII.
 */
void sis_mii_send(sc, bits, cnt)
	struct sis_softc	*sc;
	u_int32_t		bits;
	int			cnt;
{
	int			i;
 
	SIO_CLR(SIS_MII_CLK);
 
	for (i = (0x1 << (cnt - 1)); i; i >>= 1) {
		if (bits & i) {
			SIO_SET(SIS_MII_DATA);
		} else {
			SIO_CLR(SIS_MII_DATA);
		}
		DELAY(1);
		SIO_CLR(SIS_MII_CLK);
		DELAY(1);
		SIO_SET(SIS_MII_CLK);
	}
}
 
/*
 * Read an PHY register through the MII.
 */
int sis_mii_readreg(sc, frame)
	struct sis_softc	*sc;
	struct sis_mii_frame	*frame;
 	
{
	int			i, ack, s;
 
	s = splimp();
 
	/*
	 * Set up frame for RX.
	 */
	frame->mii_stdelim = SIS_MII_STARTDELIM;
	frame->mii_opcode = SIS_MII_READOP;
	frame->mii_turnaround = 0;
	frame->mii_data = 0;
 	
	/*
 	 * Turn on data xmit.
	 */
	SIO_SET(SIS_MII_DIR);

	sis_mii_sync(sc);
 
	/*
	 * Send command/address info.
	 */
	sis_mii_send(sc, frame->mii_stdelim, 2);
	sis_mii_send(sc, frame->mii_opcode, 2);
	sis_mii_send(sc, frame->mii_phyaddr, 5);
	sis_mii_send(sc, frame->mii_regaddr, 5);
 
	/* Idle bit */
	SIO_CLR((SIS_MII_CLK|SIS_MII_DATA));
	DELAY(1);
	SIO_SET(SIS_MII_CLK);
	DELAY(1);
 
	/* Turn off xmit. */
	SIO_CLR(SIS_MII_DIR);
 
	/* Check for ack */
	SIO_CLR(SIS_MII_CLK);
	DELAY(1);
	ack = CSR_READ_4(sc, SIS_EECTL) & SIS_MII_DATA;
	SIO_SET(SIS_MII_CLK);
	DELAY(1);
 
	/*
	 * Now try reading data bits. If the ack failed, we still
	 * need to clock through 16 cycles to keep the PHY(s) in sync.
	 */
	if (ack) {
		for(i = 0; i < 16; i++) {
			SIO_CLR(SIS_MII_CLK);
			DELAY(1);
			SIO_SET(SIS_MII_CLK);
			DELAY(1);
		}
		goto fail;
	}
 
	for (i = 0x8000; i; i >>= 1) {
		SIO_CLR(SIS_MII_CLK);
		DELAY(1);
		if (!ack) {
			if (CSR_READ_4(sc, SIS_EECTL) & SIS_MII_DATA)
				frame->mii_data |= i;
			DELAY(1);
		}
		SIO_SET(SIS_MII_CLK);
		DELAY(1);
	}

fail:

	SIO_CLR(SIS_MII_CLK);
	DELAY(1);
	SIO_SET(SIS_MII_CLK);
	DELAY(1);

	splx(s);

	if (ack)
		return(1);
	return(0);
}
 
/*
 * Write to a PHY register through the MII.
 */
int sis_mii_writereg(sc, frame)
	struct sis_softc	*sc;
	struct sis_mii_frame	*frame;
	
{
	int			s;
 
	 s = splimp();
 	/*
 	 * Set up frame for TX.
 	 */
 
 	frame->mii_stdelim = SIS_MII_STARTDELIM;
 	frame->mii_opcode = SIS_MII_WRITEOP;
 	frame->mii_turnaround = SIS_MII_TURNAROUND;
 	
 	/*
  	 * Turn on data output.
 	 */
 	SIO_SET(SIS_MII_DIR);
 
 	sis_mii_sync(sc);
 
 	sis_mii_send(sc, frame->mii_stdelim, 2);
 	sis_mii_send(sc, frame->mii_opcode, 2);
 	sis_mii_send(sc, frame->mii_phyaddr, 5);
 	sis_mii_send(sc, frame->mii_regaddr, 5);
 	sis_mii_send(sc, frame->mii_turnaround, 2);
 	sis_mii_send(sc, frame->mii_data, 16);
 
 	/* Idle bit. */
 	SIO_SET(SIS_MII_CLK);
 	DELAY(1);
 	SIO_CLR(SIS_MII_CLK);
 	DELAY(1);
 
 	/*
 	 * Turn off xmit.
 	 */
 	SIO_CLR(SIS_MII_DIR);
 
 	splx(s);
 
 	return(0);
}

d366 1
a366 1
	struct sis_mii_frame    frame;
d383 2
a384 1
		return CSR_READ_4(sc, NS_BMCR + (reg * 4));
a386 5
	/*
	 * Chipsets < SIS_635 seem not to be able to read/write
	 * through mdio. Use the enhanced PHY access register
	 * again for them.
	 */
d388 2
a389 2
	    sc->sis_rev < SIS_REV_635) {
		int i, val = 0;
d391 2
a392 2
		if (phy != 0)
			return(0);
d394 4
a397 8
		CSR_WRITE_4(sc, SIS_PHYCTL,
		    (phy << 11) | (reg << 6) | SIS_PHYOP_READ);
		SIS_SETBIT(sc, SIS_PHYCTL, SIS_PHYCTL_ACCESS);

		for (i = 0; i < SIS_TIMEOUT; i++) {
			if (!(CSR_READ_4(sc, SIS_PHYCTL) & SIS_PHYCTL_ACCESS))
				break;
		}
d399 4
a402 5
		if (i == SIS_TIMEOUT) {
			printf("%s: PHY failed to come ready\n",
			    sc->sc_dev.dv_xname);
			return(0);
		}
d404 1
a404 1
		val = (CSR_READ_4(sc, SIS_PHYCTL) >> 16) & 0xFFFF;
d406 2
a407 2
		if (val == 0xFFFF)
			return(0);
d409 1
a409 10
		return(val);
	} else {
		bzero((char *)&frame, sizeof(frame));

		frame.mii_phyaddr = phy;
		frame.mii_regaddr = reg;
		sis_mii_readreg(sc, &frame);

		return(frame.mii_data);
	}
a411 1

d417 1
a417 1
	struct sis_mii_frame	frame;
d426 2
a427 8
	/*
	 * Chipsets < SIS_635 seem not to be able to read/write
	 * through mdio. Use the enhanced PHY access register
	 * again for them.
	 */
	if (sc->sis_type == SIS_TYPE_900 &&
	    sc->sis_rev < SIS_REV_635) {
		int i;
d429 3
a431 2
		if (phy != 0)
			return;
d433 4
a436 8
		CSR_WRITE_4(sc, SIS_PHYCTL, (data << 16) | (phy << 11) |
		    (reg << 6) | SIS_PHYOP_WRITE);
		SIS_SETBIT(sc, SIS_PHYCTL, SIS_PHYCTL_ACCESS);

		for (i = 0; i < SIS_TIMEOUT; i++) {
			if (!(CSR_READ_4(sc, SIS_PHYCTL) & SIS_PHYCTL_ACCESS))
				break;
		}
d438 2
a439 5
		if (i == SIS_TIMEOUT)
			printf("%s: PHY failed to come ready\n",
			    sc->sc_dev.dv_xname);
	} else {
		bzero((char *)&frame, sizeof(frame));
a440 5
		frame.mii_phyaddr = phy;
		frame.mii_regaddr = reg;
		frame.mii_data = data;
		sis_mii_writereg(sc, &frame);
	}
d444 1
a444 2
void
sis_miibus_statchg(self)
d591 1
a591 1
		printf("%s: reset never completed\n", sc->sc_dev.dv_xname);
d647 1
d679 2
a680 2
			printf("%s: chip is in D%d power mode -- setting to D0\n",
			    sc->sc_dev.dv_xname, command & SIS_PSTATE_MASK);
d745 1
a751 2
	printf(": ");

a756 11
		sc->sis_srr = CSR_READ_4(sc, NS_SRR);

		if (sc->sis_srr == NS_SRR_15C)
			printf("DP83815C,");
		else if (sc->sis_srr == NS_SRR_15D)
			printf("DP83815D,");
		else if (sc->sis_srr == NS_SRR_16A)
			printf("DP83816A,");
		else
			printf("srr %x,", sc->sis_srr);

d810 2
a811 1
		    sc->sis_rev == SIS_REV_630E)
d817 1
a817 2
		    sc->sis_rev == SIS_REV_630ET ||
		    sc->sis_rev == SIS_REV_630EA1)
d825 1
a825 2
	printf(" %s, address %s\n", intrstr,
	    ether_sprintf(sc->arpcom.ac_enaddr));
d1015 2
a1016 2
			printf("%s: no memory for rx list -- packet dropped!\n",
			    sc->sc_dev.dv_xname);
d1022 2
a1023 2
			printf("%s: no memory for rx list -- packet dropped!\n",
			    sc->sc_dev.dv_xname);
d1448 1
a1455 1
	sc->sis_stopped = 0;
d1484 2
a1485 2
		printf("%s: initialization failed: no memory for rx buffers\n",
		    sc->sc_dev.dv_xname);
a1495 21
        /*
	 * Page 78 of the DP83815 data sheet (september 2002 version)
	 * recommends the following register settings "for optimum
	 * performance." for rev 15C.  The driver from NS also sets  
	 * the PHY_CR register for later versions.
	 */
	 if (sc->sis_type == SIS_TYPE_83815) {
		CSR_WRITE_4(sc, NS_PHY_PAGE, 0x0001);
		/* DC speed = 01 */
		CSR_WRITE_4(sc, NS_PHY_CR, 0x189C);
		if (sc->sis_srr == NS_SRR_15C) {  
			/* set val for c2 */
			CSR_WRITE_4(sc, NS_PHY_TDATA, 0x0000);
			/* load/kill c2 */ 
			CSR_WRITE_4(sc, NS_PHY_DSPCFG, 0x5040);
			/* rais SD off, from 4 to c */
			CSR_WRITE_4(sc, NS_PHY_SDCFG, 0x008C);
		}
		CSR_WRITE_4(sc, NS_PHY_PAGE, 0);
	}

a1564 30
	if (sc->sis_type == SIS_TYPE_83815 && sc->sis_srr < NS_SRR_16A &&
	     IFM_SUBTYPE(mii->mii_media_active) == IFM_100_TX) {
		uint32_t reg;

		/*
		 * Some DP83815s experience problems when used with short
		 * (< 30m/100ft) Ethernet cables in 100BaseTX mode.  This
		 * sequence adjusts the DSP's signal attenuation to fix the
		 * problem.
		 */
		CSR_WRITE_4(sc, NS_PHY_PAGE, 0x0001);

		reg = CSR_READ_4(sc, NS_PHY_DSPCFG);
		/* Allow coefficient to be read */
		CSR_WRITE_4(sc, NS_PHY_DSPCFG, (reg & 0xfff) | 0x1000);
		DELAY(100);
		reg = CSR_READ_4(sc, NS_PHY_TDATA);
		if ((reg & 0x0080) == 0 ||
		    (reg > 0xd8 && reg <= 0xff)) {
#ifdef DEBUG
			printf("%s: Applying short cable fix (reg=%x)\n",
			    sc->sc_dev.dv_xname, reg);
#endif
			CSR_WRITE_4(sc, NS_PHY_TDATA, 0x00e8);
			/* Adjust coefficient and prevent change */
			SIS_SETBIT(sc, NS_PHY_DSPCFG, 0x20);
		}
		CSR_WRITE_4(sc, NS_PHY_PAGE, 0);
	}

d1579 39
d1754 1
a1754 1
	printf("%s: watchdog timeout\n", sc->sc_dev.dv_xname);
a1777 3
	if (sc->sis_stopped)
		return;

a1829 1
	sc->sis_stopped = 1;
@


1.2.2.10
log
@Merge with the trunk
@
text
@d1093 1
a1093 1
	for (i = 0; i < SIS_RX_LIST_CNT_MAX; i++) {
d1212 1
a1213 1
	int			i;
d1218 1
a1218 6
	if (sc->arpcom.ac_if.if_flags & IFF_UP)
		sc->sc_rxbufs = SIS_RX_LIST_CNT_MAX;
	else
		sc->sc_rxbufs = SIS_RX_LIST_CNT_MIN;

	for (i = 0; i < sc->sc_rxbufs; i++) {
d1222 1
a1222 1
		if (i == (sc->sc_rxbufs - 1)) {
d1252 3
a1254 1
		if (m_new == NULL)
d1256 1
d1260 2
d1326 1
a1326 1
		SIS_INC(i, sc->sc_rxbufs);
d2047 1
a2047 1
	for (i = 0; i < SIS_RX_LIST_CNT_MAX; i++) {
@


1.2.2.11
log
@sync to head
@
text
@d146 1
d680 34
a725 1
allmulti:
d749 1
a749 6
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}

		h = ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 23;
a774 1
allmulti:
d793 1
a793 7
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}

		h = (ether_crc32_be(enm->enm_addrlo,
		    ETHER_ADDR_LEN) >> 25) & 0x0000007F;
@


1.1
log
@Driver for SiS 900/7016 Ethernet; from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a137 8

#ifdef SIS_USEIOSPACE
#define SIS_RES			SYS_RES_IOPORT
#define SIS_RID			SIS_PCI_LOIO
#else
#define SIS_RES			SYS_RES_MEMORY
#define SIS_RID			SIS_PCI_LOMEM
#endif
@

