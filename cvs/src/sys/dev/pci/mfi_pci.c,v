head	1.29;
access;
symbols
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.10
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.4
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.28.0.10
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.8
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.4
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.2
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.26.0.4
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.2
	OPENBSD_5_0:1.25.0.2
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.21.0.4
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.6
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.16.0.4
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11;
locks; strict;
comment	@ * @;


1.29
date	2014.09.09.03.08.30;	author dlg;	state Exp;
branches;
next	1.28;
commitid	7vQxRhkWrnBVVNjO;

1.28
date	2012.08.14.04.10.14;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2012.08.14.03.46.46;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2012.01.12.06.12.30;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.20.20.15.23;	author marco;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.01.21.51.12;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2010.04.01.23.19.39;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2010.04.01.19.02.25;	author marco;	state Exp;
branches;
next	1.21;

1.21
date	2009.02.23.15.21.34;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2009.02.10.23.21.44;	author marco;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.28.23.45.13;	author marco;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.23.12.50.23;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2008.10.27.03.11.58;	author marco;	state Exp;
branches;
next	1.16;

1.16
date	2008.02.11.03.52.50;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2008.02.11.01.07.02;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.26.05.43.03;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.26.23.02.43;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.26.21.20.55;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2006.08.06.04.40.08;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.06.03.58.36;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.21.20.20.17;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.17.19.51.51;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.16.21.56.21;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.26.01.18.20;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.26.00.57.58;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.26.00.55.40;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.26.00.51.40;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.07.17.00.42;	author marco;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.06.20.22.53;	author marco;	state Exp;
branches;
next	;


desc
@@


1.29
log
@mark the interrupt handler mpsafe, and give up biglock in the scsi cmd
submission paths. take biglock again when calling back into the scsi
stack.

tested on a variety of cards here, including the skinny mfis on the
firewall next to mpsafe myx.
@
text
@/* $OpenBSD: mfi_pci.c,v 1.28 2012/08/14 04:10:14 dlg Exp $ */
/*
 * Copyright (c) 2006 Marco Peereboom <marco@@peereboom.us>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bio.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/rwlock.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>

#include <machine/bus.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>

#include <dev/ic/mfireg.h>
#include <dev/ic/mfivar.h>

#define	MFI_BAR		0x10
#define	MFI_BAR_GEN2	0x14
#define	MFI_PCI_MEMSIZE	0x2000 /* 8k */

int	mfi_pci_match(struct device *, void *, void *);
void	mfi_pci_attach(struct device *, struct device *, void *);

struct cfattach mfi_pci_ca = {
	sizeof(struct mfi_softc), mfi_pci_match, mfi_pci_attach
};

static const
struct	mfi_pci_device {
	pcireg_t		mpd_vendor;
	pcireg_t		mpd_product;
	enum mfi_iop		mpd_iop;
} mfi_pci_devices[] = {
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_MEGARAID_SAS,
	  MFI_IOP_XSCALE },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_MEGARAID_VERDE_ZCR,
	  MFI_IOP_XSCALE },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1078,
	  MFI_IOP_PPC },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1078DE,
	  MFI_IOP_PPC },
	{ PCI_VENDOR_DELL,	PCI_PRODUCT_DELL_PERC5,
	  MFI_IOP_XSCALE },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2108_1,
	  MFI_IOP_GEN2 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2108_2,
	  MFI_IOP_GEN2 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS2008_1,
	  MFI_IOP_SKINNY }
};

const struct mfi_pci_device *mfi_pci_find_device(struct pci_attach_args *);

const struct mfi_pci_device *
mfi_pci_find_device(struct pci_attach_args *pa)
{
	const struct mfi_pci_device *mpd;
	int i;

	for (i = 0; i < nitems(mfi_pci_devices); i++) {
		mpd = &mfi_pci_devices[i];

		if (mpd->mpd_vendor == PCI_VENDOR(pa->pa_id) &&
		    mpd->mpd_product == PCI_PRODUCT(pa->pa_id))
			return (mpd);
	}

	return (NULL);
}

int
mfi_pci_match(struct device *parent, void *match, void *aux)
{
	return ((mfi_pci_find_device(aux) != NULL) ? 1 : 0);
}

void
mfi_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct mfi_softc	*sc = (struct mfi_softc *)self;
	struct pci_attach_args	*pa = aux;
	const struct mfi_pci_device *mpd;
	pci_intr_handle_t	ih;
	bus_size_t		size;
	pcireg_t		reg;
	int			regbar;

	mpd = mfi_pci_find_device(pa);
	if (mpd == NULL) {
		printf(": can't find matching pci device\n");
		return;
	}

	if (mpd->mpd_iop == MFI_IOP_GEN2 || mpd->mpd_iop == MFI_IOP_SKINNY)
		regbar = MFI_BAR_GEN2;
	else
		regbar = MFI_BAR;

	reg = pci_mapreg_type(pa->pa_pc, pa->pa_tag, regbar);
	if (pci_mapreg_map(pa, regbar, reg, 0,
	    &sc->sc_iot, &sc->sc_ioh, NULL, &size, MFI_PCI_MEMSIZE)) {
		printf(": can't map controller pci space\n");
		return;
	}

	sc->sc_dmat = pa->pa_dmat;

	if (pci_intr_map(pa, &ih) != 0) {
		printf(": can't map interrupt\n");
		goto unmap;
	}
	printf(": %s\n", pci_intr_string(pa->pa_pc, ih));

	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO | IPL_MPSAFE,
	    mfi_intr, sc, sc->sc_dev.dv_xname);
	if (!sc->sc_ih) {
		printf("%s: can't establish interrupt\n", DEVNAME(sc));
		goto unmap;
	}

	if (mfi_attach(sc, mpd->mpd_iop)) {
		printf("%s: can't attach\n", DEVNAME(sc));
		goto unintr;
	}

	return;
unintr:
	pci_intr_disestablish(pa->pa_pc, sc->sc_ih);
	sc->sc_ih = NULL;
unmap:
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, size);
}
@


1.28
log
@dont maintain tables of all the pci subtypes just so we can print things
like "Dell PERC 5/i" in dmesg. the firmware on the board knows its own name
so we can use that instead. saves some bytes in the kernel.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.26 2012/01/12 06:12:30 dlg Exp $ */
d136 2
a137 2
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, mfi_intr, sc,
	    sc->sc_dev.dv_xname);
@


1.27
log
@gc sc_flags now that the iop struct can tell us where the different IDBs
are.

noted by haesbaert@@
@
text
@a49 37
struct mfi_pci_subtype {
	pcireg_t			st_id;
	const char			*st_string;
};

static const struct mfi_pci_subtype mfi_1078_subtypes[] = {
	{ 0x10061000,	"SAS 8888ELP" },
	{ 0x100a1000,	"SAS 8708ELP" },
	{ 0x100f1000,	"SAS 8708E" },
	{ 0x10121000,	"SAS 8704ELP" },
	{ 0x10131000,	"SAS 8708EM2" },
	{ 0x10161000,	"SAS 8880EM2" },
	{ 0x1f0a1028,	"Dell PERC 6/e" },
	{ 0x1f0b1028,	"Dell PERC 6/i" },
	{ 0x1f0d1028,	"Dell CERC 6/i" },
	{ 0x1f0c1028,	"Dell PERC 6/i integrated" },
	{ 0x1f111028,	"Dell CERC 6/i integrated" },
	{ 0x0,		"" }
};

static const struct mfi_pci_subtype mfi_perc5_subtypes[] = {
	{ 0x1f011028,	"Dell PERC 5/e" },
	{ 0x1f021028,	"Dell PERC 5/i" },
	{ 0x0,		"" }
};

static const struct mfi_pci_subtype mfi_gen2_subtypes[] = {
	{ 0x1f151028,	"Dell PERC H800 Adapter" },
	{ 0x1f161028,	"Dell PERC H700 Adapter" },
	{ 0x1f171028,	"Dell PERC H700 Integrated" },
	{ 0x1f181028,	"Dell PERC H700 Modular" },
	{ 0x1f191028,	"Dell PERC H700" },
	{ 0x1f1a1028,	"Dell PERC H800 Proto Adapter" },
	{ 0x1f1b1028,	"Dell PERC H800" },
	{ 0x0,		"" }
};

d52 3
a54 4
	pcireg_t			mpd_vendor;
	pcireg_t			mpd_product;
	enum mfi_iop			mpd_iop;
	const struct mfi_pci_subtype	*mpd_subtype;
d57 1
a57 1
	  MFI_IOP_XSCALE,	NULL },
d59 1
a59 1
	  MFI_IOP_XSCALE,	NULL },
d61 1
a61 1
	  MFI_IOP_PPC,		mfi_1078_subtypes },
d63 1
a63 1
	  MFI_IOP_PPC,		mfi_1078_subtypes },
d65 1
a65 1
	  MFI_IOP_XSCALE,	mfi_perc5_subtypes },
d67 1
a67 1
	  MFI_IOP_GEN2,		mfi_gen2_subtypes },
d69 1
a69 1
	  MFI_IOP_GEN2,		mfi_gen2_subtypes },
d71 1
a71 1
	  MFI_IOP_SKINNY,	NULL },
a104 2
	const struct mfi_pci_subtype *st;
	const char		*intrstr;
a108 2
	const char		*subtype = NULL;
	char			subid[32];
d132 1
a132 2
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, size);
		return;
d134 2
a135 1
	intrstr = pci_intr_string(pa->pa_pc, ih);
d139 2
a140 23
		printf(": can't establish interrupt");
		if (intrstr)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, size);
		return;
	}

	reg = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);

	if (mpd->mpd_subtype != NULL) {
		st = mpd->mpd_subtype;
		while (st->st_id != 0x0) {
			if (st->st_id == reg) {
				subtype = st->st_string;
				break;
			}
			st++;
		}
	}
	if (subtype == NULL) {
		snprintf(subid, sizeof(subid), "0x%08x", reg);
		subtype = subid;
a142 2
	printf(": %s, %s\n", intrstr, subtype);

d145 1
a145 3
		pci_intr_disestablish(pa->pa_pc, sc->sc_ih);
		sc->sc_ih = NULL;
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, size);
d147 7
@


1.26
log
@add support for skinny variants.

from Alexey Suslikov
reviewed by marco
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.25 2011/07/20 20:15:23 marco Exp $ */
a156 2

	sc->sc_flags = mpd->mpd_iop;
@


1.25
log
@For now, disable msi interrupts.  Reading through the linux driver one
gets the impression that there are all kinds of preconditions and a
whitelist as well.  I will be working on this whitelist but for now
disable it because it is hanging at boot for several people.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.24 2011/07/01 21:51:12 deraadt Exp $ */
d108 2
d158 3
a160 1
	if (mpd->mpd_iop == MFI_IOP_GEN2)
@


1.24
log
@msi interrupts working on mfi(4)
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.23 2010/04/01 23:19:39 jsg Exp $ */
d170 1
a170 1
	if (pci_intr_map_msi(pa, &ih) != 0 && pci_intr_map(pa, &ih) != 0) {
@


1.23
log
@Add more dell subids found in the windows driver.
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.22 2010/04/01 19:02:25 marco Exp $ */
d170 1
a170 1
	if (pci_intr_map(pa, &ih)) {
@


1.22
log
@Add H700 now that we know the subid...
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.21 2009/02/23 15:21:34 jsg Exp $ */
d77 7
a83 1
	{ 0x1f171028,	"Dell PERC H700" },
@


1.21
log
@Match on the SAS1078DE which appears to be used in at least the
ServeRAID-MR10is.

While here remove duplicate entries for SAS1078/PERC6 which
are the same id, both with a SYMBIOS (LSI) vendor id and
same product id (0x0060).

ok marco@@ dlg@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.20 2009/02/10 23:21:44 marco Exp $ */
d77 2
a78 1
	{ 0x0,		"" } /* XXX add entries when known */
@


1.20
log
@Use proper BAR on newer mfi raid cards.

From Jim Giannoules
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.19 2009/01/28 23:45:13 marco Exp $ */
d93 2
a96 2
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_DELL_PERC6,
	  MFI_IOP_PPC,		mfi_1078_subtypes },
@


1.19
log
@Add support for next generation megaraid sas raid controllers.
From Jim Giannoules <gortag@@gmail.com>
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.18 2008/11/23 12:50:23 dlg Exp $ */
d40 1
d139 1
d144 9
d154 2
a155 2
	reg = pci_mapreg_type(pa->pa_pc, pa->pa_tag, MFI_BAR);
	if (pci_mapreg_map(pa, MFI_BAR, reg, 0,
@


1.18
log
@sizeofa -> nitems
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.17 2008/10/27 03:11:58 marco Exp $ */
d75 4
d95 5
a99 1
	  MFI_IOP_PPC,		mfi_1078_subtypes }
@


1.17
log
@Move some include stuff around
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.16 2008/02/11 03:52:50 dlg Exp $ */
a93 1
#define sizeofa(_a) (sizeof(_a) / sizeof((_a)[0]))
d102 1
a102 1
	for (i = 0; i < sizeofa(mfi_pci_devices); i++) {
@


1.16
log
@reinstate pci subvendor/subdevice detection so we can figure out which
variant of the board we're attached to.

for marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.15 2008/02/11 01:07:02 dlg Exp $ */
d17 2
@


1.15
log
@add support for the mfi controllers with the ppc iops, aka, LSI SAS1078 or
Dell PERC6.

committed off a machine booting and rooting off a perc6. tested on a perc5
by marco@@
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.14 2008/01/26 05:43:03 dlg Exp $ */
d47 26
d75 4
a78 3
	pcireg_t	mpd_vendor;
	pcireg_t	mpd_product;
	enum mfi_iop	mpd_iop;
d81 1
a81 1
	  MFI_IOP_XSCALE },
d83 1
a83 1
	  MFI_IOP_XSCALE },
d85 1
a85 1
	  MFI_IOP_PPC },
d87 1
a87 1
	  MFI_IOP_XSCALE },
d89 1
a89 1
	  MFI_IOP_PPC }
d124 1
d128 3
a130 1
	pcireg_t		csr;
d134 2
a135 2
	csr = pci_mapreg_type(pa->pa_pc, pa->pa_tag, MFI_BAR);
	if (pci_mapreg_map(pa, MFI_BAR, csr, 0,
d160 18
a177 1
	printf(": %s\n", intrstr);
@


1.14
log
@newline when printing about a failure to attach.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.12 2007/11/26 21:20:55 marco Exp $ */
a39 1
int	mfi_pci_find_device(void *);
d51 1
a51 4
	pcireg_t	mpd_subvendor;
	pcireg_t	mpd_subproduct;
	char		*mpd_model;
	uint32_t	mpd_flags;
d54 1
a54 1
	  0,			0,		"",			0 },
d56 3
a58 13
	  0,			0,		"",			0 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1078 ,
	  PCI_VENDOR_SYMBIOS,	0x1006,		"LSI 8888elp",		0 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1078 ,
	  PCI_VENDOR_SYMBIOS,	0x100a,		"LSI 8708elp",		0 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1078 ,
	  PCI_VENDOR_SYMBIOS,	0x100f,		"LSI 8708E",		0 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1078 ,
	  PCI_VENDOR_SYMBIOS,	0x1012,		"LSI 8704ELP",		0 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1078 ,
	  PCI_VENDOR_SYMBIOS,	0x1013,		"LSI 8708em2",		0 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_SAS1078 ,
	  PCI_VENDOR_SYMBIOS,	0x1016,		"LSI 8880em2",		0 },
d60 1
a60 9
	  PCI_VENDOR_DELL,	0x1f01,		"Dell PERC 5/e",	0 },
	{ PCI_VENDOR_DELL,	PCI_PRODUCT_DELL_PERC5,
	  PCI_VENDOR_DELL,	0x1f02,		"Dell PERC 5/i",	0 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_DELL_PERC6,
	  PCI_VENDOR_DELL,	0x1f0a,		"Dell PERC 6/e",	0 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_DELL_PERC6,
	  PCI_VENDOR_DELL,	0x1f0b,		"Dell PERC 6/i",	0 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_DELL_PERC6,
	  PCI_VENDOR_DELL,	0x1f0d,		"Dell CERC 6/i",	0 },
d62 1
a62 4
	  PCI_VENDOR_DELL,	0x1f0c,		"Dell PERC 6/i integrated", 0 },
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_DELL_PERC6,
	  PCI_VENDOR_DELL,	0x1f11,		"Dell CERC 6/i integrated", 0 },
	{ 0 }
d65 11
a75 4
int
mfi_pci_find_device(void *aux) {
	struct pci_attach_args	*pa = aux;
	int			i;
d77 3
a79 6
	for (i = 0; mfi_pci_devices[i].mpd_vendor; i++) {
		if (mfi_pci_devices[i].mpd_vendor == PCI_VENDOR(pa->pa_id) &&
		    mfi_pci_devices[i].mpd_product == PCI_PRODUCT(pa->pa_id)) {
		    	DNPRINTF(MFI_D_MISC, "mfi_pci_find_device: %i\n", i);
			return (i);
		}
d82 1
a82 1
	return (-1);
d88 1
a88 12
	int			i;

	if ((i = mfi_pci_find_device(aux)) != -1) {
		DNPRINTF(MFI_D_MISC,
		    "mfi_pci_match: vendor: %04x  product: %04x\n",
		    mfi_pci_devices[i].mpd_vendor,
		    mfi_pci_devices[i].mpd_product);

		return (1);
	}

	return (0);
d96 1
a100 1
	uint32_t		subsysid, i;
d102 1
a102 7
	subsysid = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);
	for (i = 0; mfi_pci_devices[i].mpd_vendor; i++)
		if (mfi_pci_devices[i].mpd_subvendor == PCI_VENDOR(subsysid) &&
		    mfi_pci_devices[i].mpd_subproduct == PCI_PRODUCT(subsysid)){
				printf(", %s", mfi_pci_devices[i].mpd_model);
				break;
		}
a104 1
	csr |= PCI_MAPREG_MEM_TYPE_32BIT;
d132 1
a132 1
	if (mfi_attach(sc)) {
@


1.13
log
@Add LSI PCI IDs for 1078 based megaraid; from the windows driver inf
@
text
@d172 1
a172 1
		printf("%s: can't attach", DEVNAME(sc));
@


1.12
log
@Add new PERC6 & CERC6 PCI IDs
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.11 2006/08/06 04:40:08 brad Exp $ */
d61 12
@


1.11
log
@sync PCI ids.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.10 2006/08/06 03:58:36 brad Exp $ */
d65 10
@


1.10
log
@add another MegaRAID PCI id.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.9 2006/05/21 20:20:17 marco Exp $ */
d57 1
a57 1
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_MSAS,
d59 1
a59 1
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_MVERDE_ZCR,
@


1.9
log
@Add generic management function.
Redo ccb_state flags so that we can actually sleep on it.
Redo mfi_get_info to use new mgmt function.
Add rw_locks for mgmt interface.
Make BIOCINQ dynamic.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.8 2006/05/17 19:51:51 brad Exp $ */
d58 2
@


1.8
log
@tweak the dmesg printing a bit.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.7 2006/05/16 21:56:21 marco Exp $ */
d23 1
@


1.7
log
@Labeling was the wrong way around.  Make 5e 5i and vice versa.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.6 2006/04/26 01:18:20 marco Exp $ */
a108 1
	printf(": ");
d113 1
a113 1
				printf("%s ", mfi_pci_devices[i].mpd_model);
d121 1
a121 1
		printf("can't map controller pci space\n");
d128 1
a128 1
		printf("can't map interrupt\n");
d136 1
a136 1
		printf("can't establish interrupt");
d144 1
a144 1
	printf("%s\n", intrstr);
@


1.6
log
@Undo last commit.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.5 2006/04/26 00:57:58 marco Exp $ */
d59 1
a59 1
	  PCI_VENDOR_DELL,	0x1f01,		"Dell PERC 5/i",	0 },
d61 1
a61 1
	  PCI_VENDOR_DELL,	0x1f02,		"Dell PERC 5/e",	0 },
@


1.5
log
@don't return -1, just 1.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.4 2006/04/26 00:55:40 marco Exp $ */
d78 1
a78 1
	return (1);
@


1.4
log
@typo
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.3 2006/04/26 00:51:40 marco Exp $ */
d78 1
a78 1
	return (-1);
@


1.3
log
@Add subvendor and subsysid to the mix to differentiate between controllers.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.2 2006/04/07 17:00:42 marco Exp $ */
d61 1
a61 1
	  PCI_VENDOR_DELL,	0x1f02,		"Dell Perc 5/e",	0 },
@


1.2
log
@Use new shiny debug code.
@
text
@d1 1
a1 1
/* $OpenBSD: mfi_pci.c,v 1.1 2006/04/06 20:22:53 marco Exp $ */
d51 4
a54 1
	u_int32_t	mpd_flags;
d56 6
a61 2
	{ PCI_VENDOR_SYMBIOS,	PCI_PRODUCT_SYMBIOS_MSAS,		0 },
	{ PCI_VENDOR_DELL,	PCI_PRODUCT_DELL_PERC5I	,		0 },
d107 10
d122 1
a122 1
		printf(": can't map controller pci space\n");
d129 1
a129 1
		printf(": can't map interrupt\n");
d137 1
a137 1
		printf(": can't establish interrupt");
d145 1
a145 1
	printf(": %s\n", intrstr);
@


1.1
log
@Add skeleton driver for MegaRAID SAS.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d66 1
a66 3
#ifdef MFI_DEBUG
		    	printf("mfi_pci_find_device: %i\n", i);
#endif /* MFI_DEBUG */
d80 2
a81 2
#ifdef MFI_DEBUG
		printf("mfi_pci_match: vendor: %04x  product: %04x\n",
a83 1
#endif /* MFI_DEBUG */
d131 1
@

