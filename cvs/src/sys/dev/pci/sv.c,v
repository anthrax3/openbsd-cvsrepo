head	1.34;
access;
symbols
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.34.0.4
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.32.0.8
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.31.0.6
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.27.0.12
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.10
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.8
	OPENBSD_5_0:1.27.0.6
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.4
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.4
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.21.0.8
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.6
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.4
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.16.0.8
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.14
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.7.0.4
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.34
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.33;
commitid	qGgYgJTgEFuAoGj4;

1.33
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.32;
commitid	pi1a9KN0itEngOc4;

1.32
date	2015.05.11.06.46.22;	author ratchov;	state Exp;
branches;
next	1.31;
commitid	RaOGL5SyOGOZylwx;

1.31
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.30;
commitid	OBNa5kfxQ2UXoiIw;

1.30
date	2013.11.15.16.46.27;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2013.05.24.07.58.47;	author ratchov;	state Exp;
branches;
next	1.28;

1.28
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.26;

1.26
date	2009.06.23.06.39.48;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.24;

1.24
date	2008.04.21.00.32.43;	author jakemsr;	state Exp;
branches;
next	1.23;

1.23
date	2008.01.14.01.23.53;	author jakemsr;	state Exp;
branches;
next	1.22;

1.22
date	2007.11.05.00.17.28;	author jakemsr;	state Exp;
branches;
next	1.21;

1.21
date	2005.09.11.18.17.08;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.09.04.10.13;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.16.17.20.47;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.16.21.57.23;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.14.12.42.16;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.27.11.22.54;	author ho;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.11.19.20.28;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.11.06.04.17;	author nordin;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.27.00;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.31.11.00.24;	author art;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.08.25.10.13.30;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.03.21.13.48;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.08.04.23.27.49;	author niklas;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	99.01.02.00.02.49;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	98.11.03.21.05.07;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	98.10.05.20.47.45;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.07.13.13.53.16;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	98.07.13.01.50.15;	author csapuntz;	state Exp;
branches;
next	1.1;

1.1
date	98.07.07.22.44.10;	author csapuntz;	state Exp;
branches;
next	;

1.7.4.1
date	2001.05.14.22.25.57;	author niklas;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.7.4.3;

1.7.4.3
date	2001.11.13.21.10.03;	author niklas;	state Exp;
branches;
next	1.7.4.4;

1.7.4.4
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.7.4.5;

1.7.4.5
date	2002.03.28.15.35.59;	author niklas;	state Exp;
branches;
next	1.7.4.6;

1.7.4.6
date	2003.03.28.00.38.25;	author niklas;	state Exp;
branches;
next	1.7.4.7;

1.7.4.7
date	2003.05.13.19.35.09;	author ho;	state Exp;
branches;
next	;

1.10.2.1
date	2002.01.31.22.55.36;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2002.06.11.03.42.27;	author art;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2002.10.29.00.33.29;	author art;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2003.05.19.22.19.08;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Remove unused getdev() audio driver functions.
@
text
@/*      $OpenBSD: sv.c,v 1.33 2016/09/14 06:12:19 ratchov Exp $ */

/*
 * Copyright (c) 1998 Constantine Paul Sapuntzakis
 * All rights reserved
 *
 * Author: Constantine Paul Sapuntzakis (csapuntz@@cvs.openbsd.org)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The author's name or those of the contributors may be used to
 *    endorse or promote products derived from this software without 
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * S3 SonicVibes driver
 *   Heavily based on the eap driver by Lennart Augustsson
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>

#include <dev/ic/i8237reg.h>
#include <dev/ic/s3_617.h>


#include <machine/bus.h>

#ifdef __OpenBSD__
struct        cfdriver sv_cd = {
      NULL, "sv", DV_DULL
};
#endif

#ifdef AUDIO_DEBUG
#define DPRINTF(x)	if (svdebug) printf x
#define DPRINTFN(n,x)	if (svdebug>(n)) printf x
static int	svdebug = 100;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

int	sv_match(struct device *, void *, void *);
static void	sv_attach(struct device *, struct device *, void *);
int	sv_intr(void *);

struct sv_dma {
	bus_dmamap_t map;
        caddr_t addr;
        bus_dma_segment_t segs[1];
        int nsegs;
        size_t size;
        struct sv_dma *next;
};
#define DMAADDR(map) ((map)->segs[0].ds_addr)
#define KERNADDR(map) ((void *)((map)->addr))

enum {
  SV_DMAA_CONFIGURED = 1,
  SV_DMAC_CONFIGURED = 2,
  SV_DMAA_TRIED_CONFIGURE = 4,
  SV_DMAC_TRIED_CONFIGURE = 8
};

struct sv_softc {
	struct device sc_dev;		/* base device */
	void *sc_ih;			/* interrupt vectoring */

        pci_chipset_tag_t sc_pci_chipset_tag;
        pcitag_t  sc_pci_tag;

	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;
	bus_space_handle_t sc_dmaa_ioh;
	bus_space_handle_t sc_dmac_ioh;
	bus_dma_tag_t sc_dmatag;	/* DMA tag */

        struct sv_dma *sc_dmas;

	void	(*sc_pintr)(void *);	/* dma completion intr handler */
	void	*sc_parg;		/* arg for sc_intr() */

	void	(*sc_rintr)(void *);	/* dma completion intr handler */
	void	*sc_rarg;		/* arg for sc_intr() */
	char	sc_enable;
        char    sc_trd;

        char    sc_dma_configured;
        u_int	sc_record_source;	/* recording source mask */
};


struct cfattach sv_ca = {
	sizeof(struct sv_softc), sv_match, sv_attach
};

#define ARRAY_SIZE(foo)  ((sizeof(foo)) / sizeof(foo[0]))

int	sv_allocmem(struct sv_softc *, size_t, size_t, struct sv_dma *);
int	sv_freemem(struct sv_softc *, struct sv_dma *);

int	sv_open(void *, int);
void	sv_close(void *);
int	sv_set_params(void *, int, int, struct audio_params *, struct audio_params *);
int	sv_round_blocksize(void *, int);
int	sv_dma_init_output(void *, void *, int);
int	sv_dma_init_input(void *, void *, int);
int	sv_dma_output(void *, void *, int, void (*)(void *), void *);
int	sv_dma_input(void *, void *, int, void (*)(void *), void *);
int	sv_halt_in_dma(void *);
int	sv_halt_out_dma(void *);
int	sv_mixer_set_port(void *, mixer_ctrl_t *);
int	sv_mixer_get_port(void *, mixer_ctrl_t *);
int	sv_query_devinfo(void *, mixer_devinfo_t *);
void   *sv_malloc(void *, int, size_t, int, int);
void	sv_free(void *, void *, int);
int	sv_get_props(void *);

void    sv_dumpregs(struct sv_softc *sc);

struct audio_hw_if sv_hw_if = {
	sv_open,
	sv_close,
	sv_set_params,
	sv_round_blocksize,
	NULL,
	sv_dma_init_output,
	sv_dma_init_input,
	sv_dma_output,
	sv_dma_input,
	sv_halt_out_dma,
	sv_halt_in_dma,
	NULL,
	NULL,
	sv_mixer_set_port,
	sv_mixer_get_port,
	sv_query_devinfo,
	sv_malloc,
	sv_free,
	NULL,
	sv_get_props,
	NULL,
	NULL
};


static __inline__ u_int8_t sv_read(struct sv_softc *, u_int8_t);
static __inline__ u_int8_t sv_read_indirect(struct sv_softc *, u_int8_t);
static __inline__ void sv_write(struct sv_softc *, u_int8_t, u_int8_t );
static __inline__ void sv_write_indirect(struct sv_softc *, u_int8_t, u_int8_t );
static void sv_init_mixer(struct sv_softc *);

static __inline__ void
sv_write (struct sv_softc *sc, u_int8_t reg, u_int8_t val)
{
  bus_space_write_1(sc->sc_iot, sc->sc_ioh, reg, val);
}

static __inline__ u_int8_t
sv_read (struct sv_softc *sc, u_int8_t reg)
{
  return (bus_space_read_1(sc->sc_iot, sc->sc_ioh, reg));
}

static __inline__ u_int8_t
sv_read_indirect (struct sv_softc *sc, u_int8_t reg)
{
    u_int8_t iaddr = 0;

    if (sc->sc_trd > 0)
      iaddr |= SV_IADDR_TRD;

    iaddr |= (reg & SV_IADDR_MASK);
    sv_write (sc, SV_CODEC_IADDR, iaddr);

    return (sv_read(sc, SV_CODEC_IDATA));
}

static __inline__ void
sv_write_indirect (struct sv_softc *sc, u_int8_t reg, u_int8_t val)
{
    u_int8_t iaddr = 0;
#ifdef DIAGNOSTIC
    if (reg > 0x3f) {
      printf ("Invalid register\n");
      return;
    }
#endif

    if (reg == SV_DMA_DATA_FORMAT)
      iaddr |= SV_IADDR_MCE;

    if (sc->sc_trd > 0)
      iaddr |= SV_IADDR_TRD;

    iaddr |= (reg & SV_IADDR_MASK);
    sv_write (sc, SV_CODEC_IADDR, iaddr);
    sv_write (sc, SV_CODEC_IDATA, val);
}

int
sv_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_S3 &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_S3_SONICVIBES)
	  return (1);

	return (0);
}

static void
sv_attach(struct device *parent, struct device *self, void *aux)
{
  struct sv_softc *sc = (struct sv_softc *)self;
  struct pci_attach_args *pa = aux;
  pci_chipset_tag_t pc = pa->pa_pc;
  pci_intr_handle_t ih;
  bus_size_t iosize;
  char const *intrstr;
  u_int32_t  dmareg, dmaio; 
  u_int8_t   reg;

  sc->sc_pci_chipset_tag = pc;
  sc->sc_pci_tag = pa->pa_tag;

  /* Map the enhanced port only */
  if (pci_mapreg_map(pa, SV_ENHANCED_PORTBASE_SLOT, PCI_MAPREG_TYPE_IO, 0,
      &sc->sc_iot, &sc->sc_ioh, NULL, &iosize, 0)) {
    printf (": Couldn't map enhanced synth I/O range\n");
    return;
  }

  sc->sc_dmatag = pa->pa_dmat;

  dmareg = pci_conf_read(pa->pa_pc, pa->pa_tag, SV_DMAA_CONFIG_OFF);
  iosize = 0x10;
  dmaio =  dmareg & ~(iosize - 1);
  
  if (dmaio) {
    dmareg &= 0xF;
    
    if (bus_space_map(sc->sc_iot, dmaio, iosize, 0, &sc->sc_dmaa_ioh)) {
      /* The BIOS assigned us some bad I/O address! Make sure to clear
         and disable this DMA before we enable the device */
      pci_conf_write(pa->pa_pc, pa->pa_tag, SV_DMAA_CONFIG_OFF, 0);

      printf (": can't map DMA i/o space\n");
      goto enable;
    }

    pci_conf_write(pa->pa_pc, pa->pa_tag, SV_DMAA_CONFIG_OFF,
		   dmaio | dmareg | 
		   SV_DMA_CHANNEL_ENABLE | SV_DMAA_EXTENDED_ADDR);
    sc->sc_dma_configured |= SV_DMAA_CONFIGURED;
  }

  dmareg = pci_conf_read(pa->pa_pc, pa->pa_tag, SV_DMAC_CONFIG_OFF);
  dmaio = dmareg & ~(iosize - 1);
  if (dmaio) {
    dmareg &= 0xF;

    if (bus_space_map(sc->sc_iot, dmaio, iosize, 0, &sc->sc_dmac_ioh)) {
      /* The BIOS assigned us some bad I/O address! Make sure to clear
         and disable this DMA before we enable the device */
      pci_conf_write (pa->pa_pc, pa->pa_tag, SV_DMAC_CONFIG_OFF, 
		      dmareg & ~SV_DMA_CHANNEL_ENABLE); 
      printf (": can't map DMA i/o space\n");
      goto enable;
    }

    pci_conf_write(pa->pa_pc, pa->pa_tag, SV_DMAC_CONFIG_OFF, 
		   dmaio | dmareg | SV_DMA_CHANNEL_ENABLE);
    sc->sc_dma_configured |= SV_DMAC_CONFIGURED;
  }

  /* Enable the device. */
 enable:
  sv_write_indirect(sc, SV_ANALOG_POWER_DOWN_CONTROL, 0);
  sv_write_indirect(sc, SV_DIGITAL_POWER_DOWN_CONTROL, 0);

  /* initialize codec registers */
  reg = sv_read(sc, SV_CODEC_CONTROL);
  reg |= SV_CTL_RESET;
  sv_write(sc, SV_CODEC_CONTROL, reg);
  delay(50);

  reg = sv_read(sc, SV_CODEC_CONTROL);
  reg &= ~SV_CTL_RESET;
  reg |= SV_CTL_INTA | SV_CTL_ENHANCED;

  /* This write clears the reset */
  sv_write(sc, SV_CODEC_CONTROL, reg);
  delay(50);

  /* This write actually shoves the new values in */
  sv_write(sc, SV_CODEC_CONTROL, reg);

  DPRINTF (("reg: %x\n", sv_read(sc, SV_CODEC_CONTROL)));

  /* Enable DMA interrupts */
  reg = sv_read(sc, SV_CODEC_INTMASK);
  reg &= ~(SV_INTMASK_DMAA | SV_INTMASK_DMAC);
  reg |= SV_INTMASK_UD | SV_INTMASK_SINT | SV_INTMASK_MIDI;
  sv_write(sc, SV_CODEC_INTMASK, reg);

  sv_read(sc, SV_CODEC_STATUS);

  sc->sc_trd = 0;
  sc->sc_enable = 0;

  /* Map and establish the interrupt. */
  if (pci_intr_map(pa, &ih)) {
    printf(": couldn't map interrupt\n");
    return;
  }
  intrstr = pci_intr_string(pc, ih);
  sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO | IPL_MPSAFE,
      sv_intr, sc, sc->sc_dev.dv_xname);
  if (sc->sc_ih == NULL) {
    printf(": couldn't establish interrupt");
    if (intrstr != NULL)
      printf(" at %s", intrstr);
    printf("\n");
    return;
  }
  printf(": %s\n", intrstr);

  sv_init_mixer(sc);

  audio_attach_mi(&sv_hw_if, sc, &sc->sc_dev);
}

#ifdef AUDIO_DEBUG
void
sv_dumpregs(struct sv_softc *sc)
{
  int idx;

  { int idx;
  for (idx = 0; idx < 0x50; idx += 4) {
    printf ("%02x = %x\n", idx, pci_conf_read(sc->sc_pci_chipset_tag,
            sc->sc_pci_tag, idx));
  }
  }

  for (idx = 0; idx < 6; idx++) {
    printf ("REG %02x = %02x\n", idx, sv_read(sc, idx));
  }

  for (idx = 0; idx < 0x32; idx++) {
    printf ("IREG %02x = %02x\n", idx, sv_read_indirect(sc, idx));
  }

  for (idx = 0; idx < 0x10; idx++) {
    printf ("DMA %02x = %02x\n", idx, 
	    bus_space_read_1(sc->sc_iot, sc->sc_dmaa_ioh, idx));
  }

  return;
}
#endif

int
sv_intr(void *p)
{
  struct sv_softc *sc = p;
  u_int8_t intr;

  mtx_enter(&audio_lock);
  intr = sv_read(sc, SV_CODEC_STATUS);

  if (!(intr & (SV_INTSTATUS_DMAA | SV_INTSTATUS_DMAC))) {
    mtx_leave(&audio_lock);
    return (0);
  }

  if (intr & SV_INTSTATUS_DMAA) {
    if (sc->sc_pintr)
      sc->sc_pintr(sc->sc_parg);
  }

  if (intr & SV_INTSTATUS_DMAC) {
    if (sc->sc_rintr)
      sc->sc_rintr(sc->sc_rarg);
  }
  mtx_leave(&audio_lock);
  return (1);
}

int
sv_allocmem(struct sv_softc *sc, size_t size, size_t align, struct sv_dma *p)
{
	int error;

	p->size = size;
	error = bus_dmamem_alloc(sc->sc_dmatag, p->size, align, 0,
				 p->segs, ARRAY_SIZE(p->segs),
				 &p->nsegs, BUS_DMA_NOWAIT);
	if (error)
		return (error);

	error = bus_dmamem_map(sc->sc_dmatag, p->segs, p->nsegs, p->size, 
			       &p->addr, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);
	if (error)
		goto free;

	error = bus_dmamap_create(sc->sc_dmatag, p->size, 1, p->size,
				  0, BUS_DMA_NOWAIT, &p->map);
	if (error)
		goto unmap;

	error = bus_dmamap_load(sc->sc_dmatag, p->map, p->addr, p->size, NULL, 
				BUS_DMA_NOWAIT);
	if (error)
		goto destroy;
	return (0);

destroy:
	bus_dmamap_destroy(sc->sc_dmatag, p->map);
unmap:
	bus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);
free:
	bus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);
	return (error);
}

int
sv_freemem(struct sv_softc *sc, struct sv_dma *p)
{
	bus_dmamap_unload(sc->sc_dmatag, p->map);
	bus_dmamap_destroy(sc->sc_dmatag, p->map);
	bus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);
	bus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);
	return (0);
}

int
sv_open(void *addr, int flags)
{

    struct sv_softc *sc = addr;
    int  intr_mask = 0;
    u_int8_t reg;

    /* Map the DMA channels, if necessary */
    if (!(sc->sc_dma_configured & SV_DMAA_CONFIGURED)) {
	/* XXX - there seems to be no general way to find an
	   I/O range */
	int dmaio;
	int iosize = 0x10;

	if (sc->sc_dma_configured & SV_DMAA_TRIED_CONFIGURE)
	    return (ENXIO);

	for (dmaio = 0xa000; dmaio < 0xb000; dmaio += iosize) {
	    if (!bus_space_map(sc->sc_iot, dmaio, iosize, 0, 
			      &sc->sc_dmaa_ioh)) {
		goto found_dmaa;
	    }
	}

	sc->sc_dma_configured |= SV_DMAA_TRIED_CONFIGURE;
	return (ENXIO);
    found_dmaa:
	  
	pci_conf_write(sc->sc_pci_chipset_tag, sc->sc_pci_tag,
		       SV_DMAA_CONFIG_OFF, 
		       dmaio | SV_DMA_CHANNEL_ENABLE 
		       | SV_DMAA_EXTENDED_ADDR);

	sc->sc_dma_configured |= SV_DMAA_CONFIGURED;
	intr_mask = 1;
    }

    if (!(sc->sc_dma_configured & SV_DMAC_CONFIGURED)) {
	/* XXX - there seems to be no general way to find an
	   I/O range */
	int dmaio;
	int iosize = 0x10;

	if (sc->sc_dma_configured & SV_DMAC_TRIED_CONFIGURE)
	    return (ENXIO);

	for (dmaio = 0xa000; dmaio < 0xb000; dmaio += iosize) {
	    if (!bus_space_map(sc->sc_iot, dmaio, iosize, 0, 
			      &sc->sc_dmac_ioh)) {
		goto found_dmac;
	    }
	}

	sc->sc_dma_configured |= SV_DMAC_TRIED_CONFIGURE;	    
	return (ENXIO);
    found_dmac:
	  
	pci_conf_write(sc->sc_pci_chipset_tag, sc->sc_pci_tag,
		       SV_DMAC_CONFIG_OFF, 
		       dmaio | SV_DMA_CHANNEL_ENABLE);

	sc->sc_dma_configured |= SV_DMAC_CONFIGURED;
	intr_mask = 1;
    }

    /* Make sure DMA interrupts are enabled */
    if (intr_mask) {
	reg = sv_read(sc, SV_CODEC_INTMASK);
	reg &= ~(SV_INTMASK_DMAA | SV_INTMASK_DMAC);
	reg |= SV_INTMASK_UD | SV_INTMASK_SINT | SV_INTMASK_MIDI;
	sv_write(sc, SV_CODEC_INTMASK, reg);
    }

    sc->sc_pintr = 0;
    sc->sc_rintr = 0;

    return (0);
}

/*
 * Close function is called at splaudio().
 */
void
sv_close(void *addr)
{
	struct sv_softc *sc = addr;
    
        sv_halt_in_dma(sc);
        sv_halt_out_dma(sc);

        sc->sc_pintr = 0;
        sc->sc_rintr = 0;
}

int
sv_set_params(void *addr, int setmode, int usemode,
    struct audio_params *p, struct audio_params *r)
{
	struct sv_softc *sc = addr;
        u_int32_t mode, val;
        u_int8_t reg;
	
        switch (p->encoding) {
        case AUDIO_ENCODING_SLINEAR_LE:
        	if (p->precision != 16)
			return EINVAL;
        	break;
        case AUDIO_ENCODING_ULINEAR_BE:
        case AUDIO_ENCODING_ULINEAR_LE:
        	if (p->precision != 8)
			return EINVAL;
        	break;
        default:
        	return (EINVAL);
        }

	if (p->precision == 16)
		mode = SV_DMAA_FORMAT16 | SV_DMAC_FORMAT16;
	else
		mode = 0;
	if (p->channels > 2)
		p->channels = 2;
        if (p->channels == 2)
        	mode |= SV_DMAA_STEREO | SV_DMAC_STEREO;
        if (p->sample_rate < 2000)
		p->sample_rate = 2000;
	if (p->sample_rate > 48000)
		p->sample_rate = 48000;

	p->bps = AUDIO_BPS(p->precision);
	r->bps = AUDIO_BPS(r->precision);
	p->msb = r->msb = 1;

        /* Set the encoding */
	reg = sv_read_indirect(sc, SV_DMA_DATA_FORMAT);
	reg &= ~(SV_DMAA_FORMAT16 | SV_DMAC_FORMAT16 | SV_DMAA_STEREO |
		 SV_DMAC_STEREO);
	reg |= (mode);
	sv_write_indirect(sc, SV_DMA_DATA_FORMAT, reg);

	val = p->sample_rate * 65536 / 48000;

	sv_write_indirect(sc, SV_PCM_SAMPLE_RATE_0, (val & 0xff));
	sv_write_indirect(sc, SV_PCM_SAMPLE_RATE_1, (val >> 8));

#define F_REF 24576000

	if (setmode & AUMODE_RECORD)
	{
	  /* The ADC reference frequency (f_out) is 512 * the sample rate */

	  /* f_out is dervied from the 24.576MHZ crystal by three values:
	     M & N & R. The equation is as follows:

	     f_out = (m + 2) * f_ref / ((n + 2) * (2 ^ a))

	     with the constraint that:

	     80 MhZ < (m + 2) / (n + 2) * f_ref <= 150MHz
	     and n, m >= 1
	  */

	  int  goal_f_out = 512 * r->sample_rate;
	  int  a, n, m, best_n, best_m, best_error = 10000000;
	  int  pll_sample;

	  for (a = 0; a < 8; a++) {
	    if ((goal_f_out * (1 << a)) >= 80000000)
	      break;
	  }
	  
	  /* a != 8 because sample_rate >= 2000 */

	  for (n = 33; n > 2; n--) {
	    int error;

	    m = (goal_f_out * n * (1 << a)) / F_REF;

	    if ((m > 257) || (m < 3)) continue;
 
	    pll_sample = (m * F_REF) / (n * (1 << a));
	    pll_sample /= 512;

	    /* Threshold might be good here */
	    error = pll_sample - r->sample_rate;
	    error = abs(error);
	    
	    if (error < best_error) {
	      best_error = error;
	      best_n = n;
	      best_m = m;
	      if (error == 0) break;
	    }
	  }
	

	  best_n -= 2;
	  best_m -= 2;
	  
	  sv_write_indirect(sc, SV_ADC_PLL_M, best_m);
	  sv_write_indirect(sc, SV_ADC_PLL_N, best_n | (a << SV_PLL_R_SHIFT));
	}
        return (0);
}

int
sv_round_blocksize(void *addr, int blk)
{
	return ((blk + 31) & -32);	/* keep good alignment */
}

int
sv_dma_init_input(void *addr, void *buf, int cc)
{
	struct sv_softc *sc = addr;
	struct sv_dma *p;
	int dma_count;

	DPRINTF(("sv_dma_init_input: dma start loop input addr=%p cc=%d\n", 
		 buf, cc));
        for (p = sc->sc_dmas; p && KERNADDR(p) != buf; p = p->next)
		;
	if (!p) {
		printf("sv_dma_init_input: bad addr %p\n", buf);
		return (EINVAL);
	}

	dma_count = (cc >> 1) - 1;

	bus_space_write_4(sc->sc_iot, sc->sc_dmac_ioh, SV_DMA_ADDR0,
			  DMAADDR(p));
	bus_space_write_4(sc->sc_iot, sc->sc_dmac_ioh, SV_DMA_COUNT0,
			  dma_count);
	bus_space_write_1(sc->sc_iot, sc->sc_dmac_ioh, SV_DMA_MODE,
			  DMA37MD_WRITE | DMA37MD_LOOP);

	return (0);
}

int
sv_dma_init_output(void *addr, void *buf, int cc)
{
	struct sv_softc *sc = addr;
	struct sv_dma *p;
	int dma_count;

	DPRINTF(("sv: dma start loop output buf=%p cc=%d\n", buf, cc));
        for (p = sc->sc_dmas; p && KERNADDR(p) != buf; p = p->next)
		;
	if (!p) {
		printf("sv_dma_init_output: bad addr %p\n", buf);
		return (EINVAL);
	}

	dma_count = cc - 1;

	bus_space_write_4(sc->sc_iot, sc->sc_dmaa_ioh, SV_DMA_ADDR0,
			  DMAADDR(p));
	bus_space_write_4(sc->sc_iot, sc->sc_dmaa_ioh, SV_DMA_COUNT0,
			  dma_count);
	bus_space_write_1(sc->sc_iot, sc->sc_dmaa_ioh, SV_DMA_MODE,
			  DMA37MD_READ | DMA37MD_LOOP);

	return (0);
}

int
sv_dma_output(void *addr, void *p, int cc, void (*intr)(void *), void *arg)
{
	struct sv_softc *sc = addr;
	u_int8_t mode;

	DPRINTFN(1, 
                 ("sv_dma_output: sc=%p buf=%p cc=%d intr=%p(%p)\n", 
                  addr, p, cc, intr, arg));
	sc->sc_pintr = intr;
	sc->sc_parg = arg;
	if (!(sc->sc_enable & SV_PLAY_ENABLE)) {
	        int dma_count = cc - 1;

		sv_write_indirect(sc, SV_DMAA_COUNT1, dma_count >> 8);
		sv_write_indirect(sc, SV_DMAA_COUNT0, (dma_count & 0xFF));

		mode = sv_read_indirect(sc, SV_PLAY_RECORD_ENABLE);
		mode |= SV_PLAY_ENABLE;
		sv_write_indirect(sc, SV_PLAY_RECORD_ENABLE, mode);
		sc->sc_enable |= SV_PLAY_ENABLE;
	}
        return (0);
}

int
sv_dma_input(void *addr, void *p, int cc, void (*intr)(void *), void *arg)
{
	struct sv_softc *sc = addr;
	u_int8_t mode;

	DPRINTFN(1, ("sv_dma_input: sc=%p buf=%p cc=%d intr=%p(%p)\n", 
		     addr, p, cc, intr, arg));
	sc->sc_rintr = intr;
	sc->sc_rarg = arg;
	if (!(sc->sc_enable & SV_RECORD_ENABLE)) {
	        int dma_count = (cc >> 1) - 1;

		sv_write_indirect(sc, SV_DMAC_COUNT1, dma_count >> 8);
		sv_write_indirect(sc, SV_DMAC_COUNT0, (dma_count & 0xFF));

		mode = sv_read_indirect(sc, SV_PLAY_RECORD_ENABLE);
		mode |= SV_RECORD_ENABLE;
		sv_write_indirect(sc, SV_PLAY_RECORD_ENABLE, mode);
		sc->sc_enable |= SV_RECORD_ENABLE;
	}
        return (0);
}

int
sv_halt_out_dma(void *addr)
{
	struct sv_softc *sc = addr;
	u_int8_t mode;
	
        DPRINTF(("sv: sv_halt_out_dma\n"));
	mtx_enter(&audio_lock);
	mode = sv_read_indirect(sc, SV_PLAY_RECORD_ENABLE);
	mode &= ~SV_PLAY_ENABLE;
	sc->sc_enable &= ~SV_PLAY_ENABLE;
	sv_write_indirect(sc, SV_PLAY_RECORD_ENABLE, mode);
	mtx_leave(&audio_lock);
        return (0);
}

int
sv_halt_in_dma(void *addr)
{
	struct sv_softc *sc = addr;
	u_int8_t mode;
    
        DPRINTF(("sv: sv_halt_in_dma\n"));
	mtx_enter(&audio_lock);
	mode = sv_read_indirect(sc, SV_PLAY_RECORD_ENABLE);
	mode &= ~SV_RECORD_ENABLE;
	sc->sc_enable &= ~SV_RECORD_ENABLE;
	sv_write_indirect(sc, SV_PLAY_RECORD_ENABLE, mode);
	mtx_leave(&audio_lock);
        return (0);
}

/*
 * Mixer related code is here
 *
 */

#define SV_INPUT_CLASS 0
#define SV_OUTPUT_CLASS 1
#define SV_RECORD_CLASS 2

#define SV_LAST_CLASS 2

static const char *mixer_classes[] = { AudioCinputs, AudioCoutputs, AudioCrecord };

static const struct {
  u_int8_t   l_port;
  u_int8_t   r_port;
  u_int8_t   mask;
  u_int8_t   class;
  const char *audio;
} ports[] = {
  { SV_LEFT_AUX1_INPUT_CONTROL, SV_RIGHT_AUX1_INPUT_CONTROL, SV_AUX1_MASK,
    SV_INPUT_CLASS, "aux1" },
  { SV_LEFT_CD_INPUT_CONTROL, SV_RIGHT_CD_INPUT_CONTROL, SV_CD_MASK, 
    SV_INPUT_CLASS, AudioNcd },
  { SV_LEFT_LINE_IN_INPUT_CONTROL, SV_RIGHT_LINE_IN_INPUT_CONTROL, SV_LINE_IN_MASK,
    SV_INPUT_CLASS, AudioNline },
  { SV_MIC_INPUT_CONTROL, 0, SV_MIC_MASK, SV_INPUT_CLASS, AudioNmicrophone },
  { SV_LEFT_SYNTH_INPUT_CONTROL, SV_RIGHT_SYNTH_INPUT_CONTROL, 
    SV_SYNTH_MASK, SV_INPUT_CLASS, AudioNfmsynth },
  { SV_LEFT_AUX2_INPUT_CONTROL, SV_RIGHT_AUX2_INPUT_CONTROL, SV_AUX2_MASK,
    SV_INPUT_CLASS, "aux2" },
  { SV_LEFT_PCM_INPUT_CONTROL, SV_RIGHT_PCM_INPUT_CONTROL, SV_PCM_MASK,
    SV_INPUT_CLASS, AudioNdac },
  { SV_LEFT_MIXER_OUTPUT_CONTROL, SV_RIGHT_MIXER_OUTPUT_CONTROL, 
    SV_MIXER_OUT_MASK, SV_OUTPUT_CLASS, AudioNmaster }
};


static const struct {
  int idx;
  const char *name;
} record_sources[] = {
  { SV_REC_CD, AudioNcd },
  { SV_REC_DAC, AudioNdac },
  { SV_REC_AUX2, "aux2" },
  { SV_REC_LINE, AudioNline },
  { SV_REC_AUX1, "aux1" },
  { SV_REC_MIC, AudioNmicrophone },
  { SV_REC_MIXER, AudioNmixerout }
};


#define SV_DEVICES_PER_PORT 2
#define SV_FIRST_MIXER (SV_LAST_CLASS + 1)
#define SV_LAST_MIXER (SV_DEVICES_PER_PORT * (ARRAY_SIZE(ports)) + SV_LAST_CLASS)
#define SV_RECORD_SOURCE (SV_LAST_MIXER + 1)
#define SV_MIC_BOOST (SV_LAST_MIXER + 2)
#define SV_RECORD_GAIN (SV_LAST_MIXER + 3)
#define SV_SRS_MODE (SV_LAST_MIXER + 4)

int 
sv_query_devinfo(void *addr, mixer_devinfo_t *dip)
{

  if (dip->index < 0)
    return (ENXIO);

  /* It's a class */
  if (dip->index <= SV_LAST_CLASS) {
    dip->type = AUDIO_MIXER_CLASS;
    dip->mixer_class = dip->index;
    dip->next = dip->prev = AUDIO_MIXER_LAST;
    strlcpy(dip->label.name, mixer_classes[dip->index],
	    sizeof dip->label.name);
    return (0);
  }

  if (dip->index >= SV_FIRST_MIXER &&
      dip->index <= SV_LAST_MIXER) {
    int off = dip->index - SV_FIRST_MIXER;
    int mute = (off % SV_DEVICES_PER_PORT);
    int idx = off / SV_DEVICES_PER_PORT;

    dip->mixer_class = ports[idx].class;
    strlcpy(dip->label.name, ports[idx].audio, sizeof dip->label.name);

    if (!mute) {
      dip->type = AUDIO_MIXER_VALUE;
      dip->prev = AUDIO_MIXER_LAST;
      dip->next = dip->index + 1;

      if (ports[idx].r_port != 0)
	dip->un.v.num_channels = 2;
      else
	dip->un.v.num_channels = 1;
      
      strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);

    } else {
      dip->type = AUDIO_MIXER_ENUM;
      dip->prev = dip->index - 1;
      dip->next = AUDIO_MIXER_LAST;

      strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
      dip->un.e.num_mem = 2;
      strlcpy(dip->un.e.member[0].label.name, AudioNoff,
	  sizeof dip->un.e.member[0].label.name);
      dip->un.e.member[0].ord = 0;
      strlcpy(dip->un.e.member[1].label.name, AudioNon,
	  sizeof dip->un.e.member[1].label.name);
      dip->un.e.member[1].ord = 1;

    }

    return (0);
  }

  switch (dip->index) {
  case SV_RECORD_SOURCE:
    dip->mixer_class = SV_RECORD_CLASS;
    dip->prev = AUDIO_MIXER_LAST;
    dip->next = SV_RECORD_GAIN;
    strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
    dip->type = AUDIO_MIXER_ENUM;

    dip->un.e.num_mem = ARRAY_SIZE(record_sources);

    {
      int idx;
      for (idx = 0; idx < ARRAY_SIZE(record_sources); idx++) {
	strlcpy(dip->un.e.member[idx].label.name, record_sources[idx].name,
	    sizeof dip->un.e.member[idx].label.name);
	dip->un.e.member[idx].ord = record_sources[idx].idx;
      }
    }
    return (0);

  case SV_RECORD_GAIN:
    dip->mixer_class = SV_RECORD_CLASS;
    dip->prev = SV_RECORD_SOURCE;
    dip->next = AUDIO_MIXER_LAST;
    strlcpy(dip->label.name, "gain", sizeof dip->label.name);
    dip->type = AUDIO_MIXER_VALUE;
    dip->un.v.num_channels = 1;
    strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
    return (0);

  case SV_MIC_BOOST:
    dip->mixer_class = SV_RECORD_CLASS;
    dip->prev = AUDIO_MIXER_LAST;
    dip->next = AUDIO_MIXER_LAST;
    strlcpy(dip->label.name, "micboost", sizeof dip->label.name);
    goto on_off;

  case SV_SRS_MODE:
    dip->mixer_class = SV_OUTPUT_CLASS;
    dip->prev = dip->next = AUDIO_MIXER_LAST;
    strlcpy(dip->label.name, AudioNspatial, sizeof dip->label.name);

on_off:
    dip->type = AUDIO_MIXER_ENUM;
    dip->un.e.num_mem = 2;
    strlcpy(dip->un.e.member[0].label.name, AudioNoff,
	sizeof dip->un.e.member[0].label.name);
    dip->un.e.member[0].ord = 0;
    strlcpy(dip->un.e.member[1].label.name, AudioNon,
	sizeof dip->un.e.member[1].label.name);
    dip->un.e.member[1].ord = 1;
    return (0);
  }

  return (ENXIO);
}

int
sv_mixer_set_port(void *addr, mixer_ctrl_t *cp)
{
  struct sv_softc *sc = addr;
  u_int8_t reg;
  int idx;

  if (cp->dev >= SV_FIRST_MIXER &&
      cp->dev <= SV_LAST_MIXER) {
    int off = cp->dev - SV_FIRST_MIXER;
    int mute = (off % SV_DEVICES_PER_PORT);
    idx = off / SV_DEVICES_PER_PORT;

    if (mute) {
      if (cp->type != AUDIO_MIXER_ENUM) 
	return (EINVAL);

      reg = sv_read_indirect(sc, ports[idx].l_port);
      if (cp->un.ord) 
	reg |= SV_MUTE_BIT;
      else
	reg &= ~SV_MUTE_BIT;
      sv_write_indirect(sc, ports[idx].l_port, reg);

      if (ports[idx].r_port) {
	reg = sv_read_indirect(sc, ports[idx].r_port);
	if (cp->un.ord) 
	  reg |= SV_MUTE_BIT;
	else
	  reg &= ~SV_MUTE_BIT;
	sv_write_indirect(sc, ports[idx].r_port, reg);
      }
    } else {
      int  lval, rval;

      if (cp->type != AUDIO_MIXER_VALUE)
	return (EINVAL);

      if (cp->un.value.num_channels != 1 &&
	  cp->un.value.num_channels != 2)
	return (EINVAL);

      if (ports[idx].r_port == 0) {
	if (cp->un.value.num_channels != 1)
	  return (EINVAL);
	lval = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
      } else {
	if (cp->un.value.num_channels != 2)
	  return (EINVAL);

	lval = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
	rval = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
      }

      sc->sc_trd = 1;

      reg = sv_read_indirect(sc, ports[idx].l_port);
      reg &= ~(ports[idx].mask);
      lval = ((AUDIO_MAX_GAIN - lval) * ports[idx].mask) / AUDIO_MAX_GAIN;
      reg |= lval;
      sv_write_indirect(sc, ports[idx].l_port, reg);

      if (ports[idx].r_port != 0) {
	reg = sv_read_indirect(sc, ports[idx].r_port);
	reg &= ~(ports[idx].mask);

	rval = ((AUDIO_MAX_GAIN - rval) * ports[idx].mask) / AUDIO_MAX_GAIN;
	reg |= rval;

	sv_write_indirect(sc, ports[idx].r_port, reg);
      }

      sc->sc_trd = 0;
      sv_read_indirect(sc, ports[idx].l_port);
    }

    return (0);
  }


  switch (cp->dev) {
  case SV_RECORD_SOURCE:
    if (cp->type != AUDIO_MIXER_ENUM)
      return (EINVAL);

    for (idx = 0; idx < ARRAY_SIZE(record_sources); idx++) {
      if (record_sources[idx].idx == cp->un.ord)
	goto found;
    }
    
    return (EINVAL);

  found:
    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);
    reg &= ~SV_REC_SOURCE_MASK;
    reg |= (((cp->un.ord) << SV_REC_SOURCE_SHIFT) & SV_REC_SOURCE_MASK);
    sv_write_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL, reg);

    reg = sv_read_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL);
    reg &= ~SV_REC_SOURCE_MASK;
    reg |= (((cp->un.ord) << SV_REC_SOURCE_SHIFT) & SV_REC_SOURCE_MASK);
    sv_write_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL, reg);
    return (0);

  case SV_RECORD_GAIN:
    {
      int val;

      if (cp->type != AUDIO_MIXER_VALUE)
	return (EINVAL);

      if (cp->un.value.num_channels != 1)
	return (EINVAL);

      val = (cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] * SV_REC_GAIN_MASK) 
	/ AUDIO_MAX_GAIN;

      reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);
      reg &= ~SV_REC_GAIN_MASK;
      reg |= val;
      sv_write_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL, reg);
      
      reg = sv_read_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL);
      reg &= ~SV_REC_GAIN_MASK;
      reg |= val;
      sv_write_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL, reg);

    }

    return (0);

  case SV_MIC_BOOST:
    if (cp->type != AUDIO_MIXER_ENUM)
      return (EINVAL);

    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);
    if (cp->un.ord) {
      reg |= SV_MIC_BOOST_BIT;
    } else {
      reg &= ~SV_MIC_BOOST_BIT;
    }
    
    sv_write_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL, reg);
    return (0);

  case SV_SRS_MODE:
    if (cp->type != AUDIO_MIXER_ENUM)
      return (EINVAL);

    reg = sv_read_indirect(sc, SV_SRS_SPACE_CONTROL);
    if (cp->un.ord) {
      reg &= ~SV_SRS_SPACE_ONOFF;
    } else {
      reg |= SV_SRS_SPACE_ONOFF;
    }
    
    sv_write_indirect(sc, SV_SRS_SPACE_CONTROL, reg);
    return (0);
  }

  return (EINVAL);
}

int
sv_mixer_get_port(void *addr, mixer_ctrl_t *cp)
{
  struct sv_softc *sc = addr;
  int val;
  u_int8_t reg;

  if (cp->dev >= SV_FIRST_MIXER &&
      cp->dev <= SV_LAST_MIXER) {
    int off = cp->dev - SV_FIRST_MIXER;
    int mute = (off % 2);
    int idx = off / 2;

    if (mute) {
      if (cp->type != AUDIO_MIXER_ENUM) 
	return (EINVAL);

      reg = sv_read_indirect(sc, ports[idx].l_port);
      cp->un.ord = ((reg & SV_MUTE_BIT) ? 1 : 0);
    } else {
      if (cp->type != AUDIO_MIXER_VALUE)
	return (EINVAL);

      if (cp->un.value.num_channels != 1 &&
	  cp->un.value.num_channels != 2)
	return (EINVAL);

      if ((ports[idx].r_port == 0 &&
	   cp->un.value.num_channels != 1) ||
	  (ports[idx].r_port != 0 &&
	   cp->un.value.num_channels != 2))
	return (EINVAL);

      reg = sv_read_indirect(sc, ports[idx].l_port);
      reg &= ports[idx].mask;

      val = AUDIO_MAX_GAIN - ((reg * AUDIO_MAX_GAIN) / ports[idx].mask);

      if (ports[idx].r_port != 0) {
	cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = val;

	reg = sv_read_indirect(sc, ports[idx].r_port);
	reg &= ports[idx].mask;
      
	val = AUDIO_MAX_GAIN - ((reg * AUDIO_MAX_GAIN) / ports[idx].mask);
	cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = val;
      } else 
	cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = val;
    }

    return (0);
  }

  switch (cp->dev) {
  case SV_RECORD_SOURCE:
    if (cp->type != AUDIO_MIXER_ENUM)
      return (EINVAL);

    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);
    cp->un.ord = ((reg & SV_REC_SOURCE_MASK) >> SV_REC_SOURCE_SHIFT);

    return (0);

  case SV_RECORD_GAIN:
    if (cp->type != AUDIO_MIXER_VALUE)
      return (EINVAL);

    if (cp->un.value.num_channels != 1)
      return (EINVAL);

    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL) & SV_REC_GAIN_MASK;
    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = 
      (((unsigned int)reg) * AUDIO_MAX_GAIN) / SV_REC_GAIN_MASK;

    return (0);

  case SV_MIC_BOOST:
    if (cp->type != AUDIO_MIXER_ENUM)
      return (EINVAL);

    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);
    cp->un.ord = ((reg & SV_MIC_BOOST_BIT) ? 1 : 0);

    return (0);


  case SV_SRS_MODE:
    if (cp->type != AUDIO_MIXER_ENUM)
      return (EINVAL);

    reg = sv_read_indirect(sc, SV_SRS_SPACE_CONTROL);

    cp->un.ord = ((reg & SV_SRS_SPACE_ONOFF) ? 0 : 1);
    return (0);
  }

  return (EINVAL);
}


static void
sv_init_mixer(struct sv_softc *sc)
{
  mixer_ctrl_t cp;
  int idx;

  cp.type = AUDIO_MIXER_ENUM;
  cp.dev = SV_SRS_MODE;
  cp.un.ord = 0;

  sv_mixer_set_port(sc, &cp);

  for (idx = 0; idx < ARRAY_SIZE(ports); idx++) {
    if (strcmp(ports[idx].audio, AudioNdac) == 0) {
      cp.type = AUDIO_MIXER_ENUM;
      cp.dev = SV_FIRST_MIXER + idx * SV_DEVICES_PER_PORT + 1;
      cp.un.ord = 0;
      sv_mixer_set_port(sc, &cp);
      break;
    }
  }
}

void *
sv_malloc(void *addr, int direction, size_t size, int pool, int flags)
{
	struct sv_softc *sc = addr;
        struct sv_dma *p;
        int error;

        p = malloc(sizeof(*p), pool, flags);
        if (!p)
                return (0);
        error = sv_allocmem(sc, size, 16, p);
        if (error) {
                free(p, pool, 0);
        	return (0);
        }
        p->next = sc->sc_dmas;
        sc->sc_dmas = p;
	return (KERNADDR(p));
}

void
sv_free(void *addr, void *ptr, int pool)
{
	struct sv_softc *sc = addr;
        struct sv_dma **p;

        for (p = &sc->sc_dmas; *p; p = &(*p)->next) {
                if (KERNADDR(*p) == ptr) {
                        sv_freemem(sc, *p);
                        *p = (*p)->next;
                        free(*p, pool, 0);
                        return;
                }
        }
}

int
sv_get_props(void *addr)
{
	return (AUDIO_PROP_MMAP | AUDIO_PROP_FULLDUPLEX);
}
@


1.33
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.31 2014/07/12 18:48:52 tedu Exp $ */
a126 6
struct audio_device sv_device = {
	"S3 SonicVibes",
	"",
	"sv"
};

a141 1
int	sv_getdev(void *, struct audio_device *);
a163 1
	sv_getdev,
a815 8

int
sv_getdev(void *addr, struct audio_device *retp)
{
	*retp = sv_device;
        return (0);
}

@


1.32
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@a139 1
int	sv_query_encoding(void *, struct audio_encoding *);
a153 1
paddr_t	sv_mappage(void *, void *, off_t, int);
a160 2
	NULL,
	sv_query_encoding,
a178 1
	sv_mappage,
a180 1
	NULL,
a572 25
sv_query_encoding(void *addr, struct audio_encoding *fp)
{
	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
        case 1:
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	default:
		return (EINVAL);
	}
	fp->bps = AUDIO_BPS(fp->precision);
	fp->msb = 1;

	return (0);
}

int
a1326 14
}

paddr_t
sv_mappage(void *addr, void *mem, off_t off, int prot)
{
	struct sv_softc *sc = addr;
        struct sv_dma *p;

        for (p = sc->sc_dmas; p && KERNADDR(p) != mem; p = p->next)
		;
	if (!p)
		return (-1);
	return (bus_dmamem_mmap(sc->sc_dmatag, p->segs, p->nsegs, 
				off, prot, BUS_DMA_WAITOK));
@


1.31
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.30 2013/11/15 16:46:27 brad Exp $ */
a50 2
#include <dev/mulaw.h>
#include <dev/auconv.h>
d588 1
a588 19
	case 1:
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 2:
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 3:
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
        case 4:
a593 18
	case 5:
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 6:
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
a607 2
	void (*pswcode)(void *, u_char *buf, int cnt);
	void (*rswcode)(void *, u_char *buf, int cnt);
a610 1
        pswcode = rswcode = 0;
a611 6
        case AUDIO_ENCODING_SLINEAR_BE:
        	if (p->precision == 16)
                	rswcode = pswcode = swap_bytes;
		else
			pswcode = rswcode = change_sign8;
		break;
d614 1
a614 1
			pswcode = rswcode = change_sign8;
a616 5
        	if (p->precision == 16) {
			pswcode = swap_bytes_change_sign16_le;
			rswcode = change_sign16_swap_bytes_le;
		}
		break;
d618 2
a619 2
        	if (p->precision == 16)
			pswcode = rswcode = change_sign16_le;
a620 8
        case AUDIO_ENCODING_ULAW:
        	pswcode = mulaw_to_ulinear8;
                rswcode = ulinear8_to_mulaw;
                break;
        case AUDIO_ENCODING_ALAW:
                pswcode = alaw_to_ulinear8;
                rswcode = ulinear8_to_alaw;
                break;
a637 2
        p->sw_code = pswcode;
        r->sw_code = rswcode;
@


1.30
log
@ansify some function definitions.
no functional change.

ok sthen@@
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.29 2013/05/24 07:58:47 ratchov Exp $ */
d1398 1
a1398 1
                free(p, pool);
d1416 1
a1416 1
                        free(*p, pool);
@


1.29
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.28 2013/05/15 08:29:24 ratchov Exp $ */
d200 1
a200 4
sv_write (sc, reg, val)
     struct sv_softc *sc;
     u_int8_t reg, val;
     
d206 1
a206 4
sv_read (sc, reg)
     struct sv_softc *sc;
     u_int8_t reg;
     
d212 1
a212 3
sv_read_indirect (sc, reg)
     struct sv_softc *sc;
     u_int8_t reg;
d226 1
a226 3
sv_write_indirect (sc, reg, val)
     struct sv_softc *sc;
     u_int8_t reg, val;
d248 1
a248 3
sv_match(parent, match, aux)
     struct device *parent;
     void *match, *aux;
d260 1
a260 4
sv_attach(parent, self, aux)
     struct device *parent, *self;
     void *aux;

d383 1
a383 2
sv_dumpregs(sc)
     struct sv_softc *sc;
d412 1
a412 2
sv_intr(p)
	void *p;
d439 1
a439 5
sv_allocmem(sc, size, align, p)
	struct sv_softc *sc;
	size_t size;
	size_t align;
        struct sv_dma *p;
d476 1
a476 3
sv_freemem(sc, p)
	struct sv_softc *sc;
        struct sv_dma *p;
d486 1
a486 3
sv_open(addr, flags)
	void *addr;
	int flags;
d569 1
a569 2
sv_close(addr)
	void *addr;
d581 1
a581 3
sv_query_encoding(addr, fp)
	void *addr;
	struct audio_encoding *fp;
d642 2
a643 4
sv_set_params(addr, setmode, usemode, p, r)
	void *addr;
	int setmode, usemode;
	struct audio_params *p, *r;
d777 1
a777 3
sv_round_blocksize(addr, blk)
	void *addr;
	int blk;
d783 1
a783 4
sv_dma_init_input(addr, buf, cc)
	void *addr;
	void *buf;
	int cc;
d811 1
a811 4
sv_dma_init_output(addr, buf, cc)
	void *addr;
	void *buf;
	int cc;
d838 1
a838 6
sv_dma_output(addr, p, cc, intr, arg)
	void *addr;
	void *p;
	int cc;
	void (*intr)(void *);
	void *arg;
d863 1
a863 6
sv_dma_input(addr, p, cc, intr, arg)
	void *addr;
	void *p;
	int cc;
	void (*intr)(void *);
	void *arg;
d887 1
a887 2
sv_halt_out_dma(addr)
	void *addr;
d903 1
a903 2
sv_halt_in_dma(addr)
	void *addr;
d919 1
a919 3
sv_getdev(addr, retp)
	void *addr;
        struct audio_device *retp;
d987 1
a987 3
sv_query_devinfo(addr, dip)
	void *addr;
	mixer_devinfo_t *dip;
d1101 1
a1101 3
sv_mixer_set_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d1264 1
a1264 3
sv_mixer_get_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d1364 1
a1364 2
sv_init_mixer(sc)
     struct sv_softc *sc;
d1387 1
a1387 6
sv_malloc(addr, direction, size, pool, flags)
	void *addr;
	int direction;
	size_t size;
	int pool;
	int flags;
d1407 1
a1407 4
sv_free(addr, ptr, pool)
	void *addr;
	void *ptr;
	int pool;
d1423 1
a1423 5
sv_mappage(addr, mem, off, prot)
	void *addr;
        void *mem;
        off_t off;
	int prot;
d1437 1
a1437 2
sv_get_props(addr)
	void *addr;
@


1.28
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.27 2010/07/15 03:43:11 jakemsr Exp $ */
d380 2
a381 2
  sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO, sv_intr, sc,
				 sc->sc_dev.dv_xname);
@


1.27
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.26 2009/06/23 06:39:48 jsg Exp $ */
d434 1
d437 2
a438 1
  if (!(intr & (SV_INTSTATUS_DMAA | SV_INTSTATUS_DMAC))) 
d440 1
d451 1
a451 1

d855 1
a855 1
	DPRINTF(("eap: dma start loop output buf=%p cc=%d\n", buf, cc));
a888 1

d941 2
a942 1
        DPRINTF(("eap: sv_halt_out_dma\n"));
d947 1
a947 1

d958 2
a959 1
        DPRINTF(("eap: sv_halt_in_dma\n"));
d964 1
a964 1

@


1.26
log
@Don't use == for string comparison.

"looks good to me" jakemsr@@
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.25 2008/10/25 22:30:43 jakemsr Exp $ */
d614 1
a614 1
		return (0);
d620 1
a620 1
		return (0);
d626 1
a626 1
		return (0);
d632 1
a632 1
		return (0);
d638 1
a638 1
		return (0);
d644 1
a644 1
		return (0);
d650 1
a650 1
		return (0);
d656 1
a656 1
		return (0);
d660 4
d727 3
@


1.25
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.24 2008/04/21 00:32:43 jakemsr Exp $ */
d1424 1
a1424 1
    if (ports[idx].audio == AudioNdac) {
@


1.24
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.23 2008/01/14 01:23:53 jakemsr Exp $ */
d712 2
d716 4
a719 4
	else if (p->channels != 1)
		return (EINVAL);
        if (p->sample_rate < 2000 || p->sample_rate > 48000)
        	return (EINVAL);
@


1.23
log
@protect against an invalid device index possibly leading to kernel
crash.  inspired by deanna's similar bug fix in ac97.

ok ratchov
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.22 2007/11/05 00:17:28 jakemsr Exp $ */
d187 1
@


1.22
log
@audio encoding conversion cleanup

- the endianness of the conversions don't depend on the endianness
  of machine the conversions are built on, but the endianness of the
  audio data itself.  choose encoding conversions explicitly, instead
  of relying on #defines based on the endianness of the machine.
- replace home-grown conversions with comparable conversions in
  auconv.c and mulaw.c
- use the proper conversion for ulinear_be:16 -> slinear_le:16 in
  auixp(4)

thanks ajacoutot@@ and sthen@@ for !x86 testing
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.21 2005/09/11 18:17:08 mickey Exp $ */
d1029 3
@


1.21
log
@do not inline pci_mapreg_map() anymore as it is olrite now; brad@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.20 2005/08/09 04:10:13 mickey Exp $ */
d687 2
a688 2
			pswcode = swap_bytes_change_sign16;
			rswcode = change_sign16_swap_bytes;
d693 1
a693 1
			pswcode = rswcode = change_sign16;
@


1.20
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.19 2005/07/16 17:20:47 brad Exp $ */
a279 1
  bus_addr_t iobase;
d289 3
a291 3
  if (pci_io_find(pc, pa->pa_tag, SV_ENHANCED_PORTBASE_SLOT, 
		  &iobase, &iosize)) {
    printf (": Couldn't find enhanced synth I/O range\n");
a292 5
  }

  if (bus_space_map(sc->sc_iot, iobase, iosize, 0, &sc->sc_ioh)) {
      printf(": can't map i/o space\n");
      return;
@


1.19
log
@remove __BROKEN_INDIRECT_CONFIG cruft
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.18 2005/04/16 21:57:23 mickey Exp $ */
a281 1
  pcireg_t csr;
a345 5
  csr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
  pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
		 csr | PCI_COMMAND_MASTER_ENABLE 
		 /* | PCI_COMMAND_IO_ENABLE | PCI_COMMAND_PARITY_ENABLE */);

@


1.18
log
@do not provide round_buffer if not needed unless explained why in comments
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.17 2005/04/14 12:42:16 mickey Exp $ */
a74 2
#define __BROKEN_INDIRECT_CONFIG
#ifdef __BROKEN_INDIRECT_CONFIG
a75 3
#else
int	sv_match(struct device *, struct cfdata *, void *);
#endif
@


1.17
log
@make sure round_blocksize does not produce 0 after alignment
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.16 2003/04/27 11:22:54 ho Exp $ */
a161 1
size_t	sv_round(void *, int, size_t);
d189 1
a189 1
	sv_round,
a1486 9
}

size_t
sv_round(addr, direction, size)
	void *addr;
	int direction;
	size_t size;
{
	return (size);
@


1.16
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.15 2003/02/11 19:20:28 mickey Exp $ */
d816 1
a816 1
	return (blk & -32);	/* keep good alignment */
@


1.15
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.14 2002/06/11 06:04:17 nordin Exp $ */
d627 1
a627 1
		strcpy(fp->name, AudioEulinear);
d633 1
a633 1
		strcpy(fp->name, AudioEmulaw);
d639 1
a639 1
		strcpy(fp->name, AudioEalaw);
d645 1
a645 1
		strcpy(fp->name, AudioEslinear);
d651 1
a651 1
		strcpy(fp->name, AudioEslinear_le);
d657 1
a657 1
		strcpy(fp->name, AudioEulinear_le);
d663 1
a663 1
		strcpy(fp->name, AudioEslinear_be);
d669 1
a669 1
		strcpy(fp->name, AudioEulinear_be);
d1053 2
a1054 2
    strcpy(dip->label.name, 
	   mixer_classes[dip->index]);
d1065 1
a1065 1
    strcpy(dip->label.name, ports[idx].audio);
d1077 2
a1078 2
      strcpy(dip->un.v.units.name, AudioNvolume);
		
d1084 1
a1084 1
      strcpy(dip->label.name, AudioNmute);
d1086 2
a1087 1
      strcpy(dip->un.e.member[0].label.name, AudioNoff);
d1089 2
a1090 1
      strcpy(dip->un.e.member[1].label.name, AudioNon);
d1103 1
a1103 1
    strcpy(dip->label.name, AudioNsource);
d1111 2
a1112 1
	strcpy(dip->un.e.member[idx].label.name, record_sources[idx].name);
d1122 1
a1122 1
    strcpy(dip->label.name, "gain");
d1125 1
a1125 1
    strcpy(dip->un.v.units.name, AudioNvolume);
d1132 1
a1132 1
    strcpy(dip->label.name, "micboost");
d1138 1
a1138 1
    strcpy(dip->label.name, AudioNspatial);
d1143 2
a1144 1
    strcpy(dip->un.e.member[0].label.name, AudioNoff);
d1146 2
a1147 1
    strcpy(dip->un.e.member[1].label.name, AudioNon);
@


1.14
log
@abs() is defined by ANSI C -- don't use a macro for it. ok niklas@@
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.13 2002/03/14 03:16:06 millert Exp $ */
d764 1
a764 1
	     80 MhZ < (m + 2) / (n + 2) * f_ref <= 150Mhz
@


1.13
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.12 2002/03/14 01:27:00 millert Exp $ */
a752 2
#define ABS(x) (((x) < 0) ? (-x) : (x))

d791 1
a791 1
	    error = ABS(error);
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.11 2002/01/20 19:56:53 ericj Exp $ */
d152 2
a153 2
int	sv_dma_output __P((void *, void *, int, void (*)(void *), void*));
int	sv_dma_input __P((void *, void *, int, void (*)(void *), void*));
@


1.11
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.10 2001/10/31 11:00:24 art Exp $ */
d77 1
a77 1
int	sv_match __P((struct device *, void *, void *));
d79 1
a79 1
int	sv_match __P((struct device *, struct cfdata *, void *));
d81 2
a82 2
static void	sv_attach __P((struct device *, struct device *, void *));
int	sv_intr __P((void *));
d142 2
a143 2
int	sv_allocmem __P((struct sv_softc *, size_t, size_t, struct sv_dma *));
int	sv_freemem __P((struct sv_softc *, struct sv_dma *));
d145 7
a151 7
int	sv_open __P((void *, int));
void	sv_close __P((void *));
int	sv_query_encoding __P((void *, struct audio_encoding *));
int	sv_set_params __P((void *, int, int, struct audio_params *, struct audio_params *));
int	sv_round_blocksize __P((void *, int));
int	sv_dma_init_output __P((void *, void *, int));
int	sv_dma_init_input __P((void *, void *, int));
d154 11
a164 11
int	sv_halt_in_dma __P((void *));
int	sv_halt_out_dma __P((void *));
int	sv_getdev __P((void *, struct audio_device *));
int	sv_mixer_set_port __P((void *, mixer_ctrl_t *));
int	sv_mixer_get_port __P((void *, mixer_ctrl_t *));
int	sv_query_devinfo __P((void *, mixer_devinfo_t *));
void   *sv_malloc __P((void *, int, size_t, int, int));
void	sv_free __P((void *, void *, int));
size_t	sv_round __P((void *, int, size_t));
paddr_t	sv_mappage __P((void *, void *, off_t, int));
int	sv_get_props __P((void *));
d166 1
a166 1
void    sv_dumpregs __P((struct sv_softc *sc));
d198 5
a202 5
static __inline__ u_int8_t sv_read __P((struct sv_softc *, u_int8_t));
static __inline__ u_int8_t sv_read_indirect __P((struct sv_softc *, u_int8_t));
static __inline__ void sv_write __P((struct sv_softc *, u_int8_t, u_int8_t ));
static __inline__ void sv_write_indirect __P((struct sv_softc *, u_int8_t, u_int8_t ));
static void sv_init_mixer __P((struct sv_softc *));
d686 2
a687 2
	void (*pswcode) __P((void *, u_char *buf, int cnt));
	void (*rswcode) __P((void *, u_char *buf, int cnt));
d887 1
a887 1
	void (*intr) __P((void *));
d918 1
a918 1
	void (*intr) __P((void *));
@


1.10
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.9 2001/08/25 10:13:30 art Exp $ */
d160 1
a160 1
void   *sv_malloc __P((void *, u_long, int, int));
d162 1
a162 1
u_long	sv_round __P((void *, u_long));
d1444 1
a1444 1
sv_malloc(addr, size, pool, flags)
d1446 2
a1447 1
	u_long size;
d1487 2
a1488 2
u_long
sv_round(addr, size)
d1490 2
a1491 1
	u_long size;
@


1.10.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.11 2002/01/20 19:56:53 ericj Exp $ */
d160 1
a160 1
void   *sv_malloc __P((void *, int, size_t, int, int));
d162 1
a162 1
size_t	sv_round __P((void *, int, size_t));
d1444 1
a1444 1
sv_malloc(addr, direction, size, pool, flags)
d1446 1
a1446 2
	int direction;
	size_t size;
d1486 2
a1487 2
size_t
sv_round(addr, direction, size)
d1489 1
a1489 2
	int direction;
	size_t size;
@


1.10.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.10.2.1 2002/01/31 22:55:36 niklas Exp $ */
d77 1
a77 1
int	sv_match(struct device *, void *, void *);
d79 1
a79 1
int	sv_match(struct device *, struct cfdata *, void *);
d81 2
a82 2
static void	sv_attach(struct device *, struct device *, void *);
int	sv_intr(void *);
d142 2
a143 2
int	sv_allocmem(struct sv_softc *, size_t, size_t, struct sv_dma *);
int	sv_freemem(struct sv_softc *, struct sv_dma *);
d145 20
a164 20
int	sv_open(void *, int);
void	sv_close(void *);
int	sv_query_encoding(void *, struct audio_encoding *);
int	sv_set_params(void *, int, int, struct audio_params *, struct audio_params *);
int	sv_round_blocksize(void *, int);
int	sv_dma_init_output(void *, void *, int);
int	sv_dma_init_input(void *, void *, int);
int	sv_dma_output(void *, void *, int, void (*)(void *), void *);
int	sv_dma_input(void *, void *, int, void (*)(void *), void *);
int	sv_halt_in_dma(void *);
int	sv_halt_out_dma(void *);
int	sv_getdev(void *, struct audio_device *);
int	sv_mixer_set_port(void *, mixer_ctrl_t *);
int	sv_mixer_get_port(void *, mixer_ctrl_t *);
int	sv_query_devinfo(void *, mixer_devinfo_t *);
void   *sv_malloc(void *, int, size_t, int, int);
void	sv_free(void *, void *, int);
size_t	sv_round(void *, int, size_t);
paddr_t	sv_mappage(void *, void *, off_t, int);
int	sv_get_props(void *);
d166 1
a166 1
void    sv_dumpregs(struct sv_softc *sc);
d198 5
a202 5
static __inline__ u_int8_t sv_read(struct sv_softc *, u_int8_t);
static __inline__ u_int8_t sv_read_indirect(struct sv_softc *, u_int8_t);
static __inline__ void sv_write(struct sv_softc *, u_int8_t, u_int8_t );
static __inline__ void sv_write_indirect(struct sv_softc *, u_int8_t, u_int8_t );
static void sv_init_mixer(struct sv_softc *);
d686 2
a687 2
	void (*pswcode)(void *, u_char *buf, int cnt);
	void (*rswcode)(void *, u_char *buf, int cnt);
d887 1
a887 1
	void (*intr)(void *);
d918 1
a918 1
	void (*intr)(void *);
@


1.10.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.10.2.2 2002/06/11 03:42:27 art Exp $ */
d753 2
d793 1
a793 1
	    error = abs(error);
@


1.10.2.4
log
@sync
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
d627 1
a627 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d633 1
a633 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d639 1
a639 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d645 1
a645 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d651 1
a651 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d657 1
a657 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d663 1
a663 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d669 1
a669 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d764 1
a764 1
	     80 MhZ < (m + 2) / (n + 2) * f_ref <= 150MHz
d1053 2
a1054 2
    strlcpy(dip->label.name, mixer_classes[dip->index],
	    sizeof dip->label.name);
d1065 1
a1065 1
    strlcpy(dip->label.name, ports[idx].audio, sizeof dip->label.name);
d1077 2
a1078 2
      strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);

d1084 1
a1084 1
      strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d1086 1
a1086 2
      strlcpy(dip->un.e.member[0].label.name, AudioNoff,
	  sizeof dip->un.e.member[0].label.name);
d1088 1
a1088 2
      strlcpy(dip->un.e.member[1].label.name, AudioNon,
	  sizeof dip->un.e.member[1].label.name);
d1101 1
a1101 1
    strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d1109 1
a1109 2
	strlcpy(dip->un.e.member[idx].label.name, record_sources[idx].name,
	    sizeof dip->un.e.member[idx].label.name);
d1119 1
a1119 1
    strlcpy(dip->label.name, "gain", sizeof dip->label.name);
d1122 1
a1122 1
    strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d1129 1
a1129 1
    strlcpy(dip->label.name, "micboost", sizeof dip->label.name);
d1135 1
a1135 1
    strlcpy(dip->label.name, AudioNspatial, sizeof dip->label.name);
d1140 1
a1140 2
    strlcpy(dip->un.e.member[0].label.name, AudioNoff,
	sizeof dip->un.e.member[0].label.name);
d1142 1
a1142 2
    strlcpy(dip->un.e.member[1].label.name, AudioNon,
	sizeof dip->un.e.member[1].label.name);
@


1.9
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.8 2000/04/03 21:13:48 deraadt Exp $ */
d163 1
a163 1
int	sv_mappage __P((void *, void *, int, int));
d1494 1
a1494 1
int
d1498 1
a1498 1
        int off;
@


1.8
log
@fix dmesg output
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.7 1999/08/04 23:27:49 niklas Exp $ */
d392 1
a392 2
  if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
		   pa->pa_intrline, &ih)) {
@


1.7
log
@new bus_dma API, match it
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.6 1999/01/02 00:02:49 niklas Exp $ */
a292 2
  printf ("\n");

d299 1
a299 1
    printf ("%s: Couldn't find enhanced synth I/O range\n", sc->sc_dev.dv_xname);
d304 1
a304 1
      printf("%s: can't map i/o space\n", sc->sc_dev.dv_xname);
d322 1
a322 1
      printf ("%s: can't map DMA i/o space\n", sc->sc_dev.dv_xname);
d342 1
a342 1
      printf ("%s: can't map DMA i/o space\n", sc->sc_dev.dv_xname);
d394 1
a394 1
    printf("%s: couldn't map interrupt\n", sc->sc_dev.dv_xname);
d401 1
a401 2
    printf("%s: couldn't establish interrupt",
	   sc->sc_dev.dv_xname);
d407 1
a407 1
  printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname, intrstr);
@


1.7.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.8 2000/04/03 21:13:48 deraadt Exp $ */
d293 2
d301 1
a301 1
    printf (": Couldn't find enhanced synth I/O range\n");
d306 1
a306 1
      printf(": can't map i/o space\n");
d324 1
a324 1
      printf (": can't map DMA i/o space\n");
d344 1
a344 1
      printf (": can't map DMA i/o space\n");
d396 1
a396 1
    printf(": couldn't map interrupt\n");
d403 2
a404 1
    printf(": couldn't establish interrupt");
d410 1
a410 1
  printf(": %s\n", intrstr);
@


1.7.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.7.4.1 2001/05/14 22:25:57 niklas Exp $ */
d392 2
a393 1
  if (pci_intr_map(pa, &ih)) {
@


1.7.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
d163 1
a163 1
paddr_t	sv_mappage __P((void *, void *, off_t, int));
d1494 1
a1494 1
paddr_t
d1498 1
a1498 1
        off_t off;
@


1.7.4.4
log
@Merge in trunk
@
text
@d160 1
a160 1
void   *sv_malloc __P((void *, int, size_t, int, int));
d162 1
a162 1
size_t	sv_round __P((void *, int, size_t));
d1444 1
a1444 1
sv_malloc(addr, direction, size, pool, flags)
d1446 1
a1446 2
	int direction;
	size_t size;
d1486 2
a1487 2
size_t
sv_round(addr, direction, size)
d1489 1
a1489 2
	int direction;
	size_t size;
@


1.7.4.5
log
@Merge in -current from roughly a week ago
@
text
@d77 1
a77 1
int	sv_match(struct device *, void *, void *);
d79 1
a79 1
int	sv_match(struct device *, struct cfdata *, void *);
d81 2
a82 2
static void	sv_attach(struct device *, struct device *, void *);
int	sv_intr(void *);
d142 2
a143 2
int	sv_allocmem(struct sv_softc *, size_t, size_t, struct sv_dma *);
int	sv_freemem(struct sv_softc *, struct sv_dma *);
d145 20
a164 20
int	sv_open(void *, int);
void	sv_close(void *);
int	sv_query_encoding(void *, struct audio_encoding *);
int	sv_set_params(void *, int, int, struct audio_params *, struct audio_params *);
int	sv_round_blocksize(void *, int);
int	sv_dma_init_output(void *, void *, int);
int	sv_dma_init_input(void *, void *, int);
int	sv_dma_output(void *, void *, int, void (*)(void *), void *);
int	sv_dma_input(void *, void *, int, void (*)(void *), void *);
int	sv_halt_in_dma(void *);
int	sv_halt_out_dma(void *);
int	sv_getdev(void *, struct audio_device *);
int	sv_mixer_set_port(void *, mixer_ctrl_t *);
int	sv_mixer_get_port(void *, mixer_ctrl_t *);
int	sv_query_devinfo(void *, mixer_devinfo_t *);
void   *sv_malloc(void *, int, size_t, int, int);
void	sv_free(void *, void *, int);
size_t	sv_round(void *, int, size_t);
paddr_t	sv_mappage(void *, void *, off_t, int);
int	sv_get_props(void *);
d166 1
a166 1
void    sv_dumpregs(struct sv_softc *sc);
d198 5
a202 5
static __inline__ u_int8_t sv_read(struct sv_softc *, u_int8_t);
static __inline__ u_int8_t sv_read_indirect(struct sv_softc *, u_int8_t);
static __inline__ void sv_write(struct sv_softc *, u_int8_t, u_int8_t );
static __inline__ void sv_write_indirect(struct sv_softc *, u_int8_t, u_int8_t );
static void sv_init_mixer(struct sv_softc *);
d686 2
a687 2
	void (*pswcode)(void *, u_char *buf, int cnt);
	void (*rswcode)(void *, u_char *buf, int cnt);
d887 1
a887 1
	void (*intr)(void *);
d918 1
a918 1
	void (*intr)(void *);
@


1.7.4.6
log
@Sync the SMP branch with 3.3
@
text
@d753 2
d766 1
a766 1
	     80 MhZ < (m + 2) / (n + 2) * f_ref <= 150MHz
d793 1
a793 1
	    error = abs(error);
@


1.7.4.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.7.4.6 2003/03/28 00:38:25 niklas Exp $ */
d627 1
a627 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d633 1
a633 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d639 1
a639 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d645 1
a645 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d651 1
a651 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d657 1
a657 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d663 1
a663 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d669 1
a669 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d1053 2
a1054 2
    strlcpy(dip->label.name, mixer_classes[dip->index],
	    sizeof dip->label.name);
d1065 1
a1065 1
    strlcpy(dip->label.name, ports[idx].audio, sizeof dip->label.name);
d1077 2
a1078 2
      strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);

d1084 1
a1084 1
      strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d1086 1
a1086 2
      strlcpy(dip->un.e.member[0].label.name, AudioNoff,
	  sizeof dip->un.e.member[0].label.name);
d1088 1
a1088 2
      strlcpy(dip->un.e.member[1].label.name, AudioNon,
	  sizeof dip->un.e.member[1].label.name);
d1101 1
a1101 1
    strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d1109 1
a1109 2
	strlcpy(dip->un.e.member[idx].label.name, record_sources[idx].name,
	    sizeof dip->un.e.member[idx].label.name);
d1119 1
a1119 1
    strlcpy(dip->label.name, "gain", sizeof dip->label.name);
d1122 1
a1122 1
    strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d1129 1
a1129 1
    strlcpy(dip->label.name, "micboost", sizeof dip->label.name);
d1135 1
a1135 1
    strlcpy(dip->label.name, AudioNspatial, sizeof dip->label.name);
d1140 1
a1140 2
    strlcpy(dip->un.e.member[0].label.name, AudioNoff,
	sizeof dip->un.e.member[0].label.name);
d1142 1
a1142 2
    strlcpy(dip->un.e.member[1].label.name, AudioNon,
	sizeof dip->un.e.member[1].label.name);
@


1.6
log
@Midi & sequencer support from NetBSD, mostly by Lennart Augustsson
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.5 1998/11/03 21:05:07 downsj Exp $ */
d60 1
a60 3
/* NetBSD 1.3 backwards compatibility */
#ifndef BUS_DMA_COHERENT
#define BUS_DMA_COHERENT 0	/* XXX */
d65 1
@


1.5
log
@Update audio_hw_if.
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.4 1998/10/05 20:47:45 niklas Exp $ */
d415 1
a415 1
  audio_attach_mi(&sv_hw_if, 0, sc, &sc->sc_dev);
@


1.4
log
@make compile with AUDIO_DEBUG defined
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.3 1998/07/13 13:53:16 csapuntz Exp $ */
d194 2
@


1.3
log
@

Unmute DAC and turn off 3-D SRS by default
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.2 1998/07/13 01:50:15 csapuntz Exp $ */
d425 2
a426 1
    printf ("%02x = %x\n", idx, pci_conf_read(pa->pa_pc, pa->pa_tag, idx));
@


1.2
log
@

Map DMA registers at open instead of attach time, if necessary. Less chance
of conflicts then.
@
text
@d1 1
a1 1
/*      $OpenBSD: sv.c,v 1.1 1998/07/07 22:44:10 csapuntz Exp $ */
d201 1
d411 2
d1038 1
d1040 1
a1040 1
#define SV_LAST_MIXER 2 * (ARRAY_SIZE(ports)) + SV_LAST_CLASS
d1065 2
a1066 2
    int mute = (off % 2);
    int idx = off / 2;
d1166 2
a1167 3
    int mute = (off % 2);
    
    idx = off / 2;
d1420 24
@


1.1
log
@

S3 SonicVibes driver
@
text
@d1 1
a1 1
/*      $OpenBSD: $ */
d96 7
d106 6
a111 2
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d124 1
a124 1
        char    trd;
d126 2
a127 2
        
	u_int	sc_record_source;	/* recording source mask */
d208 1
a208 1
  bus_space_write_1(sc->iot, sc->ioh, reg, val);
d217 1
a217 1
  return (bus_space_read_1(sc->iot, sc->ioh, reg));
d227 1
a227 1
    if (sc->trd > 0)
d252 1
a252 1
    if (sc->trd > 0)
d293 3
d303 1
a303 1
  if (bus_space_map(sc->iot, iobase, iosize, 0, &sc->ioh)) {
a309 1
  /* Map the DMA channels */
d313 8
d322 3
a324 2
  if (!dmaio)
    dmaio = 0xac00;
d326 4
a329 4
  if (bus_space_map(sc->iot, dmaio, iosize, 0, &sc->sc_dmaa_ioh)) {
    printf ("%s: can't map DMA i/o space\n", sc->sc_dev.dv_xname);
    /* XXX - cleanup */
    return;
a331 5
  dmareg &= 0xF;
  pci_conf_write(pa->pa_pc, pa->pa_tag, SV_DMAA_CONFIG_OFF,
		 dmaio | dmareg | 
		 SV_DMA_CHANNEL_ENABLE | SV_DMAA_EXTENDED_ADDR);

d334 2
a335 2
  if (!dmaio)
    dmaio = 0xac00 + iosize;
d337 8
a344 2
  if (bus_space_map(sc->iot, dmaio, iosize, 0, &sc->sc_dmac_ioh)) {
    printf ("%s: can't map DMA i/o space\n", sc->sc_dev.dv_xname);
d346 3
a348 2
    /* XXXX - cleanup */
    return;
a350 4
  dmareg &= 0xF;
  pci_conf_write(pa->pa_pc, pa->pa_tag, SV_DMAC_CONFIG_OFF, 
		 dmaio | dmareg | SV_DMA_CHANNEL_ENABLE);
  
d352 1
d383 1
a383 1
  reg |= SV_INTMASK_SINT | SV_INTMASK_UD | SV_INTMASK_SINT;
d388 1
a388 1
  sc->trd = 0;
d436 1
a436 1
	    bus_space_read_1(sc->iot, sc->sc_dmaa_ioh, idx));
a525 1
	struct sv_softc *sc = addr;
d527 72
a598 2
        sc->sc_pintr = 0;
        sc->sc_rintr = 0;
d600 1
a600 1
        return (0);
d841 1
a841 1
	bus_space_write_4(sc->iot, sc->sc_dmac_ioh, SV_DMA_ADDR0,
d843 1
a843 1
	bus_space_write_4(sc->iot, sc->sc_dmac_ioh, SV_DMA_COUNT0,
d845 1
a845 1
	bus_space_write_1(sc->iot, sc->sc_dmac_ioh, SV_DMA_MODE,
d871 1
a871 1
	bus_space_write_4(sc->iot, sc->sc_dmaa_ioh, SV_DMA_ADDR0,
d873 1
a873 1
	bus_space_write_4(sc->iot, sc->sc_dmaa_ioh, SV_DMA_COUNT0,
d875 1
a875 1
	bus_space_write_1(sc->iot, sc->sc_dmaa_ioh, SV_DMA_MODE,
d1207 1
a1207 1
      sc->trd = 1;
d1225 1
a1225 1
      sc->trd = 0;
@

