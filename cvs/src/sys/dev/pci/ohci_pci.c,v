head	1.40;
access;
symbols
	OPENBSD_6_2_BASE:1.40
	OPENBSD_6_1:1.40.0.14
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.40.0.12
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.8
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.6
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.39.0.6
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.2
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.38.0.10
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.8
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.6
	OPENBSD_5_0:1.38.0.4
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.2
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.33.0.6
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.8
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.4
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.32.0.4
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.29.0.4
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.17
	UBC:1.14.0.4
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.40
date	2014.05.16.18.17.03;	author mpi;	state Exp;
branches;
next	1.39;

1.39
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.38;

1.38
date	2010.12.14.16.13.16;	author jakemsr;	state Exp;
branches;
next	1.37;

1.37
date	2010.10.20.20.34.19;	author mk;	state Exp;
branches;
next	1.36;

1.36
date	2010.09.07.16.21.45;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2010.08.30.21.30.15;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.32;

1.32
date	2007.03.22.05.53.36;	author pascoe;	state Exp;
branches;
next	1.31;

1.31
date	2007.03.18.20.14.51;	author mglocker;	state Exp;
branches;
next	1.30;

1.30
date	2007.03.18.06.08.24;	author pascoe;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.22.16.09.21;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2006.05.22.15.52.48;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.30.03.43.04;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2005.08.09.04.10.13;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.21.12.30.02;	author pascoe;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.11.08.09.32;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.30.14.02.03;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.31.04.22.32;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.24.22.52.52;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.23.03.23.00;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.11.02.21.28;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.08.13.19.08;	author nate;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.08.14.53.00;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.07.22.26.33;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.15.20.57.33;	author drahn;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2001.08.25.10.13.30;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.13.07.43.35;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.12.19.11.59;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.12.15.40.32;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.22.22.43.44;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.21.02.42.49;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.04.13.21.59;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	99.11.07.21.30.18;	author fgsch;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.09.27.18.07.58;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	99.08.23.21.54.39;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	99.08.13.08.55.57;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.08.09.26;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.05.32.29;	author fgsch;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.14.22.25.51;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.07.04.10.42.43;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2002.03.28.15.35.58;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2003.03.28.00.38.23;	author niklas;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2004.02.19.10.56.28;	author niklas;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2004.06.05.23.12.52;	author niklas;	state Exp;
branches;
next	;

1.14.4.1
date	2002.06.11.03.42.26;	author art;	state Exp;
branches;
next	;


desc
@@


1.40
log
@There is no need to remember which usb(4) device is the child of an USB
host controller because autoconf(9) already does it.
@
text
@/*	$OpenBSD: ohci_pci.c,v 1.39 2013/04/15 09:23:01 mglocker Exp $	*/
/*	$NetBSD: ohci_pci.c,v 1.23 2002/10/02 16:51:47 thorpej Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * USB Open Host Controller driver.
 *
 * OHCI spec: http://www.intel.com/design/usb/ohci11d.pdf
 * USB spec: http://www.teleport.com/cgi-bin/mailmerge.cgi/~usb/cgiform.tpl
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/queue.h>

#include <machine/bus.h>

#include <dev/pci/pcivar.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usb_mem.h>

#include <dev/usb/ohcireg.h>
#include <dev/usb/ohcivar.h>

int	ohci_pci_match(struct device *, void *, void *);
void	ohci_pci_attach(struct device *, struct device *, void *);
void	ohci_pci_attach_deferred(struct device *);
int	ohci_pci_detach(struct device *, int);

struct ohci_pci_softc {
	struct ohci_softc	sc;
	pci_chipset_tag_t	sc_pc;
	void 			*sc_ih;		/* interrupt vectoring */
};

struct cfattach ohci_pci_ca = {
	sizeof(struct ohci_pci_softc), ohci_pci_match, ohci_pci_attach,
	ohci_pci_detach, ohci_activate
};

int
ohci_pci_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = (struct pci_attach_args *) aux;

	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_SERIALBUS &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_SERIALBUS_USB &&
	    PCI_INTERFACE(pa->pa_class) == PCI_INTERFACE_OHCI)
		return (1);
 
	return (0);
}

void
ohci_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct ohci_pci_softc *sc = (struct ohci_pci_softc *)self;
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	char const *intrstr;
	pci_intr_handle_t ih;
	int s;
	const char *vendor;
	char *devname = sc->sc.sc_bus.bdev.dv_xname;

	/* Map I/O registers */
	if (pci_mapreg_map(pa, PCI_CBMEM, PCI_MAPREG_TYPE_MEM, 0,
		    &sc->sc.iot, &sc->sc.ioh, NULL, &sc->sc.sc_size, 0)) {
		printf(": can't map mem space\n");
		return;
	}

	/* Record what interrupts were enabled by SMM/BIOS. */
	sc->sc.sc_intre = bus_space_read_4(sc->sc.iot, sc->sc.ioh,
	    OHCI_INTERRUPT_ENABLE);

	/* Disable interrupts, so we don't get any spurious ones. */
	bus_space_write_4(sc->sc.iot, sc->sc.ioh, OHCI_INTERRUPT_DISABLE,
			  OHCI_MIE);

	sc->sc_pc = pc;
	sc->sc.sc_bus.dmatag = pa->pa_dmat;

	bus_space_barrier(sc->sc.iot, sc->sc.ioh, 0, sc->sc.sc_size,
	    BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE);
	bus_space_write_4(sc->sc.iot, sc->sc.ioh,
	    OHCI_INTERRUPT_DISABLE, OHCI_MIE);

	s = splusb();
	/* Map and establish the interrupt. */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
		splx(s);
		return;
	}

	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_USB, ohci_intr, sc, devname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
		splx(s);
		return;
	}
	printf(": %s", intrstr);

	/* Figure out vendor for root hub descriptor. */
	vendor = pci_findvendor(pa->pa_id);
	sc->sc.sc_id_vendor = PCI_VENDOR(pa->pa_id);
	if (vendor)
		strlcpy(sc->sc.sc_vendor, vendor, sizeof (sc->sc.sc_vendor));
	else
		snprintf(sc->sc.sc_vendor, sizeof (sc->sc.sc_vendor),
		    "vendor 0x%04x", PCI_VENDOR(pa->pa_id));

	/* Display revision and perform legacy emulation handover. */
	if (ohci_checkrev(&sc->sc) != USBD_NORMAL_COMPLETION ||
	    ohci_handover(&sc->sc) != USBD_NORMAL_COMPLETION) {
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
		pci_intr_disestablish(sc->sc_pc, sc->sc_ih);
		splx(s);
		return;
	}

	/* Ignore interrupts for now */
	sc->sc.sc_bus.dying = 1;

	config_defer(self, ohci_pci_attach_deferred);

	splx(s);

	return;
}

void
ohci_pci_attach_deferred(struct device *self)
{
	struct ohci_pci_softc *sc = (struct ohci_pci_softc *)self;
	usbd_status r;
	int s;

	s = splusb();

	sc->sc.sc_bus.dying = 0;
	
	r = ohci_init(&sc->sc);
	if (r != USBD_NORMAL_COMPLETION) {
		printf("%s: init failed, error=%d\n",
		    sc->sc.sc_bus.bdev.dv_xname, r);
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
		pci_intr_disestablish(sc->sc_pc, sc->sc_ih);
		splx(s);
		return;
	}
	splx(s);

	/* Attach usb device. */
	config_found(self, &sc->sc.sc_bus, usbctlprint);
}

int
ohci_pci_detach(struct device *self, int flags)
{
	struct ohci_pci_softc *sc = (struct ohci_pci_softc *)self;
	int rv;

	rv = ohci_detach(self, flags);
	if (rv)
		return (rv);

	if (sc->sc_ih != NULL) {
		pci_intr_disestablish(sc->sc_pc, sc->sc_ih);
		sc->sc_ih = NULL;
	}
	if (sc->sc.sc_size) {
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
		sc->sc.sc_size = 0;
	}
	return (0);
}
@


1.39
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.38 2010/12/14 16:13:16 jakemsr Exp $	*/
d197 1
a197 2
	sc->sc.sc_child = config_found((void *)sc, &sc->sc.sc_bus,
				       usbctlprint);
d206 1
a206 1
	rv = ohci_detach(&sc->sc, flags);
@


1.38
log
@use the dying flag in struct usbd_bus instead of a private dying flag
in *hci_softc

ok miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.37 2010/10/20 20:34:19 mk Exp $	*/
d66 1
a66 1
	ohci_softc_t		sc;
@


1.37
log
@Disestablish interrupts if attachment fails.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.36 2010/09/07 16:21:45 deraadt Exp $	*/
d165 1
a165 1
	sc->sc.sc_dying = 1;
d183 1
a183 1
	sc->sc.sc_dying = 0;
@


1.36
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.35 2010/08/30 21:30:15 deraadt Exp $	*/
d159 1
d190 1
@


1.35
log
@Change powerhooks into activate functions, and provide stub powerhook
functions
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.34 2010/04/08 00:23:53 tedu Exp $	*/
a191 6

	sc->sc.sc_powerhook = powerhook_establish(ohci_powerhook, &sc->sc);
	if (sc->sc.sc_powerhook == NULL)
		printf("%s: unable to establish powerhook\n",
		    sc->sc.sc_bus.bdev.dv_xname);

a207 3

	if (sc->sc.sc_powerhook != NULL)
		powerhook_disestablish(sc->sc.sc_powerhook);
@


1.34
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.33 2008/06/26 05:42:17 ray Exp $	*/
d193 1
a193 1
	sc->sc.sc_powerhook = powerhook_establish(ohci_power, &sc->sc);
@


1.33
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.32 2007/03/22 05:53:36 pascoe Exp $	*/
d45 1
a45 1
#include <sys/proc.h>
@


1.32
log
@Perform legacy emulation handover for USB1 companion controllers immediately
but defer the remainder of their initialisation until after the other devices
on their PCI bus have attached.  This ensures that any USB2 controller has also
completed its initialisation before we start to initialise the USB1 parts.

This minimises the chance that a nasty SMM implementation will trash the USB1
controller's config when it performs legacy emulation handover of the USB2 part.

This time without accidentally leaving the OHCI controller shutdown, and with
some cosmetic fixes.

ok dlg@@, OHCI tests mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.31 2007/03/18 20:14:51 mglocker Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.31
log
@Backout pascoe@@'s last USB change because it page faults at attachment
time.

Chris; Get your shiz fixed and tested for the next time.  We have
better todo then wasting our time by backing out untested stuff.

OK deraadt, OK ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.29 2006/05/22 16:09:21 dlg Exp $	*/
d69 1
a103 1
	usbd_status r;
d161 29
@


1.30
log
@Perform legacy emulation handover for USB1 companion controllers immediately
but defer the remainder of their initialisation until after the other devices
on their PCI bus have attached.  This ensures that any USB2 controller has also
completed its initialisation before we start to initialise the USB1 parts.

This minimises the chance that a nasty SMM implementation will trash the USB1
controller's config when it performs legacy emulation handover of the USB2 part.
@
text
@a66 8
#ifdef OHCI_DEBUG
#define DPRINTF(x)	do { if (ohcidebug) logprintf x; } while (0)
extern int ohcidebug;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

a68 1
void	ohci_pci_attach_deferred(struct device *);
d103 2
a104 1
	int s, i;
a106 1
	u_int32_t ctl, sts;
a160 43

	/* Ignore interrupts for now */
	sc->sc.sc_dying = 1;

	/* Perform legacy handover if required. */
	ctl = bus_space_read_4(sc->sc.iot, sc->sc.ioh, OHCI_CONTROL);
	if (ctl & OHCI_IR) {
		/* SMM active, request change */
		DPRINTF(("ohci_init: SMM active, request owner change\n"));
		if ((sc->sc.sc_intre & (OHCI_OC | OHCI_MIE)) == 
		    (OHCI_OC | OHCI_MIE))
			bus_space_write_4(sc->sc.iot, sc->sc.ioh,
			    OHCI_INTERRUPT_ENABLE, OHCI_MIE);
		sts = bus_space_read_4(sc->sc.iot, sc->sc.ioh,
		    OHCI_COMMAND_STATUS);
		bus_space_write_4(sc->sc.iot, sc->sc.ioh, OHCI_COMMAND_STATUS,
		    sts | OHCI_OCR);
		for (i = 0; i < 100 && (ctl & OHCI_IR); i++) {
			usb_delay_ms(&sc->sc.sc_bus, 1);
			ctl = bus_space_read_4(sc->sc.iot, sc->sc.ioh,
			    OHCI_CONTROL);
		}
		bus_space_write_4(sc->sc.iot, sc->sc.ioh,
		    OHCI_INTERRUPT_DISABLE, OHCI_MIE);
	}

	config_defer(self, ohci_pci_attach_deferred);

	splx(s);

	return;
}

void
ohci_pci_attach_deferred(struct device *self)
{
	struct ohci_pci_softc *sc = (struct ohci_pci_softc *)self;
	usbd_status r;
	int s;

	s = splusb();

	sc->sc.sc_dying = 1;
@


1.29
log
@Warn the user if the powerhook could not be established during attach. For
extra correctness check that it is set before trying to disestablish it at
detach. Whether you can detach a pci ohci controller is a separate issue.

Inspired by krw@@'s change in ohci.c 1.67 for PR #5128.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.28 2006/05/22 15:52:48 krw Exp $	*/
d67 8
d77 1
d112 1
a112 2
	usbd_status r;
	int s;
d115 1
d170 43
@


1.28
log
@Expunge all #if defined(__NetBSD__) and #if defined(__FreeBSD__) crud.
Misused in many cases anyway.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.27 2005/12/30 03:43:04 dlg Exp $	*/
d172 3
d193 2
a194 1
	powerhook_disestablish(sc->sc.sc_powerhook);
@


1.27
log
@device_ptr_t -> struct device *

i hate typedefs
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.26 2005/08/09 04:10:13 mickey Exp $	*/
a106 6

#if defined(__NetBSD__)
	char devinfo[256];
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
	printf(": %s (rev. 0x%02x)", devinfo, PCI_REVISION(pa->pa_class));
#endif
@


1.26
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.25 2005/04/21 12:30:02 pascoe Exp $	*/
d69 1
a69 1
int	ohci_pci_detach(device_ptr_t, int);
d187 1
a187 1
ohci_pci_detach(device_ptr_t self, int flags)
@


1.25
log
@If the SMM driver had enabled ownership change interrupts, re-enable them
temporarily before we attempt to take control.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.24 2005/04/11 08:09:32 dlg Exp $	*/
a100 1
	pcitag_t tag = pa->pa_tag;
a102 1
	pcireg_t csr;
a130 5

	/* Enable the device. */
	csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG,
		       csr | PCI_COMMAND_MASTER_ENABLE);
@


1.24
log
@get rid of the lines on ehci attach that show the version and the companion
controllers. remove the insane amount of support code needed just for the
printing of the companion controllers while here.

zap it deraadt@@ sure pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.23 2005/03/30 14:02:03 dlg Exp $	*/
d122 4
@


1.23
log
@make the powerhooks the responsibility of the bus ohci is attached to

ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.22 2004/12/31 04:22:32 dlg Exp $	*/
a57 1
#include <dev/pci/usb_pci.h>
a72 1
	struct usb_pci		sc_pci;
a183 2
	usb_pci_add(&sc->sc_pci, pa, &sc->sc.sc_bus);

a208 1
	usb_pci_rem(&sc->sc_pci);
@


1.22
log
@strncpy -> strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.21 2004/05/24 22:52:52 mickey Exp $	*/
d181 3
d202 3
@


1.21
log
@do not bother w/ void pci_devinfo() calls and free resources on failures
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.20 2004/05/23 03:23:00 deraadt Exp $	*/
d168 1
a168 2
		strncpy(sc->sc.sc_vendor, vendor, 
			sizeof(sc->sc.sc_vendor) - 1);
d170 1
a170 1
		snprintf(sc->sc.sc_vendor, sizeof sc->sc.sc_vendor,
@


1.20
log
@ehci support; hacked into working shape by jonathon@@gateway.zenbu.net
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.19 2003/08/11 02:21:28 mickey Exp $	*/
d146 1
d158 1
d178 1
@


1.19
log
@cleanup dmesg output
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.18 2003/07/08 13:19:08 nate Exp $	*/
d58 1
d74 1
d181 2
d205 1
@


1.18
log
@Sync USB code with NetBSD.
This includes numerous fixes and paves the way for usb 2.0 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.17 2002/06/08 14:53:00 drahn Exp $	*/
d119 1
a119 1
		printf("%s: can't map mem space\n", devname);
d149 1
a149 2
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_USB, ohci_intr, sc,
				       devname);
d151 1
a151 1
		printf("%s: couldn't establish interrupt", devname);
d158 1
a158 1
	printf(": interrupting at %s", intrstr);
@


1.17
log
@i386 configures devices while at spl0, this causes problems if devices
attach the interrupt before initializing the hardware to make sure that
no interrupts are pending. By adding splusb() any possible interrupts
are blocked and will be handled correctly. Discussed with niklas, ok art@@
@
text
@d1 2
a2 2
/*	$OpenBSD: ohci_pci.c,v 1.16 2002/06/07 22:26:33 miod Exp $	*/
/*	$NetBSD: ohci_pci.c,v 1.9 1999/05/20 09:52:35 augustss Exp $	*/
d83 1
a83 3
ohci_pci_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d96 1
a96 4
ohci_pci_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d101 1
d107 8
d118 2
a119 2
	    &sc->sc.iot, &sc->sc.ioh, NULL, &sc->sc.sc_size, 0)) {
		printf(": can't map mem space\n");
d125 1
a125 1
			  OHCI_ALL_INTRS);
d131 2
a132 2
	csr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
d138 1
a138 1
	    OHCI_INTERRUPT_DISABLE, OHCI_ALL_INTRS);
d150 1
a150 1
	    sc->sc.sc_bus.bdev.dv_xname);
d152 1
a152 1
		printf(": couldn't establish interrupt");
d159 1
a159 1
	printf(": %s", intrstr);
d161 10
d182 1
a182 1
	    usbctlprint);
d186 1
a186 3
ohci_pci_detach(self, flags)
	device_ptr_t self;
	int flags;
@


1.16
log
@Fix more timeout handling issues in ohci. There are still cursed harrdware
that will keep dying with this applied, though.
Discussed with drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.15 2002/03/14 01:26:59 millert Exp $	*/
d110 1
d136 1
d140 1
d152 1
d161 1
d164 1
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.14 2001/09/15 20:57:33 drahn Exp $	*/
a139 4

#if defined(__OpenBSD__)
	timeout_set(&sc->sc.sc_tmo_rhsc, ohci_rhsc_enable, sc);
#endif
@


1.14
log
@Add a timer to reinable the OHCI RHSC (Root Hub Status Change)
interrupt after one second. Originally the interrupt was disabled
permanently after it fired once. This causes futher hot plug/removals
to stop working. However the interrupt will fire several times in succession
as a device is inserted/removed. This effectively debounces the interrupt.

Apparently only some systems actually plug directly into the root hub:
Most PCI cards do not, however newer apple motherboards all do.

This was sent around for review some time back and again recently, this
time with no feedback.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.13 2001/08/25 10:13:30 art Exp $	*/
d67 3
a69 3
int	ohci_pci_match __P((struct device *, void *, void *));
void	ohci_pci_attach __P((struct device *, struct device *, void *));
int	ohci_pci_detach __P((device_ptr_t, int));
@


1.14.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.14 2001/09/15 20:57:33 drahn Exp $	*/
d67 3
a69 3
int	ohci_pci_match(struct device *, void *, void *);
void	ohci_pci_attach(struct device *, struct device *, void *);
int	ohci_pci_detach(device_ptr_t, int);
a109 1
	int s;
a134 1
	s = splusb();
a137 1
		splx(s);
d141 4
a152 1
		splx(s);
a160 1
		splx(s);
a162 1
	splx(s);
@


1.13
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.12 2001/06/13 07:43:35 deraadt Exp $	*/
d140 4
@


1.12
log
@dmesg cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.11 2001/06/12 19:11:59 mickey Exp $	*/
d136 1
a136 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.11
log
@interrupts cannot happen before
*hci cannot receive interrupts before it has been initialized.
this was changed to accomodate the pcibios strategy change back
in pre-2.9 times since *hci_init enables interrupts at it's end
and thus unmapped pci interrupt hangs the machine in the
endless loop trying to deliver it (and no hci handler to ack it).
this new way we disable interrupts by hands before we map 'em
on pci and thus ensure that they will not crash an uninitialized
*hci which, in turn, will run right after the interrupt map/establish
and by the time it enables *hci interrupts all gonna be just fine.
please allow us to end this stretched remark for cvs
is getting a power outage in less than 20 minutes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.10 2001/06/12 15:40:32 niklas Exp $	*/
d152 1
a152 1
	printf(": %s\n", intrstr);
d156 2
a157 1
		printf(": init failed, error=%d\n", r);
@


1.10
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.9 2001/01/22 22:43:44 deraadt Exp $	*/
d130 4
a133 5
	r = ohci_init(&sc->sc);
	if (r != USBD_NORMAL_COMPLETION) {
		printf(": init failed, error=%d\n", r);
		return;
	}
d153 6
@


1.9
log
@fix pretty print
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.8 2001/01/21 02:42:49 mickey Exp $	*/
d113 1
a113 1
			   &sc->sc.iot, &sc->sc.ioh, NULL, &sc->sc.sc_size)) {
@


1.8
log
@map and establish interrupts _after_ chip was initialized
and driver has allocated it's internal data structures.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.7 2000/07/04 13:21:59 fgsch Exp $	*/
d153 1
a153 1
	printf(": %s", intrstr);
@


1.7
log
@sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.6 1999/11/07 21:30:18 fgsch Exp $	*/
d130 6
a154 6
	r = ohci_init(&sc->sc);
	if (r != USBD_NORMAL_COMPLETION) {
		printf(": init failed, error=%d\n", r);
		return;
	}

d157 1
a157 1
				       usbctlprint);
@


1.6
log
@sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.5 1999/09/27 18:07:58 fgsch Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
a73 1
	bus_size_t		sc_size;
d113 1
a113 1
			   &sc->sc.iot, &sc->sc.ioh, NULL, NULL)) {
d171 1
a171 1
	if (sc->sc_ih) {
d173 1
a173 1
		sc->sc_ih = 0;
d175 3
a177 3
	if (sc->sc_size) {
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc_size);
		sc->sc_size = 0;
@


1.6.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.9 2001/01/22 22:43:44 deraadt Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
d74 1
d114 1
a114 1
			   &sc->sc.iot, &sc->sc.ioh, NULL, &sc->sc.sc_size)) {
a130 6
	r = ohci_init(&sc->sc);
	if (r != USBD_NORMAL_COMPLETION) {
		printf(": init failed, error=%d\n", r);
		return;
	}

d148 7
a154 1
	printf(": %s\n", intrstr);
d158 1
a158 1
	    usbctlprint);
d172 1
a172 1
	if (sc->sc_ih != NULL) {
d174 1
a174 1
		sc->sc_ih = NULL;
d176 3
a178 3
	if (sc->sc.sc_size) {
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
		sc->sc.sc_size = 0;
@


1.6.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.6.2.1 2001/05/14 22:25:51 niklas Exp $	*/
d113 1
a113 1
	    &sc->sc.iot, &sc->sc.ioh, NULL, &sc->sc.sc_size, 0)) {
d130 5
a134 4
	bus_space_barrier(sc->sc.iot, sc->sc.ioh, 0, sc->sc.sc_size,
	    BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE);
	bus_space_write_4(sc->sc.iot, sc->sc.ioh,
	    OHCI_INTERRUPT_DISABLE, OHCI_ALL_INTRS);
d153 1
a153 8
	printf(": %s", intrstr);

	r = ohci_init(&sc->sc);
	if (r != USBD_NORMAL_COMPLETION) {
		printf("%s: init failed, error=%d\n",
		    sc->sc.sc_bus.bdev.dv_xname, r);
		return;
	}
@


1.6.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.6.2.2 2001/07/04 10:42:43 niklas Exp $	*/
d136 2
a137 1
	if (pci_intr_map(pa, &ih)) {
a140 4

#if defined(__OpenBSD__)
	timeout_set(&sc->sc.sc_tmo_rhsc, ohci_rhsc_enable, sc);
#endif
@


1.6.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d67 3
a69 3
int	ohci_pci_match(struct device *, void *, void *);
void	ohci_pci_attach(struct device *, struct device *, void *);
int	ohci_pci_detach(device_ptr_t, int);
@


1.6.2.5
log
@Sync the SMP branch with 3.3
@
text
@a109 1
	int s;
a134 1
	s = splusb();
a137 1
		splx(s);
d141 4
a152 1
		splx(s);
a160 1
		splx(s);
a162 1
	splx(s);
@


1.6.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 1
a2 1
/*	$NetBSD: ohci_pci.c,v 1.23 2002/10/02 16:51:47 thorpej Exp $	*/
d83 3
a85 1
ohci_pci_match(struct device *parent, void *match, void *aux)
d98 4
a101 1
ohci_pci_attach(struct device *parent, struct device *self, void *aux)
a105 1
	pcitag_t tag = pa->pa_tag;
a110 8
	const char *vendor;
	char *devname = sc->sc.sc_bus.bdev.dv_xname;

#if defined(__NetBSD__)
	char devinfo[256];
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
	printf(": %s (rev. 0x%02x)", devinfo, PCI_REVISION(pa->pa_class));
#endif
d114 1
a114 1
		    &sc->sc.iot, &sc->sc.ioh, NULL, &sc->sc.sc_size, 0)) {
d121 1
a121 1
			  OHCI_MIE);
d127 2
a128 2
	csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG,
d134 1
a134 1
	    OHCI_INTERRUPT_DISABLE, OHCI_MIE);
d145 2
a146 1
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_USB, ohci_intr, sc, devname);
a156 10
	/* Figure out vendor for root hub descriptor. */
	vendor = pci_findvendor(pa->pa_id);
	sc->sc.sc_id_vendor = PCI_VENDOR(pa->pa_id);
	if (vendor)
		strncpy(sc->sc.sc_vendor, vendor, 
			sizeof(sc->sc.sc_vendor) - 1);
	else
		snprintf(sc->sc.sc_vendor, sizeof sc->sc.sc_vendor,
		    "vendor 0x%04x", PCI_VENDOR(pa->pa_id));
	
d168 1
a168 1
				       usbctlprint);
d172 3
a174 1
ohci_pci_detach(device_ptr_t self, int flags)
@


1.6.2.7
log
@Merge with the trunk
@
text
@a57 1
#include <dev/pci/usb_pci.h>
a72 1
	struct usb_pci		sc_pci;
a143 1
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
a154 1
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
a173 1
		bus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc.sc_size);
a178 2
	usb_pci_add(&sc->sc_pci, pa, &sc->sc.sc_bus);

a200 1
	usb_pci_rem(&sc->sc_pci);
@


1.5
log
@Disable ints. later; NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.4 1999/08/23 21:54:39 fgsch Exp $	*/
d69 8
d79 2
a80 2
	sizeof(struct ohci_softc), ohci_pci_match, ohci_pci_attach,
	ohci_detach, ohci_activate
d93 1
a93 1
		return 1;
d95 1
a95 1
	return 0;
d104 1
a104 1
	struct ohci_softc *sc = (struct ohci_softc *)self;
d114 1
a114 1
			   &sc->iot, &sc->ioh, NULL, NULL)) {
d119 3
a121 3
	/* Disable interrupts, so we don't can any spurious ones. */
	bus_space_write_4(sc->iot, sc->ioh, 
			  OHCI_INTERRUPT_DISABLE, OHCI_ALL_INTRS);
d123 2
a124 1
	sc->sc_bus.dmatag = pa->pa_dmat;
d140 1
a140 1
	    sc->sc_bus.bdev.dv_xname);
d150 1
a150 1
	r = ohci_init(sc);
d157 24
a180 1
	sc->sc_child = config_found((void *)sc, &sc->sc_bus, usbctlprint);
@


1.4
log
@Disable interrupts early; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.3 1999/08/13 08:55:57 fgsch Exp $	*/
d71 2
a72 1
	sizeof(struct ohci_softc), ohci_pci_match, ohci_pci_attach
a103 4
	/* Disable interrupts, so we don't can any spurious ones. */
	bus_space_write_4(sc->iot, sc->ioh, 
			  OHCI_INTERRUPT_DISABLE, OHCI_ALL_INTRS);

d111 5
a115 1
	sc->sc_dmatag = pa->pa_dmat;
d148 1
a148 1
	config_found((void *)sc, &sc->sc_bus, usbctlprint);
@


1.3
log
@shorten dmesg output.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.2 1999/08/13 08:09:26 fgsch Exp $	*/
d102 4
@


1.2
log
@Remove unncessary printfs as well as NetBSD ifdefs.
Make dmesg output shorter.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci_pci.c,v 1.1 1999/08/13 05:32:29 fgsch Exp $	*/
d134 1
a134 1
	printf(": %s\n", intrstr);
@


1.1
log
@USB controllers.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a66 3
#if defined(__NetBSD__)
int	ohci_pci_match __P((struct device *, struct cfdata *, void *));
#else
a67 1
#endif
d77 1
a77 6
#if defined(__NetBSD__)
	struct cfdata *match;
#else
	void *match;
#endif
	void *aux;
a100 1
	char devinfo[256];
a101 6
#if defined(__NetBSD__)
	char *vendor;
#endif

	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
	printf(": %s (rev. 0x%02x)\n", devinfo, PCI_REVISION(pa->pa_class));
d106 1
a106 1
		printf("%s: can't map mem space\n", sc->sc_bus.bdev.dv_xname);
d120 1
a120 2
		printf("%s: couldn't map interrupt\n", 
		       sc->sc_bus.bdev.dv_xname);
d123 1
a124 3
#if defined(__NetBSD__)
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_USB, ohci_intr, sc);
#else
a126 1
#endif
d128 1
a128 2
		printf("%s: couldn't establish interrupt",
		    sc->sc_bus.bdev.dv_xname);
d134 1
a134 1
	printf("%s: interrupting at %s\n", sc->sc_bus.bdev.dv_xname, intrstr);
a135 10
#if defined(__NetBSD__)
	/* Figure out vendor for root hub descriptor. */
	vendor = pci_findvendor(pa->pa_id);
	sc->sc_id_vendor = PCI_VENDOR(pa->pa_id);
	if (vendor)
		strncpy(sc->sc_vendor, vendor, sizeof(sc->sc_vendor) - 1);
	else
		sprintf(sc->sc_vendor, "vendor 0x%04x", PCI_VENDOR(pa->pa_id));
#endif
	
d138 1
a138 2
		printf("%s: init failed, error=%d\n", sc->sc_bus.bdev.dv_xname,
		       r);
@

