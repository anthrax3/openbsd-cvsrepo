head	1.42;
access;
symbols
	OPENBSD_6_0:1.40.0.4
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.38.0.4
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.32.0.4
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.2
	OPENBSD_5_0:1.31.0.4
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.4
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.26.0.2
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.21.0.4
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.19.0.6
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.16.0.8
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.6
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.15
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	SMP:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2;
locks; strict;
comment	@ * @;


1.42
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.41;
commitid	qGgYgJTgEFuAoGj4;

1.41
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.40;
commitid	pi1a9KN0itEngOc4;

1.40
date	2016.05.13.19.51.39;	author ratchov;	state Exp;
branches;
next	1.39;
commitid	uWTeK8aUjxbIcRp7;

1.39
date	2015.05.11.06.46.22;	author ratchov;	state Exp;
branches;
next	1.38;
commitid	RaOGL5SyOGOZylwx;

1.38
date	2014.09.13.16.06.37;	author doug;	state Exp;
branches;
next	1.37;
commitid	jdBY2kKXhfcoQitp;

1.37
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.36;
commitid	OBNa5kfxQ2UXoiIw;

1.36
date	2013.11.15.16.46.27;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.34;

1.34
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.33;

1.33
date	2012.10.21.16.50.58;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2011.12.23.21.43.20;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2010.09.07.16.21.45;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2010.08.27.18.50.57;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.28;

1.28
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.26;

1.26
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.29.02.10.01;	author jakemsr;	state Exp;
branches;
next	1.24;

1.24
date	2008.04.21.00.32.43;	author jakemsr;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.22.21.42.14;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2007.10.09.17.06.18;	author gilles;	state Exp;
branches;
next	1.21;

1.21
date	2006.12.29.13.04.37;	author pedro;	state Exp;
branches;
next	1.20;

1.20
date	2006.10.01.21.46.33;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.09.04.10.13;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.16.21.57.23;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.14.12.42.16;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.06.02.56.39;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.31.11.00.24;	author art;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.09.21.17.55.44;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.05.08.29.55;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.02.11.16.29;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.12.15.40.32;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.16.19.27.38;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.16.12.51.50;	author ho;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.13.01.45.56;	author deraadt;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2001.01.16.12.07.19;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.12.17.38.30;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2001.01.11.23.36.38;	author espie;	state Exp;
branches;
next	;

1.4.4.1
date	2001.05.14.22.25.50;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.07.04.10.42.38;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2002.03.06.02.11.46;	author niklas;	state Exp;
branches;
next	1.4.4.6;

1.4.4.6
date	2002.03.28.15.35.58;	author niklas;	state Exp;
branches;
next	1.4.4.7;

1.4.4.7
date	2003.06.07.11.02.30;	author ho;	state Exp;
branches;
next	;

1.12.2.1
date	2002.01.31.22.55.35;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.06.11.03.42.26;	author art;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Remove unused getdev() audio driver functions.
@
text
@/*	$OpenBSD: maestro.c,v 1.41 2016/09/14 06:12:19 ratchov Exp $	*/
/* $FreeBSD: /c/ncvs/src/sys/dev/sound/pci/maestro.c,v 1.3 2000/11/21 12:22:11 julian Exp $ */
/*
 * FreeBSD's ESS Agogo/Maestro driver 
 * Converted from FreeBSD's pcm to OpenBSD's audio.
 * Copyright (c) 2000, 2001 David Leonard & Marc Espie
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*-
 * (FreeBSD) Credits:
 * Copyright (c) 2000 Taku YAMAMOTO <taku@@cent.saitama-u.ac.jp>
 *
 * Part of this code (especially in many magic numbers) was heavily inspired
 * by the Linux driver originally written by
 * Alan Cox <alan.cox@@linux.org>, modified heavily by
 * Zach Brown <zab@@zabbo.net>.
 *
 * busdma()-ize and buffer size reduction were suggested by
 * Cameron Grant <gandalf@@vilnya.demon.co.uk>.
 * Also he showed me the way to use busdma() suite.
 *
 * Internal speaker problems on NEC VersaPro's and Dell Inspiron 7500
 * were looked at by
 * Munehiro Matsuda <haro@@tk.kubota.co.jp>,
 * who brought patches based on the Linux driver with some simplification.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/queue.h>
#include <sys/fcntl.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>

#include <dev/ic/ac97.h>

/* -----------------------------
 * PCI config registers
 */

/* Legacy emulation */
#define CONF_LEGACY	0x40

#define LEGACY_DISABLED	0x8000

/* Chip configurations */
#define CONF_MAESTRO	0x50
#define MAESTRO_CHIBUS		0x00100000
#define MAESTRO_POSTEDWRITE	0x00000080
#define MAESTRO_DMA_PCITIMING	0x00000040
#define MAESTRO_SWAP_LR		0x00000010

/* ACPI configurations */
#define CONF_ACPI_STOPCLOCK	0x54
#define ACPI_PART_2ndC_CLOCK	15
#define ACPI_PART_CODEC_CLOCK	14
#define ACPI_PART_978		13 /* Docking station or something */
#define ACPI_PART_SPDIF		12
#define ACPI_PART_GLUE		11 /* What? */
#define ACPI_PART_DAA		10
#define ACPI_PART_PCI_IF	9
#define ACPI_PART_HW_VOL	8
#define ACPI_PART_GPIO		7
#define ACPI_PART_ASSP		6
#define ACPI_PART_SB		5
#define ACPI_PART_FM		4
#define ACPI_PART_RINGBUS	3
#define ACPI_PART_MIDI		2
#define ACPI_PART_GAME_PORT	1
#define ACPI_PART_WP		0


/* -----------------------------
 * I/O ports
 */

/* Direct Sound Processor (aka Wave Processor) */
#define PORT_DSP_DATA	0x00	/* WORD RW */
#define PORT_DSP_INDEX	0x02	/* WORD RW */
#define PORT_INT_STAT	0x04	/* WORD RW */
#define PORT_SAMPLE_CNT	0x06	/* WORD RO */

/* WaveCache */
#define PORT_WAVCACHE_INDEX	0x10	/* WORD RW */
#define PORT_WAVCACHE_DATA	0x12	/* WORD RW */
#define WAVCACHE_PCMBAR		0x1fc
#define WAVCACHE_WTBAR		0x1f0
#define WAVCACHE_BASEADDR_SHIFT	12

#define WAVCACHE_CHCTL_ADDRTAG_MASK	0xfff8
#define WAVCACHE_CHCTL_U8		0x0004
#define WAVCACHE_CHCTL_STEREO		0x0002
#define WAVCACHE_CHCTL_DECREMENTAL	0x0001

#define PORT_WAVCACHE_CTRL	0x14	/* WORD RW */
#define WAVCACHE_EXTRA_CH_ENABLED	0x0200
#define WAVCACHE_ENABLED		0x0100
#define WAVCACHE_CH_60_ENABLED		0x0080
#define WAVCACHE_WTSIZE_MASK	0x0060
#define WAVCACHE_WTSIZE_1MB	0x0000
#define WAVCACHE_WTSIZE_2MB	0x0020
#define WAVCACHE_WTSIZE_4MB	0x0040
#define WAVCACHE_WTSIZE_8MB	0x0060
#define WAVCACHE_SGC_MASK		0x000c
#define WAVCACHE_SGC_DISABLED		0x0000
#define WAVCACHE_SGC_40_47		0x0004
#define WAVCACHE_SGC_32_47		0x0008
#define WAVCACHE_TESTMODE		0x0001

/* Host Interruption */
#define PORT_HOSTINT_CTRL	0x18	/* WORD RW */
#define HOSTINT_CTRL_SOFT_RESET		0x8000
#define HOSTINT_CTRL_DSOUND_RESET	0x4000
#define HOSTINT_CTRL_HW_VOL_TO_PME	0x0400
#define HOSTINT_CTRL_CLKRUN_ENABLED	0x0100
#define HOSTINT_CTRL_HWVOL_ENABLED	0x0040
#define HOSTINT_CTRL_ASSP_INT_ENABLED	0x0010
#define HOSTINT_CTRL_ISDN_INT_ENABLED	0x0008
#define HOSTINT_CTRL_DSOUND_INT_ENABLED	0x0004
#define HOSTINT_CTRL_MPU401_INT_ENABLED	0x0002
#define HOSTINT_CTRL_SB_INT_ENABLED	0x0001

#define PORT_HOSTINT_STAT	0x1a	/* BYTE RW */
#define HOSTINT_STAT_HWVOL	0x40
#define HOSTINT_STAT_ASSP	0x10
#define HOSTINT_STAT_ISDN	0x08
#define HOSTINT_STAT_DSOUND	0x04
#define HOSTINT_STAT_MPU401	0x02
#define HOSTINT_STAT_SB		0x01

/* Hardware volume */
#define PORT_HWVOL_VOICE_SHADOW	0x1c	/* BYTE RW */
#define PORT_HWVOL_VOICE	0x1d	/* BYTE RW */
#define PORT_HWVOL_MASTER_SHADOW 0x1e	/* BYTE RW */
#define PORT_HWVOL_MASTER	0x1f	/* BYTE RW */

/* CODEC */
#define	PORT_CODEC_CMD	0x30	/* BYTE W */
#define CODEC_CMD_READ	0x80
#define	CODEC_CMD_WRITE	0x00
#define	CODEC_CMD_ADDR_MASK	0x7f

#define PORT_CODEC_STAT	0x30	/* BYTE R */
#define CODEC_STAT_MASK	0x01
#define CODEC_STAT_RW_DONE	0x00
#define CODEC_STAT_PROGLESS	0x01

#define PORT_CODEC_REG	0x32	/* WORD RW */

/* Ring bus control */
#define PORT_RINGBUS_CTRL	0x34	/* DWORD RW */
#define RINGBUS_CTRL_I2S_ENABLED	0x80000000
#define RINGBUS_CTRL_RINGBUS_ENABLED	0x20000000
#define RINGBUS_CTRL_ACLINK_ENABLED	0x10000000
#define RINGBUS_CTRL_AC97_SWRESET	0x08000000
#define RINGBUS_CTRL_IODMA_PLAYBACK_ENABLED	0x04000000
#define RINGBUS_CTRL_IODMA_RECORD_ENABLED	0x02000000

#define RINGBUS_SRC_MIC		20
#define RINGBUS_SRC_I2S		16
#define RINGBUS_SRC_ADC		12
#define RINGBUS_SRC_MODEM	8
#define RINGBUS_SRC_DSOUND	4
#define RINGBUS_SRC_ASSP	0

#define RINGBUS_DEST_MONORAL	000
#define RINGBUS_DEST_STEREO	010
#define RINGBUS_DEST_NONE	0
#define RINGBUS_DEST_DAC	1
#define RINGBUS_DEST_MODEM_IN	2
#define RINGBUS_DEST_RESERVED3	3
#define RINGBUS_DEST_DSOUND_IN	4
#define RINGBUS_DEST_ASSP_IN	5

/* General Purpose I/O */
#define PORT_GPIO_DATA	0x60	/* WORD RW */
#define PORT_GPIO_MASK	0x64	/* WORD RW */
#define PORT_GPIO_DIR	0x68	/* WORD RW */

/* Application Specific Signal Processor */
#define PORT_ASSP_MEM_INDEX	0x80	/* DWORD RW */
#define PORT_ASSP_MEM_DATA	0x84	/* WORD RW */
#define PORT_ASSP_CTRL_A	0xa2	/* BYTE RW */
#define PORT_ASSP_CTRL_B	0xa4	/* BYTE RW */
#define PORT_ASSP_CTRL_C	0xa6	/* BYTE RW */
#define PORT_ASSP_HOST_WR_INDEX	0xa8	/* BYTE W */
#define PORT_ASSP_HOST_WR_DATA	0xaa	/* BYTE RW */
#define PORT_ASSP_INT_STAT	0xac	/* BYTE RW */


/* -----------------------------
 * Wave Processor Indexed Data Registers.
 */

#define WPREG_DATA_PORT		0
#define WPREG_CRAM_PTR		1
#define WPREG_CRAM_DATA		2
#define WPREG_WAVE_DATA		3
#define WPREG_WAVE_PTR_LOW	4
#define WPREG_WAVE_PTR_HIGH	5

#define WPREG_TIMER_FREQ	6
#define WP_TIMER_FREQ_PRESCALE_MASK	0x00e0	/* actual - 9 */
#define WP_TIMER_FREQ_PRESCALE_SHIFT	5
#define WP_TIMER_FREQ_DIVIDE_MASK	0x001f
#define WP_TIMER_FREQ_DIVIDE_SHIFT	0

#define WPREG_WAVE_ROMRAM	7
#define WP_WAVE_VIRTUAL_ENABLED	0x0400
#define WP_WAVE_8BITRAM_ENABLED	0x0200
#define WP_WAVE_DRAM_ENABLED	0x0100
#define WP_WAVE_RAMSPLIT_MASK	0x00ff
#define WP_WAVE_RAMSPLIT_SHIFT	0

#define WPREG_BASE		12
#define WP_PARAOUT_BASE_MASK	0xf000
#define WP_PARAOUT_BASE_SHIFT	12
#define WP_PARAIN_BASE_MASK	0x0f00
#define WP_PARAIN_BASE_SHIFT	8
#define WP_SERIAL0_BASE_MASK	0x00f0
#define WP_SERIAL0_BASE_SHIFT	4
#define WP_SERIAL1_BASE_MASK	0x000f
#define WP_SERIAL1_BASE_SHIFT	0

#define WPREG_TIMER_ENABLE	17
#define WPREG_TIMER_START	23


/* -----------------------------
 * Audio Processing Unit.
 */
#define APUREG_APUTYPE	0
#define APU_DMA_ENABLED	0x4000
#define APU_INT_ON_LOOP	0x2000
#define APU_ENDCURVE	0x1000
#define APU_APUTYPE_MASK	0x00f0
#define APU_FILTERTYPE_MASK	0x000c
#define APU_FILTERQ_MASK	0x0003

/* APU types */
#define APU_APUTYPE_SHIFT	4

#define APUTYPE_INACTIVE	0
#define APUTYPE_16BITLINEAR	1
#define APUTYPE_16BITSTEREO	2
#define APUTYPE_8BITLINEAR	3
#define APUTYPE_8BITSTEREO	4
#define APUTYPE_8BITDIFF	5
#define APUTYPE_DIGITALDELAY	6
#define APUTYPE_DUALTAP_READER	7
#define APUTYPE_CORRELATOR	8
#define APUTYPE_INPUTMIXER	9
#define APUTYPE_WAVETABLE	10
#define APUTYPE_RATECONV	11
#define APUTYPE_16BITPINGPONG	12
/* APU type 13 through 15 are reserved. */

/* Filter types */
#define APU_FILTERTYPE_SHIFT	2

#define FILTERTYPE_2POLE_LOPASS		0
#define FILTERTYPE_2POLE_BANDPASS	1
#define FILTERTYPE_2POLE_HIPASS		2
#define FILTERTYPE_1POLE_LOPASS		3
#define FILTERTYPE_1POLE_HIPASS		4
#define FILTERTYPE_PASSTHROUGH		5

/* Filter Q */
#define APU_FILTERQ_SHIFT	0

#define FILTERQ_LESSQ	0
#define FILTERQ_MOREQ	3

/* APU register 2 */
#define APUREG_FREQ_LOBYTE	2
#define APU_FREQ_LOBYTE_MASK	0xff00
#define APU_plus6dB		0x0010

/* APU register 3 */
#define APUREG_FREQ_HIWORD	3
#define APU_FREQ_HIWORD_MASK	0x0fff

/* Frequency */
#define APU_FREQ_LOBYTE_SHIFT	8
#define APU_FREQ_HIWORD_SHIFT	0
#define FREQ_Hz2DIV(freq)	(((u_int64_t)(freq) << 16) / 48000)

/* APU register 4 */
#define APUREG_WAVESPACE	4
#define APU_STEREO		0x8000
#define APU_USE_SYSMEM		0x4000
#define APU_PCMBAR_MASK		0x6000
#define APU_64KPAGE_MASK	0xff00

/* PCM Base Address Register selection */
#define APU_PCMBAR_SHIFT	13

/* 64KW (==128KB) Page */
#define APU_64KPAGE_SHIFT	8

/* APU register 5 - 7 */
#define APUREG_CURPTR	5
#define APUREG_ENDPTR	6
#define APUREG_LOOPLEN	7

/* APU register 9 */
#define APUREG_AMPLITUDE	9
#define APU_AMPLITUDE_NOW_MASK	0xff00
#define APU_AMPLITUDE_DEST_MASK	0x00ff

/* Amplitude now? */
#define APU_AMPLITUDE_NOW_SHIFT	8

/* APU register 10 */
#define APUREG_POSITION	10
#define APU_RADIUS_MASK	0x00c0
#define APU_PAN_MASK	0x003f

/* Radius control. */
#define APU_RADIUS_SHIFT	6
#define RADIUS_CENTERCIRCLE	0
#define RADIUS_MIDDLE		1
#define RADIUS_OUTSIDE		2

/* Polar pan. */
#define APU_PAN_SHIFT	0
#define PAN_RIGHT	0x00
#define PAN_FRONT	0x08
#define PAN_LEFT	0x10


/* -----------------------------
 * Limits.
 */
#define WPWA_MAX	((1 << 22) - 1)
#define WPWA_MAXADDR	((1 << 23) - 1)
#define MAESTRO_MAXADDR	((1 << 28) - 1)



#ifdef AUDIO_DEBUG
#define DPRINTF(x)	if (maestrodebug) printf x
#define DLPRINTF(i, x)	if (maestrodebug & i) printf x
int	maestrodebug = 0;
u_long maestrointr_called;
u_long maestrodma_effective;

#define MAESTRODEBUG_INTR 1
#define MAESTRODEBUG_TIMER 2
#else
#define DPRINTF(x)
#define DLPRINTF(i, x)
#endif

#define MAESTRO_BUFSIZ		0x4000
#define lengthof(array)		(sizeof (array) / sizeof (array)[0])

#define STEP_VOLUME		0x22
#define MIDDLE_VOLUME		(STEP_VOLUME * 4)

typedef struct salloc_pool {
	struct salloc_zone {
		SLIST_ENTRY(salloc_zone) link;
		caddr_t		addr;
		size_t		size;
	} *zones;
	SLIST_HEAD(salloc_head, salloc_zone) free, used, spare;
} *salloc_t;

struct maestro_softc;

#define MAESTRO_PLAY	1
#define MAESTRO_STEREO	2
#define MAESTRO_8BIT	4
#define MAESTRO_UNSIGNED	8
#define MAESTRO_RUNNING	16

struct maestro_channel {
	struct maestro_softc 	*sc;
	int			num;
	u_int32_t		blocksize;
	u_int16_t		mode;
	u_int32_t		speed;
	u_int32_t		dv;
	u_int16_t		start;
	u_int16_t		threshold;
	u_int16_t		end;
	u_int16_t		current;
	u_int			wpwa;
	void			(*intr)(void *);
	void			*intr_arg;
};

struct maestro_softc {
	struct device		dev;

	void			*ih;
	pci_chipset_tag_t	pc;
	pcitag_t		pt;

#define MAESTRO_FLAG_SETUPGPIO	0x0001
	int			flags;
	bus_space_tag_t		iot;
	bus_space_handle_t	ioh;
	bus_dma_tag_t		dmat;

	caddr_t			dmabase;
	bus_addr_t		physaddr;
	size_t			dmasize;
	bus_dmamap_t		dmamap;
	bus_dma_segment_t	dmaseg;
	salloc_t		dmapool;

	struct ac97_codec_if	*codec_if;
	struct ac97_host_if	host_if;

	int			suspend;

	struct maestro_channel	play;
	struct maestro_channel	record;
};


typedef	u_int16_t wpreg_t;
typedef	u_int16_t wcreg_t;

salloc_t salloc_new(caddr_t, size_t, int);
void	salloc_destroy(salloc_t);
caddr_t	salloc_alloc(salloc_t, size_t);
void	salloc_free(salloc_t, caddr_t);
void	salloc_insert(salloc_t, struct salloc_head *, 
		struct salloc_zone *, int);

int	maestro_match(struct device *, void *, void *);
void	maestro_attach(struct device *, struct device *, void *);
int	maestro_activate(struct device *, int);
int	maestro_intr(void *);

int	maestro_open(void *, int);
void	maestro_close(void *);
int	maestro_set_params(void *, int, int, struct audio_params *, 
			    struct audio_params *);
int	maestro_round_blocksize(void *, int);
int	maestro_halt_output(void *);
int	maestro_halt_input(void *);
int	maestro_set_port(void *, mixer_ctrl_t *);
int	maestro_get_port(void *, mixer_ctrl_t *);
int	maestro_query_devinfo(void *, mixer_devinfo_t *);
void	*maestro_malloc(void *, int, size_t, int, int);
void	maestro_free(void *, void *, int);
int	maestro_get_props(void *);
int	maestro_trigger_output(void *, void *, void *, int, void (*)(void *),
				void *, struct audio_params *);
int	maestro_trigger_input(void *, void *, void *, int, void (*)(void *),
			       void *, struct audio_params *);

int	maestro_attach_codec(void *, struct ac97_codec_if *);
enum ac97_host_flags maestro_codec_flags(void *);
int	maestro_read_codec(void *, u_int8_t, u_int16_t *);
int	maestro_write_codec(void *, u_int8_t, u_int16_t);
void	maestro_reset_codec(void *);

void	maestro_initcodec(void *);

void	maestro_set_speed(struct maestro_channel *, u_long *);
void	maestro_init(struct maestro_softc *);

void 	maestro_channel_start(struct maestro_channel *);
void 	maestro_channel_stop(struct maestro_channel *);
void 	maestro_channel_advance_dma(struct maestro_channel *);
void	maestro_channel_suppress_jitter(struct maestro_channel *);

int	maestro_get_flags(struct pci_attach_args *);

void	ringbus_setdest(struct maestro_softc *, int, int);

wpreg_t	wp_reg_read(struct maestro_softc *, int);
void	wp_reg_write(struct maestro_softc *, int, wpreg_t);
wpreg_t	wp_apu_read(struct maestro_softc *, int, int);
void	wp_apu_write(struct maestro_softc *, int, int, wpreg_t);
void	wp_settimer(struct maestro_softc *, u_int);
void	wp_starttimer(struct maestro_softc *);
void	wp_stoptimer(struct maestro_softc *);

wcreg_t	wc_reg_read(struct maestro_softc *, int);
void	wc_reg_write(struct maestro_softc *, int, wcreg_t);
wcreg_t	wc_ctrl_read(struct maestro_softc *, int);
void	wc_ctrl_write(struct maestro_softc *, int, wcreg_t);

u_int maestro_calc_timer_freq(struct maestro_channel *);
void maestro_update_timer(struct maestro_softc *);

struct cfdriver maestro_cd = {
	NULL, "maestro", DV_DULL
};

struct cfattach maestro_ca = {
	sizeof (struct maestro_softc), maestro_match, maestro_attach,
	NULL, maestro_activate
};

struct audio_hw_if maestro_hw_if = {
	maestro_open,
	maestro_close,
	maestro_set_params,
	maestro_round_blocksize,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	maestro_halt_output,
	maestro_halt_input,
	NULL,
	NULL,
	maestro_set_port,
	maestro_get_port,
	maestro_query_devinfo,
	maestro_malloc,
	maestro_free,
	NULL,
	maestro_get_props,
	maestro_trigger_output,
	maestro_trigger_input
};

struct {
	u_short vendor, product;
	int flags;
} maestro_pcitab[] = {
	{ PCI_VENDOR_ESSTECH, PCI_PRODUCT_ESSTECH_MAESTROII,	0 },
	{ PCI_VENDOR_ESSTECH, PCI_PRODUCT_ESSTECH_MAESTRO2E,	0 },
	{ PCI_VENDOR_PLATFORM, PCI_PRODUCT_PLATFORM_ES1849,	0 },
	{ PCI_VENDOR_NEC, PCI_PRODUCT_NEC_VERSAMAESTRO,		MAESTRO_FLAG_SETUPGPIO },
	{ PCI_VENDOR_NEC, PCI_PRODUCT_NEC_VERSAPRONXVA26D,	MAESTRO_FLAG_SETUPGPIO }
};
#define NMAESTRO_PCITAB	lengthof(maestro_pcitab)

int
maestro_get_flags(struct pci_attach_args *pa)
{
	int i;

	/* Distinguish audio devices from modems with the same manfid */
	if (PCI_CLASS(pa->pa_class) != PCI_CLASS_MULTIMEDIA)
		return (-1);
	if (PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_MULTIMEDIA_AUDIO)
		return (-1);
	for (i = 0; i < NMAESTRO_PCITAB; i++)
		if (PCI_VENDOR(pa->pa_id) == maestro_pcitab[i].vendor &&
		    PCI_PRODUCT(pa->pa_id) == maestro_pcitab[i].product)
			return (maestro_pcitab[i].flags);
	return (-1);
}

/* -----------------------------
 * Driver interface.
 */

int
maestro_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;

	if (maestro_get_flags(pa) == -1)
		return (0);
	else
		return (1);
}

void
maestro_attach(struct device *parent, struct device *self, void *aux)
{
	struct maestro_softc *sc = (struct maestro_softc *)self;
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	char const *intrstr;
	pci_intr_handle_t ih;
	int error;
	u_int16_t cdata;
	int dmastage = 0;
	int rseg;

	sc->flags = maestro_get_flags(pa);

	sc->pc = pa->pa_pc;
	sc->pt = pa->pa_tag;
	sc->dmat = pa->pa_dmat;

	/* Map interrupt */
	if (pci_intr_map(pa, &ih)) {
		printf(": can't map interrupt\n");
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->ih = pci_intr_establish(pc, ih, IPL_AUDIO | IPL_MPSAFE,
	    maestro_intr, sc, sc->dev.dv_xname);
	if (sc->ih == NULL) {
		printf(": can't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s\n", intrstr);
		return;
	}
	printf(": %s", intrstr);

	pci_set_powerstate(pc, sc->pt, PCI_PMCSR_STATE_D0);

	/* Map i/o */
	if ((error = pci_mapreg_map(pa, PCI_MAPS, PCI_MAPREG_TYPE_IO, 
	    0, &sc->iot, &sc->ioh, NULL, NULL, 0)) != 0) {
		printf(", can't map i/o space\n");
		goto bad;
	};

	/* Allocate fixed DMA segment :-( */
	sc->dmasize = MAESTRO_BUFSIZ * 16;
	if ((error = bus_dmamem_alloc(sc->dmat, sc->dmasize, NBPG, 0, 
	    &sc->dmaseg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
		printf(", unable to alloc dma, error %d\n", error);
		goto bad;
	}
	dmastage = 1;
	if ((error = bus_dmamem_map(sc->dmat, &sc->dmaseg, 1,
	    sc->dmasize, &sc->dmabase, BUS_DMA_NOWAIT | 
	    BUS_DMA_COHERENT)) != 0) {
		printf(", unable to map dma, error %d\n", error);
		goto bad;
	}
	dmastage = 2;
	if ((error = bus_dmamap_create(sc->dmat, sc->dmasize, 1, 
	    sc->dmasize, 0, BUS_DMA_NOWAIT, &sc->dmamap)) != 0) {
		printf(", unable to create dma map, error %d\n", error);
		goto bad;
	}
	dmastage = 3;
	if ((error = bus_dmamap_load(sc->dmat, sc->dmamap, 
	    sc->dmabase, sc->dmasize, NULL, BUS_DMA_NOWAIT)) != 0) {
		printf(", unable to load dma map, error %d\n", error);
		goto bad;
	}

	/* XXX 
	 * The first byte of the allocated memory is not usable,
	 * the WP sometimes uses it to store status.
	 */
	/* Make DMA memory pool */
	if ((sc->dmapool = salloc_new(sc->dmabase+16, sc->dmasize-16,
	    128/*overkill?*/)) == NULL) {
		printf(", unable to make dma pool\n");
		goto bad;
	}
	
	sc->physaddr = sc->dmamap->dm_segs[0].ds_addr;

	printf("\n");

	/* Kick device */
	maestro_init(sc);
	maestro_read_codec(sc, 0, &cdata);
	if (cdata == 0x80) {
		printf("%s: PT101 codec unsupported, no mixer\n", 
		    sc->dev.dv_xname);
		/* Init values from Linux, no idea what this does. */
		maestro_write_codec(sc, 0x2a, 0x0001);
		maestro_write_codec(sc, 0x2C, 0x0000);
		maestro_write_codec(sc, 0x2C, 0xFFFF);
		maestro_write_codec(sc, 0x10, 0x9F1F);
		maestro_write_codec(sc, 0x12, 0x0808);
		maestro_write_codec(sc, 0x14, 0x9F1F);
		maestro_write_codec(sc, 0x16, 0x9F1F);
		maestro_write_codec(sc, 0x18, 0x0404);
		maestro_write_codec(sc, 0x1A, 0x0000);
		maestro_write_codec(sc, 0x1C, 0x0000);
		maestro_write_codec(sc, 0x02, 0x0404);
		maestro_write_codec(sc, 0x04, 0x0808);
		maestro_write_codec(sc, 0x0C, 0x801F);
		maestro_write_codec(sc, 0x0E, 0x801F);
		/* no control over the mixer, sorry */
		sc->codec_if = NULL;
	} else {
		/* Attach the AC'97 */
		sc->host_if.arg = sc;
		sc->host_if.attach = maestro_attach_codec;
		sc->host_if.flags = maestro_codec_flags;
		sc->host_if.read = maestro_read_codec;
		sc->host_if.write = maestro_write_codec;
		sc->host_if.reset = maestro_reset_codec;
		if (ac97_attach(&sc->host_if) != 0) {
			printf("%s: can't attach codec\n", sc->dev.dv_xname);
			goto bad;
		}
	}

	sc->play.mode = MAESTRO_PLAY;
	sc->play.sc = sc;
	sc->play.num = 0;
	sc->record.sc = sc;
	sc->record.num = 2;
	sc->record.mode = 0;

	/* Attach audio */
	audio_attach_mi(&maestro_hw_if, sc, &sc->dev);
	return;

 bad:
	if (sc->ih)
		pci_intr_disestablish(pc, sc->ih);
	printf("%s: disabled\n", sc->dev.dv_xname);
	if (sc->dmapool)
		salloc_destroy(sc->dmapool);
	if (dmastage >= 3)
		bus_dmamap_destroy(sc->dmat, sc->dmamap);
	if (dmastage >= 2)
		bus_dmamem_unmap(sc->dmat, sc->dmabase, sc->dmasize);
	if (dmastage >= 1)
		bus_dmamem_free(sc->dmat, &sc->dmaseg, 1);
}

void
maestro_init(struct maestro_softc *sc)
{
	int reg;
	pcireg_t data;

	/* Disable all legacy emulations. */
	data = pci_conf_read(sc->pc, sc->pt, CONF_LEGACY);
	data |= LEGACY_DISABLED;
	pci_conf_write(sc->pc, sc->pt, CONF_LEGACY, data);

	/* Disconnect from CHI. (Makes Dell inspiron 7500 work?)
	 * Enable posted write.
	 * Prefer PCI timing rather than that of ISA.
	 * Don't swap L/R. */
	data = pci_conf_read(sc->pc, sc->pt, CONF_MAESTRO);
	data |= MAESTRO_CHIBUS | MAESTRO_POSTEDWRITE | MAESTRO_DMA_PCITIMING;
	data &= ~MAESTRO_SWAP_LR;
	pci_conf_write(sc->pc, sc->pt, CONF_MAESTRO, data);
	/* Reset direct sound. */
	bus_space_write_2(sc->iot, sc->ioh, PORT_HOSTINT_CTRL,
	    HOSTINT_CTRL_DSOUND_RESET);
	DELAY(10000);	/* XXX - too long? */
	bus_space_write_2(sc->iot, sc->ioh, PORT_HOSTINT_CTRL, 0);
	DELAY(10000);

	/* Enable direct sound and hardware volume control interruptions. */
	bus_space_write_2(sc->iot, sc->ioh, PORT_HOSTINT_CTRL,
	    HOSTINT_CTRL_DSOUND_INT_ENABLED | HOSTINT_CTRL_HWVOL_ENABLED);

	/* Setup Wave Processor. */

	/* Enable WaveCache, set DMA base address. */
	wp_reg_write(sc, WPREG_WAVE_ROMRAM,
	    WP_WAVE_VIRTUAL_ENABLED | WP_WAVE_DRAM_ENABLED);
	bus_space_write_2(sc->iot, sc->ioh, PORT_WAVCACHE_CTRL,
	    WAVCACHE_ENABLED | WAVCACHE_WTSIZE_4MB);

	for (reg = WAVCACHE_PCMBAR; reg < WAVCACHE_PCMBAR + 4; reg++)
		wc_reg_write(sc, reg, 
			sc->physaddr >> WAVCACHE_BASEADDR_SHIFT);

	/* Setup Codec/Ringbus. */
	maestro_initcodec(sc);
	bus_space_write_4(sc->iot, sc->ioh, PORT_RINGBUS_CTRL,
	    RINGBUS_CTRL_RINGBUS_ENABLED | RINGBUS_CTRL_ACLINK_ENABLED);

	wp_reg_write(sc, WPREG_BASE, 0x8500);	/* Parallel I/O */
	ringbus_setdest(sc, RINGBUS_SRC_ADC,
	    RINGBUS_DEST_STEREO | RINGBUS_DEST_DSOUND_IN);
	ringbus_setdest(sc, RINGBUS_SRC_DSOUND,
	    RINGBUS_DEST_STEREO | RINGBUS_DEST_DAC);

	/* Setup ASSP. Needed for Dell Inspiron 7500? */
	bus_space_write_1(sc->iot, sc->ioh, PORT_ASSP_CTRL_B, 0x00);
	bus_space_write_1(sc->iot, sc->ioh, PORT_ASSP_CTRL_A, 0x03);
	bus_space_write_1(sc->iot, sc->ioh, PORT_ASSP_CTRL_C, 0x00);

	/* 
	 * Reset hw volume to a known value so that we may handle diffs
	 * off to AC'97.
	 */

	bus_space_write_1(sc->iot, sc->ioh, PORT_HWVOL_MASTER, MIDDLE_VOLUME);
	/* Setup GPIO if needed (NEC systems) */
	if (sc->flags & MAESTRO_FLAG_SETUPGPIO) {
		/* Matthew Braithwaite <matt@@braithwaite.net> reported that
		 * NEC Versa LX doesn't need GPIO operation. */
		bus_space_write_2(sc->iot, sc->ioh, 
		    PORT_GPIO_MASK, 0x9ff);
		bus_space_write_2(sc->iot, sc->ioh, PORT_GPIO_DIR,
		    bus_space_read_2(sc->iot, sc->ioh, PORT_GPIO_DIR) | 0x600);
		bus_space_write_2(sc->iot, sc->ioh, 
		    PORT_GPIO_DATA, 0x200);
	}
}

/* -----------------------------
 * Audio interface
 */

int
maestro_round_blocksize(void *self, int blk)
{
	return ((blk + 0xf) & ~0xf);
}

void *
maestro_malloc(void *arg, int dir, size_t size, int pool, int flags)
{
	struct maestro_softc *sc = (struct maestro_softc *)arg;

	return (salloc_alloc(sc->dmapool, size));
}

void
maestro_free(void *self, void *ptr, int pool)
{
	struct maestro_softc *sc = (struct maestro_softc *)self;

	salloc_free(sc->dmapool, ptr);
}

int
maestro_get_props(void *self)
{
	/* struct maestro_softc *sc = (struct maestro_softc *)self; */

	return (AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT); /* XXX */
}

int
maestro_set_port(void *self, mixer_ctrl_t *cp)
{
	struct ac97_codec_if *c = ((struct maestro_softc *)self)->codec_if;
	int rc;

	if (c) {
		/* interrupts use the mixer */
		mtx_enter(&audio_lock);
		rc = c->vtbl->mixer_set_port(c, cp);
		mtx_leave(&audio_lock);
		return rc;
	} else
		return (ENXIO);
}

int
maestro_get_port(void *self, mixer_ctrl_t *cp)
{
	struct ac97_codec_if *c = ((struct maestro_softc *)self)->codec_if;
	int rc;

	if (c) {
		/* interrupts use the mixer */
		mtx_enter(&audio_lock);
		rc = c->vtbl->mixer_get_port(c, cp);
		mtx_leave(&audio_lock);
		return rc;
	} else
		return (ENXIO);
}

int
maestro_query_devinfo(void *self, mixer_devinfo_t *cp)
{
	struct ac97_codec_if *c = ((struct maestro_softc *)self)->codec_if;
	int rc;

	if (c)  {
		/* interrupts use the mixer */
		mtx_enter(&audio_lock);
		rc = c->vtbl->query_devinfo(c, cp);
		mtx_leave(&audio_lock);
		return rc;
	} else
		return (ENXIO);
}

#define UNUSED __attribute__((unused))

void
maestro_set_speed(struct maestro_channel *ch, u_long *prate)
{
	ch->speed = *prate;
	if ((ch->mode & (MAESTRO_8BIT | MAESTRO_STEREO)) == MAESTRO_8BIT)
		ch->speed /= 2;
		
	/* special common case */
	if (ch->speed == 48000) {
		ch->dv = 0x10000;
	} else {
		/* compute 16 bits fixed point value of speed/48000,
		 * being careful not to overflow */
		 ch->dv = (((ch->speed % 48000) << 16U) + 24000) / 48000
		    + ((ch->speed / 48000) << 16U);
		/* And this is the real rate obtained */
		ch->speed = (ch->dv >> 16U) * 48000 + 
		    (((ch->dv & 0xffff)*48000)>>16U);
	}
	*prate = ch->speed;
	if ((ch->mode & (MAESTRO_8BIT | MAESTRO_STEREO)) == MAESTRO_8BIT)
		*prate *= 2;
}

u_int
maestro_calc_timer_freq(struct maestro_channel *ch)
{
	u_int	ss = 2;

	if (ch->mode & MAESTRO_8BIT)
		ss = 1;
	return (ch->speed * ss) / ch->blocksize;
}

void
maestro_update_timer(struct maestro_softc *sc)
{
	u_int freq = 0;
	u_int n;

	if (sc->play.mode & MAESTRO_RUNNING)
		freq = maestro_calc_timer_freq(&sc->play);
	if (sc->record.mode & MAESTRO_RUNNING) {
		n = maestro_calc_timer_freq(&sc->record);
		if (freq < n)
			freq = n;
	}
	if (freq) {
		wp_settimer(sc, freq);
		wp_starttimer(sc);
    	} else
		wp_stoptimer(sc);
}


int
maestro_set_params(void *hdl, int setmode, int usemode,
    struct audio_params *play, struct audio_params *rec)
{
	struct maestro_softc *sc = (struct maestro_softc *)hdl;
	
	if ((setmode & AUMODE_PLAY) == 0)
		return (0);

	/* Disallow parameter change on a running audio for now */
	if (sc->play.mode & MAESTRO_RUNNING)
		return (EINVAL);

	if (play->sample_rate < 4000)
		play->sample_rate = 4000;
	else if (play->sample_rate > 48000)
		play->sample_rate = 48000;

	if (play->channels > 2)
		play->channels = 2;

	sc->play.mode = MAESTRO_PLAY;
	if (play->channels == 2)
		sc->play.mode |= MAESTRO_STEREO;

	if (play->precision == 8) {
		sc->play.mode |= MAESTRO_8BIT;
		if (play->encoding == AUDIO_ENCODING_ULINEAR_LE ||
		    play->encoding == AUDIO_ENCODING_ULINEAR_BE)
		    sc->play.mode |= MAESTRO_UNSIGNED;
	}
	else if (play->encoding != AUDIO_ENCODING_SLINEAR_LE)
		return (EINVAL);

	play->bps = AUDIO_BPS(play->precision);
	play->msb = 1;

	maestro_set_speed(&sc->play, &play->sample_rate);
	return (0);
}

int
maestro_open(void *hdl, int flags)
{
	struct maestro_softc *sc = (struct maestro_softc *)hdl;
	DPRINTF(("%s: open(%d)\n", sc->dev.dv_xname, flags));

/* XXX work around VM brokeness */
#if 0
	if ((OFLAGS(flags) & O_ACCMODE) != O_WRONLY)
		return (EINVAL);
#endif
	sc->play.mode = MAESTRO_PLAY;
	sc->record.mode = 0;
#ifdef AUDIO_DEBUG
	maestrointr_called = 0;
	maestrodma_effective = 0;
#endif
	return (0);
}

void
maestro_close(void *hdl)
{
	struct maestro_softc *sc UNUSED = (struct maestro_softc *)hdl;
	/* nothing to do */
}


void
maestro_channel_stop(struct maestro_channel *ch)
{
	wp_apu_write(ch->sc, ch->num, APUREG_APUTYPE,
	    APUTYPE_INACTIVE << APU_APUTYPE_SHIFT);
	if (ch->mode & MAESTRO_STEREO)
	    wp_apu_write(ch->sc, ch->num+1, APUREG_APUTYPE,
		APUTYPE_INACTIVE << APU_APUTYPE_SHIFT);
	/* four channels for record... */
	if (ch->mode & MAESTRO_PLAY)
		return;
	wp_apu_write(ch->sc, ch->num+2, APUREG_APUTYPE,
	    APUTYPE_INACTIVE << APU_APUTYPE_SHIFT);
	if (ch->mode & MAESTRO_STEREO)
	    wp_apu_write(ch->sc, ch->num+3, APUREG_APUTYPE,
		APUTYPE_INACTIVE << APU_APUTYPE_SHIFT);
	
}

int
maestro_halt_input(void *hdl)
{
	struct maestro_softc *sc = (struct maestro_softc *)hdl;

	mtx_enter(&audio_lock);
	maestro_channel_stop(&sc->record);
	sc->record.mode &= ~MAESTRO_RUNNING;
	maestro_update_timer(sc);
	mtx_leave(&audio_lock);
	return 0;
}

int
maestro_halt_output(void *hdl)
{
	struct maestro_softc *sc = (struct maestro_softc *)hdl;

	mtx_enter(&audio_lock);
	maestro_channel_stop(&sc->play);
	sc->play.mode &= ~MAESTRO_RUNNING;
	maestro_update_timer(sc);
	mtx_leave(&audio_lock);
	return 0;
}

int
maestro_trigger_input(void *hdl, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct maestro_softc *sc = (struct maestro_softc *)hdl;

	mtx_enter(&audio_lock);
	sc->record.mode |= MAESTRO_RUNNING;
	sc->record.blocksize = blksize;

	maestro_channel_start(&sc->record);

	sc->record.threshold = sc->record.start;
	maestro_update_timer(sc);
	mtx_leave(&audio_lock);
	return 0;
}

void
maestro_channel_start(struct maestro_channel *ch)
{
	struct maestro_softc *sc = ch->sc;
	int n = ch->num;
	int aputype;
	wcreg_t wcreg = (sc->physaddr - 16) & WAVCACHE_CHCTL_ADDRTAG_MASK;

	switch(ch->mode & (MAESTRO_STEREO | MAESTRO_8BIT)) {
	case 0:
		aputype = APUTYPE_16BITLINEAR;
		break;
	case MAESTRO_STEREO:
		aputype = APUTYPE_16BITSTEREO;
		break;
	case MAESTRO_8BIT:
		aputype = APUTYPE_8BITLINEAR;
		break;
	case MAESTRO_8BIT|MAESTRO_STEREO:
		aputype = APUTYPE_8BITSTEREO;
		break;
	}
	if (ch->mode & MAESTRO_UNSIGNED)
		wcreg |= WAVCACHE_CHCTL_U8;
	if ((ch->mode & MAESTRO_STEREO) == 0) {
		DPRINTF(("Setting mono parameters\n"));
		wp_apu_write(sc, n, APUREG_WAVESPACE, ch->wpwa & 0xff00);
		wp_apu_write(sc, n, APUREG_CURPTR, ch->current);
		wp_apu_write(sc, n, APUREG_ENDPTR, ch->end);
		wp_apu_write(sc, n, APUREG_LOOPLEN, ch->end - ch->start);
		wp_apu_write(sc, n, APUREG_AMPLITUDE, 0xe800);
		wp_apu_write(sc, n, APUREG_POSITION, 0x8f00
		    | (RADIUS_CENTERCIRCLE << APU_RADIUS_SHIFT)
		    | (PAN_FRONT << APU_PAN_SHIFT));
		wp_apu_write(sc, n, APUREG_FREQ_LOBYTE, APU_plus6dB
		    | ((ch->dv & 0xff) << APU_FREQ_LOBYTE_SHIFT));
		wp_apu_write(sc, n, APUREG_FREQ_HIWORD, ch->dv >> 8);
		wc_ctrl_write(sc, n, wcreg);
		wp_apu_write(sc, n, APUREG_APUTYPE,
		    (aputype << APU_APUTYPE_SHIFT) | APU_DMA_ENABLED | 0xf);
	} else {
		wcreg |= WAVCACHE_CHCTL_STEREO;
		DPRINTF(("Setting stereo parameters\n"));
		wp_apu_write(sc, n+1, APUREG_WAVESPACE, ch->wpwa & 0xff00);
		wp_apu_write(sc, n+1, APUREG_CURPTR, ch->current);
		wp_apu_write(sc, n+1, APUREG_ENDPTR, ch->end);
		wp_apu_write(sc, n+1, APUREG_LOOPLEN, ch->end - ch->start);
		wp_apu_write(sc, n+1, APUREG_AMPLITUDE, 0xe800);
		wp_apu_write(sc, n+1, APUREG_POSITION, 0x8f00
		    | (RADIUS_CENTERCIRCLE << APU_RADIUS_SHIFT)
		    | (PAN_LEFT << APU_PAN_SHIFT));
		wp_apu_write(sc, n+1, APUREG_FREQ_LOBYTE, APU_plus6dB
		    | ((ch->dv & 0xff) << APU_FREQ_LOBYTE_SHIFT));
		wp_apu_write(sc, n+1, APUREG_FREQ_HIWORD, ch->dv >> 8);
		if (ch->mode & MAESTRO_8BIT)
			wp_apu_write(sc, n, APUREG_WAVESPACE, 
			    ch->wpwa & 0xff00);
		    else
			wp_apu_write(sc, n, APUREG_WAVESPACE, 
			    (ch->wpwa|(APU_STEREO >> 1)) & 0xff00);
		wp_apu_write(sc, n, APUREG_CURPTR, ch->current);
		wp_apu_write(sc, n, APUREG_ENDPTR, ch->end);
		wp_apu_write(sc, n, APUREG_LOOPLEN, ch->end - ch->start);
		wp_apu_write(sc, n, APUREG_AMPLITUDE, 0xe800);
		wp_apu_write(sc, n, APUREG_POSITION, 0x8f00
		    | (RADIUS_CENTERCIRCLE << APU_RADIUS_SHIFT)
		    | (PAN_RIGHT << APU_PAN_SHIFT));
		wp_apu_write(sc, n, APUREG_FREQ_LOBYTE, APU_plus6dB
		    | ((ch->dv & 0xff) << APU_FREQ_LOBYTE_SHIFT));
		wp_apu_write(sc, n, APUREG_FREQ_HIWORD, ch->dv >> 8);
		wc_ctrl_write(sc, n, wcreg);
		wc_ctrl_write(sc, n+1, wcreg);
		wp_apu_write(sc, n, APUREG_APUTYPE,
		    (aputype << APU_APUTYPE_SHIFT) | APU_DMA_ENABLED | 0xf);
		wp_apu_write(sc, n+1, APUREG_APUTYPE,
		    (aputype << APU_APUTYPE_SHIFT) | APU_DMA_ENABLED | 0xf);
	}
}

int
maestro_trigger_output(void *hdl, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct maestro_softc *sc = (struct maestro_softc *)hdl;
	u_int offset = ((caddr_t)start - sc->dmabase) >> 1;
	u_int size = ((char *)end - (char *)start) >> 1;

	mtx_enter(&audio_lock);
	sc->play.mode |= MAESTRO_RUNNING;
	sc->play.wpwa = APU_USE_SYSMEM | (offset >> 8);
	DPRINTF(("maestro_trigger_output: start=%p, end=%p, blksize=%x ",
		start, end, blksize));
    	DPRINTF(("offset = %x, size=%x\n", offset, size));

	sc->play.intr = intr;
	sc->play.intr_arg = arg;
	sc->play.blocksize = blksize;
	sc->play.end = offset+size;
	sc->play.start = offset;
	sc->play.current = sc->play.start;
	if ((sc->play.mode & (MAESTRO_STEREO | MAESTRO_8BIT)) == MAESTRO_STEREO) {
		sc->play.wpwa >>= 1;
		sc->play.start >>= 1;
		sc->play.end >>= 1;
		sc->play.blocksize >>= 1;
	}
	maestro_channel_start(&sc->play);

	sc->play.threshold = sc->play.start;
	maestro_update_timer(sc);
	mtx_leave(&audio_lock);
	return 0;
}

/* -----------------------------
 * Codec interface
 */

enum ac97_host_flags
maestro_codec_flags(void *self)
{
	return AC97_HOST_DONT_READ;
}

int
maestro_read_codec(void *self, u_int8_t regno, u_int16_t *datap)
{
	struct maestro_softc *sc = (struct maestro_softc *)self;
	int t;

	/* We have to wait for a SAFE time to write addr/data */
	for (t = 0; t < 20; t++) {
		if ((bus_space_read_1(sc->iot, sc->ioh, PORT_CODEC_STAT)
		    & CODEC_STAT_MASK) != CODEC_STAT_PROGLESS)
			break;
		DELAY(2);	/* 20.8us / 13 */
	}
	if (t == 20)
		printf("%s: maestro_read_codec() PROGLESS timed out.\n",
		    sc->dev.dv_xname);
		/* XXX return 1 */

	bus_space_write_1(sc->iot, sc->ioh, PORT_CODEC_CMD,
	    CODEC_CMD_READ | regno);
	DELAY(21);	/* AC97 cycle = 20.8usec */

	/* Wait for data retrieve */
	for (t = 0; t < 20; t++) {
		if ((bus_space_read_1(sc->iot, sc->ioh, PORT_CODEC_STAT)
		    & CODEC_STAT_MASK) == CODEC_STAT_RW_DONE)
			break;
		DELAY(2);	/* 20.8us / 13 */
	}
	if (t == 20)
		/* Timed out, but perform dummy read. */
		printf("%s: maestro_read_codec() RW_DONE timed out.\n",
		    sc->dev.dv_xname);

	*datap = bus_space_read_2(sc->iot, sc->ioh, PORT_CODEC_REG);
	return 0;
}

int
maestro_write_codec(void *self, u_int8_t regno, u_int16_t data)
{
	struct maestro_softc *sc = (struct maestro_softc *)self;
	int t;

	/* We have to wait for a SAFE time to write addr/data */
	for (t = 0; t < 20; t++) {
		if ((bus_space_read_1(sc->iot, sc->ioh, PORT_CODEC_STAT)
		    & CODEC_STAT_MASK) != CODEC_STAT_PROGLESS)
			break;
		DELAY(2);	/* 20.8us / 13 */
	}
	if (t == 20) {
		/* Timed out. Abort writing. */
		printf("%s: maestro_write_codec() PROGLESS timed out.\n",
		    sc->dev.dv_xname);
		return 1;
	}

	bus_space_write_2(sc->iot, sc->ioh, PORT_CODEC_REG, data);
	bus_space_write_1(sc->iot, sc->ioh, PORT_CODEC_CMD,
	    CODEC_CMD_WRITE | regno);

	return 0;
}

int
maestro_attach_codec(void *self, struct ac97_codec_if *cif)
{
	struct maestro_softc *sc = (struct maestro_softc *)self;

	sc->codec_if = cif;
	return 0;
}

void
maestro_reset_codec(void *self UNUSED)
{
}

void
maestro_initcodec(void *self)
{
	struct maestro_softc *sc = (struct maestro_softc *)self;
	u_int16_t data;

	if (bus_space_read_4(sc->iot, sc->ioh, PORT_RINGBUS_CTRL)
	    & RINGBUS_CTRL_ACLINK_ENABLED) {
		bus_space_write_4(sc->iot, sc->ioh, PORT_RINGBUS_CTRL, 0);
		DELAY(104);	/* 20.8us * (4 + 1) */
	}
	/* XXX - 2nd codec should be looked at. */
	bus_space_write_4(sc->iot, sc->ioh,
	    PORT_RINGBUS_CTRL, RINGBUS_CTRL_AC97_SWRESET);
	DELAY(2);
	bus_space_write_4(sc->iot, sc->ioh,
	    PORT_RINGBUS_CTRL, RINGBUS_CTRL_ACLINK_ENABLED);
	DELAY(21);

	maestro_read_codec(sc, 0, &data);
	if ((bus_space_read_1(sc->iot, sc->ioh, PORT_CODEC_STAT)
	    & CODEC_STAT_MASK) != 0) {
		bus_space_write_4(sc->iot, sc->ioh,
		    PORT_RINGBUS_CTRL, 0);
		DELAY(21);

		/* Try cold reset. */
		printf("%s: resetting codec\n", sc->dev.dv_xname);

		data = bus_space_read_2(sc->iot, sc->ioh, PORT_GPIO_DIR);
		if (pci_conf_read(sc->pc, sc->pt, 0x58) & 1)
			data |= 0x10;
		data |= 0x009 &
		    ~bus_space_read_2(sc->iot, sc->ioh, PORT_GPIO_DATA);
		bus_space_write_2(sc->iot, sc->ioh,
		    PORT_GPIO_MASK, 0xff6);
		bus_space_write_2(sc->iot, sc->ioh,
		    PORT_GPIO_DIR, data | 0x009);
		bus_space_write_2(sc->iot, sc->ioh,
		    PORT_GPIO_DATA, 0x000);
		DELAY(2);
		bus_space_write_2(sc->iot, sc->ioh,
		    PORT_GPIO_DATA, 0x001);
		DELAY(1);
		bus_space_write_2(sc->iot, sc->ioh,
		    PORT_GPIO_DATA, 0x009);
		DELAY(500000);
		bus_space_write_2(sc->iot, sc->ioh,
		    PORT_GPIO_DIR, data);
		DELAY(84);	/* 20.8us * 4 */
		bus_space_write_4(sc->iot, sc->ioh,
		    PORT_RINGBUS_CTRL, RINGBUS_CTRL_ACLINK_ENABLED);
		DELAY(21);
	}

	/* Check the codec to see is still busy */
	if ((bus_space_read_1(sc->iot, sc->ioh, PORT_CODEC_STAT) & 
	    CODEC_STAT_MASK) != 0) {
		printf("%s: codec failure\n", sc->dev.dv_xname);
	}
}

/* -----------------------------
 * Power management interface
 */

int
maestro_activate(struct device *self, int act)
{
	struct maestro_softc *sc = (struct maestro_softc *)self;

	switch (act) {
	case DVACT_SUSPEND:
		/* Power down device on shutdown. */
		DPRINTF(("maestro: power down\n"));
		if (sc->record.mode & MAESTRO_RUNNING) {
		    	sc->record.current = wp_apu_read(sc, sc->record.num, APUREG_CURPTR);
			maestro_channel_stop(&sc->record);
		}
		if (sc->play.mode & MAESTRO_RUNNING) {
		    	sc->play.current = wp_apu_read(sc, sc->play.num, APUREG_CURPTR);
			maestro_channel_stop(&sc->play);
		}

		wp_stoptimer(sc);

		/* Power down everything except clock. */
		bus_space_write_2(sc->iot, sc->ioh, PORT_HOSTINT_CTRL, 0);
		maestro_write_codec(sc, AC97_REG_POWER, 0xdf00);
		DELAY(20);
		bus_space_write_4(sc->iot, sc->ioh, PORT_RINGBUS_CTRL, 0);
		DELAY(1);
		break;
	case DVACT_RESUME:
		/* Power up device on resume. */
		DPRINTF(("maestro: power resume\n"));
		maestro_init(sc);
		/* Restore codec settings */
		if (sc->codec_if)
			sc->codec_if->vtbl->restore_ports(sc->codec_if);
		if (sc->play.mode & MAESTRO_RUNNING)
			maestro_channel_start(&sc->play);
		if (sc->record.mode & MAESTRO_RUNNING)
			maestro_channel_start(&sc->record);
		maestro_update_timer(sc);
		break;
	}
	return 0;
}

void
maestro_channel_advance_dma(struct maestro_channel *ch)
{
	wpreg_t pos;
#ifdef AUDIO_DEBUG
	maestrointr_called++;
#endif
	for (;;) {
		pos = wp_apu_read(ch->sc, ch->num, APUREG_CURPTR);
		/* Are we still processing the current dma block ? */
		if (pos >= ch->threshold && 
		    pos < ch->threshold + ch->blocksize/2)
			break;
		ch->threshold += ch->blocksize/2;
		if (ch->threshold >= ch->end)
			ch->threshold = ch->start;
		(*ch->intr)(ch->intr_arg);
#ifdef AUDIO_DEBUG
		maestrodma_effective++;
#endif
	}

#ifdef AUDIO_DEBUG
	if (maestrodebug && maestrointr_called % 64 == 0)
		printf("maestro: dma advanced %lu for %lu calls\n", 
			maestrodma_effective, maestrointr_called);
#endif
}

/* Some maestro makes sometimes get desynchronized in stereo mode. */
void
maestro_channel_suppress_jitter(struct maestro_channel *ch)
{
	int cp, diff;

	/* Verify that both channels are not too far off. */
	cp = wp_apu_read(ch->sc, ch->num, APUREG_CURPTR);
	diff = wp_apu_read(ch->sc, ch->num+1, APUREG_CURPTR) - cp;
	if (diff > 4 || diff < -4)
		/* Otherwise, directly resynch the 2nd channel. */
		bus_space_write_2(ch->sc->iot, ch->sc->ioh,
		    PORT_DSP_DATA, cp);
}

/* -----------------------------
 * Interrupt handler interface
 */
int
maestro_intr(void *arg)
{
	struct maestro_softc *sc = (struct maestro_softc *)arg;
	u_int16_t status;

	status = bus_space_read_1(sc->iot, sc->ioh, PORT_HOSTINT_STAT);
	if (status == 0)
		return 0;	/* Not for us? */

	mtx_enter(&audio_lock);

	/* Acknowledge all. */
	bus_space_write_2(sc->iot, sc->ioh, PORT_INT_STAT, 1);
	bus_space_write_1(sc->iot, sc->ioh, PORT_HOSTINT_STAT, status);

	/* Hardware volume support */
	if (status & HOSTINT_STAT_HWVOL && sc->codec_if != NULL) {
		int n, i, delta, v;
		mixer_ctrl_t hwvol;

		n = bus_space_read_1(sc->iot, sc->ioh, PORT_HWVOL_MASTER);
		/* Special case: Mute key */
		if (n & 0x11) {
			hwvol.type = AUDIO_MIXER_ENUM;
			hwvol.dev = 
			    sc->codec_if->vtbl->get_portnum_by_name(sc->codec_if,
				AudioCoutputs, AudioNmaster, AudioNmute);
			sc->codec_if->vtbl->mixer_get_port(sc->codec_if, &hwvol);
			hwvol.un.ord = !hwvol.un.ord;
		} else {
			hwvol.type = AUDIO_MIXER_VALUE;
			hwvol.un.value.num_channels = 2;
			hwvol.dev = 
			    sc->codec_if->vtbl->get_portnum_by_name(
			    	sc->codec_if, AudioCoutputs, AudioNmaster, 
				    NULL);
			sc->codec_if->vtbl->mixer_get_port(sc->codec_if, &hwvol);
			/* XXX AC'97 yields five bits for master volume. */
			delta = (n - MIDDLE_VOLUME)/STEP_VOLUME * 8;
			for (i = 0; i < hwvol.un.value.num_channels; i++) {
				v = ((int)hwvol.un.value.level[i]) + delta;
				if (v < 0)
					v = 0;
				else if (v > 255)
					v = 255;
				hwvol.un.value.level[i] = v;
			}
		}
		sc->codec_if->vtbl->mixer_set_port(sc->codec_if, &hwvol);
		/* Reset to compute next diffs */
		bus_space_write_1(sc->iot, sc->ioh, PORT_HWVOL_MASTER, 
		    MIDDLE_VOLUME);
	}

	if (sc->play.mode & MAESTRO_RUNNING) {
		maestro_channel_advance_dma(&sc->play);
		if (sc->play.mode & MAESTRO_STEREO)
			maestro_channel_suppress_jitter(&sc->play);
	}

	if (sc->record.mode & MAESTRO_RUNNING)
		maestro_channel_advance_dma(&sc->record);

	mtx_leave(&audio_lock);
	return 1;
}

/* -----------------------------
 * Hardware interface
 */

/* Codec/Ringbus */

void
ringbus_setdest(struct maestro_softc *sc, int src, int dest)
{
	u_int32_t	data;

	data = bus_space_read_4(sc->iot, sc->ioh, PORT_RINGBUS_CTRL);
	data &= ~(0xfU << src);
	data |= (0xfU & dest) << src;
	bus_space_write_4(sc->iot, sc->ioh, PORT_RINGBUS_CTRL, data);
}

/* Wave Processor */

wpreg_t
wp_reg_read(struct maestro_softc *sc, int reg)
{
	bus_space_write_2(sc->iot, sc->ioh, PORT_DSP_INDEX, reg);
	return bus_space_read_2(sc->iot, sc->ioh, PORT_DSP_DATA);
}

void
wp_reg_write(struct maestro_softc *sc, int reg, wpreg_t data)
{
	bus_space_write_2(sc->iot, sc->ioh, PORT_DSP_INDEX, reg);
	bus_space_write_2(sc->iot, sc->ioh, PORT_DSP_DATA, data);
}

static void
apu_setindex(struct maestro_softc *sc, int reg)
{
	int t;

	wp_reg_write(sc, WPREG_CRAM_PTR, reg);
	/* Sometimes WP fails to set apu register index. */
	for (t = 0; t < 1000; t++) {
		if (bus_space_read_2(sc->iot, sc->ioh,
		    PORT_DSP_DATA) == reg)
			break;
		bus_space_write_2(sc->iot, sc->ioh, PORT_DSP_DATA, reg);
	}
	if (t == 1000)
		printf("%s: apu_setindex() timeout\n", sc->dev.dv_xname);
}

wpreg_t
wp_apu_read(struct maestro_softc *sc, int ch, int reg)
{
	wpreg_t ret;

	apu_setindex(sc, ((unsigned)ch << 4) + reg);
	ret = wp_reg_read(sc, WPREG_DATA_PORT);
	return ret;
}

void
wp_apu_write(struct maestro_softc *sc, int ch, int reg, wpreg_t data)
{
	int t;

	apu_setindex(sc, ((unsigned)ch << 4) + reg);
	wp_reg_write(sc, WPREG_DATA_PORT, data);
	for (t = 0; t < 1000; t++) {
		if (bus_space_read_2(sc->iot, sc->ioh, PORT_DSP_DATA) == data)
			break;
		bus_space_write_2(sc->iot, sc->ioh, PORT_DSP_DATA, data);
	}
	if (t == 1000)
		printf("%s: wp_apu_write() timeout\n", sc->dev.dv_xname);
}

void
wp_settimer(struct maestro_softc *sc, u_int freq)
{
	u_int clock = 48000 << 2;
	u_int prescale = 0, divide = (freq != 0) ? (clock / freq) : ~0;

	if (divide < 4)
		divide = 4;
	else if (divide > 32 << 8)
		divide = 32 << 8;

	for (; divide > 32 << 1; divide >>= 1)
		prescale++;
	divide = (divide + 1) >> 1;

	for (; prescale < 7 && divide > 2 && !(divide & 1); divide >>= 1)
		prescale++;

	wp_reg_write(sc, WPREG_TIMER_ENABLE, 0);
	wp_reg_write(sc, WPREG_TIMER_FREQ,
	    (prescale << WP_TIMER_FREQ_PRESCALE_SHIFT) | (divide - 1));
	wp_reg_write(sc, WPREG_TIMER_ENABLE, 1);
}

void
wp_starttimer(struct maestro_softc *sc)
{
	wp_reg_write(sc, WPREG_TIMER_START, 1);
}

void
wp_stoptimer(struct maestro_softc *sc)
{
	wp_reg_write(sc, WPREG_TIMER_START, 0);
	bus_space_write_2(sc->iot, sc->ioh, PORT_INT_STAT, 1);
}

/* WaveCache */

wcreg_t
wc_reg_read(struct maestro_softc *sc, int reg)
{
	bus_space_write_2(sc->iot, sc->ioh, PORT_WAVCACHE_INDEX, reg);
	return bus_space_read_2(sc->iot, sc->ioh, PORT_WAVCACHE_DATA);
}

void
wc_reg_write(struct maestro_softc *sc, int reg, wcreg_t data)
{
	bus_space_write_2(sc->iot, sc->ioh, PORT_WAVCACHE_INDEX, reg);
	bus_space_write_2(sc->iot, sc->ioh, PORT_WAVCACHE_DATA, data);
}

u_int16_t
wc_ctrl_read(struct maestro_softc *sc, int ch)
{
	return wc_reg_read(sc, ch << 3);
}

void
wc_ctrl_write(struct maestro_softc *sc, int ch, wcreg_t data)
{
	wc_reg_write(sc, ch << 3, data);
}

/* -----------------------------
 * Simple zone allocator.
 * (All memory allocated in advance)
 */

salloc_t
salloc_new(caddr_t addr, size_t size, int nzones)
{
	struct salloc_pool *pool;
	struct salloc_zone *space;
	int i;

	pool = malloc(sizeof *pool + nzones * sizeof pool->zones[0],
	    M_TEMP, M_NOWAIT);
	if (pool == NULL)
		return NULL;
	SLIST_INIT(&pool->free);
	SLIST_INIT(&pool->used);
	SLIST_INIT(&pool->spare);
	/* Espie says the following line is obvious */
	pool->zones = (struct salloc_zone *)(pool + 1);
	for (i = 1; i < nzones; i++)
		SLIST_INSERT_HEAD(&pool->spare, &pool->zones[i], link);
	space = &pool->zones[0];
	space->addr = addr;
	space->size = size;
	SLIST_INSERT_HEAD(&pool->free, space, link);
	return pool;
}

void
salloc_destroy(salloc_t pool)
{
	free(pool, M_TEMP, 0);
}

void
salloc_insert(salloc_t pool, struct salloc_head *head, struct salloc_zone *zone,
    int merge)
{
	struct salloc_zone *prev, *next;

	/* 
	 * Insert a zone into an ordered list of zones, possibly
	 * merging adjacent zones.
	 */
	prev = NULL;
	SLIST_FOREACH(next, head, link) {
		if (next->addr > zone->addr) 
			break;
		prev = next;
	}

	if (merge && prev && prev->addr + prev->size == zone->addr) {
		prev->size += zone->size;
		SLIST_INSERT_HEAD(&pool->spare, zone, link);
		zone = prev;
	} else if (prev)
		SLIST_INSERT_AFTER(prev, zone, link);
	else
		SLIST_INSERT_HEAD(head, zone, link);
	if (merge && next && zone->addr + zone->size == next->addr) {
		zone->size += next->size;
		SLIST_REMOVE(head, next, salloc_zone, link);
		SLIST_INSERT_HEAD(&pool->spare, next, link);
	}
}

caddr_t
salloc_alloc(salloc_t pool, size_t size)
{
	struct salloc_zone *zone, *uzone;

	SLIST_FOREACH(zone, &pool->free, link) 
		if (zone->size >= size)
			break;
	if (zone == NULL)
		return NULL;
	if (zone->size == size) {
		SLIST_REMOVE(&pool->free, zone, salloc_zone, link);
		uzone = zone;
	} else {
		uzone = SLIST_FIRST(&pool->spare);
		if (uzone == NULL)
			return NULL;		/* XXX */
		SLIST_REMOVE_HEAD(&pool->spare, link);
		uzone->size = size;
		uzone->addr = zone->addr;
		zone->size -= size;
		zone->addr += size;
	}
	salloc_insert(pool, &pool->used, uzone, 0);
	return uzone->addr;
}

void
salloc_free(salloc_t pool, caddr_t addr)
{
	struct salloc_zone *zone;

	SLIST_FOREACH(zone, &pool->used, link) 
		if (zone->addr == addr)
			break;
#ifdef DIAGNOSTIC
	if (zone == NULL)
		panic("salloc_free: freeing unallocated memory");
#endif
	SLIST_REMOVE(&pool->used, zone, salloc_zone, link);
	salloc_insert(pool, &pool->free, zone, 1);
}
@


1.41
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.38 2014/09/13 16:06:37 doug Exp $	*/
a443 1
	struct audio_device	*sc_audev;
a473 1
int	maestro_getdev(void *, struct audio_device *);
a542 1
	maestro_getdev,
a554 4
struct audio_device maestro_audev = {
	"ESS Maestro", "", "maestro"
};

a611 1
	sc->sc_audev = &maestro_audev;
a855 9
}

int
maestro_getdev(void *self, struct audio_device *retp)
{
	struct maestro_softc *sc = (struct maestro_softc *)self;

	*retp = *sc->sc_audev;
	return 0;
@


1.40
log
@Unbreak build when AUDIO_DEBUG is defined: fix printf(9) format
mistakes.
@
text
@a469 1
int	maestro_query_encoding(void *, struct audio_encoding *);
a471 1
void	maestro_get_default_params(void *, int, struct audio_params *);
a480 1
paddr_t	maestro_mappage(void *, void *, off_t, int);
a534 2
	NULL,
	maestro_query_encoding,
a552 1
	maestro_mappage,
d555 1
a555 2
	maestro_trigger_input,
	maestro_get_default_params
a857 11
paddr_t
maestro_mappage(void *self, void *mem, off_t off, int prot)
{
	struct maestro_softc *sc = (struct maestro_softc *)self;

	if (off < 0)
		return -1;
	return bus_dmamem_mmap(sc->dmat, &sc->dmaseg, 1,
		off, prot, BUS_DMA_WAITOK);
}

a920 21
}

struct audio_encoding maestro_tab[] = { 
	{0, AudioEslinear_le, AUDIO_ENCODING_SLINEAR_LE, 16, 2, 1, 0},
	{1, AudioEslinear, AUDIO_ENCODING_SLINEAR, 8, 1, 1, 0},
	{2, AudioEulinear, AUDIO_ENCODING_ULINEAR, 8, 1, 1, 0}
};

int
maestro_query_encoding(void *hdl, struct audio_encoding *fp)
{
	if (fp->index < 0 || fp->index >= lengthof(maestro_tab))
		return (EINVAL);
	*fp = maestro_tab[fp->index];
	return (0);
}

void
maestro_get_default_params(void *addr, int mode, struct audio_params *params)
{
	ac97_get_default_params(params);
@


1.39
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1241 1
a1241 1
	DPRINTF(("maestro_trigger_output: start=%x, end=%x, blksize=%x ",
@


1.38
log
@Replace all queue *_END macro calls except CIRCLEQ_END with NULL.

CIRCLEQ_* is deprecated and not called in the tree.  The other queue types
have *_END macros which were added for symmetry with CIRCLEQ_END.  They are
defined as NULL.  There's no reason to keep the other *_END macro calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.37 2014/07/12 18:48:52 tedu Exp $	*/
a61 2
#include <dev/mulaw.h>
#include <dev/auconv.h>
d944 1
a944 11
	{2, AudioEulinear, AUDIO_ENCODING_ULINEAR, 8, 1, 1, 0},
	{3, AudioEslinear_be, AUDIO_ENCODING_SLINEAR_BE, 16, 2, 1,
	    AUDIO_ENCODINGFLAG_EMULATED},
	{4, AudioEulinear_le, AUDIO_ENCODING_ULINEAR_LE, 16, 2, 1,
	    AUDIO_ENCODINGFLAG_EMULATED},
	{5, AudioEulinear_be, AUDIO_ENCODING_ULINEAR_BE, 16, 2, 1,
	    AUDIO_ENCODINGFLAG_EMULATED},
	{6, AudioEmulaw, AUDIO_ENCODING_ULAW, 8, 1, 1,
	    AUDIO_ENCODINGFLAG_EMULATED},
	{7, AudioEalaw, AUDIO_ENCODING_ALAW, 8, 1, 1,
	    AUDIO_ENCODINGFLAG_EMULATED}
a1036 2
	play->factor = 1;
	play->sw_code = NULL;
d1044 1
a1044 7
	if (play->encoding == AUDIO_ENCODING_ULAW) {
		play->factor = 2;
		play->sw_code = mulaw_to_slinear16_le;
	} else if (play->encoding == AUDIO_ENCODING_ALAW) {
		play->factor = 2;
		play->sw_code = alaw_to_slinear16_le;
	} else if (play->precision == 8) {
a1049 6
	else if (play->encoding == AUDIO_ENCODING_ULINEAR_LE)
		play->sw_code = change_sign16_le;
	else if (play->encoding == AUDIO_ENCODING_SLINEAR_BE)
		play->sw_code = swap_bytes;
	else if (play->encoding == AUDIO_ENCODING_ULINEAR_BE)
		play->sw_code = change_sign16_swap_bytes_le;
@


1.37
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.36 2013/11/15 16:46:27 brad Exp $	*/
d1822 1
a1822 1
	if (zone == SLIST_END(&pool->free))
d1850 1
a1850 1
	if (zone == SLIST_END(&pool->used))
@


1.36
log
@ansify some function definitions.
no functional change.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.35 2013/05/24 07:58:46 ratchov Exp $	*/
d1779 1
a1779 1
	free(pool, M_TEMP);
@


1.35
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.34 2013/05/15 08:29:24 ratchov Exp $	*/
d584 1
a584 2
maestro_get_flags(pa)
	struct pci_attach_args *pa;
d605 1
a605 4
maestro_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d616 1
a616 4
maestro_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d765 1
a765 2
maestro_init(sc)
	struct maestro_softc *sc;
d846 1
a846 3
maestro_round_blocksize(self, blk)
	void *self;
	int blk;
d852 1
a852 5
maestro_malloc(arg, dir, size, pool, flags)
	void *arg;
	int dir;
	size_t size;
	int pool, flags;
d860 1
a860 3
maestro_free(self, ptr, pool)
	void *self, *ptr;
	int pool;
d868 1
a868 4
maestro_mappage(self, mem, off, prot)
	void *self, *mem;
	off_t off;
	int prot;
d879 1
a879 2
maestro_get_props(self)
	void *self;
d887 1
a887 3
maestro_getdev(self, retp)
	void *self;
	struct audio_device *retp;
d896 1
a896 3
maestro_set_port(self, cp)
	void *self;
	mixer_ctrl_t *cp;
d912 1
a912 3
maestro_get_port(self, cp)
	void *self;
	mixer_ctrl_t *cp;
d928 1
a928 3
maestro_query_devinfo(self, cp)
	void *self;
	mixer_devinfo_t *cp;
d960 1
a960 3
maestro_query_encoding(hdl, fp)
	void *hdl;
	struct audio_encoding *fp;
d977 1
a977 3
maestro_set_speed(ch, prate)
	struct maestro_channel *ch;
	u_long *prate;
d1001 1
a1001 2
maestro_calc_timer_freq(ch)
	struct maestro_channel *ch;
d1011 1
a1011 2
maestro_update_timer(sc)
	struct maestro_softc *sc;
d1032 2
a1033 4
maestro_set_params(hdl, setmode, usemode, play, rec)
	void *hdl;
	int setmode, usemode;
	struct audio_params *play, *rec;
d1087 1
a1087 3
maestro_open(hdl, flags)
	void *hdl;
	int flags;
d1107 1
a1107 2
maestro_close(hdl)
	void *hdl;
d1115 1
a1115 2
maestro_channel_stop(ch)
	struct maestro_channel *ch;
d1134 1
a1134 2
maestro_halt_input(hdl)
	void *hdl;
d1147 1
a1147 2
maestro_halt_output(hdl)
	void *hdl;
d1160 2
a1161 7
maestro_trigger_input(hdl, start, end, blksize, intr, arg, param)
	void *hdl;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
d1178 1
a1178 2
maestro_channel_start(ch)
	struct maestro_channel *ch;
d1257 2
a1258 7
maestro_trigger_output(hdl, start, end, blksize, intr, arg, param)
	void *hdl;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
d1296 1
a1296 2
maestro_codec_flags(self)
	void *self;
d1302 1
a1302 4
maestro_read_codec(self, regno, datap)
	void *self;
	u_int8_t regno;
	u_int16_t *datap;
d1340 1
a1340 4
maestro_write_codec(self, regno, data)
	void *self;
	u_int8_t regno;
	u_int16_t data;
d1367 1
a1367 3
maestro_attach_codec(self, cif)
	void *self;
	struct ac97_codec_if *cif;
d1376 1
a1376 2
maestro_reset_codec(self)
	void *self UNUSED;
d1381 1
a1381 2
maestro_initcodec(self)
	void *self;
d1491 1
a1491 2
maestro_channel_advance_dma(ch)
	struct maestro_channel *ch;
d1521 1
a1521 2
maestro_channel_suppress_jitter(ch)
	struct maestro_channel *ch;
d1538 1
a1538 2
maestro_intr(arg)
	void *arg;
d1752 1
a1752 4
salloc_new(addr, size, nzones)
	caddr_t addr;
	size_t size;
	int nzones;
d1777 1
a1777 2
salloc_destroy(pool)
	salloc_t pool;
d1783 2
a1784 5
salloc_insert(pool, head, zone, merge)
	salloc_t pool;
	struct salloc_head *head;
	struct salloc_zone *zone;
	int merge;
d1815 1
a1815 3
salloc_alloc(pool, size)
	salloc_t pool;
	size_t size;
d1842 1
a1842 3
salloc_free(pool, addr)
	salloc_t pool;
	caddr_t addr;
@


1.34
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.33 2012/10/21 16:50:58 deraadt Exp $	*/
d648 2
a649 2
	sc->ih = pci_intr_establish(pc, ih, IPL_AUDIO, maestro_intr, sc,
	    sc->dev.dv_xname);
@


1.33
log
@repair pci powerstate handling.  The extra timeouts were not needed.
Furthermore, all the extra powering up and down caused resumes to not
work.
ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.32 2011/12/23 21:43:20 kettenis Exp $	*/
d923 1
d925 7
a931 3
	if (c)
		return (c->vtbl->mixer_set_port(c, cp));
	else
d941 1
d943 7
a949 3
	if (c)
		return (c->vtbl->mixer_get_port(c, cp));
	else
d959 1
d961 7
a967 3
	if (c)
		return (c->vtbl->query_devinfo(c, cp));
	else
d1178 2
d1183 1
d1193 1
d1197 1
d1212 1
d1220 1
a1313 1

d1316 2
d1340 1
a1340 1

d1614 2
d1668 1
@


1.32
log
@Use the generic PCI power management code instead of rolling our own.
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.31 2010/09/07 16:21:45 deraadt Exp $	*/
a657 1
	/* Rangers, power up */
a658 1
	DELAY(100000);
a757 2
	/* Power down. */
	pci_set_powerstate(pc, sc->pt, PCI_PMCSR_STATE_D3);
a1512 1
		pci_set_powerstate(sc->pc, sc->pt, PCI_PMCSR_STATE_D3);
a1516 2
		pci_set_powerstate(sc->pc, sc->pt, PCI_PMCSR_STATE_D0);
		DELAY(100000);
@


1.31
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.30 2010/08/27 18:50:57 deraadt Exp $	*/
a101 10
/* Power management */
#define	CONF_PM_PTR	0x34	/* BYTE R */
#define	PM_CID		0	/* BYTE R */
#define	PPMI_CID	1
#define	PM_CTRL		4	/* BYTE RW */
#define	PPMI_D0		0	/* Full power */
#define	PPMI_D1		1	/* Medium power */
#define	PPMI_D2		2	/* Low power */
#define	PPMI_D3		3	/* Turned off */

a501 1
void	maestro_power(struct maestro_softc *, int);
d659 1
a659 1
	maestro_power(sc, PPMI_D0);
d761 1
a761 1
	maestro_power(sc, PPMI_D3);
d1517 1
a1517 1
		maestro_power(sc, PPMI_D3);
d1522 1
a1522 1
		maestro_power(sc, PPMI_D0);
a1535 14
}

void
maestro_power(sc, status)
	struct maestro_softc *sc;
	int status;
{
	int data;

	/* Set the power state of the device. */
	data = pci_conf_read(sc->pc, sc->pt, CONF_PM_PTR);
	data = pci_conf_read(sc->pc, sc->pt, data);
	if (data == PPMI_CID)
		pci_conf_write(sc->pc, sc->pt, data + PM_CTRL, status);
@


1.30
log
@Since the changes in neo(4) work, it is very likely that the exact same
mechnical changes work in these drivers too.  Testing can occur after
this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.29 2010/07/15 03:43:11 jakemsr Exp $	*/
a457 1
	void			*powerhook;
a512 1
void	maestro_powerhook(int, void *);
a767 4

	/* Hook power changes */
	sc->powerhook = powerhook_establish(maestro_powerhook, sc);

a1546 6
}

void
maestro_powerhook(int why, void *v)
{
	maestro_activate(v, why);
@


1.29
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.28 2010/04/08 00:23:53 tedu Exp $	*/
d478 1
d546 2
a547 1
	sizeof (struct maestro_softc), maestro_match, maestro_attach
a771 1
	sc->suspend = PWR_RESUME;
d1508 2
a1509 4
void
maestro_powerhook(why, self)
	int why;
	void *self;
d1513 2
a1514 1
	if (why != PWR_RESUME) {
a1516 1
		sc->suspend = why;
d1535 2
a1536 1
	} else {
a1538 7
		if (sc->suspend == PWR_RESUME) {
			printf("%s: resume without suspend?\n",
			    sc->dev.dv_xname);
			sc->suspend = why;
			return;
		}
		sc->suspend = why;
d1550 1
d1552 7
@


1.28
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.27 2009/03/29 21:53:52 sthen Exp $	*/
d977 4
a980 4
	{0, AudioEslinear_le, AUDIO_ENCODING_SLINEAR_LE, 16, 0},
	{1, AudioEslinear, AUDIO_ENCODING_SLINEAR, 8, 0},
	{2, AudioEulinear, AUDIO_ENCODING_ULINEAR, 8, 0},
	{3, AudioEslinear_be, AUDIO_ENCODING_SLINEAR_BE, 16,
d982 1
a982 1
	{4, AudioEulinear_le, AUDIO_ENCODING_ULINEAR_LE, 16,
d984 1
a984 1
	{5, AudioEulinear_be, AUDIO_ENCODING_ULINEAR_BE, 16,
d986 1
a986 1
	{6, AudioEmulaw, AUDIO_ENCODING_ULAW, 8,
d988 1
a988 1
	{7, AudioEalaw, AUDIO_ENCODING_ALAW, 8,
d1119 3
@


1.27
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.26 2008/10/25 22:30:43 jakemsr Exp $	*/
a53 1
#include <sys/proc.h>
@


1.26
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.25 2008/05/29 02:10:01 jakemsr Exp $	*/
d656 1
a656 1
		printf(": couldn't map interrupt\n");
d663 1
a663 1
		printf(": couldn't establish interrupt");
d677 1
a677 1
		printf(", couldn't map i/o space\n");
d755 1
a755 1
			printf("%s: couldn't attach codec\n", sc->dev.dv_xname);
@


1.25
log
@use ac97 default parameters for these ac97 based drivers.

this makes the emulation expansion factor 1 by default since there's no
emulation.  previously the factor was 2 because these drivers emulate
8-bit ulaw playback with 16-bit linear encodings.  having a factor
other than 1 by default creates block size and hiwat/lowat issues
with applications that set the block size and hiwat before other
parameters.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.24 2008/04/21 00:32:43 jakemsr Exp $	*/
d1093 2
a1094 3
	if (play->channels != 1 && play->channels != 2)
		return (EINVAL);

@


1.24
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.23 2007/10/22 21:42:14 ratchov Exp $	*/
d486 1
d576 1
a576 1
	NULL
d1002 6
@


1.23
log
@the codec is not readable. If we try to read it the ac-link enters a kind of
"busy state" in which it's not writeable. This fix tags the host as unable
to read the codec, so the ac97 driver doesn't try to read it, instead it
keeps in memory copy of all codec registers. Fixes pr 2451

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.22 2007/10/09 17:06:18 gilles Exp $	*/
d574 2
a575 1
	maestro_trigger_input
@


1.22
log
@MALLOC -> malloc

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.21 2006/12/29 13:04:37 pedro Exp $	*/
d503 1
d748 1
d1335 7
@


1.21
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.20 2006/10/01 21:46:33 espie Exp $	*/
d1827 1
a1827 1
	MALLOC(pool, salloc_t, sizeof *pool + nzones * sizeof pool->zones[0],
d1849 1
a1849 1
	FREE(pool, M_TEMP);
@


1.20
log
@zap maestro_reg.h, since it's only used in the kernel.

okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.19 2005/08/09 04:10:13 mickey Exp $	*/
d1303 1
a1303 1
	u_int size = (end - start) >> 1;
@


1.19
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.18 2005/04/16 21:57:23 mickey Exp $	*/
d67 314
a380 1
#include <dev/pci/maestro_reg.h>
@


1.18
log
@do not provide round_buffer if not needed unless explained why in comments
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.17 2005/04/14 12:42:16 mickey Exp $	*/
a326 1
	pcireg_t data;
a363 6

	/* Enable bus mastering */
	data = pci_conf_read(sc->pc, sc->pt, PCI_COMMAND_STATUS_REG);
	if ((data & PCI_COMMAND_MASTER_ENABLE) == 0)
		pci_conf_write(sc->pc, sc->pt, PCI_COMMAND_STATUS_REG,
			data | PCI_COMMAND_MASTER_ENABLE);
@


1.17
log
@make sure round_blocksize does not produce 0 after alignment
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.16 2003/06/06 02:56:39 fgsch Exp $	*/
a181 1
size_t	maestro_round_buffersize(void *, int, size_t);
d256 1
a256 1
	maestro_round_buffersize,
a569 9
}

size_t
maestro_round_buffersize(self, direction, size)
	void *self;
	int direction;
	size_t size;
{
	return (size);
@


1.16
log
@initialize blocksize from the trigger_input routine; fixes a div by zero
error. problem and patch by Gabriel Kihlman in PR/2856.
millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.15 2002/03/14 03:16:06 millert Exp $	*/
d570 1
a570 1
	return (blk & ~0xf);
@


1.15
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.14 2002/03/14 01:26:59 millert Exp $	*/
d906 1
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.13 2002/01/20 19:56:53 ericj Exp $	*/
d185 4
a188 4
int	maestro_trigger_output __P((void *, void *, void *, int, void (*)(void *),
				void *, struct audio_params *));
int	maestro_trigger_input __P((void *, void *, void *, int, void (*)(void *),
			       void *, struct audio_params *));
@


1.13
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.12 2001/10/31 11:00:24 art Exp $	*/
d118 1
a118 1
	void			(*intr) __P((void *));
d157 28
a184 28
salloc_t salloc_new __P((caddr_t, size_t, int));
void	salloc_destroy __P((salloc_t));
caddr_t	salloc_alloc __P((salloc_t, size_t));
void	salloc_free __P((salloc_t, caddr_t));
void	salloc_insert __P((salloc_t, struct salloc_head *, 
		struct salloc_zone *, int));

int	maestro_match __P((struct device *, void *, void *));
void	maestro_attach __P((struct device *, struct device *, void *));
int	maestro_intr __P((void *));

int	maestro_open __P((void *, int));
void	maestro_close __P((void *));
int	maestro_query_encoding __P((void *, struct audio_encoding *));
int	maestro_set_params __P((void *, int, int, struct audio_params *, 
			    struct audio_params *));
int	maestro_round_blocksize __P((void *, int));
int	maestro_halt_output __P((void *));
int	maestro_halt_input __P((void *));
int	maestro_getdev __P((void *, struct audio_device *));
int	maestro_set_port __P((void *, mixer_ctrl_t *));
int	maestro_get_port __P((void *, mixer_ctrl_t *));
int	maestro_query_devinfo __P((void *, mixer_devinfo_t *));
void	*maestro_malloc __P((void *, int, size_t, int, int));
void	maestro_free __P((void *, void *, int));
size_t	maestro_round_buffersize __P((void *, int, size_t));
paddr_t	maestro_mappage __P((void *, void *, off_t, int));
int	maestro_get_props __P((void *));
d190 33
a222 33
int	maestro_attach_codec __P((void *, struct ac97_codec_if *));
int	maestro_read_codec __P((void *, u_int8_t, u_int16_t *));
int	maestro_write_codec __P((void *, u_int8_t, u_int16_t));
void	maestro_reset_codec __P((void *));

void	maestro_initcodec __P((void *));

void	maestro_set_speed __P((struct maestro_channel *, u_long *));
void	maestro_init __P((struct maestro_softc *));
void	maestro_power __P((struct maestro_softc *, int));
void	maestro_powerhook __P((int, void *));

void 	maestro_channel_start __P((struct maestro_channel *));
void 	maestro_channel_stop __P((struct maestro_channel *));
void 	maestro_channel_advance_dma __P((struct maestro_channel *));
void	maestro_channel_suppress_jitter __P((struct maestro_channel *));

int	maestro_get_flags __P((struct pci_attach_args *));

void	ringbus_setdest __P((struct maestro_softc *, int, int));

wpreg_t	wp_reg_read __P((struct maestro_softc *, int));
void	wp_reg_write __P((struct maestro_softc *, int, wpreg_t));
wpreg_t	wp_apu_read __P((struct maestro_softc *, int, int));
void	wp_apu_write __P((struct maestro_softc *, int, int, wpreg_t));
void	wp_settimer __P((struct maestro_softc *, u_int));
void	wp_starttimer __P((struct maestro_softc *));
void	wp_stoptimer __P((struct maestro_softc *));

wcreg_t	wc_reg_read __P((struct maestro_softc *, int));
void	wc_reg_write __P((struct maestro_softc *, int, wcreg_t));
wcreg_t	wc_ctrl_read __P((struct maestro_softc *, int));
void	wc_ctrl_write __P((struct maestro_softc *, int, wcreg_t));
d224 2
a225 2
u_int maestro_calc_timer_freq __P((struct maestro_channel *));
void maestro_update_timer __P((struct maestro_softc *));
d899 1
a899 1
	void (*intr) __P((void *));
d999 1
a999 1
	void (*intr) __P((void *));
@


1.12
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.11 2001/09/21 17:55:44 miod Exp $	*/
d255 1
a255 1
	NULL,
d257 1
a257 1
	NULL,
d261 1
a261 3
	maestro_trigger_input,
	maestro_malloc,
	maestro_round_buffersize
@


1.12.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.13 2002/01/20 19:56:53 ericj Exp $	*/
d255 1
a255 1
	maestro_malloc,
d257 1
a257 1
	maestro_round_buffersize,
d261 3
a263 1
	maestro_trigger_input
@


1.12.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.12.2.1 2002/01/31 22:55:35 niklas Exp $	*/
d118 1
a118 1
	void			(*intr)(void *);
d157 66
a222 66
salloc_t salloc_new(caddr_t, size_t, int);
void	salloc_destroy(salloc_t);
caddr_t	salloc_alloc(salloc_t, size_t);
void	salloc_free(salloc_t, caddr_t);
void	salloc_insert(salloc_t, struct salloc_head *, 
		struct salloc_zone *, int);

int	maestro_match(struct device *, void *, void *);
void	maestro_attach(struct device *, struct device *, void *);
int	maestro_intr(void *);

int	maestro_open(void *, int);
void	maestro_close(void *);
int	maestro_query_encoding(void *, struct audio_encoding *);
int	maestro_set_params(void *, int, int, struct audio_params *, 
			    struct audio_params *);
int	maestro_round_blocksize(void *, int);
int	maestro_halt_output(void *);
int	maestro_halt_input(void *);
int	maestro_getdev(void *, struct audio_device *);
int	maestro_set_port(void *, mixer_ctrl_t *);
int	maestro_get_port(void *, mixer_ctrl_t *);
int	maestro_query_devinfo(void *, mixer_devinfo_t *);
void	*maestro_malloc(void *, int, size_t, int, int);
void	maestro_free(void *, void *, int);
size_t	maestro_round_buffersize(void *, int, size_t);
paddr_t	maestro_mappage(void *, void *, off_t, int);
int	maestro_get_props(void *);
int	maestro_trigger_output(void *, void *, void *, int, void (*)(void *),
				void *, struct audio_params *);
int	maestro_trigger_input(void *, void *, void *, int, void (*)(void *),
			       void *, struct audio_params *);

int	maestro_attach_codec(void *, struct ac97_codec_if *);
int	maestro_read_codec(void *, u_int8_t, u_int16_t *);
int	maestro_write_codec(void *, u_int8_t, u_int16_t);
void	maestro_reset_codec(void *);

void	maestro_initcodec(void *);

void	maestro_set_speed(struct maestro_channel *, u_long *);
void	maestro_init(struct maestro_softc *);
void	maestro_power(struct maestro_softc *, int);
void	maestro_powerhook(int, void *);

void 	maestro_channel_start(struct maestro_channel *);
void 	maestro_channel_stop(struct maestro_channel *);
void 	maestro_channel_advance_dma(struct maestro_channel *);
void	maestro_channel_suppress_jitter(struct maestro_channel *);

int	maestro_get_flags(struct pci_attach_args *);

void	ringbus_setdest(struct maestro_softc *, int, int);

wpreg_t	wp_reg_read(struct maestro_softc *, int);
void	wp_reg_write(struct maestro_softc *, int, wpreg_t);
wpreg_t	wp_apu_read(struct maestro_softc *, int, int);
void	wp_apu_write(struct maestro_softc *, int, int, wpreg_t);
void	wp_settimer(struct maestro_softc *, u_int);
void	wp_starttimer(struct maestro_softc *);
void	wp_stoptimer(struct maestro_softc *);

wcreg_t	wc_reg_read(struct maestro_softc *, int);
void	wc_reg_write(struct maestro_softc *, int, wcreg_t);
wcreg_t	wc_ctrl_read(struct maestro_softc *, int);
void	wc_ctrl_write(struct maestro_softc *, int, wcreg_t);
d224 2
a225 2
u_int maestro_calc_timer_freq(struct maestro_channel *);
void maestro_update_timer(struct maestro_softc *);
d899 1
a899 1
	void (*intr)(void *);
d999 1
a999 1
	void (*intr)(void *);
@


1.11
log
@Correct some pryntf() usage: get the correct number of arguments in the
correct order.
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.10 2001/09/05 08:29:55 espie Exp $	*/
d183 1
a183 1
int	maestro_mappage __P((void *, void *, int, int));
d606 1
a606 1
int
d609 2
a610 1
	int off, prot;
@


1.10
log
@Stereo jitter suppressor.
Idea from FreeBSD.
This code was not put in initially because I had no problematic
card to test.
Thanks to Chris Kuethe <ckuethe@@pyxis.cns.ualberta.ca> for having
such a card and testing this code.
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.9 2001/08/25 10:13:29 art Exp $	*/
d1226 2
a1227 1
			printf("%s: resume without suspend?\n");
@


1.9
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.8 2001/08/02 11:16:29 espie Exp $	*/
d205 1
d1289 16
d1362 1
a1362 1
	if (sc->play.mode & MAESTRO_RUNNING)
d1364 3
a1366 1
	/* XXX suppress jitter for stereo play? */
@


1.8
log
@fix mmap.
Add workaround for uvm brain-deadness (allow open O_RDWR, which is
necessary for mmap to work, since mmap(PROT_WRITE) does NOT work on
devices)
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.7 2001/06/12 15:40:32 niklas Exp $	*/
d342 1
a342 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin, pa->pa_intrline,
	    &ih)) {
@


1.7
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.6 2001/05/16 19:27:38 mickey Exp $	*/
d616 1
a616 1
	    (caddr_t)mem - sc->dmabase + off, prot, BUS_DMA_WAITOK);
d829 2
d833 1
@


1.6
log
@it is notright to malloc() w/  WAITOK at attach time, put back NULL check and change to NOWAIT
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.4 2001/03/13 01:45:56 deraadt Exp $	*/
d364 1
a364 1
	    0, &sc->iot, &sc->ioh, NULL, NULL)) != 0) {
@


1.5
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1510 3
a1512 1
	    M_TEMP, M_WAITOK);
@


1.4
log
@correct dmesg, save space
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.3 2001/01/16 12:07:19 espie Exp $	*/
a1510 2
	if (pool == NULL)
		return NULL;
@


1.4.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.4 2001/03/13 01:45:56 deraadt Exp $	*/
@


1.4.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.4.4.1 2001/05/14 22:25:50 niklas Exp $	*/
d364 1
a364 1
	    0, &sc->iot, &sc->ioh, NULL, NULL, 0)) != 0) {
d1510 1
a1510 1
	    M_TEMP, M_NOWAIT);
@


1.4.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.4.4.2 2001/07/04 10:42:38 niklas Exp $	*/
a204 1
void	maestro_channel_suppress_jitter __P((struct maestro_channel *));
d342 2
a343 1
	if (pci_intr_map(pa, &ih)) {
d616 1
a616 1
		off, prot, BUS_DMA_WAITOK);
a828 2
/* XXX work around VM brokeness */
#if 0
a830 1
#endif
d1223 1
a1223 2
			printf("%s: resume without suspend?\n",
			    sc->dev.dv_xname);
a1285 16
/* Some maestro makes sometimes get desynchronized in stereo mode. */
void
maestro_channel_suppress_jitter(ch)
	struct maestro_channel *ch;
{
	int cp, diff;

	/* Verify that both channels are not too far off. */
	cp = wp_apu_read(ch->sc, ch->num, APUREG_CURPTR);
	diff = wp_apu_read(ch->sc, ch->num+1, APUREG_CURPTR) - cp;
	if (diff > 4 || diff < -4)
		/* Otherwise, directly resynch the 2nd channel. */
		bus_space_write_2(ch->sc->iot, ch->sc->ioh,
		    PORT_DSP_DATA, cp);
}

d1343 1
a1343 1
	if (sc->play.mode & MAESTRO_RUNNING) {
d1345 1
a1345 3
		if (sc->play.mode & MAESTRO_STEREO)
			maestro_channel_suppress_jitter(&sc->play);
	}
@


1.4.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d183 1
a183 1
paddr_t	maestro_mappage __P((void *, void *, off_t, int));
d606 1
a606 1
paddr_t
d609 1
a609 2
	off_t off;
	int prot;
@


1.4.4.5
log
@Merge in trunk
@
text
@d255 1
a255 1
	maestro_malloc,
d257 1
a257 1
	maestro_round_buffersize,
d261 3
a263 1
	maestro_trigger_input
@


1.4.4.6
log
@Merge in -current from roughly a week ago
@
text
@d118 1
a118 1
	void			(*intr)(void *);
d157 66
a222 66
salloc_t salloc_new(caddr_t, size_t, int);
void	salloc_destroy(salloc_t);
caddr_t	salloc_alloc(salloc_t, size_t);
void	salloc_free(salloc_t, caddr_t);
void	salloc_insert(salloc_t, struct salloc_head *, 
		struct salloc_zone *, int);

int	maestro_match(struct device *, void *, void *);
void	maestro_attach(struct device *, struct device *, void *);
int	maestro_intr(void *);

int	maestro_open(void *, int);
void	maestro_close(void *);
int	maestro_query_encoding(void *, struct audio_encoding *);
int	maestro_set_params(void *, int, int, struct audio_params *, 
			    struct audio_params *);
int	maestro_round_blocksize(void *, int);
int	maestro_halt_output(void *);
int	maestro_halt_input(void *);
int	maestro_getdev(void *, struct audio_device *);
int	maestro_set_port(void *, mixer_ctrl_t *);
int	maestro_get_port(void *, mixer_ctrl_t *);
int	maestro_query_devinfo(void *, mixer_devinfo_t *);
void	*maestro_malloc(void *, int, size_t, int, int);
void	maestro_free(void *, void *, int);
size_t	maestro_round_buffersize(void *, int, size_t);
paddr_t	maestro_mappage(void *, void *, off_t, int);
int	maestro_get_props(void *);
int	maestro_trigger_output(void *, void *, void *, int, void (*)(void *),
				void *, struct audio_params *);
int	maestro_trigger_input(void *, void *, void *, int, void (*)(void *),
			       void *, struct audio_params *);

int	maestro_attach_codec(void *, struct ac97_codec_if *);
int	maestro_read_codec(void *, u_int8_t, u_int16_t *);
int	maestro_write_codec(void *, u_int8_t, u_int16_t);
void	maestro_reset_codec(void *);

void	maestro_initcodec(void *);

void	maestro_set_speed(struct maestro_channel *, u_long *);
void	maestro_init(struct maestro_softc *);
void	maestro_power(struct maestro_softc *, int);
void	maestro_powerhook(int, void *);

void 	maestro_channel_start(struct maestro_channel *);
void 	maestro_channel_stop(struct maestro_channel *);
void 	maestro_channel_advance_dma(struct maestro_channel *);
void	maestro_channel_suppress_jitter(struct maestro_channel *);

int	maestro_get_flags(struct pci_attach_args *);

void	ringbus_setdest(struct maestro_softc *, int, int);

wpreg_t	wp_reg_read(struct maestro_softc *, int);
void	wp_reg_write(struct maestro_softc *, int, wpreg_t);
wpreg_t	wp_apu_read(struct maestro_softc *, int, int);
void	wp_apu_write(struct maestro_softc *, int, int, wpreg_t);
void	wp_settimer(struct maestro_softc *, u_int);
void	wp_starttimer(struct maestro_softc *);
void	wp_stoptimer(struct maestro_softc *);

wcreg_t	wc_reg_read(struct maestro_softc *, int);
void	wc_reg_write(struct maestro_softc *, int, wcreg_t);
wcreg_t	wc_ctrl_read(struct maestro_softc *, int);
void	wc_ctrl_write(struct maestro_softc *, int, wcreg_t);
d224 2
a225 2
u_int maestro_calc_timer_freq(struct maestro_channel *);
void maestro_update_timer(struct maestro_softc *);
d899 1
a899 1
	void (*intr)(void *);
d999 1
a999 1
	void (*intr)(void *);
@


1.4.4.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.4.4.6 2002/03/28 15:35:58 niklas Exp $	*/
a905 1
	sc->record.blocksize = blksize;
@


1.3
log
@Add half of PT101 support: init codec, no mixer. And provide for
audio/maestro without a functional mixer.

Add hardware volume support, enable corresponding interrupt so that volume
control works within cdio.
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.2 2001/01/12 17:38:30 espie Exp $	*/
d270 1
a270 2
	int vendor, product;
	char *name;
d273 5
a277 7
	{ PCI_VENDOR_ESSTECH, PCI_PRODUCT_ESSTECH_MAESTROII,
	  "ESS Technology Maestro-2", 0 },
	{ PCI_VENDOR_ESSTECH, PCI_PRODUCT_ESSTECH_MAESTRO2E,
	  "ESS Technology Maestro-2E", 0 },
	{ 0x1285, 0x0100, "ESS Technology Maestro-1", 0 },
	{ PCI_VENDOR_NEC, 0x8058, "NEC Versa(?)", MAESTRO_FLAG_SETUPGPIO },
	{ PCI_VENDOR_NEC, 0x803c, "NEC VersaProNX VA26D", MAESTRO_FLAG_SETUPGPIO }
a310 1
/* This is grossly inelegant, but we can't store results at match time. */
a333 1
	printf("\n");
d344 1
a344 1
		printf("%s: couldn't map interrupt\n", sc->dev.dv_xname);
d351 1
a351 1
		printf("%s: couldn't establish interrupt", sc->dev.dv_xname);
d356 1
a356 1
	printf("%s: interrupting at %s, ", sc->dev.dv_xname, intrstr);
d365 1
a365 1
		printf("couldn't map i/o space\n");
d379 1
a379 2
		printf("%s: unable to alloc dma, error %d\n",
		    sc->dev.dv_xname, error);
d386 1
a386 2
		printf("%s: unable to map dma, error %d\n",
		    sc->dev.dv_xname, error);
d392 1
a392 2
		printf("%s: unable to create dma map, error %d\n",
		    sc->dev.dv_xname, error);
d398 1
a398 2
		printf("%s: unable to load dma map, error %d\n",
		    sc->dev.dv_xname, error);
d409 1
a409 1
		printf("%s: unable to make dma pool\n", sc->dev.dv_xname);
d414 2
@


1.2
log
@Activate other maestro makes, per Theo's request.
@
text
@d1 1
a1 1
/*	$OpenBSD: maestro.c,v 1.1 2001/01/11 23:36:38 espie Exp $	*/
d86 3
d411 3
a413 2
	/* XXX The first bytes of the allocated memory are not usable,
	 * apparently. I suspect they get used to store status. ME
d428 30
a457 13
		printf("PT101 codec unsupported\n");
		goto bad;
	}

	/* Attach the AC'97 */
	sc->host_if.arg = sc;
	sc->host_if.attach = maestro_attach_codec;
	sc->host_if.read = maestro_read_codec;
	sc->host_if.write = maestro_write_codec;
	sc->host_if.reset = maestro_reset_codec;
	if (ac97_attach(&sc->host_if) != 0) {
		printf("couldn't attach codec\n");
		goto bad;
d519 1
a519 1
	/* Enable direct sound interruption. */
d521 1
a521 1
	    HOSTINT_CTRL_DSOUND_INT_ENABLED);
d551 3
a553 2
	/*
	 * Setup GPIO if needed (NEC systems) 
d555 3
d651 1
a651 1
	struct maestro_softc *sc = (struct maestro_softc *)self;
d653 4
a656 1
	return (sc->codec_if->vtbl->mixer_set_port(sc->codec_if, cp));
d664 1
a664 1
	struct maestro_softc *sc = (struct maestro_softc *)self;
d666 4
a669 1
	return (sc->codec_if->vtbl->mixer_get_port(sc->codec_if, cp));
d677 6
a682 3
	struct maestro_softc *sc = (struct maestro_softc *)self;
	
	return (sc->codec_if->vtbl->query_devinfo(sc->codec_if, cp));
d971 1
a971 1
		wp_apu_write(sc, n, APUREG_FREQ_LOBYTE, APU_plus6dB
d973 1
a973 1
		wp_apu_write(sc, n, APUREG_FREQ_HIWORD, ch->dv >> 8);
d987 1
a987 1
		wp_apu_write(sc, n+1, APUREG_FREQ_LOBYTE, APU_plus6dB
d989 1
a989 1
		wp_apu_write(sc, n+1, APUREG_FREQ_HIWORD, ch->dv >> 8);
d1239 2
a1240 1
		sc->codec_if->vtbl->restore_ports(sc->codec_if);
d1309 40
a1348 1
	bus_space_write_1(sc->iot, sc->ioh, PORT_HOSTINT_STAT, 0);
@


1.1
log
@Sound driver for some ESS maestro models. Work by d@@ and me, based on
the FreeBSD driver, and some linux code. Probably some tweaks to
reach out for more pci cards (some models are currently commented out,
and we have yet to find a card where stereo output gets de-synchronized,
as the FreeBSD driver claims happens).

Suspends/resume works, recording and keyboard volume control on the way.

This is not derived from the NetBSD driver in any way. Just happens
that both works reached completion at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d126 2
a142 1
#define MAESTRO_FLAG_SETUPGPIO	0x0001
d203 1
d272 1
a272 2
	  "ESS Technology Maestro-2",
	  0 },
d274 4
a277 5
	  "ESS Technology Maestro-2E",
	  0 },
	/* { 0x1285, 0x0100, "ESS Technology Maestro-1", 0 } */
	/* { 0x1033, 0x8058, "NEC Versa(?)", MAESTRO_FLAG_SETUPGPIO } */
	/* { 0x1033, 0x803c, "NEC VersaProNX VA26D", MAESTRO_FLAG_SETUPGPIO } */
d281 18
a309 1
	int i;
d311 2
a312 2
	/* Distinguish audio devices from modems with the same manfid */
	if (PCI_CLASS(pa->pa_class) != PCI_CLASS_MULTIMEDIA)
d314 2
a315 7
	if (PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_MULTIMEDIA_AUDIO)
		return (0);
	for (i = 0; i < NMAESTRO_PCITAB; i++)
		if (PCI_VENDOR(pa->pa_id) == maestro_pcitab[i].vendor &&
		    PCI_PRODUCT(pa->pa_id) == maestro_pcitab[i].product)
			return (1);
	return (0);
d337 1
d531 1
a531 2
	 * Setup GPIO.
	 * There seems to be a special case with NEC systems.
d533 10
a542 13

#if 0
	/* Matthew Braithwaite <matt@@braithwaite.net> reported that
	 * NEC Versa LX doesn't need GPIO operation. */
	bus_space_write_2(sc->iot, sc->ioh, 
	    PORT_GPIO_MASK, 0x9ff);
	bus_space_write_2(sc->iot, sc->ioh, PORT_GPIO_DIR,
	    bus_space_read_2(sc->iot, sc->ioh, 
	    PORT_GPIO_DIR) | 0x600);
	bus_space_write_2(sc->iot, sc->ioh, 
	    PORT_GPIO_DATA, 0x200);

#endif
@

