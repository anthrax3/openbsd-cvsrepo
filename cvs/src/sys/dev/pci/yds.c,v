head	1.54;
access;
symbols
	OPENBSD_6_0:1.52.0.6
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.50.0.4
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.48.0.4
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.47.0.4
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.45.0.4
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.43.0.2
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.41.0.4
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.2
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.2
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.38.0.2
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.30.0.2
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.28.0.6
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.4
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.27.0.6
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.4
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.15
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SMP:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.2;
locks; strict;
comment	@ * @;


1.54
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.53;
commitid	qGgYgJTgEFuAoGj4;

1.53
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.52;
commitid	pi1a9KN0itEngOc4;

1.52
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.51;
commitid	fbhqfhfdKxBcsetK;

1.51
date	2015.09.10.18.10.34;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	pbNNrPaFfPV40pxN;

1.50
date	2015.05.11.06.46.22;	author ratchov;	state Exp;
branches;
next	1.49;
commitid	RaOGL5SyOGOZylwx;

1.49
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.48;
commitid	p4LJxGKbi0BU2cG6;

1.48
date	2014.11.18.23.55.01;	author krw;	state Exp;
branches;
next	1.47;
commitid	Qb045HZ5OhQfU69H;

1.47
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.46;
commitid	OBNa5kfxQ2UXoiIw;

1.46
date	2014.05.17.12.19.36;	author ratchov;	state Exp;
branches;
next	1.45;

1.45
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2013.10.01.20.06.02;	author sf;	state Exp;
branches;
next	1.43;

1.43
date	2013.05.24.07.58.47;	author ratchov;	state Exp;
branches;
next	1.42;

1.42
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.41;

1.41
date	2012.03.03.20.21.39;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2012.01.11.16.22.33;	author dhill;	state Exp;
branches;
next	1.39;

1.39
date	2011.04.03.15.36.03;	author jasper;	state Exp;
branches;
next	1.38;

1.38
date	2010.09.17.07.55.52;	author jakemsr;	state Exp;
branches;
next	1.37;

1.37
date	2010.09.07.16.21.46;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2010.09.06.19.20.23;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2010.08.27.18.50.57;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.33;

1.33
date	2010.04.06.22.28.07;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.29.21.53.53;	author sthen;	state Exp;
branches;
next	1.31;

1.31
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.30;

1.30
date	2008.05.29.02.10.01;	author jakemsr;	state Exp;
branches;
next	1.29;

1.29
date	2008.04.21.00.32.43;	author jakemsr;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.06.02.48.40;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2005.08.09.04.10.13;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.27.00.49.56;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.30.20.45.12;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.20.12.29.36;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.24.22.52.52;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.19.20.11.33;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2004.02.19.11.08.11;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.29.09.08.20;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.14.09.04.59;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.27.11.22.54;	author ho;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.25.20.14.34;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.20.00.26.17;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.27.00;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.06.23.01.40;	author ericj;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.04.20.42.18;	author ericj;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.20.04.50.06;	author jcs;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.07.17.08.35;	author deraadt;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.31.11.00.24;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.26.03.32.22;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.25.14.52.57;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.25.10.13.30;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.12.15.40.33;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.24.18.49.50;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.29.14.20.46;	author aaron;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.05.14.22.26.01;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.07.04.10.43.16;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2001.11.13.21.10.03;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.1.4.6;

1.1.4.6
date	2002.03.28.15.35.59;	author niklas;	state Exp;
branches;
next	1.1.4.7;

1.1.4.7
date	2003.03.28.00.38.25;	author niklas;	state Exp;
branches;
next	1.1.4.8;

1.1.4.8
date	2003.05.13.19.35.09;	author ho;	state Exp;
branches;
next	1.1.4.9;

1.1.4.9
date	2003.05.16.00.29.42;	author niklas;	state Exp;
branches;
next	1.1.4.10;

1.1.4.10
date	2004.02.19.10.56.30;	author niklas;	state Exp;
branches;
next	1.1.4.11;

1.1.4.11
date	2004.06.05.23.12.54;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.01.31.22.55.36;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.06.11.03.42.27;	author art;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2003.05.19.22.19.37;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.54
log
@Remove unused getdev() audio driver functions.
@
text
@/*	$OpenBSD: yds.c,v 1.53 2016/09/14 06:12:19 ratchov Exp $	*/
/*	$NetBSD: yds.c,v 1.5 2001/05/21 23:55:04 minoura Exp $	*/

/*
 * Copyright (c) 2000, 2001 Kazuki Sakamoto and Minoura Makoto.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* 
 * Yamaha YMF724[B-F]/740[B-C]/744/754
 *
 * Documentation links:
 * - ftp://ftp.alsa-project.org/pub/manuals/yamaha/
 * - ftp://ftp.alsa-project.org/pub/manuals/yamaha/pci/
 *
 * TODO:
 * - FM synth volume (difficult: mixed before ac97)
 * - Digital in/out (SPDIF) support
 * - Effect??
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/fcntl.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/queue.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>
#include <dev/midi_if.h>
#include <dev/ic/ac97.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/pci/ydsreg.h>
#include <dev/pci/ydsvar.h>

/* Debug */
#undef YDS_USE_REC_SLOT
#define YDS_USE_P44

#ifdef AUDIO_DEBUG
# define DPRINTF(x)	if (ydsdebug) printf x
# define DPRINTFN(n,x)	if (ydsdebug>(n)) printf x
int	ydsdebug = 0;
#else
# define DPRINTF(x)
# define DPRINTFN(n,x)
#endif
#ifdef YDS_USE_REC_SLOT
# define YDS_INPUT_SLOT 0	/* REC slot = ADC + loopbacks */
#else
# define YDS_INPUT_SLOT 1	/* ADC slot */
#endif

static	int ac97_id2;

int	yds_match(struct device *, void *, void *);
void	yds_attach(struct device *, struct device *, void *);
int	yds_activate(struct device *, int);
int	yds_intr(void *);

static void nswaph(u_int32_t *p, int wcount);

#define DMAADDR(p) ((p)->map->dm_segs[0].ds_addr)
#define KERNADDR(p) ((void *)((p)->addr))

int	yds_allocmem(struct yds_softc *, size_t, size_t,
	    struct yds_dma *);
int	yds_freemem(struct yds_softc *, struct yds_dma *);

#ifndef AUDIO_DEBUG
#define YWRITE1(sc, r, x) bus_space_write_1((sc)->memt, (sc)->memh, (r), (x))
#define YWRITE2(sc, r, x) bus_space_write_2((sc)->memt, (sc)->memh, (r), (x))
#define YWRITE4(sc, r, x) bus_space_write_4((sc)->memt, (sc)->memh, (r), (x))
#define YREAD1(sc, r) bus_space_read_1((sc)->memt, (sc)->memh, (r))
#define YREAD2(sc, r) bus_space_read_2((sc)->memt, (sc)->memh, (r))
#define YREAD4(sc, r) bus_space_read_4((sc)->memt, (sc)->memh, (r))
#else

u_int16_t YREAD2(struct yds_softc *sc,bus_size_t r);
u_int32_t YREAD4(struct yds_softc *sc,bus_size_t r);
void YWRITE1(struct yds_softc *sc,bus_size_t r,u_int8_t x);
void YWRITE2(struct yds_softc *sc,bus_size_t r,u_int16_t x);
void YWRITE4(struct yds_softc *sc,bus_size_t r,u_int32_t x);

u_int16_t YREAD2(struct yds_softc *sc,bus_size_t r)
{
  DPRINTFN(5, (" YREAD2(0x%lX)\n",(unsigned long)r));
  return bus_space_read_2(sc->memt,sc->memh,r);
}
u_int32_t YREAD4(struct yds_softc *sc,bus_size_t r)
{
  DPRINTFN(5, (" YREAD4(0x%lX)\n",(unsigned long)r));
  return bus_space_read_4(sc->memt,sc->memh,r);
}
void YWRITE1(struct yds_softc *sc,bus_size_t r,u_int8_t x)
{
  DPRINTFN(5, (" YWRITE1(0x%lX,0x%lX)\n",(unsigned long)r,(unsigned long)x));
  bus_space_write_1(sc->memt,sc->memh,r,x);
}
void YWRITE2(struct yds_softc *sc,bus_size_t r,u_int16_t x)
{
  DPRINTFN(5, (" YWRITE2(0x%lX,0x%lX)\n",(unsigned long)r,(unsigned long)x));
  bus_space_write_2(sc->memt,sc->memh,r,x);
}
void YWRITE4(struct yds_softc *sc,bus_size_t r,u_int32_t x)
{
  DPRINTFN(5, (" YWRITE4(0x%lX,0x%lX)\n",(unsigned long)r,(unsigned long)x));
  bus_space_write_4(sc->memt,sc->memh,r,x);
}
#endif

#define	YWRITEREGION4(sc, r, x, c)	\
	bus_space_write_region_4((sc)->memt, (sc)->memh, (r), (x), (c) / 4)

struct cfattach yds_ca = {
	sizeof(struct yds_softc), yds_match, yds_attach, NULL,
	yds_activate
};

struct cfdriver yds_cd = {
	NULL, "yds", DV_DULL
};

int	yds_open(void *, int);
void	yds_close(void *);
int	yds_set_params(void *, int, int,
	    struct audio_params *, struct audio_params *);
int	yds_round_blocksize(void *, int);
int	yds_trigger_output(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	yds_trigger_input(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	yds_halt_output(void *);
int	yds_halt_input(void *);
int	yds_mixer_set_port(void *, mixer_ctrl_t *);
int	yds_mixer_get_port(void *, mixer_ctrl_t *);
void   *yds_malloc(void *, int, size_t, int, int);
void	yds_free(void *, void *, int);
size_t	yds_round_buffersize(void *, int, size_t);
int	yds_get_props(void *);
int	yds_query_devinfo(void *addr, mixer_devinfo_t *dip);

int     yds_attach_codec(void *sc, struct ac97_codec_if *);
int	yds_read_codec(void *sc, u_int8_t a, u_int16_t *d);
int	yds_write_codec(void *sc, u_int8_t a, u_int16_t d);
void    yds_reset_codec(void *sc);
int     yds_get_portnum_by_name(struct yds_softc *, char *, char *,
	    char *);

static u_int yds_get_dstype(int);
static int yds_download_mcode(struct yds_softc *);
static int yds_allocate_slots(struct yds_softc *, int);
static void yds_configure_legacy(struct yds_softc *arg);
static void yds_enable_dsp(struct yds_softc *);
static int yds_disable_dsp(struct yds_softc *);
static int yds_ready_codec(struct yds_codec_softc *);
static int yds_halt(struct yds_softc *);
static u_int32_t yds_get_lpfq(u_int);
static u_int32_t yds_get_lpfk(u_int);
static struct yds_dma *yds_find_dma(struct yds_softc *, void *);

int	yds_init(struct yds_softc *, int);
void	yds_attachhook(struct device *);

#ifdef AUDIO_DEBUG
static void yds_dump_play_slot(struct yds_softc *, int);
#define	YDS_DUMP_PLAY_SLOT(n,sc,bank) \
	if (ydsdebug > (n)) yds_dump_play_slot(sc, bank)
#else
#define	YDS_DUMP_PLAY_SLOT(n,sc,bank)
#endif /* AUDIO_DEBUG */

static struct audio_hw_if yds_hw_if = {
	yds_open,
	yds_close,
	yds_set_params,
	yds_round_blocksize,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	yds_halt_output,
	yds_halt_input,
	NULL,
	NULL,
	yds_mixer_set_port,
	yds_mixer_get_port,
	yds_query_devinfo,
	yds_malloc,
	yds_free,
	yds_round_buffersize,
	yds_get_props,
	yds_trigger_output,
	yds_trigger_input
};

const static struct {
	u_int	id;
	u_int	flags;
#define YDS_CAP_MCODE_1			0x0001
#define YDS_CAP_MCODE_1E		0x0002
#define YDS_CAP_LEGACY_SELECTABLE	0x0004
#define YDS_CAP_LEGACY_FLEXIBLE		0x0008
#define YDS_CAP_HAS_P44			0x0010
#define YDS_CAP_LEGACY_SMOD_DISABLE	0x1000
} yds_chip_capability_list[] = {
	{ PCI_PRODUCT_YAMAHA_YMF724,
	  YDS_CAP_MCODE_1|YDS_CAP_LEGACY_SELECTABLE },
	/* 740[C] has only 32 slots.  But anyway we use only 2 */
	{ PCI_PRODUCT_YAMAHA_YMF740,
	  YDS_CAP_MCODE_1|YDS_CAP_LEGACY_SELECTABLE },	/* XXX NOT TESTED */
	{ PCI_PRODUCT_YAMAHA_YMF740C,
	  YDS_CAP_MCODE_1E|YDS_CAP_LEGACY_SELECTABLE },
	{ PCI_PRODUCT_YAMAHA_YMF724F,
	  YDS_CAP_MCODE_1E|YDS_CAP_LEGACY_SELECTABLE },
	{ PCI_PRODUCT_YAMAHA_YMF744, 
	  YDS_CAP_MCODE_1E|YDS_CAP_LEGACY_FLEXIBLE },
	{ PCI_PRODUCT_YAMAHA_YMF754,
	  YDS_CAP_MCODE_1E|YDS_CAP_LEGACY_FLEXIBLE|YDS_CAP_HAS_P44 },
	/* How about 734/737/738?? */
	{ 0, 0 }
};
#ifdef AUDIO_DEBUG
#define YDS_CAP_BITS	"\020\005P44\004LEGFLEX\003LEGSEL\002MCODE1E\001MCODE1"
#endif

#ifdef AUDIO_DEBUG
static void
yds_dump_play_slot(struct yds_softc *sc, int bank)
{
	int i, j;
	u_int32_t *p;
	u_int32_t num;
	struct yds_dma *dma;

	for (i = 0; i < N_PLAY_SLOTS; i++) {
		printf("pbankp[%d] = %p,", i*2, sc->pbankp[i*2]);
		printf("pbankp[%d] = %p\n", i*2+1, sc->pbankp[i*2+1]);
	}

	p = (u_int32_t*)sc->ptbl;
	for (i = 0; i < N_PLAY_SLOTS+1; i++) {
		printf("ptbl + %d:0x%x\n", i, *p);
		p++;
	}

	num = *(u_int32_t*)sc->ptbl;
	printf("num = %d\n", num);

	for (i = 0; i < num; i++) {

		p = (u_int32_t *)sc->pbankp[i];

		dma = yds_find_dma(sc,(void *)p);

		for (j = 0; j < sizeof(struct play_slot_ctrl_bank) /
		    sizeof(u_int32_t); j++) {
			printf("    0x%02x: 0x%08x\n",
			       (unsigned) (j * sizeof(u_int32_t)),
			       (unsigned) *p++);
		}
		/*
		p = (u_int32_t *)sc->pbankp[i*2 + 1];
		printf("  pbankp[%d] : %p\n", i*2 + 1, p);
		for (j = 0; j < sizeof(struct play_slot_ctrl_bank) /
		    sizeof(u_int32_t); j++) {
			printf("    0x%02x: 0x%08x\n",
				j * sizeof(u_int32_t), *p++);
				delay(1);
		}	
		*/
	}
}
#endif /* AUDIO_DEBUG */

static u_int
yds_get_dstype(int id)
{
	int i;

	for (i = 0; yds_chip_capability_list[i].id; i++) {
		if (PCI_PRODUCT(id) == yds_chip_capability_list[i].id)
			return yds_chip_capability_list[i].flags;
	}

	return -1;
}

static void
nswaph(u_int32_t *p, int wcount)
{
	for (; wcount; wcount -=4) {
		*p = ntohl(*p);
		p++;
	}
}

static int
yds_download_mcode(struct yds_softc *sc)
{
	u_int ctrl;
	const u_int32_t *p;
	size_t size;
	u_char *buf;
	size_t buflen;
	int error;
	struct yds_firmware *yf;

	error = loadfirmware("yds", &buf, &buflen);
	if (error)
		return 1;
	yf = (struct yds_firmware *)buf;

	if (sc->sc_flags & YDS_CAP_MCODE_1) {
		p = (u_int32_t *)&yf->data[ntohl(yf->dsplen)];
		size = ntohl(yf->ds1len);
	} else if (sc->sc_flags & YDS_CAP_MCODE_1E) {
		p = (u_int32_t *)&yf->data[ntohl(yf->dsplen) + ntohl(yf->ds1len)];
		size = ntohl(yf->ds1elen);
	} else {
		free(buf, M_DEVBUF, buflen);
		return 1;	/* unknown */
	}

	if (size > buflen) {
		printf("%s: old firmware file, update please\n",
		    sc->sc_dev.dv_xname);
		free(buf, M_DEVBUF, buflen);
		return 1;
	}

	if (yds_disable_dsp(sc)) {
		free(buf, M_DEVBUF, buflen);
		return 1;
	}

	/* Software reset */
        YWRITE4(sc, YDS_MODE, YDS_MODE_RESET);
        YWRITE4(sc, YDS_MODE, 0);

        YWRITE4(sc, YDS_MAPOF_REC, 0);
        YWRITE4(sc, YDS_MAPOF_EFFECT, 0);
        YWRITE4(sc, YDS_PLAY_CTRLBASE, 0);
        YWRITE4(sc, YDS_REC_CTRLBASE, 0);
        YWRITE4(sc, YDS_EFFECT_CTRLBASE, 0);
        YWRITE4(sc, YDS_WORK_BASE, 0);

        ctrl = YREAD2(sc, YDS_GLOBAL_CONTROL);
        YWRITE2(sc, YDS_GLOBAL_CONTROL, ctrl & ~0x0007);

	/* Download DSP microcode. */
	nswaph((u_int32_t *)&yf->data[0], ntohl(yf->dsplen));
	YWRITEREGION4(sc, YDS_DSP_INSTRAM, (u_int32_t *)&yf->data[0],
	    ntohl(yf->dsplen));

	/* Download CONTROL microcode. */
	nswaph((u_int32_t *)p, size);
	YWRITEREGION4(sc, YDS_CTRL_INSTRAM, p, size);

	yds_enable_dsp(sc);
	delay(10*1000);		/* neccesary on my 724F (??) */

	free(buf, M_DEVBUF, buflen);
	return 0;
}

static int
yds_allocate_slots(struct yds_softc *sc, int resuming)
{
	size_t pcs, rcs, ecs, ws, memsize;
	void *mp;
	u_int32_t da;		/* DMA address */
	char *va;		/* KVA */
	off_t cb;
	int i;
	struct yds_dma *p;

	/* Alloc DSP Control Data */
	pcs = YREAD4(sc, YDS_PLAY_CTRLSIZE) * sizeof(u_int32_t);
	rcs = YREAD4(sc, YDS_REC_CTRLSIZE) * sizeof(u_int32_t);
	ecs = YREAD4(sc, YDS_EFFECT_CTRLSIZE) * sizeof(u_int32_t);
	ws = WORK_SIZE;
	YWRITE4(sc, YDS_WORK_SIZE, ws / sizeof(u_int32_t));

	DPRINTF(("play control size : %d\n", (unsigned int)pcs));
	DPRINTF(("rec control size : %d\n", (unsigned int)rcs));
	DPRINTF(("eff control size : %d\n", (unsigned int)ecs));
	DPRINTF(("work size : %d\n", (unsigned int)ws));
#ifdef DIAGNOSTIC
	if (pcs != sizeof(struct play_slot_ctrl_bank)) {
		printf("%s: invalid play slot ctrldata %d != %d\n",
		       sc->sc_dev.dv_xname, (unsigned int)pcs,
		       (unsigned int)sizeof(struct play_slot_ctrl_bank));
	}
	if (rcs != sizeof(struct rec_slot_ctrl_bank)) {
		printf("%s: invalid rec slot ctrldata %d != %d\n",
		       sc->sc_dev.dv_xname, (unsigned int)rcs,
		       (unsigned int)sizeof(struct rec_slot_ctrl_bank));
        }
#endif

	memsize = N_PLAY_SLOTS*N_PLAY_SLOT_CTRL_BANK*pcs +
		  N_REC_SLOT_CTRL*N_REC_SLOT_CTRL_BANK*rcs + ws;
	memsize += (N_PLAY_SLOTS+1)*sizeof(u_int32_t);

	p = &sc->sc_ctrldata;
	if (!resuming) {
		i = yds_allocmem(sc, memsize, 16, p);
		if (i) {
			printf("%s: couldn't alloc/map DSP DMA buffer, reason %d\n",
			       sc->sc_dev.dv_xname, i);
			free(p, M_DEVBUF, 0);
			return 1;
		}
	}
	mp = KERNADDR(p);
	da = DMAADDR(p);

	DPRINTF(("mp:%p, DMA addr:%p\n",
		 mp, (void *) sc->sc_ctrldata.map->dm_segs[0].ds_addr));

	bzero(mp, memsize);

	/* Work space */
        cb = 0;
	va = (u_int8_t*)mp;
	YWRITE4(sc, YDS_WORK_BASE, da + cb);
        cb += ws;

	/* Play control data table */
        sc->ptbl = (u_int32_t *)(va + cb);
	sc->ptbloff = cb;
        YWRITE4(sc, YDS_PLAY_CTRLBASE, da + cb);
        cb += (N_PLAY_SLOT_CTRL + 1) * sizeof(u_int32_t);

	/* Record slot control data */
        sc->rbank = (struct rec_slot_ctrl_bank *)(va + cb);
        YWRITE4(sc, YDS_REC_CTRLBASE, da + cb);
	sc->rbankoff = cb;
        cb += N_REC_SLOT_CTRL * N_REC_SLOT_CTRL_BANK * rcs;

#if 0
	/* Effect slot control data -- unused */
        YWRITE4(sc, YDS_EFFECT_CTRLBASE, da + cb);
        cb += N_EFFECT_SLOT_CTRL * N_EFFECT_SLOT_CTRL_BANK * ecs;
#endif

	/* Play slot control data */
        sc->pbankoff = da + cb;
        for (i=0; i<N_PLAY_SLOT_CTRL; i++) {
		sc->pbankp[i*2] = (struct play_slot_ctrl_bank *)(va + cb);
		*(sc->ptbl + i+1) = da + cb;
                cb += pcs;

                sc->pbankp[i*2+1] = (struct play_slot_ctrl_bank *)(va + cb);
                cb += pcs;
        }
	/* Sync play control data table */
	bus_dmamap_sync(sc->sc_dmatag, p->map,
			sc->ptbloff, (N_PLAY_SLOT_CTRL+1) * sizeof(u_int32_t),
			BUS_DMASYNC_PREWRITE);

	return 0;
}

static void
yds_enable_dsp(struct yds_softc *sc)
{
	YWRITE4(sc, YDS_CONFIG, YDS_DSP_SETUP);
}

static int
yds_disable_dsp(struct yds_softc *sc)
{
	int to;
	u_int32_t data;

	data = YREAD4(sc, YDS_CONFIG);
	if (data)
		YWRITE4(sc, YDS_CONFIG, YDS_DSP_DISABLE);

	for (to = 0; to < YDS_WORK_TIMEOUT; to++) {
		if ((YREAD4(sc, YDS_STATUS) & YDS_STAT_WORK) == 0)
			return 0;
		delay(1);
	}

	return 1;
}

int
yds_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = (struct pci_attach_args *) aux;

	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_YAMAHA:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_YAMAHA_YMF724:
		case PCI_PRODUCT_YAMAHA_YMF740:
		case PCI_PRODUCT_YAMAHA_YMF740C:
		case PCI_PRODUCT_YAMAHA_YMF724F:
		case PCI_PRODUCT_YAMAHA_YMF744:
		case PCI_PRODUCT_YAMAHA_YMF754:
		/* 734, 737, 738?? */
			return (1);
		}
		break;
	}

	return (0);
}

/*
 * This routine is called after all the ISA devices are configured,
 * to avoid conflict.
 */
static void
yds_configure_legacy(struct yds_softc *sc)
#define FLEXIBLE	(sc->sc_flags & YDS_CAP_LEGACY_FLEXIBLE)
#define SELECTABLE	(sc->sc_flags & YDS_CAP_LEGACY_SELECTABLE)
{
	pcireg_t reg;
	struct device *dev;
	int i;
	bus_addr_t opl_addrs[] = {0x388, 0x398, 0x3A0, 0x3A8};
	bus_addr_t mpu_addrs[] = {0x330, 0x300, 0x332, 0x334};

	if (!FLEXIBLE && !SELECTABLE)
		return;

	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, YDS_PCI_LEGACY);
	reg &= ~0x8133c03f;	/* these bits are out of interest */
	reg |= (YDS_PCI_EX_LEGACY_IMOD | YDS_PCI_LEGACY_FMEN |
		YDS_PCI_LEGACY_MEN /*| YDS_PCI_LEGACY_MIEN*/);
	if (sc->sc_flags & YDS_CAP_LEGACY_SMOD_DISABLE)
		reg |= YDS_PCI_EX_LEGACY_SMOD_DISABLE;
	if (FLEXIBLE) {
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, YDS_PCI_LEGACY, reg);
		delay(100*1000);
	}

	/* Look for OPL */
	dev = 0;
	for (i = 0; i < sizeof(opl_addrs) / sizeof (bus_addr_t); i++) {
		if (SELECTABLE) {
			pci_conf_write(sc->sc_pc, sc->sc_pcitag,
				       YDS_PCI_LEGACY, reg | (i << (0+16)));
			delay(100*1000);	/* wait 100ms */
		} else
			pci_conf_write(sc->sc_pc, sc->sc_pcitag,
				       YDS_PCI_FM_BA, opl_addrs[i]);
		if (bus_space_map(sc->sc_opl_iot,
				  opl_addrs[i], 4, 0, &sc->sc_opl_ioh) == 0) {
			struct audio_attach_args aa; 

			aa.type = AUDIODEV_TYPE_OPL;
			aa.hwif = aa.hdl = NULL;
			dev = config_found(&sc->sc_dev, &aa, audioprint);
			if (dev == 0)
				bus_space_unmap(sc->sc_opl_iot,
						sc->sc_opl_ioh, 4);
			else {
				if (SELECTABLE)
					reg |= (i << (0+16));
				break;
			}
		} 
	}
	if (dev == 0) {
		reg &= ~YDS_PCI_LEGACY_FMEN;
		pci_conf_write(sc->sc_pc, sc->sc_pcitag,
			       YDS_PCI_LEGACY, reg);
	} else {
		/* Max. volume */
		YWRITE4(sc, YDS_LEGACY_OUT_VOLUME, 0x3fff3fff);
		YWRITE4(sc, YDS_LEGACY_REC_VOLUME, 0x3fff3fff);
	}

	/* Look for MPU */
	dev = 0;
	for (i = 0; i < sizeof(mpu_addrs) / sizeof (bus_addr_t); i++) {
		if (SELECTABLE)
			pci_conf_write(sc->sc_pc, sc->sc_pcitag,
				       YDS_PCI_LEGACY, reg | (i << (4+16)));
		else
			pci_conf_write(sc->sc_pc, sc->sc_pcitag,
				       YDS_PCI_MPU_BA, mpu_addrs[i]);
		if (bus_space_map(sc->sc_mpu_iot,
				  mpu_addrs[i], 2, 0, &sc->sc_mpu_ioh) == 0) {
			struct audio_attach_args aa; 

			aa.type = AUDIODEV_TYPE_MPU;
			aa.hwif = aa.hdl = NULL;
			dev = config_found(&sc->sc_dev, &aa, audioprint);
			if (dev == 0)
				bus_space_unmap(sc->sc_mpu_iot,
						sc->sc_mpu_ioh, 2);
			else {
				if (SELECTABLE)
					reg |= (i << (4+16));
				break;
			}
		}
	}
	if (dev == 0) {
		reg &= ~(YDS_PCI_LEGACY_MEN | YDS_PCI_LEGACY_MIEN);
		pci_conf_write(sc->sc_pc, sc->sc_pcitag,
			       YDS_PCI_LEGACY, reg);
	}
	sc->sc_mpu = dev;
} 
#undef FLEXIBLE
#undef SELECTABLE

void
yds_attach(struct device *parent, struct device *self, void *aux)
{
	struct yds_softc *sc = (struct yds_softc *)self;
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	char const *intrstr;
	pci_intr_handle_t ih;
	bus_size_t size;
	pcireg_t reg;
	int i;

	/* Map register to memory */
	if (pci_mapreg_map(pa, YDS_PCI_MBA, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->memt, &sc->memh, NULL, &size, 0)) {
		printf(": can't map mem space\n");
		return;
	}

	/* Map and establish the interrupt. */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		bus_space_unmap(sc->memt, sc->memh, size);
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO | IPL_MPSAFE,
	    yds_intr, sc, self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(sc->memt, sc->memh, size);
		return;
	}
	printf(": %s\n", intrstr);

	sc->sc_dmatag = pa->pa_dmat;
	sc->sc_pc = pc;
	sc->sc_pcitag = pa->pa_tag;
	sc->sc_id = pa->pa_id;
	sc->sc_revision = PCI_REVISION(pa->pa_class);
	sc->sc_flags = yds_get_dstype(sc->sc_id);
	if (sc->sc_dev.dv_cfdata->cf_flags & YDS_CAP_LEGACY_SMOD_DISABLE)
		sc->sc_flags |= YDS_CAP_LEGACY_SMOD_DISABLE;
#ifdef AUDIO_DEBUG
	if (ydsdebug)
		printf("%s: chip has %b\n", sc->sc_dev.dv_xname,
		    sc->sc_flags, YDS_CAP_BITS);
#endif

	/* Disable legacy mode */
	reg = pci_conf_read(pc, pa->pa_tag, YDS_PCI_LEGACY);
	pci_conf_write(pc, pa->pa_tag, YDS_PCI_LEGACY,
		       reg & YDS_PCI_LEGACY_LAD);

	/* Mute all volumes */
	for (i = 0x80; i < 0xc0; i += 2)
		YWRITE2(sc, i, 0);

	sc->sc_legacy_iot = pa->pa_iot;
	config_mountroot(self, yds_attachhook);
}

void
yds_attachhook(struct device *self)
{
	struct yds_softc *sc = (struct yds_softc *)self;
	struct yds_codec_softc *codec;
	mixer_ctrl_t ctl;
	int r, i;

	/* Initialize the device */
	if (yds_init(sc, 0) == -1)
		return;

	/*
	 * Attach ac97 codec
	 */
	for (i = 0; i < 2; i++) {
		static struct {
			int data;
			int addr;
		} statregs[] = {
			{AC97_STAT_DATA1, AC97_STAT_ADDR1},
			{AC97_STAT_DATA2, AC97_STAT_ADDR2},
		};

		if (i == 1 && ac97_id2 == -1)
			break;		/* secondary ac97 not available */

		codec = &sc->sc_codec[i];
		memcpy(&codec->sc_dev, &sc->sc_dev, sizeof(codec->sc_dev));
		codec->sc = sc;
		codec->id = i == 1 ? ac97_id2 : 0;
		codec->status_data = statregs[i].data;
		codec->status_addr = statregs[i].addr;
		codec->host_if.arg = codec;
		codec->host_if.attach = yds_attach_codec;
		codec->host_if.read = yds_read_codec;
		codec->host_if.write = yds_write_codec;
		codec->host_if.reset = yds_reset_codec;

		if ((r = ac97_attach(&codec->host_if)) != 0) {
			printf("%s: can't attach codec (error 0x%X)\n",
				sc->sc_dev.dv_xname, r);
			return;
		}
	}

	/* Just enable the DAC and master volumes by default */
	ctl.type = AUDIO_MIXER_ENUM;
	ctl.un.ord = 0;  /* off */
	ctl.dev = yds_get_portnum_by_name(sc, AudioCoutputs,
	       AudioNmaster, AudioNmute);
	yds_mixer_set_port(sc, &ctl);
	ctl.dev = yds_get_portnum_by_name(sc, AudioCinputs,
	       AudioNdac, AudioNmute);
	yds_mixer_set_port(sc, &ctl);
	ctl.dev = yds_get_portnum_by_name(sc, AudioCinputs,
	       AudioNcd, AudioNmute);
	yds_mixer_set_port(sc, &ctl);
	ctl.dev = yds_get_portnum_by_name(sc, AudioCrecord,
	       AudioNvolume, AudioNmute);
	yds_mixer_set_port(sc, &ctl);
	
	ctl.dev = yds_get_portnum_by_name(sc, AudioCrecord,
	       AudioNsource, NULL);
	ctl.type = AUDIO_MIXER_ENUM;
	ctl.un.ord = 0;
	yds_mixer_set_port(sc, &ctl);

	/* Set a reasonable default volume */
	ctl.type = AUDIO_MIXER_VALUE;
	ctl.un.value.num_channels = 2;
	ctl.un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
	ctl.un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = 127;

	ctl.dev = sc->sc_codec[0].codec_if->vtbl->get_portnum_by_name(
		sc->sc_codec[0].codec_if, AudioCoutputs, AudioNmaster, NULL);
	yds_mixer_set_port(sc, &ctl);

	audio_attach_mi(&yds_hw_if, sc, &sc->sc_dev);

	/* Watch for power changes */
	sc->suspend = DVACT_RESUME;
	yds_configure_legacy(sc);
}

int
yds_attach_codec(void *sc_, struct ac97_codec_if *codec_if)
{
	struct yds_codec_softc *sc = sc_;

	sc->codec_if = codec_if;
	return 0;
}

static int
yds_ready_codec(struct yds_codec_softc *sc)
{
	int to;

	for (to = 0; to < AC97_TIMEOUT; to++) {
		if ((YREAD2(sc->sc, sc->status_addr) & AC97_BUSY) == 0)
			return 0;
		delay(1);
	}

	return 1;
}

int
yds_read_codec(void *sc_, u_int8_t reg, u_int16_t *data)
{
	struct yds_codec_softc *sc = sc_;

	YWRITE2(sc->sc, AC97_CMD_ADDR, AC97_CMD_READ | AC97_ID(sc->id) | reg);

	if (yds_ready_codec(sc)) {
		printf("%s: yds_read_codec timeout\n",
		       sc->sc->sc_dev.dv_xname);
		return EIO;
	}

	if (PCI_PRODUCT(sc->sc->sc_id) == PCI_PRODUCT_YAMAHA_YMF744 &&
	    sc->sc->sc_revision < 2) {
		int i;

		for (i = 0; i < 600; i++)
			YREAD2(sc->sc, sc->status_data);
	}
	*data = YREAD2(sc->sc, sc->status_data);

	return 0;
}

int
yds_write_codec(void *sc_, u_int8_t reg, u_int16_t data)
{
	struct yds_codec_softc *sc = sc_;

	YWRITE2(sc->sc, AC97_CMD_ADDR, AC97_CMD_WRITE | AC97_ID(sc->id) | reg);
	YWRITE2(sc->sc, AC97_CMD_DATA, data);

	if (yds_ready_codec(sc)) {
		printf("%s: yds_write_codec timeout\n",
			sc->sc->sc_dev.dv_xname);
		return EIO;
	}

	return 0;
}

/*
 * XXX: Must handle the secondary differntly!!
 */
void
yds_reset_codec(void *sc_)
{
	struct yds_codec_softc *codec = sc_;
	struct yds_softc *sc = codec->sc;
	pcireg_t reg;

	/* reset AC97 codec */
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, YDS_PCI_DSCTRL);
	if (reg & 0x03) {
		pci_conf_write(sc->sc_pc, sc->sc_pcitag,
			       YDS_PCI_DSCTRL, reg & ~0x03);
		pci_conf_write(sc->sc_pc, sc->sc_pcitag,
			       YDS_PCI_DSCTRL, reg | 0x03);
		pci_conf_write(sc->sc_pc, sc->sc_pcitag,
			       YDS_PCI_DSCTRL, reg & ~0x03);
		delay(50000);
	}

	yds_ready_codec(sc_);
}

int
yds_intr(void *p)
{
	struct yds_softc *sc = p;
	u_int status;

	mtx_enter(&audio_lock);
	status = YREAD4(sc, YDS_STATUS);
	DPRINTFN(1, ("yds_intr: status=%08x\n", status));
	if ((status & (YDS_STAT_INT|YDS_STAT_TINT)) == 0) {
#if 0
		if (sc->sc_mpu)
			return mpu_intr(sc->sc_mpu);
#endif
		mtx_leave(&audio_lock);
		return 0;
	}

	if (status & YDS_STAT_TINT) {
		YWRITE4(sc, YDS_STATUS, YDS_STAT_TINT);
		printf ("yds_intr: timeout!\n");
	}

	if (status & YDS_STAT_INT) {
		int nbank = (YREAD4(sc, YDS_CONTROL_SELECT) == 0);

		/* Clear interrupt flag */
		YWRITE4(sc, YDS_STATUS, YDS_STAT_INT);

		/* Buffer for the next frame is always ready. */
		YWRITE4(sc, YDS_MODE, YREAD4(sc, YDS_MODE) | YDS_MODE_ACTV2);

		if (sc->sc_play.intr) {
			u_int dma, cpu, blk, len;

			/* Sync play slot control data */
			bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
					sc->pbankoff,
					sizeof(struct play_slot_ctrl_bank)*
					    (*sc->ptbl)*
					    N_PLAY_SLOT_CTRL_BANK,
					BUS_DMASYNC_POSTWRITE|
					BUS_DMASYNC_POSTREAD);
			dma = sc->pbankp[nbank]->pgstart;
			cpu = sc->sc_play.offset;
			blk = sc->sc_play.blksize;
			len = sc->sc_play.length;

			if (((dma > cpu) && (dma - cpu > blk * 2)) ||
			    ((cpu > dma) && (dma + len - cpu > blk * 2))) {
				/* We can fill the next block */
				/* Sync ring buffer for previous write */
				bus_dmamap_sync(sc->sc_dmatag,
						sc->sc_play.dma->map,
						cpu, blk,
						BUS_DMASYNC_POSTWRITE);
				sc->sc_play.intr(sc->sc_play.intr_arg);
				sc->sc_play.offset += blk;
				if (sc->sc_play.offset >= len) {
					sc->sc_play.offset -= len;
#ifdef DIAGNOSTIC
					if (sc->sc_play.offset != 0)
						printf ("Audio ringbuffer botch\n");
#endif
				}
				/* Sync ring buffer for next write */
				bus_dmamap_sync(sc->sc_dmatag,
						sc->sc_play.dma->map,
						cpu, blk,
						BUS_DMASYNC_PREWRITE);
			}
		}
		if (sc->sc_rec.intr) {
			u_int dma, cpu, blk, len;

			/* Sync rec slot control data */
			bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
					sc->rbankoff,
					sizeof(struct rec_slot_ctrl_bank)*
					    N_REC_SLOT_CTRL*
					    N_REC_SLOT_CTRL_BANK,
					BUS_DMASYNC_POSTWRITE|
					BUS_DMASYNC_POSTREAD);
			dma = sc->rbank[YDS_INPUT_SLOT*2 + nbank].pgstartadr;
			cpu = sc->sc_rec.offset;
			blk = sc->sc_rec.blksize;
			len = sc->sc_rec.length;

			if (((dma > cpu) && (dma - cpu > blk * 2)) ||
			    ((cpu > dma) && (dma + len - cpu > blk * 2))) {
				/* We can drain the current block */
				/* Sync ring buffer first */
				bus_dmamap_sync(sc->sc_dmatag,
						sc->sc_rec.dma->map,
						cpu, blk,
						BUS_DMASYNC_POSTREAD);
				sc->sc_rec.intr(sc->sc_rec.intr_arg);
				sc->sc_rec.offset += blk;
				if (sc->sc_rec.offset >= len) {
					sc->sc_rec.offset -= len;
#ifdef DIAGNOSTIC
					if (sc->sc_rec.offset != 0)
						printf ("Audio ringbuffer botch\n");
#endif
				}
				/* Sync ring buffer for next read */
				bus_dmamap_sync(sc->sc_dmatag,
						sc->sc_rec.dma->map,
						cpu, blk,
						BUS_DMASYNC_PREREAD);
			}
		}
	}
	mtx_leave(&audio_lock);
	return 1;
}

int
yds_allocmem(struct yds_softc *sc, size_t size, size_t align, struct yds_dma *p)
{
	int error;

	p->size = size;
	error = bus_dmamem_alloc(sc->sc_dmatag, p->size, align, 0,
				 p->segs, nitems(p->segs),
				 &p->nsegs, BUS_DMA_NOWAIT);
	if (error)
		return (error);

	error = bus_dmamem_map(sc->sc_dmatag, p->segs, p->nsegs, p->size, 
			       &p->addr, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);
	if (error)
		goto free;

	error = bus_dmamap_create(sc->sc_dmatag, p->size, 1, p->size,
				  0, BUS_DMA_NOWAIT, &p->map);
	if (error)
		goto unmap;

	error = bus_dmamap_load(sc->sc_dmatag, p->map, p->addr, p->size, NULL, 
				BUS_DMA_NOWAIT);
	if (error)
		goto destroy;
	return (0);

destroy:
	bus_dmamap_destroy(sc->sc_dmatag, p->map);
unmap:
	bus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);
free:
	bus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);
	return (error);
}

int
yds_freemem(struct yds_softc *sc, struct yds_dma *p)
{
	bus_dmamap_unload(sc->sc_dmatag, p->map);
	bus_dmamap_destroy(sc->sc_dmatag, p->map);
	bus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);
	bus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);
	return 0;
}

int
yds_open(void *addr, int flags)
{
	struct yds_softc *sc = addr;
	int mode;

	/* Select bank 0. */
	YWRITE4(sc, YDS_CONTROL_SELECT, 0);

	/* Start the DSP operation. */
	mode = YREAD4(sc, YDS_MODE);
	mode |= YDS_MODE_ACTV;
	mode &= ~YDS_MODE_ACTV2;
	YWRITE4(sc, YDS_MODE, mode);

	return 0;
}

/*
 * Close function is called at splaudio().
 */
void
yds_close(void *addr)
{
	struct yds_softc *sc = addr;

	yds_halt_output(sc);
	yds_halt_input(sc);
	yds_halt(sc);
}

int
yds_set_params(void *addr, int setmode, int usemode,
    struct audio_params *play, struct audio_params *rec)
{
	struct audio_params *p;
	int mode;

	for (mode = AUMODE_RECORD; mode != -1; 
	     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
		if ((setmode & mode) == 0)
			continue;

		p = mode == AUMODE_PLAY ? play : rec;

		if (p->sample_rate < 4000)
			p->sample_rate = 4000;
		if (p->sample_rate > 48000)
			p->sample_rate = 48000;
		if (p->precision > 16)
			p->precision = 16;
		if (p->channels > 2)
			p->channels = 2;

		switch (p->encoding) {
		case AUDIO_ENCODING_SLINEAR_LE:
			if (p->precision != 16)
				return EINVAL;
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
		case AUDIO_ENCODING_ULINEAR_BE:
			if (p->precision != 8)
				return EINVAL;
			break;
		default:
			return (EINVAL);
		}
		p->bps = AUDIO_BPS(p->precision);
		p->msb = 1;
	}

	return 0;
}

int
yds_round_blocksize(void *addr, int blk)
{
	/*
	 * Block size must be bigger than a frame.
	 * That is 1024bytes at most, i.e. for 48000Hz, 16bit, 2ch.
	 */
	if (blk < 1024)
		blk = 1024;

	return blk & ~4;
}

static u_int32_t
yds_get_lpfq(u_int sample_rate)
{
	int i;
	static struct lpfqt {
		u_int rate;
		u_int32_t lpfq;
	} lpfqt[] = {
		{8000,  0x32020000},
		{11025, 0x31770000},
		{16000, 0x31390000},
		{22050, 0x31c90000},
		{32000, 0x33d00000},
		{48000, 0x40000000},
		{0, 0}
	};

	if (sample_rate == 44100)		/* for P44 slot? */
		return 0x370A0000;

	for (i = 0; lpfqt[i].rate != 0; i++)
		if (sample_rate <= lpfqt[i].rate)
			break;

	return lpfqt[i].lpfq;
}

static u_int32_t
yds_get_lpfk(u_int sample_rate)
{
	int i;
	static struct lpfkt {
		u_int rate;
		u_int32_t lpfk;
	} lpfkt[] = {
		{8000,  0x18b20000},
		{11025, 0x20930000},
		{16000, 0x2b9a0000},
		{22050, 0x35a10000},
		{32000, 0x3eaa0000},
		{48000, 0x40000000},
		{0, 0}
	};

	if (sample_rate == 44100)		/* for P44 slot? */
		return 0x46460000;

	for (i = 0; lpfkt[i].rate != 0; i++)
		if (sample_rate <= lpfkt[i].rate)
			break;

	return lpfkt[i].lpfk;
}

int
yds_trigger_output(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
#define P44		(sc->sc_flags & YDS_CAP_HAS_P44)
{
	struct yds_softc *sc = addr;
	struct yds_dma *p;
	struct play_slot_ctrl_bank *psb;
	const u_int gain = 0x40000000;
	bus_addr_t s;
	size_t l;
	int i;
	int p44, channels;

	mtx_enter(&audio_lock);
#ifdef DIAGNOSTIC
	if (sc->sc_play.intr)
		panic("yds_trigger_output: already running");
#endif
	sc->sc_play.intr = intr;
	sc->sc_play.intr_arg = arg;
	sc->sc_play.offset = 0;
	sc->sc_play.blksize = blksize;

	DPRINTFN(1, ("yds_trigger_output: sc=%p start=%p end=%p "
	    "blksize=%d intr=%p(%p)\n", addr, start, end, blksize, intr, arg));

	p = yds_find_dma(sc, start);
	if (!p) {
		printf("yds_trigger_output: bad addr %p\n", start);
		mtx_leave(&audio_lock);
		return (EINVAL);
	}
	sc->sc_play.dma = p;

#ifdef DIAGNOSTIC
	{
		u_int32_t ctrlsize;
		if ((ctrlsize = YREAD4(sc, YDS_PLAY_CTRLSIZE)) !=
		    sizeof(struct play_slot_ctrl_bank) / sizeof(u_int32_t))
			panic("%s: invalid play slot ctrldata %d %zd",
			      sc->sc_dev.dv_xname, ctrlsize,
			      sizeof(struct play_slot_ctrl_bank));
	}
#endif

#ifdef YDS_USE_P44
	/* The document says the P44 SRC supports only stereo, 16bit PCM. */
	if (P44)
		p44 = ((param->sample_rate == 44100) &&
		       (param->channels == 2) &&
		       (param->precision == 16));
	else
#endif
		p44 = 0;
	channels = p44 ? 1 : param->channels;

	s = DMAADDR(p);
	l = ((char *)end - (char *)start);
	sc->sc_play.length = l;

	*sc->ptbl = channels;	/* Num of play */

	psb = sc->pbankp[0];
	memset(psb, 0, sizeof(*psb));
	psb->format = ((channels == 2 ? PSLT_FORMAT_STEREO : 0) |
		       (param->precision == 8 ? PSLT_FORMAT_8BIT : 0) |
		       (p44 ? PSLT_FORMAT_SRC441 : 0));
	psb->pgbase = s;
	psb->pgloopend = l;
	if (!p44) {
		psb->pgdeltaend = (param->sample_rate * 65536 / 48000) << 12;
		psb->lpfkend = yds_get_lpfk(param->sample_rate);
		psb->eggainend = gain;
		psb->lpfq = yds_get_lpfq(param->sample_rate);
		psb->pgdelta = psb->pgdeltaend;
		psb->lpfk = yds_get_lpfk(param->sample_rate);
		psb->eggain = gain;
	}

	for (i = 0; i < channels; i++) {
		/* i == 0: left or mono, i == 1: right */
		psb = sc->pbankp[i*2];
		if (i)
			/* copy from left */
			*psb = *(sc->pbankp[0]);
		if (channels == 2) {
			/* stereo */
			if (i == 0) {
				psb->lchgain = psb->lchgainend = gain;
			} else {
				psb->lchgain = psb->lchgainend = 0;
				psb->rchgain = psb->rchgainend = gain;
				psb->format |= PSLT_FORMAT_RCH;
			}
		} else if (!p44) {
			/* mono */
			psb->lchgain = psb->rchgain = gain;
			psb->lchgainend = psb->rchgainend = gain;
		}
		/* copy to the other bank */
		*(sc->pbankp[i*2+1]) = *psb;
	}

	YDS_DUMP_PLAY_SLOT(5, sc, 0);
	YDS_DUMP_PLAY_SLOT(5, sc, 1);

	if (p44)
		YWRITE4(sc, YDS_P44_OUT_VOLUME, 0x3fff3fff);
	else
		YWRITE4(sc, YDS_DAC_OUT_VOLUME, 0x3fff3fff);

	/* Now the play slot for the next frame is set up!! */
	/* Sync play slot control data for both directions */
	bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
			sc->ptbloff,
			sizeof(struct play_slot_ctrl_bank) *
			    channels * N_PLAY_SLOT_CTRL_BANK,
			BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
	/* Sync ring buffer */
	bus_dmamap_sync(sc->sc_dmatag, p->map, 0, blksize,
			BUS_DMASYNC_PREWRITE);
	/* HERE WE GO!! */
	YWRITE4(sc, YDS_MODE,
		YREAD4(sc, YDS_MODE) | YDS_MODE_ACTV | YDS_MODE_ACTV2);
	mtx_leave(&audio_lock);
	return 0;
}
#undef P44

int
yds_trigger_input(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct yds_softc *sc = addr;
	struct yds_dma *p;
	u_int srate, format;
	struct rec_slot_ctrl_bank *rsb;
	bus_addr_t s;
	size_t l;

	mtx_enter(&audio_lock);
#ifdef DIAGNOSTIC
	if (sc->sc_rec.intr)
		panic("yds_trigger_input: already running");
#endif
	sc->sc_rec.intr = intr;
	sc->sc_rec.intr_arg = arg;
	sc->sc_rec.offset = 0;
	sc->sc_rec.blksize = blksize;

	DPRINTFN(1, ("yds_trigger_input: "
	    "sc=%p start=%p end=%p blksize=%d intr=%p(%p)\n", 
	    addr, start, end, blksize, intr, arg));
	DPRINTFN(1, (" parameters: rate=%lu, precision=%u, channels=%u\n",
	    param->sample_rate, param->precision, param->channels));

	p = yds_find_dma(sc, start);
	if (!p) {
		printf("yds_trigger_input: bad addr %p\n", start);
		mtx_leave(&audio_lock);
		return (EINVAL);
	}
	sc->sc_rec.dma = p;

	s = DMAADDR(p);
	l = ((char *)end - (char *)start);
	sc->sc_rec.length = l;

	rsb = &sc->rbank[0];
	memset(rsb, 0, sizeof(*rsb));
	rsb->pgbase = s;
	rsb->pgloopendadr = l;
	/* Seems all 4 banks must be set up... */
	sc->rbank[1] = *rsb;
	sc->rbank[2] = *rsb;
	sc->rbank[3] = *rsb;

	YWRITE4(sc, YDS_ADC_IN_VOLUME, 0x3fff3fff);
	YWRITE4(sc, YDS_REC_IN_VOLUME, 0x3fff3fff);
	srate = 48000 * 4096 / param->sample_rate - 1;
	format = ((param->precision == 8 ? YDS_FORMAT_8BIT : 0) |
		  (param->channels == 2 ? YDS_FORMAT_STEREO : 0));
	DPRINTF(("srate=%d, format=%08x\n", srate, format));
#ifdef YDS_USE_REC_SLOT
	YWRITE4(sc, YDS_DAC_REC_VOLUME, 0x3fff3fff);
	YWRITE4(sc, YDS_P44_REC_VOLUME, 0x3fff3fff);
	YWRITE4(sc, YDS_MAPOF_REC, YDS_RECSLOT_VALID);
	YWRITE4(sc, YDS_REC_SAMPLE_RATE, srate);
	YWRITE4(sc, YDS_REC_FORMAT, format);
#else
	YWRITE4(sc, YDS_MAPOF_REC, YDS_ADCSLOT_VALID);
	YWRITE4(sc, YDS_ADC_SAMPLE_RATE, srate);
	YWRITE4(sc, YDS_ADC_FORMAT, format);
#endif
	/* Now the rec slot for the next frame is set up!! */
	/* Sync record slot control data */
	bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
			sc->rbankoff,
			sizeof(struct rec_slot_ctrl_bank)*
			    N_REC_SLOT_CTRL*
			    N_REC_SLOT_CTRL_BANK,
			BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
	/* Sync ring buffer */
	bus_dmamap_sync(sc->sc_dmatag, p->map, 0, blksize,
			BUS_DMASYNC_PREREAD);
	/* HERE WE GO!! */
	YWRITE4(sc, YDS_MODE,
		YREAD4(sc, YDS_MODE) | YDS_MODE_ACTV | YDS_MODE_ACTV2);
	mtx_leave(&audio_lock);
	return 0;
}

static int
yds_halt(struct yds_softc *sc)
{
	u_int32_t mode;

	/* Stop the DSP operation. */
	mode = YREAD4(sc, YDS_MODE);
	YWRITE4(sc, YDS_MODE, mode & ~(YDS_MODE_ACTV|YDS_MODE_ACTV2));

	/* Paranoia...  mute all */
	YWRITE4(sc, YDS_P44_OUT_VOLUME, 0);
	YWRITE4(sc, YDS_DAC_OUT_VOLUME, 0);
	YWRITE4(sc, YDS_ADC_IN_VOLUME, 0);
	YWRITE4(sc, YDS_REC_IN_VOLUME, 0);
	YWRITE4(sc, YDS_DAC_REC_VOLUME, 0);
	YWRITE4(sc, YDS_P44_REC_VOLUME, 0);

	return 0;
}

int
yds_halt_output(void *addr)
{
	struct yds_softc *sc = addr;

	DPRINTF(("yds: yds_halt_output\n"));
	mtx_enter(&audio_lock);
	if (sc->sc_play.intr) {
		sc->sc_play.intr = 0;
		/* Sync play slot control data */
		bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
				sc->pbankoff,
				sizeof(struct play_slot_ctrl_bank)*
				    (*sc->ptbl)*N_PLAY_SLOT_CTRL_BANK,
				BUS_DMASYNC_POSTWRITE|BUS_DMASYNC_POSTREAD);
		/* Stop the play slot operation */
		sc->pbankp[0]->status =
		sc->pbankp[1]->status =
		sc->pbankp[2]->status =
		sc->pbankp[3]->status = 1;
		/* Sync ring buffer */
		bus_dmamap_sync(sc->sc_dmatag, sc->sc_play.dma->map,
				0, sc->sc_play.length, BUS_DMASYNC_POSTWRITE);
	}
	mtx_leave(&audio_lock);
	return 0;
}

int
yds_halt_input(void *addr)
{
	struct yds_softc *sc = addr;

	DPRINTF(("yds: yds_halt_input\n"));
	mtx_enter(&audio_lock);
	if (sc->sc_rec.intr) {
		/* Stop the rec slot operation */
		YWRITE4(sc, YDS_MAPOF_REC, 0);
		sc->sc_rec.intr = 0;
		/* Sync rec slot control data */
		bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
				sc->rbankoff,
				sizeof(struct rec_slot_ctrl_bank)*
				    N_REC_SLOT_CTRL*N_REC_SLOT_CTRL_BANK,
				BUS_DMASYNC_POSTWRITE|BUS_DMASYNC_POSTREAD);
		/* Sync ring buffer */
		bus_dmamap_sync(sc->sc_dmatag, sc->sc_rec.dma->map,
				0, sc->sc_rec.length, BUS_DMASYNC_POSTREAD);
	}
	sc->sc_rec.intr = NULL;
	mtx_leave(&audio_lock);
	return 0;
}

int
yds_mixer_set_port(void *addr, mixer_ctrl_t *cp)
{
	struct yds_softc *sc = addr;

	return (sc->sc_codec[0].codec_if->vtbl->mixer_set_port(
	    sc->sc_codec[0].codec_if, cp));
}

int
yds_mixer_get_port(void *addr, mixer_ctrl_t *cp)
{
	struct yds_softc *sc = addr;

	return (sc->sc_codec[0].codec_if->vtbl->mixer_get_port(
	    sc->sc_codec[0].codec_if, cp));
}

int
yds_query_devinfo(void *addr, mixer_devinfo_t *dip)
{
	struct yds_softc *sc = addr;

	return (sc->sc_codec[0].codec_if->vtbl->query_devinfo(
	    sc->sc_codec[0].codec_if, dip));
}

int
yds_get_portnum_by_name(struct yds_softc *sc, char *class, char *device,
    char *qualifier)
{
	return (sc->sc_codec[0].codec_if->vtbl->get_portnum_by_name(
	    sc->sc_codec[0].codec_if, class, device, qualifier));
}

void *
yds_malloc(void *addr, int direction, size_t size, int pool, int flags)
{
	struct yds_softc *sc = addr;
	struct yds_dma *p;
	int error;

	p = malloc(sizeof(*p), pool, flags);
	if (!p)
		return (0);
	error = yds_allocmem(sc, size, 16, p);
	if (error) {
		free(p, pool, sizeof *p);
		return (0);
	}
	p->next = sc->sc_dmas;
	sc->sc_dmas = p;
	return (KERNADDR(p));
}

void
yds_free(void *addr, void *ptr, int pool)
{
	struct yds_softc *sc = addr;
	struct yds_dma **pp, *p;

	for (pp = &sc->sc_dmas; (p = *pp) != NULL; pp = &p->next) {
		if (KERNADDR(p) == ptr) {
			yds_freemem(sc, p);
			*pp = p->next;
			free(p, pool, sizeof *p);
			return;
		}
	}
}

static struct yds_dma *
yds_find_dma(struct yds_softc *sc, void *addr)
{
	struct yds_dma *p;

	for (p = sc->sc_dmas; p && KERNADDR(p) != addr; p = p->next)
		;

	return p;
}

size_t
yds_round_buffersize(void *addr, int direction, size_t size)
{
	/*
	 * Buffer size should be at least twice as bigger as a frame.
	 */
	if (size < 1024 * 3)
		size = 1024 * 3;
	return (size);
}

int
yds_get_props(void *addr)
{
	return (AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT | 
		AUDIO_PROP_FULLDUPLEX);
}

int
yds_activate(struct device *self, int act)
{
	struct yds_softc *sc = (struct yds_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_QUIESCE:
		if (sc->sc_play.intr || sc->sc_rec.intr)
			sc->sc_resume_active = 1;
		else
			sc->sc_resume_active = 0;
		rv = config_activate_children(self, act);
		if (sc->sc_resume_active)
			yds_close(sc);
		break;
	case DVACT_RESUME:
		yds_halt(sc);
		yds_init(sc, 1);
		ac97_resume(&sc->sc_codec[0].host_if, sc->sc_codec[0].codec_if);
		if (sc->sc_resume_active)
			yds_open(sc, 0);
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

int
yds_init(struct yds_softc *sc, int resuming)
{
	u_int32_t reg;

	pci_chipset_tag_t pc = sc->sc_pc;

	int to;

	DPRINTF(("in yds_init()\n"));

	/* Download microcode */
	if (!resuming) {
		if (yds_download_mcode(sc)) {
			printf("%s: download microcode failed\n", sc->sc_dev.dv_xname);
			return -1;
		}
	}
	/* Allocate DMA buffers */
	if (yds_allocate_slots(sc, resuming)) {
		printf("%s: could not allocate slots\n", sc->sc_dev.dv_xname);
		return -1;
	}

	/* Warm reset */
	reg = pci_conf_read(pc, sc->sc_pcitag, YDS_PCI_DSCTRL);
	pci_conf_write(pc, sc->sc_pcitag, YDS_PCI_DSCTRL, reg | YDS_DSCTRL_WRST);
	delay(50000);

	/*
	 * Detect primary/secondary AC97
	 *	YMF754 Hardware Specification Rev 1.01 page 24
	 */
	reg = pci_conf_read(pc, sc->sc_pcitag, YDS_PCI_DSCTRL);
	pci_conf_write(pc, sc->sc_pcitag, YDS_PCI_DSCTRL,
		reg & ~YDS_DSCTRL_CRST);
	delay(400000);		/* Needed for 740C. */

	/* Primary */
	for (to = 0; to < AC97_TIMEOUT; to++) {
		if ((YREAD2(sc, AC97_STAT_ADDR1) & AC97_BUSY) == 0)
			break;
		delay(1);
	}
	if (to == AC97_TIMEOUT) {
		printf("%s: no AC97 available\n", sc->sc_dev.dv_xname);
		return -1;
	}

	/* Secondary */
	/* Secondary AC97 is used for 4ch audio. Currently unused. */
	ac97_id2 = -1;
	if ((YREAD2(sc, YDS_ACTIVITY) & YDS_ACTIVITY_DOCKA) == 0)
		goto detected;
#if 0				/* reset secondary... */
	YWRITE2(sc, YDS_GPIO_OCTRL,
		YREAD2(sc, YDS_GPIO_OCTRL) & ~YDS_GPIO_GPO2);
	YWRITE2(sc, YDS_GPIO_FUNCE,
		(YREAD2(sc, YDS_GPIO_FUNCE)&(~YDS_GPIO_GPC2))|YDS_GPIO_GPE2);
#endif
	for (to = 0; to < AC97_TIMEOUT; to++) {
		if ((YREAD2(sc, AC97_STAT_ADDR2) & AC97_BUSY) == 0)
			break;
		delay(1);
	}
	if (to < AC97_TIMEOUT) {
		/* detect id */
		for (ac97_id2 = 1; ac97_id2 < 4; ac97_id2++) {
			YWRITE2(sc, AC97_CMD_ADDR,
				AC97_CMD_READ | AC97_ID(ac97_id2) | 0x28);

			for (to = 0; to < AC97_TIMEOUT; to++) {
				if ((YREAD2(sc, AC97_STAT_ADDR2) & AC97_BUSY)
				    == 0)
					goto detected;
				delay(1);
			}
		}
		if (ac97_id2 == 4)
			ac97_id2 = -1;
detected:
		;
	}

	pci_conf_write(pc, sc->sc_pcitag, YDS_PCI_DSCTRL,
		reg | YDS_DSCTRL_CRST);
	delay (20);
	pci_conf_write(pc, sc->sc_pcitag, YDS_PCI_DSCTRL,
		reg & ~YDS_DSCTRL_CRST);
	delay (400000);
	for (to = 0; to < AC97_TIMEOUT; to++) {
		if ((YREAD2(sc, AC97_STAT_ADDR1) & AC97_BUSY) == 0)
			break;
		delay(1);
	}

	DPRINTF(("out of yds_init()\n"));

	return 0;
}
@


1.53
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.51 2015/09/10 18:10:34 deraadt Exp $	*/
a163 1
int	yds_getdev(void *, struct audio_device *);
a214 1
	yds_getdev,
a226 6
struct audio_device yds_device = {
	"Yamaha DS-1",
	"",
	"yds"
};

a1474 8
	return 0;
}

int
yds_getdev(void *addr, struct audio_device *retp)
{
	*retp = yds_device;

@


1.52
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@a154 1
int	yds_query_encoding(void *, struct audio_encoding *);
a156 1
void	yds_get_default_params(void *, int, struct audio_params *);
a169 1
paddr_t	yds_mappage(void *, void *, off_t, int);
a205 2
	NULL,
	yds_query_encoding,
a223 1
	yds_mappage,
d226 1
a226 2
	yds_trigger_input,
	yds_get_default_params
a1089 31
yds_query_encoding(void *addr, struct audio_encoding *fp)
{
	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 1:
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	default:
		return (EINVAL);
	}
	fp->bps = AUDIO_BPS(fp->precision);
	fp->msb = 1;

	return (0);
}

void
yds_get_default_params(void *addr, int mode, struct audio_params *params)
{
	ac97_get_default_params(params);
}

int
a1584 15
}

paddr_t
yds_mappage(void *addr, void *mem, off_t off, int prot)
{
	struct yds_softc *sc = addr;
	struct yds_dma *p;

	if (off < 0)
		return (-1);
	p = yds_find_dma(sc, mem);
	if (!p)
		return (-1);
	return (bus_dmamem_mmap(sc->sc_dmatag, p->segs, p->nsegs, 
				off, prot, BUS_DMA_WAITOK));
@


1.51
log
@sizes for free(); ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.50 2015/05/11 06:46:22 ratchov Exp $	*/
d196 1
a196 1
void	yds_attachhook(void *);
d723 1
a723 1
	mountroothook_establish(yds_attachhook, sc);
d727 1
a727 1
yds_attachhook(void *xsc)
d729 1
a729 1
	struct yds_softc *sc = xsc;
d733 1
a733 1
	
@


1.50
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.49 2015/03/14 03:38:49 jsg Exp $	*/
d366 1
a366 1
		free(buf, M_DEVBUF, 0);
d373 1
a373 1
		free(buf, M_DEVBUF, 0);
d378 1
a378 1
		free(buf, M_DEVBUF, 0);
d408 1
a408 1
	free(buf, M_DEVBUF, 0);
d1579 1
a1579 1
		free(p, pool, 0);
d1597 1
a1597 1
			free(p, pool, 0);
@


1.49
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.48 2014/11/18 23:55:01 krw Exp $	*/
a56 2
#include <dev/mulaw.h>
#include <dev/auconv.h>
d944 1
a944 1
			dma = sc->pbankp[nbank]->pgstart * sc->sc_play.factor;
a1106 18
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 2:
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 3:
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 4:
a1111 18
	case 5:
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 6:
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
a1149 2
		p->factor = 1;
		p->sw_code = 0;
a1150 6
		case AUDIO_ENCODING_SLINEAR_BE:
			if (p->precision == 16)
				p->sw_code = swap_bytes;
			else
				p->sw_code = change_sign8;
			break;
d1153 1
a1153 1
				p->sw_code = change_sign8;
d1155 1
d1157 2
a1158 26
			if (p->precision == 16) {
				if (mode == AUMODE_PLAY)
					p->sw_code = swap_bytes_change_sign16_le;
				else
					p->sw_code = change_sign16_swap_bytes_le;
			}
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			if (p->precision == 16)
				p->sw_code = change_sign16_le;
			break;
		case AUDIO_ENCODING_ULAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->precision = 16;
				p->sw_code = mulaw_to_slinear16_le;
			} else
				p->sw_code = ulinear8_to_mulaw;
			break;
		case AUDIO_ENCODING_ALAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->precision = 16;
				p->sw_code = alaw_to_slinear16_le;
			} else
				p->sw_code = ulinear8_to_alaw;
a1299 7
	sc->sc_play.factor = 1;
	if (param->channels == 2)
		sc->sc_play.factor *= 2;
	if (param->precision != 8)
		sc->sc_play.factor *= 2;
	l /= sc->sc_play.factor;

a1404 6

	sc->sc_rec.factor = 1;
	if (param->channels == 2)
		sc->sc_rec.factor *= 2;
	if (param->precision != 8)
		sc->sc_rec.factor *= 2;
@


1.48
log
@Nuke yet more obvious #include duplications.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.47 2014/07/12 18:48:52 tedu Exp $	*/
a59 1
#include <dev/ic/mpuvar.h>
@


1.47
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.46 2014/05/17 12:19:36 ratchov Exp $	*/
a48 1
#include <sys/fcntl.h>
@


1.46
log
@unbreak build: exchange %b args order, from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.45 2013/12/06 21:03:04 deraadt Exp $	*/
d370 1
a370 1
		free(buf, M_DEVBUF);
d377 1
a377 1
		free(buf, M_DEVBUF);
d382 1
a382 1
		free(buf, M_DEVBUF);
d412 1
a412 1
	free(buf, M_DEVBUF);
d461 1
a461 1
			free(p, M_DEVBUF);
d1663 1
a1663 1
		free(p, pool);
d1681 1
a1681 1
			free(p, pool);
@


1.45
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.44 2013/10/01 20:06:02 sf Exp $	*/
d714 1
a714 1
			YDS_CAP_BITS, sc->sc_flags);
@


1.44
log
@Use %z* for size_t

while there, fix a few %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.43 2013/05/24 07:58:47 ratchov Exp $	*/
a1746 2
	case DVACT_SUSPEND:
		break;
d1753 3
@


1.43
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.42 2013/05/15 08:29:24 ratchov Exp $	*/
d1348 1
a1348 1
			panic("%s: invalid play slot ctrldata %d %d",
@


1.42
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.41 2012/03/03 20:21:39 miod Exp $	*/
d691 2
a692 2
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO, yds_intr, sc,
	    self->dv_xname);
@


1.41
log
@Don't print the device name again in attach error messages occuring before
a newline ever gets printed. Found the hard way with a device dying on me.
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.40 2012/01/11 16:22:33 dhill Exp $	*/
d911 1
d919 1
d1018 1
a1018 1

d1322 1
a1326 1

d1338 1
d1440 1
a1440 1

d1456 1
d1475 1
d1530 1
a1530 1

d1560 1
d1578 1
a1578 1

d1588 1
d1604 1
a1604 1

@


1.40
log
@ansify and de'register some prototypes

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.39 2011/04/03 15:36:03 jasper Exp $	*/
d680 1
a680 1
		printf("%s: can't map mem space\n", sc->sc_dev.dv_xname);
d686 1
a686 1
		printf("%s: couldn't map interrupt\n", sc->sc_dev.dv_xname);
d694 1
a694 2
		printf("%s: couldn't establish interrupt",
		    sc->sc_dev.dv_xname);
@


1.39
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.38 2010/09/17 07:55:52 jakemsr Exp $	*/
d278 1
a278 3
yds_dump_play_slot(sc, bank)
	struct yds_softc *sc;
	int bank;
d326 1
a326 2
yds_get_dstype(id)
	int id;
d348 1
a348 2
yds_download_mcode(sc)
	struct yds_softc *sc;
d516 1
a516 2
yds_enable_dsp(sc)
	struct yds_softc *sc;
d522 1
a522 2
yds_disable_dsp(sc)
	struct yds_softc *sc;
d541 1
a541 4
yds_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d568 1
a568 2
yds_configure_legacy (sc)
	struct yds_softc *sc;
d666 1
a666 4
yds_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d817 1
a817 3
yds_attach_codec(sc_, codec_if)
	void *sc_;
	struct ac97_codec_if *codec_if;
d826 1
a826 2
yds_ready_codec(sc)
	struct yds_codec_softc *sc;
d840 1
a840 4
yds_read_codec(sc_, reg, data)
	void *sc_;
	u_int8_t reg;
	u_int16_t *data;
d865 1
a865 4
yds_write_codec(sc_, reg, data)
	void *sc_;
	u_int8_t reg;
	u_int16_t data;
d885 1
a885 2
yds_reset_codec(sc_)
	void *sc_;
d907 1
a907 2
yds_intr(p)
	void *p;
d1022 1
a1022 5
yds_allocmem(sc, size, align, p)
	struct yds_softc *sc;
	size_t size;
	size_t align;
	struct yds_dma *p;
d1059 1
a1059 3
yds_freemem(sc, p)
	struct yds_softc *sc;
	struct yds_dma *p;
d1069 1
a1069 3
yds_open(addr, flags)
	void *addr;
	int flags;
d1090 1
a1090 2
yds_close(addr)
	void *addr;
d1100 1
a1100 3
yds_query_encoding(addr, fp)
	void *addr;
	struct audio_encoding *fp;
d1167 2
a1168 4
yds_set_params(addr, setmode, usemode, play, rec)
	void *addr;
	int setmode, usemode;
	struct audio_params *play, *rec;
d1241 1
a1241 3
yds_round_blocksize(addr, blk)
	void *addr;
	int blk;
d1254 1
a1254 2
yds_get_lpfq(sample_rate)
	u_int sample_rate;
d1281 1
a1281 2
yds_get_lpfk(sample_rate)
	u_int sample_rate;
d1308 2
a1309 7
yds_trigger_output(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
d1444 2
a1445 7
yds_trigger_input(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
d1531 1
a1531 2
yds_halt(sc)
	struct yds_softc *sc;
d1551 1
a1551 2
yds_halt_output(addr)
	void *addr;
d1578 1
a1578 2
yds_halt_input(addr)
	void *addr;
d1603 1
a1603 3
yds_getdev(addr, retp)
	void *addr;
	struct audio_device *retp;
d1611 1
a1611 3
yds_mixer_set_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d1620 1
a1620 3
yds_mixer_get_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d1629 1
a1629 3
yds_query_devinfo(addr, dip)
	void *addr;
	mixer_devinfo_t *dip;
d1638 2
a1639 3
yds_get_portnum_by_name(sc, class, device, qualifier)
	struct yds_softc *sc;
	char *class, *device, *qualifier;
d1646 1
a1646 5
yds_malloc(addr, direction, size, pool, flags)
	void *addr;
	int direction;
	size_t size;
	int pool, flags;
d1666 1
a1666 4
yds_free(addr, ptr, pool)
	void *addr;
	void *ptr;
	int pool;
d1682 1
a1682 3
yds_find_dma(sc, addr)
	struct yds_softc *sc;
	void *addr;
d1693 1
a1693 4
yds_round_buffersize(addr, direction, size)
	void *addr;
	int direction;
	size_t size;
d1704 1
a1704 5
yds_mappage(addr, mem, off, prot)
	void *addr;
	void *mem;
	off_t off;
	int prot;
d1719 1
a1719 2
yds_get_props(addr)
	void *addr;
@


1.38
log
@use audio(4) DVACT_{QUIESCE,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.37 2010/09/07 16:21:46 deraadt Exp $	*/
d1056 1
a1056 1
				 p->segs, sizeof(p->segs)/sizeof(p->segs[0]),
@


1.37
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.36 2010/09/06 19:20:23 deraadt Exp $	*/
d189 1
a189 1
static int yds_allocate_slots(struct yds_softc *);
d199 1
a199 1
int	yds_init(void *sc);
d421 1
a421 2
yds_allocate_slots(sc)
	struct yds_softc *sc;
d460 8
a467 6
	i = yds_allocmem(sc, memsize, 16, p);
	if (i) {
		printf("%s: couldn't alloc/map DSP DMA buffer, reason %d\n",
		       sc->sc_dev.dv_xname, i);
		free(p, M_DEVBUF);
		return 1;
d753 1
a753 1
	if (yds_init(sc) == -1)
d1809 1
d1812 9
d1824 6
a1829 2
		yds_init(sc);
		(sc->sc_codec[0].codec_if->vtbl->restore_ports)(sc->sc_codec[0].codec_if);
d1832 1
a1832 1
	return 0;
d1836 1
a1836 2
yds_init(sc_)
	void *sc_;
a1837 1
	struct yds_softc *sc = sc_;
d1847 5
a1851 3
	if (yds_download_mcode(sc)) {
		printf("%s: download microcode failed\n", sc->sc_dev.dv_xname);
		return -1;
d1854 1
a1854 1
	if (yds_allocate_slots(sc)) {
@


1.36
log
@All PWR_{SUSPEND,RESUME} can now be replaced by DVACT_{SUSPEND,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.35 2010/08/27 18:50:57 deraadt Exp $	*/
a198 1
void yds_powerhook(int, void *);
a824 2
	sc->powerhook = powerhook_establish(yds_powerhook, sc);

a1817 6
}

void
yds_powerhook(int why, void *self)
{
	yds_activate(self, why);
@


1.35
log
@Since the changes in neo(4) work, it is very likely that the exact same
mechnical changes work in these drivers too.  Testing can occur after
this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.34 2010/07/15 03:43:11 jakemsr Exp $	*/
d825 1
a825 1
	sc->suspend = PWR_RESUME;
@


1.34
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.33 2010/04/06 22:28:07 tedu Exp $	*/
d91 1
d149 2
a150 1
	sizeof(struct yds_softc), yds_match, yds_attach
d1807 2
a1808 4
void
yds_powerhook(why, self)
	int why;
	void *self;
d1812 4
a1815 15
	if (why != PWR_RESUME) {
		/* Power down */
		DPRINTF(("yds: power down\n"));
		sc->suspend = why;

	} else {
		/* Wake up */
		DPRINTF(("yds: power resume\n"));
		if (sc->suspend == PWR_RESUME) {
			printf("%s: resume without suspend?\n",
				sc->sc_dev.dv_xname);
			sc->suspend = why;
			return;
		}
		sc->suspend = why;
d1818 1
d1820 7
@


1.33
log
@update a random sampling of drivers after the proc.h -> systm.h move
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.32 2009/03/29 21:53:53 sthen Exp $	*/
d1143 1
a1143 1
		return (0);
d1149 1
a1149 1
		return (0);
d1155 1
a1155 1
		return (0);
d1161 1
a1161 1
		return (0);
d1167 1
a1167 1
		return (0);
d1173 1
a1173 1
		return (0);
d1179 1
a1179 1
		return (0);
d1185 1
a1185 1
		return (0);
d1189 4
d1270 2
@


1.32
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.31 2008/10/25 22:30:43 jakemsr Exp $	*/
a47 1
#include <sys/proc.h>
@


1.31
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.30 2008/05/29 02:10:01 jakemsr Exp $	*/
d692 1
a692 1
		printf("%s: can't map memory space\n", sc->sc_dev.dv_xname);
@


1.30
log
@use ac97 default parameters for these ac97 based drivers.

this makes the emulation expansion factor 1 by default since there's no
emulation.  previously the factor was 2 because these drivers emulate
8-bit ulaw playback with 16-bit linear encodings.  having a factor
other than 1 by default creates block size and hiwat/lowat issues
with applications that set the block size and hiwat before other
parameters.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.29 2008/04/21 00:32:43 jakemsr Exp $	*/
d1214 8
a1221 4
		if (p->sample_rate < 4000 || p->sample_rate > 48000 ||
		    (p->precision != 8 && p->precision != 16) ||
		    (p->channels != 1 && p->channels != 2))
			return (EINVAL);
@


1.29
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.28 2007/01/06 02:48:40 deraadt Exp $	*/
d161 1
d237 1
a237 1
	NULL
d1190 6
@


1.28
log
@make microcode file byte-order independent so that the file is the same
on all architectures, and have the driver cope with this as well
tested by ian
YOU MUST UPDATE YOUR MICROCODE FILE OR THE DRIVER WILL NOT BE HAPPY
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.27 2005/08/09 04:10:13 mickey Exp $	*/
d235 2
a236 1
	yds_trigger_input
@


1.27
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.26 2005/05/27 00:49:56 jason Exp $	*/
d94 2
d339 9
d366 2
a367 2
		p = (u_int32_t *)&yf->data[yf->dsplen];
		size = yf->ds1len;
d369 2
a370 2
		p = (u_int32_t *)&yf->data[yf->dsplen + yf->ds1len];
		size = yf->ds1elen;
d376 7
d403 3
a405 1
	YWRITEREGION4(sc, YDS_DSP_INSTRAM, (u_int32_t *)&yf->data[0], yf->dsplen);
d408 1
@


1.26
log
@nuke vtophys crap
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.25 2004/12/30 20:45:12 miod Exp $	*/
a710 8

	/* Enable the device. */
	reg = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	reg |= (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
		PCI_COMMAND_MASTER_ENABLE);

	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, reg);
	reg = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
@


1.25
log
@Let yds_init() return a meaningful value.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.24 2004/12/20 12:29:36 deraadt Exp $	*/
a69 5
#ifdef AUDIO_DEBUG
#include <uvm/uvm_extern.h>    /* for vtophys */
#include <uvm/uvm_pmap.h>      /* for vtophys */
#endif

a302 2
		printf("  pbankp[%d] : %p(%p)\n",
		       i, p, (void *)vtophys((vaddr_t)p));
@


1.24
log
@firmware loading from the filesystem.  pci subsystem type things
are still done early, but audio subsystem setup is deferred till
after root is mounted.  tested by mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.23 2004/05/24 22:52:52 mickey Exp $	*/
d1907 1
a1907 1
	return ac97_id2;
@


1.23
log
@do not bother w/ void pci_devinfo() calls and free resources on failures
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.22 2004/02/19 20:11:33 markus Exp $	*/
a66 2
#include <dev/microcode/yds/yds_hwmcode.h>

d191 1
a191 1
static void yds_configure_legacy(struct device *arg);
d202 1
d351 9
a359 1
	int dstype;
d361 8
a368 13
	static struct {
		const u_int32_t *mcode;
		size_t size;
	} ctrls[] = {
		{yds_ds1_ctrl_mcode, sizeof(yds_ds1_ctrl_mcode)},
		{yds_ds1e_ctrl_mcode, sizeof(yds_ds1e_ctrl_mcode)},
	};

	if (sc->sc_flags & YDS_CAP_MCODE_1)
		dstype = YDS_DS_1;
	else if (sc->sc_flags & YDS_CAP_MCODE_1E)
		dstype = YDS_DS_1E;
	else
d370 1
d372 2
a373 1
	if (yds_disable_dsp(sc))
d375 1
d389 1
a389 2
        YWRITE2(sc, YDS_GLOBAL_CONTROL,
		ctrl & ~0x0007);
d392 1
a392 3
	p = yds_dsp_mcode;
	size = sizeof(yds_dsp_mcode);
	YWRITEREGION4(sc, YDS_DSP_INSTRAM, p, size);
a394 2
	p = ctrls[dstype].mcode;
	size = ctrls[dstype].size;
d398 1
a398 1
	delay(10*1000);		/* nessesary on my 724F (??) */
d400 1
d560 2
a561 2
yds_configure_legacy (arg)
	struct device *arg;
a564 1
	struct yds_softc *sc = (struct yds_softc*) arg;
d671 1
a671 3
	struct yds_codec_softc *codec;
	mixer_ctrl_t ctl;
	int i, r;
d731 12
d744 2
a745 1
	yds_init(sc);
a814 3
	sc->sc_legacy_iot = pa->pa_iot;
	config_defer((struct device*) sc, yds_configure_legacy);

d818 2
@


1.22
log
@fix typo, KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.21 2004/02/19 11:08:11 markus Exp $	*/
d669 1
a671 1
	char devinfo[256];
a674 2
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo, sizeof devinfo);

d677 1
a677 1
	    &sc->memt, &sc->memh, NULL, NULL, 0)) {
d685 1
d697 1
@


1.21
log
@don't disable the Sound Blaster legacy mode by default, as this breaks
apm(4).  add a flag that disables Sound Blaster legacy mode, this might
be necessary for some floppies. help from jmc, ok+test hshoexer.
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.20 2003/09/29 09:08:20 miod Exp $	*/
d576 2
a577 3
	reg |= ((YDS_PCI_EX_LEGACY_IMOD) |
		(YDS_PCI_LEGACY_FMEN |
		 YDS_PCI_LEGACY_MEN /*| YDS_PCI_LEGACY_MIEN*/));
d708 1
a708 1
	if (sc->sc_dev.dv_cfdata->cf_flags & YDS_CAP_LEGACY_SMOD_DISABLE);
@


1.20
log
@avaliable -> available
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.19 2003/05/14 09:04:59 jason Exp $	*/
d256 1
d576 1
a576 1
	reg |= YDS_PCI_EX_LEGACY_SBMOD_XXX | ((YDS_PCI_EX_LEGACY_IMOD) |
d579 2
d709 2
@


1.19
log
@Nuke more commons: ac97_id2, tinfo_t
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.18 2003/04/27 11:22:54 ho Exp $	*/
d1840 1
a1840 1
		printf("%s: no AC97 avaliable\n", sc->sc_dev.dv_xname);
@


1.18
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.17 2003/02/25 20:14:34 tedu Exp $	*/
d94 2
@


1.17
log
@move NULLification to end so it's useful.

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.16 2003/02/20 00:26:17 jason Exp $	*/
d671 1
a671 1
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
d1116 1
a1116 1
		strcpy(fp->name, AudioEulinear);
d1122 1
a1122 1
		strcpy(fp->name, AudioEmulaw);
d1128 1
a1128 1
		strcpy(fp->name, AudioEalaw);
d1134 1
a1134 1
		strcpy(fp->name, AudioEslinear);
d1140 1
a1140 1
		strcpy(fp->name, AudioEslinear_le);
d1146 1
a1146 1
		strcpy(fp->name, AudioEulinear_le);
d1152 1
a1152 1
		strcpy(fp->name, AudioEslinear_be);
d1158 1
a1158 1
		strcpy(fp->name, AudioEulinear_be);
@


1.16
log
@In typical linux style, set a magic bit that makes the floppy work on
a machine with yds; reported by kurem at upcase dot inf dot upol dot cz
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.15 2002/03/14 03:16:06 millert Exp $	*/
a1597 1
	sc->sc_rec.intr = NULL;
d1612 1
@


1.15
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.14 2002/03/14 01:27:00 millert Exp $	*/
d573 1
a573 1
	reg |= ((YDS_PCI_EX_LEGACY_IMOD) |
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.13 2002/01/20 19:56:53 ericj Exp $	*/
d165 4
a168 4
int	yds_trigger_output __P((void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *));
int	yds_trigger_input __P((void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *));
d304 1
a304 1
		dma = yds_find_dma(sc,(void*)p);
d307 1
a307 1
		       i, p, (void*)vtophys((vaddr_t)p));
d452 1
a452 1
		 mp, (void*) sc->sc_ctrldata.map->dm_segs[0].ds_addr));
@


1.13
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.12 2002/01/06 23:01:40 ericj Exp $	*/
d95 3
a97 3
int	yds_match __P((struct device *, void *, void *));
void	yds_attach __P((struct device *, struct device *, void *));
int	yds_intr __P((void *));
d102 3
a104 3
int	yds_allocmem __P((struct yds_softc *, size_t, size_t,
	    struct yds_dma *));
int	yds_freemem __P((struct yds_softc *, struct yds_dma *));
d159 6
a164 6
int	yds_open __P((void *, int));
void	yds_close __P((void *));
int	yds_query_encoding __P((void *, struct audio_encoding *));
int	yds_set_params __P((void *, int, int,
	    struct audio_params *, struct audio_params *));
int	yds_round_blocksize __P((void *, int));
d169 30
a198 30
int	yds_halt_output __P((void *));
int	yds_halt_input __P((void *));
int	yds_getdev __P((void *, struct audio_device *));
int	yds_mixer_set_port __P((void *, mixer_ctrl_t *));
int	yds_mixer_get_port __P((void *, mixer_ctrl_t *));
void   *yds_malloc __P((void *, int, size_t, int, int));
void	yds_free __P((void *, void *, int));
size_t	yds_round_buffersize __P((void *, int, size_t));
paddr_t	yds_mappage __P((void *, void *, off_t, int));
int	yds_get_props __P((void *));
int	yds_query_devinfo __P((void *addr, mixer_devinfo_t *dip));

int     yds_attach_codec __P((void *sc, struct ac97_codec_if *));
int	yds_read_codec __P((void *sc, u_int8_t a, u_int16_t *d));
int	yds_write_codec __P((void *sc, u_int8_t a, u_int16_t d));
void    yds_reset_codec __P((void *sc));
int     yds_get_portnum_by_name __P((struct yds_softc *, char *, char *,
	    char *));

static u_int yds_get_dstype __P((int));
static int yds_download_mcode __P((struct yds_softc *));
static int yds_allocate_slots __P((struct yds_softc *));
static void yds_configure_legacy __P((struct device *arg));
static void yds_enable_dsp __P((struct yds_softc *));
static int yds_disable_dsp __P((struct yds_softc *));
static int yds_ready_codec __P((struct yds_codec_softc *));
static int yds_halt __P((struct yds_softc *));
static u_int32_t yds_get_lpfq __P((u_int));
static u_int32_t yds_get_lpfk __P((u_int));
static struct yds_dma *yds_find_dma __P((struct yds_softc *, void *));
d200 2
a201 2
void yds_powerhook __P((int, void *));
int	yds_init __P((void *sc));
d204 1
a204 1
static void yds_dump_play_slot __P((struct yds_softc *, int));
d1314 1
a1314 1
	void (*intr) __P((void *));
d1455 1
a1455 1
	void (*intr) __P((void *));
@


1.12
log
@
remove bogus diagnostic check.
pr#2298
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.11 2002/01/04 20:42:18 ericj Exp $	*/
d174 1
a174 1
void   *yds_malloc __P((void *, u_long, int, int));
d176 1
a176 1
u_long	yds_round_buffersize __P((void *, u_long));
d1670 1
a1670 1
yds_malloc(addr, size, pool, flags)
d1672 2
a1673 1
	u_long size;
d1725 2
a1726 2
u_long
yds_round_buffersize(addr, size)
d1728 2
a1729 1
	u_long size;
@


1.11
log
@
add 600x read for 744 rev < 2 - from netbsd
cleanup dmesg output
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.10 2001/12/20 04:50:06 jcs Exp $	*/
a1486 10

#ifdef DIAGNOSTIC
	{
		u_int32_t ctrlsize;
		if ((ctrlsize = YREAD4(sc, YDS_REC_CTRLSIZE)) !=
		    sizeof(struct rec_slot) / sizeof(u_int32_t))
			panic("%s: invalid rec slot ctrldata %d",
				sc->sc_dev.dv_xname, ctrlsize);
	}
#endif
@


1.10
log
@add powerhook support to handle APM resumes correctly, fixes PR 1814
ok provos@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.9 2001/12/07 17:08:35 deraadt Exp $	*/
a669 1
	int revision;
a671 2
	revision = PCI_REVISION(pa->pa_class);
	printf(": %s (rev. 0x%02x)\n", devinfo, revision);
d702 1
d848 7
d916 1
a916 1
#if NMPU > 0
@


1.9
log
@bitmask_snprintf goes away
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.8 2001/11/05 17:25:58 art Exp $	*/
d200 3
d669 1
a669 1
	int i, r, to;
a670 1
	int ac97_id2;
d721 1
d729 2
a730 82
	/* Download microcode */
	if (yds_download_mcode(sc)) {
		printf("%s: download microcode failed\n", sc->sc_dev.dv_xname);
		return;
	}
	/* Allocate DMA buffers */
	if (yds_allocate_slots(sc)) {
		printf("%s: could not allocate slots\n", sc->sc_dev.dv_xname);
		return;
	}

	/* Warm reset */
	reg = pci_conf_read(pc, pa->pa_tag, YDS_PCI_DSCTRL);
	pci_conf_write(pc, pa->pa_tag, YDS_PCI_DSCTRL, reg | YDS_DSCTRL_WRST);
	delay(50000);

	/*
	 * Detect primary/secondary AC97
	 *	YMF754 Hardware Specification Rev 1.01 page 24
	 */
	reg = pci_conf_read(pc, pa->pa_tag, YDS_PCI_DSCTRL);
	pci_conf_write(pc, pa->pa_tag, YDS_PCI_DSCTRL,
		reg & ~YDS_DSCTRL_CRST);
	delay(400000);		/* Needed for 740C. */

	/* Primary */
	for (to = 0; to < AC97_TIMEOUT; to++) {
		if ((YREAD2(sc, AC97_STAT_ADDR1) & AC97_BUSY) == 0)
			break;
		delay(1);
	}
	if (to == AC97_TIMEOUT) {
		printf("%s: no AC97 avaliable\n", sc->sc_dev.dv_xname);
		return;
	}

	/* Secondary */
	/* Secondary AC97 is used for 4ch audio. Currently unused. */
	ac97_id2 = -1;
	if ((YREAD2(sc, YDS_ACTIVITY) & YDS_ACTIVITY_DOCKA) == 0)
		goto detected;
#if 0				/* reset secondary... */
	YWRITE2(sc, YDS_GPIO_OCTRL,
		YREAD2(sc, YDS_GPIO_OCTRL) & ~YDS_GPIO_GPO2);
	YWRITE2(sc, YDS_GPIO_FUNCE,
		(YREAD2(sc, YDS_GPIO_FUNCE)&(~YDS_GPIO_GPC2))|YDS_GPIO_GPE2);
#endif
	for (to = 0; to < AC97_TIMEOUT; to++) {
		if ((YREAD2(sc, AC97_STAT_ADDR2) & AC97_BUSY) == 0)
			break;
		delay(1);
	}
	if (to < AC97_TIMEOUT) {
		/* detect id */
		for (ac97_id2 = 1; ac97_id2 < 4; ac97_id2++) {
			YWRITE2(sc, AC97_CMD_ADDR,
				AC97_CMD_READ | AC97_ID(ac97_id2) | 0x28);

			for (to = 0; to < AC97_TIMEOUT; to++) {
				if ((YREAD2(sc, AC97_STAT_ADDR2) & AC97_BUSY)
				    == 0)
					goto detected;
				delay(1);
			}
		}
		if (ac97_id2 == 4)
			ac97_id2 = -1;
detected:
		;
	}

	pci_conf_write(pc, pa->pa_tag, YDS_PCI_DSCTRL,
		       reg | YDS_DSCTRL_CRST);
	delay (20);
	pci_conf_write(pc, pa->pa_tag, YDS_PCI_DSCTRL,
		reg & ~YDS_DSCTRL_CRST);
	delay (400000);
	for (to = 0; to < AC97_TIMEOUT; to++) {
		if ((YREAD2(sc, AC97_STAT_ADDR1) & AC97_BUSY) == 0)
			break;
		delay(1);
	}
d802 4
d1767 128
@


1.9.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.13 2002/01/20 19:56:53 ericj Exp $	*/
d174 1
a174 1
void   *yds_malloc __P((void *, int, size_t, int, int));
d176 1
a176 1
size_t	yds_round_buffersize __P((void *, int, size_t));
a199 3
void yds_powerhook __P((int, void *));
int	yds_init __P((void *sc));

d666 3
a668 1
	int i, r;
d671 2
a702 1
	sc->sc_revision = PCI_REVISION(pa->pa_class);
a718 1

d726 82
a807 2
	/* Initialize the device */
	yds_init(sc);
a878 4

	/* Watch for power changes */
	sc->suspend = PWR_RESUME;
	sc->powerhook = powerhook_establish(yds_powerhook, sc);
a922 7
	if (PCI_PRODUCT(sc->sc->sc_id) == PCI_PRODUCT_YAMAHA_YMF744 &&
	    sc->sc->sc_revision < 2) {
		int i;

		for (i = 0; i < 600; i++)
			YREAD2(sc->sc, sc->status_data);
	}
d984 1
a984 1
#if 0
d1556 10
d1748 1
a1748 1
yds_malloc(addr, direction, size, pool, flags)
d1750 1
a1750 2
	int direction;
	size_t size;
d1802 2
a1803 2
size_t
yds_round_buffersize(addr, direction, size)
d1805 1
a1805 2
	int direction;
	size_t size;
a1839 128
}

void
yds_powerhook(why, self)
	int why;
	void *self;
{
	struct yds_softc *sc = (struct yds_softc *)self;

	if (why != PWR_RESUME) {
		/* Power down */
		DPRINTF(("yds: power down\n"));
		sc->suspend = why;

	} else {
		/* Wake up */
		DPRINTF(("yds: power resume\n"));
		if (sc->suspend == PWR_RESUME) {
			printf("%s: resume without suspend?\n",
				sc->sc_dev.dv_xname);
			sc->suspend = why;
			return;
		}
		sc->suspend = why;
		yds_init(sc);
		(sc->sc_codec[0].codec_if->vtbl->restore_ports)(sc->sc_codec[0].codec_if);
	}
}

int
yds_init(sc_)
	void *sc_;
{
	struct yds_softc *sc = sc_;
	u_int32_t reg;

	pci_chipset_tag_t pc = sc->sc_pc;

	int to;

	DPRINTF(("in yds_init()\n"));

	/* Download microcode */
	if (yds_download_mcode(sc)) {
		printf("%s: download microcode failed\n", sc->sc_dev.dv_xname);
		return -1;
	}
	/* Allocate DMA buffers */
	if (yds_allocate_slots(sc)) {
		printf("%s: could not allocate slots\n", sc->sc_dev.dv_xname);
		return -1;
	}

	/* Warm reset */
	reg = pci_conf_read(pc, sc->sc_pcitag, YDS_PCI_DSCTRL);
	pci_conf_write(pc, sc->sc_pcitag, YDS_PCI_DSCTRL, reg | YDS_DSCTRL_WRST);
	delay(50000);

	/*
	 * Detect primary/secondary AC97
	 *	YMF754 Hardware Specification Rev 1.01 page 24
	 */
	reg = pci_conf_read(pc, sc->sc_pcitag, YDS_PCI_DSCTRL);
	pci_conf_write(pc, sc->sc_pcitag, YDS_PCI_DSCTRL,
		reg & ~YDS_DSCTRL_CRST);
	delay(400000);		/* Needed for 740C. */

	/* Primary */
	for (to = 0; to < AC97_TIMEOUT; to++) {
		if ((YREAD2(sc, AC97_STAT_ADDR1) & AC97_BUSY) == 0)
			break;
		delay(1);
	}
	if (to == AC97_TIMEOUT) {
		printf("%s: no AC97 avaliable\n", sc->sc_dev.dv_xname);
		return -1;
	}

	/* Secondary */
	/* Secondary AC97 is used for 4ch audio. Currently unused. */
	ac97_id2 = -1;
	if ((YREAD2(sc, YDS_ACTIVITY) & YDS_ACTIVITY_DOCKA) == 0)
		goto detected;
#if 0				/* reset secondary... */
	YWRITE2(sc, YDS_GPIO_OCTRL,
		YREAD2(sc, YDS_GPIO_OCTRL) & ~YDS_GPIO_GPO2);
	YWRITE2(sc, YDS_GPIO_FUNCE,
		(YREAD2(sc, YDS_GPIO_FUNCE)&(~YDS_GPIO_GPC2))|YDS_GPIO_GPE2);
#endif
	for (to = 0; to < AC97_TIMEOUT; to++) {
		if ((YREAD2(sc, AC97_STAT_ADDR2) & AC97_BUSY) == 0)
			break;
		delay(1);
	}
	if (to < AC97_TIMEOUT) {
		/* detect id */
		for (ac97_id2 = 1; ac97_id2 < 4; ac97_id2++) {
			YWRITE2(sc, AC97_CMD_ADDR,
				AC97_CMD_READ | AC97_ID(ac97_id2) | 0x28);

			for (to = 0; to < AC97_TIMEOUT; to++) {
				if ((YREAD2(sc, AC97_STAT_ADDR2) & AC97_BUSY)
				    == 0)
					goto detected;
				delay(1);
			}
		}
		if (ac97_id2 == 4)
			ac97_id2 = -1;
detected:
		;
	}

	pci_conf_write(pc, sc->sc_pcitag, YDS_PCI_DSCTRL,
		reg | YDS_DSCTRL_CRST);
	delay (20);
	pci_conf_write(pc, sc->sc_pcitag, YDS_PCI_DSCTRL,
		reg & ~YDS_DSCTRL_CRST);
	delay (400000);
	for (to = 0; to < AC97_TIMEOUT; to++) {
		if ((YREAD2(sc, AC97_STAT_ADDR1) & AC97_BUSY) == 0)
			break;
		delay(1);
	}

	DPRINTF(("out of yds_init()\n"));

	return ac97_id2;
@


1.9.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.9.2.1 2002/01/31 22:55:36 niklas Exp $	*/
d95 3
a97 3
int	yds_match(struct device *, void *, void *);
void	yds_attach(struct device *, struct device *, void *);
int	yds_intr(void *);
d102 3
a104 3
int	yds_allocmem(struct yds_softc *, size_t, size_t,
	    struct yds_dma *);
int	yds_freemem(struct yds_softc *, struct yds_dma *);
d159 40
a198 40
int	yds_open(void *, int);
void	yds_close(void *);
int	yds_query_encoding(void *, struct audio_encoding *);
int	yds_set_params(void *, int, int,
	    struct audio_params *, struct audio_params *);
int	yds_round_blocksize(void *, int);
int	yds_trigger_output(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	yds_trigger_input(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	yds_halt_output(void *);
int	yds_halt_input(void *);
int	yds_getdev(void *, struct audio_device *);
int	yds_mixer_set_port(void *, mixer_ctrl_t *);
int	yds_mixer_get_port(void *, mixer_ctrl_t *);
void   *yds_malloc(void *, int, size_t, int, int);
void	yds_free(void *, void *, int);
size_t	yds_round_buffersize(void *, int, size_t);
paddr_t	yds_mappage(void *, void *, off_t, int);
int	yds_get_props(void *);
int	yds_query_devinfo(void *addr, mixer_devinfo_t *dip);

int     yds_attach_codec(void *sc, struct ac97_codec_if *);
int	yds_read_codec(void *sc, u_int8_t a, u_int16_t *d);
int	yds_write_codec(void *sc, u_int8_t a, u_int16_t d);
void    yds_reset_codec(void *sc);
int     yds_get_portnum_by_name(struct yds_softc *, char *, char *,
	    char *);

static u_int yds_get_dstype(int);
static int yds_download_mcode(struct yds_softc *);
static int yds_allocate_slots(struct yds_softc *);
static void yds_configure_legacy(struct device *arg);
static void yds_enable_dsp(struct yds_softc *);
static int yds_disable_dsp(struct yds_softc *);
static int yds_ready_codec(struct yds_codec_softc *);
static int yds_halt(struct yds_softc *);
static u_int32_t yds_get_lpfq(u_int);
static u_int32_t yds_get_lpfk(u_int);
static struct yds_dma *yds_find_dma(struct yds_softc *, void *);
d200 2
a201 2
void yds_powerhook(int, void *);
int	yds_init(void *sc);
d204 1
a204 1
static void yds_dump_play_slot(struct yds_softc *, int);
d304 1
a304 1
		dma = yds_find_dma(sc,(void *)p);
d307 1
a307 1
		       i, p, (void *)vtophys((vaddr_t)p));
d452 1
a452 1
		 mp, (void *) sc->sc_ctrldata.map->dm_segs[0].ds_addr));
d1314 1
a1314 1
	void (*intr)(void *);
d1455 1
a1455 1
	void (*intr)(void *);
@


1.9.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a94 2
static	int ac97_id2;

d573 1
a573 1
	reg |= YDS_PCI_EX_LEGACY_SBMOD_XXX | ((YDS_PCI_EX_LEGACY_IMOD) |
d671 1
a671 1
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo, sizeof devinfo);
d1116 1
a1116 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d1122 1
a1122 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d1128 1
a1128 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d1134 1
a1134 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d1140 1
a1140 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d1146 1
a1146 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d1152 1
a1152 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d1158 1
a1158 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d1598 1
a1612 1
	sc->sc_rec.intr = NULL;
@


1.8
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.7 2001/10/31 11:00:24 art Exp $	*/
d72 5
d705 3
a707 7
	if (ydsdebug) {
		char bits[80];

		printf("%s: chip has %s\n", sc->sc_dev.dv_xname,
		       bitmask_snprintf(sc->sc_flags, YDS_CAP_BITS, bits,
					sizeof(bits)));
	}
@


1.7
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.6 2001/08/26 03:32:22 jason Exp $	*/
d45 1
a93 8
#ifdef __HAS_NEW_BUS_DMAMAP_SYNC
#define yds_bus_dmamap_sync(t, m, o, l, f) \
    bus_dmamap_sync((t), (m), (o), (l), (f))
#else
#define yds_bus_dmamap_sync(t, m, o, l, f) \
    bus_dmamap_sync((t), (m), (f))
#endif

d97 2
a98 1
int	yds_allocmem __P((struct yds_softc *, size_t, size_t, struct yds_dma *));
d146 4
a153 4
struct cfattach yds_ca = {
	sizeof(struct yds_softc), yds_match, yds_attach
};

d157 2
a158 1
int	yds_set_params __P((void *, int, int, struct audio_params *, struct audio_params *));
d181 1
a181 1
				 char *));
d229 1
a229 1
	yds_trigger_input,
d483 3
a485 3
	yds_bus_dmamap_sync(sc->sc_dmatag, p->map, sc->ptbloff,
	    (N_PLAY_SLOT_CTRL+1) * sizeof(u_int32_t),
	    BUS_DMASYNC_PREWRITE);
d659 1
d662 1
d665 4
d1008 7
a1014 5
			yds_bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
			    sc->pbankoff,
			    sizeof(struct play_slot_ctrl_bank) * (*sc->ptbl)*
			    N_PLAY_SLOT_CTRL_BANK,
			    BUS_DMASYNC_POSTWRITE|BUS_DMASYNC_POSTREAD);
d1023 5
a1027 5
				/* Sync ring buffer first for previous write */
				yds_bus_dmamap_sync(sc->sc_dmatag,
				    sc->sc_play.dma->map,
				    cpu, blk,
				    BUS_DMASYNC_POSTWRITE);
d1038 4
a1041 3
				yds_bus_dmamap_sync(sc->sc_dmatag,
				    sc->sc_play.dma->map, cpu, blk,
				    BUS_DMASYNC_PREWRITE);
d1048 7
a1054 4
			yds_bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
			    sc->rbankoff, sizeof(struct rec_slot_ctrl_bank)*
			    N_REC_SLOT_CTRL * N_REC_SLOT_CTRL_BANK,
			    BUS_DMASYNC_POSTWRITE|BUS_DMASYNC_POSTREAD);
d1064 4
a1067 3
				yds_bus_dmamap_sync(sc->sc_dmatag,
				    sc->sc_rec.dma->map, cpu, blk,
				    BUS_DMASYNC_POSTREAD);
d1078 4
a1081 3
				yds_bus_dmamap_sync(sc->sc_dmatag,
				    sc->sc_rec.dma->map, cpu, blk,
				    BUS_DMASYNC_PREREAD);
d1501 5
a1505 3
	yds_bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
	    sc->ptbloff, sizeof(struct play_slot_ctrl_bank) * channels *
	    N_PLAY_SLOT_CTRL_BANK, BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
d1507 2
a1508 2
	yds_bus_dmamap_sync(sc->sc_dmatag, p->map, 0, blksize,
	    BUS_DMASYNC_PREWRITE);
d1603 6
a1608 3
	yds_bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map, sc->rbankoff,
	    sizeof(struct rec_slot_ctrl_bank) * N_REC_SLOT_CTRL *
	    N_REC_SLOT_CTRL_BANK, BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
d1610 2
a1611 1
	yds_bus_dmamap_sync(sc->sc_dmatag, p->map, 0, blksize, BUS_DMASYNC_PREREAD);
d1650 5
a1654 4
		yds_bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
		    sc->pbankoff, sizeof(struct play_slot_ctrl_bank) *
		    (*sc->ptbl)*N_PLAY_SLOT_CTRL_BANK,
		    BUS_DMASYNC_POSTWRITE|BUS_DMASYNC_POSTREAD);
d1661 2
a1662 2
		yds_bus_dmamap_sync(sc->sc_dmatag, sc->sc_play.dma->map, 0,
		    sc->sc_play.length, BUS_DMASYNC_POSTWRITE);
d1681 5
a1685 4
		yds_bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
		    sc->rbankoff, sizeof(struct rec_slot_ctrl_bank)*
		    N_REC_SLOT_CTRL*N_REC_SLOT_CTRL_BANK,
		    BUS_DMASYNC_POSTWRITE|BUS_DMASYNC_POSTREAD);
d1687 2
a1688 2
		yds_bus_dmamap_sync(sc->sc_dmatag, sc->sc_rec.dma->map, 0,
		    sc->sc_rec.length, BUS_DMASYNC_POSTREAD);
@


1.6
log
@Yup, I managed to fat finger all three of these while doing bus_dmamap_sync()
conversion (luckily only sparc64 uses the 5 arg form so far =)
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.5 2001/08/25 14:52:57 jason Exp $	*/
d177 1
a177 1
int	yds_mappage __P((void *, void *, int, int));
d1797 1
a1797 1
int
d1801 1
a1801 1
	int off;
@


1.5
log
@deal with 5 arg for of bus_dmamap_sync() if available
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.4 2001/08/25 10:13:30 art Exp $	*/
d1008 1
a1008 1
			    sc->sc_pbankoff,
d1494 1
a1494 1
	    NPLAY_SLOT_CTRL_BANK, BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
d1592 1
a1592 1
	yds_bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map, sc->sc_rbankoff,
d1666 1
a1666 1
		    sc->sc_rbankoff, sizeof(struct rec_slot_ctrl_bank)*
@


1.4
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.3 2001/06/12 15:40:33 niklas Exp $	*/
d93 8
d488 3
a490 1
	bus_dmamap_sync(sc->sc_dmatag, p->map, BUS_DMASYNC_PREWRITE);
d1007 4
a1010 1
			bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
d1021 1
a1021 1
				bus_dmamap_sync(sc->sc_dmatag,
d1023 1
d1035 2
a1036 2
				bus_dmamap_sync(sc->sc_dmatag,
				    sc->sc_play.dma->map,
d1044 3
a1046 1
			bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
d1057 3
a1059 2
				bus_dmamap_sync(sc->sc_dmatag,
				    sc->sc_rec.dma->map, BUS_DMASYNC_POSTREAD);
d1070 3
a1072 2
				bus_dmamap_sync(sc->sc_dmatag,
				    sc->sc_rec.dma->map, BUS_DMASYNC_PREREAD);
d1492 3
a1494 2
	bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
d1496 2
a1497 1
	bus_dmamap_sync(sc->sc_dmatag, p->map, BUS_DMASYNC_PREWRITE);
d1592 3
a1594 2
	bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
d1596 1
a1596 1
	bus_dmamap_sync(sc->sc_dmatag, p->map, BUS_DMASYNC_PREREAD);
d1635 3
a1637 1
		bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
d1645 2
a1646 2
		bus_dmamap_sync(sc->sc_dmatag, sc->sc_play.dma->map,
		    BUS_DMASYNC_POSTWRITE);
d1665 3
a1667 1
		bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
d1670 2
a1671 2
		bus_dmamap_sync(sc->sc_dmatag, sc->sc_rec.dma->map,
		    BUS_DMASYNC_POSTREAD);
@


1.3
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.2 2001/05/24 18:49:50 aaron Exp $	*/
d666 1
a666 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin, pa->pa_intrline,
	    &ih)) {
@


1.2
log
@Sync with NetBSD:
- Correct gain register initialization to fix L-R imbalance.
- Allow to compile on alpha with DIAGNOSTIC.
- Update TODO list.
- Some delinting.
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.1 2001/03/29 14:20:46 aaron Exp $	*/
d660 1
a660 1
	    &sc->memt, &sc->memh, NULL, NULL)) {
@


1.1
log
@Add support for Yamaha DS-XG based audio chips, as found in machines such as
newer Sony Vaio notebooks; written by Kazuki Sakamoto and Minoura Makoto.
This is a slightly updated version of the driver that was previously tested
by jcs@@rt.fm and niklas@@.

XXX - lacks MPU MIDI support for now, first we must move the mpu401 driver
from sys/dev/isa to sys/dev/ic.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD$	*/
d37 1
a37 1
 * - Fill in yds_chip_capability_list
d408 16
a423 4
	DPRINTF(("play control size : %d\n", (int) pcs));
	DPRINTF(("rec control size : %d\n", (int) rcs));
	DPRINTF(("eff control size : %d\n", (int) ecs));
	DPRINTF(("work size : %d\n", (int) ws));
d783 1
d1452 1
@


1.1.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.1 2001/03/29 14:20:46 aaron Exp $	*/
@


1.1.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: yds.c,v 1.5 2001/05/21 23:55:04 minoura Exp $	*/
d37 1
a37 1
 * - FM synth volume (difficult: mixed before ac97)
d408 4
a411 16
	DPRINTF(("play control size : %d\n", (unsigned int)pcs));
	DPRINTF(("rec control size : %d\n", (unsigned int)rcs));
	DPRINTF(("eff control size : %d\n", (unsigned int)ecs));
	DPRINTF(("work size : %d\n", (unsigned int)ws));
#ifdef DIAGNOSTIC
	if (pcs != sizeof(struct play_slot_ctrl_bank)) {
		printf("%s: invalid play slot ctrldata %d != %d\n",
		       sc->sc_dev.dv_xname, (unsigned int)pcs,
		       (unsigned int)sizeof(struct play_slot_ctrl_bank));
	}
	if (rcs != sizeof(struct rec_slot_ctrl_bank)) {
		printf("%s: invalid rec slot ctrldata %d != %d\n",
		       sc->sc_dev.dv_xname, (unsigned int)rcs,
		       (unsigned int)sizeof(struct rec_slot_ctrl_bank));
        }
#endif
d648 1
a648 1
	    &sc->memt, &sc->memh, NULL, NULL, 0)) {
a770 1
		;
a1438 1
				psb->lchgain = psb->lchgainend = 0;
@


1.1.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.1.4.2 2001/07/04 10:43:16 niklas Exp $	*/
a92 8
#ifdef __HAS_NEW_BUS_DMAMAP_SYNC
#define yds_bus_dmamap_sync(t, m, o, l, f) \
    bus_dmamap_sync((t), (m), (o), (l), (f))
#else
#define yds_bus_dmamap_sync(t, m, o, l, f) \
    bus_dmamap_sync((t), (m), (f))
#endif

d480 1
a480 3
	yds_bus_dmamap_sync(sc->sc_dmatag, p->map, sc->ptbloff,
	    (N_PLAY_SLOT_CTRL+1) * sizeof(u_int32_t),
	    BUS_DMASYNC_PREWRITE);
d666 2
a667 1
	if (pci_intr_map(pa, &ih)) {
d998 1
a998 4
			yds_bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
			    sc->pbankoff,
			    sizeof(struct play_slot_ctrl_bank) * (*sc->ptbl)*
			    N_PLAY_SLOT_CTRL_BANK,
d1009 1
a1009 1
				yds_bus_dmamap_sync(sc->sc_dmatag,
a1010 1
				    cpu, blk,
d1022 2
a1023 2
				yds_bus_dmamap_sync(sc->sc_dmatag,
				    sc->sc_play.dma->map, cpu, blk,
d1031 1
a1031 3
			yds_bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
			    sc->rbankoff, sizeof(struct rec_slot_ctrl_bank)*
			    N_REC_SLOT_CTRL * N_REC_SLOT_CTRL_BANK,
d1042 2
a1043 3
				yds_bus_dmamap_sync(sc->sc_dmatag,
				    sc->sc_rec.dma->map, cpu, blk,
				    BUS_DMASYNC_POSTREAD);
d1054 2
a1055 3
				yds_bus_dmamap_sync(sc->sc_dmatag,
				    sc->sc_rec.dma->map, cpu, blk,
				    BUS_DMASYNC_PREREAD);
d1475 2
a1476 3
	yds_bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
	    sc->ptbloff, sizeof(struct play_slot_ctrl_bank) * channels *
	    N_PLAY_SLOT_CTRL_BANK, BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
d1478 1
a1478 2
	yds_bus_dmamap_sync(sc->sc_dmatag, p->map, 0, blksize,
	    BUS_DMASYNC_PREWRITE);
d1573 2
a1574 3
	yds_bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map, sc->rbankoff,
	    sizeof(struct rec_slot_ctrl_bank) * N_REC_SLOT_CTRL *
	    N_REC_SLOT_CTRL_BANK, BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
d1576 1
a1576 1
	yds_bus_dmamap_sync(sc->sc_dmatag, p->map, 0, blksize, BUS_DMASYNC_PREREAD);
d1615 1
a1615 3
		yds_bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
		    sc->pbankoff, sizeof(struct play_slot_ctrl_bank) *
		    (*sc->ptbl)*N_PLAY_SLOT_CTRL_BANK,
d1623 2
a1624 2
		yds_bus_dmamap_sync(sc->sc_dmatag, sc->sc_play.dma->map, 0,
		    sc->sc_play.length, BUS_DMASYNC_POSTWRITE);
d1643 1
a1643 3
		yds_bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
		    sc->rbankoff, sizeof(struct rec_slot_ctrl_bank)*
		    N_REC_SLOT_CTRL*N_REC_SLOT_CTRL_BANK,
d1646 2
a1647 2
		yds_bus_dmamap_sync(sc->sc_dmatag, sc->sc_rec.dma->map, 0,
		    sc->sc_rec.length, BUS_DMASYNC_POSTREAD);
@


1.1.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a44 1
#include <sys/fcntl.h>
d93 8
d104 1
a104 2
int	yds_allocmem __P((struct yds_softc *, size_t, size_t,
	    struct yds_dma *));
d152 4
a159 4
struct cfdriver yds_cd = {
	NULL, "yds", DV_DULL
};

d163 1
a163 2
int	yds_set_params __P((void *, int, int,
	    struct audio_params *, struct audio_params *));
d177 1
a177 1
paddr_t	yds_mappage __P((void *, void *, off_t, int));
d186 1
a186 1
	    char *));
d234 1
a234 1
	yds_trigger_input
d488 3
a490 3
	bus_dmamap_sync(sc->sc_dmatag, p->map,
			sc->ptbloff, (N_PLAY_SLOT_CTRL+1) * sizeof(u_int32_t),
			BUS_DMASYNC_PREWRITE);
a663 1
	char devinfo[256];
a665 1
	int revision;
a667 4
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
	revision = PCI_REVISION(pa->pa_class);
	printf(": %s (rev. 0x%02x)\n", devinfo, revision);

d1007 5
a1011 7
			bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
					sc->pbankoff,
					sizeof(struct play_slot_ctrl_bank)*
					    (*sc->ptbl)*
					    N_PLAY_SLOT_CTRL_BANK,
					BUS_DMASYNC_POSTWRITE|
					BUS_DMASYNC_POSTREAD);
d1020 5
a1024 5
				/* Sync ring buffer for previous write */
				bus_dmamap_sync(sc->sc_dmatag,
						sc->sc_play.dma->map,
						cpu, blk,
						BUS_DMASYNC_POSTWRITE);
d1035 3
a1037 4
				bus_dmamap_sync(sc->sc_dmatag,
						sc->sc_play.dma->map,
						cpu, blk,
						BUS_DMASYNC_PREWRITE);
d1044 4
a1047 7
			bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
					sc->rbankoff,
					sizeof(struct rec_slot_ctrl_bank)*
					    N_REC_SLOT_CTRL*
					    N_REC_SLOT_CTRL_BANK,
					BUS_DMASYNC_POSTWRITE|
					BUS_DMASYNC_POSTREAD);
d1057 3
a1059 4
				bus_dmamap_sync(sc->sc_dmatag,
						sc->sc_rec.dma->map,
						cpu, blk,
						BUS_DMASYNC_POSTREAD);
d1070 3
a1072 4
				bus_dmamap_sync(sc->sc_dmatag,
						sc->sc_rec.dma->map,
						cpu, blk,
						BUS_DMASYNC_PREREAD);
d1492 3
a1494 5
	bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
			sc->ptbloff,
			sizeof(struct play_slot_ctrl_bank) *
			    channels * N_PLAY_SLOT_CTRL_BANK,
			BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
d1496 2
a1497 2
	bus_dmamap_sync(sc->sc_dmatag, p->map, 0, blksize,
			BUS_DMASYNC_PREWRITE);
d1592 3
a1594 6
	bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
			sc->rbankoff,
			sizeof(struct rec_slot_ctrl_bank)*
			    N_REC_SLOT_CTRL*
			    N_REC_SLOT_CTRL_BANK,
			BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
d1596 1
a1596 2
	bus_dmamap_sync(sc->sc_dmatag, p->map, 0, blksize,
			BUS_DMASYNC_PREREAD);
d1635 4
a1638 5
		bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
				sc->pbankoff,
				sizeof(struct play_slot_ctrl_bank)*
				    (*sc->ptbl)*N_PLAY_SLOT_CTRL_BANK,
				BUS_DMASYNC_POSTWRITE|BUS_DMASYNC_POSTREAD);
d1645 2
a1646 2
		bus_dmamap_sync(sc->sc_dmatag, sc->sc_play.dma->map,
				0, sc->sc_play.length, BUS_DMASYNC_POSTWRITE);
d1665 4
a1668 5
		bus_dmamap_sync(sc->sc_dmatag, sc->sc_ctrldata.map,
				sc->rbankoff,
				sizeof(struct rec_slot_ctrl_bank)*
				    N_REC_SLOT_CTRL*N_REC_SLOT_CTRL_BANK,
				BUS_DMASYNC_POSTWRITE|BUS_DMASYNC_POSTREAD);
d1670 2
a1671 2
		bus_dmamap_sync(sc->sc_dmatag, sc->sc_rec.dma->map,
				0, sc->sc_rec.length, BUS_DMASYNC_POSTREAD);
d1797 1
a1797 1
paddr_t
d1801 1
a1801 1
	off_t off;
@


1.1.4.5
log
@Merge in trunk
@
text
@a71 5
#ifdef AUDIO_DEBUG
#include <uvm/uvm_extern.h>    /* for vtophys */
#include <uvm/uvm_pmap.h>      /* for vtophys */
#endif

d169 1
a169 1
void   *yds_malloc __P((void *, int, size_t, int, int));
d171 1
a171 1
size_t	yds_round_buffersize __P((void *, int, size_t));
a194 3
void yds_powerhook __P((int, void *));
int	yds_init __P((void *sc));

d661 3
a663 1
	int i, r;
d666 2
a697 1
	sc->sc_revision = PCI_REVISION(pa->pa_class);
d700 7
a706 3
	if (ydsdebug)
		printf("%s: chip has %b\n", sc->sc_dev.dv_xname,
			YDS_CAP_BITS, sc->sc_flags);
a717 1

d725 82
a806 2
	/* Initialize the device */
	yds_init(sc);
a877 4

	/* Watch for power changes */
	sc->suspend = PWR_RESUME;
	sc->powerhook = powerhook_establish(yds_powerhook, sc);
a921 7
	if (PCI_PRODUCT(sc->sc->sc_id) == PCI_PRODUCT_YAMAHA_YMF744 &&
	    sc->sc->sc_revision < 2) {
		int i;

		for (i = 0; i < 600; i++)
			YREAD2(sc->sc, sc->status_data);
	}
d983 1
a983 1
#if 0
d1555 10
d1747 1
a1747 1
yds_malloc(addr, direction, size, pool, flags)
d1749 1
a1749 2
	int direction;
	size_t size;
d1801 2
a1802 2
size_t
yds_round_buffersize(addr, direction, size)
d1804 1
a1804 2
	int direction;
	size_t size;
a1838 128
}

void
yds_powerhook(why, self)
	int why;
	void *self;
{
	struct yds_softc *sc = (struct yds_softc *)self;

	if (why != PWR_RESUME) {
		/* Power down */
		DPRINTF(("yds: power down\n"));
		sc->suspend = why;

	} else {
		/* Wake up */
		DPRINTF(("yds: power resume\n"));
		if (sc->suspend == PWR_RESUME) {
			printf("%s: resume without suspend?\n",
				sc->sc_dev.dv_xname);
			sc->suspend = why;
			return;
		}
		sc->suspend = why;
		yds_init(sc);
		(sc->sc_codec[0].codec_if->vtbl->restore_ports)(sc->sc_codec[0].codec_if);
	}
}

int
yds_init(sc_)
	void *sc_;
{
	struct yds_softc *sc = sc_;
	u_int32_t reg;

	pci_chipset_tag_t pc = sc->sc_pc;

	int to;

	DPRINTF(("in yds_init()\n"));

	/* Download microcode */
	if (yds_download_mcode(sc)) {
		printf("%s: download microcode failed\n", sc->sc_dev.dv_xname);
		return -1;
	}
	/* Allocate DMA buffers */
	if (yds_allocate_slots(sc)) {
		printf("%s: could not allocate slots\n", sc->sc_dev.dv_xname);
		return -1;
	}

	/* Warm reset */
	reg = pci_conf_read(pc, sc->sc_pcitag, YDS_PCI_DSCTRL);
	pci_conf_write(pc, sc->sc_pcitag, YDS_PCI_DSCTRL, reg | YDS_DSCTRL_WRST);
	delay(50000);

	/*
	 * Detect primary/secondary AC97
	 *	YMF754 Hardware Specification Rev 1.01 page 24
	 */
	reg = pci_conf_read(pc, sc->sc_pcitag, YDS_PCI_DSCTRL);
	pci_conf_write(pc, sc->sc_pcitag, YDS_PCI_DSCTRL,
		reg & ~YDS_DSCTRL_CRST);
	delay(400000);		/* Needed for 740C. */

	/* Primary */
	for (to = 0; to < AC97_TIMEOUT; to++) {
		if ((YREAD2(sc, AC97_STAT_ADDR1) & AC97_BUSY) == 0)
			break;
		delay(1);
	}
	if (to == AC97_TIMEOUT) {
		printf("%s: no AC97 avaliable\n", sc->sc_dev.dv_xname);
		return -1;
	}

	/* Secondary */
	/* Secondary AC97 is used for 4ch audio. Currently unused. */
	ac97_id2 = -1;
	if ((YREAD2(sc, YDS_ACTIVITY) & YDS_ACTIVITY_DOCKA) == 0)
		goto detected;
#if 0				/* reset secondary... */
	YWRITE2(sc, YDS_GPIO_OCTRL,
		YREAD2(sc, YDS_GPIO_OCTRL) & ~YDS_GPIO_GPO2);
	YWRITE2(sc, YDS_GPIO_FUNCE,
		(YREAD2(sc, YDS_GPIO_FUNCE)&(~YDS_GPIO_GPC2))|YDS_GPIO_GPE2);
#endif
	for (to = 0; to < AC97_TIMEOUT; to++) {
		if ((YREAD2(sc, AC97_STAT_ADDR2) & AC97_BUSY) == 0)
			break;
		delay(1);
	}
	if (to < AC97_TIMEOUT) {
		/* detect id */
		for (ac97_id2 = 1; ac97_id2 < 4; ac97_id2++) {
			YWRITE2(sc, AC97_CMD_ADDR,
				AC97_CMD_READ | AC97_ID(ac97_id2) | 0x28);

			for (to = 0; to < AC97_TIMEOUT; to++) {
				if ((YREAD2(sc, AC97_STAT_ADDR2) & AC97_BUSY)
				    == 0)
					goto detected;
				delay(1);
			}
		}
		if (ac97_id2 == 4)
			ac97_id2 = -1;
detected:
		;
	}

	pci_conf_write(pc, sc->sc_pcitag, YDS_PCI_DSCTRL,
		reg | YDS_DSCTRL_CRST);
	delay (20);
	pci_conf_write(pc, sc->sc_pcitag, YDS_PCI_DSCTRL,
		reg & ~YDS_DSCTRL_CRST);
	delay (400000);
	for (to = 0; to < AC97_TIMEOUT; to++) {
		if ((YREAD2(sc, AC97_STAT_ADDR1) & AC97_BUSY) == 0)
			break;
		delay(1);
	}

	DPRINTF(("out of yds_init()\n"));

	return ac97_id2;
@


1.1.4.6
log
@Merge in -current from roughly a week ago
@
text
@d95 3
a97 3
int	yds_match(struct device *, void *, void *);
void	yds_attach(struct device *, struct device *, void *);
int	yds_intr(void *);
d102 3
a104 3
int	yds_allocmem(struct yds_softc *, size_t, size_t,
	    struct yds_dma *);
int	yds_freemem(struct yds_softc *, struct yds_dma *);
d159 40
a198 40
int	yds_open(void *, int);
void	yds_close(void *);
int	yds_query_encoding(void *, struct audio_encoding *);
int	yds_set_params(void *, int, int,
	    struct audio_params *, struct audio_params *);
int	yds_round_blocksize(void *, int);
int	yds_trigger_output(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	yds_trigger_input(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	yds_halt_output(void *);
int	yds_halt_input(void *);
int	yds_getdev(void *, struct audio_device *);
int	yds_mixer_set_port(void *, mixer_ctrl_t *);
int	yds_mixer_get_port(void *, mixer_ctrl_t *);
void   *yds_malloc(void *, int, size_t, int, int);
void	yds_free(void *, void *, int);
size_t	yds_round_buffersize(void *, int, size_t);
paddr_t	yds_mappage(void *, void *, off_t, int);
int	yds_get_props(void *);
int	yds_query_devinfo(void *addr, mixer_devinfo_t *dip);

int     yds_attach_codec(void *sc, struct ac97_codec_if *);
int	yds_read_codec(void *sc, u_int8_t a, u_int16_t *d);
int	yds_write_codec(void *sc, u_int8_t a, u_int16_t d);
void    yds_reset_codec(void *sc);
int     yds_get_portnum_by_name(struct yds_softc *, char *, char *,
	    char *);

static u_int yds_get_dstype(int);
static int yds_download_mcode(struct yds_softc *);
static int yds_allocate_slots(struct yds_softc *);
static void yds_configure_legacy(struct device *arg);
static void yds_enable_dsp(struct yds_softc *);
static int yds_disable_dsp(struct yds_softc *);
static int yds_ready_codec(struct yds_codec_softc *);
static int yds_halt(struct yds_softc *);
static u_int32_t yds_get_lpfq(u_int);
static u_int32_t yds_get_lpfk(u_int);
static struct yds_dma *yds_find_dma(struct yds_softc *, void *);
d200 2
a201 2
void yds_powerhook(int, void *);
int	yds_init(void *sc);
d204 1
a204 1
static void yds_dump_play_slot(struct yds_softc *, int);
d304 1
a304 1
		dma = yds_find_dma(sc,(void *)p);
d307 1
a307 1
		       i, p, (void *)vtophys((vaddr_t)p));
d452 1
a452 1
		 mp, (void *) sc->sc_ctrldata.map->dm_segs[0].ds_addr));
d1314 1
a1314 1
	void (*intr)(void *);
d1455 1
a1455 1
	void (*intr)(void *);
@


1.1.4.7
log
@Sync the SMP branch with 3.3
@
text
@d573 1
a573 1
	reg |= YDS_PCI_EX_LEGACY_SBMOD_XXX | ((YDS_PCI_EX_LEGACY_IMOD) |
d1598 1
a1612 1
	sc->sc_rec.intr = NULL;
@


1.1.4.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: yds.c,v 1.1.4.7 2003/03/28 00:38:25 niklas Exp $	*/
d671 1
a671 1
	pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo, sizeof devinfo);
d1116 1
a1116 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d1122 1
a1122 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d1128 1
a1128 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d1134 1
a1134 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d1140 1
a1140 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d1146 1
a1146 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d1152 1
a1152 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d1158 1
a1158 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
@


1.1.4.9
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a93 2

static	int ac97_id2;
@


1.1.4.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1840 1
a1840 1
		printf("%s: no AC97 available\n", sc->sc_dev.dv_xname);
@


1.1.4.11
log
@Merge with the trunk
@
text
@a255 1
#define YDS_CAP_LEGACY_SMOD_DISABLE	0x1000
d575 3
a577 4
	reg |= (YDS_PCI_EX_LEGACY_IMOD | YDS_PCI_LEGACY_FMEN |
		YDS_PCI_LEGACY_MEN /*| YDS_PCI_LEGACY_MIEN*/);
	if (sc->sc_flags & YDS_CAP_LEGACY_SMOD_DISABLE)
		reg |= YDS_PCI_EX_LEGACY_SMOD_DISABLE;
a666 1
	bus_size_t size;
d669 1
d673 2
d677 1
a677 1
	    &sc->memt, &sc->memh, NULL, &size, 0)) {
a684 1
		bus_space_unmap(sc->memt, sc->memh, size);
a695 1
		bus_space_unmap(sc->memt, sc->memh, size);
a705 2
	if (sc->sc_dev.dv_cfdata->cf_flags & YDS_CAP_LEGACY_SMOD_DISABLE)
		sc->sc_flags |= YDS_CAP_LEGACY_SMOD_DISABLE;
@


