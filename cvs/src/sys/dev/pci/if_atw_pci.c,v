head	1.18;
access;
symbols
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.8
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.6
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.4
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.15.0.10
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.8
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.4
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.14.0.6
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.12.0.6
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.7.0.8
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.6
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.4
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.18
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.17;
commitid	5gdEnqVoJuTuwdTu;

1.17
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.16;
commitid	yM2VFFhpDTeFQlve;

1.16
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.15;
commitid	LS2TNeCue5R9L67C;

1.15
date	2012.10.18.21.44.21;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.13;

1.13
date	2010.08.29.16.47.00;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.02.15.13.58;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.02.04.03.39;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.22.23.00.45;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.22.03.16.35;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.08.12.44.55;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2005.08.09.04.10.11;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2005.06.26.04.00.23;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.31.04.27.52;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.25.13.50.49;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.27.19.30.03;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.22.23.55.23;	author millert;	state Exp;
branches;
next	;


desc
@@


1.18
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_atw_pci.c,v 1.17 2014/12/22 02:28:51 tedu Exp $	*/
/*	$NetBSD: if_atw_pci.c,v 1.7 2004/07/23 07:07:55 dyoung Exp $	*/

/*-
 * Copyright (c) 1998, 1999, 2000, 2002 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center; Charles M. Hannum; and David Young.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * PCI bus front-end for the ADMtek ADM8211 802.11 MAC/BBP chip.
 *
 * Derived from the ``Tulip'' PCI bus front-end.
 */

#include <sys/param.h>
#include <sys/systm.h> 
#include <sys/mbuf.h>   
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/endian.h>
 
#include <net/if.h>
#include <net/if_media.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_radiotap.h>
#include <net80211/ieee80211_var.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/ic/atwreg.h>
#include <dev/ic/rf3000reg.h>
#include <dev/ic/si4136reg.h>
#include <dev/ic/atwvar.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

/*
 * PCI configuration space registers used by the ADM8211.
 */
#define	ATW_PCI_IOBA		0x10	/* i/o mapped base */
#define	ATW_PCI_MMBA		0x14	/* memory mapped base */

struct atw_pci_softc {
	struct atw_softc	psc_atw;	/* real ADM8211 softc */

	pci_intr_handle_t	psc_ih;		/* interrupt handle */
	void			*psc_intrcookie;

	pci_chipset_tag_t	psc_pc;		/* our PCI chipset */
	pcitag_t		psc_pcitag;	/* our PCI tag */
};

int	atw_pci_match(struct device *, void *, void *);
void	atw_pci_attach(struct device *, struct device *, void *);
int	atw_pci_detach(struct device *, int);

struct cfattach atw_pci_ca = {
    sizeof (struct atw_softc), atw_pci_match, atw_pci_attach, atw_pci_detach,
    atw_activate
};

const struct pci_matchid atw_pci_devices[] = {
	{ PCI_VENDOR_ADMTEK,		PCI_PRODUCT_ADMTEK_ADM8211 },
	{ PCI_VENDOR_3COM,		PCI_PRODUCT_3COM_3CRSHPW796 }
};

int
atw_pci_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, atw_pci_devices,
	    nitems(atw_pci_devices)));
}

static int
atw_pci_enable(struct atw_softc *sc)
{
	struct atw_pci_softc *psc = (void *)sc;

	/* Establish the interrupt. */
	psc->psc_intrcookie = pci_intr_establish(psc->psc_pc, psc->psc_ih,
	    IPL_NET, atw_intr, sc, sc->sc_dev.dv_xname);
	if (psc->psc_intrcookie == NULL) {
		printf("%s: unable to establish interrupt\n",
		    sc->sc_dev.dv_xname);
		return (1);
	}

	return (0);
}

static void
atw_pci_disable(struct atw_softc *sc)
{
	struct atw_pci_softc *psc = (void *)sc;

	/* Unhook the interrupt handler. */
	pci_intr_disestablish(psc->psc_pc, psc->psc_intrcookie);
	psc->psc_intrcookie = NULL;
}

void
atw_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct atw_pci_softc *psc = (void *) self;
	struct atw_softc *sc = &psc->psc_atw;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	const char *intrstr = NULL;
	bus_space_tag_t iot, memt;
	bus_space_handle_t ioh, memh;
	bus_size_t iosize, memsize;
	int ioh_valid, memh_valid;

	psc->psc_pc = pa->pa_pc;
	psc->psc_pcitag = pa->pa_tag;

	/*
	 * No power management hooks.
	 * XXX Maybe we should add some!
	 */
	sc->sc_flags |= ATWF_ENABLED;

	/*
	 * Get revision info, and set some chip-specific variables.
	 */
	sc->sc_rev = PCI_REVISION(pa->pa_class);

	/*
	 * Check to see if the device is in power-save mode, and
	 * being it out if necessary.
	 *
	 * XXX This code comes almost verbatim from if_tlp_pci.c. I do
	 * not understand it. Tulip clears the "sleep mode" bit in the
	 * CFDA register, first.  There is an equivalent (?) register at the
	 * same place in the ADM8211, but the docs do not assign its bits
	 * any meanings. -dcy
	 */
	pci_set_powerstate(pc, pa->pa_tag, PCI_PMCSR_STATE_D0);

	/*
	 * Map the device.
	 */
	ioh_valid = (pci_mapreg_map(pa, ATW_PCI_IOBA,
	    PCI_MAPREG_TYPE_IO, 0,
	    &iot, &ioh, NULL, &iosize, 0) == 0);
	memh_valid = (pci_mapreg_map(pa, ATW_PCI_MMBA,
	    PCI_MAPREG_TYPE_MEM|PCI_MAPREG_MEM_TYPE_32BIT, 0,
	    &memt, &memh, NULL, &memsize, 0) == 0);

	if (memh_valid) {
		sc->sc_st = memt;
		sc->sc_sh = memh;
		sc->sc_mapsize = memsize;
	} else if (ioh_valid) {
		sc->sc_st = iot;
		sc->sc_sh = ioh;
		sc->sc_mapsize = iosize;
	} else {
		printf(": unable to map device registers\n");
		return;
	}

	sc->sc_dmat = pa->pa_dmat;

	/*
	 * Get the cacheline size.
	 */
	sc->sc_cacheline = PCI_CACHELINE(pci_conf_read(pc, pa->pa_tag,
	    PCI_BHLC_REG));

	/*
	 * Get PCI data moving command info.
	 */
	if (pa->pa_flags & PCI_FLAGS_MRL_OKAY) /* read line */
		sc->sc_flags |= ATWF_MRL;
	if (pa->pa_flags & PCI_FLAGS_MRM_OKAY) /* read multiple */
		sc->sc_flags |= ATWF_MRM;
	if (pa->pa_flags & PCI_FLAGS_MWI_OKAY) /* write invalidate */
		sc->sc_flags |= ATWF_MWI;

	/*
	 * Map and establish our interrupt.
	 */
	if (pci_intr_map(pa, &psc->psc_ih)) {
		printf(": unable to map interrupt\n");
		return;
	}
	intrstr = pci_intr_string(pc, psc->psc_ih); 
	psc->psc_intrcookie = pci_intr_establish(pc, psc->psc_ih, IPL_NET,
	    atw_intr, sc, sc->sc_dev.dv_xname);
	if (psc->psc_intrcookie == NULL) {
		printf(": unable to establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}

	printf(": %s\n", intrstr);

	sc->sc_enable = atw_pci_enable;
	sc->sc_disable = atw_pci_disable;

	/*
	 * Finish off the attach.
	 */
	atw_attach(sc);
}

int
atw_pci_detach(struct device *self, int flags)
{
	struct atw_pci_softc *psc = (void *)self;
	struct atw_softc *sc = &psc->psc_atw;
	int rv;

	rv = atw_detach(sc);
	if (rv)
		return (rv);

	if (psc->psc_intrcookie != NULL)
		pci_intr_disestablish(psc->psc_pc, psc->psc_intrcookie);

	bus_space_unmap(sc->sc_st, sc->sc_sh, sc->sc_mapsize);

	return (0);
}
@


1.17
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_pci.c,v 1.16 2014/12/19 22:44:58 guenther Exp $	*/
a51 1
#include <net/if_dl.h>
@


1.16
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_pci.c,v 1.15 2012/10/18 21:44:21 deraadt Exp $	*/
a53 1
#ifdef INET
a55 1
#endif
@


1.15
log
@Convert a number of old private copies of code which predates
pci_set_powerstate() to using it instead.  Many of these chunks of code had
bugs in them, especially missing delay() calls.  Some of them were doing
things our PCI subsystem is now responsible for handling.  If you have
any of the affected devices, please keep an eye out for regressions.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_pci.c,v 1.14 2011/04/03 15:36:02 jasper Exp $	*/
d49 1
a49 2

#include <machine/endian.h>
@


1.14
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_pci.c,v 1.13 2010/08/29 16:47:00 deraadt Exp $	*/
a150 1
	int state;
d176 1
a176 10
	state = pci_set_powerstate(pc, pa->pa_tag, PCI_PMCSR_STATE_D0);
	if (state == PCI_PMCSR_STATE_D3) {
		/*
		 * The card has lost all configuration data in
		 * this state, so punt.
		 */
		printf(": unable to wake up from power state D3, "
		    "reboot required.\n");
		return;
	}
@


1.13
log
@Massage the powerhook functions into activate functions, and then call
them from the powerhook.  Fix a few quibbles about the things done for
the IFF_RUNNING and IFF_UP cases
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_pci.c,v 1.12 2009/06/02 15:13:58 jsg Exp $	*/
d109 1
a109 1
	    sizeof(atw_pci_devices)/sizeof(atw_pci_devices[0])));
@


1.12
log
@let atw at pci be detachable; untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_pci.c,v 1.11 2009/06/02 04:03:39 jsg Exp $	*/
d96 2
a97 1
    sizeof (struct atw_softc), atw_pci_match, atw_pci_attach, atw_pci_detach
@


1.11
log
@Add more CardBus ids to PCI attachments to cope with
things like the crazy ExpressCard->CardBus adapters which
make CardBus devices show as PCI devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_pci.c,v 1.10 2008/06/26 05:42:17 ray Exp $	*/
d93 1
d96 1
a96 1
    sizeof (struct atw_softc), atw_pci_match, atw_pci_attach
d148 1
d192 1
a192 1
	    &iot, &ioh, NULL, NULL, 0) == 0);
d195 1
a195 1
	    &memt, &memh, NULL, NULL, 0) == 0);
d200 1
d204 1
d255 19
@


1.10
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_pci.c,v 1.9 2007/10/22 23:00:45 fgsch Exp $	*/
d100 1
@


1.9
log
@only output on situations where power state is D3. unify the message in
such cases. ok brad@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_pci.c,v 1.8 2007/10/22 03:16:35 fgsch Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.8
log
@Use pci_set_powerstate(), shrinking the code and unifying the different
versions. ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_pci.c,v 1.7 2005/09/08 12:44:55 jsg Exp $	*/
d181 8
a188 13
	if (state != PCI_PMCSR_STATE_D0) {
		if (state == PCI_PMCSR_STATE_D3) {
			/*
			 * The card has lost all configuration data in
			 * this state, so punt.
			 */
			printf(": unable to wake up from power state D3, "
			    "reboot required.\n");
			return;
		} else {
			printf(": waking up from power state D%d\n%s",
			    state, sc->sc_dev.dv_xname);
		}
@


1.7
log
@Remove the last of the FreeBSD compatiblity goop.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_pci.c,v 1.6 2005/08/09 04:10:11 mickey Exp $	*/
d154 1
a154 2
	pcireg_t reg;
	int pmreg;
d180 3
a182 12
	if (pci_get_capability(pc, pa->pa_tag, PCI_CAP_PWRMGMT, &pmreg, 0)) {
		reg = pci_conf_read(pc, pa->pa_tag, pmreg + PCI_PMCSR);
		switch (reg & PCI_PMCSR_STATE_MASK) {
		case PCI_PMCSR_STATE_D1:
		case PCI_PMCSR_STATE_D2:
			printf(": waking up from power state D%d\n%s",
			    reg & PCI_PMCSR_STATE_MASK, sc->sc_dev.dv_xname);
			pci_conf_write(pc, pa->pa_tag, pmreg + PCI_PMCSR,
			    (reg & ~PCI_PMCSR_STATE_MASK) |
			    PCI_PMCSR_STATE_D0);
			break;
		case PCI_PMCSR_STATE_D3:
d188 1
a188 4
			       "reboot required.\n");
			pci_conf_write(pc, pa->pa_tag, pmreg + PCI_PMCSR,
			    (reg & ~PCI_PMCSR_STATE_MASK) |
			    PCI_PMCSR_STATE_D0);
d190 3
@


1.6
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_pci.c,v 1.5 2005/06/26 04:00:23 brad Exp $	*/
a66 1
#include <net80211/ieee80211_compat.h>
@


1.5
log
@Use pci_matchbyid().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_pci.c,v 1.4 2004/12/31 04:27:52 jsg Exp $	*/
a228 7

	/*
	 * Make sure bus mastering is enabled.
	 */
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG) |
	    PCI_COMMAND_MASTER_ENABLE);
@


1.4
log
@Define atw cfdriver struct in atw.c so atw at cardbus does not
depend on atw at pci. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_pci.c,v 1.3 2004/07/25 13:50:49 millert Exp $	*/
d106 1
a106 4
const struct atw_pci_product {
	u_int32_t	app_vendor;	/* PCI vendor ID */
	u_int32_t	app_product;	/* PCI product ID */
} atw_pci_products[] = {
a107 2

	{ 0,				0 },
a109 17
const struct atw_pci_product *atw_pci_lookup(const struct pci_attach_args *);

const struct atw_pci_product *
atw_pci_lookup(const struct pci_attach_args *pa)
{
	const struct atw_pci_product *app;

	for (app = atw_pci_products;
	     app->app_vendor != 0 && app->app_product != 0;
	     app++) {
		if (PCI_VENDOR(pa->pa_id) == app->app_vendor &&
		    PCI_PRODUCT(pa->pa_id) == app->app_product)
			return (app);
	}
	return (NULL);
}

d113 2
a114 6
	struct pci_attach_args *pa = aux;

	if (atw_pci_lookup(pa) != NULL)
		return (1);

	return (0);
a154 1
	const struct atw_pci_product *app;
a159 6

	app = atw_pci_lookup(pa);
	if (app == NULL) {
		printf("\n");
		panic("atw_pci_attach: impossible");
	}
@


1.3
log
@Store pci/cardbus revision number.  From NetBSD (dyoung)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_pci.c,v 1.2 2004/06/27 19:30:03 millert Exp $	*/
a103 3
};
struct cfdriver atw_cd = {
    0, "atw", DV_IFNET
@


1.2
log
@Reduce verbosity of atw PCI attach without removing actual info.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_atw_pci.c,v 1.1 2004/06/22 23:55:23 millert Exp $	*/
/*	$NetBSD: if_atw_pci.c,v 1.6 2004/02/17 21:20:55 dyoung Exp $	*/
d202 5
@


1.1
log
@atw(4) driver from NetBSD (dyoung).  Based in part on a port by
Matthew Gream.

Unfortunately, the adm8211 card I have with me does not work correctly
with the driver yet so real testing will have to wait until I get
my hands on an adm8211-based DWL-650 or something similar.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a111 1
	const char	*app_product_name;
d113 1
a113 2
	{ PCI_VENDOR_ADMTEK,		PCI_PRODUCT_ADMTEK_ADM8211,
	  "ADMtek ADM8211 802.11 MAC/BBP" },
d115 1
a115 1
	{ 0,				0,				NULL },
d126 1
a126 1
	     app->app_product_name != NULL;
d186 1
a186 1
	int pmreg, rev;
a203 7
	 * Get revision info, and set some chip-specific variables.
	 */
	rev = PCI_REVISION(pa->pa_class);
	printf(": %s, pass %d.%d\n", app->app_product_name,
	    (rev >> 4) & 0xf, rev & 0xf);

	/*
d288 1
a288 2
		printf("%s: unable to map interrupt\n",
		    sc->sc_dev.dv_xname);
d295 1
a295 2
		printf("%s: unable to establish interrupt",
		    sc->sc_dev.dv_xname);
d302 1
a302 1
	printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname, intrstr);
@

