head	1.37;
access;
symbols
	OPENBSD_6_2_BASE:1.37
	OPENBSD_6_1:1.37.0.8
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.37.0.6
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.36.0.8
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.6
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.35.0.8
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.4
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.2
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.30.0.4
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.2
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.27.0.8
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.6
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.4
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.17.0.8
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.6
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.5.0.8
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.6
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.5.0.4
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.6
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.37
date	2015.10.20.17.08.39;	author chrisz;	state Exp;
branches;
next	1.36;
commitid	dHvRleKtOmi6SxLB;

1.36
date	2014.07.08.05.35.19;	author dlg;	state Exp;
branches;
next	1.35;
commitid	0QJleeeWqZmC5anF;

1.35
date	2013.02.09.19.17.52;	author sthen;	state Exp;
branches;
next	1.34;

1.34
date	2013.01.28.02.57.02;	author dtucker;	state Exp;
branches;
next	1.33;

1.33
date	2013.01.16.05.25.57;	author dtucker;	state Exp;
branches;
next	1.32;

1.32
date	2012.10.20.16.12.22;	author chris;	state Exp;
branches;
next	1.31;

1.31
date	2012.10.18.21.44.21;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2012.01.05.19.08.25;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2011.12.08.20.19.24;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2011.03.13.15.38.50;	author stsp;	state Exp;
branches;
next	1.27;

1.27
date	2009.06.18.17.48.15;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2009.05.12.13.30.56;	author sthen;	state Exp;
branches;
next	1.25;

1.25
date	2009.05.11.07.41.52;	author sthen;	state Exp;
branches;
next	1.24;

1.24
date	2009.05.10.12.23.56;	author sthen;	state Exp;
branches;
next	1.23;

1.23
date	2009.05.10.12.09.46;	author sthen;	state Exp;
branches;
next	1.22;

1.22
date	2009.04.28.12.54.31;	author mpf;	state Exp;
branches;
next	1.21;

1.21
date	2008.07.18.13.38.40;	author thib;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.04.01.29.39;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.04.00.15.28;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.01.10.26.25;	author mglocker;	state Exp;
branches;
next	1.17;

1.17
date	2006.02.05.18.23.37;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.07.22.48.39;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.06.02.22.28;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.27.00.18.59;	author pvalchev;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.28.04.37.33;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.19.11.37.00;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.12.02.53.59;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.12.02.35.53;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.10.19.02.24;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.10.18.05.12;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.19.14.38.23;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.09.10.53.24;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.16.13.41.27;	author aaron;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.02.20.19.12.48;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.17.07.35.36;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	99.01.30.23.15.37;	author niklas;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	99.01.10.22.30.46;	author downsj;	state Exp;
branches;
next	;

1.2.6.1
date	2001.05.14.22.25.48;	author niklas;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2001.07.04.10.42.29;	author niklas;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.2.6.4;

1.2.6.4
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	1.2.6.5;

1.2.6.5
date	2004.06.05.23.12.51;	author niklas;	state Exp;
branches;
next	;

1.5.4.1
date	2003.05.19.22.18.01;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Fix 802.1p VLAN priority code points for VLAN_HWTAGGING.
Our in-kernel ether-vtag has a different layout to the vr TXSTAT register.

ok sthen@@
@
text
@/*	$OpenBSD: if_vrreg.h,v 1.36 2014/07/08 05:35:19 dlg Exp $	*/

/*
 * Copyright (c) 1997, 1998
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/pci/if_vrreg.h,v 1.17 2003/02/01 01:27:05 silby Exp $
 */

/*
 * Rhine register definitions.
 */

#define VR_PAR0			0x00	/* node address 0 to 4 */
#define VR_PAR1			0x04	/* node address 2 to 6 */
#define VR_RXCFG		0x06	/* receiver config register */
#define VR_TXCFG		0x07	/* transmit config register */
#define VR_COMMAND		0x08	/* command register */
#define VR_TQWK			0x0A	/* transmit queue wake */
#define VR_ISR			0x0C	/* interrupt/status register */
#define VR_IMR			0x0E	/* interrupt mask register */
#define VR_MAR0			0x10	/* multicast hash 0 */
#define VR_MAR1			0x14	/* multicast hash 1 */
#define VR_RXADDR		0x18	/* rx descriptor list start addr */
#define VR_TXADDR		0x1C	/* tx descriptor list start addr */
#define VR_CURRXDESC0		0x20
#define VR_CURRXDESC1		0x24
#define VR_CURRXDESC2		0x28
#define VR_CURRXDESC3		0x2C
#define VR_NEXTRXDESC0		0x30
#define VR_NEXTRXDESC1		0x34
#define VR_NEXTRXDESC2		0x38
#define VR_NEXTRXDESC3		0x3C
#define VR_CURTXDESC0		0x40
#define VR_CURTXDESC1		0x44
#define VR_CURTXDESC2		0x48
#define VR_CURTXDESC3		0x4C
#define VR_NEXTTXDESC0		0x50
#define VR_NEXTTXDESC1		0x54
#define VR_NEXTTXDESC2		0x58
#define VR_NEXTTXDESC3		0x5C
#define VR_CURRXDMA		0x60	/* current RX DMA address */
#define VR_CURTXDMA		0x64	/* current TX DMA address */
#define VR_TALLYCNT		0x68	/* tally counter test register */
#define VR_PHYADDR		0x6C
#define VR_MIISTAT		0x6D
#define VR_BCR0			0x6E
#define VR_BCR1			0x6F
#define VR_MIICMD		0x70
#define VR_MIIADDR		0x71
#define VR_MIIDATA		0x72
#define VR_EECSR		0x74
#define VR_TEST			0x75
#define VR_GPIO			0x76
#define VR_CONFIG		0x78
#define VR_MPA_CNT		0x7C
#define VR_CRC_CNT		0x7E
#define VR_STICKHW		0x83
#define VR_CAMMASK		0x88 /* length 4 bytes */
#define VR_CAMCTRL		0x92
#define VR_CAMADDR		0x93

/* Misc Registers */
#define VR_MISC_CR1		0x81
#define VR_MISCCR1_FORSRST	0x40

/*
 * RX config bits.
 */
#define VR_RXCFG_RX_ERRPKTS	0x01
#define VR_RXCFG_RX_RUNT	0x02
#define VR_RXCFG_RX_MULTI	0x04
#define VR_RXCFG_RX_BROAD	0x08
#define VR_RXCFG_RX_PROMISC	0x10
#define VR_RXCFG_RX_THRESH	0xE0

#define VR_RXTHRESH_32BYTES	0x00
#define VR_RXTHRESH_64BYTES	0x20
#define VR_RXTHRESH_128BYTES	0x40
#define VR_RXTHRESH_256BYTES	0x60
#define VR_RXTHRESH_512BYTES	0x80
#define VR_RXTHRESH_768BYTES	0xA0
#define VR_RXTHRESH_1024BYTES	0xC0
#define VR_RXTHRESH_STORENFWD	0xE0

/*
 * TX config bits.
 */
#define VR_TXCFG_TXTAGEN	0x01	/* 6105M */
#define VR_TXCFG_LOOPBKMODE	0x06
#define VR_TXCFG_BACKOFF	0x08
#define VR_TXCFG_TX_THRESH	0xE0

#define VR_TXTHRESH_32BYTES	0x00
#define VR_TXTHRESH_64BYTES	0x20
#define VR_TXTHRESH_128BYTES	0x40
#define VR_TXTHRESH_256BYTES	0x60
#define VR_TXTHRESH_512BYTES	0x80
#define VR_TXTHRESH_768BYTES	0xA0
#define VR_TXTHRESH_1024BYTES	0xC0
#define VR_TXTHRESH_STORENFWD	0xE0

/*
 * Command register bits.
 */
#define VR_CMD_INIT		0x0001
#define VR_CMD_START		0x0002
#define VR_CMD_STOP		0x0004
#define VR_CMD_RX_ON		0x0008
#define VR_CMD_TX_ON		0x0010
#define	VR_CMD_TX_GO		0x0020
#define VR_CMD_RX_GO		0x0040
#define VR_CMD_RSVD		0x0080
#define VR_CMD_RX_EARLY		0x0100
#define VR_CMD_TX_EARLY		0x0200
#define VR_CMD_FULLDUPLEX	0x0400
#define VR_CMD_TX_NOPOLL	0x0800

#define VR_CMD_RESET		0x8000

/*
 * Interrupt status bits.
 */
#define VR_ISR_RX_OK		0x0001	/* packet rx ok */
#define VR_ISR_TX_OK		0x0002	/* packet tx ok */
#define VR_ISR_RX_ERR		0x0004	/* packet rx with err */
#define VR_ISR_TX_ABRT		0x0008	/* tx aborted due to excess colls */
#define VR_ISR_TX_UNDERRUN	0x0010	/* tx buffer underflow */
#define VR_ISR_RX_NOBUF		0x0020	/* no rx buffer available */
#define VR_ISR_BUSERR		0x0040	/* PCI bus error */
#define VR_ISR_STATSOFLOW	0x0080	/* stats counter oflow */
#define VR_ISR_RX_EARLY		0x0100	/* rx early */
#define VR_ISR_LINKSTAT		0x0200	/* MII status change */
#define VR_ISR_ETI		0x0200	/* Tx early (3043/3071) */
#define VR_ISR_UDFI		0x0200	/* Tx FIFO underflow (3065) */
#define VR_ISR_RX_OFLOW		0x0400	/* rx FIFO overflow */
#define VR_ISR_RX_DROPPED	0x0800
#define VR_ISR_RX_NOBUF2	0x1000
#define VR_ISR_TX_ABRT2		0x2000
#define VR_ISR_LINKSTAT2	0x4000
#define VR_ISR_MAGICPACKET	0x8000

/*
 * Interrupt mask bits.
 */
#define VR_IMR_RX_OK		0x0001	/* packet rx ok */
#define VR_IMR_TX_OK		0x0002	/* packet tx ok */
#define VR_IMR_RX_ERR		0x0004	/* packet rx with err */
#define VR_IMR_TX_ABRT		0x0008	/* tx aborted due to excess colls */
#define VR_IMR_TX_UNDERRUN	0x0010	/* tx buffer underflow */
#define VR_IMR_RX_NOBUF		0x0020	/* no rx buffer available */
#define VR_IMR_BUSERR		0x0040	/* PCI bus error */
#define VR_IMR_STATSOFLOW	0x0080	/* stats counter oflow */
#define VR_IMR_RX_EARLY		0x0100	/* rx early */
#define VR_IMR_LINKSTAT		0x0200	/* MII status change */
#define VR_IMR_RX_OFLOW		0x0400	/* rx FIFO overflow */
#define VR_IMR_RX_DROPPED	0x0800
#define VR_IMR_RX_NOBUF2	0x1000
#define VR_IMR_TX_ABRT2		0x2000
#define VR_IMR_LINKSTAT2	0x4000
#define VR_IMR_MAGICPACKET	0x8000

#define VR_INTRS							\
	(VR_IMR_RX_OK|VR_IMR_TX_OK|VR_IMR_RX_NOBUF|			\
	VR_IMR_TX_ABRT|VR_IMR_TX_UNDERRUN|VR_IMR_BUSERR|		\
	VR_IMR_RX_ERR|VR_ISR_RX_DROPPED)

/*
 * MII status register.
 */

#define VR_MIISTAT_SPEED	0x01
#define VR_MIISTAT_LINKFAULT	0x02
#define VR_MIISTAT_MGTREADERR	0x04
#define VR_MIISTAT_MIIERR	0x08
#define VR_MIISTAT_PHYOPT	0x10
#define VR_MIISTAT_MDC_SPEED	0x20
#define VR_MIISTAT_RSVD		0x40
#define VR_MIISTAT_GPIO1POLL	0x80

/*
 * MII command register bits.
 */
#define VR_MIICMD_CLK		0x01
#define VR_MIICMD_DATAOUT	0x02
#define VR_MIICMD_DATAIN	0x04
#define VR_MIICMD_DIR		0x08
#define VR_MIICMD_DIRECTPGM	0x10
#define VR_MIICMD_WRITE_ENB	0x20
#define VR_MIICMD_READ_ENB	0x40
#define VR_MIICMD_AUTOPOLL	0x80

/*
 * EEPROM control bits.
 */
#define VR_EECSR_DATAIN		0x01	/* data out */
#define VR_EECSR_DATAOUT	0x02	/* data in */
#define VR_EECSR_CLK		0x04	/* clock */
#define VR_EECSR_CS		0x08	/* chip select */
#define VR_EECSR_DPM		0x10
#define VR_EECSR_LOAD		0x20
#define VR_EECSR_EMBP		0x40
#define VR_EECSR_EEPR		0x80

#define VR_EECMD_WRITE		0x140
#define VR_EECMD_READ		0x180
#define VR_EECMD_ERASE		0x1c0

/*
 * Test register bits.
 */
#define VR_TEST_TEST0		0x01
#define VR_TEST_TEST1		0x02
#define VR_TEST_TEST2		0x04
#define VR_TEST_TSTUD		0x08
#define VR_TEST_TSTOV		0x10
#define VR_TEST_BKOFF		0x20
#define VR_TEST_FCOL		0x40
#define VR_TEST_HBDES		0x80

/*
 * Config register bits.
 */
#define VR_CFG_PREACPIWAKE	0x00000001	/* pre-acpi wake */
#define VR_CFG_ABNORMALWAKE	0x00000002	/* abnormal shut down wake */
#define VR_CFG_RSVD0		0x00000004
#define VR_CFG_LED0		0x00000008
#define VR_CFG_LED1		0x00000010
#define VR_CFG_TAGCRC		0x00000020	/* 6105M tag in CRC */
#define VR_CFG_MIIOPT		0x00000040	/* MII extension clock */
#define VR_CFG_EELOAD		0x00000080	/* enable EEPROM programming */
#define VR_CFG_LATMENB		0x00000100	/* larency timer effect enb. */
#define VR_CFG_MRREADWAIT	0x00000200
#define VR_CFG_MRWRITEWAIT	0x00000400
#define VR_CFG_RX_ARB		0x00000800
#define VR_CFG_TX_ARB		0x00001000
#define VR_CFG_READMULTI	0x00002000
#define VR_CFG_TX_PACE		0x00004000
#define VR_CFG_TX_QDIS		0x00008000
#define VR_CFG_ROMSEL0		0x00010000
#define VR_CFG_ROMSEL1		0x00020000
#define VR_CFG_ROMSEL2		0x00040000
#define VR_CFG_ROMTIMESEL	0x00080000
#define VR_CFG_RSVD1		0x00100000
#define VR_CFG_ROMDLY		0x00200000
#define VR_CFG_ROMOPT		0x00400000
#define VR_CFG_RSVD2		0x00800000
#define VR_CFG_BACKOFFOPT	0x01000000
#define VR_CFG_BACKOFFMOD	0x02000000
#define VR_CFG_CAPEFFECT	0x04000000
#define VR_CFG_BACKOFFRAND	0x08000000
#define VR_CFG_MAGICKPACKET	0x10000000
#define VR_CFG_PCIREADLINE	0x20000000
#define VR_CFG_DIAG		0x40000000
#define VR_CFG_GPIOEN		0x80000000

/* Sticky HW bits */
#define VR_STICKHW_DS0		0x01
#define VR_STICKHW_DS1		0x02
#define VR_STICKHW_WOL_ENB	0x04
#define VR_STICKHW_WOL_STS	0x08
#define VR_STICKHW_LEGWOL_ENB	0x80

/* Wake on Lan */
#define VR_WOLCRSET		0xA0
#define VR_PWRCFGSET		0xA1
#define VR_WOLCFGSET		0xA3
#define VR_WOLCRCLR		0xA4
#define VR_PWRCFGCLR		0xA5
#define VR_WOLCFGCLR		0xA7
#define VR_PWRCSRSET		0xA8
#define VR_PWRCSRCLR		0xAC
#define VR_WOLCR_UCAST		0x10
#define VR_WOLCR_MAGIC		0x20
#define VR_WOLCR_LINKON		0x40
#define VR_WOLCR_LINKOFF	0x80
#define VR_WOLCFG_PMEOVR	0x80

/*
 * BCR0 register bits. (At least for the VT6102 chip.)
 */
#define VR_BCR0_DMA_LENGTH      0x07

#define VR_BCR0_DMA_32BYTES     0x00
#define VR_BCR0_DMA_64BYTES     0x01
#define VR_BCR0_DMA_128BYTES    0x02
#define VR_BCR0_DMA_256BYTES    0x03
#define VR_BCR0_DMA_512BYTES    0x04
#define VR_BCR0_DMA_1024BYTES   0x05
#define VR_BCR0_DMA_STORENFWD   0x07
 
#define VR_BCR0_RX_THRESH       0x38

#define VR_BCR0_RXTHRESHCFG     0x00
#define VR_BCR0_RXTHRESH64BYTES 0x08
#define VR_BCR0_RXTHRESH128BYTES 0x10
#define VR_BCR0_RXTHRESH256BYTES 0x18
#define VR_BCR0_RXTHRESH512BYTES 0x20
#define VR_BCR0_RXTHRESH1024BYTES 0x28
#define VR_BCR0_RXTHRESHSTORENFWD 0x38
#define VR_BCR0_EXTLED          0x40
#define VR_BCR0_MED2            0x80

/*
 * BCR1 register bits. (At least for the VT6102 chip.)
 */
#define VR_BCR1_POT0            0x01
#define VR_BCR1_POT1            0x02
#define VR_BCR1_POT2            0x04
#define VR_BCR1_TX_THRESH       0x38
#define VR_BCR1_TXTHRESHCFG     0x00
#define VR_BCR1_TXTHRESH64BYTES 0x08
#define VR_BCR1_TXTHRESH128BYTES 0x10
#define VR_BCR1_TXTHRESH256BYTES 0x18
#define VR_BCR1_TXTHRESH512BYTES 0x20
#define VR_BCR1_TXTHRESH1024BYTES 0x28
#define VR_BCR1_TXTHRESHSTORENFWD 0x38
#define VR_BCR1_VLANFILT_ENB	0x80		/* 6105M */

/*
 * CAM Control registers (VT6105M)
 */
#define VR_CAMCTRL_WREN		0x01
#define VR_CAMCTRL_VCAMSEL	0x02
#define VR_CAMCTRL_WRITE	0x04
#define VR_CAMCTRL_READ		0x08

/*
 * Rhine TX/RX list structure.
 */

struct vr_desc {
	u_int32_t		vr_status;
	u_int32_t		vr_ctl;
	u_int32_t		vr_data;
	u_int32_t		vr_next;
};

#define VR_RXSTAT_RXERR		0x00000001
#define VR_RXSTAT_CRCERR	0x00000002
#define VR_RXSTAT_FRAMEALIGNERR	0x00000004
#define VR_RXSTAT_FIFOOFLOW	0x00000008
#define VR_RXSTAT_GIANT		0x00000010
#define VR_RXSTAT_RUNT		0x00000020
#define VR_RXSTAT_BUSERR	0x00000040
#define VR_RXSTAT_FRAG		0x00000040	/* 6105M */
#define VR_RXSTAT_BUFFERR	0x00000080
#define VR_RXSTAT_LASTFRAG	0x00000100
#define VR_RXSTAT_FIRSTFRAG	0x00000200
#define VR_RXSTAT_RLINK		0x00000400
#define VR_RXSTAT_RX_PHYS	0x00000800
#define VR_RXSTAT_RX_BROAD	0x00001000
#define VR_RXSTAT_RX_MULTI	0x00002000
#define VR_RXSTAT_RX_VIDHIT	0x00004000	/* 6105M */
#define VR_RXSTAT_RX_OK		0x00008000
#define VR_RXSTAT_RXLEN		0x07FF0000
#define VR_RXSTAT_RXLEN_EXT	0x78000000
#define VR_RXSTAT_OWN		0x80000000

#define VR_RXBYTES(x)		((x & VR_RXSTAT_RXLEN) >> 16)
#define VR_RXSTAT (VR_RXSTAT_FIRSTFRAG|VR_RXSTAT_LASTFRAG|VR_RXSTAT_OWN)

#define VR_RXCTL_BUFLEN		0x000007FF
#define VR_RXCTL_BUFLEN_EXT	0x00007800
#define VR_RXCTL_CHAIN		0x00008000
#define VR_RXCTL_TAG		0x00010000
#define VR_RXCTL_UDP		0x00020000
#define VR_RXCTL_TCP		0x00040000
#define VR_RXCTL_IP		0x00080000
#define VR_RXCTL_TCPUDPOK	0x00100000
#define VR_RXCTL_IPOK		0x00200000
#define VR_RXCTL_SNAPTAG	0x00400000
#define VR_RXCTL_RXLERR		0x00800000	/* 6105M */
#define VR_RXCTL_RX_INTR	0x00800000

#define VR_RXCTL (VR_RXCTL_CHAIN|VR_RXCTL_RX_INTR)

#define VR_TXSTAT_DEFER		0x00000001
#define VR_TXSTAT_UNDERRUN	0x00000002
#define VR_TXSTAT_COLLCNT	0x00000078
#define VR_TXSTAT_SQE		0x00000080
#define VR_TXSTAT_ABRT		0x00000100
#define VR_TXSTAT_LATECOLL	0x00000200
#define VR_TXSTAT_CARRLOST	0x00000400
#define VR_TXSTAT_UDF		0x00000800
#define VR_TXSTAT_BUSERR	0x00002000
#define VR_TXSTAT_JABTIMEO	0x00004000
#define VR_TXSTAT_ERRSUM	0x00008000
/*
 * Note there are only 15 bits total.
 * The drop eligible indicator is left out.
 * VLAN ID at the lower 12 bits 0x0FFF;
 * priority code point at the upper 3 bits 0x7000.
 */
#define VR_TXSTAT_PQMASK	0x7FFF0000
#define VR_TXSTAT_OWN		0x80000000
#define VR_TXSTAT_PQSHIFT	16

#define VR_TXCTL_BUFLEN		0x000007FF
#define VR_TXCTL_BUFLEN_EXT	0x00007800
#define VR_TXCTL_TLINK		0x00008000
#define VR_TXCTL_NOCRC		0x00010000
#define VR_TXCTL_INSERTTAG	0x00020000
#define VR_TXCTL_IPCSUM		0x00040000
#define VR_TXCTL_UDPCSUM	0x00080000
#define VR_TXCTL_TCPCSUM	0x00100000
#define VR_TXCTL_FIRSTFRAG	0x00200000
#define VR_TXCTL_LASTFRAG	0x00400000
#define VR_TXCTL_FINT		0x00800000

/* TDES3 aka vr_next */
#define VR_TXNEXT_INTDISABLE	0x00000001

#define VR_MAXFRAGS		8
#define VR_RX_LIST_CNT		128
#define VR_TX_LIST_CNT		128
#define VR_MIN_FRAMELEN		60
#define VR_RXLEN		1524
/* determined experimentally; seems intermittent with higher values */
#define VR_RXLEN_BABYJUMBO	1758
#define VR_TX_INTR_THRESH	8

struct vr_list_data {
	struct vr_desc		vr_rx_list[VR_RX_LIST_CNT];
	struct vr_desc		vr_tx_list[VR_TX_LIST_CNT];
};

struct vr_chain {
	struct vr_desc		*vr_ptr;
	struct mbuf		*vr_mbuf;
	struct vr_chain		*vr_nextdesc;
	bus_addr_t		vr_paddr;
	bus_dmamap_t		vr_map;
};

struct vr_chain_onefrag {
	struct vr_desc		*vr_ptr;
	struct vr_chain_onefrag	*vr_nextdesc;
	struct mbuf 		*vr_mbuf;
	bus_addr_t		vr_paddr;
	bus_dmamap_t		vr_map;
};

struct vr_chain_data {
	struct vr_chain_onefrag	vr_rx_chain[VR_RX_LIST_CNT];
	struct vr_chain		vr_tx_chain[VR_TX_LIST_CNT];

	struct vr_chain_onefrag	*vr_rx_cons;
	struct vr_chain_onefrag	*vr_rx_prod;

	struct vr_chain		*vr_tx_cons;
	struct vr_chain		*vr_tx_prod;
	int			vr_tx_cnt;
	unsigned int		vr_tx_pkts;
};

struct vr_mii_frame {
	u_int8_t		mii_stdelim;
	u_int8_t		mii_opcode;
	u_int8_t		mii_phyaddr;
	u_int8_t		mii_regaddr;
	u_int8_t		mii_turnaround;
	u_int16_t		mii_data;
};

/*
 * MII constants
 */
#define VR_MII_STARTDELIM	0x01
#define VR_MII_READOP		0x02
#define VR_MII_WRITEOP		0x01
#define VR_MII_TURNAROUND	0x02

#define VR_FLAG_FORCEDELAY	1
#define VR_FLAG_SCHEDDELAY	2
#define VR_FLAG_DELAYTIMEO	3	

struct vr_dmamem {
	bus_dmamap_t		vrm_map;
	bus_dma_segment_t	vrm_seg;
	int			vrm_nsegs;
	size_t			vrm_size;
	caddr_t			vrm_kva;
};

struct vr_softc {
	struct device		sc_dev;		/* generic device structure */
	pci_chipset_tag_t	sc_pc;		/* PCI registers info */
	pcitag_t		sc_tag;
	void *			sc_ih;		/* interrupt handler cookie */
	struct arpcom		arpcom;		/* interface info */
	bus_space_handle_t	vr_bhandle;	/* bus space handle */
	bus_space_tag_t		vr_btag;	/* bus space tag */
	bus_dma_tag_t		sc_dmat;
	struct vr_type		*vr_info;	/* Rhine adapter info */
	u_int8_t		vr_revid;	/* Rhine chip revision */
	u_int8_t		vr_flags;	/* See VR_F_* below */
	struct vr_list_data	*vr_ldata;
	struct vr_chain_data	vr_cdata;
	struct mii_data		sc_mii;
	struct timeout		sc_to;
	struct timeout		sc_rxto;
	struct vr_dmamem	sc_listmap;	/* descriptor list map */
	struct vr_dmamem	sc_zeromap;	/* zero pad map */
	struct if_rxring	sc_rxring;
	int			sc_rxbufs;
	int			vr_link;
	int			vr_quirks;
};

#define VR_F_RESTART		0x01		/* Restart unit on next tick */

/*
 * register space access macros
 */
#define CSR_WRITE_4(sc, reg, val)	\
	bus_space_write_4(sc->vr_btag, sc->vr_bhandle, reg, val)
#define CSR_WRITE_2(sc, reg, val)	\
	bus_space_write_2(sc->vr_btag, sc->vr_bhandle, reg, val)
#define CSR_WRITE_1(sc, reg, val)	\
	bus_space_write_1(sc->vr_btag, sc->vr_bhandle, reg, val)

#define CSR_READ_4(sc, reg)		\
	bus_space_read_4(sc->vr_btag, sc->vr_bhandle, reg)
#define CSR_READ_2(sc, reg)		\
	bus_space_read_2(sc->vr_btag, sc->vr_bhandle, reg)
#define CSR_READ_1(sc, reg)		\
	bus_space_read_1(sc->vr_btag, sc->vr_bhandle, reg)

#define VR_TIMEOUT		1000

/*
 * VIA Rhine revision IDs
 */

#define REV_ID_VT3043_E			0x04
#define REV_ID_VT3071_A			0x20
#define REV_ID_VT3071_B			0x21
#define REV_ID_VT3065_A			0x40
#define REV_ID_VT3065_B			0x41
#define REV_ID_VT3065_C			0x42
#define REV_ID_VT6102_APOLLO		0x74
#define REV_ID_VT6103			0x78
#define REV_ID_VT3106			0x80
#define REV_ID_VT3106_J			0x80	/* 0x80-0x8F */
#define REV_ID_VT3106_S			0x90	/* 0x90-0xA0 */
#define REV_ID_VT6105M_A0		0x90
#define REV_ID_VT6105M_B1		0x94

/*
 * PCI low memory base and low I/O base register, and
 * other PCI registers.
 */

#define VR_PCI_VENDOR_ID	0x00
#define VR_PCI_DEVICE_ID	0x02
#define VR_PCI_COMMAND		0x04
#define VR_PCI_STATUS		0x06
#define VR_PCI_REVID		0x08
#define VR_PCI_CLASSCODE	0x09
#define VR_PCI_LATENCY_TIMER	0x0D
#define VR_PCI_HEADER_TYPE	0x0E
#define VR_PCI_LOIO		0x10
#define VR_PCI_LOMEM		0x14
#define VR_PCI_BIOSROM		0x30
#define VR_PCI_INTLINE		0x3C
#define VR_PCI_INTPIN		0x3D
#define VR_PCI_MINGNT		0x3E
#define VR_PCI_MINLAT		0x0F
#define VR_PCI_RESETOPT		0x48
#define VR_PCI_EEPROM_DATA	0x4C
#define VR_PCI_MODE		0x50

#define VR_MODE3_MIION		0x04

/* power management registers */
#define VR_PCI_CAPID		0xDC /* 8 bits */
#define VR_PCI_NEXTPTR		0xDD /* 8 bits */
#define VR_PCI_PWRMGMTCAP	0xDE /* 16 bits */
#define VR_PCI_PWRMGMTCTRL	0xE0 /* 16 bits */

#define VR_PME_EN		0x0010
#define VR_PME_STATUS		0x8000
@


1.36
log
@cut things that relied on mclgeti for rx ring accounting/restriction over
to using if_rxr.

cut the reporting systat did over to the rxr ioctl.

tested as much as i can on alpha, amd64, and sparc64.
mpi@@ has run it on macppc.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.35 2013/02/09 19:17:52 sthen Exp $	*/
d416 6
@


1.35
log
@Programme the VT6105M, VT6105 and RhineII-2 to permit frames of up to
1758 bytes (MTU 1740) and raise hardmtu to allow the user to set them.
Tests by Mark Patruck, Michal Markowski, mikeb, beck, dtucker. ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.34 2013/01/28 02:57:02 dtucker Exp $	*/
a470 1
	int			 vr_rx_cnt;
d526 1
@


1.34
log
@Add TX interrupt mitigation for vr(4) chips, loosely based on FreeBSD,
but with tweaks so it works on 6105Ms like those found in pcengines alix
and soekris 5501s.  ok sthen@@, help brad chris mikeb dlg jsing

There may be other 610x chips that would benefit from the VR_Q_INTDISABLE
quirk, please send me a dmesg if you can confirm it works.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.33 2013/01/16 05:25:57 dtucker Exp $	*/
d440 2
@


1.33
log
@Add hardware VLAN tag/untag support for VT6105M chips.  Help/feedback/ok
brad@@ chris@@ jsing@@ kettenis@@ mikeb@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.32 2012/10/20 16:12:22 chris Exp $	*/
d432 3
d440 1
d474 1
@


1.32
log
@Implement transmit DMA segments. The descriptor usage is from FreeBSD,
which contradicts the datasheet (but actually works).

Also, use a segment (instead of a new mbuf and data copy) to zero-pad
small packets, modeled after if_myx.

ok sthen@@, gerhard@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.31 2012/10/18 21:44:21 deraadt Exp $	*/
d86 3
d348 8
d418 1
@


1.31
log
@Convert a number of old private copies of code which predates
pci_set_powerstate() to using it instead.  Many of these chunks of code had
bugs in them, especially missing delay() calls.  Some of them were doing
things our PCI subsystem is now responsible for handling.  If you have
any of the affected devices, please keep an eye out for regressions.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.30 2012/01/05 19:08:25 deraadt Exp $	*/
d420 2
a421 2
#define VR_MAXFRAGS		16
#define VR_RX_LIST_CNT		64
a425 2
#define VR_TXOWN(x)		x->vr_ptr->vr_status

d457 1
d481 8
d506 2
a507 2
	bus_dmamap_t		sc_listmap;	/* descriptor list map */
	bus_dma_segment_t	sc_listseg;
@


1.30
log
@suspend/resume support for vr(4); from brynet@@gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.29 2011/12/08 20:19:24 markus Exp $	*/
a576 5
#define VR_PSTATE_MASK		0x0003
#define VR_PSTATE_D0		0x0000
#define VR_PSTATE_D1		0x0002
#define VR_PSTATE_D2		0x0002
#define VR_PSTATE_D3		0x0003
@


1.29
log
@add timeout to fill rx-ring in case of mbuf shortage while in vr_intr();
fixes hanging interfaces similar to in myx(4); ok dlg@@, claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.28 2011/03/13 15:38:50 stsp Exp $	*/
d484 2
@


1.28
log
@Wake On LAN support for vr(4).
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.27 2009/06/18 17:48:15 claudio Exp $	*/
d496 1
@


1.27
log
@MCLGETI support for vr(4) interfaces. This will make the newer soekris and
Alix boards suck a little bit less because it will be harder to live lock them
with traffic. Diff mostly adapted from sis(4).
OK kettenis@@, dlg@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.26 2009/05/12 13:30:56 sthen Exp $	*/
d287 15
@


1.26
log
@cleanup and simplify promiscuous/multicast setup (setmulti -> iff).
from Brad; ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.25 2009/05/11 07:41:52 sthen Exp $	*/
d438 3
a440 1
	struct vr_chain_onefrag	*vr_rx_head;
@


1.25
log
@remove local copy of vendor id/device id, there's nothing wrong with
the data from pcidevs.  suggested by chris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.24 2009/05/10 12:23:56 sthen Exp $	*/
a480 1
	int			sc_if_flags;
@


1.24
log
@Remove config register gpio definitions for older chips, gpio mii
access disappeared years ago and replace them with config register
definitions for newer chips. From chris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.23 2009/05/10 12:09:46 sthen Exp $	*/
a506 37

/*
 * General constants that are fun to know.
 *
 * VIA vendor ID
 */
#define	VIA_VENDORID			0x1106

/*
 * VIA Rhine device IDs.
 */
#define	VIA_DEVICEID_RHINE		0x3043
#define VIA_DEVICEID_RHINE_II		0x6100
#define VIA_DEVICEID_RHINE_II_2		0x3065
#define VIA_DEVICEID_RHINE_III		0x3106
#define VIA_DEVICEID_RHINE_III_M	0x3053

/*
 * Delta Electronics device ID.
 */
#define DELTA_VENDORID			0x1500

/*
 * Delta device IDs.
 */
#define DELTA_DEVICEID_RHINE_II		0x1320

/*
 * Addtron vendor ID.
 */
#define ADDTRON_VENDORID		0x4033

/*
 * Addtron device IDs.
 */
#define ADDTRON_DEVICEID_RHINE_II	0x1320

@


1.23
log
@- change device matching to use a quirks table.

- avoid the need for unnecessary mbuf copies on modern vr(4) devices
(ancient ones required longword-alignment, but this has not been the case
for several generations now). reduces cpu time, particularly for forwarded
traffic.

from chris@@. tested by chris@@, myself, Emilio Perea on various devices
including original VIA EPIA, Soekris net5501, pcengines.ch ALIX.

ok mpf. deraadt and dlg agree with committing at this stage.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.22 2009/04/28 12:54:31 mpf Exp $	*/
d46 1
d113 1
a113 1
#define VR_TXCFG_RSVD0		0x01
a115 1
#define VR_TXCFG_RSVD1		0x10
d248 7
a254 7
#define VR_CFG_GPIO2OUTENB	0x00000001
#define VR_CFG_GPIO2OUT		0x00000002	/* gen. purp. pin */
#define VR_CFG_GPIO2IN		0x00000004	/* gen. purp. pin */
#define VR_CFG_AUTOOPT		0x00000008	/* enable rx/tx autopoll */
#define VR_CFG_MIIOPT		0x00000010
#define VR_CFG_MMIENB		0x00000020	/* memory mapped mode enb */
#define VR_CFG_JUMPER		0x00000040	/* PHY and oper. mode select */
d268 1
a268 1
#define VR_CFG_RSVD0		0x00100000
d271 1
a271 1
#define VR_CFG_RSVD1		0x00800000
d327 1
d347 1
d355 1
a355 1
#define VR_RXSTAT_RX_VIDHIT	0x00004000 /* 6105M */
d367 8
d390 1
d396 5
d560 2
@


1.22
log
@The TX engine can get stuck if the interface went through a link
state change. Workaround by resetting the chip if necessary.
Also do not try to send packets if our link is down, as this triggers
watchdog timeouts.  While there correct the VR_RXSTAT_RX_OK define
(not used yet).  Changes inspired from FreeBSDs overhauled vr(4).
Testing, input and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.21 2008/07/18 13:38:40 thib Exp $	*/
a427 6
struct vr_type {
	u_int16_t		vr_vid;
	u_int16_t		vr_did;
	char			*vr_name;
};

d468 1
@


1.21
log
@o Use mbufs, for the RX ring, instead of malloc()'ing an MCLBYTES sized buffer.
o On non-strict alignment archs, dont copy the mbuf, every time, unload it, and send
  it up the stack and just get a new one for the rx ring. We still do the copy on
  strict alignment archs though...
o create a function to handle mbuf allocation for the rx ring, vr_mbuf_alloc(),
  use it to allocate the mbufs and shuffle the bus dma setup around.

ideas/code from vic(4) and sis(4);

ok reyk@@, brad@@, dlg@@
tested by many, been in snapshots for a while.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.20 2007/10/04 01:29:39 brad Exp $	*/
d353 2
a354 1
#define VR_RXSTAT_RX_OK		0x00004000
d473 1
@


1.20
log
@g/c ETHER_CRC_LEN.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.19 2007/10/04 00:15:28 brad Exp $	*/
d412 1
a412 1
	u_int8_t		*vr_buf;
d471 1
@


1.19
log
@Remove renaming of fields with #define.

Tested by jmc@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.18 2007/09/01 10:26:25 mglocker Exp $	*/
a585 4

#ifndef ETHER_CRC_LEN
#define ETHER_CRC_LEN 4
#endif
@


1.18
log
@Add VLAN reception support to vr(4).  Diff from Brad.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.17 2006/02/05 18:23:37 brad Exp $	*/
d335 2
a336 2
	u_int32_t		vr_ptr1;
	u_int32_t		vr_ptr2;
a337 4

#define vr_data		vr_ptr1
#define vr_next		vr_ptr2

@


1.17
log
@call vr_setmulti() if adjusting PROMISC or ALLMULTI and do not do a full
re-init if configuring the IP address.

tested by Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.16 2005/12/07 22:48:39 brad Exp $	*/
d396 1
a396 1
#define VR_RXLEN		1520
@


1.16
log
@this should fix the VT6103.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.15 2005/07/06 02:22:28 brad Exp $	*/
d474 1
@


1.15
log
@- Rewritten TX to use only two pointers to track producer/consumer.
- Bugfix: don't forget to set IFF_OACTIVE when TX list is full.

From FreeBSD

- clear IFF_RUNNING & IFF_OACTIVE in vr_stop() before de-allocating resources.

Thanks to cloder@@, millert@@ and pedro@@ for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.14 2005/05/27 00:18:59 pvalchev Exp $	*/
d545 1
@


1.14
log
@kill another forgotten vtophys since bus_dma conversion
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.13 2004/09/28 04:37:33 brad Exp $	*/
d427 2
a428 3
	struct vr_chain		*vr_tx_head;
	struct vr_chain		*vr_tx_tail;
	struct vr_chain		*vr_tx_free;
@


1.13
log
@Use ETHER_MAX_DIX_LEN/ETHER_MIN_LEN
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.12 2004/05/19 11:37:00 brad Exp $	*/
a591 5
#endif

#ifdef __alpha__
#undef vtophys
#define vtophys(va)		alpha_XXX_dmamap((vm_offset_t)va)
@


1.12
log
@remove duplication, use ETHER_ALIGN from if_ether.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.11 2003/10/12 02:53:59 jason Exp $	*/
a395 1
#define VR_FRAMELEN		1536
@


1.11
log
@only one vtophys left (tx data)... both the rx and tx descriptors are
fully handled by bus_dma now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.10 2003/10/12 02:35:53 jason Exp $	*/
a497 1
#define ETHER_ALIGN		2
@


1.10
log
@rework rx to use bus_dma and sprinkle with a small amount of htole32.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.9 2003/10/10 19:02:24 jason Exp $	*/
d410 1
d418 1
@


1.9
log
@unsmoke drugs in vr_encap() (simplify it quite alot)
prepare for bus_dma of tx data
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.8 2003/10/10 18:05:12 jason Exp $	*/
a414 1
	struct mbuf		*vr_mbuf;
d416 2
@


1.8
log
@don't use vtophys on rx lists any more
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.7 2003/02/19 14:38:23 miod Exp $	*/
d410 1
@


1.7
log
@Sync if_vr code with FreeBSD. This makes the driver much better when it comes
to trying to recover the hardware going nuts under the load.

Reported to work by various people including krw@@and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.6 2003/02/09 10:53:24 jason Exp $	*/
d470 2
@


1.6
log
@Must set BCR0/BCR1 since they can override the RXCFG/TXCFG registers; from freebsd via openbsd pr 3086 (thom at press dot alt-f4 dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.5 2001/05/16 13:41:27 aaron Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_vrreg.h,v 1.10 2001/02/09 06:11:21 bmilekic Exp $
d86 4
d158 2
d379 1
d464 2
d472 2
d507 2
d532 15
d555 1
d568 3
@


1.5
log
@Bring chip out of suspend mode in case we're booting after a shutdown from
Windows. Needed for the VT6102, but doesn't hurt older chips; from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.4 2001/02/20 19:12:48 jason Exp $	*/
d281 40
@


1.5.4.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_vrreg.h,v 1.17 2003/02/01 01:27:05 silby Exp $
a85 4
/* Misc Registers */
#define VR_MISC_CR1		0x81
#define VR_MISCCR1_FORSRST	0x40

a153 2
#define VR_ISR_ETI		0x0200	/* Tx early (3043/3071) */
#define VR_ISR_UDFI		0x0200	/* Tx FIFO underflow (3065) */
a282 40
 * BCR0 register bits. (At least for the VT6102 chip.)
 */
#define VR_BCR0_DMA_LENGTH      0x07

#define VR_BCR0_DMA_32BYTES     0x00
#define VR_BCR0_DMA_64BYTES     0x01
#define VR_BCR0_DMA_128BYTES    0x02
#define VR_BCR0_DMA_256BYTES    0x03
#define VR_BCR0_DMA_512BYTES    0x04
#define VR_BCR0_DMA_1024BYTES   0x05
#define VR_BCR0_DMA_STORENFWD   0x07
 
#define VR_BCR0_RX_THRESH       0x38

#define VR_BCR0_RXTHRESHCFG     0x00
#define VR_BCR0_RXTHRESH64BYTES 0x08
#define VR_BCR0_RXTHRESH128BYTES 0x10
#define VR_BCR0_RXTHRESH256BYTES 0x18
#define VR_BCR0_RXTHRESH512BYTES 0x20
#define VR_BCR0_RXTHRESH1024BYTES 0x28
#define VR_BCR0_RXTHRESHSTORENFWD 0x38
#define VR_BCR0_EXTLED          0x40
#define VR_BCR0_MED2            0x80

/*
 * BCR1 register bits. (At least for the VT6102 chip.)
 */
#define VR_BCR1_POT0            0x01
#define VR_BCR1_POT1            0x02
#define VR_BCR1_POT2            0x04
#define VR_BCR1_TX_THRESH       0x38
#define VR_BCR1_TXTHRESHCFG     0x00
#define VR_BCR1_TXTHRESH64BYTES 0x08
#define VR_BCR1_TXTHRESH128BYTES 0x10
#define VR_BCR1_TXTHRESH256BYTES 0x18
#define VR_BCR1_TXTHRESH512BYTES 0x20
#define VR_BCR1_TXTHRESH1024BYTES 0x28
#define VR_BCR1_TXTHRESHSTORENFWD 0x38

/*
a332 1
#define VR_TXSTAT_UDF		0x00000800
a416 2
	u_int8_t		vr_revid;	/* Rhine chip revision */
	u_int8_t		vr_flags;	/* See VR_F_* below */
a422 2
#define VR_F_RESTART		0x01		/* Restart unit on next tick */

a455 2
#define VIA_DEVICEID_RHINE_III		0x3106
#define VIA_DEVICEID_RHINE_III_M	0x3053
a478 15
 * VIA Rhine revision IDs
 */

#define REV_ID_VT3043_E			0x04
#define REV_ID_VT3071_A			0x20
#define REV_ID_VT3071_B			0x21
#define REV_ID_VT3065_A			0x40
#define REV_ID_VT3065_B			0x41
#define REV_ID_VT3065_C			0x42
#define REV_ID_VT6102_APOLLO		0x74
#define REV_ID_VT3106			0x80
#define REV_ID_VT3106_J			0x80	/* 0x80-0x8F */
#define REV_ID_VT3106_S			0x90	/* 0x90-0xA0 */

/*
a486 1
#define VR_PCI_REVID		0x08
a498 3
#define VR_PCI_MODE		0x50

#define VR_MODE3_MIION		0x04
@


1.4
log
@add mii support to if_vr (mostly from FreeBSD)
also sync with other FreeBSD changes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.3 2001/02/17 07:35:36 jason Exp $	*/
d84 1
d274 7
@


1.3
log
@sync with freebsd up to switch to mii
also increase the delay for accessing the eeprom (seems it needs a bit
longer to get ether address settled).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.2 1999/01/30 23:15:37 niklas Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_vrreg.h,v 1.6 1999/08/28 00:50:59 peter Exp $
a404 1
	struct ifmedia		ifmedia;	/* media info */
d407 1
a408 6
	struct vr_type		*vr_pinfo;	/* phy info */
	u_int8_t		vr_phy_addr;	/* PHY address */
	u_int8_t		vr_tx_pend;	/* TX pending */
	u_int8_t		vr_want_auto;
	u_int8_t		vr_autoneg;
	caddr_t			vr_ldata_ptr;
d411 2
d447 1
a470 32
 * Texas Instruments PHY identifiers
 */
#define TI_PHY_VENDORID		0x4000
#define TI_PHY_10BT		0x501F
#define TI_PHY_100VGPMI		0x502F

/*
 * These ID values are for the NS DP83840A 10/100 PHY
 */
#define NS_PHY_VENDORID		0x2000
#define NS_PHY_83840A		0x5C0F

/*
 * Level 1 10/100 PHY
 */
#define LEVEL1_PHY_VENDORID	0x7810
#define LEVEL1_PHY_LXT970	0x000F

/*
 * Intel 82555 10/100 PHY
 */
#define INTEL_PHY_VENDORID	0x0A28
#define INTEL_PHY_82555		0x015F

/*
 * SEEQ 80220 10/100 PHY
 */
#define SEEQ_PHY_VENDORID	0x0016
#define SEEQ_PHY_80220		0xF83F


/*
a505 99
#define PHY_UNKNOWN		6

#define VR_PHYADDR_MIN		0x00
#define VR_PHYADDR_MAX		0x1F

#define PHY_BMCR		0x00
#define PHY_BMSR		0x01
#define PHY_VENID		0x02
#define PHY_DEVID		0x03
#define PHY_ANAR		0x04
#define PHY_LPAR		0x05
#define PHY_ANEXP		0x06

#define PHY_ANAR_NEXTPAGE	0x8000
#define PHY_ANAR_RSVD0		0x4000
#define PHY_ANAR_TLRFLT		0x2000
#define PHY_ANAR_RSVD1		0x1000
#define PHY_ANAR_RSVD2		0x0800
#define PHY_ANAR_RSVD3		0x0400
#define PHY_ANAR_100BT4		0x0200
#define PHY_ANAR_100BTXFULL	0x0100
#define PHY_ANAR_100BTXHALF	0x0080
#define PHY_ANAR_10BTFULL	0x0040
#define PHY_ANAR_10BTHALF	0x0020
#define PHY_ANAR_PROTO4		0x0010
#define PHY_ANAR_PROTO3		0x0008
#define PHY_ANAR_PROTO2		0x0004
#define PHY_ANAR_PROTO1		0x0002
#define PHY_ANAR_PROTO0		0x0001

/*
 * These are the register definitions for the PHY (physical layer
 * interface chip).
 */
/*
 * PHY BMCR Basic Mode Control Register
 */
#define PHY_BMCR_RESET			0x8000
#define PHY_BMCR_LOOPBK			0x4000
#define PHY_BMCR_SPEEDSEL		0x2000
#define PHY_BMCR_AUTONEGENBL		0x1000
#define PHY_BMCR_RSVD0			0x0800	/* write as zero */
#define PHY_BMCR_ISOLATE		0x0400
#define PHY_BMCR_AUTONEGRSTR		0x0200
#define PHY_BMCR_DUPLEX			0x0100
#define PHY_BMCR_COLLTEST		0x0080
#define PHY_BMCR_RSVD1			0x0040	/* write as zero, don't care */
#define PHY_BMCR_RSVD2			0x0020	/* write as zero, don't care */
#define PHY_BMCR_RSVD3			0x0010	/* write as zero, don't care */
#define PHY_BMCR_RSVD4			0x0008	/* write as zero, don't care */
#define PHY_BMCR_RSVD5			0x0004	/* write as zero, don't care */
#define PHY_BMCR_RSVD6			0x0002	/* write as zero, don't care */
#define PHY_BMCR_RSVD7			0x0001	/* write as zero, don't care */
/*
 * RESET: 1 == software reset, 0 == normal operation
 * Resets status and control registers to default values.
 * Relatches all hardware config values.
 *
 * LOOPBK: 1 == loopback operation enabled, 0 == normal operation
 *
 * SPEEDSEL: 1 == 100Mb/s, 0 == 10Mb/s
 * Link speed is selected byt his bit or if auto-negotiation if bit
 * 12 (AUTONEGENBL) is set (in which case the value of this register
 * is ignored).
 *
 * AUTONEGENBL: 1 == Autonegotiation enabled, 0 == Autonegotiation disabled
 * Bits 8 and 13 are ignored when autoneg is set, otherwise bits 8 and 13
 * determine speed and mode. Should be cleared and then set if PHY configured
 * for no autoneg on startup.
 *
 * ISOLATE: 1 == isolate PHY from MII, 0 == normal operation
 *
 * AUTONEGRSTR: 1 == restart autonegotiation, 0 = normal operation
 *
 * DUPLEX: 1 == full duplex mode, 0 == half duplex mode
 *
 * COLLTEST: 1 == collision test enabled, 0 == normal operation
 */

/* 
 * PHY, BMSR Basic Mode Status Register 
 */   
#define PHY_BMSR_100BT4			0x8000
#define PHY_BMSR_100BTXFULL		0x4000
#define PHY_BMSR_100BTXHALF		0x2000
#define PHY_BMSR_10BTFULL		0x1000
#define PHY_BMSR_10BTHALF		0x0800
#define PHY_BMSR_RSVD1			0x0400	/* write as zero, don't care */
#define PHY_BMSR_RSVD2			0x0200	/* write as zero, don't care */
#define PHY_BMSR_RSVD3			0x0100	/* write as zero, don't care */
#define PHY_BMSR_RSVD4			0x0080	/* write as zero, don't care */
#define PHY_BMSR_MFPRESUP		0x0040
#define PHY_BMSR_AUTONEGCOMP		0x0020
#define PHY_BMSR_REMFAULT		0x0010
#define PHY_BMSR_CANAUTONEG		0x0008
#define PHY_BMSR_LINKSTAT		0x0004
#define PHY_BMSR_JABBER			0x0002
#define PHY_BMSR_EXTENDED		0x0001

d508 5
@


1.2
log
@update to latest freebsd code, fixes stalls during heavy traffic
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.1 1999/01/10 22:30:46 downsj Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_vrreg.h,v 1.2 1999/01/10 18:51:49 wpaul Exp $
a336 1

d339 1
a339 1
#define VR_TX_LIST_CNT		64
d437 1
d444 1
a444 1
#define	VIA_VENDORID		0x1106
d449 22
a470 2
#define	VIA_DEVICEID_RHINE	0x3043
#define VIA_DEVICEID_RHINE_II	0x6100
@


1.2.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.4 2001/02/20 19:12:48 jason Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_vrreg.h,v 1.10 2001/02/09 06:11:21 bmilekic Exp $
d337 1
d340 1
a340 1
#define VR_TX_LIST_CNT		128
d406 1
a408 1
	bus_dma_tag_t		sc_dmat;
d410 6
a417 2
	struct mii_data		sc_mii;
	struct timeout		sc_to;
a437 1
#define ETHER_ALIGN		2
d444 1
a444 1
#define	VIA_VENDORID			0x1106
d449 10
a458 3
#define	VIA_DEVICEID_RHINE		0x3043
#define VIA_DEVICEID_RHINE_II		0x6100
#define VIA_DEVICEID_RHINE_II_2		0x3065
d461 1
a461 1
 * Delta Electronics device ID.
d463 2
a464 1
#define DELTA_VENDORID			0x1500
d467 1
a467 1
 * Delta device IDs.
d469 2
a470 1
#define DELTA_DEVICEID_RHINE_II		0x1320
d473 1
a473 1
 * Addtron vendor ID.
d475 2
a476 1
#define ADDTRON_VENDORID		0x4033
d479 1
a479 1
 * Addtron device IDs.
d481 2
a482 1
#define ADDTRON_DEVICEID_RHINE_II	0x1320
d521 99
a621 5
#endif

#ifdef __alpha__
#undef vtophys
#define vtophys(va)		alpha_XXX_dmamap((vm_offset_t)va)
@


1.2.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vrreg.h,v 1.2.6.1 2001/05/14 22:25:48 niklas Exp $	*/
a83 1
#define VR_STICKHW		0x83
a272 7

/* Sticky HW bits */
#define VR_STICKHW_DS0		0x01
#define VR_STICKHW_DS1		0x02
#define VR_STICKHW_WOL_ENB	0x04
#define VR_STICKHW_WOL_STS	0x08
#define VR_STICKHW_LEGWOL_ENB	0x80
@


1.2.6.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_vrreg.h,v 1.17 2003/02/01 01:27:05 silby Exp $
a85 4
/* Misc Registers */
#define VR_MISC_CR1		0x81
#define VR_MISCCR1_FORSRST	0x40

a153 2
#define VR_ISR_ETI		0x0200	/* Tx early (3043/3071) */
#define VR_ISR_UDFI		0x0200	/* Tx FIFO underflow (3065) */
a282 40
 * BCR0 register bits. (At least for the VT6102 chip.)
 */
#define VR_BCR0_DMA_LENGTH      0x07

#define VR_BCR0_DMA_32BYTES     0x00
#define VR_BCR0_DMA_64BYTES     0x01
#define VR_BCR0_DMA_128BYTES    0x02
#define VR_BCR0_DMA_256BYTES    0x03
#define VR_BCR0_DMA_512BYTES    0x04
#define VR_BCR0_DMA_1024BYTES   0x05
#define VR_BCR0_DMA_STORENFWD   0x07
 
#define VR_BCR0_RX_THRESH       0x38

#define VR_BCR0_RXTHRESHCFG     0x00
#define VR_BCR0_RXTHRESH64BYTES 0x08
#define VR_BCR0_RXTHRESH128BYTES 0x10
#define VR_BCR0_RXTHRESH256BYTES 0x18
#define VR_BCR0_RXTHRESH512BYTES 0x20
#define VR_BCR0_RXTHRESH1024BYTES 0x28
#define VR_BCR0_RXTHRESHSTORENFWD 0x38
#define VR_BCR0_EXTLED          0x40
#define VR_BCR0_MED2            0x80

/*
 * BCR1 register bits. (At least for the VT6102 chip.)
 */
#define VR_BCR1_POT0            0x01
#define VR_BCR1_POT1            0x02
#define VR_BCR1_POT2            0x04
#define VR_BCR1_TX_THRESH       0x38
#define VR_BCR1_TXTHRESHCFG     0x00
#define VR_BCR1_TXTHRESH64BYTES 0x08
#define VR_BCR1_TXTHRESH128BYTES 0x10
#define VR_BCR1_TXTHRESH256BYTES 0x18
#define VR_BCR1_TXTHRESH512BYTES 0x20
#define VR_BCR1_TXTHRESH1024BYTES 0x28
#define VR_BCR1_TXTHRESHSTORENFWD 0x38

/*
a332 1
#define VR_TXSTAT_UDF		0x00000800
a416 2
	u_int8_t		vr_revid;	/* Rhine chip revision */
	u_int8_t		vr_flags;	/* See VR_F_* below */
a422 2
#define VR_F_RESTART		0x01		/* Restart unit on next tick */

a455 2
#define VIA_DEVICEID_RHINE_III		0x3106
#define VIA_DEVICEID_RHINE_III_M	0x3053
a478 15
 * VIA Rhine revision IDs
 */

#define REV_ID_VT3043_E			0x04
#define REV_ID_VT3071_A			0x20
#define REV_ID_VT3071_B			0x21
#define REV_ID_VT3065_A			0x40
#define REV_ID_VT3065_B			0x41
#define REV_ID_VT3065_C			0x42
#define REV_ID_VT6102_APOLLO		0x74
#define REV_ID_VT3106			0x80
#define REV_ID_VT3106_J			0x80	/* 0x80-0x8F */
#define REV_ID_VT3106_S			0x90	/* 0x90-0xA0 */

/*
a486 1
#define VR_PCI_REVID		0x08
a498 3
#define VR_PCI_MODE		0x50

#define VR_MODE3_MIION		0x04
@


1.2.6.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a409 2
	bus_addr_t		vr_paddr;
	bus_dmamap_t		vr_map;
d414 1
a415 3
	u_int8_t		*vr_buf;
	bus_addr_t		vr_paddr;
	bus_dmamap_t		vr_map;
a469 2
	bus_dmamap_t		sc_listmap;	/* descriptor list map */
	bus_dma_segment_t	sc_listseg;
@


1.2.6.5
log
@Merge with the trunk
@
text
@d498 1
@


1.1
log
@VIA Rhine driver, ported from FreeBSD; written by wpaul@@ctr.columbia.edu.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
 *	$FreeBSD: if_vrreg.h,v 1.1 1998/12/04 18:01:21 wpaul Exp $
d316 1
d343 1
a345 1
#define VR_UNSENT		0x12341234
@

