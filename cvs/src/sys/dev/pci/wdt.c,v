head	1.22;
access;
symbols
	OPENBSD_6_0:1.22.0.10
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.4
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.21.0.10
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.8
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.4
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.4
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.3.0.6
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.1.0.8
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.6
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.22
date	2014.12.10.12.27.57;	author mikeb;	state Exp;
branches;
next	1.21;
commitid	v6PAeA18rydwc5Vx;

1.21
date	2012.10.17.22.32.01;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.03.15.36.03;	author jasper;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.08.00.23.54;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2009.04.25.17.50.48;	author mk;	state Exp;
branches;
next	1.17;

1.17
date	2008.08.30.02.46.56;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2007.08.14.07.16.26;	author mk;	state Exp;
branches;
next	1.15;

1.15
date	2007.08.01.13.07.08;	author mk;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.25.20.47.17;	author mbalmer;	state Exp;
branches;
next	1.13;

1.13
date	2006.07.09.21.44.06;	author mk;	state Exp;
branches;
next	1.12;

1.12
date	2006.07.09.21.18.45;	author mk;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.19.11.42.07;	author mk;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.17.19.30.51;	author mk;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.11.10.56.39;	author mk;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.31.01.40.40;	author mk;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.15.20.03.07;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.11.18.17.08;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.15.20.32.17;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.27.00;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.03.06.19.13;	author mickey;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	2001.02.03.06.17.56;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	99.04.28.23.21.04;	author alex;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.05.14.22.26.01;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.28.15.35.59;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2004.02.19.10.56.30;	author niklas;	state Exp;
branches;
next	;

1.3.6.1
date	2002.06.11.03.42.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Convert watchdog(4) devices to use autoconf(9) framework.

ok deraadt, tests on glxpcib and ok mpi
@
text
@/*	$OpenBSD: wdt.c,v 1.21 2012/10/17 22:32:01 deraadt Exp $	*/

/*-
 * Copyright (c) 1998,1999 Alex Nash
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/systm.h>

#include <machine/bus.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

struct wdt_softc {
	/* wdt_dev must be the first item in the struct */
	struct device		sc_dev;

	/* feature set: 0 = none   1 = temp, buzzer, etc. */
	int			sc_features;

	/* device access through bus space */
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
};

int	wdt_probe(struct device *, void *, void *);
void	wdt_attach(struct device *, struct device *, void *);
int	wdt_activate(struct device *, int);

int	wdt_is501(struct wdt_softc *);
void	wdt_8254_count(struct wdt_softc *, int, u_int16_t);
void	wdt_8254_mode(struct wdt_softc *, int, int);
int	wdt_set_timeout(void *, int);
void	wdt_init_timer(struct wdt_softc *);
void	wdt_buzzer_off(struct wdt_softc *);
void	wdt_timer_disable(struct wdt_softc *);
void	wdt_buzzer_enable(struct wdt_softc *);

struct cfattach wdt_ca = {
	sizeof(struct wdt_softc), wdt_probe, wdt_attach,
	NULL, wdt_activate
};

struct cfdriver wdt_cd = {
	NULL, "wdt", DV_DULL
};

const struct pci_matchid wdt_devices[] = {
	{ PCI_VENDOR_INDCOMPSRC, PCI_PRODUCT_INDCOMPSRC_WDT50x }
};

/*
 *	8254 counter mappings
 */
#define WDT_8254_TC_LO		0	/* low 16 bits of timeout counter  */
#define	WDT_8254_TC_HI		1	/* high 16 bits of timeout counter */
#define WDT_8254_BUZZER		2

/*
 *	WDT500/501 ports
 */
#define WDT_8254_BASE		0
#define WDT_8254_CTL		(WDT_8254_BASE + 3)
#define WDT_DISABLE_TIMER	7
#define WDT_ENABLE_TIMER	7

/*
 *	WDT501 specific ports
 */
#define WDT_STATUS_REG		4
#define WDT_START_BUZZER	4
#define WDT_TEMPERATURE		5
#define WDT_STOP_BUZZER		5

int
wdt_probe(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, wdt_devices,
	    nitems(wdt_devices)));
}

void
wdt_attach(struct device *parent, struct device *self, void *aux)
{
	struct wdt_softc *wdt = (struct wdt_softc *)self;
	struct pci_attach_args *const pa = (struct pci_attach_args *)aux;
	bus_size_t iosize;

	/* retrieve the I/O region (BAR2) */
	if (pci_mapreg_map(pa, 0x18, PCI_MAPREG_TYPE_IO, 0,
	    &wdt->sc_iot, &wdt->sc_ioh, NULL, &iosize, 0) != 0) {
		printf("%s: couldn't find PCI I/O region\n",
		    wdt->sc_dev.dv_xname);
		return;
	}

	/* sanity check I/O size */
	if (iosize != (bus_size_t)16) {
		printf("%s: invalid I/O region size\n",
		    wdt->sc_dev.dv_xname);
		return;
	}

	/* initialize the watchdog timer structure */

	/* check the feature set available */
	if (wdt_is501(wdt))
		wdt->sc_features = 1;
	else
		wdt->sc_features = 0;

	if (wdt->sc_features) {
		/*
		 * turn off the buzzer, it may have been activated
		 * by a previous timeout
		 */
		wdt_buzzer_off(wdt);

		wdt_buzzer_enable(wdt);
	}

	/* initialize the timer modes and the lower 16-bit counter */
	wdt_init_timer(wdt);

	/*
	 * ensure that the watchdog is disabled
	 */
	wdt_timer_disable(wdt);

	/*
	 * register with the watchdog framework
	 */
	wdog_register(wdt_set_timeout, wdt);
}

int
wdt_activate(struct device *self, int act)
{
	switch (act) {
	case DVACT_POWERDOWN:
		wdog_shutdown(self);
		break;
	}

	return (0);
}

/*
 *	wdt_is501
 *
 *	Returns non-zero if the card is a 501 model.
 */
int
wdt_is501(struct wdt_softc *wdt)
{
	/*
	 *	It makes too much sense to detect the card type
	 *	by the device ID, so we have to resort to testing
	 *	the presence of a register to determine the type.
	 */
	int v = bus_space_read_1(wdt->sc_iot, wdt->sc_ioh, WDT_TEMPERATURE);

	/* XXX may not be reliable */
	if (v == 0 || v == 0xFF)
		return(0);

	return(1);
}

/*
 *	wdt_8254_count
 *
 *	Loads the specified counter with the 16-bit value 'v'.
 */
void
wdt_8254_count(struct wdt_softc *wdt, int counter, u_int16_t v)
{
	bus_space_write_1(wdt->sc_iot, wdt->sc_ioh,
			WDT_8254_BASE + counter, v & 0xFF);
	bus_space_write_1(wdt->sc_iot, wdt->sc_ioh, WDT_8254_BASE + counter, v >> 8);
}

/*
 *	wdt_8254_mode
 *
 *	Sets the mode of the specified counter.
 */
void
wdt_8254_mode(struct wdt_softc *wdt, int counter, int mode)
{
	bus_space_write_1(wdt->sc_iot, wdt->sc_ioh, WDT_8254_CTL,
		(counter << 6) | 0x30 | (mode << 1));
}

/*
 *	wdt_set_timeout
 *
 *	Load the watchdog timer with the specified number of seconds.
 *	Clamp seconds to be in the interval [2; 1800].
 */
int
wdt_set_timeout(void *self, int seconds)
{
	struct wdt_softc *wdt = (struct wdt_softc *)self;

	u_int16_t v;
	int s;

	s = splclock();

	wdt_timer_disable(wdt);

	if (seconds == 0) {
		splx(s);
		return (0);
	} else if (seconds < 2)
		seconds = 2;
	else if (seconds > 1800)
		seconds = 1800;

	/* 8254 has been programmed with a 2ms period */
	v = (u_int16_t)seconds * 50;

	/* load the new timeout count */
	wdt_8254_count(wdt, WDT_8254_TC_HI, v);

	/* enable the timer */
	bus_space_write_1(wdt->sc_iot, wdt->sc_ioh, WDT_ENABLE_TIMER, 0);

	splx(s);

	return (seconds);
}

/*
 *	wdt_timer_disable
 *
 *	Disables the watchdog timer and cancels the scheduled (if any)
 *	kernel timeout.
 */
void
wdt_timer_disable(struct wdt_softc *wdt)
{
	(void)bus_space_read_1(wdt->sc_iot, wdt->sc_ioh, WDT_DISABLE_TIMER);
}

/*
 *	wdt_init_timer
 *
 *	Configure the modes for the watchdog counters and initialize
 *	the low 16-bits of the watchdog counter to have a period of
 *	approximately 1/50th of a second.
 */
void
wdt_init_timer(struct wdt_softc *wdt)
{
	wdt_8254_mode(wdt, WDT_8254_TC_LO, 3);
	wdt_8254_mode(wdt, WDT_8254_TC_HI, 2);
	wdt_8254_count(wdt, WDT_8254_TC_LO, 41666);
}

/*******************************************************************
 *	WDT501 specific functions
 *******************************************************************/

/*
 *	wdt_buzzer_off
 *
 *	Turns the buzzer off.
 */
void
wdt_buzzer_off(struct wdt_softc *wdt)
{
	bus_space_write_1(wdt->sc_iot, wdt->sc_ioh, WDT_STOP_BUZZER, 0);
}

#ifndef WDT_DISABLE_BUZZER
/*
 *	wdt_buzzer_enable
 *
 *	Enables the buzzer when the watchdog counter expires.
 */
void
wdt_buzzer_enable(struct wdt_softc *wdt)
{
	bus_space_write_1(wdt->sc_iot, wdt->sc_ioh, WDT_8254_BUZZER, 1);
	wdt_8254_mode(wdt, WDT_8254_BUZZER, 1);
}
#else
/*
 *	wdt_buzzer_disable
 *
 *	Disables the buzzer from sounding when the watchdog counter
 *	expires.
 */
void
wdt_buzzer_disable(struct wdt_softc *wdt)
{
	wdt_8254_mode(wdt, WDT_8254_BUZZER, 0);
}
#endif
@


1.21
log
@Swap arguments to wdog_register() since it is nicer, and prepare
wdog_shutdown() for external usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.20 2011/04/03 15:36:03 jasper Exp $	*/
d56 1
d68 2
a69 1
	sizeof(struct wdt_softc), wdt_probe, wdt_attach
d162 12
@


1.20
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.19 2010/04/08 00:23:54 tedu Exp $	*/
d159 1
a159 1
	wdog_register(wdt, wdt_set_timeout);
@


1.19
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.18 2009/04/25 17:50:48 mk Exp $	*/
d105 1
a105 1
	    sizeof(wdt_devices)/sizeof(wdt_devices[0])));
@


1.18
log
@Prefix wdt softc members with sc_ like other drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.17 2008/08/30 02:46:56 jsg Exp $	*/
a33 1
#include <sys/proc.h>
@


1.17
log
@Remove the header that exposed the old wdt ioctl interface to userland,
wdt was converted to use the common watchdog code some time ago so this
is no longer needed.

"yes, we should remove it" mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.16 2007/08/14 07:16:26 mk Exp $	*/
d45 1
a45 1
	struct device		wdt_dev;
d48 1
a48 1
	int			features;
d51 2
a52 2
	bus_space_tag_t		iot;
	bus_space_handle_t	ioh;
d55 2
a56 2
int	wdtprobe(struct device *, void *, void *);
void	wdtattach(struct device *, struct device *, void *);
d68 1
a68 1
	sizeof(struct wdt_softc), wdtprobe, wdtattach
d103 1
a103 1
wdtprobe(struct device *parent, void *match, void *aux)
d110 1
a110 1
wdtattach(struct device *parent, struct device *self, void *aux)
d118 1
a118 1
	    &wdt->iot, &wdt->ioh, NULL, &iosize, 0) != 0) {
d120 1
a120 1
		    wdt->wdt_dev.dv_xname);
d127 1
a127 1
		    wdt->wdt_dev.dv_xname);
d135 1
a135 1
		wdt->features = 1;
d137 1
a137 1
		wdt->features = 0;
d139 1
a139 1
	if (wdt->features) {
d176 1
a176 1
	int v = bus_space_read_1(wdt->iot, wdt->ioh, WDT_TEMPERATURE);
d193 1
a193 1
	bus_space_write_1(wdt->iot, wdt->ioh,
d195 1
a195 1
	bus_space_write_1(wdt->iot, wdt->ioh, WDT_8254_BASE + counter, v >> 8);
d206 1
a206 1
	bus_space_write_1(wdt->iot, wdt->ioh, WDT_8254_CTL,
d243 1
a243 1
	bus_space_write_1(wdt->iot, wdt->ioh, WDT_ENABLE_TIMER, 0);
d259 1
a259 1
	(void)bus_space_read_1(wdt->iot, wdt->ioh, WDT_DISABLE_TIMER);
d289 1
a289 1
	bus_space_write_1(wdt->iot, wdt->ioh, WDT_STOP_BUZZER, 0);
d301 1
a301 1
	bus_space_write_1(wdt->iot, wdt->ioh, WDT_8254_BUZZER, 1);
@


1.16
log
@I forgot to remove the UNIT macro when the wdt char device was removed
long ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.15 2007/08/01 13:07:08 mk Exp $	*/
a41 2

#include <dev/pci/wdt50x.h>
@


1.15
log
@wdt doesn't malloc so no reason to include malloc.h.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.14 2006/11/25 20:47:17 mbalmer Exp $	*/
a102 2

#define UNIT(dev)		(minor(dev))
@


1.14
log
@use pci_matchbyid() here, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.13 2006/07/09 21:44:06 mk Exp $	*/
a33 1
#include <sys/malloc.h>
@


1.13
log
@Some more KNF stuff I missed.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.12 2006/07/09 21:18:45 mk Exp $	*/
d78 4
d110 2
a111 7
	struct pci_attach_args *const pa = (struct pci_attach_args *)aux;

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_INDCOMPSRC ||
	    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_INDCOMPSRC_WDT50x)
		return(0);

	return(1);
@


1.12
log
@ANSI and KNF.  No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.11 2006/06/19 11:42:07 mk Exp $	*/
d58 2
a59 2
int wdtprobe(struct device *, void *, void *);
void wdtattach(struct device *, struct device *, void *);
d61 8
a68 8
int wdt_is501(struct wdt_softc *);
void wdt_8254_count(struct wdt_softc *, int, u_int16_t);
void wdt_8254_mode(struct wdt_softc *, int, int);
int wdt_set_timeout(void *, int);
void wdt_init_timer(struct wdt_softc *);
void wdt_buzzer_off(struct wdt_softc *);
void wdt_timer_disable(struct wdt_softc *);
void wdt_buzzer_enable(struct wdt_softc *);
@


1.11
log
@Remove freebsdism.

input and ok mickey.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.10 2006/06/17 19:30:51 mk Exp $	*/
d104 1
a104 3
wdtprobe (parent, match, aux)
	struct device *parent;
	void *match, *aux;
d116 1
a116 3
wdtattach (parent, self, aux)
	struct device *parent, *self;
	void *aux;
d175 1
a175 1
wdt_is501 (struct wdt_softc *wdt)
d197 1
a197 1
wdt_8254_count (struct wdt_softc *wdt, int counter, u_int16_t v)
d210 1
a210 1
wdt_8254_mode (struct wdt_softc *wdt, int counter, int mode)
d223 1
a223 1
wdt_set_timeout (void *self, int seconds)
d263 1
a263 1
wdt_timer_disable (struct wdt_softc *wdt)
d276 1
a276 1
wdt_init_timer (struct wdt_softc *wdt)
d293 1
a293 1
wdt_buzzer_off (struct wdt_softc *wdt)
d305 1
a305 1
wdt_buzzer_enable (struct wdt_softc *wdt)
d318 1
a318 1
wdt_buzzer_disable (struct wdt_softc *wdt)
@


1.10
log
@KNF and destatic functions.

ok brad
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.9 2006/06/11 10:56:39 mk Exp $	*/
a52 3
	/* unit number (unlikely more than one would be present though) */
	int			unit;

a124 3
	int unit;

	unit = wdt->wdt_dev.dv_unit;
d129 2
a130 1
		printf("wdt%d: couldn't find PCI I/O region\n", unit);
d136 2
a137 1
		printf("wdt%d: invalid I/O region size\n", unit);
a141 1
	wdt->unit  = unit;
@


1.9
log
@Get rid of the wdt(4) char device.  We have watchdog(4) and
watchdogd(4), so there's no point in supporting old, unused,
non-generic interfaces.

Tested by < jg , rilk - com>.

The sensors available on the WDT501 model will be supported later using
the sensors framework.

ok mickey markus
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.8 2006/05/31 01:40:40 mk Exp $	*/
d33 1
d35 1
a36 2
#include <sys/kernel.h>
#include <sys/proc.h>
a60 1
/* externally visible functions */
d64 8
a71 9
/* static functions */
static int wdt_is501(struct wdt_softc *wdt);
static void wdt_8254_count(struct wdt_softc *wdt, int counter, u_int16_t v);
static void wdt_8254_mode(struct wdt_softc *wdt, int counter, int mode);
static int wdt_set_timeout(void *wdt, int seconds);
static void wdt_init_timer(struct wdt_softc *wdt);
static void wdt_buzzer_off(struct wdt_softc *wdt);
static void wdt_timer_disable(struct wdt_softc *wdt);
static void wdt_buzzer_enable(struct wdt_softc *wdt);
d183 1
a183 1
static int
d205 1
a205 1
static void
d218 1
a218 1
static void
d231 1
a231 1
static int
d271 1
a271 1
static void
d284 1
a284 1
static void
d301 1
a301 1
static void
d313 1
a313 1
static void
d326 1
a326 1
static void
@


1.8
log
@Use the watchdog(4) framework for watchdog services instead of rolling
more or less the same code.  This means that all our watchdog drivers
use the framework, and that they all can be configured using sysctl
kern.watchdog.{period,auto}, and they can all use watchdogd.

At least for now we still support the /dev/wdt0 char device and
userland poking using ioctl.

Testing by < jg ! rilk , com >, many thanks!

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.7 2006/03/15 20:03:07 miod Exp $	*/
a55 6
	/* how many processes are in WIOCSCHED */
	unsigned		procs;

	/* watchdog timeout */
	unsigned		timeout_secs;

a63 3
int wdtopen(dev_t, int, int, struct proc *);
int wdtclose(dev_t, int, int, struct proc *);
int wdtioctl(dev_t, u_long, caddr_t, int, struct proc *);
a71 5
static int wdt_read_temperature(struct wdt_softc *wdt);
static int wdt_read_status(struct wdt_softc *wdt);
static void wdt_display_status(struct wdt_softc *wdt);
static int wdt_get_state(struct wdt_softc *wdt, struct wdt_state *state);
static int wdt_sched(struct wdt_softc *wdt, struct proc *p);
a72 3
#if WDT_DISABLE_BUZZER
static void wdt_buzzer_disable(struct wdt_softc *wdt);
#else
a73 1
#endif
a148 2
	wdt->procs = 0;
	wdt->timeout_secs = 0;
a162 3
#ifdef WDT_DISABLE_BUZZER
		wdt_buzzer_disable(wdt);
#else
a163 1
#endif
a177 45

	printf("\n");
	wdt_display_status(wdt);
}

int
wdtopen (dev_t dev, int flags, int fmt, struct proc *p)
{
	if (UNIT(dev) >= wdt_cd.cd_ndevs || wdt_cd.cd_devs[UNIT(dev)] == NULL)
		return (ENXIO);

	return(0);
}

int
wdtclose (dev_t dev, int flags, int fmt, struct proc *p)
{
	return(0);
}

int
wdtioctl (dev_t dev, u_long cmd, caddr_t arg, int flag, struct proc *p)
{
	struct wdt_softc *wdt = wdt_cd.cd_devs[UNIT(dev)];
	int error;

	switch (cmd) {
		case WIOCSCHED:
			error = wdt_sched(wdt, p);
			break;

		case WIOCGETSTATE:
			if (wdt->features)
				error = wdt_get_state(wdt,
					(struct wdt_state *)arg);
			else
				error = ENXIO;
			break;

		default:
			error = ENXIO;
			break;
	}

	return(error);
a245 1
		wdt->timeout_secs = 0;
a261 2
	wdt->timeout_secs = seconds;

a333 129

/*
 *	wdt_read_temperature
 *
 *	Returns the temperature (in Fahrenheit) from the board.
 */
static int
wdt_read_temperature (struct wdt_softc *wdt)
{
	unsigned v = bus_space_read_1(wdt->iot, wdt->ioh, WDT_TEMPERATURE);

	return((v * 11) / 15 + 7);
}

/*
 *	wdt_read_status
 *
 *	Returns the status register bits minus the counter refresh
 *	and IRQ generated bits.
 */
static int
wdt_read_status (struct wdt_softc *wdt)
{
	/* mask off counter refresh & IRQ generated bits */
	return(bus_space_read_1(wdt->iot, wdt->ioh, WDT_STATUS_REG) & 0x7E);
}

/*
 *	wdt_display_status
 *
 *	Displays the current timeout, temperature, and power supply
 *	over/undervoltages to the console.
 */
static void
wdt_display_status (struct wdt_softc *wdt)
{
	if (wdt->features) {
		int status = wdt_read_status(wdt);
		int temp   = wdt_read_temperature(wdt);

		printf("wdt%d: WDT501 timeout %d secs, temp %d F",
			   wdt->unit, wdt->timeout_secs, temp);

		/* overvoltage bit is active low */
		if ((status & WDT_SR_PS_OVER) == 0)
			printf(" <PS overvoltage>");

		/* undervoltage bit is active low */
		if ((status & WDT_SR_PS_UNDER) == 0)
			printf(" <PS undervoltage>");
	} else {
		printf("wdt%d: WDT500 timeout %d secs",
			   wdt->unit, wdt->timeout_secs);
	}

	printf("\n");
}

/*
 *	wdt_get_state
 *
 *	Returns the temperature and status bits.
 */
static int
wdt_get_state (struct wdt_softc *wdt, struct wdt_state *state)
{
	state->temperature	= wdt_read_temperature(wdt);
	state->status		= wdt_read_status(wdt);

	return(0);
}

/*
 *	wdt_sched
 *
 *	Put the process into an infinite loop in which:
 *
 *	  - The process sleeps, waiting for a wakeup() from the tsleep()
 *	    handler.
 *	  - When awakened, the process reloads the watchdog counter and
 *	    repeats the loop.
 *
 *	The only way the loop can be broken is if the process is interrupted
 *	via a signal.
 *
 *	The whole point of this is to cause a watchdog timeout to be
 *	generated if processes are no longer being scheduled.
 */
static int
wdt_sched (struct wdt_softc *wdt, struct proc *p)
{
	int error;
	int s;

	/*
	 * Regardless of the device permissions, you must be
	 * root to do this -- a process which is STOPPED
	 * while in this function can cause a reboot to occur
	 * if the counters aren't reloaded within wdt->timeout_secs
	 * seconds.
	 */
	if ((error = suser(p, 0)))
		return(error);

	/* block out the timeout handler */
	s = splclock();

	/* indicate that we are sleeping */
	++wdt->procs;

	/* loop until the process is signaled */
	while (1) {
		error = tsleep(wdt, PCATCH | PSWP, "wdtsch", 0);

		wdt_set_timeout(wdt, wdt->timeout_secs);

		if (error != 0)
			break;
	}

	/* remove sleeping indication */
	--wdt->procs;

	/* re-enable timeout handler */
	splx(s);

	return(error);
}

@


1.7
log
@Entries in cd_devs[] may be NULL, so be sure to check for them in your
device open() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.6 2005/09/11 18:17:08 mickey Exp $	*/
a35 1
#include <sys/timeout.h>
a60 1
	struct timeout		timeout;
d78 1
a78 2
static void wdt_set_timeout(struct wdt_softc *wdt, unsigned seconds);
static void wdt_timeout(void *arg);
a84 1
static void wdt_shutdown(void *arg);
a86 1
static void wdt_timer_enable(struct wdt_softc *wdt, unsigned seconds);
d168 1
a175 7
	/*
	 * register a callback for system shutdown
	 * (we need to disable the watchdog timer during shutdown)
	 */
	if (shutdownhook_establish(wdt_shutdown, wdt) == NULL)
		return;

d194 1
a194 4
	 * it appears the timeout queue isn't processed until the
	 * kernel has fully booted, so we set the first timeout
	 * far in advance, and subsequent timeouts at the normal
	 * 30 second interval
d196 6
a201 2
	wdt_timer_enable(wdt, 90/*seconds*/);
	wdt->timeout_secs = 30;
d300 1
d302 2
a303 2
static void
wdt_set_timeout (struct wdt_softc *wdt, unsigned seconds)
d305 18
d324 1
a324 4
	u_int16_t v = (u_int16_t)seconds * 50;

	/* disable the timer */
	(void)bus_space_read_1(wdt->iot, wdt->ioh, WDT_DISABLE_TIMER);
a330 1
}
d332 1
a332 20
/*
 *	wdt_timeout
 *
 *	Kernel timeout handler.  This function is called every
 *	wdt->timeout_secs / 2 seconds.  It reloads the watchdog
 *	counters in one of two ways:
 *
 *	   - If there are one or more processes sleeping in a
 *	     WIOCSCHED ioctl(), they are woken up to perform
 *	     the counter reload.
 *	   - If no processes are sleeping in WIOCSCHED, the
 *	     counters are reloaded from here.
 *
 *	Finally, another timeout is scheduled for wdt->timeout_secs
 *	from now.
 */
static void
wdt_timeout (void *arg)
{
	struct wdt_softc *wdt = (struct wdt_softc *)arg;
d334 1
a334 5
	/* reload counters from proc in WIOCSCHED ioctl()? */
	if (wdt->procs)
		wakeup(wdt);
	else
		wdt_set_timeout(wdt, wdt->timeout_secs);
d336 1
a336 2
	/* schedule another timeout in half the countdown time */
	timeout_add(&wdt->timeout, wdt->timeout_secs * hz / 2);
a348 34
	timeout_del(&wdt->timeout);
}

/*
 *	wdt_timer_enable
 *
 *	Enables the watchdog timer to expire in the specified number
 *	of seconds.  If 'seconds' is outside the range 2-1800, it
 *	is silently clamped to be within range.
 */
static void
wdt_timer_enable (struct wdt_softc *wdt, unsigned seconds)
{
	int s;

	/* clamp range */
	if (seconds < 2)
		seconds = 2;

	if (seconds > 1800)
		seconds = 1800;

	/* block out the timeout handler */
	s = splclock();

	wdt_timer_disable(wdt);
	wdt->timeout_secs = seconds;

	timeout_set(&wdt->timeout, wdt_timeout, wdt);
	timeout_add(&wdt->timeout, hz * seconds / 2);
	wdt_set_timeout(wdt, seconds);

	/* re-enable clock interrupts */
	splx(s);
a478 13
 *	wdt_shutdown
 *
 *	Disables the watchdog timer at system shutdown time.
 */
static void
wdt_shutdown (void *arg)
{
	struct wdt_softc *wdt = (struct wdt_softc *)arg;

	wdt_timer_disable(wdt);
}

/*
d534 1
@


1.6
log
@do not inline pci_mapreg_map() anymore as it is olrite now; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.5 2003/08/15 20:32:17 tedu Exp $	*/
d220 2
a221 2
	if (UNIT(dev) >= wdt_cd.cd_ndevs)
		return(ENXIO);
@


1.5
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.4 2002/03/14 01:27:00 millert Exp $	*/
d152 1
a153 4
	bus_size_t iosize;
	bus_addr_t iobase;

	wdt->iot = pa->pa_iot;
d158 2
a159 2
	if (pci_io_find(pa->pa_pc, pa->pa_tag, 0x18, &iobase,
	    &iosize) != 0) {
a166 6
		return;
	}

	/* map I/O region */
	if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &wdt->ioh) != 0) {
		printf("wdt%d: couldn't map PCI I/O region\n", unit);
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.3 2001/02/03 06:19:13 mickey Exp $	*/
d582 1
a582 1
	if ((error = suser(p->p_ucred, &p->p_acflag)))
@


1.3
log
@fix the comment
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.2 2001/02/03 06:17:56 mickey Exp $	*/
d70 5
a74 5
int wdtprobe __P((struct device *, void *, void *));
void wdtattach __P((struct device *, struct device *, void *));
int wdtopen __P((dev_t, int, int, struct proc *));
int wdtclose __P((dev_t, int, int, struct proc *));
int wdtioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
d77 15
a91 15
static int wdt_is501 __P((struct wdt_softc *wdt));
static void wdt_8254_count __P((struct wdt_softc *wdt, int counter, u_int16_t v));
static void wdt_8254_mode __P((struct wdt_softc *wdt, int counter, int mode));
static void wdt_set_timeout __P((struct wdt_softc *wdt, unsigned seconds));
static void wdt_timeout __P((void *arg));
static void wdt_init_timer __P((struct wdt_softc *wdt));
static void wdt_buzzer_off __P((struct wdt_softc *wdt));
static int wdt_read_temperature __P((struct wdt_softc *wdt));
static int wdt_read_status __P((struct wdt_softc *wdt));
static void wdt_display_status __P((struct wdt_softc *wdt));
static int wdt_get_state __P((struct wdt_softc *wdt, struct wdt_state *state));
static void wdt_shutdown __P((void *arg));
static int wdt_sched __P((struct wdt_softc *wdt, struct proc *p));
static void wdt_timer_disable __P((struct wdt_softc *wdt));
static void wdt_timer_enable __P((struct wdt_softc *wdt, unsigned seconds));
d93 1
a93 1
static void wdt_buzzer_disable __P((struct wdt_softc *wdt));
d95 1
a95 1
static void wdt_buzzer_enable __P((struct wdt_softc *wdt));
@


1.3.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.3 2001/02/03 06:19:13 mickey Exp $	*/
d70 5
a74 5
int wdtprobe(struct device *, void *, void *);
void wdtattach(struct device *, struct device *, void *);
int wdtopen(dev_t, int, int, struct proc *);
int wdtclose(dev_t, int, int, struct proc *);
int wdtioctl(dev_t, u_long, caddr_t, int, struct proc *);
d77 15
a91 15
static int wdt_is501(struct wdt_softc *wdt);
static void wdt_8254_count(struct wdt_softc *wdt, int counter, u_int16_t v);
static void wdt_8254_mode(struct wdt_softc *wdt, int counter, int mode);
static void wdt_set_timeout(struct wdt_softc *wdt, unsigned seconds);
static void wdt_timeout(void *arg);
static void wdt_init_timer(struct wdt_softc *wdt);
static void wdt_buzzer_off(struct wdt_softc *wdt);
static int wdt_read_temperature(struct wdt_softc *wdt);
static int wdt_read_status(struct wdt_softc *wdt);
static void wdt_display_status(struct wdt_softc *wdt);
static int wdt_get_state(struct wdt_softc *wdt, struct wdt_state *state);
static void wdt_shutdown(void *arg);
static int wdt_sched(struct wdt_softc *wdt, struct proc *p);
static void wdt_timer_disable(struct wdt_softc *wdt);
static void wdt_timer_enable(struct wdt_softc *wdt, unsigned seconds);
d93 1
a93 1
static void wdt_buzzer_disable(struct wdt_softc *wdt);
d95 1
a95 1
static void wdt_buzzer_enable(struct wdt_softc *wdt);
@


1.2
log
@new timeout, even not in generic
@
text
@d1 1
a1 1
/*	$OpenBSD: wdt.c,v 1.1 1999/04/28 23:21:04 alex Exp $	*/
d558 1
a558 1
 *	  - The process sleeps, waiting for a wakeup() from the timeout()
@


1.1
log
@Added wdt driver for the Industrial Computer Source PCI-WDT50x watchdog
timers.
@
text
@d1 2
a27 1
 *	$OpenBSD$
d36 1
d38 1
d40 1
d45 1
a45 4
#include "wdt50x.h"
#include "wdt.h"

#if NWDT > 0
d62 1
d364 1
a364 1
	timeout(wdt_timeout, arg, wdt->timeout_secs * hz / 2);
d377 1
a377 1
	untimeout(wdt_timeout, wdt);
d405 2
a406 1
	timeout(wdt_timeout, wdt, hz * seconds / 2);
a608 2

#endif /* NWDT > 0 */
@


1.1.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@a0 2
/*	$OpenBSD: wdt.c,v 1.3 2001/02/03 06:19:13 mickey Exp $	*/

d26 1
a34 1
#include <sys/timeout.h>
a35 1

a36 1

d41 4
a44 1
#include <dev/pci/wdt50x.h>
a60 1
	struct timeout		timeout;
d362 1
a362 1
	timeout_add(&wdt->timeout, wdt->timeout_secs * hz / 2);
d375 1
a375 1
	timeout_del(&wdt->timeout);
d403 1
a403 2
	timeout_set(&wdt->timeout, wdt_timeout, wdt);
	timeout_add(&wdt->timeout, hz * seconds / 2);
d555 1
a555 1
 *	  - The process sleeps, waiting for a wakeup() from the tsleep()
d606 2
@


1.1.4.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 5
a74 5
int wdtprobe(struct device *, void *, void *);
void wdtattach(struct device *, struct device *, void *);
int wdtopen(dev_t, int, int, struct proc *);
int wdtclose(dev_t, int, int, struct proc *);
int wdtioctl(dev_t, u_long, caddr_t, int, struct proc *);
d77 15
a91 15
static int wdt_is501(struct wdt_softc *wdt);
static void wdt_8254_count(struct wdt_softc *wdt, int counter, u_int16_t v);
static void wdt_8254_mode(struct wdt_softc *wdt, int counter, int mode);
static void wdt_set_timeout(struct wdt_softc *wdt, unsigned seconds);
static void wdt_timeout(void *arg);
static void wdt_init_timer(struct wdt_softc *wdt);
static void wdt_buzzer_off(struct wdt_softc *wdt);
static int wdt_read_temperature(struct wdt_softc *wdt);
static int wdt_read_status(struct wdt_softc *wdt);
static void wdt_display_status(struct wdt_softc *wdt);
static int wdt_get_state(struct wdt_softc *wdt, struct wdt_state *state);
static void wdt_shutdown(void *arg);
static int wdt_sched(struct wdt_softc *wdt, struct proc *p);
static void wdt_timer_disable(struct wdt_softc *wdt);
static void wdt_timer_enable(struct wdt_softc *wdt, unsigned seconds);
d93 1
a93 1
static void wdt_buzzer_disable(struct wdt_softc *wdt);
d95 1
a95 1
static void wdt_buzzer_enable(struct wdt_softc *wdt);
@


1.1.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d582 1
a582 1
	if ((error = suser(p, 0)))
@


