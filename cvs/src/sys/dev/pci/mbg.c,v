head	1.30;
access;
symbols
	OPENBSD_6_1:1.29.0.30
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.28
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.16
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.24
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.22
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.20
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.18
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.14
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.12
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.10
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.8
	OPENBSD_5_0:1.29.0.6
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.4
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.4
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.27.0.2
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.24.0.4
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12;
locks; strict;
comment	@ * @;


1.30
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	uRv5pa9QDlZaYgwD;

1.29
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2009.04.26.02.20.58;	author cnst;	state Exp;
branches;
next	1.27;

1.27
date	2008.11.23.14.19.40;	author mbalmer;	state Exp;
branches;
next	1.26;

1.26
date	2008.11.22.15.05.24;	author mbalmer;	state Exp;
branches;
next	1.25;

1.25
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.24;

1.24
date	2007.11.26.19.44.43;	author mbalmer;	state Exp;
branches;
next	1.23;

1.23
date	2007.11.12.16.40.46;	author mbalmer;	state Exp;
branches;
next	1.22;

1.22
date	2007.11.11.15.30.26;	author mbalmer;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.07.09.56.22;	author mbalmer;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.05.19.58.29;	author mbalmer;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.04.13.31.21;	author mbalmer;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.25.08.24.55;	author mbalmer;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.24.15.41.55;	author mbalmer;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.23.07.51.55;	author mbalmer;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.08.09.23.01;	author mbalmer;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.30.19.58.43;	author mbalmer;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.03.13.27.12;	author mbalmer;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.02.19.25.02;	author mbalmer;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.30.23.44.58;	author mbalmer;	state Exp;
branches;
next	1.9;

1.9
date	2006.12.29.16.26.18;	author mbalmer;	state Exp;
branches;
next	1.8;

1.8
date	2006.12.29.10.55.30;	author mbalmer;	state Exp;
branches;
next	1.7;

1.7
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2006.12.22.09.04.42;	author mbalmer;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.22.07.19.20;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.22.07.10.43;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.18.17.50.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.18.07.58.22;	author mbalmer;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.17.16.32.35;	author mbalmer;	state Exp;
branches;
next	;


desc
@@


1.30
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: mbg.c,v 1.29 2010/04/08 00:23:53 tedu Exp $ */

/*
 * Copyright (c) 2006, 2007 Marc Balmer <mbalmer@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/timeout.h>
#include <sys/systm.h>
#include <sys/sensors.h>
#include <sys/syslog.h>
#include <sys/time.h>

#include <machine/bus.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

struct mbg_softc {
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;

	/*
	 * I/O region used by the AMCC S5920 found on the PCI509 card
	 * used to access the data.
	 */
	bus_space_tag_t		sc_iot_s5920;
	bus_space_handle_t	sc_ioh_s5920;

	struct ksensor		sc_timedelta;
	struct ksensor		sc_signal;
	struct ksensordev	sc_sensordev;
	struct timeout		sc_timeout;	/* invalidate sensor */
	int			sc_trust;	/* trust time in seconds */
	
	int			(*sc_read)(struct mbg_softc *, int cmd,
				    char *buf, size_t len,
				    struct timespec *tstamp);
};

struct mbg_time {
	u_int8_t		hundreds;
	u_int8_t		sec;
	u_int8_t		min;
	u_int8_t		hour;
	u_int8_t		mday;
	u_int8_t		wday;	/* 1 (monday) - 7 (sunday) */
	u_int8_t		mon;
	u_int8_t		year;	/* 0 - 99 */
	u_int8_t		status;
	u_int8_t		signal;
	int8_t			utc_off;
};

struct mbg_time_hr {
	u_int32_t		sec;		/* always UTC */
	u_int32_t		frac;		/* fractions of second */
	int32_t			utc_off;	/* informal only, in seconds */
	u_int16_t		status;
	u_int8_t		signal;
};

/* mbg_time.status bits */
#define MBG_FREERUN		0x01	/* clock running on xtal */
#define MBG_DST_ENA		0x02	/* DST enabled */
#define MBG_SYNC		0x04	/* clock synced at least once */
#define MBG_DST_CHG		0x08	/* DST change announcement */
#define MBG_UTC			0x10	/* special UTC firmware is installed */
#define MBG_LEAP		0x20	/* announcement of a leap second */
#define MBG_IFTM		0x40	/* current time was set from host */
#define MBG_INVALID		0x80	/* time invalid, batt. was disconn. */

/* AMCC S5920 registers */
#define AMCC_DATA		0x00	/* data register, on 2nd IO region */
#define AMCC_OMB		0x0c	/* outgoing mailbox */
#define AMCC_IMB		0x1c	/* incoming mailbox */

/* AMCC S5933 registers */
#define AMCC_OMB1		0x00	/* outgoing mailbox 1 */
#define AMCC_IMB4		0x1c	/* incoming mailbox 4 */
#define AMCC_FIFO		0x20	/* FIFO register */
#define AMCC_INTCSR		0x38	/* interrupt control/status register */
#define AMCC_MCSR		0x3c	/* master control/status register */

/* ASIC registers */
#define ASIC_CFG		0x00
#define ASIC_FEATURES		0x08	/* r/o */
#define ASIC_STATUS		0x10
#define ASIC_CTLSTATUS		0x14
#define ASIC_DATA		0x18
#define ASIC_RES1		0x1c
#define ASIC_ADDON		0x20

/* commands */
#define MBG_GET_TIME		0x00
#define MBG_GET_SYNC_TIME	0x02
#define MBG_GET_TIME_HR		0x03
#define MBG_SET_TIME		0x10
#define MBG_GET_TZCODE		0x32
#define MBG_SET_TZCODE		0x33
#define MBG_GET_FW_ID_1		0x40
#define MBG_GET_FW_ID_2		0x41
#define MBG_GET_SERNUM		0x42

/* timezone codes (for MBG_{GET|SET}_TZCODE) */
#define MBG_TZCODE_CET_CEST	0x00
#define MBG_TZCODE_CET		0x01
#define MBG_TZCODE_UTC		0x02
#define MBG_TZCODE_EET_EEST	0x03

/* misc. constants */
#define MBG_FIFO_LEN		16
#define MBG_ID_LEN		(2 * MBG_FIFO_LEN + 1)
#define MBG_BUSY		0x01
#define MBG_SIG_BIAS		55
#define MBG_SIG_MAX		68
#define NSECPERSEC		1000000000LL	/* nanoseconds per second */
#define HRDIVISOR		0x100000000LL	/* for hi-res timestamp */

int	mbg_probe(struct device *, void *, void *);
void	mbg_attach(struct device *, struct device *, void *);
void	mbg_task(void *);
void	mbg_task_hr(void *);
void	mbg_update_sensor(struct mbg_softc *sc, struct timespec *tstamp,
	    int64_t timedelta, u_int8_t rsignal, u_int16_t status);
int	mbg_read_amcc_s5920(struct mbg_softc *, int cmd, char *buf, size_t len,
	    struct timespec *tstamp);
int	mbg_read_amcc_s5933(struct mbg_softc *, int cmd, char *buf, size_t len,
	    struct timespec *tstamp);
int	mbg_read_asic(struct mbg_softc *, int cmd, char *buf, size_t len,
	    struct timespec *tstamp);
void	mbg_timeout(void *);

struct cfattach mbg_ca = {
	sizeof(struct mbg_softc), mbg_probe, mbg_attach
};

struct cfdriver mbg_cd = {
	NULL, "mbg", DV_DULL
};

const struct pci_matchid mbg_devices[] = {
	{ PCI_VENDOR_MEINBERG, PCI_PRODUCT_MEINBERG_GPS170PCI },
	{ PCI_VENDOR_MEINBERG, PCI_PRODUCT_MEINBERG_PCI32 },
	{ PCI_VENDOR_MEINBERG, PCI_PRODUCT_MEINBERG_PCI509 },
	{ PCI_VENDOR_MEINBERG, PCI_PRODUCT_MEINBERG_PCI511 },
	{ PCI_VENDOR_MEINBERG, PCI_PRODUCT_MEINBERG_PEX511 }
};

int
mbg_probe(struct device *parent, void *match, void *aux)
{
	return pci_matchbyid((struct pci_attach_args *)aux, mbg_devices,
	    nitems(mbg_devices));
}

void
mbg_attach(struct device *parent, struct device *self, void *aux)
{
	struct mbg_softc *sc = (struct mbg_softc *)self;
	struct pci_attach_args *const pa = (struct pci_attach_args *)aux;
	struct mbg_time tframe;
	pcireg_t memtype;
	bus_size_t iosize, iosize2;
	int bar = PCI_MAPREG_START, signal, t_trust;
	const char *desc;
#ifdef MBG_DEBUG
	char fw_id[MBG_ID_LEN];
#endif

	timeout_set(&sc->sc_timeout, mbg_timeout, sc);

	/* for the PEX511 use BAR2 instead of BAR0*/
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_MEINBERG_PEX511)
		bar += 0x08;

	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, bar);
	if (pci_mapreg_map(pa, bar, memtype, 0, &sc->sc_iot,
	    &sc->sc_ioh, NULL, &iosize, 0)) {
		printf(": PCI %s region not found\n",
		    memtype == PCI_MAPREG_TYPE_IO ? "I/O" : "memory");
		return;
	}

	if ((desc = pci_findproduct(pa->pa_id)) == NULL)
		desc = "Radio clock";
	strlcpy(sc->sc_timedelta.desc, desc, sizeof(sc->sc_timedelta.desc));

	strlcpy(sc->sc_sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));

	sc->sc_timedelta.type = SENSOR_TIMEDELTA;
	sc->sc_timedelta.status = SENSOR_S_UNKNOWN;
	sensor_attach(&sc->sc_sensordev, &sc->sc_timedelta);

	sc->sc_signal.type = SENSOR_PERCENT;
	sc->sc_signal.status = SENSOR_S_UNKNOWN;
	strlcpy(sc->sc_signal.desc, "Signal", sizeof(sc->sc_signal.desc));
	sensor_attach(&sc->sc_sensordev, &sc->sc_signal);

	t_trust = 12 * 60 * 60;		/* twelve hours */

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_MEINBERG_PCI32:
		sc->sc_read = mbg_read_amcc_s5933;
		sensor_task_register(sc, mbg_task, 10);
		break;
	case PCI_PRODUCT_MEINBERG_PCI509:
		/*
		 * map the second I/O region needed in addition to the first
		 * to get at the actual data.
		 */
		memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag,
		    PCI_MAPREG_START + 0x04);
		if (pci_mapreg_map(pa, PCI_MAPREG_START + 0x04, memtype, 0,
		    &sc->sc_iot_s5920, &sc->sc_ioh_s5920, NULL, &iosize2, 0)) {
			printf(": PCI2 %s region not found\n",
			    memtype == PCI_MAPREG_TYPE_IO ? "I/O" : "memory");

			/* unmap first mapped region as well if we fail */
			bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
			return;
		}
		sc->sc_read = mbg_read_amcc_s5920;
		sensor_task_register(sc, mbg_task, 10);
		break;
	case PCI_PRODUCT_MEINBERG_PCI511:
	case PCI_PRODUCT_MEINBERG_PEX511:
		sc->sc_read = mbg_read_asic;
		sensor_task_register(sc, mbg_task, 10);
		break;
	case PCI_PRODUCT_MEINBERG_GPS170PCI:
		t_trust = 4 * 24 * 60 * 60;	/* four days */
		sc->sc_read = mbg_read_asic;
		sensor_task_register(sc, mbg_task_hr, 1);
		break;
	default:
		/* this can not normally happen, but then there is murphy */
		panic(": unsupported product 0x%04x", PCI_PRODUCT(pa->pa_id));
		break;
	}

	sc->sc_trust = t_trust;

	if (sc->sc_read(sc, MBG_GET_TIME, (char *)&tframe,
	    sizeof(struct mbg_time), NULL)) {
		printf(": unknown status");
		sc->sc_signal.status = SENSOR_S_CRIT;
	} else {
		sc->sc_signal.status = SENSOR_S_OK;
		signal = tframe.signal - MBG_SIG_BIAS;
		if (signal < 0)
			signal = 0;
		else if (signal > MBG_SIG_MAX)
			signal = MBG_SIG_MAX;
		sc->sc_signal.value = signal;

		if (tframe.status & MBG_SYNC)
			printf(": synchronized");
		else
			printf(": not synchronized");
		if (tframe.status & MBG_FREERUN) {
			sc->sc_signal.status = SENSOR_S_WARN;
			printf(", free running");
		}
		if (tframe.status & MBG_IFTM)
			printf(", time set from host");
	}
#ifdef MBG_DEBUG
	if (sc->sc_read(sc, MBG_GET_FW_ID_1, fw_id, MBG_FIFO_LEN, NULL) ||
	    sc->sc_read(sc, MBG_GET_FW_ID_2, &fw_id[MBG_FIFO_LEN], MBG_FIFO_LEN,
	    NULL))
		printf(", firmware unknown");
	else {
		fw_id[MBG_ID_LEN - 1] = '\0';
		printf(", firmware %s", fw_id);
	}
#endif
	printf("\n");
	sensordev_install(&sc->sc_sensordev);
	timeout_add_sec(&sc->sc_timeout, sc->sc_trust);
}

/*
 * mbg_task() reads a timestamp from cards that to not provide a high
 * resolution timestamp.  The precision is limited to 1/100 sec.
 */
void
mbg_task(void *arg)
{
	struct mbg_softc *sc = (struct mbg_softc *)arg;
	struct mbg_time tframe;
	struct clock_ymdhms ymdhms;
	struct timespec tstamp;
	int64_t timedelta;
	time_t trecv;

	if (sc->sc_read(sc, MBG_GET_TIME, (char *)&tframe, sizeof(tframe),
	    &tstamp)) {
		sc->sc_signal.status = SENSOR_S_CRIT;
		return;
	}
	if (tframe.status & MBG_INVALID) {
		sc->sc_signal.status = SENSOR_S_CRIT;
		return;
	}
	ymdhms.dt_year = tframe.year + 2000;
	ymdhms.dt_mon = tframe.mon;
	ymdhms.dt_day = tframe.mday;
	ymdhms.dt_hour = tframe.hour;
	ymdhms.dt_min = tframe.min;
	ymdhms.dt_sec = tframe.sec;
	trecv = clock_ymdhms_to_secs(&ymdhms) - tframe.utc_off * 3600;

	timedelta = (int64_t)((tstamp.tv_sec - trecv) * 100
	    - tframe.hundreds) * 10000000LL + tstamp.tv_nsec;

	mbg_update_sensor(sc, &tstamp, timedelta, tframe.signal,
	    (u_int16_t)tframe.status);
}

/*
 * mbg_task_hr() reads a timestamp from cards that do provide a high
 * resolution timestamp.
 */
void
mbg_task_hr(void *arg)
{
	struct mbg_softc *sc = (struct mbg_softc *)arg;
	struct mbg_time_hr tframe;
	struct timespec tstamp;
	int64_t tlocal, trecv;

	if (sc->sc_read(sc, MBG_GET_TIME_HR, (char *)&tframe, sizeof(tframe),
	    &tstamp)) {
		sc->sc_signal.status = SENSOR_S_CRIT;
		return;
	}
	if (tframe.status & MBG_INVALID) {
		sc->sc_signal.status = SENSOR_S_CRIT;
		return;
	}

	tlocal = tstamp.tv_sec * NSECPERSEC + tstamp.tv_nsec;
	trecv = letoh32(tframe.sec) * NSECPERSEC +
	    (letoh32(tframe.frac) * NSECPERSEC >> 32);

	mbg_update_sensor(sc, &tstamp, tlocal - trecv, tframe.signal,
	    letoh16(tframe.status));
}

/* update the sensor value, common to all cards */
void
mbg_update_sensor(struct mbg_softc *sc, struct timespec *tstamp,
    int64_t timedelta, u_int8_t rsignal, u_int16_t status)
{
	int signal;

	sc->sc_timedelta.value = timedelta;
	sc->sc_timedelta.tv.tv_sec = tstamp->tv_sec;
	sc->sc_timedelta.tv.tv_usec = tstamp->tv_nsec / 1000;

	signal = rsignal - MBG_SIG_BIAS;
	if (signal < 0)
		signal = 0;
	else if (signal > MBG_SIG_MAX)
		signal = MBG_SIG_MAX;

	sc->sc_signal.value = signal * 100000 / MBG_SIG_MAX;
	sc->sc_signal.status = status & MBG_FREERUN ?
	    SENSOR_S_WARN : SENSOR_S_OK;
	sc->sc_signal.tv.tv_sec = sc->sc_timedelta.tv.tv_sec;
	sc->sc_signal.tv.tv_usec = sc->sc_timedelta.tv.tv_usec;
	if (!(status & MBG_FREERUN)) {
		sc->sc_timedelta.status = SENSOR_S_OK;
		timeout_add_sec(&sc->sc_timeout, sc->sc_trust);
	}
}

/*
 * send a command and read back results to an AMCC S5920 based card
 * (e.g. the PCI509 DCF77 radio clock)
 */
int
mbg_read_amcc_s5920(struct mbg_softc *sc, int cmd, char *buf, size_t len,
    struct timespec *tstamp)
{
	long timer, tmax;
	size_t quot, rem;
	u_int32_t ul;
	int n;
	u_int8_t status;

	quot = len / 4;
	rem = len % 4;

	/* write the command, optionally taking a timestamp */
	if (tstamp)
		nanotime(tstamp);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AMCC_OMB, cmd);

	/* wait for the BUSY flag to go low (approx 70 us on i386) */
	timer = 0;
	tmax = cold ? 50 : hz / 10;
	do {
		if (cold)
			delay(20);
		else
			tsleep(tstamp, 0, "mbg", 1);
		status = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    AMCC_IMB4 + 3);
	} while ((status & MBG_BUSY) && timer++ < tmax);

	if (status & MBG_BUSY)
		return -1;

	/* read data from the device */
	if (len) {
		for (n = 0; n < quot; n++) {
			*(u_int32_t *)buf = bus_space_read_4(sc->sc_iot_s5920,
			    sc->sc_ioh_s5920, AMCC_DATA);
			buf += sizeof(u_int32_t);
		}
		if (rem) {
			ul =  bus_space_read_4(sc->sc_iot_s5920,
			    sc->sc_ioh_s5920, AMCC_DATA);
			for (n = 0; n < rem; n++)
				*buf++ = *((char *)&ul + n);
		}
	} else
		bus_space_read_4(sc->sc_iot_s5920, sc->sc_ioh_s5920, AMCC_DATA);
	return 0;
}

/*
 * send a command and read back results to an AMCC S5933 based card
 * (e.g. the PCI32 DCF77 radio clock)
 */
int
mbg_read_amcc_s5933(struct mbg_softc *sc, int cmd, char *buf, size_t len,
    struct timespec *tstamp)
{
	long timer, tmax;
	size_t n;
	u_int8_t status;

	/* reset inbound mailbox and clear FIFO status */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AMCC_MCSR + 3, 0x0c);

	/* set FIFO */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AMCC_INTCSR + 3, 0x3c);

	/* write the command, optionally taking a timestamp */
	if (tstamp)
		nanotime(tstamp);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AMCC_OMB1, cmd);

	/* wait for the BUSY flag to go low (approx 70 us on i386) */
	timer = 0;
	tmax = cold ? 50 : hz / 10;
	do {
		if (cold)
			delay(20);
		else
			tsleep(tstamp, 0, "mbg", 1);
		status = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    AMCC_IMB4 + 3);
	} while ((status & MBG_BUSY) && timer++ < tmax);

	if (status & MBG_BUSY)
		return -1;

	/* read data from the device FIFO */
	for (n = 0; n < len; n++) {
		if (bus_space_read_2(sc->sc_iot, sc->sc_ioh, AMCC_MCSR)
		    & 0x20) {
			return -1;
		}
		buf[n] = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    AMCC_FIFO + (n % 4));
	}
	return 0;
}

/*
 * send a command and read back results to an ASIC based card
 * (e.g. the PCI511 DCF77 radio clock)
 */
int
mbg_read_asic(struct mbg_softc *sc, int cmd, char *buf, size_t len,
    struct timespec *tstamp)
{
	long timer, tmax;
	size_t n;
	u_int32_t data;
	u_int16_t port;
	char *p = buf;
	u_int8_t status;
	int s;

	/* write the command, optionally taking a timestamp */
	if (tstamp) {
		s = splhigh();
		nanotime(tstamp);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, ASIC_DATA, cmd);
		splx(s);
	} else
		bus_space_write_4(sc->sc_iot, sc->sc_ioh, ASIC_DATA, cmd);

	/* wait for the BUSY flag to go low */
	timer = 0;
	tmax = cold ? 50 : hz / 10;
	do {
		if (cold)
			delay(20);
		else
			tsleep(tstamp, 0, "mbg", 1);
		status = bus_space_read_1(sc->sc_iot, sc->sc_ioh, ASIC_STATUS);
	} while ((status & MBG_BUSY) && timer++ < tmax);

	if (status & MBG_BUSY)
		return -1;

	/* read data from the device FIFO */
	port = ASIC_ADDON;
	for (n = 0; n < len / 4; n++) {
		data = bus_space_read_4(sc->sc_iot, sc->sc_ioh, port);
		*(u_int32_t *)p = data;
		p += sizeof(data);
		port += sizeof(data);
	}

	if (len % 4) {
		data = bus_space_read_4(sc->sc_iot, sc->sc_ioh, port);
		for (n = 0; n < len % 4; n++) {
			*p++ = data & 0xff;
			data >>= 8;
		}
	}
	return 0;
}

/*
 * degrade the sensor state if we are feerunning for more than
 * sc->sc_trust seconds.
 */
void
mbg_timeout(void *xsc)
{
	struct mbg_softc *sc = xsc;

	if (sc->sc_timedelta.status == SENSOR_S_OK) {
		sc->sc_timedelta.status = SENSOR_S_WARN;
		/*
		 * further degrade in sc->sc_trust seconds if no new valid
		 * time data can be read from the device.
		 */
		timeout_add_sec(&sc->sc_timeout, sc->sc_trust);
	} else
		sc->sc_timedelta.status = SENSOR_S_CRIT;
}
@


1.29
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.28 2009/04/26 02:20:58 cnst Exp $ */
a18 1
#include <sys/types.h>
@


1.28
log
@in ca_attach() there is no need to set .value and .flags of sensors to 0,
since autoconf(9) allocates softc with M_ZERO;  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.27 2008/11/23 14:19:40 mbalmer Exp $ */
d23 1
a23 1
#include <sys/proc.h>
@


1.27
log
@Use the new and shiny nitems().
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.26 2008/11/22 15:05:24 mbalmer Exp $ */
a210 2
	sc->sc_timedelta.value = 0LL;
	sc->sc_timedelta.flags = 0;
a214 2
	sc->sc_signal.value = 0LL;
	sc->sc_signal.flags = 0;
@


1.26
log
@Fix a wrong comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.25 2008/09/10 14:01:23 blambert Exp $ */
d171 1
a171 1
	    sizeof(mbg_devices) / sizeof(mbg_devices[0]));
@


1.25
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.24 2007/11/26 19:44:43 mbalmer Exp $ */
d565 2
a566 2
 * Degrade the sensor state if we are feerunning for more than
 * TRUSTTIME seconds.
d576 2
a577 2
		 * further degrade in TRUSTTIME seconds if no new valid NMEA
		 * sentences are received.
@


1.24
log
@Automatically degrade the timedelta sensor if the clock is free running for to
long (12 hours for most cards, four days for the ones with higher precision
local clocks, e.g. the GPS170PCI).

All radio-clock drivers now behave more or less the same with regarding to
timedelta sensor degradation;  time to implement a few new drivers...
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.23 2007/11/12 16:40:46 mbalmer Exp $ */
d51 1
a51 1
	int			sc_trust;	/* trust time in ticks */
a179 1
	struct timeval tv_trust;
d264 1
a264 3
	tv_trust.tv_sec = t_trust;
	tv_trust.tv_usec = 0L;
	sc->sc_trust = tvtohz(&tv_trust);
d302 1
a302 1
	timeout_add(&sc->sc_timeout, sc->sc_trust);
d397 1
a397 1
		timeout_add(&sc->sc_timeout, sc->sc_trust);
d579 1
a579 1
		timeout_add(&sc->sc_timeout, sc->sc_trust);
@


1.23
log
@Don't use utc_off when using the hires timestamp.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.22 2007/11/11 15:30:26 mbalmer Exp $ */
d50 3
a52 1

d149 1
d180 1
d183 1
a183 1
	int bar = PCI_MAPREG_START, signal;
d189 2
d211 1
d223 2
d255 1
d265 4
d305 1
a383 1
	sc->sc_timedelta.status = SENSOR_S_OK;
d398 4
d565 20
@


1.22
log
@Remove all code that prints to the console or writes to the log after
initialization.  The behaviour of the Signal sensor is now the same as
for umbg(4), the sensor status indicates if the clock is synchronized,
free running or if there is a hardware problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.21 2007/11/07 09:56:22 mbalmer Exp $ */
d71 1
a71 1
	u_int32_t		sec;		/* seconds since the epoch */
d73 1
a73 1
	int32_t			utc_off;	/* UTC offset in seconds */
d354 1
a354 1
	trecv = (letoh32(tframe.sec) - letoh32(tframe.utc_off)) * NSECPERSEC +
@


1.21
log
@Fix a comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.20 2007/11/05 19:58:29 mbalmer Exp $ */
a49 1
	u_int8_t		sc_status;
d86 1
a86 4
#define MBG_INVALID		0x80	/* time is invalid */

/* status bits we are interested in */
#define MBG_STATMASK		(MBG_FREERUN | MBG_SYNC | MBG_IFTM)
d140 1
a140 1
	    int64_t timedelta, u_int8_t rsignal, u_int8_t status);
d179 1
a179 1
	int bar = PCI_MAPREG_START;
a204 1
	sc->sc_timedelta.status = SENSOR_S_UNKNOWN;
d213 1
a213 2
	strlcpy(sc->sc_signal.desc, "Signal strength",
	    sizeof(sc->sc_signal.desc));
a214 1
	sensordev_install(&sc->sc_sensordev);
d258 1
a258 1
		sc->sc_status = 0;
d260 8
a267 1
		tframe.status &= MBG_STATMASK;
d272 2
a273 1
		if (tframe.status & MBG_FREERUN)
d275 1
a277 1
		sc->sc_status = tframe.status;
d290 1
d295 1
a295 2
 * resolution timestamp.  The precision is limited to 1/100 sec. in this
 * case.
d309 1
a309 1
		log(LOG_ERR, "%s: error reading time\n", sc->sc_dev.dv_xname);
d313 1
a313 2
		log(LOG_INFO, "%s: invalid time, battery was disconnected\n",
		    sc->sc_dev.dv_xname);
d328 1
a328 1
	    tframe.status);
d345 1
a345 2
		log(LOG_ERR, "%s: error reading hi-res time\n",
		    sc->sc_dev.dv_xname);
d349 1
a349 2
		log(LOG_INFO, "%s: invalid time, battery was disconnected\n",
		    sc->sc_dev.dv_xname);
d354 2
a355 1
	trecv = tframe.sec * NSECPERSEC + (tframe.frac * NSECPERSEC >> 32);
d358 1
a358 1
	    tframe.status);
d364 1
a364 1
    int64_t timedelta, u_int8_t rsignal, u_int8_t status)
d380 2
a381 1
	sc->sc_signal.status = SENSOR_S_OK;
a383 14

	status &= MBG_STATMASK;
	if (status != sc->sc_status) {
		if (status & MBG_SYNC)
			log(LOG_INFO, "%s: clock is synchronized",
			    sc->sc_dev.dv_xname);
		if (status & MBG_FREERUN)
			log(LOG_INFO, "%s: clock is free running",
			    sc->sc_dev.dv_xname);
		if (status & MBG_IFTM)
			log(LOG_INFO, "%s: time set from host",
			    sc->sc_dev.dv_xname);
		sc->sc_status = status;
	}
a482 1
			printf("%s: FIFO error\n", sc->sc_dev.dv_xname);
@


1.20
log
@Add support for the Meinberg PEX511 PCI Express DCF77 radio clock.
Only print firmware ID when compiled with -DMBG_DEBUG, as suggested by
miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.19 2007/11/04 13:31:21 mbalmer Exp $ */
d137 1
a137 1
#define HRDIVISOR		0x100000000LL	/ for hi-res timestamp */
@


1.19
log
@Add support for the Meinberg PCI509 5V DCF77 time signal station receiver.

With feedback from kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.18 2007/10/25 08:24:55 mbalmer Exp $ */
d164 2
a165 1
	{ PCI_VENDOR_MEINBERG, PCI_PRODUCT_MEINBERG_PCI511 }
d183 3
d187 5
a191 1
	const char *desc;
d193 2
a194 2
	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, PCI_MAPREG_START);
	if (pci_mapreg_map(pa, PCI_MAPREG_START, memtype, 0, &sc->sc_iot,
d248 1
a259 8
	}	
	if (sc->sc_read(sc, MBG_GET_FW_ID_1, fw_id, MBG_FIFO_LEN, NULL) ||
	    sc->sc_read(sc, MBG_GET_FW_ID_2, &fw_id[MBG_FIFO_LEN], MBG_FIFO_LEN,
	    NULL))
		printf(": firmware unknown");
	else {
		fw_id[MBG_ID_LEN - 1] = '\0';
		printf(": firmware %s", fw_id);
d264 1
a264 1
		printf(", unknown status");
d269 1
a269 1
			printf(", synchronized");
d271 1
a271 1
			printf(", not synchronized");
d278 10
@


1.18
log
@Factor out common code to update the timedelta sensor into
mbg_update_sensor().
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d40 7
d90 6
a95 1
#define MBG_STATMASK		(MBG_FREERUN | MBG_SYNC | MBG_LEAP | MBG_IFTM)
d117 3
d124 6
d145 2
d163 1
d181 1
a181 1
	bus_size_t iosize;
d220 19
d269 2
d272 1
a272 3
			printf(", free running on xtal");
		if (tframe.status & MBG_LEAP)
			printf(", leap second");
d282 1
a282 1
 * resolution timestamp.  The precsion is limited to 1/100 sec. in this
d321 1
a321 1
 * mbg_task_hr() reads a timestamp from cars that do provide  high
d380 1
a380 4
			log(LOG_INFO, "%s: clock is free running on xtal",
			    sc->sc_dev.dv_xname);
		if (status & MBG_LEAP)
			log(LOG_INFO, "%s: leap second announced",
d390 55
d446 1
a446 1
 * (i.e. the PCI32 DCF77 radio clock)
d497 1
a497 1
 * (i.e. the PCI511 DCF77 radio clock)
d506 1
a507 1
	u_int16_t port;
@


1.17
log
@Define a bitmaks of status bits we're interested in, output/log all
relevant status bits, not only the first one.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.16 2007/10/23 07:51:55 mbalmer Exp $ */
d122 2
d237 5
d249 1
a250 1
	int signal;
d270 1
a270 1
	sc->sc_timedelta.value = (int64_t)((tstamp.tv_sec - trecv) * 100
a271 14
	sc->sc_timedelta.status = SENSOR_S_OK;
	sc->sc_timedelta.tv.tv_sec = tstamp.tv_sec;
	sc->sc_timedelta.tv.tv_usec = tstamp.tv_nsec / 1000;

	signal = tframe.signal - MBG_SIG_BIAS;
	if (signal < 0)
		signal = 0;
	else if (signal > MBG_SIG_MAX)
		signal = MBG_SIG_MAX;

	sc->sc_signal.value = signal * 100000 / MBG_SIG_MAX;
	sc->sc_signal.status = SENSOR_S_OK;
	sc->sc_signal.tv.tv_sec = sc->sc_timedelta.tv.tv_sec;
	sc->sc_signal.tv.tv_usec = sc->sc_timedelta.tv.tv_usec;
d273 2
a274 16
	tframe.status &= MBG_STATMASK;
	if (tframe.status != sc->sc_status) {
		if (tframe.status & MBG_SYNC)
			log(LOG_INFO, "%s: clock is synchronized",
			    sc->sc_dev.dv_xname);
		if (tframe.status & MBG_FREERUN)
			log(LOG_INFO, "%s: clock is free running on xtal",
			    sc->sc_dev.dv_xname);
		if (tframe.status & MBG_LEAP)
			log(LOG_INFO, "%s: leap second announced",
			    sc->sc_dev.dv_xname);
		if (tframe.status & MBG_IFTM)
			log(LOG_INFO, "%s: time set from host",
			    sc->sc_dev.dv_xname);
		sc->sc_status = tframe.status;
	}
d277 4
a287 1
	int signal;
d304 10
a313 1
	sc->sc_timedelta.value = tlocal - trecv;
d315 1
d317 2
a318 2
	sc->sc_timedelta.tv.tv_sec = tstamp.tv_sec;
	sc->sc_timedelta.tv.tv_usec = tstamp.tv_nsec / 1000;
d320 1
a320 1
	signal = tframe.signal - MBG_SIG_BIAS;
d331 3
a333 3
	tframe.status &= MBG_STATMASK;
	if (tframe.status != sc->sc_status) {
		if (tframe.status & MBG_SYNC)
d336 1
a336 1
		else if (tframe.status & MBG_FREERUN)
d339 1
a339 1
		if (tframe.status & MBG_LEAP)
d342 1
a342 1
		if (tframe.status & MBG_IFTM)
d345 1
a345 1
		sc->sc_status = tframe.status;
@


1.16
log
@Don't spam the console when there is no antenna connected.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.15 2007/10/08 09:23:01 mbalmer Exp $ */
d81 4
a84 1
 
d210 1
a210 1
		printf(": firmware unknown, ");
d213 1
a213 1
		printf(": firmware %s, ", fw_id);
d218 1
a218 1
		printf("unknown status\n");
d221 3
a223 2
		/* We only look at selected bits in the status */
		tframe.status &= (MBG_SYNC | MBG_FREERUN | MBG_INVALID);
d225 5
a229 5
			printf("free running on xtal\n");
		else if (tframe.status & MBG_SYNC)
			printf("synchronised\n");
		else if (tframe.status & MBG_INVALID)
			printf("invalid\n");
d232 1
d280 1
a280 2
	/* We only look at the SYNC, FREERUN, and INVALID bits in the status */
	tframe.status &= (MBG_SYNC | MBG_FREERUN | MBG_INVALID);
d285 1
a285 1
		else if (tframe.status & MBG_FREERUN)
d288 5
a292 2
		else if (tframe.status & MBG_INVALID)
			log(LOG_INFO, "%s: clock is invalid",
d339 1
a339 2
	/* We only look at the SYNC, FREERUN, and INVALID bits in the status */
	tframe.status &= (MBG_SYNC | MBG_FREERUN | MBG_INVALID);
d347 5
a351 2
		else if (tframe.status & MBG_INVALID)
			log(LOG_INFO, "%s: clock is invalid",
@


1.15
log
@GPS170 -> GPS170PCI
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.14 2007/09/30 19:58:43 mbalmer Exp $ */
d218 2
d275 2
d284 3
d332 2
d340 3
@


1.14
log
@Add support for the high-resulution timer found in the GPS170PCI card.

Thanks for otto@@ for looking at the time calculations
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.13 2007/03/22 16:55:31 deraadt Exp $ */
d133 1
a133 1
	{ PCI_VENDOR_MEINBERG, PCI_PRODUCT_MEINBERG_GPS170 },
d195 1
a195 1
	case PCI_PRODUCT_MEINBERG_GPS170:
@


1.13
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.12 2007/01/03 13:27:12 mbalmer Exp $ */
d4 1
a4 1
 * Copyright (c) 2006 Marc Balmer <mbalmer@@openbsd.org>
d56 1
a56 1
	u_int8_t		wday;
d58 1
a58 1
	u_int8_t		year;
d64 8
d101 1
a101 1
#define MBG_GET_HR_TIME		0x03
d112 2
d118 1
d168 18
d189 1
d192 3
a194 1
		/* FALLTHROUGH */
d197 1
a225 20

	strlcpy(sc->sc_sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));

	sc->sc_timedelta.type = SENSOR_TIMEDELTA;
	sc->sc_timedelta.status = SENSOR_S_UNKNOWN;
	sc->sc_timedelta.value = 0LL;
	sc->sc_timedelta.flags = 0;
	sensor_attach(&sc->sc_sensordev, &sc->sc_timedelta);

	sc->sc_signal.type = SENSOR_PERCENT;
	sc->sc_signal.status = SENSOR_S_UNKNOWN;
	sc->sc_signal.value = 0LL;
	sc->sc_signal.flags = 0;
	strlcpy(sc->sc_signal.desc, "Signal strength",
	    sizeof(sc->sc_signal.desc));
	sensor_attach(&sc->sc_sensordev, &sc->sc_signal);

	sensor_task_register(sc, mbg_task, 10);
	sensordev_install(&sc->sc_sensordev);
d258 52
@


1.12
log
@mbg(4) cards with ASIC take the internal timestamp at the very moment the
first command byte is written to the card over the pci bus.  the driver has
to capture this moment to get a precise timedelta.  so make sure the code
fragment that takes the internal timestamp and sends the command byte can not
be interrupted.

this function is called with a low frequency (currently 0.1 Hz).

ok claudio, mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.11 2007/01/02 19:25:02 mbalmer Exp $ */
d40 3
a42 3
	struct sensor		sc_timedelta;
	struct sensor		sc_signal;
	struct sensordev	sc_sensordev;
@


1.11
log
@Use the value returned by pci_findproduct() as the timedelta sensor description
instead of using static strings.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.10 2006/12/30 23:44:58 mbalmer Exp $ */
d336 1
d339 2
a340 1
	if (tstamp)
d342 4
a345 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, ASIC_DATA, cmd);
@


1.10
log
@Use the same PCI product name strings we have in pcidevs_data.h for the
timedelta sensor desc field and not the full description produced by
pci_devinfo() (which gets truncated in this case).  There is no need to
have the PCi vendor string in the description as this is apparent from the
driver name already.

problem noticed by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.9 2006/12/29 16:26:18 mbalmer Exp $ */
d143 1
d153 4
a158 2
		strlcpy(sc->sc_timedelta.desc, "PCI32",
		    sizeof(sc->sc_timedelta.desc));
d162 1
a162 4
		strlcpy(sc->sc_timedelta.desc, "PCI511",
		    sizeof(sc->sc_timedelta.desc));
		sc->sc_read = mbg_read_asic;
		break;
a163 2
		strlcpy(sc->sc_timedelta.desc, "GPS170",
		    sizeof(sc->sc_timedelta.desc));
a170 1

@


1.9
log
@Sort product ids alphabetically like jmc did in the manpage.  fkr also
suggested that.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.8 2006/12/29 10:55:30 mbalmer Exp $ */
d154 2
d159 4
a162 1
		/* FALLTHROUGH */
d164 2
a203 7
#ifdef PCIVERBOSE
	pci_devinfo(pa->pa_id, pa->pa_class, 0, sc->sc_timedelta.desc,
 	    sizeof(sc->sc_timedelta.desc));
#else
	strlcpy(sc->sc_timedelta.desc, "Radio clock",
	    sizeof(sc->sc_timedelta.desc));
#endif
@


1.8
log
@Add support for the Meinberg PCI511 and GPS170PCI cards.

"put it in" deraadt, ok fkr
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.7 2006/12/23 17:46:39 deraadt Exp $ */
d122 1
d124 1
a124 2
	{ PCI_VENDOR_MEINBERG, PCI_PRODUCT_MEINBERG_PCI511 },
	{ PCI_VENDOR_MEINBERG, PCI_PRODUCT_MEINBERG_GPS170 }
@


1.7
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.6 2006/12/22 09:04:42 mbalmer Exp $ */
d44 4
d79 10
a88 1
#define	AMCC_MCSR		0x3c	/* master control/status register */
d101 1
a101 1
#define	MBG_BUSY		0x01
d107 4
a110 1
int	mbg_read(struct mbg_softc *, int cmd, char *buf, size_t len,
a111 1
void	mbg_task(void *);
d122 3
a124 1
	{ PCI_VENDOR_MEINBERG, PCI_PRODUCT_MEINBERG_PCI32 }
d152 17
a168 2
	if (mbg_read(sc, MBG_GET_FW_ID_1, fw_id, MBG_FIFO_LEN, NULL) ||
	    mbg_read(sc, MBG_GET_FW_ID_2, &fw_id[MBG_FIFO_LEN], MBG_FIFO_LEN,
d176 1
a176 1
	if (mbg_read(sc, MBG_GET_TIME, (char *)&tframe,
d197 7
a203 1
	strlcpy(sc->sc_timedelta.desc, "DCF77", sizeof(sc->sc_timedelta.desc));
a214 1

d228 1
a228 1
	if (mbg_read(sc, MBG_GET_TIME, (char *)&tframe, sizeof(tframe),
d230 1
a230 2
		log(LOG_ERR, "%s: error reading time\n",
		    sc->sc_dev.dv_xname);
d274 4
d279 1
a279 1
mbg_read(struct mbg_softc *sc, int cmd, char *buf, size_t len,
d321 53
@


1.6
log
@fold long lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.5 2006/12/22 07:19:20 deraadt Exp $ */
d42 1
d157 4
a160 2
	strlcpy(sc->sc_timedelta.device, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_timedelta.device));
d166 1
a166 1
	sensor_add(&sc->sc_timedelta);
a167 2
	strlcpy(sc->sc_signal.device, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_signal.device));
d174 1
a174 1
	sensor_add(&sc->sc_signal);
d177 2
@


1.5
log
@shorten code
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.4 2006/12/22 07:10:43 deraadt Exp $ */
d171 2
a172 1
	strlcpy(sc->sc_signal.desc, "Signal strength", sizeof(sc->sc_signal.desc));
d262 2
a263 1
		status = bus_space_read_1(sc->sc_iot, sc->sc_ioh, AMCC_IMB4 + 3);
d271 2
a272 1
		if (bus_space_read_2(sc->sc_iot, sc->sc_ioh, AMCC_MCSR) & 0x20) {
@


1.4
log
@make driver look more like others do; ok mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.3 2006/12/18 17:50:39 deraadt Exp $ */
d129 1
a129 2
		printf("\n%s: PCI %s region not found\n",
		    sc->sc_dev.dv_xname,
@


1.3
log
@delete extra goo
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.2 2006/12/18 07:58:22 mbalmer Exp $ */
d36 7
a42 7
	struct device		mbg_dev;
	bus_space_tag_t		iot;
	bus_space_handle_t	ioh;

	struct sensor		timedelta;
	struct sensor		signal;
	u_int8_t		status;
d94 1
a94 1
    struct timespec *tstamp);
d119 1
a119 1
	struct mbg_softc *mbg = (struct mbg_softc *)self;
d127 2
a128 2
	if (pci_mapreg_map(pa, PCI_MAPREG_START, memtype, 0, &mbg->iot,
	    &mbg->ioh, NULL, &iosize, 0)) {
d130 1
a130 1
		    mbg->mbg_dev.dv_xname,
d135 2
a136 2
	if (mbg_read(mbg, MBG_GET_FW_ID_1, fw_id, MBG_FIFO_LEN, NULL) ||
	    mbg_read(mbg, MBG_GET_FW_ID_2, &fw_id[MBG_FIFO_LEN], MBG_FIFO_LEN,
d144 1
a144 1
	if (mbg_read(mbg, MBG_GET_TIME, (char *)&tframe,
d147 1
a147 1
		mbg->status = 0;
d155 1
a155 1
		mbg->status = tframe.status;
d157 17
a173 17
	strlcpy(mbg->timedelta.device, mbg->mbg_dev.dv_xname,
	    sizeof(mbg->timedelta.device));
	mbg->timedelta.type = SENSOR_TIMEDELTA;
	mbg->timedelta.status = SENSOR_S_UNKNOWN;
	mbg->timedelta.value = 0LL;
	mbg->timedelta.flags = 0;
	strlcpy(mbg->timedelta.desc, "DCF77", sizeof(mbg->timedelta.desc));
	sensor_add(&mbg->timedelta);

	strlcpy(mbg->signal.device, mbg->mbg_dev.dv_xname,
	    sizeof(mbg->signal.device));
	mbg->signal.type = SENSOR_PERCENT;
	mbg->signal.status = SENSOR_S_UNKNOWN;
	mbg->signal.value = 0LL;
	mbg->signal.flags = 0;
	strlcpy(mbg->signal.desc, "Signal strength", sizeof(mbg->signal.desc));
	sensor_add(&mbg->signal);
d175 1
a175 1
	sensor_task_register(mbg, mbg_task, 10);
d181 1
a181 1
	struct mbg_softc *mbg = (struct mbg_softc *)arg;
d188 1
a188 1
	if (mbg_read(mbg, MBG_GET_TIME, (char *)&tframe, sizeof(tframe),
d191 1
a191 1
		    mbg->mbg_dev.dv_xname);
d195 2
a196 2
		log(LOG_INFO, "%s: inavlid time, battery was disconnected\n",
		    mbg->mbg_dev.dv_xname);
d207 1
a207 1
	mbg->timedelta.value = (int64_t)((tstamp.tv_sec - trecv) * 100
d209 3
a211 3
	mbg->timedelta.status = SENSOR_S_OK;
	mbg->timedelta.tv.tv_sec = tstamp.tv_sec;
	mbg->timedelta.tv.tv_usec = tstamp.tv_nsec / 1000;
d219 4
a222 4
	mbg->signal.value = signal * 100000 / MBG_SIG_MAX;
	mbg->signal.status = SENSOR_S_OK;
	mbg->signal.tv.tv_sec = mbg->timedelta.tv.tv_sec;
	mbg->signal.tv.tv_usec = mbg->timedelta.tv.tv_usec;
d224 1
a224 1
	if (tframe.status != mbg->status) {
d227 1
a227 1
			    mbg->mbg_dev.dv_xname);
d230 2
a231 2
			    mbg->mbg_dev.dv_xname);
		mbg->status = tframe.status;
d236 1
a236 1
mbg_read(struct mbg_softc *mbg, int cmd, char *buf, size_t len,
d244 1
a244 1
	bus_space_write_1(mbg->iot, mbg->ioh, AMCC_MCSR + 3, 0x0c);
d247 1
a247 1
	bus_space_write_1(mbg->iot, mbg->ioh, AMCC_INTCSR + 3, 0x3c);
d252 1
a252 1
	bus_space_write_1(mbg->iot, mbg->ioh, AMCC_OMB1, cmd);
d262 1
a262 1
		status = bus_space_read_1(mbg->iot, mbg->ioh, AMCC_IMB4 + 3);
d270 2
a271 2
		if (bus_space_read_2(mbg->iot, mbg->ioh, AMCC_MCSR) & 0x20) {
			printf("%s: FIFO error\n", mbg->mbg_dev.dv_xname);
d274 1
a274 1
		buf[n] = bus_space_read_1(mbg->iot, mbg->ioh,
@


1.2
log
@Format dmesg line according to our rules and make sure the firmware id
string is '\0' terminated, plus some KNF.

from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mbg.c,v 1.1 2006/12/17 16:32:35 mbalmer Exp $ */
d138 1
a138 1
		printf(": firmware unknown, ", mbg->mbg_dev.dv_xname);
@


1.1
log
@mbg(4), a driver for Meinberg Funkuhren time signal station receivers
"Made in Switzerland"

Currently, the DCF77 PCI32 receiver card is supported

I have to mention the outstanding support from Meinberg, not only did they
give me the hardware, docs, and reference source code, but they even call
me back to explain the details of their hardware to me.  If only the wireless
manufacturors were that cooperative...

ok claudio, ok mglocker, "commit it when ready" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d91 3
a93 3
int mbg_probe(struct device *, void *, void *);
void mbg_attach(struct device *, struct device *, void *);
int mbg_read(struct mbg_softc *, int cmd, char *buf, size_t len,
d95 1
a95 1
void mbg_task(void *);
d138 5
a142 4
		printf(" (unknown firmware),",
		    mbg->mbg_dev.dv_xname);
	else
		printf(" (%s),", fw_id);
d146 1
a146 1
		printf(" unknown status\n");
d150 1
a150 1
			printf(" free running on xtal");
d152 1
a152 1
			printf(" synchronised");
d154 1
a154 2
			printf(" invalid");
		printf("\n");
d263 1
a263 1
	} while (status & MBG_BUSY && timer++ < tmax);
@

