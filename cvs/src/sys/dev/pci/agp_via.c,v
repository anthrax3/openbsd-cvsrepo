head	1.20;
access;
symbols
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.14
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.12
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.8
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.6
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.17.0.12
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.8
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.6
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.4
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.2
	OPENBSD_5_0:1.16.0.6
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.24
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.22
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.20
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.18
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.16
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.14
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.12
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.10
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.2
	SMP:1.2.0.8
	OPENBSD_3_3:1.2.0.6
	OPENBSD_3_3_BASE:1.2
	UBC:1.2.0.4
	UBC_SYNC_B:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.20
date	2014.05.27.12.40.00;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2014.03.26.14.41.41;	author mpi;	state Exp;
branches;
next	1.18;

1.18
date	2014.03.17.22.01.56;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2011.10.16.01.11.31;	author dhill;	state Exp;
branches;
next	1.16;

1.16
date	2010.08.07.19.31.23;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2009.05.10.16.57.44;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2009.05.10.15.28.45;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2009.05.10.14.44.42;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.04.20.47.35;	author grange;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.09.22.47.54;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.09.15.11.19;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2007.12.07.17.35.22;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2007.12.06.22.49.39;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2007.11.26.15.35.15;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.25.17.11.12;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.06.23.50.54;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.04.19.40.25;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.25.23.31.04;	author fgsch;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2002.07.12.20.17.03;	author mickey;	state Exp;
branches;
next	;

1.2.4.1
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@We're never going to detach agp(4), so remove the #ifdef'ed out code like we
already did for intagp(4).
@
text
@/*	$OpenBSD: agp_via.c,v 1.19 2014/03/26 14:41:41 mpi Exp $	*/
/*	$NetBSD: agp_via.c,v 1.2 2001/09/15 00:25:00 thorpej Exp $	*/

/*-
 * Copyright (c) 2000 Doug Rabson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$FreeBSD: src/sys/pci/agp_via.c,v 1.3 2001/07/05 21:28:47 jhb Exp $
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/rwlock.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/vga_pcivar.h>
#include <dev/pci/agpvar.h>
#include <dev/pci/agpreg.h>

#include <machine/bus.h>

struct agp_via_softc {
	struct device		 dev;
	struct agp_softc	*agpdev;
	struct agp_gatt		*gatt;
	int			*regs;
	pci_chipset_tag_t	 vsc_pc;
	pcitag_t		 vsc_tag;
	bus_addr_t		 vsc_apaddr;
	bus_size_t		 vsc_apsize;
	pcireg_t		 vsc_regapsize;
	pcireg_t		 vsc_regattbase;
	pcireg_t                 vsc_reggartctl;
};

void	agp_via_attach(struct device *, struct device *, void *);
int	agp_via_activate(struct device *, int);
void	agp_via_save(struct agp_via_softc *);
void	agp_via_restore(struct agp_via_softc *);
int	agp_via_probe(struct device *, void *, void *);
bus_size_t agp_via_get_aperture(void *);
int	agp_via_set_aperture(void *, bus_size_t);
void	agp_via_bind_page(void *, bus_addr_t, paddr_t, int);
void	agp_via_unbind_page(void *, bus_addr_t);
void	agp_via_flush_tlb(void *);

const struct agp_methods agp_via_methods = {
	agp_via_bind_page,
	agp_via_unbind_page,
	agp_via_flush_tlb,
};

struct cfattach viaagp_ca = {
	sizeof(struct agp_via_softc), agp_via_probe, agp_via_attach,
	NULL, agp_via_activate
};

struct cfdriver viaagp_cd = {
	NULL, "viaagp", DV_DULL
};

#define REG_GARTCTRL	0
#define REG_APSIZE	1
#define REG_ATTBASE	2

int via_v2_regs[] =
	{ AGP_VIA_GARTCTRL, AGP_VIA_APSIZE, AGP_VIA_ATTBASE };
int via_v3_regs[] =
	{ AGP3_VIA_GARTCTRL, AGP3_VIA_APSIZE, AGP3_VIA_ATTBASE };

int
agp_via_probe(struct device *parent, void *match, void *aux)
{
	struct agp_attach_args	*aa = aux;
	struct pci_attach_args	*pa = aa->aa_pa;

	/* Must be a pchb don't attach to iommu-style agp devs */
	if (agpbus_probe(aa) == 1 &&
	    PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VIATECH &&
	    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_VIATECH_K8M800_0 &&
	    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_VIATECH_K8T890_0 &&
	    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_VIATECH_K8HTB_0 &&
	    PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_VIATECH_K8HTB)
		return (1);
	return (0);
}

void
agp_via_attach(struct device *parent, struct device *self, void *aux)
{
	struct agp_via_softc	*vsc = (struct agp_via_softc *)self;
	struct agp_attach_args	*aa = aux;
	struct pci_attach_args	*pa = aa->aa_pa;
	struct agp_gatt		*gatt;
	pcireg_t		 agpsel, capval;

	vsc->vsc_pc = pa->pa_pc;
	vsc->vsc_tag = pa->pa_tag;
	pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_AGP, NULL, &capval);

	if (pci_mapreg_info(pa->pa_pc, pa->pa_tag, AGP_APBASE,
	    PCI_MAPREG_TYPE_MEM, &vsc->vsc_apaddr, NULL, NULL) != 0) {
		printf(": can't get aperture info\n");
		return;
	}

	if (AGP_CAPID_GET_MAJOR(capval) >= 3) {
		agpsel = pci_conf_read(pa->pa_pc, pa->pa_tag,
				AGP_VIA_AGPSEL_REG);
		if ((agpsel & (1 << 9)) == 0) {
			vsc->regs = via_v3_regs;
			printf(": v3");
		} else {
			vsc->regs = via_v2_regs;
			printf(": v2 compat mode");
		}
	} else {
		vsc->regs = via_v2_regs;
		printf(": v2");
	}


	vsc->vsc_apsize = agp_via_get_aperture(vsc);

	for (;;) {
		gatt = agp_alloc_gatt(pa->pa_dmat, vsc->vsc_apsize);
		if (gatt != NULL)
			break;

		/*
		 * Probably failed to alloc congigious memory. Try reducing the
		 * aperture so that the gatt size reduces.
		 */
		vsc->vsc_apsize /= 2;
		if (agp_via_set_aperture(vsc, vsc->vsc_apsize)) {
			printf(", can't set aperture size\n");
			return;
		}
	}
	vsc->gatt = gatt;

	if (vsc->regs == via_v2_regs) {
		/* Install the gatt. */
		pci_conf_write(pa->pa_pc, pa->pa_tag, vsc->regs[REG_ATTBASE],
		    gatt->ag_physical | 3);
		/* Enable the aperture. */
		pci_conf_write(pa->pa_pc, pa->pa_tag, vsc->regs[REG_GARTCTRL],
		    0x0000000f);
	} else {
		pcireg_t gartctrl;
		/* Install the gatt. */
		pci_conf_write(pa->pa_pc, pa->pa_tag, vsc->regs[REG_ATTBASE],
		    gatt->ag_physical);
		/* Enable the aperture. */
		gartctrl = pci_conf_read(pa->pa_pc, pa->pa_tag,
		    vsc->regs[REG_ATTBASE]);
		pci_conf_write(pa->pa_pc, pa->pa_tag, vsc->regs[REG_GARTCTRL],
		    gartctrl | (3 << 7));
	}
	vsc->agpdev = (struct agp_softc *)agp_attach_bus(pa, &agp_via_methods,
	    vsc->vsc_apaddr, vsc->vsc_apsize, &vsc->dev);

	return;
}

int
agp_via_activate(struct device *arg, int act)
{
	struct agp_via_softc *vsc = (struct agp_via_softc *)arg;

	switch (act) {
	case DVACT_SUSPEND:
		agp_via_save(vsc);
		break;
	case DVACT_RESUME:
		agp_via_restore(vsc);
		break;
	}

	return (0);
}

void
agp_via_save(struct agp_via_softc *vsc)
{
	vsc->vsc_regapsize = pci_conf_read(vsc->vsc_pc, vsc->vsc_tag,
	    vsc->regs[REG_APSIZE]);
	vsc->vsc_regattbase = pci_conf_read(vsc->vsc_pc, vsc->vsc_tag,
	    vsc->regs[REG_ATTBASE]);
	vsc->vsc_reggartctl = pci_conf_read(vsc->vsc_pc, vsc->vsc_tag,
	    vsc->regs[REG_GARTCTRL]);
}
void
agp_via_restore(struct agp_via_softc *vsc)
{

	/* aperture size */
	pci_conf_write(vsc->vsc_pc, vsc->vsc_tag, vsc->regs[REG_APSIZE],
	    vsc->vsc_regapsize);
	/* GATT address and enable */
	pci_conf_write(vsc->vsc_pc, vsc->vsc_tag, vsc->regs[REG_ATTBASE],
	    vsc->vsc_regattbase);
	/* Turn it all back on. */
	pci_conf_write(vsc->vsc_pc, vsc->vsc_tag, vsc->regs[REG_GARTCTRL],
	    vsc->vsc_reggartctl);
	/* flush the tlb, just in case */
	agp_via_flush_tlb(vsc);
}

bus_size_t
agp_via_get_aperture(void *sc)
{
	struct agp_via_softc	*vsc = sc;
	bus_size_t		 apsize;

	apsize = pci_conf_read(vsc->vsc_pc, vsc->vsc_tag, 
	    vsc->regs[REG_APSIZE]) & 0x1f;

	/*
	 * The size is determined by the number of low bits of
	 * register APBASE which are forced to zero. The low 20 bits
	 * are always forced to zero and each zero bit in the apsize
	 * field just read forces the corresponding bit in the 27:20
	 * to be zero. We calculate the aperture size accordingly.
	 */
	return ((((apsize ^ 0xff) << 20) | ((1 << 20) - 1)) + 1);
}

int
agp_via_set_aperture(void *sc, bus_size_t aperture)
{
	struct agp_via_softc	*vsc = sc;
	bus_size_t		 apsize;
	pcireg_t		 reg;

	/*
	 * Reverse the magic from get_aperture.
	 */
	apsize = ((aperture - 1) >> 20) ^ 0xff;

	/*
	 * Double check for sanity.
	 */
	if ((((apsize ^ 0xff) << 20) | ((1 << 20) - 1)) + 1 != aperture)
		return (EINVAL);

	reg = pci_conf_read(vsc->vsc_pc, vsc->vsc_tag, vsc->regs[REG_APSIZE]);
	reg &= ~0xff;
	reg |= apsize;
	pci_conf_write(vsc->vsc_pc, vsc->vsc_tag, vsc->regs[REG_APSIZE], reg);

	return (0);
}

void
agp_via_bind_page(void *sc, bus_addr_t offset, paddr_t physical, int flags)
{
	struct agp_via_softc *vsc = sc;

	vsc->gatt->ag_virtual[(offset - vsc->vsc_apaddr) >> AGP_PAGE_SHIFT] =
	    physical;
}

void
agp_via_unbind_page(void *sc, bus_addr_t offset)
{
	struct agp_via_softc *vsc = sc;

	vsc->gatt->ag_virtual[(offset - vsc->vsc_apaddr) >> AGP_PAGE_SHIFT] = 0;
}

void
agp_via_flush_tlb(void *sc)
{
	struct agp_via_softc *vsc = sc;
	pcireg_t gartctrl;

	if (vsc->regs == via_v2_regs) {
		pci_conf_write(vsc->vsc_pc, vsc->vsc_tag,
		    vsc->regs[REG_GARTCTRL], 0x8f);
		pci_conf_write(vsc->vsc_pc, vsc->vsc_tag,
		    vsc->regs[REG_GARTCTRL], 0x0f);
	} else {
		gartctrl = pci_conf_read(vsc->vsc_pc, vsc->vsc_tag,
		    vsc->regs[REG_GARTCTRL]);
		pci_conf_write(vsc->vsc_pc, vsc->vsc_tag,
		    vsc->regs[REG_GARTCTRL], gartctrl & ~(1 << 7));
		pci_conf_write(vsc->vsc_pc, vsc->vsc_tag,
		    vsc->regs[REG_GARTCTRL], gartctrl);
	}
}
@


1.19
log
@No need to include <sys/lock.h> when only <sys/rwlock.h> is needed,
so remove the former and include the latter instead of pulling it
in <dev/pci/agpvar.h>.  This header already requires various other
types anyway.  While here remove unneeded headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_via.c,v 1.18 2014/03/17 22:01:56 kettenis Exp $	*/
a189 20

#if 0
int
agp_via_detach(struct agp_softc *sc)
{
	struct agp_via_softc *vsc = sc->sc_chipc;
	int error;

	error = agp_generic_detach(sc);
	if (error)
		return (error);

	pci_conf_write(sc->as_pc, sc->as_tag, vsc->regs[REG_GARTCTRL], 0);
	pci_conf_write(sc->as_pc, sc->as_tag, vsc->regs[REG_ATTBASE], 0);
	AGP_SET_APERTURE(sc, vsc->initial_aperture);
	agp_free_gatt(sc, vsc->gatt);

	return (0);
}
#endif
@


1.18
log
@The AGP ioctl interface is gone; remove the header file as well.

ok matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_via.c,v 1.17 2011/10/16 01:11:31 dhill Exp $	*/
a34 3
#include <sys/kernel.h>
#include <sys/lock.h>
#include <sys/conf.h>
d36 1
@


1.17
log
@align the read to the PCI config space.

from drahn@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_via.c,v 1.16 2010/08/07 19:31:23 oga Exp $	*/
a38 1
#include <sys/agpio.h>
@


1.16
log
@Suspend/resume handler for viaagp.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_via.c,v 1.15 2010/04/08 00:23:53 tedu Exp $	*/
d136 3
a138 2
		agpsel = pci_conf_read(pa->pa_pc, pa->pa_tag, AGP_VIA_AGPSEL);
		if ((agpsel & (1 << 1)) == 0) {
@


1.15
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_via.c,v 1.14 2009/05/10 16:57:44 oga Exp $	*/
d50 14
d65 3
a80 11
struct agp_via_softc {
	struct device		 dev;
	struct agp_softc	*agpdev;
	struct agp_gatt		*gatt;
	int			*regs;
	pci_chipset_tag_t	 vsc_pc;
	pcitag_t		 vsc_tag;
	bus_addr_t		 vsc_apaddr;
	bus_size_t		 vsc_apsize;
};

d82 2
a83 1
        sizeof(struct agp_via_softc), agp_via_probe, agp_via_attach
d212 44
@


1.14
log
@Change agp attach (again) so that the driver passes in the aperture size.

While the aperture size may change during attach, it never changes after
the end of the subdriver attach function, so getting this value with a
function is a waste of time. shrinks things slightly and makes the code
clearer.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_via.c,v 1.13 2009/05/10 15:28:45 oga Exp $	*/
a36 1
#include <sys/proc.h>
@


1.13
log
@In preparation for using agp as a bus_dma backend for drm, convert the bind_page
and unbind_page callbacks from

int bind_page(void *, off_t, bus_addr_t)

to

void bind_page(void *, bus_addr_t, paddr_t, int)

We can make these function void by making sure that the agp code sanity
checks properly (it already mostly did), so by definition these
functions may not fail.  The flags field is currently unused (intagp at
least will have a use for it soon).

Been in my tree for ages.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_via.c,v 1.12 2009/05/10 14:44:42 oga Exp $	*/
a59 1
	agp_via_get_aperture,
d73 1
a73 1
	bus_size_t		 initial_aperture;
d144 1
a144 1
	vsc->initial_aperture = agp_via_get_aperture(vsc);
d147 1
a147 2
		bus_size_t size = agp_via_get_aperture(vsc);
		gatt = agp_alloc_gatt(pa->pa_dmat, size);
d155 2
a156 1
		if (agp_via_set_aperture(vsc, size / 2)) {
d182 1
a182 1
	    vsc->vsc_apaddr, &vsc->dev);
@


1.12
log
@change agp driver attach so that the driver passes in the base address
of its aperture, instead of the BAR and memory type. This is a little
larger, but allows the driver to know it's aperture address. Needed for
some future stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_via.c,v 1.11 2009/01/04 20:47:35 grange Exp $	*/
d55 2
a56 2
int	agp_via_bind_page(void *, off_t, bus_addr_t);
int	agp_via_unbind_page(void *, off_t);
d253 2
a254 2
int
agp_via_bind_page(void *sc, off_t offset, bus_addr_t physical)
d258 2
a259 5
	if (offset < 0 || offset >= (vsc->gatt->ag_entries << AGP_PAGE_SHIFT))
		return (EINVAL);

	vsc->gatt->ag_virtual[offset >> AGP_PAGE_SHIFT] = physical;
	return (0);
d262 2
a263 2
int
agp_via_unbind_page(void *sc, off_t offset)
d267 1
a267 5
	if (offset < 0 || offset >= (vsc->gatt->ag_entries << AGP_PAGE_SHIFT))
		return (EINVAL);

	vsc->gatt->ag_virtual[offset >> AGP_PAGE_SHIFT] = 0;
	return (0);
@


1.11
log
@Back from coma. Fix dmesg printfs.
ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_via.c,v 1.10 2008/11/09 22:47:54 oga Exp $	*/
d73 1
d114 1
a114 1
	struct agp_via_softc	*asc = (struct agp_via_softc *)self;
d120 2
a121 2
	asc->vsc_pc = pa->pa_pc;
	asc->vsc_tag = pa->pa_tag;
d124 6
d133 1
a133 1
			asc->regs = via_v3_regs;
d136 1
a136 1
			asc->regs = via_v2_regs;
d140 1
a140 1
		asc->regs = via_v2_regs;
d145 1
a145 1
	asc->initial_aperture = agp_via_get_aperture(asc);
d148 1
a148 1
		bus_size_t size = agp_via_get_aperture(asc);
d157 1
a157 1
		if (agp_via_set_aperture(asc, size / 2)) {
d162 1
a162 1
	asc->gatt = gatt;
d164 1
a164 1
	if (asc->regs == via_v2_regs) {
d166 1
a166 1
		pci_conf_write(pa->pa_pc, pa->pa_tag, asc->regs[REG_ATTBASE],
d169 1
a169 1
		pci_conf_write(pa->pa_pc, pa->pa_tag, asc->regs[REG_GARTCTRL],
d174 1
a174 1
		pci_conf_write(pa->pa_pc, pa->pa_tag, asc->regs[REG_ATTBASE],
d178 2
a179 2
		    asc->regs[REG_ATTBASE]);
		pci_conf_write(pa->pa_pc, pa->pa_tag, asc->regs[REG_GARTCTRL],
d182 2
a183 2
	asc->agpdev = (struct agp_softc *)agp_attach_bus(pa, &agp_via_methods,
	    AGP_APBASE, PCI_MAPREG_TYPE_MEM, &asc->dev);
d192 1
a192 1
	struct agp_via_softc *asc = sc->sc_chipc;
d199 4
a202 4
	pci_conf_write(sc->as_pc, sc->as_tag, asc->regs[REG_GARTCTRL], 0);
	pci_conf_write(sc->as_pc, sc->as_tag, asc->regs[REG_ATTBASE], 0);
	AGP_SET_APERTURE(sc, asc->initial_aperture);
	agp_free_gatt(sc, asc->gatt);
@


1.10
log
@Don't attach to the agp bridges on amd64 machines. They have a different
interface (which is currently used by iommu(4) on amd64). I have a
driver for that interface, but it would currently conflict with iommu
and as such has not been commited.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_via.c,v 1.9 2008/11/09 15:11:19 oga Exp $	*/
d127 1
a127 1
			printf("v3, ");
d130 1
a130 1
			printf("v2 compat mode, ");
d134 1
a134 1
		printf("v2, ");
d151 1
a151 1
			printf("can't set aperture size\n");
@


1.9
log
@Rework that way that agp attaches.

previously, we had a static list of pcidevs and which agp driver would
be interanlly attached. Instead, split the agp drivers so they work like
audio(4), where we attach a driver, which sets up some callbacks and
initial state, then attaches the interface (agp(4)). Since this allows
us to attach different drivers in different places, and give them
/proper/ probe functions move most of the drivers back to attaching at
pchb, where they should, and intagp (formerly agp_i810) stays attaching
at vga, since it's part of the intel integrated graphics chips.

Diff shrinks the kernel slightly, gets rid of the annoying "no integrated
graphics" warning, and allows more cleanup later.

Tested by many. fix for alpha build (the only other vga_pci.c consumer)
suggested by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_via.c,v 1.8 2007/12/07 17:35:22 oga Exp $	*/
d99 7
a105 4
	/* Must be a pchb */
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_BRIDGE && 
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_BRIDGE_HOST &&
	    PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VIATECH)
@


1.8
log
@KNF, no binary change.

Looked over by a few people.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_via.c,v 1.7 2007/12/06 22:49:39 oga Exp $	*/
a31 1

d44 1
d51 7
a57 5
u_int32_t agp_via_get_aperture(struct agp_softc *);
int	agp_via_set_aperture(struct agp_softc *, u_int32_t);
int	agp_via_bind_page(struct agp_softc *, off_t, bus_addr_t);
int	agp_via_unbind_page(struct agp_softc *, off_t);
void	agp_via_flush_tlb(struct agp_softc *);
d59 1
a59 1
struct agp_methods agp_via_methods = {
a60 1
	agp_via_set_aperture,
a63 5
	agp_generic_enable,
	agp_generic_alloc_memory,
	agp_generic_free_memory,
	agp_generic_bind_memory,
	agp_generic_unbind_memory,
d67 15
a81 3
	u_int32_t	initial_aperture; /* aperture size at startup */
	struct agp_gatt *gatt;
	int		*regs;
d94 15
a108 1
agp_via_attach(struct agp_softc *sc, struct pci_attach_args *pa)
d110 9
a118 13
	struct agp_via_softc *asc;
	struct agp_gatt *gatt;
	pcireg_t agpsel, capval;

	asc = malloc(sizeof *asc, M_AGP, M_NOWAIT | M_ZERO);
	if (asc == NULL) {
		printf("can't allocate chipset-specific softc\n");
		return (ENOMEM);
	}
	sc->sc_chipc = asc;
	sc->sc_methods = &agp_via_methods;
	pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_AGP, &sc->sc_capoff,
	    &capval);
a133 5
	if (agp_map_aperture(pa ,sc, AGP_APBASE, PCI_MAPREG_TYPE_MEM) != 0) {
		printf("can't map aperture\n");
		free(asc, M_AGP);
		return (ENXIO);
	}
d135 1
a135 1
	asc->initial_aperture = AGP_GET_APERTURE(sc);
d138 3
a140 2
		gatt = agp_alloc_gatt(sc);
		if (gatt)
d144 1
a144 1
		 * Probably contigmalloc failure. Try reducing the
d147 1
a147 2
		if (AGP_SET_APERTURE(sc, AGP_GET_APERTURE(sc) / 2)) {
			agp_generic_detach(sc);
d149 1
a149 1
			return (ENOMEM);
d172 2
d175 1
a175 1
	return (0);
d198 2
a199 2
u_int32_t
agp_via_get_aperture(struct agp_softc *sc)
d201 2
a202 2
	struct agp_via_softc *asc = sc->sc_chipc;
	u_int32_t apsize;
d204 2
a205 2
	apsize = pci_conf_read(sc->sc_pc, sc->sc_pcitag, 
	    asc->regs[REG_APSIZE]) & 0x1f;
d218 1
a218 1
agp_via_set_aperture(struct agp_softc *sc, u_int32_t aperture)
d220 3
a222 3
	struct agp_via_softc *asc = sc->sc_chipc;
	u_int32_t apsize;
	pcireg_t reg;
d235 1
a235 1
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, asc->regs[REG_APSIZE]);
d238 1
a238 1
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, asc->regs[REG_APSIZE], reg);
d244 1
a244 1
agp_via_bind_page(struct agp_softc *sc, off_t offset, bus_addr_t physical)
d246 1
a246 1
	struct agp_via_softc *asc = sc->sc_chipc;
d248 1
a248 1
	if (offset < 0 || offset >= (asc->gatt->ag_entries << AGP_PAGE_SHIFT))
d251 1
a251 1
	asc->gatt->ag_virtual[offset >> AGP_PAGE_SHIFT] = physical;
d256 1
a256 1
agp_via_unbind_page(struct agp_softc *sc, off_t offset)
d258 1
a258 1
	struct agp_via_softc *asc = sc->sc_chipc;
d260 1
a260 1
	if (offset < 0 || offset >= (asc->gatt->ag_entries << AGP_PAGE_SHIFT))
d263 1
a263 1
	asc->gatt->ag_virtual[offset >> AGP_PAGE_SHIFT] = 0;
d268 1
a268 1
agp_via_flush_tlb(struct agp_softc *sc)
d270 1
a270 1
	struct agp_via_softc *asc = sc->sc_chipc;
d273 5
a277 5
	if (asc->regs == via_v2_regs) {
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, asc->regs[REG_GARTCTRL],
		    0x8f);
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, asc->regs[REG_GARTCTRL],
		    0x0f);
d279 6
a284 6
		gartctrl = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
		    asc->regs[REG_GARTCTRL]);
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, asc->regs[REG_GARTCTRL],
		    gartctrl & ~(1 << 7));
		pci_conf_write(sc->sc_pc, sc->sc_pcitag, asc->regs[REG_GARTCTRL],
		    gartctrl);
@


1.7
log
@Destatic functions in the agp subsystem.

KNF coming shortly.

ok marco, jsg and mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_via.c,v 1.6 2007/11/26 15:35:15 deraadt Exp $	*/
d52 4
a55 4
int agp_via_set_aperture(struct agp_softc *, u_int32_t);
int agp_via_bind_page(struct agp_softc *, off_t, bus_addr_t);
int agp_via_unbind_page(struct agp_softc *, off_t);
void agp_via_flush_tlb(struct agp_softc *);
d144 1
a144 1
				 gatt->ag_physical | 3);
d147 1
a147 1
				 0x0000000f);
d152 1
a152 1
				 gatt->ag_physical);
d155 1
a155 1
				 asc->regs[REG_ATTBASE]);
d157 1
a157 1
				 gartctrl | (3 << 7));
d260 1
a260 1
				0x8f);
d262 1
a262 1
				0x0f);
d265 1
a265 1
					 asc->regs[REG_GARTCTRL]);
d267 1
a267 1
			       gartctrl & ~(1 << 7));
d269 1
a269 1
			       gartctrl);
@


1.6
log
@correct newlines surrounding the sub-bus configuration, and unify
pchb's further
ok reyk oga
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_via.c,v 1.5 2007/11/25 17:11:12 oga Exp $	*/
d51 5
a55 5
static u_int32_t agp_via_get_aperture(struct agp_softc *);
static int agp_via_set_aperture(struct agp_softc *, u_int32_t);
static int agp_via_bind_page(struct agp_softc *, off_t, bus_addr_t);
static int agp_via_unbind_page(struct agp_softc *, off_t);
static void agp_via_flush_tlb(struct agp_softc *);
d164 1
a164 1
static int
d183 1
a183 1
static u_int32_t
d202 1
a202 1
static int
d228 1
a228 1
static int
d240 1
a240 1
static int
d252 1
a252 1
static void
@


1.5
log
@Make agp attach as a device. This means that many more agp bridges
actually get detected and attached. Also adds a kernel api for
manipulating agp.

Enable this on i386 and amd64.

"I think you should commit it" deraadt@@, ok matthieu. Looked over by
several others.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_via.c,v 1.4 2007/10/06 23:50:54 krw Exp $	*/
d94 1
a94 1
		printf(": can't allocate chipset-specific softc\n");
d106 1
a106 1
			printf(" (v3)");
d109 1
a109 1
			printf(" (v2 compat mode)");
d113 1
a113 1
		printf(" (v2)");
d117 1
a117 1
		printf(": can't map aperture\n");
d135 1
a135 1
			printf(": can't set aperture size\n");
@


1.4
log
@Simpliest memset(,0,) -> M_ZERO changes. One (caddr *) cast removal,
otherwise just adding M_ZERO to malloc() and removing the immediately
adjacent memset(,0,).
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_via.c,v 1.3 2007/08/04 19:40:25 reyk Exp $	*/
d51 5
a55 5
static u_int32_t agp_via_get_aperture(struct vga_pci_softc *);
static int agp_via_set_aperture(struct vga_pci_softc *, u_int32_t);
static int agp_via_bind_page(struct vga_pci_softc *, off_t, bus_addr_t);
static int agp_via_unbind_page(struct vga_pci_softc *, off_t);
static void agp_via_flush_tlb(struct vga_pci_softc *);
d73 1
d76 8
d86 1
a86 2
agp_via_attach(struct vga_pci_softc *sc, struct pci_attach_args *pa,
	       struct pci_attach_args *pchb_pa)
d90 1
d92 1
a92 1
	asc = malloc(sizeof *asc, M_DEVBUF, M_NOWAIT | M_ZERO);
d99 2
d102 15
a116 1
	if (agp_map_aperture(sc, AGP_APBASE, PCI_MAPREG_TYPE_MEM) != 0) {
d118 1
a118 1
		free(asc, M_DEVBUF);
d141 18
a158 6
	/* Install the gatt. */
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_VIA_ATTBASE,
	    gatt->ag_physical | 3);
	
	/* Enable the aperture. */
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_VIA_GARTCTRL, 0x0000000f);
d165 1
a165 1
agp_via_detach(struct vga_pci_softc *sc)
d174 2
a175 2
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_VIA_GARTCTRL, 0);
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_VIA_ATTBASE, 0);
d184 1
a184 1
agp_via_get_aperture(struct vga_pci_softc *sc)
d186 1
d189 2
a190 2
	apsize = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
	    AGP_VIA_APSIZE) & 0x1f;
d203 1
a203 1
agp_via_set_aperture(struct vga_pci_softc *sc, u_int32_t aperture)
d205 1
d220 1
a220 1
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_VIA_APSIZE);
d223 1
a223 1
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_VIA_APSIZE, reg);
d229 1
a229 1
agp_via_bind_page(struct vga_pci_softc *sc, off_t offset, bus_addr_t physical)
d241 1
a241 1
agp_via_unbind_page(struct vga_pci_softc *sc, off_t offset)
d253 1
a253 1
agp_via_flush_tlb(struct vga_pci_softc *sc)
d255 16
a270 2
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_VIA_GARTCTRL, 0x8f);
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_VIA_GARTCTRL, 0x0f);
@


1.3
log
@Add AGP support for the intel i965 chipset, this also extends the
internal AGP API to work with 64bit PCI-Express memory and
non-standard AGP aperture bases.

tested by many
ok matthieu@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_via.c,v 1.2 2002/07/25 23:31:04 fgsch Exp $	*/
d83 1
a83 1
	asc = malloc(sizeof *asc, M_DEVBUF, M_NOWAIT);
a87 1
	memset(asc, 0, sizeof *asc);
@


1.2
log
@- some KNF.
- comment out debugging printf for i810.
- remove checks for failure if malloc is used with M_WAITOK.

mickey@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_via.c,v 1.1 2002/07/12 20:17:03 mickey Exp $	*/
d92 1
a92 1
	if (agp_map_aperture(sc) != 0) {
@


1.2.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@support for the agp gart on various agp chipsets.
only i810 driver was tested though.
based on the netbsd's lkm, initially ported
by hunter@@dg.net.ua and later made into shape by mickey.
testing by art@@ and millert@@ .
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 2
a78 1
agp_via_attach(struct vga_pci_softc *sc, struct pci_attach_args *pa, struct pci_attach_args *pchb_pa)
d86 1
a86 1
		return ENOMEM;
d95 1
a95 1
		return ENXIO;
d112 1
a112 1
			return ENOMEM;
d119 1
a119 1
			 gatt->ag_physical | 3);
d124 1
a124 1
	return 0;
d136 1
a136 1
		return error;
d143 1
a143 1
	return 0;
d152 2
a153 1
	apsize = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_VIA_APSIZE) & 0x1f;
d162 1
a162 1
	return (((apsize ^ 0xff) << 20) | ((1 << 20) - 1)) + 1;
d180 1
a180 1
		return EINVAL;
d187 1
a187 1
	return 0;
d196 1
a196 1
		return EINVAL;
d199 1
a199 1
	return 0;
d208 1
a208 1
		return EINVAL;
d211 1
a211 1
	return 0;
a219 2


@

