head	1.20;
access;
symbols
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.6
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.4
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.8
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.4
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.12.0.4
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.7.0.8
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.10
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.6
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.4
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.20
date	2016.04.30.11.32.23;	author kettenis;	state Exp;
branches;
next	1.19;
commitid	idV1JJlqFozdGODX;

1.19
date	2015.11.24.19.38.01;	author kettenis;	state Exp;
branches;
next	1.18;
commitid	hP3JcrKoIqJ5P4hp;

1.18
date	2015.11.21.14.36.08;	author kettenis;	state Exp;
branches;
next	1.17;
commitid	pB55TJecUSzFYIIr;

1.17
date	2014.09.30.18.09.23;	author stsp;	state Exp;
branches;
next	1.16;
commitid	Z07ZlAbvDVPkB1GG;

1.16
date	2014.09.26.13.00.39;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	mjhnw3hRfjtZRTzA;

1.15
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	JtO5uXxVcnZfhUkR;

1.14
date	2013.01.04.23.19.40;	author stsp;	state Exp;
branches;
next	1.13;

1.13
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2011.12.23.21.58.47;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2011.07.31.16.55.01;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2010.09.07.16.21.46;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2010.08.27.15.41.42;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2010.07.01.18.08.17;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.30.18.13.45;	author chl;	state Exp;
branches;
next	1.6;

1.6
date	2007.09.06.08.01.01;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2006.07.19.20.58.45;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2006.07.18.17.28.14;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2006.07.17.20.48.26;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.29.01.26.13;	author uwe;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.28.17.21.14;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Implement DMA support.  Bits and pieces taken from NetBSD, but we only
support ADMA2.  The older SDMA mode has too many limitations to be really
usable.  Gives us only moderate speed improvements, bus reduces the CPU load
considerably.  We will reap the full benefits once we implement wider bus
widths and high speed modes.

There is a remining issue with simultanious use of eMMC and external SD card
on (some) Intel Bay Trail hardware.  Still under investigation.

ok patrick@@, stsp@@, deraadt@@
@
text
@/*	$OpenBSD: sdhc_pci.c,v 1.19 2015/11/24 19:38:01 kettenis Exp $	*/

/*
 * Copyright (c) 2006 Uwe Stuehler <uwe@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/malloc.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
#include <dev/sdmmc/sdhcreg.h>
#include <dev/sdmmc/sdhcvar.h>
#include <dev/sdmmc/sdmmcvar.h>

/*
 * 8-bit PCI configuration register that tells us how many slots there
 * are and which BAR entry corresponds to the first slot.
 */
#define SDHC_PCI_CONF_SLOT_INFO		0x40
#define SDHC_PCI_NUM_SLOTS(info)	((((info) >> 4) & 0x7) + 1)
#define SDHC_PCI_FIRST_BAR(info)	((info) & 0x7)

/* TI specific register */
#define SDHC_PCI_GENERAL_CTL		0x4c
#define  MMC_SD_DIS			0x02

/* RICOH specific registers */
#define SDHC_PCI_MODE_KEY		0xf9
#define SDHC_PCI_MODE			0x150
#define  SDHC_PCI_MODE_SD20		0x10
#define SDHC_PCI_BASE_FREQ_KEY		0xfc
#define SDHC_PCI_BASE_FREQ		0xe1

struct sdhc_pci_softc {
	struct sdhc_softc sc;
	pci_chipset_tag_t sc_pc;
	pcitag_t sc_tag;
	pcireg_t sc_id;
	void *sc_ih;
};

int	sdhc_pci_match(struct device *, void *, void *);
void	sdhc_pci_attach(struct device *, struct device *, void *);
int	sdhc_pci_activate(struct device *, int);

void	sdhc_pci_conf_write(pci_chipset_tag_t, pcitag_t, int, uint8_t);
void	sdhc_takecontroller(struct pci_attach_args *);
void	sdhc_ricohfix(struct sdhc_pci_softc *);

struct cfattach sdhc_pci_ca = {
	sizeof(struct sdhc_pci_softc), sdhc_pci_match, sdhc_pci_attach,
	NULL, sdhc_pci_activate
};

int
sdhc_pci_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	/*
	 * The Realtek RTS5209 is supported by rtsx(4). Usually the device
	 * class for these is UNDEFINED but there are RTS5209 devices which
	 * are advertising an SYSTEM/SDHC device class in addition to a
	 * separate device advertising the UNDEFINED class. Such devices are
	 * not compatible with sdhc(4), so ignore them.
	 */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_REALTEK &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_REALTEK_RTS5209)
		return 0;

	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_SYSTEM &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_SYSTEM_SDHC)
		return 1;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_RICOH &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_RICOH_R5U822 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_RICOH_R5U823))
		return 1;

	return 0;
}

void
sdhc_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct sdhc_pci_softc *sc = (struct sdhc_pci_softc *)self;
	struct pci_attach_args *pa = aux;
	pci_intr_handle_t ih;
	char const *intrstr;
	int slotinfo;
	int nslots;
	int usedma;
	int reg;
	pcireg_t type;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	bus_size_t size;
	u_int32_t caps = 0;

	sc->sc_pc = pa->pa_pc;
	sc->sc_tag = pa->pa_tag;
	sc->sc_id = pa->pa_id;

	/* Some TI controllers needs special treatment. */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_TI &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_TI_PCI7XX1_SD &&
            pa->pa_function == 4)
		sdhc_takecontroller(pa);

	/* ENE controllers break if set to 0V bus power. */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ENE &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENE_SDCARD)
		sc->sc.sc_flags |= SDHC_F_NOPWR0;

	/* Some RICOH controllers need to be bumped into the right mode. */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_RICOH &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_RICOH_R5U822 ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_RICOH_R5U823))
		sdhc_ricohfix(sc);

	if (pci_intr_map(pa, &ih)) {
		printf(": can't map interrupt\n");
		return;
	}

	intrstr = pci_intr_string(pa->pa_pc, ih);
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_SDMMC,
	    sdhc_intr, sc, sc->sc.sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": can't establish interrupt\n");
		return;
	}
	printf(": %s\n", intrstr);

	/* Enable use of DMA if supported by the interface. */
	usedma = PCI_INTERFACE(pa->pa_class) == SDHC_PCI_INTERFACE_DMA;
	sc->sc.sc_dmat = pa->pa_dmat;

	/*
	 * Map and attach all hosts supported by the host controller.
	 */
	slotinfo = pci_conf_read(pa->pa_pc, pa->pa_tag,
	    SDHC_PCI_CONF_SLOT_INFO);
	nslots = SDHC_PCI_NUM_SLOTS(slotinfo);

	/* Allocate an array big enough to hold all the possible hosts */
	sc->sc.sc_host = mallocarray(nslots, sizeof(struct sdhc_host *),
	    M_DEVBUF, M_WAITOK);

	for (reg = SDHC_PCI_BAR_START + SDHC_PCI_FIRST_BAR(slotinfo) * 4;
	     reg < SDHC_PCI_BAR_END && nslots > 0;
	     reg += 4, nslots--) {
		if (!pci_mapreg_probe(pa->pa_pc, pa->pa_tag, reg, &type))
			break;

		if (type == PCI_MAPREG_TYPE_IO || pci_mapreg_map(pa, reg,
		    type, 0, &iot, &ioh, NULL, &size, 0)) {
			printf("%s at 0x%x: can't map registers\n",
			    sc->sc.sc_dev.dv_xname, reg);
			break;
		}

		if (sdhc_host_found(&sc->sc, iot, ioh, size, usedma, caps) != 0)
			printf("%s at 0x%x: can't initialize host\n",
			    sc->sc.sc_dev.dv_xname, reg);

		if (type & PCI_MAPREG_MEM_TYPE_64BIT)
			reg += 4;
	}
}

int
sdhc_pci_activate(struct device *self, int act)
{
	struct sdhc_pci_softc *sc = (struct sdhc_pci_softc *)self;
	int rv;

	switch (act) {
	case DVACT_SUSPEND:
		rv = sdhc_activate(self, act);
		break;
	case DVACT_RESUME:
		/* Some RICOH controllers need to be bumped into the right mode. */
		if (PCI_VENDOR(sc->sc_id) == PCI_VENDOR_RICOH &&
		    (PCI_PRODUCT(sc->sc_id) == PCI_PRODUCT_RICOH_R5U822 ||
		    PCI_PRODUCT(sc->sc_id) == PCI_PRODUCT_RICOH_R5U823))
			sdhc_ricohfix(sc);
		rv = sdhc_activate(self, act);
		break;
	default:
		rv = sdhc_activate(self, act);
		break;
	}
	return (rv);
}

void
sdhc_takecontroller(struct pci_attach_args *pa)
{
	pcitag_t tag;
	pcireg_t id, reg;

	/* Look at func 3 for the flash device */
	tag = pci_make_tag(pa->pa_pc, pa->pa_bus, pa->pa_device, 3);
	id = pci_conf_read(pa->pa_pc, tag, PCI_ID_REG);
	if (PCI_PRODUCT(id) != PCI_PRODUCT_TI_PCI7XX1_FLASH)
		return;

	/*
	 * Disable MMC/SD on the flash media controller so the
	 * SD host takes over.
	 */
	reg = pci_conf_read(pa->pa_pc, tag, SDHC_PCI_GENERAL_CTL);
	reg |= MMC_SD_DIS;
	pci_conf_write(pa->pa_pc, tag, SDHC_PCI_GENERAL_CTL, reg);
}

void
sdhc_ricohfix(struct sdhc_pci_softc *sc)
{
	/* Enable SD2.0 mode. */
	sdhc_pci_conf_write(sc->sc_pc, sc->sc_tag, SDHC_PCI_MODE_KEY, 0xfc);
	sdhc_pci_conf_write(sc->sc_pc, sc->sc_tag, SDHC_PCI_MODE, SDHC_PCI_MODE_SD20);
	sdhc_pci_conf_write(sc->sc_pc, sc->sc_tag, SDHC_PCI_MODE_KEY, 0x00);

	/*
	 * Some SD/MMC cards don't work with the default base
	 * clock frequency of 200MHz.  Lower it to 50Hz.
	 */
	sdhc_pci_conf_write(sc->sc_pc, sc->sc_tag, SDHC_PCI_BASE_FREQ_KEY, 0x01);
	sdhc_pci_conf_write(sc->sc_pc, sc->sc_tag, SDHC_PCI_BASE_FREQ, 50);
	sdhc_pci_conf_write(sc->sc_pc, sc->sc_tag, SDHC_PCI_BASE_FREQ_KEY, 0x00);
}

void
sdhc_pci_conf_write(pci_chipset_tag_t pc, pcitag_t tag, int reg, uint8_t val)
{
	pcireg_t tmp;

	tmp = pci_conf_read(pc, tag, reg & ~0x3);
	tmp &= ~(0xff << ((reg & 0x3) * 8));
	tmp |= (val << ((reg & 0x3) * 8));
	pci_conf_write(pc, tag, reg & ~0x3, tmp);
}
@


1.19
log
@Fix inverted condition in previous.

Problem reported by Mikolaj Kucharski.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_pci.c,v 1.18 2015/11/21 14:36:08 kettenis Exp $	*/
d152 1
@


1.18
log
@Make this work with 64-bit memory BARs such as those found on the new
pcengines APU.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_pci.c,v 1.17 2014/09/30 18:09:23 stsp Exp $	*/
d167 1
a167 1
		if (pci_mapreg_probe(pa->pa_pc, pa->pa_tag, reg, &type) != 0)
@


1.17
log
@Fix another Ricoh SD controller which needs to be put into slow mode to work.
reported by mlarkin@@; ok mlarkin@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_pci.c,v 1.16 2014/09/26 13:00:39 deraadt Exp $	*/
d109 1
d164 1
a164 3
	/* XXX: handle 64-bit BARs */
	for (reg = SDHC_PCI_BAR_START + SDHC_PCI_FIRST_BAR(slotinfo) *
		 sizeof(u_int32_t);
d166 3
a168 1
	     reg += sizeof(u_int32_t), nslots--) {
d170 2
a171 6
		if (pci_mem_find(pa->pa_pc, pa->pa_tag, reg,
		    NULL, NULL, NULL) != 0)
			continue;

		if (pci_mapreg_map(pa, reg, PCI_MAPREG_TYPE_MEM, 0,
		    &iot, &ioh, NULL, &size, 0)) {
d174 1
a174 1
			continue;
a177 1
			/* XXX: sc->sc_host leak */
d180 3
@


1.16
log
@new ricoh controllers must also be pushed into "old slow mode" at resume
time.  ok kettenis jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_pci.c,v 1.15 2014/07/13 23:10:23 deraadt Exp $	*/
d131 2
a132 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_RICOH_R5U823)
d200 2
a201 1
		    PCI_PRODUCT(sc->sc_id) == PCI_PRODUCT_RICOH_R5U823)
@


1.15
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_pci.c,v 1.14 2013/01/04 23:19:40 stsp Exp $	*/
d51 3
d59 3
d63 1
a63 1
void	sdhc_pci_conf_write(struct pci_attach_args *, int, uint8_t);
d67 1
a67 1
	NULL, sdhc_activate
d114 4
d131 2
a132 14
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_RICOH_R5U823) {
		/* Enable SD2.0 mode. */
		sdhc_pci_conf_write(pa, SDHC_PCI_MODE_KEY, 0xfc);
		sdhc_pci_conf_write(pa, SDHC_PCI_MODE, SDHC_PCI_MODE_SD20);
		sdhc_pci_conf_write(pa, SDHC_PCI_MODE_KEY, 0x00);

		/*
		 * Some SD/MMC cards don't work with the default base
		 * clock frequency of 200MHz.  Lower it to 50Hz.
		 */
		sdhc_pci_conf_write(pa, SDHC_PCI_BASE_FREQ_KEY, 0x01);
		sdhc_pci_conf_write(pa, SDHC_PCI_BASE_FREQ, 50);
		sdhc_pci_conf_write(pa, SDHC_PCI_BASE_FREQ_KEY, 0x00);
	}
d186 24
d232 18
a249 1
sdhc_pci_conf_write(struct pci_attach_args *pa, int reg, uint8_t val)
d253 1
a253 1
	tmp = pci_conf_read(pa->pa_pc, pa->pa_tag, reg & ~0x3);
d256 1
a256 1
	pci_conf_write(pa->pa_pc, pa->pa_tag, reg & ~0x3, tmp);
@


1.14
log
@Attach rtsx(4) only to devices using the 'undefined' PCI class, and do
not ever attach sdhc(4) to devices matching the rtsx(4) vendor/product ID.
Fixes an issue reported by Dave Anderson where on his hardware both drivers
attached to apparently the same device which then failed to work reliably.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_pci.c,v 1.13 2012/10/08 21:47:50 deraadt Exp $	*/
d161 2
a162 2
	sc->sc.sc_host = malloc(sizeof(struct sdhc_host *) * nslots, M_DEVBUF,
	    M_WAITOK);
@


1.13
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_pci.c,v 1.12 2011/12/23 21:58:47 kettenis Exp $	*/
d68 11
@


1.12
log
@Switch the Ricoh RU823 SD/MMC in SD2.0 mode (upon which it changes itself
into a Ricoh RU822 controller).  Also switch the base clock to 50MHz as some
SD/MMC cards don't work with the default 200MHz clock.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_pci.c,v 1.11 2011/07/31 16:55:01 kettenis Exp $	*/
a174 5

	/*
	 * Establish shutdown hooks.
	 */
	(void)shutdownhook_establish(sdhc_shutdown, &sc->sc);
@


1.11
log
@Add support for the Ricoh 5U823 SD/MMC controller found on the x220.

ok deraadt@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_pci.c,v 1.10 2010/09/07 16:21:46 deraadt Exp $	*/
d42 7
d57 1
d74 2
a75 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_RICOH_R5U823)
d108 1
a108 1
	/* Some RICOH controllers lack a capability register. */
d110 14
a123 5
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_RICOH_R5U823)
		caps = (0x21 << SDHC_BASE_FREQ_SHIFT) |
			(0x21 << SDHC_TIMEOUT_FREQ_SHIFT) |
			SDHC_TIMEOUT_FREQ_UNIT | SDHC_VOLTAGE_SUPP_3_3V |
			SDHC_DMA_SUPPORT;
d201 11
@


1.10
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_pci.c,v 1.9 2010/08/27 15:41:42 deraadt Exp $	*/
d65 4
d86 1
d94 1
a94 1
	/* ENE controllers break if set to 0V bus power */
d99 8
d152 1
a152 1
		if (sdhc_host_found(&sc->sc, iot, ioh, size, usedma) != 0)
@


1.9
log
@Improve sdhc_activate, and make sdhc_powerhook a simple wrapper around
it for now
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_pci.c,v 1.8 2010/07/01 18:08:17 deraadt Exp $	*/
d146 1
a146 1
	 * Establish power and shutdown hooks.
a147 1
	(void)powerhook_establish(sdhc_powerhook, &sc->sc);
@


1.8
log
@suspend/resume to the same level as apm machines.  note: that is kind
of broken since it does not detach+reattach the card (which it has to)
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_pci.c,v 1.7 2007/10/30 18:13:45 chl Exp $	*/
a48 1
int	sdhc_pci_activate(struct device *, int act);
d53 1
a53 1
	NULL, sdhc_pci_activate
d148 1
a148 1
	(void)powerhook_establish(sdhc_power, &sc->sc);
a149 14
}

int
sdhc_pci_activate(struct device *self, int act)
{
	switch (act) {
	case DVACT_SUSPEND:
		sdhc_power(PWR_SUSPEND, self);
		break;
	case DVACT_RESUME:
		sdhc_power(PWR_RESUME, self);
		break;
	}
	return (0);
@


1.7
log
@MALLOC/FREE -> malloc/free

These are the latest ones needed to build a kernel (on amd64)
without the MALLOC/FREE definitions in src/sys/sys/malloc.h

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_pci.c,v 1.6 2007/09/06 08:01:01 jsg Exp $	*/
d49 1
d53 2
a54 1
	sizeof(struct sdhc_pci_softc), sdhc_pci_match, sdhc_pci_attach
d151 14
@


1.6
log
@Don't try disabling bus power before setting the voltage on
the buggy ENE controller.
Tested by Alexey Suslikov <alexey.suslikov@@gmail.com> who
pointed out a similiar workaround in Linux.

ok miod@@, nit and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_pci.c,v 1.5 2006/07/19 20:58:45 fgsch Exp $	*/
d118 2
a119 2
	MALLOC(sc->sc.sc_host, struct sdhc_host **,
	    sizeof(struct sdhc_host *) * nslots, M_DEVBUF, M_WAITOK);
@


1.5
log
@usually works better when you check for the right device id. tsk tsk.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_pci.c,v 1.4 2006/07/18 17:28:14 fgsch Exp $	*/
d87 5
@


1.4
log
@On some TI controllers, disable the SD/MMC bit on the flash media so
the SD host takes over. originally fix from ian@@, different one commited.
tested by ian@@ and myself. uwe@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_pci.c,v 1.3 2006/07/17 20:48:26 fgsch Exp $	*/
d84 1
a84 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_TI_PCI7XX1_FLASH &&
@


1.3
log
@correct the way hosts are alloc'ed. fixes crashes on controllers with
multiple slots. tested by me and ian@@. uwe@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_pci.c,v 1.2 2006/06/29 01:26:13 uwe Exp $	*/
d25 1
d38 4
d49 1
d82 6
d144 21
@


1.2
log
@Read the "slot info" PCI configuration register to find out how many
SDHC slots there are and which BAR describes the first slot (64-bit BARs
are not handled for now).  This was needed for TI's PCI7621 SDHC so that
we don't find slots which are not really there.

Idea gleaned from Linux driver; tested with TI PCI7621 by ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_pci.c,v 1.1 2006/05/28 17:21:14 uwe Exp $	*/
d22 1
d98 6
d106 1
a106 2
		 sizeof(u_int32_t),
	     nslots = SDHC_PCI_NUM_SLOTS(slotinfo);
d122 1
@


1.1
log
@Support for standard SD host controllers like the Ricoh 5C822, a small
generic bus layer, and SCSI emulation for SD/MMC memory cards.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d28 8
d67 4
a73 2
	int usedma;
	int reg;
d95 8
a102 1
	for (reg = SDHC_PCI_BAR_START; reg < SDHC_PCI_BAR_END; reg += 4) {
@

