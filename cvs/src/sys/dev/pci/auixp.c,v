head	1.39;
access;
symbols
	OPENBSD_6_2_BASE:1.39
	OPENBSD_6_1:1.38.0.4
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.36.0.6
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.35.0.4
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.33.0.6
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.29.0.8
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.6
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.4
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.4.0.2
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.1.0.2
	OPENBSD_3_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.39
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	uRv5pa9QDlZaYgwD;

1.38
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.37;
commitid	qGgYgJTgEFuAoGj4;

1.37
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.36;
commitid	pi1a9KN0itEngOc4;

1.36
date	2015.12.11.16.07.01;	author mpi;	state Exp;
branches;
next	1.35;
commitid	fbhqfhfdKxBcsetK;

1.35
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.34;
commitid	RaOGL5SyOGOZylwx;

1.34
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.33;
commitid	p4LJxGKbi0BU2cG6;

1.33
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.32;
commitid	OBNa5kfxQ2UXoiIw;

1.32
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.30;

1.30
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.29;

1.29
date	2011.07.03.15.47.16;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	2010.09.21.02.09.15;	author jakemsr;	state Exp;
branches;
next	1.27;

1.27
date	2010.08.27.16.26.35;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2010.08.27.05.04.12;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.12.19.43.52;	author jakemsr;	state Exp;
branches;
next	1.23;

1.23
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.22;

1.22
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.21;

1.21
date	2008.09.24.19.09.05;	author chl;	state Exp;
branches;
next	1.20;

1.20
date	2008.09.17.06.14.09;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.25.23.59.33;	author jakemsr;	state Exp;
branches;
next	1.18;

1.18
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.17;

1.17
date	2008.02.13.23.35.08;	author jakemsr;	state Exp;
branches;
next	1.16;

1.16
date	2008.02.13.23.30.51;	author jakemsr;	state Exp;
branches;
next	1.15;

1.15
date	2008.02.12.13.02.21;	author jakemsr;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.15.02.52.50;	author jakemsr;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.05.00.17.28;	author jakemsr;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.22.03.16.35;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.17.00.50.46;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.26.00.36.03;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.25.21.27.15;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2007.02.14.01.12.16;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.27.21.40.01;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.13.15.48.45;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.25.23.53.35;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.26.14.31.26;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.21.18.16.40;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.07.20.08.45;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.39
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/* $OpenBSD: auixp.c,v 1.38 2016/09/19 06:46:44 ratchov Exp $ */
/* $NetBSD: auixp.c,v 1.9 2005/06/27 21:13:09 thorpej Exp $ */

/*
 * Copyright (c) 2004, 2005 Reinoud Zandijk <reinoud@@netbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * Audio driver for ATI IXP-{150,200,...} audio driver hardware.
 *
 * Recording and playback has been tested OK on various sample rates and
 * encodings.
 *
 * Known problems and issues :
 * - SPDIF is untested and needs some work still (LED stays off)
 * - 32 bit audio playback failed last time i tried but that might an AC'97
 *   codec support problem.
 * - 32 bit recording works but can't try out playing: see above.
 * - no suspend/resume support yet.
 * - multiple codecs are `supported' but not tested; the implemetation needs
 *   some cleaning up.
 */

/*#define DEBUG_AUIXP*/

#include <sys/param.h>
#include <sys/errno.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/exec.h>
#include <sys/selinfo.h>
#include <sys/audioio.h>
#include <sys/queue.h>

#include <machine/bus.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>

#include <dev/audio_if.h>
#include <dev/ic/ac97.h>

#include <dev/pci/auixpreg.h>
#include <dev/pci/auixpvar.h>

/* codec detection constant indicating the interrupt flags */
#define ALL_CODECS_NOT_READY \
    (ATI_REG_ISR_CODEC0_NOT_READY | ATI_REG_ISR_CODEC1_NOT_READY |\
     ATI_REG_ISR_CODEC2_NOT_READY)
#define CODEC_CHECK_BITS (ALL_CODECS_NOT_READY|ATI_REG_ISR_NEW_FRAME)

/* why isn't this base address register not in the headerfile? */
#define PCI_CBIO 0x10

/* macro's used */
#define KERNADDR(p)	((void *)((p)->addr))
#define	DMAADDR(p)	((p)->map->dm_segs[0].ds_addr)

const struct pci_matchid auixp_pci_devices[] = {
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_SB200_AUDIO },
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_SB300_AUDIO },
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_SB400_AUDIO },
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_SB600_AUDIO }
};

struct cfdriver auixp_cd = {
	NULL, "auixp", DV_DULL
};

int	auixp_match( struct device *, void *, void *);
void	auixp_attach(struct device *, struct device *, void *);
int	auixp_detach(struct device *, int);

int	auixp_activate(struct device *, int);

struct cfattach auixp_ca = {
	sizeof(struct auixp_softc), auixp_match, auixp_attach,
	NULL, auixp_activate
};

int	auixp_open(void *v, int flags);
void	auixp_close(void *v);
int	auixp_set_params(void *, int, int, struct audio_params *,
    struct audio_params *);
int	auixp_commit_settings(void *);
int	auixp_round_blocksize(void *, int);
int	auixp_trigger_output(void *, void *, void *, int,
    void (*)(void *), void *, struct audio_params *);
int	auixp_trigger_input(void *, void *, void *, int,
    void (*)(void *), void *, struct audio_params *);
int	auixp_halt_output(void *);
int	auixp_halt_input(void *);
int	auixp_set_port(void *, mixer_ctrl_t *);
int	auixp_get_port(void *, mixer_ctrl_t *);
int	auixp_query_devinfo(void *, mixer_devinfo_t *);
void *	auixp_malloc(void *, int, size_t, int, int);
void	auixp_free(void *, void *, int);
size_t	auixp_round_buffersize(void *, int, size_t);
int	auixp_get_props(void *);
int	auixp_intr(void *);
int	auixp_allocmem(struct auixp_softc *, size_t, size_t,
    struct auixp_dma *);
int	auixp_freemem(struct auixp_softc *, struct auixp_dma *);

/* Supporting subroutines */
int	auixp_init(struct auixp_softc *);
void	auixp_autodetect_codecs(struct auixp_softc *);
void	auixp_post_config(struct device *);

void	auixp_reset_aclink(struct auixp_softc *);
int	auixp_attach_codec(void *, struct ac97_codec_if *);
int	auixp_read_codec(void *, u_int8_t, u_int16_t *);
int	auixp_write_codec(void *, u_int8_t, u_int16_t);
int	auixp_wait_for_codecs(struct auixp_softc *, const char *);
void	auixp_reset_codec(void *);
enum ac97_host_flags	auixp_flags_codec(void *);

void	auixp_enable_dma(struct auixp_softc *, struct auixp_dma *);
void	auixp_disable_dma(struct auixp_softc *, struct auixp_dma *);
void	auixp_enable_interrupts(struct auixp_softc *);
void	auixp_disable_interrupts(struct auixp_softc *);

void	auixp_link_daisychain(struct auixp_softc *,
    struct auixp_dma *, struct auixp_dma *, int, int);
int	auixp_allocate_dma_chain(struct auixp_softc *, struct auixp_dma **);
void	auixp_program_dma_chain(struct auixp_softc *, struct auixp_dma *);
void	auixp_dma_update(struct auixp_softc *, struct auixp_dma *);
void	auixp_update_busbusy(struct auixp_softc *);

#ifdef DEBUG_AUIXP
#define DPRINTF(x)	printf x;
#else
#define DPRINTF(x)
#endif

struct audio_hw_if auixp_hw_if = {
	auixp_open,
	auixp_close,
	auixp_set_params,
	auixp_round_blocksize,
	auixp_commit_settings,
	NULL,			/* init_output  */
	NULL,			/* init_input   */
	NULL,			/* start_output */
	NULL,			/* start_input  */
	auixp_halt_output,
	auixp_halt_input,
	NULL,			/* speaker_ctl */
	NULL,			/* getfd */
	auixp_set_port,
	auixp_get_port,
	auixp_query_devinfo,
	auixp_malloc,
	auixp_free,
	auixp_round_buffersize,
	auixp_get_props,
	auixp_trigger_output,
	auixp_trigger_input
};

int
auixp_open(void *v, int flags)
{

	return 0;
}

void
auixp_close(void *v)
{
}

/* commit setting and program ATI IXP chip */
int
auixp_commit_settings(void *hdl)
{
	struct auixp_codec *co;
	struct auixp_softc *sc;
	bus_space_tag_t    iot;
	bus_space_handle_t ioh;
	struct audio_params *params;
	u_int32_t value;

	/* XXX would it be better to stop interrupts first? XXX */
	co = (struct auixp_codec *) hdl;
	sc = co->sc;
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

	/* process input settings */
	params = &sc->sc_play_params;

	/* set input interleaving (precision) */
	value  =  bus_space_read_4(iot, ioh, ATI_REG_CMD);
	value &= ~ATI_REG_CMD_INTERLEAVE_IN;
	if (params->precision <= 16)
		value |= ATI_REG_CMD_INTERLEAVE_IN;
	bus_space_write_4(iot, ioh, ATI_REG_CMD, value);

	/* process output settings */
	params = &sc->sc_play_params;

	value  =  bus_space_read_4(iot, ioh, ATI_REG_OUT_DMA_SLOT);
	value &= ~ATI_REG_OUT_DMA_SLOT_MASK;

	/* TODO SPDIF case for 8 channels */
	switch (params->channels) {
	case 6:
		value |= ATI_REG_OUT_DMA_SLOT_BIT(7) |
			 ATI_REG_OUT_DMA_SLOT_BIT(8);
		/* FALLTHROUGH */
	case 4:
		value |= ATI_REG_OUT_DMA_SLOT_BIT(6) |
			 ATI_REG_OUT_DMA_SLOT_BIT(9);
		/* FALLTHROUGH */
	default:
		value |= ATI_REG_OUT_DMA_SLOT_BIT(3) |
			 ATI_REG_OUT_DMA_SLOT_BIT(4);
		break;
	}
	/* set output threshold */
	value |= 0x04 << ATI_REG_OUT_DMA_THRESHOLD_SHIFT;
	bus_space_write_4(iot, ioh, ATI_REG_OUT_DMA_SLOT, value);

	/* set output interleaving (precision) */
	value  =  bus_space_read_4(iot, ioh, ATI_REG_CMD);
	value &= ~ATI_REG_CMD_INTERLEAVE_OUT;
	if (params->precision <= 16)
		value |= ATI_REG_CMD_INTERLEAVE_OUT;
	bus_space_write_4(iot, ioh, ATI_REG_CMD, value);

	/* enable 6 channel reordering */
	value  =  bus_space_read_4(iot, ioh, ATI_REG_6CH_REORDER);
	value &= ~ATI_REG_6CH_REORDER_EN;
	if (params->channels == 6)
		value |= ATI_REG_6CH_REORDER_EN;
	bus_space_write_4(iot, ioh, ATI_REG_6CH_REORDER, value);

	if (sc->has_spdif) {
		/* set SPDIF (if present) */
		value  =  bus_space_read_4(iot, ioh, ATI_REG_CMD);
		value &= ~ATI_REG_CMD_SPDF_CONFIG_MASK;
		value |=  ATI_REG_CMD_SPDF_CONFIG_34; /* NetBSD AC'97 default */

		/* XXX this is probably not necessary unless splitted XXX */
		value &= ~ATI_REG_CMD_INTERLEAVE_SPDF;
		if (params->precision <= 16)
			value |= ATI_REG_CMD_INTERLEAVE_SPDF;
		bus_space_write_4(iot, ioh, ATI_REG_CMD, value);
	}

	return 0;
}


/* set audio properties in desired setting */
int
auixp_set_params(void *hdl, int setmode, int usemode,
    struct audio_params *play, struct audio_params *rec)
{
	struct auixp_codec *co;
	int error;
	u_int temprate;

	co = (struct auixp_codec *) hdl;
	if (setmode & AUMODE_PLAY) {
		play->channels = 2;
		play->precision = 16;
		switch(play->encoding) {
		case AUDIO_ENCODING_SLINEAR_LE:
			break;
		default:
			return (EINVAL);
		}
		play->bps = AUDIO_BPS(play->precision);
		play->msb = 1;

		temprate = play->sample_rate;
		error = ac97_set_rate(co->codec_if,
		    AC97_REG_PCM_LFE_DAC_RATE, &play->sample_rate);
		if (error)
			return (error);

		play->sample_rate = temprate;
		error = ac97_set_rate(co->codec_if,
		    AC97_REG_PCM_SURR_DAC_RATE, &play->sample_rate);
		if (error)
			return (error);

		play->sample_rate = temprate;
		error = ac97_set_rate(co->codec_if,
		    AC97_REG_PCM_FRONT_DAC_RATE, &play->sample_rate);
		if (error)
			return (error);

	}

	if (setmode & AUMODE_RECORD) {		
		rec->channels = 2;
		rec->precision = 16;
		switch(rec->encoding) {
		case AUDIO_ENCODING_SLINEAR_LE:
			break;
		default:
			return (EINVAL);
		}
		rec->bps = AUDIO_BPS(rec->precision);
		rec->msb = 1;

		error = ac97_set_rate(co->codec_if, AC97_REG_PCM_LR_ADC_RATE,
		    &rec->sample_rate);
		if (error)
			return (error);
	}

	return (0);
}


/* called to translate a requested blocksize to a hw-possible one */
int
auixp_round_blocksize(void *v, int blk)
{

	blk = (blk + 0x1f) & ~0x1f;
	/* Be conservative; align to 32 bytes and maximise it to 64 kb */
	if (blk > 0x10000)
		blk = 0x10000;

	return blk;
}


/*
 * allocate dma capable memory and record its information for later retrieval
 * when we program the dma chain itself. The trigger routines passes on the
 * kernel virtual address we return here as a reference to the mapping.
 */
void *
auixp_malloc(void *hdl, int direction, size_t size, int pool, int flags)
{
	struct auixp_codec *co;
	struct auixp_softc *sc;
	struct auixp_dma *dma;
	int error;

	co = (struct auixp_codec *) hdl;
	sc = co->sc;
	/* get us a auixp_dma structure */
	dma = malloc(sizeof(*dma), pool, flags);
	if (!dma)
		return NULL;

	/* get us a dma buffer itself */
	error = auixp_allocmem(sc, size, 16, dma);
	if (error) {
		free(dma, pool, 0);
		printf("%s: auixp_malloc: not enough memory\n",
		    sc->sc_dev.dv_xname);
		return NULL;
	}
	SLIST_INSERT_HEAD(&sc->sc_dma_list, dma, dma_chain);

	DPRINTF(("auixp_malloc: returning kern %p,   hw 0x%08x for %d bytes "
	    "in %d segs\n", KERNADDR(dma), (u_int32_t) DMAADDR(dma), dma->size,
	    dma->nsegs)
	);

	return KERNADDR(dma);
}

/*
 * free and release dma capable memory we allocated before and remove its
 * recording
 */
void
auixp_free(void *hdl, void *addr, int pool)
{
	struct auixp_codec *co;
	struct auixp_softc *sc;
	struct auixp_dma *dma;

	co = (struct auixp_codec *) hdl;
	sc = co->sc;
	SLIST_FOREACH(dma, &sc->sc_dma_list, dma_chain) {
		if (KERNADDR(dma) == addr) {
			SLIST_REMOVE(&sc->sc_dma_list, dma, auixp_dma,
			    dma_chain);
			auixp_freemem(sc, dma);
			free(dma, pool, 0);
			return;
		}
	}
}

/* pass request to AC'97 codec code */
int
auixp_set_port(void *hdl, mixer_ctrl_t *mc)
{
	struct auixp_codec *co;

	co = (struct auixp_codec *) hdl;
	return co->codec_if->vtbl->mixer_set_port(co->codec_if, mc);
}


/* pass request to AC'97 codec code */
int
auixp_get_port(void *hdl, mixer_ctrl_t *mc)
{
	struct auixp_codec *co;

	co = (struct auixp_codec *) hdl;
	return co->codec_if->vtbl->mixer_get_port(co->codec_if, mc);
}

/* pass request to AC'97 codec code */
int
auixp_query_devinfo(void *hdl, mixer_devinfo_t *di)
{
	struct auixp_codec *co;

	co = (struct auixp_codec *) hdl;
	return co->codec_if->vtbl->query_devinfo(co->codec_if, di);
}


size_t
auixp_round_buffersize(void *hdl, int direction, size_t bufsize)
{

	/* XXX force maximum? i.e. 256 kb? */
	return bufsize;
}


int
auixp_get_props(void *hdl)
{

	return AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT | AUDIO_PROP_FULLDUPLEX;
}


/*
 * A dma descriptor has dma->nsegs segments defined in dma->segs set up when
 * we claimed the memory.
 *
 * Due to our demand for one contiguous DMA area, we only have one segment. A
 * c_dma structure is about 3 kb for the 256 entries we maximally program
 * -arbitrary limit AFAIK- so all is most likely to be in one segment/page
 * anyway.
 *
 * XXX ought to implement fragmented dma area XXX
 *
 * Note that _v variables depict kernel virtual addresses, _p variables depict
 * physical addresses.
 */
void
auixp_link_daisychain(struct auixp_softc *sc,
		struct auixp_dma *c_dma, struct auixp_dma *s_dma,
		int blksize, int blocks)
{
	atiixp_dma_desc_t *caddr_v, *next_caddr_v;
	u_int32_t caddr_p, next_caddr_p, saddr_p;
	int i;

	/* just make sure we are not changing when its running */
	auixp_disable_dma(sc, c_dma);

	/* setup dma chain start addresses */
	caddr_v = KERNADDR(c_dma);
	caddr_p = DMAADDR(c_dma);
	saddr_p = DMAADDR(s_dma);

	/* program the requested number of blocks */
	for (i = 0; i < blocks; i++) {
		/* clear the block just in case */
		bzero(caddr_v, sizeof(atiixp_dma_desc_t));

		/* round robin the chain dma addresses for its successor */
		next_caddr_v = caddr_v + 1;
		next_caddr_p = caddr_p + sizeof(atiixp_dma_desc_t);

		if (i == blocks-1) {
			next_caddr_v = KERNADDR(c_dma);
			next_caddr_p = DMAADDR(c_dma);
		}

		/* fill in the hardware dma chain descriptor in little-endian */
		caddr_v->addr   = htole32(saddr_p);
		caddr_v->status = htole16(0);
		caddr_v->size   = htole16((blksize >> 2)); /* in dwords (!!!) */
		caddr_v->next   = htole32(next_caddr_p);

		/* advance slot */
		saddr_p += blksize;	/* XXX assuming contiguous XXX */
		caddr_v  = next_caddr_v;
		caddr_p  = next_caddr_p;
	}
}


int
auixp_allocate_dma_chain(struct auixp_softc *sc, struct auixp_dma **dmap)
{
	struct auixp_dma *dma;
	int error;

	/* allocate keeper of dma area */
	*dmap = NULL;
	dma = malloc(sizeof(*dma), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (!dma)
		return ENOMEM;

	/* allocate for daisychain of IXP hardware-dma descriptors */
	error = auixp_allocmem(sc, DMA_DESC_CHAIN * sizeof(atiixp_dma_desc_t),
	    16, dma);
	if (error) {
		printf("%s: can't malloc dma descriptor chain\n",
		    sc->sc_dev.dv_xname);
		free(dma, M_DEVBUF, 0);
		return ENOMEM;
	}

	/* return info and initialise structure */
	dma->intr    = NULL;
	dma->intrarg = NULL;

	*dmap = dma;
	return 0;
}


/* program dma chain in its link address descriptor */
void
auixp_program_dma_chain(struct auixp_softc *sc, struct auixp_dma *dma)
{
	bus_space_tag_t    iot;
	bus_space_handle_t ioh;
	u_int32_t value;

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
	/* get hardware start address of DMA chain and set valid-flag in it */
	/* XXX always at start? XXX */
	value = DMAADDR(dma);
	value = value | ATI_REG_LINKPTR_EN;

	/* reset linkpointer */
	bus_space_write_4(iot, ioh, dma->linkptr, 0);

	/* reset this DMA engine */
	auixp_disable_dma(sc, dma);
	auixp_enable_dma(sc, dma);

	/* program new DMA linkpointer */
	bus_space_write_4(iot, ioh, dma->linkptr, value);
}


/* called from interrupt code to signal end of one dma-slot */
void
auixp_dma_update(struct auixp_softc *sc, struct auixp_dma *dma)
{

	/* be very paranoid */
	if (!dma)
		panic("auixp: update: dma = NULL");
	if (!dma->intr)
		panic("auixp: update: dma->intr = NULL");

	/* request more input from upper layer */
	(*dma->intr)(dma->intrarg);
}


/*
 * The magic `busbusy' bit that needs to be set when dma is active; allowing
 * busmastering?
 */
void
auixp_update_busbusy(struct auixp_softc *sc)
{
	bus_space_tag_t    iot;
	bus_space_handle_t ioh;
	u_int32_t value;
	int running;

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
	/* set bus-busy flag when either recording or playing is performed */
	value  = bus_space_read_4(iot, ioh, ATI_REG_IER);
	value &= ~ATI_REG_IER_SET_BUS_BUSY;

	running = ((sc->sc_output_dma->running) || (sc->sc_input_dma->running));
	if (running)
		value |= ATI_REG_IER_SET_BUS_BUSY;

	bus_space_write_4(iot, ioh, ATI_REG_IER, value);

}


/*
 * Called from upper audio layer to request playing audio, only called once;
 * audio is refilled by calling the intr() function when space is available
 * again.
 */
/* XXX almost literally a copy of trigger-input; could be factorised XXX */
int
auixp_trigger_output(void *hdl, void *start, void *end, int blksize,
    void (*intr)(void *), void *intrarg, struct audio_params *param)
{
	struct auixp_codec *co;
	struct auixp_softc *sc;
	struct auixp_dma   *chain_dma;
	struct auixp_dma   *sound_dma;
	u_int32_t blocks;

	co = (struct auixp_codec *) hdl;
	sc = co->sc;
	chain_dma = sc->sc_output_dma;
	/* add functions to call back */
	chain_dma->intr    = intr;
	chain_dma->intrarg = intrarg;

	/*
	 * Program output DMA chain with blocks from [start...end] with
	 * blksize fragments.
	 *
	 * NOTE, we can assume its in one block since we asked for it to be in
	 * one contiguous blob; XXX change this? XXX
	 */
	blocks = (size_t) (((caddr_t) end) - ((caddr_t) start)) / blksize;

	/* lookup `start' address in our list of DMA area's */
	SLIST_FOREACH(sound_dma, &sc->sc_dma_list, dma_chain) {
		if (KERNADDR(sound_dma) == start)
			break;
	}

	/* not ours ? then bail out */
	if (!sound_dma) {
		printf("%s: auixp_trigger_output: bad sound addr %p\n",
		    sc->sc_dev.dv_xname, start);
		return EINVAL;
	}

	/* link round-robin daisychain and program hardware */
	auixp_link_daisychain(sc, chain_dma, sound_dma, blksize, blocks);
	auixp_program_dma_chain(sc, chain_dma);

	/* mark we are now able to run now */
	mtx_enter(&audio_lock);
	chain_dma->running = 1;

	/* update bus-flags; XXX programs more flags XXX */
	auixp_update_busbusy(sc);
	mtx_leave(&audio_lock);

	/* callbacks happen in interrupt routine */
	return 0;
}


/* halt output of audio, just disable its dma and update bus state */
int
auixp_halt_output(void *hdl)
{
	struct auixp_codec *co;
	struct auixp_softc *sc;
	struct auixp_dma   *dma;

	mtx_enter(&audio_lock);
	co  = (struct auixp_codec *) hdl;
	sc  = co->sc;
	dma = sc->sc_output_dma;
	auixp_disable_dma(sc, dma);

	dma->running = 0;
	auixp_update_busbusy(sc);
	mtx_leave(&audio_lock);
	return 0;
}


/* XXX almost literally a copy of trigger-output; could be factorised XXX */
int
auixp_trigger_input(void *hdl, void *start, void *end, int blksize,
    void (*intr)(void *), void *intrarg, struct audio_params *param)
{
	struct auixp_codec *co;
	struct auixp_softc *sc;
	struct auixp_dma   *chain_dma;
	struct auixp_dma   *sound_dma;
	u_int32_t blocks;

	co = (struct auixp_codec *) hdl;
	sc = co->sc;
	chain_dma = sc->sc_input_dma;
	/* add functions to call back */
	chain_dma->intr    = intr;
	chain_dma->intrarg = intrarg;

	/*
	 * Program output DMA chain with blocks from [start...end] with
	 * blksize fragments.
	 *
	 * NOTE, we can assume its in one block since we asked for it to be in
	 * one contiguous blob; XXX change this? XXX
	 */
	blocks = (size_t) (((caddr_t) end) - ((caddr_t) start)) / blksize;

	/* lookup `start' address in our list of DMA area's */
	SLIST_FOREACH(sound_dma, &sc->sc_dma_list, dma_chain) {
		if (KERNADDR(sound_dma) == start)
			break;
	}

	/* not ours ? then bail out */
	if (!sound_dma) {
		printf("%s: auixp_trigger_input: bad sound addr %p\n",
		    sc->sc_dev.dv_xname, start);
		return EINVAL;
	}

	/* link round-robin daisychain and program hardware */
	auixp_link_daisychain(sc, chain_dma, sound_dma, blksize, blocks);
	auixp_program_dma_chain(sc, chain_dma);

	/* mark we are now able to run now */
	mtx_enter(&audio_lock);
	chain_dma->running = 1;

	/* update bus-flags; XXX programs more flags XXX */
	auixp_update_busbusy(sc);
	mtx_leave(&audio_lock);

	/* callbacks happen in interrupt routine */
	return 0;
}


/* halt sampling audio, just disable its dma and update bus state */
int
auixp_halt_input(void *hdl)
{
	struct auixp_codec *co;
	struct auixp_softc *sc;
	struct auixp_dma   *dma;

	mtx_enter(&audio_lock);
	co = (struct auixp_codec *) hdl;
	sc = co->sc;
	dma = sc->sc_input_dma;
	auixp_disable_dma(sc, dma);

	dma->running = 0;
	auixp_update_busbusy(sc);

	mtx_leave(&audio_lock);
	return 0;
}


/*
 * IXP audio interrupt handler
 *
 * note that we return the number of bits handled; the return value is not
 * documented but I saw it implemented in other drivers. Probably returning a
 * value > 0 means "I've dealt with it"
 *
 */
int
auixp_intr(void *softc)
{
	struct auixp_softc *sc;
	bus_space_tag_t    iot;
	bus_space_handle_t ioh;
	u_int32_t status, enable, detected_codecs;
	int ret;

	mtx_enter(&audio_lock);
	sc = softc;
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
	ret = 0;
	/* get status from the interrupt status register */
	status = bus_space_read_4(iot, ioh, ATI_REG_ISR);

	if (status == 0) {
		mtx_leave(&audio_lock);
		return 0;
	}

	DPRINTF(("%s: (status = %x)\n", sc->sc_dev.dv_xname, status));

	/* check DMA UPDATE flags for input & output */
	if (status & ATI_REG_ISR_IN_STATUS) {
		ret++; DPRINTF(("IN_STATUS\n"));
		auixp_dma_update(sc, sc->sc_input_dma);
	}
	if (status & ATI_REG_ISR_OUT_STATUS) {
		ret++; DPRINTF(("OUT_STATUS\n"));
		auixp_dma_update(sc, sc->sc_output_dma);
	}

	/* XXX XRUN flags not used/needed yet; should i implement it? XXX */
	/* acknowledge the interrupts nevertheless */
	if (status & ATI_REG_ISR_IN_XRUN) {
		ret++; DPRINTF(("IN_XRUN\n"));
		/* auixp_dma_xrun(sc, sc->sc_input_dma);  */
	}
	if (status & ATI_REG_ISR_OUT_XRUN) {
		ret++; DPRINTF(("OUT_XRUN\n"));
		/* auixp_dma_xrun(sc, sc->sc_output_dma); */
	}

	/* check if we are looking for codec detection */
	if (status & CODEC_CHECK_BITS) {
		ret++;
		/* mark missing codecs as not ready */
		detected_codecs = status & CODEC_CHECK_BITS;
		sc->sc_codec_not_ready_bits |= detected_codecs;

		/* disable detected interrupt sources */
		enable  = bus_space_read_4(iot, ioh, ATI_REG_IER);
		enable &= ~detected_codecs;
		bus_space_write_4(iot, ioh, ATI_REG_IER, enable);
	}

	/* acknowledge interrupt sources */
	bus_space_write_4(iot, ioh, ATI_REG_ISR, status);
	mtx_leave(&audio_lock);
	return ret;
}


/* allocate memory for dma purposes; on failure of any of the steps, roll back */
int
auixp_allocmem(struct auixp_softc *sc, size_t size,
	       size_t align, struct auixp_dma *dma)
{
	int error;

	/* remember size */
	dma->size = size;

	/* allocate DMA safe memory but in just one segment for now :( */
	error = bus_dmamem_alloc(sc->sc_dmat, dma->size, align, 0,
	    dma->segs, sizeof(dma->segs) / sizeof(dma->segs[0]), &dma->nsegs,
	    BUS_DMA_NOWAIT);
	if (error)
		return error;

	/*
	 * map allocated memory into kernel virtual address space and keep it
	 * coherent with the CPU.
	 */
	error = bus_dmamem_map(sc->sc_dmat, dma->segs, dma->nsegs, dma->size,
				&dma->addr, BUS_DMA_NOWAIT | BUS_DMA_COHERENT);
	if (error)
		goto free;

	/* allocate associated dma handle and initialize it. */
	error = bus_dmamap_create(sc->sc_dmat, dma->size, 1, dma->size, 0,
				  BUS_DMA_NOWAIT, &dma->map);
	if (error)
		goto unmap;

	/*
	 * load the dma handle with mappings for a dma transfer; all pages
	 * need to be wired.
	 */
	error = bus_dmamap_load(sc->sc_dmat, dma->map, dma->addr, dma->size, NULL,
				BUS_DMA_NOWAIT);
	if (error)
		goto destroy;

	return 0;

destroy:
	bus_dmamap_destroy(sc->sc_dmat, dma->map);
unmap:
	bus_dmamem_unmap(sc->sc_dmat, dma->addr, dma->size);
free:
	bus_dmamem_free(sc->sc_dmat, dma->segs, dma->nsegs);

	return error;
}


/* undo dma mapping and release memory allocated */
int
auixp_freemem(struct auixp_softc *sc, struct auixp_dma *p)
{

	bus_dmamap_unload(sc->sc_dmat, p->map);
	bus_dmamap_destroy(sc->sc_dmat, p->map);
	bus_dmamem_unmap(sc->sc_dmat, p->addr, p->size);
	bus_dmamem_free(sc->sc_dmat, p->segs, p->nsegs);

	return 0;
}

int
auixp_match(struct device *dev, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, auixp_pci_devices,
	    sizeof(auixp_pci_devices)/sizeof(auixp_pci_devices[0])));
}

int
auixp_activate(struct device *self, int act)
{
	struct auixp_softc *sc = (struct auixp_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		auixp_disable_interrupts(sc);
		break;
	case DVACT_RESUME:
		auixp_init(sc);
		ac97_resume(&sc->sc_codec.host_if, sc->sc_codec.codec_if);
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

void
auixp_attach(struct device *parent, struct device *self, void *aux)
{
	struct auixp_softc *sc;
	struct pci_attach_args *pa;
	pcitag_t tag;
	pci_chipset_tag_t pc;
	pci_intr_handle_t ih;
	const char *intrstr;

	sc = (struct auixp_softc *)self;
	pa = (struct pci_attach_args *)aux;
	tag = pa->pa_tag;
	pc = pa->pa_pc;

	/* map memory; its not sized -> what is the size? max PCI slot size? */
	if (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->sc_iot, &sc->sc_ioh, &sc->sc_iob, &sc->sc_ios, 0)) {
		printf(": can't map mem space\n");
		return;
	}

	/* Initialize softc */
	sc->sc_tag = tag;
	sc->sc_pct = pc;
	sc->sc_dmat = pa->pa_dmat;
	SLIST_INIT(&sc->sc_dma_list);

	/* get us the auixp_dma structures */
	auixp_allocate_dma_chain(sc, &sc->sc_output_dma);
	auixp_allocate_dma_chain(sc, &sc->sc_input_dma);

	/* when that fails we are dead in the water */
	if (!sc->sc_output_dma || !sc->sc_input_dma)
		return;

#if 0
	/* could preliminary program DMA chain */
	auixp_program_dma_chain(sc, sc->sc_output_dma);
	auixp_program_dma_chain(sc, sc->sc_input_dma);
#endif

	if (pci_intr_map(pa, &ih)) {
		printf(": can't map interrupt\n");
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO | IPL_MPSAFE,
	    auixp_intr, sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": can't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s\n", intrstr);

	/* power up chip */
	pci_set_powerstate(pc, tag, PCI_PMCSR_STATE_D0);

	/* init chip */
	if (auixp_init(sc) == -1) {
		printf("%s: auixp_attach: unable to initialize the card\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/*
	 * delay further configuration of codecs and audio after interrupts
	 * are enabled.
	 */
	config_mountroot(self, auixp_post_config);
}

/* called from autoconfigure system when interrupts are enabled */
void
auixp_post_config(struct device *self)
{
	struct auixp_softc *sc = (struct auixp_softc *)self;

	/* detect the AC97 codecs */
	auixp_autodetect_codecs(sc);

	/* Bail if no codecs attached. */
	if (!sc->sc_codec.present) {
		printf("%s: no codecs detected or initialised\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	audio_attach_mi(&auixp_hw_if, &sc->sc_codec, &sc->sc_dev);

#if notyet
	/* copy formats and invalidate entries not suitable for codec0 */
	sc->has_4ch   = AC97_IS_4CH(sc->sc_codec.codec_if);
	sc->has_6ch   = AC97_IS_6CH(sc->sc_codec.codec_if);
	sc->is_fixed  = AC97_IS_FIXED_RATE(sc->sc_codec.codec_if);
	sc->has_spdif = AC97_HAS_SPDIF(sc->sc_codec.codec_if);
#endif

	if (sc->has_spdif)
		sc->has_spdif = 0;

	/* fill in the missing details about the dma channels. */
	/* for output */
	sc->sc_output_dma->linkptr        = ATI_REG_OUT_DMA_LINKPTR;
	sc->sc_output_dma->dma_enable_bit = ATI_REG_CMD_OUT_DMA_EN |
					    ATI_REG_CMD_SEND_EN;
	/* have spdif? then this too! XXX not seeing LED yet! XXX */
	if (sc->has_spdif)
		sc->sc_output_dma->dma_enable_bit |= ATI_REG_CMD_SPDF_OUT_EN;

	/* and for input */
	sc->sc_input_dma->linkptr         = ATI_REG_IN_DMA_LINKPTR;
	sc->sc_input_dma->dma_enable_bit  = ATI_REG_CMD_IN_DMA_EN  |
					    ATI_REG_CMD_RECEIVE_EN;

	/* done! now enable all interrupts we can service */
	auixp_enable_interrupts(sc);
}

void
auixp_enable_interrupts(struct auixp_softc *sc)
{
	bus_space_tag_t     iot;
	bus_space_handle_t  ioh;
	u_int32_t value;

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
	/* clear all pending */
	bus_space_write_4(iot, ioh, ATI_REG_ISR, 0xffffffff);

	/* enable all relevant interrupt sources we can handle */
	value = bus_space_read_4(iot, ioh, ATI_REG_IER);

	value |= ATI_REG_IER_IO_STATUS_EN;
#ifdef notyet
	value |= ATI_REG_IER_IN_XRUN_EN;
	value |= ATI_REG_IER_OUT_XRUN_EN;

	value |= ATI_REG_IER_SPDIF_XRUN_EN;
	value |= ATI_REG_IER_SPDF_STATUS_EN;
#endif

	bus_space_write_4(iot, ioh, ATI_REG_IER, value);
}

void
auixp_disable_interrupts(struct auixp_softc *sc)
{
	bus_space_tag_t     iot;
	bus_space_handle_t  ioh;

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
	/* disable all interrupt sources */
	bus_space_write_4(iot, ioh, ATI_REG_IER, 0);

	/* clear all pending */
	bus_space_write_4(iot, ioh, ATI_REG_ISR, 0xffffffff);
}

/* dismantle what we've set up by undoing setup */
int
auixp_detach(struct device *self, int flags)
{
	struct auixp_softc *sc;

	sc = (struct auixp_softc *)self;
	/* XXX shouldn't we just reset the chip? XXX */
	/*
	 * should we explicitly disable interrupt generation and acknowledge
	 * what's left on? better be safe than sorry.
	 */
	auixp_disable_interrupts(sc);

	/* tear down .... */
	config_detach(&sc->sc_dev, flags);	/* XXX OK? XXX */

	if (sc->sc_ih != NULL)
		pci_intr_disestablish(sc->sc_pct, sc->sc_ih);
	if (sc->sc_ios)
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_ios);
	return 0;
}


/*
 * codec handling
 *
 * IXP audio support can have upto 3 codecs! are they chained ? or
 * alternative outlets with the same audio feed i.e. with different mixer
 * settings? XXX does NetBSD support more than one audio codec? XXX
 */


int
auixp_attach_codec(void *aux, struct ac97_codec_if *codec_if)
{
	struct auixp_codec *ixp_codec;

	ixp_codec = aux;
	ixp_codec->codec_if = codec_if;

	return 0;
}

int
auixp_read_codec(void *aux, u_int8_t reg, u_int16_t *result)
{
	struct auixp_codec *co;
	struct auixp_softc *sc;
	bus_space_tag_t     iot;
	bus_space_handle_t  ioh;
	u_int32_t data;
	int timeout;

	co  = aux;
	sc  = co->sc;
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
	if (auixp_wait_for_codecs(sc, "read_codec"))
		return 0xffff;

	/* build up command for reading codec register */
	data = (reg << ATI_REG_PHYS_OUT_ADDR_SHIFT) |
		ATI_REG_PHYS_OUT_ADDR_EN |
		ATI_REG_PHYS_OUT_RW |
		co->codec_nr;

	bus_space_write_4(iot, ioh, ATI_REG_PHYS_OUT_ADDR, data);

	if (auixp_wait_for_codecs(sc, "read_codec"))
		return 0xffff;

	/* wait until codec info is clocked in */
	timeout = 500;		/* 500*2 usec -> 0.001 sec */
	do {
		data = bus_space_read_4(iot, ioh, ATI_REG_PHYS_IN_ADDR);
		if (data & ATI_REG_PHYS_IN_READ_FLAG) {
			DPRINTF(("read ac'97 codec reg 0x%x = 0x%08x\n",
				reg, data >> ATI_REG_PHYS_IN_DATA_SHIFT));
			*result = data >> ATI_REG_PHYS_IN_DATA_SHIFT;
			return 0;
		}
		DELAY(2);
		timeout--;
	} while (timeout > 0);

	if (reg < 0x7c)
		printf("%s: codec read timeout! (reg %x)\n",
		    sc->sc_dev.dv_xname, reg);

	return 0xffff;
}

int
auixp_write_codec(void *aux, u_int8_t reg, u_int16_t data)
{
	struct auixp_codec *co;
	struct auixp_softc *sc;
	bus_space_tag_t     iot;
	bus_space_handle_t  ioh;
	u_int32_t value;

	DPRINTF(("write ac'97 codec reg 0x%x = 0x%08x\n", reg, data));
	co  = aux;
	sc  = co->sc;
	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
	if (auixp_wait_for_codecs(sc, "write_codec"))
		return -1;

	/* build up command for writing codec register */
	value = (((u_int32_t) data) << ATI_REG_PHYS_OUT_DATA_SHIFT) |
		(((u_int32_t)  reg) << ATI_REG_PHYS_OUT_ADDR_SHIFT) |
		ATI_REG_PHYS_OUT_ADDR_EN |
		co->codec_nr;

	bus_space_write_4(iot, ioh, ATI_REG_PHYS_OUT_ADDR, value);

	return 0;
}

void
auixp_reset_codec(void *aux)
{

	/* nothing to be done? */
}

enum ac97_host_flags
auixp_flags_codec(void *aux)
{
	struct auixp_codec *ixp_codec;

	ixp_codec = aux;
	return ixp_codec->codec_flags;
}

int
auixp_wait_for_codecs(struct auixp_softc *sc, const char *func)
{
	bus_space_tag_t      iot;
	bus_space_handle_t   ioh;
	u_int32_t value;
	int timeout;

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
	/* wait until all codec transfers are done */
	timeout = 500;		/* 500*2 usec -> 0.001 sec */
	do {
		value = bus_space_read_4(iot, ioh, ATI_REG_PHYS_OUT_ADDR);
		if ((value & ATI_REG_PHYS_OUT_ADDR_EN) == 0)
			return 0;

		DELAY(2);
		timeout--;
	} while (timeout > 0);

	printf("%s: %s: timed out\n", func, sc->sc_dev.dv_xname);
	return -1;
}

void
auixp_autodetect_codecs(struct auixp_softc *sc)
{
	bus_space_tag_t      iot;
	bus_space_handle_t   ioh;
	pcireg_t subdev;
	struct auixp_codec  *codec;
	int timeout;

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
	subdev = pci_conf_read(sc->sc_pct, sc->sc_tag, PCI_SUBSYS_ID_REG);

	/* ATI IXP can have upto 3 codecs; mark all codecs as not existing */
	sc->sc_codec_not_ready_bits = 0;

	/* enable all codecs to interrupt as well as the new frame interrupt */
	bus_space_write_4(iot, ioh, ATI_REG_IER, CODEC_CHECK_BITS);

	/* wait for the interrupts to happen */
	timeout = 100;		/* 100.000 usec -> 0.1 sec */

	while (timeout > 0) {
		DELAY(1000);
		if (sc->sc_codec_not_ready_bits)
			break;
		timeout--;
	}

	if (timeout == 0)
		printf("%s: WARNING: timeout during codec detection; "
			"codecs might be present but haven't interrupted\n",
			sc->sc_dev.dv_xname);

	/* disable all interrupts for now */
	auixp_disable_interrupts(sc);

	/* Attach AC97 host interfaces */
	codec = &sc->sc_codec;
	bzero(codec, sizeof(struct auixp_codec));

	codec->sc       = sc;

	codec->host_if.arg    = codec;
	codec->host_if.attach = auixp_attach_codec;
	codec->host_if.read   = auixp_read_codec;
	codec->host_if.write  = auixp_write_codec;
	codec->host_if.reset  = auixp_reset_codec;
	codec->host_if.flags  = auixp_flags_codec;
	switch (subdev) {
	case 0x1311462: /* MSI S270 */
	case 0x1611462: /* LG K1 Express */
	case 0x3511462: /* MSI L725 */
	case 0x4711462: /* MSI L720 */
	case 0x0611462: /* MSI S250 */
		codec->codec_flags = AC97_HOST_ALC650_PIN47_IS_EAPD;
		break;
	}

	if (!(sc->sc_codec_not_ready_bits & ATI_REG_ISR_CODEC0_NOT_READY)) {
		/* codec 0 present */
		DPRINTF(("auixp : YAY! codec 0 present!\n"));
		if (ac97_attach(&sc->sc_codec.host_if) == 0) {
			sc->sc_codec.codec_nr = 0;
			sc->sc_codec.present = 1;
			return;
		}
	}

	if (!(sc->sc_codec_not_ready_bits & ATI_REG_ISR_CODEC1_NOT_READY)) {
		/* codec 1 present */
		DPRINTF(("auixp : YAY! codec 1 present!\n"));
		if (ac97_attach(&sc->sc_codec.host_if) == 0) {
			sc->sc_codec.codec_nr = 1;
			sc->sc_codec.present = 1;
			return;
		}
	}

	if (!(sc->sc_codec_not_ready_bits & ATI_REG_ISR_CODEC2_NOT_READY)) {
		/* codec 2 present */
		DPRINTF(("auixp : YAY! codec 2 present!\n"));
		if (ac97_attach(&sc->sc_codec.host_if) == 0) {
			sc->sc_codec.codec_nr = 2;
			sc->sc_codec.present = 1;
			return;
		}
	}
}

void
auixp_disable_dma(struct auixp_softc *sc, struct auixp_dma *dma)
{
	bus_space_tag_t      iot;
	bus_space_handle_t   ioh;
	u_int32_t value;

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
	/* lets not stress the DMA engine more than necessary */
	value = bus_space_read_4(iot, ioh, ATI_REG_CMD);
	if (value & dma->dma_enable_bit) {
		value &= ~dma->dma_enable_bit;
		bus_space_write_4(iot, ioh, ATI_REG_CMD, value);
	}
}

void
auixp_enable_dma(struct auixp_softc *sc, struct auixp_dma *dma)
{
	bus_space_tag_t      iot;
	bus_space_handle_t   ioh;
	u_int32_t value;

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
	/* lets not stress the DMA engine more than necesssary */
	value = bus_space_read_4(iot, ioh, ATI_REG_CMD);
	if (!(value & dma->dma_enable_bit)) {
		value |= dma->dma_enable_bit;
		bus_space_write_4(iot, ioh, ATI_REG_CMD, value);
	}
}

void
auixp_reset_aclink(struct auixp_softc *sc)
{
	bus_space_tag_t      iot;
	bus_space_handle_t   ioh;
	u_int32_t value, timeout;

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;

	/* if power is down, power it up */
	value = bus_space_read_4(iot, ioh, ATI_REG_CMD);
	if (value & ATI_REG_CMD_POWERDOWN) {
		printf("%s: powering up\n", sc->sc_dev.dv_xname);

		/* explicitly enable power */
		value &= ~ATI_REG_CMD_POWERDOWN;
		bus_space_write_4(iot, ioh, ATI_REG_CMD, value);

		/* have to wait at least 10 usec for it to initialise */
		DELAY(20);
	};

	printf("%s: soft resetting aclink\n", sc->sc_dev.dv_xname);

	/* perform a soft reset */
	value  = bus_space_read_4(iot, ioh, ATI_REG_CMD);
	value |= ATI_REG_CMD_AC_SOFT_RESET;
	bus_space_write_4(iot, ioh, ATI_REG_CMD, value);

	/* need to read the CMD reg and wait aprox. 10 usec to init */
	value  = bus_space_read_4(iot, ioh, ATI_REG_CMD);
	DELAY(20);

	/* clear soft reset flag again */
	value  = bus_space_read_4(iot, ioh, ATI_REG_CMD);
	value &= ~ATI_REG_CMD_AC_SOFT_RESET;
	bus_space_write_4(iot, ioh, ATI_REG_CMD, value);

	/* check if the ac-link is working; reset device otherwise */
	timeout = 10;
	value = bus_space_read_4(iot, ioh, ATI_REG_CMD);
	while (!(value & ATI_REG_CMD_ACLINK_ACTIVE)) {
		printf("%s: not up; resetting aclink hardware\n",
				sc->sc_dev.dv_xname);

		/* dip aclink reset but keep the acsync */
		value &= ~ATI_REG_CMD_AC_RESET;
		value |=  ATI_REG_CMD_AC_SYNC;
		bus_space_write_4(iot, ioh, ATI_REG_CMD, value);

		/* need to read CMD again and wait again (clocking in issue?) */
		value = bus_space_read_4(iot, ioh, ATI_REG_CMD);
		DELAY(20);

		/* assert aclink reset again */
		value = bus_space_read_4(iot, ioh, ATI_REG_CMD);
		value |=  ATI_REG_CMD_AC_RESET;
		bus_space_write_4(iot, ioh, ATI_REG_CMD, value);

		/* check if its active now */
		value = bus_space_read_4(iot, ioh, ATI_REG_CMD);

		timeout--;
		if (timeout == 0) break;
	};

	if (timeout == 0) {
		printf("%s: giving up aclink reset\n", sc->sc_dev.dv_xname);
	};
	if (timeout != 10) {
		printf("%s: aclink hardware reset successful\n",
			sc->sc_dev.dv_xname);
	};

	/* assert reset and sync for safety */
	value  = bus_space_read_4(iot, ioh, ATI_REG_CMD);
	value |= ATI_REG_CMD_AC_SYNC | ATI_REG_CMD_AC_RESET;
	bus_space_write_4(iot, ioh, ATI_REG_CMD, value);
}

/* chip hard init */
int
auixp_init(struct auixp_softc *sc)
{
	bus_space_tag_t      iot;
	bus_space_handle_t   ioh;
	u_int32_t value;

	iot = sc->sc_iot;
	ioh = sc->sc_ioh;
	/* disable all interrupts and clear all sources */
	auixp_disable_interrupts(sc);

	/* clear all DMA enables (preserving rest of settings) */
	value = bus_space_read_4(iot, ioh, ATI_REG_CMD);
	value &= ~( ATI_REG_CMD_IN_DMA_EN  |
		    ATI_REG_CMD_OUT_DMA_EN |
		    ATI_REG_CMD_SPDF_OUT_EN );
	bus_space_write_4(iot, ioh, ATI_REG_CMD, value);

	/* Reset AC-link */
	auixp_reset_aclink(sc);

	/*
	 * codecs get auto-detected later
	 *
	 * note: we are NOT enabling interrupts yet, no codecs have been
	 * detected yet nor is anything else set up
	 */

	return 0;
}
@


1.38
log
@Remove unused getdev() audio driver functions.
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.37 2016/09/14 06:12:19 ratchov Exp $ */
d53 1
a53 1
#include <sys/types.h>
a54 1
#include <sys/param.h>
@


1.37
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.35 2015/05/11 06:46:21 ratchov Exp $ */
a127 1
int	auixp_getdev(void *, struct audio_device *);
a178 1
	auixp_getdev,
a425 8
int
auixp_getdev(void *v, struct audio_device *adp)
{
	struct auixp_softc *sc = v;
	*adp = sc->sc_audev;
	return 0;
}

a1022 6

	strlcpy(sc->sc_audev.name, "ATI IXP AC97", sizeof sc->sc_audev.name);
	snprintf(sc->sc_audev.version, sizeof sc->sc_audev.version, "0x%02x",
	    PCI_REVISION(pa->pa_class));
	strlcpy(sc->sc_audev.config, sc->sc_dev.dv_xname,
	    sizeof sc->sc_audev.config);
@


1.36
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@a112 1
int	auixp_query_encoding(void *, struct audio_encoding *);
a134 2
paddr_t	auixp_mappage(void *, void *, off_t, int);
void	auixp_get_default_params(void *, int, struct audio_params *);
a169 2
	NULL,			/* drain */
	auixp_query_encoding,
a187 1
	auixp_mappage,
d190 1
a190 2
	auixp_trigger_input,
	auixp_get_default_params
a204 26
void
auixp_get_default_params(void *v, int mode, struct audio_params *params)
{
	ac97_get_default_params(params);
}

int
auixp_query_encoding(void *hdl, struct audio_encoding *aep)
{
	switch (aep->index) {
	case 0:
		strlcpy(aep->name, AudioEslinear_le, sizeof aep->name);
		aep->encoding = AUDIO_ENCODING_SLINEAR_LE;
		aep->precision = 16;
		aep->flags = 0;
		break;
	default:
		return (EINVAL);
	}
	aep->bps = AUDIO_BPS(aep->precision);
	aep->msb = 1;

	return (0);
}


a944 30
}


/* memory map dma memory */
paddr_t
auixp_mappage(void *hdl, void *mem, off_t off, int prot)
{
	struct auixp_codec *co;
	struct auixp_softc *sc;
	struct auixp_dma *p;

	co = (struct auixp_codec *) hdl;
	sc  = co->sc;
	/* for sanity */
	if (off < 0)
		return -1;

	/* look up allocated DMA area */
	SLIST_FOREACH(p, &sc->sc_dma_list, dma_chain) {
		if (KERNADDR(p) == mem)
			break;
	}

	/* have we found it ? */
	if (!p)
		return -1;

	/* return mmap'd region */
	return bus_dmamem_mmap(sc->sc_dmat, p->segs, p->nsegs,
	    off, prot, BUS_DMA_WAITOK);
@


1.35
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.34 2015/03/14 03:38:48 jsg Exp $ */
d142 1
a142 1
void	auixp_post_config(void *);
d1117 1
a1117 1
	mountroothook_establish(auixp_post_config, self);
d1122 1
a1122 1
auixp_post_config(void *self)
d1124 1
a1124 1
	struct auixp_softc *sc;
a1125 1
	sc = (struct auixp_softc *)self;
@


1.34
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.33 2014/07/12 18:48:51 tedu Exp $ */
a70 2
#include <dev/mulaw.h>
#include <dev/auconv.h>
a222 24
		strlcpy(aep->name, AudioEulinear, sizeof aep->name);
		aep->encoding = AUDIO_ENCODING_ULINEAR;
		aep->precision = 8;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 1:
		strlcpy(aep->name, AudioEmulaw, sizeof aep->name);
		aep->encoding = AUDIO_ENCODING_ULAW;
		aep->precision = 8;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 2:
		strlcpy(aep->name, AudioEalaw, sizeof aep->name);
		aep->encoding = AUDIO_ENCODING_ALAW;
		aep->precision = 8;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 3:
		strlcpy(aep->name, AudioEslinear, sizeof aep->name);
		aep->encoding = AUDIO_ENCODING_SLINEAR;
		aep->precision = 8;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 4:
a227 18
	case 5:
		strlcpy(aep->name, AudioEulinear_le, sizeof aep->name);
		aep->encoding = AUDIO_ENCODING_ULINEAR_LE;
		aep->precision = 16;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 6:
		strlcpy(aep->name, AudioEslinear_be, sizeof aep->name);
		aep->encoding = AUDIO_ENCODING_SLINEAR_BE;
		aep->precision = 16;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(aep->name, AudioEulinear_be, sizeof aep->name);
		aep->encoding = AUDIO_ENCODING_ULINEAR_BE;
		aep->precision = 16;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
d332 2
a333 6
		play->factor = 1;
		play->sw_code = NULL;
		if (play->channels > 2)
			play->channels = 2;
		if (play->precision > 16)
			play->precision = 16;
a334 14
		case AUDIO_ENCODING_ULAW:
			switch (play->channels) {
			case 1:
				play->factor = 4;
				play->sw_code = mulaw_to_slinear16_le_mts;
				break;
			case 2:
				play->factor = 2;
				play->sw_code = mulaw_to_slinear16_le;
				break;
			default:
				return (EINVAL);
			}
			break;
a335 143
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code = linear8_to_linear16_le_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = linear8_to_linear16_le;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = noswap_bytes_mts;
					break;
				case 2:
					break;
				default:
					return (EINVAL);
				}
				break;
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code = ulinear8_to_linear16_le_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = ulinear8_to_linear16_le;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = change_sign16_le_mts;
					break;
				case 2:
					play->sw_code = change_sign16_le;
					break;
				default:
					return (EINVAL);
				}
				break;
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_ALAW:
			switch (play->channels) {
			case 1:
				play->factor = 4;
				play->sw_code = alaw_to_slinear16_le_mts;
				break;
			case 2:
				play->factor = 2;
				play->sw_code = alaw_to_slinear16_le;
				break;
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_SLINEAR_BE:
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code = linear8_to_linear16_le_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = linear8_to_linear16_le;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = swap_bytes_mts;
					break;
				case 2:
					play->sw_code = swap_bytes;
					break;
				default:
					return (EINVAL);
				}
				break;
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_ULINEAR_BE:
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code = ulinear8_to_linear16_le_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = ulinear8_to_linear16_le;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = swap_bytes_change_sign16_le_mts;
					break;
				case 2:
					play->sw_code = swap_bytes_change_sign16_le;
					break;
				default:
					return (EINVAL);
				}
				break;
			default:
				return (EINVAL);
			}
d364 2
a365 6
		rec->factor = 1;
		rec->sw_code = 0;
		if (rec->channels > 2)
			rec->channels = 2;
		if (rec->precision > 16)
			rec->precision = 16;
a366 3
		case AUDIO_ENCODING_ULAW:
			rec->sw_code = ulinear8_to_mulaw;
			break;
a367 19
			if (rec->precision == 8)
				rec->sw_code = change_sign8;
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			if (rec->precision == 16)
				rec->sw_code = change_sign16_le;
			break;
		case AUDIO_ENCODING_ALAW:
			rec->sw_code = ulinear8_to_alaw;
			break;
		case AUDIO_ENCODING_SLINEAR_BE:
			if (rec->precision == 16)
				rec->sw_code = swap_bytes;
			else
				rec->sw_code = change_sign8;
			break;
		case AUDIO_ENCODING_ULINEAR_BE:
			if (rec->precision == 16)
				rec->sw_code = swap_bytes_change_sign16_le;
@


1.33
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.32 2013/12/06 21:03:03 deraadt Exp $ */
a65 1
#include <machine/intr.h>
@


1.32
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.31 2013/05/24 07:58:46 ratchov Exp $ */
d654 1
a654 1
		free(dma, pool);
d687 1
a687 1
			free(dma, pool);
d827 1
a827 1
		free(dma, M_DEVBUF);
@


1.31
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.30 2013/05/15 08:29:24 ratchov Exp $ */
a1255 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
d1264 2
a1265 1
	case DVACT_DEACTIVATE:
@


1.30
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.29 2011/07/03 15:47:16 matthew Exp $ */
d1320 2
a1321 2
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO, auixp_intr, sc,
	    sc->sc_dev.dv_xname);
@


1.29
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.28 2010/09/21 02:09:15 jakemsr Exp $ */
d960 1
d965 1
d980 1
d988 1
a988 1

d1038 1
d1043 1
d1058 1
d1067 1
d1089 1
d1097 2
a1098 1
	if (status == 0)
d1100 1
d1140 1
a1140 1

@


1.28
log
@* add autoconf(9) activate function.  basically the same as other ac97(4)
  devices.
* only one codec will ever be supported, and there's no reason to restrict
  the supported codec to being in the first codec slot.
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.27 2010/08/27 16:26:35 deraadt Exp $ */
a1245 2
	case DVACT_ACTIVATE:
		break;
@


1.27
log
@Delete #if'd out powerhook code which is just unfinished scaffolding
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.26 2010/08/27 05:04:12 deraadt Exp $ */
d107 2
d110 2
a111 1
	sizeof(struct auixp_softc), auixp_match, auixp_attach
d1239 26
a1350 2
	struct auixp_codec *codec;
	int codec_nr;
d1356 9
d1367 4
a1370 4
	sc->has_4ch   = AC97_IS_4CH(codec->codec_if);
	sc->has_6ch   = AC97_IS_6CH(codec->codec_if);
	sc->is_fixed  = AC97_IS_FIXED_RATE(codec->codec_if);
	sc->has_spdif = AC97_HAS_SPDIF(codec->codec_if);
a1372 7
	/* attach audio devices for all detected codecs */
	for (codec_nr = 0; codec_nr < ATI_IXP_CODECS; codec_nr++) {
		codec = &sc->sc_codec[codec_nr];
		if (codec->present)
			audio_attach_mi(&auixp_hw_if, codec, &sc->sc_dev);
	}

a1476 1
	ixp_codec->present  = 1;
d1606 1
a1606 1
	int timeout, codec_nr;
a1613 1
	sc->sc_num_codecs = 0;
d1637 19
a1655 23
	for (codec_nr = 0; codec_nr < ATI_IXP_CODECS; codec_nr++) {
		codec = &sc->sc_codec[codec_nr];
		bzero(codec, sizeof(struct auixp_codec));

		codec->sc       = sc;
		codec->codec_nr = codec_nr;
		codec->present  = 0;

		codec->host_if.arg    = codec;
		codec->host_if.attach = auixp_attach_codec;
		codec->host_if.read   = auixp_read_codec;
		codec->host_if.write  = auixp_write_codec;
		codec->host_if.reset  = auixp_reset_codec;
		codec->host_if.flags  = auixp_flags_codec;
		switch (subdev) {
		case 0x1311462: /* MSI S270 */
		case 0x1611462: /* LG K1 Express */
		case 0x3511462: /* MSI L725 */
		case 0x4711462: /* MSI L720 */
		case 0x0611462: /* MSI S250 */
			codec->codec_flags = AC97_HOST_ALC650_PIN47_IS_EAPD;
			break;
		}
d1661 5
a1665 2
		if (ac97_attach(&sc->sc_codec[0].host_if) == 0)
			sc->sc_num_codecs++;
a1667 1
#ifdef notyet
d1671 5
a1675 2
		if (ac97_attach(&sc->sc_codec[1].host_if, &sc->sc_dev) == 0)
			sc->sc_num_codecs++;
d1681 5
a1685 9
		if (ac97_attach(&sc->sc_codec[2].host_if, &sc->sc_dev) == 0)
			sc->sc_num_codecs++;
	}
#endif

	if (sc->sc_num_codecs == 0) {
		printf("%s: no codecs detected or initialised\n",
		    sc->sc_dev.dv_xname);
		return;
@


1.26
log
@More killing of PWR_STANDBY.  cvs skipped these files
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.25 2010/07/15 03:43:11 jakemsr Exp $ */
a138 9

/* power management (do we support that already?) */
#if 0
void	auixp_powerhook(int, void *);
int	auixp_suspend(struct auixp_softc *);
int	auixp_resume(struct auixp_softc *);
#endif


a1244 1
	int len;
a1309 21
	/* XXX set up power hooks; not implemented yet XXX */

	len = 1;	/* shut up gcc */
#ifdef notyet
	/* create suspend save area */
	len = sizeof(u_int16_t) * (ESA_REV_B_CODE_MEMORY_LENGTH
	    + ESA_REV_B_DATA_MEMORY_LENGTH + 1);
	sc->savemem = (u_int16_t *)malloc(len, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sc->savemem == NULL) {
		printf("%s: unable to allocate suspend buffer\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	sc->powerhook = powerhook_establish(auixp_powerhook, sc);
	if (sc->powerhook == NULL)
		printf("%s: WARNING: unable to establish powerhook\n",
		    sc->sc_dev.dv_xname);

#endif

a1427 4

	if (sc->savemem)
		free(sc->savemem, M_DEVBUF);

a1811 36

#if 0
void
auixp_powerhook(int why, void *hdl)
{
	struct auixp_softc *sc;

	sc = (struct auixp_softc *)hdl;
	switch (why) {
	case PWR_SUSPEND:
		auixp_suspend(sc);
		break;
	case PWR_RESUME:
		auixp_resume(sc);
/* XXX fix me XXX */
		(sc->codec_if->vtbl->restore_ports)(sc->codec_if);
		break;
	}
}

int
auixp_suspend(struct auixp_softc *sc)
{

	/* XXX no power functions yet XXX */
	return 0;
}

int
auixp_resume(struct auixp_softc *sc)
{

	/* XXX no power functions yet XXX */
	return 0;
}
#endif /* 0 */
@


1.25
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.24 2009/10/12 19:43:52 jakemsr Exp $ */
a1856 1
	case PWR_STANDBY:
@


1.24
log
@auixp(4) also supports SB600.  from Brad.
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.23 2009/03/29 21:53:52 sthen Exp $ */
d236 1
a236 1
		return (0);
d242 1
a242 1
		return (0);
d248 1
a248 1
		return (0);
d254 1
a254 1
		return (0);
d260 1
a260 1
		return (0);
d266 1
a266 1
		return (0);
d272 1
a272 1
		return (0);
d278 1
a278 1
		return (0);
d282 4
d552 2
d610 2
@


1.23
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.22 2008/10/25 22:30:43 jakemsr Exp $ */
d95 2
a96 1
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_SB400_AUDIO }
@


1.22
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.21 2008/09/24 19:09:05 chl Exp $ */
d1255 1
a1255 1
		printf(": can't map memory space\n");
@


1.21
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok ratchov@@
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.20 2008/09/17 06:14:09 brad Exp $ */
d380 4
d568 1
a568 1
	if (setmode & AUMODE_RECORD) {
d571 4
@


1.20
log
@Update for renamed ATI PCI ids.
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.19 2008/05/25 23:59:33 jakemsr Exp $ */
a372 1
	struct auixp_softc *sc;
a376 1
	sc = co->sc;
@


1.19
log
@
use ac97 default parameters for auich(4), auixp(4) and auvia(4).
they may have codecs which only handle 48kHz sampling rates.

ok ratchov@@
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.18 2008/04/21 00:32:42 jakemsr Exp $ */
d93 3
a95 3
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_IXP_AUDIO_200 },
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_IXP_AUDIO_300 },
	{ PCI_VENDOR_ATI, PCI_PRODUCT_ATI_IXP_AUDIO_400 },
@


1.18
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.17 2008/02/13 23:35:08 jakemsr Exp $ */
d136 1
d205 1
a205 1
	NULL
d218 6
@


1.17
log
@Since SPDIF support for the auixp driver is still half done
disable it for now since some chipset revisions will freak out
on the aparent half-initialisation.

Also delay the setting of the DMA bits until after the codec
detection but before the enabling of interrupts. Note that the
DMA has to be explicitly started when the device is opened.

From reinoud NetBSD via brad@@

tested by ian@@ and matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.16 2008/02/13 23:30:51 jakemsr Exp $ */
d203 2
a204 1
	auixp_trigger_input
@


1.16
log
@as with the recent auich(4) commit, set the sample rate of the
front dac last.

problem found and analyzed by ian@@, thanks

ok ian@@
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.15 2008/02/12 13:02:21 jakemsr Exp $ */
a1258 15
	/* fill in the missing details about the dma channels. */

	/* for output */
	sc->sc_output_dma->linkptr        = ATI_REG_OUT_DMA_LINKPTR;
	sc->sc_output_dma->dma_enable_bit = ATI_REG_CMD_OUT_DMA_EN |
					    ATI_REG_CMD_SEND_EN;
	/* have spdif? then this too! XXX not seeing LED yet! XXX */
	if (sc->has_spdif)
		sc->sc_output_dma->dma_enable_bit |= ATI_REG_CMD_SPDF_OUT_EN;

	/* and for input */
	sc->sc_input_dma->linkptr         = ATI_REG_IN_DMA_LINKPTR;
	sc->sc_input_dma->dma_enable_bit  = ATI_REG_CMD_IN_DMA_EN  |
					    ATI_REG_CMD_RECEIVE_EN;

d1351 17
@


1.15
log
@
pin 47 on ALC65{0,5,8} ac97 codecs can be used for either eapd or
spdif-in.  usually the deault of spdif-in is used, but some
ATI devices use pin 47 for eapd.

add a list of subsystem ids (from ALSA) for these devices, and set
bit 1 of register 7a to select the correct function of pin 47 for
these devices.

there was code here to do this prior to the ac97 update, but it
was accidentally removed.  rename the flag and bit to more accurately
reflect what this does and hopefully avoid future confusion.

problem noticed and fix tested/ok'd by matthieu@@, thanks

also some discussion with and pointers from brad@@, thanks
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.14 2008/01/15 02:52:50 jakemsr Exp $ */
d540 1
a540 1
		    AC97_REG_PCM_FRONT_DAC_RATE, &play->sample_rate);
d552 1
a552 1
		    AC97_REG_PCM_LFE_DAC_RATE, &play->sample_rate);
@


1.14
log
@bring in lots of ac97(4) and auvia(4) updates from NetBSD

user visible changes:
- when setting up ac97(4) mixer items, for some features like surround
  sound, check if the feature if supported by the codec and only add
  items for that feature if it is
- auvia(4) now supports multichannel playback with at least some
  multichannel ac97(4) codecs

fixes problems for me and ajacoutot with different auvia(4)
devices/codecs.  no regressions reported by testers.

if you have an ac97(4) audio device and are using mixerctl.conf(5),
you may want/need to update it.

ok ratchov
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.13 2007/11/05 00:17:28 jakemsr Exp $ */
d543 1
d549 1
a552 1

d1636 5
a1640 1
			codec->codec_flags = AC97_HOST_DONT_ENABLE_SPDIF;
@


1.13
log
@audio encoding conversion cleanup

- the endianness of the conversions don't depend on the endianness
  of machine the conversions are built on, but the endianness of the
  audio data itself.  choose encoding conversions explicitly, instead
  of relying on #defines based on the endianness of the machine.
- replace home-grown conversions with comparable conversions in
  auconv.c and mulaw.c
- use the proper conversion for ulinear_be:16 -> slinear_le:16 in
  auixp(4)

thanks ajacoutot@@ and sthen@@ for !x86 testing
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.12 2007/10/22 03:16:35 fgsch Exp $ */
d367 1
d538 3
a540 1
		error = ac97_set_rate(co->codec_if, play, AUMODE_PLAY);
d543 12
d589 2
a590 1
		error = ac97_set_rate(co->codec_if, rec, AUMODE_RECORD);
@


1.12
log
@Use pci_set_powerstate(), shrinking the code and unifying the different
versions. ok by many.
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.11 2007/09/17 00:50:46 krw Exp $ */
d378 1
a378 1
				play->sw_code = mulaw_to_slinear16_mts;
d382 1
a382 1
				play->sw_code = mulaw_to_slinear16;
d394 1
a394 1
					play->sw_code = linear8_to_linear16_mts;
d398 1
a398 1
					play->sw_code = linear8_to_linear16;
d426 1
a426 1
					play->sw_code = ulinear8_to_linear16_mts;
d430 1
a430 1
					play->sw_code = ulinear8_to_linear16;
d440 1
a440 1
					play->sw_code = change_sign16_mts;
d443 1
a443 1
					play->sw_code = change_sign16;
d457 1
a457 1
				play->sw_code = alaw_to_slinear16_mts;
d461 1
a461 1
				play->sw_code = alaw_to_slinear16;
d473 1
a473 1
					play->sw_code = linear8_to_linear16_mts;
d477 1
a477 1
					play->sw_code = linear8_to_linear16;
d506 1
a506 1
					play->sw_code = ulinear8_to_linear16_mts;
d510 1
a510 1
					play->sw_code = ulinear8_to_linear16;
d520 1
a520 1
					play->sw_code = change_sign16_swap_bytes_mts;
d523 1
a523 1
					play->sw_code = change_sign16_swap_bytes;
d555 1
a555 1
				rec->sw_code = change_sign16;
d568 1
a568 1
				rec->sw_code = swap_bytes_change_sign16;
@


1.11
log
@Some bzero() -> M_ZERO. ok jakemsr@@
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.10 2007/05/26 00:36:03 krw Exp $ */
a138 1
int	auixp_power(struct auixp_softc *, int);
d1286 1
a1286 1
	auixp_power(sc, PCI_PMCSR_STATE_D0);
a1797 22

	return 0;
}

/*
 * TODO power saving and suspend / resume support
 */
int
auixp_power(struct auixp_softc *sc, int state)
{
	pcitag_t tag;
	pci_chipset_tag_t pc;
	pcireg_t data;
	int pmcapreg;

	tag = sc->sc_tag;
	pc = sc->sc_pct;
	if (pci_get_capability(pc, tag, PCI_CAP_PWRMGMT, &pmcapreg, 0)) {
		data = pci_conf_read(pc, tag, pmcapreg + PCI_PMCSR);
		if ((data & PCI_PMCSR_STATE_MASK) != state)
			pci_conf_write(pc, tag, pmcapreg + PCI_PMCSR, state);
	}
@


1.10
log
@More comment typos from Diego Casati. Including winners like funtion, allmost,
oustside, seqencer, toghether, nessissary, etc.
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.9 2007/05/25 21:27:15 krw Exp $ */
d784 1
a784 1
	dma = malloc(sizeof(*dma), M_DEVBUF, M_NOWAIT);
a786 1
	bzero(dma, sizeof(*dma));
@


1.9
log
@"interupt" -> "interrupt" in various comments. Mostly from Diego Casati.
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.8 2007/04/10 17:47:55 miod Exp $ */
d349 1
a349 1
		/* XXX this prolly is not nessisary unless splitted XXX */
d819 1
a819 1
	/* XXX allways at start? XXX */
d883 1
a883 1
/* XXX allmost literaly a copy of trigger-input; could be factorised XXX */
d958 1
a958 1
/* XXX allmost literaly a copy of trigger-output; could be factorised XXX */
d1037 2
a1038 2
 * documentated but i saw it implemented in other drivers. Prolly returning a
 * value > 0 means "i've dealt with it"
d1665 1
a1665 1
	/* lets not stress the DMA engine more than nessisary */
d1682 1
a1682 1
	/* lets not stress the DMA engine more than nessisary */
@


1.8
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.7 2007/02/14 01:12:16 jsg Exp $ */
d1090 1
a1090 1
		/* disable detected interupt sources */
@


1.7
log
@FALLTHRU -> FALLTHROUGH for consistency.
Suggested by miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.6 2006/04/27 21:40:01 matthieu Exp $ */
d808 1
a808 1
/* program dma chain in it's link address descriptor */
d938 1
a938 1
/* halt output of audio, just disable it's dma and update bus state */
d1013 1
a1013 1
/* halt sampling audio, just disable it's dma and update bus state */
@


1.6
log
@Quirk for MSI Megabook S270 audio output. Ok deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.5 2006/04/13 15:48:45 brad Exp $ */
d315 1
a315 1
		/* FALLTHRU */
d319 1
a319 1
		/* FALLTHRU */
@


1.5
log
@Coverity ID 2311: in auixp_allocate_dma_chain() free dma variable if
we are unable to allocate hardware dma descriptors.

From NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.4 2006/01/25 23:53:35 brad Exp $ */
d1571 1
d1577 2
d1619 5
@


1.4
log
@Duh! If askes to halt the input dont halt the output instead.  This also
fixes the timeout on draining when closing.

From reinoud NetBSD

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.3 2005/11/26 14:31:26 krw Exp $ */
d795 1
@


1.3
log
@Add some missing 'break;'s in auich and auixp that lint spotted. While
here, use FALLTHRU or FALLTHROUGH to make lint even happier.

ok marco@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.2 2005/11/21 18:16:40 millert Exp $ */
d1022 1
a1022 1
	dma = sc->sc_output_dma;
@


1.2
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/* $OpenBSD: auixp.c,v 1.1 2005/08/07 20:08:45 mickey Exp $ */
d315 1
a315 1
		/* fallthru */
d319 1
a319 1
		/* fallthru */
d459 1
d463 1
@


1.1
log
@ati ixp audio; ported form ntbsd in <4h of boretime; testing by krw@@ and ian@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d61 1
a61 1
#include <sys/select.h>
@

