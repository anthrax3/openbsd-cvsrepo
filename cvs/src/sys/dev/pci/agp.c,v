head	1.49;
access;
symbols
	OPENBSD_6_1:1.49.0.8
	OPENBSD_6_1_BASE:1.49
	OPENBSD_6_0:1.49.0.6
	OPENBSD_6_0_BASE:1.49
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.45.0.8
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.45.0.6
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.37.0.2
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.36.0.2
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.34.0.8
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.6
	OPENBSD_5_0:1.34.0.4
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.33.0.4
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.27.0.2
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.1.0.2
	OPENBSD_4_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.49
date	2015.12.22.21.05.37;	author kettenis;	state Exp;
branches;
next	1.48;
commitid	5vdg5NlTzbaOMag4;

1.48
date	2015.12.19.16.07.20;	author kettenis;	state Exp;
branches;
next	1.47;
commitid	NDhUxvYB3Eg6RqfI;

1.47
date	2015.12.19.14.59.25;	author kettenis;	state Exp;
branches;
next	1.46;
commitid	hf2vaC9ougVCMkma;

1.46
date	2015.09.09.19.47.11;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	oiL5hLU4dw0Ni62e;

1.45
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	JtO5uXxVcnZfhUkR;

1.44
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.43;
commitid	OBNa5kfxQ2UXoiIw;

1.43
date	2014.03.26.14.41.41;	author mpi;	state Exp;
branches;
next	1.42;

1.42
date	2014.03.17.22.01.56;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2014.03.17.04.10.59;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2014.03.16.13.57.28;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2014.03.14.23.42.41;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2013.08.06.09.45.32;	author jsg;	state Exp;
branches;
next	1.37;

1.37
date	2013.07.06.23.35.44;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2012.12.06.15.05.21;	author mpi;	state Exp;
branches;
next	1.35;

1.35
date	2012.11.13.13.37.24;	author mpi;	state Exp;
branches;
next	1.34;

1.34
date	2010.12.26.15.41.00;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2009.12.15.20.26.21;	author jasper;	state Exp;
branches;
next	1.32;

1.32
date	2009.05.10.16.57.44;	author oga;	state Exp;
branches;
next	1.31;

1.31
date	2009.05.10.15.28.45;	author oga;	state Exp;
branches;
next	1.30;

1.30
date	2009.05.10.14.44.42;	author oga;	state Exp;
branches;
next	1.29;

1.29
date	2009.04.20.01.28.45;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2009.04.15.03.09.47;	author oga;	state Exp;
branches;
next	1.27;

1.27
date	2008.11.09.15.11.19;	author oga;	state Exp;
branches;
next	1.26;

1.26
date	2008.09.26.21.15.53;	author mikeb;	state Exp;
branches;
next	1.25;

1.25
date	2008.08.17.21.31.38;	author oga;	state Exp;
branches;
next	1.24;

1.24
date	2008.07.12.17.31.06;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2008.07.07.07.54.48;	author bernd;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.25.18.54.06;	author oga;	state Exp;
branches;
next	1.21;

1.21
date	2008.05.06.19.19.02;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2008.04.09.18.59.58;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2008.03.23.19.54.47;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2008.03.23.08.36.41;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.16.19.00.28;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2008.01.04.00.23.26;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.02.03.40.38;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2007.12.07.17.35.22;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2007.12.07.14.48.50;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2007.12.06.22.49.39;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.28.16.25.58;	author chl;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.26.15.35.15;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.26.10.35.42;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.25.17.11.12;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2007.08.04.19.40.25;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.30.21.12.14;	author dim;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.03.14.05.00;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.02.22.22.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.30.19.15.30;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.16.21.32.34;	author matthieu;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2007.01.03.21.09.41;	author miod;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Remove obsolete comment.
@
text
@/* $OpenBSD: agp.c,v 1.48 2015/12/19 16:07:20 kettenis Exp $ */
/*-
 * Copyright (c) 2000 Doug Rabson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$FreeBSD: src/sys/pci/agp.c,v 1.12 2001/05/19 01:28:07 alfred Exp $
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/ic/mc6845reg.h>
#include <dev/ic/pcdisplayvar.h>
#include <dev/ic/vgareg.h>
#include <dev/ic/vgavar.h>

#include <dev/pci/agpvar.h>
#include <dev/pci/agpreg.h>

void	agp_attach(struct device *, struct device *, void *);
int	agp_probe(struct device *, void *, void *);

int	agpvga_match(struct pci_attach_args *);

int
agpdev_print(void *aux, const char *pnp)
{
	if (pnp) {
		printf("agp at %s", pnp);
	}
	return (UNCONF);
}

int
agpbus_probe(struct agp_attach_args *aa)
{
	struct pci_attach_args	*pa = aa->aa_pa;

	if (strncmp(aa->aa_busname, "agp", 3) == 0 &&
	    PCI_CLASS(pa->pa_class) == PCI_CLASS_BRIDGE && 
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_BRIDGE_HOST)
		return (1);
	return (0);
}

/*
 * Find the video card hanging off the agp bus XXX assumes only one bus
 */
int
agpvga_match(struct pci_attach_args *pa)
{
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_DISPLAY &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_DISPLAY_VGA) {
		if (pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_AGP,
		    NULL, NULL))
			return (1);
	}
	return (0);
}

struct device *
agp_attach_bus(struct pci_attach_args *pa, const struct agp_methods *methods,
    bus_addr_t apaddr, bus_size_t apsize, struct device *dev)
{
	struct agpbus_attach_args arg;

	arg.aa_methods = methods;
	arg.aa_pa = pa;
	arg.aa_apaddr = apaddr;
	arg.aa_apsize = apsize;

	printf("\n"); /* newline from the driver that called us */
	return (config_found(dev, &arg, agpdev_print));
}

int
agp_probe(struct device *parent, void *match, void *aux)
{
	/*
	 * we don't do any checking here, driver we're attaching this
	 * interface to should have already done it.
	 */
	return (1);
}

void
agp_attach(struct device *parent, struct device *self, void *aux)
{
	struct agpbus_attach_args *aa = aux;
	struct pci_attach_args *pa = aa->aa_pa;
	struct agp_softc *sc = (struct agp_softc *)self;
	u_int memsize;
	int i;

	sc->sc_chipc = parent;
	sc->sc_methods = aa->aa_methods;
	sc->sc_apaddr = aa->aa_apaddr;
	sc->sc_apsize = aa->aa_apsize;

	static const int agp_max[][2] = {
		{0,		0},
		{32,		4},
		{64,		28},
		{128,		96},
		{256,		204},
		{512,		440},
		{1024,		942},
		{2048,		1920},
		{4096,		3932}
	};

	/*
	 * Work out an upper bound for agp memory allocation. This
	 * uses a heuristic table from the Linux driver.
	 */
	memsize = ptoa(physmem) >> 20;

	for (i = 0; i < nitems(agp_max) && memsize > agp_max[i][0]; i++)
		;
	if (i == nitems(agp_max))
		i = nitems(agp_max) - 1;
	sc->sc_maxmem = agp_max[i][1] << 20;

	sc->sc_pcitag = pa->pa_tag;
	sc->sc_pc = pa->pa_pc;
	sc->sc_id = pa->pa_id;
	sc->sc_dmat = pa->pa_dmat;
	sc->sc_memt = pa->pa_memt;

	pci_get_capability(sc->sc_pc, sc->sc_pcitag, PCI_CAP_AGP,
	    &sc->sc_capoff, NULL);

	printf(": aperture at 0x%lx, size 0x%lx\n", (u_long)sc->sc_apaddr,
	    (u_long)sc->sc_apsize);
}

struct cfattach agp_ca = {
	sizeof(struct agp_softc), agp_probe, agp_attach,
	NULL, NULL
};

struct cfdriver agp_cd = {
	NULL, "agp", DV_DULL
};

struct agp_gatt *
agp_alloc_gatt(bus_dma_tag_t dmat, u_int32_t apsize)
{
	struct agp_gatt		*gatt;
	u_int32_t	 	 entries = apsize >> AGP_PAGE_SHIFT;

	gatt = malloc(sizeof(*gatt), M_AGP, M_NOWAIT | M_ZERO);
	if (!gatt)
		return (NULL);
	gatt->ag_entries = entries;
	gatt->ag_size = entries * sizeof(u_int32_t);

	if (agp_alloc_dmamem(dmat, gatt->ag_size, &gatt->ag_dmamap,
	    &gatt->ag_physical, &gatt->ag_dmaseg) != 0) {
		free(gatt, M_AGP, sizeof *gatt);
		return (NULL);
	}

	if (bus_dmamem_map(dmat, &gatt->ag_dmaseg, 1, gatt->ag_size,
	    (caddr_t *)&gatt->ag_virtual, BUS_DMA_NOWAIT) != 0) {
		agp_free_dmamem(dmat, gatt->ag_size, gatt->ag_dmamap,
		    &gatt->ag_dmaseg);
		free(gatt, M_AGP, sizeof *gatt);
		return (NULL);
	}

	agp_flush_cache();

	return (gatt);
}

void
agp_free_gatt(bus_dma_tag_t dmat, struct agp_gatt *gatt)
{
	bus_dmamem_unmap(dmat, (caddr_t)gatt->ag_virtual, gatt->ag_size);
	agp_free_dmamem(dmat, gatt->ag_size, gatt->ag_dmamap, &gatt->ag_dmaseg);
	free(gatt, M_AGP, sizeof *gatt);
}

int
agp_generic_enable(struct agp_softc *sc, u_int32_t mode)
{
	struct pci_attach_args	pa;
	pcireg_t		tstatus, mstatus, command;
	int			rq, sba, fw, rate, capoff;
	
	if (pci_find_device(&pa, agpvga_match) == 0 ||
	    pci_get_capability(pa.pa_pc, pa.pa_tag, PCI_CAP_AGP,
	    &capoff, NULL) == 0) {
		printf("agp_generic_enable: not an AGP capable device\n");
		return (-1);
	}

	tstatus = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
	    sc->sc_capoff + AGP_STATUS);
	/* display agp mode */
	mstatus = pci_conf_read(pa.pa_pc, pa.pa_tag,
	    capoff + AGP_STATUS);

	/* Set RQ to the min of mode, tstatus and mstatus */
	rq = AGP_MODE_GET_RQ(mode);
	if (AGP_MODE_GET_RQ(tstatus) < rq)
		rq = AGP_MODE_GET_RQ(tstatus);
	if (AGP_MODE_GET_RQ(mstatus) < rq)
		rq = AGP_MODE_GET_RQ(mstatus);

	/* Set SBA if all three can deal with SBA */
	sba = (AGP_MODE_GET_SBA(tstatus)
	    & AGP_MODE_GET_SBA(mstatus)
	    & AGP_MODE_GET_SBA(mode));

	/* Similar for FW */
	fw = (AGP_MODE_GET_FW(tstatus)
	    & AGP_MODE_GET_FW(mstatus)
	    & AGP_MODE_GET_FW(mode));

	/* Figure out the max rate */
	rate = (AGP_MODE_GET_RATE(tstatus)
	    & AGP_MODE_GET_RATE(mstatus)
	    & AGP_MODE_GET_RATE(mode));
	if (rate & AGP_MODE_RATE_4x)
		rate = AGP_MODE_RATE_4x;
	else if (rate & AGP_MODE_RATE_2x)
		rate = AGP_MODE_RATE_2x;
	else
		rate = AGP_MODE_RATE_1x;

	/* Construct the new mode word and tell the hardware  */
	command = AGP_MODE_SET_RQ(0, rq);
	command = AGP_MODE_SET_SBA(command, sba);
	command = AGP_MODE_SET_FW(command, fw);
	command = AGP_MODE_SET_RATE(command, rate);
	command = AGP_MODE_SET_AGP(command, 1);

	pci_conf_write(sc->sc_pc, sc->sc_pcitag,
	    sc->sc_capoff + AGP_COMMAND, command);
	pci_conf_write(pa.pa_pc, pa.pa_tag, capoff + AGP_COMMAND, command);
	return (0);
}

/*
 * Allocates a single-segment block of zeroed, wired dma memory.
 */
int
agp_alloc_dmamem(bus_dma_tag_t tag, size_t size, bus_dmamap_t *mapp,
    bus_addr_t *baddr, bus_dma_segment_t *seg)
{
	int error, level = 0, nseg;

	if ((error = bus_dmamem_alloc(tag, size, PAGE_SIZE, 0,
	    seg, 1, &nseg, BUS_DMA_NOWAIT | BUS_DMA_ZERO)) != 0)
		goto out;
	level++;

	if ((error = bus_dmamap_create(tag, size, nseg, size, 0,
	    BUS_DMA_NOWAIT, mapp)) != 0)
		goto out;
	level++;

	if ((error = bus_dmamap_load_raw(tag, *mapp, seg, nseg, size,
	    BUS_DMA_NOWAIT)) != 0)
		goto out;

	*baddr = (*mapp)->dm_segs[0].ds_addr;

	return (0);
out:
	switch (level) {
	case 2:
		bus_dmamap_destroy(tag, *mapp);
		/* FALLTHROUGH */
	case 1:
		bus_dmamem_free(tag, seg, nseg);
		break;
	default:
		break;
	}

	return (error);
}

void
agp_free_dmamem(bus_dma_tag_t tag, size_t size, bus_dmamap_t map,
    bus_dma_segment_t *seg)
{
	bus_dmamap_unload(tag, map);
	bus_dmamap_destroy(tag, map);
	bus_dmamem_free(tag, seg, 1);
}

/* Implementation of the kernel api */

void *
agp_find_device(int unit)
{
	if (unit >= agp_cd.cd_ndevs || unit < 0)
		return (NULL);
	return (agp_cd.cd_devs[unit]);
}

enum agp_acquire_state
agp_state(void *dev)
{
	struct agp_softc *sc = (struct agp_softc *) dev;
        return (sc->sc_state);
}

void
agp_get_info(void *dev, struct agp_info *info)
{
	struct agp_softc *sc = (struct agp_softc *)dev;

	if (sc->sc_capoff != 0)
		info->ai_mode = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
		    AGP_STATUS + sc->sc_capoff);
	else
		info->ai_mode = 0; /* i810 doesn't have real AGP */
	info->ai_aperture_base = sc->sc_apaddr;
	info->ai_aperture_size = sc->sc_apsize;
	info->ai_memory_allowed = sc->sc_maxmem;
	info->ai_memory_used = sc->sc_allocated;
	info->ai_devid = sc->sc_id;
}

int
agp_acquire(void *dev)
{
	struct agp_softc *sc = (struct agp_softc *)dev;

	if (sc->sc_chipc == NULL) 
		return (EINVAL);

	if (sc->sc_state != AGP_ACQUIRE_FREE)
		return (EBUSY);
	sc->sc_state = AGP_ACQUIRE_KERNEL;

	return (0);
}

int
agp_release(void *dev)
{
	struct agp_softc *sc = (struct agp_softc *)dev;

	if (sc->sc_state == AGP_ACQUIRE_FREE)
		return (0);

	if (sc->sc_state != AGP_ACQUIRE_KERNEL) 
		return (EBUSY);

	sc->sc_state = AGP_ACQUIRE_FREE;
	return (0);
}

int
agp_enable(void *dev, u_int32_t mode)
{
	struct agp_softc	*sc = dev;
	int			 ret;

	if (sc->sc_methods->enable != NULL) {
		ret = sc->sc_methods->enable(sc->sc_chipc, mode);
	} else {
		ret = agp_generic_enable(sc, mode);
	}
	return (ret);
}

paddr_t
agp_mmap(struct agp_softc *sc, off_t off, int prot)
{
	if (sc->sc_chipc == NULL)
		return (-1);

	if (off >= sc->sc_apsize)
		return (-1);

	if (sc->sc_apaddr == 0)
		return (-1);

	return bus_space_mmap(sc->sc_memt, sc->sc_apaddr, off, prot, 0);
}
@


1.48
log
@Remove code that has been unused ever since we removed the agp ioctl interface.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.47 2015/12/19 14:59:25 kettenis Exp $ */
a46 7
/*
 * the enable and {alloc, free, bind, unbind} memory routines have default
 * fallbacks, these macros do the right thing. The callbacks with no fallback
 * are called directly. These are mostly hacks around the weirdness of intel
 * integrated graphics, since they are not technically a true agp chipset,
 * but provide an almost identical interface.
 */
@


1.47
log
@Move agp_generic_enable() prototype to agpvar.h to unbreak the build on
macppc.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.46 2015/09/09 19:47:11 deraadt Exp $ */
a32 1
#include <sys/rwlock.h>
a53 3
struct agp_memory *
	agp_generic_alloc_memory(struct agp_softc *, int, vsize_t size);
int	agp_generic_free_memory(struct agp_softc *, struct agp_memory *);
a56 3
struct agp_memory *agp_find_memory(struct agp_softc *, int);
struct agp_memory *agp_lookup_memory(struct agp_softc *, off_t);

a57 2
int	agp_acquire_helper(void *dev, enum agp_acquire_state state);
int	agp_release_helper(void *dev, enum agp_acquire_state state);
a157 8
	/*
	 * The lock is used to prevent re-entry to
	 * agp_generic_bind_memory() since that function can sleep.
	 */
	rw_init(&sc->sc_lock, "agplk");

	TAILQ_INIT(&sc->sc_memory);

a179 31
struct agp_memory *
agp_find_memory(struct agp_softc *sc, int id)
{
	struct agp_memory *mem;

	AGP_DPF("searching for memory block %d\n", id);
	TAILQ_FOREACH(mem, &sc->sc_memory, am_link) {
		AGP_DPF("considering memory block %d\n", mem->am_id);
		if (mem->am_id == id)
			return (mem);
	}
	return (NULL);
}


struct agp_memory *
agp_lookup_memory(struct agp_softc *sc, off_t off)
{
	struct agp_memory* mem;

	AGP_DPF("searching for memory offset 0x%lx\n", (unsigned long)off);
	TAILQ_FOREACH(mem, &sc->sc_memory, am_link) {
		if (mem->am_is_bound == 0)
			continue;
		if (off >= mem->am_offset &&
		    off < (mem->am_offset + mem->am_size))
			return (mem);
	}
	return (NULL);
}

a279 172
struct agp_memory *
agp_generic_alloc_memory(struct agp_softc *sc, int type, vsize_t size)
{
	struct agp_memory *mem;

	if (type != 0) {
		printf("agp_generic_alloc_memory: unsupported type %d\n", type);
		return (0);
	}

	mem = malloc(sizeof *mem, M_AGP, M_WAITOK | M_ZERO);

	if (bus_dmamap_create(sc->sc_dmat, size, size / PAGE_SIZE + 1,
	    size, 0, BUS_DMA_NOWAIT, &mem->am_dmamap) != 0) {
		free(mem, M_AGP, sizeof *mem);
		return (NULL);
	}

	mem->am_id = sc->sc_nextid++;
	mem->am_size = size;
	TAILQ_INSERT_TAIL(&sc->sc_memory, mem, am_link);
	sc->sc_allocated += size;

	return (mem);
}

int
agp_generic_free_memory(struct agp_softc *sc, struct agp_memory *mem)
{
	if (mem->am_is_bound)
		return (EBUSY);

	sc->sc_allocated -= mem->am_size;
	TAILQ_REMOVE(&sc->sc_memory, mem, am_link);
	bus_dmamap_destroy(sc->sc_dmat, mem->am_dmamap);
	free(mem, M_AGP, sizeof *mem);
	return (0);
}

int
agp_generic_bind_memory(struct agp_softc *sc, struct agp_memory *mem,
    bus_size_t offset)
{
	bus_dma_segment_t	*segs, *seg;
	bus_addr_t		 apaddr = sc->sc_apaddr + offset;
	bus_size_t		 done, i, j;
	int			 nseg, error;

	rw_enter_write(&sc->sc_lock);

	if (mem->am_is_bound) {
		printf("AGP: memory already bound\n");
		rw_exit_write(&sc->sc_lock);
		return (EINVAL);
	}

	if ((offset & (AGP_PAGE_SIZE - 1)) != 0 ||
	    offset + mem->am_size > sc->sc_apsize) {
		printf("AGP: binding memory at bad offset %#lx\n",
		    (unsigned long) offset);
		rw_exit_write(&sc->sc_lock);
		return (EINVAL);
	}

	/*
	 * The memory here needs to be directly accessable from the
	 * AGP video card, so it should be allocated using bus_dma.
	 * However, it need not be contiguous, since individual pages
	 * are translated using the GATT.
	 */

	nseg = (mem->am_size + PAGE_SIZE - 1) / PAGE_SIZE;
	segs = mallocarray(nseg, sizeof *segs, M_AGP, M_WAITOK);
	if ((error = bus_dmamem_alloc(sc->sc_dmat, mem->am_size, PAGE_SIZE, 0,
	    segs, nseg, &mem->am_nseg, BUS_DMA_ZERO | BUS_DMA_WAITOK)) != 0) {
		free(segs, M_AGP, nseg * sizeof *segs);
		rw_exit_write(&sc->sc_lock);
		AGP_DPF("bus_dmamem_alloc failed %d\n", error);
		return (error);
	}
	if ((error = bus_dmamap_load_raw(sc->sc_dmat, mem->am_dmamap, segs,
	    mem->am_nseg, mem->am_size, BUS_DMA_WAITOK)) != 0) {
		bus_dmamem_free(sc->sc_dmat, segs, mem->am_nseg);
		free(segs, M_AGP, nseg * sizeof *segs);
		rw_exit_write(&sc->sc_lock);
		AGP_DPF("bus_dmamap_load failed %d\n", error);
		return (error);
	}
	mem->am_dmaseg = segs;

	/*
	 * Install entries in the GATT, making sure that if
	 * AGP_PAGE_SIZE < PAGE_SIZE and mem->am_size is not
	 * aligned to PAGE_SIZE, we don't modify too many GATT
	 * entries. Flush chipset tlb when done.
	 */
	done = 0;
	for (i = 0; i < mem->am_dmamap->dm_nsegs; i++) {
		seg = &mem->am_dmamap->dm_segs[i];
		for (j = 0; j < seg->ds_len && (done + j) < mem->am_size;
		    j += AGP_PAGE_SIZE) {
			AGP_DPF("binding offset %#lx to pa %#lx\n",
			    (unsigned long)(offset + done + j),
			    (unsigned long)seg->ds_addr + j);
			sc->sc_methods->bind_page(sc->sc_chipc,
			    apaddr + done + j, seg->ds_addr + j, 0);
		}
		done += seg->ds_len;
	}

	/*
	 * Flush the cpu cache since we are providing a new mapping
	 * for these pages.
	 */
	agp_flush_cache();

	/*
	 * Make sure the chipset gets the new mappings.
	 */
	sc->sc_methods->flush_tlb(sc->sc_chipc);

	mem->am_offset = offset;
	mem->am_is_bound = 1;

	rw_exit_write(&sc->sc_lock);

	return (0);
}

int
agp_generic_unbind_memory(struct agp_softc *sc, struct agp_memory *mem)
{
	bus_addr_t	apaddr = sc->sc_apaddr + mem->am_offset;
	bus_size_t	i;

	rw_enter_write(&sc->sc_lock);

	if (mem->am_is_bound == 0) {
		printf("AGP: memory is not bound\n");
		rw_exit_write(&sc->sc_lock);
		return (EINVAL);
	}

	if (mem->am_mapref > 0) {
		printf("AGP: memory is mapped\n");
		rw_exit_write(&sc->sc_lock);
		return (EINVAL);
	}

	/*
	 * Unbind the individual pages and flush the chipset's
	 * TLB. Unwire the pages so they can be swapped.
	 */
	for (i = 0; i < mem->am_size; i += AGP_PAGE_SIZE)
		sc->sc_methods->unbind_page(sc->sc_chipc, apaddr + i);

	agp_flush_cache();
	sc->sc_methods->flush_tlb(sc->sc_chipc);

	bus_dmamap_unload(sc->sc_dmat, mem->am_dmamap);
	bus_dmamem_free(sc->sc_dmat, mem->am_dmaseg, mem->am_nseg);

	free(mem->am_dmaseg, M_AGP, 0);

	mem->am_offset = 0;
	mem->am_is_bound = 0;

	rw_exit_write(&sc->sc_lock);

	return (0);
}

a329 44
/* Helper functions used in both user and kernel APIs */

int
agp_acquire_helper(void *dev, enum agp_acquire_state state)
{
	struct agp_softc *sc = (struct agp_softc *)dev;

	if (sc->sc_chipc == NULL) 
		return (EINVAL);

	if (sc->sc_state != AGP_ACQUIRE_FREE)
		return (EBUSY);
	sc->sc_state = state;

	return (0);
}

int
agp_release_helper(void *dev, enum agp_acquire_state state)
{
	struct agp_softc *sc = (struct agp_softc *)dev;
	struct agp_memory* mem;

	if (sc->sc_state == AGP_ACQUIRE_FREE)
		return (0);

	if (sc->sc_state != state) 
		return (EBUSY);

	/*
	 * Clear out the aperture and free any
	 * outstanding memory blocks.
	 */
	TAILQ_FOREACH(mem, &sc->sc_memory, am_link) {
		if (mem->am_is_bound) {
			printf("agp_release_helper: mem %d is bound\n",
			    mem->am_id);
			agp_unbind_memory(sc, mem);
		}
	}
	sc->sc_state = AGP_ACQUIRE_FREE;
	return (0);
}

d369 8
a376 1
        return (agp_acquire_helper(sc, AGP_ACQUIRE_KERNEL));
d384 8
a391 1
        return (agp_release_helper(sc, AGP_ACQUIRE_KERNEL));
a407 144
void *
agp_alloc_memory(void *dev, int type, vsize_t bytes)
{
	struct agp_softc	*sc = dev;
	struct agp_memory	*mem;

	if (sc->sc_methods->alloc_memory != NULL) {
		mem = sc->sc_methods->alloc_memory(sc->sc_chipc, type, bytes);
	} else {
		mem = agp_generic_alloc_memory(sc, type, bytes);
	}
        return  (mem);
}

void
agp_free_memory(void *dev, void *handle)
{
	struct agp_softc *sc = dev;
        struct agp_memory *mem = handle;

	if (sc->sc_methods->free_memory != NULL) {
		sc->sc_methods->free_memory(sc->sc_chipc, mem);
	} else {
		agp_generic_free_memory(sc, mem);
	}
}

int
agp_bind_memory(void *dev, void *handle, off_t offset)
{
	struct agp_softc	*sc = dev;
	struct agp_memory	*mem = handle;
	int			 ret;	

	if (sc->sc_methods->bind_memory != NULL) {
		ret = sc->sc_methods->bind_memory(sc->sc_chipc, mem, offset);
	} else {
		ret = agp_generic_bind_memory(sc, mem, offset);
	}
	return (ret);
}

int
agp_unbind_memory(void *dev, void *handle)
{
	struct agp_softc	*sc = dev;
        struct agp_memory	*mem = handle;
	int			 ret;	

	if (sc->sc_methods->unbind_memory != NULL) {
		ret = sc->sc_methods->unbind_memory(sc->sc_chipc, mem);
	} else {
		ret = agp_generic_unbind_memory(sc, mem);
	}
	return (ret);
}

void
agp_memory_info(void *dev, void *handle, struct agp_memory_info *mi)
{
        struct agp_memory *mem = (struct agp_memory *) handle;

        mi->ami_size = mem->am_size;
        mi->ami_physical = mem->am_physical;
        mi->ami_offset = mem->am_offset;
        mi->ami_is_bound = mem->am_is_bound;
}

void *
agp_map(struct agp_softc *sc, bus_size_t address, bus_size_t size,
    bus_space_handle_t *memh)
{
	struct agp_memory* mem;

	if (sc->sc_chipc == NULL)
		return (NULL);

	if (address >= sc->sc_apsize)
		return (NULL);

	if (sc->sc_apaddr) {
		if (bus_space_map(sc->sc_memt, sc->sc_apaddr + address, size,
		    BUS_SPACE_MAP_LINEAR | BUS_SPACE_MAP_PREFETCHABLE, memh))
			return (NULL);
	} else {
		/*
		 * If the aperture base address is 0 assume that the AGP
		 * bridge does not support remapping for processor accesses.
		 */
		mem = agp_lookup_memory(sc, address);
		if (mem == NULL)
			return (NULL);

		/*
		 * Map the whole memory region because it is easier to
		 * do so and it is improbable that only a part of it
		 * will be used.
		 */
		if (mem->am_mapref == 0)
			if (bus_dmamem_map(sc->sc_dmat, mem->am_dmaseg,
			    mem->am_nseg, mem->am_size, &mem->am_kva,
			    BUS_DMA_NOWAIT | BUS_DMA_NOCACHE))
				return (NULL);

		mem->am_mapref++;

		/*
		 * XXX Fake a bus handle even if it is managed memory,
		 * this is needed at least by radeondrm(4).
		 */
		*memh = (bus_space_handle_t)(mem->am_kva + address);
	}

	return bus_space_vaddr(sc->sc_memt, *memh);
}

void
agp_unmap(struct agp_softc *sc, void *address, size_t size,
    bus_space_handle_t memh)
{
	struct agp_memory* mem;
	caddr_t kva;

	if (sc->sc_apaddr)
		return bus_space_unmap(sc->sc_memt, memh, size);

	kva = (caddr_t)address;
	TAILQ_FOREACH(mem, &sc->sc_memory, am_link) {
		if (mem->am_is_bound == 0)
			continue;

		if (kva >= mem->am_kva && kva < (mem->am_kva + mem->am_size)) {
			mem->am_mapref--;

			if (mem->am_mapref == 0) {
				bus_dmamem_unmap(sc->sc_dmat, mem->am_kva,
				    mem->am_size);
				mem->am_kva = 0;
			}
			break;
		}
	}
}

a410 2
	struct agp_memory* mem;

d417 1
a417 5
	if (sc->sc_apaddr)
		return bus_space_mmap(sc->sc_memt, sc->sc_apaddr, off, prot, 0);

	mem = agp_lookup_memory(sc, off);
	if (mem == NULL)
d420 1
a420 2
	return bus_dmamem_mmap(sc->sc_dmat, mem->am_dmaseg, mem->am_nseg, off,
	    prot, BUS_DMA_NOCACHE);
@


1.46
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.45 2014/07/13 23:10:23 deraadt Exp $ */
a54 1
int	agp_generic_enable(struct agp_softc *, u_int32_t);
@


1.45
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.44 2014/07/12 18:48:51 tedu Exp $ */
d243 1
a243 1
		free(gatt, M_AGP, 0);
d251 1
a251 1
		free(gatt, M_AGP, 0);
d265 1
a265 1
	free(gatt, M_AGP, 0);
d343 1
a343 1
		free(mem, M_AGP, 0);
d364 1
a364 1
	free(mem, M_AGP, 0);
d404 1
a404 1
		free(segs, M_AGP, 0);
d412 1
a412 1
		free(segs, M_AGP, 0);
@


1.44
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.43 2014/03/26 14:41:41 mpi Exp $ */
d401 1
a401 1
	segs = malloc(nseg * sizeof *segs, M_AGP, M_WAITOK);
@


1.43
log
@No need to include <sys/lock.h> when only <sys/rwlock.h> is needed,
so remove the former and include the latter instead of pulling it
in <dev/pci/agpvar.h>.  This header already requires various other
types anyway.  While here remove unneeded headers.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.42 2014/03/17 22:01:56 kettenis Exp $ */
d243 1
a243 1
		free(gatt, M_AGP);
d251 1
a251 1
		free(gatt, M_AGP);
d265 1
a265 1
	free(gatt, M_AGP);
d343 1
a343 1
		free(mem, M_AGP);
d364 1
a364 1
	free(mem, M_AGP);
d404 1
a404 1
		free(segs, M_AGP);
d412 1
a412 1
		free(segs, M_AGP);
d491 1
a491 1
	free(mem->am_dmaseg, M_AGP);
@


1.42
log
@The AGP ioctl interface is gone; remove the header file as well.

ok matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.41 2014/03/17 04:10:59 jsg Exp $ */
d31 1
d33 1
d35 1
a35 1
#include <uvm/uvm.h>
@


1.41
log
@fix memory leaks in error paths when setting up the gatt
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.40 2014/03/16 13:57:28 kettenis Exp $ */
a31 3
#include <sys/agpio.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
@


1.40
log
@Remove unused prototypes.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.39 2014/03/14 23:42:41 kettenis Exp $ */
d243 2
a244 1
	    &gatt->ag_physical, &gatt->ag_dmaseg) != 0)
d246 1
d252 1
@


1.39
log
@Remove the userland AGP interface.  Now that we have KMS, it is no longer
used by any of the remaining xenocara drivers.  Except perhaps for the
legacy i810 support in the xf86-video-intel driver.  But i810 support has
almost certainly been broken for more than a year now, and any remaining
users are probably better off using the xf86-video-vesa driver ever since
XAA support was removed from the X server.

ok deraadt@@, jsg@@, mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.38 2013/08/06 09:45:32 jsg Exp $ */
a61 5
int	agpbusprint(void *, const char *);
paddr_t	agpmmap(dev_t, off_t, int);
int	agpioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	agpopen(dev_t, int, int, struct proc *);
int	agpclose(dev_t, int, int , struct proc *);
@


1.38
log
@set ai_devid in struct agp_info so drm_agp_info() will work as intended
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.37 2013/07/06 23:35:44 brad Exp $ */
a70 1
/* userland ioctl functions */
a71 6
int	agp_info_user(void *, agp_info *);
int	agp_setup_user(void *, agp_setup *);
int	agp_allocate_user(void *, agp_allocate *);
int	agp_deallocate_user(void *, int);
int	agp_bind_user(void *, agp_bind *);
int	agp_unbind_user(void *, agp_unbind *);
a203 95
paddr_t
agpmmap(dev_t dev, off_t off, int prot)
{
	struct agp_softc *sc = agp_find_device(AGPUNIT(dev));

	if (sc == NULL)
		return (-1);

	return agp_mmap(sc, off, prot);
}
int
agpopen(dev_t dev, int oflags, int devtype, struct proc *p)
{
        struct agp_softc *sc = agp_find_device(AGPUNIT(dev));

        if (sc == NULL || sc->sc_chipc == NULL)
                return (ENXIO);

        if (!sc->sc_opened)
                sc->sc_opened = 1;
        else
                return (EBUSY);

        return (0);
}


int
agpioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *pb)
{
	struct agp_softc *sc = agp_find_device(AGPUNIT(dev));

	if (sc == NULL)
		return (ENODEV);

	if (sc->sc_methods == NULL || sc->sc_chipc == NULL)
		return (ENXIO);
	
	if (cmd != AGPIOC_INFO && !(flag & FWRITE))
		return (EPERM);

	switch(cmd) {
	case AGPIOC_INFO:
		return (agp_info_user(sc, (agp_info *)addr));

	case AGPIOC_ACQUIRE:
		return (agp_acquire_helper(sc, AGP_ACQUIRE_USER));

	case AGPIOC_RELEASE:
		return (agp_release_helper(sc, AGP_ACQUIRE_USER));

	case AGPIOC_SETUP:
		return (agp_setup_user(sc, (agp_setup *)addr));

	case AGPIOC_ALLOCATE:
		return (agp_allocate_user(sc, (agp_allocate *)addr));

	case AGPIOC_DEALLOCATE:
		return (agp_deallocate_user(sc, *(int *)addr));

	case AGPIOC_BIND:
		return (agp_bind_user(sc, (agp_bind *)addr));

	case AGPIOC_UNBIND:
		return (agp_unbind_user(sc, (agp_unbind *)addr));

	default:
		return (ENOTTY);
	}

}

int
agpclose(dev_t dev, int flags, int devtype, struct proc *p)
{
	struct agp_softc *sc = agp_find_device(AGPUNIT(dev));
	struct agp_memory *mem;

	/*
         * Clear the GATT and force release on last close
         */
	if (sc->sc_state == AGP_ACQUIRE_USER) {
		while ((mem = TAILQ_FIRST(&sc->sc_memory)) != 0) {
			if (mem->am_is_bound) {
				agp_unbind_memory(sc, mem);
			}
			agp_free_memory(sc, mem);
		}
                agp_release_helper(sc, AGP_ACQUIRE_USER);
	}
        sc->sc_opened = 0;

	return (0);
}

a595 90
}

/* Implementation of the userland ioctl API */

int
agp_info_user(void *dev, agp_info *info)
{
	struct agp_softc *sc = (struct agp_softc *) dev;

	if (!sc->sc_chipc)
		return (ENXIO);

	bzero(info, sizeof *info);
	info->bridge_id = sc->sc_id;
	if (sc->sc_capoff != 0)
		info->agp_mode = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
		    AGP_STATUS + sc->sc_capoff);
	else
		info->agp_mode = 0; /* i810 doesn't have real AGP */
	info->aper_base = sc->sc_apaddr;
	info->aper_size = sc->sc_apsize >> 20;
	info->pg_total =
	info->pg_system = sc->sc_maxmem >> AGP_PAGE_SHIFT;
	info->pg_used = sc->sc_allocated >> AGP_PAGE_SHIFT;

	return (0);
}

int
agp_setup_user(void *dev, agp_setup *setup)
{
	struct agp_softc	*sc = dev;

	return (agp_enable(sc, setup->agp_mode));
}

int
agp_allocate_user(void *dev, agp_allocate *alloc)
{
	struct agp_softc	*sc = dev;
	struct agp_memory	*mem; 
	size_t			 size = alloc->pg_count << AGP_PAGE_SHIFT;

	if (sc->sc_allocated + size > sc->sc_maxmem)
		return (EINVAL);

	mem = agp_alloc_memory(sc, alloc->type, size);
	if (mem) {
		alloc->key = mem->am_id;
		alloc->physical = mem->am_physical;
		return (0);
	} else
		return (ENOMEM);
}

int
agp_deallocate_user(void *dev, int id)
{
	struct agp_softc	*sc = dev;
	struct agp_memory	*mem;

	if ((mem = agp_find_memory(sc, id)) != NULL) {
		agp_free_memory(sc, mem);
		return (0);
	} else
		return (ENOENT);
}

int
agp_bind_user(void *dev, agp_bind *bind)
{
	struct agp_softc	*sc = dev;
	struct agp_memory	*mem;

	if ((mem = agp_find_memory(sc, bind->key)) == NULL)
		return (ENOENT);
	return (agp_bind_memory(sc, mem, bind->pg_start << AGP_PAGE_SHIFT));
}


int
agp_unbind_user(void *dev, agp_unbind *unbind)
{
	struct agp_softc	*sc = dev;
	struct agp_memory	*mem;

	if ((mem = agp_find_memory(sc, unbind->key)) == NULL)
		return (ENOENT);

	return (agp_unbind_memory(sc, mem));
@


1.37
log
@Remove unsigned comparison < 0.

Pointed out by LLVM.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.36 2012/12/06 15:05:21 mpi Exp $ */
d819 3
a821 2
        info->ai_memory_allowed = sc->sc_maxmem;
        info->ai_memory_used = sc->sc_allocated;
@


1.36
log
@Rework how AGP memory regions are mapped and add support for AGP bridges
that do not support remapping for processor accesses.

Add new functions to map/unmap/mmap agp memory and let the agp layer
decides how these memory regions should be accessed. It's assumed here
that the bridge does not support remapping if its aperture address is 0.

This is the last diff required for having drm(4) on macppc using agp(4).

Joint work with and ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.35 2012/11/13 13:37:24 mpi Exp $ */
d490 1
a490 1
	if (offset < 0 || (offset & (AGP_PAGE_SIZE - 1)) != 0 ||
@


1.35
log
@Correct the first argument of agpmmap() making possible to mmap the AGP
aperture.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.34 2010/12/26 15:41:00 miod Exp $ */
d68 3
a70 1
struct agp_memory *agp_find_memory(struct agp_softc *sc, int id);
d193 1
d216 1
a216 1
	if (sc == NULL || sc->sc_chipc == NULL)
d219 1
a219 12
	if (sc->sc_apaddr) {

		if (off > sc->sc_apsize)
			return (-1);

		/*
		 * XXX this should use bus_space_mmap() but it's not
		 * availiable on all archs.
		 */
		return (sc->sc_apaddr + off);
	}
	return (-1);
a220 1

d317 18
a334 1
	return (0);
d577 5
d919 98
@


1.34
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.33 2009/12/15 20:26:21 jasper Exp $ */
d63 1
a63 1
paddr_t	agpmmap(void *, off_t, int);
d209 1
a209 1
agpmmap(void *v, off_t off, int prot)
d211 4
a214 1
	struct agp_softc* sc = (struct agp_softc *)v;
@


1.33
log
@- instead of rolling a macro that is functional equivalent to nitems(),
just use nitems(). (this leaves NENTS() alone for now)

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.32 2009/05/10 16:57:44 oga Exp $ */
d222 1
a222 1
		return atop(sc->sc_apaddr + off);
@


1.32
log
@Change agp attach (again) so that the driver passes in the aperture size.

While the aperture size may change during attach, it never changes after
the end of the subdriver attach function, so getting this value with a
function is a waste of time. shrinks things slightly and makes the code
clearer.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.31 2009/05/10 15:28:45 oga Exp $ */
a165 1
#define	agp_max_size	 (sizeof(agp_max)/sizeof(agp_max[0]))
d173 1
a173 1
	for (i = 0; i < agp_max_size && memsize > agp_max[i][0]; i++)
d175 2
a176 2
	if (i == agp_max_size)
		i = agp_max_size - 1;
@


1.31
log
@In preparation for using agp as a bus_dma backend for drm, convert the bind_page
and unbind_page callbacks from

int bind_page(void *, off_t, bus_addr_t)

to

void bind_page(void *, bus_addr_t, paddr_t, int)

We can make these function void by making sure that the agp code sanity
checks properly (it already mostly did), so by definition these
functions may not fail.  The flags field is currently unused (intagp at
least will have a use for it soon).

Been in my tree for ages.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.30 2009/05/10 14:44:42 oga Exp $ */
d118 1
a118 1
    bus_addr_t apaddr, struct device *dev)
d125 1
d153 1
d197 1
a197 1
	    (u_long)sc->sc_methods->get_aperture(sc->sc_chipc));
d216 1
a216 1
		if (off > sc->sc_methods->get_aperture(sc->sc_chipc))
d480 2
a481 3
	if (offset < 0 || (offset & (AGP_PAGE_SIZE - 1)) != 0
	    || offset + mem->am_size >
	    sc->sc_methods->get_aperture(sc->sc_chipc)) {
d703 1
a703 1
	info->aper_size = sc->sc_methods->get_aperture(sc->sc_chipc) >> 20;
d803 1
a803 1
	info->ai_aperture_size = sc->sc_methods->get_aperture(sc->sc_chipc);
@


1.30
log
@change agp driver attach so that the driver passes in the base address
of its aperture, instead of the BAR and memory type. This is a little
larger, but allows the driver to know it's aperture address. Needed for
some future stuff.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.29 2009/04/20 01:28:45 oga Exp $ */
d463 1
a463 1
			off_t offset)
d465 4
a468 5
	bus_dma_segment_t *segs, *seg;
	bus_size_t done, j;
	bus_addr_t pa;
	off_t i, k;
	int nseg, error;
d514 4
a517 2
	 * Bind the individual pages and flush the chipset's
	 * TLB.
a521 6
		/*
		 * Install entries in the GATT, making sure that if
		 * AGP_PAGE_SIZE < PAGE_SIZE and mem->am_size is not
		 * aligned to PAGE_SIZE, we don't modify too many GATT
		 * entries.
		 */
a523 1
			pa = seg->ds_addr + j;
d526 3
a528 20
			    (unsigned long)pa);
			error = sc->sc_methods->bind_page(sc->sc_chipc,
			    offset + done + j, pa);
			if (error) {
				/*
				 * Bail out. Reverse all the mappings
				 * and unwire the pages.
				 */
				for (k = 0; k < done + j; k += AGP_PAGE_SIZE)
					sc->sc_methods->unbind_page(
					    sc->sc_chipc, offset + k);

				bus_dmamap_unload(sc->sc_dmat, mem->am_dmamap);
				bus_dmamem_free(sc->sc_dmat, mem->am_dmaseg,
				    mem->am_nseg);
				free(mem->am_dmaseg, M_AGP);
				rw_exit_write(&sc->sc_lock);
				AGP_DPF("AGP_BIND_PAGE failed %d\n", error);
				return (error);
			}
d555 2
a556 1
	int i;
d572 1
a572 1
		sc->sc_methods->unbind_page(sc->sc_chipc, mem->am_offset + i);
@


1.29
log
@Don't map all agp memory we allocate.

If we're just going to be making it available to userland (the X
server), just use load_raw and make sure it's zeroed with BUS_DMA_ZERO.
Should save $AMOUNT_BOUND_TO_GART kva. Most kernel users also write
through the gart, so no mapping there either.

tested by sthen and todd a while back.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.28 2009/04/15 03:09:47 oga Exp $ */
d118 1
a118 1
    int bar, pcireg_t type, struct device *dev)
d124 1
a124 2
	arg.aa_bar = bar;
	arg.aa_type = type;
d151 1
d194 1
a194 8
	printf(": ");
	if (agp_map_aperture(pa, sc, aa->aa_bar, aa->aa_type) != 0) {
		printf("can't map aperture\n");
		sc->sc_chipc = NULL;
		return;
	}

	printf("aperture at 0x%lx, size 0x%lx\n", (u_long)sc->sc_apaddr,
a321 11
	return (0);
}

int
agp_map_aperture(struct pci_attach_args *pa, struct agp_softc *sc, u_int32_t bar, u_int32_t memtype)
{
	/* Find the aperture. Don't map it (yet), this would eat KVA */
	if (pci_mapreg_info(pa->pa_pc, pa->pa_tag, bar, memtype,
	    &sc->sc_apaddr, NULL, NULL) != 0)
		return (ENXIO);

@


1.28
log
@clean up the sub-driver callback mess a little.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.27 2008/11/09 15:11:19 oga Exp $ */
d346 2
a347 3
	struct agp_gatt	*gatt;
	u_int32_t	 entries = apsize >> AGP_PAGE_SHIFT;
	int		 nseg;
d353 1
d355 2
a356 3
	if (agp_alloc_dmamem(dmat, entries * sizeof(u_int32_t),
	    0, &gatt->ag_dmamap, (caddr_t *)&gatt->ag_virtual,
	    &gatt->ag_physical, &gatt->ag_dmaseg, 1, &nseg) != 0)
d359 7
a365 2
	gatt->ag_size = entries * sizeof(u_int32_t);
	memset(gatt->ag_virtual, 0, gatt->ag_size);
d374 2
a375 2
	agp_free_dmamem(dmat, gatt->ag_size, gatt->ag_dmamap,
	    (caddr_t)gatt->ag_virtual, &gatt->ag_dmaseg, 1);
d516 1
a516 1
	    segs, nseg, &mem->am_nseg, BUS_DMA_WAITOK)) != 0) {
d522 2
a523 13
	if ((error = bus_dmamem_map(sc->sc_dmat, segs, mem->am_nseg,
	    mem->am_size, &mem->am_virtual, BUS_DMA_WAITOK)) != 0) {
		bus_dmamem_free(sc->sc_dmat, segs, mem->am_nseg);
		free(segs, M_AGP);
		rw_exit_write(&sc->sc_lock);
		AGP_DPF("bus_dmamem_map failed %d\n", error);
		return (error);
	}
	if ((error = bus_dmamap_load(sc->sc_dmat, mem->am_dmamap,
	    mem->am_virtual, mem->am_size, NULL,
	    BUS_DMA_WAITOK)) != 0) {
		bus_dmamem_unmap(sc->sc_dmat, mem->am_virtual,
		    mem->am_size);
a562 2
				bus_dmamem_unmap(sc->sc_dmat, mem->am_virtual,
				    mem->am_size);
a617 1
	bus_dmamem_unmap(sc->sc_dmat, mem->am_virtual, mem->am_size);
d630 3
d634 2
a635 4
agp_alloc_dmamem(bus_dma_tag_t tag, size_t size, int flags,
    bus_dmamap_t *mapp, caddr_t *vaddr, bus_addr_t *baddr,
    bus_dma_segment_t *seg, int nseg, int *rseg)

d637 1
a637 1
	int error, level = 0;
d640 1
a640 6
	    seg, nseg, rseg, BUS_DMA_NOWAIT)) != 0)
		goto out;
	level++;

	if ((error = bus_dmamem_map(tag, seg, *rseg, size, vaddr,
	    BUS_DMA_NOWAIT | flags)) != 0)
d644 1
a644 1
	if ((error = bus_dmamap_create(tag, size, *rseg, size, 0,
d649 1
a649 1
	if ((error = bus_dmamap_load(tag, *mapp, *vaddr, size, NULL,
d658 1
a658 1
	case 3:
a660 3
	case 2:
		bus_dmamem_unmap(tag, *vaddr, size);
		/* FALLTHROUGH */
d662 1
a662 1
		bus_dmamem_free(tag, seg, *rseg);
d673 1
a673 1
    caddr_t vaddr, bus_dma_segment_t *seg, int nseg)
a674 1

d677 1
a677 2
	bus_dmamem_unmap(tag, vaddr, size);
	bus_dmamem_free(tag, seg, nseg);
@


1.27
log
@Rework that way that agp attaches.

previously, we had a static list of pcidevs and which agp driver would
be interanlly attached. Instead, split the agp drivers so they work like
audio(4), where we attach a driver, which sets up some callbacks and
initial state, then attaches the interface (agp(4)). Since this allows
us to attach different drivers in different places, and give them
/proper/ probe functions move most of the drivers back to attaching at
pchb, where they should, and intagp (formerly agp_i810) stays attaching
at vga, since it's part of the intel integrated graphics chips.

Diff shrinks the kernel slightly, gets rid of the annoying "no integrated
graphics" warning, and allows more cleanup later.

Tested by many. fix for alpha build (the only other vga_pci.c consumer)
suggested by miod.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.26 2008/09/26 21:15:53 mikeb Exp $ */
a55 20
#define AGP_ENABLE(sc, m) ((sc->sc_methods->enable != NULL) ?	\
	sc->sc_methods->enable(sc->sc_chipc, m) :		    	\
	agp_generic_enable(sc, m))

#define AGP_ALLOC_MEMORY(sc, t, s) ((sc->sc_methods->alloc_memory != NULL) ? \
	sc->sc_methods->alloc_memory(sc->sc_chipc, t, s) :		    \
	agp_generic_alloc_memory(sc, t, s))

#define AGP_FREE_MEMORY(sc, m) ((sc->sc_methods->free_memory != NULL) ?	\
	sc->sc_methods->free_memory(sc->sc_chipc, m) :			\
	agp_generic_free_memory(sc, m))

#define AGP_BIND_MEMORY(sc, m, o) ((sc->sc_methods->bind_memory != NULL) ? \
	sc->sc_methods->bind_memory(sc->sc_chipc, m, o)	:	 	  \
	agp_generic_bind_memory(sc, m, o))

#define AGP_UNBIND_MEMORY(sc, m) ((sc->sc_methods->unbind_memory != NULL) ? \
	sc->sc_methods->unbind_memory(sc->sc_chipc, m) :		   \
	agp_generic_unbind_memory(sc, m))

d307 1
a307 1
				AGP_UNBIND_MEMORY(sc, mem);
d309 1
a309 1
			AGP_FREE_MEMORY(sc, mem);
d609 1
a609 1
	if (!mem->am_is_bound) {
d736 1
a736 1
			AGP_UNBIND_MEMORY(sc, mem);
d772 1
a772 1
	struct agp_softc *sc = (struct agp_softc *)dev;
d774 1
a774 1
	return (AGP_ENABLE(sc, setup->agp_mode));
d780 3
a782 3
	struct agp_softc *sc = (struct agp_softc *)dev;
	struct agp_memory* mem; 
	size_t size = alloc->pg_count << AGP_PAGE_SHIFT;
d787 1
a787 1
	mem = AGP_ALLOC_MEMORY(sc, alloc->type, size);
d799 5
a803 4
	struct agp_softc *sc = (struct agp_softc *) dev;
	struct agp_memory *mem = agp_find_memory(sc, id);
	if (mem) {
		AGP_FREE_MEMORY(sc, mem);
d812 2
a813 2
	struct agp_softc *sc = (struct agp_softc *) dev;
	struct agp_memory *mem = agp_find_memory(sc, bind->key);
d815 1
a815 1
	if (!mem)
d817 1
a817 2

	return (AGP_BIND_MEMORY(sc, mem, bind->pg_start << AGP_PAGE_SHIFT));
d824 2
a825 2
	struct agp_softc *sc = (struct agp_softc *) dev;
	struct agp_memory *mem = agp_find_memory(sc, unbind->key);
d827 1
a827 1
	if (!mem)
d830 1
a830 1
	return (AGP_UNBIND_MEMORY(sc, mem));
d885 2
a886 1
	struct agp_softc *sc = (struct agp_softc *) dev;
d888 6
a893 1
        return (AGP_ENABLE(sc, mode));
d899 2
a900 1
	struct agp_softc *sc = (struct agp_softc *)dev;
d902 6
a907 1
        return  (AGP_ALLOC_MEMORY(sc, type, bytes));
d913 2
a914 2
	struct agp_softc *sc = (struct agp_softc *) dev;
        struct agp_memory *mem = (struct agp_memory *) handle;
d916 5
a920 1
        AGP_FREE_MEMORY(sc, mem);
d926 10
a935 4
	struct agp_softc *sc = (struct agp_softc *) dev;
	struct agp_memory *mem = (struct agp_memory *) handle;

	return (AGP_BIND_MEMORY(sc, mem, offset));
d941 10
a950 4
	struct agp_softc *sc = (struct agp_softc *) dev;
        struct agp_memory *mem = (struct agp_memory *) handle;

        return (AGP_UNBIND_MEMORY(sc, mem));
@


1.26
log
@Attach agp(4) to the Intel Q35 integrated video.
Tested on ASUS P5E-VM DO motherboard.

ok oga
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.25 2008/08/17 21:31:38 oga Exp $ */
d49 38
a86 8
#include "agp_ali.h"
#include "agp_amd.h"
#include "agp_amd64.h"
#include "agp_apple.h"
#include "agp_i810.h"
#include "agp_intel.h"
#include "agp_sis.h"
#include "agp_via.h"
a88 1
const struct agp_product *agp_lookup(struct pci_attach_args *pa);
d90 1
d100 13
a112 39
const struct agp_product agp_products[] = {
#if NAGP_ALI > 0
	{ PCI_VENDOR_ALI, -1, agp_ali_attach },
#endif
#if NAGP_AMD > 0
	{ PCI_VENDOR_AMD, -1, agp_amd_attach },
#endif
#if NAGP_I810 > 0
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82810_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82810_DC100_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82810E_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82815_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82830M_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82845G_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82855GM_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82865G_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82915G_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82915GM_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82945G_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82945GM_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82945GME_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82G965_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82Q965_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82GM965_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82G33_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82G35_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82Q35_HB, agp_i810_attach },
#endif 
#if NAGP_INTEL > 0
	{ PCI_VENDOR_INTEL, -1, agp_intel_attach },
#endif 
#if NAGP_SIS > 0
	{ PCI_VENDOR_SIS, -1, agp_sis_attach },
#endif
#if NAGP_VIA > 0
	{ PCI_VENDOR_VIATECH, -1, agp_via_attach },
#endif
	{ 0, 0, NULL }
};
d114 6
d121 3
d125 14
a138 1
agp_probe(struct device *parent, void *match, void *aux)
d140 1
a140 2
	struct agpbus_attach_args *aaa = aux;
	struct pci_attach_args *pa = &aaa->apa_pci_args;
d142 4
a145 4
	/* pci_args must be a pchb */
	if (PCI_CLASS(pa->pa_class) != PCI_CLASS_BRIDGE || 
	    PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_BRIDGE_HOST)
		return (0);
d147 3
a149 2
	if (agp_lookup(pa) == NULL)
		return (0);
d151 7
d164 2
a165 2
	struct agpbus_attach_args *aaa = aux;
	struct pci_attach_args *pa = &aaa->apa_pci_args;
a166 1
	const struct agp_product *ap;
d168 4
a171 1
	int i, ret;
d173 11
a183 13
	ap = agp_lookup(pa);
	if (ap) {
		static const int agp_max[][2] = {
			{0,		0},
			{32,		4},
			{64,		28},
			{128,		96},
			{256,		204},
			{512,		440},
			{1024,		942},
			{2048,		1920},
			{4096,		3932}
		};
d186 5
a190 5
		/*
		 * Work out an upper bound for agp memory allocation. This
		 * uses a heuristic table from the Linux driver.
		 */
		memsize = ptoa(physmem) >> 20;
d192 5
a196 5
		for (i = 0; i < agp_max_size && memsize > agp_max[i][0]; i++)
			;
		if (i == agp_max_size)
			i = agp_max_size - 1;
		sc->sc_maxmem = agp_max[i][1] << 20;
d198 7
a204 4
		/*
		 * The lock is used to prevent re-entry to
		 * agp_generic_bind_memory() since that function can sleep.
		 */
d206 4
a209 1
		rw_init(&sc->sc_lock, "agplk");
d211 2
a212 1
		TAILQ_INIT(&sc->sc_memory);
d214 5
a218 22
		sc->sc_pcitag = pa->pa_tag;
		sc->sc_pc = pa->pa_pc;
		sc->sc_id = pa->pa_id;
		sc->sc_dmat = pa->pa_dmat;
		sc->sc_memt = pa->pa_memt;
		sc->sc_vgapcitag = aaa->apa_vga_args.pa_tag;
		sc->sc_vgapc = aaa->apa_vga_args.pa_pc;

		pci_get_capability(sc->sc_pc, sc->sc_pcitag, PCI_CAP_AGP,
		    &sc->sc_capoff, NULL);

		sc->vga_softc = (struct vga_pci_softc *)parent;

		printf(": ");
		ret = (*ap->ap_attach)(sc, pa);
		if (ret == 0)
			printf("aperture at 0x%lx, size 0x%lx\n",
			    (u_long)sc->sc_apaddr,
			    (u_long)AGP_GET_APERTURE(sc));
		else {
			sc->sc_chipc = NULL;
		}
d220 3
d226 1
a226 1
        sizeof (struct agp_softc), agp_probe, agp_attach,
d241 1
a241 1
		if (off > AGP_GET_APERTURE(sc))
d258 1
a258 4
        if (sc == NULL)
                return (ENXIO);

        if (sc->sc_chipc == NULL)
d275 1
a275 1
	if (sc ==NULL)
d326 1
a326 1
			if (mem->am_is_bound)
d328 1
a351 31
const struct agp_product *
agp_lookup(struct pci_attach_args *pa)
{
	const struct agp_product *ap;

	/* First find the vendor. */
	for (ap = agp_products; ap->ap_attach != NULL; ap++)
		if (ap->ap_vendor == PCI_VENDOR(pa->pa_id))
			break;

	if (ap->ap_attach == NULL)
		return (NULL);

	/* Now find the product within the vendor's domain. */
	for (; ap->ap_attach != NULL; ap++) {
		/* Ran out of this vendor's section of the table. */
		if (ap->ap_vendor != PCI_VENDOR(pa->pa_id))
			return (NULL);

		if (ap->ap_product == PCI_PRODUCT(pa->pa_id))
			break;		/* Exact match. */
		if (ap->ap_product == (u_int32_t) -1)
			break;		/* Wildcard match. */
	}

	if (ap->ap_attach == NULL)
		ap = NULL;

	return (ap);
}

d356 2
a357 3
	if (pci_mapreg_info(pa->pa_pc, pa->pa_tag, bar,
	    memtype, &sc->sc_apaddr, &sc->sc_apsize,
	    &sc->sc_apflags) != 0)
a362 15
u_int32_t
agp_generic_get_aperture(struct agp_softc *sc)
{
	return (sc->sc_apsize);
}

int
agp_generic_set_aperture(struct agp_softc *sc, u_int32_t aperture)
{
	if (aperture != AGP_GET_APERTURE(sc))
		return (EINVAL);

	return (0);
}

d364 1
a364 1
agp_alloc_gatt(struct agp_softc *sc)
d366 3
a368 4
	u_int32_t apsize = AGP_GET_APERTURE(sc);
	u_int32_t entries = apsize >> AGP_PAGE_SHIFT;
	struct agp_gatt *gatt;
	int nseg;
d375 1
a375 1
	if (agp_alloc_dmamem(sc->sc_dmat, entries * sizeof(u_int32_t),
d388 1
a388 1
agp_free_gatt(struct agp_softc *sc, struct agp_gatt *gatt)
d390 1
a390 1
	agp_free_dmamem(sc->sc_dmat, gatt->ag_size, gatt->ag_dmamap,
a395 7
agp_generic_detach(struct agp_softc *sc)
{
	agp_flush_cache();
	return (0);
}

int
d398 3
a400 3
	pcireg_t tstatus, mstatus;
	pcireg_t command;
	int rq, sba, fw, rate, capoff;
d402 2
a403 1
	if (pci_get_capability(sc->sc_vgapc, sc->sc_vgapcitag, PCI_CAP_AGP,
d412 1
a412 1
	mstatus = pci_conf_read(sc->sc_vgapc, sc->sc_vgapcitag,
d452 1
a452 2
	pci_conf_write(sc->sc_vgapc, sc->sc_vgapcitag, capoff + AGP_COMMAND,
	    command);
d513 3
a515 3
	if (offset < 0
	    || (offset & (AGP_PAGE_SIZE - 1)) != 0
	    || offset + mem->am_size > AGP_GET_APERTURE(sc)) {
d578 2
a579 1
			error = AGP_BIND_PAGE(sc, offset + done + j, pa);
d586 2
a587 1
					AGP_UNBIND_PAGE(sc, offset + k);
d612 1
a612 1
	AGP_FLUSH_TLB(sc);
d641 1
a641 1
		AGP_UNBIND_PAGE(sc, mem->am_offset + i);
d644 1
a644 1
	AGP_FLUSH_TLB(sc);
d781 1
a781 1
	info->aper_size = AGP_GET_APERTURE(sc) >> 20;
d792 1
a792 1
	struct agp_softc *sc = (struct agp_softc *) dev;
d800 1
a800 1
	struct agp_softc *sc = (struct agp_softc *) dev;
d875 5
a879 2
        info->ai_mode = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
	    sc->sc_capoff + AGP_STATUS);
d881 1
a881 1
	info->ai_aperture_size = sc->sc_apsize;
d915 1
a915 1
        return  ((void *) AGP_ALLOC_MEMORY(sc, type, bytes));
@


1.25
log
@Check that the driver properly initialised before allowing agp_acquire()
to succeed.

Inspired by Tobias Ulmer, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.24 2008/07/12 17:31:06 oga Exp $ */
d96 1
@


1.24
log
@Right now agp_generic_enable() is wrong. It has been since 2006. It
assumes that the display device and the agp bridge are the same device.
In almost all cases this is incorrect.

In order to correctly enable the agp device with the correct mode, we
need to set the AGP_COMMAND register on both the display and the bridge
with the right bits. Since agp is currently attaching at vga(4), due to
the problems with the intel integrated graphics (a problem that I still
need to solve, to be honest), for now just provide both pci_attach_args
to the agp init, and get what we need from there to do the enable.

This fixes the "agp bug" which i have been known to rant about, a lot.
So agp radeons now work with dri without needing to be forced to pci
mode.

This wasn't detected before, since the only non-drm consumer of agp is
the intel X driver, the i810 agp driver has its own enable function.

tested by many. ok kettenis@@.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.23 2008/07/07 07:54:48 bernd Exp $ */
d754 3
d971 1
a971 2
agp_memory_info(void *dev, void *handle, struct
    agp_memory_info *mi)
@


1.23
log
@Add AGP and hostbridge support for the Intel 82945GME chipset.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.22 2008/06/25 18:54:06 oga Exp $ */
d177 3
d432 1
a432 1
	if (pci_get_capability(sc->sc_pc, sc->sc_pcitag, PCI_CAP_AGP,
d440 2
a441 1
	mstatus = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
d478 1
d481 2
a482 1
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, capoff + AGP_COMMAND, command);
@


1.22
log
@Support the Intel G35 which apparently works similarly to the 965.

Initial information, half the diff, and testing from Andrew Lutomirski,
thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.21 2008/05/06 19:19:02 oga Exp $ */
d90 1
@


1.21
log
@currently agp_i810 needs to map the same BAR as inteldrm, this obviously
fails.

In order to allow this, implement an API so that drm and agp can share
mappings for the BARs. Now it works as it should.

tested by many.
ok kettenis, miod said he'd look at it when it's in tree.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.20 2008/04/09 18:59:58 oga Exp $ */
d94 1
@


1.20
log
@device_lookup() increments the reference count for the device, and we
never decrement it. Since kernel mappings aren't touched if the device
is closed, just grab the softc manually instead on these functions, this
means close will be called after the kernel api has been used.

ok kettenis@@.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.19 2008/03/23 19:54:47 oga Exp $ */
d178 2
@


1.19
log
@Sometimes the registers claiming the aperture size on 9XX chipsets lie.

So instead, use the size of the aperture BAR to determine the aperture
size for agp_i810, and don't let the 855 and above have the aperture
set. Next to nothing uses it anyway so no harm.

introduce generic_{get,set} aperture which has this behaviour so other
drivers may use it if useful.

Change inspired by what freebsd did after i noticed my aperture size was
wrong.

Tested by many, ok kettenis@@.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.18 2008/03/23 08:36:41 damien Exp $ */
d222 1
a222 1
        struct agp_softc *sc = (struct agp_softc *)device_lookup(&agp_cd, AGPUNIT(dev));
d242 1
a242 1
	struct agp_softc *sc = (struct agp_softc *)device_lookup(&agp_cd, AGPUNIT(dev));
d287 1
a287 2
	struct agp_softc *sc = 
		(struct agp_softc *)device_lookup(&agp_cd, AGPUNIT(dev));
d873 3
a875 1
        return (device_lookup(&agp_cd, unit)); 
@


1.18
log
@Add AGP support for the Intel G33 chipset.
Tested on i386 with a Gigabyte G33M-DS2R motherboard (Intel GMA 3100).
Based on NetBSD code.

ok oga@@
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.17 2008/03/16 19:00:28 oga Exp $ */
d360 15
@


1.17
log
@Make agp(4) attach at vga(4) instead of pchb(4). This is because sometimes
agp and drm need to use the same memory mapping, the best way to deal
with that is to allow them to share (that's coming later), for this to
work cleanly we move the attach point of agp.

Ideally most agp drivers would attach at pchb, with only agp_i810
(and any that work similarly) attaching at vga, but this will do for
now.

ok kettenis@@, miod@@.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.16 2008/01/04 00:23:26 kettenis Exp $ */
d93 1
@


1.16
log
@Clean up Intel host bridge PCI IDs.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.15 2008/01/02 03:40:38 brad Exp $ */
d112 5
@


1.15
log
@correct the comment in agp_map_aperture().

ok owa@@ dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.14 2007/12/07 17:35:22 oga Exp $ */
d78 8
a85 9
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82810_MCH, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82810_DC100_MCH, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82810E_MCH, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82815_FULL_HUB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82840_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82830MP_IO_1, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82845G, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82852GM_HPB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82865_IO_1, agp_i810_attach },
d88 5
a92 11
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82945GP_MCH, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82945GM_MCH, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82Q963_HB, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82965_MCH, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82915G_IV, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82915GM_IGD, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82945G_IGD_1, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82945GM_IGD, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82965_IGD_1, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82965GM_MCH, agp_i810_attach },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82965GM_IGD_1, agp_i810_attach },
@


1.14
log
@KNF, no binary change.

Looked over by a few people.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.11 2007/11/28 16:25:58 chl Exp $ */
d356 1
a356 4
	/*
	 * Find and the aperture. Don't map it (yet), this would
	 * eat KVA.
	 */
@


1.13
log
@Replace lockmgr with rwlock.

advice from thib. Comments and ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.12 2007/12/06 22:49:39 oga Exp $ */
d61 8
a68 8
int agp_info_user(void *, agp_info *);
int agp_setup_user(void *, agp_setup *);
int agp_allocate_user(void *, agp_allocate *);
int agp_deallocate_user(void *, int);
int agp_bind_user(void *, agp_bind *);
int agp_unbind_user(void *, agp_unbind *);
int agp_acquire_helper(void *dev, enum agp_acquire_state state);
int agp_release_helper(void *dev, enum agp_acquire_state state);
d220 2
a221 1
int agpopen(dev_t dev , int oflags, int devtype, struct proc * p)
d416 1
a416 1
	     &capoff, NULL) == 0) {
d435 2
a436 2
	       & AGP_MODE_GET_SBA(mstatus)
	       & AGP_MODE_GET_SBA(mode));
d440 2
a441 2
	       & AGP_MODE_GET_FW(mstatus)
	       & AGP_MODE_GET_FW(mode));
d445 2
a446 2
		& AGP_MODE_GET_RATE(mstatus)
		& AGP_MODE_GET_RATE(mode));
d527 1
a527 1
			      (unsigned long) offset);
d583 1
a583 1
		     j += AGP_PAGE_SIZE) {
d586 2
a587 2
				(unsigned long)(offset + done + j),
				(unsigned long)pa);
d599 1
a599 1
						 mem->am_size);
d601 1
a601 1
						mem->am_nseg);
d670 2
a671 2
		 bus_dmamap_t *mapp, caddr_t *vaddr, bus_addr_t *baddr,
		 bus_dma_segment_t *seg, int nseg, int *rseg)
d677 1
a677 1
			seg, nseg, rseg, BUS_DMA_NOWAIT)) != 0)
d682 1
a682 1
			BUS_DMA_NOWAIT | flags)) != 0)
d687 1
a687 1
			BUS_DMA_NOWAIT, mapp)) != 0)
d692 1
a692 1
			BUS_DMA_NOWAIT)) != 0)
d718 1
a718 1
		caddr_t vaddr, bus_dma_segment_t *seg, int nseg)
d798 1
d879 1
a879 1
		    sc->sc_capoff + AGP_STATUS);
d890 1
d898 1
d906 1
d910 2
a911 1
void *agp_alloc_memory(void *dev, int type, vsize_t bytes)
d914 1
d918 2
a919 1
void agp_free_memory(void *dev, void *handle)
d923 1
d927 2
a928 1
int agp_bind_memory(void *dev, void *handle, off_t offset)
d932 1
d936 2
a937 1
int agp_unbind_memory(void *dev, void *handle)
d941 1
d945 3
a947 2
void agp_memory_info(void *dev, void *handle, struct
                     agp_memory_info *mi)
@


1.12
log
@Destatic functions in the agp subsystem.

KNF coming shortly.

ok marco, jsg and mbalmer
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.11 2007/11/28 16:25:58 chl Exp $ */
d168 1
a168 1
		lockinit(&sc->sc_lock, PZERO|PCATCH, "agplk", 0, 0);
a402 1
	lockmgr(&sc->sc_lock, LK_DRAIN, NULL);
d514 1
a514 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL);
d518 1
a518 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d527 1
a527 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d543 1
a543 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d551 1
a551 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d562 1
a562 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d602 1
a602 1
				lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d624 1
a624 1
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d634 1
a634 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL);
d638 1
a638 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d662 1
a662 1
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
@


1.11
log
@do not check malloc return value against NULL, as M_WAITOK is used

ok oga@@
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.10 2007/11/26 15:35:15 deraadt Exp $ */
d61 8
a68 8
static int agp_info_user(void *, agp_info *);
static int agp_setup_user(void *, agp_setup *);
static int agp_allocate_user(void *, agp_allocate *);
static int agp_deallocate_user(void *, int);
static int agp_bind_user(void *, agp_bind *);
static int agp_unbind_user(void *, agp_unbind *);
static int agp_acquire_helper(void *dev, enum agp_acquire_state state);
static int agp_release_helper(void *dev, enum agp_acquire_state state);
d114 1
a114 1
static int
d729 1
a729 1
static int
d741 1
a741 1
static int
d770 1
a770 1
static int
d794 1
a794 1
static int
d801 1
a801 1
static int
d820 1
a820 1
static int
d832 1
a832 1
static int
d845 1
a845 1
static int
@


1.10
log
@correct newlines surrounding the sub-bus configuration, and unify
pchb's further
ok reyk oga
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.9 2007/11/26 10:35:42 reyk Exp $ */
a476 2
	if (mem == NULL)
		return (NULL);
a540 6
	if (segs == NULL) {
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
		AGP_DPF("malloc segs (%u) failed\n",
		    nseg * sizeof *segs);
		return (ENOMEM);
	}
@


1.9
log
@fix new agp code on amd64
- internal intel graphics semi-agp chipsets need special handling in pchb.c
- re-add the i965GM device
- use the correct major device id for /dev/agp0 on amd64 (not the i386 one)

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.8 2007/11/25 17:11:12 oga Exp $ */
d180 1
d183 1
a183 1
			printf(": aperture at 0x%lx, size 0x%lx",
a187 1
			printf(": AGP GART");
@


1.8
log
@Make agp attach as a device. This means that many more agp bridges
actually get detected and attached. Also adds a kernel api for
manipulating agp.

Enable this on i386 and amd64.

"I think you should commit it" deraadt@@, ok matthieu. Looked over by
several others.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.7 2007/09/17 01:33:33 krw Exp $ */
d98 1
@


1.7
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.6 2007/08/04 19:40:25 reyk Exp $ */
d39 1
d49 10
a58 1
struct agp_memory *agp_find_memory(struct vga_pci_softc *sc, int id);
d60 52
d113 11
a123 2
struct pci_attach_args agp_pchb_pa;
int agp_pchb_pa_set = 0;
d128 3
a130 2
	struct pci_attach_args *pa = aux;
	struct vga_pci_softc *sc = (struct vga_pci_softc *)self;
d179 1
a179 1
		ret = (*ap->ap_attach)(sc, pa, &agp_pchb_pa);
d191 9
d201 1
a201 1
agp_mmap(void *v, off_t off, int prot)
d203 1
a203 2
	struct vga_config* vs = (struct vga_config*) v;
	struct vga_pci_softc* sc = (struct vga_pci_softc *)vs->vc_softc;
d210 4
d216 1
a216 1
	return -1;
d219 19
d239 1
a239 1
agp_ioctl(void *v, u_long cmd, caddr_t addr, int flag, struct proc *pb)
d241 4
a244 10
	struct vga_config *vc = v;
	struct vga_pci_softc *sc = (struct vga_pci_softc *)vc->vc_softc;
	struct agp_memory *mem;
	agp_info *info;
	agp_setup *setup;
	agp_allocate *alloc;
	agp_bind *bind;
	agp_unbind *unbind;
	vsize_t size;
	int error = 0;
d248 3
a251 15
	switch (cmd) {
	case AGPIOC_INFO:
		if (!sc->sc_chipc)
			return (ENXIO);
	case AGPIOC_ACQUIRE:
	case AGPIOC_RELEASE:
	case AGPIOC_SETUP:
	case AGPIOC_ALLOCATE:
	case AGPIOC_DEALLOCATE:
	case AGPIOC_BIND:
	case AGPIOC_UNBIND:
		if (cmd != AGPIOC_INFO && !(flag & FWRITE))
			return (EPERM);
		break;
	}
d254 1
a254 14
		info = (agp_info *)addr;
		bzero(info, sizeof *info);
		info->bridge_id = sc->sc_id;
		if (sc->sc_capoff != 0)
			info->agp_mode = pci_conf_read(sc->sc_pc, sc->sc_pcitag,
			    AGP_STATUS + sc->sc_capoff);
		else
			info->agp_mode = 0; /* i810 doesn't have real AGP */
		info->aper_base = sc->sc_apaddr;
		info->aper_size = AGP_GET_APERTURE(sc) >> 20;
		info->pg_total =
		info->pg_system = sc->sc_maxmem >> AGP_PAGE_SHIFT;
		info->pg_used = sc->sc_allocated >> AGP_PAGE_SHIFT;
		break;
d257 1
a257 5
		if (sc->sc_state != AGP_ACQUIRE_FREE)
			error = EBUSY;
		else
			sc->sc_state = AGP_ACQUIRE_USER;
		break;
d260 1
a260 21
		if (sc->sc_state == AGP_ACQUIRE_FREE)
			break;

		if (sc->sc_state != AGP_ACQUIRE_USER) {
			error = EBUSY;
			break;
		}

		/*
		 * Clear out the aperture and free any
		 * outstanding memory blocks.
		 */
		TAILQ_FOREACH(mem, &sc->sc_memory, am_link) {
			if (mem->am_is_bound) {
				printf("agp_release_helper: mem %d is bound\n",
				    mem->am_id);
				AGP_UNBIND_MEMORY(sc, mem);
			}
		}
		sc->sc_state = AGP_ACQUIRE_FREE;
		break;
d263 1
a263 3
		setup = (agp_setup *)addr;
		error = AGP_ENABLE(sc, setup->agp_mode);
		break;
d266 1
a266 13
		alloc = (agp_allocate *)addr;
		size = alloc->pg_count << AGP_PAGE_SHIFT;
		if (sc->sc_allocated + size > sc->sc_maxmem)
			error = EINVAL;
		else {
			mem = AGP_ALLOC_MEMORY(sc, alloc->type, size);
			if (mem) {
				alloc->key = mem->am_id;
				alloc->physical = mem->am_physical;
			} else
				error = ENOMEM;
		}
		break;
d269 1
a269 6
		mem = agp_find_memory(sc, *(int *)addr);
		if (mem)
			AGP_FREE_MEMORY(sc, mem);
		else
			error = ENOENT;
		break;
d272 1
a272 8
		bind = (agp_bind *)addr;
		mem = agp_find_memory(sc, bind->key);
		if (!mem)
			error = ENOENT;
		else
			error = AGP_BIND_MEMORY(sc, mem,
			    bind->pg_start << AGP_PAGE_SHIFT);
		break;
d275 2
a276 7
		unbind = (agp_unbind *)addr;
		mem = agp_find_memory(sc, unbind->key);
		if (!mem)
			error = ENOENT;
		else
			error = AGP_UNBIND_MEMORY(sc, mem);
		break;
d278 1
a278 1
		error = ENOTTY;
a280 1
	return (error);
d283 2
a284 3
#ifdef notyet
void
agp_close(void *v)
d286 2
a287 2
	struct vga_config *vc = v;
	struct vga_pci_softc *sc = (struct vga_pci_softc *)vc->vc_softc;
d291 7
a297 6
	 * Clear out the aperture and free any
	 * outstanding memory blocks.
	 */
	TAILQ_FOREACH(mem, &sc->sc_memory, am_link) {
		if (mem->am_is_bound) {
			AGP_UNBIND_MEMORY(sc, mem);
d299 1
d301 1
d303 1
a303 6
	while (!TAILQ_EMPTY(&sc->sc_memory)) {
		mem = TAILQ_FIRST(&sc->sc_memory);
		AGP_FREE_MEMORY(sc, mem);
	}

	sc->sc_state = AGP_ACQUIRE_FREE;
a304 1
#endif
d307 1
a307 1
agp_find_memory(struct vga_pci_softc *sc, int id)
d317 1
a317 1
	return 0;
a324 4
	if (!agp_pchb_pa_set)
		return (NULL);
	agp_pchb_pa_set = 0;

a350 9
void
pciagp_set_pchb(struct pci_attach_args *pa)
{
	if (!agp_pchb_pa_set) {
		memcpy(&agp_pchb_pa, pa, sizeof *pa);
		agp_pchb_pa_set++;
	}
}

d352 1
a352 1
agp_map_aperture(struct vga_pci_softc *sc, u_int32_t bar, u_int32_t memtype)
d358 1
a358 1
	if (pci_mapreg_info(sc->sc_pc, sc->sc_pcitag, bar,
d361 1
a361 1
		return ENXIO;
d363 1
a363 1
	return 0;
d367 1
a367 1
agp_alloc_gatt(struct vga_pci_softc *sc)
d374 1
a374 1
	gatt = malloc(sizeof(*gatt), M_DEVBUF, M_NOWAIT | M_ZERO);
d382 1
a382 1
		return NULL;
d388 1
a388 1
	return gatt;
d392 1
a392 1
agp_free_gatt(struct vga_pci_softc *sc, struct agp_gatt *gatt)
d396 1
a396 1
	free(gatt, M_DEVBUF);
d400 1
a400 1
agp_generic_detach(struct vga_pci_softc *sc)
d404 1
a404 1
	return 0;
d408 1
a408 1
agp_generic_enable(struct vga_pci_softc *sc, u_int32_t mode)
d417 1
a417 1
		return -1;
d462 1
a462 1
	return 0;
d466 1
a466 1
agp_generic_alloc_memory(struct vga_pci_softc *sc, int type, vsize_t size)
d472 1
a472 1
		return 0;
d475 1
a475 1
	mem = malloc(sizeof *mem, M_DEVBUF, M_WAITOK | M_ZERO);
d477 1
a477 1
		return NULL;
d481 2
a482 2
		free(mem, M_DEVBUF);
		return NULL;
d490 1
a490 1
	return mem;
d494 1
a494 1
agp_generic_free_memory(struct vga_pci_softc *sc, struct agp_memory *mem)
d497 1
a497 1
		return EBUSY;
d502 2
a503 2
	free(mem, M_DEVBUF);
	return 0;
d507 1
a507 1
agp_generic_bind_memory(struct vga_pci_softc *sc, struct agp_memory *mem,
d521 1
a521 1
		return EINVAL;
d530 1
a530 1
		return EINVAL;
d541 1
a541 1
	segs = malloc(nseg * sizeof *segs, M_DEVBUF, M_WAITOK);
d546 1
a546 1
		return ENOMEM;
d550 1
a550 1
		free(segs, M_DEVBUF);
d553 1
a553 1
		return error;
d558 1
a558 1
		free(segs, M_DEVBUF);
d561 1
a561 1
		return error;
d569 1
a569 1
		free(segs, M_DEVBUF);
d572 1
a572 1
		return error;
d609 1
a609 1
				free(mem->am_dmaseg, M_DEVBUF);
d612 1
a612 1
				return error;
d634 1
a634 1
	return 0;
d638 1
a638 1
agp_generic_unbind_memory(struct vga_pci_softc *sc, struct agp_memory *mem)
d647 1
a647 1
		return EINVAL;
d665 1
a665 1
	free(mem->am_dmaseg, M_DEVBUF);
d672 1
a672 1
	return 0;
d704 1
a704 1
	return 0;
d720 1
a720 1
	return error;
d732 217
@


1.6
log
@Add AGP support for the intel i965 chipset, this also extends the
internal AGP API to work with 64bit PCI-Express memory and
non-standard AGP aperture bases.

tested by many
ok matthieu@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.5 2007/01/30 21:12:14 dim Exp $ */
d375 1
a375 1
	gatt = malloc(sizeof(*gatt), M_DEVBUF, M_NOWAIT);
a377 1
	bzero(gatt, sizeof(*gatt));
d476 1
a476 1
	mem = malloc(sizeof *mem, M_DEVBUF, M_WAITOK);
a478 1
	bzero(mem, sizeof *mem);
@


1.5
log
@Simplify agp_generic_bind_memory by not trying to allocate big chunks
of contiguous memory in a loop.  This should save contiguous memory
for other drivers, and AGP doesn't need it.

Tested by many, ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.4 2007/01/03 14:05:00 deraadt Exp $ */
d353 1
a353 1
agp_map_aperture(struct vga_pci_softc *sc)
d359 2
a360 2
	if (pci_mapreg_info(sc->sc_pc, sc->sc_pcitag, AGP_APBASE,
	    PCI_MAPREG_TYPE_MEM, &sc->sc_apaddr, &sc->sc_apsize,
@


1.4
log
@also bail if sc_chipc is NULL; spotted by miod
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.3 2007/01/02 22:22:19 deraadt Exp $ */
d517 1
a517 1
	int contigpages, nseg, error;
a536 1
	 * XXXfvdl
a540 7
	 *
	 * Using a large chunk of contiguous memory may get in the way
	 * of other subsystems that may need one, so we try to be friendly
	 * and ask for allocation in chunks of a minimum of 8 pages
	 * of contiguous memory on average, falling back to 4, 2 and 1
	 * if really needed. Larger chunks are preferred, since allocating
	 * a bus_dma_segment per page would be overkill.
d543 22
a564 30
	for (contigpages = 32; contigpages > 0; contigpages >>= 1) {
		nseg = (mem->am_size / (contigpages * PAGE_SIZE)) + 1;
		segs = malloc(nseg * sizeof *segs, M_DEVBUF, M_WAITOK);
		if (segs == NULL)
			return ENOMEM;
		if ((error = bus_dmamem_alloc(sc->sc_dmat, mem->am_size, PAGE_SIZE, 0,
		    segs, nseg, &mem->am_nseg, BUS_DMA_WAITOK)) != 0) {
			free(segs, M_DEVBUF);
			AGP_DPF("bus_dmamem_alloc failed %d\n", error);
			continue;
		}
		if ((error = bus_dmamem_map(sc->sc_dmat, segs, mem->am_nseg,
		    mem->am_size, &mem->am_virtual, BUS_DMA_WAITOK)) != 0) {
			bus_dmamem_free(sc->sc_dmat, segs, mem->am_nseg);
			free(segs, M_DEVBUF);
			AGP_DPF("bus_dmamem_map failed %d\n", error);
			continue;
		}
		if ((error = bus_dmamap_load(sc->sc_dmat, mem->am_dmamap,
		    mem->am_virtual, mem->am_size, NULL,
		    BUS_DMA_WAITOK)) != 0) {
			bus_dmamem_unmap(sc->sc_dmat, mem->am_virtual,
			    mem->am_size);
			bus_dmamem_free(sc->sc_dmat, segs, mem->am_nseg);
			free(segs, M_DEVBUF);
			AGP_DPF("bus_dmamap_load failed %d\n", error);
			continue;
		}
		mem->am_dmaseg = segs;
		break;
d566 7
a572 2

	if (contigpages == 0) {
d574 2
a575 1
		return ENOMEM;
d577 1
d614 1
@


1.3
log
@do not permit agp_ioctl if the methods are invalid; ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.2 2006/12/30 19:15:30 miod Exp $ */
d149 1
a149 1
	if (sc->sc_methods == NULL)
@


1.2
log
@In agp_generic_alloc_memory(), make sure the age_mem structure freshly
malloc'ed is completely bzeroed before use.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.1 2006/03/16 21:32:34 matthieu Exp $ */
d148 3
@


1.1
log
@Move the agpgart handling code to a separate file.
Ansify some remaining function declarations in vga_pci.c.
ok miod@@, dim@@.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d477 1
a486 4
	mem->am_type = 0;
	mem->am_physical = 0;
	mem->am_offset = 0;
	mem->am_is_bound = 0;
@


1.1.2.1
log
@Errata #7:
       Insufficient validation in vga(4) may allow an attacker to gain
       root privileges if the kernel is compiled with option PCIAGP and
       the actual device is not an AGP device. The PCIAGP option is
       present by default on i386 kernels only.
@
text
@d1 1
a1 1
/* $OpenBSD: agp.c,v 1.1 2006/03/16 21:32:34 matthieu Exp $ */
a147 3

	if (sc->sc_methods == NULL || sc->sc_chipc == NULL)
		return (ENXIO);
@


