head	1.65;
access;
symbols
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.65.0.6
	OPENBSD_6_0_BASE:1.65
	OPENBSD_5_9:1.65.0.2
	OPENBSD_5_9_BASE:1.65
	OPENBSD_5_8:1.63.0.6
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.63.0.4
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.60.0.4
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.57.0.10
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.57.0.8
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.57.0.6
	OPENBSD_5_2_BASE:1.57
	OPENBSD_5_1_BASE:1.57
	OPENBSD_5_1:1.57.0.4
	OPENBSD_5_0:1.57.0.2
	OPENBSD_5_0_BASE:1.57
	OPENBSD_4_9:1.56.0.2
	OPENBSD_4_9_BASE:1.56
	OPENBSD_4_8:1.55.0.2
	OPENBSD_4_8_BASE:1.55
	OPENBSD_4_7:1.52.0.2
	OPENBSD_4_7_BASE:1.52
	OPENBSD_4_6:1.51.0.4
	OPENBSD_4_6_BASE:1.51
	OPENBSD_4_5:1.49.0.10
	OPENBSD_4_5_BASE:1.49
	OPENBSD_4_4:1.49.0.8
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.49.0.6
	OPENBSD_4_3_BASE:1.49
	OPENBSD_4_2:1.49.0.4
	OPENBSD_4_2_BASE:1.49
	OPENBSD_4_1:1.49.0.2
	OPENBSD_4_1_BASE:1.49
	OPENBSD_4_0:1.48.0.2
	OPENBSD_4_0_BASE:1.48
	OPENBSD_3_9:1.45.0.2
	OPENBSD_3_9_BASE:1.45
	OPENBSD_3_8:1.38.0.2
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.32.0.2
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.15
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	SMP:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.65
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.64;
commitid	5gdEnqVoJuTuwdTu;

1.64
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.63;
commitid	5DvsamK0GblTp8ww;

1.63
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.62;
commitid	yM2VFFhpDTeFQlve;

1.62
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.61;
commitid	TGHgrLxu6sxZoiFt;

1.61
date	2014.06.21.01.14.32;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	qZq5Xo7p5eCN25Vt;

1.60
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2013.11.14.12.16.01;	author dlg;	state Exp;
branches;
next	1.58;

1.58
date	2013.08.07.01.06.35;	author bluhm;	state Exp;
branches;
next	1.57;

1.57
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.56;

1.56
date	2010.08.27.18.25.47;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2010.08.07.07.08.34;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2010.08.07.07.04.35;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2010.08.06.14.11.48;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2009.10.15.17.54.56;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2009.06.05.19.30.48;	author naddy;	state Exp;
branches;
next	1.50;

1.50
date	2009.06.02.16.50.20;	author jsg;	state Exp;
branches;
next	1.49;

1.49
date	2006.11.05.02.47.01;	author brad;	state Exp;
branches;
next	1.48;

1.48
date	2006.07.01.21.48.08;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2006.06.17.18.00.43;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2006.03.08.20.51.59;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2006.01.05.21.34.35;	author brad;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2006.01.05.20.17.12;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2006.01.01.19.06.44;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.18.00.02.32;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.17.21.35.11;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.11.02.52.29;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2005.11.22.01.30.02;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2005.08.09.04.10.12;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2005.08.01.22.54.46;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2005.07.22.23.51.03;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2005.05.27.06.37.21;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.13.18.03.48;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.27.10.45.49;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2005.01.14.18.14.14;	author deraadt;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2004.09.20.04.24.00;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2004.09.18.20.31.45;	author beck;	state Exp;
branches;
next	1.29;

1.29
date	2004.09.16.02.56.22;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2004.08.04.19.42.30;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.27.02.38.38;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.18.22.37.25;	author beck;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.25.12.25.09;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.07.05.44.14;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.09.21.32.24;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.23.16.44.35;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.29.19.29.22;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.13.17.49.03;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.11.20.51.52;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.18.01.31.45;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.26.16.14.49;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2002.10.04.20.47.25;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.28.11.35.30;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.31.08.46.00;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.09.04.23.46.23;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.09.21.12.51;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.03.23.28.49;	author chris;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.13.23.19.16;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.29.14.03.01;	author art;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2000.09.25.21.03.15;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.18.15.27.54;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.26.19.12.08;	author chris;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.18.18.44.31;	author jason;	state Exp;
branches;
next	;

1.5.4.1
date	2001.05.14.22.25.45;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.07.04.10.42.13;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.5.4.7;

1.5.4.7
date	2003.05.13.19.35.06;	author ho;	state Exp;
branches;
next	1.5.4.8;

1.5.4.8
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	1.5.4.9;

1.5.4.9
date	2004.06.05.23.12.50;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;

1.32.2.1
date	2005.07.04.23.26.55;	author brad;	state Exp;
branches;
next	;

1.45.2.1
date	2006.05.02.02.06.16;	author brad;	state Exp;
branches;
next	;


desc
@@


1.65
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_fxp_pci.c,v 1.64 2015/11/24 13:33:17 mpi Exp $	*/

/*
 * Copyright (c) 1995, David Greenman
 * All rights reserved.
 *
 * Modifications to support NetBSD:
 * Copyright (c) 1997 Jason R. Thorpe.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice unmodified, this list of conditions, and the following
 *    disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	Id: if_fxp.c,v 1.55 1998/08/04 08:53:12 dg Exp
 */

/*
 * Intel EtherExpress Pro/100B PCI Fast Ethernet driver
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/timeout.h>
#include <sys/syslog.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>

#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/device.h>

#include <netinet/if_ether.h>

#include <machine/cpu.h>
#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/mii/miivar.h>

#include <dev/ic/fxpreg.h>
#include <dev/ic/fxpvar.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

int fxp_pci_match(struct device *, void *, void *);
void fxp_pci_attach(struct device *, struct device *, void *);
int fxp_pci_detach(struct device *, int);

struct fxp_pci_softc {
	struct fxp_softc	psc_softc;
	pci_chipset_tag_t	psc_pc;
	bus_size_t		psc_mapsize;
};

struct cfattach fxp_pci_ca = {
	sizeof(struct fxp_pci_softc), fxp_pci_match, fxp_pci_attach,
	fxp_pci_detach, fxp_activate
};

const struct pci_matchid fxp_pci_devices[] = {
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_8255x },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82552 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82559 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82559ER },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82562 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82562EH_HPNA_0 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82562EH_HPNA_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82562EH_HPNA_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_0 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_3 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_4 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_5 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_6 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_7 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_8 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_0 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_3 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_4 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_5 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_6 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_7 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_8 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_9 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_10 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_11 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_12 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_13 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_14 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_15 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_16 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_17 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_18 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_19 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_M },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801DB_LAN },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801E_LAN_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801E_LAN_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801FB_LAN },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801FB_LAN_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801FBM_LAN },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801GB_LAN },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801GB_LAN_2 },
};

int
fxp_pci_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, fxp_pci_devices,
	    nitems(fxp_pci_devices)));
}

void
fxp_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct fxp_pci_softc *psc = (void *)self;
	struct fxp_softc *sc = &psc->psc_softc;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	const char *chipname = NULL;
	const char *intrstr = NULL;

	if (pci_mapreg_map(pa, FXP_PCI_IOBA, PCI_MAPREG_TYPE_IO, 0,
	    &sc->sc_st, &sc->sc_sh, NULL, &psc->psc_mapsize, 0)) {
		printf(": can't map i/o space\n");
		return;
	}
	psc->psc_pc = pa->pa_pc;
	sc->sc_dmat = pa->pa_dmat;

	sc->sc_revision = PCI_REVISION(pa->pa_class);

	/*
	 * Allocate our interrupt.
	 */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		bus_space_unmap(sc->sc_st, sc->sc_sh, psc->psc_mapsize);
		return;
	}

	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, fxp_intr, sc,
	    self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(sc->sc_st, sc->sc_sh, psc->psc_mapsize);
		return;
	}

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_INTEL_8255x:
	case PCI_PRODUCT_INTEL_82559:
	case PCI_PRODUCT_INTEL_82559ER:
		chipname = "i82557";
		if (sc->sc_revision >= FXP_REV_82558_A4)
			chipname = "i82558";
		if (sc->sc_revision >= FXP_REV_82559_A0)
			chipname = "i82559";
		if (sc->sc_revision >= FXP_REV_82559S_A)
			chipname = "i82559S";
		if (sc->sc_revision >= FXP_REV_82550)
			chipname = "i82550";
		if (sc->sc_revision >= FXP_REV_82551_E)
			chipname = "i82551";
		break;
	case PCI_PRODUCT_INTEL_82552:
		chipname = "i82552";
		break;
	default:
		chipname = "i82562";
		break;
	}

	if (chipname != NULL)
		printf(", %s", chipname);

	/*
	 * Cards for which we should WRITE TO THE EEPROM
	 * to turn off dynamic standby mode to avoid
	 * a problem where the card will fail to resume when
	 * entering the IDLE state. We use this nasty if statement
	 * and corresponding pci dev numbers directly so that people
	 * know not to add new cards to this unless you are really
	 * certain what you are doing and are not going to end up
	 * killing people's eeproms.
	 */
	if ((PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL) &&
	    (PCI_PRODUCT(pa->pa_id) == 0x2449 || 
	    (PCI_PRODUCT(pa->pa_id) > 0x1030 && 
	    PCI_PRODUCT(pa->pa_id) < 0x1039) || 
	    (PCI_PRODUCT(pa->pa_id) == 0x1229 &&
	    (sc->sc_revision >= 8 && sc->sc_revision <= 16))))
		sc->sc_flags |= FXPF_DISABLE_STANDBY;

	/*
	 * enable PCI Memory Write and Invalidate command
	 */
	if (sc->sc_revision >= FXP_REV_82558_A4)
		if (PCI_CACHELINE(pci_conf_read(pa->pa_pc, pa->pa_tag,
		    PCI_BHLC_REG))) {
			pci_conf_write(pa->pa_pc, pa->pa_tag,
			    PCI_COMMAND_STATUS_REG,
			    PCI_COMMAND_INVALIDATE_ENABLE |
			    pci_conf_read(pa->pa_pc, pa->pa_tag,
			    PCI_COMMAND_STATUS_REG));
			sc->sc_flags |= FXPF_MWI_ENABLE;
		}

	/* Do generic parts of attach. */
	if (fxp_attach(sc, intrstr)) {
		/* Failed! */
		pci_intr_disestablish(pc, sc->sc_ih);
		bus_space_unmap(sc->sc_st, sc->sc_sh, psc->psc_mapsize);
		return;
	}
}

int
fxp_pci_detach(struct device *self, int flags)
{
	struct fxp_pci_softc *psc = (void *)self;
	struct fxp_softc *sc = &psc->psc_softc;

	if (sc->sc_ih != NULL)
		pci_intr_disestablish(psc->psc_pc, sc->sc_ih);
	fxp_detach(sc);
	bus_space_unmap(sc->sc_st, sc->sc_sh, psc->psc_mapsize);

	return (0);
}
@


1.64
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.63 2014/12/22 02:28:52 tedu Exp $	*/
a50 1
#include <net/if_dl.h>
@


1.63
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.62 2014/07/22 13:12:11 mpi Exp $	*/
a52 1
#include <net/if_types.h>
@


1.62
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.61 2014/06/21 01:14:32 deraadt Exp $	*/
a54 1
#ifdef INET
a55 1
#endif
@


1.61
log
@remove useless brace block; from dhill
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.60 2013/12/06 21:03:04 deraadt Exp $	*/
a56 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.60
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.59 2013/11/14 12:16:01 dlg Exp $	*/
a197 1
	{
a208 2
		break;
	}
@


1.59
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.58 2013/08/07 01:06:35 bluhm Exp $	*/
a48 1
#include <sys/task.h>
@


1.58
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.57 2011/04/03 15:36:02 jasper Exp $	*/
d49 1
a49 1
#include <sys/workq.h>
@


1.57
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.56 2010/08/27 18:25:47 deraadt Exp $	*/
a58 1
#include <netinet/in_var.h>
@


1.56
log
@Since the pci-specific activate function does nothing, move it to fxp.c.
Then it is possible for fxp_powerhook to use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.55 2010/08/07 07:08:34 deraadt Exp $	*/
d151 1
a151 1
	    sizeof(fxp_pci_devices)/sizeof(fxp_pci_devices[0])));
@


1.55
log
@In the resume case we need to check IFF_UP
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.54 2010/08/07 07:04:35 deraadt Exp $	*/
a84 2
int fxp_pci_activate(struct device *, int);
void fxp_pci_resume(void *, void *);
a89 1
	struct workq_task	psc_resume_wqt;
d94 1
a94 1
	    fxp_pci_detach, fxp_pci_activate
a278 31
}

int
fxp_pci_activate(struct device *self, int act)
{
	struct fxp_pci_softc *psc = (void *)self;
	struct fxp_softc *sc = &psc->psc_softc;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			fxp_stop(sc, 1, 0);
		config_activate_children(self, act);
		break;
	case DVACT_RESUME:
		config_activate_children(self, act);
		if (ifp->if_flags & IFF_UP)
			workq_queue_task(NULL, &psc->psc_resume_wqt, 0,
			    fxp_pci_resume, sc, NULL);
		break;
	}
	return (0);
}

void
fxp_pci_resume(void *arg1, void *arg2)
{
	struct fxp_softc *sc = arg1;

	fxp_init(sc);
@


1.54
log
@In fxp_pci_activate use the correct softc's; then use a workq since some
fxp's need load firmwares.....
tested by sebastia
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.53 2010/08/06 14:11:48 deraadt Exp $	*/
d299 1
a299 1
		if (ifp->if_flags & IFF_RUNNING)
@


1.53
log
@ca_activate for suspend/resume; tested by andrew@@afresh1.com
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.52 2009/10/15 17:54:56 deraadt Exp $	*/
d49 1
d86 1
d92 1
d287 2
a288 1
	struct fxp_softc *sc = (struct fxp_softc *)self;
d294 1
a294 1
			fxp_stop(sc, 1, 1);
d299 3
a301 2
		if (ifp->if_flags & IFF_UP)
			fxp_init(ifp);
d305 8
@


1.52
log
@Add detach support to a few more drivers, and in others do the neccessary
operations in the detach function in the right order.  Also ensure that the
interrupt handlers not trust registers that go away.
read over very carefully by dms, tested by me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.51 2009/06/05 19:30:48 naddy Exp $	*/
d84 1
d94 1
a94 1
	    fxp_pci_detach
d278 21
@


1.51
log
@Add support to fxp(4) for the 82552 MAC found in some variation of
the ICH7 chipset.  Untested, but can't break anything that already
works.  From Brad; ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.50 2009/06/02 16:50:20 jsg Exp $	*/
a270 1
	int rv;
d272 4
a275 4
	rv = fxp_detach(sc);
	if (rv == 0) {
		if (sc->sc_ih != NULL)
			pci_intr_disestablish(psc->psc_pc, sc->sc_ih);
d277 1
a277 4
		bus_space_unmap(sc->sc_st, sc->sc_sh, psc->psc_mapsize);
	}

	return (rv);
@


1.50
log
@Make fxp at pci detachable; untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.49 2006/11/05 02:47:01 brad Exp $	*/
d98 1
d213 3
@


1.49
log
@ANSI
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.48 2006/07/01 21:48:08 brad Exp $	*/
d83 7
d92 2
a93 1
	sizeof(struct fxp_softc), fxp_pci_match, fxp_pci_attach
d155 2
a156 1
	struct fxp_softc *sc = (struct fxp_softc *)self;
a161 1
	bus_size_t iosize;
d164 1
a164 1
	    &sc->sc_st, &sc->sc_sh, NULL, &iosize, 0)) {
d168 1
d178 1
a178 1
		bus_space_unmap(sc->sc_st, sc->sc_sh, iosize);
d190 1
a190 1
		bus_space_unmap(sc->sc_st, sc->sc_sh, iosize);
d257 1
a257 1
		bus_space_unmap(sc->sc_st, sc->sc_sh, iosize);
d260 18
@


1.48
log
@(fxp/re)_attach_common -> (fxp/re)_attach
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.47 2006/06/17 18:00:43 brad Exp $	*/
d138 1
a138 4
fxp_pci_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d145 1
a145 3
fxp_pci_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
@


1.47
log
@add sys/timeout.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.46 2006/03/08 20:51:59 miod Exp $	*/
d250 1
a250 1
	if (fxp_attach_common(sc, intrstr)) {
@


1.46
log
@Fix device id typo introduced in r1.41; found the hard way by Daniel Hamlin.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.45 2006/01/05 21:34:35 brad Exp $	*/
d47 1
@


1.45
log
@enable dynamic standby workaround for the 82551 as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.44 2006/01/05 20:17:12 brad Exp $	*/
d130 1
a130 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801GB_LAN_2 },
@


1.45.2.1
log
@MFC:
Fix by miod@@

Fix device id typo introduced in r1.41; found the hard way by Daniel Hamlin.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.45 2006/01/05 21:34:35 brad Exp $	*/
d130 1
a130 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801FB_LAN_2 },
@


1.44
log
@more fxp PCI ids.

From the Intel e100 driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.43 2006/01/01 19:06:44 brad Exp $	*/
d231 1
a231 1
	    (sc->sc_revision >= 8 && sc->sc_revision <= 13))))
@


1.43
log
@update for pcidevs name change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.42 2005/12/18 00:02:32 brad Exp $	*/
d98 1
a103 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_9 },
d110 14
a123 4
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_6 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_7 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_8 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_9 },
@


1.42
log
@if not a newer chip then print i82557, all fxp's attached to the ICH
chipsets are i82562.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.41 2005/12/17 21:35:11 brad Exp $	*/
d88 1
a88 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82557 },
a125 3
/*
 * Check if a device is an 82557.
 */
d180 1
a180 1
	case PCI_PRODUCT_INTEL_82557:
@


1.41
log
@more PCI ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.40 2005/12/11 02:52:29 brad Exp $	*/
d148 1
d187 1
a187 2
		const char *chipname = NULL;

a197 4

		if (chipname != NULL)
			printf(", %s", chipname);

d202 1
d205 3
@


1.40
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.39 2005/11/22 01:30:02 brad Exp $	*/
d101 3
d110 4
d120 1
d123 1
@


1.39
log
@sync with new names.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.38 2005/08/09 04:10:12 mickey Exp $	*/
a97 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_3 },
d109 1
@


1.38
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.37 2005/08/01 22:54:46 brad Exp $	*/
a101 2
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_7 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_8 },
d112 2
@


1.37
log
@add another fxp.

From NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.36 2005/07/22 23:51:03 brad Exp $	*/
a216 5

	/* enable bus mastering */
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    PCI_COMMAND_MASTER_ENABLE |
	    pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG));
@


1.36
log
@remove ICH3 workaround.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.35 2005/05/27 06:37:21 brad Exp $	*/
d114 1
@


1.35
log
@- fix reception of VLAN sized frames on 82558 and up
- add support for reception of VLAN sized frames on 82557
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.34 2005/05/13 18:03:48 brad Exp $	*/
d147 1
a147 1
	
a193 14
		break;
	case PCI_PRODUCT_INTEL_PRO_100_VE_0:
	case PCI_PRODUCT_INTEL_PRO_100_VE_1:
	case PCI_PRODUCT_INTEL_PRO_100_VM_0:
	case PCI_PRODUCT_INTEL_PRO_100_VM_1:
	case PCI_PRODUCT_INTEL_PRO_100_VM_2:
	case PCI_PRODUCT_INTEL_82562EH_HPNA_0:
	case PCI_PRODUCT_INTEL_82562EH_HPNA_1:
	case PCI_PRODUCT_INTEL_82562EH_HPNA_2:
		/*
		 * ICH3 chips apparently have problems with the enhanced
		 * features, so just treat them as an i82557.
		 */
		sc->sc_revision = 1;
@


1.34
log
@recognize 82551's
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.33 2005/03/27 10:45:49 brad Exp $	*/
a139 1
	pcireg_t rev = PCI_REVISION(pa->pa_class);
d148 1
a148 1
	sc->sc_revision = rev; 
d178 1
a178 1
		if (rev >= FXP_REV_82558_A4)
d180 1
a180 1
		if (rev >= FXP_REV_82559_A0)
d182 1
a182 1
		if (rev >= FXP_REV_82559S_A)
d184 1
a184 1
		if (rev >= FXP_REV_82550)
d186 1
a186 1
		if (rev >= FXP_REV_82551_E)
a193 4
		sc->not_82557 = (rev >= FXP_REV_82558_A4) ? 1 : 0;
		break;
	case PCI_PRODUCT_INTEL_82562:
		sc->not_82557 = 1;
a207 1
		sc->not_82557 = 0;
a209 1
		sc->not_82557 = 0;
d227 2
a228 2
	    (PCI_PRODUCT(pa->pa_id) == 0x1229 && (rev == 8 || rev == 9 ||
		rev == 12 || rev == 13))))
d239 1
a239 1
	if (rev >= FXP_REV_82558_A4)
@


1.33
log
@another fxp PCI id
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.32 2005/01/14 18:14:14 deraadt Exp $	*/
d187 2
@


1.32
log
@use PCI Memory Write and Invalidate; from bogdan@@eastonline.ru, ok pascoe
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.31 2004/09/20 04:24:00 brad Exp $	*/
d103 1
@


1.32.2.1
log
@MFC:
Fix by brad@@

fix reception of VLAN sized frames on 82558 and up

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.32 2005/01/14 18:14:14 deraadt Exp $	*/
a189 2
		sc->not_82557 = (rev >= FXP_REV_82558_A4) ? 1 : 0;

d192 1
@


1.31
log
@enable code to disable dynamic standby mode on 82550's

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.30 2004/09/18 20:31:45 beck Exp $	*/
d239 14
@


1.30
log
@new fxp variant, noticed by freebsd
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.29 2004/09/16 02:56:22 brad Exp $	*/
d231 2
a232 1
	    (PCI_PRODUCT(pa->pa_id) == 0x1229 && (rev == 8 || rev == 9))))
@


1.29
log
@- for the generic 82557 PCI ID also print the chip name if we have an 82558
or newer.
- rearrange PCI IDs a bit.
- eliminate setting the FXPF_HAS_RESUME_BUG flag now that we have support
to disable dynamic standby.

ok deraadt@@ mcbride@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.28 2004/08/04 19:42:30 mickey Exp $	*/
d102 1
@


1.28
log
@interrupt coalescing on post 82557 chips; from freebsd via Dmitry Bogdan <dsb@@poi.dvo.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.27 2004/06/27 02:38:38 brad Exp $	*/
d171 1
a171 3
	case PCI_PRODUCT_INTEL_82562:
		sc->sc_flags |= FXPF_HAS_RESUME_BUG;
		/* FALLTHROUGH */
d174 20
a195 9
	case PCI_PRODUCT_INTEL_82557:
		/*
		 * revisions
		 * 2 = 82557
		 * 4-6 = 82558
		 * 8 = 82559
		 */
		sc->not_82557 = (rev >= 4) ? 1 : 0;
		break;
a197 3
	case PCI_PRODUCT_INTEL_PRO_100_VE_2:
	case PCI_PRODUCT_INTEL_PRO_100_VE_3:
	case PCI_PRODUCT_INTEL_PRO_100_VE_4:
d201 8
a208 3
	case PCI_PRODUCT_INTEL_PRO_100_VM_3:
	case PCI_PRODUCT_INTEL_PRO_100_VM_4:
		sc->sc_flags |= FXPF_HAS_RESUME_BUG;
@


1.27
log
@stop passing an empty enaddr around since we figure out the
MAC address in the common attach code and not the PCI/CardBus
specific portions, this was a side effect of the code being
split to support CardBus.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.26 2004/05/18 22:37:25 beck Exp $	*/
d146 2
@


1.26
log
@fix from netbsd to twiddle the fxp eeprom to disable dynamic standby mode
on cards that have issues with this creating pci errors in 10 mbps mode
tested by many, including me, nick, and pval.
ok jason@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.25 2004/02/25 12:25:09 markus Exp $	*/
a136 1
	u_int8_t enaddr[6];
d226 1
a226 1
	if (fxp_attach_common(sc, enaddr, intrstr)) {
@


1.25
log
@more chipsets; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.24 2004/02/07 05:44:14 deraadt Exp $	*/
d203 17
@


1.24
log
@new fxp; cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.23 2004/01/09 21:32:24 brad Exp $	*/
d109 3
@


1.23
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.22 2003/12/23 16:44:35 mickey Exp $	*/
d101 1
@


1.22
log
@fix the error msg and enable bubs mastering
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.21 2003/09/29 19:29:22 mickey Exp $	*/
a65 2

#include <uvm/uvm_extern.h>
@


1.21
log
@use pci_mapreg_map() and free resources on failures
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.20 2003/06/13 17:49:03 deraadt Exp $	*/
d141 1
a141 1
		printf(": can't find i/o space\n");
a143 1

d201 5
@


1.20
log
@5 fxp versions (only way to find out of the HPNA versions work, is to put them in here)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.19 2003/04/11 20:51:52 millert Exp $	*/
a135 2
	bus_space_tag_t iot = pa->pa_iot;
	bus_addr_t iobase;
d139 2
a140 1
	if (pci_io_find(pc, pa->pa_tag, FXP_PCI_IOBA, &iobase, &iosize)) {
a144 5
	if (bus_space_map(iot, iobase, iosize, 0, &sc->sc_sh)) {
		printf(": can't map i/o space\n");
		return;
	}
	sc->sc_st = iot;
d152 1
d164 1
d206 2
@


1.19
log
@Match PCI_PRODUCT_INTEL_PRO_100_VE_4 and PCI_PRODUCT_INTEL_PRO_100_VM_4.
Assume these two need FXPF_HAS_RESUME_BUG.  If not, that can be changed
later.  PCI_PRODUCT_INTEL_PRO_100_VE_4 tested by Jan Johansson.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.18 2003/02/18 01:31:45 deraadt Exp $	*/
d94 3
d102 1
d108 1
@


1.18
log
@new fxp; cube@@cubidou.net
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.17 2002/11/26 16:14:49 jason Exp $	*/
d98 1
d103 1
d188 1
d193 1
@


1.17
log
@Match VE_3, too; Cliff Skolnick
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.16 2002/11/19 18:40:17 jason Exp $	*/
d102 1
@


1.16
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.15 2002/10/04 20:47:25 jason Exp $	*/
d97 1
d184 1
@


1.15
log
@Match INTEL PRO_100_VE_2, too; Chris Nadovich <chris@@jtan.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.14 2002/06/28 11:35:30 markus Exp $	*/
d89 14
d112 2
a113 21
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_INTEL)
		return (0);

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_INTEL_82557:
	case PCI_PRODUCT_INTEL_82559:
	case PCI_PRODUCT_INTEL_82559ER:
	case PCI_PRODUCT_INTEL_82562:
	case PCI_PRODUCT_INTEL_PRO_100_VE_0:
	case PCI_PRODUCT_INTEL_PRO_100_VE_1:
	case PCI_PRODUCT_INTEL_PRO_100_VE_2:
	case PCI_PRODUCT_INTEL_PRO_100_VM_0:
	case PCI_PRODUCT_INTEL_PRO_100_VM_1:
	case PCI_PRODUCT_INTEL_PRO_100_VM_2:
	case PCI_PRODUCT_INTEL_PRO_100_VM_3:
		return (1);
	}

	return (0);
@


1.14
log
@support for PCI_PRODUCT_INTEL_PRO_100_VM_3; ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.13 2002/05/31 08:46:00 mpech Exp $	*/
d110 1
d187 1
@


1.13
log
@Support for "Intel PRO/100 VM" w/ id 0x1038.

art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.12 2002/03/14 01:26:58 millert Exp $	*/
d113 1
d189 1
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.11 2001/11/06 19:53:19 miod Exp $	*/
d112 1
d187 1
@


1.11
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.10 2001/09/04 23:46:23 provos Exp $	*/
d82 2
a83 2
int fxp_pci_match __P((struct device *, void *, void *));
void fxp_pci_attach __P((struct device *, struct device *, void *));
@


1.11.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.11 2001/11/06 19:53:19 miod Exp $	*/
d82 2
a83 2
int fxp_pci_match(struct device *, void *, void *);
void fxp_pci_attach(struct device *, struct device *, void *);
a111 1
	case PCI_PRODUCT_INTEL_PRO_100_VM_2:
a185 1
	case PCI_PRODUCT_INTEL_PRO_100_VM_2:
@


1.11.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.11.2.1 2002/06/11 03:42:25 art Exp $	*/
a109 1
	case PCI_PRODUCT_INTEL_PRO_100_VE_2:
a112 1
	case PCI_PRODUCT_INTEL_PRO_100_VM_3:
a184 1
	case PCI_PRODUCT_INTEL_PRO_100_VE_2:
a187 1
	case PCI_PRODUCT_INTEL_PRO_100_VM_3:
@


1.11.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a88 18
const struct pci_matchid fxp_pci_devices[] = {
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82557 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82559 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82559ER },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82562 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_0 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_3 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_4 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_0 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_3 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_4 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_M },
};

d98 21
a118 2
	return (pci_matchbyid((struct pci_attach_args *)aux, fxp_pci_devices,
	    sizeof(fxp_pci_devices)/sizeof(fxp_pci_devices[0])));
a187 2
	case PCI_PRODUCT_INTEL_PRO_100_VE_3:
	case PCI_PRODUCT_INTEL_PRO_100_VE_4:
a191 1
	case PCI_PRODUCT_INTEL_PRO_100_VM_4:
@


1.10
log
@recognize intel pro/100 cards; okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.9 2001/08/25 10:13:29 art Exp $	*/
d67 1
a67 1
#include <vm/vm.h>
@


1.9
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.8 2001/08/09 21:12:51 jason Exp $	*/
d108 4
d181 7
@


1.8
log
@- scb_wait() is now time based (not cpu speed based)
- rearrange multicast setup to be part of init
- convert cu operations to bus_dma(9) (still have to do RFA ops).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.7 2001/08/03 23:28:49 chris Exp $	*/
d145 1
a145 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.7
log
@Fix logic for detecting 82558 and newer chips in pci;
This driver allows large frames for those chips so set IFCAP_VLAN_MTU
for 82558+
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.6 2001/06/13 23:19:16 jason Exp $	*/
d140 1
@


1.6
log
@From NetBSD, 82562 requires a nop before a resume (tested by mickey)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.5 2000/12/29 14:03:01 art Exp $	*/
d164 3
d169 1
a169 1
	default:
d177 3
@


1.5
log
@Revision 5 is 82559B.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.4 2000/09/25 21:03:15 aaron Exp $	*/
a60 15
#ifdef IPX
#include <netipx/ipx.h>
#include <netipx/ipx_if.h>
#endif

#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

#if NBPFILTER > 0
#include <net/bpf.h>
#include <net/bpfdesc.h>
#endif

d161 15
a175 7
	/*
	 * revisions
	 * 2 = 82557
	 * 4-6 = 82558
	 * 8 = 82559
	 */
	sc->not_82557 = (rev >= 4) ? 1 : 0;
@


1.5.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.5 2000/12/29 14:03:01 art Exp $	*/
@


1.5.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.5.4.1 2001/05/14 22:25:45 niklas Exp $	*/
d61 15
d176 7
a182 15
	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_INTEL_82562:
		sc->sc_flags |= FXPF_HAS_RESUME_BUG;
		sc->not_82557 = 1;
		break;
	default:
		/*
		 * revisions
		 * 2 = 82557
		 * 4-6 = 82558
		 * 8 = 82559
		 */
		sc->not_82557 = (rev >= 4) ? 1 : 0;
		break;
	}
@


1.5.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.5.4.2 2001/07/04 10:42:13 niklas Exp $	*/
a107 4
	case PCI_PRODUCT_INTEL_PRO_100_VE_0:
	case PCI_PRODUCT_INTEL_PRO_100_VE_1:
	case PCI_PRODUCT_INTEL_PRO_100_VM_0:
	case PCI_PRODUCT_INTEL_PRO_100_VM_1:
a139 1
	sc->sc_dmat = pa->pa_dmat;
d144 2
a145 1
	if (pci_intr_map(pa, &ih)) {
a163 3
		/* FALLTHROUGH */
	case PCI_PRODUCT_INTEL_82559:
	case PCI_PRODUCT_INTEL_82559ER:
d166 1
a166 1
	case PCI_PRODUCT_INTEL_82557:
a173 10
		break;
	case PCI_PRODUCT_INTEL_PRO_100_VE_0:
	case PCI_PRODUCT_INTEL_PRO_100_VE_1:
	case PCI_PRODUCT_INTEL_PRO_100_VM_0:
	case PCI_PRODUCT_INTEL_PRO_100_VM_1:
		sc->sc_flags |= FXPF_HAS_RESUME_BUG;
		sc->not_82557 = 0;
		break;
	default:
		sc->not_82557 = 0;
@


1.5.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d67 1
a67 1
#include <uvm/uvm_extern.h>
@


1.5.4.5
log
@Merge in -current from roughly a week ago
@
text
@d82 2
a83 2
int fxp_pci_match(struct device *, void *, void *);
void fxp_pci_attach(struct device *, struct device *, void *);
@


1.5.4.6
log
@Sync the SMP branch with 3.3
@
text
@a88 16
const struct pci_matchid fxp_pci_devices[] = {
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82557 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82559 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82559ER },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82562 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_0 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_3 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_0 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_3 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_M },
};

d98 18
a115 2
	return (pci_matchbyid((struct pci_attach_args *)aux, fxp_pci_devices,
	    sizeof(fxp_pci_devices)/sizeof(fxp_pci_devices[0])));
a183 2
	case PCI_PRODUCT_INTEL_PRO_100_VE_2:
	case PCI_PRODUCT_INTEL_PRO_100_VE_3:
a185 2
	case PCI_PRODUCT_INTEL_PRO_100_VM_2:
	case PCI_PRODUCT_INTEL_PRO_100_VM_3:
@


1.5.4.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.5.4.6 2003/03/28 00:38:22 niklas Exp $	*/
a97 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_4 },
a101 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_4 },
a185 1
	case PCI_PRODUCT_INTEL_PRO_100_VE_4:
a189 1
	case PCI_PRODUCT_INTEL_PRO_100_VM_4:
@


1.5.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d67 2
a93 3
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82562EH_HPNA_0 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82562EH_HPNA_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82562EH_HPNA_2 },
a98 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_5 },
a103 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VM_5 },
d131 2
d136 6
a141 2
	if (pci_mapreg_map(pa, FXP_PCI_IOBA, PCI_MAPREG_TYPE_IO, 0,
	    &sc->sc_st, &sc->sc_sh, NULL, &iosize, 0)) {
d145 1
a152 1
		bus_space_unmap(sc->sc_st, sc->sc_sh, iosize);
a163 1
		bus_space_unmap(sc->sc_st, sc->sc_sh, iosize);
a201 5
	/* enable bus mastering */
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    PCI_COMMAND_MASTER_ENABLE |
	    pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG));

a204 2
		pci_intr_disestablish(pc, sc->sc_ih);
		bus_space_unmap(sc->sc_st, sc->sc_sh, iosize);
@


1.5.4.9
log
@Merge with the trunk
@
text
@a100 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100_VE_6 },
a107 3
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_100 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801E_LAN_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801E_LAN_2 },
a198 17

	/*
	 * Cards for which we should WRITE TO THE EEPROM
	 * to turn off dynamic standby mode to avoid
	 * a problem where the card will fail to resume when
	 * entering the IDLE state. We use this nasty if statement
	 * and corresponding pci dev numbers directly so that people
	 * know not to add new cards to this unless you are really
	 * certain what you are doing and are not going to end up
	 * killing people's eeproms.
	 */
	if ((PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL) &&
	    (PCI_PRODUCT(pa->pa_id) == 0x2449 || 
	    (PCI_PRODUCT(pa->pa_id) > 0x1030 && 
	    PCI_PRODUCT(pa->pa_id) < 0x1039) || 
	    (PCI_PRODUCT(pa->pa_id) == 0x1229 && (rev == 8 || rev == 9))))
		sc->sc_flags |= FXPF_DISABLE_STANDBY;
@


1.4
log
@Support the i82562; from FreeBSD. Apparently nothing more needed than to match
its PCI device ID.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.3 2000/06/18 15:27:54 deraadt Exp $	*/
d179 1
a179 1
	 * 4, 6 = 82558
@


1.3
log
@match 82559ER
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.2 2000/04/26 19:12:08 chris Exp $	*/
d122 1
@


1.2
log
@Turn on a bit (for 82558/82559 only) which disables the chip's
builin feature to discard frames >1500 bytes (useful for jumbo frames,
also 802.1Q VLANs)

ok aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fxp_pci.c,v 1.1 2000/04/18 18:44:31 jason Exp $	*/
d121 1
@


1.1
log
@split fxp into bus independent and dependent (pci) parts (cardbus to come)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d141 1
d173 8
@

