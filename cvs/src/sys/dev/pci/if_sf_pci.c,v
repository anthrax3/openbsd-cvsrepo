head	1.14;
access;
symbols
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.8
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.6
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.4
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.4
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.8.0.6
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.4
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.12
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.10
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.6
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.8
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.2.0.4
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.13;
commitid	5gdEnqVoJuTuwdTu;

1.13
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.12;
commitid	5DvsamK0GblTp8ww;

1.12
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.11;
commitid	yM2VFFhpDTeFQlve;

1.11
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.10;
commitid	TGHgrLxu6sxZoiFt;

1.10
date	2013.08.07.01.06.37;	author bluhm;	state Exp;
branches;
next	1.9;

1.9
date	2012.10.18.21.44.21;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.25.00.37.40;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.29.12.20.32;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.22.23.00.45;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.22.03.16.35;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.06.22.43.38;	author martin;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.06.20.07.52;	author martin;	state Exp;
branches;
next	;


desc
@@


1.14
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_sf_pci.c,v 1.13 2015/11/24 13:33:17 mpi Exp $	*/
/*	$NetBSD: if_sf_pci.c,v 1.10 2006/06/17 23:34:27 christos Exp $	*/

/*-
 * Copyright (c) 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * PCI bus front-end for the Adaptec AIC-6915 (``Starfire'')
 * 10/100 Ethernet controller.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/device.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net/if_media.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/mii/miivar.h>

#include <dev/ic/aic6915.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

struct sf_pci_softc {
	struct sf_softc sc_starfire;	/* read Starfire softc */

	/* PCI-specific goo. */
	void	*sc_ih;			/* interrupt handle */
};

int	sf_pci_match(struct device *, void *, void *);
void	sf_pci_attach(struct device *, struct device *, void *);

struct cfattach sf_pci_ca = {
        sizeof(struct sf_pci_softc), sf_pci_match, sf_pci_attach
};

const struct pci_matchid sf_pci_products[] = {
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC6915 },
};

int
sf_pci_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, sf_pci_products,
	    nitems(sf_pci_products)));
}

void
sf_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct sf_pci_softc *psc = (void *) self;
	struct sf_softc *sc = &psc->sc_starfire;
	struct pci_attach_args *pa = aux;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
	bus_space_tag_t iot, memt;
	bus_space_handle_t ioh, memh;
	int ioh_valid, memh_valid;
	bus_size_t iosize, memsize;
	pcireg_t reg;

	pci_set_powerstate(pa->pa_pc, pa->pa_tag, PCI_PMCSR_STATE_D0);

	/*
	 * Map the device.
	 */
	reg = pci_mapreg_type(pa->pa_pc, pa->pa_tag, SF_PCI_MEMBA);
	switch (reg) {
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
		memh_valid = (pci_mapreg_map(pa, SF_PCI_MEMBA,
		    reg, 0, &memt, &memh, &memsize, NULL, 0) == 0);
		break;
	default:
		memh_valid = 0;
	}

	ioh_valid = (pci_mapreg_map(pa,
	    (reg == (PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT)) ?
		SF_PCI_IOBA : SF_PCI_IOBA - 0x04,
	    PCI_MAPREG_TYPE_IO, 0,
	    &iot, &ioh, &iosize, NULL, 0) == 0);

	if (memh_valid) {
		sc->sc_st = memt;
		sc->sc_sh = memh;
		sc->sc_iomapped = 0;
	} else if (ioh_valid) {
		sc->sc_st = iot;
		sc->sc_sh = ioh;
		sc->sc_iomapped = 1;
	} else {
		printf(": unable to map device registers\n");
		return;
	}

	sc->sc_dmat = pa->pa_dmat;

	/*
	 * Map and establish our interrupt.
	 */
	if (pci_intr_map(pa, &ih)) {
		printf(": unable to map interrupt\n");
		goto out;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	psc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_NET, sf_intr, sc,
	    self->dv_xname);
	if (psc->sc_ih == NULL) {
		printf(": unable to establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto out;
	}
	printf(": %s", intrstr);

	/*
	 * Finish off the attach.
	 */
	sf_attach(sc);
	return;

 out:
	if (ioh_valid)
		bus_space_unmap(iot, ioh, iosize);
	if (memh_valid)
		bus_space_unmap(memt, memh, memsize);
}
@


1.13
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf_pci.c,v 1.12 2014/12/22 02:28:52 tedu Exp $	*/
a48 1
#include <net/if_dl.h>
@


1.12
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf_pci.c,v 1.11 2014/07/22 13:12:11 mpi Exp $	*/
a49 1
#include <net/if_types.h>
@


1.11
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf_pci.c,v 1.10 2013/08/07 01:06:37 bluhm Exp $	*/
a51 1
#ifdef INET
a53 1
#endif
@


1.10
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf_pci.c,v 1.9 2012/10/18 21:44:21 deraadt Exp $	*/
a53 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.9
log
@Convert a number of old private copies of code which predates
pci_set_powerstate() to using it instead.  Many of these chunks of code had
bugs in them, especially missing delay() calls.  Some of them were doing
things our PCI subsystem is now responsible for handling.  If you have
any of the affected devices, please keep an eye out for regressions.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf_pci.c,v 1.8 2011/04/03 15:36:02 jasper Exp $	*/
a54 1
#include <netinet/in_var.h>
@


1.8
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf_pci.c,v 1.7 2008/06/26 05:42:17 ray Exp $	*/
d108 1
a108 1
	int state, ioh_valid, memh_valid;
d112 1
a112 6
	state = pci_set_powerstate(pa->pa_pc, pa->pa_tag, PCI_PMCSR_STATE_D0);
	if (state == PCI_PMCSR_STATE_D3) {
		printf(": unable to wake up from power state D3, "
		    "reboot required.\n");
		return;
	}
@


1.7
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf_pci.c,v 1.6 2008/05/25 00:37:40 brad Exp $	*/
d95 1
a95 1
	    sizeof(sf_pci_products)/sizeof(sf_pci_products[0])));
@


1.6
log
@Remove redundant enabling of bus master which pci_mapreg_map() deals
with.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf_pci.c,v 1.5 2007/10/29 12:20:32 fgsch Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.5
log
@unmap on error and correct some output in those cases.
martin@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf_pci.c,v 1.4 2007/10/22 23:00:45 fgsch Exp $	*/
a159 5

	/* Make sure bus mastering is enabled. */
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG) |
	    PCI_COMMAND_MASTER_ENABLE);
@


1.4
log
@only output on situations where power state is D3. unify the message in
such cases. ok brad@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf_pci.c,v 1.3 2007/10/22 03:16:35 fgsch Exp $	*/
d116 1
d134 1
a134 1
		    reg, 0, &memt, &memh, NULL, NULL, 0) == 0);
d144 1
a144 1
	    &iot, &ioh, NULL, NULL, 0) == 0);
d155 1
a155 2
		printf("%s: unable to map device registers\n",
		    sc->sc_dev.dv_xname);
d170 2
a171 2
		printf("%s: unable to map interrupt\n", sc->sc_dev.dv_xname);
		return;
d177 1
a177 2
		printf("%s: unable to establish interrupt",
		    sc->sc_dev.dv_xname);
d180 2
a181 1
		return;
d189 7
@


1.3
log
@Use pci_set_powerstate(), shrinking the code and unifying the different
versions. ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf_pci.c,v 1.2 2006/12/06 22:43:38 martin Exp $	*/
d119 4
a122 9
	if (state != PCI_PMCSR_STATE_D0) {
		if (state == PCI_PMCSR_STATE_D3) {
			printf("%s: unable to wake up from power state D3\n",
			    sc->sc_dev.dv_xname);
			return;
		} else {
			printf(": waking up from power state D%d\n%s",
			    state, sc->sc_dev.dv_xname);
		}
@


1.2
log
@- de-static
- use pci_matchbyid, makes attaching way simpler

ok brad@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sf_pci.c,v 1.1 2006/12/06 20:07:52 martin Exp $	*/
d115 1
a116 1
	int pmreg, ioh_valid, memh_valid;
d118 3
a120 14
	if (pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_PWRMGMT,
	    &pmreg, 0)) {
		reg = pci_conf_read(pa->pa_pc, pa->pa_tag, pmreg + PCI_PMCSR);
		switch (reg & PCI_PMCSR_STATE_MASK) {
		case PCI_PMCSR_STATE_D1:
		case PCI_PMCSR_STATE_D2:
			printf(": waking up from power state D%d\n%s",
			    reg & PCI_PMCSR_STATE_MASK, sc->sc_dev.dv_xname);
			pci_conf_write(pa->pa_pc, pa->pa_tag, pmreg + PCI_PMCSR,
			    (reg & ~PCI_PMCSR_STATE_MASK) |
			    PCI_PMCSR_STATE_D0);
			break;

		case PCI_PMCSR_STATE_D3:
a122 3
			pci_conf_write(pa->pa_pc, pa->pa_tag, pmreg + PCI_PMCSR,
			    (reg & ~PCI_PMCSR_STATE_MASK) |
			    PCI_PMCSR_STATE_D0);
d124 3
@


1.1
log
@replace Adaptec AIC-6915 Starfire driver with the fully bus_dma(9)-able
driver from NetBSD

ok brad@@ reyk@@

additional testing Nick Nauwelaerts
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d87 2
a88 2
static int	sf_pci_match(struct device *, void *, void *);
static void	sf_pci_attach(struct device *, struct device *, void *);
d94 2
a95 5
struct sf_pci_product {
	uint32_t	spp_vendor;	/* PCI vendor ID */
	uint32_t	spp_product;	/* PCI product ID */
	const char	*spp_name;	/* product name */
	const struct sf_pci_product *spp_subsys; /* subsystm IDs */
d98 1
a98 69
static const struct sf_pci_product sf_subsys_adaptec[] = {
	/* ANA-62011 (rev 0) Single port 10/100 64-bit */
	{ PCI_VENDOR_ADP,			0x0008,
	  "ANA-62011 (rev 0) 10/100 Ethernet",	NULL },

	/* ANA-62011 (rev 1) Single port 10/100 64-bit */
	{ PCI_VENDOR_ADP,			0x0009,
	  "ANA-62011 (rev 1) 10/100 Ethernet",	NULL },

	/* ANA-62022 Dual port 10/100 64-bit */
	{ PCI_VENDOR_ADP,			0x0010,
	  "ANA-62022 10/100 Ethernet",		NULL },

	/* ANA-62044 (rev 0) Quad port 10/100 64-bit */
	{ PCI_VENDOR_ADP,			0x0018,
	  "ANA-62044 (rev 0) 10/100 Ethernet",	NULL },

	/* ANA-62044 (rev 1) Quad port 10/100 64-bit */
	{ PCI_VENDOR_ADP,			0x0019,
	  "ANA-62044 (rev 1) 10/100 Ethernet",	NULL },

	/* ANA-62020 Single port 100baseFX 64-bit */
	{ PCI_VENDOR_ADP,			0x0020,
	  "ANA-62020 100baseFX Ethernet",	NULL },

	/* ANA-69011 Single port 10/100 32-bit */
	{ PCI_VENDOR_ADP,			0x0028,
	  "ANA-69011 10/100 Ethernet",		NULL },

	{ 0, 					0,
	  NULL,					NULL },
};

static const struct sf_pci_product sf_pci_products[] = {
	{ PCI_VENDOR_ADP,			PCI_PRODUCT_ADP_AIC6915,
	  "AIC-6915 10/100 Ethernet",		sf_subsys_adaptec },

	{ 0,					0,
	  NULL,					NULL },
};

static const struct sf_pci_product *
sf_pci_lookup(const struct pci_attach_args *pa)
{
	const struct sf_pci_product *spp, *subspp;
	pcireg_t subsysid;

	for (spp = sf_pci_products; spp->spp_name != NULL; spp++) {
		if (PCI_VENDOR(pa->pa_id) == spp->spp_vendor &&
		    PCI_PRODUCT(pa->pa_id) == spp->spp_product) {
			subsysid = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    PCI_SUBSYS_ID_REG);
			for (subspp = spp->spp_subsys;
			     subspp->spp_name != NULL; subspp++) {
				if (PCI_VENDOR(subsysid) ==
					subspp->spp_vendor ||
				    PCI_PRODUCT(subsysid) ==
					subspp->spp_product) {
					return (subspp);
				}
			}
			return (spp);
		}
	}

	return (NULL);
}

static int
d101 2
a102 6
	struct pci_attach_args *pa = aux;

	if (sf_pci_lookup(pa) != NULL)
		return (1);

	return (0);
d105 1
a105 1
static void
a112 1
	const struct sf_pci_product *spp;
a116 8

	spp = sf_pci_lookup(pa);
	if (spp == NULL) {
		printf("\n");
		panic("sf_pci_attach: impossible");
	}

	printf(": %s, rev. %d", spp->spp_name, PCI_REVISION(pa->pa_class));
@

