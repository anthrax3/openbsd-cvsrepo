head	1.177;
access;
symbols
	OPENBSD_6_2:1.177.0.2
	OPENBSD_6_2_BASE:1.177
	OPENBSD_6_1:1.177.0.4
	OPENBSD_6_1_BASE:1.177
	OPENBSD_6_0:1.174.0.6
	OPENBSD_6_0_BASE:1.174
	OPENBSD_5_9:1.174.0.2
	OPENBSD_5_9_BASE:1.174
	OPENBSD_5_8:1.170.0.4
	OPENBSD_5_8_BASE:1.170
	OPENBSD_5_7:1.169.0.6
	OPENBSD_5_7_BASE:1.169
	OPENBSD_5_6:1.169.0.4
	OPENBSD_5_6_BASE:1.169
	OPENBSD_5_5:1.167.0.12
	OPENBSD_5_5_BASE:1.167
	OPENBSD_5_4:1.167.0.8
	OPENBSD_5_4_BASE:1.167
	OPENBSD_5_3:1.167.0.6
	OPENBSD_5_3_BASE:1.167
	OPENBSD_5_2:1.167.0.4
	OPENBSD_5_2_BASE:1.167
	OPENBSD_5_1_BASE:1.167
	OPENBSD_5_1:1.167.0.2
	OPENBSD_5_0:1.166.0.2
	OPENBSD_5_0_BASE:1.166
	OPENBSD_4_9:1.164.0.2
	OPENBSD_4_9_BASE:1.164
	OPENBSD_4_8:1.162.0.2
	OPENBSD_4_8_BASE:1.162
	OPENBSD_4_7:1.158.0.2
	OPENBSD_4_7_BASE:1.158
	OPENBSD_4_6:1.157.0.6
	OPENBSD_4_6_BASE:1.157
	OPENBSD_4_5:1.157.0.2
	OPENBSD_4_5_BASE:1.157
	OPENBSD_4_4:1.155.0.2
	OPENBSD_4_4_BASE:1.155
	OPENBSD_4_3:1.154.0.2
	OPENBSD_4_3_BASE:1.154
	OPENBSD_4_2:1.152.0.6
	OPENBSD_4_2_BASE:1.152
	OPENBSD_4_1:1.152.0.4
	OPENBSD_4_1_BASE:1.152
	OPENBSD_4_0:1.152.0.2
	OPENBSD_4_0_BASE:1.152
	OPENBSD_3_9:1.151.0.2
	OPENBSD_3_9_BASE:1.151
	OPENBSD_3_8:1.149.0.6
	OPENBSD_3_8_BASE:1.149
	OPENBSD_3_7:1.149.0.4
	OPENBSD_3_7_BASE:1.149
	OPENBSD_3_6:1.149.0.2
	OPENBSD_3_6_BASE:1.149
	SMP_SYNC_A:1.148
	SMP_SYNC_B:1.148
	OPENBSD_3_5:1.148.0.2
	OPENBSD_3_5_BASE:1.148
	OPENBSD_3_4:1.141.0.2
	OPENBSD_3_4_BASE:1.141
	UBC_SYNC_A:1.139
	OPENBSD_3_3:1.139.0.2
	OPENBSD_3_3_BASE:1.139
	OPENBSD_3_2:1.132.0.2
	OPENBSD_3_2_BASE:1.132
	OPENBSD_3_1:1.116.0.2
	OPENBSD_3_1_BASE:1.116
	UBC_SYNC_B:1.132
	UBC:1.110.0.2
	UBC_BASE:1.110
	OPENBSD_3_0:1.103.0.2
	OPENBSD_3_0_BASE:1.103
	OPENBSD_2_9_BASE:1.57
	OPENBSD_2_9:1.57.0.2
	OPENBSD_2_8:1.51.0.2
	OPENBSD_2_8_BASE:1.51
	OPENBSD_2_7:1.38.0.2
	OPENBSD_2_7_BASE:1.38
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.4;
locks; strict;
comment	@ * @;


1.177
date	2017.02.07.17.25.46;	author patrick;	state Exp;
branches;
next	1.176;
commitid	dMJlqKWYCJoMV7JN;

1.176
date	2017.01.19.10.20.29;	author jsg;	state Exp;
branches;
next	1.175;
commitid	XsTQMwWxml82SYWa;

1.175
date	2016.11.29.10.22.30;	author jsg;	state Exp;
branches;
next	1.174;
commitid	ZQetSMB5ilG2z10X;

1.174
date	2015.12.10.21.00.51;	author naddy;	state Exp;
branches;
next	1.173;
commitid	T0HbsCFlrwPATHlH;

1.173
date	2015.11.13.15.29.55;	author naddy;	state Exp;
branches;
next	1.172;
commitid	kI77GdyYKaka3fwk;

1.172
date	2015.11.13.12.21.16;	author mikeb;	state Exp;
branches;
next	1.171;
commitid	YLaQcqVfNSwoLvqJ;

1.171
date	2015.09.10.18.10.34;	author deraadt;	state Exp;
branches;
next	1.170;
commitid	pbNNrPaFfPV40pxN;

1.170
date	2015.05.12.12.56.47;	author mikeb;	state Exp;
branches;
next	1.169;
commitid	HunUjwFm6j89ocWR;

1.169
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.168;
commitid	JtO5uXxVcnZfhUkR;

1.168
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.167;
commitid	OBNa5kfxQ2UXoiIw;

1.167
date	2012.01.13.09.53.24;	author mikeb;	state Exp;
branches;
next	1.166;

1.166
date	2011.04.05.11.48.28;	author blambert;	state Exp;
branches;
next	1.165;

1.165
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.164;

1.164
date	2011.01.12.20.55.22;	author deraadt;	state Exp;
branches;
next	1.163;

1.163
date	2010.12.15.23.34.23;	author mikeb;	state Exp;
branches;
next	1.162;

1.162
date	2010.07.05.11.07.56;	author blambert;	state Exp;
branches
	1.162.2.1;
next	1.161;

1.161
date	2010.07.02.02.40.16;	author blambert;	state Exp;
branches;
next	1.160;

1.160
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.159;

1.159
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.158;

1.158
date	2009.09.13.14.42.52;	author krw;	state Exp;
branches
	1.158.2.1;
next	1.157;

1.157
date	2008.09.25.17.55.28;	author chl;	state Exp;
branches;
next	1.156;

1.156
date	2008.08.31.09.50.12;	author jsg;	state Exp;
branches;
next	1.155;

1.155
date	2008.06.09.07.07.16;	author djm;	state Exp;
branches;
next	1.154;

1.154
date	2007.10.01.15.34.48;	author krw;	state Exp;
branches;
next	1.153;

1.153
date	2007.09.18.22.02.18;	author djm;	state Exp;
branches;
next	1.152;

1.152
date	2006.06.29.21.34.51;	author deraadt;	state Exp;
branches;
next	1.151;

1.151
date	2006.01.04.00.02.29;	author brad;	state Exp;
branches;
next	1.150;

1.150
date	2005.11.29.00.03.08;	author deraadt;	state Exp;
branches;
next	1.149;

1.149
date	2004.08.12.18.10.12;	author jason;	state Exp;
branches;
next	1.148;

1.148
date	2004.03.14.23.26.11;	author hshoexer;	state Exp;
branches;
next	1.147;

1.147
date	2004.02.03.17.17.33;	author deraadt;	state Exp;
branches;
next	1.146;

1.146
date	2004.01.20.21.01.55;	author jason;	state Exp;
branches;
next	1.145;

1.145
date	2004.01.09.21.32.24;	author brad;	state Exp;
branches;
next	1.144;

1.144
date	2003.10.09.03.47.20;	author jason;	state Exp;
branches;
next	1.143;

1.143
date	2003.09.25.15.40.54;	author jason;	state Exp;
branches;
next	1.142;

1.142
date	2003.09.24.05.23.29;	author jason;	state Exp;
branches;
next	1.141;

1.141
date	2003.08.14.15.20.29;	author jason;	state Exp;
branches;
next	1.140;

1.140
date	2003.08.01.17.55.54;	author deraadt;	state Exp;
branches;
next	1.139;

1.139
date	2003.03.13.20.08.06;	author jason;	state Exp;
branches;
next	1.138;

1.138
date	2003.02.24.20.36.02;	author jason;	state Exp;
branches;
next	1.137;

1.137
date	2003.02.17.16.48.22;	author jason;	state Exp;
branches;
next	1.136;

1.136
date	2003.02.15.23.39.12;	author jason;	state Exp;
branches;
next	1.135;

1.135
date	2002.11.26.00.42.53;	author jason;	state Exp;
branches;
next	1.134;

1.134
date	2002.11.21.19.34.25;	author jason;	state Exp;
branches;
next	1.133;

1.133
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.132;

1.132
date	2002.08.01.18.29.59;	author jason;	state Exp;
branches;
next	1.131;

1.131
date	2002.07.29.05.45.28;	author jason;	state Exp;
branches;
next	1.130;

1.130
date	2002.07.25.15.27.20;	author jason;	state Exp;
branches;
next	1.129;

1.129
date	2002.07.23.19.25.09;	author jason;	state Exp;
branches;
next	1.128;

1.128
date	2002.07.23.17.53.46;	author jason;	state Exp;
branches;
next	1.127;

1.127
date	2002.07.23.17.50.33;	author jason;	state Exp;
branches;
next	1.126;

1.126
date	2002.07.22.18.05.10;	author jason;	state Exp;
branches;
next	1.125;

1.125
date	2002.07.21.19.55.33;	author jason;	state Exp;
branches;
next	1.124;

1.124
date	2002.07.21.19.08.26;	author jason;	state Exp;
branches;
next	1.123;

1.123
date	2002.07.16.21.27.39;	author jason;	state Exp;
branches;
next	1.122;

1.122
date	2002.07.05.21.21.17;	author jason;	state Exp;
branches;
next	1.121;

1.121
date	2002.07.05.21.03.46;	author jason;	state Exp;
branches;
next	1.120;

1.120
date	2002.05.17.00.33.34;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2002.05.07.20.37.24;	author jason;	state Exp;
branches;
next	1.118;

1.118
date	2002.04.30.16.03.19;	author jason;	state Exp;
branches;
next	1.117;

1.117
date	2002.04.29.15.41.21;	author jason;	state Exp;
branches;
next	1.116;

1.116
date	2002.04.08.17.49.42;	author jason;	state Exp;
branches;
next	1.115;

1.115
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.114;

1.114
date	2002.01.31.21.17.37;	author jason;	state Exp;
branches;
next	1.113;

1.113
date	2002.01.23.15.59.12;	author jason;	state Exp;
branches;
next	1.112;

1.112
date	2002.01.09.01.53.39;	author jason;	state Exp;
branches;
next	1.111;

1.111
date	2002.01.08.23.17.24;	author jason;	state Exp;
branches;
next	1.110;

1.110
date	2001.11.14.00.14.47;	author jason;	state Exp;
branches
	1.110.2.1;
next	1.109;

1.109
date	2001.11.12.19.32.23;	author jason;	state Exp;
branches;
next	1.108;

1.108
date	2001.11.12.18.04.06;	author jason;	state Exp;
branches;
next	1.107;

1.107
date	2001.11.09.03.11.38;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches;
next	1.105;

1.105
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.104;

1.104
date	2001.11.04.18.31.42;	author jason;	state Exp;
branches;
next	1.103;

1.103
date	2001.09.06.03.31.34;	author jason;	state Exp;
branches
	1.103.2.1;
next	1.102;

1.102
date	2001.08.28.21.40.54;	author jason;	state Exp;
branches;
next	1.101;

1.101
date	2001.08.28.18.52.16;	author jason;	state Exp;
branches;
next	1.100;

1.100
date	2001.08.27.21.57.52;	author jason;	state Exp;
branches;
next	1.99;

1.99
date	2001.08.27.18.54.56;	author jason;	state Exp;
branches;
next	1.98;

1.98
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.97;

1.97
date	2001.08.22.16.34.47;	author jason;	state Exp;
branches;
next	1.96;

1.96
date	2001.08.22.16.11.31;	author jason;	state Exp;
branches;
next	1.95;

1.95
date	2001.08.22.05.15.25;	author jason;	state Exp;
branches;
next	1.94;

1.94
date	2001.08.17.17.37.12;	author ben;	state Exp;
branches;
next	1.93;

1.93
date	2001.08.15.16.59.00;	author jason;	state Exp;
branches;
next	1.92;

1.92
date	2001.08.12.20.03.48;	author mickey;	state Exp;
branches;
next	1.91;

1.91
date	2001.08.11.06.40.35;	author jason;	state Exp;
branches;
next	1.90;

1.90
date	2001.08.08.03.46.44;	author jason;	state Exp;
branches;
next	1.89;

1.89
date	2001.08.08.03.11.46;	author jason;	state Exp;
branches;
next	1.88;

1.88
date	2001.07.21.03.08.57;	author jason;	state Exp;
branches;
next	1.87;

1.87
date	2001.07.20.14.21.58;	author jason;	state Exp;
branches;
next	1.86;

1.86
date	2001.07.18.15.49.29;	author jason;	state Exp;
branches;
next	1.85;

1.85
date	2001.07.16.14.42.16;	author jason;	state Exp;
branches;
next	1.84;

1.84
date	2001.07.16.05.02.10;	author jason;	state Exp;
branches;
next	1.83;

1.83
date	2001.07.08.18.05.41;	author brad;	state Exp;
branches;
next	1.82;

1.82
date	2001.06.25.19.49.14;	author jason;	state Exp;
branches;
next	1.81;

1.81
date	2001.06.24.19.31.49;	author jason;	state Exp;
branches;
next	1.80;

1.80
date	2001.06.24.17.43.28;	author jason;	state Exp;
branches;
next	1.79;

1.79
date	2001.06.24.16.30.59;	author jason;	state Exp;
branches;
next	1.78;

1.78
date	2001.06.23.23.01.08;	author angelos;	state Exp;
branches;
next	1.77;

1.77
date	2001.06.23.22.02.53;	author angelos;	state Exp;
branches;
next	1.76;

1.76
date	2001.06.23.21.43.40;	author jason;	state Exp;
branches;
next	1.75;

1.75
date	2001.06.23.20.59.41;	author angelos;	state Exp;
branches;
next	1.74;

1.74
date	2001.06.23.20.20.32;	author jason;	state Exp;
branches;
next	1.73;

1.73
date	2001.06.23.18.30.37;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2001.06.23.00.25.37;	author jason;	state Exp;
branches;
next	1.71;

1.71
date	2001.06.22.23.53.52;	author jason;	state Exp;
branches;
next	1.70;

1.70
date	2001.06.22.19.02.44;	author jason;	state Exp;
branches;
next	1.69;

1.69
date	2001.06.14.23.55.02;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2001.06.14.23.51.58;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2001.06.14.23.51.18;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2001.06.12.15.40.31;	author niklas;	state Exp;
branches;
next	1.65;

1.65
date	2001.05.14.22.29.28;	author jason;	state Exp;
branches;
next	1.64;

1.64
date	2001.05.14.03.07.06;	author jason;	state Exp;
branches;
next	1.63;

1.63
date	2001.05.14.02.45.19;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2001.05.13.23.39.53;	author jason;	state Exp;
branches;
next	1.61;

1.61
date	2001.05.13.15.53.22;	author jason;	state Exp;
branches;
next	1.60;

1.60
date	2001.05.13.15.39.27;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2001.05.11.15.01.15;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2001.05.08.20.41.00;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2001.04.06.16.27.46;	author jason;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2001.03.28.20.02.59;	author angelos;	state Exp;
branches;
next	1.55;

1.55
date	2001.02.18.18.29.27;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2001.01.31.05.14.02;	author jason;	state Exp;
branches;
next	1.53;

1.53
date	2000.11.22.17.51.14;	author mickey;	state Exp;
branches;
next	1.52;

1.52
date	2000.11.17.05.18.41;	author angelos;	state Exp;
branches;
next	1.51;

1.51
date	2000.10.26.00.41.25;	author jason;	state Exp;
branches;
next	1.50;

1.50
date	2000.10.24.21.05.10;	author jason;	state Exp;
branches;
next	1.49;

1.49
date	2000.10.23.21.22.42;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2000.10.13.04.34.13;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2000.10.11.13.15.41;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2000.08.15.14.22.44;	author jason;	state Exp;
branches;
next	1.45;

1.45
date	2000.08.13.21.17.38;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2000.07.28.19.59.11;	author jason;	state Exp;
branches;
next	1.43;

1.43
date	2000.06.20.05.40.44;	author jason;	state Exp;
branches;
next	1.42;

1.42
date	2000.06.17.20.34.52;	author jason;	state Exp;
branches;
next	1.41;

1.41
date	2000.06.13.05.04.59;	author jason;	state Exp;
branches;
next	1.40;

1.40
date	2000.06.13.02.22.50;	author jason;	state Exp;
branches;
next	1.39;

1.39
date	2000.06.02.22.36.44;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2000.05.04.02.23.16;	author jason;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2000.04.25.06.03.46;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2000.04.25.05.32.21;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	2000.04.25.04.15.34;	author jason;	state Exp;
branches;
next	1.34;

1.34
date	2000.04.23.05.03.40;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2000.04.19.00.10.35;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2000.04.13.22.34.08;	author jason;	state Exp;
branches;
next	1.31;

1.31
date	2000.04.13.20.55.16;	author jason;	state Exp;
branches;
next	1.30;

1.30
date	2000.04.13.00.28.44;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2000.04.11.19.59.06;	author jason;	state Exp;
branches;
next	1.28;

1.28
date	2000.04.11.16.22.09;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.10.18.40.47;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2000.04.05.16.52.22;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2000.04.05.16.34.07;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2000.04.04.20.16.33;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.31.05.49.08;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2000.03.30.23.14.25;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.30.07.30.39;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.30.05.56.31;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.29.22.39.38;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.29.21.03.11;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.29.20.54.59;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.22.05.30.47;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.22.04.47.01;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.18.02.41.45;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.17.21.59.07;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.17.20.31.30;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.16.20.39.23;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.16.20.33.47;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.15.14.55.51;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.10.19.54.24;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.10.08.44.59;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.10.02.22.50;	author jason;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.12.15.00.30.44;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	99.12.06.07.29.56;	author art;	state Exp;
branches;
next	1.3;

1.3
date	99.02.24.06.09.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.02.21.00.05.14;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.02.19.02.52.19;	author deraadt;	state Exp;
branches;
next	;

1.6.2.1
date	2000.03.24.09.09.16;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.05.14.22.25.41;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.07.04.10.42.06;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2001.12.05.00.43.29;	author niklas;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.6.2.8;

1.6.2.8
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.6.2.9;

1.6.2.9
date	2003.03.28.00.38.21;	author niklas;	state Exp;
branches;
next	1.6.2.10;

1.6.2.10
date	2004.02.19.10.56.26;	author niklas;	state Exp;
branches;
next	1.6.2.11;

1.6.2.11
date	2004.06.05.23.12.49;	author niklas;	state Exp;
branches;
next	;

1.38.2.1
date	2000.06.18.02.52.30;	author jason;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2000.08.04.05.46.20;	author jason;	state Exp;
branches;
next	;

1.57.2.1
date	2001.12.01.00.31.55;	author miod;	state Exp;
branches;
next	;

1.103.2.1
date	2001.11.13.17.23.54;	author jason;	state Exp;
branches;
next	1.103.2.2;

1.103.2.2
date	2001.12.14.21.48.07;	author jason;	state Exp;
branches;
next	;

1.110.2.1
date	2002.01.31.22.55.34;	author niklas;	state Exp;
branches;
next	1.110.2.2;

1.110.2.2
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.110.2.3;

1.110.2.3
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	1.110.2.4;

1.110.2.4
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;

1.158.2.1
date	2010.12.20.14.08.39;	author jasper;	state Exp;
branches;
next	;

1.162.2.1
date	2010.12.17.16.25.14;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.177
log
@Reduce the per-packet allocation costs for crypto operations (cryptop)
by pre-allocating two cryptodesc objects and storing them in an array
instead of a linked list.  If more than two cryptodesc objects are
required use mallocarray to fetch them.  Adapt the drivers to the new
API.

This change results in one pool-get per ESP packet instead of three.
It also simplifies softraid crypto where more cryptodesc objects are
allocated than used.

From, with and ok markus@@, ok bluhm@@
"looks sane" mpi@@
@
text
@/*	$OpenBSD: hifn7751.c,v 1.176 2017/01/19 10:20:29 jsg Exp $	*/

/*
 * Invertex AEON / Hifn 7751 driver
 * Copyright (c) 1999 Invertex Inc. All rights reserved.
 * Copyright (c) 1999 Theo de Raadt
 * Copyright (c) 2000-2001 Network Security Technologies, Inc.
 *			http://www.netsec.net
 * Copyright (c) 2003 Hifn Inc.

 * This driver is based on a previous driver by Invertex, for which they
 * requested:  Please send any comments, feedback, bug-fixes, or feature
 * requests to software@@invertex.com.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *   derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

/*
 * Driver for various Hifn encryption processors.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/mbuf.h>
#include <sys/device.h>

#include <crypto/cryptodev.h>
#include <dev/rndvar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/pci/hifn7751reg.h>
#include <dev/pci/hifn7751var.h>

#undef HIFN_DEBUG

/*
 * Prototypes and count for the pci_device structure
 */
int hifn_probe(struct device *, void *, void *);
void hifn_attach(struct device *, struct device *, void *);

struct cfattach hifn_ca = {
	sizeof(struct hifn_softc), hifn_probe, hifn_attach,
};

struct cfdriver hifn_cd = {
	0, "hifn", DV_DULL
};

void	hifn_reset_board(struct hifn_softc *, int);
void	hifn_reset_puc(struct hifn_softc *);
void	hifn_puc_wait(struct hifn_softc *);
int	hifn_enable_crypto(struct hifn_softc *, pcireg_t);
void	hifn_set_retry(struct hifn_softc *);
void	hifn_init_dma(struct hifn_softc *);
void	hifn_init_pci_registers(struct hifn_softc *);
int	hifn_sramsize(struct hifn_softc *);
int	hifn_dramsize(struct hifn_softc *);
int	hifn_ramtype(struct hifn_softc *);
void	hifn_sessions(struct hifn_softc *);
int	hifn_intr(void *);
u_int	hifn_write_command(struct hifn_command *, u_int8_t *);
u_int32_t hifn_next_signature(u_int32_t a, u_int cnt);
int	hifn_newsession(u_int32_t *, struct cryptoini *);
int	hifn_freesession(u_int64_t);
int	hifn_process(struct cryptop *);
void	hifn_callback(struct hifn_softc *, struct hifn_command *, u_int8_t *);
int	hifn_crypto(struct hifn_softc *, struct hifn_command *,
    struct cryptop *);
int	hifn_readramaddr(struct hifn_softc *, int, u_int8_t *);
int	hifn_writeramaddr(struct hifn_softc *, int, u_int8_t *);
int	hifn_dmamap_aligned(bus_dmamap_t);
int	hifn_dmamap_load_src(struct hifn_softc *, struct hifn_command *);
int	hifn_dmamap_load_dst(struct hifn_softc *, struct hifn_command *);
int	hifn_init_pubrng(struct hifn_softc *);
void	hifn_rng(void *);
void	hifn_tick(void *);
void	hifn_abort(struct hifn_softc *);
void	hifn_alloc_slot(struct hifn_softc *, int *, int *, int *, int *);
void	hifn_write_4(struct hifn_softc *, int, bus_size_t, u_int32_t);
u_int32_t hifn_read_4(struct hifn_softc *, int, bus_size_t);
int	hifn_compression(struct hifn_softc *, struct cryptop *,
    struct hifn_command *);
struct mbuf *hifn_mkmbuf_chain(int, struct mbuf *);
int	hifn_compress_enter(struct hifn_softc *, struct hifn_command *);
void	hifn_callback_comp(struct hifn_softc *, struct hifn_command *,
    u_int8_t *);

struct hifn_stats hifnstats;

const struct pci_matchid hifn_devices[] = {
	{ PCI_VENDOR_INVERTEX, PCI_PRODUCT_INVERTEX_AEON },
	{ PCI_VENDOR_HIFN, PCI_PRODUCT_HIFN_7751 },
	{ PCI_VENDOR_HIFN, PCI_PRODUCT_HIFN_7811 },
	{ PCI_VENDOR_HIFN, PCI_PRODUCT_HIFN_7951 },
	{ PCI_VENDOR_HIFN, PCI_PRODUCT_HIFN_7955 },
	{ PCI_VENDOR_HIFN, PCI_PRODUCT_HIFN_7956 },
	{ PCI_VENDOR_NETSEC, PCI_PRODUCT_NETSEC_7751 },
};

int
hifn_probe(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, hifn_devices,
	    nitems(hifn_devices)));
}

void 
hifn_attach(struct device *parent, struct device *self, void *aux)
{
	struct hifn_softc *sc = (struct hifn_softc *)self;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
	char rbase;
	bus_size_t iosize0, iosize1;
	u_int16_t ena;
	int rseg;
	caddr_t kva;
	int algs[CRYPTO_ALGORITHM_MAX + 1];

	sc->sc_pci_pc = pa->pa_pc;
	sc->sc_pci_tag = pa->pa_tag;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_HIFN &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7951))
		sc->sc_flags = HIFN_HAS_RNG | HIFN_HAS_PUBLIC;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_HIFN &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7955 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7956))
		sc->sc_flags = HIFN_IS_7956 | HIFN_HAS_AES | HIFN_HAS_RNG |
		    HIFN_HAS_PUBLIC;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_HIFN &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7811)
		sc->sc_flags |= HIFN_IS_7811 | HIFN_HAS_RNG | HIFN_HAS_LEDS |
		    HIFN_NO_BURSTWRITE;

	if (pci_mapreg_map(pa, HIFN_BAR0, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->sc_st0, &sc->sc_sh0, NULL, &iosize0, 0)) {
		printf(": can't find mem space %d\n", 0);
		return;
	}

	if (pci_mapreg_map(pa, HIFN_BAR1, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->sc_st1, &sc->sc_sh1, NULL, &iosize1, 0)) {
		printf(": can't find mem space %d\n", 1);
		goto fail_io0;
	}

	hifn_set_retry(sc);

	if (sc->sc_flags & HIFN_NO_BURSTWRITE) {
		sc->sc_waw_lastgroup = -1;
		sc->sc_waw_lastreg = 1;
	}

	sc->sc_dmat = pa->pa_dmat;
	if (bus_dmamap_create(sc->sc_dmat, sizeof(*sc->sc_dma), 1,
	    sizeof(*sc->sc_dma), 0, BUS_DMA_NOWAIT, &sc->sc_dmamap)) {
		printf(": can't create dma map\n");
		goto fail_io1;
	}
	if (bus_dmamem_alloc(sc->sc_dmat, sizeof(*sc->sc_dma), PAGE_SIZE, 0,
	    sc->sc_dmasegs, 1, &sc->sc_dmansegs,
	    BUS_DMA_NOWAIT | BUS_DMA_ZERO)) {
		printf(": can't alloc dma buffer\n");
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_dmamap);
		goto fail_io1;
	}
	if (bus_dmamem_map(sc->sc_dmat, sc->sc_dmasegs, sc->sc_dmansegs,
	    sizeof(*sc->sc_dma), &kva, BUS_DMA_NOWAIT)) {
		printf(": can't map dma buffers (%lu bytes)\n",
		    (u_long)sizeof(*sc->sc_dma));
		bus_dmamem_free(sc->sc_dmat, sc->sc_dmasegs, sc->sc_dmansegs);
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_dmamap);
		goto fail_io1;
	}
	if (bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap, kva,
	    sizeof(*sc->sc_dma), NULL, BUS_DMA_NOWAIT)) {
		printf(": can't load dma map\n");
		bus_dmamem_unmap(sc->sc_dmat, kva, sizeof(*sc->sc_dma));
		bus_dmamem_free(sc->sc_dmat, sc->sc_dmasegs, sc->sc_dmansegs);
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_dmamap);
		goto fail_io1;
	}
	sc->sc_dma = (struct hifn_dma *)kva;

	hifn_reset_board(sc, 0);

	if (hifn_enable_crypto(sc, pa->pa_id) != 0) {
		printf("%s: crypto enabling failed\n", sc->sc_dv.dv_xname);
		goto fail_mem;
	}
	hifn_reset_puc(sc);

	hifn_init_dma(sc);
	hifn_init_pci_registers(sc);

	if (sc->sc_flags & HIFN_IS_7956)
		sc->sc_drammodel = 1;
	else if (hifn_ramtype(sc))
		goto fail_mem;

	if (sc->sc_drammodel == 0)
		hifn_sramsize(sc);
	else
		hifn_dramsize(sc);

	/*
	 * Workaround for NetSec 7751 rev A: half ram size because two
	 * of the address lines were left floating
	 */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_NETSEC &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETSEC_7751 &&
	    PCI_REVISION(pa->pa_class) == 0x61)
		sc->sc_ramsize >>= 1;

	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		goto fail_mem;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, hifn_intr, sc,
	    self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail_mem;
	}

	hifn_sessions(sc);

	rseg = sc->sc_ramsize / 1024;
	rbase = 'K';
	if (sc->sc_ramsize >= (1024 * 1024)) {
		rbase = 'M';
		rseg /= 1024;
	}
	printf("%d%cB %cram, %s\n", rseg, rbase,
	    sc->sc_drammodel ? 'd' : 's', intrstr);

	sc->sc_cid = crypto_get_driverid(0);
	if (sc->sc_cid < 0)
		goto fail_intr;

	WRITE_REG_0(sc, HIFN_0_PUCNFG,
	    READ_REG_0(sc, HIFN_0_PUCNFG) | HIFN_PUCNFG_CHIPID);
	ena = READ_REG_0(sc, HIFN_0_PUSTAT) & HIFN_PUSTAT_CHIPENA;

	bzero(algs, sizeof(algs));

	algs[CRYPTO_LZS_COMP] = CRYPTO_ALG_FLAG_SUPPORTED;
	switch (ena) {
	case HIFN_PUSTAT_ENA_2:
		algs[CRYPTO_3DES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
		/*FALLTHROUGH*/
	case HIFN_PUSTAT_ENA_1:
		algs[CRYPTO_MD5_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_SHA1_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	}
	if (sc->sc_flags & HIFN_HAS_AES)
		algs[CRYPTO_AES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;

	crypto_register(sc->sc_cid, algs, hifn_newsession,
	    hifn_freesession, hifn_process);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
	    sc->sc_dmamap->dm_mapsize,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	if (sc->sc_flags & (HIFN_HAS_PUBLIC | HIFN_HAS_RNG))
		hifn_init_pubrng(sc);

	timeout_set(&sc->sc_tickto, hifn_tick, sc);
	timeout_add_sec(&sc->sc_tickto, 1);

	return;

fail_intr:
	pci_intr_disestablish(pc, sc->sc_ih);
fail_mem:
	bus_dmamap_unload(sc->sc_dmat, sc->sc_dmamap);
	bus_dmamem_unmap(sc->sc_dmat, kva, sizeof(*sc->sc_dma));
	bus_dmamem_free(sc->sc_dmat, sc->sc_dmasegs, sc->sc_dmansegs);
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_dmamap);

	/* Turn off DMA polling */
	WRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |
	    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);

fail_io1:
	bus_space_unmap(sc->sc_st1, sc->sc_sh1, iosize1);
fail_io0:
	bus_space_unmap(sc->sc_st0, sc->sc_sh0, iosize0);
}

int
hifn_init_pubrng(struct hifn_softc *sc)
{
	u_int32_t r;
	int i;

	if ((sc->sc_flags & HIFN_IS_7811) == 0) {
		/* Reset 7951 public key/rng engine */
		WRITE_REG_1(sc, HIFN_1_PUB_RESET,
		    READ_REG_1(sc, HIFN_1_PUB_RESET) | HIFN_PUBRST_RESET);

		for (i = 0; i < 100; i++) {
			DELAY(1000);
			if ((READ_REG_1(sc, HIFN_1_PUB_RESET) &
			    HIFN_PUBRST_RESET) == 0)
				break;
		}

		if (i == 100) {
			printf("%s: public key init failed\n",
			    sc->sc_dv.dv_xname);
			return (1);
		}
	}

	/* Enable the rng, if available */
	if (sc->sc_flags & HIFN_HAS_RNG) {
		if (sc->sc_flags & HIFN_IS_7811) {
			r = READ_REG_1(sc, HIFN_1_7811_RNGENA);
			if (r & HIFN_7811_RNGENA_ENA) {
				r &= ~HIFN_7811_RNGENA_ENA;
				WRITE_REG_1(sc, HIFN_1_7811_RNGENA, r);
			}
			WRITE_REG_1(sc, HIFN_1_7811_RNGCFG,
			    HIFN_7811_RNGCFG_DEFL);
			r |= HIFN_7811_RNGENA_ENA;
			WRITE_REG_1(sc, HIFN_1_7811_RNGENA, r);
		} else
			WRITE_REG_1(sc, HIFN_1_RNG_CONFIG,
			    READ_REG_1(sc, HIFN_1_RNG_CONFIG) |
			    HIFN_RNGCFG_ENA);

		sc->sc_rngfirst = 1;
		if (hz >= 100)
			sc->sc_rnghz = hz / 100;
		else
			sc->sc_rnghz = 1;
		timeout_set(&sc->sc_rngto, hifn_rng, sc);
		timeout_add(&sc->sc_rngto, sc->sc_rnghz);
	}

	/* Enable public key engine, if available */
	if (sc->sc_flags & HIFN_HAS_PUBLIC) {
		WRITE_REG_1(sc, HIFN_1_PUB_IEN, HIFN_PUBIEN_DONE);
		sc->sc_dmaier |= HIFN_DMAIER_PUBDONE;
		WRITE_REG_1(sc, HIFN_1_DMA_IER, sc->sc_dmaier);
	}

	return (0);
}

void
hifn_rng(void *vsc)
{
	struct hifn_softc *sc = vsc;
	u_int32_t num1, sts, num2;
	int i;

	if (sc->sc_flags & HIFN_IS_7811) {
		for (i = 0; i < 5; i++) {
			sts = READ_REG_1(sc, HIFN_1_7811_RNGSTS);
			if (sts & HIFN_7811_RNGSTS_UFL) {
				printf("%s: RNG underflow: disabling\n",
				    sc->sc_dv.dv_xname);
				return;
			}
			if ((sts & HIFN_7811_RNGSTS_RDY) == 0)
				break;

			/*
			 * There are at least two words in the RNG FIFO
			 * at this point.
			 */
			num1 = READ_REG_1(sc, HIFN_1_7811_RNGDAT);
			num2 = READ_REG_1(sc, HIFN_1_7811_RNGDAT);
			if (sc->sc_rngfirst)
				sc->sc_rngfirst = 0;
			else {
				add_true_randomness(num1);
				add_true_randomness(num2);
			}
		}
	} else {
		num1 = READ_REG_1(sc, HIFN_1_RNG_DATA);

		if (sc->sc_rngfirst)
			sc->sc_rngfirst = 0;
		else
			add_true_randomness(num1);
	}

	timeout_add(&sc->sc_rngto, sc->sc_rnghz);
}

void
hifn_puc_wait(struct hifn_softc *sc)
{
	int i;

	for (i = 5000; i > 0; i--) {
		DELAY(1);
		if (!(READ_REG_0(sc, HIFN_0_PUCTRL) & HIFN_PUCTRL_RESET))
			break;
	}
	if (!i)
		printf("%s: proc unit did not reset\n", sc->sc_dv.dv_xname);
}

/*
 * Reset the processing unit.
 */
void
hifn_reset_puc(struct hifn_softc *sc)
{
	/* Reset processing unit */
	WRITE_REG_0(sc, HIFN_0_PUCTRL, HIFN_PUCTRL_DMAENA);
	hifn_puc_wait(sc);
}

void
hifn_set_retry(struct hifn_softc *sc)
{
	u_int32_t r;

	r = pci_conf_read(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_TRDY_TIMEOUT);
	r &= 0xffff0000;
	pci_conf_write(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_TRDY_TIMEOUT, r);
}

/*
 * Resets the board.  Values in the regesters are left as is
 * from the reset (i.e. initial values are assigned elsewhere).
 */
void
hifn_reset_board(struct hifn_softc *sc, int full)
{
	u_int32_t reg;

	/*
	 * Set polling in the DMA configuration register to zero.  0x7 avoids
	 * resetting the board and zeros out the other fields.
	 */
	WRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |
	    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);

	/*
	 * Now that polling has been disabled, we have to wait 1 ms
	 * before resetting the board.
	 */
	DELAY(1000);

	/* Reset the DMA unit */
	if (full) {
		WRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MODE);
		DELAY(1000);
	} else {
		WRITE_REG_1(sc, HIFN_1_DMA_CNFG,
		    HIFN_DMACNFG_MODE | HIFN_DMACNFG_MSTRESET);
		hifn_reset_puc(sc);
	}

	bzero(sc->sc_dma, sizeof(*sc->sc_dma));

	/* Bring dma unit out of reset */
	WRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |
	    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);

	hifn_puc_wait(sc);

	hifn_set_retry(sc);

	if (sc->sc_flags & HIFN_IS_7811) {
		for (reg = 0; reg < 1000; reg++) {
			if (READ_REG_1(sc, HIFN_1_7811_MIPSRST) &
			    HIFN_MIPSRST_CRAMINIT)
				break;
			DELAY(1000);
		}
		if (reg == 1000)
			printf(": cram init timeout\n");
	}
}

u_int32_t
hifn_next_signature(u_int32_t a, u_int cnt)
{
	int i;
	u_int32_t v;

	for (i = 0; i < cnt; i++) {

		/* get the parity */
		v = a & 0x80080125;
		v ^= v >> 16;
		v ^= v >> 8;
		v ^= v >> 4;
		v ^= v >> 2;
		v ^= v >> 1;

		a = (v & 1) ^ (a << 1);
	}

	return a;
}

struct pci2id {
	u_short		pci_vendor;
	u_short		pci_prod;
	char		card_id[13];
} pci2id[] = {
	{
		PCI_VENDOR_HIFN,
		PCI_PRODUCT_HIFN_7951,
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00 }
	}, {
		PCI_VENDOR_HIFN,
		PCI_PRODUCT_HIFN_7955,
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00 }
	}, {
		PCI_VENDOR_HIFN,
		PCI_PRODUCT_HIFN_7956,
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00 }
	}, {
		PCI_VENDOR_NETSEC,
		PCI_PRODUCT_NETSEC_7751,
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00 }
	}, {
		PCI_VENDOR_INVERTEX,
		PCI_PRODUCT_INVERTEX_AEON,
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00 }
	}, {
		PCI_VENDOR_HIFN,
		PCI_PRODUCT_HIFN_7811,
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00 }
	}, {
		/*
		 * Other vendors share this PCI ID as well, such as
		 * powercrypt, and obviously they also
		 * use the same key.
		 */
		PCI_VENDOR_HIFN,
		PCI_PRODUCT_HIFN_7751,
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00 }
	},
};

/*
 * Checks to see if crypto is already enabled.  If crypto isn't enable,
 * "hifn_enable_crypto" is called to enable it.  The check is important,
 * as enabling crypto twice will lock the board.
 */
int 
hifn_enable_crypto(struct hifn_softc *sc, pcireg_t pciid)
{
	u_int32_t dmacfg, ramcfg, encl, addr, i;
	char *offtbl = NULL;

	for (i = 0; i < nitems(pci2id); i++) {
		if (pci2id[i].pci_vendor == PCI_VENDOR(pciid) &&
		    pci2id[i].pci_prod == PCI_PRODUCT(pciid)) {
			offtbl = pci2id[i].card_id;
			break;
		}
	}

	if (offtbl == NULL) {
#ifdef HIFN_DEBUG
		printf(": Unknown card!\n");
#endif
		return (1);
	}

	ramcfg = READ_REG_0(sc, HIFN_0_PUCNFG);
	dmacfg = READ_REG_1(sc, HIFN_1_DMA_CNFG);

	/*
	 * The RAM config register's encrypt level bit needs to be set before
	 * every read performed on the encryption level register.
	 */
	WRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg | HIFN_PUCNFG_CHIPID);

	encl = READ_REG_0(sc, HIFN_0_PUSTAT) & HIFN_PUSTAT_CHIPENA;

	/*
	 * Make sure we don't re-unlock.  Two unlocks kills chip until the
	 * next reboot.
	 */
	if (encl == HIFN_PUSTAT_ENA_1 || encl == HIFN_PUSTAT_ENA_2) {
#ifdef HIFN_DEBUG
		printf(": Strong Crypto already enabled!\n");
#endif
		goto report;
	}

	if (encl != 0 && encl != HIFN_PUSTAT_ENA_0) {
#ifdef HIFN_DEBUG
		printf(": Unknown encryption level\n");
#endif
		return 1;
	}

	WRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_UNLOCK |
	    HIFN_DMACNFG_MSTRESET | HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);
	DELAY(1000);
	addr = READ_REG_1(sc, HIFN_1_UNLOCK_SECRET1);
	DELAY(1000);
	WRITE_REG_1(sc, HIFN_1_UNLOCK_SECRET2, 0);
	DELAY(1000);

	for (i = 0; i <= 12; i++) {
		addr = hifn_next_signature(addr, offtbl[i] + 0x101);
		WRITE_REG_1(sc, HIFN_1_UNLOCK_SECRET2, addr);

		DELAY(1000);
	}

	WRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg | HIFN_PUCNFG_CHIPID);
	encl = READ_REG_0(sc, HIFN_0_PUSTAT) & HIFN_PUSTAT_CHIPENA;

#ifdef HIFN_DEBUG
	if (encl != HIFN_PUSTAT_ENA_1 && encl != HIFN_PUSTAT_ENA_2)
		printf(": engine is permanently locked until next system reset");
	else
		printf(": engine enabled successfully!");
#endif

report:
	WRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg);
	WRITE_REG_1(sc, HIFN_1_DMA_CNFG, dmacfg);

	switch (encl) {
	case HIFN_PUSTAT_ENA_0:
		offtbl = "LZS";
		break;
	case HIFN_PUSTAT_ENA_1:
		offtbl = "LZS DES";
		break;
	case HIFN_PUSTAT_ENA_2:
		offtbl = "LZS 3DES ARC4 MD5 SHA1";
		break;
	default:
		offtbl = "disabled";
		break;
	}
	printf(": %s", offtbl);
	if (sc->sc_flags & HIFN_HAS_RNG)
		printf(" RNG");
	if (sc->sc_flags & HIFN_HAS_AES)
		printf(" AES");
	if (sc->sc_flags & HIFN_HAS_PUBLIC)
		printf(" PK");
	printf(", ");

	return (0);
}

/*
 * Give initial values to the registers listed in the "Register Space"
 * section of the HIFN Software Development reference manual.
 */
void 
hifn_init_pci_registers(struct hifn_softc *sc)
{
	/* write fixed values needed by the Initialization registers */
	WRITE_REG_0(sc, HIFN_0_PUCTRL, HIFN_PUCTRL_DMAENA);
	WRITE_REG_0(sc, HIFN_0_FIFOCNFG, HIFN_FIFOCNFG_THRESHOLD);
	WRITE_REG_0(sc, HIFN_0_PUIER, HIFN_PUIER_DSTOVER);

	/* write all 4 ring address registers */
	WRITE_REG_1(sc, HIFN_1_DMA_CRAR, sc->sc_dmamap->dm_segs[0].ds_addr +
	    offsetof(struct hifn_dma, cmdr[0]));
	WRITE_REG_1(sc, HIFN_1_DMA_SRAR, sc->sc_dmamap->dm_segs[0].ds_addr +
	    offsetof(struct hifn_dma, srcr[0]));
	WRITE_REG_1(sc, HIFN_1_DMA_DRAR, sc->sc_dmamap->dm_segs[0].ds_addr +
	    offsetof(struct hifn_dma, dstr[0]));
	WRITE_REG_1(sc, HIFN_1_DMA_RRAR, sc->sc_dmamap->dm_segs[0].ds_addr +
	    offsetof(struct hifn_dma, resr[0]));

	DELAY(2000);

	/* write status register */
	WRITE_REG_1(sc, HIFN_1_DMA_CSR,
	    HIFN_DMACSR_D_CTRL_DIS | HIFN_DMACSR_R_CTRL_DIS |
	    HIFN_DMACSR_S_CTRL_DIS | HIFN_DMACSR_C_CTRL_DIS |
	    HIFN_DMACSR_D_ABORT | HIFN_DMACSR_D_DONE | HIFN_DMACSR_D_LAST |
	    HIFN_DMACSR_D_WAIT | HIFN_DMACSR_D_OVER |
	    HIFN_DMACSR_R_ABORT | HIFN_DMACSR_R_DONE | HIFN_DMACSR_R_LAST |
	    HIFN_DMACSR_R_WAIT | HIFN_DMACSR_R_OVER |
	    HIFN_DMACSR_S_ABORT | HIFN_DMACSR_S_DONE | HIFN_DMACSR_S_LAST |
	    HIFN_DMACSR_S_WAIT |
	    HIFN_DMACSR_C_ABORT | HIFN_DMACSR_C_DONE | HIFN_DMACSR_C_LAST |
	    HIFN_DMACSR_C_WAIT |
	    HIFN_DMACSR_ENGINE |
	    ((sc->sc_flags & HIFN_HAS_PUBLIC) ?
		HIFN_DMACSR_PUBDONE : 0) |
	    ((sc->sc_flags & HIFN_IS_7811) ?
		HIFN_DMACSR_ILLW | HIFN_DMACSR_ILLR : 0));

	sc->sc_d_busy = sc->sc_r_busy = sc->sc_s_busy = sc->sc_c_busy = 0;
	sc->sc_dmaier |= HIFN_DMAIER_R_DONE | HIFN_DMAIER_C_ABORT |
	    HIFN_DMAIER_D_OVER | HIFN_DMAIER_R_OVER |
	    HIFN_DMAIER_S_ABORT | HIFN_DMAIER_D_ABORT | HIFN_DMAIER_R_ABORT |
	    HIFN_DMAIER_ENGINE |
	    ((sc->sc_flags & HIFN_IS_7811) ?
		HIFN_DMAIER_ILLW | HIFN_DMAIER_ILLR : 0);
	sc->sc_dmaier &= ~HIFN_DMAIER_C_WAIT;
	WRITE_REG_1(sc, HIFN_1_DMA_IER, sc->sc_dmaier);
	CLR_LED(sc, HIFN_MIPSRST_LED0 | HIFN_MIPSRST_LED1 | HIFN_MIPSRST_LED2);

	if (sc->sc_flags & HIFN_IS_7956) {
		WRITE_REG_0(sc, HIFN_0_PUCNFG, HIFN_PUCNFG_COMPSING |
		    HIFN_PUCNFG_TCALLPHASES |
		    HIFN_PUCNFG_TCDRVTOTEM | HIFN_PUCNFG_BUS32);
		WRITE_REG_1(sc, HIFN_1_PLL, HIFN_PLL_7956);
	} else {
		WRITE_REG_0(sc, HIFN_0_PUCNFG, HIFN_PUCNFG_COMPSING |
		    HIFN_PUCNFG_DRFR_128 | HIFN_PUCNFG_TCALLPHASES |
		    HIFN_PUCNFG_TCDRVTOTEM | HIFN_PUCNFG_BUS32 |
		    (sc->sc_drammodel ? HIFN_PUCNFG_DRAM : HIFN_PUCNFG_SRAM));
	}

	WRITE_REG_0(sc, HIFN_0_PUISR, HIFN_PUISR_DSTOVER);
	WRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |
	    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE | HIFN_DMACNFG_LAST |
	    ((HIFN_POLL_FREQUENCY << 16 ) & HIFN_DMACNFG_POLLFREQ) |
	    ((HIFN_POLL_SCALAR << 8) & HIFN_DMACNFG_POLLINVAL));
}

/*
 * The maximum number of sessions supported by the card
 * is dependent on the amount of context ram, which
 * encryption algorithms are enabled, and how compression
 * is configured.  This should be configured before this
 * routine is called.
 */
void
hifn_sessions(struct hifn_softc *sc)
{
	u_int32_t pucnfg;
	int ctxsize;

	pucnfg = READ_REG_0(sc, HIFN_0_PUCNFG);

	if (pucnfg & HIFN_PUCNFG_COMPSING) {
		if (pucnfg & HIFN_PUCNFG_ENCCNFG)
			ctxsize = 128;
		else
			ctxsize = 512;
		/*
		 * 7955/7956 has internal context memory of 32K
		 */
		if (sc->sc_flags & HIFN_IS_7956)
			sc->sc_maxses = 32768 / ctxsize;
		else
			sc->sc_maxses = 1 +
			    ((sc->sc_ramsize - 32768) / ctxsize);
	}
	else
		sc->sc_maxses = sc->sc_ramsize / 16384;

	if (sc->sc_maxses > 2048)
		sc->sc_maxses = 2048;
}

/*
 * Determine ram type (sram or dram).  Board should be just out of a reset
 * state when this is called.
 */
int
hifn_ramtype(struct hifn_softc *sc)
{
	u_int8_t data[8], dataexpect[8];
	int i;

	for (i = 0; i < sizeof(data); i++)
		data[i] = dataexpect[i] = 0x55;
	if (hifn_writeramaddr(sc, 0, data))
		return (-1);
	if (hifn_readramaddr(sc, 0, data))
		return (-1);
	if (bcmp(data, dataexpect, sizeof(data)) != 0) {
		sc->sc_drammodel = 1;
		return (0);
	}

	for (i = 0; i < sizeof(data); i++)
		data[i] = dataexpect[i] = 0xaa;
	if (hifn_writeramaddr(sc, 0, data))
		return (-1);
	if (hifn_readramaddr(sc, 0, data))
		return (-1);
	if (bcmp(data, dataexpect, sizeof(data)) != 0) {
		sc->sc_drammodel = 1;
		return (0);
	}

	return (0);
}

#define	HIFN_SRAM_MAX		(32 << 20)
#define	HIFN_SRAM_STEP_SIZE	16384
#define	HIFN_SRAM_GRANULARITY	(HIFN_SRAM_MAX / HIFN_SRAM_STEP_SIZE)

int
hifn_sramsize(struct hifn_softc *sc)
{
	u_int32_t a;
	u_int8_t data[8];
	u_int8_t dataexpect[sizeof(data)];
	int32_t i;

	for (i = 0; i < sizeof(data); i++)
		data[i] = dataexpect[i] = i ^ 0x5a;

	for (i = HIFN_SRAM_GRANULARITY - 1; i >= 0; i--) {
		a = i * HIFN_SRAM_STEP_SIZE;
		bcopy(&i, data, sizeof(i));
		hifn_writeramaddr(sc, a, data);
	}

	for (i = 0; i < HIFN_SRAM_GRANULARITY; i++) {
		a = i * HIFN_SRAM_STEP_SIZE;
		bcopy(&i, dataexpect, sizeof(i));
		if (hifn_readramaddr(sc, a, data) < 0)
			return (0);
		if (bcmp(data, dataexpect, sizeof(data)) != 0)
			return (0);
		sc->sc_ramsize = a + HIFN_SRAM_STEP_SIZE;
	}

	return (0);
}

/*
 * XXX For dram boards, one should really try all of the
 * HIFN_PUCNFG_DSZ_*'s.  This just assumes that PUCNFG
 * is already set up correctly.
 */
int
hifn_dramsize(struct hifn_softc *sc)
{
	u_int32_t cnfg;

	if (sc->sc_flags & HIFN_IS_7956) {
		/*
		 * 7956/7956 have a fixed internal ram of only 32K.
		 */
		sc->sc_ramsize = 32768;
	} else {
		cnfg = READ_REG_0(sc, HIFN_0_PUCNFG) &
		    HIFN_PUCNFG_DRAMMASK;
		sc->sc_ramsize = 1 << ((cnfg >> 13) + 18);
	}
	return (0);
}

void
hifn_alloc_slot(struct hifn_softc *sc, int *cmdp, int *srcp,
    int *dstp, int *resp)
{
	struct hifn_dma *dma = sc->sc_dma;

	if (dma->cmdi == HIFN_D_CMD_RSIZE) {
		dma->cmdi = 0;
		dma->cmdr[HIFN_D_CMD_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_CMDR_SYNC(sc, HIFN_D_CMD_RSIZE,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	*cmdp = dma->cmdi++;
	dma->cmdk = dma->cmdi;

	if (dma->srci == HIFN_D_SRC_RSIZE) {
		dma->srci = 0;
		dma->srcr[HIFN_D_SRC_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_SRCR_SYNC(sc, HIFN_D_SRC_RSIZE,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	*srcp = dma->srci++;
	dma->srck = dma->srci;

	if (dma->dsti == HIFN_D_DST_RSIZE) {
		dma->dsti = 0;
		dma->dstr[HIFN_D_DST_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_DSTR_SYNC(sc, HIFN_D_DST_RSIZE,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	*dstp = dma->dsti++;
	dma->dstk = dma->dsti;

	if (dma->resi == HIFN_D_RES_RSIZE) {
		dma->resi = 0;
		dma->resr[HIFN_D_RES_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_RESR_SYNC(sc, HIFN_D_RES_RSIZE,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	*resp = dma->resi++;
	dma->resk = dma->resi;
}

int
hifn_writeramaddr(struct hifn_softc *sc, int addr, u_int8_t *data)
{
	struct hifn_dma *dma = sc->sc_dma;
	struct hifn_base_command wc;
	const u_int32_t masks = HIFN_D_VALID | HIFN_D_LAST | HIFN_D_MASKDONEIRQ;
	int r, cmdi, resi, srci, dsti;

	wc.masks = htole16(3 << 13);
	wc.session_num = htole16(addr >> 14);
	wc.total_source_count = htole16(8);
	wc.total_dest_count = htole16(addr & 0x3fff);

	hifn_alloc_slot(sc, &cmdi, &srci, &dsti, &resi);

	WRITE_REG_1(sc, HIFN_1_DMA_CSR,
	    HIFN_DMACSR_C_CTRL_ENA | HIFN_DMACSR_S_CTRL_ENA |
	    HIFN_DMACSR_D_CTRL_ENA | HIFN_DMACSR_R_CTRL_ENA);

	/* build write command */
	bzero(dma->command_bufs[cmdi], HIFN_MAX_COMMAND);
	*(struct hifn_base_command *)dma->command_bufs[cmdi] = wc;
	bcopy(data, &dma->test_src, sizeof(dma->test_src));

	dma->srcr[srci].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr
	    + offsetof(struct hifn_dma, test_src));
	dma->dstr[dsti].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr
	    + offsetof(struct hifn_dma, test_dst));

	dma->cmdr[cmdi].l = htole32(16 | masks);
	dma->srcr[srci].l = htole32(8 | masks);
	dma->dstr[dsti].l = htole32(4 | masks);
	dma->resr[resi].l = htole32(4 | masks);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
	    0, sc->sc_dmamap->dm_mapsize,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	for (r = 10000; r >= 0; r--) {
		DELAY(10);
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    0, sc->sc_dmamap->dm_mapsize,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		if ((dma->resr[resi].l & htole32(HIFN_D_VALID)) == 0)
			break;
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    0, sc->sc_dmamap->dm_mapsize,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	}
	if (r == 0) {
		printf("%s: writeramaddr -- "
		    "result[%d](addr %d) still valid\n",
		    sc->sc_dv.dv_xname, resi, addr);

		return (-1);
	} else
		r = 0;

	WRITE_REG_1(sc, HIFN_1_DMA_CSR,
	    HIFN_DMACSR_C_CTRL_DIS | HIFN_DMACSR_S_CTRL_DIS |
	    HIFN_DMACSR_D_CTRL_DIS | HIFN_DMACSR_R_CTRL_DIS);

	return (r);
}

int
hifn_readramaddr(struct hifn_softc *sc, int addr, u_int8_t *data)
{
	struct hifn_dma *dma = sc->sc_dma;
	struct hifn_base_command rc;
	const u_int32_t masks = HIFN_D_VALID | HIFN_D_LAST | HIFN_D_MASKDONEIRQ;
	int r, cmdi, srci, dsti, resi;

	rc.masks = htole16(2 << 13);
	rc.session_num = htole16(addr >> 14);
	rc.total_source_count = htole16(addr & 0x3fff);
	rc.total_dest_count = htole16(8);

	hifn_alloc_slot(sc, &cmdi, &srci, &dsti, &resi);

	WRITE_REG_1(sc, HIFN_1_DMA_CSR,
	    HIFN_DMACSR_C_CTRL_ENA | HIFN_DMACSR_S_CTRL_ENA |
	    HIFN_DMACSR_D_CTRL_ENA | HIFN_DMACSR_R_CTRL_ENA);

	bzero(dma->command_bufs[cmdi], HIFN_MAX_COMMAND);
	*(struct hifn_base_command *)dma->command_bufs[cmdi] = rc;

	dma->srcr[srci].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
	    offsetof(struct hifn_dma, test_src));
	dma->test_src = 0;
	dma->dstr[dsti].p =  htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
	    offsetof(struct hifn_dma, test_dst));
	dma->test_dst = 0;
	dma->cmdr[cmdi].l = htole32(8 | masks);
	dma->srcr[srci].l = htole32(8 | masks);
	dma->dstr[dsti].l = htole32(8 | masks);
	dma->resr[resi].l = htole32(HIFN_MAX_RESULT | masks);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
	    0, sc->sc_dmamap->dm_mapsize,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	for (r = 10000; r >= 0; r--) {
		DELAY(10);
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    0, sc->sc_dmamap->dm_mapsize,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		if ((dma->resr[resi].l & htole32(HIFN_D_VALID)) == 0)
			break;
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    0, sc->sc_dmamap->dm_mapsize,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	}
	if (r == 0) {
		printf("%s: readramaddr -- "
		    "result[%d](addr %d) still valid\n",
		    sc->sc_dv.dv_xname, resi, addr);
		r = -1;
	} else {
		r = 0;
		bcopy(&dma->test_dst, data, sizeof(dma->test_dst));
	}

	WRITE_REG_1(sc, HIFN_1_DMA_CSR,
	    HIFN_DMACSR_C_CTRL_DIS | HIFN_DMACSR_S_CTRL_DIS |
	    HIFN_DMACSR_D_CTRL_DIS | HIFN_DMACSR_R_CTRL_DIS);

	return (r);
}

/*
 * Initialize the descriptor rings.
 */
void 
hifn_init_dma(struct hifn_softc *sc)
{
	struct hifn_dma *dma = sc->sc_dma;
	int i;

	hifn_set_retry(sc);

	/* initialize static pointer values */
	for (i = 0; i < HIFN_D_CMD_RSIZE; i++)
		dma->cmdr[i].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
		    offsetof(struct hifn_dma, command_bufs[i][0]));
	for (i = 0; i < HIFN_D_RES_RSIZE; i++)
		dma->resr[i].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
		    offsetof(struct hifn_dma, result_bufs[i][0]));

	dma->cmdr[HIFN_D_CMD_RSIZE].p =
	    htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
		offsetof(struct hifn_dma, cmdr[0]));
	dma->srcr[HIFN_D_SRC_RSIZE].p =
	    htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
		offsetof(struct hifn_dma, srcr[0]));
	dma->dstr[HIFN_D_DST_RSIZE].p =
	    htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
		offsetof(struct hifn_dma, dstr[0]));
	dma->resr[HIFN_D_RES_RSIZE].p =
	    htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
		offsetof(struct hifn_dma, resr[0]));

	dma->cmdu = dma->srcu = dma->dstu = dma->resu = 0;
	dma->cmdi = dma->srci = dma->dsti = dma->resi = 0;
	dma->cmdk = dma->srck = dma->dstk = dma->resk = 0;
}

/*
 * Writes out the raw command buffer space.  Returns the
 * command buffer size.
 */
u_int
hifn_write_command(struct hifn_command *cmd, u_int8_t *buf)
{
	u_int8_t *buf_pos;
	struct hifn_base_command *base_cmd;
	struct hifn_mac_command *mac_cmd;
	struct hifn_crypt_command *cry_cmd;
	struct hifn_comp_command *comp_cmd;
	int using_mac, using_crypt, using_comp, len, ivlen;
	u_int32_t dlen, slen;

	buf_pos = buf;
	using_mac = cmd->base_masks & HIFN_BASE_CMD_MAC;
	using_crypt = cmd->base_masks & HIFN_BASE_CMD_CRYPT;
	using_comp = cmd->base_masks & HIFN_BASE_CMD_COMP;

	base_cmd = (struct hifn_base_command *)buf_pos;
	base_cmd->masks = htole16(cmd->base_masks);
	slen = cmd->src_map->dm_mapsize;
	if (cmd->sloplen)
		dlen = cmd->dst_map->dm_mapsize - cmd->sloplen +
		    sizeof(u_int32_t);
	else
		dlen = cmd->dst_map->dm_mapsize;
	base_cmd->total_source_count = htole16(slen & HIFN_BASE_CMD_LENMASK_LO);
	base_cmd->total_dest_count = htole16(dlen & HIFN_BASE_CMD_LENMASK_LO);
	dlen >>= 16;
	slen >>= 16;
	base_cmd->session_num = htole16(
	    ((slen << HIFN_BASE_CMD_SRCLEN_S) & HIFN_BASE_CMD_SRCLEN_M) |
	    ((dlen << HIFN_BASE_CMD_DSTLEN_S) & HIFN_BASE_CMD_DSTLEN_M));
	buf_pos += sizeof(struct hifn_base_command);

	if (using_comp) {
		comp_cmd = (struct hifn_comp_command *)buf_pos;
		dlen = cmd->compcrd->crd_len;
		comp_cmd->source_count = htole16(dlen & 0xffff);
		dlen >>= 16;
		comp_cmd->masks = htole16(cmd->comp_masks |
		    ((dlen << HIFN_COMP_CMD_SRCLEN_S) & HIFN_COMP_CMD_SRCLEN_M));
		comp_cmd->header_skip = htole16(cmd->compcrd->crd_skip);
		comp_cmd->reserved = 0;
		buf_pos += sizeof(struct hifn_comp_command);
	}

	if (using_mac) {
		mac_cmd = (struct hifn_mac_command *)buf_pos;
		dlen = cmd->maccrd->crd_len;
		mac_cmd->source_count = htole16(dlen & 0xffff);
		dlen >>= 16;
		mac_cmd->masks = htole16(cmd->mac_masks |
		    ((dlen << HIFN_MAC_CMD_SRCLEN_S) & HIFN_MAC_CMD_SRCLEN_M));
		mac_cmd->header_skip = htole16(cmd->maccrd->crd_skip);
		mac_cmd->reserved = 0;
		buf_pos += sizeof(struct hifn_mac_command);
	}

	if (using_crypt) {
		cry_cmd = (struct hifn_crypt_command *)buf_pos;
		dlen = cmd->enccrd->crd_len;
		cry_cmd->source_count = htole16(dlen & 0xffff);
		dlen >>= 16;
		cry_cmd->masks = htole16(cmd->cry_masks |
		    ((dlen << HIFN_CRYPT_CMD_SRCLEN_S) & HIFN_CRYPT_CMD_SRCLEN_M));
		cry_cmd->header_skip = htole16(cmd->enccrd->crd_skip);
		cry_cmd->reserved = 0;
		buf_pos += sizeof(struct hifn_crypt_command);
	}

	if (using_mac && cmd->mac_masks & HIFN_MAC_CMD_NEW_KEY) {
		bcopy(cmd->mac, buf_pos, HIFN_MAC_KEY_LENGTH);
		buf_pos += HIFN_MAC_KEY_LENGTH;
	}

	if (using_crypt && cmd->cry_masks & HIFN_CRYPT_CMD_NEW_KEY) {
		switch (cmd->cry_masks & HIFN_CRYPT_CMD_ALG_MASK) {
		case HIFN_CRYPT_CMD_ALG_3DES:
			bcopy(cmd->ck, buf_pos, HIFN_3DES_KEY_LENGTH);
			buf_pos += HIFN_3DES_KEY_LENGTH;
			break;
		case HIFN_CRYPT_CMD_ALG_DES:
			bcopy(cmd->ck, buf_pos, HIFN_DES_KEY_LENGTH);
			buf_pos += HIFN_DES_KEY_LENGTH;
			break;
		case HIFN_CRYPT_CMD_ALG_RC4:
			len = 256;
			do {
				int clen;

				clen = MIN(cmd->cklen, len);
				bcopy(cmd->ck, buf_pos, clen);
				len -= clen;
				buf_pos += clen;
			} while (len > 0);
			bzero(buf_pos, 4);
			buf_pos += 4;
			break;
		case HIFN_CRYPT_CMD_ALG_AES:
			/*
			 * AES key are variable 128, 192 and
			 * 256 bits (16, 24 and 32 bytes).
			 */
			bcopy(cmd->ck, buf_pos, cmd->cklen);
			buf_pos += cmd->cklen;
			break;
		}
	}

	if (using_crypt && cmd->cry_masks & HIFN_CRYPT_CMD_NEW_IV) {
		if ((cmd->cry_masks & HIFN_CRYPT_CMD_ALG_MASK) ==
		    HIFN_CRYPT_CMD_ALG_AES)
			ivlen = HIFN_AES_IV_LENGTH;
		else
			ivlen = HIFN_IV_LENGTH;
		bcopy(cmd->iv, buf_pos, ivlen);
		buf_pos += ivlen;
	}

	if ((cmd->base_masks & (HIFN_BASE_CMD_MAC | HIFN_BASE_CMD_CRYPT |
	    HIFN_BASE_CMD_COMP)) == 0) {
		bzero(buf_pos, 8);
		buf_pos += 8;
	}

	return (buf_pos - buf);
}

int
hifn_dmamap_aligned(bus_dmamap_t map)
{
	int i;

	for (i = 0; i < map->dm_nsegs; i++) {
		if (map->dm_segs[i].ds_addr & 3)
			return (0);
		if ((i != (map->dm_nsegs - 1)) &&
		    (map->dm_segs[i].ds_len & 3))
			return (0);
	}
	return (1);
}

int
hifn_dmamap_load_dst(struct hifn_softc *sc, struct hifn_command *cmd)
{
	struct hifn_dma *dma = sc->sc_dma;
	bus_dmamap_t map = cmd->dst_map;
	u_int32_t p, l;
	int idx, used = 0, i;

	idx = dma->dsti;
	for (i = 0; i < map->dm_nsegs - 1; i++) {
		dma->dstr[idx].p = htole32(map->dm_segs[i].ds_addr);
		dma->dstr[idx].l = htole32(HIFN_D_VALID |
		    HIFN_D_MASKDONEIRQ | map->dm_segs[i].ds_len);
		HIFN_DSTR_SYNC(sc, idx,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
		used++;

		if (++idx == HIFN_D_DST_RSIZE) {
			dma->dstr[idx].l = htole32(HIFN_D_VALID |
			    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
			HIFN_DSTR_SYNC(sc, idx,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			idx = 0;
		}
	}

	if (cmd->sloplen == 0) {
		p = map->dm_segs[i].ds_addr;
		l = HIFN_D_VALID | HIFN_D_MASKDONEIRQ | HIFN_D_LAST |
		    map->dm_segs[i].ds_len;
	} else {
		p = sc->sc_dmamap->dm_segs[0].ds_addr +
		    offsetof(struct hifn_dma, slop[cmd->slopidx]);
		l = HIFN_D_VALID | HIFN_D_MASKDONEIRQ | HIFN_D_LAST |
		    sizeof(u_int32_t);

		if ((map->dm_segs[i].ds_len - cmd->sloplen) != 0) {
			dma->dstr[idx].p = htole32(map->dm_segs[i].ds_addr);
			dma->dstr[idx].l = htole32(HIFN_D_VALID |
			    HIFN_D_MASKDONEIRQ |
			    (map->dm_segs[i].ds_len - cmd->sloplen));
			HIFN_DSTR_SYNC(sc, idx,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			used++;

			if (++idx == HIFN_D_DST_RSIZE) {
				dma->dstr[idx].l = htole32(HIFN_D_VALID |
				    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
				HIFN_DSTR_SYNC(sc, idx,
				    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
				idx = 0;
			}
		}
	}
	dma->dstr[idx].p = htole32(p);
	dma->dstr[idx].l = htole32(l);
	HIFN_DSTR_SYNC(sc, idx, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	used++;

	if (++idx == HIFN_D_DST_RSIZE) {
		dma->dstr[idx].l = htole32(HIFN_D_VALID | HIFN_D_JUMP |
		    HIFN_D_MASKDONEIRQ);
		HIFN_DSTR_SYNC(sc, idx,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
		idx = 0;
	}

	dma->dsti = idx;
	dma->dstu += used;
	return (idx);
}

int
hifn_dmamap_load_src(struct hifn_softc *sc, struct hifn_command *cmd)
{
	struct hifn_dma *dma = sc->sc_dma;
	bus_dmamap_t map = cmd->src_map;
	int idx, i;
	u_int32_t last = 0;

	idx = dma->srci;
	for (i = 0; i < map->dm_nsegs; i++) {
		if (i == map->dm_nsegs - 1)
			last = HIFN_D_LAST;

		dma->srcr[idx].p = htole32(map->dm_segs[i].ds_addr);
		dma->srcr[idx].l = htole32(map->dm_segs[i].ds_len |
		    HIFN_D_VALID | HIFN_D_MASKDONEIRQ | last);
		HIFN_SRCR_SYNC(sc, idx,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

		if (++idx == HIFN_D_SRC_RSIZE) {
			dma->srcr[idx].l = htole32(HIFN_D_VALID |
			    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
			HIFN_SRCR_SYNC(sc, HIFN_D_SRC_RSIZE,
			    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
			idx = 0;
		}
	}
	dma->srci = idx;
	dma->srcu += map->dm_nsegs;
	return (idx);
}

int 
hifn_crypto(struct hifn_softc *sc, struct hifn_command *cmd,
    struct cryptop *crp)
{
	struct	hifn_dma *dma = sc->sc_dma;
	u_int32_t cmdlen;
	int cmdi, resi, s, err = 0;

	if (bus_dmamap_create(sc->sc_dmat, HIFN_MAX_DMALEN, MAX_SCATTER,
	    HIFN_MAX_SEGLEN, 0, BUS_DMA_NOWAIT, &cmd->src_map))
		return (ENOMEM);

	if (crp->crp_flags & CRYPTO_F_IMBUF) {
		if (bus_dmamap_load_mbuf(sc->sc_dmat, cmd->src_map,
		    cmd->srcu.src_m, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
			goto err_srcmap1;
		}
	} else if (crp->crp_flags & CRYPTO_F_IOV) {
		if (bus_dmamap_load_uio(sc->sc_dmat, cmd->src_map,
		    cmd->srcu.src_io, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
			goto err_srcmap1;
		}
	} else {
		err = EINVAL;
		goto err_srcmap1;
	}

	if (hifn_dmamap_aligned(cmd->src_map)) {
		cmd->sloplen = cmd->src_map->dm_mapsize & 3;
		if (crp->crp_flags & CRYPTO_F_IOV)
			cmd->dstu.dst_io = cmd->srcu.src_io;
		else if (crp->crp_flags & CRYPTO_F_IMBUF)
			cmd->dstu.dst_m = cmd->srcu.src_m;
		cmd->dst_map = cmd->src_map;
	} else {
		if (crp->crp_flags & CRYPTO_F_IOV) {
			err = EINVAL;
			goto err_srcmap;
		} else if (crp->crp_flags & CRYPTO_F_IMBUF) {
			int totlen, len;
			struct mbuf *m, *m0, *mlast;

			totlen = cmd->src_map->dm_mapsize;
			if (cmd->srcu.src_m->m_flags & M_PKTHDR) {
				len = MHLEN;
				MGETHDR(m0, M_DONTWAIT, MT_DATA);
			} else {
				len = MLEN;
				MGET(m0, M_DONTWAIT, MT_DATA);
			}
			if (m0 == NULL) {
				err = ENOMEM;
				goto err_srcmap;
			}
			if (len == MHLEN) {
				err = m_dup_pkthdr(m0, cmd->srcu.src_m,
				    M_DONTWAIT);
				if (err) {
					m_free(m0);
					goto err_srcmap;
				}
			}
			if (totlen >= MINCLSIZE) {
				MCLGET(m0, M_DONTWAIT);
				if (m0->m_flags & M_EXT)
					len = MCLBYTES;
			}
			totlen -= len;
			m0->m_pkthdr.len = m0->m_len = len;
			mlast = m0;

			while (totlen > 0) {
				MGET(m, M_DONTWAIT, MT_DATA);
				if (m == NULL) {
					err = ENOMEM;
					m_freem(m0);
					goto err_srcmap;
				}
				len = MLEN;
				if (totlen >= MINCLSIZE) {
					MCLGET(m, M_DONTWAIT);
					if (m->m_flags & M_EXT)
						len = MCLBYTES;
				}

				m->m_len = len;
				if (m0->m_flags & M_PKTHDR)
					m0->m_pkthdr.len += len;
				totlen -= len;

				mlast->m_next = m;
				mlast = m;
			}
			cmd->dstu.dst_m = m0;
		}
	}

	if (cmd->dst_map == NULL) {
		if (bus_dmamap_create(sc->sc_dmat,
		    HIFN_MAX_SEGLEN * MAX_SCATTER, MAX_SCATTER,
		    HIFN_MAX_SEGLEN, 0, BUS_DMA_NOWAIT, &cmd->dst_map)) {
			err = ENOMEM;
			goto err_srcmap;
		}
		if (crp->crp_flags & CRYPTO_F_IMBUF) {
			if (bus_dmamap_load_mbuf(sc->sc_dmat, cmd->dst_map,
			    cmd->dstu.dst_m, BUS_DMA_NOWAIT)) {
				err = ENOMEM;
				goto err_dstmap1;
			}
		} else if (crp->crp_flags & CRYPTO_F_IOV) {
			if (bus_dmamap_load_uio(sc->sc_dmat, cmd->dst_map,
			    cmd->dstu.dst_io, BUS_DMA_NOWAIT)) {
				err = ENOMEM;
				goto err_dstmap1;
			}
		}
	}

#ifdef HIFN_DEBUG
	printf("%s: Entering cmd: stat %8x ien %8x u %d/%d/%d/%d n %d/%d\n",
	    sc->sc_dv.dv_xname,
	    READ_REG_1(sc, HIFN_1_DMA_CSR), READ_REG_1(sc, HIFN_1_DMA_IER),
	    dma->cmdu, dma->srcu, dma->dstu, dma->resu,
	    cmd->src_map->dm_nsegs, cmd->dst_map->dm_nsegs);
#endif

	if (cmd->src_map == cmd->dst_map)
		bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
		    0, cmd->src_map->dm_mapsize,
		    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
	else {
		bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
		    0, cmd->src_map->dm_mapsize, BUS_DMASYNC_PREWRITE);
		bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
		    0, cmd->dst_map->dm_mapsize, BUS_DMASYNC_PREREAD);
	}

	s = splnet();

	/*
	 * need 1 cmd, and 1 res
	 * need N src, and N dst
	 */
	if ((dma->cmdu + 1) > HIFN_D_CMD_RSIZE ||
	    (dma->resu + 1) > HIFN_D_RES_RSIZE) {
		splx(s);
		err = ENOMEM;
		goto err_dstmap;
	}
	if ((dma->srcu + cmd->src_map->dm_nsegs) > HIFN_D_SRC_RSIZE ||
	    (dma->dstu + cmd->dst_map->dm_nsegs + 1) > HIFN_D_DST_RSIZE) {
		splx(s);
		err = ENOMEM;
		goto err_dstmap;
	}

	if (dma->cmdi == HIFN_D_CMD_RSIZE) {
		dma->cmdi = 0;
		dma->cmdr[HIFN_D_CMD_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_CMDR_SYNC(sc, HIFN_D_CMD_RSIZE,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	cmdi = dma->cmdi++;
	cmdlen = hifn_write_command(cmd, dma->command_bufs[cmdi]);
	HIFN_CMD_SYNC(sc, cmdi, BUS_DMASYNC_PREWRITE);

	/* .p for command/result already set */
	dma->cmdr[cmdi].l = htole32(cmdlen | HIFN_D_VALID | HIFN_D_LAST |
	    HIFN_D_MASKDONEIRQ);
	HIFN_CMDR_SYNC(sc, cmdi,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	dma->cmdu++;
	if (sc->sc_c_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_C_CTRL_ENA);
		sc->sc_c_busy = 1;
		SET_LED(sc, HIFN_MIPSRST_LED0);
	}

	/*
	 * Always enable the command wait interrupt.  We are obviously
	 * missing an interrupt or two somewhere. Enabling the command wait
	 * interrupt will guarantee we get called periodically until all
	 * of the queues are drained and thus work around this.
	 */
	sc->sc_dmaier |= HIFN_DMAIER_C_WAIT;
	WRITE_REG_1(sc, HIFN_1_DMA_IER, sc->sc_dmaier);

	hifnstats.hst_ipackets++;
	hifnstats.hst_ibytes += cmd->src_map->dm_mapsize;

	hifn_dmamap_load_src(sc, cmd);
	if (sc->sc_s_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_S_CTRL_ENA);
		sc->sc_s_busy = 1;
		SET_LED(sc, HIFN_MIPSRST_LED1);
	}

	/*
	 * Unlike other descriptors, we don't mask done interrupt from
	 * result descriptor.
	 */
#ifdef HIFN_DEBUG
	printf("load res\n");
#endif
	if (dma->resi == HIFN_D_RES_RSIZE) {
		dma->resi = 0;
		dma->resr[HIFN_D_RES_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_RESR_SYNC(sc, HIFN_D_RES_RSIZE,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	}
	resi = dma->resi++;
	dma->hifn_commands[resi] = cmd;
	HIFN_RES_SYNC(sc, resi, BUS_DMASYNC_PREREAD);
	dma->resr[resi].l = htole32(HIFN_MAX_RESULT |
	    HIFN_D_VALID | HIFN_D_LAST);
	HIFN_RESR_SYNC(sc, resi,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	dma->resu++;
	if (sc->sc_r_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_R_CTRL_ENA);
		sc->sc_r_busy = 1;
		SET_LED(sc, HIFN_MIPSRST_LED2);
	}

	if (cmd->sloplen)
		cmd->slopidx = resi;

	hifn_dmamap_load_dst(sc, cmd);

	if (sc->sc_d_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_D_CTRL_ENA);
		sc->sc_d_busy = 1;
	}

#ifdef HIFN_DEBUG
	printf("%s: command: stat %8x ier %8x\n",
	    sc->sc_dv.dv_xname,
	    READ_REG_1(sc, HIFN_1_DMA_CSR), READ_REG_1(sc, HIFN_1_DMA_IER));
#endif

	sc->sc_active = 5;
	cmd->cmd_callback = hifn_callback;
	splx(s);
	return (err);		/* success */

err_dstmap:
	if (cmd->src_map != cmd->dst_map)
		bus_dmamap_unload(sc->sc_dmat, cmd->dst_map);
err_dstmap1:
	if (cmd->src_map != cmd->dst_map)
		bus_dmamap_destroy(sc->sc_dmat, cmd->dst_map);
err_srcmap:
	if (crp->crp_flags & CRYPTO_F_IMBUF &&
	    cmd->srcu.src_m != cmd->dstu.dst_m)
		m_freem(cmd->dstu.dst_m);
	bus_dmamap_unload(sc->sc_dmat, cmd->src_map);
err_srcmap1:
	bus_dmamap_destroy(sc->sc_dmat, cmd->src_map);
	return (err);
}

void
hifn_tick(void *vsc)
{
	struct hifn_softc *sc = vsc;
	int s;

	s = splnet();
	if (sc->sc_active == 0) {
		struct hifn_dma *dma = sc->sc_dma;
		u_int32_t r = 0;

		if (dma->cmdu == 0 && sc->sc_c_busy) {
			sc->sc_c_busy = 0;
			r |= HIFN_DMACSR_C_CTRL_DIS;
			CLR_LED(sc, HIFN_MIPSRST_LED0);
		}
		if (dma->srcu == 0 && sc->sc_s_busy) {
			sc->sc_s_busy = 0;
			r |= HIFN_DMACSR_S_CTRL_DIS;
			CLR_LED(sc, HIFN_MIPSRST_LED1);
		}
		if (dma->dstu == 0 && sc->sc_d_busy) {
			sc->sc_d_busy = 0;
			r |= HIFN_DMACSR_D_CTRL_DIS;
		}
		if (dma->resu == 0 && sc->sc_r_busy) {
			sc->sc_r_busy = 0;
			r |= HIFN_DMACSR_R_CTRL_DIS;
			CLR_LED(sc, HIFN_MIPSRST_LED2);
		}
		if (r)
			WRITE_REG_1(sc, HIFN_1_DMA_CSR, r);
	}
	else
		sc->sc_active--;
	splx(s);
	timeout_add_sec(&sc->sc_tickto, 1);
}

int 
hifn_intr(void *arg)
{
	struct hifn_softc *sc = arg;
	struct hifn_dma *dma = sc->sc_dma;
	u_int32_t dmacsr, restart;
	int i, u;

	dmacsr = READ_REG_1(sc, HIFN_1_DMA_CSR);

#ifdef HIFN_DEBUG
	printf("%s: irq: stat %08x ien %08x u %d/%d/%d/%d\n",
	    sc->sc_dv.dv_xname,
	    dmacsr, READ_REG_1(sc, HIFN_1_DMA_IER),
	    dma->cmdu, dma->srcu, dma->dstu, dma->resu);
#endif

	/* Nothing in the DMA unit interrupted */
	if ((dmacsr & sc->sc_dmaier) == 0)
		return (0);

	WRITE_REG_1(sc, HIFN_1_DMA_CSR, dmacsr & sc->sc_dmaier);

	if (dmacsr & HIFN_DMACSR_ENGINE)
		WRITE_REG_0(sc, HIFN_0_PUISR, READ_REG_0(sc, HIFN_0_PUISR));

	if ((sc->sc_flags & HIFN_HAS_PUBLIC) &&
	    (dmacsr & HIFN_DMACSR_PUBDONE))
		WRITE_REG_1(sc, HIFN_1_PUB_STATUS,
		    READ_REG_1(sc, HIFN_1_PUB_STATUS) | HIFN_PUBSTS_DONE);

	restart = dmacsr & (HIFN_DMACSR_R_OVER | HIFN_DMACSR_D_OVER);
	if (restart)
		printf("%s: overrun %x\n", sc->sc_dv.dv_xname, dmacsr);

	if (sc->sc_flags & HIFN_IS_7811) {
		if (dmacsr & HIFN_DMACSR_ILLR)
			printf("%s: illegal read\n", sc->sc_dv.dv_xname);
		if (dmacsr & HIFN_DMACSR_ILLW)
			printf("%s: illegal write\n", sc->sc_dv.dv_xname);
	}

	restart = dmacsr & (HIFN_DMACSR_C_ABORT | HIFN_DMACSR_S_ABORT |
	    HIFN_DMACSR_D_ABORT | HIFN_DMACSR_R_ABORT);
	if (restart) {
		printf("%s: abort, resetting.\n", sc->sc_dv.dv_xname);
		hifnstats.hst_abort++;
		hifn_abort(sc);
		return (1);
	}

	if ((dmacsr & HIFN_DMACSR_C_WAIT) && (dma->resu == 0)) {
		/*
		 * If no slots to process and we receive a "waiting on
		 * command" interrupt, we disable the "waiting on command"
		 * (by clearing it).
		 */
		sc->sc_dmaier &= ~HIFN_DMAIER_C_WAIT;
		WRITE_REG_1(sc, HIFN_1_DMA_IER, sc->sc_dmaier);
	}

	/* clear the rings */
	i = dma->resk;
	while (dma->resu != 0) {
		HIFN_RESR_SYNC(sc, i,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		if (dma->resr[i].l & htole32(HIFN_D_VALID)) {
			HIFN_RESR_SYNC(sc, i,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			break;
		}

		if (i != HIFN_D_RES_RSIZE) {
			struct hifn_command *cmd;

			HIFN_RES_SYNC(sc, i, BUS_DMASYNC_POSTREAD);
			cmd = dma->hifn_commands[i];

			(*cmd->cmd_callback)(sc, cmd, dma->result_bufs[i]);
			hifnstats.hst_opackets++;
		}

		if (++i == (HIFN_D_RES_RSIZE + 1))
			i = 0;
		else
			dma->resu--;
	}
	dma->resk = i;

	i = dma->srck; u = dma->srcu;
	while (u != 0) {
		HIFN_SRCR_SYNC(sc, i,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		if (dma->srcr[i].l & htole32(HIFN_D_VALID)) {
			HIFN_SRCR_SYNC(sc, i,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			break;
		}
		if (++i == (HIFN_D_SRC_RSIZE + 1))
			i = 0;
		else
			u--;
	}
	dma->srck = i; dma->srcu = u;

	i = dma->cmdk; u = dma->cmdu;
	while (u != 0) {
		HIFN_CMDR_SYNC(sc, i,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		if (dma->cmdr[i].l & htole32(HIFN_D_VALID)) {
			HIFN_CMDR_SYNC(sc, i,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			break;
		}
		if (i != HIFN_D_CMD_RSIZE) {
			u--;
			HIFN_CMD_SYNC(sc, i, BUS_DMASYNC_POSTWRITE);
		}
		if (++i == (HIFN_D_CMD_RSIZE + 1))
			i = 0;
	}
	dma->cmdk = i; dma->cmdu = u;

	return (1);
}

/*
 * Allocate a new 'session' and return an encoded session id.  'sidp'
 * contains our registration id, and should contain an encoded session
 * id on successful allocation.
 */
int
hifn_newsession(u_int32_t *sidp, struct cryptoini *cri)
{
	struct cryptoini *c;
	struct hifn_softc *sc = NULL;
	int i, mac = 0, cry = 0, comp = 0, sesn;
	struct hifn_session *ses = NULL;

	if (sidp == NULL || cri == NULL)
		return (EINVAL);

	for (i = 0; i < hifn_cd.cd_ndevs; i++) {
		sc = hifn_cd.cd_devs[i];
		if (sc == NULL)
			break;
		if (sc->sc_cid == (*sidp))
			break;
	}
	if (sc == NULL)
		return (EINVAL);

	if (sc->sc_sessions == NULL) {
		ses = sc->sc_sessions = (struct hifn_session *)malloc(
		    sizeof(*ses), M_DEVBUF, M_NOWAIT);
		if (ses == NULL)
			return (ENOMEM);
		sesn = 0;
		sc->sc_nsessions = 1;
	} else {
		for (sesn = 0; sesn < sc->sc_nsessions; sesn++) {
			if (!sc->sc_sessions[sesn].hs_used) {
				ses = &sc->sc_sessions[sesn];
				break;
			}
		}

		if (ses == NULL) {
			sesn = sc->sc_nsessions;
			ses = mallocarray((sesn + 1), sizeof(*ses),
			    M_DEVBUF, M_NOWAIT);
			if (ses == NULL)
				return (ENOMEM);
			bcopy(sc->sc_sessions, ses, sesn * sizeof(*ses));
			explicit_bzero(sc->sc_sessions, sesn * sizeof(*ses));
			free(sc->sc_sessions, M_DEVBUF, 0);
			sc->sc_sessions = ses;
			ses = &sc->sc_sessions[sesn];
			sc->sc_nsessions++;
		}
	}
	bzero(ses, sizeof(*ses));

	for (c = cri; c != NULL; c = c->cri_next) {
		switch (c->cri_alg) {
		case CRYPTO_MD5_HMAC:
		case CRYPTO_SHA1_HMAC:
			if (mac)
				return (EINVAL);
			mac = 1;
			break;
		case CRYPTO_3DES_CBC:
		case CRYPTO_AES_CBC:
			if (cry)
				return (EINVAL);
			cry = 1;
			break;
		case CRYPTO_LZS_COMP:
			if (comp)
				return (EINVAL);
			comp = 1;
			break;
		default:
			return (EINVAL);
		}
	}
	if (mac == 0 && cry == 0 && comp == 0)
		return (EINVAL);

	/*
	 * XXX only want to support compression without chaining to
	 * MAC/crypt engine right now
	 */
	if ((comp && mac) || (comp && cry))
		return (EINVAL);

	*sidp = HIFN_SID(sc->sc_dv.dv_unit, sesn);
	ses->hs_used = 1;

	return (0);
}

/*
 * Deallocate a session.
 * XXX this routine should run a zero'd mac/encrypt key into context ram.
 * XXX to blow away any keys already stored there.
 */
int
hifn_freesession(u_int64_t tid)
{
	struct hifn_softc *sc;
	int card, session;
	u_int32_t sid = ((u_int32_t)tid) & 0xffffffff;

	card = HIFN_CARD(sid);
	if (card >= hifn_cd.cd_ndevs || hifn_cd.cd_devs[card] == NULL)
		return (EINVAL);

	sc = hifn_cd.cd_devs[card];
	session = HIFN_SESSION(sid);
	if (session >= sc->sc_nsessions)
		return (EINVAL);

	bzero(&sc->sc_sessions[session], sizeof(sc->sc_sessions[session]));
	return (0);
}

int
hifn_process(struct cryptop *crp)
{
	struct hifn_command *cmd = NULL;
	int card, session, err = 0, ivlen;
	struct hifn_softc *sc;
	struct cryptodesc *crd1, *crd2 = NULL, *maccrd, *enccrd;

	if (crp == NULL || crp->crp_callback == NULL) {
		hifnstats.hst_invalid++;
		return (EINVAL);
	}

	if (crp->crp_ilen == 0) {
		err = EINVAL;
		goto errout;
	}

	card = HIFN_CARD(crp->crp_sid);
	if (card >= hifn_cd.cd_ndevs || hifn_cd.cd_devs[card] == NULL) {
		err = EINVAL;
		goto errout;
	}

	sc = hifn_cd.cd_devs[card];
	session = HIFN_SESSION(crp->crp_sid);
	if (session >= sc->sc_nsessions) {
		err = EINVAL;
		goto errout;
	}

	cmd = malloc(sizeof(*cmd), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (cmd == NULL) {
		err = ENOMEM;
		goto errout;
	}

	if (crp->crp_flags & CRYPTO_F_IMBUF) {
		cmd->srcu.src_m = (struct mbuf *)crp->crp_buf;
		cmd->dstu.dst_m = (struct mbuf *)crp->crp_buf;
	} else if (crp->crp_flags & CRYPTO_F_IOV) {
		cmd->srcu.src_io = (struct uio *)crp->crp_buf;
		cmd->dstu.dst_io = (struct uio *)crp->crp_buf;
	} else {
		err = EINVAL;
		goto errout;	/* XXX we don't handle contiguous buffers! */
	}

	if (crp->crp_ndesc < 1) {
		err = EINVAL;
		goto errout;
	}
	crd1 = &crp->crp_desc[0];
	if (crp->crp_ndesc >= 2)
		crd2 = &crp->crp_desc[1];

	if (crd2 == NULL) {
		if (crd1->crd_alg == CRYPTO_MD5_HMAC ||
		    crd1->crd_alg == CRYPTO_SHA1_HMAC) {
			maccrd = crd1;
			enccrd = NULL;
		} else if (crd1->crd_alg == CRYPTO_3DES_CBC ||
		    crd1->crd_alg == CRYPTO_AES_CBC) {
			if ((crd1->crd_flags & CRD_F_ENCRYPT) == 0)
				cmd->base_masks |= HIFN_BASE_CMD_DECODE;
			maccrd = NULL;
			enccrd = crd1;
		} else if (crd1->crd_alg == CRYPTO_LZS_COMP) {
			return (hifn_compression(sc, crp, cmd));
		} else {
			err = EINVAL;
			goto errout;
		}
	} else {
		if ((crd1->crd_alg == CRYPTO_MD5_HMAC ||
		     crd1->crd_alg == CRYPTO_SHA1_HMAC) &&
		    (crd2->crd_alg == CRYPTO_3DES_CBC ||
		     crd2->crd_alg == CRYPTO_AES_CBC) &&
		    ((crd2->crd_flags & CRD_F_ENCRYPT) == 0)) {
			cmd->base_masks = HIFN_BASE_CMD_DECODE;
			maccrd = crd1;
			enccrd = crd2;
		} else if ((crd1->crd_alg == CRYPTO_3DES_CBC ||
		     crd1->crd_alg == CRYPTO_AES_CBC) &&
		    (crd2->crd_alg == CRYPTO_MD5_HMAC ||
		     crd2->crd_alg == CRYPTO_SHA1_HMAC) &&
		    (crd1->crd_flags & CRD_F_ENCRYPT)) {
			enccrd = crd1;
			maccrd = crd2;
		} else {
			/*
			 * We cannot order the 7751 as requested
			 */
			err = EINVAL;
			goto errout;
		}
	}

	if (enccrd) {
		cmd->enccrd = enccrd;
		cmd->base_masks |= HIFN_BASE_CMD_CRYPT;
		switch (enccrd->crd_alg) {
		case CRYPTO_3DES_CBC:
			cmd->cry_masks |= HIFN_CRYPT_CMD_ALG_3DES |
			    HIFN_CRYPT_CMD_MODE_CBC |
			    HIFN_CRYPT_CMD_NEW_IV;
			break;
		case CRYPTO_AES_CBC:
			cmd->cry_masks |= HIFN_CRYPT_CMD_ALG_AES |
			    HIFN_CRYPT_CMD_MODE_CBC |
			    HIFN_CRYPT_CMD_NEW_IV;
			break;
		default:
			err = EINVAL;
			goto errout;
		}
		ivlen = ((enccrd->crd_alg == CRYPTO_AES_CBC) ?
		    HIFN_AES_IV_LENGTH : HIFN_IV_LENGTH);
		if (enccrd->crd_flags & CRD_F_ENCRYPT) {
			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
				bcopy(enccrd->crd_iv, cmd->iv, ivlen);
			else
				arc4random_buf(cmd->iv, ivlen);

			if ((enccrd->crd_flags & CRD_F_IV_PRESENT) == 0) {
				if (crp->crp_flags & CRYPTO_F_IMBUF)
					err = m_copyback(cmd->srcu.src_m,
					    enccrd->crd_inject,
					    ivlen, cmd->iv, M_NOWAIT);
				else if (crp->crp_flags & CRYPTO_F_IOV)
					cuio_copyback(cmd->srcu.src_io,
					    enccrd->crd_inject,
					    ivlen, cmd->iv);
				if (err)
					goto errout;
			}
		} else {
			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
				bcopy(enccrd->crd_iv, cmd->iv, ivlen);
			else if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copydata(cmd->srcu.src_m,
				    enccrd->crd_inject, ivlen, cmd->iv);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copydata(cmd->srcu.src_io,
				    enccrd->crd_inject, ivlen, cmd->iv);
		}

		cmd->ck = enccrd->crd_key;
		cmd->cklen = enccrd->crd_klen >> 3;
		cmd->cry_masks |= HIFN_CRYPT_CMD_NEW_KEY;

		/*
		 * Need to specify the size for the AES key in the masks.
		 */
		if ((cmd->cry_masks & HIFN_CRYPT_CMD_ALG_MASK) ==
		    HIFN_CRYPT_CMD_ALG_AES) {
			switch (cmd->cklen) {
			case 16:
				cmd->cry_masks |= HIFN_CRYPT_CMD_KSZ_128;
				break;
			case 24:
				cmd->cry_masks |= HIFN_CRYPT_CMD_KSZ_192;
				break;
			case 32:
				cmd->cry_masks |= HIFN_CRYPT_CMD_KSZ_256;
				break;
			default:
				err = EINVAL;
				goto errout;
			}
		}
	}

	if (maccrd) {
		cmd->maccrd = maccrd;
		cmd->base_masks |= HIFN_BASE_CMD_MAC;

		switch (maccrd->crd_alg) {
		case CRYPTO_MD5_HMAC:
			cmd->mac_masks |= HIFN_MAC_CMD_ALG_MD5 |
			    HIFN_MAC_CMD_RESULT | HIFN_MAC_CMD_MODE_HMAC |
			    HIFN_MAC_CMD_POS_IPSEC | HIFN_MAC_CMD_TRUNC;
			break;
		case CRYPTO_SHA1_HMAC:
			cmd->mac_masks |= HIFN_MAC_CMD_ALG_SHA1 |
			    HIFN_MAC_CMD_RESULT | HIFN_MAC_CMD_MODE_HMAC |
			    HIFN_MAC_CMD_POS_IPSEC | HIFN_MAC_CMD_TRUNC;
			break;
		}

		if (maccrd->crd_alg == CRYPTO_SHA1_HMAC ||
		     maccrd->crd_alg == CRYPTO_MD5_HMAC) {
			cmd->mac_masks |= HIFN_MAC_CMD_NEW_KEY;
			bcopy(maccrd->crd_key, cmd->mac, maccrd->crd_klen >> 3);
			bzero(cmd->mac + (maccrd->crd_klen >> 3),
			    HIFN_MAC_KEY_LENGTH - (maccrd->crd_klen >> 3));
		}
	}

	cmd->crp = crp;
	cmd->session_num = session;
	cmd->softc = sc;

	err = hifn_crypto(sc, cmd, crp);
	if (!err)
		return 0;

errout:
	if (cmd != NULL) {
		explicit_bzero(cmd, sizeof(*cmd));
		free(cmd, M_DEVBUF, sizeof *cmd);
	}
	if (err == EINVAL)
		hifnstats.hst_invalid++;
	else
		hifnstats.hst_nomem++;
	crp->crp_etype = err;
	crypto_done(crp);
	return (0);
}

void
hifn_abort(struct hifn_softc *sc)
{
	struct hifn_dma *dma = sc->sc_dma;
	struct hifn_command *cmd;
	struct cryptop *crp;
	int i, u;

	i = dma->resk; u = dma->resu;
	while (u != 0) {
		cmd = dma->hifn_commands[i];
		crp = cmd->crp;

		if ((dma->resr[i].l & htole32(HIFN_D_VALID)) == 0) {
			/* Salvage what we can. */
			hifnstats.hst_opackets++;
			(*cmd->cmd_callback)(sc, cmd, dma->result_bufs[i]);
		} else {
			if (cmd->src_map == cmd->dst_map)
				bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
				    0, cmd->src_map->dm_mapsize,
				    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
			else {
				bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
				    0, cmd->src_map->dm_mapsize,
				    BUS_DMASYNC_POSTWRITE);
				bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
				    0, cmd->dst_map->dm_mapsize,
				    BUS_DMASYNC_POSTREAD);
			}

			if (cmd->srcu.src_m != cmd->dstu.dst_m) {
				m_freem(cmd->srcu.src_m);
				crp->crp_buf = (caddr_t)cmd->dstu.dst_m;
			}

			/* non-shared buffers cannot be restarted */
			if (cmd->src_map != cmd->dst_map) {
				/*
				 * XXX should be EAGAIN, delayed until
				 * after the reset.
				 */
				crp->crp_etype = ENOMEM;
				bus_dmamap_unload(sc->sc_dmat, cmd->dst_map);
				bus_dmamap_destroy(sc->sc_dmat, cmd->dst_map);
			} else
				crp->crp_etype = ENOMEM;

			bus_dmamap_unload(sc->sc_dmat, cmd->src_map);
			bus_dmamap_destroy(sc->sc_dmat, cmd->src_map);

			explicit_bzero(cmd, sizeof(*cmd));
			free(cmd, M_DEVBUF, sizeof *cmd);
			if (crp->crp_etype != EAGAIN)
				crypto_done(crp);
		}

		if (++i == HIFN_D_RES_RSIZE)
			i = 0;
		u--;
	}
	dma->resk = i; dma->resu = u;

	hifn_reset_board(sc, 1);
	hifn_init_dma(sc);
	hifn_init_pci_registers(sc);
}

void
hifn_callback(struct hifn_softc *sc, struct hifn_command *cmd,
    u_int8_t *resbuf)
{
	struct hifn_dma *dma = sc->sc_dma;
	struct cryptop *crp = cmd->crp;
	struct cryptodesc *crd;
	struct mbuf *m;
	int totlen, i, u;

	if (cmd->src_map == cmd->dst_map)
		bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
		    0, cmd->src_map->dm_mapsize,
		    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
	else {
		bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
		    0, cmd->src_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
		    0, cmd->dst_map->dm_mapsize, BUS_DMASYNC_POSTREAD);
	}

	if (crp->crp_flags & CRYPTO_F_IMBUF) {
		if (cmd->srcu.src_m != cmd->dstu.dst_m) {
			crp->crp_buf = (caddr_t)cmd->dstu.dst_m;
			totlen = cmd->src_map->dm_mapsize;
			for (m = cmd->dstu.dst_m; m != NULL; m = m->m_next) {
				if (totlen < m->m_len) {
					m->m_len = totlen;
					totlen = 0;
				} else
					totlen -= m->m_len;
			}
			cmd->dstu.dst_m->m_pkthdr.len =
			    cmd->srcu.src_m->m_pkthdr.len;
			m_freem(cmd->srcu.src_m);
		}
	}

	if (cmd->sloplen != 0) {
		if (crp->crp_flags & CRYPTO_F_IMBUF)
			crp->crp_etype =
			    m_copyback((struct mbuf *)crp->crp_buf,
			    cmd->src_map->dm_mapsize - cmd->sloplen,
			    cmd->sloplen, &dma->slop[cmd->slopidx],
			    M_NOWAIT);
		else if (crp->crp_flags & CRYPTO_F_IOV)
			cuio_copyback((struct uio *)crp->crp_buf,
			    cmd->src_map->dm_mapsize - cmd->sloplen,
			    cmd->sloplen, &dma->slop[cmd->slopidx]);
		if (crp->crp_etype)
			goto out;
	}

	i = dma->dstk; u = dma->dstu;
	while (u != 0) {
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    offsetof(struct hifn_dma, dstr[i]), sizeof(struct hifn_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		if (dma->dstr[i].l & htole32(HIFN_D_VALID)) {
			bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
			    offsetof(struct hifn_dma, dstr[i]),
			    sizeof(struct hifn_desc),
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			break;
		}
		if (++i == (HIFN_D_DST_RSIZE + 1))
			i = 0;
		else
			u--;
	}
	dma->dstk = i; dma->dstu = u;

	hifnstats.hst_obytes += cmd->dst_map->dm_mapsize;

	if (cmd->base_masks & HIFN_BASE_CMD_MAC) {
		u_int8_t *macbuf;

		macbuf = resbuf + sizeof(struct hifn_base_result);
		if (cmd->base_masks & HIFN_BASE_CMD_COMP)
			macbuf += sizeof(struct hifn_comp_result);
		macbuf += sizeof(struct hifn_mac_result);

		for (i = 0; i < crp->crp_ndesc; i++) {
			int len;

			crd = &crp->crp_desc[i];

			if (crd->crd_alg == CRYPTO_MD5_HMAC ||
			    crd->crd_alg == CRYPTO_SHA1_HMAC)
				len = 12;
			else
				continue;

			if (crp->crp_flags & CRYPTO_F_IMBUF)
				crp->crp_etype =
				    m_copyback((struct mbuf *)crp->crp_buf,
				    crd->crd_inject, len, macbuf, M_NOWAIT);
			else if ((crp->crp_flags & CRYPTO_F_IOV) && crp->crp_mac)
				bcopy((caddr_t)macbuf, crp->crp_mac, len);
			break;
		}
	}

out:
	if (cmd->src_map != cmd->dst_map) {
		bus_dmamap_unload(sc->sc_dmat, cmd->dst_map);
		bus_dmamap_destroy(sc->sc_dmat, cmd->dst_map);
	}
	bus_dmamap_unload(sc->sc_dmat, cmd->src_map);
	bus_dmamap_destroy(sc->sc_dmat, cmd->src_map);
	explicit_bzero(cmd, sizeof(*cmd));
	free(cmd, M_DEVBUF, sizeof *cmd);
	crypto_done(crp);
}

int
hifn_compression(struct hifn_softc *sc, struct cryptop *crp,
    struct hifn_command *cmd)
{
	struct cryptodesc *crd = &crp->crp_desc[0];
	int s, err = 0;

	cmd->compcrd = crd;
	cmd->base_masks |= HIFN_BASE_CMD_COMP;

	if ((crp->crp_flags & CRYPTO_F_IMBUF) == 0) {
		/*
		 * XXX can only handle mbufs right now since we can
		 * XXX dynamically resize them.
		 */
		err = EINVAL;
		return (ENOMEM);
	}

	if ((crd->crd_flags & CRD_F_COMP) == 0)
		cmd->base_masks |= HIFN_BASE_CMD_DECODE;
	if (crd->crd_alg == CRYPTO_LZS_COMP)
		cmd->comp_masks |= HIFN_COMP_CMD_ALG_LZS |
		    HIFN_COMP_CMD_CLEARHIST;

	if (bus_dmamap_create(sc->sc_dmat, HIFN_MAX_DMALEN, MAX_SCATTER,
	    HIFN_MAX_SEGLEN, 0, BUS_DMA_NOWAIT, &cmd->src_map)) {
		err = ENOMEM;
		goto fail;
	}

	if (bus_dmamap_create(sc->sc_dmat, HIFN_MAX_DMALEN, MAX_SCATTER,
	    HIFN_MAX_SEGLEN, 0, BUS_DMA_NOWAIT, &cmd->dst_map)) {
		err = ENOMEM;
		goto fail;
	}

	if (crp->crp_flags & CRYPTO_F_IMBUF) {
		int len;

		if (bus_dmamap_load_mbuf(sc->sc_dmat, cmd->src_map,
		    cmd->srcu.src_m, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
			goto fail;
		}

		len = cmd->src_map->dm_mapsize / MCLBYTES;
		if ((cmd->src_map->dm_mapsize % MCLBYTES) != 0)
			len++;
		len *= MCLBYTES;

		if ((crd->crd_flags & CRD_F_COMP) == 0)
			len *= 4;

		if (len > HIFN_MAX_DMALEN)
			len = HIFN_MAX_DMALEN;

		cmd->dstu.dst_m = hifn_mkmbuf_chain(len, cmd->srcu.src_m);
		if (cmd->dstu.dst_m == NULL) {
			err = ENOMEM;
			goto fail;
		}

		if (bus_dmamap_load_mbuf(sc->sc_dmat, cmd->dst_map,
		    cmd->dstu.dst_m, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
			goto fail;
		}
	} else if (crp->crp_flags & CRYPTO_F_IOV) {
		if (bus_dmamap_load_uio(sc->sc_dmat, cmd->src_map,
		    cmd->srcu.src_io, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
			goto fail;
		}
		if (bus_dmamap_load_uio(sc->sc_dmat, cmd->dst_map,
		    cmd->dstu.dst_io, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
			goto fail;
		}
	}

	if (cmd->src_map == cmd->dst_map)
		bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
		    0, cmd->src_map->dm_mapsize,
		    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
	else {
		bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
		    0, cmd->src_map->dm_mapsize, BUS_DMASYNC_PREWRITE);
		bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
		    0, cmd->dst_map->dm_mapsize, BUS_DMASYNC_PREREAD);
	}

	cmd->crp = crp;
	/*
	 * Always use session 0.  The modes of compression we use are
	 * stateless and there is always at least one compression
	 * context, zero.
	 */
	cmd->session_num = 0;
	cmd->softc = sc;

	s = splnet();
	err = hifn_compress_enter(sc, cmd);
	splx(s);

	if (err != 0)
		goto fail;
	return (0);

fail:
	if (cmd->dst_map != NULL) {
		if (cmd->dst_map->dm_nsegs > 0)
			bus_dmamap_unload(sc->sc_dmat, cmd->dst_map);
		bus_dmamap_destroy(sc->sc_dmat, cmd->dst_map);
	}
	if (cmd->src_map != NULL) {
		if (cmd->src_map->dm_nsegs > 0)
			bus_dmamap_unload(sc->sc_dmat, cmd->src_map);
		bus_dmamap_destroy(sc->sc_dmat, cmd->src_map);
	}
	explicit_bzero(cmd, sizeof(*cmd));
	free(cmd, M_DEVBUF, sizeof *cmd);
	if (err == EINVAL)
		hifnstats.hst_invalid++;
	else
		hifnstats.hst_nomem++;
	crp->crp_etype = err;
	crypto_done(crp);
	return (0);
}

/*
 * must be called at splnet()
 */
int
hifn_compress_enter(struct hifn_softc *sc, struct hifn_command *cmd)
{
	struct hifn_dma *dma = sc->sc_dma;
	int cmdi, resi;
	u_int32_t cmdlen;

	if ((dma->cmdu + 1) > HIFN_D_CMD_RSIZE ||
	    (dma->resu + 1) > HIFN_D_CMD_RSIZE)
		return (ENOMEM);

	if ((dma->srcu + cmd->src_map->dm_nsegs) > HIFN_D_SRC_RSIZE ||
	    (dma->dstu + cmd->dst_map->dm_nsegs) > HIFN_D_DST_RSIZE)
		return (ENOMEM);

	if (dma->cmdi == HIFN_D_CMD_RSIZE) {
		dma->cmdi = 0;
		dma->cmdr[HIFN_D_CMD_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_CMDR_SYNC(sc, HIFN_D_CMD_RSIZE,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	cmdi = dma->cmdi++;
	cmdlen = hifn_write_command(cmd, dma->command_bufs[cmdi]);
	HIFN_CMD_SYNC(sc, cmdi, BUS_DMASYNC_PREWRITE);

	/* .p for command/result already set */
	dma->cmdr[cmdi].l = htole32(cmdlen | HIFN_D_VALID | HIFN_D_LAST |
	    HIFN_D_MASKDONEIRQ);
	HIFN_CMDR_SYNC(sc, cmdi,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	dma->cmdu++;
	if (sc->sc_c_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_C_CTRL_ENA);
		sc->sc_c_busy = 1;
		SET_LED(sc, HIFN_MIPSRST_LED0);
	}

	/*
	 * Always enable the command wait interrupt.  We are obviously
	 * missing an interrupt or two somewhere. Enabling the command wait
	 * interrupt will guarantee we get called periodically until all
	 * of the queues are drained and thus work around this.
	 */
	sc->sc_dmaier |= HIFN_DMAIER_C_WAIT;
	WRITE_REG_1(sc, HIFN_1_DMA_IER, sc->sc_dmaier);

	hifnstats.hst_ipackets++;
	hifnstats.hst_ibytes += cmd->src_map->dm_mapsize;

	hifn_dmamap_load_src(sc, cmd);
	if (sc->sc_s_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_S_CTRL_ENA);
		sc->sc_s_busy = 1;
		SET_LED(sc, HIFN_MIPSRST_LED1);
	}

	/*
	 * Unlike other descriptors, we don't mask done interrupt from
	 * result descriptor.
	 */
	if (dma->resi == HIFN_D_RES_RSIZE) {
		dma->resi = 0;
		dma->resr[HIFN_D_RES_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_RESR_SYNC(sc, HIFN_D_RES_RSIZE,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	}
	resi = dma->resi++;
	dma->hifn_commands[resi] = cmd;
	HIFN_RES_SYNC(sc, resi, BUS_DMASYNC_PREREAD);
	dma->resr[resi].l = htole32(HIFN_MAX_RESULT |
	    HIFN_D_VALID | HIFN_D_LAST);
	HIFN_RESR_SYNC(sc, resi,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	dma->resu++;
	if (sc->sc_r_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_R_CTRL_ENA);
		sc->sc_r_busy = 1;
		SET_LED(sc, HIFN_MIPSRST_LED2);
	}

	if (cmd->sloplen)
		cmd->slopidx = resi;

	hifn_dmamap_load_dst(sc, cmd);

	if (sc->sc_d_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_D_CTRL_ENA);
		sc->sc_d_busy = 1;
	}
	sc->sc_active = 5;
	cmd->cmd_callback = hifn_callback_comp;
	return (0);
}

void
hifn_callback_comp(struct hifn_softc *sc, struct hifn_command *cmd,
    u_int8_t *resbuf)
{
	struct hifn_base_result baseres;
	struct cryptop *crp = cmd->crp;
	struct hifn_dma *dma = sc->sc_dma;
	struct mbuf *m;
	int err = 0, i, u;
	u_int32_t olen;
	bus_size_t dstsize;

	bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
	    0, cmd->src_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
	bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
	    0, cmd->dst_map->dm_mapsize, BUS_DMASYNC_POSTREAD);

	dstsize = cmd->dst_map->dm_mapsize;
	bus_dmamap_unload(sc->sc_dmat, cmd->dst_map);

	bcopy(resbuf, &baseres, sizeof(struct hifn_base_result));

	i = dma->dstk; u = dma->dstu;
	while (u != 0) {
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    offsetof(struct hifn_dma, dstr[i]), sizeof(struct hifn_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		if (dma->dstr[i].l & htole32(HIFN_D_VALID)) {
			bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
			    offsetof(struct hifn_dma, dstr[i]),
			    sizeof(struct hifn_desc),
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			break;
		}
		if (++i == (HIFN_D_DST_RSIZE + 1))
			i = 0;
		else
			u--;
	}
	dma->dstk = i; dma->dstu = u;

	if (baseres.flags & htole16(HIFN_BASE_RES_DSTOVERRUN)) {
		bus_size_t xlen;

		xlen = dstsize;

		m_freem(cmd->dstu.dst_m);

		if (xlen == HIFN_MAX_DMALEN) {
			/* We've done all we can. */
			err = E2BIG;
			goto out;
		}

		xlen += MCLBYTES;

		if (xlen > HIFN_MAX_DMALEN)
			xlen = HIFN_MAX_DMALEN;

		cmd->dstu.dst_m = hifn_mkmbuf_chain(xlen,
		    cmd->srcu.src_m);
		if (cmd->dstu.dst_m == NULL) {
			err = ENOMEM;
			goto out;
		}
		if (bus_dmamap_load_mbuf(sc->sc_dmat, cmd->dst_map,
		    cmd->dstu.dst_m, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
			goto out;
		}

		bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
		    0, cmd->src_map->dm_mapsize, BUS_DMASYNC_PREWRITE);
		bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
		    0, cmd->dst_map->dm_mapsize, BUS_DMASYNC_PREREAD);

		/* already at splnet... */
		err = hifn_compress_enter(sc, cmd);
		if (err != 0)
			goto out;
		return;
	}

	olen = dstsize - (letoh16(baseres.dst_cnt) |
	    (((letoh16(baseres.session) & HIFN_BASE_RES_DSTLEN_M) >>
	    HIFN_BASE_RES_DSTLEN_S) << 16));

	crp->crp_olen = olen - cmd->compcrd->crd_skip;

	bus_dmamap_unload(sc->sc_dmat, cmd->src_map);
	bus_dmamap_destroy(sc->sc_dmat, cmd->src_map);
	bus_dmamap_destroy(sc->sc_dmat, cmd->dst_map);

	m = cmd->dstu.dst_m;
	if (m->m_flags & M_PKTHDR)
		m->m_pkthdr.len = olen;
	crp->crp_buf = (caddr_t)m;
	for (; m != NULL; m = m->m_next) {
		if (olen >= m->m_len)
			olen -= m->m_len;
		else {
			m->m_len = olen;
			olen = 0;
		}
	}

	m_freem(cmd->srcu.src_m);
	explicit_bzero(cmd, sizeof(*cmd));
	free(cmd, M_DEVBUF, sizeof *cmd);
	crp->crp_etype = 0;
	crypto_done(crp);
	return;

out:
	if (cmd->dst_map != NULL) {
		if (cmd->src_map->dm_nsegs != 0)
			bus_dmamap_unload(sc->sc_dmat, cmd->src_map);
		bus_dmamap_destroy(sc->sc_dmat, cmd->dst_map);
	}
	if (cmd->src_map != NULL) {
		if (cmd->src_map->dm_nsegs != 0)
			bus_dmamap_unload(sc->sc_dmat, cmd->src_map);
		bus_dmamap_destroy(sc->sc_dmat, cmd->src_map);
	}
	m_freem(cmd->dstu.dst_m);
	explicit_bzero(cmd, sizeof(*cmd));
	free(cmd, M_DEVBUF, sizeof *cmd);
	crp->crp_etype = err;
	crypto_done(crp);
}

struct mbuf *
hifn_mkmbuf_chain(int totlen, struct mbuf *mtemplate)
{
	int len;
	struct mbuf *m, *m0, *mlast;

	if (mtemplate->m_flags & M_PKTHDR) {
		len = MHLEN;
		MGETHDR(m0, M_DONTWAIT, MT_DATA);
	} else {
		len = MLEN;
		MGET(m0, M_DONTWAIT, MT_DATA);
	}
	if (m0 == NULL)
		return (NULL);
	if (len == MHLEN) {
		if (m_dup_pkthdr(m0, mtemplate, M_DONTWAIT)) {
			m_free(m0);
			return (NULL);
		}
	}
	MCLGET(m0, M_DONTWAIT);
	if (!(m0->m_flags & M_EXT)) {
		m_freem(m0);
		return (NULL);
	}
	len = MCLBYTES;

	totlen -= len;
	m0->m_pkthdr.len = m0->m_len = len;
	mlast = m0;

	while (totlen > 0) {
		MGET(m, M_DONTWAIT, MT_DATA);
		if (m == NULL) {
			m_freem(m0);
			return (NULL);
		}
		MCLGET(m, M_DONTWAIT);
		if (!(m->m_flags & M_EXT)) {
			m_free(m);
			m_freem(m0);
			return (NULL);
		}
		len = MCLBYTES;
		m->m_len = len;
		if (m0->m_flags & M_PKTHDR)
			m0->m_pkthdr.len += len;
		totlen -= len;

		mlast->m_next = m;
		mlast = m;
	}

	return (m0);
}

void
hifn_write_4(struct hifn_softc *sc, int reggrp, bus_size_t reg,
    u_int32_t val)
{
	/*
	 * 7811 PB3 rev/2 parts lock-up on burst writes to Group 0
	 * and Group 1 registers; avoid conditions that could create
	 * burst writes by doing a read in between the writes.
	 */
	if (sc->sc_flags & HIFN_NO_BURSTWRITE) {
		if (sc->sc_waw_lastgroup == reggrp &&
		    sc->sc_waw_lastreg == reg - 4) {
			bus_space_read_4(sc->sc_st1, sc->sc_sh1, HIFN_1_REVID);
		}
		sc->sc_waw_lastgroup = reggrp;
		sc->sc_waw_lastreg = reg;
	}
	if (reggrp == 0)
		bus_space_write_4(sc->sc_st0, sc->sc_sh0, reg, val);
	else
		bus_space_write_4(sc->sc_st1, sc->sc_sh1, reg, val);

}

u_int32_t
hifn_read_4(struct hifn_softc *sc, int reggrp, bus_size_t reg)
{
	if (sc->sc_flags & HIFN_NO_BURSTWRITE) {
		sc->sc_waw_lastgroup = -1;
		sc->sc_waw_lastreg = 1;
	}
	if (reggrp == 0)
		return (bus_space_read_4(sc->sc_st0, sc->sc_sh0, reg));
	return (bus_space_read_4(sc->sc_st1, sc->sc_sh1, reg));
}
@


1.176
log
@Zero a return value variable at the start of hifn_process() to avoid
using it uninitialised in one path.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.175 2016/11/29 10:22:30 jsg Exp $	*/
d1930 1
a1930 1
	struct cryptodesc *crd1, *crd2, *maccrd, *enccrd;
d1972 1
a1972 2
	crd1 = crp->crp_desc;
	if (crd1 == NULL) {
d1976 3
a1978 1
	crd2 = crd1->crd_next;
d2295 1
a2295 1
		for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
d2298 2
d2332 1
a2332 1
	struct cryptodesc *crd = crp->crp_desc;
@


1.175
log
@m_free() and m_freem() test for NULL.  Simplify callers which had their own
NULL tests.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.174 2015/12/10 21:00:51 naddy Exp $	*/
d1928 1
a1928 1
	int card, session, err, ivlen;
@


1.174
log
@Remove plain DES from the kernel crypto framework, including the crypto
accelerator drivers.  No longer used by anything.  ok sthen@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.173 2015/11/13 15:29:55 naddy Exp $	*/
d2679 1
a2679 2
	if (cmd->dstu.dst_m != NULL)
		m_freem(cmd->dstu.dst_m);
@


1.173
log
@remove unused ARC4 support; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.172 2015/11/13 12:21:16 mikeb Exp $	*/
a297 1
		algs[CRYPTO_DES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
a1867 1
		case CRYPTO_DES_CBC:
d1984 1
a1984 2
		} else if (crd1->crd_alg == CRYPTO_DES_CBC ||
		    crd1->crd_alg == CRYPTO_3DES_CBC ||
d1999 1
a1999 2
		    (crd2->crd_alg == CRYPTO_DES_CBC ||
		     crd2->crd_alg == CRYPTO_3DES_CBC ||
d2005 1
a2005 2
		} else if ((crd1->crd_alg == CRYPTO_DES_CBC ||
		     crd1->crd_alg == CRYPTO_3DES_CBC ||
a2024 5
		case CRYPTO_DES_CBC:
			cmd->cry_masks |= HIFN_CRYPT_CMD_ALG_DES |
			    HIFN_CRYPT_CMD_MODE_CBC |
			    HIFN_CRYPT_CMD_NEW_IV;
			break;
@


1.172
log
@Remove unused non HMAC versions of MD5 and SHA1;  ok mpi, deraadt, naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.171 2015/09/10 18:10:34 deraadt Exp $	*/
a293 1
		algs[CRYPTO_ARC4] = CRYPTO_ALG_FLAG_SUPPORTED;
a1871 1
		case CRYPTO_ARC4:
d1988 1
a1988 2
		    crd1->crd_alg == CRYPTO_AES_CBC ||
		    crd1->crd_alg == CRYPTO_ARC4) {
d2004 1
a2004 2
		     crd2->crd_alg == CRYPTO_AES_CBC ||
		     crd2->crd_alg == CRYPTO_ARC4) &&
d2010 2
a2011 3
		     crd1->crd_alg == CRYPTO_ARC4 ||
		     crd1->crd_alg == CRYPTO_AES_CBC ||
		     crd1->crd_alg == CRYPTO_3DES_CBC) &&
a2029 3
		case CRYPTO_ARC4:
			cmd->cry_masks |= HIFN_CRYPT_CMD_ALG_RC4;
			break;
d2049 11
a2059 28
		if (enccrd->crd_alg != CRYPTO_ARC4) {
			ivlen = ((enccrd->crd_alg == CRYPTO_AES_CBC) ?
			    HIFN_AES_IV_LENGTH : HIFN_IV_LENGTH);
			if (enccrd->crd_flags & CRD_F_ENCRYPT) {
				if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
					bcopy(enccrd->crd_iv, cmd->iv, ivlen);
				else
					arc4random_buf(cmd->iv, ivlen);

				if ((enccrd->crd_flags & CRD_F_IV_PRESENT)
				    == 0) {
					if (crp->crp_flags & CRYPTO_F_IMBUF)
						err =
						    m_copyback(cmd->srcu.src_m,
						    enccrd->crd_inject,
						    ivlen, cmd->iv, M_NOWAIT);
					else if (crp->crp_flags & CRYPTO_F_IOV)
						cuio_copyback(cmd->srcu.src_io,
						    enccrd->crd_inject,
						    ivlen, cmd->iv);
					if (err)
						goto errout;
				}
			} else {
				if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
					bcopy(enccrd->crd_iv, cmd->iv, ivlen);
				else if (crp->crp_flags & CRYPTO_F_IMBUF)
					m_copydata(cmd->srcu.src_m,
d2061 1
a2061 1
					    ivlen, cmd->iv);
d2063 1
a2063 1
					cuio_copydata(cmd->srcu.src_io,
d2066 2
d2069 9
@


1.171
log
@sizes for free(); ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.170 2015/05/12 12:56:47 mikeb Exp $	*/
a296 2
		algs[CRYPTO_MD5] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_SHA1] = CRYPTO_ALG_FLAG_SUPPORTED;
a1863 2
		case CRYPTO_MD5:
		case CRYPTO_SHA1:
d1985 1
a1985 3
		    crd1->crd_alg == CRYPTO_SHA1_HMAC ||
		    crd1->crd_alg == CRYPTO_SHA1 ||
		    crd1->crd_alg == CRYPTO_MD5) {
d2004 1
a2004 3
		     crd1->crd_alg == CRYPTO_SHA1_HMAC ||
		     crd1->crd_alg == CRYPTO_MD5 ||
		     crd1->crd_alg == CRYPTO_SHA1) &&
d2018 1
a2018 3
		     crd2->crd_alg == CRYPTO_SHA1_HMAC ||
		     crd2->crd_alg == CRYPTO_MD5 ||
		     crd2->crd_alg == CRYPTO_SHA1) &&
a2124 5
		case CRYPTO_MD5:
			cmd->mac_masks |= HIFN_MAC_CMD_ALG_MD5 |
			    HIFN_MAC_CMD_RESULT | HIFN_MAC_CMD_MODE_HASH |
			    HIFN_MAC_CMD_POS_IPSEC;
			break;
a2129 5
		case CRYPTO_SHA1:
			cmd->mac_masks |= HIFN_MAC_CMD_ALG_SHA1 |
			    HIFN_MAC_CMD_RESULT | HIFN_MAC_CMD_MODE_HASH |
			    HIFN_MAC_CMD_POS_IPSEC;
			break;
d2321 1
a2321 5
			if (crd->crd_alg == CRYPTO_MD5)
				len = 16;
			else if (crd->crd_alg == CRYPTO_SHA1)
				len = 20;
			else if (crd->crd_alg == CRYPTO_MD5_HMAC ||
@


1.170
log
@Fixup potential use after free and a memory leak.

Found by Maxime Villard <max at m00nbsd ! net> with the Brainy Code Scanner,
thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.169 2014/07/13 23:10:23 deraadt Exp $	*/
d2177 1
a2177 1
		free(cmd, M_DEVBUF, 0);
d2240 1
a2240 1
			free(cmd, M_DEVBUF, 0);
d2369 1
a2369 1
	free(cmd, M_DEVBUF, 0);
d2494 1
a2494 1
	free(cmd, M_DEVBUF, 0);
d2711 1
a2711 1
	free(cmd, M_DEVBUF, 0);
d2730 1
a2730 1
	free(cmd, M_DEVBUF, 0);
@


1.169
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.168 2014/07/12 18:48:51 tedu Exp $	*/
d2757 1
a2757 1
	if (!(m0->m_flags & M_EXT))
d2759 2
d2775 1
@


1.168
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.167 2012/01/13 09:53:24 mikeb Exp $	*/
d1850 2
a1851 2
			ses = (struct hifn_session *)malloc((sesn + 1) *
			    sizeof(*ses), M_DEVBUF, M_NOWAIT);
@


1.167
log
@handle m_copyback errors, this code is too sensitive for such
failures to be neglected;  ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.166 2011/04/05 11:48:28 blambert Exp $	*/
d1856 1
a1856 1
			free(sc->sc_sessions, M_DEVBUF);
d2177 1
a2177 1
		free(cmd, M_DEVBUF);
d2240 1
a2240 1
			free(cmd, M_DEVBUF);
d2369 1
a2369 1
	free(cmd, M_DEVBUF);
d2494 1
a2494 1
	free(cmd, M_DEVBUF);
d2711 1
a2711 1
	free(cmd, M_DEVBUF);
d2730 1
a2730 1
	free(cmd, M_DEVBUF);
@


1.166
log
@Passing M_WAITOK to mbuf functions is supposed to be a contract between
the caller and the function that the function will not fail to allocate
memory and return a NULL pointer. However, m_dup_pkthdr() violates
this contract, making it possible for functions that pass M_WAITOK to
be surprised in ways that hurt.

Fix this by passing the wait flag all the way down the functions that
actually do the allocation for m_dup_pkthdr() so that we won't be
surprised.

man page update forthcoming

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.165 2011/04/03 15:36:02 jasper Exp $	*/
d2079 2
a2080 1
						m_copyback(cmd->srcu.src_m,
d2087 2
d2296 2
a2297 1
			m_copyback((struct mbuf *)crp->crp_buf,
d2305 2
d2352 2
a2353 1
				m_copyback((struct mbuf *)crp->crp_buf,
d2361 1
@


1.165
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.164 2011/01/12 20:55:22 deraadt Exp $	*/
d1433 2
a1434 1
				err = m_dup_pkthdr(m0, cmd->srcu.src_m);
d2743 1
a2743 1
		if (m_dup_pkthdr(m0, mtemplate)) {
@


1.164
log
@A bunch more explicit_bzero calls for key material
ubsec tested by mikeb, hifn tested by kettenis
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.163 2010/12/15 23:34:23 mikeb Exp $	*/
d138 1
a138 1
	    sizeof(hifn_devices)/sizeof(hifn_devices[0])));
d613 1
a613 1
	for (i = 0; i < sizeof(pci2id)/sizeof(pci2id[0]); i++) {
@


1.163
log
@Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.

Original commit message by angelos:

Don't keep the last blocksize-bytes of ciphertext for use as the next
plaintext's IV, in CBC mode. Use arc4random() to acquire fresh IVs per
message.

with and ok deraadt, ok markus, djm
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.162 2010/07/05 11:07:56 blambert Exp $	*/
d1854 1
a1854 1
			bzero(sc->sc_sessions, sesn * sizeof(*ses));
d2171 2
a2172 1
	if (cmd != NULL)
d2174 1
d2235 1
d2359 1
d2484 1
d2701 1
d2720 1
@


1.162
log
@timeout_add -> timeout_add_sec

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.161 2010/07/02 02:40:16 blambert Exp $	*/
a1875 4
			arc4random_buf(ses->hs_iv,
			    (c->cri_alg == CRYPTO_AES_CBC ?
			    HIFN_AES_IV_LENGTH : HIFN_IV_LENGTH));
			/*FALLTHROUGH*/
d2073 1
a2073 2
					bcopy(sc->sc_sessions[session].hs_iv,
					    cmd->iv, ivlen);
d2257 1
a2257 1
	int totlen, i, u, ivlen;
a2318 22

	if ((cmd->base_masks & (HIFN_BASE_CMD_CRYPT | HIFN_BASE_CMD_DECODE)) ==
	    HIFN_BASE_CMD_CRYPT) {
		for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
			if (crd->crd_alg != CRYPTO_DES_CBC &&
			    crd->crd_alg != CRYPTO_3DES_CBC &&
			    crd->crd_alg != CRYPTO_AES_CBC)
				continue;
			ivlen = ((crd->crd_alg == CRYPTO_AES_CBC) ?
			    HIFN_AES_IV_LENGTH : HIFN_IV_LENGTH);
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copydata((struct mbuf *)crp->crp_buf,
				    crd->crd_skip + crd->crd_len - ivlen, ivlen,
				    cmd->softc->sc_sessions[cmd->session_num].hs_iv);
			else if (crp->crp_flags & CRYPTO_F_IOV) {
				cuio_copydata((struct uio *)crp->crp_buf,
				    crd->crd_skip + crd->crd_len - ivlen, ivlen,
				    cmd->softc->sc_sessions[cmd->session_num].hs_iv);
			}
			break;
		}
	}
@


1.162.2.1
log
@Backport from -current, original commit by mikeb@@:
------
Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.
------

ok deraadt@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.162 2010/07/05 11:07:56 blambert Exp $	*/
d1876 4
d2077 2
a2078 1
					arc4random_buf(cmd->iv, ivlen);
d2262 1
a2262 1
	int totlen, i, u;
d2324 22
@


1.161
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.160 2010/05/19 15:27:35 oga Exp $	*/
d317 1
a317 1
	timeout_add(&sc->sc_tickto, hz);
d1677 1
a1677 1
	timeout_add(&sc->sc_tickto, hz);
@


1.160
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.159 2010/04/08 00:23:53 tedu Exp $	*/
d2085 1
a2085 1
						    ivlen, cmd->iv);
d2296 2
a2297 1
			    cmd->sloplen, &dma->slop[cmd->slopidx]);
d2370 1
a2370 1
				    crd->crd_inject, len, macbuf);
@


1.159
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.158 2009/09/13 14:42:52 krw Exp $	*/
d200 2
a201 1
	    sc->sc_dmasegs, 1, &sc->sc_dmansegs, BUS_DMA_NOWAIT)) {
a222 1
	bzero(sc->sc_dma, sizeof(*sc->sc_dma));
@


1.158
log
@M_DUP_PKTHDR() define -> m_dup_pkthdr() function to properly deal
with m_tag_copy_chain() failures.

Use m_defrag() to eliminate hand rolled defragging of mbufs and
some uses of M_DUP_PKTHDR().

Original diff from thib@@, claudio@@'s feedback integrated by me.

Tests kevlo@@ claudio@@, "reads ok" blambert@@

ok thib@@ claudio@@, "m_defrag() bits ok" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.157 2008/09/25 17:55:28 chl Exp $	*/
d50 1
a50 1
#include <sys/proc.h>
@


1.158.2.1
log
@Backport from -current, original commit by mikeb@@:
------
Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.
------
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.158 2009/09/13 14:42:52 krw Exp $	*/
d1876 4
d2077 2
a2078 1
					arc4random_buf(cmd->iv, ivlen);
d2262 1
a2262 1
	int totlen, i, u;
d2323 22
@


1.157
log
@remove dead store.

Found by LLVM/Clang Static Analyzer.

ok brad@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.156 2008/08/31 09:50:12 jsg Exp $	*/
d1432 7
a1438 2
			if (len == MHLEN)
				M_DUP_PKTHDR(m0, cmd->srcu.src_m);
d2760 6
a2765 2
	if (len == MHLEN)
		M_DUP_PKTHDR(m0, mtemplate);
@


1.156
log
@remove http links to dead/changed domains.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.155 2008/06/09 07:07:16 djm Exp $	*/
d1012 1
a1012 1
		r = -1;
@


1.155
log
@rename arc4random_bytes => arc4random_buf to match libc's nicer name;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.154 2007/10/01 15:34:48 krw Exp $	*/
d592 1
a592 1
		 * http://www.powercrypt.com, and obviously they also
@


1.154
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...' where
obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.153 2007/09/18 22:02:18 djm Exp $	*/
d1871 1
a1871 1
			arc4random_bytes(ses->hs_iv,
@


1.153
log
@arc4random_bytes() is the preferred interface for generating nonces;
"looks ok" markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.152 2006/06/29 21:34:51 deraadt Exp $	*/
d1961 1
a1961 2
	cmd = (struct hifn_command *)malloc(sizeof(struct hifn_command),
	    M_DEVBUF, M_NOWAIT);
a1965 1
	bzero(cmd, sizeof(struct hifn_command));
@


1.152
log
@do not check for master/io/mem enables; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.151 2006/01/04 00:02:29 brad Exp $	*/
d1871 1
a1871 1
			get_random_bytes(ses->hs_iv,
@


1.151
log
@update comment to match what the code does as of rev 1.149.

From Jochen <jochen at penguin-breeder dot org> in PR 4961

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.150 2005/11/29 00:03:08 deraadt Exp $	*/
a150 1
	u_int32_t cmd;
a172 10

	cmd = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	if (!(cmd & PCI_COMMAND_MEM_ENABLE)) {
		printf(": memory mapping not enabled\n");
		return;
	}
	if (!(cmd & PCI_COMMAND_MASTER_ENABLE)) {
		printf(": bus mastering not enabled\n");
		return;
	}
@


1.150
log
@potential memory leak in hifn7751.c:hifn_newsession; 3873, fixed by jason
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.149 2004/08/12 18:10:12 jason Exp $	*/
d1564 4
a1567 3
	 * We don't worry about missing an interrupt (which a "command wait"
	 * interrupt salvages us from), unless there is more than one command
	 * in the queue.
d2566 4
a2569 3
	 * We don't worry about missing an interrupt (which a "command wait"
	 * interrupt salvages us from), unless there is more than one command
	 * in the queue.
@


1.149
log
@Leave the command wait interrupt enabled as long as there is at least one
pending result.  This isn't a good solution (we're obviously missing an
interrupt or two in some cases), but this will guarantee we get called
periodically until all of the queues are drained.  Based on idea from
"jochen from penguin-breeder decimal org"; ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.148 2004/03/14 23:26:11 hshoexer Exp $	*/
a1866 1
	ses->hs_used = 1;
d1910 1
@


1.148
log
@Return EINVAL in case of a zero length descriptor.  The hifn can not handle
this.

ok jason@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.147 2004/02/03 17:17:33 deraadt Exp $	*/
d1568 2
a1569 4
	if (dma->cmdu > 1) {
		sc->sc_dmaier |= HIFN_DMAIER_C_WAIT;
		WRITE_REG_1(sc, HIFN_1_DMA_IER, sc->sc_dmaier);
	}
d2569 2
a2570 4
	if (dma->cmdu > 1) {
		sc->sc_dmaier |= HIFN_DMAIER_C_WAIT;
		WRITE_REG_1(sc, HIFN_1_DMA_IER, sc->sc_dmaier);
	}
@


1.147
log
@advertise features of our crypto chips better; ok tdeval
jason is being a slacker
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.146 2004/01/20 21:01:55 jason Exp $	*/
d1953 5
@


1.146
log
@don't limit the number of sessions to the onboard ram (always upload the
key and IV data).  This kinda sucks for HMAC, but the alternative is
a cache manager and I just don't want to go there.  Tested by sturm@@ (thanks!)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.145 2004/01/09 21:32:24 brad Exp $	*/
d699 1
a699 1
		offtbl = "LZS-only";
d702 1
a702 1
		offtbl = "DES";
d705 1
a705 1
		offtbl = "3DES";
d711 8
a718 1
	printf(": %s, ", offtbl);
@


1.145
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.144 2003/10/09 03:47:20 jason Exp $	*/
d1162 1
a1162 1
	base_cmd->session_num = htole16(cmd->session_num |
d1816 2
a1817 1
	int i, mac = 0, cry = 0, comp = 0;
d1832 31
a1862 5
	for (i = 0; i < sc->sc_maxses; i++)
		if (sc->sc_sessions[i].hs_state == HS_STATE_FREE)
			break;
	if (i == sc->sc_maxses)
		return (ENOMEM);
d1877 1
a1877 1
			get_random_bytes(sc->sc_sessions[i].hs_iv,
d1905 1
a1905 2
	*sidp = HIFN_SID(sc->sc_dv.dv_unit, i);
	sc->sc_sessions[i].hs_state = HS_STATE_USED;
d1928 1
a1928 1
	if (session >= sc->sc_maxses)
d1956 1
a1956 1
	if (session >= sc->sc_maxses) {
a2046 4
			if ((enccrd->crd_flags & CRD_F_ENCRYPT)
			    != sc->sc_sessions[session].hs_prev_op)
				sc->sc_sessions[session].hs_state =
				    HS_STATE_USED;
d2104 1
a2125 3

		if (sc->sc_sessions[session].hs_state == HS_STATE_USED)
			cmd->cry_masks |= HIFN_CRYPT_CMD_NEW_KEY;
d2155 2
a2156 3
		if ((maccrd->crd_alg == CRYPTO_SHA1_HMAC ||
		     maccrd->crd_alg == CRYPTO_MD5_HMAC) &&
		    sc->sc_sessions[session].hs_state == HS_STATE_USED) {
d2169 1
a2169 6
	if (!err) {
		if(enccrd)
			sc->sc_sessions[session].hs_prev_op=enccrd->crd_flags
			    & CRD_F_ENCRYPT;
		if (sc->sc_sessions[session].hs_state == HS_STATE_USED)
			sc->sc_sessions[session].hs_state = HS_STATE_KEY;
a2170 1
	}
a2245 5
	/* Force upload of key next time */
	for (i = 0; i < sc->sc_maxses; i++)
		if (sc->sc_sessions[i].hs_state == HS_STATE_KEY)
			sc->sc_sessions[i].hs_state = HS_STATE_USED;
	
@


1.144
log
@- from freebsd: 795[56] AES support
- don't bother with the master/mmio enable stuff (it's done in pci.c for us)
based on suggestion from mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.143 2003/09/25 15:40:54 jason Exp $	*/
a55 2

#include <uvm/uvm_extern.h>
@


1.143
log
@hifn 7956 support
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.142 2003/09/24 05:23:29 jason Exp $	*/
d9 2
a10 1
 *
d45 1
a45 1
 * Driver for the Hifn 7751 encryption processor.
d163 1
a163 3
	   (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7951 ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7955 ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7956))
d167 6
a177 4
	cmd |= PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, cmd);
	cmd = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);

d179 1
a179 1
		printf(": failed to enable memory mapping\n");
a181 1

d183 1
a183 1
		printf(": failed to enable bus mastering\n");
d248 3
a250 1
	if (hifn_ramtype(sc))
d282 1
a282 7
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_HIFN &&
	   (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7955 ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7956)) {
		sc->sc_maxses = 125;
		sc->sc_ramsize = 32 * 1024;
	} else
		hifn_sessions(sc);
d316 2
d771 11
a781 4
	WRITE_REG_0(sc, HIFN_0_PUCNFG, HIFN_PUCNFG_COMPSING |
	    HIFN_PUCNFG_DRFR_128 | HIFN_PUCNFG_TCALLPHASES |
	    HIFN_PUCNFG_TCDRVTOTEM | HIFN_PUCNFG_BUS32 |
	    (sc->sc_drammodel ? HIFN_PUCNFG_DRAM : HIFN_PUCNFG_SRAM));
d810 8
a817 2
		sc->sc_maxses = 1 +
		    ((sc->sc_ramsize - 32768) / ctxsize);
d905 10
a914 3
	cnfg = READ_REG_0(sc, HIFN_0_PUCNFG) &
	    HIFN_PUCNFG_DRAMMASK;
	sc->sc_ramsize = 1 << ((cnfg >> 13) + 18);
d1144 1
a1144 1
	int using_mac, using_crypt, using_comp, len;
d1218 1
a1218 1
			buf_pos += cmd->cklen;
d1233 8
d1245 7
a1251 2
		bcopy(cmd->iv, buf_pos, HIFN_IV_LENGTH);
		buf_pos += HIFN_IV_LENGTH;
d1851 1
d1853 2
a1854 1
			    HIFN_IV_LENGTH);
d1915 1
a1915 1
	int card, session, err;
d1972 1
d1991 1
d1999 1
d2038 5
d2048 2
d2052 1
a2052 2
					bcopy(enccrd->crd_iv, cmd->iv,
					    HIFN_IV_LENGTH);
d2055 1
a2055 1
					    cmd->iv, HIFN_IV_LENGTH);
d2062 1
a2062 1
						    HIFN_IV_LENGTH, cmd->iv);
d2066 1
a2066 1
						    HIFN_IV_LENGTH, cmd->iv);
d2070 1
a2070 2
					bcopy(enccrd->crd_iv, cmd->iv,
					    HIFN_IV_LENGTH);
d2074 1
a2074 1
					    HIFN_IV_LENGTH, cmd->iv);
d2078 1
a2078 1
					    HIFN_IV_LENGTH, cmd->iv);
d2085 21
d2253 1
a2253 1
	int totlen, i, u;
d2319 2
a2320 1
			    crd->crd_alg != CRYPTO_3DES_CBC)
d2322 2
d2326 1
a2326 2
				    crd->crd_skip + crd->crd_len - HIFN_IV_LENGTH,
				    HIFN_IV_LENGTH,
d2330 1
a2330 2
				    crd->crd_skip + crd->crd_len - HIFN_IV_LENGTH,
				    HIFN_IV_LENGTH,
@


1.142
log
@initial support for hifn 7955 (no AES or PK yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.141 2003/08/14 15:20:29 jason Exp $	*/
d131 1
d162 3
a164 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7951)
d281 2
a282 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7955) {
d582 5
@


1.141
log
@kill unneeded caddr_t casts for *_copyback
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.140 2003/08/01 17:55:54 deraadt Exp $	*/
d130 1
d277 6
a282 1
	hifn_sessions(sc);
d573 5
@


1.140
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.139 2003/03/13 20:08:06 jason Exp $	*/
d2205 1
a2205 1
			    cmd->sloplen, (caddr_t)&dma->slop[cmd->slopidx]);
d2209 1
a2209 1
			    cmd->sloplen, (caddr_t)&dma->slop[cmd->slopidx]);
@


1.139
log
@print LZS-only and such for the cards (more clear than saying "disabled" for the 9751 which isn't true these days)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.138 2003/02/24 20:36:02 jason Exp $	*/
d134 1
a134 4
hifn_probe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d141 1
a141 3
hifn_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d345 1
a345 2
hifn_init_pubrng(sc)
	struct hifn_softc *sc;
d406 1
a406 2
hifn_rng(vsc)
	void *vsc;
d449 1
a449 2
hifn_puc_wait(sc)
	struct hifn_softc *sc;
d466 1
a466 2
hifn_reset_puc(sc)
	struct hifn_softc *sc;
d474 1
a474 2
hifn_set_retry(sc)
	struct hifn_softc *sc;
d488 1
a488 3
hifn_reset_board(sc, full)
	struct hifn_softc *sc;
	int full;
d538 1
a538 3
hifn_next_signature(a, cnt)
	u_int32_t a;
	u_int cnt;
d603 1
a603 3
hifn_enable_crypto(sc, pciid)
	struct hifn_softc *sc;
	pcireg_t pciid;
d705 1
a705 2
hifn_init_pci_registers(sc)
	struct hifn_softc *sc;
d773 1
a773 2
hifn_sessions(sc)
	struct hifn_softc *sc;
d800 1
a800 2
hifn_ramtype(sc)
	struct hifn_softc *sc;
d835 1
a835 2
hifn_sramsize(sc)
	struct hifn_softc *sc;
d870 1
a870 2
hifn_dramsize(sc)
	struct hifn_softc *sc;
d881 2
a882 3
hifn_alloc_slot(sc, cmdp, srcp, dstp, resp)
	struct hifn_softc *sc;
	int *cmdp, *srcp, *dstp, *resp;
d928 1
a928 4
hifn_writeramaddr(sc, addr, data)
	struct hifn_softc *sc;
	int addr;
	u_int8_t *data;
d993 1
a993 4
hifn_readramaddr(sc, addr, data)
	struct hifn_softc *sc;
	int addr;
	u_int8_t *data;
d1061 1
a1061 2
hifn_init_dma(sc)
	struct hifn_softc *sc;
d1099 1
a1099 3
hifn_write_command(cmd, buf)
	struct hifn_command *cmd;
	u_int8_t *buf;
d1213 1
a1213 2
hifn_dmamap_aligned(map)
	bus_dmamap_t map;
d1228 1
a1228 3
hifn_dmamap_load_dst(sc, cmd)
	struct hifn_softc *sc;
	struct hifn_command *cmd;
d1300 1
a1300 3
hifn_dmamap_load_src(sc, cmd)
	struct hifn_softc *sc;
	struct hifn_command *cmd;
d1332 2
a1333 4
hifn_crypto(sc, cmd, crp)
	struct hifn_softc *sc;
	struct hifn_command *cmd;
	struct cryptop *crp;
d1593 1
a1593 2
hifn_tick(vsc)
	void *vsc;
d1632 1
a1632 2
hifn_intr(arg)
	void *arg;
d1763 1
a1763 3
hifn_newsession(sidp, cri)
	u_int32_t *sidp;
	struct cryptoini *cri;
d1839 1
a1839 2
hifn_freesession(tid)
	u_int64_t tid;
d1859 1
a1859 2
hifn_process(crp)
	struct cryptop *crp;
d2092 1
a2092 2
hifn_abort(sc)
	struct hifn_softc *sc;
d2164 2
a2165 4
hifn_callback(sc, cmd, resbuf)
	struct hifn_softc *sc;
	struct hifn_command *cmd;
	u_int8_t *resbuf;
d2705 2
a2706 5
hifn_write_4(sc, reggrp, reg, val)
	struct hifn_softc *sc;
	int reggrp;
	bus_size_t reg;
	u_int32_t val;
d2729 1
a2729 4
hifn_read_4(sc, reggrp, reg)
	struct hifn_softc *sc;
	int reggrp;
	bus_size_t reg;
@


1.138
log
@Add support for LZS compression (only usable by ipcomp at the moment)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.137 2003/02/17 16:48:22 jason Exp $	*/
a696 1
	printf(": ");
d698 3
d702 2
d705 1
a706 1
	case HIFN_PUSTAT_ENA_0:
d708 1
a708 1
		printf("disabled, ");
d711 1
d713 1
a713 1
	return 0;
@


1.137
log
@whitespace, typos, and compression structure defns
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.136 2003/02/15 23:39:12 jason Exp $	*/
d102 2
a103 1
int	hifn_crypto(struct hifn_softc *, struct hifn_command *, struct cryptop *);
d116 6
a121 1

d302 1
d758 1
d1131 2
a1132 1
	int using_mac, using_crypt, len;
d1138 1
d1157 12
d1229 2
a1230 1
	if ((cmd->base_masks & (HIFN_BASE_CMD_MAC|HIFN_BASE_CMD_CRYPT)) == 0) {
d1446 2
a1447 1
				m0->m_pkthdr.len += len;
d1605 1
d1689 3
d1697 1
a1697 1
	restart = dmacsr & (HIFN_DMACSR_D_OVER | HIFN_DMACSR_R_OVER);
d1717 1
a1717 1
	if ((dmacsr & HIFN_DMACSR_C_WAIT) && (dma->cmdu == 0)) {
d1728 2
a1729 2
	i = dma->resk; u = dma->resu;
	while (u != 0) {
a1739 1
			u_int8_t *macbuf = NULL;
d1744 1
a1744 6
			if (cmd->base_masks & HIFN_BASE_CMD_MAC) {
				macbuf = dma->result_bufs[i];
				macbuf += 12;
			}

			hifn_callback(sc, cmd, macbuf);
a1745 1
			u--;
d1750 2
d1753 1
a1753 1
	dma->resk = i; dma->resu = u;
d1804 1
a1804 1
	int i, mac = 0, cry = 0;
d1845 5
d1854 8
a1861 1
	if (mac == 0 && cry == 0)
d1963 2
a2145 7
			u_int8_t *macbuf;

			if (cmd->base_masks & HIFN_BASE_CMD_MAC) {
				macbuf = dma->result_bufs[i];
				macbuf += 12;
			} else
				macbuf = NULL;
d2147 1
a2147 1
			hifn_callback(sc, cmd, macbuf);
d2204 1
a2204 1
hifn_callback(sc, cmd, macbuf)
d2207 1
a2207 1
	u_int8_t *macbuf;
d2296 8
a2303 1
	if (macbuf != NULL) {
d2334 410
@


1.136
log
@kill the remaining typedefs (These are about the last trace of Invertex
save for the copyright message).
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.135 2002/11/26 00:42:53 jason Exp $	*/
d1934 3
a1936 3
                     crd1->crd_alg == CRYPTO_SHA1_HMAC ||
                     crd1->crd_alg == CRYPTO_MD5 ||
                     crd1->crd_alg == CRYPTO_SHA1) &&
d1948 3
a1950 3
                     crd2->crd_alg == CRYPTO_SHA1_HMAC ||
                     crd2->crd_alg == CRYPTO_MD5 ||
                     crd2->crd_alg == CRYPTO_SHA1) &&
d2039 1
a2039 1
                       break;
d2282 1
a2282 1
                                   crd->crd_inject, len, macbuf);
@


1.135
log
@Whitespace diff; from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.134 2002/11/21 19:34:25 jason Exp $	*/
d943 1
a943 1
	hifn_base_command_t wc;
d960 1
a960 1
	*(hifn_base_command_t *)dma->command_bufs[cmdi] = wc;
d1011 1
a1011 1
	hifn_base_command_t rc;
d1027 1
a1027 1
	*(hifn_base_command_t *)dma->command_bufs[cmdi] = rc;
d1120 3
a1122 3
	hifn_base_command_t *base_cmd;
	hifn_mac_command_t *mac_cmd;
	hifn_crypt_command_t *cry_cmd;
d1130 1
a1130 1
	base_cmd = (hifn_base_command_t *)buf_pos;
d1145 1
a1145 1
	buf_pos += sizeof(hifn_base_command_t);
d1148 1
a1148 1
		mac_cmd = (hifn_mac_command_t *)buf_pos;
d1156 1
a1156 1
		buf_pos += sizeof(hifn_mac_command_t);
d1160 1
a1160 1
		cry_cmd = (hifn_crypt_command_t *)buf_pos;
d1168 1
a1168 1
		buf_pos += sizeof(hifn_crypt_command_t);
@


1.134
log
@From Angelos:
- simplistic load balancing across multiple cards
- simplified registration process
- a few style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.133 2002/11/19 18:40:17 jason Exp $	*/
d2268 1
a2268 1
                       int len;
d2270 8
a2277 8
                       if (crd->crd_alg == CRYPTO_MD5)
                               len = 16;
                       else if (crd->crd_alg == CRYPTO_SHA1)
                               len = 20;
                       else if (crd->crd_alg == CRYPTO_MD5_HMAC ||
                           crd->crd_alg == CRYPTO_SHA1_HMAC)
                               len = 12;
                       else
@


1.133
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.132 2002/08/01 18:29:59 jason Exp $	*/
d153 1
d294 2
d298 2
a299 4
		crypto_register(sc->sc_cid, CRYPTO_3DES_CBC, 0, 0,
		    hifn_newsession, hifn_freesession, hifn_process);
		crypto_register(sc->sc_cid, CRYPTO_ARC4, 0, 0,
		    hifn_newsession, hifn_freesession, hifn_process);
d302 5
a306 10
		crypto_register(sc->sc_cid, CRYPTO_MD5, 0, 0,
		    hifn_newsession, hifn_freesession, hifn_process);
		crypto_register(sc->sc_cid, CRYPTO_SHA1, 0, 0,
		    hifn_newsession, hifn_freesession, hifn_process);
		crypto_register(sc->sc_cid, CRYPTO_MD5_HMAC, 0, 0,
		    hifn_newsession, hifn_freesession, hifn_process);
		crypto_register(sc->sc_cid, CRYPTO_SHA1_HMAC, 0, 0,
		    hifn_newsession, hifn_freesession, hifn_process);
		crypto_register(sc->sc_cid, CRYPTO_DES_CBC, 0, 0,
		    hifn_newsession, hifn_freesession, hifn_process);
d308 3
@


1.132
log
@whoops, last write tracker should be updated on every write to avoid the burst write problem on 7811.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.131 2002/07/29 05:45:28 jason Exp $	*/
d119 8
d133 2
a134 14
	struct pci_attach_args *pa = (struct pci_attach_args *) aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INVERTEX &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INVERTEX_AEON)
		return (1);
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_HIFN &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7751 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7951 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7811))
		return (1);
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_NETSEC &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETSEC_7751)
		return (1);
	return (0);
@


1.131
log
@hifn isn't sure if the burst write problem applies to the 7811 rev 1 or not, so play it safe and apply the workaround on all 7811's.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.130 2002/07/25 15:27:20 jason Exp $	*/
a2319 2
			sc->sc_waw_lastgroup = reggrp;
			sc->sc_waw_lastreg = reg;
d2321 2
@


1.130
log
@house cleaning, also fix a couple of incorrect bit definitions in the
(currently unused) pk engine
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.129 2002/07/23 19:25:09 jason Exp $	*/
d167 2
a168 1
		sc->sc_flags |= HIFN_IS_7811 | HIFN_HAS_RNG | HIFN_HAS_LEDS;
a197 8

	if (sc->sc_flags & HIFN_IS_7811) {
		u_int32_t revid;

		revid = READ_REG_1(sc, HIFN_1_REVID);
		if (revid == HIFN_REVID_7811_PB3_2)
			sc->sc_flags |= HIFN_NO_BURSTWRITE;
	}
@


1.129
log
@from reading sam@@errno.com's code:
- TRDY and RETRY register definitions were backwards
- move TRDY/RETRY setup into its own function
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.128 2002/07/23 17:53:46 jason Exp $	*/
d676 1
a676 1
	addr = READ_REG_1(sc, HIFN_UNLOCK_SECRET1);
d678 1
a678 1
	WRITE_REG_1(sc, HIFN_UNLOCK_SECRET2, 0);
d683 1
a683 1
		WRITE_REG_1(sc, HIFN_UNLOCK_SECRET2, addr);
@


1.128
log
@Don't use a magic constant
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.127 2002/07/23 17:50:33 jason Exp $	*/
d88 1
d196 1
a196 3
	cmd = pci_conf_read(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT);
	cmd &= 0xffff0000;
	pci_conf_write(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT, cmd);
d487 11
d540 1
a540 3
	reg = pci_conf_read(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT);
	reg &= 0xffff0000;
	pci_conf_write(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT, reg);
a1091 1
	u_int32_t reg;
d1094 1
a1094 3
	reg = pci_conf_read(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT);
	reg &= 0xffff0000;
	pci_conf_write(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT, reg);
@


1.127
log
@Turn READ/WRITE into function calls (driver was getting too bloated with
inline macro's; if hifn wanted to make it possible to write a very efficient
driver they would have fixed the bugs in the chips).  Also, invalidate the
burst write checks when a read is executed.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.126 2002/07/22 18:05:10 jason Exp $	*/
d203 1
a203 1
		if (revid == 0x2)
@


1.126
log
@uninitialized variable; pointed out by sam@@errno.com
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.125 2002/07/21 19:55:33 jason Exp $	*/
d112 3
a114 1
void	hifn_write_waw_4(struct hifn_softc *, int, bus_size_t, u_int32_t);
d209 1
a209 1
		sc->sc_waw_lastreg = 0xffffffff;
d2307 1
a2307 1
hifn_write_waw_4(sc, reggrp, reg, val)
d2318 8
a2325 8
	if (sc->sc_waw_lastgroup != reggrp)
		goto chipit;
	if (sc->sc_waw_lastreg == reg - 4)
		bus_space_read_4(sc->sc_st1, sc->sc_sh1, HIFN_1_REVID);

chipit:
	sc->sc_waw_lastgroup = reggrp;
	sc->sc_waw_lastreg = reg;
d2330 16
@


1.125
log
@Flip on the LEDs on a 7811 when each of the rings is active (and turn them
off when not), I should really get a life.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.124 2002/07/21 19:08:26 jason Exp $	*/
d200 1
a200 1
		READ_REG_1(sc, HIFN_1_REVID);
@


1.124
log
@Deal with the fact that one of the 7811 revisions cannot correctly handle
burst writes (bridges may coalesce sequential writes into a burst) by
inserting a read (I know, icky!) in between sequential writes.  Thanks
to sam@@errno.com, GTGI, and Hifn for helping track this one down.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.123 2002/07/16 21:27:39 jason Exp $	*/
d164 1
a164 1
		sc->sc_flags |= HIFN_IS_7811 | HIFN_HAS_RNG;
d757 1
d1518 1
d1538 1
d1566 1
d1620 1
d1625 1
d1634 1
@


1.123
log
@Two fixes from sam@@errno.com:
- fix a reference after free on the src mbuf in hifn_callback()
- prevent a mbuf leak on error in hifn_crypto()
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.122 2002/07/05 21:21:17 jason Exp $	*/
d112 1
d197 13
d2295 26
@


1.122
log
@Never call crp_callback directly, use crypto_done() instead
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.121 2002/07/05 21:03:46 jason Exp $	*/
d1578 3
a2181 1
			m_freem(cmd->srcu.src_m);
d2193 1
@


1.121
log
@KNF (no space after casts)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.120 2002/05/17 00:33:34 deraadt Exp $	*/
d2070 1
a2070 1
	crp->crp_callback(crp);
@


1.120
log
@simplify dmesg printout (all models have all crypto)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.119 2002/05/07 20:37:24 jason Exp $	*/
d1827 1
a1827 1
	u_int32_t sid = ((u_int32_t) tid) & 0xffffffff;
@


1.119
log
@7811 needs a short pause before setting up the DMA CSR during reset or it
will hang during the first DMA operation on some machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.118 2002/04/30 16:03:19 jason Exp $	*/
d278 1
a278 1
	printf(", %d%cB %cram, %s\n", rseg, rbase,
d678 1
a679 3
	case HIFN_PUSTAT_ENA_0:
		printf(": no encr/auth");
		break;
a680 2
		printf(": DES");
		break;
a681 1
		printf(": 3DES");
d683 1
d685 1
a685 1
		printf(": disabled");
@


1.118
log
@- increase sample size from 1 byte to 4 bytes so that we can detect
alias's > 4MB
- remove extra initialization loop (cut/pasto)
based on private email from Henric Jungheim <henric@@henric.info>
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.117 2002/04/29 15:41:21 jason Exp $	*/
d718 2
@


1.117
log
@Rework memory detection (again) based on code from Henric Jungheim <henric@@henric.info>
Also, while here, improve memory detection speed (poll for valid bit to be reset and exit as soon as it is or we timeout).
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.116 2002/04/08 17:49:42 jason Exp $	*/
a824 4
/*
 * For sram boards, just write/read memory until it fails, also check for
 * banking.
 */
d836 1
a836 1
	int i;
a840 3
	for (a = 0; a < sizeof(data); a++)
		data[a] = dataexpect[a] = 0x5a;

d843 1
a843 1
		data[0] = i;
d849 1
a849 1
		dataexpect[0] = i;
@


1.116
log
@Credit DARPA/USAF appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.115 2002/03/14 01:26:58 millert Exp $	*/
d829 4
d837 7
a843 2
	u_int32_t a = 0, end;
	u_int8_t data[8], dataexpect[8];
d848 4
a851 9
	end = 1 << 20;	/* 1MB */
	for (a = 0; a < end; a += 16384) {
		if (hifn_writeramaddr(sc, a, data) < 0)
			return (0);
		if (hifn_readramaddr(sc, a, data) < 0)
			return (0);
		if (bcmp(data, dataexpect, sizeof(data)) != 0)
			return (0);
		sc->sc_ramsize = a + 16384;
d854 3
a856 7
	for (a = 0; a < sizeof(data); a++)
		data[a] = dataexpect[a] = 0xa5;
	if (hifn_writeramaddr(sc, 0, data) < 0)
		return (0);

	end = sc->sc_ramsize;
	for (a = 0; a < end; a += 16384) {
d859 1
a859 1
		if (a != 0 && bcmp(data, dataexpect, sizeof(data)) == 0)
d861 1
a861 1
		sc->sc_ramsize = a + 16384;
d973 14
a986 9
	DELAY(3000);	/* let write command execute */

	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
	    0, sc->sc_dmamap->dm_mapsize,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

	if (dma->resr[resi].l & htole32(HIFN_D_VALID)) {
		printf("\n%s: writeramaddr error -- "
		    "result[%d](addr %d) valid still set\n",
d989 1
d1040 14
a1053 9
	DELAY(3000);	/* let read command execute */

	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
	    0, sc->sc_dmamap->dm_mapsize,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

	if (dma->resr[resi].l & htole32(HIFN_D_VALID)) {
		printf("\n%s: readramaddr error -- "
		    "result[%d](addr %d) valid still set\n",
@


1.115
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.114 2002/01/31 21:17:37 jason Exp $	*/
d36 5
@


1.114
log
@Whoops!  Add back matching of 7951; Matthias Bauer <bauerm@@immd1.informatik.uni-erlangen.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.113 2002/01/23 15:59:12 jason Exp $	*/
d68 2
a69 2
int hifn_probe		__P((struct device *, void *, void *));
void hifn_attach	__P((struct device *, struct device *, void *));
d79 28
a106 28
void	hifn_reset_board __P((struct hifn_softc *, int));
void	hifn_reset_puc __P((struct hifn_softc *));
void	hifn_puc_wait __P((struct hifn_softc *));
int	hifn_enable_crypto __P((struct hifn_softc *, pcireg_t));
void	hifn_init_dma __P((struct hifn_softc *));
void	hifn_init_pci_registers __P((struct hifn_softc *));
int	hifn_sramsize __P((struct hifn_softc *));
int	hifn_dramsize __P((struct hifn_softc *));
int	hifn_ramtype __P((struct hifn_softc *));
void	hifn_sessions __P((struct hifn_softc *));
int	hifn_intr __P((void *));
u_int	hifn_write_command __P((struct hifn_command *, u_int8_t *));
u_int32_t hifn_next_signature __P((u_int32_t a, u_int cnt));
int	hifn_newsession __P((u_int32_t *, struct cryptoini *));
int	hifn_freesession __P((u_int64_t));
int	hifn_process __P((struct cryptop *));
void	hifn_callback __P((struct hifn_softc *, struct hifn_command *, u_int8_t *));
int	hifn_crypto __P((struct hifn_softc *, struct hifn_command *, struct cryptop *));
int	hifn_readramaddr __P((struct hifn_softc *, int, u_int8_t *));
int	hifn_writeramaddr __P((struct hifn_softc *, int, u_int8_t *));
int	hifn_dmamap_aligned __P((bus_dmamap_t));
int	hifn_dmamap_load_src __P((struct hifn_softc *, struct hifn_command *));
int	hifn_dmamap_load_dst __P((struct hifn_softc *, struct hifn_command *));
int	hifn_init_pubrng __P((struct hifn_softc *));
void	hifn_rng __P((void *));
void	hifn_tick __P((void *));
void	hifn_abort __P((struct hifn_softc *));
void	hifn_alloc_slot __P((struct hifn_softc *, int *, int *, int *, int *));
@


1.113
log
@Add defn for MIPS reset register and use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.112 2002/01/09 01:53:39 jason Exp $	*/
d123 1
@


1.112
log
@o There's no such thing as a source overrun, remove the definition
o enable illegal read/write interrupts on 7811 (mainly for debugging)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.111 2002/01/08 23:17:24 jason Exp $	*/
d514 2
a515 1
			if (READ_REG_1(sc, 0x94) & 0x4000)
@


1.111
log
@Add support for the Hifn 7811 (Thanks to GTGI for donating the card).
While here, avoid resetting the card so often during the ram probe [speeds up autoconf and simplifies the driver a bit].
Also, add a missing argument to a debugging printf() (no longer ever called because the abort timers are disabled =)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.110 2001/11/14 00:14:47 jason Exp $	*/
d721 1
a721 1
	    HIFN_DMACSR_S_WAIT | HIFN_DMACSR_S_OVER |
d724 6
a729 2
	    HIFN_DMACSR_C_EIRQ |
	    ((sc->sc_flags & HIFN_HAS_PUBLIC) ? HIFN_DMACSR_PUBDONE : 0));
d732 4
a735 2
	    HIFN_DMAIER_S_OVER | HIFN_DMAIER_D_OVER | HIFN_DMAIER_R_OVER |
	    HIFN_DMAIER_S_ABORT | HIFN_DMAIER_D_ABORT | HIFN_DMAIER_R_ABORT;
d1641 1
a1641 2
	restart = dmacsr & (HIFN_DMACSR_S_OVER | HIFN_DMACSR_D_OVER |
	    HIFN_DMACSR_R_OVER);
d1644 7
@


1.110
log
@- Sprinkle more htole16/htole32s so that this thing has a chance of working
on big endian machines.  (Unfortunately I can't verify this really works
on sparc64 because of crazy psycho(4) interrupt problems).
- use htole32() on constants instead of letoh32() on variables and hope for
better optimization.
- In several places use the unswizzled shadows to see what kind of operation
has been queued instead of the (now) swizzled versions.
- hifn provides some BE/LE assist, but it seems to vary depending on revision
and chip number, perhaps it's worth investigating?
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.109 2001/11/12 19:32:23 jason Exp $	*/
d97 2
a98 2
int	hifn_readramaddr __P((struct hifn_softc *, int, u_int8_t *, int));
int	hifn_writeramaddr __P((struct hifn_softc *, int, u_int8_t *, int));
d106 1
d122 2
a123 4
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7751)
		return (1);
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_HIFN &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7951)
d155 4
a248 9
	/*
	 * Reinitialize again, since the DRAM/SRAM detection shifted our ring
	 * pointers and may have changed the value we send to the RAM Config
	 * Register.
	 */
	hifn_reset_board(sc, 0);
	hifn_init_dma(sc);
	hifn_init_pci_registers(sc);

d337 1
d340 11
a350 2
	WRITE_REG_1(sc, HIFN_1_PUB_RESET,
	    READ_REG_1(sc, HIFN_1_PUB_RESET) | HIFN_PUBRST_RESET);
d352 5
a356 9
	for (i = 0; i < 100; i++) {
		DELAY(1000);
		if ((READ_REG_1(sc, HIFN_1_PUB_RESET) & HIFN_PUBRST_RESET)
		    == 0)
			break;
	}
	if (i == 100) {
		printf("%s: public key init failed\n", sc->sc_dv.dv_xname);
		return (1);
d361 15
a375 2
		WRITE_REG_1(sc, HIFN_1_RNG_CONFIG,
		    READ_REG_1(sc, HIFN_1_RNG_CONFIG) | HIFN_RNGCFG_ENA);
d400 2
a401 1
	u_int32_t num;
d403 10
a412 1
	num = READ_REG_1(sc, HIFN_1_RNG_DATA);
d414 21
a434 4
	if (sc->sc_rngfirst)
		sc->sc_rngfirst = 0;
	else
		add_true_randomness(num);
d511 10
d568 5
d776 4
a786 4
	hifn_reset_board(sc, 0);
	hifn_init_dma(sc);
	hifn_init_pci_registers(sc);

d789 1
a789 1
	if (hifn_writeramaddr(sc, 0, data, 0))
d791 1
a791 1
	if (hifn_readramaddr(sc, 0, data, 1))
d800 1
a800 1
	if (hifn_writeramaddr(sc, 0, data, 2))
d802 1
a802 1
	if (hifn_readramaddr(sc, 0, data, 3))
a825 3
	hifn_reset_board(sc, 0);
	hifn_init_dma(sc);
	hifn_init_pci_registers(sc);
d828 1
a828 1
		if (hifn_writeramaddr(sc, a, data, 0) < 0)
d830 1
a830 1
		if (hifn_readramaddr(sc, a, data, 1) < 0)
a833 3
		hifn_reset_board(sc, 0);
		hifn_init_dma(sc);
		hifn_init_pci_registers(sc);
d839 1
a839 1
	if (hifn_writeramaddr(sc, 0, data, 0) < 0)
d844 1
a844 4
		hifn_reset_board(sc, 0);
		hifn_init_dma(sc);
		hifn_init_pci_registers(sc);
		if (hifn_readramaddr(sc, a, data, 0) < 0)
a850 4
	hifn_reset_board(sc, 0);
	hifn_init_dma(sc);
	hifn_init_pci_registers(sc);

d871 48
d920 1
a920 1
hifn_writeramaddr(sc, addr, data, slot)
d922 1
a922 1
	int addr, slot;
d928 1
a928 1
	int r;
d935 2
d942 2
a943 2
	bzero(dma->command_bufs[slot], HIFN_MAX_COMMAND);
	*(hifn_base_command_t *)dma->command_bufs[slot] = wc;
d946 1
a946 1
	dma->srcr[slot].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr
d948 1
a948 1
	dma->dstr[slot].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr
d951 4
a954 4
	dma->cmdr[slot].l = htole32(16 | masks);
	dma->srcr[slot].l = htole32(8 | masks);
	dma->dstr[slot].l = htole32(4 | masks);
	dma->resr[slot].l = htole32(4 | masks);
d966 1
a966 1
	if (dma->resr[slot].l & htole32(HIFN_D_VALID)) {
d969 1
a969 1
		    sc->sc_dv.dv_xname, slot, addr);
a970 1
		return (-1);
d982 1
a982 1
hifn_readramaddr(sc, addr, data, slot)
d984 1
a984 1
	int addr, slot;
d990 1
a990 1
	int r;
d997 2
d1003 2
a1004 2
	bzero(dma->command_bufs[slot], HIFN_MAX_COMMAND);
	*(hifn_base_command_t *)dma->command_bufs[slot] = rc;
d1006 1
a1006 1
	dma->srcr[slot].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
d1009 1
a1009 1
	dma->dstr[slot].p =  htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
d1012 4
a1015 4
	dma->cmdr[slot].l = htole32(8 | masks);
	dma->srcr[slot].l = htole32(8 | masks);
	dma->dstr[slot].l = htole32(8 | masks);
	dma->resr[slot].l = htole32(HIFN_MAX_RESULT | masks);
d1027 1
a1027 1
	if (dma->resr[slot].l & htole32(HIFN_D_VALID)) {
d1030 1
a1030 1
		    sc->sc_dv.dv_xname, slot, addr);
d1643 1
a1643 1
		printf("%s: abort, resetting.\n");
@


1.110.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.114 2002/01/31 21:17:37 jason Exp $	*/
d97 2
a98 2
int	hifn_readramaddr __P((struct hifn_softc *, int, u_int8_t *));
int	hifn_writeramaddr __P((struct hifn_softc *, int, u_int8_t *));
a105 1
void	hifn_alloc_slot __P((struct hifn_softc *, int *, int *, int *, int *));
d121 4
a124 3
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7751 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7951 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7811))
a155 4
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_HIFN &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7811)
		sc->sc_flags |= HIFN_IS_7811 | HIFN_HAS_RNG;

d246 9
a342 1
	u_int32_t r;
d345 2
a346 11
	if ((sc->sc_flags & HIFN_IS_7811) == 0) {
		/* Reset 7951 public key/rng engine */
		WRITE_REG_1(sc, HIFN_1_PUB_RESET,
		    READ_REG_1(sc, HIFN_1_PUB_RESET) | HIFN_PUBRST_RESET);

		for (i = 0; i < 100; i++) {
			DELAY(1000);
			if ((READ_REG_1(sc, HIFN_1_PUB_RESET) &
			    HIFN_PUBRST_RESET) == 0)
				break;
		}
d348 9
a356 5
		if (i == 100) {
			printf("%s: public key init failed\n",
			    sc->sc_dv.dv_xname);
			return (1);
		}
d361 2
a362 15
		if (sc->sc_flags & HIFN_IS_7811) {
			r = READ_REG_1(sc, HIFN_1_7811_RNGENA);
			if (r & HIFN_7811_RNGENA_ENA) {
				r &= ~HIFN_7811_RNGENA_ENA;
				WRITE_REG_1(sc, HIFN_1_7811_RNGENA, r);
			}
			WRITE_REG_1(sc, HIFN_1_7811_RNGCFG,
			    HIFN_7811_RNGCFG_DEFL);
			r |= HIFN_7811_RNGENA_ENA;
			WRITE_REG_1(sc, HIFN_1_7811_RNGENA, r);
		} else
			WRITE_REG_1(sc, HIFN_1_RNG_CONFIG,
			    READ_REG_1(sc, HIFN_1_RNG_CONFIG) |
			    HIFN_RNGCFG_ENA);

d387 1
a387 13
	u_int32_t num1, sts, num2;
	int i;

	if (sc->sc_flags & HIFN_IS_7811) {
		for (i = 0; i < 5; i++) {
			sts = READ_REG_1(sc, HIFN_1_7811_RNGSTS);
			if (sts & HIFN_7811_RNGSTS_UFL) {
				printf("%s: RNG underflow: disabling\n",
				    sc->sc_dv.dv_xname);
				return;
			}
			if ((sts & HIFN_7811_RNGSTS_RDY) == 0)
				break;
d389 1
a389 15
			/*
			 * There are at least two words in the RNG FIFO
			 * at this point.
			 */
			num1 = READ_REG_1(sc, HIFN_1_7811_RNGDAT);
			num2 = READ_REG_1(sc, HIFN_1_7811_RNGDAT);
			if (sc->sc_rngfirst)
				sc->sc_rngfirst = 0;
			else {
				add_true_randomness(num1);
				add_true_randomness(num2);
			}
		}
	} else {
		num1 = READ_REG_1(sc, HIFN_1_RNG_DATA);
d391 4
a394 5
		if (sc->sc_rngfirst)
			sc->sc_rngfirst = 0;
		else
			add_true_randomness(num1);
	}
a470 11

	if (sc->sc_flags & HIFN_IS_7811) {
		for (reg = 0; reg < 1000; reg++) {
			if (READ_REG_1(sc, HIFN_1_7811_MIPSRST) &
			    HIFN_MIPSRST_CRAMINIT)
				break;
			DELAY(1000);
		}
		if (reg == 1000)
			printf(": cram init timeout\n");
	}
a517 5
		PCI_VENDOR_HIFN,
		PCI_PRODUCT_HIFN_7811,
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00 }
	}, {
d666 1
a666 1
	    HIFN_DMACSR_S_WAIT |
d669 2
a670 6
	    HIFN_DMACSR_ENGINE |
	    ((sc->sc_flags & HIFN_HAS_PUBLIC) ?
		HIFN_DMACSR_PUBDONE : 0) |
	    ((sc->sc_flags & HIFN_IS_7811) ?
		HIFN_DMACSR_ILLW | HIFN_DMACSR_ILLR : 0));

d673 2
a674 4
	    HIFN_DMAIER_D_OVER | HIFN_DMAIER_R_OVER |
	    HIFN_DMAIER_S_ABORT | HIFN_DMAIER_D_ABORT | HIFN_DMAIER_R_ABORT |
	    ((sc->sc_flags & HIFN_IS_7811) ?
		HIFN_DMAIER_ILLW | HIFN_DMAIER_ILLR : 0);
a720 4
/*
 * Determine ram type (sram or dram).  Board should be just out of a reset
 * state when this is called.
 */
d728 4
d734 1
a734 1
	if (hifn_writeramaddr(sc, 0, data))
d736 1
a736 1
	if (hifn_readramaddr(sc, 0, data))
d745 1
a745 1
	if (hifn_writeramaddr(sc, 0, data))
d747 1
a747 1
	if (hifn_readramaddr(sc, 0, data))
d771 3
d776 1
a776 1
		if (hifn_writeramaddr(sc, a, data) < 0)
d778 1
a778 1
		if (hifn_readramaddr(sc, a, data) < 0)
d782 3
d790 1
a790 1
	if (hifn_writeramaddr(sc, 0, data) < 0)
d795 4
a798 1
		if (hifn_readramaddr(sc, a, data) < 0)
d805 4
a828 48
void
hifn_alloc_slot(sc, cmdp, srcp, dstp, resp)
	struct hifn_softc *sc;
	int *cmdp, *srcp, *dstp, *resp;
{
	struct hifn_dma *dma = sc->sc_dma;

	if (dma->cmdi == HIFN_D_CMD_RSIZE) {
		dma->cmdi = 0;
		dma->cmdr[HIFN_D_CMD_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_CMDR_SYNC(sc, HIFN_D_CMD_RSIZE,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	*cmdp = dma->cmdi++;
	dma->cmdk = dma->cmdi;

	if (dma->srci == HIFN_D_SRC_RSIZE) {
		dma->srci = 0;
		dma->srcr[HIFN_D_SRC_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_SRCR_SYNC(sc, HIFN_D_SRC_RSIZE,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	*srcp = dma->srci++;
	dma->srck = dma->srci;

	if (dma->dsti == HIFN_D_DST_RSIZE) {
		dma->dsti = 0;
		dma->dstr[HIFN_D_DST_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_DSTR_SYNC(sc, HIFN_D_DST_RSIZE,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	*dstp = dma->dsti++;
	dma->dstk = dma->dsti;

	if (dma->resi == HIFN_D_RES_RSIZE) {
		dma->resi = 0;
		dma->resr[HIFN_D_RES_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_RESR_SYNC(sc, HIFN_D_RES_RSIZE,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	*resp = dma->resi++;
	dma->resk = dma->resi;
}

d830 1
a830 1
hifn_writeramaddr(sc, addr, data)
d832 1
a832 1
	int addr;
d838 1
a838 1
	int r, cmdi, resi, srci, dsti;
a844 2
	hifn_alloc_slot(sc, &cmdi, &srci, &dsti, &resi);

d850 2
a851 2
	bzero(dma->command_bufs[cmdi], HIFN_MAX_COMMAND);
	*(hifn_base_command_t *)dma->command_bufs[cmdi] = wc;
d854 1
a854 1
	dma->srcr[srci].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr
d856 1
a856 1
	dma->dstr[dsti].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr
d859 4
a862 4
	dma->cmdr[cmdi].l = htole32(16 | masks);
	dma->srcr[srci].l = htole32(8 | masks);
	dma->dstr[dsti].l = htole32(4 | masks);
	dma->resr[resi].l = htole32(4 | masks);
d874 1
a874 1
	if (dma->resr[resi].l & htole32(HIFN_D_VALID)) {
d877 1
a877 1
		    sc->sc_dv.dv_xname, resi, addr);
d879 1
d891 1
a891 1
hifn_readramaddr(sc, addr, data)
d893 1
a893 1
	int addr;
d899 1
a899 1
	int r, cmdi, srci, dsti, resi;
a905 2
	hifn_alloc_slot(sc, &cmdi, &srci, &dsti, &resi);

d910 2
a911 2
	bzero(dma->command_bufs[cmdi], HIFN_MAX_COMMAND);
	*(hifn_base_command_t *)dma->command_bufs[cmdi] = rc;
d913 1
a913 1
	dma->srcr[srci].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
d916 1
a916 1
	dma->dstr[dsti].p =  htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
d919 4
a922 4
	dma->cmdr[cmdi].l = htole32(8 | masks);
	dma->srcr[srci].l = htole32(8 | masks);
	dma->dstr[dsti].l = htole32(8 | masks);
	dma->resr[resi].l = htole32(HIFN_MAX_RESULT | masks);
d934 1
a934 1
	if (dma->resr[resi].l & htole32(HIFN_D_VALID)) {
d937 1
a937 1
		    sc->sc_dv.dv_xname, resi, addr);
d1542 2
a1543 1
	restart = dmacsr & (HIFN_DMACSR_D_OVER | HIFN_DMACSR_R_OVER);
a1546 7
	if (sc->sc_flags & HIFN_IS_7811) {
		if (dmacsr & HIFN_DMACSR_ILLR)
			printf("%s: illegal read\n", sc->sc_dv.dv_xname);
		if (dmacsr & HIFN_DMACSR_ILLW)
			printf("%s: illegal write\n", sc->sc_dv.dv_xname);
	}

d1550 1
a1550 1
		printf("%s: abort, resetting.\n", sc->sc_dv.dv_xname);
@


1.110.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.110.2.1 2002/01/31 22:55:34 niklas Exp $	*/
a35 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d68 2
a69 2
int hifn_probe(struct device *, void *, void *);
void hifn_attach(struct device *, struct device *, void *);
d79 28
a106 28
void	hifn_reset_board(struct hifn_softc *, int);
void	hifn_reset_puc(struct hifn_softc *);
void	hifn_puc_wait(struct hifn_softc *);
int	hifn_enable_crypto(struct hifn_softc *, pcireg_t);
void	hifn_init_dma(struct hifn_softc *);
void	hifn_init_pci_registers(struct hifn_softc *);
int	hifn_sramsize(struct hifn_softc *);
int	hifn_dramsize(struct hifn_softc *);
int	hifn_ramtype(struct hifn_softc *);
void	hifn_sessions(struct hifn_softc *);
int	hifn_intr(void *);
u_int	hifn_write_command(struct hifn_command *, u_int8_t *);
u_int32_t hifn_next_signature(u_int32_t a, u_int cnt);
int	hifn_newsession(u_int32_t *, struct cryptoini *);
int	hifn_freesession(u_int64_t);
int	hifn_process(struct cryptop *);
void	hifn_callback(struct hifn_softc *, struct hifn_command *, u_int8_t *);
int	hifn_crypto(struct hifn_softc *, struct hifn_command *, struct cryptop *);
int	hifn_readramaddr(struct hifn_softc *, int, u_int8_t *);
int	hifn_writeramaddr(struct hifn_softc *, int, u_int8_t *);
int	hifn_dmamap_aligned(bus_dmamap_t);
int	hifn_dmamap_load_src(struct hifn_softc *, struct hifn_command *);
int	hifn_dmamap_load_dst(struct hifn_softc *, struct hifn_command *);
int	hifn_init_pubrng(struct hifn_softc *);
void	hifn_rng(void *);
void	hifn_tick(void *);
void	hifn_abort(struct hifn_softc *);
void	hifn_alloc_slot(struct hifn_softc *, int *, int *, int *, int *);
d273 1
a273 1
	printf("%d%cB %cram, %s\n", rseg, rbase,
a672 1
	printf(": ");
d674 3
d678 2
d681 1
a682 1
	case HIFN_PUSTAT_ENA_0:
d684 1
a684 1
		printf("disabled, ");
a713 2
	DELAY(2000);

d820 4
a823 4
#define	HIFN_SRAM_MAX		(32 << 20)
#define	HIFN_SRAM_STEP_SIZE	16384
#define	HIFN_SRAM_GRANULARITY	(HIFN_SRAM_MAX / HIFN_SRAM_STEP_SIZE)

d828 2
a829 4
	u_int32_t a;
	u_int8_t data[8];
	u_int8_t dataexpect[sizeof(data)];
	int32_t i;
d831 2
a832 2
	for (i = 0; i < sizeof(data); i++)
		data[i] = dataexpect[i] = i ^ 0x5a;
d834 9
a842 4
	for (i = HIFN_SRAM_GRANULARITY - 1; i >= 0; i--) {
		a = i * HIFN_SRAM_STEP_SIZE;
		bcopy(&i, data, sizeof(i));
		hifn_writeramaddr(sc, a, data);
d845 7
a851 3
	for (i = 0; i < HIFN_SRAM_GRANULARITY; i++) {
		a = i * HIFN_SRAM_STEP_SIZE;
		bcopy(&i, dataexpect, sizeof(i));
d854 1
a854 1
		if (bcmp(data, dataexpect, sizeof(data)) != 0)
d856 1
a856 1
		sc->sc_ramsize = a + HIFN_SRAM_STEP_SIZE;
d968 9
a976 14
	for (r = 10000; r >= 0; r--) {
		DELAY(10);
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    0, sc->sc_dmamap->dm_mapsize,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		if ((dma->resr[resi].l & htole32(HIFN_D_VALID)) == 0)
			break;
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    0, sc->sc_dmamap->dm_mapsize,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	}
	if (r == 0) {
		printf("%s: writeramaddr -- "
		    "result[%d](addr %d) still valid\n",
a978 1
		return (-1);
d1029 9
a1037 14
	for (r = 10000; r >= 0; r--) {
		DELAY(10);
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    0, sc->sc_dmamap->dm_mapsize,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		if ((dma->resr[resi].l & htole32(HIFN_D_VALID)) == 0)
			break;
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    0, sc->sc_dmamap->dm_mapsize,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	}
	if (r == 0) {
		printf("%s: readramaddr -- "
		    "result[%d](addr %d) still valid\n",
@


1.110.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.110.2.2 2002/06/11 03:42:24 art Exp $	*/
a87 1
void	hifn_set_retry(struct hifn_softc *);
a111 3
void	hifn_write_4(struct hifn_softc *, int, bus_size_t, u_int32_t);
u_int32_t hifn_read_4(struct hifn_softc *, int, bus_size_t);

d163 1
a163 2
		sc->sc_flags |= HIFN_IS_7811 | HIFN_HAS_RNG | HIFN_HAS_LEDS |
		    HIFN_NO_BURSTWRITE;
d192 3
a194 6
	hifn_set_retry(sc);

	if (sc->sc_flags & HIFN_NO_BURSTWRITE) {
		sc->sc_waw_lastgroup = -1;
		sc->sc_waw_lastreg = 1;
	}
a471 11
void
hifn_set_retry(sc)
	struct hifn_softc *sc;
{
	u_int32_t r;

	r = pci_conf_read(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_TRDY_TIMEOUT);
	r &= 0xffff0000;
	pci_conf_write(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_TRDY_TIMEOUT, r);
}

d514 3
a516 1
	hifn_set_retry(sc);
d652 1
a652 1
	addr = READ_REG_1(sc, HIFN_1_UNLOCK_SECRET1);
d654 1
a654 1
	WRITE_REG_1(sc, HIFN_1_UNLOCK_SECRET2, 0);
d659 1
a659 1
		WRITE_REG_1(sc, HIFN_1_UNLOCK_SECRET2, addr);
a742 1
	CLR_LED(sc, HIFN_MIPSRST_LED0 | HIFN_MIPSRST_LED1 | HIFN_MIPSRST_LED2);
d1067 1
d1070 3
a1072 1
	hifn_set_retry(sc);
a1502 1
		SET_LED(sc, HIFN_MIPSRST_LED0);
a1521 1
		SET_LED(sc, HIFN_MIPSRST_LED1);
a1548 1
		SET_LED(sc, HIFN_MIPSRST_LED2);
a1577 3
	if (crp->crp_flags & CRYPTO_F_IMBUF &&
	    cmd->srcu.src_m != cmd->dstu.dst_m)
		m_freem(cmd->dstu.dst_m);
a1598 1
			CLR_LED(sc, HIFN_MIPSRST_LED0);
a1602 1
			CLR_LED(sc, HIFN_MIPSRST_LED1);
a1610 1
			CLR_LED(sc, HIFN_MIPSRST_LED2);
d1827 1
a1827 1
	u_int32_t sid = ((u_int32_t)tid) & 0xffffffff;
d2070 1
a2070 1
	crypto_done(crp);
d2179 1
a2190 1
			m_freem(cmd->srcu.src_m);
a2277 42
}

void
hifn_write_4(sc, reggrp, reg, val)
	struct hifn_softc *sc;
	int reggrp;
	bus_size_t reg;
	u_int32_t val;
{
	/*
	 * 7811 PB3 rev/2 parts lock-up on burst writes to Group 0
	 * and Group 1 registers; avoid conditions that could create
	 * burst writes by doing a read in between the writes.
	 */
	if (sc->sc_flags & HIFN_NO_BURSTWRITE) {
		if (sc->sc_waw_lastgroup == reggrp &&
		    sc->sc_waw_lastreg == reg - 4) {
			bus_space_read_4(sc->sc_st1, sc->sc_sh1, HIFN_1_REVID);
		}
		sc->sc_waw_lastgroup = reggrp;
		sc->sc_waw_lastreg = reg;
	}
	if (reggrp == 0)
		bus_space_write_4(sc->sc_st0, sc->sc_sh0, reg, val);
	else
		bus_space_write_4(sc->sc_st1, sc->sc_sh1, reg, val);

}

u_int32_t
hifn_read_4(sc, reggrp, reg)
	struct hifn_softc *sc;
	int reggrp;
	bus_size_t reg;
{
	if (sc->sc_flags & HIFN_NO_BURSTWRITE) {
		sc->sc_waw_lastgroup = -1;
		sc->sc_waw_lastreg = 1;
	}
	if (reggrp == 0)
		return (bus_space_read_4(sc->sc_st0, sc->sc_sh0, reg));
	return (bus_space_read_4(sc->sc_st1, sc->sc_sh1, reg));
@


1.110.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d102 1
a102 2
int	hifn_crypto(struct hifn_softc *, struct hifn_command *,
    struct cryptop *);
d115 1
a115 6
int	hifn_compression(struct hifn_softc *, struct cryptop *,
    struct hifn_command *);
struct mbuf *hifn_mkmbuf_chain(int, struct mbuf *);
int	hifn_compress_enter(struct hifn_softc *, struct hifn_command *);
void	hifn_callback_comp(struct hifn_softc *, struct hifn_command *,
    u_int8_t *);
a118 8
const struct pci_matchid hifn_devices[] = {
	{ PCI_VENDOR_INVERTEX, PCI_PRODUCT_INVERTEX_AEON },
	{ PCI_VENDOR_HIFN, PCI_PRODUCT_HIFN_7751 },
	{ PCI_VENDOR_HIFN, PCI_PRODUCT_HIFN_7811 },
	{ PCI_VENDOR_HIFN, PCI_PRODUCT_HIFN_7951 },
	{ PCI_VENDOR_NETSEC, PCI_PRODUCT_NETSEC_7751 },
};

d125 14
a138 2
	return (pci_matchbyid((struct pci_attach_args *)aux, hifn_devices,
	    sizeof(hifn_devices)/sizeof(hifn_devices[0])));
a156 1
	int algs[CRYPTO_ALGORITHM_MAX + 1];
a296 3
	bzero(algs, sizeof(algs));

	algs[CRYPTO_LZS_COMP] = CRYPTO_ALG_FLAG_SUPPORTED;
d299 4
a302 2
		algs[CRYPTO_3DES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_ARC4] = CRYPTO_ALG_FLAG_SUPPORTED;
d305 10
a314 5
		algs[CRYPTO_MD5] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_SHA1] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_MD5_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_SHA1_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_DES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
a316 3
	crypto_register(sc->sc_cid, algs, hifn_newsession,
	    hifn_freesession, hifn_process);

d695 1
a696 3
	case HIFN_PUSTAT_ENA_0:
		offtbl = "LZS-only";
		break;
a697 2
		offtbl = "DES";
		break;
a698 1
		offtbl = "3DES";
d700 1
d702 1
a702 1
		offtbl = "disabled";
a704 1
	printf(": %s, ", offtbl);
d706 1
a706 1
	return (0);
a755 1
	    HIFN_DMAIER_ENGINE |
d948 1
a948 1
	struct hifn_base_command wc;
d965 1
a965 1
	*(struct hifn_base_command *)dma->command_bufs[cmdi] = wc;
d1016 1
a1016 1
	struct hifn_base_command rc;
d1032 1
a1032 1
	*(struct hifn_base_command *)dma->command_bufs[cmdi] = rc;
d1125 4
a1128 5
	struct hifn_base_command *base_cmd;
	struct hifn_mac_command *mac_cmd;
	struct hifn_crypt_command *cry_cmd;
	struct hifn_comp_command *comp_cmd;
	int using_mac, using_crypt, using_comp, len;
a1133 1
	using_comp = cmd->base_masks & HIFN_BASE_CMD_COMP;
d1135 1
a1135 1
	base_cmd = (struct hifn_base_command *)buf_pos;
d1150 1
a1150 13
	buf_pos += sizeof(struct hifn_base_command);

	if (using_comp) {
		comp_cmd = (struct hifn_comp_command *)buf_pos;
		dlen = cmd->compcrd->crd_len;
		comp_cmd->source_count = htole16(dlen & 0xffff);
		dlen >>= 16;
		comp_cmd->masks = htole16(cmd->comp_masks |
		    ((dlen << HIFN_COMP_CMD_SRCLEN_S) & HIFN_COMP_CMD_SRCLEN_M));
		comp_cmd->header_skip = htole16(cmd->compcrd->crd_skip);
		comp_cmd->reserved = 0;
		buf_pos += sizeof(struct hifn_comp_command);
	}
d1153 1
a1153 1
		mac_cmd = (struct hifn_mac_command *)buf_pos;
d1161 1
a1161 1
		buf_pos += sizeof(struct hifn_mac_command);
d1165 1
a1165 1
		cry_cmd = (struct hifn_crypt_command *)buf_pos;
d1173 1
a1173 1
		buf_pos += sizeof(struct hifn_crypt_command);
d1212 1
a1212 2
	if ((cmd->base_masks & (HIFN_BASE_CMD_MAC | HIFN_BASE_CMD_CRYPT |
	    HIFN_BASE_CMD_COMP)) == 0) {
d1428 1
a1428 2
				if (m0->m_flags & M_PKTHDR)
					m0->m_pkthdr.len += len;
a1585 1
	cmd->cmd_callback = hifn_callback;
a1668 3
	if (dmacsr & HIFN_DMACSR_ENGINE)
		WRITE_REG_0(sc, HIFN_0_PUISR, READ_REG_0(sc, HIFN_0_PUISR));

d1674 1
a1674 1
	restart = dmacsr & (HIFN_DMACSR_R_OVER | HIFN_DMACSR_D_OVER);
d1694 1
a1694 1
	if ((dmacsr & HIFN_DMACSR_C_WAIT) && (dma->resu == 0)) {
d1705 2
a1706 2
	i = dma->resk;
	while (dma->resu != 0) {
d1717 1
d1722 6
a1727 1
			(*cmd->cmd_callback)(sc, cmd, dma->result_bufs[i]);
d1729 1
a1733 2
		else
			dma->resu--;
d1735 1
a1735 1
	dma->resk = i;
d1786 1
a1786 1
	int i, mac = 0, cry = 0, comp = 0;
a1826 5
		case CRYPTO_LZS_COMP:
			if (comp)
				return (EINVAL);
			comp = 1;
			break;
d1831 1
a1831 8
	if (mac == 0 && cry == 0 && comp == 0)
		return (EINVAL);

	/*
	 * XXX only want to support compression without chaining to
	 * MAC/crypt engine right now
	 */
	if ((comp && mac) || (comp && cry))
a1932 2
		} else if (crd1->crd_alg == CRYPTO_LZS_COMP) {
			return (hifn_compression(sc, crp, cmd));
d1939 3
a1941 3
		     crd1->crd_alg == CRYPTO_SHA1_HMAC ||
		     crd1->crd_alg == CRYPTO_MD5 ||
		     crd1->crd_alg == CRYPTO_SHA1) &&
d1953 3
a1955 3
		     crd2->crd_alg == CRYPTO_SHA1_HMAC ||
		     crd2->crd_alg == CRYPTO_MD5 ||
		     crd2->crd_alg == CRYPTO_SHA1) &&
d2044 1
a2044 1
			break;
d2114 7
d2122 1
a2122 1
			(*cmd->cmd_callback)(sc, cmd, dma->result_bufs[i]);
d2179 1
a2179 1
hifn_callback(sc, cmd, resbuf)
d2182 1
a2182 1
	u_int8_t *resbuf;
d2271 1
a2271 8
	if (cmd->base_masks & HIFN_BASE_CMD_MAC) {
		u_int8_t *macbuf;

		macbuf = resbuf + sizeof(struct hifn_base_result);
		if (cmd->base_masks & HIFN_BASE_CMD_COMP)
			macbuf += sizeof(struct hifn_comp_result);
		macbuf += sizeof(struct hifn_mac_result);

d2273 1
a2273 1
			int len;
d2275 8
a2282 8
			if (crd->crd_alg == CRYPTO_MD5)
				len = 16;
			else if (crd->crd_alg == CRYPTO_SHA1)
				len = 20;
			else if (crd->crd_alg == CRYPTO_MD5_HMAC ||
			    crd->crd_alg == CRYPTO_SHA1_HMAC)
				len = 12;
			else
d2287 1
a2287 1
				    crd->crd_inject, len, macbuf);
a2301 410
}

int
hifn_compression(struct hifn_softc *sc, struct cryptop *crp,
    struct hifn_command *cmd)
{
	struct cryptodesc *crd = crp->crp_desc;
	int s, err = 0;

	cmd->compcrd = crd;
	cmd->base_masks |= HIFN_BASE_CMD_COMP;

	if ((crp->crp_flags & CRYPTO_F_IMBUF) == 0) {
		/*
		 * XXX can only handle mbufs right now since we can
		 * XXX dynamically resize them.
		 */
		err = EINVAL;
		return (ENOMEM);
	}

	if ((crd->crd_flags & CRD_F_COMP) == 0)
		cmd->base_masks |= HIFN_BASE_CMD_DECODE;
	if (crd->crd_alg == CRYPTO_LZS_COMP)
		cmd->comp_masks |= HIFN_COMP_CMD_ALG_LZS |
		    HIFN_COMP_CMD_CLEARHIST;

	if (bus_dmamap_create(sc->sc_dmat, HIFN_MAX_DMALEN, MAX_SCATTER,
	    HIFN_MAX_SEGLEN, 0, BUS_DMA_NOWAIT, &cmd->src_map)) {
		err = ENOMEM;
		goto fail;
	}

	if (bus_dmamap_create(sc->sc_dmat, HIFN_MAX_DMALEN, MAX_SCATTER,
	    HIFN_MAX_SEGLEN, 0, BUS_DMA_NOWAIT, &cmd->dst_map)) {
		err = ENOMEM;
		goto fail;
	}

	if (crp->crp_flags & CRYPTO_F_IMBUF) {
		int len;

		if (bus_dmamap_load_mbuf(sc->sc_dmat, cmd->src_map,
		    cmd->srcu.src_m, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
			goto fail;
		}

		len = cmd->src_map->dm_mapsize / MCLBYTES;
		if ((cmd->src_map->dm_mapsize % MCLBYTES) != 0)
			len++;
		len *= MCLBYTES;

		if ((crd->crd_flags & CRD_F_COMP) == 0)
			len *= 4;

		if (len > HIFN_MAX_DMALEN)
			len = HIFN_MAX_DMALEN;

		cmd->dstu.dst_m = hifn_mkmbuf_chain(len, cmd->srcu.src_m);
		if (cmd->dstu.dst_m == NULL) {
			err = ENOMEM;
			goto fail;
		}

		if (bus_dmamap_load_mbuf(sc->sc_dmat, cmd->dst_map,
		    cmd->dstu.dst_m, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
			goto fail;
		}
	} else if (crp->crp_flags & CRYPTO_F_IOV) {
		if (bus_dmamap_load_uio(sc->sc_dmat, cmd->src_map,
		    cmd->srcu.src_io, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
			goto fail;
		}
		if (bus_dmamap_load_uio(sc->sc_dmat, cmd->dst_map,
		    cmd->dstu.dst_io, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
			goto fail;
		}
	}

	if (cmd->src_map == cmd->dst_map)
		bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
		    0, cmd->src_map->dm_mapsize,
		    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
	else {
		bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
		    0, cmd->src_map->dm_mapsize, BUS_DMASYNC_PREWRITE);
		bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
		    0, cmd->dst_map->dm_mapsize, BUS_DMASYNC_PREREAD);
	}

	cmd->crp = crp;
	/*
	 * Always use session 0.  The modes of compression we use are
	 * stateless and there is always at least one compression
	 * context, zero.
	 */
	cmd->session_num = 0;
	cmd->softc = sc;

	s = splnet();
	err = hifn_compress_enter(sc, cmd);
	splx(s);

	if (err != 0)
		goto fail;
	return (0);

fail:
	if (cmd->dst_map != NULL) {
		if (cmd->dst_map->dm_nsegs > 0)
			bus_dmamap_unload(sc->sc_dmat, cmd->dst_map);
		bus_dmamap_destroy(sc->sc_dmat, cmd->dst_map);
	}
	if (cmd->src_map != NULL) {
		if (cmd->src_map->dm_nsegs > 0)
			bus_dmamap_unload(sc->sc_dmat, cmd->src_map);
		bus_dmamap_destroy(sc->sc_dmat, cmd->src_map);
	}
	free(cmd, M_DEVBUF);
	if (err == EINVAL)
		hifnstats.hst_invalid++;
	else
		hifnstats.hst_nomem++;
	crp->crp_etype = err;
	crypto_done(crp);
	return (0);
}

/*
 * must be called at splnet()
 */
int
hifn_compress_enter(struct hifn_softc *sc, struct hifn_command *cmd)
{
	struct hifn_dma *dma = sc->sc_dma;
	int cmdi, resi;
	u_int32_t cmdlen;

	if ((dma->cmdu + 1) > HIFN_D_CMD_RSIZE ||
	    (dma->resu + 1) > HIFN_D_CMD_RSIZE)
		return (ENOMEM);

	if ((dma->srcu + cmd->src_map->dm_nsegs) > HIFN_D_SRC_RSIZE ||
	    (dma->dstu + cmd->dst_map->dm_nsegs) > HIFN_D_DST_RSIZE)
		return (ENOMEM);

	if (dma->cmdi == HIFN_D_CMD_RSIZE) {
		dma->cmdi = 0;
		dma->cmdr[HIFN_D_CMD_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_CMDR_SYNC(sc, HIFN_D_CMD_RSIZE,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	cmdi = dma->cmdi++;
	cmdlen = hifn_write_command(cmd, dma->command_bufs[cmdi]);
	HIFN_CMD_SYNC(sc, cmdi, BUS_DMASYNC_PREWRITE);

	/* .p for command/result already set */
	dma->cmdr[cmdi].l = htole32(cmdlen | HIFN_D_VALID | HIFN_D_LAST |
	    HIFN_D_MASKDONEIRQ);
	HIFN_CMDR_SYNC(sc, cmdi,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	dma->cmdu++;
	if (sc->sc_c_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_C_CTRL_ENA);
		sc->sc_c_busy = 1;
		SET_LED(sc, HIFN_MIPSRST_LED0);
	}

	/*
	 * We don't worry about missing an interrupt (which a "command wait"
	 * interrupt salvages us from), unless there is more than one command
	 * in the queue.
	 */
	if (dma->cmdu > 1) {
		sc->sc_dmaier |= HIFN_DMAIER_C_WAIT;
		WRITE_REG_1(sc, HIFN_1_DMA_IER, sc->sc_dmaier);
	}

	hifnstats.hst_ipackets++;
	hifnstats.hst_ibytes += cmd->src_map->dm_mapsize;

	hifn_dmamap_load_src(sc, cmd);
	if (sc->sc_s_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_S_CTRL_ENA);
		sc->sc_s_busy = 1;
		SET_LED(sc, HIFN_MIPSRST_LED1);
	}

	/*
	 * Unlike other descriptors, we don't mask done interrupt from
	 * result descriptor.
	 */
	if (dma->resi == HIFN_D_RES_RSIZE) {
		dma->resi = 0;
		dma->resr[HIFN_D_RES_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_RESR_SYNC(sc, HIFN_D_RES_RSIZE,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	}
	resi = dma->resi++;
	dma->hifn_commands[resi] = cmd;
	HIFN_RES_SYNC(sc, resi, BUS_DMASYNC_PREREAD);
	dma->resr[resi].l = htole32(HIFN_MAX_RESULT |
	    HIFN_D_VALID | HIFN_D_LAST);
	HIFN_RESR_SYNC(sc, resi,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	dma->resu++;
	if (sc->sc_r_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_R_CTRL_ENA);
		sc->sc_r_busy = 1;
		SET_LED(sc, HIFN_MIPSRST_LED2);
	}

	if (cmd->sloplen)
		cmd->slopidx = resi;

	hifn_dmamap_load_dst(sc, cmd);

	if (sc->sc_d_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_D_CTRL_ENA);
		sc->sc_d_busy = 1;
	}
	sc->sc_active = 5;
	cmd->cmd_callback = hifn_callback_comp;
	return (0);
}

void
hifn_callback_comp(struct hifn_softc *sc, struct hifn_command *cmd,
    u_int8_t *resbuf)
{
	struct hifn_base_result baseres;
	struct cryptop *crp = cmd->crp;
	struct hifn_dma *dma = sc->sc_dma;
	struct mbuf *m;
	int err = 0, i, u;
	u_int32_t olen;
	bus_size_t dstsize;

	bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
	    0, cmd->src_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
	bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
	    0, cmd->dst_map->dm_mapsize, BUS_DMASYNC_POSTREAD);

	dstsize = cmd->dst_map->dm_mapsize;
	bus_dmamap_unload(sc->sc_dmat, cmd->dst_map);

	bcopy(resbuf, &baseres, sizeof(struct hifn_base_result));

	i = dma->dstk; u = dma->dstu;
	while (u != 0) {
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    offsetof(struct hifn_dma, dstr[i]), sizeof(struct hifn_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		if (dma->dstr[i].l & htole32(HIFN_D_VALID)) {
			bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
			    offsetof(struct hifn_dma, dstr[i]),
			    sizeof(struct hifn_desc),
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			break;
		}
		if (++i == (HIFN_D_DST_RSIZE + 1))
			i = 0;
		else
			u--;
	}
	dma->dstk = i; dma->dstu = u;

	if (baseres.flags & htole16(HIFN_BASE_RES_DSTOVERRUN)) {
		bus_size_t xlen;

		xlen = dstsize;

		m_freem(cmd->dstu.dst_m);

		if (xlen == HIFN_MAX_DMALEN) {
			/* We've done all we can. */
			err = E2BIG;
			goto out;
		}

		xlen += MCLBYTES;

		if (xlen > HIFN_MAX_DMALEN)
			xlen = HIFN_MAX_DMALEN;

		cmd->dstu.dst_m = hifn_mkmbuf_chain(xlen,
		    cmd->srcu.src_m);
		if (cmd->dstu.dst_m == NULL) {
			err = ENOMEM;
			goto out;
		}
		if (bus_dmamap_load_mbuf(sc->sc_dmat, cmd->dst_map,
		    cmd->dstu.dst_m, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
			goto out;
		}

		bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
		    0, cmd->src_map->dm_mapsize, BUS_DMASYNC_PREWRITE);
		bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
		    0, cmd->dst_map->dm_mapsize, BUS_DMASYNC_PREREAD);

		/* already at splnet... */
		err = hifn_compress_enter(sc, cmd);
		if (err != 0)
			goto out;
		return;
	}

	olen = dstsize - (letoh16(baseres.dst_cnt) |
	    (((letoh16(baseres.session) & HIFN_BASE_RES_DSTLEN_M) >>
	    HIFN_BASE_RES_DSTLEN_S) << 16));

	crp->crp_olen = olen - cmd->compcrd->crd_skip;

	bus_dmamap_unload(sc->sc_dmat, cmd->src_map);
	bus_dmamap_destroy(sc->sc_dmat, cmd->src_map);
	bus_dmamap_destroy(sc->sc_dmat, cmd->dst_map);

	m = cmd->dstu.dst_m;
	if (m->m_flags & M_PKTHDR)
		m->m_pkthdr.len = olen;
	crp->crp_buf = (caddr_t)m;
	for (; m != NULL; m = m->m_next) {
		if (olen >= m->m_len)
			olen -= m->m_len;
		else {
			m->m_len = olen;
			olen = 0;
		}
	}

	m_freem(cmd->srcu.src_m);
	free(cmd, M_DEVBUF);
	crp->crp_etype = 0;
	crypto_done(crp);
	return;

out:
	if (cmd->dst_map != NULL) {
		if (cmd->src_map->dm_nsegs != 0)
			bus_dmamap_unload(sc->sc_dmat, cmd->src_map);
		bus_dmamap_destroy(sc->sc_dmat, cmd->dst_map);
	}
	if (cmd->src_map != NULL) {
		if (cmd->src_map->dm_nsegs != 0)
			bus_dmamap_unload(sc->sc_dmat, cmd->src_map);
		bus_dmamap_destroy(sc->sc_dmat, cmd->src_map);
	}
	if (cmd->dstu.dst_m != NULL)
		m_freem(cmd->dstu.dst_m);
	free(cmd, M_DEVBUF);
	crp->crp_etype = err;
	crypto_done(crp);
}

struct mbuf *
hifn_mkmbuf_chain(int totlen, struct mbuf *mtemplate)
{
	int len;
	struct mbuf *m, *m0, *mlast;

	if (mtemplate->m_flags & M_PKTHDR) {
		len = MHLEN;
		MGETHDR(m0, M_DONTWAIT, MT_DATA);
	} else {
		len = MLEN;
		MGET(m0, M_DONTWAIT, MT_DATA);
	}
	if (m0 == NULL)
		return (NULL);
	if (len == MHLEN)
		M_DUP_PKTHDR(m0, mtemplate);
	MCLGET(m0, M_DONTWAIT);
	if (!(m0->m_flags & M_EXT))
		m_freem(m0);
	len = MCLBYTES;

	totlen -= len;
	m0->m_pkthdr.len = m0->m_len = len;
	mlast = m0;

	while (totlen > 0) {
		MGET(m, M_DONTWAIT, MT_DATA);
		if (m == NULL) {
			m_freem(m0);
			return (NULL);
		}
		MCLGET(m, M_DONTWAIT);
		if (!(m->m_flags & M_EXT)) {
			m_freem(m0);
			return (NULL);
		}
		len = MCLBYTES;
		m->m_len = len;
		if (m0->m_flags & M_PKTHDR)
			m0->m_pkthdr.len += len;
		totlen -= len;

		mlast->m_next = m;
		mlast = m;
	}

	return (m0);
@


1.109
log
@Sprinkle with htole32, add a garnish of htole16 and finish off with a
bit of letoh16 and letoh32 then let simmer while sparc64 gets through
the ram test correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.108 2001/11/12 18:04:06 jason Exp $	*/
d297 4
a300 4
               crypto_register(sc->sc_cid, CRYPTO_MD5, 0, 0,
                   hifn_newsession, hifn_freesession, hifn_process);
               crypto_register(sc->sc_cid, CRYPTO_SHA1, 0, 0,
                   NULL, NULL, NULL);
d304 1
a304 1
		    NULL, NULL, NULL);
d306 1
a306 1
		    NULL, NULL, NULL);
d874 1
a874 1
	if (letoh32(dma->resr[slot].l) & HIFN_D_VALID) {
d934 1
a934 1
	if (letoh32(dma->resr[slot].l) & HIFN_D_VALID) {
d1013 1
a1013 1
	base_cmd->masks = cmd->base_masks;
d1020 2
a1021 2
	base_cmd->total_source_count = slen & HIFN_BASE_CMD_LENMASK_LO;
	base_cmd->total_dest_count = dlen & HIFN_BASE_CMD_LENMASK_LO;
d1024 1
a1024 1
	base_cmd->session_num = cmd->session_num |
d1026 1
a1026 1
	    ((dlen << HIFN_BASE_CMD_DSTLEN_S) & HIFN_BASE_CMD_DSTLEN_M);
d1032 1
a1032 1
		mac_cmd->source_count = dlen & 0xffff;
d1034 3
a1036 3
		mac_cmd->masks = cmd->mac_masks |
		    ((dlen << HIFN_MAC_CMD_SRCLEN_S) & HIFN_MAC_CMD_SRCLEN_M);
		mac_cmd->header_skip = cmd->maccrd->crd_skip;
d1044 1
a1044 1
		cry_cmd->source_count = dlen & 0xffff;
d1046 3
a1048 3
		cry_cmd->masks = cmd->cry_masks |
		    ((dlen << HIFN_CRYPT_CMD_SRCLEN_S) & HIFN_CRYPT_CMD_SRCLEN_M);
		cry_cmd->header_skip = cmd->enccrd->crd_skip;
d1053 1
a1053 1
	if (using_mac && mac_cmd->masks & HIFN_MAC_CMD_NEW_KEY) {
d1058 2
a1059 2
	if (using_crypt && cry_cmd->masks & HIFN_CRYPT_CMD_NEW_KEY) {
		switch (cry_cmd->masks & HIFN_CRYPT_CMD_ALG_MASK) {
d1084 1
a1084 1
	if (using_crypt && cry_cmd->masks & HIFN_CRYPT_CMD_NEW_IV) {
d1089 1
a1089 1
	if ((base_cmd->masks & (HIFN_BASE_CMD_MAC | HIFN_BASE_CMD_CRYPT)) == 0) {
d1125 3
a1127 3
		dma->dstr[idx].p = map->dm_segs[i].ds_addr;
		dma->dstr[idx].l = HIFN_D_VALID | HIFN_D_MASKDONEIRQ |
		    map->dm_segs[i].ds_len;
d1133 2
a1134 2
			dma->dstr[idx].l = HIFN_D_VALID | HIFN_D_JUMP |
			    HIFN_D_MASKDONEIRQ;
d1152 4
a1155 3
			dma->dstr[idx].p = map->dm_segs[i].ds_addr;
			dma->dstr[idx].l = HIFN_D_VALID | HIFN_D_MASKDONEIRQ |
			    (map->dm_segs[i].ds_len - cmd->sloplen);
d1161 2
a1162 2
				dma->dstr[idx].l = HIFN_D_VALID |
				    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ;
d1169 2
a1170 2
	dma->dstr[idx].p = p;
	dma->dstr[idx].l = l;
d1175 2
a1176 2
		dma->dstr[idx].l = HIFN_D_VALID | HIFN_D_JUMP |
		    HIFN_D_MASKDONEIRQ;
d1202 3
a1204 3
		dma->srcr[idx].p = map->dm_segs[i].ds_addr;
		dma->srcr[idx].l = map->dm_segs[i].ds_len | HIFN_D_VALID |
		    HIFN_D_MASKDONEIRQ | last;
d1209 2
a1210 2
			dma->srcr[idx].l = HIFN_D_VALID | HIFN_D_JUMP |
			    HIFN_D_MASKDONEIRQ;
d1377 2
a1378 2
		dma->cmdr[HIFN_D_CMD_RSIZE].l = HIFN_D_VALID | HIFN_D_JUMP |
		    HIFN_D_MASKDONEIRQ;
a1383 4
#ifdef HIFN_DEBUG
	printf("write_command %d (nice %d)\n", cmdlen,
	    hifn_dmamap_aligned(cmd->src_map));
#endif
d1387 2
a1388 2
	dma->cmdr[cmdi].l = cmdlen | HIFN_D_VALID | HIFN_D_LAST |
	    HIFN_D_MASKDONEIRQ;
d1425 2
a1426 2
		dma->resr[HIFN_D_RES_RSIZE].l = HIFN_D_VALID | HIFN_D_JUMP |
		    HIFN_D_MASKDONEIRQ;
d1433 2
a1434 1
	dma->resr[resi].l = HIFN_MAX_RESULT | HIFN_D_VALID | HIFN_D_LAST;
d1571 1
a1571 1
		if (dma->resr[i].l & HIFN_D_VALID) {
d1603 1
a1603 1
		if (dma->srcr[i].l & HIFN_D_VALID) {
d1619 1
a1619 1
		if (dma->cmdr[i].l & HIFN_D_VALID) {
d1974 1
a1974 1
		if ((dma->resr[i].l & HIFN_D_VALID) == 0) {
d2096 1
a2096 1
		if (dma->dstr[i].l & HIFN_D_VALID) {
@


1.108
log
@Don't abuse bus_dma(9) API by using dmamap->dm_* to hold results from
bus_dmamem_* operations; instead, store them in softc.  This allows
the driver to get through autoconf on sparc64 (ok, well it fails the
ram test because of endian issues... but it's a start).
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.107 2001/11/09 03:11:38 deraadt Exp $	*/
d840 4
a843 4
	wc.masks = 3 << 13;
	wc.session_num = addr >> 14;
	wc.total_source_count = 8;
	wc.total_dest_count = addr & 0x3fff;;
d854 9
a862 9
	dma->srcr[slot].p = sc->sc_dmamap->dm_segs[0].ds_addr
	    + offsetof(struct hifn_dma, test_src);
	dma->dstr[slot].p = sc->sc_dmamap->dm_segs[0].ds_addr
	    + offsetof(struct hifn_dma, test_dst);

	dma->cmdr[slot].l = 16 | masks;
	dma->srcr[slot].l = 8 | masks;
	dma->dstr[slot].l = 4 | masks;
	dma->resr[slot].l = 4 | masks;
d874 1
a874 1
	if (dma->resr[slot].l & HIFN_D_VALID) {
d881 1
a881 1
	    r = 0;
d901 4
a904 4
	rc.masks = 2 << 13;
	rc.session_num = addr >> 14;
	rc.total_source_count = addr & 0x3fff;
	rc.total_dest_count = 8;
d913 2
a914 2
	dma->srcr[slot].p = sc->sc_dmamap->dm_segs[0].ds_addr +
	    offsetof(struct hifn_dma, test_src);
d916 2
a917 2
	dma->dstr[slot].p =  sc->sc_dmamap->dm_segs[0].ds_addr +
	    offsetof(struct hifn_dma, test_dst);
d919 4
a922 4
	dma->cmdr[slot].l = 8 | masks;
	dma->srcr[slot].l = 8 | masks;
	dma->dstr[slot].l = 8 | masks;
	dma->resr[slot].l = HIFN_MAX_RESULT | masks;
d934 1
a934 1
	if (dma->resr[slot].l & HIFN_D_VALID) {
d968 2
a969 2
		dma->cmdr[i].p = sc->sc_dmamap->dm_segs[0].ds_addr +
		    offsetof(struct hifn_dma, command_bufs[i][0]);
d971 15
a985 2
		dma->resr[i].p = sc->sc_dmamap->dm_segs[0].ds_addr +
		    offsetof(struct hifn_dma, result_bufs[i][0]);
a986 8
	dma->cmdr[HIFN_D_CMD_RSIZE].p = sc->sc_dmamap->dm_segs[0].ds_addr
	    + offsetof(struct hifn_dma, cmdr[0]);
	dma->srcr[HIFN_D_SRC_RSIZE].p = sc->sc_dmamap->dm_segs[0].ds_addr
	    + offsetof(struct hifn_dma, srcr[0]);
	dma->dstr[HIFN_D_DST_RSIZE].p = sc->sc_dmamap->dm_segs[0].ds_addr
	    + offsetof(struct hifn_dma, dstr[0]);
	dma->resr[HIFN_D_RES_RSIZE].p = sc->sc_dmamap->dm_segs[0].ds_addr
	    + offsetof(struct hifn_dma, resr[0]);
@


1.107
log
@be way more sure that software cannot be used
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.106 2001/11/06 19:53:19 miod Exp $	*/
d194 1
a194 2
	    sc->sc_dmamap->dm_segs, 1, &sc->sc_dmamap->dm_nsegs,
	    BUS_DMA_NOWAIT)) {
d199 2
a200 3
	if (bus_dmamem_map(sc->sc_dmat, sc->sc_dmamap->dm_segs,
	    sc->sc_dmamap->dm_nsegs, sizeof(*sc->sc_dma), &kva,
	    BUS_DMA_NOWAIT)) {
d203 1
a203 2
		bus_dmamem_free(sc->sc_dmat, sc->sc_dmamap->dm_segs,
		    sc->sc_dmamap->dm_nsegs);
d211 1
a211 2
		bus_dmamem_free(sc->sc_dmat, sc->sc_dmamap->dm_segs,
		    sc->sc_dmamap->dm_nsegs);
d326 1
a326 2
	bus_dmamem_free(sc->sc_dmat, sc->sc_dmamap->dm_segs,
	    sc->sc_dmamap->dm_nsegs);
@


1.106
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.105 2001/11/05 17:25:58 art Exp $	*/
d285 1
a285 1
	sc->sc_cid = crypto_get_driverid();
@


1.105
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.104 2001/11/04 18:31:42 jason Exp $	*/
d51 1
a51 1
#include <vm/vm.h>
@


1.104
log
@7751 has two registers in config space (0x40 - RETRY_TIMEOUT and 0x41,
TRDY_TIMEOUT).  These registers must be initialized to zero to disable
these timers or 7751 will get PCI aborts on its descriptor rings on
certain chipsets.  These timers were removed because they were unneeded
in the 7951.  I'm not sure how I missed this in the datasheet, but there
it is plain as day on page 24.  Thanks go to Hifn for pointing this out.

Upshot: PCI abort problem on 7751 appears to be solved.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.103 2001/09/06 03:31:34 jason Exp $	*/
a108 8
#ifdef __HAS_NEW_BUS_DMAMAP_SYNC
#define hifn_bus_dmamap_sync(t, m, o, l, f) \
    bus_dmamap_sync((t), (m), (o), (l), (f))
#else
#define hifn_bus_dmamap_sync(t, m, o, l, f) \
    bus_dmamap_sync((t), (m), (f))
#endif

d313 1
a313 1
	hifn_bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
d869 1
a869 1
	hifn_bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
d875 1
a875 1
	hifn_bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
d929 1
a929 1
	hifn_bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
d935 1
a935 1
	hifn_bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
d1345 1
a1345 1
		hifn_bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
d1349 1
a1349 1
		hifn_bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
d1351 1
a1351 1
		hifn_bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
d1989 1
a1989 1
				hifn_bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
d1993 1
a1993 1
				hifn_bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
d1996 1
a1996 1
				hifn_bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
d2055 1
a2055 1
		hifn_bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
d2059 1
a2059 1
		hifn_bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
d2061 1
a2061 1
		hifn_bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
d2095 1
a2095 1
		hifn_bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
d2099 1
a2099 1
			hifn_bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
@


1.103
log
@Rewrite interrupt handler a bit... ack interrupts sooner.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.102 2001/08/28 21:40:54 jason Exp $	*/
d157 3
d191 4
d448 2
d480 4
d972 1
d975 4
d1560 1
@


1.103.2.1
log
@Pull in patch from current:
7751 has two registers in config space (0x40 - RETRY_TIMEOUT and 0x41,
TRDY_TIMEOUT).  These registers must be initialized to zero to disable
these timers or 7751 will get PCI aborts on its descriptor rings on
certain chipsets.  These timers were removed because they were unneeded
in the 7951.  I'm not sure how I missed this in the datasheet, but there
it is plain as day on page 24.  Thanks go to Hifn for pointing this out.

Upshot: PCI abort problem on 7751 appears to be solved.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.103 2001/09/06 03:31:34 jason Exp $	*/
a156 3
	sc->sc_pci_pc = pa->pa_pc;
	sc->sc_pci_tag = pa->pa_tag;

a187 4
	cmd = pci_conf_read(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT);
	cmd &= 0xffff0000;
	pci_conf_write(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT, cmd);

a440 2
	u_int32_t reg;

a470 4

	reg = pci_conf_read(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT);
	reg &= 0xffff0000;
	pci_conf_write(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT, reg);
a958 1
	u_int32_t reg;
a960 4
	reg = pci_conf_read(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT);
	reg &= 0xffff0000;
	pci_conf_write(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT, reg);

a1541 1
		printf("%s: abort, resetting.\n");
@


1.103.2.2
log
@Pull in patch from current:
Fix (deraadt):
be way more sure that software cannot be used
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.103.2.1 2001/11/13 17:23:54 jason Exp $	*/
d293 1
a293 1
	sc->sc_cid = crypto_get_driverid(0);
@


1.102
log
@an attempt at deuglification of the previous commit (It's still ugly, tho)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.101 2001/08/28 18:52:16 jason Exp $	*/
d1511 1
a1511 1
	u_int32_t dmacsr, restart, rings = 0;
d1527 2
d1530 1
a1530 2
	    (dmacsr & HIFN_DMACSR_PUBDONE)) {
		dmacsr &= ~HIFN_DMACSR_PUBDONE;
a1532 1
	}
d1536 1
a1536 1
	if (restart) {
a1537 2
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, restart);
	}
a1546 4
	if (dma->resu > HIFN_D_RES_RSIZE)
		printf("%s: Internal Error -- ring overflow\n",
		    sc->sc_dv.dv_xname);

a1556 1

a1623 7
	/*
	 * Clear "result done" and "command wait" flags in status register.
	 * If we still have slots to process and we received a "command wait"
	 * interrupt, this will interupt us again.
	 */
	WRITE_REG_1(sc, HIFN_1_DMA_CSR,
	    HIFN_DMACSR_R_DONE | HIFN_DMACSR_C_WAIT | rings);
@


1.101
log
@Relax restriction on buffer length being % 4 = 0 for the last entry in the
chain.  This allows us to avoid mbuf copies (and EINVAL on iov's) for
packets of non "nice" length.  Do this by adding a pad u_int32_t to
catch the (possible) overflow and detecting when it's necessary.  Also,
do a bit of cleaning that ben pointed out.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.100 2001/08/27 21:57:52 jason Exp $	*/
d100 2
a101 2
int	hifn_dmamap_load __P((struct hifn_softc *, bus_dmamap_t, int,
    struct hifn_desc *, int, volatile int *, bus_addr_t));
d1104 1
a1104 1
hifn_dmamap_load(sc, map, idx, desc, ndesc, usedp, off)
d1106 74
a1179 5
	bus_dmamap_t map;
	int idx, ndesc;
	struct hifn_desc *desc;
	volatile int *usedp;
	bus_addr_t off;
d1181 4
a1184 1
	int i, last = 0;
d1186 1
d1191 2
a1192 2
		desc[idx].p = map->dm_segs[i].ds_addr;
		desc[idx].l = map->dm_segs[i].ds_len | HIFN_D_VALID |
d1194 1
a1194 4

		hifn_bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    off + (idx * sizeof(struct hifn_desc)),
		    sizeof(struct hifn_desc),
d1197 2
a1198 2
		if (++idx == ndesc) {
			desc[idx].l = HIFN_D_VALID | HIFN_D_JUMP |
d1200 1
a1200 3
			hifn_bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
			    off + (idx * sizeof(struct hifn_desc)),
			    sizeof(struct hifn_desc),
d1205 2
a1206 1
	*(usedp) += map->dm_nsegs;
d1217 2
a1218 2
	u_int32_t cmdlen, last;
	int cmdi, resi, s, err = 0, idx, i;
d1403 1
a1403 23
	idx = dma->srci;
	for (i = 0; i < cmd->src_map->dm_nsegs; i++) {
		if (i == cmd->src_map->dm_nsegs - 1)
			last = HIFN_D_LAST;
		else
			last = 0;

		dma->srcr[idx].p = cmd->src_map->dm_segs[i].ds_addr;
		dma->srcr[idx].l = cmd->src_map->dm_segs[i].ds_len |
		    HIFN_D_VALID | HIFN_D_MASKDONEIRQ | last;
		HIFN_SRCR_SYNC(sc, idx,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

		if (++idx == HIFN_D_SRC_RSIZE) {
			dma->srcr[idx].l = HIFN_D_VALID | HIFN_D_JUMP |
			    HIFN_D_MASKDONEIRQ;
			HIFN_SRCR_SYNC(sc, idx,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			idx = 0;
		}
	}
	dma->srci = idx;

d1436 1
a1436 1
		cmd->slop = (caddr_t)&dma->slop[resi];
d1438 1
a1438 69
	idx = dma->dsti;
	for (i = 0; i < cmd->dst_map->dm_nsegs; i++) {
		if (i == (cmd->dst_map->dm_nsegs - 1)) {
			if (cmd->sloplen == 0) {
				dma->dstr[idx].p =
				    cmd->dst_map->dm_segs[i].ds_addr;
				dma->dstr[idx].l = HIFN_D_VALID |
				    HIFN_D_MASKDONEIRQ | HIFN_D_LAST |
				    cmd->dst_map->dm_segs[i].ds_len;
			} else {
				if ((cmd->dst_map->dm_segs[i].ds_len -
				    cmd->sloplen) == 0) {
					dma->dstr[idx].p =
					    sc->sc_dmamap->dm_segs[0].ds_addr +
					    offsetof(struct hifn_dma, slop[resi]);
					dma->dstr[idx].l = HIFN_D_VALID |
					    HIFN_D_MASKDONEIRQ | HIFN_D_LAST |
					    sizeof(u_int32_t);
				} else {
					dma->dstr[idx].p =
					    cmd->dst_map->dm_segs[i].ds_addr;
					dma->dstr[idx].l = HIFN_D_VALID |
					    HIFN_D_MASKDONEIRQ |
					    (cmd->dst_map->dm_segs[i].ds_len -
						cmd->sloplen);

					HIFN_DSTR_SYNC(sc, idx,
					    BUS_DMASYNC_PREREAD |
					    BUS_DMASYNC_PREWRITE);

					if (++idx == HIFN_D_DST_RSIZE) {
						dma->dstr[idx].l =
						    HIFN_D_VALID |
						    HIFN_D_JUMP |
						    HIFN_D_MASKDONEIRQ;
						HIFN_DSTR_SYNC(sc, idx,
						    BUS_DMASYNC_PREREAD |
						    BUS_DMASYNC_PREWRITE);
						idx = 0;
					}

					dma->dstr[idx].p =
					    sc->sc_dmamap->dm_segs[0].ds_addr +
					    offsetof(struct hifn_dma, slop[resi]);
					dma->dstr[idx].l = HIFN_D_VALID |
					    HIFN_D_MASKDONEIRQ | HIFN_D_LAST |
					    sizeof(u_int32_t);
				}

			}
		} else {
			dma->dstr[idx].p =
			    cmd->dst_map->dm_segs[i].ds_addr;
			dma->dstr[idx].l = HIFN_D_VALID | HIFN_D_MASKDONEIRQ |
			    cmd->dst_map->dm_segs[i].ds_len;
		}

		HIFN_DSTR_SYNC(sc, idx,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

		if (++idx == HIFN_D_DST_RSIZE) {
			dma->dstr[idx].l = HIFN_D_VALID | HIFN_D_JUMP |
			    HIFN_D_MASKDONEIRQ;
			HIFN_DSTR_SYNC(sc, idx,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			idx = 0;
		}
	}
	dma->dsti = idx;
d2089 1
a2089 1
			    cmd->sloplen, cmd->slop);
d2093 1
a2093 1
			    cmd->sloplen, cmd->slop);
d2156 1
a2156 1
                               bcopy((caddr_t)macbuf, crp->crp_mac, len);
@


1.100
log
@Deal with __HAS_NEW_BUS_DMAMAP_SYNC and try to sync partial maps when possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.99 2001/08/27 18:54:56 jason Exp $	*/
d1005 5
a1009 1
	dlen = cmd->dst_map->dm_mapsize;
d1088 2
a1089 1
hifn_dmamap_aligned(bus_dmamap_t map)
d1094 3
a1096 1
		if ((map->dm_segs[i].ds_addr & 3) ||
d1148 2
a1149 2
	u_int32_t cmdlen;
	int cmdi, resi, s, err = 0;
d1173 1
d1282 8
a1289 4
	if (dma->cmdu+1 > HIFN_D_CMD_RSIZE ||
	    dma->srcu+cmd->src_map->dm_nsegs > HIFN_D_SRC_RSIZE ||
	    dma->dstu+cmd->dst_map->dm_nsegs > HIFN_D_DST_RSIZE ||
	    dma->resu+1 > HIFN_D_RES_RSIZE) {
d1333 24
a1356 4
	
	dma->srci = hifn_dmamap_load(sc, cmd->src_map, dma->srci, dma->srcr,
	    HIFN_D_SRC_RSIZE, &dma->srcu, offsetof(struct hifn_dma,
		srcr[0]));
a1361 8
	dma->dsti = hifn_dmamap_load(sc, cmd->dst_map, dma->dsti, dma->dstr,
	    HIFN_D_DST_RSIZE, &dma->dstu, offsetof(struct hifn_dma,
		dstr[0]));
	if (sc->sc_d_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_D_CTRL_ENA);
		sc->sc_d_busy = 1;
	}

d1388 78
d1809 3
a1811 3
                   crd1->crd_alg == CRYPTO_SHA1_HMAC ||
                   crd1->crd_alg == CRYPTO_SHA1 ||
                   crd1->crd_alg == CRYPTO_MD5) {
d1827 3
a1829 3
                    crd1->crd_alg == CRYPTO_SHA1_HMAC ||
                    crd1->crd_alg == CRYPTO_MD5 ||
                    crd1->crd_alg == CRYPTO_SHA1) &&
d1838 2
a1839 2
		    crd1->crd_alg == CRYPTO_ARC4 ||
		    crd1->crd_alg == CRYPTO_3DES_CBC) &&
d1841 3
a1843 3
                    crd2->crd_alg == CRYPTO_SHA1_HMAC ||
                    crd2->crd_alg == CRYPTO_MD5 ||
                    crd2->crd_alg == CRYPTO_SHA1) &&
d2104 11
@


1.99
log
@initial support for non-HMAC md5/sha1 (work by ben@@ and myself)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.98 2001/08/25 10:13:29 art Exp $	*/
d100 2
a101 2
int	hifn_dmamap_load __P((bus_dmamap_t, int, struct hifn_desc *, int,
    volatile int *));
d109 8
d314 2
a315 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
d864 2
a865 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
d870 2
a871 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
d924 2
a925 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
d930 2
a931 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
d1097 2
a1098 1
hifn_dmamap_load(map, idx, desc, ndesc, usedp)
d1103 1
d1115 5
d1123 4
d1257 10
a1266 2
	bus_dmamap_sync(sc->sc_dmat, cmd->src_map, BUS_DMASYNC_PREREAD);
	bus_dmamap_sync(sc->sc_dmat, cmd->dst_map, BUS_DMASYNC_PREWRITE);
a1269 3
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

a1277 2
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d1287 2
d1296 2
d1301 2
d1322 3
a1324 2
	dma->srci = hifn_dmamap_load(cmd->src_map, dma->srci, dma->srcr,
	    HIFN_D_SRC_RSIZE, &dma->srcu);
d1330 3
a1332 2
	dma->dsti = hifn_dmamap_load(cmd->dst_map, dma->dsti, dma->dstr,
	    HIFN_D_DST_RSIZE, &dma->dstu);
d1349 2
d1354 1
d1356 2
a1369 3
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

a1465 14
#if 0
		if (restart & (~HIFN_DMACSR_C_ABORT)) {
			printf("%s: abort %x, resetting.\n",
			    sc->sc_dv.dv_xname, dmacsr);
			hifn_abort(sc);
			return (1);
		} else {
			printf("%s: abort.\n", sc->sc_dv.dv_xname);
			/* Abort on command ring only, just restart queues */
			WRITE_REG_1(sc, HIFN_1_DMA_CSR, restart |
			    HIFN_DMACSR_C_CTRL_ENA | HIFN_DMACSR_S_CTRL_ENA |
			    HIFN_DMACSR_D_CTRL_ENA | HIFN_DMACSR_R_CTRL_ENA);
		}
#endif
a1467 3
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD); 

d1485 8
a1492 3
	while (u != 0 && (dma->resr[i].l & HIFN_D_VALID) == 0) {
		struct hifn_command *cmd;
		u_int8_t *macbuf = NULL;
d1494 11
a1504 1
		cmd = dma->hifn_commands[i];
d1506 3
a1508 3
		if (cmd->base_masks & HIFN_BASE_CMD_MAC) {
			macbuf = dma->result_bufs[i];
			macbuf += 12;
d1511 1
a1511 4
		hifn_callback(sc, cmd, macbuf);
		hifnstats.hst_opackets++;

		if (++i == HIFN_D_RES_RSIZE)
a1512 1
		u--;
d1517 9
a1525 2
	while (u != 0 && (dma->srcr[i].l & HIFN_D_VALID) == 0) {
		if (++i == HIFN_D_SRC_RSIZE)
d1527 2
a1528 1
		u--;
d1533 13
a1545 2
	while (u != 0 && (dma->cmdr[i].l & HIFN_D_VALID) == 0) {
		if (++i == HIFN_D_CMD_RSIZE)
a1546 1
		u--;
a1556 2
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
d1910 12
a1921 4
			bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
			    BUS_DMASYNC_POSTREAD);
			bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
			    BUS_DMASYNC_POSTWRITE);
d1974 1
a1974 1
	int totlen;
d1976 10
a1985 2
	bus_dmamap_sync(sc->sc_dmat, cmd->src_map, BUS_DMASYNC_POSTREAD);
	bus_dmamap_sync(sc->sc_dmat, cmd->dst_map, BUS_DMASYNC_POSTWRITE);
d2004 19
a2023 2
	dma->dstk = (dma->dstk + cmd->dst_map->dm_nsegs) % HIFN_D_DST_RSIZE;
	dma->dstu -= cmd->dst_map->dm_nsegs;
@


1.98
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.97 2001/08/22 16:34:47 jason Exp $	*/
d294 4
d1548 2
d1660 3
a1662 1
		    crd1->crd_alg == CRYPTO_SHA1_HMAC) {
d1678 3
a1680 1
		     crd1->crd_alg == CRYPTO_SHA1_HMAC) &&
d1692 3
a1694 1
		     crd2->crd_alg == CRYPTO_SHA1_HMAC) &&
a1776 3
		cmd->mac_masks |= HIFN_MAC_CMD_RESULT |
		    HIFN_MAC_CMD_MODE_HMAC | HIFN_MAC_CMD_RESULT |
		    HIFN_MAC_CMD_POS_IPSEC | HIFN_MAC_CMD_TRUNC;
d1778 22
a1799 4
		if (maccrd->crd_alg == CRYPTO_MD5_HMAC)
			cmd->mac_masks |= HIFN_MAC_CMD_ALG_MD5;
		else
			cmd->mac_masks |= HIFN_MAC_CMD_ALG_SHA1;
d1801 3
a1803 1
		if (sc->sc_sessions[session].hs_state == HS_STATE_USED) {
d1817 3
a1819 2
		sc->sc_sessions[session].hs_prev_op=enccrd->crd_flags
		    & CRD_F_ENCRYPT;
d1968 10
a1977 2
			if (crd->crd_alg != CRYPTO_MD5_HMAC &&
			    crd->crd_alg != CRYPTO_SHA1_HMAC)
d1979 1
d1982 1
a1982 1
				    crd->crd_inject, 12, macbuf);
d1984 1
a1984 1
				bcopy((caddr_t)macbuf, crp->crp_mac, 12);
@


1.97
log
@rename hs_flags -> hs_state and use #defines for the state names.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.96 2001/08/22 16:11:31 jason Exp $	*/
d252 1
a252 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.96
log
@better error handling (a merge of ben's stuff and mine)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.95 2001/08/22 05:15:25 jason Exp $	*/
d1538 1
a1538 1
		if (sc->sc_sessions[i].hs_flags == 0)
d1569 1
a1569 1
	sc->sc_sessions[i].hs_flags = 1;
d1704 2
a1705 1
				sc->sc_sessions[session].hs_flags=1;
d1759 1
a1759 1
		if (sc->sc_sessions[session].hs_flags == 1)
d1775 1
a1775 1
		if (sc->sc_sessions[session].hs_flags == 1) {
d1791 2
a1792 2
		if (sc->sc_sessions[session].hs_flags == 1)
			sc->sc_sessions[session].hs_flags = 2;
d1872 2
a1873 2
		if (sc->sc_sessions[i].hs_flags == 2)
			sc->sc_sessions[i].hs_flags = 1;
@


1.95
log
@Better error catching (badly aligned iov's are EINVAL not ENOMEM)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.94 2001/08/17 17:37:12 ben Exp $	*/
a1704 2
			sc->sc_sessions[session].hs_prev_op=enccrd->crd_flags
			    & CRD_F_ENCRYPT;
a1781 3
	if (sc->sc_sessions[session].hs_flags == 1)
		sc->sc_sessions[session].hs_flags = 2;

d1787 7
a1793 2
	if (err == 0)
		return (err);
@


1.94
log
@Add RC4 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.93 2001/08/15 16:59:00 jason Exp $	*/
d1115 1
a1115 1
	int cmdi, resi, s;
d1119 1
a1119 1
		return (-1);
d1123 2
a1124 1
		    cmd->srcu.src_m, BUS_DMA_NOWAIT))
d1126 1
d1129 2
a1130 1
		    cmd->srcu.src_io, BUS_DMA_NOWAIT))
d1132 3
a1134 1
	} else
d1136 1
d1145 2
a1146 1
		if (crp->crp_flags & CRYPTO_F_IOV)
d1148 1
a1148 1
		if (crp->crp_flags & CRYPTO_F_IMBUF) {
d1160 2
a1161 1
			if (m0 == NULL)
d1163 1
d1178 1
d1203 2
a1204 1
		    HIFN_MAX_SEGLEN, 0, BUS_DMA_NOWAIT, &cmd->dst_map))
d1206 1
d1209 2
a1210 1
			    cmd->dstu.dst_m, BUS_DMA_NOWAIT))
d1212 1
d1215 2
a1216 1
			    cmd->dstu.dst_io, BUS_DMA_NOWAIT))
d1218 1
d1249 1
d1332 1
a1332 1
	return 0;		/* success */
d1344 1
a1344 1
	return (-1);
d1791 3
a1793 4
	if (hifn_crypto(sc, cmd, crp) == 0)
		return (0);

	err = ENOMEM;
@


1.93
log
@- Attempt to recover from PCI aborts.  This is a heavy handed approach which
involves running down what's in the queue and resetting the chip.
- remove a DELAY() from reset and just wait for the proc unit to come out of
reset.
- never set the LAST bit in a JUMP descriptor
- use lengths from each map (not just source map) for total_*_length in command
[This does not fix problems with net4501, but may address problems with CA810]
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.92 2001/08/12 20:03:48 mickey Exp $	*/
d291 2
d1685 5
d1705 26
a1730 10
		if (enccrd->crd_flags & CRD_F_ENCRYPT) {
			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
				bcopy(enccrd->crd_iv, cmd->iv, HIFN_IV_LENGTH);
			else
				bcopy(sc->sc_sessions[session].hs_iv,
				    cmd->iv, HIFN_IV_LENGTH);

			if ((enccrd->crd_flags & CRD_F_IV_PRESENT) == 0) {
				if (crp->crp_flags & CRYPTO_F_IMBUF)
					m_copyback(cmd->srcu.src_m,
d1734 1
a1734 1
					cuio_copyback(cmd->srcu.src_io,
a1737 9
		} else {
			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
				bcopy(enccrd->crd_iv, cmd->iv, HIFN_IV_LENGTH);
			else if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copydata(cmd->srcu.src_m, enccrd->crd_inject,
				    HIFN_IV_LENGTH, cmd->iv);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copydata(cmd->srcu.src_io, enccrd->crd_inject,
				    HIFN_IV_LENGTH, cmd->iv);
@


1.92
log
@remove redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.91 2001/08/11 06:40:35 jason Exp $	*/
d79 1
a79 1
void	hifn_reset_board __P((struct hifn_softc *));
d81 1
d100 1
a100 1
void	hifn_dmamap_load __P((bus_dmamap_t, int *, struct hifn_desc *, int,
d105 1
d215 1
a215 1
	hifn_reset_board(sc);
d248 1
a248 1
	hifn_reset_board(sc);
d391 15
a412 2
	int i;

d415 1
a415 8
	for (i = 0; i < 5000; i++) {
		DELAY(1);
		if (!(READ_REG_0(sc, HIFN_0_PUCTRL) & HIFN_PUCTRL_RESET))
			break;
	}
	if (i == 5000)
		printf("\n%s: proc unit did not reset\n",
		    sc->sc_dv.dv_xname);
d423 1
a423 1
hifn_reset_board(sc)
d425 1
d441 9
a449 2
	WRITE_REG_1(sc, HIFN_1_DMA_CNFG,
	    HIFN_DMACNFG_MODE | HIFN_DMACNFG_MSTRESET);
a450 1
	hifn_reset_puc(sc);
d456 1
a456 4
	/*
	 * Wait another millisecond for the board to un-reset.
	 */
	DELAY(1000);
d659 1
d661 1
d714 1
a714 1
	hifn_reset_board(sc);
d757 1
a757 1
	hifn_reset_board(sc);
d768 1
a768 1
		hifn_reset_board(sc);
d781 1
a781 1
		hifn_reset_board(sc);
d791 1
a791 1
	hifn_reset_board(sc);
d978 1
a978 1
	u_int32_t dlen;
d986 3
a988 2
	dlen = cmd->src_map->dm_mapsize;
	base_cmd->total_source_count = dlen & HIFN_BASE_CMD_LENMASK_LO;
d991 1
d993 1
a993 1
	    ((dlen << HIFN_BASE_CMD_SRCLEN_S) & HIFN_BASE_CMD_SRCLEN_M) |
d1078 2
a1079 2
void
hifn_dmamap_load(map, idxp, desc, ndesc, usedp)
d1081 1
a1081 1
	int *idxp, ndesc;
d1085 1
a1085 1
	int i, idx, last = 0;
d1088 1
a1088 1
		if (i == map->dm_nsegs-1)
a1090 7
		if ((*idxp) == ndesc) {
			idx = 0;
			(*idxp) = 1;
			desc[ndesc].l = HIFN_D_VALID | HIFN_D_JUMP |
			    HIFN_D_MASKDONEIRQ | HIFN_D_LAST;
		} else
			idx = (*idxp)++;
d1094 6
d1101 2
a1102 1
	(*usedp) += map->dm_nsegs;
d1141 1
a1141 1
			struct mbuf *m, *top, **mp;
d1146 1
a1146 1
				MGETHDR(m, M_DONTWAIT, MT_DATA);
d1149 1
a1149 1
				MGET(m, M_DONTWAIT, MT_DATA);
d1151 1
a1151 1
			if (m == NULL)
d1154 1
a1154 1
				M_DUP_PKTHDR(m, cmd->srcu.src_m);
d1156 2
a1157 2
				MCLGET(m, M_DONTWAIT);
				if (m->m_flags & M_EXT)
d1160 3
a1162 3
			m->m_len = len;
			top = NULL;
			mp = &top;
d1165 4
a1168 7
				if (top) {
					MGET(m, M_DONTWAIT, MT_DATA);
					if (m == NULL) {
						m_freem(top);
						goto err_srcmap;
					}
					len = MLEN;
d1170 2
a1171 1
				if (top && totlen >= MINCLSIZE) {
d1176 1
d1178 1
d1180 3
a1182 2
				*mp = m;
				mp = &m->m_next;
d1184 1
a1184 1
			cmd->dstu.dst_m = top;
d1236 2
a1237 2
		dma->cmdr[HIFN_D_CMD_RSIZE].l = HIFN_D_VALID | HIFN_D_LAST |
		    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP;
a1239 8

	if (dma->resi == HIFN_D_RES_RSIZE) {
		dma->resi = 0;
		dma->resr[HIFN_D_RES_RSIZE].l = HIFN_D_VALID | HIFN_D_LAST |
		    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP;
	}
	resi = dma->resi++;

d1266 2
a1267 2

	hifn_dmamap_load(cmd->src_map, &dma->srci, dma->srcr,
d1274 1
a1274 1
	hifn_dmamap_load(cmd->dst_map, &dma->dsti, dma->dstr,
d1288 6
d1394 6
a1399 5
	if ((dmacsr & sc->sc_dmaier) == 0)
		return (0);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD); 
d1405 17
d1423 2
a1424 6
		/* clear aborts... */
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, restart);
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_C_CTRL_ENA |
		    HIFN_DMACSR_S_CTRL_ENA | HIFN_DMACSR_D_CTRL_ENA |
		    HIFN_DMACSR_R_CTRL_ENA);
	}
d1440 4
a1443 1
	while (dma->resu > 0) {
d1447 1
a1447 5
		cmd = dma->hifn_commands[dma->resk];

		/* if still valid, stop processing */
		if (dma->resr[dma->resk].l & HIFN_D_VALID)
			break;
d1450 1
a1450 1
			macbuf = dma->result_bufs[dma->resk];
a1454 4
	
		if (++dma->resk == HIFN_D_RES_RSIZE)
			dma->resk = 0;
		dma->resu--;
d1456 4
d1461 1
a1461 2

	/* clear the rings */
d1778 72
a1867 2
		}
		if ((m = cmd->dstu.dst_m) != NULL) {
d1869 1
a1869 2
			hifnstats.hst_obytes += totlen;
			while (m) {
a1874 4
				m = m->m_next;
				if (++dma->dstk == HIFN_D_DST_RSIZE)
					dma->dstk = 0;
				dma->dstu--;
d1876 2
a1877 5
		} else {
			hifnstats.hst_obytes += dma->dstr[dma->dstk].l & HIFN_D_LENGTH;
			if (++dma->dstk == HIFN_D_DST_RSIZE)
				dma->dstk = 0;
			dma->dstu--;
a1878 4
	} else if (crp->crp_flags & CRYPTO_F_IOV) {
		hifnstats.hst_obytes += cmd->dst_map->dm_mapsize;
		dma->dstk = (dma->dstk + cmd->dst_map->dm_nsegs) % HIFN_D_DST_RSIZE;
		dma->dstu -= cmd->dst_map->dm_nsegs;
d1880 4
@


1.91
log
@move hifn_stats definition to header
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.90 2001/08/08 03:46:44 jason Exp $	*/
d49 2
a51 4
#include <vm/vm_extern.h>
#include <vm/pmap.h>
#include <machine/pmap.h>
#include <sys/device.h>
@


1.90
log
@leave the dma engines polling for a bit after the last descriptor has been
passed through.  After a few seconds (5 currently) of no activity, stop them
completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.89 2001/08/08 03:11:46 jason Exp $	*/
d107 1
a107 9
struct hifn_stats {
	u_int64_t hst_ibytes;
	u_int64_t hst_obytes;
	u_int32_t hst_ipackets;
	u_int32_t hst_opackets;
	u_int32_t hst_invalid;
	u_int32_t hst_nomem;
	u_int32_t hst_abort;
} hifnstats;
@


1.89
log
@Initial support for RC4 operations (This probably won't work yet as
the caller of *_process() doesn't seem to initialize crd_klen correctly;
it has a zero value... still debugging...).
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.88 2001/07/21 03:08:57 jason Exp $	*/
d105 1
d315 3
d1306 1
d1323 37
a1460 17

	if (dma->cmdu == 0) {
		rings |= HIFN_DMACSR_C_CTRL_DIS;
		sc->sc_c_busy = 0;
	}
	if (dma->srcu == 0) {
		rings |= HIFN_DMACSR_S_CTRL_DIS;
		sc->sc_s_busy = 0;
	}
	if (dma->dstu == 0) {
		rings |= HIFN_DMACSR_D_CTRL_DIS;
		sc->sc_d_busy = 0;
	}
	if (dma->resu == 0) {
		rings |= HIFN_DMACSR_R_CTRL_DIS;
		sc->sc_r_busy = 0;
	}
@


1.88
log
@- Clear all interrupts during initialization (shouldn't be necessary, but
doesn't hurt).
- Turn the dma queues on and off as needed.  This results in fewer PCI
aborts on 7751.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.87 2001/07/20 14:21:58 jason Exp $	*/
d1017 23
a1039 4
		len = (cry_cmd->masks & HIFN_CRYPT_CMD_ALG_3DES) ?
		    HIFN_3DES_KEY_LENGTH : HIFN_DES_KEY_LENGTH;
		bcopy(cmd->ck, buf_pos, len);
		buf_pos += len;
d1483 3
a1485 2
		if (c->cri_alg == CRYPTO_MD5_HMAC ||
		    c->cri_alg == CRYPTO_SHA1_HMAC) {
d1489 7
a1495 2
		} else if (c->cri_alg == CRYPTO_DES_CBC ||
		    c->cri_alg == CRYPTO_3DES_CBC) {
d1499 2
a1500 1
		} else
d1502 1
a1502 1

a1508 1
	get_random_bytes(sc->sc_sessions[i].hs_iv, HIFN_IV_LENGTH);
d1598 2
a1599 1
			 crd1->crd_alg == CRYPTO_3DES_CBC) {
d1610 1
a1610 1
		    crd1->crd_alg == CRYPTO_SHA1_HMAC) &&
d1612 2
a1613 1
			crd2->crd_alg == CRYPTO_3DES_CBC) &&
d1619 1
d1622 1
a1622 1
			crd2->crd_alg == CRYPTO_SHA1_HMAC) &&
d1638 18
a1655 2
		cmd->cry_masks |= HIFN_CRYPT_CMD_MODE_CBC |
		    HIFN_CRYPT_CMD_NEW_IV;
a1683 5
		if (enccrd->crd_alg == CRYPTO_DES_CBC)
			cmd->cry_masks |= HIFN_CRYPT_CMD_ALG_DES;
		else
			cmd->cry_masks |= HIFN_CRYPT_CMD_ALG_3DES;

d1685 1
@


1.87
log
@Since the aborts seem recoverable (thus far), don't printf() about them,
just maintain a counter.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.86 2001/07/18 15:49:29 jason Exp $	*/
d156 4
a229 4
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_HIFN &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7951)
		sc->sc_flags = HIFN_HAS_RNG | HIFN_HAS_PUBLIC;

d638 14
a651 3
	WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_D_CTRL_ENA |
	    HIFN_DMACSR_R_CTRL_ENA | HIFN_DMACSR_S_CTRL_ENA |
	    HIFN_DMACSR_C_CTRL_ENA);
d816 1
d823 4
d854 1
d856 8
a863 2
	}
	return (0);
d875 1
d882 4
d912 4
a915 1
		return (-1);
d917 6
a922 2
	bcopy(&dma->test_dst, data, sizeof(dma->test_dst));
	return (0);
d1227 4
d1247 4
d1254 4
d1269 4
d1305 1
a1305 1
	u_int32_t dmacsr, restart;
d1401 17
d1423 2
a1424 1
	WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_R_DONE|HIFN_DMACSR_C_WAIT);
d1426 1
a1426 1
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD); 
@


1.86
log
@Enable reception of PCI abort interrupts and attempt to handle them.
7751 seems to generate these alot and restarting the DMA unit seems
to get things going again.  7951, however, never generates these aborts
in the same machine/slot.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.85 2001/07/16 14:42:16 jason Exp $	*/
d113 1
d1286 2
a1287 2
		printf("%s: pci abort %x... restarting\n", sc->sc_dv.dv_xname,
		    restart);
@


1.85
log
@oops, remove some debugging stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.84 2001/07/16 05:02:10 jason Exp $	*/
d640 2
a641 1
	sc->sc_dmaier |= HIFN_DMAIER_R_DONE;
d1253 2
a1254 2
	u_int32_t dmacsr;
	int i, r = 0, u;
d1267 1
a1267 1
		return (r);
a1270 1
		r = 1;
d1277 1
a1277 3
		return (r);

	r = 1;
d1282 12
d1357 1
a1357 1
	return (r);
@


1.84
log
@- Separate out reset function of proc unit
- Handle ram detection errors more gracefully
- If things go awry after enabling DMA, turn off polling
- Follow hifn's specs for readram and writeram commands more closely
- Add bus_dmamap_sync()'s during ram probing as well
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.83 2001/07/08 18:05:41 brad Exp $	*/
a830 7

	if (dma->cmdr[slot].l & HIFN_D_VALID)
		printf("cmd[%d] valid still set.\n", slot);
	if (dma->srcr[slot].l & HIFN_D_VALID)
		printf("source[%d] valid still set.\n", slot);
	if (dma->dstr[slot].l & HIFN_D_VALID)
		printf("dest[%d] valid still set.\n", slot);
@


1.83
log
@Hifn has changed its company name, make the name consistent throughout
the tree. Hi/fn, Hi/Fn and HiFn -> Hifn.
--
Ok'd by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.82 2001/06/25 19:49:14 jason Exp $	*/
d82 1
d88 1
a88 1
void	hifn_ramtype __P((struct hifn_softc *));
d223 1
d232 2
a233 1
	hifn_ramtype(sc);
d323 5
d395 21
d436 5
a440 10
	/* Reset the board.  We do this by writing zeros to the DMA reset
	 * field, the BRD reset field, and the manditory 1 at position 2.
	 * Every other field is set to zero.
	 */
	WRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MODE);

	/*
	 * Wait another millisecond for the board to reset.
	 */
	DELAY(1000);
d442 1
a442 3
	/*
	 * Turn off the reset!  (No joke.)
	 */
d686 1
a686 1
void
d699 4
a702 4
	if (hifn_writeramaddr(sc, 0, data, 0) < 0)
		return;
	if (hifn_readramaddr(sc, 0, data, 1) < 0)
		return;
d705 1
a705 1
		return;
a707 4
	hifn_reset_board(sc);
	hifn_init_dma(sc);
	hifn_init_pci_registers(sc);

d710 5
a714 5
	if (hifn_writeramaddr(sc, 0, data, 0) < 0)
		return;
	if (hifn_readramaddr(sc, 0, data, 1) < 0)
		return;
	if (bcmp(data, dataexpect, sizeof(data)) != 0)
d716 4
d810 1
d821 5
a825 2
	dma->dstr[slot].l = 8 | masks;
	dma->resr[slot].l = HIFN_MAX_RESULT | masks;
d828 11
d840 3
a842 2
		printf("%s: SRAM/DRAM detection error -- "
		    "result[%d] valid still set\n", sc->sc_dv.dv_xname, slot);
d863 1
d868 1
d871 2
a872 1
	dma->cmdr[slot].l = 16 | masks;
d877 8
a884 1
	DELAY(1000);	/* let read command execute */
d886 3
a888 2
		printf("%s: SRAM/DRAM detection error -- "
		    "result[%d] valid still set\n", sc->sc_dv.dv_xname, slot);
@


1.82
log
@Have to enable PIER as well as DMAIER in order to get interrupts from the
bignum engine.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.81 2001/06/24 19:31:49 jason Exp $	*/
d4 1
a4 1
 * Invertex AEON / Hi/fn 7751 driver
d39 1
a39 1
 * Driver for the Hi/Fn 7751 encryption processor.
@


1.81
log
@Remove some redundent copies of the total length/skip values and use the
descriptors passed in instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.80 2001/06/24 17:43:28 jason Exp $	*/
d361 1
a361 3
		WRITE_REG_1(sc, HIFN_1_PUB_STATUS,
		    READ_REG_1(sc, HIFN_1_PUB_STATUS) | HIFN_PUBSTS_DONE);

@


1.80
log
@reflect reality more closely and remove more invertex stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.79 2001/06/24 16:30:59 jason Exp $	*/
d912 1
a912 1
		dlen = cmd->mac_process_len;
d917 1
a917 1
		mac_cmd->header_skip = cmd->mac_header_skip;
d924 1
a924 1
		dlen = cmd->crypt_process_len;
d929 1
a929 1
		cry_cmd->header_skip = cmd->crypt_header_skip;
d1488 1
a1524 2
		cmd->crypt_header_skip = enccrd->crd_skip;
		cmd->crypt_process_len = enccrd->crd_len;
d1532 1
a1548 3

		cmd->mac_header_skip = maccrd->crd_skip;
		cmd->mac_process_len = maccrd->crd_len;
@


1.79
log
@- oops, masking off wrong bits in destination total length field
- make sure reserved fields are zero'd
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.78 2001/06/23 23:01:08 angelos Exp $	*/
d96 1
a96 1
int	hifn_crypto __P((struct hifn_softc *, hifn_command_t *, struct cryptop *));
d1015 1
a1015 1
		    cmd->src_m, BUS_DMA_NOWAIT))
d1019 1
a1019 1
		    cmd->src_io, BUS_DMA_NOWAIT))
d1026 1
a1026 1
			cmd->dst_io = cmd->src_io;
d1028 1
a1028 1
			cmd->dst_m = cmd->src_m;
d1038 1
a1038 1
			if (cmd->src_m->m_flags & M_PKTHDR) {
d1048 1
a1048 1
				M_DUP_PKTHDR(m, cmd->src_m);
d1077 1
a1077 1
			cmd->dst_m = top;
d1088 1
a1088 1
			    cmd->dst_m, BUS_DMA_NOWAIT))
d1092 1
a1092 1
			    cmd->dst_io, BUS_DMA_NOWAIT))
d1430 2
a1431 2
		cmd->src_m = (struct mbuf *)crp->crp_buf;
		cmd->dst_m = (struct mbuf *)crp->crp_buf;
d1433 2
a1434 2
		cmd->src_io = (struct uio *)crp->crp_buf;
		cmd->dst_io = (struct uio *)crp->crp_buf;
d1500 1
a1500 1
					m_copyback(cmd->src_m,
d1504 1
a1504 1
					cuio_copyback(cmd->src_io,
d1512 1
a1512 1
				m_copydata(cmd->src_m, enccrd->crd_inject,
d1515 1
a1515 1
				cuio_copydata(cmd->src_io, enccrd->crd_inject,
d1557 1
a1557 1
	cmd->private_data = (u_long)crp;
d1585 1
a1585 1
	struct cryptop *crp = (struct cryptop *)cmd->private_data;
d1594 3
a1596 3
		if (cmd->src_m != cmd->dst_m) {
			m_freem(cmd->src_m);
			crp->crp_buf = (caddr_t)cmd->dst_m;
d1598 1
a1598 1
		if ((m = cmd->dst_m) != NULL) {
@


1.78
log
@copydata, not copyback
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.77 2001/06/23 22:02:53 angelos Exp $	*/
d903 1
a903 1
	base_cmd->total_dest_count = dlen & HIFN_BASE_CMD_LENMASK_HI;
d918 1
d930 1
@


1.77
log
@Correctly handle the IV_PRESENT flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.76 2001/06/23 21:43:40 jason Exp $	*/
d1513 1
a1513 1
				cuio_copyback(cmd->src_io, enccrd->crd_inject,
@


1.76
log
@be sure to clear (by writing 1) the public done by in the status register
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.75 2001/06/23 20:59:41 angelos Exp $	*/
d1435 1
a1435 1
		goto errout;	/* XXX only handle mbufs right now */
d1498 6
a1503 1
					m_copyback(cmd->src_m, enccrd->crd_inject,
a1504 6
				else if (crp->crp_flags & CRYPTO_F_IOV) {
					if (crp->crp_iv == NULL)
						bzero(cmd->iv, 8);
					else
						bcopy(crp->crp_iv, cmd->iv, 8);
				}
d1512 3
a1514 6
			else if (crp->crp_flags & CRYPTO_F_IOV) {
				if (crp->crp_iv == NULL)
					bzero(cmd->iv, 8);
				else
					bcopy(crp->crp_iv, cmd->iv, 8);
			}
@


1.75
log
@Conform to new prototype for crypto_register()
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.74 2001/06/23 20:20:32 jason Exp $	*/
d1230 2
@


1.74
log
@add some infrastructure for the public engine
require reworking interrupt enable and status checking as well as
a bit of initialization
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.73 2001/06/23 18:30:37 deraadt Exp $	*/
d292 1
a292 1
		crypto_register(sc->sc_cid, CRYPTO_3DES_CBC,
d296 1
a296 1
		crypto_register(sc->sc_cid, CRYPTO_MD5_HMAC,
d298 1
a298 1
		crypto_register(sc->sc_cid, CRYPTO_SHA1_HMAC,
d300 1
a300 1
		crypto_register(sc->sc_cid, CRYPTO_DES_CBC,
@


1.73
log
@merge crypto/crypto{dev,}.h to crypto/cryptodev.h, to avoid name conflicts inside OpenSSL codebase
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.72 2001/06/23 00:25:37 jason Exp $	*/
d359 9
d620 2
a621 2
	WRITE_REG_1(sc, HIFN_1_DMA_IER, HIFN_DMAIER_R_DONE);
	sc->sc_dmaier = HIFN_DMAIER_R_DONE;
d1155 2
a1156 3
		WRITE_REG_1(sc, HIFN_1_DMA_IER,
		    HIFN_DMAIER_C_WAIT | HIFN_DMAIER_R_DONE);
		sc->sc_dmaier = HIFN_DMAIER_C_WAIT | HIFN_DMAIER_R_DONE;
d1211 1
a1211 1
	int i, u;
d1224 12
a1235 1
		return (0);
d1250 2
a1251 2
		WRITE_REG_1(sc, HIFN_1_DMA_IER, HIFN_DMAIER_R_DONE);
		sc->sc_dmaier = HIFN_DMAIER_R_DONE;
d1303 1
a1303 1
	return (1);
@


1.72
log
@- put hw defines in *reg, software defines in *var, etc
- clean up pub/rng initialization call
- attempt to remove more intertex vestiges
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.71 2001/06/22 23:53:52 jason Exp $	*/
d55 1
a55 1
#include <crypto/crypto.h>
@


1.71
log
@Fix lotsa bugs:
- Hi/Fn length fields in command structures are 18 bits (feature!), but
descriptor lengths are 16 bits.
- define dmamap maximum lengths correctly (2^18 for total length, 2^16
for segments).
- Make the defines more consistent, and add other modes
- split source_count in command descriptors into a 16 bit length, and 16bit reserved part
upshot: blocks as large as 2^18 - 8 work now for userland crypto
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.70 2001/06/22 19:02:44 jason Exp $	*/
d7 1
a7 1
 * Copyright (c) 2000 Network Security Technologies, Inc.
d62 1
a63 1
#include <dev/pci/hifn7751reg.h>
d307 2
a308 4
	if (sc->sc_flags & (HIFN_HAS_PUBLIC | HIFN_HAS_RNG)) {
		if (hifn_init_pubrng(sc) == 0) {
		}
	}
@


1.70
log
@Add support for RNG on 7951; many thanks to Soren Kristensen
<soren@@soekris.com> for donating the cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.69 2001/06/14 23:55:02 deraadt Exp $	*/
d886 1
d894 7
a900 3
	base_cmd->total_source_count = cmd->src_map->dm_mapsize;
	base_cmd->total_dest_count = cmd->dst_map->dm_mapsize;
	base_cmd->session_num = cmd->session_num;
d905 5
a909 1
		mac_cmd->masks = cmd->mac_masks;
a910 1
		mac_cmd->source_count = cmd->mac_process_len;
d916 5
a920 1
		cry_cmd->masks = cmd->cry_masks;
a921 1
		cry_cmd->source_count = cmd->crypt_process_len;
d1000 2
a1001 2
	if (bus_dmamap_create(sc->sc_dmat, HIFN_MAX_SEGLEN * MAX_SCATTER,
	    MAX_SCATTER, HIFN_MAX_SEGLEN, 0, BUS_DMA_NOWAIT, &cmd->src_map))
@


1.69
log
@hackish auto-IV mode for IOV operations
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.66 2001/06/12 15:40:31 niklas Exp $	*/
d102 2
d307 5
d326 53
@


1.68
log
@dst ring corruption fix; jason
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.67 2001/06/14 23:51:18 deraadt Exp $	*/
d1411 4
a1414 5
					if (crp->crp_iv == NULL) {
						err = EINVAL;
						goto errout;
					}
					bcopy(crp->crp_iv, cmd->iv, 8);
d1424 4
a1427 5
				if (crp->crp_iv == NULL) {
					err = EINVAL;
					goto errout;
				}
				bcopy(crp->crp_iv, cmd->iv, 8);
@


1.67
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.66 2001/06/12 15:40:31 niklas Exp $	*/
d1532 4
@


1.66
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.65 2001/05/14 22:29:28 jason Exp $	*/
d191 1
a191 1
        }
d1262 1
a1262 2
		}
		else
d1264 1
@


1.65
log
@use bus_dmamap_sync() as appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.64 2001/05/14 03:07:06 jason Exp $	*/
d168 1
a168 1
	    &sc->sc_st0, &sc->sc_sh0, NULL, &iosize0)) {
d174 1
a174 1
	    &sc->sc_st1, &sc->sc_sh1, NULL, &iosize1)) {
@


1.64
log
@- simplify hifn_dmamap_aligned()
- simplify hifn_crypto() and remove duplicate work of determining alignment
- add ability to share a map for src and dst instead of creating a new one
if all of the alignment constraints are met.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.63 2001/05/14 02:45:19 deraadt Exp $	*/
d302 3
d1025 3
d1030 3
d1041 2
d1108 3
d1149 3
d1213 2
d1503 3
@


1.63
log
@use real uio
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.62 2001/05/13 23:39:53 jason Exp $	*/
d879 1
a879 1
	int i, nicealign = 1;
d883 2
a884 4
		    (map->dm_segs[i].ds_len & 3)) {
			nicealign = 0;
			break;
		}
d886 1
a886 1
	return (nicealign);
d922 1
d924 1
a924 3
	struct	hifn_dma *dma = sc->sc_dma;
	int	cmdi, resi, nicealign = 1;
	int     s, i;
d941 8
a948 24
	for (i = 0; i < cmd->src_map->dm_nsegs; i++) {
		if ((cmd->src_map->dm_segs[i].ds_addr & 3) ||
		    (cmd->src_map->dm_segs[i].ds_len & 3)) {
			nicealign = 0;
			break;
		}
	}

	nicealign = hifn_dmamap_aligned(cmd->src_map);
	if (!nicealign && (crp->crp_flags & CRYPTO_F_IOV))
		goto err_srcmap;
	else if (!nicealign && (crp->crp_flags & CRYPTO_F_IMBUF)) {
		int totlen, len;
		struct mbuf *m, *top, **mp;

		totlen = cmd->src_map->dm_mapsize;
		if (cmd->src_m->m_flags & M_PKTHDR) {
			len = MHLEN;
			MGETHDR(m, M_DONTWAIT, MT_DATA);
		} else {
			len = MLEN;
			MGET(m, M_DONTWAIT, MT_DATA);
		}
		if (m == NULL)
d950 3
a952 10
		if (len == MHLEN)
			M_DUP_PKTHDR(m, cmd->src_m);
		if (totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
		}
		m->m_len = len;
		top = NULL;
		mp = &top;
d954 6
a959 2
		while (totlen > 0) {
			if (top) {
a960 5
				if (m == NULL) {
					m_freem(top);
					goto err_srcmap;
				}
				len = MLEN;
d962 5
a966 1
			if (top && totlen >= MINCLSIZE) {
d972 23
a994 3
			totlen -= len;
			*mp = m;
			mp = &m->m_next;
d996 1
a996 3
		cmd->dst_m = top;
	} else
		cmd->dst_m = cmd->src_m;
d998 14
a1011 12
	if (bus_dmamap_create(sc->sc_dmat, HIFN_MAX_SEGLEN * MAX_SCATTER,
	    MAX_SCATTER, HIFN_MAX_SEGLEN, 0, BUS_DMA_NOWAIT, &cmd->dst_map))
		goto err_srcmap;

	if (crp->crp_flags & CRYPTO_F_IMBUF) {
		if (bus_dmamap_load_mbuf(sc->sc_dmat, cmd->dst_map,
		    cmd->dst_m, BUS_DMA_NOWAIT))
			goto err_dstmap1;
	} else if (crp->crp_flags & CRYPTO_F_IOV) {
		if (bus_dmamap_load_uio(sc->sc_dmat, cmd->dst_map,
		    cmd->dst_io, BUS_DMA_NOWAIT))
			goto err_dstmap1;
d1052 2
a1053 1
	printf("write_command %d (nice %d)\n", cmdlen, nicealign);
d1101 2
a1102 1
	bus_dmamap_unload(sc->sc_dmat, cmd->dst_map);
d1104 2
a1105 1
	bus_dmamap_destroy(sc->sc_dmat, cmd->dst_map);
d1547 4
a1552 2
	bus_dmamap_unload(sc->sc_dmat, cmd->dst_map);
	bus_dmamap_destroy(sc->sc_dmat, cmd->dst_map);
@


1.62
log
@First try at bus_dma(9)-ifying hifn7751 driver... advantages:
- vtophys is dead
- now builds on alpha
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.61 2001/05/13 15:53:22 jason Exp $	*/
a937 11
		struct uio u;

		u.uio_iov = cmd->src_io->iov;
		u.uio_iovcnt = cmd->src_io->niov;
		u.uio_offset = u.uio_resid = 0;
		u.uio_segflg = UIO_SYSSPACE;	/* XXX */
		u.uio_procp = NULL;		/* XXX */
		u.uio_rw = UIO_READ;
		for (i = 0; i < cmd->src_io->niov; i++)
			u.uio_resid += cmd->src_io->iov[0].iov_len;

d939 1
a939 1
		    &u, BUS_DMA_NOWAIT))
a1011 11
		struct uio u;

		u.uio_iov = cmd->dst_io->iov;
		u.uio_iovcnt = cmd->dst_io->niov;
		u.uio_offset = u.uio_resid = 0;
		u.uio_segflg = UIO_SYSSPACE;	/* XXX */
		u.uio_procp = NULL;		/* XXX */
		u.uio_rw = UIO_READ;
		for (i = 0; i < cmd->dst_io->niov; i++)
			u.uio_resid += cmd->dst_io->iov[0].iov_len;

d1013 1
a1013 1
		    &u, BUS_DMA_NOWAIT))
d1322 2
a1323 2
		cmd->src_io = (struct criov *)crp->crp_buf;
		cmd->dst_io = (struct criov *)crp->crp_buf;
d1524 1
a1524 1
				criov_copydata((struct criov *)crp->crp_buf,
@


1.61
log
@missing else
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.60 2001/05/13 15:39:27 deraadt Exp $	*/
d99 3
a148 2
	bus_dma_segment_t seg;
	bus_dmamap_t dmamap;
d180 5
d186 2
a187 1
	    &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
d189 1
d192 2
a193 1
	if (bus_dmamem_map(sc->sc_dmat, &seg, rseg, sizeof(*sc->sc_dma), &kva,
d197 3
a199 8
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
		goto fail_io1;
	}
	if (bus_dmamap_create(sc->sc_dmat, sizeof(*sc->sc_dma), 1,
	    sizeof(*sc->sc_dma), 0, BUS_DMA_NOWAIT, &dmamap)) {
		printf(": can't create dma map\n");
		bus_dmamem_unmap(sc->sc_dmat, kva, sizeof(*sc->sc_dma));
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
d202 2
a203 2
	if (bus_dmamap_load(sc->sc_dmat, dmamap, kva, sizeof(*sc->sc_dma),
	    NULL, BUS_DMA_NOWAIT)) {
a204 1
		bus_dmamap_destroy(sc->sc_dmat, dmamap);
d206 3
a208 1
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
d307 1
a307 2
	bus_dmamap_unload(sc->sc_dmat, dmamap);
	bus_dmamap_destroy(sc->sc_dmat, dmamap);
d309 3
a311 1
	bus_dmamem_free(sc->sc_dmat, &seg, rseg);
d537 8
a544 4
	WRITE_REG_1(sc, HIFN_1_DMA_CRAR, vtophys(sc->sc_dma->cmdr));
	WRITE_REG_1(sc, HIFN_1_DMA_SRAR, vtophys(sc->sc_dma->srcr));
	WRITE_REG_1(sc, HIFN_1_DMA_DRAR, vtophys(sc->sc_dma->dstr));
	WRITE_REG_1(sc, HIFN_1_DMA_RRAR, vtophys(sc->sc_dma->resr));
a712 1
	u_int64_t src, dst;
d720 2
a721 2
	*(hifn_base_command_t *) sc->sc_dma->command_bufs[slot] = wc;
	bcopy(data, &src, sizeof(src));
d723 4
a726 2
	dma->srcr[slot].p = vtophys(&src);
	dma->dstr[slot].p = vtophys(&dst);
a750 1
	u_int64_t src, dst;
d757 1
a757 1
	*(hifn_base_command_t *) sc->sc_dma->command_bufs[slot] = rc;
d759 4
a762 2
	dma->srcr[slot].p = vtophys(&src);
	dma->dstr[slot].p = vtophys(&dst);
d774 1
a774 1
	bcopy(&dst, data, sizeof(dst));
d790 2
a791 1
		dma->cmdr[i].p = vtophys(dma->command_bufs[i]);
d793 2
a794 1
		dma->resr[i].p = vtophys(dma->result_bufs[i]);
d796 8
a803 4
	dma->cmdr[HIFN_D_CMD_RSIZE].p = vtophys(dma->cmdr);
	dma->srcr[HIFN_D_SRC_RSIZE].p = vtophys(dma->srcr);
	dma->dstr[HIFN_D_DST_RSIZE].p = vtophys(dma->dstr);
	dma->resr[HIFN_D_RES_RSIZE].p = vtophys(dma->resr);
d830 2
a831 2
	base_cmd->total_source_count = cmd->src_l;
	base_cmd->total_dest_count = cmd->dst_l;
d876 42
d926 1
a926 1
	int	cmdi, srci, dsti, resi, nicealign = 0;
d929 32
a960 9
	if (cmd->src_npa == 0 && cmd->src_m) {
		if (crp->crp_flags & CRYPTO_F_IMBUF)
			cmd->src_l = mbuf2pages(cmd->src_m, &cmd->src_npa,
			    cmd->src_packp, cmd->src_packl, MAX_SCATTER,
			    &nicealign);
		else if (crp->crp_flags & CRYPTO_F_IOV)
			cmd->src_l = iov2pages(cmd->src_io, &cmd->src_npa,
			    cmd->src_packp, cmd->src_packl, MAX_SCATTER,
			    &nicealign);
a961 2
	if (cmd->src_l == 0)
		return (-1);
d963 4
a966 3
	if (!nicealign && (crp->crp_flags & CRYPTO_F_IOV)) {
		return (-1);
	} else if (!nicealign && (crp->crp_flags & CRYPTO_F_IMBUF)) {
d970 1
a970 1
		totlen = cmd->dst_l = cmd->src_l;
d979 1
a979 1
			return (-1);
d996 1
a996 1
					return (-1);
d1014 24
a1037 8
	if (crp->crp_flags & CRYPTO_F_IMBUF)
		cmd->dst_l = mbuf2pages(cmd->dst_m, &cmd->dst_npa,
		    cmd->dst_packp, cmd->dst_packl, MAX_SCATTER, NULL);
	else if (crp->crp_flags & CRYPTO_F_IOV)
		cmd->dst_l = iov2pages(cmd->dst_io, &cmd->dst_npa,
		    cmd->dst_packp, cmd->dst_packl, MAX_SCATTER, NULL);
	if (cmd->dst_l == 0)
		return (-1);
d1043 2
a1044 2
	    dma->cmdu, dma->srcu, dma->dstu, dma->resu, cmd->src_npa,
	    cmd->dst_npa);
d1054 2
a1055 2
	    dma->srcu+cmd->src_npa > HIFN_D_SRC_RSIZE ||
	    dma->dstu+cmd->dst_npa > HIFN_D_DST_RSIZE ||
d1058 1
a1058 1
		return (HIFN_CRYPTO_RINGS_FULL);
d1096 1
d1098 2
a1099 21
	for (i = 0; i < cmd->src_npa; i++) {
		int last = 0;

		if (i == cmd->src_npa-1)
			last = HIFN_D_LAST;

		if (dma->srci == HIFN_D_SRC_RSIZE) {
			srci = 0, dma->srci = 1;
			dma->srcr[HIFN_D_SRC_RSIZE].l = HIFN_D_VALID |
			    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP | HIFN_D_LAST;
		} else
			srci = dma->srci++;
		dma->srcr[srci].p = cmd->src_packp[i];
		dma->srcr[srci].l = cmd->src_packl[i] | HIFN_D_VALID |
		    HIFN_D_MASKDONEIRQ | last;
		hifnstats.hst_ibytes += cmd->src_packl[i];
	}
	dma->srcu += cmd->src_npa;

	for (i = 0; i < cmd->dst_npa; i++) {
		int last = 0;
d1101 2
a1102 14
		if (i == cmd->dst_npa-1)
			last = HIFN_D_LAST;

		if (dma->dsti == HIFN_D_DST_RSIZE) {
			dsti = 0, dma->dsti = 1;
			dma->dstr[HIFN_D_DST_RSIZE].l = HIFN_D_VALID |
			    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP | HIFN_D_LAST;
		} else
			dsti = dma->dsti++;
		dma->dstr[dsti].p = cmd->dst_packp[i];
		dma->dstr[dsti].l = cmd->dst_packl[i] | HIFN_D_VALID |
		    HIFN_D_MASKDONEIRQ | last;
	}
	dma->dstu += cmd->dst_npa;
d1123 10
a1506 5
	if ((crp->crp_flags & CRYPTO_F_IMBUF) && (cmd->src_m != cmd->dst_m)) {
		m_freem(cmd->src_m);
		crp->crp_buf = (caddr_t)cmd->dst_m;
	}

d1508 4
d1513 1
a1513 1
			totlen = cmd->src_l;
d1569 4
@


1.60
log
@initial cut at /dev/crypto support.  takes original mbuf "try, and discard
if we fail" semantics and extends to two varients of data movement: mbuf,
or an iovec style block.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.57 2001/04/06 16:27:46 jason Exp $	*/
d1265 1
a1265 1
	} if (crp->crp_flags & CRYPTO_F_IOV) {
@


1.59
log
@I think this will match and work on a hifn 7951
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.58 2001/05/08 20:41:00 deraadt Exp $	*/
d96 1
a96 1
int	hifn_crypto __P((struct hifn_softc *, hifn_command_t *));
d859 1
a859 1
hifn_crypto(sc, cmd)
d862 1
d869 10
a878 3
	if (cmd->src_npa == 0 && cmd->src_m)
		cmd->src_l = mbuf2pages(cmd->src_m, &cmd->src_npa,
		    cmd->src_packp, cmd->src_packl, MAX_SCATTER, &nicealign);
d882 3
a884 1
	if (nicealign == 0) {
d929 1
a929 2
	}
	else
d932 6
a937 2
	cmd->dst_l = mbuf2pages(cmd->dst_m, &cmd->dst_npa,
	    cmd->dst_packp, cmd->dst_packl, MAX_SCATTER, NULL);
d1265 3
d1331 12
a1342 3
			if ((enccrd->crd_flags & CRD_F_IV_PRESENT) == 0)
				m_copyback(cmd->src_m, enccrd->crd_inject,
				    HIFN_IV_LENGTH, cmd->iv);
d1346 1
a1346 1
			else
d1349 7
d1400 1
a1400 1
	if (hifn_crypto(sc, cmd) == 0)
d1434 17
a1450 10
	if ((m = cmd->dst_m) != NULL) {
		totlen = cmd->src_l;
		hifnstats.hst_obytes += totlen;
		while (m) {
			if (totlen < m->m_len) {
				m->m_len = totlen;
				totlen = 0;
			} else
				totlen -= m->m_len;
			m = m->m_next;
a1454 5
	} else {
		hifnstats.hst_obytes += dma->dstr[dma->dstk].l & HIFN_D_LENGTH;
		if (++dma->dstk == HIFN_D_DST_RSIZE)
			dma->dstk = 0;
		dma->dstu--;
d1463 11
a1473 4
			m_copydata((struct mbuf *)crp->crp_buf,
			    crd->crd_skip + crd->crd_len - HIFN_IV_LENGTH,
			    HIFN_IV_LENGTH,
			    cmd->softc->sc_sessions[cmd->session_num].hs_iv);
d1483 5
a1487 2
			m_copyback((struct mbuf *)crp->crp_buf,
			    crd->crd_inject, 12, macbuf);
@


1.58
log
@simplify prints
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.57 2001/04/06 16:27:46 jason Exp $	*/
d123 3
d216 4
d386 5
d460 1
a460 3
		WRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg);
		WRITE_REG_1(sc, HIFN_1_DMA_CNFG, dmacfg);
		return 0;	/* success */
d495 1
@


1.57
log
@typo in error message
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.56 2001/03/28 20:02:59 angelos Exp $	*/
d424 1
a424 1
		printf("%s: Unknown card!\n", sc->sc_dv.dv_xname);
d446 1
a446 2
		printf("%s: Strong Crypto already enabled!\n",
		    sc->sc_dv.dv_xname);
d455 1
a455 1
		printf("%s: Unknown encryption level\n", sc->sc_dv.dv_xname);
d480 1
a480 1
		printf("Encryption engine is permanently locked until next system reset.");
d482 1
a482 1
		printf("Encryption engine enabled successfully!");
@


1.57.2.1
log
@Errata #18:
Hifn 7751 based cards may stop working on certain motherboards due to
DMA errors.
Fix (jason):
7751 has two registers in config space (0x40 - RETRY_TIMEOUT and 0x41,
TRDY_TIMEOUT).  These registers must be initialized to zero to disable
these timers or 7751 will get PCI aborts on its descriptor rings on
certain chipsets.  These timers were removed because they were unneeded
in the 7951.  I'm not sure how I missed this in the datasheet, but there
it is plain as day on page 24.  Thanks go to Hifn for pointing this out.

Upshot: PCI abort problem on 7751 appears to be solved.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.57 2001/04/06 16:27:46 jason Exp $	*/
a147 3
	sc->sc_pci_pc = pa->pa_pc;
	sc->sc_pci_tag = pa->pa_tag;

a174 4
	cmd = pci_conf_read(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT);
	cmd &= 0xffff0000;
	pci_conf_write(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT, cmd);

a312 2
	u_int32_t reg;

a346 4

	reg = pci_conf_read(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT);
	reg &= 0xffff0000;
	pci_conf_write(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT, reg);
a763 1
	u_int32_t reg;
a764 4

	reg = pci_conf_read(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT);
	reg &= 0xffff0000;
	pci_conf_write(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT, reg);
@


1.56
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.55 2001/02/18 18:29:27 deraadt Exp $	*/
d250 1
a250 1
		printf(": couldn't establish interrupt\n");
@


1.55
log
@shorten message
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.54 2001/01/31 05:14:02 jason Exp $	*/
d879 1
a879 1
			M_COPY_PKTHDR(m, cmd->src_m);
@


1.54
log
@before copying the packet header, make sure we actually got the mbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.53 2000/11/22 17:51:14 mickey Exp $	*/
d494 1
a494 1
		printf(": DES enabled");
d497 1
a497 1
		printf(": fully enabled");
@


1.53
log
@even bigger delay in ram probe; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.52 2000/11/17 05:18:41 angelos Exp $	*/
d870 1
a871 2
			M_COPY_PKTHDR(m, cmd->src_m);
			len = MHLEN;
d873 1
a874 1
			len = MLEN;
d878 2
@


1.52
log
@*HMAC96->*HMAC

Bear in mind, you will need to recompile both isakmpd/ipsecadm and
your kernel --- otherwise things won't work together.

Naturally, all these changes will not be folded into -STABLE, since
they would break binary compatibility.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.51 2000/10/26 00:41:25 jason Exp $	*/
d712 1
a712 1
	DELAY(1000);	/* let write command execute */
@


1.51
log
@shadow the dmaier to avoid an additional pci read in the interrupt path
if mastering isn't enabled, scream
document netsec rev A workaround
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.50 2000/10/24 21:05:10 jason Exp $	*/
d282 1
a282 1
		crypto_register(sc->sc_cid, CRYPTO_MD5_HMAC96,
d284 1
a284 1
		crypto_register(sc->sc_cid, CRYPTO_SHA1_HMAC96,
d1153 2
a1154 2
		if (c->cri_alg == CRYPTO_MD5_HMAC96 ||
		    c->cri_alg == CRYPTO_SHA1_HMAC96) {
d1254 2
a1255 2
		if (crd1->crd_alg == CRYPTO_MD5_HMAC96 ||
		    crd1->crd_alg == CRYPTO_SHA1_HMAC96) {
d1269 2
a1270 2
		if ((crd1->crd_alg == CRYPTO_MD5_HMAC96 ||
		    crd1->crd_alg == CRYPTO_SHA1_HMAC96) &&
d1279 2
a1280 2
		    (crd2->crd_alg == CRYPTO_MD5_HMAC96 ||
			crd2->crd_alg == CRYPTO_SHA1_HMAC96) &&
d1334 1
a1334 1
		if (maccrd->crd_alg == CRYPTO_MD5_HMAC96)
d1428 2
a1429 2
			if (crd->crd_alg != CRYPTO_MD5_HMAC96 &&
			    crd->crd_alg != CRYPTO_SHA1_HMAC96)
@


1.50
log
@Duh, C_WAIT will always be set if the card is inactive, but that interrupt
isn't always enabled.  (CSR & IER) == 0, means not to claim the intr.
deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.49 2000/10/23 21:22:42 deraadt Exp $	*/
d158 5
d223 4
d531 1
a532 5
#if 0
#if BYTE_ORDER == BIG_ENDIAN
	    (0x1 << 7) |
#endif
#endif
d967 1
a967 1
	if (dma->cmdu > 1)
d970 2
d1039 1
a1039 1
	u_int32_t dmacsr, dmaier;
a1042 2
	dmaier = READ_REG_1(sc, HIFN_1_DMA_IER) &
	    (HIFN_DMAIER_R_DONE | HIFN_DMAIER_C_WAIT);
d1052 1
a1052 1
	if ((dmacsr & dmaier) == 0)
d1066 1
@


1.49
log
@unreset takes time too, and you notice this on a p3/933
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.48 2000/10/13 04:34:13 deraadt Exp $	*/
d1032 1
a1032 1
	u_int32_t dmacsr;
d1036 2
d1046 2
a1047 1
	if ((dmacsr & (HIFN_DMACSR_R_DONE | HIFN_DMACSR_C_WAIT)) == 0)
@


1.48
log
@delays that permit more machines to work; itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.47 2000/10/11 13:15:41 itojun Exp $	*/
d333 5
@


1.47
log
@printf format string typo in HIFN_DEBUG section.
size_t on printf (cast to u_long and use %lu)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.46 2000/08/15 14:22:44 jason Exp $	*/
d91 1
a91 1
u_int32_t hifn_next_signature __P((u_int a, u_int cnt));
d337 2
a338 1
	u_int a, cnt;
d340 2
a341 1
	int i, v;
d449 1
d451 1
d453 1
d475 1
a475 1
	switch(encl) {
@


1.46
log
@- deallocate all resources grabbed during hifn_attach() when an error occurs.
- temporary workaround for netsec hifn7751 rev A: half the amount of memory
because two of the address lines were left floating (better memory check
coming soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.45 2000/08/13 21:17:38 deraadt Exp $	*/
d178 2
a179 2
		printf(": can't map dma buffers (%d bytes)\n",
		    sizeof(*sc->sc_dma));
d440 1
a440 1
		printf("%: Unknown encryption level\n",  sc->sc_dv.dv_xname);
@


1.45
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.44 2000/07/28 19:59:11 jason Exp $	*/
d140 1
a140 2
	bus_addr_t iobase;
	bus_size_t iosize;
d158 3
a160 2
	if (pci_mem_find(pc, pa->pa_tag, HIFN_BAR0, &iobase, &iosize, NULL)) {
		printf(": can't find mem space\n");
a162 5
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->sc_sh0)) {
		printf(": can't map mem space\n");
		return;
	}
	sc->sc_st0 = pa->pa_memt;
d164 4
a167 7
	if (pci_mem_find(pc, pa->pa_tag, HIFN_BAR1, &iobase, &iosize, NULL)) {
		printf(": can't find mem space\n");
		return;
	}
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->sc_sh1)) {
		printf(": can't map mem space\n");
		return;
a168 1
	sc->sc_st1 = pa->pa_memt;
d174 1
a174 1
		return;
d181 1
a181 1
		return;
d188 1
a188 1
		return;
d196 1
a196 1
		return;
d205 1
a205 1
		return;
d218 5
d235 1
a235 1
		return;
d245 1
a245 1
		return;
d261 1
a261 1
		return;
d280 14
@


1.44
log
@Use the correct bits for determining which session to delete. Some style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.43 2000/06/20 05:40:44 jason Exp $	*/
d910 2
a911 2
			splx(s);
			return (HIFN_CRYPTO_RINGS_FULL);
@


1.43
log
@call crypto_done()
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.42 2000/06/17 20:34:52 jason Exp $	*/
d1117 1
a1117 1
	for (i = 0; i < sc->sc_maxses; i++) {
a1119 1
	}
d1159 1
a1159 1
	u_int32_t sid = (tid >> 31) & 0xffffffff;
d1170 1
a1170 1
	sc->sc_sessions[session].hs_flags = 0;
d1390 2
a1391 1
			    crd->crd_skip + crd->crd_len - 8, 8,
@


1.42
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.41 2000/06/13 05:04:59 jason Exp $	*/
d1409 1
a1409 1
	crp->crp_callback(crp);
@


1.41
log
@use the source length to calculate the output length instead of relying on
the length in the descriptors (which is sometimes 0!).
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.40 2000/06/13 02:22:50 jason Exp $	*/
d1130 1
a1130 2
		}
		else if (c->cri_alg == CRYPTO_DES_CBC ||
d1213 1
a1213 2
	}
	else {
d1230 1
a1230 2
		}
		else if (crd1->crd_alg == CRYPTO_DES_CBC ||
d1236 1
a1236 2
		}
		else {
d1240 1
a1240 2
	}
	else {
d1249 1
a1249 2
		}
		else if ((crd1->crd_alg == CRYPTO_DES_CBC ||
d1256 1
a1256 2
		}
		else {
d1279 1
a1279 2
		}
		else {
d1370 1
a1370 2
			}
			else
d1377 1
a1377 2
	}
	else {
@


1.40
log
@Be more careful when setting up the mbufs for destination buffers
(similiar to what's in ubsec)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.39 2000/06/02 22:36:44 deraadt Exp $	*/
d1364 1
d1372 2
a1373 2
		int totlen = cmd->src_l, len;

d1375 4
a1378 3
			len = dma->dstr[dma->dstk].l & HIFN_D_LENGTH;
			if (len > totlen)
				len = totlen;
d1380 1
a1380 3
				totlen -= len;
			m->m_len = len;
			hifnstats.hst_obytes += m->m_len;
@


1.39
log
@callback is always static
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.38 2000/05/04 02:23:16 jason Exp $	*/
d844 8
a851 2
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		M_COPY_PKTHDR(m, cmd->src_m);
a853 1
		len = MHLEN;
@


1.38
log
@fixed context memory sizing
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.37 2000/04/25 06:03:46 jason Exp $	*/
d1050 1
a1050 2
		/* position is done, notify producer with callback */
		cmd->dest_ready_callback(sc, cmd, macbuf);
a1327 1
	cmd->dest_ready_callback = hifn_callback;
@


1.38.2.1
log
@Pull in patch from current:
Errata:
panic in m_copydata() from hifn_callback() because the length field
in the hifn descriptors are sometimes broken for large packets.
Fix (jason):
use the source length to calculate the output length instead of relying on
the length in the descriptors (which is sometimes 0!).
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.41 2000/06/13 05:04:59 jason Exp $	*/
a1360 1
	int totlen;
d1368 2
a1369 2
		totlen = cmd->src_l;
		hifnstats.hst_obytes += totlen;
d1371 3
a1373 4
			if (totlen < m->m_len) {
				m->m_len = totlen;
				totlen = 0;
			}
d1375 3
a1377 1
				totlen -= m->m_len;
@


1.38.2.2
log
@Pull in patch from current:
Fix (jason):
Use the correct bits for determining which session to delete. Some style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.38.2.1 2000/06/18 02:52:30 jason Exp $	*/
d1157 1
a1157 1
	u_int32_t sid = ((u_int32_t) tid) & 0xffffffff;
@


1.37
log
@if we have to allocate a new mbuf, don't forget to copy the header info from
the original packet.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.36 2000/04/25 05:32:21 jason Exp $	*/
d87 1
a87 1
int	hifn_checkramaddr __P((struct hifn_softc *, int));
d97 2
d220 1
a220 2
	if (hifn_checkramaddr(sc, 0) != 0)
		sc->sc_drammodel = 1;
d551 36
d588 2
a589 1
 * For sram boards, just write/read memory until it fails.
d596 4
d606 1
a606 1
		if (hifn_checkramaddr(sc, a) < 0)
d608 17
d628 4
d634 5
d659 2
a660 11

/*
 * There are both DRAM and SRAM models of the hifn board.
 * A bit in the "ram configuration register" needs to be
 * set according to the model.  The driver will guess one
 * way or the other -- and then call this routine to verify.
 *
 * 0: RAM setting okay,  -1: Current RAM setting in error
 */
int 
hifn_checkramaddr(sc, addr)
d662 2
a663 1
	int addr;
a664 3
	hifn_base_command_t write_command,read_command;
	u_int8_t data[8] = {'1', '2', '3', '4', '5', '6', '7', '8'};
	u_int8_t *source_buf, *dest_buf;
d666 8
a673 23
	const u_int32_t masks = HIFN_D_VALID | HIFN_D_LAST |
	    HIFN_D_MASKDONEIRQ;

	write_command.masks = 3 << 13;
	write_command.session_num = addr >> 14;
	write_command.total_source_count = 8;
	write_command.total_dest_count = addr & 0x3fff;;

	read_command.masks = 2 << 13;
	read_command.session_num = addr >> 14;
	read_command.total_source_count = addr & 0x3fff;
	read_command.total_dest_count = 8;

#if (HIFN_D_CMD_RSIZE < 3)
#error "descriptor ring size too small DRAM/SRAM check"
#endif

	/*
	 * We steal the 8 bytes needed for both the source and dest buffers
	 * from the 3rd slot that the DRAM/SRAM test won't use.
	 */
	source_buf = sc->sc_dma->command_bufs[2];
	dest_buf = sc->sc_dma->result_bufs[2];
d676 2
a677 2
	*(hifn_base_command_t *) sc->sc_dma->command_bufs[0] = write_command;
	bcopy(data, source_buf, sizeof(data));
d679 2
a680 2
	dma->srcr[0].p = vtophys(source_buf);
	dma->dstr[0].p = vtophys(dest_buf);
d682 4
a685 4
	dma->cmdr[0].l = 16 | masks;
	dma->srcr[0].l = 8 | masks;
	dma->dstr[0].l = 8 | masks;
	dma->resr[0].l = HIFN_MAX_RESULT | masks;
d688 7
a694 3
	if (dma->resr[0].l & HIFN_D_VALID)
		printf("%s: SRAM/DRAM detection error -- result[0] valid still set\n",
		    sc->sc_dv.dv_xname);
d696 24
a719 9
	/* Build read command */
	*(hifn_base_command_t *) sc->sc_dma->command_bufs[1] = read_command;

	dma->srcr[1].p = vtophys(source_buf);
	dma->dstr[1].p = vtophys(dest_buf);
	dma->cmdr[1].l = 16 | masks;
	dma->srcr[1].l = 8 | masks;
	dma->dstr[1].l = 8 | masks;
	dma->resr[1].l = HIFN_MAX_RESULT | masks;
d722 7
a728 4
	if (dma->resr[1].l & HIFN_D_VALID)
		printf("%s: SRAM/DRAM detection error -- result[1] valid still set\n",
		    sc->sc_dv.dv_xname);
	return (memcmp(dest_buf, data, sizeof(data)) == 0) ? 0 : -1;
@


1.36
log
@fixing the frontend means fixing the backend too... add a countdown when
computing the length of a destination buffer in the callback since hifn always
writes in multiples of 4 bytes (and AH can produce non-nice packets)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.35 2000/04/25 04:15:34 jason Exp $	*/
d781 1
@


1.35
log
@use the size of the allocation, not the minimum of what was requested and
the allocation size to determine the length of a destination buffer
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.34 2000/04/23 05:03:40 angelos Exp $	*/
a96 1
void	hifn_show_packed __P((char *s, long *pp, int *pl, int npa, int l));
d1303 2
d1306 6
a1311 1
			m->m_len = dma->dstr[dma->dstk].l & HIFN_D_LENGTH;
@


1.34
log
@freesession takes u_int64_t
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.33 2000/04/19 00:10:35 deraadt Exp $	*/
d97 1
d808 1
a808 1
			m->m_len = len = min(totlen, len);
@


1.33
log
@split out mbuf scatter gather function
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.32 2000/04/13 22:34:08 jason Exp $	*/
d93 1
a93 1
int	hifn_freesession __P((u_int32_t));
d1087 2
a1088 2
hifn_freesession(sid)
	u_int32_t sid;
d1092 1
@


1.32
log
@- let hifn_process() compute the mask bits for the command descriptors
(falls under the category of compute it once and use it).
- just copy the computed masks in hifn_write_command()
- remove the now unnecessary flags field from hifn_command
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.31 2000/04/13 20:55:16 jason Exp $	*/
a90 1
int	hifn_mbuf __P((struct mbuf *, int *, long *, int *, int, int *));
a758 68
int
hifn_mbuf(m, np, pp, lp, maxp, nicep)
	struct mbuf *m;
	int *np;
	long *pp;
	int *lp;
	int maxp;
	int *nicep;
{
	struct	mbuf *m0;
	int npa = 0, tlen = 0;

	/* generate a [pa,len] array from an mbuf */
	for (m0 = m; m; m = m->m_next) {
		void *va;
		long pg, npg;
		int len, off;

		if (m->m_len == 0)
			continue;
		len = m->m_len;
		tlen += len;
		va = m->m_data;

		lp[npa] = len;
		pp[npa] = vtophys(va);
		pg = pp[npa] & ~PAGE_MASK;
		off = (long)va & PAGE_MASK;

		while (len + off > PAGE_SIZE) {
			va = va + PAGE_SIZE - off;
			npg = vtophys(va);
			if (npg != pg) {
				/* FUCKED UP condition */
				if (++npa > maxp)
					return (0);
				continue;
			}
			lp[npa] = PAGE_SIZE - off;
			off = 0;

			if (++npa > maxp)
				return (0);

			lp[npa] = len - (PAGE_SIZE - off);
			len -= lp[npa];
			pp[npa] = vtophys(va);
		} 

		if (++npa == maxp)
			return (0);
	}

	if (nicep) {
		int nice = 1;
		int i;

		/* see if each [pa,len] entry is long-word aligned */
		for (i = 0; i < npa; i++)
			if ((lp[i] & 3) || (pp[i] & 3))
				nice = 0;
		*nicep = nice;
	}

	*np = npa;
	return (tlen);
}

d770 1
a770 1
		cmd->src_l = hifn_mbuf(cmd->src_m, &cmd->src_npa,
d817 1
a817 1
	cmd->dst_l = hifn_mbuf(cmd->dst_m, &cmd->dst_npa,
@


1.31
log
@- complete rewrite of hifn_write_command() to avoid copies by removing the
hifn_build_command() middle layer for building the command descriptor
- remove an unnecessary assignment in hifn_process()
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.30 2000/04/13 00:28:44 deraadt Exp $	*/
d706 1
a706 1
	int flags, using_mac, using_crypt, len;
a707 3
	flags = cmd->flags;
	using_mac = HIFN_USING_MAC(flags);
	using_crypt = HIFN_USING_CRYPT(flags);
d709 2
d713 1
a713 7
	base_cmd->masks = 0;
	if (using_mac)
		base_cmd->masks |= HIFN_BASE_CMD_MAC;
	if (using_crypt)
		base_cmd->masks |= HIFN_BASE_CMD_CRYPT;
	if (flags & HIFN_DECODE)
		base_cmd->masks |= HIFN_BASE_CMD_DECODE;
d721 1
a721 8
		mac_cmd->masks = HIFN_MAC_CMD_MODE_HMAC | HIFN_MAC_CMD_RESULT |
		    HIFN_MAC_CMD_POS_IPSEC;
		mac_cmd->masks |= (flags & HIFN_MAC_MD5) ?
		    HIFN_MAC_CMD_ALG_MD5 : HIFN_MAC_CMD_ALG_SHA1;
		if (flags & HIFN_MAC_TRUNC)
			mac_cmd->masks |= HIFN_MAC_CMD_TRUNC;
		if (flags & HIFN_MAC_NEW_KEY)
			mac_cmd->masks |= HIFN_MAC_CMD_NEW_KEY;
d729 1
a729 5
		cry_cmd->masks = HIFN_CRYPT_CMD_MODE_CBC | HIFN_CRYPT_CMD_NEW_IV;
		cry_cmd->masks |= (flags & HIFN_CRYPT_DES) ?
		    HIFN_CRYPT_CMD_ALG_DES : HIFN_CRYPT_CMD_ALG_3DES;
		if (flags & HIFN_CRYPT_NEW_KEY)
			cry_cmd->masks |= HIFN_CRYPT_CMD_NEW_KEY;
d735 1
a735 1
	if (flags & HIFN_MAC_NEW_KEY) {
d740 3
a742 3
	if (flags & HIFN_CRYPT_NEW_KEY) {
		len = (flags & HIFN_CRYPT_DES) ?
		    HIFN_DES_KEY_LENGTH : HIFN_3DES_KEY_LENGTH;
d1049 1
a1049 1
		if (HIFN_USING_MAC(cmd->flags)) {
a1230 5
			cmd->flags |= HIFN_ENCODE | HIFN_MAC_TRUNC;
			if (sc->sc_sessions[session].hs_flags == 1) {
				cmd->flags |= HIFN_MAC_NEW_KEY;
				sc->sc_sessions[session].hs_flags = 2;
			}
d1234 2
a1235 8
			if (crd1->crd_flags & CRD_F_ENCRYPT)
				cmd->flags |= HIFN_ENCODE;
			else
				cmd->flags |= HIFN_DECODE;
			if (sc->sc_sessions[session].hs_flags == 1) {
				cmd->flags |= HIFN_CRYPT_NEW_KEY;
				sc->sc_sessions[session].hs_flags = 2;
			}
d1250 1
a1250 1
			cmd->flags |= HIFN_DECODE | HIFN_MAC_TRUNC;
a1258 1
			cmd->flags |= HIFN_ENCODE | HIFN_MAC_TRUNC;
a1268 5

		if (sc->sc_sessions[session].hs_flags == 1) {
			cmd->flags |= HIFN_MAC_NEW_KEY | HIFN_CRYPT_NEW_KEY;
			sc->sc_sessions[session].hs_flags = 2;
		}
d1272 3
d1295 1
a1295 1
			cmd->flags |= HIFN_CRYPT_DES;
d1297 2
a1298 1
			cmd->flags |= HIFN_CRYPT_3DES;
d1302 3
d1308 5
d1314 1
a1314 1
			cmd->flags |= HIFN_MAC_MD5;
d1316 9
a1324 1
			cmd->flags |= HIFN_MAC_SHA1;
a1326 3
		bcopy(maccrd->crd_key, cmd->mac, maccrd->crd_klen >> 3);
		bzero(cmd->mac + (maccrd->crd_klen >> 3),
		      HIFN_MAC_KEY_LENGTH - (maccrd->crd_klen >> 3));
d1329 3
d1387 2
a1388 2
	if ((cmd->flags & HIFN_ENCODE) &&
	    ((cmd->flags & HIFN_CRYPT_DES) || (cmd->flags & HIFN_CRYPT_3DES))) {
@


1.30
log
@match netsec 7751 card, and oh golly gee, will ya look at that, it's
unlock secret is all 0's as well, my, what a coincidence!
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.29 2000/04/11 19:59:06 jason Exp $	*/
d90 1
a90 4
u_int	hifn_write_command __P((const struct hifn_command_buf_data *,
    u_int8_t *));
int	hifn_build_command __P((const struct hifn_command * cmd,
    struct hifn_command_buf_data *));
d698 3
a700 69
hifn_write_command(const struct hifn_command_buf_data *cmd_data,
    u_int8_t *command_buf)
{
	u_int8_t *command_buf_pos = command_buf;
	const hifn_base_command_t *base_cmd = &cmd_data->base_cmd;
	const hifn_mac_command_t *mac_cmd = &cmd_data->mac_cmd;
	const hifn_crypt_command_t *crypt_cmd = &cmd_data->crypt_cmd;
	int     using_mac = base_cmd->masks & HIFN_BASE_CMD_MAC;
	int     using_crypt = base_cmd->masks & HIFN_BASE_CMD_CRYPT;

	/* write base command structure */
	*((hifn_base_command_t *) command_buf_pos) = *base_cmd;
	command_buf_pos += sizeof(hifn_base_command_t);

	/* Write MAC command structure */
	if (using_mac) {
		*((hifn_mac_command_t *) command_buf_pos) = *mac_cmd;
		command_buf_pos += sizeof(hifn_mac_command_t);
	}

	/* Write encryption command structure */
	if (using_crypt) {
		*((hifn_crypt_command_t *) command_buf_pos) = *crypt_cmd;
		command_buf_pos += sizeof(hifn_crypt_command_t);
	}

	/* write MAC key */
	if (mac_cmd->masks & HIFN_MAC_CMD_NEW_KEY) {
		bcopy(cmd_data->mac, command_buf_pos, HIFN_MAC_KEY_LENGTH);
		command_buf_pos += HIFN_MAC_KEY_LENGTH;
	}

	/* Write crypto key */
	if (crypt_cmd->masks & HIFN_CRYPT_CMD_NEW_KEY) {
		u_int32_t alg = crypt_cmd->masks & HIFN_CRYPT_CMD_ALG_MASK;
		u_int32_t key_len = (alg == HIFN_CRYPT_CMD_ALG_DES) ?
		HIFN_DES_KEY_LENGTH : HIFN_3DES_KEY_LENGTH;
		bcopy(cmd_data->ck, command_buf_pos, key_len);
		command_buf_pos += key_len;
	}

	/* Write crypto iv */
	if (crypt_cmd->masks & HIFN_CRYPT_CMD_NEW_IV) {
		bcopy(cmd_data->iv, command_buf_pos, HIFN_IV_LENGTH);
		command_buf_pos += HIFN_IV_LENGTH;
	}

	/* Write 8 zero bytes we're not sending crypt or MAC structures */
	if (!(base_cmd->masks & HIFN_BASE_CMD_MAC) &&
	    !(base_cmd->masks & HIFN_BASE_CMD_CRYPT)) {
		*((u_int32_t *) command_buf_pos) = 0;
		command_buf_pos += 4;
		*((u_int32_t *) command_buf_pos) = 0;
		command_buf_pos += 4;
	}

	if ((command_buf_pos - command_buf) > HIFN_MAX_COMMAND)
		printf("hifn: Internal Error -- Command buffer overflow.\n");
	return command_buf_pos - command_buf;
}

/*
 * Check command input and build up structure to write
 * the command buffer later.  Returns 0 on success and
 * -1 if given bad command input was given.
 */
int 
hifn_build_command(const struct hifn_command *cmd,
    struct hifn_command_buf_data * cmd_buf_data)
d702 14
a715 66
#define HIFN_COMMAND_CHECKING

	u_int32_t flags = cmd->flags;
	hifn_base_command_t *base_cmd = &cmd_buf_data->base_cmd;
	hifn_mac_command_t *mac_cmd = &cmd_buf_data->mac_cmd;
	hifn_crypt_command_t *crypt_cmd = &cmd_buf_data->crypt_cmd;
	u_int   mac_length;
#if defined(HIFN_COMMAND_CHECKING) && 0
	int     dest_diff;
#endif

	bzero(cmd_buf_data, sizeof(struct hifn_command_buf_data));

#ifdef HIFN_COMMAND_CHECKING
	if (!(!!(flags & HIFN_DECODE) ^ !!(flags & HIFN_ENCODE))) {
		printf("hifn: encode/decode setting error\n");
		return -1;
	}
	if ((flags & HIFN_CRYPT_DES) && (flags & HIFN_CRYPT_3DES)) {
		printf("hifn: Too many crypto algorithms set in command\n");
		return -1;
	}
	if ((flags & HIFN_MAC_SHA1) && (flags & HIFN_MAC_MD5)) {
		printf("hifn: Too many MAC algorithms set in command\n");
		return -1;
	}
#endif


	/*
	 * Compute the mac value length -- leave at zero if not MAC'ing
	 */
	mac_length = 0;
	if (HIFN_USING_MAC(flags)) {
		mac_length = (flags & HIFN_MAC_TRUNC) ? HIFN_MAC_TRUNC_LENGTH :
		    ((flags & HIFN_MAC_MD5) ? HIFN_MD5_LENGTH : HIFN_SHA1_LENGTH);
	}
#ifdef HIFN_COMMAND_CHECKING
	/*
	 * Check for valid src/dest buf sizes
	 */

	/*
	 * XXX XXX  We need to include header counts into all these
	 *           checks!!!!
	 * XXX These tests are totally wrong.
	 */
#if 0
	if (cmd->src_npa <= mac_length) {
		printf("hifn: command source buffer has no data: %d <= %d\n",
		    cmd->src_npa, mac_length);
		return -1;
	}
	dest_diff = (flags & HIFN_ENCODE) ? mac_length : -mac_length;
	if (cmd->dst_npa < cmd->dst_npa + dest_diff) {
		printf("hifn:  command dest length %u too short -- needed %u\n",
		    cmd->dst_npa, cmd->dst_npa + dest_diff);
		return -1;
	}
#endif
#endif

	/*
	 * Set MAC bit
	 */
	if (HIFN_USING_MAC(flags))
d717 1
a717 3

	/* Set Encrypt bit */
	if (HIFN_USING_CRYPT(flags))
a718 4

	/*
	 * Set Decode bit
	 */
a720 5

	/*
	 * Set total source and dest counts.  These values are the same as the
	 * values set in the length field of the source and dest descriptor rings.
	 */
a722 4

	/*
	 * XXX -- We need session number range checking...
	 */
d724 1
d726 4
a729 9
	/**
	 **  Building up mac command
	 **
	 **/
	if (HIFN_USING_MAC(flags)) {

		/*
		 * Set the MAC algorithm and trunc setting
		 */
d734 1
a734 14

		/*
		 * We always use HMAC mode, assume MAC values are appended to the
		 * source buffer on decodes and we append them to the dest buffer
		 * on encodes, and order auth/encryption engines as needed by
		 * IPSEC
		 */
		mac_cmd->masks |= HIFN_MAC_CMD_MODE_HMAC | HIFN_MAC_CMD_RESULT |
		    HIFN_MAC_CMD_POS_IPSEC;

		/*
		 * Setup to send new MAC key if needed.
		 */
		if (flags & HIFN_MAC_NEW_KEY) {
a735 5
			cmd_buf_data->mac = cmd->mac;
		}
		/*
		 * Set the mac header skip and source count.
		 */
d738 1
d741 4
a744 5
	if (HIFN_USING_CRYPT(flags)) {
		/*
		 * Set the encryption algorithm bits.
		 */
		crypt_cmd->masks |= (flags & HIFN_CRYPT_DES) ?
d746 6
d753 4
a756 3
		/* We always use CBC mode and send a new IV (as needed by
		 * IPSec). */
		crypt_cmd->masks |= HIFN_CRYPT_CMD_MODE_CBC | HIFN_CRYPT_CMD_NEW_IV;
d758 6
a763 12
		/*
		 * Setup to send new encrypt key if needed.
		 */
		if (flags & HIFN_CRYPT_NEW_KEY) {
			crypt_cmd->masks |= HIFN_CRYPT_CMD_NEW_KEY;
			cmd_buf_data->ck = cmd->ck;
		}
		/*
		 * Set the encrypt header skip and source count.
		 */
		crypt_cmd->header_skip = cmd->crypt_header_skip;
		crypt_cmd->source_count = cmd->crypt_process_len;
d765 3
a767 7
#ifdef HIFN_COMMAND_CHECKING
		if (crypt_cmd->source_count % 8 != 0) {
			printf("hifn:  Error -- encryption source %u not a multiple of 8!\n",
			    crypt_cmd->source_count);
			return -1;
		}
#endif
a768 1
	cmd_buf_data->iv = cmd->iv;
d770 4
a773 12
#if 0
	printf("hifn: command parameters"
	    " -- session num %u"
	    " -- base t.s.c: %u"
	    " -- base t.d.c: %u"
	    " -- mac h.s. %u  s.c. %u"
	    " -- crypt h.s. %u  s.c. %u\n",
	    base_cmd->session_num,
	    base_cmd->total_source_count, base_cmd->total_dest_count,
	    mac_cmd->header_skip, mac_cmd->source_count,
	    crypt_cmd->header_skip, crypt_cmd->source_count);
#endif
d775 1
a775 1
	return 0;		/* success */
a852 1
	struct	hifn_command_buf_data cmd_buf_data;
a908 3
	if (hifn_build_command(cmd, &cmd_buf_data) != 0)
		return HIFN_CRYPTO_BAD_INPUT;

d945 1
a945 1
	cmdlen = hifn_write_command(&cmd_buf_data, dma->command_bufs[cmdi]);
a1332 1
		cmd->ck_len = enccrd->crd_klen >> 3;
@


1.29
log
@- add support for buffers that are not aligned (or end on a non 4byte boundary)
- recompute destination length from destination descriptors and reclaim the
  destination ring there.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.28 2000/04/11 16:22:09 jason Exp $	*/
d125 3
d356 5
@


1.28
log
@- Don't bother with PCI_COMMAND_IO_ENABLE, the card doesn't support it.
- remove some debugging code
- fix arguments to last call to crypto_register()
- for sram boards, only check 1mb of ram
- when the rings are full, call the crp->callback with crp->crp_etype == ENOMEM
	so it can clean up, then return 0
- some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.27 2000/04/10 18:40:47 jason Exp $	*/
d99 1
a99 1
void	hifn_callback __P((struct hifn_command *, u_int8_t *));
d1026 6
a1031 3
		cmd->dst_l = cmd->src_l;
		MGETHDR(cmd->dst_m, M_DONTWAIT, MT_DATA);
		if (cmd->dst_m == NULL)
d1033 23
a1055 5
		if (cmd->src_l > MHLEN) {
			MCLGET(cmd->dst_m, M_DONTWAIT);
			if ((cmd->dst_m->m_flags & M_EXT) == 0) {
				m_freem(cmd->dst_m);
				return (-1);
d1057 4
d1062 3
a1064 1
	} else
d1239 1
a1239 1
		cmd->dest_ready_callback(cmd, macbuf);
a1256 9
	i = dma->dstk; u = dma->dstu;
	while (u != 0 && (dma->dstr[i].l & HIFN_D_VALID) == 0) {
		hifnstats.hst_obytes += dma->dstr[i].l & 0xffff;
		if (++i == HIFN_D_DST_RSIZE)
			i = 0;
		u--;
	}
	dma->dstk = i; dma->dstu = u;

d1537 2
a1538 1
hifn_callback(cmd, macbuf)
d1542 1
d1545 1
d1550 17
@


1.27
log
@- Add back code from the original aeon driver to handle missed interrupts by
enabling interrupts when the command queue has more than one entry.
- fix comment on hifn_newsession to reflect reality
- allocate session structure in softc
- compute a random IV when a session is created and try to chain from a
software kept IV for subsequent packets
- add handling of CRD_F_EXPLICIT
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.26 2000/04/05 16:52:22 jason Exp $	*/
d149 1
a149 2
	cmd |= PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	    PCI_COMMAND_MASTER_ENABLE;
a176 3
#ifdef HIFN_DEBUG
	printf(" mem %x %x", sc->sc_sh0, sc->sc_sh1);
#endif
d282 1
a282 1
		    hifn_newsession, hifn_freesession, hifn_process);
d558 1
a558 1
	end = 1 << 21;	/* 2MB */
d1514 2
a1515 1
	return (crp->crp_callback(crp));
d1550 1
a1550 1
				   crd->crd_inject, 12, macbuf);
@


1.26
log
@run at splnet() instead of splimp()
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.25 2000/04/05 16:34:07 jason Exp $	*/
d1096 10
d1184 1
a1184 1
	if ((dmacsr & HIFN_DMACSR_R_DONE) == 0)
d1191 9
d1252 3
a1254 1
	 * Clear "result done" flags in status register.
d1256 1
a1256 1
	WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_R_DONE);
a1263 2
 * XXX Mac and encrypt keys should be sent to context ram and should
 * XXX maintain some sort of state.
a1286 8
	if (sc->sc_sessions == NULL) {
		sc->sc_sessions = (u_int8_t *)malloc(sc->sc_maxses,
		    M_DEVBUF, M_NOWAIT);
		if (sc->sc_sessions == NULL)
			return (ENOMEM);
		bzero(sc->sc_sessions, sc->sc_maxses);
	}

d1288 1
a1288 1
		if (sc->sc_sessions[i] == 0)
d1314 2
a1315 1
	sc->sc_sessions[i] = 1;
d1338 1
a1338 1
	if (session >= sc->sc_maxses || sc->sc_sessions == NULL)
d1341 1
a1341 1
	sc->sc_sessions[session] = 0;
d1402 1
a1402 1
			if (sc->sc_sessions[session] == 1) {
d1404 1
a1404 1
				sc->sc_sessions[session] = 2;
d1413 1
a1413 1
			if (sc->sc_sessions[session] == 1) {
d1415 1
a1415 1
				sc->sc_sessions[session] = 2;
d1452 1
a1452 1
		if (sc->sc_sessions[session] == 1) {
d1454 1
a1454 1
			sc->sc_sessions[session] = 2;
d1459 17
a1475 5
		if ((enccrd->crd_flags & (CRD_F_ENCRYPT | CRD_F_IV_PRESENT)) ==
		    CRD_F_ENCRYPT) {
			get_random_bytes(cmd->iv, HIFN_IV_LENGTH);
			m_copyback(cmd->src_m, enccrd->crd_inject,
				   HIFN_IV_LENGTH, cmd->iv);
a1476 3
		else
			m_copydata(cmd->src_m, enccrd->crd_inject,
				   HIFN_IV_LENGTH, cmd->iv);
d1503 1
d1532 13
@


1.25
log
@maintain state about keys, upload them to context ram once (and avoid the
300 clock penalty on key upload)
XXX hifn_freesession should probably zot the keys from context ram but
XXX does not yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.24 2000/04/04 20:16:33 jason Exp $	*/
d246 1
a246 1
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_IMP, hifn_intr, sc,
d1060 1
a1060 1
	s = splimp();
@


1.24
log
@add mac result pointer to the callback routine
register as supporting MD5_HMAC96 and SHA1_HMAC96
use the correct bit (HIFN_MAC_CMD_NEW_KEY) when checking the mac_cmd mask
don't append the mac result to the dest buffer, add it to the result buffer
remove incorrect source count calculation involving mac length
add order checking to hifn_process so that we can verify the request is
	possible given the ordering of processing units within the hifn.
correct hifn_callback()'s handling of mac checking and copy the computed
	mac into the right place in the mbuf.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.23 2000/03/31 05:49:08 jason Exp $	*/
d1268 16
a1283 1
	for (c = cri, i = 0; c != NULL; c = c->cri_next) {
a1298 1

d1302 3
a1304 1
	*sidp = HIFN_SID(sc->sc_dv.dv_unit, 1);
d1317 13
d1389 5
a1393 2
			cmd->flags |= HIFN_ENCODE | HIFN_MAC_TRUNC |
				HIFN_MAC_NEW_KEY;
d1398 1
a1398 1
				cmd->flags |= HIFN_ENCODE | HIFN_CRYPT_NEW_KEY;
d1400 5
a1404 1
				cmd->flags |= HIFN_DECODE | HIFN_CRYPT_NEW_KEY;
d1419 1
a1419 2
			cmd->flags |= HIFN_DECODE | HIFN_MAC_TRUNC |
			    HIFN_MAC_NEW_KEY | HIFN_CRYPT_NEW_KEY;
d1428 1
a1428 2
			cmd->flags |= HIFN_ENCODE | HIFN_MAC_TRUNC |
			    HIFN_MAC_NEW_KEY | HIFN_CRYPT_NEW_KEY;
d1439 5
d1481 1
@


1.23
log
@Remove the timeout and print_stats functions (debugging code)
Make sure to skip over zero length mbufs when building the pa/len array
Correct some of the comments to reflect reality
Fix sanity checking of the device based on the 'sid'
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.22 2000/03/30 23:14:25 jason Exp $	*/
d38 4
d99 1
a99 1
void	hifn_callback __P((struct hifn_command *));
a280 2
#if 0
		/* Can't do md5/sha1 yet */
a284 1
#endif
d724 1
a724 1
	if (mac_cmd->masks & HIFN_MAC_NEW_KEY) {
d877 1
a877 1
		mac_cmd->masks |= HIFN_MAC_CMD_MODE_HMAC | HIFN_MAC_CMD_APPEND |
a891 2
		if (flags & HIFN_DECODE)
			mac_cmd->source_count -= mac_length;
a916 3
		if (flags & HIFN_DECODE)
			crypt_cmd->source_count -= mac_length;

a927 1

d935 4
a938 4
	    base_cmd->session_num, base_cmd->total_source_count,
	    base_cmd->total_dest_count, mac_cmd->header_skip,
	    mac_cmd->source_count, crypt_cmd->header_skip,
	    crypt_cmd->source_count);
d1183 1
d1191 3
a1193 5
		if (HIFN_USING_MAC(cmd->flags) && (cmd->flags & HIFN_DECODE)) {
			u_int8_t *result_buf = dma->result_bufs[dma->resk];
	
			cmd->result_flags = (result_buf[8] & 0x2) ?
			    HIFN_MAC_BAD : 0;
d1195 1
a1195 1
	
d1197 1
a1197 1
		cmd->dest_ready_callback(cmd);
d1311 1
a1311 1
	struct cryptodesc *crd;
d1348 6
a1353 5
	for (crd = crp->crp_desc; crd != NULL; crd = crd->crd_next) {
		if (crd->crd_flags & CRD_F_ENCRYPT)
			cmd->flags |= HIFN_ENCODE;
		else
			cmd->flags |= HIFN_DECODE;
d1355 7
a1361 8
		if (crd->crd_alg == CRYPTO_MD5_HMAC96) {
			/* XXX not right */
			cmd->flags |= HIFN_MAC_MD5 | HIFN_MAC_TRUNC |
			    HIFN_MAC_NEW_KEY;
			cmd->mac_header_skip = crd->crd_skip;
			cmd->mac_process_len = crd->crd_len;
			cmd->mac = crd->crd_key;
			cmd->mac_len = crd->crd_klen >> 3;
d1363 12
a1374 8
		else if (crd->crd_alg == CRYPTO_SHA1_HMAC96) {
			/* XXX not right */
			cmd->flags |= HIFN_MAC_SHA1 | HIFN_MAC_TRUNC |
			    HIFN_MAC_NEW_KEY;
			cmd->mac_header_skip = crd->crd_skip;
			cmd->mac_process_len = crd->crd_len;
			cmd->mac = crd->crd_key;
			cmd->mac_len = crd->crd_klen >> 3;
d1376 11
a1386 17
		else if (crd->crd_alg == CRYPTO_DES_CBC) {
			if ((crd->crd_flags &
			     (CRD_F_ENCRYPT | CRD_F_IV_PRESENT)) ==
			    CRD_F_ENCRYPT) {
				get_random_bytes(cmd->iv, HIFN_IV_LENGTH);
				m_copyback(cmd->src_m, crd->crd_inject,
				    HIFN_IV_LENGTH, cmd->iv);
			}
			else
				m_copydata(cmd->src_m, crd->crd_inject,
				    HIFN_IV_LENGTH, cmd->iv);

			cmd->flags |= HIFN_CRYPT_DES | HIFN_CRYPT_NEW_KEY;
			cmd->crypt_header_skip = crd->crd_skip;
			cmd->crypt_process_len = crd->crd_len;
			cmd->ck = crd->crd_key;
			cmd->ck_len = crd->crd_klen >> 3;
d1388 9
a1396 17
		else if (crd->crd_alg == CRYPTO_3DES_CBC) {
			if ((crd->crd_flags &
			     (CRD_F_ENCRYPT | CRD_F_IV_PRESENT)) ==
			    CRD_F_IV_PRESENT) {
				get_random_bytes(cmd->iv, HIFN_IV_LENGTH);
				m_copyback(cmd->src_m, crd->crd_inject,
				    HIFN_IV_LENGTH, cmd->iv);
			}
			else
				m_copydata(cmd->src_m, crd->crd_inject,
				    HIFN_IV_LENGTH, cmd->iv);

			cmd->flags |= HIFN_CRYPT_3DES | HIFN_CRYPT_NEW_KEY;
			cmd->crypt_header_skip = crd->crd_skip;
			cmd->crypt_process_len = crd->crd_len;
			cmd->ck = crd->crd_key;
			cmd->ck_len = crd->crd_klen >> 3;
d1399 3
d1407 34
a1441 1
	cmd->dest_ready_callback = hifn_callback;
d1460 1
a1460 1
hifn_callback(cmd)
d1462 1
d1465 1
a1465 5

	if (HIFN_USING_MAC(cmd->flags) && !HIFN_MAC_OK(cmd->result_flags))
		crp->crp_etype = EIO;
	else
		crp->crp_etype = 0;
d1470 11
@


1.22
log
@document hook functions
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.21 2000/03/30 07:30:39 jason Exp $	*/
a95 2
void	hifn_timeout __P((void *));
void	hifn_print_stats __P((struct hifn_softc *));
d967 2
a968 1
		va = m->m_data;
d971 1
d1202 1
a1202 1
		/* position is done, notify producer with wakup or callback */
d1239 1
a1239 3
	 * Clear "result done" and "waiting on command ring" flags in status
	 * register.  If we still have slots to process and we received a
	 * waiting interrupt, this will interupt us again.
d1258 1
a1258 1
	struct hifn_softc *sc;
d1266 2
d1456 1
a1456 21
	(*crp->crp_callback)(crp);
}

void
hifn_timeout(v)
	void *v;
{
	struct hifn_softc *sc = v;

	hifn_print_stats(sc);
}

void
hifn_print_stats(sc)
	struct hifn_softc *sc;
{
	printf("timeout: dmacsr %08x\n",
	    READ_REG_1(sc, HIFN_1_DMA_CSR));
	printf("timeout: %08x, %08x, %08x, %08x\n",
	    READ_REG_1(sc, HIFN_1_DMA_CRAR), READ_REG_1(sc, HIFN_1_DMA_SRAR),
	    READ_REG_1(sc, HIFN_1_DMA_DRAR), READ_REG_1(sc, HIFN_1_DMA_RRAR));
@


1.21
log
@instrument bad crp's and bad crp callbacks, too
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.20 2000/03/30 05:56:31 jason Exp $	*/
d107 1
a107 1
} hifnstats = { 0, 0, 0, 0, 0, 0 };
d1247 7
d1298 5
@


1.20
log
@add some instrumentation for tracking input (commands/bytes) and output
  (results/bytes) as well as "ring full" and "other" errors
rework hifn_process so that in the event of a ring full or other error,
  the error type is set in the descriptor and the callback is executed.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.19 2000/03/29 22:39:38 jason Exp $	*/
d1307 2
a1308 1
	if (crp == NULL || crp->crp_callback == NULL)
d1310 1
@


1.19
log
@- update copyrights
- remove all ability to block (no more tsleep/wakeup)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.18 2000/03/29 21:03:11 jason Exp $	*/
d98 10
a107 1
int hifn_crypto __P((struct hifn_softc *, hifn_command_t *));
d1101 1
d1118 1
d1208 1
d1223 1
d1303 1
a1303 1
	int card, session;
d1307 3
a1309 2
	if (crp == NULL)
		goto errout;
d1311 2
a1312 1
	if (card >= hifn_cd.cd_ndevs)
d1314 2
d1318 2
a1319 1
	if (session >= sc->sc_maxses)
d1321 1
d1325 2
a1326 1
	if (cmd == NULL)
d1328 1
d1335 2
a1336 1
	else
d1338 1
d1400 2
a1401 1
		else
d1403 1
d1412 2
d1417 6
a1422 1
	return (EINVAL);
@


1.18
log
@remove round-robin use of the boards.  We're depending on the upper layer
being more intelligent about allocation in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.17 2000/03/29 20:54:59 jason Exp $	*/
d7 2
d1017 1
a1017 1
	int     error, s, i;
d1062 1
a1062 1
	while (dma->cmdu+1 > HIFN_D_CMD_RSIZE ||
a1065 1
		if (cmd->flags & HIFN_DMA_FULL_NOBLOCK) {
a1067 2
		}
		tsleep((caddr_t) dma, PZERO, "hifnring", 1);
a1139 15
	/*
	 * If not given a callback routine, we block until the dest data is
	 * ready.  (Setting interrupt timeout at 3 seconds.)
	 */
	if (cmd->dest_ready_callback == NULL) {
		printf("%s: no callback -- we're sleeping\n",
		    sc->sc_dv.dv_xname);
		error = tsleep((caddr_t) & dma->resr[resi], PZERO, "CRYPT",
		    hz * 3);
		if (error != 0)
			printf("%s: timed out waiting for interrupt"
			    " -- tsleep() exited with %d\n",
			    sc->sc_dv.dv_xname, error);
	}

d1192 1
a1192 4
		if (cmd->dest_ready_callback == NULL)
			wakeup((caddr_t) &dma->resr[dma->resk]);
		else
			cmd->dest_ready_callback(cmd);
a1308 2

	cmd->flags = HIFN_DMA_FULL_NOBLOCK;
@


1.17
log
@Long over due checkpoint:
o register the hifn as handling DES and 3DES (no md5 or sha1 yet) depending
	on whether the board is unlocked (none, half, or full)
o Fix many KNF nits
o print the amount of memory correctly and don't print the number of sessions
o set command and result buffer sizes correctly
o reclaim the descriptor rings so new commands and buffers can be added
o remove some bogus checks on the command buffer
o add new variables mac_process_len and crypt_process_len to hifn_command_t
o fix calculation in hifn_mbuf to generate the pa/len array for src/dst
o simplify the code for setting up the jump descriptor
o rework the hifn_intr routine to interrupt at IPL_IMP and simplify it's
	results processing
o more to come...
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.16 2000/03/22 05:30:47 jason Exp $	*/
d96 1
d1007 3
a1009 1
hifn_crypto(struct hifn_command *cmd)
d1012 1
a1012 3
	static u_int32_t current_device = 0;
	struct	hifn_softc *sc;
	struct	hifn_dma *dma;
a1016 9
	/* Pick the hifn board to send the data to.  Right now we use a round
	 * robin approach. */
	sc = hifn_cd.cd_devs[current_device];
	current_device++;
	if (current_device == hifn_cd.cd_ndevs ||
	    hifn_cd.cd_devs[current_device] == NULL)
		current_device = 0;
	dma = sc->sc_dma;

d1405 1
a1405 1
	if (hifn_crypto(cmd) == 0)
@


1.16
log
@fix arguments to failure printf's (correct numbers and types)
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.15 2000/03/22 04:47:01 jason Exp $	*/
d49 3
d75 3
a77 3
void	hifn_reset_board	__P((struct hifn_softc *));
int	hifn_enable_crypto	__P((struct hifn_softc *, pcireg_t));
void	hifn_init_dma	__P((struct hifn_softc *));
d83 1
a83 1
int	hifn_intr		__P((void *));
d88 1
a88 2
int	hifn_mbuf __P((struct mbuf *, int *np, long *pp, int *lp, int maxp,
    int *nicealign));
d90 6
a96 3
/*
 * Used for round robin crypto requests
 */
d124 1
d128 1
d232 1
a232 1
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, hifn_intr, sc,
d244 33
a276 3
	printf(", %dk %cram, %d sessions, %s\n",
	    sc->sc_ramsize/1024, sc->sc_drammodel ? 'd' : 's',
	    sc->sc_maxses, intrstr);
d503 1
a503 2
	    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE |
	    HIFN_DMACNFG_LAST |
d611 1
a611 1
#if (HIFN_D_RSIZE < 3)
d676 3
d763 1
a763 1
#ifdef HIFN_COMMAND_CHECKING
d799 1
a799 1
	 *  XXX XXX  We need to include header counts into all these
d801 1
d803 1
a803 1

d805 2
a806 1
		printf("hifn:  command source buffer has no data\n");
d816 1
d880 1
a880 1
		mac_cmd->source_count = cmd->src_npa - cmd->mac_header_skip;
d899 1
a899 1
		if (flags & HIFN_CRYPT_CMD_NEW_KEY) {
d907 1
a907 1
		crypt_cmd->source_count = cmd->src_npa - cmd->crypt_header_skip;
d923 1
a923 1
#if 1
d949 1
a949 2
	int npa = *np;
	int tlen = 0;
a951 1
	npa = 0;
d971 2
a972 1
				npa++;
d977 2
a978 2
			++npa;
			if (npa > maxp)
d980 1
d985 3
d1019 3
a1021 1
	if (++current_device == hifn_cd.cd_ndevs)
d1054 1
d1060 1
d1080 1
a1080 1
		cmdi = 0, dma->cmdi = 1;
d1083 2
a1084 2
	} else
		cmdi = dma->cmdi++;
d1087 1
a1087 1
		resi = 0, dma->resi = 1;
d1090 2
a1091 2
	} else
		resi = dma->resi++;
d1094 3
a1096 1
	dma->hifn_commands[cmdi] = cmd;
d1100 1
a1100 1
	dma->cmdu += 1;
d1111 1
a1111 1
			    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP;
d1114 1
a1114 1
		dma->srcr[srci].p = vtophys(cmd->src_packp[i]);
d1123 3
d1129 1
a1129 1
			    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP;
d1132 1
a1132 1
		dma->dstr[dsti].p = vtophys(cmd->dst_packp[i]);
d1142 4
d1147 1
a1147 11
	dma->resu += 1;

	/*
	 * We don't worry about missing an interrupt (which a waiting
	 * on command interrupt salvages us from), unless there is more
	 * than one command in the queue.
	 */
	if (dma->slots_in_use > 1) {
		WRITE_REG_1(sc, HIFN_1_DMA_IER,
		    HIFN_DMAIER_R_DONE | HIFN_DMAIER_C_WAIT);
	}
d1164 1
d1168 1
d1181 1
d1185 2
a1186 1
	printf("%s: irq: stat %8x ien %8x u %d/%d/%d/%d\n",
d1190 1
d1192 1
a1192 1
	if ((dmacsr & (HIFN_DMACSR_C_WAIT|HIFN_DMACSR_R_DONE)) == 0)
d1195 15
a1209 15
	if ((dma->slots_in_use == 0) && (dmacsr & HIFN_DMACSR_C_WAIT)) {
		/*
		 * If no slots to process and we received a "waiting on
		 * result" interrupt, we disable the "waiting on result"
		 * (by clearing it).
		 */
		WRITE_REG_1(sc, HIFN_1_DMA_IER, HIFN_DMAIER_R_DONE);
	} else {
		if (dma->slots_in_use > HIFN_D_RSIZE)
			printf("%s: Internal Error -- ring overflow\n",
			    sc->sc_dv.dv_xname);

		while (dma->slots_in_use > 0) {
			u_int32_t wake_pos = dma->wakeup_rpos;
			struct hifn_command *cmd = dma->hifn_commands[wake_pos];
d1211 3
a1213 3
			/* if still valid, stop processing */
			if (dma->resr[wake_pos].l & HIFN_D_VALID)
				break;
d1215 5
a1219 2
			if (HIFN_USING_MAC(cmd->flags) && (cmd->flags & HIFN_DECODE)) {
				u_int8_t *result_buf = dma->result_bufs[wake_pos];
d1221 28
a1248 16
				cmd->result_flags = (result_buf[8] & 0x2) ?
				    HIFN_MAC_BAD : 0;
				printf("%s: byte index 8 of result 0x%02x\n",
				    sc->sc_dv.dv_xname, (u_int32_t) result_buf[8]);
			}
	
			/* position is done, notify producer with wakup or callback */
			if (cmd->dest_ready_callback == NULL)
				wakeup((caddr_t) &dma->resr[wake_pos]);
			else
				cmd->dest_ready_callback(cmd);
	
			if (++dma->wakeup_rpos == HIFN_D_RSIZE)
				dma->wakeup_rpos = 0;
			dma->slots_in_use--;
		}
d1250 1
d1257 1
a1257 1
	WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_R_DONE|HIFN_DMACSR_C_WAIT);
d1259 201
@


1.15
log
@Oops... catch up with variable renaming in header file
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.14 2000/03/18 02:41:45 jason Exp $	*/
d164 1
a164 1
		printf(": can't alloc dma buffer\n", sc->sc_dv.dv_xname);
d170 1
a170 1
		    sc->sc_dv.dv_xname, sizeof(*sc->sc_dma));
d176 1
a176 1
		printf(": can't create dma map\n", sc->sc_dv.dv_xname);
d183 1
a183 1
		printf(": can't load dma map\n", sc->sc_dv.dv_xname);
@


1.14
log
@cap the maximum sessions at 2048 since that's all that is available in
the result descriptor (the command descriptor has an extra bit, but it
gets blown away in transit).
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.13 2000/03/17 21:59:07 jason Exp $	*/
d1165 1
a1165 1
				cmd->result_status = (result_buf[8] & 0x2) ?
@


1.13
log
@Be sure to mask out the chip stepping when examining the chip level
For round robin requests, use one static variable and hifn_cd to decide
the next device to use.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.12 2000/03/17 20:31:30 jason Exp $	*/
d498 3
@


1.12
log
@Fix some space->\t
Attempt to figure out how much context ram is on the board (known to work
with sram boards).
From the amount of ram & other configuration, figure out how many sessions
are available for storage.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.11 2000/03/16 20:39:23 deraadt Exp $	*/
a91 3
int hifn_num_devices = 0;
struct hifn_softc *hifn_devices[HIFN_MAX_DEVICES];

a234 3
	hifn_devices[hifn_num_devices] = sc;
	hifn_num_devices++;

d363 1
a363 1
	encl = READ_REG_0(sc, HIFN_0_PUSTAT);
d369 1
a369 1
	if (encl == 0x1020 || encl == 0x1120) {
d379 1
a379 1
	if (encl != 0 && encl != 0x3020) {
d399 1
a399 1
	encl = READ_REG_0(sc, HIFN_0_PUSTAT);
d402 1
a402 1
	if (encl != 0x1020 && encl != 0x1120)
d412 1
a412 1
	case 0x3020:
d415 1
a415 1
	case 0x1020:
d418 1
a418 1
	case 0x1120:
d970 2
a971 2
	sc = hifn_devices[current_device++];
	if (current_device == hifn_num_devices)
@


1.11
log
@document that other vendors use the hifn pci id too
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.10 2000/03/16 20:33:47 deraadt Exp $	*/
d76 4
a79 1
int	hifn_checkram __P((struct hifn_softc *));
d82 1
a82 1
	    u_int8_t *));
d84 1
a84 1
	    struct hifn_command_buf_data *));
d86 1
a86 1
	    int *nicealign));
d165 4
a168 4
        if (bus_dmamem_alloc(sc->sc_dmat, sizeof(*sc->sc_dma), PAGE_SIZE, 0,
            &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
                printf(": can't alloc dma buffer\n", sc->sc_dv.dv_xname);
                return;
d170 23
a192 23
        if (bus_dmamem_map(sc->sc_dmat, &seg, rseg, sizeof(*sc->sc_dma), &kva,
            BUS_DMA_NOWAIT)) {
                printf(": can't map dma buffers (%d bytes)\n",
                    sc->sc_dv.dv_xname, sizeof(*sc->sc_dma));
                bus_dmamem_free(sc->sc_dmat, &seg, rseg);
                return;
        }
        if (bus_dmamap_create(sc->sc_dmat, sizeof(*sc->sc_dma), 1,
            sizeof(*sc->sc_dma), 0, BUS_DMA_NOWAIT, &dmamap)) {
                printf(": can't create dma map\n", sc->sc_dv.dv_xname);
                bus_dmamem_unmap(sc->sc_dmat, kva, sizeof(*sc->sc_dma));
                bus_dmamem_free(sc->sc_dmat, &seg, rseg);
                return;
        }
        if (bus_dmamap_load(sc->sc_dmat, dmamap, kva, sizeof(*sc->sc_dma),
            NULL, BUS_DMA_NOWAIT)) {
                printf(": can't load dma map\n", sc->sc_dv.dv_xname);
                bus_dmamap_destroy(sc->sc_dmat, dmamap);
                bus_dmamem_unmap(sc->sc_dmat, kva, sizeof(*sc->sc_dma));
                bus_dmamem_free(sc->sc_dmat, &seg, rseg);
                return;
        }
        sc->sc_dma = (struct hifn_dma *)kva;
d205 1
a205 1
	if (hifn_checkram(sc) != 0)
d208 5
d241 5
a245 1
	printf(", %s\n", intrstr);
d479 70
d557 1
a557 1
hifn_checkram(sc)
d559 1
d561 1
a561 2
	hifn_base_command_t write_command = {(0x3 << 13), 0, 8, 0};
	hifn_base_command_t read_command = {(0x2 << 13), 0, 0, 8};
d568 10
d822 5
a826 5
	         * We always use HMAC mode, assume MAC values are appended to the
	         * source buffer on decodes and we append them to the dest buffer
	         * on encodes, and order auth/encryption engines as needed by
	         * IPSEC
	         */
d831 2
a832 2
	         * Setup to send new MAC key if needed.
	         */
d838 2
a839 2
	         * Set the mac header skip and source count.
	         */
d848 2
a849 2
	         * Set the encryption algorithm bits.
	         */
d858 2
a859 2
	         * Setup to send new encrypt key if needed.
	         */
d865 2
a866 2
	         * Set the encrypt header skip and source count.
	         */
@


1.10
log
@move aeon to hifn7751
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.9 2000/03/15 14:55:51 jason Exp $	*/
d308 5
@


1.9
log
@Bring in bit definitions from the datasheet and allow shared interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: aeon.c,v 1.8 2000/03/10 19:54:24 deraadt Exp $	*/
d4 1
a4 1
 * Invertex AEON driver
d53 2
a54 2
#include <dev/pci/aeonvar.h>
#include <dev/pci/aeonreg.h>
d56 1
a56 1
#undef AEON_DEBUG
d61 2
a62 2
int aeon_probe		__P((struct device *, void *, void *));
void aeon_attach	__P((struct device *, struct device *, void *));
d64 2
a65 2
struct cfattach aeon_ca = {
	sizeof(struct aeon_softc), aeon_probe, aeon_attach,
d68 2
a69 2
struct cfdriver aeon_cd = {
	0, "aeon", DV_DULL
d72 7
a78 7
void	aeon_reset_board	__P((struct aeon_softc *));
int	aeon_enable_crypto	__P((struct aeon_softc *, pcireg_t));
void	aeon_init_dma	__P((struct aeon_softc *));
void	aeon_init_pci_registers __P((struct aeon_softc *));
int	aeon_checkram __P((struct aeon_softc *));
int	aeon_intr		__P((void *));
u_int	aeon_write_command __P((const struct aeon_command_buf_data *,
d80 3
a82 3
int	aeon_build_command __P((const struct aeon_command * cmd,
	    struct aeon_command_buf_data *));
int	aeon_mbuf __P((struct mbuf *, int *np, long *pp, int *lp, int maxp,
d84 1
a84 1
u_int32_t aeon_next_signature __P((u_int a, u_int cnt));
d89 2
a90 2
int aeon_num_devices = 0;
struct aeon_softc *aeon_devices[AEON_MAX_DEVICES];
d93 1
a93 1
aeon_probe(parent, match, aux)
d110 1
a110 1
aeon_attach(parent, self, aux)
d114 1
a114 1
	struct aeon_softc *sc = (struct aeon_softc *)self;
d138 1
a138 1
	if (pci_mem_find(pc, pa->pa_tag, AEON_BAR0, &iobase, &iosize, NULL)) {
d148 1
a148 1
	if (pci_mem_find(pc, pa->pa_tag, AEON_BAR1, &iobase, &iosize, NULL)) {
d157 1
a157 1
#ifdef AEON_DEBUG
d189 1
a189 1
        sc->sc_dma = (struct aeon_dma *)kva;
d192 1
a192 1
	aeon_reset_board(sc);
d194 1
a194 1
	if (aeon_enable_crypto(sc, pa->pa_id) != 0) {
d199 2
a200 2
	aeon_init_dma(sc);
	aeon_init_pci_registers(sc);
d202 1
a202 1
	if (aeon_checkram(sc) != 0)
d210 3
a212 3
	aeon_reset_board(sc);
	aeon_init_dma(sc);
	aeon_init_pci_registers(sc);
d220 1
a220 1
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, aeon_intr, sc,
d230 2
a231 2
	aeon_devices[aeon_num_devices] = sc;
	aeon_num_devices++;
d241 2
a242 2
aeon_reset_board(sc)
	struct aeon_softc *sc;
d248 2
a249 2
	WRITE_REG_1(sc, AEON_1_DMA_CNFG, AEON_DMACNFG_MSTRESET |
	    AEON_DMACNFG_DMARESET | AEON_DMACNFG_MODE);
d261 1
a261 1
	WRITE_REG_1(sc, AEON_1_DMA_CNFG, AEON_DMACNFG_MODE);
d271 2
a272 2
	WRITE_REG_1(sc, AEON_1_DMA_CNFG, AEON_DMACNFG_MSTRESET |
	    AEON_DMACNFG_DMARESET | AEON_DMACNFG_MODE);
d276 1
a276 1
aeon_next_signature(a, cnt)
d317 1
a317 1
 * "aeon_enable_crypto" is called to enable it.  The check is important,
d321 2
a322 2
aeon_enable_crypto(sc, pciid)
	struct aeon_softc *sc;
d337 1
a337 1
#ifdef AEON_DEBUG
d343 2
a344 2
	ramcfg = READ_REG_0(sc, AEON_0_PUCNFG);
	dmacfg = READ_REG_1(sc, AEON_1_DMA_CNFG);
d350 1
a350 1
	WRITE_REG_0(sc, AEON_0_PUCNFG, ramcfg | AEON_PUCNFG_CHIPID);
d352 1
a352 1
	encl = READ_REG_0(sc, AEON_0_PUSTAT);
d359 1
a359 1
#ifdef AEON_DEBUG
d363 2
a364 2
		WRITE_REG_0(sc, AEON_0_PUCNFG, ramcfg);
		WRITE_REG_1(sc, AEON_1_DMA_CNFG, dmacfg);
d369 1
a369 1
#ifdef AEON_DEBUG
d375 4
a378 4
	WRITE_REG_1(sc, AEON_1_DMA_CNFG, AEON_DMACNFG_UNLOCK |
	    AEON_DMACNFG_MSTRESET | AEON_DMACNFG_DMARESET | AEON_DMACNFG_MODE);
	addr = READ_REG_1(sc, AEON_UNLOCK_SECRET1);
	WRITE_REG_1(sc, AEON_UNLOCK_SECRET2, 0);
d381 2
a382 2
		addr = aeon_next_signature(addr, offtbl[i] + 0x101);
		WRITE_REG_1(sc, AEON_UNLOCK_SECRET2, addr);
d387 2
a388 2
	WRITE_REG_0(sc, AEON_0_PUCNFG, ramcfg | AEON_PUCNFG_CHIPID);
	encl = READ_REG_0(sc, AEON_0_PUSTAT);
d390 1
a390 1
#ifdef AEON_DEBUG
d397 2
a398 2
	WRITE_REG_0(sc, AEON_0_PUCNFG, ramcfg);
	WRITE_REG_1(sc, AEON_1_DMA_CNFG, dmacfg);
d420 1
a420 1
 * section of the AEON Software Development reference manual.
d423 2
a424 2
aeon_init_pci_registers(sc)
	struct aeon_softc *sc;
d427 3
a429 3
	WRITE_REG_0(sc, AEON_0_PUCTRL, AEON_PUCTRL_DMAENA);
	WRITE_REG_0(sc, AEON_0_FIFOCNFG, AEON_FIFOCNFG_THRESHOLD);
	WRITE_REG_0(sc, AEON_0_PUIER, AEON_PUIER_DSTOVER);
d432 4
a435 4
	WRITE_REG_1(sc, AEON_1_DMA_CRAR, vtophys(sc->sc_dma->cmdr));
	WRITE_REG_1(sc, AEON_1_DMA_SRAR, vtophys(sc->sc_dma->srcr));
	WRITE_REG_1(sc, AEON_1_DMA_DRAR, vtophys(sc->sc_dma->dstr));
	WRITE_REG_1(sc, AEON_1_DMA_RRAR, vtophys(sc->sc_dma->resr));
d438 4
a441 4
	WRITE_REG_1(sc, AEON_1_DMA_CSR, AEON_DMACSR_D_CTRL_ENA |
	    AEON_DMACSR_R_CTRL_ENA | AEON_DMACSR_S_CTRL_ENA |
	    AEON_DMACSR_C_CTRL_ENA);
	WRITE_REG_1(sc, AEON_1_DMA_IER, AEON_DMAIER_R_DONE);
d448 11
a458 11
	WRITE_REG_0(sc, AEON_0_PUCNFG, AEON_PUCNFG_COMPSING |
	    AEON_PUCNFG_DRFR_128 | AEON_PUCNFG_TCALLPHASES |
	    AEON_PUCNFG_TCDRVTOTEM | AEON_PUCNFG_BUS32 |
	    (sc->sc_drammodel ? AEON_PUCNFG_DRAM : AEON_PUCNFG_SRAM));

	WRITE_REG_0(sc, AEON_0_PUISR, AEON_PUISR_DSTOVER);
	WRITE_REG_1(sc, AEON_1_DMA_CNFG, AEON_DMACNFG_MSTRESET |
	    AEON_DMACNFG_DMARESET | AEON_DMACNFG_MODE |
	    AEON_DMACNFG_LAST |
	    ((AEON_POLL_FREQUENCY << 16 ) & AEON_DMACNFG_POLLFREQ) |
	    ((AEON_POLL_SCALAR << 8) & AEON_DMACNFG_POLLINVAL));
d462 1
a462 1
 * There are both DRAM and SRAM models of the aeon board.
d470 2
a471 2
aeon_checkram(sc)
	struct aeon_softc *sc;
d473 2
a474 2
	aeon_base_command_t write_command = {(0x3 << 13), 0, 8, 0};
	aeon_base_command_t read_command = {(0x2 << 13), 0, 0, 8};
d477 3
a479 3
	struct aeon_dma *dma = sc->sc_dma;
	const u_int32_t masks = AEON_D_VALID | AEON_D_LAST |
	    AEON_D_MASKDONEIRQ;
d481 1
a481 1
#if (AEON_D_RSIZE < 3)
d493 1
a493 1
	*(aeon_base_command_t *) sc->sc_dma->command_bufs[0] = write_command;
d502 1
a502 1
	dma->resr[0].l = AEON_MAX_RESULT | masks;
d505 1
a505 1
	if (dma->resr[0].l & AEON_D_VALID)
d510 1
a510 1
	*(aeon_base_command_t *) sc->sc_dma->command_bufs[1] = read_command;
d517 1
a517 1
	dma->resr[1].l = AEON_MAX_RESULT | masks;
d520 1
a520 1
	if (dma->resr[1].l & AEON_D_VALID)
d530 2
a531 2
aeon_init_dma(sc)
	struct aeon_softc *sc;
d533 1
a533 1
	struct aeon_dma *dma = sc->sc_dma;
d537 1
a537 1
	for (i = 0; i < AEON_D_CMD_RSIZE; i++)
d539 1
a539 1
	for (i = 0; i < AEON_D_RES_RSIZE; i++)
d542 4
a545 4
	dma->cmdr[AEON_D_CMD_RSIZE].p = vtophys(dma->cmdr);
	dma->srcr[AEON_D_SRC_RSIZE].p = vtophys(dma->srcr);
	dma->dstr[AEON_D_DST_RSIZE].p = vtophys(dma->dstr);
	dma->resr[AEON_D_RES_RSIZE].p = vtophys(dma->resr);
d553 1
a553 1
aeon_write_command(const struct aeon_command_buf_data *cmd_data,
d557 5
a561 5
	const aeon_base_command_t *base_cmd = &cmd_data->base_cmd;
	const aeon_mac_command_t *mac_cmd = &cmd_data->mac_cmd;
	const aeon_crypt_command_t *crypt_cmd = &cmd_data->crypt_cmd;
	int     using_mac = base_cmd->masks & AEON_BASE_CMD_MAC;
	int     using_crypt = base_cmd->masks & AEON_BASE_CMD_CRYPT;
d564 2
a565 2
	*((aeon_base_command_t *) command_buf_pos) = *base_cmd;
	command_buf_pos += sizeof(aeon_base_command_t);
d569 2
a570 2
		*((aeon_mac_command_t *) command_buf_pos) = *mac_cmd;
		command_buf_pos += sizeof(aeon_mac_command_t);
d575 2
a576 2
		*((aeon_crypt_command_t *) command_buf_pos) = *crypt_cmd;
		command_buf_pos += sizeof(aeon_crypt_command_t);
d580 3
a582 3
	if (mac_cmd->masks & AEON_MAC_NEW_KEY) {
		bcopy(cmd_data->mac, command_buf_pos, AEON_MAC_KEY_LENGTH);
		command_buf_pos += AEON_MAC_KEY_LENGTH;
d586 4
a589 4
	if (crypt_cmd->masks & AEON_CRYPT_CMD_NEW_KEY) {
		u_int32_t alg = crypt_cmd->masks & AEON_CRYPT_CMD_ALG_MASK;
		u_int32_t key_len = (alg == AEON_CRYPT_CMD_ALG_DES) ?
		AEON_DES_KEY_LENGTH : AEON_3DES_KEY_LENGTH;
d595 3
a597 3
	if (crypt_cmd->masks & AEON_CRYPT_CMD_NEW_IV) {
		bcopy(cmd_data->iv, command_buf_pos, AEON_IV_LENGTH);
		command_buf_pos += AEON_IV_LENGTH;
d601 2
a602 2
	if (!(base_cmd->masks & AEON_BASE_CMD_MAC) &&
	    !(base_cmd->masks & AEON_BASE_CMD_CRYPT)) {
d609 2
a610 2
	if ((command_buf_pos - command_buf) > AEON_MAX_COMMAND)
		printf("aeon: Internal Error -- Command buffer overflow.\n");
d620 2
a621 2
aeon_build_command(const struct aeon_command *cmd,
    struct aeon_command_buf_data * cmd_buf_data)
d623 1
a623 1
#define AEON_COMMAND_CHECKING
d626 3
a628 3
	aeon_base_command_t *base_cmd = &cmd_buf_data->base_cmd;
	aeon_mac_command_t *mac_cmd = &cmd_buf_data->mac_cmd;
	aeon_crypt_command_t *crypt_cmd = &cmd_buf_data->crypt_cmd;
d630 1
a630 1
#ifdef AEON_COMMAND_CHECKING
d634 1
a634 1
	bzero(cmd_buf_data, sizeof(struct aeon_command_buf_data));
d636 3
a638 3
#ifdef AEON_COMMAND_CHECKING
	if (!(!!(flags & AEON_DECODE) ^ !!(flags & AEON_ENCODE))) {
		printf("aeon: encode/decode setting error\n");
d641 2
a642 2
	if ((flags & AEON_CRYPT_DES) && (flags & AEON_CRYPT_3DES)) {
		printf("aeon: Too many crypto algorithms set in command\n");
d645 2
a646 2
	if ((flags & AEON_MAC_SHA1) && (flags & AEON_MAC_MD5)) {
		printf("aeon: Too many MAC algorithms set in command\n");
d656 3
a658 3
	if (AEON_USING_MAC(flags)) {
		mac_length = (flags & AEON_MAC_TRUNC) ? AEON_MAC_TRUNC_LENGTH :
		    ((flags & AEON_MAC_MD5) ? AEON_MD5_LENGTH : AEON_SHA1_LENGTH);
d660 1
a660 1
#ifdef AEON_COMMAND_CHECKING
d671 1
a671 1
		printf("aeon:  command source buffer has no data\n");
d674 1
a674 1
	dest_diff = (flags & AEON_ENCODE) ? mac_length : -mac_length;
d676 1
a676 1
		printf("aeon:  command dest length %u too short -- needed %u\n",
d685 2
a686 2
	if (AEON_USING_MAC(flags))
		base_cmd->masks |= AEON_BASE_CMD_MAC;
d689 2
a690 2
	if (AEON_USING_CRYPT(flags))
		base_cmd->masks |= AEON_BASE_CMD_CRYPT;
d695 2
a696 2
	if (flags & AEON_DECODE)
		base_cmd->masks |= AEON_BASE_CMD_DECODE;
d714 1
a714 1
	if (AEON_USING_MAC(flags)) {
d719 4
a722 4
		mac_cmd->masks |= (flags & AEON_MAC_MD5) ?
		    AEON_MAC_CMD_ALG_MD5 : AEON_MAC_CMD_ALG_SHA1;
		if (flags & AEON_MAC_TRUNC)
			mac_cmd->masks |= AEON_MAC_CMD_TRUNC;
d730 2
a731 2
		mac_cmd->masks |= AEON_MAC_CMD_MODE_HMAC | AEON_MAC_CMD_APPEND |
		    AEON_MAC_CMD_POS_IPSEC;
d736 2
a737 2
		if (flags & AEON_MAC_NEW_KEY) {
			mac_cmd->masks |= AEON_MAC_CMD_NEW_KEY;
d745 1
a745 1
		if (flags & AEON_DECODE)
d749 1
a749 1
	if (AEON_USING_CRYPT(flags)) {
d753 2
a754 2
		crypt_cmd->masks |= (flags & AEON_CRYPT_DES) ?
		    AEON_CRYPT_CMD_ALG_DES : AEON_CRYPT_CMD_ALG_3DES;
d758 1
a758 1
		crypt_cmd->masks |= AEON_CRYPT_CMD_MODE_CBC | AEON_CRYPT_CMD_NEW_IV;
d763 2
a764 2
		if (flags & AEON_CRYPT_CMD_NEW_KEY) {
			crypt_cmd->masks |= AEON_CRYPT_CMD_NEW_KEY;
d772 1
a772 1
		if (flags & AEON_DECODE)
d776 1
a776 1
#ifdef AEON_COMMAND_CHECKING
d778 1
a778 1
			printf("aeon:  Error -- encryption source %u not a multiple of 8!\n",
d788 1
a788 1
	printf("aeon: command parameters"
d804 1
a804 1
aeon_mbuf(m, np, pp, lp, maxp, nicep)
d867 1
a867 1
aeon_crypto(struct aeon_command *cmd)
d871 3
a873 3
	struct	aeon_softc *sc;
	struct	aeon_dma *dma;
	struct	aeon_command_buf_data cmd_buf_data;
d877 1
a877 1
	/* Pick the aeon board to send the data to.  Right now we use a round
d879 2
a880 2
	sc = aeon_devices[current_device++];
	if (current_device == aeon_num_devices)
d885 1
a885 1
		cmd->src_l = aeon_mbuf(cmd->src_m, &cmd->src_npa,
d905 1
a905 1
	cmd->dst_l = aeon_mbuf(cmd->dst_m, &cmd->dst_npa,
d910 2
a911 2
	if (aeon_build_command(cmd, &cmd_buf_data) != 0)
		return AEON_CRYPTO_BAD_INPUT;
d915 1
a915 1
	    READ_REG_1(sc, AEON_1_DMA_CSR), READ_REG_1(sc, AEON_1_DMA_IER),
d925 5
a929 5
	while (dma->cmdu+1 > AEON_D_CMD_RSIZE ||
	    dma->srcu+cmd->src_npa > AEON_D_SRC_RSIZE ||
	    dma->dstu+cmd->dst_npa > AEON_D_DST_RSIZE ||
	    dma->resu+1 > AEON_D_RES_RSIZE) {
		if (cmd->flags & AEON_DMA_FULL_NOBLOCK) {
d931 1
a931 1
			return (AEON_CRYPTO_RINGS_FULL);
d933 1
a933 1
		tsleep((caddr_t) dma, PZERO, "aeonring", 1);
d936 1
a936 1
	if (dma->cmdi == AEON_D_CMD_RSIZE) {
d938 2
a939 2
		dma->cmdr[AEON_D_CMD_RSIZE].l = AEON_D_VALID | AEON_D_LAST |
		    AEON_D_MASKDONEIRQ | AEON_D_JUMP;
d943 1
a943 1
	if (dma->resi == AEON_D_RES_RSIZE) {
d945 2
a946 2
		dma->resr[AEON_D_RES_RSIZE].l = AEON_D_VALID | AEON_D_LAST |
		    AEON_D_MASKDONEIRQ | AEON_D_JUMP;
d950 2
a951 2
	cmdlen = aeon_write_command(&cmd_buf_data, dma->command_bufs[cmdi]);
	dma->aeon_commands[cmdi] = cmd;
d953 2
a954 2
	dma->cmdr[cmdi].l = cmdlen | AEON_D_VALID | AEON_D_LAST |
	    AEON_D_MASKDONEIRQ;
d961 1
a961 1
			last = AEON_D_LAST;
d963 1
a963 1
		if (dma->srci == AEON_D_SRC_RSIZE) {
d965 2
a966 2
			dma->srcr[AEON_D_SRC_RSIZE].l = AEON_D_VALID |
			    AEON_D_MASKDONEIRQ | AEON_D_JUMP;
d970 2
a971 2
		dma->srcr[srci].l = cmd->src_packl[i] | AEON_D_VALID |
		    AEON_D_MASKDONEIRQ | last;
d978 1
a978 1
		if (dma->dsti == AEON_D_DST_RSIZE) {
d980 2
a981 2
			dma->dstr[AEON_D_DST_RSIZE].l = AEON_D_VALID |
			    AEON_D_MASKDONEIRQ | AEON_D_JUMP;
d985 2
a986 2
		dma->dstr[dsti].l = cmd->dst_packl[i] | AEON_D_VALID |
		    AEON_D_MASKDONEIRQ | last;
d994 1
a994 1
	dma->resr[resi].l = AEON_MAX_RESULT | AEON_D_VALID | AEON_D_LAST;
d1003 2
a1004 2
		WRITE_REG_1(sc, AEON_1_DMA_IER,
		    AEON_DMAIER_R_DONE | AEON_DMAIER_C_WAIT);
d1024 1
a1024 1
	    READ_REG_1(sc, AEON_1_DMA_CSR), READ_REG_1(sc, AEON_1_DMA_IER));
d1031 1
a1031 1
aeon_intr(arg)
d1034 2
a1035 2
	struct aeon_softc *sc = arg;
	struct aeon_dma *dma = sc->sc_dma;
d1038 1
a1038 1
	dmacsr = READ_REG_1(sc, AEON_1_DMA_CSR);
d1042 1
a1042 1
	    dmacsr, READ_REG_1(sc, AEON_1_DMA_IER),
d1045 1
a1045 1
	if ((dmacsr & (AEON_DMACSR_C_WAIT|AEON_DMACSR_R_DONE)) == 0)
d1048 1
a1048 1
	if ((dma->slots_in_use == 0) && (dmacsr & AEON_DMACSR_C_WAIT)) {
d1054 1
a1054 1
		WRITE_REG_1(sc, AEON_1_DMA_IER, AEON_DMAIER_R_DONE);
d1056 1
a1056 1
		if (dma->slots_in_use > AEON_D_RSIZE)
d1062 1
a1062 1
			struct aeon_command *cmd = dma->aeon_commands[wake_pos];
d1065 1
a1065 1
			if (dma->resr[wake_pos].l & AEON_D_VALID)
d1068 1
a1068 1
			if (AEON_USING_MAC(cmd->flags) && (cmd->flags & AEON_DECODE)) {
d1072 1
a1072 1
				    AEON_MAC_BAD : 0;
d1083 1
a1083 1
			if (++dma->wakeup_rpos == AEON_D_RSIZE)
d1094 1
a1094 1
	WRITE_REG_1(sc, AEON_1_DMA_CSR, AEON_DMACSR_R_DONE|AEON_DMACSR_C_WAIT);
@


1.8
log
@repair ramcfg whacking code; mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: aeon.c,v 1.7 2000/03/10 08:44:59 mickey Exp $	*/
d138 1
a138 2
	if (pci_mem_find(pc, pa->pa_tag, PCI_BASE_ADDRESS_0, &iobase, &iosize,
	    NULL)){
d148 1
a148 2
	if (pci_mem_find(pc, pa->pa_tag, PCI_BASE_ADDRESS_1, &iobase, &iosize,
	    NULL)){
d248 2
a249 2
	WRITE_REG_1(sc, AEON_DMA_CFG, AEON_DMA_CFG_NOBOARDRESET |
	    AEON_DMA_CFG_NODMARESET | AEON_DMA_CFG_NEED);
d261 1
a261 1
	WRITE_REG_1(sc, AEON_DMA_CFG, AEON_DMA_CFG_NEED);
d271 2
a272 2
	WRITE_REG_1(sc, AEON_DMA_CFG, AEON_DMA_CFG_NOBOARDRESET |
	    AEON_DMA_CFG_NODMARESET | AEON_DMA_CFG_NEED);
d311 1
a311 1
		  0x00, 0x00, 0x00, 0x00, 0x00 }	/* XXX incorrect */
d343 2
a344 2
	ramcfg = READ_REG_0(sc, AEON_RAM_CONFIG);
	dmacfg = READ_REG_1(sc, AEON_DMA_CFG);
d350 1
a350 1
	WRITE_REG_0(sc, AEON_RAM_CONFIG, ramcfg | 0x20);
d352 1
a352 1
	encl = READ_REG_0(sc, AEON_CRYPTLEVEL);
d363 2
a364 2
		WRITE_REG_0(sc, AEON_RAM_CONFIG, ramcfg);
		WRITE_REG_1(sc, AEON_DMA_CFG, dmacfg);
d375 2
a376 1
	WRITE_REG_1(sc, AEON_DMA_CFG, 0x807);
d387 2
a388 2
	WRITE_REG_0(sc, AEON_RAM_CONFIG, ramcfg | 0x20);
	encl = READ_REG_0(sc, AEON_CRYPTLEVEL);
d397 2
a398 2
	WRITE_REG_0(sc, AEON_RAM_CONFIG, ramcfg);
	WRITE_REG_1(sc, AEON_DMA_CFG, dmacfg);
d427 3
a429 3
	WRITE_REG_0(sc, AEON_INIT_1, 0x2);
	WRITE_REG_0(sc, AEON_INIT_2, 0x400);
	WRITE_REG_0(sc, AEON_INIT_3, 0x200);
d432 4
a435 4
	WRITE_REG_1(sc, AEON_CMDR_ADDR, vtophys(sc->sc_dma->cmdr));
	WRITE_REG_1(sc, AEON_SRCR_ADDR, vtophys(sc->sc_dma->srcr));
	WRITE_REG_1(sc, AEON_DSTR_ADDR, vtophys(sc->sc_dma->dstr));
	WRITE_REG_1(sc, AEON_RESR_ADDR, vtophys(sc->sc_dma->resr));
d438 4
a441 2
	WRITE_REG_1(sc, AEON_STATUS, AEON_INIT_STATUS_REG);
	WRITE_REG_1(sc, AEON_IRQEN, AEON_INIT_INTERRUPT_ENABLE_REG);
d448 11
a458 5
	WRITE_REG_0(sc, AEON_RAM_CONFIG, AEON_INIT_RAM_CONFIG_REG |
	    sc->sc_drammodel << 4);

	WRITE_REG_0(sc, AEON_EXPAND, AEON_INIT_EXPAND_REG);
	WRITE_REG_1(sc, AEON_DMA_CFG, AEON_INIT_DMA_CONFIG_REG);
d915 1
a915 1
	    READ_REG_1(sc, AEON_STATUS), READ_REG_1(sc, AEON_IRQEN),
d1003 2
a1004 2
		WRITE_REG_1(sc, AEON_IRQEN,
		    AEON_INTR_ON_RESULT_DONE | AEON_INTR_ON_COMMAND_WAITING);
d1024 1
a1024 1
	    READ_REG_1(sc, AEON_STATUS), READ_REG_1(sc, AEON_IRQEN));
d1036 3
d1042 1
a1042 1
	    READ_REG_1(sc, AEON_STATUS), READ_REG_1(sc, AEON_IRQEN),
d1044 5
a1048 2
	
	if (dma->slots_in_use == 0 && (READ_REG_1(sc, AEON_STATUS) & (1 << 2))) {
d1054 1
a1054 1
		WRITE_REG_1(sc, AEON_IRQEN, AEON_INTR_ON_RESULT_DONE);
d1094 1
a1094 1
	WRITE_REG_1(sc, AEON_STATUS, (1 << 20) | (1 << 2));
@


1.7
log
@unlock cryptography functions on Hi/fn 7751 cryptography card.  Based on reverse engineering of an unlock binary provided by Invertex, for their AEON card, which uses the chip
@
text
@d1 1
a1 1
/*	$OpenBSD: aeon.c,v 1.6 2000/01/10 02:22:50 jason Exp $	*/
d345 3
d352 1
a352 2
	WRITE_REG_0(sc, AEON_RAM_CONFIG,
	    READ_REG_0(sc, AEON_RAM_CONFIG) | (0x1 << 5));
a364 2
#if 0
		/* XXX impossible, this writes garbage to these registers */
a366 1
#endif
a368 7

	ramcfg = READ_REG_0(sc, AEON_RAM_CONFIG);
	dmacfg = READ_REG_1(sc, AEON_DMA_CFG);

	WRITE_REG_0(sc, AEON_RAM_CONFIG, ramcfg | 0x20);

	encl = READ_REG_0(sc, AEON_CRYPTLEVEL);
@


1.6
log
@sync pcidevs and let the aeon driver match the Hi/Fn 7751
(Invertex's aeon used the Hi/Fn 7751 reference design)
@
text
@d1 1
a1 1
/*	$OpenBSD: aeon.c,v 1.5 1999/12/15 00:30:44 jason Exp $	*/
d56 1
a56 1
#define AEON_DEBUG
d73 1
a73 1
int	aeon_enable_crypto	__P((struct aeon_softc *));
d84 1
d159 1
d161 1
d196 2
a197 3
	if (aeon_enable_crypto(sc) != 0) {
		printf("%s: crypto enabling failed\n",
		    sc->sc_dv.dv_xname);
d235 1
a235 1
	printf(": %s\n", intrstr);
d277 40
d323 1
a323 1
aeon_enable_crypto(sc)
d325 1
d327 17
a343 1
	u_int32_t encryption_level;
d352 1
a352 1
	encryption_level = READ_REG_0(sc, AEON_CRYPTLEVEL);
d358 1
a358 1
	if (encryption_level == 0x1020 || encryption_level == 0x1120) {
d363 5
d371 37
a407 6
	/**
	 **
	 **   Rest of unlock procedure removed.
	 **
	 **
	 **/
d409 1
a409 1
	switch(encryption_level) {
d411 1
a411 1
		printf(" no encr/auth");
d414 1
a414 1
		printf(" DES");
d417 1
a417 1
		printf(" FULL");
d420 1
a420 1
		printf(" disabled");
@


1.6.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Invertex AEON / Hi/fn 7751 driver
d53 2
a54 2
#include <dev/pci/hifn7751var.h>
#include <dev/pci/hifn7751reg.h>
d56 1
a56 1
#undef HIFN_DEBUG
d61 2
a62 2
int hifn_probe		__P((struct device *, void *, void *));
void hifn_attach	__P((struct device *, struct device *, void *));
d64 2
a65 2
struct cfattach hifn_ca = {
	sizeof(struct hifn_softc), hifn_probe, hifn_attach,
d68 2
a69 2
struct cfdriver hifn_cd = {
	0, "hifn", DV_DULL
d72 12
a83 16
void	hifn_reset_board	__P((struct hifn_softc *));
int	hifn_enable_crypto	__P((struct hifn_softc *, pcireg_t));
void	hifn_init_dma	__P((struct hifn_softc *));
void	hifn_init_pci_registers __P((struct hifn_softc *));
int	hifn_sramsize __P((struct hifn_softc *));
int	hifn_dramsize __P((struct hifn_softc *));
int	hifn_checkramaddr __P((struct hifn_softc *, int));
void	hifn_sessions __P((struct hifn_softc *));
int	hifn_intr		__P((void *));
u_int	hifn_write_command __P((const struct hifn_command_buf_data *,
    u_int8_t *));
int	hifn_build_command __P((const struct hifn_command * cmd,
    struct hifn_command_buf_data *));
int	hifn_mbuf __P((struct mbuf *, int *np, long *pp, int *lp, int maxp,
    int *nicealign));
u_int32_t hifn_next_signature __P((u_int a, u_int cnt));
d88 3
d92 1
a92 1
hifn_probe(parent, match, aux)
d109 1
a109 1
hifn_attach(parent, self, aux)
d113 1
a113 1
	struct hifn_softc *sc = (struct hifn_softc *)self;
d137 2
a138 1
	if (pci_mem_find(pc, pa->pa_tag, HIFN_BAR0, &iobase, &iosize, NULL)) {
d148 2
a149 1
	if (pci_mem_find(pc, pa->pa_tag, HIFN_BAR1, &iobase, &iosize, NULL)) {
a157 1
#ifdef HIFN_DEBUG
a158 1
#endif
d161 26
a186 4
	if (bus_dmamem_alloc(sc->sc_dmat, sizeof(*sc->sc_dma), PAGE_SIZE, 0,
	    &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
		printf(": can't alloc dma buffer\n");
		return;
d188 1
a188 23
	if (bus_dmamem_map(sc->sc_dmat, &seg, rseg, sizeof(*sc->sc_dma), &kva,
	    BUS_DMA_NOWAIT)) {
		printf(": can't map dma buffers (%d bytes)\n",
		    sizeof(*sc->sc_dma));
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
		return;
	}
	if (bus_dmamap_create(sc->sc_dmat, sizeof(*sc->sc_dma), 1,
	    sizeof(*sc->sc_dma), 0, BUS_DMA_NOWAIT, &dmamap)) {
		printf(": can't create dma map\n");
		bus_dmamem_unmap(sc->sc_dmat, kva, sizeof(*sc->sc_dma));
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
		return;
	}
	if (bus_dmamap_load(sc->sc_dmat, dmamap, kva, sizeof(*sc->sc_dma),
	    NULL, BUS_DMA_NOWAIT)) {
		printf(": can't load dma map\n");
		bus_dmamap_destroy(sc->sc_dmat, dmamap);
		bus_dmamem_unmap(sc->sc_dmat, kva, sizeof(*sc->sc_dma));
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
		return;
	}
	sc->sc_dma = (struct hifn_dma *)kva;
d191 1
a191 1
	hifn_reset_board(sc);
d193 3
a195 2
	if (hifn_enable_crypto(sc, pa->pa_id) != 0) {
		printf("%s: crypto enabling failed\n", sc->sc_dv.dv_xname);
d199 2
a200 2
	hifn_init_dma(sc);
	hifn_init_pci_registers(sc);
d202 1
a202 1
	if (hifn_checkramaddr(sc, 0) != 0)
a204 5
	if (sc->sc_drammodel == 0)
		hifn_sramsize(sc);
	else
		hifn_dramsize(sc);

d210 3
a212 3
	hifn_reset_board(sc);
	hifn_init_dma(sc);
	hifn_init_pci_registers(sc);
d220 1
a220 1
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, hifn_intr, sc,
d230 2
a231 1
	hifn_sessions(sc);
d233 1
a233 3
	printf(", %dk %cram, %d sessions, %s\n",
	    sc->sc_ramsize/1024, sc->sc_drammodel ? 'd' : 's',
	    sc->sc_maxses, intrstr);
d241 2
a242 2
hifn_reset_board(sc)
	struct hifn_softc *sc;
d248 2
a249 2
	WRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |
	    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);
d261 1
a261 1
	WRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MODE);
d271 2
a272 24
	WRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |
	    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);
}

u_int32_t
hifn_next_signature(a, cnt)
	u_int a, cnt;
{
	int i, v;

	for (i = 0; i < cnt; i++) {

		/* get the parity */
		v = a & 0x80080125;
		v ^= v >> 16;
		v ^= v >> 8;
		v ^= v >> 4;
		v ^= v >> 2;
		v ^= v >> 1;

		a = (v & 1) ^ (a << 1);
	}

	return a;
a274 23
struct pci2id {
	u_short		pci_vendor;
	u_short		pci_prod;
	char		card_id[13];
} pci2id[] = {
	{
		PCI_VENDOR_INVERTEX,
		PCI_PRODUCT_INVERTEX_AEON,
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00 }
	}, {
		/*
		 * Other vendors share this PCI ID as well, such as
		 * http://www.powercrypt.com, and obviously they also
		 * use the same key.
		 */
		PCI_VENDOR_HIFN,
		PCI_PRODUCT_HIFN_7751,
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00 }
	},
};

d277 1
a277 1
 * "hifn_enable_crypto" is called to enable it.  The check is important,
d281 2
a282 3
hifn_enable_crypto(sc, pciid)
	struct hifn_softc *sc;
	pcireg_t pciid;
d284 1
a284 20
	u_int32_t dmacfg, ramcfg, encl, addr, i;
	char *offtbl = NULL;

	for (i = 0; i < sizeof(pci2id)/sizeof(pci2id[0]); i++) {
		if (pci2id[i].pci_vendor == PCI_VENDOR(pciid) &&
		    pci2id[i].pci_prod == PCI_PRODUCT(pciid)) {
			offtbl = pci2id[i].card_id;
			break;
		}
	}

	if (offtbl == NULL) {
#ifdef HIFN_DEBUG
		printf("%s: Unknown card!\n", sc->sc_dv.dv_xname);
#endif
		return (1);
	}

	ramcfg = READ_REG_0(sc, HIFN_0_PUCNFG);
	dmacfg = READ_REG_1(sc, HIFN_1_DMA_CNFG);
d290 2
a291 1
	WRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg | HIFN_PUCNFG_CHIPID);
d293 1
a293 1
	encl = READ_REG_0(sc, HIFN_0_PUSTAT) & HIFN_PUSTAT_CHIPENA;
d299 2
a300 2
	if (encl == HIFN_PUSTAT_ENA_1 || encl == HIFN_PUSTAT_ENA_2) {
#ifdef HIFN_DEBUG
a303 2
		WRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg);
		WRITE_REG_1(sc, HIFN_1_DMA_CNFG, dmacfg);
d307 6
a312 15
	if (encl != 0 && encl != HIFN_PUSTAT_ENA_0) {
#ifdef HIFN_DEBUG
		printf("%: Unknown encryption level\n",  sc->sc_dv.dv_xname);
#endif
		return 1;
	}

	WRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_UNLOCK |
	    HIFN_DMACNFG_MSTRESET | HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);
	addr = READ_REG_1(sc, HIFN_UNLOCK_SECRET1);
	WRITE_REG_1(sc, HIFN_UNLOCK_SECRET2, 0);

	for (i = 0; i <= 12; i++) {
		addr = hifn_next_signature(addr, offtbl[i] + 0x101);
		WRITE_REG_1(sc, HIFN_UNLOCK_SECRET2, addr);
d314 3
a316 19
		DELAY(1000);
	}

	WRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg | HIFN_PUCNFG_CHIPID);
	encl = READ_REG_0(sc, HIFN_0_PUSTAT) & HIFN_PUSTAT_CHIPENA;

#ifdef HIFN_DEBUG
	if (encl != HIFN_PUSTAT_ENA_1 && encl != HIFN_PUSTAT_ENA_2)
		printf("Encryption engine is permanently locked until next system reset.");
	else
		printf("Encryption engine enabled successfully!");
#endif

	WRITE_REG_0(sc, HIFN_0_PUCNFG, ramcfg);
	WRITE_REG_1(sc, HIFN_1_DMA_CNFG, dmacfg);

	switch(encl) {
	case HIFN_PUSTAT_ENA_0:
		printf(": no encr/auth");
d318 2
a319 2
	case HIFN_PUSTAT_ENA_1:
		printf(": DES enabled");
d321 2
a322 2
	case HIFN_PUSTAT_ENA_2:
		printf(": fully enabled");
d325 1
a325 1
		printf(": disabled");
d334 1
a334 1
 * section of the HIFN Software Development reference manual.
d337 2
a338 2
hifn_init_pci_registers(sc)
	struct hifn_softc *sc;
d341 3
a343 3
	WRITE_REG_0(sc, HIFN_0_PUCTRL, HIFN_PUCTRL_DMAENA);
	WRITE_REG_0(sc, HIFN_0_FIFOCNFG, HIFN_FIFOCNFG_THRESHOLD);
	WRITE_REG_0(sc, HIFN_0_PUIER, HIFN_PUIER_DSTOVER);
d346 4
a349 4
	WRITE_REG_1(sc, HIFN_1_DMA_CRAR, vtophys(sc->sc_dma->cmdr));
	WRITE_REG_1(sc, HIFN_1_DMA_SRAR, vtophys(sc->sc_dma->srcr));
	WRITE_REG_1(sc, HIFN_1_DMA_DRAR, vtophys(sc->sc_dma->dstr));
	WRITE_REG_1(sc, HIFN_1_DMA_RRAR, vtophys(sc->sc_dma->resr));
d352 2
a353 4
	WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_D_CTRL_ENA |
	    HIFN_DMACSR_R_CTRL_ENA | HIFN_DMACSR_S_CTRL_ENA |
	    HIFN_DMACSR_C_CTRL_ENA);
	WRITE_REG_1(sc, HIFN_1_DMA_IER, HIFN_DMAIER_R_DONE);
d360 2
a361 39
	WRITE_REG_0(sc, HIFN_0_PUCNFG, HIFN_PUCNFG_COMPSING |
	    HIFN_PUCNFG_DRFR_128 | HIFN_PUCNFG_TCALLPHASES |
	    HIFN_PUCNFG_TCDRVTOTEM | HIFN_PUCNFG_BUS32 |
	    (sc->sc_drammodel ? HIFN_PUCNFG_DRAM : HIFN_PUCNFG_SRAM));

	WRITE_REG_0(sc, HIFN_0_PUISR, HIFN_PUISR_DSTOVER);
	WRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |
	    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE |
	    HIFN_DMACNFG_LAST |
	    ((HIFN_POLL_FREQUENCY << 16 ) & HIFN_DMACNFG_POLLFREQ) |
	    ((HIFN_POLL_SCALAR << 8) & HIFN_DMACNFG_POLLINVAL));
}

/*
 * The maximum number of sessions supported by the card
 * is dependent on the amount of context ram, which
 * encryption algorithms are enabled, and how compression
 * is configured.  This should be configured before this
 * routine is called.
 */
void
hifn_sessions(sc)
	struct hifn_softc *sc;
{
	u_int32_t pucnfg;
	int ctxsize;

	pucnfg = READ_REG_0(sc, HIFN_0_PUCNFG);

	if (pucnfg & HIFN_PUCNFG_COMPSING) {
		if (pucnfg & HIFN_PUCNFG_ENCCNFG)
			ctxsize = 128;
		else
			ctxsize = 512;
		sc->sc_maxses = 1 +
		    ((sc->sc_ramsize - 32768) / ctxsize);
	}
	else
		sc->sc_maxses = sc->sc_ramsize / 16384;
d363 2
a364 2
	if (sc->sc_maxses > 2048)
		sc->sc_maxses = 2048;
d368 1
a368 43
 * For sram boards, just write/read memory until it fails.
 */
int
hifn_sramsize(sc)
	struct hifn_softc *sc;
{
	u_int32_t a = 0, end;

	hifn_reset_board(sc);
	hifn_init_dma(sc);
	hifn_init_pci_registers(sc);
	end = 1 << 21;	/* 2MB */
	for (a = 0; a < end; a += 16384) {
		if (hifn_checkramaddr(sc, a) < 0)
			return (0);
		hifn_reset_board(sc);
		hifn_init_dma(sc);
		hifn_init_pci_registers(sc);
		sc->sc_ramsize = a + 16384;
	}
	return (0);
}

/*
 * XXX For dram boards, one should really try all of the
 * HIFN_PUCNFG_DSZ_*'s.  This just assumes that PUCNFG
 * is already set up correctly.
 */
int
hifn_dramsize(sc)
	struct hifn_softc *sc;
{
	u_int32_t cnfg;

	cnfg = READ_REG_0(sc, HIFN_0_PUCNFG) &
	    HIFN_PUCNFG_DRAMMASK;
	sc->sc_ramsize = 1 << ((cnfg >> 13) + 18);
	return (0);
}


/*
 * There are both DRAM and SRAM models of the hifn board.
d376 2
a377 3
hifn_checkramaddr(sc, addr)
	struct hifn_softc *sc;
	int addr;
d379 2
a380 1
	hifn_base_command_t write_command,read_command;
d383 3
a385 13
	struct hifn_dma *dma = sc->sc_dma;
	const u_int32_t masks = HIFN_D_VALID | HIFN_D_LAST |
	    HIFN_D_MASKDONEIRQ;

	write_command.masks = 3 << 13;
	write_command.session_num = addr >> 14;
	write_command.total_source_count = 8;
	write_command.total_dest_count = addr & 0x3fff;;

	read_command.masks = 2 << 13;
	read_command.session_num = addr >> 14;
	read_command.total_source_count = addr & 0x3fff;
	read_command.total_dest_count = 8;
d387 1
a387 1
#if (HIFN_D_RSIZE < 3)
d399 1
a399 1
	*(hifn_base_command_t *) sc->sc_dma->command_bufs[0] = write_command;
d408 1
a408 1
	dma->resr[0].l = HIFN_MAX_RESULT | masks;
d411 1
a411 1
	if (dma->resr[0].l & HIFN_D_VALID)
d416 1
a416 1
	*(hifn_base_command_t *) sc->sc_dma->command_bufs[1] = read_command;
d423 1
a423 1
	dma->resr[1].l = HIFN_MAX_RESULT | masks;
d426 1
a426 1
	if (dma->resr[1].l & HIFN_D_VALID)
d436 2
a437 2
hifn_init_dma(sc)
	struct hifn_softc *sc;
d439 1
a439 1
	struct hifn_dma *dma = sc->sc_dma;
d443 1
a443 1
	for (i = 0; i < HIFN_D_CMD_RSIZE; i++)
d445 1
a445 1
	for (i = 0; i < HIFN_D_RES_RSIZE; i++)
d448 4
a451 4
	dma->cmdr[HIFN_D_CMD_RSIZE].p = vtophys(dma->cmdr);
	dma->srcr[HIFN_D_SRC_RSIZE].p = vtophys(dma->srcr);
	dma->dstr[HIFN_D_DST_RSIZE].p = vtophys(dma->dstr);
	dma->resr[HIFN_D_RES_RSIZE].p = vtophys(dma->resr);
d459 1
a459 1
hifn_write_command(const struct hifn_command_buf_data *cmd_data,
d463 5
a467 5
	const hifn_base_command_t *base_cmd = &cmd_data->base_cmd;
	const hifn_mac_command_t *mac_cmd = &cmd_data->mac_cmd;
	const hifn_crypt_command_t *crypt_cmd = &cmd_data->crypt_cmd;
	int     using_mac = base_cmd->masks & HIFN_BASE_CMD_MAC;
	int     using_crypt = base_cmd->masks & HIFN_BASE_CMD_CRYPT;
d470 2
a471 2
	*((hifn_base_command_t *) command_buf_pos) = *base_cmd;
	command_buf_pos += sizeof(hifn_base_command_t);
d475 2
a476 2
		*((hifn_mac_command_t *) command_buf_pos) = *mac_cmd;
		command_buf_pos += sizeof(hifn_mac_command_t);
d481 2
a482 2
		*((hifn_crypt_command_t *) command_buf_pos) = *crypt_cmd;
		command_buf_pos += sizeof(hifn_crypt_command_t);
d486 3
a488 3
	if (mac_cmd->masks & HIFN_MAC_NEW_KEY) {
		bcopy(cmd_data->mac, command_buf_pos, HIFN_MAC_KEY_LENGTH);
		command_buf_pos += HIFN_MAC_KEY_LENGTH;
d492 4
a495 4
	if (crypt_cmd->masks & HIFN_CRYPT_CMD_NEW_KEY) {
		u_int32_t alg = crypt_cmd->masks & HIFN_CRYPT_CMD_ALG_MASK;
		u_int32_t key_len = (alg == HIFN_CRYPT_CMD_ALG_DES) ?
		HIFN_DES_KEY_LENGTH : HIFN_3DES_KEY_LENGTH;
d501 3
a503 3
	if (crypt_cmd->masks & HIFN_CRYPT_CMD_NEW_IV) {
		bcopy(cmd_data->iv, command_buf_pos, HIFN_IV_LENGTH);
		command_buf_pos += HIFN_IV_LENGTH;
d507 2
a508 2
	if (!(base_cmd->masks & HIFN_BASE_CMD_MAC) &&
	    !(base_cmd->masks & HIFN_BASE_CMD_CRYPT)) {
d515 2
a516 2
	if ((command_buf_pos - command_buf) > HIFN_MAX_COMMAND)
		printf("hifn: Internal Error -- Command buffer overflow.\n");
d526 2
a527 2
hifn_build_command(const struct hifn_command *cmd,
    struct hifn_command_buf_data * cmd_buf_data)
d529 1
a529 1
#define HIFN_COMMAND_CHECKING
d532 3
a534 3
	hifn_base_command_t *base_cmd = &cmd_buf_data->base_cmd;
	hifn_mac_command_t *mac_cmd = &cmd_buf_data->mac_cmd;
	hifn_crypt_command_t *crypt_cmd = &cmd_buf_data->crypt_cmd;
d536 1
a536 1
#ifdef HIFN_COMMAND_CHECKING
d540 1
a540 1
	bzero(cmd_buf_data, sizeof(struct hifn_command_buf_data));
d542 3
a544 3
#ifdef HIFN_COMMAND_CHECKING
	if (!(!!(flags & HIFN_DECODE) ^ !!(flags & HIFN_ENCODE))) {
		printf("hifn: encode/decode setting error\n");
d547 2
a548 2
	if ((flags & HIFN_CRYPT_DES) && (flags & HIFN_CRYPT_3DES)) {
		printf("hifn: Too many crypto algorithms set in command\n");
d551 2
a552 2
	if ((flags & HIFN_MAC_SHA1) && (flags & HIFN_MAC_MD5)) {
		printf("hifn: Too many MAC algorithms set in command\n");
d562 3
a564 3
	if (HIFN_USING_MAC(flags)) {
		mac_length = (flags & HIFN_MAC_TRUNC) ? HIFN_MAC_TRUNC_LENGTH :
		    ((flags & HIFN_MAC_MD5) ? HIFN_MD5_LENGTH : HIFN_SHA1_LENGTH);
d566 1
a566 1
#ifdef HIFN_COMMAND_CHECKING
d577 1
a577 1
		printf("hifn:  command source buffer has no data\n");
d580 1
a580 1
	dest_diff = (flags & HIFN_ENCODE) ? mac_length : -mac_length;
d582 1
a582 1
		printf("hifn:  command dest length %u too short -- needed %u\n",
d591 2
a592 2
	if (HIFN_USING_MAC(flags))
		base_cmd->masks |= HIFN_BASE_CMD_MAC;
d595 2
a596 2
	if (HIFN_USING_CRYPT(flags))
		base_cmd->masks |= HIFN_BASE_CMD_CRYPT;
d601 2
a602 2
	if (flags & HIFN_DECODE)
		base_cmd->masks |= HIFN_BASE_CMD_DECODE;
d620 1
a620 1
	if (HIFN_USING_MAC(flags)) {
d625 4
a628 4
		mac_cmd->masks |= (flags & HIFN_MAC_MD5) ?
		    HIFN_MAC_CMD_ALG_MD5 : HIFN_MAC_CMD_ALG_SHA1;
		if (flags & HIFN_MAC_TRUNC)
			mac_cmd->masks |= HIFN_MAC_CMD_TRUNC;
d631 7
a637 7
		 * We always use HMAC mode, assume MAC values are appended to the
		 * source buffer on decodes and we append them to the dest buffer
		 * on encodes, and order auth/encryption engines as needed by
		 * IPSEC
		 */
		mac_cmd->masks |= HIFN_MAC_CMD_MODE_HMAC | HIFN_MAC_CMD_APPEND |
		    HIFN_MAC_CMD_POS_IPSEC;
d640 4
a643 4
		 * Setup to send new MAC key if needed.
		 */
		if (flags & HIFN_MAC_NEW_KEY) {
			mac_cmd->masks |= HIFN_MAC_CMD_NEW_KEY;
d647 2
a648 2
		 * Set the mac header skip and source count.
		 */
d651 1
a651 1
		if (flags & HIFN_DECODE)
d655 1
a655 1
	if (HIFN_USING_CRYPT(flags)) {
d657 4
a660 4
		 * Set the encryption algorithm bits.
		 */
		crypt_cmd->masks |= (flags & HIFN_CRYPT_DES) ?
		    HIFN_CRYPT_CMD_ALG_DES : HIFN_CRYPT_CMD_ALG_3DES;
d664 1
a664 1
		crypt_cmd->masks |= HIFN_CRYPT_CMD_MODE_CBC | HIFN_CRYPT_CMD_NEW_IV;
d667 4
a670 4
		 * Setup to send new encrypt key if needed.
		 */
		if (flags & HIFN_CRYPT_CMD_NEW_KEY) {
			crypt_cmd->masks |= HIFN_CRYPT_CMD_NEW_KEY;
d674 2
a675 2
		 * Set the encrypt header skip and source count.
		 */
d678 1
a678 1
		if (flags & HIFN_DECODE)
d682 1
a682 1
#ifdef HIFN_COMMAND_CHECKING
d684 1
a684 1
			printf("hifn:  Error -- encryption source %u not a multiple of 8!\n",
d694 1
a694 1
	printf("hifn: command parameters"
d710 1
a710 1
hifn_mbuf(m, np, pp, lp, maxp, nicep)
d773 1
a773 1
hifn_crypto(struct hifn_command *cmd)
d777 3
a779 3
	struct	hifn_softc *sc;
	struct	hifn_dma *dma;
	struct	hifn_command_buf_data cmd_buf_data;
d783 1
a783 1
	/* Pick the hifn board to send the data to.  Right now we use a round
d785 2
a786 2
	sc = hifn_cd.cd_devs[current_device];
	if (++current_device == hifn_cd.cd_ndevs)
d791 1
a791 1
		cmd->src_l = hifn_mbuf(cmd->src_m, &cmd->src_npa,
d811 1
a811 1
	cmd->dst_l = hifn_mbuf(cmd->dst_m, &cmd->dst_npa,
d816 2
a817 2
	if (hifn_build_command(cmd, &cmd_buf_data) != 0)
		return HIFN_CRYPTO_BAD_INPUT;
d821 1
a821 1
	    READ_REG_1(sc, HIFN_1_DMA_CSR), READ_REG_1(sc, HIFN_1_DMA_IER),
d831 5
a835 5
	while (dma->cmdu+1 > HIFN_D_CMD_RSIZE ||
	    dma->srcu+cmd->src_npa > HIFN_D_SRC_RSIZE ||
	    dma->dstu+cmd->dst_npa > HIFN_D_DST_RSIZE ||
	    dma->resu+1 > HIFN_D_RES_RSIZE) {
		if (cmd->flags & HIFN_DMA_FULL_NOBLOCK) {
d837 1
a837 1
			return (HIFN_CRYPTO_RINGS_FULL);
d839 1
a839 1
		tsleep((caddr_t) dma, PZERO, "hifnring", 1);
d842 1
a842 1
	if (dma->cmdi == HIFN_D_CMD_RSIZE) {
d844 2
a845 2
		dma->cmdr[HIFN_D_CMD_RSIZE].l = HIFN_D_VALID | HIFN_D_LAST |
		    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP;
d849 1
a849 1
	if (dma->resi == HIFN_D_RES_RSIZE) {
d851 2
a852 2
		dma->resr[HIFN_D_RES_RSIZE].l = HIFN_D_VALID | HIFN_D_LAST |
		    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP;
d856 2
a857 2
	cmdlen = hifn_write_command(&cmd_buf_data, dma->command_bufs[cmdi]);
	dma->hifn_commands[cmdi] = cmd;
d859 2
a860 2
	dma->cmdr[cmdi].l = cmdlen | HIFN_D_VALID | HIFN_D_LAST |
	    HIFN_D_MASKDONEIRQ;
d867 1
a867 1
			last = HIFN_D_LAST;
d869 1
a869 1
		if (dma->srci == HIFN_D_SRC_RSIZE) {
d871 2
a872 2
			dma->srcr[HIFN_D_SRC_RSIZE].l = HIFN_D_VALID |
			    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP;
d876 2
a877 2
		dma->srcr[srci].l = cmd->src_packl[i] | HIFN_D_VALID |
		    HIFN_D_MASKDONEIRQ | last;
d884 1
a884 1
		if (dma->dsti == HIFN_D_DST_RSIZE) {
d886 2
a887 2
			dma->dstr[HIFN_D_DST_RSIZE].l = HIFN_D_VALID |
			    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP;
d891 2
a892 2
		dma->dstr[dsti].l = cmd->dst_packl[i] | HIFN_D_VALID |
		    HIFN_D_MASKDONEIRQ | last;
d900 1
a900 1
	dma->resr[resi].l = HIFN_MAX_RESULT | HIFN_D_VALID | HIFN_D_LAST;
d909 2
a910 2
		WRITE_REG_1(sc, HIFN_1_DMA_IER,
		    HIFN_DMAIER_R_DONE | HIFN_DMAIER_C_WAIT);
d930 1
a930 1
	    READ_REG_1(sc, HIFN_1_DMA_CSR), READ_REG_1(sc, HIFN_1_DMA_IER));
d937 1
a937 1
hifn_intr(arg)
d940 2
a941 5
	struct hifn_softc *sc = arg;
	struct hifn_dma *dma = sc->sc_dma;
	u_int32_t dmacsr;

	dmacsr = READ_REG_1(sc, HIFN_1_DMA_CSR);
d945 1
a945 1
	    dmacsr, READ_REG_1(sc, HIFN_1_DMA_IER),
d947 2
a948 5

	if ((dmacsr & (HIFN_DMACSR_C_WAIT|HIFN_DMACSR_R_DONE)) == 0)
		return (0);

	if ((dma->slots_in_use == 0) && (dmacsr & HIFN_DMACSR_C_WAIT)) {
d954 1
a954 1
		WRITE_REG_1(sc, HIFN_1_DMA_IER, HIFN_DMAIER_R_DONE);
d956 1
a956 1
		if (dma->slots_in_use > HIFN_D_RSIZE)
d962 1
a962 1
			struct hifn_command *cmd = dma->hifn_commands[wake_pos];
d965 1
a965 1
			if (dma->resr[wake_pos].l & HIFN_D_VALID)
d968 1
a968 1
			if (HIFN_USING_MAC(cmd->flags) && (cmd->flags & HIFN_DECODE)) {
d971 2
a972 2
				cmd->result_flags = (result_buf[8] & 0x2) ?
				    HIFN_MAC_BAD : 0;
d983 1
a983 1
			if (++dma->wakeup_rpos == HIFN_D_RSIZE)
d994 1
a994 1
	WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_R_DONE|HIFN_DMACSR_C_WAIT);
@


1.6.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.57 2001/04/06 16:27:46 jason Exp $	*/
a6 2
 * Copyright (c) 2000 Network Security Technologies, Inc.
 *			http://www.netsec.net
a35 4
/*
 * Driver for the Hi/Fn 7751 encryption processor.
 */

a48 3
#include <crypto/crypto.h>
#include <dev/rndvar.h>

d72 3
a74 3
void	hifn_reset_board __P((struct hifn_softc *));
int	hifn_enable_crypto __P((struct hifn_softc *, pcireg_t));
void	hifn_init_dma __P((struct hifn_softc *));
d78 1
a78 1
void	hifn_ramtype __P((struct hifn_softc *));
d80 8
a87 19
int	hifn_intr __P((void *));
u_int	hifn_write_command __P((struct hifn_command *, u_int8_t *));
u_int32_t hifn_next_signature __P((u_int32_t a, u_int cnt));
int	hifn_newsession __P((u_int32_t *, struct cryptoini *));
int	hifn_freesession __P((u_int64_t));
int	hifn_process __P((struct cryptop *));
void	hifn_callback __P((struct hifn_softc *, struct hifn_command *, u_int8_t *));
int	hifn_crypto __P((struct hifn_softc *, hifn_command_t *));
int	hifn_readramaddr __P((struct hifn_softc *, int, u_int8_t *, int));
int	hifn_writeramaddr __P((struct hifn_softc *, int, u_int8_t *, int));

struct hifn_stats {
	u_int64_t hst_ibytes;
	u_int64_t hst_obytes;
	u_int32_t hst_ipackets;
	u_int32_t hst_opackets;
	u_int32_t hst_invalid;
	u_int32_t hst_nomem;
} hifnstats;
d89 3
a105 3
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_NETSEC &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETSEC_7751)
		return (1);
d119 2
a120 2
	char rbase;
	bus_size_t iosize0, iosize1;
a121 1
	u_int16_t ena;
d128 2
a129 1
	cmd |= PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_MASTER_ENABLE;
d138 6
a143 2
	if (!(cmd & PCI_COMMAND_MASTER_ENABLE)) {
		printf(": failed to enable bus mastering\n");
d146 1
d148 2
a149 3
	if (pci_mapreg_map(pa, HIFN_BAR0, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->sc_st0, &sc->sc_sh0, NULL, &iosize0)) {
		printf(": can't find mem space %d\n", 0);
d152 3
a154 5

	if (pci_mapreg_map(pa, HIFN_BAR1, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->sc_st1, &sc->sc_sh1, NULL, &iosize1)) {
		printf(": can't find mem space %d\n", 1);
		goto fail_io0;
d156 4
d165 1
a165 1
		goto fail_io1;
d169 2
a170 2
		printf(": can't map dma buffers (%lu bytes)\n",
		    (u_long)sizeof(*sc->sc_dma));
d172 1
a172 1
		goto fail_io1;
d179 1
a179 1
		goto fail_io1;
d187 1
a187 1
		goto fail_io1;
d196 1
a196 1
		goto fail_mem;
d202 2
a203 1
	hifn_ramtype(sc);
a210 9
	 * Workaround for NetSec 7751 rev A: half ram size because two
	 * of the address lines were left floating
	 */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_NETSEC &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETSEC_7751 &&
	    PCI_REVISION(pa->pa_class) == 0x61)
		sc->sc_ramsize >>= 1;

	/*
d222 1
a222 1
		goto fail_mem;
d228 1
a228 1
		printf(": couldn't establish interrupt");
d232 1
a232 1
		goto fail_mem;
d237 3
a239 44
	rseg = sc->sc_ramsize / 1024;
	rbase = 'K';
	if (sc->sc_ramsize >= (1024 * 1024)) {
		rbase = 'M';
		rseg /= 1024;
	}
	printf(", %d%cB %cram, %s\n", rseg, rbase,
	    sc->sc_drammodel ? 'd' : 's', intrstr);

	sc->sc_cid = crypto_get_driverid();
	if (sc->sc_cid < 0)
		goto fail_intr;

	WRITE_REG_0(sc, HIFN_0_PUCNFG,
	    READ_REG_0(sc, HIFN_0_PUCNFG) | HIFN_PUCNFG_CHIPID);
	ena = READ_REG_0(sc, HIFN_0_PUSTAT) & HIFN_PUSTAT_CHIPENA;

	switch (ena) {
	case HIFN_PUSTAT_ENA_2:
		crypto_register(sc->sc_cid, CRYPTO_3DES_CBC,
		    hifn_newsession, hifn_freesession, hifn_process);
		/*FALLTHROUGH*/
	case HIFN_PUSTAT_ENA_1:
		crypto_register(sc->sc_cid, CRYPTO_MD5_HMAC,
		    hifn_newsession, hifn_freesession, hifn_process);
		crypto_register(sc->sc_cid, CRYPTO_SHA1_HMAC,
		    NULL, NULL, NULL);
		crypto_register(sc->sc_cid, CRYPTO_DES_CBC,
		    NULL, NULL, NULL);
	}

	return;

fail_intr:
	pci_intr_disestablish(pc, sc->sc_ih);
fail_mem:
	bus_dmamap_unload(sc->sc_dmat, dmamap);
	bus_dmamap_destroy(sc->sc_dmat, dmamap);
	bus_dmamem_unmap(sc->sc_dmat, kva, sizeof(*sc->sc_dma));
	bus_dmamem_free(sc->sc_dmat, &seg, rseg);
fail_io1:
	bus_space_unmap(sc->sc_st1, sc->sc_sh1, iosize1);
fail_io0:
	bus_space_unmap(sc->sc_st0, sc->sc_sh0, iosize0);
a278 5

	/*
	 * Wait another millisecond for the board to un-reset.
	 */
	DELAY(1000);
d283 1
a283 2
	u_int32_t a;
	u_int cnt;
d285 1
a285 2
	int i;
	u_int32_t v;
a308 5
		PCI_VENDOR_NETSEC,
		PCI_PRODUCT_NETSEC_7751,
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00 }
	}, {
d381 1
a381 1
		printf("%s: Unknown encryption level\n", sc->sc_dv.dv_xname);
a387 1
	DELAY(1000);
a388 1
	DELAY(1000);
a389 1
	DELAY(1000);
d411 1
a411 1
	switch (encl) {
d416 1
a416 1
		printf(": DES");
d419 1
a419 1
		printf(": 3DES");
a452 1
	sc->sc_dmaier = HIFN_DMAIER_R_DONE;
d454 5
d466 2
a467 1
	    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE | HIFN_DMACNFG_LAST |
a502 36
void
hifn_ramtype(sc)
	struct hifn_softc *sc;
{
	u_int8_t data[8], dataexpect[8];
	int i;

	hifn_reset_board(sc);
	hifn_init_dma(sc);
	hifn_init_pci_registers(sc);

	for (i = 0; i < sizeof(data); i++)
		data[i] = dataexpect[i] = 0x55;
	if (hifn_writeramaddr(sc, 0, data, 0) < 0)
		return;
	if (hifn_readramaddr(sc, 0, data, 1) < 0)
		return;
	if (bcmp(data, dataexpect, sizeof(data)) != 0) {
		sc->sc_drammodel = 1;
		return;
	}

	hifn_reset_board(sc);
	hifn_init_dma(sc);
	hifn_init_pci_registers(sc);

	for (i = 0; i < sizeof(data); i++)
		data[i] = dataexpect[i] = 0xaa;
	if (hifn_writeramaddr(sc, 0, data, 0) < 0)
		return;
	if (hifn_readramaddr(sc, 0, data, 1) < 0)
		return;
	if (bcmp(data, dataexpect, sizeof(data)) != 0)
		sc->sc_drammodel = 1;
}

d504 1
a504 2
 * For sram boards, just write/read memory until it fails, also check for
 * banking.
a510 4
	u_int8_t data[8], dataexpect[8];

	for (a = 0; a < sizeof(data); a++)
		data[a] = dataexpect[a] = 0x5a;
d515 1
a515 1
	end = 1 << 20;	/* 1MB */
d517 1
a517 5
		if (hifn_writeramaddr(sc, a, data, 0) < 0)
			return (0);
		if (hifn_readramaddr(sc, a, data, 1) < 0)
			return (0);
		if (bcmp(data, dataexpect, sizeof(data)) != 0)
a523 22

	for (a = 0; a < sizeof(data); a++)
		data[a] = dataexpect[a] = 0xa5;
	if (hifn_writeramaddr(sc, 0, data, 0) < 0)
		return (0);

	end = sc->sc_ramsize;
	for (a = 0; a < end; a += 16384) {
		hifn_reset_board(sc);
		hifn_init_dma(sc);
		hifn_init_pci_registers(sc);
		if (hifn_readramaddr(sc, a, data, 0) < 0)
			return (0);
		if (a != 0 && bcmp(data, dataexpect, sizeof(data)) == 0)
			return (0);
		sc->sc_ramsize = a + 16384;
	}

	hifn_reset_board(sc);
	hifn_init_dma(sc);
	hifn_init_pci_registers(sc);

d544 11
a554 2
int
hifn_writeramaddr(sc, addr, data, slot)
d556 1
a556 2
	int addr, slot;
	u_int8_t *data;
d558 3
d562 23
a584 8
	hifn_base_command_t wc;
	const u_int32_t masks = HIFN_D_VALID | HIFN_D_LAST | HIFN_D_MASKDONEIRQ;
	u_int64_t src, dst;

	wc.masks = 3 << 13;
	wc.session_num = addr >> 14;
	wc.total_source_count = 8;
	wc.total_dest_count = addr & 0x3fff;;
d587 2
a588 2
	*(hifn_base_command_t *) sc->sc_dma->command_bufs[slot] = wc;
	bcopy(data, &src, sizeof(src));
d590 2
a591 2
	dma->srcr[slot].p = vtophys(&src);
	dma->dstr[slot].p = vtophys(&dst);
d593 12
a604 13
	dma->cmdr[slot].l = 16 | masks;
	dma->srcr[slot].l = 8 | masks;
	dma->dstr[slot].l = 8 | masks;
	dma->resr[slot].l = HIFN_MAX_RESULT | masks;

	DELAY(3000);	/* let write command execute */
	if (dma->resr[slot].l & HIFN_D_VALID) {
		printf("%s: SRAM/DRAM detection error -- "
		    "result[%d] valid still set\n", sc->sc_dv.dv_xname, slot);
		return (-1);
	}
	return (0);
}
d606 6
a611 24
int
hifn_readramaddr(sc, addr, data, slot)
	struct hifn_softc *sc;
	int addr, slot;
	u_int8_t *data;
{
	struct hifn_dma *dma = sc->sc_dma;
	hifn_base_command_t rc;
	const u_int32_t masks = HIFN_D_VALID | HIFN_D_LAST | HIFN_D_MASKDONEIRQ;
	u_int64_t src, dst;

	rc.masks = 2 << 13;
	rc.session_num = addr >> 14;
	rc.total_source_count = addr & 0x3fff;
	rc.total_dest_count = 8;

	*(hifn_base_command_t *) sc->sc_dma->command_bufs[slot] = rc;

	dma->srcr[slot].p = vtophys(&src);
	dma->dstr[slot].p = vtophys(&dst);
	dma->cmdr[slot].l = 16 | masks;
	dma->srcr[slot].l = 8 | masks;
	dma->dstr[slot].l = 8 | masks;
	dma->resr[slot].l = HIFN_MAX_RESULT | masks;
d614 4
a617 7
	if (dma->resr[slot].l & HIFN_D_VALID) {
		printf("%s: SRAM/DRAM detection error -- "
		    "result[%d] valid still set\n", sc->sc_dv.dv_xname, slot);
		return (-1);
	}
	bcopy(&dst, data, sizeof(dst));
	return (0);
a639 3
	dma->cmdu = dma->srcu = dma->dstu = dma->resu = 0;
	dma->cmdi = dma->srci = dma->dsti = dma->resi = 0;
	dma->cmdk = dma->srck = dma->dstk = dma->resk = 0;
d647 2
a648 3
hifn_write_command(cmd, buf)
	struct hifn_command *cmd;
	u_int8_t *buf;
d650 113
a762 9
	u_int8_t *buf_pos;
	hifn_base_command_t *base_cmd;
	hifn_mac_command_t *mac_cmd;
	hifn_crypt_command_t *cry_cmd;
	int using_mac, using_crypt, len;

	buf_pos = buf;
	using_mac = cmd->base_masks & HIFN_BASE_CMD_MAC;
	using_crypt = cmd->base_masks & HIFN_BASE_CMD_CRYPT;
d764 32
a795 2
	base_cmd = (hifn_base_command_t *)buf_pos;
	base_cmd->masks = cmd->base_masks;
d798 4
a802 1
	buf_pos += sizeof(hifn_base_command_t);
d804 33
a836 3
	if (using_mac) {
		mac_cmd = (hifn_mac_command_t *)buf_pos;
		mac_cmd->masks = cmd->mac_masks;
d838 3
a840 2
		mac_cmd->source_count = cmd->mac_process_len;
		buf_pos += sizeof(hifn_mac_command_t);
d843 34
a876 6
	if (using_crypt) {
		cry_cmd = (hifn_crypt_command_t *)buf_pos;
		cry_cmd->masks = cmd->cry_masks;
		cry_cmd->header_skip = cmd->crypt_header_skip;
		cry_cmd->source_count = cmd->crypt_process_len;
		buf_pos += sizeof(hifn_crypt_command_t);
d878 1
a879 4
	if (using_mac && mac_cmd->masks & HIFN_MAC_CMD_NEW_KEY) {
		bcopy(cmd->mac, buf_pos, HIFN_MAC_KEY_LENGTH);
		buf_pos += HIFN_MAC_KEY_LENGTH;
	}
d881 12
a892 6
	if (using_crypt && cry_cmd->masks & HIFN_CRYPT_CMD_NEW_KEY) {
		len = (cry_cmd->masks & HIFN_CRYPT_CMD_ALG_3DES) ?
		    HIFN_3DES_KEY_LENGTH : HIFN_DES_KEY_LENGTH;
		bcopy(cmd->ck, buf_pos, len);
		buf_pos += len;
	}
d894 2
a895 4
	if (using_crypt && cry_cmd->masks & HIFN_CRYPT_CMD_NEW_IV) {
		bcopy(cmd->iv, buf_pos, HIFN_IV_LENGTH);
		buf_pos += HIFN_IV_LENGTH;
	}
d897 57
a953 3
	if ((base_cmd->masks & (HIFN_BASE_CMD_MAC | HIFN_BASE_CMD_CRYPT)) == 0) {
		bzero(buf_pos, 8);
		buf_pos += 8;
d956 2
a957 1
	return (buf_pos - buf);
d961 1
a961 3
hifn_crypto(sc, cmd)
	struct hifn_softc *sc;
	struct hifn_command *cmd;
d964 4
a967 1
	struct	hifn_dma *dma = sc->sc_dma;
d969 8
a976 1
	int     s, i;
d979 1
a979 1
		cmd->src_l = mbuf2pages(cmd->src_m, &cmd->src_npa,
d985 3
a987 12
		int totlen, len;
		struct mbuf *m, *top, **mp;

		totlen = cmd->dst_l = cmd->src_l;
		if (cmd->src_m->m_flags & M_PKTHDR) {
			len = MHLEN;
			MGETHDR(m, M_DONTWAIT, MT_DATA);
		} else {
			len = MLEN;
			MGET(m, M_DONTWAIT, MT_DATA);
		}
		if (m == NULL)
d989 5
a993 24
		if (len == MHLEN)
			M_DUP_PKTHDR(m, cmd->src_m);
		if (totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
		}
		m->m_len = len;
		top = NULL;
		mp = &top;

		while (totlen > 0) {
			if (top) {
				MGET(m, M_DONTWAIT, MT_DATA);
				if (m == NULL) {
					m_freem(top);
					return (-1);
				}
				len = MLEN;
			}
			if (top && totlen >= MINCLSIZE) {
				MCLGET(m, M_DONTWAIT);
				if (m->m_flags & M_EXT)
					len = MCLBYTES;
a994 4
			m->m_len = len;
			totlen -= len;
			*mp = m;
			mp = &m->m_next;
d996 1
a996 3
		cmd->dst_m = top;
	}
	else
d999 1
a999 1
	cmd->dst_l = mbuf2pages(cmd->dst_m, &cmd->dst_npa,
d1004 3
a1006 1
#ifdef HIFN_DEBUG
a1011 1
#endif
d1013 1
a1013 1
	s = splnet();
d1019 1
a1019 1
	if (dma->cmdu+1 > HIFN_D_CMD_RSIZE ||
d1023 5
a1027 2
		splx(s);
		return (HIFN_CRYPTO_RINGS_FULL);
d1031 1
a1031 1
		dma->cmdi = 0;
d1034 2
a1035 2
	}
	cmdi = dma->cmdi++;
d1038 1
a1038 1
		dma->resi = 0;
d1041 2
a1042 2
	}
	resi = dma->resi++;
d1044 2
a1045 4
	cmdlen = hifn_write_command(cmd, dma->command_bufs[cmdi]);
#ifdef HIFN_DEBUG
	printf("write_command %d (nice %d)\n", cmdlen, nicealign);
#endif
d1049 1
a1049 14
	dma->cmdu++;

	/*
	 * We don't worry about missing an interrupt (which a "command wait"
	 * interrupt salvages us from), unless there is more than one command
	 * in the queue.
	 */
	if (dma->cmdu > 1) {
		WRITE_REG_1(sc, HIFN_1_DMA_IER,
		    HIFN_DMAIER_C_WAIT | HIFN_DMAIER_R_DONE);
		sc->sc_dmaier = HIFN_DMAIER_C_WAIT | HIFN_DMAIER_R_DONE;
	}

	hifnstats.hst_ipackets++;
d1060 1
a1060 1
			    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP | HIFN_D_LAST;
d1063 1
a1063 1
		dma->srcr[srci].p = cmd->src_packp[i];
a1065 1
		hifnstats.hst_ibytes += cmd->src_packl[i];
a1071 3
		if (i == cmd->dst_npa-1)
			last = HIFN_D_LAST;

d1075 1
a1075 1
			    HIFN_D_MASKDONEIRQ | HIFN_D_JUMP | HIFN_D_LAST;
d1078 1
a1078 1
		dma->dstr[dsti].p = cmd->dst_packp[i];
a1087 4
#ifdef HIFN_DEBUG
	printf("load res\n");
#endif
	dma->hifn_commands[resi] = cmd;
d1089 26
a1114 1
	dma->resu++;
a1115 1
#ifdef HIFN_DEBUG
a1118 1
#endif
a1130 1
	int i, u;
d1134 1
a1134 2
#ifdef HIFN_DEBUG
	printf("%s: irq: stat %08x ien %08x u %d/%d/%d/%d\n",
a1137 1
#endif
d1139 1
a1139 2
	/* Nothing in the DMA unit interrupted */
	if ((dmacsr & sc->sc_dmaier) == 0)
d1142 1
a1142 5
	if (dma->resu > HIFN_D_RES_RSIZE)
		printf("%s: Internal Error -- ring overflow\n",
		    sc->sc_dv.dv_xname);

	if ((dmacsr & HIFN_DMACSR_C_WAIT) && (dma->cmdu == 0)) {
d1144 2
a1145 2
		 * If no slots to process and we receive a "waiting on
		 * command" interrupt, we disable the "waiting on command"
d1149 31
a1179 16
		sc->sc_dmaier = HIFN_DMAIER_R_DONE;
	}

	while (dma->resu > 0) {
		struct hifn_command *cmd;
		u_int8_t *macbuf = NULL;

		cmd = dma->hifn_commands[dma->resk];

		/* if still valid, stop processing */
		if (dma->resr[dma->resk].l & HIFN_D_VALID)
			break;

		if (cmd->base_masks & HIFN_BASE_CMD_MAC) {
			macbuf = dma->result_bufs[dma->resk];
			macbuf += 12;
a1180 24

		hifn_callback(sc, cmd, macbuf);
	
		if (++dma->resk == HIFN_D_RES_RSIZE)
			dma->resk = 0;
		dma->resu--;
		hifnstats.hst_opackets++;
	}

	/* clear the rings */

	i = dma->srck; u = dma->srcu;
	while (u != 0 && (dma->srcr[i].l & HIFN_D_VALID) == 0) {
		if (++i == HIFN_D_SRC_RSIZE)
			i = 0;
		u--;
	}
	dma->srck = i; dma->srcu = u;

	i = dma->cmdk; u = dma->cmdu;
	while (u != 0 && (dma->cmdr[i].l & HIFN_D_VALID) == 0) {
		if (++i == HIFN_D_CMD_RSIZE)
			i = 0;
		u--;
a1181 1
	dma->cmdk = i; dma->cmdu = u;
d1184 3
a1186 3
	 * Clear "result done" and "command wait" flags in status register.
	 * If we still have slots to process and we received a "command wait"
	 * interrupt, this will interupt us again.
a1189 322
}

/*
 * Allocate a new 'session' and return an encoded session id.  'sidp'
 * contains our registration id, and should contain an encoded session
 * id on successful allocation.
 */
int
hifn_newsession(sidp, cri)
	u_int32_t *sidp;
	struct cryptoini *cri;
{
	struct cryptoini *c;
	struct hifn_softc *sc = NULL;
	int i, mac = 0, cry = 0;

	if (sidp == NULL || cri == NULL)
		return (EINVAL);

	for (i = 0; i < hifn_cd.cd_ndevs; i++) {
		sc = hifn_cd.cd_devs[i];
		if (sc == NULL)
			break;
		if (sc->sc_cid == (*sidp))
			break;
	}
	if (sc == NULL)
		return (EINVAL);

	for (i = 0; i < sc->sc_maxses; i++)
		if (sc->sc_sessions[i].hs_flags == 0)
			break;
	if (i == sc->sc_maxses)
		return (ENOMEM);

	for (c = cri; c != NULL; c = c->cri_next) {
		if (c->cri_alg == CRYPTO_MD5_HMAC ||
		    c->cri_alg == CRYPTO_SHA1_HMAC) {
			if (mac)
				return (EINVAL);
			mac = 1;
		} else if (c->cri_alg == CRYPTO_DES_CBC ||
		    c->cri_alg == CRYPTO_3DES_CBC) {
			if (cry)
				return (EINVAL);
			cry = 1;
		}
		else
			return (EINVAL);
	}
	if (mac == 0 && cry == 0)
		return (EINVAL);

	*sidp = HIFN_SID(sc->sc_dv.dv_unit, i);
	sc->sc_sessions[i].hs_flags = 1;
	get_random_bytes(sc->sc_sessions[i].hs_iv, HIFN_IV_LENGTH);

	return (0);
}

/*
 * Deallocate a session.
 * XXX this routine should run a zero'd mac/encrypt key into context ram.
 * XXX to blow away any keys already stored there.
 */
int
hifn_freesession(tid)
	u_int64_t tid;
{
	struct hifn_softc *sc;
	int card, session;
	u_int32_t sid = ((u_int32_t) tid) & 0xffffffff;

	card = HIFN_CARD(sid);
	if (card >= hifn_cd.cd_ndevs || hifn_cd.cd_devs[card] == NULL)
		return (EINVAL);

	sc = hifn_cd.cd_devs[card];
	session = HIFN_SESSION(sid);
	if (session >= sc->sc_maxses)
		return (EINVAL);

	bzero(&sc->sc_sessions[session], sizeof(sc->sc_sessions[session]));
	return (0);
}

int
hifn_process(crp)
	struct cryptop *crp;
{
	struct hifn_command *cmd = NULL;
	int card, session, err;
	struct hifn_softc *sc;
	struct cryptodesc *crd1, *crd2, *maccrd, *enccrd;

	if (crp == NULL || crp->crp_callback == NULL) {
		hifnstats.hst_invalid++;
		return (EINVAL);
	}

	card = HIFN_CARD(crp->crp_sid);
	if (card >= hifn_cd.cd_ndevs || hifn_cd.cd_devs[card] == NULL) {
		err = EINVAL;
		goto errout;
	}

	sc = hifn_cd.cd_devs[card];
	session = HIFN_SESSION(crp->crp_sid);
	if (session >= sc->sc_maxses) {
		err = EINVAL;
		goto errout;
	}

	cmd = (struct hifn_command *)malloc(sizeof(struct hifn_command),
	    M_DEVBUF, M_NOWAIT);
	if (cmd == NULL) {
		err = ENOMEM;
		goto errout;
	}
	bzero(cmd, sizeof(struct hifn_command));

	if (crp->crp_flags & CRYPTO_F_IMBUF) {
		cmd->src_m = (struct mbuf *)crp->crp_buf;
		cmd->dst_m = (struct mbuf *)crp->crp_buf;
	} else {
		err = EINVAL;
		goto errout;	/* XXX only handle mbufs right now */
	}

	crd1 = crp->crp_desc;
	if (crd1 == NULL) {
		err = EINVAL;
		goto errout;
	}
	crd2 = crd1->crd_next;

	if (crd2 == NULL) {
		if (crd1->crd_alg == CRYPTO_MD5_HMAC ||
		    crd1->crd_alg == CRYPTO_SHA1_HMAC) {
			maccrd = crd1;
			enccrd = NULL;
		} else if (crd1->crd_alg == CRYPTO_DES_CBC ||
			 crd1->crd_alg == CRYPTO_3DES_CBC) {
			if ((crd1->crd_flags & CRD_F_ENCRYPT) == 0)
				cmd->base_masks |= HIFN_BASE_CMD_DECODE;
			maccrd = NULL;
			enccrd = crd1;
		} else {
			err = EINVAL;
			goto errout;
		}
	} else {
		if ((crd1->crd_alg == CRYPTO_MD5_HMAC ||
		    crd1->crd_alg == CRYPTO_SHA1_HMAC) &&
		    (crd2->crd_alg == CRYPTO_DES_CBC ||
			crd2->crd_alg == CRYPTO_3DES_CBC) &&
		    ((crd2->crd_flags & CRD_F_ENCRYPT) == 0)) {
			cmd->base_masks = HIFN_BASE_CMD_DECODE;
			maccrd = crd1;
			enccrd = crd2;
		} else if ((crd1->crd_alg == CRYPTO_DES_CBC ||
		    crd1->crd_alg == CRYPTO_3DES_CBC) &&
		    (crd2->crd_alg == CRYPTO_MD5_HMAC ||
			crd2->crd_alg == CRYPTO_SHA1_HMAC) &&
		    (crd1->crd_flags & CRD_F_ENCRYPT)) {
			enccrd = crd1;
			maccrd = crd2;
		} else {
			/*
			 * We cannot order the 7751 as requested
			 */
			err = EINVAL;
			goto errout;
		}
	}

	if (enccrd) {
		cmd->base_masks |= HIFN_BASE_CMD_CRYPT;
		cmd->cry_masks |= HIFN_CRYPT_CMD_MODE_CBC |
		    HIFN_CRYPT_CMD_NEW_IV;
		if (enccrd->crd_flags & CRD_F_ENCRYPT) {
			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
				bcopy(enccrd->crd_iv, cmd->iv, HIFN_IV_LENGTH);
			else
				bcopy(sc->sc_sessions[session].hs_iv,
				    cmd->iv, HIFN_IV_LENGTH);

			if ((enccrd->crd_flags & CRD_F_IV_PRESENT) == 0)
				m_copyback(cmd->src_m, enccrd->crd_inject,
				    HIFN_IV_LENGTH, cmd->iv);
		} else {
			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
				bcopy(enccrd->crd_iv, cmd->iv, HIFN_IV_LENGTH);
			else
				m_copydata(cmd->src_m, enccrd->crd_inject,
				    HIFN_IV_LENGTH, cmd->iv);
		}

		if (enccrd->crd_alg == CRYPTO_DES_CBC)
			cmd->cry_masks |= HIFN_CRYPT_CMD_ALG_DES;
		else
			cmd->cry_masks |= HIFN_CRYPT_CMD_ALG_3DES;

		cmd->crypt_header_skip = enccrd->crd_skip;
		cmd->crypt_process_len = enccrd->crd_len;
		cmd->ck = enccrd->crd_key;

		if (sc->sc_sessions[session].hs_flags == 1)
			cmd->cry_masks |= HIFN_CRYPT_CMD_NEW_KEY;
	}

	if (maccrd) {
		cmd->base_masks |= HIFN_BASE_CMD_MAC;
		cmd->mac_masks |= HIFN_MAC_CMD_RESULT |
		    HIFN_MAC_CMD_MODE_HMAC | HIFN_MAC_CMD_RESULT |
		    HIFN_MAC_CMD_POS_IPSEC | HIFN_MAC_CMD_TRUNC;

		if (maccrd->crd_alg == CRYPTO_MD5_HMAC)
			cmd->mac_masks |= HIFN_MAC_CMD_ALG_MD5;
		else
			cmd->mac_masks |= HIFN_MAC_CMD_ALG_SHA1;

		if (sc->sc_sessions[session].hs_flags == 1) {
			cmd->mac_masks |= HIFN_MAC_CMD_NEW_KEY;
			bcopy(maccrd->crd_key, cmd->mac, maccrd->crd_klen >> 3);
			bzero(cmd->mac + (maccrd->crd_klen >> 3),
			    HIFN_MAC_KEY_LENGTH - (maccrd->crd_klen >> 3));
		}

		cmd->mac_header_skip = maccrd->crd_skip;
		cmd->mac_process_len = maccrd->crd_len;
	}

	if (sc->sc_sessions[session].hs_flags == 1)
		sc->sc_sessions[session].hs_flags = 2;

	cmd->private_data = (u_long)crp;
	cmd->session_num = session;
	cmd->softc = sc;

	if (hifn_crypto(sc, cmd) == 0)
		return (0);

	err = ENOMEM;

errout:
	if (cmd != NULL)
		free(cmd, M_DEVBUF);
	if (err == EINVAL)
		hifnstats.hst_invalid++;
	else
		hifnstats.hst_nomem++;
	crp->crp_etype = err;
	crp->crp_callback(crp);
	return (0);
}

void
hifn_callback(sc, cmd, macbuf)
	struct hifn_softc *sc;
	struct hifn_command *cmd;
	u_int8_t *macbuf;
{
	struct hifn_dma *dma = sc->sc_dma;
	struct cryptop *crp = (struct cryptop *)cmd->private_data;
	struct cryptodesc *crd;
	struct mbuf *m;
	int totlen;

	if ((crp->crp_flags & CRYPTO_F_IMBUF) && (cmd->src_m != cmd->dst_m)) {
		m_freem(cmd->src_m);
		crp->crp_buf = (caddr_t)cmd->dst_m;
	}

	if ((m = cmd->dst_m) != NULL) {
		totlen = cmd->src_l;
		hifnstats.hst_obytes += totlen;
		while (m) {
			if (totlen < m->m_len) {
				m->m_len = totlen;
				totlen = 0;
			} else
				totlen -= m->m_len;
			m = m->m_next;
			if (++dma->dstk == HIFN_D_DST_RSIZE)
				dma->dstk = 0;
			dma->dstu--;
		}
	} else {
		hifnstats.hst_obytes += dma->dstr[dma->dstk].l & HIFN_D_LENGTH;
		if (++dma->dstk == HIFN_D_DST_RSIZE)
			dma->dstk = 0;
		dma->dstu--;
	}

	if ((cmd->base_masks & (HIFN_BASE_CMD_CRYPT | HIFN_BASE_CMD_DECODE)) ==
	    HIFN_BASE_CMD_CRYPT) {
		for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
			if (crd->crd_alg != CRYPTO_DES_CBC &&
			    crd->crd_alg != CRYPTO_3DES_CBC)
				continue;
			m_copydata((struct mbuf *)crp->crp_buf,
			    crd->crd_skip + crd->crd_len - HIFN_IV_LENGTH,
			    HIFN_IV_LENGTH,
			    cmd->softc->sc_sessions[cmd->session_num].hs_iv);
			break;
		}
	}

	if (macbuf != NULL) {
		for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
			if (crd->crd_alg != CRYPTO_MD5_HMAC &&
			    crd->crd_alg != CRYPTO_SHA1_HMAC)
				continue;
			m_copyback((struct mbuf *)crp->crp_buf,
			    crd->crd_inject, 12, macbuf);
			break;
		}
	}

	free(cmd, M_DEVBUF);
	crypto_done(crp);
@


1.6.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.6.2.2 2001/05/14 22:25:41 niklas Exp $	*/
d7 1
a7 1
 * Copyright (c) 2000-2001 Network Security Technologies, Inc.
d55 1
a55 1
#include <crypto/cryptodev.h>
d62 1
a63 1
#include <dev/pci/hifn7751var.h>
d96 1
a96 1
int	hifn_crypto __P((struct hifn_softc *, struct hifn_command *, struct cryptop *));
a98 5
int	hifn_dmamap_aligned __P((bus_dmamap_t));
void	hifn_dmamap_load __P((bus_dmamap_t, int *, struct hifn_desc *, int,
    volatile int *));
int	hifn_init_pubrng __P((struct hifn_softc *));
void	hifn_rng __P((void *));
a122 3
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_HIFN &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7951)
		return (1);
d143 2
d164 1
a164 1
	    &sc->sc_st0, &sc->sc_sh0, NULL, &iosize0, 0)) {
d170 1
a170 1
	    &sc->sc_st1, &sc->sc_sh1, NULL, &iosize1, 0)) {
a175 5
	if (bus_dmamap_create(sc->sc_dmat, sizeof(*sc->sc_dma), 1,
	    sizeof(*sc->sc_dma), 0, BUS_DMA_NOWAIT, &sc->sc_dmamap)) {
		printf(": can't create dma map\n");
		goto fail_io1;
	}
d177 1
a177 2
	    sc->sc_dmamap->dm_segs, 1, &sc->sc_dmamap->dm_nsegs,
	    BUS_DMA_NOWAIT)) {
a178 1
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_dmamap);
d180 2
a181 3
	}
	if (bus_dmamem_map(sc->sc_dmat, sc->sc_dmamap->dm_segs,
	    sc->sc_dmamap->dm_nsegs, sizeof(*sc->sc_dma), &kva,
d185 8
a192 3
		bus_dmamem_free(sc->sc_dmat, sc->sc_dmamap->dm_segs,
		    sc->sc_dmamap->dm_nsegs);
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_dmamap);
d195 2
a196 2
	if (bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap, kva,
	    sizeof(*sc->sc_dma), NULL, BUS_DMA_NOWAIT)) {
d198 1
d200 1
a200 3
		bus_dmamem_free(sc->sc_dmat, sc->sc_dmamap->dm_segs,
		    sc->sc_dmamap->dm_nsegs);
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_dmamap);
a212 4
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_HIFN &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7951)
		sc->sc_flags = HIFN_HAS_RNG | HIFN_HAS_PUBLIC;

d278 1
a278 1
		crypto_register(sc->sc_cid, CRYPTO_3DES_CBC, 0, 0,
d282 1
a282 1
		crypto_register(sc->sc_cid, CRYPTO_MD5_HMAC, 0, 0,
d284 1
a284 1
		crypto_register(sc->sc_cid, CRYPTO_SHA1_HMAC, 0, 0,
d286 1
a286 1
		crypto_register(sc->sc_cid, CRYPTO_DES_CBC, 0, 0,
a289 6
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	if (sc->sc_flags & (HIFN_HAS_PUBLIC | HIFN_HAS_RNG))
		hifn_init_pubrng(sc);

d295 2
a296 1
	bus_dmamap_unload(sc->sc_dmat, sc->sc_dmamap);
d298 1
a298 3
	bus_dmamem_free(sc->sc_dmat, sc->sc_dmamap->dm_segs,
	    sc->sc_dmamap->dm_nsegs);
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_dmamap);
a304 60
int
hifn_init_pubrng(sc)
	struct hifn_softc *sc;
{
	int i;

	WRITE_REG_1(sc, HIFN_1_PUB_RESET,
	    READ_REG_1(sc, HIFN_1_PUB_RESET) | HIFN_PUBRST_RESET);

	for (i = 0; i < 100; i++) {
		DELAY(1000);
		if ((READ_REG_1(sc, HIFN_1_PUB_RESET) & HIFN_PUBRST_RESET)
		    == 0)
			break;
	}
	if (i == 100) {
		printf("%s: public key init failed\n", sc->sc_dv.dv_xname);
		return (1);
	}

	/* Enable the rng, if available */
	if (sc->sc_flags & HIFN_HAS_RNG) {
		WRITE_REG_1(sc, HIFN_1_RNG_CONFIG,
		    READ_REG_1(sc, HIFN_1_RNG_CONFIG) | HIFN_RNGCFG_ENA);
		sc->sc_rngfirst = 1;
		if (hz >= 100)
			sc->sc_rnghz = hz / 100;
		else
			sc->sc_rnghz = 1;
		timeout_set(&sc->sc_rngto, hifn_rng, sc);
		timeout_add(&sc->sc_rngto, sc->sc_rnghz);
	}

	/* Enable public key engine, if available */
	if (sc->sc_flags & HIFN_HAS_PUBLIC) {
		WRITE_REG_1(sc, HIFN_1_PUB_IEN, HIFN_PUBIEN_DONE);
		sc->sc_dmaier |= HIFN_DMAIER_PUBDONE;
		WRITE_REG_1(sc, HIFN_1_DMA_IER, sc->sc_dmaier);
	}

	return (0);
}

void
hifn_rng(vsc)
	void *vsc;
{
	struct hifn_softc *sc = vsc;
	u_int32_t num;

	num = READ_REG_1(sc, HIFN_1_RNG_DATA);

	if (sc->sc_rngfirst)
		sc->sc_rngfirst = 0;
	else
		add_true_randomness(num);

	timeout_add(&sc->sc_rngto, sc->sc_rnghz);
}

a378 5
		PCI_VENDOR_HIFN,
		PCI_PRODUCT_HIFN_7951,
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00 }
	}, {
d424 1
a424 1
		printf(": Unknown card!\n");
d446 2
a447 1
		printf(": Strong Crypto already enabled!\n");
d449 3
a451 1
		goto report;
d456 1
a456 1
		printf(": Unknown encryption level\n");
d481 1
a481 1
		printf(": engine is permanently locked until next system reset");
d483 1
a483 1
		printf(": engine enabled successfully!");
a485 1
report:
d521 4
a524 8
	WRITE_REG_1(sc, HIFN_1_DMA_CRAR, sc->sc_dmamap->dm_segs[0].ds_addr +
	    offsetof(struct hifn_dma, cmdr[0]));
	WRITE_REG_1(sc, HIFN_1_DMA_SRAR, sc->sc_dmamap->dm_segs[0].ds_addr +
	    offsetof(struct hifn_dma, srcr[0]));
	WRITE_REG_1(sc, HIFN_1_DMA_DRAR, sc->sc_dmamap->dm_segs[0].ds_addr +
	    offsetof(struct hifn_dma, dstr[0]));
	WRITE_REG_1(sc, HIFN_1_DMA_RRAR, sc->sc_dmamap->dm_segs[0].ds_addr +
	    offsetof(struct hifn_dma, resr[0]));
d530 2
a531 2
	sc->sc_dmaier |= HIFN_DMAIER_R_DONE;
	WRITE_REG_1(sc, HIFN_1_DMA_IER, sc->sc_dmaier);
d693 1
d701 2
a702 2
	*(hifn_base_command_t *)dma->command_bufs[slot] = wc;
	bcopy(data, &dma->test_src, sizeof(dma->test_src));
d704 2
a705 4
	dma->srcr[slot].p = sc->sc_dmamap->dm_segs[0].ds_addr
	    + offsetof(struct hifn_dma, test_src);
	dma->dstr[slot].p = sc->sc_dmamap->dm_segs[0].ds_addr
	    + offsetof(struct hifn_dma, test_dst);
d730 1
d737 1
a737 1
	*(hifn_base_command_t *)dma->command_bufs[slot] = rc;
d739 2
a740 4
	dma->srcr[slot].p = sc->sc_dmamap->dm_segs[0].ds_addr +
	    offsetof(struct hifn_dma, test_src);
	dma->dstr[slot].p =  sc->sc_dmamap->dm_segs[0].ds_addr +
	    offsetof(struct hifn_dma, test_dst);
d752 1
a752 1
	bcopy(&dma->test_dst, data, sizeof(dma->test_dst));
d768 1
a768 2
		dma->cmdr[i].p = sc->sc_dmamap->dm_segs[0].ds_addr +
		    offsetof(struct hifn_dma, command_bufs[i][0]);
d770 1
a770 2
		dma->resr[i].p = sc->sc_dmamap->dm_segs[0].ds_addr +
		    offsetof(struct hifn_dma, result_bufs[i][0]);
d772 4
a775 8
	dma->cmdr[HIFN_D_CMD_RSIZE].p = sc->sc_dmamap->dm_segs[0].ds_addr
	    + offsetof(struct hifn_dma, cmdr[0]);
	dma->srcr[HIFN_D_SRC_RSIZE].p = sc->sc_dmamap->dm_segs[0].ds_addr
	    + offsetof(struct hifn_dma, srcr[0]);
	dma->dstr[HIFN_D_DST_RSIZE].p = sc->sc_dmamap->dm_segs[0].ds_addr
	    + offsetof(struct hifn_dma, dstr[0]);
	dma->resr[HIFN_D_RES_RSIZE].p = sc->sc_dmamap->dm_segs[0].ds_addr
	    + offsetof(struct hifn_dma, resr[0]);
a794 1
	u_int32_t dlen;
d802 3
a804 7
	dlen = cmd->src_map->dm_mapsize;
	base_cmd->total_source_count = dlen & HIFN_BASE_CMD_LENMASK_LO;
	base_cmd->total_dest_count = dlen & HIFN_BASE_CMD_LENMASK_LO;
	dlen >>= 16;
	base_cmd->session_num = cmd->session_num |
	    ((dlen << HIFN_BASE_CMD_SRCLEN_S) & HIFN_BASE_CMD_SRCLEN_M) |
	    ((dlen << HIFN_BASE_CMD_DSTLEN_S) & HIFN_BASE_CMD_DSTLEN_M);
d809 3
a811 7
		dlen = cmd->maccrd->crd_len;
		mac_cmd->source_count = dlen & 0xffff;
		dlen >>= 16;
		mac_cmd->masks = cmd->mac_masks |
		    ((dlen << HIFN_MAC_CMD_SRCLEN_S) & HIFN_MAC_CMD_SRCLEN_M);
		mac_cmd->header_skip = cmd->maccrd->crd_skip;
		mac_cmd->reserved = 0;
d817 3
a819 7
		dlen = cmd->enccrd->crd_len;
		cry_cmd->source_count = dlen & 0xffff;
		dlen >>= 16;
		cry_cmd->masks = cmd->cry_masks |
		    ((dlen << HIFN_CRYPT_CMD_SRCLEN_S) & HIFN_CRYPT_CMD_SRCLEN_M);
		cry_cmd->header_skip = cmd->enccrd->crd_skip;
		cry_cmd->reserved = 0;
a847 40
int
hifn_dmamap_aligned(bus_dmamap_t map)
{
	int i;

	for (i = 0; i < map->dm_nsegs; i++) {
		if ((map->dm_segs[i].ds_addr & 3) ||
		    (map->dm_segs[i].ds_len & 3))
			return (0);
	}
	return (1);
}

void
hifn_dmamap_load(map, idxp, desc, ndesc, usedp)
	bus_dmamap_t map;
	int *idxp, ndesc;
	struct hifn_desc *desc;
	volatile int *usedp;
{
	int i, idx, last = 0;

	for (i = 0; i < map->dm_nsegs; i++) {
		if (i == map->dm_nsegs-1)
			last = HIFN_D_LAST;

		if ((*idxp) == ndesc) {
			idx = 0;
			(*idxp) = 1;
			desc[ndesc].l = HIFN_D_VALID | HIFN_D_JUMP |
			    HIFN_D_MASKDONEIRQ | HIFN_D_LAST;
		} else
			idx = (*idxp)++;
		desc[idx].p = map->dm_segs[i].ds_addr;
		desc[idx].l = map->dm_segs[i].ds_len | HIFN_D_VALID |
		    HIFN_D_MASKDONEIRQ | last;
	}
	(*usedp) += map->dm_nsegs;
}

d849 1
a849 1
hifn_crypto(sc, cmd, crp)
a851 1
	struct cryptop *crp;
d853 1
d855 2
a856 2
	u_int32_t cmdlen;
	int cmdi, resi, s;
d858 4
a861 2
	if (bus_dmamap_create(sc->sc_dmat, HIFN_MAX_DMALEN, MAX_SCATTER,
	    HIFN_MAX_SEGLEN, 0, BUS_DMA_NOWAIT, &cmd->src_map))
d864 32
a895 29
	if (crp->crp_flags & CRYPTO_F_IMBUF) {
		if (bus_dmamap_load_mbuf(sc->sc_dmat, cmd->src_map,
		    cmd->srcu.src_m, BUS_DMA_NOWAIT))
			goto err_srcmap1;
	} else if (crp->crp_flags & CRYPTO_F_IOV) {
		if (bus_dmamap_load_uio(sc->sc_dmat, cmd->src_map,
		    cmd->srcu.src_io, BUS_DMA_NOWAIT))
			goto err_srcmap1;
	} else
		goto err_srcmap1;

	if (hifn_dmamap_aligned(cmd->src_map)) {
		if (crp->crp_flags & CRYPTO_F_IOV)
			cmd->dstu.dst_io = cmd->srcu.src_io;
		else if (crp->crp_flags & CRYPTO_F_IMBUF)
			cmd->dstu.dst_m = cmd->srcu.src_m;
		cmd->dst_map = cmd->src_map;
	} else {
		if (crp->crp_flags & CRYPTO_F_IOV)
			goto err_srcmap;
		if (crp->crp_flags & CRYPTO_F_IMBUF) {
			int totlen, len;
			struct mbuf *m, *top, **mp;

			totlen = cmd->src_map->dm_mapsize;
			if (cmd->srcu.src_m->m_flags & M_PKTHDR) {
				len = MHLEN;
				MGETHDR(m, M_DONTWAIT, MT_DATA);
			} else {
a896 1
				MGET(m, M_DONTWAIT, MT_DATA);
d898 1
a898 5
			if (m == NULL)
				goto err_srcmap;
			if (len == MHLEN)
				M_DUP_PKTHDR(m, cmd->srcu.src_m);
			if (totlen >= MINCLSIZE) {
d904 3
a906 23
			top = NULL;
			mp = &top;

			while (totlen > 0) {
				if (top) {
					MGET(m, M_DONTWAIT, MT_DATA);
					if (m == NULL) {
						m_freem(top);
						goto err_srcmap;
					}
					len = MLEN;
				}
				if (top && totlen >= MINCLSIZE) {
					MCLGET(m, M_DONTWAIT);
					if (m->m_flags & M_EXT)
						len = MCLBYTES;
				}
				m->m_len = len;
				totlen -= len;
				*mp = m;
				mp = &m->m_next;
			}
			cmd->dstu.dst_m = top;
d908 1
d910 2
d913 4
a916 15
	if (cmd->dst_map == NULL) {
		if (bus_dmamap_create(sc->sc_dmat,
		    HIFN_MAX_SEGLEN * MAX_SCATTER, MAX_SCATTER,
		    HIFN_MAX_SEGLEN, 0, BUS_DMA_NOWAIT, &cmd->dst_map))
			goto err_srcmap;
		if (crp->crp_flags & CRYPTO_F_IMBUF) {
			if (bus_dmamap_load_mbuf(sc->sc_dmat, cmd->dst_map,
			    cmd->dstu.dst_m, BUS_DMA_NOWAIT))
				goto err_dstmap1;
		} else if (crp->crp_flags & CRYPTO_F_IOV) {
			if (bus_dmamap_load_uio(sc->sc_dmat, cmd->dst_map,
			    cmd->dstu.dst_io, BUS_DMA_NOWAIT))
				goto err_dstmap1;
		}
	}
d922 2
a923 2
	    dma->cmdu, dma->srcu, dma->dstu, dma->resu,
	    cmd->src_map->dm_nsegs, cmd->dst_map->dm_nsegs);
a925 3
	bus_dmamap_sync(sc->sc_dmat, cmd->src_map, BUS_DMASYNC_PREREAD);
	bus_dmamap_sync(sc->sc_dmat, cmd->dst_map, BUS_DMASYNC_PREWRITE);

a927 3
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

d933 2
a934 2
	    dma->srcu+cmd->src_map->dm_nsegs > HIFN_D_SRC_RSIZE ||
	    dma->dstu+cmd->dst_map->dm_nsegs > HIFN_D_DST_RSIZE ||
a935 2
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
d937 1
a937 1
		goto err_dstmap;
d956 1
a956 2
	printf("write_command %d (nice %d)\n", cmdlen,
	    hifn_dmamap_aligned(cmd->src_map));
d969 3
a971 2
		sc->sc_dmaier |= HIFN_DMAIER_C_WAIT;
		WRITE_REG_1(sc, HIFN_1_DMA_IER, sc->sc_dmaier);
a974 1
	hifnstats.hst_ibytes += cmd->src_map->dm_mapsize;
d976 21
a996 2
	hifn_dmamap_load(cmd->src_map, &dma->srci, dma->srcr,
	    HIFN_D_SRC_RSIZE, &dma->srcu);
d998 14
a1011 2
	hifn_dmamap_load(cmd->dst_map, &dma->dsti, dma->dstr,
	    HIFN_D_DST_RSIZE, &dma->dstu);
a1029 3
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

a1031 12

err_dstmap:
	if (cmd->src_map != cmd->dst_map)
		bus_dmamap_unload(sc->sc_dmat, cmd->dst_map);
err_dstmap1:
	if (cmd->src_map != cmd->dst_map)
		bus_dmamap_destroy(sc->sc_dmat, cmd->dst_map);
err_srcmap:
	bus_dmamap_unload(sc->sc_dmat, cmd->src_map);
err_srcmap1:
	bus_dmamap_destroy(sc->sc_dmat, cmd->src_map);
	return (-1);
d1041 1
a1041 1
	int i, r = 0, u;
d1054 1
a1054 17
		return (r);

	if ((sc->sc_flags & HIFN_HAS_PUBLIC) &&
	    (dmacsr & HIFN_DMACSR_PUBDONE)) {
		r = 1;
		dmacsr &= ~HIFN_DMACSR_PUBDONE;
		WRITE_REG_1(sc, HIFN_1_PUB_STATUS,
		    READ_REG_1(sc, HIFN_1_PUB_STATUS) | HIFN_PUBSTS_DONE);
	}

	if ((dmacsr & sc->sc_dmaier) == 0)
		return (r);

	r = 1;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD); 
d1066 2
a1067 2
		sc->sc_dmaier &= ~HIFN_DMAIER_C_WAIT;
		WRITE_REG_1(sc, HIFN_1_DMA_IER, sc->sc_dmaier);
d1117 1
a1117 3
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD); 
	return (r);
d1164 2
a1165 1
		} else
a1166 1

d1240 2
a1241 5
		cmd->srcu.src_m = (struct mbuf *)crp->crp_buf;
		cmd->dstu.dst_m = (struct mbuf *)crp->crp_buf;
	} else if (crp->crp_flags & CRYPTO_F_IOV) {
		cmd->srcu.src_io = (struct uio *)crp->crp_buf;
		cmd->dstu.dst_io = (struct uio *)crp->crp_buf;
d1244 1
a1244 1
		goto errout;	/* XXX we don't handle contiguous buffers! */
a1294 1
		cmd->enccrd = enccrd;
d1305 3
a1307 10
			if ((enccrd->crd_flags & CRD_F_IV_PRESENT) == 0) {
				if (crp->crp_flags & CRYPTO_F_IMBUF)
					m_copyback(cmd->srcu.src_m,
					    enccrd->crd_inject,
					    HIFN_IV_LENGTH, cmd->iv);
				else if (crp->crp_flags & CRYPTO_F_IOV)
					cuio_copyback(cmd->srcu.src_io,
					    enccrd->crd_inject,
					    HIFN_IV_LENGTH, cmd->iv);
			}
d1311 2
a1312 5
			else if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copydata(cmd->srcu.src_m, enccrd->crd_inject,
				    HIFN_IV_LENGTH, cmd->iv);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copydata(cmd->srcu.src_io, enccrd->crd_inject,
d1321 2
a1329 1
		cmd->maccrd = maccrd;
d1346 3
d1354 1
a1354 1
	cmd->crp = crp;
d1358 1
a1358 1
	if (hifn_crypto(sc, cmd, crp) == 0)
d1382 1
a1382 1
	struct cryptop *crp = cmd->crp;
d1387 4
a1390 2
	bus_dmamap_sync(sc->sc_dmat, cmd->src_map, BUS_DMASYNC_POSTREAD);
	bus_dmamap_sync(sc->sc_dmat, cmd->dst_map, BUS_DMASYNC_POSTWRITE);
d1392 10
a1401 21
	if (crp->crp_flags & CRYPTO_F_IMBUF) {
		if (cmd->srcu.src_m != cmd->dstu.dst_m) {
			m_freem(cmd->srcu.src_m);
			crp->crp_buf = (caddr_t)cmd->dstu.dst_m;
		}
		if ((m = cmd->dstu.dst_m) != NULL) {
			totlen = cmd->src_map->dm_mapsize;
			hifnstats.hst_obytes += totlen;
			while (m) {
				if (totlen < m->m_len) {
					m->m_len = totlen;
					totlen = 0;
				} else
					totlen -= m->m_len;
				m = m->m_next;
				if (++dma->dstk == HIFN_D_DST_RSIZE)
					dma->dstk = 0;
				dma->dstu--;
			}
		} else {
			hifnstats.hst_obytes += dma->dstr[dma->dstk].l & HIFN_D_LENGTH;
d1406 5
a1410 4
	} else if (crp->crp_flags & CRYPTO_F_IOV) {
		hifnstats.hst_obytes += cmd->dst_map->dm_mapsize;
		dma->dstk = (dma->dstk + cmd->dst_map->dm_nsegs) % HIFN_D_DST_RSIZE;
		dma->dstu -= cmd->dst_map->dm_nsegs;
d1419 4
a1422 11
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copydata((struct mbuf *)crp->crp_buf,
				    crd->crd_skip + crd->crd_len - HIFN_IV_LENGTH,
				    HIFN_IV_LENGTH,
				    cmd->softc->sc_sessions[cmd->session_num].hs_iv);
			else if (crp->crp_flags & CRYPTO_F_IOV) {
				cuio_copydata((struct uio *)crp->crp_buf,
				    crd->crd_skip + crd->crd_len - HIFN_IV_LENGTH,
				    HIFN_IV_LENGTH,
				    cmd->softc->sc_sessions[cmd->session_num].hs_iv);
			}
d1432 2
a1433 5
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copyback((struct mbuf *)crp->crp_buf,
				    crd->crd_inject, 12, macbuf);
			else if ((crp->crp_flags & CRYPTO_F_IOV) && crp->crp_mac)
				bcopy((caddr_t)macbuf, crp->crp_mac, 12);
a1437 6
	if (cmd->src_map != cmd->dst_map) {
		bus_dmamap_unload(sc->sc_dmat, cmd->dst_map);
		bus_dmamap_destroy(sc->sc_dmat, cmd->dst_map);
	}
	bus_dmamap_unload(sc->sc_dmat, cmd->src_map);
	bus_dmamap_destroy(sc->sc_dmat, cmd->src_map);
@


1.6.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.6.2.3 2001/07/04 10:42:06 niklas Exp $	*/
d4 1
a4 1
 * Invertex AEON / Hifn 7751 driver
d39 1
a39 1
 * Driver for the Hifn 7751 encryption processor.
d49 4
a54 2
#include <vm/vm.h>

d81 1
a81 3
void	hifn_reset_board __P((struct hifn_softc *, int));
void	hifn_reset_puc __P((struct hifn_softc *));
void	hifn_puc_wait __P((struct hifn_softc *));
d87 1
a87 1
int	hifn_ramtype __P((struct hifn_softc *));
d100 2
a101 2
int	hifn_dmamap_load_src __P((struct hifn_softc *, struct hifn_command *));
int	hifn_dmamap_load_dst __P((struct hifn_softc *, struct hifn_command *));
a103 2
void	hifn_tick __P((void *));
void	hifn_abort __P((struct hifn_softc *));
d105 8
a112 9
struct hifn_stats hifnstats;

#ifdef __HAS_NEW_BUS_DMAMAP_SYNC
#define hifn_bus_dmamap_sync(t, m, o, l, f) \
    bus_dmamap_sync((t), (m), (o), (l), (f))
#else
#define hifn_bus_dmamap_sync(t, m, o, l, f) \
    bus_dmamap_sync((t), (m), (f))
#endif
a153 4
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_HIFN &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7951)
		sc->sc_flags = HIFN_HAS_RNG | HIFN_HAS_PUBLIC;

d216 1
a216 1
	hifn_reset_board(sc, 0);
d222 4
a225 1
	hifn_reset_puc(sc);
d230 1
a230 2
	if (hifn_ramtype(sc))
		goto fail_mem;
d251 1
a251 1
	hifn_reset_board(sc, 0);
d255 2
a256 1
	if (pci_intr_map(pa, &ih)) {
a293 2
		crypto_register(sc->sc_cid, CRYPTO_ARC4, 0, 0,
		    hifn_newsession, hifn_freesession, hifn_process);
a295 4
               crypto_register(sc->sc_cid, CRYPTO_MD5, 0, 0,
                   hifn_newsession, hifn_freesession, hifn_process);
               crypto_register(sc->sc_cid, CRYPTO_SHA1, 0, 0,
                   NULL, NULL, NULL);
d304 1
a304 2
	hifn_bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
	    sc->sc_dmamap->dm_mapsize,
a309 3
	timeout_set(&sc->sc_tickto, hifn_tick, sc);
	timeout_add(&sc->sc_tickto, hz);

a319 5

	/* Turn off DMA polling */
	WRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |
	    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);

a385 27
void
hifn_puc_wait(sc)
	struct hifn_softc *sc;
{
	int i;

	for (i = 5000; i > 0; i--) {
		DELAY(1);
		if (!(READ_REG_0(sc, HIFN_0_PUCTRL) & HIFN_PUCTRL_RESET))
			break;
	}
	if (!i)
		printf("%s: proc unit did not reset\n", sc->sc_dv.dv_xname);
}

/*
 * Reset the processing unit.
 */
void
hifn_reset_puc(sc)
	struct hifn_softc *sc;
{
	/* Reset processing unit */
	WRITE_REG_0(sc, HIFN_0_PUCTRL, HIFN_PUCTRL_DMAENA);
	hifn_puc_wait(sc);
}

d391 1
a391 1
hifn_reset_board(sc, full)
a392 1
	int full;
d407 5
a411 9
	/* Reset the DMA unit */
	if (full) {
		WRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MODE);
		DELAY(1000);
	} else {
		WRITE_REG_1(sc, HIFN_1_DMA_CNFG,
		    HIFN_DMACNFG_MODE | HIFN_DMACNFG_MSTRESET);
		hifn_reset_puc(sc);
	}
d413 4
a416 1
	bzero(sc->sc_dma, sizeof(*sc->sc_dma));
d418 3
a420 1
	/* Bring dma unit out of reset */
d424 4
a427 1
	hifn_puc_wait(sc);
d615 4
a618 18
	WRITE_REG_1(sc, HIFN_1_DMA_CSR,
	    HIFN_DMACSR_D_CTRL_DIS | HIFN_DMACSR_R_CTRL_DIS |
	    HIFN_DMACSR_S_CTRL_DIS | HIFN_DMACSR_C_CTRL_DIS |
	    HIFN_DMACSR_D_ABORT | HIFN_DMACSR_D_DONE | HIFN_DMACSR_D_LAST |
	    HIFN_DMACSR_D_WAIT | HIFN_DMACSR_D_OVER |
	    HIFN_DMACSR_R_ABORT | HIFN_DMACSR_R_DONE | HIFN_DMACSR_R_LAST |
	    HIFN_DMACSR_R_WAIT | HIFN_DMACSR_R_OVER |
	    HIFN_DMACSR_S_ABORT | HIFN_DMACSR_S_DONE | HIFN_DMACSR_S_LAST |
	    HIFN_DMACSR_S_WAIT | HIFN_DMACSR_S_OVER |
	    HIFN_DMACSR_C_ABORT | HIFN_DMACSR_C_DONE | HIFN_DMACSR_C_LAST |
	    HIFN_DMACSR_C_WAIT |
	    HIFN_DMACSR_C_EIRQ |
	    ((sc->sc_flags & HIFN_HAS_PUBLIC) ? HIFN_DMACSR_PUBDONE : 0));
	sc->sc_d_busy = sc->sc_r_busy = sc->sc_s_busy = sc->sc_c_busy = 0;
	sc->sc_dmaier |= HIFN_DMAIER_R_DONE | HIFN_DMAIER_C_ABORT |
	    HIFN_DMAIER_S_OVER | HIFN_DMAIER_D_OVER | HIFN_DMAIER_R_OVER |
	    HIFN_DMAIER_S_ABORT | HIFN_DMAIER_D_ABORT | HIFN_DMAIER_R_ABORT;
	sc->sc_dmaier &= ~HIFN_DMAIER_C_WAIT;
d664 1
a664 1
int
d671 1
a671 1
	hifn_reset_board(sc, 0);
d677 4
a680 4
	if (hifn_writeramaddr(sc, 0, data, 0))
		return (-1);
	if (hifn_readramaddr(sc, 0, data, 1))
		return (-1);
d683 1
a683 1
		return (0);
d686 4
d692 5
a696 5
	if (hifn_writeramaddr(sc, 0, data, 2))
		return (-1);
	if (hifn_readramaddr(sc, 0, data, 3))
		return (-1);
	if (bcmp(data, dataexpect, sizeof(data)) != 0) {
a697 4
		return (0);
	}

	return (0);
d714 1
a714 1
	hifn_reset_board(sc, 0);
d725 1
a725 1
		hifn_reset_board(sc, 0);
d738 1
a738 1
		hifn_reset_board(sc, 0);
d748 1
a748 1
	hifn_reset_board(sc, 0);
a780 1
	int r;
a786 4
	WRITE_REG_1(sc, HIFN_1_DMA_CSR,
	    HIFN_DMACSR_C_CTRL_ENA | HIFN_DMACSR_S_CTRL_ENA |
	    HIFN_DMACSR_D_CTRL_ENA | HIFN_DMACSR_R_CTRL_ENA);

a787 1
	bzero(dma->command_bufs[slot], HIFN_MAX_COMMAND);
d798 2
a799 6
	dma->dstr[slot].l = 4 | masks;
	dma->resr[slot].l = 4 | masks;

	hifn_bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
	    0, sc->sc_dmamap->dm_mapsize,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
a801 5

	hifn_bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
	    0, sc->sc_dmamap->dm_mapsize,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

d803 2
a804 4
		printf("\n%s: writeramaddr error -- "
		    "result[%d](addr %d) valid still set\n",
		    sc->sc_dv.dv_xname, slot, addr);
		r = -1;
d806 2
a807 8
	} else
	    r = 0;

	WRITE_REG_1(sc, HIFN_1_DMA_CSR,
	    HIFN_DMACSR_C_CTRL_DIS | HIFN_DMACSR_S_CTRL_DIS |
	    HIFN_DMACSR_D_CTRL_DIS | HIFN_DMACSR_R_CTRL_DIS);

	return (r);
a818 1
	int r;
a824 5
	WRITE_REG_1(sc, HIFN_1_DMA_CSR,
	    HIFN_DMACSR_C_CTRL_ENA | HIFN_DMACSR_S_CTRL_ENA |
	    HIFN_DMACSR_D_CTRL_ENA | HIFN_DMACSR_R_CTRL_ENA);

	bzero(dma->command_bufs[slot], HIFN_MAX_COMMAND);
a828 1
	dma->test_src = 0;
d831 1
a831 2
	dma->test_dst = 0;
	dma->cmdr[slot].l = 8 | masks;
d836 1
a836 10
	hifn_bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
	    0, sc->sc_dmamap->dm_mapsize,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	DELAY(3000);	/* let read command execute */

	hifn_bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
	    0, sc->sc_dmamap->dm_mapsize,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

d838 3
a840 7
		printf("\n%s: readramaddr error -- "
		    "result[%d](addr %d) valid still set\n",
		    sc->sc_dv.dv_xname, slot, addr);
		r = -1;
	} else {
		r = 0;
		bcopy(&dma->test_dst, data, sizeof(dma->test_dst));
d842 2
a843 6

	WRITE_REG_1(sc, HIFN_1_DMA_CSR,
	    HIFN_DMACSR_C_CTRL_DIS | HIFN_DMACSR_S_CTRL_DIS |
	    HIFN_DMACSR_D_CTRL_DIS | HIFN_DMACSR_R_CTRL_DIS);

	return (r);
d891 1
a891 1
	u_int32_t dlen, slen;
d899 2
a900 7
	slen = cmd->src_map->dm_mapsize;
	if (cmd->sloplen)
		dlen = cmd->dst_map->dm_mapsize - cmd->sloplen +
		    sizeof(u_int32_t);
	else
		dlen = cmd->dst_map->dm_mapsize;
	base_cmd->total_source_count = slen & HIFN_BASE_CMD_LENMASK_LO;
a902 1
	slen >>= 16;
d904 1
a904 1
	    ((slen << HIFN_BASE_CMD_SRCLEN_S) & HIFN_BASE_CMD_SRCLEN_M) |
d938 4
a941 23
		switch (cry_cmd->masks & HIFN_CRYPT_CMD_ALG_MASK) {
		case HIFN_CRYPT_CMD_ALG_3DES:
			bcopy(cmd->ck, buf_pos, HIFN_3DES_KEY_LENGTH);
			buf_pos += HIFN_3DES_KEY_LENGTH;
			break;
		case HIFN_CRYPT_CMD_ALG_DES:
			bcopy(cmd->ck, buf_pos, HIFN_DES_KEY_LENGTH);
			buf_pos += cmd->cklen;
			break;
		case HIFN_CRYPT_CMD_ALG_RC4:
			len = 256;
			do {
				int clen;

				clen = MIN(cmd->cklen, len);
				bcopy(cmd->ck, buf_pos, clen);
				len -= clen;
				buf_pos += clen;
			} while (len > 0);
			bzero(buf_pos, 4);
			buf_pos += 4;
			break;
		}
d958 1
a958 2
hifn_dmamap_aligned(map)
	bus_dmamap_t map;
d963 1
a963 3
		if (map->dm_segs[i].ds_addr & 3)
			return (0);
		if ((i != (map->dm_nsegs - 1)) &&
d970 6
a975 4
int
hifn_dmamap_load_dst(sc, cmd)
	struct hifn_softc *sc;
	struct hifn_command *cmd;
d977 1
a977 22
	struct hifn_dma *dma = sc->sc_dma;
	bus_dmamap_t map = cmd->dst_map;
	u_int32_t p, l;
	int idx, used = 0, i;

	idx = dma->dsti;
	for (i = 0; i < map->dm_nsegs - 1; i++) {
		dma->dstr[idx].p = map->dm_segs[i].ds_addr;
		dma->dstr[idx].l = HIFN_D_VALID | HIFN_D_MASKDONEIRQ |
		    map->dm_segs[i].ds_len;
		HIFN_DSTR_SYNC(sc, idx,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
		used++;

		if (++idx == HIFN_D_DST_RSIZE) {
			dma->dstr[idx].l = HIFN_D_VALID | HIFN_D_JUMP |
			    HIFN_D_MASKDONEIRQ;
			HIFN_DSTR_SYNC(sc, idx,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			idx = 0;
		}
	}
a978 56
	if (cmd->sloplen == 0) {
		p = map->dm_segs[i].ds_addr;
		l = HIFN_D_VALID | HIFN_D_MASKDONEIRQ | HIFN_D_LAST |
		    map->dm_segs[i].ds_len;
	} else {
		p = sc->sc_dmamap->dm_segs[0].ds_addr +
		    offsetof(struct hifn_dma, slop[cmd->slopidx]);
		l = HIFN_D_VALID | HIFN_D_MASKDONEIRQ | HIFN_D_LAST |
		    sizeof(u_int32_t);

		if ((map->dm_segs[i].ds_len - cmd->sloplen) != 0) {
			dma->dstr[idx].p = map->dm_segs[i].ds_addr;
			dma->dstr[idx].l = HIFN_D_VALID | HIFN_D_MASKDONEIRQ |
			    (map->dm_segs[i].ds_len - cmd->sloplen);
			HIFN_DSTR_SYNC(sc, idx,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			used++;

			if (++idx == HIFN_D_DST_RSIZE) {
				dma->dstr[idx].l = HIFN_D_VALID |
				    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ;
				HIFN_DSTR_SYNC(sc, idx,
				    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
				idx = 0;
			}
		}
	}
	dma->dstr[idx].p = p;
	dma->dstr[idx].l = l;
	HIFN_DSTR_SYNC(sc, idx, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	used++;

	if (++idx == HIFN_D_DST_RSIZE) {
		dma->dstr[idx].l = HIFN_D_VALID | HIFN_D_JUMP |
		    HIFN_D_MASKDONEIRQ;
		HIFN_DSTR_SYNC(sc, idx,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
		idx = 0;
	}

	dma->dsti = idx;
	dma->dstu += used;
	return (idx);
}

int
hifn_dmamap_load_src(sc, cmd)
	struct hifn_softc *sc;
	struct hifn_command *cmd;
{
	struct hifn_dma *dma = sc->sc_dma;
	bus_dmamap_t map = cmd->src_map;
	int idx, i;
	u_int32_t last = 0;

	idx = dma->srci;
d980 1
a980 1
		if (i == map->dm_nsegs - 1)
d983 9
a991 2
		dma->srcr[idx].p = map->dm_segs[i].ds_addr;
		dma->srcr[idx].l = map->dm_segs[i].ds_len | HIFN_D_VALID |
a992 10
		HIFN_SRCR_SYNC(sc, idx,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

		if (++idx == HIFN_D_SRC_RSIZE) {
			dma->srcr[idx].l = HIFN_D_VALID | HIFN_D_JUMP |
			    HIFN_D_MASKDONEIRQ;
			HIFN_SRCR_SYNC(sc, HIFN_D_SRC_RSIZE,
			    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
			idx = 0;
		}
d994 1
a994 3
	dma->srci = idx;
	dma->srcu += map->dm_nsegs;
	return (idx);
d1005 1
a1005 1
	int cmdi, resi, s, err = 0;
d1009 1
a1009 1
		return (ENOMEM);
d1013 1
a1013 2
		    cmd->srcu.src_m, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
a1014 1
		}
d1017 1
a1017 2
		    cmd->srcu.src_io, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
d1019 1
a1019 3
		}
	} else {
		err = EINVAL;
a1020 1
	}
a1022 1
		cmd->sloplen = cmd->src_map->dm_mapsize & 3;
d1029 1
a1029 2
		if (crp->crp_flags & CRYPTO_F_IOV) {
			err = EINVAL;
d1031 1
a1031 1
		} else if (crp->crp_flags & CRYPTO_F_IMBUF) {
d1033 1
a1033 1
			struct mbuf *m, *m0, *mlast;
d1038 1
a1038 1
				MGETHDR(m0, M_DONTWAIT, MT_DATA);
d1041 1
a1041 1
				MGET(m0, M_DONTWAIT, MT_DATA);
d1043 1
a1043 2
			if (m0 == NULL) {
				err = ENOMEM;
a1044 1
			}
d1046 1
a1046 1
				M_DUP_PKTHDR(m0, cmd->srcu.src_m);
d1048 2
a1049 2
				MCLGET(m0, M_DONTWAIT);
				if (m0->m_flags & M_EXT)
d1052 3
a1054 3
			totlen -= len;
			m0->m_pkthdr.len = m0->m_len = len;
			mlast = m0;
d1057 7
a1063 5
				MGET(m, M_DONTWAIT, MT_DATA);
				if (m == NULL) {
					err = ENOMEM;
					m_freem(m0);
					goto err_srcmap;
d1065 1
a1065 2
				len = MLEN;
				if (totlen >= MINCLSIZE) {
a1069 1

a1070 1
				m0->m_pkthdr.len += len;
d1072 2
a1073 3

				mlast->m_next = m;
				mlast = m;
d1075 1
a1075 1
			cmd->dstu.dst_m = m0;
d1082 1
a1082 2
		    HIFN_MAX_SEGLEN, 0, BUS_DMA_NOWAIT, &cmd->dst_map)) {
			err = ENOMEM;
a1083 1
		}
d1086 1
a1086 2
			    cmd->dstu.dst_m, BUS_DMA_NOWAIT)) {
				err = ENOMEM;
a1087 1
			}
d1090 1
a1090 2
			    cmd->dstu.dst_io, BUS_DMA_NOWAIT)) {
				err = ENOMEM;
a1091 1
			}
d1103 2
a1104 10
	if (cmd->src_map == cmd->dst_map)
		hifn_bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
		    0, cmd->src_map->dm_mapsize,
		    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
	else {
		hifn_bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
		    0, cmd->src_map->dm_mapsize, BUS_DMASYNC_PREWRITE);
		hifn_bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
		    0, cmd->dst_map->dm_mapsize, BUS_DMASYNC_PREREAD);
	}
d1108 3
d1115 6
a1120 2
	if ((dma->cmdu + 1) > HIFN_D_CMD_RSIZE ||
	    (dma->resu + 1) > HIFN_D_RES_RSIZE) {
a1121 7
		err = ENOMEM;
		goto err_dstmap;
	}
	if ((dma->srcu + cmd->src_map->dm_nsegs) > HIFN_D_SRC_RSIZE ||
	    (dma->dstu + cmd->dst_map->dm_nsegs + 1) > HIFN_D_DST_RSIZE) {
		splx(s);
		err = ENOMEM;
d1127 2
a1128 4
		dma->cmdr[HIFN_D_CMD_RSIZE].l = HIFN_D_VALID | HIFN_D_JUMP |
		    HIFN_D_MASKDONEIRQ;
		HIFN_CMDR_SYNC(sc, HIFN_D_CMD_RSIZE,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
d1131 8
a1143 2
	HIFN_CMD_SYNC(sc, cmdi, BUS_DMASYNC_PREWRITE);

a1146 2
	HIFN_CMDR_SYNC(sc, cmdi,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
a1147 4
	if (sc->sc_c_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_C_CTRL_ENA);
		sc->sc_c_busy = 1;
	}
d1162 5
a1166 5
	hifn_dmamap_load_src(sc, cmd);
	if (sc->sc_s_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_S_CTRL_ENA);
		sc->sc_s_busy = 1;
	}
a1174 8
	if (dma->resi == HIFN_D_RES_RSIZE) {
		dma->resi = 0;
		dma->resr[HIFN_D_RES_RSIZE].l = HIFN_D_VALID | HIFN_D_JUMP |
		    HIFN_D_MASKDONEIRQ;
		HIFN_RESR_SYNC(sc, HIFN_D_RES_RSIZE,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	}
	resi = dma->resi++;
a1175 1
	HIFN_RES_SYNC(sc, resi, BUS_DMASYNC_PREREAD);
a1176 2
	HIFN_RESR_SYNC(sc, resi,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
a1177 14
	if (sc->sc_r_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_R_CTRL_ENA);
		sc->sc_r_busy = 1;
	}

	if (cmd->sloplen)
		cmd->slopidx = resi;

	hifn_dmamap_load_dst(sc, cmd);

	if (sc->sc_d_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_D_CTRL_ENA);
		sc->sc_d_busy = 1;
	}
d1185 3
a1187 1
	sc->sc_active = 5;
d1189 1
a1189 1
	return (err);		/* success */
d1201 1
a1201 38
	return (err);
}

void
hifn_tick(vsc)
	void *vsc;
{
	struct hifn_softc *sc = vsc;
	int s;

	s = splnet();
	if (sc->sc_active == 0) {
		struct hifn_dma *dma = sc->sc_dma;
		u_int32_t r = 0;

		if (dma->cmdu == 0 && sc->sc_c_busy) {
			sc->sc_c_busy = 0;
			r |= HIFN_DMACSR_C_CTRL_DIS;
		}
		if (dma->srcu == 0 && sc->sc_s_busy) {
			sc->sc_s_busy = 0;
			r |= HIFN_DMACSR_S_CTRL_DIS;
		}
		if (dma->dstu == 0 && sc->sc_d_busy) {
			sc->sc_d_busy = 0;
			r |= HIFN_DMACSR_D_CTRL_DIS;
		}
		if (dma->resu == 0 && sc->sc_r_busy) {
			sc->sc_r_busy = 0;
			r |= HIFN_DMACSR_R_CTRL_DIS;
		}
		if (r)
			WRITE_REG_1(sc, HIFN_1_DMA_CSR, r);
	}
	else
		sc->sc_active--;
	splx(s);
	timeout_add(&sc->sc_tickto, hz);
d1210 2
a1211 2
	u_int32_t dmacsr, restart;
	int i, u;
d1224 1
a1224 3
		return (0);

	WRITE_REG_1(sc, HIFN_1_DMA_CSR, dmacsr & sc->sc_dmaier);
d1227 3
a1229 1
	    (dmacsr & HIFN_DMACSR_PUBDONE))
d1232 6
d1239 6
a1244 12
	restart = dmacsr & (HIFN_DMACSR_S_OVER | HIFN_DMACSR_D_OVER |
	    HIFN_DMACSR_R_OVER);
	if (restart)
		printf("%s: overrun %x\n", sc->sc_dv.dv_xname, dmacsr);

	restart = dmacsr & (HIFN_DMACSR_C_ABORT | HIFN_DMACSR_S_ABORT |
	    HIFN_DMACSR_D_ABORT | HIFN_DMACSR_R_ABORT);
	if (restart) {
		hifnstats.hst_abort++;
		hifn_abort(sc);
		return (1);
	}
d1256 8
a1263 8
	/* clear the rings */
	i = dma->resk; u = dma->resu;
	while (u != 0) {
		HIFN_RESR_SYNC(sc, i,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		if (dma->resr[i].l & HIFN_D_VALID) {
			HIFN_RESR_SYNC(sc, i,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
a1264 13
		}

		if (i != HIFN_D_RES_RSIZE) {
			struct hifn_command *cmd;
			u_int8_t *macbuf = NULL;

			HIFN_RES_SYNC(sc, i, BUS_DMASYNC_POSTREAD);
			cmd = dma->hifn_commands[i];

			if (cmd->base_masks & HIFN_BASE_CMD_MAC) {
				macbuf = dma->result_bufs[i];
				macbuf += 12;
			}
d1266 3
a1268 3
			hifn_callback(sc, cmd, macbuf);
			hifnstats.hst_opackets++;
			u--;
d1271 6
a1276 2
		if (++i == (HIFN_D_RES_RSIZE + 1))
			i = 0;
d1278 2
a1279 1
	dma->resk = i; dma->resu = u;
d1282 2
a1283 9
	while (u != 0) {
		HIFN_SRCR_SYNC(sc, i,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		if (dma->srcr[i].l & HIFN_D_VALID) {
			HIFN_SRCR_SYNC(sc, i,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			break;
		}
		if (++i == (HIFN_D_SRC_RSIZE + 1))
d1285 1
a1285 2
		else
			u--;
d1290 2
a1291 13
	while (u != 0) {
		HIFN_CMDR_SYNC(sc, i,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		if (dma->cmdr[i].l & HIFN_D_VALID) {
			HIFN_CMDR_SYNC(sc, i,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			break;
		}
		if (i != HIFN_D_CMD_RSIZE) {
			u--;
			HIFN_CMD_SYNC(sc, i, BUS_DMASYNC_POSTWRITE);
		}
		if (++i == (HIFN_D_CMD_RSIZE + 1))
d1293 1
d1297 9
a1305 1
	return (1);
d1336 1
a1336 1
		if (sc->sc_sessions[i].hs_state == HS_STATE_FREE)
d1342 2
a1343 5
		switch (c->cri_alg) {
		case CRYPTO_MD5:
		case CRYPTO_SHA1:
		case CRYPTO_MD5_HMAC:
		case CRYPTO_SHA1_HMAC:
d1347 2
a1348 7
			break;
		case CRYPTO_DES_CBC:
		case CRYPTO_3DES_CBC:
			get_random_bytes(sc->sc_sessions[i].hs_iv,
			    HIFN_IV_LENGTH);
			/*FALLTHROUGH*/
		case CRYPTO_ARC4:
d1352 1
a1352 2
			break;
		default:
d1354 1
a1354 1
		}
d1360 2
a1361 1
	sc->sc_sessions[i].hs_state = HS_STATE_USED;
d1447 1
a1447 3
		    crd1->crd_alg == CRYPTO_SHA1_HMAC ||
		    crd1->crd_alg == CRYPTO_SHA1 ||
		    crd1->crd_alg == CRYPTO_MD5) {
d1451 1
a1451 2
		    crd1->crd_alg == CRYPTO_3DES_CBC ||
		    crd1->crd_alg == CRYPTO_ARC4) {
d1462 1
a1462 3
                     crd1->crd_alg == CRYPTO_SHA1_HMAC ||
                     crd1->crd_alg == CRYPTO_MD5 ||
                     crd1->crd_alg == CRYPTO_SHA1) &&
d1464 1
a1464 2
		     crd2->crd_alg == CRYPTO_3DES_CBC ||
		     crd2->crd_alg == CRYPTO_ARC4) &&
d1470 1
a1470 2
		     crd1->crd_alg == CRYPTO_ARC4 ||
		     crd1->crd_alg == CRYPTO_3DES_CBC) &&
d1472 1
a1472 3
                     crd2->crd_alg == CRYPTO_SHA1_HMAC ||
                     crd2->crd_alg == CRYPTO_MD5 ||
                     crd2->crd_alg == CRYPTO_SHA1) &&
d1488 12
a1499 48
		switch (enccrd->crd_alg) {
		case CRYPTO_ARC4:
			cmd->cry_masks |= HIFN_CRYPT_CMD_ALG_RC4;
			if ((enccrd->crd_flags & CRD_F_ENCRYPT)
			    != sc->sc_sessions[session].hs_prev_op)
				sc->sc_sessions[session].hs_state =
				    HS_STATE_USED;
			break;
		case CRYPTO_DES_CBC:
			cmd->cry_masks |= HIFN_CRYPT_CMD_ALG_DES |
			    HIFN_CRYPT_CMD_MODE_CBC |
			    HIFN_CRYPT_CMD_NEW_IV;
			break;
		case CRYPTO_3DES_CBC:
			cmd->cry_masks |= HIFN_CRYPT_CMD_ALG_3DES |
			    HIFN_CRYPT_CMD_MODE_CBC |
			    HIFN_CRYPT_CMD_NEW_IV;
			break;
		default:
			err = EINVAL;
			goto errout;
		}
		if (enccrd->crd_alg != CRYPTO_ARC4) {
			if (enccrd->crd_flags & CRD_F_ENCRYPT) {
				if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
					bcopy(enccrd->crd_iv, cmd->iv,
					    HIFN_IV_LENGTH);
				else
					bcopy(sc->sc_sessions[session].hs_iv,
					    cmd->iv, HIFN_IV_LENGTH);

				if ((enccrd->crd_flags & CRD_F_IV_PRESENT)
				    == 0) {
					if (crp->crp_flags & CRYPTO_F_IMBUF)
						m_copyback(cmd->srcu.src_m,
						    enccrd->crd_inject,
						    HIFN_IV_LENGTH, cmd->iv);
					else if (crp->crp_flags & CRYPTO_F_IOV)
						cuio_copyback(cmd->srcu.src_io,
						    enccrd->crd_inject,
						    HIFN_IV_LENGTH, cmd->iv);
				}
			} else {
				if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
					bcopy(enccrd->crd_iv, cmd->iv,
					    HIFN_IV_LENGTH);
				else if (crp->crp_flags & CRYPTO_F_IMBUF)
					m_copydata(cmd->srcu.src_m,
d1503 1
a1503 1
					cuio_copydata(cmd->srcu.src_io,
d1507 9
d1518 5
a1523 1
		cmd->cklen = enccrd->crd_klen >> 3;
d1525 1
a1525 1
		if (sc->sc_sessions[session].hs_state == HS_STATE_USED)
d1532 3
d1536 4
a1539 22
		switch (maccrd->crd_alg) {
		case CRYPTO_MD5:
			cmd->mac_masks |= HIFN_MAC_CMD_ALG_MD5 |
			    HIFN_MAC_CMD_RESULT | HIFN_MAC_CMD_MODE_HASH |
			    HIFN_MAC_CMD_POS_IPSEC;
                       break;
		case CRYPTO_MD5_HMAC:
			cmd->mac_masks |= HIFN_MAC_CMD_ALG_MD5 |
			    HIFN_MAC_CMD_RESULT | HIFN_MAC_CMD_MODE_HMAC |
			    HIFN_MAC_CMD_POS_IPSEC | HIFN_MAC_CMD_TRUNC;
			break;
		case CRYPTO_SHA1:
			cmd->mac_masks |= HIFN_MAC_CMD_ALG_SHA1 |
			    HIFN_MAC_CMD_RESULT | HIFN_MAC_CMD_MODE_HASH |
			    HIFN_MAC_CMD_POS_IPSEC;
			break;
		case CRYPTO_SHA1_HMAC:
			cmd->mac_masks |= HIFN_MAC_CMD_ALG_SHA1 |
			    HIFN_MAC_CMD_RESULT | HIFN_MAC_CMD_MODE_HMAC |
			    HIFN_MAC_CMD_POS_IPSEC | HIFN_MAC_CMD_TRUNC;
			break;
		}
d1541 1
a1541 3
		if ((maccrd->crd_alg == CRYPTO_SHA1_HMAC ||
		     maccrd->crd_alg == CRYPTO_MD5_HMAC) &&
		    sc->sc_sessions[session].hs_state == HS_STATE_USED) {
d1549 3
d1556 4
a1559 9
	err = hifn_crypto(sc, cmd, crp);
	if (!err) {
		if(enccrd)
			sc->sc_sessions[session].hs_prev_op=enccrd->crd_flags
			    & CRD_F_ENCRYPT;
		if (sc->sc_sessions[session].hs_state == HS_STATE_USED)
			sc->sc_sessions[session].hs_state = HS_STATE_KEY;
		return 0;
	}
a1573 80
hifn_abort(sc)
	struct hifn_softc *sc;
{
	struct hifn_dma *dma = sc->sc_dma;
	struct hifn_command *cmd;
	struct cryptop *crp;
	int i, u;

	i = dma->resk; u = dma->resu;
	while (u != 0) {
		cmd = dma->hifn_commands[i];
		crp = cmd->crp;

		if ((dma->resr[i].l & HIFN_D_VALID) == 0) {
			/* Salvage what we can. */
			u_int8_t *macbuf;

			if (cmd->base_masks & HIFN_BASE_CMD_MAC) {
				macbuf = dma->result_bufs[i];
				macbuf += 12;
			} else
				macbuf = NULL;
			hifnstats.hst_opackets++;
			hifn_callback(sc, cmd, macbuf);
		} else {
			if (cmd->src_map == cmd->dst_map)
				hifn_bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
				    0, cmd->src_map->dm_mapsize,
				    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
			else {
				hifn_bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
				    0, cmd->src_map->dm_mapsize,
				    BUS_DMASYNC_POSTWRITE);
				hifn_bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
				    0, cmd->dst_map->dm_mapsize,
				    BUS_DMASYNC_POSTREAD);
			}

			if (cmd->srcu.src_m != cmd->dstu.dst_m) {
				m_freem(cmd->srcu.src_m);
				crp->crp_buf = (caddr_t)cmd->dstu.dst_m;
			}

			/* non-shared buffers cannot be restarted */
			if (cmd->src_map != cmd->dst_map) {
				/*
				 * XXX should be EAGAIN, delayed until
				 * after the reset.
				 */
				crp->crp_etype = ENOMEM;
				bus_dmamap_unload(sc->sc_dmat, cmd->dst_map);
				bus_dmamap_destroy(sc->sc_dmat, cmd->dst_map);
			} else
				crp->crp_etype = ENOMEM;

			bus_dmamap_unload(sc->sc_dmat, cmd->src_map);
			bus_dmamap_destroy(sc->sc_dmat, cmd->src_map);

			free(cmd, M_DEVBUF);
			if (crp->crp_etype != EAGAIN)
				crypto_done(crp);
		}

		if (++i == HIFN_D_RES_RSIZE)
			i = 0;
		u--;
	}
	dma->resk = i; dma->resu = u;

	/* Force upload of key next time */
	for (i = 0; i < sc->sc_maxses; i++)
		if (sc->sc_sessions[i].hs_state == HS_STATE_KEY)
			sc->sc_sessions[i].hs_state = HS_STATE_USED;
	
	hifn_reset_board(sc, 1);
	hifn_init_dma(sc);
	hifn_init_pci_registers(sc);
}

void
d1583 1
a1583 1
	int totlen, i, u;
d1585 2
a1586 10
	if (cmd->src_map == cmd->dst_map)
		hifn_bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
		    0, cmd->src_map->dm_mapsize,
		    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
	else {
		hifn_bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
		    0, cmd->src_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		hifn_bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
		    0, cmd->dst_map->dm_mapsize, BUS_DMASYNC_POSTREAD);
	}
d1592 2
d1595 2
a1596 1
			for (m = cmd->dstu.dst_m; m != NULL; m = m->m_next) {
d1602 4
d1607 5
a1611 2
			cmd->dstu.dst_m->m_pkthdr.len =
			    cmd->srcu.src_m->m_pkthdr.len;
d1613 4
a1618 32
	if (cmd->sloplen != 0) {
		if (crp->crp_flags & CRYPTO_F_IMBUF)
			m_copyback((struct mbuf *)crp->crp_buf,
			    cmd->src_map->dm_mapsize - cmd->sloplen,
			    cmd->sloplen, (caddr_t)&dma->slop[cmd->slopidx]);
		else if (crp->crp_flags & CRYPTO_F_IOV)
			cuio_copyback((struct uio *)crp->crp_buf,
			    cmd->src_map->dm_mapsize - cmd->sloplen,
			    cmd->sloplen, (caddr_t)&dma->slop[cmd->slopidx]);
	}

	i = dma->dstk; u = dma->dstu;
	while (u != 0) {
		hifn_bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    offsetof(struct hifn_dma, dstr[i]), sizeof(struct hifn_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		if (dma->dstr[i].l & HIFN_D_VALID) {
			hifn_bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
			    offsetof(struct hifn_dma, dstr[i]),
			    sizeof(struct hifn_desc),
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			break;
		}
		if (++i == (HIFN_D_DST_RSIZE + 1))
			i = 0;
		else
			u--;
	}
	dma->dstk = i; dma->dstu = u;

	hifnstats.hst_obytes += cmd->dst_map->dm_mapsize;

d1642 2
a1643 10
                       int len;

                       if (crd->crd_alg == CRYPTO_MD5)
                               len = 16;
                       else if (crd->crd_alg == CRYPTO_SHA1)
                               len = 20;
                       else if (crd->crd_alg == CRYPTO_MD5_HMAC ||
                           crd->crd_alg == CRYPTO_SHA1_HMAC)
                               len = 12;
                       else
a1644 1

d1647 1
a1647 1
                                   crd->crd_inject, len, macbuf);
d1649 1
a1649 1
				bcopy((caddr_t)macbuf, crp->crp_mac, len);
@


1.6.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 1
a51 1
#include <uvm/uvm_extern.h>
d109 8
a156 3
	sc->sc_pci_pc = pa->pa_pc;
	sc->sc_pci_tag = pa->pa_tag;

a187 4
	cmd = pci_conf_read(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT);
	cmd &= 0xffff0000;
	pci_conf_write(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT, cmd);

d195 2
a196 1
	    sc->sc_dmasegs, 1, &sc->sc_dmansegs, BUS_DMA_NOWAIT)) {
d201 3
a203 2
	if (bus_dmamem_map(sc->sc_dmat, sc->sc_dmasegs, sc->sc_dmansegs,
	    sizeof(*sc->sc_dma), &kva, BUS_DMA_NOWAIT)) {
d206 2
a207 1
		bus_dmamem_free(sc->sc_dmat, sc->sc_dmasegs, sc->sc_dmansegs);
d215 2
a216 1
		bus_dmamem_free(sc->sc_dmat, sc->sc_dmasegs, sc->sc_dmansegs);
d286 1
a286 1
	sc->sc_cid = crypto_get_driverid(0);
d314 1
a314 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
d331 2
a332 1
	bus_dmamem_free(sc->sc_dmat, sc->sc_dmasegs, sc->sc_dmansegs);
a440 2
	u_int32_t reg;

a470 4

	reg = pci_conf_read(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT);
	reg &= 0xffff0000;
	pci_conf_write(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT, reg);
d840 4
a843 4
	wc.masks = htole16(3 << 13);
	wc.session_num = htole16(addr >> 14);
	wc.total_source_count = htole16(8);
	wc.total_dest_count = htole16(addr & 0x3fff);
d854 9
a862 9
	dma->srcr[slot].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr
	    + offsetof(struct hifn_dma, test_src));
	dma->dstr[slot].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr
	    + offsetof(struct hifn_dma, test_dst));

	dma->cmdr[slot].l = htole32(16 | masks);
	dma->srcr[slot].l = htole32(8 | masks);
	dma->dstr[slot].l = htole32(4 | masks);
	dma->resr[slot].l = htole32(4 | masks);
d864 1
a864 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
d870 1
a870 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
d874 1
a874 1
	if (letoh32(dma->resr[slot].l) & HIFN_D_VALID) {
d881 1
a881 1
		r = 0;
d901 4
a904 4
	rc.masks = htole16(2 << 13);
	rc.session_num = htole16(addr >> 14);
	rc.total_source_count = htole16(addr & 0x3fff);
	rc.total_dest_count = htole16(8);
d913 2
a914 2
	dma->srcr[slot].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
	    offsetof(struct hifn_dma, test_src));
d916 2
a917 2
	dma->dstr[slot].p =  htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
	    offsetof(struct hifn_dma, test_dst));
d919 4
a922 4
	dma->cmdr[slot].l = htole32(8 | masks);
	dma->srcr[slot].l = htole32(8 | masks);
	dma->dstr[slot].l = htole32(8 | masks);
	dma->resr[slot].l = htole32(HIFN_MAX_RESULT | masks);
d924 1
a924 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
d930 1
a930 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
d934 1
a934 1
	if (letoh32(dma->resr[slot].l) & HIFN_D_VALID) {
a958 1
	u_int32_t reg;
a960 4
	reg = pci_conf_read(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT);
	reg &= 0xffff0000;
	pci_conf_write(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_RETRY_TIMEOUT, reg);

d963 2
a964 2
		dma->cmdr[i].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
		    offsetof(struct hifn_dma, command_bufs[i][0]));
d966 2
a967 15
		dma->resr[i].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
		    offsetof(struct hifn_dma, result_bufs[i][0]));

	dma->cmdr[HIFN_D_CMD_RSIZE].p =
	    htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
		offsetof(struct hifn_dma, cmdr[0]));
	dma->srcr[HIFN_D_SRC_RSIZE].p =
	    htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
		offsetof(struct hifn_dma, srcr[0]));
	dma->dstr[HIFN_D_DST_RSIZE].p =
	    htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
		offsetof(struct hifn_dma, dstr[0]));
	dma->resr[HIFN_D_RES_RSIZE].p =
	    htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
		offsetof(struct hifn_dma, resr[0]));
d969 8
d1335 1
a1335 1
		bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
d1339 1
a1339 1
		bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
d1341 1
a1341 1
		bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
a1541 1
		printf("%s: abort, resetting.\n");
d1978 1
a1978 1
				bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
d1982 1
a1982 1
				bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
d1985 1
a1985 1
				bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
d2044 1
a2044 1
		bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
d2048 1
a2048 1
		bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
d2050 1
a2050 1
		bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
d2084 1
a2084 1
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
d2088 1
a2088 1
			bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
@


1.6.2.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hifn7751.c,v 1.6.2.5 2001/11/13 21:10:01 niklas Exp $	*/
d297 4
a300 4
		crypto_register(sc->sc_cid, CRYPTO_MD5, 0, 0,
		    hifn_newsession, hifn_freesession, hifn_process);
		crypto_register(sc->sc_cid, CRYPTO_SHA1, 0, 0,
		    hifn_newsession, hifn_freesession, hifn_process);
d304 1
a304 1
		    hifn_newsession, hifn_freesession, hifn_process);
d306 1
a306 1
		    hifn_newsession, hifn_freesession, hifn_process);
d874 1
a874 1
	if (dma->resr[slot].l & htole32(HIFN_D_VALID)) {
d934 1
a934 1
	if (dma->resr[slot].l & htole32(HIFN_D_VALID)) {
d1013 1
a1013 1
	base_cmd->masks = htole16(cmd->base_masks);
d1020 2
a1021 2
	base_cmd->total_source_count = htole16(slen & HIFN_BASE_CMD_LENMASK_LO);
	base_cmd->total_dest_count = htole16(dlen & HIFN_BASE_CMD_LENMASK_LO);
d1024 1
a1024 1
	base_cmd->session_num = htole16(cmd->session_num |
d1026 1
a1026 1
	    ((dlen << HIFN_BASE_CMD_DSTLEN_S) & HIFN_BASE_CMD_DSTLEN_M));
d1032 1
a1032 1
		mac_cmd->source_count = htole16(dlen & 0xffff);
d1034 3
a1036 3
		mac_cmd->masks = htole16(cmd->mac_masks |
		    ((dlen << HIFN_MAC_CMD_SRCLEN_S) & HIFN_MAC_CMD_SRCLEN_M));
		mac_cmd->header_skip = htole16(cmd->maccrd->crd_skip);
d1044 1
a1044 1
		cry_cmd->source_count = htole16(dlen & 0xffff);
d1046 3
a1048 3
		cry_cmd->masks = htole16(cmd->cry_masks |
		    ((dlen << HIFN_CRYPT_CMD_SRCLEN_S) & HIFN_CRYPT_CMD_SRCLEN_M));
		cry_cmd->header_skip = htole16(cmd->enccrd->crd_skip);
d1053 1
a1053 1
	if (using_mac && cmd->mac_masks & HIFN_MAC_CMD_NEW_KEY) {
d1058 2
a1059 2
	if (using_crypt && cmd->cry_masks & HIFN_CRYPT_CMD_NEW_KEY) {
		switch (cmd->cry_masks & HIFN_CRYPT_CMD_ALG_MASK) {
d1084 1
a1084 1
	if (using_crypt && cmd->cry_masks & HIFN_CRYPT_CMD_NEW_IV) {
d1089 1
a1089 1
	if ((cmd->base_masks & (HIFN_BASE_CMD_MAC|HIFN_BASE_CMD_CRYPT)) == 0) {
d1125 3
a1127 3
		dma->dstr[idx].p = htole32(map->dm_segs[i].ds_addr);
		dma->dstr[idx].l = htole32(HIFN_D_VALID |
		    HIFN_D_MASKDONEIRQ | map->dm_segs[i].ds_len);
d1133 2
a1134 2
			dma->dstr[idx].l = htole32(HIFN_D_VALID |
			    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
d1152 3
a1154 4
			dma->dstr[idx].p = htole32(map->dm_segs[i].ds_addr);
			dma->dstr[idx].l = htole32(HIFN_D_VALID |
			    HIFN_D_MASKDONEIRQ |
			    (map->dm_segs[i].ds_len - cmd->sloplen));
d1160 2
a1161 2
				dma->dstr[idx].l = htole32(HIFN_D_VALID |
				    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
d1168 2
a1169 2
	dma->dstr[idx].p = htole32(p);
	dma->dstr[idx].l = htole32(l);
d1174 2
a1175 2
		dma->dstr[idx].l = htole32(HIFN_D_VALID | HIFN_D_JUMP |
		    HIFN_D_MASKDONEIRQ);
d1201 3
a1203 3
		dma->srcr[idx].p = htole32(map->dm_segs[i].ds_addr);
		dma->srcr[idx].l = htole32(map->dm_segs[i].ds_len |
		    HIFN_D_VALID | HIFN_D_MASKDONEIRQ | last);
d1208 2
a1209 2
			dma->srcr[idx].l = htole32(HIFN_D_VALID |
			    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
d1376 2
a1377 2
		dma->cmdr[HIFN_D_CMD_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
d1383 4
d1390 2
a1391 2
	dma->cmdr[cmdi].l = htole32(cmdlen | HIFN_D_VALID | HIFN_D_LAST |
	    HIFN_D_MASKDONEIRQ);
d1428 2
a1429 2
		dma->resr[HIFN_D_RES_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
d1436 1
a1436 2
	dma->resr[resi].l = htole32(HIFN_MAX_RESULT |
	    HIFN_D_VALID | HIFN_D_LAST);
d1573 1
a1573 1
		if (dma->resr[i].l & htole32(HIFN_D_VALID)) {
d1605 1
a1605 1
		if (dma->srcr[i].l & htole32(HIFN_D_VALID)) {
d1621 1
a1621 1
		if (dma->cmdr[i].l & htole32(HIFN_D_VALID)) {
d1976 1
a1976 1
		if ((dma->resr[i].l & htole32(HIFN_D_VALID)) == 0) {
d2098 1
a2098 1
		if (dma->dstr[i].l & htole32(HIFN_D_VALID)) {
@


1.6.2.7
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d97 2
a98 2
int	hifn_readramaddr __P((struct hifn_softc *, int, u_int8_t *));
int	hifn_writeramaddr __P((struct hifn_softc *, int, u_int8_t *));
a105 1
void	hifn_alloc_slot __P((struct hifn_softc *, int *, int *, int *, int *));
d121 4
a124 3
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7751 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7951 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7811))
a155 4
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_HIFN &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7811)
		sc->sc_flags |= HIFN_IS_7811 | HIFN_HAS_RNG;

d246 9
a342 1
	u_int32_t r;
d345 2
a346 11
	if ((sc->sc_flags & HIFN_IS_7811) == 0) {
		/* Reset 7951 public key/rng engine */
		WRITE_REG_1(sc, HIFN_1_PUB_RESET,
		    READ_REG_1(sc, HIFN_1_PUB_RESET) | HIFN_PUBRST_RESET);

		for (i = 0; i < 100; i++) {
			DELAY(1000);
			if ((READ_REG_1(sc, HIFN_1_PUB_RESET) &
			    HIFN_PUBRST_RESET) == 0)
				break;
		}
d348 9
a356 5
		if (i == 100) {
			printf("%s: public key init failed\n",
			    sc->sc_dv.dv_xname);
			return (1);
		}
d361 2
a362 15
		if (sc->sc_flags & HIFN_IS_7811) {
			r = READ_REG_1(sc, HIFN_1_7811_RNGENA);
			if (r & HIFN_7811_RNGENA_ENA) {
				r &= ~HIFN_7811_RNGENA_ENA;
				WRITE_REG_1(sc, HIFN_1_7811_RNGENA, r);
			}
			WRITE_REG_1(sc, HIFN_1_7811_RNGCFG,
			    HIFN_7811_RNGCFG_DEFL);
			r |= HIFN_7811_RNGENA_ENA;
			WRITE_REG_1(sc, HIFN_1_7811_RNGENA, r);
		} else
			WRITE_REG_1(sc, HIFN_1_RNG_CONFIG,
			    READ_REG_1(sc, HIFN_1_RNG_CONFIG) |
			    HIFN_RNGCFG_ENA);

d387 1
a387 13
	u_int32_t num1, sts, num2;
	int i;

	if (sc->sc_flags & HIFN_IS_7811) {
		for (i = 0; i < 5; i++) {
			sts = READ_REG_1(sc, HIFN_1_7811_RNGSTS);
			if (sts & HIFN_7811_RNGSTS_UFL) {
				printf("%s: RNG underflow: disabling\n",
				    sc->sc_dv.dv_xname);
				return;
			}
			if ((sts & HIFN_7811_RNGSTS_RDY) == 0)
				break;
d389 1
a389 15
			/*
			 * There are at least two words in the RNG FIFO
			 * at this point.
			 */
			num1 = READ_REG_1(sc, HIFN_1_7811_RNGDAT);
			num2 = READ_REG_1(sc, HIFN_1_7811_RNGDAT);
			if (sc->sc_rngfirst)
				sc->sc_rngfirst = 0;
			else {
				add_true_randomness(num1);
				add_true_randomness(num2);
			}
		}
	} else {
		num1 = READ_REG_1(sc, HIFN_1_RNG_DATA);
d391 4
a394 5
		if (sc->sc_rngfirst)
			sc->sc_rngfirst = 0;
		else
			add_true_randomness(num1);
	}
a470 11

	if (sc->sc_flags & HIFN_IS_7811) {
		for (reg = 0; reg < 1000; reg++) {
			if (READ_REG_1(sc, HIFN_1_7811_MIPSRST) &
			    HIFN_MIPSRST_CRAMINIT)
				break;
			DELAY(1000);
		}
		if (reg == 1000)
			printf(": cram init timeout\n");
	}
a517 5
		PCI_VENDOR_HIFN,
		PCI_PRODUCT_HIFN_7811,
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00 }
	}, {
d666 1
a666 1
	    HIFN_DMACSR_S_WAIT |
d669 2
a670 6
	    HIFN_DMACSR_ENGINE |
	    ((sc->sc_flags & HIFN_HAS_PUBLIC) ?
		HIFN_DMACSR_PUBDONE : 0) |
	    ((sc->sc_flags & HIFN_IS_7811) ?
		HIFN_DMACSR_ILLW | HIFN_DMACSR_ILLR : 0));

d673 2
a674 4
	    HIFN_DMAIER_D_OVER | HIFN_DMAIER_R_OVER |
	    HIFN_DMAIER_S_ABORT | HIFN_DMAIER_D_ABORT | HIFN_DMAIER_R_ABORT |
	    ((sc->sc_flags & HIFN_IS_7811) ?
		HIFN_DMAIER_ILLW | HIFN_DMAIER_ILLR : 0);
a720 4
/*
 * Determine ram type (sram or dram).  Board should be just out of a reset
 * state when this is called.
 */
d728 4
d734 1
a734 1
	if (hifn_writeramaddr(sc, 0, data))
d736 1
a736 1
	if (hifn_readramaddr(sc, 0, data))
d745 1
a745 1
	if (hifn_writeramaddr(sc, 0, data))
d747 1
a747 1
	if (hifn_readramaddr(sc, 0, data))
d771 3
d776 1
a776 1
		if (hifn_writeramaddr(sc, a, data) < 0)
d778 1
a778 1
		if (hifn_readramaddr(sc, a, data) < 0)
d782 3
d790 1
a790 1
	if (hifn_writeramaddr(sc, 0, data) < 0)
d795 4
a798 1
		if (hifn_readramaddr(sc, a, data) < 0)
d805 4
a828 48
void
hifn_alloc_slot(sc, cmdp, srcp, dstp, resp)
	struct hifn_softc *sc;
	int *cmdp, *srcp, *dstp, *resp;
{
	struct hifn_dma *dma = sc->sc_dma;

	if (dma->cmdi == HIFN_D_CMD_RSIZE) {
		dma->cmdi = 0;
		dma->cmdr[HIFN_D_CMD_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_CMDR_SYNC(sc, HIFN_D_CMD_RSIZE,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	*cmdp = dma->cmdi++;
	dma->cmdk = dma->cmdi;

	if (dma->srci == HIFN_D_SRC_RSIZE) {
		dma->srci = 0;
		dma->srcr[HIFN_D_SRC_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_SRCR_SYNC(sc, HIFN_D_SRC_RSIZE,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	*srcp = dma->srci++;
	dma->srck = dma->srci;

	if (dma->dsti == HIFN_D_DST_RSIZE) {
		dma->dsti = 0;
		dma->dstr[HIFN_D_DST_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_DSTR_SYNC(sc, HIFN_D_DST_RSIZE,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	*dstp = dma->dsti++;
	dma->dstk = dma->dsti;

	if (dma->resi == HIFN_D_RES_RSIZE) {
		dma->resi = 0;
		dma->resr[HIFN_D_RES_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_RESR_SYNC(sc, HIFN_D_RES_RSIZE,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	*resp = dma->resi++;
	dma->resk = dma->resi;
}

d830 1
a830 1
hifn_writeramaddr(sc, addr, data)
d832 1
a832 1
	int addr;
d838 1
a838 1
	int r, cmdi, resi, srci, dsti;
a844 2
	hifn_alloc_slot(sc, &cmdi, &srci, &dsti, &resi);

d850 2
a851 2
	bzero(dma->command_bufs[cmdi], HIFN_MAX_COMMAND);
	*(hifn_base_command_t *)dma->command_bufs[cmdi] = wc;
d854 1
a854 1
	dma->srcr[srci].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr
d856 1
a856 1
	dma->dstr[dsti].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr
d859 4
a862 4
	dma->cmdr[cmdi].l = htole32(16 | masks);
	dma->srcr[srci].l = htole32(8 | masks);
	dma->dstr[dsti].l = htole32(4 | masks);
	dma->resr[resi].l = htole32(4 | masks);
d874 1
a874 1
	if (dma->resr[resi].l & htole32(HIFN_D_VALID)) {
d877 1
a877 1
		    sc->sc_dv.dv_xname, resi, addr);
d879 1
d891 1
a891 1
hifn_readramaddr(sc, addr, data)
d893 1
a893 1
	int addr;
d899 1
a899 1
	int r, cmdi, srci, dsti, resi;
a905 2
	hifn_alloc_slot(sc, &cmdi, &srci, &dsti, &resi);

d910 2
a911 2
	bzero(dma->command_bufs[cmdi], HIFN_MAX_COMMAND);
	*(hifn_base_command_t *)dma->command_bufs[cmdi] = rc;
d913 1
a913 1
	dma->srcr[srci].p = htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
d916 1
a916 1
	dma->dstr[dsti].p =  htole32(sc->sc_dmamap->dm_segs[0].ds_addr +
d919 4
a922 4
	dma->cmdr[cmdi].l = htole32(8 | masks);
	dma->srcr[srci].l = htole32(8 | masks);
	dma->dstr[dsti].l = htole32(8 | masks);
	dma->resr[resi].l = htole32(HIFN_MAX_RESULT | masks);
d934 1
a934 1
	if (dma->resr[resi].l & htole32(HIFN_D_VALID)) {
d937 1
a937 1
		    sc->sc_dv.dv_xname, resi, addr);
d1542 2
a1543 1
	restart = dmacsr & (HIFN_DMACSR_D_OVER | HIFN_DMACSR_R_OVER);
a1546 7
	if (sc->sc_flags & HIFN_IS_7811) {
		if (dmacsr & HIFN_DMACSR_ILLR)
			printf("%s: illegal read\n", sc->sc_dv.dv_xname);
		if (dmacsr & HIFN_DMACSR_ILLW)
			printf("%s: illegal write\n", sc->sc_dv.dv_xname);
	}

d1550 1
a1550 1
		printf("%s: abort, resetting.\n", sc->sc_dv.dv_xname);
@


1.6.2.8
log
@Merge in -current from roughly a week ago
@
text
@d68 2
a69 2
int hifn_probe(struct device *, void *, void *);
void hifn_attach(struct device *, struct device *, void *);
d79 28
a106 28
void	hifn_reset_board(struct hifn_softc *, int);
void	hifn_reset_puc(struct hifn_softc *);
void	hifn_puc_wait(struct hifn_softc *);
int	hifn_enable_crypto(struct hifn_softc *, pcireg_t);
void	hifn_init_dma(struct hifn_softc *);
void	hifn_init_pci_registers(struct hifn_softc *);
int	hifn_sramsize(struct hifn_softc *);
int	hifn_dramsize(struct hifn_softc *);
int	hifn_ramtype(struct hifn_softc *);
void	hifn_sessions(struct hifn_softc *);
int	hifn_intr(void *);
u_int	hifn_write_command(struct hifn_command *, u_int8_t *);
u_int32_t hifn_next_signature(u_int32_t a, u_int cnt);
int	hifn_newsession(u_int32_t *, struct cryptoini *);
int	hifn_freesession(u_int64_t);
int	hifn_process(struct cryptop *);
void	hifn_callback(struct hifn_softc *, struct hifn_command *, u_int8_t *);
int	hifn_crypto(struct hifn_softc *, struct hifn_command *, struct cryptop *);
int	hifn_readramaddr(struct hifn_softc *, int, u_int8_t *);
int	hifn_writeramaddr(struct hifn_softc *, int, u_int8_t *);
int	hifn_dmamap_aligned(bus_dmamap_t);
int	hifn_dmamap_load_src(struct hifn_softc *, struct hifn_command *);
int	hifn_dmamap_load_dst(struct hifn_softc *, struct hifn_command *);
int	hifn_init_pubrng(struct hifn_softc *);
void	hifn_rng(void *);
void	hifn_tick(void *);
void	hifn_abort(struct hifn_softc *);
void	hifn_alloc_slot(struct hifn_softc *, int *, int *, int *, int *);
@


1.6.2.9
log
@Sync the SMP branch with 3.3
@
text
@a35 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
a82 1
void	hifn_set_retry(struct hifn_softc *);
d96 1
a96 2
int	hifn_crypto(struct hifn_softc *, struct hifn_command *,
    struct cryptop *);
a106 8
void	hifn_write_4(struct hifn_softc *, int, bus_size_t, u_int32_t);
u_int32_t hifn_read_4(struct hifn_softc *, int, bus_size_t);
int	hifn_compression(struct hifn_softc *, struct cryptop *,
    struct hifn_command *);
struct mbuf *hifn_mkmbuf_chain(int, struct mbuf *);
int	hifn_compress_enter(struct hifn_softc *, struct hifn_command *);
void	hifn_callback_comp(struct hifn_softc *, struct hifn_command *,
    u_int8_t *);
a109 8
const struct pci_matchid hifn_devices[] = {
	{ PCI_VENDOR_INVERTEX, PCI_PRODUCT_INVERTEX_AEON },
	{ PCI_VENDOR_HIFN, PCI_PRODUCT_HIFN_7751 },
	{ PCI_VENDOR_HIFN, PCI_PRODUCT_HIFN_7811 },
	{ PCI_VENDOR_HIFN, PCI_PRODUCT_HIFN_7951 },
	{ PCI_VENDOR_NETSEC, PCI_PRODUCT_NETSEC_7751 },
};

d116 14
a129 2
	return (pci_matchbyid((struct pci_attach_args *)aux, hifn_devices,
	    sizeof(hifn_devices)/sizeof(hifn_devices[0])));
a147 1
	int algs[CRYPTO_ALGORITHM_MAX + 1];
d158 1
a158 2
		sc->sc_flags |= HIFN_IS_7811 | HIFN_HAS_RNG | HIFN_HAS_LEDS |
		    HIFN_NO_BURSTWRITE;
d187 3
a189 6
	hifn_set_retry(sc);

	if (sc->sc_flags & HIFN_NO_BURSTWRITE) {
		sc->sc_waw_lastgroup = -1;
		sc->sc_waw_lastreg = 1;
	}
d273 1
a273 1
	printf("%d%cB %cram, %s\n", rseg, rbase,
a283 3
	bzero(algs, sizeof(algs));

	algs[CRYPTO_LZS_COMP] = CRYPTO_ALG_FLAG_SUPPORTED;
d286 4
a289 2
		algs[CRYPTO_3DES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_ARC4] = CRYPTO_ALG_FLAG_SUPPORTED;
d292 10
a301 5
		algs[CRYPTO_MD5] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_SHA1] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_MD5_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_SHA1_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
		algs[CRYPTO_DES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
a303 3
	crypto_register(sc->sc_cid, algs, hifn_newsession,
	    hifn_freesession, hifn_process);

a466 11
void
hifn_set_retry(sc)
	struct hifn_softc *sc;
{
	u_int32_t r;

	r = pci_conf_read(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_TRDY_TIMEOUT);
	r &= 0xffff0000;
	pci_conf_write(sc->sc_pci_pc, sc->sc_pci_tag, HIFN_TRDY_TIMEOUT, r);
}

d509 3
a511 1
	hifn_set_retry(sc);
d647 1
a647 1
	addr = READ_REG_1(sc, HIFN_1_UNLOCK_SECRET1);
d649 1
a649 1
	WRITE_REG_1(sc, HIFN_1_UNLOCK_SECRET2, 0);
d654 1
a654 1
		WRITE_REG_1(sc, HIFN_1_UNLOCK_SECRET2, addr);
d675 1
a675 1
		offtbl = "LZS-only";
d678 1
a678 1
		offtbl = "DES";
d681 1
a681 1
		offtbl = "3DES";
d684 1
a684 1
		offtbl = "disabled";
a686 1
	printf(": %s, ", offtbl);
d688 1
a688 1
	return (0);
a713 2
	DELAY(2000);

a735 1
	    HIFN_DMAIER_ENGINE |
a739 1
	CLR_LED(sc, HIFN_MIPSRST_LED0 | HIFN_MIPSRST_LED1 | HIFN_MIPSRST_LED2);
d820 4
a823 4
#define	HIFN_SRAM_MAX		(32 << 20)
#define	HIFN_SRAM_STEP_SIZE	16384
#define	HIFN_SRAM_GRANULARITY	(HIFN_SRAM_MAX / HIFN_SRAM_STEP_SIZE)

d828 2
a829 4
	u_int32_t a;
	u_int8_t data[8];
	u_int8_t dataexpect[sizeof(data)];
	int32_t i;
d831 2
a832 2
	for (i = 0; i < sizeof(data); i++)
		data[i] = dataexpect[i] = i ^ 0x5a;
d834 9
a842 4
	for (i = HIFN_SRAM_GRANULARITY - 1; i >= 0; i--) {
		a = i * HIFN_SRAM_STEP_SIZE;
		bcopy(&i, data, sizeof(i));
		hifn_writeramaddr(sc, a, data);
d845 7
a851 3
	for (i = 0; i < HIFN_SRAM_GRANULARITY; i++) {
		a = i * HIFN_SRAM_STEP_SIZE;
		bcopy(&i, dataexpect, sizeof(i));
d854 1
a854 1
		if (bcmp(data, dataexpect, sizeof(data)) != 0)
d856 1
a856 1
		sc->sc_ramsize = a + HIFN_SRAM_STEP_SIZE;
d934 1
a934 1
	struct hifn_base_command wc;
d951 1
a951 1
	*(struct hifn_base_command *)dma->command_bufs[cmdi] = wc;
d968 9
a976 14
	for (r = 10000; r >= 0; r--) {
		DELAY(10);
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    0, sc->sc_dmamap->dm_mapsize,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		if ((dma->resr[resi].l & htole32(HIFN_D_VALID)) == 0)
			break;
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    0, sc->sc_dmamap->dm_mapsize,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	}
	if (r == 0) {
		printf("%s: writeramaddr -- "
		    "result[%d](addr %d) still valid\n",
a978 1
		return (-1);
d996 1
a996 1
	struct hifn_base_command rc;
d1012 1
a1012 1
	*(struct hifn_base_command *)dma->command_bufs[cmdi] = rc;
d1029 9
a1037 14
	for (r = 10000; r >= 0; r--) {
		DELAY(10);
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    0, sc->sc_dmamap->dm_mapsize,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		if ((dma->resr[resi].l & htole32(HIFN_D_VALID)) == 0)
			break;
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    0, sc->sc_dmamap->dm_mapsize,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	}
	if (r == 0) {
		printf("%s: readramaddr -- "
		    "result[%d](addr %d) still valid\n",
d1060 1
d1063 3
a1065 1
	hifn_set_retry(sc);
d1103 4
a1106 5
	struct hifn_base_command *base_cmd;
	struct hifn_mac_command *mac_cmd;
	struct hifn_crypt_command *cry_cmd;
	struct hifn_comp_command *comp_cmd;
	int using_mac, using_crypt, using_comp, len;
a1111 1
	using_comp = cmd->base_masks & HIFN_BASE_CMD_COMP;
d1113 1
a1113 1
	base_cmd = (struct hifn_base_command *)buf_pos;
d1128 1
a1128 13
	buf_pos += sizeof(struct hifn_base_command);

	if (using_comp) {
		comp_cmd = (struct hifn_comp_command *)buf_pos;
		dlen = cmd->compcrd->crd_len;
		comp_cmd->source_count = htole16(dlen & 0xffff);
		dlen >>= 16;
		comp_cmd->masks = htole16(cmd->comp_masks |
		    ((dlen << HIFN_COMP_CMD_SRCLEN_S) & HIFN_COMP_CMD_SRCLEN_M));
		comp_cmd->header_skip = htole16(cmd->compcrd->crd_skip);
		comp_cmd->reserved = 0;
		buf_pos += sizeof(struct hifn_comp_command);
	}
d1131 1
a1131 1
		mac_cmd = (struct hifn_mac_command *)buf_pos;
d1139 1
a1139 1
		buf_pos += sizeof(struct hifn_mac_command);
d1143 1
a1143 1
		cry_cmd = (struct hifn_crypt_command *)buf_pos;
d1151 1
a1151 1
		buf_pos += sizeof(struct hifn_crypt_command);
d1190 1
a1190 2
	if ((cmd->base_masks & (HIFN_BASE_CMD_MAC | HIFN_BASE_CMD_CRYPT |
	    HIFN_BASE_CMD_COMP)) == 0) {
d1406 1
a1406 2
				if (m0->m_flags & M_PKTHDR)
					m0->m_pkthdr.len += len;
a1495 1
		SET_LED(sc, HIFN_MIPSRST_LED0);
a1514 1
		SET_LED(sc, HIFN_MIPSRST_LED1);
a1541 1
		SET_LED(sc, HIFN_MIPSRST_LED2);
a1560 1
	cmd->cmd_callback = hifn_callback;
a1570 3
	if (crp->crp_flags & CRYPTO_F_IMBUF &&
	    cmd->srcu.src_m != cmd->dstu.dst_m)
		m_freem(cmd->dstu.dst_m);
a1591 1
			CLR_LED(sc, HIFN_MIPSRST_LED0);
a1595 1
			CLR_LED(sc, HIFN_MIPSRST_LED1);
a1603 1
			CLR_LED(sc, HIFN_MIPSRST_LED2);
a1637 3
	if (dmacsr & HIFN_DMACSR_ENGINE)
		WRITE_REG_0(sc, HIFN_0_PUISR, READ_REG_0(sc, HIFN_0_PUISR));

d1643 1
a1643 1
	restart = dmacsr & (HIFN_DMACSR_R_OVER | HIFN_DMACSR_D_OVER);
d1663 1
a1663 1
	if ((dmacsr & HIFN_DMACSR_C_WAIT) && (dma->resu == 0)) {
d1674 2
a1675 2
	i = dma->resk;
	while (dma->resu != 0) {
d1686 1
d1691 6
a1696 1
			(*cmd->cmd_callback)(sc, cmd, dma->result_bufs[i]);
d1698 1
a1702 2
		else
			dma->resu--;
d1704 1
a1704 1
	dma->resk = i;
d1755 1
a1755 1
	int i, mac = 0, cry = 0, comp = 0;
a1795 5
		case CRYPTO_LZS_COMP:
			if (comp)
				return (EINVAL);
			comp = 1;
			break;
d1800 1
a1800 8
	if (mac == 0 && cry == 0 && comp == 0)
		return (EINVAL);

	/*
	 * XXX only want to support compression without chaining to
	 * MAC/crypt engine right now
	 */
	if ((comp && mac) || (comp && cry))
d1820 1
a1820 1
	u_int32_t sid = ((u_int32_t)tid) & 0xffffffff;
a1901 2
		} else if (crd1->crd_alg == CRYPTO_LZS_COMP) {
			return (hifn_compression(sc, crp, cmd));
d1908 3
a1910 3
		     crd1->crd_alg == CRYPTO_SHA1_HMAC ||
		     crd1->crd_alg == CRYPTO_MD5 ||
		     crd1->crd_alg == CRYPTO_SHA1) &&
d1922 3
a1924 3
		     crd2->crd_alg == CRYPTO_SHA1_HMAC ||
		     crd2->crd_alg == CRYPTO_MD5 ||
		     crd2->crd_alg == CRYPTO_SHA1) &&
d2013 1
a2013 1
			break;
d2063 1
a2063 1
	crypto_done(crp);
d2083 7
d2091 1
a2091 1
			(*cmd->cmd_callback)(sc, cmd, dma->result_bufs[i]);
d2148 1
a2148 1
hifn_callback(sc, cmd, resbuf)
d2151 1
a2151 1
	u_int8_t *resbuf;
d2172 1
a2183 1
			m_freem(cmd->srcu.src_m);
d2240 1
a2240 8
	if (cmd->base_masks & HIFN_BASE_CMD_MAC) {
		u_int8_t *macbuf;

		macbuf = resbuf + sizeof(struct hifn_base_result);
		if (cmd->base_masks & HIFN_BASE_CMD_COMP)
			macbuf += sizeof(struct hifn_comp_result);
		macbuf += sizeof(struct hifn_mac_result);

d2242 1
a2242 1
			int len;
d2244 8
a2251 8
			if (crd->crd_alg == CRYPTO_MD5)
				len = 16;
			else if (crd->crd_alg == CRYPTO_SHA1)
				len = 20;
			else if (crd->crd_alg == CRYPTO_MD5_HMAC ||
			    crd->crd_alg == CRYPTO_SHA1_HMAC)
				len = 12;
			else
d2256 1
a2256 1
				    crd->crd_inject, len, macbuf);
a2270 452
}

int
hifn_compression(struct hifn_softc *sc, struct cryptop *crp,
    struct hifn_command *cmd)
{
	struct cryptodesc *crd = crp->crp_desc;
	int s, err = 0;

	cmd->compcrd = crd;
	cmd->base_masks |= HIFN_BASE_CMD_COMP;

	if ((crp->crp_flags & CRYPTO_F_IMBUF) == 0) {
		/*
		 * XXX can only handle mbufs right now since we can
		 * XXX dynamically resize them.
		 */
		err = EINVAL;
		return (ENOMEM);
	}

	if ((crd->crd_flags & CRD_F_COMP) == 0)
		cmd->base_masks |= HIFN_BASE_CMD_DECODE;
	if (crd->crd_alg == CRYPTO_LZS_COMP)
		cmd->comp_masks |= HIFN_COMP_CMD_ALG_LZS |
		    HIFN_COMP_CMD_CLEARHIST;

	if (bus_dmamap_create(sc->sc_dmat, HIFN_MAX_DMALEN, MAX_SCATTER,
	    HIFN_MAX_SEGLEN, 0, BUS_DMA_NOWAIT, &cmd->src_map)) {
		err = ENOMEM;
		goto fail;
	}

	if (bus_dmamap_create(sc->sc_dmat, HIFN_MAX_DMALEN, MAX_SCATTER,
	    HIFN_MAX_SEGLEN, 0, BUS_DMA_NOWAIT, &cmd->dst_map)) {
		err = ENOMEM;
		goto fail;
	}

	if (crp->crp_flags & CRYPTO_F_IMBUF) {
		int len;

		if (bus_dmamap_load_mbuf(sc->sc_dmat, cmd->src_map,
		    cmd->srcu.src_m, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
			goto fail;
		}

		len = cmd->src_map->dm_mapsize / MCLBYTES;
		if ((cmd->src_map->dm_mapsize % MCLBYTES) != 0)
			len++;
		len *= MCLBYTES;

		if ((crd->crd_flags & CRD_F_COMP) == 0)
			len *= 4;

		if (len > HIFN_MAX_DMALEN)
			len = HIFN_MAX_DMALEN;

		cmd->dstu.dst_m = hifn_mkmbuf_chain(len, cmd->srcu.src_m);
		if (cmd->dstu.dst_m == NULL) {
			err = ENOMEM;
			goto fail;
		}

		if (bus_dmamap_load_mbuf(sc->sc_dmat, cmd->dst_map,
		    cmd->dstu.dst_m, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
			goto fail;
		}
	} else if (crp->crp_flags & CRYPTO_F_IOV) {
		if (bus_dmamap_load_uio(sc->sc_dmat, cmd->src_map,
		    cmd->srcu.src_io, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
			goto fail;
		}
		if (bus_dmamap_load_uio(sc->sc_dmat, cmd->dst_map,
		    cmd->dstu.dst_io, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
			goto fail;
		}
	}

	if (cmd->src_map == cmd->dst_map)
		bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
		    0, cmd->src_map->dm_mapsize,
		    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
	else {
		bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
		    0, cmd->src_map->dm_mapsize, BUS_DMASYNC_PREWRITE);
		bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
		    0, cmd->dst_map->dm_mapsize, BUS_DMASYNC_PREREAD);
	}

	cmd->crp = crp;
	/*
	 * Always use session 0.  The modes of compression we use are
	 * stateless and there is always at least one compression
	 * context, zero.
	 */
	cmd->session_num = 0;
	cmd->softc = sc;

	s = splnet();
	err = hifn_compress_enter(sc, cmd);
	splx(s);

	if (err != 0)
		goto fail;
	return (0);

fail:
	if (cmd->dst_map != NULL) {
		if (cmd->dst_map->dm_nsegs > 0)
			bus_dmamap_unload(sc->sc_dmat, cmd->dst_map);
		bus_dmamap_destroy(sc->sc_dmat, cmd->dst_map);
	}
	if (cmd->src_map != NULL) {
		if (cmd->src_map->dm_nsegs > 0)
			bus_dmamap_unload(sc->sc_dmat, cmd->src_map);
		bus_dmamap_destroy(sc->sc_dmat, cmd->src_map);
	}
	free(cmd, M_DEVBUF);
	if (err == EINVAL)
		hifnstats.hst_invalid++;
	else
		hifnstats.hst_nomem++;
	crp->crp_etype = err;
	crypto_done(crp);
	return (0);
}

/*
 * must be called at splnet()
 */
int
hifn_compress_enter(struct hifn_softc *sc, struct hifn_command *cmd)
{
	struct hifn_dma *dma = sc->sc_dma;
	int cmdi, resi;
	u_int32_t cmdlen;

	if ((dma->cmdu + 1) > HIFN_D_CMD_RSIZE ||
	    (dma->resu + 1) > HIFN_D_CMD_RSIZE)
		return (ENOMEM);

	if ((dma->srcu + cmd->src_map->dm_nsegs) > HIFN_D_SRC_RSIZE ||
	    (dma->dstu + cmd->dst_map->dm_nsegs) > HIFN_D_DST_RSIZE)
		return (ENOMEM);

	if (dma->cmdi == HIFN_D_CMD_RSIZE) {
		dma->cmdi = 0;
		dma->cmdr[HIFN_D_CMD_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_CMDR_SYNC(sc, HIFN_D_CMD_RSIZE,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	cmdi = dma->cmdi++;
	cmdlen = hifn_write_command(cmd, dma->command_bufs[cmdi]);
	HIFN_CMD_SYNC(sc, cmdi, BUS_DMASYNC_PREWRITE);

	/* .p for command/result already set */
	dma->cmdr[cmdi].l = htole32(cmdlen | HIFN_D_VALID | HIFN_D_LAST |
	    HIFN_D_MASKDONEIRQ);
	HIFN_CMDR_SYNC(sc, cmdi,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	dma->cmdu++;
	if (sc->sc_c_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_C_CTRL_ENA);
		sc->sc_c_busy = 1;
		SET_LED(sc, HIFN_MIPSRST_LED0);
	}

	/*
	 * We don't worry about missing an interrupt (which a "command wait"
	 * interrupt salvages us from), unless there is more than one command
	 * in the queue.
	 */
	if (dma->cmdu > 1) {
		sc->sc_dmaier |= HIFN_DMAIER_C_WAIT;
		WRITE_REG_1(sc, HIFN_1_DMA_IER, sc->sc_dmaier);
	}

	hifnstats.hst_ipackets++;
	hifnstats.hst_ibytes += cmd->src_map->dm_mapsize;

	hifn_dmamap_load_src(sc, cmd);
	if (sc->sc_s_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_S_CTRL_ENA);
		sc->sc_s_busy = 1;
		SET_LED(sc, HIFN_MIPSRST_LED1);
	}

	/*
	 * Unlike other descriptors, we don't mask done interrupt from
	 * result descriptor.
	 */
	if (dma->resi == HIFN_D_RES_RSIZE) {
		dma->resi = 0;
		dma->resr[HIFN_D_RES_RSIZE].l = htole32(HIFN_D_VALID |
		    HIFN_D_JUMP | HIFN_D_MASKDONEIRQ);
		HIFN_RESR_SYNC(sc, HIFN_D_RES_RSIZE,
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	}
	resi = dma->resi++;
	dma->hifn_commands[resi] = cmd;
	HIFN_RES_SYNC(sc, resi, BUS_DMASYNC_PREREAD);
	dma->resr[resi].l = htole32(HIFN_MAX_RESULT |
	    HIFN_D_VALID | HIFN_D_LAST);
	HIFN_RESR_SYNC(sc, resi,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
	dma->resu++;
	if (sc->sc_r_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_R_CTRL_ENA);
		sc->sc_r_busy = 1;
		SET_LED(sc, HIFN_MIPSRST_LED2);
	}

	if (cmd->sloplen)
		cmd->slopidx = resi;

	hifn_dmamap_load_dst(sc, cmd);

	if (sc->sc_d_busy == 0) {
		WRITE_REG_1(sc, HIFN_1_DMA_CSR, HIFN_DMACSR_D_CTRL_ENA);
		sc->sc_d_busy = 1;
	}
	sc->sc_active = 5;
	cmd->cmd_callback = hifn_callback_comp;
	return (0);
}

void
hifn_callback_comp(struct hifn_softc *sc, struct hifn_command *cmd,
    u_int8_t *resbuf)
{
	struct hifn_base_result baseres;
	struct cryptop *crp = cmd->crp;
	struct hifn_dma *dma = sc->sc_dma;
	struct mbuf *m;
	int err = 0, i, u;
	u_int32_t olen;
	bus_size_t dstsize;

	bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
	    0, cmd->src_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
	bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
	    0, cmd->dst_map->dm_mapsize, BUS_DMASYNC_POSTREAD);

	dstsize = cmd->dst_map->dm_mapsize;
	bus_dmamap_unload(sc->sc_dmat, cmd->dst_map);

	bcopy(resbuf, &baseres, sizeof(struct hifn_base_result));

	i = dma->dstk; u = dma->dstu;
	while (u != 0) {
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
		    offsetof(struct hifn_dma, dstr[i]), sizeof(struct hifn_desc),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		if (dma->dstr[i].l & htole32(HIFN_D_VALID)) {
			bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
			    offsetof(struct hifn_dma, dstr[i]),
			    sizeof(struct hifn_desc),
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			break;
		}
		if (++i == (HIFN_D_DST_RSIZE + 1))
			i = 0;
		else
			u--;
	}
	dma->dstk = i; dma->dstu = u;

	if (baseres.flags & htole16(HIFN_BASE_RES_DSTOVERRUN)) {
		bus_size_t xlen;

		xlen = dstsize;

		m_freem(cmd->dstu.dst_m);

		if (xlen == HIFN_MAX_DMALEN) {
			/* We've done all we can. */
			err = E2BIG;
			goto out;
		}

		xlen += MCLBYTES;

		if (xlen > HIFN_MAX_DMALEN)
			xlen = HIFN_MAX_DMALEN;

		cmd->dstu.dst_m = hifn_mkmbuf_chain(xlen,
		    cmd->srcu.src_m);
		if (cmd->dstu.dst_m == NULL) {
			err = ENOMEM;
			goto out;
		}
		if (bus_dmamap_load_mbuf(sc->sc_dmat, cmd->dst_map,
		    cmd->dstu.dst_m, BUS_DMA_NOWAIT)) {
			err = ENOMEM;
			goto out;
		}

		bus_dmamap_sync(sc->sc_dmat, cmd->src_map,
		    0, cmd->src_map->dm_mapsize, BUS_DMASYNC_PREWRITE);
		bus_dmamap_sync(sc->sc_dmat, cmd->dst_map,
		    0, cmd->dst_map->dm_mapsize, BUS_DMASYNC_PREREAD);

		/* already at splnet... */
		err = hifn_compress_enter(sc, cmd);
		if (err != 0)
			goto out;
		return;
	}

	olen = dstsize - (letoh16(baseres.dst_cnt) |
	    (((letoh16(baseres.session) & HIFN_BASE_RES_DSTLEN_M) >>
	    HIFN_BASE_RES_DSTLEN_S) << 16));

	crp->crp_olen = olen - cmd->compcrd->crd_skip;

	bus_dmamap_unload(sc->sc_dmat, cmd->src_map);
	bus_dmamap_destroy(sc->sc_dmat, cmd->src_map);
	bus_dmamap_destroy(sc->sc_dmat, cmd->dst_map);

	m = cmd->dstu.dst_m;
	if (m->m_flags & M_PKTHDR)
		m->m_pkthdr.len = olen;
	crp->crp_buf = (caddr_t)m;
	for (; m != NULL; m = m->m_next) {
		if (olen >= m->m_len)
			olen -= m->m_len;
		else {
			m->m_len = olen;
			olen = 0;
		}
	}

	m_freem(cmd->srcu.src_m);
	free(cmd, M_DEVBUF);
	crp->crp_etype = 0;
	crypto_done(crp);
	return;

out:
	if (cmd->dst_map != NULL) {
		if (cmd->src_map->dm_nsegs != 0)
			bus_dmamap_unload(sc->sc_dmat, cmd->src_map);
		bus_dmamap_destroy(sc->sc_dmat, cmd->dst_map);
	}
	if (cmd->src_map != NULL) {
		if (cmd->src_map->dm_nsegs != 0)
			bus_dmamap_unload(sc->sc_dmat, cmd->src_map);
		bus_dmamap_destroy(sc->sc_dmat, cmd->src_map);
	}
	if (cmd->dstu.dst_m != NULL)
		m_freem(cmd->dstu.dst_m);
	free(cmd, M_DEVBUF);
	crp->crp_etype = err;
	crypto_done(crp);
}

struct mbuf *
hifn_mkmbuf_chain(int totlen, struct mbuf *mtemplate)
{
	int len;
	struct mbuf *m, *m0, *mlast;

	if (mtemplate->m_flags & M_PKTHDR) {
		len = MHLEN;
		MGETHDR(m0, M_DONTWAIT, MT_DATA);
	} else {
		len = MLEN;
		MGET(m0, M_DONTWAIT, MT_DATA);
	}
	if (m0 == NULL)
		return (NULL);
	if (len == MHLEN)
		M_DUP_PKTHDR(m0, mtemplate);
	MCLGET(m0, M_DONTWAIT);
	if (!(m0->m_flags & M_EXT))
		m_freem(m0);
	len = MCLBYTES;

	totlen -= len;
	m0->m_pkthdr.len = m0->m_len = len;
	mlast = m0;

	while (totlen > 0) {
		MGET(m, M_DONTWAIT, MT_DATA);
		if (m == NULL) {
			m_freem(m0);
			return (NULL);
		}
		MCLGET(m, M_DONTWAIT);
		if (!(m->m_flags & M_EXT)) {
			m_freem(m0);
			return (NULL);
		}
		len = MCLBYTES;
		m->m_len = len;
		if (m0->m_flags & M_PKTHDR)
			m0->m_pkthdr.len += len;
		totlen -= len;

		mlast->m_next = m;
		mlast = m;
	}

	return (m0);
}

void
hifn_write_4(sc, reggrp, reg, val)
	struct hifn_softc *sc;
	int reggrp;
	bus_size_t reg;
	u_int32_t val;
{
	/*
	 * 7811 PB3 rev/2 parts lock-up on burst writes to Group 0
	 * and Group 1 registers; avoid conditions that could create
	 * burst writes by doing a read in between the writes.
	 */
	if (sc->sc_flags & HIFN_NO_BURSTWRITE) {
		if (sc->sc_waw_lastgroup == reggrp &&
		    sc->sc_waw_lastreg == reg - 4) {
			bus_space_read_4(sc->sc_st1, sc->sc_sh1, HIFN_1_REVID);
		}
		sc->sc_waw_lastgroup = reggrp;
		sc->sc_waw_lastreg = reg;
	}
	if (reggrp == 0)
		bus_space_write_4(sc->sc_st0, sc->sc_sh0, reg, val);
	else
		bus_space_write_4(sc->sc_st1, sc->sc_sh1, reg, val);

}

u_int32_t
hifn_read_4(sc, reggrp, reg)
	struct hifn_softc *sc;
	int reggrp;
	bus_size_t reg;
{
	if (sc->sc_flags & HIFN_NO_BURSTWRITE) {
		sc->sc_waw_lastgroup = -1;
		sc->sc_waw_lastreg = 1;
	}
	if (reggrp == 0)
		return (bus_space_read_4(sc->sc_st0, sc->sc_sh0, reg));
	return (bus_space_read_4(sc->sc_st1, sc->sc_sh1, reg));
@


1.6.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d9 1
a9 2
 * Copyright (c) 2003 Hifn Inc.

d44 1
a44 1
 * Driver for various Hifn encryption processors.
d56 2
a129 2
	{ PCI_VENDOR_HIFN, PCI_PRODUCT_HIFN_7955 },
	{ PCI_VENDOR_HIFN, PCI_PRODUCT_HIFN_7956 },
d134 4
a137 1
hifn_probe(struct device *parent, void *match, void *aux)
d144 3
a146 1
hifn_attach(struct device *parent, struct device *self, void *aux)
d165 1
a165 1
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7951))
a168 6
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7955 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_HIFN_7956))
		sc->sc_flags = HIFN_IS_7956 | HIFN_HAS_AES | HIFN_HAS_RNG |
		    HIFN_HAS_PUBLIC;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_HIFN &&
d174 4
d179 1
a179 1
		printf(": memory mapping not enabled\n");
d182 1
d184 1
a184 1
		printf(": bus mastering not enabled\n");
d249 1
a249 3
	if (sc->sc_flags & HIFN_IS_7956)
		sc->sc_drammodel = 1;
	else if (hifn_ramtype(sc))
a314 2
	if (sc->sc_flags & HIFN_HAS_AES)
		algs[CRYPTO_AES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
d350 2
a351 1
hifn_init_pubrng(struct hifn_softc *sc)
d412 2
a413 1
hifn_rng(void *vsc)
d456 2
a457 1
hifn_puc_wait(struct hifn_softc *sc)
d474 2
a475 1
hifn_reset_puc(struct hifn_softc *sc)
d483 2
a484 1
hifn_set_retry(struct hifn_softc *sc)
d498 3
a500 1
hifn_reset_board(struct hifn_softc *sc, int full)
d550 3
a552 1
hifn_next_signature(u_int32_t a, u_int cnt)
a583 10
		PCI_VENDOR_HIFN,
		PCI_PRODUCT_HIFN_7955,
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00 }
	}, {
		PCI_VENDOR_HIFN,
		PCI_PRODUCT_HIFN_7956,
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00 }
	}, {
d617 3
a619 1
hifn_enable_crypto(struct hifn_softc *sc, pcireg_t pciid)
d721 2
a722 1
hifn_init_pci_registers(struct hifn_softc *sc)
d770 4
a773 11
	if (sc->sc_flags & HIFN_IS_7956) {
		WRITE_REG_0(sc, HIFN_0_PUCNFG, HIFN_PUCNFG_COMPSING |
		    HIFN_PUCNFG_TCALLPHASES |
		    HIFN_PUCNFG_TCDRVTOTEM | HIFN_PUCNFG_BUS32);
		WRITE_REG_1(sc, HIFN_1_PLL, HIFN_PLL_7956);
	} else {
		WRITE_REG_0(sc, HIFN_0_PUCNFG, HIFN_PUCNFG_COMPSING |
		    HIFN_PUCNFG_DRFR_128 | HIFN_PUCNFG_TCALLPHASES |
		    HIFN_PUCNFG_TCDRVTOTEM | HIFN_PUCNFG_BUS32 |
		    (sc->sc_drammodel ? HIFN_PUCNFG_DRAM : HIFN_PUCNFG_SRAM));
	}
d790 2
a791 1
hifn_sessions(struct hifn_softc *sc)
d803 2
a804 8
		/*
		 * 7955/7956 has internal context memory of 32K
		 */
		if (sc->sc_flags & HIFN_IS_7956)
			sc->sc_maxses = 32768 / ctxsize;
		else
			sc->sc_maxses = 1 +
			    ((sc->sc_ramsize - 32768) / ctxsize);
d818 2
a819 1
hifn_ramtype(struct hifn_softc *sc)
d854 2
a855 1
hifn_sramsize(struct hifn_softc *sc)
d890 2
a891 1
hifn_dramsize(struct hifn_softc *sc)
d895 3
a897 10
	if (sc->sc_flags & HIFN_IS_7956) {
		/*
		 * 7956/7956 have a fixed internal ram of only 32K.
		 */
		sc->sc_ramsize = 32768;
	} else {
		cnfg = READ_REG_0(sc, HIFN_0_PUCNFG) &
		    HIFN_PUCNFG_DRAMMASK;
		sc->sc_ramsize = 1 << ((cnfg >> 13) + 18);
	}
d902 3
a904 2
hifn_alloc_slot(struct hifn_softc *sc, int *cmdp, int *srcp,
    int *dstp, int *resp)
d950 4
a953 1
hifn_writeramaddr(struct hifn_softc *sc, int addr, u_int8_t *data)
d1018 4
a1021 1
hifn_readramaddr(struct hifn_softc *sc, int addr, u_int8_t *data)
d1089 2
a1090 1
hifn_init_dma(struct hifn_softc *sc)
d1128 3
a1130 1
hifn_write_command(struct hifn_command *cmd, u_int8_t *buf)
d1137 1
a1137 1
	int using_mac, using_crypt, using_comp, len, ivlen;
d1157 1
a1157 1
	base_cmd->session_num = htole16(
d1211 1
a1211 1
			buf_pos += HIFN_DES_KEY_LENGTH;
a1225 8
		case HIFN_CRYPT_CMD_ALG_AES:
			/*
			 * AES key are variable 128, 192 and
			 * 256 bits (16, 24 and 32 bytes).
			 */
			bcopy(cmd->ck, buf_pos, cmd->cklen);
			buf_pos += cmd->cklen;
			break;
d1230 2
a1231 7
		if ((cmd->cry_masks & HIFN_CRYPT_CMD_ALG_MASK) ==
		    HIFN_CRYPT_CMD_ALG_AES)
			ivlen = HIFN_AES_IV_LENGTH;
		else
			ivlen = HIFN_IV_LENGTH;
		bcopy(cmd->iv, buf_pos, ivlen);
		buf_pos += ivlen;
d1244 2
a1245 1
hifn_dmamap_aligned(bus_dmamap_t map)
d1260 3
a1262 1
hifn_dmamap_load_dst(struct hifn_softc *sc, struct hifn_command *cmd)
d1334 3
a1336 1
hifn_dmamap_load_src(struct hifn_softc *sc, struct hifn_command *cmd)
d1368 4
a1371 2
hifn_crypto(struct hifn_softc *sc, struct hifn_command *cmd,
    struct cryptop *crp)
d1631 2
a1632 1
hifn_tick(void *vsc)
d1671 2
a1672 1
hifn_intr(void *arg)
d1803 3
a1805 1
hifn_newsession(u_int32_t *sidp, struct cryptoini *cri)
d1809 1
a1809 2
	int i, mac = 0, cry = 0, comp = 0, sesn;
	struct hifn_session *ses = NULL;
d1824 5
a1828 31
	if (sc->sc_sessions == NULL) {
		ses = sc->sc_sessions = (struct hifn_session *)malloc(
		    sizeof(*ses), M_DEVBUF, M_NOWAIT);
		if (ses == NULL)
			return (ENOMEM);
		sesn = 0;
		sc->sc_nsessions = 1;
	} else {
		for (sesn = 0; sesn < sc->sc_nsessions; sesn++) {
			if (!sc->sc_sessions[sesn].hs_used) {
				ses = &sc->sc_sessions[sesn];
				break;
			}
		}

		if (ses == NULL) {
			sesn = sc->sc_nsessions;
			ses = (struct hifn_session *)malloc((sesn + 1) *
			    sizeof(*ses), M_DEVBUF, M_NOWAIT);
			if (ses == NULL)
				return (ENOMEM);
			bcopy(sc->sc_sessions, ses, sesn * sizeof(*ses));
			bzero(sc->sc_sessions, sesn * sizeof(*ses));
			free(sc->sc_sessions, M_DEVBUF);
			sc->sc_sessions = ses;
			ses = &sc->sc_sessions[sesn];
			sc->sc_nsessions++;
		}
	}
	bzero(ses, sizeof(*ses));
	ses->hs_used = 1;
d1842 2
a1843 4
		case CRYPTO_AES_CBC:
			get_random_bytes(ses->hs_iv,
			    (c->cri_alg == CRYPTO_AES_CBC ?
			    HIFN_AES_IV_LENGTH : HIFN_IV_LENGTH));
d1869 2
a1870 1
	*sidp = HIFN_SID(sc->sc_dv.dv_unit, sesn);
d1881 2
a1882 1
hifn_freesession(u_int64_t tid)
d1894 1
a1894 1
	if (session >= sc->sc_nsessions)
d1902 2
a1903 1
hifn_process(struct cryptop *crp)
d1906 1
a1906 1
	int card, session, err, ivlen;
d1923 1
a1923 1
	if (session >= sc->sc_nsessions) {
a1962 1
		    crd1->crd_alg == CRYPTO_AES_CBC ||
a1980 1
		     crd2->crd_alg == CRYPTO_AES_CBC ||
a1987 1
		     crd1->crd_alg == CRYPTO_AES_CBC ||
d2011 4
a2025 5
		case CRYPTO_AES_CBC:
			cmd->cry_masks |= HIFN_CRYPT_CMD_ALG_AES |
			    HIFN_CRYPT_CMD_MODE_CBC |
			    HIFN_CRYPT_CMD_NEW_IV;
			break;
a2030 2
			ivlen = ((enccrd->crd_alg == CRYPTO_AES_CBC) ?
			    HIFN_AES_IV_LENGTH : HIFN_IV_LENGTH);
d2033 2
a2034 1
					bcopy(enccrd->crd_iv, cmd->iv, ivlen);
d2037 1
a2037 1
					    cmd->iv, ivlen);
d2044 1
a2044 1
						    ivlen, cmd->iv);
d2048 1
a2048 1
						    ivlen, cmd->iv);
d2052 2
a2053 1
					bcopy(enccrd->crd_iv, cmd->iv, ivlen);
d2057 1
a2057 1
					    ivlen, cmd->iv);
d2061 1
a2061 1
					    ivlen, cmd->iv);
a2066 1
		cmd->cry_masks |= HIFN_CRYPT_CMD_NEW_KEY;
d2068 2
a2069 20
		/*
		 * Need to specify the size for the AES key in the masks.
		 */
		if ((cmd->cry_masks & HIFN_CRYPT_CMD_ALG_MASK) ==
		    HIFN_CRYPT_CMD_ALG_AES) {
			switch (cmd->cklen) {
			case 16:
				cmd->cry_masks |= HIFN_CRYPT_CMD_KSZ_128;
				break;
			case 24:
				cmd->cry_masks |= HIFN_CRYPT_CMD_KSZ_192;
				break;
			case 32:
				cmd->cry_masks |= HIFN_CRYPT_CMD_KSZ_256;
				break;
			default:
				err = EINVAL;
				goto errout;
			}
		}
d2099 3
a2101 2
		if (maccrd->crd_alg == CRYPTO_SHA1_HMAC ||
		     maccrd->crd_alg == CRYPTO_MD5_HMAC) {
d2114 6
a2119 1
	if (!err)
d2121 1
d2136 2
a2137 1
hifn_abort(struct hifn_softc *sc)
d2198 5
d2209 4
a2212 2
hifn_callback(struct hifn_softc *sc, struct hifn_command *cmd,
    u_int8_t *resbuf)
d2218 1
a2218 1
	int totlen, i, u, ivlen;
d2252 1
a2252 1
			    cmd->sloplen, &dma->slop[cmd->slopidx]);
d2256 1
a2256 1
			    cmd->sloplen, &dma->slop[cmd->slopidx]);
d2284 1
a2284 2
			    crd->crd_alg != CRYPTO_3DES_CBC &&
			    crd->crd_alg != CRYPTO_AES_CBC)
a2285 2
			ivlen = ((crd->crd_alg == CRYPTO_AES_CBC) ?
			    HIFN_AES_IV_LENGTH : HIFN_IV_LENGTH);
d2288 2
a2289 1
				    crd->crd_skip + crd->crd_len - ivlen, ivlen,
d2293 2
a2294 1
				    crd->crd_skip + crd->crd_len - ivlen, ivlen,
d2752 5
a2756 2
hifn_write_4(struct hifn_softc *sc, int reggrp, bus_size_t reg,
    u_int32_t val)
d2779 4
a2782 1
hifn_read_4(struct hifn_softc *sc, int reggrp, bus_size_t reg)
@


1.6.2.11
log
@Merge with the trunk
@
text
@d699 1
a699 1
		offtbl = "LZS";
d702 1
a702 1
		offtbl = "LZS DES";
d705 1
a705 1
		offtbl = "LZS 3DES ARC4 MD5 SHA1";
d711 1
a711 8
	printf(": %s", offtbl);
	if (sc->sc_flags & HIFN_HAS_RNG)
		printf(" RNG");
	if (sc->sc_flags & HIFN_HAS_AES)
		printf(" AES");
	if (sc->sc_flags & HIFN_HAS_PUBLIC)
		printf(" PK");
	printf(", ");
a1945 5
	}

	if (crp->crp_ilen == 0) {
		err = EINVAL;
		goto errout;
@


1.5
log
@nuke *vm_alloc_page_contig, use bus_dma
@
text
@d1 1
a1 1
/*	$OpenBSD: aeon.c,v 1.4 1999/12/06 07:29:56 art Exp $	*/
d101 3
@


1.4
log
@Make this work for uvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: aeon.c,v 1.3 1999/02/24 06:09:45 deraadt Exp $	*/
d118 4
d157 29
a185 7
#if defined(UVM)
	sc->sc_dma = (struct aeon_dma *)uvm_pagealloc_contig(sizeof(*sc->sc_dma),
	    0x100000, 0xffffffff, PAGE_SIZE);
#else
	sc->sc_dma = (struct aeon_dma *)vm_page_alloc_contig(sizeof(*sc->sc_dma),
	    0x100000, 0xffffffff, PAGE_SIZE);
#endif
@


1.3
log
@handle scatter-gather, seperate src/dst mbuf, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: aeon.c,v 1.2 1999/02/21 00:05:14 deraadt Exp $	*/
d153 4
d159 1
@


1.2
log
@use src/dst descriptor chaining out of an mbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: aeon.c,v 1.1 1999/02/19 02:52:19 deraadt Exp $	*/
d78 6
a83 6
u_int32_t aeon_write_command __P((const struct aeon_command_buf_data *,
    u_int8_t *));
int aeon_build_command __P((const struct aeon_command * cmd,
    struct aeon_command_buf_data *));
void aeon_intr_process_ring __P((struct aeon_softc *, struct aeon_dma *));

d409 1
a409 1
	for (i = 0; i < AEON_D_RSIZE; i++) {
d411 1
d413 5
a417 5
	}
	dma->cmdr[AEON_D_RSIZE].p = vtophys(dma->cmdr);
	dma->srcr[AEON_D_RSIZE].p = vtophys(dma->srcr);
	dma->dstr[AEON_D_RSIZE].p = vtophys(dma->dstr);
	dma->resr[AEON_D_RSIZE].p = vtophys(dma->resr);
d424 1
a424 1
u_int32_t 
d542 1
a542 1
	if (cmd->source_length <= mac_length) {
d547 1
a547 1
	if (cmd->dest_length < cmd->source_length + dest_diff) {
d549 1
a549 1
		    cmd->dest_length, cmd->source_length + dest_diff);
d574 2
a575 2
	base_cmd->total_source_count = cmd->source_length;
	base_cmd->total_dest_count = cmd->dest_length;
d616 1
a616 1
		mac_cmd->source_count = cmd->source_length - cmd->mac_header_skip;
d643 1
a643 1
		crypt_cmd->source_count = cmd->source_length - cmd->crypt_header_skip;
d675 63
d746 2
a747 12
	int	cmdi, srci, dsti, resi;
	int     error, s;
#define MAX_SCATTER 10
	long	packp[MAX_SCATTER];
	int	packl[MAX_SCATTER];
	struct	mbuf *m0, *m = cmd->m;
	int	nchunks, i;

	if (aeon_build_command(cmd, &cmd_buf_data) != 0)
		return AEON_CRYPTO_BAD_INPUT;

	s = splimp();
d756 20
a775 11
#if 1
	printf("%s: Entering command"
	    " -- Status Reg 0x%08x"
	    " -- Interrupt Enable Reg 0x%08x"
	    " -- slots in use %u"
	    " -- source length %u"
	    " -- dest length %u\n",
	    sc->sc_dv.dv_xname,
	    READ_REG_1(sc, AEON_STATUS), READ_REG_1(sc, AEON_IRQEN),
	    dma->slots_in_use, cmd->source_length, cmd->dest_length);
#endif
d777 4
a780 9
	/*
	 * Generate a [pa,len] array from an mbuf.
	 * This is very broken
	 */
	nchunks = 0;
	for (m0 = m; m; m = m->m_next) {
		void *va;
		long pg, npg;
		int len, off;
d782 2
a783 2
		va = m->m_data;
		len = m->m_len;
d785 5
a789 4
		packl[nchunks] = len;
		packp[nchunks] = vtophys(va);
		pg = packp[nchunks] & ~PAGE_MASK;
		off = (long)va & PAGE_MASK;
d791 1
a791 15
		while (len + off > PAGE_SIZE) {
			va = va + PAGE_SIZE - off;
			npg = vtophys(va);
			if (npg != pg) {
				nchunks++;
				break;
			}
			packl[nchunks] = PAGE_SIZE - off;
			off = 0;
			++nchunks;
			packl[nchunks] = len - (PAGE_SIZE - off);
			len -= packl[nchunks];
			packp[nchunks] = vtophys(va);
		} 
	}
d797 5
a801 3
	while (dma->cmdu+1 == AEON_D_RSIZE || dma->srcu+nchunks == AEON_D_RSIZE ||
	    dma->dstu+nchunks == AEON_D_RSIZE || dma->resu+1 == AEON_D_RSIZE) {
		if (cmd->flags & AEON_DMA_FULL_NOBLOCK)
d804 1
a806 2
	dma->cmdu += 1;
	dma->resu += 1;
d808 1
a808 1
	if (dma->cmdi == AEON_D_RSIZE) {
d810 1
a810 1
		dma->cmdr[AEON_D_RSIZE].l = AEON_D_VALID | AEON_D_LAST |
d815 1
a815 1
	if (dma->resi == AEON_D_RSIZE) {
d817 1
a817 1
		dma->resr[AEON_D_RSIZE].l = AEON_D_VALID | AEON_D_LAST |
d824 1
a824 4

	/*
	 * .p for command/result already set
	 */
d827 1
d829 1
a829 1
	for (i = 0; i < nchunks; i++) {
d832 1
a832 1
		if (i == nchunks-1)
d835 1
a835 1
		if (dma->srci == AEON_D_RSIZE) {
d837 1
a837 1
			dma->srcr[AEON_D_RSIZE].l = AEON_D_VALID |
d841 5
a845 1
		dma->srcu++;
d847 2
a848 3
		dma->srcr[srci].p = vtophys(packp[i]);
		dma->srcr[srci].l = packl[i] | AEON_D_VALID |
		    AEON_D_MASKDONEIRQ | last;
d850 1
a850 1
		if (dma->dsti == AEON_D_RSIZE) {
d852 1
a852 1
			dma->dstr[AEON_D_RSIZE].l = AEON_D_VALID |
d856 2
a857 4
		dma->dstu++;

		dma->dstr[dsti].p = vtophys(packp[i]);
		dma->dstr[dsti].l = packl[i] | AEON_D_VALID |
d860 1
d867 1
d894 1
a894 3
	printf("%s: command executed"
	    " -- Status Register 0x%08x"
	    " -- Interrupt Enable Reg 0x%08x\n",
a901 38
/*
 * Part of interrupt handler--cleans out done jobs from rings
 */
void
aeon_intr_process_ring(struct aeon_softc *sc, struct aeon_dma *dma)
{
	if (dma->slots_in_use > AEON_D_RSIZE)
		printf("%s: Internal Error -- ring overflow\n",
		    sc->sc_dv.dv_xname);

	while (dma->slots_in_use > 0) {
		u_int32_t wake_pos = dma->wakeup_rpos;
		struct aeon_command *cmd = dma->aeon_commands[wake_pos];

		/* if still valid, stop processing */
		if (dma->resr[wake_pos].l & AEON_D_VALID)
			break;

		if (AEON_USING_MAC(cmd->flags) && (cmd->flags & AEON_DECODE)) {
			u_int8_t *result_buf = dma->result_bufs[wake_pos];

			cmd->result_status = (result_buf[8] & 0x2) ? AEON_MAC_BAD : 0;
			printf("%s: byte index 8 of result 0x%02x\n",
			    sc->sc_dv.dv_xname, (u_int32_t) result_buf[8]);
		}

		/* position is done, notify producer with wakup or callback */
		if (cmd->dest_ready_callback == NULL)
			wakeup((caddr_t) &dma->resr[wake_pos]);
		else
			cmd->dest_ready_callback(cmd);

		if (++dma->wakeup_rpos == AEON_D_RSIZE)
			dma->wakeup_rpos = 0;
		dma->slots_in_use--;
	}
}

a907 1
	int r = 0;
d909 1
a909 5
#if 1
	printf("%s: Processing Interrupt"
	    " -- Status Reg 0x%08x"
	    " -- Interrupt Enable Reg 0x%08x"
	    " -- slots in use %u\n",
d912 2
a913 3
	    dma->slots_in_use);
#endif

a920 1
		r = 1;
d922 31
a952 2
		aeon_intr_process_ring(sc, dma);
		r = 1;
a954 5
#if 1
	printf("%s: exiting interrupt handler -- slots in use %u\n",
	    sc->sc_dv.dv_xname, dma->slots_in_use);
#endif

d961 1
a961 1
	return (r);
@


1.1
log
@invertex aeon driver base
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d17 1
a17 1
 *    notice, this list of conditions and the following disclaimer.
d19 2
a20 2
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d22 1
a22 1
 *    derived from this software without specific prior written permission.
d42 1
a63 12
void aeon_reset_board	__P((struct aeon_softc *));
int aeon_enable_crypto	__P((struct aeon_softc *));
void aeon_init_dma	__P((struct aeon_softc *));
void aeon_init_pci_registers __P((struct aeon_softc *));
int aeon_ram_setting_okay __P((struct aeon_softc *));
int aeon_intr		__P((void *));
u_int32_t aeon_write_command __P((const struct aeon_command_buf_data *,
    u_int8_t *));
int aeon_build_command __P((const struct aeon_command * cmd,
    struct aeon_command_buf_data *));
void aeon_intr_process_ring __P((struct aeon_softc *, struct aeon_dma *));

d72 13
a90 1

a104 3
/*
 * Purpose:  One time initialization for the device performed at bootup.
 */
d168 2
a169 2
	if (aeon_ram_setting_okay(sc) != 0)
		sc->is_dram_model = 1;
d203 2
a204 2
 * Purpose:  Resets the board.  Values in the regesters are left as is
 *           from the reset (i.e. initial values are assigned elsewhere).
d242 3
a244 7
 * Purpose:   Checks to see if crypto is already enabled.  If crypto
 *            isn't enable, "aeon_enable_crypto" is called to enable it.
 *            The check is important, as enabling crypto twice will lock
 *            the board.
 *
 * Returns:   0 value on success, -1 if we were not able to unlock the
 *            cryptographic engine.
d259 1
a259 1
	encryption_level = READ_REG_0(sc, AEON_ENCRYPTION_LEVEL);
d299 2
a300 3
 *  Purpose:   Give initial values to the registers listed in the
 *             "Register Space" section of the AEON Software Development
 *             reference manual.
d306 1
a306 5
	u_int32_t ram_config;

	/*
	 *  Write fixed values needed by the Initialization registers
	 */
d311 5
a315 11
	/*
	 *  Write all 4 ring address registers
	 */
	WRITE_REG_1(sc, AEON_COMMAND_RING_ADDR,
	    vtophys(sc->sc_dma->command_ring));
	WRITE_REG_1(sc, AEON_SOURCE_RING_ADDR,
	    vtophys(sc->sc_dma->source_ring));
	WRITE_REG_1(sc, AEON_DEST_RING_ADDR,
	    vtophys(sc->sc_dma->dest_ring));
	WRITE_REG_1(sc, AEON_RESULT_RING_ADDR,
	    vtophys(sc->sc_dma->result_ring));
d317 1
a317 3
	/*
	 *  Write status register
	 */
d319 1
d321 1
a321 9
	/*
	 *  Write registers which had thier initial values defined
	 *  elsewhere.  The "Encryption level register" is the only
	 *  documented register not initialized by this routine (it's read
	 *  only).
	 */
	WRITE_REG_1(sc, AEON_INTERRUPT_ENABLE, AEON_INIT_INTERRUPT_ENABLE_REG);

	ram_config = AEON_INIT_RAM_CONFIG_REG
d323 1
a323 1
	    | (0x1 << 7)
d325 4
a328 2
	    | (sc->is_dram_model << 4);
	WRITE_REG_0(sc, AEON_RAM_CONFIG, ram_config);
d334 6
a339 7
 *  Purpose:   There are both DRAM and SRAM models of the aeon board.
 *             A bit in the "ram configuration register" needs to be
 *             set according to the model.  The driver will guess one
 *             way or the other -- and then call this routine to verify.
 *  Returns:
 *     0: RAM setting okay
 *    -1: Current RAM setting in error
d342 1
a342 1
aeon_ram_setting_okay(sc)
d350 2
d353 1
a353 4
	const u_int32_t masks = AEON_DESCRIPT_VALID | AEON_DESCRIPT_LAST |
	    AEON_DESCRIPT_MASK_DONE_IRQ;

#if (AEON_DESCRIPT_RING_SIZE < 3)
d358 2
a359 2
	 *  We steal the 8 bytes needed for both the source and dest buffers
	 *  from the 3rd slot that the DRAM/SRAM test won't use.
d364 1
a364 3
	/*
	 *  Build write command
	 */
d368 2
a369 2
	dma->source_ring[0].pointer = vtophys(source_buf);
	dma->dest_ring[0].pointer = vtophys(dest_buf);
d371 4
a374 4
	dma->command_ring[0].length = 16 | masks;
	dma->source_ring[0].length = 8 | masks;
	dma->dest_ring[0].length = 8 | masks;
	dma->result_ring[0].length = AEON_MAX_RESULT_LENGTH | masks;
d376 2
a377 6
	/*
	 *  Let write command execute
	 */
	DELAY(1000);

	if (dma->result_ring[0].length & AEON_DESCRIPT_VALID)
d381 1
a381 3
	/*
	 *  Build read command
	 */
d384 6
a389 2
	dma->source_ring[1].pointer = vtophys(source_buf);
	dma->dest_ring[1].pointer = vtophys(dest_buf);
d391 2
a392 11
	dma->command_ring[1].length = 16 | masks;
	dma->source_ring[1].length = 8 | masks;
	dma->dest_ring[1].length = 8 | masks;
	dma->result_ring[1].length = AEON_MAX_RESULT_LENGTH | masks;

	/*
	 *  Let read command execute
	 */
	DELAY(1000);

	if (dma->result_ring[1].length & AEON_DESCRIPT_VALID)
a394 1

d399 1
a399 1
 *  Purpose:   Initialize the descriptor rings.
d405 1
a406 1
	struct aeon_dma *dma = sc->sc_dma;
d408 4
a411 6
	/*
	 *  Initialize static pointer values.
	 */
	for (i = 0; i < AEON_DESCRIPT_RING_SIZE; i++) {
		dma->command_ring[i].pointer = vtophys(dma->command_bufs[i]);
		dma->result_ring[i].pointer = vtophys(dma->result_bufs[i]);
d413 4
a416 12

	dma->command_ring[AEON_DESCRIPT_RING_SIZE].pointer =
	    vtophys(dma->command_ring);

	dma->source_ring[AEON_DESCRIPT_RING_SIZE].pointer =
	    vtophys(dma->source_ring);

	dma->dest_ring[AEON_DESCRIPT_RING_SIZE].pointer =
	    vtophys(dma->dest_ring);

	dma->result_ring[AEON_DESCRIPT_RING_SIZE].pointer =
	    vtophys(dma->result_ring);
d420 2
a421 2
 *  Purpose:   Writes out the raw command buffer space.  Returns the
 *             command buffer size.
d424 2
a425 4
aeon_write_command(
    const struct aeon_command_buf_data * cmd_data,
    u_int8_t * command_buf
)
a430 1

d434 1
a434 3
	/*
	 *  Write base command structure
	 */
d438 1
a438 3
	/*
	 *  Write MAC command structure
	 */
d443 2
a444 3
	/*
	 *  Write encryption command structure
	 */
d449 4
a452 5
	/*
	 *  Write MAC key
	 */
	if (mac_cmd->masks & AEON_MAC_CMD_NEW_KEY) {
		bcopy(cmd_data->mac_key, command_buf_pos, AEON_MAC_KEY_LENGTH);
d455 2
a456 3
	/*
	 *  Write crypto key
	 */
d461 1
a461 1
		bcopy(cmd_data->crypt_key, command_buf_pos, key_len);
d464 2
a465 3
	/*
	 *  Write crypto iv
	 */
d467 1
a467 1
		bcopy(cmd_data->initial_vector, command_buf_pos, AEON_IV_LENGTH);
d470 2
a471 4
	/*
	 *  Write 8 bytes of zero's if we're not sending crypt or MAC
	 *  structures
	 */
d479 2
a480 2
#if 0
	if ((command_buf_pos - command_buf) > AEON_MAX_COMMAND_LENGTH)
a481 2
#endif

a482 1

d486 3
a488 3
 *  Purpose:   Check command input and build up structure to write
 *             the command buffer later.  Returns 0 on success and
 *             -1 if given bad command input was given.
d491 2
a492 4
aeon_build_command(
    const struct aeon_command * cmd,
    struct aeon_command_buf_data * cmd_buf_data
)
a500 1

a506 1

d524 1
a524 1
	 *  Compute the mac value length -- leave at zero if not MAC'ing
d533 1
a533 1
	 *  Check for valid src/dest buf sizes
d537 2
a538 2
	 *   XXX XXX  We need to include header counts into all these
	 *            checks!!!!
a552 6

	/**
	 **  Building up base command
	 **
	 **/

d554 1
a554 1
	 *  Set MAC bit
d564 1
a564 1
	 *  Set Decode bit
d570 2
a571 2
	 *  Set total source and dest counts.  These values are the same as the
	 *  values set in the length field of the source and dest descriptor rings.
d577 1
a577 1
	 *  XXX -- We need session number range checking...
d588 1
a588 1
		 *  Set the MAC algorithm and trunc setting
d596 4
a599 4
	         *  We always use HMAC mode, assume MAC values are appended to the
	         *  source buffer on decodes and we append them to the dest buffer
	         *  on encodes, and order auth/encryption engines as needed by
	         *  IPSEC
d605 1
a605 1
	         *  Setup to send new MAC key if needed.
d607 1
a607 1
		if (flags & AEON_MAC_CMD_NEW_KEY) {
d609 1
a609 1
			cmd_buf_data->mac_key = cmd->mac_key;
d612 1
a612 1
	         *  Set the mac header skip and source count.
d614 1
d619 1
a619 4
	/**
	 **  Building up crypto command
	 **
	 **/
a620 1

d622 1
a622 1
	         *  Set the encryption algorithm bits.
d632 1
a632 1
	         *  Setup to send new encrypt key if needed.
d636 1
a636 1
			cmd_buf_data->crypt_key = cmd->crypt_key;
d639 1
a639 1
	         *  Set the encrypt header skip and source count.
d655 1
a655 1
	cmd_buf_data->initial_vector = cmd->initial_vector;
d658 1
a658 1
#if 0
d665 4
a668 8
	    base_cmd->session_num,
	    base_cmd->total_source_count,
	    base_cmd->total_dest_count,
	    mac_cmd->header_skip,
	    mac_cmd->source_count,
	    crypt_cmd->header_skip,
	    crypt_cmd->source_count
	    );
a673 4

/*
 *  Function:  aeon_process_command
 */
d675 1
a675 1
aeon_crypto(struct aeon_command * cmd)
d677 1
a677 5
	u_int32_t command_length;

	u_int32_t local_ring_pos;
	int     err;
	int     oldint;
d679 10
a688 6
	struct aeon_softc *sc;
	struct aeon_dma *dma;
	const u_int32_t masks = AEON_DESCRIPT_VALID | AEON_DESCRIPT_LAST |
	AEON_DESCRIPT_MASK_DONE_IRQ;

	struct aeon_command_buf_data cmd_buf_data;
d693 1
a693 4
	/*
	 *  Turning off interrupts
	 */
	oldint = splimp();
d702 1
a702 1
#if 0
d710 2
a711 6
	    READ_REG_1(sc, AEON_STATUS),
	    READ_REG_1(sc, AEON_INTERRUPT_ENABLE),
	    dma->slots_in_use,
	    cmd->source_length,
	    cmd->dest_length
	    );
d714 33
d748 6
a753 2
	if (dma->slots_in_use == AEON_DESCRIPT_RING_SIZE) {

d755 3
a757 11
			return AEON_CRYPTO_RINGS_FULL;

		do {
#ifdef AEON_DEBUG
			printf("%s: Waiting for unused ring.\n",
			    sc->sc_dv.dv_xname);
#endif
			/* sleep for minimum timeout */
			tsleep((caddr_t) dma, PZERO, "QFULL", 1);

		} while (dma->slots_in_use == AEON_DESCRIPT_RING_SIZE);
d759 2
a760 1
	dma->slots_in_use++;
d762 6
d769 6
a774 6
	if (dma->ring_pos == AEON_DESCRIPT_RING_SIZE) {
		local_ring_pos = 0;
		dma->ring_pos = 1;
	} else {
		local_ring_pos = dma->ring_pos++;
	}
d776 2
d779 5
a783 2
	command_length =
	    aeon_write_command(&cmd_buf_data, dma->command_bufs[local_ring_pos]);
d785 2
a786 1
	dma->aeon_commands[local_ring_pos] = cmd;
d788 2
a789 7
	/*
	 *  If we wrapped to the begining of the ring, validate the jump
	 *  descriptor.  (Not needed on the very first time command -- but it
	 *  doesn't hurt.)
	 */
	if (local_ring_pos == 0) {
		const u_int32_t jmp_masks = masks | AEON_DESCRIPT_JUMP;
d791 7
a797 9
		dma->command_ring[AEON_DESCRIPT_RING_SIZE].length = jmp_masks;
		dma->source_ring[AEON_DESCRIPT_RING_SIZE].length = jmp_masks;
		dma->dest_ring[AEON_DESCRIPT_RING_SIZE].length = jmp_masks;
		dma->result_ring[AEON_DESCRIPT_RING_SIZE].length = jmp_masks;
	}
	/*
	 *  "pointer" values for command and result descriptors are already set
	 */
	dma->command_ring[local_ring_pos].length = command_length | masks;
d799 3
a801 2
	dma->source_ring[local_ring_pos].pointer = vtophys(cmd->source_buf);
	dma->source_ring[local_ring_pos].length = cmd->source_length | masks;
d803 7
a809 2
	dma->dest_ring[local_ring_pos].pointer = vtophys(cmd->dest_buf);
	dma->dest_ring[local_ring_pos].length = cmd->dest_length | masks;
d811 4
d817 2
a818 2
	 *  Unlike other descriptors, we don't mask done interrupt from
	 *  result descriptor.
d820 1
a820 2
	dma->result_ring[local_ring_pos].length =
	    AEON_MAX_RESULT_LENGTH | AEON_DESCRIPT_VALID | AEON_DESCRIPT_LAST;
d823 3
a825 3
	 *  We don't worry about missing an interrupt (which a waiting
	 *  on command interrupt salvages us from), unless there is more
	 *  than one command in the queue.
d828 1
a828 1
		WRITE_REG_1(sc, AEON_INTERRUPT_ENABLE,
d831 1
d833 2
a834 2
	 *  If not given a callback routine, we block until the dest data is
	 *  ready.  (Setting interrupt timeout at 3 seconds.)
a836 1
#if 0
d839 1
a839 2
#endif
		err = tsleep((caddr_t) & dma->result_ring[local_ring_pos], PZERO, "CRYPT",
d841 1
a841 1
		if (err != 0)
d844 1
a844 1
			    sc->sc_dv.dv_xname, err);
d846 1
a846 1
#if 0
d851 1
a851 8
	    READ_REG_1(sc, AEON_STATUS),
	    READ_REG_1(sc, AEON_INTERRUPT_ENABLE));
#endif

	/*
	 *  Turning interupts back on
	 */
	splx(oldint);
d853 1
d858 1
a858 1
 *  Part of interrupt handler--cleans out done jobs from rings
d861 1
a861 3
aeon_intr_process_ring(sc, dma)
	struct aeon_softc *sc;
	struct aeon_dma *dma;
d863 1
a863 1
	if (dma->slots_in_use > AEON_DESCRIPT_RING_SIZE)
d868 1
a868 1
		u_int32_t wake_pos = dma->wakeup_ring_pos;
d871 2
a872 4
		/*
	         *  If still valid, stop processing
	         */
		if (dma->result_ring[wake_pos].length & AEON_DESCRIPT_VALID)
d877 1
d882 5
a886 6
		/*
	         *  Position is done, notify producer with wakup or callback
	         */
		if (cmd->dest_ready_callback == NULL) {
			wakeup((caddr_t) &dma->result_ring[wake_pos]);
		} else {
a887 1
		}
d889 2
a890 2
		if (++dma->wakeup_ring_pos == AEON_DESCRIPT_RING_SIZE)
			dma->wakeup_ring_pos = 0;
a892 1

a894 5
/*
 *  Purpose:   Interrupt handler.  The argument passed is the device
 *             structure for the board that generated the interrupt.
 *             XXX:  Remove hardcoded status checking/setting values.
 */
d901 1
a901 1
	int r;
d903 1
a903 1
#if 0
d909 2
a910 4
	    READ_REG_1(sc, AEON_STATUS),
	    READ_REG_1(sc, AEON_INTERRUPT_ENABLE),
	    dma->slots_in_use
	    );
d916 2
a917 2
		 * result" interrupt, we disable the "waiting on result" (by
		 * clearing it).
d919 2
a920 3
		WRITE_REG_1(sc, AEON_INTERRUPT_ENABLE,
		    AEON_INTR_ON_RESULT_DONE);
		r  = 1;
d926 1
a926 1
#if 0
d932 3
a934 3
	 *  Clear "result done" and "waiting on command ring" flags in status
	 *  register.  If we still have slots to process and we received a
	 *  waiting interrupt, this will interupt us again.
a938 1

@

