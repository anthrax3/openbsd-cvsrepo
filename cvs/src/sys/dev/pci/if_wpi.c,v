head	1.140;
access;
symbols
	OPENBSD_6_2:1.140.0.4
	OPENBSD_6_2_BASE:1.140
	OPENBSD_6_1:1.139.0.4
	OPENBSD_6_1_BASE:1.139
	OPENBSD_6_0:1.133.0.4
	OPENBSD_6_0_BASE:1.133
	OPENBSD_5_9:1.132.0.2
	OPENBSD_5_9_BASE:1.132
	OPENBSD_5_8:1.127.0.4
	OPENBSD_5_8_BASE:1.127
	OPENBSD_5_7:1.124.0.4
	OPENBSD_5_7_BASE:1.124
	OPENBSD_5_6:1.120.0.4
	OPENBSD_5_6_BASE:1.120
	OPENBSD_5_5:1.117.0.4
	OPENBSD_5_5_BASE:1.117
	OPENBSD_5_4:1.111.0.2
	OPENBSD_5_4_BASE:1.111
	OPENBSD_5_3:1.110.0.8
	OPENBSD_5_3_BASE:1.110
	OPENBSD_5_2:1.110.0.6
	OPENBSD_5_2_BASE:1.110
	OPENBSD_5_1_BASE:1.110
	OPENBSD_5_1:1.110.0.4
	OPENBSD_5_0:1.110.0.2
	OPENBSD_5_0_BASE:1.110
	OPENBSD_4_9:1.109.0.2
	OPENBSD_4_9_BASE:1.109
	OPENBSD_4_8:1.104.0.2
	OPENBSD_4_8_BASE:1.104
	OPENBSD_4_7:1.99.0.2
	OPENBSD_4_7_BASE:1.99
	OPENBSD_4_6:1.88.0.4
	OPENBSD_4_6_BASE:1.88
	OPENBSD_4_5:1.83.0.2
	OPENBSD_4_5_BASE:1.83
	OPENBSD_4_4:1.63.0.2
	OPENBSD_4_4_BASE:1.63
	OPENBSD_4_3:1.58.0.2
	OPENBSD_4_3_BASE:1.58
	OPENBSD_4_2:1.50.0.2
	OPENBSD_4_2_BASE:1.50
	OPENBSD_4_1:1.38.0.2
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.31.0.2
	OPENBSD_4_0_BASE:1.31;
locks; strict;
comment	@ * @;


1.140
date	2017.04.08.02.57.25;	author deraadt;	state Exp;
branches;
next	1.139;
commitid	6s3MfY9d6ZKdL2Uz;

1.139
date	2017.03.08.12.02.41;	author mpi;	state Exp;
branches;
next	1.138;
commitid	okVP7pbbXG8IxGgU;

1.138
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.137;
commitid	VyLWTsbepAOk7VQM;

1.137
date	2016.12.23.18.44.51;	author kettenis;	state Exp;
branches;
next	1.136;
commitid	0uXR4ucQpYhtKo0H;

1.136
date	2016.10.05.21.26.54;	author stsp;	state Exp;
branches;
next	1.135;
commitid	OAqmq6H99R0TS0AM;

1.135
date	2016.09.05.08.18.40;	author tedu;	state Exp;
branches;
next	1.134;
commitid	Wg4G3vdtTfPyfHAy;

1.134
date	2016.08.17.11.08.08;	author stsp;	state Exp;
branches;
next	1.133;
commitid	sI17N0M4sL6v52Ag;

1.133
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.132;
commitid	8YSL8ByWzGeIGBiJ;

1.132
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.131;
commitid	B0kwmVGiD5DVx4kv;

1.131
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.130;
commitid	5DvsamK0GblTp8ww;

1.130
date	2015.11.04.12.11.59;	author dlg;	state Exp;
branches;
next	1.129;
commitid	YT6fyIEviv9qwbl6;

1.129
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.128;
commitid	hPF95ClMUQfeqQDX;

1.128
date	2015.09.06.04.09.59;	author deraadt;	state Exp;
branches;
next	1.127;
commitid	v2laFpRHnFClq4Va;

1.127
date	2015.05.27.22.10.52;	author kettenis;	state Exp;
branches;
next	1.126;
commitid	lWmV3RdleHaEaZ4U;

1.126
date	2015.03.16.04.09.53;	author jsg;	state Exp;
branches;
next	1.125;
commitid	VSofcdbznJCBaPnY;

1.125
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.124;
commitid	p4LJxGKbi0BU2cG6;

1.124
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.123;
commitid	Hly9lJn6CNMylcFu;

1.123
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.122;
commitid	MyKPm9Q3dQu92BiX;

1.122
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.121;
commitid	yM2VFFhpDTeFQlve;

1.121
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.120;
commitid	LS2TNeCue5R9L67C;

1.120
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.119;
commitid	TGHgrLxu6sxZoiFt;

1.119
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.118;
commitid	OBNa5kfxQ2UXoiIw;

1.118
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.117;

1.117
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.116;

1.116
date	2013.11.28.20.07.32;	author kettenis;	state Exp;
branches;
next	1.115;

1.115
date	2013.11.16.12.46.29;	author kettenis;	state Exp;
branches;
next	1.114;

1.114
date	2013.11.14.12.34.30;	author dlg;	state Exp;
branches;
next	1.113;

1.113
date	2013.10.01.20.06.02;	author sf;	state Exp;
branches;
next	1.112;

1.112
date	2013.08.07.01.06.39;	author bluhm;	state Exp;
branches;
next	1.111;

1.111
date	2013.06.11.18.15.52;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2011.06.02.18.36.53;	author mk;	state Exp;
branches;
next	1.109;

1.109
date	2010.09.07.16.21.45;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	2010.08.27.20.09.01;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.106;

1.106
date	2010.08.12.16.59.29;	author damien;	state Exp;
branches;
next	1.105;

1.105
date	2010.08.12.15.04.00;	author oga;	state Exp;
branches;
next	1.104;

1.104
date	2010.08.03.18.26.25;	author kettenis;	state Exp;
branches;
next	1.103;

1.103
date	2010.07.28.21.21.38;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2010.07.22.14.42.43;	author kettenis;	state Exp;
branches;
next	1.101;

1.101
date	2010.07.22.10.22.37;	author kettenis;	state Exp;
branches;
next	1.100;

1.100
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.99;

1.99
date	2009.11.17.20.35.51;	author damien;	state Exp;
branches;
next	1.98;

1.98
date	2009.11.03.18.55.23;	author damien;	state Exp;
branches;
next	1.97;

1.97
date	2009.10.31.11.52.07;	author damien;	state Exp;
branches;
next	1.96;

1.96
date	2009.10.26.18.38.32;	author damien;	state Exp;
branches;
next	1.95;

1.95
date	2009.10.24.21.01.18;	author damien;	state Exp;
branches;
next	1.94;

1.94
date	2009.10.24.20.17.17;	author damien;	state Exp;
branches;
next	1.93;

1.93
date	2009.10.24.18.19.49;	author damien;	state Exp;
branches;
next	1.92;

1.92
date	2009.09.20.20.04.07;	author damien;	state Exp;
branches;
next	1.91;

1.91
date	2009.08.10.17.21.15;	author damien;	state Exp;
branches;
next	1.90;

1.90
date	2009.08.09.11.40.56;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2009.07.11.13.28.36;	author blambert;	state Exp;
branches;
next	1.88;

1.88
date	2009.06.02.16.28.21;	author damien;	state Exp;
branches;
next	1.87;

1.87
date	2009.05.29.08.25.45;	author damien;	state Exp;
branches;
next	1.86;

1.86
date	2009.05.12.19.10.57;	author damien;	state Exp;
branches;
next	1.85;

1.85
date	2009.04.26.02.20.58;	author cnst;	state Exp;
branches;
next	1.84;

1.84
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.83;

1.83
date	2009.02.05.17.10.49;	author damien;	state Exp;
branches;
next	1.82;

1.82
date	2009.01.26.19.18.52;	author damien;	state Exp;
branches;
next	1.81;

1.81
date	2009.01.03.10.11.55;	author damien;	state Exp;
branches;
next	1.80;

1.80
date	2008.12.22.18.20.47;	author damien;	state Exp;
branches;
next	1.79;

1.79
date	2008.12.21.18.19.58;	author damien;	state Exp;
branches;
next	1.78;

1.78
date	2008.12.03.17.17.08;	author damien;	state Exp;
branches;
next	1.77;

1.77
date	2008.12.03.14.47.17;	author cnst;	state Exp;
branches;
next	1.76;

1.76
date	2008.11.25.22.20.11;	author damien;	state Exp;
branches;
next	1.75;

1.75
date	2008.11.25.21.43.57;	author damien;	state Exp;
branches;
next	1.74;

1.74
date	2008.11.25.17.06.26;	author damien;	state Exp;
branches;
next	1.73;

1.73
date	2008.11.22.08.23.52;	author brad;	state Exp;
branches;
next	1.72;

1.72
date	2008.11.16.09.52.31;	author damien;	state Exp;
branches;
next	1.71;

1.71
date	2008.11.09.10.00.17;	author damien;	state Exp;
branches;
next	1.70;

1.70
date	2008.11.09.09.55.42;	author chl;	state Exp;
branches;
next	1.69;

1.69
date	2008.11.08.18.42.49;	author damien;	state Exp;
branches;
next	1.68;

1.68
date	2008.11.08.14.09.03;	author damien;	state Exp;
branches;
next	1.67;

1.67
date	2008.11.08.12.21.36;	author damien;	state Exp;
branches;
next	1.66;

1.66
date	2008.11.08.11.02.09;	author damien;	state Exp;
branches;
next	1.65;

1.65
date	2008.11.08.10.54.29;	author damien;	state Exp;
branches;
next	1.64;

1.64
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.63;

1.63
date	2008.07.31.20.14.17;	author damien;	state Exp;
branches;
next	1.62;

1.62
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.61;

1.61
date	2008.06.16.18.43.06;	author damien;	state Exp;
branches;
next	1.60;

1.60
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.59;

1.59
date	2008.03.08.16.24.45;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2007.11.19.19.34.25;	author damien;	state Exp;
branches;
next	1.57;

1.57
date	2007.11.03.13.10.29;	author damien;	state Exp;
branches;
next	1.56;

1.56
date	2007.09.11.18.52.32;	author damien;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.11.18.06.11;	author damien;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.10.20.34.43;	author damien;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.07.19.05.05;	author damien;	state Exp;
branches;
next	1.52;

1.52
date	2007.08.28.18.34.38;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2007.08.22.19.50.25;	author damien;	state Exp;
branches;
next	1.50;

1.50
date	2007.08.10.16.29.27;	author jasper;	state Exp;
branches;
next	1.49;

1.49
date	2007.07.24.16.07.47;	author damien;	state Exp;
branches;
next	1.48;

1.48
date	2007.07.11.16.50.12;	author damien;	state Exp;
branches;
next	1.47;

1.47
date	2007.07.10.18.29.38;	author damien;	state Exp;
branches;
next	1.46;

1.46
date	2007.07.05.20.29.22;	author damien;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.16.14.15.37;	author damien;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.11.19.26.42;	author damien;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.09.09.50.00;	author damien;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.06.20.33.18;	author damien;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.06.20.14.04;	author damien;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.06.18.06.05;	author cnst;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.05.19.49.40;	author damien;	state Exp;
branches;
next	1.38;

1.38
date	2007.01.03.18.19.06;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.26.11.14.22;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2006.11.13.20.06.38;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2006.11.01.11.25.01;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2006.10.23.18.19.26;	author damien;	state Exp;
branches;
next	1.33;

1.33
date	2006.10.23.18.16.56;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2006.09.18.16.20.20;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2006.08.28.19.47.42;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2006.08.20.14.01.07;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2006.08.18.16.04.56;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2006.08.10.09.23.32;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2006.08.06.13.12.32;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2006.08.06.12.51.09;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2006.08.04.14.30.03;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2006.08.03.09.45.20;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2006.08.01.13.08.21;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2006.08.01.12.43.56;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.17.19.07.19;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.17.18.35.46;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.16.18.54.09;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.14.19.31.47;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.14.18.40.23;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.10.20.34.45;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.05.16.42.21;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.29.20.26.54;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.25.09.26.58;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.20.15.46.55;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.20.15.31.30;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.20.13.24.02;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.20.12.44.47;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.20.11.47.29;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.19.18.44.56;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.19.18.28.23;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.19.18.24.08;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.19.18.14.35;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.17.19.50.35;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.16.05.57.44;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.14.19.00.48;	author damien;	state Exp;
branches;
next	;


desc
@@


1.140
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@/*	$OpenBSD: if_wpi.c,v 1.139 2017/03/08 12:02:41 mpi Exp $	*/

/*-
 * Copyright (c) 2006-2008
 *	Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Driver for Intel PRO/Wireless 3945ABG 802.11 network adapters.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/rwlock.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/task.h>
#include <sys/endian.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/pci/if_wpireg.h>
#include <dev/pci/if_wpivar.h>

static const struct pci_matchid wpi_devices[] = {
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_WL_3945ABG_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_PRO_WL_3945ABG_2 }
};

int		wpi_match(struct device *, void *, void *);
void		wpi_attach(struct device *, struct device *, void *);
#if NBPFILTER > 0
void		wpi_radiotap_attach(struct wpi_softc *);
#endif
int		wpi_detach(struct device *, int);
int		wpi_activate(struct device *, int);
void		wpi_wakeup(struct wpi_softc *);
void		wpi_init_task(void *);
int		wpi_nic_lock(struct wpi_softc *);
int		wpi_read_prom_data(struct wpi_softc *, uint32_t, void *, int);
int		wpi_dma_contig_alloc(bus_dma_tag_t, struct wpi_dma_info *,
		    void **, bus_size_t, bus_size_t);
void		wpi_dma_contig_free(struct wpi_dma_info *);
int		wpi_alloc_shared(struct wpi_softc *);
void		wpi_free_shared(struct wpi_softc *);
int		wpi_alloc_fwmem(struct wpi_softc *);
void		wpi_free_fwmem(struct wpi_softc *);
int		wpi_alloc_rx_ring(struct wpi_softc *, struct wpi_rx_ring *);
void		wpi_reset_rx_ring(struct wpi_softc *, struct wpi_rx_ring *);
void		wpi_free_rx_ring(struct wpi_softc *, struct wpi_rx_ring *);
int		wpi_alloc_tx_ring(struct wpi_softc *, struct wpi_tx_ring *,
		    int);
void		wpi_reset_tx_ring(struct wpi_softc *, struct wpi_tx_ring *);
void		wpi_free_tx_ring(struct wpi_softc *, struct wpi_tx_ring *);
int		wpi_read_eeprom(struct wpi_softc *);
void		wpi_read_eeprom_channels(struct wpi_softc *, int);
void		wpi_read_eeprom_group(struct wpi_softc *, int);
struct		ieee80211_node *wpi_node_alloc(struct ieee80211com *);
void		wpi_newassoc(struct ieee80211com *, struct ieee80211_node *,
		    int);
int		wpi_media_change(struct ifnet *);
int		wpi_newstate(struct ieee80211com *, enum ieee80211_state, int);
void		wpi_iter_func(void *, struct ieee80211_node *);
void		wpi_calib_timeout(void *);
int		wpi_ccmp_decap(struct wpi_softc *, struct mbuf *,
		    struct ieee80211_key *);
void		wpi_rx_done(struct wpi_softc *, struct wpi_rx_desc *,
		    struct wpi_rx_data *);
void		wpi_tx_done(struct wpi_softc *, struct wpi_rx_desc *);
void		wpi_cmd_done(struct wpi_softc *, struct wpi_rx_desc *);
void		wpi_notif_intr(struct wpi_softc *);
void		wpi_fatal_intr(struct wpi_softc *);
int		wpi_intr(void *);
int		wpi_tx(struct wpi_softc *, struct mbuf *,
		    struct ieee80211_node *);
void		wpi_start(struct ifnet *);
void		wpi_watchdog(struct ifnet *);
int		wpi_ioctl(struct ifnet *, u_long, caddr_t);
int		wpi_cmd(struct wpi_softc *, int, const void *, int, int);
int		wpi_mrr_setup(struct wpi_softc *);
void		wpi_updateedca(struct ieee80211com *);
void		wpi_set_led(struct wpi_softc *, uint8_t, uint8_t, uint8_t);
int		wpi_set_timing(struct wpi_softc *, struct ieee80211_node *);
void		wpi_power_calibration(struct wpi_softc *);
int		wpi_set_txpower(struct wpi_softc *, int);
int		wpi_get_power_index(struct wpi_softc *,
		    struct wpi_power_group *, struct ieee80211_channel *, int);
int		wpi_set_pslevel(struct wpi_softc *, int, int, int);
int		wpi_config(struct wpi_softc *);
int		wpi_scan(struct wpi_softc *, uint16_t);
int		wpi_auth(struct wpi_softc *);
int		wpi_run(struct wpi_softc *);
int		wpi_set_key(struct ieee80211com *, struct ieee80211_node *,
		    struct ieee80211_key *);
void		wpi_delete_key(struct ieee80211com *, struct ieee80211_node *,
		    struct ieee80211_key *);
int		wpi_post_alive(struct wpi_softc *);
int		wpi_load_bootcode(struct wpi_softc *, const uint8_t *, int);
int		wpi_load_firmware(struct wpi_softc *);
int		wpi_read_firmware(struct wpi_softc *);
int		wpi_clock_wait(struct wpi_softc *);
int		wpi_apm_init(struct wpi_softc *);
void		wpi_apm_stop_master(struct wpi_softc *);
void		wpi_apm_stop(struct wpi_softc *);
void		wpi_nic_config(struct wpi_softc *);
int		wpi_hw_init(struct wpi_softc *);
void		wpi_hw_stop(struct wpi_softc *);
int		wpi_init(struct ifnet *);
void		wpi_stop(struct ifnet *, int);

#ifdef WPI_DEBUG
#define DPRINTF(x)	do { if (wpi_debug > 0) printf x; } while (0)
#define DPRINTFN(n, x)	do { if (wpi_debug >= (n)) printf x; } while (0)
int wpi_debug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n, x)
#endif

struct cfdriver wpi_cd = {
	NULL, "wpi", DV_IFNET
};

struct cfattach wpi_ca = {
	sizeof (struct wpi_softc), wpi_match, wpi_attach, wpi_detach,
	wpi_activate
};

int
wpi_match(struct device *parent, void *match, void *aux)
{
	return pci_matchbyid((struct pci_attach_args *)aux, wpi_devices,
	    nitems(wpi_devices));
}

void
wpi_attach(struct device *parent, struct device *self, void *aux)
{
	struct wpi_softc *sc = (struct wpi_softc *)self;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct pci_attach_args *pa = aux;
	const char *intrstr;
	pci_intr_handle_t ih;
	pcireg_t memtype, reg;
	int i, error;

	sc->sc_pct = pa->pa_pc;
	sc->sc_pcitag = pa->pa_tag;
	sc->sc_dmat = pa->pa_dmat;

	/*
	 * Get the offset of the PCI Express Capability Structure in PCI
	 * Configuration Space (the vendor driver hard-codes it as E0h.)
	 */
	error = pci_get_capability(sc->sc_pct, sc->sc_pcitag,
	    PCI_CAP_PCIEXPRESS, &sc->sc_cap_off, NULL);
	if (error == 0) {
		printf(": PCIe capability structure not found!\n");
		return;
	}

	/* Clear device-specific "PCI retry timeout" register (41h). */
	reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag, 0x40);
	reg &= ~0xff00;
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0x40, reg);

	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, WPI_PCI_BAR0);
	error = pci_mapreg_map(pa, WPI_PCI_BAR0, memtype, 0, &sc->sc_st,
	    &sc->sc_sh, NULL, &sc->sc_sz, 0);
	if (error != 0) {
		printf(": can't map mem space\n");
		return;
	}

	/* Install interrupt handler. */
	if (pci_intr_map_msi(pa, &ih) != 0 && pci_intr_map(pa, &ih) != 0) {
		printf(": can't map interrupt\n");
		return;
	}
	intrstr = pci_intr_string(sc->sc_pct, ih);
	sc->sc_ih = pci_intr_establish(sc->sc_pct, ih, IPL_NET, wpi_intr, sc,
	    sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": can't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s", intrstr);

	/* Power ON adapter. */
	if ((error = wpi_apm_init(sc)) != 0) {
		printf(": could not power ON adapter\n");
		return;
	}

	/* Read MAC address, channels, etc from EEPROM. */
	if ((error = wpi_read_eeprom(sc)) != 0) {
		printf(": could not read EEPROM\n");
		return;
	}

	/* Allocate DMA memory for firmware transfers. */
	if ((error = wpi_alloc_fwmem(sc)) != 0) {
		printf(": could not allocate memory for firmware\n");
		return;
	}

	/* Allocate shared area. */
	if ((error = wpi_alloc_shared(sc)) != 0) {
		printf(": could not allocate shared area\n");
		goto fail1;
	}

	/* Allocate TX rings. */
	for (i = 0; i < WPI_NTXQUEUES; i++) {
		if ((error = wpi_alloc_tx_ring(sc, &sc->txq[i], i)) != 0) {
			printf(": could not allocate TX ring %d\n", i);
			goto fail2;
		}
	}

	/* Allocate RX ring. */
	if ((error = wpi_alloc_rx_ring(sc, &sc->rxq)) != 0) {
		printf(": could not allocate Rx ring\n");
		goto fail2;
	}

	/* Power OFF adapter. */
	wpi_apm_stop(sc);
	/* Clear pending interrupts. */
	WPI_WRITE(sc, WPI_INT, 0xffffffff);

	ic->ic_phytype = IEEE80211_T_OFDM;	/* not only, but not used */
	ic->ic_opmode = IEEE80211_M_STA;	/* default to BSS mode */
	ic->ic_state = IEEE80211_S_INIT;

	/* Set device capabilities. */
	ic->ic_caps =
	    IEEE80211_C_WEP |		/* WEP */
	    IEEE80211_C_RSN |		/* WPA/RSN */
	    IEEE80211_C_SCANALL |	/* device scans all channels at once */
	    IEEE80211_C_SCANALLBAND |	/* driver scans all bands at once */
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
	    IEEE80211_C_SHSLOT |	/* short slot time supported */
	    IEEE80211_C_SHPREAMBLE |	/* short preamble supported */
	    IEEE80211_C_PMGT;		/* power saving supported */

	/* Set supported rates. */
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ieee80211_std_rateset_11g;
	if (sc->sc_flags & WPI_FLAG_HAS_5GHZ) {
		ic->ic_sup_rates[IEEE80211_MODE_11A] =
		    ieee80211_std_rateset_11a;
	}

	/* IBSS channel undefined for now. */
	ic->ic_ibss_chan = &ic->ic_channels[0];

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = wpi_ioctl;
	ifp->if_start = wpi_start;
	ifp->if_watchdog = wpi_watchdog;
	memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);

	if_attach(ifp);
	ieee80211_ifattach(ifp);
	ic->ic_node_alloc = wpi_node_alloc;
	ic->ic_newassoc = wpi_newassoc;
	ic->ic_updateedca = wpi_updateedca;
	ic->ic_set_key = wpi_set_key;
	ic->ic_delete_key = wpi_delete_key;

	/* Override 802.11 state transition machine. */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = wpi_newstate;
	ieee80211_media_init(ifp, wpi_media_change, ieee80211_media_status);

	sc->amrr.amrr_min_success_threshold =  1;
	sc->amrr.amrr_max_success_threshold = 15;

#if NBPFILTER > 0
	wpi_radiotap_attach(sc);
#endif
	timeout_set(&sc->calib_to, wpi_calib_timeout, sc);
	rw_init(&sc->sc_rwlock, "wpilock");
	task_set(&sc->init_task, wpi_init_task, sc);
	return;

	/* Free allocated memory if something failed during attachment. */
fail2:	while (--i >= 0)
		wpi_free_tx_ring(sc, &sc->txq[i]);
	wpi_free_shared(sc);
fail1:	wpi_free_fwmem(sc);
}

#if NBPFILTER > 0
/*
 * Attach the interface to 802.11 radiotap.
 */
void
wpi_radiotap_attach(struct wpi_softc *sc)
{
	bpfattach(&sc->sc_drvbpf, &sc->sc_ic.ic_if, DLT_IEEE802_11_RADIO,
	    sizeof (struct ieee80211_frame) + IEEE80211_RADIOTAP_HDRLEN);

	sc->sc_rxtap_len = sizeof sc->sc_rxtapu;
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(WPI_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof sc->sc_txtapu;
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(WPI_TX_RADIOTAP_PRESENT);
}
#endif

int
wpi_detach(struct device *self, int flags)
{
	struct wpi_softc *sc = (struct wpi_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int qid;

	timeout_del(&sc->calib_to);
	task_del(systq, &sc->init_task);

	/* Uninstall interrupt handler. */
	if (sc->sc_ih != NULL)
		pci_intr_disestablish(sc->sc_pct, sc->sc_ih);

	/* Free DMA resources. */
	wpi_free_rx_ring(sc, &sc->rxq);
	for (qid = 0; qid < WPI_NTXQUEUES; qid++)
		wpi_free_tx_ring(sc, &sc->txq[qid]);
	wpi_free_shared(sc);
	wpi_free_fwmem(sc);

	bus_space_unmap(sc->sc_st, sc->sc_sh, sc->sc_sz);

	ieee80211_ifdetach(ifp);
	if_detach(ifp);

	return 0;
}

int
wpi_activate(struct device *self, int act)
{
	struct wpi_softc *sc = (struct wpi_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			wpi_stop(ifp, 0);
		break;
	case DVACT_WAKEUP:
		wpi_wakeup(sc);
		break;
	}

	return 0;
}

void
wpi_wakeup(struct wpi_softc *sc)
{
	pcireg_t reg;

	/* Clear device-specific "PCI retry timeout" register (41h). */
	reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag, 0x40);
	reg &= ~0xff00;
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0x40, reg);

	wpi_init_task(sc);
}

void
wpi_init_task(void *arg1)
{
	struct wpi_softc *sc = arg1;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int s;

	rw_enter_write(&sc->sc_rwlock);
	s = splnet();

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == IFF_UP)
		wpi_init(ifp);

	splx(s);
	rw_exit_write(&sc->sc_rwlock);
}

int
wpi_nic_lock(struct wpi_softc *sc)
{
	int ntries;

	/* Request exclusive access to NIC. */
	WPI_SETBITS(sc, WPI_GP_CNTRL, WPI_GP_CNTRL_MAC_ACCESS_REQ);

	/* Spin until we actually get the lock. */
	for (ntries = 0; ntries < 1000; ntries++) {
		if ((WPI_READ(sc, WPI_GP_CNTRL) &
		     (WPI_GP_CNTRL_MAC_ACCESS_ENA | WPI_GP_CNTRL_SLEEP)) ==
		    WPI_GP_CNTRL_MAC_ACCESS_ENA)
			return 0;
		DELAY(10);
	}
	return ETIMEDOUT;
}

static __inline void
wpi_nic_unlock(struct wpi_softc *sc)
{
	WPI_CLRBITS(sc, WPI_GP_CNTRL, WPI_GP_CNTRL_MAC_ACCESS_REQ);
}

static __inline uint32_t
wpi_prph_read(struct wpi_softc *sc, uint32_t addr)
{
	WPI_WRITE(sc, WPI_PRPH_RADDR, WPI_PRPH_DWORD | addr);
	WPI_BARRIER_READ_WRITE(sc);
	return WPI_READ(sc, WPI_PRPH_RDATA);
}

static __inline void
wpi_prph_write(struct wpi_softc *sc, uint32_t addr, uint32_t data)
{
	WPI_WRITE(sc, WPI_PRPH_WADDR, WPI_PRPH_DWORD | addr);
	WPI_BARRIER_WRITE(sc);
	WPI_WRITE(sc, WPI_PRPH_WDATA, data);
}

static __inline void
wpi_prph_setbits(struct wpi_softc *sc, uint32_t addr, uint32_t mask)
{
	wpi_prph_write(sc, addr, wpi_prph_read(sc, addr) | mask);
}

static __inline void
wpi_prph_clrbits(struct wpi_softc *sc, uint32_t addr, uint32_t mask)
{
	wpi_prph_write(sc, addr, wpi_prph_read(sc, addr) & ~mask);
}

static __inline void
wpi_prph_write_region_4(struct wpi_softc *sc, uint32_t addr,
    const uint32_t *data, int count)
{
	for (; count > 0; count--, data++, addr += 4)
		wpi_prph_write(sc, addr, *data);
}

#ifdef WPI_DEBUG

static __inline uint32_t
wpi_mem_read(struct wpi_softc *sc, uint32_t addr)
{
	WPI_WRITE(sc, WPI_MEM_RADDR, addr);
	WPI_BARRIER_READ_WRITE(sc);
	return WPI_READ(sc, WPI_MEM_RDATA);
}

static __inline void  
wpi_mem_write(struct wpi_softc *sc, uint32_t addr, uint32_t data)
{
	WPI_WRITE(sc, WPI_MEM_WADDR, addr);
	WPI_BARRIER_WRITE(sc);
	WPI_WRITE(sc, WPI_MEM_WDATA, data);
}

static __inline void
wpi_mem_read_region_4(struct wpi_softc *sc, uint32_t addr, uint32_t *data,
    int count)
{
	for (; count > 0; count--, addr += 4)
		*data++ = wpi_mem_read(sc, addr);
}

#endif

int
wpi_read_prom_data(struct wpi_softc *sc, uint32_t addr, void *data, int count)
{
	uint8_t *out = data;
	uint32_t val;
	int error, ntries;

	if ((error = wpi_nic_lock(sc)) != 0)
		return error;

	for (; count > 0; count -= 2, addr++) {
		WPI_WRITE(sc, WPI_EEPROM, addr << 2);
		WPI_CLRBITS(sc, WPI_EEPROM, WPI_EEPROM_CMD);

		for (ntries = 0; ntries < 10; ntries++) {
			val = WPI_READ(sc, WPI_EEPROM);
			if (val & WPI_EEPROM_READ_VALID)
				break;
			DELAY(5);
		}
		if (ntries == 10) {
			printf("%s: could not read EEPROM\n",
			    sc->sc_dev.dv_xname);
			return ETIMEDOUT;
		}
		*out++ = val >> 16;
		if (count > 1)
			*out++ = val >> 24;
	}

	wpi_nic_unlock(sc);
	return 0;
}

int
wpi_dma_contig_alloc(bus_dma_tag_t tag, struct wpi_dma_info *dma, void **kvap,
    bus_size_t size, bus_size_t alignment)
{
	int nsegs, error;

	dma->tag = tag;
	dma->size = size;

	error = bus_dmamap_create(tag, size, 1, size, 0, BUS_DMA_NOWAIT,
	    &dma->map);
	if (error != 0)
		goto fail;

	error = bus_dmamem_alloc(tag, size, alignment, 0, &dma->seg, 1, &nsegs,
	    BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error != 0)
		goto fail;

	error = bus_dmamem_map(tag, &dma->seg, 1, size, &dma->vaddr,
	    BUS_DMA_NOWAIT | BUS_DMA_COHERENT);
	if (error != 0)
		goto fail;

	error = bus_dmamap_load_raw(tag, dma->map, &dma->seg, 1, size,
	    BUS_DMA_NOWAIT);
	if (error != 0)
		goto fail;

	bus_dmamap_sync(tag, dma->map, 0, size, BUS_DMASYNC_PREWRITE);

	dma->paddr = dma->map->dm_segs[0].ds_addr;
	if (kvap != NULL)
		*kvap = dma->vaddr;

	return 0;

fail:	wpi_dma_contig_free(dma);
	return error;
}

void
wpi_dma_contig_free(struct wpi_dma_info *dma)
{
	if (dma->map != NULL) {
		if (dma->vaddr != NULL) {
			bus_dmamap_sync(dma->tag, dma->map, 0, dma->size,
			    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(dma->tag, dma->map);
			bus_dmamem_unmap(dma->tag, dma->vaddr, dma->size);
			bus_dmamem_free(dma->tag, &dma->seg, 1);
			dma->vaddr = NULL;
		}
		bus_dmamap_destroy(dma->tag, dma->map);
		dma->map = NULL;
	}
}

int
wpi_alloc_shared(struct wpi_softc *sc)
{
	/* Shared buffer must be aligned on a 4KB boundary. */
	return wpi_dma_contig_alloc(sc->sc_dmat, &sc->shared_dma,
	    (void **)&sc->shared, sizeof (struct wpi_shared), 4096);
}

void
wpi_free_shared(struct wpi_softc *sc)
{
	wpi_dma_contig_free(&sc->shared_dma);
}

int
wpi_alloc_fwmem(struct wpi_softc *sc)
{
	/* Allocate enough contiguous space to store text and data. */
	return wpi_dma_contig_alloc(sc->sc_dmat, &sc->fw_dma, NULL,
	    WPI_FW_TEXT_MAXSZ + WPI_FW_DATA_MAXSZ, 16);
}

void
wpi_free_fwmem(struct wpi_softc *sc)
{
	wpi_dma_contig_free(&sc->fw_dma);
}

int
wpi_alloc_rx_ring(struct wpi_softc *sc, struct wpi_rx_ring *ring)
{
	bus_size_t size;
	int i, error;

	ring->cur = 0;

	/* Allocate RX descriptors (16KB aligned.) */
	size = WPI_RX_RING_COUNT * sizeof (uint32_t);
	error = wpi_dma_contig_alloc(sc->sc_dmat, &ring->desc_dma,
	    (void **)&ring->desc, size, 16 * 1024);
	if (error != 0) {
		printf("%s: could not allocate RX ring DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/*
	 * Allocate and map RX buffers.
	 */
	for (i = 0; i < WPI_RX_RING_COUNT; i++) {
		struct wpi_rx_data *data = &ring->data[i];

		error = bus_dmamap_create(sc->sc_dmat, WPI_RBUF_SIZE, 1,
		    WPI_RBUF_SIZE, 0, BUS_DMA_NOWAIT, &data->map);
		if (error != 0) {
			printf("%s: could not create RX buf DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		data->m = MCLGETI(NULL, M_DONTWAIT, NULL, WPI_RBUF_SIZE);
		if (data->m == NULL) {
			printf("%s: could not allocate RX mbuf\n",
			    sc->sc_dev.dv_xname);
			error = ENOBUFS;
			goto fail;
		}

		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(data->m, void *), WPI_RBUF_SIZE, NULL,
		    BUS_DMA_NOWAIT | BUS_DMA_READ);
		if (error != 0) {
			printf("%s: can't map mbuf (error %d)\n",
			    sc->sc_dev.dv_xname, error);
			goto fail;
		}

		/* Set physical address of RX buffer. */
		ring->desc[i] = htole32(data->map->dm_segs[0].ds_addr);
	}

	bus_dmamap_sync(sc->sc_dmat, ring->desc_dma.map, 0, size,
	    BUS_DMASYNC_PREWRITE);

	return 0;

fail:	wpi_free_rx_ring(sc, ring);
	return error;
}

void
wpi_reset_rx_ring(struct wpi_softc *sc, struct wpi_rx_ring *ring)
{
	int ntries;

	if (wpi_nic_lock(sc) == 0) {
		WPI_WRITE(sc, WPI_FH_RX_CONFIG, 0);
		for (ntries = 0; ntries < 100; ntries++) {
			if (WPI_READ(sc, WPI_FH_RX_STATUS) &
			    WPI_FH_RX_STATUS_IDLE)
				break;
			DELAY(10);
		}
		wpi_nic_unlock(sc);
	}
	ring->cur = 0;
}

void
wpi_free_rx_ring(struct wpi_softc *sc, struct wpi_rx_ring *ring)
{
	int i;

	wpi_dma_contig_free(&ring->desc_dma);

	for (i = 0; i < WPI_RX_RING_COUNT; i++) {
		struct wpi_rx_data *data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_sync(sc->sc_dmat, data->map, 0,
			    data->map->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
		}
		if (data->map != NULL)
			bus_dmamap_destroy(sc->sc_dmat, data->map);
	}
}

int
wpi_alloc_tx_ring(struct wpi_softc *sc, struct wpi_tx_ring *ring, int qid)
{
	bus_addr_t paddr;
	bus_size_t size;
	int i, error;

	ring->qid = qid;
	ring->queued = 0;
	ring->cur = 0;

	/* Allocate TX descriptors (16KB aligned.) */
	size = WPI_TX_RING_COUNT * sizeof (struct wpi_tx_desc);
	error = wpi_dma_contig_alloc(sc->sc_dmat, &ring->desc_dma,
	    (void **)&ring->desc, size, 16 * 1024);
	if (error != 0) {
		printf("%s: could not allocate TX ring DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/* Update shared area with ring physical address. */
	sc->shared->txbase[qid] = htole32(ring->desc_dma.paddr);
	bus_dmamap_sync(sc->sc_dmat, sc->shared_dma.map, 0,
	    sizeof (struct wpi_shared), BUS_DMASYNC_PREWRITE);

	/*
	 * We only use rings 0 through 4 (4 EDCA + cmd) so there is no need
	 * to allocate commands space for other rings.
	 * XXX Do we really need to allocate descriptors for other rings?
	 */
	if (qid > 4)
		return 0;

	size = WPI_TX_RING_COUNT * sizeof (struct wpi_tx_cmd);
	error = wpi_dma_contig_alloc(sc->sc_dmat, &ring->cmd_dma,
	    (void **)&ring->cmd, size, 4);
	if (error != 0) {
		printf("%s: could not allocate TX cmd DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	paddr = ring->cmd_dma.paddr;
	for (i = 0; i < WPI_TX_RING_COUNT; i++) {
		struct wpi_tx_data *data = &ring->data[i];

		data->cmd_paddr = paddr;
		paddr += sizeof (struct wpi_tx_cmd);

		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    WPI_MAX_SCATTER - 1, MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &data->map);
		if (error != 0) {
			printf("%s: could not create TX buf DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
	}
	return 0;

fail:	wpi_free_tx_ring(sc, ring);
	return error;
}

void
wpi_reset_tx_ring(struct wpi_softc *sc, struct wpi_tx_ring *ring)
{
	int i;

	for (i = 0; i < WPI_TX_RING_COUNT; i++) {
		struct wpi_tx_data *data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_sync(sc->sc_dmat, data->map, 0,
			    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
			data->m = NULL;
		}
	}
	/* Clear TX descriptors. */
	memset(ring->desc, 0, ring->desc_dma.size);
	sc->qfullmsk &= ~(1 << ring->qid);
	ring->queued = 0;
	ring->cur = 0;
}

void
wpi_free_tx_ring(struct wpi_softc *sc, struct wpi_tx_ring *ring)
{
	int i;

	wpi_dma_contig_free(&ring->desc_dma);
	wpi_dma_contig_free(&ring->cmd_dma);

	for (i = 0; i < WPI_TX_RING_COUNT; i++) {
		struct wpi_tx_data *data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_sync(sc->sc_dmat, data->map, 0,
			    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
		}
		if (data->map != NULL)
			bus_dmamap_destroy(sc->sc_dmat, data->map);
	}
}

int
wpi_read_eeprom(struct wpi_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	char domain[4];
	int i;

	if ((WPI_READ(sc, WPI_EEPROM_GP) & 0x6) == 0) {
		printf("%s: bad EEPROM signature\n", sc->sc_dev.dv_xname);
		return EIO;
	}
	/* Clear HW ownership of EEPROM. */
	WPI_CLRBITS(sc, WPI_EEPROM_GP, WPI_EEPROM_GP_IF_OWNER);

	wpi_read_prom_data(sc, WPI_EEPROM_CAPABILITIES, &sc->cap, 1);
	wpi_read_prom_data(sc, WPI_EEPROM_REVISION, &sc->rev, 2);
	wpi_read_prom_data(sc, WPI_EEPROM_TYPE, &sc->type, 1);

	DPRINTF(("cap=%x rev=%x type=%x\n", sc->cap, letoh16(sc->rev),
	    sc->type));

	/* Read and print regulatory domain (4 ASCII characters.) */
	wpi_read_prom_data(sc, WPI_EEPROM_DOMAIN, domain, 4);
	printf(", %.4s", domain);

	/* Read and print MAC address. */
	wpi_read_prom_data(sc, WPI_EEPROM_MAC, ic->ic_myaddr, 6);
	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));

	/* Read the list of authorized channels. */
	for (i = 0; i < WPI_CHAN_BANDS_COUNT; i++)
		wpi_read_eeprom_channels(sc, i);

	/* Read the list of TX power groups. */
	for (i = 0; i < WPI_POWER_GROUPS_COUNT; i++)
		wpi_read_eeprom_group(sc, i);

	return 0;
}

void
wpi_read_eeprom_channels(struct wpi_softc *sc, int n)
{
	struct ieee80211com *ic = &sc->sc_ic;
	const struct wpi_chan_band *band = &wpi_bands[n];
	struct wpi_eeprom_chan channels[WPI_MAX_CHAN_PER_BAND];
	int chan, i;

	wpi_read_prom_data(sc, band->addr, channels,
	    band->nchan * sizeof (struct wpi_eeprom_chan));

	for (i = 0; i < band->nchan; i++) {
		if (!(channels[i].flags & WPI_EEPROM_CHAN_VALID))
			continue;

		chan = band->chan[i];

		if (n == 0) {	/* 2GHz band */
			ic->ic_channels[chan].ic_freq =
			    ieee80211_ieee2mhz(chan, IEEE80211_CHAN_2GHZ);
			ic->ic_channels[chan].ic_flags =
			    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
			    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;

		} else {	/* 5GHz band */
			/*
			 * Some adapters support channels 7, 8, 11 and 12
			 * both in the 2GHz and 4.9GHz bands.
			 * Because of limitations in our net80211 layer,
			 * we don't support them in the 4.9GHz band.
			 */
			if (chan <= 14)
				continue;

			ic->ic_channels[chan].ic_freq =
			    ieee80211_ieee2mhz(chan, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[chan].ic_flags = IEEE80211_CHAN_A;
			/* We have at least one valid 5GHz channel. */
			sc->sc_flags |= WPI_FLAG_HAS_5GHZ;
		}

		/* Is active scan allowed on this channel? */
		if (!(channels[i].flags & WPI_EEPROM_CHAN_ACTIVE)) {
			ic->ic_channels[chan].ic_flags |=
			    IEEE80211_CHAN_PASSIVE;
		}

		/* Save maximum allowed TX power for this channel. */
		sc->maxpwr[chan] = channels[i].maxpwr;

		DPRINTF(("adding chan %d flags=0x%x maxpwr=%d\n",
		    chan, channels[i].flags, sc->maxpwr[chan]));
	}
}

void
wpi_read_eeprom_group(struct wpi_softc *sc, int n)
{
	struct wpi_power_group *group = &sc->groups[n];
	struct wpi_eeprom_group rgroup;
	int i;

	wpi_read_prom_data(sc, WPI_EEPROM_POWER_GRP + n * 32, &rgroup,
	    sizeof rgroup);

	/* Save TX power group information. */
	group->chan   = rgroup.chan;
	group->maxpwr = rgroup.maxpwr;
	/* Retrieve temperature at which the samples were taken. */
	group->temp   = (int16_t)letoh16(rgroup.temp);

	DPRINTF(("power group %d: chan=%d maxpwr=%d temp=%d\n", n,
	    group->chan, group->maxpwr, group->temp));

	for (i = 0; i < WPI_SAMPLES_COUNT; i++) {
		group->samples[i].index = rgroup.samples[i].index;
		group->samples[i].power = rgroup.samples[i].power;

		DPRINTF(("\tsample %d: index=%d power=%d\n", i,
		    group->samples[i].index, group->samples[i].power));
	}
}

struct ieee80211_node *
wpi_node_alloc(struct ieee80211com *ic)
{
	return malloc(sizeof (struct wpi_node), M_DEVBUF, M_NOWAIT | M_ZERO);
}

void
wpi_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni, int isnew)
{
	struct wpi_softc *sc = ic->ic_if.if_softc;
	struct wpi_node *wn = (void *)ni;
	uint8_t rate;
	int ridx, i;

	ieee80211_amrr_node_init(&sc->amrr, &wn->amn);
	/* Start at lowest available bit-rate, AMRR will raise. */
	ni->ni_txrate = 0;

	for (i = 0; i < ni->ni_rates.rs_nrates; i++) {
		rate = ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL;
		/* Map 802.11 rate to HW rate index. */
		for (ridx = 0; ridx <= WPI_RIDX_MAX; ridx++)
			if (wpi_rates[ridx].rate == rate)
				break;
		wn->ridx[i] = ridx;
	}
}

int
wpi_media_change(struct ifnet *ifp)
{
	struct wpi_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t rate, ridx;
	int error;

	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return error;

	if (ic->ic_fixed_rate != -1) {
		rate = ic->ic_sup_rates[ic->ic_curmode].
		    rs_rates[ic->ic_fixed_rate] & IEEE80211_RATE_VAL;
		/* Map 802.11 rate to HW rate index. */
		for (ridx = 0; ridx <= WPI_RIDX_MAX; ridx++)
			if (wpi_rates[ridx].rate == rate)
				break;
		sc->fixed_ridx = ridx;
	}

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
	    (IFF_UP | IFF_RUNNING)) {
		wpi_stop(ifp, 0);
		error = wpi_init(ifp);
	}
	return error;
}

int
wpi_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct ifnet *ifp = &ic->ic_if;
	struct wpi_softc *sc = ifp->if_softc;
	int error;

	timeout_del(&sc->calib_to);

	switch (nstate) {
	case IEEE80211_S_SCAN:
		/* Make the link LED blink while we're scanning. */
		wpi_set_led(sc, WPI_LED_LINK, 20, 2);

		if ((error = wpi_scan(sc, IEEE80211_CHAN_2GHZ)) != 0) {
			printf("%s: could not initiate scan\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
		ic->ic_state = nstate;
		return 0;

	case IEEE80211_S_ASSOC:
		if (ic->ic_state != IEEE80211_S_RUN)
			break;
		/* FALLTHROUGH */
	case IEEE80211_S_AUTH:
		/* Reset state to handle reassociations correctly. */
		sc->rxon.associd = 0;
		sc->rxon.filter &= ~htole32(WPI_FILTER_BSS);

		if ((error = wpi_auth(sc)) != 0) {
			printf("%s: could not move to auth state\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
		break;

	case IEEE80211_S_RUN:
		if ((error = wpi_run(sc)) != 0) {
			printf("%s: could not move to run state\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
		break;

	case IEEE80211_S_INIT:
		break;
	}

	return sc->sc_newstate(ic, nstate, arg);
}

void
wpi_iter_func(void *arg, struct ieee80211_node *ni)
{
	struct wpi_softc *sc = arg;
	struct wpi_node *wn = (struct wpi_node *)ni;

	ieee80211_amrr_choose(&sc->amrr, ni, &wn->amn);
}

void
wpi_calib_timeout(void *arg)
{
	struct wpi_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	int s;

	s = splnet();
	/* Automatic rate control triggered every 500ms. */
	if (ic->ic_fixed_rate == -1) {
		if (ic->ic_opmode == IEEE80211_M_STA)
			wpi_iter_func(sc, ic->ic_bss);
		else
			ieee80211_iterate_nodes(ic, wpi_iter_func, sc);
	}

	/* Force automatic TX power calibration every 60 secs. */
	if (++sc->calib_cnt >= 120) {
		wpi_power_calibration(sc);
		sc->calib_cnt = 0;
	}
	splx(s);

	/* Automatic rate control triggered every 500ms. */
	timeout_add_msec(&sc->calib_to, 500);
}

int
wpi_ccmp_decap(struct wpi_softc *sc, struct mbuf *m, struct ieee80211_key *k)
{
	struct ieee80211_frame *wh;
	uint64_t pn, *prsc;
	uint8_t *ivp;
	uint8_t tid;
	int hdrlen;

	wh = mtod(m, struct ieee80211_frame *);
	hdrlen = ieee80211_get_hdrlen(wh);
	ivp = (uint8_t *)wh + hdrlen;

	/* Check that ExtIV bit is be set. */
	if (!(ivp[3] & IEEE80211_WEP_EXTIV)) {
		DPRINTF(("CCMP decap ExtIV not set\n"));
		return 1;
	}
	tid = ieee80211_has_qos(wh) ?
	    ieee80211_get_qos(wh) & IEEE80211_QOS_TID : 0;
	prsc = &k->k_rsc[tid];

	/* Extract the 48-bit PN from the CCMP header. */
	pn = (uint64_t)ivp[0]       |
	     (uint64_t)ivp[1] <<  8 |
	     (uint64_t)ivp[4] << 16 |
	     (uint64_t)ivp[5] << 24 |
	     (uint64_t)ivp[6] << 32 |
	     (uint64_t)ivp[7] << 40;
	if (pn <= *prsc) {
		/*
		 * Not necessarily a replayed frame since we did not check
		 * the sequence number of the 802.11 header yet.
		 */
		DPRINTF(("CCMP replayed\n"));
		return 1;
	}
	/* Update last seen packet number. */
	*prsc = pn;

	/* Clear Protected bit and strip IV. */
	wh->i_fc[1] &= ~IEEE80211_FC1_PROTECTED;
	memmove(mtod(m, caddr_t) + IEEE80211_CCMP_HDRLEN, wh, hdrlen);
	m_adj(m, IEEE80211_CCMP_HDRLEN);
	/* Strip MIC. */
	m_adj(m, -IEEE80211_CCMP_MICLEN);
	return 0;
}

void
wpi_rx_done(struct wpi_softc *sc, struct wpi_rx_desc *desc,
    struct wpi_rx_data *data)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct wpi_rx_ring *ring = &sc->rxq;
	struct wpi_rx_stat *stat;
	struct wpi_rx_head *head;
	struct wpi_rx_tail *tail;
	struct ieee80211_frame *wh;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	struct mbuf *m, *m1;
	uint32_t flags;
	int error;

	bus_dmamap_sync(sc->sc_dmat, data->map, 0, WPI_RBUF_SIZE,
	    BUS_DMASYNC_POSTREAD);
	stat = (struct wpi_rx_stat *)(desc + 1);

	if (stat->len > WPI_STAT_MAXLEN) {
		printf("%s: invalid RX statistic header\n",
		    sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		return;
	}
	head = (struct wpi_rx_head *)((caddr_t)(stat + 1) + stat->len);
	tail = (struct wpi_rx_tail *)((caddr_t)(head + 1) + letoh16(head->len));
	flags = letoh32(tail->flags);

	/* Discard frames with a bad FCS early. */
	if ((flags & WPI_RX_NOERROR) != WPI_RX_NOERROR) {
		DPRINTFN(2, ("rx tail flags error %x\n", flags));
		ifp->if_ierrors++;
		return;
	}
	/* Discard frames that are too short. */
	if (letoh16(head->len) < sizeof (*wh)) {
		DPRINTF(("frame too short: %d\n", letoh16(head->len)));
		ic->ic_stats.is_rx_tooshort++;
		ifp->if_ierrors++;
		return;
	}

	m1 = MCLGETI(NULL, M_DONTWAIT, NULL, WPI_RBUF_SIZE);
	if (m1 == NULL) {
		ic->ic_stats.is_rx_nombuf++;
		ifp->if_ierrors++;
		return;
	}
	bus_dmamap_unload(sc->sc_dmat, data->map);

	error = bus_dmamap_load(sc->sc_dmat, data->map, mtod(m1, void *),
	    WPI_RBUF_SIZE, NULL, BUS_DMA_NOWAIT | BUS_DMA_READ);
	if (error != 0) {
		m_freem(m1);

		/* Try to reload the old mbuf. */
		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(data->m, void *), WPI_RBUF_SIZE, NULL,
		    BUS_DMA_NOWAIT | BUS_DMA_READ);
		if (error != 0) {
			panic("%s: could not load old RX mbuf",
			    sc->sc_dev.dv_xname);
		}
		/* Physical address may have changed. */
		ring->desc[ring->cur] = htole32(data->map->dm_segs[0].ds_addr);
		bus_dmamap_sync(sc->sc_dmat, ring->desc_dma.map,
		    ring->cur * sizeof (uint32_t), sizeof (uint32_t),
		    BUS_DMASYNC_PREWRITE);
		ifp->if_ierrors++;
		return;
	}

	m = data->m;
	data->m = m1;
	/* Update RX descriptor. */
	ring->desc[ring->cur] = htole32(data->map->dm_segs[0].ds_addr);
	bus_dmamap_sync(sc->sc_dmat, ring->desc_dma.map,
	    ring->cur * sizeof (uint32_t), sizeof (uint32_t),
	    BUS_DMASYNC_PREWRITE);

	/* Finalize mbuf. */
	m->m_data = (caddr_t)(head + 1);
	m->m_pkthdr.len = m->m_len = letoh16(head->len);

	/* Grab a reference to the source node. */
	wh = mtod(m, struct ieee80211_frame *);
	ni = ieee80211_find_rxnode(ic, wh);

	rxi.rxi_flags = 0;
	if ((wh->i_fc[1] & IEEE80211_FC1_PROTECTED) &&
	    !IEEE80211_IS_MULTICAST(wh->i_addr1) &&
	    (ni->ni_flags & IEEE80211_NODE_RXPROT) &&
	    ni->ni_pairwise_key.k_cipher == IEEE80211_CIPHER_CCMP) {
		if ((flags & WPI_RX_CIPHER_MASK) != WPI_RX_CIPHER_CCMP) {
			ic->ic_stats.is_ccmp_dec_errs++;
			ifp->if_ierrors++;
			m_freem(m);
			return;
		}
		/* Check whether decryption was successful or not. */
		if ((flags & WPI_RX_DECRYPT_MASK) != WPI_RX_DECRYPT_OK) {
			DPRINTF(("CCMP decryption failed 0x%x\n", flags));
			ic->ic_stats.is_ccmp_dec_errs++;
			ifp->if_ierrors++;
			m_freem(m);
			return;
		}
		if (wpi_ccmp_decap(sc, m, &ni->ni_pairwise_key) != 0) {
			ifp->if_ierrors++;
			m_freem(m);
			return;
		}
		rxi.rxi_flags |= IEEE80211_RXI_HWDEC;
	}

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct wpi_rx_radiotap_header *tap = &sc->sc_rxtap;

		tap->wr_flags = 0;
		if (letoh16(head->flags) & 0x4)
			tap->wr_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;
		tap->wr_chan_freq =
		    htole16(ic->ic_channels[head->chan].ic_freq);
		tap->wr_chan_flags =
		    htole16(ic->ic_channels[head->chan].ic_flags);
		tap->wr_dbm_antsignal = (int8_t)(stat->rssi - WPI_RSSI_OFFSET);
		tap->wr_dbm_antnoise = (int8_t)letoh16(stat->noise);
		tap->wr_tsft = tail->tstamp;
		tap->wr_antenna = (letoh16(head->flags) >> 4) & 0xf;
		switch (head->rate) {
		/* CCK rates. */
		case  10: tap->wr_rate =   2; break;
		case  20: tap->wr_rate =   4; break;
		case  55: tap->wr_rate =  11; break;
		case 110: tap->wr_rate =  22; break;
		/* OFDM rates. */
		case 0xd: tap->wr_rate =  12; break;
		case 0xf: tap->wr_rate =  18; break;
		case 0x5: tap->wr_rate =  24; break;
		case 0x7: tap->wr_rate =  36; break;
		case 0x9: tap->wr_rate =  48; break;
		case 0xb: tap->wr_rate =  72; break;
		case 0x1: tap->wr_rate =  96; break;
		case 0x3: tap->wr_rate = 108; break;
		/* Unknown rate: should not happen. */
		default:  tap->wr_rate =   0;
		}

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_rxtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
	}
#endif

	/* Send the frame to the 802.11 layer. */
	rxi.rxi_rssi = stat->rssi;
	rxi.rxi_tstamp = 0;	/* unused */
	ieee80211_input(ifp, m, ni, &rxi);

	/* Node is no longer needed. */
	ieee80211_release_node(ic, ni);
}

void
wpi_tx_done(struct wpi_softc *sc, struct wpi_rx_desc *desc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct wpi_tx_ring *ring = &sc->txq[desc->qid & 0x3];
	struct wpi_tx_data *data = &ring->data[desc->idx];
	struct wpi_tx_stat *stat = (struct wpi_tx_stat *)(desc + 1);
	struct wpi_node *wn = (struct wpi_node *)data->ni;

	/* Update rate control statistics. */
	wn->amn.amn_txcnt++;
	if (stat->retrycnt > 0)
		wn->amn.amn_retrycnt++;

	if ((letoh32(stat->status) & 0xff) != 1)
		ifp->if_oerrors++;

	/* Unmap and free mbuf. */
	bus_dmamap_sync(sc->sc_dmat, data->map, 0, data->map->dm_mapsize,
	    BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(sc->sc_dmat, data->map);
	m_freem(data->m);
	data->m = NULL;
	ieee80211_release_node(ic, data->ni);
	data->ni = NULL;

	sc->sc_tx_timer = 0;
	if (--ring->queued < WPI_TX_RING_LOMARK) {
		sc->qfullmsk &= ~(1 << ring->qid);
		if (sc->qfullmsk == 0 && ifq_is_oactive(&ifp->if_snd)) {
			ifq_clr_oactive(&ifp->if_snd);
			(*ifp->if_start)(ifp);
		}
	}
}

void
wpi_cmd_done(struct wpi_softc *sc, struct wpi_rx_desc *desc)
{
	struct wpi_tx_ring *ring = &sc->txq[4];
	struct wpi_tx_data *data;

	if ((desc->qid & 7) != 4)
		return;	/* Not a command ack. */

	data = &ring->data[desc->idx];

	/* If the command was mapped in an mbuf, free it. */
	if (data->m != NULL) {
		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    data->map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, data->map);
		m_freem(data->m);
		data->m = NULL;
	}
	wakeup(&ring->cmd[desc->idx]);
}

void
wpi_notif_intr(struct wpi_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	uint32_t hw;

	bus_dmamap_sync(sc->sc_dmat, sc->shared_dma.map, 0,
	    sizeof (struct wpi_shared), BUS_DMASYNC_POSTREAD);

	hw = letoh32(sc->shared->next);
	while (sc->rxq.cur != hw) {
		struct wpi_rx_data *data = &sc->rxq.data[sc->rxq.cur];
		struct wpi_rx_desc *desc;

		bus_dmamap_sync(sc->sc_dmat, data->map, 0, sizeof (*desc),
		    BUS_DMASYNC_POSTREAD);
		desc = mtod(data->m, struct wpi_rx_desc *);

		DPRINTFN(4, ("rx notification qid=%x idx=%d flags=%x type=%d "
		    "len=%d\n", desc->qid, desc->idx, desc->flags, desc->type,
		    letoh32(desc->len)));

		if (!(desc->qid & 0x80))	/* Reply to a command. */
			wpi_cmd_done(sc, desc);

		switch (desc->type) {
		case WPI_RX_DONE:
			/* An 802.11 frame has been received. */
			wpi_rx_done(sc, desc, data);
			break;

		case WPI_TX_DONE:
			/* An 802.11 frame has been transmitted. */
			wpi_tx_done(sc, desc);
			break;

		case WPI_UC_READY:
		{
			struct wpi_ucode_info *uc =
			    (struct wpi_ucode_info *)(desc + 1);

			/* The microcontroller is ready. */
			bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (*desc),
			    sizeof (*uc), BUS_DMASYNC_POSTREAD);
			DPRINTF(("microcode alive notification version %x "
			    "alive %x\n", letoh32(uc->version),
			    letoh32(uc->valid)));

			if (letoh32(uc->valid) != 1) {
				printf("%s: microcontroller initialization "
				    "failed\n", sc->sc_dev.dv_xname);
			}
			if (uc->subtype != WPI_UCODE_INIT) {
				/* Save the address of the error log. */
				sc->errptr = letoh32(uc->errptr);
			}
			break;
		}
		case WPI_STATE_CHANGED:
		{
			uint32_t *status = (uint32_t *)(desc + 1);

			/* Enabled/disabled notification. */
			bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (*desc),
			    sizeof (*status), BUS_DMASYNC_POSTREAD);
			DPRINTF(("state changed to %x\n", letoh32(*status)));

			if (letoh32(*status) & 1) {
				/* The radio button has to be pushed. */
				printf("%s: Radio transmitter is off\n",
				    sc->sc_dev.dv_xname);
				/* Turn the interface down. */
				wpi_stop(ifp, 1);
				return;	/* No further processing. */
			}
			break;
		}
		case WPI_START_SCAN:
		{
			struct wpi_start_scan *scan =
			    (struct wpi_start_scan *)(desc + 1);

			bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (*desc),
			    sizeof (*scan), BUS_DMASYNC_POSTREAD);
			DPRINTFN(2, ("scanning channel %d status %x\n",
			    scan->chan, letoh32(scan->status)));

			/* Fix current channel. */
			ic->ic_bss->ni_chan = &ic->ic_channels[scan->chan];
			break;
		}
		case WPI_STOP_SCAN:
		{
			struct wpi_stop_scan *scan =
			    (struct wpi_stop_scan *)(desc + 1);

			bus_dmamap_sync(sc->sc_dmat, data->map, sizeof (*desc),
			    sizeof (*scan), BUS_DMASYNC_POSTREAD);
			DPRINTF(("scan finished nchan=%d status=%d chan=%d\n",
			    scan->nchan, scan->status, scan->chan));

			if (scan->status == 1 && scan->chan <= 14 &&
			    (sc->sc_flags & WPI_FLAG_HAS_5GHZ)) {
				/*
				 * We just finished scanning 2GHz channels,
				 * start scanning 5GHz ones.
				 */
				if (wpi_scan(sc, IEEE80211_CHAN_5GHZ) == 0)
					break;
			}
			ieee80211_end_scan(ifp);
			break;
		}
		}

		sc->rxq.cur = (sc->rxq.cur + 1) % WPI_RX_RING_COUNT;
	}

	/* Tell the firmware what we have processed. */
	hw = (hw == 0) ? WPI_RX_RING_COUNT - 1 : hw - 1;
	WPI_WRITE(sc, WPI_FH_RX_WPTR, hw & ~7);
}

#ifdef WPI_DEBUG
/*
 * Dump the error log of the firmware when a firmware panic occurs.  Although
 * we can't debug the firmware because it is neither open source nor free, it
 * can help us to identify certain classes of problems.
 */
void
wpi_fatal_intr(struct wpi_softc *sc)
{
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
	struct wpi_fwdump dump;
	uint32_t i, offset, count;

	/* Check that the error log address is valid. */
	if (sc->errptr < WPI_FW_DATA_BASE ||
	    sc->errptr + sizeof (dump) >
	    WPI_FW_DATA_BASE + WPI_FW_DATA_MAXSZ) {
		printf("%s: bad firmware error log address 0x%08x\n",
		    sc->sc_dev.dv_xname, sc->errptr);
		return;
	}

	if (wpi_nic_lock(sc) != 0) {
		printf("%s: could not read firmware error log\n",
		    sc->sc_dev.dv_xname);
		return;
	}
	/* Read number of entries in the log. */
	count = wpi_mem_read(sc, sc->errptr);
	if (count == 0 || count * sizeof (dump) > WPI_FW_DATA_MAXSZ) {
		printf("%s: invalid count field (count=%u)\n",
		    sc->sc_dev.dv_xname, count);
		wpi_nic_unlock(sc);
		return;
	}
	/* Skip "count" field. */
	offset = sc->errptr + sizeof (uint32_t);
	printf("firmware error log (count=%u):\n", count);
	for (i = 0; i < count; i++) {
		wpi_mem_read_region_4(sc, offset, (uint32_t *)&dump,
		    sizeof (dump) / sizeof (uint32_t));

		printf("  error type = \"%s\" (0x%08X)\n",
		    (dump.desc < N(wpi_fw_errmsg)) ?
			wpi_fw_errmsg[dump.desc] : "UNKNOWN",
		    dump.desc);
		printf("  error data      = 0x%08X\n",
		    dump.data);
		printf("  branch link     = 0x%08X%08X\n",
		    dump.blink[0], dump.blink[1]);
		printf("  interrupt link  = 0x%08X%08X\n",
		    dump.ilink[0], dump.ilink[1]);
		printf("  time            = %u\n", dump.time);

		offset += sizeof (dump);
	}
	wpi_nic_unlock(sc);
	/* Dump driver status (TX and RX rings) while we're here. */
	printf("driver status:\n");
	for (i = 0; i < 6; i++) {
		struct wpi_tx_ring *ring = &sc->txq[i];
		printf("  tx ring %2d: qid=%-2d cur=%-3d queued=%-3d\n",
		    i, ring->qid, ring->cur, ring->queued);
	}
	printf("  rx ring: cur=%d\n", sc->rxq.cur);
	printf("  802.11 state %d\n", sc->sc_ic.ic_state);
#undef N
}
#endif

int
wpi_intr(void *arg)
{
	struct wpi_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	uint32_t r1, r2;

	/* Disable interrupts. */
	WPI_WRITE(sc, WPI_MASK, 0);

	r1 = WPI_READ(sc, WPI_INT);
	r2 = WPI_READ(sc, WPI_FH_INT);

	if (r1 == 0 && r2 == 0) {
		if (ifp->if_flags & IFF_UP)
			WPI_WRITE(sc, WPI_MASK, WPI_INT_MASK);
		return 0;	/* Interrupt not for us. */
	}
	if (r1 == 0xffffffff || (r1 & 0xfffffff0) == 0xa5a5a5a0)
		return 0;	/* Hardware gone! */

	/* Acknowledge interrupts. */
	WPI_WRITE(sc, WPI_INT, r1);
	WPI_WRITE(sc, WPI_FH_INT, r2);

	if (r1 & (WPI_INT_SW_ERR | WPI_INT_HW_ERR)) {
		printf("%s: fatal firmware error\n", sc->sc_dev.dv_xname);
		/* Dump firmware error log and stop. */
#ifdef WPI_DEBUG
		wpi_fatal_intr(sc);
#endif
		wpi_stop(ifp, 1);
		task_add(systq, &sc->init_task);
		return 1;
	}
	if ((r1 & (WPI_INT_FH_RX | WPI_INT_SW_RX)) ||
	    (r2 & WPI_FH_INT_RX))
		wpi_notif_intr(sc);

	if (r1 & WPI_INT_ALIVE)
		wakeup(sc);	/* Firmware is alive. */

	/* Re-enable interrupts. */
	if (ifp->if_flags & IFF_UP)
		WPI_WRITE(sc, WPI_MASK, WPI_INT_MASK);

	return 1;
}

int
wpi_tx(struct wpi_softc *sc, struct mbuf *m, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct wpi_node *wn = (void *)ni;
	struct wpi_tx_ring *ring;
	struct wpi_tx_desc *desc;
	struct wpi_tx_data *data;
	struct wpi_tx_cmd *cmd;
	struct wpi_cmd_data *tx;
	const struct wpi_rate *rinfo;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k = NULL;
	enum ieee80211_edca_ac ac;
	uint32_t flags;
	uint16_t qos;
	u_int hdrlen;
	uint8_t *ivp, tid, ridx, type;
	int i, totlen, hasqos, error;

	wh = mtod(m, struct ieee80211_frame *);
	hdrlen = ieee80211_get_hdrlen(wh);
	type = wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK;

	/* Select EDCA Access Category and TX ring for this frame. */
	if ((hasqos = ieee80211_has_qos(wh))) {
		qos = ieee80211_get_qos(wh);
		tid = qos & IEEE80211_QOS_TID;
		ac = ieee80211_up_to_ac(ic, tid);
	} else {
		tid = 0;
		ac = EDCA_AC_BE;
	}

	ring = &sc->txq[ac];
	desc = &ring->desc[ring->cur];
	data = &ring->data[ring->cur];

	/* Choose a TX rate index. */
	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    type != IEEE80211_FC0_TYPE_DATA) {
		ridx = (ic->ic_curmode == IEEE80211_MODE_11A) ?
		    WPI_RIDX_OFDM6 : WPI_RIDX_CCK1;
	} else if (ic->ic_fixed_rate != -1) {
		ridx = sc->fixed_ridx;
	} else
		ridx = wn->ridx[ni->ni_txrate];
	rinfo = &wpi_rates[ridx];

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct wpi_tx_radiotap_header *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_chan_freq = htole16(ni->ni_chan->ic_freq);
		tap->wt_chan_flags = htole16(ni->ni_chan->ic_flags);
		tap->wt_rate = rinfo->rate;
		tap->wt_hwqueue = ac;
		if ((ic->ic_flags & IEEE80211_F_WEPON) &&
		    (wh->i_fc[1] & IEEE80211_FC1_PROTECTED))
			tap->wt_flags |= IEEE80211_RADIOTAP_F_WEP;

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	totlen = m->m_pkthdr.len;

	/* Encrypt the frame if need be. */
	if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
		/* Retrieve key for TX. */
		k = ieee80211_get_txkey(ic, wh, ni);
		if (k->k_cipher != IEEE80211_CIPHER_CCMP) {
			/* Do software encryption. */
			if ((m = ieee80211_encrypt(ic, m, k)) == NULL)
				return ENOBUFS;
			/* 802.11 header may have moved. */
			wh = mtod(m, struct ieee80211_frame *);
			totlen = m->m_pkthdr.len;

		} else	/* HW appends CCMP MIC. */
			totlen += IEEE80211_CCMP_HDRLEN;
	}

	/* Prepare TX firmware command. */
	cmd = &ring->cmd[ring->cur];
	cmd->code = WPI_CMD_TX_DATA;
	cmd->flags = 0;
	cmd->qid = ring->qid;
	cmd->idx = ring->cur;

	tx = (struct wpi_cmd_data *)cmd->data;
	/* NB: No need to clear tx, all fields are reinitialized here. */

	flags = 0;
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		/* Unicast frame, check if an ACK is expected. */
		if (!hasqos || (qos & IEEE80211_QOS_ACK_POLICY_MASK) !=
		    IEEE80211_QOS_ACK_POLICY_NOACK)
			flags |= WPI_TX_NEED_ACK;
	}

	/* Check if frame must be protected using RTS/CTS or CTS-to-self. */
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		/* NB: Group frames are sent using CCK in 802.11b/g. */
		if (totlen + IEEE80211_CRC_LEN > ic->ic_rtsthreshold) {
			flags |= WPI_TX_NEED_RTS | WPI_TX_FULL_TXOP;
		} else if ((ic->ic_flags & IEEE80211_F_USEPROT) &&
		    ridx <= WPI_RIDX_OFDM54) {
			if (ic->ic_protmode == IEEE80211_PROT_CTSONLY)
				flags |= WPI_TX_NEED_CTS | WPI_TX_FULL_TXOP;
			else if (ic->ic_protmode == IEEE80211_PROT_RTSCTS)
				flags |= WPI_TX_NEED_RTS | WPI_TX_FULL_TXOP;
		}
	}

	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    type != IEEE80211_FC0_TYPE_DATA)
		tx->id = WPI_ID_BROADCAST;
	else
		tx->id = wn->id;

	if (type == IEEE80211_FC0_TYPE_MGT) {
		uint8_t subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;

#ifndef IEEE80211_STA_ONLY
		/* Tell HW to set timestamp in probe responses. */
		if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP)
			flags |= WPI_TX_INSERT_TSTAMP;
#endif
		if (subtype == IEEE80211_FC0_SUBTYPE_ASSOC_REQ ||
		    subtype == IEEE80211_FC0_SUBTYPE_REASSOC_REQ)
			tx->timeout = htole16(3);
		else
			tx->timeout = htole16(2);
	} else
		tx->timeout = htole16(0);

	tx->len = htole16(totlen);
	tx->tid = tid;
	tx->rts_ntries = 7;
	tx->data_ntries = 15;
	tx->ofdm_mask = 0xff;
	tx->cck_mask = 0x0f;
	tx->lifetime = htole32(WPI_LIFETIME_INFINITE);
	tx->plcp = rinfo->plcp;

	/* Copy 802.11 header in TX command. */
	memcpy((uint8_t *)(tx + 1), wh, hdrlen);

	if (k != NULL && k->k_cipher == IEEE80211_CIPHER_CCMP) {
		/* Trim 802.11 header and prepend CCMP IV. */
		m_adj(m, hdrlen - IEEE80211_CCMP_HDRLEN);
		ivp = mtod(m, uint8_t *);
		k->k_tsc++;
		ivp[0] = k->k_tsc;
		ivp[1] = k->k_tsc >> 8;
		ivp[2] = 0;
		ivp[3] = k->k_id << 6 | IEEE80211_WEP_EXTIV;
		ivp[4] = k->k_tsc >> 16;
		ivp[5] = k->k_tsc >> 24;
		ivp[6] = k->k_tsc >> 32;
		ivp[7] = k->k_tsc >> 40;

		tx->security = WPI_CIPHER_CCMP;
		memcpy(tx->key, k->k_key, k->k_len);
	} else {
		/* Trim 802.11 header. */
		m_adj(m, hdrlen);
		tx->security = 0;
	}
	tx->flags = htole32(flags);

	error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m,
	    BUS_DMA_NOWAIT | BUS_DMA_WRITE);
	if (error != 0 && error != EFBIG) {
		printf("%s: can't map mbuf (error %d)\n",
		    sc->sc_dev.dv_xname, error);
		m_freem(m);
		return error;
	}
	if (error != 0) {
		/* Too many DMA segments, linearize mbuf. */
		if (m_defrag(m, M_DONTWAIT)) {
			m_freem(m);
			return ENOBUFS;
		}
		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m,
		    BUS_DMA_NOWAIT | BUS_DMA_WRITE);
		if (error != 0) {
			printf("%s: can't map mbuf (error %d)\n",
			    sc->sc_dev.dv_xname, error);
			m_freem(m);
			return error;
		}
	}

	data->m = m;
	data->ni = ni;

	DPRINTFN(4, ("sending data: qid=%d idx=%d len=%d nsegs=%d\n",
	    ring->qid, ring->cur, m->m_pkthdr.len, data->map->dm_nsegs));

	/* Fill TX descriptor. */
	desc->flags = htole32(WPI_PAD32(m->m_pkthdr.len) << 28 |
	    (1 + data->map->dm_nsegs) << 24);
	/* First DMA segment is used by the TX command. */
	desc->segs[0].addr = htole32(ring->cmd_dma.paddr +
	    ring->cur * sizeof (struct wpi_tx_cmd));
	desc->segs[0].len  = htole32(4 + sizeof (struct wpi_cmd_data) +
	    ((hdrlen + 3) & ~3));
	/* Other DMA segments are for data payload. */
	for (i = 1; i <= data->map->dm_nsegs; i++) {
		desc->segs[i].addr =
		    htole32(data->map->dm_segs[i - 1].ds_addr);
		desc->segs[i].len  =
		    htole32(data->map->dm_segs[i - 1].ds_len);
	}

	bus_dmamap_sync(sc->sc_dmat, data->map, 0, data->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, ring->cmd_dma.map,
	    (caddr_t)cmd - ring->cmd_dma.vaddr, sizeof (*cmd),
	    BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, ring->desc_dma.map,
	    (caddr_t)desc - ring->desc_dma.vaddr, sizeof (*desc),
	    BUS_DMASYNC_PREWRITE);

	/* Kick TX ring. */
	ring->cur = (ring->cur + 1) % WPI_TX_RING_COUNT;
	WPI_WRITE(sc, WPI_HBUS_TARG_WRPTR, ring->qid << 8 | ring->cur);

	/* Mark TX ring as full if we reach a certain threshold. */
	if (++ring->queued > WPI_TX_RING_HIMARK)
		sc->qfullmsk |= 1 << ring->qid;

	return 0;
}

void
wpi_start(struct ifnet *ifp)
{
	struct wpi_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct mbuf *m;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	for (;;) {
		if (sc->qfullmsk != 0) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}
		/* Send pending management frames first. */
		m = mq_dequeue(&ic->ic_mgtq);
		if (m != NULL) {
			ni = m->m_pkthdr.ph_cookie;
			goto sendit;
		}
		if (ic->ic_state != IEEE80211_S_RUN)
			break;

		/* Encapsulate and send data frames. */
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;
#if NBPFILTER > 0
		if (ifp->if_bpf != NULL)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
		if ((m = ieee80211_encap(ifp, m, &ni)) == NULL)
			continue;
sendit:
#if NBPFILTER > 0
		if (ic->ic_rawbpf != NULL)
			bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_OUT);
#endif
		if (wpi_tx(sc, m, ni) != 0) {
			ieee80211_release_node(ic, ni);
			ifp->if_oerrors++;
			continue;
		}

		sc->sc_tx_timer = 5;
		ifp->if_timer = 1;
	}
}

void
wpi_watchdog(struct ifnet *ifp)
{
	struct wpi_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;

	if (sc->sc_tx_timer > 0) {
		if (--sc->sc_tx_timer == 0) {
			printf("%s: device timeout\n", sc->sc_dev.dv_xname);
			wpi_stop(ifp, 1);
			ifp->if_oerrors++;
			return;
		}
		ifp->if_timer = 1;
	}

	ieee80211_watchdog(ifp);
}

int
wpi_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct wpi_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;

	error = rw_enter(&sc->sc_rwlock, RW_WRITE | RW_INTR);
	if (error)
		return error;
	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (!(ifp->if_flags & IFF_RUNNING))
				error = wpi_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				wpi_stop(ifp, 1);
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);

		if (error == ENETRESET)
			error = 0;
		break;

	case SIOCS80211POWER:
		error = ieee80211_ioctl(ifp, cmd, data);
		if (error != ENETRESET)
			break;
		if (ic->ic_state == IEEE80211_S_RUN) {
			if (ic->ic_flags & IEEE80211_F_PMGTON)
				error = wpi_set_pslevel(sc, 0, 3, 0);
			else	/* back to CAM */
				error = wpi_set_pslevel(sc, 0, 0, 0);
		} else {
			/* Defer until transition to IEEE80211_S_RUN. */
			error = 0;
		}
		break;

	default:
		error = ieee80211_ioctl(ifp, cmd, data);
	}

	if (error == ENETRESET) {
		error = 0;
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
		    (IFF_UP | IFF_RUNNING)) {
			wpi_stop(ifp, 0);
			error = wpi_init(ifp);
		}
	}

	splx(s);
	rw_exit_write(&sc->sc_rwlock);
	return error;
}

/*
 * Send a command to the firmware.
 */
int
wpi_cmd(struct wpi_softc *sc, int code, const void *buf, int size, int async)
{
	struct wpi_tx_ring *ring = &sc->txq[4];
	struct wpi_tx_desc *desc;
	struct wpi_tx_data *data;
	struct wpi_tx_cmd *cmd;
	struct mbuf *m;
	bus_addr_t paddr;
	int totlen, error;

	desc = &ring->desc[ring->cur];
	data = &ring->data[ring->cur];
	totlen = 4 + size;

	if (size > sizeof cmd->data) {
		/* Command is too large to fit in a descriptor. */
		if (totlen > MCLBYTES)
			return EINVAL;
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL)
			return ENOMEM;
		if (totlen > MHLEN) {
			MCLGET(m, M_DONTWAIT);
			if (!(m->m_flags & M_EXT)) {
				m_freem(m);
				return ENOMEM;
			}
		}
		cmd = mtod(m, struct wpi_tx_cmd *);
		error = bus_dmamap_load(sc->sc_dmat, data->map, cmd, totlen,
		    NULL, BUS_DMA_NOWAIT | BUS_DMA_WRITE);
		if (error != 0) {
			m_freem(m);
			return error;
		}
		data->m = m;
		paddr = data->map->dm_segs[0].ds_addr;
	} else {
		cmd = &ring->cmd[ring->cur];
		paddr = data->cmd_paddr;
	}

	cmd->code = code;
	cmd->flags = 0;
	cmd->qid = ring->qid;
	cmd->idx = ring->cur;
	memcpy(cmd->data, buf, size);

	desc->flags = htole32(WPI_PAD32(size) << 28 | 1 << 24);
	desc->segs[0].addr = htole32(paddr);
	desc->segs[0].len  = htole32(totlen);

	if (size > sizeof cmd->data) {
		bus_dmamap_sync(sc->sc_dmat, data->map, 0, totlen,
		    BUS_DMASYNC_PREWRITE);
	} else {
		bus_dmamap_sync(sc->sc_dmat, ring->cmd_dma.map,
		    (caddr_t)cmd - ring->cmd_dma.vaddr, totlen,
		    BUS_DMASYNC_PREWRITE);
	}
	bus_dmamap_sync(sc->sc_dmat, ring->desc_dma.map,
	    (caddr_t)desc - ring->desc_dma.vaddr, sizeof (*desc),
	    BUS_DMASYNC_PREWRITE);

	/* Kick command ring. */
	ring->cur = (ring->cur + 1) % WPI_TX_RING_COUNT;
	WPI_WRITE(sc, WPI_HBUS_TARG_WRPTR, ring->qid << 8 | ring->cur);

	return async ? 0 : tsleep(cmd, PCATCH, "wpicmd", hz);
}

/*
 * Configure HW multi-rate retries.
 */
int
wpi_mrr_setup(struct wpi_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct wpi_mrr_setup mrr;
	int i, error;

	/* CCK rates (not used with 802.11a). */
	for (i = WPI_RIDX_CCK1; i <= WPI_RIDX_CCK11; i++) {
		mrr.rates[i].flags = 0;
		mrr.rates[i].plcp = wpi_rates[i].plcp;
		/* Fallback to the immediate lower CCK rate (if any.) */
		mrr.rates[i].next =
		    (i == WPI_RIDX_CCK1) ? WPI_RIDX_CCK1 : i - 1;
		/* Try one time at this rate before falling back to "next". */
		mrr.rates[i].ntries = 1;
	}
	/* OFDM rates (not used with 802.11b). */
	for (i = WPI_RIDX_OFDM6; i <= WPI_RIDX_OFDM54; i++) {
		mrr.rates[i].flags = 0;
		mrr.rates[i].plcp = wpi_rates[i].plcp;
		/* Fallback to the immediate lower rate (if any.) */
		/* We allow fallback from OFDM/6 to CCK/2 in 11b/g mode. */
		mrr.rates[i].next = (i == WPI_RIDX_OFDM6) ?
		    ((ic->ic_curmode == IEEE80211_MODE_11A) ?
			WPI_RIDX_OFDM6 : WPI_RIDX_CCK2) :
		    i - 1;
		/* Try one time at this rate before falling back to "next". */
		mrr.rates[i].ntries = 1;
	}
	/* Setup MRR for control frames. */
	mrr.which = htole32(WPI_MRR_CTL);
	error = wpi_cmd(sc, WPI_CMD_MRR_SETUP, &mrr, sizeof mrr, 0);
	if (error != 0) {
		printf("%s: could not setup MRR for control frames\n",
		    sc->sc_dev.dv_xname);
		return error;
	}
	/* Setup MRR for data frames. */
	mrr.which = htole32(WPI_MRR_DATA);
	error = wpi_cmd(sc, WPI_CMD_MRR_SETUP, &mrr, sizeof mrr, 0);
	if (error != 0) {
		printf("%s: could not setup MRR for data frames\n",
		    sc->sc_dev.dv_xname);
		return error;
	}
	return 0;
}

void
wpi_updateedca(struct ieee80211com *ic)
{
#define WPI_EXP2(x)	((1 << (x)) - 1)	/* CWmin = 2^ECWmin - 1 */
	struct wpi_softc *sc = ic->ic_softc;
	struct wpi_edca_params cmd;
	int aci;

	memset(&cmd, 0, sizeof cmd);
	cmd.flags = htole32(WPI_EDCA_UPDATE);
	for (aci = 0; aci < EDCA_NUM_AC; aci++) {
		const struct ieee80211_edca_ac_params *ac =
		    &ic->ic_edca_ac[aci];
		cmd.ac[aci].aifsn = ac->ac_aifsn;
		cmd.ac[aci].cwmin = htole16(WPI_EXP2(ac->ac_ecwmin));
		cmd.ac[aci].cwmax = htole16(WPI_EXP2(ac->ac_ecwmax));
		cmd.ac[aci].txoplimit =
		    htole16(IEEE80211_TXOP_TO_US(ac->ac_txoplimit));
	}
	(void)wpi_cmd(sc, WPI_CMD_EDCA_PARAMS, &cmd, sizeof cmd, 1);
#undef WPI_EXP2
}

void
wpi_set_led(struct wpi_softc *sc, uint8_t which, uint8_t off, uint8_t on)
{
	struct wpi_cmd_led led;

	led.which = which;
	led.unit = htole32(100000);	/* on/off in unit of 100ms */
	led.off = off;
	led.on = on;
	(void)wpi_cmd(sc, WPI_CMD_SET_LED, &led, sizeof led, 1);
}

int
wpi_set_timing(struct wpi_softc *sc, struct ieee80211_node *ni)
{
	struct wpi_cmd_timing cmd;
	uint64_t val, mod;

	memset(&cmd, 0, sizeof cmd);
	memcpy(&cmd.tstamp, ni->ni_tstamp, sizeof (uint64_t));
	cmd.bintval = htole16(ni->ni_intval);
	cmd.lintval = htole16(10);

	/* Compute remaining time until next beacon. */
	val = (uint64_t)ni->ni_intval * 1024;	/* msecs -> usecs */
	mod = letoh64(cmd.tstamp) % val;
	cmd.binitval = htole32((uint32_t)(val - mod));

	DPRINTF(("timing bintval=%u, tstamp=%llu, init=%u\n",
	    ni->ni_intval, letoh64(cmd.tstamp), (uint32_t)(val - mod)));

	return wpi_cmd(sc, WPI_CMD_TIMING, &cmd, sizeof cmd, 1);
}

/*
 * This function is called periodically (every minute) to adjust TX power
 * based on temperature variation.
 */
void
wpi_power_calibration(struct wpi_softc *sc)
{
	int temp;

	temp = (int)WPI_READ(sc, WPI_UCODE_GP2);
	/* Sanity-check temperature. */
	if (temp < -260 || temp > 25) {
		/* This can't be correct, ignore. */
		DPRINTF(("out-of-range temperature reported: %d\n", temp));
		return;
	}
	DPRINTF(("temperature %d->%d\n", sc->temp, temp));
	/* Adjust TX power if need be (delta > 6). */
	if (abs(temp - sc->temp) > 6) {
		/* Record temperature of last calibration. */
		sc->temp = temp;
		(void)wpi_set_txpower(sc, 1);
	}
}

/*
 * Set TX power for current channel (each rate has its own power settings).
 */
int
wpi_set_txpower(struct wpi_softc *sc, int async)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_channel *ch;
	struct wpi_power_group *group;
	struct wpi_cmd_txpower cmd;
	u_int chan;
	int idx, i;

	/* Retrieve current channel from last RXON. */
	chan = sc->rxon.chan;
	DPRINTF(("setting TX power for channel %d\n", chan));
	ch = &ic->ic_channels[chan];

	/* Find the TX power group to which this channel belongs. */
	if (IEEE80211_IS_CHAN_5GHZ(ch)) {
		for (group = &sc->groups[1]; group < &sc->groups[4]; group++)
			if (chan <= group->chan)
				break;
	} else
		group = &sc->groups[0];

	memset(&cmd, 0, sizeof cmd);
	cmd.band = IEEE80211_IS_CHAN_5GHZ(ch) ? 0 : 1;
	cmd.chan = htole16(chan);

	/* Set TX power for all OFDM and CCK rates. */
	for (i = 0; i <= WPI_RIDX_MAX ; i++) {
		/* Retrieve TX power for this channel/rate. */
		idx = wpi_get_power_index(sc, group, ch, i);

		cmd.rates[i].plcp = wpi_rates[i].plcp;

		if (IEEE80211_IS_CHAN_5GHZ(ch)) {
			cmd.rates[i].rf_gain = wpi_rf_gain_5ghz[idx];
			cmd.rates[i].dsp_gain = wpi_dsp_gain_5ghz[idx];
		} else {
			cmd.rates[i].rf_gain = wpi_rf_gain_2ghz[idx];
			cmd.rates[i].dsp_gain = wpi_dsp_gain_2ghz[idx];
		}
		DPRINTF(("chan %d/rate %d: power index %d\n", chan,
		    wpi_rates[i].rate, idx));
	}
	return wpi_cmd(sc, WPI_CMD_TXPOWER, &cmd, sizeof cmd, async);
}

/*
 * Determine TX power index for a given channel/rate combination.
 * This takes into account the regulatory information from EEPROM and the
 * current temperature.
 */
int
wpi_get_power_index(struct wpi_softc *sc, struct wpi_power_group *group,
    struct ieee80211_channel *c, int ridx)
{
/* Fixed-point arithmetic division using a n-bit fractional part. */
#define fdivround(a, b, n)	\
	((((1 << n) * (a)) / (b) + (1 << n) / 2) / (1 << n))

/* Linear interpolation. */
#define interpolate(x, x1, y1, x2, y2, n)	\
	((y1) + fdivround(((x) - (x1)) * ((y2) - (y1)), (x2) - (x1), n))

	struct ieee80211com *ic = &sc->sc_ic;
	struct wpi_power_sample *sample;
	int pwr, idx;
	u_int chan;

	/* Get channel number. */
	chan = ieee80211_chan2ieee(ic, c);

	/* Default TX power is group maximum TX power minus 3dB. */
	pwr = group->maxpwr / 2;

	/* Decrease TX power for highest OFDM rates to reduce distortion. */
	switch (ridx) {
	case WPI_RIDX_OFDM36:
		pwr -= IEEE80211_IS_CHAN_2GHZ(c) ? 0 :  5;
		break;
	case WPI_RIDX_OFDM48:
		pwr -= IEEE80211_IS_CHAN_2GHZ(c) ? 7 : 10;
		break;
	case WPI_RIDX_OFDM54:
		pwr -= IEEE80211_IS_CHAN_2GHZ(c) ? 9 : 12;
		break;
	}

	/* Never exceed the channel maximum allowed TX power. */
	pwr = MIN(pwr, sc->maxpwr[chan]);

	/* Retrieve TX power index into gain tables from samples. */
	for (sample = group->samples; sample < &group->samples[3]; sample++)
		if (pwr > sample[1].power)
			break;
	/* Fixed-point linear interpolation using a 19-bit fractional part. */
	idx = interpolate(pwr, sample[0].power, sample[0].index,
	    sample[1].power, sample[1].index, 19);

	/*-
	 * Adjust power index based on current temperature:
	 * - if cooler than factory-calibrated: decrease output power
	 * - if warmer than factory-calibrated: increase output power
	 */
	idx -= (sc->temp - group->temp) * 11 / 100;

	/* Decrease TX power for CCK rates (-5dB). */
	if (ridx >= WPI_RIDX_CCK1)
		idx += 10;

	/* Make sure idx stays in a valid range. */
	if (idx < 0)
		idx = 0;
	else if (idx > WPI_MAX_PWR_INDEX)
		idx = WPI_MAX_PWR_INDEX;
	return idx;

#undef interpolate
#undef fdivround
}

/*
 * Set STA mode power saving level (between 0 and 5).
 * Level 0 is CAM (Continuously Aware Mode), 5 is for maximum power saving.
 */
int
wpi_set_pslevel(struct wpi_softc *sc, int dtim, int level, int async)
{
	struct wpi_pmgt_cmd cmd;
	const struct wpi_pmgt *pmgt;
	uint32_t max, skip_dtim;
	pcireg_t reg;
	int i;

	/* Select which PS parameters to use. */
	if (dtim <= 10)
		pmgt = &wpi_pmgt[0][level];
	else
		pmgt = &wpi_pmgt[1][level];

	memset(&cmd, 0, sizeof cmd);
	if (level != 0)	/* not CAM */
		cmd.flags |= htole16(WPI_PS_ALLOW_SLEEP);
	/* Retrieve PCIe Active State Power Management (ASPM). */
	reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag,
	    sc->sc_cap_off + PCI_PCIE_LCSR);
	if (!(reg & PCI_PCIE_LCSR_ASPM_L0S))	/* L0s Entry disabled. */
		cmd.flags |= htole16(WPI_PS_PCI_PMGT);
	cmd.rxtimeout = htole32(pmgt->rxtimeout * 1024);
	cmd.txtimeout = htole32(pmgt->txtimeout * 1024);

	if (dtim == 0) {
		dtim = 1;
		skip_dtim = 0;
	} else
		skip_dtim = pmgt->skip_dtim;
	if (skip_dtim != 0) {
		cmd.flags |= htole16(WPI_PS_SLEEP_OVER_DTIM);
		max = pmgt->intval[4];
		if (max == (uint32_t)-1)
			max = dtim * (skip_dtim + 1);
		else if (max > dtim)
			max = (max / dtim) * dtim;
	} else
		max = dtim;
	for (i = 0; i < 5; i++)
		cmd.intval[i] = htole32(MIN(max, pmgt->intval[i]));

	DPRINTF(("setting power saving level to %d\n", level));
	return wpi_cmd(sc, WPI_CMD_SET_POWER_MODE, &cmd, sizeof cmd, async);
}

int
wpi_config(struct wpi_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct wpi_bluetooth bluetooth;
	struct wpi_node_info node;
	int error;

	/* Set power saving level to CAM during initialization. */
	if ((error = wpi_set_pslevel(sc, 0, 0, 0)) != 0) {
		printf("%s: could not set power saving level\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

	/* Configure bluetooth coexistence. */
	memset(&bluetooth, 0, sizeof bluetooth);
	bluetooth.flags = WPI_BT_COEX_MODE_4WIRE;
	bluetooth.lead_time = WPI_BT_LEAD_TIME_DEF;
	bluetooth.max_kill = WPI_BT_MAX_KILL_DEF;
	error = wpi_cmd(sc, WPI_CMD_BT_COEX, &bluetooth, sizeof bluetooth, 0);
	if (error != 0) {
		printf("%s: could not configure bluetooth coexistence\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

	/* Configure adapter. */
	memset(&sc->rxon, 0, sizeof (struct wpi_rxon));
	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	IEEE80211_ADDR_COPY(sc->rxon.myaddr, ic->ic_myaddr);
	/* Set default channel. */
	sc->rxon.chan = ieee80211_chan2ieee(ic, ic->ic_ibss_chan);
	sc->rxon.flags = htole32(WPI_RXON_TSF);
	if (IEEE80211_IS_CHAN_2GHZ(ic->ic_ibss_chan))
		sc->rxon.flags |= htole32(WPI_RXON_AUTO | WPI_RXON_24GHZ);
	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		sc->rxon.mode = WPI_MODE_STA;
		sc->rxon.filter = htole32(WPI_FILTER_MULTICAST);
		break;
	case IEEE80211_M_MONITOR:
		sc->rxon.mode = WPI_MODE_MONITOR;
		sc->rxon.filter = htole32(WPI_FILTER_MULTICAST |
		    WPI_FILTER_CTL | WPI_FILTER_PROMISC);
		break;
	default:
		/* Should not get there. */
		break;
	}
	sc->rxon.cck_mask  = 0x0f;	/* not yet negotiated */
	sc->rxon.ofdm_mask = 0xff;	/* not yet negotiated */
	DPRINTF(("setting configuration\n"));
	error = wpi_cmd(sc, WPI_CMD_RXON, &sc->rxon, sizeof (struct wpi_rxon),
	    0);
	if (error != 0) {
		printf("%s: RXON command failed\n", sc->sc_dev.dv_xname);
		return error;
	}

	/* Configuration has changed, set TX power accordingly. */
	if ((error = wpi_set_txpower(sc, 0)) != 0) {
		printf("%s: could not set TX power\n", sc->sc_dev.dv_xname);
		return error;
	}

	/* Add broadcast node. */
	memset(&node, 0, sizeof node);
	IEEE80211_ADDR_COPY(node.macaddr, etherbroadcastaddr);
	node.id = WPI_ID_BROADCAST;
	node.plcp = wpi_rates[WPI_RIDX_CCK1].plcp;
	node.action = htole32(WPI_ACTION_SET_RATE);
	node.antenna = WPI_ANTENNA_BOTH;
	error = wpi_cmd(sc, WPI_CMD_ADD_NODE, &node, sizeof node, 0);
	if (error != 0) {
		printf("%s: could not add broadcast node\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

	if ((error = wpi_mrr_setup(sc)) != 0) {
		printf("%s: could not setup MRR\n", sc->sc_dev.dv_xname);
		return error;
	}
	return 0;
}

int
wpi_scan(struct wpi_softc *sc, uint16_t flags)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct wpi_scan_hdr *hdr;
	struct wpi_cmd_data *tx;
	struct wpi_scan_essid *essid;
	struct wpi_scan_chan *chan;
	struct ieee80211_frame *wh;
	struct ieee80211_rateset *rs;
	struct ieee80211_channel *c;
	uint8_t *buf, *frm;
	int buflen, error;

	buf = malloc(WPI_SCAN_MAXSZ, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (buf == NULL) {
		printf("%s: could not allocate buffer for scan command\n",
		    sc->sc_dev.dv_xname);
		return ENOMEM;
	}
	hdr = (struct wpi_scan_hdr *)buf;
	/*
	 * Move to the next channel if no frames are received within 10ms
	 * after sending the probe request.
	 */
	hdr->quiet_time = htole16(10);		/* timeout in milliseconds */
	hdr->quiet_threshold = htole16(1);	/* min # of packets */

	tx = (struct wpi_cmd_data *)(hdr + 1);
	tx->flags = htole32(WPI_TX_AUTO_SEQ);
	tx->id = WPI_ID_BROADCAST;
	tx->lifetime = htole32(WPI_LIFETIME_INFINITE);

	if (flags & IEEE80211_CHAN_5GHZ) {
		hdr->crc_threshold = htole16(1);
		/* Send probe requests at 6Mbps. */
		tx->plcp = wpi_rates[WPI_RIDX_OFDM6].plcp;
		rs = &ic->ic_sup_rates[IEEE80211_MODE_11A];
	} else {
		hdr->flags = htole32(WPI_RXON_24GHZ | WPI_RXON_AUTO);
		/* Send probe requests at 1Mbps. */
		tx->plcp = wpi_rates[WPI_RIDX_CCK1].plcp;
		rs = &ic->ic_sup_rates[IEEE80211_MODE_11G];
	}

	essid = (struct wpi_scan_essid *)(tx + 1);
	if (ic->ic_des_esslen != 0) {
		essid[0].id  = IEEE80211_ELEMID_SSID;
		essid[0].len = ic->ic_des_esslen;
		memcpy(essid[0].data, ic->ic_des_essid, ic->ic_des_esslen);
	}
	/*
	 * Build a probe request frame.  Most of the following code is a
	 * copy & paste of what is done in net80211.
	 */
	wh = (struct ieee80211_frame *)(essid + 4);
	wh->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_MGT |
	    IEEE80211_FC0_SUBTYPE_PROBE_REQ;
	wh->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	IEEE80211_ADDR_COPY(wh->i_addr1, etherbroadcastaddr);
	IEEE80211_ADDR_COPY(wh->i_addr2, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(wh->i_addr3, etherbroadcastaddr);
	*(uint16_t *)&wh->i_dur[0] = 0;	/* filled by HW */
	*(uint16_t *)&wh->i_seq[0] = 0;	/* filled by HW */

	frm = (uint8_t *)(wh + 1);
	frm = ieee80211_add_ssid(frm, NULL, 0);
	frm = ieee80211_add_rates(frm, rs);
	if (rs->rs_nrates > IEEE80211_RATE_SIZE)
		frm = ieee80211_add_xrates(frm, rs);

	/* Set length of probe request. */
	tx->len = htole16(frm - (uint8_t *)wh);

	chan = (struct wpi_scan_chan *)frm;
	for (c  = &ic->ic_channels[1];
	     c <= &ic->ic_channels[IEEE80211_CHAN_MAX]; c++) {
		if ((c->ic_flags & flags) != flags)
			continue;

		chan->chan = ieee80211_chan2ieee(ic, c);
		DPRINTFN(2, ("adding channel %d\n", chan->chan));
		chan->flags = 0;
		if (!(c->ic_flags & IEEE80211_CHAN_PASSIVE))
			chan->flags |= WPI_CHAN_ACTIVE;
		if (ic->ic_des_esslen != 0)
			chan->flags |= WPI_CHAN_NPBREQS(1);
		chan->dsp_gain = 0x6e;
		if (IEEE80211_IS_CHAN_5GHZ(c)) {
			chan->rf_gain = 0x3b;
			chan->active  = htole16(24);
			chan->passive = htole16(110);
		} else {
			chan->rf_gain = 0x28;
			chan->active  = htole16(36);
			chan->passive = htole16(120);
		}
		hdr->nchan++;
		chan++;
	}

	buflen = (uint8_t *)chan - buf;
	hdr->len = htole16(buflen);

	DPRINTF(("sending scan command nchan=%d\n", hdr->nchan));
	error = wpi_cmd(sc, WPI_CMD_SCAN, buf, buflen, 1);
	free(buf, M_DEVBUF, WPI_SCAN_MAXSZ);
	return error;
}

int
wpi_auth(struct wpi_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni = ic->ic_bss;
	struct wpi_node_info node;
	int error;

	/* Update adapter configuration. */
	IEEE80211_ADDR_COPY(sc->rxon.bssid, ni->ni_bssid);
	sc->rxon.chan = ieee80211_chan2ieee(ic, ni->ni_chan);
	sc->rxon.flags = htole32(WPI_RXON_TSF);
	if (IEEE80211_IS_CHAN_2GHZ(ni->ni_chan))
		sc->rxon.flags |= htole32(WPI_RXON_AUTO | WPI_RXON_24GHZ);
	if (ic->ic_flags & IEEE80211_F_SHSLOT)
		sc->rxon.flags |= htole32(WPI_RXON_SHSLOT);
	if (ic->ic_flags & IEEE80211_F_SHPREAMBLE)
		sc->rxon.flags |= htole32(WPI_RXON_SHPREAMBLE);
	switch (ic->ic_curmode) {
	case IEEE80211_MODE_11A:
		sc->rxon.cck_mask  = 0;
		sc->rxon.ofdm_mask = 0x15;
		break;
	case IEEE80211_MODE_11B:
		sc->rxon.cck_mask  = 0x03;
		sc->rxon.ofdm_mask = 0;
		break;
	default:	/* Assume 802.11b/g. */
		sc->rxon.cck_mask  = 0x0f;
		sc->rxon.ofdm_mask = 0x15;
	}
	DPRINTF(("rxon chan %d flags %x cck %x ofdm %x\n", sc->rxon.chan,
	    sc->rxon.flags, sc->rxon.cck_mask, sc->rxon.ofdm_mask));
	error = wpi_cmd(sc, WPI_CMD_RXON, &sc->rxon, sizeof (struct wpi_rxon),
	    1);
	if (error != 0) {
		printf("%s: RXON command failed\n", sc->sc_dev.dv_xname);
		return error;
	}

	/* Configuration has changed, set TX power accordingly. */
	if ((error = wpi_set_txpower(sc, 1)) != 0) {
		printf("%s: could not set TX power\n", sc->sc_dev.dv_xname);
		return error;
	}
	/*
	 * Reconfiguring RXON clears the firmware nodes table so we must
	 * add the broadcast node again.
	 */
	memset(&node, 0, sizeof node);
	IEEE80211_ADDR_COPY(node.macaddr, etherbroadcastaddr);
	node.id = WPI_ID_BROADCAST;
	node.plcp = (ic->ic_curmode == IEEE80211_MODE_11A) ?
	    wpi_rates[WPI_RIDX_OFDM6].plcp : wpi_rates[WPI_RIDX_CCK1].plcp;
	node.action = htole32(WPI_ACTION_SET_RATE);
	node.antenna = WPI_ANTENNA_BOTH;
	error = wpi_cmd(sc, WPI_CMD_ADD_NODE, &node, sizeof node, 1);
	if (error != 0) {
		printf("%s: could not add broadcast node\n",
		    sc->sc_dev.dv_xname);
		return error;
	}
	return 0;
}

int
wpi_run(struct wpi_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni = ic->ic_bss;
	struct wpi_node_info node;
	int error;

	if (ic->ic_opmode == IEEE80211_M_MONITOR) {
		/* Link LED blinks while monitoring. */
		wpi_set_led(sc, WPI_LED_LINK, 5, 5);
		return 0;
	}
	if ((error = wpi_set_timing(sc, ni)) != 0) {
		printf("%s: could not set timing\n", sc->sc_dev.dv_xname);
		return error;
	}

	/* Update adapter configuration. */
	sc->rxon.associd = htole16(IEEE80211_AID(ni->ni_associd));
	/* Short preamble and slot time are negotiated when associating. */
	sc->rxon.flags &= ~htole32(WPI_RXON_SHPREAMBLE | WPI_RXON_SHSLOT);
	if (ic->ic_flags & IEEE80211_F_SHSLOT)
		sc->rxon.flags |= htole32(WPI_RXON_SHSLOT);
	if (ic->ic_flags & IEEE80211_F_SHPREAMBLE)
		sc->rxon.flags |= htole32(WPI_RXON_SHPREAMBLE);
	sc->rxon.filter |= htole32(WPI_FILTER_BSS);
	DPRINTF(("rxon chan %d flags %x\n", sc->rxon.chan, sc->rxon.flags));
	error = wpi_cmd(sc, WPI_CMD_RXON, &sc->rxon, sizeof (struct wpi_rxon),
	    1);
	if (error != 0) {
		printf("%s: RXON command failed\n", sc->sc_dev.dv_xname);
		return error;
	}

	/* Configuration has changed, set TX power accordingly. */
	if ((error = wpi_set_txpower(sc, 1)) != 0) {
		printf("%s: could not set TX power\n", sc->sc_dev.dv_xname);
		return error;
	}

	/* Fake a join to init the TX rate. */
	((struct wpi_node *)ni)->id = WPI_ID_BSS;
	wpi_newassoc(ic, ni, 1);

	/* Add BSS node. */
	memset(&node, 0, sizeof node);
	IEEE80211_ADDR_COPY(node.macaddr, ni->ni_bssid);
	node.id = WPI_ID_BSS;
	node.plcp = (ic->ic_curmode == IEEE80211_MODE_11A) ?
	    wpi_rates[WPI_RIDX_OFDM6].plcp : wpi_rates[WPI_RIDX_CCK1].plcp;
	node.action = htole32(WPI_ACTION_SET_RATE);
	node.antenna = WPI_ANTENNA_BOTH;
	DPRINTF(("adding BSS node\n"));
	error = wpi_cmd(sc, WPI_CMD_ADD_NODE, &node, sizeof node, 1);
	if (error != 0) {
		printf("%s: could not add BSS node\n", sc->sc_dev.dv_xname);
		return error;
	}

	/* Start periodic calibration timer. */
	sc->calib_cnt = 0;
	timeout_add_msec(&sc->calib_to, 500);

	/* Link LED always on while associated. */
	wpi_set_led(sc, WPI_LED_LINK, 0, 1);

	/* Enable power-saving mode if requested by user. */
	if (sc->sc_ic.ic_flags & IEEE80211_F_PMGTON)
		(void)wpi_set_pslevel(sc, 0, 3, 1);

	return 0;
}

/*
 * We support CCMP hardware encryption/decryption of unicast frames only.
 * HW support for TKIP really sucks.  We should let TKIP die anyway.
 */
int
wpi_set_key(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct ieee80211_key *k)
{
	struct wpi_softc *sc = ic->ic_softc;
	struct wpi_node *wn = (void *)ni;
	struct wpi_node_info node;
	uint16_t kflags;

	if ((k->k_flags & IEEE80211_KEY_GROUP) ||
	    k->k_cipher != IEEE80211_CIPHER_CCMP)
		return ieee80211_set_key(ic, ni, k);

	kflags = WPI_KFLAG_CCMP | WPI_KFLAG_KID(k->k_id);
	memset(&node, 0, sizeof node);
	node.id = wn->id;
	node.control = WPI_NODE_UPDATE;
	node.flags = WPI_FLAG_SET_KEY;
	node.kflags = htole16(kflags);
	memcpy(node.key, k->k_key, k->k_len);
	DPRINTF(("set key id=%d for node %d\n", k->k_id, node.id));
	return wpi_cmd(sc, WPI_CMD_ADD_NODE, &node, sizeof node, 1);
}

void
wpi_delete_key(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct ieee80211_key *k)
{
	struct wpi_softc *sc = ic->ic_softc;
	struct wpi_node *wn = (void *)ni;
	struct wpi_node_info node;

	if ((k->k_flags & IEEE80211_KEY_GROUP) ||
	    k->k_cipher != IEEE80211_CIPHER_CCMP) {
		/* See comment about other ciphers above. */
		ieee80211_delete_key(ic, ni, k);
		return;
	}
	if (ic->ic_state != IEEE80211_S_RUN)
		return;	/* Nothing to do. */
	memset(&node, 0, sizeof node);
	node.id = wn->id;
	node.control = WPI_NODE_UPDATE;
	node.flags = WPI_FLAG_SET_KEY;
	node.kflags = 0;
	DPRINTF(("delete keys for node %d\n", node.id));
	(void)wpi_cmd(sc, WPI_CMD_ADD_NODE, &node, sizeof node, 1);
}

int
wpi_post_alive(struct wpi_softc *sc)
{
	int ntries, error;

	/* Check (again) that the radio is not disabled. */
	if ((error = wpi_nic_lock(sc)) != 0)
		return error;
	/* NB: Runtime firmware must be up and running. */
	if (!(wpi_prph_read(sc, WPI_APMG_RFKILL) & 1)) {
		printf("%s: radio is disabled by hardware switch\n",
		    sc->sc_dev.dv_xname);
		wpi_nic_unlock(sc);
		return EPERM;	/* :-) */
	}
	wpi_nic_unlock(sc);

	/* Wait for thermal sensor to calibrate. */
	for (ntries = 0; ntries < 1000; ntries++) {
		if ((sc->temp = (int)WPI_READ(sc, WPI_UCODE_GP2)) != 0)
			break;
		DELAY(10);
	}
	if (ntries == 1000) {
		printf("%s: timeout waiting for thermal sensor calibration\n",
		    sc->sc_dev.dv_xname);
		return ETIMEDOUT;
	}
	DPRINTF(("temperature %d\n", sc->temp));
	return 0;
}

/*
 * The firmware boot code is small and is intended to be copied directly into
 * the NIC internal memory (no DMA transfer.)
 */
int
wpi_load_bootcode(struct wpi_softc *sc, const uint8_t *ucode, int size)
{
	int error, ntries;

	size /= sizeof (uint32_t);

	if ((error = wpi_nic_lock(sc)) != 0)
		return error;

	/* Copy microcode image into NIC memory. */
	wpi_prph_write_region_4(sc, WPI_BSM_SRAM_BASE,
	    (const uint32_t *)ucode, size);

	wpi_prph_write(sc, WPI_BSM_WR_MEM_SRC, 0);
	wpi_prph_write(sc, WPI_BSM_WR_MEM_DST, WPI_FW_TEXT_BASE);
	wpi_prph_write(sc, WPI_BSM_WR_DWCOUNT, size);

	/* Start boot load now. */
	wpi_prph_write(sc, WPI_BSM_WR_CTRL, WPI_BSM_WR_CTRL_START);

	/* Wait for transfer to complete. */
	for (ntries = 0; ntries < 1000; ntries++) {
		if (!(wpi_prph_read(sc, WPI_BSM_WR_CTRL) &
		    WPI_BSM_WR_CTRL_START))
			break;
		DELAY(10);
	}
	if (ntries == 1000) {
		printf("%s: could not load boot firmware\n",
		    sc->sc_dev.dv_xname);
		wpi_nic_unlock(sc);
		return ETIMEDOUT;
	}

	/* Enable boot after power up. */
	wpi_prph_write(sc, WPI_BSM_WR_CTRL, WPI_BSM_WR_CTRL_START_EN);

	wpi_nic_unlock(sc);
	return 0;
}

int
wpi_load_firmware(struct wpi_softc *sc)
{
	struct wpi_fw_info *fw = &sc->fw;
	struct wpi_dma_info *dma = &sc->fw_dma;
	int error;

	/* Copy initialization sections into pre-allocated DMA-safe memory. */
	memcpy(dma->vaddr, fw->init.data, fw->init.datasz);
	bus_dmamap_sync(sc->sc_dmat, dma->map, 0, fw->init.datasz,
	    BUS_DMASYNC_PREWRITE);
	memcpy(dma->vaddr + WPI_FW_DATA_MAXSZ,
	    fw->init.text, fw->init.textsz);
	bus_dmamap_sync(sc->sc_dmat, dma->map, WPI_FW_DATA_MAXSZ,
	    fw->init.textsz, BUS_DMASYNC_PREWRITE);

	/* Tell adapter where to find initialization sections. */
	if ((error = wpi_nic_lock(sc)) != 0)
		return error;
	wpi_prph_write(sc, WPI_BSM_DRAM_DATA_ADDR, dma->paddr);
	wpi_prph_write(sc, WPI_BSM_DRAM_DATA_SIZE, fw->init.datasz);
	wpi_prph_write(sc, WPI_BSM_DRAM_TEXT_ADDR,
	    dma->paddr + WPI_FW_DATA_MAXSZ);
	wpi_prph_write(sc, WPI_BSM_DRAM_TEXT_SIZE, fw->init.textsz);
	wpi_nic_unlock(sc);

	/* Load firmware boot code. */
	error = wpi_load_bootcode(sc, fw->boot.text, fw->boot.textsz);
	if (error != 0) {
		printf("%s: could not load boot firmware\n",
		    sc->sc_dev.dv_xname);
		return error;
	}
	/* Now press "execute". */
	WPI_WRITE(sc, WPI_RESET, 0);

	/* Wait at most one second for first alive notification. */
	if ((error = tsleep(sc, PCATCH, "wpiinit", hz)) != 0) {
		printf("%s: timeout waiting for adapter to initialize\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

	/* Copy runtime sections into pre-allocated DMA-safe memory. */
	memcpy(dma->vaddr, fw->main.data, fw->main.datasz);
	bus_dmamap_sync(sc->sc_dmat, dma->map, 0, fw->main.datasz,
	    BUS_DMASYNC_PREWRITE);
	memcpy(dma->vaddr + WPI_FW_DATA_MAXSZ,
	    fw->main.text, fw->main.textsz);
	bus_dmamap_sync(sc->sc_dmat, dma->map, WPI_FW_DATA_MAXSZ,
	    fw->main.textsz, BUS_DMASYNC_PREWRITE);

	/* Tell adapter where to find runtime sections. */
	if ((error = wpi_nic_lock(sc)) != 0)
		return error;
	wpi_prph_write(sc, WPI_BSM_DRAM_DATA_ADDR, dma->paddr);
	wpi_prph_write(sc, WPI_BSM_DRAM_DATA_SIZE, fw->main.datasz);
	wpi_prph_write(sc, WPI_BSM_DRAM_TEXT_ADDR,
	    dma->paddr + WPI_FW_DATA_MAXSZ);
	wpi_prph_write(sc, WPI_BSM_DRAM_TEXT_SIZE,
	    WPI_FW_UPDATED | fw->main.textsz);
	wpi_nic_unlock(sc);

	return 0;
}

int
wpi_read_firmware(struct wpi_softc *sc)
{
	struct wpi_fw_info *fw = &sc->fw;
	const struct wpi_firmware_hdr *hdr;
	int error;

	/* Read firmware image from filesystem. */
	if ((error = loadfirmware("wpi-3945abg", &fw->data, &fw->datalen)) != 0) {
		printf("%s: error, %d, could not read firmware %s\n",
		    sc->sc_dev.dv_xname, error, "wpi-3945abg");
		return error;
	}
	if (fw->datalen < sizeof (*hdr)) {
		printf("%s: truncated firmware header: %zu bytes\n",
		    sc->sc_dev.dv_xname, fw->datalen);
		free(fw->data, M_DEVBUF, fw->datalen);
		return EINVAL;
	}
	/* Extract firmware header information. */
	hdr = (struct wpi_firmware_hdr *)fw->data;
	fw->main.textsz = letoh32(hdr->main_textsz);
	fw->main.datasz = letoh32(hdr->main_datasz);
	fw->init.textsz = letoh32(hdr->init_textsz);
	fw->init.datasz = letoh32(hdr->init_datasz);
	fw->boot.textsz = letoh32(hdr->boot_textsz);
	fw->boot.datasz = 0;

	/* Sanity-check firmware header. */
	if (fw->main.textsz > WPI_FW_TEXT_MAXSZ ||
	    fw->main.datasz > WPI_FW_DATA_MAXSZ ||
	    fw->init.textsz > WPI_FW_TEXT_MAXSZ ||
	    fw->init.datasz > WPI_FW_DATA_MAXSZ ||
	    fw->boot.textsz > WPI_FW_BOOT_TEXT_MAXSZ ||
	    (fw->boot.textsz & 3) != 0) {
		printf("%s: invalid firmware header\n", sc->sc_dev.dv_xname);
		free(fw->data, M_DEVBUF, fw->datalen);
		return EINVAL;
	}

	/* Check that all firmware sections fit. */
	if (fw->datalen < sizeof (*hdr) + fw->main.textsz + fw->main.datasz +
	    fw->init.textsz + fw->init.datasz + fw->boot.textsz) {
		printf("%s: firmware file too short: %zu bytes\n",
		    sc->sc_dev.dv_xname, fw->datalen);
		free(fw->data, M_DEVBUF, fw->datalen);
		return EINVAL;
	}

	/* Get pointers to firmware sections. */
	fw->main.text = (const uint8_t *)(hdr + 1);
	fw->main.data = fw->main.text + fw->main.textsz;
	fw->init.text = fw->main.data + fw->main.datasz;
	fw->init.data = fw->init.text + fw->init.textsz;
	fw->boot.text = fw->init.data + fw->init.datasz;

	return 0;
}

int
wpi_clock_wait(struct wpi_softc *sc)
{
	int ntries;

	/* Set "initialization complete" bit. */
	WPI_SETBITS(sc, WPI_GP_CNTRL, WPI_GP_CNTRL_INIT_DONE);

	/* Wait for clock stabilization. */
	for (ntries = 0; ntries < 25000; ntries++) {
		if (WPI_READ(sc, WPI_GP_CNTRL) & WPI_GP_CNTRL_MAC_CLOCK_READY)
			return 0;
		DELAY(100);
	}
	printf("%s: timeout waiting for clock stabilization\n",
	    sc->sc_dev.dv_xname);
	return ETIMEDOUT;
}

int
wpi_apm_init(struct wpi_softc *sc)
{
	int error;

	WPI_SETBITS(sc, WPI_ANA_PLL, WPI_ANA_PLL_INIT);
	/* Disable L0s. */
	WPI_SETBITS(sc, WPI_GIO_CHICKEN, WPI_GIO_CHICKEN_L1A_NO_L0S_RX);

	if ((error = wpi_clock_wait(sc)) != 0)
		return error;

	if ((error = wpi_nic_lock(sc)) != 0)
		return error;
	/* Enable DMA. */
	wpi_prph_write(sc, WPI_APMG_CLK_ENA,
	    WPI_APMG_CLK_DMA_CLK_RQT | WPI_APMG_CLK_BSM_CLK_RQT);
	DELAY(20);
	/* Disable L1. */
	wpi_prph_setbits(sc, WPI_APMG_PCI_STT, WPI_APMG_PCI_STT_L1A_DIS);
	wpi_nic_unlock(sc);

	return 0;
}

void
wpi_apm_stop_master(struct wpi_softc *sc)
{
	int ntries;

	WPI_SETBITS(sc, WPI_RESET, WPI_RESET_STOP_MASTER);

	if ((WPI_READ(sc, WPI_GP_CNTRL) & WPI_GP_CNTRL_PS_MASK) ==
	    WPI_GP_CNTRL_MAC_PS)
		return;	/* Already asleep. */

	for (ntries = 0; ntries < 100; ntries++) {
		if (WPI_READ(sc, WPI_RESET) & WPI_RESET_MASTER_DISABLED)
			return;
		DELAY(10);
	}
	printf("%s: timeout waiting for master\n", sc->sc_dev.dv_xname);
}

void
wpi_apm_stop(struct wpi_softc *sc)
{
	wpi_apm_stop_master(sc);
	WPI_SETBITS(sc, WPI_RESET, WPI_RESET_SW);
}

void
wpi_nic_config(struct wpi_softc *sc)
{
	pcireg_t reg;
	uint8_t rev;

	/* Voodoo from the reference driver. */
	reg = pci_conf_read(sc->sc_pct, sc->sc_pcitag, PCI_CLASS_REG);
	rev = PCI_REVISION(reg);
	if ((rev & 0xc0) == 0x40)
		WPI_SETBITS(sc, WPI_HW_IF_CONFIG, WPI_HW_IF_CONFIG_ALM_MB);
	else if (!(rev & 0x80))
		WPI_SETBITS(sc, WPI_HW_IF_CONFIG, WPI_HW_IF_CONFIG_ALM_MM);

	if (sc->cap == 0x80)
		WPI_SETBITS(sc, WPI_HW_IF_CONFIG, WPI_HW_IF_CONFIG_SKU_MRC);

	if ((letoh16(sc->rev) & 0xf0) == 0xd0)
		WPI_SETBITS(sc, WPI_HW_IF_CONFIG, WPI_HW_IF_CONFIG_REV_D);
	else
		WPI_CLRBITS(sc, WPI_HW_IF_CONFIG, WPI_HW_IF_CONFIG_REV_D);

	if (sc->type > 1)
		WPI_SETBITS(sc, WPI_HW_IF_CONFIG, WPI_HW_IF_CONFIG_TYPE_B);
}

int
wpi_hw_init(struct wpi_softc *sc)
{
	int chnl, ntries, error;

	/* Clear pending interrupts. */
	WPI_WRITE(sc, WPI_INT, 0xffffffff);

	if ((error = wpi_apm_init(sc)) != 0) {
		printf("%s: could not power ON adapter\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

	/* Select VMAIN power source. */
	if ((error = wpi_nic_lock(sc)) != 0)
		return error;
	wpi_prph_clrbits(sc, WPI_APMG_PS, WPI_APMG_PS_PWR_SRC_MASK);
	wpi_nic_unlock(sc);
	/* Spin until VMAIN gets selected. */
	for (ntries = 0; ntries < 5000; ntries++) {
		if (WPI_READ(sc, WPI_GPIO_IN) & WPI_GPIO_IN_VMAIN)
			break;
		DELAY(10);
	}
	if (ntries == 5000) {
		printf("%s: timeout selecting power source\n",
		    sc->sc_dev.dv_xname);
		return ETIMEDOUT;
	}

	/* Perform adapter initialization. */
	(void)wpi_nic_config(sc);

	/* Initialize RX ring. */
	if ((error = wpi_nic_lock(sc)) != 0)
		return error;
	/* Set physical address of RX ring. */
	WPI_WRITE(sc, WPI_FH_RX_BASE, sc->rxq.desc_dma.paddr);
	/* Set physical address of RX read pointer. */
	WPI_WRITE(sc, WPI_FH_RX_RPTR_ADDR, sc->shared_dma.paddr +
	    offsetof(struct wpi_shared, next));
	WPI_WRITE(sc, WPI_FH_RX_WPTR, 0);
	/* Enable RX. */
	WPI_WRITE(sc, WPI_FH_RX_CONFIG,
	    WPI_FH_RX_CONFIG_DMA_ENA |
	    WPI_FH_RX_CONFIG_RDRBD_ENA |
	    WPI_FH_RX_CONFIG_WRSTATUS_ENA |
	    WPI_FH_RX_CONFIG_MAXFRAG |
	    WPI_FH_RX_CONFIG_NRBD(WPI_RX_RING_COUNT_LOG) |
	    WPI_FH_RX_CONFIG_IRQ_DST_HOST |
	    WPI_FH_RX_CONFIG_IRQ_RBTH(1));
	(void)WPI_READ(sc, WPI_FH_RSSR_TBL);	/* barrier */
	WPI_WRITE(sc, WPI_FH_RX_WPTR, (WPI_RX_RING_COUNT - 1) & ~7);
	wpi_nic_unlock(sc);

	/* Initialize TX rings. */
	if ((error = wpi_nic_lock(sc)) != 0)
		return error;
	wpi_prph_write(sc, WPI_ALM_SCHED_MODE, 2);	/* bypass mode */
	wpi_prph_write(sc, WPI_ALM_SCHED_ARASTAT, 1);	/* enable RA0 */
	/* Enable all 6 TX rings. */
	wpi_prph_write(sc, WPI_ALM_SCHED_TXFACT, 0x3f);
	wpi_prph_write(sc, WPI_ALM_SCHED_SBYPASS_MODE1, 0x10000);
	wpi_prph_write(sc, WPI_ALM_SCHED_SBYPASS_MODE2, 0x30002);
	wpi_prph_write(sc, WPI_ALM_SCHED_TXF4MF, 4);
	wpi_prph_write(sc, WPI_ALM_SCHED_TXF5MF, 5);
	/* Set physical address of TX rings. */
	WPI_WRITE(sc, WPI_FH_TX_BASE, sc->shared_dma.paddr);
	WPI_WRITE(sc, WPI_FH_MSG_CONFIG, 0xffff05a5);

	/* Enable all DMA channels. */
	for (chnl = 0; chnl < WPI_NDMACHNLS; chnl++) {
		WPI_WRITE(sc, WPI_FH_CBBC_CTRL(chnl), 0);
		WPI_WRITE(sc, WPI_FH_CBBC_BASE(chnl), 0);
		WPI_WRITE(sc, WPI_FH_TX_CONFIG(chnl), 0x80200008);
	}
	wpi_nic_unlock(sc);
	(void)WPI_READ(sc, WPI_FH_TX_BASE);	/* barrier */

	/* Clear "radio off" and "commands blocked" bits. */
	WPI_WRITE(sc, WPI_UCODE_GP1_CLR, WPI_UCODE_GP1_RFKILL);
	WPI_WRITE(sc, WPI_UCODE_GP1_CLR, WPI_UCODE_GP1_CMD_BLOCKED);

	/* Clear pending interrupts. */
	WPI_WRITE(sc, WPI_INT, 0xffffffff);
	/* Enable interrupts. */
	WPI_WRITE(sc, WPI_MASK, WPI_INT_MASK);

	/* _Really_ make sure "radio off" bit is cleared! */
	WPI_WRITE(sc, WPI_UCODE_GP1_CLR, WPI_UCODE_GP1_RFKILL);
	WPI_WRITE(sc, WPI_UCODE_GP1_CLR, WPI_UCODE_GP1_RFKILL);

	if ((error = wpi_load_firmware(sc)) != 0) {
		printf("%s: could not load firmware\n", sc->sc_dev.dv_xname);
		return error;
	}
	/* Wait at most one second for firmware alive notification. */
	if ((error = tsleep(sc, PCATCH, "wpiinit", hz)) != 0) {
		printf("%s: timeout waiting for adapter to initialize\n",
		    sc->sc_dev.dv_xname);
		return error;
	}
	/* Do post-firmware initialization. */
	return wpi_post_alive(sc);
}

void
wpi_hw_stop(struct wpi_softc *sc)
{
	int chnl, qid, ntries;
	uint32_t tmp;

	WPI_WRITE(sc, WPI_RESET, WPI_RESET_NEVO);

	/* Disable interrupts. */
	WPI_WRITE(sc, WPI_MASK, 0);
	WPI_WRITE(sc, WPI_INT, 0xffffffff);
	WPI_WRITE(sc, WPI_FH_INT, 0xffffffff);

	/* Make sure we no longer hold the NIC lock. */
	wpi_nic_unlock(sc);

	if (wpi_nic_lock(sc) == 0) {
		/* Stop TX scheduler. */
		wpi_prph_write(sc, WPI_ALM_SCHED_MODE, 0);
		wpi_prph_write(sc, WPI_ALM_SCHED_TXFACT, 0);

		/* Stop all DMA channels. */
		for (chnl = 0; chnl < WPI_NDMACHNLS; chnl++) {
			WPI_WRITE(sc, WPI_FH_TX_CONFIG(chnl), 0);
			for (ntries = 0; ntries < 100; ntries++) {
				tmp = WPI_READ(sc, WPI_FH_TX_STATUS);
				if ((tmp & WPI_FH_TX_STATUS_IDLE(chnl)) ==
				    WPI_FH_TX_STATUS_IDLE(chnl))
					break;
				DELAY(10);
			}
		}
		wpi_nic_unlock(sc);
	}

	/* Stop RX ring. */
	wpi_reset_rx_ring(sc, &sc->rxq);

	/* Reset all TX rings. */
	for (qid = 0; qid < WPI_NTXQUEUES; qid++)
		wpi_reset_tx_ring(sc, &sc->txq[qid]);

	if (wpi_nic_lock(sc) == 0) {
		wpi_prph_write(sc, WPI_APMG_CLK_DIS, WPI_APMG_CLK_DMA_CLK_RQT);
		wpi_nic_unlock(sc);
	}
	DELAY(5);
	/* Power OFF adapter. */
	wpi_apm_stop(sc);
}

int
wpi_init(struct ifnet *ifp)
{
	struct wpi_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	int error;

#ifdef notyet
	/* Check that the radio is not disabled by hardware switch. */
	if (!(WPI_READ(sc, WPI_GP_CNTRL) & WPI_GP_CNTRL_RFKILL)) {
		printf("%s: radio is disabled by hardware switch\n",
		    sc->sc_dev.dv_xname);
		error = EPERM;	/* :-) */
		goto fail;
	}
#endif
	/* Read firmware images from the filesystem. */
	if ((error = wpi_read_firmware(sc)) != 0) {
		printf("%s: could not read firmware\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	/* Initialize hardware and upload firmware. */
	error = wpi_hw_init(sc);
	free(sc->fw.data, M_DEVBUF, sc->fw.datalen);
	if (error != 0) {
		printf("%s: could not initialize hardware\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/* Configure adapter now that it is ready. */
	if ((error = wpi_config(sc)) != 0) {
		printf("%s: could not configure device\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_flags |= IFF_RUNNING;

	if (ic->ic_opmode != IEEE80211_M_MONITOR)
		ieee80211_begin_scan(ifp);
	else
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);

	return 0;

fail:	wpi_stop(ifp, 1);
	return error;
}

void
wpi_stop(struct ifnet *ifp, int disable)
{
	struct wpi_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;

	ifp->if_timer = sc->sc_tx_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/* In case we were scanning, release the scan "lock". */
	ic->ic_scan_lock = IEEE80211_SCAN_UNLOCKED;

	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);

	/* Power OFF hardware. */
	wpi_hw_stop(sc);
}
@


1.139
log
@Do not clear IFF_UP, even in the error path, clearing IFF_RUNNING
is enough.

This flag should only be set by the stack, drivers shouldn't mess
with it.

Discussed with dlg@@ and mikeb@@, ok mikeb@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.138 2017/01/22 10:17:38 dlg Exp $	*/
a2959 1
	size_t size;
d2963 1
a2963 1
	if ((error = loadfirmware("wpi-3945abg", &fw->data, &size)) != 0) {
d2968 1
a2968 1
	if (size < sizeof (*hdr)) {
d2970 2
a2971 2
		    sc->sc_dev.dv_xname, size);
		free(fw->data, M_DEVBUF, size);
d2991 1
a2991 1
		free(fw->data, M_DEVBUF, size);
d2996 1
a2996 1
	if (size < sizeof (*hdr) + fw->main.textsz + fw->main.datasz +
d2999 2
a3000 2
		    sc->sc_dev.dv_xname, size);
		free(fw->data, M_DEVBUF, size);
d3292 1
a3292 1
	free(sc->fw.data, M_DEVBUF, 0);
@


1.138
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.137 2016/12/23 18:44:51 kettenis Exp $	*/
a1478 1
				ifp->if_flags &= ~IFF_UP;
a1955 1
			ifp->if_flags &= ~IFF_UP;
@


1.137
log
@Hide static inline functions that are only used in debug code behind the same
#ifdef as the debug code itself.  Prevents clang from warning about these
functions being unused.

ok stsp@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.136 2016/10/05 21:26:54 stsp Exp $	*/
a1363 2
	else
		ifp->if_opackets++;
@


1.136
log
@Hide wpi(4) fatal firmware error details inside #ifdef WPI_DEBUG.
ok sthen tb deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.135 2016/09/05 08:18:40 tedu Exp $	*/
d497 2
d522 2
@


1.135
log
@convert busy flag and tsleep to rwlock as in iwm
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.134 2016/08/17 11:08:08 stsp Exp $	*/
d1529 1
d1597 1
d1627 1
d1629 1
@


1.134
log
@wpi(4) scans all bands at once, as far as the net80211 stack is concerned.
So set the appropriate scan capability flags in the ic.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.133 2016/04/13 10:34:32 mpi Exp $	*/
d30 1
d327 1
d426 1
a427 3
	while (sc->sc_flags & WPI_FLAG_BUSY)
		tsleep(&sc->sc_flags, 0, "wpipwr", 0);
	sc->sc_flags |= WPI_FLAG_BUSY;
a431 2
	sc->sc_flags &= ~WPI_FLAG_BUSY;
	wakeup(&sc->sc_flags);
d433 1
d1970 3
a1973 11
	/*
	 * Prevent processes from entering this function while another
	 * process is tsleep'ing in it.
	 */
	while ((sc->sc_flags & WPI_FLAG_BUSY) && error == 0)
		error = tsleep(&sc->sc_flags, PCATCH, "wpiioc", 0);
	if (error != 0) {
		splx(s);
		return error;
	}
	sc->sc_flags |= WPI_FLAG_BUSY;
a2027 2
	sc->sc_flags &= ~WPI_FLAG_BUSY;
	wakeup(&sc->sc_flags);
d2029 1
@


1.133
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.132 2015/11/25 03:09:59 dlg Exp $	*/
d281 2
@


1.132
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.131 2015/11/24 13:33:17 mpi Exp $	*/
a301 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.131
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.130 2015/11/04 12:11:59 dlg Exp $	*/
d1375 2
a1376 2
		if (sc->qfullmsk == 0 && (ifp->if_flags & IFF_OACTIVE)) {
			ifp->if_flags &= ~IFF_OACTIVE;
d1898 1
a1898 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d1903 1
a1903 1
			ifp->if_flags |= IFF_OACTIVE;
d3312 1
a3312 1
	ifp->if_flags &= ~IFF_OACTIVE;
d3333 2
a3334 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.130
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.129 2015/10/25 13:04:28 mpi Exp $	*/
a50 1
#include <net/if_types.h>
@


1.129
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.128 2015/09/06 04:09:59 deraadt Exp $	*/
d1908 1
a1908 1
		IF_DEQUEUE(&ic->ic_mgtq, m);
@


1.128
log
@sizes for free() - most are about the firmware memory
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.127 2015/05/27 22:10:52 kettenis Exp $	*/
a1967 1
	struct ifaddr *ifa;
a1985 1
		ifa = (struct ifaddr *)data;
a1986 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.127
log
@Use m_defrag(9) instead of rolling our own inlined version.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.126 2015/03/16 04:09:53 jsg Exp $	*/
d2625 1
a2625 1
	free(buf, M_DEVBUF, 0);
d2982 1
a2982 1
		free(fw->data, M_DEVBUF, 0);
d3002 1
a3002 1
		free(fw->data, M_DEVBUF, 0);
d3011 1
a3011 1
		free(fw->data, M_DEVBUF, 0);
@


1.126
log
@convert timeout_add() calls using hz to timeout_add_msec()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.125 2015/03/14 03:38:48 jsg Exp $	*/
a1657 1
	struct mbuf *m1;
d1835 1
a1835 2
		MGETHDR(m1, M_DONTWAIT, MT_DATA);
		if (m1 == NULL) {
a1838 13
		if (m->m_pkthdr.len > MHLEN) {
			MCLGET(m1, M_DONTWAIT);
			if (!(m1->m_flags & M_EXT)) {
				m_freem(m);
				m_freem(m1);
				return ENOBUFS;
			}
		}
		m_copydata(m, 0, m->m_pkthdr.len, mtod(m1, caddr_t));
		m1->m_pkthdr.len = m1->m_len = m->m_pkthdr.len;
		m_freem(m);
		m = m1;

@


1.125
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.124 2015/02/10 23:25:46 mpi Exp $	*/
d2771 1
a2771 1
	timeout_add(&sc->calib_to, hz / 2);
@


1.124
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.123 2015/01/27 03:17:36 dlg Exp $	*/
a48 1
#include <net/if_arp.h>
@


1.123
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.122 2014/12/22 02:28:52 tedu Exp $	*/
a1256 1
	m->m_pkthdr.rcvif = ifp;
@


1.122
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.121 2014/12/19 22:44:58 guenther Exp $	*/
d77 1
a77 1
void		wpi_init_task(void *, void *);
d327 1
a327 1
	task_set(&sc->init_task, wpi_init_task, sc, NULL);
d415 1
a415 1
	wpi_init_task(sc, NULL);
d419 1
a419 1
wpi_init_task(void *arg1, void *args2)
@


1.121
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.120 2014/07/22 13:12:11 mpi Exp $	*/
a2005 1
#ifdef INET
a2007 1
#endif
@


1.120
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.119 2014/07/12 18:48:52 tedu Exp $	*/
d36 1
a38 1
#include <machine/endian.h>
@


1.119
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.118 2014/03/19 10:09:19 mpi Exp $	*/
a54 1
#include <netinet/in_systm.h>
a55 1
#include <netinet/ip.h>
@


1.118
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.117 2013/12/06 21:03:04 deraadt Exp $	*/
d2646 1
a2646 1
	free(buf, M_DEVBUF);
d3003 1
a3003 1
		free(fw->data, M_DEVBUF);
d3023 1
a3023 1
		free(fw->data, M_DEVBUF);
d3032 1
a3032 1
		free(fw->data, M_DEVBUF);
d3324 1
a3324 1
	free(sc->fw.data, M_DEVBUF);
@


1.117
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.116 2013/11/28 20:07:32 kettenis Exp $	*/
d1929 1
a1929 1
			ni = (void *)m->m_pkthdr.rcvif;
@


1.116
log
@Seems we simply have tolibe with fatal firmware errors.  Even Linux, with its
driver written by Intel engineers occasionally gets them.  So when we get one,
simply reset the chip, reload the firware and bring the interface up again.

ok chris@@, phessler@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.115 2013/11/16 12:46:29 kettenis Exp $	*/
d78 1
a78 1
void		wpi_resume(struct wpi_softc *);
d399 2
a400 2
	case DVACT_RESUME:
		wpi_resume(sc);
d408 1
a408 1
wpi_resume(struct wpi_softc *sc)
d417 1
a417 1
	task_add(systq, &sc->init_task);
@


1.115
log
@Enable 802.11a support.  Seems to work fine on:

wpi0 at pci2 dev 0 function 0 "Intel PRO/Wireless 3945ABG" rev 0x02: msi, MoW2

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.114 2013/11/14 12:34:30 dlg Exp $	*/
d78 2
a79 1
void		wpi_resume(void *, void *);
a192 2
	task_set(&sc->sc_resume_t, wpi_resume, sc, NULL);

d329 1
d367 1
d400 1
a400 1
		task_add(systq, &sc->sc_resume_t);
d408 1
a408 1
wpi_resume(void *arg1, void *arg2)
a409 2
	struct wpi_softc *sc = arg1;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
a410 1
	int s;
d417 10
d432 1
a432 1
	if (ifp->if_flags & IFF_UP)
a1630 1
		ifp->if_flags &= ~IFF_UP;
d1632 1
@


1.114
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.113 2013/10/01 20:06:02 sf Exp $	*/
d925 2
@


1.113
log
@Use %z* for size_t

while there, fix a few %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.112 2013/08/07 01:06:39 bluhm Exp $	*/
d35 1
a35 1
#include <sys/workq.h>
d192 2
d399 1
a399 2
		workq_queue_task(NULL, &sc->sc_resume_wqt, 0,
		    wpi_resume, sc, NULL);
@


1.112
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.111 2013/06/11 18:15:52 deraadt Exp $	*/
d2990 1
a2990 1
		printf("%s: truncated firmware header: %d bytes\n",
d3019 1
a3019 1
		printf("%s: firmware file too short: %d bytes\n",
@


1.111
log
@Replace all ovbcopy with memmove; swap the src and dst arguments too
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.110 2011/06/02 18:36:53 mk Exp $	*/
a55 1
#include <netinet/in_var.h>
@


1.110
log
@MSI for wpi(4).

``Reasonably confident that will work on all hardware, go ahead and
commit.'' kettenis (worst jinx ever)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.109 2010/09/07 16:21:45 deraadt Exp $	*/
d1158 1
a1158 1
	ovbcopy(wh, mtod(m, caddr_t) + IEEE80211_CCMP_HDRLEN, hdrlen);
@


1.109
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.108 2010/08/27 20:09:01 deraadt Exp $	*/
d218 1
a218 1
	if (pci_intr_map(pa, &ih) != 0) {
@


1.108
log
@Move the guts of the powerhook function into the activate function and make
it stop calling the powerhook function; then make the powerhook function
call activate.  This basically inverts the whole goop.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.107 2010/08/27 17:08:00 jsg Exp $	*/
a79 1
void		wpi_powerhook(int, void *);
a328 3

	sc->powerhook = powerhook_establish(wpi_powerhook, sc);

a370 3
	if (sc->powerhook != NULL)
		powerhook_disestablish(sc->powerhook);

a429 6
}

void
wpi_powerhook(int why, void *arg)
{
	wpi_activate(arg, why);
@


1.107
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.106 2010/08/12 16:59:29 damien Exp $	*/
d80 1
a80 1
void		wpi_power(int, void *);
d331 1
a331 1
	sc->powerhook = powerhook_establish(wpi_power, sc);
d416 1
a416 7
	wpi_power(PWR_RESUME, arg1);
}

void
wpi_power(int why, void *arg)
{
	struct wpi_softc *sc = arg;
a420 5
	if (why != PWR_RESUME) {
		wpi_stop(ifp, 0);
		return;
	}

d437 6
@


1.106
log
@homogeneous style.

no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.105 2010/08/12 15:04:00 oga Exp $	*/
a303 1
	ifp->if_init = wpi_init;
@


1.105
log
@Instead of returning EBUSY when the busy flag is set in the ioctl, sleep
until whoever has it is done with it.

This is kept as flag/sleep condvars instead of a rwlock because later we
may want to quiesce the handler before suspend to make sure nothing is
sleeping on a chip that is about to be whacked (doing so will change the
proc so rwlocks won't work).

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.104 2010/08/03 18:26:25 kettenis Exp $	*/
d411 1
a411 1
	return (0);
d2005 1
a2005 1
	while (sc->sc_flags & WPI_FLAG_BUSY && error == 0)
d2007 1
a2007 1
	if (error) {
@


1.104
log
@Bring the suspend/resume code of all the Intel wireless drivers in line with
iwn(4) again.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.103 2010/07/28 21:21:38 deraadt Exp $	*/
d439 2
d447 1
d2005 3
a2007 1
	if (sc->sc_flags & WPI_FLAG_BUSY) {
d2009 1
a2009 1
		return EBUSY;
d2072 1
@


1.103
log
@Make legacy xxpower() functions call xxstop() on suspend, and simplify their
resume paths.  For new-style suspend/resume, add a ca_activate function where
it is missing, and use a workq to resume because these drivers like to sleep.
ok damien
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.102 2010/07/22 14:42:43 kettenis Exp $	*/
d441 2
a442 5
	if (ifp->if_flags & IFF_UP) {
		ifp->if_init(ifp);
		if (ifp->if_flags & IFF_RUNNING)
			ifp->if_start(ifp);
	}
@


1.102
log
@Add suspend/resume logic.  As discussed with phessler@@, incorporating
suggestions by damien@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.101 2010/07/22 10:22:37 kettenis Exp $	*/
d403 1
a403 1
			wpi_stop(ifp, 1);
d424 1
a424 1
	struct ifnet *ifp;
d428 2
a429 1
	if (why != PWR_RESUME)
d431 1
a440 1
	ifp = &sc->sc_ic.ic_if;
@


1.101
log
@Prevent a process from entering wpi_ioctl while another process is
tsleep'ing (for example waiting for the firmware to become alive)
in iwn_init.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.100 2010/04/20 22:05:43 tedu Exp $	*/
d35 1
d78 2
d167 2
a168 1
	sizeof (struct wpi_softc), wpi_match, wpi_attach, wpi_detach
d394 26
d437 2
d445 2
@


1.100
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.99 2009/11/17 20:35:51 damien Exp $	*/
d1966 9
d2034 1
@


1.99
log
@nuke the temperature sensor.
it is totally useless since (contrary to the one in iwn(4)) it
is not in any known unit (can't be converted to degK or degC).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.98 2009/11/03 18:55:23 damien Exp $	*/
a27 1
#include <sys/sysctl.h>
@


1.98
log
@use BUS_DMA_{READ,WRITE} hints when mapping mbufs for Rx/Tx even
though this does nothing on i386 and amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.97 2009/10/31 11:52:07 damien Exp $	*/
a35 1
#include <sys/sensors.h>
a73 3
#ifndef SMALL_KERNEL
void		wpi_sensor_attach(struct wpi_softc *);
#endif
d124 1
a124 1
void		wpi_power_calibration(struct wpi_softc *, int);
a323 3
#ifndef SMALL_KERNEL
	wpi_sensor_attach(sc);
#endif
a339 19
#ifndef SMALL_KERNEL
/*
 * Attach the adapter on-board thermal sensor to the sensors framework.
 */
void
wpi_sensor_attach(struct wpi_softc *sc)
{
	strlcpy(sc->sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof sc->sensordev.xname);
	strlcpy(sc->sensor.desc, "temperature 0 - 285",
	    sizeof sc->sensor.desc);
	sc->sensor.type = SENSOR_INTEGER;	/* not in muK! */
	/* Temperature is not valid unless interface is up. */
	sc->sensor.flags = SENSOR_FINVALID;
	sensor_attach(&sc->sensordev, &sc->sensor);
	sensordev_install(&sc->sensordev);
}
#endif

a384 6
#ifndef SMALL_KERNEL
	/* Detach the thermal sensor. */
	sensor_detach(&sc->sensordev, &sc->sensor);
	sensordev_deinstall(&sc->sensordev);
#endif

d1079 1
a1079 1
	int temp, s;
a1088 3
	/* Update sensor. */
	temp = (int)WPI_READ(sc, WPI_UCODE_GP2);
	sc->sensor.value = temp + 260;
d1092 1
a1092 1
		wpi_power_calibration(sc, temp);
d2219 1
a2219 1
wpi_power_calibration(struct wpi_softc *sc, int temp)
d2221 3
a2832 2
	sc->sensor.value = sc->temp + 260;
	sc->sensor.flags &= ~SENSOR_FINVALID;
a3329 4

	/* Temperature sensor is no longer valid. */
	sc->sensor.value = 0;
	sc->sensor.flags |= SENSOR_FINVALID;
@


1.97
log
@reorder operations in detach(), call powerhook_disestablish() earlier,
call if_detach() last.
no need to splnet() since we are already called at the right ipl.

iwn(4) diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.96 2009/10/26 18:38:32 damien Exp $	*/
d696 1
a696 1
		    BUS_DMA_NOWAIT);
d1239 1
a1239 1
	    WPI_RBUF_SIZE, NULL, BUS_DMA_NOWAIT);
d1246 1
a1246 1
		    BUS_DMA_NOWAIT);
d1841 1
a1841 1
	    BUS_DMA_NOWAIT);
d1869 1
a1869 1
		    BUS_DMA_NOWAIT);
d2099 1
a2099 1
		    NULL, BUS_DMA_NOWAIT);
@


1.96
log
@start Tx at lowest available rate to give initial WPA handshake and
DHCP more chance to succeed w/o too much retries.
AMRR is good enough at raising the Tx rate fast.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.95 2009/10/24 21:01:18 damien Exp $	*/
d391 1
a391 1
	int s, qid;
a392 1
	s = splnet();
d399 2
a400 3
	ieee80211_ifdetach(ifp);
 	if_detach(ifp);
	splx(s);
d409 2
d417 2
a418 4
	if (sc->powerhook != NULL)
		powerhook_disestablish(sc->powerhook);

	bus_space_unmap(sc->sc_st, sc->sc_sh, sc->sc_sz);
@


1.95
log
@call wpi_power_calibration() at splnet().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.94 2009/10/24 20:17:17 damien Exp $	*/
d590 1
a590 1
	    BUS_DMA_NOWAIT);
d1003 2
a1012 3
		/* Initial TX rate <= 24Mbps. */
		if (rate <= 48)
			ni->ni_txrate = i;
@


1.94
log
@add explicit barriers for read/write accesses to prph and internal memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.93 2009/10/24 18:19:49 damien Exp $	*/
d1116 1
a1118 1
		s = splnet();
a1122 1
		splx(s);
d1133 2
@


1.93
log
@- update bluetooth coexistence command
- rename CMD_CONFIGURE into CMD_RXON (like iwn)
- properly stop TX FIFOs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.92 2009/09/20 20:04:07 damien Exp $	*/
d480 1
d488 1
d516 1
d524 1
@


1.92
log
@Implement a detach function in wpi(4) and iwn(4).
Some laptops will power off the PCIe socket when the radio kill
switch is turned on.

Reported and tested by Frantisek Holop on iwn(4).
Initial diff for iwn(4) by jsg@@
Some additional bits by Frantisek Holop (sensor_detach).
Some tweaks and adaptation to wpi(4) by me.

Fixes kernel/6223.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.91 2009/08/10 17:21:15 damien Exp $	*/
d349 1
a349 1
 * Attach the adapter's on-board thermal sensor to the sensors framework.
d774 1
a774 1
	/* Update shared area with ring's physical address. */
d2344 1
a2344 1
	/* Default TX power is group's maximum TX power minus 3dB. */
d2360 1
a2360 1
	/* Never exceed the channel's maximum allowed TX power. */
d2462 3
a2464 3
	bluetooth.flags = 3;
	bluetooth.lead = 0xaa;
	bluetooth.kill = 1;
d2498 2
a2499 2
	error = wpi_cmd(sc, WPI_CMD_CONFIGURE, &sc->rxon,
	    sizeof (struct wpi_rxon), 0);
d2501 1
a2501 1
		printf("%s: configure command failed\n", sc->sc_dev.dv_xname);
d2650 1
a2650 1
	/* Update adapter's configuration. */
d2675 2
a2676 2
	error = wpi_cmd(sc, WPI_CMD_CONFIGURE, &sc->rxon,
	    sizeof (struct wpi_rxon), 1);
d2678 1
a2678 1
		printf("%s: could not configure\n", sc->sc_dev.dv_xname);
d2688 1
a2688 1
	 * Reconfiguring RXON clears the firmware's nodes table so we must
d2725 1
a2725 1
	/* Update adapter's configuration. */
d2735 2
a2736 2
	error = wpi_cmd(sc, WPI_CMD_CONFIGURE, &sc->rxon,
	    sizeof (struct wpi_rxon), 1);
d2738 1
a2738 2
		printf("%s: could not update configuration\n",
		    sc->sc_dev.dv_xname);
d3262 1
@


1.91
log
@i prefer (m == NULL) over (!m)
change two error messages while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.90 2009/08/09 11:40:56 deraadt Exp $	*/
d81 1
d169 1
a169 1
	sizeof (struct wpi_softc), wpi_match, wpi_attach
d385 39
@


1.90
log
@MCLGETI() will now allocate a mbuf header if it is not provided, thus
reducing the amount of splnet/splx dancing required.. especially in the
worst case (of m_cldrop)
ok dlg kettenis damien
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.89 2009/07/11 13:28:36 blambert Exp $	*/
d645 2
a646 2
		if (!data->m) {
			printf("%s: could not allocate RX mbuf cluster\n",
d1189 1
a1189 1
	if (!m1) {
@


1.89
log
@timeout_add -> timeout_add_msec

Been running this on my laptop for a while now with no apparent ill effects.

originally from a longer list from grange@@
ok krw@@ as part of that list
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.88 2009/06/02 16:28:21 damien Exp $	*/
d644 2
a645 9
		MGETHDR(data->m, M_DONTWAIT, MT_DATA);
		if (data->m == NULL) {
			printf("%s: could not allocate RX mbuf\n",
			    sc->sc_dev.dv_xname);
			error = ENOBUFS;
			goto fail;
		}
		MCLGETI(data->m, M_DONTWAIT, NULL, WPI_RBUF_SIZE);
		if (!(data->m->m_flags & M_EXT)) {
d1188 2
a1189 9
	MGETHDR(m1, M_DONTWAIT, MT_DATA);
	if (m1 == NULL) {
		ic->ic_stats.is_rx_nombuf++;
		ifp->if_ierrors++;
		return;
	}
	MCLGETI(m1, M_DONTWAIT, NULL, WPI_RBUF_SIZE);
	if (!(m1->m_flags & M_EXT)) {
		m_freem(m1);
@


1.88
log
@do not leak mbufs in the Rx path in case hardware decryption failed.
this leak was introduced when i switched to MCLGETI.

reported by mpf@@ and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.87 2009/05/29 08:25:45 damien Exp $	*/
d1098 1
a1098 1
	timeout_add(&sc->calib_to, hz / 2);
@


1.87
log
@fix confusion between number of DMA channels and number of Tx queues.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.86 2009/05/12 19:10:57 damien Exp $	*/
d1257 1
d1265 1
d1270 1
@


1.86
log
@switch wpi(4) and iwn(4) over to MCLGETI.
notice that i'm not using the per-ifp mbuf accounting/mitigation yet.
for iwn(4), this means we wont' be able to support full 8KB AMSDU on
machines without an IOMMU since >4KB clusters are not guaranteed to
be physcontig.  fortunately, we can program the hardware to do 4KB
AMSDUs only.
simplify {pwi,iwn}_dma_contig_alloc while i'm here: use BUS_DMA_ZERO
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.85 2009/04/26 02:20:58 cnst Exp $	*/
d788 1
a788 2
	uint32_t tmp;
	int i, ntries;
a789 11
	if (wpi_nic_lock(sc) == 0) {
		WPI_WRITE(sc, WPI_FH_TX_CONFIG(ring->qid), 0);
		for (ntries = 0; ntries < 100; ntries++) {
			tmp = WPI_READ(sc, WPI_FH_TX_STATUS);
			if ((tmp & WPI_FH_TX_STATUS_IDLE(ring->qid)) ==
			    WPI_FH_TX_STATUS_IDLE(ring->qid))
				break;
			DELAY(10);
		}
		wpi_nic_unlock(sc);
	}
d3111 1
a3111 1
	int qid, ntries, error;
d3179 5
a3183 5
	for (qid = 0; qid < 6; qid++) {
		WPI_WRITE(sc, WPI_FH_CBBC_CTRL(qid), 0);
		WPI_WRITE(sc, WPI_FH_CBBC_BASE(qid), 0);
		/* Enable TX for this ring. */
		WPI_WRITE(sc, WPI_FH_TX_CONFIG(qid), 0x80200008);
d3218 2
a3219 1
	int qid;
a3230 1
	/* Stop TX scheduler. */
d3232 1
d3234 12
d3249 4
a3252 1
	/* Stop all TX rings. */
a3254 3

	/* Stop RX ring. */
	wpi_reset_rx_ring(sc, &sc->rxq);
@


1.85
log
@in ca_attach() there is no need to set .value and .flags of sensors to 0,
since autoconf(9) allocates softc with M_ZERO;  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.84 2009/03/29 21:53:52 sthen Exp $	*/
d85 1
a85 1
		    void **, bus_size_t, bus_size_t, int);
a90 4
struct		wpi_rbuf *wpi_alloc_rbuf(struct wpi_softc *);
void		wpi_free_rbuf(caddr_t, u_int, void *);
int		wpi_alloc_rpool(struct wpi_softc *);
void		wpi_free_rpool(struct wpi_softc *);
a258 6
	/* Allocate RX buffers. */
	if ((error = wpi_alloc_rpool(sc)) != 0) {
		printf(": could not allocate RX buffers\n");
		goto fail2;
	}

d263 1
a263 1
			goto fail3;
d270 1
a270 1
		goto fail3;
d340 1
a340 1
fail3:	while (--i >= 0)
d342 1
a342 2
	wpi_free_rpool(sc);
fail2:	wpi_free_shared(sc);
d528 1
a528 1
    bus_size_t size, bus_size_t alignment, int flags)
d535 2
a536 1
	error = bus_dmamap_create(tag, size, 1, size, 0, flags, &dma->map);
d541 1
a541 1
	    flags);
d545 2
a546 1
	error = bus_dmamem_map(tag, &dma->seg, 1, size, &dma->vaddr, flags);
d550 2
a551 1
	error = bus_dmamap_load_raw(tag, dma->map, &dma->seg, 1, size, flags);
a554 1
	memset(dma->vaddr, 0, size);
d589 1
a589 2
	    (void **)&sc->shared, sizeof (struct wpi_shared), 4096,
	    BUS_DMA_NOWAIT);
d603 1
a603 1
	    WPI_FW_TEXT_MAXSZ + WPI_FW_DATA_MAXSZ, 16, BUS_DMA_NOWAIT);
a611 61
struct wpi_rbuf *
wpi_alloc_rbuf(struct wpi_softc *sc)
{
	struct wpi_rbuf *rbuf;

	rbuf = SLIST_FIRST(&sc->rxq.freelist);
	if (rbuf == NULL)
		return NULL;
	SLIST_REMOVE_HEAD(&sc->rxq.freelist, next);
	return rbuf;
}

/*
 * This is called automatically by the network stack when the mbuf to which
 * our RX buffer is attached is freed.
 */
void
wpi_free_rbuf(caddr_t buf, u_int size, void *arg)
{
	struct wpi_rbuf *rbuf = arg;
	struct wpi_softc *sc = rbuf->sc;

	/* Put the RX buffer back in the free list. */
	SLIST_INSERT_HEAD(&sc->rxq.freelist, rbuf, next);
}

int
wpi_alloc_rpool(struct wpi_softc *sc)
{
	struct wpi_rx_ring *ring = &sc->rxq;
	int i, error;

	/* Allocate a big chunk of DMA'able memory... */
	error = wpi_dma_contig_alloc(sc->sc_dmat, &ring->buf_dma, NULL,
	    WPI_RBUF_COUNT * WPI_RBUF_SIZE, 4096, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not allocate Rx buffers DMA memory\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

	/* ...and split it into chunks of WPI_RBUF_SIZE bytes. */
	SLIST_INIT(&ring->freelist);
	for (i = 0; i < WPI_RBUF_COUNT; i++) {
		struct wpi_rbuf *rbuf = &ring->rbuf[i];

		rbuf->sc = sc;	/* Backpointer for callbacks. */
		rbuf->vaddr = ring->buf_dma.vaddr + i * WPI_RBUF_SIZE;
		rbuf->paddr = ring->buf_dma.paddr + i * WPI_RBUF_SIZE;

		SLIST_INSERT_HEAD(&ring->freelist, rbuf, next);
	}
	return 0;
}

void
wpi_free_rpool(struct wpi_softc *sc)
{
	wpi_dma_contig_free(&sc->rxq.buf_dma);
}

d623 1
a623 1
	    (void **)&ring->desc, size, 16 * 1024, BUS_DMA_NOWAIT);
d631 1
a631 1
	 * Allocate RX buffers.
d635 8
a642 1
		struct wpi_rbuf *rbuf;
d648 1
a648 1
			error = ENOMEM;
d651 3
a653 4
		if ((rbuf = wpi_alloc_rbuf(sc)) == NULL) {
			m_freem(data->m);
			data->m = NULL;
			printf("%s: could not allocate RX buffer\n",
d655 10
a664 1
			error = ENOMEM;
a666 3
		/* Attach RX buffer to mbuf header. */
		MEXTADD(data->m, rbuf->vaddr, WPI_RBUF_SIZE, 0, wpi_free_rbuf,
		    rbuf);
d669 1
a669 1
		ring->desc[i] = htole32(rbuf->paddr);
d671 4
d707 10
a716 2
		if (ring->data[i].m != NULL)
			m_freem(ring->data[i].m);
d734 1
a734 1
	    (void **)&ring->desc, size, 16 * 1024, BUS_DMA_NOWAIT);
d756 1
a756 1
	    (void **)&ring->cmd, size, 4, BUS_DMA_NOWAIT);
a1171 1
	struct wpi_rbuf *rbuf;
d1177 1
d1179 2
a1181 3
	bus_dmamap_sync(sc->sc_dmat, ring->buf_dma.map,
	    (caddr_t)stat - ring->buf_dma.vaddr, WPI_RBUF_SIZE,
	    BUS_DMASYNC_POSTREAD);
d1200 1
a1200 1
	if (letoh16(head->len) < sizeof (struct ieee80211_frame)) {
d1207 37
d1245 6
a1284 27
	if ((rbuf = SLIST_FIRST(&sc->rxq.freelist)) != NULL) {
		MGETHDR(m1, M_DONTWAIT, MT_DATA);
		if (m1 == NULL) {
			ic->ic_stats.is_rx_nombuf++;
			ifp->if_ierrors++;
			return;
		}
		/* Attach RX buffer to mbuf header. */
		MEXTADD(m1, rbuf->vaddr, WPI_RBUF_SIZE, 0, wpi_free_rbuf,
		    rbuf);
		SLIST_REMOVE_HEAD(&sc->rxq.freelist, next);

		data->m = m1;

		/* Update RX descriptor. */
		ring->desc[ring->cur] = htole32(rbuf->paddr);
	} else {
		/* No free rbufs, copy frame into an mbuf. */
		m = m_copym2(m, 0, M_COPYALL, M_DONTWAIT);
		if (m == NULL) {
			/* No free mbufs either, drop frame. */
			ic->ic_stats.is_rx_nombuf++;
			ifp->if_ierrors++;
			return;
		}
	}

d1413 1
a1413 1
		struct wpi_rx_desc *desc = (void *)data->m->m_ext.ext_buf;
d1415 1
a1415 2
		bus_dmamap_sync(sc->sc_dmat, sc->rxq.buf_dma.map,
		    (caddr_t)desc - sc->rxq.buf_dma.vaddr, sizeof (*desc),
d1417 1
d1443 1
a1443 2
			bus_dmamap_sync(sc->sc_dmat, sc->rxq.buf_dma.map,
			    (caddr_t)uc - sc->rxq.buf_dma.vaddr,
d1464 1
a1464 2
			bus_dmamap_sync(sc->sc_dmat, sc->rxq.buf_dma.map,
			    (caddr_t)status - sc->rxq.buf_dma.vaddr,
d1484 1
a1484 2
			bus_dmamap_sync(sc->sc_dmat, sc->rxq.buf_dma.map,
			    (caddr_t)scan - sc->rxq.buf_dma.vaddr,
d1498 1
a1498 2
			bus_dmamap_sync(sc->sc_dmat, sc->rxq.buf_dma.map,
			    (caddr_t)scan - sc->rxq.buf_dma.vaddr,
@


1.84
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.83 2009/02/05 17:10:49 damien Exp $	*/
a369 1
	sc->sensor.value = 0;
@


1.83
log
@fix uninitialized var (in a code path that is not used yet).

found by chl@@ using llvm/clang
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.82 2009/01/26 19:18:52 damien Exp $	*/
d218 1
a218 1
		printf(": could not map memory space\n");
d224 1
a224 1
		printf(": could not map interrupt\n");
d231 1
a231 1
		printf(": could not establish interrupt");
d1861 1
a1861 1
		printf("%s: could not map mbuf (error %d)\n",
d1889 1
a1889 1
			printf("%s: could not map mbuf (error %d)\n",
@


1.82
log
@I changed the IEEE80211_QOS_ACK_POLICY_* definitions to be more in line
with other net80211 flags (we no longer need to shift.)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.81 2009/01/03 10:11:55 damien Exp $	*/
d2450 1
@


1.81
log
@remove check for rfkill switch state using GP_CNTRL as it does not
seem to work properly.
it is checked later in wpi_post_alive() anyway.

pointed out by many, further investigated by Tim van der Molen.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.80 2008/12/22 18:20:47 damien Exp $	*/
d1782 1
a1782 2
		if (!hasqos || (qos & IEEE80211_QOS_ACK_POLICY_MASK) >>
		    IEEE80211_QOS_ACK_POLICY_SHIFT !=
@


1.80
log
@I swapped MGETHDR arguments in my m_defrag removal commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.79 2008/12/21 18:19:58 damien Exp $	*/
d3308 1
d3316 1
a3316 1

@


1.79
log
@Undo m_defrag().

m_defrag() does not work.  It seems to assume that if the length of
the mbuf passed as parameter is less than MHLEN, then it is an mbuf
header and not a cluster (or something like that.)
It thus fails miserably in the bcopy path.
I don't have the time to investigate further into this.

Thanks to Okan Demirmen for reporting the issue on a ral(4) RT2560.
The RT2560 chipset does not support TX scatter and thus m_defrag()
was called much more often than in other drivers using m_defrag()
where it was less noticeable.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.78 2008/12/03 17:17:08 damien Exp $	*/
d1869 1
a1869 1
		MGETHDR(m1, MT_DATA, M_DONTWAIT);
@


1.78
log
@allow users to select a fixed rate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.77 2008/12/03 14:47:17 cnst Exp $	*/
d1690 1
d1869 2
a1870 1
		if (m_defrag(m, M_DONTWAIT) != 0) {
d1872 9
a1880 1
			return ENOMEM;
d1882 5
@


1.77
log
@don't overwrite an error code from wpi_init() in wpi_ioctl(), logic is
now in line with iwn_ioctl();  'dead assignment' llvm/clang;  ok damien
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.76 2008/11/25 22:20:11 damien Exp $	*/
d1043 3
d1052 10
d1715 1
a1715 1
	/* Chose a TX rate index. */
d1720 2
@


1.76
log
@more sizeof->nitems
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.75 2008/11/25 21:43:57 damien Exp $	*/
d2042 1
a2047 1
		error = 0;
@


1.75
log
@use shiny new m_defrag() and nitems() instead of rolling our own.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.74 2008/11/25 17:06:26 damien Exp $	*/
d179 1
a179 1
	    sizeof wpi_devices / sizeof wpi_devices[0]);
@


1.74
log
@add a shitload of bus_dmamap_sync() calls, even though they are no-ops
on i386 and amd64 (we do not implement bounce buffers) where this hardware
is likely to be found.  this is good programming practice.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.73 2008/11/22 08:23:52 brad Exp $	*/
a1677 1
	struct mbuf *m1;
d1853 1
a1853 2
		MGETHDR(m1, M_DONTWAIT, MT_DATA);
		if (m1 == NULL) {
a1856 13
		if (m->m_pkthdr.len > MHLEN) {
			MCLGET(m1, M_DONTWAIT);
			if (!(m1->m_flags & M_EXT)) {
				m_freem(m);
				m_freem(m1);
				return ENOMEM;
			}
		}
		m_copydata(m, 0, m->m_pkthdr.len, mtod(m1, caddr_t));
		m1->m_len = m1->m_pkthdr.len = m->m_pkthdr.len;
		m_freem(m);
		m = m1;

@


1.73
log
@- Slight wording tweak.. leave -> let.
- Sync wpi(4)'s set_key comment with the comment from iwn(4).

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.72 2008/11/16 09:52:31 damien Exp $	*/
d565 1
d582 2
d791 2
d854 2
d880 2
d1215 3
d1380 2
d1411 2
d1427 3
d1435 4
d1463 3
d1485 3
d1506 3
d1521 3
d1904 9
d2125 12
d2929 2
d2933 2
d2965 2
d2969 2
@


1.72
log
@clear pending interrupts in the driver attach routine.
otherwise the chip comes up with the RF_TOGGLED bit set which triggers
an if_stop() call if a shared interrupt occurs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.71 2008/11/09 10:00:17 damien Exp $	*/
d2731 4
a2743 5
	/*
	 * We support CCMP hardware encryption/decryption of unicast frames
	 * only.  Hardware support for TKIP really sucks and it is not worth
	 * implementing.  We should leave TKIP die anyway.
	 */
@


1.71
log
@rework the rate coding code to get rid of the ugly {wpi,iwn}_plcp_signal()
function.  will be required for future MCS support in iwn.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.69 2008/11/08 18:42:49 damien Exp $	*/
d285 2
d1045 1
a1045 1
	return 0;
d3084 1
a3084 1
	/* Clear any pending interrupts. */
d3163 1
a3163 1
	/* Clear any pending interrupts. */
@


1.70
log
@uninitialized value, caused by a typo.

Found by LLVM/Clang Static Analyzer.

ok damien@@
@
text
@a120 1
uint8_t		wpi_plcp_signal(int);
d1010 17
a1026 9
	int i;

	ieee80211_amrr_node_init(&sc->amrr, &((struct wpi_node *)ni)->amn);

	/* Set rate to some reasonable initial value. */
	for (i = ni->ni_rates.rs_nrates - 1;
	     i > 0 && (ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL) > 72;
	     i--);
	ni->ni_txrate = i;
a1626 29
uint8_t
wpi_plcp_signal(int rate)
{
	switch (rate) {
	/* CCK rates (returned values are device-dependent) */
	case 2:		return 10;
	case 4:		return 20;
	case 11:	return 55;
	case 22:	return 110;

	/* OFDM rates (cf IEEE Std 802.11a-1999, pp. 14 Table 80) */
	/* R1-R4, (u)ral is R4-R1 */
	case 12:	return 0xd;
	case 18:	return 0xf;
	case 24:	return 0x5;
	case 36:	return 0x7;
	case 48:	return 0x9;
	case 72:	return 0xb;
	case 96:	return 0x1;
	case 108:	return 0x3;

	/* Unsupported rates (should not get there.) */
	default:	return 0;
	}
}

/* Determine if a given rate is CCK or OFDM. */
#define WPI_RATE_IS_OFDM(rate) ((rate) >= 12 && (rate) != 22)

d1631 1
d1637 1
a1643 1
	uint8_t *ivp, tid, type;
d1645 2
a1646 1
	int i, totlen, hasqos, rate, error;
d1666 1
a1666 1
	/* Chose a TX rate. */
d1669 2
a1670 4
		rate = ni->ni_rates.rs_rates[0];
	} else if (ic->ic_fixed_rate != -1) {
		rate = ic->ic_sup_rates[ic->ic_curmode].
		    rs_rates[ic->ic_fixed_rate];
d1672 2
a1673 2
		rate = ni->ni_rates.rs_rates[ni->ni_txrate];
	rate &= IEEE80211_RATE_VAL;
d1683 1
a1683 1
		tap->wt_rate = rate;
d1742 1
a1742 1
		    WPI_RATE_IS_OFDM(rate)) {
d1754 1
a1754 1
		tx->id = ((struct wpi_node *)ni)->id;
d1779 1
a1779 1
	tx->rate = wpi_plcp_signal(rate);
d2097 1
a2097 1
	for (i = WPI_CCK1; i <= WPI_CCK11; i++) {
d2099 1
a2099 1
		mrr.rates[i].plcp = wpi_ridx_to_plcp[i];
d2101 2
a2102 1
		mrr.rates[i].next = (i == WPI_CCK1) ? WPI_CCK1 : i - 1;
d2107 1
a2107 1
	for (i = WPI_OFDM6; i <= WPI_OFDM54; i++) {
d2109 1
a2109 1
		mrr.rates[i].plcp = wpi_ridx_to_plcp[i];
d2112 1
a2112 1
		mrr.rates[i].next = (i == WPI_OFDM6) ?
d2114 1
a2114 1
			WPI_OFDM6 : WPI_CCK2) :
d2248 1
a2248 1
	for (i = 0; i <= 11 ; i++) {
d2250 1
a2250 1
		idx = wpi_get_power_index(sc, group, ch, wpi_ridx_to_rate[i]);
d2252 1
a2252 1
		cmd.rates[i].plcp = wpi_ridx_to_plcp[i];
d2262 1
a2262 1
		    wpi_ridx_to_rate[i], idx));
d2274 1
a2274 1
    struct ieee80211_channel *c, int rate)
d2296 2
a2297 2
	switch (rate) {
	case 72:	/* OFDM36 */
d2300 1
a2300 1
	case 96:	/* OFDM48 */
d2303 1
a2303 1
	case 108:	/* OFDM54 */
d2327 1
a2327 1
	if (!WPI_RATE_IS_OFDM(rate))
d2462 1
a2462 1
	node.rate = wpi_ridx_to_plcp[WPI_CCK1];
d2515 1
a2515 1
		tx->rate = wpi_ridx_to_plcp[WPI_OFDM6];
d2520 1
a2520 1
		tx->rate = wpi_ridx_to_plcp[WPI_CCK1];
d2641 2
a2642 2
	node.rate = (ic->ic_curmode == IEEE80211_MODE_11A) ?
	    wpi_ridx_to_plcp[WPI_OFDM6] : wpi_ridx_to_plcp[WPI_CCK1];
d2696 4
a2700 1
	((struct wpi_node *)ni)->id = WPI_ID_BSS;
d2704 2
a2705 2
	node.rate = (ic->ic_curmode == IEEE80211_MODE_11A) ?
	    wpi_ridx_to_plcp[WPI_OFDM6] : wpi_ridx_to_plcp[WPI_CCK1];
a2713 3

	/* Fake a join to init the TX rate. */
	wpi_newassoc(ic, ni, 1);
@


1.69
log
@when defragmenting an mbuf chain, do not call M_DUP_PKTHDR.
this is an overkill in this case as it duplicates mbuf tags etc...

following a discussion with kettenis@@ a few months ago about gem(4)
did some cleanup while i was there.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.68 2008/11/08 14:09:03 damien Exp $	*/
d1078 1
a1078 1
		if ((error == wpi_run(sc)) != 0) {
@


1.68
log
@initialize k to NULL in wpi_tx_data()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.67 2008/11/08 12:21:36 damien Exp $	*/
d122 1
a122 1
int		wpi_tx_data(struct wpi_softc *, struct mbuf *,
d1131 1
a1131 1
wpi_ccmp_decap(struct wpi_softc *sc, struct mbuf *m0, struct ieee80211_key *k)
d1139 1
a1139 1
	wh = mtod(m0, struct ieee80211_frame *);
d1172 2
a1173 2
	ovbcopy(wh, mtod(m0, caddr_t) + IEEE80211_CCMP_HDRLEN, hdrlen);
	m_adj(m0, IEEE80211_CCMP_HDRLEN);
d1175 1
a1175 1
	m_adj(m0, -IEEE80211_CCMP_MICLEN);
d1193 1
a1193 1
	struct mbuf *m, *mnew;
d1258 2
a1259 2
		MGETHDR(mnew, M_DONTWAIT, MT_DATA);
		if (mnew == NULL) {
d1265 1
a1265 1
		MEXTADD(mnew, rbuf->vaddr, WPI_RBUF_SIZE, 0, wpi_free_rbuf,
d1269 1
a1269 1
		data->m = mnew;
d1650 1
a1650 1
wpi_tx_data(struct wpi_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
d1661 1
a1661 1
	struct mbuf *mnew;
d1668 1
a1668 1
	wh = mtod(m0, struct ieee80211_frame *);
d1713 1
a1713 1
		mb.m_next = m0;
d1721 1
a1721 1
	totlen = m0->m_pkthdr.len;
d1729 1
a1729 1
			if ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)
d1732 2
a1733 2
			wh = mtod(m0, struct ieee80211_frame *);
			totlen = m0->m_pkthdr.len;
d1808 2
a1809 2
		m_adj(m0, hdrlen - IEEE80211_CCMP_HDRLEN);
		ivp = mtod(m0, uint8_t *);
d1824 1
a1824 1
		m_adj(m0, hdrlen);
d1829 1
a1829 1
	error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
d1834 1
a1834 1
		m_freem(m0);
d1839 3
a1841 4

		MGETHDR(mnew, M_DONTWAIT, MT_DATA);
		if (mnew == NULL) {
			m_freem(m0);
d1844 5
a1848 6
		M_DUP_PKTHDR(mnew, m0);
		if (m0->m_pkthdr.len > MHLEN) {
			MCLGET(mnew, M_DONTWAIT);
			if (!(mnew->m_flags & M_EXT)) {
				m_freem(m0);
				m_freem(mnew);
d1852 4
a1855 4
		m_copydata(m0, 0, m0->m_pkthdr.len, mtod(mnew, caddr_t));
		m_freem(m0);
		mnew->m_len = mnew->m_pkthdr.len;
		m0 = mnew;
d1857 1
a1857 1
		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
d1862 1
a1862 1
			m_freem(m0);
d1867 1
a1867 1
	data->m = m0;
d1871 1
a1871 1
	    ring->qid, ring->cur, m0->m_pkthdr.len, data->map->dm_nsegs));
d1874 1
a1874 1
	desc->flags = htole32(WPI_PAD32(m0->m_pkthdr.len) << 28 |
d1940 1
a1940 1
		if (wpi_tx_data(sc, m, ni) != 0) {
@


1.67
log
@do not allocate cmd memory for rings 5 and 6 (HCCA) which are unused.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.66 2008/11/08 11:02:09 damien Exp $	*/
d1659 1
a1659 1
	struct ieee80211_key *k;
@


1.66
log
@major wpi(4) overhaul.
wpi(4) and iwn(4) used to be in sync but with the latest iwn(4)
changes, this was no longer the case.  that commit repair this.
it brings HW CCMP encryption/decryption among other things.

requires an update of the wpi-firmware package.
please report any regression you might see.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.64 2008/08/27 09:05:03 damien Exp $	*/
d787 8
@


1.65
log
@major wpi(4) overhaul.
wpi(4) and iwn(4) used to be in sync but with the latest iwn(4)
changes, this was no longer the case.  that commit repair this.
it brings HW CCMP encryption/decryption among other things.

requires an update of the wpi-firmware package.
please report any regression you might see.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.61 2008/06/16 18:43:06 damien Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006, 2007
d78 1
d80 1
d82 2
d102 3
d110 1
a110 9
void		wpi_mem_lock(struct wpi_softc *);
void		wpi_mem_unlock(struct wpi_softc *);
uint32_t	wpi_mem_read(struct wpi_softc *, uint16_t);
void		wpi_mem_write(struct wpi_softc *, uint16_t, uint32_t);
void		wpi_mem_write_region_4(struct wpi_softc *, uint16_t,
		    const uint32_t *, int);
int		wpi_read_prom_data(struct wpi_softc *, uint32_t, void *, int);
int		wpi_load_microcode(struct wpi_softc *, const uint8_t *, int);
int		wpi_load_firmware(struct wpi_softc *);
d112 3
a114 3
void		wpi_iter_func(void *, struct ieee80211_node *);
void		wpi_power_calibration(struct wpi_softc *, int);
void		wpi_rx_intr(struct wpi_softc *, struct wpi_rx_desc *,
d116 2
a117 2
void		wpi_tx_intr(struct wpi_softc *, struct wpi_rx_desc *);
void		wpi_cmd_intr(struct wpi_softc *, struct wpi_rx_desc *);
d119 1
a120 3
void		wpi_read_eeprom(struct wpi_softc *);
void		wpi_read_eeprom_channels(struct wpi_softc *, int);
void		wpi_read_eeprom_group(struct wpi_softc *, int);
d123 1
a123 1
		    struct ieee80211_node *, int);
a128 2
int		wpi_set_key(struct ieee80211com *, struct ieee80211_node *,
		    struct ieee80211_key *);
d131 3
a133 3
void		wpi_enable_tsf(struct wpi_softc *, struct ieee80211_node *);
int		wpi_set_txpower(struct wpi_softc *,
		    struct ieee80211_channel *, int);
d136 3
d140 16
a155 6
int		wpi_scan(struct wpi_softc *, uint16_t);
int		wpi_config(struct wpi_softc *);
void		wpi_stop_master(struct wpi_softc *);
int		wpi_power_up(struct wpi_softc *);
int		wpi_reset(struct wpi_softc *);
void		wpi_hw_config(struct wpi_softc *);
d162 1
a162 1
int wpi_debug = 1;
d168 4
d180 1
a180 1
	    sizeof (wpi_devices) / sizeof (wpi_devices[0]));
a182 3
/* Base Address Register */
#define WPI_PCI_BAR0	0x10

a190 2
	bus_space_tag_t memt;
	bus_space_handle_t memh;
d192 1
a192 1
	pcireg_t data;
d197 12
d210 8
a217 8
	/* clear device specific PCI configuration register 0x41 */
	data = pci_conf_read(sc->sc_pct, sc->sc_pcitag, 0x40);
	data &= ~0x0000ff00;
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0x40, data);

	/* map the register window */
	error = pci_mapreg_map(pa, WPI_PCI_BAR0, PCI_MAPREG_TYPE_MEM |
	    PCI_MAPREG_MEM_TYPE_32BIT, 0, &memt, &memh, NULL, &sc->sc_sz, 0);
d223 1
a223 4
	sc->sc_st = memt;
	sc->sc_sh = memh;
	sc->sc_dmat = pa->pa_dmat;

a227 1

d240 9
a248 5
	/*
	 * Put adapter into a known state.
	 */
	if ((error = wpi_reset(sc)) != 0) {
		printf(": could not reset adapter\n");
d252 1
a252 3
	/*
	 * Allocate DMA memory for firmware transfers.
	 */
d254 1
a254 1
		printf(": could not allocate firmware memory\n");
d258 1
a258 3
	/*
	 * Allocate shared page and Tx/Rx rings.
	 */
d264 1
d266 1
a266 1
		printf(": could not allocate Rx buffers\n");
d270 1
d273 1
a273 1
			printf(": could not allocate Tx ring %d\n", i);
d278 1
d284 3
d291 1
a291 1
	/* set device capabilities */
d293 1
a293 1
	    IEEE80211_C_WEP |		/* s/w WEP */
a295 1
	    IEEE80211_C_TXPMGT |	/* tx power management */
d297 2
a298 1
	    IEEE80211_C_SHPREAMBLE;	/* short preamble supported */
d300 1
a300 5
	/* read supported channels and MAC address from EEPROM */
	wpi_read_eeprom(sc);

	/* set supported .11a, .11b and .11g rates */
	ic->ic_sup_rates[IEEE80211_MODE_11A] = ieee80211_std_rateset_11a;
d303 4
d308 1
a308 1
	/* IBSS channel undefined for now */
d324 1
a324 1
#ifdef notyet
d326 1
a326 2
#endif
	ic->ic_updateedca = wpi_updateedca;
d328 1
a328 1
	/* override state transition machine */
d339 1
d341 1
a341 1

d348 1
a348 1
	/* free allocated memory if something failed during attachment */
d368 1
a368 1
	/* temperature invalid until interface is up */
d376 1
a382 1
#if NBPFILTER > 0
d393 1
a394 1
}
d401 1
a401 1
	pcireg_t data;
d407 4
a410 4
	/* clear device specific PCI configuration register 0x41 */
	data = pci_conf_read(sc->sc_pct, sc->sc_pcitag, 0x40);
	data &= ~0x0000ff00;
	pci_conf_write(sc->sc_pct, sc->sc_pcitag, 0x40, data);
d423 115
a589 3
/*
 * Allocate a shared page between host and NIC.
 */
d593 1
a593 1
	/* must be aligned on a 4K-page boundary */
d595 1
a595 1
	    (void **)&sc->shared, sizeof (struct wpi_shared), PAGE_SIZE,
a604 3
/*
 * Allocate DMA-safe memory for firmware transfer.
 */
d608 1
a608 1
	/* allocate enough contiguous space to store text and data */
d610 1
a610 2
	    WPI_FW_MAIN_TEXT_MAXSZ + WPI_FW_MAIN_DATA_MAXSZ, 0,
	    BUS_DMA_NOWAIT);
d632 2
a633 2
 * This is called automatically by the network stack when the mbuf to which our
 * Rx buffer is attached is freed.
d641 1
a641 1
	/* put the buffer back in the free list */
d651 1
a651 1
	/* allocate a big chunk of DMA'able memory.. */
d653 1
a653 1
	    WPI_RBUF_COUNT * WPI_RBUF_SIZE, PAGE_SIZE, BUS_DMA_NOWAIT);
d660 1
a660 1
	/* ..and split it into 3KB chunks */
d665 1
a665 1
		rbuf->sc = sc;	/* backpointer for callbacks */
d683 1
d688 2
d691 1
a691 2
	    (void **)&ring->desc, WPI_RX_RING_COUNT * sizeof (uint32_t),
	    WPI_RING_DMA_ALIGN, BUS_DMA_NOWAIT);
d693 1
a693 1
		printf("%s: could not allocate rx ring DMA memory\n",
d699 1
a699 1
	 * Setup Rx buffers.
d707 1
a707 1
			printf("%s: could not allocate rx mbuf\n",
d715 1
a715 1
			printf("%s: could not allocate rx buffer\n",
d720 1
a720 1
		/* attach Rx buffer to mbuf */
d724 1
a726 1

d738 9
a746 7
	wpi_mem_lock(sc);

	WPI_WRITE(sc, WPI_RX_CONFIG, 0);
	for (ntries = 0; ntries < 100; ntries++) {
		if (WPI_READ(sc, WPI_RX_STATUS) & WPI_RX_IDLE)
			break;
		DELAY(10);
a747 6
#ifdef WPI_DEBUG
	if (ntries == 100 && wpi_debug > 0)
		printf("%s: timeout resetting Rx ring\n", sc->sc_dev.dv_xname);
#endif
	wpi_mem_unlock(sc);

d767 1
d775 1
d778 1
a778 1
	    (void **)&ring->desc, size, WPI_RING_DMA_ALIGN, BUS_DMA_NOWAIT);
d780 1
a780 1
		printf("%s: could not allocate tx ring DMA memory\n",
d785 1
a785 1
	/* update shared page with ring's base address */
d792 1
a792 1
		printf("%s: could not allocate tx cmd DMA memory\n",
d797 1
d801 3
d808 1
a808 1
			printf("%s: could not create tx buf DMA map\n",
a812 1

d825 10
a834 13
	wpi_mem_lock(sc);

	WPI_WRITE(sc, WPI_TX_CONFIG(ring->qid), 0);
	for (ntries = 0; ntries < 100; ntries++) {
		tmp = WPI_READ(sc, WPI_TX_STATUS);
		if ((tmp & WPI_TX_IDLE(ring->qid)) == WPI_TX_IDLE(ring->qid))
			break;
		DELAY(10);
	}
#ifdef WPI_DEBUG
	if (ntries == 100 && wpi_debug > 0) {
		printf("%s: timeout resetting Tx ring %d\n",
		    sc->sc_dev.dv_xname, ring->qid);
a835 3
#endif
	wpi_mem_unlock(sc);

d845 3
a847 1

d867 123
d1007 1
a1007 1
	/* set rate to some reasonable initial value */
d1026 1
a1026 1
		wpi_init(ifp);
a1035 1
	struct ieee80211_node *ni;
d1042 1
a1042 1
		/* make the link LED blink while we're scanning */
d1045 1
a1045 1
		if ((error = wpi_scan(sc, IEEE80211_CHAN_G)) != 0) {
d1058 3
a1060 3
		/* reset state to handle reassociations correctly */
		sc->config.associd = 0;
		sc->config.filter &= ~htole32(WPI_FILTER_BSS);
d1063 1
a1063 1
			printf("%s: could not send authentication request\n",
d1070 2
a1071 33
		if (ic->ic_opmode == IEEE80211_M_MONITOR) {
			/* link LED blinks while monitoring */
			wpi_set_led(sc, WPI_LED_LINK, 5, 5);
			break;
		}
		ni = ic->ic_bss;

		wpi_enable_tsf(sc, ni);

		/* update adapter's configuration */
		sc->config.associd = htole16(ni->ni_associd & ~0xc000);
		/* short preamble/slot time are negotiated when associating */
		sc->config.flags &= ~htole32(WPI_CONFIG_SHPREAMBLE |
		    WPI_CONFIG_SHSLOT);
		if (ic->ic_flags & IEEE80211_F_SHSLOT)
			sc->config.flags |= htole32(WPI_CONFIG_SHSLOT);
		if (ic->ic_flags & IEEE80211_F_SHPREAMBLE)
			sc->config.flags |= htole32(WPI_CONFIG_SHPREAMBLE);
		sc->config.filter |= htole32(WPI_FILTER_BSS);

		DPRINTF(("config chan %d flags %x\n", sc->config.chan,
		    sc->config.flags));
		error = wpi_cmd(sc, WPI_CMD_CONFIGURE, &sc->config,
		    sizeof (struct wpi_config), 1);
		if (error != 0) {
			printf("%s: could not update configuration\n",
			    sc->sc_dev.dv_xname);
			return error;
		}

		/* configuration has changed, set Tx power accordingly */
		if ((error = wpi_set_txpower(sc, ni->ni_chan, 1)) != 0) {
			printf("%s: could not set Tx power\n",
a1074 12

		if (ic->ic_opmode == IEEE80211_M_STA) {
			/* fake a join to init the tx rate */
			wpi_newassoc(ic, ni, 1);
		}

		/* start periodic calibration timer */
		sc->calib_cnt = 0;
		timeout_add(&sc->calib_to, hz / 2);

		/* link LED always on while associated */
		wpi_set_led(sc, WPI_LED_LINK, 0, 1);
a1083 3
/*
 * Grab exclusive access to NIC memory.
 */
d1085 1
a1085 1
wpi_mem_lock(struct wpi_softc *sc)
d1087 2
a1088 2
	uint32_t tmp;
	int ntries;
d1090 1
a1090 239
	tmp = WPI_READ(sc, WPI_GPIO_CTL);
	WPI_WRITE(sc, WPI_GPIO_CTL, tmp | WPI_GPIO_MAC);

	/* spin until we actually get the lock */
	for (ntries = 0; ntries < 1000; ntries++) {
		if ((WPI_READ(sc, WPI_GPIO_CTL) &
		    (WPI_GPIO_CLOCK | WPI_GPIO_SLEEP)) == WPI_GPIO_CLOCK)
			break;
		DELAY(10);
	}
	if (ntries == 1000)
		printf("%s: could not lock memory\n", sc->sc_dev.dv_xname);
}

/*
 * Release lock on NIC memory.
 */
void
wpi_mem_unlock(struct wpi_softc *sc)
{
	uint32_t tmp = WPI_READ(sc, WPI_GPIO_CTL);
	WPI_WRITE(sc, WPI_GPIO_CTL, tmp & ~WPI_GPIO_MAC);
}

uint32_t
wpi_mem_read(struct wpi_softc *sc, uint16_t addr)
{
	WPI_WRITE(sc, WPI_READ_MEM_ADDR, WPI_MEM_4 | addr);
	return WPI_READ(sc, WPI_READ_MEM_DATA);
}

void
wpi_mem_write(struct wpi_softc *sc, uint16_t addr, uint32_t data)
{
	WPI_WRITE(sc, WPI_WRITE_MEM_ADDR, WPI_MEM_4 | addr);
	WPI_WRITE(sc, WPI_WRITE_MEM_DATA, data);
}

void
wpi_mem_write_region_4(struct wpi_softc *sc, uint16_t addr,
    const uint32_t *data, int wlen)
{
	for (; wlen > 0; wlen--, data++, addr += 4)
		wpi_mem_write(sc, addr, *data);
}

/*
 * Read `len' bytes from the EEPROM.  We access the EEPROM through the MAC
 * instead of using the traditional bit-bang method.
 */
int
wpi_read_prom_data(struct wpi_softc *sc, uint32_t addr, void *data, int len)
{
	uint8_t *out = data;
	uint32_t val;
	int ntries;

	wpi_mem_lock(sc);
	for (; len > 0; len -= 2, addr++) {
		WPI_WRITE(sc, WPI_EEPROM_CTL, addr << 2);

		for (ntries = 0; ntries < 10; ntries++) {
			if ((val = WPI_READ(sc, WPI_EEPROM_CTL)) &
			    WPI_EEPROM_READY)
				break;
			DELAY(5);
		}
		if (ntries == 10) {
			printf("%s: could not read EEPROM\n",
			    sc->sc_dev.dv_xname);
			return ETIMEDOUT;
		}
		*out++ = val >> 16;
		if (len > 1)
			*out++ = val >> 24;
	}
	wpi_mem_unlock(sc);

	return 0;
}

/*
 * The firmware boot code is small and is intended to be copied directly into
 * the NIC internal memory.
 */
int
wpi_load_microcode(struct wpi_softc *sc, const uint8_t *ucode, int size)
{
	int ntries;

	size /= sizeof (uint32_t);

	wpi_mem_lock(sc);

	/* copy microcode image into NIC memory */
	wpi_mem_write_region_4(sc, WPI_MEM_UCODE_BASE,
	    (const uint32_t *)ucode, size);

	wpi_mem_write(sc, WPI_MEM_UCODE_SRC, 0);
	wpi_mem_write(sc, WPI_MEM_UCODE_DST, WPI_FW_TEXT);
	wpi_mem_write(sc, WPI_MEM_UCODE_SIZE, size);

	/* run microcode */
	wpi_mem_write(sc, WPI_MEM_UCODE_CTL, WPI_UC_RUN);

	/* wait for transfer to complete */
	for (ntries = 0; ntries < 1000; ntries++) {
		if (!(wpi_mem_read(sc, WPI_MEM_UCODE_CTL) & WPI_UC_RUN))
			break;
		DELAY(10);
	}
	if (ntries == 1000) {
		wpi_mem_unlock(sc);
		printf("%s: could not load boot firmware\n",
		    sc->sc_dev.dv_xname);
		return ETIMEDOUT;
	}
	wpi_mem_write(sc, WPI_MEM_UCODE_CTL, WPI_UC_ENABLE);

	wpi_mem_unlock(sc);

	return 0;
}

int
wpi_load_firmware(struct wpi_softc *sc)
{
	struct wpi_dma_info *dma = &sc->fw_dma;
	const struct wpi_firmware_hdr *hdr;
	const uint8_t *init_text, *init_data, *main_text, *main_data;
	const uint8_t *boot_text;
	uint32_t init_textsz, init_datasz, main_textsz, main_datasz;
	uint32_t boot_textsz;
	u_char *fw;
	size_t size;
	int error;

	/* load firmware image from disk */
	if ((error = loadfirmware("wpi-3945abg", &fw, &size)) != 0) {
		printf("%s: error, %d, could not read firmware %s\n",
		    sc->sc_dev.dv_xname, error, "wpi-3945abg");
		goto fail1;
	}

	/* extract firmware header information */
	if (size < sizeof (struct wpi_firmware_hdr)) {
		printf("%s: truncated firmware header: %d bytes\n",
		    sc->sc_dev.dv_xname, size);
		error = EINVAL;
		goto fail2;
	}
	hdr = (const struct wpi_firmware_hdr *)fw;
	main_textsz = letoh32(hdr->main_textsz);
	main_datasz = letoh32(hdr->main_datasz);
	init_textsz = letoh32(hdr->init_textsz);
	init_datasz = letoh32(hdr->init_datasz);
	boot_textsz = letoh32(hdr->boot_textsz);

	/* sanity-check firmware segments sizes */
	if (main_textsz > WPI_FW_MAIN_TEXT_MAXSZ ||
	    main_datasz > WPI_FW_MAIN_DATA_MAXSZ ||
	    init_textsz > WPI_FW_INIT_TEXT_MAXSZ ||
	    init_datasz > WPI_FW_INIT_DATA_MAXSZ ||
	    boot_textsz > WPI_FW_BOOT_TEXT_MAXSZ ||
	    (boot_textsz & 3) != 0) {
		printf("%s: invalid firmware header\n", sc->sc_dev.dv_xname);
		error = EINVAL;
		goto fail2;
	}

	/* check that all firmware segments are present */
	if (size < sizeof (struct wpi_firmware_hdr) + main_textsz +
	    main_datasz + init_textsz + init_datasz + boot_textsz) {
		printf("%s: firmware file too short: %d bytes\n",
		    sc->sc_dev.dv_xname, size);
		error = EINVAL;
		goto fail2;
	}

	/* get pointers to firmware segments */
	main_text = (const uint8_t *)(hdr + 1);
	main_data = main_text + main_textsz;
	init_text = main_data + main_datasz;
	init_data = init_text + init_textsz;
	boot_text = init_data + init_datasz;

	/* copy initialization images into pre-allocated DMA-safe memory */
	memcpy(dma->vaddr, init_data, init_datasz);
	memcpy(dma->vaddr + WPI_FW_INIT_DATA_MAXSZ, init_text, init_textsz);

	/* tell adapter where to find initialization images */
	wpi_mem_lock(sc);
	wpi_mem_write(sc, WPI_MEM_DATA_BASE, dma->paddr);
	wpi_mem_write(sc, WPI_MEM_DATA_SIZE, init_datasz);
	wpi_mem_write(sc, WPI_MEM_TEXT_BASE,
	    dma->paddr + WPI_FW_INIT_DATA_MAXSZ);
	wpi_mem_write(sc, WPI_MEM_TEXT_SIZE, init_textsz);
	wpi_mem_unlock(sc);

	/* load firmware boot code */
	if ((error = wpi_load_microcode(sc, boot_text, boot_textsz)) != 0) {
		printf("%s: could not load boot firmware\n",
		    sc->sc_dev.dv_xname);
		goto fail2;
	}

	/* now press "execute" ;-) */
	WPI_WRITE(sc, WPI_RESET, 0);

	/* wait at most one second for first alive notification */
	if ((error = tsleep(sc, PCATCH, "wpiinit", hz)) != 0) {
		/* this isn't what was supposed to happen.. */
		printf("%s: timeout waiting for adapter to initialize\n",
		    sc->sc_dev.dv_xname);
		goto fail2;
	}

	/* copy runtime images into pre-allocated DMA-safe memory */
	memcpy(dma->vaddr, main_data, main_datasz);
	memcpy(dma->vaddr + WPI_FW_MAIN_DATA_MAXSZ, main_text, main_textsz);

	/* tell adapter where to find runtime images */
	wpi_mem_lock(sc);
	wpi_mem_write(sc, WPI_MEM_DATA_BASE, dma->paddr);
	wpi_mem_write(sc, WPI_MEM_DATA_SIZE, main_datasz);
	wpi_mem_write(sc, WPI_MEM_TEXT_BASE,
	    dma->paddr + WPI_FW_MAIN_DATA_MAXSZ);
	wpi_mem_write(sc, WPI_MEM_TEXT_SIZE, WPI_FW_UPDATED | main_textsz);
	wpi_mem_unlock(sc);

	/* wait at most one second for second alive notification */
	if ((error = tsleep(sc, PCATCH, "wpiinit", hz)) != 0) {
		/* this isn't what was supposed to happen.. */
		printf("%s: timeout waiting for adapter to initialize\n",
		    sc->sc_dev.dv_xname);
	}

fail2:	free(fw, M_DEVBUF);
fail1:	return error;
d1100 1
a1100 1
	/* automatic rate control triggered every 500ms */
d1109 2
a1110 3

	/* update sensor data */
	temp = (int)WPI_READ(sc, WPI_TEMPERATURE);
d1113 1
a1113 1
	/* automatic power calibration every 60s */
d1118 1
a1118 1

d1122 2
a1123 2
void
wpi_iter_func(void *arg, struct ieee80211_node *ni)
d1125 5
a1129 2
	struct wpi_softc *sc = arg;
	struct wpi_node *wn = (struct wpi_node *)ni;
d1131 3
a1133 2
	ieee80211_amrr_choose(&sc->amrr, ni, &wn->amn);
}
d1135 23
a1157 12
/*
 * This function is called periodically (every 60 seconds) to adjust output
 * power to temperature changes.
 */
void
wpi_power_calibration(struct wpi_softc *sc, int temp)
{
	/* sanity-check read value */
	if (temp < -260 || temp > 25) {
		/* this can't be correct, ignore */
		DPRINTF(("out-of-range temperature reported: %d\n", temp));
		return;
d1159 2
d1162 7
a1168 13
	DPRINTF(("temperature %d->%d\n", sc->temp, temp));

	/* adjust Tx power if need be */
	if (abs(temp - sc->temp) <= 6)
		return;

	sc->temp = temp;

	if (wpi_set_txpower(sc, sc->sc_ic.ic_bss->ni_chan, 1) != 0) {
		/* just warn, too bad for the automatic calibration... */
		printf("%s: could not adjust Tx power\n",
		    sc->sc_dev.dv_xname);
	}
d1172 1
a1172 1
wpi_rx_intr(struct wpi_softc *sc, struct wpi_rx_desc *desc,
d1186 1
d1191 1
a1191 1
		printf("%s: invalid rx statistic header\n",
a1195 1

d1198 1
d1200 10
a1209 12
	DPRINTFN(4, ("rx intr: idx=%d len=%d stat len=%d rssi=%d rate=%x "
	    "chan=%d tstamp=%llu\n", ring->cur, letoh32(desc->len),
	    letoh16(head->len), (int8_t)stat->rssi, head->rate, head->chan,
	    letoh64(tail->tstamp)));

	/*
	 * Discard Rx frames with bad CRC early (XXX we may want to pass them
	 * to radiotap in monitor mode).
	 */
	if ((letoh32(tail->flags) & WPI_RX_NOERROR) != WPI_RX_NOERROR) {
		DPRINTFN(2, ("rx tail flags error %x\n",
		    letoh32(tail->flags)));
d1215 2
a1216 1
	/* finalize mbuf */
d1221 28
d1252 1
d1256 1
a1256 2

		/* attach Rx buffer to mbuf */
d1263 1
a1263 1
		/* update Rx descriptor */
d1266 1
a1266 1
		/* no free rbufs, copy frame */
d1269 2
a1270 1
			/* no free mbufs either, drop frame */
d1282 2
d1293 1
a1293 1
		/* CCK rates */
d1298 1
a1298 1
		/* OFDM rates */
d1307 1
a1307 1
		/* unknown rate: should not happen */
a1309 2
		if (letoh16(head->flags) & 0x4)
			tap->wr_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;
d1321 1
a1321 6
	/* grab a reference to the source node */
	wh = mtod(m, struct ieee80211_frame *);
	ni = ieee80211_find_rxnode(ic, wh);

	/* send the frame to the 802.11 layer */
	rxi.rxi_flags = 0;
d1326 1
a1326 1
	/* node is no longer needed */
d1331 1
a1331 1
wpi_tx_intr(struct wpi_softc *sc, struct wpi_rx_desc *desc)
d1340 1
a1340 10
	DPRINTFN(4, ("tx done: qid=%d idx=%d retries=%d nkill=%d rate=%x "
	    "duration=%d status=%x\n", desc->qid, desc->idx, stat->ntries,
	    stat->nkill, stat->rate, letoh32(stat->duration),
	    letoh32(stat->status)));

	/*
	 * Update rate control statistics for the node.
	 * XXX we should not count mgmt frames since they're always sent at
	 * the lowest available bit-rate.
	 */
d1342 1
a1342 2
	if (stat->ntries > 0) {
		DPRINTFN(3, ("tx intr ntries %d\n", stat->ntries));
a1343 1
	}
d1350 1
a1356 2
	ring->queued--;

d1358 7
a1364 2
	ifp->if_flags &= ~IFF_OACTIVE;
	(*ifp->if_start)(ifp);
d1368 1
a1368 1
wpi_cmd_intr(struct wpi_softc *sc, struct wpi_rx_desc *desc)
d1374 1
a1374 1
		return;	/* not a command ack */
d1378 1
a1378 1
	/* if the command was mapped in a mbuf, free it */
a1383 1

d1403 2
a1404 2
		if (!(desc->qid & 0x80))	/* reply to a command */
			wpi_cmd_intr(sc, desc);
d1408 2
a1409 2
			/* a 802.11 frame was received */
			wpi_rx_intr(sc, desc, data);
d1413 2
a1414 2
			/* a 802.11 frame has been transmitted */
			wpi_tx_intr(sc, desc);
d1422 1
a1422 1
			/* the microcontroller is ready */
d1431 4
d1441 1
a1441 1
			/* enabled/disabled notification */
d1445 1
a1445 1
				/* the radio button has to be pushed */
d1448 1
a1448 1
				/* turn the interface down */
d1451 1
a1451 1
				return;	/* no further processing */
d1463 1
a1463 1
			/* fix current channel */
d1475 2
a1476 1
			if (scan->status == 1 && scan->chan <= 14) {
d1478 2
a1479 2
				 * We just finished scanning 802.11g channels,
				 * start scanning 802.11a ones.
d1481 1
a1481 1
				if (wpi_scan(sc, IEEE80211_CHAN_A) == 0)
d1492 1
a1492 1
	/* tell the firmware what we have processed */
d1494 69
a1562 1
	WPI_WRITE(sc, WPI_RX_WIDX, hw & ~7);
d1570 1
a1570 1
	uint32_t r;
d1572 2
a1573 3
	r = WPI_READ(sc, WPI_INTR);
	if (r == 0 || r == 0xffffffff)
		return 0;	/* not for us */
d1575 2
a1576 1
	DPRINTFN(6, ("interrupt reg %x\n", r));
d1578 11
a1588 4
	/* disable interrupts */
	WPI_WRITE(sc, WPI_MASK, 0);
	/* ack interrupts */
	WPI_WRITE(sc, WPI_INTR, r);
d1590 1
a1590 2
	if (r & (WPI_SW_ERROR | WPI_HW_ERROR)) {
		/* SYSTEM FAILURE, SYSTEM FAILURE */
d1592 2
d1598 2
a1599 2

	if (r & WPI_RX_INTR)
d1602 2
a1603 2
	if (r & WPI_ALIVE_INTR)	/* firmware initialized */
		wakeup(sc);
d1605 1
a1605 1
	/* re-enable interrupts */
d1607 1
a1607 1
		WPI_WRITE(sc, WPI_MASK, WPI_INTR_MASK);
d1633 1
a1633 1
	/* unsupported rates (should not get there) */
d1638 1
a1638 1
/* quickly determine if a given rate is CCK or OFDM */
d1642 1
a1642 2
wpi_tx_data(struct wpi_softc *sc, struct mbuf *m0, struct ieee80211_node *ni,
    int ac)
d1645 1
a1645 1
	struct wpi_tx_ring *ring = &sc->txq[ac];
d1652 1
d1654 3
d1658 15
a1672 1
	int i, rate, error;
d1674 1
d1678 1
a1678 4
	wh = mtod(m0, struct ieee80211_frame *);
	hdrlen = ieee80211_get_hdrlen(wh);

	/* pickup a rate */
d1680 1
a1680 3
	    ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	     IEEE80211_FC0_TYPE_MGT)) {
		/* mgmt/multicast frames are sent at the lowest avail. rate */
d1699 2
a1700 1
		if (wh->i_fc[1] & IEEE80211_FC1_WEP)
d1713 19
d1739 1
a1739 2
	/* no need to zero tx, all fields are reinitialized here */
	tx->flags = 0;
d1741 7
a1747 7
	if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
		k = ieee80211_get_txkey(ic, wh, ni);

		if ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)
			return ENOBUFS;

		wh = mtod(m0, struct ieee80211_frame *);
d1750 1
d1752 4
a1755 13
		tx->id = WPI_ID_BSS;
		tx->flags |= htole32(WPI_TX_NEED_ACK);
	} else
		tx->id = WPI_ID_BROADCAST;

	/* check if RTS/CTS or CTS-to-self protection must be used */
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		/* multicast frames are not sent at OFDM rates in 802.11b/g */
		if (m0->m_pkthdr.len + IEEE80211_CRC_LEN >
		    ic->ic_rtsthreshold) {
			tx->flags |= htole32(WPI_TX_NEED_RTS |
			    WPI_TX_FULL_TXOP);
		} else if ((ic->ic_flags & IEEE80211_F_USEPROT) &&
d1757 4
a1760 7
			if (ic->ic_protmode == IEEE80211_PROT_CTSONLY) {
				tx->flags |= htole32(WPI_TX_NEED_CTS |
				    WPI_TX_FULL_TXOP);
			} else if (ic->ic_protmode == IEEE80211_PROT_RTSCTS) {
				tx->flags |= htole32(WPI_TX_NEED_RTS |
				    WPI_TX_FULL_TXOP);
			}
d1764 5
a1768 1
	tx->flags |= htole32(WPI_TX_AUTO_SEQ);
d1770 1
a1770 2
	if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	    IEEE80211_FC0_TYPE_MGT) {
d1773 2
a1774 1
		/* tell h/w to set timestamp in probe responses */
d1776 2
a1777 2
			tx->flags |= htole32(WPI_TX_INSERT_TSTAMP);

d1786 2
a1787 2
	tx->len = htole16(m0->m_pkthdr.len);
	tx->rate = wpi_plcp_signal(rate);
d1793 1
d1795 1
a1795 1
	/* copy and trim IEEE802.11 header */
d1797 23
a1819 1
	m_adj(m0, hdrlen);
d1830 1
a1830 1
		/* too many fragments, linearize */
a1845 1

d1867 1
a1867 1
	/* first scatter/gather segment is used by the tx data command */
d1870 1
d1875 1
d1883 3
a1885 1
	ring->queued++;
d1887 3
a1889 3
	/* kick ring */
	ring->cur = (ring->cur + 1) % WPI_TX_RING_COUNT;
	WPI_WRITE(sc, WPI_TX_WIDX, ring->qid << 8 | ring->cur);
d1900 1
a1900 1
	struct mbuf *m0;
a1901 4
	/*
	 * net80211 may still try to send management frames even if the
	 * IFF_RUNNING flag is not set...
	 */
d1906 12
a1917 8
		IF_POLL(&ic->ic_mgtq, m0);
		if (m0 != NULL) {
			/* management frames go into ring 0 */
			if (sc->txq[0].queued >= WPI_TX_RING_COUNT - 8) {
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}
			IF_DEQUEUE(&ic->ic_mgtq, m0);
d1919 4
a1922 2
			ni = (struct ieee80211_node *)m0->m_pkthdr.rcvif;
			m0->m_pkthdr.rcvif = NULL;
d1924 2
a1925 2
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
d1927 3
a1929 15
			if (wpi_tx_data(sc, m0, ni, 0) != 0)
				break;

		} else {
			if (ic->ic_state != IEEE80211_S_RUN)
				break;
			IFQ_POLL(&ifp->if_snd, m0);
			if (m0 == NULL)
				break;
			if (sc->txq[0].queued >= WPI_TX_RING_COUNT - 8) {
				/* there is no place left in this ring */
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}
			IFQ_DEQUEUE(&ifp->if_snd, m0);
d1931 2
a1932 2
			if (ifp->if_bpf != NULL)
				bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
d1934 4
a1937 13
			m0 = ieee80211_encap(ifp, m0, &ni);
			if (m0 == NULL)
				continue;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
#endif
			if (wpi_tx_data(sc, m0, ni, 0) != 0) {
				if (ni != NULL)
					ieee80211_release_node(ic, ni);
				ifp->if_oerrors++;
				break;
			}
d1989 1
a1989 1
				wpi_init(ifp);
d2007 15
d2030 1
a2030 1
			wpi_init(ifp);
a2038 112
void
wpi_read_eeprom(struct wpi_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	char domain[4];
	int i;

	wpi_read_prom_data(sc, WPI_EEPROM_CAPABILITIES, &sc->cap, 1);
	wpi_read_prom_data(sc, WPI_EEPROM_REVISION, &sc->rev, 2);
	wpi_read_prom_data(sc, WPI_EEPROM_TYPE, &sc->type, 1);

	DPRINTF(("cap=%x rev=%x type=%x\n", sc->cap, letoh16(sc->rev),
	    sc->type));

	/* read and print regulatory domain */
	wpi_read_prom_data(sc, WPI_EEPROM_DOMAIN, domain, 4);
	printf(", %.4s", domain);

	/* read and print MAC address */
	wpi_read_prom_data(sc, WPI_EEPROM_MAC, ic->ic_myaddr, 6);
	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));

	/* read the list of authorized channels */
	for (i = 0; i < WPI_CHAN_BANDS_COUNT; i++)
		wpi_read_eeprom_channels(sc, i);

	/* read the list of power groups */
	for (i = 0; i < WPI_POWER_GROUPS_COUNT; i++)
		wpi_read_eeprom_group(sc, i);
}

void
wpi_read_eeprom_channels(struct wpi_softc *sc, int n)
{
	struct ieee80211com *ic = &sc->sc_ic;
	const struct wpi_chan_band *band = &wpi_bands[n];
	struct wpi_eeprom_chan channels[WPI_MAX_CHAN_PER_BAND];
	int chan, i;

	wpi_read_prom_data(sc, band->addr, channels,
	    band->nchan * sizeof (struct wpi_eeprom_chan));

	for (i = 0; i < band->nchan; i++) {
		if (!(channels[i].flags & WPI_EEPROM_CHAN_VALID))
			continue;

		chan = band->chan[i];

		if (n == 0) {	/* 2GHz band */
			ic->ic_channels[chan].ic_freq =
			    ieee80211_ieee2mhz(chan, IEEE80211_CHAN_2GHZ);
			ic->ic_channels[chan].ic_flags =
			    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
			    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;

		} else {	/* 5GHz band */
			/*
			 * Some 3945ABG adapters support channels 7, 8, 11
			 * and 12 in the 2GHz *and* 5GHz bands.
			 * Because of limitations in our net80211(9) stack,
			 * we can't support these channels in 5GHz band.
			 */
			if (chan <= 14)
				continue;

			ic->ic_channels[chan].ic_freq =
			    ieee80211_ieee2mhz(chan, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[chan].ic_flags = IEEE80211_CHAN_A;
		}

		/* is active scan allowed on this channel? */
		if (!(channels[i].flags & WPI_EEPROM_CHAN_ACTIVE)) {
			ic->ic_channels[chan].ic_flags |=
			    IEEE80211_CHAN_PASSIVE;
		}

		/* save maximum allowed power for this channel */
		sc->maxpwr[chan] = channels[i].maxpwr;

		DPRINTF(("adding chan %d flags=0x%x maxpwr=%d\n",
		    chan, channels[i].flags, sc->maxpwr[chan]));
	}
}

void
wpi_read_eeprom_group(struct wpi_softc *sc, int n)
{
	struct wpi_power_group *group = &sc->groups[n];
	struct wpi_eeprom_group rgroup;
	int i;

	wpi_read_prom_data(sc, WPI_EEPROM_POWER_GRP + n * 32, &rgroup,
	    sizeof rgroup);

	/* save power group information */
	group->chan   = rgroup.chan;
	group->maxpwr = rgroup.maxpwr;
	/* temperature at which the samples were taken */
	group->temp   = (int16_t)letoh16(rgroup.temp);

	DPRINTF(("power group %d: chan=%d maxpwr=%d temp=%d\n", n,
	    group->chan, group->maxpwr, group->temp));

	for (i = 0; i < WPI_SAMPLES_COUNT; i++) {
		group->samples[i].index = rgroup.samples[i].index;
		group->samples[i].power = rgroup.samples[i].power;

		DPRINTF(("\tsample %d: index=%d power=%d\n", i,
		    group->samples[i].index, group->samples[i].power));
	}
}

d2047 1
d2049 3
d2053 3
a2055 1
	KASSERT(size <= sizeof cmd->data);
d2057 27
a2083 2
	desc = &ring->desc[ring->cur];
	cmd = &ring->cmd[ring->cur];
d2092 2
a2093 3
	desc->segs[0].addr = htole32(ring->cmd_dma.paddr +
	    ring->cur * sizeof (struct wpi_tx_cmd));
	desc->segs[0].len  = htole32(4 + size);
d2095 1
a2095 1
	/* kick cmd ring */
d2097 1
a2097 1
	WPI_WRITE(sc, WPI_TX_WIDX, ring->qid << 8 | ring->cur);
d2103 1
a2103 1
 * Configure h/w multi-rate retries.
d2112 1
a2112 1
	/* CCK rates (not used with 802.11a) */
d2116 1
a2116 1
		/* fallback to the immediate lower CCK rate (if any) */
d2118 1
a2118 1
		/* try one time at this rate before falling back to "next" */
d2121 1
a2121 2

	/* OFDM rates (not used with 802.11b) */
d2125 2
a2126 2
		/* fallback to the immediate lower rate (if any) */
		/* we allow fallback from OFDM/6 to CCK/2 in 11b/g mode */
d2131 1
a2131 1
		/* try one time at this rate before falling back to "next" */
d2134 1
a2134 2

	/* setup MRR for control frames */
d2142 1
a2142 2

	/* setup MRR for data frames */
a2149 1

a2152 33
/*
 * Install a pairwise key into the hardware.
 */
int
wpi_set_key(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct ieee80211_key *k)
{
	struct wpi_softc *sc = ic->ic_softc;
	struct wpi_node_info node;

	if (k->k_flags & IEEE80211_KEY_GROUP)
		return 0;

	memset(&node, 0, sizeof node);

	switch (k->k_cipher) {
	case IEEE80211_CIPHER_CCMP:
		node.security = htole16(WPI_CIPHER_CCMP);
		node.security |= htole16(k->k_id << 8);
		memcpy(node.key, k->k_key, k->k_len);
		break;
	default:
		return 0;
	}

	node.id = WPI_ID_BSS;
	IEEE80211_ADDR_COPY(node.macaddr, ni->ni_macaddr);
	node.control = WPI_NODE_UPDATE;
	node.flags = WPI_FLAG_SET_KEY;

	return wpi_cmd(sc, WPI_CMD_ADD_NODE, &node, sizeof node, 1);
}

a2184 1

d2188 2
a2189 2
void
wpi_enable_tsf(struct wpi_softc *sc, struct ieee80211_node *ni)
d2191 1
a2191 1
	struct wpi_cmd_tsf tsf;
d2194 4
a2197 4
	memset(&tsf, 0, sizeof tsf);
	memcpy(&tsf.tstamp, ni->ni_tstamp, sizeof (uint64_t));
	tsf.bintval = htole16(ni->ni_intval);
	tsf.lintval = htole16(10);
d2199 1
a2199 1
	/* compute remaining time until next beacon */
d2201 5
a2205 2
	mod = letoh64(tsf.tstamp) % val;
	tsf.binitval = htole32((uint32_t)(val - mod));
d2207 2
a2208 2
	DPRINTF(("TSF bintval=%u tstamp=%llu, init=%u\n",
	    ni->ni_intval, letoh64(tsf.tstamp), (uint32_t)(val - mod)));
d2210 20
a2229 2
	if (wpi_cmd(sc, WPI_CMD_TSF, &tsf, sizeof tsf, 1) != 0)
		printf("%s: could not enable TSF\n", sc->sc_dev.dv_xname);
d2233 1
a2233 1
 * Update Tx power to match what is defined for channel `c'.
d2236 1
a2236 1
wpi_set_txpower(struct wpi_softc *sc, struct ieee80211_channel *c, int async)
d2239 1
d2241 1
a2241 1
	struct wpi_cmd_txpower txpower;
d2243 1
a2243 1
	int i;
d2245 4
a2248 2
	/* get channel number */
	chan = ieee80211_chan2ieee(ic, c);
d2250 2
a2251 2
	/* find the power group to which this channel belongs */
	if (IEEE80211_IS_CHAN_5GHZ(c)) {
d2258 3
a2260 3
	memset(&txpower, 0, sizeof txpower);
	txpower.band = IEEE80211_IS_CHAN_5GHZ(c) ? 0 : 1;
	txpower.chan = htole16(chan);
d2262 1
a2262 1
	/* set Tx power for all OFDM and CCK rates */
d2264 2
a2265 3
		/* retrieve Tx power for this channel/rate combination */
		int idx = wpi_get_power_index(sc, group, c,
		    wpi_ridx_to_rate[i]);
d2267 1
a2267 1
		txpower.rates[i].plcp = wpi_ridx_to_plcp[i];
d2269 3
a2271 3
		if (IEEE80211_IS_CHAN_5GHZ(c)) {
			txpower.rates[i].rf_gain = wpi_rf_gain_5ghz[idx];
			txpower.rates[i].dsp_gain = wpi_dsp_gain_5ghz[idx];
d2273 2
a2274 2
			txpower.rates[i].rf_gain = wpi_rf_gain_2ghz[idx];
			txpower.rates[i].dsp_gain = wpi_dsp_gain_2ghz[idx];
d2279 1
a2279 2

	return wpi_cmd(sc, WPI_CMD_TXPOWER, &txpower, sizeof txpower, async);
d2283 1
a2283 1
 * Determine Tx power index for a given channel/rate combination.
d2291 1
a2291 1
/* fixed-point arithmetic division using a n-bit fractional part */
d2295 1
a2295 1
/* linear interpolation */
d2304 1
a2304 1
	/* get channel number */
d2307 1
a2307 1
	/* default power is group's maximum power - 3dB */
d2310 1
a2310 1
	/* decrease power for highest OFDM rates to reduce distortion */
d2312 1
a2312 1
	case 72:	/* 36Mb/s */
d2315 1
a2315 1
	case 96:	/* 48Mb/s */
d2318 1
a2318 1
	case 108:	/* 54Mb/s */
d2323 1
a2323 1
	/* never exceed channel's maximum allowed Tx power */
d2326 1
a2326 1
	/* retrieve power index into gain tables from samples */
d2330 1
a2330 1
	/* fixed-point linear interpolation using a 19-bit fractional part */
d2341 1
a2341 1
	/* decrease power for CCK rates (-5dB) */
d2345 1
a2345 1
	/* keep power index in a valid range */
d2347 3
a2349 3
		return 0;
	if (idx > WPI_MAX_PWR_INDEX)
		return WPI_MAX_PWR_INDEX;
d2356 50
d2407 1
a2407 1
wpi_auth(struct wpi_softc *sc)
d2410 2
a2411 1
	struct ieee80211_node *ni = ic->ic_bss;
d2415 4
a2418 30
	/* update adapter's configuration */
	IEEE80211_ADDR_COPY(sc->config.bssid, ni->ni_bssid);
	sc->config.chan = ieee80211_chan2ieee(ic, ni->ni_chan);
	if (IEEE80211_IS_CHAN_2GHZ(ni->ni_chan)) {
		sc->config.flags |= htole32(WPI_CONFIG_AUTO |
		    WPI_CONFIG_24GHZ);
	}
	switch (ic->ic_curmode) {
	case IEEE80211_MODE_11A:
		sc->config.cck_mask  = 0;
		sc->config.ofdm_mask = 0x15;
		break;
	case IEEE80211_MODE_11B:
		sc->config.cck_mask  = 0x03;
		sc->config.ofdm_mask = 0;
		break;
	default:	/* assume 802.11b/g */
		sc->config.cck_mask  = 0x0f;
		sc->config.ofdm_mask = 0x15;
	}
	if (ic->ic_flags & IEEE80211_F_SHSLOT)
		sc->config.flags |= htole32(WPI_CONFIG_SHSLOT);
	if (ic->ic_flags & IEEE80211_F_SHPREAMBLE)
		sc->config.flags |= htole32(WPI_CONFIG_SHPREAMBLE);
	DPRINTF(("config chan %d flags %x cck %x ofdm %x\n", sc->config.chan,
	    sc->config.flags, sc->config.cck_mask, sc->config.ofdm_mask));
	error = wpi_cmd(sc, WPI_CMD_CONFIGURE, &sc->config,
	    sizeof (struct wpi_config), 1);
	if (error != 0) {
		printf("%s: could not configure\n", sc->sc_dev.dv_xname);
d2422 48
a2469 3
	/* configuration has changed, set Tx power accordingly */
	if ((error = wpi_set_txpower(sc, ni->ni_chan, 1)) != 0) {
		printf("%s: could not set Tx power\n", sc->sc_dev.dv_xname);
d2473 1
a2473 1
	/* add default node */
d2475 3
a2477 4
	IEEE80211_ADDR_COPY(node.macaddr, ni->ni_bssid);
	node.id = WPI_ID_BSS;
	node.rate = (ic->ic_curmode == IEEE80211_MODE_11A) ?
	    wpi_plcp_signal(12) : wpi_plcp_signal(2);
d2480 1
a2480 1
	error = wpi_cmd(sc, WPI_CMD_ADD_NODE, &node, sizeof node, 1);
d2482 2
a2483 1
		printf("%s: could not add BSS node\n", sc->sc_dev.dv_xname);
d2487 4
a2493 4
/*
 * Send a scan request to the firmware.  Since this command is huge, we map it
 * into a mbuf instead of using the pre-allocated set of commands.
 */
a2497 4
	struct wpi_tx_ring *ring = &sc->txq[4];
	struct wpi_tx_desc *desc;
	struct wpi_tx_data *data;
	struct wpi_tx_cmd *cmd;
d2505 2
a2506 3
	enum ieee80211_phymode mode;
	uint8_t *frm;
	int pktlen, error;
d2508 3
a2510 6
	desc = &ring->desc[ring->cur];
	data = &ring->data[ring->cur];

	MGETHDR(data->m, M_DONTWAIT, MT_DATA);
	if (data->m == NULL) {
		printf("%s: could not allocate mbuf for scan command\n",
d2514 1
a2514 17
	MCLGET(data->m, M_DONTWAIT);
	if (!(data->m->m_flags & M_EXT)) {
		m_freem(data->m);
		data->m = NULL;
		printf("%s: could not allocate mbuf for scan command\n",
		    sc->sc_dev.dv_xname);
		return ENOMEM;
	}

	cmd = mtod(data->m, struct wpi_tx_cmd *);
	cmd->code = WPI_CMD_SCAN;
	cmd->flags = 0;
	cmd->qid = ring->qid;
	cmd->idx = ring->cur;

	hdr = (struct wpi_scan_hdr *)cmd->data;
	memset(hdr, 0, sizeof (struct wpi_scan_hdr));
d2516 2
a2517 3
	 * Move to the next channel if no packets are received within 5 msecs
	 * after sending the probe request (this helps to reduce the duration
	 * of active scans).
d2519 2
a2520 2
	hdr->quiet = htole16(5);	/* timeout in milliseconds */
	hdr->plcp_threshold = htole16(1);	/* min # of packets */
a2522 1
	memset(tx, 0, sizeof (struct wpi_cmd_data));
d2527 1
a2527 1
	if (flags & IEEE80211_CHAN_A) {
d2529 1
a2529 1
		/* send probe requests at 6Mbps */
d2531 1
d2533 2
a2534 2
		hdr->flags = htole32(WPI_CONFIG_24GHZ | WPI_CONFIG_AUTO);
		/* send probe requests at 1Mbps */
d2536 1
d2540 5
a2544 5
	memset(essid, 0, 4 * sizeof (struct wpi_scan_essid));
	essid[0].id  = IEEE80211_ELEMID_SSID;
	essid[0].len = ic->ic_des_esslen;
	memcpy(essid[0].data, ic->ic_des_essid, ic->ic_des_esslen);

d2549 1
a2549 1
	wh = (struct ieee80211_frame *)&essid[4];
d2556 2
a2557 2
	*(u_int16_t *)&wh->i_dur[0] = 0;	/* filled by h/w */
	*(u_int16_t *)&wh->i_seq[0] = 0;	/* filled by h/w */
d2560 1
a2560 8

	/* add SSID IE */
	frm = ieee80211_add_ssid(frm, ic->ic_des_essid, ic->ic_des_esslen);

	mode = ieee80211_chan2mode(ic, ic->ic_ibss_chan);
	rs = &ic->ic_sup_rates[mode];

	/* add supported rates IE */
a2561 2

	/* add supported xrates IE */
d2565 1
a2565 1
	/* setup length of probe request */
d2575 1
d2577 1
a2577 1
		if (!(c->ic_flags & IEEE80211_CHAN_PASSIVE)) {
d2579 2
a2580 3
			if (ic->ic_des_esslen != 0)
				chan->flags |= WPI_CHAN_DIRECT;
		}
d2584 1
a2584 1
			chan->active  = htole16(10);
d2588 1
a2588 1
			chan->active  = htole16(20);
a2592 2

		frm += sizeof (struct wpi_scan_chan);
d2595 2
a2596 2
	hdr->len = htole16(frm - (uint8_t *)hdr);
	pktlen = frm - (uint8_t *)cmd;
d2598 4
a2601 19
	error = bus_dmamap_load(sc->sc_dmat, data->map, cmd, pktlen, NULL,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not map scan command\n",
		    sc->sc_dev.dv_xname);
		m_freem(data->m);
		data->m = NULL;
		return error;
	}

	desc->flags = htole32(WPI_PAD32(pktlen) << 28 | 1 << 24);
	desc->segs[0].addr = htole32(data->map->dm_segs[0].ds_addr);
	desc->segs[0].len  = htole32(data->map->dm_segs[0].ds_len);

	/* kick cmd ring */
	ring->cur = (ring->cur + 1) % WPI_TX_RING_COUNT;
	WPI_WRITE(sc, WPI_TX_WIDX, ring->qid << 8 | ring->cur);

	return 0;	/* will be notified async. of failure/success */
d2605 1
a2605 1
wpi_config(struct wpi_softc *sc)
d2608 1
a2608 3
	struct ifnet *ifp = &ic->ic_if;
	struct wpi_power power;
	struct wpi_bluetooth bluetooth;
d2612 27
a2638 4
	/* set power mode */
	memset(&power, 0, sizeof power);
	power.flags = htole32(WPI_POWER_CAM | 0x8);
	error = wpi_cmd(sc, WPI_CMD_SET_POWER_MODE, &power, sizeof power, 0);
d2640 1
a2640 1
		printf("%s: could not set power mode\n", sc->sc_dev.dv_xname);
d2644 17
a2660 7
	/* configure bluetooth coexistence */
	memset(&bluetooth, 0, sizeof bluetooth);
	bluetooth.flags = 3;
	bluetooth.lead = 0xaa;
	bluetooth.kill = 1;
	error = wpi_cmd(sc, WPI_CMD_BLUETOOTH, &bluetooth, sizeof bluetooth,
	    0);
d2662 1
a2662 1
		printf("%s: could not configure bluetooth coexistence\n",
d2666 2
d2669 12
a2680 10
	/* configure adapter */
	memset(&sc->config, 0, sizeof (struct wpi_config));
	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	IEEE80211_ADDR_COPY(sc->config.myaddr, ic->ic_myaddr);
	/* set default channel */
	sc->config.chan = ieee80211_chan2ieee(ic, ic->ic_ibss_chan);
	sc->config.flags = htole32(WPI_CONFIG_TSF);
	if (IEEE80211_IS_CHAN_2GHZ(ic->ic_ibss_chan)) {
		sc->config.flags |= htole32(WPI_CONFIG_AUTO |
		    WPI_CONFIG_24GHZ);
d2682 3
a2684 18
	sc->config.filter = 0;
	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		sc->config.mode = WPI_MODE_STA;
		sc->config.filter |= htole32(WPI_FILTER_MULTICAST);
		break;
	case IEEE80211_M_IBSS:
	case IEEE80211_M_AHDEMO:
		sc->config.mode = WPI_MODE_IBSS;
		break;
	case IEEE80211_M_HOSTAP:
		sc->config.mode = WPI_MODE_HOSTAP;
		break;
	case IEEE80211_M_MONITOR:
		sc->config.mode = WPI_MODE_MONITOR;
		sc->config.filter |= htole32(WPI_FILTER_MULTICAST |
		    WPI_FILTER_CTL | WPI_FILTER_PROMISC);
		break;
d2686 13
a2698 4
	sc->config.cck_mask  = 0x0f;	/* not yet negotiated */
	sc->config.ofdm_mask = 0xff;	/* not yet negotiated */
	error = wpi_cmd(sc, WPI_CMD_CONFIGURE, &sc->config,
	    sizeof (struct wpi_config), 0);
d2700 2
a2701 1
		printf("%s: configure command failed\n", sc->sc_dev.dv_xname);
d2705 3
a2707 3
	/* configuration has changed, set Tx power accordingly */
	if ((error = wpi_set_txpower(sc, ic->ic_ibss_chan, 0)) != 0) {
		printf("%s: could not set Tx power\n", sc->sc_dev.dv_xname);
d2711 2
a2712 1
	/* add broadcast node */
d2714 4
a2717 3
	IEEE80211_ADDR_COPY(node.macaddr, etherbroadcastaddr);
	node.id = WPI_ID_BROADCAST;
	node.rate = wpi_plcp_signal(2);
d2720 2
a2721 1
	error = wpi_cmd(sc, WPI_CMD_ADD_NODE, &node, sizeof node, 0);
d2723 1
a2723 2
		printf("%s: could not add broadcast node\n",
		    sc->sc_dev.dv_xname);
d2727 13
a2739 4
	if ((error = wpi_mrr_setup(sc)) != 0) {
		printf("%s: could not setup MRR\n", sc->sc_dev.dv_xname);
		return error;
	}
d2744 3
a2746 2
void
wpi_stop_master(struct wpi_softc *sc)
d2748 4
a2751 2
	uint32_t tmp;
	int ntries;
d2753 8
a2760 2
	tmp = WPI_READ(sc, WPI_RESET);
	WPI_WRITE(sc, WPI_RESET, tmp | WPI_STOP_MASTER);
d2762 18
a2779 3
	tmp = WPI_READ(sc, WPI_GPIO_CTL);
	if ((tmp & WPI_GPIO_PWR_STATUS) == WPI_GPIO_PWR_SLEEP)
		return;	/* already asleep */
d2781 5
a2785 8
	for (ntries = 0; ntries < 100; ntries++) {
		if (WPI_READ(sc, WPI_RESET) & WPI_MASTER_DISABLED)
			break;
		DELAY(10);
	}
	if (ntries == 100) {
		printf("%s: timeout waiting for master\n",
		    sc->sc_dev.dv_xname);
d2787 9
d2799 1
a2799 1
wpi_power_up(struct wpi_softc *sc)
d2801 1
a2801 2
	uint32_t tmp;
	int ntries;
d2803 11
a2813 4
	wpi_mem_lock(sc);
	tmp = wpi_mem_read(sc, WPI_MEM_POWER);
	wpi_mem_write(sc, WPI_MEM_POWER, tmp & ~0x03000000);
	wpi_mem_unlock(sc);
d2815 3
a2817 2
	for (ntries = 0; ntries < 5000; ntries++) {
		if (WPI_READ(sc, WPI_GPIO_STATUS) & WPI_POWERED)
d2821 2
a2822 2
	if (ntries == 5000) {
		printf("%s: timeout waiting for NIC to power up\n",
d2826 3
d2832 4
d2837 1
a2837 1
wpi_reset(struct wpi_softc *sc)
d2839 3
a2841 2
	uint32_t tmp;
	int ntries;
d2843 2
a2844 2
	/* clear any pending interrupts */
	WPI_WRITE(sc, WPI_INTR, 0xffffffff);
d2846 3
a2848 2
	tmp = WPI_READ(sc, WPI_PLL_CTL);
	WPI_WRITE(sc, WPI_PLL_CTL, tmp | WPI_PLL_INIT);
d2850 3
a2852 2
	tmp = WPI_READ(sc, WPI_CHICKEN);
	WPI_WRITE(sc, WPI_CHICKEN, tmp | WPI_CHICKEN_RXNOLOS);
d2854 2
a2855 2
	tmp = WPI_READ(sc, WPI_GPIO_CTL);
	WPI_WRITE(sc, WPI_GPIO_CTL, tmp | WPI_GPIO_INIT);
d2857 1
a2857 1
	/* wait for clock stabilization */
d2859 2
a2860 1
		if (WPI_READ(sc, WPI_GPIO_CTL) & WPI_GPIO_CLOCK)
d2865 1
a2865 1
		printf("%s: timeout waiting for clock stabilization\n",
d2867 1
d2871 138
a3008 5
	/* initialize EEPROM */
	tmp = WPI_READ(sc, WPI_EEPROM_STATUS);
	if ((tmp & WPI_EEPROM_VERSION) == 0) {
		printf("%s: EEPROM not found\n", sc->sc_dev.dv_xname);
		return EIO;
d3010 26
a3035 1
	WPI_WRITE(sc, WPI_EEPROM_STATUS, tmp & ~WPI_EEPROM_LOCKED);
d3041 20
a3060 1
wpi_hw_config(struct wpi_softc *sc)
d3062 3
a3064 1
	uint32_t rev, hw;
d3066 5
a3070 2
	/* voodoo from the reference driver */
	hw = WPI_READ(sc, WPI_HWCONFIG);
d3072 3
a3074 2
	rev = pci_conf_read(sc->sc_pct, sc->sc_pcitag, PCI_CLASS_REG);
	rev = PCI_REVISION(rev);
d3076 1
a3076 1
		hw |= WPI_HW_ALM_MB;
d3078 1
a3078 1
		hw |= WPI_HW_ALM_MM;
d3081 1
a3081 1
		hw |= WPI_HW_SKU_MRC;
a3082 1
	hw &= ~WPI_HW_REV_D;
d3084 3
a3086 1
		hw |= WPI_HW_REV_D;
d3089 1
a3089 4
		hw |= WPI_HW_TYPE_B;

	DPRINTF(("setting h/w config %x\n", hw));
	WPI_WRITE(sc, WPI_HWCONFIG, hw);
d3093 1
a3093 1
wpi_init(struct ifnet *ifp)
a3094 3
	struct wpi_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t tmp;
d3097 8
a3104 1
	(void)wpi_reset(sc);
d3106 27
a3132 14
	wpi_mem_lock(sc);
	wpi_mem_write(sc, WPI_MEM_CLOCK1, 0xa00);
	DELAY(20);
	tmp = wpi_mem_read(sc, WPI_MEM_PCIDEV);
	wpi_mem_write(sc, WPI_MEM_PCIDEV, tmp | 0x800);
	wpi_mem_unlock(sc);

	(void)wpi_power_up(sc);
	wpi_hw_config(sc);

	/* init Rx ring */
	wpi_mem_lock(sc);
	WPI_WRITE(sc, WPI_RX_BASE, sc->rxq.desc_dma.paddr);
	WPI_WRITE(sc, WPI_RX_RIDX_PTR, sc->shared_dma.paddr +
d3134 13
a3146 13
	WPI_WRITE(sc, WPI_RX_WIDX, (WPI_RX_RING_COUNT - 1) & ~7);
	WPI_WRITE(sc, WPI_RX_CONFIG, 0xa9601010);
	wpi_mem_unlock(sc);

	/* init Tx rings */
	wpi_mem_lock(sc);
	wpi_mem_write(sc, WPI_MEM_MODE, 2);	/* bypass mode */
	wpi_mem_write(sc, WPI_MEM_RA, 1);	/* enable RA0 */
	wpi_mem_write(sc, WPI_MEM_TXCFG, 0x3f);	/* enable all 6 Tx rings */
	wpi_mem_write(sc, WPI_MEM_BYPASS1, 0x10000);
	wpi_mem_write(sc, WPI_MEM_BYPASS2, 0x30002);
	wpi_mem_write(sc, WPI_MEM_MAGIC4, 4);
	wpi_mem_write(sc, WPI_MEM_MAGIC5, 5);
d3148 14
a3161 2
	WPI_WRITE(sc, WPI_TX_BASE_PTR, sc->shared_dma.paddr);
	WPI_WRITE(sc, WPI_MSG_CONFIG, 0xffff05a5);
d3164 20
a3183 18
		WPI_WRITE(sc, WPI_TX_CTL(qid), 0);
		WPI_WRITE(sc, WPI_TX_BASE(qid), 0);
		WPI_WRITE(sc, WPI_TX_CONFIG(qid), 0x80200008);
	}
	wpi_mem_unlock(sc);

	/* clear "radio off" and "disable command" bits (reversed logic) */
	WPI_WRITE(sc, WPI_UCODE_CLR, WPI_RADIO_OFF);
	WPI_WRITE(sc, WPI_UCODE_CLR, WPI_DISABLE_CMD);

	/* clear any pending interrupts */
	WPI_WRITE(sc, WPI_INTR, 0xffffffff);
	/* enable interrupts */
	WPI_WRITE(sc, WPI_MASK, WPI_INTR_MASK);

	/* not sure why/if this is necessary... */
	WPI_WRITE(sc, WPI_UCODE_CLR, WPI_RADIO_OFF);
	WPI_WRITE(sc, WPI_UCODE_CLR, WPI_RADIO_OFF);
d3187 43
a3229 1
		goto fail1;
d3231 4
d3236 9
a3244 5
	/* check that the radio is not disabled by RF switch */
	wpi_mem_lock(sc);
	tmp = wpi_mem_read(sc, WPI_MEM_RFKILL);
	wpi_mem_unlock(sc);
	if (!(tmp & 1)) {
d3247 2
a3248 2
		error = EPERM;	/* XXX ;-) */
		goto fail1;
d3251 4
a3254 5
	/* wait for thermal sensors to calibrate */
	for (ntries = 0; ntries < 1000; ntries++) {
		if ((sc->temp = (int)WPI_READ(sc, WPI_TEMPERATURE)) != 0)
			break;
		DELAY(10);
d3256 6
a3261 2
	if (ntries == 1000) {
		printf("%s: timeout waiting for thermal sensors calibration\n",
d3263 1
a3263 2
		error = ETIMEDOUT;
		goto fail1;
a3264 3
	DPRINTF(("temperature %d\n", sc->temp));
	sc->sensor.value = sc->temp + 260;
	sc->sensor.flags &= ~SENSOR_FINVALID;
d3266 1
d3270 1
a3270 1
		goto fail1;
d3283 1
a3283 1
fail1:	wpi_stop(ifp, 1);
a3291 2
	uint32_t tmp;
	int i;
d3296 1
a3296 1
	/* in case we were scanning, release the scan "lock" */
d3301 2
a3302 16
	/* disable interrupts */
	WPI_WRITE(sc, WPI_MASK, 0);
	WPI_WRITE(sc, WPI_INTR, WPI_INTR_MASK);
	WPI_WRITE(sc, WPI_INTR_STATUS, 0xff);
	WPI_WRITE(sc, WPI_INTR_STATUS, 0x00070000);

	wpi_mem_lock(sc);
	wpi_mem_write(sc, WPI_MEM_MODE, 0);
	wpi_mem_unlock(sc);

	/* reset all Tx rings */
	for (i = 0; i < WPI_NTXQUEUES; i++)
		wpi_reset_tx_ring(sc, &sc->txq[i]);

	/* reset Rx ring */
	wpi_reset_rx_ring(sc, &sc->rxq);
d3304 1
a3304 1
	/* temperature is no longer valid */
a3306 10

	wpi_mem_lock(sc);
	wpi_mem_write(sc, WPI_MEM_CLOCK2, 0x200);
	wpi_mem_unlock(sc);

	DELAY(5);

	wpi_stop_master(sc);
	tmp = WPI_READ(sc, WPI_RESET);
	WPI_WRITE(sc, WPI_RESET, tmp | WPI_SW_RESET);
a3307 4

struct cfdriver wpi_cd = {
	NULL, "wpi", DV_IFNET
};
@


1.64
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.63 2008/07/31 20:14:17 damien Exp $	*/
a2610 2
#ifndef IEEE80211_STA_ONLY
#ifdef notyet
a2617 2
#endif
#endif
a2622 3
	default:
		/* should not get there */
		break;
d2728 1
a2728 1
	for (ntries = 0; ntries < 25000; ntries++) {
d2731 1
a2731 1
		DELAY(100);
d2733 1
a2733 1
	if (ntries == 25000) {
@


1.63
log
@Wait much longer for clock stabilization.

From jcs@@ and in accordance with what the Intel Linux driver does.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.62 2008/07/21 18:43:19 damien Exp $	*/
d2611 2
d2620 2
d2626 3
@


1.62
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.61 2008/06/16 18:43:06 damien Exp $	*/
d2728 1
a2728 1
	for (ntries = 0; ntries < 1000; ntries++) {
d2731 1
a2731 1
		DELAY(10);
d2733 1
a2733 1
	if (ntries == 1000) {
@


1.61
log
@replace min() and max() function calls by MIN() and MAX().
MIN() and MAX() are macros that can evaluate their arguments twice
but it is safe in this context.

following a post from miod@@ about the harmfulness of min() and max()
in the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.60 2008/04/16 18:32:15 damien Exp $	*/
d1207 1
d1321 4
a1324 1
	ieee80211_input(ifp, m, ni, stat->rssi, 0);
@


1.60
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.59 2008/03/08 16:24:45 espie Exp $	*/
d2298 1
a2298 1
	pwr = min(pwr, sc->maxpwr[chan]);
@


1.59
log
@allows SMALL_KERNEL compiles
okay damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.58 2007/11/19 19:34:25 damien Exp $	*/
d133 1
a133 1
		    const struct ieee80211_key *);
d273 1
d303 1
d305 1
d1575 1
d1578 1
a1578 1
	int i, rate, error, ovhd = 0;
d1633 7
a1639 12
		const struct ieee80211_key *key =
		    &ic->ic_nw_keys[ic->ic_wep_txkey];
		if (key->k_cipher == IEEE80211_CIPHER_WEP40)
			tx->security = WPI_CIPHER_WEP40;
		else
			tx->security = WPI_CIPHER_WEP104;
		tx->security |= ic->ic_wep_txkey << 6;
		memcpy(&tx->key[3], key->k_key, key->k_len);
		/* compute crypto overhead */
		ovhd = IEEE80211_WEP_TOTLEN;
	} else
		tx->security = 0;
d1650 1
a1650 1
		if (m0->m_pkthdr.len + ovhd + IEEE80211_CRC_LEN >
d2120 1
a2120 1
    const struct ieee80211_key *k)
@


1.58
log
@all TX rings have the same fixed size (256 entries) and this is not
configurable so simplify rings allocation a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.57 2007/11/03 13:10:29 damien Exp $	*/
d75 1
d77 1
d313 1
d315 1
d332 1
d350 1
@


1.57
log
@fix ENETRESET handling in {wpi,iwn}_ioctl() so that the firmware won't
panic when resetting the device - requested by many
fix ifconfig -M (the interface still has to be down though ie it won't
work while the interface is up).
fix AMPDU window for 4965AGN (has no effect since 802.11n is not
supported yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.56 2007/09/11 18:52:32 damien Exp $	*/
d93 1
a93 1
		    int, int);
d253 1
a253 3
		struct wpi_tx_ring *txq = &sc->txq[i];
		error = wpi_alloc_tx_ring(sc, txq, WPI_TX_RING_COUNT, i);
		if (error != 0) {
d259 1
a259 2
	error = wpi_alloc_rx_ring(sc, &sc->rxq);
	if (error != 0) {
d629 1
a629 2
wpi_alloc_tx_ring(struct wpi_softc *sc, struct wpi_tx_ring *ring, int count,
    int qid)
d631 1
a634 1
	ring->count = count;
d638 1
d640 1
a640 2
	    (void **)&ring->desc, count * sizeof (struct wpi_tx_desc),
	    WPI_RING_DMA_ALIGN, BUS_DMA_NOWAIT);
d650 1
d652 1
a652 2
	    (void **)&ring->cmd, count * sizeof (struct wpi_tx_cmd), 4,
	    BUS_DMA_NOWAIT);
d659 1
a659 9
	ring->data = malloc(count * sizeof (struct wpi_tx_data), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (ring->data == NULL) {
		printf("%s: could not allocate tx data slots\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	for (i = 0; i < count; i++) {
d701 1
a701 1
	for (i = 0; i < ring->count; i++) {
d723 6
a728 8
	if (ring->data != NULL) {
		for (i = 0; i < ring->count; i++) {
			struct wpi_tx_data *data = &ring->data[i];

			if (data->m != NULL) {
				bus_dmamap_unload(sc->sc_dmat, data->map);
				m_freem(data->m);
			}
a729 1
		free(ring->data, M_DEVBUF);
d1780 1
a1780 1
			if (sc->txq[0].queued >= sc->txq[0].count - 8) {
d1801 1
a1801 1
			if (sc->txq[0].queued >= sc->txq[0].count - 8) {
@


1.56
log
@- add callbacks for setting EDCA parameters and pairwise crypto keys.
- tweaks to make it look more like iwn(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.55 2007/09/11 18:06:11 damien Exp $	*/
d778 3
a780 1
	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING))
d782 1
a782 1

a795 3
	if (ic->ic_state == IEEE80211_S_SCAN)
		ic->ic_scan_lock = IEEE80211_SCAN_UNLOCKED;

d1914 2
a1915 1
		    (IFF_UP | IFF_RUNNING))
d1917 1
d2909 3
@


1.55
log
@fix a bug in the scan command I introduced with my previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.54 2007/09/10 20:34:43 damien Exp $	*/
d75 2
d130 3
d184 1
a184 1
	int ac, error;
d252 3
a254 3
	for (ac = 0; ac < 4; ac++) {
		error = wpi_alloc_tx_ring(sc, &sc->txq[ac], WPI_TX_RING_COUNT,
		    ac);
d256 1
a256 1
			printf(": could not allocate Tx ring %d\n", ac);
a260 6
	error = wpi_alloc_tx_ring(sc, &sc->cmdq, WPI_CMD_RING_COUNT, 4);
	if (error != 0) {
		printf(": could not allocate command ring\n");
		goto fail3;
	}

d264 1
a264 1
		goto fail4;
d303 2
d314 23
a336 1
	/* register thermal sensor with the sensor framework */
d347 1
d349 6
a354 4
	timeout_set(&sc->calib_to, wpi_calib_timeout, sc);

	sc->powerhook = powerhook_establish(wpi_power, sc);

d356 1
a356 1
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
a366 10

	return;

	/* free allocated memory if something failed during attachment */
fail4:	wpi_free_tx_ring(sc, &sc->cmdq);
fail3:	while (--ac >= 0)
		wpi_free_tx_ring(sc, &sc->txq[ac]);
	wpi_free_rpool(sc);
fail2:	wpi_free_shared(sc);
fail1:	wpi_free_fwmem(sc);
d693 1
d700 2
a701 1
		if (WPI_READ(sc, WPI_TX_STATUS) & WPI_TX_IDLE(ring->qid))
d1380 1
a1380 1
	struct wpi_tx_ring *ring = &sc->cmdq;
d2042 1
a2042 1
	struct wpi_tx_ring *ring = &sc->cmdq;
d2063 1
a2063 1
	ring->cur = (ring->cur + 1) % WPI_CMD_RING_COUNT;
d2124 56
d2388 1
a2388 1
	IEEE80211_ADDR_COPY(node.bssid, ni->ni_bssid);
d2411 1
a2411 1
	struct wpi_tx_ring *ring = &sc->cmdq;
d2561 1
a2561 1
	ring->cur = (ring->cur + 1) % WPI_CMD_RING_COUNT;
d2646 1
a2646 1
	IEEE80211_ADDR_COPY(node.bssid, etherbroadcastaddr);
d2904 1
a2904 1
	int ac;
d2922 2
a2923 3
	for (ac = 0; ac < 4; ac++)
		wpi_reset_tx_ring(sc, &sc->txq[ac]);
	wpi_reset_tx_ring(sc, &sc->cmdq);
a2938 1

@


1.54
log
@- add support for 802.11 headers with various sizes (will be required
  for EDCA support).
- remove an unused function.
- fix scan command.
- detect if the hardware radio switch is on instead of failing in the
  calibration of the thermal sensor with an obscure message.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.53 2007/09/07 19:05:05 damien Exp $	*/
d2387 1
@


1.53
log
@use new malloc M_ZERO flag to shrink kernel.
remove <malloc.h> from files where malloc is not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.52 2007/08/28 18:34:38 deraadt Exp $	*/
a133 3
#ifdef notyet
int		wpi_setup_beacon(struct wpi_softc *, struct ieee80211_node *);
#endif
d1565 1
d1572 1
d1677 1
a1678 2

	/* be very persistant at sending frames out */
a1680 1

d1685 3
a1687 5
	tx->len = htole16(m0->m_pkthdr.len);

	/* save and trim IEEE802.11 header */
	m_copydata(m0, 0, sizeof (struct ieee80211_frame), (caddr_t)&tx->wh);
	m_adj(m0, sizeof (struct ieee80211_frame));
d1741 2
a1742 1
	desc->segs[0].len  = htole32(4 + sizeof (struct wpi_cmd_data));
a2264 75
/*
 * Build a beacon frame that the firmware will broadcast periodically in
 * IBSS or HostAP modes.
 */
#ifdef notyet
int
wpi_setup_beacon(struct wpi_softc *sc, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct wpi_tx_ring *ring = &sc->cmdq;
	struct wpi_tx_desc *desc;
	struct wpi_tx_data *data;
	struct wpi_tx_cmd *cmd;
	struct wpi_cmd_beacon *bcn;
	struct mbuf *m0;
	int error;

	desc = &ring->desc[ring->cur];
	data = &ring->data[ring->cur];

	m0 = ieee80211_beacon_alloc(ic, ni);
	if (m0 == NULL) {
		printf("%s: could not allocate beacon frame\n",
		    sc->sc_dev.dv_xname);
		return ENOMEM;
	}

	cmd = &ring->cmd[ring->cur];
	cmd->code = WPI_CMD_SET_BEACON;
	cmd->flags = 0;
	cmd->qid = ring->qid;
	cmd->idx = ring->cur;

	bcn = (struct wpi_cmd_beacon *)cmd->data;
	memset(bcn, 0, sizeof (struct wpi_cmd_beacon));
	bcn->id = WPI_ID_BROADCAST;
	bcn->ofdm_mask = 0xff;
	bcn->cck_mask = 0x0f;
	bcn->lifetime = htole32(WPI_LIFETIME_INFINITE);
	bcn->len = htole16(m0->m_pkthdr.len);
	bcn->rate = (ic->ic_curmode == IEEE80211_MODE_11A) ?
	    wpi_plcp_signal(12) : wpi_plcp_signal(2);
	bcn->flags = htole32(WPI_TX_AUTO_SEQ | WPI_TX_INSERT_TSTAMP);

	/* save and trim IEEE802.11 header */
	m_copydata(m0, 0, sizeof (struct ieee80211_frame), (caddr_t)&bcn->wh);
	m_adj(m0, sizeof (struct ieee80211_frame));

	/* assume beacon frame is contiguous */
	error = bus_dmamap_load(sc->sc_dmat, data->map, mtod(m0, void *),
	    m0->m_pkthdr.len, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not map beacon\n", sc->sc_dev.dv_xname);
		m_freem(m0);
		return error;
	}

	data->m = m0;

	/* first scatter/gather segment is used by the beacon command */
	desc->flags = htole32(WPI_PAD32(m0->m_pkthdr.len) << 28 | 2 << 24);
	desc->segs[0].addr = htole32(ring->cmd_dma.paddr +
	    ring->cur * sizeof (struct wpi_tx_cmd));
	desc->segs[0].len  = htole32(4 + sizeof (struct wpi_cmd_beacon));
	desc->segs[1].addr = htole32(data->map->dm_segs[0].ds_addr);
	desc->segs[1].len  = htole32(data->map->dm_segs[0].ds_len);

	/* kick cmd ring */
	ring->cur = (ring->cur + 1) % WPI_CMD_RING_COUNT;
	WPI_WRITE(sc, WPI_TX_WIDX, ring->qid << 8 | ring->cur);

	return 0;
}
#endif

d2342 2
a2377 3
	hdr->txflags = htole32(WPI_TX_AUTO_SEQ);
	hdr->id = WPI_ID_BROADCAST;
	hdr->lifetime = htole32(WPI_LIFETIME_INFINITE);
d2386 5
d2394 1
a2394 1
		hdr->rate = wpi_plcp_signal(12);
d2398 1
a2398 1
		hdr->rate = wpi_plcp_signal(2);
d2401 5
a2405 4
	/* for directed scans, firmware inserts the essid IE itself */
	hdr->essid[0].id  = IEEE80211_ELEMID_SSID;
	hdr->essid[0].len = ic->ic_des_esslen;
	memcpy(hdr->essid[0].data, ic->ic_des_essid, ic->ic_des_esslen);
d2411 1
a2411 1
	wh = (struct ieee80211_frame *)(hdr + 1);
d2423 2
a2424 3
	/* add empty essid IE (firmware generates it for directed scans) */
	*frm++ = IEEE80211_ELEMID_SSID;
	*frm++ = 0;
d2437 1
a2437 1
	hdr->paylen = htole16(frm - (uint8_t *)wh);
d2773 11
@


1.52
log
@unify firmware load failure messages; ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.51 2007/08/22 19:50:25 damien Exp $	*/
d651 1
a651 1
	    M_NOWAIT);
a657 2
	memset(ring->data, 0, count * sizeof (struct wpi_tx_data));

d736 1
a736 6
	struct wpi_node *wn;

	wn = malloc(sizeof (struct wpi_node), M_DEVBUF, M_NOWAIT);
	if (wn != NULL)
		memset(wn, 0, sizeof (struct wpi_node));
	return (struct ieee80211_node *)wn;
@


1.51
log
@when running out of rx buffers, allocate a new mbuf and copy the rx
buffer into it using m_copym2() instead of just dropping the received
frame.  otherwise, it may happen that all rx buffers are queued by
tcp_input() waiting for a frame that will never arrive because we are
dropping it.  when it happens, rx stop working and it is hard to
recover from this.
the problem is not visible when using WEP because WEP decryption is
currently done by software and that rx buffers are copied into mbufs
by the software decryption code.
while i'm here, increase the number of rx buffers allocated by wpi(4)
from 80 to 96 to limit the number of copies.

problem and solution found by bluhm@@ - thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.50 2007/08/10 16:29:27 jasper Exp $	*/
d1024 2
a1025 2
		printf("%s: could not read firmware file\n",
		    sc->sc_dev.dv_xname);
@


1.50
log
@make it more clear that the temperature can range between 0 and 285,
by using "0 - 285" instead of "0..285"

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.49 2007/07/24 16:07:47 damien Exp $	*/
a1236 13
	MGETHDR(mnew, M_DONTWAIT, MT_DATA);
	if (mnew == NULL) {
		ifp->if_ierrors++;
		return;
	}
	if ((rbuf = wpi_alloc_rbuf(sc)) == NULL) {
		m_freem(mnew);
		ifp->if_ierrors++;
		return;
	}
 	/* attach Rx buffer to mbuf */
	MEXTADD(mnew, rbuf->vaddr, WPI_RBUF_SIZE, 0, wpi_free_rbuf, rbuf);

a1237 5
	data->m = mnew;

	/* update Rx descriptor */
	ring->desc[ring->cur] = htole32(rbuf->paddr);

d1243 26
d1400 1
a1400 1
		struct wpi_rx_desc *desc = mtod(data->m, struct wpi_rx_desc *);
@


1.49
log
@hardware WEP in the TX path.
make sure to clear the SCAN lock in case the scan is interrupted.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.48 2007/07/11 16:50:12 damien Exp $	*/
d319 1
a319 1
	strlcpy(sc->sensor.desc, "temperature 0..285",
@


1.48
log
@endianness
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.47 2007/07/10 18:29:38 damien Exp $	*/
d786 3
a1559 1
	struct ifnet *ifp = &ic->ic_if;
d1567 1
a1567 1
	int i, rate, error;
a1573 9
	if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
		m0 = ieee80211_wep_crypt(ifp, m0, 1);
		if (m0 == NULL)
			return ENOBUFS;

		/* packet header may have moved, reset our local pointer */
		wh = mtod(m0, struct ieee80211_frame *);
	}

d1620 14
d1643 1
a1643 1
		if (m0->m_pkthdr.len + IEEE80211_CRC_LEN >
@


1.47
log
@change firmware loading code to adopt the new 2.14.4 firmware layout.
while i'm here, fix allocation of the Rx ring descriptors so we don't
waste memory.

IMPORTANT: you must upgrade your wpi-firmware package to rev. 2.14.4
or the driver will stop working.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.46 2007/07/05 20:29:22 damien Exp $	*/
a1005 1

d1036 2
a1037 2
	init_textsz = htole32(hdr->init_textsz);
	init_datasz = htole32(hdr->init_datasz);
@


1.46
log
@move the logic of determining whether an extended supported rates IE is
needed or not to the callers (instead of doing nothing in add_xrates).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.45 2007/06/16 14:15:37 damien Exp $	*/
d103 2
d106 1
a106 2
int		wpi_load_segment(struct wpi_softc *, uint32_t, const uint8_t *,
		    int);
d540 1
a540 2
	    (void **)&ring->desc,
	    WPI_RX_RING_COUNT * sizeof (struct wpi_rx_desc),
d920 8
d963 4
d968 1
a968 2
wpi_load_segment(struct wpi_softc *sc, uint32_t target, const uint8_t *data,
    int len)
d970 1
a970 3
	struct wpi_dma_info *dma = &sc->fw_dma;
	struct wpi_tx_desc desc;
	int ntries, error = 0;
d972 1
a972 2
	DPRINTFN(2, ("loading firmware segment target=%x len=%d\n", target,
	    len));
d974 1
a974 3
	/* copy data to pre-allocated DMA-safe memory */
	memcpy(dma->vaddr, data, len);
	bus_dmamap_sync(dma->tag, dma->map, 0, len, BUS_DMASYNC_PREWRITE);
d976 7
a982 5
	/* setup Tx descriptor */
	memset(&desc, 0, sizeof desc);
	desc.flags = htole32(WPI_PAD32(len) << 28 | 1 << 24);
	desc.segs[0].addr = htole32(dma->paddr);
	desc.segs[0].len  = htole32(len);
d984 2
a985 2
	/* tell adapter where to copy data in its internal memory */
	WPI_WRITE(sc, WPI_FW_TARGET, target);
d987 3
a989 13
	WPI_WRITE(sc, WPI_TX_CONFIG(6), 0);

	/* copy Tx descriptor into NIC memory */
	WPI_WRITE_REGION_4(sc, WPI_TX_DESC(6), (uint32_t *)&desc,
	    sizeof desc / sizeof (uint32_t));

	WPI_WRITE(sc, WPI_TX_CREDIT(6), 0xfffff);
	WPI_WRITE(sc, WPI_TX_STATE(6), 0x4001);
	WPI_WRITE(sc, WPI_TX_CONFIG(6), 0x80000001);

	/* wait while the adapter transfers the segment */
	for (ntries = 0; ntries < 100; ntries++) {
		if (WPI_READ(sc, WPI_TX_STATUS) & WPI_TX_IDLE(6))
d991 1
a991 1
		DELAY(1000);
d993 3
a995 2
	if (ntries == 100) {
		printf("%s: timeout transferring firmware segment\n",
d997 1
a997 1
		error = ETIMEDOUT;
d999 1
d1001 1
a1001 1
	WPI_WRITE(sc, WPI_TX_CREDIT(6), 0);
d1003 1
a1003 1
	return error;
d1006 1
d1012 4
a1015 2
	const uint8_t *boot_text, *boot_data, *main_text, *main_data;
	uint32_t main_textsz, main_datasz, boot_textsz, boot_datasz;
a1017 1
	uint32_t tmp;
d1021 1
a1021 1
	if ((error = loadfirmware("wpi-ucode", &fw, &size)) != 0) {
d1037 2
a1039 1
	boot_datasz = letoh32(hdr->boot_datasz);
d1041 8
a1048 22
	/* sanity-check firmware header */
	if (main_textsz > WPI_FW_MAIN_TEXT_MAXSZ) {
		printf("%s: main .text segment too large: %u bytes\n",
		    sc->sc_dev.dv_xname, main_textsz);
		error = EINVAL;
		goto fail2;
	}
	if (main_datasz > WPI_FW_MAIN_DATA_MAXSZ) {
		printf("%s: main .data segment too large: %u bytes\n",
		    sc->sc_dev.dv_xname, main_datasz);
		error = EINVAL;
		goto fail2;
	}
	if (boot_textsz > WPI_FW_BOOT_TEXT_MAXSZ) {
		printf("%s: boot .text segment too large: %u bytes\n",
		    sc->sc_dev.dv_xname, boot_textsz);
		error = EINVAL;
		goto fail2;
	}
	if (boot_datasz > WPI_FW_BOOT_DATA_MAXSZ) {
		printf("%s: boot .data segment too large: %u bytes\n",
		    sc->sc_dev.dv_xname, boot_datasz);
d1055 1
a1055 1
	    main_datasz + boot_textsz + boot_datasz) {
d1065 7
a1071 2
	boot_text = main_data + main_datasz;
	boot_data = boot_text + boot_textsz;
d1073 12
a1084 4
	/* load firmware boot .data segment into NIC */
	error = wpi_load_segment(sc, WPI_FW_DATA, boot_data, boot_datasz);
	if (error != 0) {
		printf("%s: could not load firmware boot .data segment\n",
d1089 7
a1095 4
	/* load firmware boot .text segment into NIC */
	error = wpi_load_segment(sc, WPI_FW_TEXT, boot_text, boot_textsz);
	if (error != 0) {
		printf("%s: could not load firmware boot .text segment\n",
d1100 3
a1102 5
	/* copy firmware runtime into pre-allocated DMA-safe memory */
	memcpy(dma->vaddr, main_text, main_textsz);
	memcpy(dma->vaddr + main_textsz, main_data, main_datasz);
	bus_dmamap_sync(dma->tag, dma->map, 0, main_textsz + main_datasz,
	    BUS_DMASYNC_PREWRITE);
d1104 1
a1104 1
	/* tell adapter where to find firmware runtime */
d1106 5
a1110 4
	wpi_mem_write(sc, WPI_MEM_MAIN_TEXT_BASE, dma->paddr);
	wpi_mem_write(sc, WPI_MEM_MAIN_TEXT_SIZE, main_textsz);
	wpi_mem_write(sc, WPI_MEM_MAIN_DATA_BASE, dma->paddr + main_textsz);
	wpi_mem_write(sc, WPI_MEM_MAIN_DATA_SIZE, main_datasz);
d1113 1
a1113 6
	/* now press "execute" ;-) */
	tmp = WPI_READ(sc, WPI_RESET);
	tmp &= ~(WPI_MASTER_DISABLED | WPI_STOP_MASTER | WPI_NEVO_RESET);
	WPI_WRITE(sc, WPI_RESET, tmp);

	/* ..and wait at most one second for adapter to initialize */
@


1.45
log
@do not allocate ring descriptors for the service queue.
this queue is used to load the firmware and the descriptors are written
differently (in wpi_load_segment()).
so the DMA descriptors were actually unused.

saves 16KB of memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.44 2007/06/11 19:26:42 damien Exp $	*/
d2502 2
a2503 1
	frm = ieee80211_add_xrates(frm, rs);
@


1.44
log
@Wait for firmware command WPI_CMD_TXPOWER to complete before sending
the WPI_CMD_ADD_NODE command in wpi_config().
Fixes mp kernels.

Tested by jasper@@, deanna@@, fkr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.43 2007/06/09 09:50:00 damien Exp $	*/
a263 6
	error = wpi_alloc_tx_ring(sc, &sc->svcq, WPI_SVC_RING_COUNT, 5);
	if (error != 0) {
		printf(": could not allocate service ring\n");
		goto fail4;
	}

d267 1
a267 1
		goto fail5;
a346 1
fail5:	wpi_free_tx_ring(sc, &sc->svcq);
a2906 1
	wpi_reset_tx_ring(sc, &sc->svcq);
@


1.43
log
@print regulatory domain in dmesg output.
fix typo in a comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.42 2007/06/06 20:33:18 damien Exp $	*/
d68 1
a68 1
const struct pci_matchid wpi_devices[] = {
d130 1
a130 1
		    struct ieee80211_channel *);
d854 1
a854 1
		if ((error = wpi_set_txpower(sc, ni->ni_chan)) != 0) {
d996 1
a996 1
	/* wait while the adapter transfers the block */
d1193 1
a1193 1
	if (wpi_set_txpower(sc, sc->sc_ic.ic_bss->ni_chan) != 0) {
d1968 1
a1968 1
			 * Some 3945abg adapters support channels 7, 8, 11
d2151 1
a2151 1
wpi_set_txpower(struct wpi_softc *sc, struct ieee80211_channel *c)
d2193 1
a2193 1
	return wpi_cmd(sc, WPI_CMD_TXPOWER, &txpower, sizeof txpower, 1);
d2387 1
a2387 1
	if ((error = wpi_set_txpower(sc, ni->ni_chan)) != 0) {
d2639 1
a2639 1
	if ((error = wpi_set_txpower(sc, ic->ic_ibss_chan)) != 0) {
@


1.42
log
@comment an unused function (wpi_setup_beacon).
i do not plan to add support for independant bss or hostap modes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.41 2007/06/06 20:14:04 damien Exp $	*/
a289 1
	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));
d1915 1
d1925 5
a1929 1
	/* read MAC address */
d1931 1
d2250 1
a2250 1
	 * - if colder than factory-calibrated: decrease output power
@


1.41
log
@- #undef the correct macro
- improve a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.40 2007/06/06 18:06:05 cnst Exp $	*/
d133 1
d135 1
d2269 1
d2338 1
@


1.40
log
@make sensors framework usage consistent with other drivers; ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.39 2007/06/05 19:49:40 damien Exp $	*/
d2241 5
a2245 1
	/* adjust power index based on current temperature */
d2260 1
a2260 1
#undef fdiv
@


1.39
log
@Major wpi(4) update:

1/ Update the driver to use the new firmware images from Intel (2.14.3.)
2/ Read the list of supported channels from the EEPROM instead of having
   it hard-coded in the driver.
3/ Limit output power to what is specified in EEPROM.
4/ Decrease output power for highest OFDM rates to reduce distortion.
5/ Automatically adjust output power to temperature changes for increased
   throughput and range.
6/ Attach the adapter's onboard thermal sensor to the sensor framework.
7/ Replace 'magic' fields in structures with their correct definitions.

NOTE1: you must upgrade your wpi-firmware package to rev 2.14.3 or the
driver will stop working.

NOTE2: if you are using a channel not allowed by the regulatory domain
of your adapter, you will no longer be able to associate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.38 2007/01/03 18:19:06 claudio Exp $	*/
a325 1
	sc->sensor.status = SENSOR_S_OK;
d329 1
a330 1
	sensor_attach(&sc->sensordev, &sc->sensor);
@


1.38
log
@M_DUP_PKTHDR() cleanup. On static mbufs M_DUP_PKTHDR() will leak mbuf tags.
See similar commit to dev/usb/if_rum.c for more info. With this commit
all drivers have been switched away from the incorrect M_DUP_PKTHDR() usage.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.37 2006/11/26 11:14:22 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006
d36 1
a72 5
static const uint8_t wpi_ridx_to_plcp[] = {
	0xd, 0xf, 0x5, 0x7, 0x9, 0xb, 0x1, 0x3,	/* OFDM R1-R4 */
	10, 20, 55, 110	/* CCK */
};

d81 2
d95 2
d103 2
a104 7
void		wpi_mem_write_region_4(struct wpi_softc *, uint16_t,
		    const uint32_t *, int);
uint16_t	wpi_read_prom_word(struct wpi_softc *, uint32_t);
int		wpi_load_microcode(struct wpi_softc *, const char *, int);
int		wpi_load_firmware_block(struct wpi_softc *, uint32_t,
		    bus_dma_segment_t *);
int		wpi_load_firmware(struct wpi_softc *, uint32_t, const char *,
d106 4
d117 2
d129 4
a142 4
void		wpi_iter_func(void *, struct ieee80211_node *);
void		wpi_amrr_timeout(void *);
void		wpi_newassoc(struct ieee80211com *, struct ieee80211_node *,
		    int);
d179 1
a179 1
	int i, ac, error;
d227 8
d239 1
a239 1
		return;
d244 1
a244 1
		goto fail1;
d252 1
a252 1
			goto fail2;
d259 1
a259 1
		goto fail2;
d265 1
a265 1
		goto fail3;
d271 1
a271 1
		goto fail4;
d286 1
d290 1
a290 1
	/* set supported .11a rates */
a291 19

	/* set supported .11a channels */
	for (i = 36; i <= 64; i += 4) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
		ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
	}
	for (i = 100; i <= 140; i += 4) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
		ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
	}
	for (i = 149; i <= 165; i += 4) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
		ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
	}

	/* set supported .11b and .11g rates */
a294 9
	/* set supported .11b and .11g channels (1 through 14) */
	for (i = 1; i <= 14; i++) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
		ic->ic_channels[i].ic_flags =
		    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
		    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
	}

d305 1
a305 1
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
d319 15
a333 1
	timeout_set(&sc->amrr_ch, wpi_amrr_timeout, sc);
d352 4
a355 3
fail4:	wpi_free_tx_ring(sc, &sc->svcq);
fail3:	wpi_free_tx_ring(sc, &sc->cmdq);
fail2:	while (--ac >= 0)
d358 2
a359 1
fail1:	wpi_free_shared(sc);
d414 1
a414 1
	bzero(dma->vaddr, size);
a446 2
	int error;

d448 1
a448 1
	error = wpi_dma_contig_alloc(sc->sc_dmat, &sc->shared_dma,
a450 5
	if (error != 0) {
		printf("%s: could not allocate shared area DMA memory\n",
		    sc->sc_dev.dv_xname);
	}
	return error;
d459 18
d665 1
a665 1
	bzero(ring->data, count * sizeof (struct wpi_tx_data));
d749 1
a749 1
		bzero(wn, sizeof (struct wpi_node));
d753 15
d788 1
d791 1
a791 1
	timeout_del(&sc->amrr_ch);
d812 1
a812 1
		sc->config.state = 0;
d828 1
d830 1
a830 1
		wpi_enable_tsf(sc, ic->ic_bss);
d833 1
a833 1
		sc->config.state = htole16(WPI_STATE_ASSOCIATED);
d853 7
d862 1
a862 1
			wpi_newassoc(ic, ic->ic_bss, 1);
d865 3
a867 3
		/* start automatic rate control timer */
		if (ic->ic_fixed_rate == -1)
			timeout_add(&sc->amrr_ch, hz / 2);
a926 8
void
wpi_mem_write_region_4(struct wpi_softc *sc, uint16_t addr,
    const uint32_t *data, int wlen)
{
	for (; wlen > 0; wlen--, data++, addr += 4)
		wpi_mem_write(sc, addr, *data);
}

d928 2
a929 2
 * Read 16 bits from the EEPROM.  We access EEPROM through the MAC instead of
 * using the traditional bit-bang method.
d931 2
a932 2
uint16_t
wpi_read_prom_word(struct wpi_softc *sc, uint32_t addr)
d934 2
a936 3
	uint32_t val;

	WPI_WRITE(sc, WPI_EEPROM_CTL, addr << 2);
d939 2
a940 6
	for (ntries = 0; ntries < 10; ntries++) {
		if ((val = WPI_READ(sc, WPI_EEPROM_CTL)) & WPI_EEPROM_READY)
			break;
		DELAY(10);
	}
	wpi_mem_unlock(sc);
d942 14
a955 3
	if (ntries == 10) {
		printf("%s: could not read EEPROM\n", sc->sc_dev.dv_xname);
		return 0xdead;
a956 29
	return val >> 16;
}

/*
 * The firmware boot code is small and is intended to be copied directly into
 * the NIC internal memory.
 */
int
wpi_load_microcode(struct wpi_softc *sc, const char *ucode, int size)
{
	/* check that microcode size is a multiple of 4 */
	if (size & 3)
		return EINVAL;

	size /= sizeof (uint32_t);

	wpi_mem_lock(sc);

	/* copy microcode image into NIC memory */
	wpi_mem_write_region_4(sc, WPI_MEM_UCODE_BASE, (const uint32_t *)ucode,
	    size);

	wpi_mem_write(sc, WPI_MEM_UCODE_SRC, 0);
	wpi_mem_write(sc, WPI_MEM_UCODE_DST, WPI_FW_TEXT);
	wpi_mem_write(sc, WPI_MEM_UCODE_SIZE, size);

	/* run microcode */
	wpi_mem_write(sc, WPI_MEM_UCODE_CTL, WPI_UC_RUN);

d963 2
a964 2
wpi_load_firmware_block(struct wpi_softc *sc, uint32_t target,
    bus_dma_segment_t *seg)
d966 1
d970 2
a971 2
	DPRINTFN(2, ("loading firmware block target=%x addr=%x len=%d\n",
	    target, seg->ds_addr, seg->ds_len));
d973 9
a981 4
	bzero(&desc, sizeof desc);
	desc.flags = htole32(WPI_PAD32(seg->ds_len) << 28 | 1 << 24);
	desc.segs[0].addr = htole32(seg->ds_addr);
	desc.segs[0].len  = htole32(seg->ds_len);
d983 1
a983 1
	/* tell adapter where to copy firmware block in its internal memory */
d988 1
a988 1
	/* copy firmware block descriptor into NIC memory */
d996 1
a996 1
	/* wait while the adapter is busy copying the firmware block */
d1003 1
a1003 1
		printf("%s: timeout transferring firmware block\n",
a1012 6
/*
 * The firmware text and data segments are transferred to the NIC using DMA.
 * The driver just DMA-maps the firmware and tells the NIC where to find it.
 * Once the NIC has copied the firmware into its internal memory, we can free
 * our local copy in the driver.
 */
d1014 1
a1014 2
wpi_load_firmware(struct wpi_softc *sc, uint32_t target, const char *fw,
    int size)
d1016 8
a1023 2
	bus_dmamap_t map;
	int i, nsegs, error;
d1025 6
a1030 1
	nsegs = 1 + ((size + PAGE_SIZE - 1) / PAGE_SIZE);
d1032 56
a1087 2
	error = bus_dmamap_create(sc->sc_dmat, size, nsegs, WPI_MAX_SEG_LEN,
	    0, BUS_DMA_NOWAIT, &map);
d1089 3
a1091 3
		printf("%s: could not create firmware DMA map (error=%d)\n",
		    sc->sc_dev.dv_xname, error);
		goto fail1;
d1094 2
a1095 3
	/* XXX: we're discarding a const qualifier here! */
	error = bus_dmamap_load(sc->sc_dmat, map, (void *)fw, size, NULL,
	    BUS_DMA_NOWAIT | BUS_DMA_WRITE);
d1097 2
a1098 2
		printf("%s: could not load firmware DMA map (error=%d)\n",
		    sc->sc_dev.dv_xname, error);
d1102 13
a1114 2
	DPRINTF(("load firmware target=%x size=%d nsegs=%d\n", target, size,
	    map->dm_nsegs));
d1116 4
a1119 2
	/* make sure the adapter will get up-to-date values */
	bus_dmamap_sync(sc->sc_dmat, map, 0, size, BUS_DMASYNC_PREWRITE);
d1121 5
a1125 6
	wpi_mem_lock(sc);
	for (i = 0; i < map->dm_nsegs; i++) {
		error = wpi_load_firmware_block(sc, target, &map->dm_segs[i]);
		if (error != 0)
			break;
		target += map->dm_segs[i].ds_len;
a1126 1
	wpi_mem_unlock(sc);
d1128 1
a1128 3
	bus_dmamap_sync(sc->sc_dmat, map, 0, size, BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(sc->sc_dmat, map);
fail2:	bus_dmamap_destroy(sc->sc_dmat, map);
d1133 68
d1633 1
d1687 1
a1687 1
	tx->lifetime = htole32(0xffffffff);
a1910 3
/*
 * Extract various information from EEPROM.
 */
a1914 1
	uint16_t val;
d1917 7
d1925 89
a2013 16
	val = wpi_read_prom_word(sc, WPI_EEPROM_MAC + 0);
	ic->ic_myaddr[0] = val & 0xff;
	ic->ic_myaddr[1] = val >> 8;
	val = wpi_read_prom_word(sc, WPI_EEPROM_MAC + 1);
	ic->ic_myaddr[2] = val & 0xff;
	ic->ic_myaddr[3] = val >> 8;
	val = wpi_read_prom_word(sc, WPI_EEPROM_MAC + 2);
	ic->ic_myaddr[4] = val & 0xff;
	ic->ic_myaddr[5] = val >> 8;

	/* read power settings for 2.4GHz channels */
	for (i = 0; i < 14; i++) {
		sc->pwr1[i] = wpi_read_prom_word(sc, WPI_EEPROM_PWR1 + i);
		sc->pwr2[i] = wpi_read_prom_word(sc, WPI_EEPROM_PWR2 + i);
		DPRINTFN(2, ("channel %d pwr1 0x%04x pwr2 0x%04x\n", i + 1,
		    sc->pwr1[i], sc->pwr2[i]));
d2036 1
a2036 1
	bcopy(buf, cmd->data, size);
d2086 1
a2086 1
	error = wpi_cmd(sc, WPI_CMD_MRR_SETUP, &mrr, sizeof mrr, 1);
d2095 1
a2095 1
	error = wpi_cmd(sc, WPI_CMD_MRR_SETUP, &mrr, sizeof mrr, 1);
d2124 2
a2125 2
	bzero(&tsf, sizeof tsf);
	bcopy(ni->ni_tstamp, &tsf.tstamp, sizeof (uint64_t));
d2142 119
d2293 1
a2293 1
	bzero(bcn, sizeof (struct wpi_cmd_beacon));
d2297 1
a2297 1
	bcn->lifetime = htole32(0xffffffff);
a2343 1
	sc->config.flags = htole32(WPI_CONFIG_TSF);
d2374 6
d2381 1
a2381 1
	bzero(&node, sizeof node);
d2386 2
a2393 6
	error = wpi_mrr_setup(sc);
	if (error != 0) {
		printf("%s: could not setup MRR\n", sc->sc_dev.dv_xname);
		return error;
	}

d2443 4
a2446 2
	bzero(hdr, sizeof (struct wpi_scan_hdr));
	hdr->first = 1;
d2453 1
a2453 1
	hdr->threshold = htole16(1);	/* min # of packets */
d2456 1
a2456 1
		hdr->band = htole16(WPI_SCAN_5GHZ);
a2463 3
	hdr->id = WPI_ID_BROADCAST;
	hdr->mask = htole32(0xffffffff);
	hdr->magic1 = htole32(1 << 13);
d2465 4
a2468 2
	hdr->esslen = ic->ic_des_esslen;
	bcopy(ic->ic_des_essid, hdr->essid, ic->ic_des_esslen);
d2486 3
a2488 2
	/* add essid IE */
	frm = ieee80211_add_ssid(frm, ic->ic_des_essid, ic->ic_des_esslen);
d2500 1
a2500 1
	hdr->length = htole16(frm - (uint8_t *)wh);
d2509 7
a2515 3
		chan->flags = (c->ic_flags & IEEE80211_CHAN_PASSIVE) ?
		    0 : WPI_CHAN_ACTIVE;
		chan->magic = htole16(0x62ab);
d2517 2
a2518 1
			chan->active = htole16(10);
d2521 2
a2522 1
			chan->active = htole16(20);
d2531 2
a2532 2
	hdr->len = hdr->nchan * sizeof (struct wpi_scan_chan);
	pktlen = frm - mtod(data->m, uint8_t *);
a2559 1
	struct wpi_txpower txpower;
a2564 10
	/* set Tx power for 2.4GHz channels (values read from EEPROM) */
	bzero(&txpower, sizeof txpower);
	bcopy(sc->pwr1, txpower.pwr1, 14 * sizeof (uint16_t));
	bcopy(sc->pwr2, txpower.pwr2, 14 * sizeof (uint16_t));
	error = wpi_cmd(sc, WPI_CMD_TXPOWER, &txpower, sizeof txpower, 0);
	if (error != 0) {
		printf("%s: could not set txpower\n", sc->sc_dev.dv_xname);
		return error;
	}

d2566 2
a2567 2
	bzero(&power, sizeof power);
	power.flags = htole32(0x8);	/* XXX */
d2575 1
a2575 1
	bzero(&bluetooth, sizeof bluetooth);
d2588 1
a2588 1
	bzero(&sc->config, sizeof (struct wpi_config));
d2626 6
d2633 1
a2633 1
	bzero(&node, sizeof node);
d2637 2
d2646 5
a2745 1
	uint16_t val;
d2748 1
a2748 1
	/* voodoo from the Linux "driver".. */
d2758 1
a2758 2
	val = wpi_read_prom_word(sc, WPI_EEPROM_CAPABILITIES);
	if ((val & 0xff) == 0x80)
a2760 1
	val = wpi_read_prom_word(sc, WPI_EEPROM_REVISION);
d2762 1
a2762 1
	if ((val & 0xf0) == 0xd0)
d2765 1
a2765 2
	val = wpi_read_prom_word(sc, WPI_EEPROM_TYPE);
	if ((val & 0xff) > 1)
a2776 4
	const struct wpi_firmware_hdr *hdr;
	const char *boot, *text, *data;
	u_char *fw;
	size_t size;
d2830 3
a2832 12
	if ((error = loadfirmware("wpi-ucode", &fw, &size)) != 0) {
		printf("%s: could not read firmware file\n",
		    sc->sc_dev.dv_xname);
		goto fail1;
	}

	if (size < sizeof (struct wpi_firmware_hdr)) {
		printf("%s: firmware file too short: %d bytes\n",
		    sc->sc_dev.dv_xname, size);
		error = EINVAL;
		goto fail2;
	}
d2834 1
a2834 24
	hdr = (const struct wpi_firmware_hdr *)fw;
	if (size < sizeof (struct wpi_firmware_hdr) + letoh32(hdr->textsz) +
	    letoh32(hdr->datasz) + letoh32(hdr->bootsz)) {
		printf("%s: firmware file too short: %d bytes\n",
		    sc->sc_dev.dv_xname, size);
		error = EINVAL;
		goto fail2;
	}

	/* firmware image layout: |HDR|<--TEXT-->|<--DATA-->|<--BOOT-->| */
	text = (const char *)(hdr + 1);
	data = text + letoh32(hdr->textsz);
	boot = data + letoh32(hdr->datasz);

	/* load firmware boot code into NIC */
	error = wpi_load_microcode(sc, boot, letoh32(hdr->bootsz));
	if (error != 0) {
		printf("%s: could not load microcode\n", sc->sc_dev.dv_xname);
		goto fail2;
	}

	/* load firmware .text segment into NIC */
	error = wpi_load_firmware(sc, WPI_FW_TEXT, text, letoh32(hdr->textsz));
	if (error != 0) {
a2835 22
		goto fail2;
	}

	/* load firmware .data segment into NIC */
	error = wpi_load_firmware(sc, WPI_FW_DATA, data, letoh32(hdr->datasz));
	if (error != 0) {
		printf("%s: could not load firmware\n", sc->sc_dev.dv_xname);
		goto fail2;
	}

	free(fw, M_DEVBUF);

	/* now press "execute" ;-) */
	tmp = WPI_READ(sc, WPI_RESET);
	tmp &= ~(WPI_MASTER_DISABLED | WPI_STOP_MASTER | WPI_NEVO_RESET);
	WPI_WRITE(sc, WPI_RESET, tmp);

	/* ..and wait at most one second for adapter to initialize */
	if ((error = tsleep(sc, PCATCH, "wpiinit", hz)) != 0) {
		/* this isn't what was supposed to happen.. */
		printf("%s: timeout waiting for adapter to initialize\n",
		    sc->sc_dev.dv_xname);
d2841 1
a2841 1
		if (WPI_READ(sc, WPI_TEMPERATURE) != 0)
d2851 3
a2853 1
	DPRINTF(("temperature %d\n", (int)WPI_READ(sc, WPI_TEMPERATURE)));
a2870 1
fail2:	free(fw, M_DEVBUF);
d2907 4
a2920 41
}

void
wpi_iter_func(void *arg, struct ieee80211_node *ni)
{
	struct wpi_softc *sc = arg;
	struct wpi_node *wn = (struct wpi_node *)ni;

	ieee80211_amrr_choose(&sc->amrr, ni, &wn->amn);
}

void
wpi_amrr_timeout(void *arg)
{
	struct wpi_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	int s;

	s = splnet();
	if (ic->ic_opmode == IEEE80211_M_STA)
		wpi_iter_func(sc, ic->ic_bss);
	else
		ieee80211_iterate_nodes(ic, wpi_iter_func, sc);
	splx(s);

	timeout_add(&sc->amrr_ch, hz / 2);
}

void
wpi_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni, int isnew)
{
	struct wpi_softc *sc = ic->ic_if.if_softc;
	int i;

	ieee80211_amrr_node_init(&sc->amrr, &((struct wpi_node *)ni)->amn);

	/* set rate to some reasonable initial value */
	for (i = ni->ni_rates.rs_nrates - 1;
	     i > 0 && (ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL) > 72;
	     i--);
	ni->ni_txrate = i;
@


1.37
log
@do not have each net80211 driver define its own rates structures.  if they use
the standard rates, use some defined by net80211 itself.  kernel shrinks a bit
ok jsg mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.36 2006/11/13 20:06:38 damien Exp $	*/
a1159 1
		M_DUP_PKTHDR(&mb, m);
d1163 3
a1165 1
		mb.m_pkthdr.len += mb.m_len;
a1473 1
		M_DUP_PKTHDR(&mb, m0);
d1477 3
a1479 1
		mb.m_pkthdr.len += mb.m_len;
@


1.36
log
@first round of commits for proper 11b/g protection support:
- use the newly introduced ieee80211_get_rts() and
  ieee80211_get_cts_to_self() functions.
- use CTS-to-self instead of RTS/CTS to protect OFDM frames in
  a mixed 11b/g BSS.
- make sure multicast frames are sent using CCK modulation.

remove support for 5GHz radios in ral(4) RT2560 and ural(4).
i'm not aware of any such adapters on the market and 11a code
is known to be broken.

some cleanup while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.35 2006/11/01 11:25:01 damien Exp $	*/
a71 12
/*
 * Supported rates for 802.11a/b/g modes (in 500Kbps unit).
 */
static const struct ieee80211_rateset wpi_rateset_11a =
	{ 8, { 12, 18, 24, 36, 48, 72, 96, 108 } };

static const struct ieee80211_rateset wpi_rateset_11b =
	{ 4, { 2, 4, 11, 22 } };

static const struct ieee80211_rateset wpi_rateset_11g =
	{ 12, { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 } };

d281 1
a281 1
	ic->ic_sup_rates[IEEE80211_MODE_11A] = wpi_rateset_11a;
d301 2
a302 2
	ic->ic_sup_rates[IEEE80211_MODE_11B] = wpi_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = wpi_rateset_11g;
@


1.35
log
@fix firmware fatal errors on re-associations.

reported and tested by Marc Winiger and dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.34 2006/10/23 18:19:26 damien Exp $	*/
d1460 4
a1463 3
	if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	    IEEE80211_FC0_TYPE_MGT) {
		/* mgmt frames are sent at the lowest available bit-rate */
d1465 5
a1469 7
	} else {
		if (ic->ic_fixed_rate != -1) {
			rate = ic->ic_sup_rates[ic->ic_curmode].
			    rs_rates[ic->ic_fixed_rate];
		} else
			rate = ni->ni_rates.rs_rates[ni->ni_txrate];
	}
d1506 2
d1509 3
d1513 1
a1513 2
		    ic->ic_rtsthreshold || (WPI_RATE_IS_OFDM(rate) &&
		    (ic->ic_flags & IEEE80211_F_USEPROT))) {
d1516 9
d1526 1
a1526 2
	} else
		tx->id = WPI_ID_BROADCAST;
@


1.34
log
@remove detach() function. this is not hotplug and this is dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.33 2006/10/23 18:16:56 damien Exp $	*/
d793 4
a851 1
	case IEEE80211_S_ASSOC:
@


1.33
log
@make sure wpi_iter_func() is called at splnet.
simplify wpi_dma_contig_alloc().
various cosmetic tweaks while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.32 2006/09/18 16:20:20 damien Exp $	*/
a90 1
int		wpi_detach(struct device *, int);
d165 1
a165 1
	sizeof (struct wpi_softc), wpi_match, wpi_attach, wpi_detach
a373 30
}

int
wpi_detach(struct device *self, int flags)
{
	struct wpi_softc *sc = (struct wpi_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int ac;

	wpi_stop(ifp, 1);

	ieee80211_ifdetach(ifp);
	if_detach(ifp);

	for (ac = 0; ac < 4; ac++)
		wpi_free_tx_ring(sc, &sc->txq[ac]);
	wpi_free_tx_ring(sc, &sc->cmdq);
	wpi_free_tx_ring(sc, &sc->svcq);
	wpi_free_rx_ring(sc, &sc->rxq);
	wpi_free_rpool(sc);
	wpi_free_shared(sc);

	if (sc->sc_ih != NULL) {
		pci_intr_disestablish(sc->sc_pct, sc->sc_ih);
		sc->sc_ih = NULL;
	}

	bus_space_unmap(sc->sc_st, sc->sc_sh, sc->sc_sz);

	return 0;
@


1.32
log
@don't use IF_PREPEND() on altq's.
use IFQ_POLL()/IFQ_DEQUEUE() logic instead as described in altq(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.31 2006/08/28 19:47:42 damien Exp $	*/
d93 1
a93 1
int		wpi_dma_contig_alloc(struct wpi_softc *, struct wpi_dma_info *,
d95 1
a95 1
void		wpi_dma_contig_free(struct wpi_softc *, struct wpi_dma_info *);
d434 2
a435 2
wpi_dma_contig_alloc(struct wpi_softc *sc, struct wpi_dma_info *dma,
    void **kvap, bus_size_t size, bus_size_t alignment, int flags)
d439 1
d442 2
a443 4
	error = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0, flags,
	    &dma->map);
	if (error != 0) {
		printf("%s: could not create DMA map\n", sc->sc_dev.dv_xname);
a444 1
	}
d446 3
a448 5
	error = bus_dmamem_alloc(sc->sc_dmat, size, alignment, 0, &dma->seg,
	    1, &nsegs, flags);
	if (error != 0) {
		printf("%s: could not allocate DMA memory\n",
		    sc->sc_dev.dv_xname);
a449 1
	}
d451 2
a452 4
	error = bus_dmamem_map(sc->sc_dmat, &dma->seg, 1, size, &dma->vaddr,
	    flags);
	if (error != 0) {
		printf("%s: could not map DMA memory\n", sc->sc_dev.dv_xname);
a453 1
	}
d455 2
a456 4
	error = bus_dmamap_load_raw(sc->sc_dmat, dma->map, &dma->seg, 1, size,
	    flags);
	if (error != 0) {
		printf("%s: could not load DMA memory\n", sc->sc_dev.dv_xname);
a457 1
	}
d467 1
a467 1
fail:	wpi_dma_contig_free(sc, dma);
d472 1
a472 1
wpi_dma_contig_free(struct wpi_softc *sc, struct wpi_dma_info *dma)
d476 3
a478 3
			bus_dmamap_unload(sc->sc_dmat, dma->map);
			bus_dmamem_unmap(sc->sc_dmat, dma->vaddr, dma->size);
			bus_dmamem_free(sc->sc_dmat, &dma->seg, 1);
d481 1
a481 1
		bus_dmamap_destroy(sc->sc_dmat, dma->map);
d495 3
a497 2
	error = wpi_dma_contig_alloc(sc, &sc->shared_dma, (void **)&sc->shared,
	    sizeof (struct wpi_shared), PAGE_SIZE, BUS_DMA_NOWAIT);
d508 1
a508 1
	wpi_dma_contig_free(sc, &sc->shared_dma);
a540 1
	struct wpi_rbuf *rbuf;
d544 1
a544 1
	error = wpi_dma_contig_alloc(sc, &ring->buf_dma, NULL,
d555 1
a555 1
		rbuf = &ring->rbuf[i];
d569 1
a569 1
	wpi_dma_contig_free(sc, &sc->rxq.buf_dma);
a574 2
	struct wpi_rx_data *data;
	struct wpi_rbuf *rbuf;
d579 2
a580 1
	error = wpi_dma_contig_alloc(sc, &ring->desc_dma, (void **)&ring->desc,
d593 2
a594 1
		data = &ring->data[i];
d651 1
a651 1
	wpi_dma_contig_free(sc, &ring->desc_dma);
a662 1
	struct wpi_tx_data *data;
d670 1
a670 1
	error = wpi_dma_contig_alloc(sc, &ring->desc_dma,
d682 3
a684 2
	error = wpi_dma_contig_alloc(sc, &ring->cmd_dma, (void **)&ring->cmd,
	    count * sizeof (struct wpi_tx_cmd), 4, BUS_DMA_NOWAIT);
d702 1
a702 1
		data = &ring->data[i];
a722 1
	struct wpi_tx_data *data;
d742 1
a742 1
		data = &ring->data[i];
a757 1
	struct wpi_tx_data *data;
d760 2
a761 2
	wpi_dma_contig_free(sc, &ring->desc_dma);
	wpi_dma_contig_free(sc, &ring->cmd_dma);
d765 1
a765 1
			data = &ring->data[i];
a1289 2
	struct wpi_rx_desc *desc;
	struct wpi_rx_data *data;
d1294 2
a1295 3
		data = &sc->rxq.data[sc->rxq.cur];

		desc = mtod(data->m, struct wpi_rx_desc *);
d2672 1
d2674 1
d2679 1
@


1.31
log
@Completely rework the allocation/management of Rx buffers.
The firmware expects 3KB Rx buffers so we can't just map mbuf clusters
which are only 2KB.  Also it seems that Rx buffers must be aligned on
a 1KB boundary which is not necessary the case with mbuf clusters.
We want to make damn sure the firmware will not DMA anything outside the
mapped Rx buffers.  The size of the Rx buffers is probably configurable
but Intel will refuse to answer to any question regarding the
programmation of the chipset, and a dump of the device registers led to
nowhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.30 2006/08/20 14:01:07 damien Exp $	*/
d1701 1
a1701 1
			IFQ_DEQUEUE(&ifp->if_snd, m0);
a1705 1
				IF_PREPEND(&ifp->if_snd, m0);
d1709 1
@


1.30
log
@- turn the interface down if the user press the radio kill button while
  the interface is up.
- undef WPI_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.29 2006/08/18 16:04:56 damien Exp $	*/
d98 4
d246 5
d256 1
a256 1
			goto fail1;
d263 1
a263 1
		goto fail1;
d269 1
a269 1
		goto fail2;
d275 1
a275 1
		goto fail3;
d369 3
a371 3
fail3:	wpi_free_tx_ring(sc, &sc->svcq);
fail2:	wpi_free_tx_ring(sc, &sc->cmdq);
fail1:	while (--ac >= 0)
d373 2
a374 1
	wpi_free_shared(sc);
d394 1
d473 2
a474 1
	*kvap = dma->vaddr;
a511 1

d521 62
d587 1
d602 1
a602 1
	 * Allocate Rx buffers.
a606 8
		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT, &data->map);
		if (error != 0) {
			printf("%s: could not create rx buf DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

d614 1
a614 3

		MCLGET(data->m, M_DONTWAIT);
		if (!(data->m->m_flags & M_EXT)) {
d617 1
a617 1
			printf("%s: could not allocate rx mbuf cluster\n",
d622 3
d626 1
a626 10
		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(data->m, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT |
		    BUS_DMA_READ);
		if (error != 0) {
			printf("%s: could not load rx buf DMA map\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}

		ring->desc[i] = htole32(data->map->dm_segs[0].ds_addr);
a659 1
	struct wpi_rx_data *data;
d665 2
a666 7
		data = &ring->data[i];

		if (data->m != NULL) {
			bus_dmamap_unload(sc->sc_dmat, data->map);
			m_freem(data->m);
		}
		bus_dmamap_destroy(sc->sc_dmat, data->map);
d1121 1
a1124 1
	int error;
d1159 1
a1159 13

	MCLGET(mnew, M_DONTWAIT);
	if (!(mnew->m_flags & M_EXT)) {
		m_freem(mnew);
		ifp->if_ierrors++;
		return;
	}

	bus_dmamap_unload(sc->sc_dmat, data->map);

	error = bus_dmamap_load(sc->sc_dmat, data->map, mtod(mnew, void *),
	    MCLBYTES, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
a1160 9

		/* try to reload the old mbuf */
		error = bus_dmamap_load(sc->sc_dmat, data->map,
		    mtod(data->m, void *), MCLBYTES, NULL, BUS_DMA_NOWAIT);
		if (error != 0) {
			/* very unlikely that it will fail... */
			panic("%s: could not load old rx mbuf",
			    sc->sc_dev.dv_xname);
		}
d1164 2
d1171 1
a1171 1
	ring->desc[ring->cur] = htole32(data->map->dm_segs[0].ds_addr);
a1610 1

a2130 1

@


1.29
log
@set of unrelated cosmetic tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.28 2006/08/10 09:23:32 damien Exp $	*/
a151 2
#define WPI_DEBUG

d1325 4
d1406 2
a1407 1
	WPI_WRITE(sc, WPI_MASK, WPI_INTR_MASK);
@


1.28
log
@fix a use-after-free (read) of a mbuf in wpi_tx_intr().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.27 2006/08/06 13:12:32 damien Exp $	*/
d496 2
a497 3
	error = wpi_dma_contig_alloc(sc, &sc->shared_dma,
	    (void **)&sc->shared, sizeof (struct wpi_shared), PAGE_SIZE,
	    BUS_DMA_NOWAIT);
d520 1
a520 2
	error = wpi_dma_contig_alloc(sc, &ring->desc_dma,
	    (void **)&ring->desc,
@


1.27
log
@endianness.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.26 2006/08/06 12:51:09 damien Exp $	*/
d1230 5
a1235 1

a1240 4
	if ((letoh32(stat->status) & 0xff) != 1)
		ifp->if_oerrors++;
	else
		ifp->if_opackets++;
@


1.26
log
@cosmetic tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.25 2006/08/04 14:30:03 damien Exp $	*/
d1539 1
a1539 1
			tx->timeout = 3;
d1541 1
a1541 1
			tx->timeout = 2;
d1543 1
a1543 1
		tx->timeout = 0;
@


1.25
log
@extend the set of supported 802.11a channels (100-140).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.24 2006/08/03 09:45:20 damien Exp $	*/
d1313 1
a1313 1
				printf("%s microcontroller initialization "
d1531 2
d1534 1
a1534 2
		if ((wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) ==
		    IEEE80211_FC0_SUBTYPE_PROBE_RESP)
d1537 2
a1538 4
		if (((wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) ==
		     IEEE80211_FC0_SUBTYPE_ASSOC_REQ) ||
		    ((wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) ==
		     IEEE80211_FC0_SUBTYPE_REASSOC_REQ))
@


1.24
log
@Fix 802.11a.  With these changes I can now connect my wpi(4) to
a ral(4)-based 802.11a AP.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.23 2006/08/01 13:08:21 damien Exp $	*/
d291 5
@


1.23
log
@more 802.11a bits
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.22 2006/08/01 12:43:56 damien Exp $	*/
d1548 1
a1548 1
	tx->cck_mask = 0xf;
d1799 1
a1799 1
		DPRINTF(("channel %d pwr1 0x%04x pwr2 0x%04x\n", i + 1,
d1843 1
d1863 4
a1866 1
		mrr.rates[i].next = (i == WPI_OFDM6) ? WPI_CCK2 : i - 1;
d1964 1
a1964 1
	bcn->cck_mask = 0xf;
d2012 5
a2225 2
	/* Intel's binary only daemon is a joke.. */

d2262 1
d2264 5
a2268 2
	sc->config.flags = htole32(WPI_CONFIG_TSF | WPI_CONFIG_AUTO |
	    WPI_CONFIG_24GHZ);
@


1.22
log
@- improve scan code to support scanning of 802.11a channels
- fix protection mode
- fix association to APs hiding their SSID
+ various cosmetic tweaks while i'm here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.21 2006/06/17 19:07:19 damien Exp $	*/
d1963 2
a1964 1
	bcn->rate = wpi_plcp_signal(2);
d2008 6
a2013 1
	if (ic->ic_curmode == IEEE80211_MODE_11B) {
d2016 2
a2017 4
	} else if (IEEE80211_IS_CHAN_5GHZ(ni->ni_chan)) {
		sc->config.cck_mask  = 0;
		sc->config.ofdm_mask = 0x15;
	} else {	/* assume 802.11b/g */
d2038 2
a2039 1
	node.rate = wpi_plcp_signal(2);
@


1.21
log
@Move AMRR rate control algorithm out of wpi(4) and ural(4), into net80211.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.20 2006/06/17 18:35:46 damien Exp $	*/
a74 1
#ifdef notyet
d77 1
a77 1
#endif
d139 1
a139 1
int		wpi_scan(struct wpi_softc *);
a285 1
#ifdef notyet
a299 1
#endif
d344 1
a344 1
	    sizeof (struct ieee80211_frame) + 64);
d776 1
a776 1
		if ((error = wpi_scan(sc)) != 0) {
d1340 15
a1354 1
			DPRINTF(("scan finished\n"));
d1358 1
d1387 1
d1509 2
a1510 1
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1))
d1512 9
a1520 3
	else if (m0->m_pkthdr.len + IEEE80211_CRC_LEN > ic->ic_rtsthreshold ||
	    ((ic->ic_flags & IEEE80211_F_USEPROT) && WPI_RATE_IS_OFDM(rate)))
		tx->flags |= htole32(WPI_TX_NEED_RTS | WPI_TX_FULL_TXOP);
a1523 4
	/* retrieve destination node's id */
	tx->id = IEEE80211_IS_MULTICAST(wh->i_addr1) ? WPI_ID_BROADCAST :
	    WPI_ID_BSS;

d2055 1
a2055 1
wpi_scan(struct wpi_softc *sc)
a2064 1
	struct ieee80211_node *ni = ic->ic_bss;
d2066 1
d2069 1
a2069 1
	int i, pktlen, error;
d2099 17
a2115 6
	hdr->nchan = 14;
	hdr->len = hdr->nchan * sizeof (struct wpi_scan_chan);
	hdr->quiet = htole16(5);
	hdr->threshold = htole16(1);
	hdr->filter = htole32(5);	/* XXX */
	hdr->rate = wpi_plcp_signal(2);
d2118 4
a2121 2
	hdr->esslen = ni->ni_esslen;
	bcopy(ni->ni_essid, hdr->essid, ni->ni_esslen);
d2140 1
a2140 1
	frm = ieee80211_add_ssid(frm, ni->ni_essid, ni->ni_esslen);
a2153 1
	/* XXX: align on a 4-byte boundary? */
d2155 8
a2162 3
	for (i = 1; i <= hdr->nchan; i++, chan++) {
		chan->flags = 3;
		chan->chan = i;
d2164 9
a2172 2
		chan->active = htole16(20);
		chan->passive = htole16(120);
d2177 1
d2180 2
a2181 2
	error = bus_dmamap_load(sc->sc_dmat, data->map, cmd, pktlen,
	    NULL, BUS_DMA_NOWAIT);
d2537 1
@


1.20
log
@- re-enable AMRR
- unmap the good buffer in wpi_tx_intr
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.19 2006/06/16 18:54:09 damien Exp $	*/
d61 1
a106 2
void		wpi_node_copy(struct ieee80211com *, struct ieee80211_node *,
		    const struct ieee80211_node *);
d123 1
a123 2
void		wpi_tx_intr(struct wpi_softc *, struct wpi_rx_desc *,
		    struct wpi_rx_data *);
d148 1
a148 3

/* rate control algorithm: should be moved to net80211 */
void		wpi_amrr_init(struct wpi_amrr *);
d150 2
a151 1
void		wpi_amrr_ratectl(void *, struct ieee80211_node *);
d332 1
a332 1
	ic->ic_node_copy = wpi_node_copy;
d339 2
a738 1
/* ARGSUSED */
d742 1
a742 1
	struct wpi_amrr *amrr;
d744 4
a747 14
	amrr = malloc(sizeof (struct wpi_amrr), M_DEVBUF, M_NOWAIT);
	if (amrr != NULL) {
		bzero(amrr, sizeof (struct wpi_amrr));
		wpi_amrr_init(amrr);
	}
	return (struct ieee80211_node *)amrr;
}

void
wpi_node_copy(struct ieee80211com *ic, struct ieee80211_node *dst,
    const struct ieee80211_node *src)
{
	*dst = *src;
	wpi_amrr_init((struct wpi_amrr *)dst);
d829 5
d1203 1
a1203 2
wpi_tx_intr(struct wpi_softc *sc, struct wpi_rx_desc *desc,
    struct wpi_rx_data *data)
d1208 1
a1208 1
	struct wpi_tx_data *txdata = &ring->data[desc->idx];
d1210 1
a1210 1
	struct wpi_amrr *amrr = (struct wpi_amrr *)txdata->ni;
d1222 1
a1222 1
	amrr->txcnt++;
d1225 1
a1225 1
		amrr->retrycnt++;
d1228 1
a1228 1
	bus_dmamap_unload(sc->sc_dmat, txdata->map);
d1230 4
a1233 4
	m_freem(txdata->m);
	txdata->m = NULL;
	ieee80211_release_node(ic, txdata->ni);
	txdata->ni = NULL;
d1297 1
a1297 1
			wpi_tx_intr(sc, desc, data);
d1985 1
a1985 1
	struct wpi_node node;
d2168 1
a2168 1
	struct wpi_node node;
a2579 28
/*-
 * Naive implementation of the Adaptive Multi Rate Retry algorithm:
 *     "IEEE 802.11 Rate Adaptation: A Practical Approach"
 *     Mathieu Lacage, Hossein Manshaei, Thierry Turletti
 *     INRIA Sophia - Projet Planete
 *     http://www-sop.inria.fr/rapports/sophia/RR-5208.html
 */
#define is_success(amrr)	\
	((amrr)->retrycnt < (amrr)->txcnt / 10)
#define is_failure(amrr)	\
	((amrr)->retrycnt > (amrr)->txcnt / 3)
#define is_enough(amrr)		\
	((amrr)->txcnt > 10)
#define is_min_rate(ni)		\
	((ni)->ni_txrate == 0)
#define is_max_rate(ni)		\
	((ni)->ni_txrate == (ni)->ni_rates.rs_nrates - 1)
#define increase_rate(ni)	\
	((ni)->ni_txrate++)
#define decrease_rate(ni)	\
	((ni)->ni_txrate--)
#define reset_cnt(amrr)		\
	do { (amrr)->txcnt = (amrr)->retrycnt = 0; } while (0)

#define WPI_AMRR_MIN_SUCCESS_THRESHOLD	 1
#define WPI_AMRR_MAX_SUCCESS_THRESHOLD	15

/* XXX should reset all nodes on S_INIT */
d2581 1
a2581 1
wpi_amrr_init(struct wpi_amrr *amrr)
d2583 2
a2584 2
	struct ieee80211_node *ni = &amrr->ni;
	int i;
d2586 1
a2586 12
	amrr->success = 0;
	amrr->recovery = 0;
	amrr->txcnt = amrr->retrycnt = 0;
	amrr->success_threshold = WPI_AMRR_MIN_SUCCESS_THRESHOLD;

	/* set rate to some reasonable initial value */
	ni = &amrr->ni;
	for (i = ni->ni_rates.rs_nrates - 1;
	     i > 0 && (ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL) > 72;
	     i--);

	ni->ni_txrate = i;
d2596 1
a2596 1
		wpi_amrr_ratectl(NULL, ic->ic_bss);
d2598 1
a2598 1
		ieee80211_iterate_nodes(ic, wpi_amrr_ratectl, NULL);
a2602 1
/* ARGSUSED */
d2604 1
a2604 1
wpi_amrr_ratectl(void *arg, struct ieee80211_node *ni)
d2606 2
a2607 2
	struct wpi_amrr *amrr = (struct wpi_amrr *)ni;
	int need_change = 0;
d2609 1
a2609 35
	if (is_success(amrr) && is_enough(amrr)) {
		amrr->success++;
		if (amrr->success >= amrr->success_threshold &&
		    !is_max_rate(ni)) {
			amrr->recovery = 1;
			amrr->success = 0;
			increase_rate(ni);
			DPRINTFN(2, ("AMRR increasing rate %d (txcnt=%d "
			    "retrycnt=%d)\n", ni->ni_txrate, amrr->txcnt,
			    amrr->retrycnt));
			need_change = 1;
		} else {
			amrr->recovery = 0;
		}
	} else if (is_failure(amrr)) {
		amrr->success = 0;
		if (!is_min_rate(ni)) {
			if (amrr->recovery) {
				amrr->success_threshold *= 2;
				if (amrr->success_threshold >
				    WPI_AMRR_MAX_SUCCESS_THRESHOLD)
					amrr->success_threshold =
					    WPI_AMRR_MAX_SUCCESS_THRESHOLD;
			} else {
				amrr->success_threshold =
				    WPI_AMRR_MIN_SUCCESS_THRESHOLD;
			}
			decrease_rate(ni);
			DPRINTFN(2, ("AMRR decreasing rate %d (txcnt=%d "
			    "retrycnt=%d)\n", ni->ni_txrate, amrr->txcnt,
			    amrr->retrycnt));
			need_change = 1;
		}
		amrr->recovery = 0;	/* paper is incorrect */
	}
d2611 5
a2615 2
	if (is_enough(amrr) || need_change)
		reset_cnt(amrr);
@


1.19
log
@- fix reassociations (the firmware was crashing because the configuration
  was not properly reset) -- tested by Jean-Baptiste Campesato
- load the firmware block by block to avoid allocating a large amount of
  contiguous memory, which may not be possible at the time the interface
  is turned up.
- rename WPI_CONFIG_ASSOCIATED into WPI_STATE_ASSOCIATED
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.18 2006/06/14 19:31:47 damien Exp $	*/
d842 1
a842 1
		if (ic->ic_fixed_rate != -1)
d1236 1
a1236 1
	bus_dmamap_unload(sc->sc_dmat, data->map);
@


1.18
log
@must use RTS/CTS protection when sending frames at OFDM rates in a BSS
with non-ERP STAs.  some bits are missing in net80211 though, so this
code won't be triggered yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.17 2006/06/14 18:40:23 brad Exp $	*/
d118 2
d800 4
d821 1
a821 1
		sc->config.state = htole16(WPI_CONFIG_ASSOCIATED);
a969 6
/*
 * The firmware text and data segments are transferred to the NIC using DMA.
 * The driver just copies the firmware into DMA-safe memory and tells the NIC
 * where to find it.  Once the NIC has copied the firmware into its internal
 * memory, we can free our local copy in the driver.
 */
d971 2
a972 2
wpi_load_firmware(struct wpi_softc *sc, uint32_t target, const char *fw,
    int size)
a973 3
	bus_dmamap_t map;
	bus_dma_segment_t seg;
	caddr_t virtaddr;
d975 1
a975 20
	int i, ntries, nsegs, error;

	/*
	 * Allocate DMA-safe memory to store the firmware.
	 */
	error = bus_dmamap_create(sc->sc_dmat, size, WPI_MAX_SCATTER,
	    WPI_MAX_SEG_LEN, 0, BUS_DMA_NOWAIT, &map);
	if (error != 0) {
		printf("%s: could not create firmware DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail1;
	}

	error = bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE, 0, &seg, 1,
	    &nsegs, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not allocate firmware DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail2;
	}
d977 2
a978 21
	error = bus_dmamem_map(sc->sc_dmat, &seg, nsegs, size, &virtaddr,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not map firmware DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail3;
	}

	error = bus_dmamap_load(sc->sc_dmat, map, virtaddr, size, NULL,
	    BUS_DMA_NOWAIT | BUS_DMA_WRITE);
	if (error != 0) {
		printf("%s: could not load firmware DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail4;
	}

	/* copy firmware image to DMA-safe memory */
	bcopy(fw, virtaddr, size);

	/* make sure the adapter will get up-to-date values */
	bus_dmamap_sync(sc->sc_dmat, map, 0, size, BUS_DMASYNC_PREWRITE);
d981 3
a983 7
	desc.flags = htole32(WPI_PAD32(size) << 28 | map->dm_nsegs << 24);
	for (i = 0; i < map->dm_nsegs; i++) {
		desc.segs[i].addr = htole32(map->dm_segs[i].ds_addr);
		desc.segs[i].len  = htole32(map->dm_segs[i].ds_len);
	}

	wpi_mem_lock(sc);
d985 1
a985 1
	/* tell adapter where to copy image in its internal memory */
d990 1
a990 1
	/* copy firmware descriptor into NIC memory */
d998 1
a998 1
	/* wait while the adapter is busy copying the firmware */
d1005 1
a1005 1
		printf("%s: timeout transferring firmware\n",
d1012 48
a1063 2
fail4:	bus_dmamem_unmap(sc->sc_dmat, virtaddr, size);
fail3:	bus_dmamem_free(sc->sc_dmat, &seg, 1);
d1105 2
a1106 1
		DPRINTF(("rx tail flags error %x\n", letoh32(tail->flags)));
@


1.17
log
@clear the IFF_UP interface flag before shutting down the interface.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.16 2006/06/10 20:34:45 damien Exp $	*/
d1425 3
d1504 2
a1505 1
	else if (m0->m_pkthdr.len + IEEE80211_CRC_LEN > ic->ic_rtsthreshold)
@


1.16
log
@endianness
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.15 2006/06/05 16:42:21 damien Exp $	*/
d367 1
a367 1
wpi_detach(struct device* self, int flags)
d1693 1
@


1.15
log
@- discard Rx frames with a bad CRC early
- don't start AMRR if we have set a fixed rate
- fix TSF synchronization
- remove a x2 prototype + ;; (pointed out by Jean-Baptiste Campesato)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.14 2006/05/29 20:26:54 miod Exp $	*/
d738 1
d1898 1
a1898 1
	val = (uint64_t)tsf.bintval * 1024;	/* msecs -> usecs */
a2005 1

@


1.14
log
@Do not cast a bus_addr_t back in to a pointer as these types may not be
compatible; plus this makes a computation clearer. ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.13 2006/05/25 09:26:58 damien Exp $	*/
a150 1
void		wpi_amrr_init(struct wpi_amrr *);
d822 1
a822 1
		sc->config.filter |= htole32(WPI_FILTER_BSSID);
d835 2
a836 1
		timeout_add(&sc->amrr_ch, hz / 2);
d1098 10
d1222 5
a1226 1
	/* update rate control statistics for the node */
d1507 1
a1507 1
	    WPI_ID_BSSID;
d1533 1
a1533 1
	tx->cck_mask = 0xf;;
d1889 1
a1893 1
	tsf.binitval = htole32(102400);	/* XXX */
d1896 8
d2018 1
a2018 1
	node.id = WPI_ID_BSSID;
d2608 1
@


1.13
log
@automatic rate control (AMRR) + cosmetic and small fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.12 2006/05/20 15:46:55 damien Exp $	*/
d2383 2
a2384 2
	WPI_WRITE(sc, WPI_RX_RIDX_PTR,
	    (uint32_t)&((struct wpi_shared *)sc->shared_dma.paddr)->next);
@


1.12
log
@more radiotap.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.11 2006/05/20 15:31:30 damien Exp $	*/
d84 2
a85 2
static const uint8_t wpi_ridx_to_rate[] = {
	0xd, 0xf, 0x5, 0x7, 0x9, 0xb, 0x1, 0x3,	/* OFDM */
d105 3
d128 1
d149 6
a230 1

d333 3
d341 2
d402 1
d412 1
d419 1
d739 21
d782 2
d816 7
d825 2
d835 3
d856 1
a856 1
        uint32_t tmp;
d965 1
a965 1
 * The driver just copies the firmware into DMA'able memory and tells the NIC
d980 1
a980 1
	 * Allocate DMA'able memory to store the firmware.
d1014 1
a1014 1
	/* copy firmware image to DMA'able memory */
d1023 2
a1024 2
		desc.segs[i].physaddr = htole32(map->dm_segs[i].ds_addr);
		desc.segs[i].len = htole32(map->dm_segs[i].ds_len);
d1152 1
a1152 1
		tap->wr_dbm_antnoise = (int8_t)stat->noise;
d1169 1
a1169 1
		case 0x3: tap->wr_rate = 109; break;
d1205 1
d1212 7
d1255 1
a1255 1
	wakeup(&sc->cmdq.cmd[desc->idx]);
d1344 1
a1344 1
	WPI_WRITE(sc, WPI_RX_WIDX, hw & ~0x7);
d1384 26
d1423 1
a1423 1
	int i, error;
a1426 1
	cmd = &ring->cmd[ring->cur];
d1439 14
d1459 3
a1461 3
		tap->wt_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
		tap->wt_rate = 2;	/* 1Mb/s */
d1475 1
d1487 1
a1487 1
		tx->flags |= htole32(WPI_TX_NEED_RTS);
a1490 6
	/* tell h/w to set timestamp in probe responses */
	if ((wh->i_fc[0] &
	    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==
	    (IEEE80211_FC0_TYPE_MGT | IEEE80211_FC0_SUBTYPE_PROBE_RESP))
		tx->flags |= htole32(WPI_TX_INSERT_TSTAMP);

d1495 7
a1501 1
	if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_MGT) {
d1506 1
a1506 1
			tx->duration = 3;
d1508 1
a1508 1
			tx->duration = 2;
d1510 1
a1510 1
		tx->duration = 0;
d1512 1
a1512 1
	tx->rate = 10;	/* 1Mb/s */
d1518 2
a1519 2
	tx->ofdm_mask = sc->config.ofdm_mask;
	tx->cck_mask = sc->config.cck_mask;
d1579 1
a1579 1
	desc->segs[0].physaddr = htole32(ring->cmd_dma.paddr +
d1581 1
a1581 1
	desc->segs[0].len = htole32(4 + sizeof (struct wpi_cmd_data));
d1583 1
a1583 1
		desc->segs[i].physaddr =
d1585 1
a1585 1
		desc->segs[i].len =
d1787 1
a1787 1
	cmd = &ring->cmd[ring->cur]; 
d1796 1
a1796 1
	desc->segs[0].physaddr = htole32(ring->cmd_dma.paddr +
d1798 1
a1798 1
	desc->segs[0].len = htole32(4 + size);
d1819 1
a1819 1
		mrr.rates[i].plcp = wpi_ridx_to_rate[i];
d1829 4
a1832 3
		mrr.rates[i].plcp = wpi_ridx_to_rate[i];
		/* fallback to the immediate lower OFDM rate (if any) */
		mrr.rates[i].next = (i == WPI_OFDM6) ? WPI_OFDM6 : i - 1;
d1921 2
d1925 1
a1925 1
	bcn->rate = 10;	/* 1Mb/s */
d1945 1
a1945 1
	desc->segs[0].physaddr = htole32(ring->cmd_dma.paddr +
d1947 3
a1949 3
	desc->segs[0].len = htole32(4 + sizeof (struct wpi_cmd_beacon));
	desc->segs[1].physaddr = htole32(data->map->dm_segs[0].ds_addr);
	desc->segs[1].len = htole32(data->map->dm_segs[0].ds_len);
d1997 1
a1997 1
	node.rate = 10;	/* 1Mb/s */
d2067 1
a2067 1
	hdr->rate = 10;	/* 1Mb/s */
d2075 1
a2075 2
	 * copy & paste of what is done in net80211.  Unfortunately, the
	 * functions to add IEs are static and thus can't be reused here.
d2129 2
a2130 2
	desc->segs[0].physaddr = htole32(data->map->dm_segs[0].ds_addr);
	desc->segs[0].len = htole32(data->map->dm_segs[0].ds_len);
d2143 1
d2186 1
d2223 1
a2223 1
	node.rate = 10;	/* 1Mb/s */
d2368 1
a2368 1
	wpi_reset(sc);
d2377 1
a2377 1
	wpi_power_up(sc);
d2557 108
@


1.11
log
@more rx radiotap stats
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.10 2006/05/20 13:24:02 damien Exp $	*/
d1362 4
@


1.10
log
@- fix monitor mode
- cosmetic in wpi_dma_contig_alloc()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.9 2006/05/20 12:44:47 damien Exp $	*/
d1099 24
a1122 1
		tap->wr_antsignal = stat->signal;
a1151 1
#ifdef WPI_DEBUG
d1153 1
a1153 1
#endif
d1873 1
a1873 1
		sc->config.flags |= htole32(WPI_CONFIG_SHORT_SLOT);
@


1.9
log
@- fix CCK mask for 802.11b/only
- add beacon command for future IBSS or HostAP mode support
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.8 2006/05/20 11:47:29 damien Exp $	*/
d413 2
a414 2
	error = bus_dmamap_create(sc->sc_dmat, dma->size, 1, dma->size, 0,
	    flags, &dma->map);
d420 2
a421 2
	error = bus_dmamem_alloc(sc->sc_dmat, dma->size, alignment, 0,
	    &dma->seg, 1, &nsegs, flags);
d428 2
a429 2
	error = bus_dmamem_map(sc->sc_dmat, &dma->seg, 1, dma->size,
	    &dma->vaddr, flags);
d435 2
a436 2
	error = bus_dmamap_load_raw(sc->sc_dmat, dma->map, &dma->seg, 1,
	    dma->size, flags);
d442 1
a442 1
	bzero(dma->vaddr, dma->size);
d766 6
d1360 2
a1370 4
#ifdef notyet
	tx->flags |= htole32(WPI_TX_NEED_RTS);
#endif

d2059 21
a2079 4
	sc->config.mode = WPI_MODE_STA;
	sc->config.flags =
	    htole32(WPI_CONFIG_TSF | WPI_CONFIG_AUTO | WPI_CONFIG_24GHZ);
	sc->config.filter = htole32(WPI_FILTER_MULTICAST);
@


1.8
log
@- fix short slot time and short preamble settings
- fix basic rates setting
- fix check for WEP encryption (authreq frames might require encryption
  in shared mode)
- cleanup a few things while i'm here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.7 2006/05/19 18:44:56 damien Exp $	*/
d134 1
d1755 70
d1837 1
a1837 1
		sc->config.cck_mask  = 0x0f;
d1851 2
a1852 2
	DPRINTF(("config chan %d flags %x\n", sc->config.chan,
	    sc->config.flags));
@


1.7
log
@read channels calibration settings from EEPROM only once in wpi_attach()
instead of doing it in wpi_init().
remove a double definition of wpi_ioctl() while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.6 2006/05/19 18:28:23 damien Exp $	*/
d20 2
a21 3
/*-
 * Intel(R) PRO/Wireless 3945ABG driver
 * http://www.intel.com/network/connectivity/products/wireless/prowireless_mobile.htm
d273 1
d1316 1
a1316 3
	if ((ic->ic_flags & IEEE80211_F_WEPON) &&
	    (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	    IEEE80211_FC0_TYPE_DATA) {
d1356 1
a1356 1
	/* tell h/w to add timestamp in probe responses */
d1613 3
d1634 1
a1634 1
	/* read channels power settings for 2GHz channels */
d1636 4
a1639 4
		sc->calib1[i] = wpi_read_prom_word(sc, WPI_EEPROM_CALIB1 + i);
		sc->calib2[i] = wpi_read_prom_word(sc, WPI_EEPROM_CALIB2 + i);
		DPRINTF(("channel %d calib1 0x%04x calib2 0x%04x\n", i + 1,
		    sc->calib1[i], sc->calib2[i]));
d1745 1
a1745 1
	tsf.tstamp = 0;
a1763 2
	sc->config.cck_mask  = 0x0f;	/* XXX */
	sc->config.ofdm_mask = 0x15;	/* XXX */
d1765 14
a1778 1
	sc->config.flags |= htole32(WPI_CONFIG_SHORT_SLOT);
d1780 2
d1950 2
a1951 2
	bcopy(sc->calib1, txpower.calib1, 14 * sizeof (uint16_t));
	bcopy(sc->calib2, txpower.calib2, 14 * sizeof (uint16_t));
d2187 1
a2187 1
	/* clear radio off and disable command bits (reversed logic) */
@


1.6
log
@don't leak a mbuf with each scan command
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.5 2006/05/19 18:24:08 damien Exp $	*/
d125 1
a125 1
int		wpi_ioctl(struct ifnet *, u_long, caddr_t);
a181 1
	uint16_t val;
d276 1
a276 11
	/* read MAC address from EEPROM */
	val = wpi_read_prom_word(sc, WPI_EEPROM_MAC + 0);
	ic->ic_myaddr[0] = val & 0xff;
	ic->ic_myaddr[1] = val >> 8;
	val = wpi_read_prom_word(sc, WPI_EEPROM_MAC + 1);
	ic->ic_myaddr[2] = val & 0xff;
	ic->ic_myaddr[3] = val >> 8;
	val = wpi_read_prom_word(sc, WPI_EEPROM_MAC + 2);
	ic->ic_myaddr[4] = val & 0xff;
	ic->ic_myaddr[5] = val >> 8;

d1615 27
d2130 1
a2130 1
	int i, qid, ntries, error;
a2180 8

	/* read channels power settings before firmware locks EEPROM */
	for (i = 0; i < 14; i++) {
		sc->calib1[i] = wpi_read_prom_word(sc, WPI_EEPROM_CALIB1 + i);
		sc->calib2[i] = wpi_read_prom_word(sc, WPI_EEPROM_CALIB2 + i);
		DPRINTF(("channel %d calib1 0x%04x calib2 0x%04x\n", i + 1,
		    sc->calib1[i], sc->calib2[i]));
	}
@


1.5
log
@simplify finalization of mbuf in wpi_rx_intr()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.4 2006/05/19 18:14:35 damien Exp $	*/
d1162 3
d1167 9
@


1.4
log
@use ieee80211_add_ssid() in ieee80211_beacon_alloc() and wpi(4) instead
of duplicating the code.

last commit was ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.3 2006/05/17 19:50:35 damien Exp $	*/
d1090 2
a1091 10
	m->m_pkthdr.len = m->m_len =
	    sizeof (struct wpi_rx_desc) +
	    sizeof (struct wpi_rx_stat) + stat->len +
	    sizeof (struct wpi_rx_head) + letoh16(head->len) +
	    sizeof (struct wpi_rx_tail);

	/* remove head + tail */
	m_adj(m, sizeof (struct wpi_rx_desc) + sizeof (struct wpi_rx_stat) +
	    stat->len + sizeof (struct wpi_rx_head));
	m_adj(m, -sizeof (struct wpi_rx_tail));
@


1.3
log
@mega-commit of unrelated changes:

- factor out contiguous DMA allocations (the same code was duplicated
  in several places and was sometimes incorrect)
- s/EIO/ETIMEDOUT where it makes sense
- s/memset/bzero/g
- don't always bzero the ring descriptors
- scan channels 1-14 instead of 1-13
- remove the auhmode stuff since mgt frames are sent by net80211
- remove the SCANALL flag since the f/w notifies us when it switches
  to another channel
- don't re-enable interrupts on f/w panics
- KASSERT that commands fit in a descriptor
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1853 1
a1853 5
	/* frm = ieee80211_add_ssid(frm, ni->ni_essid, ni->ni_esslen);*/
	*frm++ = IEEE80211_ELEMID_SSID;
	*frm++ = ni->ni_esslen;
	bcopy(ni->ni_essid, frm, ni->ni_esslen);
	frm += ni->ni_esslen;
@


1.2
log
@Fix tsleep wait channel name; ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wpi.c,v 1.1 2006/05/14 19:00:48 damien Exp $	*/
d94 3
a271 1
	    IEEE80211_C_SCANALL |	/* h/w scan */
a414 3
/*
 * Allocate a shared page between host and NIC.
 */
d416 2
a417 1
wpi_alloc_shared(struct wpi_softc *sc)
d421 4
a424 2
	error = bus_dmamap_create(sc->sc_dmat, sizeof (struct wpi_shared), 1,
	    sizeof (struct wpi_shared), 0, BUS_DMA_NOWAIT, &sc->shmap);
d426 1
a426 2
		printf("%s: could not create shared area DMA map\n",
		    sc->sc_dev.dv_xname);
d430 2
a431 3
	/* must be aligned on a 4K-page boundary */
	error = bus_dmamem_alloc(sc->sc_dmat, sizeof (struct wpi_shared),
	    PAGE_SIZE, 0, &sc->shseg, 1, &nsegs, BUS_DMA_NOWAIT);
d433 1
a433 1
		printf("%s: could not allocate shared area DMA memory\n",
d438 2
a439 3
	error = bus_dmamem_map(sc->sc_dmat, &sc->shseg, nsegs,
	    sizeof (struct wpi_shared), (caddr_t *)&sc->shared,
	    BUS_DMA_NOWAIT);
d441 1
a441 2
		printf("%s: could not map shared area DMA memory\n",
		    sc->sc_dev.dv_xname);
d445 2
a446 2
	error = bus_dmamap_load(sc->sc_dmat, sc->shmap, sc->shared,
	    sizeof (struct wpi_shared), NULL, BUS_DMA_NOWAIT);
d448 1
a448 2
		printf("%s: could not load shared area DMA map\n",
		    sc->sc_dev.dv_xname);
d452 4
a455 1
	bzero(sc->shared, sizeof (struct wpi_shared));
d459 36
a494 1
fail:	wpi_free_shared(sc);
d501 1
a501 8
	if (sc->shared != NULL) {
		bus_dmamap_unload(sc->sc_dmat, sc->shmap);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->shared,
		    sizeof (struct wpi_shared));
		bus_dmamem_free(sc->sc_dmat, &sc->shseg, 1);
	}
	if (sc->shmap != NULL)
		bus_dmamap_destroy(sc->sc_dmat, sc->shmap);
d508 1
a508 1
	int i, nsegs, error;
d512 2
a513 11
	error = bus_dmamap_create(sc->sc_dmat,
	    WPI_RX_RING_COUNT * sizeof (struct wpi_rx_desc), 1,
	    WPI_RX_RING_COUNT * sizeof (struct wpi_rx_desc), 0, BUS_DMA_NOWAIT,
	    &ring->map);
	if (error != 0) {
		printf("%s: could not create rx ring DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat,
d515 1
a515 1
	    WPI_RING_DMA_ALIGN, 0, &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT);
a521 20
	error = bus_dmamem_map(sc->sc_dmat, &ring->seg, nsegs,
	    WPI_RX_RING_COUNT * sizeof (struct wpi_rx_desc),
	    (caddr_t *)&ring->desc, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not map rx ring DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, ring->map, ring->desc,
	    WPI_RX_RING_COUNT * sizeof (struct wpi_rx_desc), NULL,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load rx ring DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	bzero(ring->desc, WPI_RX_RING_COUNT * sizeof (struct wpi_rx_desc));

d600 1
a600 8
	if (ring->desc != NULL) {
		bus_dmamap_unload(sc->sc_dmat, ring->map);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)ring->desc,
		    WPI_RX_RING_COUNT * sizeof (struct wpi_rx_desc));
		bus_dmamem_free(sc->sc_dmat, &ring->seg, 1);
	}
	if (ring->map != NULL)
		bus_dmamap_destroy(sc->sc_dmat, ring->map);
d618 1
a618 1
	int i, nsegs, error;
d625 3
a627 13
	error = bus_dmamap_create(sc->sc_dmat,
	    count * sizeof (struct wpi_tx_desc), 1,
	    count * sizeof (struct wpi_tx_desc), 0, BUS_DMA_NOWAIT,
	    &ring->map);
	if (error != 0) {
		printf("%s: could not create tx ring DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat,
	    count * sizeof (struct wpi_tx_desc), WPI_RING_DMA_ALIGN, 0,
	    &ring->seg, 1, &nsegs, BUS_DMA_NOWAIT);
a633 19
	error = bus_dmamem_map(sc->sc_dmat, &ring->seg, nsegs,
	    count * sizeof (struct wpi_tx_desc), (caddr_t *)&ring->desc,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not map tx ring DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, ring->map, ring->desc,
	    count * sizeof (struct wpi_tx_desc), NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load tx ring DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	bzero(ring->desc, count * sizeof (struct wpi_tx_desc));

d635 1
a635 1
	sc->shared->txbase[qid] = htole32(ring->map->dm_segs[0].ds_addr);
d637 2
a638 13
	error = bus_dmamap_create(sc->sc_dmat,
	    count * sizeof (struct wpi_tx_cmd), 1,
	    count * sizeof (struct wpi_tx_cmd), 0, BUS_DMA_NOWAIT,
	    &ring->cmd_map);
	if (error != 0) {
		printf("%s: could not create tx cmd DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamem_alloc(sc->sc_dmat,
	    count * sizeof (struct wpi_tx_cmd), PAGE_SIZE, 0, &ring->cmd_seg,
	    1, &nsegs, BUS_DMA_NOWAIT);
a644 19
	error = bus_dmamem_map(sc->sc_dmat, &ring->cmd_seg, nsegs,
	    count * sizeof (struct wpi_tx_cmd), (caddr_t *)&ring->cmd,
	    BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not map tx cmd DMA memory\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = bus_dmamap_load(sc->sc_dmat, ring->cmd_map, ring->cmd,
	    count * sizeof (struct wpi_tx_cmd), NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: could not load tx ring DMA map\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	bzero(ring->cmd, count * sizeof (struct wpi_tx_cmd));

d716 2
a717 17
	if (ring->desc != NULL) {
		bus_dmamap_unload(sc->sc_dmat, ring->map);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)ring->desc,
		    WPI_RX_RING_COUNT * sizeof (struct wpi_rx_desc));
		bus_dmamem_free(sc->sc_dmat, &ring->seg, 1);
	}
	if (ring->map != NULL)
		bus_dmamap_destroy(sc->sc_dmat, ring->map);

	if (ring->cmd != NULL) {
		bus_dmamap_unload(sc->sc_dmat, ring->cmd_map);
		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)ring->cmd,
		    ring->count * sizeof (struct wpi_tx_cmd));
		bus_dmamem_free(sc->sc_dmat, &ring->cmd_seg, 1);
	}
	if (ring->cmd_map != NULL)
		bus_dmamap_destroy(sc->sc_dmat, ring->cmd_map);
d857 4
d1003 1
a1003 1
		error = EIO;
d1046 1
a1046 1
	    "chan=%d tstamp=%lld\n", ring->cur, letoh32(desc->len),
d1156 4
a1159 1
	ifp->if_opackets++;
d1233 1
d1246 3
d1287 1
a1287 1
		r = 0;	/* don't process any other interrupt */
d1455 3
a1457 2
	memset(desc, 0, sizeof (struct wpi_tx_desc));
	desc->segs[0].physaddr = htole32(ring->cmd_map->dm_segs[0].ds_addr +
d1459 1
a1459 2
	desc->segs[0].len = htole32(
	    (4 + sizeof (struct wpi_cmd_data) + 3) & ~3);
a1465 2
	desc->flags = htole32(WPI_PAD32(m0->m_pkthdr.len) << 28 |
	    (1 + data->map->dm_nsegs) << 24);
a1606 12
	case SIOCG80211AUTH:
		((struct ieee80211_auth *)data)->i_authtype = sc->authmode;
		break;

	case SIOCS80211AUTH:
		/* only super-user can do that! */
		if ((error = suser(curproc, 0)) != 0)
			break;

		sc->authmode = ((struct ieee80211_auth *)data)->i_authtype;
		break;

d1632 2
a1642 1
	bzero(desc, sizeof (struct wpi_tx_desc));
d1644 1
a1644 1
	desc->segs[0].physaddr = htole32(ring->cmd_map->dm_segs[0].ds_addr +
d1723 1
a1723 1
	memset(&tsf, 0, sizeof tsf);
d1756 1
a1756 1
	memset(&node, 0, sizeof node);
d1822 1
a1822 1
	memset(hdr, 0, sizeof (struct wpi_scan_hdr));
d1824 1
a1824 1
	hdr->nchan = 13;
a2113 1
	bus_addr_t pshared;
a2127 2
	pshared = sc->shmap->dm_segs[0].ds_addr;

d2130 1
a2130 1
	WPI_WRITE(sc, WPI_RX_BASE, sc->rxq.map->dm_segs[0].ds_addr);
d2132 1
a2132 1
	    (uint32_t)&((struct wpi_shared *)pshared)->next);
d2147 1
a2147 1
	WPI_WRITE(sc, WPI_TX_BASE_PTR, pshared);
d2245 1
a2245 1
		error = EIO;
@


1.1
log
@Initial import of wpi(4), a blob-free driver for Intel PRO/Wireless 3945ABG
802.11 adapters as found in Centrino Duo laptops.
More to come but works well enough for me to commit this over a wpi(4).

go for it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1736 1
a1736 1
	return async ? 0 : tsleep(cmd, PCATCH, "iwicmd", hz);
@

