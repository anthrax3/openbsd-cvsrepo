head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.10
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.8
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.8
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.10
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.8
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.4
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.16.0.4
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.8
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.6
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.14
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.12
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.10
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.8
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	SMP:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2;
locks; strict;
comment	@ * @;


1.20
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.19;
commitid	p4LJxGKbi0BU2cG6;

1.19
date	2014.01.18.22.33.59;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.30.00.35.40;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.20.16.06.32;	author martin;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.18.19.52.09;	author martin;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.14.09.31.52;	author martin;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.09.04.10.13;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.05.17.25.58;	author art;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.09.27.04.01.42;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.26.03.32.22;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.25.14.52.57;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.25.10.13.30;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.12.15.40.33;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.14.06.37.01;	author fgsch;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2001.02.14.05.10.18;	author fgsch;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.14.22.25.56;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.07.04.10.43.01;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2001.10.31.03.22.47;	author nate;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2001.11.13.21.10.03;	author niklas;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2002.03.28.15.35.59;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2002.06.11.03.42.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: pcscp.c,v 1.19 2014/01/18 22:33:59 dlg Exp $	*/
/*	$NetBSD: pcscp.c,v 1.26 2003/10/19 10:25:42 tsutsui Exp $	*/

/*-
 * Copyright (c) 1997, 1998, 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center; Izumi Tsutsui.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * pcscp.c: device dependent code for AMD Am53c974 (PCscsi-PCI)
 * written by Izumi Tsutsui <tsutsui@@ceres.dti.ne.jp>
 *
 * Technical manual available at
 * http://www.amd.com/files/connectivitysolutions/networking/archivednetworking/19113.pdf
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/buf.h>

#include <machine/bus.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_message.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/ic/ncr53c9xreg.h>
#include <dev/ic/ncr53c9xvar.h>

#include <dev/pci/pcscpreg.h>

#define IO_MAP_REG	0x10

struct pcscp_softc {
	struct ncr53c9x_softc sc_ncr53c9x;	/* glue to MI code */

	bus_space_tag_t sc_st;		/* bus space tag */
	bus_space_handle_t sc_sh;	/* bus space handle */
	void *sc_ih;			/* interrupt cookie */

	bus_dma_tag_t sc_dmat;		/* DMA tag */

	bus_dmamap_t sc_xfermap;	/* DMA map for transfers */

	u_int32_t *sc_mdladdr;		/* MDL array */
	bus_dmamap_t sc_mdldmap;	/* MDL DMA map */

	int	sc_active;		/* DMA state */
	int	sc_datain;		/* DMA Data Direction */
	size_t	sc_dmasize;		/* DMA size */
	char	**sc_dmaaddr;		/* DMA address */
	size_t	*sc_dmalen;		/* DMA length */
};

#define	READ_DMAREG(sc, reg) \
	bus_space_read_4((sc)->sc_st, (sc)->sc_sh, (reg))
#define	WRITE_DMAREG(sc, reg, var) \
	bus_space_write_4((sc)->sc_st, (sc)->sc_sh, (reg), (var))

#define	PCSCP_READ_REG(sc, reg) \
	bus_space_read_1((sc)->sc_st, (sc)->sc_sh, (reg) << 2)
#define	PCSCP_WRITE_REG(sc, reg, val) \
	bus_space_write_1((sc)->sc_st, (sc)->sc_sh, (reg) << 2, (val))

int	pcscp_match(struct device *, void *, void *); 
void	pcscp_attach(struct device *, struct device *, void *);  

struct cfattach pcscp_ca = {
	sizeof(struct pcscp_softc), pcscp_match, pcscp_attach
};

struct cfdriver pcscp_cd = {
	NULL, "pcscp", DV_DULL
};

/*
 * Functions and the switch for the MI code.
 */

u_char	pcscp_read_reg(struct ncr53c9x_softc *, int);
void	pcscp_write_reg(struct ncr53c9x_softc *, int, u_char);
int	pcscp_dma_isintr(struct ncr53c9x_softc *);
void	pcscp_dma_reset(struct ncr53c9x_softc *);
int	pcscp_dma_intr(struct ncr53c9x_softc *);
int	pcscp_dma_setup(struct ncr53c9x_softc *, caddr_t *,
			       size_t *, int, size_t *);
void	pcscp_dma_go(struct ncr53c9x_softc *);
void	pcscp_dma_stop(struct ncr53c9x_softc *);
int	pcscp_dma_isactive(struct ncr53c9x_softc *);

struct ncr53c9x_glue pcscp_glue = {
	pcscp_read_reg,
	pcscp_write_reg,
	pcscp_dma_isintr,
	pcscp_dma_reset,
	pcscp_dma_intr,
	pcscp_dma_setup,
	pcscp_dma_go,
	pcscp_dma_stop,
	pcscp_dma_isactive,
	NULL,			/* gl_clear_latched_intr */
};

int
pcscp_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_AMD)
		return 0;

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_AMD_PCSCSI_PCI:
		return 1;
	}
	return 0;
}

/*
 * Attach this instance, and then all the sub-devices
 */
void
pcscp_attach(struct device *parent, struct device *self, void *aux)
{
	struct pci_attach_args *pa = aux;
	struct pcscp_softc *esc = (void *)self;
	struct ncr53c9x_softc *sc = &esc->sc_ncr53c9x;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	pci_intr_handle_t ih;
	const char *intrstr;
	bus_dma_segment_t seg;
	int error, rseg;

	if (pci_mapreg_map(pa, IO_MAP_REG, PCI_MAPREG_TYPE_IO, 0,
	     &iot, &ioh, NULL, NULL, 0)) {
		printf("%s: unable to map registers\n", sc->sc_dev.dv_xname);
		return;
	}

	sc->sc_glue = &pcscp_glue;

	esc->sc_st = iot;
	esc->sc_sh = ioh;
	esc->sc_dmat = pa->pa_dmat;

	/*
	 * XXX More of this should be in ncr53c9x_attach(), but
	 * XXX should we really poke around the chip that much in
	 * XXX the MI code?  Think about this more...
	 */

	/*
	 * Set up static configuration info.
	 */

	/*
	 * XXX should read configuration from EEPROM?
	 *
	 * MI ncr53c9x driver does not support configuration
	 * per each target device, though...
	 */
	sc->sc_id = 7;
	sc->sc_cfg1 = sc->sc_id | NCRCFG1_PARENB;
	sc->sc_cfg2 = NCRCFG2_SCSI2 | NCRCFG2_FE;
	sc->sc_cfg3 = NCRAMDCFG3_IDM | NCRAMDCFG3_FCLK;
	sc->sc_cfg4 = NCRAMDCFG4_GE12NS | NCRAMDCFG4_RADE;
	sc->sc_rev = NCR_VARIANT_AM53C974;
	sc->sc_features = NCR_F_FASTSCSI;
	sc->sc_cfg3_fscsi = NCRAMDCFG3_FSCSI;
	sc->sc_freq = 40; /* MHz */

	/*
	 * XXX minsync and maxxfer _should_ be set up in MI code,
	 * XXX but it appears to have some dependency on what sort
	 * XXX of DMA we're hooked up to, etc.
	 */

	/*
	 * This is the value used to start sync negotiations
	 * Note that the NCR register "SYNCTP" is programmed
	 * in "clocks per byte", and has a minimum value of 4.
	 * The SCSI period used in negotiation is one-fourth
	 * of the time (in nanoseconds) needed to transfer one byte.
	 * Since the chip's clock is given in MHz, we have the following
	 * formula: 4 * period = (1000 / freq) * 4
	 */

	sc->sc_minsync = 1000 / sc->sc_freq; 

	/* Really no limit, but since we want to fit into the TCR... */
	sc->sc_maxxfer = 16 * 1024 * 1024;

	/*
	 * Create the DMA maps for the data transfers.
         */

#define MDL_SEG_SIZE	0x1000 /* 4kbyte per segment */
#define MDL_SEG_OFFSET	0x0FFF
#define MDL_SIZE	(MAXPHYS / MDL_SEG_SIZE + 1) /* no hardware limit? */

	if (bus_dmamap_create(esc->sc_dmat, MAXPHYS, MDL_SIZE, MDL_SEG_SIZE,
	    MDL_SEG_SIZE, BUS_DMA_NOWAIT, &esc->sc_xfermap)) {
		printf("%s: can't create dma maps\n", sc->sc_dev.dv_xname);
		return;
	}

	/*
	 * Allocate and map memory for the MDL.
	 */

	if ((error = bus_dmamem_alloc(esc->sc_dmat,
	    sizeof(u_int32_t) * MDL_SIZE, PAGE_SIZE, 0, &seg, 1, &rseg,
	    BUS_DMA_NOWAIT)) != 0) {
		printf("%s: unable to allocate memory for the MDL, "
		    "error = %d\n", sc->sc_dev.dv_xname, error);
		goto fail_0;
	}
	if ((error = bus_dmamem_map(esc->sc_dmat, &seg, rseg,
	    sizeof(u_int32_t) * MDL_SIZE , (caddr_t *)&esc->sc_mdladdr,
	    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
		printf("%s: unable to map the MDL memory, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_1;
	}
	if ((error = bus_dmamap_create(esc->sc_dmat, 
	    sizeof(u_int32_t) * MDL_SIZE, 1, sizeof(u_int32_t) * MDL_SIZE,
	    0, BUS_DMA_NOWAIT, &esc->sc_mdldmap)) != 0) {
		printf("%s: unable to map_create for the MDL, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_2;
	}
	if ((error = bus_dmamap_load(esc->sc_dmat, esc->sc_mdldmap,
	     esc->sc_mdladdr, sizeof(u_int32_t) * MDL_SIZE,
	     NULL, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: unable to load for the MDL, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_3;
	}

	/* map and establish interrupt */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		goto fail_4;
	}

	intrstr = pci_intr_string(pa->pa_pc, ih);
	esc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO,
	    ncr53c9x_intr, esc, sc->sc_dev.dv_xname);
	if (esc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail_4;
	}
	if (intrstr != NULL)
		printf(": %s\n", intrstr);

	/* Do the common parts of attachment. */
	printf("%s", sc->sc_dev.dv_xname);

	ncr53c9x_attach(sc);

	/* Turn on target selection using the `dma' method */
	sc->sc_features |= NCR_F_DMASELECT;

	return;

fail_4:
	bus_dmamap_unload(esc->sc_dmat, esc->sc_mdldmap);
fail_3:
	bus_dmamap_destroy(esc->sc_dmat, esc->sc_mdldmap);
fail_2:
	bus_dmamem_unmap(esc->sc_dmat, (caddr_t)esc->sc_mdldmap,
	    sizeof(uint32_t) * MDL_SIZE);
fail_1:
	bus_dmamem_free(esc->sc_dmat, &seg, rseg);
fail_0:
	bus_dmamap_destroy(esc->sc_dmat, esc->sc_xfermap);
}

/*
 * Glue functions.
 */

u_char
pcscp_read_reg(struct ncr53c9x_softc *sc, int reg)
{
	struct pcscp_softc *esc = (struct pcscp_softc *)sc;

	return PCSCP_READ_REG(esc, reg);
}

void
pcscp_write_reg(struct ncr53c9x_softc *sc, int reg, u_char v)
{
	struct pcscp_softc *esc = (struct pcscp_softc *)sc;

	PCSCP_WRITE_REG(esc, reg, v);
}

int
pcscp_dma_isintr(struct ncr53c9x_softc *sc)
{
	struct pcscp_softc *esc = (struct pcscp_softc *)sc;

	return (PCSCP_READ_REG(esc, NCR_STAT) & NCRSTAT_INT) != 0;
}

void
pcscp_dma_reset(struct ncr53c9x_softc *sc)
{
	struct pcscp_softc *esc = (struct pcscp_softc *)sc;

	WRITE_DMAREG(esc, DMA_CMD, DMACMD_IDLE);

	esc->sc_active = 0;
}

int
pcscp_dma_intr(struct ncr53c9x_softc *sc)
{
	struct pcscp_softc *esc = (struct pcscp_softc *)sc;
	int trans, resid, i;
	bus_dmamap_t dmap = esc->sc_xfermap;
	int datain = esc->sc_datain;
	u_int32_t dmastat;
	char *p = NULL;

	dmastat = READ_DMAREG(esc, DMA_STAT);

	if (dmastat & DMASTAT_ERR) {
		/* XXX not tested... */
		WRITE_DMAREG(esc, DMA_CMD,
		    DMACMD_ABORT | (datain ? DMACMD_DIR : 0));

		printf("%s: error: DMA error detected; Aborting.\n",
		    sc->sc_dev.dv_xname);
		bus_dmamap_unload(esc->sc_dmat, dmap);
		return -1;
	}

	if (dmastat & DMASTAT_ABT) {
		/* XXX What should be done? */
		printf("%s: dma_intr: DMA aborted.\n", sc->sc_dev.dv_xname);
		WRITE_DMAREG(esc, DMA_CMD,
		    DMACMD_IDLE | (datain ? DMACMD_DIR : 0));
		esc->sc_active = 0;
		return 0;
	}

#ifdef DIAGNOSTIC
	/* This is an "assertion" :) */
	if (esc->sc_active == 0)
		panic("pcscp dmaintr: DMA wasn't active");
#endif

	/* DMA has stopped */

	esc->sc_active = 0;

	if (esc->sc_dmasize == 0) {
		/* A "Transfer Pad" operation completed */
		NCR_DMA(("dmaintr: discarded %d bytes (tcl=%d, tcm=%d)\n",
		    PCSCP_READ_REG(esc, NCR_TCL) |
		    (PCSCP_READ_REG(esc, NCR_TCM) << 8),
		    PCSCP_READ_REG(esc, NCR_TCL),
		    PCSCP_READ_REG(esc, NCR_TCM)));
		return 0;
	}

	resid = 0;
	/*
	 * If a transfer onto the SCSI bus gets interrupted by the device
	 * (e.g. for a SAVEPOINTER message), the data in the FIFO counts
	 * as residual since the ESP counter registers get decremented as
	 * bytes are clocked into the FIFO.
	 */
	if (!datain &&
	    (resid = (PCSCP_READ_REG(esc, NCR_FFLAG) & NCRFIFO_FF)) != 0) {
		NCR_DMA(("pcscp_dma_intr: empty esp FIFO of %d ", resid));
	}

	if ((sc->sc_espstat & NCRSTAT_TC) == 0) {
		/*
		 * `Terminal count' is off, so read the residue
		 * out of the ESP counter registers.
		 */
		if (datain) {
			resid = PCSCP_READ_REG(esc, NCR_FFLAG) & NCRFIFO_FF;
			while (resid > 1)
				resid =
				    PCSCP_READ_REG(esc, NCR_FFLAG) & NCRFIFO_FF;
			WRITE_DMAREG(esc, DMA_CMD, DMACMD_BLAST | DMACMD_MDL |
			    (datain ? DMACMD_DIR : 0));

			for (i = 0; i < 0x8000; i++) /* XXX 0x8000 ? */
				if (READ_DMAREG(esc, DMA_STAT) & DMASTAT_BCMP)
					break;

			/* See the below comments... */
			if (resid)
				p = *esc->sc_dmaaddr;
		}
		
		resid += PCSCP_READ_REG(esc, NCR_TCL) |
		    (PCSCP_READ_REG(esc, NCR_TCM) << 8) |
		    (PCSCP_READ_REG(esc, NCR_TCH) << 16);
	} else {
		while ((dmastat & DMASTAT_DONE) == 0)
			dmastat = READ_DMAREG(esc, DMA_STAT);
	}

	WRITE_DMAREG(esc, DMA_CMD, DMACMD_IDLE | (datain ? DMACMD_DIR : 0));

	/* sync MDL */
	bus_dmamap_sync(esc->sc_dmat, esc->sc_mdldmap,
	    0, sizeof(u_int32_t) * dmap->dm_nsegs, BUS_DMASYNC_POSTWRITE);
	/* sync transfer buffer */
	bus_dmamap_sync(esc->sc_dmat, dmap, 0, dmap->dm_mapsize,
	    datain ? BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(esc->sc_dmat, dmap);

	trans = esc->sc_dmasize - resid;

	/*
	 * From the technical manual notes:
	 *
	 * `In some odd byte conditions, one residual byte will be left
	 *  in the SCSI FIFO, and the FIFO flags will never count to 0.
	 *  When this happens, the residual byte should be retrieved
	 *  via PIO following completion of the BLAST operation.'
	 */
	
	if (p) {
		p += trans;
		*p = PCSCP_READ_REG(esc, NCR_FIFO);
		trans++;
	}

	if (trans < 0) {			/* transferred < 0 ? */
#if 0
		/*
		 * This situation can happen in perfectly normal operation
		 * if the ESP is reselected while using DMA to select
		 * another target.  As such, don't print the warning.
		 */
		printf("%s: xfer (%d) > req (%d)\n",
		    sc->sc_dev.dv_xname, trans, esc->sc_dmasize);
#endif
		trans = esc->sc_dmasize;
	}

	NCR_DMA(("dmaintr: tcl=%d, tcm=%d, tch=%d; trans=%d, resid=%d\n",
	    PCSCP_READ_REG(esc, NCR_TCL),
	    PCSCP_READ_REG(esc, NCR_TCM),
	    PCSCP_READ_REG(esc, NCR_TCH),
	    trans, resid));

	*esc->sc_dmalen -= trans;
	*esc->sc_dmaaddr += trans;

	return 0;
}

int
pcscp_dma_setup(struct ncr53c9x_softc *sc, caddr_t *addr, size_t *len,
    int datain, size_t *dmasize)
{
	struct pcscp_softc *esc = (struct pcscp_softc *)sc;
	bus_dmamap_t dmap = esc->sc_xfermap;
	u_int32_t *mdl;
	int error, nseg, seg;
	bus_addr_t s_offset, s_addr;

	WRITE_DMAREG(esc, DMA_CMD, DMACMD_IDLE | (datain ? DMACMD_DIR : 0));

	esc->sc_dmaaddr = addr;
	esc->sc_dmalen = len;
	esc->sc_dmasize = *dmasize;
	esc->sc_datain = datain;

#ifdef DIAGNOSTIC
	if ((*dmasize / MDL_SEG_SIZE) > MDL_SIZE)
		panic("pcscp: transfer size too large");
#endif

	/*
	 * No need to set up DMA in `Transfer Pad' operation.
	 * (case of *dmasize == 0)
	 */
	if (*dmasize == 0)
		return 0;

	error = bus_dmamap_load(esc->sc_dmat, dmap, *esc->sc_dmaaddr,
	    *esc->sc_dmalen, NULL,
	    ((sc->sc_nexus->xs->flags & SCSI_NOSLEEP) ?
	    BUS_DMA_NOWAIT : BUS_DMA_WAITOK) | BUS_DMA_STREAMING |
	    ((sc->sc_nexus->xs->flags & SCSI_DATA_IN) ?
	     BUS_DMA_READ : BUS_DMA_WRITE));
	if (error) {
		printf("%s: unable to load dmamap, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		return error;
	}

	/* set transfer length */
	WRITE_DMAREG(esc, DMA_STC, *dmasize); 

	/* set up MDL */
	mdl = esc->sc_mdladdr;
	nseg = dmap->dm_nsegs;

	/* the first segment is possibly not aligned with 4k MDL boundary */
	s_addr = dmap->dm_segs[0].ds_addr;
	s_offset = s_addr & MDL_SEG_OFFSET;
	s_addr -= s_offset;

	/* set the first MDL and offset */
	WRITE_DMAREG(esc, DMA_SPA, s_offset); 
	*mdl++ = htole32(s_addr);

	/* the rest dmamap segments are aligned with 4k boundary */
	for (seg = 1; seg < nseg; seg++)
		*mdl++ = htole32(dmap->dm_segs[seg].ds_addr);

	return 0;
}

void
pcscp_dma_go(struct ncr53c9x_softc *sc)
{
	struct pcscp_softc *esc = (struct pcscp_softc *)sc;
	bus_dmamap_t dmap = esc->sc_xfermap, mdldmap = esc->sc_mdldmap;
	int datain = esc->sc_datain;

	/* No DMA transfer in Transfer Pad operation */
	if (esc->sc_dmasize == 0)
		return;

	/* sync transfer buffer */
	bus_dmamap_sync(esc->sc_dmat, dmap, 0, dmap->dm_mapsize,
	    datain ? BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);

	/* sync MDL */
	bus_dmamap_sync(esc->sc_dmat, mdldmap,
	    0, sizeof(u_int32_t) * dmap->dm_nsegs, BUS_DMASYNC_PREWRITE); 

	/* set Starting MDL Address */
	WRITE_DMAREG(esc, DMA_SMDLA, mdldmap->dm_segs[0].ds_addr);

	/* set DMA command register bits */
	/* XXX DMA Transfer Interrupt Enable bit is broken? */
	WRITE_DMAREG(esc, DMA_CMD, DMACMD_IDLE | DMACMD_MDL |
	    /* DMACMD_INTE | */
	    (datain ? DMACMD_DIR : 0));

	/* issue DMA start command */
	WRITE_DMAREG(esc, DMA_CMD, DMACMD_START | DMACMD_MDL |
	    /* DMACMD_INTE | */
	    (datain ? DMACMD_DIR : 0));

	esc->sc_active = 1;
}

void
pcscp_dma_stop(struct ncr53c9x_softc *sc)
{
	struct pcscp_softc *esc = (struct pcscp_softc *)sc;

	/* dma stop */
	/* XXX What should we do here ? */
	WRITE_DMAREG(esc, DMA_CMD,
	    DMACMD_ABORT | (esc->sc_datain ? DMACMD_DIR : 0));
	bus_dmamap_unload(esc->sc_dmat, esc->sc_xfermap);

	esc->sc_active = 0;
}

int
pcscp_dma_isactive(struct ncr53c9x_softc *sc)
{
	struct pcscp_softc *esc = (struct pcscp_softc *)sc;

	/* XXX should check esc->sc_active? */
	if ((READ_DMAREG(esc, DMA_CMD) & DMACMD_CMD) != DMACMD_IDLE)
		return 1;
	return 0;
}
@


1.19
log
@instead of having every bit of glue set up and attach an identical
scsi_adapter struct, just do it once in the chip code.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.18 2011/04/07 15:30:16 miod Exp $	*/
a47 1
#include <machine/intr.h>
@


1.18
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.17 2010/06/28 18:31:02 krw Exp $	*/
a121 7
struct scsi_adapter pcscp_adapter = {
	ncr53c9x_scsi_cmd,	/* cmd */
	scsi_minphys,		/* scsi_minphys */
	0,			/* open */
	0,			/* close */
};

d294 1
a294 1
	ncr53c9x_attach(sc, &pcscp_adapter);
@


1.17
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.16 2009/02/16 21:19:07 miod Exp $	*/
d174 1
a174 1
	     &iot, &ioh, NULL, NULL, NULL)) {
@


1.16
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.15 2008/06/26 05:42:17 ray Exp $	*/
d301 1
a301 1
	ncr53c9x_attach(sc, &pcscp_adapter, NULL);
@


1.15
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.14 2006/04/30 00:35:40 brad Exp $	*/
d124 1
a124 1
	minphys,		/* minphys */
@


1.14
log
@Free one more resource on attach failure.

From NetBSD

ok martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.13 2006/04/20 16:06:32 martin Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.13
log
@ANSI function declarations

prompted by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.12 2006/04/18 19:52:09 martin Exp $	*/
d262 1
a262 1
		return;
d269 1
a269 1
		goto fail_0;
d276 1
a276 1
		goto fail_1;
d283 1
a283 1
		goto fail_2;
d289 1
a289 1
		goto fail_3;
d300 1
a300 1
		goto fail_3;
d315 2
d318 1
a318 1
	bus_dmamap_unload(esc->sc_dmat, esc->sc_mdldmap);
a319 2
	bus_dmamap_destroy(esc->sc_dmat, esc->sc_mdldmap);
fail_1:
d322 2
d325 1
a325 1
	bus_dmamem_free(esc->sc_dmat, &seg, rseg);
@


1.12
log
@- establish interrupt after all dma resouces are successfully allocated
- wrap an assertion with #ifdef DIAGNOSTIC
- call bus_dmamap_sync for mdldmap at POSTWRITE for consistency
- pass proper dmamapsize for mdldmap
- Call bus_space_{read,write}_1() directly to access ncr53c9x common registers
- Unload xfer dmamap in pscsp_dma_stop()
- Free resources if attach fails

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.11 2006/04/14 09:31:52 martin Exp $	*/
d150 1
a150 3
pcscp_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d153 1
d168 1
a168 3
pcscp_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d331 1
a331 3
pcscp_read_reg(sc, reg)
	struct ncr53c9x_softc *sc;
	int reg;
d339 1
a339 4
pcscp_write_reg(sc, reg, v)
	struct ncr53c9x_softc *sc;
	int reg;
	u_char v;
d347 1
a347 2
pcscp_dma_isintr(sc)
	struct ncr53c9x_softc *sc;
d355 1
a355 2
pcscp_dma_reset(sc)
	struct ncr53c9x_softc *sc;
d365 1
a365 2
pcscp_dma_intr(sc)
	struct ncr53c9x_softc *sc;
d511 2
a512 6
pcscp_dma_setup(sc, addr, len, datain, dmasize)
	struct ncr53c9x_softc *sc;
	caddr_t *addr;
	size_t *len;
	int datain;
	size_t *dmasize;
d575 1
a575 2
pcscp_dma_go(sc)
	struct ncr53c9x_softc *sc;
d611 1
a611 2
pcscp_dma_stop(sc)
	struct ncr53c9x_softc *sc;
d625 1
a625 2
pcscp_dma_isactive(sc)
	struct ncr53c9x_softc *sc;
@


1.11
log
@- Add BUS_DMA_STREAMING to data transfer map loads.
- Use BUS_DMA_READ and BUS_DMA_WRITE in some obvious places.
- Remove PCnet ID, it makes no sense having it here.
- Remove code to map PCI_MAPREG_TYPE_MEM, which is not supported by 53c974.
- Update technical manual URL.
- Utilize bus_dma(9) functions more efficiently.

from NetBSD; ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.10 2005/08/09 04:10:13 mickey Exp $	*/
a55 1
#include <machine/endian.h>
d98 4
a101 5
/* don't have to use MI defines in MD code... */
#undef	NCR_READ_REG
#define	NCR_READ_REG(sc, reg)		pcscp_read_reg((sc), (reg))
#undef	NCR_WRITE_REG
#define	NCR_WRITE_REG(sc, reg, val)	pcscp_write_reg((sc), (reg), (val))
a241 19
	/* map and establish interrupt */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		return;
	}

	intrstr = pci_intr_string(pa->pa_pc, ih);
	esc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, 
	    ncr53c9x_intr, esc, sc->sc_dev.dv_xname);
	if (esc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	if (intrstr != NULL)
		printf(": %s\n", intrstr);

d272 1
a272 1
		return;
d279 1
a279 1
		return;
d286 18
a303 1
		return;
d305 2
d315 12
d340 1
a340 1
	return bus_space_read_1(esc->sc_st, esc->sc_sh, reg << 2);
d351 1
a351 1
	bus_space_write_1(esc->sc_st, esc->sc_sh, reg << 2, v);
d358 1
d360 1
a360 1
	return NCR_READ_REG(sc, NCR_STAT) & NCRSTAT_INT;
d407 1
d411 1
d420 4
a423 4
		    NCR_READ_REG(sc, NCR_TCL) |
		    (NCR_READ_REG(sc, NCR_TCM) << 8),
		    NCR_READ_REG(sc, NCR_TCL),
		    NCR_READ_REG(sc, NCR_TCM)));
d435 1
a435 1
	    (resid = (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF)) != 0) {
d445 1
a445 1
			resid = NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF;
d448 1
a448 1
				    NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF;
d461 3
a463 9
		resid += (NCR_READ_REG(sc, NCR_TCL) |
		    (NCR_READ_REG(sc, NCR_TCM) << 8) |
		    ((sc->sc_cfg2 & NCRCFG2_FE)
		    ? (NCR_READ_REG(sc, NCR_TCH) << 16) : 0));

		if (resid == 0 && esc->sc_dmasize == 65536 &&
		    (sc->sc_cfg2 & NCRCFG2_FE) == 0)
			/* A transfer of 64K is encoded as `TCL=TCM=0' */
			resid = 65536;
d465 1
a465 1
		while((dmastat & DMASTAT_DONE) == 0)
d471 4
d492 1
a492 1
		*p = NCR_READ_REG(sc, NCR_FIFO);
d510 3
a512 3
	    NCR_READ_REG(sc, NCR_TCL),
	    NCR_READ_REG(sc, NCR_TCM),
	    (sc->sc_cfg2 & NCRCFG2_FE) ? NCR_READ_REG(sc, NCR_TCH) : 0,
d606 2
a607 2
	bus_dmamap_sync(esc->sc_dmat, mdldmap, 0, mdldmap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
d636 1
@


1.10
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: pcscp.c,v 1.9 2002/03/14 01:26:59 millert Exp $	*/
/*	$NetBSD: pcscp.c,v 1.11 2000/11/14 18:42:58 thorpej Exp $	*/
d46 1
a46 1
 * http://www.amd.com/products/npd/techdocs/techdocs.html
a71 1
#define MEM_MAP_REG	0x14
a161 3
#if 0
	case PCI_PRODUCT_AMD_PCNETS_PCI:
#endif
d178 2
a179 3
	bus_space_tag_t st, iot, memt;
	bus_space_handle_t sh, ioh, memh;
	int ioh_valid, memh_valid;
d185 3
a187 18
	ioh_valid = (pci_mapreg_map(pa, IO_MAP_REG, PCI_MAPREG_TYPE_IO, 0,
	    &iot, &ioh, NULL, NULL, 0) == 0);
#if 0	/* XXX cannot use memory map? */
	memh_valid = (pci_mapreg_map(pa, MEM_MAP_REG,
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,
	    &memt, &memh, NULL, NULL, 0) == 0);
#else
	memh_valid = 0;
#endif

	if (memh_valid) {
		st = memt;
		sh = memh;
	} else if (ioh_valid) {
		st = iot;
		sh = ioh;
	} else {
		printf(": unable to map registers\n");
d193 2
a194 2
	esc->sc_st = st;
	esc->sc_sh = sh;
d271 2
a272 2
	if (bus_dmamap_create(esc->sc_dmat, MAXPHYS, MDL_SIZE, MAXPHYS, 0,
	    BUS_DMA_NOWAIT, &esc->sc_xfermap)) {
a522 1
	long rest, count;
d545 4
a548 2
	    sc->sc_nexus->xs->flags & SCSI_NOSLEEP ?
	    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
a562 1
	count = dmap->dm_segs[0].ds_len;
a565 1
	rest = MDL_SEG_SIZE - s_offset;
a569 8
	count -= rest;
	
	/* rests of the first dmamap segment */
	while (count > 0) {
		s_addr += MDL_SEG_SIZE;
		*mdl++ = htole32(s_addr);
		count -= MDL_SEG_SIZE;
	}
d572 2
a573 15
	for (seg = 1; seg < nseg; seg++) {
		count = dmap->dm_segs[seg].ds_len;
		s_addr = dmap->dm_segs[seg].ds_addr;

		/* first 4kbyte of each dmamap segment */
		*mdl++ = htole32(s_addr);
		count -= MDL_SEG_SIZE;

		/* trailing contiguous 4k frames of each dmamap segments */
		while (count > 0) {
			s_addr += MDL_SEG_SIZE;
			*mdl++ = htole32(s_addr);
			count -= MDL_SEG_SIZE;
		}
	}
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.8 2001/11/05 17:25:58 art Exp $	*/
a186 1
	pcireg_t csr;
a216 4
	csr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    csr | PCI_COMMAND_MASTER_ENABLE | PCI_COMMAND_IO_ENABLE);
				     
@


1.8
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.7 2001/09/27 04:01:42 jason Exp $	*/
d106 2
a107 2
int	pcscp_match __P((struct device *, void *, void *)); 
void	pcscp_attach __P((struct device *, struct device *, void *));  
d121 10
a130 10
u_char	pcscp_read_reg __P((struct ncr53c9x_softc *, int));
void	pcscp_write_reg __P((struct ncr53c9x_softc *, int, u_char));
int	pcscp_dma_isintr __P((struct ncr53c9x_softc *));
void	pcscp_dma_reset __P((struct ncr53c9x_softc *));
int	pcscp_dma_intr __P((struct ncr53c9x_softc *));
int	pcscp_dma_setup __P((struct ncr53c9x_softc *, caddr_t *,
			       size_t *, int, size_t *));
void	pcscp_dma_go __P((struct ncr53c9x_softc *));
void	pcscp_dma_stop __P((struct ncr53c9x_softc *));
int	pcscp_dma_isactive __P((struct ncr53c9x_softc *));
@


1.8.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.8 2001/11/05 17:25:58 art Exp $	*/
d106 2
a107 2
int	pcscp_match(struct device *, void *, void *); 
void	pcscp_attach(struct device *, struct device *, void *);  
d121 10
a130 10
u_char	pcscp_read_reg(struct ncr53c9x_softc *, int);
void	pcscp_write_reg(struct ncr53c9x_softc *, int, u_char);
int	pcscp_dma_isintr(struct ncr53c9x_softc *);
void	pcscp_dma_reset(struct ncr53c9x_softc *);
int	pcscp_dma_intr(struct ncr53c9x_softc *);
int	pcscp_dma_setup(struct ncr53c9x_softc *, caddr_t *,
			       size_t *, int, size_t *);
void	pcscp_dma_go(struct ncr53c9x_softc *);
void	pcscp_dma_stop(struct ncr53c9x_softc *);
int	pcscp_dma_isactive(struct ncr53c9x_softc *);
@


1.7
log
@Huge merge with NetBSD.  For full details look at their revision history (1.26 -> 1.83)...
Highlights:
o tag queue support
o fas366 support (doesn't work yet on sparc, but does on sparc64)
o tons more
(thanks to hugh, fgsch and beck for testing)
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.6 2001/08/26 03:32:22 jason Exp $	*/
a151 8
#ifdef __HAS_NEW_BUS_DMAMAP_SYNC
#define pcscp_bus_dmamap_sync(t, m, o, l, f) \
    bus_dmamap_sync((t), (m), (o), (l), (f))
#else
#define pcscp_bus_dmamap_sync(t, m, o, l, f) \
    bus_dmamap_sync((t), (m), (f))
#endif

d489 1
a489 1
	pcscp_bus_dmamap_sync(esc->sc_dmat, dmap, 0, dmap->dm_mapsize,
d638 1
a638 1
	pcscp_bus_dmamap_sync(esc->sc_dmat, dmap, 0, dmap->dm_mapsize,
d642 1
a642 1
	pcscp_bus_dmamap_sync(esc->sc_dmat, mdldmap, 0, mdldmap->dm_mapsize,
@


1.6
log
@Yup, I managed to fat finger all three of these while doing bus_dmamap_sync()
conversion (luckily only sparc64 uses the 5 arg form so far =)
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.5 2001/08/25 14:52:57 jason Exp $	*/
d349 1
a349 1
	ncr53c9x_dmaselect = 1;
@


1.5
log
@deal with 5 arg for of bus_dmamap_sync() if available
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.4 2001/08/25 10:13:30 art Exp $	*/
d497 1
a497 1
	pcscp_bus_dmamap_sync(esc->sc_dmat, dmap, 0, dmap_>dm_mapsize,
@


1.4
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.3 2001/06/12 15:40:33 niklas Exp $	*/
d152 8
d497 1
a497 1
	bus_dmamap_sync(esc->sc_dmat, dmap,
d646 1
a646 1
	bus_dmamap_sync(esc->sc_dmat, dmap,
d650 1
a650 1
	bus_dmamap_sync(esc->sc_dmat, mdldmap,
@


1.3
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.2 2001/02/14 06:37:01 fgsch Exp $	*/
d270 1
a270 2
	if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.2
log
@Change output to fit OpenBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.1 2001/02/14 05:10:18 fgsch Exp $	*/
d191 2
a192 3
	ioh_valid = (pci_mapreg_map(pa, IO_MAP_REG,
	    PCI_MAPREG_TYPE_IO, 0,
	    &iot, &ioh, NULL, NULL) == 0);
d196 1
a196 1
	    &memt, &memh, NULL, NULL) == 0);
@


1.2.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.2 2001/02/14 06:37:01 fgsch Exp $	*/
@


1.2.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.2.4.1 2001/05/14 22:25:56 niklas Exp $	*/
d191 3
a193 2
	ioh_valid = (pci_mapreg_map(pa, IO_MAP_REG, PCI_MAPREG_TYPE_IO, 0,
	    &iot, &ioh, NULL, NULL, 0) == 0);
d197 1
a197 1
	    &memt, &memh, NULL, NULL, 0) == 0);
@


1.2.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pcscp.c,v 1.2.4.2 2001/07/04 10:43:01 niklas Exp $	*/
a151 8
#ifdef __HAS_NEW_BUS_DMAMAP_SYNC
#define pcscp_bus_dmamap_sync(t, m, o, l, f) \
    bus_dmamap_sync((t), (m), (o), (l), (f))
#else
#define pcscp_bus_dmamap_sync(t, m, o, l, f) \
    bus_dmamap_sync((t), (m), (f))
#endif

d270 2
a271 1
	if (pci_intr_map(pa, &ih)) {
d342 1
a342 1
	sc->sc_features |= NCR_F_DMASELECT;
d490 1
a490 1
	pcscp_bus_dmamap_sync(esc->sc_dmat, dmap, 0, dmap->dm_mapsize,
d639 1
a639 1
	pcscp_bus_dmamap_sync(esc->sc_dmat, dmap, 0, dmap->dm_mapsize,
d643 1
a643 1
	pcscp_bus_dmamap_sync(esc->sc_dmat, mdldmap, 0, mdldmap->dm_mapsize,
@


1.2.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d152 8
d497 1
a497 1
	bus_dmamap_sync(esc->sc_dmat, dmap, 0, dmap->dm_mapsize,
d646 1
a646 1
	bus_dmamap_sync(esc->sc_dmat, dmap, 0, dmap->dm_mapsize,
d650 1
a650 1
	bus_dmamap_sync(esc->sc_dmat, mdldmap, 0, mdldmap->dm_mapsize,
@


1.2.4.5
log
@Merge in -current from roughly a week ago
@
text
@d106 2
a107 2
int	pcscp_match(struct device *, void *, void *); 
void	pcscp_attach(struct device *, struct device *, void *);  
d121 10
a130 10
u_char	pcscp_read_reg(struct ncr53c9x_softc *, int);
void	pcscp_write_reg(struct ncr53c9x_softc *, int, u_char);
int	pcscp_dma_isintr(struct ncr53c9x_softc *);
void	pcscp_dma_reset(struct ncr53c9x_softc *);
int	pcscp_dma_intr(struct ncr53c9x_softc *);
int	pcscp_dma_setup(struct ncr53c9x_softc *, caddr_t *,
			       size_t *, int, size_t *);
void	pcscp_dma_go(struct ncr53c9x_softc *);
void	pcscp_dma_stop(struct ncr53c9x_softc *);
int	pcscp_dma_isactive(struct ncr53c9x_softc *);
@


1.1
log
@Support for AMD Am53c974 SCSI controllers; from NetBSD.
Thanks to Quentin Barnes <qbarnes@@urbana.css.mot.com> for his help.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a211 1
	printf("\n");
d273 1
a273 1
		printf("%s: couldn't map interrupt\n", sc->sc_dev.dv_xname);
d281 1
a281 1
		printf("%s: couldn't establish interrupt", sc->sc_dev.dv_xname);
d288 1
a288 2
		printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname,
		    intrstr);
@

