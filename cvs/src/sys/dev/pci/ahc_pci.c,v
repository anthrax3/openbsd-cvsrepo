head	1.57;
access;
symbols
	OPENBSD_6_2:1.57.0.12
	OPENBSD_6_2_BASE:1.57
	OPENBSD_6_1:1.57.0.10
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.57.0.8
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.57.0.4
	OPENBSD_5_8_BASE:1.57
	OPENBSD_5_7:1.56.0.6
	OPENBSD_5_7_BASE:1.56
	OPENBSD_5_6:1.56.0.4
	OPENBSD_5_6_BASE:1.56
	OPENBSD_5_5:1.55.0.14
	OPENBSD_5_5_BASE:1.55
	OPENBSD_5_4:1.55.0.10
	OPENBSD_5_4_BASE:1.55
	OPENBSD_5_3:1.55.0.8
	OPENBSD_5_3_BASE:1.55
	OPENBSD_5_2:1.55.0.6
	OPENBSD_5_2_BASE:1.55
	OPENBSD_5_1_BASE:1.55
	OPENBSD_5_1:1.55.0.4
	OPENBSD_5_0:1.55.0.2
	OPENBSD_5_0_BASE:1.55
	OPENBSD_4_9:1.53.0.12
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.53.0.10
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.53.0.6
	OPENBSD_4_7_BASE:1.53
	OPENBSD_4_6:1.53.0.8
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.53.0.4
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.53.0.2
	OPENBSD_4_4_BASE:1.53
	OPENBSD_4_3:1.52.0.2
	OPENBSD_4_3_BASE:1.52
	OPENBSD_4_2:1.51.0.2
	OPENBSD_4_2_BASE:1.51
	OPENBSD_4_1:1.50.0.4
	OPENBSD_4_1_BASE:1.50
	OPENBSD_4_0:1.50.0.2
	OPENBSD_4_0_BASE:1.50
	OPENBSD_3_9:1.49.0.4
	OPENBSD_3_9_BASE:1.49
	OPENBSD_3_8:1.49.0.2
	OPENBSD_3_8_BASE:1.49
	OPENBSD_3_7:1.47.0.2
	OPENBSD_3_7_BASE:1.47
	OPENBSD_3_6:1.45.0.2
	OPENBSD_3_6_BASE:1.45
	SMP_SYNC_A:1.43
	SMP_SYNC_B:1.43
	OPENBSD_3_5:1.43.0.2
	OPENBSD_3_5_BASE:1.43
	OPENBSD_3_4:1.40.0.2
	OPENBSD_3_4_BASE:1.40
	UBC_SYNC_A:1.37
	OPENBSD_3_3:1.37.0.2
	OPENBSD_3_3_BASE:1.37
	OPENBSD_3_2:1.35.0.2
	OPENBSD_3_2_BASE:1.35
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	UBC_SYNC_B:1.35
	UBC:1.26.0.4
	UBC_BASE:1.26
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.17.0.2
	OPENBSD_2_7_BASE:1.17
	SMP:1.12.0.2
	SMP_BASE:1.12
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.57
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.56;
commitid	p4LJxGKbi0BU2cG6;

1.56
date	2014.05.08.18.09.22;	author sf;	state Exp;
branches;
next	1.55;

1.55
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	2011.07.04.22.17.23;	author matthew;	state Exp;
branches;
next	1.53;

1.53
date	2008.05.13.02.24.08;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2007.09.07.18.07.06;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2007.05.14.01.37.50;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2006.07.11.18.48.27;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2005.08.09.04.10.10;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	2005.03.24.17.15.28;	author martin;	state Exp;
branches;
next	1.47;

1.47
date	2005.02.21.03.10.57;	author martin;	state Exp;
branches;
next	1.46;

1.46
date	2005.02.12.15.32.11;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2004.08.13.23.38.54;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2004.08.01.01.36.24;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2004.01.05.01.09.18;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2003.12.24.22.45.45;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2003.09.25.07.11.15;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2003.08.15.23.01.01;	author fgsch;	state Exp;
branches;
next	1.39;

1.39
date	2003.08.12.10.27.10;	author fgsch;	state Exp;
branches;
next	1.38;

1.38
date	2003.07.25.09.49.21;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2003.02.18.13.14.42;	author jmc;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.19.18.40.16;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	2002.07.05.05.41.02;	author smurph;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.30.19.19.49;	author smurph;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.29.23.53.33;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.28.00.34.54;	author smurph;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.19.21.07.25;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.19.02.49.20;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.18.23.25.38;	author smurph;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.16.04.36.32;	author smurph;	state Exp;
branches;
next	1.26;

1.26
date	2001.09.21.17.55.43;	author miod;	state Exp;
branches
	1.26.4.1;
next	1.25;

1.25
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.23.05.41.14;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.10.11.07.23;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.12.15.40.29;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.22.22.36.52;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2000.12.29.03.51.41;	author smurph;	state Exp;
branches;
next	1.19;

1.19
date	2000.07.03.22.18.37;	author smurph;	state Exp;
branches;
next	1.18;

1.18
date	2000.05.26.06.49.32;	author chris;	state Exp;
branches;
next	1.17;

1.17
date	2000.04.13.23.51.23;	author smurph;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.13.04.25.10;	author smurph;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.06.18.21.42;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.05.04.29.59;	author smurph;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.22.04.01.07;	author smurph;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.31.01.50.55;	author weingart;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	99.09.22.21.57.08;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.08.27.23.29.52;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	98.01.07.11.03.25;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.01.05.13.35.18;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.08.05.05.38.22;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.11.28.23.28.01;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.11.12.20.30.48;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.10.16.12.40.55;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.21.22.27.49;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.27.21.15.55;	author shawn;	state Exp;
branches;
next	1.1;

1.1
date	96.05.26.00.27.39;	author deraadt;	state Exp;
branches;
next	;

1.12.2.1
date	2000.03.24.09.09.16;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2001.05.14.22.25.32;	author niklas;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2001.07.04.10.41.51;	author niklas;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.12.2.5;

1.12.2.5
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.12.2.6;

1.12.2.6
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.12.2.7;

1.12.2.7
date	2003.03.28.00.38.20;	author niklas;	state Exp;
branches;
next	1.12.2.8;

1.12.2.8
date	2004.02.19.10.56.25;	author niklas;	state Exp;
branches;
next	;

1.26.4.1
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.26.4.2;

1.26.4.2
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	1.26.4.3;

1.26.4.3
date	2003.05.19.22.17.59;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: ahc_pci.c,v 1.56 2014/05/08 18:09:22 sf Exp $	*/
/*	$NetBSD: ahc_pci.c,v 1.43 2003/08/18 09:16:22 taca Exp $	*/

/*
 * Product specific probe and attach routines for:
 *      3940, 2940, aic7895, aic7890, aic7880,
 *	aic7870, aic7860 and aic7850 SCSI controllers
 *
 * Copyright (c) 1994-2001 Justin T. Gibbs.
 * Copyright (c) 2000-2001 Adaptec Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 *
 * $Id: ahc_pci.c,v 1.56 2014/05/08 18:09:22 sf Exp $
 *
 * //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#57 $
 *
 * $FreeBSD: /repoman/r/ncvs/src/sys/dev/aic7xxx/aic7xxx_pci.c,v 1.22 2003/01/20 20:44:55 gibbs Exp $
 */
/*
 * Ported from FreeBSD by Pascal Renauld, Network Storage Solutions, Inc. - April 2003
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/queue.h>
#include <sys/device.h>
#include <sys/reboot.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

#define AHC_PCI_IOADDR	PCI_MAPREG_START	/* I/O Address */
#define AHC_PCI_MEMADDR	(PCI_MAPREG_START + 4)	/* Mem I/O Address */

#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>

#ifndef __i386__
#define AHC_ALLOW_MEMIO
#endif

static __inline uint64_t
ahc_compose_id(u_int device, u_int vendor, u_int subdevice, u_int subvendor)
{
	uint64_t id;

	id = subvendor
	   | (subdevice << 16)
	   | ((uint64_t)vendor << 32)
	   | ((uint64_t)device << 48);

	return (id);
}

#define ID_ALL_MASK			0xFFFFFFFFFFFFFFFFull
#define ID_DEV_VENDOR_MASK		0xFFFFFFFF00000000ull
#define ID_9005_GENERIC_MASK		0xFFF0FFFF00000000ull
#define ID_9005_SISL_MASK		0x000FFFFF00000000ull
#define ID_9005_SISL_ID			0x0005900500000000ull
#define ID_AIC7850			0x5078900400000000ull
#define ID_AHA_2902_04_10_15_20_30C	0x5078900478509004ull
#define ID_AIC7855			0x5578900400000000ull
#define ID_AIC7859			0x3860900400000000ull
#define ID_AHA_2930CU			0x3860900438699004ull
#define ID_AIC7860			0x6078900400000000ull
#define ID_AIC7860C			0x6078900478609004ull
#define ID_AHA_1480A			0x6075900400000000ull
#define ID_AHA_2940AU_0			0x6178900400000000ull
#define ID_AHA_2940AU_1			0x6178900478619004ull
#define ID_AHA_2940AU_CN		0x2178900478219004ull
#define ID_AHA_2930C_VAR		0x6038900438689004ull

#define ID_AIC7870			0x7078900400000000ull
#define ID_AHA_2940			0x7178900400000000ull
#define ID_AHA_3940			0x7278900400000000ull
#define ID_AHA_398X			0x7378900400000000ull
#define ID_AHA_2944			0x7478900400000000ull
#define ID_AHA_3944			0x7578900400000000ull
#define ID_AHA_4944			0x7678900400000000ull

#define ID_AIC7880			0x8078900400000000ull
#define ID_AIC7880_B			0x8078900478809004ull
#define ID_AHA_2940U			0x8178900400000000ull
#define ID_AHA_3940U			0x8278900400000000ull
#define ID_AHA_2944U			0x8478900400000000ull
#define ID_AHA_3944U			0x8578900400000000ull
#define ID_AHA_398XU			0x8378900400000000ull
#define ID_AHA_4944U			0x8678900400000000ull
#define ID_AHA_2940UB			0x8178900478819004ull
#define ID_AHA_2930U			0x8878900478889004ull
#define ID_AHA_2940U_PRO		0x8778900478879004ull
#define ID_AHA_2940U_CN			0x0078900478009004ull

#define ID_AIC7895			0x7895900478959004ull
#define ID_AIC7895_ARO			0x7890900478939004ull
#define ID_AIC7895_ARO_MASK		0xFFF0FFFFFFFFFFFFull
#define ID_AHA_2940U_DUAL		0x7895900478919004ull
#define ID_AHA_3940AU			0x7895900478929004ull
#define ID_AHA_3944AU			0x7895900478949004ull

#define ID_AIC7890			0x001F9005000F9005ull
#define ID_AIC7890_ARO			0x00139005000F9005ull
#define ID_AAA_131U2			0x0013900500039005ull
#define ID_AHA_2930U2			0x0011900501819005ull
#define ID_AHA_2940U2B			0x00109005A1009005ull
#define ID_AHA_2940U2_OEM		0x0010900521809005ull
#define ID_AHA_2940U2			0x00109005A1809005ull
#define ID_AHA_2950U2B			0x00109005E1009005ull

#define ID_AIC7892			0x008F9005FFFF9005ull
#define ID_AIC7892_ARO			0x00839005FFFF9005ull
#define ID_AHA_2915LP			0x0082900502109005ull
#define ID_AHA_29160			0x00809005E2A09005ull
#define ID_AHA_29160_CPQ		0x00809005E2A00E11ull
#define ID_AHA_29160N			0x0080900562A09005ull
#define ID_AHA_29160C			0x0080900562209005ull
#define ID_AHA_29160B			0x00809005E2209005ull
#define ID_AHA_19160B			0x0081900562A19005ull

#define ID_AIC7896			0x005F9005FFFF9005ull
#define ID_AIC7896_ARO			0x00539005FFFF9005ull
#define ID_AHA_3950U2B_0		0x00509005FFFF9005ull
#define ID_AHA_3950U2B_1		0x00509005F5009005ull
#define ID_AHA_3950U2D_0		0x00519005FFFF9005ull
#define ID_AHA_3950U2D_1		0x00519005B5009005ull

#define ID_AIC7899			0x00CF9005FFFF9005ull
#define ID_AIC7899_ARO			0x00C39005FFFF9005ull
#define ID_AHA_3960D			0x00C09005F6209005ull
#define ID_AHA_3960D_CPQ		0x00C09005F6200E11ull

#define ID_AIC7810			0x1078900400000000ull
#define ID_AIC7815			0x7815900400000000ull

#define DEVID_9005_TYPE(id) ((id) & 0xF)
#define		DEVID_9005_TYPE_HBA		0x0	/* Standard Card */
#define		DEVID_9005_TYPE_AAA		0x3	/* RAID Card */
#define		DEVID_9005_TYPE_SISL		0x5	/* Container ROMB */
#define		DEVID_9005_TYPE_MB		0xF	/* On Motherboard */

#define DEVID_9005_MAXRATE(id) (((id) & 0x30) >> 4)
#define		DEVID_9005_MAXRATE_U160		0x0
#define		DEVID_9005_MAXRATE_ULTRA2	0x1
#define		DEVID_9005_MAXRATE_ULTRA	0x2
#define		DEVID_9005_MAXRATE_FAST		0x3

#define DEVID_9005_MFUNC(id) (((id) & 0x40) >> 6)

#define DEVID_9005_CLASS(id) (((id) & 0xFF00) >> 8)
#define		DEVID_9005_CLASS_SPI		0x0	/* Parallel SCSI */

#define SUBID_9005_TYPE(id) ((id) & 0xF)
#define		SUBID_9005_TYPE_MB		0xF	/* On Motherboard */
#define		SUBID_9005_TYPE_CARD		0x0	/* Standard Card */
#define		SUBID_9005_TYPE_LCCARD		0x1	/* Low Cost Card */
#define		SUBID_9005_TYPE_RAID		0x3	/* Combined with Raid */

#define SUBID_9005_TYPE_KNOWN(id)			\
	  ((((id) & 0xF) == SUBID_9005_TYPE_MB)		\
	|| (((id) & 0xF) == SUBID_9005_TYPE_CARD)	\
	|| (((id) & 0xF) == SUBID_9005_TYPE_LCCARD)	\
	|| (((id) & 0xF) == SUBID_9005_TYPE_RAID))

#define SUBID_9005_MAXRATE(id) (((id) & 0x30) >> 4)
#define		SUBID_9005_MAXRATE_ULTRA2	0x0
#define		SUBID_9005_MAXRATE_ULTRA	0x1
#define		SUBID_9005_MAXRATE_U160		0x2
#define		SUBID_9005_MAXRATE_RESERVED	0x3

#define SUBID_9005_SEEPTYPE(id)						\
	((SUBID_9005_TYPE(id) == SUBID_9005_TYPE_MB)			\
	 ? ((id) & 0xC0) >> 6						\
	 : ((id) & 0x300) >> 8)
#define		SUBID_9005_SEEPTYPE_NONE	0x0
#define		SUBID_9005_SEEPTYPE_1K		0x1
#define		SUBID_9005_SEEPTYPE_2K_4K	0x2
#define		SUBID_9005_SEEPTYPE_RESERVED	0x3
#define SUBID_9005_AUTOTERM(id)						\
	((SUBID_9005_TYPE(id) == SUBID_9005_TYPE_MB)			\
	 ? (((id) & 0x400) >> 10) == 0					\
	 : (((id) & 0x40) >> 6) == 0)

#define SUBID_9005_NUMCHAN(id)						\
	((SUBID_9005_TYPE(id) == SUBID_9005_TYPE_MB)			\
	 ? ((id) & 0x300) >> 8						\
	 : ((id) & 0xC00) >> 10)

#define SUBID_9005_LEGACYCONN(id)					\
	((SUBID_9005_TYPE(id) == SUBID_9005_TYPE_MB)			\
	 ? 0								\
	 : ((id) & 0x80) >> 7)

#define SUBID_9005_MFUNCENB(id)						\
	((SUBID_9005_TYPE(id) == SUBID_9005_TYPE_MB)			\
	 ? ((id) & 0x800) >> 11						\
	 : ((id) & 0x1000) >> 12)
/*
 * Informational only. Should use chip register to be
 * certain, but may be use in identification strings.
 */
#define SUBID_9005_CARD_SCSIWIDTH_MASK	0x2000
#define SUBID_9005_CARD_PCIWIDTH_MASK	0x4000
#define SUBID_9005_CARD_SEDIFF_MASK	0x8000

static ahc_device_setup_t ahc_aic785X_setup;
static ahc_device_setup_t ahc_aic7860_setup;
static ahc_device_setup_t ahc_apa1480_setup;
static ahc_device_setup_t ahc_aic7870_setup;
static ahc_device_setup_t ahc_aha394X_setup;
static ahc_device_setup_t ahc_aha494X_setup;
static ahc_device_setup_t ahc_aha398X_setup;
static ahc_device_setup_t ahc_aic7880_setup;
static ahc_device_setup_t ahc_aha2940Pro_setup;
static ahc_device_setup_t ahc_aha394XU_setup;
static ahc_device_setup_t ahc_aha398XU_setup;
static ahc_device_setup_t ahc_aic7890_setup;
static ahc_device_setup_t ahc_aic7892_setup;
static ahc_device_setup_t ahc_aic7895_setup;
static ahc_device_setup_t ahc_aic7896_setup;
static ahc_device_setup_t ahc_aic7899_setup;
static ahc_device_setup_t ahc_aha29160C_setup;
static ahc_device_setup_t ahc_raid_setup;
static ahc_device_setup_t ahc_aha394XX_setup;
static ahc_device_setup_t ahc_aha494XX_setup;
static ahc_device_setup_t ahc_aha398XX_setup;

struct ahc_pci_identity ahc_pci_ident_table [] =
{
	/* aic7850 based controllers */
	{
		ID_AHA_2902_04_10_15_20_30C,
		ID_ALL_MASK,
		ahc_aic785X_setup
	},
	/* aic7860 based controllers */
	{
		ID_AHA_2930CU,
		ID_ALL_MASK,
		ahc_aic7860_setup
	},
	{
		ID_AHA_1480A & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_apa1480_setup
	},
	{
		ID_AHA_2940AU_0 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7860_setup
	},
	{
		ID_AHA_2940AU_CN & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7860_setup
	},
	{
		ID_AHA_2930C_VAR & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7860_setup
	},
	/* aic7870 based controllers */
	{
		ID_AHA_2940,
		ID_ALL_MASK,
		ahc_aic7870_setup
	},
	{
		ID_AHA_3940,
		ID_ALL_MASK,
		ahc_aha394X_setup
	},
	{
		ID_AHA_398X,
		ID_ALL_MASK,
		ahc_aha398X_setup
	},
	{
		ID_AHA_2944,
		ID_ALL_MASK,
		ahc_aic7870_setup
	},
	{
		ID_AHA_3944,
		ID_ALL_MASK,
		ahc_aha394X_setup
	},
	{
		ID_AHA_4944,
		ID_ALL_MASK,
		ahc_aha494X_setup
	},
	/* aic7880 based controllers */
	{
		ID_AHA_2940U & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7880_setup
	},
	{
		ID_AHA_3940U & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aha394XU_setup
	},
	{
		ID_AHA_2944U & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7880_setup
	},
	{
		ID_AHA_3944U & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aha394XU_setup
	},
	{
		ID_AHA_398XU & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aha398XU_setup
	},
	{
		/*
		 * XXX Don't know the slot numbers
		 * so we can't identify channels
		 */
		ID_AHA_4944U & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7880_setup
	},
	{
		ID_AHA_2930U & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7880_setup
	},
	{
		ID_AHA_2940U_PRO & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aha2940Pro_setup
	},
	{
		ID_AHA_2940U_CN & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7880_setup
	},
	/* Ignore all SISL (AAC on MB) based controllers. */
	{
		ID_9005_SISL_ID,
		ID_9005_SISL_MASK,
		NULL
	},
	/* aic7890 based controllers */
	{
		ID_AHA_2930U2,
		ID_ALL_MASK,
		ahc_aic7890_setup
	},
	{
		ID_AHA_2940U2B,
		ID_ALL_MASK,
		ahc_aic7890_setup
	},
	{
		ID_AHA_2940U2_OEM,
		ID_ALL_MASK,
		ahc_aic7890_setup
	},
	{
		ID_AHA_2940U2,
		ID_ALL_MASK,
		ahc_aic7890_setup
	},
	{
		ID_AHA_2950U2B,
		ID_ALL_MASK,
		ahc_aic7890_setup
	},
	{
		ID_AIC7890_ARO,
		ID_ALL_MASK,
		ahc_aic7890_setup
	},
	{
		ID_AAA_131U2,
		ID_ALL_MASK,
		ahc_aic7890_setup
	},
	/* aic7892 based controllers */
	{
		ID_AHA_29160,
		ID_ALL_MASK,
		ahc_aic7892_setup
	},
	{
		ID_AHA_29160_CPQ,
		ID_ALL_MASK,
		ahc_aic7892_setup
	},
	{
		ID_AHA_29160N,
		ID_ALL_MASK,
		ahc_aic7892_setup
	},
	{
		ID_AHA_29160C,
		ID_ALL_MASK,
		ahc_aha29160C_setup
	},
	{
		ID_AHA_29160B,
		ID_ALL_MASK,
		ahc_aic7892_setup
	},
	{
		ID_AHA_19160B,
		ID_ALL_MASK,
		ahc_aic7892_setup
	},
	{
		ID_AIC7892_ARO,
		ID_ALL_MASK,
		ahc_aic7892_setup
	},
	{
		ID_AHA_2915LP,
		ID_ALL_MASK,
		ahc_aic7892_setup
	},
	/* aic7895 based controllers */	
	{
		ID_AHA_2940U_DUAL,
		ID_ALL_MASK,
		ahc_aic7895_setup
	},
	{
		ID_AHA_3940AU,
		ID_ALL_MASK,
		ahc_aic7895_setup
	},
	{
		ID_AHA_3944AU,
		ID_ALL_MASK,
		ahc_aic7895_setup
	},
	{
		ID_AIC7895_ARO,
		ID_AIC7895_ARO_MASK,
		ahc_aic7895_setup
	},
	/* aic7896/97 based controllers */	
	{
		ID_AHA_3950U2B_0,
		ID_ALL_MASK,
		ahc_aic7896_setup
	},
	{
		ID_AHA_3950U2B_1,
		ID_ALL_MASK,
		ahc_aic7896_setup
	},
	{
		ID_AHA_3950U2D_0,
		ID_ALL_MASK,
		ahc_aic7896_setup
	},
	{
		ID_AHA_3950U2D_1,
		ID_ALL_MASK,
		ahc_aic7896_setup
	},
	{
		ID_AIC7896_ARO,
		ID_ALL_MASK,
		ahc_aic7896_setup
	},
	/* aic7899 based controllers */	
	{
		ID_AHA_3960D,
		ID_ALL_MASK,
		ahc_aic7899_setup
	},
	{
		ID_AHA_3960D_CPQ,
		ID_ALL_MASK,
		ahc_aic7899_setup
	},
	{
		ID_AIC7899_ARO,
		ID_ALL_MASK,
		ahc_aic7899_setup
	},
	/* Generic chip probes for devices we don't know 'exactly' */
	{
		ID_AIC7850 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic785X_setup
	},
	{
		ID_AIC7855 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic785X_setup
	},
	{
		ID_AIC7859 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7860_setup
	},
	{
		ID_AIC7860 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7860_setup
	},
	{
		ID_AIC7870 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7870_setup
	},
	{
		ID_AIC7880 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7880_setup
	},
	{
		ID_AIC7890 & ID_9005_GENERIC_MASK,
		ID_9005_GENERIC_MASK,
		ahc_aic7890_setup
	},
	{
		ID_AIC7892 & ID_9005_GENERIC_MASK,
		ID_9005_GENERIC_MASK,
		ahc_aic7892_setup
	},
	{
		ID_AIC7895 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7895_setup
	},
	{
		ID_AIC7896 & ID_9005_GENERIC_MASK,
		ID_9005_GENERIC_MASK,
		ahc_aic7896_setup
	},
	{
		ID_AIC7899 & ID_9005_GENERIC_MASK,
		ID_9005_GENERIC_MASK,
		ahc_aic7899_setup
	},
	{
		ID_AIC7810 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_raid_setup
	},
	{
		ID_AIC7815 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_raid_setup
	}
};

#define AHC_394X_SLOT_CHANNEL_A	4
#define AHC_394X_SLOT_CHANNEL_B	5

#define AHC_398X_SLOT_CHANNEL_A	4
#define AHC_398X_SLOT_CHANNEL_B	8
#define AHC_398X_SLOT_CHANNEL_C	12

#define AHC_494X_SLOT_CHANNEL_A	4
#define AHC_494X_SLOT_CHANNEL_B	5
#define AHC_494X_SLOT_CHANNEL_C	6
#define AHC_494X_SLOT_CHANNEL_D	7

#define	DEVCONFIG		0x40
#define		PCIERRGENDIS	0x80000000ul
#define		SCBSIZE32	0x00010000ul	/* aic789X only */
#define		REXTVALID	0x00001000ul	/* ultra cards only */
#define		MPORTMODE	0x00000400ul	/* aic7870+ only */
#define		RAMPSM		0x00000200ul	/* aic7870+ only */
#define		VOLSENSE	0x00000100ul
#define		PCI64BIT	0x00000080ul	/* 64Bit PCI bus (Ultra2 Only)*/
#define		SCBRAMSEL	0x00000080ul
#define		MRDCEN		0x00000040ul
#define		EXTSCBTIME	0x00000020ul	/* aic7870 only */
#define		EXTSCBPEN	0x00000010ul	/* aic7870 only */
#define		BERREN		0x00000008ul
#define		DACEN		0x00000004ul
#define		STPWLEVEL	0x00000002ul
#define		DIFACTNEGEN	0x00000001ul	/* aic7870 only */

#define	CSIZE_LATTIME		0x0c
#define		CACHESIZE	0x0000003ful	/* only 5 bits */
#define		LATTIME		0x0000ff00ul

/* PCI STATUS definitions */
#define	DPE	0x80
#define SSE	0x40
#define	RMA	0x20
#define	RTA	0x10
#define STA	0x08
#define DPR	0x01

static int ahc_9005_subdevinfo_valid(uint16_t vendor, uint16_t device,
				     uint16_t subvendor, uint16_t subdevice);
static int ahc_ext_scbram_present(struct ahc_softc *ahc);
static void ahc_scbram_config(struct ahc_softc *ahc, int enable,
				  int pcheck, int fast, int large);
static void ahc_probe_ext_scbram(struct ahc_softc *ahc);
static int  ahc_pci_chip_init(struct ahc_softc *ahc);

int ahc_pci_probe(struct device *, void *, void *);
void ahc_pci_attach(struct device *, struct device *, void *);


struct cfattach ahc_pci_ca = {
	sizeof(struct ahc_softc), ahc_pci_probe, ahc_pci_attach
};

const struct ahc_pci_identity *
ahc_find_pci_device(id, subid, func)
	pcireg_t id, subid;
	u_int func;
{
	u_int64_t  full_id;
	const struct	   ahc_pci_identity *entry;
	u_int	   i;

	full_id = ahc_compose_id(PCI_PRODUCT(id), PCI_VENDOR(id),
				 PCI_PRODUCT(subid), PCI_VENDOR(subid));

	/*
	 * If the second function is not hooked up, ignore it.
	 * Unfortunately, not all MB vendors implement the
	 * subdevice ID as per the Adaptec spec, so do our best
	 * to sanity check it prior to accepting the subdevice
	 * ID as valid.
	 */
	if (func > 0
	    && ahc_9005_subdevinfo_valid(PCI_VENDOR(id), PCI_PRODUCT(id), 
					 PCI_VENDOR(subid), PCI_PRODUCT(subid))
	    && SUBID_9005_MFUNCENB(PCI_PRODUCT(subid)) == 0)
		return (NULL);

	for (i = 0; i < NUM_ELEMENTS(ahc_pci_ident_table); i++) {
		entry = &ahc_pci_ident_table[i];
		if (entry->full_id == (full_id & entry->id_mask))
			return (entry);
	}
	return (NULL);
}

int
ahc_pci_probe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct pci_attach_args *pa = aux;
	const struct	   ahc_pci_identity *entry;
	pcireg_t   subid;

	subid = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);
	entry = ahc_find_pci_device(pa->pa_id, subid, pa->pa_function);
	return (entry != NULL && entry->setup != NULL) ? 1 : 0;
}

void
ahc_pci_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pci_attach_args *pa = aux;
	const struct	   ahc_pci_identity *entry;
	struct		   ahc_softc *ahc = (void *)self;
	pcireg_t	   command;
	u_int		   our_id = 0;
	u_int		   sxfrctl1;
	u_int		   scsiseq;
	u_int		   sblkctl;
	uint8_t 	   dscommand0;
	uint32_t	   devconfig;
	int		   error;
	pcireg_t	   subid;
	int		   ioh_valid;
	bus_space_tag_t    st, iot;
	bus_space_handle_t sh, ioh;
#ifdef AHC_ALLOW_MEMIO
	int		   memh_valid;
	bus_space_tag_t    memt;
	bus_space_handle_t memh;
	pcireg_t memtype;
#endif
	pci_intr_handle_t  ih;
	const char        *intrstr;
	struct ahc_pci_busdata *bd;
	int i;

	/*
	 * Instead of ahc_alloc() as in FreeBSD, do the few relevant
	 * initializations manually.
	 */
	LIST_INIT(&ahc->pending_scbs);
	ahc->channel = 'A';
	ahc->seqctl = FASTMODE;
	for (i = 0; i < AHC_NUM_TARGETS; i++)
		TAILQ_INIT(&ahc->untagged_queues[i]);

	/*
	 * SCSI_IS_SCSIBUS_B() must returns false until sc_channel_b
	 * has been properly initialized. XXX Breaks if >254 scsi buses.
	 */
	ahc->sc_channel_b.scsibus = 0xff;

	ahc->dev_softc = pa;

	ahc_set_name(ahc, ahc->sc_dev.dv_xname);
	ahc->parent_dmat = pa->pa_dmat;

	subid = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);
	entry = ahc_find_pci_device(pa->pa_id, subid, pa->pa_function);
	if (entry == NULL)
		return;

	/* Keep information about the PCI bus */
	bd = malloc(sizeof (struct ahc_pci_busdata), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (bd == NULL) {
		printf("%s: unable to allocate bus-specific data\n",
		    ahc_name(ahc));
		return;
	}

	bd->pc = pa->pa_pc;
	bd->tag = pa->pa_tag;
	bd->func = pa->pa_function;
	bd->dev = pa->pa_device;
	bd->class = pa->pa_class;

	ahc->bd = bd;

	error = entry->setup(ahc);
	if (error != 0)
		return;

	ioh_valid = 0;

#ifdef AHC_ALLOW_MEMIO
	memh_valid = 0;
	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, AHC_PCI_MEMADDR);
	switch (memtype) {
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
		memh_valid = (pci_mapreg_map(pa, AHC_PCI_MEMADDR,
					     memtype, 0, &memt, &memh, NULL, NULL, 0) == 0);
		break;
	default:
		memh_valid = 0;
	}
	if (memh_valid == 0)
#endif
		ioh_valid = (pci_mapreg_map(pa, AHC_PCI_IOADDR,
		    PCI_MAPREG_TYPE_IO, 0, &iot, &ioh, NULL, NULL, 0) == 0);
#if 0
	printf("%s: mem mapping: memt 0x%lx, memh 0x%lx, iot 0x%lx, ioh 0x%lx\n",
	       ahc_name(ahc), (u_long)memt, memh, (u_long)iot, ioh);
#endif

	if (ioh_valid) {
		st = iot;
		sh = ioh;
#ifdef AHC_ALLOW_MEMIO
	} else if (memh_valid) {
		st = memt;
		sh = memh;
#endif
	} else {
		printf(": unable to map registers\n");
		return;
	}
	ahc->tag = st;
	ahc->bsh = sh;

	ahc->chip |= AHC_PCI;
	/*
	 * Before we continue probing the card, ensure that
	 * its interrupts are *disabled*.  We don't want
	 * a misstep to hang the machine in an interrupt
	 * storm.
	 */
	ahc_intr_enable(ahc, FALSE);

	/*
	 * XXX somehow reading this once fails on some sparc64 systems.
	 *     This may be a problem in the sparc64 PCI code. Doing it
	 *     twice works around it.
	 */
	devconfig = pci_conf_read(pa->pa_pc, pa->pa_tag, DEVCONFIG);
	devconfig = pci_conf_read(pa->pa_pc, pa->pa_tag, DEVCONFIG);

	/*
	 * If we need to support high memory, enable dual
	 * address cycles.  This bit must be set to enable
	 * high address bit generation even if we are on a
	 * 64bit bus (PCI64BIT set in devconfig).
	 */
	if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {

		if (1/*bootverbose*/)
			printf("%s: Enabling 39Bit Addressing\n",
			       ahc_name(ahc));
		devconfig |= DACEN;
	}
	
	/* Ensure that pci error generation, a test feature, is disabled. */
	devconfig |= PCIERRGENDIS;

	pci_conf_write(pa->pa_pc, pa->pa_tag, DEVCONFIG, devconfig);

	/*
	 * Disable PCI parity error reporting.  Users typically
	 * do this to work around broken PCI chipsets that get
	 * the parity timing wrong and thus generate lots of spurious
	 * errors.
	 */
	if ((ahc->flags & AHC_DISABLE_PCI_PERR) != 0) {
		command = pci_conf_read(pa->pa_pc, pa->pa_tag,
		    PCI_COMMAND_STATUS_REG);
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
		    command & ~PCI_COMMAND_PARITY_ENABLE);
	}

	/* On all PCI adapters, we allow SCB paging */
	ahc->flags |= AHC_PAGESCBS;
	error = ahc_softc_init(ahc);
	if (error != 0)
		goto error_out;

	ahc->bus_intr = ahc_pci_intr;
	ahc->bus_chip_init = ahc_pci_chip_init;

	/* Remember how the card was setup in case there is no SEEPROM */
	if ((ahc_inb(ahc, HCNTRL) & POWRDN) == 0) {
		ahc_pause(ahc);
		if ((ahc->features & AHC_ULTRA2) != 0)
			our_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;
		else
			our_id = ahc_inb(ahc, SCSIID) & OID;
		sxfrctl1 = ahc_inb(ahc, SXFRCTL1) & STPWEN;
		scsiseq = ahc_inb(ahc, SCSISEQ);
	} else {
		sxfrctl1 = STPWEN;
		our_id = 7;
		scsiseq = 0;
	}

	error = ahc_reset(ahc, /*reinit*/FALSE);
	if (error != 0)
		goto error_out;

	if ((ahc->features & AHC_DT) != 0) {
		u_int sfunct;

		/* Perform ALT-Mode Setup */
		sfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;
		ahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);
		ahc_outb(ahc, OPTIONMODE,
			 OPTIONMODE_DEFAULTS|AUTOACKEN|BUSFREEREV|EXPPHASEDIS);
		ahc_outb(ahc, SFUNCT, sfunct);

		/* Normal mode setup */
		ahc_outb(ahc, CRCCONTROL1, CRCVALCHKEN|CRCENDCHKEN|CRCREQCHKEN
					  |TARGCRCENDEN);
	}

	if (pci_intr_map(pa, &ih)) {
		printf("%s: couldn't map interrupt\n", ahc_name(ahc));
		ahc_free(ahc);
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	ahc->ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO,
	    ahc_platform_intr, ahc, ahc->sc_dev.dv_xname);
	if (ahc->ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		ahc_free(ahc);
		return;
	} else
		printf(": %s\n", intrstr ? intrstr : "?");

	dscommand0 = ahc_inb(ahc, DSCOMMAND0);
	dscommand0 |= MPARCKEN|CACHETHEN;
	if ((ahc->features & AHC_ULTRA2) != 0) {

		/*
		 * DPARCKEN doesn't work correctly on
		 * some MBs so don't use it.
		 */
		dscommand0 &= ~DPARCKEN;
	}

	/*
	 * Handle chips that must have cache line
	 * streaming (dis/en)abled.
	 */
	if ((ahc->bugs & AHC_CACHETHEN_DIS_BUG) != 0)
		dscommand0 |= CACHETHEN;

	if ((ahc->bugs & AHC_CACHETHEN_BUG) != 0)
		dscommand0 &= ~CACHETHEN;

	ahc_outb(ahc, DSCOMMAND0, dscommand0);

	ahc->pci_cachesize =
	    pci_conf_read(pa->pa_pc, pa->pa_tag, CSIZE_LATTIME) & CACHESIZE;
	ahc->pci_cachesize *= 4;

	if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0
	    && ahc->pci_cachesize == 4) {
		pci_conf_write(pa->pa_pc, pa->pa_tag, CSIZE_LATTIME, 0);
		ahc->pci_cachesize = 0;
	}

	/*
	 * We cannot perform ULTRA speeds without the presence
	 * of the external precision resistor.
	 */
	if ((ahc->features & AHC_ULTRA) != 0) {
		uint32_t devconfig;

		devconfig = pci_conf_read(pa->pa_pc, pa->pa_tag, DEVCONFIG);
		if ((devconfig & REXTVALID) == 0)
			ahc->features &= ~AHC_ULTRA;
	}

	ahc->seep_config = malloc(sizeof(*ahc->seep_config), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (ahc->seep_config == NULL)
		goto error_out;
	
	/* See if we have a SEEPROM and perform auto-term */
	ahc_check_extport(ahc, &sxfrctl1);

	/*
	 * Take the LED out of diagnostic mode
	 */
	sblkctl = ahc_inb(ahc, SBLKCTL);
	ahc_outb(ahc, SBLKCTL, (sblkctl & ~(DIAGLEDEN|DIAGLEDON)));

	if ((ahc->features & AHC_ULTRA2) != 0) {
		ahc_outb(ahc, DFF_THRSH, RD_DFTHRSH_MAX|WR_DFTHRSH_MAX);
	} else {
		ahc_outb(ahc, DSPCISTATUS, DFTHRSH_100);
	}

	if (ahc->flags & AHC_USEDEFAULTS) {
		/*
		 * PCI Adapter default setup
		 * Should only be used if the adapter does not have
		 * a SEEPROM.
		 */
		/* See if someone else set us up already */
		if ((ahc->flags & AHC_NO_BIOS_INIT) == 0
		 && scsiseq != 0) {
			printf("%s: Using left over BIOS settings\n",
				ahc_name(ahc));
			ahc->flags &= ~AHC_USEDEFAULTS;
			ahc->flags |= AHC_BIOS_ENABLED;
		} else {
			/*
			 * Assume only one connector and always turn
			 * on termination.
			 */
 			our_id = 0x07;
			sxfrctl1 = STPWEN;
		}
		ahc_outb(ahc, SCSICONF, our_id|ENSPCHK|RESET_SCSI);

		ahc->our_id = our_id;
	}

	/*
	 * Take a look to see if we have external SRAM.
	 * We currently do not attempt to use SRAM that is
	 * shared among multiple controllers.
	 */
	ahc_probe_ext_scbram(ahc);

	/*
	 * Record our termination setting for the
	 * generic initialization routine.
	 */
	if ((sxfrctl1 & STPWEN) != 0)
		ahc->flags |= AHC_TERM_ENB_A;

	/*
	 * Save chip register configuration data for chip resets
	 * that occur during runtime and resume events.
	 */
	ahc->bus_softc.pci_softc.devconfig =
	    pci_conf_read(pa->pa_pc, pa->pa_tag, DEVCONFIG);
	ahc->bus_softc.pci_softc.command =
	    pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	ahc->bus_softc.pci_softc.csize_lattime =
	    pci_conf_read(pa->pa_pc, pa->pa_tag, CSIZE_LATTIME);
	ahc->bus_softc.pci_softc.dscommand0 = ahc_inb(ahc, DSCOMMAND0);
	ahc->bus_softc.pci_softc.dspcistatus = ahc_inb(ahc, DSPCISTATUS);
	if ((ahc->features & AHC_DT) != 0) {
		u_int sfunct;

		sfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;
		ahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);
		ahc->bus_softc.pci_softc.optionmode = ahc_inb(ahc, OPTIONMODE);
		ahc->bus_softc.pci_softc.targcrccnt = ahc_inw(ahc, TARGCRCCNT);
		ahc_outb(ahc, SFUNCT, sfunct);
		ahc->bus_softc.pci_softc.crccontrol1 =
		    ahc_inb(ahc, CRCCONTROL1);
	}
	if ((ahc->features & AHC_MULTI_FUNC) != 0)
		ahc->bus_softc.pci_softc.scbbaddr = ahc_inb(ahc, SCBBADDR);

	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc->bus_softc.pci_softc.dff_thrsh = ahc_inb(ahc, DFF_THRSH);

	/* Core initialization */
	if (ahc_init(ahc))
		goto error_out;

	ahc_attach(ahc);

	return;

 error_out:
	ahc_free(ahc);
	return;
}

static int
ahc_9005_subdevinfo_valid(uint16_t device, uint16_t vendor,
			  uint16_t subdevice, uint16_t subvendor)
{
	int result;

	/* Default to invalid. */
	result = 0;
	if (vendor == 0x9005
	 && subvendor == 0x9005
         && subdevice != device
         && SUBID_9005_TYPE_KNOWN(subdevice) != 0) {

		switch (SUBID_9005_TYPE(subdevice)) {
		case SUBID_9005_TYPE_MB:
			break;
		case SUBID_9005_TYPE_CARD:
		case SUBID_9005_TYPE_LCCARD:
			/*
			 * Currently only trust Adaptec cards to
			 * get the sub device info correct.
			 */
			if (DEVID_9005_TYPE(device) == DEVID_9005_TYPE_HBA)
				result = 1;
			break;
		case SUBID_9005_TYPE_RAID:
			break;
		default:
			break;
		}
	}
	return (result);
}


/*
 * Test for the presense of external sram in an
 * "unshared" configuration.
 */
static int
ahc_ext_scbram_present(struct ahc_softc *ahc)
{
	u_int chip;
	int ramps;
	int single_user;
	uint32_t devconfig;

	chip = ahc->chip & AHC_CHIPID_MASK;
	devconfig = pci_conf_read(ahc->bd->pc, ahc->bd->tag, DEVCONFIG);
	single_user = (devconfig & MPORTMODE) != 0;

	if ((ahc->features & AHC_ULTRA2) != 0)
		ramps = (ahc_inb(ahc, DSCOMMAND0) & RAMPS) != 0;
	else if (chip == AHC_AIC7895 || chip == AHC_AIC7895C)
		/*
		 * External SCBRAM arbitration is flakey
		 * on these chips.  Unfortunately this means
		 * we don't use the extra SCB ram space on the
		 * 3940AUW.
		 */
		ramps = 0;
	else if (chip >= AHC_AIC7870)
		ramps = (devconfig & RAMPSM) != 0;
	else
		ramps = 0;

	if (ramps && single_user)
		return (1);
	return (0);
}

/*
 * Enable external scbram.
 */
static void
ahc_scbram_config(struct ahc_softc *ahc, int enable, int pcheck,
		  int fast, int large)
{
	uint32_t devconfig;

	if (ahc->features & AHC_MULTI_FUNC) {
		/*
		 * Set the SCB Base addr (highest address bit)
		 * depending on which channel we are.
		 */
		ahc_outb(ahc, SCBBADDR, ahc->bd->func);
	}

	ahc->flags &= ~AHC_LSCBS_ENABLED;
	if (large)
		ahc->flags |= AHC_LSCBS_ENABLED;
	devconfig = pci_conf_read(ahc->bd->pc, ahc->bd->tag, DEVCONFIG);
	if ((ahc->features & AHC_ULTRA2) != 0) {
		u_int dscommand0;

		dscommand0 = ahc_inb(ahc, DSCOMMAND0);
		if (enable)
			dscommand0 &= ~INTSCBRAMSEL;
		else
			dscommand0 |= INTSCBRAMSEL;
		if (large)
			dscommand0 &= ~USCBSIZE32;
		else
			dscommand0 |= USCBSIZE32;
		ahc_outb(ahc, DSCOMMAND0, dscommand0);
	} else {
		if (fast)
			devconfig &= ~EXTSCBTIME;
		else
			devconfig |= EXTSCBTIME;
		if (enable)
			devconfig &= ~SCBRAMSEL;
		else
			devconfig |= SCBRAMSEL;
		if (large)
			devconfig &= ~SCBSIZE32;
		else
			devconfig |= SCBSIZE32;
	}
	if (pcheck)
		devconfig |= EXTSCBPEN;
	else
		devconfig &= ~EXTSCBPEN;

	pci_conf_write(ahc->bd->pc, ahc->bd->tag, DEVCONFIG, devconfig);
}

/*
 * Take a look to see if we have external SRAM.
 * We currently do not attempt to use SRAM that is
 * shared among multiple controllers.
 */
static void
ahc_probe_ext_scbram(struct ahc_softc *ahc)
{
	int num_scbs;
	int test_num_scbs;
	int enable;
	int pcheck;
	int fast;
	int large;

	enable = FALSE;
	pcheck = FALSE;
	fast = FALSE;
	large = FALSE;
	num_scbs = 0;
	
	if (ahc_ext_scbram_present(ahc) == 0)
		goto done;

	/*
	 * Probe for the best parameters to use.
	 */
	ahc_scbram_config(ahc, /*enable*/TRUE, pcheck, fast, large);
	num_scbs = ahc_probe_scbs(ahc);
	if (num_scbs == 0) {
		/* The SRAM wasn't really present. */
		goto done;
	}
	enable = TRUE;

	/*
	 * Clear any outstanding parity error
	 * and ensure that parity error reporting
	 * is enabled.
	 */
	ahc_outb(ahc, SEQCTL, 0);
	ahc_outb(ahc, CLRINT, CLRPARERR);
	ahc_outb(ahc, CLRINT, CLRBRKADRINT);

	/* Now see if we can do parity */
	ahc_scbram_config(ahc, enable, /*pcheck*/TRUE, fast, large);
	num_scbs = ahc_probe_scbs(ahc);
	if ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0
	 || (ahc_inb(ahc, ERROR) & MPARERR) == 0)
		pcheck = TRUE;

	/* Clear any resulting parity error */
	ahc_outb(ahc, CLRINT, CLRPARERR);
	ahc_outb(ahc, CLRINT, CLRBRKADRINT);

	/* Now see if we can do fast timing */
	ahc_scbram_config(ahc, enable, pcheck, /*fast*/TRUE, large);
	test_num_scbs = ahc_probe_scbs(ahc);
	if (test_num_scbs == num_scbs
	 && ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0
	  || (ahc_inb(ahc, ERROR) & MPARERR) == 0))
		fast = TRUE;

	/*
	 * See if we can use large SCBs and still maintain
	 * the same overall count of SCBs.
	 */
	if ((ahc->features & AHC_LARGE_SCBS) != 0) {
		ahc_scbram_config(ahc, enable, pcheck, fast, /*large*/TRUE);
		test_num_scbs = ahc_probe_scbs(ahc);
		if (test_num_scbs >= num_scbs) {
			large = TRUE;
			num_scbs = test_num_scbs;
	 		if (num_scbs >= 64) {
				/*
				 * We have enough space to move the
				 * "busy targets table" into SCB space
				 * and make it qualify all the way to the
				 * lun level.
				 */
				ahc->flags |= AHC_SCB_BTT;
			}
		}
	}
done:
	/*
	 * Disable parity error reporting until we
	 * can load instruction ram.
	 */
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS);
	/* Clear any latched parity error */
	ahc_outb(ahc, CLRINT, CLRPARERR);
	ahc_outb(ahc, CLRINT, CLRBRKADRINT);
	if (1/*bootverbose*/ && enable) {
		printf("%s: External SRAM, %s access%s, %dbytes/SCB\n",
		       ahc_name(ahc), fast ? "fast" : "slow", 
		       pcheck ? ", parity checking enabled" : "",
		       large ? 64 : 32);
	}
	ahc_scbram_config(ahc, enable, pcheck, fast, large);
}

#if 0
/*
 * Perform some simple tests that should catch situations where
 * our registers are invalidly mapped.
 */
int
ahc_pci_test_register_access(struct ahc_softc *ahc)
{
	int	 error;
	u_int	 status1;
	uint32_t cmd;
	uint8_t	 hcntrl;

	error = EIO;

	/*
	 * Enable PCI error interrupt status, but suppress NMIs
	 * generated by SERR raised due to target aborts.
	 */
	cmd = pci_conf_read(ahc->bd->pc, ahc->bd->tag, PCIR_COMMAND);
	pci_conf_write(ahc->bd->pc, ahc->bd->tag, PCIR_COMMAND,
		       cmd & ~PCIM_CMD_SERRESPEN);

	/*
	 * First a simple test to see if any
	 * registers can be read.  Reading
	 * HCNTRL has no side effects and has
	 * at least one bit that is guaranteed to
	 * be zero so it is a good register to
	 * use for this test.
	 */
	hcntrl = ahc_inb(ahc, HCNTRL);
	if (hcntrl == 0xFF)
		goto fail;

	/*
	 * Next create a situation where write combining
	 * or read prefetching could be initiated by the
	 * CPU or host bridge.  Our device does not support
	 * either, so look for data corruption and/or flagged
	 * PCI errors.
	 */
	ahc_outb(ahc, HCNTRL, hcntrl|PAUSE);
	while (ahc_is_paused(ahc) == 0)
		;
	ahc_outb(ahc, SEQCTL, PERRORDIS);
	ahc_outb(ahc, SCBPTR, 0);
	ahc_outl(ahc, SCB_BASE, 0x5aa555aa);
	if (ahc_inl(ahc, SCB_BASE) != 0x5aa555aa)
		goto fail;

	status1 = pci_conf_read(ahc->bd->pc, ahc->bd->tag,
				PCI_COMMAND_STATUS_REG + 1);
	if ((status1 & STA) != 0)
		goto fail;

	error = 0;

fail:
	/* Silently clear any latched errors. */
	status1 = pci_conf_read(ahc->bd->pc, ahc->bd->tag, PCI_COMMAND_STATUS_REG + 1);
	ahc_pci_write_config(ahc->dev_softc, PCIR_STATUS + 1,
			     status1, /*bytes*/1);
	ahc_outb(ahc, CLRINT, CLRPARERR);
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS);
	ahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND, cmd, /*bytes*/2);
	return (error);
}
#endif

void
ahc_pci_intr(struct ahc_softc *ahc)
{
	u_int error;
	u_int status1;

	error = ahc_inb(ahc, ERROR);
	if ((error & PCIERRSTAT) == 0)
		return;

	status1 = pci_conf_read(ahc->bd->pc, ahc->bd->tag, PCI_COMMAND_STATUS_REG);

	printf("%s: PCI error Interrupt at seqaddr = 0x%x\n",
	      ahc_name(ahc),
	      ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));

	if (status1 & DPE) {
		printf("%s: Data Parity Error Detected during address "
		       "or write data phase\n", ahc_name(ahc));
	}
	if (status1 & SSE) {
		printf("%s: Signal System Error Detected\n", ahc_name(ahc));
	}
	if (status1 & RMA) {
		printf("%s: Received a Master Abort\n", ahc_name(ahc));
	}
	if (status1 & RTA) {
		printf("%s: Received a Target Abort\n", ahc_name(ahc));
	}
	if (status1 & STA) {
		printf("%s: Signaled a Target Abort\n", ahc_name(ahc));
	}
	if (status1 & DPR) {
		printf("%s: Data Parity Error has been reported via PERR#\n",
		       ahc_name(ahc));
	}

	/* Clear latched errors. */
	pci_conf_write(ahc->bd->pc, ahc->bd->tag,  PCI_COMMAND_STATUS_REG, status1);

	if ((status1 & (DPE|SSE|RMA|RTA|STA|DPR)) == 0) {
		printf("%s: Latched PCIERR interrupt with "
		       "no status bits set\n", ahc_name(ahc)); 
	} else {
		ahc_outb(ahc, CLRINT, CLRPARERR);
	}

	ahc_unpause(ahc);
}

static int
ahc_pci_chip_init(struct ahc_softc *ahc)
{
	ahc_outb(ahc, DSCOMMAND0, ahc->bus_softc.pci_softc.dscommand0);
	ahc_outb(ahc, DSPCISTATUS, ahc->bus_softc.pci_softc.dspcistatus);
	if ((ahc->features & AHC_DT) != 0) {
		u_int sfunct;

		sfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;
		ahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);
		ahc_outb(ahc, OPTIONMODE, ahc->bus_softc.pci_softc.optionmode);
		ahc_outw(ahc, TARGCRCCNT, ahc->bus_softc.pci_softc.targcrccnt);
		ahc_outb(ahc, SFUNCT, sfunct);
		ahc_outb(ahc, CRCCONTROL1,
			 ahc->bus_softc.pci_softc.crccontrol1);
	}
	if ((ahc->features & AHC_MULTI_FUNC) != 0)
		ahc_outb(ahc, SCBBADDR, ahc->bus_softc.pci_softc.scbbaddr);

	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, DFF_THRSH, ahc->bus_softc.pci_softc.dff_thrsh);

	return (ahc_chip_init(ahc));
}

static int
ahc_aic785X_setup(struct ahc_softc *ahc)
{
	uint8_t rev;

	ahc->channel = 'A';
	ahc->chip = AHC_AIC7850;
	ahc->features = AHC_AIC7850_FE;
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
	rev = PCI_REVISION(ahc->bd->class);
	if (rev >= 1)
		ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
	ahc->instruction_ram_size = 512;
	return (0);
}

static int
ahc_aic7860_setup(struct ahc_softc *ahc)
{
	uint8_t rev;

	ahc->channel = 'A';
	ahc->chip = AHC_AIC7860;
	ahc->features = AHC_AIC7860_FE;
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
	rev = PCI_REVISION(ahc->bd->class);
	if (rev >= 1)
		ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
	ahc->instruction_ram_size = 512;
	return (0);
}

static int
ahc_apa1480_setup(struct ahc_softc *ahc)
{
	int error;

	error = ahc_aic7860_setup(ahc);
	if (error != 0)
		return (error);
	ahc->features |= AHC_REMOVABLE;
	return (0);
}

static int
ahc_aic7870_setup(struct ahc_softc *ahc)
{

	ahc->channel = 'A';
	ahc->chip = AHC_AIC7870;
	ahc->features = AHC_AIC7870_FE;
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
	ahc->instruction_ram_size = 512;
	return (0);
}

static int
ahc_aha394X_setup(struct ahc_softc *ahc)
{
	int error;

	error = ahc_aic7870_setup(ahc);
	if (error == 0)
		error = ahc_aha394XX_setup(ahc);
	return (error);
}

static int
ahc_aha398X_setup(struct ahc_softc *ahc)
{
	int error;

	error = ahc_aic7870_setup(ahc);
	if (error == 0)
		error = ahc_aha398XX_setup(ahc);
	return (error);
}

static int
ahc_aha494X_setup(struct ahc_softc *ahc)
{
	int error;

	error = ahc_aic7870_setup(ahc);
	if (error == 0)
		error = ahc_aha494XX_setup(ahc);
	return (error);
}

static int
ahc_aic7880_setup(struct ahc_softc *ahc)
{
	uint8_t rev;

	ahc->channel = 'A';
	ahc->chip = AHC_AIC7880;
	ahc->features = AHC_AIC7880_FE;
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
	rev = PCI_REVISION(ahc->bd->class);
	if (rev >= 1) {
		ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
	} else {
		ahc->bugs |= AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
	}
	ahc->instruction_ram_size = 512;
	return (0);
}

static int
ahc_aha2940Pro_setup(struct ahc_softc *ahc)
{

	ahc->flags |= AHC_INT50_SPEEDFLEX;
	return (ahc_aic7880_setup(ahc));
}

static int
ahc_aha394XU_setup(struct ahc_softc *ahc)
{
	int error;

	error = ahc_aic7880_setup(ahc);
	if (error == 0)
		error = ahc_aha394XX_setup(ahc);
	return (error);
}

static int
ahc_aha398XU_setup(struct ahc_softc *ahc)
{
	int error;

	error = ahc_aic7880_setup(ahc);
	if (error == 0)
		error = ahc_aha398XX_setup(ahc);
	return (error);
}

static int
ahc_aic7890_setup(struct ahc_softc *ahc)
{
	uint8_t rev;

	ahc->channel = 'A';
	ahc->chip = AHC_AIC7890;
	ahc->features = AHC_AIC7890_FE;
	ahc->flags |= AHC_NEWEEPROM_FMT;
	rev = PCI_REVISION(ahc->bd->class);
	if (rev == 0)
		ahc->bugs |= AHC_AUTOFLUSH_BUG|AHC_CACHETHEN_BUG;
	ahc->instruction_ram_size = 768;
	return (0);
}

static int
ahc_aic7892_setup(struct ahc_softc *ahc)
{

	ahc->channel = 'A';
	ahc->chip = AHC_AIC7892;
	ahc->features = AHC_AIC7892_FE;
	ahc->flags |= AHC_NEWEEPROM_FMT;
	ahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;
	ahc->instruction_ram_size = 1024;
	return (0);
}

static int
ahc_aic7895_setup(struct ahc_softc *ahc)
{
	uint8_t rev;

	ahc->channel = (ahc->bd->func == 1) ? 'B' : 'A';
	/*
	 * The 'C' revision of the aic7895 has a few additional features.
	 */
	rev = PCI_REVISION(ahc->bd->class);
	if (rev >= 4) {
		ahc->chip = AHC_AIC7895C;
		ahc->features = AHC_AIC7895C_FE;
	} else  {
		u_int command;

		ahc->chip = AHC_AIC7895;
		ahc->features = AHC_AIC7895_FE;

		/*
		 * The BIOS disables the use of MWI transactions
		 * since it does not have the MWI bug work around
		 * we have.  Disabling MWI reduces performance, so
		 * turn it on again.
		 */
		command = pci_conf_read(ahc->bd->pc, ahc->bd->tag, PCI_COMMAND_STATUS_REG);
		command |=  PCI_COMMAND_INVALIDATE_ENABLE;
		pci_conf_write(ahc->bd->pc, ahc->bd->tag, PCI_COMMAND_STATUS_REG, command);
		ahc->bugs |= AHC_PCI_MWI_BUG;
	}
	/*
	 * XXX Does CACHETHEN really not work???  What about PCI retry?
	 * on C level chips.  Need to test, but for now, play it safe.
	 */
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_PCI_2_1_RETRY_BUG
		  |  AHC_CACHETHEN_BUG;

#if 0
	uint32_t devconfig;

	/*
	 * Cachesize must also be zero due to stray DAC
	 * problem when sitting behind some bridges.
	 */
	pci_conf_write(ahc->bd->pc, ahc->bd->tag, CSIZE_LATTIME, 0);
	devconfig = pci_conf_read(ahc->bd->pc, ahc->bd->tag, DEVCONFIG);
	devconfig |= MRDCEN;
	pci_conf_write(ahc->bd->pc, ahc->bd->tag, DEVCONFIG, devconfig);
#endif
	ahc->flags |= AHC_NEWEEPROM_FMT;
	ahc->instruction_ram_size = 512;
	return (0);
}

static int
ahc_aic7896_setup(struct ahc_softc *ahc)
{
	ahc->channel = (ahc->bd->func == 1) ? 'B' : 'A';
	ahc->chip = AHC_AIC7896;
	ahc->features = AHC_AIC7896_FE;
	ahc->flags |= AHC_NEWEEPROM_FMT;
	ahc->bugs |= AHC_CACHETHEN_DIS_BUG;
	ahc->instruction_ram_size = 768;
	return (0);
}

static int
ahc_aic7899_setup(struct ahc_softc *ahc)
{
	ahc->channel = (ahc->bd->func == 1) ? 'B' : 'A';
	ahc->chip = AHC_AIC7899;
	ahc->features = AHC_AIC7899_FE;
	ahc->flags |= AHC_NEWEEPROM_FMT;
	ahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;
	ahc->instruction_ram_size = 1024;
	return (0);
}

static int
ahc_aha29160C_setup(struct ahc_softc *ahc)
{
	int error;

	error = ahc_aic7899_setup(ahc);
	if (error != 0)
		return (error);
	ahc->features |= AHC_REMOVABLE;
	return (0);
}

static int
ahc_raid_setup(struct ahc_softc *ahc)
{
	printf("RAID functionality unsupported\n");
	return (ENXIO);
}

static int
ahc_aha394XX_setup(struct ahc_softc *ahc)
{

	switch (ahc->bd->dev) {
	case AHC_394X_SLOT_CHANNEL_A:
		ahc->channel = 'A';
		break;
	case AHC_394X_SLOT_CHANNEL_B:
		ahc->channel = 'B';
		break;
	default:
		printf("adapter at unexpected slot %d\n"
		       "unable to map to a channel\n",
		       ahc->bd->dev);
		ahc->channel = 'A';
	}
	return (0);
}

static int
ahc_aha398XX_setup(struct ahc_softc *ahc)
{

	switch (ahc->bd->dev) {
	case AHC_398X_SLOT_CHANNEL_A:
		ahc->channel = 'A';
		break;
	case AHC_398X_SLOT_CHANNEL_B:
		ahc->channel = 'B';
		break;
	case AHC_398X_SLOT_CHANNEL_C:
		ahc->channel = 'C';
		break;
	default:
		printf("adapter at unexpected slot %d\n"
		       "unable to map to a channel\n",
		       ahc->bd->dev);
		ahc->channel = 'A';
		break;
	}
	ahc->flags |= AHC_LARGE_SEEPROM;
	return (0);
}

static int
ahc_aha494XX_setup(struct ahc_softc *ahc)
{

	switch (ahc->bd->dev) {
	case AHC_494X_SLOT_CHANNEL_A:
		ahc->channel = 'A';
		break;
	case AHC_494X_SLOT_CHANNEL_B:
		ahc->channel = 'B';
		break;
	case AHC_494X_SLOT_CHANNEL_C:
		ahc->channel = 'C';
		break;
	case AHC_494X_SLOT_CHANNEL_D:
		ahc->channel = 'D';
		break;
	default:
		printf("adapter at unexpected slot %d\n"
		       "unable to map to a channel\n",
		       ahc->bd->dev);
		ahc->channel = 'A';
	}
	ahc->flags |= AHC_LARGE_SEEPROM;
	return (0);
}
@


1.56
log
@Format string fix in disabled code. Format bus_space_handle_t with %xl,
cast bus_space_tag_t to (u_long)
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.55 2011/07/17 22:46:48 matthew Exp $	*/
d45 1
a45 1
 * $Id: ahc_pci.c,v 1.55 2011/07/17 22:46:48 matthew Exp $
a73 2

#include <dev/ic/smc93cx6var.h>
@


1.55
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.54 2011/07/04 22:17:23 matthew Exp $	*/
d45 1
a45 1
 * $Id: ahc_pci.c,v 1.53 2008/05/13 02:24:08 brad Exp $
d796 2
a797 2
	printf("%s: mem mapping: memt 0x%x, memh 0x%x, iot 0x%x, ioh 0x%lx\n",
	       ahc_name(ahc), memt, (u_int32_t)memh, (u_int32_t)iot, ioh);
@


1.54
log
@Use the SDEV_2NDBUS flag like isp(4) instead of the current
scsi_link::scsibus hack to determine which channel the link is
associated with.

"looks sane" dlg@@, but haven't found any testers yet; committing so
further SCSI refactorings can go in.  dlg@@ or I will back out or fix
if anything breaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.53 2008/05/13 02:24:08 brad Exp $	*/
d739 6
@


1.53
log
@Remove commented out NetBSD __KERNEL_RCSID macro usage.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.52 2007/09/07 18:07:06 krw Exp $	*/
d45 1
a45 1
 * $Id: ahc_pci.c,v 1.52 2007/09/07 18:07:06 krw Exp $
a738 6

	/*
	 * SCSI_IS_SCSIBUS_B() must returns false until sc_channel_b
	 * has been properly initialized. XXX Breaks if >254 scsi buses.
	 */
	ahc->sc_channel_b.scsibus = 0xff;
@


1.52
log
@The obvious bzero/memset -> M_ZERO changes.
@
text
@d1 3
a3 1
/*	$OpenBSD: ahc_pci.c,v 1.51 2007/05/14 01:37:50 deraadt Exp $	*/
d45 1
a45 1
 * $Id: ahc_pci.c,v 1.51 2007/05/14 01:37:50 deraadt Exp $
a53 3

#include <sys/cdefs.h>
/* __KERNEL_RCSID(0, "$NetBSD: ahc_pci.c,v 1.43 2003/08/18 09:16:22 taca Exp $"); */
@


1.51
log
@delete unused code; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.50 2006/07/11 18:48:27 kettenis Exp $	*/
d43 1
a43 1
 * $Id: ahc_pci.c,v 1.50 2006/07/11 18:48:27 kettenis Exp $
d758 2
a759 1
	bd = malloc(sizeof (struct ahc_pci_busdata), M_DEVBUF, M_NOWAIT);
d761 2
a762 1
		printf("%s: unable to allocate bus-specific data\n", ahc_name(ahc));
a764 1
	memset(bd, 0, sizeof(struct ahc_pci_busdata));
d971 2
a972 2
	ahc->seep_config = malloc(sizeof(*ahc->seep_config),
				  M_DEVBUF, M_NOWAIT);
a975 2
	memset(ahc->seep_config, 0, sizeof(*ahc->seep_config));

@


1.50
log
@Read PCI command/status register right before modifying it to prevent restoring
bits set by mapping BARs.

tested by steven@@, ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.49 2005/08/09 04:10:10 mickey Exp $	*/
d43 1
a43 1
 * $Id: ahc_pci.c,v 1.49 2005/08/09 04:10:10 mickey Exp $
a595 2
const u_int ahc_num_pci_devs = NUM_ELEMENTS(ahc_pci_ident_table);
		
d678 1
a678 1
	for (i = 0; i < ahc_num_pci_devs; i++) {
@


1.49
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.48 2005/03/24 17:15:28 martin Exp $	*/
d43 1
a43 1
 * $Id: ahc_pci.c,v 1.48 2005/03/24 17:15:28 martin Exp $
a753 1
	command = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
d859 6
a864 3
	if ((ahc->flags & AHC_DISABLE_PCI_PERR) != 0)
	  command &= ~PCI_COMMAND_PARITY_ENABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
@


1.48
log
@enable memory-mapped i/o everywhere but on i386

suggested by mickey@@, ok krw@@, deraadt@@, also tested by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.47 2005/02/21 03:10:57 martin Exp $	*/
d43 1
a43 1
 * $Id: ahc_pci.c,v 1.47 2005/02/21 03:10:57 martin Exp $
a852 4

	/* Ensure busmastering is enabled */
	command |= PCI_COMMAND_MASTER_ENABLE;;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
@


1.47
log
@define AHC_ALLOW_MEMIO on macppc, resulting in support for more
controllers and better performance

ok drahn@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.46 2005/02/12 15:32:11 krw Exp $	*/
d43 1
a43 1
 * $Id: ahc_pci.c,v 1.46 2005/02/12 15:32:11 krw Exp $
d78 1
a78 1
#if defined (__hppa__) || (__macppc__)
@


1.46
log
@Fix crashes during probe by ensuring that SCSI_IS_SCSIBUS_B() returns
false until scsi bus b is initialized.

Set TWIN_CHNLB bit that is used elsewhere. Missed chunk from last code
sync.

Problem found and fixes tested on HP Proliant ML310 by Valov Oleg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.45 2004/08/13 23:38:54 krw Exp $	*/
d43 1
a43 1
 * $Id: ahc_pci.c,v 1.45 2004/08/13 23:38:54 krw Exp $
d78 1
a78 1
#ifdef __hppa__
@


1.45
log
@Fix issue with auto request sense handling for both ahc and ahd.

Restore hppa functionality, add sgi functionality for ahc.

ok deraadt@@, plus marco@@, mickey@@, pefo@@ for various bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.44 2004/08/01 01:36:24 krw Exp $	*/
d43 1
a43 1
 * $Id: ahc_pci.c,v 1.44 2004/08/01 01:36:24 krw Exp $
d742 6
@


1.44
log
@Fold in relevant bits of the most recent two updates from
gibbs@@freebsd.

Large commit messages detailing all changes can be read at revisions
1.97 and 1.100 of aic7xxx.c:

www.freebsd.org/cgi/cvsweb.cgi/src/sys/dev/aic7xxx/aic7xxx.c

Tested by marco, nate and pefo. Fixed broken system for nate.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.43 2004/01/05 01:09:18 krw Exp $	*/
d43 1
a43 1
 * $Id: ahc_pci.c,v 1.43 2004/01/05 01:09:18 krw Exp $
d78 3
d719 1
a719 1
	int		   ioh_valid, memh_valid;
d723 1
d774 1
a774 1
	ioh_valid = memh_valid = 0;
d777 1
d788 1
d790 2
a791 3
	ioh_valid = (pci_mapreg_map(pa, AHC_PCI_IOADDR,
				    PCI_MAPREG_TYPE_IO, 0, &iot, 
				    &ioh, NULL, NULL, 0) == 0);
@


1.43
log
@Reduce ahc verbosity. Put chip details inside an if (bootverbose) {}
block. Put irq on first ahc line after 'rev 0xYY', rather than a
separate line.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.42 2003/12/24 22:45:45 krw Exp $	*/
d43 1
a43 1
 * $Id: ahc_pci.c,v 1.42 2003/12/24 22:45:45 krw Exp $
d642 1
d727 11
d864 1
d881 1
a881 1
	error = ahc_reset(ahc);
d1025 30
d1417 25
d1453 1
d1469 1
d1493 1
d1545 1
d1591 1
d1604 1
d1658 1
d1670 1
d1682 1
@


1.42
log
@Sync ahc with NetBSD, which was in turn updated from FreeBSD by Pascal
Renauld of Network Storage Solutions, Inc. Many fixes, wider device
support. In particular, the notorious 'Target 0' problem seems to be
fixed.

Does *not* include any updates to isa or eisa code beyond what was
necessary to compile.

Known issues:

1) Tagged Queuing is probably not optimal.

2) PPR negotiation may not be fully functional.

3) No support yet for freezing devices or channels.

4) The mechanism for preventing 'A' and 'B' channel confusion during probe
can fail if scsibus > 254 found.

5) Requeuing I/O's not working. A workaround will be committed almost
immediately. At the moment timeouts, SCSI message rejects, aborting
SCB's and trying to freeze a device may cause incomplete i/o's to be
reported as complete.

6) Verbosity and probe messages need work.

7) Last disk on bus seems to go through an extra re-negotiation.

8) >16 devices on an adapter will trigger the usual problems of total
openings exceeding available SCB's under heavy load.

Tested by deraadt@@, beck@@, miod@@, naddy@@, drahn@@, marc@@ amoung
others.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.41 2003/09/25 07:11:15 deraadt Exp $	*/
d43 1
a43 1
 * $Id: ahc_pci.c,v 1.43 2003/08/18 09:16:22 taca Exp $
d896 1
a896 2
		printf("%s: couldn't establish interrupt",
		       ahc->sc_dev.dv_xname);
d902 2
a903 4
	}
	printf("\n");
	if (intrstr != NULL)
		printf("%s: interrupting at %s\n", ahc_name(ahc), intrstr);
@


1.41
log
@support AAA131U2; cmaxwell@@themanor.net
@
text
@d1 1
a1 3
/*	$OpenBSD: ahc_pci.c,v 1.40 2003/08/15 23:01:01 fgsch Exp $	*/
/*	$NetBSD: ahc_pci.c,v 1.9 1996/10/21 22:56:24 thorpej Exp $	*/

d4 2
a5 1
 *      3940, 2940, aic7880, aic7870, aic7860 and aic7850 SCSI controllers
d7 2
a8 1
 * Copyright (c) 1995, 1996 Justin T. Gibbs.
d15 14
a28 7
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d30 6
a35 5
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d38 13
a50 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d53 3
d62 2
a66 3
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

a68 1
#include <dev/pci/pcidevs.h>
a72 1
#include <dev/ic/aic7xxxreg.h>
d75 1
a77 12
/* 
 * XXX memory-mapped is busted on some i386 on-board chips.
 * for i386, we don't even try it.  Also, suppress the damn 
 * PCI bus errors messages on i386.  They are not fatal, and are 
 * usually caused by some other device on the PCI bus.  But some 
 * ahc cards won't work without ACKing them.  So just ACK and go!  
 * XXX- smurph
 */
#ifndef i386
#define AHC_ALLOW_MEMIO
#define AHC_SHOW_PCI_ERRORS
#endif
d79 155
d235 2
a236 2
 * Under normal circumstances, these messages are unnecessary
 * and not terribly cosmetic.
d238 25
a262 5
#ifdef DEBUG
#define bootverbose	1
#else
#define bootverbose	0
#endif
d264 328
a591 1
#define PCI_BASEADR0	PCI_MAPREG_START
d593 2
d602 4
a605 2
#define	EXROMBADR		0x30
#define 	EXROMEN		0x00000001UL	/* External Rom Enable */
d608 15
a622 14
#define		SCBSIZE32	0x00010000UL	/* aic789X only */
#define		REXTVALID	0x00001000UL	/* ultra cards only */
#define		MPORTMODE	0x00000400UL	/* aic7870+ only */
#define		RAMPSM		0x00000200UL	/* aic7870+ only */
#define		VOLSENSE	0x00000100UL
#define		PCI64BIT	0x00000080UL	/* 64Bit PCI bus (Ultra2 Only)*/
#define		SCBRAMSEL	0x00000080UL
#define		MRDCEN		0x00000040UL
#define		EXTSCBTIME	0x00000020UL	/* aic7870 only */
#define		EXTSCBPEN	0x00000010UL	/* aic7870 only */
#define		BERREN		0x00000008UL
#define		DACEN		0x00000004UL
#define		STPWLEVEL	0x00000002UL
#define		DIFACTNEGEN	0x00000001UL	/* aic7870 only */
d625 2
a626 2
#define		CACHESIZE	0x0000003fUL	/* only 5 bits */
#define		LATTIME		0x0000ff00UL
d628 11
a638 1
static int  ahc_ext_scbram_present(struct ahc_softc *ahc);
a641 33
static void check_extport(struct ahc_softc *ahc, u_int *sxfrctl1);
static void configure_termination(struct ahc_softc *ahc,
				  struct seeprom_descriptor *sd,
				  u_int adapter_control,
				  u_int *sxfrctl1);
static void ahc_new_term_detect(struct ahc_softc *ahc,
				int *enableSEC_low,
				int *enableSEC_high,
				int *enablePRI_low,
				int *enablePRI_high,
				int *eeprom_present);
static void aic787X_cable_detect(struct ahc_softc *ahc,
				 int *internal50_present,
				 int *internal68_present,
				 int *externalcable_present,
				 int *eeprom_present);
static void aic785X_cable_detect(struct ahc_softc *ahc,
				 int *internal50_present,
				 int *externalcable_present,
				 int *eeprom_present);
static void write_brdctl(struct ahc_softc *ahc, u_int8_t value);
static u_int8_t read_brdctl(struct ahc_softc *ahc);

int ahc_do_pci_config(struct ahc_softc *ahc);

void load_seeprom(struct ahc_softc *ahc);
static int acquire_seeprom(struct ahc_softc *ahc,
			   struct seeprom_descriptor *sd);
static void release_seeprom(struct seeprom_descriptor *sd);
static int verify_cksum(struct seeprom_config *);
int ahc_probe_scbs(struct ahc_softc *ahc);

static u_char aic3940_count;
d646 1
d651 32
a682 35
const struct pci_matchid ahc_pci_devices[] = {
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC7810 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC7850 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC7855 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC7860 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2940AU },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC7870 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2930CU },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2940 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_3940 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_3985 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2944 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC7880 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2940U },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_3940U },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_398XU },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2944U },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2940UWPro },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_7895 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AAA131U2 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7890 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_2940U2 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_2930U2 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7892 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_29160 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_19160B },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_3950U2B },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_3950U2D },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7896 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7899B },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7899D },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7899F },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7899 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_3960D },
};
d686 2
a687 2
struct device *parent;
void *match, *aux;
d689 7
a695 2
	return (pci_matchbyid((struct pci_attach_args *)aux, ahc_pci_devices,
	    sizeof(ahc_pci_devices)/sizeof(ahc_pci_devices[0])));
d700 2
a701 2
struct device *parent, *self;
void *aux;
d704 22
a725 3
	struct ahc_softc *ahc = (void *)self;
	pcireg_t devconfig;
	pcireg_t command;
a726 1
	/* setup the PCI stuff */
a728 6
	/* 
	 * We really don't allocate our softc, but 
	 * we need to do the initialization. And this 
	 * also allocates the platform_data structure.
	 */
	ahc_alloc(ahc, NULL);
a729 3
	ahc_set_unit(ahc, ahc->sc_dev.dv_unit);
	
	/* set dma tags */
d731 12
a742 167
	ahc->buffer_dmat = pa->pa_dmat;
        ahc->shared_data_dmat = pa->pa_dmat;
	
	/* card specific setup */
	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_ADP:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_ADP_7895:
			ahc->channel = pa->pa_function == 1 ? 'B' : 'A';
			/* The 'C' revision of the aic7895 
			   has a few additional features */
			if (PCI_REVISION(pa->pa_class) >= 4){
				ahc->chip |= AHC_AIC7895C;
			} else {
				ahc->chip |= AHC_AIC7895;
			}
			break;
		case PCI_PRODUCT_ADP_3940U:
		case PCI_PRODUCT_ADP_3940:
			if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADP_3940U) {
				ahc->chip |= AHC_AIC7880;
			} else {
				ahc->chip |= AHC_AIC7870;
			}
			aic3940_count++;
			if (!(aic3940_count & 0x01))
				/* Even count implies second channel */
				ahc->channel = 'B';
			break;
		case PCI_PRODUCT_ADP_2940UWPro:
			ahc->flags |= AHC_INT50_SPEEDFLEX;
			/* fall through */
		case PCI_PRODUCT_ADP_AIC7880:
		case PCI_PRODUCT_ADP_398XU:	/* XXX */
		case PCI_PRODUCT_ADP_2944U:
		case PCI_PRODUCT_ADP_2940U:
			ahc->chip |= AHC_AIC7880;
			break;
		case PCI_PRODUCT_ADP_AIC7870:
		case PCI_PRODUCT_ADP_2944:
		case PCI_PRODUCT_ADP_2940:
			ahc->chip |= AHC_AIC7870;
			break;
		case PCI_PRODUCT_ADP_AIC7860:
		case PCI_PRODUCT_ADP_2940AU:
			ahc->chip |= AHC_AIC7860;
			break;
		case PCI_PRODUCT_ADP_AIC7855:
		case PCI_PRODUCT_ADP_AIC7850:
			ahc->chip |= AHC_AIC7850;
			break;
		default:
			/* TTT */
			break;
	}
		break;
	case PCI_VENDOR_ADP2:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_ADP2_AIC7890:
		case PCI_PRODUCT_ADP2_2940U2:
		case PCI_PRODUCT_ADP2_2930U2:
		case PCI_PRODUCT_ADP2_AAA131U2:
			ahc->chip |= AHC_AIC7890;
			break;
		case PCI_PRODUCT_ADP2_AIC7892:
		case PCI_PRODUCT_ADP2_29160:
		case PCI_PRODUCT_ADP2_19160B:
			ahc->chip |= AHC_AIC7892;
			break;
		case PCI_PRODUCT_ADP2_3950U2B:
		case PCI_PRODUCT_ADP2_3950U2D:
		case PCI_PRODUCT_ADP2_AIC7896:
			ahc->chip |= AHC_AIC7896;
			ahc->channel = pa->pa_function == 1 ? 'B' : 'A';
			devconfig = ahc_pci_read_config(ahc->dev_softc, 
						  DEVCONFIG, 4);
			/* turn off 64 bit for now XXX smurph */
			devconfig &= ~PCI64BIT;
			ahc_pci_write_config(ahc->dev_softc, 
				       DEVCONFIG, devconfig, 4);
			break;
		case PCI_PRODUCT_ADP2_AIC7899:
		case PCI_PRODUCT_ADP2_3960D:
			ahc->chip |= AHC_AIC7899;
			ahc->channel = pa->pa_function == 1 ? 'B' : 'A';
			break;
		default:
			/* TTT */
			break;
		}
	}
	
	/* chip specific setup */
	switch(ahc->chip){
	case AHC_AIC7850:
	case AHC_AIC7855:
	case AHC_AIC7859:
		ahc->features = AHC_AIC7850_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		if (PCI_REVISION(pa->pa_class) >= 1)
			ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
		break;
	case AHC_AIC7860:
		ahc->features = AHC_AIC7860_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		if (PCI_REVISION(pa->pa_class) >= 1)
			ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
		break;
	case AHC_AIC7870:
		ahc->features = AHC_AIC7870_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		break;
	case AHC_AIC7880:
		ahc->features = AHC_AIC7880_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
		if (PCI_REVISION(pa->pa_class) >= 1) {
			ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
		} else {
			ahc->bugs |= AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		}
		break;
	case AHC_AIC7895:
		ahc->features = AHC_AIC7895_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		/*
		 * The BIOS disables the use of MWI transactions
		 * since it does not have the MWI bug work around
		 * we have.  Disabling MWI reduces performance, so
		 * turn it on again.
		 */
		command = pci_conf_read(pa->pa_pc, pa->pa_tag,
					PCI_COMMAND_STATUS_REG);
		command |= PCI_COMMAND_INVALIDATE_ENABLE;
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
			       command);
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_PCI_2_1_RETRY_BUG
			  |  AHC_CACHETHEN_BUG | AHC_PCI_MWI_BUG;
		break;		
	case AHC_AIC7895C:
		ahc->features = AHC_AIC7895C_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_PCI_2_1_RETRY_BUG
			  |  AHC_CACHETHEN_BUG;
		break;
	case AHC_AIC7890:
		ahc->features = AHC_AIC7890_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		if (PCI_REVISION(pa->pa_class) == 0)
			ahc->bugs |= AHC_AUTOFLUSH_BUG|AHC_CACHETHEN_BUG;
		break;
	case AHC_AIC7892:
		ahc->features = AHC_AIC7892_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;
		break;
	case AHC_AIC7896:
		ahc->features = AHC_AIC7896_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_CACHETHEN_DIS_BUG;
		break;
	case AHC_AIC7899:
		ahc->features = AHC_AIC7899_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;
		break;
	default:
		break;
d744 7
d752 1
a752 3
	/* setup the PCI interrupt */
	ahc->bus_intr = ahc_pci_intr;
	ahc->unsolicited_ints = 0; 
d754 2
a755 2
	if(ahc_do_pci_config(ahc)){
		ahc_free(ahc);
a756 4
	}
	
	ahc_attach(ahc);
}
d758 1
a758 9
int
ahc_pci_map_registers(ahc)
	struct ahc_softc *ahc;
{
	pcireg_t	command;
	int		ioh_valid;
	bus_space_tag_t  iot;
	bus_space_handle_t ioh;
	struct pci_attach_args *pa = ahc->dev_softc;
a759 2
	command = ahc_pci_read_config(ahc->dev_softc,
				      PCI_COMMAND_STATUS_REG, 4);
d761 9
a769 36
	/*
	 * attempt to use memory mapping on hardware that supports it.
	 * e.g powerpc  XXX - smurph
	 *
	 * Note:  If this fails, IO mapping is used.
	 */
	if ((command & PCI_COMMAND_MEM_ENABLE) != 0) {
		pcireg_t memtype;
		memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, AHC_PCI_MEMADDR);
		switch (memtype) {
		case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
		case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
			ioh_valid = (pci_mapreg_map(pa, AHC_PCI_MEMADDR,
				memtype, 0, &iot, &ioh, NULL, NULL, 0) == 0);
			break;
		default:
			ioh_valid = 0;
		}
		if (ioh_valid) {
			/*
			 * Do a quick test to see if memory mapped
			 * I/O is functioning correctly.
			 */
			ahc->tag = iot;
			ahc->bsh = ioh;
			if (ahc_inb(ahc, HCNTRL) == 0xFF) {
				/* nope, use I/O mapping */
                                ioh_valid = 0;
			} else {
				/* Using memory mapping, disable I/O mapping */
                                command &= ~PCI_COMMAND_IO_ENABLE;
				ahc_pci_write_config(ahc->dev_softc,
						     PCI_COMMAND_STATUS_REG,
						     command, 4);
			}
		}
a770 2
	
	if (!ioh_valid) /* try to drop back to IO mapping */
d772 7
a778 10
	{
		ioh_valid = (pci_mapreg_map(pa, AHC_PCI_IOADDR,
		    PCI_MAPREG_TYPE_IO, 0, &iot, &ioh, NULL, NULL, 0) == 0);
		
		/* Using I/O mapping, disable memory mapping */
		command &= ~PCI_COMMAND_MEM_ENABLE;
		ahc_pci_write_config(ahc->dev_softc,
				     PCI_COMMAND_STATUS_REG,
				     command, 4);
	}
d780 9
a788 2
	if (!ioh_valid) {
		/* Game Over.  Insert coin... */
d790 1
a790 1
		return (1);
d792 2
a793 18
	ahc->tag = iot;
	ahc->bsh = ioh;
	return (0);
}

int
ahc_do_pci_config(ahc)
	struct ahc_softc *ahc;
{
	pcireg_t	 command;
	u_int		 our_id = 0;
	u_int		 sxfrctl1;
	u_int		 scsiseq;
	u_int		 dscommand0;
	int		 error;
	int		 opri;
	uint8_t		 sblkctl;

d796 1
a796 12
#if 0
	ahc_power_state_change(ahc, AHC_POWER_STATE_D0);
#endif 
	error = ahc_pci_map_registers(ahc);
	if (error != 0)
		return (error);
	/* 
	 * Registers are mapped. Now it is safe to use 
	 * the ahc_inb and ahc_outb macros. 
	 */
	
	/* 
d805 8
a818 1
		pcireg_t devconfig;
d820 1
a820 1
		if (bootverbose)
a822 1
		devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
a823 1
		ahc_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig, 4);
d826 5
d832 12
a843 2
        command = ahc_pci_read_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, 4);
	command |= PCI_COMMAND_MASTER_ENABLE; 
a844 2
	ahc_pci_write_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, command, 4);
	
a846 1

d849 3
a851 1
		return (error);
d870 1
a870 1
		return (ENXIO);
d887 21
a907 6
	/*
	 * Protect ourself from spurrious interrupts during
	 * initialization.
	 */
	opri = splbio();
	
d930 3
a932 3
	
	ahc->pci_cachesize = ahc_pci_read_config(ahc->dev_softc,
						 CSIZE_LATTIME, 4) & CACHESIZE;
d936 2
a937 5
	 && ahc->pci_cachesize == 4) {
		u_int csl = ahc_pci_read_config(ahc->dev_softc,
						CSIZE_LATTIME, 4);
		csl &= ~CACHESIZE;
		ahc_pci_write_config(ahc->dev_softc, CSIZE_LATTIME, csl, 4);
d942 1
a942 1
	 * We cannot perform ULTRA speeds without the presense
d948 1
a948 1
		devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
d953 7
d961 1
a961 1
	check_extport(ahc, &sxfrctl1);
d982 2
a983 1
		if (scsiseq != 0) {
d1015 4
a1018 4
	/* Core initialization */
	error = ahc_init(ahc);
	if (error != 0)
		return (error);
d1020 1
a1020 2
	/* Special func to force negotiation */
	ahc_force_neg(ahc);
d1022 4
a1025 4
	/*
	 * Link this softc in with all other ahc instances.
	 */
	ahc_softc_insert(ahc);
d1027 5
a1031 6
	/*
	 * Allow interrupts now that we are completely setup.
	 */
	error = ahc_pci_map_int(ahc);
	if (error != 0)
		return (error);
d1033 6
a1038 2
	ahc_intr_enable(ahc, TRUE);
	splx(opri);
d1040 19
a1058 1
	return (0);
d1061 7
a1067 3
int
ahc_pci_map_int(ahc)
	struct ahc_softc *ahc;
d1069 1
a1069 35
	const char *intrstr = NULL;
	pci_intr_handle_t ih;
	struct pci_attach_args *pa = ahc->dev_softc;
	
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		return 1;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	
	ahc->platform_data->ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO,
						    ahc_platform_intr, ahc,
						    ahc->sc_dev.dv_xname);
	
	if (ahc->platform_data->ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return 1;
	}
	
	if (intrstr != NULL)
		printf(": %s\n", intrstr);
	return 0;
}

/*
 * Test for the presense of external sram in an
 * "unshared" configuration.
 */
static int
ahc_ext_scbram_present(struct ahc_softc *ahc)
{
	u_int chip;
d1073 1
a1073 1
	
d1075 1
a1075 3
	
	devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);

d1080 8
d1102 2
a1103 6
ahc_scbram_config(ahc, enable, pcheck, fast, large)
	struct ahc_softc *ahc;
	int enable;
	int pcheck;
	int fast;
	int large;
d1105 1
a1105 1
	pcireg_t devconfig;
d1112 1
a1112 1
		ahc_outb(ahc, SCBBADDR, ahc_get_pci_function(ahc->dev_softc));
d1115 4
a1118 1
	devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
d1151 1
a1151 1
	ahc_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig, 4);
d1160 1
a1160 2
ahc_probe_ext_scbram(ahc)
	struct ahc_softc *ahc;
d1247 1
a1247 1
	if (bootverbose && enable) {
d1256 1
d1258 2
a1259 2
 * Check the external port logic for a serial eeprom
 * and termination/cable detection contrls.
d1261 76
a1336 18
static void
check_extport(ahc, sxfrctl1)
	struct ahc_softc *ahc;
	u_int *sxfrctl1;
{
	struct	seeprom_descriptor sd;
	struct	seeprom_config sc;
	u_int	scsi_conf;
	u_int	adapter_control;
	int	have_seeprom;
	int	have_autoterm;
	
	sd.sd_tag = ahc->tag;
	sd.sd_bsh = ahc->bsh;
	sd.sd_regsize = 1;
	sd.sd_control_offset = SEECTL;		
	sd.sd_status_offset = SEECTL;		
	sd.sd_dataout_offset = SEECTL;		
d1338 3
a1340 10
	/*
	 * For some multi-channel devices, the c46 is simply too
	 * small to work.  For the other controller types, we can
	 * get our information from either SEEPROM type.  Set the
	 * type to start our probe with accordingly.
	 */
	if (ahc->flags & AHC_LARGE_SEEPROM)
		sd.sd_chip = C56_66;
	else
		sd.sd_chip = C46;
d1342 19
a1360 36
	sd.sd_MS = SEEMS;
	sd.sd_RDY = SEERDY;
	sd.sd_CS = SEECS;
	sd.sd_CK = SEECK;
	sd.sd_DO = SEEDO;
	sd.sd_DI = SEEDI;

	have_seeprom = acquire_seeprom(ahc, &sd);
	if (have_seeprom) {

		if (bootverbose) 
			printf("%s: Reading SEEPROM...", ahc_name(ahc));

		for (;;) {
			u_int start_addr;

			start_addr = 32 * (ahc->channel - 'A');

			have_seeprom = read_seeprom(&sd, (uint16_t *)&sc,
						    start_addr, sizeof(sc)/2);

			if (have_seeprom)
				have_seeprom = verify_cksum(&sc);

			if (have_seeprom != 0 || sd.sd_chip == C56_66) {
				if (bootverbose) {
					if (have_seeprom == 0)
						printf ("checksum error\n");
					else
						printf ("done.\n");
				}
				break;
			}
			sd.sd_chip = C56_66;
		}
		release_seeprom(&sd);
d1363 7
a1369 31
	if (!have_seeprom) {
		/*
		 * Pull scratch ram settings and treat them as
		 * if they are the contents of an seeprom if
		 * the 'ADPT' signature is found in SCB2.
		 * We manually compose the data as 16bit values
		 * to avoid endian issues.
		 */
		ahc_outb(ahc, SCBPTR, 2);
		if (ahc_inb(ahc, SCB_BASE) == 'A'
		 && ahc_inb(ahc, SCB_BASE + 1) == 'D'
		 && ahc_inb(ahc, SCB_BASE + 2) == 'P'
		 && ahc_inb(ahc, SCB_BASE + 3) == 'T') {
			uint16_t *sc_data;
			int	  i;

			sc_data = (uint16_t *)&sc;
			for (i = 0; i < 32; i++) {
				uint16_t val;
				int	 j;

				j = i * 2;
				val = ahc_inb(ahc, SRAM_BASE + j)
				    | ahc_inb(ahc, SRAM_BASE + j + 1) << 8;
			}
			have_seeprom = verify_cksum(&sc);
		}
		/*
		 * Clear any SCB parity errors in case this data and
		 * its associated parity was not initialized by the BIOS
		 */
a1370 1
		ahc_outb(ahc, CLRINT, CLRBRKADRINT);
d1373 2
a1374 28
	if (!have_seeprom) {
		if (bootverbose)
			printf("%s: No SEEPROM available.\n", ahc_name(ahc));
		ahc->flags |= AHC_USEDEFAULTS;
	} else {
		/*
		 * Put the data we've collected down into SRAM
		 * where ahc_init will find it.
		 */
		int i;
		int max_targ = sc.max_targets & CFMAXTARG;
		uint16_t discenable;
		uint16_t ultraenb;

		discenable = 0;
		ultraenb = 0;
		if ((sc.adapter_control & CFULTRAEN) != 0) {
			/*
			 * Determine if this adapter has a "newstyle"
			 * SEEPROM format.
			 */
			for (i = 0; i < max_targ; i++) {
				if ((sc.device_flags[i] & CFSYNCHISULTRA) != 0){
					ahc->flags |= AHC_NEWEEPROM_FMT;
					break;
				}
			}
		}
d1376 4
a1379 21
		for (i = 0; i < max_targ; i++) {
			u_int     scsirate;
			uint16_t target_mask;

			target_mask = 0x01 << i;
			if (sc.device_flags[i] & CFDISC)
				discenable |= target_mask;
			if ((ahc->flags & AHC_NEWEEPROM_FMT) != 0) {
				if ((sc.device_flags[i] & CFSYNCHISULTRA) != 0)
					ultraenb |= target_mask;
			} else if ((sc.adapter_control & CFULTRAEN) != 0) {
				ultraenb |= target_mask;
			}
			if ((sc.device_flags[i] & CFXFER) == 0x04
			 && (ultraenb & target_mask) != 0) {
				/* Treat 10MHz as a non-ultra speed */
				sc.device_flags[i] &= ~CFXFER;
			 	ultraenb &= ~target_mask;
			}
			if ((ahc->features & AHC_ULTRA2) != 0) {
				u_int offset;
d1381 9
a1389 5
				if (sc.device_flags[i] & CFSYNCH)
					offset = MAX_OFFSET_ULTRA2;
				else 
					offset = 0;
				ahc_outb(ahc, TARG_OFFSET + i, offset);
d1391 4
a1394 20
				/*
				 * The ultra enable bits contain the
				 * high bit of the ultra2 sync rate
				 * field.
				 */
				scsirate = (sc.device_flags[i] & CFXFER)
					 | ((ultraenb & target_mask)
					    ? 0x8 : 0x0);
				if (sc.device_flags[i] & CFWIDEB)
					scsirate |= WIDEXFER;
			} else {
				scsirate = (sc.device_flags[i] & CFXFER) << 4;
				if (sc.device_flags[i] & CFSYNCH)
					scsirate |= SOFS;
				if (sc.device_flags[i] & CFWIDEB)
					scsirate |= WIDEXFER;
			}
			ahc_outb(ahc, TARG_SCSIRATE + i, scsirate);
		}
		ahc->our_id = sc.brtime_id & CFSCSIID;
d1396 9
a1404 5
		scsi_conf = (ahc->our_id & 0x7);
		if (sc.adapter_control & CFSPARITY)
			scsi_conf |= ENSPCHK;
		if (sc.adapter_control & CFRESETB)
			scsi_conf |= RESET_SCSI;
d1406 4
a1409 2
		ahc->flags |=
		    (sc.adapter_control & CFBOOTCHAN) >> CFBOOTCHANSHIFT;
d1411 6
a1416 2
		if (sc.bios_control & CFEXTEND)
			ahc->flags |= AHC_EXTENDED_TRANS_A;
d1418 3
a1420 9
		if (sc.bios_control & CFBIOSEN)
			ahc->flags |= AHC_BIOS_ENABLED;
		if (ahc->features & AHC_ULTRA
		 && (ahc->flags & AHC_NEWEEPROM_FMT) == 0) {
			/* Should we enable Ultra mode? */
			if (!(sc.adapter_control & CFULTRAEN))
				/* Treat us as a non-ultra card */
				ultraenb = 0;
		}
d1422 6
a1427 20
		if (sc.signature == CFSIGNATURE
		 || sc.signature == CFSIGNATURE2) {
			pcireg_t devconfig;

			/* Honor the STPWLEVEL settings */
			devconfig = ahc_pci_read_config(ahc->dev_softc, 
							DEVCONFIG, 4);
			devconfig &= ~STPWLEVEL;
			if ((sc.bios_control & CFSTPWLEVEL) != 0)
				devconfig |= STPWLEVEL;
			ahc_pci_write_config(ahc->dev_softc,
					     DEVCONFIG, devconfig, 4);
		}
		/* Set SCSICONF info */
		ahc_outb(ahc, SCSICONF, scsi_conf);
		ahc_outb(ahc, DISC_DSB, ~(discenable & 0xff));
		ahc_outb(ahc, DISC_DSB + 1, ~((discenable >> 8) & 0xff));
		ahc_outb(ahc, ULTRA_ENB, ultraenb & 0xff);
		ahc_outb(ahc, ULTRA_ENB + 1, (ultraenb >> 8) & 0xff);
	}
d1429 4
a1432 11
	/*
	 * Cards that have the external logic necessary to talk to
	 * a SEEPROM, are almost certain to have the remaining logic
	 * necessary for auto-termination control.  This assumption
	 * hasn't failed yet...
	 */
	have_autoterm = have_seeprom;
	if (have_seeprom)
		adapter_control = sc.adapter_control;
	else
		adapter_control = CFAUTOTERM;
d1434 4
a1437 17
	/*
	 * Some low-cost chips have SEEPROM and auto-term control built
	 * in, instead of using a GAL.  They can tell us directly
	 * if the termination logic is enabled.
	 */
	if ((ahc->features & AHC_SPIOCAP) != 0) {
		if ((ahc_inb(ahc, SPIOCAP) & SSPIOCPS) != 0)
			have_autoterm = TRUE;
		else
			have_autoterm = FALSE;
	}

	if (have_autoterm) {
		acquire_seeprom(ahc, &sd);
		configure_termination(ahc, &sd, adapter_control, sxfrctl1);
		release_seeprom(&sd);
	}
d1440 2
a1441 5
static void
configure_termination(struct ahc_softc *ahc,
		      struct seeprom_descriptor *sd,
		      u_int adapter_control,
		      u_int *sxfrctl1)
d1443 1
a1443 3
	uint8_t brddat;
	
	brddat = 0;
d1445 5
a1449 63
	/*
	 * Update the settings in sxfrctl1 to match the
	 * termination settings 
	 */
	*sxfrctl1 = 0;
	
	/*
	 * SEECS must be on for the GALS to latch
	 * the data properly.  Be sure to leave MS
	 * on or we will release the seeprom.
	 */
	SEEPROM_OUTB(sd, sd->sd_MS | sd->sd_CS);
	if ((adapter_control & CFAUTOTERM) != 0
	 || (ahc->features & AHC_NEW_TERMCTL) != 0) {
		int internal50_present;
		int internal68_present;
		int externalcable_present;
		int eeprom_present;
		int enableSEC_low;
		int enableSEC_high;
		int enablePRI_low;
		int enablePRI_high;
		int sum;

		enableSEC_low = 0;
		enableSEC_high = 0;
		enablePRI_low = 0;
		enablePRI_high = 0;
		if ((ahc->features & AHC_NEW_TERMCTL) != 0) {
			ahc_new_term_detect(ahc, &enableSEC_low,
					       &enableSEC_high,
					       &enablePRI_low,
					       &enablePRI_high,
					       &eeprom_present);
			if ((adapter_control & CFSEAUTOTERM) == 0) {
				if (bootverbose)
					printf("%s: Manual SE Termination\n",
					       ahc_name(ahc));
				enableSEC_low = (adapter_control & CFSELOWTERM);
				enableSEC_high =
				    (adapter_control & CFSEHIGHTERM);
			}
			if ((adapter_control & CFAUTOTERM) == 0) {
				if (bootverbose)
					printf("%s: Manual LVD Termination\n",
					       ahc_name(ahc));
				enablePRI_low = (adapter_control & CFSTERM);
				enablePRI_high = (adapter_control & CFWSTERM);
			}
			/* Make the table calculations below happy */
			internal50_present = 0;
			internal68_present = 1;
			externalcable_present = 1;
		} else if ((ahc->features & AHC_SPIOCAP) != 0) {
			aic785X_cable_detect(ahc, &internal50_present,
					     &externalcable_present,
					     &eeprom_present);
		} else {
			aic787X_cable_detect(ahc, &internal50_present,
					     &internal68_present,
					     &externalcable_present,
					     &eeprom_present);
		}
d1451 4
a1454 2
		if ((ahc->features & AHC_WIDE) == 0)
			internal68_present = 0;
d1456 5
a1460 16
		if (bootverbose
		 && (ahc->features & AHC_ULTRA2) == 0) {
			printf("%s: internal 50 cable %s present",
			       ahc_name(ahc),
			       internal50_present ? "is":"not");

			if ((ahc->features & AHC_WIDE) != 0)
				printf(", internal 68 cable %s present",
				       internal68_present ? "is":"not");
			printf("\n%s: external cable %s present\n",
			       ahc_name(ahc),
			       externalcable_present ? "is":"not");
		}
		if (bootverbose)
			printf("%s: BIOS eeprom %s present\n",
			       ahc_name(ahc), eeprom_present ? "is" : "not");
d1462 4
a1465 10
		if ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0) {
			/*
			 * The 50 pin connector is a separate bus,
			 * so force it to always be terminated.
			 * In the future, perform current sensing
			 * to determine if we are in the middle of
			 * a properly terminated bus.
			 */
			internal50_present = 0;
		}
d1467 12
a1478 16
		/*
		 * Now set the termination based on what
		 * we found.
		 * Flash Enable = BRDDAT7
		 * Secondary High Term Enable = BRDDAT6
		 * Secondary Low Term Enable = BRDDAT5 (7890)
		 * Primary High Term Enable = BRDDAT4 (7890)
		 */
		if ((ahc->features & AHC_ULTRA2) == 0
		 && (internal50_present != 0)
		 && (internal68_present != 0)
		 && (externalcable_present != 0)) {
			printf("%s: Illegal cable configuration!!. "
			       "Only two connectors on the "
			       "adapter may be used at a "
			       "time!\n", ahc_name(ahc));
d1480 3
a1482 9
			/*
			 * Pretend there are no cables in the hope
			 * that having all of the termination on
			 * gives us a more stable bus.
			 */
		 	internal50_present = 0;
			internal68_present = 0;
			externalcable_present = 0;
		}
d1484 3
a1486 16
		if ((ahc->features & AHC_WIDE) != 0
		 && ((externalcable_present == 0)
		  || (internal68_present == 0)
		  || (enableSEC_high != 0))) {
			brddat |= BRDDAT6;
			if (bootverbose) {
				if ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0)
					printf("%s: 68 pin termination "
					       "Enabled\n", ahc_name(ahc));
				else
					printf("%s: %sHigh byte termination "
					       "Enabled\n", ahc_name(ahc),
					       enableSEC_high ? "Secondary "
							      : "");
			}
		}
d1488 4
a1491 18
		sum = internal50_present + internal68_present
		    + externalcable_present;
		if (sum < 2 || (enableSEC_low != 0)) {
			if ((ahc->features & AHC_ULTRA2) != 0)
				brddat |= BRDDAT5;
			else
				*sxfrctl1 |= STPWEN;
			if (bootverbose) {
				if ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0)
					printf("%s: 50 pin termination "
					       "Enabled\n", ahc_name(ahc));
				else
					printf("%s: %sLow byte termination "
					       "Enabled\n", ahc_name(ahc),
					       enableSEC_low ? "Secondary "
							     : "");
			}
		}
d1493 5
a1497 6
		if (enablePRI_low != 0) {
			*sxfrctl1 |= STPWEN;
			if (bootverbose)
				printf("%s: Primary Low Byte termination "
				       "Enabled\n", ahc_name(ahc));
		}
d1499 4
a1502 5
		/*
		 * Setup STPWEN before setting up the rest of
		 * the termination per the tech note on the U160 cards.
		 */
		ahc_outb(ahc, SXFRCTL1, *sxfrctl1);
d1504 5
a1508 9
		if (enablePRI_high != 0) {
			brddat |= BRDDAT4;
			if (bootverbose)
				printf("%s: Primary High Byte "
				       "termination Enabled\n",
				       ahc_name(ahc));
		}
		
		write_brdctl(ahc, brddat);
d1510 4
a1513 3
	} else {
		if ((adapter_control & CFSTERM) != 0) {
			*sxfrctl1 |= STPWEN;
d1515 8
a1522 27
			if (bootverbose)
				printf("%s: %sLow byte termination Enabled\n",
				       ahc_name(ahc),
				       (ahc->features & AHC_ULTRA2) ? "Primary "
								    : "");
		}

		if ((adapter_control & CFWSTERM) != 0
		 && (ahc->features & AHC_WIDE) != 0) {
			brddat |= BRDDAT6;
			if (bootverbose)
				printf("%s: %sHigh byte termination Enabled\n",
				       ahc_name(ahc),
				       (ahc->features & AHC_ULTRA2)
				     ? "Secondary " : "");
		}

		/*
		 * Setup STPWEN before setting up the rest of
		 * the termination per the tech note on the U160 cards.
		 */
		ahc_outb(ahc, SXFRCTL1, *sxfrctl1);

		if ((ahc->features & AHC_WIDE) != 0)
			write_brdctl(ahc, brddat);
	}
	SEEPROM_OUTB(sd, sd->sd_MS); /* Clear CS */
d1525 2
a1526 9
static void
ahc_new_term_detect(ahc, enableSEC_low, enableSEC_high, enablePRI_low, 
		    enablePRI_high, eeprom_present)
	struct ahc_softc *ahc;
	int *enableSEC_low;
	int *enableSEC_high;
	int *enablePRI_low;
	int *enablePRI_high;
	int *eeprom_present;
a1527 1
	u_int8_t brdctl;
d1529 6
a1534 13
	/*
	 * BRDDAT7 = Eeprom
	 * BRDDAT6 = Enable Secondary High Byte termination
	 * BRDDAT5 = Enable Secondary Low Byte termination
	 * BRDDAT4 = Enable Primary high byte termination
	 * BRDDAT3 = Enable Primary low byte termination
	 */
	brdctl = read_brdctl(ahc);
	*eeprom_present = brdctl & BRDDAT7;
	*enableSEC_high = (brdctl & BRDDAT6);
	*enableSEC_low = (brdctl & BRDDAT5);
	*enablePRI_high = (brdctl & BRDDAT4);
	*enablePRI_low = (brdctl & BRDDAT3);
d1537 2
a1538 8
static void
aic787X_cable_detect(ahc, internal50_present, internal68_present,
		     externalcable_present, eeprom_present)
	struct ahc_softc *ahc;
	int *internal50_present;
	int *internal68_present;
	int *externalcable_present;
	int *eeprom_present;
d1540 1
a1540 1
	u_int8_t brdctl;
d1542 1
d1544 1
a1544 5
	 * First read the status of our cables.
	 * Set the rom bank to 0 since the
	 * bank setting serves as a multiplexor
	 * for the cable detection logic.
	 * BRDDAT5 controls the bank switch.
d1546 6
a1551 1
	write_brdctl(ahc, 0);
d1553 14
d1568 2
a1569 3
	 * Now read the state of the internal
	 * connectors.  BRDDAT6 is INT50 and
	 * BRDDAT7 is INT68.
d1571 2
a1572 3
	brdctl = read_brdctl(ahc);
	*internal50_present = (brdctl & BRDDAT6) ? 0 : 1;
	*internal68_present = (brdctl & BRDDAT7) ? 0 : 1;
d1574 2
a1575 5
	/*
	 * Set the rom bank to 1 and determine
	 * the other signals.
	 */
	write_brdctl(ahc, BRDDAT5);
d1578 2
a1579 3
	 * Now read the state of the external
	 * connectors.  BRDDAT6 is EXT68 and
	 * BRDDAT7 is EPROMPS.
d1581 7
a1587 3
	brdctl = read_brdctl(ahc);
	*externalcable_present = (brdctl & BRDDAT6) ? 0 : 1;
	*eeprom_present = (brdctl & BRDDAT7) ? 1 : 0;
d1590 9
a1598 17
static void
aic785X_cable_detect(ahc, internal50_present, externalcable_present,
		     eeprom_present)
	struct ahc_softc *ahc;
	int *internal50_present;
	int *externalcable_present;
	int *eeprom_present;
{
	u_int8_t brdctl;

	ahc_outb(ahc, BRDCTL, BRDRW|BRDCS);
	ahc_outb(ahc, BRDCTL, 0);
	brdctl = ahc_inb(ahc, BRDCTL);
	*internal50_present = (brdctl & BRDDAT5) ? 0 : 1;
	*externalcable_present = (brdctl & BRDDAT6) ? 0 : 1;

	*eeprom_present = (ahc_inb(ahc, SPIOCAP) & EEPROM) ? 1 : 0;
d1601 9
a1609 55
static void
write_brdctl(ahc, value)
	struct   ahc_softc *ahc;
	u_int8_t value;
{
	u_int8_t brdctl;

	if ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {
		brdctl = BRDSTB;
		if (ahc->channel == 'B')
			brdctl |= BRDCS;
	} else if ((ahc->features & AHC_ULTRA2) != 0) {
		brdctl = 0;
	} else {
		brdctl = BRDSTB|BRDCS;
	}
	ahc_outb(ahc, BRDCTL, brdctl);
	ahc_flush_device_writes(ahc);
	brdctl |= value;
	ahc_outb(ahc, BRDCTL, brdctl);
	ahc_flush_device_writes(ahc);
	if ((ahc->features & AHC_ULTRA2) != 0)
		brdctl |= BRDSTB_ULTRA2;
	else
		brdctl &= ~BRDSTB;
	ahc_outb(ahc, BRDCTL, brdctl);
	ahc_flush_device_writes(ahc);
	if ((ahc->features & AHC_ULTRA2) != 0)
		brdctl = 0;
	else
		brdctl &= ~BRDCS;
	ahc_outb(ahc, BRDCTL, brdctl);
}

static u_int8_t
read_brdctl(ahc)
	struct   ahc_softc *ahc;
{
	u_int8_t brdctl;
	u_int8_t value;

	if ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {
		brdctl = BRDRW;
		if (ahc->channel == 'B')
			brdctl |= BRDCS;
	} else if ((ahc->features & AHC_ULTRA2) != 0) {
		brdctl = BRDRW_ULTRA2;
	} else {
		brdctl = BRDRW|BRDCS;
	}
	ahc_outb(ahc, BRDCTL, brdctl);
	ahc_flush_device_writes(ahc);
	value = ahc_inb(ahc, BRDCTL);
	ahc_outb(ahc, BRDCTL, 0);
	return (value);
d1613 1
a1613 3
acquire_seeprom(ahc, sd)
	struct ahc_softc *ahc;
	struct seeprom_descriptor *sd;
d1615 1
a1615 1
	int wait;
d1617 5
a1621 21
	if ((ahc->features & AHC_SPIOCAP) != 0
		 && (ahc_inb(ahc, SPIOCAP) & SEEPROM) == 0)
		return (0);

	/*
	 * Request access of the memory port.  When access is
	 * granted, SEERDY will go high.  We use a 1 second
	 * timeout which should be near 1 second more than
	 * is needed.  Reason: after the chip reset, there
	 * should be no contention.
	 */
	SEEPROM_OUTB(sd, sd->sd_MS);
	wait = 1000;  /* 1 second timeout in msec */
	while (--wait && ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0)) {
		DELAY(1000);  /* delay 1 msec */
	}
	if ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0) {
		SEEPROM_OUTB(sd, 0); 
		return (0);
	}
	return (1);
d1624 2
a1625 3
static void
release_seeprom(sd)
	struct seeprom_descriptor *sd;
d1627 2
a1628 2
	/* Release access to the memory port and the serial EEPROM. */
	SEEPROM_OUTB(sd, 0);
d1631 2
a1632 17
#define DPE	PCI_STATUS_PARITY_DETECT
#define SSE	PCI_STATUS_SPECIAL_ERROR
#define RMA	PCI_STATUS_MASTER_ABORT
#define RTA	PCI_STATUS_MASTER_TARGET_ABORT
#define STA	PCI_STATUS_TARGET_TARGET_ABORT
#define DPR	PCI_STATUS_PARITY_ERROR

#define PCIDEBUG
#ifdef	PCIDEBUG
#define	PCI_PRINT(Printstuff) printf Printstuff
#else
#define	PCI_PRINT(Printstuff)
#endif

void
ahc_pci_intr(ahc)
	struct ahc_softc *ahc;
a1633 1
	pcireg_t status1;
d1635 15
a1649 7
	if ((ahc_inb(ahc, ERROR) & PCIERRSTAT) == 0)
		return;
  	PCI_PRINT(("%s: PCI error Interrupt at seqaddr = 0x%x\n",
		   ahc_name(ahc), 
		   ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8)));
 
	status1 = ahc_pci_read_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, 4);
d1651 3
a1653 25
/* define AHC_SHOW_PCI_ERRORS to get painful errors on your i386 console */
#ifdef AHC_SHOW_PCI_ERRORS
	if (status1 & DPE) {
		PCI_PRINT(("%s: Data Parity Error Detected during address "
			   "or write data phase\n", ahc_name(ahc)));
	}
#endif
	if (status1 & SSE) {
		PCI_PRINT(("%s: Signal System Error Detected\n", ahc_name(ahc)));
	}
	if (status1 & RMA) {
		PCI_PRINT(("%s: Received a Master Abort\n", ahc_name(ahc)));
	}
	if (status1 & RTA) {
		PCI_PRINT(("%s: Received a Target Abort\n", ahc_name(ahc)));
	}
	if (status1 & STA) {
		PCI_PRINT(("%s: Signaled a Target Abort\n", ahc_name(ahc)));
	}
	if (status1 & DPR) {
		PCI_PRINT(("%s: Data Parity Error has been reported via PERR#\n",
			   ahc_name(ahc)));
	}
	
	ahc_pci_write_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, status1, 4);
d1655 16
a1670 5
	if ((status1 & (DPE|SSE|RMA|RTA|STA|DPR)) == 0) {
		printf("%s: Latched PCIERR interrupt with "
		       "no status bits set\n", ahc_name(ahc)); 
	} else {
		ahc_outb(ahc, CLRINT, CLRPARERR);
d1672 2
a1673 4
	
	ahc_unpause(ahc);

	return;
d1677 1
a1677 1
verify_cksum(struct seeprom_config *sc)
d1679 19
a1697 16
	int i;
	int maxaddr;
	u_int32_t checksum;
	u_int16_t *scarray;

	maxaddr = (sizeof(*sc)/2) - 1;
	checksum = 0;
	scarray = (uint16_t *)sc;

	for (i = 0; i < maxaddr; i++)
		checksum = checksum + scarray[i];
	if (checksum == 0 ||
	    (checksum & 0xFFFF) != sc->checksum) {
		return (0);
	} else {
		return (1);
d1699 2
@


1.40
log
@- remove ahc dependency, convert smc93cx6 into an attribute.
- support for 8 and 32 bit registers.
from NetBSD.
deraadt@@ and krw@@ testing and ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.39 2003/08/12 10:27:10 fgsch Exp $	*/
d179 1
d290 1
@


1.39
log
@move verify_cksum() to ahc; krw@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.38 2003/07/25 09:49:21 henning Exp $	*/
d951 3
a953 1
	sd.sd_ahc = ahc;
@


1.38
log
@The AIC5900 and AIC5905 are ATM chipsets, not SCSI controllers.
Jason Ackley <jason@@ackley.net> in PR3368
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.37 2003/02/18 13:14:42 jmc Exp $	*/
d148 1
d1666 22
@


1.37
log
@intial -> initial;

the great intial witch hunt, as prompted by tdeval@@

os-aix-dso.c: ok henning@@
ab.C: ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.36 2002/11/19 18:40:16 jason Exp $	*/
a162 2
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC5900 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC5905 },
@


1.36
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.35 2002/07/05 05:41:02 smurph Exp $	*/
d583 1
a583 1
	 * intialization.
@


1.35
log
@attempt to make ahc smaller.  change PCI interrupt handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.34 2002/06/30 19:19:49 smurph Exp $	*/
d159 37
d201 2
a202 49
	struct pci_attach_args *pa = aux;

	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_ADP:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_ADP_AIC7810:
		case PCI_PRODUCT_ADP_AIC7850:
		case PCI_PRODUCT_ADP_AIC7855:
		case PCI_PRODUCT_ADP_AIC5900:
		case PCI_PRODUCT_ADP_AIC5905:
		case PCI_PRODUCT_ADP_AIC7860:
		case PCI_PRODUCT_ADP_2940AU:
		case PCI_PRODUCT_ADP_AIC7870:
		case PCI_PRODUCT_ADP_2930CU:
		case PCI_PRODUCT_ADP_2940:
		case PCI_PRODUCT_ADP_3940:
		case PCI_PRODUCT_ADP_3985:
		case PCI_PRODUCT_ADP_2944:
		case PCI_PRODUCT_ADP_AIC7880:
		case PCI_PRODUCT_ADP_2940U:
		case PCI_PRODUCT_ADP_3940U:
		case PCI_PRODUCT_ADP_398XU:
		case PCI_PRODUCT_ADP_2944U:
		case PCI_PRODUCT_ADP_2940UWPro:
		case PCI_PRODUCT_ADP_7895:
			return (1);
		}
			break;
	case PCI_VENDOR_ADP2:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_ADP2_AIC7890:
		case PCI_PRODUCT_ADP2_2940U2:
		case PCI_PRODUCT_ADP2_2930U2:
		case PCI_PRODUCT_ADP2_AIC7892:
		case PCI_PRODUCT_ADP2_29160:
		case PCI_PRODUCT_ADP2_19160B:
		case PCI_PRODUCT_ADP2_3950U2B:
		case PCI_PRODUCT_ADP2_3950U2D:
		case PCI_PRODUCT_ADP2_AIC7896:
		case PCI_PRODUCT_ADP2_AIC7899B:
		case PCI_PRODUCT_ADP2_AIC7899D:
		case PCI_PRODUCT_ADP2_AIC7899F:
		case PCI_PRODUCT_ADP2_AIC7899:
		case PCI_PRODUCT_ADP2_3960D:
			return (1);
		}
		break;
	}
	return (0);
@


1.34
log
@Make sure interrupts are disabled at init and attempt better termination.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.33 2002/06/29 23:53:33 miod Exp $	*/
d408 3
a410 2
	ahc->platform_data->pci_intr_func = ahc_pci_intr;
	
d1627 1
a1627 1
int
d1634 1
a1634 1
		return 0;
d1676 1
a1676 1
	return 1;
@


1.33
log
@Be sure to correctly initialize the ahc_softc members before using
ahc_inb(), to prevent an early panic. This could only affect non-i386
architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.32 2002/06/28 00:34:54 smurph Exp $	*/
d505 5
d517 8
a524 4
	ahc->chip |= AHC_PCI; /* we are a PCI controller */
#if 0
	ahc_power_state_change(ahc, AHC_POWER_STATE_D0);
#endif 
d1042 6
d1323 9
@


1.32
log
@Return of new ahc
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.31 2002/03/19 21:07:25 millert Exp $	*/
d454 2
d547 1
a547 1
	/* Remeber how the card was setup in case there is no SEEPROM */
@


1.31
log
@remove __P
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.30 2002/03/19 02:49:20 millert Exp $	*/
d56 2
a57 1
#include <dev/ic/aic7xxxvar.h>
d92 3
d97 3
a99 2
#define		MPORTMODE	0x00000400UL	/* aic7870 only */
#define		RAMPSM		0x00000200UL	/* aic7870 only */
d101 1
a102 1
#define		PCI64		0x00000080UL	/* aic7891 & aic7897 only */
d105 1
a105 1
#define		EXTSCBPEN	0x00000010UL	/* aic7870 & aic7890 only */
d112 2
a113 2
#define		CACHESIZE	0x0000003ful	/* only 5 bits */
#define		LATTIME		0x0000ff00ul
a114 1
int	    ahc_pci_intr(struct ahc_softc *ahc);
d116 2
a117 2
static void ahc_ext_scbram_config(struct ahc_softc *ahc, int enable,
				  int pcheck, int fast);
d142 2
a158 6
struct ahc_pci_data {
	pci_chipset_tag_t pc;
	pcitag_t tag;
	u_int function;
};

d222 5
a226 18
	bus_space_tag_t  iot;
	bus_space_handle_t ioh;
	pci_intr_handle_t ih;
	pcireg_t	   command;
	const char *intrstr;
	unsigned opri = 0;
	ahc_chip ahc_c = AHC_PCI; /* we are a PCI controller */
	ahc_flag ahc_flags = AHC_FNONE;
	ahc_feature ahc_f = AHC_FENONE;
	int	ioh_valid;

	u_char ultra_enb = 0;
	u_char our_id = 0;
	u_char channel = 'A';
	u_int    sxfrctl1;
	u_int    scsiseq;
	/* So we can access PCI configuration space after init */
	struct ahc_pci_data *pd;
d228 8
a235 1
	ahc->sc_dmat = pa->pa_dmat;
d237 6
a242 3
	command = pci_conf_read(pa->pa_pc, pa->pa_tag,
				PCI_COMMAND_STATUS_REG);

d247 7
a253 17
			{
				pcireg_t devconfig;
				channel = pa->pa_function == 1 ? 'B' : 'A';
				ahc_c |= AHC_AIC7895;
				/* The 'C' revision of the aic7895 
				   has a few additional features */
				if (PCI_REVISION(pa->pa_class) >= 4)
					ahc_f = AHC_AIC7895C_FE;
				else
					ahc_f = AHC_AIC7895_FE;
				ahc_flags |= AHC_NEWEEPROM_FMT;
				devconfig = pci_conf_read(pa->pa_pc, 
							  pa->pa_tag,
							  DEVCONFIG);
				devconfig &= ~SCBSIZE32;
				pci_conf_write(pa->pa_pc, pa->pa_tag,
					       DEVCONFIG, devconfig);
d256 1
a256 1
	   case PCI_PRODUCT_ADP_3940U:
d259 1
a259 2
				ahc_c |= AHC_AIC7880;
				ahc_f = AHC_AIC7880_FE;
d261 1
a261 2
				ahc_c |= AHC_AIC7870;
				ahc_f = AHC_AIC7870_FE;
d266 1
a266 1
				channel = 'B';
d269 4
a272 3
			ahc_c |= AHC_AIC7880;
			ahc_f = AHC_AIC7880_FE;
			ahc_f |= AHC_INT50_SPEEDFLEX;
d275 1
a275 2
			ahc_c |= AHC_AIC7880;
			ahc_f = AHC_AIC7880_FE;
d277 1
d280 1
a280 2
			ahc_c |= AHC_AIC7870;
			ahc_f = AHC_AIC7870_FE;
d282 1
d284 1
a284 15
			ahc_c |= AHC_AIC7860;
			ahc_f = AHC_AIC7860_FE;
			break;
		case PCI_PRODUCT_ADP_398XU:	/* XXX */
		case PCI_PRODUCT_ADP_AIC7880:
			ahc_c |= AHC_AIC7880;
			ahc_f = AHC_AIC7880_FE;
			break;
		case PCI_PRODUCT_ADP_AIC7870:
			ahc_c |= AHC_AIC7870;
			ahc_f = AHC_AIC7870_FE;
			break;
		case PCI_PRODUCT_ADP_AIC7860:
			ahc_c |= AHC_AIC7860;
			ahc_f = AHC_AIC7860_FE;
d288 1
a288 2
			ahc_c |= AHC_AIC7850;
			ahc_f = AHC_AIC7850_FE;
d300 1
a300 3
			ahc_c |= AHC_AIC7890;
			ahc_f = AHC_AIC7890_FE;
			ahc_flags |= AHC_NEWEEPROM_FMT;
d305 1
a305 3
			ahc_c |= AHC_AIC7892;
			ahc_f = AHC_AIC7892_FE;
			ahc_flags |= AHC_NEWEEPROM_FMT;
d310 8
a317 14
			{
				pcireg_t devconfig;
				channel = pa->pa_function == 1 ? 'B' : 'A';
				ahc_c |= AHC_AIC7896;
				ahc_f = AHC_AIC7896_FE;
				ahc_flags |= AHC_NEWEEPROM_FMT;
				devconfig = pci_conf_read(pa->pa_pc, 
							  pa->pa_tag, 
							  DEVCONFIG);
				/* turn off 64 bit for now XXX smurph */
				devconfig &= ~PCI64;
				pci_conf_write(pa->pa_pc, pa->pa_tag, 
					       DEVCONFIG, devconfig);
			}
d321 2
a322 3
			ahc_c |= AHC_AIC7899;
			ahc_f = AHC_AIC7899_FE;
			ahc_flags |= AHC_NEWEEPROM_FMT;
d329 98
d428 2
d449 16
d472 6
d483 1
a483 1
		return;
d485 4
a488 4
	
	/* Ensure busmastering is enabled */
	command |= PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
d490 24
a513 5
	pd = malloc(sizeof (struct ahc_pci_data), M_DEVBUF, M_NOWAIT);
	if (pd == NULL) {
		printf(": error allocating pci data\n");
		return;
	}
d515 8
a522 7
	pd->pc = pa->pa_pc;
	pd->tag = pa->pa_tag;
	pd->function = pa->pa_function;

	/* setup the PCI stuff */
	ahc->pci_data = pd;
	ahc->pci_intr_func = ahc_pci_intr;
d524 11
d536 2
d539 1
a539 1
	ahc_flags |= AHC_PAGESCBS;
d541 3
a543 2
	ahc_construct(ahc, pa->pa_iot, ioh, ahc_c, ahc_flags, ahc_f, channel);
	/* Now we can use the ahc_inb and ahc_outb macros */
a544 3
	/* setup the PCI error interrupt handler */
	ahc->pci_intr_func = &ahc_pci_intr;
	
d546 12
a557 12
	ahc_outb(ahc, HCNTRL, ahc->pause);
	if ((ahc->features & AHC_ULTRA2) != 0)
		our_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;
	else
		our_id = ahc_inb(ahc, SCSIID) & OID;
	sxfrctl1 = ahc_inb(ahc, SXFRCTL1) & STPWEN;
	scsiseq = ahc_inb(ahc, SCSISEQ);
	
	if (ahc_reset(ahc) != 0) {
		/* Failed */
		ahc_free(ahc);
		return;
d559 5
a563 5
	
	if (ahc->features & AHC_ULTRA)
		ultra_enb = bus_space_read_1(pa->pa_iot, ioh, SXFRCTL0) &
						FAST20;
	
a564 1
		u_int optionmode;
d570 2
a571 7
		optionmode = ahc_inb(ahc, OPTIONMODE);
		if (bootverbose)
			printf("%s: OptionMode = %x\n", ahc_name(ahc), optionmode);
		ahc_outb(ahc, OPTIONMODE, OPTIONMODE_DEFAULTS);
		/* Send CRC info in target mode every 4K */
		ahc_outb(ahc, TARGCRCCNT, 0);
		ahc_outb(ahc, TARGCRCCNT + 1, 0x10);
d576 1
a576 1
					|TARGCRCENDEN|TARGCRCCNTEN);
a578 20
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		ahc_free(ahc);
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	ahc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, ahc_intr, ahc,
	    ahc->sc_dev.dv_xname);

	if (ahc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		ahc_free(ahc);
		return;
	}
	if (intrstr != NULL)
		printf(": %s\n", intrstr);

d584 11
d597 2
a598 1
	 * Do aic7880/aic7870/aic7860/aic7850 specific initialization
d600 20
a619 3
	{
		u_int8_t sblkctl;
		u_int dscommand0;
d621 6
a626 3
		dscommand0 = ahc_inb(ahc, DSCOMMAND0);
		dscommand0 |= MPARCKEN;
		if ((ahc->features & AHC_ULTRA2) != 0) {
d628 4
a631 7
			/*
			 * DPARCKEN doesn't work correctly on
			 * some MBs so don't use it.
			 */
			dscommand0 &= ~(USCBSIZE32|DPARCKEN);
			dscommand0 |= CACHETHEN;
		}
d633 2
a634 1
		ahc_outb(ahc, DSCOMMAND0, dscommand0);
d636 5
a640 2
		/* See if we have an SEEPROM and perform auto-term */
		check_extport(ahc, &sxfrctl1);
d642 5
a646 5
		/*
		 * Take the LED out of diagnostic mode
		 */
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, (sblkctl & ~(DIAGLEDEN|DIAGLEDON)));
d648 1
d650 3
a652 3
		 * I don't know where this is set in the SEEPROM or by the
		 * BIOS, so we default to 100% on Ultra or slower controllers
		 * and 75% on ULTRA2 controllers.
d654 6
a659 2
		if ((ahc->features & AHC_ULTRA2) != 0) {
			ahc_outb(ahc, DFF_THRSH, RD_DFTHRSH_75|WR_DFTHRSH_75);
a660 4
			ahc_outb(ahc, DSPCISTATUS, DFTHRSH_100);
		}

		if (ahc->flags & AHC_USEDEFAULTS) {
d662 2
a663 3
			 * PCI Adapter default setup
			 * Should only be used if the adapter does not have
			 * an SEEPROM.
d665 4
a668 14
			/* See if someone else set us up already */
			if (scsiseq != 0) {
				printf("%s: Using left over BIOS settings\n",
						 ahc_name(ahc));
				ahc->flags &= ~AHC_USEDEFAULTS;
			} else {
				/*
				 * Assume only one connector and always turn
				 * on termination.
				 */
				our_id = 0x07;
				sxfrctl1 = STPWEN;
			}
			ahc_outb(ahc, SCSICONF, our_id|ENSPCHK|RESET_SCSI);
d670 1
a670 2
			ahc->our_id = our_id;
		}
a679 2
	printf("%s: ", ahc_name(ahc));

d687 21
a707 5
	if (ahc_init(ahc)) {
		ahc_free(ahc);
		splx(opri);
		return; /* XXX PCI code should take return status */
	}
d710 32
a741 1
	ahc_attach(ahc);
d749 1
a749 2
ahc_ext_scbram_present(ahc)
struct ahc_softc *ahc;
d751 1
d754 5
a758 2
	pcireg_t devconfig;
	struct ahc_pci_data *pd = ahc->pci_data;
a759 1
	devconfig = pci_conf_read(pd->pc, pd->tag, DEVCONFIG);
d764 1
a764 1
	else if ((ahc->chip & AHC_CHIPID_MASK) >= AHC_AIC7870)
d767 1
a767 1
		ramps	= 0;
d778 6
a783 5
ahc_ext_scbram_config(ahc, enable, pcheck, fast)
struct ahc_softc *ahc;
int enable;
int pcheck;
int fast;
a785 1
	struct ahc_pci_data *pd = ahc->pci_data;
a787 1
		u_char channel; 
d792 1
a792 2
		channel = pd->function == 1 ? 1 : 0;
		ahc_outb(ahc, SCBBADDR, channel);
d795 1
a795 2
	devconfig = pci_conf_read(pd->pc, pd->tag, DEVCONFIG);
	
d804 4
d818 4
d828 1
a828 1
	pci_conf_write(pd->pc, pd->tag, DEVCONFIG, devconfig);
d838 1
a838 1
struct ahc_softc *ahc;
d845 1
d847 6
d854 1
a854 1
		return;
d859 1
a859 4
	enable = 0;
	pcheck = 0;
	fast = 0;
	ahc_ext_scbram_config(ahc,	/*enable*/1, pcheck, fast);
d865 10
a874 1
	enable = 1;
d877 1
a877 1
	ahc_ext_scbram_config(ahc, enable, /*pcheck*/1, fast);
d880 2
a881 2
		 || (ahc_inb(ahc, ERROR) & MPARERR) == 0)
		pcheck = 1;
d888 1
a888 1
	ahc_ext_scbram_config(ahc, enable, pcheck, /*fast*/1);
d891 3
a893 3
		 && ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0
			  || (ahc_inb(ahc, ERROR) & MPARERR) == 0))
		fast = 1;
d895 28
a922 2
	done:
	/* Clear any resulting parity error */
d926 4
a929 4
		printf("%s: External SRAM, %dns access%s\n",
				 ahc_name(ahc), fast ? 10 : 20,
				 pcheck ? ", parity checking enabled" : "");

d931 1
a931 1
	ahc_ext_scbram_config(ahc, enable, pcheck, fast);
d940 2
a941 2
struct ahc_softc *ahc;
u_int *sxfrctl1;
d943 11
a953 12
	struct     seeprom_descriptor sd;
	struct     seeprom_config sc;
	u_int   scsi_conf;
	u_int   adapter_control;
	int     have_seeprom;
	int     have_autoterm;

	sd.sd_tag = ahc->sc_iot;
	sd.sd_bsh = ahc->sc_ioh;
	sd.sd_control_offset = SEECTL;      
	sd.sd_status_offset = SEECTL;    
	sd.sd_dataout_offset = SEECTL;      
d976 1
a976 1
		if (bootverbose)
d980 1
a980 1
			bus_size_t start_addr;
d984 9
a992 21
			have_seeprom = read_seeprom(&sd,
						    (u_int16_t *)&sc,
						    start_addr,
						    sizeof(sc)/2);

			if (have_seeprom) {
				/* Check checksum */
				int i;
				int maxaddr;
				u_int32_t checksum;
				u_int16_t *scarray;

				maxaddr = (sizeof(sc)/2) - 1;
				checksum = 0;
				scarray = (u_int16_t *)&sc;

				for (i = 0; i < maxaddr; i++)
					checksum = checksum + scarray[i];
				if (checksum == 0
				    || (checksum & 0xFFFF) != sc.checksum) {
					if (bootverbose && sd.sd_chip == C56_66)
d994 2
a995 5
					have_seeprom = 0;
				} else {
					if (bootverbose)
						printf("done.\n");
					break;
d997 1
d999 4
d1004 26
a1029 3
			if (sd.sd_chip == C56_66)
				break;
			sd.sd_chip = C56_66;
d1044 2
a1045 2
		u_int16_t discenable;
		u_int16_t ultraenb;
d1055 1
a1055 1
				if ((sc.device_flags[i] & CFSYNCHISULTRA) != 0) {
d1064 1
a1064 1
			u_int16_t target_mask;
d1076 1
a1076 1
				 && (ultraenb & target_mask) != 0) {
d1079 1
a1079 1
				ultraenb &= ~target_mask;
d1086 1
a1086 1
				else
d1090 5
d1096 2
a1097 1
				| ((ultraenb & target_mask) ? 0x8 : 0x0);
d1117 3
d1122 3
d1126 1
a1126 1
			 && (ahc->flags & AHC_NEWEEPROM_FMT) == 0) {
d1132 14
d1173 1
a1173 1
			have_autoterm = 1;
d1175 1
a1175 1
			have_autoterm = 0;
d1178 2
a1179 1
	if (have_autoterm)
d1181 2
a1182 2

	release_seeprom(&sd);
d1186 4
a1189 5
configure_termination(ahc, sd, adapter_control, sxfrctl1)
struct ahc_softc *ahc;
struct seeprom_descriptor *sd;
u_int adapter_control;
u_int *sxfrctl1;
d1191 2
a1192 2
	u_int8_t brddat;

d1200 1
a1200 1

d1208 1
a1208 1
		 || (ahc->features & AHC_NEW_TERMCTL) != 0) {
d1217 1
d1225 4
a1228 4
					    &enableSEC_high,
					    &enablePRI_low,
					    &enablePRI_high,
					    &eeprom_present);
d1232 4
a1235 3
							 ahc_name(ahc));
				enableSEC_low = (adapter_control & CFSTERM);
				enableSEC_high = (adapter_control & CFWSTERM);
d1241 2
a1242 2
				enablePRI_low = enablePRI_high =
					(adapter_control & CFLVDSTERM);
d1262 8
a1269 6
		if (bootverbose) {
			if ((ahc->features & AHC_ULTRA2) == 0) {
				printf("%s: internal 50 cable %s present, "
				       "internal 68 cable %s present\n",
				       ahc_name(ahc),
				       internal50_present ? "is":"not",
d1271 5
a1275 5

				printf("%s: external cable %s present\n",
				       ahc_name(ahc),
				       externalcable_present ? "is":"not");
			}
a1277 1
		}
d1299 3
a1301 3
		    && (internal50_present != 0)
		    && (internal68_present != 0)
		    && (externalcable_present != 0)) {
d1309 3
a1311 3
			 && ((externalcable_present == 0)
				  || (internal68_present == 0)
				  || (enableSEC_high != 0))) {
d1321 1
a1321 1
					       : "");
d1325 3
a1327 4
		if (((internal50_present ? 1 : 0)
			  + (internal68_present ? 1 : 0)
			  + (externalcable_present ? 1 : 0)) <= 1
			 || (enableSEC_low != 0)) {
d1340 1
a1340 1
					       : "");
d1364 1
a1364 1

d1374 2
a1375 2
				       (ahc->features & AHC_ULTRA2)
				       ? "Primary " : "");
d1378 2
a1379 1
		if ((adapter_control & CFWSTERM) != 0) {
d1385 1
a1385 1
				       ? "Secondary " : "");
d1394 2
a1395 1
		write_brdctl(ahc, brddat);
d1403 6
a1408 6
struct ahc_softc *ahc;
int *enableSEC_low;
int *enableSEC_high;
int *enablePRI_low;
int *enablePRI_high;
int *eeprom_present;
d1430 5
a1434 5
struct ahc_softc *ahc;
int *internal50_present;
int *internal68_present;
int *externalcable_present;
int *eeprom_present;
d1453 2
a1454 2
	*internal50_present = !(brdctl & BRDDAT6);
	*internal68_present = !(brdctl & BRDDAT7);
d1468 2
a1469 2
	*externalcable_present = !(brdctl & BRDDAT6);
	*eeprom_present = brdctl & BRDDAT7;
d1475 4
a1478 4
struct ahc_softc *ahc;
int *internal50_present;
int *externalcable_present;
int *eeprom_present;
d1485 2
a1486 2
	*internal50_present = !(brdctl & BRDDAT5);
	*externalcable_present = !(brdctl & BRDDAT6);
d1488 1
a1488 1
	*eeprom_present = (ahc_inb(ahc, SPIOCAP) & EEPROM) != 0;
d1493 2
a1494 2
struct   ahc_softc *ahc;
u_int8_t value;
d1508 1
a1508 1
	DELAY(20);
d1511 1
a1511 1
	DELAY(20);
d1517 1
a1517 1
	DELAY(20);
d1527 1
a1527 1
struct   ahc_softc *ahc;
d1542 1
a1542 1
	DELAY(20);
d1550 2
a1551 2
struct ahc_softc *ahc;
struct seeprom_descriptor *sd;
d1580 1
a1580 1
struct seeprom_descriptor *sd;
d1593 7
d1602 1
a1602 1
struct ahc_softc *ahc;
a1604 1
	struct ahc_pci_data *pd = ahc->pci_data;
d1608 5
a1612 2

	status1 = pci_conf_read(pd->pc, pd->tag, PCI_COMMAND_STATUS_REG);
d1615 1
a1615 1
#ifdef AHC_SHOW_PCI_ERRORS	
d1617 2
a1618 2
		printf("%s: Data Parity Error Detected during address "
				 "or write data phase\n", ahc_name(ahc));
d1622 1
a1622 1
		printf("%s: Signal System Error Detected\n", ahc_name(ahc));
d1625 1
a1625 1
		printf("%s: Received a Master Abort\n", ahc_name(ahc));
d1628 1
a1628 1
		printf("%s: Received a Target Abort\n", ahc_name(ahc));
d1631 1
a1631 1
		printf("%s: Signaled a Target Abort\n", ahc_name(ahc));
d1634 2
a1635 2
		printf("%s: Data Parity Error has been reported via PERR#\n",
				 ahc_name(ahc));
d1637 3
d1642 2
a1643 5
				 "no status bits set\n", ahc_name(ahc)); 
	}
	pci_conf_write(pd->pc, pd->tag, PCI_COMMAND_STATUS_REG, status1);

	if (status1 & (DPR|RMA|RTA)) {
d1646 2
@


1.30
log
@revert to older ahc driver until the new one's bugs are fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.26 2001/09/21 17:55:43 miod Exp $	*/
d110 33
a142 33
int	    ahc_pci_intr __P((struct ahc_softc *ahc));
static int  ahc_ext_scbram_present __P((struct ahc_softc *ahc));
static void ahc_ext_scbram_config __P((struct ahc_softc *ahc, int enable,
													int pcheck, int fast));
static void ahc_probe_ext_scbram __P((struct ahc_softc *ahc));
static void check_extport __P((struct ahc_softc *ahc, u_int *sxfrctl1));
static void configure_termination __P((struct ahc_softc *ahc,
				       struct seeprom_descriptor *sd,
				       u_int adapter_control,
				       u_int *sxfrctl1));
static void ahc_new_term_detect __P((struct ahc_softc *ahc,
				     int *enableSEC_low,
				     int *enableSEC_high,
				     int *enablePRI_low,
				     int *enablePRI_high,
				     int *eeprom_present));
static void aic787X_cable_detect __P((struct ahc_softc *ahc,
				      int *internal50_present,
				      int *internal68_present,
				      int *externalcable_present,
				      int *eeprom_present));
static void aic785X_cable_detect __P((struct ahc_softc *ahc,
				      int *internal50_present,
				      int *externalcable_present,
				      int *eeprom_present));
static void write_brdctl __P((struct ahc_softc *ahc, u_int8_t value));
static u_int8_t read_brdctl __P((struct ahc_softc *ahc));

void load_seeprom __P((struct ahc_softc *ahc));
static int acquire_seeprom __P((struct ahc_softc *ahc,
				struct seeprom_descriptor *sd));
static void release_seeprom __P((struct seeprom_descriptor *sd));
int ahc_probe_scbs __P((struct ahc_softc *ahc));
d146 2
a147 2
int ahc_pci_probe __P((struct device *, void *, void *));
void ahc_pci_attach __P((struct device *, struct device *, void *));
@


1.29
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.28 2002/02/18 23:25:38 smurph Exp $	*/
d56 2
a57 3
#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>
#include <dev/ic/aic7xxx_93cx6.h>
a90 3
#define	EXROMBADR		0x30
#define 	EXROMEN		0x00000001ul	/* External Rom Enable */

d92 13
a104 14
#define		SCBSIZE32	0x00010000ul	/* aic789X only */
#define		REXTVALID	0x00001000ul	/* ultra cards only */
#define		MPORTMODE	0x00000400ul	/* aic7870+ only */
#define		RAMPSM		0x00000200ul	/* aic7870+ only */
#define		VOLSENSE	0x00000100ul
#define		PCI64BIT	0x00000080ul	/* 64Bit PCI bus (Ultra2 Only)*/
#define		SCBRAMSEL	0x00000080ul
#define		MRDCEN		0x00000040ul
#define		EXTSCBTIME	0x00000020ul	/* aic7870 only */
#define		EXTSCBPEN	0x00000010ul	/* aic7870 only */
#define		BERREN		0x00000008ul
#define		DACEN		0x00000004ul
#define		STPWLEVEL	0x00000002ul
#define		DIFACTNEGEN	0x00000001ul	/* aic7870 only */
d110 7
a116 6
static int  ahc_ext_scbram_present(struct ahc_softc *ahc);
static void ahc_scbram_config(struct ahc_softc *ahc, int enable,
				   int pcheck, int fast, int large);
static void ahc_probe_ext_scbram(struct ahc_softc *ahc);
static void check_extport(struct ahc_softc *ahc, u_int *sxfrctl1);
static void configure_termination(struct ahc_softc *ahc,
d119 2
a120 2
				       u_int *sxfrctl1);
static void ahc_new_term_detect(struct ahc_softc *ahc,
d125 2
a126 2
				     int *eeprom_present);
static void aic787X_cable_detect(struct ahc_softc *ahc,
d130 2
a131 2
				      int *eeprom_present);
static void aic785X_cable_detect(struct ahc_softc *ahc,
d134 9
a142 11
				      int *eeprom_present);
static void write_brdctl(struct ahc_softc *ahc, u_int8_t value);
static u_int8_t read_brdctl(struct ahc_softc *ahc);

int ahc_do_pci_config(struct ahc_softc *ahc);

void load_seeprom(struct ahc_softc *ahc);
static int acquire_seeprom(struct ahc_softc *ahc,
				struct seeprom_descriptor *sd);
static void release_seeprom(struct seeprom_descriptor *sd);
int ahc_probe_scbs(struct ahc_softc *ahc);
d146 2
a147 2
int ahc_pci_probe(struct device *, void *, void *);
void ahc_pci_attach(struct device *, struct device *, void *);
d153 6
d222 20
a241 2
	pcireg_t devconfig;
	pcireg_t command;
d243 2
a244 2
	/* setup the PCI stuff */
	ahc->dev_softc = pa;
a245 15
	/* 
	 * We really don't allocate our softc, but 
	 * we need to do the initialization. And this 
	 * also allocates the platform_data structure.
	 */
	ahc_alloc(ahc, NULL);
	ahc_set_name(ahc, ahc->sc_dev.dv_xname);
	ahc_set_unit(ahc, ahc->sc_dev.dv_unit);
	
	/* set dma tags */
	ahc->parent_dmat = pa->pa_dmat;
	ahc->buffer_dmat = pa->pa_dmat;
        ahc->shared_data_dmat = pa->pa_dmat;
	
	/* card specific setup */
d250 17
a266 7
			ahc->channel = pa->pa_function == 1 ? 'B' : 'A';
			/* The 'C' revision of the aic7895 
			   has a few additional features */
			if (PCI_REVISION(pa->pa_class) >= 4){
				ahc->chip |= AHC_AIC7895C;
			} else {
				ahc->chip |= AHC_AIC7895;
d269 1
a269 1
		case PCI_PRODUCT_ADP_3940U:
d272 2
a273 1
				ahc->chip |= AHC_AIC7880;
d275 2
a276 1
				ahc->chip |= AHC_AIC7870;
d281 1
a281 1
				ahc->channel = 'B';
d284 3
a286 4
			ahc->flags |= AHC_INT50_SPEEDFLEX;
			/* fall through */
		case PCI_PRODUCT_ADP_AIC7880:
		case PCI_PRODUCT_ADP_398XU:	/* XXX */
d289 2
a290 1
			ahc->chip |= AHC_AIC7880;
a291 1
		case PCI_PRODUCT_ADP_AIC7870:
d294 15
a308 1
			ahc->chip |= AHC_AIC7870;
d311 2
a312 2
		case PCI_PRODUCT_ADP_2940AU:
			ahc->chip |= AHC_AIC7860;
d316 2
a317 1
			ahc->chip |= AHC_AIC7850;
d329 3
a331 1
			ahc->chip |= AHC_AIC7890;
d336 3
a338 1
			ahc->chip |= AHC_AIC7892;
d343 14
a356 8
			ahc->chip |= AHC_AIC7896;
			ahc->channel = pa->pa_function == 1 ? 'B' : 'A';
			devconfig = ahc_pci_read_config(ahc->dev_softc, 
						  DEVCONFIG, 4);
			/* turn off 64 bit for now XXX smurph */
			devconfig &= ~PCI64BIT;
			ahc_pci_write_config(ahc->dev_softc, 
				       DEVCONFIG, devconfig, 4);
d360 3
a362 2
			ahc->chip |= AHC_AIC7899;
			ahc->channel = pa->pa_function == 1 ? 'B' : 'A';
a368 98
	
	/* chip specific setup */
	switch(ahc->chip){
	case AHC_AIC7850:
	case AHC_AIC7855:
	case AHC_AIC7859:
		ahc->features = AHC_AIC7850_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		if (PCI_REVISION(pa->pa_class) >= 1)
			ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
		break;
	case AHC_AIC7860:
		ahc->features = AHC_AIC7860_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		if (PCI_REVISION(pa->pa_class) >= 1)
			ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
		break;
	case AHC_AIC7870:
		ahc->features = AHC_AIC7870_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		break;
	case AHC_AIC7880:
		ahc->features = AHC_AIC7880_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
		if (PCI_REVISION(pa->pa_class) >= 1) {
			ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
		} else {
			ahc->bugs |= AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		}
		break;
	case AHC_AIC7895:
		ahc->features = AHC_AIC7895_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		/*
		 * The BIOS disables the use of MWI transactions
		 * since it does not have the MWI bug work around
		 * we have.  Disabling MWI reduces performance, so
		 * turn it on again.
		 */
		command = pci_conf_read(pa->pa_pc, pa->pa_tag,
					PCI_COMMAND_STATUS_REG);
		command |= PCI_COMMAND_INVALIDATE_ENABLE;
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
			       command);
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_PCI_2_1_RETRY_BUG
			  |  AHC_CACHETHEN_BUG | AHC_PCI_MWI_BUG;
		break;		
	case AHC_AIC7895C:
		ahc->features = AHC_AIC7895C_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_PCI_2_1_RETRY_BUG
			  |  AHC_CACHETHEN_BUG;
		break;
	case AHC_AIC7890:
		ahc->features = AHC_AIC7890_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		if (PCI_REVISION(pa->pa_class) == 0)
			ahc->bugs |= AHC_AUTOFLUSH_BUG|AHC_CACHETHEN_BUG;
		break;
	case AHC_AIC7892:
		ahc->features = AHC_AIC7892_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;
		break;
	case AHC_AIC7896:
		ahc->features = AHC_AIC7896_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_CACHETHEN_DIS_BUG;
		break;
	case AHC_AIC7899:
		ahc->features = AHC_AIC7899_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;
		break;
	default:
		break;
	}

	/* setup the PCI interrupt */
	ahc->platform_data->pci_intr_func = ahc_pci_intr;
	
	if(ahc_do_pci_config(ahc)){
		ahc_free(ahc);
		return;
	}
	
	ahc_attach(ahc);
}

int
ahc_pci_map_registers(ahc)
	struct ahc_softc *ahc;
{
	pcireg_t	command;
	int		ioh_valid;
	bus_space_tag_t  iot;
	bus_space_handle_t ioh;
	struct pci_attach_args *pa = ahc->dev_softc;
a369 2
	command = ahc_pci_read_config(ahc->dev_softc,
				      PCI_COMMAND_STATUS_REG, 4);
a388 16
		if (ioh_valid) {
			/*
			 * Do a quick test to see if memory mapped
			 * I/O is functioning correctly.
			 */
			if (ahc_inb(ahc, HCNTRL) == 0xFF) {
				/* nope, use I/O mapping */
                                ioh_valid = 0;
			} else {
				/* Using memory mapping, disable I/O mapping */
                                command &= ~PCI_COMMAND_IO_ENABLE;
				ahc_pci_write_config(ahc->dev_softc,
						     PCI_COMMAND_STATUS_REG,
						     command, 4);
			}
		}
a395 6
		
		/* Using I/O mapping, disable memory mapping */
		command &= ~PCI_COMMAND_MEM_ENABLE;
		ahc_pci_write_config(ahc->dev_softc,
				     PCI_COMMAND_STATUS_REG,
				     command, 4);
d401 11
a411 1
		return (1);
a412 4
	ahc->tag = iot;
	ahc->bsh = ioh;
	return (0);
}
d414 3
a416 24
int
ahc_do_pci_config(ahc)
	struct ahc_softc *ahc;
{
	pcireg_t	 command;
	u_int		 our_id = 0;
	u_int		 sxfrctl1;
	u_int		 scsiseq;
	u_int		 dscommand0;
	int		 error;
	int		 opri;
	uint8_t		 sblkctl;

	error = ahc_pci_map_registers(ahc);
	if (error != 0)
		return (error);
	/* 
	 * Registers are mapped. Now it is safe to use 
	 * the ahc_inb and ahc_outb macros. 
	 */
	ahc->chip |= AHC_PCI; /* we are a PCI controller */
#if 0
	ahc_power_state_change(ahc, AHC_POWER_STATE_D0);
#endif 
d418 3
a420 8
	/*
	 * If we need to support high memory, enable dual
	 * address cycles.  This bit must be set to enable
	 * high address bit generation even if we are on a
	 * 64bit bus (PCI64BIT set in devconfig).
	 */
	if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
		pcireg_t devconfig;
a421 11
		if (bootverbose)
			printf("%s: Enabling 39Bit Addressing\n",
			       ahc_name(ahc));
		devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
		devconfig |= DACEN;
		ahc_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig, 4);
	}
	
	/* Ensure busmastering is enabled */
        command = ahc_pci_read_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, 4);
	command |= PCI_COMMAND_MASTER_ENABLE; 
a422 2
	ahc_pci_write_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, command, 4);
	
d424 1
a424 1
	ahc->flags |= AHC_PAGESCBS;
d426 2
a427 3
	error = ahc_softc_init(ahc);
	if (error != 0)
		return (error);
d429 3
d433 12
a444 12
	if ((ahc_inb(ahc, HCNTRL) & POWRDN) == 0) {
		ahc_pause(ahc);
		if ((ahc->features & AHC_ULTRA2) != 0)
			our_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;
		else
			our_id = ahc_inb(ahc, SCSIID) & OID;
		sxfrctl1 = ahc_inb(ahc, SXFRCTL1) & STPWEN;
		scsiseq = ahc_inb(ahc, SCSISEQ);
	} else {
		sxfrctl1 = STPWEN;
		our_id = 7;
		scsiseq = 0;
d446 5
a450 5

	error = ahc_reset(ahc);
	if (error != 0)
		return (ENXIO);

d452 1
d458 7
a464 2
		ahc_outb(ahc, OPTIONMODE,
			 OPTIONMODE_DEFAULTS|AUTOACKEN|BUSFREEREV|EXPPHASEDIS);
d469 1
a469 1
					  |TARGCRCENDEN);
d472 20
a496 11
	
	dscommand0 = ahc_inb(ahc, DSCOMMAND0);
	dscommand0 |= MPARCKEN|CACHETHEN;
	if ((ahc->features & AHC_ULTRA2) != 0) {

		/*
		 * DPARCKEN doesn't work correctly on
		 * some MBs so don't use it.
		 */
		dscommand0 &= ~DPARCKEN;
	}
d499 1
a499 2
	 * Handle chips that must have cache line
	 * streaming (dis/en)abled.
d501 3
a503 2
	if ((ahc->bugs & AHC_CACHETHEN_DIS_BUG) != 0)
		dscommand0 |= CACHETHEN;
d505 3
a507 2
	if ((ahc->bugs & AHC_CACHETHEN_BUG) != 0)
		dscommand0 &= ~CACHETHEN;
d509 7
a515 14
	ahc_outb(ahc, DSCOMMAND0, dscommand0);
	
	ahc->pci_cachesize = ahc_pci_read_config(ahc->dev_softc,
						 CSIZE_LATTIME, 4) & CACHESIZE;
	ahc->pci_cachesize *= 4;

	if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0
	 && ahc->pci_cachesize == 4) {
		u_int csl = ahc_pci_read_config(ahc->dev_softc,
						CSIZE_LATTIME, 4);
		csl &= ~CACHESIZE;
		ahc_pci_write_config(ahc->dev_softc, CSIZE_LATTIME, csl, 4);
		ahc->pci_cachesize = 0;
	}
d517 1
a517 6
	/*
	 * We cannot perform ULTRA speeds without the presense
	 * of the external precision resistor.
	 */
	if ((ahc->features & AHC_ULTRA) != 0) {
		uint32_t devconfig;
d519 2
a520 4
		devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
		if ((devconfig & REXTVALID) == 0)
			ahc->features &= ~AHC_ULTRA;
	}
d522 5
a526 2
	/* See if we have a SEEPROM and perform auto-term */
	check_extport(ahc, &sxfrctl1);
a527 13
	/*
	 * Take the LED out of diagnostic mode
	 */
	sblkctl = ahc_inb(ahc, SBLKCTL);
	ahc_outb(ahc, SBLKCTL, (sblkctl & ~(DIAGLEDEN|DIAGLEDON)));

	if ((ahc->features & AHC_ULTRA2) != 0) {
		ahc_outb(ahc, DFF_THRSH, RD_DFTHRSH_MAX|WR_DFTHRSH_MAX);
	} else {
		ahc_outb(ahc, DSPCISTATUS, DFTHRSH_100);
	}

	if (ahc->flags & AHC_USEDEFAULTS) {
d529 3
a531 3
		 * PCI Adapter default setup
		 * Should only be used if the adapter does not have
		 * a SEEPROM.
d533 2
a534 6
		/* See if someone else set us up already */
		if (scsiseq != 0) {
			printf("%s: Using left over BIOS settings\n",
				ahc_name(ahc));
			ahc->flags &= ~AHC_USEDEFAULTS;
			ahc->flags |= AHC_BIOS_ENABLED;
d536 4
d541 3
a543 2
			 * Assume only one connector and always turn
			 * on termination.
d545 16
a560 2
 			our_id = 0x07;
			sxfrctl1 = STPWEN;
a561 3
		ahc_outb(ahc, SCSICONF, our_id|ENSPCHK|RESET_SCSI);

		ahc->our_id = our_id;
d571 2
d580 5
a584 21
	/* Core initialization */
	error = ahc_init(ahc);
	if (error != 0)
		return (error);

	/* Special func to force negotiation */
	ahc_force_neg(ahc);

	/*
	 * Link this softc in with all other ahc instances.
	 */
	ahc_softc_insert(ahc);

	/*
	 * Allow interrupts now that we are completely setup.
	 */
	error = ahc_pci_map_int(ahc);
	if (error != 0)
		return (error);

	ahc_intr_enable(ahc, TRUE);
d587 1
a587 32
	return (0);
}

int
ahc_pci_map_int(ahc)
	struct ahc_softc *ahc;
{
	const char *intrstr = NULL;
	pci_intr_handle_t ih;
	struct pci_attach_args *pa = ahc->dev_softc;
	
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		return 1;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	
	ahc->platform_data->ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO,
						    ahc_platform_intr, ahc,
						    ahc->sc_dev.dv_xname);
	
	if (ahc->platform_data->ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return 1;
	}
	
	if (intrstr != NULL)
		printf(": %s\n", intrstr);
	return 0;
d595 2
a596 1
ahc_ext_scbram_present(struct ahc_softc *ahc)
a597 1
	u_int chip;
d600 2
a601 5
	uint32_t devconfig;
	
	chip = ahc->chip & AHC_CHIPID_MASK;
	
	devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
d603 1
d608 1
a608 1
	else if (chip >= AHC_AIC7870)
d611 1
a611 1
		ramps = 0;
d622 5
a626 6
ahc_scbram_config(ahc, enable, pcheck, fast, large)
	struct ahc_softc *ahc;
	int enable;
	int pcheck;
	int fast;
	int large;
d629 1
d632 1
d637 2
a638 1
		ahc_outb(ahc, SCBBADDR, ahc_get_pci_function(ahc->dev_softc));
d641 2
a642 1
	devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
a650 4
		if (large)
			dscommand0 &= ~USCBSIZE32;
		else
			dscommand0 |= USCBSIZE32;
a660 4
		if (large)
			devconfig &= ~SCBSIZE32;
		else
			devconfig |= SCBSIZE32;
d667 1
a667 1
	ahc_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig, 4);
d677 1
a677 1
	struct ahc_softc *ahc;
a683 1
	int large;
a684 6
	enable = FALSE;
	pcheck = FALSE;
	fast = FALSE;
	large = FALSE;
	num_scbs = 0;
	
d686 1
a686 1
		goto done;
d691 4
a694 1
	ahc_scbram_config(ahc, /*enable*/TRUE, pcheck, fast, large);
d700 1
a700 10
	enable = TRUE;

	/*
	 * Clear any outstanding parity error
	 * and ensure that parity error reporting
	 * is enabled.
	 */
	ahc_outb(ahc, SEQCTL, 0);
	ahc_outb(ahc, CLRINT, CLRPARERR);
	ahc_outb(ahc, CLRINT, CLRBRKADRINT);
d703 1
a703 1
	ahc_scbram_config(ahc, enable, /*pcheck*/TRUE, fast, large);
d706 2
a707 2
	 || (ahc_inb(ahc, ERROR) & MPARERR) == 0)
		pcheck = TRUE;
d714 1
a714 1
	ahc_scbram_config(ahc, enable, pcheck, /*fast*/TRUE, large);
d717 3
a719 3
	 && ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0
	  || (ahc_inb(ahc, ERROR) & MPARERR) == 0))
		fast = TRUE;
d721 2
a722 28
	/*
	 * See if we can use large SCBs and still maintain
	 * the same overall count of SCBs.
	 */
	if ((ahc->features & AHC_LARGE_SCBS) != 0) {
		ahc_scbram_config(ahc, enable, pcheck, fast, /*large*/TRUE);
		test_num_scbs = ahc_probe_scbs(ahc);
		if (test_num_scbs >= num_scbs) {
			large = TRUE;
			num_scbs = test_num_scbs;
	 		if (num_scbs >= 64) {
				/*
				 * We have enough space to move the
				 * "busy targets table" into SCB space
				 * and make it qualify all the way to the
				 * lun level.
				 */
				ahc->flags |= AHC_SCB_BTT;
			}
		}
	}
done:
	/*
	 * Disable parity error reporting until we
	 * can load instruction ram.
	 */
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS);
	/* Clear any latched parity error */
d726 4
a729 4
		printf("%s: External SRAM, %s access%s, %dbytes/SCB\n",
		       ahc_name(ahc), fast ? "fast" : "slow", 
		       pcheck ? ", parity checking enabled" : "",
		       large ? 64 : 32);
d731 1
a731 1
	ahc_scbram_config(ahc, enable, pcheck, fast, large);
d740 2
a741 2
	struct ahc_softc *ahc;
	u_int *sxfrctl1;
d743 12
a754 11
	struct	seeprom_descriptor sd;
	struct	seeprom_config sc;
	u_int	scsi_conf;
	u_int	adapter_control;
	int	have_seeprom;
	int	have_autoterm;
	
	sd.sd_ahc = ahc;
	sd.sd_control_offset = SEECTL;		
	sd.sd_status_offset = SEECTL;		
	sd.sd_dataout_offset = SEECTL;		
d777 1
a777 1
		if (bootverbose) 
d781 1
a781 1
			u_int start_addr;
d785 21
a805 9
			have_seeprom = read_seeprom(&sd, (uint16_t *)&sc,
						    start_addr, sizeof(sc)/2);

			if (have_seeprom)
				have_seeprom = verify_cksum(&sc);

			if (have_seeprom != 0 || sd.sd_chip == C56_66) {
				if (bootverbose) {
					if (have_seeprom == 0)
d807 5
a811 2
					else
						printf ("done.\n");
d813 3
a816 1
			}
a818 30
		release_seeprom(&sd);
	}

	if (!have_seeprom) {
		/*
		 * Pull scratch ram settings and treat them as
		 * if they are the contents of an seeprom if
		 * the 'ADPT' signature is found in SCB2.
		 * We manually compose the data as 16bit values
		 * to avoid endian issues.
		 */
		ahc_outb(ahc, SCBPTR, 2);
		if (ahc_inb(ahc, SCB_BASE) == 'A'
		 && ahc_inb(ahc, SCB_BASE + 1) == 'D'
		 && ahc_inb(ahc, SCB_BASE + 2) == 'P'
		 && ahc_inb(ahc, SCB_BASE + 3) == 'T') {
			uint16_t *sc_data;
			int	  i;

			sc_data = (uint16_t *)&sc;
			for (i = 0; i < 32; i++) {
				uint16_t val;
				int	 j;

				j = i * 2;
				val = ahc_inb(ahc, SRAM_BASE + j)
				    | ahc_inb(ahc, SRAM_BASE + j + 1) << 8;
			}
			have_seeprom = verify_cksum(&sc);
		}
d832 2
a833 2
		uint16_t discenable;
		uint16_t ultraenb;
d843 1
a843 1
				if ((sc.device_flags[i] & CFSYNCHISULTRA) != 0){
d852 1
a852 1
			uint16_t target_mask;
d864 1
a864 1
			 && (ultraenb & target_mask) != 0) {
d867 1
a867 1
			 	ultraenb &= ~target_mask;
d874 1
a874 1
				else 
a877 5
				/*
				 * The ultra enable bits contain the
				 * high bit of the ultra2 sync rate
				 * field.
				 */
d879 1
a879 2
					 | ((ultraenb & target_mask)
					    ? 0x8 : 0x0);
a898 3
		ahc->flags |=
		    (sc.adapter_control & CFBOOTCHAN) >> CFBOOTCHANSHIFT;

a900 3

		if (sc.bios_control & CFBIOSEN)
			ahc->flags |= AHC_BIOS_ENABLED;
d902 1
a902 1
		 && (ahc->flags & AHC_NEWEEPROM_FMT) == 0) {
a907 14

		if (sc.signature == CFSIGNATURE
		 || sc.signature == CFSIGNATURE2) {
			pcireg_t devconfig;

			/* Honor the STPWLEVEL settings */
			devconfig = ahc_pci_read_config(ahc->dev_softc, 
							DEVCONFIG, 4);
			devconfig &= ~STPWLEVEL;
			if ((sc.bios_control & CFSTPWLEVEL) != 0)
				devconfig |= STPWLEVEL;
			ahc_pci_write_config(ahc->dev_softc,
					     DEVCONFIG, devconfig, 4);
		}
d935 1
a935 1
			have_autoterm = TRUE;
d937 1
a937 1
			have_autoterm = FALSE;
d940 1
a940 2
	if (have_autoterm) {
		acquire_seeprom(ahc, &sd);
d942 2
a943 2
		release_seeprom(&sd);
	}
d947 5
a951 4
configure_termination(struct ahc_softc *ahc,
		      struct seeprom_descriptor *sd,
		      u_int adapter_control,
		      u_int *sxfrctl1)
d953 2
a954 2
	uint8_t brddat;
	
d962 1
a962 1
	
d970 1
a970 1
	 || (ahc->features & AHC_NEW_TERMCTL) != 0) {
a978 1
		int sum;
d986 4
a989 4
					       &enableSEC_high,
					       &enablePRI_low,
					       &enablePRI_high,
					       &eeprom_present);
d993 3
a995 4
					       ahc_name(ahc));
				enableSEC_low = (adapter_control & CFSELOWTERM);
				enableSEC_high =
				    (adapter_control & CFSEHIGHTERM);
d1001 2
a1002 2
				enablePRI_low = (adapter_control & CFSTERM);
				enablePRI_high = (adapter_control & CFWSTERM);
d1022 7
a1028 5
		if (bootverbose
		 && (ahc->features & AHC_ULTRA2) == 0) {
			printf("%s: internal 50 cable %s present",
			       ahc_name(ahc),
			       internal50_present ? "is":"not");
d1030 4
a1033 8
			if ((ahc->features & AHC_WIDE) != 0)
				printf(", internal 68 cable %s present",
				       internal68_present ? "is":"not");
			printf("\n%s: external cable %s present\n",
			       ahc_name(ahc),
			       externalcable_present ? "is":"not");
		}
		if (bootverbose)
d1036 1
d1058 3
a1060 3
		 && (internal50_present != 0)
		 && (internal68_present != 0)
		 && (externalcable_present != 0)) {
d1068 3
a1070 3
		 && ((externalcable_present == 0)
		  || (internal68_present == 0)
		  || (enableSEC_high != 0))) {
d1080 1
a1080 1
							      : "");
d1084 4
a1087 3
		sum = internal50_present + internal68_present
		    + externalcable_present;
		if (sum < 2 || (enableSEC_low != 0)) {
d1100 1
a1100 1
							     : "");
d1124 1
a1124 1
		
d1134 2
a1135 2
				       (ahc->features & AHC_ULTRA2) ? "Primary "
								    : "");
d1138 1
a1138 2
		if ((adapter_control & CFWSTERM) != 0
		 && (ahc->features & AHC_WIDE) != 0) {
d1144 1
a1144 1
				     ? "Secondary " : "");
d1153 1
a1153 2
		if ((ahc->features & AHC_WIDE) != 0)
			write_brdctl(ahc, brddat);
d1161 6
a1166 6
	struct ahc_softc *ahc;
	int *enableSEC_low;
	int *enableSEC_high;
	int *enablePRI_low;
	int *enablePRI_high;
	int *eeprom_present;
d1188 5
a1192 5
	struct ahc_softc *ahc;
	int *internal50_present;
	int *internal68_present;
	int *externalcable_present;
	int *eeprom_present;
d1211 2
a1212 2
	*internal50_present = (brdctl & BRDDAT6) ? 0 : 1;
	*internal68_present = (brdctl & BRDDAT7) ? 0 : 1;
d1226 2
a1227 2
	*externalcable_present = (brdctl & BRDDAT6) ? 0 : 1;
	*eeprom_present = (brdctl & BRDDAT7) ? 1 : 0;
d1233 4
a1236 4
	struct ahc_softc *ahc;
	int *internal50_present;
	int *externalcable_present;
	int *eeprom_present;
d1243 2
a1244 2
	*internal50_present = (brdctl & BRDDAT5) ? 0 : 1;
	*externalcable_present = (brdctl & BRDDAT6) ? 0 : 1;
d1246 1
a1246 1
	*eeprom_present = (ahc_inb(ahc, SPIOCAP) & EEPROM) ? 1 : 0;
d1251 2
a1252 2
	struct   ahc_softc *ahc;
	u_int8_t value;
d1266 1
a1266 1
	ahc_flush_device_writes(ahc);
d1269 1
a1269 1
	ahc_flush_device_writes(ahc);
d1275 1
a1275 1
	ahc_flush_device_writes(ahc);
d1285 1
a1285 1
	struct   ahc_softc *ahc;
d1300 1
a1300 1
	ahc_flush_device_writes(ahc);
d1308 2
a1309 2
	struct ahc_softc *ahc;
	struct seeprom_descriptor *sd;
d1338 1
a1338 1
	struct seeprom_descriptor *sd;
a1350 7
#define PCIDEBUG
#ifdef	PCIDEBUG
#define	PCI_PRINT(Printstuff) printf Printstuff
#else
#define	PCI_PRINT(Printstuff)
#endif

d1353 1
a1353 1
	struct ahc_softc *ahc;
d1356 1
d1360 2
a1361 5
  	PCI_PRINT(("%s: PCI error Interrupt at seqaddr = 0x%x\n",
		   ahc_name(ahc), 
		   ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8)));
 
	status1 = ahc_pci_read_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, 4);
d1364 1
a1364 1
#ifdef AHC_SHOW_PCI_ERRORS
d1366 2
a1367 2
		PCI_PRINT(("%s: Data Parity Error Detected during address "
			   "or write data phase\n", ahc_name(ahc)));
d1371 1
a1371 1
		PCI_PRINT(("%s: Signal System Error Detected\n", ahc_name(ahc)));
d1374 1
a1374 1
		PCI_PRINT(("%s: Received a Master Abort\n", ahc_name(ahc)));
d1377 1
a1377 1
		PCI_PRINT(("%s: Received a Target Abort\n", ahc_name(ahc)));
d1380 1
a1380 1
		PCI_PRINT(("%s: Signaled a Target Abort\n", ahc_name(ahc)));
d1383 2
a1384 2
		PCI_PRINT(("%s: Data Parity Error has been reported via PERR#\n",
			   ahc_name(ahc)));
a1385 3
	
	ahc_pci_write_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, status1, 4);

d1388 5
a1392 2
		       "no status bits set\n", ahc_name(ahc)); 
	} else {
a1394 2
	
	ahc_unpause(ahc);
@


1.28
log
@This should fix AHA-3950BU2.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.27 2002/02/16 04:36:32 smurph Exp $	*/
d115 6
a120 6
static int  ahc_ext_scbram_present __P((struct ahc_softc *ahc));
static void ahc_scbram_config __P((struct ahc_softc *ahc, int enable,
				   int pcheck, int fast, int large));
static void ahc_probe_ext_scbram __P((struct ahc_softc *ahc));
static void check_extport __P((struct ahc_softc *ahc, u_int *sxfrctl1));
static void configure_termination __P((struct ahc_softc *ahc,
d123 2
a124 2
				       u_int *sxfrctl1));
static void ahc_new_term_detect __P((struct ahc_softc *ahc,
d129 2
a130 2
				     int *eeprom_present));
static void aic787X_cable_detect __P((struct ahc_softc *ahc,
d134 2
a135 2
				      int *eeprom_present));
static void aic785X_cable_detect __P((struct ahc_softc *ahc,
d138 11
a148 11
				      int *eeprom_present));
static void write_brdctl __P((struct ahc_softc *ahc, u_int8_t value));
static u_int8_t read_brdctl __P((struct ahc_softc *ahc));

int ahc_do_pci_config __P((struct ahc_softc *ahc));

void load_seeprom __P((struct ahc_softc *ahc));
static int acquire_seeprom __P((struct ahc_softc *ahc,
				struct seeprom_descriptor *sd));
static void release_seeprom __P((struct seeprom_descriptor *sd));
int ahc_probe_scbs __P((struct ahc_softc *ahc));
d152 2
a153 2
int ahc_pci_probe __P((struct device *, void *, void *));
void ahc_pci_attach __P((struct device *, struct device *, void *));
@


1.27
log
@New port of FreeBSD's ahc driver
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.26 2001/09/21 17:55:43 miod Exp $	*/
d224 3
d407 1
a407 2
	/* setup the PCI stuff */
	ahc->dev_softc = pa;
@


1.26
log
@Correct some pryntf() usage: get the correct number of arguments in the
correct order.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.25 2001/08/25 10:13:29 art Exp $	*/
d56 3
a58 2
#include <dev/ic/aic7xxxvar.h>
#include <dev/ic/smc93cx6var.h>
d92 3
d96 14
a109 13
#define		SCBSIZE32	0x00010000UL	/* aic789X only */
#define		MPORTMODE	0x00000400UL	/* aic7870 only */
#define		RAMPSM		0x00000200UL	/* aic7870 only */
#define		VOLSENSE	0x00000100UL
#define		SCBRAMSEL	0x00000080UL
#define		PCI64		0x00000080UL	/* aic7891 & aic7897 only */
#define		MRDCEN		0x00000040UL
#define		EXTSCBTIME	0x00000020UL	/* aic7870 only */
#define		EXTSCBPEN	0x00000010UL	/* aic7870 & aic7890 only */
#define		BERREN		0x00000008UL
#define		DACEN		0x00000004UL
#define		STPWLEVEL	0x00000002UL
#define		DIFACTNEGEN	0x00000001UL	/* aic7870 only */
a114 1
int	    ahc_pci_intr __P((struct ahc_softc *ahc));
d116 2
a117 2
static void ahc_ext_scbram_config __P((struct ahc_softc *ahc, int enable,
													int pcheck, int fast));
d142 2
a158 6
struct ahc_pci_data {
	pci_chipset_tag_t pc;
	pcitag_t tag;
	u_int function;
};

d222 2
a223 18
	bus_space_tag_t  iot;
	bus_space_handle_t ioh;
	pci_intr_handle_t ih;
	pcireg_t	   command;
	const char *intrstr;
	unsigned opri = 0;
	ahc_chip ahc_c = AHC_PCI; /* we are a PCI controller */
	ahc_flag ahc_flags = AHC_FNONE;
	ahc_feature ahc_f = AHC_FENONE;
	int	ioh_valid;

	u_char ultra_enb = 0;
	u_char our_id = 0;
	u_char channel = 'A';
	u_int    sxfrctl1;
	u_int    scsiseq;
	/* So we can access PCI configuration space after init */
	struct ahc_pci_data *pd;
d225 8
a232 1
	ahc->sc_dmat = pa->pa_dmat;
d234 6
a239 3
	command = pci_conf_read(pa->pa_pc, pa->pa_tag,
				PCI_COMMAND_STATUS_REG);

d244 7
a250 17
			{
				pcireg_t devconfig;
				channel = pa->pa_function == 1 ? 'B' : 'A';
				ahc_c |= AHC_AIC7895;
				/* The 'C' revision of the aic7895 
				   has a few additional features */
				if (PCI_REVISION(pa->pa_class) >= 4)
					ahc_f = AHC_AIC7895C_FE;
				else
					ahc_f = AHC_AIC7895_FE;
				ahc_flags |= AHC_NEWEEPROM_FMT;
				devconfig = pci_conf_read(pa->pa_pc, 
							  pa->pa_tag,
							  DEVCONFIG);
				devconfig &= ~SCBSIZE32;
				pci_conf_write(pa->pa_pc, pa->pa_tag,
					       DEVCONFIG, devconfig);
d253 1
a253 1
	   case PCI_PRODUCT_ADP_3940U:
d256 1
a256 2
				ahc_c |= AHC_AIC7880;
				ahc_f = AHC_AIC7880_FE;
d258 1
a258 2
				ahc_c |= AHC_AIC7870;
				ahc_f = AHC_AIC7870_FE;
d263 1
a263 1
				channel = 'B';
d266 4
a269 3
			ahc_c |= AHC_AIC7880;
			ahc_f = AHC_AIC7880_FE;
			ahc_f |= AHC_INT50_SPEEDFLEX;
d272 1
a272 2
			ahc_c |= AHC_AIC7880;
			ahc_f = AHC_AIC7880_FE;
d274 1
d277 1
a277 2
			ahc_c |= AHC_AIC7870;
			ahc_f = AHC_AIC7870_FE;
d279 1
d281 1
a281 15
			ahc_c |= AHC_AIC7860;
			ahc_f = AHC_AIC7860_FE;
			break;
		case PCI_PRODUCT_ADP_398XU:	/* XXX */
		case PCI_PRODUCT_ADP_AIC7880:
			ahc_c |= AHC_AIC7880;
			ahc_f = AHC_AIC7880_FE;
			break;
		case PCI_PRODUCT_ADP_AIC7870:
			ahc_c |= AHC_AIC7870;
			ahc_f = AHC_AIC7870_FE;
			break;
		case PCI_PRODUCT_ADP_AIC7860:
			ahc_c |= AHC_AIC7860;
			ahc_f = AHC_AIC7860_FE;
d285 1
a285 2
			ahc_c |= AHC_AIC7850;
			ahc_f = AHC_AIC7850_FE;
d297 1
a297 3
			ahc_c |= AHC_AIC7890;
			ahc_f = AHC_AIC7890_FE;
			ahc_flags |= AHC_NEWEEPROM_FMT;
d302 1
a302 3
			ahc_c |= AHC_AIC7892;
			ahc_f = AHC_AIC7892_FE;
			ahc_flags |= AHC_NEWEEPROM_FMT;
d307 8
a314 14
			{
				pcireg_t devconfig;
				channel = pa->pa_function == 1 ? 'B' : 'A';
				ahc_c |= AHC_AIC7896;
				ahc_f = AHC_AIC7896_FE;
				ahc_flags |= AHC_NEWEEPROM_FMT;
				devconfig = pci_conf_read(pa->pa_pc, 
							  pa->pa_tag, 
							  DEVCONFIG);
				/* turn off 64 bit for now XXX smurph */
				devconfig &= ~PCI64;
				pci_conf_write(pa->pa_pc, pa->pa_tag, 
					       DEVCONFIG, devconfig);
			}
d318 2
a319 3
			ahc_c |= AHC_AIC7899;
			ahc_f = AHC_AIC7899_FE;
			ahc_flags |= AHC_NEWEEPROM_FMT;
d326 99
d426 2
d447 16
d470 6
d481 1
a481 1
		return;
d483 4
a486 4
	
	/* Ensure busmastering is enabled */
	command |= PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
d488 24
a511 5
	pd = malloc(sizeof (struct ahc_pci_data), M_DEVBUF, M_NOWAIT);
	if (pd == NULL) {
		printf(": error allocating pci data\n");
		return;
	}
d513 8
a520 7
	pd->pc = pa->pa_pc;
	pd->tag = pa->pa_tag;
	pd->function = pa->pa_function;

	/* setup the PCI stuff */
	ahc->pci_data = pd;
	ahc->pci_intr_func = ahc_pci_intr;
d522 11
d534 2
d537 1
a537 1
	ahc_flags |= AHC_PAGESCBS;
d539 3
a541 2
	ahc_construct(ahc, pa->pa_iot, ioh, ahc_c, ahc_flags, ahc_f, channel);
	/* Now we can use the ahc_inb and ahc_outb macros */
a542 3
	/* setup the PCI error interrupt handler */
	ahc->pci_intr_func = &ahc_pci_intr;
	
d544 12
a555 12
	ahc_outb(ahc, HCNTRL, ahc->pause);
	if ((ahc->features & AHC_ULTRA2) != 0)
		our_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;
	else
		our_id = ahc_inb(ahc, SCSIID) & OID;
	sxfrctl1 = ahc_inb(ahc, SXFRCTL1) & STPWEN;
	scsiseq = ahc_inb(ahc, SCSISEQ);
	
	if (ahc_reset(ahc) != 0) {
		/* Failed */
		ahc_free(ahc);
		return;
d557 5
a561 5
	
	if (ahc->features & AHC_ULTRA)
		ultra_enb = bus_space_read_1(pa->pa_iot, ioh, SXFRCTL0) &
						FAST20;
	
a562 1
		u_int optionmode;
d568 2
a569 7
		optionmode = ahc_inb(ahc, OPTIONMODE);
		if (bootverbose)
			printf("%s: OptionMode = %x\n", ahc_name(ahc), optionmode);
		ahc_outb(ahc, OPTIONMODE, OPTIONMODE_DEFAULTS);
		/* Send CRC info in target mode every 4K */
		ahc_outb(ahc, TARGCRCCNT, 0);
		ahc_outb(ahc, TARGCRCCNT + 1, 0x10);
d574 1
a574 1
					|TARGCRCENDEN|TARGCRCCNTEN);
a576 20
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		ahc_free(ahc);
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	ahc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, ahc_intr, ahc,
	    ahc->sc_dev.dv_xname);

	if (ahc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		ahc_free(ahc);
		return;
	}
	if (intrstr != NULL)
		printf(": %s\n", intrstr);

d582 11
d595 2
a596 1
	 * Do aic7880/aic7870/aic7860/aic7850 specific initialization
d598 20
a617 3
	{
		u_int8_t sblkctl;
		u_int dscommand0;
d619 6
a624 3
		dscommand0 = ahc_inb(ahc, DSCOMMAND0);
		dscommand0 |= MPARCKEN;
		if ((ahc->features & AHC_ULTRA2) != 0) {
d626 4
a629 7
			/*
			 * DPARCKEN doesn't work correctly on
			 * some MBs so don't use it.
			 */
			dscommand0 &= ~(USCBSIZE32|DPARCKEN);
			dscommand0 |= CACHETHEN;
		}
d631 2
a632 1
		ahc_outb(ahc, DSCOMMAND0, dscommand0);
d634 5
a638 2
		/* See if we have an SEEPROM and perform auto-term */
		check_extport(ahc, &sxfrctl1);
d640 5
a644 5
		/*
		 * Take the LED out of diagnostic mode
		 */
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, (sblkctl & ~(DIAGLEDEN|DIAGLEDON)));
d646 1
d648 3
a650 3
		 * I don't know where this is set in the SEEPROM or by the
		 * BIOS, so we default to 100% on Ultra or slower controllers
		 * and 75% on ULTRA2 controllers.
d652 6
a657 2
		if ((ahc->features & AHC_ULTRA2) != 0) {
			ahc_outb(ahc, DFF_THRSH, RD_DFTHRSH_75|WR_DFTHRSH_75);
a658 4
			ahc_outb(ahc, DSPCISTATUS, DFTHRSH_100);
		}

		if (ahc->flags & AHC_USEDEFAULTS) {
d660 2
a661 3
			 * PCI Adapter default setup
			 * Should only be used if the adapter does not have
			 * an SEEPROM.
d663 4
a666 14
			/* See if someone else set us up already */
			if (scsiseq != 0) {
				printf("%s: Using left over BIOS settings\n",
						 ahc_name(ahc));
				ahc->flags &= ~AHC_USEDEFAULTS;
			} else {
				/*
				 * Assume only one connector and always turn
				 * on termination.
				 */
				our_id = 0x07;
				sxfrctl1 = STPWEN;
			}
			ahc_outb(ahc, SCSICONF, our_id|ENSPCHK|RESET_SCSI);
d668 1
a668 2
			ahc->our_id = our_id;
		}
a677 2
	printf("%s: ", ahc_name(ahc));

d685 21
a705 5
	if (ahc_init(ahc)) {
		ahc_free(ahc);
		splx(opri);
		return; /* XXX PCI code should take return status */
	}
d708 32
a739 1
	ahc_attach(ahc);
d747 1
a747 2
ahc_ext_scbram_present(ahc)
struct ahc_softc *ahc;
d749 1
d752 5
a756 2
	pcireg_t devconfig;
	struct ahc_pci_data *pd = ahc->pci_data;
a757 1
	devconfig = pci_conf_read(pd->pc, pd->tag, DEVCONFIG);
d762 1
a762 1
	else if ((ahc->chip & AHC_CHIPID_MASK) >= AHC_AIC7870)
d765 1
a765 1
		ramps	= 0;
d776 6
a781 5
ahc_ext_scbram_config(ahc, enable, pcheck, fast)
struct ahc_softc *ahc;
int enable;
int pcheck;
int fast;
a783 1
	struct ahc_pci_data *pd = ahc->pci_data;
a785 1
		u_char channel; 
d790 1
a790 2
		channel = pd->function == 1 ? 1 : 0;
		ahc_outb(ahc, SCBBADDR, channel);
d793 1
a793 2
	devconfig = pci_conf_read(pd->pc, pd->tag, DEVCONFIG);
	
d802 4
d816 4
d826 1
a826 1
	pci_conf_write(pd->pc, pd->tag, DEVCONFIG, devconfig);
d836 1
a836 1
struct ahc_softc *ahc;
d843 1
d845 6
d852 1
a852 1
		return;
d857 1
a857 4
	enable = 0;
	pcheck = 0;
	fast = 0;
	ahc_ext_scbram_config(ahc,	/*enable*/1, pcheck, fast);
d863 10
a872 1
	enable = 1;
d875 1
a875 1
	ahc_ext_scbram_config(ahc, enable, /*pcheck*/1, fast);
d878 2
a879 2
		 || (ahc_inb(ahc, ERROR) & MPARERR) == 0)
		pcheck = 1;
d886 1
a886 1
	ahc_ext_scbram_config(ahc, enable, pcheck, /*fast*/1);
d889 3
a891 3
		 && ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0
			  || (ahc_inb(ahc, ERROR) & MPARERR) == 0))
		fast = 1;
d893 28
a920 2
	done:
	/* Clear any resulting parity error */
d924 4
a927 4
		printf("%s: External SRAM, %dns access%s\n",
				 ahc_name(ahc), fast ? 10 : 20,
				 pcheck ? ", parity checking enabled" : "");

d929 1
a929 1
	ahc_ext_scbram_config(ahc, enable, pcheck, fast);
d938 2
a939 2
struct ahc_softc *ahc;
u_int *sxfrctl1;
d941 11
a951 12
	struct     seeprom_descriptor sd;
	struct     seeprom_config sc;
	u_int   scsi_conf;
	u_int   adapter_control;
	int     have_seeprom;
	int     have_autoterm;

	sd.sd_tag = ahc->sc_iot;
	sd.sd_bsh = ahc->sc_ioh;
	sd.sd_control_offset = SEECTL;      
	sd.sd_status_offset = SEECTL;    
	sd.sd_dataout_offset = SEECTL;      
d974 1
a974 1
		if (bootverbose)
d978 1
a978 1
			bus_size_t start_addr;
d982 9
a990 21
			have_seeprom = read_seeprom(&sd,
						    (u_int16_t *)&sc,
						    start_addr,
						    sizeof(sc)/2);

			if (have_seeprom) {
				/* Check checksum */
				int i;
				int maxaddr;
				u_int32_t checksum;
				u_int16_t *scarray;

				maxaddr = (sizeof(sc)/2) - 1;
				checksum = 0;
				scarray = (u_int16_t *)&sc;

				for (i = 0; i < maxaddr; i++)
					checksum = checksum + scarray[i];
				if (checksum == 0
				    || (checksum & 0xFFFF) != sc.checksum) {
					if (bootverbose && sd.sd_chip == C56_66)
d992 2
a993 5
					have_seeprom = 0;
				} else {
					if (bootverbose)
						printf("done.\n");
					break;
d995 1
d997 4
d1002 26
a1027 3
			if (sd.sd_chip == C56_66)
				break;
			sd.sd_chip = C56_66;
d1042 2
a1043 2
		u_int16_t discenable;
		u_int16_t ultraenb;
d1053 1
a1053 1
				if ((sc.device_flags[i] & CFSYNCHISULTRA) != 0) {
d1062 1
a1062 1
			u_int16_t target_mask;
d1074 1
a1074 1
				 && (ultraenb & target_mask) != 0) {
d1077 1
a1077 1
				ultraenb &= ~target_mask;
d1084 1
a1084 1
				else
d1088 5
d1094 2
a1095 1
				| ((ultraenb & target_mask) ? 0x8 : 0x0);
d1115 3
d1120 3
d1124 1
a1124 1
			 && (ahc->flags & AHC_NEWEEPROM_FMT) == 0) {
d1130 14
d1171 1
a1171 1
			have_autoterm = 1;
d1173 1
a1173 1
			have_autoterm = 0;
d1176 2
a1177 1
	if (have_autoterm)
d1179 2
a1180 2

	release_seeprom(&sd);
d1184 4
a1187 5
configure_termination(ahc, sd, adapter_control, sxfrctl1)
struct ahc_softc *ahc;
struct seeprom_descriptor *sd;
u_int adapter_control;
u_int *sxfrctl1;
d1189 2
a1190 2
	u_int8_t brddat;

d1198 1
a1198 1

d1206 1
a1206 1
		 || (ahc->features & AHC_NEW_TERMCTL) != 0) {
d1215 1
d1223 4
a1226 4
					    &enableSEC_high,
					    &enablePRI_low,
					    &enablePRI_high,
					    &eeprom_present);
d1230 4
a1233 3
							 ahc_name(ahc));
				enableSEC_low = (adapter_control & CFSTERM);
				enableSEC_high = (adapter_control & CFWSTERM);
d1239 2
a1240 2
				enablePRI_low = enablePRI_high =
					(adapter_control & CFLVDSTERM);
d1260 8
a1267 6
		if (bootverbose) {
			if ((ahc->features & AHC_ULTRA2) == 0) {
				printf("%s: internal 50 cable %s present, "
				       "internal 68 cable %s present\n",
				       ahc_name(ahc),
				       internal50_present ? "is":"not",
d1269 5
a1273 5

				printf("%s: external cable %s present\n",
				       ahc_name(ahc),
				       externalcable_present ? "is":"not");
			}
a1275 1
		}
d1297 3
a1299 3
		    && (internal50_present != 0)
		    && (internal68_present != 0)
		    && (externalcable_present != 0)) {
d1307 3
a1309 3
			 && ((externalcable_present == 0)
				  || (internal68_present == 0)
				  || (enableSEC_high != 0))) {
d1319 1
a1319 1
					       : "");
d1323 3
a1325 4
		if (((internal50_present ? 1 : 0)
			  + (internal68_present ? 1 : 0)
			  + (externalcable_present ? 1 : 0)) <= 1
			 || (enableSEC_low != 0)) {
d1338 1
a1338 1
					       : "");
d1362 1
a1362 1

d1372 2
a1373 2
				       (ahc->features & AHC_ULTRA2)
				       ? "Primary " : "");
d1376 2
a1377 1
		if ((adapter_control & CFWSTERM) != 0) {
d1383 1
a1383 1
				       ? "Secondary " : "");
d1392 2
a1393 1
		write_brdctl(ahc, brddat);
d1401 6
a1406 6
struct ahc_softc *ahc;
int *enableSEC_low;
int *enableSEC_high;
int *enablePRI_low;
int *enablePRI_high;
int *eeprom_present;
d1428 5
a1432 5
struct ahc_softc *ahc;
int *internal50_present;
int *internal68_present;
int *externalcable_present;
int *eeprom_present;
d1451 2
a1452 2
	*internal50_present = !(brdctl & BRDDAT6);
	*internal68_present = !(brdctl & BRDDAT7);
d1466 2
a1467 2
	*externalcable_present = !(brdctl & BRDDAT6);
	*eeprom_present = brdctl & BRDDAT7;
d1473 4
a1476 4
struct ahc_softc *ahc;
int *internal50_present;
int *externalcable_present;
int *eeprom_present;
d1483 2
a1484 2
	*internal50_present = !(brdctl & BRDDAT5);
	*externalcable_present = !(brdctl & BRDDAT6);
d1486 1
a1486 1
	*eeprom_present = (ahc_inb(ahc, SPIOCAP) & EEPROM) != 0;
d1491 2
a1492 2
struct   ahc_softc *ahc;
u_int8_t value;
d1506 1
a1506 1
	DELAY(20);
d1509 1
a1509 1
	DELAY(20);
d1515 1
a1515 1
	DELAY(20);
d1525 1
a1525 1
struct   ahc_softc *ahc;
d1540 1
a1540 1
	DELAY(20);
d1548 2
a1549 2
struct ahc_softc *ahc;
struct seeprom_descriptor *sd;
d1578 1
a1578 1
struct seeprom_descriptor *sd;
d1591 7
d1600 1
a1600 1
struct ahc_softc *ahc;
a1602 1
	struct ahc_pci_data *pd = ahc->pci_data;
d1606 5
a1610 2

	status1 = pci_conf_read(pd->pc, pd->tag, PCI_COMMAND_STATUS_REG);
d1613 1
a1613 1
#ifdef AHC_SHOW_PCI_ERRORS	
d1615 2
a1616 2
		printf("%s: Data Parity Error Detected during address "
				 "or write data phase\n", ahc_name(ahc));
d1620 1
a1620 1
		printf("%s: Signal System Error Detected\n", ahc_name(ahc));
d1623 1
a1623 1
		printf("%s: Received a Master Abort\n", ahc_name(ahc));
d1626 1
a1626 1
		printf("%s: Received a Target Abort\n", ahc_name(ahc));
d1629 1
a1629 1
		printf("%s: Signaled a Target Abort\n", ahc_name(ahc));
d1632 2
a1633 2
		printf("%s: Data Parity Error has been reported via PERR#\n",
				 ahc_name(ahc));
d1635 3
d1640 2
a1641 5
				 "no status bits set\n", ahc_name(ahc)); 
	}
	pci_conf_write(pd->pc, pd->tag, PCI_COMMAND_STATUS_REG, status1);

	if (status1 & (DPR|RMA|RTA)) {
d1644 2
@


1.26.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.26 2001/09/21 17:55:43 miod Exp $	*/
d110 33
a142 33
int	    ahc_pci_intr(struct ahc_softc *ahc);
static int  ahc_ext_scbram_present(struct ahc_softc *ahc);
static void ahc_ext_scbram_config(struct ahc_softc *ahc, int enable,
				  int pcheck, int fast);
static void ahc_probe_ext_scbram(struct ahc_softc *ahc);
static void check_extport(struct ahc_softc *ahc, u_int *sxfrctl1);
static void configure_termination(struct ahc_softc *ahc,
				  struct seeprom_descriptor *sd,
				  u_int adapter_control,
				  u_int *sxfrctl1);
static void ahc_new_term_detect(struct ahc_softc *ahc,
				int *enableSEC_low,
				int *enableSEC_high,
				int *enablePRI_low,
				int *enablePRI_high,
				int *eeprom_present);
static void aic787X_cable_detect(struct ahc_softc *ahc,
				 int *internal50_present,
				 int *internal68_present,
				 int *externalcable_present,
				 int *eeprom_present);
static void aic785X_cable_detect(struct ahc_softc *ahc,
				 int *internal50_present,
				 int *externalcable_present,
				 int *eeprom_present);
static void write_brdctl(struct ahc_softc *ahc, u_int8_t value);
static u_int8_t read_brdctl(struct ahc_softc *ahc);

void load_seeprom(struct ahc_softc *ahc);
static int acquire_seeprom(struct ahc_softc *ahc,
			   struct seeprom_descriptor *sd);
static void release_seeprom(struct seeprom_descriptor *sd);
int ahc_probe_scbs(struct ahc_softc *ahc);
d146 2
a147 2
int ahc_pci_probe(struct device *, void *, void *);
void ahc_pci_attach(struct device *, struct device *, void *);
@


1.26.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.26.4.1 2002/06/11 03:42:24 art Exp $	*/
d56 1
a56 2
#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>
a90 3
#define	EXROMBADR		0x30
#define 	EXROMEN		0x00000001UL	/* External Rom Enable */

d93 2
a94 3
#define		REXTVALID	0x00001000UL	/* ultra cards only */
#define		MPORTMODE	0x00000400UL	/* aic7870+ only */
#define		RAMPSM		0x00000200UL	/* aic7870+ only */
a95 1
#define		PCI64BIT	0x00000080UL	/* 64Bit PCI bus (Ultra2 Only)*/
d97 1
d100 1
a100 1
#define		EXTSCBPEN	0x00000010UL	/* aic7870 only */
d107 2
a108 2
#define		CACHESIZE	0x0000003fUL	/* only 5 bits */
#define		LATTIME		0x0000ff00UL
d110 1
d112 2
a113 2
static void ahc_scbram_config(struct ahc_softc *ahc, int enable,
				  int pcheck, int fast, int large);
a137 2
int ahc_do_pci_config(struct ahc_softc *ahc);

d153 6
d222 18
a239 2
	pcireg_t devconfig;
	pcireg_t command;
d241 4
a244 2
	/* setup the PCI stuff */
	ahc->dev_softc = pa;
a245 15
	/* 
	 * We really don't allocate our softc, but 
	 * we need to do the initialization. And this 
	 * also allocates the platform_data structure.
	 */
	ahc_alloc(ahc, NULL);
	ahc_set_name(ahc, ahc->sc_dev.dv_xname);
	ahc_set_unit(ahc, ahc->sc_dev.dv_unit);
	
	/* set dma tags */
	ahc->parent_dmat = pa->pa_dmat;
	ahc->buffer_dmat = pa->pa_dmat;
        ahc->shared_data_dmat = pa->pa_dmat;
	
	/* card specific setup */
d250 17
a266 7
			ahc->channel = pa->pa_function == 1 ? 'B' : 'A';
			/* The 'C' revision of the aic7895 
			   has a few additional features */
			if (PCI_REVISION(pa->pa_class) >= 4){
				ahc->chip |= AHC_AIC7895C;
			} else {
				ahc->chip |= AHC_AIC7895;
d269 1
a269 1
		case PCI_PRODUCT_ADP_3940U:
d272 2
a273 1
				ahc->chip |= AHC_AIC7880;
d275 2
a276 1
				ahc->chip |= AHC_AIC7870;
d281 1
a281 1
				ahc->channel = 'B';
d284 3
a286 4
			ahc->flags |= AHC_INT50_SPEEDFLEX;
			/* fall through */
		case PCI_PRODUCT_ADP_AIC7880:
		case PCI_PRODUCT_ADP_398XU:	/* XXX */
d289 2
a290 1
			ahc->chip |= AHC_AIC7880;
a291 1
		case PCI_PRODUCT_ADP_AIC7870:
d294 15
a308 1
			ahc->chip |= AHC_AIC7870;
d311 2
a312 2
		case PCI_PRODUCT_ADP_2940AU:
			ahc->chip |= AHC_AIC7860;
d316 2
a317 1
			ahc->chip |= AHC_AIC7850;
d329 3
a331 1
			ahc->chip |= AHC_AIC7890;
d336 3
a338 1
			ahc->chip |= AHC_AIC7892;
d343 14
a356 8
			ahc->chip |= AHC_AIC7896;
			ahc->channel = pa->pa_function == 1 ? 'B' : 'A';
			devconfig = ahc_pci_read_config(ahc->dev_softc, 
						  DEVCONFIG, 4);
			/* turn off 64 bit for now XXX smurph */
			devconfig &= ~PCI64BIT;
			ahc_pci_write_config(ahc->dev_softc, 
				       DEVCONFIG, devconfig, 4);
d360 3
a362 2
			ahc->chip |= AHC_AIC7899;
			ahc->channel = pa->pa_function == 1 ? 'B' : 'A';
a368 89
	
	/* chip specific setup */
	switch(ahc->chip){
	case AHC_AIC7850:
	case AHC_AIC7855:
	case AHC_AIC7859:
		ahc->features = AHC_AIC7850_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		if (PCI_REVISION(pa->pa_class) >= 1)
			ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
		break;
	case AHC_AIC7860:
		ahc->features = AHC_AIC7860_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		if (PCI_REVISION(pa->pa_class) >= 1)
			ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
		break;
	case AHC_AIC7870:
		ahc->features = AHC_AIC7870_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		break;
	case AHC_AIC7880:
		ahc->features = AHC_AIC7880_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
		if (PCI_REVISION(pa->pa_class) >= 1) {
			ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
		} else {
			ahc->bugs |= AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		}
		break;
	case AHC_AIC7895:
		ahc->features = AHC_AIC7895_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		/*
		 * The BIOS disables the use of MWI transactions
		 * since it does not have the MWI bug work around
		 * we have.  Disabling MWI reduces performance, so
		 * turn it on again.
		 */
		command = pci_conf_read(pa->pa_pc, pa->pa_tag,
					PCI_COMMAND_STATUS_REG);
		command |= PCI_COMMAND_INVALIDATE_ENABLE;
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
			       command);
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_PCI_2_1_RETRY_BUG
			  |  AHC_CACHETHEN_BUG | AHC_PCI_MWI_BUG;
		break;		
	case AHC_AIC7895C:
		ahc->features = AHC_AIC7895C_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_PCI_2_1_RETRY_BUG
			  |  AHC_CACHETHEN_BUG;
		break;
	case AHC_AIC7890:
		ahc->features = AHC_AIC7890_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		if (PCI_REVISION(pa->pa_class) == 0)
			ahc->bugs |= AHC_AUTOFLUSH_BUG|AHC_CACHETHEN_BUG;
		break;
	case AHC_AIC7892:
		ahc->features = AHC_AIC7892_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;
		break;
	case AHC_AIC7896:
		ahc->features = AHC_AIC7896_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_CACHETHEN_DIS_BUG;
		break;
	case AHC_AIC7899:
		ahc->features = AHC_AIC7899_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;
		break;
	default:
		break;
	}

	/* setup the PCI interrupt */
	ahc->bus_intr = ahc_pci_intr;
	ahc->unsolicited_ints = 0; 

	if(ahc_do_pci_config(ahc)){
		ahc_free(ahc);
		return;
	}
	
	ahc_attach(ahc);
}
a369 12
int
ahc_pci_map_registers(ahc)
	struct ahc_softc *ahc;
{
	pcireg_t	command;
	int		ioh_valid;
	bus_space_tag_t  iot;
	bus_space_handle_t ioh;
	struct pci_attach_args *pa = ahc->dev_softc;

	command = ahc_pci_read_config(ahc->dev_softc,
				      PCI_COMMAND_STATUS_REG, 4);
a388 18
		if (ioh_valid) {
			/*
			 * Do a quick test to see if memory mapped
			 * I/O is functioning correctly.
			 */
			ahc->tag = iot;
			ahc->bsh = ioh;
			if (ahc_inb(ahc, HCNTRL) == 0xFF) {
				/* nope, use I/O mapping */
                                ioh_valid = 0;
			} else {
				/* Using memory mapping, disable I/O mapping */
                                command &= ~PCI_COMMAND_IO_ENABLE;
				ahc_pci_write_config(ahc->dev_softc,
						     PCI_COMMAND_STATUS_REG,
						     command, 4);
			}
		}
a395 6
		
		/* Using I/O mapping, disable memory mapping */
		command &= ~PCI_COMMAND_MEM_ENABLE;
		ahc_pci_write_config(ahc->dev_softc,
				     PCI_COMMAND_STATUS_REG,
				     command, 4);
d401 11
a411 1
		return (1);
a412 4
	ahc->tag = iot;
	ahc->bsh = ioh;
	return (0);
}
d414 3
a416 33
int
ahc_do_pci_config(ahc)
	struct ahc_softc *ahc;
{
	pcireg_t	 command;
	u_int		 our_id = 0;
	u_int		 sxfrctl1;
	u_int		 scsiseq;
	u_int		 dscommand0;
	int		 error;
	int		 opri;
	uint8_t		 sblkctl;


	ahc->chip |= AHC_PCI;
#if 0
	ahc_power_state_change(ahc, AHC_POWER_STATE_D0);
#endif 
	error = ahc_pci_map_registers(ahc);
	if (error != 0)
		return (error);
	/* 
	 * Registers are mapped. Now it is safe to use 
	 * the ahc_inb and ahc_outb macros. 
	 */
	
	/* 
	 * Before we continue probing the card, ensure that
	 * its interrupts are *disabled*.  We don't want
	 * a misstep to hang the machine in an interrupt
	 * storm.
	 */
	ahc_intr_enable(ahc, FALSE);
d418 3
a420 8
	/*
	 * If we need to support high memory, enable dual
	 * address cycles.  This bit must be set to enable
	 * high address bit generation even if we are on a
	 * 64bit bus (PCI64BIT set in devconfig).
	 */
	if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
		pcireg_t devconfig;
a421 11
		if (bootverbose)
			printf("%s: Enabling 39Bit Addressing\n",
			       ahc_name(ahc));
		devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
		devconfig |= DACEN;
		ahc_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig, 4);
	}
	
	/* Ensure busmastering is enabled */
        command = ahc_pci_read_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, 4);
	command |= PCI_COMMAND_MASTER_ENABLE; 
a422 2
	ahc_pci_write_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, command, 4);
	
d424 1
a424 1
	ahc->flags |= AHC_PAGESCBS;
d426 19
a444 17
	error = ahc_softc_init(ahc);
	if (error != 0)
		return (error);

	/* Remember how the card was setup in case there is no SEEPROM */
	if ((ahc_inb(ahc, HCNTRL) & POWRDN) == 0) {
		ahc_pause(ahc);
		if ((ahc->features & AHC_ULTRA2) != 0)
			our_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;
		else
			our_id = ahc_inb(ahc, SCSIID) & OID;
		sxfrctl1 = ahc_inb(ahc, SXFRCTL1) & STPWEN;
		scsiseq = ahc_inb(ahc, SCSISEQ);
	} else {
		sxfrctl1 = STPWEN;
		our_id = 7;
		scsiseq = 0;
d446 5
a450 5

	error = ahc_reset(ahc);
	if (error != 0)
		return (ENXIO);

d452 1
d458 7
a464 2
		ahc_outb(ahc, OPTIONMODE,
			 OPTIONMODE_DEFAULTS|AUTOACKEN|BUSFREEREV|EXPPHASEDIS);
d469 7
a475 1
					  |TARGCRCENDEN);
d477 14
a496 11
	
	dscommand0 = ahc_inb(ahc, DSCOMMAND0);
	dscommand0 |= MPARCKEN|CACHETHEN;
	if ((ahc->features & AHC_ULTRA2) != 0) {

		/*
		 * DPARCKEN doesn't work correctly on
		 * some MBs so don't use it.
		 */
		dscommand0 &= ~DPARCKEN;
	}
d499 1
a499 2
	 * Handle chips that must have cache line
	 * streaming (dis/en)abled.
d501 3
a503 2
	if ((ahc->bugs & AHC_CACHETHEN_DIS_BUG) != 0)
		dscommand0 |= CACHETHEN;
d505 3
a507 2
	if ((ahc->bugs & AHC_CACHETHEN_BUG) != 0)
		dscommand0 &= ~CACHETHEN;
d509 7
a515 14
	ahc_outb(ahc, DSCOMMAND0, dscommand0);
	
	ahc->pci_cachesize = ahc_pci_read_config(ahc->dev_softc,
						 CSIZE_LATTIME, 4) & CACHESIZE;
	ahc->pci_cachesize *= 4;

	if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0
	 && ahc->pci_cachesize == 4) {
		u_int csl = ahc_pci_read_config(ahc->dev_softc,
						CSIZE_LATTIME, 4);
		csl &= ~CACHESIZE;
		ahc_pci_write_config(ahc->dev_softc, CSIZE_LATTIME, csl, 4);
		ahc->pci_cachesize = 0;
	}
d517 1
a517 6
	/*
	 * We cannot perform ULTRA speeds without the presense
	 * of the external precision resistor.
	 */
	if ((ahc->features & AHC_ULTRA) != 0) {
		uint32_t devconfig;
d519 2
a520 4
		devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
		if ((devconfig & REXTVALID) == 0)
			ahc->features &= ~AHC_ULTRA;
	}
d522 5
a526 2
	/* See if we have a SEEPROM and perform auto-term */
	check_extport(ahc, &sxfrctl1);
a527 13
	/*
	 * Take the LED out of diagnostic mode
	 */
	sblkctl = ahc_inb(ahc, SBLKCTL);
	ahc_outb(ahc, SBLKCTL, (sblkctl & ~(DIAGLEDEN|DIAGLEDON)));

	if ((ahc->features & AHC_ULTRA2) != 0) {
		ahc_outb(ahc, DFF_THRSH, RD_DFTHRSH_MAX|WR_DFTHRSH_MAX);
	} else {
		ahc_outb(ahc, DSPCISTATUS, DFTHRSH_100);
	}

	if (ahc->flags & AHC_USEDEFAULTS) {
d529 3
a531 3
		 * PCI Adapter default setup
		 * Should only be used if the adapter does not have
		 * a SEEPROM.
d533 2
a534 6
		/* See if someone else set us up already */
		if (scsiseq != 0) {
			printf("%s: Using left over BIOS settings\n",
				ahc_name(ahc));
			ahc->flags &= ~AHC_USEDEFAULTS;
			ahc->flags |= AHC_BIOS_ENABLED;
d536 4
d541 3
a543 2
			 * Assume only one connector and always turn
			 * on termination.
d545 16
a560 2
 			our_id = 0x07;
			sxfrctl1 = STPWEN;
a561 3
		ahc_outb(ahc, SCSICONF, our_id|ENSPCHK|RESET_SCSI);

		ahc->our_id = our_id;
d571 2
d580 5
a584 21
	/* Core initialization */
	error = ahc_init(ahc);
	if (error != 0)
		return (error);

	/* Special func to force negotiation */
	ahc_force_neg(ahc);

	/*
	 * Link this softc in with all other ahc instances.
	 */
	ahc_softc_insert(ahc);

	/*
	 * Allow interrupts now that we are completely setup.
	 */
	error = ahc_pci_map_int(ahc);
	if (error != 0)
		return (error);

	ahc_intr_enable(ahc, TRUE);
d587 1
a587 32
	return (0);
}

int
ahc_pci_map_int(ahc)
	struct ahc_softc *ahc;
{
	const char *intrstr = NULL;
	pci_intr_handle_t ih;
	struct pci_attach_args *pa = ahc->dev_softc;
	
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		return 1;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	
	ahc->platform_data->ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO,
						    ahc_platform_intr, ahc,
						    ahc->sc_dev.dv_xname);
	
	if (ahc->platform_data->ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return 1;
	}
	
	if (intrstr != NULL)
		printf(": %s\n", intrstr);
	return 0;
d595 2
a596 1
ahc_ext_scbram_present(struct ahc_softc *ahc)
a597 1
	u_int chip;
d600 2
a601 5
	uint32_t devconfig;
	
	chip = ahc->chip & AHC_CHIPID_MASK;
	
	devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
d603 1
d608 1
a608 1
	else if (chip >= AHC_AIC7870)
d611 1
a611 1
		ramps = 0;
d622 5
a626 6
ahc_scbram_config(ahc, enable, pcheck, fast, large)
	struct ahc_softc *ahc;
	int enable;
	int pcheck;
	int fast;
	int large;
d629 1
d632 1
d637 2
a638 1
		ahc_outb(ahc, SCBBADDR, ahc_get_pci_function(ahc->dev_softc));
d641 2
a642 1
	devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
a650 4
		if (large)
			dscommand0 &= ~USCBSIZE32;
		else
			dscommand0 |= USCBSIZE32;
a660 4
		if (large)
			devconfig &= ~SCBSIZE32;
		else
			devconfig |= SCBSIZE32;
d667 1
a667 1
	ahc_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig, 4);
d677 1
a677 1
	struct ahc_softc *ahc;
a683 1
	int large;
a684 6
	enable = FALSE;
	pcheck = FALSE;
	fast = FALSE;
	large = FALSE;
	num_scbs = 0;
	
d686 1
a686 1
		goto done;
d691 4
a694 1
	ahc_scbram_config(ahc, /*enable*/TRUE, pcheck, fast, large);
d700 1
a700 10
	enable = TRUE;

	/*
	 * Clear any outstanding parity error
	 * and ensure that parity error reporting
	 * is enabled.
	 */
	ahc_outb(ahc, SEQCTL, 0);
	ahc_outb(ahc, CLRINT, CLRPARERR);
	ahc_outb(ahc, CLRINT, CLRBRKADRINT);
d703 1
a703 1
	ahc_scbram_config(ahc, enable, /*pcheck*/TRUE, fast, large);
d706 2
a707 2
	 || (ahc_inb(ahc, ERROR) & MPARERR) == 0)
		pcheck = TRUE;
d714 1
a714 1
	ahc_scbram_config(ahc, enable, pcheck, /*fast*/TRUE, large);
d717 3
a719 3
	 && ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0
	  || (ahc_inb(ahc, ERROR) & MPARERR) == 0))
		fast = TRUE;
d721 2
a722 28
	/*
	 * See if we can use large SCBs and still maintain
	 * the same overall count of SCBs.
	 */
	if ((ahc->features & AHC_LARGE_SCBS) != 0) {
		ahc_scbram_config(ahc, enable, pcheck, fast, /*large*/TRUE);
		test_num_scbs = ahc_probe_scbs(ahc);
		if (test_num_scbs >= num_scbs) {
			large = TRUE;
			num_scbs = test_num_scbs;
	 		if (num_scbs >= 64) {
				/*
				 * We have enough space to move the
				 * "busy targets table" into SCB space
				 * and make it qualify all the way to the
				 * lun level.
				 */
				ahc->flags |= AHC_SCB_BTT;
			}
		}
	}
done:
	/*
	 * Disable parity error reporting until we
	 * can load instruction ram.
	 */
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS);
	/* Clear any latched parity error */
d726 4
a729 4
		printf("%s: External SRAM, %s access%s, %dbytes/SCB\n",
		       ahc_name(ahc), fast ? "fast" : "slow", 
		       pcheck ? ", parity checking enabled" : "",
		       large ? 64 : 32);
d731 1
a731 1
	ahc_scbram_config(ahc, enable, pcheck, fast, large);
d740 2
a741 2
	struct ahc_softc *ahc;
	u_int *sxfrctl1;
d743 12
a754 11
	struct	seeprom_descriptor sd;
	struct	seeprom_config sc;
	u_int	scsi_conf;
	u_int	adapter_control;
	int	have_seeprom;
	int	have_autoterm;
	
	sd.sd_ahc = ahc;
	sd.sd_control_offset = SEECTL;		
	sd.sd_status_offset = SEECTL;		
	sd.sd_dataout_offset = SEECTL;		
d777 1
a777 1
		if (bootverbose) 
d781 1
a781 1
			u_int start_addr;
d785 21
a805 9
			have_seeprom = read_seeprom(&sd, (uint16_t *)&sc,
						    start_addr, sizeof(sc)/2);

			if (have_seeprom)
				have_seeprom = verify_cksum(&sc);

			if (have_seeprom != 0 || sd.sd_chip == C56_66) {
				if (bootverbose) {
					if (have_seeprom == 0)
d807 5
a811 2
					else
						printf ("done.\n");
d813 3
a816 1
			}
a818 36
		release_seeprom(&sd);
	}

	if (!have_seeprom) {
		/*
		 * Pull scratch ram settings and treat them as
		 * if they are the contents of an seeprom if
		 * the 'ADPT' signature is found in SCB2.
		 * We manually compose the data as 16bit values
		 * to avoid endian issues.
		 */
		ahc_outb(ahc, SCBPTR, 2);
		if (ahc_inb(ahc, SCB_BASE) == 'A'
		 && ahc_inb(ahc, SCB_BASE + 1) == 'D'
		 && ahc_inb(ahc, SCB_BASE + 2) == 'P'
		 && ahc_inb(ahc, SCB_BASE + 3) == 'T') {
			uint16_t *sc_data;
			int	  i;

			sc_data = (uint16_t *)&sc;
			for (i = 0; i < 32; i++) {
				uint16_t val;
				int	 j;

				j = i * 2;
				val = ahc_inb(ahc, SRAM_BASE + j)
				    | ahc_inb(ahc, SRAM_BASE + j + 1) << 8;
			}
			have_seeprom = verify_cksum(&sc);
		}
		/*
		 * Clear any SCB parity errors in case this data and
		 * its associated parity was not initialized by the BIOS
		 */
		ahc_outb(ahc, CLRINT, CLRPARERR);
		ahc_outb(ahc, CLRINT, CLRBRKADRINT);
d832 2
a833 2
		uint16_t discenable;
		uint16_t ultraenb;
d843 1
a843 1
				if ((sc.device_flags[i] & CFSYNCHISULTRA) != 0){
d852 1
a852 1
			uint16_t target_mask;
d864 1
a864 1
			 && (ultraenb & target_mask) != 0) {
d867 1
a867 1
			 	ultraenb &= ~target_mask;
d874 1
a874 1
				else 
a877 5
				/*
				 * The ultra enable bits contain the
				 * high bit of the ultra2 sync rate
				 * field.
				 */
d879 1
a879 2
					 | ((ultraenb & target_mask)
					    ? 0x8 : 0x0);
a898 3
		ahc->flags |=
		    (sc.adapter_control & CFBOOTCHAN) >> CFBOOTCHANSHIFT;

a900 3

		if (sc.bios_control & CFBIOSEN)
			ahc->flags |= AHC_BIOS_ENABLED;
d902 1
a902 1
		 && (ahc->flags & AHC_NEWEEPROM_FMT) == 0) {
a907 14

		if (sc.signature == CFSIGNATURE
		 || sc.signature == CFSIGNATURE2) {
			pcireg_t devconfig;

			/* Honor the STPWLEVEL settings */
			devconfig = ahc_pci_read_config(ahc->dev_softc, 
							DEVCONFIG, 4);
			devconfig &= ~STPWLEVEL;
			if ((sc.bios_control & CFSTPWLEVEL) != 0)
				devconfig |= STPWLEVEL;
			ahc_pci_write_config(ahc->dev_softc,
					     DEVCONFIG, devconfig, 4);
		}
d935 1
a935 1
			have_autoterm = TRUE;
d937 1
a937 1
			have_autoterm = FALSE;
d940 1
a940 2
	if (have_autoterm) {
		acquire_seeprom(ahc, &sd);
d942 2
a943 2
		release_seeprom(&sd);
	}
d947 5
a951 4
configure_termination(struct ahc_softc *ahc,
		      struct seeprom_descriptor *sd,
		      u_int adapter_control,
		      u_int *sxfrctl1)
d953 2
a954 2
	uint8_t brddat;
	
d962 1
a962 1
	
d970 1
a970 1
	 || (ahc->features & AHC_NEW_TERMCTL) != 0) {
a978 1
		int sum;
d986 4
a989 4
					       &enableSEC_high,
					       &enablePRI_low,
					       &enablePRI_high,
					       &eeprom_present);
d993 3
a995 4
					       ahc_name(ahc));
				enableSEC_low = (adapter_control & CFSELOWTERM);
				enableSEC_high =
				    (adapter_control & CFSEHIGHTERM);
d1001 2
a1002 2
				enablePRI_low = (adapter_control & CFSTERM);
				enablePRI_high = (adapter_control & CFWSTERM);
d1022 7
a1028 5
		if (bootverbose
		 && (ahc->features & AHC_ULTRA2) == 0) {
			printf("%s: internal 50 cable %s present",
			       ahc_name(ahc),
			       internal50_present ? "is":"not");
d1030 4
a1033 8
			if ((ahc->features & AHC_WIDE) != 0)
				printf(", internal 68 cable %s present",
				       internal68_present ? "is":"not");
			printf("\n%s: external cable %s present\n",
			       ahc_name(ahc),
			       externalcable_present ? "is":"not");
		}
		if (bootverbose)
d1036 1
d1058 3
a1060 3
		 && (internal50_present != 0)
		 && (internal68_present != 0)
		 && (externalcable_present != 0)) {
a1064 9

			/*
			 * Pretend there are no cables in the hope
			 * that having all of the termination on
			 * gives us a more stable bus.
			 */
		 	internal50_present = 0;
			internal68_present = 0;
			externalcable_present = 0;
d1068 3
a1070 3
		 && ((externalcable_present == 0)
		  || (internal68_present == 0)
		  || (enableSEC_high != 0))) {
d1080 1
a1080 1
							      : "");
d1084 4
a1087 3
		sum = internal50_present + internal68_present
		    + externalcable_present;
		if (sum < 2 || (enableSEC_low != 0)) {
d1100 1
a1100 1
							     : "");
d1124 1
a1124 1
		
d1134 2
a1135 2
				       (ahc->features & AHC_ULTRA2) ? "Primary "
								    : "");
d1138 1
a1138 2
		if ((adapter_control & CFWSTERM) != 0
		 && (ahc->features & AHC_WIDE) != 0) {
d1144 1
a1144 1
				     ? "Secondary " : "");
d1153 1
a1153 2
		if ((ahc->features & AHC_WIDE) != 0)
			write_brdctl(ahc, brddat);
d1161 6
a1166 6
	struct ahc_softc *ahc;
	int *enableSEC_low;
	int *enableSEC_high;
	int *enablePRI_low;
	int *enablePRI_high;
	int *eeprom_present;
d1188 5
a1192 5
	struct ahc_softc *ahc;
	int *internal50_present;
	int *internal68_present;
	int *externalcable_present;
	int *eeprom_present;
d1211 2
a1212 2
	*internal50_present = (brdctl & BRDDAT6) ? 0 : 1;
	*internal68_present = (brdctl & BRDDAT7) ? 0 : 1;
d1226 2
a1227 2
	*externalcable_present = (brdctl & BRDDAT6) ? 0 : 1;
	*eeprom_present = (brdctl & BRDDAT7) ? 1 : 0;
d1233 4
a1236 4
	struct ahc_softc *ahc;
	int *internal50_present;
	int *externalcable_present;
	int *eeprom_present;
d1243 2
a1244 2
	*internal50_present = (brdctl & BRDDAT5) ? 0 : 1;
	*externalcable_present = (brdctl & BRDDAT6) ? 0 : 1;
d1246 1
a1246 1
	*eeprom_present = (ahc_inb(ahc, SPIOCAP) & EEPROM) ? 1 : 0;
d1251 2
a1252 2
	struct   ahc_softc *ahc;
	u_int8_t value;
d1266 1
a1266 1
	ahc_flush_device_writes(ahc);
d1269 1
a1269 1
	ahc_flush_device_writes(ahc);
d1275 1
a1275 1
	ahc_flush_device_writes(ahc);
d1285 1
a1285 1
	struct   ahc_softc *ahc;
d1300 1
a1300 1
	ahc_flush_device_writes(ahc);
d1308 2
a1309 2
	struct ahc_softc *ahc;
	struct seeprom_descriptor *sd;
d1338 1
a1338 1
	struct seeprom_descriptor *sd;
d1351 1
a1351 8
#define PCIDEBUG
#ifdef	PCIDEBUG
#define	PCI_PRINT(Printstuff) printf Printstuff
#else
#define	PCI_PRINT(Printstuff)
#endif

void
d1353 1
a1353 1
	struct ahc_softc *ahc;
d1356 1
d1359 3
a1361 6
		return;
  	PCI_PRINT(("%s: PCI error Interrupt at seqaddr = 0x%x\n",
		   ahc_name(ahc), 
		   ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8)));
 
	status1 = ahc_pci_read_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, 4);
d1364 1
a1364 1
#ifdef AHC_SHOW_PCI_ERRORS
d1366 2
a1367 2
		PCI_PRINT(("%s: Data Parity Error Detected during address "
			   "or write data phase\n", ahc_name(ahc)));
d1371 1
a1371 1
		PCI_PRINT(("%s: Signal System Error Detected\n", ahc_name(ahc)));
d1374 1
a1374 1
		PCI_PRINT(("%s: Received a Master Abort\n", ahc_name(ahc)));
d1377 1
a1377 1
		PCI_PRINT(("%s: Received a Target Abort\n", ahc_name(ahc)));
d1380 1
a1380 1
		PCI_PRINT(("%s: Signaled a Target Abort\n", ahc_name(ahc)));
d1383 2
a1384 2
		PCI_PRINT(("%s: Data Parity Error has been reported via PERR#\n",
			   ahc_name(ahc)));
a1385 3
	
	ahc_pci_write_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, status1, 4);

d1388 5
a1392 2
		       "no status bits set\n", ahc_name(ahc)); 
	} else {
a1394 2
	
	ahc_unpause(ahc);
d1396 1
a1396 1
	return;
@


1.26.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a158 37
const struct pci_matchid ahc_pci_devices[] = {
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC7810 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC7850 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC7855 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC5900 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC5905 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC7860 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2940AU },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC7870 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2930CU },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2940 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_3940 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_3985 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2944 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC7880 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2940U },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_3940U },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_398XU },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2944U },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2940UWPro },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_7895 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7890 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_2940U2 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_2930U2 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7892 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_29160 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_19160B },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_3950U2B },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_3950U2D },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7896 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7899B },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7899D },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7899F },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7899 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_3960D },
};

d164 49
a212 2
	return (pci_matchbyid((struct pci_attach_args *)aux, ahc_pci_devices,
	    sizeof(ahc_pci_devices)/sizeof(ahc_pci_devices[0])));
d593 1
a593 1
	 * initialization.
@


1.25
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.24 2001/08/23 05:41:14 deraadt Exp $	*/
d473 1
a473 1
		printf(": couldn't map interrupt\n", ahc->sc_dev.dv_xname);
@


1.24
log
@shorten
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.23 2001/07/10 11:07:23 espie Exp $	*/
d472 1
a472 2
	if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
			 pa->pa_intrline, &ih)) {
@


1.23
log
@ANSI C does not like labels: without a statement after that.
Restore missing breaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.22 2001/06/12 15:40:29 niklas Exp $	*/
d203 3
@


1.22
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.21 2001/01/22 22:36:52 deraadt Exp $	*/
d363 1
@


1.21
log
@pretty print even during failure conditions
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.20 2000/12/29 03:51:41 smurph Exp $	*/
d380 1
a380 1
				memtype, 0, &iot, &ioh, NULL, NULL) == 0);
d391 1
a391 1
		    PCI_MAPREG_TYPE_IO, 0, &iot, &ioh, NULL, NULL) == 0);
@


1.20
log
@Suppress PCI bus error messages on i386.  They are not fatal and are usually
caused by another device on the PCI bus.  So we won't print them.  Just ACK them and go.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.19 2000/07/03 22:18:37 smurph Exp $	*/
d470 1
a470 1
		printf("%s: couldn't map interrupt\n", ahc->sc_dev.dv_xname);
d476 1
a476 1
                                        ahc->sc_dev.dv_xname);
d729 1
a729 1
}             
d1354 1
a1354 1
        
d1356 1
a1356 1
                return 0;
d1393 1
a1393 1
        return 1;
@


1.19
log
@Add support for big endian hardware.  Clean up memory vs. io mapping code.
Fix for drives with Tag quirks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.18 2000/05/26 06:49:32 chris Exp $	*/
d61 5
a65 1
 * for i386, we don't even try it.
d69 1
d1360 2
d1366 1
@


1.18
log
@Match 2930CU, it works with the new driver
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.17 2000/04/13 23:51:23 smurph Exp $	*/
d59 8
a215 5
#ifdef AHC_ALLOW_MEMIO
	bus_space_tag_t memt;
	bus_space_handle_t memh;
	int	memh_valid;
#endif
d360 21
d382 1
a382 4
#ifdef AHC_ALLOW_MEMIO
	memh_valid = (pci_mapreg_map(pa, AHC_PCI_MEMADDR,
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,
	    &memt, &memh, NULL, NULL) == 0);
d384 4
a387 2
	ioh_valid = (pci_mapreg_map(pa, AHC_PCI_IOADDR,
	    PCI_MAPREG_TYPE_IO, 0, &iot, &ioh, NULL, NULL) == 0);
d389 2
a390 8
	if (ioh_valid) {
		/* do nothing */
#ifdef AHC_ALLOW_MEMIO
	} else if (memh_valid) {
		/* do nothing */
#endif
	} else {
		/* error out */
@


1.17
log
@Add support for Adaptec 2930U2 controller.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.16 2000/04/13 04:25:10 smurph Exp $	*/
d164 1
@


1.16
log
@Add support for Adaptec 2930U2 controller.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.15 2000/04/06 18:21:42 aaron Exp $	*/
d180 1
d182 1
a182 1
		case PCI_PRODUCT_ADP2_AIC7890:
@


1.15
log
@Don't match AIC6915 -- that's a network card, supported by sf(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.14 2000/04/05 04:29:59 smurph Exp $	*/
d315 1
@


1.14
log
@Changed boot messages and fixed Ultra160 boot messages.
AHA-29160 Ultra160 verified working.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.13 2000/03/22 04:01:07 smurph Exp $	*/
a173 1
		case PCI_PRODUCT_ADP_AIC6915:
@


1.13
log
@new ahc driver.  Adds support for newer Adaptec controllers.  This represents two months of work.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.12 2000/01/31 01:50:55 weingart Exp $	*/
d431 2
a432 1
		printf("OptionMode = %x\n", optionmode);
@


1.12
log
@Add support for 93C66 and 93C56 SEEPROM chips.
Adapted from FreeBSD code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.11 1999/09/22 21:57:08 deraadt Exp $	*/
a35 4
#if defined(__FreeBSD__)
#include <pci.h>
#endif
#if NPCI > 0 || defined(__NetBSD__) || defined(__OpenBSD__)
a40 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a43 1
#endif /* defined(__NetBSD__) */
a47 16
#if defined(__FreeBSD__)

#include <pci/pcireg.h>
#include <pci/pcivar.h>

#include <machine/clock.h>

#include <i386/scsi/aic7xxx.h>
#include <i386/scsi/93cx6.h>

#include <dev/aic7xxx/aic7xxx_reg.h>

#define PCI_BASEADR0	PCI_MAP_REG_START

#elif defined(__NetBSD__) || defined(__OpenBSD__)

d50 4
d71 2
a72 1
#endif /* defined(__NetBSD__) */
d74 3
a76 14
#define PCI_DEVICE_ID_ADAPTEC_3940U	0x82789004ul
#define PCI_DEVICE_ID_ADAPTEC_398XU	0x83789004ul
#define PCI_DEVICE_ID_ADAPTEC_2944U	0x84789004ul
#define PCI_DEVICE_ID_ADAPTEC_2940U	0x81789004ul
#define PCI_DEVICE_ID_ADAPTEC_2940AU	0x61789004ul
#define PCI_DEVICE_ID_ADAPTEC_3940	0x72789004ul
#define PCI_DEVICE_ID_ADAPTEC_2944	0x74789004ul
#define PCI_DEVICE_ID_ADAPTEC_2940	0x71789004ul
#define PCI_DEVICE_ID_ADAPTEC_AIC7880	0x80789004ul
#define PCI_DEVICE_ID_ADAPTEC_AIC7870	0x70789004ul
#define PCI_DEVICE_ID_ADAPTEC_AIC7860	0x60789004ul
#define PCI_DEVICE_ID_ADAPTEC_AIC7855	0x55789004ul
#define PCI_DEVICE_ID_ADAPTEC_AIC7850	0x50789004ul
#define PCI_DEVICE_ID_ADAPTEC_2940UWPro	0x87789004ul
d79 13
a91 11
#define		MPORTMODE	0x00000400ul	/* aic7870 only */
#define		RAMPSM		0x00000200ul	/* aic7870 only */
#define		VOLSENSE	0x00000100ul
#define		SCBRAMSEL	0x00000080ul
#define		MRDCEN		0x00000040ul
#define		EXTSCBTIME	0x00000020ul	/* aic7870 only */
#define		EXTSCBPEN	0x00000010ul	/* aic7870 only */
#define		BERREN		0x00000008ul
#define		DACEN		0x00000004ul
#define		STPWLEVEL	0x00000002ul
#define		DIFACTNEGEN	0x00000001ul	/* aic7870 only */
d97 31
a127 68
/*
 * Define the format of the aic78X0 SEEPROM registers (16 bits).
 *
 */

struct seeprom_config {

/*
 * SCSI ID Configuration Flags
 */
#define CFXFER		0x0007		/* synchronous transfer rate */
#define CFSYNCH		0x0008		/* enable synchronous transfer */
#define CFDISC		0x0010		/* enable disconnection */
#define CFWIDEB		0x0020		/* wide bus device */
/* UNUSED		0x00C0 */
#define CFSTART		0x0100		/* send start unit SCSI command */
#define CFINCBIOS	0x0200		/* include in BIOS scan */
#define CFRNFOUND	0x0400		/* report even if not found */
/* UNUSED		0xf800 */
  u_int16_t device_flags[16];	/* words 0-15 */

/*
 * BIOS Control Bits
 */
#define CFSUPREM	0x0001		/* support all removeable drives */
#define CFSUPREMB	0x0002		/* support removeable drives for boot only */
#define CFBIOSEN	0x0004		/* BIOS enabled */
/* UNUSED		0x0008 */
#define CFSM2DRV	0x0010		/* support more than two drives */
/* UNUSED		0x0060 */
#define CFEXTEND	0x0080		/* extended translation enabled */
/* UNUSED		0xff00 */
  u_int16_t bios_control;		/* word 16 */

/*
 * Host Adapter Control Bits
 */
/* UNUSED		0x0001 */
#define CFULTRAEN       0x0002          /* Ultra SCSI speed enable (Ultra cards) */
#define CFSTERM		0x0004		/* SCSI low byte termination (non-wide cards) */
#define CFWSTERM	0x0008		/* SCSI high byte termination (wide card) */
#define CFSPARITY	0x0010		/* SCSI parity */
/* UNUSED		0x0020 */
#define CFRESETB	0x0040		/* reset SCSI bus at IC initialization */
/* UNUSED		0xff80 */
  u_int16_t adapter_control;	/* word 17 */

/*
 * Bus Release, Host Adapter ID
 */
#define CFSCSIID	0x000f		/* host adapter SCSI ID */
/* UNUSED		0x00f0 */
#define CFBRTIME	0xff00		/* bus release time */
 u_int16_t brtime_id;		/* word 18 */

/*
 * Maximum targets
 */
#define CFMAXTARG	0x00ff	/* maximum targets */
/* UNUSED		0xff00 */
  u_int16_t max_targets;		/* word 19 */

  u_int16_t res_1[11];		/* words 20-30 */
  u_int16_t checksum;		/* word 31 */
};

static void load_seeprom __P((struct ahc_data *ahc));
static int acquire_seeprom __P((struct seeprom_descriptor *sd));
d129 1
a132 67
#if defined(__FreeBSD__)

static char* aic7870_probe __P((pcici_t tag, pcidi_t type));
static void aic7870_attach __P((pcici_t config_id, int unit));

static struct  pci_device ahc_pci_driver = {
	"ahc",
        aic7870_probe,
        aic7870_attach,
        &ahc_unit,
	NULL
};

DATA_SET (pcidevice_set, ahc_pci_driver);

static  char*
aic7870_probe (pcici_t tag, pcidi_t type)
{
	switch(type) {
		case PCI_DEVICE_ID_ADAPTEC_3940U:
			return ("Adaptec 3940 Ultra SCSI host adapter");
			break;
		case PCI_DEVICE_ID_ADAPTEC_3940:
			return ("Adaptec 3940 SCSI host adapter");
			break;
		case PCI_DEVICE_ID_ADAPTEC_2944U:
			return ("Adaptec 2944 Ultra SCSI host adapter");
			break;
		case PCI_DEVICE_ID_ADAPTEC_2940U:
			return ("Adaptec 2940 Ultra SCSI host adapter");
			break;
		case PCI_DEVICE_ID_ADAPTEC_2944:
			return ("Adaptec 2944 SCSI host adapter");
			break;
		case PCI_DEVICE_ID_ADAPTEC_2940:
			return ("Adaptec 2940 SCSI host adapter");
			break;
		case PCI_DEVICE_ID_ADAPTEC_2940AU:
			return ("Adaptec 2940A Ultra SCSI host adapter");
			break;
		case PCI_DEVICE_ID_ADAPTEC_AIC7880:
			return ("Adaptec aic7880 Ultra SCSI host adapter");
			break;
		case PCI_DEVICE_ID_ADAPTEC_AIC7870:
			return ("Adaptec aic7870 SCSI host adapter");
			break;
		case PCI_DEVICE_ID_ADAPTEC_AIC7860:
			return ("Adaptec aic7860 SCSI host adapter");
			break;
		case PCI_DEVICE_ID_ADAPTEC_AIC7855:
			return ("Adaptec aic7855 SCSI host adapter");
			break;
		case PCI_DEVICE_ID_ADAPTEC_2940UWPro:
			return ("Adaptec 2940UW Pro Ultra SCSI host adapter");
			break;
		case PCI_DEVICE_ID_ADAPTEC_AIC7850:
			return ("Adaptec aic7850 SCSI host adapter");
			break;
		default:
			break;
	}
	return (0);

}

#elif defined(__NetBSD__) || defined(__OpenBSD__)

d137 7
a143 1
	sizeof(struct ahc_data), ahc_pci_probe, ahc_pci_attach
d148 46
a193 21
        struct device *parent;
        void *match, *aux; 
{       
        struct pci_attach_args *pa = aux;

	switch (pa->pa_id) {
	case PCI_DEVICE_ID_ADAPTEC_3940U:
	case PCI_DEVICE_ID_ADAPTEC_398XU:
	case PCI_DEVICE_ID_ADAPTEC_2944U:
	case PCI_DEVICE_ID_ADAPTEC_2940U:
	case PCI_DEVICE_ID_ADAPTEC_2940AU:
	case PCI_DEVICE_ID_ADAPTEC_3940:
	case PCI_DEVICE_ID_ADAPTEC_2944:
	case PCI_DEVICE_ID_ADAPTEC_2940:
	case PCI_DEVICE_ID_ADAPTEC_AIC7880:
	case PCI_DEVICE_ID_ADAPTEC_AIC7870:
	case PCI_DEVICE_ID_ADAPTEC_AIC7860:
	case PCI_DEVICE_ID_ADAPTEC_AIC7855:
	case PCI_DEVICE_ID_ADAPTEC_AIC7850:
	case PCI_DEVICE_ID_ADAPTEC_2940UWPro:
		return 1;
d195 1
a195 1
	return 0;
a196 1
#endif /* defined(__NetBSD__) */
d198 1
a198 7
#if defined(__FreeBSD__)
static void
aic7870_attach(config_id, unit)
	pcici_t config_id;
	int	unit;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
void    
d200 2
a201 3
        struct device *parent, *self;
        void *aux;
#endif
a202 4
#if defined(__FreeBSD__)
	u_long io_port;
	int unit = ahc->sc_dev.dv_unit;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
d204 2
a205 3
	struct ahc_data *ahc = (void *)self;
	bus_addr_t iobase;
	bus_size_t iosize;
d207 5
d213 1
a214 2
#endif
	u_long id;
d216 5
a220 5
	ahc_type ahc_t = AHC_NONE;
	ahc_flag ahc_f = AHC_FNONE;
#if defined(__FreeBSD__)
	struct ahc_data *ahc;
#endif
d223 43
a265 27

#if defined(__FreeBSD__)
        if(!(io_port = pci_conf_read(config_id, PCI_BASEADR0)))
		return;
	/*
	 * The first bit of PCI_BASEADR0 is always
	 * set hence we mask it off.
	 */
	io_port &= 0xfffffffe;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
	if (pci_io_find(pa->pa_pc, pa->pa_tag, PCI_BASEADR0, &iobase, &iosize))
		return;
	if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &ioh))
		return;
#endif

#if defined(__FreeBSD__)
	switch ((id = pci_conf_read(config_id, PCI_ID_REG))) {
#elif defined(__NetBSD__) || defined(__OpenBSD__)
	switch (id = pa->pa_id) {
#endif
		case PCI_DEVICE_ID_ADAPTEC_3940U:
		case PCI_DEVICE_ID_ADAPTEC_3940:
			if (id == PCI_DEVICE_ID_ADAPTEC_3940U)
				ahc_t = AHC_394U;
			else
				ahc_t = AHC_394;
d267 1
a267 1
			if(!(aic3940_count & 0x01))
d269 1
a269 1
				ahc_f |= AHC_CHNLB;
d271 35
a305 4
		case PCI_DEVICE_ID_ADAPTEC_2944U:
		case PCI_DEVICE_ID_ADAPTEC_2940U:
		case PCI_DEVICE_ID_ADAPTEC_2940UWPro:
			ahc_t = AHC_294U;
d307 2
a308 3
		case PCI_DEVICE_ID_ADAPTEC_2944:
		case PCI_DEVICE_ID_ADAPTEC_2940:
			ahc_t = AHC_294;
d310 34
a343 12
		case PCI_DEVICE_ID_ADAPTEC_2940AU:
			ahc_t = AHC_294AU;
			break;
		case PCI_DEVICE_ID_ADAPTEC_398XU:	/* XXX */
		case PCI_DEVICE_ID_ADAPTEC_AIC7880:
			ahc_t = AHC_AIC7880;
			break;
		case PCI_DEVICE_ID_ADAPTEC_AIC7870:
			ahc_t = AHC_AIC7870;
			break;
		case PCI_DEVICE_ID_ADAPTEC_AIC7860:
			ahc_t = AHC_AIC7860;
d345 5
a349 3
		case PCI_DEVICE_ID_ADAPTEC_AIC7855:
		case PCI_DEVICE_ID_ADAPTEC_AIC7850:
			ahc_t = AHC_AIC7850;
d352 2
a353 1
			break;
d355 8
d364 5
a368 13
	/* On all PCI adapters, we allow SCB paging */
	ahc_f |= AHC_PAGESCBS;

	/* Remeber how the card was setup in case there is no SEEPROM */
#if defined(__FreeBSD__)
	our_id = inb(SCSIID + io_port) & OID;
	if(ahc_t & AHC_ULTRA)
		ultra_enb = inb(SXFRCTL0 + io_port) & ULTRAEN;
#else
	our_id = bus_space_read_1(pa->pa_iot, ioh, SCSIID) & OID;
	if(ahc_t & AHC_ULTRA)
		ultra_enb = bus_space_read_1(pa->pa_iot, ioh, SXFRCTL0) &
		    ULTRAEN;
d370 15
d386 7
a392 5
#if defined(__FreeBSD__)
	ahc_reset(io_port);
#elif defined(__NetBSD__) || defined(__OpenBSD__)
	ahc_reset(ahc->sc_dev.dv_xname, pa->pa_iot, ioh);
#endif
a393 7
	if(ahc_t & AHC_AIC7870){
#if defined(__FreeBSD__)
		u_long devconfig = pci_conf_read(config_id, DEVCONFIG);
#elif defined(__NetBSD__) || defined(__OpenBSD__)
		u_long devconfig =
			pci_conf_read(pa->pa_pc, pa->pa_tag, DEVCONFIG);
#endif
d395 2
a396 29
		if(devconfig & (RAMPSM)) {
			/*
			 * External SRAM present.  Have the probe walk
			 * the SCBs to see how much SRAM we have and set
			 * the number of SCBs accordingly.  We have to
			 * turn off SCBRAMSEL to access the external
			 * SCB SRAM.
			 *
			 * It seems that early versions of the aic7870
			 * didn't use these bits, hence the hack for the
			 * 3940 above.  I would guess that recent 3940s
			 * using later aic7870 or aic7880 chips do
			 * actually set RAMPSM.
			 *
			 * The documentation isn't clear, but it sounds
			 * like the value written to devconfig must not
			 * have RAMPSM set.  The second sixteen bits of
			 * the register are R/O anyway, so it shouldn't
			 * affect RAMPSM either way.
			 */
			devconfig &= ~(RAMPSM|SCBRAMSEL);
#if defined(__FreeBSD__)
			pci_conf_write(config_id, DEVCONFIG, devconfig);
#elif defined(__NetBSD__) || defined(__OpenBSD__)
			pci_conf_write(pa->pa_pc, pa->pa_tag,
				       DEVCONFIG, devconfig);
#endif
		}
	}
d398 2
a399 3
#if defined(__FreeBSD__)
	if(!(ahc = ahc_alloc(unit, io_port, ahc_t, ahc_f)))
		return;  /* XXX PCI code should take return status */
d401 14
a414 1
	if(!(pci_map_int(config_id, ahc_intr, (void *)ahc, &bio_imask))) {
d418 24
a441 2
#elif defined(__NetBSD__) || defined(__OpenBSD__)
	ahc_construct(ahc, pa->pa_iot, ioh, ahc_t, ahc_f);
d445 1
a445 1
		printf(": couldn't map interrupt\n");
a449 3
#ifndef __OpenBSD__
	ahc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, ahc_intr, ahc);
#else
d451 2
a452 2
	    ahc->sc_dev.dv_xname);
#endif
d463 1
a463 1
#endif
d471 1
a471 1
	 * Do aic7870/aic7880/aic7850 specific initialization
d474 6
a479 2
		u_char	sblkctl;
		char	*id_string;
a480 27
		switch(ahc->type) {
		   case AHC_394U:
		   case AHC_294U:
		   case AHC_AIC7880:
		   {
			id_string = "aic7880 ";
			load_seeprom(ahc);
			break;
		   }
		   case AHC_394:
		   case AHC_294:
		   case AHC_AIC7870:
		   {
			id_string = "aic7870 ";
			load_seeprom(ahc);
			break;
		   }
		   case AHC_294AU:
		   case AHC_AIC7860:
		   {
			id_string = "aic7860 ";
			load_seeprom(ahc);
			break;
		   }
		   case AHC_AIC7850:
		   {
			id_string = "aic7850 ";
d482 2
a483 2
			 * Use defaults, if the chip wasn't initialized by
			 * a BIOS.
d485 2
a486 10
			ahc->flags |= AHC_USEDEFAULTS;
			break;
		   }
		   default:
		   {
			printf("ahc: Unknown controller type.  Ignoring.\n");
			ahc_free(ahc);
			splx(opri);
			return;
		   }
d489 5
d497 2
a498 2
		sblkctl = AHC_INB(ahc, SBLKCTL);
		AHC_OUTB(ahc, SBLKCTL, (sblkctl & ~(DIAGLEDEN|DIAGLEDON)));
d502 2
a503 1
		 * BIOS, so we default to 100%.
d505 5
a509 1
		AHC_OUTB(ahc, DSPCISTATUS, DFTHRSH_100);
d511 1
a511 1
		if(ahc->flags & AHC_USEDEFAULTS) {
d518 1
a518 16
			u_long i;
		        for(i = TARG_SCRATCH; i < 0x60; i++) {
                        	if(AHC_INB(ahc, i) != 0x00)
					break;
			}
			if(i == TARG_SCRATCH) {
				/*
				 * Try looking for all ones.  You can get
				 * either.
				 */
		        	for (i = TARG_SCRATCH; i < 0x60; i++) {
                        		if(AHC_INB(ahc, i) != 0xff)
						break;
				}
			}
			if((i != 0x60) && (our_id != 0)) {
d520 1
a520 1
					ahc_name(ahc));
d522 1
a522 9
			}
			else
				our_id = 0x07;
			AHC_OUTB(ahc, SCSICONF,
				 (our_id & 0x07)|ENSPCHK|RESET_SCSI);
			/* In case we are a wide card */
			AHC_OUTB(ahc, SCSICONF + 1, our_id);

			if(!ultra_enb || (ahc->flags & AHC_USEDEFAULTS)) {
d524 2
a525 3
				 * If there wasn't a BIOS or the board
				 * wasn't in this mode to begin with, 
				 * turn off ultra.
d527 2
a528 1
				ahc->type &= ~AHC_ULTRA;
d530 3
d534 1
d536 15
a550 2
		printf("%s: %s", ahc_name(ahc), id_string);
	}
d552 1
a552 1
	if(ahc_init(ahc)){
d563 29
a591 1
 * Read the SEEPROM.  Return 0 on failure
d593 121
a713 3
void
load_seeprom(ahc)
	struct	ahc_data *ahc;
d715 7
a721 11
	struct	seeprom_descriptor sd;
	struct	seeprom_config sc;
	u_short *scarray = (u_short *)&sc;
	u_short	checksum = 0;
	u_char	scsi_conf;
	u_char	host_id;
	int	have_seeprom;
                 
#if defined(__FreeBSD__)
	sd.sd_iobase = ahc->baseport + SEECTL;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
d724 14
a737 5
	sd.sd_control_offset = SEECTL;
	sd.sd_status_offset = SEECTL;
	sd.sd_dataout_offset = SEECTL;
#endif
	sd.sd_chip = C46;	/* XXX - backwards compat */
d746 1
a746 3
	if(bootverbose) 
		printf("%s: Reading SEEPROM...", ahc_name(ahc));
	have_seeprom = acquire_seeprom(&sd);
d748 37
a784 15
		have_seeprom = read_seeprom(&sd,
					    (u_int16_t *)&sc,
					    ahc->flags & AHC_CHNLB,
					    sizeof(sc)/2);
		release_seeprom(&sd);
		if (have_seeprom) {
			/* Check checksum */
			int i;

			for (i = 0;i < (sizeof(sc)/2 - 1);i = i + 1)
				checksum = checksum + scarray[i];
			if (checksum != sc.checksum) {
				if(bootverbose)
					printf ("checksum error");
				have_seeprom = 0;
d786 4
a789 2
			else if(bootverbose)
				printf("done.\n");
d792 1
d794 2
a795 2
		if(bootverbose)
			printf("\n%s: No SEEPROM availible\n", ahc_name(ahc));
d797 1
a797 2
	}
	else {
d804 21
d826 1
a826 7
	        for(i = 0; i < max_targ; i++){
	                u_char target_settings;
			target_settings = (sc.device_flags[i] & CFXFER) << 4;
			if (sc.device_flags[i] & CFSYNCH)
				target_settings |= SOFS;
			if (sc.device_flags[i] & CFWIDEB)
				target_settings |= WIDEXFER;
d828 34
a861 2
				ahc->discenable |= (0x01 << i);
			AHC_OUTB(ahc, TARG_SCRATCH+i, target_settings);
d863 1
a863 4
		AHC_OUTB(ahc, DISC_DSB, ~(ahc->discenable & 0xff));
		AHC_OUTB(ahc, DISC_DSB + 1, ~((ahc->discenable >> 8) & 0xff));

		host_id = sc.brtime_id & CFSCSIID;
d865 2
a866 2
		scsi_conf = (host_id & 0x7);
		if(sc.adapter_control & CFSPARITY)
d868 1
a868 1
		if(sc.adapter_control & CFRESETB)
d871 4
a874 1
		if(ahc->type & AHC_ULTRA) {
d876 1
a876 1
			if(!(sc.adapter_control & CFULTRAEN))
d878 1
a878 1
				ahc->type &= ~AHC_ULTRA;
d880 6
a885 4
		/* Set the host ID */
		AHC_OUTB(ahc, SCSICONF, scsi_conf);
		/* In case we are a wide card */
		AHC_OUTB(ahc, SCSICONF + 1, host_id);
d887 389
d1279 3
a1281 2
acquire_seeprom(sd)
	struct seeprom_descriptor *sd;
d1285 4
d1299 2
a1300 2
		DELAY (1000);  /* delay 1 msec */
        }
d1304 2
a1305 2
	}         
	return(1);
d1310 1
a1310 1
	struct seeprom_descriptor *sd;
d1316 51
a1366 1
#endif /* NPCI > 0 */
@


1.12.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 4
d45 1
d49 1
d54 16
a71 4
#include <dev/pci/pcidevs.h>

#define AHC_PCI_IOADDR	PCI_MAPREG_START	/* I/O Address */
#define AHC_PCI_MEMADDR	(PCI_MAPREG_START + 4)	/* Mem I/O Address */
d89 1
a89 2
#define AHC_394X_SLOT_CHANNEL_A	4
#define AHC_394X_SLOT_CHANNEL_B	5
d91 14
a104 3
#define AHC_398X_SLOT_CHANNEL_A	4
#define AHC_398X_SLOT_CHANNEL_B	8
#define AHC_398X_SLOT_CHANNEL_C	12
d107 11
a117 13
#define		SCBSIZE32	0x00010000UL	/* aic789X only */
#define		MPORTMODE	0x00000400UL	/* aic7870 only */
#define		RAMPSM		0x00000200UL	/* aic7870 only */
#define		VOLSENSE	0x00000100UL
#define		SCBRAMSEL	0x00000080UL
#define		PCI64		0x00000080UL	/* aic7891 & aic7897 only */
#define		MRDCEN		0x00000040UL
#define		EXTSCBTIME	0x00000020UL	/* aic7870 only */
#define		EXTSCBPEN	0x00000010UL	/* aic7870 & aic7890 only */
#define		BERREN		0x00000008UL
#define		DACEN		0x00000004UL
#define		STPWLEVEL	0x00000002UL
#define		DIFACTNEGEN	0x00000001UL	/* aic7870 only */
d123 68
a190 31
int	    ahc_pci_intr __P((struct ahc_softc *ahc));
static int  ahc_ext_scbram_present __P((struct ahc_softc *ahc));
static void ahc_ext_scbram_config __P((struct ahc_softc *ahc, int enable,
													int pcheck, int fast));
static void ahc_probe_ext_scbram __P((struct ahc_softc *ahc));
static void check_extport __P((struct ahc_softc *ahc, u_int *sxfrctl1));
static void configure_termination __P((struct ahc_softc *ahc,
				       struct seeprom_descriptor *sd,
				       u_int adapter_control,
				       u_int *sxfrctl1));
static void ahc_new_term_detect __P((struct ahc_softc *ahc,
				     int *enableSEC_low,
				     int *enableSEC_high,
				     int *enablePRI_low,
				     int *enablePRI_high,
				     int *eeprom_present));
static void aic787X_cable_detect __P((struct ahc_softc *ahc,
				      int *internal50_present,
				      int *internal68_present,
				      int *externalcable_present,
				      int *eeprom_present));
static void aic785X_cable_detect __P((struct ahc_softc *ahc,
				      int *internal50_present,
				      int *externalcable_present,
				      int *eeprom_present));
static void write_brdctl __P((struct ahc_softc *ahc, u_int8_t value));
static u_int8_t read_brdctl __P((struct ahc_softc *ahc));

void load_seeprom __P((struct ahc_softc *ahc));
static int acquire_seeprom __P((struct ahc_softc *ahc,
				struct seeprom_descriptor *sd));
a191 1
int ahc_probe_scbs __P((struct ahc_softc *ahc));
d195 67
d266 1
a266 7
	sizeof(struct ahc_softc), ahc_pci_probe, ahc_pci_attach
};

struct ahc_pci_data {
	pci_chipset_tag_t pc;
	pcitag_t tag;
	u_int function;
d271 21
a291 46
struct device *parent;
void *match, *aux;
{
	struct pci_attach_args *pa = aux;

	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_ADP:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_ADP_AIC7810:
		case PCI_PRODUCT_ADP_AIC7850:
		case PCI_PRODUCT_ADP_AIC7855:
		case PCI_PRODUCT_ADP_AIC5900:
		case PCI_PRODUCT_ADP_AIC5905:
		case PCI_PRODUCT_ADP_AIC7860:
		case PCI_PRODUCT_ADP_2940AU:
		case PCI_PRODUCT_ADP_AIC7870:
		case PCI_PRODUCT_ADP_2940:
		case PCI_PRODUCT_ADP_3940:
		case PCI_PRODUCT_ADP_3985:
		case PCI_PRODUCT_ADP_2944:
		case PCI_PRODUCT_ADP_AIC7880:
		case PCI_PRODUCT_ADP_2940U:
		case PCI_PRODUCT_ADP_3940U:
		case PCI_PRODUCT_ADP_398XU:
		case PCI_PRODUCT_ADP_2944U:
		case PCI_PRODUCT_ADP_2940UWPro:
		case PCI_PRODUCT_ADP_AIC6915:
		case PCI_PRODUCT_ADP_7895:
			return (1);
		}
			break;
	case PCI_VENDOR_ADP2:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_ADP2_2940U2:
		case PCI_PRODUCT_ADP2_AIC7890:
		case PCI_PRODUCT_ADP2_AIC7892:
		case PCI_PRODUCT_ADP2_29160:
		case PCI_PRODUCT_ADP2_19160B:
		case PCI_PRODUCT_ADP2_3950U2B:
		case PCI_PRODUCT_ADP2_3950U2D:
		case PCI_PRODUCT_ADP2_AIC7896:
		case PCI_PRODUCT_ADP2_AIC7899:
		case PCI_PRODUCT_ADP2_3960D:
			return (1);
		}
		break;
d293 1
a293 1
	return (0);
d295 1
d297 7
a303 1
void
d305 3
a307 2
struct device *parent, *self;
void *aux;
d309 4
d314 3
a316 2
	struct ahc_softc *ahc = (void *)self;
	bus_space_tag_t  iot;
a317 5
#ifdef AHC_ALLOW_MEMIO
	bus_space_tag_t memt;
	bus_space_handle_t memh;
	int	memh_valid;
#endif
a318 1
	pcireg_t	   command;
d320 2
d323 5
a327 5
	ahc_chip ahc_c = AHC_PCI; /* we are a PCI controller */
	ahc_flag ahc_flags = AHC_FNONE;
	ahc_feature ahc_f = AHC_FENONE;
	int	ioh_valid;

d330 27
a356 43
	u_char channel = 'A';
	u_int    sxfrctl1;
	u_int    scsiseq;
	/* So we can access PCI configuration space after init */
	struct ahc_pci_data *pd;

	ahc->sc_dmat = pa->pa_dmat;
	
	command = pci_conf_read(pa->pa_pc, pa->pa_tag,
				PCI_COMMAND_STATUS_REG);

	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_ADP:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_ADP_7895:
			{
				pcireg_t devconfig;
				channel = pa->pa_function == 1 ? 'B' : 'A';
				ahc_c |= AHC_AIC7895;
				/* The 'C' revision of the aic7895 
				   has a few additional features */
				if (PCI_REVISION(pa->pa_class) >= 4)
					ahc_f = AHC_AIC7895C_FE;
				else
					ahc_f = AHC_AIC7895_FE;
				ahc_flags |= AHC_NEWEEPROM_FMT;
				devconfig = pci_conf_read(pa->pa_pc, 
							  pa->pa_tag,
							  DEVCONFIG);
				devconfig &= ~SCBSIZE32;
				pci_conf_write(pa->pa_pc, pa->pa_tag,
					       DEVCONFIG, devconfig);
			}
			break;
	   case PCI_PRODUCT_ADP_3940U:
		case PCI_PRODUCT_ADP_3940:
			if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADP_3940U) {
				ahc_c |= AHC_AIC7880;
				ahc_f = AHC_AIC7880_FE;
			} else {
				ahc_c |= AHC_AIC7870;
				ahc_f = AHC_AIC7870_FE;
			}
d358 1
a358 1
			if (!(aic3940_count & 0x01))
d360 6
a365 1
				channel = 'B';
d367 3
a369 35
		case PCI_PRODUCT_ADP_2940UWPro:
			ahc_c |= AHC_AIC7880;
			ahc_f = AHC_AIC7880_FE;
			ahc_f |= AHC_INT50_SPEEDFLEX;
		case PCI_PRODUCT_ADP_2944U:
		case PCI_PRODUCT_ADP_2940U:
			ahc_c |= AHC_AIC7880;
			ahc_f = AHC_AIC7880_FE;
			break;
		case PCI_PRODUCT_ADP_2944:
		case PCI_PRODUCT_ADP_2940:
			ahc_c |= AHC_AIC7870;
			ahc_f = AHC_AIC7870_FE;
			break;
		case PCI_PRODUCT_ADP_2940AU:
			ahc_c |= AHC_AIC7860;
			ahc_f = AHC_AIC7860_FE;
			break;
		case PCI_PRODUCT_ADP_398XU:	/* XXX */
		case PCI_PRODUCT_ADP_AIC7880:
			ahc_c |= AHC_AIC7880;
			ahc_f = AHC_AIC7880_FE;
			break;
		case PCI_PRODUCT_ADP_AIC7870:
			ahc_c |= AHC_AIC7870;
			ahc_f = AHC_AIC7870_FE;
			break;
		case PCI_PRODUCT_ADP_AIC7860:
			ahc_c |= AHC_AIC7860;
			ahc_f = AHC_AIC7860_FE;
			break;
		case PCI_PRODUCT_ADP_AIC7855:
		case PCI_PRODUCT_ADP_AIC7850:
			ahc_c |= AHC_AIC7850;
			ahc_f = AHC_AIC7850_FE;
d371 9
a379 2
		default:
			/* TTT */
d381 2
a382 34
	}
		break;
	case PCI_VENDOR_ADP2:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_ADP2_AIC7890:
		case PCI_PRODUCT_ADP2_2940U2:
			ahc_c |= AHC_AIC7890;
			ahc_f = AHC_AIC7890_FE;
			ahc_flags |= AHC_NEWEEPROM_FMT;
			break;
		case PCI_PRODUCT_ADP2_AIC7892:
		case PCI_PRODUCT_ADP2_29160:
		case PCI_PRODUCT_ADP2_19160B:
			ahc_c |= AHC_AIC7892;
			ahc_f = AHC_AIC7892_FE;
			ahc_flags |= AHC_NEWEEPROM_FMT;
			break;
		case PCI_PRODUCT_ADP2_3950U2B:
		case PCI_PRODUCT_ADP2_3950U2D:
		case PCI_PRODUCT_ADP2_AIC7896:
			{
				pcireg_t devconfig;
				channel = pa->pa_function == 1 ? 'B' : 'A';
				ahc_c |= AHC_AIC7896;
				ahc_f = AHC_AIC7896_FE;
				ahc_flags |= AHC_NEWEEPROM_FMT;
				devconfig = pci_conf_read(pa->pa_pc, 
							  pa->pa_tag, 
							  DEVCONFIG);
				/* turn off 64 bit for now XXX smurph */
				devconfig &= ~PCI64;
				pci_conf_write(pa->pa_pc, pa->pa_tag, 
					       DEVCONFIG, devconfig);
			}
d384 3
a386 5
		case PCI_PRODUCT_ADP2_AIC7899:
		case PCI_PRODUCT_ADP2_3960D:
			ahc_c |= AHC_AIC7899;
			ahc_f = AHC_AIC7899_FE;
			ahc_flags |= AHC_NEWEEPROM_FMT;
d389 1
a389 2
			/* TTT */
		}
d391 14
a404 5
	
#ifdef AHC_ALLOW_MEMIO
	memh_valid = (pci_mapreg_map(pa, AHC_PCI_MEMADDR,
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,
	    &memt, &memh, NULL, NULL) == 0);
a405 2
	ioh_valid = (pci_mapreg_map(pa, AHC_PCI_IOADDR,
	    PCI_MAPREG_TYPE_IO, 0, &iot, &ioh, NULL, NULL) == 0);
d407 4
a410 5
	if (ioh_valid) {
		/* do nothing */
#ifdef AHC_ALLOW_MEMIO
	} else if (memh_valid) {
		/* do nothing */
a411 15
	} else {
		/* error out */
		printf(": unable to map registers\n");
		return;
	}
	
	/* Ensure busmastering is enabled */
	command |= PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);

	pd = malloc(sizeof (struct ahc_pci_data), M_DEVBUF, M_NOWAIT);
	if (pd == NULL) {
		printf(": error allocating pci data\n");
		return;
	}
d413 7
a419 7
	pd->pc = pa->pa_pc;
	pd->tag = pa->pa_tag;
	pd->function = pa->pa_function;

	/* setup the PCI stuff */
	ahc->pci_data = pd;
	ahc->pci_intr_func = ahc_pci_intr;
d421 29
d451 3
a453 5
	/* On all PCI adapters, we allow SCB paging */
	ahc_flags |= AHC_PAGESCBS;

	ahc_construct(ahc, pa->pa_iot, ioh, ahc_c, ahc_flags, ahc_f, channel);
	/* Now we can use the ahc_inb and ahc_outb macros */
d455 1
a455 14
	/* setup the PCI error interrupt handler */
	ahc->pci_intr_func = &ahc_pci_intr;
	
	/* Remeber how the card was setup in case there is no SEEPROM */
	ahc_outb(ahc, HCNTRL, ahc->pause);
	if ((ahc->features & AHC_ULTRA2) != 0)
		our_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;
	else
		our_id = ahc_inb(ahc, SCSIID) & OID;
	sxfrctl1 = ahc_inb(ahc, SXFRCTL1) & STPWEN;
	scsiseq = ahc_inb(ahc, SCSISEQ);
	
	if (ahc_reset(ahc) != 0) {
		/* Failed */
d459 2
a460 24
	
	if (ahc->features & AHC_ULTRA)
		ultra_enb = bus_space_read_1(pa->pa_iot, ioh, SXFRCTL0) &
						FAST20;
	
	if ((ahc->features & AHC_DT) != 0) {
		u_int optionmode;
		u_int sfunct;

		/* Perform ALT-Mode Setup */
		sfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;
		ahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);
		optionmode = ahc_inb(ahc, OPTIONMODE);
		printf("OptionMode = %x\n", optionmode);
		ahc_outb(ahc, OPTIONMODE, OPTIONMODE_DEFAULTS);
		/* Send CRC info in target mode every 4K */
		ahc_outb(ahc, TARGCRCCNT, 0);
		ahc_outb(ahc, TARGCRCCNT + 1, 0x10);
		ahc_outb(ahc, SFUNCT, sfunct);

		/* Normal mode setup */
		ahc_outb(ahc, CRCCONTROL1, CRCVALCHKEN|CRCENDCHKEN|CRCREQCHKEN
					|TARGCRCENDEN|TARGCRCCNTEN);
	}
d464 1
a464 1
		printf("%s: couldn't map interrupt\n", ahc->sc_dev.dv_xname);
d469 3
d473 2
a474 2
                                        ahc->sc_dev.dv_xname);

d485 1
a485 1

d493 1
a493 1
	 * Do aic7880/aic7870/aic7860/aic7850 specific initialization
d496 2
a497 6
		u_int8_t sblkctl;
		u_int dscommand0;

		dscommand0 = ahc_inb(ahc, DSCOMMAND0);
		dscommand0 |= MPARCKEN;
		if ((ahc->features & AHC_ULTRA2) != 0) {
d499 27
d527 2
a528 2
			 * DPARCKEN doesn't work correctly on
			 * some MBs so don't use it.
d530 10
a539 2
			dscommand0 &= ~(USCBSIZE32|DPARCKEN);
			dscommand0 |= CACHETHEN;
a541 5
		ahc_outb(ahc, DSCOMMAND0, dscommand0);

		/* See if we have an SEEPROM and perform auto-term */
		check_extport(ahc, &sxfrctl1);

d545 2
a546 2
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, (sblkctl & ~(DIAGLEDEN|DIAGLEDON)));
d550 1
a550 2
		 * BIOS, so we default to 100% on Ultra or slower controllers
		 * and 75% on ULTRA2 controllers.
d552 1
a552 5
		if ((ahc->features & AHC_ULTRA2) != 0) {
			ahc_outb(ahc, DFF_THRSH, RD_DFTHRSH_75|WR_DFTHRSH_75);
		} else {
			ahc_outb(ahc, DSPCISTATUS, DFTHRSH_100);
		}
d554 1
a554 1
		if (ahc->flags & AHC_USEDEFAULTS) {
d561 16
a576 1
			if (scsiseq != 0) {
d578 1
a578 1
						 ahc_name(ahc));
d580 9
a588 1
			} else {
d590 3
a592 2
				 * Assume only one connector and always turn
				 * on termination.
d594 1
a594 2
				our_id = 0x07;
				sxfrctl1 = STPWEN;
d596 1
a596 1
			ahc_outb(ahc, SCSICONF, our_id|ENSPCHK|RESET_SCSI);
d598 1
a598 2
			ahc->our_id = our_id;
		}
d601 1
a601 17
	/*
	 * Take a look to see if we have external SRAM.
	 * We currently do not attempt to use SRAM that is
	 * shared among multiple controllers.
	 */
	ahc_probe_ext_scbram(ahc);

	printf("%s: ", ahc_name(ahc));

	/*
	 * Record our termination setting for the
	 * generic initialization routine.
	 */
	if ((sxfrctl1 & STPWEN) != 0)
		ahc->flags |= AHC_TERM_ENB_A;

	if (ahc_init(ahc)) {
d612 1
a612 2
 * Test for the presense of external sram in an
 * "unshared" configuration.
d614 3
a616 33
static int
ahc_ext_scbram_present(ahc)
struct ahc_softc *ahc;
{
	int ramps;
	int single_user;
	pcireg_t devconfig;
	struct ahc_pci_data *pd = ahc->pci_data;

	devconfig = pci_conf_read(pd->pc, pd->tag, DEVCONFIG);
	single_user = (devconfig & MPORTMODE) != 0;

	if ((ahc->features & AHC_ULTRA2) != 0)
		ramps = (ahc_inb(ahc, DSCOMMAND0) & RAMPS) != 0;
	else if ((ahc->chip & AHC_CHIPID_MASK) >= AHC_AIC7870)
		ramps = (devconfig & RAMPSM) != 0;
	else
		ramps	= 0;

	if (ramps && single_user)
		return (1);
	return (0);
}

/*
 * Enable external scbram.
 */
static void
ahc_ext_scbram_config(ahc, enable, pcheck, fast)
struct ahc_softc *ahc;
int enable;
int pcheck;
int fast;
d618 11
a628 122
	pcireg_t devconfig;
	struct ahc_pci_data *pd = ahc->pci_data;

	if (ahc->features & AHC_MULTI_FUNC) {
		u_char channel; 
		/*
		 * Set the SCB Base addr (highest address bit)
		 * depending on which channel we are.
		 */
		channel = pd->function == 1 ? 1 : 0;
		ahc_outb(ahc, SCBBADDR, channel);
	}

	devconfig = pci_conf_read(pd->pc, pd->tag, DEVCONFIG);
	
	if ((ahc->features & AHC_ULTRA2) != 0) {
		u_int dscommand0;

		dscommand0 = ahc_inb(ahc, DSCOMMAND0);
		if (enable)
			dscommand0 &= ~INTSCBRAMSEL;
		else
			dscommand0 |= INTSCBRAMSEL;
		ahc_outb(ahc, DSCOMMAND0, dscommand0);
	} else {
		if (fast)
			devconfig &= ~EXTSCBTIME;
		else
			devconfig |= EXTSCBTIME;
		if (enable)
			devconfig &= ~SCBRAMSEL;
		else
			devconfig |= SCBRAMSEL;
	}
	if (pcheck)
		devconfig |= EXTSCBPEN;
	else
		devconfig &= ~EXTSCBPEN;

	pci_conf_write(pd->pc, pd->tag, DEVCONFIG, devconfig);
}

/*
 * Take a look to see if we have external SRAM.
 * We currently do not attempt to use SRAM that is
 * shared among multiple controllers.
 */
static void
ahc_probe_ext_scbram(ahc)
struct ahc_softc *ahc;
{
	int num_scbs;
	int test_num_scbs;
	int enable;
	int pcheck;
	int fast;

	if (ahc_ext_scbram_present(ahc) == 0)
		return;

	/*
	 * Probe for the best parameters to use.
	 */
	enable = 0;
	pcheck = 0;
	fast = 0;
	ahc_ext_scbram_config(ahc,	/*enable*/1, pcheck, fast);
	num_scbs = ahc_probe_scbs(ahc);
	if (num_scbs == 0) {
		/* The SRAM wasn't really present. */
		goto done;
	}
	enable = 1;

	/* Now see if we can do parity */
	ahc_ext_scbram_config(ahc, enable, /*pcheck*/1, fast);
	num_scbs = ahc_probe_scbs(ahc);
	if ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0
		 || (ahc_inb(ahc, ERROR) & MPARERR) == 0)
		pcheck = 1;

	/* Clear any resulting parity error */
	ahc_outb(ahc, CLRINT, CLRPARERR);
	ahc_outb(ahc, CLRINT, CLRBRKADRINT);

	/* Now see if we can do fast timing */
	ahc_ext_scbram_config(ahc, enable, pcheck, /*fast*/1);
	test_num_scbs = ahc_probe_scbs(ahc);
	if (test_num_scbs == num_scbs
		 && ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0
			  || (ahc_inb(ahc, ERROR) & MPARERR) == 0))
		fast = 1;

	done:
	/* Clear any resulting parity error */
	ahc_outb(ahc, CLRINT, CLRPARERR);
	ahc_outb(ahc, CLRINT, CLRBRKADRINT);
	if (bootverbose && enable) {
		printf("%s: External SRAM, %dns access%s\n",
				 ahc_name(ahc), fast ? 10 : 20,
				 pcheck ? ", parity checking enabled" : "");

	}
	ahc_ext_scbram_config(ahc, enable, pcheck, fast);
}             

/*
 * Check the external port logic for a serial eeprom
 * and termination/cable detection contrls.
 */
static void
check_extport(ahc, sxfrctl1)
struct ahc_softc *ahc;
u_int *sxfrctl1;
{
	struct     seeprom_descriptor sd;
	struct     seeprom_config sc;
	u_int   scsi_conf;
	u_int   adapter_control;
	int     have_seeprom;
	int     have_autoterm;

d631 5
a635 14
	sd.sd_control_offset = SEECTL;      
	sd.sd_status_offset = SEECTL;    
	sd.sd_dataout_offset = SEECTL;      

	/*
	 * For some multi-channel devices, the c46 is simply too
	 * small to work.  For the other controller types, we can
	 * get our information from either SEEPROM type.  Set the
	 * type to start our probe with accordingly.
	 */
	if (ahc->flags & AHC_LARGE_SEEPROM)
		sd.sd_chip = C56_66;
	else
		sd.sd_chip = C46;
d644 3
a646 1
	have_seeprom = acquire_seeprom(ahc, &sd);
d648 15
a662 37

		if (bootverbose)
			printf("%s: Reading SEEPROM...", ahc_name(ahc));

		for (;;) {
			bus_size_t start_addr;

			start_addr = 32 * (ahc->channel - 'A');

			have_seeprom = read_seeprom(&sd,
						    (u_int16_t *)&sc,
						    start_addr,
						    sizeof(sc)/2);

			if (have_seeprom) {
				/* Check checksum */
				int i;
				int maxaddr;
				u_int32_t checksum;
				u_int16_t *scarray;

				maxaddr = (sizeof(sc)/2) - 1;
				checksum = 0;
				scarray = (u_int16_t *)&sc;

				for (i = 0; i < maxaddr; i++)
					checksum = checksum + scarray[i];
				if (checksum == 0
				    || (checksum & 0xFFFF) != sc.checksum) {
					if (bootverbose && sd.sd_chip == C56_66)
						printf ("checksum error\n");
					have_seeprom = 0;
				} else {
					if (bootverbose)
						printf("done.\n");
					break;
				}
d664 2
a665 4

			if (sd.sd_chip == C56_66)
				break;
			sd.sd_chip = C56_66;
a667 1

d669 2
a670 2
		if (bootverbose)
			printf("%s: No SEEPROM available.\n", ahc_name(ahc));
d672 2
a673 1
	} else {
a679 2
		u_int16_t discenable;
		u_int16_t ultraenb;
d681 10
a690 13
		discenable = 0;
		ultraenb = 0;
		if ((sc.adapter_control & CFULTRAEN) != 0) {
			/*
			 * Determine if this adapter has a "newstyle"
			 * SEEPROM format.
			 */
			for (i = 0; i < max_targ; i++) {
				if ((sc.device_flags[i] & CFSYNCHISULTRA) != 0) {
					ahc->flags |= AHC_NEWEEPROM_FMT;
					break;
				}
			}
d692 2
d695 1
a695 42
		for (i = 0; i < max_targ; i++) {
			u_int     scsirate;
			u_int16_t target_mask;

			target_mask = 0x01 << i;
			if (sc.device_flags[i] & CFDISC)
				discenable |= target_mask;
			if ((ahc->flags & AHC_NEWEEPROM_FMT) != 0) {
				if ((sc.device_flags[i] & CFSYNCHISULTRA) != 0)
					ultraenb |= target_mask;
			} else if ((sc.adapter_control & CFULTRAEN) != 0) {
				ultraenb |= target_mask;
			}
			if ((sc.device_flags[i] & CFXFER) == 0x04
				 && (ultraenb & target_mask) != 0) {
				/* Treat 10MHz as a non-ultra speed */
				sc.device_flags[i] &= ~CFXFER;
				ultraenb &= ~target_mask;
			}
			if ((ahc->features & AHC_ULTRA2) != 0) {
				u_int offset;

				if (sc.device_flags[i] & CFSYNCH)
					offset = MAX_OFFSET_ULTRA2;
				else
					offset = 0;
				ahc_outb(ahc, TARG_OFFSET + i, offset);

				scsirate = (sc.device_flags[i] & CFXFER)
				| ((ultraenb & target_mask) ? 0x8 : 0x0);
				if (sc.device_flags[i] & CFWIDEB)
					scsirate |= WIDEXFER;
			} else {
				scsirate = (sc.device_flags[i] & CFXFER) << 4;
				if (sc.device_flags[i] & CFSYNCH)
					scsirate |= SOFS;
				if (sc.device_flags[i] & CFWIDEB)
					scsirate |= WIDEXFER;
			}
			ahc_outb(ahc, TARG_SCSIRATE + i, scsirate);
		}
		ahc->our_id = sc.brtime_id & CFSCSIID;
d697 2
a698 2
		scsi_conf = (ahc->our_id & 0x7);
		if (sc.adapter_control & CFSPARITY)
d700 1
a700 1
		if (sc.adapter_control & CFRESETB)
d703 1
a703 4
		if (sc.bios_control & CFEXTEND)
			ahc->flags |= AHC_EXTENDED_TRANS_A;
		if (ahc->features & AHC_ULTRA
			 && (ahc->flags & AHC_NEWEEPROM_FMT) == 0) {
d705 1
a705 1
			if (!(sc.adapter_control & CFULTRAEN))
d707 1
a707 1
				ultraenb = 0;
d709 4
a712 6
		/* Set SCSICONF info */
		ahc_outb(ahc, SCSICONF, scsi_conf);
		ahc_outb(ahc, DISC_DSB, ~(discenable & 0xff));
		ahc_outb(ahc, DISC_DSB + 1, ~((discenable >> 8) & 0xff));
		ahc_outb(ahc, ULTRA_ENB, ultraenb & 0xff);
		ahc_outb(ahc, ULTRA_ENB + 1, (ultraenb >> 8) & 0xff);
a713 389

	/*
	 * Cards that have the external logic necessary to talk to
	 * a SEEPROM, are almost certain to have the remaining logic
	 * necessary for auto-termination control.  This assumption
	 * hasn't failed yet...
	 */
	have_autoterm = have_seeprom;
	if (have_seeprom)
		adapter_control = sc.adapter_control;
	else
		adapter_control = CFAUTOTERM;

	/*
	 * Some low-cost chips have SEEPROM and auto-term control built
	 * in, instead of using a GAL.  They can tell us directly
	 * if the termination logic is enabled.
	 */
	if ((ahc->features & AHC_SPIOCAP) != 0) {
		if ((ahc_inb(ahc, SPIOCAP) & SSPIOCPS) != 0)
			have_autoterm = 1;
		else
			have_autoterm = 0;
	}

	if (have_autoterm)
		configure_termination(ahc, &sd, adapter_control, sxfrctl1);

	release_seeprom(&sd);
}

static void
configure_termination(ahc, sd, adapter_control, sxfrctl1)
struct ahc_softc *ahc;
struct seeprom_descriptor *sd;
u_int adapter_control;
u_int *sxfrctl1;
{
	u_int8_t brddat;

	brddat = 0;

	/*
	 * Update the settings in sxfrctl1 to match the
	 * termination settings 
	 */
	*sxfrctl1 = 0;

	/*
	 * SEECS must be on for the GALS to latch
	 * the data properly.  Be sure to leave MS
	 * on or we will release the seeprom.
	 */
	SEEPROM_OUTB(sd, sd->sd_MS | sd->sd_CS);
	if ((adapter_control & CFAUTOTERM) != 0
		 || (ahc->features & AHC_NEW_TERMCTL) != 0) {
		int internal50_present;
		int internal68_present;
		int externalcable_present;
		int eeprom_present;
		int enableSEC_low;
		int enableSEC_high;
		int enablePRI_low;
		int enablePRI_high;

		enableSEC_low = 0;
		enableSEC_high = 0;
		enablePRI_low = 0;
		enablePRI_high = 0;
		if ((ahc->features & AHC_NEW_TERMCTL) != 0) {
			ahc_new_term_detect(ahc, &enableSEC_low,
					    &enableSEC_high,
					    &enablePRI_low,
					    &enablePRI_high,
					    &eeprom_present);
			if ((adapter_control & CFSEAUTOTERM) == 0) {
				if (bootverbose)
					printf("%s: Manual SE Termination\n",
							 ahc_name(ahc));
				enableSEC_low = (adapter_control & CFSTERM);
				enableSEC_high = (adapter_control & CFWSTERM);
			}
			if ((adapter_control & CFAUTOTERM) == 0) {
				if (bootverbose)
					printf("%s: Manual LVD Termination\n",
					       ahc_name(ahc));
				enablePRI_low = enablePRI_high =
					(adapter_control & CFLVDSTERM);
			}
			/* Make the table calculations below happy */
			internal50_present = 0;
			internal68_present = 1;
			externalcable_present = 1;
		} else if ((ahc->features & AHC_SPIOCAP) != 0) {
			aic785X_cable_detect(ahc, &internal50_present,
					     &externalcable_present,
					     &eeprom_present);
		} else {
			aic787X_cable_detect(ahc, &internal50_present,
					     &internal68_present,
					     &externalcable_present,
					     &eeprom_present);
		}

		if ((ahc->features & AHC_WIDE) == 0)
			internal68_present = 0;

		if (bootverbose) {
			if ((ahc->features & AHC_ULTRA2) == 0) {
				printf("%s: internal 50 cable %s present, "
				       "internal 68 cable %s present\n",
				       ahc_name(ahc),
				       internal50_present ? "is":"not",
				       internal68_present ? "is":"not");

				printf("%s: external cable %s present\n",
				       ahc_name(ahc),
				       externalcable_present ? "is":"not");
			}
			printf("%s: BIOS eeprom %s present\n",
			       ahc_name(ahc), eeprom_present ? "is" : "not");
		}

		if ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0) {
			/*
			 * The 50 pin connector is a separate bus,
			 * so force it to always be terminated.
			 * In the future, perform current sensing
			 * to determine if we are in the middle of
			 * a properly terminated bus.
			 */
			internal50_present = 0;
		}

		/*
		 * Now set the termination based on what
		 * we found.
		 * Flash Enable = BRDDAT7
		 * Secondary High Term Enable = BRDDAT6
		 * Secondary Low Term Enable = BRDDAT5 (7890)
		 * Primary High Term Enable = BRDDAT4 (7890)
		 */
		if ((ahc->features & AHC_ULTRA2) == 0
		    && (internal50_present != 0)
		    && (internal68_present != 0)
		    && (externalcable_present != 0)) {
			printf("%s: Illegal cable configuration!!. "
			       "Only two connectors on the "
			       "adapter may be used at a "
			       "time!\n", ahc_name(ahc));
		}

		if ((ahc->features & AHC_WIDE) != 0
			 && ((externalcable_present == 0)
				  || (internal68_present == 0)
				  || (enableSEC_high != 0))) {
			brddat |= BRDDAT6;
			if (bootverbose) {
				if ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0)
					printf("%s: 68 pin termination "
					       "Enabled\n", ahc_name(ahc));
				else
					printf("%s: %sHigh byte termination "
					       "Enabled\n", ahc_name(ahc),
					       enableSEC_high ? "Secondary "
					       : "");
			}
		}

		if (((internal50_present ? 1 : 0)
			  + (internal68_present ? 1 : 0)
			  + (externalcable_present ? 1 : 0)) <= 1
			 || (enableSEC_low != 0)) {
			if ((ahc->features & AHC_ULTRA2) != 0)
				brddat |= BRDDAT5;
			else
				*sxfrctl1 |= STPWEN;
			if (bootverbose) {
				if ((ahc->flags & AHC_INT50_SPEEDFLEX) != 0)
					printf("%s: 50 pin termination "
					       "Enabled\n", ahc_name(ahc));
				else
					printf("%s: %sLow byte termination "
					       "Enabled\n", ahc_name(ahc),
					       enableSEC_low ? "Secondary "
					       : "");
			}
		}

		if (enablePRI_low != 0) {
			*sxfrctl1 |= STPWEN;
			if (bootverbose)
				printf("%s: Primary Low Byte termination "
				       "Enabled\n", ahc_name(ahc));
		}

		/*
		 * Setup STPWEN before setting up the rest of
		 * the termination per the tech note on the U160 cards.
		 */
		ahc_outb(ahc, SXFRCTL1, *sxfrctl1);

		if (enablePRI_high != 0) {
			brddat |= BRDDAT4;
			if (bootverbose)
				printf("%s: Primary High Byte "
				       "termination Enabled\n",
				       ahc_name(ahc));
		}

		write_brdctl(ahc, brddat);

	} else {
		if ((adapter_control & CFSTERM) != 0) {
			*sxfrctl1 |= STPWEN;

			if (bootverbose)
				printf("%s: %sLow byte termination Enabled\n",
				       ahc_name(ahc),
				       (ahc->features & AHC_ULTRA2)
				       ? "Primary " : "");
		}

		if ((adapter_control & CFWSTERM) != 0) {
			brddat |= BRDDAT6;
			if (bootverbose)
				printf("%s: %sHigh byte termination Enabled\n",
				       ahc_name(ahc),
				       (ahc->features & AHC_ULTRA2)
				       ? "Secondary " : "");
		}

		/*
		 * Setup STPWEN before setting up the rest of
		 * the termination per the tech note on the U160 cards.
		 */
		ahc_outb(ahc, SXFRCTL1, *sxfrctl1);

		write_brdctl(ahc, brddat);
	}
	SEEPROM_OUTB(sd, sd->sd_MS); /* Clear CS */
}

static void
ahc_new_term_detect(ahc, enableSEC_low, enableSEC_high, enablePRI_low, 
		    enablePRI_high, eeprom_present)
struct ahc_softc *ahc;
int *enableSEC_low;
int *enableSEC_high;
int *enablePRI_low;
int *enablePRI_high;
int *eeprom_present;
{
	u_int8_t brdctl;

	/*
	 * BRDDAT7 = Eeprom
	 * BRDDAT6 = Enable Secondary High Byte termination
	 * BRDDAT5 = Enable Secondary Low Byte termination
	 * BRDDAT4 = Enable Primary high byte termination
	 * BRDDAT3 = Enable Primary low byte termination
	 */
	brdctl = read_brdctl(ahc);
	*eeprom_present = brdctl & BRDDAT7;
	*enableSEC_high = (brdctl & BRDDAT6);
	*enableSEC_low = (brdctl & BRDDAT5);
	*enablePRI_high = (brdctl & BRDDAT4);
	*enablePRI_low = (brdctl & BRDDAT3);
}

static void
aic787X_cable_detect(ahc, internal50_present, internal68_present,
		     externalcable_present, eeprom_present)
struct ahc_softc *ahc;
int *internal50_present;
int *internal68_present;
int *externalcable_present;
int *eeprom_present;
{
	u_int8_t brdctl;

	/*
	 * First read the status of our cables.
	 * Set the rom bank to 0 since the
	 * bank setting serves as a multiplexor
	 * for the cable detection logic.
	 * BRDDAT5 controls the bank switch.
	 */
	write_brdctl(ahc, 0);

	/*
	 * Now read the state of the internal
	 * connectors.  BRDDAT6 is INT50 and
	 * BRDDAT7 is INT68.
	 */
	brdctl = read_brdctl(ahc);
	*internal50_present = !(brdctl & BRDDAT6);
	*internal68_present = !(brdctl & BRDDAT7);

	/*
	 * Set the rom bank to 1 and determine
	 * the other signals.
	 */
	write_brdctl(ahc, BRDDAT5);

	/*
	 * Now read the state of the external
	 * connectors.  BRDDAT6 is EXT68 and
	 * BRDDAT7 is EPROMPS.
	 */
	brdctl = read_brdctl(ahc);
	*externalcable_present = !(brdctl & BRDDAT6);
	*eeprom_present = brdctl & BRDDAT7;
}

static void
aic785X_cable_detect(ahc, internal50_present, externalcable_present,
		     eeprom_present)
struct ahc_softc *ahc;
int *internal50_present;
int *externalcable_present;
int *eeprom_present;
{
	u_int8_t brdctl;

	ahc_outb(ahc, BRDCTL, BRDRW|BRDCS);
	ahc_outb(ahc, BRDCTL, 0);
	brdctl = ahc_inb(ahc, BRDCTL);
	*internal50_present = !(brdctl & BRDDAT5);
	*externalcable_present = !(brdctl & BRDDAT6);

	*eeprom_present = (ahc_inb(ahc, SPIOCAP) & EEPROM) != 0;
}

static void
write_brdctl(ahc, value)
struct   ahc_softc *ahc;
u_int8_t value;
{
	u_int8_t brdctl;

	if ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {
		brdctl = BRDSTB;
		if (ahc->channel == 'B')
			brdctl |= BRDCS;
	} else if ((ahc->features & AHC_ULTRA2) != 0) {
		brdctl = 0;
	} else {
		brdctl = BRDSTB|BRDCS;
	}
	ahc_outb(ahc, BRDCTL, brdctl);
	DELAY(20);
	brdctl |= value;
	ahc_outb(ahc, BRDCTL, brdctl);
	DELAY(20);
	if ((ahc->features & AHC_ULTRA2) != 0)
		brdctl |= BRDSTB_ULTRA2;
	else
		brdctl &= ~BRDSTB;
	ahc_outb(ahc, BRDCTL, brdctl);
	DELAY(20);
	if ((ahc->features & AHC_ULTRA2) != 0)
		brdctl = 0;
	else
		brdctl &= ~BRDCS;
	ahc_outb(ahc, BRDCTL, brdctl);
}

static u_int8_t
read_brdctl(ahc)
struct   ahc_softc *ahc;
{
	u_int8_t brdctl;
	u_int8_t value;

	if ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {
		brdctl = BRDRW;
		if (ahc->channel == 'B')
			brdctl |= BRDCS;
	} else if ((ahc->features & AHC_ULTRA2) != 0) {
		brdctl = BRDRW_ULTRA2;
	} else {
		brdctl = BRDRW|BRDCS;
	}
	ahc_outb(ahc, BRDCTL, brdctl);
	DELAY(20);
	value = ahc_inb(ahc, BRDCTL);
	ahc_outb(ahc, BRDCTL, 0);
	return (value);
d717 2
a718 3
acquire_seeprom(ahc, sd)
struct ahc_softc *ahc;
struct seeprom_descriptor *sd;
a721 4
	if ((ahc->features & AHC_SPIOCAP) != 0
		 && (ahc_inb(ahc, SPIOCAP) & SEEPROM) == 0)
		return (0);

d732 2
a733 2
		DELAY(1000);  /* delay 1 msec */
	}
d737 2
a738 2
	}
	return (1);
d743 1
a743 1
struct seeprom_descriptor *sd;
d749 1
a749 51
#define DPE	PCI_STATUS_PARITY_DETECT
#define SSE	PCI_STATUS_SPECIAL_ERROR
#define RMA	PCI_STATUS_MASTER_ABORT
#define RTA	PCI_STATUS_MASTER_TARGET_ABORT
#define STA	PCI_STATUS_TARGET_TARGET_ABORT
#define DPR	PCI_STATUS_PARITY_ERROR

int
ahc_pci_intr(ahc)
struct ahc_softc *ahc;
{
	pcireg_t status1;
	struct ahc_pci_data *pd = ahc->pci_data;
        
	if ((ahc_inb(ahc, ERROR) & PCIERRSTAT) == 0)
                return 0;

	status1 = pci_conf_read(pd->pc, pd->tag, PCI_COMMAND_STATUS_REG);

	if (status1 & DPE) {
		printf("%s: Data Parity Error Detected during address "
				 "or write data phase\n", ahc_name(ahc));
	}
	if (status1 & SSE) {
		printf("%s: Signal System Error Detected\n", ahc_name(ahc));
	}
	if (status1 & RMA) {
		printf("%s: Received a Master Abort\n", ahc_name(ahc));
	}
	if (status1 & RTA) {
		printf("%s: Received a Target Abort\n", ahc_name(ahc));
	}
	if (status1 & STA) {
		printf("%s: Signaled a Target Abort\n", ahc_name(ahc));
	}
	if (status1 & DPR) {
		printf("%s: Data Parity Error has been reported via PERR#\n",
				 ahc_name(ahc));
	}
	if ((status1 & (DPE|SSE|RMA|RTA|STA|DPR)) == 0) {
		printf("%s: Latched PCIERR interrupt with "
				 "no status bits set\n", ahc_name(ahc)); 
	}
	pci_conf_write(pd->pc, pd->tag, PCI_COMMAND_STATUS_REG, status1);

	if (status1 & (DPR|RMA|RTA)) {
		ahc_outb(ahc, CLRINT, CLRPARERR);
	}

        return 1;
}
@


1.12.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.21 2001/01/22 22:36:52 deraadt Exp $	*/
a58 13
/* 
 * XXX memory-mapped is busted on some i386 on-board chips.
 * for i386, we don't even try it.  Also, suppress the damn 
 * PCI bus errors messages on i386.  They are not fatal, and are 
 * usually caused by some other device on the PCI bus.  But some 
 * ahc cards won't work without ACKing them.  So just ACK and go!  
 * XXX- smurph
 */
#ifndef i386
#define AHC_ALLOW_MEMIO
#define AHC_SHOW_PCI_ERRORS
#endif

a163 1
		case PCI_PRODUCT_ADP_2930CU:
d174 1
d181 1
a182 2
		case PCI_PRODUCT_ADP2_2940U2:
		case PCI_PRODUCT_ADP2_2930U2:
d207 5
a315 1
		case PCI_PRODUCT_ADP2_2930U2:
d355 8
d364 2
d367 2
a368 21
	/*
	 * attempt to use memory mapping on hardware that supports it.
	 * e.g powerpc  XXX - smurph
	 *
	 * Note:  If this fails, IO mapping is used.
	 */
	if ((command & PCI_COMMAND_MEM_ENABLE) != 0) {
		pcireg_t memtype;
		memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, AHC_PCI_MEMADDR);
		switch (memtype) {
		case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
		case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
			ioh_valid = (pci_mapreg_map(pa, AHC_PCI_MEMADDR,
				memtype, 0, &iot, &ioh, NULL, NULL) == 0);
			break;
		default:
			ioh_valid = 0;
		}
	}
	
	if (!ioh_valid) /* try to drop back to IO mapping */
d370 2
a371 7
	{
		ioh_valid = (pci_mapreg_map(pa, AHC_PCI_IOADDR,
		    PCI_MAPREG_TYPE_IO, 0, &iot, &ioh, NULL, NULL) == 0);
	}

	if (!ioh_valid) {
		/* Game Over.  Insert coin... */
d431 1
a431 2
		if (bootverbose)
			printf("%s: OptionMode = %x\n", ahc_name(ahc), optionmode);
d445 1
a445 1
		printf(": couldn't map interrupt\n", ahc->sc_dev.dv_xname);
d451 1
a451 1
	    ahc->sc_dev.dv_xname);
d704 1
a704 1
}
d1329 1
a1329 1

d1331 1
a1331 1
		return 0;
a1334 2
/* define AHC_SHOW_PCI_ERRORS to get painful errors on your i386 console */
#ifdef AHC_SHOW_PCI_ERRORS	
a1338 1
#endif
d1365 1
a1365 1
	return 1;
@


1.12.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.12.2.2 2001/05/14 22:25:32 niklas Exp $	*/
d380 1
a380 1
				memtype, 0, &iot, &ioh, NULL, NULL, 0) == 0);
d391 1
a391 1
		    PCI_MAPREG_TYPE_IO, 0, &iot, &ioh, NULL, NULL, 0) == 0);
@


1.12.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.12.2.3 2001/07/04 10:41:51 niklas Exp $	*/
a202 3
		case PCI_PRODUCT_ADP2_AIC7899B:
		case PCI_PRODUCT_ADP2_AIC7899D:
		case PCI_PRODUCT_ADP2_AIC7899F:
a362 1
			break;
d468 3
a470 2
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
@


1.12.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 2
a57 3
#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>
#include <dev/ic/aic7xxx_93cx6.h>
a90 3
#define	EXROMBADR		0x30
#define 	EXROMEN		0x00000001ul	/* External Rom Enable */

d92 13
a104 14
#define		SCBSIZE32	0x00010000ul	/* aic789X only */
#define		REXTVALID	0x00001000ul	/* ultra cards only */
#define		MPORTMODE	0x00000400ul	/* aic7870+ only */
#define		RAMPSM		0x00000200ul	/* aic7870+ only */
#define		VOLSENSE	0x00000100ul
#define		PCI64BIT	0x00000080ul	/* 64Bit PCI bus (Ultra2 Only)*/
#define		SCBRAMSEL	0x00000080ul
#define		MRDCEN		0x00000040ul
#define		EXTSCBTIME	0x00000020ul	/* aic7870 only */
#define		EXTSCBPEN	0x00000010ul	/* aic7870 only */
#define		BERREN		0x00000008ul
#define		DACEN		0x00000004ul
#define		STPWLEVEL	0x00000002ul
#define		DIFACTNEGEN	0x00000001ul	/* aic7870 only */
d110 1
d112 2
a113 2
static void ahc_scbram_config __P((struct ahc_softc *ahc, int enable,
				   int pcheck, int fast, int large));
a137 2
int ahc_do_pci_config __P((struct ahc_softc *ahc));

d153 6
d222 20
a241 2
	pcireg_t devconfig;
	pcireg_t command;
d243 2
a244 2
	/* setup the PCI stuff */
	ahc->dev_softc = pa;
a245 15
	/* 
	 * We really don't allocate our softc, but 
	 * we need to do the initialization. And this 
	 * also allocates the platform_data structure.
	 */
	ahc_alloc(ahc, NULL);
	ahc_set_name(ahc, ahc->sc_dev.dv_xname);
	ahc_set_unit(ahc, ahc->sc_dev.dv_unit);
	
	/* set dma tags */
	ahc->parent_dmat = pa->pa_dmat;
	ahc->buffer_dmat = pa->pa_dmat;
        ahc->shared_data_dmat = pa->pa_dmat;
	
	/* card specific setup */
d250 17
a266 7
			ahc->channel = pa->pa_function == 1 ? 'B' : 'A';
			/* The 'C' revision of the aic7895 
			   has a few additional features */
			if (PCI_REVISION(pa->pa_class) >= 4){
				ahc->chip |= AHC_AIC7895C;
			} else {
				ahc->chip |= AHC_AIC7895;
d269 1
a269 1
		case PCI_PRODUCT_ADP_3940U:
d272 2
a273 1
				ahc->chip |= AHC_AIC7880;
d275 2
a276 1
				ahc->chip |= AHC_AIC7870;
d281 1
a281 1
				ahc->channel = 'B';
d284 3
a286 4
			ahc->flags |= AHC_INT50_SPEEDFLEX;
			/* fall through */
		case PCI_PRODUCT_ADP_AIC7880:
		case PCI_PRODUCT_ADP_398XU:	/* XXX */
d289 2
a290 1
			ahc->chip |= AHC_AIC7880;
a291 1
		case PCI_PRODUCT_ADP_AIC7870:
d294 15
a308 1
			ahc->chip |= AHC_AIC7870;
d311 2
a312 2
		case PCI_PRODUCT_ADP_2940AU:
			ahc->chip |= AHC_AIC7860;
d316 2
a317 1
			ahc->chip |= AHC_AIC7850;
d329 3
a331 1
			ahc->chip |= AHC_AIC7890;
d336 3
a338 1
			ahc->chip |= AHC_AIC7892;
d343 14
a356 8
			ahc->chip |= AHC_AIC7896;
			ahc->channel = pa->pa_function == 1 ? 'B' : 'A';
			devconfig = ahc_pci_read_config(ahc->dev_softc, 
						  DEVCONFIG, 4);
			/* turn off 64 bit for now XXX smurph */
			devconfig &= ~PCI64BIT;
			ahc_pci_write_config(ahc->dev_softc, 
				       DEVCONFIG, devconfig, 4);
d360 3
a362 2
			ahc->chip |= AHC_AIC7899;
			ahc->channel = pa->pa_function == 1 ? 'B' : 'A';
a368 98
	
	/* chip specific setup */
	switch(ahc->chip){
	case AHC_AIC7850:
	case AHC_AIC7855:
	case AHC_AIC7859:
		ahc->features = AHC_AIC7850_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		if (PCI_REVISION(pa->pa_class) >= 1)
			ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
		break;
	case AHC_AIC7860:
		ahc->features = AHC_AIC7860_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		if (PCI_REVISION(pa->pa_class) >= 1)
			ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
		break;
	case AHC_AIC7870:
		ahc->features = AHC_AIC7870_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		break;
	case AHC_AIC7880:
		ahc->features = AHC_AIC7880_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
		if (PCI_REVISION(pa->pa_class) >= 1) {
			ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
		} else {
			ahc->bugs |= AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		}
		break;
	case AHC_AIC7895:
		ahc->features = AHC_AIC7895_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		/*
		 * The BIOS disables the use of MWI transactions
		 * since it does not have the MWI bug work around
		 * we have.  Disabling MWI reduces performance, so
		 * turn it on again.
		 */
		command = pci_conf_read(pa->pa_pc, pa->pa_tag,
					PCI_COMMAND_STATUS_REG);
		command |= PCI_COMMAND_INVALIDATE_ENABLE;
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
			       command);
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_PCI_2_1_RETRY_BUG
			  |  AHC_CACHETHEN_BUG | AHC_PCI_MWI_BUG;
		break;		
	case AHC_AIC7895C:
		ahc->features = AHC_AIC7895C_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_PCI_2_1_RETRY_BUG
			  |  AHC_CACHETHEN_BUG;
		break;
	case AHC_AIC7890:
		ahc->features = AHC_AIC7890_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		if (PCI_REVISION(pa->pa_class) == 0)
			ahc->bugs |= AHC_AUTOFLUSH_BUG|AHC_CACHETHEN_BUG;
		break;
	case AHC_AIC7892:
		ahc->features = AHC_AIC7892_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;
		break;
	case AHC_AIC7896:
		ahc->features = AHC_AIC7896_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_CACHETHEN_DIS_BUG;
		break;
	case AHC_AIC7899:
		ahc->features = AHC_AIC7899_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;
		break;
	default:
		break;
	}

	/* setup the PCI interrupt */
	ahc->platform_data->pci_intr_func = ahc_pci_intr;
	
	if(ahc_do_pci_config(ahc)){
		ahc_free(ahc);
		return;
	}
	
	ahc_attach(ahc);
}

int
ahc_pci_map_registers(ahc)
	struct ahc_softc *ahc;
{
	pcireg_t	command;
	int		ioh_valid;
	bus_space_tag_t  iot;
	bus_space_handle_t ioh;
	struct pci_attach_args *pa = ahc->dev_softc;
a369 2
	command = ahc_pci_read_config(ahc->dev_softc,
				      PCI_COMMAND_STATUS_REG, 4);
a388 16
		if (ioh_valid) {
			/*
			 * Do a quick test to see if memory mapped
			 * I/O is functioning correctly.
			 */
			if (ahc_inb(ahc, HCNTRL) == 0xFF) {
				/* nope, use I/O mapping */
                                ioh_valid = 0;
			} else {
				/* Using memory mapping, disable I/O mapping */
                                command &= ~PCI_COMMAND_IO_ENABLE;
				ahc_pci_write_config(ahc->dev_softc,
						     PCI_COMMAND_STATUS_REG,
						     command, 4);
			}
		}
a395 6
		
		/* Using I/O mapping, disable memory mapping */
		command &= ~PCI_COMMAND_MEM_ENABLE;
		ahc_pci_write_config(ahc->dev_softc,
				     PCI_COMMAND_STATUS_REG,
				     command, 4);
d401 11
a411 1
		return (1);
a412 4
	ahc->tag = iot;
	ahc->bsh = ioh;
	return (0);
}
d414 3
a416 24
int
ahc_do_pci_config(ahc)
	struct ahc_softc *ahc;
{
	pcireg_t	 command;
	u_int		 our_id = 0;
	u_int		 sxfrctl1;
	u_int		 scsiseq;
	u_int		 dscommand0;
	int		 error;
	int		 opri;
	uint8_t		 sblkctl;

	error = ahc_pci_map_registers(ahc);
	if (error != 0)
		return (error);
	/* 
	 * Registers are mapped. Now it is safe to use 
	 * the ahc_inb and ahc_outb macros. 
	 */
	ahc->chip |= AHC_PCI; /* we are a PCI controller */
#if 0
	ahc_power_state_change(ahc, AHC_POWER_STATE_D0);
#endif 
d418 3
a420 8
	/*
	 * If we need to support high memory, enable dual
	 * address cycles.  This bit must be set to enable
	 * high address bit generation even if we are on a
	 * 64bit bus (PCI64BIT set in devconfig).
	 */
	if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
		pcireg_t devconfig;
a421 11
		if (bootverbose)
			printf("%s: Enabling 39Bit Addressing\n",
			       ahc_name(ahc));
		devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
		devconfig |= DACEN;
		ahc_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig, 4);
	}
	
	/* Ensure busmastering is enabled */
        command = ahc_pci_read_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, 4);
	command |= PCI_COMMAND_MASTER_ENABLE; 
a422 2
	ahc_pci_write_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, command, 4);
	
d424 1
a424 1
	ahc->flags |= AHC_PAGESCBS;
d426 2
a427 3
	error = ahc_softc_init(ahc);
	if (error != 0)
		return (error);
d429 3
d433 12
a444 12
	if ((ahc_inb(ahc, HCNTRL) & POWRDN) == 0) {
		ahc_pause(ahc);
		if ((ahc->features & AHC_ULTRA2) != 0)
			our_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;
		else
			our_id = ahc_inb(ahc, SCSIID) & OID;
		sxfrctl1 = ahc_inb(ahc, SXFRCTL1) & STPWEN;
		scsiseq = ahc_inb(ahc, SCSISEQ);
	} else {
		sxfrctl1 = STPWEN;
		our_id = 7;
		scsiseq = 0;
d446 5
a450 5

	error = ahc_reset(ahc);
	if (error != 0)
		return (ENXIO);

d452 1
d458 7
a464 2
		ahc_outb(ahc, OPTIONMODE,
			 OPTIONMODE_DEFAULTS|AUTOACKEN|BUSFREEREV|EXPPHASEDIS);
d469 1
a469 1
					  |TARGCRCENDEN);
d472 20
a496 11
	
	dscommand0 = ahc_inb(ahc, DSCOMMAND0);
	dscommand0 |= MPARCKEN|CACHETHEN;
	if ((ahc->features & AHC_ULTRA2) != 0) {

		/*
		 * DPARCKEN doesn't work correctly on
		 * some MBs so don't use it.
		 */
		dscommand0 &= ~DPARCKEN;
	}
d499 1
a499 2
	 * Handle chips that must have cache line
	 * streaming (dis/en)abled.
d501 3
a503 2
	if ((ahc->bugs & AHC_CACHETHEN_DIS_BUG) != 0)
		dscommand0 |= CACHETHEN;
d505 3
a507 2
	if ((ahc->bugs & AHC_CACHETHEN_BUG) != 0)
		dscommand0 &= ~CACHETHEN;
d509 7
a515 14
	ahc_outb(ahc, DSCOMMAND0, dscommand0);
	
	ahc->pci_cachesize = ahc_pci_read_config(ahc->dev_softc,
						 CSIZE_LATTIME, 4) & CACHESIZE;
	ahc->pci_cachesize *= 4;

	if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0
	 && ahc->pci_cachesize == 4) {
		u_int csl = ahc_pci_read_config(ahc->dev_softc,
						CSIZE_LATTIME, 4);
		csl &= ~CACHESIZE;
		ahc_pci_write_config(ahc->dev_softc, CSIZE_LATTIME, csl, 4);
		ahc->pci_cachesize = 0;
	}
d517 1
a517 11
	/*
	 * We cannot perform ULTRA speeds without the presense
	 * of the external precision resistor.
	 */
	if ((ahc->features & AHC_ULTRA) != 0) {
		uint32_t devconfig;

		devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
		if ((devconfig & REXTVALID) == 0)
			ahc->features &= ~AHC_ULTRA;
	}
d519 2
a520 2
	/* See if we have a SEEPROM and perform auto-term */
	check_extport(ahc, &sxfrctl1);
d522 5
a526 11
	/*
	 * Take the LED out of diagnostic mode
	 */
	sblkctl = ahc_inb(ahc, SBLKCTL);
	ahc_outb(ahc, SBLKCTL, (sblkctl & ~(DIAGLEDEN|DIAGLEDON)));

	if ((ahc->features & AHC_ULTRA2) != 0) {
		ahc_outb(ahc, DFF_THRSH, RD_DFTHRSH_MAX|WR_DFTHRSH_MAX);
	} else {
		ahc_outb(ahc, DSPCISTATUS, DFTHRSH_100);
	}
a527 1
	if (ahc->flags & AHC_USEDEFAULTS) {
d529 3
a531 3
		 * PCI Adapter default setup
		 * Should only be used if the adapter does not have
		 * a SEEPROM.
d533 2
a534 6
		/* See if someone else set us up already */
		if (scsiseq != 0) {
			printf("%s: Using left over BIOS settings\n",
				ahc_name(ahc));
			ahc->flags &= ~AHC_USEDEFAULTS;
			ahc->flags |= AHC_BIOS_ENABLED;
d536 4
d541 3
a543 2
			 * Assume only one connector and always turn
			 * on termination.
d545 16
a560 2
 			our_id = 0x07;
			sxfrctl1 = STPWEN;
a561 3
		ahc_outb(ahc, SCSICONF, our_id|ENSPCHK|RESET_SCSI);

		ahc->our_id = our_id;
d571 2
d580 5
a584 21
	/* Core initialization */
	error = ahc_init(ahc);
	if (error != 0)
		return (error);

	/* Special func to force negotiation */
	ahc_force_neg(ahc);

	/*
	 * Link this softc in with all other ahc instances.
	 */
	ahc_softc_insert(ahc);

	/*
	 * Allow interrupts now that we are completely setup.
	 */
	error = ahc_pci_map_int(ahc);
	if (error != 0)
		return (error);

	ahc_intr_enable(ahc, TRUE);
d587 1
a587 32
	return (0);
}

int
ahc_pci_map_int(ahc)
	struct ahc_softc *ahc;
{
	const char *intrstr = NULL;
	pci_intr_handle_t ih;
	struct pci_attach_args *pa = ahc->dev_softc;
	
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		return 1;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	
	ahc->platform_data->ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO,
						    ahc_platform_intr, ahc,
						    ahc->sc_dev.dv_xname);
	
	if (ahc->platform_data->ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return 1;
	}
	
	if (intrstr != NULL)
		printf(": %s\n", intrstr);
	return 0;
d595 2
a596 1
ahc_ext_scbram_present(struct ahc_softc *ahc)
a597 1
	u_int chip;
d600 2
a601 5
	uint32_t devconfig;
	
	chip = ahc->chip & AHC_CHIPID_MASK;
	
	devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
d603 1
d608 1
a608 1
	else if (chip >= AHC_AIC7870)
d611 1
a611 1
		ramps = 0;
d622 5
a626 6
ahc_scbram_config(ahc, enable, pcheck, fast, large)
	struct ahc_softc *ahc;
	int enable;
	int pcheck;
	int fast;
	int large;
d629 1
d632 1
d637 2
a638 1
		ahc_outb(ahc, SCBBADDR, ahc_get_pci_function(ahc->dev_softc));
d641 2
a642 1
	devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
a650 4
		if (large)
			dscommand0 &= ~USCBSIZE32;
		else
			dscommand0 |= USCBSIZE32;
a660 4
		if (large)
			devconfig &= ~SCBSIZE32;
		else
			devconfig |= SCBSIZE32;
d667 1
a667 1
	ahc_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig, 4);
d677 1
a677 1
	struct ahc_softc *ahc;
a683 1
	int large;
a684 6
	enable = FALSE;
	pcheck = FALSE;
	fast = FALSE;
	large = FALSE;
	num_scbs = 0;
	
d686 1
a686 1
		goto done;
d691 4
a694 1
	ahc_scbram_config(ahc, /*enable*/TRUE, pcheck, fast, large);
d700 1
a700 10
	enable = TRUE;

	/*
	 * Clear any outstanding parity error
	 * and ensure that parity error reporting
	 * is enabled.
	 */
	ahc_outb(ahc, SEQCTL, 0);
	ahc_outb(ahc, CLRINT, CLRPARERR);
	ahc_outb(ahc, CLRINT, CLRBRKADRINT);
d703 1
a703 1
	ahc_scbram_config(ahc, enable, /*pcheck*/TRUE, fast, large);
d706 2
a707 2
	 || (ahc_inb(ahc, ERROR) & MPARERR) == 0)
		pcheck = TRUE;
d714 1
a714 1
	ahc_scbram_config(ahc, enable, pcheck, /*fast*/TRUE, large);
d717 3
a719 3
	 && ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0
	  || (ahc_inb(ahc, ERROR) & MPARERR) == 0))
		fast = TRUE;
d721 2
a722 28
	/*
	 * See if we can use large SCBs and still maintain
	 * the same overall count of SCBs.
	 */
	if ((ahc->features & AHC_LARGE_SCBS) != 0) {
		ahc_scbram_config(ahc, enable, pcheck, fast, /*large*/TRUE);
		test_num_scbs = ahc_probe_scbs(ahc);
		if (test_num_scbs >= num_scbs) {
			large = TRUE;
			num_scbs = test_num_scbs;
	 		if (num_scbs >= 64) {
				/*
				 * We have enough space to move the
				 * "busy targets table" into SCB space
				 * and make it qualify all the way to the
				 * lun level.
				 */
				ahc->flags |= AHC_SCB_BTT;
			}
		}
	}
done:
	/*
	 * Disable parity error reporting until we
	 * can load instruction ram.
	 */
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS);
	/* Clear any latched parity error */
d726 4
a729 4
		printf("%s: External SRAM, %s access%s, %dbytes/SCB\n",
		       ahc_name(ahc), fast ? "fast" : "slow", 
		       pcheck ? ", parity checking enabled" : "",
		       large ? 64 : 32);
d731 1
a731 1
	ahc_scbram_config(ahc, enable, pcheck, fast, large);
d740 2
a741 2
	struct ahc_softc *ahc;
	u_int *sxfrctl1;
d743 12
a754 11
	struct	seeprom_descriptor sd;
	struct	seeprom_config sc;
	u_int	scsi_conf;
	u_int	adapter_control;
	int	have_seeprom;
	int	have_autoterm;
	
	sd.sd_ahc = ahc;
	sd.sd_control_offset = SEECTL;		
	sd.sd_status_offset = SEECTL;		
	sd.sd_dataout_offset = SEECTL;		
d777 1
a777 1
		if (bootverbose) 
d781 1
a781 1
			u_int start_addr;
d785 21
a805 9
			have_seeprom = read_seeprom(&sd, (uint16_t *)&sc,
						    start_addr, sizeof(sc)/2);

			if (have_seeprom)
				have_seeprom = verify_cksum(&sc);

			if (have_seeprom != 0 || sd.sd_chip == C56_66) {
				if (bootverbose) {
					if (have_seeprom == 0)
d807 5
a811 2
					else
						printf ("done.\n");
d813 3
a816 1
			}
a818 30
		release_seeprom(&sd);
	}

	if (!have_seeprom) {
		/*
		 * Pull scratch ram settings and treat them as
		 * if they are the contents of an seeprom if
		 * the 'ADPT' signature is found in SCB2.
		 * We manually compose the data as 16bit values
		 * to avoid endian issues.
		 */
		ahc_outb(ahc, SCBPTR, 2);
		if (ahc_inb(ahc, SCB_BASE) == 'A'
		 && ahc_inb(ahc, SCB_BASE + 1) == 'D'
		 && ahc_inb(ahc, SCB_BASE + 2) == 'P'
		 && ahc_inb(ahc, SCB_BASE + 3) == 'T') {
			uint16_t *sc_data;
			int	  i;

			sc_data = (uint16_t *)&sc;
			for (i = 0; i < 32; i++) {
				uint16_t val;
				int	 j;

				j = i * 2;
				val = ahc_inb(ahc, SRAM_BASE + j)
				    | ahc_inb(ahc, SRAM_BASE + j + 1) << 8;
			}
			have_seeprom = verify_cksum(&sc);
		}
d832 2
a833 2
		uint16_t discenable;
		uint16_t ultraenb;
d843 1
a843 1
				if ((sc.device_flags[i] & CFSYNCHISULTRA) != 0){
d852 1
a852 1
			uint16_t target_mask;
d864 1
a864 1
			 && (ultraenb & target_mask) != 0) {
d867 1
a867 1
			 	ultraenb &= ~target_mask;
d874 1
a874 1
				else 
a877 5
				/*
				 * The ultra enable bits contain the
				 * high bit of the ultra2 sync rate
				 * field.
				 */
d879 1
a879 2
					 | ((ultraenb & target_mask)
					    ? 0x8 : 0x0);
a898 3
		ahc->flags |=
		    (sc.adapter_control & CFBOOTCHAN) >> CFBOOTCHANSHIFT;

a900 3

		if (sc.bios_control & CFBIOSEN)
			ahc->flags |= AHC_BIOS_ENABLED;
d902 1
a902 1
		 && (ahc->flags & AHC_NEWEEPROM_FMT) == 0) {
a907 14

		if (sc.signature == CFSIGNATURE
		 || sc.signature == CFSIGNATURE2) {
			pcireg_t devconfig;

			/* Honor the STPWLEVEL settings */
			devconfig = ahc_pci_read_config(ahc->dev_softc, 
							DEVCONFIG, 4);
			devconfig &= ~STPWLEVEL;
			if ((sc.bios_control & CFSTPWLEVEL) != 0)
				devconfig |= STPWLEVEL;
			ahc_pci_write_config(ahc->dev_softc,
					     DEVCONFIG, devconfig, 4);
		}
d935 1
a935 1
			have_autoterm = TRUE;
d937 1
a937 1
			have_autoterm = FALSE;
d940 1
a940 2
	if (have_autoterm) {
		acquire_seeprom(ahc, &sd);
d942 2
a943 2
		release_seeprom(&sd);
	}
d947 5
a951 4
configure_termination(struct ahc_softc *ahc,
		      struct seeprom_descriptor *sd,
		      u_int adapter_control,
		      u_int *sxfrctl1)
d953 2
a954 2
	uint8_t brddat;
	
d962 1
a962 1
	
d970 1
a970 1
	 || (ahc->features & AHC_NEW_TERMCTL) != 0) {
a978 1
		int sum;
d986 4
a989 4
					       &enableSEC_high,
					       &enablePRI_low,
					       &enablePRI_high,
					       &eeprom_present);
d993 3
a995 4
					       ahc_name(ahc));
				enableSEC_low = (adapter_control & CFSELOWTERM);
				enableSEC_high =
				    (adapter_control & CFSEHIGHTERM);
d1001 2
a1002 2
				enablePRI_low = (adapter_control & CFSTERM);
				enablePRI_high = (adapter_control & CFWSTERM);
d1022 7
a1028 5
		if (bootverbose
		 && (ahc->features & AHC_ULTRA2) == 0) {
			printf("%s: internal 50 cable %s present",
			       ahc_name(ahc),
			       internal50_present ? "is":"not");
d1030 4
a1033 8
			if ((ahc->features & AHC_WIDE) != 0)
				printf(", internal 68 cable %s present",
				       internal68_present ? "is":"not");
			printf("\n%s: external cable %s present\n",
			       ahc_name(ahc),
			       externalcable_present ? "is":"not");
		}
		if (bootverbose)
d1036 1
d1058 3
a1060 3
		 && (internal50_present != 0)
		 && (internal68_present != 0)
		 && (externalcable_present != 0)) {
d1068 3
a1070 3
		 && ((externalcable_present == 0)
		  || (internal68_present == 0)
		  || (enableSEC_high != 0))) {
d1080 1
a1080 1
							      : "");
d1084 4
a1087 3
		sum = internal50_present + internal68_present
		    + externalcable_present;
		if (sum < 2 || (enableSEC_low != 0)) {
d1100 1
a1100 1
							     : "");
d1124 1
a1124 1
		
d1134 2
a1135 2
				       (ahc->features & AHC_ULTRA2) ? "Primary "
								    : "");
d1138 1
a1138 2
		if ((adapter_control & CFWSTERM) != 0
		 && (ahc->features & AHC_WIDE) != 0) {
d1144 1
a1144 1
				     ? "Secondary " : "");
d1153 1
a1153 2
		if ((ahc->features & AHC_WIDE) != 0)
			write_brdctl(ahc, brddat);
d1161 6
a1166 6
	struct ahc_softc *ahc;
	int *enableSEC_low;
	int *enableSEC_high;
	int *enablePRI_low;
	int *enablePRI_high;
	int *eeprom_present;
d1188 5
a1192 5
	struct ahc_softc *ahc;
	int *internal50_present;
	int *internal68_present;
	int *externalcable_present;
	int *eeprom_present;
d1211 2
a1212 2
	*internal50_present = (brdctl & BRDDAT6) ? 0 : 1;
	*internal68_present = (brdctl & BRDDAT7) ? 0 : 1;
d1226 2
a1227 2
	*externalcable_present = (brdctl & BRDDAT6) ? 0 : 1;
	*eeprom_present = (brdctl & BRDDAT7) ? 1 : 0;
d1233 4
a1236 4
	struct ahc_softc *ahc;
	int *internal50_present;
	int *externalcable_present;
	int *eeprom_present;
d1243 2
a1244 2
	*internal50_present = (brdctl & BRDDAT5) ? 0 : 1;
	*externalcable_present = (brdctl & BRDDAT6) ? 0 : 1;
d1246 1
a1246 1
	*eeprom_present = (ahc_inb(ahc, SPIOCAP) & EEPROM) ? 1 : 0;
d1251 2
a1252 2
	struct   ahc_softc *ahc;
	u_int8_t value;
d1266 1
a1266 1
	ahc_flush_device_writes(ahc);
d1269 1
a1269 1
	ahc_flush_device_writes(ahc);
d1275 1
a1275 1
	ahc_flush_device_writes(ahc);
d1285 1
a1285 1
	struct   ahc_softc *ahc;
d1300 1
a1300 1
	ahc_flush_device_writes(ahc);
d1308 2
a1309 2
	struct ahc_softc *ahc;
	struct seeprom_descriptor *sd;
d1338 1
a1338 1
	struct seeprom_descriptor *sd;
a1350 7
#define PCIDEBUG
#ifdef	PCIDEBUG
#define	PCI_PRINT(Printstuff) printf Printstuff
#else
#define	PCI_PRINT(Printstuff)
#endif

d1353 1
a1353 1
	struct ahc_softc *ahc;
d1356 1
d1360 2
a1361 5
  	PCI_PRINT(("%s: PCI error Interrupt at seqaddr = 0x%x\n",
		   ahc_name(ahc), 
		   ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8)));
 
	status1 = ahc_pci_read_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, 4);
d1364 1
a1364 1
#ifdef AHC_SHOW_PCI_ERRORS
d1366 2
a1367 2
		PCI_PRINT(("%s: Data Parity Error Detected during address "
			   "or write data phase\n", ahc_name(ahc)));
d1371 1
a1371 1
		PCI_PRINT(("%s: Signal System Error Detected\n", ahc_name(ahc)));
d1374 1
a1374 1
		PCI_PRINT(("%s: Received a Master Abort\n", ahc_name(ahc)));
d1377 1
a1377 1
		PCI_PRINT(("%s: Received a Target Abort\n", ahc_name(ahc)));
d1380 1
a1380 1
		PCI_PRINT(("%s: Signaled a Target Abort\n", ahc_name(ahc)));
d1383 2
a1384 2
		PCI_PRINT(("%s: Data Parity Error has been reported via PERR#\n",
			   ahc_name(ahc)));
a1385 3
	
	ahc_pci_write_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, status1, 4);

d1388 5
a1392 2
		       "no status bits set\n", ahc_name(ahc)); 
	} else {
a1394 2
	
	ahc_unpause(ahc);
@


1.12.2.6
log
@Merge in -current from roughly a week ago
@
text
@d56 3
a58 2
#include <dev/ic/aic7xxxvar.h>
#include <dev/ic/smc93cx6var.h>
d92 3
d96 14
a109 13
#define		SCBSIZE32	0x00010000UL	/* aic789X only */
#define		MPORTMODE	0x00000400UL	/* aic7870 only */
#define		RAMPSM		0x00000200UL	/* aic7870 only */
#define		VOLSENSE	0x00000100UL
#define		SCBRAMSEL	0x00000080UL
#define		PCI64		0x00000080UL	/* aic7891 & aic7897 only */
#define		MRDCEN		0x00000040UL
#define		EXTSCBTIME	0x00000020UL	/* aic7870 only */
#define		EXTSCBPEN	0x00000010UL	/* aic7870 & aic7890 only */
#define		BERREN		0x00000008UL
#define		DACEN		0x00000004UL
#define		STPWLEVEL	0x00000002UL
#define		DIFACTNEGEN	0x00000001UL	/* aic7870 only */
d115 34
a148 33
int	    ahc_pci_intr(struct ahc_softc *ahc);
static int  ahc_ext_scbram_present(struct ahc_softc *ahc);
static void ahc_ext_scbram_config(struct ahc_softc *ahc, int enable,
				  int pcheck, int fast);
static void ahc_probe_ext_scbram(struct ahc_softc *ahc);
static void check_extport(struct ahc_softc *ahc, u_int *sxfrctl1);
static void configure_termination(struct ahc_softc *ahc,
				  struct seeprom_descriptor *sd,
				  u_int adapter_control,
				  u_int *sxfrctl1);
static void ahc_new_term_detect(struct ahc_softc *ahc,
				int *enableSEC_low,
				int *enableSEC_high,
				int *enablePRI_low,
				int *enablePRI_high,
				int *eeprom_present);
static void aic787X_cable_detect(struct ahc_softc *ahc,
				 int *internal50_present,
				 int *internal68_present,
				 int *externalcable_present,
				 int *eeprom_present);
static void aic785X_cable_detect(struct ahc_softc *ahc,
				 int *internal50_present,
				 int *externalcable_present,
				 int *eeprom_present);
static void write_brdctl(struct ahc_softc *ahc, u_int8_t value);
static u_int8_t read_brdctl(struct ahc_softc *ahc);

void load_seeprom(struct ahc_softc *ahc);
static int acquire_seeprom(struct ahc_softc *ahc,
			   struct seeprom_descriptor *sd);
static void release_seeprom(struct seeprom_descriptor *sd);
int ahc_probe_scbs(struct ahc_softc *ahc);
d152 2
a153 2
int ahc_pci_probe(struct device *, void *, void *);
void ahc_pci_attach(struct device *, struct device *, void *);
a158 6
struct ahc_pci_data {
	pci_chipset_tag_t pc;
	pcitag_t tag;
	u_int function;
};

d222 5
a226 18
	bus_space_tag_t  iot;
	bus_space_handle_t ioh;
	pci_intr_handle_t ih;
	pcireg_t	   command;
	const char *intrstr;
	unsigned opri = 0;
	ahc_chip ahc_c = AHC_PCI; /* we are a PCI controller */
	ahc_flag ahc_flags = AHC_FNONE;
	ahc_feature ahc_f = AHC_FENONE;
	int	ioh_valid;

	u_char ultra_enb = 0;
	u_char our_id = 0;
	u_char channel = 'A';
	u_int    sxfrctl1;
	u_int    scsiseq;
	/* So we can access PCI configuration space after init */
	struct ahc_pci_data *pd;
d228 13
a240 1
	ahc->sc_dmat = pa->pa_dmat;
d242 1
a242 3
	command = pci_conf_read(pa->pa_pc, pa->pa_tag,
				PCI_COMMAND_STATUS_REG);

d247 7
a253 17
			{
				pcireg_t devconfig;
				channel = pa->pa_function == 1 ? 'B' : 'A';
				ahc_c |= AHC_AIC7895;
				/* The 'C' revision of the aic7895 
				   has a few additional features */
				if (PCI_REVISION(pa->pa_class) >= 4)
					ahc_f = AHC_AIC7895C_FE;
				else
					ahc_f = AHC_AIC7895_FE;
				ahc_flags |= AHC_NEWEEPROM_FMT;
				devconfig = pci_conf_read(pa->pa_pc, 
							  pa->pa_tag,
							  DEVCONFIG);
				devconfig &= ~SCBSIZE32;
				pci_conf_write(pa->pa_pc, pa->pa_tag,
					       DEVCONFIG, devconfig);
d256 1
a256 1
	   case PCI_PRODUCT_ADP_3940U:
d259 1
a259 2
				ahc_c |= AHC_AIC7880;
				ahc_f = AHC_AIC7880_FE;
d261 1
a261 2
				ahc_c |= AHC_AIC7870;
				ahc_f = AHC_AIC7870_FE;
d266 1
a266 1
				channel = 'B';
d269 4
a272 3
			ahc_c |= AHC_AIC7880;
			ahc_f = AHC_AIC7880_FE;
			ahc_f |= AHC_INT50_SPEEDFLEX;
d275 1
a275 2
			ahc_c |= AHC_AIC7880;
			ahc_f = AHC_AIC7880_FE;
d277 1
d280 1
a280 2
			ahc_c |= AHC_AIC7870;
			ahc_f = AHC_AIC7870_FE;
d282 1
d284 1
a284 15
			ahc_c |= AHC_AIC7860;
			ahc_f = AHC_AIC7860_FE;
			break;
		case PCI_PRODUCT_ADP_398XU:	/* XXX */
		case PCI_PRODUCT_ADP_AIC7880:
			ahc_c |= AHC_AIC7880;
			ahc_f = AHC_AIC7880_FE;
			break;
		case PCI_PRODUCT_ADP_AIC7870:
			ahc_c |= AHC_AIC7870;
			ahc_f = AHC_AIC7870_FE;
			break;
		case PCI_PRODUCT_ADP_AIC7860:
			ahc_c |= AHC_AIC7860;
			ahc_f = AHC_AIC7860_FE;
d288 1
a288 2
			ahc_c |= AHC_AIC7850;
			ahc_f = AHC_AIC7850_FE;
d300 1
a300 3
			ahc_c |= AHC_AIC7890;
			ahc_f = AHC_AIC7890_FE;
			ahc_flags |= AHC_NEWEEPROM_FMT;
d305 1
a305 3
			ahc_c |= AHC_AIC7892;
			ahc_f = AHC_AIC7892_FE;
			ahc_flags |= AHC_NEWEEPROM_FMT;
d310 8
a317 14
			{
				pcireg_t devconfig;
				channel = pa->pa_function == 1 ? 'B' : 'A';
				ahc_c |= AHC_AIC7896;
				ahc_f = AHC_AIC7896_FE;
				ahc_flags |= AHC_NEWEEPROM_FMT;
				devconfig = pci_conf_read(pa->pa_pc, 
							  pa->pa_tag, 
							  DEVCONFIG);
				/* turn off 64 bit for now XXX smurph */
				devconfig &= ~PCI64;
				pci_conf_write(pa->pa_pc, pa->pa_tag, 
					       DEVCONFIG, devconfig);
			}
d321 2
a322 3
			ahc_c |= AHC_AIC7899;
			ahc_f = AHC_AIC7899_FE;
			ahc_flags |= AHC_NEWEEPROM_FMT;
d329 98
d428 2
d449 16
d472 6
d483 1
a483 1
		return;
d485 4
a488 4
	
	/* Ensure busmastering is enabled */
	command |= PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
d490 24
a513 5
	pd = malloc(sizeof (struct ahc_pci_data), M_DEVBUF, M_NOWAIT);
	if (pd == NULL) {
		printf(": error allocating pci data\n");
		return;
	}
d515 8
a522 7
	pd->pc = pa->pa_pc;
	pd->tag = pa->pa_tag;
	pd->function = pa->pa_function;

	/* setup the PCI stuff */
	ahc->pci_data = pd;
	ahc->pci_intr_func = ahc_pci_intr;
d524 11
d536 2
d539 1
a539 1
	ahc_flags |= AHC_PAGESCBS;
d541 3
a543 2
	ahc_construct(ahc, pa->pa_iot, ioh, ahc_c, ahc_flags, ahc_f, channel);
	/* Now we can use the ahc_inb and ahc_outb macros */
a544 3
	/* setup the PCI error interrupt handler */
	ahc->pci_intr_func = &ahc_pci_intr;
	
d546 12
a557 12
	ahc_outb(ahc, HCNTRL, ahc->pause);
	if ((ahc->features & AHC_ULTRA2) != 0)
		our_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;
	else
		our_id = ahc_inb(ahc, SCSIID) & OID;
	sxfrctl1 = ahc_inb(ahc, SXFRCTL1) & STPWEN;
	scsiseq = ahc_inb(ahc, SCSISEQ);
	
	if (ahc_reset(ahc) != 0) {
		/* Failed */
		ahc_free(ahc);
		return;
d559 5
a563 5
	
	if (ahc->features & AHC_ULTRA)
		ultra_enb = bus_space_read_1(pa->pa_iot, ioh, SXFRCTL0) &
						FAST20;
	
a564 1
		u_int optionmode;
d570 2
a571 7
		optionmode = ahc_inb(ahc, OPTIONMODE);
		if (bootverbose)
			printf("%s: OptionMode = %x\n", ahc_name(ahc), optionmode);
		ahc_outb(ahc, OPTIONMODE, OPTIONMODE_DEFAULTS);
		/* Send CRC info in target mode every 4K */
		ahc_outb(ahc, TARGCRCCNT, 0);
		ahc_outb(ahc, TARGCRCCNT + 1, 0x10);
d576 1
a576 1
					|TARGCRCENDEN|TARGCRCCNTEN);
a578 20
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		ahc_free(ahc);
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	ahc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, ahc_intr, ahc,
	    ahc->sc_dev.dv_xname);

	if (ahc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		ahc_free(ahc);
		return;
	}
	if (intrstr != NULL)
		printf(": %s\n", intrstr);

d584 11
d597 2
a598 1
	 * Do aic7880/aic7870/aic7860/aic7850 specific initialization
d600 20
a619 3
	{
		u_int8_t sblkctl;
		u_int dscommand0;
d621 6
a626 3
		dscommand0 = ahc_inb(ahc, DSCOMMAND0);
		dscommand0 |= MPARCKEN;
		if ((ahc->features & AHC_ULTRA2) != 0) {
d628 4
a631 7
			/*
			 * DPARCKEN doesn't work correctly on
			 * some MBs so don't use it.
			 */
			dscommand0 &= ~(USCBSIZE32|DPARCKEN);
			dscommand0 |= CACHETHEN;
		}
d633 2
a634 1
		ahc_outb(ahc, DSCOMMAND0, dscommand0);
d636 5
a640 2
		/* See if we have an SEEPROM and perform auto-term */
		check_extport(ahc, &sxfrctl1);
d642 5
a646 5
		/*
		 * Take the LED out of diagnostic mode
		 */
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, (sblkctl & ~(DIAGLEDEN|DIAGLEDON)));
d648 1
d650 3
a652 3
		 * I don't know where this is set in the SEEPROM or by the
		 * BIOS, so we default to 100% on Ultra or slower controllers
		 * and 75% on ULTRA2 controllers.
d654 6
a659 2
		if ((ahc->features & AHC_ULTRA2) != 0) {
			ahc_outb(ahc, DFF_THRSH, RD_DFTHRSH_75|WR_DFTHRSH_75);
a660 4
			ahc_outb(ahc, DSPCISTATUS, DFTHRSH_100);
		}

		if (ahc->flags & AHC_USEDEFAULTS) {
d662 2
a663 3
			 * PCI Adapter default setup
			 * Should only be used if the adapter does not have
			 * an SEEPROM.
d665 4
a668 14
			/* See if someone else set us up already */
			if (scsiseq != 0) {
				printf("%s: Using left over BIOS settings\n",
						 ahc_name(ahc));
				ahc->flags &= ~AHC_USEDEFAULTS;
			} else {
				/*
				 * Assume only one connector and always turn
				 * on termination.
				 */
				our_id = 0x07;
				sxfrctl1 = STPWEN;
			}
			ahc_outb(ahc, SCSICONF, our_id|ENSPCHK|RESET_SCSI);
d670 1
a670 2
			ahc->our_id = our_id;
		}
a679 2
	printf("%s: ", ahc_name(ahc));

d687 21
a707 5
	if (ahc_init(ahc)) {
		ahc_free(ahc);
		splx(opri);
		return; /* XXX PCI code should take return status */
	}
d710 32
a741 1
	ahc_attach(ahc);
d749 1
a749 2
ahc_ext_scbram_present(ahc)
struct ahc_softc *ahc;
d751 1
d754 5
a758 2
	pcireg_t devconfig;
	struct ahc_pci_data *pd = ahc->pci_data;
a759 1
	devconfig = pci_conf_read(pd->pc, pd->tag, DEVCONFIG);
d764 1
a764 1
	else if ((ahc->chip & AHC_CHIPID_MASK) >= AHC_AIC7870)
d767 1
a767 1
		ramps	= 0;
d778 6
a783 5
ahc_ext_scbram_config(ahc, enable, pcheck, fast)
struct ahc_softc *ahc;
int enable;
int pcheck;
int fast;
a785 1
	struct ahc_pci_data *pd = ahc->pci_data;
a787 1
		u_char channel; 
d792 1
a792 2
		channel = pd->function == 1 ? 1 : 0;
		ahc_outb(ahc, SCBBADDR, channel);
d795 1
a795 2
	devconfig = pci_conf_read(pd->pc, pd->tag, DEVCONFIG);
	
d804 4
d818 4
d828 1
a828 1
	pci_conf_write(pd->pc, pd->tag, DEVCONFIG, devconfig);
d838 1
a838 1
struct ahc_softc *ahc;
d845 1
d847 6
d854 1
a854 1
		return;
d859 1
a859 4
	enable = 0;
	pcheck = 0;
	fast = 0;
	ahc_ext_scbram_config(ahc,	/*enable*/1, pcheck, fast);
d865 10
a874 1
	enable = 1;
d877 1
a877 1
	ahc_ext_scbram_config(ahc, enable, /*pcheck*/1, fast);
d880 2
a881 2
		 || (ahc_inb(ahc, ERROR) & MPARERR) == 0)
		pcheck = 1;
d888 1
a888 1
	ahc_ext_scbram_config(ahc, enable, pcheck, /*fast*/1);
d891 3
a893 3
		 && ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0
			  || (ahc_inb(ahc, ERROR) & MPARERR) == 0))
		fast = 1;
d895 28
a922 2
	done:
	/* Clear any resulting parity error */
d926 4
a929 4
		printf("%s: External SRAM, %dns access%s\n",
				 ahc_name(ahc), fast ? 10 : 20,
				 pcheck ? ", parity checking enabled" : "");

d931 1
a931 1
	ahc_ext_scbram_config(ahc, enable, pcheck, fast);
d940 2
a941 2
struct ahc_softc *ahc;
u_int *sxfrctl1;
d943 11
a953 12
	struct     seeprom_descriptor sd;
	struct     seeprom_config sc;
	u_int   scsi_conf;
	u_int   adapter_control;
	int     have_seeprom;
	int     have_autoterm;

	sd.sd_tag = ahc->sc_iot;
	sd.sd_bsh = ahc->sc_ioh;
	sd.sd_control_offset = SEECTL;      
	sd.sd_status_offset = SEECTL;    
	sd.sd_dataout_offset = SEECTL;      
d976 1
a976 1
		if (bootverbose)
d980 1
a980 1
			bus_size_t start_addr;
d984 9
a992 21
			have_seeprom = read_seeprom(&sd,
						    (u_int16_t *)&sc,
						    start_addr,
						    sizeof(sc)/2);

			if (have_seeprom) {
				/* Check checksum */
				int i;
				int maxaddr;
				u_int32_t checksum;
				u_int16_t *scarray;

				maxaddr = (sizeof(sc)/2) - 1;
				checksum = 0;
				scarray = (u_int16_t *)&sc;

				for (i = 0; i < maxaddr; i++)
					checksum = checksum + scarray[i];
				if (checksum == 0
				    || (checksum & 0xFFFF) != sc.checksum) {
					if (bootverbose && sd.sd_chip == C56_66)
d994 2
a995 5
					have_seeprom = 0;
				} else {
					if (bootverbose)
						printf("done.\n");
					break;
d997 1
d999 4
d1004 26
a1029 3
			if (sd.sd_chip == C56_66)
				break;
			sd.sd_chip = C56_66;
d1044 2
a1045 2
		u_int16_t discenable;
		u_int16_t ultraenb;
d1055 1
a1055 1
				if ((sc.device_flags[i] & CFSYNCHISULTRA) != 0) {
d1064 1
a1064 1
			u_int16_t target_mask;
d1076 1
a1076 1
				 && (ultraenb & target_mask) != 0) {
d1079 1
a1079 1
				ultraenb &= ~target_mask;
d1086 1
a1086 1
				else
d1090 5
d1096 2
a1097 1
				| ((ultraenb & target_mask) ? 0x8 : 0x0);
d1117 3
d1122 3
d1126 1
a1126 1
			 && (ahc->flags & AHC_NEWEEPROM_FMT) == 0) {
d1132 14
d1173 1
a1173 1
			have_autoterm = 1;
d1175 1
a1175 1
			have_autoterm = 0;
d1178 2
a1179 1
	if (have_autoterm)
d1181 2
a1182 2

	release_seeprom(&sd);
d1186 4
a1189 5
configure_termination(ahc, sd, adapter_control, sxfrctl1)
struct ahc_softc *ahc;
struct seeprom_descriptor *sd;
u_int adapter_control;
u_int *sxfrctl1;
d1191 2
a1192 2
	u_int8_t brddat;

d1200 1
a1200 1

d1208 1
a1208 1
		 || (ahc->features & AHC_NEW_TERMCTL) != 0) {
d1217 1
d1225 4
a1228 4
					    &enableSEC_high,
					    &enablePRI_low,
					    &enablePRI_high,
					    &eeprom_present);
d1232 4
a1235 3
							 ahc_name(ahc));
				enableSEC_low = (adapter_control & CFSTERM);
				enableSEC_high = (adapter_control & CFWSTERM);
d1241 2
a1242 2
				enablePRI_low = enablePRI_high =
					(adapter_control & CFLVDSTERM);
d1262 8
a1269 6
		if (bootverbose) {
			if ((ahc->features & AHC_ULTRA2) == 0) {
				printf("%s: internal 50 cable %s present, "
				       "internal 68 cable %s present\n",
				       ahc_name(ahc),
				       internal50_present ? "is":"not",
d1271 5
a1275 5

				printf("%s: external cable %s present\n",
				       ahc_name(ahc),
				       externalcable_present ? "is":"not");
			}
a1277 1
		}
d1299 3
a1301 3
		    && (internal50_present != 0)
		    && (internal68_present != 0)
		    && (externalcable_present != 0)) {
d1309 3
a1311 3
			 && ((externalcable_present == 0)
				  || (internal68_present == 0)
				  || (enableSEC_high != 0))) {
d1321 1
a1321 1
					       : "");
d1325 3
a1327 4
		if (((internal50_present ? 1 : 0)
			  + (internal68_present ? 1 : 0)
			  + (externalcable_present ? 1 : 0)) <= 1
			 || (enableSEC_low != 0)) {
d1340 1
a1340 1
					       : "");
d1364 1
a1364 1

d1374 2
a1375 2
				       (ahc->features & AHC_ULTRA2)
				       ? "Primary " : "");
d1378 2
a1379 1
		if ((adapter_control & CFWSTERM) != 0) {
d1385 1
a1385 1
				       ? "Secondary " : "");
d1394 2
a1395 1
		write_brdctl(ahc, brddat);
d1403 6
a1408 6
struct ahc_softc *ahc;
int *enableSEC_low;
int *enableSEC_high;
int *enablePRI_low;
int *enablePRI_high;
int *eeprom_present;
d1430 5
a1434 5
struct ahc_softc *ahc;
int *internal50_present;
int *internal68_present;
int *externalcable_present;
int *eeprom_present;
d1453 2
a1454 2
	*internal50_present = !(brdctl & BRDDAT6);
	*internal68_present = !(brdctl & BRDDAT7);
d1468 2
a1469 2
	*externalcable_present = !(brdctl & BRDDAT6);
	*eeprom_present = brdctl & BRDDAT7;
d1475 4
a1478 4
struct ahc_softc *ahc;
int *internal50_present;
int *externalcable_present;
int *eeprom_present;
d1485 2
a1486 2
	*internal50_present = !(brdctl & BRDDAT5);
	*externalcable_present = !(brdctl & BRDDAT6);
d1488 1
a1488 1
	*eeprom_present = (ahc_inb(ahc, SPIOCAP) & EEPROM) != 0;
d1493 2
a1494 2
struct   ahc_softc *ahc;
u_int8_t value;
d1508 1
a1508 1
	DELAY(20);
d1511 1
a1511 1
	DELAY(20);
d1517 1
a1517 1
	DELAY(20);
d1527 1
a1527 1
struct   ahc_softc *ahc;
d1542 1
a1542 1
	DELAY(20);
d1550 2
a1551 2
struct ahc_softc *ahc;
struct seeprom_descriptor *sd;
d1580 1
a1580 1
struct seeprom_descriptor *sd;
d1593 7
d1602 1
a1602 1
struct ahc_softc *ahc;
a1604 1
	struct ahc_pci_data *pd = ahc->pci_data;
d1608 5
a1612 2

	status1 = pci_conf_read(pd->pc, pd->tag, PCI_COMMAND_STATUS_REG);
d1615 1
a1615 1
#ifdef AHC_SHOW_PCI_ERRORS	
d1617 2
a1618 2
		printf("%s: Data Parity Error Detected during address "
				 "or write data phase\n", ahc_name(ahc));
d1622 1
a1622 1
		printf("%s: Signal System Error Detected\n", ahc_name(ahc));
d1625 1
a1625 1
		printf("%s: Received a Master Abort\n", ahc_name(ahc));
d1628 1
a1628 1
		printf("%s: Received a Target Abort\n", ahc_name(ahc));
d1631 1
a1631 1
		printf("%s: Signaled a Target Abort\n", ahc_name(ahc));
d1634 2
a1635 2
		printf("%s: Data Parity Error has been reported via PERR#\n",
				 ahc_name(ahc));
d1637 3
d1642 2
a1643 5
				 "no status bits set\n", ahc_name(ahc)); 
	}
	pci_conf_write(pd->pc, pd->tag, PCI_COMMAND_STATUS_REG, status1);

	if (status1 & (DPR|RMA|RTA)) {
d1646 2
@


1.12.2.7
log
@Sync the SMP branch with 3.3
@
text
@d56 1
a56 2
#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>
a90 3
#define	EXROMBADR		0x30
#define 	EXROMEN		0x00000001UL	/* External Rom Enable */

d93 2
a94 3
#define		REXTVALID	0x00001000UL	/* ultra cards only */
#define		MPORTMODE	0x00000400UL	/* aic7870+ only */
#define		RAMPSM		0x00000200UL	/* aic7870+ only */
a95 1
#define		PCI64BIT	0x00000080UL	/* 64Bit PCI bus (Ultra2 Only)*/
d97 1
d100 1
a100 1
#define		EXTSCBPEN	0x00000010UL	/* aic7870 only */
d107 2
a108 2
#define		CACHESIZE	0x0000003fUL	/* only 5 bits */
#define		LATTIME		0x0000ff00UL
d110 1
d112 2
a113 2
static void ahc_scbram_config(struct ahc_softc *ahc, int enable,
				  int pcheck, int fast, int large);
a137 2
int ahc_do_pci_config(struct ahc_softc *ahc);

d153 4
a156 35
const struct pci_matchid ahc_pci_devices[] = {
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC7810 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC7850 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC7855 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC5900 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC5905 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC7860 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2940AU },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC7870 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2930CU },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2940 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_3940 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_3985 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2944 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_AIC7880 },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2940U },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_3940U },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_398XU },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2944U },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_2940UWPro },
	{ PCI_VENDOR_ADP, PCI_PRODUCT_ADP_7895 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7890 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_2940U2 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_2930U2 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7892 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_29160 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_19160B },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_3950U2B },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_3950U2D },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7896 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7899B },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7899D },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7899F },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AIC7899 },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_3960D },
d164 49
a212 2
	return (pci_matchbyid((struct pci_attach_args *)aux, ahc_pci_devices,
	    sizeof(ahc_pci_devices)/sizeof(ahc_pci_devices[0])));
d222 18
a239 2
	pcireg_t devconfig;
	pcireg_t command;
d241 4
a244 2
	/* setup the PCI stuff */
	ahc->dev_softc = pa;
a245 15
	/* 
	 * We really don't allocate our softc, but 
	 * we need to do the initialization. And this 
	 * also allocates the platform_data structure.
	 */
	ahc_alloc(ahc, NULL);
	ahc_set_name(ahc, ahc->sc_dev.dv_xname);
	ahc_set_unit(ahc, ahc->sc_dev.dv_unit);
	
	/* set dma tags */
	ahc->parent_dmat = pa->pa_dmat;
	ahc->buffer_dmat = pa->pa_dmat;
        ahc->shared_data_dmat = pa->pa_dmat;
	
	/* card specific setup */
d250 17
a266 7
			ahc->channel = pa->pa_function == 1 ? 'B' : 'A';
			/* The 'C' revision of the aic7895 
			   has a few additional features */
			if (PCI_REVISION(pa->pa_class) >= 4){
				ahc->chip |= AHC_AIC7895C;
			} else {
				ahc->chip |= AHC_AIC7895;
d269 1
a269 1
		case PCI_PRODUCT_ADP_3940U:
d272 2
a273 1
				ahc->chip |= AHC_AIC7880;
d275 2
a276 1
				ahc->chip |= AHC_AIC7870;
d281 1
a281 1
				ahc->channel = 'B';
d284 3
a286 4
			ahc->flags |= AHC_INT50_SPEEDFLEX;
			/* fall through */
		case PCI_PRODUCT_ADP_AIC7880:
		case PCI_PRODUCT_ADP_398XU:	/* XXX */
d289 2
a290 1
			ahc->chip |= AHC_AIC7880;
a291 1
		case PCI_PRODUCT_ADP_AIC7870:
d294 15
a308 1
			ahc->chip |= AHC_AIC7870;
d311 2
a312 2
		case PCI_PRODUCT_ADP_2940AU:
			ahc->chip |= AHC_AIC7860;
d316 2
a317 1
			ahc->chip |= AHC_AIC7850;
d329 3
a331 1
			ahc->chip |= AHC_AIC7890;
d336 3
a338 1
			ahc->chip |= AHC_AIC7892;
d343 14
a356 8
			ahc->chip |= AHC_AIC7896;
			ahc->channel = pa->pa_function == 1 ? 'B' : 'A';
			devconfig = ahc_pci_read_config(ahc->dev_softc, 
						  DEVCONFIG, 4);
			/* turn off 64 bit for now XXX smurph */
			devconfig &= ~PCI64BIT;
			ahc_pci_write_config(ahc->dev_softc, 
				       DEVCONFIG, devconfig, 4);
d360 3
a362 2
			ahc->chip |= AHC_AIC7899;
			ahc->channel = pa->pa_function == 1 ? 'B' : 'A';
a368 89
	
	/* chip specific setup */
	switch(ahc->chip){
	case AHC_AIC7850:
	case AHC_AIC7855:
	case AHC_AIC7859:
		ahc->features = AHC_AIC7850_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		if (PCI_REVISION(pa->pa_class) >= 1)
			ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
		break;
	case AHC_AIC7860:
		ahc->features = AHC_AIC7860_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		if (PCI_REVISION(pa->pa_class) >= 1)
			ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
		break;
	case AHC_AIC7870:
		ahc->features = AHC_AIC7870_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		break;
	case AHC_AIC7880:
		ahc->features = AHC_AIC7880_FE;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
		if (PCI_REVISION(pa->pa_class) >= 1) {
			ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
		} else {
			ahc->bugs |= AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
		}
		break;
	case AHC_AIC7895:
		ahc->features = AHC_AIC7895_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		/*
		 * The BIOS disables the use of MWI transactions
		 * since it does not have the MWI bug work around
		 * we have.  Disabling MWI reduces performance, so
		 * turn it on again.
		 */
		command = pci_conf_read(pa->pa_pc, pa->pa_tag,
					PCI_COMMAND_STATUS_REG);
		command |= PCI_COMMAND_INVALIDATE_ENABLE;
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
			       command);
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_PCI_2_1_RETRY_BUG
			  |  AHC_CACHETHEN_BUG | AHC_PCI_MWI_BUG;
		break;		
	case AHC_AIC7895C:
		ahc->features = AHC_AIC7895C_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_PCI_2_1_RETRY_BUG
			  |  AHC_CACHETHEN_BUG;
		break;
	case AHC_AIC7890:
		ahc->features = AHC_AIC7890_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		if (PCI_REVISION(pa->pa_class) == 0)
			ahc->bugs |= AHC_AUTOFLUSH_BUG|AHC_CACHETHEN_BUG;
		break;
	case AHC_AIC7892:
		ahc->features = AHC_AIC7892_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;
		break;
	case AHC_AIC7896:
		ahc->features = AHC_AIC7896_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_CACHETHEN_DIS_BUG;
		break;
	case AHC_AIC7899:
		ahc->features = AHC_AIC7899_FE;
		ahc->flags |= AHC_NEWEEPROM_FMT;
		ahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;
		break;
	default:
		break;
	}

	/* setup the PCI interrupt */
	ahc->bus_intr = ahc_pci_intr;
	ahc->unsolicited_ints = 0; 

	if(ahc_do_pci_config(ahc)){
		ahc_free(ahc);
		return;
	}
	
	ahc_attach(ahc);
}
a369 12
int
ahc_pci_map_registers(ahc)
	struct ahc_softc *ahc;
{
	pcireg_t	command;
	int		ioh_valid;
	bus_space_tag_t  iot;
	bus_space_handle_t ioh;
	struct pci_attach_args *pa = ahc->dev_softc;

	command = ahc_pci_read_config(ahc->dev_softc,
				      PCI_COMMAND_STATUS_REG, 4);
a388 18
		if (ioh_valid) {
			/*
			 * Do a quick test to see if memory mapped
			 * I/O is functioning correctly.
			 */
			ahc->tag = iot;
			ahc->bsh = ioh;
			if (ahc_inb(ahc, HCNTRL) == 0xFF) {
				/* nope, use I/O mapping */
                                ioh_valid = 0;
			} else {
				/* Using memory mapping, disable I/O mapping */
                                command &= ~PCI_COMMAND_IO_ENABLE;
				ahc_pci_write_config(ahc->dev_softc,
						     PCI_COMMAND_STATUS_REG,
						     command, 4);
			}
		}
a395 6
		
		/* Using I/O mapping, disable memory mapping */
		command &= ~PCI_COMMAND_MEM_ENABLE;
		ahc_pci_write_config(ahc->dev_softc,
				     PCI_COMMAND_STATUS_REG,
				     command, 4);
d401 11
a411 1
		return (1);
a412 4
	ahc->tag = iot;
	ahc->bsh = ioh;
	return (0);
}
d414 3
a416 33
int
ahc_do_pci_config(ahc)
	struct ahc_softc *ahc;
{
	pcireg_t	 command;
	u_int		 our_id = 0;
	u_int		 sxfrctl1;
	u_int		 scsiseq;
	u_int		 dscommand0;
	int		 error;
	int		 opri;
	uint8_t		 sblkctl;


	ahc->chip |= AHC_PCI;
#if 0
	ahc_power_state_change(ahc, AHC_POWER_STATE_D0);
#endif 
	error = ahc_pci_map_registers(ahc);
	if (error != 0)
		return (error);
	/* 
	 * Registers are mapped. Now it is safe to use 
	 * the ahc_inb and ahc_outb macros. 
	 */
	
	/* 
	 * Before we continue probing the card, ensure that
	 * its interrupts are *disabled*.  We don't want
	 * a misstep to hang the machine in an interrupt
	 * storm.
	 */
	ahc_intr_enable(ahc, FALSE);
d418 3
a420 8
	/*
	 * If we need to support high memory, enable dual
	 * address cycles.  This bit must be set to enable
	 * high address bit generation even if we are on a
	 * 64bit bus (PCI64BIT set in devconfig).
	 */
	if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
		pcireg_t devconfig;
a421 11
		if (bootverbose)
			printf("%s: Enabling 39Bit Addressing\n",
			       ahc_name(ahc));
		devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
		devconfig |= DACEN;
		ahc_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig, 4);
	}
	
	/* Ensure busmastering is enabled */
        command = ahc_pci_read_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, 4);
	command |= PCI_COMMAND_MASTER_ENABLE; 
a422 2
	ahc_pci_write_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, command, 4);
	
d424 1
a424 1
	ahc->flags |= AHC_PAGESCBS;
d426 19
a444 17
	error = ahc_softc_init(ahc);
	if (error != 0)
		return (error);

	/* Remember how the card was setup in case there is no SEEPROM */
	if ((ahc_inb(ahc, HCNTRL) & POWRDN) == 0) {
		ahc_pause(ahc);
		if ((ahc->features & AHC_ULTRA2) != 0)
			our_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;
		else
			our_id = ahc_inb(ahc, SCSIID) & OID;
		sxfrctl1 = ahc_inb(ahc, SXFRCTL1) & STPWEN;
		scsiseq = ahc_inb(ahc, SCSISEQ);
	} else {
		sxfrctl1 = STPWEN;
		our_id = 7;
		scsiseq = 0;
d446 5
a450 5

	error = ahc_reset(ahc);
	if (error != 0)
		return (ENXIO);

d452 1
d458 7
a464 2
		ahc_outb(ahc, OPTIONMODE,
			 OPTIONMODE_DEFAULTS|AUTOACKEN|BUSFREEREV|EXPPHASEDIS);
d469 7
a475 1
					  |TARGCRCENDEN);
d477 14
d494 1
a494 1
	 * initialization.
a496 11
	
	dscommand0 = ahc_inb(ahc, DSCOMMAND0);
	dscommand0 |= MPARCKEN|CACHETHEN;
	if ((ahc->features & AHC_ULTRA2) != 0) {

		/*
		 * DPARCKEN doesn't work correctly on
		 * some MBs so don't use it.
		 */
		dscommand0 &= ~DPARCKEN;
	}
d499 1
a499 2
	 * Handle chips that must have cache line
	 * streaming (dis/en)abled.
d501 3
a503 2
	if ((ahc->bugs & AHC_CACHETHEN_DIS_BUG) != 0)
		dscommand0 |= CACHETHEN;
d505 3
a507 2
	if ((ahc->bugs & AHC_CACHETHEN_BUG) != 0)
		dscommand0 &= ~CACHETHEN;
d509 7
a515 14
	ahc_outb(ahc, DSCOMMAND0, dscommand0);
	
	ahc->pci_cachesize = ahc_pci_read_config(ahc->dev_softc,
						 CSIZE_LATTIME, 4) & CACHESIZE;
	ahc->pci_cachesize *= 4;

	if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0
	 && ahc->pci_cachesize == 4) {
		u_int csl = ahc_pci_read_config(ahc->dev_softc,
						CSIZE_LATTIME, 4);
		csl &= ~CACHESIZE;
		ahc_pci_write_config(ahc->dev_softc, CSIZE_LATTIME, csl, 4);
		ahc->pci_cachesize = 0;
	}
d517 1
a517 6
	/*
	 * We cannot perform ULTRA speeds without the presense
	 * of the external precision resistor.
	 */
	if ((ahc->features & AHC_ULTRA) != 0) {
		uint32_t devconfig;
d519 2
a520 4
		devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
		if ((devconfig & REXTVALID) == 0)
			ahc->features &= ~AHC_ULTRA;
	}
d522 5
a526 2
	/* See if we have a SEEPROM and perform auto-term */
	check_extport(ahc, &sxfrctl1);
a527 13
	/*
	 * Take the LED out of diagnostic mode
	 */
	sblkctl = ahc_inb(ahc, SBLKCTL);
	ahc_outb(ahc, SBLKCTL, (sblkctl & ~(DIAGLEDEN|DIAGLEDON)));

	if ((ahc->features & AHC_ULTRA2) != 0) {
		ahc_outb(ahc, DFF_THRSH, RD_DFTHRSH_MAX|WR_DFTHRSH_MAX);
	} else {
		ahc_outb(ahc, DSPCISTATUS, DFTHRSH_100);
	}

	if (ahc->flags & AHC_USEDEFAULTS) {
d529 3
a531 3
		 * PCI Adapter default setup
		 * Should only be used if the adapter does not have
		 * a SEEPROM.
d533 2
a534 6
		/* See if someone else set us up already */
		if (scsiseq != 0) {
			printf("%s: Using left over BIOS settings\n",
				ahc_name(ahc));
			ahc->flags &= ~AHC_USEDEFAULTS;
			ahc->flags |= AHC_BIOS_ENABLED;
d536 4
d541 3
a543 2
			 * Assume only one connector and always turn
			 * on termination.
d545 16
a560 2
 			our_id = 0x07;
			sxfrctl1 = STPWEN;
a561 3
		ahc_outb(ahc, SCSICONF, our_id|ENSPCHK|RESET_SCSI);

		ahc->our_id = our_id;
d571 2
d580 5
a584 21
	/* Core initialization */
	error = ahc_init(ahc);
	if (error != 0)
		return (error);

	/* Special func to force negotiation */
	ahc_force_neg(ahc);

	/*
	 * Link this softc in with all other ahc instances.
	 */
	ahc_softc_insert(ahc);

	/*
	 * Allow interrupts now that we are completely setup.
	 */
	error = ahc_pci_map_int(ahc);
	if (error != 0)
		return (error);

	ahc_intr_enable(ahc, TRUE);
d587 1
a587 32
	return (0);
}

int
ahc_pci_map_int(ahc)
	struct ahc_softc *ahc;
{
	const char *intrstr = NULL;
	pci_intr_handle_t ih;
	struct pci_attach_args *pa = ahc->dev_softc;
	
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		return 1;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	
	ahc->platform_data->ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO,
						    ahc_platform_intr, ahc,
						    ahc->sc_dev.dv_xname);
	
	if (ahc->platform_data->ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return 1;
	}
	
	if (intrstr != NULL)
		printf(": %s\n", intrstr);
	return 0;
d595 2
a596 1
ahc_ext_scbram_present(struct ahc_softc *ahc)
a597 1
	u_int chip;
d600 2
a601 5
	uint32_t devconfig;
	
	chip = ahc->chip & AHC_CHIPID_MASK;
	
	devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
d603 1
d608 1
a608 1
	else if (chip >= AHC_AIC7870)
d611 1
a611 1
		ramps = 0;
d622 5
a626 6
ahc_scbram_config(ahc, enable, pcheck, fast, large)
	struct ahc_softc *ahc;
	int enable;
	int pcheck;
	int fast;
	int large;
d629 1
d632 1
d637 2
a638 1
		ahc_outb(ahc, SCBBADDR, ahc_get_pci_function(ahc->dev_softc));
d641 2
a642 1
	devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, 4);
a650 4
		if (large)
			dscommand0 &= ~USCBSIZE32;
		else
			dscommand0 |= USCBSIZE32;
a660 4
		if (large)
			devconfig &= ~SCBSIZE32;
		else
			devconfig |= SCBSIZE32;
d667 1
a667 1
	ahc_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig, 4);
d677 1
a677 1
	struct ahc_softc *ahc;
a683 1
	int large;
a684 6
	enable = FALSE;
	pcheck = FALSE;
	fast = FALSE;
	large = FALSE;
	num_scbs = 0;
	
d686 1
a686 1
		goto done;
d691 4
a694 1
	ahc_scbram_config(ahc, /*enable*/TRUE, pcheck, fast, large);
d700 1
a700 10
	enable = TRUE;

	/*
	 * Clear any outstanding parity error
	 * and ensure that parity error reporting
	 * is enabled.
	 */
	ahc_outb(ahc, SEQCTL, 0);
	ahc_outb(ahc, CLRINT, CLRPARERR);
	ahc_outb(ahc, CLRINT, CLRBRKADRINT);
d703 1
a703 1
	ahc_scbram_config(ahc, enable, /*pcheck*/TRUE, fast, large);
d706 2
a707 2
	 || (ahc_inb(ahc, ERROR) & MPARERR) == 0)
		pcheck = TRUE;
d714 1
a714 1
	ahc_scbram_config(ahc, enable, pcheck, /*fast*/TRUE, large);
d717 3
a719 3
	 && ((ahc_inb(ahc, INTSTAT) & BRKADRINT) == 0
	  || (ahc_inb(ahc, ERROR) & MPARERR) == 0))
		fast = TRUE;
d721 2
a722 28
	/*
	 * See if we can use large SCBs and still maintain
	 * the same overall count of SCBs.
	 */
	if ((ahc->features & AHC_LARGE_SCBS) != 0) {
		ahc_scbram_config(ahc, enable, pcheck, fast, /*large*/TRUE);
		test_num_scbs = ahc_probe_scbs(ahc);
		if (test_num_scbs >= num_scbs) {
			large = TRUE;
			num_scbs = test_num_scbs;
	 		if (num_scbs >= 64) {
				/*
				 * We have enough space to move the
				 * "busy targets table" into SCB space
				 * and make it qualify all the way to the
				 * lun level.
				 */
				ahc->flags |= AHC_SCB_BTT;
			}
		}
	}
done:
	/*
	 * Disable parity error reporting until we
	 * can load instruction ram.
	 */
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS);
	/* Clear any latched parity error */
d726 4
a729 4
		printf("%s: External SRAM, %s access%s, %dbytes/SCB\n",
		       ahc_name(ahc), fast ? "fast" : "slow", 
		       pcheck ? ", parity checking enabled" : "",
		       large ? 64 : 32);
d731 1
a731 1
	ahc_scbram_config(ahc, enable, pcheck, fast, large);
d740 2
a741 2
	struct ahc_softc *ahc;
	u_int *sxfrctl1;
d743 12
a754 11
	struct	seeprom_descriptor sd;
	struct	seeprom_config sc;
	u_int	scsi_conf;
	u_int	adapter_control;
	int	have_seeprom;
	int	have_autoterm;
	
	sd.sd_ahc = ahc;
	sd.sd_control_offset = SEECTL;		
	sd.sd_status_offset = SEECTL;		
	sd.sd_dataout_offset = SEECTL;		
d777 1
a777 1
		if (bootverbose) 
d781 1
a781 1
			u_int start_addr;
d785 21
a805 9
			have_seeprom = read_seeprom(&sd, (uint16_t *)&sc,
						    start_addr, sizeof(sc)/2);

			if (have_seeprom)
				have_seeprom = verify_cksum(&sc);

			if (have_seeprom != 0 || sd.sd_chip == C56_66) {
				if (bootverbose) {
					if (have_seeprom == 0)
d807 5
a811 2
					else
						printf ("done.\n");
d813 3
a816 1
			}
a818 36
		release_seeprom(&sd);
	}

	if (!have_seeprom) {
		/*
		 * Pull scratch ram settings and treat them as
		 * if they are the contents of an seeprom if
		 * the 'ADPT' signature is found in SCB2.
		 * We manually compose the data as 16bit values
		 * to avoid endian issues.
		 */
		ahc_outb(ahc, SCBPTR, 2);
		if (ahc_inb(ahc, SCB_BASE) == 'A'
		 && ahc_inb(ahc, SCB_BASE + 1) == 'D'
		 && ahc_inb(ahc, SCB_BASE + 2) == 'P'
		 && ahc_inb(ahc, SCB_BASE + 3) == 'T') {
			uint16_t *sc_data;
			int	  i;

			sc_data = (uint16_t *)&sc;
			for (i = 0; i < 32; i++) {
				uint16_t val;
				int	 j;

				j = i * 2;
				val = ahc_inb(ahc, SRAM_BASE + j)
				    | ahc_inb(ahc, SRAM_BASE + j + 1) << 8;
			}
			have_seeprom = verify_cksum(&sc);
		}
		/*
		 * Clear any SCB parity errors in case this data and
		 * its associated parity was not initialized by the BIOS
		 */
		ahc_outb(ahc, CLRINT, CLRPARERR);
		ahc_outb(ahc, CLRINT, CLRBRKADRINT);
d832 2
a833 2
		uint16_t discenable;
		uint16_t ultraenb;
d843 1
a843 1
				if ((sc.device_flags[i] & CFSYNCHISULTRA) != 0){
d852 1
a852 1
			uint16_t target_mask;
d864 1
a864 1
			 && (ultraenb & target_mask) != 0) {
d867 1
a867 1
			 	ultraenb &= ~target_mask;
d874 1
a874 1
				else 
a877 5
				/*
				 * The ultra enable bits contain the
				 * high bit of the ultra2 sync rate
				 * field.
				 */
d879 1
a879 2
					 | ((ultraenb & target_mask)
					    ? 0x8 : 0x0);
a898 3
		ahc->flags |=
		    (sc.adapter_control & CFBOOTCHAN) >> CFBOOTCHANSHIFT;

a900 3

		if (sc.bios_control & CFBIOSEN)
			ahc->flags |= AHC_BIOS_ENABLED;
d902 1
a902 1
		 && (ahc->flags & AHC_NEWEEPROM_FMT) == 0) {
a907 14

		if (sc.signature == CFSIGNATURE
		 || sc.signature == CFSIGNATURE2) {
			pcireg_t devconfig;

			/* Honor the STPWLEVEL settings */
			devconfig = ahc_pci_read_config(ahc->dev_softc, 
							DEVCONFIG, 4);
			devconfig &= ~STPWLEVEL;
			if ((sc.bios_control & CFSTPWLEVEL) != 0)
				devconfig |= STPWLEVEL;
			ahc_pci_write_config(ahc->dev_softc,
					     DEVCONFIG, devconfig, 4);
		}
d935 1
a935 1
			have_autoterm = TRUE;
d937 1
a937 1
			have_autoterm = FALSE;
d940 1
a940 2
	if (have_autoterm) {
		acquire_seeprom(ahc, &sd);
d942 2
a943 2
		release_seeprom(&sd);
	}
d947 5
a951 4
configure_termination(struct ahc_softc *ahc,
		      struct seeprom_descriptor *sd,
		      u_int adapter_control,
		      u_int *sxfrctl1)
d953 2
a954 2
	uint8_t brddat;
	
d962 1
a962 1
	
d970 1
a970 1
	 || (ahc->features & AHC_NEW_TERMCTL) != 0) {
a978 1
		int sum;
d986 4
a989 4
					       &enableSEC_high,
					       &enablePRI_low,
					       &enablePRI_high,
					       &eeprom_present);
d993 3
a995 4
					       ahc_name(ahc));
				enableSEC_low = (adapter_control & CFSELOWTERM);
				enableSEC_high =
				    (adapter_control & CFSEHIGHTERM);
d1001 2
a1002 2
				enablePRI_low = (adapter_control & CFSTERM);
				enablePRI_high = (adapter_control & CFWSTERM);
d1022 7
a1028 5
		if (bootverbose
		 && (ahc->features & AHC_ULTRA2) == 0) {
			printf("%s: internal 50 cable %s present",
			       ahc_name(ahc),
			       internal50_present ? "is":"not");
d1030 4
a1033 8
			if ((ahc->features & AHC_WIDE) != 0)
				printf(", internal 68 cable %s present",
				       internal68_present ? "is":"not");
			printf("\n%s: external cable %s present\n",
			       ahc_name(ahc),
			       externalcable_present ? "is":"not");
		}
		if (bootverbose)
d1036 1
d1058 3
a1060 3
		 && (internal50_present != 0)
		 && (internal68_present != 0)
		 && (externalcable_present != 0)) {
a1064 9

			/*
			 * Pretend there are no cables in the hope
			 * that having all of the termination on
			 * gives us a more stable bus.
			 */
		 	internal50_present = 0;
			internal68_present = 0;
			externalcable_present = 0;
d1068 3
a1070 3
		 && ((externalcable_present == 0)
		  || (internal68_present == 0)
		  || (enableSEC_high != 0))) {
d1080 1
a1080 1
							      : "");
d1084 4
a1087 3
		sum = internal50_present + internal68_present
		    + externalcable_present;
		if (sum < 2 || (enableSEC_low != 0)) {
d1100 1
a1100 1
							     : "");
d1124 1
a1124 1
		
d1134 2
a1135 2
				       (ahc->features & AHC_ULTRA2) ? "Primary "
								    : "");
d1138 1
a1138 2
		if ((adapter_control & CFWSTERM) != 0
		 && (ahc->features & AHC_WIDE) != 0) {
d1144 1
a1144 1
				     ? "Secondary " : "");
d1153 1
a1153 2
		if ((ahc->features & AHC_WIDE) != 0)
			write_brdctl(ahc, brddat);
d1161 6
a1166 6
	struct ahc_softc *ahc;
	int *enableSEC_low;
	int *enableSEC_high;
	int *enablePRI_low;
	int *enablePRI_high;
	int *eeprom_present;
d1188 5
a1192 5
	struct ahc_softc *ahc;
	int *internal50_present;
	int *internal68_present;
	int *externalcable_present;
	int *eeprom_present;
d1211 2
a1212 2
	*internal50_present = (brdctl & BRDDAT6) ? 0 : 1;
	*internal68_present = (brdctl & BRDDAT7) ? 0 : 1;
d1226 2
a1227 2
	*externalcable_present = (brdctl & BRDDAT6) ? 0 : 1;
	*eeprom_present = (brdctl & BRDDAT7) ? 1 : 0;
d1233 4
a1236 4
	struct ahc_softc *ahc;
	int *internal50_present;
	int *externalcable_present;
	int *eeprom_present;
d1243 2
a1244 2
	*internal50_present = (brdctl & BRDDAT5) ? 0 : 1;
	*externalcable_present = (brdctl & BRDDAT6) ? 0 : 1;
d1246 1
a1246 1
	*eeprom_present = (ahc_inb(ahc, SPIOCAP) & EEPROM) ? 1 : 0;
d1251 2
a1252 2
	struct   ahc_softc *ahc;
	u_int8_t value;
d1266 1
a1266 1
	ahc_flush_device_writes(ahc);
d1269 1
a1269 1
	ahc_flush_device_writes(ahc);
d1275 1
a1275 1
	ahc_flush_device_writes(ahc);
d1285 1
a1285 1
	struct   ahc_softc *ahc;
d1300 1
a1300 1
	ahc_flush_device_writes(ahc);
d1308 2
a1309 2
	struct ahc_softc *ahc;
	struct seeprom_descriptor *sd;
d1338 1
a1338 1
	struct seeprom_descriptor *sd;
d1351 1
a1351 8
#define PCIDEBUG
#ifdef	PCIDEBUG
#define	PCI_PRINT(Printstuff) printf Printstuff
#else
#define	PCI_PRINT(Printstuff)
#endif

void
d1353 1
a1353 1
	struct ahc_softc *ahc;
d1356 1
d1359 3
a1361 6
		return;
  	PCI_PRINT(("%s: PCI error Interrupt at seqaddr = 0x%x\n",
		   ahc_name(ahc), 
		   ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8)));
 
	status1 = ahc_pci_read_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, 4);
d1364 1
a1364 1
#ifdef AHC_SHOW_PCI_ERRORS
d1366 2
a1367 2
		PCI_PRINT(("%s: Data Parity Error Detected during address "
			   "or write data phase\n", ahc_name(ahc)));
d1371 1
a1371 1
		PCI_PRINT(("%s: Signal System Error Detected\n", ahc_name(ahc)));
d1374 1
a1374 1
		PCI_PRINT(("%s: Received a Master Abort\n", ahc_name(ahc)));
d1377 1
a1377 1
		PCI_PRINT(("%s: Received a Target Abort\n", ahc_name(ahc)));
d1380 1
a1380 1
		PCI_PRINT(("%s: Signaled a Target Abort\n", ahc_name(ahc)));
d1383 2
a1384 2
		PCI_PRINT(("%s: Data Parity Error has been reported via PERR#\n",
			   ahc_name(ahc)));
a1385 3
	
	ahc_pci_write_config(ahc->dev_softc, PCI_COMMAND_STATUS_REG, status1, 4);

d1388 5
a1392 2
		       "no status bits set\n", ahc_name(ahc)); 
	} else {
a1394 2
	
	ahc_unpause(ahc);
d1396 1
a1396 1
	return;
@


1.12.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 2
d6 1
a6 2
 *      3940, 2940, aic7895, aic7890, aic7880,
 *	aic7870, aic7860 and aic7850 SCSI controllers
d8 1
a8 2
 * Copyright (c) 1994-2001 Justin T. Gibbs.
 * Copyright (c) 2000-2001 Adaptec Inc.
d15 7
a21 14
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
d23 5
a27 6
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d30 4
a33 13
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 *
 * $Id$
 *
 * //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#57 $
 *
 * $FreeBSD: /repoman/r/ncvs/src/sys/dev/aic7xxx/aic7xxx_pci.c,v 1.22 2003/01/20 20:44:55 gibbs Exp $
 */
/*
 * Ported from FreeBSD by Pascal Renauld, Network Storage Solutions, Inc. - April 2003
a35 3
#include <sys/cdefs.h>
/* __KERNEL_RCSID(0, "$NetBSD: ahc_pci.c,v 1.43 2003/08/18 09:16:22 taca Exp $"); */

a41 2
#include <sys/reboot.h>

d45 3
d50 1
d55 1
a57 1

d60 12
a72 155
static __inline uint64_t
ahc_compose_id(u_int device, u_int vendor, u_int subdevice, u_int subvendor)
{
	uint64_t id;

	id = subvendor
	   | (subdevice << 16)
	   | ((uint64_t)vendor << 32)
	   | ((uint64_t)device << 48);

	return (id);
}

#define ID_ALL_MASK			0xFFFFFFFFFFFFFFFFull
#define ID_DEV_VENDOR_MASK		0xFFFFFFFF00000000ull
#define ID_9005_GENERIC_MASK		0xFFF0FFFF00000000ull
#define ID_9005_SISL_MASK		0x000FFFFF00000000ull
#define ID_9005_SISL_ID			0x0005900500000000ull
#define ID_AIC7850			0x5078900400000000ull
#define ID_AHA_2902_04_10_15_20_30C	0x5078900478509004ull
#define ID_AIC7855			0x5578900400000000ull
#define ID_AIC7859			0x3860900400000000ull
#define ID_AHA_2930CU			0x3860900438699004ull
#define ID_AIC7860			0x6078900400000000ull
#define ID_AIC7860C			0x6078900478609004ull
#define ID_AHA_1480A			0x6075900400000000ull
#define ID_AHA_2940AU_0			0x6178900400000000ull
#define ID_AHA_2940AU_1			0x6178900478619004ull
#define ID_AHA_2940AU_CN		0x2178900478219004ull
#define ID_AHA_2930C_VAR		0x6038900438689004ull

#define ID_AIC7870			0x7078900400000000ull
#define ID_AHA_2940			0x7178900400000000ull
#define ID_AHA_3940			0x7278900400000000ull
#define ID_AHA_398X			0x7378900400000000ull
#define ID_AHA_2944			0x7478900400000000ull
#define ID_AHA_3944			0x7578900400000000ull
#define ID_AHA_4944			0x7678900400000000ull

#define ID_AIC7880			0x8078900400000000ull
#define ID_AIC7880_B			0x8078900478809004ull
#define ID_AHA_2940U			0x8178900400000000ull
#define ID_AHA_3940U			0x8278900400000000ull
#define ID_AHA_2944U			0x8478900400000000ull
#define ID_AHA_3944U			0x8578900400000000ull
#define ID_AHA_398XU			0x8378900400000000ull
#define ID_AHA_4944U			0x8678900400000000ull
#define ID_AHA_2940UB			0x8178900478819004ull
#define ID_AHA_2930U			0x8878900478889004ull
#define ID_AHA_2940U_PRO		0x8778900478879004ull
#define ID_AHA_2940U_CN			0x0078900478009004ull

#define ID_AIC7895			0x7895900478959004ull
#define ID_AIC7895_ARO			0x7890900478939004ull
#define ID_AIC7895_ARO_MASK		0xFFF0FFFFFFFFFFFFull
#define ID_AHA_2940U_DUAL		0x7895900478919004ull
#define ID_AHA_3940AU			0x7895900478929004ull
#define ID_AHA_3944AU			0x7895900478949004ull

#define ID_AIC7890			0x001F9005000F9005ull
#define ID_AIC7890_ARO			0x00139005000F9005ull
#define ID_AAA_131U2			0x0013900500039005ull
#define ID_AHA_2930U2			0x0011900501819005ull
#define ID_AHA_2940U2B			0x00109005A1009005ull
#define ID_AHA_2940U2_OEM		0x0010900521809005ull
#define ID_AHA_2940U2			0x00109005A1809005ull
#define ID_AHA_2950U2B			0x00109005E1009005ull

#define ID_AIC7892			0x008F9005FFFF9005ull
#define ID_AIC7892_ARO			0x00839005FFFF9005ull
#define ID_AHA_2915LP			0x0082900502109005ull
#define ID_AHA_29160			0x00809005E2A09005ull
#define ID_AHA_29160_CPQ		0x00809005E2A00E11ull
#define ID_AHA_29160N			0x0080900562A09005ull
#define ID_AHA_29160C			0x0080900562209005ull
#define ID_AHA_29160B			0x00809005E2209005ull
#define ID_AHA_19160B			0x0081900562A19005ull

#define ID_AIC7896			0x005F9005FFFF9005ull
#define ID_AIC7896_ARO			0x00539005FFFF9005ull
#define ID_AHA_3950U2B_0		0x00509005FFFF9005ull
#define ID_AHA_3950U2B_1		0x00509005F5009005ull
#define ID_AHA_3950U2D_0		0x00519005FFFF9005ull
#define ID_AHA_3950U2D_1		0x00519005B5009005ull

#define ID_AIC7899			0x00CF9005FFFF9005ull
#define ID_AIC7899_ARO			0x00C39005FFFF9005ull
#define ID_AHA_3960D			0x00C09005F6209005ull
#define ID_AHA_3960D_CPQ		0x00C09005F6200E11ull

#define ID_AIC7810			0x1078900400000000ull
#define ID_AIC7815			0x7815900400000000ull

#define DEVID_9005_TYPE(id) ((id) & 0xF)
#define		DEVID_9005_TYPE_HBA		0x0	/* Standard Card */
#define		DEVID_9005_TYPE_AAA		0x3	/* RAID Card */
#define		DEVID_9005_TYPE_SISL		0x5	/* Container ROMB */
#define		DEVID_9005_TYPE_MB		0xF	/* On Motherboard */

#define DEVID_9005_MAXRATE(id) (((id) & 0x30) >> 4)
#define		DEVID_9005_MAXRATE_U160		0x0
#define		DEVID_9005_MAXRATE_ULTRA2	0x1
#define		DEVID_9005_MAXRATE_ULTRA	0x2
#define		DEVID_9005_MAXRATE_FAST		0x3

#define DEVID_9005_MFUNC(id) (((id) & 0x40) >> 6)

#define DEVID_9005_CLASS(id) (((id) & 0xFF00) >> 8)
#define		DEVID_9005_CLASS_SPI		0x0	/* Parallel SCSI */

#define SUBID_9005_TYPE(id) ((id) & 0xF)
#define		SUBID_9005_TYPE_MB		0xF	/* On Motherboard */
#define		SUBID_9005_TYPE_CARD		0x0	/* Standard Card */
#define		SUBID_9005_TYPE_LCCARD		0x1	/* Low Cost Card */
#define		SUBID_9005_TYPE_RAID		0x3	/* Combined with Raid */

#define SUBID_9005_TYPE_KNOWN(id)			\
	  ((((id) & 0xF) == SUBID_9005_TYPE_MB)		\
	|| (((id) & 0xF) == SUBID_9005_TYPE_CARD)	\
	|| (((id) & 0xF) == SUBID_9005_TYPE_LCCARD)	\
	|| (((id) & 0xF) == SUBID_9005_TYPE_RAID))

#define SUBID_9005_MAXRATE(id) (((id) & 0x30) >> 4)
#define		SUBID_9005_MAXRATE_ULTRA2	0x0
#define		SUBID_9005_MAXRATE_ULTRA	0x1
#define		SUBID_9005_MAXRATE_U160		0x2
#define		SUBID_9005_MAXRATE_RESERVED	0x3

#define SUBID_9005_SEEPTYPE(id)						\
	((SUBID_9005_TYPE(id) == SUBID_9005_TYPE_MB)			\
	 ? ((id) & 0xC0) >> 6						\
	 : ((id) & 0x300) >> 8)
#define		SUBID_9005_SEEPTYPE_NONE	0x0
#define		SUBID_9005_SEEPTYPE_1K		0x1
#define		SUBID_9005_SEEPTYPE_2K_4K	0x2
#define		SUBID_9005_SEEPTYPE_RESERVED	0x3
#define SUBID_9005_AUTOTERM(id)						\
	((SUBID_9005_TYPE(id) == SUBID_9005_TYPE_MB)			\
	 ? (((id) & 0x400) >> 10) == 0					\
	 : (((id) & 0x40) >> 6) == 0)

#define SUBID_9005_NUMCHAN(id)						\
	((SUBID_9005_TYPE(id) == SUBID_9005_TYPE_MB)			\
	 ? ((id) & 0x300) >> 8						\
	 : ((id) & 0xC00) >> 10)

#define SUBID_9005_LEGACYCONN(id)					\
	((SUBID_9005_TYPE(id) == SUBID_9005_TYPE_MB)			\
	 ? 0								\
	 : ((id) & 0x80) >> 7)

#define SUBID_9005_MFUNCENB(id)						\
	((SUBID_9005_TYPE(id) == SUBID_9005_TYPE_MB)			\
	 ? ((id) & 0x800) >> 11						\
	 : ((id) & 0x1000) >> 12)
d74 2
a75 2
 * Informational only. Should use chip register to be
 * certain, but may be use in identification strings.
d77 5
a81 25
#define SUBID_9005_CARD_SCSIWIDTH_MASK	0x2000
#define SUBID_9005_CARD_PCIWIDTH_MASK	0x4000
#define SUBID_9005_CARD_SEDIFF_MASK	0x8000

static ahc_device_setup_t ahc_aic785X_setup;
static ahc_device_setup_t ahc_aic7860_setup;
static ahc_device_setup_t ahc_apa1480_setup;
static ahc_device_setup_t ahc_aic7870_setup;
static ahc_device_setup_t ahc_aha394X_setup;
static ahc_device_setup_t ahc_aha494X_setup;
static ahc_device_setup_t ahc_aha398X_setup;
static ahc_device_setup_t ahc_aic7880_setup;
static ahc_device_setup_t ahc_aha2940Pro_setup;
static ahc_device_setup_t ahc_aha394XU_setup;
static ahc_device_setup_t ahc_aha398XU_setup;
static ahc_device_setup_t ahc_aic7890_setup;
static ahc_device_setup_t ahc_aic7892_setup;
static ahc_device_setup_t ahc_aic7895_setup;
static ahc_device_setup_t ahc_aic7896_setup;
static ahc_device_setup_t ahc_aic7899_setup;
static ahc_device_setup_t ahc_aha29160C_setup;
static ahc_device_setup_t ahc_raid_setup;
static ahc_device_setup_t ahc_aha394XX_setup;
static ahc_device_setup_t ahc_aha494XX_setup;
static ahc_device_setup_t ahc_aha398XX_setup;
d83 1
a83 328
struct ahc_pci_identity ahc_pci_ident_table [] =
{
	/* aic7850 based controllers */
	{
		ID_AHA_2902_04_10_15_20_30C,
		ID_ALL_MASK,
		ahc_aic785X_setup
	},
	/* aic7860 based controllers */
	{
		ID_AHA_2930CU,
		ID_ALL_MASK,
		ahc_aic7860_setup
	},
	{
		ID_AHA_1480A & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_apa1480_setup
	},
	{
		ID_AHA_2940AU_0 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7860_setup
	},
	{
		ID_AHA_2940AU_CN & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7860_setup
	},
	{
		ID_AHA_2930C_VAR & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7860_setup
	},
	/* aic7870 based controllers */
	{
		ID_AHA_2940,
		ID_ALL_MASK,
		ahc_aic7870_setup
	},
	{
		ID_AHA_3940,
		ID_ALL_MASK,
		ahc_aha394X_setup
	},
	{
		ID_AHA_398X,
		ID_ALL_MASK,
		ahc_aha398X_setup
	},
	{
		ID_AHA_2944,
		ID_ALL_MASK,
		ahc_aic7870_setup
	},
	{
		ID_AHA_3944,
		ID_ALL_MASK,
		ahc_aha394X_setup
	},
	{
		ID_AHA_4944,
		ID_ALL_MASK,
		ahc_aha494X_setup
	},
	/* aic7880 based controllers */
	{
		ID_AHA_2940U & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7880_setup
	},
	{
		ID_AHA_3940U & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aha394XU_setup
	},
	{
		ID_AHA_2944U & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7880_setup
	},
	{
		ID_AHA_3944U & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aha394XU_setup
	},
	{
		ID_AHA_398XU & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aha398XU_setup
	},
	{
		/*
		 * XXX Don't know the slot numbers
		 * so we can't identify channels
		 */
		ID_AHA_4944U & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7880_setup
	},
	{
		ID_AHA_2930U & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7880_setup
	},
	{
		ID_AHA_2940U_PRO & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aha2940Pro_setup
	},
	{
		ID_AHA_2940U_CN & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7880_setup
	},
	/* Ignore all SISL (AAC on MB) based controllers. */
	{
		ID_9005_SISL_ID,
		ID_9005_SISL_MASK,
		NULL
	},
	/* aic7890 based controllers */
	{
		ID_AHA_2930U2,
		ID_ALL_MASK,
		ahc_aic7890_setup
	},
	{
		ID_AHA_2940U2B,
		ID_ALL_MASK,
		ahc_aic7890_setup
	},
	{
		ID_AHA_2940U2_OEM,
		ID_ALL_MASK,
		ahc_aic7890_setup
	},
	{
		ID_AHA_2940U2,
		ID_ALL_MASK,
		ahc_aic7890_setup
	},
	{
		ID_AHA_2950U2B,
		ID_ALL_MASK,
		ahc_aic7890_setup
	},
	{
		ID_AIC7890_ARO,
		ID_ALL_MASK,
		ahc_aic7890_setup
	},
	{
		ID_AAA_131U2,
		ID_ALL_MASK,
		ahc_aic7890_setup
	},
	/* aic7892 based controllers */
	{
		ID_AHA_29160,
		ID_ALL_MASK,
		ahc_aic7892_setup
	},
	{
		ID_AHA_29160_CPQ,
		ID_ALL_MASK,
		ahc_aic7892_setup
	},
	{
		ID_AHA_29160N,
		ID_ALL_MASK,
		ahc_aic7892_setup
	},
	{
		ID_AHA_29160C,
		ID_ALL_MASK,
		ahc_aha29160C_setup
	},
	{
		ID_AHA_29160B,
		ID_ALL_MASK,
		ahc_aic7892_setup
	},
	{
		ID_AHA_19160B,
		ID_ALL_MASK,
		ahc_aic7892_setup
	},
	{
		ID_AIC7892_ARO,
		ID_ALL_MASK,
		ahc_aic7892_setup
	},
	{
		ID_AHA_2915LP,
		ID_ALL_MASK,
		ahc_aic7892_setup
	},
	/* aic7895 based controllers */	
	{
		ID_AHA_2940U_DUAL,
		ID_ALL_MASK,
		ahc_aic7895_setup
	},
	{
		ID_AHA_3940AU,
		ID_ALL_MASK,
		ahc_aic7895_setup
	},
	{
		ID_AHA_3944AU,
		ID_ALL_MASK,
		ahc_aic7895_setup
	},
	{
		ID_AIC7895_ARO,
		ID_AIC7895_ARO_MASK,
		ahc_aic7895_setup
	},
	/* aic7896/97 based controllers */	
	{
		ID_AHA_3950U2B_0,
		ID_ALL_MASK,
		ahc_aic7896_setup
	},
	{
		ID_AHA_3950U2B_1,
		ID_ALL_MASK,
		ahc_aic7896_setup
	},
	{
		ID_AHA_3950U2D_0,
		ID_ALL_MASK,
		ahc_aic7896_setup
	},
	{
		ID_AHA_3950U2D_1,
		ID_ALL_MASK,
		ahc_aic7896_setup
	},
	{
		ID_AIC7896_ARO,
		ID_ALL_MASK,
		ahc_aic7896_setup
	},
	/* aic7899 based controllers */	
	{
		ID_AHA_3960D,
		ID_ALL_MASK,
		ahc_aic7899_setup
	},
	{
		ID_AHA_3960D_CPQ,
		ID_ALL_MASK,
		ahc_aic7899_setup
	},
	{
		ID_AIC7899_ARO,
		ID_ALL_MASK,
		ahc_aic7899_setup
	},
	/* Generic chip probes for devices we don't know 'exactly' */
	{
		ID_AIC7850 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic785X_setup
	},
	{
		ID_AIC7855 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic785X_setup
	},
	{
		ID_AIC7859 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7860_setup
	},
	{
		ID_AIC7860 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7860_setup
	},
	{
		ID_AIC7870 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7870_setup
	},
	{
		ID_AIC7880 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7880_setup
	},
	{
		ID_AIC7890 & ID_9005_GENERIC_MASK,
		ID_9005_GENERIC_MASK,
		ahc_aic7890_setup
	},
	{
		ID_AIC7892 & ID_9005_GENERIC_MASK,
		ID_9005_GENERIC_MASK,
		ahc_aic7892_setup
	},
	{
		ID_AIC7895 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_aic7895_setup
	},
	{
		ID_AIC7896 & ID_9005_GENERIC_MASK,
		ID_9005_GENERIC_MASK,
		ahc_aic7896_setup
	},
	{
		ID_AIC7899 & ID_9005_GENERIC_MASK,
		ID_9005_GENERIC_MASK,
		ahc_aic7899_setup
	},
	{
		ID_AIC7810 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_raid_setup
	},
	{
		ID_AIC7815 & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahc_raid_setup
	}
};
a84 2
const u_int ahc_num_pci_devs = NUM_ELEMENTS(ahc_pci_ident_table);
		
d92 2
a93 4
#define AHC_494X_SLOT_CHANNEL_A	4
#define AHC_494X_SLOT_CHANNEL_B	5
#define AHC_494X_SLOT_CHANNEL_C	6
#define AHC_494X_SLOT_CHANNEL_D	7
d96 14
a109 15
#define		PCIERRGENDIS	0x80000000ul
#define		SCBSIZE32	0x00010000ul	/* aic789X only */
#define		REXTVALID	0x00001000ul	/* ultra cards only */
#define		MPORTMODE	0x00000400ul	/* aic7870+ only */
#define		RAMPSM		0x00000200ul	/* aic7870+ only */
#define		VOLSENSE	0x00000100ul
#define		PCI64BIT	0x00000080ul	/* 64Bit PCI bus (Ultra2 Only)*/
#define		SCBRAMSEL	0x00000080ul
#define		MRDCEN		0x00000040ul
#define		EXTSCBTIME	0x00000020ul	/* aic7870 only */
#define		EXTSCBPEN	0x00000010ul	/* aic7870 only */
#define		BERREN		0x00000008ul
#define		DACEN		0x00000004ul
#define		STPWLEVEL	0x00000002ul
#define		DIFACTNEGEN	0x00000001ul	/* aic7870 only */
d112 2
a113 2
#define		CACHESIZE	0x0000003ful	/* only 5 bits */
#define		LATTIME		0x0000ff00ul
d115 1
a115 11
/* PCI STATUS definitions */
#define	DPE	0x80
#define SSE	0x40
#define	RMA	0x20
#define	RTA	0x10
#define STA	0x08
#define DPR	0x01

static int ahc_9005_subdevinfo_valid(uint16_t vendor, uint16_t device,
				     uint16_t subvendor, uint16_t subdevice);
static int ahc_ext_scbram_present(struct ahc_softc *ahc);
d119 32
a154 1

d159 36
a194 32
const struct ahc_pci_identity *
ahc_find_pci_device(id, subid, func)
	pcireg_t id, subid;
	u_int func;
{
	u_int64_t  full_id;
	const struct	   ahc_pci_identity *entry;
	u_int	   i;

	full_id = ahc_compose_id(PCI_PRODUCT(id), PCI_VENDOR(id),
				 PCI_PRODUCT(subid), PCI_VENDOR(subid));

	/*
	 * If the second function is not hooked up, ignore it.
	 * Unfortunately, not all MB vendors implement the
	 * subdevice ID as per the Adaptec spec, so do our best
	 * to sanity check it prior to accepting the subdevice
	 * ID as valid.
	 */
	if (func > 0
	    && ahc_9005_subdevinfo_valid(PCI_VENDOR(id), PCI_PRODUCT(id), 
					 PCI_VENDOR(subid), PCI_PRODUCT(subid))
	    && SUBID_9005_MFUNCENB(PCI_PRODUCT(subid)) == 0)
		return (NULL);

	for (i = 0; i < ahc_num_pci_devs; i++) {
		entry = &ahc_pci_ident_table[i];
		if (entry->full_id == (full_id & entry->id_mask))
			return (entry);
	}
	return (NULL);
}
d198 2
a199 2
	struct device *parent;
	void *match, *aux;
d201 2
a202 7
	struct pci_attach_args *pa = aux;
	const struct	   ahc_pci_identity *entry;
	pcireg_t   subid;

	subid = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);
	entry = ahc_find_pci_device(pa->pa_id, subid, pa->pa_function);
	return (entry != NULL && entry->setup != NULL) ? 1 : 0;
d207 2
a208 2
	struct device *parent, *self;
	void *aux;
d211 3
a213 22
	const struct	   ahc_pci_identity *entry;
	struct		   ahc_softc *ahc = (void *)self;
	pcireg_t	   command;
	u_int		   our_id = 0;
	u_int		   sxfrctl1;
	u_int		   scsiseq;
	u_int		   sblkctl;
	uint8_t 	   dscommand0;
	uint32_t	   devconfig;
	int		   error;
	pcireg_t	   subid;
	int		   ioh_valid, memh_valid;
	bus_space_tag_t    st, iot;
	bus_space_handle_t sh, ioh;
#ifdef AHC_ALLOW_MEMIO
	bus_space_tag_t    memt;
	bus_space_handle_t memh;
	pcireg_t memtype;
#endif
	pci_intr_handle_t  ih;
	const char        *intrstr;
	struct ahc_pci_busdata *bd;
d215 1
d218 6
d225 3
d229 167
d397 3
a399 5
	command = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	subid = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);
	entry = ahc_find_pci_device(pa->pa_id, subid, pa->pa_function);
	if (entry == NULL)
		return;
d401 2
a402 4
	/* Keep information about the PCI bus */
	bd = malloc(sizeof (struct ahc_pci_busdata), M_DEVBUF, M_NOWAIT);
	if (bd == NULL) {
		printf("%s: unable to allocate bus-specific data\n", ahc_name(ahc));
d405 3
a407 1
	memset(bd, 0, sizeof(struct ahc_pci_busdata));
d409 9
a417 13
	bd->pc = pa->pa_pc;
	bd->tag = pa->pa_tag;
	bd->func = pa->pa_function;
	bd->dev = pa->pa_device;
	bd->class = pa->pa_class;

	ahc->bd = bd;

	error = entry->setup(ahc);
	if (error != 0)
		return;

	ioh_valid = memh_valid = 0;
d419 2
d422 36
a457 9
	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, AHC_PCI_MEMADDR);
	switch (memtype) {
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
		memh_valid = (pci_mapreg_map(pa, AHC_PCI_MEMADDR,
					     memtype, 0, &memt, &memh, NULL, NULL, 0) == 0);
		break;
	default:
		memh_valid = 0;
d459 2
d462 10
a471 7
	ioh_valid = (pci_mapreg_map(pa, AHC_PCI_IOADDR,
				    PCI_MAPREG_TYPE_IO, 0, &iot, 
				    &ioh, NULL, NULL, 0) == 0);
#if 0
	printf("%s: mem mapping: memt 0x%x, memh 0x%x, iot 0x%x, ioh 0x%lx\n",
	       ahc_name(ahc), memt, (u_int32_t)memh, (u_int32_t)iot, ioh);
#endif
d473 2
a474 9
	if (ioh_valid) {
		st = iot;
		sh = ioh;
#ifdef AHC_ALLOW_MEMIO
	} else if (memh_valid) {
		st = memt;
		sh = memh;
#endif
	} else {
d476 1
a476 1
		return;
d478 18
a495 2
	ahc->tag = st;
	ahc->bsh = sh;
d498 12
a509 1
	/*
a517 8
	 * XXX somehow reading this once fails on some sparc64 systems.
	 *     This may be a problem in the sparc64 PCI code. Doing it
	 *     twice works around it.
	 */
	devconfig = pci_conf_read(pa->pa_pc, pa->pa_tag, DEVCONFIG);
	devconfig = pci_conf_read(pa->pa_pc, pa->pa_tag, DEVCONFIG);

	/*
d524 1
d526 1
a526 1
		if (1/*bootverbose*/)
d529 1
d531 1
a533 5
	/* Ensure that pci error generation, a test feature, is disabled. */
	devconfig |= PCIERRGENDIS;

	pci_conf_write(pa->pa_pc, pa->pa_tag, DEVCONFIG, devconfig);

d535 2
a536 12
	command |= PCI_COMMAND_MASTER_ENABLE;;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);

	/*
	 * Disable PCI parity error reporting.  Users typically
	 * do this to work around broken PCI chipsets that get
	 * the parity timing wrong and thus generate lots of spurious
	 * errors.
	 */
	if ((ahc->flags & AHC_DISABLE_PCI_PERR) != 0)
	  command &= ~PCI_COMMAND_PARITY_ENABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
d538 2
d542 1
d545 1
a545 3
		goto error_out;

	ahc->bus_intr = ahc_pci_intr;
d564 1
a564 1
		goto error_out;
d581 6
a586 18
	if (pci_intr_map(pa, &ih)) {
		printf("%s: couldn't map interrupt\n", ahc_name(ahc));
		ahc_free(ahc);
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	ahc->ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO,
	    ahc_platform_intr, ahc, ahc->sc_dev.dv_xname);
	if (ahc->ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		ahc_free(ahc);
		return;
	} else
		printf(": %s\n", intrstr ? intrstr : "?");

d609 3
a611 3

	ahc->pci_cachesize =
	    pci_conf_read(pa->pa_pc, pa->pa_tag, CSIZE_LATTIME) & CACHESIZE;
d615 5
a619 2
	    && ahc->pci_cachesize == 4) {
		pci_conf_write(pa->pa_pc, pa->pa_tag, CSIZE_LATTIME, 0);
d624 1
a624 1
	 * We cannot perform ULTRA speeds without the presence
d630 1
a630 1
		devconfig = pci_conf_read(pa->pa_pc, pa->pa_tag, DEVCONFIG);
a634 7
	ahc->seep_config = malloc(sizeof(*ahc->seep_config),
				  M_DEVBUF, M_NOWAIT);
	if (ahc->seep_config == NULL)
		goto error_out;
	
	memset(ahc->seep_config, 0, sizeof(*ahc->seep_config));

d636 1
a636 1
	ahc_check_extport(ahc, &sxfrctl1);
d657 1
a657 2
		if ((ahc->flags & AHC_NO_BIOS_INIT) == 0
		 && scsiseq != 0) {
d689 4
a692 4
	if (ahc_init(ahc))
		goto error_out;

	ahc_attach(ahc);
d694 2
a695 1
	return;
d697 4
a700 4
 error_out:
	ahc_free(ahc);
	return;
}
d702 6
a707 5
static int
ahc_9005_subdevinfo_valid(uint16_t device, uint16_t vendor,
			  uint16_t subdevice, uint16_t subvendor)
{
	int result;
d709 2
a710 6
	/* Default to invalid. */
	result = 0;
	if (vendor == 0x9005
	 && subvendor == 0x9005
         && subdevice != device
         && SUBID_9005_TYPE_KNOWN(subdevice) != 0) {
d712 1
a712 19
		switch (SUBID_9005_TYPE(subdevice)) {
		case SUBID_9005_TYPE_MB:
			break;
		case SUBID_9005_TYPE_CARD:
		case SUBID_9005_TYPE_LCCARD:
			/*
			 * Currently only trust Adaptec cards to
			 * get the sub device info correct.
			 */
			if (DEVID_9005_TYPE(device) == DEVID_9005_TYPE_HBA)
				result = 1;
			break;
		case SUBID_9005_TYPE_RAID:
			break;
		default:
			break;
		}
	}
	return (result);
d715 37
a751 7

/*
 * Test for the presense of external sram in an
 * "unshared" configuration.
 */
static int
ahc_ext_scbram_present(struct ahc_softc *ahc)
d757 4
a761 2
	chip = ahc->chip & AHC_CHIPID_MASK;
	devconfig = pci_conf_read(ahc->bd->pc, ahc->bd->tag, DEVCONFIG);
a765 8
	else if (chip == AHC_AIC7895 || chip == AHC_AIC7895C)
		/*
		 * External SCBRAM arbitration is flakey
		 * on these chips.  Unfortunately this means
		 * we don't use the extra SCB ram space on the
		 * 3940AUW.
		 */
		ramps = 0;
d780 6
a785 2
ahc_scbram_config(struct ahc_softc *ahc, int enable, int pcheck,
		  int fast, int large)
d787 1
a787 1
	uint32_t devconfig;
d794 1
a794 1
		ahc_outb(ahc, SCBBADDR, ahc->bd->func);
d797 1
a797 4
	ahc->flags &= ~AHC_LSCBS_ENABLED;
	if (large)
		ahc->flags |= AHC_LSCBS_ENABLED;
	devconfig = pci_conf_read(ahc->bd->pc, ahc->bd->tag, DEVCONFIG);
d830 1
a830 1
	pci_conf_write(ahc->bd->pc, ahc->bd->tag, DEVCONFIG, devconfig);
d839 2
a840 1
ahc_probe_ext_scbram(struct ahc_softc *ahc)
d927 1
a927 1
	if (1/*bootverbose*/ && enable) {
a935 1
#if 0
d937 2
a938 2
 * Perform some simple tests that should catch situations where
 * our registers are invalidly mapped.
d940 27
a966 64
int
ahc_pci_test_register_access(struct ahc_softc *ahc)
{
	int	 error;
	u_int	 status1;
	uint32_t cmd;
	uint8_t	 hcntrl;

	error = EIO;

	/*
	 * Enable PCI error interrupt status, but suppress NMIs
	 * generated by SERR raised due to target aborts.
	 */
	cmd = pci_conf_read(ahc->bd->pc, ahc->bd->tag, PCIR_COMMAND);
	pci_conf_write(ahc->bd->pc, ahc->bd->tag, PCIR_COMMAND,
		       cmd & ~PCIM_CMD_SERRESPEN);

	/*
	 * First a simple test to see if any
	 * registers can be read.  Reading
	 * HCNTRL has no side effects and has
	 * at least one bit that is guaranteed to
	 * be zero so it is a good register to
	 * use for this test.
	 */
	hcntrl = ahc_inb(ahc, HCNTRL);
	if (hcntrl == 0xFF)
		goto fail;

	/*
	 * Next create a situation where write combining
	 * or read prefetching could be initiated by the
	 * CPU or host bridge.  Our device does not support
	 * either, so look for data corruption and/or flagged
	 * PCI errors.
	 */
	ahc_outb(ahc, HCNTRL, hcntrl|PAUSE);
	while (ahc_is_paused(ahc) == 0)
		;
	ahc_outb(ahc, SEQCTL, PERRORDIS);
	ahc_outb(ahc, SCBPTR, 0);
	ahc_outl(ahc, SCB_BASE, 0x5aa555aa);
	if (ahc_inl(ahc, SCB_BASE) != 0x5aa555aa)
		goto fail;

	status1 = pci_conf_read(ahc->bd->pc, ahc->bd->tag,
				PCI_COMMAND_STATUS_REG + 1);
	if ((status1 & STA) != 0)
		goto fail;

	error = 0;

fail:
	/* Silently clear any latched errors. */
	status1 = pci_conf_read(ahc->bd->pc, ahc->bd->tag, PCI_COMMAND_STATUS_REG + 1);
	ahc_pci_write_config(ahc->dev_softc, PCIR_STATUS + 1,
			     status1, /*bytes*/1);
	ahc_outb(ahc, CLRINT, CLRPARERR);
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS);
	ahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND, cmd, /*bytes*/2);
	return (error);
}
#endif
d968 37
a1004 5
void
ahc_pci_intr(struct ahc_softc *ahc)
{
	u_int error;
	u_int status1;
d1006 34
a1039 3
	error = ahc_inb(ahc, ERROR);
	if ((error & PCIERRSTAT) == 0)
		return;
d1041 28
a1068 1
	status1 = pci_conf_read(ahc->bd->pc, ahc->bd->tag, PCI_COMMAND_STATUS_REG);
d1070 21
a1090 3
	printf("%s: PCI error Interrupt at seqaddr = 0x%x\n",
	      ahc_name(ahc),
	      ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));
d1092 5
a1096 20
	if (status1 & DPE) {
		printf("%s: Data Parity Error Detected during address "
		       "or write data phase\n", ahc_name(ahc));
	}
	if (status1 & SSE) {
		printf("%s: Signal System Error Detected\n", ahc_name(ahc));
	}
	if (status1 & RMA) {
		printf("%s: Received a Master Abort\n", ahc_name(ahc));
	}
	if (status1 & RTA) {
		printf("%s: Received a Target Abort\n", ahc_name(ahc));
	}
	if (status1 & STA) {
		printf("%s: Signaled a Target Abort\n", ahc_name(ahc));
	}
	if (status1 & DPR) {
		printf("%s: Data Parity Error has been reported via PERR#\n",
		       ahc_name(ahc));
	}
d1098 20
a1117 2
	/* Clear latched errors. */
	pci_conf_write(ahc->bd->pc, ahc->bd->tag,  PCI_COMMAND_STATUS_REG, status1);
d1119 5
a1123 6
	if ((status1 & (DPE|SSE|RMA|RTA|STA|DPR)) == 0) {
		printf("%s: Latched PCIERR interrupt with "
		       "no status bits set\n", ahc_name(ahc)); 
	} else {
		ahc_outb(ahc, CLRINT, CLRPARERR);
	}
d1125 2
a1126 2
	ahc_unpause(ahc);
}
d1128 2
a1129 4
static int
ahc_aic785X_setup(struct ahc_softc *ahc)
{
	uint8_t rev;
d1131 9
a1139 9
	ahc->channel = 'A';
	ahc->chip = AHC_AIC7850;
	ahc->features = AHC_AIC7850_FE;
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
	rev = PCI_REVISION(ahc->bd->class);
	if (rev >= 1)
		ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
	return (0);
}
d1141 20
a1160 4
static int
ahc_aic7860_setup(struct ahc_softc *ahc)
{
	uint8_t rev;
d1162 11
a1172 9
	ahc->channel = 'A';
	ahc->chip = AHC_AIC7860;
	ahc->features = AHC_AIC7860_FE;
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
	rev = PCI_REVISION(ahc->bd->class);
	if (rev >= 1)
		ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
	return (0);
}
d1174 11
a1184 4
static int
ahc_apa1480_setup(struct ahc_softc *ahc)
{
	int error;
d1186 5
a1190 5
	error = ahc_aic7860_setup(ahc);
	if (error != 0)
		return (error);
	ahc->features |= AHC_REMOVABLE;
	return (0);
d1193 5
a1197 2
static int
ahc_aic7870_setup(struct ahc_softc *ahc)
d1199 3
d1203 63
a1265 6
	ahc->channel = 'A';
	ahc->chip = AHC_AIC7870;
	ahc->features = AHC_AIC7870_FE;
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
	return (0);
}
d1267 2
a1268 4
static int
ahc_aha394X_setup(struct ahc_softc *ahc)
{
	int error;
d1270 16
a1285 5
	error = ahc_aic7870_setup(ahc);
	if (error == 0)
		error = ahc_aha394XX_setup(ahc);
	return (error);
}
d1287 10
a1296 4
static int
ahc_aha398X_setup(struct ahc_softc *ahc)
{
	int error;
d1298 16
a1313 5
	error = ahc_aic7870_setup(ahc);
	if (error == 0)
		error = ahc_aha398XX_setup(ahc);
	return (error);
}
d1315 9
a1323 4
static int
ahc_aha494X_setup(struct ahc_softc *ahc)
{
	int error;
d1325 16
a1340 5
	error = ahc_aic7870_setup(ahc);
	if (error == 0)
		error = ahc_aha494XX_setup(ahc);
	return (error);
}
d1342 18
a1359 4
static int
ahc_aic7880_setup(struct ahc_softc *ahc)
{
	uint8_t rev;
d1361 6
a1366 12
	ahc->channel = 'A';
	ahc->chip = AHC_AIC7880;
	ahc->features = AHC_AIC7880_FE;
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
	rev = PCI_REVISION(ahc->bd->class);
	if (rev >= 1) {
		ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
	} else {
		ahc->bugs |= AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
	}
	return (0);
}
d1368 5
a1372 3
static int
ahc_aha2940Pro_setup(struct ahc_softc *ahc)
{
d1374 9
a1382 3
	ahc->flags |= AHC_INT50_SPEEDFLEX;
	return (ahc_aic7880_setup(ahc));
}
d1384 3
a1386 4
static int
ahc_aha394XU_setup(struct ahc_softc *ahc)
{
	int error;
d1388 6
a1393 5
	error = ahc_aic7880_setup(ahc);
	if (error == 0)
		error = ahc_aha394XX_setup(ahc);
	return (error);
}
d1395 9
a1403 4
static int
ahc_aha398XU_setup(struct ahc_softc *ahc)
{
	int error;
d1405 5
a1409 5
	error = ahc_aic7880_setup(ahc);
	if (error == 0)
		error = ahc_aha398XX_setup(ahc);
	return (error);
}
d1411 4
a1414 13
static int
ahc_aic7890_setup(struct ahc_softc *ahc)
{
	uint8_t rev;

	ahc->channel = 'A';
	ahc->chip = AHC_AIC7890;
	ahc->features = AHC_AIC7890_FE;
	ahc->flags |= AHC_NEWEEPROM_FMT;
	rev = PCI_REVISION(ahc->bd->class);
	if (rev == 0)
		ahc->bugs |= AHC_AUTOFLUSH_BUG|AHC_CACHETHEN_BUG;
	return (0);
d1417 9
a1425 2
static int
ahc_aic7892_setup(struct ahc_softc *ahc)
d1427 1
d1429 13
a1441 6
	ahc->channel = 'A';
	ahc->chip = AHC_AIC7892;
	ahc->features = AHC_AIC7892_FE;
	ahc->flags |= AHC_NEWEEPROM_FMT;
	ahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;
	return (0);
d1444 8
a1451 2
static int
ahc_aic7895_setup(struct ahc_softc *ahc)
d1453 1
a1453 1
	uint8_t rev;
a1454 1
	ahc->channel = (ahc->bd->func == 1) ? 'B' : 'A';
d1456 5
a1460 1
	 * The 'C' revision of the aic7895 has a few additional features.
d1462 1
a1462 6
	rev = PCI_REVISION(ahc->bd->class);
	if (rev >= 4) {
		ahc->chip = AHC_AIC7895C;
		ahc->features = AHC_AIC7895C_FE;
	} else  {
		u_int command;
d1464 8
a1471 2
		ahc->chip = AHC_AIC7895;
		ahc->features = AHC_AIC7895_FE;
a1472 11
		/*
		 * The BIOS disables the use of MWI transactions
		 * since it does not have the MWI bug work around
		 * we have.  Disabling MWI reduces performance, so
		 * turn it on again.
		 */
		command = pci_conf_read(ahc->bd->pc, ahc->bd->tag, PCI_COMMAND_STATUS_REG);
		command |=  PCI_COMMAND_INVALIDATE_ENABLE;
		pci_conf_write(ahc->bd->pc, ahc->bd->tag, PCI_COMMAND_STATUS_REG, command);
		ahc->bugs |= AHC_PCI_MWI_BUG;
	}
d1474 2
a1475 2
	 * XXX Does CACHETHEN really not work???  What about PCI retry?
	 * on C level chips.  Need to test, but for now, play it safe.
d1477 1
a1477 5
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_PCI_2_1_RETRY_BUG
		  |  AHC_CACHETHEN_BUG;

#if 0
	uint32_t devconfig;
d1480 3
a1482 2
	 * Cachesize must also be zero due to stray DAC
	 * problem when sitting behind some bridges.
d1484 3
a1486 7
	pci_conf_write(ahc->bd->pc, ahc->bd->tag, CSIZE_LATTIME, 0);
	devconfig = pci_conf_read(ahc->bd->pc, ahc->bd->tag, DEVCONFIG);
	devconfig |= MRDCEN;
	pci_conf_write(ahc->bd->pc, ahc->bd->tag, DEVCONFIG, devconfig);
#endif
	ahc->flags |= AHC_NEWEEPROM_FMT;
	return (0);
d1489 17
a1505 9
static int
ahc_aic7896_setup(struct ahc_softc *ahc)
{
	ahc->channel = (ahc->bd->func == 1) ? 'B' : 'A';
	ahc->chip = AHC_AIC7896;
	ahc->features = AHC_AIC7896_FE;
	ahc->flags |= AHC_NEWEEPROM_FMT;
	ahc->bugs |= AHC_CACHETHEN_DIS_BUG;
	return (0);
d1508 32
a1539 9
static int
ahc_aic7899_setup(struct ahc_softc *ahc)
{
	ahc->channel = (ahc->bd->func == 1) ? 'B' : 'A';
	ahc->chip = AHC_AIC7899;
	ahc->features = AHC_AIC7899_FE;
	ahc->flags |= AHC_NEWEEPROM_FMT;
	ahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;
	return (0);
d1542 21
a1562 10
static int
ahc_aha29160C_setup(struct ahc_softc *ahc)
{
	int error;

	error = ahc_aic7899_setup(ahc);
	if (error != 0)
		return (error);
	ahc->features |= AHC_REMOVABLE;
	return (0);
d1566 3
a1568 1
ahc_raid_setup(struct ahc_softc *ahc)
d1570 1
a1570 3
	printf("RAID functionality unsupported\n");
	return (ENXIO);
}
d1572 3
a1574 3
static int
ahc_aha394XX_setup(struct ahc_softc *ahc)
{
d1576 15
a1590 12
	switch (ahc->bd->dev) {
	case AHC_394X_SLOT_CHANNEL_A:
		ahc->channel = 'A';
		break;
	case AHC_394X_SLOT_CHANNEL_B:
		ahc->channel = 'B';
		break;
	default:
		printf("adapter at unexpected slot %d\n"
		       "unable to map to a channel\n",
		       ahc->bd->dev);
		ahc->channel = 'A';
d1592 1
a1592 1
	return (0);
d1595 3
a1597 2
static int
ahc_aha398XX_setup(struct ahc_softc *ahc)
d1599 3
d1603 13
a1615 20
	switch (ahc->bd->dev) {
	case AHC_398X_SLOT_CHANNEL_A:
		ahc->channel = 'A';
		break;
	case AHC_398X_SLOT_CHANNEL_B:
		ahc->channel = 'B';
		break;
	case AHC_398X_SLOT_CHANNEL_C:
		ahc->channel = 'C';
		break;
	default:
		printf("adapter at unexpected slot %d\n"
		       "unable to map to a channel\n",
		       ahc->bd->dev);
		ahc->channel = 'A';
		break;
	}
	ahc->flags |= AHC_LARGE_SEEPROM;
	return (0);
}
d1617 3
a1619 2
static int
ahc_aha494XX_setup(struct ahc_softc *ahc)
d1621 9
d1631 31
a1661 18
	switch (ahc->bd->dev) {
	case AHC_494X_SLOT_CHANNEL_A:
		ahc->channel = 'A';
		break;
	case AHC_494X_SLOT_CHANNEL_B:
		ahc->channel = 'B';
		break;
	case AHC_494X_SLOT_CHANNEL_C:
		ahc->channel = 'C';
		break;
	case AHC_494X_SLOT_CHANNEL_D:
		ahc->channel = 'D';
		break;
	default:
		printf("adapter at unexpected slot %d\n"
		       "unable to map to a channel\n",
		       ahc->bd->dev);
		ahc->channel = 'A';
d1663 4
a1666 2
	ahc->flags |= AHC_LARGE_SEEPROM;
	return (0);
@


1.11
log
@2940UWPro support
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.10 1999/08/27 23:29:52 downsj Exp $	*/
d629 5
a633 3
	sd.sd_iot = ahc->sc_iot;
	sd.sd_ioh = ahc->sc_ioh;
	sd.sd_offset = SEECTL;
d635 2
d731 1
a731 1
	while (--wait && ((SEEPROM_INB(sd) & sd->sd_RDY) == 0)) {
d734 1
a734 1
	if ((SEEPROM_INB(sd) & sd->sd_RDY) == 0) {
@


1.10
log
@Add device ID for 398XUW, such as found on some RAID controllers.
(This allows, for instance, an AAA-131CF to function as a normal SCSI
controller with this driver.)
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.9 1998/01/07 11:03:25 deraadt Exp $	*/
d104 1
d247 3
d290 1
d364 1
@


1.9
log
@now this is really pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.8 1998/01/05 13:35:18 deraadt Exp $	*/
d92 1
d274 1
d368 1
@


1.8
log
@new style pci attach printing
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.7 1997/08/05 05:38:22 niklas Exp $	*/
d455 1
a455 1
		printf(", couldn't map interrupt\n");
d467 1
a467 1
		printf(", couldn't establish interrupt");
d475 1
a475 1
		printf(", %s\n", intrstr);
@


1.7
log
@Make compile on alpha
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.6 1996/11/28 23:28:01 niklas Exp $	*/
a400 1
	printf("\n");
d455 1
a455 1
		printf("%s: couldn't map interrupt\n", ahc->sc_dev.dv_xname);
d467 1
a467 2
		printf("%s: couldn't establish interrupt",
		       ahc->sc_dev.dv_xname);
d475 1
a475 2
		printf("%s: interrupting at %s\n", ahc->sc_dev.dv_xname,
		       intrstr);
@


1.6
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_pci.c,v 1.9 1996/10/21 22:56:24 thorpej Exp $	*/
d461 5
a465 3
	ahc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, ahc_intr, ahc
#ifdef __OpenBSD__
	    , ahc->sc_dev.dv_xname
a466 1
	    );
@


1.5
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 3
a33 2
 *
 *	$Id: ahc_pci.c,v 1.4 1996/10/16 12:40:55 deraadt Exp $
d47 1
a47 1
#include <machine/bus.old.h>
d77 5
d83 4
d94 1
d230 3
d275 1
d304 1
d308 3
a310 3
	bus_io_addr_t iobase;
	bus_io_size_t iosize;
	bus_io_handle_t ioh;
d335 1
a335 1
	if (bus_io_map(pa->pa_bc, iobase, iosize, &ioh))
d363 3
d392 1
a392 1
	our_id = bus_io_read_1(pa->pa_bc, ioh, SCSIID) & OID;
d394 2
a395 1
		ultra_enb = bus_io_read_1(pa->pa_bc, ioh, SXFRCTL0) & ULTRAEN;
d402 1
a402 1
	ahc_reset(ahc->sc_dev.dv_xname, pa->pa_bc, ioh);
d452 1
a452 1
	ahc_construct(ahc, pa->pa_bc, ioh, ahc_t, ahc_f);
d509 1
d513 1
a513 5
			/*
			 * Use defaults, if the chip wasn't initialized by
			 * a BIOS.
			 */
			ahc->flags |= AHC_USEDEFAULTS;
d622 1
a622 1
	sd.sd_bc = ahc->sc_bc;
@


1.4
log
@unused var
@
text
@d32 1
a32 1
 *	$Id: ahc_pci.c,v 1.3 1996/08/21 22:27:49 deraadt Exp $
d46 1
a46 1
#include <machine/bus.h>
@


1.3
log
@check for __OpenBSD__, prep for tossing __NetBSD__?
@
text
@d32 1
a32 1
 *	$Id: ahc_pci.c,v 1.2 1996/06/27 21:15:55 shawn Exp $
a291 1
	int unit = ahc->sc_dev.dv_unit;
@


1.2
log
@new 2940 driver merged from freebsd sources 960623
@
text
@d32 1
a32 1
 *	$Id: aic7870.c,v 1.37 1996/06/08 06:55:55 gibbs Exp $
d38 1
a38 1
#if NPCI > 0 || defined(__NetBSD__)
d44 1
a44 1
#if defined(__NetBSD__)
d67 1
a67 1
#elif defined(__NetBSD__)
d241 1
a241 1
#elif defined(__NetBSD__)
d280 1
a280 1
#elif defined(__NetBSD__)
d289 1
a289 1
#elif defined(__NetBSD__)
d317 1
a317 1
#elif defined(__NetBSD__)
d326 1
a326 1
#elif defined(__NetBSD__)
d381 1
a381 1
#elif defined(__NetBSD__)
d389 1
a389 1
#elif defined(__NetBSD__)
d417 1
a417 1
#elif defined(__NetBSD__)
d432 1
a432 1
#elif defined(__NetBSD__)
d605 1
a605 1
#elif defined(__NetBSD__)
@


1.1
log
@sync 0521
@
text
@a0 2
/*	$NetBSD: ahc_pci.c,v 1.2 1996/05/20 00:56:39 thorpej Exp $	*/

d31 2
a46 1
#ifdef __alpha__
a47 1
#endif
d177 2
a423 35
	/*
	 * Ensure that we are using good values for the PCI burst size
	 * and latency timer.
	 */
	{
#if defined(__FreeBSD__)
		u_long csize_lattime = pci_conf_read(config_id, CSIZE_LATTIME);
#elif defined(__NetBSD__)
		u_long csize_lattime =
			pci_conf_read(pa->pa_pc, pa->pa_tag, CSIZE_LATTIME);
#endif

		if((csize_lattime & CACHESIZE) == 0) {
			/* default to 8DWDs. What's the PCI define for this? */
			csize_lattime |= 8;
		}
		if((csize_lattime & LATTIME) == 0) {
			/* Default to 64 PCLKS (is this a good value?) */
			/* This may also be availble in the SEEPROM?? */
			csize_lattime |= (64 << 8);
		}
		if(bootverbose)
			printf("ahc%d: BurstLen = %ldDWDs, "
			       "Latency Timer = %ldPCLKS\n",
				unit,
				csize_lattime & CACHESIZE,
				(csize_lattime >> 8) & 0xff);
#if defined(__FreeBSD__)
		pci_conf_write(config_id, CSIZE_LATTIME, csize_lattime);
#elif defined(__NetBSD__)
		pci_conf_write(pa->pa_pc, pa->pa_tag, CSIZE_LATTIME,
			       csize_lattime);
#endif
	}

d540 1
a540 1
                        	if(AHC_INB(ahc, i) != 0xff)
d543 11
a553 1
			if(i != 0x60) {
a585 1
	return;
d654 1
a654 1
	        for(i = 0; i <= max_targ; i++){
d687 33
@
