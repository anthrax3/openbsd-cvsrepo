head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.12
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.10
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.4
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.4
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.10.0.6
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.4
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.9.0.4
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5;
locks; strict;
comment	@ * @;


1.20
date	2014.10.20.19.19.20;	author miod;	state Exp;
branches;
next	1.19;
commitid	Sm3Pkodk6fU0diOs;

1.19
date	2014.09.13.05.17.48;	author jsg;	state Exp;
branches;
next	1.18;
commitid	T0UNNwZrQQgqguE1;

1.18
date	2013.08.25.02.15.10;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2012.03.11.13.33.06;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2010.03.02.10.52.27;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2009.12.15.20.26.21;	author jasper;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.17.06.56.56;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.11.20.24.47;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.23.08.49.27;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2006.09.20.19.45.16;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.13.15.56.01;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.11.23.50.59;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.23.14.46.05;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.07.02.17.59;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2005.08.09.04.10.10;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2005.08.05.17.00.09;	author mpf;	state Exp;
branches;
next	1.3;

1.3
date	2005.08.02.23.48.59;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.09.21.47.20;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2005.07.06.01.52.13;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Be sure to return if the pci interrupt can't be mapped, instead of falling
through the remainder of the attachment logic.
@
text
@/*	$OpenBSD: ciss_pci.c,v 1.19 2014/09/13 05:17:48 jsg Exp $	*/

/*
 * Copyright (c) 2005 Michael Shalayeff
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>

#include <machine/bus.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>

#include <dev/ic/cissreg.h>
#include <dev/ic/cissvar.h>

#define	CISS_BAR	0x10

int	ciss_pci_match(struct device *, void *, void *);
void	ciss_pci_attach(struct device *, struct device *, void *);
int	ciss_activate(struct device *, int);

struct cfattach ciss_pci_ca = {
	sizeof(struct ciss_softc), ciss_pci_match, ciss_pci_attach,
	NULL, ciss_activate
};

const struct pci_matchid ciss_pci_devices[] = {
	{ PCI_VENDOR_COMPAQ,	PCI_PRODUCT_COMPAQ_CSA532 },
	{ PCI_VENDOR_COMPAQ,	PCI_PRODUCT_COMPAQ_CSA5300 },
	{ PCI_VENDOR_COMPAQ,	PCI_PRODUCT_COMPAQ_CSA5300_2 },
	{ PCI_VENDOR_COMPAQ,	PCI_PRODUCT_COMPAQ_CSA5312 },
	{ PCI_VENDOR_COMPAQ,	PCI_PRODUCT_COMPAQ_CSA5i },
	{ PCI_VENDOR_COMPAQ,	PCI_PRODUCT_COMPAQ_CSA5i_2 },
	{ PCI_VENDOR_COMPAQ,	PCI_PRODUCT_COMPAQ_CSA6i },
	{ PCI_VENDOR_COMPAQ,	PCI_PRODUCT_COMPAQ_CSA641 },
	{ PCI_VENDOR_COMPAQ,	PCI_PRODUCT_COMPAQ_CSA642 },
	{ PCI_VENDOR_COMPAQ,	PCI_PRODUCT_COMPAQ_CSA6400 },
	{ PCI_VENDOR_COMPAQ,	PCI_PRODUCT_COMPAQ_CSA6400EM },
	{ PCI_VENDOR_COMPAQ,	PCI_PRODUCT_COMPAQ_CSA6422 },
	{ PCI_VENDOR_COMPAQ,	PCI_PRODUCT_COMPAQ_CSA64XX },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAE200 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAE200I_1 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAE200I_2 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAE200I_3 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAE200I_4 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAE500_1 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAE500_2 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAH240 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAH240AR },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAH240TR },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAH241 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAH244BR },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP212 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP220I },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP222 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP224BR },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP230I },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP240TR },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP246BR },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP410 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP410I },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP411 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP420 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP420I },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP421 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP430 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP430I },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP431 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP440 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP440AR },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP441 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP530 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP531 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP542T },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP600 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP700M },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP711M },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP712M },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP721M },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP731M },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP741M },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP800 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP812 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP822 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP830 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP830I },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP840 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP841 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAV100 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSA_1 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSA_2 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSA_3 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSA_4 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSA_5 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSA_6 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSA_7 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSA_8 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSA_9 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSA_10 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSA_11 }
};

int
ciss_pci_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	return pci_matchbyid(pa, ciss_pci_devices, nitems(ciss_pci_devices));
}

void
ciss_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct ciss_softc *sc = (struct ciss_softc *)self;
	struct pci_attach_args *pa = aux;
	bus_size_t size, cfgsz;
	pci_intr_handle_t ih;
	const char *intrstr;
	int cfg_bar, memtype;
	pcireg_t reg;

	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, CISS_BAR);
	if (pci_mapreg_map(pa, CISS_BAR, memtype, 0,
	    &sc->iot, &sc->ioh, NULL, &size, 0)) {
		printf(": can't map controller mem space\n");
		return;
	}
	sc->dmat = pa->pa_dmat;

	sc->iem = CISS_READYENA;
	reg = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);
	if (PCI_VENDOR(reg) == PCI_VENDOR_COMPAQ &&
	    (PCI_PRODUCT(reg) == PCI_PRODUCT_COMPAQ_CSA5i ||
	     PCI_PRODUCT(reg) == PCI_PRODUCT_COMPAQ_CSA532 ||
	     PCI_PRODUCT(reg) == PCI_PRODUCT_COMPAQ_CSA5312))
		sc->iem = CISS_READYENAB;

	cfg_bar = bus_space_read_2(sc->iot, sc->ioh, CISS_CFG_BAR);
	sc->cfgoff = bus_space_read_4(sc->iot, sc->ioh, CISS_CFG_OFF);
	if (cfg_bar != CISS_BAR) {
		if (pci_mapreg_map(pa, cfg_bar, PCI_MAPREG_TYPE_MEM, 0,
		    NULL, &sc->cfg_ioh, NULL, &cfgsz, 0)) {
			printf(": can't map controller config space\n");  
			bus_space_unmap(sc->iot, sc->ioh, size);
			return;
		}
	} else {
		sc->cfg_ioh = sc->ioh;
		cfgsz = size;
	}

	if (sc->cfgoff + sizeof(struct ciss_config) > cfgsz) {
		printf(": unfit config space\n");
		bus_space_unmap(sc->iot, sc->ioh, size);
		if (cfg_bar != CISS_BAR)
			bus_space_unmap(sc->iot, sc->cfg_ioh, cfgsz);
		return;
	}

	/* disable interrupts until ready */
	bus_space_write_4(sc->iot, sc->ioh, CISS_IMR,
	    bus_space_read_4(sc->iot, sc->ioh, CISS_IMR) | sc->iem);

	if (pci_intr_map(pa, &ih)) {
		printf(": can't map interrupt\n");
		bus_space_unmap(sc->iot, sc->ioh, size);
		if (cfg_bar != CISS_BAR)
			bus_space_unmap(sc->iot, sc->cfg_ioh, cfgsz);
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, ciss_intr, sc,
	    sc->sc_dev.dv_xname);
	if (!sc->sc_ih) {
		printf(": can't establish interrupt");
		if (intrstr)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(sc->iot, sc->ioh, size);
		if (cfg_bar != CISS_BAR)
			bus_space_unmap(sc->iot, sc->cfg_ioh, cfgsz);
		return;
	}

	printf(": %s\n%s", intrstr, sc->sc_dev.dv_xname);

	if (ciss_attach(sc)) {
		pci_intr_disestablish(pa->pa_pc, sc->sc_ih);
		sc->sc_ih = NULL;
		bus_space_unmap(sc->iot, sc->ioh, size);
		if (cfg_bar != CISS_BAR)
			bus_space_unmap(sc->iot, sc->cfg_ioh, cfgsz);
		return;
	}

	/* enable interrupts now */
	bus_space_write_4(sc->iot, sc->ioh, CISS_IMR,
	    bus_space_read_4(sc->iot, sc->ioh, CISS_IMR) & ~sc->iem);
}

int
ciss_activate(struct device *self, int act)
{
	int ret = 0;

	ret = config_activate_children(self, act);

	switch (act) {
	case DVACT_POWERDOWN:
		ciss_shutdown(self);
		break;
	}

	return (ret);
}
@


1.19
log
@Add HP Gen9 Smart Array/Smart HBA devices.
Untested, but there doesn't seem to have been any changes to
the firmware interface so these should work without additional
changes, as was the case with the last few generations.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss_pci.c,v 1.18 2013/08/25 02:15:10 jsg Exp $	*/
d204 1
@


1.18
log
@new ciss devices from Scott Benesh of HP via FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss_pci.c,v 1.17 2013/05/30 16:15:02 deraadt Exp $	*/
d70 5
d78 1
d80 2
d91 3
d96 1
d103 1
d109 2
@


1.17
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss_pci.c,v 1.16 2012/03/11 13:33:06 jsg Exp $	*/
d73 1
d80 5
d90 1
d94 2
@


1.16
log
@add PCI ids for HP Smart Array P220i/P222/P420/P420i/P421/P721m/P822
from Scott Benesh of HP via FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss_pci.c,v 1.15 2010/03/02 10:52:27 sthen Exp $	*/
d42 1
d45 2
a46 1
	sizeof(struct ciss_softc), ciss_pci_match, ciss_pci_attach
d196 16
@


1.15
log
@- Add PCI id for the Smart Array P700m adapter.
- Rename one of the existing Smart Array entries (0x3237) to reflect
  its name as being a Smart Array E500 adapter.

From FreeBSD

- Add a Smart Array E200i PCI id missing from ciss_pci.c, although it
  has been in pcidevs for some time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss_pci.c,v 1.14 2009/12/15 20:26:21 jasper Exp $	*/
d69 2
d74 3
d81 1
d84 1
@


1.14
log
@- instead of rolling a macro that is functional equivalent to nitems(),
just use nitems(). (this leaves NENTS() alone for now)

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss_pci.c,v 1.13 2008/11/17 06:56:56 brad Exp $	*/
d65 3
a67 1
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAE500 },
d73 1
d89 1
a89 2
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSA_11 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSA_12 }
@


1.13
log
@Add the HP Smart Array P711m/P712m PCI ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss_pci.c,v 1.12 2008/06/11 20:24:47 jsg Exp $	*/
a88 1
#define	CISS_PCI_NDEVS	sizeof(ciss_pci_devices)/sizeof(ciss_pci_devices[0])
d95 1
a95 1
	return pci_matchbyid(pa, ciss_pci_devices, CISS_PCI_NDEVS);
@


1.12
log
@Add a bunch of new ciss devices from Scott Benesh at HP via FreeBSD.
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss_pci.c,v 1.11 2008/05/23 08:49:27 brad Exp $	*/
d71 2
@


1.11
log
@Simplify the combination use of pci_mapreg_type()/pci_mapreg_map() as
suggested by dlg@@ awhile ago.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss_pci.c,v 1.10 2006/09/20 19:45:16 brad Exp $	*/
d66 4
d72 1
@


1.10
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss_pci.c,v 1.9 2005/12/13 15:56:01 brad Exp $	*/
a103 5
	if (memtype != (PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT) &&
	    memtype != (PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT)) {
		printf(": wrong BAR type\n");
		return;
	}
d106 1
a106 1
		printf(": can't map controller i/o space\n");
@


1.9
log
@- Add a whole bunch of new PCI ids.
- Remove the version ("valance") check as it is not necessary.

From FreeBSD

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss_pci.c,v 1.8 2005/12/11 23:50:59 brad Exp $	*/
d65 1
d80 1
a80 2
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSA_12 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSA_13 },
@


1.8
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss_pci.c,v 1.7 2005/11/23 14:46:05 mickey Exp $	*/
d54 1
d61 6
a67 2
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP800 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAP600 },
d69 2
d72 9
@


1.7
log
@hp sa p600 sas; from Srebrenko Sehic <haver@@insecure.dk>
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss_pci.c,v 1.6 2005/09/07 02:17:59 mickey Exp $	*/
d63 2
a64 2
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSASP600 },
	{ PCI_VENDOR_HP,	PCI_PRODUCT_HP_HPSAE400 },
@


1.6
log
@kill dead func proto
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss_pci.c,v 1.5 2005/08/09 04:10:10 mickey Exp $	*/
d63 1
@


1.5
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss_pci.c,v 1.4 2005/08/05 17:00:09 mpf Exp $	*/
a39 1
int	ciss_pci_find_device(void *);
@


1.4
log
@Add one more Compaq Smart Array 6i.
Found in an HP DL380 G4 and works nicely.
OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss_pci.c,v 1.3 2005/08/02 23:48:59 mickey Exp $	*/
a132 5

	/* enable bus mastering (should not it be mi?) */
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG) |
	    PCI_COMMAND_MASTER_ENABLE);
@


1.3
log
@int mask is matched on the subsys ids not prod ids
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss_pci.c,v 1.2 2005/07/09 21:47:20 mickey Exp $	*/
d60 1
@


1.2
log
@handle 64bit bar; found by mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ciss_pci.c,v 1.1 2005/07/06 01:52:13 mickey Exp $	*/
d84 1
d100 5
a104 4
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_COMPAQ &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_COMPAQ_CSA5i ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_COMPAQ_CSA532 ||
	     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_COMPAQ_CSA5312))
@


1.1
log
@smartarray 5* raid controller; does io but needs more work; commented out in configs for now
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d83 1
a83 1
	int cfg_bar;
d85 7
a91 1
	if (pci_mapreg_map(pa, CISS_BAR, PCI_MAPREG_TYPE_MEM, 0,
@

