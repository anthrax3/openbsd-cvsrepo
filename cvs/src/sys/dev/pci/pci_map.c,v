head	1.31;
access;
symbols
	OPENBSD_6_2:1.31.0.12
	OPENBSD_6_2_BASE:1.31
	OPENBSD_6_1:1.31.0.10
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.8
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.4
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.30.0.12
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.30.0.10
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.8
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.4
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.29.0.8
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.6
	OPENBSD_5_0:1.29.0.4
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.2
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.28.0.4
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.24.0.4
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.23.0.4
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.20.0.6
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.4
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.2.0.6
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.4
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.31
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.30;
commitid	p4LJxGKbi0BU2cG6;

1.30
date	2013.02.09.20.43.33;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2010.09.06.12.30.35;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2010.02.28.21.37.54;	author miod;	state Exp;
branches
	1.28.4.1;
next	1.27;

1.27
date	2009.10.06.21.35.43;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.25.20.56.40;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2009.07.23.19.29.58;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2009.04.06.20.51.48;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.10.13.39.01;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.09.21.47.36;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2007.01.26.01.18.48;	author tsi;	state Exp;
branches;
next	1.19;

1.19
date	2006.12.12.18.28.54;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.07.31.11.06.33;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.04.18.07.29;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.31.08.58.05;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.07.01.07.41;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.07.01.04.49;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.19.22.28.40;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.15.20.18.10;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.09.19.52.04;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.27.20.59.15;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.28.15.26.23;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.28.15.14.08;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.13.08.25.25;	author niklas;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2001.06.12.15.40.32;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.20.17.39.04;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.09.16.09.09;	author chris;	state Exp;
branches;
next	1.2;

1.2
date	99.07.18.21.25.19;	author csapuntz;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	99.07.18.03.20.18;	author csapuntz;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.14.22.25.52;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.07.04.10.42.46;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2002.03.28.15.35.58;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2004.02.19.10.56.28;	author niklas;	state Exp;
branches;
next	;

1.6.4.1
date	2002.06.11.03.42.26;	author art;	state Exp;
branches;
next	;

1.28.4.1
date	2010.10.02.02.54.40;	author william;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*      $OpenBSD: pci_map.c,v 1.30 2013/02/09 20:43:33 miod Exp $     */
/*	$NetBSD: pci_map.c,v 1.7 2000/05/10 16:58:42 thorpej Exp $	*/

/*-
 * Copyright (c) 1998, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum; by William R. Studenmund; by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * PCI device mapping.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

#ifndef PCI_IO_START
#define PCI_IO_START	0
#endif

#ifndef PCI_IO_END
#define PCI_IO_END	0xffffffff
#endif

#ifndef PCI_MEM_START
#define PCI_MEM_START	0
#endif

#ifndef PCI_MEM_END
#define PCI_MEM_END	0xffffffff
#endif


int obsd_pci_io_find(pci_chipset_tag_t, pcitag_t, int, pcireg_t,
    bus_addr_t *, bus_size_t *, int *);
int obsd_pci_mem_find(pci_chipset_tag_t, pcitag_t, int, pcireg_t,
    bus_addr_t *, bus_size_t *, int *);

int
obsd_pci_io_find(pci_chipset_tag_t pc, pcitag_t tag, int reg, pcireg_t type,
    bus_addr_t *basep, bus_size_t *sizep, int *flagsp)
{
	pcireg_t address, mask, csr;
	int s;

	if (reg < PCI_MAPREG_START ||
#if 0
	    /*
	     * Can't do this check; some devices have mapping registers
	     * way out in left field.
	     */
	    reg >= PCI_MAPREG_END ||
#endif
	    (reg & 3))
		panic("pci_io_find: bad request");

	/*
	 * Section 6.2.5.1, `Address Maps', tells us that:
	 *
	 * 1) The builtin software should have already mapped the device in a
	 * reasonable way.
	 *
	 * 2) A device which wants 2^n bytes of memory will hardwire the bottom
	 * n bits of the address to 0.  As recommended, we write all 1s while
	 * the device is disabled and see what we get back.
	 */
	s = splhigh();
	csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	if (csr & PCI_COMMAND_IO_ENABLE)
		pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG,
		    csr & ~PCI_COMMAND_IO_ENABLE);
	address = pci_conf_read(pc, tag, reg);
	pci_conf_write(pc, tag, reg, 0xffffffff);
	mask = pci_conf_read(pc, tag, reg);
	pci_conf_write(pc, tag, reg, address);
	if (csr & PCI_COMMAND_IO_ENABLE)
		pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, csr);
	splx(s);

	if (PCI_MAPREG_TYPE(address) != PCI_MAPREG_TYPE_IO) {
#ifdef DEBUG
		printf("pci_io_find: expected type i/o, found mem\n");
#endif
		return (EINVAL);
	}

	if (PCI_MAPREG_IO_SIZE(mask) == 0) {
#ifdef DEBUG
		printf("pci_io_find: void region\n");
#endif
		return (ENOENT);
	}

	if (basep != 0)
		*basep = PCI_MAPREG_IO_ADDR(address);
	if (sizep != 0)
		*sizep = PCI_MAPREG_IO_SIZE(mask);
	if (flagsp != 0)
		*flagsp = 0;

	return (0);
}

int
obsd_pci_mem_find(pci_chipset_tag_t pc, pcitag_t tag, int reg, pcireg_t type,
    bus_addr_t *basep, bus_size_t *sizep, int *flagsp)
{
	pcireg_t address, mask, address1 = 0, mask1 = 0xffffffff, csr;
	u_int64_t waddress, wmask;
	int s, is64bit;

	is64bit = (PCI_MAPREG_MEM_TYPE(type) == PCI_MAPREG_MEM_TYPE_64BIT);

	if (reg < PCI_MAPREG_START ||
#if 0
	    /*
	     * Can't do this check; some devices have mapping registers
	     * way out in left field.
	     */
	    reg >= PCI_MAPREG_END ||
#endif
	    (reg & 3))
		panic("pci_mem_find: bad request");

	if (is64bit && (reg + 4) >= PCI_MAPREG_END)
		panic("pci_mem_find: bad 64-bit request");

	/*
	 * Section 6.2.5.1, `Address Maps', tells us that:
	 *
	 * 1) The builtin software should have already mapped the device in a
	 * reasonable way.
	 *
	 * 2) A device which wants 2^n bytes of memory will hardwire the bottom
	 * n bits of the address to 0.  As recommended, we write all 1s while
	 * the device is disabled and see what we get back.
	 */
	s = splhigh();
	csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	if (csr & PCI_COMMAND_MEM_ENABLE)
		pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG,
		    csr & ~PCI_COMMAND_MEM_ENABLE);
	address = pci_conf_read(pc, tag, reg);
	pci_conf_write(pc, tag, reg, PCI_MAPREG_MEM_ADDR_MASK);
	mask = pci_conf_read(pc, tag, reg);
	pci_conf_write(pc, tag, reg, address);
	if (is64bit) {
		address1 = pci_conf_read(pc, tag, reg + 4);
		pci_conf_write(pc, tag, reg + 4, 0xffffffff);
		mask1 = pci_conf_read(pc, tag, reg + 4);
		pci_conf_write(pc, tag, reg + 4, address1);
	}
	if (csr & PCI_COMMAND_MEM_ENABLE)
		pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, csr);
	splx(s);

	if (PCI_MAPREG_TYPE(address) != PCI_MAPREG_TYPE_MEM) {
#ifdef DEBUG
		printf("pci_mem_find: expected type mem, found i/o\n");
#endif
		return (EINVAL);
	}
	if (type != -1 && 
	    PCI_MAPREG_MEM_TYPE(address) != PCI_MAPREG_MEM_TYPE(type)) {
#ifdef DEBUG
		printf("pci_mem_find: expected mem type %08x, found %08x\n",
		    PCI_MAPREG_MEM_TYPE(type),
		    PCI_MAPREG_MEM_TYPE(address));
#endif
		return (EINVAL);
	}

	waddress = (u_int64_t)address1 << 32UL | address;
	wmask = (u_int64_t)mask1 << 32UL | mask;

	if ((is64bit && PCI_MAPREG_MEM64_SIZE(wmask) == 0) ||
	    (!is64bit && PCI_MAPREG_MEM_SIZE(mask) == 0)) {
#ifdef DEBUG
		printf("pci_mem_find: void region\n");
#endif
		return (ENOENT);
	}

	switch (PCI_MAPREG_MEM_TYPE(address)) {
	case PCI_MAPREG_MEM_TYPE_32BIT:
	case PCI_MAPREG_MEM_TYPE_32BIT_1M:
		break;
	case PCI_MAPREG_MEM_TYPE_64BIT:
		/*
		 * Handle the case of a 64-bit memory register on a
		 * platform with 32-bit addressing.  Make sure that
		 * the address assigned and the device's memory size
		 * fit in 32 bits.  We implicitly assume that if
		 * bus_addr_t is 64-bit, then so is bus_size_t.
		 */
		if (sizeof(u_int64_t) > sizeof(bus_addr_t) &&
		    (address1 != 0 || mask1 != 0xffffffff)) {
#ifdef DEBUG
			printf("pci_mem_find: 64-bit memory map which is "
			    "inaccessible on a 32-bit platform\n");
#endif
			return (EINVAL);
		}
		break;
	default:
#ifdef DEBUG
		printf("pci_mem_find: reserved mapping register type\n");
#endif
		return (EINVAL);
	}

	if (sizeof(u_int64_t) > sizeof(bus_addr_t)) {
		if (basep != 0)
			*basep = PCI_MAPREG_MEM_ADDR(address);
		if (sizep != 0)
			*sizep = PCI_MAPREG_MEM_SIZE(mask);
	} else {
		if (basep != 0)
			*basep = PCI_MAPREG_MEM64_ADDR(waddress);
		if (sizep != 0)
			*sizep = PCI_MAPREG_MEM64_SIZE(wmask);
	}
	if (flagsp != 0)
		*flagsp =
		    PCI_MAPREG_MEM_PREFETCHABLE(address) ?
		      BUS_SPACE_MAP_PREFETCHABLE : 0;

	return (0);
}

int
pci_io_find(pci_chipset_tag_t pc, pcitag_t pcitag, int reg,
    bus_addr_t *iobasep, bus_size_t *iosizep)
{
	return (obsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));
}

int
pci_mem_find(pci_chipset_tag_t pc, pcitag_t pcitag, int reg,
    bus_addr_t *membasep, bus_size_t *memsizep, int *cacheablep)
{
	return (obsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,
				  cacheablep));
}

pcireg_t
pci_mapreg_type(pci_chipset_tag_t pc, pcitag_t tag, int reg)
{
	return (_PCI_MAPREG_TYPEBITS(pci_conf_read(pc, tag, reg)));
}

int
pci_mapreg_probe(pci_chipset_tag_t pc, pcitag_t tag, int reg, pcireg_t *typep)
{
	pcireg_t address, mask, csr;
	int s;
	
	s = splhigh();
	csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	if (csr & (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE))
		pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, csr &
		    ~(PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE));
	address = pci_conf_read(pc, tag, reg);
	pci_conf_write(pc, tag, reg, 0xffffffff);
	mask = pci_conf_read(pc, tag, reg);
	pci_conf_write(pc, tag, reg, address);
	if (csr & (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE))
		pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, csr);
	splx(s);

	if (mask == 0) /* unimplemented mapping register */
		return (0);

	if (typep)
		*typep = _PCI_MAPREG_TYPEBITS(address);
	return (1);
}

int
pci_mapreg_info(pci_chipset_tag_t pc, pcitag_t tag, int reg, pcireg_t type,
    bus_addr_t *basep, bus_size_t *sizep, int *flagsp)
{

	if (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO)
		return (obsd_pci_io_find(pc, tag, reg, type, basep, sizep,
		    flagsp));
	else
		return (obsd_pci_mem_find(pc, tag, reg, type, basep, sizep,
		    flagsp));
}

int
pci_mapreg_map(struct pci_attach_args *pa, int reg, pcireg_t type, int flags,
    bus_space_tag_t *tagp, bus_space_handle_t *handlep, bus_addr_t *basep,
    bus_size_t *sizep, bus_size_t maxsize)
{
	bus_space_tag_t tag;
	bus_space_handle_t handle;
	bus_addr_t base;
	bus_size_t size;
	pcireg_t csr;
	int rv;

	if ((rv = pci_mapreg_info(pa->pa_pc, pa->pa_tag, reg, type,
	    &base, &size, NULL)) != 0)
		return (rv);
#if !defined(__sparc64__)
	if (base == 0) {
		struct extent *ex;
		bus_addr_t start, end;

		if (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {
			ex = pa->pa_ioex;
			if (ex != NULL) {
				start = max(PCI_IO_START, ex->ex_start);
				end = min(PCI_IO_END, ex->ex_end);
			}
		} else {
			ex = pa->pa_memex;
			if (ex != NULL) {
				start = max(PCI_MEM_START, ex->ex_start);
				end = min(PCI_MEM_END, ex->ex_end);
			}
		}

		if (ex == NULL || extent_alloc_subregion(ex, start, end,
		    size, size, 0, 0, 0, &base))
			return (EINVAL); /* disabled because of invalid BAR */

		pci_conf_write(pa->pa_pc, pa->pa_tag, reg, base);
		if (PCI_MAPREG_MEM_TYPE(type) == PCI_MAPREG_MEM_TYPE_64BIT)
			pci_conf_write(pa->pa_pc, pa->pa_tag, reg + 4,
			    (u_int64_t)base >> 32);
	}
#endif

	csr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	if (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO)
		csr |= PCI_COMMAND_IO_ENABLE;
	else
		csr |= PCI_COMMAND_MEM_ENABLE;
	/* XXX Should this only be done for devices that do DMA?  */
	csr |= PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, csr);

	if (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {
		if ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)
			return (EINVAL);
		tag = pa->pa_iot;
	} else {
		if ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)
			return (EINVAL);
		tag = pa->pa_memt;
	}

	/* The caller can request limitation of the mapping's size. */
	if (maxsize != 0 && size > maxsize) {
#ifdef DEBUG
		printf("pci_mapreg_map: limited PCI mapping from %lx to %lx\n",
		    (u_long)size, (u_long)maxsize);
#endif
		size = maxsize;
	}

	if (bus_space_map(tag, base, size, flags, &handle))
		return (1);

	if (tagp != NULL)
		*tagp = tag;
	if (handlep != NULL)
		*handlep = handle;
	if (basep != NULL)
		*basep = base;
	if (sizep != NULL)
		*sizep = size;

	return (0);
}
@


1.30
log
@No longer #ifdef BUS_SPACE_MAP_PREFETCHABLE, as all <machine/bus.h> are
expcted to provide it nowadays.
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.29 2010/09/06 12:30:35 kettenis Exp $     */
a38 1
#include <sys/device.h>
@


1.29
log
@Some stupid hardware marks PCI BARs as prefetchable that aren't side-effect
free.  Mapping those with BUS_SPACE_MAP_PREFETCHABLE can have disastrous
effects, like the NMIs observed by jsg@@ with certain Intel 10Gb Ethernet
devices.  So stop trusting the devices and instead require drivers to
explicitly pass the BUS_SPACE_MAP_PREFECTHABLE flag to pci_mapreg_map().
The pci_mapreg_info() call will continue to return BUS_SPACE_MAP_PREFECTHABLE
flags for prefetchable BARs as an easy way to figure out whether a BAR is
prefetchable.  Since the vga_pci.c code uses this interface, all consumers
of VGA BARs will still use the BUS_SPACE_MAP_PREFETCHABLE flag when
appropriate.

ok oga@@, jsg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.28 2010/02/28 21:37:54 miod Exp $     */
a251 1
#ifdef BUS_SPACE_MAP_PREFETCHABLE
d253 1
a253 3
		      BUS_SPACE_MAP_PREFETCHABLE :
#endif
		  0;
@


1.28
log
@In pci_mapreg_map(), do not blindly dereference a possible NULL pointer
upon stumbling on a BAR which value is zero.
Found the hard way by kurt@@, ok kettenis@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.27 2009/10/06 21:35:43 kettenis Exp $     */
d323 1
a323 1
pci_mapreg_map(struct pci_attach_args *pa, int reg, pcireg_t type, int busflags,
a331 1
	int flags;
d335 1
a335 1
	    &base, &size, &flags)) != 0)
d395 1
a395 1
	if (bus_space_map(tag, base, size, busflags | flags, &handle))
@


1.28.4.1
log
@MFC:

- - -
revision 1.29
date: 2010/09/06 12:30:35;  author: kettenis;  state: Exp;  lines: +4 -5
Some stupid hardware marks PCI BARs as prefetchable that aren't side-effect
free.  Mapping those with BUS_SPACE_MAP_PREFETCHABLE can have disastrous
effects, like the NMIs observed by jsg@@ with certain Intel 10Gb Ethernet
devices.  So stop trusting the devices and instead require drivers to
explicitly pass the BUS_SPACE_MAP_PREFECTHABLE flag to pci_mapreg_map().
- - -

from sthen
ok deraadt
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.28 2010/02/28 21:37:54 miod Exp $     */
d323 1
a323 1
pci_mapreg_map(struct pci_attach_args *pa, int reg, pcireg_t type, int flags,
d332 1
d336 1
a336 1
	    &base, &size, NULL)) != 0)
d396 1
a396 1
	if (bus_space_map(tag, base, size, flags, &handle))
@


1.27
log
@Allow MD limits for allocating PCI io and mem space and specify limits on
i386 and amd64 to make avoid legacy ISA I/O registers.  Fixes issues with
ThinkPad T-series Dock II units as reported by sobrado@@

ok miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.26 2009/08/25 20:56:40 kettenis Exp $     */
d345 4
a348 2
			start = max(PCI_IO_START, ex->ex_start);
			end = min(PCI_IO_END, ex->ex_end);
d351 4
a354 2
			start = max(PCI_MEM_START, ex->ex_start);
			end = min(PCI_MEM_END, ex->ex_end);
@


1.26
log
@We can treat BARs initialized to 0 as invalid now on socppc.
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.25 2009/07/23 19:29:58 kettenis Exp $     */
d44 16
d341 1
d343 1
a343 1
		if (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO)
d345 3
a347 1
		else
d349 3
d353 2
a354 1
		if (ex == NULL || extent_alloc(ex, size, size, 0, 0, 0, &base))
@


1.25
log
@Avoid twiddling the lower bits of a BAR such that the code becomes usable
for mapping ROM BARs.
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.24 2009/04/06 20:51:48 kettenis Exp $     */
d322 1
a322 1
#if !defined(__sparc64__) && !defined(__socppc__)
@


1.24
log
@Set a first step on the road towards proper accounting of PCI resources by
keeping a per-bus extent containing the address space available to the bus.
Address space assigned to devices will be removed from these extents when
we attach a bus.  And when we try to map a PCI BAR that hasn't had address
space assigned to it, we will allocate free space from this extent.

This won't do anything until the parent devices actually allocate and
initialize the extents.

ok oga@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.23 2008/06/26 05:42:17 ray Exp $     */
d155 1
a155 1
	pci_conf_write(pc, tag, reg, 0xffffffff);
@


1.23
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.22 2008/05/10 13:39:01 kettenis Exp $     */
d323 16
a338 2
	if (base == 0)
		return (EINVAL);	/* disabled because of invalid BAR */
@


1.22
log
@On socppc, we need to be able to map a zero base address too.
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.21 2008/04/09 21:47:36 kettenis Exp $     */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.21
log
@On sparc64, a zero base address doesn't mean the BAR is invalid.  We probably
need a MD base address validation function, but skipping the check on sparc64
will do for now.

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.20 2007/01/26 01:18:48 tsi Exp $     */
d329 1
a329 1
#ifndef __sparc64__
@


1.20
log
@As per PCI specs, disable an adapter's transaction response while
sizing its BARs.

tested niallo@@, tsi@@, ian@@, mk@@, sturm@@, kettenis@@, krw@@, beck@@, drahn@@
ok beck@@, kettenis@@, drahn@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.19 2006/12/12 18:28:54 deraadt Exp $     */
d329 1
d332 1
@


1.19
log
@ignore bars which are 0; ok kettenis
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.18 2006/07/31 11:06:33 mickey Exp $     */
d61 1
a61 1
	pcireg_t address, mask;
d82 2
a83 2
	 * n bits of the address to 0.  As recommended, we write all 1s and see
	 * what we get back.
d86 4
d94 2
d126 1
a126 1
	pcireg_t address, mask, address1 = 0, mask1 = 0xffffffff;
d153 2
a154 2
	 * n bits of the address to 0.  As recommended, we write all 1s and see
	 * what we get back.
d157 4
d171 2
d276 1
a276 1
	pcireg_t address, mask;
d280 4
d288 2
@


1.18
log
@puc@@cardbus (only added (commented out) to whom has puc@@pci enabled)
tested on puc@@pci by fkr and meself on the cardbus.
still needs a bit more work but generally works.
deraadt@@ ok and some input from miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.17 2006/07/04 18:07:29 kettenis Exp $     */
d308 6
a325 3
		if ((rv = obsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type,
		    &base, &size, &flags)) != 0)
			return (rv);
a329 3
		if ((rv = obsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type,
		    &base, &size, &flags)) != 0)
			return (rv);
@


1.17
log
@Do not blindly enable io and mem space for all matched PCI devices.  This is
known to be wrong for legacy VGA devices.  It also seems to have bad side
effects for some unconfigured PCI-PCI bridges.  Instead, enable io or mem
space when we map it.

ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.16 2006/05/31 08:58:05 jason Exp $     */
a253 5

#define _PCI_MAPREG_TYPEBITS(reg) \
	(PCI_MAPREG_TYPE(reg) == PCI_MAPREG_TYPE_IO ? \
	reg & PCI_MAPREG_TYPE_MASK : \
	reg & (PCI_MAPREG_TYPE_MASK|PCI_MAPREG_MEM_TYPE_MASK))
@


1.16
log
@Damnit! no static functions in the kernel
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.15 2006/04/07 01:07:41 brad Exp $     */
d309 1
d312 9
@


1.15
log
@Don't check for a BAR address past PCI_MAPREG_END; some devices
have BARs way out in left field.

From NetBSD
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.14 2006/04/07 01:04:49 brad Exp $     */
d52 1
a52 1
static int obsd_pci_io_find(pci_chipset_tag_t, pcitag_t, int, pcireg_t,
d54 1
a54 1
static int obsd_pci_mem_find(pci_chipset_tag_t, pcitag_t, int, pcireg_t,
d57 1
a57 1
static int
d116 1
a116 1
static int
@


1.14
log
@implement a check whether a BAR is present at all at a given
configuration space address, pci_mapreg_probe().

From NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.13 2006/03/19 22:28:40 brad Exp $     */
d64 9
a72 1
	if (reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3))
d126 9
a134 1
	if (reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3))
@


1.13
log
@ANSIfy
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.12 2005/03/15 20:18:10 miod Exp $     */
d239 5
d247 18
a264 1
	pcireg_t rv;
d266 3
a268 6
	rv = pci_conf_read(pc, tag, reg);
	if (PCI_MAPREG_TYPE(rv) == PCI_MAPREG_TYPE_IO)
		rv &= PCI_MAPREG_TYPE_MASK;
	else
		rv &= PCI_MAPREG_TYPE_MASK|PCI_MAPREG_MEM_TYPE_MASK;
	return (rv);
@


1.12
log
@Only print warning messages in pci_{io,mem}_find() if option DEBUG; instead,
do not return 1 on failure but a real errno the caller can check for proper
action.

tweaks and ok mickey@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.11 2004/10/09 19:52:04 brad Exp $     */
d52 1
a52 1
static int nbsd_pci_io_find(pci_chipset_tag_t, pcitag_t, int, pcireg_t,
d54 1
a54 1
static int nbsd_pci_mem_find(pci_chipset_tag_t, pcitag_t, int, pcireg_t,
d58 2
a59 8
nbsd_pci_io_find(pc, tag, reg, type, basep, sizep, flagsp)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int reg;
	pcireg_t type;
	bus_addr_t *basep;
	bus_size_t *sizep;
	int *flagsp;
d109 2
a110 8
nbsd_pci_mem_find(pc, tag, reg, type, basep, sizep, flagsp)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int reg;
	pcireg_t type;
	bus_addr_t *basep;
	bus_size_t *sizep;
	int *flagsp;
d225 2
a226 6
pci_io_find(pc, pcitag, reg, iobasep, iosizep)
	pci_chipset_tag_t pc;
	pcitag_t pcitag;
	int reg;
	bus_addr_t *iobasep;
	bus_size_t *iosizep;
d228 1
a228 1
	return (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));
d232 2
a233 7
pci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)
	pci_chipset_tag_t pc;
	pcitag_t pcitag;
	int reg;
	bus_addr_t *membasep;
	bus_size_t *memsizep;
	int *cacheablep;
d235 1
a235 1
	return (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,
d240 1
a240 4
pci_mapreg_type(pc, tag, reg)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int reg;
d253 2
a254 8
pci_mapreg_info(pc, tag, reg, type, basep, sizep, flagsp)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int reg;
	pcireg_t type;
	bus_addr_t *basep;
	bus_size_t *sizep;
	int *flagsp;
d258 1
a258 1
		return (nbsd_pci_io_find(pc, tag, reg, type, basep, sizep,
d261 1
a261 1
		return (nbsd_pci_mem_find(pc, tag, reg, type, basep, sizep,
d266 3
a268 9
pci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep, maxsize)
	struct pci_attach_args *pa;
	int reg, busflags;
	pcireg_t type;
	bus_space_tag_t *tagp;
	bus_space_handle_t *handlep;
	bus_addr_t *basep;
	bus_size_t *sizep;
	bus_size_t maxsize;
d280 1
a280 1
		if ((rv = nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type,
d287 1
a287 1
		if ((rv = nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type,
@


1.11
log
@When testing for a void region, use PCI_MAPREG_MEM_SIZE() for 32bit memaddr.
If the 32bit mask read is 0, wmask will be 0xffffffff00000000, and
PCI_MAPREG_MEM64_SIZE() won't make this 0.

From NetBSD

ok mickey@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.10 2003/08/27 20:59:15 mickey Exp $     */
d91 1
d93 2
a94 1
		return (1);
d98 1
d100 2
a101 1
		return (1);
d160 1
d162 2
a163 1
		return (1);
d167 1
d171 2
a172 1
		return (1);
d180 1
d182 2
a183 1
		return (1);
d200 1
d203 2
a204 1
			return (1);
d208 1
d210 2
a211 1
		return (1);
d311 1
d315 4
a318 4
			return (1);
		if (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,
				     &size, &flags))
			return (1);
d322 4
a325 4
			return (1);
		if (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,
				      &size, &flags))
			return (1);
@


1.10
log
@this bit is defined as prefetchable and not cachable and thus rename and use appropriately
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.8 2003/02/28 15:14:08 mickey Exp $     */
d170 2
a171 1
	if (PCI_MAPREG_MEM64_SIZE(wmask) == 0) {
@


1.9
log
@remove non-typo changes. sorry folks
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.7 2002/03/14 01:26:59 millert Exp $     */
d211 4
a214 3
		*flagsp = PCI_MAPREG_MEM_CACHEABLE(address)
#ifndef __OpenBSD__
		    ? BUS_SPACE_MAP_CACHEABLE : 0
d216 1
a216 1
		  ;
@


1.8
log
@typo; from weissmanndude
@
text
@d211 1
a211 1
		*flagsp = 0 /*PCI_MAPREG_MEM_CACHEABLE(address)*/
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.6 2001/06/13 08:25:25 niklas Exp $     */
d211 1
a211 1
		*flagsp = PCI_MAPREG_MEM_CACHEABLE(address)
@


1.6
log
@typo spotted by Mike Pechkin <mpech@@prosoft.org.lv>
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.5 2001/06/12 15:40:32 niklas Exp $     */
d52 4
a55 4
static int nbsd_pci_io_find __P((pci_chipset_tag_t, pcitag_t, int, pcireg_t,
    bus_addr_t *, bus_size_t *, int *));
static int nbsd_pci_mem_find __P((pci_chipset_tag_t, pcitag_t, int, pcireg_t,
    bus_addr_t *, bus_size_t *, int *));
@


1.6.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.6 2001/06/13 08:25:25 niklas Exp $     */
d52 4
a55 4
static int nbsd_pci_io_find(pci_chipset_tag_t, pcitag_t, int, pcireg_t,
    bus_addr_t *, bus_size_t *, int *);
static int nbsd_pci_mem_find(pci_chipset_tag_t, pcitag_t, int, pcireg_t,
    bus_addr_t *, bus_size_t *, int *);
@


1.5
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.4 2000/09/20 17:39:04 niklas Exp $     */
d316 1
a316 1
		    (u_long)size, (u_long)maxsize):
@


1.4
log
@support 64bit BARs from NetBSD
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.3 2000/06/09 16:09:09 chris Exp $     */
d280 1
a280 1
pci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)
d288 1
d312 9
d324 1
a324 1
	if (tagp != 0)
d326 1
a326 1
	if (handlep != 0)
d328 1
a328 1
	if (basep != 0)
d330 1
a330 1
	if (sizep != 0)
@


1.3
log
@Import pci_mapreg_type from NetBSD
@
text
@d1 2
a2 2
/*      $OpenBSD: pci_map.c,v 1.2 1999/07/18 21:25:19 csapuntz Exp $     */
/*	$NetBSD: pci_map.c,v 1.5 1998/08/15 10:10:54 mycroft Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
d9 1
a9 1
 * by Charles M. Hannum.
d120 5
a124 2
	pcireg_t address, mask;
	int s;
d127 4
a130 1
		panic("pci_find_mem: bad request");
d147 6
d167 4
a170 1
	if (PCI_MAPREG_MEM_SIZE(mask) == 0) {
d180 14
a193 2
		printf("pci_mem_find: 64-bit memory mapping register\n");
		return (1);
d199 11
a209 4
	if (basep != 0)
		*basep = PCI_MAPREG_MEM_ADDR(address);
	if (sizep != 0)
		*sizep = PCI_MAPREG_MEM_SIZE(mask);
@


1.2
log
@

Import of NetBSD ATA/IDE stuff.

Introduction of home-grown

To enable this stuff in your configuration, look at the NEWATA conf file
and go through

dev/isa/files.isa
dev/pci/files.pci
conf/files
arch/i386/conf/files.i386

and follow the instructions on commenting/uncommenting stuff
@
text
@d1 1
a1 1
/*      $OpenBSD: $     */
d210 15
@


1.2.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*      $OpenBSD: pci_map.c,v 1.4 2000/09/20 17:39:04 niklas Exp $     */
/*	$NetBSD: pci_map.c,v 1.7 2000/05/10 16:58:42 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 2000 The NetBSD Foundation, Inc.
d9 1
a9 1
 * by Charles M. Hannum; by William R. Studenmund; by Jason R. Thorpe.
d120 2
a121 5
	pcireg_t address, mask, address1 = 0, mask1 = 0xffffffff;
	u_int64_t waddress, wmask;
	int s, is64bit;

	is64bit = (PCI_MAPREG_MEM_TYPE(type) == PCI_MAPREG_MEM_TYPE_64BIT);
d124 1
a124 4
		panic("pci_mem_find: bad request");

	if (is64bit && (reg + 4) >= PCI_MAPREG_END)
		panic("pci_mem_find: bad 64-bit request");
a140 6
	if (is64bit) {
		address1 = pci_conf_read(pc, tag, reg + 4);
		pci_conf_write(pc, tag, reg + 4, 0xffffffff);
		mask1 = pci_conf_read(pc, tag, reg + 4);
		pci_conf_write(pc, tag, reg + 4, address1);
	}
d155 1
a155 4
	waddress = (u_int64_t)address1 << 32UL | address;
	wmask = (u_int64_t)mask1 << 32UL | mask;

	if (PCI_MAPREG_MEM64_SIZE(wmask) == 0) {
d165 2
a166 14
		/*
		 * Handle the case of a 64-bit memory register on a
		 * platform with 32-bit addressing.  Make sure that
		 * the address assigned and the device's memory size
		 * fit in 32 bits.  We implicitly assume that if
		 * bus_addr_t is 64-bit, then so is bus_size_t.
		 */
		if (sizeof(u_int64_t) > sizeof(bus_addr_t) &&
		    (address1 != 0 || mask1 != 0xffffffff)) {
			printf("pci_mem_find: 64-bit memory map which is "
			    "inaccessible on a 32-bit platform\n");
			return (1);
		}
		break;
d172 4
a175 11
	if (sizeof(u_int64_t) > sizeof(bus_addr_t)) {
		if (basep != 0)
			*basep = PCI_MAPREG_MEM_ADDR(address);
		if (sizep != 0)
			*sizep = PCI_MAPREG_MEM_SIZE(mask);
	} else {
		if (basep != 0)
			*basep = PCI_MAPREG_MEM64_ADDR(waddress);
		if (sizep != 0)
			*sizep = PCI_MAPREG_MEM64_SIZE(wmask);
	}
a209 15
pcireg_t
pci_mapreg_type(pc, tag, reg)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int reg;
{
	pcireg_t rv;

	rv = pci_conf_read(pc, tag, reg);
	if (PCI_MAPREG_TYPE(rv) == PCI_MAPREG_TYPE_IO)
		rv &= PCI_MAPREG_TYPE_MASK;
	else
		rv &= PCI_MAPREG_TYPE_MASK|PCI_MAPREG_MEM_TYPE_MASK;
	return (rv);
}
@


1.2.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*      $OpenBSD: pci_map.c,v 1.2.4.1 2001/05/14 22:25:52 niklas Exp $     */
d280 1
a280 1
pci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep, maxsize)
a287 1
	bus_size_t maxsize;
a310 9
	/* The caller can request limitation of the mapping's size. */
	if (maxsize != 0 && size > maxsize) {
#ifdef DEBUG
		printf("pci_mapreg_map: limited PCI mapping from %lx to %lx\n",
		    (u_long)size, (u_long)maxsize);
#endif
		size = maxsize;
	}

d314 1
a314 1
	if (tagp != NULL)
d316 1
a316 1
	if (handlep != NULL)
d318 1
a318 1
	if (basep != NULL)
d320 1
a320 1
	if (sizep != NULL)
@


1.2.4.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*      $OpenBSD$     */
d52 4
a55 4
static int nbsd_pci_io_find(pci_chipset_tag_t, pcitag_t, int, pcireg_t,
    bus_addr_t *, bus_size_t *, int *);
static int nbsd_pci_mem_find(pci_chipset_tag_t, pcitag_t, int, pcireg_t,
    bus_addr_t *, bus_size_t *, int *);
@


1.2.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d211 3
a213 4
		*flagsp =
#ifdef BUS_SPACE_MAP_PREFETCHABLE
		    PCI_MAPREG_MEM_PREFETCHABLE(address) ?
		      BUS_SPACE_MAP_PREFETCHABLE :
d215 1
a215 1
		  0;
@


1.1
log
@

Added pci_mapreg* interface from NetBSD.
Added PCI 2.2 stuff from NetBSD
Modified if_de to use mapreg interface
@
text
@d1 1
@

