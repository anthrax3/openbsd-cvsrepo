head	1.40;
access;
symbols
	OPENBSD_6_2:1.40.0.8
	OPENBSD_6_2_BASE:1.40
	OPENBSD_6_1:1.40.0.12
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.40.0.10
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.6
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.4
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.39.0.18
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.16
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.12
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.10
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.8
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.6
	OPENBSD_5_0:1.39.0.4
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.39.0.2
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.38.0.6
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.38.0.4
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.36.0.24
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.22
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.20
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.36.0.18
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.36.0.16
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.36.0.14
	OPENBSD_4_0_BASE:1.36
	OPENBSD_3_9:1.36.0.12
	OPENBSD_3_9_BASE:1.36
	OPENBSD_3_8:1.36.0.10
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.36.0.8
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.36.0.6
	OPENBSD_3_6_BASE:1.36
	SMP_SYNC_A:1.36
	SMP_SYNC_B:1.36
	OPENBSD_3_5:1.36.0.4
	OPENBSD_3_5_BASE:1.36
	OPENBSD_3_4:1.36.0.2
	OPENBSD_3_4_BASE:1.36
	UBC_SYNC_A:1.35
	OPENBSD_3_3:1.35.0.4
	OPENBSD_3_3_BASE:1.35
	OPENBSD_3_2:1.35.0.2
	OPENBSD_3_2_BASE:1.35
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	UBC_SYNC_B:1.35
	UBC:1.22.0.4
	UBC_BASE:1.22
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	SMP:1.15.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9;
locks; strict;
comment	@ * @;


1.40
date	2014.08.15.15.37.51;	author mikeb;	state Exp;
branches;
next	1.39;
commitid	1HNugRqq8KSFJPRm;

1.39
date	2010.12.15.23.34.23;	author mikeb;	state Exp;
branches;
next	1.38;

1.38
date	2009.03.27.13.31.30;	author reyk;	state Exp;
branches
	1.38.2.1
	1.38.6.1;
next	1.37;

1.37
date	2009.03.25.12.17.30;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.04.16.02.41;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	2002.09.24.18.33.26;	author jason;	state Exp;
branches;
next	1.34;

1.34
date	2002.07.03.00.24.29;	author jason;	state Exp;
branches;
next	1.33;

1.33
date	2002.05.15.15.15.42;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	2002.05.13.22.28.56;	author jason;	state Exp;
branches;
next	1.31;

1.31
date	2002.05.06.20.53.05;	author jason;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.06.15.42.23;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.02.18.20.50;	author jason;	state Exp;
branches;
next	1.28;

1.28
date	2002.04.26.05.06.03;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2002.04.26.04.24.17;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2002.04.08.17.49.42;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2002.01.28.16.26.21;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2002.01.28.15.44.36;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.19.21.15.37;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.02.04.34.47;	author jason;	state Exp;
branches
	1.22.4.1;
next	1.21;

1.21
date	2001.06.29.21.52.42;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.29.16.19.15;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.08.01.59.32;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.30.02.26.14;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.23.04.46.41;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.22.22.53.38;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.14.02.45.19;	author deraadt;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.05.13.15.39.27;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.13.01.20.02;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.29.00.39.21;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.11.18.56.50;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.11.18.52.53;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.13.22.06.48;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.13.22.03.09;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.11.19.38.16;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.29.23.42.00;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.19.02.51.29;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.13.05.15.19;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.12.19.50.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.03.13.14.39;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.18.01.25.19;	author jason;	state Exp;
branches;
next	;

1.15.2.1
date	2001.05.14.22.26.00;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2001.07.04.10.43.14;	author niklas;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2003.03.28.00.38.25;	author niklas;	state Exp;
branches;
next	1.15.2.5;

1.15.2.5
date	2003.06.07.11.02.31;	author ho;	state Exp;
branches;
next	;

1.22.4.1
date	2002.01.31.22.55.36;	author niklas;	state Exp;
branches;
next	1.22.4.2;

1.22.4.2
date	2002.06.11.03.42.27;	author art;	state Exp;
branches;
next	1.22.4.3;

1.22.4.3
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	;

1.38.2.1
date	2010.12.20.14.08.41;	author jasper;	state Exp;
branches;
next	;

1.38.6.1
date	2010.12.17.16.25.14;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Remove support for public key operations
@
text
@/*	$OpenBSD: ubsecvar.h,v 1.39 2010/12/15 23:34:23 mikeb Exp $	*/

/*
 * Copyright (c) 2000 Theo de Raadt
 * Copyright (c) 2001 Patrik Lindergren (patrik@@ipunplugged.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

/* Maximum queue length */
#ifndef UBS_MAX_NQUEUE
#define UBS_MAX_NQUEUE		60
#endif

#define	UBS_MAX_SCATTER		64	/* Maximum scatter/gather depth */

#ifndef UBS_MAX_AGGR
#define	UBS_MAX_AGGR		17	/* Maximum aggregation count */
#endif

#ifndef UBS_MIN_AGGR
#define	UBS_MIN_AGGR		5	/* < 5827, Maximum aggregation count */
#endif

#define	UBSEC_CARD(sid)		(((sid) & 0xf0000000) >> 28)
#define	UBSEC_SESSION(sid)	( (sid) & 0x0fffffff)
#define	UBSEC_SID(crd, sesn)	(((crd) << 28) | ((sesn) & 0x0fffffff))

#define UBS_DEF_RTY		0xff	/* PCI Retry Timeout */
#define UBS_DEF_TOUT		0xff	/* PCI TRDY Timeout */
#define UBS_DEF_CACHELINE	0x01	/* Cache Line setting */

struct ubsec_dma_alloc {
	u_int32_t		dma_paddr;
	caddr_t			dma_vaddr;
	bus_dmamap_t		dma_map;
	bus_dma_segment_t	dma_seg;
	bus_size_t		dma_size;
	int			dma_nseg;
};

struct ubsec_q2 {
	SIMPLEQ_ENTRY(ubsec_q2)		q_next;
	struct ubsec_dma_alloc		q_mcr;
	struct ubsec_dma_alloc		q_ctx;
	u_int				q_type;
};

struct ubsec_q2_rng {
	struct ubsec_q2			rng_q;
	struct ubsec_dma_alloc		rng_buf;
	int				rng_used;
};

#define	UBSEC_RNG_BUFSIZ	16		/* measured in 32bit words */

struct ubsec_dmachunk {
	struct ubsec_mcr	d_mcr;
	struct ubsec_mcr_add	d_mcradd[UBS_MAX_AGGR-1];
	struct ubsec_pktbuf	d_sbuf[UBS_MAX_SCATTER-1];
	struct ubsec_pktbuf	d_dbuf[UBS_MAX_SCATTER-1];
	u_int32_t		d_macbuf[5];
	union {
		struct ubsec_pktctx_aes256	ctx_aes256;
		struct ubsec_pktctx_aes192	ctx_aes192;
		struct ubsec_pktctx_aes128	ctx_aes128;
		struct ubsec_pktctx_3des	ctx_3des;
		struct ubsec_pktctx		ctx;
	} d_ctx;
};

struct ubsec_dma {
	SIMPLEQ_ENTRY(ubsec_dma)	d_next;
	struct ubsec_dmachunk		*d_dma;
	struct ubsec_dma_alloc		d_alloc;
};

#define	UBS_FLAGS_KEY		0x01		/* has key accelerator */
#define	UBS_FLAGS_LONGCTX	0x02		/* uses long ipsec ctx */
#define	UBS_FLAGS_BIGKEY	0x04		/* 2048bit keys */
#define	UBS_FLAGS_HWNORM	0x08		/* hardware normalization */
#define	UBS_FLAGS_RNG		0x10		/* hardware rng */
#define UBS_FLAGS_AES		0x20		/* supports aes */
#define UBS_FLAGS_MULTIMCR	0x40		/* 5827+ with 4 MCRs */
#define UBS_FLAGS_RNG4		0x80		/* 5827+ RNG on MCR4 */

struct ubsec_q {
	SIMPLEQ_ENTRY(ubsec_q)		q_next;
	int				q_nstacked_mcrs;
	struct ubsec_q			*q_stacked_mcr[UBS_MAX_AGGR-1];
	struct cryptop			*q_crp;
	struct ubsec_dma		*q_dma;

	struct mbuf			*q_src_m, *q_dst_m;
	struct uio			*q_src_io, *q_dst_io;

	bus_dmamap_t			q_src_map;
	bus_dmamap_t			q_dst_map;

	int				q_sesn;
};

struct ubsec_softc {
	struct	device		sc_dv;		/* generic device */
	void			*sc_ih;		/* interrupt handler cookie */
	bus_space_handle_t	sc_sh;		/* memory handle */
	bus_space_tag_t		sc_st;		/* memory tag */
	bus_dma_tag_t		sc_dmat;	/* dma tag */
	int			sc_flags;	/* device specific flags */
	u_int32_t		sc_statmask;	/* interrupt status mask */
	int32_t			sc_cid;		/* crypto tag */
	int			sc_maxaggr;	/* max pkt aggregation */
	SIMPLEQ_HEAD(,ubsec_q)	sc_queue;	/* packet queue, mcr1 */
	int			sc_nqueue;	/* count enqueued, mcr1 */
	SIMPLEQ_HEAD(,ubsec_q)	sc_qchip;	/* on chip, mcr1 */
	SIMPLEQ_HEAD(,ubsec_q)	sc_freequeue;	/* list of free queue elements */
	SIMPLEQ_HEAD(,ubsec_q2)	sc_queue2;	/* packet queue, mcr2 */
	int			sc_nqueue2;	/* count enqueued, mcr2 */
	SIMPLEQ_HEAD(,ubsec_q2)	sc_qchip2;	/* on chip, mcr2 */
	SIMPLEQ_HEAD(,ubsec_q2)	sc_queue4;	/* packet queue, mcr4 */
	int			sc_nqueue4;	/* count enqueued, mcr4 */
	SIMPLEQ_HEAD(,ubsec_q2)	sc_qchip4;	/* on chip, mcr4 */
	int			sc_nsessions;	/* # of sessions */
	struct ubsec_session	*sc_sessions;	/* sessions */
	struct timeout		sc_rngto;	/* rng timeout */
	int			sc_rnghz;	/* rng poll time */
	struct ubsec_q2_rng	sc_rng;
	struct ubsec_dma	sc_dmaa[UBS_MAX_NQUEUE];
	struct ubsec_q		*sc_queuea[UBS_MAX_NQUEUE];
};

struct ubsec_session {
	u_int32_t	ses_used;
	u_int32_t	ses_key[8];		/* 3DES/AES key */
	u_int32_t	ses_hminner[5];		/* hmac inner state */
	u_int32_t	ses_hmouter[5];		/* hmac outer state */
	u_int32_t	ses_iv[4];		/* [3]DES iv or AES iv/icv */
};

struct ubsec_stats {
	u_int64_t hst_ibytes;
	u_int64_t hst_obytes;
	u_int32_t hst_ipackets;
	u_int32_t hst_opackets;
	u_int32_t hst_invalid;
	u_int32_t hst_nomem;
	u_int32_t hst_queuefull;
	u_int32_t hst_dmaerr;
	u_int32_t hst_mcrerr;
	u_int32_t hst_nodmafree;
};
@


1.39
log
@Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.

Original commit message by angelos:

Don't keep the last blocksize-bytes of ciphertext for use as the next
plaintext's IV, in CBC mode. Use arc4random() to acquire fresh IVs per
message.

with and ok deraadt, ok markus, djm
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.38 2009/03/27 13:31:30 reyk Exp $	*/
a78 30
/* C = (M ^ E) mod N */
#define	UBS_MODEXP_PAR_M	0
#define	UBS_MODEXP_PAR_E	1
#define	UBS_MODEXP_PAR_N	2
struct ubsec_q2_modexp {
	struct ubsec_q2			me_q;
	struct cryptkop *		me_krp;
	struct ubsec_dma_alloc		me_M;
	struct ubsec_dma_alloc		me_E;
	struct ubsec_dma_alloc		me_C;
	struct ubsec_dma_alloc		me_epb;
	int				me_modbits;
	int				me_shiftbits;
	int				me_normbits;
};

#define	UBS_RSAPRIV_PAR_P	0
#define	UBS_RSAPRIV_PAR_Q	1
#define	UBS_RSAPRIV_PAR_DP	2
#define	UBS_RSAPRIV_PAR_DQ	3
#define	UBS_RSAPRIV_PAR_PINV	4
#define	UBS_RSAPRIV_PAR_MSGIN	5
#define	UBS_RSAPRIV_PAR_MSGOUT	6
struct ubsec_q2_rsapriv {
	struct ubsec_q2			rpr_q;
	struct cryptkop *		rpr_krp;
	struct ubsec_dma_alloc		rpr_msgin;
	struct ubsec_dma_alloc		rpr_msgout;
};

a153 1
	SIMPLEQ_HEAD(,ubsec_q2)	sc_q2free;	/* free list */
@


1.38
log
@Add support for the BCM5825 and the next-generation BCM5860, 5861,
5862 Broadcom CryptoNetX IPSec/SSL Security Processors.  The 5825 is a
faster version of the already supported 5823, and the even faster 586x
series is a bit different and needed some more changes.  The RNG
engine on the 586x is not supported yet but I hope to fix it soon...

ubsec0 at pci4 dev 0 function 0 "Broadcom 5862" rev 0x01: 3DES MD5 SHA1 AES PK, apic 10 int 10 (irq 11)

tested by phessler@@ and me
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.35 2002/09/24 18:33:26 jason Exp $	*/
a154 1
	int				q_flags;
a185 2

#define	UBSEC_QFLAGS_COPYOUTIV		0x1
@


1.38.2.1
log
@Backport from -current, original commit by mikeb@@:
------
Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.
------
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.38 2009/03/27 13:31:30 reyk Exp $	*/
d155 1
d187 2
@


1.38.6.1
log
@Backport from -current, original commit by mikeb@@:
------
Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.
------

ok deraadt@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.38 2009/03/27 13:31:30 reyk Exp $	*/
d155 1
d187 2
@


1.37
log
@add support for AES-CBC with the BCM5823 (or newer, but we don't support newer
variants yet).

ok deraadt@@ dlg@@
@
text
@d42 5
a46 1
#define	UBS_MAX_AGGR		5	/* Maximum aggregation count */
d138 2
d167 1
d175 3
@


1.36
log
@nuke term 3 based on terms file
@
text
@d114 4
a117 1
		struct ubsec_pktctx_long	ctxl;
d133 1
d182 1
a182 1
	u_int32_t	ses_deskey[6];		/* 3DES key */
d185 1
a185 1
	u_int32_t	ses_iv[2];		/* [3]DES iv */
@


1.35
log
@Don't use constants for the output parameter, use the iparam count as a pointer to the first result location.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.34 2002/07/03 00:24:29 jason Exp $	*/
a15 2
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.34
log
@But when denormalizing we need the normalized length, too as well as the destination length.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.33 2002/05/15 15:15:42 jason Exp $	*/
a80 1
#define	UBS_MODEXP_PAR_C	3
@


1.33
log
@Rework MODEXP:
5805 (and 5601) require the modulus and base to be normalized to the right of
one of several different register lengths.  The result is also normalized to
the same length.  Provide functions for shifting the bits back and forth
as appropriate.  Note: for consistencies sake the exponent is NOT normalized.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.32 2002/05/13 22:28:56 jason Exp $	*/
d91 1
@


1.32
log
@add and use three more flags:
RNG: chip has usable rng (5805/5820/5821)
HWNORM: chip will automagically normalize bignums (5820/5821)
BIGKEY: chip supports "large keys" (5820/5821)
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.31 2002/05/06 20:53:05 jason Exp $	*/
d90 1
@


1.31
log
@basic infrastructure for handling RSA with CRT parameters.  Just need to
figure out how p, q, dp, dq, and pinv fit into the context.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.30 2002/05/06 15:42:23 jason Exp $	*/
d128 3
@


1.30
log
@- Only copy the significant bits of the result out (and make sure the buffer
is long enough to handle it) and bzero the rest.
- Increase key buffer sizes to 2048 bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.29 2002/05/02 18:20:50 jason Exp $	*/
d90 14
@


1.29
log
@Don't refer to the parameters directly by number, use macro's so it can be
changed later if necessary.
Also, don't bother bzero'n the mcr, all of the fields are initialized anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.28 2002/04/26 05:06:03 jason Exp $	*/
d89 1
@


1.28
log
@1024 bit max
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.27 2002/04/26 04:24:17 jason Exp $	*/
d78 4
@


1.27
log
@register as supporting modular exponentiation
still contains much debugging code and isn't quite done, but its a start
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.26 2002/04/08 17:49:42 jason Exp $	*/
a174 1

@


1.26
log
@Credit DARPA/USAF appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.25 2002/01/28 16:26:21 jason Exp $	*/
d68 1
d76 11
d150 1
@


1.25
log
@First round of post-bus_dma cleanups:
- remove the packl/packp arrays and rework handling appropriately
- destination map may or may not exist, cope.
- remove a redundant bus_dmamap_sync() in _process (real sync is in _feed)
- remove long deprecated q_{src,dst}pkt stuff from queue structure
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.24 2002/01/28 15:44:36 jason Exp $	*/
d29 5
@


1.24
log
@Quick (and a little dirty) conversion to bus_dma(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.23 2002/01/19 21:15:37 jason Exp $	*/
a97 2
	struct ubsec_pktbuf		q_srcpkt[UBS_MAX_SCATTER-1];
	struct ubsec_pktbuf		q_dstpkt[UBS_MAX_SCATTER-1];
a102 3
	long				q_src_packp[UBS_MAX_SCATTER];
	int				q_src_packl[UBS_MAX_SCATTER];
	int				q_src_npa, q_src_l;
a103 4

	long				q_dst_packp[UBS_MAX_SCATTER];
	int				q_dst_packl[UBS_MAX_SCATTER];
	int				q_dst_npa, q_dst_l;
@


1.23
log
@From Patrik Lindergren (patrik@@ipunplugged.com):
* make the driver big-endian aware
* handling for DMA errors
* move some allocations to attach
From me:
whitespace clean up and vtophys removal (almost works on sparc64)
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.22 2001/07/02 04:34:47 jason Exp $	*/
d108 1
d113 2
@


1.22
log
@- More vtophys death: packet buffer lists are is bus_dma(9) memory as is
the mac buffer
- also, reenable aggregation code (accidentally removed)
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.21 2001/06/29 21:52:42 jason Exp $	*/
d5 1
d37 2
d40 1
d46 4
a72 1
#if 0
a74 1
#endif
d90 26
d128 1
d138 1
a138 1
	SIMPLEQ_HEAD(,ubsec_dma) sc_dma;
a140 24
#define	UBS_FLAGS_KEY		0x01		/* has key accelerator */
#define	UBS_FLAGS_LONGCTX	0x02		/* uses long ipsec ctx */

struct ubsec_q {
	SIMPLEQ_ENTRY(ubsec_q)		q_next;
	struct cryptop			*q_crp;
	struct ubsec_mcr		*q_mcr;
	struct ubsec_pktbuf		q_srcpkt[UBS_MAX_SCATTER-1];
	struct ubsec_pktbuf		q_dstpkt[UBS_MAX_SCATTER-1];
	struct ubsec_dma		*q_dma;

	struct mbuf 		      	*q_src_m, *q_dst_m;
	struct uio			*q_src_io, *q_dst_io;

	long				q_src_packp[UBS_MAX_SCATTER];
	int				q_src_packl[UBS_MAX_SCATTER];
	int				q_src_npa, q_src_l;

	long				q_dst_packp[UBS_MAX_SCATTER];
	int				q_dst_packl[UBS_MAX_SCATTER];
	int				q_dst_npa, q_dst_l;
	int				q_sesn;
	int				q_flags;
};
d146 16
a161 3
	u_int32_t       ses_hminner[5];		/* hmac inner state */
	u_int32_t       ses_hmouter[5];		/* hmac outer state */
	u_int32_t       ses_iv[2];		/* [3]DES iv */
d163 1
@


1.22.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.25 2002/01/28 16:26:21 jason Exp $	*/
a4 1
 * Copyright (c) 2001 Patrik Lindergren (patrik@@ipunplugged.com)
a35 2

#ifndef UBS_MAX_AGGR
a36 1
#endif
a41 4
#define UBS_DEF_RTY		0xff	/* PCI Retry Timeout */
#define UBS_DEF_TOUT		0xff	/* PCI TRDY Timeout */
#define UBS_DEF_CACHELINE	0x01	/* Cache Line setting */

d65 1
d68 1
a83 20
#define	UBS_FLAGS_KEY		0x01		/* has key accelerator */
#define	UBS_FLAGS_LONGCTX	0x02		/* uses long ipsec ctx */

struct ubsec_q {
	SIMPLEQ_ENTRY(ubsec_q)		q_next;
	int				q_nstacked_mcrs;
	struct ubsec_q			*q_stacked_mcr[UBS_MAX_AGGR-1];
	struct cryptop			*q_crp;
	struct ubsec_dma		*q_dma;

	struct mbuf			*q_src_m, *q_dst_m;
	struct uio			*q_src_io, *q_dst_io;

	bus_dmamap_t			q_src_map;
	bus_dmamap_t			q_dst_map;

	int				q_sesn;
	int				q_flags;
};

a95 1
	SIMPLEQ_HEAD(,ubsec_q)	sc_freequeue;	/* list of free queue elements */
d105 1
a105 1
	struct ubsec_q		*sc_queuea[UBS_MAX_NQUEUE];
d108 24
d137 3
a139 16
	u_int32_t	ses_hminner[5];		/* hmac inner state */
	u_int32_t	ses_hmouter[5];		/* hmac outer state */
	u_int32_t	ses_iv[2];		/* [3]DES iv */
};

struct ubsec_stats {
	u_int64_t hst_ibytes;
	u_int64_t hst_obytes;
	u_int32_t hst_ipackets;
	u_int32_t hst_opackets;
	u_int32_t hst_invalid;
	u_int32_t hst_nomem;
	u_int32_t hst_queuefull;
	u_int32_t hst_dmaerr;
	u_int32_t hst_mcrerr;
	u_int32_t hst_nodmafree;
a140 1

@


1.22.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.22.4.1 2002/01/31 22:55:36 niklas Exp $	*/
a28 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
a62 1
	u_int				q_type;
a69 31

/* C = (M ^ E) mod N */
#define	UBS_MODEXP_PAR_M	0
#define	UBS_MODEXP_PAR_E	1
#define	UBS_MODEXP_PAR_N	2
#define	UBS_MODEXP_PAR_C	3
struct ubsec_q2_modexp {
	struct ubsec_q2			me_q;
	struct cryptkop *		me_krp;
	struct ubsec_dma_alloc		me_M;
	struct ubsec_dma_alloc		me_E;
	struct ubsec_dma_alloc		me_C;
	struct ubsec_dma_alloc		me_epb;
	int				me_modbits;
	int				me_shiftbits;
};

#define	UBS_RSAPRIV_PAR_P	0
#define	UBS_RSAPRIV_PAR_Q	1
#define	UBS_RSAPRIV_PAR_DP	2
#define	UBS_RSAPRIV_PAR_DQ	3
#define	UBS_RSAPRIV_PAR_PINV	4
#define	UBS_RSAPRIV_PAR_MSGIN	5
#define	UBS_RSAPRIV_PAR_MSGOUT	6
struct ubsec_q2_rsapriv {
	struct ubsec_q2			rpr_q;
	struct cryptkop *		rpr_krp;
	struct ubsec_dma_alloc		rpr_msgin;
	struct ubsec_dma_alloc		rpr_msgout;
};

a91 3
#define	UBS_FLAGS_BIGKEY	0x04		/* 2048bit keys */
#define	UBS_FLAGS_HWNORM	0x08		/* hardware normalization */
#define	UBS_FLAGS_RNG		0x10		/* hardware rng */
a132 1
	SIMPLEQ_HEAD(,ubsec_q2)	sc_q2free;	/* free list */
d157 1
@


1.22.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.22.4.2 2002/06/11 03:42:27 art Exp $	*/
d81 1
a90 1
	int				me_normbits;
@


1.21
log
@move definitions around a bit and define a few more constants
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.20 2001/06/29 16:19:15 jason Exp $	*/
d64 14
d80 2
a81 1
	struct ubsec_dma_alloc		d_ctx;
a128 1
	u_int32_t			q_macbuf[5];
@


1.20
log
@allocate contexts during attach since we can't mess with them during
interrupts (the space allocation is wasteful, but more data will be
moved into the allocation soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.19 2001/06/08 01:59:32 jason Exp $	*/
d35 7
d100 2
a101 2
	struct ubsec_pktbuf		q_srcpkt[MAX_SCATTER-1];
	struct ubsec_pktbuf		q_dstpkt[MAX_SCATTER-1];
d107 2
a108 2
	long				q_src_packp[MAX_SCATTER];
	int				q_src_packl[MAX_SCATTER];
d111 2
a112 2
	long				q_dst_packp[MAX_SCATTER];
	int				q_dst_packl[MAX_SCATTER];
@


1.19
log
@Put back bus_dmaification of context's (seems to have been fixed by
recent changes to cryptosoft.c).  So, mcr and pktbuf handling to go...
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.18 2001/05/30 02:26:14 jason Exp $	*/
d30 5
d57 5
d82 2
d95 1
a95 1
	struct ubsec_dma_alloc		q_ctx_dma;
a119 5

/* Maximum queue length */
#ifndef UBS_MAX_NQUEUE
#define UBS_MAX_NQUEUE		60
#endif
@


1.18
log
@Un-bus_dma(9) mcr1 context and mcr operations (causes problems under load).
Reimplement mcr2 bus_dma handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.17 2001/05/23 04:46:41 jason Exp $	*/
d83 1
a83 2
	struct ubsec_pktctx		q_ctx;
	struct ubsec_pktctx_long	q_ctxl;
@


1.17
log
@bus_dmaify mcr handling (just leaves buffer lists and mac buffer to go...)
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.16 2001/05/22 22:53:38 jason Exp $	*/
d31 1
a31 1
	u_int64_t		dma_paddr;
d35 1
d50 1
a50 2
#define UBSEC_RNG_BUFSIZ	16

d70 2
a71 2
	int			sc_rnghz;	/* rng frequency */
	struct ubsec_q2_rng	sc_rng;		/* rng structures */
a80 1
	struct ubsec_dma_alloc		q_mcr_dma;
d83 2
a84 1
	struct ubsec_dma_alloc		q_ctx_dma;
a85 1
	struct ubsec_softc		*q_sc;
a91 1
	int				q_flags;
d98 1
a99 1

@


1.16
log
@- Don't poll the rng more than 100 times a second
- bus_dmaify mcr2 operations (rng)
- start bus_dma of mcr1 operations (context; mcr and pktbufs to go)
... more to come ...
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.15 2001/05/14 02:45:19 deraadt Exp $	*/
d81 1
@


1.15
log
@use real uio
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.14 2001/05/13 15:39:27 deraadt Exp $	*/
d30 22
d70 2
d83 1
a83 2
	struct ubsec_pktctx		q_ctx;
	struct ubsec_pktctx_long	q_ctxl;
d87 1
a87 1
	struct uio			*q_src, *q_dst;
d92 1
d101 1
a101 9
struct ubsec_q2 {
	SIMPLEQ_ENTRY(ubsec_q2)		q_next;
	struct ubsec_softc		*q_sc;
	struct ubsec_mcr		*q_mcr;
	void				*q_ctx;
	struct ubsec_pktbuf		q_srcpkt[MAX_SCATTER-1];
	struct ubsec_pktbuf		q_dstpkt[MAX_SCATTER-1];
	void				*q_private;
};
@


1.15.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.12 2001/01/29 00:39:21 jason Exp $	*/
d36 1
a36 1
	int			sc_5601;	/* device is 5601 */
d50 3
d60 1
d64 1
@


1.15.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.15.2.1 2001/05/14 22:26:00 niklas Exp $	*/
a29 54
/* Maximum queue length */
#ifndef UBS_MAX_NQUEUE
#define UBS_MAX_NQUEUE		60
#endif

#define	UBS_MAX_SCATTER		64	/* Maximum scatter/gather depth */
#define	UBS_MAX_AGGR		5	/* Maximum aggregation count */

#define	UBSEC_CARD(sid)		(((sid) & 0xf0000000) >> 28)
#define	UBSEC_SESSION(sid)	( (sid) & 0x0fffffff)
#define	UBSEC_SID(crd, sesn)	(((crd) << 28) | ((sesn) & 0x0fffffff))

struct ubsec_dma_alloc {
	u_int32_t		dma_paddr;
	caddr_t			dma_vaddr;
	bus_dmamap_t		dma_map;
	bus_dma_segment_t	dma_seg;
	bus_size_t		dma_size;
	int			dma_nseg;
};

struct ubsec_q2 {
	SIMPLEQ_ENTRY(ubsec_q2)		q_next;
	struct ubsec_dma_alloc		q_mcr;
	struct ubsec_dma_alloc		q_ctx;
};

struct ubsec_q2_rng {
	struct ubsec_q2			rng_q;
	struct ubsec_dma_alloc		rng_buf;
	int				rng_used;
};
#define	UBSEC_RNG_BUFSIZ	16		/* measured in 32bit words */

struct ubsec_dmachunk {
#if 0
	struct ubsec_mcr	d_mcr;
	struct ubsec_mcr_add	d_mcradd[UBS_MAX_AGGR-1];
#endif
	struct ubsec_pktbuf	d_sbuf[UBS_MAX_SCATTER-1];
	struct ubsec_pktbuf	d_dbuf[UBS_MAX_SCATTER-1];
	u_int32_t		d_macbuf[5];
	union {
		struct ubsec_pktctx_long	ctxl;
		struct ubsec_pktctx		ctx;
	} d_ctx;
};

struct ubsec_dma {
	SIMPLEQ_ENTRY(ubsec_dma)	d_next;
	struct ubsec_dmachunk		*d_dma;
	struct ubsec_dma_alloc		d_alloc;
};

d36 1
a36 1
	int			sc_flags;	/* device specific flags */
a47 4
	int			sc_rnghz;	/* rng poll time */
	struct ubsec_q2_rng	sc_rng;
	struct ubsec_dma	sc_dmaa[UBS_MAX_NQUEUE];
	SIMPLEQ_HEAD(,ubsec_dma) sc_dma;
a49 3
#define	UBS_FLAGS_KEY		0x01		/* has key accelerator */
#define	UBS_FLAGS_LONGCTX	0x02		/* uses long ipsec ctx */

d54 3
a56 3
	struct ubsec_pktbuf		q_srcpkt[UBS_MAX_SCATTER-1];
	struct ubsec_pktbuf		q_dstpkt[UBS_MAX_SCATTER-1];
	struct ubsec_dma		*q_dma;
d58 1
a59 1
	struct uio			*q_src_io, *q_dst_io;
d61 2
a62 2
	long				q_src_packp[UBS_MAX_SCATTER];
	int				q_src_packl[UBS_MAX_SCATTER];
d65 2
a66 2
	long				q_dst_packp[UBS_MAX_SCATTER];
	int				q_dst_packl[UBS_MAX_SCATTER];
d68 1
a69 1
	int				q_flags;
d71 10
a80 1
#define	UBSEC_QFLAGS_COPYOUTIV		0x1
d89 5
@


1.15.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a4 1
 * Copyright (c) 2001 Patrik Lindergren (patrik@@ipunplugged.com)
a35 2

#ifndef UBS_MAX_AGGR
a36 1
#endif
a41 4
#define UBS_DEF_RTY		0xff	/* PCI Retry Timeout */
#define UBS_DEF_TOUT		0xff	/* PCI TRDY Timeout */
#define UBS_DEF_CACHELINE	0x01	/* Cache Line setting */

d65 1
d68 1
a83 20
#define	UBS_FLAGS_KEY		0x01		/* has key accelerator */
#define	UBS_FLAGS_LONGCTX	0x02		/* uses long ipsec ctx */

struct ubsec_q {
	SIMPLEQ_ENTRY(ubsec_q)		q_next;
	int				q_nstacked_mcrs;
	struct ubsec_q			*q_stacked_mcr[UBS_MAX_AGGR-1];
	struct cryptop			*q_crp;
	struct ubsec_dma		*q_dma;

	struct mbuf			*q_src_m, *q_dst_m;
	struct uio			*q_src_io, *q_dst_io;

	bus_dmamap_t			q_src_map;
	bus_dmamap_t			q_dst_map;

	int				q_sesn;
	int				q_flags;
};

a95 1
	SIMPLEQ_HEAD(,ubsec_q)	sc_freequeue;	/* list of free queue elements */
d105 1
a105 1
	struct ubsec_q		*sc_queuea[UBS_MAX_NQUEUE];
d108 24
d137 3
a139 16
	u_int32_t	ses_hminner[5];		/* hmac inner state */
	u_int32_t	ses_hmouter[5];		/* hmac outer state */
	u_int32_t	ses_iv[2];		/* [3]DES iv */
};

struct ubsec_stats {
	u_int64_t hst_ibytes;
	u_int64_t hst_obytes;
	u_int32_t hst_ipackets;
	u_int32_t hst_opackets;
	u_int32_t hst_invalid;
	u_int32_t hst_nomem;
	u_int32_t hst_queuefull;
	u_int32_t hst_dmaerr;
	u_int32_t hst_mcrerr;
	u_int32_t hst_nodmafree;
a140 1

@


1.15.2.4
log
@Sync the SMP branch with 3.3
@
text
@a28 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
a62 1
	u_int				q_type;
a69 31

/* C = (M ^ E) mod N */
#define	UBS_MODEXP_PAR_M	0
#define	UBS_MODEXP_PAR_E	1
#define	UBS_MODEXP_PAR_N	2
struct ubsec_q2_modexp {
	struct ubsec_q2			me_q;
	struct cryptkop *		me_krp;
	struct ubsec_dma_alloc		me_M;
	struct ubsec_dma_alloc		me_E;
	struct ubsec_dma_alloc		me_C;
	struct ubsec_dma_alloc		me_epb;
	int				me_modbits;
	int				me_shiftbits;
	int				me_normbits;
};

#define	UBS_RSAPRIV_PAR_P	0
#define	UBS_RSAPRIV_PAR_Q	1
#define	UBS_RSAPRIV_PAR_DP	2
#define	UBS_RSAPRIV_PAR_DQ	3
#define	UBS_RSAPRIV_PAR_PINV	4
#define	UBS_RSAPRIV_PAR_MSGIN	5
#define	UBS_RSAPRIV_PAR_MSGOUT	6
struct ubsec_q2_rsapriv {
	struct ubsec_q2			rpr_q;
	struct cryptkop *		rpr_krp;
	struct ubsec_dma_alloc		rpr_msgin;
	struct ubsec_dma_alloc		rpr_msgout;
};

a91 3
#define	UBS_FLAGS_BIGKEY	0x04		/* 2048bit keys */
#define	UBS_FLAGS_HWNORM	0x08		/* hardware normalization */
#define	UBS_FLAGS_RNG		0x10		/* hardware rng */
a132 1
	SIMPLEQ_HEAD(,ubsec_q2)	sc_q2free;	/* free list */
d157 1
@


1.15.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.15.2.4 2003/03/28 00:38:25 niklas Exp $	*/
d16 2
@


1.14
log
@initial cut at /dev/crypto support.  takes original mbuf "try, and discard
if we fail" semantics and extends to two varients of data movement: mbuf,
or an iovec style block.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.10 2001/01/11 18:52:53 deraadt Exp $	*/
d64 1
a64 1
	struct criov			*q_src, *q_dst;
@


1.13
log
@Initial support for Broadcom 5820, which is very much like the 5805 except
that the packet context structure for ipsec has changed (added two fields
and, annoyingly, rearranged several of them).  The MCR2 operations (only
RNG is used at this point) are supported, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.12 2001/01/29 00:39:21 jason Exp $	*/
d64 1
@


1.12
log
@- add infrastructure for dealing with the key generator (MCR2)
- add support for the onboard rng using that structure
- add a interrupt status mask (differs for 5501 and 5601)
- reorganize slightly to take into account that MCR1 isn't the only reason
  for interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.11 2001/01/11 18:56:50 deraadt Exp $	*/
d36 1
a36 1
	int			sc_5601;	/* device is 5601 */
d50 3
d60 1
@


1.11
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.9 2000/08/13 22:06:48 deraadt Exp $	*/
d37 1
d39 6
a44 3
	SIMPLEQ_HEAD(,ubsec_q)	sc_queue;	/* packet queue */
	int			sc_nqueue;	/* count enqueued */
	SIMPLEQ_HEAD(,ubsec_q)	sc_qchip;	/* on chip */
d47 1
d70 10
@


1.10
log
@move ich to auich at mickey's request
@
text
@a54 1
	struct criov			*q_src, *q_dst;
@


1.9
log
@fix session code
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.7 2000/08/11 19:38:16 deraadt Exp $	*/
d55 1
@


1.8
log
@not completely working session code from jason
@
text
@d64 1
a64 1
	struct ubsec_session *		q_ses;
d77 1
a77 1
#define UBS_MAX_NQUEUE		24
@


1.7
log
@move mcr out of q; and write prelim mcr aggregation code, which does not yet
work for some reason or another, so it is currently disabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.6 2000/07/29 23:42:00 jason Exp $	*/
d41 2
d64 9
@


1.6
log
@remove the (unused) sc_intrmask, and be more careful about initializing
the BS_CTRL register... The BE32 & BE64 bits do NOT do what they imply,
so leave the bits set, and add the ones we want.  This allows ubsec to
interop with our software implementation (at least for encryption).
More work to be done in this driver though...  Many thanks to Jimmy Ruane
at Broadcom for the pointer about BE32 & BE64!
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.5 2000/06/19 02:51:29 jason Exp $	*/
d46 1
a46 1
	struct ubsec_mcr		q_mcr;
@


1.5
log
@oops, add macbuf to the queue structure
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.4 2000/06/13 05:15:19 jason Exp $	*/
a37 1
	u_int32_t		sc_intrmask;	/* interrupt mask */
@


1.4
log
@put an upperbound on queue length
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.3 2000/06/12 19:50:35 deraadt Exp $	*/
d62 1
@


1.3
log
@ESP 3des now works, after squishing 4 bugs
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.2 2000/06/03 13:14:39 jason Exp $	*/
d63 5
@


1.2
log
@Move everything to where is supposed to be (reg definitions, etc).
Add some of the skip logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsecvar.h,v 1.1 2000/05/18 01:25:19 jason Exp $	*/
d42 20
@


1.1
log
@work in progress: driver for BlueSteel (Broadcom) 5[56]01 crypto accelerator
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a29 3
/*
 * Holds data specific to a single UBSEC board.
 */
d31 11
a41 13
	struct device	sc_dv;		/* generic device */
	void *		sc_ih;		/* interrupt handler cookie */

	bus_space_handle_t	sc_sh;
	bus_space_tag_t		sc_st;
	bus_dma_tag_t		sc_dmat;

	int			sc_5601;

	int32_t sc_cid;
	int sc_maxses;
	int sc_ramsize;
	struct ubsec_session sc_sessions[2048];
@

