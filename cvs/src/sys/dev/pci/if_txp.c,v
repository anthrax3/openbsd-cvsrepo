head	1.125;
access;
symbols
	OPENBSD_6_0:1.124.0.4
	OPENBSD_6_0_BASE:1.124
	OPENBSD_5_9:1.123.0.2
	OPENBSD_5_9_BASE:1.123
	OPENBSD_5_8:1.116.0.4
	OPENBSD_5_8_BASE:1.116
	OPENBSD_5_7:1.113.0.4
	OPENBSD_5_7_BASE:1.113
	OPENBSD_5_6:1.111.0.4
	OPENBSD_5_6_BASE:1.111
	OPENBSD_5_5:1.108.0.4
	OPENBSD_5_5_BASE:1.108
	OPENBSD_5_4:1.106.0.4
	OPENBSD_5_4_BASE:1.106
	OPENBSD_5_3:1.106.0.2
	OPENBSD_5_3_BASE:1.106
	OPENBSD_5_2:1.104.0.6
	OPENBSD_5_2_BASE:1.104
	OPENBSD_5_1_BASE:1.104
	OPENBSD_5_1:1.104.0.4
	OPENBSD_5_0:1.104.0.2
	OPENBSD_5_0_BASE:1.104
	OPENBSD_4_9:1.102.0.2
	OPENBSD_4_9_BASE:1.102
	OPENBSD_4_8:1.101.0.4
	OPENBSD_4_8_BASE:1.101
	OPENBSD_4_7:1.101.0.2
	OPENBSD_4_7_BASE:1.101
	OPENBSD_4_6:1.100.0.4
	OPENBSD_4_6_BASE:1.100
	OPENBSD_4_5:1.99.0.2
	OPENBSD_4_5_BASE:1.99
	OPENBSD_4_4:1.91.0.2
	OPENBSD_4_4_BASE:1.91
	OPENBSD_4_3:1.84.0.4
	OPENBSD_4_3_BASE:1.84
	OPENBSD_4_2:1.84.0.2
	OPENBSD_4_2_BASE:1.84
	OPENBSD_4_1:1.83.0.4
	OPENBSD_4_1_BASE:1.83
	OPENBSD_4_0:1.83.0.2
	OPENBSD_4_0_BASE:1.83
	OPENBSD_3_9:1.79.0.2
	OPENBSD_3_9_BASE:1.79
	OPENBSD_3_8:1.78.0.2
	OPENBSD_3_8_BASE:1.78
	OPENBSD_3_7:1.76.0.2
	OPENBSD_3_7_BASE:1.76
	OPENBSD_3_6:1.72.0.2
	OPENBSD_3_6_BASE:1.72
	SMP_SYNC_A:1.72
	SMP_SYNC_B:1.72
	OPENBSD_3_5:1.71.0.2
	OPENBSD_3_5_BASE:1.71
	OPENBSD_3_4:1.69.0.2
	OPENBSD_3_4_BASE:1.69
	UBC_SYNC_A:1.68
	OPENBSD_3_3:1.68.0.2
	OPENBSD_3_3_BASE:1.68
	OPENBSD_3_2:1.66.0.2
	OPENBSD_3_2_BASE:1.66
	OPENBSD_3_1:1.63.0.2
	OPENBSD_3_1_BASE:1.63
	UBC_SYNC_B:1.66
	UBC:1.59.0.2
	UBC_BASE:1.59
	OPENBSD_3_0:1.56.0.2
	OPENBSD_3_0_BASE:1.56
	SMP:1.27.0.2
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_9:1.20.0.2;
locks; strict;
comment	@ * @;


1.125
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.124;
commitid	VyLWTsbepAOk7VQM;

1.124
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.123;
commitid	8YSL8ByWzGeIGBiJ;

1.123
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.122;
commitid	fbhqfhfdKxBcsetK;

1.122
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.121;
commitid	B0kwmVGiD5DVx4kv;

1.121
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.120;
commitid	5gdEnqVoJuTuwdTu;

1.120
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.119;
commitid	5DvsamK0GblTp8ww;

1.119
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.118;
commitid	eYnPulzvLjDImPCa;

1.118
date	2015.11.14.17.54.57;	author mpi;	state Exp;
branches;
next	1.117;
commitid	Waft2RDjXAxr4qZ9;

1.117
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.116;
commitid	hPF95ClMUQfeqQDX;

1.116
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.115;
commitid	MVWrtktB46JRxFWT;

1.115
date	2015.04.30.07.51.07;	author mpi;	state Exp;
branches;
next	1.114;
commitid	H09AuNxNnUcYramX;

1.114
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.113;
commitid	p4LJxGKbi0BU2cG6;

1.113
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.112;
commitid	yM2VFFhpDTeFQlve;

1.112
date	2014.12.06.23.20.17;	author krw;	state Exp;
branches;
next	1.111;
commitid	dHu3Jb8ymJQQ9GXS;

1.111
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.110;
commitid	TGHgrLxu6sxZoiFt;

1.110
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.109;
commitid	JtO5uXxVcnZfhUkR;

1.109
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.108;
commitid	OBNa5kfxQ2UXoiIw;

1.108
date	2013.11.26.09.50.33;	author mpi;	state Exp;
branches;
next	1.107;

1.107
date	2013.08.07.01.06.38;	author bluhm;	state Exp;
branches;
next	1.106;

1.106
date	2012.12.01.09.55.03;	author brad;	state Exp;
branches;
next	1.105;

1.105
date	2012.11.23.18.40.30;	author gsoares;	state Exp;
branches;
next	1.104;

1.104
date	2011.04.05.18.01.21;	author henning;	state Exp;
branches;
next	1.103;

1.103
date	2011.04.03.15.36.03;	author jasper;	state Exp;
branches;
next	1.102;

1.102
date	2010.09.20.07.40.38;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2009.08.13.14.24.47;	author jasper;	state Exp;
branches;
next	1.100;

1.100
date	2009.03.24.11.12.10;	author kettenis;	state Exp;
branches;
next	1.99;

1.99
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.98;

1.98
date	2008.11.09.15.08.26;	author naddy;	state Exp;
branches;
next	1.97;

1.97
date	2008.10.16.19.18.03;	author naddy;	state Exp;
branches;
next	1.96;

1.96
date	2008.10.16.19.16.21;	author naddy;	state Exp;
branches;
next	1.95;

1.95
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.94;

1.94
date	2008.09.18.15.16.30;	author naddy;	state Exp;
branches;
next	1.93;

1.93
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.92;

1.92
date	2008.09.08.07.38.33;	author brad;	state Exp;
branches;
next	1.91;

1.91
date	2008.05.31.02.08.14;	author brad;	state Exp;
branches;
next	1.90;

1.90
date	2008.05.22.21.03.41;	author brad;	state Exp;
branches;
next	1.89;

1.89
date	2008.05.22.19.23.04;	author mk;	state Exp;
branches;
next	1.88;

1.88
date	2008.05.22.06.48.56;	author brad;	state Exp;
branches;
next	1.87;

1.87
date	2008.05.22.02.32.29;	author brad;	state Exp;
branches;
next	1.86;

1.86
date	2008.05.22.02.30.55;	author brad;	state Exp;
branches;
next	1.85;

1.85
date	2008.04.03.21.43.21;	author brad;	state Exp;
branches;
next	1.84;

1.84
date	2007.04.11.14.41.15;	author claudio;	state Exp;
branches;
next	1.83;

1.83
date	2006.06.29.21.36.40;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2006.05.28.00.04.24;	author jason;	state Exp;
branches;
next	1.81;

1.81
date	2006.04.26.15.47.07;	author jason;	state Exp;
branches;
next	1.80;

1.80
date	2006.03.25.22.41.45;	author djm;	state Exp;
branches;
next	1.79;

1.79
date	2006.02.16.21.02.34;	author brad;	state Exp;
branches;
next	1.78;

1.78
date	2005.06.15.16.28.09;	author camield;	state Exp;
branches;
next	1.77;

1.77
date	2005.04.25.17.55.51;	author brad;	state Exp;
branches;
next	1.76;

1.76
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.75;

1.75
date	2004.12.17.14.10.40;	author grange;	state Exp;
branches;
next	1.74;

1.74
date	2004.12.14.01.50.42;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.72;

1.72
date	2004.05.31.19.25.00;	author mcbride;	state Exp;
branches;
next	1.71;

1.71
date	2003.12.29.23.06.55;	author brad;	state Exp;
branches;
next	1.70;

1.70
date	2003.10.22.11.02.41;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2003.06.02.19.03.37;	author jason;	state Exp;
branches;
next	1.68;

1.68
date	2003.02.28.00.51.36;	author jason;	state Exp;
branches;
next	1.67;

1.67
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.66;

1.66
date	2002.07.11.20.27.04;	author jason;	state Exp;
branches;
next	1.65;

1.65
date	2002.07.11.20.15.46;	author jason;	state Exp;
branches;
next	1.64;

1.64
date	2002.04.30.23.18.41;	author jason;	state Exp;
branches;
next	1.63;

1.63
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	2002.03.12.09.51.20;	author kjc;	state Exp;
branches;
next	1.61;

1.61
date	2002.02.15.20.45.31;	author nordin;	state Exp;
branches;
next	1.60;

1.60
date	2002.02.07.16.56.34;	author jason;	state Exp;
branches;
next	1.59;

1.59
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.59.2.1;
next	1.58;

1.58
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.57;

1.57
date	2001.11.02.19.31.00;	author jason;	state Exp;
branches;
next	1.56;

1.56
date	2001.09.21.17.55.44;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2001.08.27.22.06.52;	author jason;	state Exp;
branches;
next	1.53;

1.53
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2001.08.24.21.11.14;	author jason;	state Exp;
branches;
next	1.51;

1.51
date	2001.08.17.00.01.46;	author jason;	state Exp;
branches;
next	1.50;

1.50
date	2001.08.12.20.03.49;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2001.08.10.15.58.49;	author jason;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.27.06.34.50;	author kjc;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.24.22.58.01;	author fgsch;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.23.22.56.51;	author jason;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.23.20.54.15;	author jason;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.23.04.44.25;	author jason;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.23.04.20.42;	author jason;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.22.14.39.20;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.12.15.40.31;	author niklas;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.05.02.15.19;	author jason;	state Exp;
branches;
next	1.39;

1.39
date	2001.05.30.14.41.59;	author jason;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.30.05.30.17;	author jason;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.30.04.49.32;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.30.04.26.55;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.29.01.01.51;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.28.10.32.23;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.25.10.04.54;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.16.14.34.29;	author fgsch;	state Exp;
branches;
next	1.31;

1.31
date	2001.05.16.02.47.49;	author jason;	state Exp;
branches;
next	1.30;

1.30
date	2001.05.16.02.01.16;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.15.14.57.28;	author jason;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.15.05.18.13;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.10.00.44.33;	author jason;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2001.05.09.02.25.08;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.08.05.22.01;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.08.03.52.43;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.03.05.22.51;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.02.15.00.32;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	2001.04.30.04.52.20;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.15.22.47.38;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.15.21.17.53;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.15.21.03.21;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.13.20.13.30;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.13.17.50.30;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.12.22.40.12;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.12.20.36.06;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.12.15.01.19;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.11.15.41.08;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.10.22.10.09;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.10.19.52.37;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.09.22.04.59;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.09.05.36.16;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.09.04.09.17;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.09.03.15.47;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.08.21.47.45;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.08.18.26.38;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.08.05.40.23;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.08.05.28.49;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.08.02.16.52;	author jason;	state Exp;
branches;
next	;

1.27.2.1
date	2001.05.14.22.25.48;	author niklas;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2001.07.04.10.42.26;	author niklas;	state Exp;
branches;
next	1.27.2.3;

1.27.2.3
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.27.2.4;

1.27.2.4
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.27.2.5;

1.27.2.5
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.27.2.6;

1.27.2.6
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.27.2.7;

1.27.2.7
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.27.2.8;

1.27.2.8
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.27.2.9;

1.27.2.9
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	1.27.2.10;

1.27.2.10
date	2004.06.05.23.12.51;	author niklas;	state Exp;
branches;
next	;

1.59.2.1
date	2002.06.11.03.42.26;	author art;	state Exp;
branches;
next	1.59.2.2;

1.59.2.2
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	1.59.2.3;

1.59.2.3
date	2003.05.19.22.18.01;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.125
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_txp.c,v 1.124 2016/04/13 10:34:32 mpi Exp $	*/

/*
 * Copyright (c) 2001
 *	Jason L. Wright <jason@@thought.net>, Theo de Raadt, and
 *	Aaron Campbell <aaron@@monkey.org>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR THE VOICES IN THEIR HEADS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Driver for 3c990 (Typhoon) Ethernet ASIC
 */

#include "bpfilter.h"
#include "vlan.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/timeout.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/bus.h>

#include <dev/mii/mii.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/pci/if_txpreg.h>

/*
 * These currently break the 3c990 firmware, hopefully will be resolved
 * at some point.
 */
#undef	TRY_TX_UDP_CSUM
#undef	TRY_TX_TCP_CSUM

int txp_probe(struct device *, void *, void *);
void txp_attach(struct device *, struct device *, void *);
void txp_attachhook(struct device *);
int txp_intr(void *);
void txp_tick(void *);
int txp_ioctl(struct ifnet *, u_long, caddr_t);
void txp_start(struct ifnet *);
void txp_stop(struct txp_softc *);
void txp_init(struct txp_softc *);
void txp_watchdog(struct ifnet *);

int txp_chip_init(struct txp_softc *);
int txp_reset_adapter(struct txp_softc *);
int txp_download_fw(struct txp_softc *);
int txp_download_fw_wait(struct txp_softc *);
int txp_download_fw_section(struct txp_softc *,
    struct txp_fw_section_header *, int, u_char *, size_t);
int txp_alloc_rings(struct txp_softc *);
void txp_dma_free(struct txp_softc *, struct txp_dma_alloc *);
int txp_dma_malloc(struct txp_softc *, bus_size_t, struct txp_dma_alloc *, int);
void txp_set_filter(struct txp_softc *);

int txp_cmd_desc_numfree(struct txp_softc *);
int txp_command(struct txp_softc *, u_int16_t, u_int16_t, u_int32_t,
    u_int32_t, u_int16_t *, u_int32_t *, u_int32_t *, int);
int txp_command2(struct txp_softc *, u_int16_t, u_int16_t,
    u_int32_t, u_int32_t, struct txp_ext_desc *, u_int8_t,
    struct txp_rsp_desc **, int);
int txp_response(struct txp_softc *, u_int32_t, u_int16_t, u_int16_t,
    struct txp_rsp_desc **);
void txp_rsp_fixup(struct txp_softc *, struct txp_rsp_desc *,
    struct txp_rsp_desc *);
void txp_capabilities(struct txp_softc *);

void txp_ifmedia_sts(struct ifnet *, struct ifmediareq *);
int txp_ifmedia_upd(struct ifnet *);
void txp_show_descriptor(void *);
void txp_tx_reclaim(struct txp_softc *, struct txp_tx_ring *,
    struct txp_dma_alloc *);
void txp_rxbuf_reclaim(struct txp_softc *);
void txp_rx_reclaim(struct txp_softc *, struct txp_rx_ring *,
    struct txp_dma_alloc *);

struct cfattach txp_ca = {
	sizeof(struct txp_softc), txp_probe, txp_attach,
};

struct cfdriver txp_cd = {
	NULL, "txp", DV_IFNET
};

const struct pci_matchid txp_devices[] = {
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990TX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990TX95 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990TX97 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990SVR95 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990SVR97 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C990BTXM },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C990BSVR },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990FX },
};

int
txp_probe(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, txp_devices,
	    nitems(txp_devices)));
}

void
txp_attachhook(struct device *self)
{
	struct txp_softc *sc = (struct txp_softc *)self;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_int16_t p1;
	u_int32_t p2;
	int s;

	s = splnet();
	printf("%s: ", sc->sc_dev.dv_xname);

	if (txp_chip_init(sc)) {
		printf("failed chip init\n");
		splx(s);
		return;
	}

	if (txp_download_fw(sc)) {
		splx(s);
		return;
	}

	if (txp_alloc_rings(sc)) {
		splx(s);
		return;
	}

	if (txp_command(sc, TXP_CMD_MAX_PKT_SIZE_WRITE, TXP_MAX_PKTLEN, 0, 0,
	    NULL, NULL, NULL, 1)) {
		splx(s);
		return;
	}

	if (txp_command(sc, TXP_CMD_STATION_ADDRESS_READ, 0, 0, 0,
	    &p1, &p2, NULL, 1)) {
		splx(s);
		return;
	}

	p1 = htole16(p1);
	sc->sc_arpcom.ac_enaddr[0] = ((u_int8_t *)&p1)[1];
	sc->sc_arpcom.ac_enaddr[1] = ((u_int8_t *)&p1)[0];
	p2 = htole32(p2);
	sc->sc_arpcom.ac_enaddr[2] = ((u_int8_t *)&p2)[3];
	sc->sc_arpcom.ac_enaddr[3] = ((u_int8_t *)&p2)[2];
	sc->sc_arpcom.ac_enaddr[4] = ((u_int8_t *)&p2)[1];
	sc->sc_arpcom.ac_enaddr[5] = ((u_int8_t *)&p2)[0];

	printf("address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));
	sc->sc_cold = 0;

	ifmedia_init(&sc->sc_ifmedia, 0, txp_ifmedia_upd, txp_ifmedia_sts);
	ifmedia_add(&sc->sc_ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);
	ifmedia_add(&sc->sc_ifmedia, IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);
	ifmedia_add(&sc->sc_ifmedia, IFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);
	ifmedia_add(&sc->sc_ifmedia, IFM_ETHER|IFM_100_TX, 0, NULL);
	ifmedia_add(&sc->sc_ifmedia, IFM_ETHER|IFM_100_TX|IFM_HDX, 0, NULL);
	ifmedia_add(&sc->sc_ifmedia, IFM_ETHER|IFM_100_TX|IFM_FDX, 0, NULL);
	ifmedia_add(&sc->sc_ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);

	sc->sc_xcvr = TXP_XCVR_AUTO;
	txp_command(sc, TXP_CMD_XCVR_SELECT, TXP_XCVR_AUTO, 0, 0,
	    NULL, NULL, NULL, 0);
	ifmedia_set(&sc->sc_ifmedia, IFM_ETHER|IFM_AUTO);

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = txp_ioctl;
	ifp->if_start = txp_start;
	ifp->if_watchdog = txp_watchdog;
	ifp->if_baudrate = IF_Mbps(10);
	IFQ_SET_MAXLEN(&ifp->if_snd, TX_ENTRIES);
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);

	txp_capabilities(sc);

	timeout_set(&sc->sc_tick, txp_tick, sc);

	/*
	 * Attach us everywhere
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

	splx(s);
}

void
txp_attach(struct device *parent, struct device *self, void *aux)
{
	struct txp_softc *sc = (struct txp_softc *)self;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
	bus_size_t iosize;

	sc->sc_cold = 1;

	if (pci_mapreg_map(pa, TXP_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->sc_bt, &sc->sc_bh, NULL, &iosize, 0)) {
		printf(": can't map mem space %d\n", 0);
		return;
	}

	sc->sc_dmat = pa->pa_dmat;

	/*
	 * Allocate our interrupt.
	 */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		return;
	}

	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, txp_intr, sc,
	    self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s\n", intrstr);

	config_mountroot(self, txp_attachhook);

}

int
txp_chip_init(struct txp_softc *sc)
{
	/* disable interrupts */
	WRITE_REG(sc, TXP_IER, 0);
	WRITE_REG(sc, TXP_IMR,
	    TXP_INT_SELF | TXP_INT_PCI_TABORT | TXP_INT_PCI_MABORT |
	    TXP_INT_DMA3 | TXP_INT_DMA2 | TXP_INT_DMA1 | TXP_INT_DMA0 |
	    TXP_INT_LATCH);

	/* ack all interrupts */
	WRITE_REG(sc, TXP_ISR, TXP_INT_RESERVED | TXP_INT_LATCH |
	    TXP_INT_A2H_7 | TXP_INT_A2H_6 | TXP_INT_A2H_5 | TXP_INT_A2H_4 |
	    TXP_INT_SELF | TXP_INT_PCI_TABORT | TXP_INT_PCI_MABORT |
	    TXP_INT_DMA3 | TXP_INT_DMA2 | TXP_INT_DMA1 | TXP_INT_DMA0 |
	    TXP_INT_A2H_3 | TXP_INT_A2H_2 | TXP_INT_A2H_1 | TXP_INT_A2H_0);

	if (txp_reset_adapter(sc))
		return (-1);

	/* disable interrupts */
	WRITE_REG(sc, TXP_IER, 0);
	WRITE_REG(sc, TXP_IMR,
	    TXP_INT_SELF | TXP_INT_PCI_TABORT | TXP_INT_PCI_MABORT |
	    TXP_INT_DMA3 | TXP_INT_DMA2 | TXP_INT_DMA1 | TXP_INT_DMA0 |
	    TXP_INT_LATCH);

	/* ack all interrupts */
	WRITE_REG(sc, TXP_ISR, TXP_INT_RESERVED | TXP_INT_LATCH |
	    TXP_INT_A2H_7 | TXP_INT_A2H_6 | TXP_INT_A2H_5 | TXP_INT_A2H_4 |
	    TXP_INT_SELF | TXP_INT_PCI_TABORT | TXP_INT_PCI_MABORT |
	    TXP_INT_DMA3 | TXP_INT_DMA2 | TXP_INT_DMA1 | TXP_INT_DMA0 |
	    TXP_INT_A2H_3 | TXP_INT_A2H_2 | TXP_INT_A2H_1 | TXP_INT_A2H_0);

	return (0);
}

int
txp_reset_adapter(struct txp_softc *sc)
{
	u_int32_t r;
	int i;

	WRITE_REG(sc, TXP_SRR, TXP_SRR_ALL);
	DELAY(1000);
	WRITE_REG(sc, TXP_SRR, 0);

	/* Should wait max 6 seconds */
	for (i = 0; i < 6000; i++) {
		r = READ_REG(sc, TXP_A2H_0);
		if (r == STAT_WAITING_FOR_HOST_REQUEST)
			break;
		DELAY(1000);
	}

	if (r != STAT_WAITING_FOR_HOST_REQUEST) {
		printf("%s: reset hung\n", TXP_DEVNAME(sc));
		return (-1);
	}

	return (0);
}

int
txp_download_fw(struct txp_softc *sc)
{
	struct txp_fw_file_header *fileheader;
	struct txp_fw_section_header *secthead;
	u_int32_t r, i, ier, imr;
	size_t buflen;
	int sect, err;
	u_char *buf;

	ier = READ_REG(sc, TXP_IER);
	WRITE_REG(sc, TXP_IER, ier | TXP_INT_A2H_0);

	imr = READ_REG(sc, TXP_IMR);
	WRITE_REG(sc, TXP_IMR, imr | TXP_INT_A2H_0);

	for (i = 0; i < 10000; i++) {
		r = READ_REG(sc, TXP_A2H_0);
		if (r == STAT_WAITING_FOR_HOST_REQUEST)
			break;
		DELAY(50);
	}
	if (r != STAT_WAITING_FOR_HOST_REQUEST) {
		printf("not waiting for host request\n");
		return (-1);
	}

	/* Ack the status */
	WRITE_REG(sc, TXP_ISR, TXP_INT_A2H_0);

	err = loadfirmware("3c990", &buf, &buflen);
	if (err) {
		printf("failed loadfirmware of file 3c990: errno %d\n",
		    err);
		return (err);
	}

	fileheader = (struct txp_fw_file_header *)buf;
	if (bcmp("TYPHOON", fileheader->magicid, sizeof(fileheader->magicid))) {
		printf("firmware invalid magic\n");
		goto fail;
	}

	/* Tell boot firmware to get ready for image */
	WRITE_REG(sc, TXP_H2A_1, letoh32(fileheader->addr));
	WRITE_REG(sc, TXP_H2A_2, letoh32(fileheader->hmac[0]));
	WRITE_REG(sc, TXP_H2A_3, letoh32(fileheader->hmac[1]));
	WRITE_REG(sc, TXP_H2A_4, letoh32(fileheader->hmac[2]));
	WRITE_REG(sc, TXP_H2A_5, letoh32(fileheader->hmac[3]));
	WRITE_REG(sc, TXP_H2A_6, letoh32(fileheader->hmac[4]));
	WRITE_REG(sc, TXP_H2A_0, TXP_BOOTCMD_RUNTIME_IMAGE);

	if (txp_download_fw_wait(sc)) {
		printf("fw wait failed, initial\n");
		goto fail;
	}

	secthead = (struct txp_fw_section_header *)(buf +
	    sizeof(struct txp_fw_file_header));

	for (sect = 0; sect < letoh32(fileheader->nsections); sect++) {
		if (txp_download_fw_section(sc, secthead, sect, buf, buflen))
			goto fail;
		secthead = (struct txp_fw_section_header *)
		    (((u_int8_t *)secthead) + letoh32(secthead->nbytes) +
			sizeof(*secthead));
	}

	WRITE_REG(sc, TXP_H2A_0, TXP_BOOTCMD_DOWNLOAD_COMPLETE);

	for (i = 0; i < 10000; i++) {
		r = READ_REG(sc, TXP_A2H_0);
		if (r == STAT_WAITING_FOR_BOOT)
			break;
		DELAY(50);
	}
	if (r != STAT_WAITING_FOR_BOOT) {
		printf("not waiting for boot\n");
		goto fail;
	}

	WRITE_REG(sc, TXP_IER, ier);
	WRITE_REG(sc, TXP_IMR, imr);

	free(buf, M_DEVBUF, 0);
	return (0);
fail:
	free(buf, M_DEVBUF, 0);
	return (-1);
}

int
txp_download_fw_wait(struct txp_softc *sc)
{
	u_int32_t i, r;

	for (i = 0; i < 10000; i++) {
		r = READ_REG(sc, TXP_ISR);
		if (r & TXP_INT_A2H_0)
			break;
		DELAY(50);
	}

	if (!(r & TXP_INT_A2H_0)) {
		printf("fw wait failed comm0\n");
		return (-1);
	}

	WRITE_REG(sc, TXP_ISR, TXP_INT_A2H_0);

	r = READ_REG(sc, TXP_A2H_0);
	if (r != STAT_WAITING_FOR_SEGMENT) {
		printf("fw not waiting for segment\n");
		return (-1);
	}
	return (0);
}

int
txp_download_fw_section(struct txp_softc *sc,
    struct txp_fw_section_header *sect, int sectnum, u_char *buf,
    size_t buflen)
{
	struct txp_dma_alloc dma;
	int rseg, err = 0;
	struct mbuf m;
	u_int16_t csum;

	/* Skip zero length sections */
	if (sect->nbytes == 0)
		return (0);

	/* Make sure we aren't past the end of the image */
	rseg = ((u_int8_t *)sect) - ((u_int8_t *)buf);
	if (rseg >= buflen) {
		printf("fw invalid section address, section %d\n", sectnum);
		return (-1);
	}

	/* Make sure this section doesn't go past the end */
	rseg += letoh32(sect->nbytes);
	if (rseg >= buflen) {
		printf("fw truncated section %d\n", sectnum);
		return (-1);
	}

	/* map a buffer, copy segment to it, get physaddr */
	if (txp_dma_malloc(sc, letoh32(sect->nbytes), &dma, 0)) {
		printf("fw dma malloc failed, section %d\n", sectnum);
		return (-1);
	}

	bcopy(((u_int8_t *)sect) + sizeof(*sect), dma.dma_vaddr,
	    letoh32(sect->nbytes));

	/*
	 * dummy up mbuf and verify section checksum
	 */
	m.m_type = MT_DATA;
	m.m_next = m.m_nextpkt = NULL;
	m.m_len = letoh32(sect->nbytes);
	m.m_data = dma.dma_vaddr;
	m.m_flags = 0;
	csum = in_cksum(&m, letoh32(sect->nbytes));
	if (csum != sect->cksum) {
		printf("fw section %d, bad cksum (expected 0x%x got 0x%x)\n",
		    sectnum, sect->cksum, csum);
		err = -1;
		goto bail;
	}

	bus_dmamap_sync(sc->sc_dmat, dma.dma_map, 0,
	    dma.dma_map->dm_mapsize, BUS_DMASYNC_PREWRITE);

	WRITE_REG(sc, TXP_H2A_1, letoh32(sect->nbytes));
	WRITE_REG(sc, TXP_H2A_2, letoh16(sect->cksum));
	WRITE_REG(sc, TXP_H2A_3, letoh32(sect->addr));
	WRITE_REG(sc, TXP_H2A_4, dma.dma_paddr >> 32);
	WRITE_REG(sc, TXP_H2A_5, dma.dma_paddr & 0xffffffff);
	WRITE_REG(sc, TXP_H2A_0, TXP_BOOTCMD_SEGMENT_AVAILABLE);

	if (txp_download_fw_wait(sc)) {
		printf("%s: fw wait failed, section %d\n",
		    sc->sc_dev.dv_xname, sectnum);
		err = -1;
	}

	bus_dmamap_sync(sc->sc_dmat, dma.dma_map, 0,
	    dma.dma_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);

bail:
	txp_dma_free(sc, &dma);

	return (err);
}

int
txp_intr(void *vsc)
{
	struct txp_softc *sc = vsc;
	struct txp_hostvar *hv = sc->sc_hostvar;
	u_int32_t isr;
	int claimed = 0;

	/* mask all interrupts */
	WRITE_REG(sc, TXP_IMR, TXP_INT_RESERVED | TXP_INT_SELF |
	    TXP_INT_A2H_7 | TXP_INT_A2H_6 | TXP_INT_A2H_5 | TXP_INT_A2H_4 |
	    TXP_INT_A2H_2 | TXP_INT_A2H_1 | TXP_INT_A2H_0 |
	    TXP_INT_DMA3 | TXP_INT_DMA2 | TXP_INT_DMA1 | TXP_INT_DMA0 |
	    TXP_INT_PCI_TABORT | TXP_INT_PCI_MABORT |  TXP_INT_LATCH);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
	    sizeof(struct txp_hostvar), BUS_DMASYNC_POSTWRITE|BUS_DMASYNC_POSTREAD);

	isr = READ_REG(sc, TXP_ISR);
	while (isr) {
		claimed = 1;
		WRITE_REG(sc, TXP_ISR, isr);

		if ((*sc->sc_rxhir.r_roff) != (*sc->sc_rxhir.r_woff))
			txp_rx_reclaim(sc, &sc->sc_rxhir, &sc->sc_rxhiring_dma);
		if ((*sc->sc_rxlor.r_roff) != (*sc->sc_rxlor.r_woff))
			txp_rx_reclaim(sc, &sc->sc_rxlor, &sc->sc_rxloring_dma);

		if (hv->hv_rx_buf_write_idx == hv->hv_rx_buf_read_idx)
			txp_rxbuf_reclaim(sc);

		if (sc->sc_txhir.r_cnt && (sc->sc_txhir.r_cons !=
		    TXP_OFFSET2IDX(letoh32(*(sc->sc_txhir.r_off)))))
			txp_tx_reclaim(sc, &sc->sc_txhir, &sc->sc_txhiring_dma);

		if (sc->sc_txlor.r_cnt && (sc->sc_txlor.r_cons !=
		    TXP_OFFSET2IDX(letoh32(*(sc->sc_txlor.r_off)))))
			txp_tx_reclaim(sc, &sc->sc_txlor, &sc->sc_txloring_dma);

		isr = READ_REG(sc, TXP_ISR);
	}

	bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
	    sizeof(struct txp_hostvar), BUS_DMASYNC_POSTWRITE|BUS_DMASYNC_POSTREAD);

	/* unmask all interrupts */
	WRITE_REG(sc, TXP_IMR, TXP_INT_A2H_3);

	txp_start(&sc->sc_arpcom.ac_if);

	return (claimed);
}

void
txp_rx_reclaim(struct txp_softc *sc, struct txp_rx_ring *r,
    struct txp_dma_alloc *dma)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct txp_rx_desc *rxd;
	struct mbuf *m;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct txp_swdesc *sd;
	u_int32_t roff, woff;
	int idx;
	u_int16_t sumflags = 0;

	roff = letoh32(*r->r_roff);
	woff = letoh32(*r->r_woff);
	idx = roff / sizeof(struct txp_rx_desc);
	rxd = r->r_desc + idx;

	while (roff != woff) {

		bus_dmamap_sync(sc->sc_dmat, dma->dma_map,
		    idx * sizeof(struct txp_rx_desc), sizeof(struct txp_rx_desc),
		    BUS_DMASYNC_POSTREAD);

		if (rxd->rx_flags & RX_FLAGS_ERROR) {
			printf("%s: error 0x%x\n", sc->sc_dev.dv_xname,
			    letoh32(rxd->rx_stat));
			ifp->if_ierrors++;
			goto next;
		}

		/* retrieve stashed pointer */
		bcopy((u_long *)&rxd->rx_vaddrlo, &sd, sizeof(sd));

		bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
		    sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(sc->sc_dmat, sd->sd_map);
		bus_dmamap_destroy(sc->sc_dmat, sd->sd_map);
		m = sd->sd_mbuf;
		free(sd, M_DEVBUF, 0);
		m->m_pkthdr.len = m->m_len = letoh16(rxd->rx_len);

#ifdef __STRICT_ALIGNMENT
		{
			/*
			 * XXX Nice chip, except it won't accept "off by 2"
			 * buffers, so we're force to copy.  Supposedly
			 * this will be fixed in a newer firmware rev
			 * and this will be temporary.
			 */
			struct mbuf *mnew;

			MGETHDR(mnew, M_DONTWAIT, MT_DATA);
			if (mnew == NULL) {
				m_freem(m);
				goto next;
			}
			if (m->m_len > (MHLEN - 2)) {
				MCLGET(mnew, M_DONTWAIT);
				if (!(mnew->m_flags & M_EXT)) {
					m_freem(mnew);
					m_freem(m);
					goto next;
				}
			}
			mnew->m_pkthdr.len = mnew->m_len = m->m_len;
			mnew->m_data += 2;
			bcopy(m->m_data, mnew->m_data, m->m_len);
			m_freem(m);
			m = mnew;
		}
#endif

#if NVLAN > 0
		/*
		 * XXX Another firmware bug: the vlan encapsulation
		 * is always removed, even when we tell the card not
		 * to do that.  Restore the vlan encapsulation below.
		 */
		if (rxd->rx_stat & htole32(RX_STAT_VLAN)) {
			m->m_pkthdr.ether_vtag = ntohs(rxd->rx_vlan >> 16);
			m->m_flags |= M_VLANTAG;
		}
#endif

		if (rxd->rx_stat & htole32(RX_STAT_IPCKSUMBAD))
			sumflags |= M_IPV4_CSUM_IN_BAD;
		else if (rxd->rx_stat & htole32(RX_STAT_IPCKSUMGOOD))
			sumflags |= M_IPV4_CSUM_IN_OK;

		if (rxd->rx_stat & htole32(RX_STAT_TCPCKSUMBAD))
			sumflags |= M_TCP_CSUM_IN_BAD;
		else if (rxd->rx_stat & htole32(RX_STAT_TCPCKSUMGOOD))
			sumflags |= M_TCP_CSUM_IN_OK;

		if (rxd->rx_stat & htole32(RX_STAT_UDPCKSUMBAD))
			sumflags |= M_UDP_CSUM_IN_BAD;
		else if (rxd->rx_stat & htole32(RX_STAT_UDPCKSUMGOOD))
			sumflags |= M_UDP_CSUM_IN_OK;

		m->m_pkthdr.csum_flags = sumflags;

		ml_enqueue(&ml, m);

next:
		bus_dmamap_sync(sc->sc_dmat, dma->dma_map,
		    idx * sizeof(struct txp_rx_desc), sizeof(struct txp_rx_desc),
		    BUS_DMASYNC_PREREAD);

		roff += sizeof(struct txp_rx_desc);
		if (roff == (RX_ENTRIES * sizeof(struct txp_rx_desc))) {
			idx = 0;
			roff = 0;
			rxd = r->r_desc;
		} else {
			idx++;
			rxd++;
		}
		woff = letoh32(*r->r_woff);
	}

	if_input(ifp, &ml);

	*r->r_roff = htole32(woff);
}

void
txp_rxbuf_reclaim(struct txp_softc *sc)
{
	struct txp_hostvar *hv = sc->sc_hostvar;
	struct txp_rxbuf_desc *rbd;
	struct txp_swdesc *sd;
	u_int32_t i, end;

	end = TXP_OFFSET2IDX(letoh32(hv->hv_rx_buf_read_idx));
	i = TXP_OFFSET2IDX(letoh32(hv->hv_rx_buf_write_idx));

	if (++i == RXBUF_ENTRIES)
		i = 0;

	rbd = sc->sc_rxbufs + i;

	while (i != end) {
		sd = (struct txp_swdesc *)malloc(sizeof(struct txp_swdesc),
		    M_DEVBUF, M_NOWAIT);
		if (sd == NULL)
			break;

		MGETHDR(sd->sd_mbuf, M_DONTWAIT, MT_DATA);
		if (sd->sd_mbuf == NULL)
			goto err_sd;

		MCLGET(sd->sd_mbuf, M_DONTWAIT);
		if ((sd->sd_mbuf->m_flags & M_EXT) == 0)
			goto err_mbuf;
		sd->sd_mbuf->m_pkthdr.len = sd->sd_mbuf->m_len = MCLBYTES;
		if (bus_dmamap_create(sc->sc_dmat, TXP_MAX_PKTLEN, 1,
		    TXP_MAX_PKTLEN, 0, BUS_DMA_NOWAIT, &sd->sd_map))
			goto err_mbuf;
		if (bus_dmamap_load_mbuf(sc->sc_dmat, sd->sd_map, sd->sd_mbuf,
		    BUS_DMA_NOWAIT)) {
			bus_dmamap_destroy(sc->sc_dmat, sd->sd_map);
			goto err_mbuf;
		}

		bus_dmamap_sync(sc->sc_dmat, sc->sc_rxbufring_dma.dma_map,
		    i * sizeof(struct txp_rxbuf_desc),
		    sizeof(struct txp_rxbuf_desc), BUS_DMASYNC_POSTWRITE);
		    
		/* stash away pointer */
		bcopy(&sd, (u_long *)&rbd->rb_vaddrlo, sizeof(sd));

		rbd->rb_paddrlo = ((u_int64_t)sd->sd_map->dm_segs[0].ds_addr)
		    & 0xffffffff;
		rbd->rb_paddrhi = ((u_int64_t)sd->sd_map->dm_segs[0].ds_addr)
		    >> 32;

		bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
		    sd->sd_map->dm_mapsize, BUS_DMASYNC_PREREAD);

		bus_dmamap_sync(sc->sc_dmat, sc->sc_rxbufring_dma.dma_map,
		    i * sizeof(struct txp_rxbuf_desc),
		    sizeof(struct txp_rxbuf_desc), BUS_DMASYNC_PREWRITE);

		hv->hv_rx_buf_write_idx = htole32(TXP_IDX2OFFSET(i));

		if (++i == RXBUF_ENTRIES) {
			i = 0;
			rbd = sc->sc_rxbufs;
		} else
			rbd++;
	}
	return;

err_mbuf:
	m_freem(sd->sd_mbuf);
err_sd:
	free(sd, M_DEVBUF, 0);
}

/*
 * Reclaim mbufs and entries from a transmit ring.
 */
void
txp_tx_reclaim(struct txp_softc *sc, struct txp_tx_ring *r,
    struct txp_dma_alloc *dma)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_int32_t idx = TXP_OFFSET2IDX(letoh32(*(r->r_off)));
	u_int32_t cons = r->r_cons, cnt = r->r_cnt;
	struct txp_tx_desc *txd = r->r_desc + cons;
	struct txp_swdesc *sd = sc->sc_txd + cons;
	struct mbuf *m;

	while (cons != idx) {
		if (cnt == 0)
			break;

		bus_dmamap_sync(sc->sc_dmat, dma->dma_map,
		    cons * sizeof(struct txp_tx_desc),
		    sizeof(struct txp_tx_desc),
		    BUS_DMASYNC_POSTWRITE);

		if ((txd->tx_flags & TX_FLAGS_TYPE_M) ==
		    TX_FLAGS_TYPE_DATA) {
			bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
			    sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, sd->sd_map);
			m = sd->sd_mbuf;
			if (m != NULL) {
				m_freem(m);
				txd->tx_addrlo = 0;
				txd->tx_addrhi = 0;
			}
		}
		ifq_clr_oactive(&ifp->if_snd);

		if (++cons == TX_ENTRIES) {
			txd = r->r_desc;
			cons = 0;
			sd = sc->sc_txd;
		} else {
			txd++;
			sd++;
		}

		cnt--;
	}

	r->r_cons = cons;
	r->r_cnt = cnt;
	if (cnt == 0)
		ifp->if_timer = 0;
}

int
txp_alloc_rings(struct txp_softc *sc)
{
	struct txp_boot_record *boot;
	struct txp_swdesc *sd;
	u_int32_t r;
	int i, j;

	/* boot record */
	if (txp_dma_malloc(sc, sizeof(struct txp_boot_record), &sc->sc_boot_dma,
	    BUS_DMA_COHERENT)) {
		printf("can't allocate boot record\n");
		return (-1);
	}
	boot = (struct txp_boot_record *)sc->sc_boot_dma.dma_vaddr;
	bzero(boot, sizeof(*boot));
	sc->sc_boot = boot;

	/* host variables */
	if (txp_dma_malloc(sc, sizeof(struct txp_hostvar), &sc->sc_host_dma,
	    BUS_DMA_COHERENT)) {
		printf("can't allocate host ring\n");
		goto bail_boot;
	}
	bzero(sc->sc_host_dma.dma_vaddr, sizeof(struct txp_hostvar));
	boot->br_hostvar_lo = htole32(sc->sc_host_dma.dma_paddr & 0xffffffff);
	boot->br_hostvar_hi = htole32(sc->sc_host_dma.dma_paddr >> 32);
	sc->sc_hostvar = (struct txp_hostvar *)sc->sc_host_dma.dma_vaddr;

	/* high priority tx ring */
	if (txp_dma_malloc(sc, sizeof(struct txp_tx_desc) * TX_ENTRIES,
	    &sc->sc_txhiring_dma, BUS_DMA_COHERENT)) {
		printf("can't allocate high tx ring\n");
		goto bail_host;
	}
	bzero(sc->sc_txhiring_dma.dma_vaddr, sizeof(struct txp_tx_desc) * TX_ENTRIES);
	boot->br_txhipri_lo = htole32(sc->sc_txhiring_dma.dma_paddr & 0xffffffff);
	boot->br_txhipri_hi = htole32(sc->sc_txhiring_dma.dma_paddr >> 32);
	boot->br_txhipri_siz = htole32(TX_ENTRIES * sizeof(struct txp_tx_desc));
	sc->sc_txhir.r_reg = TXP_H2A_1;
	sc->sc_txhir.r_desc = (struct txp_tx_desc *)sc->sc_txhiring_dma.dma_vaddr;
	sc->sc_txhir.r_cons = sc->sc_txhir.r_prod = sc->sc_txhir.r_cnt = 0;
	sc->sc_txhir.r_off = &sc->sc_hostvar->hv_tx_hi_desc_read_idx;
	for (i = 0; i < TX_ENTRIES; i++) {
		if (bus_dmamap_create(sc->sc_dmat, TXP_MAX_PKTLEN,
		    TX_ENTRIES - 4, TXP_MAX_SEGLEN, 0,
		    BUS_DMA_NOWAIT, &sc->sc_txd[i].sd_map) != 0) {
			for (j = 0; j < i; j++) {
				bus_dmamap_destroy(sc->sc_dmat,
				    sc->sc_txd[j].sd_map);
				sc->sc_txd[j].sd_map = NULL;
			}
			goto bail_txhiring;
		}
	}

	/* low priority tx ring */
	if (txp_dma_malloc(sc, sizeof(struct txp_tx_desc) * TX_ENTRIES,
	    &sc->sc_txloring_dma, BUS_DMA_COHERENT)) {
		printf("can't allocate low tx ring\n");
		goto bail_txhiring;
	}
	bzero(sc->sc_txloring_dma.dma_vaddr, sizeof(struct txp_tx_desc) * TX_ENTRIES);
	boot->br_txlopri_lo = htole32(sc->sc_txloring_dma.dma_paddr & 0xffffffff);
	boot->br_txlopri_hi = htole32(sc->sc_txloring_dma.dma_paddr >> 32);
	boot->br_txlopri_siz = htole32(TX_ENTRIES * sizeof(struct txp_tx_desc));
	sc->sc_txlor.r_reg = TXP_H2A_3;
	sc->sc_txlor.r_desc = (struct txp_tx_desc *)sc->sc_txloring_dma.dma_vaddr;
	sc->sc_txlor.r_cons = sc->sc_txlor.r_prod = sc->sc_txlor.r_cnt = 0;
	sc->sc_txlor.r_off = &sc->sc_hostvar->hv_tx_lo_desc_read_idx;

	/* high priority rx ring */
	if (txp_dma_malloc(sc, sizeof(struct txp_rx_desc) * RX_ENTRIES,
	    &sc->sc_rxhiring_dma, BUS_DMA_COHERENT)) {
		printf("can't allocate high rx ring\n");
		goto bail_txloring;
	}
	bzero(sc->sc_rxhiring_dma.dma_vaddr, sizeof(struct txp_rx_desc) * RX_ENTRIES);
	boot->br_rxhipri_lo = htole32(sc->sc_rxhiring_dma.dma_paddr & 0xffffffff);
	boot->br_rxhipri_hi = htole32(sc->sc_rxhiring_dma.dma_paddr >> 32);
	boot->br_rxhipri_siz = htole32(RX_ENTRIES * sizeof(struct txp_rx_desc));
	sc->sc_rxhir.r_desc =
	    (struct txp_rx_desc *)sc->sc_rxhiring_dma.dma_vaddr;
	sc->sc_rxhir.r_roff = &sc->sc_hostvar->hv_rx_hi_read_idx;
	sc->sc_rxhir.r_woff = &sc->sc_hostvar->hv_rx_hi_write_idx;
	bus_dmamap_sync(sc->sc_dmat, sc->sc_rxhiring_dma.dma_map,
	    0, sc->sc_rxhiring_dma.dma_map->dm_mapsize, BUS_DMASYNC_PREREAD);

	/* low priority ring */
	if (txp_dma_malloc(sc, sizeof(struct txp_rx_desc) * RX_ENTRIES,
	    &sc->sc_rxloring_dma, BUS_DMA_COHERENT)) {
		printf("can't allocate low rx ring\n");
		goto bail_rxhiring;
	}
	bzero(sc->sc_rxloring_dma.dma_vaddr, sizeof(struct txp_rx_desc) * RX_ENTRIES);
	boot->br_rxlopri_lo = htole32(sc->sc_rxloring_dma.dma_paddr & 0xffffffff);
	boot->br_rxlopri_hi = htole32(sc->sc_rxloring_dma.dma_paddr >> 32);
	boot->br_rxlopri_siz = htole32(RX_ENTRIES * sizeof(struct txp_rx_desc));
	sc->sc_rxlor.r_desc =
	    (struct txp_rx_desc *)sc->sc_rxloring_dma.dma_vaddr;
	sc->sc_rxlor.r_roff = &sc->sc_hostvar->hv_rx_lo_read_idx;
	sc->sc_rxlor.r_woff = &sc->sc_hostvar->hv_rx_lo_write_idx;
	bus_dmamap_sync(sc->sc_dmat, sc->sc_rxloring_dma.dma_map,
	    0, sc->sc_rxloring_dma.dma_map->dm_mapsize, BUS_DMASYNC_PREREAD);

	/* command ring */
	if (txp_dma_malloc(sc, sizeof(struct txp_cmd_desc) * CMD_ENTRIES,
	    &sc->sc_cmdring_dma, BUS_DMA_COHERENT)) {
		printf("can't allocate command ring\n");
		goto bail_rxloring;
	}
	bzero(sc->sc_cmdring_dma.dma_vaddr, sizeof(struct txp_cmd_desc) * CMD_ENTRIES);
	boot->br_cmd_lo = htole32(sc->sc_cmdring_dma.dma_paddr & 0xffffffff);
	boot->br_cmd_hi = htole32(sc->sc_cmdring_dma.dma_paddr >> 32);
	boot->br_cmd_siz = htole32(CMD_ENTRIES * sizeof(struct txp_cmd_desc));
	sc->sc_cmdring.base = (struct txp_cmd_desc *)sc->sc_cmdring_dma.dma_vaddr;
	sc->sc_cmdring.size = CMD_ENTRIES * sizeof(struct txp_cmd_desc);
	sc->sc_cmdring.lastwrite = 0;

	/* response ring */
	if (txp_dma_malloc(sc, sizeof(struct txp_rsp_desc) * RSP_ENTRIES,
	    &sc->sc_rspring_dma, BUS_DMA_COHERENT)) {
		printf("can't allocate response ring\n");
		goto bail_cmdring;
	}
	bzero(sc->sc_rspring_dma.dma_vaddr, sizeof(struct txp_rsp_desc) * RSP_ENTRIES);
	boot->br_resp_lo = htole32(sc->sc_rspring_dma.dma_paddr & 0xffffffff);
	boot->br_resp_hi = htole32(sc->sc_rspring_dma.dma_paddr >> 32);
	boot->br_resp_siz = htole32(CMD_ENTRIES * sizeof(struct txp_rsp_desc));
	sc->sc_rspring.base = (struct txp_rsp_desc *)sc->sc_rspring_dma.dma_vaddr;
	sc->sc_rspring.size = RSP_ENTRIES * sizeof(struct txp_rsp_desc);
	sc->sc_rspring.lastwrite = 0;

	/* receive buffer ring */
	if (txp_dma_malloc(sc, sizeof(struct txp_rxbuf_desc) * RXBUF_ENTRIES,
	    &sc->sc_rxbufring_dma, BUS_DMA_COHERENT)) {
		printf("can't allocate rx buffer ring\n");
		goto bail_rspring;
	}
	bzero(sc->sc_rxbufring_dma.dma_vaddr, sizeof(struct txp_rxbuf_desc) * RXBUF_ENTRIES);
	boot->br_rxbuf_lo = htole32(sc->sc_rxbufring_dma.dma_paddr & 0xffffffff);
	boot->br_rxbuf_hi = htole32(sc->sc_rxbufring_dma.dma_paddr >> 32);
	boot->br_rxbuf_siz = htole32(RXBUF_ENTRIES * sizeof(struct txp_rxbuf_desc));
	sc->sc_rxbufs = (struct txp_rxbuf_desc *)sc->sc_rxbufring_dma.dma_vaddr;
	for (i = 0; i < RXBUF_ENTRIES; i++) {
		sd = (struct txp_swdesc *)malloc(sizeof(struct txp_swdesc),
		    M_DEVBUF, M_NOWAIT);

		/* stash away pointer */
		bcopy(&sd, (u_long *)&sc->sc_rxbufs[i].rb_vaddrlo, sizeof(sd));

		if (sd == NULL)
			break;

		MGETHDR(sd->sd_mbuf, M_DONTWAIT, MT_DATA);
		if (sd->sd_mbuf == NULL) {
			goto bail_rxbufring;
		}

		MCLGET(sd->sd_mbuf, M_DONTWAIT);
		if ((sd->sd_mbuf->m_flags & M_EXT) == 0) {
			goto bail_rxbufring;
		}
		sd->sd_mbuf->m_pkthdr.len = sd->sd_mbuf->m_len = MCLBYTES;
		if (bus_dmamap_create(sc->sc_dmat, TXP_MAX_PKTLEN, 1,
		    TXP_MAX_PKTLEN, 0, BUS_DMA_NOWAIT, &sd->sd_map)) {
			goto bail_rxbufring;
		}
		if (bus_dmamap_load_mbuf(sc->sc_dmat, sd->sd_map, sd->sd_mbuf,
		    BUS_DMA_NOWAIT)) {
			bus_dmamap_destroy(sc->sc_dmat, sd->sd_map);
			goto bail_rxbufring;
		}
		bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
		    sd->sd_map->dm_mapsize, BUS_DMASYNC_PREREAD);

		sc->sc_rxbufs[i].rb_paddrlo =
		    ((u_int64_t)sd->sd_map->dm_segs[0].ds_addr) & 0xffffffff;
		sc->sc_rxbufs[i].rb_paddrhi =
		    ((u_int64_t)sd->sd_map->dm_segs[0].ds_addr) >> 32;
	}
	bus_dmamap_sync(sc->sc_dmat, sc->sc_rxbufring_dma.dma_map,
	    0, sc->sc_rxbufring_dma.dma_map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
	sc->sc_hostvar->hv_rx_buf_write_idx = htole32((RXBUF_ENTRIES - 1) *
	    sizeof(struct txp_rxbuf_desc));

	/* zero dma */
	if (txp_dma_malloc(sc, sizeof(u_int32_t), &sc->sc_zero_dma,
	    BUS_DMA_COHERENT)) {
		printf("can't allocate response ring\n");
		goto bail_rxbufring;
	}
	bzero(sc->sc_zero_dma.dma_vaddr, sizeof(u_int32_t));
	boot->br_zero_lo = htole32(sc->sc_zero_dma.dma_paddr & 0xffffffff);
	boot->br_zero_hi = htole32(sc->sc_zero_dma.dma_paddr >> 32);

	/* See if it's waiting for boot, and try to boot it */
	for (i = 0; i < 10000; i++) {
		r = READ_REG(sc, TXP_A2H_0);
		if (r == STAT_WAITING_FOR_BOOT)
			break;
		DELAY(50);
	}
	if (r != STAT_WAITING_FOR_BOOT) {
		printf("not waiting for boot\n");
		goto bail;
	}
	WRITE_REG(sc, TXP_H2A_2, sc->sc_boot_dma.dma_paddr >> 32);
	WRITE_REG(sc, TXP_H2A_1, sc->sc_boot_dma.dma_paddr & 0xffffffff);
	WRITE_REG(sc, TXP_H2A_0, TXP_BOOTCMD_REGISTER_BOOT_RECORD);

	/* See if it booted */
	for (i = 0; i < 10000; i++) {
		r = READ_REG(sc, TXP_A2H_0);
		if (r == STAT_RUNNING)
			break;
		DELAY(50);
	}
	if (r != STAT_RUNNING) {
		printf("fw not running\n");
		goto bail;
	}

	/* Clear TX and CMD ring write registers */
	WRITE_REG(sc, TXP_H2A_1, TXP_BOOTCMD_NULL);
	WRITE_REG(sc, TXP_H2A_2, TXP_BOOTCMD_NULL);
	WRITE_REG(sc, TXP_H2A_3, TXP_BOOTCMD_NULL);
	WRITE_REG(sc, TXP_H2A_0, TXP_BOOTCMD_NULL);

	return (0);

bail:
	txp_dma_free(sc, &sc->sc_zero_dma);
bail_rxbufring:
	for (i = 0; i < RXBUF_ENTRIES; i++) {
		bcopy((u_long *)&sc->sc_rxbufs[i].rb_vaddrlo, &sd, sizeof(sd));
		if (sd)
			free(sd, M_DEVBUF, 0);
	}
	txp_dma_free(sc, &sc->sc_rxbufring_dma);
bail_rspring:
	txp_dma_free(sc, &sc->sc_rspring_dma);
bail_cmdring:
	txp_dma_free(sc, &sc->sc_cmdring_dma);
bail_rxloring:
	txp_dma_free(sc, &sc->sc_rxloring_dma);
bail_rxhiring:
	txp_dma_free(sc, &sc->sc_rxhiring_dma);
bail_txloring:
	txp_dma_free(sc, &sc->sc_txloring_dma);
bail_txhiring:
	txp_dma_free(sc, &sc->sc_txhiring_dma);
bail_host:
	txp_dma_free(sc, &sc->sc_host_dma);
bail_boot:
	txp_dma_free(sc, &sc->sc_boot_dma);
	return (-1);
}

int
txp_dma_malloc(struct txp_softc *sc, bus_size_t size,
    struct txp_dma_alloc *dma, int mapflags)
{
	int r;

	if ((r = bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE, 0,
	    &dma->dma_seg, 1, &dma->dma_nseg, 0)) != 0)
		goto fail_0;

	if ((r = bus_dmamem_map(sc->sc_dmat, &dma->dma_seg, dma->dma_nseg,
	    size, &dma->dma_vaddr, mapflags | BUS_DMA_NOWAIT)) != 0)
		goto fail_1;

	if ((r = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT, &dma->dma_map)) != 0)
		goto fail_2;

	if ((r = bus_dmamap_load(sc->sc_dmat, dma->dma_map, dma->dma_vaddr,
	    size, NULL, BUS_DMA_NOWAIT)) != 0)
		goto fail_3;

	dma->dma_paddr = dma->dma_map->dm_segs[0].ds_addr;
	return (0);

fail_3:
	bus_dmamap_destroy(sc->sc_dmat, dma->dma_map);
fail_2:
	bus_dmamem_unmap(sc->sc_dmat, dma->dma_vaddr, size);
fail_1:
	bus_dmamem_free(sc->sc_dmat, &dma->dma_seg, dma->dma_nseg);
fail_0:
	return (r);
}

void
txp_dma_free(struct txp_softc *sc, struct txp_dma_alloc *dma)
{
	bus_dmamap_unload(sc->sc_dmat, dma->dma_map);
	bus_dmamem_unmap(sc->sc_dmat, dma->dma_vaddr, dma->dma_map->dm_mapsize);
	bus_dmamem_free(sc->sc_dmat, &dma->dma_seg, dma->dma_nseg);
	bus_dmamap_destroy(sc->sc_dmat, dma->dma_map);
}

int
txp_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct txp_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *) data;
	int s, error = 0;

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		txp_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			txp_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				txp_stop(sc);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_ifmedia, command);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			txp_set_filter(sc);
		error = 0;
	}

	splx(s);
	return(error);
}

void
txp_init(struct txp_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int s;

	txp_stop(sc);

	s = splnet();

	txp_set_filter(sc);

	txp_command(sc, TXP_CMD_TX_ENABLE, 0, 0, 0, NULL, NULL, NULL, 1);
	txp_command(sc, TXP_CMD_RX_ENABLE, 0, 0, 0, NULL, NULL, NULL, 1);

	WRITE_REG(sc, TXP_IER, TXP_INT_RESERVED | TXP_INT_SELF |
	    TXP_INT_A2H_7 | TXP_INT_A2H_6 | TXP_INT_A2H_5 | TXP_INT_A2H_4 |
	    TXP_INT_A2H_2 | TXP_INT_A2H_1 | TXP_INT_A2H_0 |
	    TXP_INT_DMA3 | TXP_INT_DMA2 | TXP_INT_DMA1 | TXP_INT_DMA0 |
	    TXP_INT_PCI_TABORT | TXP_INT_PCI_MABORT |  TXP_INT_LATCH);
	WRITE_REG(sc, TXP_IMR, TXP_INT_A2H_3);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (!timeout_pending(&sc->sc_tick))
		timeout_add_sec(&sc->sc_tick, 1);

	splx(s);
}

void
txp_tick(void *vsc)
{
	struct txp_softc *sc = vsc;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct txp_rsp_desc *rsp = NULL;
	struct txp_ext_desc *ext;
	int s;

	s = splnet();
	txp_rxbuf_reclaim(sc);

	if (txp_command2(sc, TXP_CMD_READ_STATISTICS, 0, 0, 0, NULL, 0,
	    &rsp, 1))
		goto out;
	if (rsp->rsp_numdesc != 6)
		goto out;
	if (txp_command(sc, TXP_CMD_CLEAR_STATISTICS, 0, 0, 0,
	    NULL, NULL, NULL, 1))
		goto out;
	ext = (struct txp_ext_desc *)(rsp + 1);

	ifp->if_ierrors += ext[3].ext_2 + ext[3].ext_3 + ext[3].ext_4 +
	    ext[4].ext_1 + ext[4].ext_4;
	ifp->if_oerrors += ext[0].ext_1 + ext[1].ext_1 + ext[1].ext_4 +
	    ext[2].ext_1;
	ifp->if_collisions += ext[0].ext_2 + ext[0].ext_3 + ext[1].ext_2 +
	    ext[1].ext_3;

out:
	if (rsp != NULL)
		free(rsp, M_DEVBUF, 0);

	splx(s);
	timeout_add_sec(&sc->sc_tick, 1);
}

void
txp_start(struct ifnet *ifp)
{
	struct txp_softc *sc = ifp->if_softc;
	struct txp_tx_ring *r = &sc->sc_txhir;
	struct txp_tx_desc *txd;
	int txdidx;
	struct txp_frag_desc *fxd;
	struct mbuf *m, *mnew;
	struct txp_swdesc *sd;
	u_int32_t firstprod, firstcnt, prod, cnt, i;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	prod = r->r_prod;
	cnt = r->r_cnt;

	while (1) {
		m = ifq_deq_begin(&ifp->if_snd);
		if (m == NULL)
			break;
		mnew = NULL;

		firstprod = prod;
		firstcnt = cnt;

		sd = sc->sc_txd + prod;
		sd->sd_mbuf = m;

		if (bus_dmamap_load_mbuf(sc->sc_dmat, sd->sd_map, m,
		    BUS_DMA_NOWAIT)) {
			MGETHDR(mnew, M_DONTWAIT, MT_DATA);
			if (mnew == NULL)
				goto oactive1;
			if (m->m_pkthdr.len > MHLEN) {
				MCLGET(mnew, M_DONTWAIT);
				if ((mnew->m_flags & M_EXT) == 0) {
					m_freem(mnew);
					goto oactive1;
				}
			}
			m_copydata(m, 0, m->m_pkthdr.len, mtod(mnew, caddr_t));
			mnew->m_pkthdr.len = mnew->m_len = m->m_pkthdr.len;
			ifq_deq_commit(&ifp->if_snd, m);
			m_freem(m);
			m = mnew;
			if (bus_dmamap_load_mbuf(sc->sc_dmat, sd->sd_map, m,
			    BUS_DMA_NOWAIT))
				goto oactive1;
		}

		if ((TX_ENTRIES - cnt) < 4)
			goto oactive;

		txd = r->r_desc + prod;
		txdidx = prod;
		txd->tx_flags = TX_FLAGS_TYPE_DATA;
		txd->tx_numdesc = 0;
		txd->tx_addrlo = 0;
		txd->tx_addrhi = 0;
		txd->tx_totlen = m->m_pkthdr.len;
		txd->tx_pflags = 0;
		txd->tx_numdesc = sd->sd_map->dm_nsegs;

		if (++prod == TX_ENTRIES)
			prod = 0;

		if (++cnt >= (TX_ENTRIES - 4))
			goto oactive;

#if NVLAN > 0
		if (m->m_flags & M_VLANTAG) {
			txd->tx_pflags = TX_PFLAGS_VLAN |
			    (htons(m->m_pkthdr.ether_vtag) << TX_PFLAGS_VLANTAG_S);
		}
#endif

		if (m->m_pkthdr.csum_flags & M_IPV4_CSUM_OUT)
			txd->tx_pflags |= TX_PFLAGS_IPCKSUM;
#ifdef TRY_TX_TCP_CSUM
		if (m->m_pkthdr.csum_flags & M_TCP_CSUM_OUT)
			txd->tx_pflags |= TX_PFLAGS_TCPCKSUM;
#endif
#ifdef TRY_TX_UDP_CSUM
		if (m->m_pkthdr.csum_flags & M_UDP_CSUM_OUT)
			txd->tx_pflags |= TX_PFLAGS_UDPCKSUM;
#endif

		bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
		    sd->sd_map->dm_mapsize, BUS_DMASYNC_PREWRITE);

		fxd = (struct txp_frag_desc *)(r->r_desc + prod);
		for (i = 0; i < sd->sd_map->dm_nsegs; i++) {
			if (++cnt >= (TX_ENTRIES - 4)) {
				bus_dmamap_sync(sc->sc_dmat, sd->sd_map,
				    0, sd->sd_map->dm_mapsize,
				    BUS_DMASYNC_POSTWRITE);
				goto oactive;
			}

			fxd->frag_flags = FRAG_FLAGS_TYPE_FRAG |
			    FRAG_FLAGS_VALID;
			fxd->frag_rsvd1 = 0;
			fxd->frag_len = sd->sd_map->dm_segs[i].ds_len;
			fxd->frag_addrlo =
			    ((u_int64_t)sd->sd_map->dm_segs[i].ds_addr) &
			    0xffffffff;
			fxd->frag_addrhi =
			    ((u_int64_t)sd->sd_map->dm_segs[i].ds_addr) >>
			    32;
			fxd->frag_rsvd2 = 0;

			bus_dmamap_sync(sc->sc_dmat,
			    sc->sc_txhiring_dma.dma_map,
			    prod * sizeof(struct txp_frag_desc),
			    sizeof(struct txp_frag_desc), BUS_DMASYNC_PREWRITE);

			if (++prod == TX_ENTRIES) {
				fxd = (struct txp_frag_desc *)r->r_desc;
				prod = 0;
			} else
				fxd++;

		}

		/*
		 * if mnew isn't NULL, we already dequeued and copied
		 * the packet.
		 */
		if (mnew == NULL)
			ifq_deq_commit(&ifp->if_snd, m);

		ifp->if_timer = 5;

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		txd->tx_flags |= TX_FLAGS_VALID;
		bus_dmamap_sync(sc->sc_dmat, sc->sc_txhiring_dma.dma_map,
		    txdidx * sizeof(struct txp_tx_desc),
		    sizeof(struct txp_tx_desc), BUS_DMASYNC_PREWRITE);

#if 0
		{
			struct mbuf *mx;
			int i;

			printf("txd: flags 0x%x ndesc %d totlen %d pflags 0x%x\n",
			    txd->tx_flags, txd->tx_numdesc, txd->tx_totlen,
			    txd->tx_pflags);
			for (mx = m; mx != NULL; mx = mx->m_next) {
				for (i = 0; i < mx->m_len; i++) {
					printf(":%02x",
					    (u_int8_t)m->m_data[i]);
				}
			}
			printf("\n");
		}
#endif

		WRITE_REG(sc, r->r_reg, TXP_IDX2OFFSET(prod));
	}

	r->r_prod = prod;
	r->r_cnt = cnt;
	return;

oactive:
	bus_dmamap_unload(sc->sc_dmat, sd->sd_map);
oactive1:
	ifq_deq_rollback(&ifp->if_snd, m);
	ifq_set_oactive(&ifp->if_snd);
	r->r_prod = firstprod;
	r->r_cnt = firstcnt;
}

/*
 * Handle simple commands sent to the typhoon
 */
int
txp_command(struct txp_softc *sc, u_int16_t id, u_int16_t in1,
    u_int32_t in2, u_int32_t in3, u_int16_t *out1, u_int32_t *out2,
    u_int32_t *out3, int wait)
{
	struct txp_rsp_desc *rsp = NULL;

	if (txp_command2(sc, id, in1, in2, in3, NULL, 0, &rsp, wait))
		return (-1);

	if (!wait)
		return (0);

	if (out1 != NULL)
		*out1 = letoh16(rsp->rsp_par1);
	if (out2 != NULL)
		*out2 = letoh32(rsp->rsp_par2);
	if (out3 != NULL)
		*out3 = letoh32(rsp->rsp_par3);
	free(rsp, M_DEVBUF, 0);
	return (0);
}

int
txp_command2(struct txp_softc *sc, u_int16_t id, u_int16_t in1,
    u_int32_t in2, u_int32_t in3, struct txp_ext_desc *in_extp,
    u_int8_t in_extn,struct txp_rsp_desc **rspp, int wait)
{
	struct txp_hostvar *hv = sc->sc_hostvar;
	struct txp_cmd_desc *cmd;
	struct txp_ext_desc *ext;
	u_int32_t idx, i;
	u_int16_t seq;

	if (txp_cmd_desc_numfree(sc) < (in_extn + 1)) {
		printf("%s: no free cmd descriptors\n", TXP_DEVNAME(sc));
		return (-1);
	}

	idx = sc->sc_cmdring.lastwrite;
	cmd = (struct txp_cmd_desc *)(((u_int8_t *)sc->sc_cmdring.base) + idx);
	bzero(cmd, sizeof(*cmd));

	cmd->cmd_numdesc = in_extn;
	seq = sc->sc_seq++;
	cmd->cmd_seq = htole16(seq);
	cmd->cmd_id = htole16(id);
	cmd->cmd_par1 = htole16(in1);
	cmd->cmd_par2 = htole32(in2);
	cmd->cmd_par3 = htole32(in3);
	cmd->cmd_flags = CMD_FLAGS_TYPE_CMD |
	    (wait ? CMD_FLAGS_RESP : 0) | CMD_FLAGS_VALID;

	idx += sizeof(struct txp_cmd_desc);
	if (idx == sc->sc_cmdring.size)
		idx = 0;

	for (i = 0; i < in_extn; i++) {
		ext = (struct txp_ext_desc *)(((u_int8_t *)sc->sc_cmdring.base) + idx);
		bcopy(in_extp, ext, sizeof(struct txp_ext_desc));
		in_extp++;
		idx += sizeof(struct txp_cmd_desc);
		if (idx == sc->sc_cmdring.size)
			idx = 0;
	}

	sc->sc_cmdring.lastwrite = idx;

	WRITE_REG(sc, TXP_H2A_2, sc->sc_cmdring.lastwrite);
	bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
	    sizeof(struct txp_hostvar), BUS_DMASYNC_PREREAD);

	if (!wait)
		return (0);

	for (i = 0; i < 10000; i++) {
		bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
		    sizeof(struct txp_hostvar), BUS_DMASYNC_POSTREAD);
		idx = letoh32(hv->hv_resp_read_idx);
		if (idx != letoh32(hv->hv_resp_write_idx)) {
			*rspp = NULL;
			if (txp_response(sc, idx, id, seq, rspp))
				return (-1);
			if (*rspp != NULL)
				break;
		}
		bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
		    sizeof(struct txp_hostvar), BUS_DMASYNC_PREREAD);
		DELAY(50);
	}
	if (i == 1000 || (*rspp) == NULL) {
		printf("%s: 0x%x command failed\n", TXP_DEVNAME(sc), id);
		return (-1);
	}

	return (0);
}

int
txp_response(struct txp_softc *sc, u_int32_t ridx, u_int16_t id,
    u_int16_t seq, struct txp_rsp_desc **rspp)
{
	struct txp_hostvar *hv = sc->sc_hostvar;
	struct txp_rsp_desc *rsp;

	while (ridx != letoh32(hv->hv_resp_write_idx)) {
		rsp = (struct txp_rsp_desc *)(((u_int8_t *)sc->sc_rspring.base) + ridx);

		if (id == letoh16(rsp->rsp_id) && letoh16(rsp->rsp_seq) == seq) {
			*rspp = mallocarray(rsp->rsp_numdesc + 1,
			    sizeof(struct txp_rsp_desc), M_DEVBUF, M_NOWAIT);
			if ((*rspp) == NULL)
				return (-1);
			txp_rsp_fixup(sc, rsp, *rspp);
			return (0);
		}

		if (rsp->rsp_flags & RSP_FLAGS_ERROR) {
			printf("%s: response error: id 0x%x\n",
			    TXP_DEVNAME(sc), letoh16(rsp->rsp_id));
			txp_rsp_fixup(sc, rsp, NULL);
			ridx = letoh32(hv->hv_resp_read_idx);
			continue;
		}

		switch (letoh16(rsp->rsp_id)) {
		case TXP_CMD_CYCLE_STATISTICS:
		case TXP_CMD_MEDIA_STATUS_READ:
			break;
		case TXP_CMD_HELLO_RESPONSE:
			printf("%s: hello\n", TXP_DEVNAME(sc));
			break;
		default:
			printf("%s: unknown id(0x%x)\n", TXP_DEVNAME(sc),
			    letoh16(rsp->rsp_id));
		}

		txp_rsp_fixup(sc, rsp, NULL);
		ridx = letoh32(hv->hv_resp_read_idx);
		hv->hv_resp_read_idx = letoh32(ridx);
	}

	return (0);
}

void
txp_rsp_fixup(struct txp_softc *sc, struct txp_rsp_desc *rsp,
    struct txp_rsp_desc *dst)
{
	struct txp_rsp_desc *src = rsp;
	struct txp_hostvar *hv = sc->sc_hostvar;
	u_int32_t i, ridx;

	ridx = letoh32(hv->hv_resp_read_idx);

	for (i = 0; i < rsp->rsp_numdesc + 1; i++) {
		if (dst != NULL)
			bcopy(src, dst++, sizeof(struct txp_rsp_desc));
		ridx += sizeof(struct txp_rsp_desc);
		if (ridx == sc->sc_rspring.size) {
			src = sc->sc_rspring.base;
			ridx = 0;
		} else
			src++;
		sc->sc_rspring.lastwrite = ridx;
		hv->hv_resp_read_idx = htole32(ridx);
	}
	
	hv->hv_resp_read_idx = htole32(ridx);
}

int
txp_cmd_desc_numfree(struct txp_softc *sc)
{
	struct txp_hostvar *hv = sc->sc_hostvar;
	struct txp_boot_record *br = sc->sc_boot;
	u_int32_t widx, ridx, nfree;

	widx = sc->sc_cmdring.lastwrite;
	ridx = letoh32(hv->hv_cmd_read_idx);

	if (widx == ridx) {
		/* Ring is completely free */
		nfree = letoh32(br->br_cmd_siz) - sizeof(struct txp_cmd_desc);
	} else {
		if (widx > ridx)
			nfree = letoh32(br->br_cmd_siz) -
			    (widx - ridx + sizeof(struct txp_cmd_desc));
		else
			nfree = ridx - widx - sizeof(struct txp_cmd_desc);
	}

	return (nfree / sizeof(struct txp_cmd_desc));
}

void
txp_stop(struct txp_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	timeout_del(&sc->sc_tick);

	/* Mark the interface as down and cancel the watchdog timer. */
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_timer = 0;

	txp_command(sc, TXP_CMD_TX_DISABLE, 0, 0, 0, NULL, NULL, NULL, 1);
	txp_command(sc, TXP_CMD_RX_DISABLE, 0, 0, 0, NULL, NULL, NULL, 1);
}

void
txp_watchdog(struct ifnet *ifp)
{
}

int
txp_ifmedia_upd(struct ifnet *ifp)
{
	struct txp_softc *sc = ifp->if_softc;
	struct ifmedia *ifm = &sc->sc_ifmedia;
	u_int16_t new_xcvr;

	if (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)
		return (EINVAL);

	if (IFM_SUBTYPE(ifm->ifm_media) == IFM_10_T) {
		if ((ifm->ifm_media & IFM_GMASK) == IFM_FDX)
			new_xcvr = TXP_XCVR_10_FDX;
		else
			new_xcvr = TXP_XCVR_10_HDX;
	} else if (IFM_SUBTYPE(ifm->ifm_media) == IFM_100_TX) {
		if ((ifm->ifm_media & IFM_GMASK) == IFM_FDX)
			new_xcvr = TXP_XCVR_100_FDX;
		else
			new_xcvr = TXP_XCVR_100_HDX;
	} else if (IFM_SUBTYPE(ifm->ifm_media) == IFM_AUTO) {
		new_xcvr = TXP_XCVR_AUTO;
	} else
		return (EINVAL);

	/* nothing to do */
	if (sc->sc_xcvr == new_xcvr)
		return (0);

	txp_command(sc, TXP_CMD_XCVR_SELECT, new_xcvr, 0, 0,
	    NULL, NULL, NULL, 0);
	sc->sc_xcvr = new_xcvr;

	return (0);
}

void
txp_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct txp_softc *sc = ifp->if_softc;
	struct ifmedia *ifm = &sc->sc_ifmedia;
	u_int16_t bmsr, bmcr, anar, anlpar;

	ifmr->ifm_status = IFM_AVALID;
	ifmr->ifm_active = IFM_ETHER;

	if (txp_command(sc, TXP_CMD_PHY_MGMT_READ, 0, MII_BMSR, 0,
	    &bmsr, NULL, NULL, 1))
		goto bail;
	if (txp_command(sc, TXP_CMD_PHY_MGMT_READ, 0, MII_BMSR, 0,
	    &bmsr, NULL, NULL, 1))
		goto bail;

	if (txp_command(sc, TXP_CMD_PHY_MGMT_READ, 0, MII_BMCR, 0,
	    &bmcr, NULL, NULL, 1))
		goto bail;

	if (txp_command(sc, TXP_CMD_PHY_MGMT_READ, 0, MII_ANAR, 0,
	    &anar, NULL, NULL, 1))
		goto bail;

	if (txp_command(sc, TXP_CMD_PHY_MGMT_READ, 0, MII_ANLPAR, 0,
	    &anlpar, NULL, NULL, 1))
		goto bail;

	if (bmsr & BMSR_LINK)
		ifmr->ifm_status |= IFM_ACTIVE;

	if (bmcr & BMCR_ISO) {
		ifmr->ifm_active |= IFM_NONE;
		ifmr->ifm_status = 0;
		return;
	}

	if (bmcr & BMCR_LOOP)
		ifmr->ifm_active |= IFM_LOOP;

	if (bmcr & BMCR_AUTOEN) {
		if ((bmsr & BMSR_ACOMP) == 0) {
			ifmr->ifm_active |= IFM_NONE;
			return;
		}

		anlpar &= anar;
		if (anlpar & ANLPAR_TX_FD)
			ifmr->ifm_active |= IFM_100_TX|IFM_FDX;
		else if (anlpar & ANLPAR_T4)
			ifmr->ifm_active |= IFM_100_T4|IFM_HDX;
		else if (anlpar & ANLPAR_TX)
			ifmr->ifm_active |= IFM_100_TX|IFM_HDX;
		else if (anlpar & ANLPAR_10_FD)
			ifmr->ifm_active |= IFM_10_T|IFM_FDX;
		else if (anlpar & ANLPAR_10)
			ifmr->ifm_active |= IFM_10_T|IFM_HDX;
		else
			ifmr->ifm_active |= IFM_NONE;
	} else
		ifmr->ifm_active = ifm->ifm_cur->ifm_media;
	return;

bail:
	ifmr->ifm_active |= IFM_NONE;
	ifmr->ifm_status &= ~IFM_AVALID;
}

void
txp_show_descriptor(void *d)
{
	struct txp_cmd_desc *cmd = d;
	struct txp_rsp_desc *rsp = d;
	struct txp_tx_desc *txd = d;
	struct txp_frag_desc *frgd = d;

	switch (cmd->cmd_flags & CMD_FLAGS_TYPE_M) {
	case CMD_FLAGS_TYPE_CMD:
		/* command descriptor */
		printf("[cmd flags 0x%x num %d id %d seq %d par1 0x%x par2 0x%x par3 0x%x]\n",
		    cmd->cmd_flags, cmd->cmd_numdesc, letoh16(cmd->cmd_id),
		    letoh16(cmd->cmd_seq), letoh16(cmd->cmd_par1),
		    letoh32(cmd->cmd_par2), letoh32(cmd->cmd_par3));
		break;
	case CMD_FLAGS_TYPE_RESP:
		/* response descriptor */
		printf("[rsp flags 0x%x num %d id %d seq %d par1 0x%x par2 0x%x par3 0x%x]\n",
		    rsp->rsp_flags, rsp->rsp_numdesc, letoh16(rsp->rsp_id),
		    letoh16(rsp->rsp_seq), letoh16(rsp->rsp_par1),
		    letoh32(rsp->rsp_par2), letoh32(rsp->rsp_par3));
		break;
	case CMD_FLAGS_TYPE_DATA:
		/* data header (assuming tx for now) */
		printf("[data flags 0x%x num %d totlen %d addr 0x%x/0x%x pflags 0x%x]",
		    txd->tx_flags, txd->tx_numdesc, txd->tx_totlen,
		    txd->tx_addrlo, txd->tx_addrhi, txd->tx_pflags);
		break;
	case CMD_FLAGS_TYPE_FRAG:
		/* fragment descriptor */
		printf("[frag flags 0x%x rsvd1 0x%x len %d addr 0x%x/0x%x rsvd2 0x%x]",
		    frgd->frag_flags, frgd->frag_rsvd1, frgd->frag_len,
		    frgd->frag_addrlo, frgd->frag_addrhi, frgd->frag_rsvd2);
		break;
	default:
		printf("[unknown(%x) flags 0x%x num %d id %d seq %d par1 0x%x par2 0x%x par3 0x%x]\n",
		    cmd->cmd_flags & CMD_FLAGS_TYPE_M,
		    cmd->cmd_flags, cmd->cmd_numdesc, letoh16(cmd->cmd_id),
		    letoh16(cmd->cmd_seq), letoh16(cmd->cmd_par1),
		    letoh32(cmd->cmd_par2), letoh32(cmd->cmd_par3));
		break;
	}
}

void
txp_set_filter(struct txp_softc *sc)
{
	struct arpcom *ac = &sc->sc_arpcom;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_int32_t hashbit, hash[2];
	u_int16_t filter;
	int mcnt = 0;
	struct ether_multi *enm;
	struct ether_multistep step;

	if (ifp->if_flags & IFF_PROMISC) {
		filter = TXP_RXFILT_PROMISC;
		goto setit;
	}

	if (ac->ac_multirangecnt > 0)
		ifp->if_flags |= IFF_ALLMULTI;

	filter = TXP_RXFILT_DIRECT;

	if (ifp->if_flags & IFF_BROADCAST)
		filter |= TXP_RXFILT_BROADCAST;

	if (ifp->if_flags & IFF_ALLMULTI)
		filter |= TXP_RXFILT_ALLMULTI;
	else {
		hash[0] = hash[1] = 0;

		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			mcnt++;
			hashbit = (u_int16_t)(ether_crc32_be(enm->enm_addrlo,
			    ETHER_ADDR_LEN) & (64 - 1));
			hash[hashbit / 32] |= (1 << hashbit % 32);
			ETHER_NEXT_MULTI(step, enm);
		}

		if (mcnt > 0) {
			filter |= TXP_RXFILT_HASHMULTI;
			txp_command(sc, TXP_CMD_MCAST_HASH_MASK_WRITE,
			    2, hash[0], hash[1], NULL, NULL, NULL, 0);
		}
	}

setit:
	txp_command(sc, TXP_CMD_RX_FILTER_WRITE, filter, 0, 0,
	    NULL, NULL, NULL, 1);
}

void
txp_capabilities(struct txp_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct txp_rsp_desc *rsp = NULL;
	struct txp_ext_desc *ext;

	if (txp_command2(sc, TXP_CMD_OFFLOAD_READ, 0, 0, 0, NULL, 0, &rsp, 1))
		goto out;

	if (rsp->rsp_numdesc != 1)
		goto out;
	ext = (struct txp_ext_desc *)(rsp + 1);

	sc->sc_tx_capability = ext->ext_1 & OFFLOAD_MASK;
	sc->sc_rx_capability = ext->ext_2 & OFFLOAD_MASK;

	ifp->if_capabilities = IFCAP_VLAN_MTU;

#if NVLAN > 0
	if (rsp->rsp_par2 & rsp->rsp_par3 & OFFLOAD_VLAN) {
		sc->sc_tx_capability |= OFFLOAD_VLAN;
		sc->sc_rx_capability |= OFFLOAD_VLAN;
		ifp->if_capabilities |= IFCAP_VLAN_HWTAGGING;
	}
#endif

#if 0
	/* not ready yet */
	if (rsp->rsp_par2 & rsp->rsp_par3 & OFFLOAD_IPSEC) {
		sc->sc_tx_capability |= OFFLOAD_IPSEC;
		sc->sc_rx_capability |= OFFLOAD_IPSEC;
		ifp->if_capabilities |= IFCAP_IPSEC;
	}
#endif

	if (rsp->rsp_par2 & rsp->rsp_par3 & OFFLOAD_IPCKSUM) {
		sc->sc_tx_capability |= OFFLOAD_IPCKSUM;
		sc->sc_rx_capability |= OFFLOAD_IPCKSUM;
		ifp->if_capabilities |= IFCAP_CSUM_IPv4;
	}

	if (rsp->rsp_par2 & rsp->rsp_par3 & OFFLOAD_TCPCKSUM) {
		sc->sc_rx_capability |= OFFLOAD_TCPCKSUM;
#ifdef TRY_TX_TCP_CSUM
		sc->sc_tx_capability |= OFFLOAD_TCPCKSUM;
		ifp->if_capabilities |= IFCAP_CSUM_TCPv4;
#endif
	}

	if (rsp->rsp_par2 & rsp->rsp_par3 & OFFLOAD_UDPCKSUM) {
		sc->sc_rx_capability |= OFFLOAD_UDPCKSUM;
#ifdef TRY_TX_UDP_CSUM
		sc->sc_tx_capability |= OFFLOAD_UDPCKSUM;
		ifp->if_capabilities |= IFCAP_CSUM_UDPv4;
#endif
	}

	if (txp_command(sc, TXP_CMD_OFFLOAD_WRITE, 0,
	    sc->sc_tx_capability, sc->sc_rx_capability, NULL, NULL, NULL, 1))
		goto out;

out:
	if (rsp != NULL)
		free(rsp, M_DEVBUF, 0);
}
@


1.124
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.123 2015/12/11 16:07:02 mpi Exp $	*/
a820 1
				ifp->if_opackets++;
a1248 1
	ifp->if_opackets += rsp->rsp_par2;
@


1.123
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.122 2015/11/25 03:09:59 dlg Exp $	*/
a216 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.122
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.121 2015/11/24 17:11:39 mpi Exp $	*/
d76 1
a76 1
void txp_attachhook(void *vsc);
d145 1
a145 1
txp_attachhook(void *vsc)
d147 1
a147 1
	struct txp_softc *sc = vsc;
d273 1
a273 4
	if (rootvp == NULL)
		mountroothook_establish(txp_attachhook, sc);
	else
		txp_attachhook(sc);
@


1.121
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.120 2015/11/24 13:33:17 mpi Exp $	*/
d828 1
a828 1
		ifp->if_flags &= ~IFF_OACTIVE;
d1218 1
a1218 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1276 1
a1276 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d1438 1
a1438 1
	ifp->if_flags |= IFF_OACTIVE;
d1649 2
a1650 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.120
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.119 2015/11/20 03:35:23 dlg Exp $	*/
a47 1
#include <net/if_dl.h>
@


1.119
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.118 2015/11/14 17:54:57 mpi Exp $	*/
a48 1
#include <net/if_types.h>
@


1.118
log
@Do not include <net/if_vlan_var.h> when it's not necessary.

Because of the VLAN hacks in mpw(4) this file still contains the definition
of "struct ifvlan" which depends on <sys/refcnt.h> which in turns pull
<sys/atomic.h>...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.117 2015/10/25 13:04:28 mpi Exp $	*/
d1285 1
a1285 1
		IFQ_POLL(&ifp->if_snd, m);
d1310 1
a1310 1
			IFQ_DEQUEUE(&ifp->if_snd, m);
d1397 1
a1397 1
			IFQ_DEQUEUE(&ifp->if_snd, m);
d1439 1
@


1.117
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.116 2015/06/24 09:40:54 mpi Exp $	*/
a57 4
#endif

#if NVLAN > 0
#include <net/if_vlan_var.h>
@


1.116
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.115 2015/04/30 07:51:07 mpi Exp $	*/
a1161 1
	struct ifaddr *ifa = (struct ifaddr *) data;
d1170 1
a1170 9
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			txp_init(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
		default:
			txp_init(sc);
			break;
		}
@


1.115
log
@Convert moar drivers to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.114 2015/03/14 03:38:48 jsg Exp $	*/
a1269 1
	ifp->if_ipackets += ext[2].ext_3;
@


1.114
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.113 2014/12/22 02:28:52 tedu Exp $	*/
d605 1
a662 1
			mnew->m_pkthdr.rcvif = ifp;
a682 8
#if NBPFILTER > 0
		/*
		 * Handle BPF listeners. Let the BPF user see the packet.
		 */
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

d700 1
a700 1
		ether_input_mbuf(ifp, m);
d719 2
a726 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a752 1
		sd->sd_mbuf->m_pkthdr.rcvif = ifp;
a856 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a1017 1
		sd->sd_mbuf->m_pkthdr.rcvif = ifp;
@


1.113
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.112 2014/12/06 23:20:17 krw Exp $	*/
a66 1
#include <dev/mii/miivar.h>
@


1.112
log
@A few last 'easy' #include dedups.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.111 2014/07/22 13:12:11 mpi Exp $	*/
a50 1
#ifdef INET
a52 1
#endif
a1182 1
#ifdef INET
a1186 1
#endif /* INET */
@


1.111
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.110 2014/07/13 23:10:23 deraadt Exp $	*/
a62 1
#include <net/if_types.h>
@


1.110
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.109 2014/07/12 18:48:52 tedu Exp $	*/
a52 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.109
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.108 2013/11/26 09:50:33 mpi Exp $	*/
d1588 2
a1589 3
			*rspp = (struct txp_rsp_desc *)malloc(
			    sizeof(struct txp_rsp_desc) * (rsp->rsp_numdesc + 1),
			    M_DEVBUF, M_NOWAIT);
@


1.108
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.107 2013/08/07 01:06:38 bluhm Exp $	*/
d439 1
a439 1
	free(buf, M_DEVBUF);
d442 1
a442 1
	free(buf, M_DEVBUF);
d642 1
a642 1
		free(sd, M_DEVBUF);
d809 1
a809 1
	free(sd, M_DEVBUF);
d1108 1
a1108 1
			free(sd, M_DEVBUF);
d1292 1
a1292 1
		free(rsp, M_DEVBUF);
d1498 1
a1498 1
	free(rsp, M_DEVBUF);
d1959 1
a1959 1
		free(rsp, M_DEVBUF);
@


1.107
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.106 2012/12/01 09:55:03 brad Exp $	*/
d1861 3
a1863 1
again:
a1875 15
			if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
				/*
				 * We must listen to a range of multicast
				 * addresses.  For now, just accept all
				 * multicasts, rather than trying to set only
				 * those filter bits needed to match the range.
				 * (At this time, the only use of address
				 * ranges is for IP multicast routing, for
				 * which the range is big enough to require
				 * all bits set.)
				 */
				ifp->if_flags |= IFF_ALLMULTI;
				goto again;
			}

@


1.106
log
@Don't bother to zero initialize the if_capabilities field first and
then set the flags. Just set the flags as is done everywhere else.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.105 2012/11/23 18:40:30 gsoares Exp $	*/
a53 1
#include <netinet/in_var.h>
@


1.105
log
@set ifp->if_baudrate with IF_Gbps() / IF_Mbps().

OK reyk@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.104 2011/04/05 18:01:21 henning Exp $	*/
a230 1
	ifp->if_capabilities = 0;
d1926 1
a1926 1
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
@


1.104
log
@mechanic rename M_{TCP|UDP}V4_CSUM_OUT -> M_{TCP|UDP}_CSUM_OUT
ok claudio krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.103 2011/04/03 15:36:03 jasper Exp $	*/
d228 1
a228 1
	ifp->if_baudrate = 10000000;
@


1.103
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.102 2010/09/20 07:40:38 deraadt Exp $	*/
d1381 1
a1381 1
		if (m->m_pkthdr.csum_flags & M_TCPV4_CSUM_OUT)
d1385 1
a1385 1
		if (m->m_pkthdr.csum_flags & M_UDPV4_CSUM_OUT)
@


1.102
log
@Stop doing shutdown hooks in network drivers where possible.  We already
take all interfaces down, via their xxstop routines.  Claudio and I have
verified that none of the shutdown hooks do much extra beyond what xxstop
was already doing; it is largely a pile of junk.
ok claudio, some early comments by sthen; also read by matthew, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.101 2009/08/13 14:24:47 jasper Exp $	*/
d154 1
a154 1
	    sizeof(txp_devices)/sizeof(txp_devices[0])));
@


1.101
log
@- consistify cfdriver for the ethernet drivers (0 -> NULL)

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.100 2009/03/24 11:12:10 kettenis Exp $	*/
a91 1
void txp_shutdown(void *);
a243 1
	shutdownhook_establish(txp_shutdown, sc);
a867 16
}

void
txp_shutdown(void *vsc)
{
	struct txp_softc *sc = (struct txp_softc *)vsc;

	/* mask all interrupts */
	WRITE_REG(sc, TXP_IMR,
	    TXP_INT_SELF | TXP_INT_PCI_TABORT | TXP_INT_PCI_MABORT |
	    TXP_INT_DMA3 | TXP_INT_DMA2 | TXP_INT_DMA1 | TXP_INT_DMA0 |
	    TXP_INT_LATCH);

	txp_command(sc, TXP_CMD_TX_DISABLE, 0, 0, 0, NULL, NULL, NULL, 0);
	txp_command(sc, TXP_CMD_RX_DISABLE, 0, 0, 0, NULL, NULL, NULL, 0);
	txp_command(sc, TXP_CMD_HALT, 0, 0, 0, NULL, NULL, NULL, 0);
@


1.100
log
@Upgrade to newer firmware needed by some txp(4) variants.  Fixes PR 6085.
From FreeBSD.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.99 2008/11/28 02:44:18 brad Exp $	*/
d136 1
a136 1
	0, "txp", DV_IFNET
@


1.99
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.98 2008/11/09 15:08:26 naddy Exp $	*/
d404 5
@


1.98
log
@Introduce bpf_mtap_ether(), which for the benefit of bpf listeners
creates the VLAN encapsulation from the tag stored in the mbuf
header.  Idea from FreeBSD, input from claudio@@ and canacar@@.

Switch all hardware VLAN enabled drivers to the new function.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.97 2008/10/16 19:18:03 naddy Exp $	*/
d1193 2
a1194 2
	struct ifreq *ifr = (struct ifreq *)data;
	struct ifaddr *ifa = (struct ifaddr *)data;
d1214 1
a1222 5
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);
a1223 10
		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				txp_set_filter(sc);
			error = 0;
		}
		break;
d1228 1
d1231 6
@


1.97
log
@Switch the existing TX VLAN hardware support over to having the
tag in the header.  Convert TX tagging in the drivers.

Help and ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.96 2008/10/16 19:16:21 naddy Exp $	*/
d693 1
a693 1
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
d1457 1
a1457 1
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
@


1.96
log
@Convert RX tag stripping to storing the tag in the mbuf header and
enable RX tag stripping for re(4).

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.95 2008/10/02 20:21:14 brad Exp $	*/
a1330 3
#if NVLAN > 0
	struct ifvlan		*ifv;
#endif
d1392 1
a1392 3
		if ((m->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&
		    m->m_pkthdr.rcvif != NULL) {
			ifv = m->m_pkthdr.rcvif->if_softc;
d1394 1
a1394 1
			    (htons(ifv->ifv_tag) << TX_PFLAGS_VLANTAG_S);
@


1.95
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.94 2008/09/18 15:16:30 naddy Exp $	*/
a643 25
#if NVLAN > 0
		/*
		 * XXX Another firmware bug: the vlan encapsulation
		 * is always removed, even when we tell the card not
		 * to do that.  Restore the vlan encapsulation below.
		 */
		if (rxd->rx_stat & htole32(RX_STAT_VLAN)) {
			struct ether_vlan_header vh;

			if (m->m_pkthdr.len < ETHER_HDR_LEN) {
				m_freem(m);
				goto next;
			}
			m_copydata(m, 0, ETHER_HDR_LEN, (caddr_t)&vh);
			vh.evl_proto = vh.evl_encap_proto;
			vh.evl_tag = rxd->rx_vlan >> 16;
			vh.evl_encap_proto = htons(ETHERTYPE_VLAN);
			m_adj(m, ETHER_HDR_LEN);
			M_PREPEND(m, sizeof(vh), M_DONTWAIT);
			if (m == NULL)
				goto next;
			m_copyback(m, 0, sizeof(vh), &vh);
		}
#endif

d676 12
a764 3
		/* reserve some space for a possible VLAN header */
		sd->sd_mbuf->m_data += 8;
		sd->sd_mbuf->m_pkthdr.len = sd->sd_mbuf->m_len = MCLBYTES - 8;
d766 1
d1047 1
a1047 3
		/* reserve some space for a possible VLAN header */
		sd->sd_mbuf->m_data += 8;
		sd->sd_mbuf->m_pkthdr.len = sd->sd_mbuf->m_len = MCLBYTES - 8;
d1957 1
@


1.94
log
@Introduce the infrastructure required to support hardware VLAN tag
stripping:  Add a field to the mbuf pkthdr to hold the tag and an
mbuf flag that tells if the tag is valid.  Inspired by FreeBSD.

Struct packing suggested by kettenis@@.   csum_flags is now 16 bits.
Adapt to this in the drivers.

ok reyk@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.93 2008/09/10 14:01:23 blambert Exp $	*/
a1215 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {
		splx(s);
		return error;
	}

d1260 1
a1260 2
		error = ENOTTY;
		break;
a1263 1

@


1.93
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.92 2008/09/08 07:38:33 brad Exp $	*/
d612 2
a613 1
	int sumflags = 0, idx;
@


1.92
log
@IEEE 802.3 Annex 28B.3 explicitly specifies the following relative
priorities of the technologies supported by 802.3 Selector Field
value.

1000BASE-T full duplex
1000BASE-T
100BASE-T2 full duplex
100BASE-TX full duplex
100BASE-T2
100BASE-T4
100BASE-TX
10BASE-T full duplex
10BAST-T

However PHY drivers did not honor the order such that 100BASE-T4 had
higher priority than 100BASE-TX full duplex. Fix a long standing bug
such that PHY drivers choose the highest common denominator ability.

This bug is exposed by a Cisco 3550 switch which inadvertently
announces 100BASE-T4 capability even though it is not capable of
100BASE-T4 operation, it is a 100BASE-TX switch.

From FreeBSD

Tested with dc(4), fxp(4), rl(4), sis(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.91 2008/05/31 02:08:14 brad Exp $	*/
d1299 1
a1299 1
		timeout_add(&sc->sc_tick, hz);
d1340 1
a1340 1
	timeout_add(&sc->sc_tick, hz);
@


1.91
log
@Clear the IFF_RUNNING/IFF_OACTIVE flags and the watchdog timer in
txp_stop().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.90 2008/05/22 21:03:41 brad Exp $	*/
d1829 3
a1831 1
		if (anlpar & ANLPAR_T4)
a1832 2
		else if (anlpar & ANLPAR_TX_FD)
			ifmr->ifm_active |= IFM_100_TX|IFM_FDX;
@


1.90
log
@ANSI function definitions.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.89 2008/05/22 19:23:04 mk Exp $	*/
a1296 1
	ifp->if_timer = 0;
d1728 8
a1737 2

	timeout_del(&sc->sc_tick);
@


1.89
log
@More timeout(9) usage cleaned up.

ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.88 2008/05/22 06:48:56 brad Exp $	*/
d152 1
a152 3
txp_probe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d250 1
a250 3
txp_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d297 1
a297 2
txp_chip_init(sc)
	struct txp_softc *sc;
d334 1
a334 2
txp_reset_adapter(sc)
	struct txp_softc *sc;
d360 1
a360 2
txp_download_fw(sc)
	struct txp_softc *sc;
d446 1
a446 2
txp_download_fw_wait(sc)
	struct txp_softc *sc;
d473 3
a475 6
txp_download_fw_section(sc, sect, sectnum, buf, buflen)
	struct txp_softc *sc;
	struct txp_fw_section_header *sect;
	int sectnum;
	u_char *buf;
	size_t buflen;
d551 1
a551 2
txp_intr(vsc)
	void *vsc;
d604 2
a605 4
txp_rx_reclaim(sc, r, dma)
	struct txp_softc *sc;
	struct txp_rx_ring *r;
	struct txp_dma_alloc *dma;
d748 1
a748 2
txp_rxbuf_reclaim(sc)
	struct txp_softc *sc;
d829 2
a830 4
txp_tx_reclaim(sc, r, dma)
	struct txp_softc *sc;
	struct txp_tx_ring *r;
	struct txp_dma_alloc *dma;
d882 1
a882 2
txp_shutdown(vsc)
	void *vsc;
d898 1
a898 2
txp_alloc_rings(sc)
	struct txp_softc *sc;
d1162 2
a1163 5
txp_dma_malloc(sc, size, dma, mapflags)
	struct txp_softc *sc;
	bus_size_t size;
	struct txp_dma_alloc *dma;
	int mapflags;
d1197 1
a1197 3
txp_dma_free(sc, dma)
	struct txp_softc *sc;
	struct txp_dma_alloc *dma;
d1206 1
a1206 4
txp_ioctl(ifp, command, data)
	struct ifnet *ifp;
	u_long command;
	caddr_t data;
d1274 1
a1274 2
txp_init(sc)
	struct txp_softc *sc;
d1306 1
a1306 2
txp_tick(vsc)
	void *vsc;
d1345 1
a1345 2
txp_start(ifp)
	struct ifnet *ifp;
d1531 3
a1533 5
txp_command(sc, id, in1, in2, in3, out1, out2, out3, wait)
	struct txp_softc *sc;
	u_int16_t id, in1, *out1;
	u_int32_t in2, in3, *out2, *out3;
	int wait;
d1554 3
a1556 8
txp_command2(sc, id, in1, in2, in3, in_extp, in_extn, rspp, wait)
	struct txp_softc *sc;
	u_int16_t id, in1;
	u_int32_t in2, in3;
	struct txp_ext_desc *in_extp;
	u_int8_t in_extn;
	struct txp_rsp_desc **rspp;
	int wait;
d1629 2
a1630 6
txp_response(sc, ridx, id, seq, rspp)
	struct txp_softc *sc;
	u_int32_t ridx;
	u_int16_t id;
	u_int16_t seq;
	struct txp_rsp_desc **rspp;
d1677 2
a1678 3
txp_rsp_fixup(sc, rsp, dst)
	struct txp_softc *sc;
	struct txp_rsp_desc *rsp, *dst;
d1703 1
a1703 2
txp_cmd_desc_numfree(sc)
	struct txp_softc *sc;
d1727 1
a1727 2
txp_stop(sc)
	struct txp_softc *sc;
d1736 1
a1736 2
txp_watchdog(ifp)
	struct ifnet *ifp;
d1741 1
a1741 2
txp_ifmedia_upd(ifp)
	struct ifnet *ifp;
d1777 1
a1777 3
txp_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
d1846 1
a1846 2
txp_show_descriptor(d)
	void *d;
d1891 1
a1891 2
txp_set_filter(sc)
	struct txp_softc *sc;
d1954 1
a1954 2
txp_capabilities(sc)
	struct txp_softc *sc;
@


1.88
log
@Remove unnecessary receive filter call from the attach hook. This is
already dealt with via txp_init().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.87 2008/05/22 02:32:29 brad Exp $	*/
d1776 1
a1776 2
	if (timeout_pending(&sc->sc_tick))
		timeout_del(&sc->sc_tick);
@


1.87
log
@Read the MII_ANAR register and get the common denominator ability.

From FreeBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.86 2008/05/22 02:30:55 brad Exp $	*/
a198 2

	txp_set_filter(sc);
@


1.86
log
@Remove the "loaded firmware" message from dmesg. Only print something
if there was an error.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.85 2008/04/03 21:43:21 brad Exp $	*/
d1832 1
a1832 1
	u_int16_t bmsr, bmcr, anlpar;
d1848 4
d1874 1
@


1.85
log
@Add missing half duplex flags for the media status.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.84 2007/04/11 14:41:15 claudio Exp $	*/
a447 1
	printf("loaded firmware, ");
@


1.84
log
@Do not use m_prepend() directly, always use M_PREPEND() instead.
While changing that also change the order of the __STRICT_ALIGNMENT case and
introduce a bit of headroom in the mcluster used for the RX DMA. This prevents
unnecessary allocations of mbufs. Tested by camield@@ OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.83 2006/06/29 21:36:40 deraadt Exp $	*/
d1872 1
a1872 1
			ifmr->ifm_active |= IFM_100_T4;
d1876 1
a1876 1
			ifmr->ifm_active |= IFM_100_TX;
d1880 1
a1880 1
			ifmr->ifm_active |= IFM_10_T;
@


1.83
log
@do not check for master/io/mem enables
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.82 2006/05/28 00:04:24 jason Exp $	*/
d660 25
a716 28
#if NVLAN > 0
		/*
		 * XXX Another firmware bug: the vlan encapsulation
		 * is always removed, even when we tell the card not
		 * to do that.  Restore the vlan encapsulation below.
		 */
		if (rxd->rx_stat & htole32(RX_STAT_VLAN)) {
			struct ether_vlan_header vh;

			if (m->m_pkthdr.len < ETHER_HDR_LEN) {
				m_freem(m);
				goto next;
			}
			m_copydata(m, 0, ETHER_HDR_LEN, (caddr_t)&vh);
			vh.evl_proto = vh.evl_encap_proto;
			vh.evl_tag = rxd->rx_vlan >> 16;
			vh.evl_encap_proto = htons(ETHERTYPE_VLAN);
			m_adj(m, ETHER_HDR_LEN);
			if ((m = m_prepend(m, sizeof(vh), M_DONTWAIT)) == NULL)
				goto next;
			m->m_pkthdr.len += sizeof(vh);
			if (m->m_len < sizeof(vh) &&
			    (m = m_pullup(m, sizeof(vh))) == NULL)
				goto next;
			m_copyback(m, 0, sizeof(vh), &vh);
		}
#endif

d795 3
a798 1
		sd->sd_mbuf->m_pkthdr.len = sd->sd_mbuf->m_len = MCLBYTES;
d1083 3
a1085 1
		sd->sd_mbuf->m_pkthdr.len = sd->sd_mbuf->m_len = MCLBYTES;
@


1.82
log
@unknown ioctl is ENOTTY not EINVAL
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.81 2006/04/26 15:47:07 jason Exp $	*/
a263 1
	u_int32_t command;
a266 11
	command = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);

	if (!(command & PCI_COMMAND_MASTER_ENABLE)) {
		printf(": failed to enable bus mastering\n");
		return;
	}

	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf(": failed to enable memory mapping\n");
		return;
	}
@


1.81
log
@coverity, covsmerity: no reason to put an overly complex fix in here in
an error case that almost never happens.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.80 2006/03/25 22:41:45 djm Exp $	*/
d1305 1
a1305 1
		error = EINVAL;
@


1.80
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.79 2006/02/16 21:02:34 brad Exp $	*/
d1080 4
a1109 3
		/* stash away pointer */
		bcopy(&sd, (u_long *)&sc->sc_rxbufs[i].rb_vaddrlo, sizeof(sd));

d1169 5
@


1.79
log
@set IFCAP_VLAN_MTU unconditionally.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.78 2005/06/15 16:28:09 camield Exp $	*/
d737 1
a737 1
			bpf_mtap(ifp->if_bpf, m);
d1524 1
a1524 1
			bpf_mtap(ifp->if_bpf, m);
@


1.78
log
@Disable hardware vlan decapsulation, but not really.  Because of a firmware
bug the vlan tag is always stripped off, so restore the encapsulation in
software.

ok deraadt, "looks ok" jason brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.77 2005/04/25 17:55:51 brad Exp $	*/
d66 1
d2025 2
a2027 1
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
@


1.77
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.76 2005/01/15 05:24:11 brad Exp $	*/
d703 28
a755 8
#if NVLAN > 0
		if (rxd->rx_stat & htole32(RX_STAT_VLAN)) {
			if (vlan_input_tag(m, htons(rxd->rx_vlan >> 16)) < 0)
				ifp->if_noproto++;
			goto next;
		}
#endif

a2027 1
		sc->sc_rx_capability |= OFFLOAD_VLAN;
@


1.76
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.75 2004/12/17 14:10:40 grange Exp $	*/
d726 1
a726 1
		m->m_pkthdr.csum = sumflags;
d1444 1
a1444 1
		if (m->m_pkthdr.csum & M_IPV4_CSUM_OUT)
d1447 1
a1447 1
		if (m->m_pkthdr.csum & M_TCPV4_CSUM_OUT)
d1451 1
a1451 1
		if (m->m_pkthdr.csum & M_UDPV4_CSUM_OUT)
@


1.75
log
@Fix printf in loadfirmware error path.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.74 2004/12/14 01:50:42 deraadt Exp $	*/
d1268 2
a1269 1
			txp_set_filter(sc);
@


1.74
log
@txp(4) late firmware loading, written somewhere over the pacific, tested
by mcbride, reduces size of the kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.73 2004/09/23 17:45:16 brad Exp $	*/
d411 1
a411 1
		printf(": failed loadfirmware of file 3c990: errno %d\n",
@


1.73
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.72 2004/05/31 19:25:00 mcbride Exp $	*/
a78 2
#include <dev/microcode/typhoon/3c990img.h>

d88 1
d103 1
a103 1
    struct txp_fw_section_header *, int);
d160 1
a160 3
txp_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d162 1
a162 5
	struct txp_softc *sc = (struct txp_softc *)self;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
a163 2
	bus_size_t iosize;
	u_int32_t command;
d166 1
d168 2
a169 3
	sc->sc_cold = 1;

	command = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
d171 3
a173 7
	if (!(command & PCI_COMMAND_MASTER_ENABLE)) {
		printf(": failed to enable bus mastering\n");
		return;
	}

	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf(": failed to enable memory mapping\n");
a175 7
	if (pci_mapreg_map(pa, TXP_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->sc_bt, &sc->sc_bh, NULL, &iosize, 0)) {
		printf(": can't map mem space %d\n", 0);
		return;
	}

	sc->sc_dmat = pa->pa_dmat;
d177 2
a178 5
	/*
	 * Allocate our interrupt.
	 */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
d182 2
a183 8
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, txp_intr, sc,
	    self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
a185 10
	printf(": %s", intrstr);

	if (txp_chip_init(sc))
		return;

	if (txp_download_fw(sc))
		return;

	if (txp_alloc_rings(sc))
		return;
d188 2
a189 1
	    NULL, NULL, NULL, 1))
d191 1
d194 2
a195 1
	    &p1, &p2, NULL, 1))
d197 1
d210 1
a210 1
	printf(" address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));
d249 62
a383 1
	int sect;
d385 3
d402 1
a402 1
		printf(": not waiting for host request\n");
d409 8
a416 1
	fileheader = (struct txp_fw_file_header *)tc990image;
d418 2
a419 2
		printf(": fw invalid magic\n");
		return (-1);
d427 2
a428 2
		printf("%s: fw wait failed, initial\n", sc->sc_dev.dv_xname);
		return (-1);
d431 1
a431 1
	secthead = (struct txp_fw_section_header *)(((u_int8_t *)tc990image) +
d435 2
a436 2
		if (txp_download_fw_section(sc, secthead, sect))
			return (-1);
d451 2
a452 2
		printf(": not waiting for boot\n");
		return (-1);
d458 2
d461 3
d480 1
a480 1
		printf(": fw wait failed comm0\n");
d488 1
a488 1
		printf(": fw not waiting for segment\n");
d495 1
a495 1
txp_download_fw_section(sc, sect, sectnum)
d499 2
d512 3
a514 3
	rseg = ((u_int8_t *)sect) - ((u_int8_t *)tc990image);
	if (rseg >= sizeof(tc990image)) {
		printf(": fw invalid section address, section %d\n", sectnum);
d520 2
a521 2
	if (rseg >= sizeof(tc990image)) {
		printf(": fw truncated section %d\n", sectnum);
d527 1
a527 1
		printf(": fw dma malloc failed, section %d\n", sectnum);
d544 1
a544 1
		printf(": fw section %d, bad cksum (expected 0x%x got 0x%x)\n",
d923 1
a923 1
		printf(": can't allocate boot record\n");
d933 1
a933 1
		printf(": can't allocate host ring\n");
d944 1
a944 1
		printf(": can't allocate high tx ring\n");
d971 1
a971 1
		printf(": can't allocate low tx ring\n");
d986 1
a986 1
		printf(": can't allocate high rx ring\n");
d1003 1
a1003 1
		printf(": can't allocate low rx ring\n");
d1020 1
a1020 1
		printf(": can't allocate command ring\n");
d1034 1
a1034 1
		printf(": can't allocate response ring\n");
d1048 1
a1048 1
		printf(": can't allocate rx buffer ring\n");
d1102 1
a1102 1
		printf(": can't allocate response ring\n");
d1117 1
a1117 1
		printf(": not waiting for boot\n");
d1132 1
a1132 1
		printf(": fw not running\n");
@


1.72
log
@Replace local crc32 with ether_crc32_be.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.71 2003/12/29 23:06:55 brad Exp $	*/
a262 1
	ifp->if_mtu = ETHERMTU;
a264 1
	ifp->if_output = ether_output;
@


1.71
log
@no vtophys(), don't need uvm_extern.h anymore.

tested on alpha, i386, macppc and sparc64.

ok millert@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.70 2003/10/22 11:02:41 henning Exp $	*/
d1886 1
a1886 1
	u_int32_t crc, carry, hashbit, hash[2];
d1888 1
a1888 2
	u_int8_t octet;
	int i, j, mcnt = 0;
d1926 2
a1927 15
			crc = 0xffffffff;

			for (i = 0; i < ETHER_ADDR_LEN; i++) {
				octet = enm->enm_addrlo[i];
				for (j = 0; j < 8; j++) {
					carry = ((crc & 0x80000000) ? 1 : 0) ^
					    (octet & 1);
					crc <<= 1;
					octet >>= 1;
					if (carry)
						crc = (crc ^ TXP_POLYNOMIAL) |
						    carry;
				}
			}
			hashbit = (u_int16_t)(crc & (64 - 1));
@


1.70
log
@one more 3c990 variant; tested by Niko Itajarvi <niko.itajarvi@@satabaana.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.69 2003/06/02 19:03:37 jason Exp $	*/
a68 1
#include <uvm/uvm_extern.h>              /* for vtophys */
@


1.69
log
@Remove clause 3 & 4 (with permission from aaron and deraadt)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.68 2003/02/28 00:51:36 jason Exp $	*/
d142 1
@


1.68
log
@add support for 3cr990 (not 3cr990a,b,c, etc) and 3cr990-fx; from linux driver
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.67 2002/11/19 18:40:17 jason Exp $	*/
a15 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright,
 *	Theo de Raadt and Aaron Campbell.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
@


1.67
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.66 2002/07/11 20:27:04 jason Exp $	*/
d148 1
d155 1
@


1.66
log
@add rcsid to firmware, and remove defn for tc990_IMAGE_SIZE, its ugly.
(shoulda caught this before like I caught const'fying it, oh well)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.65 2002/07/11 20:15:46 jason Exp $	*/
d147 9
d161 2
a162 16
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_3COM)
		return (0);

	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_3COM_3CR990TX95:
	case PCI_PRODUCT_3COM_3CR990TX97:
	case PCI_PRODUCT_3COM_3CR990SVR95:
	case PCI_PRODUCT_3COM_3CR990SVR97:
	case PCI_PRODUCT_3COM_3C990BTXM:
	case PCI_PRODUCT_3COM_3C990BSVR:
		return (1);
	}

	return (0);
@


1.65
log
@Convert the cmd and response queues to be endian aware, also prepare for new firmware version.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.64 2002/04/30 23:18:41 jason Exp $	*/
a86 1
#define	tc990_IMAGE_SIZE
@


1.64
log
@enough letoh-foo to get through firmware upload on big endian machines
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.63 2002/03/14 01:26:59 millert Exp $	*/
d87 1
d247 1
d250 1
d578 1
a578 1
		    TXP_OFFSET2IDX(*(sc->sc_txhir.r_off))))
d582 1
a582 1
		    TXP_OFFSET2IDX(*(sc->sc_txlor.r_off))))
d612 2
a613 2
	roff = *r->r_roff;
	woff = *r->r_woff;
d625 1
a625 1
			    rxd->rx_stat);
d639 1
a639 1
		m->m_pkthdr.len = m->m_len = rxd->rx_len;
d681 1
a681 1
		if (rxd->rx_stat & RX_STAT_IPCKSUMBAD)
d683 1
a683 1
		else if (rxd->rx_stat & RX_STAT_IPCKSUMGOOD)
d686 1
a686 1
		if (rxd->rx_stat & RX_STAT_TCPCKSUMBAD)
d688 1
a688 1
		else if (rxd->rx_stat & RX_STAT_TCPCKSUMGOOD)
d691 1
a691 1
		if (rxd->rx_stat & RX_STAT_UDPCKSUMBAD)
d693 1
a693 1
		else if (rxd->rx_stat & RX_STAT_UDPCKSUMGOOD)
d699 1
a699 1
		if (rxd->rx_stat & RX_STAT_VLAN) {
d722 1
a722 1
		woff = *r->r_woff;
d725 1
a725 1
	*r->r_roff = woff;
d738 2
a739 2
	end = TXP_OFFSET2IDX(hv->hv_rx_buf_read_idx);
	i = TXP_OFFSET2IDX(hv->hv_rx_buf_write_idx);
d789 1
a789 1
		hv->hv_rx_buf_write_idx = TXP_IDX2OFFSET(i);
d815 1
a815 1
	u_int32_t idx = TXP_OFFSET2IDX(*(r->r_off));
d907 2
a908 2
	boot->br_hostvar_lo = sc->sc_host_dma.dma_paddr & 0xffffffff;
	boot->br_hostvar_hi = sc->sc_host_dma.dma_paddr >> 32;
d918 3
a920 3
	boot->br_txhipri_lo = sc->sc_txhiring_dma.dma_paddr & 0xffffffff;
	boot->br_txhipri_hi = sc->sc_txhiring_dma.dma_paddr >> 32;
	boot->br_txhipri_siz = TX_ENTRIES * sizeof(struct txp_tx_desc);
d945 3
a947 3
	boot->br_txlopri_lo = sc->sc_txloring_dma.dma_paddr & 0xffffffff;
	boot->br_txlopri_hi = sc->sc_txloring_dma.dma_paddr >> 32;
	boot->br_txlopri_siz = TX_ENTRIES * sizeof(struct txp_tx_desc);
d960 3
a962 3
	boot->br_rxhipri_lo = sc->sc_rxhiring_dma.dma_paddr & 0xffffffff;
	boot->br_rxhipri_hi = sc->sc_rxhiring_dma.dma_paddr >> 32;
	boot->br_rxhipri_siz = RX_ENTRIES * sizeof(struct txp_rx_desc);
d977 3
a979 3
	boot->br_rxlopri_lo = sc->sc_rxloring_dma.dma_paddr & 0xffffffff;
	boot->br_rxlopri_hi = sc->sc_rxloring_dma.dma_paddr >> 32;
	boot->br_rxlopri_siz = RX_ENTRIES * sizeof(struct txp_rx_desc);
d994 3
a996 3
	boot->br_cmd_lo = sc->sc_cmdring_dma.dma_paddr & 0xffffffff;
	boot->br_cmd_hi = sc->sc_cmdring_dma.dma_paddr >> 32;
	boot->br_cmd_siz = CMD_ENTRIES * sizeof(struct txp_cmd_desc);
d1008 3
a1010 3
	boot->br_resp_lo = sc->sc_rspring_dma.dma_paddr & 0xffffffff;
	boot->br_resp_hi = sc->sc_rspring_dma.dma_paddr >> 32;
	boot->br_resp_siz = CMD_ENTRIES * sizeof(struct txp_rsp_desc);
d1022 3
a1024 3
	boot->br_rxbuf_lo = sc->sc_rxbufring_dma.dma_paddr & 0xffffffff;
	boot->br_rxbuf_hi = sc->sc_rxbufring_dma.dma_paddr >> 32;
	boot->br_rxbuf_siz = RXBUF_ENTRIES * sizeof(struct txp_rxbuf_desc);
d1066 2
a1067 2
	sc->sc_hostvar->hv_rx_buf_write_idx = (RXBUF_ENTRIES - 1) *
	    sizeof(struct txp_rxbuf_desc);
d1076 2
a1077 2
	boot->br_zero_lo = sc->sc_zero_dma.dma_paddr & 0xffffffff;
	boot->br_zero_hi = sc->sc_zero_dma.dma_paddr >> 32;
d1532 1
a1532 1
		*out1 = rsp->rsp_par1;
d1534 1
a1534 1
		*out2 = rsp->rsp_par2;
d1536 1
a1536 1
		*out3 = rsp->rsp_par3;
d1567 6
a1572 5
	cmd->cmd_seq = seq = sc->sc_seq++;
	cmd->cmd_id = id;
	cmd->cmd_par1 = in1;
	cmd->cmd_par2 = in2;
	cmd->cmd_par3 = in3;
d1601 2
a1602 2
		idx = hv->hv_resp_read_idx;
		if (idx != hv->hv_resp_write_idx) {
d1632 1
a1632 1
	while (ridx != hv->hv_resp_write_idx) {
d1635 1
a1635 1
		if (id == rsp->rsp_id && rsp->rsp_seq == seq) {
d1647 1
a1647 1
			    TXP_DEVNAME(sc), rsp->rsp_id);
d1649 1
a1649 1
			ridx = hv->hv_resp_read_idx;
d1653 1
a1653 1
		switch (rsp->rsp_id) {
d1662 1
a1662 1
			    rsp->rsp_id);
d1666 2
a1667 2
		ridx = hv->hv_resp_read_idx;
		hv->hv_resp_read_idx = ridx;
d1682 1
a1682 1
	ridx = hv->hv_resp_read_idx;
d1693 2
a1694 1
		sc->sc_rspring.lastwrite = hv->hv_resp_read_idx = ridx;
d1697 1
a1697 1
	hv->hv_resp_read_idx = ridx;
d1709 1
a1709 1
	ridx = hv->hv_cmd_read_idx;
d1713 1
a1713 1
		nfree = br->br_cmd_siz - sizeof(struct txp_cmd_desc);
d1716 1
a1716 1
			nfree = br->br_cmd_siz -
d1858 3
a1860 2
		    cmd->cmd_flags, cmd->cmd_numdesc, cmd->cmd_id, cmd->cmd_seq,
		    cmd->cmd_par1, cmd->cmd_par2, cmd->cmd_par3);
d1865 3
a1867 2
		    rsp->rsp_flags, rsp->rsp_numdesc, rsp->rsp_id, rsp->rsp_seq,
		    rsp->rsp_par1, rsp->rsp_par2, rsp->rsp_par3);
d1884 3
a1886 2
		    cmd->cmd_flags, cmd->cmd_numdesc, cmd->cmd_id, cmd->cmd_seq,
		    cmd->cmd_par1, cmd->cmd_par2, cmd->cmd_par3);
@


1.63
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.62 2002/03/12 09:51:20 kjc Exp $	*/
d397 1
a397 1
	WRITE_REG(sc, TXP_H2A_1, fileheader->addr);
d408 1
a408 1
	for (sect = 0; sect < fileheader->nsections; sect++) {
d412 2
a413 1
		    (((u_int8_t *)secthead) + secthead->nbytes + sizeof(*secthead));
d486 1
a486 1
	rseg += sect->nbytes;
d493 1
a493 1
	if (txp_dma_malloc(sc, sect->nbytes, &dma, 0)) {
d498 2
a499 1
	bcopy(((u_int8_t *)sect) + sizeof(*sect), dma.dma_vaddr, sect->nbytes);
d506 1
a506 1
	m.m_len = sect->nbytes;
d509 1
a509 1
	csum = in_cksum(&m, sect->nbytes);
d520 3
a522 3
	WRITE_REG(sc, TXP_H2A_1, sect->nbytes);
	WRITE_REG(sc, TXP_H2A_2, sect->cksum);
	WRITE_REG(sc, TXP_H2A_3, sect->addr);
@


1.62
log
@sync with KAME
ALTQify more drivers.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.61 2002/02/15 20:45:31 nordin Exp $	*/
d96 26
a121 26
int txp_probe		__P((struct device *, void *, void *));
void txp_attach		__P((struct device *, struct device *, void *));
int txp_intr		__P((void *));
void txp_tick		__P((void *));
void txp_shutdown	__P((void *));
int txp_ioctl		__P((struct ifnet *, u_long, caddr_t));
void txp_start		__P((struct ifnet *));
void txp_stop		__P((struct txp_softc *));
void txp_init		__P((struct txp_softc *));
void txp_watchdog	__P((struct ifnet *));

int txp_chip_init __P((struct txp_softc *));
int txp_reset_adapter __P((struct txp_softc *));
int txp_download_fw __P((struct txp_softc *));
int txp_download_fw_wait __P((struct txp_softc *));
int txp_download_fw_section __P((struct txp_softc *,
    struct txp_fw_section_header *, int));
int txp_alloc_rings __P((struct txp_softc *));
void txp_dma_free __P((struct txp_softc *, struct txp_dma_alloc *));
int txp_dma_malloc __P((struct txp_softc *, bus_size_t, struct txp_dma_alloc *, int));
void txp_set_filter __P((struct txp_softc *));

int txp_cmd_desc_numfree __P((struct txp_softc *));
int txp_command __P((struct txp_softc *, u_int16_t, u_int16_t, u_int32_t,
    u_int32_t, u_int16_t *, u_int32_t *, u_int32_t *, int));
int txp_command2 __P((struct txp_softc *, u_int16_t, u_int16_t,
d123 15
a137 15
    struct txp_rsp_desc **, int));
int txp_response __P((struct txp_softc *, u_int32_t, u_int16_t, u_int16_t,
    struct txp_rsp_desc **));
void txp_rsp_fixup __P((struct txp_softc *, struct txp_rsp_desc *,
    struct txp_rsp_desc *));
void txp_capabilities __P((struct txp_softc *));

void txp_ifmedia_sts __P((struct ifnet *, struct ifmediareq *));
int txp_ifmedia_upd __P((struct ifnet *));
void txp_show_descriptor __P((void *));
void txp_tx_reclaim __P((struct txp_softc *, struct txp_tx_ring *,
    struct txp_dma_alloc *));
void txp_rxbuf_reclaim __P((struct txp_softc *));
void txp_rx_reclaim __P((struct txp_softc *, struct txp_rx_ring *,
    struct txp_dma_alloc *));
@


1.61
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.60 2002/02/07 16:56:34 jason Exp $	*/
d1347 1
a1347 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
d1350 1
d1372 1
d1456 7
a1505 1
	IF_PREPEND(&ifp->if_snd, m);
@


1.60
log
@fix copyright; chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.59 2001/11/06 19:53:19 miod Exp $	*/
d1246 1
a1246 1
	(void)splx(s);
@


1.59
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.58 2001/11/05 17:25:58 art Exp $	*/
d27 1
a27 1
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
@


1.59.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.59 2001/11/06 19:53:19 miod Exp $	*/
d27 1
a27 1
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR THE VOICES IN THEIR HEADS
d96 26
a121 26
int txp_probe(struct device *, void *, void *);
void txp_attach(struct device *, struct device *, void *);
int txp_intr(void *);
void txp_tick(void *);
void txp_shutdown(void *);
int txp_ioctl(struct ifnet *, u_long, caddr_t);
void txp_start(struct ifnet *);
void txp_stop(struct txp_softc *);
void txp_init(struct txp_softc *);
void txp_watchdog(struct ifnet *);

int txp_chip_init(struct txp_softc *);
int txp_reset_adapter(struct txp_softc *);
int txp_download_fw(struct txp_softc *);
int txp_download_fw_wait(struct txp_softc *);
int txp_download_fw_section(struct txp_softc *,
    struct txp_fw_section_header *, int);
int txp_alloc_rings(struct txp_softc *);
void txp_dma_free(struct txp_softc *, struct txp_dma_alloc *);
int txp_dma_malloc(struct txp_softc *, bus_size_t, struct txp_dma_alloc *, int);
void txp_set_filter(struct txp_softc *);

int txp_cmd_desc_numfree(struct txp_softc *);
int txp_command(struct txp_softc *, u_int16_t, u_int16_t, u_int32_t,
    u_int32_t, u_int16_t *, u_int32_t *, u_int32_t *, int);
int txp_command2(struct txp_softc *, u_int16_t, u_int16_t,
d123 15
a137 15
    struct txp_rsp_desc **, int);
int txp_response(struct txp_softc *, u_int32_t, u_int16_t, u_int16_t,
    struct txp_rsp_desc **);
void txp_rsp_fixup(struct txp_softc *, struct txp_rsp_desc *,
    struct txp_rsp_desc *);
void txp_capabilities(struct txp_softc *);

void txp_ifmedia_sts(struct ifnet *, struct ifmediareq *);
int txp_ifmedia_upd(struct ifnet *);
void txp_show_descriptor(void *);
void txp_tx_reclaim(struct txp_softc *, struct txp_tx_ring *,
    struct txp_dma_alloc *);
void txp_rxbuf_reclaim(struct txp_softc *);
void txp_rx_reclaim(struct txp_softc *, struct txp_rx_ring *,
    struct txp_dma_alloc *);
d397 1
a397 1
	WRITE_REG(sc, TXP_H2A_1, letoh32(fileheader->addr));
d408 1
a408 1
	for (sect = 0; sect < letoh32(fileheader->nsections); sect++) {
d412 1
a412 2
		    (((u_int8_t *)secthead) + letoh32(secthead->nbytes) +
			sizeof(*secthead));
d485 1
a485 1
	rseg += letoh32(sect->nbytes);
d492 1
a492 1
	if (txp_dma_malloc(sc, letoh32(sect->nbytes), &dma, 0)) {
d497 1
a497 2
	bcopy(((u_int8_t *)sect) + sizeof(*sect), dma.dma_vaddr,
	    letoh32(sect->nbytes));
d504 1
a504 1
	m.m_len = letoh32(sect->nbytes);
d507 1
a507 1
	csum = in_cksum(&m, letoh32(sect->nbytes));
d518 3
a520 3
	WRITE_REG(sc, TXP_H2A_1, letoh32(sect->nbytes));
	WRITE_REG(sc, TXP_H2A_2, letoh16(sect->cksum));
	WRITE_REG(sc, TXP_H2A_3, letoh32(sect->addr));
d1246 1
a1246 1
	splx(s);
d1347 1
a1347 1
		IFQ_POLL(&ifp->if_snd, m);
a1349 1
		mnew = NULL;
a1370 1
			IFQ_DEQUEUE(&ifp->if_snd, m);
a1453 7
		/*
		 * if mnew isn't NULL, we already dequeued and copied
		 * the packet.
		 */
		if (mnew == NULL)
			IFQ_DEQUEUE(&ifp->if_snd, m);

d1497 1
@


1.59.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.59.2.1 2002/06/11 03:42:26 art Exp $	*/
a245 1
	p1 = htole16(p1);
a247 1
	p2 = htole32(p2);
d575 1
a575 1
		    TXP_OFFSET2IDX(letoh32(*(sc->sc_txhir.r_off)))))
d579 1
a579 1
		    TXP_OFFSET2IDX(letoh32(*(sc->sc_txlor.r_off)))))
d609 2
a610 2
	roff = letoh32(*r->r_roff);
	woff = letoh32(*r->r_woff);
d622 1
a622 1
			    letoh32(rxd->rx_stat));
d636 1
a636 1
		m->m_pkthdr.len = m->m_len = letoh16(rxd->rx_len);
d678 1
a678 1
		if (rxd->rx_stat & htole32(RX_STAT_IPCKSUMBAD))
d680 1
a680 1
		else if (rxd->rx_stat & htole32(RX_STAT_IPCKSUMGOOD))
d683 1
a683 1
		if (rxd->rx_stat & htole32(RX_STAT_TCPCKSUMBAD))
d685 1
a685 1
		else if (rxd->rx_stat & htole32(RX_STAT_TCPCKSUMGOOD))
d688 1
a688 1
		if (rxd->rx_stat & htole32(RX_STAT_UDPCKSUMBAD))
d690 1
a690 1
		else if (rxd->rx_stat & htole32(RX_STAT_UDPCKSUMGOOD))
d696 1
a696 1
		if (rxd->rx_stat & htole32(RX_STAT_VLAN)) {
d719 1
a719 1
		woff = letoh32(*r->r_woff);
d722 1
a722 1
	*r->r_roff = htole32(woff);
d735 2
a736 2
	end = TXP_OFFSET2IDX(letoh32(hv->hv_rx_buf_read_idx));
	i = TXP_OFFSET2IDX(letoh32(hv->hv_rx_buf_write_idx));
d786 1
a786 1
		hv->hv_rx_buf_write_idx = htole32(TXP_IDX2OFFSET(i));
d812 1
a812 1
	u_int32_t idx = TXP_OFFSET2IDX(letoh32(*(r->r_off)));
d904 2
a905 2
	boot->br_hostvar_lo = htole32(sc->sc_host_dma.dma_paddr & 0xffffffff);
	boot->br_hostvar_hi = htole32(sc->sc_host_dma.dma_paddr >> 32);
d915 3
a917 3
	boot->br_txhipri_lo = htole32(sc->sc_txhiring_dma.dma_paddr & 0xffffffff);
	boot->br_txhipri_hi = htole32(sc->sc_txhiring_dma.dma_paddr >> 32);
	boot->br_txhipri_siz = htole32(TX_ENTRIES * sizeof(struct txp_tx_desc));
d942 3
a944 3
	boot->br_txlopri_lo = htole32(sc->sc_txloring_dma.dma_paddr & 0xffffffff);
	boot->br_txlopri_hi = htole32(sc->sc_txloring_dma.dma_paddr >> 32);
	boot->br_txlopri_siz = htole32(TX_ENTRIES * sizeof(struct txp_tx_desc));
d957 3
a959 3
	boot->br_rxhipri_lo = htole32(sc->sc_rxhiring_dma.dma_paddr & 0xffffffff);
	boot->br_rxhipri_hi = htole32(sc->sc_rxhiring_dma.dma_paddr >> 32);
	boot->br_rxhipri_siz = htole32(RX_ENTRIES * sizeof(struct txp_rx_desc));
d974 3
a976 3
	boot->br_rxlopri_lo = htole32(sc->sc_rxloring_dma.dma_paddr & 0xffffffff);
	boot->br_rxlopri_hi = htole32(sc->sc_rxloring_dma.dma_paddr >> 32);
	boot->br_rxlopri_siz = htole32(RX_ENTRIES * sizeof(struct txp_rx_desc));
d991 3
a993 3
	boot->br_cmd_lo = htole32(sc->sc_cmdring_dma.dma_paddr & 0xffffffff);
	boot->br_cmd_hi = htole32(sc->sc_cmdring_dma.dma_paddr >> 32);
	boot->br_cmd_siz = htole32(CMD_ENTRIES * sizeof(struct txp_cmd_desc));
d1005 3
a1007 3
	boot->br_resp_lo = htole32(sc->sc_rspring_dma.dma_paddr & 0xffffffff);
	boot->br_resp_hi = htole32(sc->sc_rspring_dma.dma_paddr >> 32);
	boot->br_resp_siz = htole32(CMD_ENTRIES * sizeof(struct txp_rsp_desc));
d1019 3
a1021 3
	boot->br_rxbuf_lo = htole32(sc->sc_rxbufring_dma.dma_paddr & 0xffffffff);
	boot->br_rxbuf_hi = htole32(sc->sc_rxbufring_dma.dma_paddr >> 32);
	boot->br_rxbuf_siz = htole32(RXBUF_ENTRIES * sizeof(struct txp_rxbuf_desc));
d1063 2
a1064 2
	sc->sc_hostvar->hv_rx_buf_write_idx = htole32((RXBUF_ENTRIES - 1) *
	    sizeof(struct txp_rxbuf_desc));
d1073 2
a1074 2
	boot->br_zero_lo = htole32(sc->sc_zero_dma.dma_paddr & 0xffffffff);
	boot->br_zero_hi = htole32(sc->sc_zero_dma.dma_paddr >> 32);
d1529 1
a1529 1
		*out1 = letoh16(rsp->rsp_par1);
d1531 1
a1531 1
		*out2 = letoh32(rsp->rsp_par2);
d1533 1
a1533 1
		*out3 = letoh32(rsp->rsp_par3);
d1564 5
a1568 6
	seq = sc->sc_seq++;
	cmd->cmd_seq = htole16(seq);
	cmd->cmd_id = htole16(id);
	cmd->cmd_par1 = htole16(in1);
	cmd->cmd_par2 = htole32(in2);
	cmd->cmd_par3 = htole32(in3);
d1597 2
a1598 2
		idx = letoh32(hv->hv_resp_read_idx);
		if (idx != letoh32(hv->hv_resp_write_idx)) {
d1628 1
a1628 1
	while (ridx != letoh32(hv->hv_resp_write_idx)) {
d1631 1
a1631 1
		if (id == letoh16(rsp->rsp_id) && letoh16(rsp->rsp_seq) == seq) {
d1643 1
a1643 1
			    TXP_DEVNAME(sc), letoh16(rsp->rsp_id));
d1645 1
a1645 1
			ridx = letoh32(hv->hv_resp_read_idx);
d1649 1
a1649 1
		switch (letoh16(rsp->rsp_id)) {
d1658 1
a1658 1
			    letoh16(rsp->rsp_id));
d1662 2
a1663 2
		ridx = letoh32(hv->hv_resp_read_idx);
		hv->hv_resp_read_idx = letoh32(ridx);
d1678 1
a1678 1
	ridx = letoh32(hv->hv_resp_read_idx);
d1689 1
a1689 2
		sc->sc_rspring.lastwrite = ridx;
		hv->hv_resp_read_idx = htole32(ridx);
d1692 1
a1692 1
	hv->hv_resp_read_idx = htole32(ridx);
d1704 1
a1704 1
	ridx = letoh32(hv->hv_cmd_read_idx);
d1708 1
a1708 1
		nfree = letoh32(br->br_cmd_siz) - sizeof(struct txp_cmd_desc);
d1711 1
a1711 1
			nfree = letoh32(br->br_cmd_siz) -
d1853 2
a1854 3
		    cmd->cmd_flags, cmd->cmd_numdesc, letoh16(cmd->cmd_id),
		    letoh16(cmd->cmd_seq), letoh16(cmd->cmd_par1),
		    letoh32(cmd->cmd_par2), letoh32(cmd->cmd_par3));
d1859 2
a1860 3
		    rsp->rsp_flags, rsp->rsp_numdesc, letoh16(rsp->rsp_id),
		    letoh16(rsp->rsp_seq), letoh16(rsp->rsp_par1),
		    letoh32(rsp->rsp_par2), letoh32(rsp->rsp_par3));
d1877 2
a1878 3
		    cmd->cmd_flags, cmd->cmd_numdesc, letoh16(cmd->cmd_id),
		    letoh16(cmd->cmd_seq), letoh16(cmd->cmd_par1),
		    letoh32(cmd->cmd_par2), letoh32(cmd->cmd_par3));
@


1.59.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a146 11
const struct pci_matchid txp_devices[] = {
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990TX95 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990TX97 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990SVR95 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990SVR97 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C990BTXM },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C990BSVR },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990FX },
};

d152 16
a167 2
	return (pci_matchbyid((struct pci_attach_args *)aux, txp_devices,
	    sizeof(txp_devices)/sizeof(txp_devices[0])));
@


1.58
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.57 2001/11/02 19:31:00 jason Exp $	*/
d76 1
a76 1
#include <vm/vm.h>              /* for vtophys */
@


1.57
log
@- Set valid bit in transmit descriptors and tx fragment descriptors (previous
firmware versions didn't use it, but newer ones might... play it safe).
- add a bit of debugging code to tx so I can get dumps easier to send to 3com.
(ifdef'd out).
- ifdef both places that require modification to enable TX cksums to avoid
errors like halfway enabling them (which caused me a bit of pain the
other day).
- TX UDP/TCP cksums still hang the firmware
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.56 2001/09/21 17:55:44 miod Exp $	*/
d515 1
a515 1
	txp_bus_dmamap_sync(sc->sc_dmat, dma.dma_map, 0,
d531 1
a531 1
	txp_bus_dmamap_sync(sc->sc_dmat, dma.dma_map, 0,
d556 1
a556 1
	txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
d583 1
a583 1
	txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
d614 1
a614 1
		txp_bus_dmamap_sync(sc->sc_dmat, dma->dma_map,
d628 1
a628 1
		txp_bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
d704 1
a704 1
		txp_bus_dmamap_sync(sc->sc_dmat, dma->dma_map,
d765 1
a765 1
		txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_rxbufring_dma.dma_map,
d777 1
a777 1
		txp_bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
d780 1
a780 1
		txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_rxbufring_dma.dma_map,
d820 1
a820 1
		txp_bus_dmamap_sync(sc->sc_dmat, dma->dma_map,
d827 1
a827 1
			txp_bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
d962 1
a962 1
	txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_rxhiring_dma.dma_map,
d979 1
a979 1
	txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_rxloring_dma.dma_map,
d1047 1
a1047 1
		txp_bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
d1058 1
a1058 1
	txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_rxbufring_dma.dma_map,
d1417 1
a1417 1
		txp_bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
d1423 1
a1423 1
				txp_bus_dmamap_sync(sc->sc_dmat, sd->sd_map,
d1441 1
a1441 1
			txp_bus_dmamap_sync(sc->sc_dmat,
d1462 1
a1462 1
		txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_txhiring_dma.dma_map,
d1578 1
a1578 1
	txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
d1585 1
a1585 1
		txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
d1595 1
a1595 1
		txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
@


1.56
log
@Correct some pryntf() usage: get the correct number of arguments in the
correct order.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.55 2001/09/11 20:05:25 miod Exp $	*/
d89 7
d1331 1
d1382 1
a1382 1

d1387 1
a1387 1
		txd->tx_totlen = 0;
d1408 1
a1408 1
#if 0
d1411 2
d1417 2
a1418 3
		txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_txhiring_dma.dma_map,
		    prod * sizeof(struct txp_tx_desc), sizeof(struct txp_tx_desc),
		    BUS_DMASYNC_PREWRITE);
d1422 4
a1425 1
			if (++cnt >= (TX_ENTRIES - 4))
d1427 1
d1429 2
a1430 1
			fxd->frag_flags = FRAG_FLAGS_TYPE_FRAG;
d1461 23
a1483 2
		txp_bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
		    sd->sd_map->dm_mapsize, BUS_DMASYNC_PREWRITE);
d1632 2
a1633 1
			printf("%s: response error!\n", TXP_DEVNAME(sc));
d1994 2
a1995 1
#if 0
a1996 3
#endif
		sc->sc_rx_capability |= OFFLOAD_TCPCKSUM;
#if 0
d2002 2
a2003 1
#if 0
a2004 3
#endif
		sc->sc_rx_capability |= OFFLOAD_UDPCKSUM;
#if 0
@


1.55
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.54 2001/08/27 22:06:52 jason Exp $	*/
d394 1
a394 1
		printf(": fw wait failed, initial\n");
d441 1
a441 1
		printf(": fw wait failed comm0\n", sc->sc_dev.dv_xname);
d449 1
a449 1
		printf(": fw not waiting for segment\n", sc->sc_dev.dv_xname);
d519 2
a520 1
		printf(": fw wait failed, section %d\n", sectnum);
@


1.54
log
@get direction of read/write correct in calls to bus_dmamap_sync()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.53 2001/08/25 10:13:29 art Exp $	*/
a76 1
#include <vm/vm_kern.h>
@


1.53
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.52 2001/08/24 21:11:14 jason Exp $	*/
d510 1
a510 1
	    dma.dma_map->dm_mapsize, BUS_DMASYNC_PREREAD);
d525 1
a525 1
	    dma.dma_map->dm_mapsize, BUS_DMASYNC_POSTREAD);
d609 1
a609 1
		    BUS_DMASYNC_POSTWRITE);
d622 1
a622 1
		    sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
d699 1
a699 1
		    BUS_DMASYNC_PREWRITE);
d760 1
a760 1
		    sizeof(struct txp_rxbuf_desc), BUS_DMASYNC_POSTREAD);
d771 1
a771 1
		    sd->sd_map->dm_mapsize, BUS_DMASYNC_PREWRITE);
d775 1
a775 1
		    sizeof(struct txp_rxbuf_desc), BUS_DMASYNC_PREREAD);
d816 1
a816 1
		    BUS_DMASYNC_POSTREAD);
d821 1
a821 1
			    sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTREAD);
d956 1
a956 1
	    0, sc->sc_rxhiring_dma.dma_map->dm_mapsize, BUS_DMASYNC_PREWRITE);
d973 1
a973 1
	    0, sc->sc_rxloring_dma.dma_map->dm_mapsize, BUS_DMASYNC_PREWRITE);
d1041 1
a1041 1
		    sd->sd_map->dm_mapsize, BUS_DMASYNC_PREWRITE);
d1053 1
a1053 1
	    BUS_DMASYNC_PREREAD);
d1409 1
a1409 1
		    BUS_DMASYNC_PREREAD);
d1430 1
a1430 1
			    sizeof(struct txp_frag_desc), BUS_DMASYNC_PREREAD);
d1448 1
a1448 1
		    sd->sd_map->dm_mapsize, BUS_DMASYNC_PREREAD);
d1544 1
a1544 1
	    sizeof(struct txp_hostvar), BUS_DMASYNC_PREWRITE);
d1551 1
a1551 1
		    sizeof(struct txp_hostvar), BUS_DMASYNC_POSTWRITE);
d1561 1
a1561 1
		    sizeof(struct txp_hostvar), BUS_DMASYNC_PREWRITE);
@


1.52
log
@missing bus_dmamap_sync() calls on descriptors... also deal with 5 argument form of bus_dmamap_sync()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.51 2001/08/17 00:01:46 jason Exp $	*/
d204 1
a204 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.51
log
@Oops, maxseglen and maxlen were backwards in call to bus_dmamap_create().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.50 2001/08/12 20:03:49 mickey Exp $	*/
d127 2
a128 1
void txp_tx_reclaim __P((struct txp_softc *, struct txp_tx_ring *));
d130 2
a131 1
void txp_rx_reclaim __P((struct txp_softc *, struct txp_rx_ring *));
d510 2
a511 1
	bus_dmamap_sync(sc->sc_dmat, dma.dma_map, BUS_DMASYNC_PREREAD);
d525 2
a526 1
	bus_dmamap_sync(sc->sc_dmat, dma.dma_map, BUS_DMASYNC_POSTREAD);
d550 3
d559 1
a559 1
			txp_rx_reclaim(sc, &sc->sc_rxhir);
d561 1
a561 1
			txp_rx_reclaim(sc, &sc->sc_rxlor);
d568 1
a568 1
			txp_tx_reclaim(sc, &sc->sc_txhir);
d572 1
a572 1
			txp_tx_reclaim(sc, &sc->sc_txlor);
d577 3
d589 1
a589 1
txp_rx_reclaim(sc, r)
d592 1
d599 1
a599 1
	int sumflags = 0;
d603 2
a604 1
	rxd = r->r_desc + (roff / sizeof(struct txp_rx_desc));
d607 5
d622 2
a623 2
		bus_dmamap_sync(sc->sc_dmat, sd->sd_map,
		    BUS_DMASYNC_POSTWRITE);
d698 3
d704 1
d707 2
a708 1
		} else
d710 1
a757 1
		bus_dmamap_sync(sc->sc_dmat, sd->sd_map, BUS_DMASYNC_PREWRITE);
d759 4
d771 7
d798 1
a798 1
txp_tx_reclaim(sc, r)
d801 1
d814 5
d821 2
a822 2
			bus_dmamap_sync(sc->sc_dmat, sd->sd_map,
			    BUS_DMASYNC_POSTREAD);
d956 2
d973 2
d1041 2
a1042 1
		bus_dmamap_sync(sc->sc_dmat, sd->sd_map, BUS_DMASYNC_PREWRITE);
d1052 3
d1382 1
d1408 4
a1416 2
			txd->tx_numdesc++;

d1428 5
d1448 2
a1449 1
		bus_dmamap_sync(sc->sc_dmat, sd->sd_map, BUS_DMASYNC_PREREAD);
d1544 2
d1551 2
d1561 2
@


1.50
log
@remove redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.49 2001/08/10 15:58:49 jason Exp $	*/
d876 2
a877 2
		if (bus_dmamap_create(sc->sc_dmat, TXP_MAX_SEGLEN,
		    TX_ENTRIES - 4, TXP_MAX_PKTLEN, 0,
@


1.49
log
@allocate tx dma maps in attach instead of creating/destroying them for each tx
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.48 2001/06/27 06:34:50 kjc Exp $	*/
a76 1
#include <vm/pmap.h>            /* for vtophys */
a77 1
#include <vm/vm_extern.h>
@


1.48
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.47 2001/06/24 22:58:01 fgsch Exp $	*/
a786 1
			bus_dmamap_destroy(sc->sc_dmat, sd->sd_map);
d840 1
a840 1
	int i;
d877 12
a1304 5
		if (bus_dmamap_create(sc->sc_dmat, TXP_MAX_SEGLEN,
		    TX_ENTRIES - 4, TXP_MAX_PKTLEN, 0,
		    BUS_DMA_NOWAIT, &sd->sd_map))
			goto oactive1;

d1309 1
a1309 1
				goto oactive2;
d1314 1
a1314 1
					goto oactive2;
d1323 1
a1323 1
				goto oactive2;
a1404 2
oactive2:
	bus_dmamap_destroy(sc->sc_dmat, sd->sd_map);
@


1.47
log
@- vlan_input_tag() takes 2 args now.
- use ether_input_mbuf().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.46 2001/06/23 22:56:51 jason Exp $	*/
d273 2
a274 1
	ifp->if_snd.ifq_maxlen = TX_ENTRIES;
d1284 1
a1284 1
		IF_DEQUEUE(&ifp->if_snd, m);
@


1.46
log
@ether_input_mbuf()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.45 2001/06/23 20:54:15 jason Exp $	*/
d673 1
a673 5
			struct ether_header *eh;

			eh = mtod(m, struct ether_header *);
			m_adj(m, sizeof(struct ether_header));
			if (vlan_input_tag(eh, m, htons(rxd->rx_vlan >> 16)) < 0)
@


1.45
log
@Go ahead and add the output checksum handling for tcp/udp (commented out)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.44 2001/06/23 04:44:25 jason Exp $	*/
a585 1
	struct ether_header *eh;
a613 2
		eh = mtod(m, struct ether_header *);

a653 2
		m_adj(m, sizeof(struct ether_header));

d673 4
d683 1
a683 1
		ether_input(ifp, eh, m);
@


1.44
log
@IPv4 transmit checksum offload handling
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.43 2001/06/23 04:20:42 jason Exp $	*/
d1353 6
@


1.43
log
@- Add IPv4, UDP, and TCP RX checksum offloading support
- Do not enable IPSEC offloading (don't know how that got there =)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.42 2001/06/22 14:39:20 deraadt Exp $	*/
d1351 3
d1878 1
a1886 1
#if 0
a1887 1
#endif
a1888 1
#if 0
a1889 1
#endif
@


1.42
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.41 2001/06/12 15:40:31 niklas Exp $	*/
d590 1
d659 17
d1874 1
d1880 1
d1882 1
a1883 2
	/* not supported, yet */
	if (rsp->rsp_par2 & rsp->rsp_par3 & OFFLOAD_IPCKSUM) {
d1885 1
d1887 1
d1889 1
d1893 1
d1895 1
d1897 1
d1899 1
d1903 1
d1905 1
d1907 1
d1909 1
a1910 1
#endif
@


1.41
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.40 2001/06/05 02:15:19 jason Exp $	*/
d1063 1
a1063 1
        int r;
@


1.40
log
@updated firmware from 3com (Thanks!); contains support for 3cr990B cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.39 2001/05/30 14:41:59 jason Exp $	*/
d194 1
a194 1
	    &sc->sc_bt, &sc->sc_bh, NULL, &iosize)) {
@


1.39
log
@- gather statistics (ipackets, ierrors, collisions, etc) from txp itself
- better spl handling
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.38 2001/05/30 05:30:17 jason Exp $	*/
a89 1
#define u32 u_int32_t
a90 1
#undef u32
@


1.38
log
@define txp_command() in terms of txp_command2().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.37 2001/05/30 04:49:32 jason Exp $	*/
a616 1
		ifp->if_ipackets++;
d1118 1
a1118 1
	s = splimp();
d1186 1
a1186 1
	s = splimp();
d1215 3
d1220 1
a1220 1
	s = splimp();
d1222 25
a1247 1
	splx(s);
a1520 2
			printf("%s: stats\n", TXP_DEVNAME(sc));
			break;
@


1.37
log
@expand txp_command2 to handle extension desciptors for long commands
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.36 2001/05/30 04:26:55 jason Exp $	*/
a1370 2
	struct txp_hostvar *hv = sc->sc_hostvar;
	struct txp_cmd_desc *cmd;
a1371 2
	u_int32_t idx, i;
	u_int16_t seq;
d1373 1
a1373 2
	if (txp_cmd_desc_numfree(sc) == 0) {
		printf("%s: no free cmd descriptors\n", TXP_DEVNAME(sc));
a1374 21
	}

	idx = sc->sc_cmdring.lastwrite;
	cmd = (struct txp_cmd_desc *)(((u_int8_t *)sc->sc_cmdring.base) + idx);
	bzero(cmd, sizeof(*cmd));

	cmd->cmd_numdesc = 0;
	cmd->cmd_seq = seq = sc->sc_seq++;
	cmd->cmd_id = id;
	cmd->cmd_par1 = in1;
	cmd->cmd_par2 = in2;
	cmd->cmd_par3 = in3;
	cmd->cmd_flags = CMD_FLAGS_TYPE_CMD |
	    (wait ? CMD_FLAGS_RESP : 0) | CMD_FLAGS_VALID;

	idx += sizeof(struct txp_cmd_desc);
	if (idx == sc->sc_cmdring.size)
		idx = 0;
	sc->sc_cmdring.lastwrite = idx;

	WRITE_REG(sc, TXP_H2A_2, sc->sc_cmdring.lastwrite);
a1378 18
	for (i = 0; i < 10000; i++) {
		idx = hv->hv_resp_read_idx;
		if (idx != hv->hv_resp_write_idx) {
			rsp = NULL;
			if (txp_response(sc, idx, cmd->cmd_id, seq, &rsp))
				return (-1);
			if (rsp != NULL)
				break;
		}
		DELAY(50);
	}
	if (i == 1000 || rsp == NULL) {
		printf("%s: 0x%x command failed\n", TXP_DEVNAME(sc), id);
		if (rsp != NULL)
			free(rsp, M_DEVBUF);
		return (-1);
	}

a1384 1

a1385 1

d1447 1
a1447 1
			if (txp_response(sc, idx, cmd->cmd_id, seq, rspp))
@


1.36
log
@- better handling for capabilities: check the card to make sure it supports
IPsec offloading before claiming to have that capability.
- also add cksum offload capabilities (commented out for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.35 2001/05/29 01:01:51 angelos Exp $	*/
d119 3
a121 2
int txp_command2 __P((struct txp_softc *, u_int16_t, u_int16_t, u_int32_t,
    u_int32_t, struct txp_rsp_desc **, int));
d1436 1
a1436 1
txp_command2(sc, id, in1, in2, in3, rspp, wait)
d1440 2
d1447 1
d1451 1
a1451 1
	if (txp_cmd_desc_numfree(sc) == 0) {
d1460 1
a1460 1
	cmd->cmd_numdesc = 0;
d1472 10
d1861 1
a1861 1
	if (txp_command2(sc, TXP_CMD_OFFLOAD_READ, 0, 0, 0, &rsp, 1))
d1868 2
a1869 2
	sc->sc_tx_capability = ext->ext_1 & 0xfffffffe;
	sc->sc_rx_capability = ext->ext_2 & 0xfffffffe;
@


1.35
log
@Set, don't OR the capabilities.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.34 2001/05/28 10:32:23 angelos Exp $	*/
d125 1
a125 1
void txp_vlan_enable __P((struct txp_softc *));
a241 4
#if NVLAN > 0
	txp_vlan_enable(sc);
#endif

d275 1
a275 1
	ifp->if_capabilities = IFCAP_IPSEC;
d278 2
d1840 1
a1840 1
txp_vlan_enable(sc)
d1843 1
a1846 8
	/* Setup type filter */
	if (txp_command(sc, TXP_CMD_VLAN_ETHER_TYPE_WRITE, ETHERTYPE_8021Q,
	    0, 0, NULL, NULL, NULL, 1))
		goto out;

	/*
	 * Try to enable VLAN offload capability
	 */
d1854 39
d1894 1
a1894 3
	    (ext->ext_1 | OFFLOAD_VLAN) & rsp->rsp_par2,
	    (ext->ext_2 | OFFLOAD_VLAN) & rsp->rsp_par3,
	    NULL, NULL, NULL, 1))
@


1.34
log
@Set the IFCAP_IPSEC capability.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.33 2001/05/25 10:04:54 deraadt Exp $	*/
d279 1
a279 1
	ifp->if_capabilities |= IFCAP_IPSEC;
@


1.33
log
@we just *love it* when official people at major vendors send us
accurate information about upcoming models of their cards
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.32 2001/05/16 14:34:29 fgsch Exp $	*/
d279 1
@


1.32
log
@Use dm_mapsize instead of homegrown one; jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.31 2001/05/16 02:47:49 jason Exp $	*/
d157 2
@


1.31
log
@update copyright
use bcmp not strncmp for verifying the magic number in the firmware
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.30 2001/05/16 02:01:16 jason Exp $	*/
a1082 1
	dma->dma_size = size;
d1101 2
a1103 2
	bus_dmamem_unmap(sc->sc_dmat, dma->dma_vaddr, dma->dma_size);
	bus_dmamem_free(sc->sc_dmat, &dma->dma_seg, dma->dma_nseg);
@


1.30
log
@If we run out of transmit slots, try to copy the next mbuf into a single
fragment and try again.  Failing that, operate as normal.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.29 2001/05/15 14:57:28 jason Exp $	*/
d5 1
a5 1
 *	Jason L. Wright <jason@@thought.net> and
d18 2
a19 2
 *	This product includes software developed by Jason L. Wright and
 *	Aaron Campbell.
d385 1
a385 1
	if (strncmp("TYPHOON", fileheader->magicid, sizeof(fileheader->magicid))) {
@


1.29
log
@- correct some bus_dmamap_sync() usage
- redo dma_alloc(), dma_free() a bit (I had them right to begin with)
- add an alignment shim on rx buffers on strict alignment arch's (this is
hideous, but hopefully temporary)
Upshot: works on alpha now
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.28 2001/05/15 05:18:13 jason Exp $	*/
d1231 1
a1231 1
	struct mbuf *m;
d1261 19
a1279 4
		    BUS_DMA_NOWAIT))
			goto oactive2;

		/* XXX should copy if it doesn't currently fit. */
@


1.28
log
@- bus-dmaify txp
- use symbolic name instead of value for maximum packet length
- make this compile on alpha (be careful with pointers stored in device descriptors)
- fix a mbuf leak in the tx full case
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.27 2001/05/10 00:44:33 jason Exp $	*/
d509 1
a509 2
	bus_dmamap_sync(sc->sc_dmat, dma.dma_map,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
a520 1
		goto bail;
d523 1
a523 2
	bus_dmamap_sync(sc->sc_dmat, dma.dma_map,
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
d617 32
d1066 8
d1076 1
a1076 17
		return (r);

	if ((r = bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE, 0,
	    dma->dma_map->dm_segs, dma->dma_map->dm_nsegs,
	    &dma->dma_map->dm_nsegs, BUS_DMA_NOWAIT)) != 0) {
		bus_dmamap_destroy(sc->sc_dmat, dma->dma_map);
		return (r);
	}

	if ((r = bus_dmamem_map(sc->sc_dmat, dma->dma_map->dm_segs,
	    dma->dma_map->dm_nsegs, size, &dma->dma_vaddr,
	    mapflags | BUS_DMA_NOWAIT)) != 0) {
		bus_dmamem_free(sc->sc_dmat, dma->dma_map->dm_segs,
		    dma->dma_map->dm_nsegs);
		bus_dmamap_destroy(sc->sc_dmat, dma->dma_map);
		return (r);
	}
d1079 2
a1080 6
	    size, NULL, BUS_DMA_NOWAIT)) != 0) {
		bus_dmamem_unmap(sc->sc_dmat, dma->dma_vaddr, size);
		bus_dmamem_free(sc->sc_dmat, dma->dma_map->dm_segs, dma->dma_map->dm_nsegs);
		bus_dmamap_destroy(sc->sc_dmat, dma->dma_map);
		return (r);
	}
d1083 2
d1086 8
a1093 1
	return (0);
a1100 2
	bus_dmamem_unmap(sc->sc_dmat, dma->dma_vaddr, dma->dma_map->dm_mapsize);
	bus_dmamem_free(sc->sc_dmat, dma->dma_map->dm_segs, dma->dma_map->dm_nsegs);
d1103 2
@


1.27
log
@in txp_intr() only refill the rx buffer ring if it is empty; based on
suggestion from Pankaj Chhabra.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.26 2001/05/09 02:25:08 jason Exp $	*/
d230 1
a230 1
	if (txp_command(sc, TXP_CMD_MAX_PKT_SIZE_WRITE, 0x800, 0, 0,
d591 1
d606 9
a614 1
		m = (struct mbuf *)rxd->rx_vaddrlo;
d661 1
a661 1
	struct mbuf *m;
d673 3
a675 6
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL)
			break;
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			m_freem(m);
d677 17
d695 1
a695 1
		m->m_pkthdr.rcvif = ifp;
d697 7
a703 4
		rbd->rb_vaddrlo = (u_int32_t)m;
		rbd->rb_vaddrhi = 0;
		rbd->rb_paddrlo = vtophys(m->m_data);
		rbd->rb_paddrhi = 0;
d713 6
d733 1
d742 5
a746 1
			m = (struct mbuf *)txd->tx_addrlo;
d759 2
a760 1
		} else
d762 2
d797 1
d922 4
a925 1
		struct mbuf *m;
d927 14
a940 4
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL) {
			printf(": rxbuf allocation failed\n");
			goto bail_rspring;
d942 4
a945 5
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			printf(": rxbuf cluster allocation failed\n");
			m_freem(m);
			goto bail_rspring;
d947 9
a955 5
		m->m_pkthdr.rcvif = ifp;
		sc->sc_rxbufs[i].rb_vaddrlo = (u_int32_t)m;
		sc->sc_rxbufs[i].rb_vaddrhi = 0;
		sc->sc_rxbufs[i].rb_paddrlo = vtophys(m->m_data);
		sc->sc_rxbufs[i].rb_paddrhi = 0;
d1205 3
a1207 2
	struct mbuf *mhead, *m;
	u_int32_t firstprod, firstcnt, prod, cnt;
a1221 6
		mhead = m;

		if ((TX_ENTRIES - cnt) < 4) {
			ifp->if_flags |= IFF_OACTIVE;
			break;
		}
d1226 11
a1236 1
		txd = r->r_desc + prod;
d1238 1
a1238 2
		if (++prod == TX_ENTRIES)
			prod = 0;
d1240 1
a1240 1
		if (++cnt >= (TX_ENTRIES - 4))
d1243 2
d1247 1
a1247 1
		txd->tx_addrlo = (u_int32_t)m;
d1252 6
d1268 1
a1268 6
		while (m != NULL) {
			if (m->m_len == 0) {
				m = m->m_next;
				continue;
			}

d1276 7
a1282 3
			fxd->frag_len = m->m_len;
			fxd->frag_addrlo = vtophys(m->m_data);
			fxd->frag_addrhi = 0;
a1283 1
			m = m->m_next;
d1297 1
a1297 1
			bpf_mtap(ifp->if_bpf, mhead);
d1300 1
d1309 4
d1316 1
@


1.27.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.20 2001/04/15 22:47:38 jason Exp $	*/
d119 2
d123 3
a125 1
void txp_rsp_fixup __P((struct txp_softc *, struct txp_rsp_desc *));
d240 4
d539 1
d560 2
a561 1
		txp_rxbuf_reclaim(sc);
d621 8
d776 1
a776 1
	bzero(sc->sc_host_dma.dma_vaddr, sc->sc_host_dma.dma_siz);
d787 1
a787 1
	bzero(sc->sc_txhiring_dma.dma_vaddr, sc->sc_txhiring_dma.dma_siz);
d802 1
a802 1
	bzero(sc->sc_txloring_dma.dma_vaddr, sc->sc_txloring_dma.dma_siz);
d817 1
a817 1
	bzero(sc->sc_rxhiring_dma.dma_vaddr, sc->sc_rxhiring_dma.dma_siz);
d832 1
a832 1
	bzero(sc->sc_rxloring_dma.dma_vaddr, sc->sc_rxloring_dma.dma_siz);
d847 1
a847 1
	bzero(sc->sc_cmdring_dma.dma_vaddr, sc->sc_cmdring_dma.dma_siz);
d861 1
a861 1
	bzero(sc->sc_rspring_dma.dma_vaddr, sc->sc_rspring_dma.dma_siz);
d875 1
a875 1
	bzero(sc->sc_rxbufring_dma.dma_vaddr, sc->sc_rxbufring_dma.dma_siz);
d909 1
a909 1
	bzero(sc->sc_zero_dma.dma_vaddr, sc->sc_zero_dma.dma_siz);
d980 4
d985 3
a987 11
	    &dma->dma_seg, 1, &dma->dma_nseg, BUS_DMA_NOWAIT)) != 0) {
		return (r);
	}
	if (dma->dma_nseg != 1) {
		bus_dmamem_free(sc->sc_dmat, &dma->dma_seg, dma->dma_nseg);
		return (-1);
	}
	   
	if ((r = bus_dmamem_map(sc->sc_dmat, &dma->dma_seg, dma->dma_nseg,
	    size, &dma->dma_vaddr, mapflags | BUS_DMA_NOWAIT)) != 0) {
		bus_dmamem_free(sc->sc_dmat, &dma->dma_seg, dma->dma_nseg);
d991 6
a996 4
	if ((r = bus_dmamap_create(sc->sc_dmat, size, dma->dma_nseg,
	    size, 0, BUS_DMA_NOWAIT, &dma->dma_map)) != 0) {
		bus_dmamem_unmap(sc->sc_dmat, dma->dma_vaddr, size);
		bus_dmamem_free(sc->sc_dmat, &dma->dma_seg, dma->dma_nseg);
d1002 2
a1004 2
		bus_dmamem_unmap(sc->sc_dmat, dma->dma_vaddr, size);
		bus_dmamem_free(sc->sc_dmat, &dma->dma_seg, dma->dma_nseg);
a1008 1
	dma->dma_siz = size;
d1018 2
a1021 2
	bus_dmamem_unmap(sc->sc_dmat, dma->dma_vaddr, dma->dma_siz);
	bus_dmamem_free(sc->sc_dmat, &dma->dma_seg, dma->dma_nseg);
d1148 1
a1148 1
	struct mbuf *m;
d1150 3
d1164 1
d1189 9
d1227 6
d1247 1
a1247 1
 * XXX this needs to have a callback mechanism
d1303 2
d1315 38
a1352 2
	idx += sizeof(struct txp_rsp_desc);
	if (idx == sc->sc_rspring.size)
d1354 22
a1375 1
	sc->sc_rspring.lastwrite = hv->hv_resp_read_idx = idx;
d1395 6
a1400 1
			*rspp = rsp;
d1406 1
a1406 1
			txp_rsp_fixup(sc, rsp);
d1425 1
a1425 1
		txp_rsp_fixup(sc, rsp);
d1434 1
a1434 1
txp_rsp_fixup(sc, rsp)
d1436 1
a1436 1
	struct txp_rsp_desc *rsp;
d1438 1
d1445 2
d1448 2
a1449 1
		if (ridx == sc->sc_rspring.size)
d1451 2
d1654 1
a1654 1
	u_int16_t filter = 0;
d1660 5
d1666 7
a1672 5
	if (ifp->if_flags & IFF_PROMISC)
		filter = TXP_RXFILT_PROMISC;
	else if (ifp->if_flags & IFF_ALLMULTI)
		filter = TXP_RXFILT_DIRECT | TXP_RXFILT_ALLMULTI |
		    TXP_RXFILT_BROADCAST;
a1673 1
		filter = TXP_RXFILT_DIRECT | TXP_RXFILT_BROADCAST;
d1680 1
d1720 1
d1723 33
@


1.27.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.27.2.1 2001/05/14 22:25:48 niklas Exp $	*/
d5 1
a5 1
 *	Jason L. Wright <jason@@thought.net>, Theo de Raadt, and
d18 2
a19 2
 *	This product includes software developed by Jason L. Wright,
 *	Theo de Raadt and Aaron Campbell.
d90 1
d92 1
a118 3
int txp_command2 __P((struct txp_softc *, u_int16_t, u_int16_t,
    u_int32_t, u_int32_t, struct txp_ext_desc *, u_int8_t,
    struct txp_rsp_desc **, int));
d121 1
a121 3
void txp_rsp_fixup __P((struct txp_softc *, struct txp_rsp_desc *,
    struct txp_rsp_desc *));
void txp_capabilities __P((struct txp_softc *));
a152 2
	case PCI_PRODUCT_3COM_3C990BTXM:
	case PCI_PRODUCT_3COM_3C990BSVR:
d189 1
a189 1
	    &sc->sc_bt, &sc->sc_bh, NULL, &iosize, 0)) {
d226 1
a226 1
	if (txp_command(sc, TXP_CMD_MAX_PKT_SIZE_WRITE, TXP_MAX_PKTLEN, 0, 0,
d268 1
a268 3
	IFQ_SET_MAXLEN(&ifp->if_snd, TX_ENTRIES);
	IFQ_SET_READY(&ifp->if_snd);
	ifp->if_capabilities = 0;
a270 2
	txp_capabilities(sc);

d377 1
a377 1
	if (bcmp("TYPHOON", fileheader->magicid, sizeof(fileheader->magicid))) {
d501 2
a502 1
	bus_dmamap_sync(sc->sc_dmat, dma.dma_map, BUS_DMASYNC_PREREAD);
d514 1
d517 2
a518 1
	bus_dmamap_sync(sc->sc_dmat, dma.dma_map, BUS_DMASYNC_POSTREAD);
a530 1
	struct txp_hostvar *hv = sc->sc_hostvar;
d551 1
a551 2
		if (hv->hv_rx_buf_write_idx == hv->hv_rx_buf_read_idx)
			txp_rxbuf_reclaim(sc);
d579 1
a580 1
	struct txp_swdesc *sd;
a581 1
	int sumflags = 0;
d595 1
a595 9
		/* retrieve stashed pointer */
		bcopy((u_long *)&rxd->rx_vaddrlo, &sd, sizeof(sd));

		bus_dmamap_sync(sc->sc_dmat, sd->sd_map,
		    BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, sd->sd_map);
		bus_dmamap_destroy(sc->sc_dmat, sd->sd_map);
		m = sd->sd_mbuf;
		free(sd, M_DEVBUF);
d598 2
a599 31
#ifdef __STRICT_ALIGNMENT
		{
			/*
			 * XXX Nice chip, except it won't accept "off by 2"
			 * buffers, so we're force to copy.  Supposedly
			 * this will be fixed in a newer firmware rev
			 * and this will be temporary.
			 */
			struct mbuf *mnew;

			MGETHDR(mnew, M_DONTWAIT, MT_DATA);
			if (mnew == NULL) {
				m_freem(m);
				goto next;
			}
			if (m->m_len > (MHLEN - 2)) {
				MCLGET(mnew, M_DONTWAIT);
				if (!(mnew->m_flags & M_EXT)) {
					m_freem(mnew);
					m_freem(m);
					goto next;
				}
			}
			mnew->m_pkthdr.rcvif = ifp;
			mnew->m_pkthdr.len = mnew->m_len = m->m_len;
			mnew->m_data += 2;
			bcopy(m->m_data, mnew->m_data, m->m_len);
			m_freem(m);
			m = mnew;
		}
#endif
d609 1
a609 24
		if (rxd->rx_stat & RX_STAT_IPCKSUMBAD)
			sumflags |= M_IPV4_CSUM_IN_BAD;
		else if (rxd->rx_stat & RX_STAT_IPCKSUMGOOD)
			sumflags |= M_IPV4_CSUM_IN_OK;

		if (rxd->rx_stat & RX_STAT_TCPCKSUMBAD)
			sumflags |= M_TCP_CSUM_IN_BAD;
		else if (rxd->rx_stat & RX_STAT_TCPCKSUMGOOD)
			sumflags |= M_TCP_CSUM_IN_OK;

		if (rxd->rx_stat & RX_STAT_UDPCKSUMBAD)
			sumflags |= M_UDP_CSUM_IN_BAD;
		else if (rxd->rx_stat & RX_STAT_UDPCKSUMGOOD)
			sumflags |= M_UDP_CSUM_IN_OK;

		m->m_pkthdr.csum = sumflags;

#if NVLAN > 0
		if (rxd->rx_stat & RX_STAT_VLAN) {
			if (vlan_input_tag(m, htons(rxd->rx_vlan >> 16)) < 0)
				ifp->if_noproto++;
			goto next;
		}
#endif
d611 1
a611 1
		ether_input_mbuf(ifp, m);
d634 1
a634 1
	struct txp_swdesc *sd;
d646 6
a651 3
		sd = (struct txp_swdesc *)malloc(sizeof(struct txp_swdesc),
		    M_DEVBUF, M_NOWAIT);
		if (sd == NULL)
a652 17

		MGETHDR(sd->sd_mbuf, M_DONTWAIT, MT_DATA);
		if (sd->sd_mbuf == NULL)
			goto err_sd;

		MCLGET(sd->sd_mbuf, M_DONTWAIT);
		if ((sd->sd_mbuf->m_flags & M_EXT) == 0)
			goto err_mbuf;
		sd->sd_mbuf->m_pkthdr.rcvif = ifp;
		sd->sd_mbuf->m_pkthdr.len = sd->sd_mbuf->m_len = MCLBYTES;
		if (bus_dmamap_create(sc->sc_dmat, TXP_MAX_PKTLEN, 1,
		    TXP_MAX_PKTLEN, 0, BUS_DMA_NOWAIT, &sd->sd_map))
			goto err_mbuf;
		if (bus_dmamap_load_mbuf(sc->sc_dmat, sd->sd_map, sd->sd_mbuf,
		    BUS_DMA_NOWAIT)) {
			bus_dmamap_destroy(sc->sc_dmat, sd->sd_map);
			goto err_mbuf;
d654 1
a654 4
		bus_dmamap_sync(sc->sc_dmat, sd->sd_map, BUS_DMASYNC_PREWRITE);

		/* stash away pointer */
		bcopy(&sd, (u_long *)&rbd->rb_vaddrlo, sizeof(sd));
d656 4
a659 4
		rbd->rb_paddrlo = ((u_int64_t)sd->sd_map->dm_segs[0].ds_addr)
		    & 0xffffffff;
		rbd->rb_paddrhi = ((u_int64_t)sd->sd_map->dm_segs[0].ds_addr)
		    >> 32;
a668 6
	return;

err_mbuf:
	m_freem(sd->sd_mbuf);
err_sd:
	free(sd, M_DEVBUF);
a682 1
	struct txp_swdesc *sd = sc->sc_txd + cons;
d691 1
a691 5
			bus_dmamap_sync(sc->sc_dmat, sd->sd_map,
			    BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->sc_dmat, sd->sd_map);
			bus_dmamap_destroy(sc->sc_dmat, sd->sd_map);
			m = sd->sd_mbuf;
d704 1
a704 2
			sd = sc->sc_txd;
		} else {
a705 2
			sd++;
		}
a738 1
	struct txp_swdesc *sd;
d758 1
a758 1
	bzero(sc->sc_host_dma.dma_vaddr, sizeof(struct txp_hostvar));
d769 1
a769 1
	bzero(sc->sc_txhiring_dma.dma_vaddr, sizeof(struct txp_tx_desc) * TX_ENTRIES);
d784 1
a784 1
	bzero(sc->sc_txloring_dma.dma_vaddr, sizeof(struct txp_tx_desc) * TX_ENTRIES);
d799 1
a799 1
	bzero(sc->sc_rxhiring_dma.dma_vaddr, sizeof(struct txp_rx_desc) * RX_ENTRIES);
d814 1
a814 1
	bzero(sc->sc_rxloring_dma.dma_vaddr, sizeof(struct txp_rx_desc) * RX_ENTRIES);
d829 1
a829 1
	bzero(sc->sc_cmdring_dma.dma_vaddr, sizeof(struct txp_cmd_desc) * CMD_ENTRIES);
d843 1
a843 1
	bzero(sc->sc_rspring_dma.dma_vaddr, sizeof(struct txp_rsp_desc) * RSP_ENTRIES);
d857 1
a857 1
	bzero(sc->sc_rxbufring_dma.dma_vaddr, sizeof(struct txp_rxbuf_desc) * RXBUF_ENTRIES);
d863 1
a863 4
		sd = (struct txp_swdesc *)malloc(sizeof(struct txp_swdesc),
		    M_DEVBUF, M_NOWAIT);
		if (sd == NULL)
			break;
d865 10
a874 19
		MGETHDR(sd->sd_mbuf, M_DONTWAIT, MT_DATA);
		if (sd->sd_mbuf == NULL) {
			goto bail_rxbufring;
		}

		MCLGET(sd->sd_mbuf, M_DONTWAIT);
		if ((sd->sd_mbuf->m_flags & M_EXT) == 0) {
			goto bail_rxbufring;
		}
		sd->sd_mbuf->m_pkthdr.len = sd->sd_mbuf->m_len = MCLBYTES;
		sd->sd_mbuf->m_pkthdr.rcvif = ifp;
		if (bus_dmamap_create(sc->sc_dmat, TXP_MAX_PKTLEN, 1,
		    TXP_MAX_PKTLEN, 0, BUS_DMA_NOWAIT, &sd->sd_map)) {
			goto bail_rxbufring;
		}
		if (bus_dmamap_load_mbuf(sc->sc_dmat, sd->sd_map, sd->sd_mbuf,
		    BUS_DMA_NOWAIT)) {
			bus_dmamap_destroy(sc->sc_dmat, sd->sd_map);
			goto bail_rxbufring;
d876 5
a880 9
		bus_dmamap_sync(sc->sc_dmat, sd->sd_map, BUS_DMASYNC_PREWRITE);

		/* stash away pointer */
		bcopy(&sd, (u_long *)&sc->sc_rxbufs[i].rb_vaddrlo, sizeof(sd));

		sc->sc_rxbufs[i].rb_paddrlo =
		    ((u_int64_t)sd->sd_map->dm_segs[0].ds_addr) & 0xffffffff;
		sc->sc_rxbufs[i].rb_paddrhi =
		    ((u_int64_t)sd->sd_map->dm_segs[0].ds_addr) >> 32;
d891 1
a891 1
	bzero(sc->sc_zero_dma.dma_vaddr, sizeof(u_int32_t));
d960 1
a960 1
	int r;
d963 8
a970 3
	    &dma->dma_seg, 1, &dma->dma_nseg, 0)) != 0)
		goto fail_0;

d972 4
a975 2
	    size, &dma->dma_vaddr, mapflags | BUS_DMA_NOWAIT)) != 0)
		goto fail_1;
d977 6
a982 3
	if ((r = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT, &dma->dma_map)) != 0)
		goto fail_2;
d985 6
a990 2
	    size, NULL, BUS_DMA_NOWAIT)) != 0)
		goto fail_3;
d993 2
a995 9

fail_3:
	bus_dmamap_destroy(sc->sc_dmat, dma->dma_map);
fail_2:
	bus_dmamem_unmap(sc->sc_dmat, dma->dma_vaddr, size);
fail_1:
	bus_dmamem_free(sc->sc_dmat, &dma->dma_seg, dma->dma_nseg);
fail_0:
	return (r);
d1004 2
a1005 1
	bus_dmamem_unmap(sc->sc_dmat, dma->dma_vaddr, dma->dma_map->dm_mapsize);
a1006 1
	bus_dmamap_destroy(sc->sc_dmat, dma->dma_map);
d1020 1
a1020 1
	s = splnet();
d1088 1
a1088 1
	s = splnet();
a1116 3
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct txp_rsp_desc *rsp = NULL;
	struct txp_ext_desc *ext;
d1119 1
a1119 1
	s = splnet();
d1121 1
a1121 24

	if (txp_command2(sc, TXP_CMD_READ_STATISTICS, 0, 0, 0, NULL, 0,
	    &rsp, 1))
		goto out;
	if (rsp->rsp_numdesc != 6)
		goto out;
	if (txp_command(sc, TXP_CMD_CLEAR_STATISTICS, 0, 0, 0,
	    NULL, NULL, NULL, 1))
		goto out;
	ext = (struct txp_ext_desc *)(rsp + 1);

	ifp->if_ierrors += ext[3].ext_2 + ext[3].ext_3 + ext[3].ext_4 +
	    ext[4].ext_1 + ext[4].ext_4;
	ifp->if_oerrors += ext[0].ext_1 + ext[1].ext_1 + ext[1].ext_4 +
	    ext[2].ext_1;
	ifp->if_collisions += ext[0].ext_2 + ext[0].ext_3 + ext[1].ext_2 +
	    ext[1].ext_3;
	ifp->if_opackets += rsp->rsp_par2;
	ifp->if_ipackets += ext[2].ext_3;

out:
	if (rsp != NULL)
		free(rsp, M_DEVBUF);

a1122 1
	timeout_add(&sc->sc_tick, hz);
d1133 2
a1134 6
	struct mbuf *m, *mnew;
	struct txp_swdesc *sd;
	u_int32_t firstprod, firstcnt, prod, cnt, i;
#if NVLAN > 0
	struct ifvlan		*ifv;
#endif
d1143 1
a1143 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
d1147 5
d1155 1
a1155 2
		sd = sc->sc_txd + prod;
		sd->sd_mbuf = m;
d1157 2
a1158 25
		if (bus_dmamap_create(sc->sc_dmat, TXP_MAX_SEGLEN,
		    TX_ENTRIES - 4, TXP_MAX_PKTLEN, 0,
		    BUS_DMA_NOWAIT, &sd->sd_map))
			goto oactive1;

		if (bus_dmamap_load_mbuf(sc->sc_dmat, sd->sd_map, m,
		    BUS_DMA_NOWAIT)) {
			MGETHDR(mnew, M_DONTWAIT, MT_DATA);
			if (mnew == NULL)
				goto oactive2;
			if (m->m_pkthdr.len > MHLEN) {
				MCLGET(mnew, M_DONTWAIT);
				if ((mnew->m_flags & M_EXT) == 0) {
					m_freem(mnew);
					goto oactive2;
				}
			}
			m_copydata(m, 0, m->m_pkthdr.len, mtod(mnew, caddr_t));
			mnew->m_pkthdr.len = mnew->m_len = m->m_pkthdr.len;
			m_freem(m);
			m = mnew;
			if (bus_dmamap_load_mbuf(sc->sc_dmat, sd->sd_map, m,
			    BUS_DMA_NOWAIT))
				goto oactive2;
		}
d1160 1
a1160 1
		if ((TX_ENTRIES - cnt) < 4)
a1162 2
		txd = r->r_desc + prod;

d1165 1
a1165 1
		txd->tx_addrlo = 0;
d1170 6
a1175 14
		if (++prod == TX_ENTRIES)
			prod = 0;

		if (++cnt >= (TX_ENTRIES - 4))
			goto oactive;

#if NVLAN > 0
		if ((m->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&
		    m->m_pkthdr.rcvif != NULL) {
			ifv = m->m_pkthdr.rcvif->if_softc;
			txd->tx_pflags = TX_PFLAGS_VLAN |
			    (htons(ifv->ifv_tag) << TX_PFLAGS_VLANTAG_S);
		}
#endif
a1176 11
		if (m->m_pkthdr.csum & M_IPV4_CSUM_OUT)
			txd->tx_pflags |= TX_PFLAGS_IPCKSUM;
#if 0
		if (m->m_pkthdr.csum & M_TCPV4_CSUM_OUT)
			txd->tx_pflags |= TX_PFLAGS_TCPCKSUM;
		if (m->m_pkthdr.csum & M_UDPV4_CSUM_OUT)
			txd->tx_pflags |= TX_PFLAGS_UDPCKSUM;
#endif

		fxd = (struct txp_frag_desc *)(r->r_desc + prod);
		for (i = 0; i < sd->sd_map->dm_nsegs; i++) {
d1184 3
a1186 7
			fxd->frag_len = sd->sd_map->dm_segs[i].ds_len;
			fxd->frag_addrlo =
			    ((u_int64_t)sd->sd_map->dm_segs[i].ds_addr) &
			    0xffffffff;
			fxd->frag_addrhi =
			    ((u_int64_t)sd->sd_map->dm_segs[i].ds_addr) >>
			    32;
d1188 1
a1198 7

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m);
#endif

		bus_dmamap_sync(sc->sc_dmat, sd->sd_map, BUS_DMASYNC_PREREAD);
a1206 4
	bus_dmamap_unload(sc->sc_dmat, sd->sd_map);
oactive2:
	bus_dmamap_destroy(sc->sc_dmat, sd->sd_map);
oactive1:
a1209 1
	IF_PREPEND(&ifp->if_snd, m);
d1213 1
a1213 1
 * Handle simple commands sent to the typhoon
a1221 28
	struct txp_rsp_desc *rsp = NULL;

	if (txp_command2(sc, id, in1, in2, in3, NULL, 0, &rsp, wait))
		return (-1);

	if (!wait)
		return (0);

	if (out1 != NULL)
		*out1 = rsp->rsp_par1;
	if (out2 != NULL)
		*out2 = rsp->rsp_par2;
	if (out3 != NULL)
		*out3 = rsp->rsp_par3;
	free(rsp, M_DEVBUF);
	return (0);
}

int
txp_command2(sc, id, in1, in2, in3, in_extp, in_extn, rspp, wait)
	struct txp_softc *sc;
	u_int16_t id, in1;
	u_int32_t in2, in3;
	struct txp_ext_desc *in_extp;
	u_int8_t in_extn;
	struct txp_rsp_desc **rspp;
	int wait;
{
d1224 1
a1224 1
	struct txp_ext_desc *ext;
d1228 1
a1228 1
	if (txp_cmd_desc_numfree(sc) < (in_extn + 1)) {
d1237 1
a1237 1
	cmd->cmd_numdesc = in_extn;
a1248 10

	for (i = 0; i < in_extn; i++) {
		ext = (struct txp_ext_desc *)(((u_int8_t *)sc->sc_cmdring.base) + idx);
		bcopy(in_extp, ext, sizeof(struct txp_ext_desc));
		in_extp++;
		idx += sizeof(struct txp_cmd_desc);
		if (idx == sc->sc_cmdring.size)
			idx = 0;
	}

d1259 2
a1260 2
			*rspp = NULL;
			if (txp_response(sc, idx, id, seq, rspp))
d1262 1
a1262 1
			if (*rspp != NULL)
d1267 1
a1267 1
	if (i == 1000 || (*rspp) == NULL) {
d1272 12
d1302 1
a1302 6
			*rspp = (struct txp_rsp_desc *)malloc(
			    sizeof(struct txp_rsp_desc) * (rsp->rsp_numdesc + 1),
			    M_DEVBUF, M_NOWAIT);
			if ((*rspp) == NULL)
				return (-1);
			txp_rsp_fixup(sc, rsp, *rspp);
d1308 1
a1308 1
			txp_rsp_fixup(sc, rsp, NULL);
d1315 2
d1327 1
a1327 1
		txp_rsp_fixup(sc, rsp, NULL);
d1336 1
a1336 1
txp_rsp_fixup(sc, rsp, dst)
d1338 1
a1338 1
	struct txp_rsp_desc *rsp, *dst;
a1339 1
	struct txp_rsp_desc *src = rsp;
a1345 2
		if (dst != NULL)
			bcopy(src, dst++, sizeof(struct txp_rsp_desc));
d1347 1
a1347 2
		if (ridx == sc->sc_rspring.size) {
			src = sc->sc_rspring.base;
a1348 2
		} else
			src++;
d1550 1
a1550 1
	u_int16_t filter;
d1556 2
a1557 1
	if (ifp->if_flags & IFF_PROMISC) {
d1559 3
a1561 11
		goto setit;
	}

again:
	filter = TXP_RXFILT_DIRECT;

	if (ifp->if_flags & IFF_BROADCAST)
		filter |= TXP_RXFILT_BROADCAST;

	if (ifp->if_flags & IFF_ALLMULTI)
		filter |= TXP_RXFILT_ALLMULTI;
d1563 1
a1569 1
				 * We must listen to a range of multicast
a1608 1
setit:
a1610 71
}

void
txp_capabilities(sc)
	struct txp_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct txp_rsp_desc *rsp = NULL;
	struct txp_ext_desc *ext;

	if (txp_command2(sc, TXP_CMD_OFFLOAD_READ, 0, 0, 0, NULL, 0, &rsp, 1))
		goto out;

	if (rsp->rsp_numdesc != 1)
		goto out;
	ext = (struct txp_ext_desc *)(rsp + 1);

	sc->sc_tx_capability = ext->ext_1 & OFFLOAD_MASK;
	sc->sc_rx_capability = ext->ext_2 & OFFLOAD_MASK;

#if NVLAN > 0
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
	if (rsp->rsp_par2 & rsp->rsp_par3 & OFFLOAD_VLAN) {
		sc->sc_tx_capability |= OFFLOAD_VLAN;
		sc->sc_rx_capability |= OFFLOAD_VLAN;
		ifp->if_capabilities |= IFCAP_VLAN_HWTAGGING;
	}
#endif

#if 0
	/* not ready yet */
	if (rsp->rsp_par2 & rsp->rsp_par3 & OFFLOAD_IPSEC) {
		sc->sc_tx_capability |= OFFLOAD_IPSEC;
		sc->sc_rx_capability |= OFFLOAD_IPSEC;
		ifp->if_capabilities |= IFCAP_IPSEC;
	}
#endif

	if (rsp->rsp_par2 & rsp->rsp_par3 & OFFLOAD_IPCKSUM) {
		sc->sc_tx_capability |= OFFLOAD_IPCKSUM;
		sc->sc_rx_capability |= OFFLOAD_IPCKSUM;
		ifp->if_capabilities |= IFCAP_CSUM_IPv4;
	}

	if (rsp->rsp_par2 & rsp->rsp_par3 & OFFLOAD_TCPCKSUM) {
#if 0
		sc->sc_tx_capability |= OFFLOAD_TCPCKSUM;
#endif
		sc->sc_rx_capability |= OFFLOAD_TCPCKSUM;
#if 0
		ifp->if_capabilities |= IFCAP_CSUM_TCPv4;
#endif
	}

	if (rsp->rsp_par2 & rsp->rsp_par3 & OFFLOAD_UDPCKSUM) {
#if 0
		sc->sc_tx_capability |= OFFLOAD_UDPCKSUM;
#endif
		sc->sc_rx_capability |= OFFLOAD_UDPCKSUM;
#if 0
		ifp->if_capabilities |= IFCAP_CSUM_UDPv4;
#endif
	}

	if (txp_command(sc, TXP_CMD_OFFLOAD_WRITE, 0,
	    sc->sc_tx_capability, sc->sc_rx_capability, NULL, NULL, NULL, 1))
		goto out;

out:
	if (rsp != NULL)
		free(rsp, M_DEVBUF);
@


1.27.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.27.2.2 2001/07/04 10:42:26 niklas Exp $	*/
d77 3
d129 1
a129 2
void txp_tx_reclaim __P((struct txp_softc *, struct txp_tx_ring *,
    struct txp_dma_alloc *));
d131 1
a131 2
void txp_rx_reclaim __P((struct txp_softc *, struct txp_rx_ring *,
    struct txp_dma_alloc *));
d204 2
a205 1
	if (pci_intr_map(pa, &ih)) {
d396 1
a396 1
		printf("%s: fw wait failed, initial\n", sc->sc_dev.dv_xname);
d443 1
a443 1
		printf(": fw wait failed comm0\n");
d451 1
a451 1
		printf(": fw not waiting for segment\n");
d510 1
a510 2
	txp_bus_dmamap_sync(sc->sc_dmat, dma.dma_map, 0,
	    dma.dma_map->dm_mapsize, BUS_DMASYNC_PREWRITE);
d520 1
a520 2
		printf("%s: fw wait failed, section %d\n",
		    sc->sc_dev.dv_xname, sectnum);
d524 1
a524 2
	txp_bus_dmamap_sync(sc->sc_dmat, dma.dma_map, 0,
	    dma.dma_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
a547 3
	txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
	    sizeof(struct txp_hostvar), BUS_DMASYNC_POSTWRITE|BUS_DMASYNC_POSTREAD);

d554 1
a554 1
			txp_rx_reclaim(sc, &sc->sc_rxhir, &sc->sc_rxhiring_dma);
d556 1
a556 1
			txp_rx_reclaim(sc, &sc->sc_rxlor, &sc->sc_rxloring_dma);
d563 1
a563 1
			txp_tx_reclaim(sc, &sc->sc_txhir, &sc->sc_txhiring_dma);
d567 1
a567 1
			txp_tx_reclaim(sc, &sc->sc_txlor, &sc->sc_txloring_dma);
a571 3
	txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
	    sizeof(struct txp_hostvar), BUS_DMASYNC_POSTWRITE|BUS_DMASYNC_POSTREAD);

d581 1
a581 1
txp_rx_reclaim(sc, r, dma)
a583 1
	struct txp_dma_alloc *dma;
d590 1
a590 1
	int sumflags = 0, idx;
d594 1
a594 2
	idx = roff / sizeof(struct txp_rx_desc);
	rxd = r->r_desc + idx;
a596 5

		txp_bus_dmamap_sync(sc->sc_dmat, dma->dma_map,
		    idx * sizeof(struct txp_rx_desc), sizeof(struct txp_rx_desc),
		    BUS_DMASYNC_POSTREAD);

d607 2
a608 2
		txp_bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
		    sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTREAD);
a682 3
		txp_bus_dmamap_sync(sc->sc_dmat, dma->dma_map,
		    idx * sizeof(struct txp_rx_desc), sizeof(struct txp_rx_desc),
		    BUS_DMASYNC_PREREAD);
a685 1
			idx = 0;
d688 1
a688 2
		} else {
			idx++;
a689 1
		}
d737 1
a738 4
		txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_rxbufring_dma.dma_map,
		    i * sizeof(struct txp_rxbuf_desc),
		    sizeof(struct txp_rxbuf_desc), BUS_DMASYNC_POSTWRITE);
		    
a746 7
		txp_bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
		    sd->sd_map->dm_mapsize, BUS_DMASYNC_PREREAD);

		txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_rxbufring_dma.dma_map,
		    i * sizeof(struct txp_rxbuf_desc),
		    sizeof(struct txp_rxbuf_desc), BUS_DMASYNC_PREWRITE);

d767 1
a767 1
txp_tx_reclaim(sc, r, dma)
a769 1
	struct txp_dma_alloc *dma;
a781 5
		txp_bus_dmamap_sync(sc->sc_dmat, dma->dma_map,
		    cons * sizeof(struct txp_tx_desc),
		    sizeof(struct txp_tx_desc),
		    BUS_DMASYNC_POSTWRITE);

d784 2
a785 2
			txp_bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
			    sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
d787 1
d841 1
a841 1
	int i, j;
a877 12
	for (i = 0; i < TX_ENTRIES; i++) {
		if (bus_dmamap_create(sc->sc_dmat, TXP_MAX_PKTLEN,
		    TX_ENTRIES - 4, TXP_MAX_SEGLEN, 0,
		    BUS_DMA_NOWAIT, &sc->sc_txd[i].sd_map) != 0) {
			for (j = 0; j < i; j++) {
				bus_dmamap_destroy(sc->sc_dmat,
				    sc->sc_txd[j].sd_map);
				sc->sc_txd[j].sd_map = NULL;
			}
			goto bail_txhiring;
		}
	}
a907 2
	txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_rxhiring_dma.dma_map,
	    0, sc->sc_rxhiring_dma.dma_map->dm_mapsize, BUS_DMASYNC_PREREAD);
a922 2
	txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_rxloring_dma.dma_map,
	    0, sc->sc_rxloring_dma.dma_map->dm_mapsize, BUS_DMASYNC_PREREAD);
d989 1
a989 2
		txp_bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
		    sd->sd_map->dm_mapsize, BUS_DMASYNC_PREREAD);
a998 3
	txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_rxbufring_dma.dma_map,
	    0, sc->sc_rxbufring_dma.dma_map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
d1294 5
d1303 1
a1303 1
				goto oactive1;
d1308 1
a1308 1
					goto oactive1;
d1317 1
a1317 1
				goto oactive1;
a1330 1
		txd->tx_numdesc = sd->sd_map->dm_nsegs;
a1355 4
		txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_txhiring_dma.dma_map,
		    prod * sizeof(struct txp_tx_desc), sizeof(struct txp_tx_desc),
		    BUS_DMASYNC_PREWRITE);

d1361 2
a1373 5
			txp_bus_dmamap_sync(sc->sc_dmat,
			    sc->sc_txhiring_dma.dma_map,
			    prod * sizeof(struct txp_frag_desc),
			    sizeof(struct txp_frag_desc), BUS_DMASYNC_PREWRITE);

d1389 1
a1389 2
		txp_bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
		    sd->sd_map->dm_mapsize, BUS_DMASYNC_PREWRITE);
d1399 2
a1485 2
	txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
	    sizeof(struct txp_hostvar), BUS_DMASYNC_PREREAD);
a1490 2
		txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
		    sizeof(struct txp_hostvar), BUS_DMASYNC_POSTREAD);
a1498 2
		txp_bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
		    sizeof(struct txp_hostvar), BUS_DMASYNC_PREREAD);
@


1.27.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d76 1
a76 1
#include <uvm/uvm_extern.h>              /* for vtophys */
a88 7
/*
 * These currently break the 3c990 firmware, hopefully will be resolved
 * at some point.
 */
#undef	TRY_TX_UDP_CSUM
#undef	TRY_TX_TCP_CSUM

d508 1
a508 1
	bus_dmamap_sync(sc->sc_dmat, dma.dma_map, 0,
d524 1
a524 1
	bus_dmamap_sync(sc->sc_dmat, dma.dma_map, 0,
d549 1
a549 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
d576 1
a576 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
d607 1
a607 1
		bus_dmamap_sync(sc->sc_dmat, dma->dma_map,
d621 1
a621 1
		bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
d697 1
a697 1
		bus_dmamap_sync(sc->sc_dmat, dma->dma_map,
d758 1
a758 1
		bus_dmamap_sync(sc->sc_dmat, sc->sc_rxbufring_dma.dma_map,
d770 1
a770 1
		bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
d773 1
a773 1
		bus_dmamap_sync(sc->sc_dmat, sc->sc_rxbufring_dma.dma_map,
d813 1
a813 1
		bus_dmamap_sync(sc->sc_dmat, dma->dma_map,
d820 1
a820 1
			bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
d955 1
a955 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_rxhiring_dma.dma_map,
d972 1
a972 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_rxloring_dma.dma_map,
d1040 1
a1040 1
		bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
d1051 1
a1051 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_rxbufring_dma.dma_map,
a1323 1
	int txdidx;
d1374 1
a1374 1
		txdidx = prod;
d1379 1
a1379 1
		txd->tx_totlen = m->m_pkthdr.len;
d1400 1
a1400 1
#ifdef TRY_TX_TCP_CSUM
a1402 2
#endif
#ifdef TRY_TX_UDP_CSUM
d1407 3
a1409 2
		bus_dmamap_sync(sc->sc_dmat, sd->sd_map, 0,
		    sd->sd_map->dm_mapsize, BUS_DMASYNC_PREWRITE);
d1413 1
a1413 4
			if (++cnt >= (TX_ENTRIES - 4)) {
				bus_dmamap_sync(sc->sc_dmat, sd->sd_map,
				    0, sd->sd_map->dm_mapsize,
				    BUS_DMASYNC_POSTWRITE);
a1414 1
			}
d1416 1
a1416 2
			fxd->frag_flags = FRAG_FLAGS_TYPE_FRAG |
			    FRAG_FLAGS_VALID;
d1427 1
a1427 1
			bus_dmamap_sync(sc->sc_dmat,
d1447 2
a1448 23
		txd->tx_flags |= TX_FLAGS_VALID;
		bus_dmamap_sync(sc->sc_dmat, sc->sc_txhiring_dma.dma_map,
		    txdidx * sizeof(struct txp_tx_desc),
		    sizeof(struct txp_tx_desc), BUS_DMASYNC_PREWRITE);

#if 0
		{
			struct mbuf *mx;
			int i;

			printf("txd: flags 0x%x ndesc %d totlen %d pflags 0x%x\n",
			    txd->tx_flags, txd->tx_numdesc, txd->tx_totlen,
			    txd->tx_pflags);
			for (mx = m; mx != NULL; mx = mx->m_next) {
				for (i = 0; i < mx->m_len; i++) {
					printf(":%02x",
					    (u_int8_t)m->m_data[i]);
				}
			}
			printf("\n");
		}
#endif

d1543 1
a1543 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
d1550 1
a1550 1
		bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
d1560 1
a1560 1
		bus_dmamap_sync(sc->sc_dmat, sc->sc_host_dma.dma_map, 0,
d1597 1
a1597 2
			printf("%s: response error: id 0x%x\n",
			    TXP_DEVNAME(sc), rsp->rsp_id);
d1958 3
d1962 1
a1962 2
#ifdef TRY_TX_TCP_CSUM
		sc->sc_tx_capability |= OFFLOAD_TCPCKSUM;
d1968 3
d1972 1
a1972 2
#ifdef TRY_TX_UDP_CSUM
		sc->sc_tx_capability |= OFFLOAD_UDPCKSUM;
@


1.27.2.5
log
@Merge in trunk
@
text
@d27 1
a27 1
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR THE VOICES IN THEIR HEADS
d1246 1
a1246 1
	splx(s);
@


1.27.2.6
log
@Merge in -current from roughly a week ago
@
text
@d96 26
a121 26
int txp_probe(struct device *, void *, void *);
void txp_attach(struct device *, struct device *, void *);
int txp_intr(void *);
void txp_tick(void *);
void txp_shutdown(void *);
int txp_ioctl(struct ifnet *, u_long, caddr_t);
void txp_start(struct ifnet *);
void txp_stop(struct txp_softc *);
void txp_init(struct txp_softc *);
void txp_watchdog(struct ifnet *);

int txp_chip_init(struct txp_softc *);
int txp_reset_adapter(struct txp_softc *);
int txp_download_fw(struct txp_softc *);
int txp_download_fw_wait(struct txp_softc *);
int txp_download_fw_section(struct txp_softc *,
    struct txp_fw_section_header *, int);
int txp_alloc_rings(struct txp_softc *);
void txp_dma_free(struct txp_softc *, struct txp_dma_alloc *);
int txp_dma_malloc(struct txp_softc *, bus_size_t, struct txp_dma_alloc *, int);
void txp_set_filter(struct txp_softc *);

int txp_cmd_desc_numfree(struct txp_softc *);
int txp_command(struct txp_softc *, u_int16_t, u_int16_t, u_int32_t,
    u_int32_t, u_int16_t *, u_int32_t *, u_int32_t *, int);
int txp_command2(struct txp_softc *, u_int16_t, u_int16_t,
d123 15
a137 15
    struct txp_rsp_desc **, int);
int txp_response(struct txp_softc *, u_int32_t, u_int16_t, u_int16_t,
    struct txp_rsp_desc **);
void txp_rsp_fixup(struct txp_softc *, struct txp_rsp_desc *,
    struct txp_rsp_desc *);
void txp_capabilities(struct txp_softc *);

void txp_ifmedia_sts(struct ifnet *, struct ifmediareq *);
int txp_ifmedia_upd(struct ifnet *);
void txp_show_descriptor(void *);
void txp_tx_reclaim(struct txp_softc *, struct txp_tx_ring *,
    struct txp_dma_alloc *);
void txp_rxbuf_reclaim(struct txp_softc *);
void txp_rx_reclaim(struct txp_softc *, struct txp_rx_ring *,
    struct txp_dma_alloc *);
d1347 1
a1347 1
		IFQ_POLL(&ifp->if_snd, m);
a1349 1
		mnew = NULL;
a1370 1
			IFQ_DEQUEUE(&ifp->if_snd, m);
a1453 7
		/*
		 * if mnew isn't NULL, we already dequeued and copied
		 * the packet.
		 */
		if (mnew == NULL)
			IFQ_DEQUEUE(&ifp->if_snd, m);

d1497 1
@


1.27.2.7
log
@Sync the SMP branch with 3.3
@
text
@a146 11
const struct pci_matchid txp_devices[] = {
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990TX95 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990TX97 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990SVR95 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990SVR97 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C990BTXM },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3C990BSVR },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990FX },
};

d152 16
a167 2
	return (pci_matchbyid((struct pci_attach_args *)aux, txp_devices,
	    sizeof(txp_devices)/sizeof(txp_devices[0])));
a245 1
	p1 = htole16(p1);
a247 1
	p2 = htole32(p2);
d397 1
a397 1
	WRITE_REG(sc, TXP_H2A_1, letoh32(fileheader->addr));
d408 1
a408 1
	for (sect = 0; sect < letoh32(fileheader->nsections); sect++) {
d412 1
a412 2
		    (((u_int8_t *)secthead) + letoh32(secthead->nbytes) +
			sizeof(*secthead));
d485 1
a485 1
	rseg += letoh32(sect->nbytes);
d492 1
a492 1
	if (txp_dma_malloc(sc, letoh32(sect->nbytes), &dma, 0)) {
d497 1
a497 2
	bcopy(((u_int8_t *)sect) + sizeof(*sect), dma.dma_vaddr,
	    letoh32(sect->nbytes));
d504 1
a504 1
	m.m_len = letoh32(sect->nbytes);
d507 1
a507 1
	csum = in_cksum(&m, letoh32(sect->nbytes));
d518 3
a520 3
	WRITE_REG(sc, TXP_H2A_1, letoh32(sect->nbytes));
	WRITE_REG(sc, TXP_H2A_2, letoh16(sect->cksum));
	WRITE_REG(sc, TXP_H2A_3, letoh32(sect->addr));
d573 1
a573 1
		    TXP_OFFSET2IDX(letoh32(*(sc->sc_txhir.r_off)))))
d577 1
a577 1
		    TXP_OFFSET2IDX(letoh32(*(sc->sc_txlor.r_off)))))
d607 2
a608 2
	roff = letoh32(*r->r_roff);
	woff = letoh32(*r->r_woff);
d620 1
a620 1
			    letoh32(rxd->rx_stat));
d634 1
a634 1
		m->m_pkthdr.len = m->m_len = letoh16(rxd->rx_len);
d676 1
a676 1
		if (rxd->rx_stat & htole32(RX_STAT_IPCKSUMBAD))
d678 1
a678 1
		else if (rxd->rx_stat & htole32(RX_STAT_IPCKSUMGOOD))
d681 1
a681 1
		if (rxd->rx_stat & htole32(RX_STAT_TCPCKSUMBAD))
d683 1
a683 1
		else if (rxd->rx_stat & htole32(RX_STAT_TCPCKSUMGOOD))
d686 1
a686 1
		if (rxd->rx_stat & htole32(RX_STAT_UDPCKSUMBAD))
d688 1
a688 1
		else if (rxd->rx_stat & htole32(RX_STAT_UDPCKSUMGOOD))
d694 1
a694 1
		if (rxd->rx_stat & htole32(RX_STAT_VLAN)) {
d717 1
a717 1
		woff = letoh32(*r->r_woff);
d720 1
a720 1
	*r->r_roff = htole32(woff);
d733 2
a734 2
	end = TXP_OFFSET2IDX(letoh32(hv->hv_rx_buf_read_idx));
	i = TXP_OFFSET2IDX(letoh32(hv->hv_rx_buf_write_idx));
d784 1
a784 1
		hv->hv_rx_buf_write_idx = htole32(TXP_IDX2OFFSET(i));
d810 1
a810 1
	u_int32_t idx = TXP_OFFSET2IDX(letoh32(*(r->r_off)));
d902 2
a903 2
	boot->br_hostvar_lo = htole32(sc->sc_host_dma.dma_paddr & 0xffffffff);
	boot->br_hostvar_hi = htole32(sc->sc_host_dma.dma_paddr >> 32);
d913 3
a915 3
	boot->br_txhipri_lo = htole32(sc->sc_txhiring_dma.dma_paddr & 0xffffffff);
	boot->br_txhipri_hi = htole32(sc->sc_txhiring_dma.dma_paddr >> 32);
	boot->br_txhipri_siz = htole32(TX_ENTRIES * sizeof(struct txp_tx_desc));
d940 3
a942 3
	boot->br_txlopri_lo = htole32(sc->sc_txloring_dma.dma_paddr & 0xffffffff);
	boot->br_txlopri_hi = htole32(sc->sc_txloring_dma.dma_paddr >> 32);
	boot->br_txlopri_siz = htole32(TX_ENTRIES * sizeof(struct txp_tx_desc));
d955 3
a957 3
	boot->br_rxhipri_lo = htole32(sc->sc_rxhiring_dma.dma_paddr & 0xffffffff);
	boot->br_rxhipri_hi = htole32(sc->sc_rxhiring_dma.dma_paddr >> 32);
	boot->br_rxhipri_siz = htole32(RX_ENTRIES * sizeof(struct txp_rx_desc));
d972 3
a974 3
	boot->br_rxlopri_lo = htole32(sc->sc_rxloring_dma.dma_paddr & 0xffffffff);
	boot->br_rxlopri_hi = htole32(sc->sc_rxloring_dma.dma_paddr >> 32);
	boot->br_rxlopri_siz = htole32(RX_ENTRIES * sizeof(struct txp_rx_desc));
d989 3
a991 3
	boot->br_cmd_lo = htole32(sc->sc_cmdring_dma.dma_paddr & 0xffffffff);
	boot->br_cmd_hi = htole32(sc->sc_cmdring_dma.dma_paddr >> 32);
	boot->br_cmd_siz = htole32(CMD_ENTRIES * sizeof(struct txp_cmd_desc));
d1003 3
a1005 3
	boot->br_resp_lo = htole32(sc->sc_rspring_dma.dma_paddr & 0xffffffff);
	boot->br_resp_hi = htole32(sc->sc_rspring_dma.dma_paddr >> 32);
	boot->br_resp_siz = htole32(CMD_ENTRIES * sizeof(struct txp_rsp_desc));
d1017 3
a1019 3
	boot->br_rxbuf_lo = htole32(sc->sc_rxbufring_dma.dma_paddr & 0xffffffff);
	boot->br_rxbuf_hi = htole32(sc->sc_rxbufring_dma.dma_paddr >> 32);
	boot->br_rxbuf_siz = htole32(RXBUF_ENTRIES * sizeof(struct txp_rxbuf_desc));
d1061 2
a1062 2
	sc->sc_hostvar->hv_rx_buf_write_idx = htole32((RXBUF_ENTRIES - 1) *
	    sizeof(struct txp_rxbuf_desc));
d1071 2
a1072 2
	boot->br_zero_lo = htole32(sc->sc_zero_dma.dma_paddr & 0xffffffff);
	boot->br_zero_hi = htole32(sc->sc_zero_dma.dma_paddr >> 32);
d1527 1
a1527 1
		*out1 = letoh16(rsp->rsp_par1);
d1529 1
a1529 1
		*out2 = letoh32(rsp->rsp_par2);
d1531 1
a1531 1
		*out3 = letoh32(rsp->rsp_par3);
d1562 5
a1566 6
	seq = sc->sc_seq++;
	cmd->cmd_seq = htole16(seq);
	cmd->cmd_id = htole16(id);
	cmd->cmd_par1 = htole16(in1);
	cmd->cmd_par2 = htole32(in2);
	cmd->cmd_par3 = htole32(in3);
d1595 2
a1596 2
		idx = letoh32(hv->hv_resp_read_idx);
		if (idx != letoh32(hv->hv_resp_write_idx)) {
d1626 1
a1626 1
	while (ridx != letoh32(hv->hv_resp_write_idx)) {
d1629 1
a1629 1
		if (id == letoh16(rsp->rsp_id) && letoh16(rsp->rsp_seq) == seq) {
d1641 1
a1641 1
			    TXP_DEVNAME(sc), letoh16(rsp->rsp_id));
d1643 1
a1643 1
			ridx = letoh32(hv->hv_resp_read_idx);
d1647 1
a1647 1
		switch (letoh16(rsp->rsp_id)) {
d1656 1
a1656 1
			    letoh16(rsp->rsp_id));
d1660 2
a1661 2
		ridx = letoh32(hv->hv_resp_read_idx);
		hv->hv_resp_read_idx = letoh32(ridx);
d1676 1
a1676 1
	ridx = letoh32(hv->hv_resp_read_idx);
d1687 1
a1687 2
		sc->sc_rspring.lastwrite = ridx;
		hv->hv_resp_read_idx = htole32(ridx);
d1690 1
a1690 1
	hv->hv_resp_read_idx = htole32(ridx);
d1702 1
a1702 1
	ridx = letoh32(hv->hv_cmd_read_idx);
d1706 1
a1706 1
		nfree = letoh32(br->br_cmd_siz) - sizeof(struct txp_cmd_desc);
d1709 1
a1709 1
			nfree = letoh32(br->br_cmd_siz) -
d1851 2
a1852 3
		    cmd->cmd_flags, cmd->cmd_numdesc, letoh16(cmd->cmd_id),
		    letoh16(cmd->cmd_seq), letoh16(cmd->cmd_par1),
		    letoh32(cmd->cmd_par2), letoh32(cmd->cmd_par3));
d1857 2
a1858 3
		    rsp->rsp_flags, rsp->rsp_numdesc, letoh16(rsp->rsp_id),
		    letoh16(rsp->rsp_seq), letoh16(rsp->rsp_par1),
		    letoh32(rsp->rsp_par2), letoh32(rsp->rsp_par3));
d1875 2
a1876 3
		    cmd->cmd_flags, cmd->cmd_numdesc, letoh16(cmd->cmd_id),
		    letoh16(cmd->cmd_seq), letoh16(cmd->cmd_par1),
		    letoh32(cmd->cmd_par2), letoh32(cmd->cmd_par3));
@


1.27.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.27.2.7 2003/03/28 00:38:22 niklas Exp $	*/
d16 7
@


1.27.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 1
a141 1
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CR990TX },
@


1.27.2.10
log
@Merge with the trunk
@
text
@d1886 1
a1886 1
	u_int32_t hashbit, hash[2];
d1888 2
a1889 1
	int mcnt = 0;
d1927 15
a1941 2
			hashbit = (u_int16_t)(ether_crc32_be(enm->enm_addrlo,
			    ETHER_ADDR_LEN) & (64 - 1));
@


1.26
log
@revert reverted patch now that bus_dma has been updated on i386
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.25 2001/05/08 05:22:01 jason Exp $	*/
d539 1
d560 2
a561 1
		txp_rxbuf_reclaim(sc);
@


1.25
log
@add transmit side of bpf tapping
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.24 2001/05/08 03:52:43 jason Exp $	*/
d1007 1
a1007 1
	dma->dma_size = size;
d1016 1
a1016 1
	bus_dmamem_unmap(sc->sc_dmat, dma->dma_vaddr, dma->dma_size);
@


1.24
log
@- add support for hardware vlan tag insertion and removal
- add necessary definitions for extension descriptors, missing commands,
and offload capabilities
- rework command/response (again) to allow for long responses (still need
support for long commands, though).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.23 2001/05/03 05:22:51 jason Exp $	*/
d1146 1
a1146 1
	struct mbuf *m;
d1162 1
d1225 6
@


1.23
log
@grr... part of the bus_dma change depended on local stuff: revert that part
for now until folks comment on the dependent patch; pointed out by fgsch.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.22 2001/05/02 15:00:32 jason Exp $	*/
d119 2
d123 3
a125 1
void txp_rsp_fixup __P((struct txp_softc *, struct txp_rsp_desc *));
d240 4
d619 8
d1148 3
d1186 9
d1238 1
a1238 1
 * XXX this needs to have a callback mechanism
d1294 2
d1306 38
a1343 2
	idx += sizeof(struct txp_rsp_desc);
	if (idx == sc->sc_rspring.size)
d1345 22
a1366 1
	sc->sc_rspring.lastwrite = hv->hv_resp_read_idx = idx;
d1386 6
a1391 1
			*rspp = rsp;
d1397 1
a1397 1
			txp_rsp_fixup(sc, rsp);
d1416 1
a1416 1
		txp_rsp_fixup(sc, rsp);
d1425 1
a1425 1
txp_rsp_fixup(sc, rsp)
d1427 1
a1427 1
	struct txp_rsp_desc *rsp;
d1429 1
d1436 2
d1439 2
a1440 1
		if (ridx == sc->sc_rspring.size)
d1442 2
d1714 33
@


1.22
log
@- somewhat better use of bus_dma interface
- use constants for bzero'n allocated memory instead of retrieving mapped size
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.21 2001/04/30 04:52:20 jason Exp $	*/
d991 1
a991 1

d1000 1
a1000 1
	bus_dmamem_unmap(sc->sc_dmat, dma->dma_vaddr, dma->dma_map->dm_mapsize);
@


1.21
log
@pretty up rx filter setup
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.20 2001/04/15 22:47:38 jason Exp $	*/
d758 1
a758 1
	bzero(sc->sc_host_dma.dma_vaddr, sc->sc_host_dma.dma_siz);
d769 1
a769 1
	bzero(sc->sc_txhiring_dma.dma_vaddr, sc->sc_txhiring_dma.dma_siz);
d784 1
a784 1
	bzero(sc->sc_txloring_dma.dma_vaddr, sc->sc_txloring_dma.dma_siz);
d799 1
a799 1
	bzero(sc->sc_rxhiring_dma.dma_vaddr, sc->sc_rxhiring_dma.dma_siz);
d814 1
a814 1
	bzero(sc->sc_rxloring_dma.dma_vaddr, sc->sc_rxloring_dma.dma_siz);
d829 1
a829 1
	bzero(sc->sc_cmdring_dma.dma_vaddr, sc->sc_cmdring_dma.dma_siz);
d843 1
a843 1
	bzero(sc->sc_rspring_dma.dma_vaddr, sc->sc_rspring_dma.dma_siz);
d857 1
a857 1
	bzero(sc->sc_rxbufring_dma.dma_vaddr, sc->sc_rxbufring_dma.dma_siz);
d891 1
a891 1
	bzero(sc->sc_zero_dma.dma_vaddr, sc->sc_zero_dma.dma_siz);
d962 4
d967 3
a969 11
	    &dma->dma_seg, 1, &dma->dma_nseg, BUS_DMA_NOWAIT)) != 0) {
		return (r);
	}
	if (dma->dma_nseg != 1) {
		bus_dmamem_free(sc->sc_dmat, &dma->dma_seg, dma->dma_nseg);
		return (-1);
	}
	   
	if ((r = bus_dmamem_map(sc->sc_dmat, &dma->dma_seg, dma->dma_nseg,
	    size, &dma->dma_vaddr, mapflags | BUS_DMA_NOWAIT)) != 0) {
		bus_dmamem_free(sc->sc_dmat, &dma->dma_seg, dma->dma_nseg);
d973 6
a978 4
	if ((r = bus_dmamap_create(sc->sc_dmat, size, dma->dma_nseg,
	    size, 0, BUS_DMA_NOWAIT, &dma->dma_map)) != 0) {
		bus_dmamem_unmap(sc->sc_dmat, dma->dma_vaddr, size);
		bus_dmamem_free(sc->sc_dmat, &dma->dma_seg, dma->dma_nseg);
d984 2
a986 2
		bus_dmamem_unmap(sc->sc_dmat, dma->dma_vaddr, size);
		bus_dmamem_free(sc->sc_dmat, &dma->dma_seg, dma->dma_nseg);
a990 1
	dma->dma_siz = size;
d1000 2
a1003 2
	bus_dmamem_unmap(sc->sc_dmat, dma->dma_vaddr, dma->dma_siz);
	bus_dmamem_free(sc->sc_dmat, &dma->dma_seg, dma->dma_nseg);
@


1.20
log
@- in txp_intr(), don't call the rx/tx handlers unless necessary
- make txp_rx_reclaim() run on offsets instead of indices (avoids several
division/multiplication conversions)
- remove vlan tag support for now (it doesn't work anyway)
- optimize txp_start(), txp_rx_reclaim(), and txp_tx_reclaim() a bit (this is
based on my original attempts at these functions... only now it works =)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.19 2001/04/15 21:17:53 jason Exp $	*/
d1550 1
a1550 1
	u_int16_t filter = 0;
d1556 5
d1562 7
a1568 5
	if (ifp->if_flags & IFF_PROMISC)
		filter = TXP_RXFILT_PROMISC;
	else if (ifp->if_flags & IFF_ALLMULTI)
		filter = TXP_RXFILT_DIRECT | TXP_RXFILT_ALLMULTI |
		    TXP_RXFILT_BROADCAST;
a1569 1
		filter = TXP_RXFILT_DIRECT | TXP_RXFILT_BROADCAST;
d1576 1
d1616 1
@


1.19
log
@mask off Arm2Host_Comm_3 interrupts now that rx buffer reclamation has
some out of resource handling (a2h_3 is a heartbeat generated every ~8ms
and thus provides 125intrs/sec even when idle).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.18 2001/04/15 21:03:21 jason Exp $	*/
d546 5
a550 2
		txp_rx_reclaim(sc, &sc->sc_rxhir);
		txp_rx_reclaim(sc, &sc->sc_rxlor);
d552 8
a559 2
		txp_tx_reclaim(sc, &sc->sc_txhir);
		txp_tx_reclaim(sc, &sc->sc_txlor);
d581 1
a581 1
	u_int32_t ridx, widx;
d583 3
a585 5
	ridx = (*r->r_roff) / sizeof(struct txp_rx_desc);
	widx = (*r->r_woff) / sizeof(struct txp_rx_desc);

	while (ridx != widx) {
		rxd = &r->r_desc[ridx];
d587 1
a610 12
		if (rxd->rx_stat & RX_STAT_VLAN) {
			printf("%s: vlan tag 0x%x\n", sc->sc_dev.dv_xname,
			    rxd->rx_vlan);
#if NVLAN > 0
			if (vlan_input_tag(eh, m, rxd->rx_stat & 0xffff) < 0)
				ifp->if_data.ifi_noproto++;
#else
			m_freem(m);
#endif
			goto next;
		}

d615 7
a621 4
		if (++ridx == RX_ENTRIES)
			ridx = 0;

		widx = (*r->r_woff) / sizeof(struct txp_rx_desc);
d624 1
a624 6
	ridx = (*r->r_roff) / sizeof(struct txp_rx_desc);
	while (ridx != widx) {
		if (++ridx == RX_ENTRIES)
			ridx = 0;
		*r->r_roff = ridx * sizeof(struct txp_rx_desc);
	}
d643 2
a645 2
		rbd = &sc->sc_rxbufs[i];

d663 1
a663 1
		if (++i == RXBUF_ENTRIES)
d665 3
d681 2
a682 1
	struct txp_tx_desc *txd;
d685 2
a686 2
	while (r->r_cons != idx) {
		if (r->r_cnt == 0)
a688 4
		txd = &r->r_desc[r->r_cons];
		r->r_cons = (r->r_cons + 1) % TX_ENTRIES;
		r->r_cnt--;

d695 1
d700 8
d710 3
a712 1
	if (r->r_cnt == 0)
d1134 1
a1134 1
	u_int32_t firstprod, firstcnt;
d1139 3
d1143 1
a1143 1
		IF_DEQUEUE(&ifp->if_snd, m);	/* no mbufs */
d1147 1
a1147 1
		if ((TX_ENTRIES - r->r_cnt) < 4) {
d1152 2
a1153 2
		firstprod = r->r_prod;
		firstcnt = r->r_cnt;
d1155 6
a1160 4
		txd = &r->r_desc[r->r_prod];
		r->r_prod = (r->r_prod + 1) % TX_ENTRIES;
		r->r_cnt++;
		if (r->r_cnt == (TX_ENTRIES - 4)) {
a1161 1
		}
d1170 1
d1177 3
a1181 6
			fxd = (struct txp_frag_desc *)&r->r_desc[r->r_prod];
			r->r_prod = (r->r_prod + 1) % TX_ENTRIES;
			r->r_cnt++;
			if (r->r_cnt == (TX_ENTRIES - 4))
				goto oactive;

d1189 7
d1199 1
a1199 1
		WRITE_REG(sc, r->r_reg, TXP_IDX2OFFSET(r->r_prod));
d1202 2
@


1.18
log
@- setup a timeout that will try to refill the rxbuffer ring (this makes
out of resource handling a bit better).
- in txp_stop(), disable the rx process, too
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.17 2001/04/13 20:13:30 jason Exp $	*/
d537 1
a537 1
	    TXP_INT_A2H_3 | TXP_INT_A2H_2 | TXP_INT_A2H_1 | TXP_INT_A2H_0 |
d556 1
a556 1
	WRITE_REG(sc, TXP_IMR, 0);
d1092 1
a1092 1
	    TXP_INT_A2H_3 | TXP_INT_A2H_2 | TXP_INT_A2H_1 | TXP_INT_A2H_0 |
d1095 1
a1095 1
	WRITE_REG(sc, TXP_IMR, 0);
@


1.17
log
@- attempt to get dma coherent buffers for most of the shared memory uses
- correct rx_reclaim (still needs some work)
- rework txp_init() a bit to do the operations in the right order
- wait for filter setup to complete before returning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.16 2001/04/13 17:50:30 jason Exp $	*/
d271 2
d653 1
a653 3
		if (m == NULL) {
			printf("%s: rxbuf alloc failed\n",
			    sc->sc_dev.dv_xname);
a654 1
		}
a657 2
			printf("%s: rxbuf cluster alloc failed\n",
			    sc->sc_dev.dv_xname);
a1003 9
void
txp_tick(vsc)
	void *vsc;
{
	struct txp_softc *sc = vsc;

	timeout_add(&sc->sc_tick_tmo, hz);
}

d1101 3
d1107 12
a1368 1
#if 0
d1370 3
a1372 1
#endif
@


1.16
log
@- rx buffer ring management (working)
- simplify/encapsulate fully transmit ring handling
- initialize sc_xcvr to be auto
- initial rx descriptor ring handling (doesn't work yet)
status: firmware, boot, media, tx, and rx buffer management work
(actual received frames don't... yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.15 2001/04/12 22:40:12 jason Exp $	*/
d113 1
a113 1
int txp_dma_malloc __P((struct txp_softc *, bus_size_t, struct txp_dma_alloc *));
d127 1
a127 1
void txp_rxbuf_claim __P((struct txp_softc *));
d234 2
d476 1
a476 1
	if (txp_dma_malloc(sc, sect->nbytes, &dma)) {
d546 1
a546 1
		txp_rxbuf_claim(sc);
d570 1
a570 1
	u_int32_t i, end;
d572 2
a573 5
	i = (*r->r_roff) / sizeof(struct txp_rx_desc);
	end = (*r->r_woff) / sizeof(struct txp_rx_desc);

	while (i != end) {
		printf("%s: rxd %u\n", sc->sc_dev.dv_xname, i);
d575 2
a576 1
		rxd = &r->r_desc[i];
d586 1
a586 2
		m->m_len = rxd->rx_len;

a612 1

a615 1
		*r->r_roff = i * sizeof(struct txp_rx_desc);
d617 4
a620 2
		if (++i == RX_ENTRIES)
			i = 0;
d623 6
d632 1
a632 1
txp_rxbuf_claim(sc)
d667 1
a667 1
		rbd->rb_paddrlo = vtophys(m->m_data + 2);
d741 2
a742 1
	if (txp_dma_malloc(sc, sizeof(struct txp_boot_record), &sc->sc_boot_dma)) {
d751 2
a752 1
	if (txp_dma_malloc(sc, sizeof(struct txp_hostvar), &sc->sc_host_dma)) {
d763 1
a763 1
	    &sc->sc_txhiring_dma)) {
d778 1
a778 1
	    &sc->sc_txloring_dma)) {
d793 1
a793 1
	    &sc->sc_rxhiring_dma)) {
d806 1
a806 1
	/* low priority rx ring */
d808 1
a808 1
	    &sc->sc_rxloring_dma)) {
d823 1
a823 1
	    &sc->sc_cmdring_dma)) {
d837 1
a837 1
	    &sc->sc_rspring_dma)) {
d851 1
a851 1
	    &sc->sc_rxbufring_dma)) {
d877 1
a877 1
		sc->sc_rxbufs[i].rb_paddrlo = vtophys(m->m_data + 2);
d884 2
a885 1
	if (txp_dma_malloc(sc, sizeof(u_int32_t), &sc->sc_zero_dma)) {
d952 1
a952 1
txp_dma_malloc(sc, size, dma)
d956 1
d970 1
a970 1
	    size, &dma->dma_vaddr, BUS_DMA_NOWAIT)) != 0) {
d1097 2
a1098 2
	txp_command(sc, TXP_CMD_XCVR_SELECT, sc->sc_xcvr, 0, 0,
	    NULL, NULL, NULL, 0);
a1101 2
	txp_set_filter(sc);

d1590 1
a1590 1
	    NULL, NULL, NULL, 0);
@


1.15
log
@- initial rx buffer ring management routines and allocation
- go ahead and initialized the rx filter (but don't enable RX just yet)
- correct descriptor definition for txp_rx_desc (not the same size as any
other descriptor)
- definition of txp_rxbuf_desc
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.14 2001/04/12 20:36:06 jason Exp $	*/
d42 1
d72 4
d126 1
a126 1
void txp_tx_reclaim __P((struct txp_softc *, struct txp_tx_ring *, u_int32_t));
d128 1
d252 2
a253 1
	ifmedia_set(&sc->sc_ifmedia, IFM_ETHER|IFM_AUTO);
d256 1
a526 1
	struct txp_hostvar *hv = sc->sc_hostvar;
d542 2
d545 2
a546 2
		txp_tx_reclaim(sc, &sc->sc_txhir, hv->hv_tx_hi_desc_read_idx);
		txp_tx_reclaim(sc, &sc->sc_txlor, hv->hv_tx_lo_desc_read_idx);
d560 67
d630 1
d636 5
a640 2
	i = TXP_OFFSET2IDX(hv->hv_rx_buf_read_idx);
	end = TXP_OFFSET2IDX(hv->hv_rx_buf_write_idx);
d658 1
a658 2

		printf("%s: rxbuf claim\n", i);
d662 1
a662 1
		rbd->rb_paddrlo = vtophys(m->m_data);
d665 2
a669 2

	hv->hv_rx_buf_write_idx = TXP_IDX2OFFSET(i);
d676 1
a676 1
txp_tx_reclaim(sc, r, off)
a678 1
	u_int32_t off;
d681 1
a681 1
	u_int32_t idx = TXP_OFFSET2IDX(off);
d730 1
d767 1
d781 2
a782 1
	sc->sc_txhir.r_cons = sc->sc_txhir.r_prod = sc->sc_txhir.r_cnt = 0;
d794 4
d809 4
d867 1
d870 1
a870 1
		sc->sc_rxbufs[i].rb_paddrlo = vtophys(m->m_data);
d873 2
d1088 2
a1089 2
	txp_set_filter(sc);

a1090 1
#if 0
d1092 2
a1093 1
#endif
@


1.14
log
@- complete rewrite of transmit routines (these really work, but need
optimization)
-  add in IFF_OACTIVE and if_timer handling
status: firmware, boot, media, and transmit working
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.13 2001/04/12 15:01:19 jason Exp $	*/
d122 1
d535 1
d550 43
d753 31
d787 1
a787 1
		goto bail_rspring;
d830 2
a995 1
#if 0
a996 1
#endif
d999 3
@


1.13
log
@- sort of working transmit routines and tx interrupt handling, definately
more to do here
- be sure to set maximum packet size early
- remove old debugging code and add new
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.12 2001/04/11 15:41:08 jason Exp $	*/
a120 1
int txp_encap __P((struct txp_softc *, struct txp_tx_ring *, struct mbuf *, u_int32_t *, u_int32_t *, u_int32_t *));
d557 3
a559 2
	u_int32_t i = r->r_cons, idx = TXP_OFFSET2IDX(off), cnt = r->r_cnt;
	struct txp_tx_desc *txd = &r->r_desc[i];
d562 2
a563 2
	while (i != idx) {
		if (cnt == 0)
d565 5
d572 2
a573 2
			bcopy(&txd->tx_addrlo, &m, sizeof(struct mbuf *));
			if (m != NULL)
d575 3
a577 1
			bzero(txd, sizeof(*txd));
d579 2
a580 1
		cnt--;
d582 2
a583 8
		if (++i == TX_ENTRIES) {
			i = 0;
			txd = r->r_desc;
		} else
			txd++;
	}
	r->r_cons = i;
	r->r_cnt = cnt;
d933 1
d944 1
a944 1
	struct txp_tx_ring *r;
d946 1
d948 1
a948 1
	u_int32_t bix, totlen, cnt;
d953 2
a954 5
	r = &sc->sc_txhir;
	bix = r->r_prod;

	while ((TX_ENTRIES - r->r_cnt) > 4) {
		IF_DEQUEUE(&ifp->if_snd, m);
d958 4
a961 8
#if NBPFILTER > 0
		/*
		 * If BPF is listening on this interface, let it see the
		 * packet before we commit it to the wire.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m);
#endif
d963 2
a964 3
		txd = &r->r_desc[bix];
		if (++bix == TX_ENTRIES)
			bix = 0;
d966 2
d969 2
a970 9

		if (txp_encap(sc, &sc->sc_txhir, m, &bix, &totlen, &cnt)) {
			if (bix == 0)
				bix = TX_ENTRIES;
			bix--;
			r->r_cnt--;
			IF_PREPEND(&ifp->if_snd, m);
			ifp->if_flags |= IFF_OACTIVE;
			break;
a972 1
		bzero(txd, sizeof(*txd));
d974 26
a999 33
		txd->tx_totlen = totlen;
		txd->tx_numdesc = cnt;
		/* stash mbuf * in the descriptor */
		bcopy(&m, &txd->tx_addrlo, sizeof(struct mbuf *));

		/* Kick the txp */
		WRITE_REG(sc, r->r_reg, TXP_IDX2OFFSET(bix));

		if (++bix == TX_ENTRIES)
			bix = 0;
	}

	r->r_prod = bix;
}

int
txp_encap(sc, r, mhead, bixp, totlenp, cntp)
	struct txp_softc *sc;
	struct txp_tx_ring *r;
	struct mbuf *mhead;
	u_int32_t *bixp, *totlenp, *cntp;
{
	struct mbuf *m;
	struct txp_frag_desc *fd;
	u_int32_t cnt = 0, cur, frag, totlen = 0;
	u_int64_t addr;

	cur = frag = *bixp;
	fd = (struct txp_frag_desc *)&r->r_desc[frag];
	m = mhead;

	while (m != NULL) {
		if (m->m_len == 0) {
a1000 1
			continue;
d1003 2
a1004 23
		totlen += m->m_len;

		if ((TX_ENTRIES - (r->r_cnt + cnt)) < 4)
			goto err;

		bzero(fd, sizeof(*fd));
		fd->frag_flags = FRAG_FLAGS_TYPE_FRAG;
		addr = vtophys(m->m_data);
		fd->frag_addrlo = addr & 0xffffffff;
		fd->frag_addrhi = addr >> 32;
		fd->frag_len = m->m_len;

		cur = frag;
		cnt++;
		frag++;
		if (frag == TX_ENTRIES) {
			frag = 0;
			fd = (struct txp_frag_desc *)r->r_desc;
		} else {
			fd++;
		}

		m = m->m_next;
a1005 6
	*bixp = frag;
	*totlenp = totlen;
	*cntp = cnt;
	r->r_cnt += cnt;

	return (0);
d1007 1
a1007 6
err:
	for (; cnt > 0; cnt--) {
		if (frag == 0)
			frag = TX_ENTRIES;
		frag--;
	}
d1009 4
a1012 1
	return (ENOBUFS);
@


1.12
log
@make this load the linux style image file as distributed on 3com's
website.  The license is still too restrictive to be in the tree, though.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.11 2001/04/10 22:10:09 jason Exp $	*/
d121 2
d169 2
d220 4
d236 1
d258 1
a258 1
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;
d328 1
a328 1
		printf(": reset hung\n");
d518 3
d523 23
d549 35
d638 3
d652 3
d909 7
d919 14
d935 1
d940 3
d944 1
d949 4
a952 1
	for (;;) {
d956 38
a993 2
		/* XXX enqueue and send the packet */
		m_freem(m);
d995 65
d1079 1
a1079 1
		printf(": no free cmd descriptors\n");
a1095 2
	txp_show_descriptor(cmd);

d1118 1
a1118 1
		printf(": command failed\n");
a1150 2
		txp_show_descriptor(rsp);

d1157 1
a1157 1
			printf(": response error!\n");
d1165 1
a1165 1
			printf(": stats\n");
d1170 1
a1170 1
			printf(": hello\n");
d1173 2
a1174 1
			printf(": unknown id(0x%x)\n", rsp->rsp_id);
d1234 4
d1269 2
a1270 1
	}
a1315 1
		printf("isolated!\n");
a1324 1
			printf("acomp!\n");
a1352 1
#if 0
d1355 2
d1371 12
a1389 1
#endif
@


1.11
log
@add shutdown hook to stop the adapter completely
put txp_set_filter() in the right places
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.10 2001/04/10 19:52:37 jason Exp $	*/
d84 4
a87 1
#include <dev/microcode/typhoon/typhoon_image.h>
d355 1
a355 1
	fileheader = (struct txp_fw_file_header *)TyphoonImage;
d370 1
a370 1
	secthead = (struct txp_fw_section_header *)(TyphoonImage +
d443 2
a444 2
	rseg = ((u_int8_t *)sect) - ((u_int8_t *)TyphoonImage);
	if (rseg >= sizeof(TyphoonImage)) {
d451 1
a451 1
	if (rseg >= sizeof(TyphoonImage)) {
@


1.10
log
@receive filter programming
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.9 2001/04/09 22:04:59 jason Exp $	*/
a510 1

d517 9
a525 1
	txp_stop(sc);
d698 1
a698 1
	int r;
d708 1
a708 1

d808 1
a808 1
			/* XXX TODO: set multicast list */
d830 3
@


1.9
log
@- full media support (and remove all of the mii stuff... the firmware wants
to maintain write control over the phy... fine... but we query it to get
current status).
- fix several bugs in cmd/rsp handling: match responses to commands via id/seq,
and add a routine to fixup the queue if it gets mangled).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.8 2001/04/09 05:36:16 jason Exp $	*/
d106 1
d1159 70
@


1.8
log
@partial mii support (commented out because the response queue freaks out)
get link status via media status query (unclear how to get speed/duplex this way)
fix media command definitions to match documentation
update the hostvar index for response queue on successful query
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.7 2001/04/09 04:09:17 jason Exp $	*/
d110 1
a110 1
int txp_response __P((struct txp_softc *, u_int32_t, u_int16_t,
d112 1
d116 1
a116 2
int txp_miibus_readreg __P((struct device *, int, int));
void txp_miibus_writereg __P((struct device *, int, int, int));
a236 7
#if 0
	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = txp_miibus_readreg;
	sc->sc_mii.mii_writereg = txp_miibus_writereg;
	mii_phy_probe(self, &sc->sc_mii, 0xffffffff);
#endif

d856 1
d868 1
a868 1
	cmd->cmd_seq = 0x11;
d876 2
d892 1
a892 1
			if (txp_response(sc, idx, cmd->cmd_id, &rsp))
d920 1
a920 1
txp_response(sc, ridx, id, rspp)
d924 1
a929 1
again:
d933 3
a935 1
		if (id == rsp->rsp_id) {
d942 1
a942 1
			/* XXX fixup */
a951 1
			printf(": mediastatus\n");
a957 3
			/* XXX fixup */
			ridx = hv->hv_resp_read_idx;
			goto again;
d960 2
d968 20
d1067 16
a1082 1
	u_int16_t p1;
d1084 3
a1086 20
	switch (sc->sc_xcvr) {
	case TXP_XCVR_10_HDX:
		ifmr->ifm_active = IFM_ETHER | IFM_10_T | IFM_HDX;
		break;
	case TXP_XCVR_10_FDX:
		ifmr->ifm_active = IFM_ETHER | IFM_10_T | IFM_FDX;
		break;
	case TXP_XCVR_100_HDX:
		ifmr->ifm_active = IFM_ETHER | IFM_100_TX | IFM_HDX;
		break;
	case TXP_XCVR_100_FDX:
		ifmr->ifm_active = IFM_ETHER | IFM_100_TX | IFM_HDX;
		break;
	case TXP_XCVR_AUTO:
		ifmr->ifm_active = IFM_ETHER | IFM_AUTO;
		break;
	default:
		ifmr->ifm_active = IFM_ETHER | IFM_NONE;
		break;
	}
d1088 2
a1089 1
	/* XXX determine real speed/duplex status */
d1091 5
a1095 7
	if (txp_command(sc, TXP_CMD_MEDIA_STATUS_READ, 0, 0, 0,
	    &p1, NULL, NULL, 1))
		ifmr->ifm_status &= ~IFM_AVALID;
	else {
		ifmr->ifm_status |= IFM_AVALID;
		if ((p1 & TXP_MEDIA_NOLINK) == 0)
			ifmr->ifm_status |= IFM_ACTIVE;
a1096 1
}
d1098 9
a1106 6
void
txp_miibus_writereg(self, phy, reg, val)
	struct device *self;
	int phy, reg, val;
{
	struct txp_softc *sc = (struct txp_softc *)self;
d1108 15
a1122 2
	if (phy != 0)
		return;
d1124 3
a1126 2
	txp_command(sc, TXP_CMD_PHY_MGMT_WRITE, val, reg, 0,
	    NULL, NULL, NULL, 0);
d1129 3
a1131 4
int
txp_miibus_readreg(self, phy, reg)
	struct device *self;
	int phy, reg;
d1133 3
a1135 2
	struct txp_softc *sc = (struct txp_softc *)self;
	u_int16_t dat;
d1137 21
a1157 7
	if (phy != 0)
		return (0);

	if (txp_command(sc, TXP_CMD_PHY_MGMT_READ, 0, reg, 0,
	    &dat, NULL, NULL, 1))
		return (0);
	return (dat);
@


1.7
log
@basic media handling/switching
XXX: Status routine needs to really query device to get duplex/speed/link
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.6 2001/04/09 03:15:47 jason Exp $	*/
d115 2
d237 6
d915 5
d1051 1
d1074 41
a1114 2
	/* XXX determine real speed/duplex/link status */
	ifmr->ifm_status &= ~IFM_AVALID;
@


1.6
log
@- implement command and response ring management
- rewrite definitions for command/response rings (bad aaron, shared memory structures are volatile and should not use nonportable bit slices, ':')
Status: loads firmware, boots, gets mac address
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.5 2001/04/08 21:47:45 jason Exp $	*/
d113 11
d223 13
d754 1
a754 1
	struct ifreq *ifr = (struct ifreq *) data;
d803 4
d996 63
a1058 3
struct cfattach txp_ca = {
	sizeof(struct txp_softc), txp_probe, txp_attach,
};
d1060 3
a1062 3
struct cfdriver txp_cd = {
	0, "txp", DV_IFNET
};
@


1.5
log
@- bring over some bus_dma allocation code (from failed attempt to bus_dma-ify ubsec)
- allocate rings and boot the card
Status: firmware loads, card appears to boot correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.4 2001/04/08 18:26:38 jason Exp $	*/
d107 6
d147 2
d199 12
a210 1
	printf("\n");
d510 1
d512 2
a513 2
	/* host ring */
	if (txp_dma_malloc(sc, sizeof(struct txp_hostring), &sc->sc_host_dma)) {
d518 3
a520 2
	boot->br_hostring_lo = sc->sc_host_dma.dma_paddr & 0xffffffff;
	boot->br_hostring_hi = sc->sc_host_dma.dma_paddr >> 32;
d576 3
d581 2
a582 2
	if (txp_dma_malloc(sc, sizeof(struct txp_resp_desc) * RESP_ENTRIES,
	    &sc->sc_respring_dma)) {
d586 7
a592 4
	bzero(sc->sc_respring_dma.dma_vaddr, sc->sc_respring_dma.dma_siz);
	boot->br_resp_lo = sc->sc_respring_dma.dma_paddr & 0xffffffff;
	boot->br_resp_hi = sc->sc_respring_dma.dma_paddr >> 32;
	boot->br_resp_siz = CMD_ENTRIES * sizeof(struct txp_resp_desc);
d597 1
a597 1
		goto bail_respring;
d640 2
a641 2
bail_respring:
	txp_dma_free(sc, &sc->sc_respring_dma);
d811 143
@


1.4
log
@- load microcode from better directory (still not in tree)
- reg "definition" for soft reset register
- make sure fileheader and section number are initialized before use
- verify section checksum before use
- add a skeleton txp_start()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.3 2001/04/08 05:40:23 jason Exp $	*/
d86 3
a88 3
int txp_probe	__P((struct device *, void *, void *));
void txp_attach	__P((struct device *, struct device *, void *));
int txp_intr	__P((void *));
d103 3
d188 3
a316 3
	secthead = (struct txp_fw_section_header *)(TyphoonImage +
	    sizeof(struct txp_fw_file_header));

d322 3
d385 1
a385 4
	u_int64_t pa;
	bus_dma_tag_t dmat = sc->sc_dmat;
	bus_dma_segment_t seg;
	bus_dmamap_t dmamap;
a386 1
	caddr_t kva;
d409 2
a410 3
	if (bus_dmamem_alloc(dmat, sect->nbytes, PAGE_SIZE, 0, &seg, 1, &rseg,
	    BUS_DMA_NOWAIT)) {
		printf(": fw dmamam alloc fail\n");
a412 18
	if (bus_dmamem_map(dmat, &seg, rseg, sect->nbytes, &kva,
	    BUS_DMA_NOWAIT)) {
		printf(": fw dmamem map fail\n");
		err = -1;
		goto bail_free;
	}
	if (bus_dmamap_create(dmat, sect->nbytes, 1, sect->nbytes, 0,
	    BUS_DMA_NOWAIT, &dmamap)) {
		printf(": fw dmamap create fail\n");
		err = -1;
		goto bail_unmap;
	}
	if (bus_dmamap_load(dmat, dmamap, kva, sect->nbytes, NULL,
	    BUS_DMA_NOWAIT)) {
		printf(": fw dmamap load fail\n");
		err = -1;
		goto bail_destroy;
	}
d414 1
a414 1
	bcopy(((u_int8_t *)sect) + sizeof(*sect), kva, sect->nbytes);
d416 3
d422 1
a422 1
	m.m_data = kva;
d432 1
a432 1
	bus_dmamap_sync(dmat, dmamap,
a434 2
	pa = dmamap->dm_segs[0].ds_addr;

d438 2
a439 2
	WRITE_REG(sc, TXP_H2A_4, pa >> 32);
	WRITE_REG(sc, TXP_H2A_5, pa & 0xffffffff);
d445 1
d448 1
a448 1
	bus_dmamap_sync(dmat, dmamap,
d452 1
a452 7
	bus_dmamap_unload(dmat, dmamap);
bail_destroy:
	bus_dmamap_destroy(dmat, dmamap);
bail_unmap:
	bus_dmamem_unmap(dmat, kva, sect->nbytes);
bail_free:
	bus_dmamem_free(dmat, &seg, rseg);
d474 211
@


1.3
log
@make sure that we don't go off the end of the image
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.2 2001/04/08 05:28:49 jason Exp $	*/
d84 1
a84 1
#include <dev/pci/typhoon_image.h>
d252 1
a252 1
	WRITE_REG(sc, TXP_SRR, 0x7f);
a300 4
	/* Tell boot firmware to get ready for image */
	WRITE_REG(sc, TXP_H2A_1, fileheader->addr);
	WRITE_REG(sc, TXP_H2A_0, TXP_BOOTCMD_RUNTIME_IMAGE);

d307 4
d315 1
a315 1
		printf(": fw wait failed, initial\n", sect);
d385 2
d433 13
a462 1

d465 2
d582 12
@


1.2
log
@cleanup, more register definitions
@
text
@d1 1
a1 1
/*	$OpenBSD: if_txp.c,v 1.1 2001/04/08 02:16:52 jason Exp $	*/
d389 14
@


1.1
log
@Skeleton driver for 3c990 (mainly so aaron/theo/myself can coordinate)
- the firmware image is still under a restrictive license, so it will
not be in the tree yet
- driver only knows how to (correctly) upload firmware
- register definitions and such are incomplete
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d18 2
a19 1
 *	This product includes software developed by Jason L. Wright.
a85 32
/* XXX not here */
struct txp_softc {
	struct device		sc_dev;
	void *			sc_ih;
	bus_space_handle_t	sc_bh;
	bus_space_tag_t		sc_bt;
	bus_dma_tag_t		sc_dmat;
	struct arpcom		sc_arpcom;
	struct timeout		sc_tick_tmo;
};

struct txp_fw_file_header {
	u_int8_t       	magicid[8];
	u_int32_t	version;
	u_int32_t	nsections;
	u_int32_t	addr;
};

struct txp_fw_section_header {
	u_int32_t	nbytes;
	u_int16_t	cksum;
	u_int16_t	reserved;
	u_int32_t	addr;
};

#define TXP_PCI_LOMEM                   0x14
#define WRITE_REG(sc,reg,val) \
    bus_space_write_4((sc)->sc_bt, (sc)->sc_bh, reg, val)
#define READ_REG(sc,reg) \
    bus_space_read_4((sc)->sc_bt, (sc)->sc_bh, reg)
/* end XXX not here */

d212 5
a216 2
	WRITE_REG(sc, TXP_INT_ENABLE_REGISTER, 0);
	WRITE_REG(sc, TXP_INT_MASK_REGISTER, 0x0000ffff);
d219 5
a223 1
	WRITE_REG(sc, TXP_INT_STATUS_REGISTER, 0xffffffff);
d229 5
a233 2
	WRITE_REG(sc, TXP_INT_ENABLE_REGISTER, 0);
	WRITE_REG(sc, TXP_INT_MASK_REGISTER, 0x0000ffff);
d236 5
a240 1
	WRITE_REG(sc, TXP_INT_STATUS_REGISTER, 0xffffffff);
d252 1
a252 1
	WRITE_REG(sc, TXP_SOFT_RESET_REGISTER, 0x7f);
d254 1
a254 1
	WRITE_REG(sc, TXP_SOFT_RESET_REGISTER, 0);
d258 2
a259 2
		r = READ_REG(sc, TXP_ARM2HOST_COMM_0_REGISTER);
		if (r == TYPHOON_WAITING_FOR_HOST_REQUEST)
d264 1
a264 1
	if (r != TYPHOON_WAITING_FOR_HOST_REQUEST) {
d281 5
a285 7
	ier = READ_REG(sc, TXP_INT_ENABLE_REGISTER);
	WRITE_REG(sc, TXP_INT_ENABLE_REGISTER,
	    ier | TYPHOON_INT_ARM2HOST_COMM_0);

	imr = READ_REG(sc, TXP_INT_MASK_REGISTER);
	WRITE_REG(sc, TXP_INT_MASK_REGISTER,
	    imr | TYPHOON_INT_ARM2HOST_COMM_0);
d288 2
a289 2
		r = READ_REG(sc, TXP_ARM2HOST_COMM_0_REGISTER);
		if (r == TYPHOON_WAITING_FOR_HOST_REQUEST)
d293 1
a293 1
	if (r != TYPHOON_WAITING_FOR_HOST_REQUEST) {
d299 1
a299 1
	WRITE_REG(sc, TXP_INT_STATUS_REGISTER, TYPHOON_INT_ARM2HOST_COMM_0);
d302 2
a303 2
	WRITE_REG(sc, TXP_HOST2ARM_COMM_1_REGISTER, fileheader->addr);
	WRITE_REG(sc, TXP_HOST2ARM_COMM_0_REGISTER, TYPHOON_BOOTCOMMAND_RUNTIME_IMAGE);
d326 1
a326 2
	WRITE_REG(sc, TXP_HOST2ARM_COMM_0_REGISTER,
	    TYPHOON_BOOTCOMMAND_DOWNLOAD_COMPLETE);
d329 2
a330 2
		r = READ_REG(sc, TXP_ARM2HOST_COMM_0_REGISTER);
		if (r == TYPHOON_WAITING_FOR_BOOT)
d334 1
a334 1
	if (r != TYPHOON_WAITING_FOR_BOOT) {
d339 2
a340 2
	WRITE_REG(sc, TXP_INT_ENABLE_REGISTER, ier);
	WRITE_REG(sc, TXP_INT_MASK_REGISTER, imr);
d352 2
a353 2
		r = READ_REG(sc, TXP_INT_STATUS_REGISTER);
		if (r & TYPHOON_INT_ARM2HOST_COMM_0)
d358 1
a358 1
	if (!(r & TYPHOON_INT_ARM2HOST_COMM_0)) {
d363 1
a363 1
	WRITE_REG(sc, TXP_INT_STATUS_REGISTER, TYPHOON_INT_ARM2HOST_COMM_0);
d365 2
a366 2
	r = READ_REG(sc, TXP_ARM2HOST_COMM_0_REGISTER);
	if (r != TYPHOON_WAITING_FOR_SEGMENT) {
d414 1
d416 1
d422 6
a427 7
	WRITE_REG(sc, TXP_HOST2ARM_COMM_1_REGISTER, sect->nbytes);
	WRITE_REG(sc, TXP_HOST2ARM_COMM_2_REGISTER, sect->cksum);
	WRITE_REG(sc, TXP_HOST2ARM_COMM_3_REGISTER, sect->addr);
	WRITE_REG(sc, TXP_HOST2ARM_COMM_4_REGISTER, pa >> 32);
	WRITE_REG(sc, TXP_HOST2ARM_COMM_5_REGISTER, pa & 0xffffffff);
	WRITE_REG(sc, TXP_HOST2ARM_COMM_0_REGISTER,
	    TYPHOON_BOOTCOMMAND_SEGMENT_AVAILABLE);
a431 1
		goto bail;
d434 1
a436 2

bail:
@

