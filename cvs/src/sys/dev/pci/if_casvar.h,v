head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.24
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.28
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.26
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.14
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.22
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.20
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.18
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.16
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.12
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.10
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.8
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.6
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.6
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.4
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.4.0.2
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.3.0.2
	OPENBSD_4_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.7
date	2010.09.20.07.40.38;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.13.12.18.58;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.26.17.15.32;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2007.04.15.16.31.30;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.27.21.19.40;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.25.21.54.52;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2007.02.24.20.13.34;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Stop doing shutdown hooks in network drivers where possible.  We already
take all interfaces down, via their xxstop routines.  Claudio and I have
verified that none of the shutdown hooks do much extra beyond what xxstop
was already doing; it is largely a pile of junk.
ok claudio, some early comments by sthen; also read by matthew, jsg
@
text
@/*	$OpenBSD: if_casvar.h,v 1.6 2009/06/13 12:18:58 kettenis Exp $	*/

/*
 *
 * Copyright (C) 2007 Mark Kettenis.
 * Copyright (C) 2001 Eduardo Horvath.
 * All rights reserved.
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR  ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR  BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#ifndef	_IF_CASVAR_H
#define	_IF_CASVAR_H

#include <sys/queue.h>
#include <sys/timeout.h>

/*
 * Misc. definitions for Sun Cassini ethernet controllers.
 */

/*
 * Preferred page size.  Cassini has a configurable page size, but
 * needs at least 8k to handle jumbo frames.  This happens to be the
 * default anyway.
 */
#define	CAS_PAGE_SIZE		8192

/*
 * Transmit descriptor ring size.  This is arbitrary, but allocate
 * enough descriptors for 64 pending transmissions and 16 segments
 * per packet.
 */
#define	CAS_NTXSEGS		16

#define	CAS_TXQUEUELEN		64
#define	CAS_NTXDESC		(CAS_TXQUEUELEN * CAS_NTXSEGS)
#define	CAS_NTXDESC_MASK	(CAS_NTXDESC - 1)
#define	CAS_NEXTTX(x)		((x + 1) & CAS_NTXDESC_MASK)

struct cas_sxd {
	struct mbuf *sd_mbuf;
	bus_dmamap_t sd_map;
};

/*
 * Receive descriptor ring size.  We have one Rx buffer per incoming
 * packet, so this logic is a little simpler.
 */
#define	CAS_NRXDESC		128
#define	CAS_NRXDESC_MASK	(CAS_NRXDESC - 1)

/*
 * Receive completion ring size.
 */
#define	CAS_NRXCOMP		256
#define	CAS_NRXCOMP_MASK	(CAS_NRXCOMP - 1)
#define	CAS_NEXTRX(x)		((x + 1) & CAS_NRXCOMP_MASK)

/*
 * Control structures are DMA'd to the Cassini chip.  We allocate them in
 * a single clump that maps to a single DMA segment to make several things
 * easier.
 */
struct cas_control_data {
	/*
	 * The transmit descriptors.
	 */
	struct cas_desc ccd_txdescs[CAS_NTXDESC];

	/*
	 * The receive completions.
	 */
	struct cas_comp ccd_rxcomps[CAS_NRXCOMP];

	/*
	 * The receive descriptors.
	 */
	struct cas_desc ccd_rxdescs[CAS_NRXDESC];
	char ccd_unused[CAS_PAGE_SIZE - CAS_NRXDESC * 16];
	struct cas_desc ccd_rxdescs2[CAS_NRXDESC];
};

#define	CAS_CDOFF(x)		offsetof(struct cas_control_data, x)
#define	CAS_CDTXOFF(x)		CAS_CDOFF(ccd_txdescs[(x)])
#define	CAS_CDRXOFF(x)		CAS_CDOFF(ccd_rxdescs[(x)])
#define	CAS_CDRXOFF2(x)		CAS_CDOFF(ccd_rxdescs2[(x)])
#define	CAS_CDRXCOFF(x)		CAS_CDOFF(ccd_rxcomps[(x)])

/*
 * Software state for receive jobs.
 */
struct cas_rxsoft {
	bus_dmamap_t rxs_dmamap;	/* our DMA map */
	bus_dma_segment_t rxs_dmaseg;	/* our DMA segment */
	caddr_t rxs_kva;
};

/*
 * Software state per device.
 */
struct cas_softc {
	struct device	sc_dev;		/* generic device information */
	struct arpcom	sc_arpcom;	/* ethernet common data */
	struct mii_data	sc_mii;		/* MII media control */
#define sc_media	sc_mii.mii_media/* shorthand */
	struct timeout	sc_tick_ch;	/* tick callout */

	bus_space_tag_t	sc_memt;
	bus_space_handle_t sc_memh;
	void		*sc_ih;

	bus_dma_tag_t	sc_dmatag;	/* bus dma tag */
	bus_dmamap_t	sc_dmamap;	/* bus dma handle */
	int		sc_burst;	/* DVMA burst size in effect */
	int		sc_phys[2];	/* MII instance -> PHY map */

	int		sc_mif_config;	/* Selected MII reg setting */

	/*
	 * Ring buffer DMA stuff.
	 */
	bus_dma_segment_t sc_cdseg;	/* control data memory */
	int		sc_cdnseg;	/* number of segments */
	bus_dmamap_t sc_cddmamap;	/* control data DMA map */
#define	sc_cddma	sc_cddmamap->dm_segs[0].ds_addr

	/*
	 * Software state for transmit and receive descriptors.
	 */
	struct cas_sxd sc_txd[CAS_NTXDESC];
	u_int32_t sc_tx_cnt, sc_tx_prod, sc_tx_cons;

	struct cas_rxsoft sc_rxsoft[CAS_NRXDESC];
	struct cas_rxsoft sc_rxsoft2[CAS_NRXDESC];

	/*
	 * Control data structures.
	 */
	struct cas_control_data *sc_control_data;
#define	sc_txdescs	sc_control_data->ccd_txdescs
#define	sc_rxdescs	sc_control_data->ccd_rxdescs
#define	sc_rxdescs2	sc_control_data->ccd_rxdescs2
#define	sc_rxcomps	sc_control_data->ccd_rxcomps

	int			sc_rxptr;		/* next ready RX descriptor/descsoft */
	int			sc_rxfifosize;
	int			sc_rxdptr;

	int			sc_rev;
	int			sc_inited;
	int			sc_debug;
};

/*
 * This maccro determines whether we have a Cassini+.
 */
#define	CAS_PLUS(sc)	(sc->sc_rev > 0x10)

#define	CAS_DMA_READ(v)		letoh64(v)
#define	CAS_DMA_WRITE(v)	htole64(v)

#define	CAS_CDTXADDR(sc, x)	((sc)->sc_cddma + CAS_CDTXOFF((x)))
#define	CAS_CDRXADDR(sc, x)	((sc)->sc_cddma + CAS_CDRXOFF((x)))
#define	CAS_CDRXADDR2(sc, x)	((sc)->sc_cddma + CAS_CDRXOFF2((x)))
#define	CAS_CDRXCADDR(sc, x)	((sc)->sc_cddma + CAS_CDRXCOFF((x)))

#define	CAS_CDTXSYNC(sc, x, n, ops)					\
do {									\
	int __x, __n;							\
									\
	__x = (x);							\
	__n = (n);							\
									\
	/* If it will wrap around, sync to the end of the ring. */	\
	if ((__x + __n) > CAS_NTXDESC) {				\
		bus_dmamap_sync((sc)->sc_dmatag, (sc)->sc_cddmamap,	\
		    CAS_CDTXOFF(__x), sizeof(struct cas_desc) *		\
		    (CAS_NTXDESC - __x), (ops));			\
		__n -= (CAS_NTXDESC - __x);				\
		__x = 0;						\
	}								\
									\
	/* Now sync whatever is left. */				\
	bus_dmamap_sync((sc)->sc_dmatag, (sc)->sc_cddmamap,		\
	    CAS_CDTXOFF(__x), sizeof(struct cas_desc) * __n, (ops));	\
} while (0)

#define	CAS_CDRXSYNC(sc, x, ops)					\
	bus_dmamap_sync((sc)->sc_dmatag, (sc)->sc_cddmamap,		\
	    CAS_CDRXOFF((x)), sizeof(struct cas_desc), (ops))

#define	CAS_CDRXCSYNC(sc, x, ops)					\
	bus_dmamap_sync((sc)->sc_dmatag, (sc)->sc_cddmamap,		\
	    CAS_CDRXCOFF((x)), sizeof(struct cas_desc), (ops))

#define	CAS_INIT_RXDESC(sc, d, s)					\
do {									\
	struct cas_rxsoft *__rxs = &sc->sc_rxsoft[(s)];			\
	struct cas_desc *__rxd = &sc->sc_rxdescs[(d)];			\
									\
	__rxd->cd_addr =						\
	    CAS_DMA_WRITE(__rxs->rxs_dmamap->dm_segs[0].ds_addr);	\
	__rxd->cd_flags =						\
	    CAS_DMA_WRITE((s));						\
	CAS_CDRXSYNC((sc), (d), BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE); \
} while (0)

#endif
@


1.6
log
@Simplify ioctl handling.  From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_casvar.h,v 1.5 2007/11/26 17:15:32 kettenis Exp $	*/
a173 1
	void			*sc_sh;		/* shutdownhook cookie */
@


1.5
log
@Make Cassini+ work; remove some unused macros while I'm there.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_casvar.h,v 1.4 2007/04/15 16:31:30 kettenis Exp $	*/
a137 2

	int		sc_if_flags;
@


1.4
log
@Give this code a chance to work on platforms where the page size isn't 8k.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_casvar.h,v 1.3 2007/02/27 21:19:40 kettenis Exp $	*/
d101 2
d108 1
d158 1
d166 1
d173 1
a173 1
	/* ========== */
a178 3
#define	CAS_DMA_READ(v)		letoh64(v)
#define	CAS_DMA_WRITE(v)	htole64(v)

d180 1
a180 1
 * This macro returns the current media entry for *non-MII* media.
d182 1
a182 3
#define	CAS_CURRENT_MEDIA(sc)						\
	(IFM_SUBTYPE((sc)->sc_mii.mii_media.ifm_cur->ifm_media) != IFM_AUTO ? \
	 (sc)->sc_mii.mii_media.ifm_cur : (sc)->sc_nway_active)
d184 2
a185 7
/*
 * This macro determines if a change to media-related OPMODE bits requires
 * a chip reset.
 */
#define	CAS_MEDIA_NEEDSRESET(sc, newbits)				\
	(((sc)->sc_opmode & OPMODE_MEDIA_BITS) !=			\
	 ((newbits) & OPMODE_MEDIA_BITS))
d189 1
@


1.3
log
@Cut away some dead wood.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_casvar.h,v 1.2 2007/02/25 21:54:52 kettenis Exp $	*/
d42 7
@


1.2
log
@Make receiving packets work.  Driver works well enough to do the commit over.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_casvar.h,v 1.1 2007/02/24 20:13:34 kettenis Exp $	*/
a104 1
	struct mbuf *rxs_mbuf;		/* head of our mbuf chain */
a109 21

/*
 * Table which describes the transmit threshold mode.  We generally
 * start at index 0.  Whenever we get a transmit underrun, we increment
 * our index, falling back if we encounter the NULL terminator.
 */
struct cas_txthresh_tab {
	u_int32_t txth_opmode;		/* OPMODE bits */
	const char *txth_name;		/* name of mode */
};

/*
 * Some misc. statics, useful for debugging.
 */
struct cas_stats {
	u_long		ts_tx_uf;	/* transmit underflow errors */
	u_long		ts_tx_to;	/* transmit jabber timeouts */
	u_long		ts_tx_ec;	/* excessive collision count */
	u_long		ts_tx_lc;	/* late collision count */
};

a132 5
	void *sc_sdhook;		/* shutdown hook */
	void *sc_powerhook;		/* power management hook */

	struct cas_stats sc_stats;	/* debugging stats */

a156 8
	int			sc_txfree;		/* number of free Tx descriptors */
	int			sc_txnext;		/* next ready Tx descriptor */

	u_int32_t		sc_tdctl_ch;		/* conditional desc chaining */
	u_int32_t		sc_tdctl_er;		/* conditional desc end-of-ring */

	u_int32_t		sc_setup_fsls;	/* FS|LS on setup descriptor */

a228 10

#ifdef _KERNEL
int	cas_mediachange(struct ifnet *);
void	cas_mediastatus(struct ifnet *, struct ifmediareq *);

void	cas_config(struct cas_softc *);
void	cas_reset(struct cas_softc *);
int	cas_intr(void *);
#endif /* _KERNEL */

@


1.1
log
@Start of a driver for Sun Cassini gigabit ethernet interfaces.  Driver can
send packets but not receive any yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d5 1
d44 1
a44 1
 * Transmit descriptor list size.  This is arbitrary, but allocate
d61 1
a61 1
 * Receive descriptor list size.  We have one Rx buffer per incoming
a65 1
#define	CAS_NEXTRX(x)		((x + 1) & CAS_NRXDESC_MASK)
d68 8
a75 1
 * Control structures are DMA'd to the GEM chip.  We allocate them in
d83 6
a88 1
	struct cas_desc gcd_txdescs[CAS_NTXDESC];
d93 1
a93 1
	struct cas_desc gcd_rxdescs[CAS_NRXDESC];
d97 3
a99 2
#define	CAS_CDTXOFF(x)		CAS_CDOFF(gcd_txdescs[(x)])
#define	CAS_CDRXOFF(x)		CAS_CDOFF(gcd_rxdescs[(x)])
d107 2
d180 3
a182 2
#define	sc_txdescs	sc_control_data->gcd_txdescs
#define	sc_rxdescs	sc_control_data->gcd_rxdescs
d194 1
d202 2
a203 2
#define	CAS_DMA_READ(sc, v)	letoh64(v)
#define	CAS_DMA_WRITE(sc, v)	htole64(v)
d222 1
a222 2

#define	CAS_CDSPADDR(sc)	((sc)->sc_cddma + CAS_CDSPOFF)
d249 1
a249 1
#define	CAS_CDSPSYNC(sc, ops)						\
d251 1
a251 1
	    CAS_CDSPOFF, CAS_SETUP_PACKET_LEN, (ops))
d253 1
a253 1
#define	CAS_INIT_RXDESC(sc, x)						\
d255 2
a256 3
	struct cas_rxsoft *__rxs = &sc->sc_rxsoft[(x)];			\
	struct cas_desc *__rxd = &sc->sc_rxdescs[(x)];			\
	struct mbuf *__m = __rxs->rxs_mbuf;				\
d258 5
a262 8
	__m->m_data = __m->m_ext.ext_buf;				\
	__rxd->gd_addr =						\
	    CAS_DMA_WRITE((sc), __rxs->rxs_dmamap->dm_segs[0].ds_addr);	\
	__rxd->gd_flags =						\
	    CAS_DMA_WRITE((sc),						\
		(((__m->m_ext.ext_size)<<CAS_RD_BUFSHIFT)		\
	    & CAS_RD_BUFSIZE) | CAS_RD_OWN);				\
	CAS_CDRXSYNC((sc), (x), BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE); \
@

