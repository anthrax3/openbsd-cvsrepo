head	1.32;
access;
symbols
	OPENBSD_6_0:1.32.0.14
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.32.0.10
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.8
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.32.0.6
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.28.0.2
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.26.0.6
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.4
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.25.0.4
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.23.0.6
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.8
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.4
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.21.0.4
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	SMP:1.3.0.4
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	UBC_SYNC_B:1.2
	OPENBSD_3_2:1.2.0.4
	OPENBSD_3_2_BASE:1.2
	UBC:1.2.0.2;
locks; strict;
comment	@ * @;


1.32
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2013.10.01.20.06.00;	author sf;	state Exp;
branches;
next	1.30;

1.30
date	2013.07.03.15.34.48;	author sf;	state Exp;
branches;
next	1.29;

1.29
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2012.10.05.10.51.28;	author haesbaert;	state Exp;
branches;
next	1.27;

1.27
date	2012.08.16.18.41.17;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2011.04.09.04.33.40;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2010.08.08.04.49.25;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.06.12.39.03;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.03.09.36.26;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2006.12.11.18.16.37;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.28.16.17.57;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2006.09.28.18.19.14;	author grange;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.09.00.39.04;	author dlg;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.08.22.59.14;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.08.09.58.44;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.08.09.21.14;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.07.11.56.23;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.15.10.28.17;	author grange;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.09.19.32.14;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.06.00.18.35;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.05.10.43.15;	author grange;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.05.08.57.27;	author grange;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.05.08.54.27;	author grange;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.02.04.01.43;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.17.10.18.01;	author grange;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.28.17.15.12;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.04.17.12.34;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.05.22.49.49;	author mickey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2002.06.05.22.35.16;	author mickey;	state Exp;
branches;
next	;

1.2.2.1
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2003.05.19.22.17.59;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@/*	$OpenBSD: amdpm.c,v 1.31 2013/10/01 20:06:00 sf Exp $	*/

/*
 * Copyright (c) 2006 Alexander Yurchenko <grange@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*-
 * Copyright (c) 2002 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Enami Tsugutomo.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/rwlock.h>
#include <sys/timeout.h>
#include <sys/timetc.h>

#include <machine/bus.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <dev/rndvar.h>
#include <dev/i2c/i2cvar.h>

#ifdef AMDPM_DEBUG
#define DPRINTF(x...) printf(x)
#else
#define DPRINTF(x...)
#endif

#define AMDPM_SMBUS_DELAY	100
#define AMDPM_SMBUS_TIMEOUT	1

u_int amdpm_get_timecount(struct timecounter *tc);

#ifndef AMDPM_FREQUENCY
#define AMDPM_FREQUENCY 3579545
#endif

static struct timecounter amdpm_timecounter = {
	amdpm_get_timecount,	/* get_timecount */
	0,			/* no poll_pps */
	0xffffff,		/* counter_mask */
	AMDPM_FREQUENCY,	/* frequency */
	"AMDPM",		/* name */
	1000			/* quality */
};

#define	AMDPM_CONFREG	0x40

/* 0x40: General Configuration 1 Register */
#define	AMDPM_RNGEN	0x00000080	/* random number generator enable */
#define	AMDPM_STOPTMR	0x00000040	/* stop free-running timer */

/* 0x41: General Configuration 2 Register */
#define	AMDPM_PMIOEN	0x00008000	/* system management IO space enable */
#define	AMDPM_TMRRST	0x00004000	/* reset free-running timer */
#define	AMDPM_TMR32	0x00000800	/* extended (32 bit) timer enable */

/* 0x42: SCI Interrupt Configuration Register */
/* 0x43: Previous Power State Register */

#define	AMDPM_PMPTR	0x58		/* PMxx System Management IO space
					   Pointer */
#define NFPM_PMPTR	0x14		/* nForce System Management IO space
					   POinter */
#define	AMDPM_PMBASE(x)	((x) & 0xff00)	/* PMxx base address */
#define	AMDPM_PMSIZE	256		/* PMxx space size */

/* Registers in PMxx space */
#define	AMDPM_TMR	0x08		/* 24/32 bit timer register */

#define	AMDPM_RNGDATA	0xf0		/* 32 bit random data register */
#define	AMDPM_RNGSTAT	0xf4		/* RNG status register */
#define	AMDPM_RNGDONE	0x00000001	/* Random number generation complete */

#define AMDPM_SMB_REGS  0xe0		/* offset of SMB register space */
#define AMDPM_SMB_SIZE  0xf		/* size of SMB register space */ 
#define AMDPM_SMBSTAT	0x0		/* SMBus status */
#define AMDPM_SMBSTAT_ABRT	(1 << 0)	/* transfer abort */
#define AMDPM_SMBSTAT_COL	(1 << 1)	/* collision */
#define AMDPM_SMBSTAT_PRERR	(1 << 2)	/* protocol error */
#define AMDPM_SMBSTAT_HBSY	(1 << 3)	/* host controller busy */
#define AMDPM_SMBSTAT_CYC	(1 << 4)	/* cycle complete */
#define AMDPM_SMBSTAT_TO	(1 << 5)	/* timeout */
#define AMDPM_SMBSTAT_SNP	(1 << 8)	/* snoop address match */
#define AMDPM_SMBSTAT_SLV	(1 << 9)	/* slave address match */
#define AMDPM_SMBSTAT_SMBA	(1 << 10)	/* SMBALERT# asserted */
#define AMDPM_SMBSTAT_BSY	(1 << 11)	/* bus busy */
#define AMDPM_SMBSTAT_BITS	"\020\001ABRT\002COL\003PRERR\004HBSY\005CYC\006TO\011SNP\012SLV\013SMBA\014BSY"
#define AMDPM_SMBCTL	0x2		/* SMBus control */
#define AMDPM_SMBCTL_CMD_QUICK	0		/* QUICK command */
#define AMDPM_SMBCTL_CMD_BYTE	1		/* BYTE command */
#define AMDPM_SMBCTL_CMD_BDATA	2		/* BYTE DATA command */
#define AMDPM_SMBCTL_CMD_WDATA	3		/* WORD DATA command */
#define AMDPM_SMBCTL_CMD_PCALL	4		/* PROCESS CALL command */
#define AMDPM_SMBCTL_CMD_BLOCK	5		/* BLOCK command */
#define AMDPM_SMBCTL_START	(1 << 3)	/* start transfer */
#define AMDPM_SMBCTL_CYCEN	(1 << 4)	/* intr on cycle complete */
#define AMDPM_SMBCTL_ABORT	(1 << 5)	/* abort transfer */
#define AMDPM_SMBCTL_SNPEN	(1 << 8)	/* intr on snoop addr match */
#define AMDPM_SMBCTL_SLVEN	(1 << 9)	/* intr on slave addr match */
#define AMDPM_SMBCTL_SMBAEN	(1 << 10)	/* intr on SMBALERT# */
#define AMDPM_SMBADDR	0x4		/* SMBus address */
#define AMDPM_SMBADDR_READ	(1 << 0)	/* read direction */
#define AMDPM_SMBADDR_ADDR(x)	(((x) & 0x7f) << 1) /* 7-bit address */
#define AMDPM_SMBDATA	0x6		/* SMBus data */
#define AMDPM_SMBCMD	0x8		/* SMBus command */


struct amdpm_softc {
	struct device sc_dev;

	pci_chipset_tag_t sc_pc;
	pcitag_t sc_tag;

	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;		/* PMxx space */
	bus_space_handle_t sc_i2c_ioh;		/* I2C space */
	int sc_poll;

	struct timeout sc_rnd_ch;

	struct i2c_controller sc_i2c_tag;
	struct rwlock sc_i2c_lock;
	struct {
		i2c_op_t op;
		void *buf;
		size_t len;
		int flags;
		volatile int error;
	} sc_i2c_xfer;
};

int	amdpm_match(struct device *, void *, void *);
void	amdpm_attach(struct device *, struct device *, void *);
int	amdpm_activate(struct device *, int);
void	amdpm_rnd_callout(void *);

int	amdpm_i2c_acquire_bus(void *, int);
void	amdpm_i2c_release_bus(void *, int);
int	amdpm_i2c_exec(void *, i2c_op_t, i2c_addr_t, const void *, size_t,
	    void *, size_t, int);

int	amdpm_intr(void *);

struct cfattach amdpm_ca = {
	sizeof(struct amdpm_softc), amdpm_match, amdpm_attach,
	NULL, amdpm_activate
};

struct cfdriver amdpm_cd = {
	NULL, "amdpm", DV_DULL
};

const struct pci_matchid amdpm_ids[] = {
	{ PCI_VENDOR_AMD, PCI_PRODUCT_AMD_PBC756_PMC },
	{ PCI_VENDOR_AMD, PCI_PRODUCT_AMD_766_PMC },
	{ PCI_VENDOR_AMD, PCI_PRODUCT_AMD_PBC768_PMC },
	{ PCI_VENDOR_AMD, PCI_PRODUCT_AMD_8111_PMC },
	{ PCI_VENDOR_NVIDIA, PCI_PRODUCT_NVIDIA_NFORCE_SMB }
};

int
amdpm_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid(aux, amdpm_ids,
	    sizeof(amdpm_ids) / sizeof(amdpm_ids[0])));
}

void
amdpm_attach(struct device *parent, struct device *self, void *aux)
{
	struct amdpm_softc *sc = (struct amdpm_softc *) self;
	struct pci_attach_args *pa = aux;
	struct i2cbus_attach_args iba;
	pcireg_t cfg_reg, reg;
	int i;

	sc->sc_pc = pa->pa_pc;
	sc->sc_tag = pa->pa_tag;
	sc->sc_iot = pa->pa_iot;
	sc->sc_poll = 1; /* XXX */

	
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_AMD)  {
		cfg_reg = pci_conf_read(pa->pa_pc, pa->pa_tag, AMDPM_CONFREG);
		if ((cfg_reg & AMDPM_PMIOEN) == 0) {
			printf(": PMxx space isn't enabled\n");
			return;
		}

		reg = pci_conf_read(pa->pa_pc, pa->pa_tag, AMDPM_PMPTR);
		if (AMDPM_PMBASE(reg) == 0 ||
		    bus_space_map(sc->sc_iot, AMDPM_PMBASE(reg), AMDPM_PMSIZE,
		    0, &sc->sc_ioh)) {
			printf("\n");
			return;
		}
		if (bus_space_subregion(sc->sc_iot, sc->sc_ioh, AMDPM_SMB_REGS,
		    AMDPM_SMB_SIZE, &sc->sc_i2c_ioh)) {
			printf(": failed to map I2C subregion\n");
			return;	
		}

		if ((cfg_reg & AMDPM_TMRRST) == 0 &&
		    (cfg_reg & AMDPM_STOPTMR) == 0 &&
		    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AMD_PBC768_PMC ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AMD_8111_PMC)) {
			printf(": %d-bit timer at %lluHz",
			    (cfg_reg & AMDPM_TMR32) ? 32 : 24,
			    amdpm_timecounter.tc_frequency);

			amdpm_timecounter.tc_priv = sc;
			if (cfg_reg & AMDPM_TMR32)
				amdpm_timecounter.tc_counter_mask = 0xffffffffu;
			tc_init(&amdpm_timecounter);
		}	
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AMD_PBC768_PMC ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AMD_8111_PMC) {
			if ((cfg_reg & AMDPM_RNGEN) ==0) {
				pci_conf_write(pa->pa_pc, pa->pa_tag, 
				    AMDPM_CONFREG, cfg_reg | AMDPM_RNGEN);
				cfg_reg = pci_conf_read(pa->pa_pc, pa->pa_tag,
				    AMDPM_CONFREG);
			}
			if (cfg_reg & AMDPM_RNGEN) {
			/* Check to see if we can read data from the RNG. */
				(void) bus_space_read_4(sc->sc_iot, sc->sc_ioh,
				    AMDPM_RNGDATA);
				for (i = 1000; i--; ) {
					if (bus_space_read_1(sc->sc_iot, 
					    sc->sc_ioh, AMDPM_RNGSTAT) & 
					    AMDPM_RNGDONE)
						break;
					DELAY(10);
				}
				if (bus_space_read_1(sc->sc_iot, sc->sc_ioh,
				    AMDPM_RNGSTAT) & AMDPM_RNGDONE) {
					printf(": rng active");
					timeout_set(&sc->sc_rnd_ch, 
					    amdpm_rnd_callout, sc);
					amdpm_rnd_callout(sc);
				}
			}
		}
	} else if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_NVIDIA) {
		reg = pci_conf_read(pa->pa_pc, pa->pa_tag, NFPM_PMPTR);
		if (AMDPM_PMBASE(reg) == 0 ||
		    bus_space_map(sc->sc_iot, AMDPM_PMBASE(reg), AMDPM_SMB_SIZE, 0,
		    &sc->sc_i2c_ioh)) {
			printf(": failed to map I2C subregion\n");
			return;
		}
	}
	printf("\n");

	/* Attach I2C bus */
	rw_init(&sc->sc_i2c_lock, "iiclk");
	sc->sc_i2c_tag.ic_cookie = sc;
	sc->sc_i2c_tag.ic_acquire_bus = amdpm_i2c_acquire_bus;
	sc->sc_i2c_tag.ic_release_bus = amdpm_i2c_release_bus;
	sc->sc_i2c_tag.ic_exec = amdpm_i2c_exec;

	bzero(&iba, sizeof(iba));
	iba.iba_name = "iic";
	iba.iba_tag = &sc->sc_i2c_tag;
	config_found(self, &iba, iicbus_print);
}

int
amdpm_activate(struct device *self, int act)
{
	struct amdpm_softc *sc = (struct amdpm_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_RESUME:
		if (timeout_initialized(&sc->sc_rnd_ch)) {
			pcireg_t cfg_reg;

			/* Restart the AMD PBC768_PMC/8111_PMC RNG */
			cfg_reg = pci_conf_read(sc->sc_pc, sc->sc_tag,
			    AMDPM_CONFREG);
			pci_conf_write(sc->sc_pc, sc->sc_tag, 
			    AMDPM_CONFREG, cfg_reg | AMDPM_RNGEN);
		
		}
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

void
amdpm_rnd_callout(void *v)
{
	struct amdpm_softc *sc = v;
	u_int32_t reg;

	if ((bus_space_read_4(sc->sc_iot, sc->sc_ioh, AMDPM_RNGSTAT) &
	    AMDPM_RNGDONE) != 0) {
		reg = bus_space_read_4(sc->sc_iot, sc->sc_ioh, AMDPM_RNGDATA);
		add_true_randomness(reg);
	}
	timeout_add(&sc->sc_rnd_ch, 1);
}

u_int
amdpm_get_timecount(struct timecounter *tc)
{
	struct amdpm_softc *sc = tc->tc_priv;
	u_int u2;
#if 0
	u_int u1, u3;
#endif

	u2 = bus_space_read_4(sc->sc_iot, sc->sc_ioh, AMDPM_TMR);
#if 0
	u3 = bus_space_read_4(sc->sc_iot, sc->sc_ioh, AMDPM_TMR);
	do {
		u1 = u2;
		u2 = u3;
		u3 = bus_space_read_4(sc->sc_iot, sc->sc_ioh, AMDPM_TMR);
	} while (u1 > u2 || u2 > u3);
#endif
	return (u2);
}

int
amdpm_i2c_acquire_bus(void *cookie, int flags)
{
	struct amdpm_softc *sc = cookie;

	if (cold || sc->sc_poll || (flags & I2C_F_POLL))
		return (0);

	return (rw_enter(&sc->sc_i2c_lock, RW_WRITE | RW_INTR));
}

void
amdpm_i2c_release_bus(void *cookie, int flags)
{
	struct amdpm_softc *sc = cookie;

	if (cold || sc->sc_poll || (flags & I2C_F_POLL))
		return;

	rw_exit(&sc->sc_i2c_lock);
}

int
amdpm_i2c_exec(void *cookie, i2c_op_t op, i2c_addr_t addr,
    const void *cmdbuf, size_t cmdlen, void *buf, size_t len, int flags)
{
	struct amdpm_softc *sc = cookie;
	u_int8_t *b;
	u_int16_t st, ctl, data;
	int retries;

	DPRINTF("%s: exec: op %d, addr 0x%02x, cmdlen %d, len %d, "
	    "flags 0x%02x\n", sc->sc_dev.dv_xname, op, addr, cmdlen,
	    len, flags);

	/* Wait for bus to be idle */
	for (retries = 100; retries > 0; retries--) {
		st = bus_space_read_2(sc->sc_iot, sc->sc_i2c_ioh, AMDPM_SMBSTAT);
		if (!(st & AMDPM_SMBSTAT_BSY))
			break;
		DELAY(AMDPM_SMBUS_DELAY);
	}
	DPRINTF("%s: exec: st 0x%b\n", sc->sc_dev.dv_xname, st,
	    AMDPM_SMBSTAT_BITS);
	if (st & AMDPM_SMBSTAT_BSY)
		return (1);

	if (cold || sc->sc_poll)
		flags |= I2C_F_POLL;

	if (!I2C_OP_STOP_P(op) || cmdlen > 1 || len > 2)
		return (1);

	/* Setup transfer */
	sc->sc_i2c_xfer.op = op;
	sc->sc_i2c_xfer.buf = buf;
	sc->sc_i2c_xfer.len = len;
	sc->sc_i2c_xfer.flags = flags;
	sc->sc_i2c_xfer.error = 0;

	/* Set slave address and transfer direction */
	bus_space_write_2(sc->sc_iot, sc->sc_i2c_ioh, AMDPM_SMBADDR,
	    AMDPM_SMBADDR_ADDR(addr) |
	    (I2C_OP_READ_P(op) ? AMDPM_SMBADDR_READ : 0));

	b = (void *)cmdbuf;
	if (cmdlen > 0)
		/* Set command byte */
		bus_space_write_1(sc->sc_iot, sc->sc_i2c_ioh, AMDPM_SMBCMD, b[0]);

	if (I2C_OP_WRITE_P(op)) {
		/* Write data */
		data = 0;
		b = buf;
		if (len > 0)
			data = b[0];
		if (len > 1)
			data |= ((u_int16_t)b[1] << 8);
		if (len > 0)
			bus_space_write_2(sc->sc_iot, sc->sc_i2c_ioh,
			    AMDPM_SMBDATA, data);
	}

	/* Set SMBus command */
	if (len == 0)
		ctl = AMDPM_SMBCTL_CMD_BYTE;
	else if (len == 1)
		ctl = AMDPM_SMBCTL_CMD_BDATA;
	else if (len == 2)
		ctl = AMDPM_SMBCTL_CMD_WDATA;
	else
		panic("%s: unexpected len %zd", __func__, len);

	if ((flags & I2C_F_POLL) == 0)
		ctl |= AMDPM_SMBCTL_CYCEN;

	/* Start transaction */
	ctl |= AMDPM_SMBCTL_START;
	bus_space_write_2(sc->sc_iot, sc->sc_i2c_ioh, AMDPM_SMBCTL, ctl);

	if (flags & I2C_F_POLL) {
		/* Poll for completion */
		DELAY(AMDPM_SMBUS_DELAY);
		for (retries = 1000; retries > 0; retries--) {
			st = bus_space_read_2(sc->sc_iot, sc->sc_i2c_ioh,
			    AMDPM_SMBSTAT);
			if ((st & AMDPM_SMBSTAT_HBSY) == 0)
				break;
			DELAY(AMDPM_SMBUS_DELAY);
		}
		if (st & AMDPM_SMBSTAT_HBSY)
			goto timeout;
		amdpm_intr(sc);
	} else {
		/* Wait for interrupt */
		if (tsleep(sc, PRIBIO, "amdpm", AMDPM_SMBUS_TIMEOUT * hz))
			goto timeout;
	}

	if (sc->sc_i2c_xfer.error)
		return (1);

	return (0);

timeout:
	/*
	 * Transfer timeout. Kill the transaction and clear status bits.
	 */
	printf("%s: exec: op %d, addr 0x%02x, cmdlen %zu, len %zu, "
	    "flags 0x%02x: timeout, status 0x%b\n",
	    sc->sc_dev.dv_xname, op, addr, cmdlen, len, flags,
	    st, AMDPM_SMBSTAT_BITS);
	bus_space_write_2(sc->sc_iot, sc->sc_i2c_ioh, AMDPM_SMBCTL,
	    AMDPM_SMBCTL_ABORT);
	DELAY(AMDPM_SMBUS_DELAY);
	st = bus_space_read_2(sc->sc_iot, sc->sc_i2c_ioh, AMDPM_SMBSTAT);
	if ((st & AMDPM_SMBSTAT_ABRT) == 0)
		printf("%s: abort failed, status 0x%b\n",
		    sc->sc_dev.dv_xname, st, AMDPM_SMBSTAT_BITS);
	bus_space_write_2(sc->sc_iot, sc->sc_i2c_ioh, AMDPM_SMBSTAT, st);
	return (1);
}

int
amdpm_intr(void *arg)
{
	struct amdpm_softc *sc = arg;
	u_int16_t st, data;
	u_int8_t *b;
	size_t len;

	/* Read status */
	st = bus_space_read_2(sc->sc_iot, sc->sc_i2c_ioh, AMDPM_SMBSTAT);
	if ((st & AMDPM_SMBSTAT_HBSY) != 0 || (st & (AMDPM_SMBSTAT_ABRT |
	    AMDPM_SMBSTAT_COL | AMDPM_SMBSTAT_PRERR | AMDPM_SMBSTAT_CYC |
	    AMDPM_SMBSTAT_TO | AMDPM_SMBSTAT_SNP | AMDPM_SMBSTAT_SLV |
	    AMDPM_SMBSTAT_SMBA)) == 0)
		/* Interrupt was not for us */
		return (0);

	DPRINTF("%s: intr: st 0x%b\n", sc->sc_dev.dv_xname, st,
	    AMDPM_SMBSTAT_BITS);

	/* Clear status bits */
	bus_space_write_2(sc->sc_iot, sc->sc_i2c_ioh, AMDPM_SMBSTAT, st);

	/* Check for errors */
	if (st & (AMDPM_SMBSTAT_COL | AMDPM_SMBSTAT_PRERR |
	    AMDPM_SMBSTAT_TO)) {
		sc->sc_i2c_xfer.error = 1;
		goto done;
	}

	if (st & AMDPM_SMBSTAT_CYC) {
		if (I2C_OP_WRITE_P(sc->sc_i2c_xfer.op))
			goto done;

		/* Read data */
		b = sc->sc_i2c_xfer.buf;
		len = sc->sc_i2c_xfer.len;
		if (len > 0) {
			data = bus_space_read_2(sc->sc_iot, sc->sc_i2c_ioh,
			    AMDPM_SMBDATA);
			b[0] = data & 0xff;
		}
		if (len > 1)
			b[1] = (data >> 8) & 0xff;
	}

done:
	if ((sc->sc_i2c_xfer.flags & I2C_F_POLL) == 0)
		wakeup(sc);
	return (1);
}
@


1.31
log
@Use %z* for size_t

while there, fix a few %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.30 2013/07/03 15:34:48 sf Exp $	*/
d315 1
a315 1
	int ret = 0;
a317 6
	case DVACT_QUIESCE:
		ret = config_activate_children(self, act);
		break;
	case DVACT_SUSPEND:
		ret = config_activate_children(self, act);
		break;
d329 1
a329 1
		ret = config_activate_children(self, act);
d331 2
a332 2
	case DVACT_POWERDOWN:
		ret = config_activate_children(self, act);
d335 1
a335 1
	return (ret);
@


1.30
log
@fix: cast void * to char *, fix format args for (u)int64_t,
tc_frequency is unsigned

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.29 2013/05/30 16:15:02 deraadt Exp $	*/
d507 1
a507 1
	printf("%s: exec: op %d, addr 0x%02x, cmdlen %d, len %d, "
@


1.29
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.28 2012/10/05 10:51:28 haesbaert Exp $	*/
d250 1
a250 1
			printf(": %d-bit timer at %dHz",
@


1.28
log
@Avoid uninitiliazed use of ctl and corresponding warnings.
Part of the work to remove -Wno-uninitialized.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.27 2012/08/16 18:41:17 tedu Exp $	*/
d188 2
a189 2
	sizeof(struct amdpm_softc), amdpm_match, amdpm_attach, NULL,
	amdpm_activate
d315 1
d318 6
d335 4
d341 1
a341 1
	return (0);
@


1.27
log
@we are past the point where timecounters may disappear
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.26 2011/04/09 04:33:40 deraadt Exp $	*/
d458 2
@


1.26
log
@use unique wait channels
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.25 2010/08/08 04:49:25 deraadt Exp $	*/
a53 1
#ifdef __HAVE_TIMECOUNTER
a54 1
#endif
a73 1
#ifdef __HAVE_TIMECOUNTER
a87 1
#endif
a245 1
#ifdef __HAVE_TIMECOUNTER
a258 1
#endif
a346 1
#ifdef __HAVE_TIMECOUNTER
a366 1
#endif
@


1.25
log
@at resume time, re-nable the AMDPM_RNGEN bit
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.24 2010/04/08 00:23:53 tedu Exp $	*/
d489 1
a489 1
		if (tsleep(sc, PRIBIO, "iicexec", AMDPM_SMBUS_TIMEOUT * hz))
@


1.24
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.23 2008/06/26 05:42:17 ray Exp $	*/
d181 1
d192 2
a193 1
	sizeof(struct amdpm_softc), amdpm_match, amdpm_attach
d315 22
@


1.23
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.22 2008/05/06 12:39:03 markus Exp $	*/
a52 1
#include <sys/proc.h>
@


1.22
log
@AMD_8111_PMC has timecounter, too; ok grange@@ some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.21 2007/05/03 09:36:26 dlg Exp $	*/
a33 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.21
log
@convert lockmgr style locks to rwlocks.

input from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.20 2006/12/11 18:16:37 deraadt Exp $	*/
d259 2
a260 1
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AMD_PBC768_PMC) {
@


1.20
log
@do not bus_space_map devices which are at address 0; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.19 2006/11/28 16:17:57 kettenis Exp $	*/
d59 1
a59 1
#include <sys/lock.h>
d177 1
a177 1
	struct lock sc_i2c_lock;
d310 1
a310 1
	lockinit(&sc->sc_i2c_lock, PRIBIO | PCATCH, "iiclk", 0, 0);
d367 1
a367 1
	return (lockmgr(&sc->sc_i2c_lock, LK_EXCLUSIVE, NULL));
d378 1
a378 1
	lockmgr(&sc->sc_i2c_lock, LK_RELEASE, NULL);
@


1.19
log
@acpi may steal power management functionality, in which case we
cannot io map the device.  Bail out without warning.  If we want
to retain the rgn we could re-enable io and be very very careful.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.18 2006/09/28 18:19:14 grange Exp $	*/
d244 2
a245 1
		if (bus_space_map(sc->sc_iot, AMDPM_PMBASE(reg), AMDPM_PMSIZE,
d300 2
a301 1
		if (bus_space_map(sc->sc_iot, AMDPM_PMBASE(reg), AMDPM_SMB_SIZE, 0,
@


1.18
log
@Provide more info in error messages so we can see what's going
on. And some cosmetics in debug messages while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.17 2006/03/09 00:39:04 dlg Exp $	*/
d244 3
a246 3
		if (bus_space_map(sc->sc_iot, AMDPM_PMBASE(reg), AMDPM_PMSIZE, 0, 
		    &sc->sc_ioh)) {
			printf(": failed to map PMxx space\n");
@


1.17
log
@unbreak the tree. i dunno how this compiled on my box at home.

found by marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.16 2006/03/08 22:59:14 dlg Exp $	*/
d388 3
a390 2
	DPRINTF("%s: exec: op %d, addr 0x%x, cmdlen %d, len %d, flags 0x%x\n",
	    sc->sc_dev.dv_xname, op, addr, cmdlen, len, flags);
d483 4
a486 2
	printf("%s: timeout, status 0x%b\n", sc->sc_dev.dv_xname, st,
	    AMDPM_SMBSTAT_BITS);
d492 1
a492 1
		printf("%s: transaction abort failed, status 0x%b\n",
@


1.16
log
@amdpmreg.h is only used by amdpm.c, so merge the header into the c file.
this unclutters the tree a bit.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.15 2006/03/08 09:58:44 dlg Exp $	*/
a71 2
#include <dev/pci/amdpmreg.h>

d91 9
a161 9
static struct timecounter amdpm_timecounter = {
	amdpm_get_timecount,	/* get_timecount */
	0,			/* no poll_pps */
	0xffffff,		/* counter_mask */
	AMDPM_FREQUENCY,	/* frequency */
	"AMDPM",		/* name */
	1000			/* quality */
};
#endif
@


1.15
log
@tweak the debug macros a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.14 2006/03/08 09:21:14 dlg Exp $	*/
d92 62
@


1.14
log
@fix support for the smbus controller on nforce 1 chipsets. only try to
use the timer and rng on amd chips.

diff, testing, and patience from gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.13 2006/03/07 11:56:23 dlg Exp $	*/
d78 1
a78 1
#define DPRINTF(x) printf x
d80 1
a80 1
#define DPRINTF(x)
d328 2
a329 2
	DPRINTF(("%s: exec: op %d, addr 0x%x, cmdlen %d, len %d, flags 0x%x\n",
	    sc->sc_dev.dv_xname, op, addr, cmdlen, len, flags));
d338 2
a339 2
	DPRINTF(("%s: exec: st 0x%b\n", sc->sc_dev.dv_xname, st,
	    AMDPM_SMBSTAT_BITS));
d452 2
a453 2
	DPRINTF(("%s: intr: st 0x%b\n", sc->sc_dev.dv_xname, st,
	    AMDPM_SMBSTAT_BITS));
@


1.13
log
@whitespace fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.12 2006/01/15 10:28:17 grange Exp $	*/
d111 1
d168 1
a168 1
	int i, base;
d175 19
a193 17
	cfg_reg = pci_conf_read(pa->pa_pc, pa->pa_tag, AMDPM_CONFREG);
	if ((cfg_reg & AMDPM_PMIOEN) == 0) {
		printf(": PMxx space isn't enabled\n");
		return;
	}
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_NVIDIA)
		base = NFPM_PMPTR;
	else
		/* PCI_VENDOR_AMD */
		base = AMDPM_PMPTR;

	reg = pci_conf_read(pa->pa_pc, pa->pa_tag, base);
	if (bus_space_map(sc->sc_iot, AMDPM_PMBASE(reg), AMDPM_PMSIZE,
	    0, &sc->sc_ioh)) {
		printf(": failed to map PMxx space\n");
		return;
	}
d196 12
a207 12
	if ((cfg_reg & AMDPM_TMRRST) == 0 &&
	    (cfg_reg & AMDPM_STOPTMR) == 0 &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AMD_PBC768_PMC) {
		printf(": %d-bit timer at %dHz",
		    (cfg_reg & AMDPM_TMR32) ? 32 : 24,
		    amdpm_timecounter.tc_frequency);

		amdpm_timecounter.tc_priv = sc;
		if (cfg_reg & AMDPM_TMR32)
			amdpm_timecounter.tc_counter_mask = 0xffffffffu;
		tc_init(&amdpm_timecounter);
	}
d209 9
a217 9
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AMD_PBC768_PMC ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AMD_8111_PMC) {
		if ((cfg_reg & AMDPM_RNGEN) ==0) {
			pci_conf_write(pa->pa_pc, pa->pa_tag, AMDPM_CONFREG,
			    cfg_reg | AMDPM_RNGEN);
			cfg_reg = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    AMDPM_CONFREG);
		}
		if (cfg_reg & AMDPM_RNGEN) {
d219 9
a227 3
			(void) bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			    AMDPM_RNGDATA);
			for (i = 1000; i--; ) {
d229 6
a234 10
				    AMDPM_RNGSTAT) & AMDPM_RNGDONE)
					break;
				DELAY(10);
			}
			if (bus_space_read_1(sc->sc_iot, sc->sc_ioh,
			    AMDPM_RNGSTAT) & AMDPM_RNGDONE) {
				printf(": rng active");
				timeout_set(&sc->sc_rnd_ch, amdpm_rnd_callout,
				    sc);
				amdpm_rnd_callout(sc);
d236 7
d333 1
a333 1
		st = bus_space_read_2(sc->sc_iot, sc->sc_ioh, AMDPM_SMBSTAT);
d357 1
a357 1
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, AMDPM_SMBADDR,
d364 1
a364 1
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, AMDPM_SMBCMD, b[0]);
d375 1
a375 1
			bus_space_write_2(sc->sc_iot, sc->sc_ioh,
d392 1
a392 1
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, AMDPM_SMBCTL, ctl);
d398 1
a398 1
			st = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
d424 1
a424 1
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, AMDPM_SMBCTL,
d427 1
a427 1
	st = bus_space_read_2(sc->sc_iot, sc->sc_ioh, AMDPM_SMBSTAT);
d431 1
a431 1
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, AMDPM_SMBSTAT, st);
d444 1
a444 1
	st = bus_space_read_2(sc->sc_iot, sc->sc_ioh, AMDPM_SMBSTAT);
d456 1
a456 1
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, AMDPM_SMBSTAT, st);
d473 1
a473 1
			data = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
@


1.12
log
@In iic_exec don't fail immediately if bus is already busy. It might be
running a BIOS' transfer so wait a bit and try again.
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.11 2006/01/09 19:32:14 deraadt Exp $	*/
d179 1
a179 1
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_NVIDIA) 
d181 1
a181 1
	else  
d184 1
a184 1
		
d209 1
a209 1
			pci_conf_write(pa->pa_pc, pa->pa_tag, AMDPM_CONFREG, 
d211 1
a211 1
			cfg_reg = pci_conf_read(pa->pa_pc, pa->pa_tag, 
d216 1
a216 1
			(void) bus_space_read_4(sc->sc_iot, sc->sc_ioh, 
d218 3
a220 3
		        for (i = 1000; i--; ) {
				if (bus_space_read_1(sc->sc_iot, sc->sc_ioh, 
				    AMDPM_RNGSTAT) & AMDPM_RNGDONE) 
d224 1
a224 1
			if (bus_space_read_1(sc->sc_iot, sc->sc_ioh, 
d227 1
a227 1
				timeout_set(&sc->sc_rnd_ch, amdpm_rnd_callout, 
d325 1
a325 1
	}			
@


1.11
log
@with an offset tweak, this can also support the nvidia nforce smbus
same unit is found on amd756 and amd8111.  try to support the RNG as
well. from gklok@@cogeco.ca
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.10 2006/01/06 00:18:35 brad Exp $	*/
d319 7
a325 2
	/* Check if there's a transfer already running */
	st = bus_space_read_2(sc->sc_iot, sc->sc_ioh, AMDPM_SMBSTAT);
@


1.10
log
@remove NetBSD's event counter code.

ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.9 2006/01/05 10:43:15 grange Exp $	*/
d146 1
d148 3
a150 1
	{ PCI_VENDOR_AMD, PCI_PRODUCT_AMD_PBC768_PMC }
a165 1
	struct timeval tv1, tv2;
d167 1
a167 1
	int i;
d179 7
a185 1
	reg = pci_conf_read(pa->pa_pc, pa->pa_tag, AMDPM_PMPTR);
d206 11
a216 12

	if (cfg_reg & AMDPM_RNGEN) {
		/* Check to see if we can read data from the RNG. */
		(void) bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    AMDPM_RNGDATA);
		/* benchmark the RNG */
		microtime(&tv1);
		for (i = 2 * 1024; i--; ) {
			while(!(bus_space_read_1(sc->sc_iot, sc->sc_ioh,
			    AMDPM_RNGSTAT) & AMDPM_RNGDONE))
				;
			(void) bus_space_read_4(sc->sc_iot, sc->sc_ioh,
d218 13
a231 9
		microtime(&tv2);

		timersub(&tv2, &tv1, &tv1);
		if (tv1.tv_sec)
			tv1.tv_usec += 1000000 * tv1.tv_sec;
		printf(": rng active, %dKb/sec", 8 * 1000000 / tv1.tv_usec);

		timeout_set(&sc->sc_rnd_ch, amdpm_rnd_callout, sc);
		amdpm_rnd_callout(sc);
d233 1
a245 2

	printf("\n");
@


1.9
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.8 2006/01/05 08:57:27 grange Exp $	*/
a113 5
#ifdef AMDPM_RND_COUNTERS
	struct evcnt sc_rnd_hits;
	struct evcnt sc_rnd_miss;
	struct evcnt sc_rnd_data[256];
#endif
a144 6
#ifdef AMDPM_RND_COUNTERS
#define	AMDPM_RNDCNT_INCR(ev)	(ev)->ev_count++
#else
#define	AMDPM_RNDCNT_INCR(ev)	/* nothing */
#endif

a218 11
#ifdef AMDPM_RND_COUNTERS
			evcnt_attach_dynamic(&sc->sc_rnd_hits, EVCNT_TYPE_MISC,
			    NULL, sc->sc_dev.dv_xname, "rnd hits");
			evcnt_attach_dynamic(&sc->sc_rnd_miss, EVCNT_TYPE_MISC,
			    NULL, sc->sc_dev.dv_xname, "rnd miss");
			for (i = 0; i < 256; i++) {
				evcnt_attach_dynamic(&sc->sc_rnd_data[i],
				    EVCNT_TYPE_MISC, NULL, sc->sc_dev.dv_xname,
				    "rnd data");
			}
#endif
a242 3
#ifdef AMDPM_RND_COUNTERS
	int i;
#endif
d248 1
a248 7
#ifdef AMDPM_RND_COUNTERS
		AMDPM_RNDCNT_INCR(&sc->sc_rnd_hits);
		for (i = 0; i < sizeof(reg); i++, reg >>= NBBY)
			AMDPM_RNDCNT_INCR(&sc->sc_rnd_data[reg & 0xff]);
#endif
	} else
		AMDPM_RNDCNT_INCR(&sc->sc_rnd_miss);
@


1.8
log
@Add my copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.7 2006/01/05 08:54:27 grange Exp $	*/
d252 1
a252 1
	bzero(&iba, sizeof iba);
@


1.7
log
@Add SMBus host interface support for amdpm(4).

ok deraadt@@
@
text
@d1 17
a17 1
/*	$OpenBSD: amdpm.c,v 1.6 2006/01/02 04:01:43 brad Exp $	*/
@


1.6
log
@use pci_matchbyid.
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.5 2004/09/17 10:18:01 grange Exp $	*/
d41 1
d43 2
a44 1
#include <sys/device.h>
d50 2
d56 2
d59 10
a68 1
#include <dev/pci/amdpmreg.h>
d95 1
d103 10
d119 7
d142 1
a142 1
	{ PCI_VENDOR_AMD, PCI_PRODUCT_AMD_PBC768_PMC },
d157 1
d165 1
d229 12
d289 185
@


1.5
log
@Some cleanup:
- don't mix unsigned and u_int across the code
- un'static some funcs

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.4 2004/07/28 17:15:12 tholo Exp $	*/
d107 5
d115 2
a116 7
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_AMD &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AMD_PBC768_PMC ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AMD_766_PMC))
		return (1);
	return (0);
@


1.4
log
@This touches only MI code, and adds new time keeping code.  The
code is all conditionalized on __HAVE_TIMECOUNTER, and not
enabled on any platforms.

adjtime(2) support exists, courtesy of nordin@@, sysctl(2) support
and a concept of quality for each time source attached exists.

High quality time sources exists for PIIX4 ACPI timer as well as
some AMD power management chips.  This will have to be redone
once we actually add ACPI support (at that time we need to use
the ACPI interfaces to get at these clocks).

ok art@@ ken@@ miod@@ jmc@@ and many more
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.3 2002/11/04 17:12:34 fgsch Exp $	*/
d56 1
a56 1
unsigned amdpm_get_timecount(struct timecounter *tc);
d221 1
a221 1
unsigned
d225 1
a225 1
	unsigned u2;
d227 1
a227 1
	unsigned u1, u3;
@


1.3
log
@make this compile; reported by pluf, mickey ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: amdpm.c,v 1.1 2002/06/05 22:35:16 mickey Exp $	*/
d44 3
d55 17
d113 2
a114 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AMD_PBC768_PMC)
d125 1
a125 1
	pcireg_t reg;
d132 2
a133 2
	reg = pci_conf_read(pa->pa_pc, pa->pa_tag, AMDPM_CONFREG);
	if ((reg & AMDPM_PMIOEN) == 0) {
d144 16
a159 2
	reg = pci_conf_read(pa->pa_pc, pa->pa_tag, AMDPM_CONFREG);
	if (reg & AMDPM_RNGEN) {
d193 2
d219 23
@


1.2
log
@steal'' performance calculating loop from pchb.c and have a uniform output
@
text
@d77 4
@


1.2.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2.2.2
log
@sync
@
text
@a76 4
struct cfdriver amdpm_cd = {
	NULL, "amdpm", DV_DULL
};

@


1.1
log
@a driver for the rng on the amd768 power management device (no actual power management capabilities are supported yet; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d99 1
a100 1
	u_int32_t pmreg;
d124 8
a131 6
		for (i = 0; i < 1000; i++) {
			pmreg = bus_space_read_4(sc->sc_iot,
			    sc->sc_ioh, AMDPM_RNGSTAT);
			if (pmreg & AMDPM_RNGDONE)
				break;
			delay(1);
d133 7
a139 3
		if ((pmreg & AMDPM_RNGDONE) != 0) {
			printf(": rng active (apprx. %dms)\n", i);
			timeout_set(&sc->sc_rnd_ch, amdpm_rnd_callout, sc);
d151 2
a152 2
			amdpm_rnd_callout(sc);
		}
@

