head	1.32;
access;
symbols
	OPENBSD_6_1:1.32.0.4
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.30.0.8
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.29.0.8
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.6
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.26.0.10
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.8
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.6
	OPENBSD_5_0:1.26.0.4
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.23.0.4
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.6
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.10
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.8
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.6
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.13
	UBC:1.9.0.4
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	SMP:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.32
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.31;
commitid	qGgYgJTgEFuAoGj4;

1.31
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.30;
commitid	pi1a9KN0itEngOc4;

1.30
date	2015.05.11.06.46.22;	author ratchov;	state Exp;
branches;
next	1.29;
commitid	RaOGL5SyOGOZylwx;

1.29
date	2013.11.15.16.46.27;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.26;

1.26
date	2010.09.07.16.21.45;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2010.08.27.18.49.40;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.23;

1.23
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.29.02.10.01;	author jakemsr;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.21.00.32.43;	author jakemsr;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.05.00.17.28;	author jakemsr;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.09.04.10.13;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.12.06.50.20;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.22.04.29.06;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.21.19.38.36;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.21.10.01.27;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2002.10.04.20.05.12;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.16.18.32.34;	author art;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2001.08.25.10.13.30;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.18.19.27.18;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.12.15.40.32;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.03.21.29.23;	author deraadt;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2000.07.19.09.04.37;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.14.03.56.50;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.13.00.36.42;	author csapuntz;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.13.00.10.52;	author csapuntz;	state Exp;
branches;
next	;

1.5.4.1
date	2001.05.14.22.25.51;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.07.04.10.42.42;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2002.03.06.02.11.46;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2002.03.28.15.35.58;	author niklas;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2003.03.28.00.38.23;	author niklas;	state Exp;
branches;
next	1.5.4.7;

1.5.4.7
date	2003.05.13.19.35.07;	author ho;	state Exp;
branches;
next	;

1.9.4.1
date	2002.01.31.22.55.35;	author niklas;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2002.06.11.03.42.26;	author art;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2002.10.29.00.33.29;	author art;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2003.05.19.22.18.01;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Remove unused getdev() audio driver functions.
@
text
@/*      $OpenBSD: neo.c,v 1.31 2016/09/14 06:12:19 ratchov Exp $       */

/*
 * Copyright (c) 1999 Cameron Grant <gandalf@@vilnya.demon.co.uk>
 * All rights reserved.
 *
 * Derived from the public domain Linux driver
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/dev/sound/pci/neomagic.c,v 1.8 2000/03/20 15:30:50 cg Exp $
 */



#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>
#include <dev/ic/ac97.h>

#include <dev/pci/neoreg.h>

/* -------------------------------------------------------------------- */
/*
 * As of 04/13/00, public documentation on the Neomagic 256 is not available.
 * These comments were gleaned by looking at the driver carefully.
 *
 * The Neomagic 256 AV/ZX chips provide both video and audio capabilities
 * on one chip. About 2-6 megabytes of memory are associated with
 * the chip. Most of this goes to video frame buffers, but some is used for
 * audio buffering.
 *
 * Unlike most PCI audio chips, the Neomagic chip does not rely on DMA.
 * Instead, the chip allows you to carve two ring buffers out of its
 * memory. How you carve this and how much you can carve seems to be
 * voodoo. The algorithm is in nm_init.
 *
 * Most Neomagic audio chips use the AC-97 codec interface. However, there
 * seem to be a select few chips 256AV chips that do not support AC-97.
 * This driver does not support them but there are rumors that it
 * might work with wss isa drivers. This might require some playing around
 * with your BIOS.
 *
 * The Neomagic 256 AV/ZX have 2 PCI I/O region descriptors. Both of
 * them describe a memory region. The frame buffer is the first region
 * and the register set is the second region.
 *
 * The register manipulation logic is taken from the Linux driver,
 * which is in the public domain.
 *
 * The Neomagic is even nice enough to map the AC-97 codec registers into
 * the register space to allow direct manipulation. Watch out, accessing
 * AC-97 registers on the Neomagic requires great delicateness, otherwise
 * the thing will hang the PCI bus, rendering your system frozen.
 *
 * For one, it seems the Neomagic status register that reports AC-97
 * readiness should NOT be polled more often than once each 1ms.
 *
 * Also, writes to the AC-97 register space may take over 40us to
 * complete.
 *
 * Unlike many sound engines, the Neomagic does not support (as fas as
 * we know :) ) the notion of interrupting every n bytes transferred,
 * unlike many DMA engines.  Instead, it allows you to specify one
 * location in each ring buffer (called the watermark). When the chip
 * passes that location while playing, it signals an interrupt.
 *
 * The ring buffer size is currently 16k. That is about 100ms of audio
 * at 44.1khz/stero/16 bit. However, to keep the buffer full, interrupts
 * are generated more often than that, so 20-40 interrupts per second
 * should not be unexpected. Increasing BUFFSIZE should help minimize
 * the glitches due to drivers that spend too much time looping at high
 * privelege levels as well as the impact of badly written audio
 * interface clients.
 *
 * TO-DO list:
 *    neo_malloc/neo_free are still seriously broken.
 *
 *    Figure out interaction with video stuff (look at Xfree86 driver?)
 *
 *    Power management (neoactivate)
 *
 *    Fix detection of Neo devices that don't work this driver (see neo_attach)
 *
 *    Figure out how to shrink that huge table neo-coeff.h
 */

#define	NM_BUFFSIZE	16384

#define NM256AV_PCI_ID  0x800510c8
#define NM256ZX_PCI_ID  0x800610c8

/* device private data */
struct neo_softc {
	struct          device dev;

	bus_space_tag_t bufiot;
	bus_space_handle_t  bufioh;

	bus_space_tag_t regiot;
	bus_space_handle_t  regioh;

	u_int32_t	type;
	void            *ih;

	void	(*pintr)(void *);	/* dma completion intr handler */
	void	*parg;		/* arg for intr() */

	void	(*rintr)(void *);	/* dma completion intr handler */
	void	*rarg;		/* arg for intr() */

	u_int32_t	ac97_base, ac97_status, ac97_busy;
	u_int32_t	buftop, pbuf, rbuf, cbuf, acbuf;
	u_int32_t	playint, recint, misc1int, misc2int;
	u_int32_t	irsz, badintr;

        u_int32_t       pbufsize;
        u_int32_t       rbufsize;

	u_int32_t       pblksize;
	u_int32_t       rblksize;

        u_int32_t       pwmark;
        u_int32_t       rwmark;

	struct ac97_codec_if *codec_if;
	struct ac97_host_if host_if;
};

static struct neo_firmware *nf;

/* -------------------------------------------------------------------- */

/*
 * prototypes
 */

static int	 nm_waitcd(struct neo_softc *sc);
static int	 nm_loadcoeff(struct neo_softc *sc, int dir, int num);
static int       nm_init(struct neo_softc *);

int    nmchan_getptr(struct neo_softc *, int);
/* talk to the card */
static u_int32_t nm_rd(struct neo_softc *, int, int);
static void	 nm_wr(struct neo_softc *, int, u_int32_t, int);
static u_int32_t nm_rdbuf(struct neo_softc *, int, int);
static void	 nm_wrbuf(struct neo_softc *, int, u_int32_t, int);

int	neo_match(struct device *, void *, void *);
void	neo_attach(struct device *, struct device *, void *);
int	neo_activate(struct device *, int);
int	neo_intr(void *);

int	neo_open(void *, int);
void	neo_close(void *);
int	neo_set_params(void *, int, int, struct audio_params *, struct audio_params *);
int	neo_round_blocksize(void *, int);
int	neo_trigger_output(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	neo_trigger_input(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	neo_halt_output(void *);
int	neo_halt_input(void *);
int	neo_mixer_set_port(void *, mixer_ctrl_t *);
int	neo_mixer_get_port(void *, mixer_ctrl_t *);
int     neo_attach_codec(void *sc, struct ac97_codec_if *);
int	neo_read_codec(void *sc, u_int8_t a, u_int16_t *d);
int	neo_write_codec(void *sc, u_int8_t a, u_int16_t d);
void    neo_reset_codec(void *sc);
enum ac97_host_flags neo_flags_codec(void *sc);
int	neo_query_devinfo(void *, mixer_devinfo_t *);
void   *neo_malloc(void *, int, size_t, int, int);
void	neo_free(void *, void *, int);
size_t	neo_round_buffersize(void *, int, size_t);
int	neo_get_props(void *);
void	neo_set_mixer(struct neo_softc *sc, int a, int d);

struct cfdriver neo_cd = {
	NULL, "neo", DV_DULL
};


struct cfattach neo_ca = {
	sizeof(struct neo_softc), neo_match, neo_attach, NULL,
	neo_activate
};


#if 0
static u_int32_t badcards[] = {
	0x0007103c,
	0x008f1028,
};
#endif

#define NUM_BADCARDS (sizeof(badcards) / sizeof(u_int32_t))

/* The actual rates supported by the card. */
static int samplerates[9] = {
	8000,
	11025,
	16000,
	22050,
	24000,
	32000,
	44100,
	48000,
	99999999
};

/* -------------------------------------------------------------------- */

struct audio_hw_if neo_hw_if = {
	neo_open,
	neo_close,
	neo_set_params,
#if 1
	neo_round_blocksize,
#else
	NULL,
#endif
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	neo_halt_output,
	neo_halt_input,
	NULL,
	NULL,
	neo_mixer_set_port,
	neo_mixer_get_port,
	neo_query_devinfo,
	neo_malloc,
	neo_free,
	neo_round_buffersize,
	neo_get_props,
	neo_trigger_output,
	neo_trigger_input

};

/* -------------------------------------------------------------------- */

/* Hardware */
static u_int32_t
nm_rd(struct neo_softc *sc, int regno, int size)
{
	bus_space_tag_t st = sc->regiot;
	bus_space_handle_t sh = sc->regioh;

	switch (size) {
	case 1:
		return bus_space_read_1(st, sh, regno);
	case 2:
		return bus_space_read_2(st, sh, regno);
	case 4:
		return bus_space_read_4(st, sh, regno);
	default:
		return (0xffffffff);
	}
}

static void
nm_wr(struct neo_softc *sc, int regno, u_int32_t data, int size)
{
	bus_space_tag_t st = sc->regiot;
	bus_space_handle_t sh = sc->regioh;

	switch (size) {
	case 1:
		bus_space_write_1(st, sh, regno, data);
		break;
	case 2:
		bus_space_write_2(st, sh, regno, data);
		break;
	case 4:
		bus_space_write_4(st, sh, regno, data);
		break;
	}
}

static u_int32_t
nm_rdbuf(struct neo_softc *sc, int regno, int size)
{
	bus_space_tag_t st = sc->bufiot;
	bus_space_handle_t sh = sc->bufioh;

	switch (size) {
	case 1:
		return bus_space_read_1(st, sh, regno);
	case 2:
		return bus_space_read_2(st, sh, regno);
	case 4:
		return bus_space_read_4(st, sh, regno);
	default:
		return (0xffffffff);
	}
}

static void
nm_wrbuf(struct neo_softc *sc, int regno, u_int32_t data, int size)
{
	bus_space_tag_t st = sc->bufiot;
	bus_space_handle_t sh = sc->bufioh;

	switch (size) {
	case 1:
		bus_space_write_1(st, sh, regno, data);
		break;
	case 2:
		bus_space_write_2(st, sh, regno, data);
		break;
	case 4:
		bus_space_write_4(st, sh, regno, data);
		break;
	}
}

/* ac97 codec */
static int
nm_waitcd(struct neo_softc *sc)
{
	int cnt = 10;
	int fail = 1;

	while (cnt-- > 0) {
		if (nm_rd(sc, sc->ac97_status, 2) & sc->ac97_busy)
			DELAY(100);
		else {
		        fail = 0;
			break;
		}
	}
	return (fail);
}


static void
nm_ackint(struct neo_softc *sc, u_int32_t num)
{
	if (sc->type == NM256AV_PCI_ID)
		nm_wr(sc, NM_INT_REG, num << 1, 2);
	else if (sc->type == NM256ZX_PCI_ID)
		nm_wr(sc, NM_INT_REG, num, 4);
}

static int
nm_loadcoeff(struct neo_softc *sc, int dir, int num)
{
	int ofs, sz, i;
	u_int32_t addr;

	if (nf == NULL) {
		size_t buflen;
		u_char *buf;
		int error;

		error = loadfirmware("neo-coefficients", &buf, &buflen);
		if (error)
			return (error);
		nf = (struct neo_firmware *)buf;
	}

	addr = (dir == AUMODE_PLAY)? 0x01c : 0x21c;
	if (dir == AUMODE_RECORD)
		num += 8;
	sz = nf->coefficientSizes[num];
	ofs = 0;
	while (num-- > 0)
		ofs+= nf->coefficientSizes[num];
	for (i = 0; i < sz; i++)
		nm_wrbuf(sc, sc->cbuf + i, nf->coefficients[ofs + i], 1);
	nm_wr(sc, addr, sc->cbuf, 4);
	if (dir == AUMODE_PLAY)
		sz--;
	nm_wr(sc, addr + 4, sc->cbuf + sz, 4);
	return (0);
}

int
nmchan_getptr(struct neo_softc *sc, int mode)
{
	if (mode == AUMODE_PLAY)
		return (nm_rd(sc, NM_PBUFFER_CURRP, 4) - sc->pbuf);
	else
		return (nm_rd(sc, NM_RBUFFER_CURRP, 4) - sc->rbuf);
}


/* The interrupt handler */
int
neo_intr(void *p)
{
	struct neo_softc *sc = (struct neo_softc *)p;
	int status, x;
	int rv = 0;

	mtx_enter(&audio_lock);
	status = nm_rd(sc, NM_INT_REG, sc->irsz);

	if (status & sc->playint) {
		status &= ~sc->playint;

		sc->pwmark += sc->pblksize;
		sc->pwmark %= sc->pbufsize;

		nm_wr(sc, NM_PBUFFER_WMARK, sc->pbuf + sc->pwmark, 4);

		nm_ackint(sc, sc->playint);

		if (sc->pintr)
			(*sc->pintr)(sc->parg);

		rv = 1;
	}
	if (status & sc->recint) {
		status &= ~sc->recint;

		sc->rwmark += sc->rblksize;
		sc->rwmark %= sc->rbufsize;

		nm_ackint(sc, sc->recint);
		if (sc->rintr)
			(*sc->rintr)(sc->rarg);

		rv = 1;
	}
	if (status & sc->misc1int) {
		status &= ~sc->misc1int;
		nm_ackint(sc, sc->misc1int);
		x = nm_rd(sc, 0x400, 1);
		nm_wr(sc, 0x400, x | 2, 1);
		printf("%s: misc int 1\n", sc->dev.dv_xname);
		rv = 1;
	}
	if (status & sc->misc2int) {
		status &= ~sc->misc2int;
		nm_ackint(sc, sc->misc2int);
		x = nm_rd(sc, 0x400, 1);
		nm_wr(sc, 0x400, x & ~2, 1);
		printf("%s: misc int 2\n", sc->dev.dv_xname);
		rv = 1;
	}
	if (status) {
		status &= ~sc->misc2int;
		nm_ackint(sc, sc->misc2int);
		printf("%s: unknown int\n", sc->dev.dv_xname);
		rv = 1;
	}
	mtx_leave(&audio_lock);
	return (rv);
}

/* -------------------------------------------------------------------- */

/*
 * Probe and attach the card
 */

static int
nm_init(struct neo_softc *sc)
{
	u_int32_t ofs, i;

	if (sc->type == NM256AV_PCI_ID) {
		sc->ac97_base = NM_MIXER_OFFSET;
		sc->ac97_status = NM_MIXER_STATUS_OFFSET;
		sc->ac97_busy = NM_MIXER_READY_MASK;

		sc->buftop = 2560 * 1024;

		sc->irsz = 2;
		sc->playint = NM_PLAYBACK_INT;
		sc->recint = NM_RECORD_INT;
		sc->misc1int = NM_MISC_INT_1;
		sc->misc2int = NM_MISC_INT_2;
	} else if (sc->type == NM256ZX_PCI_ID) {
		sc->ac97_base = NM_MIXER_OFFSET;
		sc->ac97_status = NM2_MIXER_STATUS_OFFSET;
		sc->ac97_busy = NM2_MIXER_READY_MASK;

		sc->buftop = (nm_rd(sc, 0xa0b, 2)? 6144 : 4096) * 1024;

		sc->irsz = 4;
		sc->playint = NM2_PLAYBACK_INT;
		sc->recint = NM2_RECORD_INT;
		sc->misc1int = NM2_MISC_INT_1;
		sc->misc2int = NM2_MISC_INT_2;
	} else return -1;
	sc->badintr = 0;
	ofs = sc->buftop - 0x0400;
	sc->buftop -= 0x1400;

	if ((nm_rdbuf(sc, ofs, 4) & NM_SIG_MASK) == NM_SIGNATURE) {
		i = nm_rdbuf(sc, ofs + 4, 4);
		if (i != 0 && i != 0xffffffff)
			sc->buftop = i;
	}

	sc->cbuf = sc->buftop - NM_MAX_COEFFICIENT;
	sc->rbuf = sc->cbuf - NM_BUFFSIZE;
	sc->pbuf = sc->rbuf - NM_BUFFSIZE;
	sc->acbuf = sc->pbuf - (NM_TOTAL_COEFF_COUNT * 4);

	nm_wr(sc, 0, 0x11, 1);
	nm_wr(sc, NM_RECORD_ENABLE_REG, 0, 1);
	nm_wr(sc, 0x214, 0, 2);

	return 0;
}


void
neo_attach(struct device *parent, struct device *self, void *aux)
{
	struct neo_softc *sc = (struct neo_softc *)self;
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	char const *intrstr;
	pci_intr_handle_t ih;
	int error;

	sc->type = pa->pa_id;

	/* Map I/O register */
	if (pci_mapreg_map(pa, PCI_MAPS, PCI_MAPREG_TYPE_MEM, 0,
			   &sc->bufiot, &sc->bufioh, NULL, NULL, 0)) {
		printf("\n%s: can't map i/o space\n", sc->dev.dv_xname);
		return;
	}


	if (pci_mapreg_map(pa, PCI_MAPS + 4, PCI_MAPREG_TYPE_MEM, 0,
			   &sc->regiot, &sc->regioh, NULL, NULL, 0)) {
		printf("\n%s: can't map i/o space\n", sc->dev.dv_xname);
		return;
	}

	/* Map and establish the interrupt. */
	if (pci_intr_map(pa, &ih)) {
		printf("\n%s: couldn't map interrupt\n", sc->dev.dv_xname);
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->ih = pci_intr_establish(pc, ih, IPL_AUDIO | IPL_MPSAFE,
	    neo_intr, sc, sc->dev.dv_xname);

	if (sc->ih == NULL) {
		printf("\n%s: couldn't establish interrupt",
		       sc->dev.dv_xname);
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s\n", intrstr);

	if ((error = nm_init(sc)) != 0)
		return;

	sc->host_if.arg = sc;

	sc->host_if.attach = neo_attach_codec;
	sc->host_if.read   = neo_read_codec;
	sc->host_if.write  = neo_write_codec;
	sc->host_if.reset  = neo_reset_codec;
	sc->host_if.flags  = neo_flags_codec;

	if ((error = ac97_attach(&sc->host_if)) != 0)
		return;

	audio_attach_mi(&neo_hw_if, sc, &sc->dev);

	return;
}

int
neo_activate(struct device *self, int act)
{
	struct neo_softc *sc = (struct neo_softc *)self;

	switch (act) {
	case DVACT_SUSPEND:
		break;
	case DVACT_RESUME:
		nm_init(sc);
		(sc->codec_if->vtbl->restore_ports)(sc->codec_if);
		break;
	}
	return 0;
}

int
neo_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = (struct pci_attach_args *) aux;
#if 0
	u_int32_t subdev, badcard;
#endif

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_NEOMAGIC)
		return (0);

#if 0
	subdev = (pci_get_subdevice(dev) << 16) | pci_get_subvendor(dev);
#endif
	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_NEOMAGIC_NM256AV:
#if 0
		i = 0;
		while ((i < NUM_BADCARDS) && (badcards[i] != subdev))
			i++;
		if (i == NUM_BADCARDS)
			s = "NeoMagic 256AV";
		DEB(else)
			DEB(device_printf(dev, "this is a non-ac97 NM256AV, not attaching\n"));
		return (1);
#endif
	case PCI_PRODUCT_NEOMAGIC_NM256ZX:
		return (1);
	}

	return (0);
}

int
neo_read_codec(void *sc_, u_int8_t a, u_int16_t *d)
{
	struct neo_softc *sc = sc_;

	if (!nm_waitcd(sc)) {
		*d = nm_rd(sc, sc->ac97_base + a, 2);
		DELAY(1000);
		return 0;
	}

	return (ENXIO);
}


int
neo_write_codec(void *sc_, u_int8_t a, u_int16_t d)
{
	struct neo_softc *sc = sc_;
	int cnt = 3;

	if (!nm_waitcd(sc)) {
		while (cnt-- > 0) {
			nm_wr(sc, sc->ac97_base + a, d, 2);
			if (!nm_waitcd(sc)) {
				DELAY(1000);
				return (0);
			}
		}
	}

        return (ENXIO);
}


int
neo_attach_codec(void *sc_, struct ac97_codec_if *codec_if)
{
	struct neo_softc *sc = sc_;

	sc->codec_if = codec_if;
	return (0);
}

void
neo_reset_codec(void *sc)
{
	nm_wr(sc, 0x6c0, 0x01, 1);
	nm_wr(sc, 0x6cc, 0x87, 1);
	nm_wr(sc, 0x6cc, 0x80, 1);
	nm_wr(sc, 0x6cc, 0x00, 1);

	return;
}


enum ac97_host_flags
neo_flags_codec(void *sc)
{
	return (AC97_HOST_DONT_READANY);
}

int
neo_open(void *addr, int flags)
{
	return (0);
}

/*
 * Close function is called at splaudio().
 */
void
neo_close(void *addr)
{
	struct neo_softc *sc = addr;

	neo_halt_output(sc);
	neo_halt_input(sc);

	sc->pintr = 0;
	sc->rintr = 0;
}

/* Todo: don't commit settings to card until we've verified all parameters */
int
neo_set_params(void *addr, int setmode, int usemode,
    struct audio_params *play, struct audio_params *rec)
{
	struct neo_softc *sc = addr;
	u_int32_t base;
	u_int8_t x;
	int mode;
	struct audio_params *p;

	for (mode = AUMODE_RECORD; mode != -1;
	     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
		if ((setmode & mode) == 0)
			continue;

		p = mode == AUMODE_PLAY ? play : rec;

		if (p == NULL) continue;

		for (x = 0; x < 8; x++)
			if (p->sample_rate < (samplerates[x] + samplerates[x + 1]) / 2)
				break;

		p->sample_rate = samplerates[x];
		nm_loadcoeff(sc, mode, x);

		x <<= 4;
		x &= NM_RATE_MASK;
		if (p->precision == 16) x |= NM_RATE_BITS_16;
		if (p->channels == 2) x |= NM_RATE_STEREO;

		base = (mode == AUMODE_PLAY) ?
		    NM_PLAYBACK_REG_OFFSET : NM_RECORD_REG_OFFSET;
		nm_wr(sc, base + NM_RATE_REG_OFFSET, x, 1);

		switch (p->encoding) {
		case AUDIO_ENCODING_SLINEAR_LE:
			if (p->precision != 16)
				return EINVAL;
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
		case AUDIO_ENCODING_ULINEAR_BE:
			if (p->precision != 8)
				return EINVAL;
			break;
		default:
			return (EINVAL);
		}
		p->bps = AUDIO_BPS(p->precision);
		p->msb = 1;
	}

	return (0);
}

int
neo_round_blocksize(void *addr, int blk)
{
	return (NM_BUFFSIZE / 2);
}

int
neo_trigger_output(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct neo_softc *sc = addr;
	int ssz;

	mtx_enter(&audio_lock);
	sc->pintr = intr;
	sc->parg = arg;

	ssz = (param->precision == 16) ? 2 : 1;
	if (param->channels == 2)
		ssz <<= 1;

	sc->pbufsize = ((char *)end - (char *)start);
	sc->pblksize = blksize;
	sc->pwmark = blksize;
	nm_wr(sc, NM_PBUFFER_START, sc->pbuf, 4);
	nm_wr(sc, NM_PBUFFER_END, sc->pbuf + sc->pbufsize - ssz, 4);
	nm_wr(sc, NM_PBUFFER_CURRP, sc->pbuf, 4);
	nm_wr(sc, NM_PBUFFER_WMARK, sc->pbuf + sc->pwmark, 4);
	nm_wr(sc, NM_PLAYBACK_ENABLE_REG, NM_PLAYBACK_FREERUN |
	    NM_PLAYBACK_ENABLE_FLAG, 1);
	nm_wr(sc, NM_AUDIO_MUTE_REG, 0, 2);
	mtx_leave(&audio_lock);
	return (0);
}



int
neo_trigger_input(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct neo_softc *sc = addr;
	int ssz;

	mtx_enter(&audio_lock);
	sc->rintr = intr;
	sc->rarg = arg;

	ssz = (param->precision == 16) ? 2 : 1;
	if (param->channels == 2)
		ssz <<= 1;

	sc->rbufsize = ((char *)end - (char *)start);
	sc->rblksize = blksize;
	sc->rwmark = blksize;
	nm_wr(sc, NM_RBUFFER_START, sc->rbuf, 4);
	nm_wr(sc, NM_RBUFFER_END, sc->rbuf + sc->rbufsize, 4);
	nm_wr(sc, NM_RBUFFER_CURRP, sc->rbuf, 4);
	nm_wr(sc, NM_RBUFFER_WMARK, sc->rbuf + sc->rwmark, 4);
	nm_wr(sc, NM_RECORD_ENABLE_REG, NM_RECORD_FREERUN |
	    NM_RECORD_ENABLE_FLAG, 1);
	mtx_leave(&audio_lock);
	return (0);
}

int
neo_halt_output(void *addr)
{
	struct neo_softc *sc = (struct neo_softc *)addr;

	mtx_enter(&audio_lock);
	nm_wr(sc, NM_PLAYBACK_ENABLE_REG, 0, 1);
	nm_wr(sc, NM_AUDIO_MUTE_REG, NM_AUDIO_MUTE_BOTH, 2);

	sc->pintr = 0;
	mtx_leave(&audio_lock);
	return (0);
}

int
neo_halt_input(void *addr)
{
	struct neo_softc *sc = (struct neo_softc *)addr;

	mtx_enter(&audio_lock);
	nm_wr(sc, NM_RECORD_ENABLE_REG, 0, 1);

	sc->rintr = 0;
	mtx_leave(&audio_lock);
	return (0);
}

int
neo_mixer_set_port(void *addr, mixer_ctrl_t *cp)
{
	struct neo_softc *sc = addr;

	return ((sc->codec_if->vtbl->mixer_set_port)(sc->codec_if, cp));
}

int
neo_mixer_get_port(void *addr, mixer_ctrl_t *cp)
{
	struct neo_softc *sc = addr;

	return ((sc->codec_if->vtbl->mixer_get_port)(sc->codec_if, cp));
}

int
neo_query_devinfo(void *addr, mixer_devinfo_t *dip)
{
	struct neo_softc *sc = addr;

	return ((sc->codec_if->vtbl->query_devinfo)(sc->codec_if, dip));
}

void *
neo_malloc(void *addr, int direction, size_t size, int pool, int flags)
{
	struct neo_softc *sc = addr;
	void *rv = 0;

	switch (direction) {
	case AUMODE_PLAY:
		rv = (char *)sc->bufioh + sc->pbuf;
		break;
	case AUMODE_RECORD:
		rv = (char *)sc->bufioh + sc->rbuf;
		break;
	default:
		break;
	}

	return (rv);
}

void
neo_free(void *addr, void *ptr, int pool)
{
	return;
}

size_t
neo_round_buffersize(void *addr, int direction, size_t size)
{
	return (NM_BUFFSIZE);
}


int
neo_get_props(void *addr)
{
	return (AUDIO_PROP_INDEPENDENT | AUDIO_PROP_FULLDUPLEX);
}
@


1.31
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.29 2013/11/15 16:46:27 brad Exp $       */
a190 1
int	neo_getdev(void *, struct audio_device *);
a215 6
struct audio_device neo_device = {
	"NeoMagic 256",
	"",
	"neo"
};

a256 1
	neo_getdev,
a881 7
	return (0);
}

int
neo_getdev(void *addr, struct audio_device *retp)
{
	*retp = neo_device;
@


1.30
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@a182 1
int	neo_query_encoding(void *, struct audio_encoding *);
a183 1
void	neo_get_default_params(void *, int, struct audio_params *);
a249 2
	NULL,
	neo_query_encoding,
a271 1
	0,				/* neo_mappage, */
d274 1
a274 2
	neo_trigger_input,
	neo_get_default_params
a742 31
}

int
neo_query_encoding(void *addr, struct audio_encoding *fp)
{
	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 1:
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	default:
		return (EINVAL);
	}
	fp->bps = AUDIO_BPS(fp->precision);
	fp->msb = 1;

	return (0);
}

void
neo_get_default_params(void *addr, int mode, struct audio_params *params)
{
	ac97_get_default_params(params);
@


1.29
log
@ansify some function definitions.
no functional change.

ok sthen@@
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.28 2013/05/24 07:58:46 ratchov Exp $       */
a45 2
#include <dev/mulaw.h>
#include <dev/auconv.h>
a761 18
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 2:
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 3:
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 4:
a766 18
	case 5:
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 6:
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
a817 2
		p->factor = 1;
		p->sw_code = 0;
a818 6
		case AUDIO_ENCODING_SLINEAR_BE:
			if (p->precision == 16)
				p->sw_code = swap_bytes;
			else
				p->sw_code = change_sign8;
			break;
d821 1
a821 1
				p->sw_code = change_sign8;
d823 1
d825 2
a826 24
			if (p->precision == 16) {
				if (mode == AUMODE_PLAY)
					p->sw_code = swap_bytes_change_sign16_le;
				else
					p->sw_code = change_sign16_swap_bytes_le;
			}
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			if (p->precision == 16)
				p->sw_code = change_sign16_le;
			break;
		case AUDIO_ENCODING_ULAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = mulaw_to_slinear16_le;
			} else
				p->sw_code = ulinear8_to_mulaw;
			break;
		case AUDIO_ENCODING_ALAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = alaw_to_slinear16_le;
			} else
				p->sw_code = ulinear8_to_alaw;
d855 1
a855 1
	ssz = (param->precision * param->factor == 16)? 2 : 1;
d886 1
a886 1
	ssz = (param->precision * param->factor == 16)? 2 : 1;
@


1.28
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.27 2013/05/15 08:29:24 ratchov Exp $       */
d425 1
a425 3
nmchan_getptr(sc, mode)
        struct neo_softc *sc;
	int mode;
d558 1
a558 4
neo_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d638 1
a638 4
neo_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d671 1
a671 4
neo_read_codec(sc_, a, d)
        void *sc_;
	u_int8_t a;
	u_int16_t *d;
d686 1
a686 4
neo_write_codec(sc_, a, d)
        void *sc_;
	u_int8_t a;
	u_int16_t d;
d706 1
a706 3
neo_attach_codec(sc_, codec_if)
	void *sc_;
	struct ac97_codec_if  *codec_if;
d715 1
a715 2
neo_reset_codec(sc)
	void *sc;
d727 1
a727 2
neo_flags_codec(sc)
	void *sc;
d733 1
a733 3
neo_open(addr, flags)
	void *addr;
	int flags;
d742 1
a742 2
neo_close(addr)
	void *addr;
d754 1
a754 3
neo_query_encoding(addr, fp)
	void *addr;
	struct audio_encoding *fp;
d822 2
a823 4
neo_set_params(addr, setmode, usemode, play, rec)
	void *addr;
	int setmode, usemode;
	struct audio_params *play, *rec;
d906 1
a906 3
neo_round_blocksize(addr, blk)
	void *addr;
	int blk;
d912 2
a913 7
neo_trigger_output(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
d943 2
a944 7
neo_trigger_input(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
d971 1
a971 2
neo_halt_output(addr)
	void *addr;
d985 1
a985 2
neo_halt_input(addr)
	void *addr;
d998 1
a998 3
neo_getdev(addr, retp)
	void *addr;
	struct audio_device *retp;
d1005 1
a1005 3
neo_mixer_set_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d1013 1
a1013 3
neo_mixer_get_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d1021 1
a1021 3
neo_query_devinfo(addr, dip)
	void *addr;
	mixer_devinfo_t *dip;
d1029 1
a1029 5
neo_malloc(addr, direction, size, pool, flags)
	void *addr;
	int  direction;
	size_t size;
	int pool, flags;
d1049 1
a1049 4
neo_free(addr, ptr, pool)
	void *addr;
	void *ptr;
	int pool;
d1055 1
a1055 4
neo_round_buffersize(addr, direction, size)
	void *addr;
	int direction;
	size_t size;
d1062 1
a1062 2
neo_get_props(addr)
	void *addr;
a1063 1

@


1.27
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.26 2010/09/07 16:21:45 deraadt Exp $       */
d594 2
a595 2
	sc->ih = pci_intr_establish(pc, ih, IPL_AUDIO, neo_intr, sc,
				       sc->dev.dv_xname);
@


1.26
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.25 2010/08/27 18:49:40 deraadt Exp $       */
d444 1
d496 1
a496 1

d950 1
a960 1

d968 1
a968 1

d986 1
a996 1

d1003 1
a1003 1

d1013 1
d1018 1
a1018 1

d1028 1
d1032 1
a1032 1

@


1.25
log
@Mangle neo_power's contents into a neo_activate function, then make
neo_power into a stub which calls it.  Tested on an ancient z505r; my
first laptop....
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.24 2010/07/15 03:43:11 jakemsr Exp $       */
a156 2

	void *powerhook;
a208 2
void    neo_powerhook(int why, void *arg);

a619 2
	sc->powerhook = powerhook_establish(neo_powerhook, sc);

a638 6
}

void
neo_powerhook(int why, void *addr)
{
	neo_activate(addr, why);
@


1.24
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.23 2008/10/25 22:30:43 jakemsr Exp $       */
d182 1
d211 1
a211 1
void    neo_power(int why, void *arg);
d220 2
a221 1
	sizeof(struct neo_softc), neo_match, neo_attach
d624 1
a624 1
	sc->powerhook = powerhook_establish(neo_power, sc);
d631 2
a632 2
void
neo_power(int why, void *addr)
d634 1
a634 1
	struct neo_softc *sc = (struct neo_softc *)addr;
d636 4
a639 1
	if (why == PWR_RESUME) {
d642 1
d644 1
d647 5
a651 1

@


1.23
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.22 2008/05/29 02:10:01 jakemsr Exp $       */
d785 1
a785 1
		return (0);
d791 1
a791 1
		return (0);
d797 1
a797 1
		return (0);
d803 1
a803 1
		return (0);
d809 1
a809 1
		return (0);
d815 1
a815 1
		return (0);
d821 1
a821 1
		return (0);
d827 1
a827 1
		return (0);
d831 4
d923 2
a925 1

@


1.22
log
@use ac97 default parameters for these ac97 based drivers.

this makes the emulation expansion factor 1 by default since there's no
emulation.  previously the factor was 2 because these drivers emulate
8-bit ulaw playback with 16-bit linear encodings.  having a factor
other than 1 by default creates block size and hiwat/lowat issues
with applications that set the block size and hiwat before other
parameters.

ok ratchov@@
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.21 2008/04/21 00:32:43 jakemsr Exp $       */
a863 2

		if (x == 8) return (EINVAL);
@


1.21
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.20 2007/11/05 00:17:28 jakemsr Exp $       */
d188 1
d284 1
a284 1
	NULL
d831 6
@


1.20
log
@audio encoding conversion cleanup

- the endianness of the conversions don't depend on the endianness
  of machine the conversions are built on, but the endianness of the
  audio data itself.  choose encoding conversions explicitly, instead
  of relying on #defines based on the endianness of the machine.
- replace home-grown conversions with comparable conversions in
  auconv.c and mulaw.c
- use the proper conversion for ulinear_be:16 -> slinear_le:16 in
  auixp(4)

thanks ajacoutot@@ and sthen@@ for !x86 testing
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.19 2005/08/09 04:10:13 mickey Exp $       */
d283 1
@


1.19
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.18 2004/12/12 06:50:20 deraadt Exp $       */
d887 1
a887 1
					p->sw_code = swap_bytes_change_sign16;
d889 1
a889 1
					p->sw_code = change_sign16_swap_bytes;
d894 1
a894 1
				p->sw_code = change_sign16;
d899 1
a899 1
				p->sw_code = mulaw_to_slinear16;
d906 1
a906 1
				p->sw_code = alaw_to_slinear16;
@


1.18
log
@remove old microcode include
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.17 2004/11/22 04:29:06 deraadt Exp $       */
a568 1
	pcireg_t csr;
a607 5

	/* Enable the device. */
	csr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
		       csr | PCI_COMMAND_MASTER_ENABLE);
@


1.17
log
@filesystem firmware loading
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.16 2003/04/27 11:22:53 ho Exp $       */
a50 1
//#include <dev/microcode/neomagic/neo-coeff.h>
@


1.16
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.15 2003/03/21 19:38:36 jason Exp $       */
d51 1
a51 1
#include <dev/microcode/neomagic/neo-coeff.h>
d162 2
d398 11
d412 1
a412 1
	sz = coefficientSizes[num];
d415 1
a415 1
		ofs+= coefficientSizes[num];
d417 1
a417 1
		nm_wrbuf(sc, sc->cbuf + i, coefficients[ofs + i], 1);
@


1.15
log
@install a powerhook to restore the AC97 state after suspend;
aditya at dsl dot cis dot upenn dot edu via pr 3165; ok millert
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.14 2003/02/21 10:01:27 tedu Exp $       */
d773 1
a773 1
		strcpy(fp->name, AudioEulinear);
d779 1
a779 1
		strcpy(fp->name, AudioEmulaw);
d785 1
a785 1
		strcpy(fp->name, AudioEalaw);
d791 1
a791 1
		strcpy(fp->name, AudioEslinear);
d797 1
a797 1
		strcpy(fp->name, AudioEslinear_le);
d803 1
a803 1
		strcpy(fp->name, AudioEulinear_le);
d809 1
a809 1
		strcpy(fp->name, AudioEslinear_be);
d815 1
a815 1
		strcpy(fp->name, AudioEulinear_be);
@


1.14
log
@remove unused variable

ok mickey@@
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.13 2002/10/04 20:05:12 mickey Exp $       */
d158 2
d208 1
a208 1

d614 2
d620 13
@


1.13
log
@formatting, grammar, spaces; from grendel@@zeitbombe.org
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.12 2002/03/14 03:16:06 millert Exp $       */
d427 1
a427 1
	int status, x, active;
a429 1
	active = (sc->pintr || sc->rintr);
@


1.12
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.11 2002/03/14 01:26:59 millert Exp $       */
d54 1
a54 1
/* 
d61 1
a61 1
 * audio buffering
d64 2
a65 2
 * Instead, the chip allows you to carve out two ring buffers out of its
 * memory. However you carve this and how much you can carve seems to be
d68 1
a68 1
 * Most Neomagic audio chips use the AC-97 codec interface. However, there 
d71 1
a71 1
 * mgiht work with wss isa drivers. This might require some playing around
d89 1
a89 1
 * Also, writes to the AC-97 register space may take order 40us to
d93 1
a93 1
 * we know :) the notion of interrupting every n bytes transferred,
d97 1
a97 1
 * 
d102 1
a102 1
 * of glitches due to drivers that spend to much time looping at high
d113 1
a113 1
 *    Fix detect of Neo devices that don't work this driver (see neo_attach)   
d133 1
a133 1
	u_int32_t 	type;
d142 1
a142 1
	u_int32_t 	ac97_base, ac97_status, ac97_busy;
d157 1
a157 1
	struct ac97_host_if host_if;	
d166 2
a167 2
static int 	 nm_waitcd(struct neo_softc *sc);
static int 	 nm_loadcoeff(struct neo_softc *sc, int dir, int num);
d173 1
a173 1
static void 	 nm_wr(struct neo_softc *, int, u_int32_t, int);
d175 1
a175 1
static void 	 nm_wrbuf(struct neo_softc *, int, u_int32_t, int);
d209 1
a209 1
struct  cfdriver neo_cd = {
d300 1
a300 1
		return 0xffffffff;
d337 1
a337 1
		return 0xffffffff;
d382 1
a382 1
	if (sc->type == NM256AV_PCI_ID) {
d384 1
a384 1
	} else if (sc->type == NM256ZX_PCI_ID) {
a385 1
	}
d407 1
a407 1
	return 0;
d416 1
a416 1
		return nm_rd(sc, NM_PBUFFER_CURRP, 4) - sc->pbuf;
d418 1
a418 1
		return nm_rd(sc, NM_RBUFFER_CURRP, 4) - sc->rbuf;
d526 1
a526 1
 	if ((nm_rdbuf(sc, ofs, 4) & NM_SIG_MASK) == NM_SIGNATURE) {
d581 1
a581 1
	sc->ih = pci_intr_establish(pc, ih, IPL_AUDIO, neo_intr, sc, 
d661 1
a661 1
	
d742 1
a742 1
    
d822 1
a822 1
	for (mode = AUMODE_RECORD; mode != -1; 
d834 1
a834 1
		
d845 1
a845 1
		base = (mode == AUMODE_PLAY)? 
d848 1
a848 1
		
d902 1
a902 1
	return (NM_BUFFSIZE / 2);	
d929 1
a929 1
	nm_wr(sc, NM_PBUFFER_END, sc->pbuf + sc->pbufsize - ssz, 4); 
d950 1
a950 1
	struct neo_softc *sc = addr;	
d1017 1
a1017 2
	return ((sc->codec_if->vtbl->mixer_set_port)(sc->codec_if,
						     cp));
d1027 1
a1027 2
	return ((sc->codec_if->vtbl->mixer_get_port)(sc->codec_if,
						     cp));
d1052 2
a1053 2
	  rv = (char *)sc->bufioh + sc->pbuf;
	  break;
d1055 2
a1056 2
	  rv = (char *)sc->bufioh + sc->rbuf;
	  break;
d1058 1
a1058 1
	  break;
d1088 1
a1088 2
	return (AUDIO_PROP_INDEPENDENT | 
                AUDIO_PROP_FULLDUPLEX);
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.10 2002/01/20 19:56:53 ericj Exp $       */
d186 4
a189 4
int	neo_trigger_output __P((void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *));
int	neo_trigger_input __P((void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *));
d925 1
a925 1
	sc->pbufsize = ((char*)end - (char *)start);
d961 1
a961 1
	sc->rbufsize = ((char*)end - (char *)start);
@


1.10
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.9 2001/09/16 18:32:34 art Exp $       */
d177 9
a185 9
int	neo_match __P((struct device *, void *, void *));
void	neo_attach __P((struct device *, struct device *, void *));
int	neo_intr __P((void *));

int	neo_open __P((void *, int));
void	neo_close __P((void *));
int	neo_query_encoding __P((void *, struct audio_encoding *));
int	neo_set_params __P((void *, int, int, struct audio_params *, struct audio_params *));
int	neo_round_blocksize __P((void *, int));
d190 16
a205 16
int	neo_halt_output __P((void *));
int	neo_halt_input __P((void *));
int	neo_getdev __P((void *, struct audio_device *));
int	neo_mixer_set_port __P((void *, mixer_ctrl_t *));
int	neo_mixer_get_port __P((void *, mixer_ctrl_t *));
int     neo_attach_codec __P((void *sc, struct ac97_codec_if *));
int	neo_read_codec __P((void *sc, u_int8_t a, u_int16_t *d));
int	neo_write_codec __P((void *sc, u_int8_t a, u_int16_t d));
void    neo_reset_codec __P((void *sc));
enum ac97_host_flags neo_flags_codec __P((void *sc));
int	neo_query_devinfo __P((void *, mixer_devinfo_t *));
void   *neo_malloc __P((void *, int, size_t, int, int));
void	neo_free __P((void *, void *, int));
size_t	neo_round_buffersize __P((void *, int, size_t));
int	neo_get_props __P((void *));
void	neo_set_mixer __P((struct neo_softc *sc, int a, int d));
d911 1
a911 1
	void (*intr) __P((void *));
d947 1
a947 1
	void (*intr) __P((void *));
@


1.9
log
@Typos in comments.
From Alexander Yurchenko <grange@@rt.mipt.ru>
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.8 2001/08/25 10:13:30 art Exp $       */
d273 1
a273 1
	NULL, /* neo_malloc_old, */
d275 2
a276 2
	NULL, /* neo_round_buffersize_old, */
	0, /* neo_mappage, */
a279 2
	neo_malloc,
	neo_round_buffersize,
@


1.9.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.10 2002/01/20 19:56:53 ericj Exp $       */
d273 1
a273 1
	neo_malloc,
d275 2
a276 2
	neo_round_buffersize,
	0,				/* neo_mappage, */
d280 2
@


1.9.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.9.4.1 2002/01/31 22:55:35 niklas Exp $       */
d177 29
a205 29
int	neo_match(struct device *, void *, void *);
void	neo_attach(struct device *, struct device *, void *);
int	neo_intr(void *);

int	neo_open(void *, int);
void	neo_close(void *);
int	neo_query_encoding(void *, struct audio_encoding *);
int	neo_set_params(void *, int, int, struct audio_params *, struct audio_params *);
int	neo_round_blocksize(void *, int);
int	neo_trigger_output(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	neo_trigger_input(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	neo_halt_output(void *);
int	neo_halt_input(void *);
int	neo_getdev(void *, struct audio_device *);
int	neo_mixer_set_port(void *, mixer_ctrl_t *);
int	neo_mixer_get_port(void *, mixer_ctrl_t *);
int     neo_attach_codec(void *sc, struct ac97_codec_if *);
int	neo_read_codec(void *sc, u_int8_t a, u_int16_t *d);
int	neo_write_codec(void *sc, u_int8_t a, u_int16_t d);
void    neo_reset_codec(void *sc);
enum ac97_host_flags neo_flags_codec(void *sc);
int	neo_query_devinfo(void *, mixer_devinfo_t *);
void   *neo_malloc(void *, int, size_t, int, int);
void	neo_free(void *, void *, int);
size_t	neo_round_buffersize(void *, int, size_t);
int	neo_get_props(void *);
void	neo_set_mixer(struct neo_softc *sc, int a, int d);
d911 1
a911 1
	void (*intr)(void *);
d925 1
a925 1
	sc->pbufsize = ((char *)end - (char *)start);
d947 1
a947 1
	void (*intr)(void *);
d961 1
a961 1
	sc->rbufsize = ((char *)end - (char *)start);
@


1.9.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.9.4.2 2002/06/11 03:42:26 art Exp $       */
d54 1
a54 1
/*
d61 1
a61 1
 * audio buffering.
d64 2
a65 2
 * Instead, the chip allows you to carve two ring buffers out of its
 * memory. How you carve this and how much you can carve seems to be
d68 1
a68 1
 * Most Neomagic audio chips use the AC-97 codec interface. However, there
d71 1
a71 1
 * might work with wss isa drivers. This might require some playing around
d89 1
a89 1
 * Also, writes to the AC-97 register space may take over 40us to
d93 1
a93 1
 * we know :) ) the notion of interrupting every n bytes transferred,
d97 1
a97 1
 *
d102 1
a102 1
 * the glitches due to drivers that spend too much time looping at high
d113 1
a113 1
 *    Fix detection of Neo devices that don't work this driver (see neo_attach)
d133 1
a133 1
	u_int32_t	type;
d142 1
a142 1
	u_int32_t	ac97_base, ac97_status, ac97_busy;
d157 1
a157 1
	struct ac97_host_if host_if;
d166 2
a167 2
static int	 nm_waitcd(struct neo_softc *sc);
static int	 nm_loadcoeff(struct neo_softc *sc, int dir, int num);
d173 1
a173 1
static void	 nm_wr(struct neo_softc *, int, u_int32_t, int);
d175 1
a175 1
static void	 nm_wrbuf(struct neo_softc *, int, u_int32_t, int);
d209 1
a209 1
struct cfdriver neo_cd = {
d300 1
a300 1
		return (0xffffffff);
d337 1
a337 1
		return (0xffffffff);
d382 1
a382 1
	if (sc->type == NM256AV_PCI_ID)
d384 1
a384 1
	else if (sc->type == NM256ZX_PCI_ID)
d386 1
d408 1
a408 1
	return (0);
d417 1
a417 1
		return (nm_rd(sc, NM_PBUFFER_CURRP, 4) - sc->pbuf);
d419 1
a419 1
		return (nm_rd(sc, NM_RBUFFER_CURRP, 4) - sc->rbuf);
d527 1
a527 1
	if ((nm_rdbuf(sc, ofs, 4) & NM_SIG_MASK) == NM_SIGNATURE) {
d582 1
a582 1
	sc->ih = pci_intr_establish(pc, ih, IPL_AUDIO, neo_intr, sc,
d662 1
a662 1

d743 1
a743 1

d823 1
a823 1
	for (mode = AUMODE_RECORD; mode != -1;
d835 1
a835 1

d846 1
a846 1
		base = (mode == AUMODE_PLAY) ?
d849 1
a849 1

d903 1
a903 1
	return (NM_BUFFSIZE / 2);
d930 1
a930 1
	nm_wr(sc, NM_PBUFFER_END, sc->pbuf + sc->pbufsize - ssz, 4);
d951 1
a951 1
	struct neo_softc *sc = addr;
d1018 2
a1019 1
	return ((sc->codec_if->vtbl->mixer_set_port)(sc->codec_if, cp));
d1029 2
a1030 1
	return ((sc->codec_if->vtbl->mixer_get_port)(sc->codec_if, cp));
d1055 2
a1056 2
		rv = (char *)sc->bufioh + sc->pbuf;
		break;
d1058 2
a1059 2
		rv = (char *)sc->bufioh + sc->rbuf;
		break;
d1061 1
a1061 1
		break;
d1091 2
a1092 1
	return (AUDIO_PROP_INDEPENDENT | AUDIO_PROP_FULLDUPLEX);
@


1.9.4.4
log
@sync
@
text
@d1 1
a1 1
/*      $OpenBSD$       */
a157 2

	void *powerhook;
d206 1
a206 1
void    neo_power(int why, void *arg);
d427 1
a427 1
	int status, x;
d430 1
a612 2
	sc->powerhook = powerhook_establish(neo_power, sc);

a617 13
void
neo_power(int why, void *addr)
{
	struct neo_softc *sc = (struct neo_softc *)addr;

	if (why == PWR_RESUME) {
		nm_init(sc);
		(sc->codec_if->vtbl->restore_ports)(sc->codec_if);
	}
}



d757 1
a757 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d763 1
a763 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d769 1
a769 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d775 1
a775 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d781 1
a781 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d787 1
a787 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d793 1
a793 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d799 1
a799 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
@


1.8
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.7 2001/06/18 19:27:18 deraadt Exp $       */
d25 1
a25 1
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHERIN CONTRACT, STRICT
d27 1
a27 1
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THEPOSSIBILITY OF
d76 1
a76 1
 * and the register set is the secodn region.
@


1.7
log
@more more microcode (so it does not end up installed in includes, for one)
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.6 2001/06/12 15:40:32 niklas Exp $       */
d579 1
a579 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
			 pa->pa_intrline, &ih)) {
@


1.6
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.5 2001/03/03 21:29:23 deraadt Exp $       */
d51 1
a51 1
#include <dev/pci/neo-coeff.h>
@


1.5
log
@use AC97_HOST_DONT_READANY since some machines are unreliable
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.4 2000/07/19 09:04:37 csapuntz Exp $       */
d566 1
a566 1
			   &sc->bufiot, &sc->bufioh, NULL, NULL)) {
d573 1
a573 1
			   &sc->regiot, &sc->regioh, NULL, NULL)) {
@


1.5.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.5 2001/03/03 21:29:23 deraadt Exp $       */
@


1.5.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.5.4.1 2001/05/14 22:25:51 niklas Exp $       */
d51 1
a51 1
#include <dev/microcode/neomagic/neo-coeff.h>
d566 1
a566 1
			   &sc->bufiot, &sc->bufioh, NULL, NULL, 0)) {
d573 1
a573 1
			   &sc->regiot, &sc->regioh, NULL, NULL, 0)) {
@


1.5.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.5.4.2 2001/07/04 10:42:42 niklas Exp $       */
d25 1
a25 1
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
d27 1
a27 1
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
d76 1
a76 1
 * and the register set is the second region.
d579 2
a580 1
	if (pci_intr_map(pa, &ih)) {
@


1.5.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*      $OpenBSD$       */
d273 1
a273 1
	neo_malloc,
d275 2
a276 2
	neo_round_buffersize,
	0,				/* neo_mappage, */
d280 2
@


1.5.4.5
log
@Merge in -current from roughly a week ago
@
text
@d177 29
a205 29
int	neo_match(struct device *, void *, void *);
void	neo_attach(struct device *, struct device *, void *);
int	neo_intr(void *);

int	neo_open(void *, int);
void	neo_close(void *);
int	neo_query_encoding(void *, struct audio_encoding *);
int	neo_set_params(void *, int, int, struct audio_params *, struct audio_params *);
int	neo_round_blocksize(void *, int);
int	neo_trigger_output(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	neo_trigger_input(void *, void *, void *, int, void (*)(void *),
	    void *, struct audio_params *);
int	neo_halt_output(void *);
int	neo_halt_input(void *);
int	neo_getdev(void *, struct audio_device *);
int	neo_mixer_set_port(void *, mixer_ctrl_t *);
int	neo_mixer_get_port(void *, mixer_ctrl_t *);
int     neo_attach_codec(void *sc, struct ac97_codec_if *);
int	neo_read_codec(void *sc, u_int8_t a, u_int16_t *d);
int	neo_write_codec(void *sc, u_int8_t a, u_int16_t d);
void    neo_reset_codec(void *sc);
enum ac97_host_flags neo_flags_codec(void *sc);
int	neo_query_devinfo(void *, mixer_devinfo_t *);
void   *neo_malloc(void *, int, size_t, int, int);
void	neo_free(void *, void *, int);
size_t	neo_round_buffersize(void *, int, size_t);
int	neo_get_props(void *);
void	neo_set_mixer(struct neo_softc *sc, int a, int d);
d911 1
a911 1
	void (*intr)(void *);
d925 1
a925 1
	sc->pbufsize = ((char *)end - (char *)start);
d947 1
a947 1
	void (*intr)(void *);
d961 1
a961 1
	sc->rbufsize = ((char *)end - (char *)start);
@


1.5.4.6
log
@Sync the SMP branch with 3.3
@
text
@d54 1
a54 1
/*
d61 1
a61 1
 * audio buffering.
d64 2
a65 2
 * Instead, the chip allows you to carve two ring buffers out of its
 * memory. How you carve this and how much you can carve seems to be
d68 1
a68 1
 * Most Neomagic audio chips use the AC-97 codec interface. However, there
d71 1
a71 1
 * might work with wss isa drivers. This might require some playing around
d89 1
a89 1
 * Also, writes to the AC-97 register space may take over 40us to
d93 1
a93 1
 * we know :) ) the notion of interrupting every n bytes transferred,
d97 1
a97 1
 *
d102 1
a102 1
 * the glitches due to drivers that spend too much time looping at high
d113 1
a113 1
 *    Fix detection of Neo devices that don't work this driver (see neo_attach)
d133 1
a133 1
	u_int32_t	type;
d142 1
a142 1
	u_int32_t	ac97_base, ac97_status, ac97_busy;
d157 1
a157 3
	struct ac97_host_if host_if;

	void *powerhook;
d166 2
a167 2
static int	 nm_waitcd(struct neo_softc *sc);
static int	 nm_loadcoeff(struct neo_softc *sc, int dir, int num);
d173 1
a173 1
static void	 nm_wr(struct neo_softc *, int, u_int32_t, int);
d175 1
a175 1
static void	 nm_wrbuf(struct neo_softc *, int, u_int32_t, int);
a205 1
void    neo_power(int why, void *arg);
d208 2
a209 1
struct cfdriver neo_cd = {
d300 1
a300 1
		return (0xffffffff);
d337 1
a337 1
		return (0xffffffff);
d382 1
a382 1
	if (sc->type == NM256AV_PCI_ID)
d384 1
a384 1
	else if (sc->type == NM256ZX_PCI_ID)
d386 1
d408 1
a408 1
	return (0);
d417 1
a417 1
		return (nm_rd(sc, NM_PBUFFER_CURRP, 4) - sc->pbuf);
d419 1
a419 1
		return (nm_rd(sc, NM_RBUFFER_CURRP, 4) - sc->rbuf);
d428 1
a428 1
	int status, x;
d431 1
d527 1
a527 1
	if ((nm_rdbuf(sc, ofs, 4) & NM_SIG_MASK) == NM_SIGNATURE) {
d582 1
a582 1
	sc->ih = pci_intr_establish(pc, ih, IPL_AUDIO, neo_intr, sc,
a613 2
	sc->powerhook = powerhook_establish(neo_power, sc);

a618 13
void
neo_power(int why, void *addr)
{
	struct neo_softc *sc = (struct neo_softc *)addr;

	if (why == PWR_RESUME) {
		nm_init(sc);
		(sc->codec_if->vtbl->restore_ports)(sc->codec_if);
	}
}



d662 1
a662 1

d743 1
a743 1

d823 1
a823 1
	for (mode = AUMODE_RECORD; mode != -1;
d835 1
a835 1

d846 1
a846 1
		base = (mode == AUMODE_PLAY) ?
d849 1
a849 1

d903 1
a903 1
	return (NM_BUFFSIZE / 2);
d930 1
a930 1
	nm_wr(sc, NM_PBUFFER_END, sc->pbuf + sc->pbufsize - ssz, 4);
d951 1
a951 1
	struct neo_softc *sc = addr;
d1018 2
a1019 1
	return ((sc->codec_if->vtbl->mixer_set_port)(sc->codec_if, cp));
d1029 2
a1030 1
	return ((sc->codec_if->vtbl->mixer_get_port)(sc->codec_if, cp));
d1055 2
a1056 2
		rv = (char *)sc->bufioh + sc->pbuf;
		break;
d1058 2
a1059 2
		rv = (char *)sc->bufioh + sc->rbuf;
		break;
d1061 1
a1061 1
		break;
d1091 2
a1092 1
	return (AUDIO_PROP_INDEPENDENT | AUDIO_PROP_FULLDUPLEX);
@


1.5.4.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.5.4.6 2003/03/28 00:38:23 niklas Exp $       */
d773 1
a773 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d779 1
a779 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d785 1
a785 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d791 1
a791 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d797 1
a797 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d803 1
a803 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d809 1
a809 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d815 1
a815 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
@


1.4
log
@

As in NetBSD, added direction to allocm/round_buffer_size APIs.
Accomplished by adding functions to audio_hw_if instead of redoing
current ones so as to minimize need to change drivers.

For Neomagic, tell the AC97 subsystem that we don't support reads.
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.3 2000/04/14 03:56:50 csapuntz Exp $       */
d727 1
a727 1
	return (AC97_HOST_DONT_READ);
@


1.3
log
@

Some documentation for future generations of maintainers
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.2 2000/04/13 00:36:42 csapuntz Exp $       */
a155 2
        int             mallocIdx;

d199 1
d201 1
a201 1
void   *neo_malloc __P((void *, u_long, int, int));
d203 1
a203 2
u_long	neo_round_buffersize __P((void *, u_long));
int	neo_mappage __P((void *, void *, int, int));
d273 1
a273 1
	neo_malloc,
d275 1
a275 1
	neo_round_buffersize,
d280 3
d612 2
a613 1
		
d723 7
d1047 1
a1047 1
neo_malloc(addr, size, pool, flags)
d1049 2
a1050 1
	u_long size;
d1056 2
a1057 2
	switch (sc->mallocIdx) {
	case 0:
a1058 1
	  sc->mallocIdx++;
d1060 1
a1060 1
	case 1:
a1061 1
	  sc->mallocIdx++;
d1079 2
a1080 2
u_long
neo_round_buffersize(addr, size)
d1082 2
a1083 1
	u_long size;
@


1.2
log
@

Remove printf from interrupt handler...

Use blksize more aggressively instead of hard-wiring it everywhere

Fix to nm_waitcd and neo_malloc. neo_malloc still ain't pretty.
@
text
@d1 1
a1 1
/*      $OpenBSD: neo.c,v 1.1 2000/04/13 00:10:52 csapuntz Exp $       */
d54 63
d257 1
d259 3
@


1.1
log
@

NeoMagic 256AV/ZX audio driver

Still in beta.

May lock up your machine when accessing mixer
@
text
@d1 1
a1 1
/*      $OpenBSD: if_fxp.c,v 1.25 2000/03/30 02:49:35 jason Exp $       */
d86 4
d93 2
d299 1
d304 2
a305 1
		else
d307 1
d309 1
a309 1
	return (nm_rd(sc, sc->ac97_status, 2) & sc->ac97_busy);
d371 1
a371 3
		printf ("offset = %d\n", nmchan_getptr(sc, AUMODE_PLAY));

		sc->pwmark += (sc->pbufsize / 2);
d385 4
d853 2
a854 1
	sc->pwmark = sc->pbufsize / 2;
d888 8
a897 5
	nm_wr(sc, NM_RBUFFER_START, sc->rbuf, 4);
	nm_wr(sc, NM_RBUFFER_END, 
	      sc->rbuf + ((char *)end - (char *)start), 4);
	nm_wr(sc, NM_RBUFFER_CURRP, sc->rbuf, 4);
	nm_wr(sc, NM_RBUFFER_WMARK, sc->rbuf + NM_BUFFSIZE / 2, 4);
a968 10
#if 0
int
neo_get_portnum_by_name(sc, class, device, qualifier)
	struct neo_softc *sc;
	char *class, *device, *qualifier;
{
	return ((sc->codec_if->vtbl->get_portnum_by_name)(sc->codec_if, class,
             device, qualifier));
}
#endif
d977 1
d979 14
a992 1
	return ((char *)sc->bufioh + sc->pbuf);
@

