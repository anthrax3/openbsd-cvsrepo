head	1.25;
access;
symbols
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.25.0.12
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.10
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.4
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.24.0.24
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.22
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.18
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.16
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.14
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.12
	OPENBSD_5_0:1.24.0.10
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.8
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.6
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.4
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.19.0.8
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.6
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.9.0.8
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.9
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SMP:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.2;
locks; strict;
comment	@ * @;


1.25
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.24;
commitid	LS2TNeCue5R9L67C;

1.24
date	2009.04.06.15.18.45;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2009.03.06.08.04.31;	author grange;	state Exp;
branches;
next	1.22;

1.22
date	2009.03.05.21.19.04;	author grange;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.03.10.32.19;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2008.05.06.12.20.45;	author mpf;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.29.21.34.51;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.22.02.36.28;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.21.20.11.47;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.18.05.39.10;	author nate;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.09.04.10.10;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.23.04.02.25;	author marco;	state Exp;
branches;
next	1.13;

1.13
date	2004.08.29.19.07.26;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.28.15.49.44;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.21.20.33.39;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.19.11.51.56;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.27.19.21.16;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.28.20.57.34;	author nate;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.16.18.31.22;	author art;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.07.12.04.22;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.07.11.24.09;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.12.15.40.29;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.10.09.39.36;	author niklas;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.05.14.22.25.31;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.07.04.10.41.49;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2002.03.28.15.35.56;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2003.03.28.00.38.20;	author niklas;	state Exp;
branches;
next	1.1.4.6;

1.1.4.6
date	2004.06.05.23.12.48;	author niklas;	state Exp;
branches;
next	;

1.6.4.1
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@/*	$OpenBSD: aac_pci.c,v 1.24 2009/04/06 15:18:45 kettenis Exp $	*/

/*-
 * Copyright (c) 2000 Michael Smith
 * Copyright (c) 2000 BSDi
 * Copyright (c) 2000 Niklas Hallqvist
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$FreeBSD: /c/ncvs/src/sys/dev/aac/aac_pci.c,v 1.1 2000/09/13 03:20:34 msmith Exp $
 */

/*
 * This driver would not have rewritten for OpenBSD if it was not for the
 * hardware donation from Nocom.  I want to thank them for their support.
 * Of course, credit should go to Mike Smith for the original work he did
 * in the FreeBSD driver where I found lots of inspiration.
 * - Niklas Hallqvist
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <sys/selinfo.h>
#include <sys/rwlock.h>
#include <sys/endian.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

#include <dev/ic/aacreg.h>
#include <dev/ic/aacvar.h>

int	aac_pci_probe(struct device *, void *, void *);
void	aac_pci_attach(struct device *, struct device *, void *);

/* Adaptec */
#define PCI_PRODUCT_ADP2_AACASR2200S   0x0285
#define PCI_PRODUCT_ADP2_AACASR2120S   0x0286
#define PCI_PRODUCT_ADP2_AACADPSATA2C  0x0289
#define PCI_PRODUCT_ADP2_AACASR2230S   0x028c
#define PCI_PRODUCT_ADP2_AACASR2130S   0x028d
#define PCI_PRODUCT_ADP2_AACADPSATA4C  0x0290
#define PCI_PRODUCT_ADP2_AACADPSATA6C  0x0291
#define PCI_PRODUCT_ADP2_AACADPSATA8C  0x0292
#define PCI_PRODUCT_ADP2_AACADPSATA16C 0x0293

/* Dell */
#define PCI_PRODUCT_ADP2_AACCERCSATA6C 0x0291
#define PCI_PRODUCT_ADP2_AACPERC320DC  0x0287

/* IBM */
#define PCI_PRODUCT_ADP2_AACSERVERAID8I 0x02f2
#define PCI_PRODUCT_ADP2_AACSERVERAID8I_2 0x0312
#define PCI_PRODUCT_ADP2_AACSERVERAID8K 0x9580
#define PCI_PRODUCT_ADP2_AACSERVERAID8S 0x034d

struct aac_sub_ident {
	u_int16_t subvendor;
	u_int16_t subdevice;
	char *desc;
} aac_sub_identifiers[] = {
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACADPSATA2C, "Adaptec 1210SA" }, /* guess */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACASR2130S, "Adaptec 2130S" },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACASR2230S, "Adaptec 2230S" },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACADPSATA4C, "Adaptec 2410SA" },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACADPSATA6C, "Adaptec 2610SA" },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACADPSATA8C, "Adaptec 2810SA" }, /* guess */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACADPSATA16C, "Adaptec 21610SA" }, /* guess */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACASR2120S, "Adaptec 2120S" },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACASR2200S, "Adaptec 2200S" },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_ADP2_AACCERCSATA6C, "Dell CERC-SATA" },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_ADP2_AACPERC320DC, "Dell PERC 320/DC" },
	{ PCI_VENDOR_IBM, PCI_PRODUCT_ADP2_AACSERVERAID8I, "IBM ServeRAID-8i" },
	{ PCI_VENDOR_IBM, PCI_PRODUCT_ADP2_AACSERVERAID8I_2, "IBM ServeRAID-8i" },
	{ PCI_VENDOR_IBM, PCI_PRODUCT_ADP2_AACSERVERAID8K, "IBM ServeRAID-8k" },
	{ PCI_VENDOR_IBM, PCI_PRODUCT_ADP2_AACSERVERAID8S, "IBM ServeRAID-8s" },
	{ 0, 0, "" }
};

struct aac_ident {
	u_int16_t vendor;
	u_int16_t device;
	u_int16_t subvendor;
	u_int16_t subdevice;
	int	hwif;
} aac_identifiers[] = {
	/* Dell PERC 2/Si models */
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_2SI, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_2SI, AAC_HWIF_I960RX },
	/* Dell PERC 3/Di models */
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_3, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_SUB2, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_SUB3, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI_3, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_3_SUB, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI_3, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_3_SUB2, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI_3, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_3_SUB3, AAC_HWIF_I960RX },
	/* Dell PERC 3/Si models */
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3SI, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3SI, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3SI_2, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3SI_2_SUB, AAC_HWIF_I960RX },
	/* Adaptec SATA RAID 2 channel XXX guess */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_ASR2200S, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_AACADPSATA2C, AAC_HWIF_I960RX },
	/* Adaptec SATA RAID 4 channel */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_ASR2200S, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_AACADPSATA4C, AAC_HWIF_I960RX },
	/* Adaptec SATA RAID 6 channel XXX guess */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_ASR2200S, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_AACADPSATA6C, AAC_HWIF_I960RX },
	/* Adaptec SATA RAID 8 channel XXX guess */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_ASR2200S, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_AACADPSATA8C, AAC_HWIF_I960RX },
	/* Adaptec SATA RAID 16 channel XXX guess */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_ASR2200S, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_AACADPSATA16C, AAC_HWIF_I960RX },
	/* Dell CERC-SATA */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_ASR2200S, PCI_VENDOR_DELL,
	    PCI_PRODUCT_ADP2_AACCERCSATA6C, AAC_HWIF_I960RX },
	/* Dell PERC 320/DC */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_ASR2200S, PCI_VENDOR_DELL,
	    PCI_PRODUCT_ADP2_AACPERC320DC, AAC_HWIF_I960RX },
	/* Adaptec ADP-2622 */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AAC2622, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_AAC2622, AAC_HWIF_I960RX },
	/* Adaptec ADP-364 */
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_21554, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_AAC364, AAC_HWIF_STRONGARM },
	/* Adaptec ADP-3642 */
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_21554, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_AAC3642, AAC_HWIF_STRONGARM },
	/* Dell PERC 2/QC */
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_21554, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_PERC_2QC, AAC_HWIF_STRONGARM },
	/* HP NetRAID-4M */
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_21554, PCI_VENDOR_HP,
	    PCI_PRODUCT_HP_NETRAID_4M, AAC_HWIF_STRONGARM },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_ASR2200S, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_ASR2120S, AAC_HWIF_I960RX },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_ASR2200S, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_ASR2200S, AAC_HWIF_I960RX },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACASR2120S, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_AACASR2130S, AAC_HWIF_RKT },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACASR2120S, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_AACASR2230S, AAC_HWIF_RKT },
	/* IBM ServeRAID-8i/8k/8s */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACASR2200S, PCI_VENDOR_IBM,
	    PCI_PRODUCT_ADP2_AACSERVERAID8I, AAC_HWIF_I960RX },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACASR2200S, PCI_VENDOR_IBM,
	    PCI_PRODUCT_ADP2_AACSERVERAID8I_2, AAC_HWIF_I960RX },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACASR2120S, PCI_VENDOR_IBM,
	    PCI_PRODUCT_ADP2_AACSERVERAID8K, AAC_HWIF_RKT },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACASR2200S, PCI_VENDOR_IBM,
	    PCI_PRODUCT_ADP2_AACSERVERAID8S, AAC_HWIF_I960RX },
	{ 0, 0, 0, 0 }
};

struct cfattach aac_pci_ca = {
	sizeof (struct aac_softc), aac_pci_probe, aac_pci_attach
};

/*
 * Determine whether this is one of our supported adapters.
 */
int
aac_pci_probe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
        struct pci_attach_args *pa = aux;
	struct aac_ident *m;
	u_int32_t subsysid;

	for (m = aac_identifiers; m->vendor != 0; m++)
		if (m->vendor == PCI_VENDOR(pa->pa_id) &&
		    m->device == PCI_PRODUCT(pa->pa_id)) {
			subsysid = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    PCI_SUBSYS_ID_REG);
			if (m->subvendor == PCI_VENDOR(subsysid) &&
			    m->subdevice == PCI_PRODUCT(subsysid))
				return (1);
		}
	return (0);
}

void
aac_pci_attach(parent, self, aux)
        struct device *parent, *self;
        void *aux;
{
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	struct aac_softc *sc = (void *)self;
	bus_addr_t membase;
	bus_size_t memsize;
	pci_intr_handle_t ih;
	const char *intrstr;
	int state = 0;
	struct aac_ident *m;
	struct aac_sub_ident *subid;
	u_int32_t subsysid;
	pcireg_t memtype;

	printf(": ");
	subsysid = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);
	if ((PCI_VENDOR(pa->pa_id) != PCI_VENDOR(subsysid)) ||
	    (PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT(subsysid))) {
		for (subid = aac_sub_identifiers; subid->subvendor != 0;
		    subid++) {
			if (subid->subvendor == PCI_VENDOR(subsysid) &&
			    subid->subdevice == PCI_PRODUCT(subsysid)) {
				printf("%s ", subid->desc);
				break;
			}
		}
	}

	/*
	 * Map control/status registers.
	 */
	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, PCI_MAPREG_START);
	if (pci_mapreg_map(pa, PCI_MAPREG_START, memtype, 0, &sc->aac_memt,
	    &sc->aac_memh, &membase, &memsize, AAC_REGSIZE)) {
		printf("can't find mem space\n");
		goto bail_out;
	}
	state++;

	if (pci_intr_map(pa, &ih)) {
		printf("couldn't map interrupt\n");
		goto bail_out;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->aac_ih = pci_intr_establish(pc, ih, IPL_BIO, aac_intr, sc,
	    sc->aac_dev.dv_xname);
	if (sc->aac_ih == NULL) {
		printf("couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto bail_out;
	}
	state++;
	if (intrstr != NULL)
		printf("%s\n", intrstr);

	sc->aac_dmat = pa->pa_dmat;
 
	for (m = aac_identifiers; m->vendor != 0; m++)
		if (m->vendor == PCI_VENDOR(pa->pa_id) &&
		    m->device == PCI_PRODUCT(pa->pa_id)) {
			if (m->subvendor == PCI_VENDOR(subsysid) &&
			    m->subdevice == PCI_PRODUCT(subsysid)) {
				sc->aac_hwif = m->hwif;
				switch(sc->aac_hwif) {
				case AAC_HWIF_I960RX:
					AAC_DPRINTF(AAC_D_MISC,
					    ("set hardware up for i960Rx"));
					sc->aac_if = aac_rx_interface;
					break;
				case AAC_HWIF_STRONGARM:
					AAC_DPRINTF(AAC_D_MISC,
					    ("set hardware up for StrongARM"));
					sc->aac_if = aac_sa_interface;
					break;
				case AAC_HWIF_FALCON:
					AAC_DPRINTF(AAC_D_MISC,
					   ("set hardware up for Falcon/PPC"));
					sc->aac_if = aac_fa_interface;
					break;
				case AAC_HWIF_RKT:
					AAC_DPRINTF(AAC_D_MISC,
					   ("set hardware up for Rocket/MIPS"));
					sc->aac_if = aac_rkt_interface;
					break;
				default:
					sc->aac_hwif = AAC_HWIF_UNKNOWN;
					break;
				}
				break;
			}
		}

	if (aac_attach(sc))
		goto bail_out;

	return;

 bail_out:
	if (state > 1)
		pci_intr_disestablish(pc, sc->aac_ih);
	if (state > 0)
		bus_space_unmap(sc->aac_memt, sc->aac_memh, memsize);
	return;
}
@


1.24
log
@Adjust for renaming the DEC 21554 in pcidevs.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.23 2009/03/06 08:04:31 grange Exp $	*/
d49 1
a51 1
#include <machine/endian.h>
@


1.23
log
@Bring a few more PCI IDs from freebsd to match IBM ServeRAID 8i and 8s.
Not tested but should work.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.22 2009/03/05 21:19:04 grange Exp $	*/
d166 1
a166 1
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_CPQ42XX, PCI_VENDOR_ADP2,
d169 1
a169 1
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_CPQ42XX, PCI_VENDOR_ADP2,
d172 1
a172 1
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_CPQ42XX, PCI_VENDOR_ADP2,
d175 1
a175 1
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_CPQ42XX, PCI_VENDOR_HP,
@


1.22
log
@Add support for IBM ServeRAID-8k. Thanks to Sergey Prysiazhnyi
<apelsin@@atmnis.com> for patiently testing my numerous diffs.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.21 2008/06/03 10:32:19 brad Exp $	*/
d83 2
d86 1
d104 2
d107 1
d185 5
a189 1
	/* IBM ServeRAID */
d192 2
@


1.21
log
@deal with a 64-bit BAR such as with PCIe chipsets.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.20 2008/05/06 12:20:45 mpf Exp $	*/
d82 3
d101 1
d179 3
@


1.20
log
@Remove bogus entries for PCI_PRODUCT_DELL_PERC_3DI_2, which apparently
is an UART. Makes aac(4) compile again.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.19 2006/06/29 21:34:51 deraadt Exp $	*/
d223 1
d242 2
a243 2
	if (pci_mapreg_map(pa, PCI_MAPREG_START,
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0, &sc->aac_memt,
@


1.19
log
@do not check for master/io/mem enables; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.18 2006/04/22 02:36:28 brad Exp $	*/
a114 2
	    PCI_PRODUCT_DELL_PERC_3DI_2, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI, PCI_VENDOR_DELL,
a119 2
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI_2, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_2_SUB, AAC_HWIF_I960RX },
@


1.18
log
@Add support for the Adaptec RAID-On-Chip architecture.  This in turn
provides support for the Adaptec 2130S and 2230SLP adapters.

From FreeBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.17 2005/11/21 20:11:47 deraadt Exp $	*/
a218 1
	pcireg_t command;
a239 14
	}

	/*
	 * Verify that the adapter is correctly set up in PCI space.
	 */
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	AAC_DPRINTF(AAC_D_MISC, ("pci command status reg 0x08x "));
	if (!(command & PCI_COMMAND_MASTER_ENABLE)) {
		printf("can't enable bus-master feature\n");
		goto bail_out;
	}
	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf("memory window not available\n");
		goto bail_out;
@


1.17
log
@missing selinfo changeover
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.16 2005/11/18 05:39:10 nate Exp $	*/
d71 2
d88 2
d175 4
a299 1

d309 8
@


1.16
log
@Major improvements to the aac(4) device driver.
- decouple the command structures from scsi structures, allowing non block
oriented commands (e.g. management commands) to be built.
- redesign the various command queues to remove race conditions and to allow
commands from multiple sources to coexist in the system
- move major processing of commands and messages to a dedicated kernel
thread to avoid spending too long in the interrupt handler
- add device data structures for various management commands to the header
file

Much code from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.15 2005/08/09 04:10:10 mickey Exp $	*/
d47 1
a47 1
#include <sys/select.h>
@


1.15
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.14 2004/11/23 04:02:25 marco Exp $	*/
d47 2
a166 1
	/* Adaptec ASR-2120S */
d168 1
a168 2
	    PCI_PRODUCT_ADP2_AACASR2120S, AAC_HWIF_I960RX },
	/* Adaptec ASR-2200S */
d170 1
a170 1
	    PCI_PRODUCT_ADP2_AACASR2200S, AAC_HWIF_I960RX },
d253 2
a254 2
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0, &sc->sc_memt,
	    &sc->sc_memh, &membase, &memsize, AAC_REGSIZE)) {
d265 3
a267 3
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_BIO, aac_intr, sc,
	    sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
d278 1
a278 1
	sc->sc_dmat = pa->pa_dmat;
d285 2
a286 2
				sc->sc_hwif = m->hwif;
				switch(sc->sc_hwif) {
d290 1
a290 1
					sc->sc_if = aac_rx_interface;
d296 6
a301 1
					sc->sc_if = aac_sa_interface;
d315 1
a315 1
		pci_intr_disestablish(pc, sc->sc_ih);
d317 1
a317 1
		bus_space_unmap(sc->sc_memt, sc->sc_memh, memsize);
@


1.14
log
@Add Adaptec ASR2200S U320 RAID
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.13 2004/08/29 19:07:26 marco Exp $	*/
d211 1
a211 1
	u_int16_t command;
a237 3
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
@


1.13
log
@Add Adaptec 2120S.  ok deraadt@@ mickey@@

Found and tested by Alexei E. Suslikov <cruel at texnika.com.ua>
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.12 2004/05/28 15:49:44 marco Exp $	*/
d66 1
d89 1
d168 3
@


1.12
log
@Clean up subsysid lookups + print subsysid string during boot.
Add:
* Adaptec 1210SA, 2410SA, 2610SA, 2810SA, 21610SA
* Dell CERC-SATA, PERC 320/DC
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.11 2004/05/21 20:33:39 marco Exp $	*/
d66 1
d87 1
d163 3
@


1.11
log
@Add support for Dell CERC SATA.  ok krw@@, henning@@ & deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.10 2004/05/19 11:51:56 henning Exp $	*/
d65 26
d125 16
a140 1
	/* Adaptec CERC-SATA */
d142 4
a145 1
	    PCI_PRODUCT_ADP2_AACCERCSATA, AAC_HWIF_I960RX },
d208 1
d212 12
a275 2
			subsysid = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    PCI_SUBSYS_ID_REG);
@


1.10
log
@unbreak by removing the 'nonexistant" PERC 3/QC here as well
we usually test compile at least a kernel before removing pcidevs shitz...
the carrot goes to marco's nose
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.9 2002/07/27 19:21:16 aaron Exp $	*/
d99 3
@


1.9
log
@Was missing product entries for the PERC_3DI_2 and PERC_3DI_3 ID's. Now the
RAID in Dell PowerEdge 2650 machines will be configured.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.8 2002/04/28 20:57:34 nate Exp $	*/
a110 3
	/* Dell PERC 3/QC */
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_CPQ42XX, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_PERC_3QC, AAC_HWIF_STRONGARM },
@


1.8
log
@Add some new PERC 3/Di models.
From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.7 2002/03/14 01:26:58 millert Exp $	*/
d78 4
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.6 2001/09/16 18:31:22 art Exp $	*/
d84 6
@


1.6
log
@Typo in comment.
From Alexander Yurchenko <grange@@rt.mipt.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.5 2001/08/25 10:13:29 art Exp $	*/
d62 2
a63 2
int	aac_pci_probe __P((struct device *, void *, void *));
void	aac_pci_attach __P((struct device *, struct device *, void *));
@


1.6.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.6 2001/09/16 18:31:22 art Exp $	*/
d62 2
a63 2
int	aac_pci_probe(struct device *, void *, void *);
void	aac_pci_attach(struct device *, struct device *, void *);
a83 6
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI_3, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_3_SUB, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI_3, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_3_SUB2, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI_3, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_3_SUB3, AAC_HWIF_I960RX },
@


1.6.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.6.4.1 2002/06/11 03:42:24 art Exp $	*/
a77 4
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_2, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_3, AAC_HWIF_I960RX },
@


1.5
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.4 2001/07/07 12:04:22 niklas Exp $	*/
d35 1
a35 1
 * hardware dontion from Nocom.  I want to thank them for their support.
@


1.4
log
@On 2nd though, pci_conf_read returns host-ordered words.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.3 2001/07/07 11:24:09 niklas Exp $	*/
d186 1
a186 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin, pa->pa_intrline,
	    &ih)) {
@


1.3
log
@Correct PCI identifier matching.  Match more devices too.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.2 2001/06/12 15:40:29 niklas Exp $	*/
d130 2
a131 2
			subsysid = letoh32(pci_conf_read(pa->pa_pc, pa->pa_tag,
			    PCI_SUBSYS_ID_REG));
d210 2
a211 2
			subsysid = letoh32(pci_conf_read(pa->pa_pc, pa->pa_tag,
			    PCI_SUBSYS_ID_REG));
@


1.2
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.1 2000/11/10 09:39:36 niklas Exp $	*/
d68 2
d72 36
a107 10
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_2SI, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3SI, AAC_HWIF_I960RX },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AAC2622, AAC_HWIF_I960RX },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AAC364, AAC_HWIF_STRONGARM },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AAC3642, AAC_HWIF_STRONGARM },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_PERC_2QC, AAC_HWIF_STRONGARM },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_PERC_3QC, AAC_HWIF_STRONGARM },
	{ PCI_VENDOR_HP, PCI_PRODUCT_HP_NETRAID_4M, AAC_HWIF_STRONGARM },
	{ 0, 0, 0 }
d125 1
d129 7
a135 2
		    m->device == PCI_PRODUCT(pa->pa_id))
			return (1);
d154 1
d210 18
a227 12
			sc->sc_hwif = m->hwif;
			switch(sc->sc_hwif) {
			case AAC_HWIF_I960RX:
				AAC_DPRINTF(AAC_D_MISC,
				    ("set hardware up for i960Rx"));
				sc->sc_if = aac_rx_interface;
				break;

			case AAC_HWIF_STRONGARM:
				AAC_DPRINTF(AAC_D_MISC,
				    ("set hardware up for StrongARM"));
				sc->sc_if = aac_sa_interface;
a229 1
			break;
@


1.1
log
@Adaptec "FSA" RAID driver
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d145 1
a145 1
	    &sc->sc_memh, &membase, &memsize)) {
@


1.1.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.1 2000/11/10 09:39:36 niklas Exp $	*/
@


1.1.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.1.4.1 2001/05/14 22:25:31 niklas Exp $	*/
d145 1
a145 1
	    &sc->sc_memh, &membase, &memsize, AAC_REGSIZE)) {
@


1.1.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: aac_pci.c,v 1.1.4.2 2001/07/04 10:41:49 niklas Exp $	*/
d35 1
a35 1
 * hardware donation from Nocom.  I want to thank them for their support.
a67 2
	u_int16_t subvendor;
	u_int16_t subdevice;
d70 10
a79 36
	/* Dell PERC 2/Si models */
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_2SI, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_2SI, AAC_HWIF_I960RX },
	/* Dell PERC 3/Di models */
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_SUB2, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_SUB3, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI_2, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_2_SUB, AAC_HWIF_I960RX },
	/* Dell PERC 3/Si models */
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3SI, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3SI, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3SI_2, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3SI_2_SUB, AAC_HWIF_I960RX },
	/* Adaptec ADP-2622 */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AAC2622, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_AAC2622, AAC_HWIF_I960RX },
	/* Adaptec ADP-364 */
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_CPQ42XX, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_AAC364, AAC_HWIF_STRONGARM },
	/* Adaptec ADP-3642 */
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_CPQ42XX, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_AAC3642, AAC_HWIF_STRONGARM },
	/* Dell PERC 2/QC */
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_CPQ42XX, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_PERC_2QC, AAC_HWIF_STRONGARM },
	/* Dell PERC 3/QC */
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_CPQ42XX, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_PERC_3QC, AAC_HWIF_STRONGARM },
	/* HP NetRAID-4M */
	{ PCI_VENDOR_DEC, PCI_PRODUCT_DEC_CPQ42XX, PCI_VENDOR_HP,
	    PCI_PRODUCT_HP_NETRAID_4M, AAC_HWIF_STRONGARM },
	{ 0, 0, 0, 0 }
a96 1
	u_int32_t subsysid;
d100 2
a101 7
		    m->device == PCI_PRODUCT(pa->pa_id)) {
			subsysid = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    PCI_SUBSYS_ID_REG);
			if (m->subvendor == PCI_VENDOR(subsysid) &&
			    m->subdevice == PCI_PRODUCT(subsysid))
				return (1);
		}
a119 1
	u_int32_t subsysid;
d151 2
a152 1
	if (pci_intr_map(pa, &ih)) {
d175 12
a186 18
			subsysid = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    PCI_SUBSYS_ID_REG);
			if (m->subvendor == PCI_VENDOR(subsysid) &&
			    m->subdevice == PCI_PRODUCT(subsysid)) {
				sc->sc_hwif = m->hwif;
				switch(sc->sc_hwif) {
				case AAC_HWIF_I960RX:
					AAC_DPRINTF(AAC_D_MISC,
					    ("set hardware up for i960Rx"));
					sc->sc_if = aac_rx_interface;
					break;

				case AAC_HWIF_STRONGARM:
					AAC_DPRINTF(AAC_D_MISC,
					    ("set hardware up for StrongARM"));
					sc->sc_if = aac_sa_interface;
					break;
				}
d189 1
@


1.1.4.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 2
a63 2
int	aac_pci_probe(struct device *, void *, void *);
void	aac_pci_attach(struct device *, struct device *, void *);
@


1.1.4.5
log
@Sync the SMP branch with 3.3
@
text
@a78 4
	    PCI_PRODUCT_DELL_PERC_3DI_2, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_3, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI, PCI_VENDOR_DELL,
a83 6
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI_3, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_3_SUB, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI_3, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_3_SUB2, AAC_HWIF_I960RX },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_DELL_PERC_3DI_3, PCI_VENDOR_DELL,
	    PCI_PRODUCT_DELL_PERC_3DI_3_SUB3, AAC_HWIF_I960RX },
@


1.1.4.6
log
@Merge with the trunk
@
text
@a64 26
/* Adaptec */
#define PCI_PRODUCT_ADP2_AACADPSATA2C  0x0289
#define PCI_PRODUCT_ADP2_AACADPSATA4C  0x0290
#define PCI_PRODUCT_ADP2_AACADPSATA6C  0x0291
#define PCI_PRODUCT_ADP2_AACADPSATA8C  0x0292
#define PCI_PRODUCT_ADP2_AACADPSATA16C 0x0293

/* Dell */
#define PCI_PRODUCT_ADP2_AACCERCSATA6C 0x0291
#define PCI_PRODUCT_ADP2_AACPERC320DC  0x0287

struct aac_sub_ident {
	u_int16_t subvendor;
	u_int16_t subdevice;
	char *desc;
} aac_sub_identifiers[] = {
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACADPSATA2C, "Adaptec 1210SA" }, /* guess */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACADPSATA4C, "Adaptec 2410SA" },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACADPSATA6C, "Adaptec 2610SA" },
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACADPSATA8C, "Adaptec 2810SA" }, /* guess */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_AACADPSATA16C, "Adaptec 21610SA" }, /* guess */
	{ PCI_VENDOR_DELL, PCI_PRODUCT_ADP2_AACCERCSATA6C, "Dell CERC-SATA" },
	{ PCI_VENDOR_DELL, PCI_PRODUCT_ADP2_AACPERC320DC, "Dell PERC 320/DC" },
	{ 0, 0, "" }
};

a98 21
	/* Adaptec SATA RAID 2 channel XXX guess */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_ASR2200S, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_AACADPSATA2C, AAC_HWIF_I960RX },
	/* Adaptec SATA RAID 4 channel */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_ASR2200S, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_AACADPSATA4C, AAC_HWIF_I960RX },
	/* Adaptec SATA RAID 6 channel XXX guess */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_ASR2200S, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_AACADPSATA6C, AAC_HWIF_I960RX },
	/* Adaptec SATA RAID 8 channel XXX guess */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_ASR2200S, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_AACADPSATA8C, AAC_HWIF_I960RX },
	/* Adaptec SATA RAID 16 channel XXX guess */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_ASR2200S, PCI_VENDOR_ADP2,
	    PCI_PRODUCT_ADP2_AACADPSATA16C, AAC_HWIF_I960RX },
	/* Dell CERC-SATA */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_ASR2200S, PCI_VENDOR_DELL,
	    PCI_PRODUCT_ADP2_AACCERCSATA6C, AAC_HWIF_I960RX },
	/* Dell PERC 320/DC */
	{ PCI_VENDOR_ADP2, PCI_PRODUCT_ADP2_ASR2200S, PCI_VENDOR_DELL,
	    PCI_PRODUCT_ADP2_AACPERC320DC, AAC_HWIF_I960RX },
d111 3
a163 1
	struct aac_sub_ident *subid;
a166 12
	subsysid = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);
	if ((PCI_VENDOR(pa->pa_id) != PCI_VENDOR(subsysid)) ||
	    (PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT(subsysid))) {
		for (subid = aac_sub_identifiers; subid->subvendor != 0;
		    subid++) {
			if (subid->subvendor == PCI_VENDOR(subsysid) &&
			    subid->subdevice == PCI_PRODUCT(subsysid)) {
				printf("%s ", subid->desc);
				break;
			}
		}
	}
d219 2
@


