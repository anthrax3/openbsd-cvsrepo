head	1.38;
access;
symbols
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.37.0.6
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.35.0.4
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.33.0.4
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.32.0.16
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.14
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.32.0.10
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.8
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.6
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.31.0.4
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.30.0.4
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.28.0.4
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.2
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.27.0.6
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.4
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.2
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.10
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.8
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.6
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.6
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.14
	UBC:1.13.0.4
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.9.0.10
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.8
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.6
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3;
locks; strict;
comment	@ * @;


1.38
date	2016.08.14.04.51.29;	author dlg;	state Exp;
branches;
next	1.37;
commitid	vyQThDNY2pBp7A9K;

1.37
date	2015.11.04.00.09.59;	author dlg;	state Exp;
branches;
next	1.36;
commitid	SQdQ8n5H8XjU4sVS;

1.36
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.35;
commitid	6vhYvh5CxZAHMnsN;

1.35
date	2015.06.26.11.50.39;	author kettenis;	state Exp;
branches;
next	1.34;
commitid	ZHSeOBG3WVHwrk21;

1.34
date	2015.06.25.18.35.48;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	16OmVJruFc3qS99o;

1.33
date	2015.02.10.03.51.58;	author mpi;	state Exp;
branches;
next	1.32;
commitid	ApakTLn9KdXCsoKj;

1.32
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.31;

1.31
date	2010.05.02.22.19.27;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2009.06.19.14.13.41;	author naddy;	state Exp;
branches;
next	1.29;

1.29
date	2008.08.15.15.49.08;	author naddy;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.03.00.47.37;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2006.07.08.04.15.36;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.31.02.45.42;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.06.02.57.30;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.15.10.43.35;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.07.00.03.16;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.25.02.23.39;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2005.09.08.01.09.58;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2005.09.06.16.03.40;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2005.09.06.00.41.41;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.16.17.20.47;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.16.16.08.07;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.29.00.37.50;	author martin;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.08.21.16.47;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.02.22.50.00;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.18.19.32.01;	author mickey;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2001.05.05.20.56.59;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.20.19.39.42;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.03.06.10.18;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	99.01.11.04.31.14;	author jason;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	98.10.08.05.51.19;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	98.08.28.06.31.25;	author rahnds;	state Exp;
branches;
next	1.6;

1.6
date	98.08.07.16.48.18;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	97.11.16.07.41.27;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.11.13.21.15.21;	author rees;	state Exp;
branches;
next	1.3;

1.3
date	97.10.20.20.56.14;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	97.07.29.19.31.47;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.06.18.19.07.07;	author dm;	state Exp;
branches;
next	;

1.9.6.1
date	2001.05.14.22.25.44;	author niklas;	state Exp;
branches;
next	1.9.6.2;

1.9.6.2
date	2001.07.04.10.42.12;	author niklas;	state Exp;
branches;
next	1.9.6.3;

1.9.6.3
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.9.6.4;

1.9.6.4
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	;

1.13.4.1
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	;


desc
@@


1.38
log
@u_quad_t -> uint64_t

de is amazing(tm). it really should be cut back and simplified a bit.
@
text
@/*	$OpenBSD: if_devar.h,v 1.37 2015/11/04 00:09:59 dlg Exp $	*/
/*	$NetBSD: if_devar.h,v 1.13 1997/06/08 18:46:36 thorpej Exp $	*/

/*-
 * Copyright (c) 1994-1997 Matt Thomas (matt@@3am-software.com)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Id: if_devar.h,v 1.23 1997/06/03 18:51:16 thomas Exp
 */

#define TULIP_CSR_READ(sc, csr) \
    bus_space_read_4((sc)->tulip_bustag, (sc)->tulip_bushandle, (sc)->tulip_csrs.csr)
#define TULIP_CSR_WRITE(sc, csr, val) \
    bus_space_write_4((sc)->tulip_bustag, (sc)->tulip_bushandle, (sc)->tulip_csrs.csr, (val))

#define TULIP_CSR_READBYTE(sc, csr) \
    bus_space_read_1((sc)->tulip_bustag, (sc)->tulip_bushandle, (sc)->tulip_csrs.csr)
#define TULIP_CSR_WRITEBYTE(sc, csr, val) \
    bus_space_write_1((sc)->tulip_bustag, (sc)->tulip_bushandle, (sc)->tulip_csrs.csr, (val))

#ifdef TULIP_IOMAPPED
#define	TULIP_PCI_CSRSIZE	8
#define	TULIP_PCI_CSROFFSET	0
#else /* TULIP_IOMAPPED */
#define	TULIP_PCI_CSRSIZE	8
#define	TULIP_PCI_CSROFFSET	0
#endif /* TULIP_IOMAPPED */

/*
 * This structure contains "pointers" for the registers on
 * the various 21x4x chips.  CSR0 through CSR8 are common
 * to all chips.  After that, it gets messy...
 */
typedef struct {
    bus_size_t csr_busmode;			/* CSR0 */
    bus_size_t csr_txpoll;			/* CSR1 */
    bus_size_t csr_rxpoll;			/* CSR2 */
    bus_size_t csr_rxlist;			/* CSR3 */
    bus_size_t csr_txlist;			/* CSR4 */
    bus_size_t csr_status;			/* CSR5 */
    bus_size_t csr_command;			/* CSR6 */
    bus_size_t csr_intr;			/* CSR7 */
    bus_size_t csr_missed_frames;		/* CSR8 */
    bus_size_t csr_9;			/* CSR9 */
    bus_size_t csr_10;			/* CSR10 */
    bus_size_t csr_11;			/* CSR11 */
    bus_size_t csr_12;			/* CSR12 */
    bus_size_t csr_13;			/* CSR13 */
    bus_size_t csr_14;			/* CSR14 */
    bus_size_t csr_15;			/* CSR15 */
} tulip_regfile_t;

#define	csr_enetrom		csr_9	/* 21040 */
#define	csr_reserved		csr_10	/* 21040 */
#define	csr_full_duplex		csr_11	/* 21040 */
#define	csr_bootrom		csr_10	/* 21041/21140A/?? */
#define	csr_gp			csr_12	/* 21140* */
#define	csr_watchdog		csr_15	/* 21140* */
#define	csr_gp_timer		csr_11	/* 21041/21140* */
#define	csr_srom_mii		csr_9	/* 21041/21140* */
#define	csr_sia_status		csr_12	/* 2104x */
#define csr_sia_connectivity	csr_13	/* 2104x */
#define csr_sia_tx_rx		csr_14	/* 2104x */
#define csr_sia_general		csr_15	/* 2104x */

/*
 * While 21x4x allows chaining of its descriptors, this driver
 * doesn't take advantage of it.  We keep the descriptors in a
 * traditional FIFO ring.
 */
typedef struct {
    tulip_desc_t *ri_first;	/* first entry in ring */
    tulip_desc_t *ri_last;	/* one after last entry */
    tulip_desc_t *ri_nextin;	/* next to processed by host */
    tulip_desc_t *ri_nextout;	/* next to processed by adapter */
    int ri_max;
    int ri_free;
} tulip_ringinfo_t;

/*
 * The 21040 has a stupid restriction in that the receive
 * buffers must be longword aligned.  But since Ethernet
 * headers are not a multiple of longwords in size this forces
 * the data to non-longword aligned.  Since IP requires the
 * data to be longword aligned, we need to copy it after it has
 * been DMA'ed in our memory.
 *
 * Since we have to copy it anyways, we might as well as allocate
 * dedicated receive space for the input.  This allows to use a
 * small receive buffer size and more ring entries to be able to
 * better keep with a flood of tiny Ethernet packets.
 *
 * The receive space MUST ALWAYS be a multiple of the page size.
 * And the number of receive descriptors multiplied by the size
 * of the receive buffers must equal the receive space.  This
 * is so that we can manipulate the page tables so that even if a
 * packet wraps around the end of the receive space, we can
 * treat it as virtually contiguous.
 *
 * The above used to be true (the stupid restriction is still true)
 * but we gone to directly DMA'ing into MBUFs (unless it's on an
 * architecture which can't handle unaligned accesses) because with
 * 100Mb/s cards the copying is just too much of a hit.
 */
#ifdef __STRICT_ALIGNMENT
#define	TULIP_COPY_RXDATA	1
#endif

#define	TULIP_DATA_PER_DESC	2032
#define	TULIP_TXTIMER		4
#define	TULIP_RXDESCS		48
#define	TULIP_TXDESCS		32
#define	TULIP_RXQ_TARGET	32
#if TULIP_RXQ_TARGET >= TULIP_RXDESCS
#error TULIP_RXQ_TARGET must be less than TULIP_RXDESCS
#endif
#define	TULIP_RX_BUFLEN		((MCLBYTES < 2048 ? MCLBYTES : 2048) - 16)

/*
 * Forward reference to make C happy.
 */
typedef struct _tulip_softc_t tulip_softc_t;

/*
 * The various controllers support.  Technically the DE425 is just
 * a 21040 on EISA.  But since it remarkably difference from normal
 * 21040s, we give it its own chip id.
 */

typedef enum {
    TULIP_21040, TULIP_DE425,
    TULIP_21041,
    TULIP_21140, TULIP_21140A, TULIP_21142,
    TULIP_21143,
    TULIP_CHIPID_UNKNOWN
} tulip_chipid_t;

/*
 * Various physical media types supported.
 * BNCAUI is BNC or AUI since on the 21040 you can't really tell
 * which is in use.
 */
typedef enum {
    TULIP_MEDIA_UNKNOWN,
    TULIP_MEDIA_10BASET,
    TULIP_MEDIA_10BASET_FD,
    TULIP_MEDIA_BNC,
    TULIP_MEDIA_AUI,
    TULIP_MEDIA_EXTSIA,
    TULIP_MEDIA_AUIBNC,
    TULIP_MEDIA_100BASETX,
    TULIP_MEDIA_100BASETX_FD,
    TULIP_MEDIA_100BASET4,
    TULIP_MEDIA_100BASEFX,
    TULIP_MEDIA_100BASEFX_FD,
    TULIP_MEDIA_MAX
} tulip_media_t;

#define	TULIP_BIT(b)		(1L << ((int)(b)))
#define	TULIP_FDBIT(m)		(1L << ((int)TULIP_MEDIA_ ## m ## _FD))
#define	TULIP_MBIT(m)		(1L << ((int)TULIP_MEDIA_ ## m ))
#define	TULIP_IS_MEDIA_FD(m)	(TULIP_BIT(m) & \
				 (TULIP_FDBIT(10BASET) \
				  |TULIP_FDBIT(100BASETX) \
				  |TULIP_FDBIT(100BASEFX)))
#define	TULIP_CAN_MEDIA_FD(m)	(TULIP_BIT(m) & \
				 (TULIP_MBIT(10BASET) \
				  |TULIP_MBIT(100BASETX) \
				  |TULIP_MBIT(100BASEFX)))
#define	TULIP_FD_MEDIA_OF(m)	((tulip_media_t)((m) + 1))
#define	TULIP_HD_MEDIA_OF(m)	((tulip_media_t)((m) - 1))
#define	TULIP_IS_MEDIA_100MB(m)	((m) >= TULIP_MEDIA_100BASETX)
#define	TULIP_IS_MEDIA_TP(m)	((TULIP_BIT(m) & \
				  (TULIP_MBIT(BNC) \
				   |TULIP_MBIT(AUI) \
				   |TULIP_MBIT(AUIBNC) \
				   |TULIP_MBIT(EXTSIA))) == 0)

#define	TULIP_SROM_ATTR_MII		0x0100
#define	TULIP_SROM_ATTR_NWAY		0x0200
#define	TULIP_SROM_ATTR_AUTOSENSE	0x0400
#define	TULIP_SROM_ATTR_POWERUP		0x0800
#define	TULIP_SROM_ATTR_NOLINKPASS	0x1000

typedef struct {
    enum {
	TULIP_MEDIAINFO_NONE,
	TULIP_MEDIAINFO_SIA,
	TULIP_MEDIAINFO_GPR,
	TULIP_MEDIAINFO_MII,
	TULIP_MEDIAINFO_RESET,
	TULIP_MEDIAINFO_SYM
    } mi_type;
    union {
	struct {
	    u_int16_t sia_connectivity;
	    u_int16_t sia_tx_rx;
	    u_int16_t sia_general;
	    u_int32_t sia_gp_control;	/* 21142/21143 */
	    u_int32_t sia_gp_data;	/* 21142/21143 */
	} un_sia;
	struct {
	    u_int32_t gpr_cmdmode;
	    u_int32_t gpr_gpcontrol;	/* 21142/21143 */
	    u_int32_t gpr_gpdata;
	    u_int8_t gpr_actmask;
	    u_int8_t gpr_actdata;
	    u_int8_t gpr_default : 1;
	} un_gpr;
	struct {
	    u_int32_t mii_mediamask;
	    u_int16_t mii_capabilities;
	    u_int16_t mii_advertisement;
	    u_int16_t mii_full_duplex;
	    u_int16_t mii_tx_threshold;
	    u_int16_t mii_interrupt;	/* 21142/21143 */
	    u_int8_t mii_phyaddr;
	    u_int8_t mii_gpr_length;
	    u_int8_t mii_gpr_offset;
	    u_int8_t mii_reset_length;
	    u_int8_t mii_reset_offset;
	    u_int32_t mii_phyid;
	} un_mii;
    } mi_un;
} tulip_media_info_t;

#define	mi_sia_connectivity	mi_un.un_sia.sia_connectivity
#define	mi_sia_tx_rx		mi_un.un_sia.sia_tx_rx
#define mi_sia_general		mi_un.un_sia.sia_general
#define	mi_sia_gp_control	mi_un.un_sia.sia_gp_control
#define	mi_sia_gp_data		mi_un.un_sia.sia_gp_data

#define	mi_gpcontrol		mi_un.un_gpr.gpr_gpcontrol
#define	mi_gpdata		mi_un.un_gpr.gpr_gpdata
#define	mi_actmask		mi_un.un_gpr.gpr_actmask
#define	mi_actdata		mi_un.un_gpr.gpr_actdata
#define	mi_default		mi_un.un_gpr.gpr_default
#define	mi_cmdmode		mi_un.un_gpr.gpr_cmdmode

#define	mi_phyaddr		mi_un.un_mii.mii_phyaddr
#define	mi_gpr_length		mi_un.un_mii.mii_gpr_length
#define	mi_gpr_offset		mi_un.un_mii.mii_gpr_offset
#define	mi_reset_length		mi_un.un_mii.mii_reset_length
#define	mi_reset_offset		mi_un.un_mii.mii_reset_offset
#define	mi_capabilities		mi_un.un_mii.mii_capabilities
#define	mi_advertisement	mi_un.un_mii.mii_advertisement
#define	mi_full_duplex		mi_un.un_mii.mii_full_duplex
#define	mi_tx_threshold		mi_un.un_mii.mii_tx_threshold
#define	mi_mediamask		mi_un.un_mii.mii_mediamask
#define	mi_mii_interrupt	mi_un.un_mii.mii_interrupt
#define	mi_phyid		mi_un.un_mii.mii_phyid

#define	TULIP_MEDIAINFO_SIA_INIT(sc, mi, chipid, media) do { \
    (mi)->mi_type = TULIP_MEDIAINFO_SIA; \
    sc->tulip_mediums[TULIP_MEDIA_ ## media] = (mi); \
    (mi)->mi_sia_connectivity = TULIP_ ## chipid ## _SIACONN_ ## media; \
    (mi)->mi_sia_tx_rx        = TULIP_ ## chipid ## _SIATXRX_ ## media; \
    (mi)->mi_sia_general      = TULIP_ ## chipid ## _SIAGEN_ ## media; \
} while (0)

#define TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, media) do {	\
    if ((sc)->tulip_mediums[TULIP_MEDIA_ ## media] == NULL	\
	    && ((mi)->mi_capabilities & PHYSTS_ ## media)) {	\
	(sc)->tulip_mediums[TULIP_MEDIA_ ## media] = (mi);	\
	(mi)->mi_mediamask |= TULIP_BIT(TULIP_MEDIA_ ## media);	\
    } \
} while (0)

#define	TULIP_MII_NOPHY		32
/*
 * Some boards need to treated specially.  The following enumeration
 * identifies the cards with quirks (or those we just want to single
 * out for special merit or scorn).
 */
typedef enum {
    TULIP_21040_GENERIC,		/* Generic 21040 (works with most any board) */
    TULIP_21140_ISV,			/* Digital Semicondutor 21140 ISV SROM Format */
    TULIP_21142_ISV,			/* Digital Semicondutor 21142 ISV SROM Format */
    TULIP_21143_ISV,			/* Digital Semicondutor 21143 ISV SROM Format */
    TULIP_21140_DEC_EB,			/* Digital Semicondutor 21140 Evaluation Board */
    TULIP_21140_MII,			/* 21140[A] with MII */
    TULIP_21140_DEC_DE500,		/* Digital DE500-?? 10/100 */
    TULIP_21140_SMC_9332,		/* SMC 9332 */
    TULIP_21140_COGENT_EM100,		/* Cogent EM100 100 only */
    TULIP_21140_ZNYX_ZX34X,		/* ZNYX ZX342 10/100 */
    TULIP_21140_ASANTE,			/* AsanteFast 10/100 */
    TULIP_21140_EN1207,			/* Accton EN2107 10/100 BNC */
    TULIP_21041_GENERIC			/* Generic 21041 card */
} tulip_board_t;

typedef enum {
    TULIP_MEDIAPOLL_TIMER,		/* 100ms timer fired */
    TULIP_MEDIAPOLL_FASTTIMER,		/* <100ms timer fired */
    TULIP_MEDIAPOLL_LINKFAIL,		/* called from interrupt routine */
    TULIP_MEDIAPOLL_LINKPASS,		/* called from interrupt routine */
    TULIP_MEDIAPOLL_START,		/* start a media probe (called from reset) */
    TULIP_MEDIAPOLL_TXPROBE_OK,		/* txprobe succeeded */
    TULIP_MEDIAPOLL_TXPROBE_FAILED,	/* txprobe failed */
    TULIP_MEDIAPOLL_MAX
} tulip_mediapoll_event_t;

typedef enum {
    TULIP_LINK_DOWN,			/* Link is down */
    TULIP_LINK_UP,			/* link is ok */
    TULIP_LINK_UNKNOWN			/* we can't tell either way */
} tulip_link_status_t;

/*
 * This data structure is used to abstract out the quirks.
 * media_probe  = tries to determine the media type.
 * media_select = enables the current media (or autosenses)
 * media_poll	= autosenses media
 * media_preset = 21140, etal requires bit to set before the
 *		  the software reset; hence pre-set.  Should be
 *		  pre-reset but that's ugly.
 */

typedef struct {
    tulip_board_t bd_type;
    void (*bd_media_probe)(tulip_softc_t * const sc);
    void (*bd_media_select)(tulip_softc_t * const sc);
    void (*bd_media_poll)(tulip_softc_t * const sc, tulip_mediapoll_event_t event);
    void (*bd_media_preset)(tulip_softc_t * const sc);
} tulip_boardsw_t;

/*
 * The next few declarations are for MII/PHY based board.
 *
 *    The first enumeration identifies a superset of various datums
 * that can be obtained from various PHY chips.  Not all PHYs will
 * support all datums.
 *    The modedata structure indicates what register contains
 * a datum, what mask is applied the register contents, and what the
 * result should be.
 *    The attr structure records information about a supported PHY.
 *    The phy structure records information about a PHY instance.
 */

typedef enum {
    PHY_MODE_10T,
    PHY_MODE_100TX,
    PHY_MODE_100T4,
    PHY_MODE_FULLDUPLEX,
    PHY_MODE_MAX
} tulip_phy_mode_t;

typedef struct {
    u_int16_t pm_regno;
    u_int16_t pm_mask;
    u_int16_t pm_value;
} tulip_phy_modedata_t;

typedef struct {
    u_int32_t attr_id;
    u_int16_t attr_flags;
#define	PHY_NEED_HARD_RESET	0x0001
#define	PHY_DUAL_CYCLE_TA	0x0002
    tulip_phy_modedata_t attr_modes[PHY_MODE_MAX];
#ifdef TULIP_DEBUG
    const char *attr_name;
#endif
} tulip_phy_attr_t;

/*
 * Various probe states used when trying to autosense the media.
 */

typedef enum {
    TULIP_PROBE_INACTIVE,
    TULIP_PROBE_PHYRESET,
    TULIP_PROBE_PHYAUTONEG,
    TULIP_PROBE_GPRTEST,
    TULIP_PROBE_MEDIATEST,
    TULIP_PROBE_FAILED
} tulip_probe_state_t;

typedef struct {
    /*
     * Transmit Statistics
     */
    u_int32_t dot3StatsSingleCollisionFrames;
    u_int32_t dot3StatsMultipleCollisionFrames;
    u_int32_t dot3StatsSQETestErrors;
    u_int32_t dot3StatsDeferredTransmissions;
    u_int32_t dot3StatsLateCollisions;
    u_int32_t dot3StatsExcessiveCollisions;
    u_int32_t dot3StatsCarrierSenseErrors;
    u_int32_t dot3StatsInternalMacTransmitErrors;
    u_int32_t dot3StatsInternalTransmitUnderflows;	/* not in rfc1650! */
    u_int32_t dot3StatsInternalTransmitBabbles;		/* not in rfc1650! */
    /*
     * Receive Statistics
     */
    u_int32_t dot3StatsMissedFrames;	/* not in rfc1650! */
    u_int32_t dot3StatsAlignmentErrors;
    u_int32_t dot3StatsFCSErrors;
    u_int32_t dot3StatsFrameTooLongs;
    u_int32_t dot3StatsInternalMacReceiveErrors;
} tulip_dot3_stats_t;

/*
 * Now to important stuff.  This is softc structure (where does softc
 * come from??? No idea) for the tulip device.
 *
 */
struct _tulip_softc_t {
    struct device tulip_dev;		/* base device */
    void *tulip_ih;			/* interrupt vectoring */
    void *tulip_ats;			/* shutdown hook */

    bus_space_tag_t tulip_bustag;	/* tag of CSR region being used */
    bus_space_handle_t tulip_bushandle;	/* handle for CSR region being used */
    pci_chipset_tag_t tulip_pc;
    u_int8_t tulip_enaddr[ETHER_ADDR_LEN];
    struct ifmedia tulip_ifmedia;
    bus_dma_tag_t tulip_dmatag;		/* bus DMA tag */
    bus_dmamap_t tulip_setupmap;
    bus_dmamap_t tulip_txdescmap;
    bus_dmamap_t tulip_free_txmaps[TULIP_TXDESCS];
    unsigned tulip_num_free_txmaps;
    bus_dmamap_t tulip_rxdescmap;
    bus_dmamap_t tulip_free_rxmaps[TULIP_RXDESCS];
    unsigned tulip_num_free_rxmaps;
    struct arpcom tulip_ac;
    struct timeout tulip_stmo;
    tulip_regfile_t tulip_csrs;
    u_int32_t tulip_flags;
#define	TULIP_WANTSETUP		0x00000001
#define	TULIP_WANTHASHPERFECT	0x00000002
#define	TULIP_WANTHASHONLY	0x00000004
#define	TULIP_DOINGSETUP	0x00000008
#define	TULIP_PRINTMEDIA	0x00000010
#define	TULIP_TXPROBE_ACTIVE	0x00000020
#define	TULIP_ALLMULTI		0x00000040
#define	TULIP_WANTRXACT		0x00000080
#define	TULIP_RXACT		0x00000100
#define	TULIP_INRESET		0x00000200
#define	TULIP_NEEDRESET		0x00000400
#define	TULIP_SQETEST		0x00000800
#define	TULIP_FULLDUPLEX	0x00001000
#define	TULIP_xxxxxx1		0x00002000
#define	TULIP_WANTTXSTART	0x00004000
#define	TULIP_NEWTXTHRESH	0x00008000
#define	TULIP_NOAUTOSENSE	0x00010000
#define	TULIP_PRINTLINKUP	0x00020000
#define	TULIP_LINKUP		0x00040000
#define	TULIP_RXBUFSLOW		0x00080000
#define	TULIP_NOMESSAGES	0x00100000
#define	TULIP_SYSTEMERROR	0x00200000
#define	TULIP_TIMEOUTPENDING	0x00400000
#define	TULIP_xxxxxx2		0x00800000
#define	TULIP_TRYNWAY		0x01000000
#define	TULIP_DIDNWAY		0x02000000
#define	TULIP_RXIGNORE		0x04000000
#define	TULIP_PROBE1STPASS	0x08000000
#define	TULIP_DEVICEPROBE	0x10000000
#define	TULIP_PROMISC		0x20000000
#define	TULIP_HASHONLY		0x40000000
#define	TULIP_xxxxxx3		0x80000000
    /* only 4 bits left! */
    u_int32_t tulip_features;	/* static bits indicating features of chip */
#define	TULIP_HAVE_GPR		0x00000001	/* have gp register (140[A]) */
#define	TULIP_HAVE_RXBADOVRFLW	0x00000002	/* RX corrupts on overflow */
#define	TULIP_HAVE_POWERMGMT	0x00000004	/* Snooze/sleep modes */
#define	TULIP_HAVE_MII		0x00000008	/* Some medium on MII */
#define	TULIP_HAVE_SIANWAY	0x00000010	/* SIA does NWAY */
#define	TULIP_HAVE_DUALSENSE	0x00000020	/* SIA senses both AUI & TP */
#define	TULIP_HAVE_SIAGP	0x00000040	/* SIA has a GP port */
#define	TULIP_HAVE_BROKEN_HASH	0x00000080	/* Broken Multicast Hash */
#define	TULIP_HAVE_ISVSROM	0x00000100	/* uses ISV SROM Format */
#define	TULIP_HAVE_BASEROM	0x00000200	/* Board ROM can be cloned */
#define	TULIP_HAVE_SLAVEDROM	0x00000400	/* Board ROM cloned */
#define	TULIP_HAVE_SLAVEDINTR	0x00000800	/* Board slaved interrupt */
#define	TULIP_HAVE_SHAREDINTR	0x00001000	/* Board shares interrupts */
#define	TULIP_HAVE_OKROM	0x00002000	/* ROM was recognized */
#define	TULIP_HAVE_NOMEDIA	0x00004000	/* did not detect any media */
#define	TULIP_HAVE_STOREFWD	0x00008000	/* have CMD_STOREFWD */
#define	TULIP_HAVE_SIA100	0x00010000	/* has LS100 in SIA status */
#define	TULIP_HAVE_OKSROM	0x00020000	/* SROM CRC is OK */
    u_int32_t tulip_intrmask;	/* our copy of csr_intr */
    u_int32_t tulip_cmdmode;	/* our copy of csr_cmdmode */
    u_int32_t tulip_last_system_error : 3;	/* last system error (only value is
						   TULIP_SYSTEMERROR is also set) */
    u_int32_t tulip_txtimer;		/* transmission timer */
    u_int32_t tulip_system_errors;	/* number of system errors encountered */
    u_int32_t tulip_statusbits;	/* status bits from CSR5 that may need to be printed */

    tulip_media_info_t *tulip_mediums[TULIP_MEDIA_MAX];	/* indexes into mediainfo */
    tulip_media_t tulip_media;			/* current media type */
    u_int32_t tulip_abilities;	/* remote system's abiltities (as defined in IEEE 802.3u) */

    u_int8_t tulip_revinfo;			/* revision of chip */
    u_int8_t tulip_phyaddr;			/* 0..31 -- address of current phy */
    u_int8_t tulip_gpinit;			/* active pins on 21140 */
    u_int8_t tulip_gpdata;			/* default gpdata for 21140 */

    struct {
	u_int8_t probe_count;			/* count of probe operations */
	int32_t probe_timeout;			/* time in ms of probe timeout */
	tulip_probe_state_t probe_state;	/* current media probe state */
	tulip_media_t probe_media;		/* current media being probed */
	u_int32_t probe_mediamask;		/* medias checked */
	u_int32_t probe_passes;			/* times autosense failed */
	u_int32_t probe_txprobes;		/* txprobes attempted */
    } tulip_probe;
#define	tulip_probe_count	tulip_probe.probe_count
#define	tulip_probe_timeout	tulip_probe.probe_timeout
#define	tulip_probe_state	tulip_probe.probe_state
#define	tulip_probe_media	tulip_probe.probe_media
#define	tulip_probe_mediamask	tulip_probe.probe_mediamask
#define	tulip_probe_passes	tulip_probe.probe_passes

    tulip_chipid_t tulip_chipid;		/* type of chip we are using */
    const tulip_boardsw_t *tulip_boardsw;	/* board/chip characteristics */
    tulip_softc_t *tulip_slaves;		/* slaved devices (ZX3xx) */
#if defined(TULIP_DEBUG)
    /*
     * Debugging/Statistical information
     */
    struct {
	tulip_media_t dbg_last_media;
	u_int32_t dbg_intrs;
	u_int32_t dbg_media_probes;
	u_int32_t dbg_txprobe_nocarr;
	u_int32_t dbg_txprobe_exccoll;
	u_int32_t dbg_link_downed;
	u_int32_t dbg_link_suspected;
	u_int32_t dbg_link_intrs;
	u_int32_t dbg_link_pollintrs;
	u_int32_t dbg_link_failures;
	u_int32_t dbg_nway_starts;
	u_int32_t dbg_nway_failures;
	u_int16_t dbg_phyregs[32][4];
	u_int32_t dbg_rxlowbufs;
	u_int32_t dbg_rxintrs;
	u_int32_t dbg_last_rxintrs;
	u_int32_t dbg_high_rxintrs_hz;
	u_int32_t dbg_no_txmaps;
	u_int32_t dbg_txput_finishes[8];
	u_int32_t dbg_txprobes_ok[TULIP_MEDIA_MAX];
	u_int32_t dbg_txprobes_failed[TULIP_MEDIA_MAX];
	u_int32_t dbg_events[TULIP_MEDIAPOLL_MAX];
	u_int32_t dbg_rxpktsperintr[TULIP_RXDESCS];
    } tulip_dbg;
#endif
#if defined(TULIP_PERFSTATS)
#define	TULIP_PERF_CURRENT	0
#define	TULIP_PERF_PREVIOUS	1
#define	TULIP_PERF_TOTAL	2
#define	TULIP_PERF_MAX		3
    struct tulip_perfstats {
	uint64_t perf_intr_cycles;
	uint64_t perf_ifstart_cycles;
	uint64_t perf_ifioctl_cycles;
	uint64_t perf_ifwatchdog_cycles;
	uint64_t perf_timeout_cycles;
	uint64_t perf_txput_cycles;
	uint64_t perf_txintr_cycles;
	uint64_t perf_rxintr_cycles;
	uint64_t perf_rxget_cycles;
	unsigned perf_intr;
	unsigned perf_ifstart;
	unsigned perf_ifioctl;
	unsigned perf_ifwatchdog;
	unsigned perf_timeout;
	unsigned perf_txput;
	unsigned perf_txintr;
	unsigned perf_rxintr;
	unsigned perf_rxget;
    } tulip_perfstats[TULIP_PERF_MAX];
#define	tulip_curperfstats		tulip_perfstats[TULIP_PERF_CURRENT]
#endif
    struct mbuf_list tulip_txq;
    struct mbuf_list tulip_rxq;
    tulip_dot3_stats_t tulip_dot3stats;
    tulip_ringinfo_t tulip_rxinfo;
    tulip_ringinfo_t tulip_txinfo;
    tulip_media_info_t tulip_mediainfo[10];
    /*
     * The setup buffers for sending the setup frame to the chip.
     * one is the one being sent while the other is the one being
     * filled.
     */
#define TULIP_SETUP	192
    tulip_desc_t *tulip_setupbuf;
    u_int32_t tulip_setupdata[TULIP_SETUP / sizeof(u_int32_t)];

    char tulip_boardid[16];		/* buffer for board ID */
    u_int8_t tulip_rombuf[128];
    struct device *tulip_pci_busno;	/* needed for multiport boards */
    u_int8_t tulip_pci_devno;		/* needed for multiport boards */
    u_int8_t tulip_connidx;
    tulip_srom_connection_t tulip_conntype;
    tulip_desc_t *tulip_rxdescs;
    tulip_desc_t *tulip_txdescs;
};

#define	TULIP_DO_AUTOSENSE(sc)	(IFM_SUBTYPE((sc)->tulip_ifmedia.ifm_media) == IFM_AUTO)

static const char * const tulip_chipdescs[] = {
    "21040",
    NULL,
    "21041",
    "21140",
    "21140A",
    "21142",
    "21143",
    "82C168",
};

#ifdef TULIP_DEBUG
static const char * const tulip_mediums[] = {
    "unknown",			/* TULIP_MEDIA_UNKNOWN */
    "10baseT",			/* TULIP_MEDIA_10BASET */
    "Full Duplex 10baseT",	/* TULIP_MEDIA_10BASET_FD */
    "BNC",			/* TULIP_MEDIA_BNC */
    "AUI",			/* TULIP_MEDIA_AUI */
    "External SIA",		/* TULIP_MEDIA_EXTSIA */
    "AUI/BNC",			/* TULIP_MEDIA_AUIBNC */
    "100baseTX",		/* TULIP_MEDIA_100BASET */
    "Full Duplex 100baseTX",	/* TULIP_MEDIA_100BASET_FD */
    "100baseT4",		/* TULIP_MEDIA_100BASET4 */
    "100baseFX",		/* TULIP_MEDIA_100BASEFX */
    "Full Duplex 100baseFX",	/* TULIP_MEDIA_100BASEFX_FD */
};
#endif

static const uint64_t tulip_media_to_ifmedia[] = {
    IFM_ETHER | IFM_NONE,		/* TULIP_MEDIA_UNKNOWN */
    IFM_ETHER | IFM_10_T,		/* TULIP_MEDIA_10BASET */
    IFM_ETHER | IFM_10_T | IFM_FDX,	/* TULIP_MEDIA_10BASET_FD */
    IFM_ETHER | IFM_10_2,		/* TULIP_MEDIA_BNC */
    IFM_ETHER | IFM_10_5,		/* TULIP_MEDIA_AUI */
    IFM_ETHER | IFM_MANUAL,		/* TULIP_MEDIA_EXTSIA */
    IFM_ETHER | IFM_10_5,		/* TULIP_MEDIA_AUIBNC */
    IFM_ETHER | IFM_100_TX,		/* TULIP_MEDIA_100BASET */
    IFM_ETHER | IFM_100_TX | IFM_FDX,	/* TULIP_MEDIA_100BASET_FD */
    IFM_ETHER | IFM_100_T4,		/* TULIP_MEDIA_100BASET4 */
    IFM_ETHER | IFM_100_FX,		/* TULIP_MEDIA_100BASEFX */
    IFM_ETHER | IFM_100_FX | IFM_FDX,	/* TULIP_MEDIA_100BASEFX_FD */
};

#ifdef TULIP_DEBUG
static const char * const tulip_system_errors[] = {
    "parity error",
    "master abort",
    "target abort",
    "reserved #3",
    "reserved #4",
    "reserved #5",
    "reserved #6",
    "reserved #7",
};

static const char * const tulip_status_bits[] = {
    NULL,
    "transmit process stopped",
    NULL,
    "transmit jabber timeout",

    NULL,
    "transmit underflow",
    NULL,
    "receive underflow",

    "receive process stopped",
    "receive watchdog timeout",
    NULL,
    NULL,

    "link failure",
    NULL,
    NULL,
};
#endif

static const struct {
    tulip_srom_connection_t sc_type;
    tulip_media_t sc_media;
    u_int32_t sc_attrs;
} tulip_srom_conninfo[] = {
    { TULIP_SROM_CONNTYPE_10BASET,		TULIP_MEDIA_10BASET },
    { TULIP_SROM_CONNTYPE_BNC,			TULIP_MEDIA_BNC },
    { TULIP_SROM_CONNTYPE_AUI,			TULIP_MEDIA_AUI },
    { TULIP_SROM_CONNTYPE_100BASETX,		TULIP_MEDIA_100BASETX },
    { TULIP_SROM_CONNTYPE_100BASET4,		TULIP_MEDIA_100BASET4 },
    { TULIP_SROM_CONNTYPE_100BASEFX,		TULIP_MEDIA_100BASEFX },
    { TULIP_SROM_CONNTYPE_MII_10BASET,		TULIP_MEDIA_10BASET,
		TULIP_SROM_ATTR_MII },
    { TULIP_SROM_CONNTYPE_MII_100BASETX,	TULIP_MEDIA_100BASETX,
		TULIP_SROM_ATTR_MII },
    { TULIP_SROM_CONNTYPE_MII_100BASET4,	TULIP_MEDIA_100BASET4,
		TULIP_SROM_ATTR_MII },
    { TULIP_SROM_CONNTYPE_MII_100BASEFX,	TULIP_MEDIA_100BASEFX,
		TULIP_SROM_ATTR_MII },
    { TULIP_SROM_CONNTYPE_10BASET_NWAY,		TULIP_MEDIA_10BASET,
		TULIP_SROM_ATTR_NWAY },
    { TULIP_SROM_CONNTYPE_10BASET_FD,		TULIP_MEDIA_10BASET_FD },
    { TULIP_SROM_CONNTYPE_MII_10BASET_FD,	TULIP_MEDIA_10BASET_FD,
		TULIP_SROM_ATTR_MII },
    { TULIP_SROM_CONNTYPE_100BASETX_FD,		TULIP_MEDIA_100BASETX_FD },
    { TULIP_SROM_CONNTYPE_MII_100BASETX_FD,	TULIP_MEDIA_100BASETX_FD,
		TULIP_SROM_ATTR_MII },
    { TULIP_SROM_CONNTYPE_10BASET_NOLINKPASS,	TULIP_MEDIA_10BASET,
		TULIP_SROM_ATTR_NOLINKPASS },
    { TULIP_SROM_CONNTYPE_AUTOSENSE,		TULIP_MEDIA_UNKNOWN,
		TULIP_SROM_ATTR_AUTOSENSE },
    { TULIP_SROM_CONNTYPE_AUTOSENSE_POWERUP,	TULIP_MEDIA_UNKNOWN,
		TULIP_SROM_ATTR_AUTOSENSE|TULIP_SROM_ATTR_POWERUP },
    { TULIP_SROM_CONNTYPE_AUTOSENSE_NWAY,	TULIP_MEDIA_UNKNOWN,
		TULIP_SROM_ATTR_AUTOSENSE|TULIP_SROM_ATTR_NWAY },
    { TULIP_SROM_CONNTYPE_NOT_USED,		TULIP_MEDIA_UNKNOWN }
};
#define	TULIP_SROM_LASTCONNIDX (nitems(tulip_srom_conninfo) - 1)

static const struct {
    tulip_media_t sm_type;
    tulip_srom_media_t sm_srom_type;
} tulip_srom_mediums[] = {
    { 	TULIP_MEDIA_100BASEFX_FD,	TULIP_SROM_MEDIA_100BASEFX_FD	},
    {	TULIP_MEDIA_100BASEFX,		TULIP_SROM_MEDIA_100BASEFX	},
    {	TULIP_MEDIA_100BASET4,		TULIP_SROM_MEDIA_100BASET4	},
    {	TULIP_MEDIA_100BASETX_FD,	TULIP_SROM_MEDIA_100BASETX_FD	},
    {	TULIP_MEDIA_100BASETX,		TULIP_SROM_MEDIA_100BASETX	},
    {	TULIP_MEDIA_10BASET_FD,		TULIP_SROM_MEDIA_10BASET_FD	},
    {	TULIP_MEDIA_AUI,		TULIP_SROM_MEDIA_AUI		},
    {	TULIP_MEDIA_BNC,		TULIP_SROM_MEDIA_BNC		},
    {	TULIP_MEDIA_10BASET,		TULIP_SROM_MEDIA_10BASET	},
    {	TULIP_MEDIA_UNKNOWN						}
};

/*
 * This driver supports a maximum of 32 tulip boards.
 * This should be enough for the forseeable future.
 */
#define	TULIP_MAX_DEVICES	32

#define TULIP_RXDESC_PRESYNC(sc, di, s)	\
	bus_dmamap_sync((sc)->tulip_dmatag, (sc)->tulip_rxdescmap, \
		   (caddr_t) di - (caddr_t) (sc)->tulip_rxdescs, \
		   (s), BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE)
#define TULIP_RXDESC_POSTSYNC(sc, di, s)	\
	bus_dmamap_sync((sc)->tulip_dmatag, (sc)->tulip_rxdescmap, \
		   (caddr_t) di - (caddr_t) (sc)->tulip_rxdescs, \
		   (s), BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE)
#define	TULIP_RXMAP_PRESYNC(sc, map) \
	bus_dmamap_sync((sc)->tulip_dmatag, (map), 0, (map)->dm_mapsize, \
			BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE)
#define	TULIP_RXMAP_POSTSYNC(sc, map) \
	bus_dmamap_sync((sc)->tulip_dmatag, (map), 0, (map)->dm_mapsize, \
			BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE)
#define	TULIP_RXMAP_CREATE(sc, mapp) \
	bus_dmamap_create((sc)->tulip_dmatag, TULIP_RX_BUFLEN, 2, \
			  TULIP_DATA_PER_DESC, 0, \
			  BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW, (mapp))

#define TULIP_TXDESC_PRESYNC(sc, di, s)	\
	bus_dmamap_sync((sc)->tulip_dmatag, (sc)->tulip_txdescmap, \
			(caddr_t) di - (caddr_t) (sc)->tulip_txdescs, \
			(s), BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE)
#define TULIP_TXDESC_POSTSYNC(sc, di, s)	\
	bus_dmamap_sync((sc)->tulip_dmatag, (sc)->tulip_txdescmap, \
			(caddr_t) di - (caddr_t) (sc)->tulip_txdescs, \
			(s), BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE)
#define	TULIP_TXMAP_PRESYNC(sc, map) \
	bus_dmamap_sync((sc)->tulip_dmatag, (map), 0, (map)->dm_mapsize, \
			BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE)
#define	TULIP_TXMAP_POSTSYNC(sc, map) \
	bus_dmamap_sync((sc)->tulip_dmatag, (map), 0, (map)->dm_mapsize, \
			BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE)
#define	TULIP_TXMAP_CREATE(sc, mapp) \
	bus_dmamap_create((sc)->tulip_dmatag, TULIP_DATA_PER_DESC, \
			  TULIP_MAX_TXSEG, TULIP_DATA_PER_DESC, \
			  0, BUS_DMA_NOWAIT, (mapp))

extern struct cfattach de_ca;
extern struct cfdriver de_cd;
#define	TULIP_UNIT_TO_SOFTC(unit)	((tulip_softc_t *) de_cd.cd_devs[unit])
#define TULIP_IFP_TO_SOFTC(ifp)         ((tulip_softc_t *)((ifp)->if_softc))
#define	tulip_unit			tulip_dev.dv_unit
#define tulip_xname                     tulip_dev.dv_cfdata->cf_driver->cd_name

#define	TULIP_PRINTF_FMT		"%s%d"
#define	TULIP_PRINTF_ARGS		sc->tulip_xname, sc->tulip_unit

#define	TULIP_BURSTSIZE(unit)		3

#define	tulip_if	tulip_ac.ac_if
#define	tulip_name	tulip_if.if_name
#define	tulip_enaddr	tulip_ac.ac_enaddr
#define	tulip_multicnt	tulip_ac.ac_multicnt

#define	tulip_bpf	tulip_if.if_bpf

#define	tulip_intrfunc_t	int

#if defined(TULIP_PERFSTATS)
#define	TULIP_PERFMERGE(sc, member) \
	do { (sc)->tulip_perfstats[TULIP_PERF_TOTAL].member \
	     += (sc)->tulip_perfstats[TULIP_PERF_CURRENT].member; \
	 (sc)->tulip_perfstats[TULIP_PERF_PREVIOUS].member \
	      = (sc)->tulip_perfstats[TULIP_PERF_CURRENT].member; \
	    (sc)->tulip_perfstats[TULIP_PERF_CURRENT].member = 0; } while (0)
#define	TULIP_PERFSTART(name) const tulip_cycle_t perfstart_ ## name = TULIP_PERFREAD();
#define	TULIP_PERFEND(name)	do { \
	    (sc)->tulip_curperfstats.perf_ ## name ## _cycles += TULIP_PERFDIFF(perfstart_ ## name, TULIP_PERFREAD()); \
	    (sc)->tulip_curperfstats.perf_ ## name++; \
	} while (0)
#if defined(__i386__)
typedef uint64_t tulip_cycle_t;
static __inline__ tulip_cycle_t
TULIP_PERFREAD(
    void)
{
    tulip_cycle_t x;
    __asm__ volatile (".byte 0x0f, 0x31" : "=A" (x));
    return x;
}
#define	TULIP_PERFDIFF(s, f)	((f) - (s))
#elif defined(__alpha__)
typedef unsigned long tulip_cycle_t;
static __inline__ tulip_cycle_t
TULIP_PERFREAD(
    void)
{
    tulip_cycle_t x;
    __asm__ volatile ("rpcc %0" : "=r" (x));
    return x;
}
#define	TULIP_PERFDIFF(s, f)	((unsigned int) ((f) - (s)))
#endif
#else
#define	TULIP_PERFSTART(name)	
#define	TULIP_PERFEND(name)	do { } while (0)
#define	TULIP_PERFMERGE(s,n)	do { } while (0)
#endif /* TULIP_PERFSTATS */

#define	TULIP_MAX_TXSEG		30

#define	TULIP_ADDREQUAL(a1, a2) \
	(((u_int16_t *)a1)[0] == ((u_int16_t *)a2)[0] \
	 && ((u_int16_t *)a1)[1] == ((u_int16_t *)a2)[1] \
	 && ((u_int16_t *)a1)[2] == ((u_int16_t *)a2)[2])
#define	TULIP_ADDRBRDCST(a1) \
	(((u_int16_t *)a1)[0] == 0xFFFFU \
	 && ((u_int16_t *)a1)[1] == 0xFFFFU \
	 && ((u_int16_t *)a1)[2] == 0xFFFFU)

#define TULIP_GETCTX(m, t)	((t) (m)->m_pkthdr.ph_cookie + 0)
#define TULIP_SETCTX(m, c)	((void) ((m)->m_pkthdr.ph_cookie = (void *)(c)))
@


1.37
log
@replace the ifqueues used for tulip_txq and _rxq with mbuf_lists.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.36 2015/09/11 13:02:28 stsp Exp $	*/
d571 9
a579 9
	u_quad_t perf_intr_cycles;
	u_quad_t perf_ifstart_cycles;
	u_quad_t perf_ifioctl_cycles;
	u_quad_t perf_ifwatchdog_cycles;
	u_quad_t perf_timeout_cycles;
	u_quad_t perf_txput_cycles;
	u_quad_t perf_txintr_cycles;
	u_quad_t perf_rxintr_cycles;
	u_quad_t perf_rxget_cycles;
d829 1
a829 1
typedef u_quad_t tulip_cycle_t;
@


1.36
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.35 2015/06/26 11:50:39 kettenis Exp $	*/
d592 2
a593 2
    struct ifqueue tulip_txq;
    struct ifqueue tulip_rxq;
@


1.35
log
@There is no excuse for using dma_alloc(9) when a bus_dma_tag_t is available.

deraadt@@ thinks this isn't worth it, but reyk@@ and mlarkin@@ tested it anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.34 2015/06/25 18:35:48 deraadt Exp $	*/
d647 1
a647 1
static const int tulip_media_to_ifmedia[] = {
@


1.34
log
@Ensure the setup block is DMA reachable.
tested by reyk, mlarkin, others
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.33 2015/02/10 03:51:58 mpi Exp $	*/
d604 1
a604 1
    u_int32_t *tulip_setupdma;
@


1.33
log
@Do not abuse `rcvif'.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.32 2011/04/03 15:36:02 jasper Exp $	*/
d603 4
a606 2
    u_int32_t tulip_setupbuf[192/sizeof(u_int32_t)];
    u_int32_t tulip_setupdata[192/sizeof(u_int32_t)];
@


1.32
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.31 2010/05/02 22:19:27 miod Exp $	*/
d866 2
a867 2
#define TULIP_GETCTX(m, t)	((t) (m)->m_pkthdr.rcvif + 0)
#define TULIP_SETCTX(m, c)	((void) ((m)->m_pkthdr.rcvif = (void *) (c)))
@


1.31
log
@Remove unused softc member.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.30 2009/06/19 14:13:41 naddy Exp $	*/
d731 1
a731 2
#define	TULIP_SROM_LASTCONNIDX	\
		(sizeof(tulip_srom_conninfo)/sizeof(tulip_srom_conninfo[0]) - 1)
@


1.30
log
@Tidy up allocation of transmit DMA maps and generalize it to also
tidy up allocation of receive DMA maps.  Previously the driver was
using DMA maps off the free list without fully allocating them, in
order to save two or three lines releasing them on error paths.
This was causing it to reuse a map already in use when under load.
From NetBSD.

Revert a workaround against a NULL pointer dereference on alpha
when invoking bus_dmaamp_sync.

All submitted by Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.29 2008/08/15 15:49:08 naddy Exp $	*/
d444 1
a444 1
    struct timeout tulip_ftmo, tulip_stmo;
@


1.29
log
@Prefer unaligned accesses over copying the rx buffer on all archs that can
handle it, not only i386.  ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.28 2007/09/03 00:47:37 krw Exp $	*/
d438 2
a439 2
    bus_dmamap_t tulip_txmaps[TULIP_TXDESCS];
    unsigned tulip_txmaps_free;
d441 2
a442 2
    bus_dmamap_t tulip_rxmaps[TULIP_RXDESCS];
    unsigned tulip_rxmaps_free;
@


1.28
log
@Typos from miod. 'intrrupt' -> 'interrupt' in some comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.27 2006/07/08 04:15:36 brad Exp $	*/
d114 1
a114 1
 * of the receive buffers must equal the recevive space.  This
d124 1
a124 1
#if !defined(__i386__)
@


1.27
log
@print the chipset revision too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.26 2006/05/31 02:45:42 brad Exp $	*/
d427 1
a427 1
    void *tulip_ih;			/* intrrupt vectoring */
@


1.26
log
@allow TULIP_TXTIMER to fit in the softc field tulip_txtimer.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.25 2006/05/06 02:57:30 brad Exp $	*/
a40 2
#define	TULIP_EISA_CSRSIZE	16
#define	TULIP_EISA_CSROFFSET	0
a616 1
#ifdef TULIP_DEBUG
d618 1
a618 4
    "21040 [10Mb/s]",
#if defined(TULIP_EISA)
    "DE425 [10Mb/s]",
#else
d620 6
a625 7
#endif
    "21041 [10Mb/s]",
    "21140 [10-100Mb/s]",
    "21140A [10-100Mb/s]",
    "21142 [10-100Mb/s]",
    "21143 [10-100Mb/s]",
    "82C168 [10-100Mb/s]",
a626 1
#endif
@


1.25
log
@restore ALTQ support which was lost with rev 1.87
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.24 2005/11/15 10:43:35 mickey Exp $	*/
d505 1
a505 1
    u_int32_t tulip_txtimer : 2;	/* transmission timer */
@


1.24
log
@all csr offsets are bus_size_t
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.23 2005/11/07 00:03:16 brad Exp $	*/
a574 1
	u_quad_t perf_ifstart_one_cycles;
a583 1
	unsigned perf_ifstart_one;
@


1.23
log
@add bus_dma support.

From NetBSD

tested on i386/alpha.

ok martin@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.22 2005/09/25 02:23:39 brad Exp $	*/
d56 16
a71 16
    bus_addr_t csr_busmode;			/* CSR0 */
    bus_addr_t csr_txpoll;			/* CSR1 */
    bus_addr_t csr_rxpoll;			/* CSR2 */
    bus_addr_t csr_rxlist;			/* CSR3 */
    bus_addr_t csr_txlist;			/* CSR4 */
    bus_addr_t csr_status;			/* CSR5 */
    bus_addr_t csr_command;			/* CSR6 */
    bus_addr_t csr_intr;			/* CSR7 */
    bus_addr_t csr_missed_frames;		/* CSR8 */
    bus_addr_t csr_9;			/* CSR9 */
    bus_addr_t csr_10;			/* CSR10 */
    bus_addr_t csr_11;			/* CSR11 */
    bus_addr_t csr_12;			/* CSR12 */
    bus_addr_t csr_13;			/* CSR13 */
    bus_addr_t csr_14;			/* CSR14 */
    bus_addr_t csr_15;			/* CSR15 */
@


1.22
log
@remove more indirection through typedef's and macros
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.21 2005/09/08 01:09:58 brad Exp $	*/
a50 34
 *  Swap macro to access certain data types.
 */
#if defined(BYTE_ORDER) && BYTE_ORDER == BIG_ENDIAN
__inline__ static u_int32_t FILT_BO(u_int32_t);
__inline__ static u_int32_t DESC_BO(u_int32_t);

__inline__ static u_int32_t
FILT_BO(x)
    u_int32_t x;
{
	u_int32_t s;

	s = (x & 0xffff) << 16 | ((x & 0xff) << 8) | ((x & 0xff00) >> 8);
	return s;
}

__inline__ static u_int32_t
DESC_BO(x)
    u_int32_t x;
{
	u_int32_t s;

	s = x;
	x = (((s) >> 24) | (((s) >> 8) & 0xff00) | 
             ((s) << 24) | (((s) & 0xff00) << 8));
	return x;
}

#else
#define FILT_BO(x)	(x)
#define DESC_BO(x)	(x)
#endif

/*
d126 1
a126 1
#if defined(__alpha__) || defined(__mips__)
d130 1
d133 1
a133 1
#define	TULIP_TXDESCS		128
d437 8
d559 2
d615 2
a616 2
    tulip_desc_t tulip_rxdescs[TULIP_RXDESCS];
    tulip_desc_t tulip_txdescs[TULIP_TXDESCS];
d766 38
a813 5
#if defined(__alpha__)
/* XXX XXX NEED REAL DMA MAPPING SUPPORT XXX XXX */
#define TULIP_KVATOPHYS(sc, va)		alpha_XXX_dmamap((vm_offset_t)(va))
#endif

a824 4
#if !defined(TULIP_KVATOPHYS)
#define	TULIP_KVATOPHYS(sc, va)	vtophys((vaddr_t)va)
#endif

d876 3
@


1.21
log
@remove some trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.20 2005/09/06 16:03:40 brad Exp $	*/
a29 2
typedef bus_addr_t tulip_csrptr_t;

d90 16
a105 16
    tulip_csrptr_t csr_busmode;			/* CSR0 */
    tulip_csrptr_t csr_txpoll;			/* CSR1 */
    tulip_csrptr_t csr_rxpoll;			/* CSR2 */
    tulip_csrptr_t csr_rxlist;			/* CSR3 */
    tulip_csrptr_t csr_txlist;			/* CSR4 */
    tulip_csrptr_t csr_status;			/* CSR5 */
    tulip_csrptr_t csr_command;			/* CSR6 */
    tulip_csrptr_t csr_intr;			/* CSR7 */
    tulip_csrptr_t csr_missed_frames;		/* CSR8 */
    tulip_csrptr_t csr_9;			/* CSR9 */
    tulip_csrptr_t csr_10;			/* CSR10 */
    tulip_csrptr_t csr_11;			/* CSR11 */
    tulip_csrptr_t csr_12;			/* CSR12 */
    tulip_csrptr_t csr_13;			/* CSR13 */
    tulip_csrptr_t csr_14;			/* CSR14 */
    tulip_csrptr_t csr_15;			/* CSR15 */
a361 1

a788 2
typedef void ifnet_ret_t;
typedef u_long ioctl_cmd_t;
a795 11
#if NBPFILTER > 0
#define	TULIP_BPF_MTAP(sc, m)	bpf_mtap((sc)->tulip_if.if_bpf, m)
#define	TULIP_BPF_TAP(sc, p, l)	bpf_tap((sc)->tulip_if.if_bpf, p, l)
#define	TULIP_BPF_ATTACH(sc)
#endif

#define	TULIP_RAISESPL()		splnet()
#define	TULIP_RAISESOFTSPL()		splsoftnet()
#define	TULIP_RESTORESPL(s)		splx(s)
#define	loudprintf			printf

a859 4
#define	TULIP_EADDR_FMT		"%s"
#define	TULIP_EADDR_ARGS(addr)	ether_sprintf(addr)

#define	TULIP_CRC32_POLY	0xEDB88320UL	/* CRC-32 Poly -- Little Endian */
a869 2

typedef int tulip_spl_t;
@


1.20
log
@- fix up the ioctl handler and make it use ether_ioctl() too
- remove more unused code
- remove some of the macros to make this more readable

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.19 2005/09/06 00:41:41 brad Exp $	*/
d126 1
a126 1
 * traditional FIFO ring.  
d154 1
a154 1
 * packet wraps around the end of the receive space, we can 
d158 1
a158 1
 * but we gone to directly DMA'ing into MBUFs (unless it's on an 
d460 1
a460 1
 * come from??? No idea) for the tulip device.  
d648 1
a648 1
static const char * const tulip_chipdescs[] = { 
d845 1
a845 1
	    (sc)->tulip_curperfstats.perf_ ## name ++; \
@


1.19
log
@another round of removing ifdef crud from this driver.

ok krw@@ martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.18 2005/07/16 17:20:47 brad Exp $	*/
a825 4

#define	TULIP_ETHERCOM(sc)		(&(sc)->tulip_ac)
#define	TULIP_ARP_IFINIT(sc, ifa)	arp_ifinit(TULIP_ETHERCOM(sc), (ifa))
#define	TULIP_ETHER_IFATTACH(sc)	ether_ifattach(&(sc)->tulip_if)
@


1.18
log
@remove __BROKEN_INDIRECT_CONFIG cruft
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.17 2005/04/16 16:08:07 deraadt Exp $	*/
a29 5
#if !defined(_DEVAR_H)
#define _DEVAR_H

#if defined(__NetBSD__) || defined(__OpenBSD__)

a40 1
#endif /* __NetBSD__ */
a46 11

#if !defined(__NetBSD__) && !defined(__OpenBSD__)
typedef u_int16_t tulip_csrptr_t;

#define	TULIP_CSR_READ(sc, csr)			(inl((sc)->tulip_csrs.csr))
#define	TULIP_CSR_WRITE(sc, csr, val)   	outl((sc)->tulip_csrs.csr, val)

#define	TULIP_CSR_READBYTE(sc, csr)		(inb((sc)->tulip_csrs.csr))
#define	TULIP_CSR_WRITEBYTE(sc, csr, val)	outb((sc)->tulip_csrs.csr, val)
#endif /* __NetBSD__ */

a47 1

a49 13

#if !defined(__NetBSD__) && !defined(__OpenBSD__)
typedef volatile u_int32_t *tulip_csrptr_t;

/*
 * macros to read and write CSRs.  Note that the "0 +" in
 * READ_CSR is to prevent the macro from being an lvalue
 * and WRITE_CSR shouldn't be assigned from.
 */
#define	TULIP_CSR_READ(sc, csr)		(0 + *(sc)->tulip_csrs.csr)
#define	TULIP_CSR_WRITE(sc, csr, val)	((void)(*(sc)->tulip_csrs.csr = (val)))
#endif /* __NetBSD__ */

a380 5
#if defined(__bsdi__) && _BSDI_VERSION >= 199701
    struct ifmedia_entry *bd_media_list;
    int bd_media_cnt;
    int bd_media_options_mask;
#endif
a463 16
#if defined(__bsdi__)
    struct device tulip_dev;		/* base device */
    struct isadev tulip_id;		/* ISA device */
    struct intrhand tulip_ih;		/* intrrupt vectoring */
    struct atshutdown tulip_ats;	/* shutdown hook */
#if _BSDI_VERSION < 199401
    caddr_t tulip_bpf;			/* for BPF */
#else
    prf_t tulip_pf;			/* printf function */
#if _BSDI_VERSION >= 199701
    struct mii_data tulip_mii;		/* Generic MII and media data */
#define	tulip_ifmedia tulip_mii.mii_media
#endif /* _BSDI_VERSION >= 199701 */
#endif /* _BSDI_VERSION < 199401 */
#endif /* __bsdi__ */
#if defined(__NetBSD__) || defined(__OpenBSD__)
a470 3
#if !defined(__OpenBSD__)
    struct ethercom tulip_ec;
#endif
a471 2
#endif
#if !defined(tulip_ifmedia) && defined(IFM_ETHER)
a472 2
#endif
#if !defined(__NetBSD__)
a474 1
#endif
d531 2
a532 1
    u_int32_t tulip_last_system_error : 3;	/* last system error (only value is TULIP_SYSTEMERROR is also set) */
a636 3
#ifndef __OpenBSD__
    u_int8_t tulip_pci_busno;		/* needed for multiport boards */
#else
a637 1
#endif
a642 3
#if defined(__NetBSD__) && NRND > 0
    rndsource_element_t    tulip_rndsource;
#endif
a644 1
#if defined(IFM_ETHER)
a645 6
#else
#define	TULIP_DO_AUTOSENSE(sc)	(((sc)->tulip_flags & TULIP_NOAUTOSENSE) == 0)
#endif


#if defined(TULIP_HDR_DATA)
a680 1
#if defined(IFM_ETHER)
a694 1
#endif /* defined(IFM_ETHER) */
a784 1
#endif /* TULIP_HDR_DATA */
a791 76
#if defined(TULIP_USE_SOFTINTR) && defined(TULIP_HDR_DATA)
static u_int32_t tulip_softintr_mask;
static int tulip_softintr_last_unit;
static int tulip_softintr_max_unit;
static void tulip_softintr(void);
#endif

#ifdef notyet
#define	SIOCGADDRROM		_IOW('i', 240, struct ifreq)	/* get 128 bytes of ROM */
#define	SIOCGCHIPID		_IOWR('i', 241, struct ifreq)	/* get chipid */
#endif

#if defined(__FreeBSD__)
typedef void ifnet_ret_t;
typedef int ioctl_cmd_t;
#if defined(TULIP_HDR_DATA)
static tulip_softc_t *tulips[TULIP_MAX_DEVICES];
#endif
#if BSD >= 199506
#define TULIP_IFP_TO_SOFTC(ifp) ((tulip_softc_t *)((ifp)->if_softc))
#if NBPFILTER > 0
#define	TULIP_BPF_MTAP(sc, m)	bpf_mtap(&(sc)->tulip_if, m)
#define	TULIP_BPF_TAP(sc, p, l)	bpf_tap(&(sc)->tulip_if, p, l)
#define	TULIP_BPF_ATTACH(sc)	bpfattach(&(sc)->tulip_if, DLT_EN10MB, sizeof(struct ether_header))
#endif
#define	tulip_intrfunc_t	void
#define	TULIP_VOID_INTRFUNC
#define	IFF_NOTRAILERS		0
#if 0
#define	TULIP_KVATOPHYS(sc, va)	kvtop(va)
#endif
#define	TULIP_EADDR_FMT		"%6D"
#define	TULIP_EADDR_ARGS(addr)	addr, ":"
#else
extern int bootverbose;
#define TULIP_IFP_TO_SOFTC(ifp)         (TULIP_UNIT_TO_SOFTC((ifp)->if_unit))
#include <sys/devconf.h>
#define	TULIP_DEVCONF
#endif
#if defined(TULIP_USE_SOFTINTR)
NETISR_SET(NETISR_DE, tulip_softintr);
#endif
#define	TULIP_UNIT_TO_SOFTC(unit)	(tulips[unit])
#define	TULIP_BURSTSIZE(unit)		pci_max_burst_len
#define	loudprintf			if (bootverbose) printf
#endif

#if defined(__bsdi__)
typedef int ifnet_ret_t;
typedef u_long ioctl_cmd_t;
extern struct cfdriver decd;
#define	TULIP_UNIT_TO_SOFTC(unit)	((tulip_softc_t *) decd.cd_devs[unit])
#define TULIP_IFP_TO_SOFTC(ifp)		(TULIP_UNIT_TO_SOFTC((ifp)->if_unit))
#define	TULIP_ETHER_IFATTACH(sc)	ether_attach(&(sc)->tulip_if)
#if _BSDI_VERSION >= 199510
#if 0
#define	TULIP_BURSTSIZE(unit)		log2_burst_size
#endif
#define	loudprintf			aprint_verbose
#define	printf				(*sc->tulip_pf)
#define	MCNT(x) (sizeof(x) / sizeof(struct ifmedia_entry))
#elif _BSDI_VERSION <= 199401
#define	DRQNONE				0
#define	loudprintf			printf
static void
arp_ifinit(
    struct arpcom *ac,
    struct ifaddr *ifa)
{
    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;
    arpwhohas(ac, &ac->ac_ipaddr);
}
#endif
#endif	/* __bsdi__ */

#if defined(__NetBSD__) || defined(__OpenBSD__)
a798 1
#if defined(__OpenBSD__)
a799 3
#else
#define	tulip_xname			tulip_if.if_xname
#endif
d806 1
a811 10
#if !defined(__OpenBSD__)
#define	tulip_if			tulip_ec.ec_if
#define	tulip_enaddr			tulip_enaddr
#define	tulip_multicnt			tulip_ec.ec_multicnt
#define	TULIP_ETHERCOM(sc)		(&(sc)->tulip_ec)
#define	TULIP_ARP_IFINIT(sc, ifa)	arp_ifinit(&(sc)->tulip_if, (ifa))
#define	TULIP_ETHER_IFATTACH(sc)	ether_ifattach(&(sc)->tulip_if, (sc)->tulip_enaddr)
#define	TULIP_PRINTF_FMT		"%s"
#define	TULIP_PRINTF_ARGS		sc->tulip_xname
#else
a813 2
#endif
#endif	/* __NetBSD__ */
a819 8
#ifndef TULIP_PRINTF_FMT
#define	TULIP_PRINTF_FMT		"%s%d"
#endif
#ifndef TULIP_PRINTF_ARGS
#define	TULIP_PRINTF_ARGS		sc->tulip_name, sc->tulip_unit
#endif

#ifndef TULIP_BURSTSIZE
a820 1
#endif
a821 1
#ifndef	tulip_if
a822 4
#endif
#ifndef tulip_unit
#define	tulip_unit	tulip_if.if_unit
#endif
a823 1
#ifndef tulip_enaddr
a824 2
#endif
#ifndef tulip_multicnt
a825 1
#endif
a826 1
#if !defined(TULIP_ETHERCOM)
a827 3
#endif

#if !defined(TULIP_ARP_IFINIT)
a828 3
#endif

#if !defined(TULIP_ETHER_IFATTACH)
a829 1
#endif
a830 1
#if !defined(tulip_bpf) && (!defined(__bsdi__) || _BSDI_VERSION >= 199401)
a831 1
#endif
a832 1
#if !defined(tulip_intrfunc_t)
a833 1
#endif
a838 20
#ifndef TULIP_RAISESPL
#define	TULIP_RAISESPL()		splimp()
#endif
#ifndef TULIP_RAISESOFTSPL
#define	TULIP_RAISESOFTSPL()		splnet()
#endif
#ifndef TULUP_RESTORESPL
#define	TULIP_RESTORESPL(s)		splx(s)
#endif

/*
 * While I think FreeBSD's 2.2 change to the bpf is a nice simplification,
 * it does add yet more conditional code to this driver.  Sigh.
 */
#if !defined(TULIP_BPF_MTAP) && NBPFILTER > 0
#define	TULIP_BPF_MTAP(sc, m)	bpf_mtap((sc)->tulip_bpf, m)
#define	TULIP_BPF_TAP(sc, p, l)	bpf_tap((sc)->tulip_bpf, p, l)
#define	TULIP_BPF_ATTACH(sc)	bpfattach(&(sc)->tulip_bpf, &(sc)->tulip_if, DLT_EN10MB, sizeof(struct ether_header))
#endif

a879 4
/*
 * However, this change to FreeBSD I am much less enamored with.
 */
#if !defined(TULIP_EADDR_FMT)
a881 1
#endif
a895 2

#endif /* !defined(_DEVAR_H) */
@


1.17
log
@remove lots of crud from this driver, makes it fit on the alpha media
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.16 2005/03/29 00:37:50 martin Exp $	*/
a31 4

#if defined(__OpenBSD__)
#define __BROKEN_INDIRECT_CONFIG
#endif
@


1.16
log
@pull over some minor fixes from NetBSD:

- use ETHER_ADDR_LEN where apropriate
- consistency fixes in mem-io vs io-io logic
- fixes for 21143 in full-duplex mode
- minor nits here and there

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.15 2004/11/08 21:16:47 deraadt Exp $	*/
d723 2
d739 1
d775 1
d807 1
@


1.15
log
@put more debug stuff inside #ifdef, to make the driver a wee bit smaller
for the alpha
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.14 2002/06/02 22:50:00 deraadt Exp $	*/
d553 1
a553 1
#define	TULIP_xxxxxx0		0x00001000
d700 3
a702 1
#if defined(__NetBSD__)
a703 2
#else
    u_int8_t tulip_pci_busno;		/* needed for multiport boards */
@


1.14
log
@withough -> without
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.13 2001/07/18 19:32:01 mickey Exp $	*/
d738 1
d753 1
@


1.13
log
@fix vtophys usage, mainly ppc-required; art@@ ok and tried to bribe^H^H^H^H^Hmotivate me to bussydma 'em too (;
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.12 2001/05/05 20:56:59 art Exp $	*/
d14 1
a14 1
 *    derived from this software withough specific prior written permission
@


1.13.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.13 2001/07/18 19:32:01 mickey Exp $	*/
d14 1
a14 1
 *    derived from this software without specific prior written permission
@


1.12
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.11 2001/02/20 19:39:42 mickey Exp $	*/
d1030 1
a1030 1
#define	TULIP_KVATOPHYS(sc, va)	vtophys(va)
@


1.11
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.10 2001/02/03 06:10:18 mickey Exp $	*/
a892 1
#define	CLBYTES			PAGE_SIZE
@


1.10
log
@new timeout, space control
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.9 1999/01/11 04:31:14 jason Exp $	*/
d955 5
@


1.9
log
@remove pnic stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.8 1998/10/08 05:51:19 jason Exp $	*/
d537 1
@


1.9.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.11 2001/02/20 19:39:42 mickey Exp $	*/
a536 1
    struct timeout tulip_ftmo, tulip_stmo;
a953 5
#if NBPFILTER > 0
#define	TULIP_BPF_MTAP(sc, m)	bpf_mtap((sc)->tulip_if.if_bpf, m)
#define	TULIP_BPF_TAP(sc, p, l)	bpf_tap((sc)->tulip_if.if_bpf, p, l)
#define	TULIP_BPF_ATTACH(sc)
#endif
@


1.9.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.9.6.1 2001/05/14 22:25:44 niklas Exp $	*/
d893 1
@


1.9.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.9.6.2 2001/07/04 10:42:12 niklas Exp $	*/
d1030 1
a1030 1
#define	TULIP_KVATOPHYS(sc, va)	vtophys((vaddr_t)va)
@


1.9.6.4
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d14 1
a14 1
 *    derived from this software without specific prior written permission
@


1.8
log
@Support for the Lite-On PNIC found on Netgear FA310TX rev D1 and
several other boards.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.7 1998/08/28 06:31:25 rahnds Exp $	*/
a142 3
    tulip_csrptr_t csr_19;			/* CSR19 - PNIC */
    tulip_csrptr_t csr_20;			/* CSR20 - PNIC */
    tulip_csrptr_t csr_23;			/* CSR23 - PNIC */
a225 1
    TULIP_LC82C168,
@


1.7
log
@Changes to make if_de driver work on big endian machines with a 21040 based
card. Tested on i386 and alpha. Could use some cleanup to swab constants
instead of variables, so that the compiler can do the work, not the processor.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.6 1998/08/07 16:48:18 pefo Exp $	*/
d143 3
d229 1
d738 1
@


1.6
log
@com.c needs to know about mem mapped ports in ppc systems.

ncr.c and if_de.c needs some hooks for systems with ncr and dec
ether chips on the motherboard that runs on odd clocks and doesn't
support a srom. srom is emulated in machine dependent code.

big endian support for ncr and dec ether finished. the 21040
have some more coding requirements if it is to run BE since
it does not have the descriptor endian swap configuration bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.5 1997/11/16 07:41:27 millert Exp $	*/
d100 1
a100 2
	s = x;
	s = s << 16;
@


1.5
log
@pull #ifdef __alpha__ out from a #ifdef __NetBSD__
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.4 1997/11/13 21:15:21 rees Exp $	*/
d90 4
a93 1
#if BYTE_ORDER == BIG_ENDIAN
d95 1
a95 1
FILT_SWAP(x)
d104 13
d118 2
a119 1
#define FILT_SWAP(x)	(x)
d198 1
a198 1
#if defined(__alpha__)
@


1.4
log
@merge netbsd 1.22
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.3 1997/10/20 20:56:14 pefo Exp $	*/
a950 4
#if defined(__alpha__)
/* XXX XXX NEED REAL DMA MAPPING SUPPORT XXX XXX */
#define TULIP_KVATOPHYS(sc, va)		alpha_XXX_dmamap((vm_offset_t)(va))
#endif
d956 5
@


1.3
log
@Few minor changes to make if_de work big endian on 21140
@
text
@d1 1
a1 1
/*	$OpenBSD: if_devar.h,v 1.2 1997/07/29 19:31:47 downsj Exp $	*/
d262 1
d362 1
d468 1
d470 2
a471 1
    u_int32_t dot3StatsCarrierSenseErrors;
d536 3
a538 3
#define	TULIP_TXINTPENDING	0x00001000
#define	TULIP_xxxxxx0		0x00002000
#define	TULIP_xxxxxx1		0x00004000
d547 1
a547 1
#define	TULIP_FASTTIMEOUTPENDING	0x00800000
d555 2
a556 1
    /* only 1 bit left! */
d574 2
a636 2
	u_int32_t dbg_txpipe;
	u_int32_t dbg_txpipestats[TULIP_TXDESCS];
d639 29
d683 3
d687 1
d693 3
d901 1
a908 3
#if (_BSD_VERSION == 199510)
#define TULIP_ETHER_IFATTACH(sc)	ether_attach(&(sc)->tulip_if)
#endif
d940 1
d951 4
d959 1
d961 5
a965 5
#define	loudprintf			printf

#if defined(__alpha__)
/* XXX XXX NEED REAL DMA MAPPING SUPPORT XXX XXX */
#define TULIP_KVATOPHYS(sc, va)		alpha_XXX_dmamap((vm_offset_t)(va))
a966 1
#endif	/* __NetBSD__ */
a974 1

a977 1

a978 1

a981 1

a985 7
#ifndef TULIP_PRINTF_FMT
#define	TULIP_PRINTF_FMT		"%s%d"
#endif
#ifndef TULIP_PRINTF_ARGS
#define	TULIP_PRINTF_ARGS		sc->tulip_name, sc->tulip_unit
#endif

d1029 41
@


1.2
log
@Support BSD/OS 2.1, add OpenBSD tags.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 18
@


1.1
log
@csapuntz@@lcs.mit.edu: Port of NetBSD tulip driver.  Works with new (21140-AC-based) SMC Etherpower cards.
@
text
@d1 1
d849 3
@
