head	1.129;
access;
symbols
	OPENBSD_6_2_BASE:1.129
	OPENBSD_6_1:1.125.0.4
	OPENBSD_6_1_BASE:1.125
	OPENBSD_6_0:1.123.0.4
	OPENBSD_6_0_BASE:1.123
	OPENBSD_5_9:1.122.0.2
	OPENBSD_5_9_BASE:1.122
	OPENBSD_5_8:1.115.0.4
	OPENBSD_5_8_BASE:1.115
	OPENBSD_5_7:1.112.0.4
	OPENBSD_5_7_BASE:1.112
	OPENBSD_5_6:1.106.0.4
	OPENBSD_5_6_BASE:1.106
	OPENBSD_5_5:1.102.0.4
	OPENBSD_5_5_BASE:1.102
	OPENBSD_5_4:1.98.0.2
	OPENBSD_5_4_BASE:1.98
	OPENBSD_5_3:1.97.0.2
	OPENBSD_5_3_BASE:1.97
	OPENBSD_5_2:1.94.0.2
	OPENBSD_5_2_BASE:1.94
	OPENBSD_5_1_BASE:1.93
	OPENBSD_5_1:1.93.0.4
	OPENBSD_5_0:1.93.0.2
	OPENBSD_5_0_BASE:1.93
	OPENBSD_4_9:1.91.0.2
	OPENBSD_4_9_BASE:1.91
	OPENBSD_4_8:1.87.0.2
	OPENBSD_4_8_BASE:1.87
	OPENBSD_4_7:1.86.0.2
	OPENBSD_4_7_BASE:1.86
	OPENBSD_4_6:1.75.0.4
	OPENBSD_4_6_BASE:1.75
	OPENBSD_4_5:1.69.0.2
	OPENBSD_4_5_BASE:1.69
	OPENBSD_4_4:1.64.0.2
	OPENBSD_4_4_BASE:1.64
	OPENBSD_4_3:1.62.0.2
	OPENBSD_4_3_BASE:1.62
	OPENBSD_4_2:1.56.0.2
	OPENBSD_4_2_BASE:1.56
	OPENBSD_4_1:1.50.0.2
	OPENBSD_4_1_BASE:1.50
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17;
locks; strict;
comment	@ * @;


1.129
date	2017.06.02.01.47.36;	author dlg;	state Exp;
branches;
next	1.128;
commitid	1ApNhPU4DfNKU8bB;

1.128
date	2017.06.01.23.22.14;	author dlg;	state Exp;
branches;
next	1.127;
commitid	45puB1zmY4KCvlV9;

1.127
date	2017.04.10.02.15.54;	author jsg;	state Exp;
branches;
next	1.126;
commitid	crEWZc68Iw2tAav9;

1.126
date	2017.04.08.03.36.50;	author jmatthew;	state Exp;
branches;
next	1.125;
commitid	DRBLgFUY8hJwZ9FX;

1.125
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.124;
commitid	VyLWTsbepAOk7VQM;

1.124
date	2017.01.08.18.08.14;	author visa;	state Exp;
branches;
next	1.123;
commitid	riH4VCDRaaOQfCKK;

1.123
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.122;
commitid	8YSL8ByWzGeIGBiJ;

1.122
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.121;
commitid	B0kwmVGiD5DVx4kv;

1.121
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.120;
commitid	5gdEnqVoJuTuwdTu;

1.120
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.119;
commitid	5DvsamK0GblTp8ww;

1.119
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.118;
commitid	eYnPulzvLjDImPCa;

1.118
date	2015.11.14.17.54.57;	author mpi;	state Exp;
branches;
next	1.117;
commitid	Waft2RDjXAxr4qZ9;

1.117
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.116;
commitid	hPF95ClMUQfeqQDX;

1.116
date	2015.09.11.09.14.52;	author deraadt;	state Exp;
branches;
next	1.115;
commitid	5zugXzo285Za9CZe;

1.115
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.114;
commitid	MVWrtktB46JRxFWT;

1.114
date	2015.04.30.07.51.07;	author mpi;	state Exp;
branches;
next	1.113;
commitid	H09AuNxNnUcYramX;

1.113
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.112;
commitid	p4LJxGKbi0BU2cG6;

1.112
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.111;
commitid	yM2VFFhpDTeFQlve;

1.111
date	2014.11.24.23.28.50;	author brad;	state Exp;
branches;
next	1.110;
commitid	XH6emJ2GytHJKyJh;

1.110
date	2014.10.19.03.54.56;	author brad;	state Exp;
branches;
next	1.109;
commitid	Syw76WEKykZQsFhj;

1.109
date	2014.10.09.09.34.17;	author mpi;	state Exp;
branches;
next	1.108;
commitid	yDxsxNV4FAi6hcpx;

1.108
date	2014.10.04.18.20.50;	author brad;	state Exp;
branches;
next	1.107;
commitid	eL7cTe4eMSWeFnXu;

1.107
date	2014.09.23.21.16.42;	author brad;	state Exp;
branches;
next	1.106;
commitid	CcJdkijeMGG5QOLH;

1.106
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.105;
commitid	TGHgrLxu6sxZoiFt;

1.105
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.104;
commitid	OBNa5kfxQ2UXoiIw;

1.104
date	2014.07.09.00.15.20;	author dlg;	state Exp;
branches;
next	1.103;
commitid	YmJ8zUfUH16Nbnur;

1.103
date	2014.07.08.05.35.18;	author dlg;	state Exp;
branches;
next	1.102;
commitid	0QJleeeWqZmC5anF;

1.102
date	2013.12.28.03.35.42;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2013.12.08.16.39.38;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2013.08.07.01.06.36;	author bluhm;	state Exp;
branches;
next	1.98;

1.98
date	2013.03.17.10.56.23;	author brad;	state Exp;
branches;
next	1.97;

1.97
date	2013.02.01.06.51.32;	author brad;	state Exp;
branches;
next	1.96;

1.96
date	2012.11.29.21.10.32;	author brad;	state Exp;
branches;
next	1.95;

1.95
date	2012.10.18.21.44.21;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2012.03.28.12.02.49;	author jsg;	state Exp;
branches;
next	1.93;

1.93
date	2011.06.22.16.44.27;	author tedu;	state Exp;
branches;
next	1.92;

1.92
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.91;

1.91
date	2010.11.17.10.43.23;	author kevlo;	state Exp;
branches;
next	1.90;

1.90
date	2010.09.20.07.40.38;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2010.09.12.10.39.50;	author kettenis;	state Exp;
branches;
next	1.88;

1.88
date	2010.08.31.17.13.44;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.86;

1.86
date	2010.01.09.02.40.18;	author sthen;	state Exp;
branches;
next	1.85;

1.85
date	2009.12.18.21.46.24;	author sthen;	state Exp;
branches;
next	1.84;

1.84
date	2009.12.17.01.09.28;	author sthen;	state Exp;
branches;
next	1.83;

1.83
date	2009.11.26.00.12.31;	author kettenis;	state Exp;
branches;
next	1.82;

1.82
date	2009.11.24.15.56.03;	author kettenis;	state Exp;
branches;
next	1.81;

1.81
date	2009.11.24.14.21.26;	author claudio;	state Exp;
branches;
next	1.80;

1.80
date	2009.11.24.14.18.21;	author claudio;	state Exp;
branches;
next	1.79;

1.79
date	2009.10.15.17.54.56;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2009.10.04.18.32.02;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2009.08.13.14.24.47;	author jasper;	state Exp;
branches;
next	1.76;

1.76
date	2009.08.09.11.40.56;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2009.03.29.14.36.34;	author jsg;	state Exp;
branches;
next	1.74;

1.74
date	2009.03.29.12.53.41;	author jsg;	state Exp;
branches;
next	1.73;

1.73
date	2009.03.27.10.16.17;	author jsg;	state Exp;
branches;
next	1.72;

1.72
date	2009.03.23.21.58.54;	author kettenis;	state Exp;
branches;
next	1.71;

1.71
date	2009.03.23.21.34.20;	author kettenis;	state Exp;
branches;
next	1.70;

1.70
date	2009.03.16.12.47.35;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2009.02.22.16.40.13;	author kettenis;	state Exp;
branches;
next	1.68;

1.68
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.67;

1.67
date	2008.10.14.18.01.53;	author naddy;	state Exp;
branches;
next	1.66;

1.66
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.65;

1.65
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.64;

1.64
date	2008.06.21.21.15.20;	author brad;	state Exp;
branches;
next	1.63;

1.63
date	2008.05.23.08.49.27;	author brad;	state Exp;
branches;
next	1.62;

1.62
date	2008.03.02.19.16.43;	author brad;	state Exp;
branches;
next	1.61;

1.61
date	2008.02.03.21.20.23;	author brad;	state Exp;
branches;
next	1.60;

1.60
date	2007.11.25.00.27.44;	author kettenis;	state Exp;
branches;
next	1.59;

1.59
date	2007.11.14.10.00.47;	author brad;	state Exp;
branches;
next	1.58;

1.58
date	2007.10.02.07.35.55;	author brad;	state Exp;
branches;
next	1.57;

1.57
date	2007.09.17.08.46.52;	author brad;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.27.19.15.47;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2007.06.01.04.35.28;	author kettenis;	state Exp;
branches;
next	1.54;

1.54
date	2007.05.26.16.44.21;	author reyk;	state Exp;
branches;
next	1.53;

1.53
date	2007.05.22.04.30.55;	author ray;	state Exp;
branches;
next	1.52;

1.52
date	2007.05.14.15.28.45;	author jsg;	state Exp;
branches;
next	1.51;

1.51
date	2007.05.12.18.19.54;	author kettenis;	state Exp;
branches;
next	1.50;

1.50
date	2007.02.26.04.00.25;	author todd;	state Exp;
branches;
next	1.49;

1.49
date	2007.02.13.20.10.33;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2007.02.12.21.28.23;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2007.02.11.22.16.21;	author kettenis;	state Exp;
branches;
next	1.46;

1.46
date	2007.02.10.23.19.34;	author kettenis;	state Exp;
branches;
next	1.45;

1.45
date	2007.02.10.22.49.46;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2007.02.10.02.27.56;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2007.02.03.12.50.26;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2007.01.17.02.43.02;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2007.01.13.21.05.55;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2007.01.08.20.32.34;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2007.01.03.11.49.16;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2006.12.30.22.08.15;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2006.12.30.20.39.09;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2006.12.28.16.34.42;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2006.12.28.10.22.07;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2006.12.24.22.56.48;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2006.12.24.14.34.27;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2006.12.16.20.19.34;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2006.12.16.19.15.35;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2006.12.15.20.37.34;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2006.12.12.20.48.11;	author mk;	state Exp;
branches;
next	1.28;

1.28
date	2006.12.08.02.13.36;	author gwk;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.06.23.34.45;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2006.11.25.16.26.17;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2006.11.23.22.02.57;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2006.11.23.21.56.32;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2006.11.17.19.34.34;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2006.11.16.03.25.45;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2006.09.27.02.27.04;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2006.09.26.19.37.28;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2006.09.25.23.26.36;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2006.09.22.13.06.15;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2006.09.16.01.20.26;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2006.08.25.00.21.10;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.20.07.04.12;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.19.21.33.57;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.19.21.16.22;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2006.08.19.04.03.22;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2006.08.17.22.07.40;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.17.21.56.42;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2006.08.17.21.37.44;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.17.21.31.37;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2006.08.17.21.07.20;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2006.08.17.20.55.34;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2006.08.17.20.07.52;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2006.08.17.19.48.08;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2006.08.17.19.42.48;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.17.19.30.55;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.16.21.06.23;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.129
log
@only update the tx descriptors high address if it changes.

this should effectively double (or restore?) the number of packets that
can be fit on the tx ring.

tested on an od1000.
@
text
@/*	$OpenBSD: if_msk.c,v 1.127 2017/04/10 02:15:54 jsg Exp $	*/

/*
 * Copyright (c) 1997, 1998, 1999, 2000
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: /c/ncvs/src/sys/pci/if_sk.c,v 1.20 2000/04/22 02:16:37 wpaul Exp $
 */

/*
 * Copyright (c) 2003 Nathan L. Binkert <binkertn@@umich.edu>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * SysKonnect SK-NET gigabit ethernet driver for FreeBSD. Supports
 * the SK-984x series adapters, both single port and dual port.
 * References:
 * 	The XaQti XMAC II datasheet,
 * http://www.freebsd.org/~wpaul/SysKonnect/xmacii_datasheet_rev_c_9-29.pdf
 *	The SysKonnect GEnesis manual, http://www.syskonnect.com
 *
 * Note: XaQti has been acquired by Vitesse, and Vitesse does not have the
 * XMAC II datasheet online. I have put my copy at people.freebsd.org as a
 * convenience to others until Vitesse corrects this problem:
 *
 * http://people.freebsd.org/~wpaul/SysKonnect/xmacii_datasheet_rev_c_9-29.pdf
 *
 * Written by Bill Paul <wpaul@@ee.columbia.edu>
 * Department of Electrical Engineering
 * Columbia University, New York City
 */

/*
 * The SysKonnect gigabit ethernet adapters consist of two main
 * components: the SysKonnect GEnesis controller chip and the XaQti Corp.
 * XMAC II gigabit ethernet MAC. The XMAC provides all of the MAC
 * components and a PHY while the GEnesis controller provides a PCI
 * interface with DMA support. Each card may have between 512K and
 * 2MB of SRAM on board depending on the configuration.
 *
 * The SysKonnect GEnesis controller can have either one or two XMAC
 * chips connected to it, allowing single or dual port NIC configurations.
 * SysKonnect has the distinction of being the only vendor on the market
 * with a dual port gigabit ethernet NIC. The GEnesis provides dual FIFOs,
 * dual DMA queues, packet/MAC/transmit arbiters and direct access to the
 * XMAC registers. This driver takes advantage of these features to allow
 * both XMACs to operate as independent interfaces.
 */
 
#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/timeout.h>
#include <sys/device.h>
#include <sys/queue.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/pci/if_skreg.h>
#include <dev/pci/if_mskvar.h>

int mskc_probe(struct device *, void *, void *);
void mskc_attach(struct device *, struct device *self, void *aux);
int mskc_detach(struct device *, int);
int mskc_activate(struct device *, int);
void mskc_reset(struct sk_softc *);
int msk_probe(struct device *, void *, void *);
void msk_attach(struct device *, struct device *self, void *aux);
int msk_detach(struct device *, int);
int msk_activate(struct device *, int);
void msk_reset(struct sk_if_softc *);
int mskcprint(void *, const char *);
int msk_intr(void *);
void msk_intr_yukon(struct sk_if_softc *);
static __inline int msk_rxvalid(struct sk_softc *, u_int32_t, u_int32_t);
void msk_rxeof(struct sk_if_softc *, u_int16_t, u_int32_t);
void msk_txeof(struct sk_if_softc *);
int msk_encap(struct sk_if_softc *, struct mbuf *, u_int32_t *);
void msk_start(struct ifnet *);
int msk_ioctl(struct ifnet *, u_long, caddr_t);
void msk_init(void *);
void msk_init_yukon(struct sk_if_softc *);
void msk_stop(struct sk_if_softc *, int);
void msk_watchdog(struct ifnet *);
int msk_ifmedia_upd(struct ifnet *);
void msk_ifmedia_sts(struct ifnet *, struct ifmediareq *);
int msk_newbuf(struct sk_if_softc *);
int msk_init_rx_ring(struct sk_if_softc *);
int msk_init_tx_ring(struct sk_if_softc *);
void msk_fill_rx_ring(struct sk_if_softc *);

int msk_miibus_readreg(struct device *, int, int);
void msk_miibus_writereg(struct device *, int, int, int);
void msk_miibus_statchg(struct device *);

void msk_iff(struct sk_if_softc *);
void msk_tick(void *);

#ifdef MSK_DEBUG
#define DPRINTF(x)	if (mskdebug) printf x
#define DPRINTFN(n,x)	if (mskdebug >= (n)) printf x
int	mskdebug = 0;

void msk_dump_txdesc(struct msk_tx_desc *, int);
void msk_dump_mbuf(struct mbuf *);
void msk_dump_bytes(const char *, int);
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

/* supported device vendors */
const struct pci_matchid mskc_devices[] = {
	{ PCI_VENDOR_DLINK,		PCI_PRODUCT_DLINK_DGE550SX },
	{ PCI_VENDOR_DLINK,		PCI_PRODUCT_DLINK_DGE550T_B1 },
	{ PCI_VENDOR_DLINK,		PCI_PRODUCT_DLINK_DGE560SX },
	{ PCI_VENDOR_DLINK,		PCI_PRODUCT_DLINK_DGE560T },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8021CU },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8021X },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8022CU },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8022X },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8035 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8036 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8038 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8039 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8040 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8040T },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8042 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8048 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8050 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8052 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8053 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8055 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8055_2 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8056 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8057 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8058 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8059 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8061CU },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8061X },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8062CU },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8062X },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8070 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8071 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8072 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8075 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8079 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_C032 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_C033 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_C034 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_C036 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_C042 },
	{ PCI_VENDOR_SCHNEIDERKOCH,	PCI_PRODUCT_SCHNEIDERKOCH_SK9Exx },
	{ PCI_VENDOR_SCHNEIDERKOCH,	PCI_PRODUCT_SCHNEIDERKOCH_SK9Sxx }
};

static inline u_int32_t
sk_win_read_4(struct sk_softc *sc, u_int32_t reg)
{
	return CSR_READ_4(sc, reg);
}

static inline u_int16_t
sk_win_read_2(struct sk_softc *sc, u_int32_t reg)
{
	return CSR_READ_2(sc, reg);
}

static inline u_int8_t
sk_win_read_1(struct sk_softc *sc, u_int32_t reg)
{
	return CSR_READ_1(sc, reg);
}

static inline void
sk_win_write_4(struct sk_softc *sc, u_int32_t reg, u_int32_t x)
{
	CSR_WRITE_4(sc, reg, x);
}

static inline void
sk_win_write_2(struct sk_softc *sc, u_int32_t reg, u_int16_t x)
{
	CSR_WRITE_2(sc, reg, x);
}

static inline void
sk_win_write_1(struct sk_softc *sc, u_int32_t reg, u_int8_t x)
{
	CSR_WRITE_1(sc, reg, x);
}

int
msk_miibus_readreg(struct device *dev, int phy, int reg)
{
	struct sk_if_softc *sc_if = (struct sk_if_softc *)dev;
	u_int16_t val;
	int i;

        SK_YU_WRITE_2(sc_if, YUKON_SMICR, YU_SMICR_PHYAD(phy) |
		      YU_SMICR_REGAD(reg) | YU_SMICR_OP_READ);
        
	for (i = 0; i < SK_TIMEOUT; i++) {
		DELAY(1);
		val = SK_YU_READ_2(sc_if, YUKON_SMICR);
		if (val & YU_SMICR_READ_VALID)
			break;
	}

	if (i == SK_TIMEOUT) {
		printf("%s: phy failed to come ready\n",
		       sc_if->sk_dev.dv_xname);
		return (0);
	}
        
 	DPRINTFN(9, ("msk_miibus_readreg: i=%d, timeout=%d\n", i,
		     SK_TIMEOUT));

        val = SK_YU_READ_2(sc_if, YUKON_SMIDR);

	DPRINTFN(9, ("msk_miibus_readreg phy=%d, reg=%#x, val=%#x\n",
		     phy, reg, val));

	return (val);
}

void
msk_miibus_writereg(struct device *dev, int phy, int reg, int val)
{
	struct sk_if_softc *sc_if = (struct sk_if_softc *)dev;
	int i;

	DPRINTFN(9, ("msk_miibus_writereg phy=%d reg=%#x val=%#x\n",
		     phy, reg, val));

	SK_YU_WRITE_2(sc_if, YUKON_SMIDR, val);
	SK_YU_WRITE_2(sc_if, YUKON_SMICR, YU_SMICR_PHYAD(phy) |
		      YU_SMICR_REGAD(reg) | YU_SMICR_OP_WRITE);

	for (i = 0; i < SK_TIMEOUT; i++) {
		DELAY(1);
		if (!(SK_YU_READ_2(sc_if, YUKON_SMICR) & YU_SMICR_BUSY))
			break;
	}

	if (i == SK_TIMEOUT)
		printf("%s: phy write timed out\n", sc_if->sk_dev.dv_xname);
}

void
msk_miibus_statchg(struct device *dev)
{
	struct sk_if_softc *sc_if = (struct sk_if_softc *)dev;
	struct mii_data *mii = &sc_if->sk_mii;
	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
	int gpcr;

	gpcr = SK_YU_READ_2(sc_if, YUKON_GPCR);
	gpcr &= (YU_GPCR_TXEN | YU_GPCR_RXEN);

	if (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO ||
	    sc_if->sk_softc->sk_type == SK_YUKON_FE_P) {
		/* Set speed. */
		gpcr |= YU_GPCR_SPEED_DIS;
		switch (IFM_SUBTYPE(mii->mii_media_active)) {
		case IFM_1000_SX:
		case IFM_1000_LX:
		case IFM_1000_CX:
		case IFM_1000_T:
			gpcr |= (YU_GPCR_GIG | YU_GPCR_SPEED);
			break;
		case IFM_100_TX:
			gpcr |= YU_GPCR_SPEED;
			break;
		}

		/* Set duplex. */
		gpcr |= YU_GPCR_DPLX_DIS;
		if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX)
			gpcr |= YU_GPCR_DUPLEX;

		/* Disable flow control. */
		gpcr |= YU_GPCR_FCTL_DIS;
		gpcr |= (YU_GPCR_FCTL_TX_DIS | YU_GPCR_FCTL_RX_DIS);
	}

	SK_YU_WRITE_2(sc_if, YUKON_GPCR, gpcr);

	DPRINTFN(9, ("msk_miibus_statchg: gpcr=%x\n",
		     SK_YU_READ_2(((struct sk_if_softc *)dev), YUKON_GPCR)));
}

void
msk_iff(struct sk_if_softc *sc_if)
{
	struct ifnet *ifp = &sc_if->arpcom.ac_if;
	struct arpcom *ac = &sc_if->arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	u_int32_t hashes[2];
	u_int16_t rcr;
	int h;

	rcr = SK_YU_READ_2(sc_if, YUKON_RCR);
	rcr &= ~(YU_RCR_MUFLEN | YU_RCR_UFLEN);
	ifp->if_flags &= ~IFF_ALLMULTI;

	/*
	 * Always accept frames destined to our station address.
	 */
	rcr |= YU_RCR_UFLEN;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		if (ifp->if_flags & IFF_PROMISC)
			rcr &= ~YU_RCR_UFLEN;
		else
			rcr |= YU_RCR_MUFLEN;
		hashes[0] = hashes[1] = 0xFFFFFFFF;
	} else {
		rcr |= YU_RCR_MUFLEN;
		/* Program new filter. */
		bzero(hashes, sizeof(hashes));

		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = ether_crc32_be(enm->enm_addrlo,
			    ETHER_ADDR_LEN) & ((1 << SK_HASH_BITS) - 1);

			if (h < 32)
				hashes[0] |= (1 << h);
			else
				hashes[1] |= (1 << (h - 32));

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	SK_YU_WRITE_2(sc_if, YUKON_MCAH1, hashes[0] & 0xffff);
	SK_YU_WRITE_2(sc_if, YUKON_MCAH2, (hashes[0] >> 16) & 0xffff);
	SK_YU_WRITE_2(sc_if, YUKON_MCAH3, hashes[1] & 0xffff);
	SK_YU_WRITE_2(sc_if, YUKON_MCAH4, (hashes[1] >> 16) & 0xffff);
	SK_YU_WRITE_2(sc_if, YUKON_RCR, rcr);
}

int
msk_init_rx_ring(struct sk_if_softc *sc_if)
{
	struct msk_chain_data	*cd = &sc_if->sk_cdata;
	struct msk_ring_data	*rd = sc_if->sk_rdata;
	int			i, nexti;

	bzero(rd->sk_rx_ring, sizeof(struct msk_rx_desc) * MSK_RX_RING_CNT);

	for (i = 0; i < MSK_RX_RING_CNT; i++) {
		cd->sk_rx_chain[i].sk_le = &rd->sk_rx_ring[i];
		if (i == (MSK_RX_RING_CNT - 1))
			nexti = 0;
		else
			nexti = i + 1;
		cd->sk_rx_chain[i].sk_next = &cd->sk_rx_chain[nexti];
	}

	sc_if->sk_cdata.sk_rx_prod = 0;
	sc_if->sk_cdata.sk_rx_cons = 0;

	/* two ring entries per packet, so the effective ring size is halved */
	if_rxr_init(&sc_if->sk_cdata.sk_rx_ring, 2, MSK_RX_RING_CNT/2);

	msk_fill_rx_ring(sc_if);
	return (0);
}

int
msk_init_tx_ring(struct sk_if_softc *sc_if)
{
	struct sk_softc		*sc = sc_if->sk_softc;
	struct msk_chain_data	*cd = &sc_if->sk_cdata;
	struct msk_ring_data	*rd = sc_if->sk_rdata;
	bus_dmamap_t		dmamap;
	struct sk_txmap_entry	*entry;
	int			i, nexti;

	bzero(sc_if->sk_rdata->sk_tx_ring,
	    sizeof(struct msk_tx_desc) * MSK_TX_RING_CNT);

	SIMPLEQ_INIT(&sc_if->sk_txmap_head);
	for (i = 0; i < MSK_TX_RING_CNT; i++) {
		cd->sk_tx_chain[i].sk_le = &rd->sk_tx_ring[i];
		if (i == (MSK_TX_RING_CNT - 1))
			nexti = 0;
		else
			nexti = i + 1;
		cd->sk_tx_chain[i].sk_next = &cd->sk_tx_chain[nexti];

		if (bus_dmamap_create(sc->sc_dmatag, sc_if->sk_pktlen,
		    SK_NTXSEG, sc_if->sk_pktlen, 0, BUS_DMA_NOWAIT, &dmamap))
			return (ENOBUFS);

		entry = malloc(sizeof(*entry), M_DEVBUF, M_NOWAIT);
		if (!entry) {
			bus_dmamap_destroy(sc->sc_dmatag, dmamap);
			return (ENOBUFS);
		}
		entry->dmamap = dmamap;
		SIMPLEQ_INSERT_HEAD(&sc_if->sk_txmap_head, entry, link);
	}

	sc_if->sk_cdata.sk_tx_prod = 0;
	sc_if->sk_cdata.sk_tx_cons = 0;
	sc_if->sk_cdata.sk_tx_cnt = 0;

	MSK_CDTXSYNC(sc_if, 0, MSK_TX_RING_CNT,
	    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

	return (0);
}

int
msk_newbuf(struct sk_if_softc *sc_if)
{
	struct sk_chain		*c;
	struct msk_rx_desc	*r;
	struct mbuf		*m;
	bus_dmamap_t		dmamap;
	int			error;
	int			i, head;
	uint64_t		addr;

	m = MCLGETI(NULL, M_DONTWAIT, NULL, sc_if->sk_pktlen);
	if (m == NULL)
		return (0);
	m->m_len = m->m_pkthdr.len = sc_if->sk_pktlen;
	m_adj(m, ETHER_ALIGN);

	dmamap = sc_if->sk_cdata.sk_rx_map[sc_if->sk_cdata.sk_rx_prod];

	error = bus_dmamap_load_mbuf(sc_if->sk_softc->sc_dmatag, dmamap, m,
	    BUS_DMA_READ|BUS_DMA_NOWAIT);
	if (error) {
		m_freem(m);
		return (0);
	}

	bus_dmamap_sync(sc_if->sk_softc->sc_dmatag, dmamap, 0,
	    dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);

	c = &sc_if->sk_cdata.sk_rx_chain[sc_if->sk_cdata.sk_rx_prod];
	head = sc_if->sk_cdata.sk_rx_prod;
	r = c->sk_le;
	c->sk_mbuf = m;

	/* high 32 bits of address */
	addr = dmamap->dm_segs[0].ds_addr;
	r->sk_addr = htole32(addr >> 32);
	MSK_CDRXSYNC(sc_if, sc_if->sk_cdata.sk_rx_prod,
	    BUS_DMASYNC_PREWRITE);

	SK_INC(sc_if->sk_cdata.sk_rx_prod, MSK_RX_RING_CNT);
	c = &sc_if->sk_cdata.sk_rx_chain[sc_if->sk_cdata.sk_rx_prod];
	r = c->sk_le;

	/* low 32 bits of address + length */
	r->sk_addr = htole32(addr & 0xffffffff);
	r->sk_len = htole16(dmamap->dm_segs[0].ds_len);
	r->sk_ctl = 0;
	MSK_CDRXSYNC(sc_if, sc_if->sk_cdata.sk_rx_prod,
	    BUS_DMASYNC_PREWRITE);

	r->sk_opcode = SK_Y2_RXOPC_PACKET | SK_Y2_RXOPC_OWN;

	MSK_CDRXSYNC(sc_if, sc_if->sk_cdata.sk_rx_prod,
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);

	SK_INC(sc_if->sk_cdata.sk_rx_prod, MSK_RX_RING_CNT);

	for (i = 1; i < dmamap->dm_nsegs; i++) {
		c = &sc_if->sk_cdata.sk_rx_chain[sc_if->sk_cdata.sk_rx_prod];
		r = c->sk_le;
		c->sk_mbuf = NULL;

		/* high 32 bits of address */
		addr = dmamap->dm_segs[i].ds_addr;
		r->sk_addr = htole32(addr >> 32);
		MSK_CDRXSYNC(sc_if, sc_if->sk_cdata.sk_rx_prod,
		    BUS_DMASYNC_PREWRITE);

		r->sk_opcode = SK_Y2_RXOPC_ADDR64 | SK_Y2_RXOPC_OWN;

		MSK_CDRXSYNC(sc_if, sc_if->sk_cdata.sk_rx_prod,
		    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);

		SK_INC(sc_if->sk_cdata.sk_rx_prod, MSK_RX_RING_CNT);
		c = &sc_if->sk_cdata.sk_rx_chain[sc_if->sk_cdata.sk_rx_prod];
		c->sk_mbuf = NULL;
		r = c->sk_le;

		/* low 32 bits of address + length */
		r->sk_addr = htole32(addr & 0xffffffff);
		r->sk_len = htole16(dmamap->dm_segs[i].ds_len);
		r->sk_ctl = 0;

		MSK_CDRXSYNC(sc_if, sc_if->sk_cdata.sk_rx_prod,
		    BUS_DMASYNC_PREWRITE);

		r->sk_opcode = SK_Y2_RXOPC_BUFFER | SK_Y2_RXOPC_OWN;

		MSK_CDRXSYNC(sc_if, sc_if->sk_cdata.sk_rx_prod,
		    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);

		SK_INC(sc_if->sk_cdata.sk_rx_prod, MSK_RX_RING_CNT);
	}

	c = &sc_if->sk_cdata.sk_rx_chain[head];
	r = c->sk_le;
	r->sk_opcode = SK_Y2_RXOPC_ADDR64 | SK_Y2_RXOPC_OWN;

	MSK_CDRXSYNC(sc_if, head, BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);

	return (dmamap->dm_nsegs);
}

/*
 * Set media options.
 */
int
msk_ifmedia_upd(struct ifnet *ifp)
{
	struct sk_if_softc *sc_if = ifp->if_softc;

	mii_mediachg(&sc_if->sk_mii);
	return (0);
}

/*
 * Report current media status.
 */
void
msk_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct sk_if_softc *sc_if = ifp->if_softc;

	mii_pollstat(&sc_if->sk_mii);
	ifmr->ifm_active = sc_if->sk_mii.mii_media_active;
	ifmr->ifm_status = sc_if->sk_mii.mii_media_status;
}

int
msk_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct sk_if_softc *sc_if = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *) data;
	struct mii_data *mii;
	int s, error = 0;

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			msk_init(sc_if);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				msk_init(sc_if);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				msk_stop(sc_if, 0);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		mii = &sc_if->sk_mii;
		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);
		break;

	case SIOCGIFRXR:
		error = if_rxr_ioctl((struct if_rxrinfo *)ifr->ifr_data,
		    NULL, sc_if->sk_pktlen, &sc_if->sk_cdata.sk_rx_ring);
 		break;

	default:
		error = ether_ioctl(ifp, &sc_if->arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			msk_iff(sc_if);
		error = 0;
	}

	splx(s);
	return (error);
}

/*
 * Probe for a SysKonnect GEnesis chip. Check the PCI vendor and device
 * IDs against our list and return a device name if we find a match.
 */
int
mskc_probe(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, mskc_devices,
	    nitems(mskc_devices)));
}

/*
 * Force the GEnesis into reset, then bring it out of reset.
 */
void
mskc_reset(struct sk_softc *sc)
{
	u_int32_t imtimer_ticks, reg1;
	int reg;

	DPRINTFN(2, ("mskc_reset\n"));

	CSR_WRITE_1(sc, SK_CSR, SK_CSR_SW_RESET);
	CSR_WRITE_1(sc, SK_CSR, SK_CSR_MASTER_RESET);

	DELAY(1000);
	CSR_WRITE_1(sc, SK_CSR, SK_CSR_SW_UNRESET);
	DELAY(2);
	CSR_WRITE_1(sc, SK_CSR, SK_CSR_MASTER_UNRESET);

	sk_win_write_1(sc, SK_TESTCTL1, 2);

	if (sc->sk_type == SK_YUKON_EC_U || sc->sk_type == SK_YUKON_EX ||
	    sc->sk_type >= SK_YUKON_FE_P) {
		/* enable all clocks. */
		sk_win_write_4(sc, SK_Y2_PCI_REG(SK_PCI_OURREG3), 0);
		reg1 = sk_win_read_4(sc, SK_Y2_PCI_REG(SK_PCI_OURREG4));
		reg1 &= (SK_Y2_REG4_FORCE_ASPM_REQUEST|
		    SK_Y2_REG4_ASPM_GPHY_LINK_DOWN|
		    SK_Y2_REG4_ASPM_INT_FIFO_EMPTY|
		    SK_Y2_REG4_ASPM_CLKRUN_REQUEST);
		sk_win_write_4(sc, SK_Y2_PCI_REG(SK_PCI_OURREG4), reg1);

		reg1 = sk_win_read_4(sc, SK_Y2_PCI_REG(SK_PCI_OURREG5));
		reg1 &= SK_Y2_REG5_TIM_VMAIN_AV_MASK;
		sk_win_write_4(sc, SK_Y2_PCI_REG(SK_PCI_OURREG5), reg1);
		sk_win_write_4(sc, SK_Y2_PCI_REG(SK_PCI_CFGREG1), 0);

		/*
		 * Disable status race, workaround for Yukon EC Ultra &
		 * Yukon EX.
		 */
		reg1 = sk_win_read_4(sc, SK_GPIO);
		reg1 |= SK_Y2_GPIO_STAT_RACE_DIS;
		sk_win_write_4(sc, SK_GPIO, reg1);
		sk_win_read_4(sc, SK_GPIO);
	}

	reg1 = sk_win_read_4(sc, SK_Y2_PCI_REG(SK_PCI_OURREG1));
	if (sc->sk_type == SK_YUKON_XL && sc->sk_rev > SK_YUKON_XL_REV_A1)
		reg1 |= (SK_Y2_REG1_PHY1_COMA | SK_Y2_REG1_PHY2_COMA);
	else
		reg1 &= ~(SK_Y2_REG1_PHY1_COMA | SK_Y2_REG1_PHY2_COMA);
	sk_win_write_4(sc, SK_Y2_PCI_REG(SK_PCI_OURREG1), reg1);

	if (sc->sk_type == SK_YUKON_XL && sc->sk_rev > SK_YUKON_XL_REV_A1)
		sk_win_write_1(sc, SK_Y2_CLKGATE,
		    SK_Y2_CLKGATE_LINK1_GATE_DIS |
		    SK_Y2_CLKGATE_LINK2_GATE_DIS |
		    SK_Y2_CLKGATE_LINK1_CORE_DIS |
		    SK_Y2_CLKGATE_LINK2_CORE_DIS |
		    SK_Y2_CLKGATE_LINK1_PCI_DIS | SK_Y2_CLKGATE_LINK2_PCI_DIS);
	else
		sk_win_write_1(sc, SK_Y2_CLKGATE, 0);

	CSR_WRITE_2(sc, SK_LINK_CTRL, SK_LINK_RESET_SET);
	CSR_WRITE_2(sc, SK_LINK_CTRL + SK_WIN_LEN, SK_LINK_RESET_SET);
	DELAY(1000);
	CSR_WRITE_2(sc, SK_LINK_CTRL, SK_LINK_RESET_CLEAR);
	CSR_WRITE_2(sc, SK_LINK_CTRL + SK_WIN_LEN, SK_LINK_RESET_CLEAR);

	if (sc->sk_type == SK_YUKON_EX || sc->sk_type == SK_YUKON_SUPR) {
		CSR_WRITE_2(sc, SK_GMAC_CTRL, SK_GMAC_BYP_MACSECRX |
		    SK_GMAC_BYP_MACSECTX | SK_GMAC_BYP_RETR_FIFO);
	}

	sk_win_write_1(sc, SK_TESTCTL1, 1);

	DPRINTFN(2, ("mskc_reset: sk_csr=%x\n", CSR_READ_1(sc, SK_CSR)));
	DPRINTFN(2, ("mskc_reset: sk_link_ctrl=%x\n",
		     CSR_READ_2(sc, SK_LINK_CTRL)));

	/* Disable ASF */
	CSR_WRITE_1(sc, SK_Y2_ASF_CSR, SK_Y2_ASF_RESET);
	CSR_WRITE_2(sc, SK_CSR, SK_CSR_ASF_OFF);

	/* Clear I2C IRQ noise */
	CSR_WRITE_4(sc, SK_I2CHWIRQ, 1);

	/* Disable hardware timer */
	CSR_WRITE_1(sc, SK_TIMERCTL, SK_IMCTL_STOP);
	CSR_WRITE_1(sc, SK_TIMERCTL, SK_IMCTL_IRQ_CLEAR);

	/* Disable descriptor polling */
	CSR_WRITE_4(sc, SK_DPT_TIMER_CTRL, SK_DPT_TCTL_STOP);

	/* Disable time stamps */
	CSR_WRITE_1(sc, SK_TSTAMP_CTL, SK_TSTAMP_STOP);
	CSR_WRITE_1(sc, SK_TSTAMP_CTL, SK_TSTAMP_IRQ_CLEAR);

	/* Enable RAM interface */
	sk_win_write_1(sc, SK_RAMCTL, SK_RAMCTL_UNRESET);
	for (reg = SK_TO0;reg <= SK_TO11; reg++)
		sk_win_write_1(sc, reg, 36);
	sk_win_write_1(sc, SK_RAMCTL + (SK_WIN_LEN / 2), SK_RAMCTL_UNRESET);
	for (reg = SK_TO0;reg <= SK_TO11; reg++)
		sk_win_write_1(sc, reg + (SK_WIN_LEN / 2), 36);

	/*
	 * Configure interrupt moderation. The moderation timer
	 * defers interrupts specified in the interrupt moderation
	 * timer mask based on the timeout specified in the interrupt
	 * moderation timer init register. Each bit in the timer
	 * register represents one tick, so to specify a timeout in
	 * microseconds, we have to multiply by the correct number of
	 * ticks-per-microsecond.
	 */
	switch (sc->sk_type) {
	case SK_YUKON_EC:
	case SK_YUKON_EC_U:
	case SK_YUKON_EX:
	case SK_YUKON_SUPR:
	case SK_YUKON_ULTRA2:
	case SK_YUKON_OPTIMA:
	case SK_YUKON_PRM:
	case SK_YUKON_OPTIMA2:
		imtimer_ticks = SK_IMTIMER_TICKS_YUKON_EC;
		break;
	case SK_YUKON_FE:
		imtimer_ticks = SK_IMTIMER_TICKS_YUKON_FE;
		break;
	case SK_YUKON_FE_P:
		imtimer_ticks = SK_IMTIMER_TICKS_YUKON_FE_P;
		break;
	case SK_YUKON_XL:
		imtimer_ticks = SK_IMTIMER_TICKS_YUKON_XL;
		break;
	default:
		imtimer_ticks = SK_IMTIMER_TICKS_YUKON;
		break;
	}

	/* Reset status ring. */
	bzero(sc->sk_status_ring,
	    MSK_STATUS_RING_CNT * sizeof(struct msk_status_desc));
	sc->sk_status_idx = 0;

	sk_win_write_4(sc, SK_STAT_BMU_CSR, SK_STAT_BMU_RESET);
	sk_win_write_4(sc, SK_STAT_BMU_CSR, SK_STAT_BMU_UNRESET);

	sk_win_write_2(sc, SK_STAT_BMU_LIDX, MSK_STATUS_RING_CNT - 1);
	sk_win_write_4(sc, SK_STAT_BMU_ADDRLO,
	    sc->sk_status_map->dm_segs[0].ds_addr);
	sk_win_write_4(sc, SK_STAT_BMU_ADDRHI,
	    (u_int64_t)sc->sk_status_map->dm_segs[0].ds_addr >> 32);
	sk_win_write_2(sc, SK_STAT_BMU_TX_THRESH, 10);
	sk_win_write_1(sc, SK_STAT_BMU_FIFOWM, 16);
	sk_win_write_1(sc, SK_STAT_BMU_FIFOIWM, 16);

#if 0
	sk_win_write_4(sc, SK_Y2_LEV_ITIMERINIT, SK_IM_USECS(100));
	sk_win_write_4(sc, SK_Y2_TX_ITIMERINIT, SK_IM_USECS(1000));
	sk_win_write_4(sc, SK_Y2_ISR_ITIMERINIT, SK_IM_USECS(20));
#else
	sk_win_write_4(sc, SK_Y2_ISR_ITIMERINIT, SK_IM_USECS(4));
#endif

	sk_win_write_4(sc, SK_STAT_BMU_CSR, SK_STAT_BMU_ON);

	sk_win_write_1(sc, SK_Y2_LEV_ITIMERCTL, SK_IMCTL_START);
	sk_win_write_1(sc, SK_Y2_TX_ITIMERCTL, SK_IMCTL_START);
	sk_win_write_1(sc, SK_Y2_ISR_ITIMERCTL, SK_IMCTL_START);
}

int
msk_probe(struct device *parent, void *match, void *aux)
{
	struct skc_attach_args *sa = aux;

	if (sa->skc_port != SK_PORT_A && sa->skc_port != SK_PORT_B)
		return (0);

	switch (sa->skc_type) {
	case SK_YUKON_XL:
	case SK_YUKON_EC_U:
	case SK_YUKON_EX:
	case SK_YUKON_EC:
	case SK_YUKON_FE:
	case SK_YUKON_FE_P:
	case SK_YUKON_SUPR:
	case SK_YUKON_ULTRA2:
	case SK_YUKON_OPTIMA:
	case SK_YUKON_PRM:
	case SK_YUKON_OPTIMA2:
		return (1);
	}

	return (0);
}

void
msk_reset(struct sk_if_softc *sc_if)
{
	/* GMAC and GPHY Reset */
	SK_IF_WRITE_4(sc_if, 0, SK_GMAC_CTRL, SK_GMAC_RESET_SET);
	SK_IF_WRITE_4(sc_if, 0, SK_GPHY_CTRL, SK_GPHY_RESET_SET);
	DELAY(1000);
	SK_IF_WRITE_4(sc_if, 0, SK_GPHY_CTRL, SK_GPHY_RESET_CLEAR);
	SK_IF_WRITE_4(sc_if, 0, SK_GMAC_CTRL, SK_GMAC_LOOP_OFF |
		      SK_GMAC_PAUSE_ON | SK_GMAC_RESET_CLEAR);
}

/*
 * Each XMAC chip is attached as a separate logical IP interface.
 * Single port cards will have only one logical interface of course.
 */
void
msk_attach(struct device *parent, struct device *self, void *aux)
{
	struct sk_if_softc *sc_if = (struct sk_if_softc *)self;
	struct sk_softc *sc = (struct sk_softc *)parent;
	struct skc_attach_args *sa = aux;
	struct ifnet *ifp;
	caddr_t kva;
	int i;
	u_int32_t chunk;
	int mii_flags;
	int error;

	sc_if->sk_port = sa->skc_port;
	sc_if->sk_softc = sc;
	sc->sk_if[sa->skc_port] = sc_if;

	DPRINTFN(2, ("begin msk_attach: port=%d\n", sc_if->sk_port));

	/*
	 * Get station address for this interface. Note that
	 * dual port cards actually come with three station
	 * addresses: one for each port, plus an extra. The
	 * extra one is used by the SysKonnect driver software
	 * as a 'virtual' station address for when both ports
	 * are operating in failover mode. Currently we don't
	 * use this extra address.
	 */
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		sc_if->arpcom.ac_enaddr[i] =
		    sk_win_read_1(sc, SK_MAC0_0 + (sa->skc_port * 8) + i);

	printf(": address %s\n",
	    ether_sprintf(sc_if->arpcom.ac_enaddr));

	/*
	 * Set up RAM buffer addresses. The Yukon2 has a small amount
	 * of SRAM on it, somewhere between 4K and 48K.  We need to
	 * divide this up between the transmitter and receiver.  We
	 * give the receiver 2/3 of the memory (rounded down), and the
	 * transmitter whatever remains.
	 */
	chunk = (2 * (sc->sk_ramsize / sizeof(u_int64_t)) / 3) & ~0xff;
	sc_if->sk_rx_ramstart = 0;
	sc_if->sk_rx_ramend = sc_if->sk_rx_ramstart + chunk - 1;
	chunk = (sc->sk_ramsize / sizeof(u_int64_t)) - chunk;
	sc_if->sk_tx_ramstart = sc_if->sk_rx_ramend + 1;
	sc_if->sk_tx_ramend = sc_if->sk_tx_ramstart + chunk - 1;

	DPRINTFN(2, ("msk_attach: rx_ramstart=%#x rx_ramend=%#x\n"
		     "           tx_ramstart=%#x tx_ramend=%#x\n",
		     sc_if->sk_rx_ramstart, sc_if->sk_rx_ramend,
		     sc_if->sk_tx_ramstart, sc_if->sk_tx_ramend));

	/* Allocate the descriptor queues. */
	if (bus_dmamem_alloc(sc->sc_dmatag, sizeof(struct msk_ring_data),
	    PAGE_SIZE, 0, &sc_if->sk_ring_seg, 1, &sc_if->sk_ring_nseg,
	    BUS_DMA_NOWAIT | BUS_DMA_ZERO)) {
		printf(": can't alloc rx buffers\n");
		goto fail;
	}
	if (bus_dmamem_map(sc->sc_dmatag, &sc_if->sk_ring_seg,
	    sc_if->sk_ring_nseg,
	    sizeof(struct msk_ring_data), &kva, BUS_DMA_NOWAIT)) {
		printf(": can't map dma buffers (%lu bytes)\n",
		       (ulong)sizeof(struct msk_ring_data));
		goto fail_1;
	}
	if (bus_dmamap_create(sc->sc_dmatag, sizeof(struct msk_ring_data), 1,
	    sizeof(struct msk_ring_data), 0, BUS_DMA_NOWAIT,
            &sc_if->sk_ring_map)) {
		printf(": can't create dma map\n");
		goto fail_2;
	}
	if (bus_dmamap_load(sc->sc_dmatag, sc_if->sk_ring_map, kva,
	    sizeof(struct msk_ring_data), NULL, BUS_DMA_NOWAIT)) {
		printf(": can't load dma map\n");
		goto fail_3;
	}
        sc_if->sk_rdata = (struct msk_ring_data *)kva;

	if (sc->sk_type != SK_YUKON_FE &&
	    sc->sk_type != SK_YUKON_FE_P)
		sc_if->sk_pktlen = SK_JLEN;
	else
		sc_if->sk_pktlen = MCLBYTES;

	for (i = 0; i < MSK_RX_RING_CNT; i++) {
		if ((error = bus_dmamap_create(sc->sc_dmatag,
		    sc_if->sk_pktlen, SK_NRXSEG, sc_if->sk_pktlen,
		    0, 0, &sc_if->sk_cdata.sk_rx_map[i])) != 0) {
			printf("\n%s: unable to create rx DMA map %d, "
			    "error = %d\n", sc->sk_dev.dv_xname, i, error);
			goto fail_4;
		}
	}

	ifp = &sc_if->arpcom.ac_if;
	ifp->if_softc = sc_if;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = msk_ioctl;
	ifp->if_start = msk_start;
	ifp->if_watchdog = msk_watchdog;
	if (sc->sk_type != SK_YUKON_FE &&
	    sc->sk_type != SK_YUKON_FE_P)
		ifp->if_hardmtu = SK_JUMBO_MTU;
	IFQ_SET_MAXLEN(&ifp->if_snd, MSK_TX_RING_CNT - 1);
	bcopy(sc_if->sk_dev.dv_xname, ifp->if_xname, IFNAMSIZ);

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	msk_reset(sc_if);

	/*
	 * Do miibus setup.
	 */
	msk_init_yukon(sc_if);

 	DPRINTFN(2, ("msk_attach: 1\n"));

	sc_if->sk_mii.mii_ifp = ifp;
	sc_if->sk_mii.mii_readreg = msk_miibus_readreg;
	sc_if->sk_mii.mii_writereg = msk_miibus_writereg;
	sc_if->sk_mii.mii_statchg = msk_miibus_statchg;

	ifmedia_init(&sc_if->sk_mii.mii_media, 0,
	    msk_ifmedia_upd, msk_ifmedia_sts);
	mii_flags = MIIF_DOPAUSE;
	if (sc->sk_fibertype)
		mii_flags |= MIIF_HAVEFIBER;
	mii_attach(self, &sc_if->sk_mii, 0xffffffff, 0,
	    MII_OFFSET_ANY, mii_flags);
	if (LIST_FIRST(&sc_if->sk_mii.mii_phys) == NULL) {
		printf("%s: no PHY found!\n", sc_if->sk_dev.dv_xname);
		ifmedia_add(&sc_if->sk_mii.mii_media, IFM_ETHER|IFM_MANUAL,
			    0, NULL);
		ifmedia_set(&sc_if->sk_mii.mii_media, IFM_ETHER|IFM_MANUAL);
	} else
		ifmedia_set(&sc_if->sk_mii.mii_media, IFM_ETHER|IFM_AUTO);

	timeout_set(&sc_if->sk_tick_ch, msk_tick, sc_if);

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

	DPRINTFN(2, ("msk_attach: end\n"));
	return;

fail_4:
	for (i = 0; i < MSK_RX_RING_CNT; i++) {
		if (sc_if->sk_cdata.sk_rx_map[i] != NULL)
			bus_dmamap_destroy(sc->sc_dmatag,
			    sc_if->sk_cdata.sk_rx_map[i]);
	}

fail_3:
	bus_dmamap_destroy(sc->sc_dmatag, sc_if->sk_ring_map);
fail_2:
	bus_dmamem_unmap(sc->sc_dmatag, kva, sizeof(struct msk_ring_data));
fail_1:
	bus_dmamem_free(sc->sc_dmatag, &sc_if->sk_ring_seg, sc_if->sk_ring_nseg);
fail:
	sc->sk_if[sa->skc_port] = NULL;
}

int
msk_detach(struct device *self, int flags)
{
	struct sk_if_softc *sc_if = (struct sk_if_softc *)self;
	struct sk_softc *sc = sc_if->sk_softc;
	struct ifnet *ifp= &sc_if->arpcom.ac_if;

	if (sc->sk_if[sc_if->sk_port] == NULL)
		return (0);

	msk_stop(sc_if, 1);

	/* Detach any PHYs we might have. */
	if (LIST_FIRST(&sc_if->sk_mii.mii_phys) != NULL)
		mii_detach(&sc_if->sk_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	/* Delete any remaining media. */
	ifmedia_delete_instance(&sc_if->sk_mii.mii_media, IFM_INST_ANY);

	ether_ifdetach(ifp);
	if_detach(ifp);

	bus_dmamem_unmap(sc->sc_dmatag, (caddr_t)sc_if->sk_rdata,
	    sizeof(struct msk_ring_data));
	bus_dmamem_free(sc->sc_dmatag,
	    &sc_if->sk_ring_seg, sc_if->sk_ring_nseg);
	bus_dmamap_destroy(sc->sc_dmatag, sc_if->sk_ring_map);
	sc->sk_if[sc_if->sk_port] = NULL;

	return (0);
}

int
msk_activate(struct device *self, int act)
{
	struct sk_if_softc *sc_if = (void *)self;
	struct ifnet *ifp = &sc_if->arpcom.ac_if;
	int rv = 0;

	switch (act) {
	case DVACT_RESUME:
		msk_reset(sc_if);
		if (ifp->if_flags & IFF_RUNNING)
			msk_init(sc_if);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

int
mskcprint(void *aux, const char *pnp)
{
	struct skc_attach_args *sa = aux;

	if (pnp)
		printf("msk port %c at %s",
		    (sa->skc_port == SK_PORT_A) ? 'A' : 'B', pnp);
	else
		printf(" port %c", (sa->skc_port == SK_PORT_A) ? 'A' : 'B');
	return (UNCONF);
}

/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
void
mskc_attach(struct device *parent, struct device *self, void *aux)
{
	struct sk_softc *sc = (struct sk_softc *)self;
	struct pci_attach_args *pa = aux;
	struct skc_attach_args skca;
	pci_chipset_tag_t pc = pa->pa_pc;
	pcireg_t memtype;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
	u_int8_t hw, pmd;
	char *revstr = NULL;
	caddr_t kva;

	DPRINTFN(2, ("begin mskc_attach\n"));

	pci_set_powerstate(pa->pa_pc, pa->pa_tag, PCI_PMCSR_STATE_D0);

	/*
	 * Map control/status registers.
	 */
	memtype = pci_mapreg_type(pc, pa->pa_tag, SK_PCI_LOMEM);
	if (pci_mapreg_map(pa, SK_PCI_LOMEM, memtype, 0, &sc->sk_btag,
	    &sc->sk_bhandle, NULL, &sc->sk_bsize, 0)) {
		printf(": can't map mem space\n");
		return;
	}

	sc->sc_dmatag = pa->pa_dmat;

	sc->sk_type = sk_win_read_1(sc, SK_CHIPVER);
	sc->sk_rev = (sk_win_read_1(sc, SK_CONFIG) >> 4);

	/* bail out here if chip is not recognized */
	if (!(SK_IS_YUKON2(sc))) {
		printf(": unknown chip type: %d\n", sc->sk_type);
		goto fail_1;
	}
	DPRINTFN(2, ("mskc_attach: allocate interrupt\n"));

	/* Allocate interrupt */
	if (pci_intr_map_msi(pa, &ih) != 0 && pci_intr_map(pa, &ih) != 0) {
		printf(": couldn't map interrupt\n");
		goto fail_1;
	}

	intrstr = pci_intr_string(pc, ih);
	sc->sk_intrhand = pci_intr_establish(pc, ih, IPL_NET, msk_intr, sc,
	    self->dv_xname);
	if (sc->sk_intrhand == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail_1;
	}
	sc->sk_pc = pc;

	if (bus_dmamem_alloc(sc->sc_dmatag,
	    MSK_STATUS_RING_CNT * sizeof(struct msk_status_desc),
	    MSK_STATUS_RING_CNT * sizeof(struct msk_status_desc),
	    0, &sc->sk_status_seg, 1, &sc->sk_status_nseg,
	    BUS_DMA_NOWAIT | BUS_DMA_ZERO)) {
		printf(": can't alloc status buffers\n");
		goto fail_2;
	}

	if (bus_dmamem_map(sc->sc_dmatag,
	    &sc->sk_status_seg, sc->sk_status_nseg,
	    MSK_STATUS_RING_CNT * sizeof(struct msk_status_desc),
	    &kva, BUS_DMA_NOWAIT)) {
		printf(": can't map dma buffers (%lu bytes)\n",
		    (ulong)(MSK_STATUS_RING_CNT * sizeof(struct msk_status_desc)));
		goto fail_3;
	}
	if (bus_dmamap_create(sc->sc_dmatag,
	    MSK_STATUS_RING_CNT * sizeof(struct msk_status_desc), 1,
	    MSK_STATUS_RING_CNT * sizeof(struct msk_status_desc), 0,
	    BUS_DMA_NOWAIT, &sc->sk_status_map)) {
		printf(": can't create dma map\n");
		goto fail_4;
	}
	if (bus_dmamap_load(sc->sc_dmatag, sc->sk_status_map, kva,
	    MSK_STATUS_RING_CNT * sizeof(struct msk_status_desc),
	    NULL, BUS_DMA_NOWAIT)) {
		printf(": can't load dma map\n");
		goto fail_5;
	}
	sc->sk_status_ring = (struct msk_status_desc *)kva;

	/* Reset the adapter. */
	mskc_reset(sc);

	sc->sk_ramsize = sk_win_read_1(sc, SK_EPROM0) * 4096;
	DPRINTFN(2, ("mskc_attach: ramsize=%dK\n", sc->sk_ramsize / 1024));

	pmd = sk_win_read_1(sc, SK_PMDTYPE);
	if (pmd == 'L' || pmd == 'S' || pmd == 'P')
		sc->sk_fibertype = 1;

	switch (sc->sk_type) {
	case SK_YUKON_XL:
		sc->sk_name = "Yukon-2 XL";
		break;
	case SK_YUKON_EC_U:
		sc->sk_name = "Yukon-2 EC Ultra";
		break;
	case SK_YUKON_EX:
		sc->sk_name = "Yukon-2 Extreme";
		break;
	case SK_YUKON_EC:
		sc->sk_name = "Yukon-2 EC";
		break;
	case SK_YUKON_FE:
		sc->sk_name = "Yukon-2 FE";
		break;
	case SK_YUKON_FE_P:
		sc->sk_name = "Yukon-2 FE+";
		break;
	case SK_YUKON_SUPR:
		sc->sk_name = "Yukon-2 Supreme";
		break;
	case SK_YUKON_ULTRA2:
		sc->sk_name = "Yukon-2 Ultra 2";
		break;
	case SK_YUKON_OPTIMA:
		sc->sk_name = "Yukon-2 Optima";
		break;
	case SK_YUKON_PRM:
		sc->sk_name = "Yukon-2 Optima Prime";
		break;
	case SK_YUKON_OPTIMA2:
		sc->sk_name = "Yukon-2 Optima 2";
		break;
	default:
		sc->sk_name = "Yukon (Unknown)";
	}

	if (sc->sk_type == SK_YUKON_XL) {
		switch (sc->sk_rev) {
		case SK_YUKON_XL_REV_A0:
			revstr = "A0";
			break;
		case SK_YUKON_XL_REV_A1:
			revstr = "A1";
			break;
		case SK_YUKON_XL_REV_A2:
			revstr = "A2";
			break;
		case SK_YUKON_XL_REV_A3:
			revstr = "A3";
			break;
		default:
			;
		}
	}

	if (sc->sk_type == SK_YUKON_EC) {
		switch (sc->sk_rev) {
		case SK_YUKON_EC_REV_A1:
			revstr = "A1";
			break;
		case SK_YUKON_EC_REV_A2:
			revstr = "A2";
			break;
		case SK_YUKON_EC_REV_A3:
			revstr = "A3";
			break;
		default:
			;
		}
	}

	if (sc->sk_type == SK_YUKON_EC_U) {
		switch (sc->sk_rev) {
		case SK_YUKON_EC_U_REV_A0:
			revstr = "A0";
			break;
		case SK_YUKON_EC_U_REV_A1:
			revstr = "A1";
			break;
		case SK_YUKON_EC_U_REV_B0:
			revstr = "B0";
			break;
		case SK_YUKON_EC_U_REV_B1:
			revstr = "B1";
			break;
		default:
			;
		}
	}

	if (sc->sk_type == SK_YUKON_FE) {
		switch (sc->sk_rev) {
		case SK_YUKON_FE_REV_A1:
			revstr = "A1";
			break;
		case SK_YUKON_FE_REV_A2:
			revstr = "A2";
			break;
		default:
			;
		}
	}

	if (sc->sk_type == SK_YUKON_FE_P && sc->sk_rev == SK_YUKON_FE_P_REV_A0)
		revstr = "A0";

	if (sc->sk_type == SK_YUKON_EX) {
		switch (sc->sk_rev) {
		case SK_YUKON_EX_REV_A0:
			revstr = "A0";
			break;
		case SK_YUKON_EX_REV_B0:
			revstr = "B0";
			break;
		default:
			;
		}
	}

	if (sc->sk_type == SK_YUKON_SUPR) {
		switch (sc->sk_rev) {
		case SK_YUKON_SUPR_REV_A0:
			revstr = "A0";
			break;
		case SK_YUKON_SUPR_REV_B0:
			revstr = "B0";
			break;
		case SK_YUKON_SUPR_REV_B1:
			revstr = "B1";
			break;
		default:
			;
		}
	}

	if (sc->sk_type == SK_YUKON_PRM) {
		switch (sc->sk_rev) {
		case SK_YUKON_PRM_REV_Z1:
			revstr = "Z1";
			break;
		case SK_YUKON_PRM_REV_A0:
			revstr = "A0";
			break;
		default:
			;
		}
	}

	/* Announce the product name. */
	printf(", %s", sc->sk_name);
	if (revstr != NULL)
		printf(" rev. %s", revstr);
	printf(" (0x%x): %s\n", sc->sk_rev, intrstr);

	sc->sk_macs = 1;

	hw = sk_win_read_1(sc, SK_Y2_HWRES);
	if ((hw & SK_Y2_HWRES_LINK_MASK) == SK_Y2_HWRES_LINK_DUAL) {
		if ((sk_win_read_1(sc, SK_Y2_CLKGATE) &
		    SK_Y2_CLKGATE_LINK2_INACTIVE) == 0)
			sc->sk_macs++;
	}

	skca.skc_port = SK_PORT_A;
	skca.skc_type = sc->sk_type;
	skca.skc_rev = sc->sk_rev;
	(void)config_found(&sc->sk_dev, &skca, mskcprint);

	if (sc->sk_macs > 1) {
		skca.skc_port = SK_PORT_B;
		skca.skc_type = sc->sk_type;
		skca.skc_rev = sc->sk_rev;
		(void)config_found(&sc->sk_dev, &skca, mskcprint);
	}

	/* Turn on the 'driver is loaded' LED. */
	CSR_WRITE_2(sc, SK_LED, SK_LED_GREEN_ON);

	return;

fail_4:
	bus_dmamem_unmap(sc->sc_dmatag, (caddr_t)sc->sk_status_ring,
	    MSK_STATUS_RING_CNT * sizeof(struct msk_status_desc));
fail_3:
	bus_dmamem_free(sc->sc_dmatag,
	    &sc->sk_status_seg, sc->sk_status_nseg);
	sc->sk_status_nseg = 0;
fail_5:
	bus_dmamap_destroy(sc->sc_dmatag, sc->sk_status_map);
fail_2:
	pci_intr_disestablish(sc->sk_pc, sc->sk_intrhand);
	sc->sk_intrhand = NULL;
fail_1:
	bus_space_unmap(sc->sk_btag, sc->sk_bhandle, sc->sk_bsize);
	sc->sk_bsize = 0;
}

int
mskc_detach(struct device *self, int flags)
{
	struct sk_softc *sc = (struct sk_softc *)self;
	int rv;

	if (sc->sk_intrhand)
		pci_intr_disestablish(sc->sk_pc, sc->sk_intrhand);

	rv = config_detach_children(self, flags);
	if (rv != 0)
		return (rv);

	if (sc->sk_status_nseg > 0) {
		bus_dmamap_destroy(sc->sc_dmatag, sc->sk_status_map);
		bus_dmamem_unmap(sc->sc_dmatag, (caddr_t)sc->sk_status_ring,
		    MSK_STATUS_RING_CNT * sizeof(struct msk_status_desc));
		bus_dmamem_free(sc->sc_dmatag,
		    &sc->sk_status_seg, sc->sk_status_nseg);
	}

	if (sc->sk_bsize > 0)
		bus_space_unmap(sc->sk_btag, sc->sk_bhandle, sc->sk_bsize);

	return(0);
}

int
mskc_activate(struct device *self, int act)
{
	struct sk_softc *sc = (void *)self;
	int rv = 0;

	switch (act) {
	case DVACT_RESUME:
		mskc_reset(sc);
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

int
msk_encap(struct sk_if_softc *sc_if, struct mbuf *m_head, u_int32_t *txidx)
{
	struct sk_softc		*sc = sc_if->sk_softc;
	struct msk_tx_desc	*f = NULL;
	u_int32_t		frag, cur;
	int			i, entries = 0;
	struct sk_txmap_entry	*entry;
	bus_dmamap_t		txmap;
	uint64_t		addr;
	uint32_t		hiaddr;
	uint8_t			opcode;

	DPRINTFN(2, ("msk_encap\n"));

	entry = SIMPLEQ_FIRST(&sc_if->sk_txmap_head);
	if (entry == NULL) {
		DPRINTFN(2, ("msk_encap: no txmap available\n"));
		return (ENOBUFS);
	}
	txmap = entry->dmamap;

	cur = frag = *txidx;

	switch (bus_dmamap_load_mbuf(sc->sc_dmatag, txmap, m_head,
	    BUS_DMA_STREAMING | BUS_DMA_NOWAIT)) {
	case 0:
		break;
	case EFBIG: /* mbuf chain is too fragmented */
		if (m_defrag(m_head, M_DONTWAIT) == 0 &&
		    bus_dmamap_load_mbuf(sc->sc_dmatag, txmap, m_head,
		    BUS_DMA_STREAMING | BUS_DMA_NOWAIT) == 0)
			break;
		/* FALLTHROUGH */
	default:
		return (1);
	}

	/* Sync the DMA map. */
	bus_dmamap_sync(sc->sc_dmatag, txmap, 0, txmap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	opcode = 0;
	for (i = 0; i < txmap->dm_nsegs; i++) {
		/* high 32 bits of address */
		addr = txmap->dm_segs[i].ds_addr;
		hiaddr = addr >> 32;
		if (sc_if->sk_tx_hiaddr != hiaddr) {
			f = &sc_if->sk_rdata->sk_tx_ring[frag];
			f->sk_addr = htole32(hiaddr);
			f->sk_opcode = opcode | SK_Y2_TXOPC_ADDR64;

			sc_if->sk_tx_hiaddr = hiaddr;

			SK_INC(frag, MSK_TX_RING_CNT);
			opcode = SK_Y2_TXOPC_OWN;
			entries++;
		}

		/* low 32 bits of address + length */
		f = &sc_if->sk_rdata->sk_tx_ring[frag];
		f->sk_addr = htole32(addr);
		f->sk_len = htole16(txmap->dm_segs[i].ds_len);
		f->sk_ctl = 0;
		f->sk_opcode = opcode |
		    (i == 0 ? SK_Y2_TXOPC_PACKET : SK_Y2_TXOPC_BUFFER);
		cur = frag;

		SK_INC(frag, MSK_TX_RING_CNT);
		opcode = SK_Y2_TXOPC_OWN;
		entries++;
	}

	sc_if->sk_cdata.sk_tx_chain[cur].sk_mbuf = m_head;
	SIMPLEQ_REMOVE_HEAD(&sc_if->sk_txmap_head, link);

	sc_if->sk_cdata.sk_tx_map[cur] = entry;
	sc_if->sk_rdata->sk_tx_ring[cur].sk_ctl |= SK_Y2_TXCTL_LASTFRAG;

	/* Sync descriptors before handing to chip */
	MSK_CDTXSYNC(sc_if, *txidx, entries,
            BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

	sc_if->sk_rdata->sk_tx_ring[*txidx].sk_opcode |= SK_Y2_TXOPC_OWN;

	/* Sync first descriptor to hand it off */
	MSK_CDTXSYNC(sc_if, *txidx, 1,
	    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

	sc_if->sk_cdata.sk_tx_cnt += entries;

#ifdef MSK_DEBUG
	if (mskdebug >= 2) {
		struct msk_tx_desc *le;
		u_int32_t idx;
		for (idx = *txidx; idx != frag; SK_INC(idx, MSK_TX_RING_CNT)) {
			le = &sc_if->sk_rdata->sk_tx_ring[idx];
			msk_dump_txdesc(le, idx);
		}
	}
#endif

	*txidx = frag;

	DPRINTFN(2, ("msk_encap: completed successfully\n"));

	return (0);
}

void
msk_start(struct ifnet *ifp)
{
	struct sk_if_softc	*sc_if = ifp->if_softc;
	struct mbuf		*m_head = NULL;
	u_int32_t		idx = sc_if->sk_cdata.sk_tx_prod;
	int			post = 0;

	for (;;) {
		if (sc_if->sk_cdata.sk_tx_cnt + (SK_NTXSEG * 2) + 1 >
		    MSK_TX_RING_CNT) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		m_head = ifq_dequeue(&ifp->if_snd);
		if (m_head == NULL)
			break;

		/*
		 * Pack the data into the transmit ring. If we
		 * don't have room, set the OACTIVE flag and wait
		 * for the NIC to drain the ring.
		 */
		if (msk_encap(sc_if, m_head, &idx)) {
			m_freem(m_head);
			continue;
		}

		/* now we are committed to transmit the packet */

		/*
		 * If there's a BPF listener, bounce a copy of this frame
		 * to him.
		 */
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif
		post = 1;
	}
	if (post == 0)
		return;

	/* Transmit */
	sc_if->sk_cdata.sk_tx_prod = idx;
	SK_IF_WRITE_2(sc_if, 1, SK_TXQA1_Y2_PREF_PUTIDX, idx);

	/* Set a timeout in case the chip goes out to lunch. */
	ifp->if_timer = MSK_TX_TIMEOUT;
}

void
msk_watchdog(struct ifnet *ifp)
{
	struct sk_if_softc *sc_if = ifp->if_softc;

	/*
	 * Reclaim first as there is a possibility of losing Tx completion
	 * interrupts.
	 */
	msk_txeof(sc_if);
	if (sc_if->sk_cdata.sk_tx_cnt != 0) {
		printf("%s: watchdog timeout\n", sc_if->sk_dev.dv_xname);

		ifp->if_oerrors++;

		/* XXX Resets both ports; we shouldn't do that. */
		mskc_reset(sc_if->sk_softc);
		msk_reset(sc_if);
		msk_init(sc_if);
	}
}

static __inline int
msk_rxvalid(struct sk_softc *sc, u_int32_t stat, u_int32_t len)
{
	if ((stat & (YU_RXSTAT_CRCERR | YU_RXSTAT_LONGERR |
	    YU_RXSTAT_MIIERR | YU_RXSTAT_BADFC | YU_RXSTAT_GOODFC |
	    YU_RXSTAT_JABBER)) != 0 ||
	    (stat & YU_RXSTAT_RXOK) != YU_RXSTAT_RXOK ||
	    YU_RXSTAT_BYTES(stat) != len)
		return (0);

	return (1);
}

void
msk_rxeof(struct sk_if_softc *sc_if, u_int16_t len, u_int32_t rxstat)
{
	struct sk_softc		*sc = sc_if->sk_softc;
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
	struct mbuf_list	ml = MBUF_LIST_INITIALIZER();
	struct mbuf		*m;
	struct sk_chain		*cur_rx;
	int			i, cur, total_len = len;
	bus_dmamap_t		dmamap;

	DPRINTFN(2, ("msk_rxeof\n"));

	cur = sc_if->sk_cdata.sk_rx_cons;

	/* Sync the descriptor */
	MSK_CDRXSYNC(sc_if, cur, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);

	cur_rx = &sc_if->sk_cdata.sk_rx_chain[cur];
	if (cur_rx->sk_mbuf == NULL)
		return;

	dmamap = sc_if->sk_cdata.sk_rx_map[cur];
	for (i = 0; i < dmamap->dm_nsegs; i++) {
		/* each segment consumes two slots on the ring */
	  	SK_INC(sc_if->sk_cdata.sk_rx_cons, MSK_RX_RING_CNT);
	  	SK_INC(sc_if->sk_cdata.sk_rx_cons, MSK_RX_RING_CNT);
	}
	if_rxr_put(&sc_if->sk_cdata.sk_rx_ring, dmamap->dm_nsegs);

	bus_dmamap_sync(sc_if->sk_softc->sc_dmatag, dmamap, 0,
	    dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
	bus_dmamap_unload(sc_if->sk_softc->sc_dmatag, dmamap);

	m = cur_rx->sk_mbuf;
	cur_rx->sk_mbuf = NULL;

	if (total_len < SK_MIN_FRAMELEN ||
	    total_len > SK_JUMBO_FRAMELEN ||
	    msk_rxvalid(sc, rxstat, total_len) == 0) {
		ifp->if_ierrors++;
		m_freem(m);
		return;
	}

	m->m_pkthdr.len = m->m_len = total_len;

	ml_enqueue(&ml, m);
	if_input(ifp, &ml);
}

void
msk_txeof(struct sk_if_softc *sc_if)
{
	struct sk_softc		*sc = sc_if->sk_softc;
	struct msk_tx_desc	*cur_tx;
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
	u_int32_t		idx, reg, sk_ctl;
	struct sk_txmap_entry	*entry;

	DPRINTFN(2, ("msk_txeof\n"));

	if (sc_if->sk_port == SK_PORT_A)
		reg = SK_STAT_BMU_TXA1_RIDX;
	else
		reg = SK_STAT_BMU_TXA2_RIDX;

	/*
	 * Go through our tx ring and free mbufs for those
	 * frames that have been sent.
	 */
	idx = sc_if->sk_cdata.sk_tx_cons;
	while (idx != sk_win_read_2(sc, reg)) {
		MSK_CDTXSYNC(sc_if, idx, 1,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);

		cur_tx = &sc_if->sk_rdata->sk_tx_ring[idx];
		sk_ctl = cur_tx->sk_ctl;
#ifdef MSK_DEBUG
		if (mskdebug >= 2)
			msk_dump_txdesc(cur_tx, idx);
#endif
		if (sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf != NULL) {
			entry = sc_if->sk_cdata.sk_tx_map[idx];

			m_freem(sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf);
			sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf = NULL;

			bus_dmamap_sync(sc->sc_dmatag, entry->dmamap, 0,
			    entry->dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);

			bus_dmamap_unload(sc->sc_dmatag, entry->dmamap);
			SIMPLEQ_INSERT_TAIL(&sc_if->sk_txmap_head, entry,
					  link);
			sc_if->sk_cdata.sk_tx_map[idx] = NULL;
		}
		sc_if->sk_cdata.sk_tx_cnt--;
		SK_INC(idx, MSK_TX_RING_CNT);
	}
	ifp->if_timer = sc_if->sk_cdata.sk_tx_cnt > 0 ? MSK_TX_TIMEOUT : 0;

	sc_if->sk_cdata.sk_tx_cons = idx;

	if (ifq_is_oactive(&ifp->if_snd))
		ifq_restart(&ifp->if_snd);
}

void
msk_fill_rx_ring(struct sk_if_softc *sc_if)
{
	u_int slots, used;

	slots = if_rxr_get(&sc_if->sk_cdata.sk_rx_ring, MSK_RX_RING_CNT/2);
	while (slots > 0) {
		used = msk_newbuf(sc_if);
		if (used == 0)
			break;

		slots -= used;
	}
	if_rxr_put(&sc_if->sk_cdata.sk_rx_ring, slots);
}

void
msk_tick(void *xsc_if)
{
	struct sk_if_softc *sc_if = xsc_if;  
	struct mii_data *mii = &sc_if->sk_mii;
	int s;

	s = splnet();
	mii_tick(mii);
	splx(s);
	timeout_add_sec(&sc_if->sk_tick_ch, 1);
}

void
msk_intr_yukon(struct sk_if_softc *sc_if)
{
	u_int8_t status;

	status = SK_IF_READ_1(sc_if, 0, SK_GMAC_ISR);
	/* RX overrun */
	if ((status & SK_GMAC_INT_RX_OVER) != 0) {
		SK_IF_WRITE_1(sc_if, 0, SK_RXMF1_CTRL_TEST,
		    SK_RFCTL_RX_FIFO_OVER);
	}
	/* TX underrun */
	if ((status & SK_GMAC_INT_TX_UNDER) != 0) {
		SK_IF_WRITE_1(sc_if, 0, SK_TXMF1_CTRL_TEST,
		    SK_TFCTL_TX_FIFO_UNDER);
	}

	DPRINTFN(2, ("msk_intr_yukon status=%#x\n", status));
}

int
msk_intr(void *xsc)
{
	struct sk_softc		*sc = xsc;
	struct sk_if_softc	*sc_if;
	struct sk_if_softc	*sc_if0 = sc->sk_if[SK_PORT_A];
	struct sk_if_softc	*sc_if1 = sc->sk_if[SK_PORT_B];
	struct ifnet		*ifp0 = NULL, *ifp1 = NULL;
	int			claimed = 0, rx[2] = {0, 0};
	u_int32_t		status;
	struct msk_status_desc	*cur_st;

	status = CSR_READ_4(sc, SK_Y2_ISSR2);
	if (status == 0xffffffff)
		return (0);
	if (status == 0) {
		CSR_WRITE_4(sc, SK_Y2_ICR, 2);
		return (0);
	}

	status = CSR_READ_4(sc, SK_ISR);

	if (sc_if0 != NULL)
		ifp0 = &sc_if0->arpcom.ac_if;
	if (sc_if1 != NULL)
		ifp1 = &sc_if1->arpcom.ac_if;

	if (sc_if0 && (status & SK_Y2_IMR_MAC1) &&
	    (ifp0->if_flags & IFF_RUNNING)) {
		msk_intr_yukon(sc_if0);
	}

	if (sc_if1 && (status & SK_Y2_IMR_MAC2) &&
	    (ifp1->if_flags & IFF_RUNNING)) {
		msk_intr_yukon(sc_if1);
	}

	MSK_CDSTSYNC(sc, sc->sk_status_idx,
	    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	cur_st = &sc->sk_status_ring[sc->sk_status_idx];

	while (cur_st->sk_opcode & SK_Y2_STOPC_OWN) {
		cur_st->sk_opcode &= ~SK_Y2_STOPC_OWN;
		switch (cur_st->sk_opcode) {
		case SK_Y2_STOPC_RXSTAT:
			sc_if = sc->sk_if[cur_st->sk_link & 0x01];
			rx[cur_st->sk_link & 0x01] = 1;
			msk_rxeof(sc_if, letoh16(cur_st->sk_len),
			    letoh32(cur_st->sk_status));
			break;
		case SK_Y2_STOPC_TXSTAT:
			if (sc_if0)
				msk_txeof(sc_if0);
			if (sc_if1)
				msk_txeof(sc_if1);
			break;
		default:
			printf("opcode=0x%x\n", cur_st->sk_opcode);
			break;
		}
		SK_INC(sc->sk_status_idx, MSK_STATUS_RING_CNT);

		MSK_CDSTSYNC(sc, sc->sk_status_idx,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
		cur_st = &sc->sk_status_ring[sc->sk_status_idx];
	}

	if (status & SK_Y2_IMR_BMU) {
		CSR_WRITE_4(sc, SK_STAT_BMU_CSR, SK_STAT_BMU_IRQ_CLEAR);
		claimed = 1;
	}

	CSR_WRITE_4(sc, SK_Y2_ICR, 2);

	if (rx[0]) {
		msk_fill_rx_ring(sc_if0);
		SK_IF_WRITE_2(sc_if0, 0, SK_RXQ1_Y2_PREF_PUTIDX,
		    sc_if0->sk_cdata.sk_rx_prod);
	}
	if (rx[1]) {
		msk_fill_rx_ring(sc_if1);
		SK_IF_WRITE_2(sc_if1, 0, SK_RXQ1_Y2_PREF_PUTIDX,
		    sc_if1->sk_cdata.sk_rx_prod);
	}

	if (ifp0 != NULL && !IFQ_IS_EMPTY(&ifp0->if_snd))
		msk_start(ifp0);
	if (ifp1 != NULL && !IFQ_IS_EMPTY(&ifp1->if_snd))
		msk_start(ifp1);

	return (claimed);
}

void
msk_init_yukon(struct sk_if_softc *sc_if)
{
	u_int32_t		v;
	u_int16_t		reg;
	struct sk_softc		*sc;
	int			i;

	sc = sc_if->sk_softc;

	DPRINTFN(2, ("msk_init_yukon: start: sk_csr=%#x\n",
		     CSR_READ_4(sc_if->sk_softc, SK_CSR)));

	DPRINTFN(6, ("msk_init_yukon: 1\n"));

	DPRINTFN(3, ("msk_init_yukon: gmac_ctrl=%#x\n",
		     SK_IF_READ_4(sc_if, 0, SK_GMAC_CTRL)));

	DPRINTFN(6, ("msk_init_yukon: 3\n"));

	/* unused read of the interrupt source register */
	DPRINTFN(6, ("msk_init_yukon: 4\n"));
	SK_IF_READ_2(sc_if, 0, SK_GMAC_ISR);

	DPRINTFN(6, ("msk_init_yukon: 4a\n"));
	reg = SK_YU_READ_2(sc_if, YUKON_PAR);
	DPRINTFN(6, ("msk_init_yukon: YUKON_PAR=%#x\n", reg));

	/* MIB Counter Clear Mode set */
        reg |= YU_PAR_MIB_CLR;
	DPRINTFN(6, ("msk_init_yukon: YUKON_PAR=%#x\n", reg));
	DPRINTFN(6, ("msk_init_yukon: 4b\n"));
	SK_YU_WRITE_2(sc_if, YUKON_PAR, reg);

	/* MIB Counter Clear Mode clear */
	DPRINTFN(6, ("msk_init_yukon: 5\n"));
        reg &= ~YU_PAR_MIB_CLR;
	SK_YU_WRITE_2(sc_if, YUKON_PAR, reg);

	/* receive control reg */
	DPRINTFN(6, ("msk_init_yukon: 7\n"));
	SK_YU_WRITE_2(sc_if, YUKON_RCR, YU_RCR_CRCR);

	/* transmit parameter register */
	DPRINTFN(6, ("msk_init_yukon: 8\n"));
	SK_YU_WRITE_2(sc_if, YUKON_TPR, YU_TPR_JAM_LEN(0x3) |
		      YU_TPR_JAM_IPG(0xb) | YU_TPR_JAM2DATA_IPG(0x1a) );

	/* serial mode register */
	DPRINTFN(6, ("msk_init_yukon: 9\n"));
	reg = YU_SMR_DATA_BLIND(0x1c) |
	      YU_SMR_MFL_VLAN |
	      YU_SMR_IPG_DATA(0x1e);

	if (sc->sk_type != SK_YUKON_FE &&
	    sc->sk_type != SK_YUKON_FE_P)
		reg |= YU_SMR_MFL_JUMBO;

	SK_YU_WRITE_2(sc_if, YUKON_SMR, reg);

	DPRINTFN(6, ("msk_init_yukon: 10\n"));
	/* Setup Yukon's address */
	for (i = 0; i < 3; i++) {
		/* Write Source Address 1 (unicast filter) */
		SK_YU_WRITE_2(sc_if, YUKON_SAL1 + i * 4, 
			      sc_if->arpcom.ac_enaddr[i * 2] |
			      sc_if->arpcom.ac_enaddr[i * 2 + 1] << 8);
	}

	for (i = 0; i < 3; i++) {
		reg = sk_win_read_2(sc_if->sk_softc,
				    SK_MAC1_0 + i * 2 + sc_if->sk_port * 8);
		SK_YU_WRITE_2(sc_if, YUKON_SAL2 + i * 4, reg);
	}

	/* Program promiscuous mode and multicast filters */
	DPRINTFN(6, ("msk_init_yukon: 11\n"));
	msk_iff(sc_if);

	/* enable interrupt mask for counter overflows */
	DPRINTFN(6, ("msk_init_yukon: 12\n"));
	SK_YU_WRITE_2(sc_if, YUKON_TIMR, 0);
	SK_YU_WRITE_2(sc_if, YUKON_RIMR, 0);
	SK_YU_WRITE_2(sc_if, YUKON_TRIMR, 0);

	/* Configure RX MAC FIFO Flush Mask */
	v = YU_RXSTAT_FOFL | YU_RXSTAT_CRCERR | YU_RXSTAT_MIIERR |
	    YU_RXSTAT_BADFC | YU_RXSTAT_GOODFC | YU_RXSTAT_RUNT |
	    YU_RXSTAT_JABBER;
	SK_IF_WRITE_2(sc_if, 0, SK_RXMF1_FLUSH_MASK, v);

	/* Configure RX MAC FIFO */
	SK_IF_WRITE_1(sc_if, 0, SK_RXMF1_CTRL_TEST, SK_RFCTL_RESET_CLEAR);
	SK_IF_WRITE_2(sc_if, 0, SK_RXMF1_CTRL_TEST, SK_RFCTL_OPERATION_ON |
	    SK_RFCTL_FIFO_FLUSH_ON);

	/* Increase flush threshould to 64 bytes */
	SK_IF_WRITE_2(sc_if, 0, SK_RXMF1_FLUSH_THRESHOLD,
	    SK_RFCTL_FIFO_THRESHOLD + 1);

	/* Configure TX MAC FIFO */
	SK_IF_WRITE_1(sc_if, 0, SK_TXMF1_CTRL_TEST, SK_TFCTL_RESET_CLEAR);
	SK_IF_WRITE_2(sc_if, 0, SK_TXMF1_CTRL_TEST, SK_TFCTL_OPERATION_ON);

#if 1
	SK_YU_WRITE_2(sc_if, YUKON_GPCR, YU_GPCR_TXEN | YU_GPCR_RXEN);
#endif
	DPRINTFN(6, ("msk_init_yukon: end\n"));
}

/*
 * Note that to properly initialize any part of the GEnesis chip,
 * you first have to take it out of reset mode.
 */
void
msk_init(void *xsc_if)
{
	struct sk_if_softc	*sc_if = xsc_if;
	struct sk_softc		*sc = sc_if->sk_softc;
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
	struct mii_data		*mii = &sc_if->sk_mii;
	int			s;

	DPRINTFN(2, ("msk_init\n"));

	s = splnet();

	/* Cancel pending I/O and free all RX/TX buffers. */
	msk_stop(sc_if, 0);

	/* Configure I2C registers */

	/* Configure XMAC(s) */
	msk_init_yukon(sc_if);
	mii_mediachg(mii);

	sc_if->sk_tx_hiaddr = 0;

	/* Configure transmit arbiter(s) */
	SK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL, SK_TXARCTL_ON);
#if 0
	    SK_TXARCTL_ON|SK_TXARCTL_FSYNC_ON);
#endif

	/* Configure RAMbuffers */
	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_UNRESET);
	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_START, sc_if->sk_rx_ramstart);
	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_WR_PTR, sc_if->sk_rx_ramstart);
	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_RD_PTR, sc_if->sk_rx_ramstart);
	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_END, sc_if->sk_rx_ramend);
	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_ON);

	SK_IF_WRITE_4(sc_if, 1, SK_TXRBA1_CTLTST, SK_RBCTL_UNRESET);
	SK_IF_WRITE_4(sc_if, 1, SK_TXRBA1_CTLTST, SK_RBCTL_STORENFWD_ON);
	SK_IF_WRITE_4(sc_if, 1, SK_TXRBA1_START, sc_if->sk_tx_ramstart);
	SK_IF_WRITE_4(sc_if, 1, SK_TXRBA1_WR_PTR, sc_if->sk_tx_ramstart);
	SK_IF_WRITE_4(sc_if, 1, SK_TXRBA1_RD_PTR, sc_if->sk_tx_ramstart);
	SK_IF_WRITE_4(sc_if, 1, SK_TXRBA1_END, sc_if->sk_tx_ramend);
	SK_IF_WRITE_4(sc_if, 1, SK_TXRBA1_CTLTST, SK_RBCTL_ON);

	/* Configure BMUs */
	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, 0x00000016);
	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, 0x00000d28);
	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, 0x00000080);
	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_WATERMARK, 0x00000600);

	SK_IF_WRITE_4(sc_if, 1, SK_TXQA1_BMU_CSR, 0x00000016);
	SK_IF_WRITE_4(sc_if, 1, SK_TXQA1_BMU_CSR, 0x00000d28);
	SK_IF_WRITE_4(sc_if, 1, SK_TXQA1_BMU_CSR, 0x00000080);
	SK_IF_WRITE_4(sc_if, 1, SK_TXQA1_WATERMARK, 0x00000600);

	/* Make sure the sync transmit queue is disabled. */
	SK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_RESET);

	/* Init descriptors */
	if (msk_init_rx_ring(sc_if) == ENOBUFS) {
		printf("%s: initialization failed: no "
		    "memory for rx buffers\n", sc_if->sk_dev.dv_xname);
		msk_stop(sc_if, 0);
		splx(s);
		return;
	}

	if (msk_init_tx_ring(sc_if) == ENOBUFS) {
		printf("%s: initialization failed: no "
		    "memory for tx buffers\n", sc_if->sk_dev.dv_xname);
		msk_stop(sc_if, 0);
		splx(s);
		return;
	}

	/* Initialize prefetch engine. */
	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_Y2_PREF_CSR, 0x00000001);
	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_Y2_PREF_CSR, 0x00000002);
	SK_IF_WRITE_2(sc_if, 0, SK_RXQ1_Y2_PREF_LIDX, MSK_RX_RING_CNT - 1);
	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_Y2_PREF_ADDRLO,
	    MSK_RX_RING_ADDR(sc_if, 0));
	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_Y2_PREF_ADDRHI,
	    (u_int64_t)MSK_RX_RING_ADDR(sc_if, 0) >> 32);
	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_Y2_PREF_CSR, 0x00000008);
	SK_IF_READ_4(sc_if, 0, SK_RXQ1_Y2_PREF_CSR);

	SK_IF_WRITE_4(sc_if, 1, SK_TXQA1_Y2_PREF_CSR, 0x00000001);
	SK_IF_WRITE_4(sc_if, 1, SK_TXQA1_Y2_PREF_CSR, 0x00000002);
	SK_IF_WRITE_2(sc_if, 1, SK_TXQA1_Y2_PREF_LIDX, MSK_TX_RING_CNT - 1);
	SK_IF_WRITE_4(sc_if, 1, SK_TXQA1_Y2_PREF_ADDRLO,
	    MSK_TX_RING_ADDR(sc_if, 0));
	SK_IF_WRITE_4(sc_if, 1, SK_TXQA1_Y2_PREF_ADDRHI,
	    (u_int64_t)MSK_TX_RING_ADDR(sc_if, 0) >> 32);
	SK_IF_WRITE_4(sc_if, 1, SK_TXQA1_Y2_PREF_CSR, 0x00000008);
	SK_IF_READ_4(sc_if, 1, SK_TXQA1_Y2_PREF_CSR);

	SK_IF_WRITE_2(sc_if, 0, SK_RXQ1_Y2_PREF_PUTIDX,
	    sc_if->sk_cdata.sk_rx_prod);

	/* Configure interrupt handling */
	if (sc_if->sk_port == SK_PORT_A)
		sc->sk_intrmask |= SK_Y2_INTRS1;
	else
		sc->sk_intrmask |= SK_Y2_INTRS2;
	sc->sk_intrmask |= SK_Y2_IMR_BMU;
	CSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	timeout_add_sec(&sc_if->sk_tick_ch, 1);

	splx(s);
}

void
msk_stop(struct sk_if_softc *sc_if, int softonly)
{
	struct sk_softc		*sc = sc_if->sk_softc;
	struct ifnet		*ifp = &sc_if->arpcom.ac_if;
	struct sk_txmap_entry	*dma;
	int			i;

	DPRINTFN(2, ("msk_stop\n"));

	timeout_del(&sc_if->sk_tick_ch);

	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/* Stop transfer of Tx descriptors */

	/* Stop transfer of Rx descriptors */

	if (!softonly) {
		/* Turn off various components of this interface. */
		SK_IF_WRITE_1(sc_if,0, SK_RXMF1_CTRL_TEST, SK_RFCTL_RESET_SET);
		SK_IF_WRITE_1(sc_if,0, SK_TXMF1_CTRL_TEST, SK_TFCTL_RESET_SET);
		SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_OFFLINE);
		SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);
		SK_IF_WRITE_4(sc_if, 1, SK_TXQA1_BMU_CSR, SK_TXBMU_OFFLINE);
		SK_IF_WRITE_4(sc_if, 1, SK_TXRBA1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);
		SK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL, SK_TXARCTL_OFF);
		SK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);
		SK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_TXLEDCTL_COUNTER_STOP);
		SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_OFF);
		SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_LINKSYNC_OFF);

		SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_Y2_PREF_CSR, 0x00000001);
		SK_IF_WRITE_4(sc_if, 1, SK_TXQA1_Y2_PREF_CSR, 0x00000001);

		/* Disable interrupts */
		if (sc_if->sk_port == SK_PORT_A)
			sc->sk_intrmask &= ~SK_Y2_INTRS1;
		else
			sc->sk_intrmask &= ~SK_Y2_INTRS2;
		CSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);
	}

	/* Free RX and TX mbufs still in the queues. */
	for (i = 0; i < MSK_RX_RING_CNT; i++) {
		if (sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf != NULL) {
			m_freem(sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf);
			sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf = NULL;
		}
	}

	sc_if->sk_cdata.sk_rx_prod = 0;
	sc_if->sk_cdata.sk_rx_cons = 0;

	for (i = 0; i < MSK_TX_RING_CNT; i++) {
		if (sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf != NULL) {
			m_freem(sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf);
			sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf = NULL;
			SIMPLEQ_INSERT_HEAD(&sc_if->sk_txmap_head,
			    sc_if->sk_cdata.sk_tx_map[i], link);
			sc_if->sk_cdata.sk_tx_map[i] = 0;
		}
	}

	while ((dma = SIMPLEQ_FIRST(&sc_if->sk_txmap_head))) {
		SIMPLEQ_REMOVE_HEAD(&sc_if->sk_txmap_head, link);
		bus_dmamap_destroy(sc->sc_dmatag, dma->dmamap);
		free(dma, M_DEVBUF, sizeof *dma);
	}
}

struct cfattach mskc_ca = {
	sizeof(struct sk_softc), mskc_probe, mskc_attach, mskc_detach,
	mskc_activate
};

struct cfdriver mskc_cd = {
	NULL, "mskc", DV_DULL
};

struct cfattach msk_ca = {
	sizeof(struct sk_if_softc), msk_probe, msk_attach, msk_detach,
	msk_activate
};

struct cfdriver msk_cd = {
	NULL, "msk", DV_IFNET
};

#ifdef MSK_DEBUG
void
msk_dump_txdesc(struct msk_tx_desc *le, int idx)
{
#define DESC_PRINT(X)					\
	if (X)					\
		printf("txdesc[%d]." #X "=%#x\n",	\
		       idx, X);

	DESC_PRINT(letoh32(le->sk_addr));
	DESC_PRINT(letoh16(le->sk_len));
	DESC_PRINT(le->sk_ctl);
	DESC_PRINT(le->sk_opcode);
#undef DESC_PRINT
}

void
msk_dump_bytes(const char *data, int len)
{
	int c, i, j;

	for (i = 0; i < len; i += 16) {
		printf("%08x  ", i);
		c = len - i;
		if (c > 16) c = 16;

		for (j = 0; j < c; j++) {
			printf("%02x ", data[i + j] & 0xff);
			if ((j & 0xf) == 7 && j > 0)
				printf(" ");
		}
		
		for (; j < 16; j++)
			printf("   ");
		printf("  ");

		for (j = 0; j < c; j++) {
			int ch = data[i + j] & 0xff;
			printf("%c", ' ' <= ch && ch <= '~' ? ch : ' ');
		}
		
		printf("\n");
		
		if (c < 16)
			break;
	}
}

void
msk_dump_mbuf(struct mbuf *m)
{
	int count = m->m_pkthdr.len;

	printf("m=%#lx, m->m_pkthdr.len=%#d\n", m, m->m_pkthdr.len);

	while (count > 0 && m) {
		printf("m=%#lx, m->m_data=%#lx, m->m_len=%d\n",
		       m, m->m_data, m->m_len);
		msk_dump_bytes(mtod(m, char *), m->m_len);

		count -= m->m_len;
		m = m->m_next;
	}
}
#endif
@


1.128
log
@reorder ops in sk_start to avoid possibly rolling back ifq_deq.

instead of checking for space after beggining to deq a packet, check
for space before committing to handling a packet. this means we
can use ifq_dequeue instead of ifq_deq_begin/commit/rollback.

this is a port of src/sys/dev/pci/if_sk.c r1.187, but tweaked to
account for msk using twice the tx ring descriptors thanks to its
annoying support for 64bit addresses.

tested on an od1000
ok jmatthew@@ sthen@@
@
text
@d1476 1
a1476 1
	int			i, entries;
d1480 2
d1512 1
d1516 12
a1527 8
		f = &sc_if->sk_rdata->sk_tx_ring[frag];
		f->sk_addr = htole32(addr >> 32);
		if (i == 0)
			f->sk_opcode = SK_Y2_TXOPC_ADDR64;
		else
			f->sk_opcode = SK_Y2_TXOPC_ADDR64 | SK_Y2_TXOPC_OWN;

		SK_INC(frag, MSK_TX_RING_CNT);
d1531 1
a1531 1
		f->sk_addr = htole32(addr & 0xffffffff);
d1534 2
a1535 4
		if (i == 0)
			f->sk_opcode = SK_Y2_TXOPC_PACKET | SK_Y2_TXOPC_OWN;
		else
			f->sk_opcode = SK_Y2_TXOPC_BUFFER | SK_Y2_TXOPC_OWN;
d1537 1
d1539 2
d1767 1
a1767 2
	if (sc_if->sk_cdata.sk_tx_cnt < MSK_TX_RING_CNT - 2)
		ifq_clr_oactive(&ifp->if_snd);
d1769 2
a1770 1
	sc_if->sk_cdata.sk_tx_cons = idx;
d2050 2
@


1.127
log
@Attempt to map msk(4) interrupt via MSI.

The device tree that ships with the overdrive 1000 has an interrupt-map
property that is known to be wrong.  Using MSI on msk makes the builtin
Ethernet on the overdrive 1000 work.

Tested on arm64 with
"Marvell Yukon 88E8059" rev 0x00, Yukon-2 Optima (0x1)

and i386 with
"Marvell Yukon 88E8072" rev 0x10, Yukon-2 Extreme rev. B0 (0x2)

Committing this early in the release cycle to try find cases where using
MSI doesn't work.

Based on part of an earlier patch from jmatthew@@
ok jmatthew@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.126 2017/04/08 03:36:50 jmatthew Exp $	*/
d1492 12
a1503 14
#ifdef MSK_DEBUG
	if (mskdebug >= 2)
		msk_dump_mbuf(m_head);
#endif

	/*
	 * Start packing the mbufs in this chain into
	 * the fragment pointers. Stop when we run out
	 * of fragments or hit the end of the mbuf chain.
	 */
	if (bus_dmamap_load_mbuf(sc->sc_dmatag, txmap, m_head,
	    BUS_DMA_NOWAIT)) {
		DPRINTFN(2, ("msk_encap: dmamap failed\n"));
		return (ENOBUFS);
a1505 9
	entries = txmap->dm_nsegs * 2;
	if (entries > (MSK_TX_RING_CNT - sc_if->sk_cdata.sk_tx_cnt - 2)) {
		DPRINTFN(2, ("msk_encap: too few descriptors free\n"));
		bus_dmamap_unload(sc->sc_dmatag, txmap);
		return (ENOBUFS);
	}

	DPRINTFN(2, ("msk_encap: dm_nsegs=%d\n", txmap->dm_nsegs));

d1577 1
a1577 1
	int			pkts = 0;
d1579 6
a1584 1
	DPRINTFN(2, ("msk_start\n"));
d1586 1
a1586 2
	while (sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf == NULL) {
		m_head = ifq_deq_begin(&ifp->if_snd);
d1596 2
a1597 3
			ifq_deq_rollback(&ifp->if_snd, m_head);
			ifq_set_oactive(&ifp->if_snd);
			break;
a1600 2
		ifq_deq_commit(&ifp->if_snd, m_head);
		pkts++;
d1610 1
d1612 1
a1612 1
	if (pkts == 0)
d1616 2
a1617 3
	if (idx != sc_if->sk_cdata.sk_tx_prod) {
		sc_if->sk_cdata.sk_tx_prod = idx;
		SK_IF_WRITE_2(sc_if, 1, SK_TXQA1_Y2_PREF_PUTIDX, idx);
d1619 2
a1620 3
		/* Set a timeout in case the chip goes out to lunch. */
		ifp->if_timer = MSK_TX_TIMEOUT;
	}
@


1.126
log
@Use ADDR64 opcodes to specify 64bit DMA addresses for all buffers.  This
consumes two ring entries per segment, halving the effective size of the
rings, but keeps things simple.  This is required for the onboard nic
on the Overdrive 1000 to work.

ok kettenis@@, tested on i386 by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.125 2017/01/22 10:17:38 dlg Exp $	*/
d1167 1
a1167 1
	if (pci_intr_map(pa, &ih)) {
@


1.125
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.124 2017/01/08 18:08:14 visa Exp $	*/
d428 2
a429 1
	if_rxr_init(&sc_if->sk_cdata.sk_rx_ring, 2, MSK_RX_RING_CNT);
d489 1
d514 12
a525 1
	r->sk_addr = htole32(dmamap->dm_segs[0].ds_addr);
d528 2
d531 4
a534 1
	MSK_CDRXSYNC(sc_if, head, BUS_DMASYNC_PREWRITE);
d543 18
a560 1
		r->sk_addr = htole32(dmamap->dm_segs[i].ds_addr);
d577 1
a577 1
	r->sk_opcode = SK_Y2_RXOPC_PACKET | SK_Y2_RXOPC_OWN;
d1474 1
a1474 1
	struct msk_tx_desc		*f = NULL;
d1476 1
a1476 1
	int			i;
d1479 1
d1508 2
a1509 1
	if (txmap->dm_nsegs > (MSK_TX_RING_CNT - sc_if->sk_cdata.sk_tx_cnt - 2)) {
d1522 2
d1525 11
a1535 1
		f->sk_addr = htole32(txmap->dm_segs[i].ds_addr);
d1539 1
a1539 1
			f->sk_opcode = SK_Y2_TXOPC_PACKET;
d1553 1
a1553 1
	MSK_CDTXSYNC(sc_if, *txidx, txmap->dm_nsegs,
d1562 1
a1562 1
	sc_if->sk_cdata.sk_tx_cnt += txmap->dm_nsegs;
d1693 2
d1781 1
a1781 1
	slots = if_rxr_get(&sc_if->sk_cdata.sk_rx_ring, MSK_RX_RING_CNT);
@


1.124
log
@Use a macro for the Tx timeout value.

OK deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.123 2016/04/13 10:34:32 mpi Exp $	*/
a1699 2
		if (sk_ctl & SK_Y2_TXCTL_LASTFRAG)
			ifp->if_opackets++;
@


1.123
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.122 2015/11/25 03:09:59 dlg Exp $	*/
d1581 1
a1581 1
		ifp->if_timer = 5;
d1719 1
a1719 1
	ifp->if_timer = sc_if->sk_cdata.sk_tx_cnt > 0 ? 5 : 0;
@


1.122
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.121 2015/11/24 17:11:39 mpi Exp $	*/
a960 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.121
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.120 2015/11/24 13:33:17 mpi Exp $	*/
d1556 1
a1556 1
			ifp->if_flags |= IFF_OACTIVE;
d1723 1
a1723 1
		ifp->if_flags &= ~IFF_OACTIVE;
d2092 1
a2092 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2111 2
a2112 1
	ifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);
@


1.120
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.119 2015/11/20 03:35:23 dlg Exp $	*/
a102 1
#include <net/if_dl.h>
@


1.119
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.118 2015/11/14 17:54:57 mpi Exp $	*/
a103 1
#include <net/if_types.h>
@


1.118
log
@Do not include <net/if_vlan_var.h> when it's not necessary.

Because of the VLAN hacks in mpw(4) this file still contains the definition
of "struct ifvlan" which depends on <sys/refcnt.h> which in turns pull
<sys/atomic.h>...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.117 2015/10/25 13:04:28 mpi Exp $	*/
d1547 1
a1547 1
		IFQ_POLL(&ifp->if_snd, m_head);
d1557 1
d1563 1
a1563 1
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.117
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.116 2015/09/11 09:14:52 deraadt Exp $	*/
a109 1
#include <net/if_vlan_var.h>
@


1.116
log
@size for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.115 2015/06/24 09:40:54 mpi Exp $	*/
a580 1
	struct ifaddr *ifa = (struct ifaddr *) data;
a591 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc_if->arpcom, ifa);
@


1.115
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.114 2015/04/30 07:51:07 mpi Exp $	*/
d2171 1
a2171 1
		free(dma, M_DEVBUF, 0);
@


1.114
log
@Convert moar drivers to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.113 2015/03/14 03:38:48 jsg Exp $	*/
a1671 2
	ifp->if_ipackets++;

@


1.113
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.112 2014/12/22 02:28:52 tedu Exp $	*/
d1631 1
a1668 1
	m->m_pkthdr.rcvif = ifp;
d1671 1
d1674 1
a1674 7
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

	/* pass it on. */
	ether_input_mbuf(ifp, m);
@


1.112
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.111 2014/11/24 23:28:50 brad Exp $	*/
a117 1
#include <dev/mii/brgphyreg.h>
@


1.111
log
@rxr ioctl handling.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.110 2014/10/19 03:54:56 brad Exp $	*/
a105 1
#ifdef INET
a107 1
#endif
a593 1
#ifdef INET
a595 1
#endif
@


1.110
log
@Use sc_if->sk_pktlen to specify the maximum DMA transfer size and maximum
DMA segment size when setting up the TX buffers in msk_init_tx_ring().

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.109 2014/10/09 09:34:17 mpi Exp $	*/
d619 5
@


1.109
log
@Revert "enable MSI support", it introduced a regression on some chips.

Theo Buehler reported some connectivity lost with a Yukon-2 EC 88E8053
on tech@@ and I could reproduce it with Yukon-2 FE 88E8036.

Discussed with brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.108 2014/10/04 18:20:50 brad Exp $	*/
d462 2
a463 2
		if (bus_dmamap_create(sc->sc_dmatag, SK_JLEN, SK_NTXSEG,
		   SK_JLEN, 0, BUS_DMA_NOWAIT, &dmamap))
@


1.108
log
@- Recognize the Yukon Prime and Yukon Optima 2 chipsets.
- Recognize some more revs of the EC U and Supreme chipsets.
- Add the PCI id for the Yukon 88E8079.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.107 2014/09/23 21:16:42 brad Exp $	*/
d1139 1
a1139 1
	if (pci_intr_map_msi(pa, &ih) != 0 && pci_intr_map(pa, &ih) != 0) {
@


1.107
log
@Enable MSI support.

Tested with a number of chipsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.106 2014/07/22 13:12:11 mpi Exp $	*/
d214 1
d768 2
d836 2
d1221 1
a1221 1
		sc->sk_name = "Yukon-2 Ultra2";
d1226 6
d1282 3
d1319 15
a1333 2
	if (sc->sk_type == SK_YUKON_SUPR && sc->sk_rev == SK_YUKON_SUPR_REV_A0)
		revstr = "A0";
d1335 12
@


1.106
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.105 2014/07/12 18:48:51 tedu Exp $	*/
d1134 1
a1134 1
	if (pci_intr_map(pa, &ih)) {
@


1.105
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.104 2014/07/09 00:15:20 dlg Exp $	*/
a107 4
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netinet/tcp.h>
@


1.104
log
@avoid being too smart when filling the rx ring.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.103 2014/07/08 05:35:18 dlg Exp $	*/
d2143 1
a2143 1
		free(dma, M_DEVBUF);
@


1.103
log
@cut things that relied on mclgeti for rx ring accounting/restriction over
to using if_rxr.

cut the reporting systat did over to the rxr ioctl.

tested as much as i can on alpha, amd64, and sparc64.
mpi@@ has run it on macppc.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.102 2013/12/28 03:35:42 deraadt Exp $	*/
d1711 1
a1711 1
	while (slots > SK_NRXSEG) {
@


1.102
log
@The few network drivers that called their children's (ie. mii PHY
drivers) activate functions at DVACT_RESUME time do not need to do
so, since their PHYs are repaired by IFF_UP.
NOTE: if_msk is the one that previously relied on mii/eephy.c doing
a crazy dance.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.101 2013/12/08 16:39:38 deraadt Exp $	*/
d436 2
a437 1
	sc_if->sk_cdata.sk_rx_cnt = 0;
d498 3
a500 3
	m = MCLGETI(NULL, M_DONTWAIT, &sc_if->arpcom.ac_if, sc_if->sk_pktlen);
	if (!m)
		return (ENOBUFS);
d510 1
a510 7
		return (ENOBUFS);
	}

	if (dmamap->dm_nsegs > (MSK_RX_RING_CNT - sc_if->sk_cdata.sk_rx_cnt)) {
		bus_dmamap_unload(sc_if->sk_softc->sc_dmatag, dmamap);
		m_freem(m);
		return (ENOBUFS);
a527 1
	sc_if->sk_cdata.sk_rx_cnt++;
a546 1
		sc_if->sk_cdata.sk_rx_cnt++;
d555 1
a555 1
	return (0);
d948 1
a948 1
		    sc_if->sk_pktlen, 4, sc_if->sk_pktlen,
a1006 1
	m_clsetwms(ifp, sc_if->sk_pktlen, 2, MSK_RX_RING_CNT);
a1614 1
		sc_if->sk_cdata.sk_rx_cnt--;
d1616 1
d1708 6
a1713 2
	while (sc_if->sk_cdata.sk_rx_cnt < MSK_RX_RING_CNT) {
		if (msk_newbuf(sc_if) == ENOBUFS)
d1715 2
d1718 1
a2128 1
	sc_if->sk_cdata.sk_rx_cnt = 0;
@


1.101
log
@simplify activate function
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.100 2013/12/06 21:03:04 deraadt Exp $	*/
a1077 1
		rv = config_activate_children(self, act);
@


1.100
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.99 2013/08/07 01:06:36 bluhm Exp $	*/
d791 1
a1075 3
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);
		break;
d1405 2
a1406 1
	case DVACT_QUIESCE:
d1409 1
a1409 5
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);
		break;
	case DVACT_RESUME:
		mskc_reset(sc);
@


1.99
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.98 2013/03/17 10:56:23 brad Exp $	*/
a1074 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
d1083 3
@


1.98
log
@Correct the clock speeds used to calculate int moderation values provided
by the SK_IM_USECS() macro.

From FreeBSD

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.97 2013/02/01 06:51:32 brad Exp $	*/
a108 1
#include <netinet/in_var.h>
@


1.97
log
@Rewrite the receive filter handling code and cleanup the ioctl bits.

ok jsg@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.96 2012/11/29 21:10:32 brad Exp $	*/
d774 4
a777 2
	case SK_YUKON_XL:
	case SK_YUKON_FE:
d780 9
@


1.96
log
@Remove setting an initial assumed baudrate upon driver attach which is not
necessarily correct, there might not even be a link when attaching.

ok mikeb@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.95 2012/10/18 21:44:21 deraadt Exp $	*/
d168 1
a168 2
void msk_setmulti(struct sk_if_softc *);
void msk_setpromisc(struct sk_if_softc *);
d365 1
a365 1
msk_setmulti(struct sk_if_softc *sc_if)
d367 1
a367 3
	struct ifnet *ifp= &sc_if->arpcom.ac_if;
	u_int32_t hashes[2] = { 0, 0 };
	int h;
d371 3
d375 3
a377 5
	/* First, zot all the existing filters. */
	SK_YU_WRITE_2(sc_if, YUKON_MCAH1, 0);
	SK_YU_WRITE_2(sc_if, YUKON_MCAH2, 0);
	SK_YU_WRITE_2(sc_if, YUKON_MCAH3, 0);
	SK_YU_WRITE_2(sc_if, YUKON_MCAH4, 0);
d379 4
d384 7
a390 5
	/* Now program new ones. */
allmulti:
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
		hashes[0] = 0xFFFFFFFF;
		hashes[1] = 0xFFFFFFFF;
d392 4
a395 1
		/* First find the tail of the list. */
d398 3
a400 7
			if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
				 ETHER_ADDR_LEN)) {
				ifp->if_flags |= IFF_ALLMULTI;
				goto allmulti;
			}
			h = ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) &
			    ((1 << SK_HASH_BITS) - 1);
d414 1
a414 13
}

void
msk_setpromisc(struct sk_if_softc *sc_if)
{
	struct ifnet *ifp = &sc_if->arpcom.ac_if;

	if (ifp->if_flags & IFF_PROMISC)
		SK_YU_CLRBIT_2(sc_if, YUKON_RCR,
		    YU_RCR_UFLEN | YU_RCR_MUFLEN);
	else
		SK_YU_SETBIT_2(sc_if, YUKON_RCR,
		    YU_RCR_UFLEN | YU_RCR_MUFLEN);
d610 1
a610 1
#endif /* INET */
d615 4
a618 9
			if (ifp->if_flags & IFF_RUNNING &&
			    (sc_if->sk_if_flags ^ ifp->if_flags) &
			     IFF_PROMISC) {
				msk_setpromisc(sc_if);
				msk_setmulti(sc_if);
			} else {
				if (!(ifp->if_flags & IFF_RUNNING))
					msk_init(sc_if);
			}
a622 1
		sc_if->sk_if_flags = ifp->if_flags;
d637 1
a637 1
			msk_setmulti(sc_if);
d1919 1
a1919 4
	/* Set promiscuous mode */
	msk_setpromisc(sc_if);

	/* Set multicast filter */
d1921 1
a1921 1
	msk_setmulti(sc_if);
@


1.95
log
@Convert a number of old private copies of code which predates
pci_set_powerstate() to using it instead.  Many of these chunks of code had
bugs in them, especially missing delay() calls.  Some of them were doing
things our PCI subsystem is now responsible for handling.  If you have
any of the affected devices, please keep an eye out for regressions.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.94 2012/03/28 12:02:49 jsg Exp $	*/
a972 1
	ifp->if_baudrate = 1000000000;
@


1.94
log
@Take some additional steps needed to make the PHY on EC Ultra/8056
work correctly, based on similiar changes in FreeBSD.

Originally from Brad Davis but changed quite a bit by claudio kettenis
and myself since.  ok kettenis@@, earlier version ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.93 2011/06/22 16:44:27 tedu Exp $	*/
d1121 1
a1121 1
	pcireg_t command, memtype;
d1130 1
a1130 29
	/*
	 * Handle power management nonsense.
	 */
	command = pci_conf_read(pc, pa->pa_tag, SK_PCI_CAPID) & 0x000000FF;

	if (command == 0x01) {
		command = pci_conf_read(pc, pa->pa_tag, SK_PCI_PWRMGMTCTRL);
		if (command & SK_PSTATE_MASK) {
			u_int32_t		iobase, membase, irq;

			/* Save important PCI config data. */
			iobase = pci_conf_read(pc, pa->pa_tag, SK_PCI_LOIO);
			membase = pci_conf_read(pc, pa->pa_tag, SK_PCI_LOMEM);
			irq = pci_conf_read(pc, pa->pa_tag, SK_PCI_INTLINE);

			/* Reset the power state. */
			printf("%s chip is in D%d power mode "
			    "-- setting to D0\n", sc->sk_dev.dv_xname,
			    command & SK_PSTATE_MASK);
			command &= 0xFFFFFFFC;
			pci_conf_write(pc, pa->pa_tag,
			    SK_PCI_PWRMGMTCTRL, command);

			/* Restore PCI config data. */
			pci_conf_write(pc, pa->pa_tag, SK_PCI_LOIO, iobase);
			pci_conf_write(pc, pa->pa_tag, SK_PCI_LOMEM, membase);
			pci_conf_write(pc, pa->pa_tag, SK_PCI_INTLINE, irq);
		}
	}
@


1.93
log
@kill a few more casts that aren't helpful.  ok krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.92 2011/04/03 15:36:02 jasper Exp $	*/
d691 26
@


1.92
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.91 2010/11/17 10:43:23 kevlo Exp $	*/
d433 1
a433 2
	bzero((char *)rd->sk_rx_ring,
	    sizeof(struct msk_rx_desc) * MSK_RX_RING_CNT);
d462 1
a462 1
	bzero((char *)sc_if->sk_rdata->sk_tx_ring,
d773 1
a773 1
	bzero((char *)sc->sk_status_ring,
@


1.91
log
@Add support for Marvell 88E8059, found in HP mini 5102.
Tested by Frans Haarman <franshaarman at gmail.com>

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.90 2010/09/20 07:40:38 deraadt Exp $	*/
d669 1
a669 1
	    sizeof(mskc_devices)/sizeof(mskc_devices[0])));
@


1.90
log
@Stop doing shutdown hooks in network drivers where possible.  We already
take all interfaces down, via their xxstop routines.  Claudio and I have
verified that none of the shutdown hooks do much extra beyond what xxstop
was already doing; it is largely a pile of junk.
ok claudio, some early comments by sthen; also read by matthew, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.89 2010/09/12 10:39:50 kettenis Exp $	*/
d211 1
d766 1
d822 1
d1241 3
@


1.89
log
@Add some missing bus_dmamap_sync().  Fix a small whitespace problem while
I'm there.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.88 2010/08/31 17:13:44 deraadt Exp $	*/
a138 1
void mskc_shutdown(void *);
a992 2
	sc_if->sk_sdhook = shutdownhook_establish(mskc_shutdown, sc);

a1024 3
	if (sc_if->sk_sdhook != NULL)
		shutdownhook_disestablish(sc_if->sk_sdhook);

a1592 17
}

void
mskc_shutdown(void *v)
{
	struct sk_softc		*sc = v;

	DPRINTFN(2, ("msk_shutdown\n"));

	/* Turn off the 'driver is loaded' LED. */
	CSR_WRITE_2(sc, SK_LED, SK_LED_GREEN_OFF);

	/*
	 * Reset the GEnesis controller. Doing this should also
	 * assert the resets on the attached XMAC(s).
	 */
	mskc_reset(sc);
@


1.88
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.87 2010/05/19 15:27:35 oga Exp $	*/
d541 2
d554 4
d559 1
d1863 1
a1863 1
		SK_IF_WRITE_2(sc_if0, 0,  SK_RXQ1_Y2_PREF_PUTIDX,
d1868 1
a1868 1
		SK_IF_WRITE_2(sc_if1, 0,  SK_RXQ1_Y2_PREF_PUTIDX,
@


1.87
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.86 2010/01/09 02:40:18 sthen Exp $	*/
d1052 3
a1064 1

d1409 3
a1419 1

@


1.86
log
@Remove typo and magic numbers from #if 0'd block, from Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.85 2009/12/18 21:46:24 sthen Exp $	*/
d893 1
a893 1
	    BUS_DMA_NOWAIT)) {
a915 1
	bzero(sc_if->sk_rdata, sizeof(struct msk_ring_data));
d1172 2
a1173 1
	    0, &sc->sk_status_seg, 1, &sc->sk_status_nseg, BUS_DMA_NOWAIT)) {
a1199 2
	bzero(sc->sk_status_ring,
	    MSK_STATUS_RING_CNT * sizeof(struct msk_status_desc));
@


1.85
log
@More device id ordering, from Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.84 2009/12/17 01:09:28 sthen Exp $	*/
d783 3
a785 4
	sk_win_write_4(sc, SK_Y2_LEV_TIMERINIT, SK_IM_USECS(100));
	sk_win_write_4(sc, 0x0ec0, SK_IM_USECS(1000));

	sk_win_write_4(sc, 0x0ed0, SK_IM_USECS(20));
@


1.84
log
@Device id ordering, from Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.83 2009/11/26 00:12:31 kettenis Exp $	*/
a191 5
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_C032 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_C033 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_C034 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_C036 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_C042 },
d220 7
a226 2
	{ PCI_VENDOR_SCHNEIDERKOCH,	PCI_PRODUCT_SCHNEIDERKOCH_SK9Sxx },
	{ PCI_VENDOR_SCHNEIDERKOCH,	PCI_PRODUCT_SCHNEIDERKOCH_SK9Exx }
@


1.83
log
@Only re-initialise interfaces on suspend if they were IFF_RUNNING.

ok deraadt@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.82 2009/11/24 15:56:03 kettenis Exp $	*/
d215 1
a224 1
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8057 },
@


1.82
log
@Thoroughly reset the chip upon suspend and give the PHY a chance to
re-initialise itself afterward.

ok deraadt@@, mlarkin@@, claudio@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.81 2009/11/24 14:21:26 claudio Exp $	*/
d1050 1
d1060 2
a1061 1
		msk_init(sc_if);
@


1.81
log
@for MCLGETI to work correctly drivers need to first dequeue all available
packets and then refill the RX ring. When not done this way the rx ring can
not grow correctly. Tested by jmc@@, OK deraadt@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.80 2009/11/24 14:18:21 claudio Exp $	*/
d137 1
d143 1
d1047 20
d1402 19
d2175 2
a2176 1
	sizeof(struct sk_softc), mskc_probe, mskc_attach, mskc_detach
d2184 2
a2185 1
	sizeof(struct sk_if_softc), msk_probe, msk_attach, msk_detach
@


1.80
log
@msk_newbuf() had an off by one when putting the packet onto the cluster
and cleared the mbuf pointer of the next element, causing a mbuf leak.
While there also ensure that the valid bit of the first buffer is only set
when the full chain got assembled.
Tested by jmc@@, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.79 2009/10/15 17:54:56 deraadt Exp $	*/
d985 1
d1744 1
a1744 1
	int			claimed = 0;
d1782 1
a1784 3
			msk_fill_rx_ring(sc_if);
			SK_IF_WRITE_2(sc_if, 0,  SK_RXQ1_Y2_PREF_PUTIDX,
			    sc_if->sk_cdata.sk_rx_prod);
d1809 11
@


1.79
log
@Add detach support to a few more drivers, and in others do the neccessary
operations in the detach function in the right order.  Also ensure that the
interrupt handlers not trust registers that go away.
read over very carefully by dms, tested by me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.78 2009/10/04 18:32:02 deraadt Exp $	*/
d504 1
a504 1
	int			opcode, i;
d531 1
d535 12
a546 2
	opcode = SK_Y2_RXOPC_PACKET;
	for (i = 0; i < dmamap->dm_nsegs; i++) {
d550 3
a552 2
		r->sk_opcode = opcode | SK_Y2_RXOPC_OWN;
		opcode = SK_Y2_RXOPC_BUFFER;
d556 1
d558 3
a560 4
		c = &sc_if->sk_cdata.sk_rx_chain[sc_if->sk_cdata.sk_rx_prod];
		r = c->sk_le;
		c->sk_mbuf = NULL;
	}
d562 1
a562 1
	MSK_CDRXSYNC(sc_if, i, BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
@


1.78
log
@Correctly store the tag results from bus_dmamem_alloc() so that the
detach routine can free the right resources
ok dlg kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.77 2009/08/13 14:24:47 jasper Exp $	*/
d154 1
a154 1
void msk_stop(struct sk_if_softc *);
d615 1
a615 1
				msk_stop(sc_if);
d1006 4
a1009 1
	timeout_del(&sc_if->sk_tick_ch);
a1017 3
	if (sc_if->sk_sdhook != NULL)
		shutdownhook_disestablish(sc_if->sk_sdhook);

a1020 1
	bus_dmamap_destroy(sc->sc_dmatag, sc_if->sk_ring_map);
d1025 1
a1321 2
fail_5:
	bus_dmamap_destroy(sc->sc_dmatag, sc->sk_status_map);
d1329 2
d1345 3
a1359 3
	if (sc->sk_intrhand)
		pci_intr_disestablish(sc->sk_pc, sc->sk_intrhand);

d1736 2
d1938 1
a1938 1
	msk_stop(sc_if);
d1986 1
a1986 1
		msk_stop(sc_if);
d1994 1
a1994 1
		msk_stop(sc_if);
d2040 1
a2040 1
msk_stop(struct sk_if_softc *sc_if)
d2057 24
a2080 22
	/* Turn off various components of this interface. */
	SK_IF_WRITE_1(sc_if,0, SK_RXMF1_CTRL_TEST, SK_RFCTL_RESET_SET);
	SK_IF_WRITE_1(sc_if,0, SK_TXMF1_CTRL_TEST, SK_TFCTL_RESET_SET);
	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_OFFLINE);
	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);
	SK_IF_WRITE_4(sc_if, 1, SK_TXQA1_BMU_CSR, SK_TXBMU_OFFLINE);
	SK_IF_WRITE_4(sc_if, 1, SK_TXRBA1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);
	SK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL, SK_TXARCTL_OFF);
	SK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);
	SK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_TXLEDCTL_COUNTER_STOP);
	SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_OFF);
	SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_LINKSYNC_OFF);

	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_Y2_PREF_CSR, 0x00000001);
	SK_IF_WRITE_4(sc_if, 1, SK_TXQA1_Y2_PREF_CSR, 0x00000001);

	/* Disable interrupts */
	if (sc_if->sk_port == SK_PORT_A)
		sc->sk_intrmask &= ~SK_Y2_INTRS1;
	else
		sc->sk_intrmask &= ~SK_Y2_INTRS2;
	CSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);
d2089 4
@


1.77
log
@- consistify cfdriver for the ethernet drivers (0 -> NULL)

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.76 2009/08/09 11:40:56 deraadt Exp $	*/
d831 1
a831 2
	bus_dma_segment_t seg;
	int i, rseg;
d879 2
a880 1
	    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
d884 2
a885 1
	if (bus_dmamem_map(sc->sc_dmatag, &seg, rseg,
d991 1
a991 1
	bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
@


1.76
log
@MCLGETI() will now allocate a mbuf header if it is not provided, thus
reducing the amount of splnet/splx dancing required.. especially in the
worst case (of m_cldrop)
ok dlg kettenis damien
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.75 2009/03/29 14:36:34 jsg Exp $	*/
d2107 1
a2107 1
	0, "mskc", DV_DULL
d2115 1
a2115 1
	0, "msk", DV_IFNET
@


1.75
log
@Bypass macsec on extreme/supreme based chips.
Makes my 88E8072 work.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.74 2009/03/29 12:53:41 jsg Exp $	*/
d506 2
a507 2
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
a508 6

	MCLGETI(m, M_DONTWAIT, &sc_if->arpcom.ac_if, sc_if->sk_pktlen);
	if ((m->m_flags & M_EXT) == 0) {
		m_freem(m);
		return (ENOBUFS);
	}
@


1.74
log
@Remove holdover XMAC II writes/reads inherited from sk as
they aren't required and cause problems like the 88E8072
hard locking a system when enabling macsec bypass.

Tested on 8053/8072 by me and 8021 by kettenis.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.73 2009/03/27 10:16:17 jsg Exp $	*/
d700 5
@


1.73
log
@add definitions for more yukon 2 revisions found in linux driver
(which tend to be required to know which of the many bugs we will need
 to work around before each particular revision of hardware will
 actually work).
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.72 2009/03/23 21:58:54 kettenis Exp $	*/
a2055 1
	SK_XM_SETBIT_2(sc_if, XM_GPIO, XM_GPIO_RESETMAC);
a2076 3

	SK_XM_READ_2(sc_if, XM_ISR);
	SK_XM_WRITE_2(sc_if, XM_IMR, 0xFFFF);
@


1.72
log
@Switch msk(4) over to using MCLGETI when allocating mbufs for the RX ring.
This gets rid of one of the evil jumbo allocators!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.71 2009/03/23 21:34:20 kettenis Exp $	*/
d1249 16
d1269 20
@


1.71
log
@Prevent null pointer dereference that could happen when we process an RX
interrupt that was queued while stopping the interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.70 2009/03/16 12:47:35 deraadt Exp $	*/
d158 1
a158 4
int msk_newbuf(struct sk_if_softc *, int, struct mbuf *, bus_dmamap_t);
int msk_alloc_jumbo_mem(struct sk_if_softc *);
void *msk_jalloc(struct sk_if_softc *);
void msk_jfree(caddr_t, u_int, void *);
d161 1
d443 1
a443 10
	for (i = 0; i < MSK_RX_RING_CNT; i++) {
		if (msk_newbuf(sc_if, i, NULL,
		    sc_if->sk_cdata.sk_rx_jumbo_map) == ENOBUFS) {
			printf("%s: failed alloc of %dth mbuf\n",
			    sc_if->sk_dev.dv_xname, i);
			return (ENOBUFS);
		}
	}

	sc_if->sk_cdata.sk_rx_prod = MSK_RX_RING_CNT - 1;
d445 1
d447 1
d497 1
a497 2
msk_newbuf(struct sk_if_softc *sc_if, int i, struct mbuf *m,
	  bus_dmamap_t dmamap)
a498 1
	struct mbuf		*m_new = NULL;
d501 4
d506 3
a508 2
	if (m == NULL) {
		caddr_t buf = NULL;
d510 4
a513 25
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return (ENOBUFS);
		
		/* Allocate the jumbo buffer */
		buf = msk_jalloc(sc_if);
		if (buf == NULL) {
			m_freem(m_new);
			DPRINTFN(1, ("%s jumbo allocation failed -- packet "
			    "dropped!\n", sc_if->arpcom.ac_if.if_xname));
			return (ENOBUFS);
		}

		/* Attach the buffer to the mbuf */
		m_new->m_len = m_new->m_pkthdr.len = SK_JLEN;
		MEXTADD(m_new, buf, SK_JLEN, 0, msk_jfree, sc_if);
	} else {
		/*
	 	 * We're re-using a previously allocated mbuf;
		 * be sure to re-init pointers and lengths to
		 * default values.
		 */
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = SK_JLEN;
		m_new->m_data = m_new->m_ext.ext_buf;
d515 2
a516 1
	m_adj(m_new, ETHER_ALIGN);
d518 1
a518 9
	c = &sc_if->sk_cdata.sk_rx_chain[i];
	r = c->sk_le;
	c->sk_mbuf = m_new;
	r->sk_addr = htole32(dmamap->dm_segs[0].ds_addr +
	    (((vaddr_t)m_new->m_data
             - (vaddr_t)sc_if->sk_cdata.sk_jumbo_buf)));
	r->sk_len = htole16(SK_JLEN);
	r->sk_ctl = 0;
	r->sk_opcode = SK_Y2_RXOPC_PACKET | SK_Y2_RXOPC_OWN;
d520 6
a525 8
	MSK_CDRXSYNC(sc_if, i, BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);

	return (0);
}

/*
 * Memory management for jumbo frames.
 */
d527 3
a529 15
int
msk_alloc_jumbo_mem(struct sk_if_softc *sc_if)
{
	struct sk_softc		*sc = sc_if->sk_softc;
	caddr_t			ptr, kva;
	bus_dma_segment_t	seg;
	int		i, rseg, state, error;
	struct sk_jpool_entry   *entry;

	state = error = 0;

	/* Grab a big chunk o' storage. */
	if (bus_dmamem_alloc(sc->sc_dmatag, MSK_JMEM, PAGE_SIZE, 0,
			     &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
		printf(": can't alloc rx buffers");
d533 2
a534 27
	state = 1;
	if (bus_dmamem_map(sc->sc_dmatag, &seg, rseg, MSK_JMEM, &kva,
			   BUS_DMA_NOWAIT)) {
		printf(": can't map dma buffers (%d bytes)", MSK_JMEM);
		error = ENOBUFS;
		goto out;
	}

	state = 2;
	if (bus_dmamap_create(sc->sc_dmatag, MSK_JMEM, 1, MSK_JMEM, 0,
	    BUS_DMA_NOWAIT, &sc_if->sk_cdata.sk_rx_jumbo_map)) {
		printf(": can't create dma map");
		error = ENOBUFS;
		goto out;
	}

	state = 3;
	if (bus_dmamap_load(sc->sc_dmatag, sc_if->sk_cdata.sk_rx_jumbo_map,
			    kva, MSK_JMEM, NULL, BUS_DMA_NOWAIT)) {
		printf(": can't load dma map");
		error = ENOBUFS;
		goto out;
	}

	state = 4;
	sc_if->sk_cdata.sk_jumbo_buf = (caddr_t)kva;
	DPRINTFN(1,("msk_jumbo_buf = 0x%08X\n", sc_if->sk_cdata.sk_jumbo_buf));
d536 3
a538 2
	LIST_INIT(&sc_if->sk_jfree_listhead);
	LIST_INIT(&sc_if->sk_jinuse_listhead);
d540 14
a553 37
	/*
	 * Now divide it up into 9K pieces and save the addresses
	 * in an array.
	 */
	ptr = sc_if->sk_cdata.sk_jumbo_buf;
	for (i = 0; i < MSK_JSLOTS; i++) {
		sc_if->sk_cdata.sk_jslots[i] = ptr;
		ptr += SK_JLEN;
		entry = malloc(sizeof(struct sk_jpool_entry),
		    M_DEVBUF, M_NOWAIT);
		if (entry == NULL) {
			sc_if->sk_cdata.sk_jumbo_buf = NULL;
			printf(": no memory for jumbo buffer queue!");
			error = ENOBUFS;
			goto out;
		}
		entry->slot = i;
		LIST_INSERT_HEAD(&sc_if->sk_jfree_listhead,
				 entry, jpool_entries);
	}
out:
	if (error != 0) {
		switch (state) {
		case 4:
			bus_dmamap_unload(sc->sc_dmatag,
			    sc_if->sk_cdata.sk_rx_jumbo_map);
		case 3:
			bus_dmamap_destroy(sc->sc_dmatag,
			    sc_if->sk_cdata.sk_rx_jumbo_map);
		case 2:
			bus_dmamem_unmap(sc->sc_dmatag, kva, MSK_JMEM);
		case 1:
			bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
			break;
		default:
			break;
		}
d556 1
a556 2
	return (error);
}
d558 1
a558 47
/*
 * Allocate a jumbo buffer.
 */
void *
msk_jalloc(struct sk_if_softc *sc_if)
{
	struct sk_jpool_entry   *entry;

	entry = LIST_FIRST(&sc_if->sk_jfree_listhead);

	if (entry == NULL)
		return (NULL);

	LIST_REMOVE(entry, jpool_entries);
	LIST_INSERT_HEAD(&sc_if->sk_jinuse_listhead, entry, jpool_entries);
	return (sc_if->sk_cdata.sk_jslots[entry->slot]);
}

/*
 * Release a jumbo buffer.
 */
void
msk_jfree(caddr_t buf, u_int size, void	*arg)
{
	struct sk_jpool_entry *entry;
	struct sk_if_softc *sc;
	int i;

	/* Extract the softc struct pointer. */
	sc = (struct sk_if_softc *)arg;

	if (sc == NULL)
		panic("msk_jfree: can't find softc pointer!");

	/* calculate the slot this buffer belongs to */
	i = ((vaddr_t)buf
	     - (vaddr_t)sc->sk_cdata.sk_jumbo_buf) / SK_JLEN;

	if ((i < 0) || (i >= MSK_JSLOTS))
		panic("msk_jfree: asked to free buffer that we don't manage!");

	entry = LIST_FIRST(&sc->sk_jinuse_listhead);
	if (entry == NULL)
		panic("msk_jfree: buffer not in use!");
	entry->slot = i;
	LIST_REMOVE(entry, jpool_entries);
	LIST_INSERT_HEAD(&sc->sk_jfree_listhead, entry, jpool_entries);
d836 1
d905 14
a918 4
	/* Try to allocate memory for jumbo buffers. */
	if (msk_alloc_jumbo_mem(sc_if)) {
		printf(": jumbo buffer allocation failed\n");
		goto fail_3;
d979 7
d1538 1
a1538 1
	int			cur, total_len = len;
a1543 2
	SK_INC(sc_if->sk_cdata.sk_rx_cons, MSK_RX_RING_CNT);
	SK_INC(sc_if->sk_cdata.sk_rx_prod, MSK_RX_RING_CNT);
d1552 6
a1557 1
	dmamap = sc_if->sk_cdata.sk_rx_jumbo_map;
d1560 1
d1569 1
a1569 1
		msk_newbuf(sc_if, cur, m, dmamap);
d1573 2
a1574 20
	/*
	 * Try to allocate a new jumbo buffer. If that fails, copy the
	 * packet to mbufs and put the jumbo buffer back in the ring
	 * so it can be re-used. If allocating mbufs fails, then we
	 * have to drop the packet.
	 */
	if (msk_newbuf(sc_if, cur, NULL, dmamap) == ENOBUFS) {
		struct mbuf		*m0;
		m0 = m_devget(mtod(m, char *), total_len, ETHER_ALIGN,
		    ifp, NULL);
		msk_newbuf(sc_if, cur, m, dmamap);
		if (m0 == NULL) {
			ifp->if_ierrors++;
			return;
		}
		m = m0;
	} else {
		m->m_pkthdr.rcvif = ifp;
		m->m_pkthdr.len = m->m_len = total_len;
	}
d1646 9
d1733 1
@


1.70
log
@88E8057 is a Yukon 2 Ultra 2, and this might make it work on a little
shiny green box in Japan
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.69 2009/02/22 16:40:13 kettenis Exp $	*/
d1675 3
a1678 1

@


1.69
log
@Make Yukon-2 FE+ (88E8040, 88E8042) work.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.68 2008/11/28 02:44:18 brad Exp $	*/
d224 1
d943 1
d1161 1
a1161 1
		printf("sk port %c at %s",
d1322 3
@


1.68
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.67 2008/10/14 18:01:53 naddy Exp $	*/
d332 2
a333 1
	if (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO) {
d1257 2
a1258 1
	    MSK_STATUS_RING_CNT * sizeof(struct msk_status_desc), PAGE_SIZE,
d1813 1
d1852 2
a1853 2
			msk_rxeof(sc->sk_if[cur_st->sk_link],
			    letoh16(cur_st->sk_len),
d1855 2
a1856 3
			SK_IF_WRITE_2(sc->sk_if[cur_st->sk_link], 0,
			    SK_RXQ1_Y2_PREF_PUTIDX,
			    sc->sk_if[cur_st->sk_link]->sk_cdata.sk_rx_prod);
@


1.67
log
@Change m_devget()'s outdated and unused "offset" argument:  It is
now the offset into the first mbuf of the target chain before copying
the source data over.  From FreeBSD.

Convert drivers' use of m_devget().  Mostly from thib@@.

Update mbuf(9) man page.

ok claudio@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.66 2008/10/02 20:21:14 brad Exp $	*/
d730 1
a731 1
	struct ifaddr *ifa = (struct ifaddr *) data;
d747 1
a747 6
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ifp->if_hardmtu)
			error = EINVAL;
		else if (ifp->if_mtu != ifr->ifr_mtu)
			ifp->if_mtu = ifr->ifr_mtu;
		break;
d765 1
a765 16
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc_if->arpcom) :
		    ether_delmulti(ifr, &sc_if->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				msk_setmulti(sc_if);
			error = 0;
		}
		break;
d771 1
d774 6
@


1.66
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.65 2008/09/10 14:01:22 blambert Exp $	*/
d1705 2
a1706 2
		m0 = m_devget(mtod(m, char *) - ETHER_ALIGN,
		    total_len + ETHER_ALIGN, 0, ifp, NULL);
a1711 1
		m_adj(m0, ETHER_ALIGN);
@


1.65
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.64 2008/06/21 21:15:20 brad Exp $	*/
a736 5
	if ((error = ether_ioctl(ifp, &sc_if->arpcom, command, data)) > 0) {
		splx(s);
		return (error);
	}

d792 1
a792 2
		error = ENOTTY;
		break;
a795 1

@


1.64
log
@add Marvell Yukon PCI id for the 88E8040T chipset.

From Linux sky2/Marvell sk98lin drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.63 2008/05/23 08:49:27 brad Exp $	*/
d1805 1
a1805 1
	timeout_add(&sc_if->sk_tick_ch, hz);
d2136 1
a2136 1
	timeout_add(&sc_if->sk_tick_ch, hz);
@


1.63
log
@Simplify the combination use of pci_mapreg_type()/pci_mapreg_map() as
suggested by dlg@@ awhile ago.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.62 2008/03/02 19:16:43 brad Exp $	*/
d206 1
@


1.62
log
@Change some spaces to tabs in the transmit functions.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.61 2008/02/03 21:20:23 brad Exp $	*/
a1236 1

d1238 2
a1239 7
	switch (memtype) {
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
		if (pci_mapreg_map(pa, SK_PCI_LOMEM, memtype, 0, &sc->sk_btag,
		    &sc->sk_bhandle, NULL, &sc->sk_bsize, 0) == 0)
			break;
	default:
@


1.61
log
@- add Marvell Yukon PCI ids for a second 88E8055 chipset and the 88E8075 chipset.
- add initial support for the Marvell Yukon Supreme ASIC.

Inspired by similar changes to the Linux sky2 driver.

ok kettenis@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.60 2007/11/25 00:27:44 kettenis Exp $	*/
d1573 3
a1575 3
        struct sk_if_softc	*sc_if = ifp->if_softc;
        struct mbuf		*m_head = NULL;
        u_int32_t		idx = sc_if->sk_cdata.sk_tx_prod;
@


1.60
log
@Make msk(4) detachable.

"can't be wrong" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.59 2007/11/14 10:00:47 brad Exp $	*/
d212 1
d222 1
d959 1
d1340 3
@


1.59
log
@add the Marvell 88E8042 and 88E8072 PCI ids.

From the Linux sky2 driver.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.58 2007/10/02 07:35:55 brad Exp $	*/
d136 1
d141 1
d982 1
a982 1
	struct sk_if_softc *sc_if = (struct sk_if_softc *) self;
d1118 1
a1118 1
	shutdownhook_establish(mskc_shutdown, sc);
d1134 35
a1194 1
	bus_size_t size;
a1197 2
	bus_dma_segment_t seg;
	int rseg;
d1239 2
a1240 3
		if (pci_mapreg_map(pa, SK_PCI_LOMEM,
				   memtype, 0, &sc->sk_btag, &sc->sk_bhandle,
				   NULL, &size, 0) == 0)
d1275 1
d1278 2
a1279 2
	    MSK_STATUS_RING_CNT * sizeof(struct msk_status_desc),
	    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
d1284 2
a1285 1
	if (bus_dmamem_map(sc->sc_dmatag, &seg, rseg,
d1425 1
a1425 1
	bus_dmamem_unmap(sc->sc_dmatag, kva, 
d1428 3
a1430 1
	bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
d1432 2
a1433 1
	pci_intr_disestablish(pc, sc->sk_intrhand);
d1435 29
a1463 1
	bus_space_unmap(sc->sk_btag, sc->sk_bhandle, size);
d2211 1
a2211 1
	sizeof(struct sk_softc), mskc_probe, mskc_attach,
d2219 1
a2219 1
	sizeof(struct sk_if_softc), msk_probe, msk_attach,
@


1.58
log
@add initial support for the Marvell PCIe Yukon FE+ Fast Ethernet chipsets.

Inspired by similar changes to the Linux sky2 driver.

Tested by dunceor, Schoeberle Daniel, moritz@@ and brad@@ on existing
known working adapters. These chipsets are not actually available
in hardware yet.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.57 2007/09/17 08:46:52 brad Exp $	*/
d204 1
d218 1
@


1.57
log
@Remove an unused function msk_setfilt() which was copied from sk(4) and is
not of use to the Yukon chipsets.

ok kettenis@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.56 2007/06/27 19:15:47 kettenis Exp $	*/
d203 2
d952 1
d1068 2
a1069 1
	if (sc->sk_type != SK_YUKON_FE)
d1298 3
d1894 2
a1895 1
	if (sc->sk_type != SK_YUKON_FE)
@


1.56
log
@Shrink code by not using __inline without static; like we did for sk(4).

From brad at comstyle dot com.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.55 2007/06/01 04:35:28 kettenis Exp $	*/
a166 1
void msk_setfilt(struct sk_if_softc *, caddr_t, int);
a351 10
}

void
msk_setfilt(struct sk_if_softc *sc_if, caddr_t addr, int slot)
{
	int base = XM_RXFILT_ENTRY(slot);

	SK_XM_WRITE_2(sc_if, base, *(u_int16_t *)(&addr[0]));
	SK_XM_WRITE_2(sc_if, base + 2, *(u_int16_t *)(&addr[2]));
	SK_XM_WRITE_2(sc_if, base + 4, *(u_int16_t *)(&addr[4]));
@


1.55
log
@Only probe phy's at address 0; gets rid of bogus phy's on the
Marvell Yukon 88E8036.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.54 2007/05/26 16:44:21 reyk Exp $	*/
d144 1
a144 1
__inline int msk_rxvalid(struct sk_softc *, u_int32_t, u_int32_t);
d1590 1
a1590 1
__inline int
@


1.54
log
@separate the attach information from the status information with a colon.

suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.53 2007/05/22 04:30:55 ray Exp $	*/
d1103 1
a1103 1
	mii_attach(self, &sc_if->sk_mii, 0xffffffff, MII_PHY_ANY,
@


1.53
log
@%z in printf(9) is not the same as %z in printf(3).  Change to %lu
and cast arg to ulong.

OK miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.52 2007/05/14 15:28:45 jsg Exp $	*/
d1015 1
a1015 1
	printf(", address %s\n",
@


1.52
log
@Properly wrap mii_tick() up in splnet().
This seems to fix a bizzare problem I was having for some time with msk on
MP amd64 where the machine would reboot itself under load.
At least sk(4) and rl(4) code seems to have the potential for a similiar problem.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.51 2007/05/12 18:19:54 kettenis Exp $	*/
d1045 2
a1046 2
		printf(": can't map dma buffers (%z bytes)\n",
		       sizeof(struct msk_ring_data));
d1258 2
a1259 2
		printf(": can't map dma buffers (%z bytes)\n",
		    MSK_STATUS_RING_CNT * sizeof(struct msk_status_desc));
@


1.51
log
@Take alignment restrictions into account when setting up RAM buffer addresses.
This makes Yukon-2 FE chips work reliably.
Pointed out by giovanni at gmail dot com.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.50 2007/02/26 04:00:25 todd Exp $	*/
d1735 1
d1737 1
d1739 1
@


1.50
log
@This fixes the function names printed in the panic strings so that
the correct function names are being used, this is msk(4), not sk(4).
from brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.49 2007/02/13 20:10:33 kettenis Exp $	*/
d993 1
a993 1
	u_int32_t chunk, val;
d1019 5
a1023 9
	 * Set up RAM buffer addresses. The NIC will have a certain
	 * amount of SRAM on it, somewhere between 512K and 2MB. We
	 * need to divide this up a) between the transmitter and
 	 * receiver and b) between the two XMACs, if this is a
	 * dual port NIC. Our algorithm is to divide up the memory
	 * evenly so that everyone gets a fair share.
	 *
	 * Just to be contrary, Yukon2 appears to have separate memory
	 * for each MAC.
d1025 6
a1030 9
	chunk = sc->sk_ramsize  - (sc->sk_ramsize + 2) / 3;
	val = sc->sk_rboff / sizeof(u_int64_t);
	sc_if->sk_rx_ramstart = val;
	val += (chunk / sizeof(u_int64_t));
	sc_if->sk_rx_ramend = val - 1;
	chunk = sc->sk_ramsize - chunk;
	sc_if->sk_tx_ramstart = val;
	val += (chunk / sizeof(u_int64_t));
	sc_if->sk_tx_ramend = val - 1;
d1164 1
a1164 1
	u_int8_t hw, pmd, skrs;
d1282 2
a1283 10
	skrs = sk_win_read_1(sc, SK_EPROM0);
	if (skrs == 0x00)
		sc->sk_ramsize = 0x20000;
	else
		sc->sk_ramsize = skrs * (1<<12);
	sc->sk_rboff = SK_RBOFF_0;

	DPRINTFN(2, ("mskc_attach: ramsize=%d (%dk), rboff=%d\n",
		     sc->sk_ramsize, sc->sk_ramsize / 1024,
		     sc->sk_rboff));
@


1.49
log
@Fix typo.  Spotted by brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.48 2007/02/12 21:28:23 kettenis Exp $	*/
d686 1
a686 1
		panic("sk_jfree: can't find softc pointer!");
d693 1
a693 1
		panic("sk_jfree: asked to free buffer that we don't manage!");
@


1.48
log
@Avoid unnecessary resets.  This should make fiber 88E8021/22 work completely.
tested by jsg@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.47 2007/02/11 22:16:21 kettenis Exp $	*/
d1109 1
a1109 1
		mii_flags = MIIF_HAVEFIBER;
@


1.47
log
@Add support for fiber on 88E8021/22.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.46 2007/02/10 23:19:34 kettenis Exp $	*/
d136 1
d140 1
a155 1
void msk_reset(struct sk_softc *);
d822 2
a823 1
void msk_reset(struct sk_softc *sc)
d828 1
a828 1
	DPRINTFN(2, ("msk_reset\n"));
d865 2
a866 2
	DPRINTFN(2, ("sk_reset: sk_csr=%x\n", CSR_READ_1(sc, SK_CSR)));
	DPRINTFN(2, ("msk_reset: sk_link_ctrl=%x\n",
d967 12
d1091 2
d1107 1
a1107 1
	mii_flags = MIIF_DOPAUSE|MIIF_FORCEANEG;
d1287 1
a1287 1
	msk_reset(sc);
d1582 2
a1583 1
		msk_reset(sc_if->sk_softc);
d1602 1
a1602 1
	msk_reset(sc);
a1869 11

	/* GMAC and GPHY Reset */
	SK_IF_WRITE_4(sc_if, 0, SK_GMAC_CTRL, SK_GMAC_RESET_SET);
	SK_IF_WRITE_4(sc_if, 0, SK_GPHY_CTRL, SK_GPHY_RESET_SET);
	DELAY(1000);

	DPRINTFN(6, ("msk_init_yukon: 2\n"));

	SK_IF_WRITE_4(sc_if, 0, SK_GPHY_CTRL, SK_GPHY_RESET_CLEAR);
	SK_IF_WRITE_4(sc_if, 0, SK_GMAC_CTRL, SK_GMAC_LOOP_OFF |
		      SK_GMAC_PAUSE_ON | SK_GMAC_RESET_CLEAR);
@


1.46
log
@Adjust for new/renamed DLink card & Marvell chips.  Based on a diff by brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.45 2007/02/10 22:49:46 kettenis Exp $	*/
d980 1
d1091 3
d1095 1
a1095 1
	    MII_OFFSET_ANY, MIIF_DOPAUSE|MIIF_FORCEANEG);
d1155 1
a1155 1
	u_int8_t hw, skrs;
d1283 4
@


1.45
log
@Add preliminary support for Marvell Yukon-II Extreme chips.
Based on a diff from brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.44 2007/02/10 02:27:56 krw Exp $	*/
d187 1
a189 1
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_1 },
d195 4
d208 7
a214 8
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKONII_8021CU },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKONII_8021X },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKONII_8022CU },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKONII_8022X },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKONII_8061CU },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKONII_8061X },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKONII_8062CU },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKONII_8062X },
@


1.44
log
@Move HASH_BITS constant to if_skreg.h as SK_HASH_BITS.  Remove unused
code and an unnecessary comment, No functional change.

From brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.43 2007/02/03 12:50:26 kettenis Exp $	*/
d953 1
d1283 3
@


1.43
log
@Fix typo; clear tx FIFO underrun IRQ as intended instead of rx FIFO overrun
IRQ.  From brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.42 2007/01/17 02:43:02 krw Exp $	*/
a350 2
#define HASH_BITS	6
  
d393 1
a393 1
			    ((1 << HASH_BITS) - 1);
@


1.42
log
@Remove some textual sk heritage warts by renaming some functions and
eliminating a one line called once function by inserting its code
inline.

No functional change.

From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.41 2007/01/13 21:05:55 kettenis Exp $	*/
d1738 1
a1738 1
		SK_IF_WRITE_1(sc_if, 0, SK_RXMF1_CTRL_TEST,
@


1.41
log
@Correctly count outbound packets.

From brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.40 2007/01/08 20:32:34 kettenis Exp $	*/
d162 3
a164 3
int msk_marv_miibus_readreg(struct device *, int, int);
void msk_marv_miibus_writereg(struct device *, int, int, int);
void msk_marv_miibus_statchg(struct device *);
a165 1
u_int32_t msk_yukon_hash(caddr_t);
d169 1
a169 1
void msk_yukon_tick(void *);
d253 1
a253 1
msk_marv_miibus_readreg(struct device *dev, int phy, int reg)
d275 1
a275 1
 	DPRINTFN(9, ("msk_marv_miibus_readreg: i=%d, timeout=%d\n", i,
d280 1
a280 1
	DPRINTFN(9, ("msk_marv_miibus_readreg phy=%d, reg=%#x, val=%#x\n",
d287 1
a287 1
msk_marv_miibus_writereg(struct device *dev, int phy, int reg, int val)
d292 1
a292 1
	DPRINTFN(9, ("msk_marv_miibus_writereg phy=%d reg=%#x val=%#x\n",
d310 1
a310 1
msk_marv_miibus_statchg(struct device *dev)
d347 1
a347 1
	DPRINTFN(9, ("msk_marv_miibus_statchg: gpcr=%x\n",
a352 9
u_int32_t
msk_yukon_hash(caddr_t addr)
{
	u_int32_t crc;

	crc = ether_crc32_be(addr, ETHER_ADDR_LEN);
	return (crc & ((1 << HASH_BITS) - 1));
}

d394 2
a395 1
			h = msk_yukon_hash(enm->enm_addrlo);
d1082 3
a1084 3
	sc_if->sk_mii.mii_readreg = msk_marv_miibus_readreg;
	sc_if->sk_mii.mii_writereg = msk_marv_miibus_writereg;
	sc_if->sk_mii.mii_statchg = msk_marv_miibus_statchg;
d1098 1
a1098 1
	timeout_set(&sc_if->sk_tick_ch, msk_yukon_tick, sc_if);
d1716 1
a1716 1
msk_yukon_tick(void *xsc_if)
@


1.40
log
@No need to re-init on every media change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.39 2007/01/03 11:49:16 krw Exp $	*/
d1692 1
a1692 1
		sk_ctl = letoh32(cur_tx->sk_ctl);
d1697 1
a1697 1
		if (sk_ctl & SK_TXCTL_LASTFRAG)
@


1.39
log
@Don't say 'Marvell' twice for each sk/msk device in dmesg. No functional
change.

from brad@@ ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.38 2006/12/30 22:08:15 kettenis Exp $	*/
a717 1
	msk_init(sc_if);
@


1.38
log
@Enable jumbo frames (except on the Yukon-2 FE).

From brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.37 2006/12/30 20:39:09 kettenis Exp $	*/
d1290 1
a1290 1
		sc->sk_name = "Marvell Yukon-2 XL";
d1293 1
a1293 1
		sc->sk_name = "Marvell Yukon-2 EC Ultra";
d1296 1
a1296 1
		sc->sk_name = "Marvell Yukon-2 EC";
d1299 1
a1299 1
		sc->sk_name = "Marvell Yukon-2 FE";
d1302 1
a1302 1
		sc->sk_name = "Marvell Yukon (Unknown)";
@


1.37
log
@Pass MIIF_FORCEANEG to mii_attack() until we stop doing unnecessary PHY
hardware resets.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.36 2006/12/28 16:34:42 kettenis Exp $	*/
d1076 2
a1077 3
#ifdef notyet
	ifp->if_hardmtu = SK_JUMBO_MTU;
#endif
d1897 8
a1904 3
	SK_YU_WRITE_2(sc_if, YUKON_SMR, YU_SMR_DATA_BLIND(0x1c) |
		      YU_SMR_MFL_VLAN | YU_SMR_MFL_JUMBO |
		      YU_SMR_IPG_DATA(0x1e));
@


1.36
log
@Remove useless code dealing with media type.  Simplify PHY reset code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.35 2006/12/28 10:22:07 kettenis Exp $	*/
d1100 1
a1100 1
	    MII_OFFSET_ANY, MIIF_DOPAUSE);
@


1.35
log
@Pass MIIF_DOPAUSE to mii_attach().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.34 2006/12/24 22:56:48 kettenis Exp $	*/
a1288 8
	/* Read and save physical media type */
	sc->sk_pmd = sk_win_read_1(sc, SK_PMDTYPE);

	if (!(sc->sk_pmd == 'L' || sc->sk_pmd == 'S'))
		sc->sk_coppertype = 1;
	else
		sc->sk_coppertype = 0;

d1840 1
a1840 1
	u_int32_t		phy, v;
d1853 1
a1854 1
	SK_IF_WRITE_4(sc_if, 0, SK_GMAC_CTRL, SK_GMAC_RESET_SET);
d1859 1
a1859 17
#if 0
	phy = SK_GPHY_INT_POL_HI | SK_GPHY_DIS_FC | SK_GPHY_DIS_SLEEP |
		SK_GPHY_ENA_XC | SK_GPHY_ANEG_ALL | SK_GPHY_ENA_PAUSE;
#else
	phy = SK_GPHY_ENA_PAUSE;
#endif

	if (sc->sk_coppertype)
		phy |= SK_GPHY_COPPER;
	else
		phy |= SK_GPHY_FIBER;

	DPRINTFN(3, ("msk_init_yukon: phy=%#x\n", phy));

	SK_IF_WRITE_4(sc_if, 0, SK_GPHY_CTRL, phy | SK_GPHY_RESET_SET);
	DELAY(1000);
	SK_IF_WRITE_4(sc_if, 0, SK_GPHY_CTRL, phy | SK_GPHY_RESET_CLEAR);
@


1.34
log
@Make non-autonegotiated 10baseT and 100baseTX work.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.33 2006/12/24 14:34:27 kettenis Exp $	*/
d1100 1
a1100 1
	    MII_OFFSET_ANY, 0);
@


1.33
log
@In msk_marv_miibus_writereg, wait for busy flag to clear instead of
continuing when busy flag set.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.32 2006/12/16 20:19:34 kettenis Exp $	*/
d313 35
@


1.32
log
@Enable RAM buffer for the second port too; makes dual port cards work so
reenable attachment of the second port on cards that have it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.31 2006/12/16 19:15:35 kettenis Exp $	*/
d302 1
a302 1
		if (SK_YU_READ_2(sc_if, YUKON_SMICR) & YU_SMICR_BUSY)
@


1.31
log
@Process status descriptors for port B.  Fix two typos while I'm there.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.30 2006/12/15 20:37:34 kettenis Exp $	*/
d863 3
a1335 1
#if notyet
a1340 1
#endif
@


1.30
log
@Process status descriptors that have SK_Y2_STOPC_OWN bit set instead of
looking at SK_STAT_BMU_PUTIDX; makes Yukon-2 XL rev. A3 work.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.29 2006/12/12 20:48:11 mk Exp $	*/
d1646 1
a1646 1
	u_int32_t		idx, sk_ctl;
d1651 5
d1661 1
a1661 1
	while (idx != sk_win_read_2(sc, SK_STAT_BMU_TXA1_RIDX)) {
d1778 4
a1781 1
			msk_txeof(sc->sk_if[cur_st->sk_link]);
d1926 1
a1926 1
	SK_IF_WRITE_2(sc_if, 0, SK_RXMF1_CTRL_TEST, SK_TFCTL_OPERATION_ON |
d2090 1
a2090 1
	SK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);
@


1.29
log
@Clarifying a few pcidevs entry names based on names found
in a much more recent Marvell Linux sk98lin driver.

From brad@@.

ok me and kettenis (via mglocker)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.28 2006/12/08 02:13:36 gwk Exp $	*/
a1731 1
	u_int16_t		idx;
d1757 7
a1763 7
	idx = CSR_READ_2(sc, SK_STAT_BMU_PUTIDX);
	while (sc->sk_status_idx != idx) {
		MSK_CDSTSYNC(sc, sc->sk_status_idx,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);

		cur_st = &sc->sk_status_ring[sc->sk_status_idx];
		switch (cur_st->sk_opcode & ~SK_Y2_STOPC_OWN) {
d1780 4
a1783 1
		idx = CSR_READ_2(sc, SK_STAT_BMU_PUTIDX);
@


1.28
log
@Add the Broadcom BCM5787F PCI id.
Add D-Link DGE-560SX and another Marvell Yukon (unknown model) PCI ids.
From the Linux sky2 driver via brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.27 2006/12/06 23:34:45 reyk Exp $	*/
d191 5
a195 6
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_2 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_3 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_4 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_5 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_6 },
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_7 },
d199 1
@


1.27
log
@- Move TX ring full sanity check further up and check the number of DMA
segments from the DMA map, instead of counting the DMA segments in the
for loop and breaking out later.
- Unload the DMA map if encountering an error condition.

Tested on amd64/i386/sparc64

ok brad@@ mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.26 2006/11/25 16:26:17 brad Exp $	*/
d188 1
d196 1
@


1.26
log
@remove some sk(4) specific media handling code.

ok kettenis@@

Tested with Yukon-2 EC and Yukon-2 XL.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.25 2006/11/23 22:02:57 kettenis Exp $	*/
a1327 1

d1374 1
a1374 1
	u_int32_t		frag, cur, cnt = 0;
d1406 6
a1418 4
		if ((MSK_TX_RING_CNT - (sc_if->sk_cdata.sk_tx_cnt + cnt)) < 2) {
			DPRINTFN(2, ("msk_encap: too few descriptors free\n"));
			return (ENOBUFS);
		}
d1423 1
a1423 1
		if (cnt == 0)
a1428 1
		cnt++;
d1447 1
a1447 1
	sc_if->sk_cdata.sk_tx_cnt += cnt;
@


1.25
log
@Do not attach second port on dual port cards for now.
This makes the first port work.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.24 2006/11/23 21:56:32 kettenis Exp $	*/
d1252 1
a1252 3
	if (sc->sk_pmd == 'T' || sc->sk_pmd == '1' ||
	    (SK_IS_YUKON2(sc) && !(sc->sk_pmd == 'L' ||
	    sc->sk_pmd == 'S')))
@


1.24
log
@Set some more power management bits; makes Yukon-2 XL work somewhat.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.23 2006/11/17 19:34:34 kettenis Exp $	*/
d1334 1
d1340 1
@


1.23
log
@Remove code that deals with sk(4) specific phy's that breaks certain msk(4)
variants.

tested by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.22 2006/11/16 03:25:45 brad Exp $	*/
d795 1
a795 1
	u_int32_t imtimer_ticks;
a801 1
	CSR_WRITE_2(sc, SK_LINK_CTRL, SK_LINK_RESET_SET);
d807 23
d831 3
@


1.22
log
@when checking for an appropriate revision of chipset use SK_IS_YUKON2
instead of SK_IS_YUKON.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.21 2006/09/27 02:27:04 brad Exp $	*/
a257 8
	if (phy != 0 ||
	    (sc_if->sk_phytype != SK_PHYTYPE_MARV_COPPER &&
	     sc_if->sk_phytype != SK_PHYTYPE_MARV_FIBER)) {
		DPRINTFN(9, ("msk_marv_miibus_readreg (skip) phy=%d, reg=%#x\n",
			     phy, reg));
		return (0);
	}

a970 17

	/* Read and save PHY type */
	sc_if->sk_phytype = sk_win_read_1(sc, SK_EPROM1) & 0xF;

	/* Set PHY address */
	if ((sc_if->sk_phytype < SK_PHYTYPE_MARV_COPPER &&
	     sc->sk_pmd != 'L' && sc->sk_pmd != 'S')) {
		/* not initialized, punt */
		sc_if->sk_phytype = SK_PHYTYPE_MARV_COPPER;

		sc->sk_coppertype = 1;
	}

	sc_if->sk_phyaddr = SK_PHYADDR_MARV;

	if (!(sc->sk_coppertype))
		sc_if->sk_phytype = SK_PHYTYPE_MARV_FIBER;
@


1.21
log
@fix the use of LIST_INSERT_HEAD in [m]sk_alloc_jumbo_mem().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.20 2006/09/26 19:37:28 brad Exp $	*/
d1181 1
a1181 1
	if (!(SK_IS_YUKON(sc))) {
@


1.20
log
@Set sk_jumbo_buf to NULL if malloc() fails in the for loop within
[m]sk_alloc_jumbo_mem().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.19 2006/09/25 23:26:36 brad Exp $	*/
d607 1
a607 5
		if (i)
			LIST_INSERT_HEAD(&sc_if->sk_jfree_listhead,
				 entry, jpool_entries);
		else
			LIST_INSERT_HEAD(&sc_if->sk_jinuse_listhead,
a666 1

@


1.19
log
@add the new PCI ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.18 2006/09/22 13:06:15 brad Exp $	*/
d601 1
@


1.18
log
@add the Marvell Yukon 88E8056 PCI id
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.17 2006/09/16 01:20:26 jsg Exp $	*/
d187 1
d189 6
@


1.17
log
@Asking for HWERR interrupts and not acknowledging them leads
to interrupt storms on several machines, so don't ask.

Diff from kettenis@@ who can't commit at the moment.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.16 2006/08/25 00:21:10 brad Exp $	*/
d194 2
a203 1
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_3 },
@


1.16
log
@Allow the driver to compile with MSK_DEBUG.

From riz@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.15 2006/08/20 07:04:12 brad Exp $	*/
d2035 1
a2035 1
	sc->sk_intrmask |= SK_Y2_IMR_HWERR | SK_Y2_IMR_BMU;
a2036 2

	CSR_WRITE_4(sc, SK_IEMR, 0x2e00003f);
@


1.15
log
@sort PCI ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.14 2006/08/19 21:33:57 brad Exp $	*/
d1389 1
a1389 1
		sk_dump_mbuf(m_head);
@


1.14
log
@remove another Yukon Lite workaround.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.13 2006/08/19 21:16:22 kettenis Exp $	*/
d191 1
a192 1
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKON_8050 },
d195 1
a196 1
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKONII_8021X },
d199 1
a200 1
	{ PCI_VENDOR_MARVELL,		PCI_PRODUCT_MARVELL_YUKONII_8061X },
@


1.13
log
@Make sure Rx timestamps are disabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.12 2006/08/19 04:03:22 brad Exp $	*/
a1907 5
	/* Disable RX MAC FIFO Flush for YUKON-Lite Rev. A0 only */
	if (sc->sk_type == SK_YUKON_LITE && sc->sk_rev == SK_YUKON_LITE_REV_A0)
		v = SK_TFCTL_OPERATION_ON;
	else
		v = SK_TFCTL_OPERATION_ON | SK_RFCTL_FIFO_FLUSH_ON;
d1910 2
a1911 1
	SK_IF_WRITE_2(sc_if, 0, SK_RXMF1_CTRL_TEST, v);
@


1.12
log
@set the capabilities VLAN MTU flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.11 2006/08/17 22:07:40 brad Exp $	*/
d831 4
@


1.11
log
@remove more unused code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.10 2006/08/17 21:56:42 brad Exp $	*/
a1034 1
#ifdef notyet
a1035 1
#endif
@


1.10
log
@remove the Yukon Lite workaround which is not being used in the msk(4) driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.9 2006/08/17 21:37:44 brad Exp $	*/
d922 1
d957 9
a965 13
	{
		u_int32_t		chunk, val;

		chunk = sc->sk_ramsize  - (sc->sk_ramsize + 2) / 3;
		val = sc->sk_rboff / sizeof(u_int64_t);
		sc_if->sk_rx_ramstart = val;
		val += (chunk / sizeof(u_int64_t));
		sc_if->sk_rx_ramend = val - 1;
		chunk = sc->sk_ramsize - chunk;
		sc_if->sk_tx_ramstart = val;
		val += (chunk / sizeof(u_int64_t));
		sc_if->sk_tx_ramend = val - 1;
	}
d1114 1
a1114 1
	u_int8_t skrs;
d1175 1
a1175 1
	if (! SK_IS_YUKON(sc)) {
a1253 9
	case SK_YUKON:
		sc->sk_name = "Marvell Yukon";
		break;
	case SK_YUKON_LITE:
		sc->sk_name = "Marvell Yukon Lite";
		break;
	case SK_YUKON_LP:
		sc->sk_name = "Marvell Yukon LP";
		break;
a1269 36
	/* Yukon Lite Rev A0 needs special test, from sk98lin driver */
	if (sc->sk_type == SK_YUKON || sc->sk_type == SK_YUKON_LP) {
		u_int32_t flashaddr;
		u_int8_t testbyte;

		flashaddr = sk_win_read_4(sc, SK_EP_ADDR);

		/* test Flash-Address Register */
		sk_win_write_1(sc, SK_EP_ADDR+3, 0xff);
		testbyte = sk_win_read_1(sc, SK_EP_ADDR+3);

		if (testbyte != 0) {
			/* This is a Yukon Lite Rev A0 */
			sc->sk_type = SK_YUKON_LITE;
			sc->sk_rev = SK_YUKON_LITE_REV_A0;
			/* restore Flash-Address Register */
			sk_win_write_4(sc, SK_EP_ADDR, flashaddr);
		}
	}

	if (sc->sk_type == SK_YUKON_LITE) {
		switch (sc->sk_rev) {
		case SK_YUKON_LITE_REV_A0:
			revstr = "A0";
			break;
		case SK_YUKON_LITE_REV_A1:
			revstr = "A1";
			break;
		case SK_YUKON_LITE_REV_A3:
			revstr = "A3";
			break;
		default:
			;
		}
	}

d1327 4
a1330 11
	if (SK_IS_YUKON2(sc)) {
		u_int8_t hw;

		hw = sk_win_read_1(sc, SK_Y2_HWRES);
		if ((hw & SK_Y2_HWRES_LINK_MASK) == SK_Y2_HWRES_LINK_DUAL) {
			if ((sk_win_read_1(sc, SK_Y2_CLKGATE) &
			    SK_Y2_CLKGATE_LINK2_INACTIVE) == 0)
				sc->sk_macs++;
		}
	} else {
		if (!(sk_win_read_1(sc, SK_CONFIG) & SK_CONFIG_SINGLEMAC))
@


1.9
log
@cosmetic tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.8 2006/08/17 21:31:37 brad Exp $	*/
a1858 12
	if (sc->sk_type == SK_YUKON_LITE &&
	    sc->sk_rev >= SK_YUKON_LITE_REV_A3) {
		/*
		 * Workaround code for COMA mode, set PHY reset.
		 * Otherwise it will not correctly take chip out of
		 * powerdown (coma)
		 */
		v = sk_win_read_4(sc, SK_GPIO);
		v |= SK_GPIO_DIR9 | SK_GPIO_DAT9;
		sk_win_write_4(sc, SK_GPIO, v);
	}

a1866 11

	if (sc->sk_type == SK_YUKON_LITE &&
	    sc->sk_rev >= SK_YUKON_LITE_REV_A3) {
		/*
		 * Workaround code for COMA mode, clear PHY reset
		 */
		v = sk_win_read_4(sc, SK_GPIO);
		v |= SK_GPIO_DIR9;
		v &= ~SK_GPIO_DAT9;
		sk_win_write_4(sc, SK_GPIO, v);
	}
@


1.8
log
@remove PCI ids which msk(4) will match against from sk(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.7 2006/08/17 21:07:20 brad Exp $	*/
d1063 1
a1063 2
	}
	else
@


1.7
log
@2 more PCI ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.6 2006/08/17 20:55:34 kettenis Exp $	*/
d791 1
a791 1
	    sizeof(mskc_devices)/sizeof(mskc_devices[0])) ? 3 : 0);
@


1.6
log
@Remove some #ifdef'ed out (bogus) debug code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.5 2006/08/17 20:07:52 brad Exp $	*/
d187 1
d202 1
@


1.5
log
@remove some unused code from msk_init_yukon().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.4 2006/08/17 19:48:08 brad Exp $	*/
a1780 1
#if 1
a1787 5
#else
	status = CSR_READ_4(sc, SK_Y2_EISR);
	if (status == 0)
		return (0);
#endif
a1834 1
#if 1
a1835 3
#else
	CSR_READ_4(sc, SK_Y2_LISR);
#endif
@


1.4
log
@SK_DEBUG/skdebug -> MSK_DEBUG/mskdebug
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.3 2006/08/17 19:42:48 brad Exp $	*/
a1945 1
#if 1
a1946 4
#else
	SK_YU_WRITE_2(sc_if, YUKON_RCR, YU_RCR_UFLEN | YU_RCR_MUFLEN |
		      YU_RCR_CRCR);
#endif
@


1.3
log
@refactor the promiscuous mode handling code and simplify the ioctl handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.2 2006/08/17 19:30:55 brad Exp $	*/
d172 4
a175 6

#undef SK_DEBUG
#ifdef SK_DEBUG
#define DPRINTF(x)	if (skdebug) printf x
#define DPRINTFN(n,x)	if (skdebug >= (n)) printf x
int	skdebug = 2;
d1439 2
a1440 2
#ifdef SK_DEBUG
	if (skdebug >= 2)
d1497 2
a1498 2
#ifdef SK_DEBUG
	if (skdebug >= 2) {
d1708 2
a1709 2
#ifdef SK_DEBUG
		if (skdebug >= 2)
d2228 1
a2228 1
#ifdef SK_DEBUG
@


1.2
log
@get rid of the last traces of ykc.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_msk.c,v 1.1 2006/08/16 21:06:23 kettenis Exp $	*/
d169 1
d383 13
d738 3
a740 10
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc_if->sk_if_flags & IFF_PROMISC)) {
				SK_YU_CLRBIT_2(sc_if, YUKON_RCR,
				    YU_RCR_UFLEN | YU_RCR_MUFLEN);
				msk_setmulti(sc_if);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc_if->sk_if_flags & IFF_PROMISC) {
				SK_YU_SETBIT_2(sc_if, YUKON_RCR,
				    YU_RCR_UFLEN | YU_RCR_MUFLEN);
a750 1
		error = 0;
d1980 3
@


1.1
log
@Enter msk(4), an initial stab at a driver for the Marvell Yukon-2 Gigabit
ethernet controllers.  It works well enough to commit over.  There's a lot
code duplication from sk(4) though that needs to be reduced.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sk.c,v 1.118 2006/07/30 18:48:52 brad Exp $	*/
d134 3
a136 3
int ykc_probe(struct device *, void *, void *);
void ykc_attach(struct device *, struct device *self, void *aux);
void ykc_shutdown(void *);
d139 1
a139 1
int ykcprint(void *, const char *);
d187 1
a187 1
const struct pci_matchid ykc_devices[] = {
d782 1
a782 1
ykc_probe(struct device *parent, void *match, void *aux)
d784 2
a785 2
	return (pci_matchbyid((struct pci_attach_args *)aux, ykc_devices,
	    sizeof(ykc_devices)/sizeof(ykc_devices[0])) ? 3 : 0);
d1069 1
a1069 1
	shutdownhook_establish(ykc_shutdown, sc);
d1085 1
a1085 1
ykcprint(void *aux, const char *pnp)
d1102 1
a1102 1
ykc_attach(struct device *parent, struct device *self, void *aux)
d1118 1
a1118 1
	DPRINTFN(2, ("begin ykc_attach\n"));
d1177 1
a1177 1
	DPRINTFN(2, ("ykc_attach: allocate interrupt\n"));
d1237 1
a1237 1
	DPRINTFN(2, ("ykc_attach: ramsize=%d (%dk), rboff=%d\n",
d1387 1
a1387 1
	(void)config_found(&sc->sk_dev, &skca, ykcprint);
d1393 1
a1393 1
		(void)config_found(&sc->sk_dev, &skca, ykcprint);
d1584 1
a1584 1
ykc_shutdown(void *v)
d2206 1
a2206 1
	sizeof(struct sk_softc), ykc_probe, ykc_attach,
@

