head	1.92;
access;
symbols
	OPENBSD_6_2:1.92.0.2
	OPENBSD_6_2_BASE:1.92
	OPENBSD_6_1:1.92.0.4
	OPENBSD_6_1_BASE:1.92
	OPENBSD_6_0:1.91.0.4
	OPENBSD_6_0_BASE:1.91
	OPENBSD_5_9:1.90.0.2
	OPENBSD_5_9_BASE:1.90
	OPENBSD_5_8:1.84.0.4
	OPENBSD_5_8_BASE:1.84
	OPENBSD_5_7:1.81.0.4
	OPENBSD_5_7_BASE:1.81
	OPENBSD_5_6:1.79.0.4
	OPENBSD_5_6_BASE:1.79
	OPENBSD_5_5:1.78.0.4
	OPENBSD_5_5_BASE:1.78
	OPENBSD_5_4:1.73.0.4
	OPENBSD_5_4_BASE:1.73
	OPENBSD_5_3:1.73.0.2
	OPENBSD_5_3_BASE:1.73
	OPENBSD_5_2:1.71.0.6
	OPENBSD_5_2_BASE:1.71
	OPENBSD_5_1_BASE:1.71
	OPENBSD_5_1:1.71.0.4
	OPENBSD_5_0:1.71.0.2
	OPENBSD_5_0_BASE:1.71
	OPENBSD_4_9:1.70.0.2
	OPENBSD_4_9_BASE:1.70
	OPENBSD_4_8:1.69.0.2
	OPENBSD_4_8_BASE:1.69
	OPENBSD_4_7:1.68.0.2
	OPENBSD_4_7_BASE:1.68
	OPENBSD_4_6:1.67.0.6
	OPENBSD_4_6_BASE:1.67
	OPENBSD_4_5:1.67.0.2
	OPENBSD_4_5_BASE:1.67
	OPENBSD_4_4:1.58.0.2
	OPENBSD_4_4_BASE:1.58
	OPENBSD_4_3:1.57.0.2
	OPENBSD_4_3_BASE:1.57
	OPENBSD_4_2:1.56.0.4
	OPENBSD_4_2_BASE:1.56
	OPENBSD_4_1:1.56.0.2
	OPENBSD_4_1_BASE:1.56
	OPENBSD_4_0:1.55.0.2
	OPENBSD_4_0_BASE:1.55
	OPENBSD_3_9:1.49.0.2
	OPENBSD_3_9_BASE:1.49
	OPENBSD_3_8:1.44.0.2
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.31.0.2
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.26.0.4
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.25.0.2
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.23
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	SMP:1.4.0.2;
locks; strict;
comment	@ * @;


1.92
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.91;
commitid	VyLWTsbepAOk7VQM;

1.91
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.90;
commitid	8YSL8ByWzGeIGBiJ;

1.90
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.89;
commitid	B0kwmVGiD5DVx4kv;

1.89
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.88;
commitid	5gdEnqVoJuTuwdTu;

1.88
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.87;
commitid	eYnPulzvLjDImPCa;

1.87
date	2015.11.14.17.54.57;	author mpi;	state Exp;
branches;
next	1.86;
commitid	Waft2RDjXAxr4qZ9;

1.86
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.85;
commitid	hPF95ClMUQfeqQDX;

1.85
date	2015.09.12.10.15.10;	author miod;	state Exp;
branches;
next	1.84;
commitid	7nT32okhwAwISbr0;

1.84
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.83;
commitid	MVWrtktB46JRxFWT;

1.83
date	2015.04.13.08.45.48;	author mpi;	state Exp;
branches;
next	1.82;
commitid	aiRvgNOa4qke9vft;

1.82
date	2015.04.08.10.07.47;	author mpi;	state Exp;
branches;
next	1.81;
commitid	hnmA6leYzflFI0c3;

1.81
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.80;
commitid	yM2VFFhpDTeFQlve;

1.80
date	2014.08.20.00.59.56;	author dlg;	state Exp;
branches;
next	1.79;
commitid	Hg9680ax96joal9S;

1.79
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.78;
commitid	TGHgrLxu6sxZoiFt;

1.78
date	2013.11.26.09.50.33;	author mpi;	state Exp;
branches;
next	1.77;

1.77
date	2013.11.18.19.43.00;	author brad;	state Exp;
branches;
next	1.76;

1.76
date	2013.10.01.20.06.01;	author sf;	state Exp;
branches;
next	1.75;

1.75
date	2013.08.21.05.21.44;	author dlg;	state Exp;
branches;
next	1.74;

1.74
date	2013.08.07.01.06.36;	author bluhm;	state Exp;
branches;
next	1.73;

1.73
date	2012.11.29.21.10.32;	author brad;	state Exp;
branches;
next	1.72;

1.72
date	2012.10.18.21.44.21;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2011.06.22.16.44.27;	author tedu;	state Exp;
branches;
next	1.70;

1.70
date	2010.09.20.07.40.38;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.68;

1.68
date	2009.08.13.14.24.47;	author jasper;	state Exp;
branches;
next	1.67;

1.67
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.66;

1.66
date	2008.11.09.15.08.26;	author naddy;	state Exp;
branches;
next	1.65;

1.65
date	2008.10.28.22.45.20;	author brad;	state Exp;
branches;
next	1.64;

1.64
date	2008.10.28.07.01.56;	author brad;	state Exp;
branches;
next	1.63;

1.63
date	2008.10.28.05.04.32;	author brad;	state Exp;
branches;
next	1.62;

1.62
date	2008.10.28.04.32.23;	author brad;	state Exp;
branches;
next	1.61;

1.61
date	2008.10.16.19.18.03;	author naddy;	state Exp;
branches;
next	1.60;

1.60
date	2008.10.15.19.12.18;	author blambert;	state Exp;
branches;
next	1.59;

1.59
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.58;

1.58
date	2008.05.23.08.49.27;	author brad;	state Exp;
branches;
next	1.57;

1.57
date	2007.11.26.09.28.33;	author martynas;	state Exp;
branches;
next	1.56;

1.56
date	2006.10.25.02.37.50;	author brad;	state Exp;
branches;
next	1.55;

1.55
date	2006.05.28.00.20.21;	author brad;	state Exp;
branches;
next	1.54;

1.54
date	2006.05.28.00.04.24;	author jason;	state Exp;
branches;
next	1.53;

1.53
date	2006.05.27.10.03.15;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.20.03.47.56;	author brad;	state Exp;
branches;
next	1.51;

1.51
date	2006.03.25.22.41.45;	author djm;	state Exp;
branches;
next	1.50;

1.50
date	2006.03.04.04.40.57;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2006.02.16.20.54.35;	author brad;	state Exp;
branches;
next	1.48;

1.48
date	2005.11.23.11.30.14;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	2005.11.04.17.22.05;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2005.10.09.04.44.45;	author brad;	state Exp;
branches;
next	1.45;

1.45
date	2005.09.11.18.17.08;	author mickey;	state Exp;
branches;
next	1.44;

1.44
date	2005.08.09.04.10.12;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2005.07.30.04.25.00;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2005.07.25.00.49.44;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.09.23.18.53;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2005.07.09.22.26.14;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2005.07.09.22.14.27;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2005.07.09.22.09.39;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2005.07.09.20.57.18;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2005.07.09.20.53.08;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2005.07.02.23.10.11;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.25.21.01.17;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.25.20.59.04;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.25.17.55.51;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2005.02.17.18.07.36;	author jfb;	state Exp;
branches;
next	1.30;

1.30
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2004.08.05.19.57.17;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.30.01.51.51;	author mcbride;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.09.21.52.17;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2003.08.06.21.08.07;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.15.06.31.24;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.26.06.01.28;	author nate;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.22.17.53.43;	author nate;	state Exp;
branches;
next	1.22;

1.22
date	2002.09.21.15.29.46;	author nate;	state Exp;
branches;
next	1.21;

1.21
date	2002.09.21.15.05.49;	author nate;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.10.18.08.13;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.05.13.48.11;	author aaron;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.12.09.51.20;	author kjc;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.15.20.45.31;	author nordin;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.13.21.00.16;	author mickey;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.05.01.02.25;	author nate;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.26.14.23.27;	author peter;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.21.17.55.44;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.04.14.17.51;	author nate;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.12.20.03.49;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.06.06.18.43;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.06.01.55.25;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.02.06.53.43;	author nate;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.07.02.05.24.07;	author nate;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.24.22.58.01;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.08.02.26.13;	author nate;	state Exp;
branches;
next	;

1.4.2.1
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2001.12.05.00.43.29;	author niklas;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.4.2.7;

1.4.2.7
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	1.4.2.8;

1.4.2.8
date	2004.06.05.23.12.50;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.92
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_nge.c,v 1.91 2016/04/13 10:34:32 mpi Exp $	*/
/*
 * Copyright (c) 2001 Wind River Systems
 * Copyright (c) 1997, 1998, 1999, 2000, 2001
 *	Bill Paul <wpaul@@bsdi.com>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: if_nge.c,v 1.35 2002/08/08 18:33:28 ambrisko Exp $
 */

/*
 * National Semiconductor DP83820/DP83821 gigabit ethernet driver
 * for FreeBSD. Datasheets are available from:
 *
 * http://www.national.com/ds/DP/DP83820.pdf
 * http://www.national.com/ds/DP/DP83821.pdf
 *
 * These chips are used on several low cost gigabit ethernet NICs
 * sold by D-Link, Addtron, SMC and Asante. Both parts are
 * virtually the same, except the 83820 is a 64-bit/32-bit part,
 * while the 83821 is 32-bit only.
 *
 * Many cards also use National gigE transceivers, such as the
 * DP83891, DP83861 and DP83862 gigPHYTER parts. The DP83861 datasheet
 * contains a full register description that applies to all of these
 * components:
 *
 * http://www.national.com/ds/DP/DP83861.pdf
 *
 * Written by Bill Paul <wpaul@@bsdi.com>
 * BSDi Open Source Solutions
 */

/*
 * The NatSemi DP83820 and 83821 controllers are enhanced versions
 * of the NatSemi MacPHYTER 10/100 devices. They support 10, 100
 * and 1000Mbps speeds with 1000baseX (ten bit interface), MII and GMII
 * ports. Other features include 8K TX FIFO and 32K RX FIFO, TCP/IP
 * hardware checksum offload (IPv4 only), VLAN tagging and filtering,
 * priority TX and RX queues, a 2048 bit multicast hash filter, 4 RX pattern
 * matching buffers, one perfect address filter buffer and interrupt
 * moderation. The 83820 supports both 64-bit and 32-bit addressing
 * and data transfers: the 64-bit support can be toggled on or off
 * via software. This affects the size of certain fields in the DMA
 * descriptors.
 *
 * There are two bugs/misfeatures in the 83820/83821 that I have
 * discovered so far:
 *
 * - Receive buffers must be aligned on 64-bit boundaries, which means
 *   you must resort to copying data in order to fix up the payload
 *   alignment.
 *
 * - In order to transmit jumbo frames larger than 8170 bytes, you have
 *   to turn off transmit checksum offloading, because the chip can't
 *   compute the checksum on an outgoing frame unless it fits entirely
 *   within the TX FIFO, which is only 8192 bytes in size. If you have
 *   TX checksum offload enabled and you transmit attempt to transmit a
 *   frame larger than 8170 bytes, the transmitter will wedge.
 *
 * To work around the latter problem, TX checksum offload is disabled
 * if the user selects an MTU larger than 8152 (8170 - 18).
 */

#include "bpfilter.h"
#include "vlan.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <uvm/uvm_extern.h>              /* for vtophys */
#define	VTOPHYS(v)	vtophys((vaddr_t)(v))

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#define NGE_USEIOSPACE

#include <dev/pci/if_ngereg.h>

int nge_probe(struct device *, void *, void *);
void nge_attach(struct device *, struct device *, void *);

int nge_newbuf(struct nge_softc *, struct nge_desc *,
			     struct mbuf *);
int nge_encap(struct nge_softc *, struct mbuf *, u_int32_t *);
void nge_rxeof(struct nge_softc *);
void nge_txeof(struct nge_softc *);
int nge_intr(void *);
void nge_tick(void *);
void nge_start(struct ifnet *);
int nge_ioctl(struct ifnet *, u_long, caddr_t);
void nge_init(void *);
void nge_stop(struct nge_softc *);
void nge_watchdog(struct ifnet *);
int nge_ifmedia_mii_upd(struct ifnet *);
void nge_ifmedia_mii_sts(struct ifnet *, struct ifmediareq *);
int nge_ifmedia_tbi_upd(struct ifnet *);
void nge_ifmedia_tbi_sts(struct ifnet *, struct ifmediareq *);

void nge_delay(struct nge_softc *);
void nge_eeprom_idle(struct nge_softc *);
void nge_eeprom_putbyte(struct nge_softc *, int);
void nge_eeprom_getword(struct nge_softc *, int, u_int16_t *);
void nge_read_eeprom(struct nge_softc *, caddr_t, int, int, int);

void nge_mii_sync(struct nge_softc *);
void nge_mii_send(struct nge_softc *, u_int32_t, int);
int nge_mii_readreg(struct nge_softc *, struct nge_mii_frame *);
int nge_mii_writereg(struct nge_softc *, struct nge_mii_frame *);

int nge_miibus_readreg(struct device *, int, int);
void nge_miibus_writereg(struct device *, int, int, int);
void nge_miibus_statchg(struct device *);

void nge_setmulti(struct nge_softc *);
void nge_reset(struct nge_softc *);
int nge_list_rx_init(struct nge_softc *);
int nge_list_tx_init(struct nge_softc *);

#ifdef NGE_USEIOSPACE
#define NGE_RES			SYS_RES_IOPORT
#define NGE_RID			NGE_PCI_LOIO
#else
#define NGE_RES			SYS_RES_MEMORY
#define NGE_RID			NGE_PCI_LOMEM
#endif

#ifdef NGE_DEBUG
#define DPRINTF(x)	if (ngedebug) printf x
#define DPRINTFN(n,x)	if (ngedebug >= (n)) printf x
int	ngedebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#define NGE_SETBIT(sc, reg, x)				\
	CSR_WRITE_4(sc, reg,				\
		CSR_READ_4(sc, reg) | (x))

#define NGE_CLRBIT(sc, reg, x)				\
	CSR_WRITE_4(sc, reg,				\
		CSR_READ_4(sc, reg) & ~(x))

#define SIO_SET(x)					\
	CSR_WRITE_4(sc, NGE_MEAR, CSR_READ_4(sc, NGE_MEAR) | (x))

#define SIO_CLR(x)					\
	CSR_WRITE_4(sc, NGE_MEAR, CSR_READ_4(sc, NGE_MEAR) & ~(x))

void
nge_delay(struct nge_softc *sc)
{
	int			idx;

	for (idx = (300 / 33) + 1; idx > 0; idx--)
		CSR_READ_4(sc, NGE_CSR);
}

void
nge_eeprom_idle(struct nge_softc *sc)
{
	int		i;

	SIO_SET(NGE_MEAR_EE_CSEL);
	nge_delay(sc);
	SIO_SET(NGE_MEAR_EE_CLK);
	nge_delay(sc);

	for (i = 0; i < 25; i++) {
		SIO_CLR(NGE_MEAR_EE_CLK);
		nge_delay(sc);
		SIO_SET(NGE_MEAR_EE_CLK);
		nge_delay(sc);
	}

	SIO_CLR(NGE_MEAR_EE_CLK);
	nge_delay(sc);
	SIO_CLR(NGE_MEAR_EE_CSEL);
	nge_delay(sc);
	CSR_WRITE_4(sc, NGE_MEAR, 0x00000000);
}

/*
 * Send a read command and address to the EEPROM, check for ACK.
 */
void
nge_eeprom_putbyte(struct nge_softc *sc, int addr)
{
	int			d, i;

	d = addr | NGE_EECMD_READ;

	/*
	 * Feed in each bit and strobe the clock.
	 */
	for (i = 0x400; i; i >>= 1) {
		if (d & i) {
			SIO_SET(NGE_MEAR_EE_DIN);
		} else {
			SIO_CLR(NGE_MEAR_EE_DIN);
		}
		nge_delay(sc);
		SIO_SET(NGE_MEAR_EE_CLK);
		nge_delay(sc);
		SIO_CLR(NGE_MEAR_EE_CLK);
		nge_delay(sc);
	}
}

/*
 * Read a word of data stored in the EEPROM at address 'addr.'
 */
void
nge_eeprom_getword(struct nge_softc *sc, int addr, u_int16_t *dest)
{
	int			i;
	u_int16_t		word = 0;

	/* Force EEPROM to idle state. */
	nge_eeprom_idle(sc);

	/* Enter EEPROM access mode. */
	nge_delay(sc);
	SIO_CLR(NGE_MEAR_EE_CLK);
	nge_delay(sc);
	SIO_SET(NGE_MEAR_EE_CSEL);
	nge_delay(sc);

	/*
	 * Send address of word we want to read.
	 */
	nge_eeprom_putbyte(sc, addr);

	/*
	 * Start reading bits from EEPROM.
	 */
	for (i = 0x8000; i; i >>= 1) {
		SIO_SET(NGE_MEAR_EE_CLK);
		nge_delay(sc);
		if (CSR_READ_4(sc, NGE_MEAR) & NGE_MEAR_EE_DOUT)
			word |= i;
		nge_delay(sc);
		SIO_CLR(NGE_MEAR_EE_CLK);
		nge_delay(sc);
	}

	/* Turn off EEPROM access mode. */
	nge_eeprom_idle(sc);

	*dest = word;
}

/*
 * Read a sequence of words from the EEPROM.
 */
void
nge_read_eeprom(struct nge_softc *sc, caddr_t dest, int off, int cnt, int swap)
{
	int			i;
	u_int16_t		word = 0, *ptr;

	for (i = 0; i < cnt; i++) {
		nge_eeprom_getword(sc, off + i, &word);
		ptr = (u_int16_t *)(dest + (i * 2));
		if (swap)
			*ptr = ntohs(word);
		else
			*ptr = word;
	}
}

/*
 * Sync the PHYs by setting data bit and strobing the clock 32 times.
 */
void
nge_mii_sync(struct nge_softc *sc)
{
	int			i;

	SIO_SET(NGE_MEAR_MII_DIR|NGE_MEAR_MII_DATA);

	for (i = 0; i < 32; i++) {
		SIO_SET(NGE_MEAR_MII_CLK);
		DELAY(1);
		SIO_CLR(NGE_MEAR_MII_CLK);
		DELAY(1);
	}
}

/*
 * Clock a series of bits through the MII.
 */
void
nge_mii_send(struct nge_softc *sc, u_int32_t bits, int cnt)
{
	int			i;

	SIO_CLR(NGE_MEAR_MII_CLK);

	for (i = (0x1 << (cnt - 1)); i; i >>= 1) {
                if (bits & i) {
			SIO_SET(NGE_MEAR_MII_DATA);
                } else {
			SIO_CLR(NGE_MEAR_MII_DATA);
                }
		DELAY(1);
		SIO_CLR(NGE_MEAR_MII_CLK);
		DELAY(1);
		SIO_SET(NGE_MEAR_MII_CLK);
	}
}

/*
 * Read an PHY register through the MII.
 */
int
nge_mii_readreg(struct nge_softc *sc, struct nge_mii_frame *frame)
{
	int			i, ack, s;

	s = splnet();

	/*
	 * Set up frame for RX.
	 */
	frame->mii_stdelim = NGE_MII_STARTDELIM;
	frame->mii_opcode = NGE_MII_READOP;
	frame->mii_turnaround = 0;
	frame->mii_data = 0;

	CSR_WRITE_4(sc, NGE_MEAR, 0);

	/*
	 * Turn on data xmit.
	 */
	SIO_SET(NGE_MEAR_MII_DIR);

	nge_mii_sync(sc);

	/*
	 * Send command/address info.
	 */
	nge_mii_send(sc, frame->mii_stdelim, 2);
	nge_mii_send(sc, frame->mii_opcode, 2);
	nge_mii_send(sc, frame->mii_phyaddr, 5);
	nge_mii_send(sc, frame->mii_regaddr, 5);

	/* Idle bit */
	SIO_CLR((NGE_MEAR_MII_CLK|NGE_MEAR_MII_DATA));
	DELAY(1);
	SIO_SET(NGE_MEAR_MII_CLK);
	DELAY(1);

	/* Turn off xmit. */
	SIO_CLR(NGE_MEAR_MII_DIR);
	/* Check for ack */
	SIO_CLR(NGE_MEAR_MII_CLK);
	DELAY(1);
	ack = CSR_READ_4(sc, NGE_MEAR) & NGE_MEAR_MII_DATA;
	SIO_SET(NGE_MEAR_MII_CLK);
	DELAY(1);

	/*
	 * Now try reading data bits. If the ack failed, we still
	 * need to clock through 16 cycles to keep the PHY(s) in sync.
	 */
	if (ack) {
		for(i = 0; i < 16; i++) {
			SIO_CLR(NGE_MEAR_MII_CLK);
			DELAY(1);
			SIO_SET(NGE_MEAR_MII_CLK);
			DELAY(1);
		}
		goto fail;
	}

	for (i = 0x8000; i; i >>= 1) {
		SIO_CLR(NGE_MEAR_MII_CLK);
		DELAY(1);
		if (!ack) {
			if (CSR_READ_4(sc, NGE_MEAR) & NGE_MEAR_MII_DATA)
				frame->mii_data |= i;
			DELAY(1);
		}
		SIO_SET(NGE_MEAR_MII_CLK);
		DELAY(1);
	}

fail:

	SIO_CLR(NGE_MEAR_MII_CLK);
	DELAY(1);
	SIO_SET(NGE_MEAR_MII_CLK);
	DELAY(1);

	splx(s);

	if (ack)
		return(1);
	return(0);
}

/*
 * Write to a PHY register through the MII.
 */
int
nge_mii_writereg(struct nge_softc *sc, struct nge_mii_frame *frame)
{
	int			s;

	s = splnet();
	/*
	 * Set up frame for TX.
	 */

	frame->mii_stdelim = NGE_MII_STARTDELIM;
	frame->mii_opcode = NGE_MII_WRITEOP;
	frame->mii_turnaround = NGE_MII_TURNAROUND;

	/*
	 * Turn on data output.
	 */
	SIO_SET(NGE_MEAR_MII_DIR);

	nge_mii_sync(sc);

	nge_mii_send(sc, frame->mii_stdelim, 2);
	nge_mii_send(sc, frame->mii_opcode, 2);
	nge_mii_send(sc, frame->mii_phyaddr, 5);
	nge_mii_send(sc, frame->mii_regaddr, 5);
	nge_mii_send(sc, frame->mii_turnaround, 2);
	nge_mii_send(sc, frame->mii_data, 16);

	/* Idle bit. */
	SIO_SET(NGE_MEAR_MII_CLK);
	DELAY(1);
	SIO_CLR(NGE_MEAR_MII_CLK);
	DELAY(1);

	/*
	 * Turn off xmit.
	 */
	SIO_CLR(NGE_MEAR_MII_DIR);

	splx(s);

	return(0);
}

int
nge_miibus_readreg(struct device *dev, int phy, int reg)
{
	struct nge_softc	*sc = (struct nge_softc *)dev;
	struct nge_mii_frame	frame;

	DPRINTFN(9, ("%s: nge_miibus_readreg\n", sc->sc_dv.dv_xname));

	bzero(&frame, sizeof(frame));

	frame.mii_phyaddr = phy;
	frame.mii_regaddr = reg;
	nge_mii_readreg(sc, &frame);

	return(frame.mii_data);
}

void
nge_miibus_writereg(struct device *dev, int phy, int reg, int data)
{
	struct nge_softc	*sc = (struct nge_softc *)dev;
	struct nge_mii_frame	frame;


	DPRINTFN(9, ("%s: nge_miibus_writereg\n", sc->sc_dv.dv_xname));

	bzero(&frame, sizeof(frame));

	frame.mii_phyaddr = phy;
	frame.mii_regaddr = reg;
	frame.mii_data = data;
	nge_mii_writereg(sc, &frame);
}

void
nge_miibus_statchg(struct device *dev)
{
	struct nge_softc	*sc = (struct nge_softc *)dev;
	struct mii_data		*mii = &sc->nge_mii;
	u_int32_t		txcfg, rxcfg;

	txcfg = CSR_READ_4(sc, NGE_TX_CFG);
	rxcfg = CSR_READ_4(sc, NGE_RX_CFG);

	DPRINTFN(4, ("%s: nge_miibus_statchg txcfg=%#x, rxcfg=%#x\n",
		     sc->sc_dv.dv_xname, txcfg, rxcfg));

	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX) {
		txcfg |= (NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR);
		rxcfg |= (NGE_RXCFG_RX_FDX);
	} else {
		txcfg &= ~(NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR);
		rxcfg &= ~(NGE_RXCFG_RX_FDX);
	}

	txcfg |= NGE_TXCFG_AUTOPAD;
	
	CSR_WRITE_4(sc, NGE_TX_CFG, txcfg);
	CSR_WRITE_4(sc, NGE_RX_CFG, rxcfg);

	/* If we have a 1000Mbps link, set the mode_1000 bit. */
	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T)
		NGE_SETBIT(sc, NGE_CFG, NGE_CFG_MODE_1000);
	else
		NGE_CLRBIT(sc, NGE_CFG, NGE_CFG_MODE_1000);
}

void
nge_setmulti(struct nge_softc *sc)
{
	struct arpcom		*ac = &sc->arpcom;
	struct ifnet		*ifp = &ac->ac_if;
	struct ether_multi      *enm;
	struct ether_multistep  step;
	u_int32_t		h = 0, i, filtsave;
	int			bit, index;

	if (ac->ac_multirangecnt > 0)
		ifp->if_flags |= IFF_ALLMULTI;

	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
		NGE_CLRBIT(sc, NGE_RXFILT_CTL,
		    NGE_RXFILTCTL_MCHASH|NGE_RXFILTCTL_UCHASH);
		NGE_SETBIT(sc, NGE_RXFILT_CTL, NGE_RXFILTCTL_ALLMULTI);
		return;
	}

	/*
	 * We have to explicitly enable the multicast hash table
	 * on the NatSemi chip if we want to use it, which we do.
	 * We also have to tell it that we don't want to use the
	 * hash table for matching unicast addresses.
	 */
	NGE_SETBIT(sc, NGE_RXFILT_CTL, NGE_RXFILTCTL_MCHASH);
	NGE_CLRBIT(sc, NGE_RXFILT_CTL,
	    NGE_RXFILTCTL_ALLMULTI|NGE_RXFILTCTL_UCHASH);

	filtsave = CSR_READ_4(sc, NGE_RXFILT_CTL);

	/* first, zot all the existing hash bits */
	for (i = 0; i < NGE_MCAST_FILTER_LEN; i += 2) {
		CSR_WRITE_4(sc, NGE_RXFILT_CTL, NGE_FILTADDR_MCAST_LO + i);
		CSR_WRITE_4(sc, NGE_RXFILT_DATA, 0);
	}

	/*
	 * From the 11 bits returned by the crc routine, the top 7
	 * bits represent the 16-bit word in the mcast hash table
	 * that needs to be updated, and the lower 4 bits represent
	 * which bit within that byte needs to be set.
	 */
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		h = (ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 21) &
		    0x00000FFF;
		index = (h >> 4) & 0x7F;
		bit = h & 0xF;
		CSR_WRITE_4(sc, NGE_RXFILT_CTL,
		    NGE_FILTADDR_MCAST_LO + (index * 2));
		NGE_SETBIT(sc, NGE_RXFILT_DATA, (1 << bit));
		ETHER_NEXT_MULTI(step, enm);
	}

	CSR_WRITE_4(sc, NGE_RXFILT_CTL, filtsave);
}

void
nge_reset(struct nge_softc *sc)
{
	int			i;

	NGE_SETBIT(sc, NGE_CSR, NGE_CSR_RESET);

	for (i = 0; i < NGE_TIMEOUT; i++) {
		if (!(CSR_READ_4(sc, NGE_CSR) & NGE_CSR_RESET))
			break;
	}

	if (i == NGE_TIMEOUT)
		printf("%s: reset never completed\n", sc->sc_dv.dv_xname);

	/* Wait a little while for the chip to get its brains in order. */
	DELAY(1000);

	/*
	 * If this is a NetSemi chip, make sure to clear
	 * PME mode.
	 */
	CSR_WRITE_4(sc, NGE_CLKRUN, NGE_CLKRUN_PMESTS);
	CSR_WRITE_4(sc, NGE_CLKRUN, 0);
}

/*
 * Probe for an NatSemi chip. Check the PCI vendor and device
 * IDs against our list and return a device name if we find a match.
 */
int
nge_probe(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_NS &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NS_DP83820)
		return (1);

	return (0);
}

/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
void
nge_attach(struct device *parent, struct device *self, void *aux)
{
	struct nge_softc	*sc = (struct nge_softc *)self;
	struct pci_attach_args	*pa = aux;
	pci_chipset_tag_t	pc = pa->pa_pc;
	pci_intr_handle_t	ih;
	const char		*intrstr = NULL;
	bus_size_t		size;
	bus_dma_segment_t	seg;
	bus_dmamap_t		dmamap;
	int			rseg;
	u_char			eaddr[ETHER_ADDR_LEN];
#ifndef NGE_USEIOSPACE
	pcireg_t		memtype;
#endif
	struct ifnet		*ifp;
	caddr_t			kva;

	pci_set_powerstate(pa->pa_pc, pa->pa_tag, PCI_PMCSR_STATE_D0);

	/*
	 * Map control/status registers.
	 */
	DPRINTFN(5, ("%s: map control/status regs\n", sc->sc_dv.dv_xname));

#ifdef NGE_USEIOSPACE
	DPRINTFN(5, ("%s: pci_mapreg_map\n", sc->sc_dv.dv_xname));
	if (pci_mapreg_map(pa, NGE_PCI_LOIO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->nge_btag, &sc->nge_bhandle, NULL, &size, 0)) {
		printf(": can't map i/o space\n");
		return;
	}
#else
	DPRINTFN(5, ("%s: pci_mapreg_map\n", sc->sc_dv.dv_xname));
	memtype = pci_mapreg_type(pc, pa->pa_tag, NGE_PCI_LOMEM);
	if (pci_mapreg_map(pa, NGE_PCI_LOMEM, memtype, 0, &sc->nge_btag,
	    &sc->nge_bhandle, NULL, &size, 0)) {
		printf(": can't map mem space\n");
		return;
	}
#endif

	/* Disable all interrupts */
	CSR_WRITE_4(sc, NGE_IER, 0);

	DPRINTFN(5, ("%s: pci_intr_map\n", sc->sc_dv.dv_xname));
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		goto fail_1;
	}

	DPRINTFN(5, ("%s: pci_intr_string\n", sc->sc_dv.dv_xname));
	intrstr = pci_intr_string(pc, ih);
	DPRINTFN(5, ("%s: pci_intr_establish\n", sc->sc_dv.dv_xname));
	sc->nge_intrhand = pci_intr_establish(pc, ih, IPL_NET, nge_intr, sc,
					      sc->sc_dv.dv_xname);
	if (sc->nge_intrhand == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail_1;
	}
	printf(": %s", intrstr);

	/* Reset the adapter. */
	DPRINTFN(5, ("%s: nge_reset\n", sc->sc_dv.dv_xname));
	nge_reset(sc);

	/*
	 * Get station address from the EEPROM.
	 */
	DPRINTFN(5, ("%s: nge_read_eeprom\n", sc->sc_dv.dv_xname));
	nge_read_eeprom(sc, (caddr_t)&eaddr[4], NGE_EE_NODEADDR, 1, 0);
	nge_read_eeprom(sc, (caddr_t)&eaddr[2], NGE_EE_NODEADDR + 1, 1, 0);
	nge_read_eeprom(sc, (caddr_t)&eaddr[0], NGE_EE_NODEADDR + 2, 1, 0);

	/*
	 * A NatSemi chip was detected. Inform the world.
	 */
	printf(", address %s\n", ether_sprintf(eaddr));

	bcopy(eaddr, &sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);

	sc->sc_dmatag = pa->pa_dmat;
	DPRINTFN(5, ("%s: bus_dmamem_alloc\n", sc->sc_dv.dv_xname));
	if (bus_dmamem_alloc(sc->sc_dmatag, sizeof(struct nge_list_data),
			     PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT |
			     BUS_DMA_ZERO)) {
		printf("%s: can't alloc rx buffers\n", sc->sc_dv.dv_xname);
		goto fail_2;
	}
	DPRINTFN(5, ("%s: bus_dmamem_map\n", sc->sc_dv.dv_xname));
	if (bus_dmamem_map(sc->sc_dmatag, &seg, rseg,
			   sizeof(struct nge_list_data), &kva,
			   BUS_DMA_NOWAIT)) {
		printf("%s: can't map dma buffers (%zd bytes)\n",
		       sc->sc_dv.dv_xname, sizeof(struct nge_list_data));
		goto fail_3;
	}
	DPRINTFN(5, ("%s: bus_dmamem_create\n", sc->sc_dv.dv_xname));
	if (bus_dmamap_create(sc->sc_dmatag, sizeof(struct nge_list_data), 1,
			      sizeof(struct nge_list_data), 0,
			      BUS_DMA_NOWAIT, &dmamap)) {
		printf("%s: can't create dma map\n", sc->sc_dv.dv_xname);
		goto fail_4;
	}
	DPRINTFN(5, ("%s: bus_dmamem_load\n", sc->sc_dv.dv_xname));
	if (bus_dmamap_load(sc->sc_dmatag, dmamap, kva,
			    sizeof(struct nge_list_data), NULL,
			    BUS_DMA_NOWAIT)) {
		goto fail_5;
	}

	DPRINTFN(5, ("%s: bzero\n", sc->sc_dv.dv_xname));
	sc->nge_ldata = (struct nge_list_data *)kva;

	ifp = &sc->arpcom.ac_if;
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = nge_ioctl;
	ifp->if_start = nge_start;
	ifp->if_watchdog = nge_watchdog;
	ifp->if_hardmtu = NGE_JUMBO_MTU;
	IFQ_SET_MAXLEN(&ifp->if_snd, NGE_TX_LIST_CNT - 1);
	DPRINTFN(5, ("%s: bcopy\n", sc->sc_dv.dv_xname));
	bcopy(sc->sc_dv.dv_xname, ifp->if_xname, IFNAMSIZ);

	ifp->if_capabilities = IFCAP_VLAN_MTU;

#if NVLAN > 0
	ifp->if_capabilities |= IFCAP_VLAN_HWTAGGING;
#endif

	/*
	 * Do MII setup.
	 */
	DPRINTFN(5, ("%s: mii setup\n", sc->sc_dv.dv_xname));
	if (CSR_READ_4(sc, NGE_CFG) & NGE_CFG_TBI_EN) {
		DPRINTFN(5, ("%s: TBI mode\n", sc->sc_dv.dv_xname));
		sc->nge_tbi = 1;

		ifmedia_init(&sc->nge_ifmedia, 0, nge_ifmedia_tbi_upd, 
			     nge_ifmedia_tbi_sts);

		ifmedia_add(&sc->nge_ifmedia, IFM_ETHER|IFM_NONE, 0, NULL),
		ifmedia_add(&sc->nge_ifmedia, IFM_ETHER|IFM_1000_SX, 0, NULL);
		ifmedia_add(&sc->nge_ifmedia, IFM_ETHER|IFM_1000_SX|IFM_FDX,
			    0, NULL);
		ifmedia_add(&sc->nge_ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);

		ifmedia_set(&sc->nge_ifmedia, IFM_ETHER|IFM_AUTO);
	    
		CSR_WRITE_4(sc, NGE_GPIO, CSR_READ_4(sc, NGE_GPIO)
			    | NGE_GPIO_GP4_OUT 
			    | NGE_GPIO_GP1_OUTENB | NGE_GPIO_GP2_OUTENB 
			    | NGE_GPIO_GP3_OUTENB | NGE_GPIO_GP4_OUTENB
			    | NGE_GPIO_GP5_OUTENB);

		NGE_SETBIT(sc, NGE_CFG, NGE_CFG_MODE_1000);
	} else {
		sc->nge_mii.mii_ifp = ifp;
		sc->nge_mii.mii_readreg = nge_miibus_readreg;
		sc->nge_mii.mii_writereg = nge_miibus_writereg;
		sc->nge_mii.mii_statchg = nge_miibus_statchg;

		ifmedia_init(&sc->nge_mii.mii_media, 0, nge_ifmedia_mii_upd,
			     nge_ifmedia_mii_sts);
		mii_attach(&sc->sc_dv, &sc->nge_mii, 0xffffffff, MII_PHY_ANY,
			   MII_OFFSET_ANY, 0);
		
		if (LIST_FIRST(&sc->nge_mii.mii_phys) == NULL) {
			
			printf("%s: no PHY found!\n", sc->sc_dv.dv_xname);
			ifmedia_add(&sc->nge_mii.mii_media,
				    IFM_ETHER|IFM_MANUAL, 0, NULL);
			ifmedia_set(&sc->nge_mii.mii_media,
				    IFM_ETHER|IFM_MANUAL);
		}
		else
			ifmedia_set(&sc->nge_mii.mii_media,
				    IFM_ETHER|IFM_AUTO);
	}

	/*
	 * Call MI attach routine.
	 */
	DPRINTFN(5, ("%s: if_attach\n", sc->sc_dv.dv_xname));
	if_attach(ifp);
	DPRINTFN(5, ("%s: ether_ifattach\n", sc->sc_dv.dv_xname));
	ether_ifattach(ifp);
	DPRINTFN(5, ("%s: timeout_set\n", sc->sc_dv.dv_xname));
	timeout_set(&sc->nge_timeout, nge_tick, sc);
	timeout_add_sec(&sc->nge_timeout, 1);
	return;

fail_5:
	bus_dmamap_destroy(sc->sc_dmatag, dmamap);

fail_4:
	bus_dmamem_unmap(sc->sc_dmatag, kva,
	    sizeof(struct nge_list_data));

fail_3:
	bus_dmamem_free(sc->sc_dmatag, &seg, rseg);

fail_2:
	pci_intr_disestablish(pc, sc->nge_intrhand);

fail_1:
	bus_space_unmap(sc->nge_btag, sc->nge_bhandle, size);
}

/*
 * Initialize the transmit descriptors.
 */
int
nge_list_tx_init(struct nge_softc *sc)
{
	struct nge_list_data	*ld;
	struct nge_ring_data	*cd;
	int			i;

	cd = &sc->nge_cdata;
	ld = sc->nge_ldata;

	for (i = 0; i < NGE_TX_LIST_CNT; i++) {
		if (i == (NGE_TX_LIST_CNT - 1)) {
			ld->nge_tx_list[i].nge_nextdesc =
			    &ld->nge_tx_list[0];
			ld->nge_tx_list[i].nge_next =
			    VTOPHYS(&ld->nge_tx_list[0]);
		} else {
			ld->nge_tx_list[i].nge_nextdesc =
			    &ld->nge_tx_list[i + 1];
			ld->nge_tx_list[i].nge_next =
			    VTOPHYS(&ld->nge_tx_list[i + 1]);
		}
		ld->nge_tx_list[i].nge_mbuf = NULL;
		ld->nge_tx_list[i].nge_ptr = 0;
		ld->nge_tx_list[i].nge_ctl = 0;
	}

	cd->nge_tx_prod = cd->nge_tx_cons = cd->nge_tx_cnt = 0;

	return(0);
}


/*
 * Initialize the RX descriptors and allocate mbufs for them. Note that
 * we arrange the descriptors in a closed ring, so that the last descriptor
 * points back to the first.
 */
int
nge_list_rx_init(struct nge_softc *sc)
{
	struct nge_list_data	*ld;
	struct nge_ring_data	*cd;
	int			i;

	ld = sc->nge_ldata;
	cd = &sc->nge_cdata;

	for (i = 0; i < NGE_RX_LIST_CNT; i++) {
		if (nge_newbuf(sc, &ld->nge_rx_list[i], NULL) == ENOBUFS)
			return(ENOBUFS);
		if (i == (NGE_RX_LIST_CNT - 1)) {
			ld->nge_rx_list[i].nge_nextdesc =
			    &ld->nge_rx_list[0];
			ld->nge_rx_list[i].nge_next =
			    VTOPHYS(&ld->nge_rx_list[0]);
		} else {
			ld->nge_rx_list[i].nge_nextdesc =
			    &ld->nge_rx_list[i + 1];
			ld->nge_rx_list[i].nge_next =
			    VTOPHYS(&ld->nge_rx_list[i + 1]);
		}
	}

	cd->nge_rx_prod = 0;

	return(0);
}

/*
 * Initialize an RX descriptor and attach an MBUF cluster.
 */
int
nge_newbuf(struct nge_softc *sc, struct nge_desc *c, struct mbuf *m)
{
	struct mbuf		*m_new = NULL;

	if (m == NULL) {
		m_new = MCLGETI(NULL, NGE_MCLBYTES, NULL, M_DONTWAIT);
		if (m_new == NULL)
			return (ENOBUFS);
	} else {
		/*
		 * We're re-using a previously allocated mbuf;
		 * be sure to re-init pointers and lengths to
		 * default values.
		 */
		m_new = m;
		m_new->m_data = m_new->m_ext.ext_buf;
	}

	m_new->m_len = m_new->m_pkthdr.len = NGE_MCLBYTES;
	m_adj(m_new, sizeof(u_int64_t));

	c->nge_mbuf = m_new;
	c->nge_ptr = VTOPHYS(mtod(m_new, caddr_t));
	DPRINTFN(7,("%s: c->nge_ptr=%#x\n", sc->sc_dv.dv_xname,
		    c->nge_ptr));
	c->nge_ctl = m_new->m_len;
	c->nge_extsts = 0;

	return(0);
}

/*
 * A frame has been uploaded: pass the resulting mbuf chain up to
 * the higher level protocols.
 */
void
nge_rxeof(struct nge_softc *sc)
{
	struct mbuf_list	ml = MBUF_LIST_INITIALIZER();
        struct mbuf		*m;
        struct ifnet		*ifp;
	struct nge_desc		*cur_rx;
	int			i, total_len = 0;
	u_int32_t		rxstat;

	ifp = &sc->arpcom.ac_if;
	i = sc->nge_cdata.nge_rx_prod;

	while (NGE_OWNDESC(&sc->nge_ldata->nge_rx_list[i])) {
		struct mbuf		*m0 = NULL;
		u_int32_t		extsts;

		cur_rx = &sc->nge_ldata->nge_rx_list[i];
		rxstat = cur_rx->nge_rxstat;
		extsts = cur_rx->nge_extsts;
		m = cur_rx->nge_mbuf;
		cur_rx->nge_mbuf = NULL;
		total_len = NGE_RXBYTES(cur_rx);
		NGE_INC(i, NGE_RX_LIST_CNT);

		/*
		 * If an error occurs, update stats, clear the
		 * status word and leave the mbuf cluster in place:
		 * it should simply get re-used next time this descriptor
		 * comes up in the ring.
		 */
		if (!(rxstat & NGE_CMDSTS_PKT_OK)) {
#if NVLAN > 0
			if ((rxstat & NGE_RXSTAT_RUNT) &&
			    total_len >= (ETHER_MIN_LEN - ETHER_CRC_LEN -
			    ETHER_VLAN_ENCAP_LEN)) {
				/*
				 * Workaround a hardware bug. Accept runt
				 * frames if its length is larger than or
				 * equal to 56.
				 */
			} else {
#endif
				ifp->if_ierrors++;
				nge_newbuf(sc, cur_rx, m);
				continue;
#if NVLAN > 0
			}
#endif
		}

		/*
		 * Ok. NatSemi really screwed up here. This is the
		 * only gigE chip I know of with alignment constraints
		 * on receive buffers. RX buffers must be 64-bit aligned.
		 */
#ifndef __STRICT_ALIGNMENT
		/*
		 * By popular demand, ignore the alignment problems
		 * on the Intel x86 platform. The performance hit
		 * incurred due to unaligned accesses is much smaller
		 * than the hit produced by forcing buffer copies all
		 * the time, especially with jumbo frames. We still
		 * need to fix up the alignment everywhere else though.
		 */
		if (nge_newbuf(sc, cur_rx, NULL) == ENOBUFS) {
#endif
			m0 = m_devget(mtod(m, char *), total_len, ETHER_ALIGN);
			nge_newbuf(sc, cur_rx, m);
			if (m0 == NULL) {
				ifp->if_ierrors++;
				continue;
			}
			m_adj(m0, ETHER_ALIGN);
			m = m0;
#ifndef __STRICT_ALIGNMENT
		} else {
			m->m_pkthdr.len = m->m_len = total_len;
		}
#endif

#if NVLAN > 0
		if (extsts & NGE_RXEXTSTS_VLANPKT) {
			m->m_pkthdr.ether_vtag =
			    ntohs(extsts & NGE_RXEXTSTS_VTCI);
			m->m_flags |= M_VLANTAG;
		}
#endif

		/* Do IP checksum checking. */
		if (extsts & NGE_RXEXTSTS_IPPKT) {
			if (!(extsts & NGE_RXEXTSTS_IPCSUMERR))
				m->m_pkthdr.csum_flags |= M_IPV4_CSUM_IN_OK;
			if ((extsts & NGE_RXEXTSTS_TCPPKT) &&
			    (!(extsts & NGE_RXEXTSTS_TCPCSUMERR)))
				m->m_pkthdr.csum_flags |= M_TCP_CSUM_IN_OK;
			else if ((extsts & NGE_RXEXTSTS_UDPPKT) &&
				 (!(extsts & NGE_RXEXTSTS_UDPCSUMERR)))
				m->m_pkthdr.csum_flags |= M_UDP_CSUM_IN_OK;
		}

		ml_enqueue(&ml, m);
	}

	if_input(ifp, &ml);

	sc->nge_cdata.nge_rx_prod = i;
}

/*
 * A frame was downloaded to the chip. It's safe for us to clean up
 * the list buffers.
 */

void
nge_txeof(struct nge_softc *sc)
{
	struct nge_desc		*cur_tx;
	struct ifnet		*ifp;
	u_int32_t		idx;

	ifp = &sc->arpcom.ac_if;

	/*
	 * Go through our tx list and free mbufs for those
	 * frames that have been transmitted.
	 */
	idx = sc->nge_cdata.nge_tx_cons;
	while (idx != sc->nge_cdata.nge_tx_prod) {
		cur_tx = &sc->nge_ldata->nge_tx_list[idx];

		if (NGE_OWNDESC(cur_tx))
			break;

		if (cur_tx->nge_ctl & NGE_CMDSTS_MORE) {
			sc->nge_cdata.nge_tx_cnt--;
			NGE_INC(idx, NGE_TX_LIST_CNT);
			continue;
		}

		if (!(cur_tx->nge_ctl & NGE_CMDSTS_PKT_OK)) {
			ifp->if_oerrors++;
			if (cur_tx->nge_txstat & NGE_TXSTAT_EXCESSCOLLS)
				ifp->if_collisions++;
			if (cur_tx->nge_txstat & NGE_TXSTAT_OUTOFWINCOLL)
				ifp->if_collisions++;
		}

		ifp->if_collisions +=
		    (cur_tx->nge_txstat & NGE_TXSTAT_COLLCNT) >> 16;

		if (cur_tx->nge_mbuf != NULL) {
			m_freem(cur_tx->nge_mbuf);
			cur_tx->nge_mbuf = NULL;
			ifq_clr_oactive(&ifp->if_snd);
		}

		sc->nge_cdata.nge_tx_cnt--;
		NGE_INC(idx, NGE_TX_LIST_CNT);
	}

	sc->nge_cdata.nge_tx_cons = idx;

	if (idx == sc->nge_cdata.nge_tx_prod)
		ifp->if_timer = 0;
}

void
nge_tick(void *xsc)
{
	struct nge_softc	*sc = xsc;
	struct mii_data		*mii = &sc->nge_mii;
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	int			s;

	s = splnet();

	DPRINTFN(10, ("%s: nge_tick: link=%d\n", sc->sc_dv.dv_xname,
		      sc->nge_link));

	timeout_add_sec(&sc->nge_timeout, 1);
	if (sc->nge_link) {
		splx(s);
		return;
	}

	if (sc->nge_tbi) {
		if (IFM_SUBTYPE(sc->nge_ifmedia.ifm_cur->ifm_media)
		    == IFM_AUTO) {
			u_int32_t bmsr, anlpar, txcfg, rxcfg;

			bmsr = CSR_READ_4(sc, NGE_TBI_BMSR);
			DPRINTFN(2, ("%s: nge_tick: bmsr=%#x\n",
				     sc->sc_dv.dv_xname, bmsr));

			if (!(bmsr & NGE_TBIBMSR_ANEG_DONE)) {
				CSR_WRITE_4(sc, NGE_TBI_BMCR, 0);

				splx(s);
				return;
			}
				
			anlpar = CSR_READ_4(sc, NGE_TBI_ANLPAR);
			txcfg = CSR_READ_4(sc, NGE_TX_CFG);
			rxcfg = CSR_READ_4(sc, NGE_RX_CFG);
			
			DPRINTFN(2, ("%s: nge_tick: anlpar=%#x, txcfg=%#x, "
				     "rxcfg=%#x\n", sc->sc_dv.dv_xname, anlpar,
				     txcfg, rxcfg));
			
			if (anlpar == 0 || anlpar & NGE_TBIANAR_FDX) {
				txcfg |= (NGE_TXCFG_IGN_HBEAT|
					  NGE_TXCFG_IGN_CARR);
				rxcfg |= NGE_RXCFG_RX_FDX;
			} else {
				txcfg &= ~(NGE_TXCFG_IGN_HBEAT|
					   NGE_TXCFG_IGN_CARR);
				rxcfg &= ~(NGE_RXCFG_RX_FDX);
			}
			txcfg |= NGE_TXCFG_AUTOPAD;
			CSR_WRITE_4(sc, NGE_TX_CFG, txcfg);
			CSR_WRITE_4(sc, NGE_RX_CFG, rxcfg);
		}

		DPRINTF(("%s: gigabit link up\n", sc->sc_dv.dv_xname));
		sc->nge_link++;
		if (!IFQ_IS_EMPTY(&ifp->if_snd))
			nge_start(ifp);
	} else {
		mii_tick(mii);
		if (mii->mii_media_status & IFM_ACTIVE &&
		    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
			sc->nge_link++;
			if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T)
				DPRINTF(("%s: gigabit link up\n",
					 sc->sc_dv.dv_xname));
			if (!IFQ_IS_EMPTY(&ifp->if_snd))
				nge_start(ifp);
		}
		
	}

	splx(s);
}

int
nge_intr(void *arg)
{
	struct nge_softc	*sc;
	struct ifnet		*ifp;
	u_int32_t		status;
	int			claimed = 0;

	sc = arg;
	ifp = &sc->arpcom.ac_if;

	/* Suppress unwanted interrupts */
	if (!(ifp->if_flags & IFF_UP)) {
		nge_stop(sc);
		return (0);
	}

	/* Disable interrupts. */
	CSR_WRITE_4(sc, NGE_IER, 0);

	/* Data LED on for TBI mode */
	if(sc->nge_tbi)
		 CSR_WRITE_4(sc, NGE_GPIO, CSR_READ_4(sc, NGE_GPIO)
			     | NGE_GPIO_GP3_OUT);

	for (;;) {
		/* Reading the ISR register clears all interrupts. */
		status = CSR_READ_4(sc, NGE_ISR);

		if ((status & NGE_INTRS) == 0)
			break;

		claimed = 1;

		if ((status & NGE_ISR_TX_DESC_OK) ||
		    (status & NGE_ISR_TX_ERR) ||
		    (status & NGE_ISR_TX_OK) ||
		    (status & NGE_ISR_TX_IDLE))
			nge_txeof(sc);

		if ((status & NGE_ISR_RX_DESC_OK) ||
		    (status & NGE_ISR_RX_ERR) ||
		    (status & NGE_ISR_RX_OFLOW) ||
		    (status & NGE_ISR_RX_FIFO_OFLOW) ||
		    (status & NGE_ISR_RX_IDLE) ||
		    (status & NGE_ISR_RX_OK))
			nge_rxeof(sc);

		if ((status & NGE_ISR_RX_IDLE))
			NGE_SETBIT(sc, NGE_CSR, NGE_CSR_RX_ENABLE);

		if (status & NGE_ISR_SYSERR) {
			nge_reset(sc);
			ifp->if_flags &= ~IFF_RUNNING;
			nge_init(sc);
		}

#if 0
		/* 
		 * XXX: nge_tick() is not ready to be called this way
		 * it screws up the aneg timeout because mii_tick() is
		 * only to be called once per second.
		 */
		if (status & NGE_IMR_PHY_INTR) {
			sc->nge_link = 0;
			nge_tick(sc);
		}
#endif
	}

	/* Re-enable interrupts. */
	CSR_WRITE_4(sc, NGE_IER, 1);

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		nge_start(ifp);

	/* Data LED off for TBI mode */
	if(sc->nge_tbi)
		CSR_WRITE_4(sc, NGE_GPIO, CSR_READ_4(sc, NGE_GPIO)
			    & ~NGE_GPIO_GP3_OUT);

	return claimed;
}

/*
 * Encapsulate an mbuf chain in a descriptor by coupling the mbuf data
 * pointers to the fragment pointers.
 */
int
nge_encap(struct nge_softc *sc, struct mbuf *m_head, u_int32_t *txidx)
{
	struct nge_desc		*f = NULL;
	struct mbuf		*m;
	int			frag, cur, cnt = 0;

	/*
	 * Start packing the mbufs in this chain into
	 * the fragment pointers. Stop when we run out
	 * of fragments or hit the end of the mbuf chain.
	 */
	m = m_head;
	cur = frag = *txidx;

	for (m = m_head; m != NULL; m = m->m_next) {
		if (m->m_len != 0) {
			if ((NGE_TX_LIST_CNT -
			    (sc->nge_cdata.nge_tx_cnt + cnt)) < 2)
				return(ENOBUFS);
			f = &sc->nge_ldata->nge_tx_list[frag];
			f->nge_ctl = NGE_CMDSTS_MORE | m->m_len;
			f->nge_ptr = VTOPHYS(mtod(m, vaddr_t));
			DPRINTFN(7,("%s: f->nge_ptr=%#x\n",
				    sc->sc_dv.dv_xname, f->nge_ptr));
			if (cnt != 0)
				f->nge_ctl |= NGE_CMDSTS_OWN;
			cur = frag;
			NGE_INC(frag, NGE_TX_LIST_CNT);
			cnt++;
		}
	}

	if (m != NULL)
		return(ENOBUFS);

	sc->nge_ldata->nge_tx_list[*txidx].nge_extsts = 0;

#if NVLAN > 0
	if (m_head->m_flags & M_VLANTAG) {
		sc->nge_ldata->nge_tx_list[cur].nge_extsts |=
		    (NGE_TXEXTSTS_VLANPKT|htons(m_head->m_pkthdr.ether_vtag));
	}
#endif

	sc->nge_ldata->nge_tx_list[cur].nge_mbuf = m_head;
	sc->nge_ldata->nge_tx_list[cur].nge_ctl &= ~NGE_CMDSTS_MORE;
	sc->nge_ldata->nge_tx_list[*txidx].nge_ctl |= NGE_CMDSTS_OWN;
	sc->nge_cdata.nge_tx_cnt += cnt;
	*txidx = frag;

	return(0);
}

/*
 * Main transmit routine. To avoid having to do mbuf copies, we put pointers
 * to the mbuf data regions directly in the transmit lists. We also save a
 * copy of the pointers since the transmit list fragment pointers are
 * physical addresses.
 */

void
nge_start(struct ifnet *ifp)
{
	struct nge_softc	*sc;
	struct mbuf		*m_head = NULL;
	u_int32_t		idx;
	int			pkts = 0;

	sc = ifp->if_softc;

	if (!sc->nge_link)
		return;

	idx = sc->nge_cdata.nge_tx_prod;

	if (ifq_is_oactive(&ifp->if_snd))
		return;

	while(sc->nge_ldata->nge_tx_list[idx].nge_mbuf == NULL) {
		m_head = ifq_deq_begin(&ifp->if_snd);
		if (m_head == NULL)
			break;

		if (nge_encap(sc, m_head, &idx)) {
			ifq_deq_rollback(&ifp->if_snd, m_head);
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		/* now we are committed to transmit the packet */
		ifq_deq_commit(&ifp->if_snd, m_head);
		pkts++;

#if NBPFILTER > 0
		/*
		 * If there's a BPF listener, bounce a copy of this frame
		 * to him.
		 */
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif
	}
	if (pkts == 0)
		return;

	/* Transmit */
	sc->nge_cdata.nge_tx_prod = idx;
	NGE_SETBIT(sc, NGE_CSR, NGE_CSR_TX_ENABLE);

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;
}

void
nge_init(void *xsc)
{
	struct nge_softc	*sc = xsc;
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	struct mii_data		*mii;
	u_int32_t		txcfg, rxcfg;
	uint64_t		media;
	int			s;

	if (ifp->if_flags & IFF_RUNNING)
		return;

	s = splnet();

	/*
	 * Cancel pending I/O and free all RX/TX buffers.
	 */
	nge_stop(sc);

	mii = sc->nge_tbi ? NULL: &sc->nge_mii;

	/* Set MAC address */
	CSR_WRITE_4(sc, NGE_RXFILT_CTL, NGE_FILTADDR_PAR0);
	CSR_WRITE_4(sc, NGE_RXFILT_DATA,
	    ((u_int16_t *)sc->arpcom.ac_enaddr)[0]);
	CSR_WRITE_4(sc, NGE_RXFILT_CTL, NGE_FILTADDR_PAR1);
	CSR_WRITE_4(sc, NGE_RXFILT_DATA,
	    ((u_int16_t *)sc->arpcom.ac_enaddr)[1]);
	CSR_WRITE_4(sc, NGE_RXFILT_CTL, NGE_FILTADDR_PAR2);
	CSR_WRITE_4(sc, NGE_RXFILT_DATA,
	    ((u_int16_t *)sc->arpcom.ac_enaddr)[2]);

	/* Init circular RX list. */
	if (nge_list_rx_init(sc) == ENOBUFS) {
		printf("%s: initialization failed: no "
			"memory for rx buffers\n", sc->sc_dv.dv_xname);
		nge_stop(sc);
		splx(s);
		return;
	}

	/*
	 * Init tx descriptors.
	 */
	nge_list_tx_init(sc);

	/*
	 * For the NatSemi chip, we have to explicitly enable the
	 * reception of ARP frames, as well as turn on the 'perfect
	 * match' filter where we store the station address, otherwise
	 * we won't receive unicasts meant for this host.
	 */
	NGE_SETBIT(sc, NGE_RXFILT_CTL, NGE_RXFILTCTL_ARP);
	NGE_SETBIT(sc, NGE_RXFILT_CTL, NGE_RXFILTCTL_PERFECT);

	 /* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC)
		NGE_SETBIT(sc, NGE_RXFILT_CTL, NGE_RXFILTCTL_ALLPHYS);
	else
		NGE_CLRBIT(sc, NGE_RXFILT_CTL, NGE_RXFILTCTL_ALLPHYS);

	/*
	 * Set the capture broadcast bit to capture broadcast frames.
	 */
	if (ifp->if_flags & IFF_BROADCAST)
		NGE_SETBIT(sc, NGE_RXFILT_CTL, NGE_RXFILTCTL_BROAD);
	else
		NGE_CLRBIT(sc, NGE_RXFILT_CTL, NGE_RXFILTCTL_BROAD);

	/*
	 * Load the multicast filter.
	 */
	nge_setmulti(sc);

	/* Turn the receive filter on */
	NGE_SETBIT(sc, NGE_RXFILT_CTL, NGE_RXFILTCTL_ENABLE);

	/*
	 * Load the address of the RX and TX lists.
	 */
	CSR_WRITE_4(sc, NGE_RX_LISTPTR,
	    VTOPHYS(&sc->nge_ldata->nge_rx_list[0]));
	CSR_WRITE_4(sc, NGE_TX_LISTPTR,
	    VTOPHYS(&sc->nge_ldata->nge_tx_list[0]));

	/* Set RX configuration */
	CSR_WRITE_4(sc, NGE_RX_CFG, NGE_RXCFG);

	/*
	 * Enable hardware checksum validation for all IPv4
	 * packets, do not reject packets with bad checksums.
	 */
	CSR_WRITE_4(sc, NGE_VLAN_IP_RXCTL, NGE_VIPRXCTL_IPCSUM_ENB);

	/*
	 * If VLAN support is enabled, tell the chip to detect
	 * and strip VLAN tag info from received frames. The tag
	 * will be provided in the extsts field in the RX descriptors.
	 */
	if (ifp->if_capabilities & IFCAP_VLAN_HWTAGGING)
		NGE_SETBIT(sc, NGE_VLAN_IP_RXCTL,
		    NGE_VIPRXCTL_TAG_DETECT_ENB | NGE_VIPRXCTL_TAG_STRIP_ENB);

	/* Set TX configuration */
	CSR_WRITE_4(sc, NGE_TX_CFG, NGE_TXCFG);

	/*
	 * If VLAN support is enabled, tell the chip to insert
	 * VLAN tags on a per-packet basis as dictated by the
	 * code in the frame encapsulation routine.
	 */
	if (ifp->if_capabilities & IFCAP_VLAN_HWTAGGING)
		NGE_SETBIT(sc, NGE_VLAN_IP_TXCTL, NGE_VIPTXCTL_TAG_PER_PKT);

	/* Set full/half duplex mode. */
	if (sc->nge_tbi)
		media = sc->nge_ifmedia.ifm_cur->ifm_media;
	else
		media = mii->mii_media_active;

	txcfg = CSR_READ_4(sc, NGE_TX_CFG);
	rxcfg = CSR_READ_4(sc, NGE_RX_CFG);

	DPRINTFN(4, ("%s: nge_init txcfg=%#x, rxcfg=%#x\n",
		     sc->sc_dv.dv_xname, txcfg, rxcfg));

	if ((media & IFM_GMASK) == IFM_FDX) {
		txcfg |= (NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR);
		rxcfg |= (NGE_RXCFG_RX_FDX);
	} else {
		txcfg &= ~(NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR);
		rxcfg &= ~(NGE_RXCFG_RX_FDX);
	}

	txcfg |= NGE_TXCFG_AUTOPAD;
	
	CSR_WRITE_4(sc, NGE_TX_CFG, txcfg);
	CSR_WRITE_4(sc, NGE_RX_CFG, rxcfg);

	nge_tick(sc);

	/*
	 * Enable the delivery of PHY interrupts based on
	 * link/speed/duplex status changes and enable return
	 * of extended status information in the DMA descriptors,
	 * required for checksum offloading.
	 */
	NGE_SETBIT(sc, NGE_CFG, NGE_CFG_PHYINTR_SPD|NGE_CFG_PHYINTR_LNK|
		   NGE_CFG_PHYINTR_DUP|NGE_CFG_EXTSTS_ENB);

	DPRINTFN(1, ("%s: nge_init: config=%#x\n", sc->sc_dv.dv_xname,
		     CSR_READ_4(sc, NGE_CFG)));

	/*
	 * Configure interrupt holdoff (moderation). We can
	 * have the chip delay interrupt delivery for a certain
	 * period. Units are in 100us, and the max setting
	 * is 25500us (0xFF x 100us). Default is a 100us holdoff.
	 */
	CSR_WRITE_4(sc, NGE_IHR, 0x01);

	/*
	 * Enable interrupts.
	 */
	CSR_WRITE_4(sc, NGE_IMR, NGE_INTRS);
	CSR_WRITE_4(sc, NGE_IER, 1);

	/* Enable receiver and transmitter. */
	NGE_CLRBIT(sc, NGE_CSR, NGE_CSR_TX_DISABLE|NGE_CSR_RX_DISABLE);
	NGE_SETBIT(sc, NGE_CSR, NGE_CSR_RX_ENABLE);

	if (sc->nge_tbi)
	    nge_ifmedia_tbi_upd(ifp);
	else
	    nge_ifmedia_mii_upd(ifp);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);
}

/*
 * Set mii media options.
 */
int
nge_ifmedia_mii_upd(struct ifnet *ifp)
{
	struct nge_softc	*sc = ifp->if_softc;
	struct mii_data 	*mii = &sc->nge_mii;

	DPRINTFN(2, ("%s: nge_ifmedia_mii_upd\n", sc->sc_dv.dv_xname));

	sc->nge_link = 0;

	if (mii->mii_instance) {
		struct mii_softc *miisc;
		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
			mii_phy_reset(miisc);
	}
	mii_mediachg(mii);

	return(0);
}

/*
 * Report current mii media status.
 */
void
nge_ifmedia_mii_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct nge_softc	*sc = ifp->if_softc;
	struct mii_data *mii = &sc->nge_mii;

	DPRINTFN(2, ("%s: nge_ifmedia_mii_sts\n", sc->sc_dv.dv_xname));

	mii_pollstat(mii);
	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;
}

/*
 * Set mii media options.
 */
int
nge_ifmedia_tbi_upd(struct ifnet *ifp)
{
	struct nge_softc	*sc = ifp->if_softc;

	DPRINTFN(2, ("%s: nge_ifmedia_tbi_upd\n", sc->sc_dv.dv_xname));

	sc->nge_link = 0;

	if (IFM_SUBTYPE(sc->nge_ifmedia.ifm_cur->ifm_media) 
	    == IFM_AUTO) {
		u_int32_t anar, bmcr;
		anar = CSR_READ_4(sc, NGE_TBI_ANAR);
		anar |= (NGE_TBIANAR_HDX | NGE_TBIANAR_FDX);
		CSR_WRITE_4(sc, NGE_TBI_ANAR, anar);

		bmcr = CSR_READ_4(sc, NGE_TBI_BMCR);
		bmcr |= (NGE_TBIBMCR_ENABLE_ANEG|NGE_TBIBMCR_RESTART_ANEG);
		CSR_WRITE_4(sc, NGE_TBI_BMCR, bmcr);

		bmcr &= ~(NGE_TBIBMCR_RESTART_ANEG);
		CSR_WRITE_4(sc, NGE_TBI_BMCR, bmcr);
	} else {
		u_int32_t txcfg, rxcfg;
		txcfg = CSR_READ_4(sc, NGE_TX_CFG);
		rxcfg = CSR_READ_4(sc, NGE_RX_CFG);

		if ((sc->nge_ifmedia.ifm_cur->ifm_media & IFM_GMASK)
		    == IFM_FDX) {
			txcfg |= NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR;
			rxcfg |= NGE_RXCFG_RX_FDX;
		} else {
			txcfg &= ~(NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR);
			rxcfg &= ~(NGE_RXCFG_RX_FDX);
		}

		txcfg |= NGE_TXCFG_AUTOPAD;
		CSR_WRITE_4(sc, NGE_TX_CFG, txcfg);
		CSR_WRITE_4(sc, NGE_RX_CFG, rxcfg);
	}
	
	NGE_CLRBIT(sc, NGE_GPIO, NGE_GPIO_GP3_OUT);

	return(0);
}

/*
 * Report current tbi media status.
 */
void
nge_ifmedia_tbi_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct nge_softc	*sc = ifp->if_softc;
	u_int32_t		bmcr;

	bmcr = CSR_READ_4(sc, NGE_TBI_BMCR);
	
	if (IFM_SUBTYPE(sc->nge_ifmedia.ifm_cur->ifm_media) == IFM_AUTO) {
		u_int32_t bmsr = CSR_READ_4(sc, NGE_TBI_BMSR);
		DPRINTFN(2, ("%s: nge_ifmedia_tbi_sts bmsr=%#x, bmcr=%#x\n",
			     sc->sc_dv.dv_xname, bmsr, bmcr));
	
		if (!(bmsr & NGE_TBIBMSR_ANEG_DONE)) {
			ifmr->ifm_active = IFM_ETHER|IFM_NONE;
			ifmr->ifm_status = IFM_AVALID;
			return;
		}
	} else {
		DPRINTFN(2, ("%s: nge_ifmedia_tbi_sts bmcr=%#x\n",
			     sc->sc_dv.dv_xname, bmcr));
	}
		
	ifmr->ifm_status = IFM_AVALID|IFM_ACTIVE;
	ifmr->ifm_active = IFM_ETHER|IFM_1000_SX;
	
	if (bmcr & NGE_TBIBMCR_LOOPBACK)
		ifmr->ifm_active |= IFM_LOOP;
	
	if (IFM_SUBTYPE(sc->nge_ifmedia.ifm_cur->ifm_media) == IFM_AUTO) {
		u_int32_t anlpar = CSR_READ_4(sc, NGE_TBI_ANLPAR);
		DPRINTFN(2, ("%s: nge_ifmedia_tbi_sts anlpar=%#x\n",
			     sc->sc_dv.dv_xname, anlpar));
		
		ifmr->ifm_active |= IFM_AUTO;
		if (anlpar & NGE_TBIANLPAR_FDX) {
			ifmr->ifm_active |= IFM_FDX;
		} else if (anlpar & NGE_TBIANLPAR_HDX) {
			ifmr->ifm_active |= IFM_HDX;
		} else
			ifmr->ifm_active |= IFM_FDX;
		
	} else if ((sc->nge_ifmedia.ifm_cur->ifm_media & IFM_GMASK) == IFM_FDX)
		ifmr->ifm_active |= IFM_FDX;
	else
		ifmr->ifm_active |= IFM_HDX;
	
}

int
nge_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct nge_softc	*sc = ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *) data;
	struct mii_data		*mii;
	int			s, error = 0;

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		nge_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->nge_if_flags & IFF_PROMISC)) {
				NGE_SETBIT(sc, NGE_RXFILT_CTL,
				    NGE_RXFILTCTL_ALLPHYS|
				    NGE_RXFILTCTL_ALLMULTI);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->nge_if_flags & IFF_PROMISC) {
				NGE_CLRBIT(sc, NGE_RXFILT_CTL,
				    NGE_RXFILTCTL_ALLPHYS);
				if (!(ifp->if_flags & IFF_ALLMULTI))
					NGE_CLRBIT(sc, NGE_RXFILT_CTL,
					    NGE_RXFILTCTL_ALLMULTI);
			} else {
				ifp->if_flags &= ~IFF_RUNNING;
				nge_init(sc);
			}
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				nge_stop(sc);
		}
		sc->nge_if_flags = ifp->if_flags;
		error = 0;
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		if (sc->nge_tbi) {
			error = ifmedia_ioctl(ifp, ifr, &sc->nge_ifmedia, 
					      command);
		} else {
			mii = &sc->nge_mii;
			error = ifmedia_ioctl(ifp, ifr, &mii->mii_media,
					      command);
		}
		break;

	default:
		error = ether_ioctl(ifp, &sc->arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			nge_setmulti(sc);
		error = 0;
	}

	splx(s);
	return(error);
}

void
nge_watchdog(struct ifnet *ifp)
{
	struct nge_softc	*sc;

	sc = ifp->if_softc;

	ifp->if_oerrors++;
	printf("%s: watchdog timeout\n", sc->sc_dv.dv_xname);

	nge_stop(sc);
	nge_reset(sc);
	ifp->if_flags &= ~IFF_RUNNING;
	nge_init(sc);

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		nge_start(ifp);
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void
nge_stop(struct nge_softc *sc)
{
	int			i;
	struct ifnet		*ifp;
	struct mii_data		*mii;

	ifp = &sc->arpcom.ac_if;
	ifp->if_timer = 0;
	if (sc->nge_tbi) {
		mii = NULL;
	} else {
		mii = &sc->nge_mii;
	}

	timeout_del(&sc->nge_timeout);

	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	CSR_WRITE_4(sc, NGE_IER, 0);
	CSR_WRITE_4(sc, NGE_IMR, 0);
	NGE_SETBIT(sc, NGE_CSR, NGE_CSR_TX_DISABLE|NGE_CSR_RX_DISABLE);
	DELAY(1000);
	CSR_WRITE_4(sc, NGE_TX_LISTPTR, 0);
	CSR_WRITE_4(sc, NGE_RX_LISTPTR, 0);

	if (!sc->nge_tbi)
		mii_down(mii);

	sc->nge_link = 0;

	/*
	 * Free data in the RX lists.
	 */
	for (i = 0; i < NGE_RX_LIST_CNT; i++) {
		if (sc->nge_ldata->nge_rx_list[i].nge_mbuf != NULL) {
			m_freem(sc->nge_ldata->nge_rx_list[i].nge_mbuf);
			sc->nge_ldata->nge_rx_list[i].nge_mbuf = NULL;
		}
	}
	bzero(&sc->nge_ldata->nge_rx_list,
		sizeof(sc->nge_ldata->nge_rx_list));

	/*
	 * Free the TX list buffers.
	 */
	for (i = 0; i < NGE_TX_LIST_CNT; i++) {
		if (sc->nge_ldata->nge_tx_list[i].nge_mbuf != NULL) {
			m_freem(sc->nge_ldata->nge_tx_list[i].nge_mbuf);
			sc->nge_ldata->nge_tx_list[i].nge_mbuf = NULL;
		}
	}

	bzero(&sc->nge_ldata->nge_tx_list,
		sizeof(sc->nge_ldata->nge_tx_list));
}

struct cfattach nge_ca = {
	sizeof(struct nge_softc), nge_probe, nge_attach
};

struct cfdriver nge_cd = {
	NULL, "nge", DV_IFNET
};
@


1.91
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.90 2015/11/25 03:09:59 dlg Exp $	*/
a1145 1
		ifp->if_opackets++;
@


1.90
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.89 2015/11/24 17:11:39 mpi Exp $	*/
a795 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.89
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.88 2015/11/20 03:35:23 dlg Exp $	*/
d1151 1
a1151 1
			ifp->if_flags &= ~IFF_OACTIVE;
d1406 1
a1406 1
	if (ifp->if_flags & IFF_OACTIVE)
d1416 1
a1416 1
			ifp->if_flags |= IFF_OACTIVE;
d1624 1
a1624 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1879 2
a1880 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.88
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.87 2015/11/14 17:54:57 mpi Exp $	*/
a103 1
#include <net/if_dl.h>
@


1.87
log
@Do not include <net/if_vlan_var.h> when it's not necessary.

Because of the VLAN hacks in mpw(4) this file still contains the definition
of "struct ifvlan" which depends on <sys/refcnt.h> which in turns pull
<sys/atomic.h>...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.86 2015/10/25 13:04:28 mpi Exp $	*/
d1411 1
a1411 1
		IFQ_POLL(&ifp->if_snd, m_head);
d1416 1
d1422 1
a1422 1
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.86
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.85 2015/09/12 10:15:10 miod Exp $	*/
a108 5

#if NVLAN > 0
#include <net/if_types.h>
#include <net/if_vlan_var.h>
#endif
@


1.85
log
@More ifmedia64 fallout; that should be the last.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.84 2015/06/24 09:40:54 mpi Exp $	*/
a1777 1
	struct ifaddr		*ifa = (struct ifaddr *) data;
d1787 1
a1787 9
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			nge_init(sc);
			arp_ifinit(&sc->arpcom, ifa);
			break;
		default:
			nge_init(sc);
			break;
                }
@


1.84
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.83 2015/04/13 08:45:48 mpi Exp $	*/
d1458 2
a1459 1
	int			s, media;
@


1.83
log
@Now that if_input() set the receiving interface pointer on mbufs for us
there's no need to do it in m_devget(9).

Stop passing an ``ifp'' will help for upcoming interface pointer -> index
conversion.

While here remove unused ``ifp'' argument from m_clget(9) and kill two
birds^W layer violations in one commit.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.82 2015/04/08 10:07:47 mpi Exp $	*/
a1081 2

		ifp->if_ipackets++;
@


1.82
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.81 2014/12/22 02:28:52 tedu Exp $	*/
d1069 1
a1069 2
			m0 = m_devget(mtod(m, char *), total_len,
			    ETHER_ALIGN, ifp);
@


1.81
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.80 2014/08/20 00:59:56 dlg Exp $	*/
d1005 1
a1079 1
			m->m_pkthdr.rcvif = ifp;
a1093 8
#if NBPFILTER > 0
		/*
		 * Handle BPF listeners. Let the BPF user see the packet.
		 */
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

d1106 1
a1106 1
		ether_input_mbuf(ifp, m);
d1108 2
@


1.80
log
@replace the custom jumbo allocator with MCLGETI.

putting this in the tree to make it easier for people to test.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.79 2014/07/22 13:12:11 mpi Exp $	*/
a106 1
#ifdef INET
a108 1
#endif
a1796 1
#ifdef INET
a1800 1
#endif /* INET */
@


1.79
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.78 2013/11/26 09:50:33 mpi Exp $	*/
a137 4
int nge_alloc_jumbo_mem(struct nge_softc *);
void *nge_jalloc(struct nge_softc *);
void nge_jfree(caddr_t, u_int, void *);

a795 8
	/* Try to allocate memory for jumbo buffers. */
	DPRINTFN(5, ("%s: nge_alloc_jumbo_mem\n", sc->sc_dv.dv_xname));
	if (nge_alloc_jumbo_mem(sc)) {
		printf("%s: jumbo buffer allocation failed\n",
		       sc->sc_dv.dv_xname);
		goto fail_5;
	}

d974 1
a974 3
		caddr_t buf = NULL;

		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
a976 11

		/* Allocate the jumbo buffer */
		buf = nge_jalloc(sc);
		if (buf == NULL) {
			m_freem(m_new);
			return (ENOBUFS);
		}

		/* Attach the buffer to the mbuf */
		m_new->m_len = m_new->m_pkthdr.len = NGE_MCLBYTES;
		MEXTADD(m_new, buf, NGE_MCLBYTES, 0, nge_jfree, sc);
a983 1
		m_new->m_len = m_new->m_pkthdr.len = NGE_MCLBYTES;
d987 1
a997 155
}

int
nge_alloc_jumbo_mem(struct nge_softc *sc)
{
	caddr_t			ptr, kva;
	bus_dma_segment_t	seg;
	bus_dmamap_t		dmamap;
	int			i, rseg, state, error;
	struct nge_jpool_entry	*entry;

	state = error = 0;

	if (bus_dmamem_alloc(sc->sc_dmatag, NGE_JMEM, PAGE_SIZE, 0,
			     &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
		printf("%s: can't alloc rx buffers\n", sc->sc_dv.dv_xname);
		return (ENOBUFS);
	}

	state = 1;
	if (bus_dmamem_map(sc->sc_dmatag, &seg, rseg, NGE_JMEM, &kva,
			   BUS_DMA_NOWAIT)) {
		printf("%s: can't map dma buffers (%zd bytes)\n",
		       sc->sc_dv.dv_xname, NGE_JMEM);
		error = ENOBUFS;
		goto out;
	}

	state = 2;
	if (bus_dmamap_create(sc->sc_dmatag, NGE_JMEM, 1,
			      NGE_JMEM, 0, BUS_DMA_NOWAIT, &dmamap)) {
		printf("%s: can't create dma map\n", sc->sc_dv.dv_xname);
		error = ENOBUFS;
		goto out;
	}

	state = 3;
	if (bus_dmamap_load(sc->sc_dmatag, dmamap, kva, NGE_JMEM,
			    NULL, BUS_DMA_NOWAIT)) {
		printf("%s: can't load dma map\n", sc->sc_dv.dv_xname);
		error = ENOBUFS;
		goto out;
        }

	state = 4;
	sc->nge_cdata.nge_jumbo_buf = (caddr_t)kva;
	DPRINTFN(1,("%s: nge_jumbo_buf=%#x, NGE_MCLBYTES=%#x\n",
		    sc->sc_dv.dv_xname , sc->nge_cdata.nge_jumbo_buf,
		    NGE_MCLBYTES));

	LIST_INIT(&sc->nge_jfree_listhead);
	LIST_INIT(&sc->nge_jinuse_listhead);

	/*
	 * Now divide it up into 9K pieces and save the addresses
	 * in an array. Note that we play an evil trick here by using
	 * the first few bytes in the buffer to hold the address
	 * of the softc structure for this interface. This is because
	 * nge_jfree() needs it, but it is called by the mbuf management
	 * code which will not pass it to us explicitly.
	 */
	ptr = sc->nge_cdata.nge_jumbo_buf;
	for (i = 0; i < NGE_JSLOTS; i++) {
		sc->nge_cdata.nge_jslots[i].nge_buf = ptr;
		sc->nge_cdata.nge_jslots[i].nge_inuse = 0;
		ptr += NGE_MCLBYTES;
		entry = malloc(sizeof(struct nge_jpool_entry),
			       M_DEVBUF, M_NOWAIT);
		if (entry == NULL) {
			sc->nge_cdata.nge_jumbo_buf = NULL;
			printf("%s: no memory for jumbo buffer queue!\n",
			       sc->sc_dv.dv_xname);
			error = ENOBUFS;
			goto out;
		}
		entry->slot = i;
		LIST_INSERT_HEAD(&sc->nge_jfree_listhead, entry,
				 jpool_entries);
	}
out:
	if (error != 0) {
		switch (state) {
		case 4:
			bus_dmamap_unload(sc->sc_dmatag, dmamap);
		case 3:
			bus_dmamap_destroy(sc->sc_dmatag, dmamap);
		case 2:
			bus_dmamem_unmap(sc->sc_dmatag, kva, NGE_JMEM);
		case 1:
			bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
			break;
		default:
			break;
		}
	}
 
	return (error);
}

/*
 * Allocate a jumbo buffer.
 */
void *
nge_jalloc(struct nge_softc *sc)
{
	struct nge_jpool_entry   *entry;

	entry = LIST_FIRST(&sc->nge_jfree_listhead);

	if (entry == NULL)
		return (NULL);

	LIST_REMOVE(entry, jpool_entries);
	LIST_INSERT_HEAD(&sc->nge_jinuse_listhead, entry, jpool_entries);
	sc->nge_cdata.nge_jslots[entry->slot].nge_inuse = 1;
	return(sc->nge_cdata.nge_jslots[entry->slot].nge_buf);
}

/*
 * Release a jumbo buffer.
 */
void
nge_jfree(caddr_t buf, u_int size, void *arg)
{
	struct nge_softc	*sc;
	int		        i;
	struct nge_jpool_entry *entry;

	/* Extract the softc struct pointer. */
	sc = (struct nge_softc *)arg;

	if (sc == NULL)
		panic("nge_jfree: can't find softc pointer!");

	/* calculate the slot this buffer belongs to */

	i = ((vaddr_t)buf - (vaddr_t)sc->nge_cdata.nge_jumbo_buf)
	  / NGE_MCLBYTES;

	if ((i < 0) || (i >= NGE_JSLOTS))
		panic("nge_jfree: asked to free buffer that we don't manage!");
	else if (sc->nge_cdata.nge_jslots[i].nge_inuse == 0)
		panic("nge_jfree: buffer already free!");
	else {
		sc->nge_cdata.nge_jslots[i].nge_inuse--;
		if(sc->nge_cdata.nge_jslots[i].nge_inuse == 0) {
			entry = LIST_FIRST(&sc->nge_jinuse_listhead);
			if (entry == NULL)
				panic("nge_jfree: buffer not in use!");
			entry->slot = i;
			LIST_REMOVE(entry, jpool_entries);
			LIST_INSERT_HEAD(&sc->nge_jfree_listhead,
					 entry, jpool_entries);
		}
	}
@


1.78
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.77 2013/11/18 19:43:00 brad Exp $	*/
a108 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.77
log
@- ansify some function definitions
- remove return at end of void functions
- remove extraneous braces

no functional change.

ok chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.76 2013/10/01 20:06:01 sf Exp $	*/
d589 3
a591 1
allmulti:
a624 4
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}
@


1.76
log
@Use %z* for size_t

while there, fix a few %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.75 2013/08/21 05:21:44 dlg Exp $	*/
d213 1
a213 2
nge_delay(sc)
	struct nge_softc	*sc;
d222 1
a222 2
nge_eeprom_idle(sc)
	struct nge_softc	*sc;
d249 1
a249 3
nge_eeprom_putbyte(sc, addr)
	struct nge_softc	*sc;
	int			addr;
d276 1
a276 4
nge_eeprom_getword(sc, addr, dest)
	struct nge_softc	*sc;
	int			addr;
	u_int16_t		*dest;
d319 1
a319 6
nge_read_eeprom(sc, dest, off, cnt, swap)
	struct nge_softc	*sc;
	caddr_t			dest;
	int			off;
	int			cnt;
	int			swap;
d338 1
a338 2
nge_mii_sync(sc)
	struct nge_softc		*sc;
d356 1
a356 4
nge_mii_send(sc, bits, cnt)
	struct nge_softc		*sc;
	u_int32_t		bits;
	int			cnt;
d379 1
a379 3
nge_mii_readreg(sc, frame)
	struct nge_softc		*sc;
	struct nge_mii_frame	*frame;
d469 1
a469 3
nge_mii_writereg(sc, frame)
	struct nge_softc		*sc;
	struct nge_mii_frame	*frame;
d513 1
a513 3
nge_miibus_readreg(dev, phy, reg)
	struct device		*dev;
	int			phy, reg;
d530 1
a530 3
nge_miibus_writereg(dev, phy, reg, data)
	struct device		*dev;
	int			phy, reg, data;
d547 1
a547 2
nge_miibus_statchg(dev)
	struct device		*dev;
d580 1
a580 2
nge_setmulti(sc)
	struct nge_softc	*sc;
d641 1
a641 2
nge_reset(sc)
	struct nge_softc	*sc;
d671 1
a671 4
nge_probe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d687 1
a687 3
nge_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d913 1
a913 2
nge_list_tx_init(sc)
	struct nge_softc	*sc;
d951 1
a951 2
nge_list_rx_init(sc)
	struct nge_softc	*sc;
d985 1
a985 4
nge_newbuf(sc, c, m)
	struct nge_softc	*sc;
	struct nge_desc		*c;
	struct mbuf		*m;
d1030 1
a1030 2
nge_alloc_jumbo_mem(sc)
	struct nge_softc	*sc;
d1130 1
a1130 2
nge_jalloc(sc)
	struct nge_softc	*sc;
d1149 1
a1149 4
nge_jfree(buf, size, arg)
	caddr_t		buf;
	u_int		size;
	void		*arg;
d1189 1
a1189 2
nge_rxeof(sc)
	struct nge_softc	*sc;
d1312 1
a1312 2
nge_txeof(sc)
	struct nge_softc	*sc;
d1366 1
a1366 2
nge_tick(xsc)
	void			*xsc;
d1444 1
a1444 2
nge_intr(arg)
	void			*arg;
d1532 1
a1532 4
nge_encap(sc, m_head, txidx)
	struct nge_softc	*sc;
	struct mbuf		*m_head;
	u_int32_t		*txidx;
d1593 1
a1593 2
nge_start(ifp)
	struct ifnet		*ifp;
d1647 1
a1647 2
nge_init(xsc)
	void			*xsc;
d1832 1
a1832 2
nge_ifmedia_mii_upd(ifp)
	struct ifnet		*ifp;
d1855 1
a1855 3
nge_ifmedia_mii_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
d1871 1
a1871 2
nge_ifmedia_tbi_upd(ifp)
	struct ifnet		*ifp;
d1920 1
a1920 3
nge_ifmedia_tbi_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
d1969 1
a1969 4
nge_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
d2050 1
a2050 2
nge_watchdog(ifp)
	struct ifnet		*ifp;
d2073 1
a2073 2
nge_stop(sc)
	struct nge_softc	*sc;
@


1.75
log
@get rid of the copy argument in m_devget that let you provide an
alternative to bcopy since noone uses it.

while there use memcpy instead of bcopy because we know the memory cannot
overlap.

ok henning@@ matthew@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.74 2013/08/07 01:06:36 bluhm Exp $	*/
d815 1
a815 1
		printf("%s: can't map dma buffers (%d bytes)\n",
d1087 1
a1087 1
		printf("%s: can't map dma buffers (%d bytes)\n",
@


1.74
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.73 2012/11/29 21:10:32 brad Exp $	*/
d1298 1
a1298 1
			    ETHER_ALIGN, ifp, NULL);
@


1.73
log
@Remove setting an initial assumed baudrate upon driver attach which is not
necessarily correct, there might not even be a link when attaching.

ok mikeb@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.72 2012/10/18 21:44:21 deraadt Exp $	*/
a109 1
#include <netinet/in_var.h>
@


1.72
log
@Convert a number of old private copies of code which predates
pci_set_powerstate() to using it instead.  Many of these chunks of code had
bugs in them, especially missing delay() calls.  Some of them were doing
things our PCI subsystem is now responsible for handling.  If you have
any of the affected devices, please keep an eye out for regressions.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.71 2011/06/22 16:44:27 tedu Exp $	*/
a850 1
	ifp->if_baudrate = 1000000000;
@


1.71
log
@kill a few more casts that aren't helpful.  ok krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.70 2010/09/20 07:40:38 deraadt Exp $	*/
a731 1
	pcireg_t		command;
d738 1
a738 29
	/*
	 * Handle power management nonsense.
	 */
	DPRINTFN(5, ("%s: preparing for conf read\n", sc->sc_dv.dv_xname));
	command = pci_conf_read(pc, pa->pa_tag, NGE_PCI_CAPID) & 0x000000FF;
	if (command == 0x01) {
		command = pci_conf_read(pc, pa->pa_tag, NGE_PCI_PWRMGMTCTRL);
		if (command & NGE_PSTATE_MASK) {
			pcireg_t	iobase, membase, irq;

			/* Save important PCI config data. */
			iobase = pci_conf_read(pc, pa->pa_tag, NGE_PCI_LOIO);
			membase = pci_conf_read(pc, pa->pa_tag, NGE_PCI_LOMEM);
			irq = pci_conf_read(pc, pa->pa_tag, NGE_PCI_INTLINE);

			/* Reset the power state. */
			printf("%s: chip is in D%d power mode "
			       "-- setting to D0\n", sc->sc_dv.dv_xname,
			       command & NGE_PSTATE_MASK);
			command &= 0xFFFFFFFC;
			pci_conf_write(pc, pa->pa_tag,
				       NGE_PCI_PWRMGMTCTRL, command);

			/* Restore PCI config data. */
			pci_conf_write(pc, pa->pa_tag, NGE_PCI_LOIO, iobase);
			pci_conf_write(pc, pa->pa_tag, NGE_PCI_LOMEM, membase);
			pci_conf_write(pc, pa->pa_tag, NGE_PCI_INTLINE, irq);
		}
	}
@


1.70
log
@Stop doing shutdown hooks in network drivers where possible.  We already
take all interfaces down, via their xxstop routines.  Claudio and I have
verified that none of the shutdown hooks do much extra beyond what xxstop
was already doing; it is largely a pile of junk.
ok claudio, some early comments by sthen; also read by matthew, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.69 2010/05/19 15:27:35 oga Exp $	*/
d543 1
a543 1
	bzero((char *)&frame, sizeof(frame));
d563 1
a563 1
	bzero((char *)&frame, sizeof(frame));
d831 1
a831 1
	bcopy(eaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);
d2205 1
a2205 1
	bzero((char *)&sc->nge_ldata->nge_rx_list,
d2218 1
a2218 1
	bzero((char *)&sc->nge_ldata->nge_tx_list,
@


1.69
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.68 2009/08/13 14:24:47 jasper Exp $	*/
a156 1
void nge_shutdown(void *);
a2219 14
}

/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
void
nge_shutdown(xsc)
	void *xsc;
{
	struct nge_softc *sc = (struct nge_softc *)xsc;

	nge_reset(sc);
	nge_stop(sc);
@


1.68
log
@- consistify cfdriver for the ethernet drivers (0 -> NULL)

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.67 2008/11/28 02:44:18 brad Exp $	*/
d837 2
a838 1
			     PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
a865 1
	bzero(sc->nge_ldata, sizeof(struct nge_list_data));
@


1.67
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.66 2008/11/09 15:08:26 naddy Exp $	*/
d2242 1
a2242 1
	0, "nge", DV_IFNET
@


1.66
log
@Introduce bpf_mtap_ether(), which for the benefit of bpf listeners
creates the VLAN encapsulation from the tag stored in the mbuf
header.  Idea from FreeBSD, input from claudio@@ and canacar@@.

Switch all hardware VLAN enabled drivers to the new function.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.65 2008/10/28 22:45:20 brad Exp $	*/
d2064 1
a2065 1
	struct ifaddr		*ifa = (struct ifaddr *)data;
a2071 6
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ifp->if_hardmtu)
			error = EINVAL;
		else if (ifp->if_mtu != ifr->ifr_mtu)
			ifp->if_mtu = ifr->ifr_mtu;
		break;
d2086 1
a2113 5
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI)
			? ether_addmulti(ifr, &sc->arpcom)
			: ether_delmulti(ifr, &sc->arpcom);
a2114 6
		if (error == ENETRESET) {
			if (ifp->if_flags & IFF_RUNNING)
				nge_setmulti(sc);
			error = 0;
		}
		break;
d2126 1
d2129 6
@


1.65
log
@#if NVLAN > 0 in one more spot.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.64 2008/10/28 07:01:56 brad Exp $	*/
d1360 1
a1360 1
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
d1712 1
a1712 1
			bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
@


1.64
log
@Implement a workaround for stupid hw when using VLAN stripping.  Frames
that are 64 bytes with a VLAN header appended like ARP frames or ICMP
echos are flagged as runts when the tag is stripped.

Issue mentioned by yongari@@FreeBSD, info gleaned from the Linux driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.63 2008/10/28 05:04:32 brad Exp $	*/
d1275 1
a1275 1
	while(NGE_OWNDESC(&sc->nge_ldata->nge_rx_list[i])) {
d1347 1
d1353 1
@


1.63
log
@Don't need NVLAN > 0 checks around this code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.62 2008/10/28 04:32:23 brad Exp $	*/
d1294 17
a1310 3
			ifp->if_ierrors++;
			nge_newbuf(sc, cur_rx, m);
			continue;
@


1.62
log
@Re-add support TX VLAN tag insertion and RX VLAN tag stripping.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.61 2008/10/16 19:18:03 naddy Exp $	*/
a1806 1
#if NVLAN > 0
a1814 1
#endif
a1818 1
#if NVLAN > 0
a1825 1
#endif
@


1.61
log
@Switch the existing TX VLAN hardware support over to having the
tag in the header.  Convert TX tagging in the drivers.

Help and ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.60 2008/10/15 19:12:18 blambert Exp $	*/
d890 1
a890 1
#ifdef NGE_VLAN
d1333 6
d1637 1
a1637 1
		    (NGE_TXEXTSTS_VLANPKT|m_head->m_pkthdr.ether_vtag);
d1806 11
@


1.60
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.59 2008/10/02 20:21:14 brad Exp $	*/
a1595 7
#if NVLAN > 0
	struct ifvlan		*ifv = NULL;

	if ((m_head->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&
	    m_head->m_pkthdr.rcvif != NULL)
		ifv = m_head->m_pkthdr.rcvif->if_softc;
#endif
d1629 1
a1629 1
	if (ifv != NULL) {
d1631 1
a1631 1
			(NGE_TXEXTSTS_VLANPKT|ifv->ifv_tag);
@


1.59
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.58 2008/05/23 08:49:27 brad Exp $	*/
d953 1
a953 1
	timeout_add(&sc->nge_timeout, hz);
d1433 1
a1433 1
	timeout_add(&sc->nge_timeout, hz);
@


1.58
log
@Simplify the combination use of pci_mapreg_type()/pci_mapreg_map() as
suggested by dlg@@ awhile ago.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.57 2007/11/26 09:28:33 martynas Exp $	*/
a2048 5
	if ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {
		splx(s);
		return (error);
	}

d2121 1
a2121 2
		error = ENOTTY;
		break;
a2124 1

@


1.57
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.56 2006/10/25 02:37:50 brad Exp $	*/
d785 2
a786 8
	switch (memtype) {
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
		if (pci_mapreg_map(pa, NGE_PCI_LOMEM,
				   memtype, 0, &sc->nge_btag, &sc->nge_bhandle,
				   NULL, &size, 0) == 0)
			break;
	default:
@


1.56
log
@replace a few more instances of hand rolled code with the
LIST_FOREACH macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.55 2006/05/28 00:20:21 brad Exp $	*/
d1516 1
a1516 1
	/* Supress unwanted interrupts */
@


1.55
log
@- remove ETHER_MAX_LEN_JUMBO and ETHERMTU_JUMBO.
- use if_hardmtu for MTU ioctl handlers.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.54 2006/05/28 00:04:24 jason Exp $	*/
d1910 2
a1911 3
		struct mii_softc	*miisc;
		for (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;
		     miisc = LIST_NEXT(miisc, mii_list))
@


1.54
log
@unknown ioctl is ENOTTY not EINVAL
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.53 2006/05/27 10:03:15 brad Exp $	*/
d888 1
a888 1
	ifp->if_hardmtu = ETHERMTU_JUMBO;
d2063 1
a2063 1
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ETHERMTU_JUMBO)
@


1.53
log
@remove IFCAP_JUMBO_MTU interface capabilities flag and set if_hardmtu in a few
more drivers.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.52 2006/05/20 03:47:56 brad Exp $	*/
d2133 1
a2133 1
		error = EINVAL;
@


1.52
log
@set if_jumbo_mtu and the IFCAP_JUMBO_MTU capabilities flag where
appropriate.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.51 2006/03/25 22:41:45 djm Exp $	*/
d888 1
d894 1
a894 1
	ifp->if_capabilities = IFCAP_VLAN_MTU | IFCAP_JUMBO_MTU;
@


1.51
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.50 2006/03/04 04:40:57 brad Exp $	*/
d893 1
a893 1
	ifp->if_capabilities = IFCAP_VLAN_MTU;
@


1.50
log
@remove the colon between "address" and the MAC address.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.49 2006/02/16 20:54:35 brad Exp $	*/
d1343 1
a1343 1
			bpf_mtap(ifp->if_bpf, m);
d1702 1
a1702 1
			bpf_mtap(ifp->if_bpf, m_head);
@


1.49
log
@Do not bother enabling HW TX checksum offload since the code to
support this feature was removed awhile ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.48 2005/11/23 11:30:14 mickey Exp $	*/
d836 1
a836 1
	printf(", address: %s\n", ether_sprintf(eaddr));
@


1.48
log
@assume vtophys(vaddr_t) just what all the other archs expect; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.47 2005/11/04 17:22:05 brad Exp $	*/
d895 4
d1775 1
a1775 1
	if (ifp->if_flags & IFF_PROMISC) {
d1777 1
a1777 1
	} else {
a1778 1
	}
d1783 1
a1783 1
	if (ifp->if_flags & IFF_BROADCAST) {
d1785 1
a1785 1
	} else {
a1786 1
	}
a1814 5

	/*
	 * Enable TX IPv4 checksumming on a per-packet basis.
	 */
	CSR_WRITE_4(sc, NGE_VLAN_IP_TXCTL, NGE_VIPTXCTL_CSUM_PER_PKT);
@


1.47
log
@- splimp -> splnet
- remove spl from attach
- fix dmesg printing
- de-allocate resources on failure to attach
- remove redundant checks just before pci_mapreg_map()
- use pci_mapreg_type()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.46 2005/10/09 04:44:45 brad Exp $	*/
d125 1
d993 1
a993 1
			    vtophys(&ld->nge_tx_list[0]);
d998 1
a998 1
			    vtophys(&ld->nge_tx_list[i + 1]);
d1034 1
a1034 1
			    vtophys(&ld->nge_rx_list[0]);
d1039 1
a1039 1
			    vtophys(&ld->nge_rx_list[i + 1]);
d1090 1
a1090 1
	c->nge_ptr = vtophys(mtod(m_new, caddr_t));
d1620 1
a1620 1
			f->nge_ptr = vtophys(mtod(m, vaddr_t));
d1798 1
a1798 1
	    vtophys(&sc->nge_ldata->nge_rx_list[0]));
d1800 1
a1800 1
	    vtophys(&sc->nge_ldata->nge_tx_list[0]));
@


1.46
log
@fix bus_dmamem_alloc() failure case.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.45 2005/09/11 18:17:08 mickey Exp $	*/
d402 1
a402 1
	s = splimp();
d494 1
a494 1
	s = splimp();
d727 1
a727 1
	bus_size_t		iosize;
d730 1
a730 1
	int			s, rseg;
d732 4
a735 1
	u_int32_t		command;
a736 1
	int			error = 0;
a738 2
	s = splimp();

a772 1
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
a774 9
	if (!(command & PCI_COMMAND_IO_ENABLE)) {
		printf("%s: failed to enable I/O ports!\n",
		       sc->sc_dv.dv_xname);
		error = ENXIO;
		goto fail;
	}
	/*
	 * Map control/status registers.
	 */
d777 1
a777 1
	    &sc->nge_btag, &sc->nge_bhandle, NULL, &iosize, 0)) {
d779 1
a779 1
		goto fail;
a781 6
	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf("%s: failed to enable memory mapping!\n",
		       sc->sc_dv.dv_xname);
		error = ENXIO;
		goto fail;
	}
d783 9
a791 2
	if (pci_mapreg_map(pa, NGE_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->nge_btag, &sc->nge_bhandle, NULL, &iosize, 0)) {
d793 1
a793 1
		goto fail;
d835 1
a835 1
	printf(": address: %s\n", ether_sprintf(eaddr));
d844 1
a844 1
		goto fail_1;
d852 1
a852 2
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		goto fail_1;
d859 1
a859 4
		bus_dmamem_unmap(sc->sc_dmatag, kva,
				 sizeof(struct nge_list_data));
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		goto fail_1;
d865 1
a865 5
		bus_dmamap_destroy(sc->sc_dmatag, dmamap);
		bus_dmamem_unmap(sc->sc_dmatag, kva,
				 sizeof(struct nge_list_data));
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		goto fail_1;
d877 1
a877 1
		goto fail_1;
d954 14
d970 1
a970 3
	bus_space_unmap(sc->nge_btag, sc->nge_bhandle, iosize);
fail:
	splx(s);
d1428 1
a1428 1
	s = splimp();
d1726 1
a1726 1
	s = splimp();
d2055 1
a2055 1
	s = splimp();
d2100 1
@


1.45
log
@do not inline pci_mapreg_map() anymore as it is olrite now; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.44 2005/08/09 04:10:12 mickey Exp $	*/
d1118 1
a1118 2
		error = ENOBUFS;
		goto out;
@


1.44
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.43 2005/07/30 04:25:00 brad Exp $	*/
a726 1
	bus_addr_t		iobase;
d747 1
a747 1
			u_int32_t		iobase, membase, irq;
d785 3
a787 7
	DPRINTFN(5, ("%s: pci_io_find\n", sc->sc_dv.dv_xname));
	if (pci_io_find(pc, pa->pa_tag, NGE_PCI_LOIO, &iobase, &iosize)) {
		printf(": can't find i/o space\n");
		goto fail;
	}
	DPRINTFN(5, ("%s: bus_space_map\n", sc->sc_dv.dv_xname));
	if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->nge_bhandle)) {
a790 1
	sc->nge_btag = pa->pa_iot;
d798 3
a800 8
	DPRINTFN(5, ("%s: pci_mem_find\n", sc->sc_dv.dv_xname));
	if (pci_mem_find(pc, pa->pa_tag, NGE_PCI_LOMEM, &iobase,
			 &iosize, NULL)) {
		printf(": can't find mem space\n");
		goto fail;
	}
	DPRINTFN(5, ("%s: bus_space_map\n", sc->sc_dv.dv_xname));
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->nge_bhandle)) {
a803 2

	sc->nge_btag = pa->pa_memt;
d812 1
a812 1
		goto fail;
d825 1
a825 1
		goto fail;
d853 1
a853 1
		goto fail;
d862 1
a862 1
		goto fail;
d872 1
a872 1
		goto fail;
d882 1
a882 1
		goto fail;
d894 1
a894 1
		goto fail;
d972 2
@


1.43
log
@sync nge/ti_alloc_jumbo_mem() to look like bge's bge_alloc_jumbo_mem()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.42 2005/07/25 00:49:44 brad Exp $	*/
a773 4
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	  PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
@


1.42
log
@don't bother with printf in *_jalloc()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.41 2005/07/09 23:18:53 brad Exp $	*/
d1125 1
a1125 1
	int			i, rseg;
d1128 2
d1133 2
a1134 1
		return (ENOBUFS);
d1136 2
d1142 2
a1143 2
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		return (ENOBUFS);
d1145 2
d1150 2
a1151 3
		bus_dmamem_unmap(sc->sc_dmatag, kva, NGE_JMEM);
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		return (ENOBUFS);
d1153 2
d1158 2
a1159 4
		bus_dmamap_destroy(sc->sc_dmatag, dmamap);
		bus_dmamem_unmap(sc->sc_dmatag, kva, NGE_JMEM);
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		return (ENOBUFS);
d1161 2
a1186 4
			bus_dmamap_unload(sc->sc_dmatag, dmamap);
			bus_dmamap_destroy(sc->sc_dmatag, dmamap);
			bus_dmamem_unmap(sc->sc_dmatag, kva, NGE_JMEM);
			bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
d1190 2
a1191 1
			return(ENOBUFS);
d1197 18
a1214 2

	return(0);
@


1.41
log
@remove code for TX checksum
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.40 2005/07/09 22:26:14 brad Exp $	*/
d1207 2
a1208 6
	if (entry == NULL) {
#ifdef NGE_VERBOSE
		printf("%s: no free jumbo buffers\n", sc->sc_dv.dv_xname);
#endif
		return(NULL);
	}
@


1.40
log
@don't clear RUNNING here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.39 2005/07/09 22:14:27 brad Exp $	*/
a1636 4
	/*
	 * Card handles checksumming on a packet by packet
	 * basis.
	 */
a1637 11
	if (m_head->m_pkthdr.csum_flags) {
		if (m_head->m_pkthdr.csum_flags & M_IPV4_CSUM_OUT)
			sc->nge_ldata->nge_tx_list[*txidx].nge_extsts |=
			    NGE_TXEXTSTS_IPCSUM;
		if (m_head->m_pkthdr.csum_flags & M_TCPV4_CSUM_OUT)
			sc->nge_ldata->nge_tx_list[*txidx].nge_extsts |=
			    NGE_TXEXTSTS_TCPCSUM;
		if (m_head->m_pkthdr.csum_flags & M_UDPV4_CSUM_OUT)
			sc->nge_ldata->nge_tx_list[*txidx].nge_extsts |=
			    NGE_TXEXTSTS_UDPCSUM;
	}
@


1.39
log
@better
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.38 2005/07/09 22:09:39 brad Exp $	*/
a2118 1
				ifp->if_flags &= ~IFF_RUNNING;
@


1.38
log
@- mbuf external storage is of (caddr_t), not (caddr_t *).
- simplify code a bit and use MEXTADD macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.37 2005/07/09 20:57:18 brad Exp $	*/
d2085 1
a2085 1
		else
@


1.37
log
@fix SIOCSIFMTU
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.36 2005/07/09 20:53:08 brad Exp $	*/
a1076 1
	caddr_t			*buf = NULL;
d1079 2
d1083 1
a1083 1
			return(ENOBUFS);
d1089 1
a1089 1
			return(ENOBUFS);
d1091 1
d1093 2
a1094 7
		m_new->m_data = m_new->m_ext.ext_buf = (void *)buf;
		m_new->m_flags |= M_EXT;
		m_new->m_ext.ext_size = m_new->m_pkthdr.len =
			m_new->m_len = NGE_MCLBYTES;
		m_new->m_ext.ext_free = nge_jfree;
		m_new->m_ext.ext_arg = sc;
		MCLINITREFERENCE(m_new);
d1096 5
@


1.36
log
@- disable TX checksum offload since this chip has a bug where
  it'll wedge if you try to transmit a Jumbo frame larger than
  8152 bytes.
- Rip out VLAN stripping support. From camiel@@
- Only set Ok flags for receive checksum offload otherwise
  fallback on software.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.35 2005/07/02 23:10:11 brad Exp $	*/
d2081 1
a2081 1
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu < ETHERMTU_JUMBO)
@


1.35
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.34 2005/05/25 21:01:17 brad Exp $	*/
a922 5
	ifp->if_capabilities =
	    IFCAP_CSUM_IPv4 | IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4;
#if NVLAN > 0
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
#endif
d926 2
d1345 1
a1345 3
			if (extsts & NGE_RXEXTSTS_IPCSUMERR)
				m->m_pkthdr.csum_flags |= M_IPV4_CSUM_IN_BAD;
			else
d1347 2
a1348 5
		}
		if (extsts & NGE_RXEXTSTS_TCPPKT) {
			if (extsts & NGE_RXEXTSTS_TCPCSUMERR)
				m->m_pkthdr.csum_flags |= M_TCP_CSUM_IN_BAD;
			else
d1350 2
a1351 5
		}
		if (extsts & NGE_RXEXTSTS_UDPPKT) {
			if (extsts & NGE_RXEXTSTS_UDPCSUMERR)
				m->m_pkthdr.csum_flags |= M_UDP_CSUM_IN_BAD;
			else
a1354 12
#if NVLAN > 0
		/*
		 * If we received a packet with a vlan tag, pass it
		 * to vlan_input() instead of ether_input().
		 */
		if (extsts & NGE_RXEXTSTS_VLANPKT) {
			if (vlan_input_tag(m, extsts & NGE_RXEXTSTS_VTCI) < 0)
				ifp->if_data.ifi_noproto++;
                        continue;
                }
#endif

a1826 11
#if NVLAN > 0
	/*
	 * If VLAN support is enabled, tell the chip to detect
	 * and strip VLAN tag info from received frames. The tag
	 * will be provided in the extsts field in the RX descriptors.
	 */
	if (ifp->if_capabilities & IFCAP_VLAN_HWTAGGING)
		NGE_SETBIT(sc, NGE_VLAN_IP_RXCTL,
		    NGE_VIPRXCTL_TAG_DETECT_ENB|NGE_VIPRXCTL_TAG_STRIP_ENB);
#endif

d2081 1
a2081 1
		if (ifr->ifr_mtu > ETHERMTU_JUMBO || ifr->ifr_mtu < ETHERMIN)
d2083 1
a2083 1
		else {
a2084 12
			/*
			 * Workaround: if the MTU is larger than
			 * 8152 (TX FIFO size minus 64 minus 18), turn off
			 * TX checksum offloading.
			 */
			if (ifr->ifr_mtu >= 8152)
				ifp->if_capabilities &= ~(IFCAP_CSUM_IPv4 |
				    IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4);
			else
				ifp->if_capabilities = IFCAP_CSUM_IPv4 |
					IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4;
		}
@


1.34
log
@Fix instances of macros with improperly parenthasized arguments.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.33 2005/05/25 20:59:04 brad Exp $	*/
d2247 3
a2285 2

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.33
log
@- Fixed resetting of the watchdog timer and queue full flag.
- When reading PHY regs over the i2c bus, the turnaround ACK bit
  is read one clock edge too late. This bit is driven low by
  slave (as any other input data bits from slave) when the clock
  is LOW. The current code did read the bit after the clock was
  driven high again.
- Do not call mii_pollstat() from within device tick routines; the status
  information is updated by mii_tick().

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.32 2005/04/25 17:55:51 brad Exp $	*/
d208 1
a208 1
	CSR_WRITE_4(sc, NGE_MEAR, CSR_READ_4(sc, NGE_MEAR) | x)
d211 1
a211 1
	CSR_WRITE_4(sc, NGE_MEAR, CSR_READ_4(sc, NGE_MEAR) & ~x)
@


1.32
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.31 2005/02/17 18:07:36 jfb Exp $	*/
d440 1
a442 1
	ack = CSR_READ_4(sc, NGE_MEAR) & NGE_MEAR_MII_DATA;
d1393 1
a1393 1
	struct nge_desc		*cur_tx = NULL;
a1398 3
	/* Clear the timeout timer. */
	ifp->if_timer = 0;

d1431 1
a1435 1
		ifp->if_timer = 0;
d1440 2
a1441 2
	if (cur_tx != NULL)
		ifp->if_flags &= ~IFF_OACTIVE;
a1507 1
		mii_pollstat(mii);
@


1.31
log
@miscellaneous typo fixes:
- sturct -> struct (spotted by pedro)
- elimination of consecutive 'the' words

ok jmc@@, henning@@, krw@@, robert@@, some whining by jolan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.30 2004/09/23 17:45:16 brad Exp $	*/
d1349 1
a1349 1
				m->m_pkthdr.csum |= M_IPV4_CSUM_IN_BAD;
d1351 1
a1351 1
				m->m_pkthdr.csum |= M_IPV4_CSUM_IN_OK;
d1355 1
a1355 1
				m->m_pkthdr.csum |= M_TCP_CSUM_IN_BAD;
d1357 1
a1357 1
				m->m_pkthdr.csum |= M_TCP_CSUM_IN_OK;
d1361 1
a1361 1
				m->m_pkthdr.csum |= M_UDP_CSUM_IN_BAD;
d1363 1
a1363 1
				m->m_pkthdr.csum |= M_UDP_CSUM_IN_OK;
d1667 2
a1668 2
	if (m_head->m_pkthdr.csum) {
		if (m_head->m_pkthdr.csum & M_IPV4_CSUM_OUT)
d1671 1
a1671 1
		if (m_head->m_pkthdr.csum & M_TCPV4_CSUM_OUT)
d1674 1
a1674 1
		if (m_head->m_pkthdr.csum & M_UDPV4_CSUM_OUT)
@


1.30
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.29 2004/08/05 19:57:17 brad Exp $	*/
d1167 1
a1167 1
	 * the first few bytes in the buffer to hold the the address
@


1.29
log
@remove some separate per driver constants and use
ETHER_MAX_LEN_JUMBO/ETHERMTU_JUMBO where appropriate.

ok mcbride@@ henning@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.28 2004/05/30 01:51:51 mcbride Exp $	*/
a915 1
	ifp->if_mtu = ETHERMTU;
a917 1
	ifp->if_output = ether_output;
@


1.28
log
@Multicast fixups:
- remove bogus use of LLADDR
- scrap nge_crc in favour of ether_crc32_be
- accept all multicast when we encounter a multicast range

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.27 2004/04/09 21:52:17 henning Exp $	*/
d2121 1
a2121 1
		if (ifr->ifr_mtu > NGE_JUMBO_MTU || ifr->ifr_mtu < ETHERMIN)
@


1.27
log
@do not whine if we cannot get mbufs. the countless printfd makes the machine
crawl under mbuf starvation, making the situationmuch worse, and don't make
sense in the first place.
ok tdeval@@ millert@@ beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.26 2003/08/06 21:08:07 millert Exp $	*/
a177 1
u_int32_t nge_crc(struct nge_softc *, caddr_t);
a604 30
u_int32_t
nge_crc(sc, addr)
	struct nge_softc	*sc;
	caddr_t			addr;
{
	u_int32_t		crc, carry;
	int			i, j;
	u_int8_t		c;

	/* Compute CRC for the address value. */
	crc = 0xFFFFFFFF; /* initial value */

	for (i = 0; i < 6; i++) {
		c = *(addr + i);
		for (j = 0; j < 8; j++) {
			carry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);
			crc <<= 1;
			c >>= 1;
			if (carry)
				crc = (crc ^ 0x04c11db6) | carry;
		}
	}

	/*
	 * return the filter bit position
	 */

	return((crc >> 21) & 0x00000FFF);
}

d616 1
d650 6
a655 1
		h = nge_crc(sc, LLADDR((struct sockaddr_dl *)enm->enm_addrlo));
@


1.26
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.25 2003/01/15 06:31:24 art Exp $	*/
d1111 1
a1111 3
		if (m_new == NULL) {
			printf("%s: no memory for rx list "
			       "-- packet dropped!\n", sc->sc_dv.dv_xname);
a1112 1
		}
a1116 4
#ifdef NGE_VERBOSE
			printf("%s: jumbo allocation failed "
			       "-- packet dropped!\n", sc->sc_dv.dv_xname);
#endif
a1350 3
				printf("%s: no receive buffers "
				    "available -- packet dropped!\n",
				    sc->sc_dv.dv_xname);
@


1.25
log
@Get rid of the remaining vm_offset_t in pci drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.24 2002/11/26 06:01:28 nate Exp $	*/
d809 1
a809 1
		error = ENXIO;;
@


1.24
log
@1000baseTX -> 1000baseT
- More technically correct
- Matches FreeBSD and NetBSD
- Preserved #define for 1000baseTX for backwards compatibility
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.23 2002/09/22 17:53:43 nate Exp $	*/
d1685 1
a1685 1
			f->nge_ptr = vtophys(mtod(m, vm_offset_t));
@


1.23
log
@use #ifndef __STRICT_ALIGNMENT instead of #ifdef __i386.
recommended by jason
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.22 2002/09/21 15:29:46 nate Exp $	*/
d600 1
a600 1
	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_TX)
d1552 1
a1552 1
			if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_TX)
@


1.22
log
@Add support for TBI mode in fiber based cards (heavily inspired by FreeBSD)
Clean up debugging printfs
Remove some old debugging code that shouldn't be there.
More changes from FreeBSD:
- ignore alignment problem on x86 platforms and don't copy.
- increase receive list to 128 to match transmit
- change a bit in the interrupt handling
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.21 2002/09/21 15:05:49 nate Exp $	*/
d1343 1
a1343 1
#ifdef __i386__
d1366 1
a1366 1
#ifdef __i386__
@


1.21
log
@cleanup, remove register
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.20 2002/07/10 18:08:13 deraadt Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/dev/nge/if_nge.c,v 1.19 2001/07/25 00:19:55 brooks Exp $
a147 1
void nge_rxeoc(struct nge_softc *);
d157 4
a160 2
int nge_ifmedia_upd(struct ifnet *);
void nge_ifmedia_sts(struct ifnet *, struct ifmediareq *);
d542 2
d562 2
d578 7
d587 2
a588 3
		NGE_SETBIT(sc, NGE_TX_CFG,
		    (NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR));
		NGE_SETBIT(sc, NGE_RX_CFG, NGE_RXCFG_RX_FDX);
d590 2
a591 3
		NGE_CLRBIT(sc, NGE_TX_CFG,
		    (NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR));
		NGE_CLRBIT(sc, NGE_RX_CFG, NGE_RXCFG_RX_FDX);
d594 7
a600 2
	switch (IFM_SUBTYPE(sc->nge_mii.mii_media_active)) {
	case IFM_1000_TX:  /* Gigabit using GMII interface */
d602 1
a602 6
		NGE_CLRBIT(sc, NGE_CFG, NGE_CFG_TBI_EN);
		break;

	case IFM_1000_SX:  /* Gigabit using TBI interface */
	case IFM_1000_CX:
	case IFM_1000_LX:
a603 9
		NGE_SETBIT(sc, NGE_CFG, NGE_CFG_TBI_EN);
		break;

	default: /* Default to MII interface */
		NGE_CLRBIT(sc, NGE_CFG, NGE_CFG_MODE_1000|
			   NGE_CFG_TBI_EN);
		break;
	}

d662 1
a662 1
		   NGE_RXFILTCTL_ALLMULTI|NGE_RXFILTCTL_UCHASH);
a737 2
struct nge_softc *my_nge_softc;

a763 1
	my_nge_softc = sc;
d768 1
a768 1
	DPRINTFN(5, ("Preparing for conf read\n"));
d798 1
a798 1
	DPRINTFN(5, ("Map control/status regs\n"));
d815 1
a815 1
	DPRINTFN(5, ("pci_io_find\n"));
d820 1
a820 1
	DPRINTFN(5, ("bus_space_map\n"));
d833 1
a833 1
	DPRINTFN(5, ("pci_mem_find\n"));
d839 1
a839 1
	DPRINTFN(5, ("bus_space_map\n"));
d848 4
a851 1
	DPRINTFN(5, ("pci_intr_map\n"));
d857 1
a857 1
	DPRINTFN(5, ("pci_intr_string\n"));
d859 1
a859 1
	DPRINTFN(5, ("pci_intr_establish\n"));
d872 1
a872 1
	DPRINTFN(5, ("nge_reset\n"));
d878 1
a878 1
	DPRINTFN(5, ("nge_read_eeprom\n"));
d891 1
a891 1
	DPRINTFN(5, ("bus_dmamem_alloc\n"));
d897 1
a897 1
	DPRINTFN(5, ("bus_dmamem_map\n"));
d906 1
a906 1
	DPRINTFN(5, ("bus_dmamem_create\n"));
d916 1
a916 1
	DPRINTFN(5, ("bus_dmamem_load\n"));
d927 1
a927 1
	DPRINTFN(5, ("bzero\n"));
d932 1
a932 1
	DPRINTFN(5, ("nge_alloc_jumbo_mem\n"));
d955 1
a955 1
	DPRINTFN(5, ("bcopy\n"));
d961 45
a1005 15
	DPRINTFN(5, ("mii setup\n"));
	sc->nge_mii.mii_ifp = ifp;
	sc->nge_mii.mii_readreg = nge_miibus_readreg;
	sc->nge_mii.mii_writereg = nge_miibus_writereg;
	sc->nge_mii.mii_statchg = nge_miibus_statchg;
	ifmedia_init(&sc->nge_mii.mii_media, 0, nge_ifmedia_upd,
		     nge_ifmedia_sts);
	mii_attach(&sc->sc_dv, &sc->nge_mii, 0xffffffff, MII_PHY_ANY,
		   MII_OFFSET_ANY, 0);

	if (LIST_FIRST(&sc->nge_mii.mii_phys) == NULL) {
		printf("%s: no PHY found!\n", sc->sc_dv.dv_xname);
		ifmedia_add(&sc->nge_mii.mii_media, IFM_ETHER|IFM_MANUAL,
		    0, NULL);
		ifmedia_set(&sc->nge_mii.mii_media, IFM_ETHER|IFM_MANUAL);
a1006 2
	else
		ifmedia_set(&sc->nge_mii.mii_media, IFM_ETHER|IFM_AUTO);
d1011 1
a1011 1
	DPRINTFN(5, ("if_attach\n"));
d1013 1
a1013 1
	DPRINTFN(5, ("ether_ifattach\n"));
d1015 1
a1015 1
	DPRINTFN(5, ("timeout_set\n"));
d1145 2
a1146 1
	DPRINTFN(7,("c->nge_ptr = 0x%08X\n", c->nge_ptr));
d1191 3
a1193 2
	DPRINTFN(1,("nge_jumbo_buf = 0x%08X\n", sc->nge_cdata.nge_jumbo_buf));
	DPRINTFN(1,("NGE_MCLBYTES = 0x%08X\n", NGE_MCLBYTES));
a1337 1

d1343 27
a1369 9
		m0 = m_devget(mtod(m, char *) - ETHER_ALIGN,
		    total_len + ETHER_ALIGN, 0, ifp, NULL);
		nge_newbuf(sc, cur_rx, m);
		if (m0 == NULL) {
			printf("%s: no receive buffers "
			    "available -- packet dropped!\n",
			    sc->sc_dv.dv_xname);
			ifp->if_ierrors++;
			continue;
d1371 1
a1371 2
		m_adj(m0, ETHER_ALIGN);
		m = m0;
a1420 12
void
nge_rxeoc(sc)
	struct nge_softc	*sc;
{
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;
	nge_rxeof(sc);
	ifp->if_flags &= ~IFF_RUNNING;
	nge_init(sc);
}

d1495 17
a1511 1
	mii_tick(mii);
d1513 35
a1547 1
	if (!sc->nge_link) {
d1553 2
a1554 2
				DPRINTFN("%s: gigabit link up\n",
					 sc->sc_dv.dv_xname);
d1557 2
a1558 2
		} else
			timeout_add(&sc->nge_timeout, hz);
d1585 5
d1606 4
d1613 2
a1614 4
		if ((status & NGE_ISR_RX_ERR) ||
		    (status & NGE_ISR_RX_OFLOW)) {
			nge_rxeoc(sc);
		}
d1622 7
a1628 1
		if (status & NGE_ISR_PHY_INTR) {
d1632 1
d1641 5
d1686 2
a1687 1
			DPRINTFN(7,("f->nge_ptr = 0x%08X\n", f->nge_ptr));
d1707 1
a1707 1
				NGE_TXEXTSTS_IPCSUM;
d1710 1
a1710 1
				NGE_TXEXTSTS_TCPCSUM;
d1713 1
a1713 1
				NGE_TXEXTSTS_UDPCSUM;
a1793 2
int nge_loop = 0;

d1800 3
a1802 2
	struct mii_data		*mii = &sc->nge_mii;
	int			s;
a1812 1
	nge_reset(sc);
d1814 1
a1814 2
	/* Turn the receive filter off */
	NGE_CLRBIT(sc, NGE_RXFILT_CTL, NGE_RXFILTCTL_ENABLE);
d1903 1
a1903 2
	CSR_WRITE_4(sc, NGE_TX_CFG, NGE_TXCFG |
		    (nge_loop ? NGE_TXCFG_LOOPBK : 0));
d1921 14
a1934 4
	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX) {
		NGE_SETBIT(sc, NGE_TX_CFG,
		    (NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR));
		NGE_SETBIT(sc, NGE_RX_CFG, NGE_RXCFG_RX_FDX);
d1936 2
a1937 3
		NGE_CLRBIT(sc, NGE_TX_CFG,
		    (NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR));
		NGE_CLRBIT(sc, NGE_RX_CFG, NGE_RXCFG_RX_FDX);
d1940 7
d1956 10
a1965 1
	DPRINTFN("NGE_CFG: 0x%08X\n", CSR_READ_4(sc, NGE_CFG));
d1977 4
a1980 1
	nge_ifmedia_upd(ifp);
d1989 1
a1989 1
 * Set media options.
d1992 1
a1992 1
nge_ifmedia_upd(ifp)
d1996 3
a1998 1
	struct mii_data		*mii = &sc->nge_mii;
d2001 1
d2014 1
a2014 1
 * Report current media status.
d2017 1
a2017 1
nge_ifmedia_sts(ifp, ifmr)
d2022 3
a2024 1
	struct mii_data		*mii = &sc->nge_mii;
d2031 104
d2161 3
a2163 3
			 * If requested MTU is larger than the
			 * size of the TX buffer, turn off TX
			 * checksumming.
d2228 8
a2235 2
		mii = &sc->nge_mii;
		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);
d2277 1
a2277 3
	struct ifmedia_entry	*ifm;
	struct mii_data		*mii = &sc->nge_mii;
	int			mtmp, itmp;
d2281 5
d2295 2
a2296 13
	/*
	 * Isolate/power down the PHY, but leave the media selection
	 * unchanged so that things will be put back to normal when
	 * we bring the interface back up.
	 */
	itmp = ifp->if_flags;
	ifp->if_flags |= IFF_UP;
	ifm = mii->mii_media.ifm_cur;
	mtmp = ifm->ifm_media;
	ifm->ifm_media = IFM_ETHER|IFM_NONE;
	mii_mediachg(mii);
	ifm->ifm_media = mtmp;
	ifp->if_flags = itmp;
@


1.20
log
@shorten address printout
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.19 2002/07/05 13:48:11 aaron Exp $	*/
d213 2
a214 1
void nge_delay(sc)
d223 2
a224 1
void nge_eeprom_idle(sc)
d251 2
a252 1
void nge_eeprom_putbyte(sc, addr)
d256 1
a256 1
	register int		d, i;
d280 2
a281 1
void nge_eeprom_getword(sc, addr, dest)
d286 1
a286 1
	register int		i;
d326 2
a327 1
void nge_read_eeprom(sc, dest, off, cnt, swap)
d350 2
a351 1
void nge_mii_sync(sc)
d354 1
a354 1
	register int		i;
d369 2
a370 1
void nge_mii_send(sc, bits, cnt)
d395 2
a396 1
int nge_mii_readreg(sc, frame)
d487 2
a488 1
int nge_mii_writereg(sc, frame)
d533 2
a534 1
int nge_miibus_readreg(dev, phy, reg)
d550 2
a551 1
void nge_miibus_writereg(dev, phy, reg, data)
d567 2
a568 1
void nge_miibus_statchg(dev)
d605 2
a606 1
u_int32_t nge_crc(sc, addr)
d635 2
a636 1
void nge_setmulti(sc)
d691 2
a692 1
void nge_reset(sc)
d695 1
a695 1
	register int		i;
d722 2
a723 1
int nge_probe(parent, match, aux)
d743 2
a744 1
void nge_attach(parent, self, aux)
d997 2
a998 1
int nge_list_tx_init(sc)
d1036 2
a1037 1
int nge_list_rx_init(sc)
d1071 2
a1072 1
int nge_newbuf(sc, c, m)
d1123 2
a1124 1
int nge_alloc_jumbo_mem(sc)
d1203 2
a1204 1
void *nge_jalloc(sc)
d1227 2
a1228 1
void nge_jfree(buf, size, arg)
d1270 2
a1271 1
void nge_rxeof(sc)
d1374 2
a1375 1
void nge_rxeoc(sc)
d1391 2
a1392 1
void nge_txeof(sc)
d1449 2
a1450 1
void nge_tick(xsc)
d1479 2
a1480 1
int nge_intr(arg)
d1549 2
a1550 1
int nge_encap(sc, m_head, txidx)
d1634 2
a1635 1
void nge_start(ifp)
d1691 2
a1692 1
void nge_init(xsc)
d1862 2
a1863 1
int nge_ifmedia_upd(ifp)
d1884 2
a1885 1
void nge_ifmedia_sts(ifp, ifmr)
d1897 2
a1898 1
int nge_ioctl(ifp, command, data)
d2003 2
a2004 1
void nge_watchdog(ifp)
d2027 2
a2028 1
void nge_stop(sc)
d2031 1
a2031 1
	register int		i;
d2096 2
a2097 1
void nge_shutdown(xsc)
@


1.19
log
@Typo; stobe -> strobe
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.18 2002/03/14 01:26:59 millert Exp $	*/
d868 1
a868 1
	printf(": Ethernet address: %s\n", ether_sprintf(eaddr));
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.17 2002/03/12 09:51:20 kjc Exp $	*/
d258 1
a258 1
	 * Feed in each bit and stobe the clock.
@


1.17
log
@sync with KAME
ALTQify more drivers.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.16 2002/02/15 20:45:31 nordin Exp $	*/
d137 2
a138 2
int nge_probe		__P((struct device *, void *, void *));
void nge_attach		__P((struct device *, struct device *, void *));
d140 41
a180 41
int nge_alloc_jumbo_mem	__P((struct nge_softc *));
void *nge_jalloc	__P((struct nge_softc *));
void nge_jfree		__P((caddr_t, u_int, void *));

int nge_newbuf		__P((struct nge_softc *, struct nge_desc *,
			     struct mbuf *));
int nge_encap		__P((struct nge_softc *, struct mbuf *, u_int32_t *));
void nge_rxeof		__P((struct nge_softc *));
void nge_rxeoc		__P((struct nge_softc *));
void nge_txeof		__P((struct nge_softc *));
int nge_intr		__P((void *));
void nge_tick		__P((void *));
void nge_start		__P((struct ifnet *));
int nge_ioctl		__P((struct ifnet *, u_long, caddr_t));
void nge_init		__P((void *));
void nge_stop		__P((struct nge_softc *));
void nge_watchdog	__P((struct ifnet *));
void nge_shutdown	__P((void *));
int nge_ifmedia_upd	__P((struct ifnet *));
void nge_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));

void nge_delay		__P((struct nge_softc *));
void nge_eeprom_idle	__P((struct nge_softc *));
void nge_eeprom_putbyte	__P((struct nge_softc *, int));
void nge_eeprom_getword	__P((struct nge_softc *, int, u_int16_t *));
void nge_read_eeprom	__P((struct nge_softc *, caddr_t, int, int, int));

void nge_mii_sync	__P((struct nge_softc *));
void nge_mii_send	__P((struct nge_softc *, u_int32_t, int));
int nge_mii_readreg	__P((struct nge_softc *, struct nge_mii_frame *));
int nge_mii_writereg	__P((struct nge_softc *, struct nge_mii_frame *));

int nge_miibus_readreg	__P((struct device *, int, int));
void nge_miibus_writereg	__P((struct device *, int, int, int));
void nge_miibus_statchg	__P((struct device *));

void nge_setmulti	__P((struct nge_softc *));
u_int32_t nge_crc	__P((struct nge_softc *, caddr_t));
void nge_reset		__P((struct nge_softc *));
int nge_list_rx_init	__P((struct nge_softc *));
int nge_list_tx_init	__P((struct nge_softc *));
@


1.16
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.15 2001/11/13 21:00:16 mickey Exp $	*/
d930 2
a931 1
	ifp->if_snd.ifq_maxlen = NGE_TX_LIST_CNT - 1;
d1443 1
a1443 1
			if (ifp->if_snd.ifq_head != NULL)
d1511 1
a1511 1
	if (ifp->if_snd.ifq_head != NULL)
d1611 1
d1624 1
a1624 1
		IF_DEQUEUE(&ifp->if_snd, m_head);
a1628 1
			IF_PREPEND(&ifp->if_snd, m_head);
d1633 4
d1646 2
d1984 1
a1984 1
	if (ifp->if_snd.ifq_head != NULL)
@


1.15
log
@cleanup whole lots of spaces and tabs, while muffling
w/ the cards we have here and those are the cheapest
petrolleum product on the east cost, let me tell ya.
insert valid freebsd rcsid and a comment about bugs and such.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.14 2001/11/06 19:53:19 miod Exp $	*/
d1692 1
a1692 1
		(void)splx(s);
d1818 1
a1818 1
	(void)splx(s);
d1957 1
a1957 1
	(void)splx(s);
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.15 2001/11/13 21:00:16 mickey Exp $	*/
d137 2
a138 2
int nge_probe(struct device *, void *, void *);
void nge_attach(struct device *, struct device *, void *);
d140 41
a180 41
int nge_alloc_jumbo_mem(struct nge_softc *);
void *nge_jalloc(struct nge_softc *);
void nge_jfree(caddr_t, u_int, void *);

int nge_newbuf(struct nge_softc *, struct nge_desc *,
			     struct mbuf *);
int nge_encap(struct nge_softc *, struct mbuf *, u_int32_t *);
void nge_rxeof(struct nge_softc *);
void nge_rxeoc(struct nge_softc *);
void nge_txeof(struct nge_softc *);
int nge_intr(void *);
void nge_tick(void *);
void nge_start(struct ifnet *);
int nge_ioctl(struct ifnet *, u_long, caddr_t);
void nge_init(void *);
void nge_stop(struct nge_softc *);
void nge_watchdog(struct ifnet *);
void nge_shutdown(void *);
int nge_ifmedia_upd(struct ifnet *);
void nge_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void nge_delay(struct nge_softc *);
void nge_eeprom_idle(struct nge_softc *);
void nge_eeprom_putbyte(struct nge_softc *, int);
void nge_eeprom_getword(struct nge_softc *, int, u_int16_t *);
void nge_read_eeprom(struct nge_softc *, caddr_t, int, int, int);

void nge_mii_sync(struct nge_softc *);
void nge_mii_send(struct nge_softc *, u_int32_t, int);
int nge_mii_readreg(struct nge_softc *, struct nge_mii_frame *);
int nge_mii_writereg(struct nge_softc *, struct nge_mii_frame *);

int nge_miibus_readreg(struct device *, int, int);
void nge_miibus_writereg(struct device *, int, int, int);
void nge_miibus_statchg(struct device *);

void nge_setmulti(struct nge_softc *);
u_int32_t nge_crc(struct nge_softc *, caddr_t);
void nge_reset(struct nge_softc *);
int nge_list_rx_init(struct nge_softc *);
int nge_list_tx_init(struct nge_softc *);
d930 1
a930 2
	IFQ_SET_MAXLEN(&ifp->if_snd, NGE_TX_LIST_CNT - 1);
	IFQ_SET_READY(&ifp->if_snd);
d1442 1
a1442 1
			if (!IFQ_IS_EMPTY(&ifp->if_snd))
d1510 1
a1510 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd))
a1609 1
	int			pkts = 0;
d1622 1
a1622 1
		IFQ_POLL(&ifp->if_snd, m_head);
d1627 1
a1631 4
		/* now we are committed to transmit the packet */
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
		pkts++;

a1640 2
	if (pkts == 0)
		return;
d1692 1
a1692 1
		splx(s);
d1818 1
a1818 1
	splx(s);
d1957 1
a1957 1
	splx(s);
d1977 1
a1977 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd))
@


1.15.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.15.2.1 2002/06/11 03:42:25 art Exp $	*/
d34 1
a34 1
 * $FreeBSD: if_nge.c,v 1.35 2002/08/08 18:33:28 ambrisko Exp $
d148 1
d158 2
a159 4
int nge_ifmedia_mii_upd(struct ifnet *);
void nge_ifmedia_mii_sts(struct ifnet *, struct ifmediareq *);
int nge_ifmedia_tbi_upd(struct ifnet *);
void nge_ifmedia_tbi_sts(struct ifnet *, struct ifmediareq *);
d213 1
a213 2
void
nge_delay(sc)
d222 1
a222 2
void
nge_eeprom_idle(sc)
d249 1
a249 2
void
nge_eeprom_putbyte(sc, addr)
d253 1
a253 1
	int			d, i;
d258 1
a258 1
	 * Feed in each bit and strobe the clock.
d277 1
a277 2
void
nge_eeprom_getword(sc, addr, dest)
d282 1
a282 1
	int			i;
d322 1
a322 2
void
nge_read_eeprom(sc, dest, off, cnt, swap)
d345 1
a345 2
void
nge_mii_sync(sc)
d348 1
a348 1
	int			i;
d363 1
a363 2
void
nge_mii_send(sc, bits, cnt)
d388 1
a388 2
int
nge_mii_readreg(sc, frame)
d479 1
a479 2
int
nge_mii_writereg(sc, frame)
d524 1
a524 2
int
nge_miibus_readreg(dev, phy, reg)
a530 2
	DPRINTFN(9, ("%s: nge_miibus_readreg\n", sc->sc_dv.dv_xname));

d540 1
a540 2
void
nge_miibus_writereg(dev, phy, reg, data)
a547 2
	DPRINTFN(9, ("%s: nge_miibus_writereg\n", sc->sc_dv.dv_xname));

d556 1
a556 2
void
nge_miibus_statchg(dev)
a560 7
	u_int32_t		txcfg, rxcfg;

	txcfg = CSR_READ_4(sc, NGE_TX_CFG);
	rxcfg = CSR_READ_4(sc, NGE_RX_CFG);

	DPRINTFN(4, ("%s: nge_miibus_statchg txcfg=%#x, rxcfg=%#x\n",
		     sc->sc_dv.dv_xname, txcfg, rxcfg));
d563 3
a565 2
		txcfg |= (NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR);
		rxcfg |= (NGE_RXCFG_RX_FDX);
d567 3
a569 2
		txcfg &= ~(NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR);
		rxcfg &= ~(NGE_RXCFG_RX_FDX);
d572 5
a576 4
	txcfg |= NGE_TXCFG_AUTOPAD;
	
	CSR_WRITE_4(sc, NGE_TX_CFG, txcfg);
	CSR_WRITE_4(sc, NGE_RX_CFG, rxcfg);
d578 3
a580 4
	/* If we have a 1000Mbps link, set the mode_1000 bit. */
	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_TX)
		NGE_SETBIT(sc, NGE_CFG, NGE_CFG_MODE_1000);
	else
d582 9
d593 1
a593 2
u_int32_t
nge_crc(sc, addr)
d622 1
a622 2
void
nge_setmulti(sc)
d647 1
a647 1
	    NGE_RXFILTCTL_ALLMULTI|NGE_RXFILTCTL_UCHASH);
d677 1
a677 2
void
nge_reset(sc)
d680 1
a680 1
	int			i;
d707 1
a707 2
int
nge_probe(parent, match, aux)
d721 2
d727 1
a727 2
void
nge_attach(parent, self, aux)
d748 1
d753 1
a753 1
	DPRINTFN(5, ("%s: preparing for conf read\n", sc->sc_dv.dv_xname));
d783 1
a783 1
	DPRINTFN(5, ("%s: map control/status regs\n", sc->sc_dv.dv_xname));
d800 1
a800 1
	DPRINTFN(5, ("%s: pci_io_find\n", sc->sc_dv.dv_xname));
d805 1
a805 1
	DPRINTFN(5, ("%s: bus_space_map\n", sc->sc_dv.dv_xname));
d818 1
a818 1
	DPRINTFN(5, ("%s: pci_mem_find\n", sc->sc_dv.dv_xname));
d824 1
a824 1
	DPRINTFN(5, ("%s: bus_space_map\n", sc->sc_dv.dv_xname));
d833 1
a833 4
	/* Disable all interrupts */
	CSR_WRITE_4(sc, NGE_IER, 0);

	DPRINTFN(5, ("%s: pci_intr_map\n", sc->sc_dv.dv_xname));
d839 1
a839 1
	DPRINTFN(5, ("%s: pci_intr_string\n", sc->sc_dv.dv_xname));
d841 1
a841 1
	DPRINTFN(5, ("%s: pci_intr_establish\n", sc->sc_dv.dv_xname));
d854 1
a854 1
	DPRINTFN(5, ("%s: nge_reset\n", sc->sc_dv.dv_xname));
d860 1
a860 1
	DPRINTFN(5, ("%s: nge_read_eeprom\n", sc->sc_dv.dv_xname));
d868 1
a868 1
	printf(": address: %s\n", ether_sprintf(eaddr));
d873 1
a873 1
	DPRINTFN(5, ("%s: bus_dmamem_alloc\n", sc->sc_dv.dv_xname));
d879 1
a879 1
	DPRINTFN(5, ("%s: bus_dmamem_map\n", sc->sc_dv.dv_xname));
d888 1
a888 1
	DPRINTFN(5, ("%s: bus_dmamem_create\n", sc->sc_dv.dv_xname));
d898 1
a898 1
	DPRINTFN(5, ("%s: bus_dmamem_load\n", sc->sc_dv.dv_xname));
d909 1
a909 1
	DPRINTFN(5, ("%s: bzero\n", sc->sc_dv.dv_xname));
d914 1
a914 1
	DPRINTFN(5, ("%s: nge_alloc_jumbo_mem\n", sc->sc_dv.dv_xname));
d937 1
a937 1
	DPRINTFN(5, ("%s: bcopy\n", sc->sc_dv.dv_xname));
d943 15
a957 45
	DPRINTFN(5, ("%s: mii setup\n", sc->sc_dv.dv_xname));
	if (CSR_READ_4(sc, NGE_CFG) & NGE_CFG_TBI_EN) {
		DPRINTFN(5, ("%s: TBI mode\n", sc->sc_dv.dv_xname));
		sc->nge_tbi = 1;

		ifmedia_init(&sc->nge_ifmedia, 0, nge_ifmedia_tbi_upd, 
			     nge_ifmedia_tbi_sts);

		ifmedia_add(&sc->nge_ifmedia, IFM_ETHER|IFM_NONE, 0, NULL),
		ifmedia_add(&sc->nge_ifmedia, IFM_ETHER|IFM_1000_SX, 0, NULL);
		ifmedia_add(&sc->nge_ifmedia, IFM_ETHER|IFM_1000_SX|IFM_FDX,
			    0, NULL);
		ifmedia_add(&sc->nge_ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);

		ifmedia_set(&sc->nge_ifmedia, IFM_ETHER|IFM_AUTO);
	    
		CSR_WRITE_4(sc, NGE_GPIO, CSR_READ_4(sc, NGE_GPIO)
			    | NGE_GPIO_GP4_OUT 
			    | NGE_GPIO_GP1_OUTENB | NGE_GPIO_GP2_OUTENB 
			    | NGE_GPIO_GP3_OUTENB | NGE_GPIO_GP4_OUTENB
			    | NGE_GPIO_GP5_OUTENB);

		NGE_SETBIT(sc, NGE_CFG, NGE_CFG_MODE_1000);
	} else {
		sc->nge_mii.mii_ifp = ifp;
		sc->nge_mii.mii_readreg = nge_miibus_readreg;
		sc->nge_mii.mii_writereg = nge_miibus_writereg;
		sc->nge_mii.mii_statchg = nge_miibus_statchg;

		ifmedia_init(&sc->nge_mii.mii_media, 0, nge_ifmedia_mii_upd,
			     nge_ifmedia_mii_sts);
		mii_attach(&sc->sc_dv, &sc->nge_mii, 0xffffffff, MII_PHY_ANY,
			   MII_OFFSET_ANY, 0);
		
		if (LIST_FIRST(&sc->nge_mii.mii_phys) == NULL) {
			
			printf("%s: no PHY found!\n", sc->sc_dv.dv_xname);
			ifmedia_add(&sc->nge_mii.mii_media,
				    IFM_ETHER|IFM_MANUAL, 0, NULL);
			ifmedia_set(&sc->nge_mii.mii_media,
				    IFM_ETHER|IFM_MANUAL);
		}
		else
			ifmedia_set(&sc->nge_mii.mii_media,
				    IFM_ETHER|IFM_AUTO);
d959 2
d965 1
a965 1
	DPRINTFN(5, ("%s: if_attach\n", sc->sc_dv.dv_xname));
d967 1
a967 1
	DPRINTFN(5, ("%s: ether_ifattach\n", sc->sc_dv.dv_xname));
d969 1
a969 1
	DPRINTFN(5, ("%s: timeout_set\n", sc->sc_dv.dv_xname));
d980 1
a980 2
int
nge_list_tx_init(sc)
d1018 1
a1018 2
int
nge_list_rx_init(sc)
d1052 1
a1052 2
int
nge_newbuf(sc, c, m)
d1096 1
a1096 2
	DPRINTFN(7,("%s: c->nge_ptr=%#x\n", sc->sc_dv.dv_xname,
		    c->nge_ptr));
d1103 1
a1103 2
int
nge_alloc_jumbo_mem(sc)
d1140 2
a1141 3
	DPRINTFN(1,("%s: nge_jumbo_buf=%#x, NGE_MCLBYTES=%#x\n",
		    sc->sc_dv.dv_xname , sc->nge_cdata.nge_jumbo_buf,
		    NGE_MCLBYTES));
d1182 1
a1182 2
void *
nge_jalloc(sc)
d1205 1
a1205 2
void
nge_jfree(buf, size, arg)
d1247 1
a1247 2
void
nge_rxeof(sc)
d1283 1
d1289 9
a1297 27
#ifndef __STRICT_ALIGNMENT
		/*
		 * By popular demand, ignore the alignment problems
		 * on the Intel x86 platform. The performance hit
		 * incurred due to unaligned accesses is much smaller
		 * than the hit produced by forcing buffer copies all
		 * the time, especially with jumbo frames. We still
		 * need to fix up the alignment everywhere else though.
		 */
		if (nge_newbuf(sc, cur_rx, NULL) == ENOBUFS) {
#endif
			m0 = m_devget(mtod(m, char *), total_len,
			    ETHER_ALIGN, ifp, NULL);
			nge_newbuf(sc, cur_rx, m);
			if (m0 == NULL) {
				printf("%s: no receive buffers "
				    "available -- packet dropped!\n",
				    sc->sc_dv.dv_xname);
				ifp->if_ierrors++;
				continue;
			}
			m_adj(m0, ETHER_ALIGN);
			m = m0;
#ifndef __STRICT_ALIGNMENT
		} else {
			m->m_pkthdr.rcvif = ifp;
			m->m_pkthdr.len = m->m_len = total_len;
d1299 2
a1300 1
#endif
d1350 11
d1366 1
a1366 2
void
nge_txeof(sc)
d1423 1
a1423 2
void
nge_tick(xsc)
d1433 1
a1433 46
	DPRINTFN(10, ("%s: nge_tick: link=%d\n", sc->sc_dv.dv_xname,
		      sc->nge_link));

	timeout_add(&sc->nge_timeout, hz);
	if (sc->nge_link) {
		splx(s);
		return;
	}

	if (sc->nge_tbi) {
		if (IFM_SUBTYPE(sc->nge_ifmedia.ifm_cur->ifm_media)
		    == IFM_AUTO) {
			u_int32_t bmsr, anlpar, txcfg, rxcfg;

			bmsr = CSR_READ_4(sc, NGE_TBI_BMSR);
			DPRINTFN(2, ("%s: nge_tick: bmsr=%#x\n",
				     sc->sc_dv.dv_xname, bmsr));

			if (!(bmsr & NGE_TBIBMSR_ANEG_DONE)) {
				CSR_WRITE_4(sc, NGE_TBI_BMCR, 0);

				splx(s);
				return;
			}
				
			anlpar = CSR_READ_4(sc, NGE_TBI_ANLPAR);
			txcfg = CSR_READ_4(sc, NGE_TX_CFG);
			rxcfg = CSR_READ_4(sc, NGE_RX_CFG);
			
			DPRINTFN(2, ("%s: nge_tick: anlpar=%#x, txcfg=%#x, "
				     "rxcfg=%#x\n", sc->sc_dv.dv_xname, anlpar,
				     txcfg, rxcfg));
			
			if (anlpar == 0 || anlpar & NGE_TBIANAR_FDX) {
				txcfg |= (NGE_TXCFG_IGN_HBEAT|
					  NGE_TXCFG_IGN_CARR);
				rxcfg |= NGE_RXCFG_RX_FDX;
			} else {
				txcfg &= ~(NGE_TXCFG_IGN_HBEAT|
					   NGE_TXCFG_IGN_CARR);
				rxcfg &= ~(NGE_RXCFG_RX_FDX);
			}
			txcfg |= NGE_TXCFG_AUTOPAD;
			CSR_WRITE_4(sc, NGE_TX_CFG, txcfg);
			CSR_WRITE_4(sc, NGE_RX_CFG, rxcfg);
		}
d1435 1
a1435 6
		DPRINTF(("%s: gigabit link up\n", sc->sc_dv.dv_xname));
		sc->nge_link++;
		if (!IFQ_IS_EMPTY(&ifp->if_snd))
			nge_start(ifp);
	} else {
		mii_tick(mii);
d1441 2
a1442 2
				DPRINTF(("%s: gigabit link up\n",
					 sc->sc_dv.dv_xname));
d1445 2
a1446 2
		}
		
d1452 1
a1452 2
int
nge_intr(arg)
a1471 5
	/* Data LED on for TBI mode */
	if(sc->nge_tbi)
		 CSR_WRITE_4(sc, NGE_GPIO, CSR_READ_4(sc, NGE_GPIO)
			     | NGE_GPIO_GP3_OUT);

a1487 4
		    (status & NGE_ISR_RX_ERR) ||
		    (status & NGE_ISR_RX_OFLOW) ||
		    (status & NGE_ISR_RX_FIFO_OFLOW) ||
		    (status & NGE_ISR_RX_IDLE) ||
d1491 4
a1494 2
		if ((status & NGE_ISR_RX_IDLE))
			NGE_SETBIT(sc, NGE_CSR, NGE_CSR_RX_ENABLE);
d1502 1
a1502 7
#if 0
		/* 
		 * XXX: nge_tick() is not ready to be called this way
		 * it screws up the aneg timeout because mii_tick() is
		 * only to be called once per second.
		 */
		if (status & NGE_IMR_PHY_INTR) {
a1505 1
#endif
a1513 5
	/* Data LED off for TBI mode */
	if(sc->nge_tbi)
		CSR_WRITE_4(sc, NGE_GPIO, CSR_READ_4(sc, NGE_GPIO)
			    & ~NGE_GPIO_GP3_OUT);

d1521 1
a1521 2
int
nge_encap(sc, m_head, txidx)
d1553 1
a1553 2
			DPRINTFN(7,("%s: f->nge_ptr=%#x\n",
				    sc->sc_dv.dv_xname, f->nge_ptr));
d1573 1
a1573 1
			    NGE_TXEXTSTS_IPCSUM;
d1576 1
a1576 1
			    NGE_TXEXTSTS_TCPCSUM;
d1579 1
a1579 1
			    NGE_TXEXTSTS_UDPCSUM;
d1605 1
a1605 2
void
nge_start(ifp)
d1659 3
a1661 2
void
nge_init(xsc)
d1666 2
a1667 3
	struct mii_data		*mii;
	u_int32_t		txcfg, rxcfg;
	int			s, media;
d1678 1
d1680 2
a1681 1
	mii = sc->nge_tbi ? NULL: &sc->nge_mii;
d1770 2
a1771 1
	CSR_WRITE_4(sc, NGE_TX_CFG, NGE_TXCFG);
d1789 4
a1792 14
	if (sc->nge_tbi)
		media = sc->nge_ifmedia.ifm_cur->ifm_media;
	else
		media = mii->mii_media_active;

	txcfg = CSR_READ_4(sc, NGE_TX_CFG);
	rxcfg = CSR_READ_4(sc, NGE_RX_CFG);

	DPRINTFN(4, ("%s: nge_init txcfg=%#x, rxcfg=%#x\n",
		     sc->sc_dv.dv_xname, txcfg, rxcfg));

	if ((media & IFM_GMASK) == IFM_FDX) {
		txcfg |= (NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR);
		rxcfg |= (NGE_RXCFG_RX_FDX);
d1794 3
a1796 2
		txcfg &= ~(NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR);
		rxcfg &= ~(NGE_RXCFG_RX_FDX);
a1798 7
	txcfg |= NGE_TXCFG_AUTOPAD;
	
	CSR_WRITE_4(sc, NGE_TX_CFG, txcfg);
	CSR_WRITE_4(sc, NGE_RX_CFG, rxcfg);

	nge_tick(sc);

d1808 1
a1808 10
	DPRINTFN(1, ("%s: nge_init: config=%#x\n", sc->sc_dv.dv_xname,
		     CSR_READ_4(sc, NGE_CFG)));

	/*
	 * Configure interrupt holdoff (moderation). We can
	 * have the chip delay interrupt delivery for a certain
	 * period. Units are in 100us, and the max setting
	 * is 25500us (0xFF x 100us). Default is a 100us holdoff.
	 */
	CSR_WRITE_4(sc, NGE_IHR, 0x01);
d1820 1
a1820 4
	if (sc->nge_tbi)
	    nge_ifmedia_tbi_upd(ifp);
	else
	    nge_ifmedia_mii_upd(ifp);
d1829 1
a1829 1
 * Set mii media options.
d1831 1
a1831 2
int
nge_ifmedia_mii_upd(ifp)
d1835 1
a1835 3
	struct mii_data 	*mii = &sc->nge_mii;

	DPRINTFN(2, ("%s: nge_ifmedia_mii_upd\n", sc->sc_dv.dv_xname));
a1837 1

d1850 1
a1850 1
 * Report current mii media status.
d1852 1
a1852 2
void
nge_ifmedia_mii_sts(ifp, ifmr)
d1857 1
a1857 3
	struct mii_data *mii = &sc->nge_mii;

	DPRINTFN(2, ("%s: nge_ifmedia_mii_sts\n", sc->sc_dv.dv_xname));
d1864 1
a1864 106
/*
 * Set mii media options.
 */
int
nge_ifmedia_tbi_upd(ifp)
	struct ifnet		*ifp;
{
	struct nge_softc	*sc = ifp->if_softc;

	DPRINTFN(2, ("%s: nge_ifmedia_tbi_upd\n", sc->sc_dv.dv_xname));

	sc->nge_link = 0;

	if (IFM_SUBTYPE(sc->nge_ifmedia.ifm_cur->ifm_media) 
	    == IFM_AUTO) {
		u_int32_t anar, bmcr;
		anar = CSR_READ_4(sc, NGE_TBI_ANAR);
		anar |= (NGE_TBIANAR_HDX | NGE_TBIANAR_FDX);
		CSR_WRITE_4(sc, NGE_TBI_ANAR, anar);

		bmcr = CSR_READ_4(sc, NGE_TBI_BMCR);
		bmcr |= (NGE_TBIBMCR_ENABLE_ANEG|NGE_TBIBMCR_RESTART_ANEG);
		CSR_WRITE_4(sc, NGE_TBI_BMCR, bmcr);

		bmcr &= ~(NGE_TBIBMCR_RESTART_ANEG);
		CSR_WRITE_4(sc, NGE_TBI_BMCR, bmcr);
	} else {
		u_int32_t txcfg, rxcfg;
		txcfg = CSR_READ_4(sc, NGE_TX_CFG);
		rxcfg = CSR_READ_4(sc, NGE_RX_CFG);

		if ((sc->nge_ifmedia.ifm_cur->ifm_media & IFM_GMASK)
		    == IFM_FDX) {
			txcfg |= NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR;
			rxcfg |= NGE_RXCFG_RX_FDX;
		} else {
			txcfg &= ~(NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR);
			rxcfg &= ~(NGE_RXCFG_RX_FDX);
		}

		txcfg |= NGE_TXCFG_AUTOPAD;
		CSR_WRITE_4(sc, NGE_TX_CFG, txcfg);
		CSR_WRITE_4(sc, NGE_RX_CFG, rxcfg);
	}
	
	NGE_CLRBIT(sc, NGE_GPIO, NGE_GPIO_GP3_OUT);

	return(0);
}

/*
 * Report current tbi media status.
 */
void
nge_ifmedia_tbi_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
{
	struct nge_softc	*sc = ifp->if_softc;
	u_int32_t		bmcr;

	bmcr = CSR_READ_4(sc, NGE_TBI_BMCR);
	
	if (IFM_SUBTYPE(sc->nge_ifmedia.ifm_cur->ifm_media) == IFM_AUTO) {
		u_int32_t bmsr = CSR_READ_4(sc, NGE_TBI_BMSR);
		DPRINTFN(2, ("%s: nge_ifmedia_tbi_sts bmsr=%#x, bmcr=%#x\n",
			     sc->sc_dv.dv_xname, bmsr, bmcr));
	
		if (!(bmsr & NGE_TBIBMSR_ANEG_DONE)) {
			ifmr->ifm_active = IFM_ETHER|IFM_NONE;
			ifmr->ifm_status = IFM_AVALID;
			return;
		}
	} else {
		DPRINTFN(2, ("%s: nge_ifmedia_tbi_sts bmcr=%#x\n",
			     sc->sc_dv.dv_xname, bmcr));
	}
		
	ifmr->ifm_status = IFM_AVALID|IFM_ACTIVE;
	ifmr->ifm_active = IFM_ETHER|IFM_1000_SX;
	
	if (bmcr & NGE_TBIBMCR_LOOPBACK)
		ifmr->ifm_active |= IFM_LOOP;
	
	if (IFM_SUBTYPE(sc->nge_ifmedia.ifm_cur->ifm_media) == IFM_AUTO) {
		u_int32_t anlpar = CSR_READ_4(sc, NGE_TBI_ANLPAR);
		DPRINTFN(2, ("%s: nge_ifmedia_tbi_sts anlpar=%#x\n",
			     sc->sc_dv.dv_xname, anlpar));
		
		ifmr->ifm_active |= IFM_AUTO;
		if (anlpar & NGE_TBIANLPAR_FDX) {
			ifmr->ifm_active |= IFM_FDX;
		} else if (anlpar & NGE_TBIANLPAR_HDX) {
			ifmr->ifm_active |= IFM_HDX;
		} else
			ifmr->ifm_active |= IFM_FDX;
		
	} else if ((sc->nge_ifmedia.ifm_cur->ifm_media & IFM_GMASK) == IFM_FDX)
		ifmr->ifm_active |= IFM_FDX;
	else
		ifmr->ifm_active |= IFM_HDX;
	
}

int
nge_ioctl(ifp, command, data)
d1889 3
a1891 3
			 * Workaround: if the MTU is larger than
			 * 8152 (TX FIFO size minus 64 minus 18), turn off
			 * TX checksum offloading.
d1956 2
a1957 8
		if (sc->nge_tbi) {
			error = ifmedia_ioctl(ifp, ifr, &sc->nge_ifmedia, 
					      command);
		} else {
			mii = &sc->nge_mii;
			error = ifmedia_ioctl(ifp, ifr, &mii->mii_media,
					      command);
		}
d1969 1
a1969 2
void
nge_watchdog(ifp)
d1992 1
a1992 2
void
nge_stop(sc)
d1995 1
a1995 1
	int			i;
d1997 3
a1999 1
	struct mii_data		*mii;
a2002 5
	if (sc->nge_tbi) {
		mii = NULL;
	} else {
		mii = &sc->nge_mii;
	}
d2012 13
a2024 2
	if (!sc->nge_tbi)
		mii_down(mii);
d2060 1
a2060 2
void
nge_shutdown(xsc)
@


1.15.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d600 1
a600 1
	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T)
d1552 1
a1552 1
			if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T)
d1685 1
a1685 1
			f->nge_ptr = vtophys(mtod(m, vaddr_t));
@


1.14
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.13 2001/10/05 01:02:25 nate Exp $	*/
d34 1
a34 1
 * $FreeBSD$
d73 16
a88 4
 * As far as I can tell, the 83820 and 83821 are decent chips, marred by
 * only one flaw: the RX buffers must be aligned on 64-bit boundaries.
 * So far this is the only gigE MAC that I've encountered with this
 * requirement.
a390 1
	
d403 1
a403 1
	
d407 1
a407 1
 	 * Turn on data xmit.
a481 1
	
d493 1
a493 1
	
d495 1
a495 1
 	 * Turn on data output.
d577 1
a577 1
		
d584 1
a584 1
		
d597 1
a597 1
	u_int32_t		crc, carry; 
d829 1
a829 1
	
d912 1
a912 1
	
d1158 1
a1158 1
		entry = malloc(sizeof(struct nge_jpool_entry), 
d1185 1
a1185 1
	
d1187 1
a1187 1
	
d1236 1
a1236 1
			LIST_INSERT_HEAD(&sc->nge_jfree_listhead, 
d1241 1
d1274 1
a1274 1
	 	 * comes up in the ring.
a1445 1
		
a1447 1

d1479 1
a1479 1
		
d1537 1
a1537 1
 	 * Start packing the mbufs in this chain into
d1539 1
a1539 1
 	 * of fragments or hit the end of the mbuf chain.
d1570 1
a1570 1
		if (m_head->m_pkthdr.csum & M_IPV4_CSUM_OUT) 
d1573 1
a1573 1
		if (m_head->m_pkthdr.csum & M_TCPV4_CSUM_OUT) 
d1576 1
a1576 1
		if (m_head->m_pkthdr.csum & M_UDPV4_CSUM_OUT) 
d1886 1
a1886 1
			if (ifr->ifr_mtu >= 8152) 
d1890 1
a1890 1
				ifp->if_capabilities = IFCAP_CSUM_IPv4 | 
@


1.13
log
@random KNF and removal of unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.12 2001/09/26 14:23:27 peter Exp $	*/
d112 1
a112 1
#include <vm/vm.h>              /* for vtophys */
@


1.12
log
@* add missing #include "vlan.h"
* add IFCAP_VLAN_MTU capability
* put test around hardware assited (de)tagging of VLAN packets

This now means that vlan's built using the driver can pass full
size packets.

IFCAP_VLAN_HWTAGGING is not currently enabled as it does not work
in the current sources. more study required.

ok'ed by jason@@, nate@@ was watching mail back and forth
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.11 2001/09/21 17:55:44 miod Exp $	*/
a113 2
#define NGE_USEIOSPACE

d121 2
a621 2
	ifp = &sc->arpcom.ac_if;

d637 1
a637 1
	    NGE_RXFILTCTL_ALLMULTI|NGE_RXFILTCTL_UCHASH);
d1062 1
a1062 1
			    "-- packet dropped!\n", sc->sc_dv.dv_xname);
a1630 1

d1864 1
a1864 1
       }
a2051 1

@


1.11
log
@Correct some pryntf() usage: get the correct number of arguments in the
correct order.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.10 2001/09/11 20:05:25 miod Exp $	*/
d80 1
d925 3
d1561 1
d1751 3
a1753 2
	NGE_SETBIT(sc, NGE_VLAN_IP_RXCTL,
	    NGE_VIPRXCTL_TAG_DETECT_ENB|NGE_VIPRXCTL_TAG_STRIP_ENB);
d1771 2
a1772 1
	NGE_SETBIT(sc, NGE_VLAN_IP_TXCTL, NGE_VIPTXCTL_TAG_PER_PKT);
@


1.10
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.9 2001/09/04 14:17:51 nate Exp $	*/
d859 1
a859 1
	printf(": Ethernet address: %s\n", ether_sprintf(eaddr), ":");
@


1.9
log
@Select between MII/GMII/TBI in the mii_mediachg function instead of in the
interrupt handler since it is more reliable.  Pointed out by wpaul
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.8 2001/08/25 10:13:29 art Exp $	*/
a111 1
#include <vm/vm_kern.h>
@


1.8
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.7 2001/08/12 20:03:49 mickey Exp $	*/
d561 20
a1492 19
			switch (sc->nge_mii.mii_media_active & 0x1F) {
			case IFM_1000_TX:  /* Gigabit using GMII interface */
			  NGE_SETBIT(sc, NGE_CFG, NGE_CFG_MODE_1000);
			  NGE_CLRBIT(sc, NGE_CFG, NGE_CFG_TBI_EN);
			  break;

			case IFM_1000_SX:  /* Gigabit using TBI interface */
			case IFM_1000_CX:
			case IFM_1000_LX:
			  NGE_CLRBIT(sc, NGE_CFG, NGE_CFG_MODE_1000);
			  NGE_SETBIT(sc, NGE_CFG, NGE_CFG_TBI_EN);
			  break;

			default: /* Default to MII interface */
			  NGE_CLRBIT(sc, NGE_CFG, NGE_CFG_MODE_1000|
				     NGE_CFG_TBI_EN);
			  break;
			}

@


1.7
log
@remove redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.6 2001/07/06 06:18:43 angelos Exp $	*/
d806 1
a806 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
			 pa->pa_intrline, &ih)) {
@


1.6
log
@Only clear the relevant capabilities when the MTU is set too
high. Clarify logic of message tagging.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.5 2001/07/06 01:55:25 angelos Exp $	*/
a111 1
#include <vm/pmap.h>            /* for vtophys */
a112 1
#include <vm/vm_extern.h>
@


1.5
log
@IP/TCP/UDP checksumming on the NIC; from rtecco@@umich.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.4 2001/07/02 06:53:43 nate Exp $	*/
d906 2
a907 1
	ifp->if_capabilities =  IFCAP_CSUM_IPv4 | IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4;
d1283 18
a1300 15
		if (extsts & NGE_RXEXTSTS_IPPKT && 
		    !(extsts & NGE_RXEXTSTS_IPCSUMERR))
			m->m_pkthdr.csum |= M_IPV4_CSUM_IN_OK;
		else if (extsts & NGE_RXEXTSTS_IPCSUMERR)
			m->m_pkthdr.csum |= M_IPV4_CSUM_IN_BAD;
		if (extsts & NGE_RXEXTSTS_TCPPKT &&
		    !(extsts & NGE_RXEXTSTS_TCPCSUMERR)) 
			m->m_pkthdr.csum |= M_TCP_CSUM_IN_OK;
		else if (extsts & NGE_RXEXTSTS_TCPCSUMERR)
			m->m_pkthdr.csum |= M_TCP_CSUM_IN_BAD;
		if (extsts & NGE_RXEXTSTS_UDPPKT &&
		    !(extsts & NGE_RXEXTSTS_UDPCSUMERR))
			m->m_pkthdr.csum |= M_UDP_CSUM_IN_OK;
		else if (extsts & NGE_RXEXTSTS_UDPCSUMERR)
			m->m_pkthdr.csum |= M_UDP_CSUM_IN_BAD;
d1877 2
a1878 1
				ifp->if_capabilities = 0;
@


1.4
log
@When the PHY status changes, we need to check what the media speed is
so that we can choose between MII, GMII, and TBI interfaces to the
physical layer.

Don't print debugging info by default.  Change some debugging info.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.3 2001/07/02 05:24:07 nate Exp $	*/
a126 2
#define NGE_CSUM_FEATURES	(CSUM_IP | CSUM_TCP | CSUM_UDP)

d906 1
a1280 1
#ifdef NGE_CSUM_OFFLOAD
d1282 15
a1296 5
		if (extsts & NGE_RXEXTSTS_IPPKT)
			m->m_pkthdr.csum_flags |= CSUM_IP_CHECKED;
		if (!(extsts & NGE_RXEXTSTS_IPCSUMERR))
			m->m_pkthdr.csum_flags |= CSUM_IP_CHECKED;
#endif
d1552 15
a1566 1
	sc->nge_ldata->nge_tx_list[cur].nge_extsts = 0;
a1736 1
#ifdef NGE_CSUM_OFFLOAD
a1737 1
#endif
a1755 1
#ifdef NGE_CSUM_OFFLOAD
a1756 1
#endif
d1780 3
a1782 1
	 * link/speed/duplex status changes.
d1785 1
a1785 1
		   NGE_CFG_PHYINTR_DUP);
d1862 17
@


1.4.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.4 2001/07/02 06:53:43 nate Exp $	*/
a79 1
#include "vlan.h"
d112 5
d125 1
a125 1
#define NGE_USEIOSPACE
d127 1
a127 1
#include <dev/pci/if_ngereg.h>
a564 20

	switch (IFM_SUBTYPE(sc->nge_mii.mii_media_active)) {
	case IFM_1000_TX:  /* Gigabit using GMII interface */
		NGE_SETBIT(sc, NGE_CFG, NGE_CFG_MODE_1000);
		NGE_CLRBIT(sc, NGE_CFG, NGE_CFG_TBI_EN);
		break;
		
	case IFM_1000_SX:  /* Gigabit using TBI interface */
	case IFM_1000_CX:
	case IFM_1000_LX:
		NGE_CLRBIT(sc, NGE_CFG, NGE_CFG_MODE_1000);
		NGE_SETBIT(sc, NGE_CFG, NGE_CFG_TBI_EN);
		break;
		
	default: /* Default to MII interface */
		NGE_CLRBIT(sc, NGE_CFG, NGE_CFG_MODE_1000|
			   NGE_CFG_TBI_EN);
		break;
	}

d606 2
d623 1
a623 1
		   NGE_RXFILTCTL_ALLMULTI|NGE_RXFILTCTL_UCHASH);
d810 2
a811 1
	if (pci_intr_map(pa, &ih)) {
d845 1
a845 1
	printf(": Ethernet address: %s\n", ether_sprintf(eaddr));
a907 5
	ifp->if_capabilities =
	    IFCAP_CSUM_IPv4 | IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4;
#if NVLAN > 0
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
#endif
d1044 1
a1044 1
			       "-- packet dropped!\n", sc->sc_dv.dv_xname);
d1282 1
d1284 5
a1288 18
		if (extsts & NGE_RXEXTSTS_IPPKT) {
			if (extsts & NGE_RXEXTSTS_IPCSUMERR)
				m->m_pkthdr.csum |= M_IPV4_CSUM_IN_BAD;
			else
				m->m_pkthdr.csum |= M_IPV4_CSUM_IN_OK;
		}
		if (extsts & NGE_RXEXTSTS_TCPPKT) {
			if (extsts & NGE_RXEXTSTS_TCPCSUMERR)
				m->m_pkthdr.csum |= M_TCP_CSUM_IN_BAD;
			else
				m->m_pkthdr.csum |= M_TCP_CSUM_IN_OK;
		}
		if (extsts & NGE_RXEXTSTS_UDPPKT) {
			if (extsts & NGE_RXEXTSTS_UDPCSUMERR)
				m->m_pkthdr.csum |= M_UDP_CSUM_IN_BAD;
			else
				m->m_pkthdr.csum |= M_UDP_CSUM_IN_OK;
		}
d1464 19
d1544 1
a1544 16
	/*
	 * Card handles checksumming on a packet by packet
	 * basis.
	 */
	sc->nge_ldata->nge_tx_list[*txidx].nge_extsts = 0;
	if (m_head->m_pkthdr.csum) {
		if (m_head->m_pkthdr.csum & M_IPV4_CSUM_OUT) 
			sc->nge_ldata->nge_tx_list[*txidx].nge_extsts |=
				NGE_TXEXTSTS_IPCSUM;
		if (m_head->m_pkthdr.csum & M_TCPV4_CSUM_OUT) 
			sc->nge_ldata->nge_tx_list[*txidx].nge_extsts |=
				NGE_TXEXTSTS_TCPCSUM;
		if (m_head->m_pkthdr.csum & M_UDPV4_CSUM_OUT) 
			sc->nge_ldata->nge_tx_list[*txidx].nge_extsts |=
				NGE_TXEXTSTS_UDPCSUM;
	}
d1605 1
d1715 1
d1717 1
d1725 2
a1726 3
	if (ifp->if_capabilities & IFCAP_VLAN_HWTAGGING)
		NGE_SETBIT(sc, NGE_VLAN_IP_RXCTL,
		    NGE_VIPRXCTL_TAG_DETECT_ENB|NGE_VIPRXCTL_TAG_STRIP_ENB);
d1736 1
d1738 1
d1746 1
a1746 2
	if (ifp->if_capabilities & IFCAP_VLAN_HWTAGGING)
		NGE_SETBIT(sc, NGE_VLAN_IP_TXCTL, NGE_VIPTXCTL_TAG_PER_PKT);
d1762 1
a1762 3
	 * link/speed/duplex status changes and enable return
	 * of extended status information in the DMA descriptors,
	 * required for checksum offloading.
d1765 1
a1765 1
		   NGE_CFG_PHYINTR_DUP|NGE_CFG_EXTSTS_ENB);
d1839 1
a1839 1
	}
a1841 18
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > NGE_JUMBO_MTU || ifr->ifr_mtu < ETHERMIN)
			error = EINVAL;
		else {
			ifp->if_mtu = ifr->ifr_mtu;
			/*
			 * If requested MTU is larger than the
			 * size of the TX buffer, turn off TX
			 * checksumming.
			 */
			if (ifr->ifr_mtu >= 8152) 
				ifp->if_capabilities &= ~(IFCAP_CSUM_IPv4 |
				    IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4);
			else
				ifp->if_capabilities = IFCAP_CSUM_IPv4 | 
					IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4;
		}
		break;
d2009 1
@


1.4.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d112 1
a112 1
#include <uvm/uvm_extern.h>              /* for vtophys */
@


1.4.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.4.2.2 2001/11/13 21:10:02 niklas Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/dev/nge/if_nge.c,v 1.19 2001/07/25 00:19:55 brooks Exp $
d73 4
a76 16
 * There are two bugs/misfeatures in the 83820/83821 that I have
 * discovered so far:
 *
 * - Receive buffers must be aligned on 64-bit boundaries, which means
 *   you must resort to copying data in order to fix up the payload
 *   alignment.
 *
 * - In order to transmit jumbo frames larger than 8170 bytes, you have
 *   to turn off transmit checksum offloading, because the chip can't
 *   compute the checksum on an outgoing frame unless it fits entirely
 *   within the TX FIFO, which is only 8192 bytes in size. If you have
 *   TX checksum offload enabled and you transmit attempt to transmit a
 *   frame larger than 8170 bytes, the transmitter will wedge.
 *
 * To work around the latter problem, TX checksum offload is disabled
 * if the user selects an MTU larger than 8152 (8170 - 18).
d379 1
d392 1
a392 1

d396 1
a396 1
	 * Turn on data xmit.
d471 1
d483 1
a483 1

d485 1
a485 1
	 * Turn on data output.
d567 1
a567 1

d574 1
a574 1

d587 1
a587 1
	u_int32_t		crc, carry;
d819 1
a819 1

d902 1
a902 1

d1148 1
a1148 1
		entry = malloc(sizeof(struct nge_jpool_entry),
d1175 1
a1175 1

d1177 1
a1177 1

d1226 1
a1226 1
			LIST_INSERT_HEAD(&sc->nge_jfree_listhead,
a1230 1

d1263 1
a1263 1
		 * comes up in the ring.
d1435 1
d1438 1
d1470 1
a1470 1

d1528 1
a1528 1
	 * Start packing the mbufs in this chain into
d1530 1
a1530 1
	 * of fragments or hit the end of the mbuf chain.
d1561 1
a1561 1
		if (m_head->m_pkthdr.csum & M_IPV4_CSUM_OUT)
d1564 1
a1564 1
		if (m_head->m_pkthdr.csum & M_TCPV4_CSUM_OUT)
d1567 1
a1567 1
		if (m_head->m_pkthdr.csum & M_UDPV4_CSUM_OUT)
d1877 1
a1877 1
			if (ifr->ifr_mtu >= 8152)
d1881 1
a1881 1
				ifp->if_capabilities = IFCAP_CSUM_IPv4 |
@


1.4.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1692 1
a1692 1
		splx(s);
d1818 1
a1818 1
	splx(s);
d1957 1
a1957 1
	splx(s);
@


1.4.2.5
log
@Merge in -current from roughly a week ago
@
text
@d137 2
a138 2
int nge_probe(struct device *, void *, void *);
void nge_attach(struct device *, struct device *, void *);
d140 41
a180 41
int nge_alloc_jumbo_mem(struct nge_softc *);
void *nge_jalloc(struct nge_softc *);
void nge_jfree(caddr_t, u_int, void *);

int nge_newbuf(struct nge_softc *, struct nge_desc *,
			     struct mbuf *);
int nge_encap(struct nge_softc *, struct mbuf *, u_int32_t *);
void nge_rxeof(struct nge_softc *);
void nge_rxeoc(struct nge_softc *);
void nge_txeof(struct nge_softc *);
int nge_intr(void *);
void nge_tick(void *);
void nge_start(struct ifnet *);
int nge_ioctl(struct ifnet *, u_long, caddr_t);
void nge_init(void *);
void nge_stop(struct nge_softc *);
void nge_watchdog(struct ifnet *);
void nge_shutdown(void *);
int nge_ifmedia_upd(struct ifnet *);
void nge_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void nge_delay(struct nge_softc *);
void nge_eeprom_idle(struct nge_softc *);
void nge_eeprom_putbyte(struct nge_softc *, int);
void nge_eeprom_getword(struct nge_softc *, int, u_int16_t *);
void nge_read_eeprom(struct nge_softc *, caddr_t, int, int, int);

void nge_mii_sync(struct nge_softc *);
void nge_mii_send(struct nge_softc *, u_int32_t, int);
int nge_mii_readreg(struct nge_softc *, struct nge_mii_frame *);
int nge_mii_writereg(struct nge_softc *, struct nge_mii_frame *);

int nge_miibus_readreg(struct device *, int, int);
void nge_miibus_writereg(struct device *, int, int, int);
void nge_miibus_statchg(struct device *);

void nge_setmulti(struct nge_softc *);
u_int32_t nge_crc(struct nge_softc *, caddr_t);
void nge_reset(struct nge_softc *);
int nge_list_rx_init(struct nge_softc *);
int nge_list_tx_init(struct nge_softc *);
d930 1
a930 2
	IFQ_SET_MAXLEN(&ifp->if_snd, NGE_TX_LIST_CNT - 1);
	IFQ_SET_READY(&ifp->if_snd);
d1442 1
a1442 1
			if (!IFQ_IS_EMPTY(&ifp->if_snd))
d1510 1
a1510 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd))
a1609 1
	int			pkts = 0;
d1622 1
a1622 1
		IFQ_POLL(&ifp->if_snd, m_head);
d1627 1
a1631 4
		/* now we are committed to transmit the packet */
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
		pkts++;

a1640 2
	if (pkts == 0)
		return;
d1977 1
a1977 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd))
@


1.4.2.6
log
@Sync the SMP branch with 3.3
@
text
@d34 1
a34 1
 * $FreeBSD: if_nge.c,v 1.35 2002/08/08 18:33:28 ambrisko Exp $
d148 1
d158 2
a159 4
int nge_ifmedia_mii_upd(struct ifnet *);
void nge_ifmedia_mii_sts(struct ifnet *, struct ifmediareq *);
int nge_ifmedia_tbi_upd(struct ifnet *);
void nge_ifmedia_tbi_sts(struct ifnet *, struct ifmediareq *);
d213 1
a213 2
void
nge_delay(sc)
d222 1
a222 2
void
nge_eeprom_idle(sc)
d249 1
a249 2
void
nge_eeprom_putbyte(sc, addr)
d253 1
a253 1
	int			d, i;
d258 1
a258 1
	 * Feed in each bit and strobe the clock.
d277 1
a277 2
void
nge_eeprom_getword(sc, addr, dest)
d282 1
a282 1
	int			i;
d322 1
a322 2
void
nge_read_eeprom(sc, dest, off, cnt, swap)
d345 1
a345 2
void
nge_mii_sync(sc)
d348 1
a348 1
	int			i;
d363 1
a363 2
void
nge_mii_send(sc, bits, cnt)
d388 1
a388 2
int
nge_mii_readreg(sc, frame)
d479 1
a479 2
int
nge_mii_writereg(sc, frame)
d524 1
a524 2
int
nge_miibus_readreg(dev, phy, reg)
a530 2
	DPRINTFN(9, ("%s: nge_miibus_readreg\n", sc->sc_dv.dv_xname));

d540 1
a540 2
void
nge_miibus_writereg(dev, phy, reg, data)
a547 2
	DPRINTFN(9, ("%s: nge_miibus_writereg\n", sc->sc_dv.dv_xname));

d556 1
a556 2
void
nge_miibus_statchg(dev)
a560 7
	u_int32_t		txcfg, rxcfg;

	txcfg = CSR_READ_4(sc, NGE_TX_CFG);
	rxcfg = CSR_READ_4(sc, NGE_RX_CFG);

	DPRINTFN(4, ("%s: nge_miibus_statchg txcfg=%#x, rxcfg=%#x\n",
		     sc->sc_dv.dv_xname, txcfg, rxcfg));
d563 3
a565 2
		txcfg |= (NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR);
		rxcfg |= (NGE_RXCFG_RX_FDX);
d567 3
a569 2
		txcfg &= ~(NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR);
		rxcfg &= ~(NGE_RXCFG_RX_FDX);
d572 5
a576 4
	txcfg |= NGE_TXCFG_AUTOPAD;
	
	CSR_WRITE_4(sc, NGE_TX_CFG, txcfg);
	CSR_WRITE_4(sc, NGE_RX_CFG, rxcfg);
d578 3
a580 4
	/* If we have a 1000Mbps link, set the mode_1000 bit. */
	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T)
		NGE_SETBIT(sc, NGE_CFG, NGE_CFG_MODE_1000);
	else
d582 9
d593 1
a593 2
u_int32_t
nge_crc(sc, addr)
d622 1
a622 2
void
nge_setmulti(sc)
d647 1
a647 1
	    NGE_RXFILTCTL_ALLMULTI|NGE_RXFILTCTL_UCHASH);
d677 1
a677 2
void
nge_reset(sc)
d680 1
a680 1
	int			i;
d707 1
a707 2
int
nge_probe(parent, match, aux)
d721 2
d727 1
a727 2
void
nge_attach(parent, self, aux)
d748 1
d753 1
a753 1
	DPRINTFN(5, ("%s: preparing for conf read\n", sc->sc_dv.dv_xname));
d783 1
a783 1
	DPRINTFN(5, ("%s: map control/status regs\n", sc->sc_dv.dv_xname));
d800 1
a800 1
	DPRINTFN(5, ("%s: pci_io_find\n", sc->sc_dv.dv_xname));
d805 1
a805 1
	DPRINTFN(5, ("%s: bus_space_map\n", sc->sc_dv.dv_xname));
d818 1
a818 1
	DPRINTFN(5, ("%s: pci_mem_find\n", sc->sc_dv.dv_xname));
d824 1
a824 1
	DPRINTFN(5, ("%s: bus_space_map\n", sc->sc_dv.dv_xname));
d833 1
a833 4
	/* Disable all interrupts */
	CSR_WRITE_4(sc, NGE_IER, 0);

	DPRINTFN(5, ("%s: pci_intr_map\n", sc->sc_dv.dv_xname));
d839 1
a839 1
	DPRINTFN(5, ("%s: pci_intr_string\n", sc->sc_dv.dv_xname));
d841 1
a841 1
	DPRINTFN(5, ("%s: pci_intr_establish\n", sc->sc_dv.dv_xname));
d854 1
a854 1
	DPRINTFN(5, ("%s: nge_reset\n", sc->sc_dv.dv_xname));
d860 1
a860 1
	DPRINTFN(5, ("%s: nge_read_eeprom\n", sc->sc_dv.dv_xname));
d868 1
a868 1
	printf(": address: %s\n", ether_sprintf(eaddr));
d873 1
a873 1
	DPRINTFN(5, ("%s: bus_dmamem_alloc\n", sc->sc_dv.dv_xname));
d879 1
a879 1
	DPRINTFN(5, ("%s: bus_dmamem_map\n", sc->sc_dv.dv_xname));
d888 1
a888 1
	DPRINTFN(5, ("%s: bus_dmamem_create\n", sc->sc_dv.dv_xname));
d898 1
a898 1
	DPRINTFN(5, ("%s: bus_dmamem_load\n", sc->sc_dv.dv_xname));
d909 1
a909 1
	DPRINTFN(5, ("%s: bzero\n", sc->sc_dv.dv_xname));
d914 1
a914 1
	DPRINTFN(5, ("%s: nge_alloc_jumbo_mem\n", sc->sc_dv.dv_xname));
d937 1
a937 1
	DPRINTFN(5, ("%s: bcopy\n", sc->sc_dv.dv_xname));
d943 15
a957 45
	DPRINTFN(5, ("%s: mii setup\n", sc->sc_dv.dv_xname));
	if (CSR_READ_4(sc, NGE_CFG) & NGE_CFG_TBI_EN) {
		DPRINTFN(5, ("%s: TBI mode\n", sc->sc_dv.dv_xname));
		sc->nge_tbi = 1;

		ifmedia_init(&sc->nge_ifmedia, 0, nge_ifmedia_tbi_upd, 
			     nge_ifmedia_tbi_sts);

		ifmedia_add(&sc->nge_ifmedia, IFM_ETHER|IFM_NONE, 0, NULL),
		ifmedia_add(&sc->nge_ifmedia, IFM_ETHER|IFM_1000_SX, 0, NULL);
		ifmedia_add(&sc->nge_ifmedia, IFM_ETHER|IFM_1000_SX|IFM_FDX,
			    0, NULL);
		ifmedia_add(&sc->nge_ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);

		ifmedia_set(&sc->nge_ifmedia, IFM_ETHER|IFM_AUTO);
	    
		CSR_WRITE_4(sc, NGE_GPIO, CSR_READ_4(sc, NGE_GPIO)
			    | NGE_GPIO_GP4_OUT 
			    | NGE_GPIO_GP1_OUTENB | NGE_GPIO_GP2_OUTENB 
			    | NGE_GPIO_GP3_OUTENB | NGE_GPIO_GP4_OUTENB
			    | NGE_GPIO_GP5_OUTENB);

		NGE_SETBIT(sc, NGE_CFG, NGE_CFG_MODE_1000);
	} else {
		sc->nge_mii.mii_ifp = ifp;
		sc->nge_mii.mii_readreg = nge_miibus_readreg;
		sc->nge_mii.mii_writereg = nge_miibus_writereg;
		sc->nge_mii.mii_statchg = nge_miibus_statchg;

		ifmedia_init(&sc->nge_mii.mii_media, 0, nge_ifmedia_mii_upd,
			     nge_ifmedia_mii_sts);
		mii_attach(&sc->sc_dv, &sc->nge_mii, 0xffffffff, MII_PHY_ANY,
			   MII_OFFSET_ANY, 0);
		
		if (LIST_FIRST(&sc->nge_mii.mii_phys) == NULL) {
			
			printf("%s: no PHY found!\n", sc->sc_dv.dv_xname);
			ifmedia_add(&sc->nge_mii.mii_media,
				    IFM_ETHER|IFM_MANUAL, 0, NULL);
			ifmedia_set(&sc->nge_mii.mii_media,
				    IFM_ETHER|IFM_MANUAL);
		}
		else
			ifmedia_set(&sc->nge_mii.mii_media,
				    IFM_ETHER|IFM_AUTO);
d959 2
d965 1
a965 1
	DPRINTFN(5, ("%s: if_attach\n", sc->sc_dv.dv_xname));
d967 1
a967 1
	DPRINTFN(5, ("%s: ether_ifattach\n", sc->sc_dv.dv_xname));
d969 1
a969 1
	DPRINTFN(5, ("%s: timeout_set\n", sc->sc_dv.dv_xname));
d980 1
a980 2
int
nge_list_tx_init(sc)
d1018 1
a1018 2
int
nge_list_rx_init(sc)
d1052 1
a1052 2
int
nge_newbuf(sc, c, m)
d1096 1
a1096 2
	DPRINTFN(7,("%s: c->nge_ptr=%#x\n", sc->sc_dv.dv_xname,
		    c->nge_ptr));
d1103 1
a1103 2
int
nge_alloc_jumbo_mem(sc)
d1140 2
a1141 3
	DPRINTFN(1,("%s: nge_jumbo_buf=%#x, NGE_MCLBYTES=%#x\n",
		    sc->sc_dv.dv_xname , sc->nge_cdata.nge_jumbo_buf,
		    NGE_MCLBYTES));
d1182 1
a1182 2
void *
nge_jalloc(sc)
d1205 1
a1205 2
void
nge_jfree(buf, size, arg)
d1247 1
a1247 2
void
nge_rxeof(sc)
d1283 1
d1289 9
a1297 27
#ifndef __STRICT_ALIGNMENT
		/*
		 * By popular demand, ignore the alignment problems
		 * on the Intel x86 platform. The performance hit
		 * incurred due to unaligned accesses is much smaller
		 * than the hit produced by forcing buffer copies all
		 * the time, especially with jumbo frames. We still
		 * need to fix up the alignment everywhere else though.
		 */
		if (nge_newbuf(sc, cur_rx, NULL) == ENOBUFS) {
#endif
			m0 = m_devget(mtod(m, char *), total_len,
			    ETHER_ALIGN, ifp, NULL);
			nge_newbuf(sc, cur_rx, m);
			if (m0 == NULL) {
				printf("%s: no receive buffers "
				    "available -- packet dropped!\n",
				    sc->sc_dv.dv_xname);
				ifp->if_ierrors++;
				continue;
			}
			m_adj(m0, ETHER_ALIGN);
			m = m0;
#ifndef __STRICT_ALIGNMENT
		} else {
			m->m_pkthdr.rcvif = ifp;
			m->m_pkthdr.len = m->m_len = total_len;
d1299 2
a1300 1
#endif
d1350 11
d1366 1
a1366 2
void
nge_txeof(sc)
d1423 1
a1423 2
void
nge_tick(xsc)
d1433 1
a1433 46
	DPRINTFN(10, ("%s: nge_tick: link=%d\n", sc->sc_dv.dv_xname,
		      sc->nge_link));

	timeout_add(&sc->nge_timeout, hz);
	if (sc->nge_link) {
		splx(s);
		return;
	}

	if (sc->nge_tbi) {
		if (IFM_SUBTYPE(sc->nge_ifmedia.ifm_cur->ifm_media)
		    == IFM_AUTO) {
			u_int32_t bmsr, anlpar, txcfg, rxcfg;

			bmsr = CSR_READ_4(sc, NGE_TBI_BMSR);
			DPRINTFN(2, ("%s: nge_tick: bmsr=%#x\n",
				     sc->sc_dv.dv_xname, bmsr));

			if (!(bmsr & NGE_TBIBMSR_ANEG_DONE)) {
				CSR_WRITE_4(sc, NGE_TBI_BMCR, 0);

				splx(s);
				return;
			}
				
			anlpar = CSR_READ_4(sc, NGE_TBI_ANLPAR);
			txcfg = CSR_READ_4(sc, NGE_TX_CFG);
			rxcfg = CSR_READ_4(sc, NGE_RX_CFG);
			
			DPRINTFN(2, ("%s: nge_tick: anlpar=%#x, txcfg=%#x, "
				     "rxcfg=%#x\n", sc->sc_dv.dv_xname, anlpar,
				     txcfg, rxcfg));
			
			if (anlpar == 0 || anlpar & NGE_TBIANAR_FDX) {
				txcfg |= (NGE_TXCFG_IGN_HBEAT|
					  NGE_TXCFG_IGN_CARR);
				rxcfg |= NGE_RXCFG_RX_FDX;
			} else {
				txcfg &= ~(NGE_TXCFG_IGN_HBEAT|
					   NGE_TXCFG_IGN_CARR);
				rxcfg &= ~(NGE_RXCFG_RX_FDX);
			}
			txcfg |= NGE_TXCFG_AUTOPAD;
			CSR_WRITE_4(sc, NGE_TX_CFG, txcfg);
			CSR_WRITE_4(sc, NGE_RX_CFG, rxcfg);
		}
d1435 1
a1435 6
		DPRINTF(("%s: gigabit link up\n", sc->sc_dv.dv_xname));
		sc->nge_link++;
		if (!IFQ_IS_EMPTY(&ifp->if_snd))
			nge_start(ifp);
	} else {
		mii_tick(mii);
d1440 3
a1442 3
			if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T)
				DPRINTF(("%s: gigabit link up\n",
					 sc->sc_dv.dv_xname));
d1445 2
a1446 2
		}
		
d1452 1
a1452 2
int
nge_intr(arg)
a1471 5
	/* Data LED on for TBI mode */
	if(sc->nge_tbi)
		 CSR_WRITE_4(sc, NGE_GPIO, CSR_READ_4(sc, NGE_GPIO)
			     | NGE_GPIO_GP3_OUT);

a1487 4
		    (status & NGE_ISR_RX_ERR) ||
		    (status & NGE_ISR_RX_OFLOW) ||
		    (status & NGE_ISR_RX_FIFO_OFLOW) ||
		    (status & NGE_ISR_RX_IDLE) ||
d1491 4
a1494 2
		if ((status & NGE_ISR_RX_IDLE))
			NGE_SETBIT(sc, NGE_CSR, NGE_CSR_RX_ENABLE);
d1502 1
a1502 7
#if 0
		/* 
		 * XXX: nge_tick() is not ready to be called this way
		 * it screws up the aneg timeout because mii_tick() is
		 * only to be called once per second.
		 */
		if (status & NGE_IMR_PHY_INTR) {
a1505 1
#endif
a1513 5
	/* Data LED off for TBI mode */
	if(sc->nge_tbi)
		CSR_WRITE_4(sc, NGE_GPIO, CSR_READ_4(sc, NGE_GPIO)
			    & ~NGE_GPIO_GP3_OUT);

d1521 1
a1521 2
int
nge_encap(sc, m_head, txidx)
d1552 2
a1553 3
			f->nge_ptr = vtophys(mtod(m, vaddr_t));
			DPRINTFN(7,("%s: f->nge_ptr=%#x\n",
				    sc->sc_dv.dv_xname, f->nge_ptr));
d1573 1
a1573 1
			    NGE_TXEXTSTS_IPCSUM;
d1576 1
a1576 1
			    NGE_TXEXTSTS_TCPCSUM;
d1579 1
a1579 1
			    NGE_TXEXTSTS_UDPCSUM;
d1605 1
a1605 2
void
nge_start(ifp)
d1659 3
a1661 2
void
nge_init(xsc)
d1666 2
a1667 3
	struct mii_data		*mii;
	u_int32_t		txcfg, rxcfg;
	int			s, media;
d1678 1
d1680 2
a1681 1
	mii = sc->nge_tbi ? NULL: &sc->nge_mii;
d1770 2
a1771 1
	CSR_WRITE_4(sc, NGE_TX_CFG, NGE_TXCFG);
d1789 4
a1792 14
	if (sc->nge_tbi)
		media = sc->nge_ifmedia.ifm_cur->ifm_media;
	else
		media = mii->mii_media_active;

	txcfg = CSR_READ_4(sc, NGE_TX_CFG);
	rxcfg = CSR_READ_4(sc, NGE_RX_CFG);

	DPRINTFN(4, ("%s: nge_init txcfg=%#x, rxcfg=%#x\n",
		     sc->sc_dv.dv_xname, txcfg, rxcfg));

	if ((media & IFM_GMASK) == IFM_FDX) {
		txcfg |= (NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR);
		rxcfg |= (NGE_RXCFG_RX_FDX);
d1794 3
a1796 2
		txcfg &= ~(NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR);
		rxcfg &= ~(NGE_RXCFG_RX_FDX);
a1798 7
	txcfg |= NGE_TXCFG_AUTOPAD;
	
	CSR_WRITE_4(sc, NGE_TX_CFG, txcfg);
	CSR_WRITE_4(sc, NGE_RX_CFG, rxcfg);

	nge_tick(sc);

d1808 1
a1808 10
	DPRINTFN(1, ("%s: nge_init: config=%#x\n", sc->sc_dv.dv_xname,
		     CSR_READ_4(sc, NGE_CFG)));

	/*
	 * Configure interrupt holdoff (moderation). We can
	 * have the chip delay interrupt delivery for a certain
	 * period. Units are in 100us, and the max setting
	 * is 25500us (0xFF x 100us). Default is a 100us holdoff.
	 */
	CSR_WRITE_4(sc, NGE_IHR, 0x01);
d1820 1
a1820 4
	if (sc->nge_tbi)
	    nge_ifmedia_tbi_upd(ifp);
	else
	    nge_ifmedia_mii_upd(ifp);
d1829 1
a1829 1
 * Set mii media options.
d1831 1
a1831 2
int
nge_ifmedia_mii_upd(ifp)
d1835 1
a1835 3
	struct mii_data 	*mii = &sc->nge_mii;

	DPRINTFN(2, ("%s: nge_ifmedia_mii_upd\n", sc->sc_dv.dv_xname));
a1837 1

d1850 1
a1850 1
 * Report current mii media status.
d1852 1
a1852 2
void
nge_ifmedia_mii_sts(ifp, ifmr)
d1857 1
a1857 3
	struct mii_data *mii = &sc->nge_mii;

	DPRINTFN(2, ("%s: nge_ifmedia_mii_sts\n", sc->sc_dv.dv_xname));
d1864 1
a1864 106
/*
 * Set mii media options.
 */
int
nge_ifmedia_tbi_upd(ifp)
	struct ifnet		*ifp;
{
	struct nge_softc	*sc = ifp->if_softc;

	DPRINTFN(2, ("%s: nge_ifmedia_tbi_upd\n", sc->sc_dv.dv_xname));

	sc->nge_link = 0;

	if (IFM_SUBTYPE(sc->nge_ifmedia.ifm_cur->ifm_media) 
	    == IFM_AUTO) {
		u_int32_t anar, bmcr;
		anar = CSR_READ_4(sc, NGE_TBI_ANAR);
		anar |= (NGE_TBIANAR_HDX | NGE_TBIANAR_FDX);
		CSR_WRITE_4(sc, NGE_TBI_ANAR, anar);

		bmcr = CSR_READ_4(sc, NGE_TBI_BMCR);
		bmcr |= (NGE_TBIBMCR_ENABLE_ANEG|NGE_TBIBMCR_RESTART_ANEG);
		CSR_WRITE_4(sc, NGE_TBI_BMCR, bmcr);

		bmcr &= ~(NGE_TBIBMCR_RESTART_ANEG);
		CSR_WRITE_4(sc, NGE_TBI_BMCR, bmcr);
	} else {
		u_int32_t txcfg, rxcfg;
		txcfg = CSR_READ_4(sc, NGE_TX_CFG);
		rxcfg = CSR_READ_4(sc, NGE_RX_CFG);

		if ((sc->nge_ifmedia.ifm_cur->ifm_media & IFM_GMASK)
		    == IFM_FDX) {
			txcfg |= NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR;
			rxcfg |= NGE_RXCFG_RX_FDX;
		} else {
			txcfg &= ~(NGE_TXCFG_IGN_HBEAT|NGE_TXCFG_IGN_CARR);
			rxcfg &= ~(NGE_RXCFG_RX_FDX);
		}

		txcfg |= NGE_TXCFG_AUTOPAD;
		CSR_WRITE_4(sc, NGE_TX_CFG, txcfg);
		CSR_WRITE_4(sc, NGE_RX_CFG, rxcfg);
	}
	
	NGE_CLRBIT(sc, NGE_GPIO, NGE_GPIO_GP3_OUT);

	return(0);
}

/*
 * Report current tbi media status.
 */
void
nge_ifmedia_tbi_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
{
	struct nge_softc	*sc = ifp->if_softc;
	u_int32_t		bmcr;

	bmcr = CSR_READ_4(sc, NGE_TBI_BMCR);
	
	if (IFM_SUBTYPE(sc->nge_ifmedia.ifm_cur->ifm_media) == IFM_AUTO) {
		u_int32_t bmsr = CSR_READ_4(sc, NGE_TBI_BMSR);
		DPRINTFN(2, ("%s: nge_ifmedia_tbi_sts bmsr=%#x, bmcr=%#x\n",
			     sc->sc_dv.dv_xname, bmsr, bmcr));
	
		if (!(bmsr & NGE_TBIBMSR_ANEG_DONE)) {
			ifmr->ifm_active = IFM_ETHER|IFM_NONE;
			ifmr->ifm_status = IFM_AVALID;
			return;
		}
	} else {
		DPRINTFN(2, ("%s: nge_ifmedia_tbi_sts bmcr=%#x\n",
			     sc->sc_dv.dv_xname, bmcr));
	}
		
	ifmr->ifm_status = IFM_AVALID|IFM_ACTIVE;
	ifmr->ifm_active = IFM_ETHER|IFM_1000_SX;
	
	if (bmcr & NGE_TBIBMCR_LOOPBACK)
		ifmr->ifm_active |= IFM_LOOP;
	
	if (IFM_SUBTYPE(sc->nge_ifmedia.ifm_cur->ifm_media) == IFM_AUTO) {
		u_int32_t anlpar = CSR_READ_4(sc, NGE_TBI_ANLPAR);
		DPRINTFN(2, ("%s: nge_ifmedia_tbi_sts anlpar=%#x\n",
			     sc->sc_dv.dv_xname, anlpar));
		
		ifmr->ifm_active |= IFM_AUTO;
		if (anlpar & NGE_TBIANLPAR_FDX) {
			ifmr->ifm_active |= IFM_FDX;
		} else if (anlpar & NGE_TBIANLPAR_HDX) {
			ifmr->ifm_active |= IFM_HDX;
		} else
			ifmr->ifm_active |= IFM_FDX;
		
	} else if ((sc->nge_ifmedia.ifm_cur->ifm_media & IFM_GMASK) == IFM_FDX)
		ifmr->ifm_active |= IFM_FDX;
	else
		ifmr->ifm_active |= IFM_HDX;
	
}

int
nge_ioctl(ifp, command, data)
d1889 3
a1891 3
			 * Workaround: if the MTU is larger than
			 * 8152 (TX FIFO size minus 64 minus 18), turn off
			 * TX checksum offloading.
d1956 2
a1957 8
		if (sc->nge_tbi) {
			error = ifmedia_ioctl(ifp, ifr, &sc->nge_ifmedia, 
					      command);
		} else {
			mii = &sc->nge_mii;
			error = ifmedia_ioctl(ifp, ifr, &mii->mii_media,
					      command);
		}
d1969 1
a1969 2
void
nge_watchdog(ifp)
d1992 1
a1992 2
void
nge_stop(sc)
d1995 1
a1995 1
	int			i;
d1997 3
a1999 1
	struct mii_data		*mii;
a2002 5
	if (sc->nge_tbi) {
		mii = NULL;
	} else {
		mii = &sc->nge_mii;
	}
d2012 13
a2024 2
	if (!sc->nge_tbi)
		mii_down(mii);
d2060 1
a2060 2
void
nge_shutdown(xsc)
@


1.4.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d809 1
a809 1
		error = ENXIO;
@


1.4.2.8
log
@Merge with the trunk
@
text
@d178 1
d606 30
a646 1
allmulti:
d680 1
a680 6
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}
		h = (ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 21) &
		    0x00000FFF;
d1111 3
a1113 1
		if (m_new == NULL)
d1115 1
d1120 4
d1358 3
@


1.3
log
@No need to return at the end of a void function
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.2 2001/06/24 22:58:01 fgsch Exp $	*/
a181 1
#define NGE_DEBUG
d185 1
a185 1
int	ngedebug = 10;
d217 1
a217 1
	register int		i;
d1399 2
a1400 2
				printf("%s: gigabit link up\n",
				       sc->sc_dv.dv_xname);
d1462 1
a1462 1
		if (status & NGE_IMR_PHY_INTR) {
d1464 19
d1639 3
d1710 1
d1764 4
a1767 2
	NGE_SETBIT(sc, NGE_CFG, NGE_CFG_PHYINTR_SPD|NGE_CFG_MODE_1000|
	    NGE_CFG_PHYINTR_LNK|NGE_CFG_PHYINTR_DUP);
@


1.2
log
@- vlan_input_tag() takes 2 args now.
- use ether_input_mbuf().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_nge.c,v 1.1 2001/06/08 02:26:13 nate Exp $	*/
a212 2

	return;
a236 2

	return;
a264 2

	return;
a309 2

	return;
a332 2

	return;
a350 2

	return;
a548 2

	return;
a565 2

	return;
a651 2

	return;
a677 2

        return;
a1212 2

	return;
a1306 2

	return;
a1317 1
	return;
a1379 2

	return;
a1410 2

	return;
a1597 2

	return;
a1760 2

	return;
a1796 2

	return;
a1902 2

	return;
a1970 2

	return;
a1983 2

	return;
@


1.1
log
@Initial cut at a driver for the National Semiconductor DP83820 and DP83821
gigabit macs.  (Not working for me yet.)
From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a1242 1
        struct ether_header	*eh;
a1295 1
		eh = mtod(m, struct ether_header *);
d1305 1
a1305 4

		/* Remove header from mbuf and pass it on. */
		m_adj(m, sizeof(struct ether_header));

a1306 1
#ifdef NGE_CSUM_OFFLOAD
d1319 1
a1319 2
			if (vlan_input_tag(eh, m,
					   extsts & NGE_RXEXTSTS_VTCI) < 0)
d1325 1
a1325 1
		ether_input(ifp, eh, m);
@

