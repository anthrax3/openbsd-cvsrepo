head	1.58;
access;
symbols
	OPENBSD_6_2_BASE:1.58
	OPENBSD_6_1:1.58.0.4
	OPENBSD_6_1_BASE:1.58
	OPENBSD_6_0:1.55.0.8
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.55.0.4
	OPENBSD_5_8_BASE:1.55
	OPENBSD_5_7:1.53.0.6
	OPENBSD_5_7_BASE:1.53
	OPENBSD_5_6:1.53.0.4
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.52.0.4
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.51.0.2
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.49.0.8
	OPENBSD_5_3_BASE:1.49
	OPENBSD_5_2:1.49.0.6
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.4
	OPENBSD_5_0:1.49.0.2
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.47.0.2
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.45.0.2
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.44.0.4
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.44.0.6
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.44.0.2
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.39.0.2
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.34.0.2
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.33.0.10
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.33.0.8
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.33.0.6
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.33.0.4
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.33.0.2
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.27.0.4
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.20
	UBC:1.13.0.2
	UBC_BASE:1.13
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	SMP:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.58
date	2016.12.20.15.45.29;	author ratchov;	state Exp;
branches;
next	1.57;
commitid	dDW2VmDmW7exz02w;

1.57
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.56;
commitid	qGgYgJTgEFuAoGj4;

1.56
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.55;
commitid	pi1a9KN0itEngOc4;

1.55
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.54;
commitid	RaOGL5SyOGOZylwx;

1.54
date	2015.05.07.01.55.43;	author jsg;	state Exp;
branches;
next	1.53;
commitid	KhO2CJgSFKm4Q3Hj;

1.53
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.52;
commitid	OBNa5kfxQ2UXoiIw;

1.52
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.50;

1.50
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.49;

1.49
date	2011.07.03.15.47.16;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.47;

1.47
date	2010.09.12.03.17.34;	author jakemsr;	state Exp;
branches;
next	1.46;

1.46
date	2010.09.12.02.03.35;	author jakemsr;	state Exp;
branches;
next	1.45;

1.45
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.44;

1.44
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.43;

1.43
date	2008.10.23.21.50.01;	author jakemsr;	state Exp;
branches;
next	1.42;

1.42
date	2008.10.02.18.29.40;	author jakemsr;	state Exp;
branches;
next	1.41;

1.41
date	2008.09.24.19.09.05;	author chl;	state Exp;
branches;
next	1.40;

1.40
date	2008.08.12.06.50.16;	author jakemsr;	state Exp;
branches;
next	1.39;

1.39
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.38;

1.38
date	2008.05.25.23.59.33;	author jakemsr;	state Exp;
branches;
next	1.37;

1.37
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.36;

1.36
date	2008.03.30.08.48.53;	author jakemsr;	state Exp;
branches;
next	1.35;

1.35
date	2008.03.24.07.05.22;	author jakemsr;	state Exp;
branches;
next	1.34;

1.34
date	2008.01.15.02.52.50;	author jakemsr;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.06.01.45.22;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.16.21.57.23;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.14.12.42.16;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.11.19.31.43;	author matthieu;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.07.03.17.42;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2004.09.14.23.45.11;	author pvalchev;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.09.21.32.24;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.19.20.33.28;	author grange;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.21.19.32.20;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.28.15.26.23;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.28.15.14.08;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.03.16.19.22;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.02.05.03.18;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.31.20.28.38;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.30.15.13.20;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.08.18.33.53;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.19.17.47.37;	author mickey;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.31.11.00.24;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.12.15.40.30;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.16.12.51.49;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.16.05.22.58;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.21.04.59.01;	author deraadt;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2001.04.16.03.18.18;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.14.08.09.51;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.27.02.50.07;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.14.18.04.07;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.20.21.45.19;	author deraadt;	state Exp;
branches;
next	;

1.6.4.1
date	2001.05.14.22.25.33;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.07.04.10.41.54;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2001.12.05.00.43.29;	author niklas;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.6.4.8;

1.6.4.8
date	2003.03.28.00.38.20;	author niklas;	state Exp;
branches;
next	1.6.4.9;

1.6.4.9
date	2003.05.13.19.35.04;	author ho;	state Exp;
branches;
next	1.6.4.10;

1.6.4.10
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.6.4.11;

1.6.4.11
date	2004.02.19.10.56.25;	author niklas;	state Exp;
branches;
next	;

1.13.2.1
date	2002.01.31.22.55.34;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Simplify the activate() functions of auglx(4), autri(4), and
auvia(4). From Michael W.  Bombardieri <mb at ii.net>. Thanks.
@
text
@/*	$OpenBSD: auvia.c,v 1.57 2016/09/19 06:46:44 ratchov Exp $ */
/*	$NetBSD: auvia.c,v 1.28 2002/11/04 16:38:49 kent Exp $	*/

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Tyler C. Sarna
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * VIA Technologies VT82C686A Southbridge Audio Driver
 *
 * Documentation links:
 *
 * ftp://ftp.alsa-project.org/pub/manuals/via/686a.pdf
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/audioio.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>

#include <dev/audio_if.h>

#include <dev/ic/ac97.h>

#include <dev/pci/auviavar.h>

struct auvia_dma {
	struct auvia_dma *next;
	caddr_t addr;
	size_t size;
	bus_dmamap_t map;
	bus_dma_segment_t seg;
};

struct auvia_dma_op {
	u_int32_t ptr;
	u_int32_t flags;
#define AUVIA_DMAOP_EOL		0x80000000
#define AUVIA_DMAOP_FLAG	0x40000000
#define AUVIA_DMAOP_STOP	0x20000000
#define AUVIA_DMAOP_COUNT(x)	((x)&0x00FFFFFF)
};

int	auvia_match(struct device *, void *, void *);
void	auvia_attach(struct device *, struct device *, void *);
int	auvia_open(void *, int);
void	auvia_close(void *);
void	auvia_set_params_sub(struct auvia_softc *, struct auvia_softc_chan *,
	struct audio_params *);
int	auvia_set_params(void *, int, int, struct audio_params *,
	struct audio_params *);
int	auvia_round_blocksize(void *, int);
int	auvia_halt_output(void *);
int	auvia_halt_input(void *);
int	auvia_set_port(void *, mixer_ctrl_t *);
int	auvia_get_port(void *, mixer_ctrl_t *);
int	auvia_query_devinfo(void *, mixer_devinfo_t *);
void *	auvia_malloc(void *, int, size_t, int, int);
void	auvia_free(void *, void *, int);
size_t	auvia_round_buffersize(void *, int, size_t);
int	auvia_get_props(void *);
int	auvia_build_dma_ops(struct auvia_softc *, struct auvia_softc_chan *,
	struct auvia_dma *, void *, void *, int);
int	auvia_trigger_output(void *, void *, void *, int, void (*)(void *),
	void *, struct audio_params *);
int	auvia_trigger_input(void *, void *, void *, int, void (*)(void *),
	void *, struct audio_params *);

int	auvia_intr(void *);

int	auvia_activate(struct device *, int);

struct  cfdriver auvia_cd = {
	NULL, "auvia", DV_DULL
};

struct cfattach auvia_ca = {
	sizeof (struct auvia_softc), auvia_match, auvia_attach,
	    NULL, auvia_activate
};

#define AUVIA_PCICONF_JUNK	0x40
#define		AUVIA_PCICONF_ENABLES	 0x00FF0000	/* reg 42 mask */
#define		AUVIA_PCICONF_ACLINKENAB 0x00008000	/* ac link enab */
#define		AUVIA_PCICONF_ACNOTRST	 0x00004000	/* ~(ac reset) */
#define		AUVIA_PCICONF_ACSYNC	 0x00002000	/* ac sync */
#define		AUVIA_PCICONF_ACVSR	 0x00000800	/* var. samp. rate */
#define		AUVIA_PCICONF_ACSGD	 0x00000400	/* SGD enab */
#define		AUVIA_PCICONF_ACFM	 0x00000200	/* FM enab */
#define		AUVIA_PCICONF_ACSB	 0x00000100	/* SB enab */
#define		AUVIA_PCICONF_PRIVALID	 0x00000001	/* primary codec rdy */

#define AUVIA_PLAY_BASE			0x00
#define AUVIA_RECORD_BASE		0x10

/* *_RP_* are offsets from AUVIA_PLAY_BASE or AUVIA_RECORD_BASE */
#define	AUVIA_RP_STAT			0x00
#define		AUVIA_RPSTAT_INTR		0x03
#define AUVIA_RP_CONTROL		0x01
#define		AUVIA_RPCTRL_START		0x80
#define		AUVIA_RPCTRL_TERMINATE		0x40
#define		AUVIA_RPCTRL_AUTOSTART		0x20
/* The following are 8233 specific */
#define		AUVIA_RPCTRL_STOP		0x04
#define		AUVIA_RPCTRL_EOL		0x02
#define		AUVIA_RPCTRL_FLAG		0x01
#define	AUVIA_RP_MODE			0x02		/* 82c686 specific */
#define		AUVIA_RPMODE_INTR_FLAG		0x01
#define		AUVIA_RPMODE_INTR_EOL		0x02
#define		AUVIA_RPMODE_STEREO		0x10
#define		AUVIA_RPMODE_16BIT		0x20
#define		AUVIA_RPMODE_AUTOSTART		0x80
#define	AUVIA_RP_DMAOPS_BASE		0x04

#define	VIA8233_RP_DXS_LVOL		0x02
#define	VIA8233_RP_DXS_RVOL		0x03
#define	VIA8233_RP_RATEFMT		0x08
#define		VIA8233_RATEFMT_48K	0xfffff
#define		VIA8233_RATEFMT_STEREO	0x00100000
#define		VIA8233_RATEFMT_16BIT	0x00200000

#define VIA_RP_DMAOPS_COUNT		0x0c

#define VIA8233_MP_BASE			0x40
	/* STAT, CONTROL, DMAOPS_BASE, DMAOPS_COUNT are valid */
#define VIA8233_OFF_MP_FORMAT		0x02
#define		VIA8233_MP_FORMAT_8BIT		0x00
#define		VIA8233_MP_FORMAT_16BIT		0x80
#define		VIA8233_MP_FORMAT_CHANNLE_MASK	0x70 /* 1, 2, 4, 6 */
#define VIA8233_OFF_MP_SCRATCH		0x03
#define VIA8233_OFF_MP_STOP		0x08

#define VIA8233_WR_BASE			0x60

#define	AUVIA_CODEC_CTL			0x80
#define		AUVIA_CODEC_READ		0x00800000
#define		AUVIA_CODEC_BUSY		0x01000000
#define		AUVIA_CODEC_PRIVALID		0x02000000
#define		AUVIA_CODEC_INDEX(x)		((x)<<16)

#define CH_WRITE1(sc, ch, off, v)	\
	bus_space_write_1((sc)->sc_iot,	(sc)->sc_ioh, (ch)->sc_base + (off), v)
#define CH_WRITE4(sc, ch, off, v)	\
	bus_space_write_4((sc)->sc_iot,	(sc)->sc_ioh, (ch)->sc_base + (off), v)
#define CH_READ1(sc, ch, off)		\
	bus_space_read_1((sc)->sc_iot, (sc)->sc_ioh, (ch)->sc_base + (off))
#define CH_READ4(sc, ch, off)		\
	bus_space_read_4((sc)->sc_iot, (sc)->sc_ioh, (ch)->sc_base + (off))

#define TIMEOUT	50

struct audio_hw_if auvia_hw_if = {
	auvia_open,
	auvia_close,
	auvia_set_params,
	auvia_round_blocksize,
	NULL, /* commit_settings */
	NULL, /* init_output */
	NULL, /* init_input */
	NULL, /* start_output */
	NULL, /* start_input */
	auvia_halt_output,
	auvia_halt_input,
	NULL, /* speaker_ctl */
	NULL, /* setfd */
	auvia_set_port,
	auvia_get_port,
	auvia_query_devinfo,
	auvia_malloc,
	auvia_free,
	auvia_round_buffersize,
	auvia_get_props,
	auvia_trigger_output,
	auvia_trigger_input
};

int	auvia_attach_codec(void *, struct ac97_codec_if *);
int	auvia_write_codec(void *, u_int8_t, u_int16_t);
int	auvia_read_codec(void *, u_int8_t, u_int16_t *);
void	auvia_reset_codec(void *);
int	auvia_waitready_codec(struct auvia_softc *sc);
int	auvia_waitvalid_codec(struct auvia_softc *sc);
void	auvia_spdif_event(void *, int);

int	auvia_resume(struct auvia_softc *);

const struct pci_matchid auvia_devices[] = {
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT82C686A_AC97 },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT8233_AC97 },
};

int
auvia_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, auvia_devices,
	    nitems(auvia_devices)));
}

int
auvia_activate(struct device *self, int act)
{
	struct auvia_softc *sc = (struct auvia_softc *)self;

	if (act == DVACT_RESUME)
		auvia_resume(sc);
	return (config_activate_children(self, act));
}

void
auvia_attach(struct device *parent, struct device *self, void *aux)
{
	struct pci_attach_args *pa = aux;
	struct auvia_softc *sc = (struct auvia_softc *) self;
	const char *intrstr = NULL;
	struct mixer_ctrl ctl;
	pci_chipset_tag_t pc = pa->pa_pc;
	pcitag_t pt = pa->pa_tag;
	pci_intr_handle_t ih;
	bus_size_t iosize;
	pcireg_t pr;
	int r, i;

	sc->sc_play.sc_base = AUVIA_PLAY_BASE;
	sc->sc_record.sc_base = AUVIA_RECORD_BASE;
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VT8233_AC97) {
		sc->sc_flags |= AUVIA_FLAGS_VT8233;
		sc->sc_play.sc_base = VIA8233_MP_BASE;
		sc->sc_record.sc_base = VIA8233_WR_BASE;
	}

	if (pci_mapreg_map(pa, 0x10, PCI_MAPREG_TYPE_IO, 0, &sc->sc_iot,
	    &sc->sc_ioh, NULL, &iosize, 0)) {
		printf(": can't map i/o space\n");
		return;
	}

	sc->sc_dmat = pa->pa_dmat;
	sc->sc_pc = pc;
	sc->sc_pt = pt;

	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
		return;
	}
	intrstr = pci_intr_string(pc, ih);

	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO | IPL_MPSAFE,
	    auvia_intr, sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
		return;
	}

	printf(": %s\n", intrstr);

	/* disable SBPro compat & others */
	pr = pci_conf_read(pc, pt, AUVIA_PCICONF_JUNK);

	pr &= ~AUVIA_PCICONF_ENABLES; /* clear compat function enables */
	/* XXX what to do about MIDI, FM, joystick? */

	pr |= (AUVIA_PCICONF_ACLINKENAB | AUVIA_PCICONF_ACNOTRST |
	    AUVIA_PCICONF_ACVSR | AUVIA_PCICONF_ACSGD);

	pr &= ~(AUVIA_PCICONF_ACFM | AUVIA_PCICONF_ACSB);

	pci_conf_write(pc, pt, AUVIA_PCICONF_JUNK, pr);
	sc->sc_pci_junk = pr;

	sc->host_if.arg = sc;
	sc->host_if.attach = auvia_attach_codec;
	sc->host_if.read = auvia_read_codec;
	sc->host_if.write = auvia_write_codec;
	sc->host_if.reset = auvia_reset_codec;
	sc->host_if.spdif_event = auvia_spdif_event;

	if ((r = ac97_attach(&sc->host_if)) != 0) {
		printf("%s: can't attach codec (error 0x%X)\n",
		    sc->sc_dev.dv_xname, r);
		pci_intr_disestablish(pc, sc->sc_ih);
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
		return;
	}

	/* disable mutes */
	for (i = 0; i < 4; i++) {
		static struct {
			char *class, *device;
		} d[] = {
			{ AudioCoutputs, AudioNmaster},
			{ AudioCinputs, AudioNdac},
			{ AudioCinputs, AudioNcd},
			{ AudioCrecord, AudioNvolume},
		};

		ctl.type = AUDIO_MIXER_ENUM;
		ctl.un.ord = 0;

		ctl.dev = sc->codec_if->vtbl->get_portnum_by_name(sc->codec_if,
		    d[i].class, d[i].device, AudioNmute);
		auvia_set_port(sc, &ctl);
	}

	/* set a reasonable default volume */

	ctl.type = AUDIO_MIXER_VALUE;
	ctl.un.value.num_channels = 2;
	ctl.un.value.level[AUDIO_MIXER_LEVEL_LEFT] = \
	ctl.un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = 199;

	ctl.dev = sc->codec_if->vtbl->get_portnum_by_name(sc->codec_if,
	    AudioCoutputs, AudioNmaster, NULL);
	auvia_set_port(sc, &ctl);

	audio_attach_mi(&auvia_hw_if, sc, &sc->sc_dev);
	sc->codec_if->vtbl->unlock(sc->codec_if);
}


int
auvia_attach_codec(void *addr, struct ac97_codec_if *cif)
{
	struct auvia_softc *sc = addr;

	sc->codec_if = cif;

	return 0;
}


void
auvia_reset_codec(void *addr)
{
	int i;
	struct auvia_softc *sc = addr;
	pcireg_t r;

	/* perform a codec cold reset */

	r = pci_conf_read(sc->sc_pc, sc->sc_pt, AUVIA_PCICONF_JUNK);

	r &= ~AUVIA_PCICONF_ACNOTRST;	/* enable RESET (active low) */
	pci_conf_write(sc->sc_pc, sc->sc_pt, AUVIA_PCICONF_JUNK, r);
	delay(2);

	r |= AUVIA_PCICONF_ACNOTRST;	/* disable RESET (inactive high) */
	pci_conf_write(sc->sc_pc, sc->sc_pt, AUVIA_PCICONF_JUNK, r);
	delay(200);

	for (i = 500000; i != 0 && !(pci_conf_read(sc->sc_pc, sc->sc_pt,
		AUVIA_PCICONF_JUNK) & AUVIA_PCICONF_PRIVALID); i--)
		DELAY(1);
	if (i == 0)
		printf("%s: codec reset timed out\n", sc->sc_dev.dv_xname);
}


int
auvia_waitready_codec(struct auvia_softc *sc)
{
	int i;

	/* poll until codec not busy */
	for (i = 0; (i < TIMEOUT) && (bus_space_read_4(sc->sc_iot, sc->sc_ioh,
	     AUVIA_CODEC_CTL) & AUVIA_CODEC_BUSY); i++)
		delay(1);

	if (i >= TIMEOUT) {
		printf("%s: codec busy\n", sc->sc_dev.dv_xname);
		return 1;
	}

	return 0;
}


int
auvia_waitvalid_codec(struct auvia_softc *sc)
{
	int i;

	/* poll until codec valid */
	for (i = 0; (i < TIMEOUT) && !(bus_space_read_4(sc->sc_iot, sc->sc_ioh,
	     AUVIA_CODEC_CTL) & AUVIA_CODEC_PRIVALID); i++)
		delay(1);

	if (i >= TIMEOUT) {
		printf("%s: codec invalid\n", sc->sc_dev.dv_xname);
		return 1;
	}

	return 0;
}


int
auvia_write_codec(void *addr, u_int8_t reg, u_int16_t val)
{
	struct auvia_softc *sc = addr;

	if (auvia_waitready_codec(sc))
		return 1;

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, AUVIA_CODEC_CTL,
	    AUVIA_CODEC_PRIVALID | AUVIA_CODEC_INDEX(reg) | val);

	return 0;
}


int
auvia_read_codec(void *addr, u_int8_t reg, u_int16_t *val)
{
	struct auvia_softc *sc = addr;

	if (auvia_waitready_codec(sc))
		return 1;

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, AUVIA_CODEC_CTL,
	    AUVIA_CODEC_PRIVALID | AUVIA_CODEC_READ | AUVIA_CODEC_INDEX(reg));

	if (auvia_waitready_codec(sc))
		return 1;

	if (auvia_waitvalid_codec(sc))
		return 1;

	*val = bus_space_read_2(sc->sc_iot, sc->sc_ioh, AUVIA_CODEC_CTL);

	return 0;
}


void
auvia_spdif_event(void *addr, int flag)
{
	struct auvia_softc *sc = addr;
	sc->sc_spdif = flag;
}

int
auvia_open(void *addr, int flags)
{
	struct auvia_softc *sc = addr;
	sc->codec_if->vtbl->lock(sc->codec_if);
	return 0;
}


void
auvia_close(void *addr)
{
	struct auvia_softc *sc = addr;
	sc->codec_if->vtbl->unlock(sc->codec_if);

	/* XXX: already called by audio_close() */
	auvia_halt_output(sc);
	auvia_halt_input(sc);

	sc->sc_play.sc_intr = NULL;
	sc->sc_record.sc_intr = NULL;
}


void
auvia_set_params_sub(struct auvia_softc *sc, struct auvia_softc_chan *ch,
		     struct audio_params *p)
{
	u_int32_t v;
	u_int16_t regval;

	if (!(sc->sc_flags & AUVIA_FLAGS_VT8233)) {
		regval = (p->channels == 2 ? AUVIA_RPMODE_STEREO : 0)
			| (p->precision == 16 ?
				AUVIA_RPMODE_16BIT : 0)
			| AUVIA_RPMODE_INTR_FLAG | AUVIA_RPMODE_INTR_EOL
			| AUVIA_RPMODE_AUTOSTART;
		ch->sc_reg = regval;
	} else if (ch->sc_base != VIA8233_MP_BASE) {
		v = CH_READ4(sc, ch, VIA8233_RP_RATEFMT);
		v &= ~(VIA8233_RATEFMT_48K | VIA8233_RATEFMT_STEREO
			| VIA8233_RATEFMT_16BIT);

		v |= VIA8233_RATEFMT_48K * (p->sample_rate / 20)
			/ (48000 / 20);
		if (p->channels == 2)
			v |= VIA8233_RATEFMT_STEREO;
		if (p->precision == 16)
			v |= VIA8233_RATEFMT_16BIT;

		CH_WRITE4(sc, ch, VIA8233_RP_RATEFMT, v);
	} else {
		static const u_int32_t slottab[7] =
			{ 0, 0xff000011, 0xff000021, 0,
			  0xff004321, 0, 0xff436521};

		regval = (p->precision == 16
			? VIA8233_MP_FORMAT_16BIT : VIA8233_MP_FORMAT_8BIT)
			| (p->channels << 4);
		CH_WRITE1(sc, ch, VIA8233_OFF_MP_FORMAT, regval);
		CH_WRITE4(sc, ch, VIA8233_OFF_MP_STOP, slottab[p->channels]);
	}
}

int
auvia_set_params(void *addr, int setmode, int usemode,
    struct audio_params *play, struct audio_params *rec)
{
	struct auvia_softc *sc = addr;
	struct auvia_softc_chan *ch;
	struct audio_params *p;
	struct ac97_codec_if* codec = sc->codec_if;
	int reg, mode;
	u_int16_t ext_id;

	/* for mode in (RECORD, PLAY) */
	for (mode = AUMODE_RECORD; mode != -1;
	     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
		if ((setmode & mode) == 0)
			continue;

		if (mode == AUMODE_PLAY) {
			p = play;
			ch = &sc->sc_play;
			reg = AC97_REG_PCM_FRONT_DAC_RATE;
		} else {
			p = rec;
			ch = &sc->sc_record;
			reg = AC97_REG_PCM_LR_ADC_RATE;
		}

		if (ch->sc_base == VIA8233_MP_BASE && mode == AUMODE_PLAY) {
			ext_id = codec->vtbl->get_caps(codec);
			if (p->channels == 1) {
				/* ok */
			} else if (p->channels == 2) {
				/* ok */
			} else if (p->channels == 4
				&& ext_id & AC97_EXT_AUDIO_SDAC) {
				/* ok */
			} else if (p->channels == 6
				&& (ext_id & AC97_BITS_6CH) == AC97_BITS_6CH) {
				/* ok */
			} else {
				p->channels = 2;
			}
		} else {
			if (p->channels > 2)
				p->channels = 2;
		}

		if (p->sample_rate < 4000)
			p->sample_rate = 4000;
		if (p->sample_rate > 48000)
			p->sample_rate = 48000;
		if (p->precision > 16)
			p->precision = 16;

		/* XXX only 16-bit 48kHz slinear_le if s/pdif enabled ? */
		if (sc->sc_spdif) {
			p->sample_rate = 48000;
			p->precision = 16;
			p->encoding = AUDIO_ENCODING_SLINEAR_LE;
		}

		/* XXX only 16-bit 48kHz slinear_le if s/pdif enabled ? */
		if (sc->sc_spdif &&
		    ((p->sample_rate != 48000) || (p->precision != 16) ||
		    (p->encoding != AUDIO_ENCODING_SLINEAR_LE)))
			return (EINVAL);

		if (AC97_IS_FIXED_RATE(codec)) {
 			p->sample_rate = AC97_SINGLE_RATE;
 		} else {
			if (codec->vtbl->set_rate(codec, reg, &p->sample_rate))
				return (EINVAL);

			if (ch->sc_base == VIA8233_MP_BASE &&
			    mode == AUMODE_PLAY) {
				reg = AC97_REG_PCM_SURR_DAC_RATE;
				if (p->channels >= 4
				    && codec->vtbl->set_rate(codec, reg,
				    &p->sample_rate))
					return (EINVAL);
				reg = AC97_REG_PCM_LFE_DAC_RATE;
				if (p->channels == 6
				    && codec->vtbl->set_rate(codec, reg,
				    &p->sample_rate))
 				return (EINVAL);
			}
 		}

		switch (p->encoding) {
		case AUDIO_ENCODING_SLINEAR_LE:
			if (p->precision != 16)
				return EINVAL;
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
		case AUDIO_ENCODING_ULINEAR_BE:
			if (p->precision != 8)
				return EINVAL;
			break;
		default:
			return (EINVAL);
		}
		auvia_set_params_sub(sc, ch, p);

		p->bps = AUDIO_BPS(p->precision);
		p->msb = 1;
	}

	return 0;
}


int
auvia_round_blocksize(void *addr, int blk)
{
	struct auvia_softc *sc = addr;

	if (sc->bufsize / blk > AUVIA_DMALIST_MAX)
		blk = sc->bufsize / AUVIA_DMALIST_MAX + 1;
	return ((blk + 31) & -32);
}


int
auvia_halt_output(void *addr)
{
	struct auvia_softc *sc = addr;
	struct auvia_softc_chan *ch = &(sc->sc_play);

	CH_WRITE1(sc, ch, AUVIA_RP_CONTROL, AUVIA_RPCTRL_TERMINATE);
	ch->sc_intr = NULL;
	return 0;
}


int
auvia_halt_input(void *addr)
{
	struct auvia_softc *sc = addr;
	struct auvia_softc_chan *ch = &(sc->sc_record);

	CH_WRITE1(sc, ch, AUVIA_RP_CONTROL, AUVIA_RPCTRL_TERMINATE);
	ch->sc_intr = NULL;
	return 0;
}


int
auvia_set_port(void *addr, mixer_ctrl_t *cp)
{
	struct auvia_softc *sc = addr;

	return (sc->codec_if->vtbl->mixer_set_port(sc->codec_if, cp));
}


int
auvia_get_port(void *addr, mixer_ctrl_t *cp)
{
	struct auvia_softc *sc = addr;

	return (sc->codec_if->vtbl->mixer_get_port(sc->codec_if, cp));
}


int
auvia_query_devinfo(void *addr, mixer_devinfo_t *dip)
{
	struct auvia_softc *sc = addr;

	return (sc->codec_if->vtbl->query_devinfo(sc->codec_if, dip));
}


void *
auvia_malloc(void *addr, int direction, size_t size, int pool, int flags)
{
	struct auvia_softc *sc = addr;
	struct auvia_dma *p;
	int error;
	int rseg;

	p = malloc(sizeof(*p), pool, flags);
	if (!p)
		return 0;

	p->size = size;
	if ((error = bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE, 0, &p->seg,
	    1, &rseg, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: unable to allocate dma, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_alloc;
	}

	if ((error = bus_dmamem_map(sc->sc_dmat, &p->seg, rseg, size, &p->addr,
	    BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {
		printf("%s: unable to map dma, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_map;
	}

	if ((error = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT, &p->map)) != 0) {
		printf("%s: unable to create dma map, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_create;
	}

	if ((error = bus_dmamap_load(sc->sc_dmat, p->map, p->addr, size, NULL,
	    BUS_DMA_NOWAIT)) != 0) {
		printf("%s: unable to load dma map, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_load;
	}

	p->next = sc->sc_dmas;
	sc->sc_dmas = p;

	return p->addr;


fail_load:
	bus_dmamap_destroy(sc->sc_dmat, p->map);
fail_create:
	bus_dmamem_unmap(sc->sc_dmat, p->addr, size);
fail_map:
	bus_dmamem_free(sc->sc_dmat, &p->seg, 1);
fail_alloc:
	free(p, pool, 0);
	return 0;
}


void
auvia_free(void *addr, void *ptr, int pool)
{
	struct auvia_softc *sc = addr;
	struct auvia_dma **pp, *p;

	for (pp = &(sc->sc_dmas); (p = *pp) != NULL; pp = &p->next)
		if (p->addr == ptr) {
			bus_dmamap_unload(sc->sc_dmat, p->map);
			bus_dmamap_destroy(sc->sc_dmat, p->map);
			bus_dmamem_unmap(sc->sc_dmat, p->addr, p->size);
			bus_dmamem_free(sc->sc_dmat, &p->seg, 1);

			*pp = p->next;
			free(p, pool, 0);
			return;
		}

	panic("auvia_free: trying to free unallocated memory");
}

size_t
auvia_round_buffersize(void *addr, int direction, size_t bufsize)
{
	struct auvia_softc *sc = addr;

	sc->bufsize = bufsize;
	return bufsize;
}

int
auvia_get_props(void *addr)
{
	int props;

	props = AUDIO_PROP_MMAP|AUDIO_PROP_INDEPENDENT|AUDIO_PROP_FULLDUPLEX;

	return  props;
}


int
auvia_build_dma_ops(struct auvia_softc *sc, struct auvia_softc_chan *ch,
    struct auvia_dma *p, void *start, void *end, int blksize)
{
	struct auvia_dma_op *op;
	struct auvia_dma *dp;
	bus_addr_t s;
	size_t l;
	int segs;

	s = p->map->dm_segs[0].ds_addr;
	l = (vaddr_t)end - (vaddr_t)start;
	segs = howmany(l, blksize);
	if (segs > AUVIA_DMALIST_MAX) {
		panic("%s: build_dma_ops: too many DMA segments",
			    sc->sc_dev.dv_xname);
	}

	if (segs > ch->sc_dma_op_count) {
		/* if old list was too small, free it */
		if (ch->sc_dma_ops)
			auvia_free(sc, ch->sc_dma_ops, M_DEVBUF);

		ch->sc_dma_ops = auvia_malloc(sc, 0,
		    sizeof(struct auvia_dma_op) * segs, M_DEVBUF, M_WAITOK);

		for (dp = sc->sc_dmas; dp &&
		     dp->addr != (void *)(ch->sc_dma_ops); dp = dp->next)
			;

		if (!dp)
			panic("%s: build_dma_ops: where'd my memory go??? "
			    "address (%p)", sc->sc_dev.dv_xname,
			    ch->sc_dma_ops);

		ch->sc_dma_op_count = segs;
		ch->sc_dma_ops_dma = dp;
	}

	op = ch->sc_dma_ops;

	while (l) {
		op->ptr = htole32(s);
		l = l - min(l, blksize);
		/* if last block */
		op->flags = htole32((l? AUVIA_DMAOP_FLAG : AUVIA_DMAOP_EOL) | blksize);
		s += blksize;
		op++;
	}

	return 0;
}


int
auvia_trigger_output(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct auvia_softc *sc = addr;
	struct auvia_softc_chan *ch = &(sc->sc_play);
	struct auvia_dma *p;

	for (p = sc->sc_dmas; p && p->addr != start; p = p->next)
		;

	if (!p)
		panic("auvia_trigger_output: request with bad start "
		    "address (%p)", start);

	if (auvia_build_dma_ops(sc, ch, p, start, end, blksize)) {
		return 1;
	}

	ch->sc_intr = intr;
	ch->sc_arg = arg;

	CH_WRITE4(sc, ch, AUVIA_RP_DMAOPS_BASE,
	    ch->sc_dma_ops_dma->map->dm_segs[0].ds_addr);
	mtx_enter(&audio_lock);
	if (sc->sc_flags & AUVIA_FLAGS_VT8233) {
		if (ch->sc_base != VIA8233_MP_BASE) {
			CH_WRITE1(sc, ch, VIA8233_RP_DXS_LVOL, 0);
			CH_WRITE1(sc, ch, VIA8233_RP_DXS_RVOL, 0);
		}
		CH_WRITE1(sc, ch, AUVIA_RP_CONTROL,
		    AUVIA_RPCTRL_START | AUVIA_RPCTRL_AUTOSTART |
		    AUVIA_RPCTRL_STOP  | AUVIA_RPCTRL_EOL | AUVIA_RPCTRL_FLAG);
	} else {
		CH_WRITE1(sc, ch, AUVIA_RP_MODE, ch->sc_reg);
		CH_WRITE1(sc, ch, AUVIA_RP_CONTROL, AUVIA_RPCTRL_START);
	}
	mtx_leave(&audio_lock);
	return 0;
}


int
auvia_trigger_input(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct auvia_softc *sc = addr;
	struct auvia_softc_chan *ch = &(sc->sc_record);
	struct auvia_dma *p;

	for (p = sc->sc_dmas; p && p->addr != start; p = p->next)
		;

	if (!p)
		panic("auvia_trigger_input: request with bad start "
		    "address (%p)", start);

	if (auvia_build_dma_ops(sc, ch, p, start, end, blksize))
		return 1;

	ch->sc_intr = intr;
	ch->sc_arg = arg;

	CH_WRITE4(sc, ch, AUVIA_RP_DMAOPS_BASE,
		  ch->sc_dma_ops_dma->map->dm_segs[0].ds_addr);

	mtx_enter(&audio_lock);
	if (sc->sc_flags & AUVIA_FLAGS_VT8233) {
		if (ch->sc_base != VIA8233_MP_BASE) {
			CH_WRITE1(sc, ch, VIA8233_RP_DXS_LVOL, 0);
			CH_WRITE1(sc, ch, VIA8233_RP_DXS_RVOL, 0);
		}
		CH_WRITE1(sc, ch, AUVIA_RP_CONTROL,
		    AUVIA_RPCTRL_START | AUVIA_RPCTRL_AUTOSTART |
		    AUVIA_RPCTRL_STOP  | AUVIA_RPCTRL_EOL | AUVIA_RPCTRL_FLAG);
	} else {
		CH_WRITE1(sc, ch, AUVIA_RP_MODE, ch->sc_reg);
		CH_WRITE1(sc, ch, AUVIA_RP_CONTROL, AUVIA_RPCTRL_START);
	}
	mtx_leave(&audio_lock);
	return 0;
}


int
auvia_intr(void *arg)
{
	struct auvia_softc *sc = arg;
	struct auvia_softc_chan *ch;
	u_int8_t r;
	int i = 0;

	mtx_enter(&audio_lock);
	ch = &sc->sc_record;
	r = CH_READ1(sc, ch, AUVIA_RP_STAT);
	if (r & AUVIA_RPSTAT_INTR) {
		if (sc->sc_record.sc_intr)
			sc->sc_record.sc_intr(sc->sc_record.sc_arg);

		/* clear interrupts */
		CH_WRITE1(sc, ch, AUVIA_RP_STAT, AUVIA_RPSTAT_INTR);

		i++;
	}
	ch = &sc->sc_play;
	r = CH_READ1(sc, ch, AUVIA_RP_STAT);
	if (r & AUVIA_RPSTAT_INTR) {
		if (sc->sc_play.sc_intr)
			sc->sc_play.sc_intr(sc->sc_play.sc_arg);

		/* clear interrupts */
		CH_WRITE1(sc, ch, AUVIA_RP_STAT, AUVIA_RPSTAT_INTR);

		i++;
	}
	mtx_leave(&audio_lock);
	return (i? 1 : 0);
}


int
auvia_resume(struct auvia_softc *sc)
{
	pci_conf_read(sc->sc_pc, sc->sc_pt, AUVIA_PCICONF_JUNK);
	pci_conf_write(sc->sc_pc, sc->sc_pt, AUVIA_PCICONF_JUNK,
	    sc->sc_pci_junk);

	ac97_resume(&sc->host_if, sc->codec_if);

	return (0);
}

@


1.57
log
@Remove unused getdev() audio driver functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.56 2016/09/14 06:12:19 ratchov Exp $ */
a231 1
	int rv = 0;
d233 1
a233 2
	switch (act) {
	case DVACT_RESUME:
d235 1
a235 7
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
a236 1

@


1.56
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.54 2015/05/07 01:55:43 jsg Exp $ */
a83 1
int	auvia_getdev(void *, struct audio_device *);
a193 1
	auvia_getdev,
a689 17
	return 0;
}


int
auvia_getdev(void *addr, struct audio_device *retp)
{
	struct auvia_softc *sc = addr;

	if (retp) {
		strncpy(retp->name,
		    sc->sc_flags & AUVIA_FLAGS_VT8233? "VIA VT8233" :
		    "VIA VT82C686A", sizeof(retp->name));
		strncpy(retp->version, sc->sc_revision, sizeof(retp->version));
		strncpy(retp->config, "auvia", sizeof(retp->config));
	}

@


1.55
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@a76 1
int	auvia_query_encoding(void *, struct audio_encoding *);
a80 1
void	auvia_get_default_params(void *, int, struct audio_params *);
a90 1
paddr_t	auvia_mappage(void *, void *, off_t, int);
a184 2
	NULL, /* drain */
	auvia_query_encoding,
a202 1
	auvia_mappage,
d205 1
a205 2
	auvia_trigger_input,
	auvia_get_default_params
a509 42
int
auvia_query_encoding(void *addr, struct audio_encoding *fp)
{
	struct auvia_softc *sc = addr;

	if (sc->sc_spdif) {
		switch (fp->index) {
		case 0:
			strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
			fp->precision = 16;
			fp->flags = 0;
			fp->bps = 2;
			fp->msb = 1;
			return (0);
		default:
			return (EINVAL);
		}
	} else {
		switch (fp->index) {
		case 0:
			strlcpy(fp->name, AudioEulinear, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_ULINEAR;
			fp->precision = 8;
			fp->flags = 0;
			break;
		case 1:
			strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
			fp->precision = 16;
			fp->flags = 0;
			break;
		default:
			return (EINVAL);
		}
		fp->bps = AUDIO_BPS(fp->precision);
		fp->msb = 1;

		return (0);
	}
}

a549 6
void
auvia_get_default_params(void *addr, int mode, struct audio_params *params)
{
	ac97_get_default_params(params);
}

a827 20

paddr_t
auvia_mappage(void *addr, void *mem, off_t off, int prot)
{
	struct auvia_softc *sc = addr;
	struct auvia_dma *p;

	if (off < 0)
		return -1;

	for (p = sc->sc_dmas; p && p->addr != mem; p = p->next)
		;

	if (!p)
		return -1;

	return bus_dmamem_mmap(sc->sc_dmat, &p->seg, 1, off, prot,
	    BUS_DMA_WAITOK);
}

@


1.54
log
@fix indentation
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.53 2014/07/12 18:48:51 tedu Exp $ */
a50 2
#include <dev/mulaw.h>
#include <dev/auconv.h>
a543 18
			strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_ULAW;
			fp->precision = 8;
			fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
			break;
		case 2:
			strlcpy(fp->name, AudioEalaw, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_ALAW;
			fp->precision = 8;
			fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
			break;
		case 3:
			strlcpy(fp->name, AudioEslinear, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_SLINEAR;
			fp->precision = 8;
			fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
			break;
		case 4:
a548 18
		case 5:
			strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
			fp->precision = 16;
			fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
			break;
		case 6:
			strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
			fp->precision = 16;
			fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
			break;
		case 7:
			strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
			fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
			fp->precision = 16;
			fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
			break;
d568 1
a568 1
			| (p->precision * p->factor == 16 ?
a692 2
		p->factor = 1;
		p->sw_code = 0;
a693 6
		case AUDIO_ENCODING_SLINEAR_BE:
			if (p->precision == 16)
				p->sw_code = swap_bytes;
			else
				p->sw_code = change_sign8;
			break;
d696 1
a696 1
				p->sw_code = change_sign8;
d698 1
d700 2
a701 25
			if (p->precision == 16)
				p->sw_code = mode == AUMODE_PLAY?
				    swap_bytes_change_sign16_le :
				    change_sign16_swap_bytes_le;
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			if (p->precision == 16)
				p->sw_code = change_sign16_le;
			break;
		case AUDIO_ENCODING_ULAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = mulaw_to_slinear16_le;
			} else
				p->sw_code = ulinear8_to_mulaw;
			break;
		case AUDIO_ENCODING_ALAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = alaw_to_slinear16_le;
			} else
				p->sw_code = ulinear8_to_alaw;
			break;
		case AUDIO_ENCODING_SLINEAR:
		case AUDIO_ENCODING_ULINEAR:
@


1.53
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.52 2013/12/06 21:03:03 deraadt Exp $ */
d722 1
a722 1
				return (EINVAL);
@


1.52
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.51 2013/05/24 07:58:46 ratchov Exp $ */
d917 1
a917 1
	free(p, pool);
d936 1
a936 1
			free(p, pool);
@


1.51
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.50 2013/05/15 08:29:24 ratchov Exp $ */
a245 5
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
	case DVACT_SUSPEND:
		break;
d250 2
a251 1
	case DVACT_DEACTIVATE:
@


1.50
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.49 2011/07/03 15:47:16 matthew Exp $ */
d301 2
a302 2
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO, auvia_intr, sc,
	    sc->sc_dev.dv_xname);
@


1.49
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.48 2011/04/03 15:36:02 jasper Exp $ */
d514 1
d1065 1
a1065 1

d1078 1
a1078 1

d1107 1
d1120 1
d1133 1
a1133 1

d1156 1
a1156 1

@


1.48
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.47 2010/09/12 03:17:34 jakemsr Exp $ */
a245 2
 	case DVACT_ACTIVATE:
		break;
@


1.47
log
@silly me.  use the switch() variable, not the case value.
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.46 2010/09/12 02:03:35 jakemsr Exp $ */
d236 1
a236 1
	    sizeof(auvia_devices)/sizeof(auvia_devices[0])));
@


1.46
log
@autoconf activate suspend/resume for auvia(4).  uses new audio(4)
DVACT_{QUIESCE,RESUME].
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.45 2010/07/15 03:43:11 jakemsr Exp $ */
d249 1
a249 1
		rv = config_activate_children(self, DVACT_QUIESCE);
d255 1
a255 1
		rv = config_activate_children(self, DVACT_RESUME);
@


1.45
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.44 2008/10/25 22:30:43 jakemsr Exp $ */
d106 2
d113 2
a114 1
	sizeof (struct auvia_softc), auvia_match, auvia_attach
d225 2
d239 24
d328 1
d1158 14
@


1.44
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.43 2008/10/23 21:50:01 jakemsr Exp $ */
d506 2
d519 1
a519 1
			return (0);
d525 1
a525 1
			return (0);
d531 1
a531 1
			return (0);
d537 1
a537 1
			return (0);
d543 1
a543 1
			return (0);
d549 1
a549 1
			return (0);
d555 1
a555 1
			return (0);
d561 1
a561 1
			return (0);
d565 4
d571 1
d750 3
@


1.43
log
@
S/PDIF output support in ac97(4), auich(4) and auvia(4)

from NetBSD

tested by a few with no regressions.  optical works for jsg@@.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.42 2008/10/02 18:29:40 jakemsr Exp $ */
d651 1
a651 1
				return (EINVAL);
d654 2
a655 2
			if (p->channels != 1 && p->channels != 2)
				return (EINVAL);
d658 13
a670 3
		if ((p->sample_rate < 4000 || p->sample_rate > 48000) ||
		    (p->precision != 8 && p->precision != 16))
			return (EINVAL);
@


1.42
log
@
according to the alsa driver for these devices, the hardware provides
256 buffer descriptors, and the 256th descriptor is flakey.  this
driver uses one descriptor for each block of the buffer, so we need
to make sure buffer size / block size < 256, or we will run out of
usable descriptors.

lets me play youtube videos via gnash on my auvia equipped machine.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.41 2008/09/24 19:09:05 chl Exp $ */
d220 1
d305 1
d346 1
d464 7
d474 2
d484 1
d497 66
a562 51
	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = 0;
		return (0);
	case 1:
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		return (0);
	case 2:
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		return (0);
	case 3:
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		return (0);
	case 4:
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		return (0);
	case 5:
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		return (0);
	case 6:
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		return (0);
	case 7:
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		return (0);
	default:
		return (EINVAL);
a564 1

d660 6
@


1.41
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.40 2008/08/12 06:50:16 jakemsr Exp $ */
d94 1
d206 1
a206 1
	NULL, /* auvia_round_buffersize */
d709 4
d865 9
d918 4
@


1.40
log
@
VT8233+ uses a different register base for capturing

from NetBSD.  fixes recording for kili@@, martynas@@ and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.39 2008/06/26 05:42:17 ray Exp $ */
a925 1
	dp = ch->sc_dma_ops_dma;
@


1.39
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.38 2008/05/25 23:59:33 jakemsr Exp $ */
d164 2
d252 1
a882 1
	struct auvia_softc *sc = addr;
d885 1
a885 5
	props = AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT; 

	/* recording doesn't work correctly on 8233 based devices */
	if (!(sc->sc_flags & AUVIA_FLAGS_VT8233))
		props |= AUDIO_PROP_FULLDUPLEX;
@


1.38
log
@
use ac97 default parameters for auich(4), auixp(4) and auvia(4).
they may have codecs which only handle 48kHz sampling rates.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.37 2008/04/21 00:32:42 jakemsr Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.37
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.36 2008/03/30 08:48:53 jakemsr Exp $ */
d91 1
d215 1
a215 1
	NULL
d581 5
@


1.36
log
@todd@@ has 82c686 based auvia(4) devices that do full-duplex
properly.  restore full-duplex capabilities for 82c686 based
devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.34 2008/01/15 02:52:50 jakemsr Exp $ */
d213 2
a214 1
	auvia_trigger_input
@


1.35
log
@auvia(4) doesn't record properly, so don't claim full-duplex
capabilities.
@
text
@d880 10
a889 1
	return (AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT);
@


1.34
log
@bring in lots of ac97(4) and auvia(4) updates from NetBSD

user visible changes:
- when setting up ac97(4) mixer items, for some features like surround
  sound, check if the feature if supported by the codec and only add
  items for that feature if it is
- auvia(4) now supports multichannel playback with at least some
  multichannel ac97(4) codecs

fixes problems for me and ajacoutot with different auvia(4)
devices/codecs.  no regressions reported by testers.

if you have an ac97(4) audio device and are using mixerctl.conf(5),
you may want/need to update it.

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.33 2005/05/06 01:45:22 miod Exp $ */
d880 1
a880 2
	return (AUDIO_PROP_MMAP |  AUDIO_PROP_INDEPENDENT |
	    AUDIO_PROP_FULLDUPLEX);
@


1.33
log
@Remove debug printf which crept in; spotted by drahn@@
@
text
@d1 2
a2 2
/*	$OpenBSD: auvia.c,v 1.32 2005/04/16 21:57:23 mickey Exp $ */
/*	$NetBSD: auvia.c,v 1.7 2000/11/15 21:06:33 jdolecek Exp $	*/
a81 3
/* rev. H and later seem to support only fixed rate 44.1 kHz */
#define	AUVIA_FIXED_RATE	44100

d86 3
a88 1
int	auvia_query_encoding(void *addr, struct audio_encoding *fp);
d133 1
d144 1
a144 1
#define AUVIA_RP_MODE			0x02
d159 10
a168 1
#define VIA_RP_DMAOPS_COUNT		0x0C
d176 9
d250 3
a252 1
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VT8233_AC97)
d254 2
d539 40
d585 1
d587 3
a589 2
	u_int16_t regval;
	int mode, base;
d599 2
a600 1
			base = AUVIA_PLAY_BASE;
d603 2
a604 1
			base = AUVIA_RECORD_BASE;
d607 18
a624 15
		if (sc->sc_flags & AUVIA_FLAGS_VT8233) {
			u_int32_t v = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			    base + VIA8233_RP_RATEFMT) & ~(VIA8233_RATEFMT_48K
			    | VIA8233_RATEFMT_STEREO | VIA8233_RATEFMT_16BIT);

			v |= VIA8233_RATEFMT_48K *
			    (p->sample_rate / 20) / (48000 / 20);

			if (p->channels == 2)
				v |= VIA8233_RATEFMT_STEREO;
			if (p->precision == 16)
				v |= VIA8233_RATEFMT_16BIT;

			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    base + VIA8233_RP_RATEFMT, v);
d627 2
a628 1
		if (ac97_set_rate(sc->codec_if, p, mode))
d631 20
a650 3
		if ((p->precision != 8 && p->precision != 16) ||
		    (p->channels != 1 && p->channels != 2))
			return (EINVAL);
d695 1
a695 11

		regval = (p->channels == 2 ? AUVIA_RPMODE_STEREO : 0)
			| (p->precision * p->factor == 16 ?
				AUVIA_RPMODE_16BIT : 0)
			| AUVIA_RPMODE_INTR_FLAG | AUVIA_RPMODE_INTR_EOL
			| AUVIA_RPMODE_AUTOSTART;

		if (mode == AUMODE_PLAY)
			sc->sc_play.sc_reg = regval;
		else
			sc->sc_record.sc_reg = regval;
d713 1
d715 2
a716 3
	bus_space_write_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_PLAY_BASE + AUVIA_RP_CONTROL, AUVIA_RPCTRL_TERMINATE);

d725 1
d727 2
a728 3
	bus_space_write_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_RECORD_BASE + AUVIA_RP_CONTROL, AUVIA_RPCTRL_TERMINATE);

d958 1
a958 2
	bus_space_write_4(sc->sc_iot, sc->sc_ioh,
	    AUVIA_PLAY_BASE + AUVIA_RP_DMAOPS_BASE,
a960 3
	bus_space_write_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_PLAY_BASE + AUVIA_RP_MODE, ch->sc_reg);

d962 5
a966 6
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_PLAY_BASE + VIA8233_RP_DXS_LVOL, 0);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_PLAY_BASE + VIA8233_RP_DXS_RVOL, 0);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_PLAY_BASE + AUVIA_RP_CONTROL,
d969 4
a972 3
	} else
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_PLAY_BASE + AUVIA_RP_CONTROL, AUVIA_RPCTRL_START);
d999 2
a1000 5
	bus_space_write_4(sc->sc_iot, sc->sc_ioh,
	    AUVIA_RECORD_BASE + AUVIA_RP_DMAOPS_BASE,
	    ch->sc_dma_ops_dma->map->dm_segs[0].ds_addr);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_RECORD_BASE + AUVIA_RP_MODE, ch->sc_reg);
d1003 5
a1007 6
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_RECORD_BASE + VIA8233_RP_DXS_LVOL, 0);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_RECORD_BASE + VIA8233_RP_DXS_RVOL, 0);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_RECORD_BASE + AUVIA_RP_CONTROL,
d1010 4
a1013 4
	} else
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_RECORD_BASE + AUVIA_RP_CONTROL, AUVIA_RPCTRL_START);

d1022 1
d1026 3
a1028 2
	r = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_RECORD_BASE + AUVIA_RP_STAT);
d1034 1
a1034 2
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_RECORD_BASE + AUVIA_RP_STAT, AUVIA_RPSTAT_INTR);
d1038 2
a1039 2
	r = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_PLAY_BASE + AUVIA_RP_STAT);
d1045 1
a1045 2
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_PLAY_BASE + AUVIA_RP_STAT, AUVIA_RPSTAT_INTR);
@


1.32
log
@do not provide round_buffer if not needed unless explained why in comments
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.31 2005/04/14 12:42:16 mickey Exp $ */
a845 1
	printf("auvia: op = %p\n", op);
@


1.31
log
@make sure round_blocksize does not produce 0 after alignment
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.30 2005/04/11 19:31:43 matthieu Exp $ */
a100 1
size_t	auvia_round_buffersize(void *, int, size_t);
d191 1
a191 1
	auvia_round_buffersize,
a778 8


size_t
auvia_round_buffersize(void *addr, int direction, size_t size)
{
	return size;
}

@


1.30
log
@Make sure that the requested size is a multiple of block size in
auvia_build_dma_ops(). Patch by miod@@, ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.29 2004/12/07 03:17:42 jsg Exp $ */
d629 1
a629 1
	return (blk & -32);
@


1.29
log
@Don't link to ac97 specs from individual drivers.
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.28 2004/09/14 23:45:11 pvalchev Exp $ */
d603 3
d828 2
a829 2
	l = ((char *)end - (char *)start);
	segs = (l + blksize - 1) / blksize;
d831 1
a831 1
	if (segs > (ch->sc_dma_op_count)) {
d855 1
d858 1
a858 1
		l = l - blksize;
@


1.28
log
@remove unused variable; netbsd, ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.27 2004/01/09 21:32:24 brad Exp $ */
a45 2
 * ftp://ftp.alsa-project.org/pub/manuals/general/ac97r21.pdf
 * ftp://ftp.alsa-project.org/pub/manuals/ad/AD1881_0.pdf (example AC'97 codec)
@


1.27
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.26 2003/10/19 20:33:28 grange Exp $ */
d822 1
a822 1
	bus_addr_t s, e;
a827 1
	e = s + l;
@


1.26
log
@Put fix from NetBSD:
Enable auvia_reset_codec's code and wait until the card is available.
Fixes 'invalid codec' problems (at least with AD1980).

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.25 2003/05/21 19:32:20 drahn Exp $ */
a54 2

#include <uvm/uvm_extern.h>
@


1.25
log
@Endian fix for this driver, now works on big endian machines, ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.24 2003/04/27 11:22:53 ho Exp $ */
d134 1
d345 1
a345 1
#ifdef notyet /* XXX seems to make codec become unready... ??? */
d361 5
a365 2
	auvia_waitready_codec(sc);
#endif
@


1.24
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.23 2003/02/28 15:26:23 mickey Exp $ */
d854 1
a854 1
		op->ptr = s;
d857 1
a857 1
		op->flags = (l? AUVIA_DMAOP_FLAG : AUVIA_DMAOP_EOL) | blksize;
@


1.23
log
@remove non-typo changes. sorry folks
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.21 2002/11/19 18:40:17 jason Exp $ */
d466 1
a466 1
		strcpy(fp->name, AudioEulinear);
d472 1
a472 1
		strcpy(fp->name, AudioEmulaw);
d478 1
a478 1
		strcpy(fp->name, AudioEalaw);
d484 1
a484 1
		strcpy(fp->name, AudioEslinear);
d490 1
a490 1
		strcpy(fp->name, AudioEslinear_le);
d496 1
a496 1
		strcpy(fp->name, AudioEulinear_le);
d502 1
a502 1
		strcpy(fp->name, AudioEslinear_be);
d508 1
a508 1
		strcpy(fp->name, AudioEulinear_be);
@


1.22
log
@typo; from weissmanndude
@
text
@d135 2
a136 2
#define AUVIA_PLAY_BASE		0x00
#define AUVIA_RECORD_BASE	0x10
d138 6
a143 6
#define	AUVIA_RP_STAT		0x00
#define		AUVIA_RPSTAT_INTR	0x03
#define AUVIA_RP_CONTROL	0x01
#define		AUVIA_RPCTRL_START	0x80
#define		AUVIA_RPCTRL_TERMINATE	0x40
#define		AUVIA_RPCTRL_AUTOSTART	0x20
d145 14
a158 18
#define		AUVIA_RPCTRL_STOP	0x04
#define		AUVIA_RPCTRL_EOL	0x02
#define		AUVIA_RPCTRL_FLAG	0x01
#define AUVIA_RP_MODE		0x02
#define		AUVIA_RPMODE_INTR_FLAG	0x01
#define		AUVIA_RPMODE_INTR_EOL	0x02
#define		AUVIA_RPMODE_STEREO	0x10
#define		AUVIA_RPMODE_16BIT	0x20
#define		AUVIA_RPMODE_AUTOSTART	0x80
#define	AUVIA_RP_DMAOPS_BASE	0x04
#define		AUVIA_RPDMAOP_PTR	0x00
#define		AUVIA_RPDMAOP_IDX	0x04
#define		AUVIA_RPDMAOP_CNT	0x08
#define		AUVIA_RPDMAOP_CHIDX	0x0f

#define	VIA8233_RP_DXS_LVOL	0x02
#define	VIA8233_RP_DXS_RVOL	0x03
#define	VIA8233_RP_RATEFMT	0x08
d163 7
a169 11
#define	AUVIA_MPB_BASE		0x40
#define		AUVIA_MPBMODE_16BIT	0x80
#define		AUVIA_MPBMODE_CHMASK	0x70

#define	AUVIA_CAPTURE_BASE	0x60

#define	AUVIA_CODEC_CTL		0x80
#define		AUVIA_CODEC_READ	0x00800000
#define		AUVIA_CODEC_BUSY	0x01000000
#define		AUVIA_CODEC_PRIVALID	0x02000000
#define		AUVIA_CODEC_INDEX(x)	((x)<<16)
a232 1
	const char *p;
a268 15
	switch (PCI_REVISION(pa->pa_class) & 0xf0) {
	case 0x10: p = "pre-8233";	break;
	case 0x20: p = "8233C";		break;
	case 0x30: p = "8233";		break;
	case 0x50: p = "8235";		break;
	case 0x40: p = "8233A";
		sc->sc_flags |= AUVIA_FLAGS_MPB;
		break;
	}

	sprintf(sc->sc_audev.name, "%s AC97", p);
	sprintf(sc->sc_audev.version, "0x%x",
	    PCI_REVISION(pa->pa_class) & 0xf);
	strcpy(sc->sc_audev.config, sc->sc_dev.dv_xname);

d550 4
a553 27
			if (mode == AUMODE_PLAY &&
			    sc->sc_flags & AUVIA_FLAGS_MPB) {
				static const u_int32_t nch2sl[] = {
					0, 1, 0x21, 0,
					0x4321, 0, 0x436521
				};
				int slots;

				bus_space_write_1(sc->sc_iot, sc->sc_ioh,
				    AUVIA_MPB_BASE + AUVIA_RP_MODE,
				    (p->precision == 16? AUVIA_MPBMODE_16BIT:0)
				    | (p->channels << 4));

				if (p->channels <
				    sizeof(nch2sl) / sizeof(*nch2sl))
					slots = 0;
				else
					slots = nch2sl[p->channels];
				bus_space_write_4(sc->sc_iot, sc->sc_ioh,
				    AUVIA_RP_DMAOPS_BASE + AUVIA_RPDMAOP_IDX,
				    slots | 0xff000000);
			} else {
				if (p->channels == 2)
					v |= VIA8233_RATEFMT_STEREO;
				if (p->precision == 16)
					v |= VIA8233_RATEFMT_16BIT;
			}
d655 1
a655 1
auvia_getdev(void *v, struct audio_device *adp)
d657 10
a666 2
	struct auvia_softc *sc = v;
	*adp = sc->sc_audev;
d961 1
a961 1
	int base, i = 0;
d975 2
a976 6

	if (sc->sc_flags & AUVIA_FLAGS_MPB)
		base = AUVIA_MPB_BASE;
	else
		base = AUVIA_PLAY_BASE;
	r = bus_space_read_1(sc->sc_iot, sc->sc_ioh, base + AUVIA_RP_STAT);
d983 1
a983 1
		    base + AUVIA_RP_STAT, AUVIA_RPSTAT_INTR);
@


1.21
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.20 2002/06/03 16:19:22 mickey Exp $ */
d135 2
a136 2
#define AUVIA_PLAY_BASE			0x00
#define AUVIA_RECORD_BASE		0x10
d138 6
a143 6
#define	AUVIA_RP_STAT			0x00
#define		AUVIA_RPSTAT_INTR		0x03
#define AUVIA_RP_CONTROL		0x01
#define		AUVIA_RPCTRL_START		0x80
#define		AUVIA_RPCTRL_TERMINATE		0x40
#define		AUVIA_RPCTRL_AUTOSTART		0x20
d145 18
a162 14
#define		AUVIA_RPCTRL_STOP		0x04
#define		AUVIA_RPCTRL_EOL		0x02
#define		AUVIA_RPCTRL_FLAG		0x01
#define AUVIA_RP_MODE			0x02
#define		AUVIA_RPMODE_INTR_FLAG		0x01
#define		AUVIA_RPMODE_INTR_EOL		0x02
#define		AUVIA_RPMODE_STEREO		0x10
#define		AUVIA_RPMODE_16BIT		0x20
#define		AUVIA_RPMODE_AUTOSTART		0x80
#define	AUVIA_RP_DMAOPS_BASE		0x04

#define	VIA8233_RP_DXS_LVOL		0x02
#define	VIA8233_RP_DXS_RVOL		0x03
#define	VIA8233_RP_RATEFMT		0x08
d167 11
a177 7
#define VIA_RP_DMAOPS_COUNT		0x0C

#define	AUVIA_CODEC_CTL			0x80
#define		AUVIA_CODEC_READ		0x00800000
#define		AUVIA_CODEC_BUSY		0x01000000
#define		AUVIA_CODEC_PRIVALID		0x02000000
#define		AUVIA_CODEC_INDEX(x)		((x)<<16)
d241 1
d278 15
d574 27
a600 4
			if (p->channels == 2)
				v |= VIA8233_RATEFMT_STEREO;
			if (p->precision == 16)
				v |= VIA8233_RATEFMT_16BIT;
d702 1
a702 1
auvia_getdev(void *addr, struct audio_device *retp)
d704 2
a705 10
	struct auvia_softc *sc = addr;

	if (retp) {
		strncpy(retp->name,
		    sc->sc_flags & AUVIA_FLAGS_VT8233? "VIA VT8233" :
		    "VIA VT82C686A", sizeof(retp->name));
		strncpy(retp->version, sc->sc_revision, sizeof(retp->version));
		strncpy(retp->config, "auvia", sizeof(retp->config));
	}

d1000 1
a1000 1
	int i = 0;
d1014 6
a1019 2
	r = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_PLAY_BASE + AUVIA_RP_STAT);
d1026 1
a1026 1
		    AUVIA_PLAY_BASE + AUVIA_RP_STAT, AUVIA_RPSTAT_INTR);
@


1.20
log
@wrong cutnpaster; problem reported by Tim Tickel <twt@@globodom.com> via pr2711
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.19 2002/06/02 05:03:18 mickey Exp $ */
d209 4
d217 2
a218 13
	struct pci_attach_args *pa = (struct pci_attach_args *) aux;

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_VIATECH)
		return 0;

	switch(PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_VIATECH_VT82C686A_AC97:
		return 1;
	case PCI_PRODUCT_VIATECH_VT8233_AC97:
		return 1;
	default:
		return 0;
	}
@


1.19
log
@knf, spaces, no \n in panic
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.18 2002/05/31 20:28:38 mickey Exp $ */
d900 1
a900 1
	    AUVIA_PLAY_BASE + AUVIA_RP_CONTROL, ch->sc_reg);
@


1.18
log
@put the right thing into the audio name; pt out by Sebastian Stark <seb@@todesplanet.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.17 2002/05/30 15:13:20 mickey Exp $ */
d156 3
a158 3
#define	VIA8233_RP_DXS_LVOL          0x02
#define	VIA8233_RP_DXS_RVOL          0x03
#define	VIA8233_RP_RATEFMT           0x08
d163 1
a163 1
#define VIA_RP_DMAOPS_COUNT         0x0C
d218 1
a218 1
	switch(PCI_PRODUCT(pa->pa_id)) { 
d282 2
a283 2
	pr |= (AUVIA_PCICONF_ACLINKENAB | AUVIA_PCICONF_ACNOTRST
		| AUVIA_PCICONF_ACVSR | AUVIA_PCICONF_ACSGD);
d297 1
a297 1
			sc->sc_dev.dv_xname, r);
d318 1
a318 1
			d[i].class, d[i].device, AudioNmute);
d330 1
a330 1
		AudioCoutputs, AudioNmaster, NULL);
d363 1
a363 1
	r |= AUVIA_PCICONF_ACNOTRST;		/* disable RESET (inactive high) */
d379 1
a379 1
		AUVIA_CODEC_CTL) & AUVIA_CODEC_BUSY); i++)
d381 1
d398 3
a400 2
		AUVIA_CODEC_CTL) & AUVIA_CODEC_PRIVALID); i++)
			delay(1);
d419 1
a419 1
		AUVIA_CODEC_PRIVALID | AUVIA_CODEC_INDEX(reg) | val);
d434 1
a434 1
		AUVIA_CODEC_PRIVALID | AUVIA_CODEC_READ | AUVIA_CODEC_INDEX(reg));
d528 1
a528 1
	struct audio_params *play, struct audio_params *rec)
d587 4
a590 6
			if (p->precision == 16) {
				if (mode == AUMODE_PLAY)
					p->sw_code = swap_bytes_change_sign16_le;
				else
					p->sw_code = change_sign16_swap_bytes_le;
			}
d620 1
a620 1
		if (mode == AUMODE_PLAY) {
d622 1
a622 1
		} else {
a623 1
		}
d816 2
a817 2
	return AUDIO_PROP_MMAP |  AUDIO_PROP_INDEPENDENT
		| AUDIO_PROP_FULLDUPLEX;
d823 1
a823 1
	struct auvia_dma *p, void *start, void *end, int blksize)
d838 1
a838 1
		if (ch->sc_dma_ops) {
a839 1
		}
d842 1
a842 1
			sizeof(struct auvia_dma_op) * segs, M_DEVBUF, M_WAITOK);
d844 3
a846 4
		for (dp = sc->sc_dmas;
			dp && dp->addr != (void *)(ch->sc_dma_ops);
			dp = dp->next)
				;
d850 2
a851 2
				"address (%p)\n", sc->sc_dev.dv_xname,
				ch->sc_dma_ops);
d863 2
a864 6
		if (!l) {
			/* if last block */
			op->flags = AUVIA_DMAOP_EOL | blksize;
		} else {
			op->flags = AUVIA_DMAOP_FLAG | blksize;
		}
d874 2
a875 3
auvia_trigger_output(void *addr, void *start, void *end,
	int blksize, void (*intr)(void *), void *arg,
	struct audio_params *param)
d886 1
a886 1
			"address (%p)\n", start);
d920 2
a921 3
auvia_trigger_input(void *addr, void *start, void *end,
	int blksize, void (*intr)(void *), void *arg,
	struct audio_params *param)
d932 1
a932 1
			"address (%p)\n", start);
d934 1
a934 1
	if (auvia_build_dma_ops(sc, ch, p, start, end, blksize)) {
a935 1
	}
d944 1
a944 2
	    AUVIA_RECORD_BASE + AUVIA_RP_MODE,
	    ch->sc_reg);
@


1.17
log
@proper support for vt8233; from freebsd; tested by Jolan Luff <jolan@@encryptedemail.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.16 2002/05/08 18:33:53 mickey Exp $ */
d668 3
a670 1
		strncpy(retp->name, "VIA VT82C686A", sizeof(retp->name));
@


1.16
log
@kt266 is reported to be doing auvia alright by Ian McWilliam <ianm@@cit.uws.edu.au>
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.15 2002/03/14 01:26:58 millert Exp $ */
d135 4
a138 2
#define AUVIA_PLAY_STAT			0x00
#define AUVIA_RECORD_STAT		0x10
d140 1
a140 2
#define AUVIA_PLAY_CONTROL		0x01
#define AUVIA_RECORD_CONTROL		0x11
d143 6
a148 2
#define AUVIA_PLAY_MODE			0x02
#define AUVIA_RECORD_MODE		0x12
d154 10
a163 2
#define	AUVIA_PLAY_DMAOPS_BASE		0x04
#define	AUVIA_RECORD_DMAOPS_BASE	0x14
d239 1
d243 13
d257 2
a258 1
		printf("%s: couldn't map interrupt\n", sc->sc_dev.dv_xname);
d270 1
a273 4
	sc->sc_dmat = pa->pa_dmat;
	sc->sc_pc = pc;
	sc->sc_pt = pt;

a275 6
	if (pci_mapreg_map(pa, 0x10, PCI_MAPREG_TYPE_IO, 0, &sc->sc_iot,
	    &sc->sc_ioh, &sc->sc_ioaddr, &sc->sc_iosize, 0)) {
		printf("%s: can't map i/o space\n", sc->sc_dev.dv_xname);
		return;
	}

d298 2
d531 1
a531 1
	int mode;
d539 24
a562 1
		p = mode == AUMODE_PLAY ? play : rec;
d643 2
a644 2
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AUVIA_PLAY_CONTROL,
		AUVIA_RPCTRL_TERMINATE);
d655 2
a656 2
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AUVIA_RECORD_CONTROL,
		AUVIA_RPCTRL_TERMINATE);
d901 19
a919 8
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, AUVIA_PLAY_DMAOPS_BASE,
		ch->sc_dma_ops_dma->map->dm_segs[0].ds_addr);

	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AUVIA_PLAY_MODE,
		ch->sc_reg);

	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AUVIA_PLAY_CONTROL,
		AUVIA_RPCTRL_START);
d948 19
a966 8
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, AUVIA_RECORD_DMAOPS_BASE,
		ch->sc_dma_ops_dma->map->dm_segs[0].ds_addr);

	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AUVIA_RECORD_MODE,
		ch->sc_reg);

	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AUVIA_RECORD_CONTROL,
		AUVIA_RPCTRL_START);
d979 2
a980 1
	r = bus_space_read_1(sc->sc_iot, sc->sc_ioh, AUVIA_RECORD_STAT);
d986 2
a987 2
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, AUVIA_RECORD_STAT,
			AUVIA_RPSTAT_INTR);
d991 2
a992 1
	r = bus_space_read_1(sc->sc_iot, sc->sc_ioh, AUVIA_PLAY_STAT);
d998 2
a999 2
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, AUVIA_PLAY_STAT,
			AUVIA_RPSTAT_INTR);
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.14 2002/01/20 19:56:53 ericj Exp $ */
d204 7
a210 1
	if (PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_VIATECH_VT82C686A_AC97)
d212 1
a212 2

	return 1;
@


1.14
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.13 2001/11/19 17:47:37 mickey Exp $ */
d115 1
a115 1
int	auvia_intr __P((void *));
@


1.13
log
@remove local hack and use ac97_set_rate; tested by form@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.12 2001/11/06 19:53:19 miod Exp $ */
d180 1
a180 1
	NULL,
d182 1
a182 1
	NULL,
d186 1
a186 3
	auvia_trigger_input,
	auvia_malloc,
	auvia_round_buffersize,
@


1.13.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.14 2002/01/20 19:56:53 ericj Exp $ */
d180 1
a180 1
	auvia_malloc,
d182 1
a182 1
	auvia_round_buffersize,
d186 3
a188 1
	auvia_trigger_input
@


1.13.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.13.2.1 2002/01/31 22:55:34 niklas Exp $ */
d115 1
a115 1
int	auvia_intr(void *);
d135 2
a136 4
#define AUVIA_PLAY_BASE			0x00
#define AUVIA_RECORD_BASE		0x10

#define	AUVIA_RP_STAT			0x00
d138 2
a139 1
#define AUVIA_RP_CONTROL		0x01
d142 2
a143 6
#define		AUVIA_RPCTRL_AUTOSTART		0x20
/* The following are 8233 specific */
#define		AUVIA_RPCTRL_STOP		0x04
#define		AUVIA_RPCTRL_EOL		0x02
#define		AUVIA_RPCTRL_FLAG		0x01
#define AUVIA_RP_MODE			0x02
d149 2
a150 10
#define	AUVIA_RP_DMAOPS_BASE		0x04

#define	VIA8233_RP_DXS_LVOL		0x02
#define	VIA8233_RP_DXS_RVOL		0x03
#define	VIA8233_RP_RATEFMT		0x08
#define		VIA8233_RATEFMT_48K	0xfffff
#define		VIA8233_RATEFMT_STEREO	0x00100000
#define		VIA8233_RATEFMT_16BIT	0x00200000

#define VIA_RP_DMAOPS_COUNT		0x0C
d204 2
d207 1
a207 8
	switch(PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_VIATECH_VT82C686A_AC97:
		return 1;
	case PCI_PRODUCT_VIATECH_VT8233_AC97:
		return 1;
	default:
		return 0;
	}
a220 1
	bus_size_t iosize;
a223 13
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VT8233_AC97)
		sc->sc_flags |= AUVIA_FLAGS_VT8233;

	if (pci_mapreg_map(pa, 0x10, PCI_MAPREG_TYPE_IO, 0, &sc->sc_iot,
	    &sc->sc_ioh, NULL, &iosize, 0)) {
		printf(": can't map i/o space\n");
		return;
	}

	sc->sc_dmat = pa->pa_dmat;
	sc->sc_pc = pc;
	sc->sc_pt = pt;

d225 1
a225 2
		printf(": couldn't map interrupt\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
a236 1
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
d240 4
d246 6
d258 2
a259 2
	pr |= (AUVIA_PCICONF_ACLINKENAB | AUVIA_PCICONF_ACNOTRST |
	    AUVIA_PCICONF_ACVSR | AUVIA_PCICONF_ACSGD);
d273 1
a273 3
		    sc->sc_dev.dv_xname, r);
		pci_intr_disestablish(pc, sc->sc_ih);
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
d292 1
a292 1
		    d[i].class, d[i].device, AudioNmute);
d304 1
a304 1
	    AudioCoutputs, AudioNmaster, NULL);
d337 1
a337 1
	r |= AUVIA_PCICONF_ACNOTRST;	/* disable RESET (inactive high) */
d353 1
a353 1
	     AUVIA_CODEC_CTL) & AUVIA_CODEC_BUSY); i++)
a354 1

d371 2
a372 3
	     AUVIA_CODEC_CTL) & AUVIA_CODEC_PRIVALID); i++)
		delay(1);

d391 1
a391 1
	    AUVIA_CODEC_PRIVALID | AUVIA_CODEC_INDEX(reg) | val);
d406 1
a406 1
	    AUVIA_CODEC_PRIVALID | AUVIA_CODEC_READ | AUVIA_CODEC_INDEX(reg));
d500 1
a500 1
    struct audio_params *play, struct audio_params *rec)
d505 1
a505 1
	int mode, base;
d513 1
a513 24
		if (mode == AUMODE_PLAY) {
			p = play;
			base = AUVIA_PLAY_BASE;
		} else {
			p = rec;
			base = AUVIA_RECORD_BASE;
		}

		if (sc->sc_flags & AUVIA_FLAGS_VT8233) {
			u_int32_t v = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			    base + VIA8233_RP_RATEFMT) & ~(VIA8233_RATEFMT_48K
			    | VIA8233_RATEFMT_STEREO | VIA8233_RATEFMT_16BIT);

			v |= VIA8233_RATEFMT_48K *
			    (p->sample_rate / 20) / (48000 / 20);

			if (p->channels == 2)
				v |= VIA8233_RATEFMT_STEREO;
			if (p->precision == 16)
				v |= VIA8233_RATEFMT_16BIT;

			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    base + VIA8233_RP_RATEFMT, v);
		}
d536 6
a541 4
			if (p->precision == 16)
				p->sw_code = mode == AUMODE_PLAY?
				    swap_bytes_change_sign16_le :
				    change_sign16_swap_bytes_le;
d571 1
a571 1
		if (mode == AUMODE_PLAY)
d573 1
a573 1
		else
d575 1
d594 2
a595 2
	bus_space_write_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_PLAY_BASE + AUVIA_RP_CONTROL, AUVIA_RPCTRL_TERMINATE);
d606 2
a607 2
	bus_space_write_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_RECORD_BASE + AUVIA_RP_CONTROL, AUVIA_RPCTRL_TERMINATE);
d619 1
a619 3
		strncpy(retp->name,
		    sc->sc_flags & AUVIA_FLAGS_VT8233? "VIA VT8233" :
		    "VIA VT82C686A", sizeof(retp->name));
d766 2
a767 2
	return (AUDIO_PROP_MMAP |  AUDIO_PROP_INDEPENDENT |
	    AUDIO_PROP_FULLDUPLEX);
d773 1
a773 1
    struct auvia_dma *p, void *start, void *end, int blksize)
d788 1
a788 1
		if (ch->sc_dma_ops)
d790 1
d793 1
a793 1
		    sizeof(struct auvia_dma_op) * segs, M_DEVBUF, M_WAITOK);
d795 4
a798 3
		for (dp = sc->sc_dmas; dp &&
		     dp->addr != (void *)(ch->sc_dma_ops); dp = dp->next)
			;
d802 2
a803 2
			    "address (%p)", sc->sc_dev.dv_xname,
			    ch->sc_dma_ops);
d815 6
a820 2
		/* if last block */
		op->flags = (l? AUVIA_DMAOP_FLAG : AUVIA_DMAOP_EOL) | blksize;
d830 3
a832 2
auvia_trigger_output(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
d843 1
a843 1
		    "address (%p)", start);
d852 2
a853 3
	bus_space_write_4(sc->sc_iot, sc->sc_ioh,
	    AUVIA_PLAY_BASE + AUVIA_RP_DMAOPS_BASE,
	    ch->sc_dma_ops_dma->map->dm_segs[0].ds_addr);
d855 2
a856 2
	bus_space_write_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_PLAY_BASE + AUVIA_RP_MODE, ch->sc_reg);
d858 2
a859 12
	if (sc->sc_flags & AUVIA_FLAGS_VT8233) {
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_PLAY_BASE + VIA8233_RP_DXS_LVOL, 0);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_PLAY_BASE + VIA8233_RP_DXS_RVOL, 0);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_PLAY_BASE + AUVIA_RP_CONTROL,
		    AUVIA_RPCTRL_START | AUVIA_RPCTRL_AUTOSTART |
		    AUVIA_RPCTRL_STOP  | AUVIA_RPCTRL_EOL | AUVIA_RPCTRL_FLAG);
	} else
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_PLAY_BASE + AUVIA_RP_CONTROL, AUVIA_RPCTRL_START);
d866 3
a868 2
auvia_trigger_input(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
d879 1
a879 1
		    "address (%p)", start);
d881 1
a881 1
	if (auvia_build_dma_ops(sc, ch, p, start, end, blksize))
d883 1
d888 8
a895 18
	bus_space_write_4(sc->sc_iot, sc->sc_ioh,
	    AUVIA_RECORD_BASE + AUVIA_RP_DMAOPS_BASE,
	    ch->sc_dma_ops_dma->map->dm_segs[0].ds_addr);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_RECORD_BASE + AUVIA_RP_MODE, ch->sc_reg);

	if (sc->sc_flags & AUVIA_FLAGS_VT8233) {
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_RECORD_BASE + VIA8233_RP_DXS_LVOL, 0);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_RECORD_BASE + VIA8233_RP_DXS_RVOL, 0);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_RECORD_BASE + AUVIA_RP_CONTROL,
		    AUVIA_RPCTRL_START | AUVIA_RPCTRL_AUTOSTART |
		    AUVIA_RPCTRL_STOP  | AUVIA_RPCTRL_EOL | AUVIA_RPCTRL_FLAG);
	} else
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_RECORD_BASE + AUVIA_RP_CONTROL, AUVIA_RPCTRL_START);
d908 1
a908 2
	r = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_RECORD_BASE + AUVIA_RP_STAT);
d914 2
a915 2
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_RECORD_BASE + AUVIA_RP_STAT, AUVIA_RPSTAT_INTR);
d919 1
a919 2
	r = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_PLAY_BASE + AUVIA_RP_STAT);
d925 2
a926 2
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_PLAY_BASE + AUVIA_RP_STAT, AUVIA_RPSTAT_INTR);
@


1.13.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a208 4
const struct pci_matchid auvia_devices[] = {
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT82C686A_AC97 },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT8233_AC97 },
};
d213 13
a225 2
	return (pci_matchbyid((struct pci_attach_args *)aux, auvia_devices,
	    sizeof(auvia_devices)/sizeof(auvia_devices[0])));
d473 1
a473 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d479 1
a479 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d485 1
a485 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d491 1
a491 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d497 1
a497 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d503 1
a503 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d509 1
a509 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d515 1
a515 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
@


1.12
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.11 2001/10/31 11:00:24 art Exp $ */
a223 1
	u_int16_t v;
a278 16
	/*
	 * Print a warning if the codec doesn't support hardware variable
	 * rate audio.
	 */
	if (auvia_read_codec(sc, AC97_REG_EXT_AUDIO_ID, &v)
		|| !(v & AC97_EXT_AUDIO_VRA)) {
		printf("%s: warning: codec doesn't support hardware AC'97 2.0 Variable Rate Audio\n",
			sc->sc_dev.dv_xname);
		sc->sc_fixed_rate = AUVIA_FIXED_RATE;
	} else {
		/* enable VRA */
		auvia_write_codec(sc, AC97_REG_EXT_AUDIO_CTRL,
			AC97_EXT_AUDIO_VRA | AC97_EXT_AUDIO_VRM);
		sc->sc_fixed_rate = 0;
	}

d507 1
a507 1
	int reg, mode;
d517 4
a520 2
		if (p->sample_rate < 4000 || p->sample_rate > 48000 ||
		    (p->precision != 8 && p->precision != 16) ||
a522 10

		reg = mode == AUMODE_PLAY ?
			AC97_REG_FRONT_DAC_RATE : AC97_REG_PCM_ADC_RATE;

		if (!sc->sc_fixed_rate) {
			auvia_write_codec(sc, reg, (u_int16_t) p->sample_rate);
			auvia_read_codec(sc, reg, &regval);
			p->sample_rate = regval;
		} else
			p->sample_rate = sc->sc_fixed_rate;
@


1.11
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.10 2001/08/25 10:13:29 art Exp $ */
d56 1
a56 1
#include <vm/vm.h>
@


1.10
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.9 2001/06/12 15:40:30 niklas Exp $ */
d106 1
a106 1
int	auvia_mappage(void *, void *, int, int);
d770 2
a771 2
int
auvia_mappage(void *addr, void *mem, int off, int prot)
@


1.9
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.8 2001/05/16 12:51:49 ho Exp $ */
d227 1
a227 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin, pa->pa_intrline,
			&ih)) {
@


1.8
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.7 2001/05/16 05:22:58 mickey Exp $ */
d251 1
a251 1
	    &sc->sc_ioh, &sc->sc_ioaddr, &sc->sc_iosize)) {
@


1.7
log
@extended registers are now in ac97.h
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.6 2001/04/21 04:59:01 deraadt Exp $ */
a821 5

		if (ch->sc_dma_ops == NULL) {
			printf("%s: couldn't build dmaops\n", sc->sc_dev.dv_xname);
			return 1;
		}
@


1.6
log
@correct dmesg
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.5 2001/04/16 03:18:18 deraadt Exp $ */
a159 8
#define	AC97_REG_EXT_AUDIO_ID		0x28
#define		AC97_CODEC_DOES_VRA		0x0001
#define	AC97_REG_EXT_AUDIO_STAT		0x2A
#define		AC97_ENAB_VRA			0x0001
#define		AC97_ENAB_MICVRA		0x0004
#define	AC97_REG_EXT_DAC_RATE		0x2C
#define	AC97_REG_EXT_ADC_RATE		0x32

d286 1
a286 1
		|| !(v & AC97_CODEC_DOES_VRA)) {
d292 2
a293 2
		auvia_write_codec(sc, AC97_REG_EXT_AUDIO_STAT,
			AC97_ENAB_VRA | AC97_ENAB_MICVRA);
d541 1
a541 1
			AC97_REG_EXT_DAC_RATE : AC97_REG_EXT_ADC_RATE;
@


1.6.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d256 1
a256 1
	printf("%s\n", intrstr);
@


1.6.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.6.4.1 2001/05/14 22:25:33 niklas Exp $ */
d160 8
d256 1
a256 1
	printf(": %s\n", intrstr);
d259 1
a259 1
	    &sc->sc_ioh, &sc->sc_ioaddr, &sc->sc_iosize, 0)) {
d294 1
a294 1
		|| !(v & AC97_EXT_AUDIO_VRA)) {
d300 2
a301 2
		auvia_write_codec(sc, AC97_REG_EXT_AUDIO_CTRL,
			AC97_EXT_AUDIO_VRA | AC97_EXT_AUDIO_VRM);
d549 1
a549 1
			AC97_REG_FRONT_DAC_RATE : AC97_REG_PCM_ADC_RATE;
d830 5
@


1.6.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.6.4.2 2001/07/04 10:41:54 niklas Exp $ */
d227 2
a228 1
	if (pci_intr_map(pa, &ih)) {
@


1.6.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d56 1
a56 1
#include <uvm/uvm_extern.h>
d106 1
a106 1
paddr_t	auvia_mappage(void *, void *, off_t, int);
d770 2
a771 2
paddr_t
auvia_mappage(void *addr, void *mem, off_t off, int prot)
@


1.6.4.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.6.4.4 2001/11/13 21:10:01 niklas Exp $ */
d224 1
d280 16
d524 1
a524 1
	int mode;
d534 3
a536 1
		if (ac97_set_rate(sc->codec_if, p, mode))
d539 9
a547 3
		if ((p->precision != 8 && p->precision != 16) ||
		    (p->channels != 1 && p->channels != 2))
			return (EINVAL);
@


1.6.4.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d180 1
a180 1
	auvia_malloc,
d182 1
a182 1
	auvia_round_buffersize,
d186 3
a188 1
	auvia_trigger_input
@


1.6.4.7
log
@Merge in -current from roughly a week ago
@
text
@d115 1
a115 1
int	auvia_intr(void *);
@


1.6.4.8
log
@Sync the SMP branch with 3.3
@
text
@d135 2
a136 4
#define AUVIA_PLAY_BASE			0x00
#define AUVIA_RECORD_BASE		0x10

#define	AUVIA_RP_STAT			0x00
d138 2
a139 1
#define AUVIA_RP_CONTROL		0x01
d142 2
a143 6
#define		AUVIA_RPCTRL_AUTOSTART		0x20
/* The following are 8233 specific */
#define		AUVIA_RPCTRL_STOP		0x04
#define		AUVIA_RPCTRL_EOL		0x02
#define		AUVIA_RPCTRL_FLAG		0x01
#define AUVIA_RP_MODE			0x02
d149 2
a150 10
#define	AUVIA_RP_DMAOPS_BASE		0x04

#define	VIA8233_RP_DXS_LVOL		0x02
#define	VIA8233_RP_DXS_RVOL		0x03
#define	VIA8233_RP_RATEFMT		0x08
#define		VIA8233_RATEFMT_48K	0xfffff
#define		VIA8233_RATEFMT_STEREO	0x00100000
#define		VIA8233_RATEFMT_16BIT	0x00200000

#define VIA_RP_DMAOPS_COUNT		0x0C
a195 4
const struct pci_matchid auvia_devices[] = {
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT82C686A_AC97 },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT8233_AC97 },
};
d200 8
a207 2
	return (pci_matchbyid((struct pci_attach_args *)aux, auvia_devices,
	    sizeof(auvia_devices)/sizeof(auvia_devices[0])));
a220 1
	bus_size_t iosize;
a223 13
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VT8233_AC97)
		sc->sc_flags |= AUVIA_FLAGS_VT8233;

	if (pci_mapreg_map(pa, 0x10, PCI_MAPREG_TYPE_IO, 0, &sc->sc_iot,
	    &sc->sc_ioh, NULL, &iosize, 0)) {
		printf(": can't map i/o space\n");
		return;
	}

	sc->sc_dmat = pa->pa_dmat;
	sc->sc_pc = pc;
	sc->sc_pt = pt;

d225 1
a225 2
		printf(": couldn't map interrupt\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
a236 1
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
d240 4
d246 6
d258 2
a259 2
	pr |= (AUVIA_PCICONF_ACLINKENAB | AUVIA_PCICONF_ACNOTRST |
	    AUVIA_PCICONF_ACVSR | AUVIA_PCICONF_ACSGD);
d273 1
a273 3
		    sc->sc_dev.dv_xname, r);
		pci_intr_disestablish(pc, sc->sc_ih);
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
d292 1
a292 1
		    d[i].class, d[i].device, AudioNmute);
d304 1
a304 1
	    AudioCoutputs, AudioNmaster, NULL);
d337 1
a337 1
	r |= AUVIA_PCICONF_ACNOTRST;	/* disable RESET (inactive high) */
d353 1
a353 1
	     AUVIA_CODEC_CTL) & AUVIA_CODEC_BUSY); i++)
a354 1

d371 2
a372 3
	     AUVIA_CODEC_CTL) & AUVIA_CODEC_PRIVALID); i++)
		delay(1);

d391 1
a391 1
	    AUVIA_CODEC_PRIVALID | AUVIA_CODEC_INDEX(reg) | val);
d406 1
a406 1
	    AUVIA_CODEC_PRIVALID | AUVIA_CODEC_READ | AUVIA_CODEC_INDEX(reg));
d500 1
a500 1
    struct audio_params *play, struct audio_params *rec)
d505 1
a505 1
	int mode, base;
d513 1
a513 24
		if (mode == AUMODE_PLAY) {
			p = play;
			base = AUVIA_PLAY_BASE;
		} else {
			p = rec;
			base = AUVIA_RECORD_BASE;
		}

		if (sc->sc_flags & AUVIA_FLAGS_VT8233) {
			u_int32_t v = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
			    base + VIA8233_RP_RATEFMT) & ~(VIA8233_RATEFMT_48K
			    | VIA8233_RATEFMT_STEREO | VIA8233_RATEFMT_16BIT);

			v |= VIA8233_RATEFMT_48K *
			    (p->sample_rate / 20) / (48000 / 20);

			if (p->channels == 2)
				v |= VIA8233_RATEFMT_STEREO;
			if (p->precision == 16)
				v |= VIA8233_RATEFMT_16BIT;

			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    base + VIA8233_RP_RATEFMT, v);
		}
d536 6
a541 4
			if (p->precision == 16)
				p->sw_code = mode == AUMODE_PLAY?
				    swap_bytes_change_sign16_le :
				    change_sign16_swap_bytes_le;
d571 1
a571 1
		if (mode == AUMODE_PLAY)
d573 1
a573 1
		else
d575 1
d594 2
a595 2
	bus_space_write_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_PLAY_BASE + AUVIA_RP_CONTROL, AUVIA_RPCTRL_TERMINATE);
d606 2
a607 2
	bus_space_write_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_RECORD_BASE + AUVIA_RP_CONTROL, AUVIA_RPCTRL_TERMINATE);
d619 1
a619 3
		strncpy(retp->name,
		    sc->sc_flags & AUVIA_FLAGS_VT8233? "VIA VT8233" :
		    "VIA VT82C686A", sizeof(retp->name));
d766 2
a767 2
	return (AUDIO_PROP_MMAP |  AUDIO_PROP_INDEPENDENT |
	    AUDIO_PROP_FULLDUPLEX);
d773 1
a773 1
    struct auvia_dma *p, void *start, void *end, int blksize)
d788 1
a788 1
		if (ch->sc_dma_ops)
d790 1
d793 1
a793 1
		    sizeof(struct auvia_dma_op) * segs, M_DEVBUF, M_WAITOK);
d795 4
a798 3
		for (dp = sc->sc_dmas; dp &&
		     dp->addr != (void *)(ch->sc_dma_ops); dp = dp->next)
			;
d802 2
a803 2
			    "address (%p)", sc->sc_dev.dv_xname,
			    ch->sc_dma_ops);
d815 6
a820 2
		/* if last block */
		op->flags = (l? AUVIA_DMAOP_FLAG : AUVIA_DMAOP_EOL) | blksize;
d830 3
a832 2
auvia_trigger_output(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
d843 1
a843 1
		    "address (%p)", start);
d852 2
a853 3
	bus_space_write_4(sc->sc_iot, sc->sc_ioh,
	    AUVIA_PLAY_BASE + AUVIA_RP_DMAOPS_BASE,
	    ch->sc_dma_ops_dma->map->dm_segs[0].ds_addr);
d855 2
a856 2
	bus_space_write_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_PLAY_BASE + AUVIA_RP_MODE, ch->sc_reg);
d858 2
a859 12
	if (sc->sc_flags & AUVIA_FLAGS_VT8233) {
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_PLAY_BASE + VIA8233_RP_DXS_LVOL, 0);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_PLAY_BASE + VIA8233_RP_DXS_RVOL, 0);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_PLAY_BASE + AUVIA_RP_CONTROL,
		    AUVIA_RPCTRL_START | AUVIA_RPCTRL_AUTOSTART |
		    AUVIA_RPCTRL_STOP  | AUVIA_RPCTRL_EOL | AUVIA_RPCTRL_FLAG);
	} else
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_PLAY_BASE + AUVIA_RP_CONTROL, AUVIA_RPCTRL_START);
d866 3
a868 2
auvia_trigger_input(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
d879 1
a879 1
		    "address (%p)", start);
d881 1
a881 1
	if (auvia_build_dma_ops(sc, ch, p, start, end, blksize))
d883 1
d888 8
a895 18
	bus_space_write_4(sc->sc_iot, sc->sc_ioh,
	    AUVIA_RECORD_BASE + AUVIA_RP_DMAOPS_BASE,
	    ch->sc_dma_ops_dma->map->dm_segs[0].ds_addr);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_RECORD_BASE + AUVIA_RP_MODE, ch->sc_reg);

	if (sc->sc_flags & AUVIA_FLAGS_VT8233) {
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_RECORD_BASE + VIA8233_RP_DXS_LVOL, 0);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_RECORD_BASE + VIA8233_RP_DXS_RVOL, 0);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_RECORD_BASE + AUVIA_RP_CONTROL,
		    AUVIA_RPCTRL_START | AUVIA_RPCTRL_AUTOSTART |
		    AUVIA_RPCTRL_STOP  | AUVIA_RPCTRL_EOL | AUVIA_RPCTRL_FLAG);
	} else
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_RECORD_BASE + AUVIA_RP_CONTROL, AUVIA_RPCTRL_START);
d908 1
a908 2
	r = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_RECORD_BASE + AUVIA_RP_STAT);
d914 2
a915 2
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_RECORD_BASE + AUVIA_RP_STAT, AUVIA_RPSTAT_INTR);
d919 1
a919 2
	r = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
	    AUVIA_PLAY_BASE + AUVIA_RP_STAT);
d925 2
a926 2
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    AUVIA_PLAY_BASE + AUVIA_RP_STAT, AUVIA_RPSTAT_INTR);
@


1.6.4.9
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.6.4.8 2003/03/28 00:38:20 niklas Exp $ */
d466 1
a466 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d472 1
a472 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d478 1
a478 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d484 1
a484 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d490 1
a490 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d496 1
a496 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d502 1
a502 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d508 1
a508 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
@


1.6.4.10
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.6.4.9 2003/05/13 19:35:04 ho Exp $ */
d854 1
a854 1
		op->ptr = htole32(s);
d857 1
a857 1
		op->flags = htole32((l? AUVIA_DMAOP_FLAG : AUVIA_DMAOP_EOL) | blksize);
@


1.6.4.11
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d56 2
a133 1
#define		AUVIA_PCICONF_PRIVALID	 0x00000001	/* primary codec rdy */
d344 1
a344 1
	int i;
d360 2
a361 5
	for (i = 500000; i != 0 && !(pci_conf_read(sc->sc_pc, sc->sc_pt,
		AUVIA_PCICONF_JUNK) & AUVIA_PCICONF_PRIVALID); i--)
		DELAY(1);
	if (i == 0)
		printf("%s: codec reset timed out\n", sc->sc_dev.dv_xname);
@


1.5
log
@dmesg cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.4 2001/03/14 08:09:51 mickey Exp $ */
d256 1
a256 1
	printf("%s\n", intrstr);
@


1.4
log
@count interrupts proper; pointed out and tested by form@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.3 2000/12/27 02:50:07 mickey Exp $ */
a234 13
	r = PCI_REVISION(pa->pa_class);
	sc->sc_revision[1] = '\0';
	if (r == 0x20) {
		sc->sc_revision[0] = 'H';
	} else if ((r >= 0x10) && (r <= 0x14)) {
		sc->sc_revision[0] = 'A' + (r - 0x10);
	} else {
		sprintf(sc->sc_revision, "0x%02X", r);
	}

	printf(": VIA VT82C686A AC'97 Audio (rev %s)\n",
		sc->sc_revision);

d245 1
a245 1
		printf("%s: couldn't establish interrupt",sc->sc_dev.dv_xname);
d256 1
a256 1
	printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname, intrstr);
@


1.3
log
@behave nicely w/ fixed rate codecs; from netbsd; testing by Igor Lulic <il11@@mail.csuchico.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: auvia.c,v 1.2 2000/10/14 18:04:07 aaron Exp $ */
d960 1
d970 2
d981 2
d985 1
a985 1
	return 1;
@


1.2
log
@Add $OpenBSD$ tags.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: auvia.c,v 1.3.4.1 2000/06/30 16:27:49 simonb Exp $	*/
d56 2
d86 3
d226 1
a226 1
        const char *intrstr = NULL;
d229 2
a230 2
        pcitag_t pt = pa->pa_tag;
        pci_intr_handle_t ih;
d233 1
a233 1
        int r, i;
d272 1
a272 1
                           &sc->sc_ioh, &sc->sc_ioaddr, &sc->sc_iosize)) {
d302 4
d307 2
a308 4
	|| !(v & AC97_CODEC_DOES_VRA)) {
		/* XXX */

		printf("%s: codec must support AC'97 2.0 Variable Rate Audio\n",
d310 1
a310 1
		return;
d315 1
d328 1
a328 1
		
d347 2
a348 2
	
        audio_attach_mi(&auvia_hw_if, sc, &sc->sc_dev);
d472 1
a472 1
    
d549 1
a549 1
	for (mode = AUMODE_RECORD; mode != -1; 
d564 6
a569 3
		auvia_write_codec(sc, reg, (u_int16_t) p->sample_rate);
		auvia_read_codec(sc, reg, &regval);
		p->sample_rate = regval;
d641 1
a641 1
        struct auvia_softc *sc = addr;
d653 1
a653 1
        struct auvia_softc *sc = addr;
d665 1
a665 1
        struct auvia_softc *sc = addr;
d717 4
a720 4
	if ((error = bus_dmamem_alloc(sc->sc_dmat, size, NBPG, 0, &p->seg, 1, 
				      &rseg, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: unable to allocate dma, error = %d\n", 
		       sc->sc_dev.dv_xname, error);
d725 3
a727 3
				    BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {
		printf("%s: unable to map dma, error = %d\n", 
		       sc->sc_dev.dv_xname, error);
d731 2
a732 2
	if ((error = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0, 
				       BUS_DMA_NOWAIT, &p->map)) != 0) {
d734 1
a734 1
		       sc->sc_dev.dv_xname, error);
d739 1
a739 1
				     BUS_DMA_NOWAIT)) != 0) {
d741 1
a741 1
		       sc->sc_dev.dv_xname, error);
d775 1
a775 1
			
d807 2
a808 2
	return bus_dmamem_mmap(sc->sc_dmat, &p->seg, 1, off, prot, 
	       BUS_DMA_WAITOK);
@


1.1
log
@new auvia and fms drivers from netbsd (testing requests sent out, since i cannot find any of these devices)
@
text
@d1 1
@

