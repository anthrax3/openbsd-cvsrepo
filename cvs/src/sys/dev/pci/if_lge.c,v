head	1.73;
access;
symbols
	OPENBSD_6_2_BASE:1.73
	OPENBSD_6_1:1.73.0.4
	OPENBSD_6_1_BASE:1.73
	OPENBSD_6_0:1.72.0.4
	OPENBSD_6_0_BASE:1.72
	OPENBSD_5_9:1.71.0.2
	OPENBSD_5_9_BASE:1.71
	OPENBSD_5_8:1.67.0.4
	OPENBSD_5_8_BASE:1.67
	OPENBSD_5_7:1.64.0.4
	OPENBSD_5_7_BASE:1.64
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.61.0.4
	OPENBSD_5_5_BASE:1.61
	OPENBSD_5_4:1.57.0.4
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.57.0.2
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.55.0.6
	OPENBSD_5_2_BASE:1.55
	OPENBSD_5_1_BASE:1.55
	OPENBSD_5_1:1.55.0.4
	OPENBSD_5_0:1.55.0.2
	OPENBSD_5_0_BASE:1.55
	OPENBSD_4_9:1.53.0.4
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.53.0.2
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.52.0.2
	OPENBSD_4_7_BASE:1.52
	OPENBSD_4_6:1.50.0.6
	OPENBSD_4_6_BASE:1.50
	OPENBSD_4_5:1.50.0.2
	OPENBSD_4_5_BASE:1.50
	OPENBSD_4_4:1.47.0.2
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.46.0.2
	OPENBSD_4_3_BASE:1.46
	OPENBSD_4_2:1.45.0.4
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.45.0.2
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.44.0.2
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.36.0.2
	OPENBSD_3_9_BASE:1.36
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.6.0.2
	UBC_BASE:1.6
	SMP:1.3.0.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.73
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.72;
commitid	VyLWTsbepAOk7VQM;

1.72
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.71;
commitid	8YSL8ByWzGeIGBiJ;

1.71
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.70;
commitid	B0kwmVGiD5DVx4kv;

1.70
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.69;
commitid	5gdEnqVoJuTuwdTu;

1.69
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.68;
commitid	eYnPulzvLjDImPCa;

1.68
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.67;
commitid	hPF95ClMUQfeqQDX;

1.67
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.66;
commitid	MVWrtktB46JRxFWT;

1.66
date	2015.04.13.08.45.48;	author mpi;	state Exp;
branches;
next	1.65;
commitid	aiRvgNOa4qke9vft;

1.65
date	2015.04.08.10.07.47;	author mpi;	state Exp;
branches;
next	1.64;
commitid	hnmA6leYzflFI0c3;

1.64
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.63;
commitid	yM2VFFhpDTeFQlve;

1.63
date	2014.08.20.01.00.15;	author dlg;	state Exp;
branches;
next	1.62;
commitid	43V8XvJeQoOYpvwp;

1.62
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.61;
commitid	TGHgrLxu6sxZoiFt;

1.61
date	2013.11.26.09.50.33;	author mpi;	state Exp;
branches;
next	1.60;

1.60
date	2013.10.01.20.06.01;	author sf;	state Exp;
branches;
next	1.59;

1.59
date	2013.08.21.05.21.44;	author dlg;	state Exp;
branches;
next	1.58;

1.58
date	2013.08.07.01.06.36;	author bluhm;	state Exp;
branches;
next	1.57;

1.57
date	2012.11.29.21.10.32;	author brad;	state Exp;
branches;
next	1.56;

1.56
date	2012.10.18.21.44.21;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2011.06.22.16.44.27;	author tedu;	state Exp;
branches;
next	1.54;

1.54
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.53;

1.53
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.52;

1.52
date	2009.08.13.14.24.47;	author jasper;	state Exp;
branches;
next	1.51;

1.51
date	2009.08.10.17.25.07;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2008.10.22.00.01.59;	author brad;	state Exp;
branches;
next	1.48;

1.48
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.47;

1.47
date	2008.05.23.08.49.27;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2007.11.26.09.28.33;	author martynas;	state Exp;
branches;
next	1.45;

1.45
date	2006.10.25.02.37.50;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.28.00.20.21;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2006.05.28.00.04.24;	author jason;	state Exp;
branches;
next	1.42;

1.42
date	2006.05.27.20.42.51;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2006.05.27.10.03.15;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2006.05.20.03.47.56;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2006.04.30.05.37.27;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.25.22.41.45;	author djm;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.20.16.15.03;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2005.12.24.19.16.31;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2005.11.23.11.30.14;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2005.10.09.04.44.45;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2005.10.09.02.00.57;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2005.10.08.23.38.52;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2005.10.08.20.45.01;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2005.10.08.04.46.29;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.08.04.20.11;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.07.21.30.38;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.07.21.23.51;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2005.10.07.21.17.42;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.07.21.05.15;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.07.20.57.21;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2005.09.11.18.17.08;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.09.04.10.12;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.02.23.10.11;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2005.06.18.04.23.09;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.11.03.54.59;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.25.17.55.51;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.05.19.57.17;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.05.20.24.30;	author mcbride;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.09.21.52.17;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.06.06.43.12;	author david;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.06.21.08.07;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.26.06.01.28;	author nate;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.10.18.08.13;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.12.09.51.20;	author kjc;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.15.20.45.31;	author nordin;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.11.05.16.50.12;	author todd;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.05.04.16.11;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.09.05.20.58.54;	author nate;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.04.20.36.38;	author nate;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2004.06.05.23.12.50;	author niklas;	state Exp;
branches;
next	1.3.4.8;

1.3.4.8
date	2004.06.07.20.41.25;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.73
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_lge.c,v 1.72 2016/04/13 10:34:32 mpi Exp $	*/
/*
 * Copyright (c) 2001 Wind River Systems
 * Copyright (c) 1997, 1998, 1999, 2000, 2001
 *	Bill Paul <william.paul@@windriver.com>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/dev/lge/if_lge.c,v 1.6 2001/06/20 19:47:55 bmilekic Exp $
 */

/*
 * Level 1 LXT1001 gigabit ethernet driver for FreeBSD. Public
 * documentation not available, but ask me nicely.
 *
 * Written by Bill Paul <william.paul@@windriver.com>
 * Wind River Systems
 */

/*
 * The Level 1 chip is used on some D-Link, SMC and Addtron NICs.
 * It's a 64-bit PCI part that supports TCP/IP checksum offload,
 * VLAN tagging/insertion, GMII and TBI (1000baseX) ports. There
 * are three supported methods for data transfer between host and
 * NIC: programmed I/O, traditional scatter/gather DMA and Packet
 * Propulsion Technology (tm) DMA. The latter mechanism is a form
 * of double buffer DMA where the packet data is copied to a
 * pre-allocated DMA buffer who's physical address has been loaded
 * into a table at device initialization time. The rationale is that
 * the virtual to physical address translation needed for normal
 * scatter/gather DMA is more expensive than the data copy needed
 * for double buffering. This may be true in Windows NT and the like,
 * but it isn't true for us, at least on the x86 arch. This driver
 * uses the scatter/gather I/O method for both TX and RX.
 *
 * The LXT1001 only supports TCP/IP checksum offload on receive.
 * Also, the VLAN tagging is done using a 16-entry table which allows
 * the chip to perform hardware filtering based on VLAN tags. Sadly,
 * our vlan support doesn't currently play well with this kind of
 * hardware support.
 *
 * Special thanks to:
 * - Jeff James at Intel, for arranging to have the LXT1001 manual
 *   released (at long last)
 * - Beny Chen at D-Link, for actually sending it to me
 * - Brad Short and Keith Alexis at SMC, for sending me sample
 *   SMC9462SX and SMC9462TX adapters for testing
 * - Paul Saab at Y!, for not killing me (though it remains to be seen
 *   if in fact he did me much of a favor)
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <uvm/uvm_extern.h>              /* for vtophys */
#define	VTOPHYS(v)	vtophys((vaddr_t)(v))

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#define LGE_USEIOSPACE

#include <dev/pci/if_lgereg.h>

int lge_probe(struct device *, void *, void *);
void lge_attach(struct device *, struct device *, void *);

struct cfattach lge_ca = {
	sizeof(struct lge_softc), lge_probe, lge_attach
};

struct cfdriver lge_cd = {
	NULL, "lge", DV_IFNET
};

int lge_newbuf(struct lge_softc *, struct lge_rx_desc *,
			     struct mbuf *);
int lge_encap(struct lge_softc *, struct mbuf *, u_int32_t *);
void lge_rxeof(struct lge_softc *, int);
void lge_txeof(struct lge_softc *);
int lge_intr(void *);
void lge_tick(void *);
void lge_start(struct ifnet *);
int lge_ioctl(struct ifnet *, u_long, caddr_t);
void lge_init(void *);
void lge_stop(struct lge_softc *);
void lge_watchdog(struct ifnet *);
int lge_ifmedia_upd(struct ifnet *);
void lge_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void lge_eeprom_getword(struct lge_softc *, int, u_int16_t *);
void lge_read_eeprom(struct lge_softc *, caddr_t, int, int, int);

int lge_miibus_readreg(struct device *, int, int);
void lge_miibus_writereg(struct device *, int, int, int);
void lge_miibus_statchg(struct device *);

void lge_setmulti(struct lge_softc *);
void lge_reset(struct lge_softc *);
int lge_list_rx_init(struct lge_softc *);
int lge_list_tx_init(struct lge_softc *);

#ifdef LGE_DEBUG
#define DPRINTF(x)	if (lgedebug) printf x
#define DPRINTFN(n,x)	if (lgedebug >= (n)) printf x
int	lgedebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

const struct pci_matchid lge_devices[] = {
	{ PCI_VENDOR_LEVEL1, PCI_PRODUCT_LEVEL1_LXT1001 }
};

#define LGE_SETBIT(sc, reg, x)				\
	CSR_WRITE_4(sc, reg,				\
		CSR_READ_4(sc, reg) | (x))

#define LGE_CLRBIT(sc, reg, x)				\
	CSR_WRITE_4(sc, reg,				\
		CSR_READ_4(sc, reg) & ~(x))

#define SIO_SET(x)					\
	CSR_WRITE_4(sc, LGE_MEAR, CSR_READ_4(sc, LGE_MEAR) | x)

#define SIO_CLR(x)					\
	CSR_WRITE_4(sc, LGE_MEAR, CSR_READ_4(sc, LGE_MEAR) & ~x)

/*
 * Read a word of data stored in the EEPROM at address 'addr.'
 */
void
lge_eeprom_getword(struct lge_softc *sc, int addr, u_int16_t *dest)
{
	int			i;
	u_int32_t		val;

	CSR_WRITE_4(sc, LGE_EECTL, LGE_EECTL_CMD_READ|
	    LGE_EECTL_SINGLEACCESS|((addr >> 1) << 8));

	for (i = 0; i < LGE_TIMEOUT; i++)
		if (!(CSR_READ_4(sc, LGE_EECTL) & LGE_EECTL_CMD_READ))
			break;

	if (i == LGE_TIMEOUT) {
		printf("%s: EEPROM read timed out\n", sc->sc_dv.dv_xname);
		return;
	}

	val = CSR_READ_4(sc, LGE_EEDATA);

	if (addr & 1)
		*dest = (val >> 16) & 0xFFFF;
	else
		*dest = val & 0xFFFF;
}

/*
 * Read a sequence of words from the EEPROM.
 */
void
lge_read_eeprom(struct lge_softc *sc, caddr_t dest, int off,
    int cnt, int swap)
{
	int			i;
	u_int16_t		word = 0, *ptr;

	for (i = 0; i < cnt; i++) {
		lge_eeprom_getword(sc, off + i, &word);
		ptr = (u_int16_t *)(dest + (i * 2));
		if (swap)
			*ptr = ntohs(word);
		else
			*ptr = word;
	}
}

int
lge_miibus_readreg(struct device *dev, int phy, int reg)
{
	struct lge_softc	*sc = (struct lge_softc *)dev;
	int			i;

	/*
	 * If we have a non-PCS PHY, pretend that the internal
	 * autoneg stuff at PHY address 0 isn't there so that
	 * the miibus code will find only the GMII PHY.
	 */
	if (sc->lge_pcs == 0 && phy == 0)
		return (0);

	CSR_WRITE_4(sc, LGE_GMIICTL, (phy << 8) | reg | LGE_GMIICMD_READ);

	for (i = 0; i < LGE_TIMEOUT; i++)
		if (!(CSR_READ_4(sc, LGE_GMIICTL) & LGE_GMIICTL_CMDBUSY))
			break;

	if (i == LGE_TIMEOUT) {
		printf("%s: PHY read timed out\n", sc->sc_dv.dv_xname);
		return (0);
	}

	return (CSR_READ_4(sc, LGE_GMIICTL) >> 16);
}

void
lge_miibus_writereg(struct device *dev, int phy, int reg, int data)
{
	struct lge_softc	*sc = (struct lge_softc *)dev;
	int			i;

	CSR_WRITE_4(sc, LGE_GMIICTL,
	    (data << 16) | (phy << 8) | reg | LGE_GMIICMD_WRITE);

	for (i = 0; i < LGE_TIMEOUT; i++)
		if (!(CSR_READ_4(sc, LGE_GMIICTL) & LGE_GMIICTL_CMDBUSY))
			break;

	if (i == LGE_TIMEOUT) {
		printf("%s: PHY write timed out\n", sc->sc_dv.dv_xname);
	}
}

void
lge_miibus_statchg(struct device *dev)
{
	struct lge_softc	*sc = (struct lge_softc *)dev;
	struct mii_data		*mii = &sc->lge_mii;

	LGE_CLRBIT(sc, LGE_GMIIMODE, LGE_GMIIMODE_SPEED);
	switch (IFM_SUBTYPE(mii->mii_media_active)) {
	case IFM_1000_T:
	case IFM_1000_SX:
		LGE_SETBIT(sc, LGE_GMIIMODE, LGE_SPEED_1000);
		break;
	case IFM_100_TX:
		LGE_SETBIT(sc, LGE_GMIIMODE, LGE_SPEED_100);
		break;
	case IFM_10_T:
		LGE_SETBIT(sc, LGE_GMIIMODE, LGE_SPEED_10);
		break;
	default:
		/*
		 * Choose something, even if it's wrong. Clearing
		 * all the bits will hose autoneg on the internal
		 * PHY.
		 */
		LGE_SETBIT(sc, LGE_GMIIMODE, LGE_SPEED_1000);
		break;
	}

	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX) {
		LGE_SETBIT(sc, LGE_GMIIMODE, LGE_GMIIMODE_FDX);
	} else {
		LGE_CLRBIT(sc, LGE_GMIIMODE, LGE_GMIIMODE_FDX);
	}
}

void
lge_setmulti(struct lge_softc *sc)
{
	struct arpcom		*ac = &sc->arpcom;
	struct ifnet		*ifp = &ac->ac_if;
	struct ether_multi      *enm;
	struct ether_multistep  step;
	u_int32_t		h = 0, hashes[2] = { 0, 0 };

	/* Make sure multicast hash table is enabled. */
	CSR_WRITE_4(sc, LGE_MODE1, LGE_MODE1_SETRST_CTL1|LGE_MODE1_RX_MCAST);

	if (ac->ac_multirangecnt > 0)
		ifp->if_flags |= IFF_ALLMULTI;

	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
		CSR_WRITE_4(sc, LGE_MAR0, 0xFFFFFFFF);
		CSR_WRITE_4(sc, LGE_MAR1, 0xFFFFFFFF);
		return;
	}

	/* first, zot all the existing hash bits */
	CSR_WRITE_4(sc, LGE_MAR0, 0);
	CSR_WRITE_4(sc, LGE_MAR1, 0);

	/* now program new ones */
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		h = (ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26) &
		    0x0000003F;
		if (h < 32)
			hashes[0] |= (1 << h);
		else
			hashes[1] |= (1 << (h - 32));
		ETHER_NEXT_MULTI(step, enm);
	}

	CSR_WRITE_4(sc, LGE_MAR0, hashes[0]);
	CSR_WRITE_4(sc, LGE_MAR1, hashes[1]);
}

void
lge_reset(struct lge_softc *sc)
{
	int			i;

	LGE_SETBIT(sc, LGE_MODE1, LGE_MODE1_SETRST_CTL0|LGE_MODE1_SOFTRST);

	for (i = 0; i < LGE_TIMEOUT; i++) {
		if (!(CSR_READ_4(sc, LGE_MODE1) & LGE_MODE1_SOFTRST))
			break;
	}

	if (i == LGE_TIMEOUT)
		printf("%s: reset never completed\n", sc->sc_dv.dv_xname);

	/* Wait a little while for the chip to get its brains in order. */
	DELAY(1000);
}

/*
 * Probe for a Level 1 chip. Check the PCI vendor and device
 * IDs against our list and return a device name if we find a match.
 */
int
lge_probe(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, lge_devices,
	    nitems(lge_devices)));
}

/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
void
lge_attach(struct device *parent, struct device *self, void *aux)
{
	struct lge_softc	*sc = (struct lge_softc *)self;
	struct pci_attach_args	*pa = aux;
	pci_chipset_tag_t	pc = pa->pa_pc;
	pci_intr_handle_t	ih;
	const char		*intrstr = NULL;
	bus_size_t		size;
	bus_dma_segment_t	seg;
	bus_dmamap_t		dmamap;
	int			rseg;
	u_char			eaddr[ETHER_ADDR_LEN];
#ifndef LGE_USEIOSPACE
	pcireg_t		memtype;
#endif
	struct ifnet		*ifp;
	caddr_t			kva;

	pci_set_powerstate(pa->pa_pc, pa->pa_tag, PCI_PMCSR_STATE_D0);

	/*
	 * Map control/status registers.
	 */
	DPRINTFN(5, ("Map control/status regs\n"));

	DPRINTFN(5, ("pci_mapreg_map\n"));
#ifdef LGE_USEIOSPACE
	if (pci_mapreg_map(pa, LGE_PCI_LOIO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->lge_btag, &sc->lge_bhandle, NULL, &size, 0)) {
		printf(": can't map i/o space\n");
		return;
	}
#else
	memtype = pci_mapreg_type(pc, pa->pa_tag, LGE_PCI_LOMEM);
	if (pci_mapreg_map(pa, LGE_PCI_LOMEM, memtype, 0, &sc->lge_btag,
	    &sc->lge_bhandle, NULL, &size, 0)) {
		printf(": can't map mem space\n");
		return;
	}
#endif

	DPRINTFN(5, ("pci_intr_map\n"));
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		goto fail_1;
	}

	DPRINTFN(5, ("pci_intr_string\n"));
	intrstr = pci_intr_string(pc, ih);
	DPRINTFN(5, ("pci_intr_establish\n"));
	sc->lge_intrhand = pci_intr_establish(pc, ih, IPL_NET, lge_intr, sc,
					      sc->sc_dv.dv_xname);
	if (sc->lge_intrhand == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail_1;
	}
	printf(": %s", intrstr);

	/* Reset the adapter. */
	DPRINTFN(5, ("lge_reset\n"));
	lge_reset(sc);

	/*
	 * Get station address from the EEPROM.
	 */
	DPRINTFN(5, ("lge_read_eeprom\n"));
	lge_read_eeprom(sc, (caddr_t)&eaddr[0], LGE_EE_NODEADDR_0, 1, 0);
	lge_read_eeprom(sc, (caddr_t)&eaddr[2], LGE_EE_NODEADDR_1, 1, 0);
	lge_read_eeprom(sc, (caddr_t)&eaddr[4], LGE_EE_NODEADDR_2, 1, 0);

	/*
	 * A Level 1 chip was detected. Inform the world.
	 */
	printf(", address %s\n", ether_sprintf(eaddr));

	bcopy(eaddr, &sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);

	sc->sc_dmatag = pa->pa_dmat;
	DPRINTFN(5, ("bus_dmamem_alloc\n"));
	if (bus_dmamem_alloc(sc->sc_dmatag, sizeof(struct lge_list_data),
	    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT | BUS_DMA_ZERO)) {
		printf("%s: can't alloc rx buffers\n", sc->sc_dv.dv_xname);
		goto fail_2;
	}
	DPRINTFN(5, ("bus_dmamem_map\n"));
	if (bus_dmamem_map(sc->sc_dmatag, &seg, rseg,
			   sizeof(struct lge_list_data), &kva,
			   BUS_DMA_NOWAIT)) {
		printf("%s: can't map dma buffers (%zd bytes)\n",
		       sc->sc_dv.dv_xname, sizeof(struct lge_list_data));
		goto fail_3;
	}
	DPRINTFN(5, ("bus_dmamem_create\n"));
	if (bus_dmamap_create(sc->sc_dmatag, sizeof(struct lge_list_data), 1,
			      sizeof(struct lge_list_data), 0,
			      BUS_DMA_NOWAIT, &dmamap)) {
		printf("%s: can't create dma map\n", sc->sc_dv.dv_xname);
		goto fail_4;
	}
	DPRINTFN(5, ("bus_dmamem_load\n"));
	if (bus_dmamap_load(sc->sc_dmatag, dmamap, kva,
			    sizeof(struct lge_list_data), NULL,
			    BUS_DMA_NOWAIT)) {
		goto fail_5;
	}

	DPRINTFN(5, ("bzero\n"));
	sc->lge_ldata = (struct lge_list_data *)kva;

	ifp = &sc->arpcom.ac_if;
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = lge_ioctl;
	ifp->if_start = lge_start;
	ifp->if_watchdog = lge_watchdog;
	ifp->if_hardmtu = LGE_JUMBO_MTU;
	IFQ_SET_MAXLEN(&ifp->if_snd, LGE_TX_LIST_CNT - 1);
	DPRINTFN(5, ("bcopy\n"));
	bcopy(sc->sc_dv.dv_xname, ifp->if_xname, IFNAMSIZ);

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	if (CSR_READ_4(sc, LGE_GMIIMODE) & LGE_GMIIMODE_PCSENH)
		sc->lge_pcs = 1;
	else
		sc->lge_pcs = 0;

	/*
	 * Do MII setup.
	 */
	DPRINTFN(5, ("mii setup\n"));
	sc->lge_mii.mii_ifp = ifp;
	sc->lge_mii.mii_readreg = lge_miibus_readreg;
	sc->lge_mii.mii_writereg = lge_miibus_writereg;
	sc->lge_mii.mii_statchg = lge_miibus_statchg;
	ifmedia_init(&sc->lge_mii.mii_media, 0, lge_ifmedia_upd,
		     lge_ifmedia_sts);
	mii_attach(&sc->sc_dv, &sc->lge_mii, 0xffffffff, MII_PHY_ANY,
		   MII_OFFSET_ANY, 0);

	if (LIST_FIRST(&sc->lge_mii.mii_phys) == NULL) {
		printf("%s: no PHY found!\n", sc->sc_dv.dv_xname);
		ifmedia_add(&sc->lge_mii.mii_media, IFM_ETHER|IFM_MANUAL,
			    0, NULL);
		ifmedia_set(&sc->lge_mii.mii_media, IFM_ETHER|IFM_MANUAL);
	} else {
		DPRINTFN(5, ("ifmedia_set\n"));
		ifmedia_set(&sc->lge_mii.mii_media, IFM_ETHER|IFM_AUTO);
	}

	/*
	 * Call MI attach routine.
	 */
	DPRINTFN(5, ("if_attach\n"));
	if_attach(ifp);
	DPRINTFN(5, ("ether_ifattach\n"));
	ether_ifattach(ifp);
	DPRINTFN(5, ("timeout_set\n"));
	timeout_set(&sc->lge_timeout, lge_tick, sc);
	timeout_add_sec(&sc->lge_timeout, 1);
	return;

fail_5:
	bus_dmamap_destroy(sc->sc_dmatag, dmamap);

fail_4:
	bus_dmamem_unmap(sc->sc_dmatag, kva,
	    sizeof(struct lge_list_data));

fail_3:
	bus_dmamem_free(sc->sc_dmatag, &seg, rseg);

fail_2:
	pci_intr_disestablish(pc, sc->lge_intrhand);

fail_1:
	bus_space_unmap(sc->lge_btag, sc->lge_bhandle, size);
}

/*
 * Initialize the transmit descriptors.
 */
int
lge_list_tx_init(struct lge_softc *sc)
{
	struct lge_list_data	*ld;
	struct lge_ring_data	*cd;
	int			i;

	cd = &sc->lge_cdata;
	ld = sc->lge_ldata;
	for (i = 0; i < LGE_TX_LIST_CNT; i++) {
		ld->lge_tx_list[i].lge_mbuf = NULL;
		ld->lge_tx_list[i].lge_ctl = 0;
	}

	cd->lge_tx_prod = cd->lge_tx_cons = 0;

	return (0);
}


/*
 * Initialize the RX descriptors and allocate mbufs for them. Note that
 * we arrange the descriptors in a closed ring, so that the last descriptor
 * points back to the first.
 */
int
lge_list_rx_init(struct lge_softc *sc)
{
	struct lge_list_data	*ld;
	struct lge_ring_data	*cd;
	int			i;

	ld = sc->lge_ldata;
	cd = &sc->lge_cdata;

	cd->lge_rx_prod = cd->lge_rx_cons = 0;

	CSR_WRITE_4(sc, LGE_RXDESC_ADDR_HI, 0);

	for (i = 0; i < LGE_RX_LIST_CNT; i++) {
		if (CSR_READ_1(sc, LGE_RXCMDFREE_8BIT) == 0)
			break;
		if (lge_newbuf(sc, &ld->lge_rx_list[i], NULL) == ENOBUFS)
			return (ENOBUFS);
	}

	/* Clear possible 'rx command queue empty' interrupt. */
	CSR_READ_4(sc, LGE_ISR);

	return (0);
}

/*
 * Initialize a RX descriptor and attach a MBUF cluster.
 */
int
lge_newbuf(struct lge_softc *sc, struct lge_rx_desc *c, struct mbuf *m)
{
	struct mbuf		*m_new = NULL;

	if (m == NULL) {
		m_new = MCLGETI(NULL, LGE_JLEN, NULL, M_DONTWAIT);
		if (m_new == NULL)
			return (ENOBUFS);
	} else {
		/*
		 * We're re-using a previously allocated mbuf;
		 * be sure to re-init pointers and lengths to
		 * default values.
		 */
		m_new = m;
		m_new->m_data = m_new->m_ext.ext_buf;
	}
	m_new->m_len = m_new->m_pkthdr.len = LGE_JLEN;

	/*
	 * Adjust alignment so packet payload begins on a
	 * longword boundary. Mandatory for Alpha, useful on
	 * x86 too.
	*/
	m_adj(m_new, ETHER_ALIGN);

	c->lge_mbuf = m_new;
	c->lge_fragptr_hi = 0;
	c->lge_fragptr_lo = VTOPHYS(mtod(m_new, caddr_t));
	c->lge_fraglen = m_new->m_len;
	c->lge_ctl = m_new->m_len | LGE_RXCTL_WANTINTR | LGE_FRAGCNT(1);
	c->lge_sts = 0;

	/*
	 * Put this buffer in the RX command FIFO. To do this,
	 * we just write the physical address of the descriptor
	 * into the RX descriptor address registers. Note that
	 * there are two registers, one high DWORD and one low
	 * DWORD, which lets us specify a 64-bit address if
	 * desired. We only use a 32-bit address for now.
	 * Writing to the low DWORD register is what actually
	 * causes the command to be issued, so we do that
	 * last.
	 */
	CSR_WRITE_4(sc, LGE_RXDESC_ADDR_LO, VTOPHYS(c));
	LGE_INC(sc->lge_cdata.lge_rx_prod, LGE_RX_LIST_CNT);

	return (0);
}

/*
 * A frame has been uploaded: pass the resulting mbuf chain up to
 * the higher level protocols.
 */
void
lge_rxeof(struct lge_softc *sc, int cnt)
{
	struct mbuf_list	ml = MBUF_LIST_INITIALIZER();
        struct mbuf		*m;
        struct ifnet		*ifp;
	struct lge_rx_desc	*cur_rx;
	int			c, i, total_len = 0;
	u_int32_t		rxsts, rxctl;

	ifp = &sc->arpcom.ac_if;

	/* Find out how many frames were processed. */
	c = cnt;
	i = sc->lge_cdata.lge_rx_cons;

	/* Suck them in. */
	while(c) {
		struct mbuf		*m0 = NULL;

		cur_rx = &sc->lge_ldata->lge_rx_list[i];
		rxctl = cur_rx->lge_ctl;
		rxsts = cur_rx->lge_sts;
		m = cur_rx->lge_mbuf;
		cur_rx->lge_mbuf = NULL;
		total_len = LGE_RXBYTES(cur_rx);
		LGE_INC(i, LGE_RX_LIST_CNT);
		c--;

		/*
		 * If an error occurs, update stats, clear the
		 * status word and leave the mbuf cluster in place:
		 * it should simply get re-used next time this descriptor
	 	 * comes up in the ring.
		 */
		if (rxctl & LGE_RXCTL_ERRMASK) {
			ifp->if_ierrors++;
			lge_newbuf(sc, &LGE_RXTAIL(sc), m);
			continue;
		}

		if (lge_newbuf(sc, &LGE_RXTAIL(sc), NULL) == ENOBUFS) {
			m0 = m_devget(mtod(m, char *), total_len, ETHER_ALIGN);
			lge_newbuf(sc, &LGE_RXTAIL(sc), m);
			if (m0 == NULL) {
				ifp->if_ierrors++;
				continue;
			}
			m = m0;
		} else {
			m->m_pkthdr.len = m->m_len = total_len;
		}

		/* Do IP checksum checking. */
		if (rxsts & LGE_RXSTS_ISIP) {
			if (!(rxsts & LGE_RXSTS_IPCSUMERR))
				m->m_pkthdr.csum_flags |= M_IPV4_CSUM_IN_OK;
		}
		if (rxsts & LGE_RXSTS_ISTCP) {
			if (!(rxsts & LGE_RXSTS_TCPCSUMERR))
				m->m_pkthdr.csum_flags |= M_TCP_CSUM_IN_OK;
		}
		if (rxsts & LGE_RXSTS_ISUDP) {
			if (!(rxsts & LGE_RXSTS_UDPCSUMERR))
				m->m_pkthdr.csum_flags |= M_UDP_CSUM_IN_OK;
		}

		ml_enqueue(&ml, m);
	}

	if_input(ifp, &ml);

	sc->lge_cdata.lge_rx_cons = i;
}

/*
 * A frame was downloaded to the chip. It's safe for us to clean up
 * the list buffers.
 */

void
lge_txeof(struct lge_softc *sc)
{
	struct lge_tx_desc	*cur_tx = NULL;
	struct ifnet		*ifp;
	u_int32_t		idx, txdone;

	ifp = &sc->arpcom.ac_if;

	/* Clear the timeout timer. */
	ifp->if_timer = 0;

	/*
	 * Go through our tx list and free mbufs for those
	 * frames that have been transmitted.
	 */
	idx = sc->lge_cdata.lge_tx_cons;
	txdone = CSR_READ_1(sc, LGE_TXDMADONE_8BIT);

	while (idx != sc->lge_cdata.lge_tx_prod && txdone) {
		cur_tx = &sc->lge_ldata->lge_tx_list[idx];

		if (cur_tx->lge_mbuf != NULL) {
			m_freem(cur_tx->lge_mbuf);
			cur_tx->lge_mbuf = NULL;
		}
		cur_tx->lge_ctl = 0;

		txdone--;
		LGE_INC(idx, LGE_TX_LIST_CNT);
		ifp->if_timer = 0;
	}

	sc->lge_cdata.lge_tx_cons = idx;

	if (cur_tx != NULL)
		ifq_clr_oactive(&ifp->if_snd);
}

void
lge_tick(void *xsc)
{
	struct lge_softc	*sc = xsc;
	struct mii_data		*mii = &sc->lge_mii;
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	int			s;

	s = splnet();

	CSR_WRITE_4(sc, LGE_STATSIDX, LGE_STATS_SINGLE_COLL_PKTS);
	ifp->if_collisions += CSR_READ_4(sc, LGE_STATSVAL);
	CSR_WRITE_4(sc, LGE_STATSIDX, LGE_STATS_MULTI_COLL_PKTS);
	ifp->if_collisions += CSR_READ_4(sc, LGE_STATSVAL);

	if (!sc->lge_link) {
		mii_tick(mii);
		if (mii->mii_media_status & IFM_ACTIVE &&
		    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
			sc->lge_link++;
			if (!IFQ_IS_EMPTY(&ifp->if_snd))
				lge_start(ifp);
		}
	}

	timeout_add_sec(&sc->lge_timeout, 1);

	splx(s);
}

int
lge_intr(void *arg)
{
	struct lge_softc	*sc;
	struct ifnet		*ifp;
	u_int32_t		status;
	int			claimed = 0;

	sc = arg;
	ifp = &sc->arpcom.ac_if;

	/* Suppress unwanted interrupts */
	if (!(ifp->if_flags & IFF_UP)) {
		lge_stop(sc);
		return (0);
	}

	for (;;) {
		/*
		 * Reading the ISR register clears all interrupts, and
		 * clears the 'interrupts enabled' bit in the IMR
		 * register.
		 */
		status = CSR_READ_4(sc, LGE_ISR);

		if ((status & LGE_INTRS) == 0)
			break;

		claimed = 1;

		if ((status & (LGE_ISR_TXCMDFIFO_EMPTY|LGE_ISR_TXDMA_DONE)))
			lge_txeof(sc);

		if (status & LGE_ISR_RXDMA_DONE)
			lge_rxeof(sc, LGE_RX_DMACNT(status));

		if (status & LGE_ISR_RXCMDFIFO_EMPTY)
			lge_init(sc);

		if (status & LGE_ISR_PHY_INTR) {
			sc->lge_link = 0;
			timeout_del(&sc->lge_timeout);
			lge_tick(sc);
		}
	}

	/* Re-enable interrupts. */
	CSR_WRITE_4(sc, LGE_IMR, LGE_IMR_SETRST_CTL0|LGE_IMR_INTR_ENB);

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		lge_start(ifp);

	return (claimed);
}

/*
 * Encapsulate an mbuf chain in a descriptor by coupling the mbuf data
 * pointers to the fragment pointers.
 */
int
lge_encap(struct lge_softc *sc, struct mbuf *m_head, u_int32_t *txidx)
{
	struct lge_frag		*f = NULL;
	struct lge_tx_desc	*cur_tx;
	struct mbuf		*m;
	int			frag = 0, tot_len = 0;

	/*
 	 * Start packing the mbufs in this chain into
	 * the fragment pointers. Stop when we run out
 	 * of fragments or hit the end of the mbuf chain.
	 */
	m = m_head;
	cur_tx = &sc->lge_ldata->lge_tx_list[*txidx];
	frag = 0;

	for (m = m_head; m != NULL; m = m->m_next) {
		if (m->m_len != 0) {
			tot_len += m->m_len;
			f = &cur_tx->lge_frags[frag];
			f->lge_fraglen = m->m_len;
			f->lge_fragptr_lo = VTOPHYS(mtod(m, vaddr_t));
			f->lge_fragptr_hi = 0;
			frag++;
		}
	}

	if (m != NULL)
		return (ENOBUFS);

	cur_tx->lge_mbuf = m_head;
	cur_tx->lge_ctl = LGE_TXCTL_WANTINTR|LGE_FRAGCNT(frag)|tot_len;
	LGE_INC((*txidx), LGE_TX_LIST_CNT);

	/* Queue for transmit */
	CSR_WRITE_4(sc, LGE_TXDESC_ADDR_LO, VTOPHYS(cur_tx));

	return (0);
}

/*
 * Main transmit routine. To avoid having to do mbuf copies, we put pointers
 * to the mbuf data regions directly in the transmit lists. We also save a
 * copy of the pointers since the transmit list fragment pointers are
 * physical addresses.
 */

void
lge_start(struct ifnet *ifp)
{
	struct lge_softc	*sc;
	struct mbuf		*m_head = NULL;
	u_int32_t		idx;
	int			pkts = 0;

	sc = ifp->if_softc;

	if (!sc->lge_link)
		return;

	idx = sc->lge_cdata.lge_tx_prod;

	if (ifq_is_oactive(&ifp->if_snd))
		return;

	while(sc->lge_ldata->lge_tx_list[idx].lge_mbuf == NULL) {
		if (CSR_READ_1(sc, LGE_TXCMDFREE_8BIT) == 0)
			break;

		m_head = ifq_deq_begin(&ifp->if_snd);
		if (m_head == NULL)
			break;

		if (lge_encap(sc, m_head, &idx)) {
			ifq_deq_rollback(&ifp->if_snd, m_head);
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		/* now we are committed to transmit the packet */
		ifq_deq_commit(&ifp->if_snd, m_head);
		pkts++;

#if NBPFILTER > 0
		/*
		 * If there's a BPF listener, bounce a copy of this frame
		 * to him.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif
	}
	if (pkts == 0)
		return;

	sc->lge_cdata.lge_tx_prod = idx;

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;
}

void
lge_init(void *xsc)
{
	struct lge_softc	*sc = xsc;
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	int			s;

	s = splnet();

	/*
	 * Cancel pending I/O and free all RX/TX buffers.
	 */
	lge_stop(sc);
	lge_reset(sc);

	/* Set MAC address */
	CSR_WRITE_4(sc, LGE_PAR0, *(u_int32_t *)(&sc->arpcom.ac_enaddr[0]));
	CSR_WRITE_4(sc, LGE_PAR1, *(u_int32_t *)(&sc->arpcom.ac_enaddr[4]));

	/* Init circular RX list. */
	if (lge_list_rx_init(sc) == ENOBUFS) {
		printf("%s: initialization failed: no "
		       "memory for rx buffers\n", sc->sc_dv.dv_xname);
		lge_stop(sc);
		splx(s);
		return;
	}

	/*
	 * Init tx descriptors.
	 */
	lge_list_tx_init(sc);

	/* Set initial value for MODE1 register. */
	CSR_WRITE_4(sc, LGE_MODE1, LGE_MODE1_RX_UCAST|
	    LGE_MODE1_TX_CRC|LGE_MODE1_TXPAD|
	    LGE_MODE1_RX_FLOWCTL|LGE_MODE1_SETRST_CTL0|
	    LGE_MODE1_SETRST_CTL1|LGE_MODE1_SETRST_CTL2);

	 /* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC) {
		CSR_WRITE_4(sc, LGE_MODE1,
		    LGE_MODE1_SETRST_CTL1|LGE_MODE1_RX_PROMISC);
	} else {
		CSR_WRITE_4(sc, LGE_MODE1, LGE_MODE1_RX_PROMISC);
	}

	/*
	 * Set the capture broadcast bit to capture broadcast frames.
	 */
	if (ifp->if_flags & IFF_BROADCAST) {
		CSR_WRITE_4(sc, LGE_MODE1,
		    LGE_MODE1_SETRST_CTL1|LGE_MODE1_RX_BCAST);
	} else {
		CSR_WRITE_4(sc, LGE_MODE1, LGE_MODE1_RX_BCAST);
	}

	/* Packet padding workaround? */
	CSR_WRITE_4(sc, LGE_MODE1, LGE_MODE1_SETRST_CTL1|LGE_MODE1_RMVPAD);

	/* No error frames */
	CSR_WRITE_4(sc, LGE_MODE1, LGE_MODE1_RX_ERRPKTS);

	/* Receive large frames */
	CSR_WRITE_4(sc, LGE_MODE1, LGE_MODE1_SETRST_CTL1|LGE_MODE1_RX_GIANTS);

	/* Workaround: disable RX/TX flow control */
	CSR_WRITE_4(sc, LGE_MODE1, LGE_MODE1_TX_FLOWCTL);
	CSR_WRITE_4(sc, LGE_MODE1, LGE_MODE1_RX_FLOWCTL);

	/* Make sure to strip CRC from received frames */
	CSR_WRITE_4(sc, LGE_MODE1, LGE_MODE1_RX_CRC);

	/* Turn off magic packet mode */
	CSR_WRITE_4(sc, LGE_MODE1, LGE_MODE1_MPACK_ENB);

	/* Turn off all VLAN stuff */
	CSR_WRITE_4(sc, LGE_MODE1, LGE_MODE1_VLAN_RX|LGE_MODE1_VLAN_TX|
	    LGE_MODE1_VLAN_STRIP|LGE_MODE1_VLAN_INSERT);

	/* Workarond: FIFO overflow */
	CSR_WRITE_2(sc, LGE_RXFIFO_HIWAT, 0x3FFF);
	CSR_WRITE_4(sc, LGE_IMR, LGE_IMR_SETRST_CTL1|LGE_IMR_RXFIFO_WAT);

	/*
	 * Load the multicast filter.
	 */
	lge_setmulti(sc);

	/*
	 * Enable hardware checksum validation for all received IPv4
	 * packets, do not reject packets with bad checksums.
	 */
	CSR_WRITE_4(sc, LGE_MODE2, LGE_MODE2_RX_IPCSUM|
	    LGE_MODE2_RX_TCPCSUM|LGE_MODE2_RX_UDPCSUM|
	    LGE_MODE2_RX_ERRCSUM);

	/*
	 * Enable the delivery of PHY interrupts based on
	 * link/speed/duplex status chalges.
	 */
	CSR_WRITE_4(sc, LGE_MODE1, LGE_MODE1_SETRST_CTL0|LGE_MODE1_GMIIPOLL);

	/* Enable receiver and transmitter. */
	CSR_WRITE_4(sc, LGE_RXDESC_ADDR_HI, 0);
	CSR_WRITE_4(sc, LGE_MODE1, LGE_MODE1_SETRST_CTL1|LGE_MODE1_RX_ENB);

	CSR_WRITE_4(sc, LGE_TXDESC_ADDR_HI, 0);
	CSR_WRITE_4(sc, LGE_MODE1, LGE_MODE1_SETRST_CTL1|LGE_MODE1_TX_ENB);

	/*
	 * Enable interrupts.
	 */
	CSR_WRITE_4(sc, LGE_IMR, LGE_IMR_SETRST_CTL0|
	    LGE_IMR_SETRST_CTL1|LGE_IMR_INTR_ENB|LGE_INTRS);

	lge_ifmedia_upd(ifp);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);

	timeout_add_sec(&sc->lge_timeout, 1);
}

/*
 * Set media options.
 */
int
lge_ifmedia_upd(struct ifnet *ifp)
{
	struct lge_softc	*sc = ifp->if_softc;
	struct mii_data		*mii = &sc->lge_mii;

	sc->lge_link = 0;
	if (mii->mii_instance) {
		struct mii_softc *miisc;
		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
			mii_phy_reset(miisc);
	}
	mii_mediachg(mii);

	return (0);
}

/*
 * Report current media status.
 */
void
lge_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct lge_softc	*sc = ifp->if_softc;
	struct mii_data		*mii = &sc->lge_mii;

	mii_pollstat(mii);
	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;
}

int
lge_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct lge_softc	*sc = ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *) data;
	struct mii_data		*mii;
	int			s, error = 0;

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			lge_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->lge_if_flags & IFF_PROMISC)) {
				CSR_WRITE_4(sc, LGE_MODE1,
				    LGE_MODE1_SETRST_CTL1|
				    LGE_MODE1_RX_PROMISC);
				lge_setmulti(sc);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->lge_if_flags & IFF_PROMISC) {
				CSR_WRITE_4(sc, LGE_MODE1,
				    LGE_MODE1_RX_PROMISC);
				lge_setmulti(sc);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    (ifp->if_flags ^ sc->lge_if_flags) & IFF_ALLMULTI) {
				lge_setmulti(sc);
			} else {
				if (!(ifp->if_flags & IFF_RUNNING))
					lge_init(sc);
			}
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				lge_stop(sc);
		}
		sc->lge_if_flags = ifp->if_flags;
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		mii = &sc->lge_mii;
		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);
		break;

	default:
		error = ether_ioctl(ifp, &sc->arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			lge_setmulti(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

void
lge_watchdog(struct ifnet *ifp)
{
	struct lge_softc	*sc;

	sc = ifp->if_softc;

	ifp->if_oerrors++;
	printf("%s: watchdog timeout\n", sc->sc_dv.dv_xname);

	lge_stop(sc);
	lge_reset(sc);
	lge_init(sc);

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		lge_start(ifp);
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void
lge_stop(struct lge_softc *sc)
{
	int			i;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;
	ifp->if_timer = 0;
	timeout_del(&sc->lge_timeout);

	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	CSR_WRITE_4(sc, LGE_IMR, LGE_IMR_INTR_ENB);

	/* Disable receiver and transmitter. */
	CSR_WRITE_4(sc, LGE_MODE1, LGE_MODE1_RX_ENB|LGE_MODE1_TX_ENB);
	sc->lge_link = 0;

	/*
	 * Free data in the RX lists.
	 */
	for (i = 0; i < LGE_RX_LIST_CNT; i++) {
		if (sc->lge_ldata->lge_rx_list[i].lge_mbuf != NULL) {
			m_freem(sc->lge_ldata->lge_rx_list[i].lge_mbuf);
			sc->lge_ldata->lge_rx_list[i].lge_mbuf = NULL;
		}
	}
	bzero(&sc->lge_ldata->lge_rx_list, sizeof(sc->lge_ldata->lge_rx_list));

	/*
	 * Free the TX list buffers.
	 */
	for (i = 0; i < LGE_TX_LIST_CNT; i++) {
		if (sc->lge_ldata->lge_tx_list[i].lge_mbuf != NULL) {
			m_freem(sc->lge_ldata->lge_tx_list[i].lge_mbuf);
			sc->lge_ldata->lge_tx_list[i].lge_mbuf = NULL;
		}
	}

	bzero(&sc->lge_ldata->lge_tx_list, sizeof(sc->lge_ldata->lge_tx_list));
}
@


1.72
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.71 2015/11/25 03:09:59 dlg Exp $	*/
a779 1
		ifp->if_opackets++;
@


1.71
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.70 2015/11/24 17:11:39 mpi Exp $	*/
a502 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.70
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.69 2015/11/20 03:35:23 dlg Exp $	*/
d796 1
a796 1
		ifp->if_flags &= ~IFF_OACTIVE;
d951 1
a951 1
	if (ifp->if_flags & IFF_OACTIVE)
d964 1
a964 1
			ifp->if_flags |= IFF_OACTIVE;
d1111 1
a1111 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1250 2
a1251 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.69
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.68 2015/10/25 13:04:28 mpi Exp $	*/
a88 1
#include <net/if_dl.h>
@


1.68
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.67 2015/06/24 09:40:54 mpi Exp $	*/
d959 1
a959 1
		IFQ_POLL(&ifp->if_snd, m_head);
d964 1
d970 1
a970 1
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.67
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.66 2015/04/13 08:45:48 mpi Exp $	*/
a1155 1
	struct ifaddr		*ifa = (struct ifaddr *) data;
a1166 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->arpcom, ifa);
@


1.66
log
@Now that if_input() set the receiving interface pointer on mbufs for us
there's no need to do it in m_devget(9).

Stop passing an ``ifp'' will help for upcoming interface pointer -> index
conversion.

While here remove unused ``ifp'' argument from m_clget(9) and kill two
birds^W layer violations in one commit.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.65 2015/04/08 10:07:47 mpi Exp $	*/
a731 2

		ifp->if_ipackets++;
@


1.65
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.64 2014/12/22 02:28:52 tedu Exp $	*/
d722 1
a722 2
			m0 = m_devget(mtod(m, char *), total_len, ETHER_ALIGN,
			    ifp);
@


1.64
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.63 2014/08/20 01:00:15 dlg Exp $	*/
d683 1
a730 1
			m->m_pkthdr.rcvif = ifp;
a735 8
#if NBPFILTER > 0
		/*
		 * Handle BPF listeners. Let the BPF user see the packet.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

d750 1
a750 1
		ether_input_mbuf(ifp, m);
d752 2
@


1.63
log
@replace the custom jumbo allocator with MCLGETI.

putting this in the tree to make it easier for people to test.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.62 2014/07/22 13:12:11 mpi Exp $	*/
a91 1
#ifdef INET
a93 1
#endif
a1176 1
#ifdef INET
a1178 1
#endif /* INET */
@


1.62
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.61 2013/11/26 09:50:33 mpi Exp $	*/
a125 4
int lge_alloc_jumbo_mem(struct lge_softc *);
void *lge_jalloc(struct lge_softc *);
void lge_jfree(caddr_t, u_int, void *);

a497 8
	/* Try to allocate memory for jumbo buffers. */
	DPRINTFN(5, ("lge_alloc_jumbo_mem\n"));
	if (lge_alloc_jumbo_mem(sc)) {
		printf("%s: jumbo buffer allocation failed\n",
		       sc->sc_dv.dv_xname);
		goto fail_5;
	}

d633 1
a633 3
		caddr_t buf = NULL;

		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
a635 11

		/* Allocate the jumbo buffer */
		buf = lge_jalloc(sc);
		if (buf == NULL) {
			m_freem(m_new);
			return (ENOBUFS);
		}

		/* Attach the buffer to the mbuf */
		m_new->m_len = m_new->m_pkthdr.len = LGE_JLEN;
		MEXTADD(m_new, buf, LGE_JLEN, 0, lge_jfree, sc);
a642 1
		m_new->m_len = m_new->m_pkthdr.len = LGE_JLEN;
d645 1
a675 140
}

int
lge_alloc_jumbo_mem(struct lge_softc *sc)
{
	caddr_t			ptr, kva;
	bus_dma_segment_t	seg;
	bus_dmamap_t		dmamap;
	int			i, rseg, state, error;
	struct lge_jpool_entry   *entry;

	state = error = 0;

	/* Grab a big chunk o' storage. */
	if (bus_dmamem_alloc(sc->sc_dmatag, LGE_JMEM, PAGE_SIZE, 0,
			     &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
		printf("%s: can't alloc rx buffers\n", sc->sc_dv.dv_xname);
		return (ENOBUFS);
	}

	state = 1;
	if (bus_dmamem_map(sc->sc_dmatag, &seg, rseg, LGE_JMEM, &kva,
			   BUS_DMA_NOWAIT)) {
		printf("%s: can't map dma buffers (%zd bytes)\n",
		       sc->sc_dv.dv_xname, LGE_JMEM);
		error = ENOBUFS;
		goto out;
	}

	state = 2;
	if (bus_dmamap_create(sc->sc_dmatag, LGE_JMEM, 1,
			      LGE_JMEM, 0, BUS_DMA_NOWAIT, &dmamap)) {
		printf("%s: can't create dma map\n", sc->sc_dv.dv_xname);
		error = ENOBUFS;
		goto out;
	}

	state = 3;
	if (bus_dmamap_load(sc->sc_dmatag, dmamap, kva, LGE_JMEM,
			    NULL, BUS_DMA_NOWAIT)) {
		printf("%s: can't load dma map\n", sc->sc_dv.dv_xname);
		error = ENOBUFS;
		goto out;
        }

	state = 4;
	sc->lge_cdata.lge_jumbo_buf = (caddr_t)kva;
	DPRINTFN(1,("lge_jumbo_buf = 0x%08X\n", sc->lge_cdata.lge_jumbo_buf));
	DPRINTFN(1,("LGE_JLEN = 0x%08X\n", LGE_JLEN));

	LIST_INIT(&sc->lge_jfree_listhead);
	LIST_INIT(&sc->lge_jinuse_listhead);

	/*
	 * Now divide it up into 9K pieces and save the addresses
	 * in an array.
	 */
	ptr = sc->lge_cdata.lge_jumbo_buf;
	for (i = 0; i < LGE_JSLOTS; i++) {
		sc->lge_cdata.lge_jslots[i] = ptr;
		ptr += LGE_JLEN;
		entry = malloc(sizeof(struct lge_jpool_entry), 
		    M_DEVBUF, M_NOWAIT);
		if (entry == NULL) {
			sc->lge_cdata.lge_jumbo_buf = NULL;
			printf("%s: no memory for jumbo buffer queue!\n",
			       sc->sc_dv.dv_xname);
			error = ENOBUFS;
			goto out;
		}
		entry->slot = i;
		LIST_INSERT_HEAD(&sc->lge_jfree_listhead,
				 entry, jpool_entries);
	}
out:
	if (error != 0) {
		switch (state) {
		case 4:
			bus_dmamap_unload(sc->sc_dmatag, dmamap);
		case 3:
			bus_dmamap_destroy(sc->sc_dmatag, dmamap);
		case 2:
			bus_dmamem_unmap(sc->sc_dmatag, kva, LGE_JMEM);
		case 1:
			bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
			break;
		default:
			break;
		}
	}

	return (error);
}

/*
 * Allocate a jumbo buffer.
 */
void *
lge_jalloc(struct lge_softc *sc)
{
	struct lge_jpool_entry   *entry;

	entry = LIST_FIRST(&sc->lge_jfree_listhead);

	if (entry == NULL)
		return (NULL);

	LIST_REMOVE(entry, jpool_entries);
	LIST_INSERT_HEAD(&sc->lge_jinuse_listhead, entry, jpool_entries);
	return (sc->lge_cdata.lge_jslots[entry->slot]);
}

/*
 * Release a jumbo buffer.
 */
void
lge_jfree(caddr_t buf, u_int size, void *arg)
{
	struct lge_softc	*sc;
	int		        i;
	struct lge_jpool_entry   *entry;

	/* Extract the softc struct pointer. */
	sc = (struct lge_softc *)arg;

	if (sc == NULL)
		panic("lge_jfree: can't find softc pointer!");

	/* calculate the slot this buffer belongs to */
	i = ((vaddr_t)buf - (vaddr_t)sc->lge_cdata.lge_jumbo_buf) / LGE_JLEN;

	if ((i < 0) || (i >= LGE_JSLOTS))
		panic("lge_jfree: asked to free buffer that we don't manage!");

	entry = LIST_FIRST(&sc->lge_jinuse_listhead);
	if (entry == NULL)
		panic("lge_jfree: buffer not in use!");
	entry->slot = i;
	LIST_REMOVE(entry, jpool_entries);
	LIST_INSERT_HEAD(&sc->lge_jfree_listhead, entry, jpool_entries);
@


1.61
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.60 2013/10/01 20:06:01 sf Exp $	*/
a93 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.60
log
@Use %z* for size_t

while there, fix a few %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.59 2013/08/21 05:21:44 dlg Exp $	*/
d328 3
a330 1
allmulti:
a343 4
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}
@


1.59
log
@get rid of the copy argument in m_devget that let you provide an
alternative to bcopy since noone uses it.

while there use memcpy instead of bcopy because we know the memory cannot
overlap.

ok henning@@ matthew@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.58 2013/08/07 01:06:36 bluhm Exp $	*/
d485 1
a485 1
		printf("%s: can't map dma buffers (%d bytes)\n",
d728 1
a728 1
		printf("%s: can't map dma buffers (%d bytes)\n",
@


1.58
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.57 2012/11/29 21:10:32 brad Exp $	*/
d893 1
a893 1
			    ifp, NULL);
@


1.57
log
@Remove setting an initial assumed baudrate upon driver attach which is not
necessarily correct, there might not even be a link when attaching.

ok mikeb@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.56 2012/10/18 21:44:21 deraadt Exp $	*/
a94 1
#include <netinet/in_var.h>
@


1.56
log
@Convert a number of old private copies of code which predates
pci_set_powerstate() to using it instead.  Many of these chunks of code had
bugs in them, especially missing delay() calls.  Some of them were doing
things our PCI subsystem is now responsible for handling.  If you have
any of the affected devices, please keep an eye out for regressions.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.55 2011/06/22 16:44:27 tedu Exp $	*/
a520 1
	ifp->if_baudrate = 1000000000;
@


1.55
log
@kill a few more casts that aren't helpful.  ok krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.54 2011/04/03 15:36:02 jasper Exp $	*/
a406 1
	pcireg_t		command;
d413 1
a413 29
	/*
	 * Handle power management nonsense.
	 */
	DPRINTFN(5, ("Preparing for conf read\n"));
	command = pci_conf_read(pc, pa->pa_tag, LGE_PCI_CAPID) & 0x000000FF;
	if (command == 0x01) {
		command = pci_conf_read(pc, pa->pa_tag, LGE_PCI_PWRMGMTCTRL);
		if (command & LGE_PSTATE_MASK) {
			pcireg_t	iobase, membase, irq;

			/* Save important PCI config data. */
			iobase = pci_conf_read(pc, pa->pa_tag, LGE_PCI_LOIO);
			membase = pci_conf_read(pc, pa->pa_tag, LGE_PCI_LOMEM);
			irq = pci_conf_read(pc, pa->pa_tag, LGE_PCI_INTLINE);

			/* Reset the power state. */
			printf("%s: chip is in D%d power mode "
			       "-- setting to D0\n", sc->sc_dv.dv_xname,
			       command & LGE_PSTATE_MASK);
			command &= 0xFFFFFFFC;
			pci_conf_write(pc, pa->pa_tag,
				       LGE_PCI_PWRMGMTCTRL, command);
			
			/* Restore PCI config data. */
			pci_conf_write(pc, pa->pa_tag, LGE_PCI_LOIO, iobase);
			pci_conf_write(pc, pa->pa_tag, LGE_PCI_LOMEM, membase);
			pci_conf_write(pc, pa->pa_tag, LGE_PCI_INTLINE, irq);
		}
	}
@


1.54
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.53 2010/05/19 15:27:35 oga Exp $	*/
d502 1
a502 1
	bcopy(eaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);
d1483 1
a1483 2
	bzero((char *)&sc->lge_ldata->lge_rx_list,
		sizeof(sc->lge_ldata->lge_rx_list));
d1495 1
a1495 2
	bzero((char *)&sc->lge_ldata->lge_tx_list,
		sizeof(sc->lge_ldata->lge_tx_list));
@


1.53
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.52 2009/08/13 14:24:47 jasper Exp $	*/
d387 1
a387 1
	    sizeof(lge_devices)/sizeof(lge_devices[0])));
@


1.52
log
@- consistify cfdriver for the ethernet drivers (0 -> NULL)

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.51 2009/08/10 17:25:07 deraadt Exp $	*/
d507 1
a507 1
			     PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
a534 1
	bzero(sc->lge_ldata, sizeof(struct lge_list_data));
@


1.51
log
@delete xxshutdown handlers that are never even hooked up
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.50 2008/11/28 02:44:18 brad Exp $	*/
d126 1
a126 1
	0, "lge", DV_IFNET
@


1.50
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.49 2008/10/22 00:01:59 brad Exp $	*/
a144 1
void lge_shutdown(void *);
a1498 13
}

/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
void
lge_shutdown(void *xsc)
{
	struct lge_softc	*sc = (struct lge_softc *)xsc;

	lge_reset(sc);
	lge_stop(sc);
@


1.49
log
@Fix a typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.48 2008/09/10 14:01:22 blambert Exp $	*/
d1369 1
a1370 1
	struct ifaddr		*ifa = (struct ifaddr *)data;
d1386 1
a1386 6
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ifp->if_hardmtu)
			error = EINVAL;
		else if (ifp->if_mtu != ifr->ifr_mtu)
			ifp->if_mtu = ifr->ifr_mtu;
		break;
a1414 5
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI)
			? ether_addmulti(ifr, &sc->arpcom)
			: ether_delmulti(ifr, &sc->arpcom);
a1415 6
		if (error == ENETRESET) {
			if (ifp->if_flags & IFF_RUNNING)
				lge_setmulti(sc);
			error = 0;
		}
		break;
d1421 1
d1423 7
a1429 2
		error = ENOTTY;
		break;
a1432 1

@


1.48
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.47 2008/05/23 08:49:27 brad Exp $	*/
d643 1
a643 1
 * we arralge the descriptors in a closed ring, so that the last descriptor
d674 1
a674 1
 * Initialize an RX descriptor and attach an MBUF cluster.
@


1.47
log
@Simplify the combination use of pci_mapreg_type()/pci_mapreg_map() as
suggested by dlg@@ awhile ago.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.46 2007/11/26 09:28:33 martynas Exp $	*/
d598 1
a598 1
	timeout_add(&sc->lge_timeout, hz);
d1038 1
a1038 1
	timeout_add(&sc->lge_timeout, hz);
d1328 1
a1328 1
	timeout_add(&sc->lge_timeout, hz);
@


1.46
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.45 2006/10/25 02:37:50 brad Exp $	*/
d459 2
a460 8
	switch (memtype) {
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
		if (pci_mapreg_map(pa, LGE_PCI_LOMEM,
				   memtype, 0, &sc->lge_btag, &sc->lge_bhandle,
				   NULL, &size, 0) == 0)
			break;
	default:
@


1.45
log
@replace a few more instances of hand rolled code with the
LIST_FOREACH macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.44 2006/05/28 00:20:21 brad Exp $	*/
d1060 1
a1060 1
	/* Supress unwanted interrupts */
@


1.44
log
@- remove ETHER_MAX_LEN_JUMBO and ETHERMTU_JUMBO.
- use if_hardmtu for MTU ioctl handlers.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.43 2006/05/28 00:04:24 jason Exp $	*/
d1348 2
a1349 3
		struct mii_softc	*miisc;
		for (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;
		    miisc = LIST_NEXT(miisc, mii_list))
@


1.43
log
@unknown ioctl is ENOTTY not EINVAL
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.42 2006/05/27 20:42:51 brad Exp $	*/
d559 1
a559 1
	ifp->if_hardmtu = ETHERMTU_JUMBO;
d711 1
a711 1
		m_new->m_len = m_new->m_pkthdr.len = ETHER_MAX_LEN_JUMBO;
d1394 1
a1394 1
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ETHERMTU_JUMBO)
@


1.42
log
@remove FreeBSD specific code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.41 2006/05/27 10:03:15 brad Exp $	*/
d1445 1
a1445 1
		error = EINVAL;
@


1.41
log
@remove IFCAP_JUMBO_MTU interface capabilities flag and set if_hardmtu in a few
more drivers.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.40 2006/05/20 03:47:56 brad Exp $	*/
a160 8
#ifdef LGE_USEIOSPACE
#define LGE_RES			SYS_RES_IOPORT
#define LGE_RID			LGE_PCI_LOIO
#else
#define LGE_RES			SYS_RES_MEMORY
#define LGE_RID			LGE_PCI_LOMEM
#endif

d171 1
a171 1
	{ PCI_VENDOR_LEVEL1, PCI_PRODUCT_LEVEL1_LXT1001 },
@


1.40
log
@set if_jumbo_mtu and the IFCAP_JUMBO_MTU capabilities flag where
appropriate.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.39 2006/04/30 05:37:27 brad Exp $	*/
d567 1
d573 1
a573 1
	ifp->if_capabilities = IFCAP_VLAN_MTU | IFCAP_JUMBO_MTU;
@


1.39
log
@- check for IFF_RUNNING being set before calling lge_init().
- call lge_setmulti() when enabling/disabling promisc mode or
if the IFF_ALLMULTI flag is set.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.38 2006/03/25 22:41:45 djm Exp $	*/
d572 1
a572 1
	ifp->if_capabilities = IFCAP_VLAN_MTU;
@


1.38
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.37 2006/03/20 16:15:03 brad Exp $	*/
a136 1
void lge_rxeoc(struct lge_softc *);
a980 10
void
lge_rxeoc(struct lge_softc *sc)
{
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;
	ifp->if_flags &= ~IFF_RUNNING;
	lge_init(sc);
}

d1093 1
a1093 1
			lge_rxeoc(sc);
a1226 3
	if (ifp->if_flags & IFF_RUNNING)
		return;

d1393 2
a1394 1
		switch (ifa->ifa_addr->sa_family) {
d1396 1
a1396 2
		case AF_INET:
			lge_init(sc);
a1397 1
			break;
a1398 4
		default:
			lge_init(sc);
			break;
                }
d1414 1
d1420 4
d1425 2
a1426 2
				ifp->if_flags &= ~IFF_RUNNING;
				lge_init(sc);
a1472 1
	ifp->if_flags &= ~IFF_RUNNING;
@


1.37
log
@de-register.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.36 2005/12/24 19:16:31 brad Exp $	*/
d959 1
a959 1
			bpf_mtap(ifp->if_bpf, m);
d1215 1
a1215 1
			bpf_mtap(ifp->if_bpf, m_head);
@


1.36
log
@clear RUNNING here to do a full init.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.35 2005/11/23 11:30:14 mickey Exp $	*/
d203 1
a203 1
	register int		i;
d373 1
a373 1
	register int		i;
d1501 1
a1501 1
	register int		i;
@


1.35
log
@assume vtophys(vaddr_t) just what all the other archs expect; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.34 2005/10/09 04:44:45 brad Exp $	*/
d1439 1
@


1.34
log
@fix bus_dmamem_alloc() failure case.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.33 2005/10/09 02:00:57 brad Exp $	*/
d105 1
a105 1
#include <uvm/uvm_pmap.h>            /* for vtophys */
d732 1
a732 1
	c->lge_fragptr_lo = vtophys(mtod(m_new, caddr_t));
d748 1
a748 1
	CSR_WRITE_4(sc, LGE_RXDESC_ADDR_LO, vtophys(c));
d1148 1
a1148 1
			f->lge_fragptr_lo = vtophys(mtod(m, vaddr_t));
d1162 1
a1162 1
	CSR_WRITE_4(sc, LGE_TXDESC_ADDR_LO, vtophys(cur_tx));
@


1.33
log
@use pci_matchbyid().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.32 2005/10/08 23:38:52 brad Exp $	*/
d769 1
a769 2
		error = ENOBUFS;
		goto out;
@


1.32
log
@stop bzero'ing the softc in lge_attach() and tada lge(4) now works
to some extent.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.31 2005/10/08 20:45:01 brad Exp $	*/
d179 4
d396 2
a397 7
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_LEVEL1 &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_LEVEL1_LXT1001)
		return (1);

	return (0);
@


1.31
log
@a little better like this.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.30 2005/10/08 04:46:29 brad Exp $	*/
a424 2
	bzero(sc, sizeof(struct lge_softc));

a562 1
	bcopy(sc->sc_dv.dv_xname, ifp->if_xname, IFNAMSIZ);
d571 2
a588 1
	DPRINTFN(5, ("ifmedia_init\n"));
a590 1
	DPRINTFN(5, ("mii_attach\n"));
a964 15
#if 0
		if (rxsts & LGE_RXSTS_ISIP)
			m->m_pkthdr.csum_flags |= CSUM_IP_CHECKED;
		if (!(rxsts & LGE_RXSTS_IPCSUMERR))
			m->m_pkthdr.csum_flags |= CSUM_IP_VALID;
		if ((rxsts & LGE_RXSTS_ISTCP &&
		    !(rxsts & LGE_RXSTS_TCPCSUMERR)) ||
		    (rxsts & LGE_RXSTS_ISUDP &&
		    !(rxsts & LGE_RXSTS_UDPCSUMERR))) {
			m->m_pkthdr.csum_flags |=
			    CSUM_DATA_VALID|CSUM_PSEUDO_HDR;
			m->m_pkthdr.csum_data = 0xffff;
		}
#endif

d966 1
a966 3
			if (rxsts & LGE_RXSTS_IPCSUMERR)
				m->m_pkthdr.csum_flags |= M_IPV4_CSUM_IN_BAD;
			else
d970 1
a970 3
			if (rxsts & LGE_RXSTS_TCPCSUMERR)
				m->m_pkthdr.csum_flags |= M_TCP_CSUM_IN_BAD;
			else
d974 1
a974 3
			if (rxsts & LGE_RXSTS_UDPCSUMERR)
				m->m_pkthdr.csum_flags |= M_UDP_CSUM_IN_BAD;
			else
@


1.30
log
@- remove return at end of void function
- function return value on separate line
- ANSI protos
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.29 2005/10/08 04:20:11 brad Exp $	*/
d271 1
a271 1
lge_miibus_writereg(struct devce *dev, int phy, int reg, int data)
d565 1
a573 2
	DPRINTFN(5, ("bcopy\n"));
	bcopy(sc->sc_dv.dv_xname, ifp->if_xname, IFNAMSIZ);
d640 1
a640 1
lge_list_tx_init(struct lge_soft *sc)
d855 1
a855 2
lge_jalloc(sc)
	struct lge_softc	*sc;
a1578 1

@


1.29
log
@remove unused VLAN headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.28 2005/10/07 21:30:38 brad Exp $	*/
d121 8
d196 2
a197 4
void lge_eeprom_getword(sc, addr, dest)
	struct lge_softc	*sc;
	int			addr;
	u_int16_t		*dest;
a219 2

	return;
d225 3
a227 6
void lge_read_eeprom(sc, dest, off, cnt, swap)
	struct lge_softc	*sc;
	caddr_t			dest;
	int			off;
	int			cnt;
	int			swap;
a239 2

	return;
d242 2
a243 3
int lge_miibus_readreg(dev, phy, reg)
	struct device *		dev;
	int			phy, reg;
d254 1
a254 1
		return(0);
d264 1
a264 1
		return(0);
d267 1
a267 1
	return(CSR_READ_4(sc, LGE_GMIICTL) >> 16);
d270 2
a271 3
void lge_miibus_writereg(dev, phy, reg, data)
	struct device *		dev;
	int			phy, reg, data;
d288 2
a289 2
void lge_miibus_statchg(dev)
	struct device *		dev;
a320 2

	return;
d323 2
a324 2
void lge_setmulti(sc)
	struct lge_softc	*sc;
a363 2

	return;
d366 2
a367 2
void lge_reset(sc)
	struct lge_softc	*sc;
a382 2

        return;
d389 2
a390 4
int lge_probe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d405 2
a406 3
void lge_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d640 2
a641 2
int lge_list_tx_init(sc)
	struct lge_softc	*sc;
d656 1
a656 1
	return(0);
d665 2
a666 2
int lge_list_rx_init(sc)
	struct lge_softc	*sc;
d683 1
a683 1
			return(ENOBUFS);
d689 1
a689 1
	return(0);
d695 2
a696 4
int lge_newbuf(sc, c, m)
	struct lge_softc	*sc;
	struct lge_rx_desc	*c;
	struct mbuf		*m;
d759 2
a760 2
int lge_alloc_jumbo_mem(sc)
	struct lge_softc	*sc;
d855 2
a856 1
void *lge_jalloc(sc)
d874 2
a875 4
void lge_jfree(buf, size, arg)
	caddr_t		buf;
	u_int		size;
	void		*arg;
a898 2

	return;
d905 2
a906 3
void lge_rxeof(sc, cnt)
	struct lge_softc	*sc;
	int			cnt;
a1007 2

	return;
d1010 2
a1011 2
void lge_rxeoc(sc)
	struct lge_softc	*sc;
a1017 1
	return;
d1025 2
a1026 2
void lge_txeof(sc)
	struct lge_softc	*sc;
a1062 2

	return;
d1065 2
a1066 2
void lge_tick(xsc)
	void			*xsc;
a1084 4
			if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_SX||
			    IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T)
				printf("%s: gigabit link up\n",
				       sc->sc_dv.dv_xname);
a1092 2

	return;
d1095 2
a1096 2
int lge_intr(arg)
	void			*arg;
d1147 1
a1147 1
	return claimed;
d1154 2
a1155 4
int lge_encap(sc, m_head, txidx)
	struct lge_softc	*sc;
	struct mbuf		*m_head;
	u_int32_t		*txidx;
d1183 1
a1183 1
		return(ENOBUFS);
d1192 1
a1192 1
	return(0);
d1202 2
a1203 2
void lge_start(ifp)
	struct ifnet		*ifp;
a1254 2

	return;
d1257 2
a1258 2
void lge_init(xsc)
	void			*xsc;
a1383 2

	return;
d1389 2
a1390 2
int lge_ifmedia_upd(ifp)
	struct ifnet		*ifp;
d1404 1
a1404 1
	return(0);
d1410 2
a1411 3
void lge_ifmedia_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
a1418 2

	return;
d1421 2
a1422 4
int lge_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
d1499 1
a1499 1
	return(error);
d1502 2
a1503 2
void lge_watchdog(ifp)
	struct ifnet		*ifp;
a1518 2

	return;
d1525 2
a1526 2
void lge_stop(sc)
	struct lge_softc	*sc;
a1566 2

	return;
d1573 2
a1574 2
void lge_shutdown(xsc)
	void *xsc;
a1579 2

	return;
a1581 7
struct cfattach lge_ca = {
	sizeof(struct lge_softc), lge_probe, lge_attach
};

struct cfdriver lge_cd = {
	0, "lge", DV_IFNET
};
@


1.28
log
@IFCAP_VLAN_MTU
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.27 2005/10/07 21:23:51 brad Exp $	*/
a97 5
#endif

#if NVLAN > 0
#include <net/if_types.h>
#include <net/if_vlan_var.h>
@


1.27
log
@revert this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.26 2005/10/07 21:17:42 brad Exp $	*/
d592 2
@


1.26
log
@sync lge_alloc_jumbo_mem() to look like bge's bge_alloc_jumbo_mem()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.25 2005/10/07 21:05:15 brad Exp $	*/
d610 1
a610 1
	mii_attach(self, &sc->lge_mii, 0xffffffff, MII_PHY_ANY,
@


1.25
log
@free bus_dma resources for all failures in attach.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.24 2005/10/07 20:57:21 brad Exp $	*/
d782 1
a782 1
	int			i, rseg;
d785 2
d791 2
a792 1
		return (ENOBUFS);
d794 2
d800 2
a801 2
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		return (ENOBUFS);
d803 2
d808 2
a809 3
		bus_dmamem_unmap(sc->sc_dmatag, kva, LGE_JMEM);
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		return (ENOBUFS);
d811 2
d816 2
a817 4
		bus_dmamap_destroy(sc->sc_dmatag, dmamap);
		bus_dmamem_unmap(sc->sc_dmatag, kva, LGE_JMEM);
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		return (ENOBUFS);
d819 2
a838 4
			bus_dmamap_unload(sc->sc_dmatag, dmamap);
			bus_dmamap_destroy(sc->sc_dmatag, dmamap);
			bus_dmamem_unmap(sc->sc_dmatag, kva, LGE_JMEM);
			bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
d842 2
a843 1
			return(ENOBUFS);
d849 16
d866 1
a866 1
	return(0);
d876 1
a876 1
	
d878 3
a880 7
	
	if (entry == NULL) {
#ifdef LGE_VERBOSE
		printf("%s: no free jumbo buffers\n", sc->sc_dv.dv_xname);
#endif
		return(NULL);
	}
d884 1
a884 1
	return(sc->lge_cdata.lge_jslots[entry->slot]);
@


1.24
log
@some fixes for the lge driver, though still doesn't work..

- use MEXTADD() macro
- remove spl from attach
- use splnet
- disestablish interrupt on failure and some other cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.23 2005/09/11 18:17:08 mickey Exp $	*/
d553 1
a553 2
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		goto fail_2;
d560 1
a560 4
		bus_dmamem_unmap(sc->sc_dmatag, kva,
				 sizeof(struct lge_list_data));
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		goto fail_2;
d566 1
a566 5
		bus_dmamap_destroy(sc->sc_dmatag, dmamap);
		bus_dmamem_unmap(sc->sc_dmatag, kva,
				 sizeof(struct lge_list_data));
		bus_dmamem_free(sc->sc_dmatag, &seg, rseg);
		goto fail_2;
d578 1
a578 1
		goto fail_2;
d634 10
@


1.23
log
@do not inline pci_mapreg_map() anymore as it is olrite now; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.22 2005/08/09 04:10:12 mickey Exp $	*/
a126 1
void lge_free_jumbo_mem(struct lge_softc *);
d430 1
a430 1
	bus_size_t		iosize;
d433 1
a433 1
	int			s, rseg;
d435 4
a438 1
	u_int32_t		command;
a439 1
	int			error = 0;
a441 2
	s = splimp();

a477 1
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
d479 1
a480 10
	if (!(command & PCI_COMMAND_IO_ENABLE)) {
		printf("%s: failed to enable I/O ports!\n",
		       sc->sc_dv.dv_xname);
		error = ENXIO;
		goto fail;
	}
	/*
	 * Map control/status registers.
	 */
	DPRINTFN(5, ("pci_mapreg_map\n"));
d482 1
a482 1
	    &sc->lge_btag, &sc->lge_bhandle, NULL, &iosize, 0)) {
d484 1
a484 1
		goto fail;
d487 9
a495 9
	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf("%s: failed to enable memory mapping!\n",
		       sc->sc_dv.dv_xname);
		error = ENXIO;
		goto fail;
	}
	DPRINTFN(5, ("pci_mapreg_map\n"));
	if (pci_mapreg_map(pa, LGE_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->lge_btag, &sc->lge_bhandle, NULL, &iosize, 0)) {
d497 1
a497 1
		goto fail;
d536 1
a536 1
	printf(": address: %s\n", ether_sprintf(eaddr));
d545 1
a545 1
		goto fail_1;
d554 1
a554 1
		goto fail_1;
d564 1
a564 1
		goto fail_1;
d574 1
a574 1
		goto fail_1;
d586 1
a586 1
		goto fail_1;
d614 1
d617 2
a618 1
	mii_attach(&sc->sc_dv, &sc->lge_mii, 0xffffffff, MII_PHY_ANY,
d626 3
a629 2
	else
		ifmedia_set(&sc->lge_mii.mii_media, IFM_ETHER|IFM_AUTO);
d641 4
d647 1
a647 3
	bus_space_unmap(sc->lge_btag, sc->lge_bhandle, iosize);
fail:
	splx(s);
a713 1
	caddr_t			*buf = NULL;
d716 2
d719 2
a720 3
		if (m_new == NULL) {
			return(ENOBUFS);
		}
d726 1
a726 1
			return(ENOBUFS);
d728 1
d730 2
a731 7
		m_new->m_data = m_new->m_ext.ext_buf = (void *)buf;
		m_new->m_flags |= M_EXT;
		m_new->m_ext.ext_size = m_new->m_pkthdr.len =
			m_new->m_len = LGE_JLEN;
		m_new->m_ext.ext_free = lge_jfree;
		m_new->m_ext.ext_arg = sc;
		MCLINITREFERENCE(m_new);
d733 5
d771 1
a771 1
	return(0);
d1080 1
a1080 1
	s = splimp();
d1281 2
a1285 2
	s = splimp();

d1454 1
a1454 1
	s = splimp();
d1472 1
a1472 1
		if (ifr->ifr_mtu > ETHERMTU_JUMBO)
d1474 1
a1474 1
		else
a1490 1
				ifp->if_flags &= ~IFF_RUNNING;
a1497 1
		error = 0;
@


1.22
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.21 2005/07/02 23:10:11 brad Exp $	*/
a430 1
	bus_addr_t		iobase;
d453 1
a453 1
			u_int32_t		iobase, membase, irq;
d491 3
a493 7
	DPRINTFN(5, ("pci_io_find\n"));
	if (pci_io_find(pc, pa->pa_tag, LGE_PCI_LOIO, &iobase, &iosize)) {
		printf(": can't find i/o space\n");
		goto fail;
	}
	DPRINTFN(5, ("bus_space_map\n"));
	if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->lge_bhandle)) {
a496 1
	sc->lge_btag = pa->pa_iot;
d504 3
a506 8
	DPRINTFN(5, ("pci_mem_find\n"));
	if (pci_mem_find(pc, pa->pa_tag, LGE_PCI_LOMEM, &iobase,
			 &iosize, NULL)) {
		printf(": can't find mem space\n");
		goto fail;
	}
	DPRINTFN(5, ("bus_space_map\n"));
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->lge_bhandle)) {
a509 2
	
	sc->lge_btag = pa->pa_memt;
d515 1
a515 1
		goto fail;
d528 1
a528 1
		goto fail;
d556 1
a556 1
		goto fail;
d565 1
a565 1
		goto fail;
d575 1
a575 1
		goto fail;
d585 1
a585 1
		goto fail;
d597 1
a597 1
		goto fail;
d650 2
@


1.21
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.20 2005/06/18 04:23:09 brad Exp $	*/
a479 4
	command = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	  PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
@


1.20
log
@though this doesn't work yet at least allow it to compile first.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.19 2005/05/11 03:54:59 brad Exp $	*/
d1582 3
a1614 2

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.19
log
@Do not call mii_pollstat() immediately after mii_tick().

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.18 2005/04/25 17:55:51 brad Exp $	*/
d364 1
a364 1
		h = ( ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26) &
a365 1
		h = lge_crc(sc, LLADDR((struct sockaddr_dl *)enm->enm_addrlo));
@


1.18
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.17 2004/09/23 17:45:16 brad Exp $	*/
a1109 1
		mii_pollstat(mii);
@


1.17
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.16 2004/08/05 19:57:17 brad Exp $	*/
d1010 1
a1010 1
				m->m_pkthdr.csum |= M_IPV4_CSUM_IN_BAD;
d1012 1
a1012 1
				m->m_pkthdr.csum |= M_IPV4_CSUM_IN_OK;
d1016 1
a1016 1
				m->m_pkthdr.csum |= M_TCP_CSUM_IN_BAD;
d1018 1
a1018 1
				m->m_pkthdr.csum |= M_TCP_CSUM_IN_OK;
d1022 1
a1022 1
				m->m_pkthdr.csum |= M_UDP_CSUM_IN_BAD;
d1024 1
a1024 1
				m->m_pkthdr.csum |= M_UDP_CSUM_IN_OK;
@


1.16
log
@remove some separate per driver constants and use
ETHER_MAX_LEN_JUMBO/ETHERMTU_JUMBO where appropriate.

ok mcbride@@ henning@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.15 2004/06/05 20:24:30 mcbride Exp $	*/
a619 1
	ifp->if_mtu = ETHERMTU;
a621 1
	ifp->if_output = ether_output;
@


1.15
log
@- replace handrolled crc32 with ether_crc32_be()
- make multicast ranges work

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.14 2004/04/09 21:52:17 henning Exp $	*/
d762 1
a762 1
		m_new->m_len = m_new->m_pkthdr.len = LGE_JUMBO_FRAMELEN;
d1496 1
a1496 1
		if (ifr->ifr_mtu > LGE_JUMBO_MTU)
@


1.14
log
@do not whine if we cannot get mbufs. the countless printfd makes the machine
crawl under mbuf starvation, making the situationmuch worse, and don't make
sense in the first place.
ok tdeval@@ millert@@ beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.13 2003/10/06 06:43:12 david Exp $	*/
a155 1
u_int32_t lge_crc(struct lge_softc *, caddr_t);
a333 28
u_int32_t lge_crc(sc, addr)
	struct lge_softc	*sc;
	caddr_t			addr;
{
	u_int32_t		crc, carry;
	int			i, j;
	u_int8_t		c;

	/* Compute CRC for the address value. */
	crc = 0xFFFFFFFF; /* initial value */

	for (i = 0; i < 6; i++) {
		c = *(addr + i);
		for (j = 0; j < 8; j++) {
			carry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);
			crc <<= 1;
			c >>= 1;
			if (carry)
				crc = (crc ^ 0x04c11db6) | carry;
		}
	}

	/*
	 * return the filter bit position
	 */
	return((crc >> 26) & 0x0000003F);
}

d346 1
d360 6
a365 2
		if (memcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0)
			continue;
@


1.13
log
@make lge(4) compile, from tedu@@
ok jason@@ nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.12 2003/08/06 21:08:07 millert Exp $	*/
a766 2
			printf("%s: no memory for rx list "
			       "-- packet dropped!\n", sc->sc_dv.dv_xname);
a772 4
#ifdef LGE_VERBOSE
			printf("%s: jumbo allocation failed "
			       "-- packet dropped!\n", sc->sc_dv.dv_xname);
#endif
a998 3
				printf("%s: no receive buffers "
				       "available -- packet dropped!\n",
				       sc->sc_dv.dv_xname);
@


1.12
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.11 2002/11/26 06:01:28 nate Exp $	*/
d1248 1
a1248 1
			f->lge_fragptr_lo = vtophys(mtod(m, vm_offset_t));
@


1.11
log
@1000baseTX -> 1000baseT
- More technically correct
- Matches FreeBSD and NetBSD
- Preserved #define for 1000baseTX for backwards compatibility
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.10 2002/07/10 18:08:13 deraadt Exp $	*/
d515 1
a515 1
		error = ENXIO;;
@


1.10
log
@shorten address printout
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.9 2002/03/14 01:26:58 millert Exp $	*/
d306 1
a306 1
	case IFM_1000_TX:
d1150 1
a1150 1
			    IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_TX)
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.8 2002/03/12 09:51:20 kjc Exp $	*/
d589 1
a589 1
	printf(": Ethernet address: %s\n", ether_sprintf(eaddr));
@


1.8
log
@sync with KAME
ALTQify more drivers.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.7 2002/02/15 20:45:31 nordin Exp $	*/
d123 2
a124 2
int lge_probe		__P((struct device *, void *, void *));
void lge_attach		__P((struct device *, struct device *, void *));
d126 34
a159 34
int lge_alloc_jumbo_mem	__P((struct lge_softc *));
void lge_free_jumbo_mem	__P((struct lge_softc *));
void *lge_jalloc	__P((struct lge_softc *));
void lge_jfree		__P((caddr_t, u_int, void *));

int lge_newbuf		__P((struct lge_softc *, struct lge_rx_desc *,
			     struct mbuf *));
int lge_encap		__P((struct lge_softc *, struct mbuf *, u_int32_t *));
void lge_rxeof		__P((struct lge_softc *, int));
void lge_rxeoc		__P((struct lge_softc *));
void lge_txeof		__P((struct lge_softc *));
int lge_intr		__P((void *));
void lge_tick		__P((void *));
void lge_start		__P((struct ifnet *));
int lge_ioctl		__P((struct ifnet *, u_long, caddr_t));
void lge_init		__P((void *));
void lge_stop		__P((struct lge_softc *));
void lge_watchdog	__P((struct ifnet *));
void lge_shutdown	__P((void *));
int lge_ifmedia_upd	__P((struct ifnet *));
void lge_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));

void lge_eeprom_getword	__P((struct lge_softc *, int, u_int16_t *));
void lge_read_eeprom	__P((struct lge_softc *, caddr_t, int, int, int));

int lge_miibus_readreg	__P((struct device *, int, int));
void lge_miibus_writereg	__P((struct device *, int, int, int));
void lge_miibus_statchg	__P((struct device *));

void lge_setmulti	__P((struct lge_softc *));
u_int32_t lge_crc	__P((struct lge_softc *, caddr_t));
void lge_reset		__P((struct lge_softc *));
int lge_list_rx_init	__P((struct lge_softc *));
int lge_list_tx_init	__P((struct lge_softc *));
@


1.7
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.6 2001/11/06 19:53:19 miod Exp $	*/
d651 2
a652 1
	ifp->if_snd.ifq_maxlen = LGE_TX_LIST_CNT - 1;
d1153 1
a1153 1
			if (ifp->if_snd.ifq_head != NULL)
d1214 1
a1214 1
	if (ifp->if_snd.ifq_head != NULL)
d1280 1
d1296 1
a1296 1
		IF_DEQUEUE(&ifp->if_snd, m_head);
a1300 1
			IF_PREPEND(&ifp->if_snd, m_head);
d1305 4
d1318 2
d1600 1
a1600 1
	if (ifp->if_snd.ifq_head != NULL)
@


1.6
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.5 2001/11/05 16:50:12 todd Exp $	*/
d1351 1
a1351 1
		(void)splx(s);
d1448 1
a1448 1
	(void)splx(s);
d1573 1
a1573 1
	(void)splx(s);
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.6 2001/11/06 19:53:19 miod Exp $	*/
d123 2
a124 2
int lge_probe(struct device *, void *, void *);
void lge_attach(struct device *, struct device *, void *);
d126 34
a159 34
int lge_alloc_jumbo_mem(struct lge_softc *);
void lge_free_jumbo_mem(struct lge_softc *);
void *lge_jalloc(struct lge_softc *);
void lge_jfree(caddr_t, u_int, void *);

int lge_newbuf(struct lge_softc *, struct lge_rx_desc *,
			     struct mbuf *);
int lge_encap(struct lge_softc *, struct mbuf *, u_int32_t *);
void lge_rxeof(struct lge_softc *, int);
void lge_rxeoc(struct lge_softc *);
void lge_txeof(struct lge_softc *);
int lge_intr(void *);
void lge_tick(void *);
void lge_start(struct ifnet *);
int lge_ioctl(struct ifnet *, u_long, caddr_t);
void lge_init(void *);
void lge_stop(struct lge_softc *);
void lge_watchdog(struct ifnet *);
void lge_shutdown(void *);
int lge_ifmedia_upd(struct ifnet *);
void lge_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void lge_eeprom_getword(struct lge_softc *, int, u_int16_t *);
void lge_read_eeprom(struct lge_softc *, caddr_t, int, int, int);

int lge_miibus_readreg(struct device *, int, int);
void lge_miibus_writereg(struct device *, int, int, int);
void lge_miibus_statchg(struct device *);

void lge_setmulti(struct lge_softc *);
u_int32_t lge_crc(struct lge_softc *, caddr_t);
void lge_reset(struct lge_softc *);
int lge_list_rx_init(struct lge_softc *);
int lge_list_tx_init(struct lge_softc *);
d651 1
a651 2
	IFQ_SET_MAXLEN(&ifp->if_snd, LGE_TX_LIST_CNT - 1);
	IFQ_SET_READY(&ifp->if_snd);
d1152 1
a1152 1
			if (!IFQ_IS_EMPTY(&ifp->if_snd))
d1213 1
a1213 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd))
a1278 1
	int			pkts = 0;
d1294 1
a1294 1
		IFQ_POLL(&ifp->if_snd, m_head);
d1299 1
a1303 4
		/* now we are committed to transmit the packet */
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
		pkts++;

a1312 2
	if (pkts == 0)
		return;
d1351 1
a1351 1
		splx(s);
d1448 1
a1448 1
	splx(s);
d1573 1
a1573 1
	splx(s);
d1593 1
a1593 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd))
@


1.6.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.6.2.1 2002/06/11 03:42:25 art Exp $	*/
d589 1
a589 1
	printf(": address: %s\n", ether_sprintf(eaddr));
@


1.6.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d306 1
a306 1
	case IFM_1000_T:
d1150 1
a1150 1
			    IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T)
@


1.5
log
@compile fix; fgsch@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.4 2001/11/05 04:16:11 fgsch Exp $	*/
d109 2
a110 2
#include <vm/vm.h>              /* for vtophys */
#include <vm/pmap.h>            /* for vtophys */
@


1.4
log
@Use ether_input_mbuf(). As a bonus, tcpdump should show the ethernet
headers now; nate@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.3 2001/09/11 20:05:25 miod Exp $	*/
a961 1
        struct ether_header	*eh;
@


1.3
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.2 2001/09/05 20:58:54 nate Exp $	*/
a1017 4
		eh = mtod(m, struct ether_header *);

		/* Remove header from mbuf and pass it on. */
		m_adj(m, sizeof(struct ether_header));
d1062 1
a1062 1
		ether_input(ifp, eh, m);
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@Merge in -current
@
text
@d109 2
a110 2
#include <uvm/uvm_extern.h>              /* for vtophys */
#include <uvm/uvm_pmap.h>            /* for vtophys */
d962 1
d1018 4
d1066 1
a1066 1
		ether_input_mbuf(ifp, m);
@


1.3.4.3
log
@Merge in trunk
@
text
@d1351 1
a1351 1
		splx(s);
d1448 1
a1448 1
	splx(s);
d1573 1
a1573 1
	splx(s);
@


1.3.4.4
log
@Merge in -current from roughly a week ago
@
text
@d123 2
a124 2
int lge_probe(struct device *, void *, void *);
void lge_attach(struct device *, struct device *, void *);
d126 34
a159 34
int lge_alloc_jumbo_mem(struct lge_softc *);
void lge_free_jumbo_mem(struct lge_softc *);
void *lge_jalloc(struct lge_softc *);
void lge_jfree(caddr_t, u_int, void *);

int lge_newbuf(struct lge_softc *, struct lge_rx_desc *,
			     struct mbuf *);
int lge_encap(struct lge_softc *, struct mbuf *, u_int32_t *);
void lge_rxeof(struct lge_softc *, int);
void lge_rxeoc(struct lge_softc *);
void lge_txeof(struct lge_softc *);
int lge_intr(void *);
void lge_tick(void *);
void lge_start(struct ifnet *);
int lge_ioctl(struct ifnet *, u_long, caddr_t);
void lge_init(void *);
void lge_stop(struct lge_softc *);
void lge_watchdog(struct ifnet *);
void lge_shutdown(void *);
int lge_ifmedia_upd(struct ifnet *);
void lge_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void lge_eeprom_getword(struct lge_softc *, int, u_int16_t *);
void lge_read_eeprom(struct lge_softc *, caddr_t, int, int, int);

int lge_miibus_readreg(struct device *, int, int);
void lge_miibus_writereg(struct device *, int, int, int);
void lge_miibus_statchg(struct device *);

void lge_setmulti(struct lge_softc *);
u_int32_t lge_crc(struct lge_softc *, caddr_t);
void lge_reset(struct lge_softc *);
int lge_list_rx_init(struct lge_softc *);
int lge_list_tx_init(struct lge_softc *);
d651 1
a651 2
	IFQ_SET_MAXLEN(&ifp->if_snd, LGE_TX_LIST_CNT - 1);
	IFQ_SET_READY(&ifp->if_snd);
d1152 1
a1152 1
			if (!IFQ_IS_EMPTY(&ifp->if_snd))
d1213 1
a1213 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd))
a1278 1
	int			pkts = 0;
d1294 1
a1294 1
		IFQ_POLL(&ifp->if_snd, m_head);
d1299 1
a1303 4
		/* now we are committed to transmit the packet */
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
		pkts++;

a1312 2
	if (pkts == 0)
		return;
d1593 1
a1593 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd))
@


1.3.4.5
log
@Sync the SMP branch with 3.3
@
text
@d306 1
a306 1
	case IFM_1000_T:
d589 1
a589 1
	printf(": address: %s\n", ether_sprintf(eaddr));
d1150 1
a1150 1
			    IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T)
@


1.3.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d515 1
a515 1
		error = ENXIO;
d1248 1
a1248 1
			f->lge_fragptr_lo = vtophys(mtod(m, vaddr_t));
@


1.3.4.7
log
@Merge with the trunk
@
text
@d767 2
d775 4
d1005 3
@


1.3.4.8
log
@sync to head
@
text
@d156 1
d335 28
a374 1
allmulti:
d388 2
a389 6
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}
		h = ( ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26) &
		    0x0000003F;
@


1.2
log
@fix pci_intr_map so that it uses the new interface
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lge.c,v 1.1 2001/09/04 20:36:38 nate Exp $	*/
a110 1
#include <vm/vm_kern.h>
@


1.1
log
@Driver for the Level1 LXT1001 Gigabit Ethernet Chip.
From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d556 1
a556 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
			 pa->pa_intrline, &ih)) {
@

