head	1.75;
access;
symbols
	OPENBSD_6_1:1.75.0.4
	OPENBSD_6_1_BASE:1.75
	OPENBSD_6_0:1.73.0.4
	OPENBSD_6_0_BASE:1.73
	OPENBSD_5_9:1.67.0.2
	OPENBSD_5_9_BASE:1.67
	OPENBSD_5_8:1.62.0.4
	OPENBSD_5_8_BASE:1.62
	OPENBSD_5_7:1.59.0.4
	OPENBSD_5_7_BASE:1.59
	OPENBSD_5_6:1.57.0.4
	OPENBSD_5_6_BASE:1.57
	OPENBSD_5_5:1.56.0.4
	OPENBSD_5_5_BASE:1.56
	OPENBSD_5_4:1.54.0.10
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.54.0.8
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.54.0.6
	OPENBSD_5_2_BASE:1.54
	OPENBSD_5_1_BASE:1.54
	OPENBSD_5_1:1.54.0.4
	OPENBSD_5_0:1.54.0.2
	OPENBSD_5_0_BASE:1.54
	OPENBSD_4_9:1.52.0.4
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.52.0.2
	OPENBSD_4_8_BASE:1.52
	OPENBSD_4_7:1.51.0.2
	OPENBSD_4_7_BASE:1.51
	OPENBSD_4_6:1.49.0.6
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.49.0.2
	OPENBSD_4_5_BASE:1.49
	OPENBSD_4_4:1.43.0.4
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.43.0.2
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.42.0.2
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.37.0.2
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.31.0.2
	OPENBSD_4_0_BASE:1.31;
locks; strict;
comment	@ * @;


1.75
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.74;
commitid	VyLWTsbepAOk7VQM;

1.74
date	2016.11.29.10.22.30;	author jsg;	state Exp;
branches;
next	1.73;
commitid	ZQetSMB5ilG2z10X;

1.73
date	2016.05.16.04.34.25;	author dlg;	state Exp;
branches;
next	1.72;
commitid	n891M7FUFJL7cUTG;

1.72
date	2016.04.28.00.11.56;	author dlg;	state Exp;
branches;
next	1.71;
commitid	ptaZifRlV58p07Mz;

1.71
date	2016.04.27.13.02.39;	author dlg;	state Exp;
branches;
next	1.70;
commitid	gNura1JqH0LqMwIA;

1.70
date	2016.04.27.12.56.20;	author dlg;	state Exp;
branches;
next	1.69;
commitid	r5aIPhxzYDQ1Yj0g;

1.69
date	2016.04.27.12.54.20;	author dlg;	state Exp;
branches;
next	1.68;
commitid	mjLiWyUmrdURoX66;

1.68
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.67;
commitid	8YSL8ByWzGeIGBiJ;

1.67
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.66;
commitid	B0kwmVGiD5DVx4kv;

1.66
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.65;
commitid	5gdEnqVoJuTuwdTu;

1.65
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.64;
commitid	eYnPulzvLjDImPCa;

1.64
date	2015.11.14.17.54.57;	author mpi;	state Exp;
branches;
next	1.63;
commitid	Waft2RDjXAxr4qZ9;

1.63
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.62;
commitid	hPF95ClMUQfeqQDX;

1.62
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.61;
commitid	MVWrtktB46JRxFWT;

1.61
date	2015.04.30.07.51.07;	author mpi;	state Exp;
branches;
next	1.60;
commitid	H09AuNxNnUcYramX;

1.60
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.59;
commitid	p4LJxGKbi0BU2cG6;

1.59
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.58;
commitid	yM2VFFhpDTeFQlve;

1.58
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.57;
commitid	LS2TNeCue5R9L67C;

1.57
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.56;
commitid	TGHgrLxu6sxZoiFt;

1.56
date	2013.11.26.09.50.33;	author mpi;	state Exp;
branches;
next	1.55;

1.55
date	2013.08.07.01.06.39;	author bluhm;	state Exp;
branches;
next	1.54;

1.54
date	2011.04.05.18.01.21;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2011.04.03.15.36.03;	author jasper;	state Exp;
branches;
next	1.52;

1.52
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.51;

1.51
date	2009.08.13.14.24.47;	author jasper;	state Exp;
branches;
next	1.50;

1.50
date	2009.08.10.17.29.19;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.48;

1.48
date	2008.11.09.15.08.26;	author naddy;	state Exp;
branches;
next	1.47;

1.47
date	2008.10.21.00.26.40;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2008.10.16.19.18.03;	author naddy;	state Exp;
branches;
next	1.45;

1.45
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2008.09.24.19.12.59;	author chl;	state Exp;
branches;
next	1.43;

1.43
date	2007.09.19.03.50.25;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.28.23.39.07;	author ckuethe;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.26.18.40.28;	author dlg;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.26.18.38.26;	author dlg;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.26.18.29.11;	author dlg;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.26.18.25.11;	author dlg;	state Exp;
branches;
next	1.37;

1.37
date	2007.02.27.22.39.39;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2007.02.27.22.18.53;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2006.10.24.20.14.43;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2006.10.23.21.08.22;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2006.10.11.00.08.51;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2006.10.10.23.39.15;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2006.08.25.00.55.37;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2006.08.10.17.24.32;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2006.08.10.15.48.45;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2006.08.02.00.23.18;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2006.07.21.01.57.15;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2006.07.14.02.32.14;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.21.07.15.58;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.09.19.09.41;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.01.23.04.55;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2006.06.01.22.58.42;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.01.21.56.26;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.01.21.53.52;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.01.09.39.13;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.01.09.20.04;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.28.00.20.21;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.28.00.04.24;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.27.10.03.15;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.26.20.50.41;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.20.03.47.56;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.15.00.41.51;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.14.22.19.04;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.14.21.51.22;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.14.21.41.25;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.14.21.11.10;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.14.20.19.23;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.14.19.55.51;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.13.05.12.38;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.13.05.02.37;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.01.01.31.48;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.01.01.11.49;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.01.00.34.12;	author brad;	state Exp;
branches;
next	;


desc
@@


1.75
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_xge.c,v 1.74 2016/11/29 10:22:30 jsg Exp $	*/
/*	$NetBSD: if_xge.c,v 1.1 2005/09/09 10:30:27 ragge Exp $	*/

/*
 * Copyright (c) 2004, SUNET, Swedish University Computer Network.
 * All rights reserved.
 *
 * Written by Anders Magnusson for SUNET, Swedish University Computer Network.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project by
 *      SUNET, Swedish University Computer Network.
 * 4. The name of SUNET may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY SUNET ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL SUNET
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Driver for the Neterion Xframe Ten Gigabit Ethernet controller.
 */

#include "bpfilter.h"
#include "vlan.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/mii/miivar.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <sys/lock.h>

#include <dev/pci/if_xgereg.h>

/* Xframe chipset revisions */
#define XGE_TYPE_XENA		1	/* Xframe */
#define XGE_TYPE_HERC		2	/* Xframe-II */

#define XGE_PCISIZE_XENA	26
#define XGE_PCISIZE_HERC	64

/*
 * Some tunable constants, tune with care!
 */
#define RX_MODE		RX_MODE_1  /* Receive mode (buffer usage, see below) */
#define NRXDESCS	1016	   /* # of receive descriptors (requested) */
#define NTXDESCS	2048	   /* Number of transmit descriptors */
#define NTXFRAGS	100	   /* Max fragments per packet */

/*
 * Receive buffer modes; 1, 3 or 5 buffers.
 */
#define RX_MODE_1 1
#define RX_MODE_3 3
#define RX_MODE_5 5

/*
 * Use clever macros to avoid a bunch of #ifdef's.
 */
#define XCONCAT3(x,y,z) x ## y ## z
#define CONCAT3(x,y,z) XCONCAT3(x,y,z)
#define NDESC_BUFMODE CONCAT3(NDESC_,RX_MODE,BUFMODE)
#define rxd_4k CONCAT3(rxd,RX_MODE,_4k)
/* XXX */
#if 0
#define rxdesc ___CONCAT(rxd,RX_MODE)
#endif
#define rxdesc rxd1

#define NEXTTX(x)	(((x)+1) % NTXDESCS)
#define NRXFRAGS	RX_MODE /* hardware imposed frags */
#define NRXPAGES	((NRXDESCS/NDESC_BUFMODE)+1)
#define NRXREAL		(NRXPAGES*NDESC_BUFMODE)
#define RXMAPSZ		(NRXPAGES*PAGE_SIZE)

/*
 * Magic to fix a bug when the MAC address cannot be read correctly.
 * This came from the Linux driver.
 */
static const uint64_t xge_fix_mac[] = {
	0x0060000000000000ULL, 0x0060600000000000ULL,
	0x0040600000000000ULL, 0x0000600000000000ULL,
	0x0020600000000000ULL, 0x0060600000000000ULL,
	0x0020600000000000ULL, 0x0060600000000000ULL,
	0x0020600000000000ULL, 0x0060600000000000ULL,
	0x0020600000000000ULL, 0x0060600000000000ULL,
	0x0020600000000000ULL, 0x0060600000000000ULL,
	0x0020600000000000ULL, 0x0060600000000000ULL,
	0x0020600000000000ULL, 0x0060600000000000ULL,
	0x0020600000000000ULL, 0x0060600000000000ULL,
	0x0020600000000000ULL, 0x0060600000000000ULL,
	0x0020600000000000ULL, 0x0060600000000000ULL,
	0x0020600000000000ULL, 0x0000600000000000ULL,
	0x0040600000000000ULL, 0x0060600000000000ULL,
};

/*
 * Constants to be programmed into Hercules's registers, to configure
 * the XGXS transciever.
 */
static const uint64_t xge_herc_dtx_cfg[] = {
	0x8000051536750000ULL, 0x80000515367500E0ULL,
	0x8000051536750004ULL, 0x80000515367500E4ULL,

	0x80010515003F0000ULL, 0x80010515003F00E0ULL,
	0x80010515003F0004ULL, 0x80010515003F00E4ULL,

	0x801205150D440000ULL, 0x801205150D4400E0ULL,
	0x801205150D440004ULL, 0x801205150D4400E4ULL,

	0x80020515F2100000ULL, 0x80020515F21000E0ULL,
	0x80020515F2100004ULL, 0x80020515F21000E4ULL,
};

static const uint64_t xge_xena_dtx_cfg[] = {
	0x8000051500000000ULL, 0x80000515000000E0ULL,
	0x80000515D9350004ULL, 0x80000515D93500E4ULL,

	0x8001051500000000ULL, 0x80010515000000E0ULL,
	0x80010515001E0004ULL, 0x80010515001E00E4ULL,

	0x8002051500000000ULL, 0x80020515000000E0ULL,
	0x80020515F2100004ULL, 0x80020515F21000E4ULL,
 };

struct xge_softc {
	struct device		sc_dev;
	struct arpcom		sc_arpcom;
	struct ifmedia		xena_media;

	void			*sc_ih;

	bus_dma_tag_t		sc_dmat;
	bus_space_tag_t		sc_st;
	bus_space_handle_t	sc_sh;
	bus_space_tag_t		sc_txt;
	bus_space_handle_t	sc_txh;

	pcireg_t		sc_pciregs[16];

	int			xge_type; /* chip type */
	int			xge_if_flags;

	/* Transmit structures */
	struct txd		*sc_txd[NTXDESCS]; /* transmit frags array */
	bus_addr_t		sc_txdp[NTXDESCS]; /* dva of transmit frags */
	bus_dmamap_t		sc_txm[NTXDESCS]; /* transmit frags map */
	struct mbuf		*sc_txb[NTXDESCS]; /* transmit mbuf pointer */
	int			sc_nexttx, sc_lasttx;
	bus_dmamap_t		sc_txmap; /* transmit descriptor map */

	/* Receive data */
	bus_dmamap_t		sc_rxmap; /* receive descriptor map */
	struct rxd_4k		*sc_rxd_4k[NRXPAGES]; /* receive desc pages */
	bus_dmamap_t		sc_rxm[NRXREAL]; /* receive buffer map */
	struct mbuf		*sc_rxb[NRXREAL]; /* mbufs on rx descriptors */
	int			sc_nextrx; /* next descriptor to check */
};

#ifdef XGE_DEBUG
#define DPRINTF(x)	do { if (xgedebug) printf x ; } while (0)
#define DPRINTFN(n,x)	do { if (xgedebug >= (n)) printf x ; } while (0)
int	xgedebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

int xge_match(struct device *, void *, void *);
void xge_attach(struct device *, struct device *, void *);
int xge_alloc_txmem(struct xge_softc *);
int xge_alloc_rxmem(struct xge_softc *);
void xge_start(struct ifnet *);
void xge_stop(struct ifnet *, int);
int xge_add_rxbuf(struct xge_softc *, int);
void xge_setmulti(struct xge_softc *);
void xge_setpromisc(struct xge_softc *);
int xge_setup_xgxs_xena(struct xge_softc *);
int xge_setup_xgxs_herc(struct xge_softc *);
int xge_ioctl(struct ifnet *, u_long, caddr_t);
int xge_init(struct ifnet *);
void xge_ifmedia_status(struct ifnet *, struct ifmediareq *);
int xge_xgmii_mediachange(struct ifnet *);
void xge_enable(struct xge_softc *);
int xge_intr(void  *);

/*
 * Helpers to address registers.
 */
#define PIF_WCSR(csr, val)	pif_wcsr(sc, csr, val)
#define PIF_RCSR(csr)		pif_rcsr(sc, csr)
#define TXP_WCSR(csr, val)	txp_wcsr(sc, csr, val)
#define PIF_WKEY(csr, val)	pif_wkey(sc, csr, val)

static inline void
pif_wcsr(struct xge_softc *sc, bus_size_t csr, uint64_t val)
{
#if defined(__LP64__)
	bus_space_write_raw_8(sc->sc_st, sc->sc_sh, csr, val);
#else
	uint32_t lval, hval;

	lval = val&0xffffffff;
	hval = val>>32;

#if BYTE_ORDER == LITTLE_ENDIAN
	bus_space_write_raw_4(sc->sc_st, sc->sc_sh, csr, lval);
	bus_space_write_raw_4(sc->sc_st, sc->sc_sh, csr+4, hval);
#else
	bus_space_write_raw_4(sc->sc_st, sc->sc_sh, csr+4, lval);
	bus_space_write_raw_4(sc->sc_st, sc->sc_sh, csr, hval);
#endif
#endif
}

static inline uint64_t
pif_rcsr(struct xge_softc *sc, bus_size_t csr)
{
	uint64_t val;
#if defined(__LP64__)
	val = bus_space_read_raw_8(sc->sc_st, sc->sc_sh, csr);
#else
	uint64_t val2;

	val = bus_space_read_raw_4(sc->sc_st, sc->sc_sh, csr);
	val2 = bus_space_read_raw_4(sc->sc_st, sc->sc_sh, csr+4);
#if BYTE_ORDER == LITTLE_ENDIAN
	val |= (val2 << 32);
#else
	val = (val << 32 | val2);
#endif
#endif
	return (val);
}

static inline void
txp_wcsr(struct xge_softc *sc, bus_size_t csr, uint64_t val)
{
#if defined(__LP64__)
	bus_space_write_raw_8(sc->sc_txt, sc->sc_txh, csr, val);
#else
	uint32_t lval, hval;

	lval = val&0xffffffff;
	hval = val>>32;

#if BYTE_ORDER == LITTLE_ENDIAN
	bus_space_write_raw_4(sc->sc_txt, sc->sc_txh, csr, lval);
	bus_space_write_raw_4(sc->sc_txt, sc->sc_txh, csr+4, hval);
#else
	bus_space_write_raw_4(sc->sc_txt, sc->sc_txh, csr, hval);
	bus_space_write_raw_4(sc->sc_txt, sc->sc_txh, csr+4, lval);
#endif
#endif
}

static inline void
pif_wkey(struct xge_softc *sc, bus_size_t csr, uint64_t val)
{
#if defined(__LP64__)
	if (sc->xge_type == XGE_TYPE_XENA)
		PIF_WCSR(RMAC_CFG_KEY, RMAC_KEY_VALUE);

	bus_space_write_raw_8(sc->sc_st, sc->sc_sh, csr, val);
#else
	uint32_t lval, hval;

	lval = val&0xffffffff;
	hval = val>>32;

	if (sc->xge_type == XGE_TYPE_XENA)
		PIF_WCSR(RMAC_CFG_KEY, RMAC_KEY_VALUE);

#if BYTE_ORDER == LITTLE_ENDIAN
	bus_space_write_raw_4(sc->sc_st, sc->sc_sh, csr, lval);
#else
	bus_space_write_raw_4(sc->sc_st, sc->sc_sh, csr, hval);
#endif

	if (sc->xge_type == XGE_TYPE_XENA)
		PIF_WCSR(RMAC_CFG_KEY, RMAC_KEY_VALUE);
#if BYTE_ORDER == LITTLE_ENDIAN
	bus_space_write_raw_4(sc->sc_st, sc->sc_sh, csr+4, hval);
#else
	bus_space_write_raw_4(sc->sc_st, sc->sc_sh, csr+4, lval);
#endif
#endif
}

struct cfattach xge_ca = {
	sizeof(struct xge_softc), xge_match, xge_attach
};

struct cfdriver xge_cd = {
	NULL, "xge", DV_IFNET
};

#define XNAME sc->sc_dev.dv_xname

#define XGE_RXSYNC(desc, what) \
	bus_dmamap_sync(sc->sc_dmat, sc->sc_rxmap, \
	(desc/NDESC_BUFMODE) * XGE_PAGE + sizeof(struct rxdesc) * \
	(desc%NDESC_BUFMODE), sizeof(struct rxdesc), what)
#define XGE_RXD(desc)	&sc->sc_rxd_4k[desc/NDESC_BUFMODE]-> \
	r4_rxd[desc%NDESC_BUFMODE]

/*
 * Non-tunable constants.
 */
#define XGE_MAX_FRAMELEN	9622
#define XGE_MAX_MTU		(XGE_MAX_FRAMELEN - ETHER_HDR_LEN - \
				 ETHER_CRC_LEN - ETHER_VLAN_ENCAP_LEN)

const struct pci_matchid xge_devices[] = {
	{ PCI_VENDOR_NETERION, PCI_PRODUCT_NETERION_XFRAME },
	{ PCI_VENDOR_NETERION, PCI_PRODUCT_NETERION_XFRAME_2 }
};

int
xge_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, xge_devices,
	    nitems(xge_devices)));
}

void
xge_attach(struct device *parent, struct device *self, void *aux)
{
	struct pci_attach_args *pa = aux;
	struct xge_softc *sc;
	struct ifnet *ifp;
	pcireg_t memtype;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
	pci_chipset_tag_t pc = pa->pa_pc;
	uint8_t enaddr[ETHER_ADDR_LEN];
	uint64_t val;
	int i;

	sc = (struct xge_softc *)self;

	sc->sc_dmat = pa->pa_dmat;

	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETERION_XFRAME)
		sc->xge_type = XGE_TYPE_XENA;
	else
		sc->xge_type = XGE_TYPE_HERC;

	/* Get BAR0 address */
	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, XGE_PIF_BAR);
	if (pci_mapreg_map(pa, XGE_PIF_BAR, memtype, 0,
	    &sc->sc_st, &sc->sc_sh, 0, 0, 0)) {
		printf(": unable to map PIF BAR registers\n");
		return;
	}

	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, XGE_TXP_BAR);
	if (pci_mapreg_map(pa, XGE_TXP_BAR, memtype, 0,
	    &sc->sc_txt, &sc->sc_txh, 0, 0, 0)) {
		printf(": unable to map TXP BAR registers\n");
		return;
	}

	if (sc->xge_type == XGE_TYPE_XENA) {
		/* Save PCI config space */
		for (i = 0; i < XGE_PCISIZE_XENA; i += 4)
			sc->sc_pciregs[i/4] = pci_conf_read(pa->pa_pc, pa->pa_tag, i);
			sc->sc_pciregs[i/4] = pci_conf_read(pa->pa_pc, pa->pa_tag, i);
	}

#if BYTE_ORDER == LITTLE_ENDIAN
	val = (uint64_t)0xFFFFFFFFFFFFFFFFULL;
	val &= ~(TxF_R_SE|RxF_W_SE);
	PIF_WCSR(SWAPPER_CTRL, val);
	PIF_WCSR(SWAPPER_CTRL, val);
#endif
	if ((val = PIF_RCSR(PIF_RD_SWAPPER_Fb)) != SWAPPER_MAGIC) {
		printf(": failed configuring endian (read), %llx != %llx!\n",
		    (unsigned long long)val, SWAPPER_MAGIC);
	}

	PIF_WCSR(XMSI_ADDRESS, SWAPPER_MAGIC);
	if ((val = PIF_RCSR(XMSI_ADDRESS)) != SWAPPER_MAGIC) {
		printf(": failed configuring endian (write), %llx != %llx!\n",
			(unsigned long long)val, SWAPPER_MAGIC);
	} 

	/*
	 * Fix for all "FFs" MAC address problems observed on
	 * Alpha platforms. Not needed for Herc.
	 */
	if (sc->xge_type == XGE_TYPE_XENA) {
		/*
		 * The MAC addr may be all FF's, which is not good.
		 * Resolve it by writing some magics to GPIO_CONTROL and
		 * force a chip reset to read in the serial eeprom again.
		 */
		for (i = 0; i < nitems(xge_fix_mac); i++) {
			PIF_WCSR(GPIO_CONTROL, xge_fix_mac[i]);
			PIF_RCSR(GPIO_CONTROL);
		}

		/*
		 * Reset the chip and restore the PCI registers.
		 */
		PIF_WCSR(SW_RESET, 0xa5a5a50000000000ULL);
		DELAY(500000);
		for (i = 0; i < XGE_PCISIZE_XENA; i += 4)
			pci_conf_write(pa->pa_pc, pa->pa_tag, i, sc->sc_pciregs[i/4]);

		/*
		 * Restore the byte order registers.
		 */
#if BYTE_ORDER == LITTLE_ENDIAN
		val = (uint64_t)0xFFFFFFFFFFFFFFFFULL;
		val &= ~(TxF_R_SE|RxF_W_SE);
		PIF_WCSR(SWAPPER_CTRL, val);
		PIF_WCSR(SWAPPER_CTRL, val);
#endif

		if ((val = PIF_RCSR(PIF_RD_SWAPPER_Fb)) != SWAPPER_MAGIC) {
			printf(": failed configuring endian2 (read), %llx != %llx!\n",
			    (unsigned long long)val, SWAPPER_MAGIC);
			return;
		}

		PIF_WCSR(XMSI_ADDRESS, SWAPPER_MAGIC);
		if ((val = PIF_RCSR(XMSI_ADDRESS)) != SWAPPER_MAGIC) {
			printf(": failed configuring endian2 (write), %llx != %llx!\n",
			    (unsigned long long)val, SWAPPER_MAGIC);
			return;
		}
	}

	/*
	 * XGXS initialization.
	 */

	/*
	 * For Herc, bring EOI out of reset before XGXS.
	 */
	if (sc->xge_type == XGE_TYPE_HERC) {
		val = PIF_RCSR(SW_RESET);
		val &= 0xffff00ffffffffffULL;
		PIF_WCSR(SW_RESET,val);
		delay(1000*1000);	/* wait for 1 sec */
	}

	/* 29, Bring adapter out of reset */
	val = PIF_RCSR(SW_RESET);
	val &= 0xffffff00ffffffffULL;
	PIF_WCSR(SW_RESET, val);
	DELAY(500000);

	/* Ensure that it's safe to access registers by checking
	 * RIC_RUNNING bit is reset. Check is valid only for XframeII.
	 */
	if (sc->xge_type == XGE_TYPE_HERC){
		for (i = 0; i < 50; i++) {
			val = PIF_RCSR(ADAPTER_STATUS);
			if (!(val & RIC_RUNNING))
				break;
			delay(20*1000);
		}

		if (i == 50) {
			printf(": not safe to access registers\n");
			return;
		}
	}

	/* 30, configure XGXS transceiver */
	if (sc->xge_type == XGE_TYPE_XENA)
		xge_setup_xgxs_xena(sc);
	else if(sc->xge_type == XGE_TYPE_HERC)
		xge_setup_xgxs_herc(sc);

	/* 33, program MAC address (not needed here) */
	/* Get ethernet address */
	PIF_WCSR(RMAC_ADDR_CMD_MEM,
	    RMAC_ADDR_CMD_MEM_STR|RMAC_ADDR_CMD_MEM_OFF(0));
	while (PIF_RCSR(RMAC_ADDR_CMD_MEM) & RMAC_ADDR_CMD_MEM_STR)
		;
	val = PIF_RCSR(RMAC_ADDR_DATA0_MEM);
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		enaddr[i] = (uint8_t)(val >> (56 - (8*i)));

	/*
	 * Get memory for transmit descriptor lists.
	 */
	if (xge_alloc_txmem(sc)) {
		printf(": failed allocating txmem.\n");
		return;
	}

	/* 9 and 10 - set FIFO number/prio */
	PIF_WCSR(TX_FIFO_P0, TX_FIFO_LEN0(NTXDESCS));
	PIF_WCSR(TX_FIFO_P1, 0ULL);
	PIF_WCSR(TX_FIFO_P2, 0ULL);
	PIF_WCSR(TX_FIFO_P3, 0ULL);

	/* 11, XXX set round-robin prio? */

	/* 12, enable transmit FIFO */
	val = PIF_RCSR(TX_FIFO_P0);
	val |= TX_FIFO_ENABLE;
	PIF_WCSR(TX_FIFO_P0, val);

	/* 13, disable some error checks */
	PIF_WCSR(TX_PA_CFG,
	    TX_PA_CFG_IFR|TX_PA_CFG_ISO|TX_PA_CFG_ILC|TX_PA_CFG_ILE);

	/* Create transmit DMA maps */
	for (i = 0; i < NTXDESCS; i++) {
		if (bus_dmamap_create(sc->sc_dmat, XGE_MAX_FRAMELEN,
		    NTXFRAGS, XGE_MAX_FRAMELEN, 0, BUS_DMA_NOWAIT,
		    &sc->sc_txm[i])) {
			printf(": cannot create TX DMA maps\n");
			return;
		}
	}

	sc->sc_lasttx = NTXDESCS-1;

	/*
	 * RxDMA initialization.
	 * Only use one out of 8 possible receive queues.
	 */
	/* allocate rx descriptor memory */
	if (xge_alloc_rxmem(sc)) {
		printf(": failed allocating rxmem\n");
		return;
	}

	/* Create receive buffer DMA maps */
	for (i = 0; i < NRXREAL; i++) {
		if (bus_dmamap_create(sc->sc_dmat, XGE_MAX_FRAMELEN,
		    NRXFRAGS, XGE_MAX_FRAMELEN, 0, BUS_DMA_NOWAIT,
		    &sc->sc_rxm[i])) {
			printf(": cannot create RX DMA maps\n");
			return;
		}
	}

	/* allocate mbufs to receive descriptors */
	for (i = 0; i < NRXREAL; i++)
		if (xge_add_rxbuf(sc, i))
			panic("out of mbufs too early");

	/* 14, setup receive ring priority */
	PIF_WCSR(RX_QUEUE_PRIORITY, 0ULL); /* only use one ring */

	/* 15, setup receive ring round-robin calendar */
	PIF_WCSR(RX_W_ROUND_ROBIN_0, 0ULL); /* only use one ring */
	PIF_WCSR(RX_W_ROUND_ROBIN_1, 0ULL);
	PIF_WCSR(RX_W_ROUND_ROBIN_2, 0ULL);
	PIF_WCSR(RX_W_ROUND_ROBIN_3, 0ULL);
	PIF_WCSR(RX_W_ROUND_ROBIN_4, 0ULL);

	/* 16, write receive ring start address */
	PIF_WCSR(PRC_RXD0_0, (uint64_t)sc->sc_rxmap->dm_segs[0].ds_addr);
	/* PRC_RXD0_[1-7] are not used */

	/* 17, Setup alarm registers */
	PIF_WCSR(PRC_ALARM_ACTION, 0ULL); /* Default everything to retry */

	/* 18, init receive ring controller */
#if RX_MODE == RX_MODE_1
	val = RING_MODE_1;
#elif RX_MODE == RX_MODE_3
	val = RING_MODE_3;
#else /* RX_MODE == RX_MODE_5 */
	val = RING_MODE_5;
#endif
	PIF_WCSR(PRC_CTRL_0, RC_IN_SVC|val);
	/* leave 1-7 disabled */
	/* XXXX snoop configuration? */

	/* 19, set chip memory assigned to the queue */
	if (sc->xge_type == XGE_TYPE_XENA) {
		/* all 64M to queue 0 */
		PIF_WCSR(RX_QUEUE_CFG, MC_QUEUE(0, 64));
	} else {
		/* all 32M to queue 0 */
		PIF_WCSR(RX_QUEUE_CFG, MC_QUEUE(0, 32));
	}

	/* 20, setup RLDRAM parameters */
	/* do not touch it for now */

	/* 21, setup pause frame thresholds */
	/* so not touch the defaults */
	/* XXX - must 0xff be written as stated in the manual? */

	/* 22, configure RED */
	/* we do not want to drop packets, so ignore */

	/* 23, initiate RLDRAM */
	val = PIF_RCSR(MC_RLDRAM_MRS);
	val |= MC_QUEUE_SIZE_ENABLE|MC_RLDRAM_MRS_ENABLE;
	PIF_WCSR(MC_RLDRAM_MRS, val);
	DELAY(1000);

	/*
	 * Setup interrupt policies.
	 */
	/* 40, Transmit interrupts */
	PIF_WCSR(TTI_DATA1_MEM, TX_TIMER_VAL(0x1ff) | TX_TIMER_AC |
	    TX_URNG_A(5) | TX_URNG_B(20) | TX_URNG_C(48));
	PIF_WCSR(TTI_DATA2_MEM,
	    TX_UFC_A(25) | TX_UFC_B(64) | TX_UFC_C(128) | TX_UFC_D(512));
	PIF_WCSR(TTI_COMMAND_MEM, TTI_CMD_MEM_WE | TTI_CMD_MEM_STROBE);
	while (PIF_RCSR(TTI_COMMAND_MEM) & TTI_CMD_MEM_STROBE)
		;

	/* 41, Receive interrupts */
	PIF_WCSR(RTI_DATA1_MEM, RX_TIMER_VAL(0x800) | RX_TIMER_AC |
	    RX_URNG_A(5) | RX_URNG_B(20) | RX_URNG_C(50));
	PIF_WCSR(RTI_DATA2_MEM,
	    RX_UFC_A(64) | RX_UFC_B(128) | RX_UFC_C(256) | RX_UFC_D(512));
	PIF_WCSR(RTI_COMMAND_MEM, RTI_CMD_MEM_WE | RTI_CMD_MEM_STROBE);
	while (PIF_RCSR(RTI_COMMAND_MEM) & RTI_CMD_MEM_STROBE)
		;

	/*
	 * Setup media stuff.
	 */
	ifmedia_init(&sc->xena_media, IFM_IMASK, xge_xgmii_mediachange,
	    xge_ifmedia_status);
	ifmedia_add(&sc->xena_media, IFM_ETHER|IFM_10G_SR, 0, NULL);
	ifmedia_set(&sc->xena_media, IFM_ETHER|IFM_10G_SR);

	ifp = &sc->sc_arpcom.ac_if;
	strlcpy(ifp->if_xname, XNAME, IFNAMSIZ);
	memcpy(sc->sc_arpcom.ac_enaddr, enaddr, ETHER_ADDR_LEN);
	ifp->if_baudrate = IF_Gbps(10);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = xge_ioctl;
	ifp->if_start = xge_start;
	ifp->if_hardmtu = XGE_MAX_MTU;
	IFQ_SET_MAXLEN(&ifp->if_snd, NTXDESCS - 1);

	ifp->if_capabilities = IFCAP_VLAN_MTU | IFCAP_CSUM_IPv4 |
	    IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4;

#if NVLAN > 0
	ifp->if_capabilities |= IFCAP_VLAN_HWTAGGING;
#endif

	/*
	 * Attach the interface.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

	/*
	 * Setup interrupt vector before initializing.
	 */
	if (pci_intr_map(pa, &ih)) {
		printf(": unable to map interrupt\n");
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	if ((sc->sc_ih =
	    pci_intr_establish(pc, ih, IPL_NET, xge_intr, sc, XNAME)) == NULL) {
		printf(": unable to establish interrupt at %s\n",
		    intrstr ? intrstr : "<unknown>");
		return;
	    }
	printf(": %s, address %s\n", intrstr, ether_sprintf(enaddr));
}

void
xge_ifmedia_status(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct xge_softc *sc = ifp->if_softc;
	uint64_t reg;

	ifmr->ifm_status = IFM_AVALID;
	ifmr->ifm_active = IFM_ETHER|IFM_10G_SR;

	reg = PIF_RCSR(ADAPTER_STATUS);
	if ((reg & (RMAC_REMOTE_FAULT|RMAC_LOCAL_FAULT)) == 0)
		ifmr->ifm_status |= IFM_ACTIVE;
}

int
xge_xgmii_mediachange(struct ifnet *ifp)
{
	return (0);
}

void
xge_enable(struct xge_softc *sc)
{
	uint64_t val;

	/* 2, enable adapter */
	val = PIF_RCSR(ADAPTER_CONTROL);
	val |= ADAPTER_EN;
	PIF_WCSR(ADAPTER_CONTROL, val);

	/* 3, light the card enable led */
	val = PIF_RCSR(ADAPTER_CONTROL);
	val |= LED_ON;
	PIF_WCSR(ADAPTER_CONTROL, val);
#ifdef XGE_DEBUG
	printf("%s: link up\n", XNAME);
#endif
}

int
xge_init(struct ifnet *ifp)
{
	struct xge_softc *sc = ifp->if_softc;
	uint64_t val;
	int s;

	s = splnet();

	/*
	 * Cancel any pending I/O
	 */
	xge_stop(ifp, 0);

	/* 31+32, setup MAC config */
	PIF_WKEY(MAC_CFG, TMAC_EN|RMAC_EN|TMAC_APPEND_PAD|RMAC_STRIP_FCS|
	    RMAC_BCAST_EN|RMAC_DISCARD_PFRM);

	DELAY(1000);

	/* 54, ensure that the adapter is 'quiescent' */
	val = PIF_RCSR(ADAPTER_STATUS);
	if ((val & QUIESCENT) != QUIESCENT) {
#if 0
		char buf[200];
#endif
		printf("%s: adapter not quiescent, aborting\n", XNAME);
		val = (val & QUIESCENT) ^ QUIESCENT;
#if 0
		bitmask_snprintf(val, QUIESCENT_BMSK, buf, sizeof buf);
		printf("%s: ADAPTER_STATUS missing bits %s\n", XNAME, buf);
#endif
		splx(s);
		return (1);
	}

	if (!(ifp->if_capabilities & IFCAP_VLAN_HWTAGGING)) {
		/* disable VLAN tag stripping */
		val = PIF_RCSR(RX_PA_CFG);
		val &= ~STRIP_VLAN_TAG;
		PIF_WCSR(RX_PA_CFG, val);
	}

	/* set MRU */
	PIF_WCSR(RMAC_MAX_PYLD_LEN, RMAC_PYLD_LEN(XGE_MAX_FRAMELEN));

	/* 56, enable the transmit laser */
	val = PIF_RCSR(ADAPTER_CONTROL);
	val |= EOI_TX_ON;
	PIF_WCSR(ADAPTER_CONTROL, val);

	xge_enable(sc);

	/*
	 * Enable all interrupts
	 */
	PIF_WCSR(TX_TRAFFIC_MASK, 0);
	PIF_WCSR(RX_TRAFFIC_MASK, 0);
	PIF_WCSR(TXPIC_INT_MASK, 0);
	PIF_WCSR(RXPIC_INT_MASK, 0);

	PIF_WCSR(MAC_INT_MASK, MAC_TMAC_INT); /* only from RMAC */
	PIF_WCSR(MAC_RMAC_ERR_REG, RMAC_LINK_STATE_CHANGE_INT);
	PIF_WCSR(MAC_RMAC_ERR_MASK, ~RMAC_LINK_STATE_CHANGE_INT);
	PIF_WCSR(GENERAL_INT_MASK, 0);

	xge_setpromisc(sc);

	xge_setmulti(sc);

	/* Done... */
	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);

	return (0);
}

void
xge_stop(struct ifnet *ifp, int disable)
{
	struct xge_softc *sc = ifp->if_softc;
	uint64_t val;

	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	val = PIF_RCSR(ADAPTER_CONTROL);
	val &= ~ADAPTER_EN;
	PIF_WCSR(ADAPTER_CONTROL, val);

	while ((PIF_RCSR(ADAPTER_STATUS) & QUIESCENT) != QUIESCENT)
		;
}

int
xge_intr(void *pv)
{
	struct xge_softc *sc = pv;
	struct txd *txd;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	bus_dmamap_t dmp;
	uint64_t val;
	int i, lasttx, plen;

	val = PIF_RCSR(GENERAL_INT_STATUS);
	if (val == 0)
		return (0); /* no interrupt here */

	PIF_WCSR(GENERAL_INT_STATUS, val);

	if ((val = PIF_RCSR(MAC_RMAC_ERR_REG)) & RMAC_LINK_STATE_CHANGE_INT) {
		/* Wait for quiescence */
#ifdef XGE_DEBUG
		printf("%s: link down\n", XNAME);
#endif
		while ((PIF_RCSR(ADAPTER_STATUS) & QUIESCENT) != QUIESCENT)
			;
		PIF_WCSR(MAC_RMAC_ERR_REG, RMAC_LINK_STATE_CHANGE_INT);

		val = PIF_RCSR(ADAPTER_STATUS);
		if ((val & (RMAC_REMOTE_FAULT|RMAC_LOCAL_FAULT)) == 0)
			xge_enable(sc); /* Only if link restored */
	}

	if ((val = PIF_RCSR(TX_TRAFFIC_INT)))
		PIF_WCSR(TX_TRAFFIC_INT, val); /* clear interrupt bits */
	/*
	 * Collect sent packets.
	 */
	lasttx = sc->sc_lasttx;
	while ((i = NEXTTX(sc->sc_lasttx)) != sc->sc_nexttx) {
		txd = sc->sc_txd[i];
		dmp = sc->sc_txm[i];

		bus_dmamap_sync(sc->sc_dmat, dmp, 0,
		    dmp->dm_mapsize,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);

		if (txd->txd_control1 & TXD_CTL1_OWN) {
			bus_dmamap_sync(sc->sc_dmat, dmp, 0,
			    dmp->dm_mapsize, BUS_DMASYNC_PREREAD);
			break;
		}
		bus_dmamap_unload(sc->sc_dmat, dmp);
		m_freem(sc->sc_txb[i]);
		sc->sc_lasttx = i;
	}

	if (sc->sc_lasttx != lasttx)
		ifq_clr_oactive(&ifp->if_snd);

	/* Try to get more packets on the wire */
	xge_start(ifp);

	/* clear interrupt bits */
	if ((val = PIF_RCSR(RX_TRAFFIC_INT)))
		PIF_WCSR(RX_TRAFFIC_INT, val);

	for (;;) {
		struct rxdesc *rxd;
		struct mbuf *m;

		XGE_RXSYNC(sc->sc_nextrx,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);

		rxd = XGE_RXD(sc->sc_nextrx);
		if (rxd->rxd_control1 & RXD_CTL1_OWN) {
			XGE_RXSYNC(sc->sc_nextrx, BUS_DMASYNC_PREREAD);
			break;
		}

		/* got a packet */
		m = sc->sc_rxb[sc->sc_nextrx];
#if RX_MODE == RX_MODE_1
		plen = m->m_len = RXD_CTL2_BUF0SIZ(rxd->rxd_control2);
#elif RX_MODE == RX_MODE_3
#error Fix rxmodes in xge_intr
#elif RX_MODE == RX_MODE_5
		plen = m->m_len = RXD_CTL2_BUF0SIZ(rxd->rxd_control2);
		plen += m->m_next->m_len = RXD_CTL2_BUF1SIZ(rxd->rxd_control2);
		plen += m->m_next->m_next->m_len =
		    RXD_CTL2_BUF2SIZ(rxd->rxd_control2);
		plen += m->m_next->m_next->m_next->m_len =
		    RXD_CTL3_BUF3SIZ(rxd->rxd_control3);
		plen += m->m_next->m_next->m_next->m_next->m_len =
		    RXD_CTL3_BUF4SIZ(rxd->rxd_control3);
#endif
		m->m_pkthdr.len = plen;

		val = rxd->rxd_control1;

		if (xge_add_rxbuf(sc, sc->sc_nextrx)) {
			/* Failed, recycle this mbuf */
#if RX_MODE == RX_MODE_1
			rxd->rxd_control2 = RXD_MKCTL2(MCLBYTES, 0, 0);
			rxd->rxd_control1 = RXD_CTL1_OWN;
#elif RX_MODE == RX_MODE_3
#elif RX_MODE == RX_MODE_5
#endif
			XGE_RXSYNC(sc->sc_nextrx,
			    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
			ifp->if_ierrors++;
			break;
		}

		if (RXD_CTL1_PROTOS(val) & RXD_CTL1_P_IPv4)
			m->m_pkthdr.csum_flags |= M_IPV4_CSUM_IN_OK;
		if (RXD_CTL1_PROTOS(val) & RXD_CTL1_P_TCP)
			m->m_pkthdr.csum_flags |= M_TCP_CSUM_IN_OK;
		if (RXD_CTL1_PROTOS(val) & RXD_CTL1_P_UDP)
			m->m_pkthdr.csum_flags |= M_UDP_CSUM_IN_OK;

#if NVLAN > 0
		if (RXD_CTL1_PROTOS(val) & RXD_CTL1_P_VLAN) {
			m->m_pkthdr.ether_vtag =
			    RXD_CTL2_VLANTAG(rxd->rxd_control2);
			m->m_flags |= M_VLANTAG;
		}
#endif

		ml_enqueue(&ml, m);

		if (++sc->sc_nextrx == NRXREAL)
			sc->sc_nextrx = 0;
	}

	if_input(ifp, &ml);

	return (1);
}

int
xge_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct xge_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *) data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			xge_init(ifp);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING &&
			    (ifp->if_flags ^ sc->xge_if_flags) &
			     IFF_PROMISC) {
				xge_setpromisc(sc);
			} else {
				if (!(ifp->if_flags & IFF_RUNNING))
					xge_init(ifp);
			}
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				xge_stop(ifp, 1);
		}
		sc->xge_if_flags = ifp->if_flags;
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->xena_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			xge_setmulti(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

void
xge_setmulti(struct xge_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct arpcom *ac = &sc->sc_arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	int i, numaddr = 1; /* first slot used for card unicast address */
	uint64_t val;

	if (ac->ac_multirangecnt > 0)
		goto allmulti;

	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (numaddr == MAX_MCAST_ADDR)
			goto allmulti;
		for (val = 0, i = 0; i < ETHER_ADDR_LEN; i++) {
			val <<= 8;
			val |= enm->enm_addrlo[i];
		}
		PIF_WCSR(RMAC_ADDR_DATA0_MEM, val << 16);
		PIF_WCSR(RMAC_ADDR_DATA1_MEM, 0xFFFFFFFFFFFFFFFFULL);
		PIF_WCSR(RMAC_ADDR_CMD_MEM, RMAC_ADDR_CMD_MEM_WE|
		    RMAC_ADDR_CMD_MEM_STR|RMAC_ADDR_CMD_MEM_OFF(numaddr));
		while (PIF_RCSR(RMAC_ADDR_CMD_MEM) & RMAC_ADDR_CMD_MEM_STR)
			;
		numaddr++;
		ETHER_NEXT_MULTI(step, enm);
	}
	/* set the remaining entries to the broadcast address */
	for (i = numaddr; i < MAX_MCAST_ADDR; i++) {
		PIF_WCSR(RMAC_ADDR_DATA0_MEM, 0xffffffffffff0000ULL);
		PIF_WCSR(RMAC_ADDR_DATA1_MEM, 0xFFFFFFFFFFFFFFFFULL);
		PIF_WCSR(RMAC_ADDR_CMD_MEM, RMAC_ADDR_CMD_MEM_WE|
		    RMAC_ADDR_CMD_MEM_STR|RMAC_ADDR_CMD_MEM_OFF(i));
		while (PIF_RCSR(RMAC_ADDR_CMD_MEM) & RMAC_ADDR_CMD_MEM_STR)
			;
	}
	ifp->if_flags &= ~IFF_ALLMULTI;
	return;

allmulti:
	/* Just receive everything with the multicast bit set */
	ifp->if_flags |= IFF_ALLMULTI;
	PIF_WCSR(RMAC_ADDR_DATA0_MEM, 0x8000000000000000ULL);
	PIF_WCSR(RMAC_ADDR_DATA1_MEM, 0xF000000000000000ULL);
	PIF_WCSR(RMAC_ADDR_CMD_MEM, RMAC_ADDR_CMD_MEM_WE|
	    RMAC_ADDR_CMD_MEM_STR|RMAC_ADDR_CMD_MEM_OFF(1));
	while (PIF_RCSR(RMAC_ADDR_CMD_MEM) & RMAC_ADDR_CMD_MEM_STR)
		;
}

void
xge_setpromisc(struct xge_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	uint64_t val;

	val = PIF_RCSR(MAC_CFG);

	if (ifp->if_flags & IFF_PROMISC)
		val |= RMAC_PROM_EN;
	else
		val &= ~RMAC_PROM_EN;

	PIF_WCSR(MAC_CFG, val);
}

void
xge_start(struct ifnet *ifp)
{
	struct xge_softc *sc = ifp->if_softc;
	struct txd *txd = NULL; /* XXX - gcc */
	bus_dmamap_t dmp;
	struct	mbuf *m;
	uint64_t par, lcr;
	int nexttx = 0, ntxd, error, i;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	par = lcr = 0;
	for (;;) {
		m = ifq_deq_begin(&ifp->if_snd);
		if (m == NULL)
			break;	/* out of packets */

		if (sc->sc_nexttx == sc->sc_lasttx) {
			ifq_deq_rollback(&ifp->if_snd, m);
			break;	/* No more space */
		}

		nexttx = sc->sc_nexttx;
		dmp = sc->sc_txm[nexttx];

		if ((error = bus_dmamap_load_mbuf(sc->sc_dmat, dmp, m,
		    BUS_DMA_WRITE|BUS_DMA_NOWAIT)) != 0) {
			ifq_deq_rollback(&ifp->if_snd, m);
			printf("%s: bus_dmamap_load_mbuf error %d\n",
			    XNAME, error);
			break;
		}
		ifq_deq_commit(&ifp->if_snd, m);

		bus_dmamap_sync(sc->sc_dmat, dmp, 0, dmp->dm_mapsize,
		    BUS_DMASYNC_PREWRITE);

		txd = sc->sc_txd[nexttx];
		sc->sc_txb[nexttx] = m;
		for (i = 0; i < dmp->dm_nsegs; i++) {
			if (dmp->dm_segs[i].ds_len == 0)
				continue;
			txd->txd_control1 = dmp->dm_segs[i].ds_len;
			txd->txd_control2 = 0;
			txd->txd_bufaddr = dmp->dm_segs[i].ds_addr;
			txd++;
		}
		ntxd = txd - sc->sc_txd[nexttx] - 1;
		txd = sc->sc_txd[nexttx];
		txd->txd_control1 |= TXD_CTL1_OWN|TXD_CTL1_GCF;
		txd->txd_control2 = TXD_CTL2_UTIL;

#if NVLAN > 0
		if (m->m_flags & M_VLANTAG) {
			txd->txd_control2 |= TXD_CTL2_VLANE;
			txd->txd_control2 |=
			    TXD_CTL2_VLANT(m->m_pkthdr.ether_vtag);
		}
#endif

		if (m->m_pkthdr.csum_flags & M_IPV4_CSUM_OUT)
			txd->txd_control2 |= TXD_CTL2_CIPv4;
		if (m->m_pkthdr.csum_flags & M_TCP_CSUM_OUT)
			txd->txd_control2 |= TXD_CTL2_CTCP;
		if (m->m_pkthdr.csum_flags & M_UDP_CSUM_OUT)
			txd->txd_control2 |= TXD_CTL2_CUDP;

		txd[ntxd].txd_control1 |= TXD_CTL1_GCL;

		bus_dmamap_sync(sc->sc_dmat, dmp, 0, dmp->dm_mapsize,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

		par = sc->sc_txdp[nexttx];
		lcr = TXDL_NUMTXD(ntxd) | TXDL_LGC_FIRST | TXDL_LGC_LAST;
		TXP_WCSR(TXDL_PAR, par);
		TXP_WCSR(TXDL_LCR, lcr);

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif /* NBPFILTER > 0 */

		sc->sc_nexttx = NEXTTX(nexttx);
	}
}

/*
 * Allocate DMA memory for transmit descriptor fragments.
 * Only one map is used for all descriptors.
 */
int
xge_alloc_txmem(struct xge_softc *sc)
{
	struct txd *txp;
	bus_dma_segment_t seg;
	bus_addr_t txdp;
	caddr_t kva;
	int i, rseg, state;

#define TXMAPSZ (NTXDESCS*NTXFRAGS*sizeof(struct txd))
	state = 0;
	if (bus_dmamem_alloc(sc->sc_dmat, TXMAPSZ, PAGE_SIZE, 0,
	    &seg, 1, &rseg, BUS_DMA_NOWAIT))
		goto err;
	state++;
	if (bus_dmamem_map(sc->sc_dmat, &seg, rseg, TXMAPSZ, &kva,
	    BUS_DMA_NOWAIT))
		goto err;

	state++;
	if (bus_dmamap_create(sc->sc_dmat, TXMAPSZ, 1, TXMAPSZ, 0,
	    BUS_DMA_NOWAIT, &sc->sc_txmap))
		goto err;
	state++;
	if (bus_dmamap_load(sc->sc_dmat, sc->sc_txmap,
	    kva, TXMAPSZ, NULL, BUS_DMA_NOWAIT))
		goto err;

	/* setup transmit array pointers */
	txp = (struct txd *)kva;
	txdp = seg.ds_addr;
	for (i = 0; i < NTXDESCS; i++) {
		sc->sc_txd[i] = txp;
		sc->sc_txdp[i] = txdp;
		txp += NTXFRAGS;
		txdp += (NTXFRAGS * sizeof(struct txd));
	}

	return (0);

err:
	if (state > 2)
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_txmap);
	if (state > 1)
		bus_dmamem_unmap(sc->sc_dmat, kva, TXMAPSZ);
	if (state > 0)
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
	return (ENOBUFS);
}

/*
 * Allocate DMA memory for receive descriptor,
 * only one map is used for all descriptors.
 * link receive descriptor pages together.
 */
int
xge_alloc_rxmem(struct xge_softc *sc)
{
	struct rxd_4k *rxpp;
	bus_dma_segment_t seg;
	caddr_t kva;
	int i, rseg, state;

	/* sanity check */
	if (sizeof(struct rxd_4k) != XGE_PAGE) {
		printf("bad compiler struct alignment, %d != %d\n",
		    (int)sizeof(struct rxd_4k), XGE_PAGE);
		return (EINVAL);
	}

	state = 0;
	if (bus_dmamem_alloc(sc->sc_dmat, RXMAPSZ, PAGE_SIZE, 0,
	    &seg, 1, &rseg, BUS_DMA_NOWAIT))
		goto err;
	state++;
	if (bus_dmamem_map(sc->sc_dmat, &seg, rseg, RXMAPSZ, &kva,
	    BUS_DMA_NOWAIT))
		goto err;

	state++;
	if (bus_dmamap_create(sc->sc_dmat, RXMAPSZ, 1, RXMAPSZ, 0,
	    BUS_DMA_NOWAIT, &sc->sc_rxmap))
		goto err;
	state++;
	if (bus_dmamap_load(sc->sc_dmat, sc->sc_rxmap,
	    kva, RXMAPSZ, NULL, BUS_DMA_NOWAIT))
		goto err;

	/* setup receive page link pointers */
	for (rxpp = (struct rxd_4k *)kva, i = 0; i < NRXPAGES; i++, rxpp++) {
		sc->sc_rxd_4k[i] = rxpp;
		rxpp->r4_next = (uint64_t)sc->sc_rxmap->dm_segs[0].ds_addr +
		    (i*sizeof(struct rxd_4k)) + sizeof(struct rxd_4k);
	}
	sc->sc_rxd_4k[NRXPAGES-1]->r4_next =
	    (uint64_t)sc->sc_rxmap->dm_segs[0].ds_addr;

	return (0);

err:
	if (state > 2)
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_rxmap);
	if (state > 1)
		bus_dmamem_unmap(sc->sc_dmat, kva, RXMAPSZ);
	if (state > 0)
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
	return (ENOBUFS);
}


/*
 * Add a new mbuf chain to descriptor id.
 */
int
xge_add_rxbuf(struct xge_softc *sc, int id)
{
	struct rxdesc *rxd;
	struct mbuf *m[5];
	int page, desc, error;
#if RX_MODE == RX_MODE_5
	int i;
#endif

	page = id/NDESC_BUFMODE;
	desc = id%NDESC_BUFMODE;

	rxd = &sc->sc_rxd_4k[page]->r4_rxd[desc];

	/*
	 * Allocate mbufs.
	 * Currently five mbufs and two clusters are used,
	 * the hardware will put (ethernet, ip, tcp/udp) headers in
	 * their own buffer and the clusters are only used for data.
	 */
#if RX_MODE == RX_MODE_1
	MGETHDR(m[0], M_DONTWAIT, MT_DATA);
	if (m[0] == NULL)
		return (ENOBUFS);
	MCLGETI(m[0], M_DONTWAIT, NULL, XGE_MAX_FRAMELEN + ETHER_ALIGN);
	if ((m[0]->m_flags & M_EXT) == 0) {
		m_freem(m[0]);
		return (ENOBUFS);
	}
	m[0]->m_len = m[0]->m_pkthdr.len = XGE_MAX_FRAMELEN + ETHER_ALIGN;
#elif RX_MODE == RX_MODE_3
#error missing rxmode 3.
#elif RX_MODE == RX_MODE_5
	MGETHDR(m[0], M_DONTWAIT, MT_DATA);
	for (i = 1; i < 5; i++) {
		MGET(m[i], M_DONTWAIT, MT_DATA);
	}
	if (m[3])
		MCLGET(m[3], M_DONTWAIT);
	if (m[4])
		MCLGET(m[4], M_DONTWAIT);
	if (!m[0] || !m[1] || !m[2] || !m[3] || !m[4] ||
	    ((m[3]->m_flags & M_EXT) == 0) || ((m[4]->m_flags & M_EXT) == 0)) {
		/* Out of something */
		for (i = 0; i < 5; i++)
			m_free(m[i]);
		return (ENOBUFS);
	}
	/* Link'em together */
	m[0]->m_next = m[1];
	m[1]->m_next = m[2];
	m[2]->m_next = m[3];
	m[3]->m_next = m[4];
#else
#error bad mode RX_MODE
#endif

	if (sc->sc_rxb[id])
		bus_dmamap_unload(sc->sc_dmat, sc->sc_rxm[id]);
	sc->sc_rxb[id] = m[0];

	m_adj(m[0], ETHER_ALIGN);

	error = bus_dmamap_load_mbuf(sc->sc_dmat, sc->sc_rxm[id], m[0],
	    BUS_DMA_READ|BUS_DMA_NOWAIT);
	if (error)
		return (error);
	bus_dmamap_sync(sc->sc_dmat, sc->sc_rxm[id], 0,
	    sc->sc_rxm[id]->dm_mapsize, BUS_DMASYNC_PREREAD);

#if RX_MODE == RX_MODE_1
	rxd->rxd_control2 = RXD_MKCTL2(m[0]->m_len, 0, 0);
	rxd->rxd_buf0 = (uint64_t)sc->sc_rxm[id]->dm_segs[0].ds_addr;
	rxd->rxd_control1 = RXD_CTL1_OWN;
#elif RX_MODE == RX_MODE_3
#elif RX_MODE == RX_MODE_5
	rxd->rxd_control3 = RXD_MKCTL3(0, m[3]->m_len, m[4]->m_len);
	rxd->rxd_control2 = RXD_MKCTL2(m[0]->m_len, m[1]->m_len, m[2]->m_len);
	rxd->rxd_buf0 = (uint64_t)sc->sc_rxm[id]->dm_segs[0].ds_addr;
	rxd->rxd_buf1 = (uint64_t)sc->sc_rxm[id]->dm_segs[1].ds_addr;
	rxd->rxd_buf2 = (uint64_t)sc->sc_rxm[id]->dm_segs[2].ds_addr;
	rxd->rxd_buf3 = (uint64_t)sc->sc_rxm[id]->dm_segs[3].ds_addr;
	rxd->rxd_buf4 = (uint64_t)sc->sc_rxm[id]->dm_segs[4].ds_addr;
	rxd->rxd_control1 = RXD_CTL1_OWN;
#endif

	XGE_RXSYNC(id, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	return (0);
}

/*
 * This magic comes from the FreeBSD driver.
 */
int
xge_setup_xgxs_xena(struct xge_softc *sc)
{
	int i;

	for (i = 0; i < nitems(xge_xena_dtx_cfg); i++) {
		PIF_WCSR(DTX_CONTROL, xge_xena_dtx_cfg[i]);
		DELAY(100);
	}

	return (0);
}

int
xge_setup_xgxs_herc(struct xge_softc *sc)
{
	int i;

	for (i = 0; i < nitems(xge_herc_dtx_cfg); i++) {
		PIF_WCSR(DTX_CONTROL, xge_herc_dtx_cfg[i]);
		DELAY(100);
	}

	return (0);
}
@


1.74
log
@m_free() and m_freem() test for NULL.  Simplify callers which had their own
NULL tests.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.73 2016/05/16 04:34:25 dlg Exp $	*/
a903 1
		ifp->if_opackets++;
@


1.73
log
@enable reception and transmission of jumbo frames.

xge can go up to 9622 bytes in a frame. support for rx ring moderation
is coming.

from marisa emerson
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.72 2016/04/28 00:11:56 dlg Exp $	*/
d1363 1
a1363 2
			if (m[i] != NULL)
				m_free(m[i]);
@


1.72
log
@correctly set up byteswapping so this chip works on big endian archs

this, plus the m_adj fix before, makes xge work on sparc64

from marisa emerson
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.71 2016/04/27 13:02:39 dlg Exp $	*/
d559 2
a560 1
		    NTXFRAGS, MCLBYTES, 0, BUS_DMA_NOWAIT, &sc->sc_txm[i])) {
d581 2
a582 1
		    NRXFRAGS, MCLBYTES, 0, BUS_DMA_NOWAIT, &sc->sc_rxm[i])) {
a683 1
#ifdef XGE_JUMBO
a684 1
#endif
a799 1
#ifdef XGE_JUMBO
a800 3
#else
	PIF_WCSR(RMAC_MAX_PYLD_LEN, RMAC_PYLD_LEN(ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN));
#endif
d1342 1
a1342 1
	MCLGET(m[0], M_DONTWAIT);
d1347 1
a1347 1
	m[0]->m_len = m[0]->m_pkthdr.len = m[0]->m_ext.ext_size;
@


1.71
log
@whitespace fixes, no functional change

largely done by marisa emerson
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.70 2016/04/27 12:56:20 dlg Exp $	*/
d241 3
d249 8
a256 2
	bus_space_write_4(sc->sc_st, sc->sc_sh, csr, lval);
	bus_space_write_4(sc->sc_st, sc->sc_sh, csr+4, hval);
d262 5
a266 1
	uint64_t val, val2;
d268 3
a270 2
	val = bus_space_read_4(sc->sc_st, sc->sc_sh, csr);
	val2 = bus_space_read_4(sc->sc_st, sc->sc_sh, csr+4);
d272 4
d282 3
d290 8
a297 2
	bus_space_write_4(sc->sc_txt, sc->sc_txh, csr, lval);
	bus_space_write_4(sc->sc_txt, sc->sc_txh, csr+4, hval);
a299 1

d303 6
d317 5
a321 1
	bus_space_write_4(sc->sc_st, sc->sc_sh, csr, lval);
d325 6
a330 2

	bus_space_write_4(sc->sc_st, sc->sc_sh, csr+4, hval);
d411 1
a419 1

d421 1
a421 1
		printf(": failed configuring endian, %llx != %llx!\n",
a422 1
		return;
d425 6
d465 8
a472 1
			printf(": failed configuring endian2, %llx != %llx!\n",
a817 1
	PIF_WCSR(GENERAL_INT_MASK, 0);
d822 1
d824 1
@


1.70
log
@align rx buffers so ip packets will be aligned correctly for the stack

this matters more for strict alignment archs than the ones xge
currently runs on.

from marisa emerson
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.69 2016/04/27 12:54:20 dlg Exp $	*/
d161 1
a161 1
 
d246 1
a246 1
	bus_space_write_4(sc->sc_st, sc->sc_sh, csr, lval); 
d269 1
a269 1
	bus_space_write_4(sc->sc_txt, sc->sc_txh, csr, lval); 
d389 1
a389 1
	 */ 
d393 1
a393 1
		 * Resolve it by writing some magics to GPIO_CONTROL and 
d636 1
a636 1
			       IFCAP_CSUM_TCPv4 | IFCAP_CSUM_UDPv4;
d675 1
a675 1
	if ((reg & (RMAC_REMOTE_FAULT|RMAC_LOCAL_FAULT)) == 0)	
d704 1
a704 1
int 
d828 1
a828 1
			
d942 1
a942 1
int 
d968 1
a968 1
                } else {
d1063 1
a1063 1
void 
d1249 1
a1249 1
	sc->sc_rxd_4k[NRXPAGES-1]->r4_next = 
d1310 1
a1310 1
	if (!m[0] || !m[1] || !m[2] || !m[3] || !m[4] || 
@


1.69
log
@tweak some command list handling

prefix the arrays with xge_, make them const, and use nitems to
iterate over them. move xge_setup_xgxs_xena to iterating over a
list of commands instead of doing a long series of register writes
in code.

from marisa emerson, who tested on both xena and herc boards
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.68 2016/04/13 10:34:32 mpi Exp $	*/
d1330 2
@


1.68
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.67 2015/11/25 03:09:59 dlg Exp $	*/
d123 1
a123 1
static uint64_t fix_mac[] = {
d144 1
a144 2
#define END_SIGN 0x0
static uint64_t herc_dtx_cfg[] = {
d156 8
d165 3
a167 2
	END_SIGN
};
d396 2
a397 2
		for (i = 0; i < nitems(fix_mac); i++) {
			PIF_WCSR(GPIO_CONTROL, fix_mac[i]);
d1364 1
a1364 1
	/* The magic numbers are described in the users guide */
d1366 3
a1368 64
	/* Writing to MDIO 0x8000 (Global Config 0) */
	PIF_WCSR(DTX_CONTROL, 0x8000051500000000ULL); DELAY(50);
	PIF_WCSR(DTX_CONTROL, 0x80000515000000E0ULL); DELAY(50);
	PIF_WCSR(DTX_CONTROL, 0x80000515D93500E4ULL); DELAY(50);

	/* Writing to MDIO 0x8000 (Global Config 1) */
	PIF_WCSR(DTX_CONTROL, 0x8001051500000000ULL); DELAY(50);
	PIF_WCSR(DTX_CONTROL, 0x80010515000000e0ULL); DELAY(50);
	PIF_WCSR(DTX_CONTROL, 0x80010515001e00e4ULL); DELAY(50);

	/* Reset the Gigablaze */
	PIF_WCSR(DTX_CONTROL, 0x8002051500000000ULL); DELAY(50);
	PIF_WCSR(DTX_CONTROL, 0x80020515000000E0ULL); DELAY(50);
	PIF_WCSR(DTX_CONTROL, 0x80020515F21000E4ULL); DELAY(50);

	/* read the pole settings */
	PIF_WCSR(DTX_CONTROL, 0x8000051500000000ULL); DELAY(50);
	PIF_WCSR(DTX_CONTROL, 0x80000515000000e0ULL); DELAY(50);
	PIF_WCSR(DTX_CONTROL, 0x80000515000000ecULL); DELAY(50);

	PIF_WCSR(DTX_CONTROL, 0x8001051500000000ULL); DELAY(50);
	PIF_WCSR(DTX_CONTROL, 0x80010515000000e0ULL); DELAY(50);
	PIF_WCSR(DTX_CONTROL, 0x80010515000000ecULL); DELAY(50);

	PIF_WCSR(DTX_CONTROL, 0x8002051500000000ULL); DELAY(50);
	PIF_WCSR(DTX_CONTROL, 0x80020515000000e0ULL); DELAY(50);
	PIF_WCSR(DTX_CONTROL, 0x80020515000000ecULL); DELAY(50);

	/* Workaround for TX Lane XAUI initialization error.
	   Read Xpak PHY register 24 for XAUI lane status */
	PIF_WCSR(DTX_CONTROL, 0x0018040000000000ULL); DELAY(50);
	PIF_WCSR(DTX_CONTROL, 0x00180400000000e0ULL); DELAY(50);
	PIF_WCSR(DTX_CONTROL, 0x00180400000000ecULL); DELAY(50);

	/* 
	 * Reading the MDIO control with value 0x1804001c0F001c
	 * means the TxLanes were already in sync
	 * Reading the MDIO control with value 0x1804000c0x001c
	 * means some TxLanes are not in sync where x is a 4-bit
	 * value representing each lanes
	 */
#if 0
	val = PIF_RCSR(MDIO_CONTROL);
	if (val != 0x1804001c0F001cULL) {
		printf("%s: MDIO_CONTROL: %llx != %llx\n", 
		    XNAME, val, 0x1804001c0F001cULL);
		return (1);
	}
#endif

	/* Set and remove the DTE XS INTLoopBackN */
	PIF_WCSR(DTX_CONTROL, 0x0000051500000000ULL); DELAY(50);
	PIF_WCSR(DTX_CONTROL, 0x00000515604000e0ULL); DELAY(50);
	PIF_WCSR(DTX_CONTROL, 0x00000515604000e4ULL); DELAY(50);
	PIF_WCSR(DTX_CONTROL, 0x00000515204000e4ULL); DELAY(50);
	PIF_WCSR(DTX_CONTROL, 0x00000515204000ecULL); DELAY(50);

#if 0
	/* Reading the DTX control register Should be 0x5152040001c */
	val = PIF_RCSR(DTX_CONTROL);
	if (val != 0x5152040001cULL) {
		printf("%s: DTX_CONTROL: %llx != %llx\n", 
		    XNAME, val, 0x5152040001cULL);
		return (1);
a1369 5
#endif

	PIF_WCSR(MDIO_CONTROL, 0x0018040000000000ULL); DELAY(50);
	PIF_WCSR(MDIO_CONTROL, 0x00180400000000e0ULL); DELAY(50);
	PIF_WCSR(MDIO_CONTROL, 0x00180400000000ecULL); DELAY(50);
a1370 9
#if 0
	/* Reading the MIOD control should be 0x1804001c0f001c */
	val = PIF_RCSR(MDIO_CONTROL);
	if (val != 0x1804001c0f001cULL) {
		printf("%s: MDIO_CONTROL2: %llx != %llx\n",
		    XNAME, val, 0x1804001c0f001cULL);
		return (1);
	}
#endif
d1377 1
a1377 1
	int dtx_cnt = 0;
d1379 2
a1380 2
	while (herc_dtx_cfg[dtx_cnt] != END_SIGN) {
		PIF_WCSR(DTX_CONTROL, herc_dtx_cfg[dtx_cnt]);
a1381 1
		dtx_cnt++;
@


1.67
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.66 2015/11/24 17:11:40 mpi Exp $	*/
a625 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.66
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.65 2015/11/20 03:35:23 dlg Exp $	*/
d772 1
a772 1
	ifp->if_flags &= ~IFF_OACTIVE;
d785 2
a786 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d853 1
a853 1
		ifp->if_flags &= ~IFF_OACTIVE;
d1066 1
a1066 1
	if ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)
@


1.65
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.64 2015/11/14 17:54:57 mpi Exp $	*/
a55 1
#include <net/if_dl.h>
@


1.64
log
@Do not include <net/if_vlan_var.h> when it's not necessary.

Because of the VLAN hacks in mpw(4) this file still contains the definition
of "struct ifvlan" which depends on <sys/refcnt.h> which in turns pull
<sys/atomic.h>...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.63 2015/10/25 13:04:28 mpi Exp $	*/
d1071 1
a1071 1
		IFQ_POLL(&ifp->if_snd, m);
d1075 2
a1076 1
		if (sc->sc_nexttx == sc->sc_lasttx)
d1078 1
d1085 1
d1090 1
a1090 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.63
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.62 2015/06/24 09:40:54 mpi Exp $	*/
a60 5

#if NVLAN > 0
#include <net/if_types.h>
#include <net/if_vlan_var.h>
#endif
@


1.62
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.61 2015/04/30 07:51:07 mpi Exp $	*/
a943 1
	struct ifaddr *ifa = (struct ifaddr *) data;
a953 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_arpcom, ifa);
@


1.61
log
@Convert moar drivers to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.60 2015/03/14 03:38:48 jsg Exp $	*/
a912 2

		ifp->if_ipackets++;
@


1.60
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.59 2014/12/22 02:28:52 tedu Exp $	*/
d807 1
a895 1
		m->m_pkthdr.rcvif = ifp;
d931 1
a931 6
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif /* NBPFILTER > 0 */

		ether_input_mbuf(ifp, m);
d936 2
@


1.59
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.58 2014/12/19 22:44:58 guenther Exp $	*/
a73 1
#include <dev/mii/mii.h>
@


1.58
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.57 2014/07/22 13:12:11 mpi Exp $	*/
a58 1
#ifdef INET
a60 1
#endif
a960 1
#ifdef INET
a962 1
#endif /* INET */
@


1.57
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.56 2013/11/26 09:50:33 mpi Exp $	*/
d53 1
a74 1
#include <machine/endian.h>
@


1.56
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.55 2013/08/07 01:06:39 bluhm Exp $	*/
a59 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a60 2
#include <netinet/tcp.h>
#include <netinet/udp.h>
@


1.55
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.54 2011/04/05 18:01:21 henning Exp $	*/
d1019 3
a1023 4
		if (memcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			/* Skip ranges */
			goto allmulti;
		}
@


1.54
log
@mechanic rename M_{TCP|UDP}V4_CSUM_OUT -> M_{TCP|UDP}_CSUM_OUT
ok claudio krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.53 2011/04/03 15:36:03 jasper Exp $	*/
a60 1
#include <netinet/in_var.h>
@


1.53
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.52 2010/04/08 00:23:53 tedu Exp $	*/
d1141 1
a1141 1
		if (m->m_pkthdr.csum_flags & M_TCPV4_CSUM_OUT)
d1143 1
a1143 1
		if (m->m_pkthdr.csum_flags & M_UDPV4_CSUM_OUT)
@


1.52
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.51 2009/08/13 14:24:47 jasper Exp $	*/
d332 1
a332 1
	    sizeof(xge_devices)/sizeof(xge_devices[0])));
d402 1
a402 1
		for (i = 0; i < sizeof(fix_mac)/sizeof(fix_mac[0]); i++) {
@


1.51
log
@- consistify cfdriver for the ethernet drivers (0 -> NULL)

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.50 2009/08/10 17:29:19 deraadt Exp $	*/
a88 1
#include <sys/proc.h>
@


1.50
log
@xge_shutdown is not needed now that interface is stopped, since
xge_shutdown was just calling stop again
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.49 2008/11/28 02:44:18 brad Exp $	*/
d305 1
a305 1
	0, "xge", DV_IFNET
@


1.49
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.48 2008/11/09 15:08:26 naddy Exp $	*/
a181 1
	void			*sc_shutdownhook;
a224 1
void xge_shutdown(void *);
a655 2
	sc->sc_shutdownhook = shutdownhook_establish(xge_shutdown, sc);

a807 9
}

void
xge_shutdown(void *pv)
{
	struct xge_softc *sc = (struct xge_softc *)pv;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	xge_stop(ifp, 1);
@


1.48
log
@Introduce bpf_mtap_ether(), which for the benefit of bpf listeners
creates the VLAN encapsulation from the tag stored in the mbuf
header.  Idea from FreeBSD, input from claudio@@ and canacar@@.

Switch all hardware VLAN enabled drivers to the new function.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.47 2008/10/21 00:26:40 brad Exp $	*/
d971 1
a972 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d987 1
a987 6
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ifp->if_hardmtu)
			error = EINVAL;
		else if (ifp->if_mtu != ifr->ifr_mtu)
			ifp->if_mtu = ifr->ifr_mtu;
		break;
d1004 1
a1004 12
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI)
			? ether_addmulti(ifr, &sc->sc_arpcom)
			: ether_delmulti(ifr, &sc->sc_arpcom);

                if (error == ENETRESET) {
                        if (ifp->if_flags & IFF_RUNNING)
				xge_setmulti(sc);
			error = 0;
		}
		break;
d1009 1
d1012 6
@


1.47
log
@Re-add support for RX VLAN tag stripping.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.46 2008/10/16 19:18:03 naddy Exp $	*/
d955 1
a955 1
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
d1181 1
a1181 1
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
@


1.46
log
@Switch the existing TX VLAN hardware support over to having the
tag in the header.  Convert TX tagging in the drivers.

Help and ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.45 2008/10/02 20:21:14 brad Exp $	*/
d752 6
a757 4
	/* disable VLAN tag stripping */
	val = PIF_RCSR(RX_PA_CFG);
	val &= ~STRIP_VLAN_TAG;
	PIF_WCSR(RX_PA_CFG, val);
d944 8
@


1.45
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.44 2008/09/24 19:12:59 chl Exp $	*/
a1101 3
#if NVLAN > 0
	struct ifvlan *ifv = NULL;
#endif
d1145 1
a1145 4
		if ((m->m_flags & (M_PROTO1|M_PKTHDR)) == (M_PROTO1|M_PKTHDR) &&
		    m->m_pkthdr.rcvif != NULL) {
			ifv = m->m_pkthdr.rcvif->if_softc;

d1147 2
a1148 1
			txd->txd_control2 |= TXD_CTL2_VLANT(ifv->ifv_tag);
@


1.44
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok henning@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.43 2007/09/19 03:50:25 brad Exp $	*/
a966 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

d1016 1
a1016 1
		error = ENOTTY;
a1019 1

@


1.43
log
@Use the proper baudrate for 10Gb hw now that it can fit into the buadrate
field.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.42 2007/05/28 23:39:07 ckuethe Exp $	*/
d1224 1
a1224 1
	for (txp = (struct txd *)kva, i = 0; i < NTXDESCS; i++) {
@


1.42
log
@fix C++ style comment
from brad, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.41 2007/05/26 18:40:28 dlg Exp $	*/
d634 1
a634 1
	ifp->if_baudrate = 1000000000;
@


1.41
log
@wrap the debug macro in do { } while (0)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.40 2007/05/26 18:38:26 dlg Exp $	*/
d446 1
a446 1
		delay(1000*1000);	//wait for 1 sec
@


1.40
log
@reformat the softc to make it look like everything else we have.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.39 2007/05/26 18:29:11 dlg Exp $	*/
d212 2
a213 2
#define DPRINTF(x)	if (xgedebug) printf x
#define DPRINTFN(n,x)	if (xgedebug >= (n)) printf x
@


1.39
log
@get rid of #define sc_if sc_arpcom.ac_if
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.38 2007/05/26 18:25:11 dlg Exp $	*/
d177 12
a188 11
	struct device sc_dev;
	struct arpcom sc_arpcom;
	bus_dma_tag_t sc_dmat;
	bus_space_tag_t sc_st;
	bus_space_handle_t sc_sh;
	bus_space_tag_t sc_txt;
	bus_space_handle_t sc_txh;
	void *sc_ih;
	int xge_type;			/* chip type */
	int xge_if_flags;
	void *sc_shutdownhook;
d190 4
a193 2
	struct ifmedia xena_media;
	pcireg_t sc_pciregs[16];
d196 6
a201 6
	struct txd *sc_txd[NTXDESCS];	/* transmit frags array */
	bus_addr_t sc_txdp[NTXDESCS];	/* bus address of transmit frags */
	bus_dmamap_t sc_txm[NTXDESCS];	/* transmit frags map */
	struct mbuf *sc_txb[NTXDESCS];	/* transmit mbuf pointer */
	int sc_nexttx, sc_lasttx;
	bus_dmamap_t sc_txmap;		/* transmit descriptor map */
d204 5
a208 5
	bus_dmamap_t sc_rxmap;		/* receive descriptor map */
	struct rxd_4k *sc_rxd_4k[NRXPAGES]; /* receive desc pages */
	bus_dmamap_t sc_rxm[NRXREAL];	/* receive buffer map */
	struct mbuf *sc_rxb[NRXREAL];	/* mbufs on receive descriptors */
	int sc_nextrx;			/* next descriptor to check */
@


1.38
log
@this isnt netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.37 2007/02/27 22:39:39 kettenis Exp $	*/
a178 1
#define sc_if sc_arpcom.ac_if
d823 1
a823 1
	struct ifnet *ifp = &sc->sc_if;
@


1.37
log
@Enable HW Tx checksum offloading and VLAN tag insertion.  From brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.36 2007/02/27 22:18:53 kettenis Exp $	*/
a40 5

#include <sys/cdefs.h>
#if 0
__KERNEL_RCSID(0, "$NetBSD: if_xge.c,v 1.1 2005/09/09 10:30:27 ragge Exp $");
#endif
@


1.36
log
@Don't strip off VLAN tags.  From brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.35 2006/10/24 20:14:43 brad Exp $	*/
d648 6
a653 1
	ifp->if_capabilities = IFCAP_VLAN_MTU;
d1111 3
d1156 11
a1166 2
#ifdef XGE_CKSUM
		if (m->m_pkthdr.csum_flags & M_CSUM_IPv4)
d1168 1
a1168 1
		if (m->m_pkthdr.csum_flags & M_CSUM_TCPv4)
d1170 1
a1170 1
		if (m->m_pkthdr.csum_flags & M_CSUM_UDPv4)
d1172 1
a1172 1
#endif
@


1.35
log
@remove useless chunks of code that do nothing, since endian adjustments
only have to be made for little endian architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.34 2006/10/23 21:08:22 brad Exp $	*/
d749 5
@


1.34
log
@- remove the TODO comments at the top.
- add the VLAN headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.33 2006/10/11 00:08:51 brad Exp $	*/
a389 4
#elif BYTE_ORDER == BIG_ENDIAN
	/* do nothing */
#else
#error bad endianness!
a428 4
#elif BYTE_ORDER == BIG_ENDIAN
		/* do nothing */
#else
#error bad endianness!
@


1.33
log
@call xge_stop() at the top of xge_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.32 2006/10/10 23:39:15 brad Exp $	*/
d39 1
a39 5
 * Device driver for the Neterion Xframe Ten Gigabit Ethernet controller.
 *
 * TODO (in no specific order):
 *	HW VLAN support.
 *	IPv6 HW cksum.
d48 1
d71 5
@


1.32
log
@- Only use the MAC address workaround for the Xframe chipset.
- For the Xfrme II chipset, bring EOI out of reset before XGXS.
- Check for the adapter status bit RIC_RUNNING before trying to
  access any registers with the Xframe II chipset.
- Add new DTX_Control values for the Xframe II chipset to
  initialize the XGXS transciever.
- Make sure to clear IFF_RUNNING/IFF_OACTIVE in xge_stop().

From Veena Parat @@ Neterion
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.31 2006/08/25 00:55:37 brad Exp $	*/
d725 8
d752 1
d790 2
d999 1
a999 1
				xge_stop(ifp, 0);
@


1.31
log
@only write to the RMAC_CFG_KEY register for the Xframe chipset.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.30 2006/08/10 17:24:32 brad Exp $	*/
d158 20
a211 2
#define XGE_DEBUG

d231 2
a232 1
int xge_setup_xgxs(struct xge_softc *);
d351 1
a351 1
	int i, pcisize;
d357 1
a357 1
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETERION_XFRAME) {
d359 1
a359 2
		pcisize = XGE_PCISIZE_XENA;
	} else {
a360 2
		pcisize = XGE_PCISIZE_HERC;
	}
d377 5
a381 3
	/* Save PCI config space */
	for (i = 0; i < pcisize; i += 4)
		sc->sc_pciregs[i/4] = pci_conf_read(pa->pa_pc, pa->pa_tag, i);
d401 13
a413 16
	 * The MAC addr may be all FF's, which is not good.
	 * Resolve it by writing some magics to GPIO_CONTROL and 
	 * force a chip reset to read in the serial eeprom again.
	 */
	for (i = 0; i < sizeof(fix_mac)/sizeof(fix_mac[0]); i++) {
		PIF_WCSR(GPIO_CONTROL, fix_mac[i]);
		PIF_RCSR(GPIO_CONTROL);
	}

	/*
	 * Reset the chip and restore the PCI registers.
	 */
	PIF_WCSR(SW_RESET, XGXS_RESET(0xA5));
	DELAY(500000);
	for (i = 0; i < pcisize; i += 4)
		pci_conf_write(pa->pa_pc, pa->pa_tag, i, sc->sc_pciregs[i/4]);
d415 11
a425 3
	/*
	 * Restore the byte order registers.
	 */
d427 4
a430 4
	val = (uint64_t)0xFFFFFFFFFFFFFFFFULL;
	val &= ~(TxF_R_SE|RxF_W_SE);
	PIF_WCSR(SWAPPER_CTRL, val);
	PIF_WCSR(SWAPPER_CTRL, val);
d432 1
a432 1
	/* do nothing */
d437 5
a441 4
	if ((val = PIF_RCSR(PIF_RD_SWAPPER_Fb)) != SWAPPER_MAGIC) {
		printf(": failed configuring endian2, %llx != %llx!\n",
		    (unsigned long long)val, SWAPPER_MAGIC);
		return;
d447 15
a461 2
	/* 29, reset */
	PIF_WCSR(SW_RESET, 0);
d464 17
d482 4
a485 1
	xge_setup_xgxs(sc);
a717 1

d760 1
d769 1
d790 2
d1376 1
a1376 1
xge_setup_xgxs(struct xge_softc *sc)
d1460 14
@


1.30
log
@- xge_mcast_filter() -> xge_setmulti().
- move the promiscuous mode handling code to xge_setpromisc() and simplify
the ioctl handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.29 2006/08/10 15:48:45 brad Exp $	*/
d96 7
d236 1
d245 1
d259 1
d272 9
a280 3
	PIF_WCSR(RMAC_CFG_KEY, RMAC_KEY_VALUE);
	bus_space_write_4(sc->sc_st, sc->sc_sh, csr, lval); 
	PIF_WCSR(RMAC_CFG_KEY, RMAC_KEY_VALUE);
a306 6

#define XGE_TYPE_XENA		1	/* Xframe-I */
#define XGE_TYPE_HERC		2	/* Xframe-II */

#define XGE_PCISIZE_XENA	26
#define XGE_PCISIZE_HERC	64
@


1.29
log
@- Use BUS_DMA_NOWAIT flag with bus_dmamap_create() in xge_attach() for the
creation of transmit and receive DMA maps.
- Fix typos in xge_alloc_rxmem(), make sure to destroy and unmap the RX
descriptor map instead of the TX descriptor map when encountering an error.

From Gireesh Nagabhushana @@ Neterion
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.28 2006/08/02 00:23:18 brad Exp $	*/
d204 2
a205 1
void xge_mcast_filter(struct xge_softc *);
d705 3
a707 1
	xge_mcast_filter(sc);
a880 1
	uint64_t val;
a906 6
		/*
		 * If interface is marked up and not running, then start it.
		 * If it is marked down and running, stop it.
		 * XXX If it's up then re-initialize it. This is so flags
		 * such as IFF_PROMISC are handled.
		 */
d909 3
a911 11
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->xge_if_flags & IFF_PROMISC)) {
				val = PIF_RCSR(MAC_CFG);
				val |= RMAC_PROM_EN;
				PIF_WCSR(MAC_CFG, val);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->xge_if_flags & IFF_PROMISC) {
				val = PIF_RCSR(MAC_CFG);
				val &= ~RMAC_PROM_EN;
				PIF_WCSR(MAC_CFG, val);
d930 1
a930 1
				xge_mcast_filter(sc);
d948 1
a948 1
xge_mcast_filter(struct xge_softc *sc)
d999 16
@


1.28
log
@disable Jumbos until reception of Jumbo frames can be fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.27 2006/07/21 01:57:15 brad Exp $	*/
d457 1
a457 1
		    NTXFRAGS, MCLBYTES, 0, 0, &sc->sc_txm[i])) {
d478 1
a478 1
		    NRXFRAGS, MCLBYTES, 0, 0, &sc->sc_rxm[i])) {
d1196 1
a1196 1
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_txmap);
d1198 1
a1198 1
		bus_dmamem_unmap(sc->sc_dmat, kva, TXMAPSZ);
@


1.27
log
@lower the number of TX descriptors from 8192 to 2048.

From Gireesh Nagabhushana @@ Neterion
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.26 2006/07/14 02:32:14 brad Exp $	*/
d580 1
d582 1
d681 1
d683 3
@


1.26
log
@debug message macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.25 2006/06/21 07:15:58 brad Exp $	*/
d101 1
a101 1
#define NTXDESCS	8192	   /* Number of transmit descriptors */
@


1.25
log
@use the 10Gb SR media type for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.24 2006/06/09 19:09:41 brad Exp $	*/
d184 11
@


1.24
log
@fix up the comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.23 2006/06/01 23:04:55 brad Exp $	*/
d558 2
a559 2
	ifmedia_add(&sc->xena_media, IFM_ETHER|IFM_1000_SX, 0, NULL);
	ifmedia_set(&sc->xena_media, IFM_ETHER|IFM_1000_SX);
d607 1
a607 1
	ifmr->ifm_active = IFM_ETHER|IFM_1000_SX;
@


1.23
log
@hide link up/down messages under XGE_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.22 2006/06/01 22:58:42 brad Exp $	*/
d131 2
a132 2
 * Magics to fix a bug when the mac address can't be read correctly.
 * Comes from the Linux driver.
@


1.22
log
@do not enable promiscous mode by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.21 2006/06/01 21:56:26 brad Exp $	*/
d634 1
d636 1
d737 1
d739 1
@


1.21
log
@These magics -> This magic
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.20 2006/06/01 21:53:52 brad Exp $	*/
d163 1
d646 1
a646 1
	    RMAC_BCAST_EN|RMAC_DISCARD_PFRM|RMAC_PROM_EN);
d857 1
d891 16
a906 2
			if (!(ifp->if_flags & IFF_RUNNING))
				xge_init(ifp);
d911 1
@


1.20
log
@The largest allowable frame size is 9622 bytes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.19 2006/06/01 09:39:13 brad Exp $	*/
d1261 1
a1261 1
 * These magics comes from the FreeBSD driver.
@


1.19
log
@enable hardware RX checksum offload.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.18 2006/06/01 09:20:04 brad Exp $	*/
d275 3
a277 2
#define XGE_MAX_FRAMELEN	9600
#define XGE_MAX_MTU		(XGE_MAX_FRAMELEN - ETHER_HDR_LEN - ETHER_CRC_LEN)
@


1.18
log
@formatting
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.17 2006/05/28 00:20:21 brad Exp $	*/
d828 6
a833 17
#if XGE_CKSUM
		if (RXD_CTL1_PROTOS(val) & (RXD_CTL1_P_IPv4|RXD_CTL1_P_IPv6)) {
			m->m_pkthdr.csum_flags |= M_CSUM_IPv4;
			if (RXD_CTL1_L3CSUM(val) != 0xffff)
				m->m_pkthdr.csum_flags |= M_CSUM_IPv4_BAD;
		}
		if (RXD_CTL1_PROTOS(val) & RXD_CTL1_P_TCP) {
			m->m_pkthdr.csum_flags |= M_CSUM_TCPv4|M_CSUM_TCPv6;
			if (RXD_CTL1_L4CSUM(val) != 0xffff)
				m->m_pkthdr.csum_flags |= M_CSUM_TCP_UDP_BAD;
		}
		if (RXD_CTL1_PROTOS(val) & RXD_CTL1_P_UDP) {
			m->m_pkthdr.csum_flags |= M_CSUM_UDPv4|M_CSUM_UDPv6;
			if (RXD_CTL1_L4CSUM(val) != 0xffff)
				m->m_pkthdr.csum_flags |= M_CSUM_TCP_UDP_BAD;
		}
#endif
@


1.17
log
@- remove ETHER_MAX_LEN_JUMBO and ETHERMTU_JUMBO.
- use if_hardmtu for MTU ioctl handlers.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.16 2006/05/28 00:04:24 jason Exp $	*/
d227 1
a227 1
	return val;
d506 7
a512 4
	if (sc->xge_type == XGE_TYPE_XENA)
		PIF_WCSR(RX_QUEUE_CFG, MC_QUEUE(0, 64)); /* all 64M to queue 0 */
	else
		PIF_WCSR(RX_QUEUE_CFG, MC_QUEUE(0, 32)); /* all 32M to queue 0 */
d615 1
a615 1
	return 0;
d660 1
a660 1
		return 1;
d689 1
a689 1
	return 0;
d727 1
a727 1
		return 0; /* no interrupt here */
a854 1

d857 1
a857 1
	return 1;
d927 2
a928 1
	return(error);
d1105 1
a1105 1
	return 0;
d1114 1
a1114 1
	return ENOBUFS;
d1134 1
a1134 1
		return EINVAL;
d1164 1
a1164 1
	return 0;
d1173 1
a1173 1
	return ENOBUFS;
d1204 1
a1204 1
		return ENOBUFS;
d1208 1
a1208 1
		return ENOBUFS;
d1228 1
a1228 1
		return ENOBUFS;
d1246 1
a1246 1
		return error;
d1267 1
a1267 1
	return 0;
d1324 1
a1324 1
		return 1;
d1341 1
a1341 1
		return 1;
d1355 1
a1355 1
		return 1;
d1358 1
a1358 1
	return 0;
@


1.16
log
@unknown ioctl is ENOTTY not EINVAL
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.15 2006/05/27 10:03:15 brad Exp $	*/
d275 2
a276 1
#define XGE_MAX_MTU		9600
d443 1
a443 1
		if (bus_dmamap_create(sc->sc_dmat, XGE_MAX_MTU,
d464 1
a464 1
		if (bus_dmamap_create(sc->sc_dmat, XGE_MAX_MTU,
d661 1
a661 1
	PIF_WCSR(RMAC_MAX_PYLD_LEN, RMAC_PYLD_LEN(XGE_MAX_MTU));
d884 1
a884 1
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > XGE_MAX_MTU)
@


1.15
log
@remove IFCAP_JUMBO_MTU interface capabilities flag and set if_hardmtu in a few
more drivers.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.14 2006/05/26 20:50:41 deraadt Exp $	*/
d920 1
a920 1
		error = EINVAL;
@


1.14
log
@rename jumbo mtu to if_hardmtu; ok brad reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.13 2006/05/20 03:47:56 brad Exp $	*/
d567 1
a567 1
	ifp->if_capabilities = IFCAP_VLAN_MTU | IFCAP_JUMBO_MTU;
@


1.13
log
@set if_jumbo_mtu and the IFCAP_JUMBO_MTU capabilities flag where
appropriate.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.12 2006/05/15 00:41:51 brad Exp $	*/
d563 1
a563 1
	ifp->if_jumbo_mtu = XGE_MAX_MTU;
@


1.12
log
@add a shutdown hook.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.11 2006/05/14 22:19:04 brad Exp $	*/
d563 1
d567 1
a567 1
	ifp->if_capabilities = IFCAP_VLAN_MTU;
@


1.11
log
@only call init if not running.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.10 2006/05/14 21:51:22 brad Exp $	*/
d163 1
d190 1
d574 2
d701 9
d861 1
a861 1
	struct ifaddr  *ifa = (struct ifaddr *)data;
@


1.10
log
@set the multicast filter in xge_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.9 2006/05/14 21:41:25 brad Exp $	*/
d882 2
a883 1
			xge_init(ifp);
@


1.9
log
@set the maximum MRU by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.8 2006/05/14 21:11:10 brad Exp $	*/
d673 2
@


1.8
log
@account for interrupts in the interrupt handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.7 2006/05/14 20:19:23 deraadt Exp $	*/
d654 3
d867 1
a867 1
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > XGE_MAX_MTU) {
d869 1
a869 3
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
			PIF_WCSR(RMAC_MAX_PYLD_LEN,
			    RMAC_PYLD_LEN(ifr->ifr_mtu));
a870 1
		}
@


1.7
log
@re-enable link up/down messages because they spray a lot right now
(clearly indicating some bug)
copy mac address correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.5 2006/05/13 05:12:38 brad Exp $	*/
d835 1
a835 1
	return 0;
@


1.6
log
@comment out link up/down printf's.
@
text
@d555 1
a555 1
	strlcpy(sc->sc_arpcom.ac_enaddr, enaddr, ETHER_ADDR_LEN);
a622 1
#if 0
a623 1
#endif
a709 1
#if 0
a710 1
#endif
@


1.5
log
@use the PCI id from pcireg.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.4 2006/05/13 05:02:37 brad Exp $	*/
d623 1
d625 1
d712 1
d714 1
@


1.4
log
@add the PCI id and minimal changes necessary for the Xframe-II, according
to the Xframe-II porting docs from Neterion. currently untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.3 2006/05/01 01:31:48 brad Exp $	*/
d283 1
a283 1
	{ PCI_VENDOR_NETERION, PCI_PRODUCT_NETERION_XFRAMEII }
@


1.3
log
@always call xge_init() here, for the time being.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.2 2006/05/01 01:11:49 brad Exp $	*/
d162 1
d275 6
d283 1
d305 1
a305 1
	int i;
d311 8
d335 1
a335 1
	for (i = 0; i < 64; i += 4)
d368 1
a368 1
	PIF_WCSR(SW_RESET, 0xa5a5a50000000000ULL);
d370 1
a370 1
	for (i = 0; i < 64; i += 4)
d503 4
a506 1
	PIF_WCSR(RX_QUEUE_CFG, MC_QUEUE(0, 64)); /* all 64M to queue 0 */
@


1.2
log
@OpenBSD-ify the attach function printf's.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xge.c,v 1.1 2006/05/01 00:34:12 brad Exp $	*/
d861 1
a861 2
			if (!(ifp->if_flags & IFF_RUNNING))
				xge_init(ifp);
@


1.1
log
@initial port of a driver for the Neterion Xframe-I 10Gb Ethernet adapter.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d307 1
a307 1
		printf("%s: unable to map PIF BAR registers\n", XNAME);
d314 1
a314 1
		printf("%s: unable to map TXP BAR registers\n", XNAME);
d334 2
a335 2
		printf("%s: failed configuring endian, %llx != %llx!\n",
		    XNAME, (unsigned long long)val, SWAPPER_MAGIC);
d372 2
a373 2
		printf("%s: failed configuring endian2, %llx != %llx!\n",
		    XNAME, (unsigned long long)val, SWAPPER_MAGIC);
d401 1
a401 1
		printf("%s: failed allocating txmem.\n", XNAME);
d426 1
a426 1
			printf("%s: cannot create TX DMA maps\n", XNAME);
d439 1
a439 1
		printf("%s: failed allocating rxmem\n", XNAME);
d447 1
a447 1
			printf("%s: cannot create RX DMA maps\n", XNAME);
a533 2
	printf(", address %s\n", ether_sprintf(enaddr));

d557 1
a557 2
		printf("%s: unable to map interrupt\n",
		    XNAME);
d563 2
a564 2
		printf("%s: unable to establish interrupt at %s\n",
		    XNAME, intrstr ? intrstr : "<unknown>");
d567 1
a567 1
	printf("%s: interrupting at %s\n", XNAME, intrstr);
@

