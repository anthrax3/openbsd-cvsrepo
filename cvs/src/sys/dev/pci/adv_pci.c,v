head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.22
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.24
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.12
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.20
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.18
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.16
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.14
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.10
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.8
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.6
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.4
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.10.0.12
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.10
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.6
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.8
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.4
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.2
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.8.0.6
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.12
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.10
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.8
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.6
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.5.0.4
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.12
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.6
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.11
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.11.18.17.08;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.19.18.40.16;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.25.10.13.29;	author art;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	98.11.17.07.55.46;	author downsj;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	98.11.17.06.09.01;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	98.09.28.01.56.58;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	98.09.27.03.38.09;	author downsj;	state Exp;
branches;
next	;

1.4.6.1
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2003.03.28.00.38.20;	author niklas;	state Exp;
branches;
next	;

1.5.4.1
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2003.05.19.22.17.59;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@/*	$OpenBSD: adv_pci.c,v 1.10 2008/06/26 05:42:17 ray Exp $	*/
/*	$NetBSD: adv_pci.c,v 1.5 1998/09/26 15:52:55 dante Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc. All rights reserved.
 * 
 * Author: Baldassare Dante Profeta <dante@@mclink.it>
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Device probe and attach routines for the following
 * Advanced Systems Inc. SCSI controllers:
 *
 *    Connectivity Products:
 *      ABP920 - Bus-Master PCI (16 CDB)
 *      ABP930 - Bus-Master PCI (16 CDB)		(Footnote 1)
 *      ABP930U - Bus-Master PCI Ultra (16 CDB)
 *      ABP930UA - Bus-Master PCI Ultra (16 CDB)
 *      ABP960 - Bus-Master PCI MAC/PC (16 CDB)		(Footnote 2)
 *      ABP960U - Bus-Master PCI MAC/PC Ultra (16 CDB)	(Footnote 2)
 *
 *   Single Channel Products:
 *      ABP940 - Bus-Master PCI (240 CDB)
 *      ABP940U - Bus-Master PCI Ultra (240 CDB)
 *      ABP970 - Bus-Master PCI MAC/PC (240 CDB)
 *      ABP970U - Bus-Master PCI MAC/PC Ultra (240 CDB)
 *
 *   Multi Channel Products:
 *      ABP950 - Dual Channel Bus-Master PCI (240 CDB Per Channel)
 *      ABP980 - Four Channel Bus-Master PCI (240 CDB Per Channel)
 *      ABP980U - Four Channel Bus-Master PCI Ultra (240 CDB Per Channel)
 *
 *   Footnotes:
 *     1. This board has been sold by SIIG as the Fast SCSI Pro PCI.
 *     2. This board has been sold by Iomega as a Jaz Jet PCI adapter.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/queue.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/ic/adv.h>
#include <dev/ic/advlib.h>

/******************************************************************************/

#define PCI_CBIO        0x10

/******************************************************************************/

int	adv_pci_match(struct device *, void *, void *);
void	adv_pci_attach(struct device *, struct device *, void *);

struct cfattach adv_pci_ca =
{
	sizeof(ASC_SOFTC), adv_pci_match, adv_pci_attach
};

const struct pci_matchid adv_pci_devices[] = {
	{ PCI_VENDOR_ADVSYS, PCI_PRODUCT_ADVSYS_1200A },
	{ PCI_VENDOR_ADVSYS, PCI_PRODUCT_ADVSYS_1200B },
	{ PCI_VENDOR_ADVSYS, PCI_PRODUCT_ADVSYS_ULTRA },
};

/******************************************************************************/
/*
 * Check the slots looking for a board we recognise
 * If we find one, note its address (slot) and call
 * the actual probe routine to check it out.
 */
int 
adv_pci_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	return (pci_matchbyid((struct pci_attach_args *)aux, adv_pci_devices,
	    nitems(adv_pci_devices)));
}


void 
adv_pci_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pci_attach_args *pa = aux;
	ASC_SOFTC      *sc = (void *) self;
	bus_space_handle_t ioh;
	bus_size_t advsize;
	pci_intr_handle_t ih;
	pci_chipset_tag_t pc = pa->pa_pc;
	const char     *intrstr;
	int retval;

	sc->sc_flags = 0x0;

	/*
	 * Latency timer settings.
	 */
	{
		u_int32_t       bhlcr;

		bhlcr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);

		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADVSYS_1200A ||
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADVSYS_1200B) {
			bhlcr &= 0xFFFF00FFul;
			pci_conf_write(pa->pa_pc, pa->pa_tag,
					PCI_BHLC_REG, bhlcr);
		} else if ((PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADVSYS_ULTRA) &&
			   (PCI_LATTIMER(bhlcr) < 0x20)) {
			bhlcr &= 0xFFFF00FFul;
			bhlcr |= 0x00002000ul;
			pci_conf_write(pa->pa_pc, pa->pa_tag,
					PCI_BHLC_REG, bhlcr);
		}
	}


	/*
	 * Map Device Registers for I/O
	 */
	retval = pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->sc_iot, &ioh, NULL, &advsize, 0);
	if (retval) {
		printf(": unable to map device registers\n");
		return;
	}
	sc->sc_ioh = ioh;
	sc->sc_dmat = pa->pa_dmat;
	sc->pci_device_id = pa->pa_id;
	sc->bus_type = ASC_IS_PCI;

	/*
	 * Initialize the board
	 */
	if (adv_init(sc)) {
		printf(": adv_init failed\n");
		bus_space_unmap(sc->sc_iot, ioh, advsize);
		return;
	}

	/*
	 * Map Interrupt line
	 */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		bus_space_unmap(sc->sc_iot, ioh, advsize);
		return;
	}
	intrstr = pci_intr_string(pc, ih);

	/*
	 * Establish Interrupt handler
	 */
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_BIO, adv_intr, sc,
				       sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(sc->sc_iot, ioh, advsize);
		return;
	}
	printf(": %s\n", intrstr);

	/*
	 * Attach all the sub-devices we can find
	 */
	adv_attach(sc);
}
/******************************************************************************/
@


1.10
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adv_pci.c,v 1.9 2007/04/10 17:47:55 miod Exp $	*/
d111 1
a111 1
	    sizeof(adv_pci_devices)/sizeof(adv_pci_devices[0])));
@


1.9
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: adv_pci.c,v 1.8 2005/09/11 18:17:08 mickey Exp $	*/
a16 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.8
log
@do not inline pci_mapreg_map() anymore as it is olrite now; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: adv_pci.c,v 1.7 2002/11/19 18:40:16 jason Exp $	*/
d109 1
a109 1
 * If we find one, note it's address (slot) and call
@


1.7
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: adv_pci.c,v 1.6 2002/03/14 01:26:58 millert Exp $	*/
a129 1
	bus_addr_t advbase;
d164 2
a165 3
	retval = pci_io_find(pc, pa->pa_tag, PCI_CBIO, &advbase, &advsize);
	if (retval == 0)
		retval = bus_space_map(pa->pa_iot, advbase, advsize, 0, &ioh);
d167 1
a167 2
		printf("\n%s: unable to map device registers\n",
		       sc->sc_dev.dv_xname);
a169 1
	sc->sc_iot = pa->pa_iot;
d178 5
a182 2
	if (adv_init(sc))
		panic("adv_pci_attach: adv_init failed");
d188 2
a189 1
		printf("\n%s: couldn't map interrupt\n", sc->sc_dev.dv_xname);
d200 1
a200 2
		printf("\n%s: couldn't establish interrupt",
		       sc->sc_dev.dv_xname);
d204 1
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: adv_pci.c,v 1.5 2001/08/25 10:13:29 art Exp $	*/
d100 6
d117 2
a118 11
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ADVSYS)
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_ADVSYS_1200A:
		case PCI_PRODUCT_ADVSYS_1200B:
		case PCI_PRODUCT_ADVSYS_ULTRA:
			return (1);
		}

	return 0;
@


1.5
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: adv_pci.c,v 1.4 1998/11/17 07:55:46 downsj Exp $	*/
d92 2
a93 2
int	adv_pci_match __P((struct device *, void *, void *));
void	adv_pci_attach __P((struct device *, struct device *, void *));
@


1.5.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: adv_pci.c,v 1.5 2001/08/25 10:13:29 art Exp $	*/
d92 2
a93 2
int	adv_pci_match(struct device *, void *, void *);
void	adv_pci_attach(struct device *, struct device *, void *);
@


1.5.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a99 6
const struct pci_matchid adv_pci_devices[] = {
	{ PCI_VENDOR_ADVSYS, PCI_PRODUCT_ADVSYS_1200A },
	{ PCI_VENDOR_ADVSYS, PCI_PRODUCT_ADVSYS_1200B },
	{ PCI_VENDOR_ADVSYS, PCI_PRODUCT_ADVSYS_ULTRA },
};

d111 11
a121 2
	return (pci_matchbyid((struct pci_attach_args *)aux, adv_pci_devices,
	    sizeof(adv_pci_devices)/sizeof(adv_pci_devices[0])));
@


1.4
log
@Remove 940UW from the comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: adv_pci.c,v 1.3 1998/11/17 06:09:01 downsj Exp $	*/
d191 1
a191 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
			 pa->pa_intrline, &ih)) {
@


1.4.6.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: adv_pci.c,v 1.4 1998/11/17 07:55:46 downsj Exp $	*/
d191 2
a192 1
	if (pci_intr_map(pa, &ih)) {
@


1.4.6.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d92 2
a93 2
int	adv_pci_match(struct device *, void *, void *);
void	adv_pci_attach(struct device *, struct device *, void *);
@


1.4.6.3
log
@Sync the SMP branch with 3.3
@
text
@a99 6
const struct pci_matchid adv_pci_devices[] = {
	{ PCI_VENDOR_ADVSYS, PCI_PRODUCT_ADVSYS_1200A },
	{ PCI_VENDOR_ADVSYS, PCI_PRODUCT_ADVSYS_1200B },
	{ PCI_VENDOR_ADVSYS, PCI_PRODUCT_ADVSYS_ULTRA },
};

d111 11
a121 2
	return (pci_matchbyid((struct pci_attach_args *)aux, adv_pci_devices,
	    sizeof(adv_pci_devices)/sizeof(adv_pci_devices[0])));
@


1.3
log
@Kill redundant PCI code.
@
text
@d1 1
a1 1
/*	$OpenBSD: adv_pci.c,v 1.2 1998/09/28 01:56:58 downsj Exp $	*/
a53 1
 *      ABP940UW - Bus-Master PCI Ultra-Wide (240 CDB)
@


1.2
log
@Sync w/ NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: adv_pci.c,v 1.1 1998/09/27 03:38:09 downsj Exp $	*/
a137 1
	u_int32_t       command;
d142 1
a142 12
	/*
	 * Make sure IO/MEM/MASTER are enabled
	 */
	command = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	if ((command & (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
			PCI_COMMAND_MASTER_ENABLE)) !=
	    (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
	     PCI_COMMAND_MASTER_ENABLE)) {
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
		 command | (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
			    PCI_COMMAND_MASTER_ENABLE));
	}
@


1.1
log
@AdvanSys PCI SCSI driver, from NetBSD; dante@@mclink.it.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: adv_pci.c,v 1.4 1998/08/31 17:15:25 dante Exp $	*/
d43 1
a43 1
 *      ABP930 - Bus-Master PCI (16 CDB)		(Footnote 2)
d46 2
a47 2
 *      ABP960 - Bus-Master PCI MAC/PC (16 CDB)		(Footnote 1)
 *      ABP960U - Bus-Master PCI MAC/PC Ultra (16 CDB)	(Footnote 1)
d62 2
a63 2
 *     1. This board has been sold by Iomega as a Jaz Jet PCI adapter.
 *     2. This board has been sold by SIIG as the Fast SCSI Pro PCI.
a119 2
		case PCI_PRODUCT_ADVSYS_2300:
			return (0);
a142 6
	if ((PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ADVSYS) &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADVSYS_2300)) {
			sc->sc_flags |= ASC_WIDE_BOARD;
			printf("(unsupported wide board)");
	}

@

