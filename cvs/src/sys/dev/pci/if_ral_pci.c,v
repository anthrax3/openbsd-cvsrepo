head	1.25;
access;
symbols
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.24.0.6
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.23.0.10
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.8
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.20.0.14
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.12
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.10
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.8
	OPENBSD_5_0:1.20.0.6
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.4
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.8.0.4
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.2
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.6.0.4
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.25
date	2016.08.17.11.50.52;	author stsp;	state Exp;
branches;
next	1.24;
commitid	HEQW3uHEkL9CrHHt;

1.24
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.23;
commitid	5gdEnqVoJuTuwdTu;

1.23
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2013.11.14.12.28.48;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2013.08.01.09.21.09;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2010.08.04.19.48.33;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.05.14.14.02;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.01.12.08.36;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2009.05.12.17.43.16;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2009.05.11.19.49.14;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.25.22.20.11;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2008.07.21.19.41.44;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2007.12.09.00.08.35;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2007.12.04.22.26.54;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.15.21.40.47;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.15.21.15.34;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.18.20.44.40;	author grange;	state Exp;
branches;
next	1.7;

1.7
date	2006.10.22.12.14.44;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.09.20.03.43;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2005.08.09.04.10.12;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.22.10.41.30;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.19.12.11.40;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2005.02.18.19.57.54;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.15.20.51.22;	author damien;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Add support for RT5390 and RT5392 chipsets to the ral(4) driver.

Tested by procter@@ on RT2860 and by me on RT2790 and RT3090.
Ported from FreeBSD by James Hastings.
@
text
@/*	$OpenBSD: if_ral_pci.c,v 1.24 2015/11/24 17:11:39 mpi Exp $  */

/*-
 * Copyright (c) 2005-2010 Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * PCI front-end for the Ralink RT2560/RT2561/RT2860/RT3090 driver.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/timeout.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/ic/rt2560var.h>
#include <dev/ic/rt2661var.h>
#include <dev/ic/rt2860var.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

static struct ral_opns {
	int	(*attach)(void *, int);
	int	(*detach)(void *);
	void	(*suspend)(void *);
	void	(*wakeup)(void *);
	int	(*intr)(void *);

}  ral_rt2560_opns = {
	rt2560_attach,
	rt2560_detach,
	rt2560_suspend,
	rt2560_wakeup,
	rt2560_intr

}, ral_rt2661_opns = {
	rt2661_attach,
	rt2661_detach,
	rt2661_suspend,
	rt2661_wakeup,
	rt2661_intr

}, ral_rt2860_opns = {
	rt2860_attach,
	rt2860_detach,
	rt2860_suspend,
	rt2860_wakeup,
	rt2860_intr
};

struct ral_pci_softc {
	union {
		struct rt2560_softc	sc_rt2560;
		struct rt2661_softc	sc_rt2661;
		struct rt2860_softc	sc_rt2860;
	} u;
#define sc_sc	u.sc_rt2560

	/* PCI specific goo */
	struct ral_opns		*sc_opns;
	pci_chipset_tag_t	sc_pc;
	void			*sc_ih;
	bus_size_t		sc_mapsize;
};

/* Base Address Register */
#define RAL_PCI_BAR0	0x10

int	ral_pci_match(struct device *, void *, void *);
void	ral_pci_attach(struct device *, struct device *, void *);
int	ral_pci_detach(struct device *, int);
int	ral_pci_activate(struct device *, int);
void	ral_pci_wakeup(struct ral_pci_softc *);

struct cfattach ral_pci_ca = {
	sizeof (struct ral_pci_softc), ral_pci_match, ral_pci_attach,
	ral_pci_detach, ral_pci_activate
};

const struct pci_matchid ral_pci_devices[] = {
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2560 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2561 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2561S },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2661 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2860 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2890 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2760 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2790 },
	{ PCI_VENDOR_AWT,    PCI_PRODUCT_AWT_RT2890 },
	{ PCI_VENDOR_EDIMAX, PCI_PRODUCT_EDIMAX_RT2860_1 },
	{ PCI_VENDOR_EDIMAX, PCI_PRODUCT_EDIMAX_RT2860_2 },
	{ PCI_VENDOR_EDIMAX, PCI_PRODUCT_EDIMAX_RT2860_3 },
	{ PCI_VENDOR_EDIMAX, PCI_PRODUCT_EDIMAX_RT2860_4 },
	{ PCI_VENDOR_EDIMAX, PCI_PRODUCT_EDIMAX_RT2860_5 },
	{ PCI_VENDOR_EDIMAX, PCI_PRODUCT_EDIMAX_RT2860_6 },
	{ PCI_VENDOR_EDIMAX, PCI_PRODUCT_EDIMAX_RT2860_7 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT3060 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT3062 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT3090 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT3091 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT3092 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT3562 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT3592 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT3593 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT5390 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT5392 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT5390_1 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT5390_2 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT5390_3 }
};

int
ral_pci_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, ral_pci_devices,
	    nitems(ral_pci_devices)));
}

void
ral_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct ral_pci_softc *psc = (struct ral_pci_softc *)self;
	struct rt2560_softc *sc = &psc->sc_sc;
	struct pci_attach_args *pa = aux;
	const char *intrstr;
	pci_intr_handle_t ih;
	pcireg_t memtype;
	int error;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_RALINK) {
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_RALINK_RT2560:
			psc->sc_opns = &ral_rt2560_opns;
			break;
		case PCI_PRODUCT_RALINK_RT2561:
		case PCI_PRODUCT_RALINK_RT2561S:
		case PCI_PRODUCT_RALINK_RT2661:
			psc->sc_opns = &ral_rt2661_opns;
			break;
		default:
			psc->sc_opns = &ral_rt2860_opns;
			break;
		}
	} else {
		/* all other vendors are RT2860 only */
		psc->sc_opns = &ral_rt2860_opns;
	}
	sc->sc_dmat = pa->pa_dmat;
	psc->sc_pc = pa->pa_pc;

	/* map control/status registers */
	memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag, RAL_PCI_BAR0);
	error = pci_mapreg_map(pa, RAL_PCI_BAR0, memtype, 0, &sc->sc_st,
	    &sc->sc_sh, NULL, &psc->sc_mapsize, 0);
	if (error != 0) {
		printf(": can't map mem space\n");
		return;
	}

	if (pci_intr_map(pa, &ih) != 0) {
		printf(": can't map interrupt\n");
		return;
	}

	intrstr = pci_intr_string(psc->sc_pc, ih);
	psc->sc_ih = pci_intr_establish(psc->sc_pc, ih, IPL_NET,
	    psc->sc_opns->intr, sc, sc->sc_dev.dv_xname);
	if (psc->sc_ih == NULL) {
		printf(": can't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(": %s", intrstr);

	(*psc->sc_opns->attach)(sc, PCI_PRODUCT(pa->pa_id));
}

int
ral_pci_detach(struct device *self, int flags)
{
	struct ral_pci_softc *psc = (struct ral_pci_softc *)self;
	struct rt2560_softc *sc = &psc->sc_sc;
	int error;

	if (psc->sc_ih != NULL) {
		pci_intr_disestablish(psc->sc_pc, psc->sc_ih);

		error = (*psc->sc_opns->detach)(sc);
		if (error != 0)
			return error;
	}

	if (psc->sc_mapsize > 0)
		bus_space_unmap(sc->sc_st, sc->sc_sh, psc->sc_mapsize);

	return 0;
}

int
ral_pci_activate(struct device *self, int act)
{
	struct ral_pci_softc *psc = (struct ral_pci_softc *)self;
	struct rt2560_softc *sc = &psc->sc_sc;

	switch (act) {
	case DVACT_SUSPEND:
		(*psc->sc_opns->suspend)(sc);
		break;
	case DVACT_WAKEUP:
		ral_pci_wakeup(psc);
		break;
	}
	return 0;
}

void
ral_pci_wakeup(struct ral_pci_softc *psc)
{
	struct rt2560_softc *sc = &psc->sc_sc;
	int s;

	s = splnet();
	(*psc->sc_opns->wakeup)(sc);
	splx(s);
}
@


1.24
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.23 2013/12/06 21:03:04 deraadt Exp $  */
d138 6
a143 1
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT3593 }
@


1.23
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.22 2013/11/14 12:28:48 dlg Exp $  */
a38 1
#include <net/if_dl.h>
@


1.22
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.21 2013/08/01 09:21:09 kettenis Exp $  */
a33 1
#include <sys/task.h>
d61 1
a61 1
	void	(*resume)(void *);
d68 1
a68 1
	rt2560_resume,
d75 1
a75 1
	rt2661_resume,
d82 1
a82 1
	rt2860_resume,
a98 1
	struct task		sc_resume_t;
d108 1
a108 1
void	ral_pci_resume(void *, void *);
a159 2
	task_set(&psc->sc_resume_t, ral_pci_resume, psc, NULL);

d241 2
a242 2
	case DVACT_RESUME:
		task_add(systq, &psc->sc_resume_t);
a244 1

d249 1
a249 1
ral_pci_resume(void *arg1, void *arg2)
a250 1
	struct ral_pci_softc *psc = arg1;
d255 1
a255 1
	(*psc->sc_opns->resume)(sc);
@


1.21
log
@Add support for the Ralink RT3060, which uses the RT3572 MAC/BBP.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.20 2010/08/04 19:48:33 damien Exp $  */
d34 1
a34 1
#include <sys/workq.h>
d100 1
a100 1
	struct workq_task	sc_resume_wqt;
d162 2
d246 1
a246 2
		workq_queue_task(NULL, &psc->sc_resume_wqt, 0,
		    ral_pci_resume, psc, NULL);
@


1.20
log
@add suspend/resume support for PCI ral(4) devices.

ok deraadt@@, sthen@@

tested by matthew@@ (RT2560), dcoppa@@ (RT2790), okan@@ (RT2860), todd@@ (RT2560)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.19 2010/04/05 14:14:02 damien Exp $  */
d134 1
@


1.19
log
@Initial bits for >=RT3090 support.
Probably not functionnal yet (but test reports are welcome).

Update microcode for RT2860 while I'm here (remember to run
make && make install under sys/dev/microcode/ral/).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.18 2009/11/01 12:08:36 damien Exp $  */
d34 1
d61 2
d68 2
d75 2
d82 2
d100 1
d109 2
d114 1
a114 1
	ral_pci_detach
d230 31
@


1.18
log
@call powerhook_disestablish() and pci_intr_disestablish() earlier.

diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.17 2009/05/12 17:43:16 damien Exp $  */
d4 1
a4 2
 * Copyright (c) 2005-2007
 *	Damien Bergamini <damien.bergamini@@free.fr>
d20 1
a20 1
 * PCI front-end for the Ralink RT2560/RT2561/RT2661/RT2860 driver.
d121 8
a128 1
	{ PCI_VENDOR_EDIMAX, PCI_PRODUCT_EDIMAX_RT2860_7 }
d159 1
a159 4
		case PCI_PRODUCT_RALINK_RT2860:
		case PCI_PRODUCT_RALINK_RT2890:
		case PCI_PRODUCT_RALINK_RT2760:
		case PCI_PRODUCT_RALINK_RT2790:
@


1.17
log
@fix EDIMAX attachment.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.16 2009/05/11 19:49:14 damien Exp $  */
d204 2
a208 3

		pci_intr_disestablish(psc->sc_pc, psc->sc_ih);
		psc->sc_ih = NULL;
@


1.16
log
@attach to Edimax RT2860.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.15 2009/03/29 21:53:52 sthen Exp $  */
d143 19
a161 14
	switch (PCI_PRODUCT(pa->pa_id)) {
	case PCI_PRODUCT_RALINK_RT2560:
		psc->sc_opns = &ral_rt2560_opns;
		break;
	case PCI_PRODUCT_RALINK_RT2561:
	case PCI_PRODUCT_RALINK_RT2561S:
	case PCI_PRODUCT_RALINK_RT2661:
		psc->sc_opns = &ral_rt2661_opns;
		break;
	case PCI_PRODUCT_RALINK_RT2860:
	case PCI_PRODUCT_RALINK_RT2890:
	case PCI_PRODUCT_RALINK_RT2760:
	case PCI_PRODUCT_RALINK_RT2790:
	case PCI_PRODUCT_AWT_RT2890:
a162 1
		break;
a163 1

@


1.15
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.14 2008/11/25 22:20:11 damien Exp $  */
d107 2
a108 2
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2560  },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2561  },
d110 13
a122 6
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2661  },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2860  },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2890  },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2760  },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2790  },
	{ PCI_VENDOR_AWT,    PCI_PRODUCT_AWT_RT2890     }
@


1.14
log
@more sizeof->nitems
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.13 2008/07/21 19:41:44 damien Exp $  */
d162 1
a162 1
		printf(": could not map memory space\n");
d167 1
a167 1
		printf(": could not map interrupt\n");
d175 1
a175 1
		printf(": could not establish interrupt");
@


1.13
log
@rename rt2860 pci ids to match with reality.
import some fixes for 1T2R adapters from the linux vendor driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.12 2007/12/09 00:08:35 deraadt Exp $  */
d122 1
a122 1
	    sizeof (ral_pci_devices) / sizeof (ral_pci_devices[0])));
@


1.12
log
@in raldetach, do not call chip-specific detach if it was never called in
the first place (ie. if interrupt allocation failed)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.11 2007/12/04 22:26:54 deraadt Exp $  */
d107 9
a115 8
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2560    },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2561    },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2561S   },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2661    },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2860_1  },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2860_1E },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2860_2  },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2860_3  }
d145 5
a149 4
	case PCI_PRODUCT_RALINK_RT2860_1:
	case PCI_PRODUCT_RALINK_RT2860_1E:
	case PCI_PRODUCT_RALINK_RT2860_2:
	case PCI_PRODUCT_RALINK_RT2860_3:
@


1.11
log
@expresscard ral(4) rt2860 now can attach and detach correctly
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.10 2007/11/15 21:40:47 deraadt Exp $  */
d191 4
a194 3
	error = (*psc->sc_opns->detach)(sc);
	if (error != 0)
		return error;
a195 1
	if (psc->sc_ih != NULL) {
@


1.10
log
@match expresscard ral
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.9 2007/11/15 21:15:34 damien Exp $  */
d189 10
d200 2
a201 2
	(*psc->sc_opns->detach)(sc);
	pci_intr_disestablish(psc->sc_pc, psc->sc_ih);
@


1.9
log
@New driver for Ralink RT2860 chipset.
Attaches as 'ral' as it shares the PCI and CardBus frontends with
RT2560 and RT2661 though it is actually a separate driver.

Requires a firmware that can't be redistributed with the base system
due to license restrictions (exact same license as iwn(4) firmware).

The 802.11n capabilities not yet supported (except MIMO).
Great thanks to Sam Fourman Jr for donating hardware.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.8 2006/11/18 20:44:40 grange Exp $  */
d107 8
a114 7
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2560   },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2561   },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2561S  },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2661   },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2860_1 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2860_2 },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2860_3 }
d145 1
@


1.8
log
@Remove some useless variables/code dealing with cardbus BARs
reprogramming.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.7 2006/10/22 12:14:44 damien Exp $  */
d4 1
a4 1
 * Copyright (c) 2005, 2006
d21 1
a21 1
 * PCI front-end for the Ralink RT2560/RT2561/RT2561S/RT2661 driver.
d52 1
d72 5
d83 1
d107 7
a113 4
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2560  },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2561  },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2561S },
	{ PCI_VENDOR_RALINK, PCI_PRODUCT_RALINK_RT2661  }
d131 1
d134 15
a148 2
	psc->sc_opns = (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_RALINK_RT2560) ?
	    &ral_rt2560_opns : &ral_rt2661_opns;
d154 3
a156 3
	error = pci_mapreg_map(pa, RAL_PCI_BAR0, PCI_MAPREG_TYPE_MEM |
	    PCI_MAPREG_MEM_TYPE_32BIT, 0, &sc->sc_st, &sc->sc_sh, NULL,
	    &psc->sc_mapsize, 0);
@


1.7
log
@replace rssadapt(9) with amrr for automatic rate control.
as a side-effect, this should fix all the "bogus xmit rate" panics
users have been complaining about for some time when operating in
HostAP mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.6 2006/01/09 20:03:43 damien Exp $  */
a119 1
	bus_addr_t base;
d131 1
a131 1
	    PCI_MAPREG_MEM_TYPE_32BIT, 0, &sc->sc_st, &sc->sc_sh, &base,
@


1.6
log
@- add preliminary support for Ralink Technology RT2561, RT2561S and RT2661
  chipsets in ral(4).
- restructure the code a bit; split ic/ral.c into ic/rt2560.c and ic/rt2661.c
- import the 8051 microcode files required by these chipsets.
- more to come;  there is currently no automatic rate control and some
  features are untested (hostap and ibss modes for instance).  most of
  the pre-802.11n capabilities of the RT2661 chipset are not supported
  (like frame aggregation, piggy-back).  MIMO should work though the
  performance/range gain has not been measured.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.5 2005/08/09 04:10:12 mickey Exp $  */
d47 1
a47 1
#include <net80211/ieee80211_rssadapt.h>
@


1.5
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.4 2005/02/22 10:41:30 damien Exp $  */
d4 1
a4 1
 * Copyright (c) 2005
d21 1
a21 1
 * PCI front-end for the Ralink RT2500 driver.
d50 2
a51 1
#include <dev/ic/ralvar.h>
d57 16
d74 5
a78 1
	struct ral_softc	sc_sc;
d81 1
d99 7
d109 2
a110 7
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_RALINK &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_RALINK_RT2560)
		return 1;

	return 0;
d117 1
a117 1
	struct ral_softc *sc = &psc->sc_sc;
d123 4
a126 1
	
d145 2
a146 2
	psc->sc_ih = pci_intr_establish(psc->sc_pc, ih, IPL_NET, ral_intr, sc,
	    sc->sc_dev.dv_xname);
d156 1
a156 1
	ral_attach(sc);
d163 1
a163 1
	struct ral_softc *sc = &psc->sc_sc;
d165 1
a165 1
	ral_detach(sc);
@


1.4
log
@make ral compile on macppc.
pointed out by "barryg" (Barry Dexter A. Gonzaga).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.3 2005/02/19 12:11:40 damien Exp $  */
a97 1
	pcireg_t reg;
a101 5

	/* enable the appropriate bits in the PCI CSR */
	reg = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	reg |= PCI_COMMAND_MASTER_ENABLE | PCI_COMMAND_MEM_ENABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, reg);
@


1.3
log
@fix dmesg output. pointed out by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.2 2005/02/18 19:57:54 damien Exp $  */
d34 1
@


1.2
log
@make sure bpfilter.h is included before including ralvar.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral_pci.c,v 1.1 2005/02/15 20:51:22 damien Exp $  */
a102 2
	printf("\n");

d132 1
a132 1
	printf(": %s\n", intrstr);
@


1.1
log
@Driver for Ralink Technology RT2500 wireless adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD$  */
d23 2
@

