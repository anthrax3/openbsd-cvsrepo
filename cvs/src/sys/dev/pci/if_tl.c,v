head	1.71;
access;
symbols
	OPENBSD_6_1:1.70.0.4
	OPENBSD_6_1_BASE:1.70
	OPENBSD_6_0:1.69.0.4
	OPENBSD_6_0_BASE:1.69
	OPENBSD_5_9:1.68.0.2
	OPENBSD_5_9_BASE:1.68
	OPENBSD_5_8:1.64.0.4
	OPENBSD_5_8_BASE:1.64
	OPENBSD_5_7:1.61.0.4
	OPENBSD_5_7_BASE:1.61
	OPENBSD_5_6:1.60.0.4
	OPENBSD_5_6_BASE:1.60
	OPENBSD_5_5:1.59.0.4
	OPENBSD_5_5_BASE:1.59
	OPENBSD_5_4:1.53.0.4
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.53.0.2
	OPENBSD_5_3_BASE:1.53
	OPENBSD_5_2:1.51.0.6
	OPENBSD_5_2_BASE:1.51
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.4
	OPENBSD_5_0:1.51.0.2
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.50.0.4
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.50.0.2
	OPENBSD_4_8_BASE:1.50
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.47.0.4
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.46.0.2
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.43.0.6
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.43.0.4
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.43.0.2
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.42.0.4
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.42.0.2
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.37.0.2
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.34.0.2
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.33.0.2
	OPENBSD_3_7_BASE:1.33
	OPENBSD_3_6:1.31.0.6
	OPENBSD_3_6_BASE:1.31
	SMP_SYNC_A:1.31
	SMP_SYNC_B:1.31
	OPENBSD_3_5:1.31.0.4
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	UBC_SYNC_A:1.29
	OPENBSD_3_3:1.29.0.2
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	UBC_SYNC_B:1.28
	UBC:1.24.0.2
	UBC_BASE:1.24
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	SMP:1.10.0.4
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.71
date	2017.07.13.17.44.36;	author naddy;	state Exp;
branches;
next	1.70;
commitid	5CxrHTMc1LzYPeQn;

1.70
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.69;
commitid	VyLWTsbepAOk7VQM;

1.69
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.68;
commitid	8YSL8ByWzGeIGBiJ;

1.68
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.67;
commitid	B0kwmVGiD5DVx4kv;

1.67
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.66;
commitid	5gdEnqVoJuTuwdTu;

1.66
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.65;
commitid	hPF95ClMUQfeqQDX;

1.65
date	2015.09.14.11.18.49;	author stsp;	state Exp;
branches;
next	1.64;
commitid	AyPOP6b7LKyRd0yH;

1.64
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.63;
commitid	MVWrtktB46JRxFWT;

1.63
date	2015.04.30.07.51.07;	author mpi;	state Exp;
branches;
next	1.62;
commitid	H09AuNxNnUcYramX;

1.62
date	2015.04.01.14.29.54;	author mpi;	state Exp;
branches;
next	1.61;
commitid	YvwyndathKBmcy5L;

1.61
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.60;
commitid	yM2VFFhpDTeFQlve;

1.60
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.59;
commitid	TGHgrLxu6sxZoiFt;

1.59
date	2014.01.31.08.58.32;	author brad;	state Exp;
branches;
next	1.58;

1.58
date	2014.01.31.06.05.40;	author brad;	state Exp;
branches;
next	1.57;

1.57
date	2013.11.26.09.50.33;	author mpi;	state Exp;
branches;
next	1.56;

1.56
date	2013.11.18.19.43.00;	author brad;	state Exp;
branches;
next	1.55;

1.55
date	2013.10.01.20.06.01;	author sf;	state Exp;
branches;
next	1.54;

1.54
date	2013.08.07.01.06.38;	author bluhm;	state Exp;
branches;
next	1.53;

1.53
date	2012.11.29.21.10.32;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2012.11.23.18.40.30;	author gsoares;	state Exp;
branches;
next	1.51;

1.51
date	2011.06.22.16.44.27;	author tedu;	state Exp;
branches;
next	1.50;

1.50
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.49;

1.49
date	2009.08.13.14.24.47;	author jasper;	state Exp;
branches;
next	1.48;

1.48
date	2009.08.10.19.41.05;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.46;

1.46
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.45;

1.45
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.08.21.19.13;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2006.06.29.21.35.39;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2006.05.28.00.04.24;	author jason;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.25.22.41.45;	author djm;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.20.16.15.03;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.04.23.40.14;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.23.11.30.14;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2005.11.07.02.57.45;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2005.09.11.18.17.08;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2005.07.02.22.52.16;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2004.09.14.22.39.03;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2003.08.19.14.01.35;	author mpech;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.30.02.52.51;	author avsm;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.15.06.31.24;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.08.14.48.57;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.05.13.48.11;	author aaron;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.15.20.45.31;	author nordin;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.12.20.03.49;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.27.06.34.49;	author kjc;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.24.20.27.01;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.05.02.03.12;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.25.06.37.27;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.20.19.39.43;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.03.05.52.27;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.25.03.50.51;	author todd;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.14.03.56.32;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.21.04.03.52;	author jason;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2000.06.20.03.24.21;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.15.02.28.15;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	99.09.13.20.41.38;	author jason;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	99.03.03.22.51.50;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	99.02.27.19.05.43;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	98.12.31.02.40.21;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	98.12.22.05.33.52;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	98.12.03.04.16.58;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	98.11.23.21.55.56;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	98.11.16.18.33.32;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	98.11.11.05.24.13;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	98.10.10.03.55.05;	author jason;	state Exp;
branches;
next	;

1.10.4.1
date	2000.02.20.11.57.07;	author niklas;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2001.05.14.22.25.47;	author niklas;	state Exp;
branches;
next	1.10.4.3;

1.10.4.3
date	2001.07.04.10.42.24;	author niklas;	state Exp;
branches;
next	1.10.4.4;

1.10.4.4
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.10.4.5;

1.10.4.5
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.10.4.6;

1.10.4.6
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.10.4.7;

1.10.4.7
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.10.4.8;

1.10.4.8
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.10.4.9;

1.10.4.9
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	;

1.13.2.1
date	2000.12.23.05.49.31;	author jason;	state Exp;
branches;
next	;

1.24.2.1
date	2002.06.11.03.42.26;	author art;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	1.24.2.3;

1.24.2.3
date	2003.05.19.22.18.01;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.71
log
@Fix multicast reception: use unsigned chars to avoid accidental sign
extension in hash calculation.  Reported & diagnosed by Nick Briggs.
ok mpi@@
@
text
@/*	$OpenBSD: if_tl.c,v 1.70 2017/01/22 10:17:38 dlg Exp $	*/

/*
 * Copyright (c) 1997, 1998
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/pci/if_tl.c,v 1.64 2001/02/06 10:11:48 phk Exp $
 */

/*
 * Texas Instruments ThunderLAN driver for FreeBSD 2.2.6 and 3.x.
 * Supports many Compaq PCI NICs based on the ThunderLAN ethernet controller,
 * the National Semiconductor DP83840A physical interface and the
 * Microchip Technology 24Cxx series serial EEPROM.
 *
 * Written using the following four documents:
 *
 * Texas Instruments ThunderLAN Programmer's Guide (www.ti.com)
 * National Semiconductor DP83840A data sheet (www.national.com)
 * Microchip Technology 24C02C data sheet (www.microchip.com)
 * Micro Linear ML6692 100BaseTX only PHY data sheet (www.microlinear.com)
 * 
 * Written by Bill Paul <wpaul@@ctr.columbia.edu>
 * Electrical Engineering Department
 * Columbia University, New York City
 */

/*
 * Some notes about the ThunderLAN:
 *
 * The ThunderLAN controller is a single chip containing PCI controller
 * logic, approximately 3K of on-board SRAM, a LAN controller, and media
 * independent interface (MII) bus. The MII allows the ThunderLAN chip to
 * control up to 32 different physical interfaces (PHYs). The ThunderLAN
 * also has a built-in 10baseT PHY, allowing a single ThunderLAN controller
 * to act as a complete ethernet interface.
 *
 * Other PHYs may be attached to the ThunderLAN; the Compaq 10/100 cards
 * use a National Semiconductor DP83840A PHY that supports 10 or 100Mb/sec
 * in full or half duplex. Some of the Compaq Deskpro machines use a
 * Level 1 LXT970 PHY with the same capabilities. Certain Olicom adapters
 * use a Micro Linear ML6692 100BaseTX only PHY, which can be used in
 * concert with the ThunderLAN's internal PHY to provide full 10/100
 * support. This is cheaper than using a standalone external PHY for both
 * 10/100 modes and letting the ThunderLAN's internal PHY go to waste.
 * A serial EEPROM is also attached to the ThunderLAN chip to provide
 * power-up default register settings and for storing the adapter's
 * station address. Although not supported by this driver, the ThunderLAN
 * chip can also be connected to token ring PHYs.
 *
 * The ThunderLAN has a set of registers which can be used to issue
 * commands, acknowledge interrupts, and to manipulate other internal
 * registers on its DIO bus. The primary registers can be accessed
 * using either programmed I/O (inb/outb) or via PCI memory mapping,
 * depending on how the card is configured during the PCI probing
 * phase. It is even possible to have both PIO and memory mapped
 * access turned on at the same time.
 * 
 * Frame reception and transmission with the ThunderLAN chip is done
 * using frame 'lists.' A list structure looks more or less like this:
 *
 * struct tl_frag {
 *	u_int32_t		fragment_address;
 *	u_int32_t		fragment_size;
 * };
 * struct tl_list {
 *	u_int32_t		forward_pointer;
 *	u_int16_t		cstat;
 *	u_int16_t		frame_size;
 *	struct tl_frag		fragments[10];
 * };
 *
 * The forward pointer in the list header can be either a 0 or the address
 * of another list, which allows several lists to be linked together. Each
 * list contains up to 10 fragment descriptors. This means the chip allows
 * ethernet frames to be broken up into up to 10 chunks for transfer to
 * and from the SRAM. Note that the forward pointer and fragment buffer
 * addresses are physical memory addresses, not virtual. Note also that
 * a single ethernet frame can not span lists: if the host wants to
 * transmit a frame and the frame data is split up over more than 10
 * buffers, the frame has to collapsed before it can be transmitted.
 *
 * To receive frames, the driver sets up a number of lists and populates
 * the fragment descriptors, then it sends an RX GO command to the chip.
 * When a frame is received, the chip will DMA it into the memory regions
 * specified by the fragment descriptors and then trigger an RX 'end of
 * frame interrupt' when done. The driver may choose to use only one
 * fragment per list; this may result is slighltly less efficient use
 * of memory in exchange for improving performance.
 *
 * To transmit frames, the driver again sets up lists and fragment
 * descriptors, only this time the buffers contain frame data that
 * is to be DMA'ed into the chip instead of out of it. Once the chip
 * has transferred the data into its on-board SRAM, it will trigger a
 * TX 'end of frame' interrupt. It will also generate an 'end of channel'
 * interrupt when it reaches the end of the list.
 */

/*
 * Some notes about this driver:
 *
 * The ThunderLAN chip provides a couple of different ways to organize
 * reception, transmission and interrupt handling. The simplest approach
 * is to use one list each for transmission and reception. In this mode,
 * the ThunderLAN will generate two interrupts for every received frame
 * (one RX EOF and one RX EOC) and two for each transmitted frame (one
 * TX EOF and one TX EOC). This may make the driver simpler but it hurts
 * performance to have to handle so many interrupts.
 *
 * Initially I wanted to create a circular list of receive buffers so
 * that the ThunderLAN chip would think there was an infinitely long
 * receive channel and never deliver an RXEOC interrupt. However this
 * doesn't work correctly under heavy load: while the manual says the
 * chip will trigger an RXEOF interrupt each time a frame is copied into
 * memory, you can't count on the chip waiting around for you to acknowledge
 * the interrupt before it starts trying to DMA the next frame. The result
 * is that the chip might traverse the entire circular list and then wrap
 * around before you have a chance to do anything about it. Consequently,
 * the receive list is terminated (with a 0 in the forward pointer in the
 * last element). Each time an RXEOF interrupt arrives, the used list
 * is shifted to the end of the list. This gives the appearance of an
 * infinitely large RX chain so long as the driver doesn't fall behind
 * the chip and allow all of the lists to be filled up.
 *
 * If all the lists are filled, the adapter will deliver an RX 'end of
 * channel' interrupt when it hits the 0 forward pointer at the end of
 * the chain. The RXEOC handler then cleans out the RX chain and resets
 * the list head pointer in the ch_parm register and restarts the receiver.
 *
 * For frame transmission, it is possible to program the ThunderLAN's
 * transmit interrupt threshold so that the chip can acknowledge multiple
 * lists with only a single TX EOF interrupt. This allows the driver to
 * queue several frames in one shot, and only have to handle a total
 * two interrupts (one TX EOF and one TX EOC) no matter how many frames
 * are transmitted. Frame transmission is done directly out of the
 * mbufs passed to the tl_start() routine via the interface send queue.
 * The driver simply sets up the fragment descriptors in the transmit
 * lists to point to the mbuf data regions and sends a TX GO command.
 *
 * Note that since the RX and TX lists themselves are always used
 * only by the driver, the are malloc()ed once at driver initialization
 * time and never free()ed.
 *
 * Also, in order to remain as platform independent as possible, this
 * driver uses memory mapped register access to manipulate the card
 * as opposed to programmed I/O. This avoids the use of the inb/outb
 * (and related) instructions which are specific to the i386 platform.
 *
 * Using these techniques, this driver achieves very high performance
 * by minimizing the amount of interrupts generated during large
 * transfers and by completely avoiding buffer copies. Frame transfer
 * to and from the ThunderLAN chip is performed entirely by the chip
 * itself thereby reducing the load on the host CPU.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/timeout.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <uvm/uvm_extern.h>              /* for vtophys */
#define	VTOPHYS(v)	vtophys((vaddr_t)(v))

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

/*
 * Default to using PIO register access mode to pacify certain
 * laptop docking stations with built-in ThunderLAN chips that
 * don't seem to handle memory mapped mode properly.
 */
#define TL_USEIOSPACE

#include <dev/pci/if_tlreg.h>
#include <dev/mii/tlphyvar.h>

const struct tl_products tl_prods[] = {
	{ PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_N100TX, TLPHY_MEDIA_NO_10_T },
	{ PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_N10T, TLPHY_MEDIA_10_5 },
	{ PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_IntNF3P, TLPHY_MEDIA_10_2 },
	{ PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_IntPL100TX, TLPHY_MEDIA_10_5|TLPHY_MEDIA_NO_10_T },
	{ PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_DPNet100TX, TLPHY_MEDIA_10_5|TLPHY_MEDIA_NO_10_T },
	{ PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_DP4000, TLPHY_MEDIA_10_5|TLPHY_MEDIA_NO_10_T },
	{ PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_NF3P_BNC, TLPHY_MEDIA_10_2 },
	{ PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_NF3P, TLPHY_MEDIA_10_5 },
	{ PCI_VENDOR_TI, PCI_PRODUCT_TI_TLAN, 0 },
	{ 0, 0, 0 }
};

int tl_probe(struct device *, void *, void *);
void tl_attach(struct device *, struct device *, void *);
void tl_wait_up(void *);
int tl_intvec_rxeoc(void *, u_int32_t);
int tl_intvec_txeoc(void *, u_int32_t);
int tl_intvec_txeof(void *, u_int32_t);
int tl_intvec_rxeof(void *, u_int32_t);
int tl_intvec_adchk(void *, u_int32_t);
int tl_intvec_netsts(void *, u_int32_t);

int tl_newbuf(struct tl_softc *, struct tl_chain_onefrag *);
void tl_stats_update(void *);
int tl_encap(struct tl_softc *, struct tl_chain *, struct mbuf *);

int tl_intr(void *);
void tl_start(struct ifnet *);
int tl_ioctl(struct ifnet *, u_long, caddr_t);
void tl_init(void *);
void tl_stop(struct tl_softc *);
void tl_watchdog(struct ifnet *);
int tl_ifmedia_upd(struct ifnet *);
void tl_ifmedia_sts(struct ifnet *, struct ifmediareq *);

u_int8_t tl_eeprom_putbyte(struct tl_softc *, int);
u_int8_t tl_eeprom_getbyte(struct tl_softc *, int, u_int8_t *);
int tl_read_eeprom(struct tl_softc *, caddr_t, int, int);

void tl_mii_sync(struct tl_softc *);
void tl_mii_send(struct tl_softc *, u_int32_t, int);
int tl_mii_readreg(struct tl_softc *, struct tl_mii_frame *);
int tl_mii_writereg(struct tl_softc *, struct tl_mii_frame *);
int tl_miibus_readreg(struct device *, int, int);
void tl_miibus_writereg(struct device *, int, int, int);
void tl_miibus_statchg(struct device *);

void tl_setmode(struct tl_softc *, uint64_t);
int tl_calchash(u_int8_t *);
void tl_iff(struct tl_softc *);
void tl_setfilt(struct tl_softc *, caddr_t, int);
void tl_softreset(struct tl_softc *, int);
void tl_hardreset(struct device *);
int tl_list_rx_init(struct tl_softc *);
int tl_list_tx_init(struct tl_softc *);

u_int8_t tl_dio_read8(struct tl_softc *, int);
u_int16_t tl_dio_read16(struct tl_softc *, int);
u_int32_t tl_dio_read32(struct tl_softc *, int);
void tl_dio_write8(struct tl_softc *, int, int);
void tl_dio_write16(struct tl_softc *, int, int);
void tl_dio_write32(struct tl_softc *, int, int);
void tl_dio_setbit(struct tl_softc *, int, int);
void tl_dio_clrbit(struct tl_softc *, int, int);
void tl_dio_setbit16(struct tl_softc *, int, int);
void tl_dio_clrbit16(struct tl_softc *, int, int);

u_int8_t
tl_dio_read8(struct tl_softc *sc, int reg)
{
	CSR_WRITE_2(sc, TL_DIO_ADDR, reg);
	return(CSR_READ_1(sc, TL_DIO_DATA + (reg & 3)));
}

u_int16_t
tl_dio_read16(struct tl_softc *sc, int reg)
{
	CSR_WRITE_2(sc, TL_DIO_ADDR, reg);
	return(CSR_READ_2(sc, TL_DIO_DATA + (reg & 3)));
}

u_int32_t
tl_dio_read32(struct tl_softc *sc, int reg)
{
	CSR_WRITE_2(sc, TL_DIO_ADDR, reg);
	return(CSR_READ_4(sc, TL_DIO_DATA + (reg & 3)));
}

void
tl_dio_write8(struct tl_softc *sc, int reg, int val)
{
	CSR_WRITE_2(sc, TL_DIO_ADDR, reg);
	CSR_WRITE_1(sc, TL_DIO_DATA + (reg & 3), val);
}

void
tl_dio_write16(struct tl_softc *sc, int reg, int val)
{
	CSR_WRITE_2(sc, TL_DIO_ADDR, reg);
	CSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), val);
}

void
tl_dio_write32(struct tl_softc *sc, int reg, int val)
{
	CSR_WRITE_2(sc, TL_DIO_ADDR, reg);
	CSR_WRITE_4(sc, TL_DIO_DATA + (reg & 3), val);
}

void
tl_dio_setbit(struct tl_softc *sc, int reg, int bit)
{
	u_int8_t			f;

	CSR_WRITE_2(sc, TL_DIO_ADDR, reg);
	f = CSR_READ_1(sc, TL_DIO_DATA + (reg & 3));
	f |= bit;
	CSR_WRITE_1(sc, TL_DIO_DATA + (reg & 3), f);
}

void
tl_dio_clrbit(struct tl_softc *sc, int reg, int bit)
{
	u_int8_t			f;

	CSR_WRITE_2(sc, TL_DIO_ADDR, reg);
	f = CSR_READ_1(sc, TL_DIO_DATA + (reg & 3));
	f &= ~bit;
	CSR_WRITE_1(sc, TL_DIO_DATA + (reg & 3), f);
}

void
tl_dio_setbit16(struct tl_softc *sc, int reg, int bit)
{
	u_int16_t			f;

	CSR_WRITE_2(sc, TL_DIO_ADDR, reg);
	f = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));
	f |= bit;
	CSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);
}

void
tl_dio_clrbit16(struct tl_softc *sc, int reg, int bit)
{
	u_int16_t			f;

	CSR_WRITE_2(sc, TL_DIO_ADDR, reg);
	f = CSR_READ_2(sc, TL_DIO_DATA + (reg & 3));
	f &= ~bit;
	CSR_WRITE_2(sc, TL_DIO_DATA + (reg & 3), f);
}

/*
 * Send an instruction or address to the EEPROM, check for ACK.
 */
u_int8_t
tl_eeprom_putbyte(struct tl_softc *sc, int byte)
{
	int			i, ack = 0;

	/*
	 * Make sure we're in TX mode.
	 */
	tl_dio_setbit(sc, TL_NETSIO, TL_SIO_ETXEN);

	/*
	 * Feed in each bit and strobe the clock.
	 */
	for (i = 0x80; i; i >>= 1) {
		if (byte & i)
			tl_dio_setbit(sc, TL_NETSIO, TL_SIO_EDATA);
		else
			tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_EDATA);
		DELAY(1);
		tl_dio_setbit(sc, TL_NETSIO, TL_SIO_ECLOK);
		DELAY(1);
		tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ECLOK);
	}

	/*
	 * Turn off TX mode.
	 */
	tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ETXEN);

	/*
	 * Check for ack.
	 */
	tl_dio_setbit(sc, TL_NETSIO, TL_SIO_ECLOK);
	ack = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_EDATA;
	tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ECLOK);

	return(ack);
}

/*
 * Read a byte of data stored in the EEPROM at address 'addr.'
 */
u_int8_t
tl_eeprom_getbyte(struct tl_softc *sc, int addr, u_int8_t *dest)
{
	int			i;
	u_int8_t		byte = 0;

	tl_dio_write8(sc, TL_NETSIO, 0);

	EEPROM_START;

	/*
	 * Send write control code to EEPROM.
	 */
	if (tl_eeprom_putbyte(sc, EEPROM_CTL_WRITE)) {
		printf("%s: failed to send write command, status: %x\n",
			sc->sc_dev.dv_xname, tl_dio_read8(sc, TL_NETSIO));
		return(1);
	}

	/*
	 * Send address of byte we want to read.
	 */
	if (tl_eeprom_putbyte(sc, addr)) {
		printf("%s: failed to send address, status: %x\n",
			sc->sc_dev.dv_xname, tl_dio_read8(sc, TL_NETSIO));
		return(1);
	}

	EEPROM_STOP;
	EEPROM_START;
	/*
	 * Send read control code to EEPROM.
	 */
	if (tl_eeprom_putbyte(sc, EEPROM_CTL_READ)) {
		printf("%s: failed to send write command, status: %x\n",
			sc->sc_dev.dv_xname, tl_dio_read8(sc, TL_NETSIO));
		return(1);
	}

	/*
	 * Start reading bits from EEPROM.
	 */
	tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ETXEN);
	for (i = 0x80; i; i >>= 1) {
		tl_dio_setbit(sc, TL_NETSIO, TL_SIO_ECLOK);
		DELAY(1);
		if (tl_dio_read8(sc, TL_NETSIO) & TL_SIO_EDATA)
			byte |= i;
		tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_ECLOK);
		DELAY(1);
	}

	EEPROM_STOP;

	/*
	 * No ACK generated for read, so just return byte.
	 */

	*dest = byte;

	return(0);
}

/*
 * Read a sequence of bytes from the EEPROM.
 */
int
tl_read_eeprom(struct tl_softc *sc, caddr_t dest, int off, int cnt)
{
	int			err = 0, i;
	u_int8_t		byte = 0;

	for (i = 0; i < cnt; i++) {
		err = tl_eeprom_getbyte(sc, off + i, &byte);
		if (err)
			break;
		*(dest + i) = byte;
	}

	return(err ? 1 : 0);
}

void
tl_mii_sync(struct tl_softc *sc)
{
	int			i;

	tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);

	for (i = 0; i < 32; i++) {
		tl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);
		tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);
	}
}

void
tl_mii_send(struct tl_softc *sc, u_int32_t bits, int cnt)
{
	int			i;

	for (i = (0x1 << (cnt - 1)); i; i >>= 1) {
		tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);
		if (bits & i)
			tl_dio_setbit(sc, TL_NETSIO, TL_SIO_MDATA);
		else
			tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MDATA);
		tl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);
	}
}

int
tl_mii_readreg(struct tl_softc *sc, struct tl_mii_frame *frame)
{
	int			i, ack, s;
	int			minten = 0;

	s = splnet();

	tl_mii_sync(sc);

	/*
	 * Set up frame for RX.
	 */
	frame->mii_stdelim = TL_MII_STARTDELIM;
	frame->mii_opcode = TL_MII_READOP;
	frame->mii_turnaround = 0;
	frame->mii_data = 0;
	
	/*
	 * Turn off MII interrupt by forcing MINTEN low.
	 */
	minten = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MINTEN;
	if (minten)
		tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);

	/*
 	 * Turn on data xmit.
	 */
	tl_dio_setbit(sc, TL_NETSIO, TL_SIO_MTXEN);

	/*
	 * Send command/address info.
	 */
	tl_mii_send(sc, frame->mii_stdelim, 2);
	tl_mii_send(sc, frame->mii_opcode, 2);
	tl_mii_send(sc, frame->mii_phyaddr, 5);
	tl_mii_send(sc, frame->mii_regaddr, 5);

	/*
	 * Turn off xmit.
	 */
	tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);

	/* Idle bit */
	tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);
	tl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);

	/* Check for ack */
	tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);
	ack = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MDATA;

	/* Complete the cycle */
	tl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);

	/*
	 * Now try reading data bits. If the ack failed, we still
	 * need to clock through 16 cycles to keep the PHYs in sync.
	 */
	if (ack) {
		for(i = 0; i < 16; i++) {
			tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);
			tl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);
		}
		goto fail;
	}

	for (i = 0x8000; i; i >>= 1) {
		tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);
		if (!ack) {
			if (tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MDATA)
				frame->mii_data |= i;
		}
		tl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);
	}

fail:

	tl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);
	tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);

	/* Reenable interrupts */
	if (minten)
		tl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);

	splx(s);

	if (ack)
		return(1);
	return(0);
}

int
tl_mii_writereg(struct tl_softc *sc, struct tl_mii_frame *frame)
{
	int			s;
	int			minten;

	tl_mii_sync(sc);

	s = splnet();
	/*
	 * Set up frame for TX.
	 */

	frame->mii_stdelim = TL_MII_STARTDELIM;
	frame->mii_opcode = TL_MII_WRITEOP;
	frame->mii_turnaround = TL_MII_TURNAROUND;
	
	/*
	 * Turn off MII interrupt by forcing MINTEN low.
	 */
	minten = tl_dio_read8(sc, TL_NETSIO) & TL_SIO_MINTEN;
	if (minten)
		tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);

	/*
 	 * Turn on data output.
	 */
	tl_dio_setbit(sc, TL_NETSIO, TL_SIO_MTXEN);

	tl_mii_send(sc, frame->mii_stdelim, 2);
	tl_mii_send(sc, frame->mii_opcode, 2);
	tl_mii_send(sc, frame->mii_phyaddr, 5);
	tl_mii_send(sc, frame->mii_regaddr, 5);
	tl_mii_send(sc, frame->mii_turnaround, 2);
	tl_mii_send(sc, frame->mii_data, 16);

	tl_dio_setbit(sc, TL_NETSIO, TL_SIO_MCLK);
	tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MCLK);

	/*
	 * Turn off xmit.
	 */
	tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MTXEN);

	/* Reenable interrupts */
	if (minten)
		tl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);

	splx(s);

	return(0);
}

int
tl_miibus_readreg(struct device *dev, int phy, int reg)
{
	struct tl_softc *sc = (struct tl_softc *)dev;
	struct tl_mii_frame	frame;

	bzero(&frame, sizeof(frame));

	frame.mii_phyaddr = phy;
	frame.mii_regaddr = reg;
	tl_mii_readreg(sc, &frame);

	return(frame.mii_data);
}

void
tl_miibus_writereg(struct device *dev, int phy, int reg, int data)
{
	struct tl_softc *sc = (struct tl_softc *)dev;
	struct tl_mii_frame	frame;

	bzero(&frame, sizeof(frame));

	frame.mii_phyaddr = phy;
	frame.mii_regaddr = reg;
	frame.mii_data = data;

	tl_mii_writereg(sc, &frame);
}

void
tl_miibus_statchg(struct device *dev)
{
	struct tl_softc *sc = (struct tl_softc *)dev;

	if ((sc->sc_mii.mii_media_active & IFM_GMASK) == IFM_FDX)
		tl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);
	else
		tl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);
}

/*
 * Set modes for bitrate devices.
 */
void
tl_setmode(struct tl_softc *sc, uint64_t media)
{
	if (IFM_SUBTYPE(media) == IFM_10_5)
		tl_dio_setbit(sc, TL_ACOMMIT, TL_AC_MTXD1);
	if (IFM_SUBTYPE(media) == IFM_10_T) {
		tl_dio_clrbit(sc, TL_ACOMMIT, TL_AC_MTXD1);
		if ((media & IFM_GMASK) == IFM_FDX) {
			tl_dio_clrbit(sc, TL_ACOMMIT, TL_AC_MTXD3);
			tl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);
		} else {
			tl_dio_setbit(sc, TL_ACOMMIT, TL_AC_MTXD3);
			tl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);
		}
	}
}

/*
 * Calculate the hash of a MAC address for programming the multicast hash
 * table.  This hash is simply the address split into 6-bit chunks
 * XOR'd, e.g.
 * byte: 000000|00 1111|1111 22|222222|333333|33 4444|4444 55|555555
 * bit:  765432|10 7654|3210 76|543210|765432|10 7654|3210 76|543210
 * Bytes 0-2 and 3-5 are symmetrical, so are folded together.  Then
 * the folded 24-bit value is split into 6-bit portions and XOR'd.
 */
int
tl_calchash(u_int8_t *addr)
{
	int			t;

	t = (addr[0] ^ addr[3]) << 16 | (addr[1] ^ addr[4]) << 8 |
		(addr[2] ^ addr[5]);
	return ((t >> 18) ^ (t >> 12) ^ (t >> 6) ^ t) & 0x3f;
}

/*
 * The ThunderLAN has a perfect MAC address filter in addition to
 * the multicast hash filter. The perfect filter can be programmed
 * with up to four MAC addresses. The first one is always used to
 * hold the station address, which leaves us free to use the other
 * three for multicast addresses.
 */
void
tl_setfilt(struct tl_softc *sc, caddr_t addr, int slot)
{
	int			i;
	u_int16_t		regaddr;

	regaddr = TL_AREG0_B5 + (slot * ETHER_ADDR_LEN);

	for (i = 0; i < ETHER_ADDR_LEN; i++)
		tl_dio_write8(sc, regaddr + i, *(addr + i));
}

/*
 * XXX In FreeBSD 3.0, multicast addresses are managed using a doubly
 * linked list. This is fine, except addresses are added from the head
 * end of the list. We want to arrange for 224.0.0.1 (the "all hosts")
 * group to always be in the perfect filter, but as more groups are added,
 * the 224.0.0.1 entry (which is always added first) gets pushed down
 * the list and ends up at the tail. So after 3 or 4 multicast groups
 * are added, the all-hosts entry gets pushed out of the perfect filter
 * and into the hash table.
 *
 * Because the multicast list is a doubly-linked list as opposed to a
 * circular queue, we don't have the ability to just grab the tail of
 * the list and traverse it backwards. Instead, we have to traverse
 * the list once to find the tail, then traverse it again backwards to
 * update the multicast filter.
 */
void
tl_iff(struct tl_softc *sc)
{
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	struct arpcom		*ac = &sc->arpcom;
	struct ether_multistep step;
	struct ether_multi *enm;
	u_int32_t		hashes[2];
	int			h = 0;

	tl_dio_clrbit(sc, TL_NETCMD, (TL_CMD_CAF | TL_CMD_NOBRX));
	bzero(hashes, sizeof(hashes));
	ifp->if_flags &= ~IFF_ALLMULTI;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		if (ifp->if_flags & IFF_PROMISC)
			tl_dio_setbit(sc, TL_NETCMD, TL_CMD_CAF);
		else
			hashes[0] = hashes[1] = 0xffffffff;
	} else {
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = tl_calchash(enm->enm_addrlo);

			if (h < 32)
				hashes[0] |= (1 << h);
			else
				hashes[1] |= (1 << (h - 32));

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	tl_dio_write32(sc, TL_HASH1, hashes[0]);
	tl_dio_write32(sc, TL_HASH2, hashes[1]);
}

/*
 * This routine is recommended by the ThunderLAN manual to insure that
 * the internal PHY is powered up correctly. It also recommends a one
 * second pause at the end to 'wait for the clocks to start' but in my
 * experience this isn't necessary.
 */
void
tl_hardreset(struct device *dev)
{
	struct tl_softc		*sc = (struct tl_softc *)dev;
	int			i;
	u_int16_t		flags;

	flags = BMCR_LOOP|BMCR_ISO|BMCR_PDOWN;

	for (i =0 ; i < MII_NPHY; i++)
		tl_miibus_writereg(dev, i, MII_BMCR, flags);

	tl_miibus_writereg(dev, 31, MII_BMCR, BMCR_ISO);
	tl_mii_sync(sc);
	while(tl_miibus_readreg(dev, 31, MII_BMCR) & BMCR_RESET);

	DELAY(5000);
}

void
tl_softreset(struct tl_softc *sc, int internal)
{
        u_int32_t               cmd, dummy, i;

        /* Assert the adapter reset bit. */
	CMD_SET(sc, TL_CMD_ADRST);
        /* Turn off interrupts */
	CMD_SET(sc, TL_CMD_INTSOFF);

	/* First, clear the stats registers. */
	for (i = 0; i < 5; i++)
		dummy = tl_dio_read32(sc, TL_TXGOODFRAMES);

        /* Clear Areg and Hash registers */
	for (i = 0; i < 8; i++)
		tl_dio_write32(sc, TL_AREG0_B5, 0x00000000);

        /*
	 * Set up Netconfig register. Enable one channel and
	 * one fragment mode.
	 */
	tl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_ONECHAN|TL_CFG_ONEFRAG);
	if (internal && !sc->tl_bitrate) {
		tl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_PHYEN);
	} else {
		tl_dio_clrbit16(sc, TL_NETCONFIG, TL_CFG_PHYEN);
	}

	/* Handle cards with bitrate devices. */
	if (sc->tl_bitrate)
		tl_dio_setbit16(sc, TL_NETCONFIG, TL_CFG_BITRATE);

	/*
	 * Load adapter irq pacing timer and tx threshold.
	 * We make the transmit threshold 1 initially but we may
	 * change that later.
	 */
	cmd = CSR_READ_4(sc, TL_HOSTCMD);
	cmd |= TL_CMD_NES;
	cmd &= ~(TL_CMD_RT|TL_CMD_EOC|TL_CMD_ACK_MASK|TL_CMD_CHSEL_MASK);
	CMD_PUT(sc, cmd | (TL_CMD_LDTHR | TX_THR));
	CMD_PUT(sc, cmd | (TL_CMD_LDTMR | 0x00000003));

        /* Unreset the MII */
	tl_dio_setbit(sc, TL_NETSIO, TL_SIO_NMRST);

	/* Take the adapter out of reset */
	tl_dio_setbit(sc, TL_NETCMD, TL_CMD_NRESET|TL_CMD_NWRAP);

	/* Wait for things to settle down a little. */
	DELAY(500);
}

/*
 * Initialize the transmit lists.
 */
int
tl_list_tx_init(struct tl_softc *sc)
{
	struct tl_chain_data	*cd;
	struct tl_list_data	*ld;
	int			i;

	cd = &sc->tl_cdata;
	ld = sc->tl_ldata;
	for (i = 0; i < TL_TX_LIST_CNT; i++) {
		cd->tl_tx_chain[i].tl_ptr = &ld->tl_tx_list[i];
		if (i == (TL_TX_LIST_CNT - 1))
			cd->tl_tx_chain[i].tl_next = NULL;
		else
			cd->tl_tx_chain[i].tl_next = &cd->tl_tx_chain[i + 1];
	}

	cd->tl_tx_free = &cd->tl_tx_chain[0];
	cd->tl_tx_tail = cd->tl_tx_head = NULL;
	sc->tl_txeoc = 1;

	return(0);
}

/*
 * Initialize the RX lists and allocate mbufs for them.
 */
int
tl_list_rx_init(struct tl_softc *sc)
{
	struct tl_chain_data	*cd;
	struct tl_list_data	*ld;
	int			i;

	cd = &sc->tl_cdata;
	ld = sc->tl_ldata;

	for (i = 0; i < TL_RX_LIST_CNT; i++) {
		cd->tl_rx_chain[i].tl_ptr =
			(struct tl_list_onefrag *)&ld->tl_rx_list[i];
		if (tl_newbuf(sc, &cd->tl_rx_chain[i]) == ENOBUFS)
			return(ENOBUFS);
		if (i == (TL_RX_LIST_CNT - 1)) {
			cd->tl_rx_chain[i].tl_next = NULL;
			ld->tl_rx_list[i].tlist_fptr = 0;
		} else {
			cd->tl_rx_chain[i].tl_next = &cd->tl_rx_chain[i + 1];
			ld->tl_rx_list[i].tlist_fptr =
					VTOPHYS(&ld->tl_rx_list[i + 1]);
		}
	}

	cd->tl_rx_head = &cd->tl_rx_chain[0];
	cd->tl_rx_tail = &cd->tl_rx_chain[TL_RX_LIST_CNT - 1];

	return(0);
}

int
tl_newbuf(struct tl_softc *sc, struct tl_chain_onefrag *c)
{
	struct mbuf		*m_new = NULL;

	MGETHDR(m_new, M_DONTWAIT, MT_DATA);
	if (m_new == NULL) {
		return(ENOBUFS);
	}

	MCLGET(m_new, M_DONTWAIT);
	if (!(m_new->m_flags & M_EXT)) {
		m_freem(m_new);
		return(ENOBUFS);
	}

#ifdef __alpha__
	m_new->m_data += 2;
#endif

	c->tl_mbuf = m_new;
	c->tl_next = NULL;
	c->tl_ptr->tlist_frsize = MCLBYTES;
	c->tl_ptr->tlist_fptr = 0;
	c->tl_ptr->tl_frag.tlist_dadr = VTOPHYS(mtod(m_new, caddr_t));
	c->tl_ptr->tl_frag.tlist_dcnt = MCLBYTES;
	c->tl_ptr->tlist_cstat = TL_CSTAT_READY;

	return(0);
}
/*
 * Interrupt handler for RX 'end of frame' condition (EOF). This
 * tells us that a full ethernet frame has been captured and we need
 * to handle it.
 *
 * Reception is done using 'lists' which consist of a header and a
 * series of 10 data count/data address pairs that point to buffers.
 * Initially you're supposed to create a list, populate it with pointers
 * to buffers, then load the physical address of the list into the
 * ch_parm register. The adapter is then supposed to DMA the received
 * frame into the buffers for you.
 *
 * To make things as fast as possible, we have the chip DMA directly
 * into mbufs. This saves us from having to do a buffer copy: we can
 * just hand the mbufs directly to the network stack. Once the frame
 * has been sent on its way, the 'list' structure is assigned a new
 * buffer and moved to the end of the RX chain. As long we we stay
 * ahead of the chip, it will always think it has an endless receive
 * channel.
 *
 * If we happen to fall behind and the chip manages to fill up all of
 * the buffers, it will generate an end of channel interrupt and wait
 * for us to empty the chain and restart the receiver.
 */
int
tl_intvec_rxeof(void *xsc, u_int32_t type)
{
	struct tl_softc		*sc;
	int			r = 0, total_len = 0;
	struct ether_header	*eh;
	struct mbuf		*m;
	struct mbuf_list	ml = MBUF_LIST_INITIALIZER();
	struct ifnet		*ifp;
	struct tl_chain_onefrag	*cur_rx;

	sc = xsc;
	ifp = &sc->arpcom.ac_if;

	while(sc->tl_cdata.tl_rx_head != NULL) {
		cur_rx = sc->tl_cdata.tl_rx_head;
		if (!(cur_rx->tl_ptr->tlist_cstat & TL_CSTAT_FRAMECMP))
			break;
		r++;
		sc->tl_cdata.tl_rx_head = cur_rx->tl_next;
		m = cur_rx->tl_mbuf;
		total_len = cur_rx->tl_ptr->tlist_frsize;

		if (tl_newbuf(sc, cur_rx) == ENOBUFS) {
			ifp->if_ierrors++;
			cur_rx->tl_ptr->tlist_frsize = MCLBYTES;
			cur_rx->tl_ptr->tlist_cstat = TL_CSTAT_READY;
			cur_rx->tl_ptr->tl_frag.tlist_dcnt = MCLBYTES;
			continue;
		}

		sc->tl_cdata.tl_rx_tail->tl_ptr->tlist_fptr =
						VTOPHYS(cur_rx->tl_ptr);
		sc->tl_cdata.tl_rx_tail->tl_next = cur_rx;
		sc->tl_cdata.tl_rx_tail = cur_rx;

		eh = mtod(m, struct ether_header *);

		/*
		 * Note: when the ThunderLAN chip is in 'capture all
		 * frames' mode, it will receive its own transmissions.
		 * We drop don't need to process our own transmissions,
		 * so we drop them here and continue.
		 */
		/*if (ifp->if_flags & IFF_PROMISC && */
		if (!bcmp(eh->ether_shost, sc->arpcom.ac_enaddr,
		 					ETHER_ADDR_LEN)) {
				m_freem(m);
				continue;
		}

		m->m_pkthdr.len = m->m_len = total_len;
		ml_enqueue(&ml, m);
	}

	if_input(ifp, &ml);

	return(r);
}

/*
 * The RX-EOC condition hits when the ch_parm address hasn't been
 * initialized or the adapter reached a list with a forward pointer
 * of 0 (which indicates the end of the chain). In our case, this means
 * the card has hit the end of the receive buffer chain and we need to
 * empty out the buffers and shift the pointer back to the beginning again.
 */
int
tl_intvec_rxeoc(void *xsc, u_int32_t type)
{
	struct tl_softc		*sc;
	int			r;
	struct tl_chain_data	*cd;

	sc = xsc;
	cd = &sc->tl_cdata;

	/* Flush out the receive queue and ack RXEOF interrupts. */
	r = tl_intvec_rxeof(xsc, type);
	CMD_PUT(sc, TL_CMD_ACK | r | (type & ~(0x00100000)));
	r = 1;
	cd->tl_rx_head = &cd->tl_rx_chain[0];
	cd->tl_rx_tail = &cd->tl_rx_chain[TL_RX_LIST_CNT - 1];
	CSR_WRITE_4(sc, TL_CH_PARM, VTOPHYS(sc->tl_cdata.tl_rx_head->tl_ptr));
	r |= (TL_CMD_GO|TL_CMD_RT);
	return(r);
}

int
tl_intvec_txeof(void *xsc, u_int32_t type)
{
	struct tl_softc		*sc;
	int			r = 0;
	struct tl_chain		*cur_tx;

	sc = xsc;

	/*
	 * Go through our tx list and free mbufs for those
	 * frames that have been sent.
	 */
	while (sc->tl_cdata.tl_tx_head != NULL) {
		cur_tx = sc->tl_cdata.tl_tx_head;
		if (!(cur_tx->tl_ptr->tlist_cstat & TL_CSTAT_FRAMECMP))
			break;
		sc->tl_cdata.tl_tx_head = cur_tx->tl_next;

		r++;
		m_freem(cur_tx->tl_mbuf);
		cur_tx->tl_mbuf = NULL;

		cur_tx->tl_next = sc->tl_cdata.tl_tx_free;
		sc->tl_cdata.tl_tx_free = cur_tx;
		if (!cur_tx->tl_ptr->tlist_fptr)
			break;
	}

	return(r);
}

/*
 * The transmit end of channel interrupt. The adapter triggers this
 * interrupt to tell us it hit the end of the current transmit list.
 *
 * A note about this: it's possible for a condition to arise where
 * tl_start() may try to send frames between TXEOF and TXEOC interrupts.
 * You have to avoid this since the chip expects things to go in a
 * particular order: transmit, acknowledge TXEOF, acknowledge TXEOC.
 * When the TXEOF handler is called, it will free all of the transmitted
 * frames and reset the tx_head pointer to NULL. However, a TXEOC
 * interrupt should be received and acknowledged before any more frames
 * are queued for transmission. If tl_statrt() is called after TXEOF
 * resets the tx_head pointer but _before_ the TXEOC interrupt arrives,
 * it could attempt to issue a transmit command prematurely.
 *
 * To guard against this, tl_start() will only issue transmit commands
 * if the tl_txeoc flag is set, and only the TXEOC interrupt handler
 * can set this flag once tl_start() has cleared it.
 */
int
tl_intvec_txeoc(void *xsc, u_int32_t type)
{
	struct tl_softc		*sc;
	struct ifnet		*ifp;
	u_int32_t		cmd;

	sc = xsc;
	ifp = &sc->arpcom.ac_if;

	/* Clear the timeout timer. */
	ifp->if_timer = 0;

	if (sc->tl_cdata.tl_tx_head == NULL) {
		ifq_clr_oactive(&ifp->if_snd);
		sc->tl_cdata.tl_tx_tail = NULL;
		sc->tl_txeoc = 1;
	} else {
		sc->tl_txeoc = 0;
		/* First we have to ack the EOC interrupt. */
		CMD_PUT(sc, TL_CMD_ACK | 0x00000001 | type);
		/* Then load the address of the next TX list. */
		CSR_WRITE_4(sc, TL_CH_PARM,
		    VTOPHYS(sc->tl_cdata.tl_tx_head->tl_ptr));
		/* Restart TX channel. */
		cmd = CSR_READ_4(sc, TL_HOSTCMD);
		cmd &= ~TL_CMD_RT;
		cmd |= TL_CMD_GO|TL_CMD_INTSON;
		CMD_PUT(sc, cmd);
		return(0);
	}

	return(1);
}

int
tl_intvec_adchk(void *xsc, u_int32_t type)
{
	struct tl_softc		*sc;

	sc = xsc;

	if (type)
		printf("%s: adapter check: %x\n", sc->sc_dev.dv_xname,
			(unsigned int)CSR_READ_4(sc, TL_CH_PARM));

	tl_softreset(sc, 1);
	tl_stop(sc);
	tl_init(sc);
	CMD_SET(sc, TL_CMD_INTSON);

	return(0);
}

int
tl_intvec_netsts(void *xsc, u_int32_t type)
{
	struct tl_softc		*sc;
	u_int16_t		netsts;

	sc = xsc;

	netsts = tl_dio_read16(sc, TL_NETSTS);
	tl_dio_write16(sc, TL_NETSTS, netsts);

	printf("%s: network status: %x\n", sc->sc_dev.dv_xname, netsts);

	return(1);
}

int
tl_intr(void *xsc)
{
	struct tl_softc		*sc;
	struct ifnet		*ifp;
	int			r = 0;
	u_int32_t		type = 0;
	u_int16_t		ints = 0;
	u_int8_t		ivec = 0;

	sc = xsc;

	/* Disable interrupts */
	ints = CSR_READ_2(sc, TL_HOST_INT);
	CSR_WRITE_2(sc, TL_HOST_INT, ints);
	type = (ints << 16) & 0xFFFF0000;
	ivec = (ints & TL_VEC_MASK) >> 5;
	ints = (ints & TL_INT_MASK) >> 2;

	ifp = &sc->arpcom.ac_if;

	switch(ints) {
	case (TL_INTR_INVALID):
		/* Re-enable interrupts but don't ack this one. */
		CMD_PUT(sc, type);
		r = 0;
		break;
	case (TL_INTR_TXEOF):
		r = tl_intvec_txeof((void *)sc, type);
		break;
	case (TL_INTR_TXEOC):
		r = tl_intvec_txeoc((void *)sc, type);
		break;
	case (TL_INTR_STATOFLOW):
		tl_stats_update(sc);
		r = 1;
		break;
	case (TL_INTR_RXEOF):
		r = tl_intvec_rxeof((void *)sc, type);
		break;
	case (TL_INTR_DUMMY):
		printf("%s: got a dummy interrupt\n", sc->sc_dev.dv_xname);
		r = 1;
		break;
	case (TL_INTR_ADCHK):
		if (ivec)
			r = tl_intvec_adchk((void *)sc, type);
		else
			r = tl_intvec_netsts((void *)sc, type);
		break;
	case (TL_INTR_RXEOC):
		r = tl_intvec_rxeoc((void *)sc, type);
		break;
	default:
		printf("%s: bogus interrupt type\n", sc->sc_dev.dv_xname);
		break;
	}

	/* Re-enable interrupts */
	if (r) {
		CMD_PUT(sc, TL_CMD_ACK | r | type);
	}

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		tl_start(ifp);

	return r;
}

void
tl_stats_update(void *xsc)
{
	struct tl_softc		*sc;
	struct ifnet		*ifp;
	struct tl_stats		tl_stats;
	u_int32_t		*p;
	int			s;

	s = splnet();

	bzero(&tl_stats, sizeof(struct tl_stats));

	sc = xsc;
	ifp = &sc->arpcom.ac_if;

	p = (u_int32_t *)&tl_stats;

	CSR_WRITE_2(sc, TL_DIO_ADDR, TL_TXGOODFRAMES|TL_DIO_ADDR_INC);
	*p++ = CSR_READ_4(sc, TL_DIO_DATA);
	*p++ = CSR_READ_4(sc, TL_DIO_DATA);
	*p++ = CSR_READ_4(sc, TL_DIO_DATA);
	*p++ = CSR_READ_4(sc, TL_DIO_DATA);
	*p++ = CSR_READ_4(sc, TL_DIO_DATA);

	ifp->if_collisions += tl_stats.tl_tx_single_collision +
				tl_stats.tl_tx_multi_collision;
	ifp->if_ierrors += tl_stats.tl_crc_errors + tl_stats.tl_code_errors +
			    tl_rx_overrun(tl_stats);
	ifp->if_oerrors += tl_tx_underrun(tl_stats);

	if (tl_tx_underrun(tl_stats)) {
		u_int8_t	tx_thresh;
		tx_thresh = tl_dio_read8(sc, TL_ACOMMIT) & TL_AC_TXTHRESH;
		if (tx_thresh != TL_AC_TXTHRESH_WHOLEPKT) {
			tx_thresh >>= 4;
			tx_thresh++;
			tl_dio_clrbit(sc, TL_ACOMMIT, TL_AC_TXTHRESH);
			tl_dio_setbit(sc, TL_ACOMMIT, tx_thresh << 4);
		}
	}

	timeout_add_sec(&sc->tl_stats_tmo, 1);

	if (!sc->tl_bitrate)
		mii_tick(&sc->sc_mii);

	splx(s);
}

/*
 * Encapsulate an mbuf chain in a list by coupling the mbuf data
 * pointers to the fragment pointers.
 */
int
tl_encap(struct tl_softc *sc, struct tl_chain *c, struct mbuf *m_head)
{
	int			frag = 0;
	struct tl_frag		*f = NULL;
	int			total_len;
	struct mbuf		*m;

	/*
 	 * Start packing the mbufs in this chain into
	 * the fragment pointers. Stop when we run out
 	 * of fragments or hit the end of the mbuf chain.
	 */
	m = m_head;
	total_len = 0;

	for (m = m_head, frag = 0; m != NULL; m = m->m_next) {
		if (m->m_len != 0) {
			if (frag == TL_MAXFRAGS)
				break;
			total_len+= m->m_len;
			c->tl_ptr->tl_frag[frag].tlist_dadr =
				VTOPHYS(mtod(m, vaddr_t));
			c->tl_ptr->tl_frag[frag].tlist_dcnt = m->m_len;
			frag++;
		}
	}

	/*
	 * Handle special cases.
	 * Special case #1: we used up all 10 fragments, but
	 * we have more mbufs left in the chain. Copy the
	 * data into an mbuf cluster. Note that we don't
	 * bother clearing the values in the other fragment
	 * pointers/counters; it wouldn't gain us anything,
	 * and would waste cycles.
	 */
	if (m != NULL) {
		struct mbuf		*m_new = NULL;

		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return(1);
		if (m_head->m_pkthdr.len > MHLEN) {
			MCLGET(m_new, M_DONTWAIT);
			if (!(m_new->m_flags & M_EXT)) {
				m_freem(m_new);
				return(1);
			}
		}
		m_copydata(m_head, 0, m_head->m_pkthdr.len,	
					mtod(m_new, caddr_t));
		m_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;
		m_freem(m_head);
		m_head = m_new;
		f = &c->tl_ptr->tl_frag[0];
		f->tlist_dadr = VTOPHYS(mtod(m_new, caddr_t));
		f->tlist_dcnt = total_len = m_new->m_len;
		frag = 1;
	}

	/*
	 * Special case #2: the frame is smaller than the minimum
	 * frame size. We have to pad it to make the chip happy.
	 */
	if (total_len < TL_MIN_FRAMELEN) {
		f = &c->tl_ptr->tl_frag[frag];
		f->tlist_dcnt = TL_MIN_FRAMELEN - total_len;
		f->tlist_dadr = VTOPHYS(&sc->tl_ldata->tl_pad);
		total_len += f->tlist_dcnt;
		frag++;
	}

	c->tl_mbuf = m_head;
	c->tl_ptr->tl_frag[frag - 1].tlist_dcnt |= TL_LAST_FRAG;
	c->tl_ptr->tlist_frsize = total_len;
	c->tl_ptr->tlist_cstat = TL_CSTAT_READY;
	c->tl_ptr->tlist_fptr = 0;

	return(0);
}

/*
 * Main transmit routine. To avoid having to do mbuf copies, we put pointers
 * to the mbuf data regions directly in the transmit lists. We also save a
 * copy of the pointers since the transmit list fragment pointers are
 * physical addresses.
 */
void
tl_start(struct ifnet *ifp)
{
	struct tl_softc		*sc;
	struct mbuf		*m_head = NULL;
	u_int32_t		cmd;
	struct tl_chain		*prev = NULL, *cur_tx = NULL, *start_tx;

	sc = ifp->if_softc;

	/*
	 * Check for an available queue slot. If there are none,
	 * punt.
	 */
	if (sc->tl_cdata.tl_tx_free == NULL) {
		ifq_set_oactive(&ifp->if_snd);
		return;
	}

	start_tx = sc->tl_cdata.tl_tx_free;

	while(sc->tl_cdata.tl_tx_free != NULL) {
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
		if (m_head == NULL)
			break;

		/* Pick a chain member off the free list. */
		cur_tx = sc->tl_cdata.tl_tx_free;
		sc->tl_cdata.tl_tx_free = cur_tx->tl_next;

		cur_tx->tl_next = NULL;

		/* Pack the data into the list. */
		tl_encap(sc, cur_tx, m_head);

		/* Chain it together */
		if (prev != NULL) {
			prev->tl_next = cur_tx;
			prev->tl_ptr->tlist_fptr = VTOPHYS(cur_tx->tl_ptr);
		}
		prev = cur_tx;

		/*
		 * If there's a BPF listener, bounce a copy of this frame
		 * to him.
		 */
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, cur_tx->tl_mbuf,
			    BPF_DIRECTION_OUT);
#endif
	}

	/*
	 * If there are no packets queued, bail.
	 */
	if (cur_tx == NULL)
		return;

	/*
	 * That's all we can stands, we can't stands no more.
	 * If there are no other transfers pending, then issue the
	 * TX GO command to the adapter to start things moving.
	 * Otherwise, just leave the data in the queue and let
	 * the EOF/EOC interrupt handler send.
	 */
	if (sc->tl_cdata.tl_tx_head == NULL) {
		sc->tl_cdata.tl_tx_head = start_tx;
		sc->tl_cdata.tl_tx_tail = cur_tx;

		if (sc->tl_txeoc) {
			sc->tl_txeoc = 0;
			CSR_WRITE_4(sc, TL_CH_PARM, VTOPHYS(start_tx->tl_ptr));
			cmd = CSR_READ_4(sc, TL_HOSTCMD);
			cmd &= ~TL_CMD_RT;
			cmd |= TL_CMD_GO|TL_CMD_INTSON;
			CMD_PUT(sc, cmd);
		}
	} else {
		sc->tl_cdata.tl_tx_tail->tl_next = start_tx;
		sc->tl_cdata.tl_tx_tail = cur_tx;
	}

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 10;
}

void
tl_init(void *xsc)
{
	struct tl_softc		*sc = xsc;
	struct ifnet		*ifp = &sc->arpcom.ac_if;
        int			s;

	s = splnet();

	/*
	 * Cancel pending I/O.
	 */
	tl_stop(sc);

	/* Initialize TX FIFO threshold */
	tl_dio_clrbit(sc, TL_ACOMMIT, TL_AC_TXTHRESH);
	tl_dio_setbit(sc, TL_ACOMMIT, TL_AC_TXTHRESH_16LONG);

	/* Set PCI burst size */
	tl_dio_write8(sc, TL_BSIZEREG, TL_RXBURST_16LONG|TL_TXBURST_16LONG);

	tl_dio_write16(sc, TL_MAXRX, MCLBYTES);

	/* Init our MAC address */
	tl_setfilt(sc, (caddr_t)&sc->arpcom.ac_enaddr, 0);

	/* Program promiscuous mode and multicast filters. */
	tl_iff(sc);

	/* Init circular RX list. */
	if (tl_list_rx_init(sc) == ENOBUFS) {
		printf("%s: initialization failed: no memory for rx buffers\n",
			sc->sc_dev.dv_xname);
		tl_stop(sc);
		splx(s);
		return;
	}

	/* Init TX pointers. */
	tl_list_tx_init(sc);

	/* Enable PCI interrupts. */
	CMD_SET(sc, TL_CMD_INTSON);

	/* Load the address of the rx list */
	CMD_SET(sc, TL_CMD_RT);
	CSR_WRITE_4(sc, TL_CH_PARM, VTOPHYS(&sc->tl_ldata->tl_rx_list[0]));

	if (!sc->tl_bitrate)
		mii_mediachg(&sc->sc_mii);
	else
		tl_ifmedia_upd(ifp);

	/* Send the RX go command */
	CMD_SET(sc, TL_CMD_GO|TL_CMD_NES|TL_CMD_RT);

	splx(s);

	/* Start the stats update counter */
	timeout_set(&sc->tl_stats_tmo, tl_stats_update, sc);
	timeout_add_sec(&sc->tl_stats_tmo, 1);
	timeout_set(&sc->tl_wait_tmo, tl_wait_up, sc);
	timeout_add_sec(&sc->tl_wait_tmo, 2);
}

/*
 * Set media options.
 */
int
tl_ifmedia_upd(struct ifnet *ifp)
{
	struct tl_softc *sc = ifp->if_softc;

	if (sc->tl_bitrate)
		tl_setmode(sc, sc->ifmedia.ifm_media);
	else
		mii_mediachg(&sc->sc_mii);

	return(0);
}

/*
 * Report current media status.
 */
void
tl_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct tl_softc		*sc;
	struct mii_data		*mii;

	sc = ifp->if_softc;
	mii = &sc->sc_mii;

	ifmr->ifm_active = IFM_ETHER;
	if (sc->tl_bitrate) {
		if (tl_dio_read8(sc, TL_ACOMMIT) & TL_AC_MTXD1)
			ifmr->ifm_active = IFM_ETHER|IFM_10_5;
		else
			ifmr->ifm_active = IFM_ETHER|IFM_10_T;
		if (tl_dio_read8(sc, TL_ACOMMIT) & TL_AC_MTXD3)
			ifmr->ifm_active |= IFM_HDX;
		else
			ifmr->ifm_active |= IFM_FDX;
		return;
	} else {
		mii_pollstat(mii);
		ifmr->ifm_active = mii->mii_media_active;
		ifmr->ifm_status = mii->mii_media_status;
	}
}

int
tl_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct tl_softc		*sc = ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *) data;
	int			s, error = 0;

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			tl_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				tl_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				tl_stop(sc);
		}
		break;

	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		if (sc->tl_bitrate)
			error = ifmedia_ioctl(ifp, ifr, &sc->ifmedia, command);
		else
			error = ifmedia_ioctl(ifp, ifr,
			    &sc->sc_mii.mii_media, command);
		break;

	default:
		error = ether_ioctl(ifp, &sc->arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			tl_iff(sc);
		error = 0;
	}

	splx(s);
	return(error);
}

void
tl_watchdog(struct ifnet *ifp)
{
	struct tl_softc		*sc;

	sc = ifp->if_softc;

	printf("%s: device timeout\n", sc->sc_dev.dv_xname);

	ifp->if_oerrors++;

	tl_softreset(sc, 1);
	tl_init(sc);
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void
tl_stop(struct tl_softc *sc)
{
	int			i;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	/* Stop the stats updater. */
	timeout_del(&sc->tl_stats_tmo);
	timeout_del(&sc->tl_wait_tmo);

	/* Stop the transmitter */
	CMD_CLR(sc, TL_CMD_RT);
	CMD_SET(sc, TL_CMD_STOP);
	CSR_WRITE_4(sc, TL_CH_PARM, 0);

	/* Stop the receiver */
	CMD_SET(sc, TL_CMD_RT);
	CMD_SET(sc, TL_CMD_STOP);
	CSR_WRITE_4(sc, TL_CH_PARM, 0);

	/*
	 * Disable host interrupts.
	 */
	CMD_SET(sc, TL_CMD_INTSOFF);

	/*
	 * Clear list pointer.
	 */
	CSR_WRITE_4(sc, TL_CH_PARM, 0);

	/*
	 * Free the RX lists.
	 */
	for (i = 0; i < TL_RX_LIST_CNT; i++) {
		if (sc->tl_cdata.tl_rx_chain[i].tl_mbuf != NULL) {
			m_freem(sc->tl_cdata.tl_rx_chain[i].tl_mbuf);
			sc->tl_cdata.tl_rx_chain[i].tl_mbuf = NULL;
		}
	}
	bzero(&sc->tl_ldata->tl_rx_list, sizeof(sc->tl_ldata->tl_rx_list));

	/*
	 * Free the TX list buffers.
	 */
	for (i = 0; i < TL_TX_LIST_CNT; i++) {
		if (sc->tl_cdata.tl_tx_chain[i].tl_mbuf != NULL) {
			m_freem(sc->tl_cdata.tl_tx_chain[i].tl_mbuf);
			sc->tl_cdata.tl_tx_chain[i].tl_mbuf = NULL;
		}
	}
	bzero(&sc->tl_ldata->tl_tx_list, sizeof(sc->tl_ldata->tl_tx_list));

	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
}

int
tl_probe(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = (struct pci_attach_args *) aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_TI) {
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_TI_TLAN)
			return 1;
		return 0;
	}

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_COMPAQ) {
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_COMPAQ_N100TX:
		case PCI_PRODUCT_COMPAQ_N10T:
		case PCI_PRODUCT_COMPAQ_IntNF3P:
		case PCI_PRODUCT_COMPAQ_DPNet100TX:
		case PCI_PRODUCT_COMPAQ_IntPL100TX:
		case PCI_PRODUCT_COMPAQ_DP4000:
		case PCI_PRODUCT_COMPAQ_N10T2:
		case PCI_PRODUCT_COMPAQ_N10_TX_UTP:
		case PCI_PRODUCT_COMPAQ_NF3P:
		case PCI_PRODUCT_COMPAQ_NF3P_BNC:
			return 1;
		}
		return 0;
	}

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_OLICOM) {
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_OLICOM_OC2183:
		case PCI_PRODUCT_OLICOM_OC2325:
		case PCI_PRODUCT_OLICOM_OC2326:
			return 1;
		}
		return 0;
	}

	return 0;
}

void
tl_attach(struct device *parent, struct device *self, void *aux)
{
	struct tl_softc *sc = (struct tl_softc *)self;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	bus_size_t iosize;
	u_int32_t command;
	int i, rseg;
	bus_dma_segment_t seg;
	bus_dmamap_t dmamap;
	caddr_t kva;

	/*
	 * Map control/status registers.
	 */

#ifdef TL_USEIOSPACE
	if (pci_mapreg_map(pa, TL_PCI_LOIO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->tl_btag, &sc->tl_bhandle, NULL, &iosize, 0)) {
		if (pci_mapreg_map(pa, TL_PCI_LOMEM, PCI_MAPREG_TYPE_IO, 0,
		    &sc->tl_btag, &sc->tl_bhandle, NULL, &iosize, 0)) {
			printf(": can't map i/o space\n");
			return;
		}
	}
#else
	if (pci_mapreg_map(pa, TL_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->tl_btag, &sc->tl_bhandle, NULL, &iosize, 0)){
		if (pci_mapreg_map(pa, TL_PCI_LOIO, PCI_MAPREG_TYPE_MEM, 0,
		    &sc->tl_btag, &sc->tl_bhandle, NULL, &iosize, 0)){
			printf(": can't map mem space\n");
			return;
		}
	}
#endif

	/*
	 * Manual wants the PCI latency timer jacked up to 0xff
	 */
	command = pci_conf_read(pa->pa_pc, pa->pa_tag, TL_PCI_LATENCY_TIMER);
	command |= 0x0000ff00;
	pci_conf_write(pa->pa_pc, pa->pa_tag, TL_PCI_LATENCY_TIMER, command);

	/*
	 * Allocate our interrupt.
	 */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		bus_space_unmap(sc->tl_btag, sc->tl_bhandle, iosize);
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, tl_intr, sc,
	    self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": could not establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(sc->tl_btag, sc->tl_bhandle, iosize);
		return;
	}
	printf(": %s", intrstr);

	sc->sc_dmat = pa->pa_dmat;
	if (bus_dmamem_alloc(sc->sc_dmat, sizeof(struct tl_list_data),
	    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT | BUS_DMA_ZERO)) {
		printf("%s: can't alloc list\n", sc->sc_dev.dv_xname);
		bus_space_unmap(sc->tl_btag, sc->tl_bhandle, iosize);
		return;
	}
	if (bus_dmamem_map(sc->sc_dmat, &seg, rseg, sizeof(struct tl_list_data),
	    &kva, BUS_DMA_NOWAIT)) {
		printf("%s: can't map dma buffers (%zd bytes)\n",
		    sc->sc_dev.dv_xname, sizeof(struct tl_list_data));
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
		return;
	}
	if (bus_dmamap_create(sc->sc_dmat, sizeof(struct tl_list_data), 1,
	    sizeof(struct tl_list_data), 0, BUS_DMA_NOWAIT, &dmamap)) {
		printf("%s: can't create dma map\n", sc->sc_dev.dv_xname);
		bus_dmamem_unmap(sc->sc_dmat, kva, sizeof(struct tl_list_data));
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
		bus_space_unmap(sc->tl_btag, sc->tl_bhandle, iosize);
		return;
	}
	if (bus_dmamap_load(sc->sc_dmat, dmamap, kva,
	    sizeof(struct tl_list_data), NULL, BUS_DMA_NOWAIT)) {
		printf("%s: can't load dma map\n", sc->sc_dev.dv_xname);
		bus_dmamap_destroy(sc->sc_dmat, dmamap);
		bus_dmamem_unmap(sc->sc_dmat, kva, sizeof(struct tl_list_data));
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
		bus_space_unmap(sc->tl_btag, sc->tl_bhandle, iosize);
		return;
	}
	sc->tl_ldata = (struct tl_list_data *)kva;

	for (sc->tl_product = tl_prods; sc->tl_product->tp_vend;
	     sc->tl_product++) {
		if (sc->tl_product->tp_vend == PCI_VENDOR(pa->pa_id) &&
		    sc->tl_product->tp_prod == PCI_PRODUCT(pa->pa_id))
			break;
	}
		
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_COMPAQ ||
	    PCI_VENDOR(pa->pa_id) == PCI_VENDOR_TI)
		sc->tl_eeaddr = TL_EEPROM_EADDR;
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_OLICOM)
		sc->tl_eeaddr = TL_EEPROM_EADDR_OC;

	/*
	 * Reset adapter.
	 */
	tl_softreset(sc, 1);
	tl_hardreset(self);
	DELAY(1000000);
	tl_softreset(sc, 1);

	/*
	 * Get station address from the EEPROM.
	 */
	if (tl_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
	    sc->tl_eeaddr, ETHER_ADDR_LEN)) {
		printf("\n%s: failed to read station address\n",
		    sc->sc_dev.dv_xname);
		bus_space_unmap(sc->tl_btag, sc->tl_bhandle, iosize);
		return;
	}

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_OLICOM) {
		for (i = 0; i < ETHER_ADDR_LEN; i += 2) {
			u_int16_t *p;

			p = (u_int16_t *)&sc->arpcom.ac_enaddr[i];
			*p = ntohs(*p);
		}
	}

	printf(" address %s\n", ether_sprintf(sc->arpcom.ac_enaddr));

	ifp = &sc->arpcom.ac_if;
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = tl_ioctl;
	ifp->if_start = tl_start;
	ifp->if_watchdog = tl_watchdog;
	IFQ_SET_MAXLEN(&ifp->if_snd, TL_TX_LIST_CNT - 1);
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	/*
	 * Reset adapter (again).
	 */
	tl_softreset(sc, 1);
	tl_hardreset(self);
	DELAY(1000000);
	tl_softreset(sc, 1);

	/*
	 * Do MII setup. If no PHYs are found, then this is a
	 * bitrate ThunderLAN chip that only supports 10baseT
	 * and AUI/BNC.
	 */
	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = tl_miibus_readreg;
	sc->sc_mii.mii_writereg = tl_miibus_writereg;
	sc->sc_mii.mii_statchg = tl_miibus_statchg;
	ifmedia_init(&sc->sc_mii.mii_media, 0, tl_ifmedia_upd, tl_ifmedia_sts);
	mii_attach(self, &sc->sc_mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY,
	    0);
	if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
		struct ifmedia *ifm;
		sc->tl_bitrate = 1;
		ifmedia_init(&sc->ifmedia, 0, tl_ifmedia_upd, tl_ifmedia_sts);
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_5, 0, NULL);
		ifmedia_set(&sc->ifmedia, IFM_ETHER|IFM_10_T);
		/* Reset again, this time setting bitrate mode. */
		tl_softreset(sc, 1);
		ifm = &sc->ifmedia;
		ifm->ifm_media = ifm->ifm_cur->ifm_media;
		tl_ifmedia_upd(ifp);
	} else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);

	/*
	 * Attach us everywhere.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);
}

void
tl_wait_up(void *xsc)
{
	struct tl_softc *sc = xsc;
	struct ifnet *ifp = &sc->arpcom.ac_if;

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
}

struct cfattach tl_ca = {
	sizeof(struct tl_softc), tl_probe, tl_attach
};

struct cfdriver tl_cd = {
	NULL, "tl", DV_IFNET
};
@


1.70
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.69 2016/04/13 10:34:32 mpi Exp $	*/
d275 1
a275 1
int tl_calchash(caddr_t);
d750 1
a750 1
tl_calchash(caddr_t addr)
@


1.69
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.68 2015/11/25 03:09:59 dlg Exp $	*/
a1328 1
	ifp->if_opackets += tl_tx_goodframes(tl_stats);
@


1.68
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.67 2015/11/24 17:11:39 mpi Exp $	*/
a1966 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.67
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.66 2015/10/25 13:04:28 mpi Exp $	*/
d1179 1
a1179 1
		ifp->if_flags &= ~IFF_OACTIVE;
d1462 1
a1462 1
		ifp->if_flags |= IFF_OACTIVE;
d1771 2
a1772 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d2023 1
a2023 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.66
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.65 2015/09/14 11:18:49 stsp Exp $	*/
a199 1
#include <net/if_dl.h>
@


1.65
log
@Fix more ifmedia64 fallout in the kernel. It's hiding everywhere...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.64 2015/06/24 09:40:54 mpi Exp $	*/
a1651 1
	struct ifaddr		*ifa = (struct ifaddr *) data;
a1661 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->arpcom, ifa);
@


1.64
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.63 2015/04/30 07:51:07 mpi Exp $	*/
d275 1
a275 1
void tl_setmode(struct tl_softc *, int);
d725 1
a725 1
tl_setmode(struct tl_softc *sc, int media)
@


1.63
log
@Convert moar drivers to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.62 2015/04/01 14:29:54 mpi Exp $	*/
a1332 1
	ifp->if_ipackets += tl_rx_goodframes(tl_stats);
@


1.62
log
@Kill useless comments talking about ether_input().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.61 2014/12/22 02:28:52 tedu Exp $	*/
d1034 1
a1063 1
		m->m_pkthdr.rcvif = ifp;
d1079 1
a1079 6
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
		/* pass it on. */
		ether_input_mbuf(ifp, m);
d1081 2
@


1.61
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.60 2014/07/22 13:12:11 mpi Exp $	*/
d1017 5
a1021 4
 * just hand the mbufs directly to ether_input(). Once the frame has
 * been sent on its way, the 'list' structure is assigned a new buffer
 * and moved to the end of the RX chain. As long we we stay ahead of
 * the chip, it will always think it has an endless receive channel.
a1079 8
		/*
	 	 * Handle BPF listeners. Let the BPF user see the packet, but
	 	 * don't pass it up to the ether_input() layer unless it's
	 	 * a broadcast packet, multicast packet, matches our ethernet
	 	 * address or the interface is in promiscuous mode. If we don't
	 	 * want the packet, just forget it. We leave the mbuf in place
	 	 * since it can be used again later.
	 	 */
@


1.60
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.59 2014/01/31 08:58:32 brad Exp $	*/
a196 1
#ifdef INET
a198 1
#endif
a1673 1
#ifdef INET
a1675 1
#endif
@


1.59
log
@tl(4) already allowed for reception of frames up to MCLBYTES in size so
set IFCAP_VLAN_MTU to allow for VLAN sized frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.58 2014/01/31 06:05:40 brad Exp $	*/
a198 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.58
log
@Rewrite the receive filter handling code, reinstate the hash filter and cleanup
the ioctl bits.

Tested by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.57 2013/11/26 09:50:33 mpi Exp $	*/
d1989 2
@


1.57
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.56 2013/11/18 19:43:00 brad Exp $	*/
a279 1
#if 0
d281 1
a281 2
#endif
void tl_setmulti(struct tl_softc *);
a744 1
#if 0
a762 1
#endif
d800 1
a800 1
tl_setmulti(struct tl_softc *sc)
d802 2
a803 4
	struct ifnet		*ifp;
	u_int32_t		hashes[2] = { 0, 0 };
	int			h;
	struct arpcom *ac = &sc->arpcom;
d806 2
a807 1
	ifp = &sc->arpcom.ac_if;
d809 3
a811 2
	tl_dio_write32(sc, TL_HASH1, 0);
	tl_dio_write32(sc, TL_HASH2, 0);
d813 18
a830 6
	ifp->if_flags &= ~IFF_ALLMULTI;
	ETHER_FIRST_MULTI(step, ac, enm);
	h = 0;
	while (enm != NULL) {
		h++;
		ETHER_NEXT_MULTI(step, enm);
a831 5
	if (h) {
		hashes[0] = hashes[1] = 0xffffffff;
		ifp->if_flags |= IFF_ALLMULTI;
	} else
		hashes[0] = hashes[1] = 0x00000000;
a834 2

	return;
a1572 16
	/*
	 * Set 'capture all frames' bit for promiscuous mode.
	 */
	if (ifp->if_flags & IFF_PROMISC)
		tl_dio_setbit(sc, TL_NETCMD, TL_CMD_CAF);
	else
		tl_dio_clrbit(sc, TL_NETCMD, TL_CMD_CAF);

	/*
	 * Set capture broadcast bit to capture broadcast frames.
	 */
	if (ifp->if_flags & IFF_BROADCAST)
		tl_dio_clrbit(sc, TL_NETCMD, TL_CMD_NOBRX);
	else
		tl_dio_setbit(sc, TL_NETCMD, TL_CMD_NOBRX);

d1578 2
a1579 2
	/* Init multicast filter, if needed. */
	tl_setmulti(sc);
d1676 2
a1677 1
		switch (ifa->ifa_addr->sa_family) {
d1679 1
a1679 2
		case AF_INET:
			tl_init(sc);
d1681 1
a1681 6
			break;
#endif /* INET */
		default:
			tl_init(sc);
			break;
		}
d1686 3
a1688 11
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->tl_if_flags & IFF_PROMISC)) {
				tl_dio_setbit(sc, TL_NETCMD, TL_CMD_CAF);
				tl_setmulti(sc);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->tl_if_flags & IFF_PROMISC) {
				tl_dio_clrbit(sc, TL_NETCMD, TL_CMD_CAF);
				tl_setmulti(sc);
			} else
d1691 1
a1691 1
			if (ifp->if_flags & IFF_RUNNING) {
a1692 1
			}
a1693 2
		sc->tl_if_flags = ifp->if_flags;
		error = 0;
d1711 1
a1711 1
			tl_setmulti(sc);
@


1.56
log
@- ansify some function definitions
- remove return at end of void functions
- remove extraneous braces

no functional change.

ok chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.55 2013/10/01 20:06:01 sf Exp $	*/
a817 14
#if 0
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (memcmp(enm->enm_addrlo, enm->enm_addrhi, 6) == 0) {
			h = tl_calchash(enm->enm_addrlo);
			hashes[h/32] |= (1 << (h % 32));
		} else {
			hashes[0] = hashes[1] = 0xffffffff;
			ifp->if_flags |= IFF_ALLMULTI;
			break;
		}
		ETHER_NEXT_MULTI(step, enm);
	}
#else
a828 1
#endif
@


1.55
log
@Use %z* for size_t

while there, fix a few %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.54 2013/08/07 01:06:38 bluhm Exp $	*/
d254 1
a254 2
int tl_newbuf(struct tl_softc *,
					struct tl_chain_onefrag *);
d256 1
a256 2
int tl_encap(struct tl_softc *, struct tl_chain *,
						struct mbuf *);
d268 1
a268 2
u_int8_t	tl_eeprom_getbyte(struct tl_softc *,
						int, u_int8_t *);
d301 2
a302 3
u_int8_t tl_dio_read8(sc, reg)
	struct tl_softc		*sc;
	int			reg;
d308 2
a309 3
u_int16_t tl_dio_read16(sc, reg)
	struct tl_softc		*sc;
	int			reg;
d315 2
a316 3
u_int32_t tl_dio_read32(sc, reg)
	struct tl_softc		*sc;
	int			reg;
d322 2
a323 4
void tl_dio_write8(sc, reg, val)
	struct tl_softc		*sc;
	int			reg;
	int			val;
a326 1
	return;
d329 2
a330 4
void tl_dio_write16(sc, reg, val)
	struct tl_softc		*sc;
	int			reg;
	int			val;
a333 1
	return;
d336 2
a337 4
void tl_dio_write32(sc, reg, val)
	struct tl_softc		*sc;
	int			reg;
	int			val;
a340 1
	return;
d343 2
a344 4
void tl_dio_setbit(sc, reg, bit)
	struct tl_softc		*sc;
	int			reg;
	int			bit;
a351 2

	return;
d354 2
a355 4
void tl_dio_clrbit(sc, reg, bit)
	struct tl_softc		*sc;
	int			reg;
	int			bit;
a362 2

	return;
d365 2
a366 4
void tl_dio_setbit16(sc, reg, bit)
	struct tl_softc		*sc;
	int			reg;
	int			bit;
a373 2

	return;
d376 2
a377 4
void tl_dio_clrbit16(sc, reg, bit)
	struct tl_softc		*sc;
	int			reg;
	int			bit;
a384 2

	return;
d390 2
a391 3
u_int8_t tl_eeprom_putbyte(sc, byte)
	struct tl_softc		*sc;
	int			byte;
d404 1
a404 1
		if (byte & i) {
d406 1
a406 1
		} else {
a407 1
		}
d432 2
a433 4
u_int8_t tl_eeprom_getbyte(sc, addr, dest)
	struct tl_softc		*sc;
	int			addr;
	u_int8_t		*dest;
d498 2
a499 5
int tl_read_eeprom(sc, dest, off, cnt)
	struct tl_softc		*sc;
	caddr_t			dest;
	int			off;
	int			cnt;
d514 2
a515 2
void tl_mii_sync(sc)
	struct tl_softc		*sc;
a524 2

	return;
d527 2
a528 4
void tl_mii_send(sc, bits, cnt)
	struct tl_softc		*sc;
	u_int32_t		bits;
	int			cnt;
d534 1
a534 1
		if (bits & i) {
d536 1
a536 1
		} else {
a537 1
		}
d542 2
a543 4
int tl_mii_readreg(sc, frame)
	struct tl_softc		*sc;
	struct tl_mii_frame	*frame;
	
d564 1
a564 1
	if (minten) {
a565 1
	}
d623 1
a623 1
	if (minten) {
a624 1
	}
d633 2
a634 4
int tl_mii_writereg(sc, frame)
	struct tl_softc		*sc;
	struct tl_mii_frame	*frame;
	
d654 1
a654 1
	if (minten) {
a655 1
	}
d686 2
a687 3
int tl_miibus_readreg(dev, phy, reg)
	struct device		*dev;
	int			phy, reg;
d701 2
a702 3
void tl_miibus_writereg(dev, phy, reg, data)
	struct device		*dev;
	int			phy, reg, data;
d716 2
a717 2
void tl_miibus_statchg(dev)
	struct device *dev;
d721 1
a721 1
	if ((sc->sc_mii.mii_media_active & IFM_GMASK) == IFM_FDX) {
d723 1
a723 1
	} else {
a724 1
	}
d730 2
a731 3
void tl_setmode(sc, media)
	struct tl_softc		*sc;
	int			media;
d757 2
a758 2
int tl_calchash(addr)
	caddr_t			addr;
d775 2
a776 4
void tl_setfilt(sc, addr, slot)
	struct tl_softc		*sc;
	caddr_t			addr;
	int			slot;
a784 2

	return;
d803 2
a804 2
void tl_setmulti(sc)
	struct tl_softc		*sc;
d841 1
a841 1
	} else {
a842 1
	}
d857 2
a858 2
void tl_hardreset(dev)
	struct device *dev;
a873 1
	return;
d876 2
a877 3
void tl_softreset(sc, internal)
	struct tl_softc		*sc;
	int			internal;
a927 2

        return;
d933 2
a934 2
int tl_list_tx_init(sc)
	struct tl_softc		*sc;
d960 2
a961 2
int tl_list_rx_init(sc)
	struct tl_softc		*sc;
d991 2
a992 3
int tl_newbuf(sc, c)
	struct tl_softc		*sc;
	struct tl_chain_onefrag	*c;
d1044 2
a1045 3
int tl_intvec_rxeof(xsc, type)
	void			*xsc;
	u_int32_t		type;
d1105 1
a1105 1
		if (ifp->if_bpf) {
a1106 1
		}
d1122 2
a1123 3
int tl_intvec_rxeoc(xsc, type)
	void			*xsc;
	u_int32_t		type;
d1143 2
a1144 3
int tl_intvec_txeof(xsc, type)
	void			*xsc;
	u_int32_t		type;
d1194 2
a1195 3
int tl_intvec_txeoc(xsc, type)
	void			*xsc;
	u_int32_t		type;
d1229 2
a1230 3
int tl_intvec_adchk(xsc, type)
	void			*xsc;
	u_int32_t		type;
d1248 2
a1249 3
int tl_intvec_netsts(xsc, type)
	void			*xsc;
	u_int32_t		type;
d1264 2
a1265 2
int tl_intr(xsc)
	void			*xsc;
d1333 2
a1334 2
void tl_stats_update(xsc)
	void			*xsc;
a1382 1
	return;
d1389 2
a1390 4
int tl_encap(sc, c, m_head)
	struct tl_softc		*sc;
	struct tl_chain		*c;
	struct mbuf		*m_head;
d1430 1
a1430 1
		if (m_new == NULL) {
a1431 1
		}
d1477 2
a1478 2
void tl_start(ifp)
	struct ifnet		*ifp;
a1563 2

	return;
d1566 2
a1567 2
void tl_init(xsc)
	void			*xsc;
d1630 1
a1630 1
	if (!sc->tl_bitrate) {
d1632 1
a1632 1
	} else {
a1633 1
	}
a1644 2

	return;
d1651 1
a1651 2
tl_ifmedia_upd(ifp)
	struct ifnet *ifp;
d1666 2
a1667 3
void tl_ifmedia_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
a1690 2

	return;
d1693 2
a1694 4
int tl_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
d1765 2
a1766 2
void tl_watchdog(ifp)
	struct ifnet		*ifp;
a1777 2

	return;
d1784 2
a1785 2
void tl_stop(sc)
	struct tl_softc		*sc;
a1838 2

	return;
d1842 1
a1842 4
tl_probe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d1883 1
a1883 3
tl_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d2081 1
a2081 2
tl_wait_up(xsc)
	void *xsc;
@


1.54
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.53 2012/11/29 21:10:32 brad Exp $	*/
d2054 1
a2054 1
		printf("%s: can't map dma buffers (%d bytes)\n",
@


1.53
log
@Remove setting an initial assumed baudrate upon driver attach which is not
necessarily correct, there might not even be a link when attaching.

ok mikeb@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.52 2012/11/23 18:40:30 gsoares Exp $	*/
a199 1
#include <netinet/in_var.h>
@


1.52
log
@set ifp->if_baudrate with IF_Gbps() / IF_Mbps().

OK reyk@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.51 2011/06/22 16:44:27 tedu Exp $	*/
a2127 1
	ifp->if_baudrate = IF_Mbps(10);
@


1.51
log
@kill a few more casts that aren't helpful.  ok krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.50 2010/05/19 15:27:35 oga Exp $	*/
d2128 1
a2128 1
	ifp->if_baudrate = 10000000;
@


1.50
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.49 2009/08/13 14:24:47 jasper Exp $	*/
d744 1
a744 1
	bzero((char *)&frame, sizeof(frame));
d760 1
a760 1
	bzero((char *)&frame, sizeof(frame));
d1416 1
a1416 1
	bzero((char *)&tl_stats, sizeof(struct tl_stats));
d1914 1
a1914 2
	bzero((char *)&sc->tl_ldata->tl_rx_list,
		sizeof(sc->tl_ldata->tl_rx_list));
d1925 1
a1925 2
	bzero((char *)&sc->tl_ldata->tl_tx_list,
		sizeof(sc->tl_ldata->tl_tx_list));
@


1.49
log
@- consistify cfdriver for the ethernet drivers (0 -> NULL)

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.48 2009/08/10 19:41:05 deraadt Exp $	*/
d2050 1
a2050 1
	    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
a2079 1
	bzero(sc->tl_ldata, sizeof(struct tl_list_data));
@


1.48
log
@A few more simple cases of shutdown hooks which only call xxstop, when
we now know the interface has already been stopped
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.47 2009/03/29 21:53:52 sthen Exp $	*/
d2196 1
a2196 1
	0, "tl", DV_IFNET
@


1.47
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.46 2008/11/28 02:44:18 brad Exp $	*/
a266 1
void tl_shutdown(void *);
a2177 2

	shutdownhook_establish(tl_shutdown, sc);
a2188 9
}

void
tl_shutdown(xsc)
	void *xsc;
{
	struct tl_softc *sc = xsc;

	tl_stop(sc);
@


1.46
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.45 2008/10/02 20:21:14 brad Exp $	*/
d2006 1
a2006 1
			printf(": failed to map i/o space\n");
d2015 1
a2015 1
			printf(": failed to map memory space\n");
@


1.45
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.44 2008/09/10 14:01:23 blambert Exp $	*/
d1785 1
a1786 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d1806 1
d1829 1
a1829 15
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			tl_setmulti(sc);
			error = 0;
		}
		break;
d1838 1
d1841 6
@


1.44
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.43 2007/05/08 21:19:13 deraadt Exp $	*/
a1790 5
	if ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {
		splx(s);
		return error;
	}

d1852 1
a1852 2
		error = ENOTTY;
		break;
a1855 1

@


1.43
log
@#if 0 a function that is only ever called in #if 0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.42 2006/06/29 21:35:39 deraadt Exp $	*/
d1450 1
a1450 1
	timeout_add(&sc->tl_stats_tmo, hz);
d1722 1
a1722 1
	timeout_add(&sc->tl_stats_tmo, hz);
d1724 1
a1724 1
	timeout_add(&sc->tl_wait_tmo, 2 * hz);
@


1.42
log
@no need to check io/mem enables before calling pci_mapreg_map()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.41 2006/05/28 00:04:24 jason Exp $	*/
d285 1
d287 1
d803 1
d822 1
@


1.41
log
@unknown ioctl is ENOTTY not EINVAL
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.40 2006/03/25 22:41:45 djm Exp $	*/
a2008 1
	command = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
a2010 4
	if (!(command & PCI_COMMAND_IO_ENABLE)) {
		printf(": failed to enable I/O ports\n");
		return;
	}
a2019 4
	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf(": failed to enable memory mapping\n");
		return;
	}
@


1.40
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.39 2006/03/20 16:15:03 brad Exp $	*/
d1853 1
a1853 1
		error = EINVAL;
@


1.39
log
@de-register.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.38 2006/03/04 23:40:14 brad Exp $	*/
d1169 1
a1169 1
			bpf_mtap(ifp->if_bpf, m);
d1598 2
a1599 1
			bpf_mtap(ifp->if_bpf, cur_tx->tl_mbuf);
@


1.38
log
@don't set the interface pointer twice in tl_init().

From: Andrey Matveev <evol at online dot ptt dot ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.37 2005/11/23 11:30:14 mickey Exp $	*/
d425 1
a425 1
	register int		i, ack = 0;
d470 1
a470 1
	register int		i;
d555 1
a555 1
	register int		i;
d1885 1
a1885 1
	register int		i;
@


1.37
log
@assume vtophys(vaddr_t) just what all the other archs expect; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.36 2005/11/07 02:57:45 brad Exp $	*/
a1647 2

	ifp = &sc->arpcom.ac_if;
@


1.36
log
@- splimp -> splnet
- remove spl's from attach
- removing redundant checks before pci_mapreg_map()
- fix dmesg printing
- de-allocate resources on failure to attach
- remove unused VLAN input code from vge(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.35 2005/09/11 18:17:08 mickey Exp $	*/
d213 1
d1042 1
a1042 1
					vtophys(&ld->tl_rx_list[i + 1]);
d1077 1
a1077 1
	c->tl_ptr->tl_frag.tlist_dadr = vtophys(mtod(m_new, caddr_t));
d1138 1
a1138 1
						vtophys(cur_rx->tl_ptr);
d1203 1
a1203 1
	CSR_WRITE_4(sc, TL_CH_PARM, vtophys(sc->tl_cdata.tl_rx_head->tl_ptr));
d1284 1
a1284 1
		    vtophys(sc->tl_cdata.tl_tx_head->tl_ptr));
d1483 1
a1483 1
				vtophys(mtod(m, vaddr_t));
d1518 1
a1518 1
		f->tlist_dadr = vtophys(mtod(m_new, caddr_t));
d1530 1
a1530 1
		f->tlist_dadr = vtophys(&sc->tl_ldata->tl_pad);
d1588 1
a1588 1
			prev->tl_ptr->tlist_fptr = vtophys(cur_tx->tl_ptr);
d1621 1
a1621 1
			CSR_WRITE_4(sc, TL_CH_PARM, vtophys(start_tx->tl_ptr));
d1704 1
a1704 1
	CSR_WRITE_4(sc, TL_CH_PARM, vtophys(&sc->tl_ldata->tl_rx_list[0]));
@


1.35
log
@do not inline pci_mapreg_map() anymore as it is olrite now; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.34 2005/07/02 22:52:16 brad Exp $	*/
d592 1
a592 1
	s = splimp();
d689 1
a689 1
	s = splimp();
d1410 1
a1410 1
	s = splimp();
d1646 1
a1646 1
	s = splimp();
d1785 1
a1785 1
	s = splimp();
@


1.34
log
@add TLPHY_MEDIA_NO_10_T flag for DP4000 model
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.33 2004/09/23 17:45:16 brad Exp $	*/
a1998 1
	bus_addr_t iobase;
d2016 5
a2020 4
	if (pci_io_find(pc, pa->pa_tag, TL_PCI_LOIO, &iobase, &iosize)) {
		if (pci_io_find(pc, pa->pa_tag, TL_PCI_LOMEM,
		    &iobase, &iosize)) {
			printf(": failed to find i/o space\n");
a2023 5
	if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->tl_bhandle)) {
		printf(": failed map i/o space\n");
		return;
	}
	sc->tl_btag = pa->pa_iot;
d2029 5
a2033 4
	if (pci_mem_find(pc, pa->pa_tag, TL_PCI_LOMEM, &iobase, &iosize, NULL)){
		if (pci_mem_find(pc, pa->pa_tag, TL_PCI_LOIO,
		    &iobase, &iosize, NULL)) {
			printf(": failed to find memory space\n");
a2036 5
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->tl_bhandle)) {
		printf(": failed map memory space\n");
		return;
	}
	sc->tl_btag = pa->pa_memt;
d2051 1
d2062 1
d2071 1
d2086 1
d2095 1
d2129 2
a2130 1
	    return;
@


1.33
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.32 2004/09/14 22:39:03 brad Exp $	*/
d237 1
a237 1
	{ PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_DP4000, TLPHY_MEDIA_10_5 },
@


1.32
log
@Call tl_ifmedia_upd() in tl_init() for cards with bitrate devices

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.31 2003/08/19 14:01:35 mpech Exp $	*/
a2148 1
	ifp->if_mtu = ETHERMTU;
a2150 1
	ifp->if_output = ether_output;
@


1.31
log
@missing break.

jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.30 2003/06/30 02:52:51 avsm Exp $	*/
d1705 1
a1705 1
	if (!sc->tl_bitrate) 
d1707 3
@


1.30
log
@remove the use of tl_unit
jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.29 2003/01/15 06:31:24 art Exp $	*/
d1803 1
@


1.29
log
@Get rid of the remaining vm_offset_t in pci drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.28 2002/07/08 14:48:57 itojun Exp $	*/
d480 2
a481 2
		printf("tl%d: failed to send write command, status: %x\n",
				sc->tl_unit, tl_dio_read8(sc, TL_NETSIO));
d489 2
a490 2
		printf("tl%d: failed to send address, status: %x\n",
				sc->tl_unit, tl_dio_read8(sc, TL_NETSIO));
d500 2
a501 2
		printf("tl%d: failed to send write command, status: %x\n",
				sc->tl_unit, tl_dio_read8(sc, TL_NETSIO));
d1304 1
a1304 1
		printf("tl%d: adapter check: %x\n", sc->tl_unit,
d1327 1
a1327 1
	printf("tl%d: network status: %x\n", sc->tl_unit, netsts);
d1373 1
a1373 1
		printf("tl%d: got a dummy interrupt\n", sc->tl_unit);
d1386 1
a1386 1
		printf("tl%d: bogus interrupt type\n", sc->tl_unit);
d1688 2
a1689 2
		printf("tl%d: initialization failed: no "
			"memory for rx buffers\n", sc->tl_unit);
d1865 1
a1865 1
	printf("tl%d: device timeout\n", sc->tl_unit);
a2107 1
	sc->tl_unit = sc->sc_dev.dv_unit;
@


1.28
log
@tl* multicast filter is broken.  use ALLMULTI for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.27 2002/07/05 13:48:11 aaron Exp $	*/
d1482 1
a1482 1
				vtophys(mtod(m, vm_offset_t));
@


1.27
log
@Typo; stobe -> strobe
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.26 2002/03/14 01:26:59 millert Exp $	*/
d863 1
a863 1
	int			h, i;
a866 1
	u_int8_t		dummy[] = { 0, 0, 0, 0, 0 ,0 };
a868 3
	/* First, zot all the existing filters. */
	for (i = 1; i < 4; i++)
		tl_setfilt(sc, (caddr_t)&dummy, i);
d872 5
a876 14
	/* Now program new ones. */
	if (ifp->if_flags & IFF_ALLMULTI) {
		hashes[0] = 0xFFFFFFFF;
		hashes[1] = 0xFFFFFFFF;
	} else {
		i = 1;
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			if (i < 4) {
				tl_setfilt(sc, enm->enm_addrlo, i);
				i++;
				continue;
			}

d878 5
a882 6
			if (h < 32)
				hashes[0] |= (1 << h);
			else
				hashes[1] |= (1 << (h - 32));
				
			ETHER_NEXT_MULTI(step, enm);
d884 1
d886 14
@


1.26
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.25 2002/02/15 20:45:31 nordin Exp $	*/
d432 1
a432 1
	 * Feed in each bit and stobe the clock.
@


1.25
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.24 2001/11/06 19:53:19 miod Exp $	*/
d244 58
a301 58
int tl_probe	__P((struct device *, void *, void *));
void tl_attach	__P((struct device *, struct device *, void *));
void tl_wait_up	__P((void *));
int tl_intvec_rxeoc	__P((void *, u_int32_t));
int tl_intvec_txeoc	__P((void *, u_int32_t));
int tl_intvec_txeof	__P((void *, u_int32_t));
int tl_intvec_rxeof	__P((void *, u_int32_t));
int tl_intvec_adchk	__P((void *, u_int32_t));
int tl_intvec_netsts	__P((void *, u_int32_t));

int tl_newbuf		__P((struct tl_softc *,
					struct tl_chain_onefrag *));
void tl_stats_update	__P((void *));
int tl_encap		__P((struct tl_softc *, struct tl_chain *,
						struct mbuf *));

int tl_intr		__P((void *));
void tl_start		__P((struct ifnet *));
int tl_ioctl		__P((struct ifnet *, u_long, caddr_t));
void tl_init		__P((void *));
void tl_stop		__P((struct tl_softc *));
void tl_watchdog		__P((struct ifnet *));
void tl_shutdown		__P((void *));
int tl_ifmedia_upd	__P((struct ifnet *));
void tl_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));

u_int8_t tl_eeprom_putbyte	__P((struct tl_softc *, int));
u_int8_t	tl_eeprom_getbyte	__P((struct tl_softc *,
						int, u_int8_t *));
int tl_read_eeprom	__P((struct tl_softc *, caddr_t, int, int));

void tl_mii_sync		__P((struct tl_softc *));
void tl_mii_send		__P((struct tl_softc *, u_int32_t, int));
int tl_mii_readreg	__P((struct tl_softc *, struct tl_mii_frame *));
int tl_mii_writereg	__P((struct tl_softc *, struct tl_mii_frame *));
int tl_miibus_readreg	__P((struct device *, int, int));
void tl_miibus_writereg	__P((struct device *, int, int, int));
void tl_miibus_statchg	__P((struct device *));

void tl_setmode		__P((struct tl_softc *, int));
int tl_calchash		__P((caddr_t));
void tl_setmulti		__P((struct tl_softc *));
void tl_setfilt		__P((struct tl_softc *, caddr_t, int));
void tl_softreset	__P((struct tl_softc *, int));
void tl_hardreset	__P((struct device *));
int tl_list_rx_init	__P((struct tl_softc *));
int tl_list_tx_init	__P((struct tl_softc *));

u_int8_t tl_dio_read8	__P((struct tl_softc *, int));
u_int16_t tl_dio_read16	__P((struct tl_softc *, int));
u_int32_t tl_dio_read32	__P((struct tl_softc *, int));
void tl_dio_write8	__P((struct tl_softc *, int, int));
void tl_dio_write16	__P((struct tl_softc *, int, int));
void tl_dio_write32	__P((struct tl_softc *, int, int));
void tl_dio_setbit	__P((struct tl_softc *, int, int));
void tl_dio_clrbit	__P((struct tl_softc *, int, int));
void tl_dio_setbit16	__P((struct tl_softc *, int, int));
void tl_dio_clrbit16	__P((struct tl_softc *, int, int));
@


1.24
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.23 2001/08/25 10:13:29 art Exp $	*/
d1710 1
a1710 1
	(void)splx(s);
d1852 1
a1852 1
	(void)splx(s);
@


1.24.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.24 2001/11/06 19:53:19 miod Exp $	*/
d244 58
a301 58
int tl_probe(struct device *, void *, void *);
void tl_attach(struct device *, struct device *, void *);
void tl_wait_up(void *);
int tl_intvec_rxeoc(void *, u_int32_t);
int tl_intvec_txeoc(void *, u_int32_t);
int tl_intvec_txeof(void *, u_int32_t);
int tl_intvec_rxeof(void *, u_int32_t);
int tl_intvec_adchk(void *, u_int32_t);
int tl_intvec_netsts(void *, u_int32_t);

int tl_newbuf(struct tl_softc *,
					struct tl_chain_onefrag *);
void tl_stats_update(void *);
int tl_encap(struct tl_softc *, struct tl_chain *,
						struct mbuf *);

int tl_intr(void *);
void tl_start(struct ifnet *);
int tl_ioctl(struct ifnet *, u_long, caddr_t);
void tl_init(void *);
void tl_stop(struct tl_softc *);
void tl_watchdog(struct ifnet *);
void tl_shutdown(void *);
int tl_ifmedia_upd(struct ifnet *);
void tl_ifmedia_sts(struct ifnet *, struct ifmediareq *);

u_int8_t tl_eeprom_putbyte(struct tl_softc *, int);
u_int8_t	tl_eeprom_getbyte(struct tl_softc *,
						int, u_int8_t *);
int tl_read_eeprom(struct tl_softc *, caddr_t, int, int);

void tl_mii_sync(struct tl_softc *);
void tl_mii_send(struct tl_softc *, u_int32_t, int);
int tl_mii_readreg(struct tl_softc *, struct tl_mii_frame *);
int tl_mii_writereg(struct tl_softc *, struct tl_mii_frame *);
int tl_miibus_readreg(struct device *, int, int);
void tl_miibus_writereg(struct device *, int, int, int);
void tl_miibus_statchg(struct device *);

void tl_setmode(struct tl_softc *, int);
int tl_calchash(caddr_t);
void tl_setmulti(struct tl_softc *);
void tl_setfilt(struct tl_softc *, caddr_t, int);
void tl_softreset(struct tl_softc *, int);
void tl_hardreset(struct device *);
int tl_list_rx_init(struct tl_softc *);
int tl_list_tx_init(struct tl_softc *);

u_int8_t tl_dio_read8(struct tl_softc *, int);
u_int16_t tl_dio_read16(struct tl_softc *, int);
u_int32_t tl_dio_read32(struct tl_softc *, int);
void tl_dio_write8(struct tl_softc *, int, int);
void tl_dio_write16(struct tl_softc *, int, int);
void tl_dio_write32(struct tl_softc *, int, int);
void tl_dio_setbit(struct tl_softc *, int, int);
void tl_dio_clrbit(struct tl_softc *, int, int);
void tl_dio_setbit16(struct tl_softc *, int, int);
void tl_dio_clrbit16(struct tl_softc *, int, int);
d1710 1
a1710 1
	splx(s);
d1852 1
a1852 1
	splx(s);
@


1.24.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.24.2.1 2002/06/11 03:42:26 art Exp $	*/
d432 1
a432 1
	 * Feed in each bit and strobe the clock.
d863 1
a863 1
	int			h;
d867 1
d870 3
d876 14
a889 5
	ifp->if_flags &= ~IFF_ALLMULTI;
#if 0
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (memcmp(enm->enm_addrlo, enm->enm_addrhi, 6) == 0) {
d891 6
a896 5
			hashes[h/32] |= (1 << (h % 32));
		} else {
			hashes[0] = hashes[1] = 0xffffffff;
			ifp->if_flags |= IFF_ALLMULTI;
			break;
a897 1
		ETHER_NEXT_MULTI(step, enm);
a898 14
#else
	ETHER_FIRST_MULTI(step, ac, enm);
	h = 0;
	while (enm != NULL) {
		h++;
		ETHER_NEXT_MULTI(step, enm);
	}
	if (h) {
		hashes[0] = hashes[1] = 0xffffffff;
		ifp->if_flags |= IFF_ALLMULTI;
	} else {
		hashes[0] = hashes[1] = 0x00000000;
	}
#endif
@


1.24.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1482 1
a1482 1
				vtophys(mtod(m, vaddr_t));
@


1.23
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.22 2001/08/12 20:03:49 mickey Exp $	*/
d212 1
a212 1
#include <vm/vm.h>              /* for vtophys */
@


1.22
log
@remove redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.21 2001/06/27 06:34:49 kjc Exp $	*/
d2053 1
a2053 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.21
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.20 2001/06/24 20:27:01 fgsch Exp $	*/
a212 1
#include <vm/pmap.h>            /* for vtophys */
@


1.20
log
@more ether_input_mbuf() conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.19 2001/04/05 02:03:12 jason Exp $	*/
d1395 1
a1395 1
	if (ifp->if_snd.ifq_head != NULL)
d1571 1
a1571 1
		IF_DEQUEUE(&ifp->if_snd, m_head);
d2154 2
a2155 1
	ifp->if_snd.ifq_maxlen = TL_TX_LIST_CNT - 1;
@


1.19
log
@merge with freebsd/netbsd; mainly a conversion to mii
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.18 2001/03/25 06:37:27 csapuntz Exp $	*/
d1157 1
a1167 1
			m->m_pkthdr.len = m->m_len = total_len;
d1171 2
a1172 5
		/* Remove header from mbuf and pass it on. */
		m->m_pkthdr.len = m->m_len =
				total_len - sizeof(struct ether_header);
		m->m_data += sizeof(struct ether_header);
		ether_input(ifp, eh, m);
@


1.18
log
@Missing splx(s). Thanks to Dawson and team
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.17 2001/02/20 19:39:43 mickey Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_tl.c,v 1.32 1999/05/09 17:07:01 peter Exp $
d215 3
d229 2
a230 1
/* #define TL_BACKGROUND_AUTONEG */
d232 12
a243 1
#include <dev/pci/if_tlreg.h>
a247 2

int tl_attach_phy	__P((struct tl_softc *));
d280 3
a282 2
u_int16_t tl_phy_readreg	__P((struct tl_softc *, int));
void tl_phy_writereg	__P((struct tl_softc *, int, int));
a283 1
void tl_autoneg		__P((struct tl_softc *, int, int));
d289 1
a289 1
void tl_hardreset	__P((struct tl_softc *));
d736 3
a738 3
u_int16_t tl_phy_readreg(sc, reg)
	struct tl_softc		*sc;
	int			reg;
d740 1
d745 1
a745 1
	frame.mii_phyaddr = sc->tl_phy_addr;
a748 3
	/* Reenable MII interrupts, just in case. */
	tl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);

d752 3
a754 4
void tl_phy_writereg(sc, reg, data)
	struct tl_softc		*sc;
	int			reg;
	int			data;
d756 1
d761 1
a761 1
	frame.mii_phyaddr = sc->tl_phy_addr;
a765 5

	/* Reenable MII interrupts, just in case. */
	tl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);

	return;
d768 2
a769 51
/*
 * Initiate autonegotiation with a link partner.
 *
 * Note that the Texas Instruments ThunderLAN programmer's guide
 * fails to mention one very important point about autonegotiation.
 * Autonegotiation is done largely by the PHY, independent of the
 * ThunderLAN chip itself: the PHY sets the flags in the BMCR
 * register to indicate what modes were selected and if link status
 * is good. In fact, the PHY does pretty much all of the work itself,
 * except for one small detail.
 *
 * The PHY may negotiate a full-duplex of half-duplex link, and set
 * the PHY_BMCR_DUPLEX bit accordingly, but the ThunderLAN's 'NetCommand'
 * register _also_ has a half-duplex/full-duplex bit, and you MUST ALSO
 * SET THIS BIT MANUALLY TO CORRESPOND TO THE MODE SELECTED FOR THE PHY!
 * In other words, both the ThunderLAN chip and the PHY have to be
 * programmed for full-duplex mode in order for full-duplex to actually
 * work. So in order for autonegotiation to really work right, we have
 * to wait for the link to come up, check the BMCR register, then set
 * the ThunderLAN for full or half-duplex as needed.
 *
 * I struggled for two days to figure this out, so I'm making a point
 * of drawing attention to this fact. I think it's very strange that
 * the ThunderLAN doesn't automagically track the duplex state of the
 * PHY, but there you have it.
 *
 * Also when, using a National Semiconductor DP83840A PHY, we have to
 * allow a full three seconds for autonegotiation to complete. So what
 * we do is flip the autonegotiation restart bit, then set a timeout
 * to wake us up in three seconds to check the link state.
 *
 * Note that there are some versions of the Olicom 2326 that use a
 * Micro Linear ML6692 100BaseTX PHY. This particular PHY is designed
 * to provide 100BaseTX support only, but can be used with a controller
 * that supports an internal 10Mbps PHY to provide a complete
 * 10/100Mbps solution. However, the ML6692 does not have vendor and
 * device ID registers, and hence always shows up with a vendor/device
 * ID of 0.
 *
 * We detect this configuration by checking the phy vendor ID in the
 * softc structure. If it's a zero, and we're negotiating a high-speed
 * mode, then we turn off the internal PHY. If it's a zero and we've
 * negotiated a high-speed mode, we turn on the internal PHY. Note
 * that to make things even more fun, we have to make extra sure that
 * the loopback bit in the internal PHY's control register is turned
 * off.
 */
void tl_autoneg(sc, flag, verbose)
	struct tl_softc		*sc;
	int			flag;
	int			verbose;
d771 1
a771 3
	u_int16_t		phy_sts = 0, media = 0, advert, ability;
	struct ifnet		*ifp;
	struct ifmedia		*ifm;
d773 2
a774 132
	ifm = &sc->ifmedia;
	ifp = &sc->arpcom.ac_if;

	/*
	 * First, see if autoneg is supported. If not, there's
	 * no point in continuing.
	 */
	phy_sts = tl_phy_readreg(sc, PHY_BMSR);
	if (!(phy_sts & PHY_BMSR_CANAUTONEG)) {
		if (verbose)
			printf("tl%d: autonegotiation not supported\n",
							sc->tl_unit);
		return;
	}

	switch (flag) {
	case TL_FLAG_FORCEDELAY:
		/*
	 	 * XXX Never use this option anywhere but in the probe
	 	 * routine: making the kernel stop dead in its tracks
 		 * for three whole seconds after we've gone multi-user
		 * is really bad manners.
	 	 */
		tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);
		DELAY(500);
		phy_sts = tl_phy_readreg(sc, PHY_BMCR);
		phy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;
		tl_phy_writereg(sc, PHY_BMCR, phy_sts);
		DELAY(5000000);
		break;
	case TL_FLAG_SCHEDDELAY:
		/*
		 * Wait for the transmitter to go idle before starting
		 * an autoneg session, otherwise tl_start() may clobber
	 	 * our timeout, and we don't want to allow transmission
		 * during an autoneg session since that can screw it up.
	 	 */
		if (!sc->tl_txeoc) {
			sc->tl_want_auto = 1;
			return;
		}
		tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);
		DELAY(500);
		phy_sts = tl_phy_readreg(sc, PHY_BMCR);
		phy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;
		tl_phy_writereg(sc, PHY_BMCR, phy_sts);
		ifp->if_timer = 10;
		sc->tl_autoneg = 1;
		sc->tl_want_auto = 0;
		return;
	case TL_FLAG_DELAYTIMEO:
		ifp->if_timer = 0;
		sc->tl_autoneg = 0;
		break;
	default:
		printf("tl%d: invalid autoneg flag: %d\n", sc->tl_unit, flag);
		return;
	}

	/*
 	 * Read the BMSR register twice: the LINKSTAT bit is a
	 * latching bit.
	 */
	tl_phy_readreg(sc, PHY_BMSR);
	phy_sts = tl_phy_readreg(sc, PHY_BMSR);
	if (phy_sts & PHY_BMSR_AUTONEGCOMP) {
		if (verbose)
			printf("tl%d: autoneg complete, ", sc->tl_unit);
		phy_sts = tl_phy_readreg(sc, PHY_BMSR);
	} else {
		if (verbose)
			printf("tl%d: autoneg not complete, ", sc->tl_unit);
	}

	/* Link is good. Report modes and set duplex mode. */
	if (phy_sts & PHY_BMSR_LINKSTAT) {
		if (verbose)
			printf("link status good ");

		advert = tl_phy_readreg(sc, TL_PHY_ANAR);
		ability = tl_phy_readreg(sc, TL_PHY_LPAR);
		media = tl_phy_readreg(sc, PHY_BMCR);

		/*
	 	 * Be sure to turn off the ISOLATE and
		 * LOOPBACK bits in the control register,
		 * otherwise we may not be able to communicate.
		 */
		media &= ~(PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);
		/* Set the DUPLEX bit in the NetCmd register accordingly. */
		if (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {
			ifm->ifm_media = IFM_ETHER|IFM_100_T4;
			media |= PHY_BMCR_SPEEDSEL;
			media &= ~PHY_BMCR_DUPLEX;
			if (verbose)
				printf("(100baseT4)\n");
		} else if (advert & PHY_ANAR_100BTXFULL &&
			ability & PHY_ANAR_100BTXFULL) {
			ifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;
			media |= PHY_BMCR_SPEEDSEL;
			media |= PHY_BMCR_DUPLEX;
			if (verbose)
				printf("(full-duplex, 100Mbps)\n");
		} else if (advert & PHY_ANAR_100BTXHALF &&
			ability & PHY_ANAR_100BTXHALF) {
			ifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;
			media |= PHY_BMCR_SPEEDSEL;
			media &= ~PHY_BMCR_DUPLEX;
			if (verbose)
				printf("(half-duplex, 100Mbps)\n");
		} else if (advert & PHY_ANAR_10BTFULL &&
			ability & PHY_ANAR_10BTFULL) {
			ifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;
			media &= ~PHY_BMCR_SPEEDSEL;
			media |= PHY_BMCR_DUPLEX;
			if (verbose)
				printf("(full-duplex, 10Mbps)\n");
		} else {
			ifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;
			media &= ~PHY_BMCR_SPEEDSEL;
			media &= ~PHY_BMCR_DUPLEX;
			if (verbose)
				printf("(half-duplex, 10Mbps)\n");
		}

		if (media & PHY_BMCR_DUPLEX)
			tl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);
		else
			tl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);

		media &= ~PHY_BMCR_AUTONEGENBL;
		tl_phy_writereg(sc, PHY_BMCR, media);
d776 1
a776 10
		if (verbose)
			printf("no carrier\n");
	}

	tl_init(sc);

	if (sc->tl_tx_pend) {
		sc->tl_autoneg = 0;
		sc->tl_tx_pend = 0;
		tl_start(ifp);
a777 2

	return;
d781 1
a781 2
 * Set speed and duplex mode. Also program autoneg advertisements
 * accordingly.
d787 2
a788 69
	u_int16_t		bmcr;

	if (sc->tl_bitrate) {
		if (IFM_SUBTYPE(media) == IFM_10_5)
			tl_dio_setbit(sc, TL_ACOMMIT, TL_AC_MTXD1);
		if (IFM_SUBTYPE(media) == IFM_10_T) {
			tl_dio_clrbit(sc, TL_ACOMMIT, TL_AC_MTXD1);
			if ((media & IFM_GMASK) == IFM_FDX) {
				tl_dio_clrbit(sc, TL_ACOMMIT, TL_AC_MTXD3);
				tl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);
			} else {
				tl_dio_setbit(sc, TL_ACOMMIT, TL_AC_MTXD3);
				tl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);
			}
		}
		return;
	}

	bmcr = tl_phy_readreg(sc, PHY_BMCR);

	bmcr &= ~(PHY_BMCR_SPEEDSEL|PHY_BMCR_DUPLEX|PHY_BMCR_AUTONEGENBL|
		  PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);

	if (IFM_SUBTYPE(media) == IFM_LOOP)
		bmcr |= PHY_BMCR_LOOPBK;

	if (IFM_SUBTYPE(media) == IFM_AUTO)
		bmcr |= PHY_BMCR_AUTONEGENBL;

	/*
	 * The ThunderLAN's internal PHY has an AUI transceiver
	 * that can be selected. This is usually attached to a
	 * 10base2/BNC port. In order to activate this port, we
	 * have to set the AUISEL bit in the internal PHY's
	 * special control register.
	 */
	if (IFM_SUBTYPE(media) == IFM_10_5) {
		u_int16_t		addr, ctl;
		addr = sc->tl_phy_addr;
		sc->tl_phy_addr = TL_PHYADDR_MAX;
		ctl = tl_phy_readreg(sc, TL_PHY_CTL);
		ctl |= PHY_CTL_AUISEL;
		tl_phy_writereg(sc, TL_PHY_CTL, ctl);
		tl_phy_writereg(sc, PHY_BMCR, bmcr);
		sc->tl_phy_addr = addr;
		bmcr |= PHY_BMCR_ISOLATE;
	} else {
		u_int16_t		addr, ctl;
		addr = sc->tl_phy_addr;
		sc->tl_phy_addr = TL_PHYADDR_MAX;
		ctl = tl_phy_readreg(sc, TL_PHY_CTL);
		ctl &= ~PHY_CTL_AUISEL;
		tl_phy_writereg(sc, TL_PHY_CTL, ctl);
		tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);
		sc->tl_phy_addr = addr;
		bmcr &= ~PHY_BMCR_ISOLATE;
	}

	if (IFM_SUBTYPE(media) == IFM_100_TX) {
		bmcr |= PHY_BMCR_SPEEDSEL;
		if ((media & IFM_GMASK) == IFM_FDX) {
			bmcr |= PHY_BMCR_DUPLEX;
			tl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);
		} else {
			bmcr &= ~PHY_BMCR_DUPLEX;
			tl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);
		}
	}

d790 1
a790 1
		bmcr &= ~PHY_BMCR_SPEEDSEL;
d792 1
a792 1
			bmcr |= PHY_BMCR_DUPLEX;
d795 1
a795 1
			bmcr &= ~PHY_BMCR_DUPLEX;
a798 6

	tl_phy_writereg(sc, PHY_BMCR, bmcr);

	tl_init(sc);

	return;
d913 2
a914 2
void tl_hardreset(sc)
	struct tl_softc		*sc;
d916 1
d918 1
a918 3
	u_int16_t		old_addr, flags;

	old_addr = sc->tl_phy_addr;
d920 1
a920 4
	for (i = 0; i < TL_PHYADDR_MAX + 1; i++) {
		sc->tl_phy_addr = i;
		tl_mii_sync(sc);
	}
d922 2
a923 13
	flags = PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE|PHY_BMCR_PWRDOWN;

	for (i = 0; i < TL_PHYADDR_MAX + 1; i++) {
		sc->tl_phy_addr = i;
		tl_phy_writereg(sc, PHY_BMCR, flags);
	}

	sc->tl_phy_addr = TL_PHYADDR_MAX;
	tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);

	DELAY(50000);

	tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_LOOPBK|PHY_BMCR_ISOLATE);
d925 1
d927 1
d929 1
a929 4
	while(tl_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_RESET);

	sc->tl_phy_addr = old_addr;

a966 3
        /* Set PCI burst size */
	tl_dio_write8(sc, TL_BSIZEREG, 0x33);

a980 10
	/* Clear status register */
        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_MIRQ);
        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_HBEAT);
        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_TXSTOP);
        tl_dio_setbit16(sc, TL_NETSTS, TL_STS_RXSTOP);

	/* Enable network status interrupts for everything. */
	tl_dio_setbit(sc, TL_NETMASK, TL_MASK_MASK7|TL_MASK_MASK6|
			TL_MASK_MASK5|TL_MASK_MASK4);

a990 102
 * Do the interface setup and attach for a PHY on a particular
 * ThunderLAN chip. Also also set up interrupt vectors.
 */ 
int tl_attach_phy(sc)
	struct tl_softc		*sc;
{
	int			phy_ctl;
	int			media = IFM_ETHER|IFM_100_TX|IFM_FDX;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	sc->tl_phy_did = tl_phy_readreg(sc, TL_PHY_DEVID);
	sc->tl_phy_vid = tl_phy_readreg(sc, TL_PHY_VENID);
	sc->tl_phy_sts = tl_phy_readreg(sc, TL_PHY_GENSTS);
	phy_ctl = tl_phy_readreg(sc, TL_PHY_GENCTL);

	if (sc->tl_phy_sts & PHY_BMSR_100BT4 ||
		sc->tl_phy_sts & PHY_BMSR_100BTXFULL ||
		sc->tl_phy_sts & PHY_BMSR_100BTXHALF) 
		ifp->if_baudrate = 100000000;
	else
		ifp->if_baudrate = 10000000;

	if (sc->tl_phy_sts & PHY_BMSR_100BT4 ||
		sc->tl_phy_sts & PHY_BMSR_100BTXHALF ||
		sc->tl_phy_sts & PHY_BMSR_100BTXHALF) {
	} else {
		media &= ~IFM_100_TX;
		media |= IFM_10_T;
	}

	if (sc->tl_phy_sts & PHY_BMSR_100BTXFULL ||
		sc->tl_phy_sts & PHY_BMSR_10BTFULL) {
	} else {
		media &= ~IFM_FDX;
	}

	if (sc->tl_phy_sts & PHY_BMSR_CANAUTONEG) {
		media = IFM_ETHER|IFM_AUTO;
	}

	/* Set up ifmedia data and callbacks. */
	ifmedia_init(&sc->ifmedia, 0, tl_ifmedia_upd, tl_ifmedia_sts);

	/*
	 * All ThunderLANs support at least 10baseT half duplex.
	 * They also support AUI selection if used in 10Mb/s modes.
	 */
	ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);
	ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);
	ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_5, 0, NULL);

	/* Some ThunderLAN PHYs support autonegotiation. */
	if (sc->tl_phy_sts & PHY_BMSR_CANAUTONEG)
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);

	/* Some support 10baseT full duplex. */
	if (sc->tl_phy_sts & PHY_BMSR_10BTFULL)
		ifmedia_add(&sc->ifmedia,
			IFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);

	/* Some support 100BaseTX half duplex. */
	if (sc->tl_phy_sts & PHY_BMSR_100BTXHALF)
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_TX, 0, NULL);
	if (sc->tl_phy_sts & PHY_BMSR_100BTXHALF)
		ifmedia_add(&sc->ifmedia,
			IFM_ETHER|IFM_100_TX|IFM_HDX, 0, NULL);

	/* Some support 100BaseTX full duplex. */
	if (sc->tl_phy_sts & PHY_BMSR_100BTXFULL)
		ifmedia_add(&sc->ifmedia,
			IFM_ETHER|IFM_100_TX|IFM_FDX, 0, NULL);

	/* Some also support 100BaseT4. */
	if (sc->tl_phy_sts & PHY_BMSR_100BT4)
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_T4, 0, NULL);

	/* Set default media. */
	ifmedia_set(&sc->ifmedia, media);

	/*
	 * Kick off an autonegotiation session if this PHY supports it.
	 * This is necessary to make sure the chip's duplex mode matches
	 * the PHY's duplex mode. It may not: once enabled, the PHY may
	 * autonegotiate full-duplex mode with its link partner, but the
	 * ThunderLAN chip defaults to half-duplex and stays there unless
	 * told otherwise.
	 */
	if (sc->tl_phy_sts & PHY_BMSR_CANAUTONEG) {
		tl_init(sc);
#ifdef TL_BACKGROUND_AUTONEG
		tl_autoneg(sc, TL_FLAG_SCHEDDELAY, 1);
#else
		tl_autoneg(sc, TL_FLAG_FORCEDELAY, 1);
#endif
	}

	return(0);
}

/*
a1279 10
		/*
		 * If we just drained the TX queue and
		 * there's an autoneg request waiting, set
		 * it in motion. This will block the transmitter
		 * until the autoneg session completes which will
		 * no doubt piss off any processes waiting to
		 * transmit, but that's the way the ball bounces.
		 */
		if (sc->tl_want_auto)
			tl_autoneg(sc, TL_FLAG_SCHEDDELAY, 1);
d1286 1
a1286 1
				vtophys(sc->tl_cdata.tl_tx_head->tl_ptr));
a1302 1
	u_int16_t		bmcr, ctl;
d1310 1
a1310 18
	/*
	 * Before resetting the adapter, try reading the PHY
	 * settings so we can put them back later. This is
	 * necessary to keep the chip operating at the same
	 * speed and duplex settings after the reset completes.
	 */
	if (!sc->tl_bitrate) {
		bmcr = tl_phy_readreg(sc, PHY_BMCR);
		ctl = tl_phy_readreg(sc, TL_PHY_CTL);
		tl_softreset(sc, 1);
		tl_phy_writereg(sc, PHY_BMCR, bmcr);
		tl_phy_writereg(sc, TL_PHY_CTL, ctl);
		if (bmcr & PHY_BMCR_DUPLEX) {
			tl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);
		} else {
			tl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);
		}
	}
d1411 3
d1437 11
d1450 4
a1561 5
	if (sc->tl_autoneg) {
		sc->tl_tx_pend = 1;
		return;
	}

a1647 4
	u_int16_t		phy_sts;

	if (sc->tl_autoneg)
		return;
d1658 7
d1681 2
a1700 10
	/*
	 * Enable PHY interrupts.
	 */
	phy_sts = tl_phy_readreg(sc, TL_PHY_CTL);
	phy_sts |= PHY_CTL_INTEN;
	tl_phy_writereg(sc, TL_PHY_CTL, phy_sts);

	/* Enable MII interrupts. */
	tl_dio_setbit(sc, TL_NETSIO, TL_SIO_MINTEN);

d1708 2
a1709 23
	/*
	 * XXX This is a kludge to handle adapters with the Micro Linear
	 * ML6692 100BaseTX PHY, which only supports 100Mbps modes and
	 * relies on the controller's internal 10Mbps PHY to provide
	 * 10Mbps modes. The ML6692 always shows up with a vendor/device ID
	 * of 0 (it doesn't actually have vendor/device ID registers)
	 * so we use that property to detect it. In theory there ought to
	 * be a better way to 'spot the looney' but I can't find one.
         */
        if (!sc->tl_phy_vid) {
                u_int8_t                        addr = 0;
                u_int16_t                       bmcr;

                bmcr = tl_phy_readreg(sc, PHY_BMCR);
                addr = sc->tl_phy_addr;
                sc->tl_phy_addr = TL_PHYADDR_MAX;
                tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);
                if (bmcr & PHY_BMCR_SPEEDSEL)
                        tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_ISOLATE);
                else
                        tl_phy_writereg(sc, PHY_BMCR, bmcr);
                sc->tl_phy_addr = addr;
        }
d1712 1
a1712 1
	CMD_SET(sc, TL_CMD_GO|TL_CMD_RT);
d1728 3
a1730 2
int tl_ifmedia_upd(ifp)
	struct ifnet		*ifp;
d1732 1
a1732 2
	struct tl_softc		*sc;
	struct ifmedia		*ifm;
d1734 2
a1735 8
	sc = ifp->if_softc;
	ifm = &sc->ifmedia;

	if (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)
		return(EINVAL);

	if (IFM_SUBTYPE(ifm->ifm_media) == IFM_AUTO)
		tl_autoneg(sc, TL_FLAG_SCHEDDELAY, 1);
d1737 1
a1737 1
		tl_setmode(sc, ifm->ifm_media);
a1748 2
	u_int16_t		phy_ctl;
	u_int16_t		phy_sts;
d1750 1
d1753 1
a1765 19
	}

	phy_ctl = tl_phy_readreg(sc, PHY_BMCR);
	phy_sts = tl_phy_readreg(sc, TL_PHY_CTL);

	if (phy_sts & PHY_CTL_AUISEL)
		ifmr->ifm_active = IFM_ETHER|IFM_10_5;

	if (phy_ctl & PHY_BMCR_LOOPBK)
		ifmr->ifm_active = IFM_ETHER|IFM_LOOP;

	if (phy_ctl & PHY_BMCR_SPEEDSEL)
		ifmr->ifm_active = IFM_ETHER|IFM_100_TX;
	else
		ifmr->ifm_active = IFM_ETHER|IFM_10_T;

	if (phy_ctl & PHY_BMCR_DUPLEX) {
		ifmr->ifm_active |= IFM_FDX;
		ifmr->ifm_active &= ~IFM_HDX;
d1767 3
a1769 2
		ifmr->ifm_active &= ~IFM_FDX;
		ifmr->ifm_active |= IFM_HDX;
d1808 12
a1819 1
			tl_init(sc);
d1825 1
d1845 5
a1849 1
		error = ifmedia_ioctl(ifp, ifr, &sc->ifmedia, command);
a1864 1
	u_int16_t		bmsr;
d1868 1
a1868 13
	if (sc->tl_autoneg) {
		tl_autoneg(sc, TL_FLAG_DELAYTIMEO, 1);
		return;
	}

	/* Check that we're still connected. */
	tl_phy_readreg(sc, PHY_BMSR);
	bmsr = tl_phy_readreg(sc, PHY_BMSR);
	if (!(bmsr & PHY_BMSR_LINKSTAT)) {
		printf("tl%d: no carrier\n", sc->tl_unit);
		tl_autoneg(sc, TL_FLAG_SCHEDDELAY, 1);
	} else
		printf("tl%d: device timeout\n", sc->tl_unit);
d1872 1
a1909 5
	 * Disable MII interrupts.
	 */
	tl_dio_clrbit(sc, TL_NETSIO, TL_SIO_MINTEN);

	/*
d2001 4
a2004 3
	u_int round;
	u_int8_t *roundptr;
	int i, phys;
d2074 26
a2099 5
	sc->tl_ldata_ptr = malloc(sizeof(struct tl_list_data) + 8,
				M_DEVBUF, M_NOWAIT);
	if (sc->tl_ldata_ptr == NULL) {
		printf("\n%s: no memory for list buffers\n",
		    sc->sc_dev.dv_xname);
d2102 2
a2103 1
	bzero(sc->tl_ldata_ptr, sizeof(struct tl_list_data) + 8);
d2105 4
a2108 13
	sc->tl_ldata = (struct tl_list_data *)sc->tl_ldata_ptr;
#ifdef __i386__
	round = (u_int32_t)sc->tl_ldata_ptr & 0xF;
#endif
#ifdef __alpha__
	round = (u_int64_t)sc->tl_ldata_ptr & 0xF;
#endif
	roundptr = sc->tl_ldata_ptr;
	for (i = 0; i < 8; i++) {
		if (round % 8) {
			round++;
			roundptr++;
		} else
d2111 1
a2111 2
	sc->tl_ldata = (struct tl_list_data *)roundptr;

d2123 1
a2123 1
	tl_hardreset(sc);
d2157 1
a2157 1
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;
d2164 1
a2164 1
	tl_hardreset(sc);
d2168 13
a2180 18
	for (i = TL_PHYADDR_MIN; i < TL_PHYADDR_MAX + 1; i++) {
		sc->tl_phy_addr = i;
		tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);
		DELAY(500);
		while(tl_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_RESET);
		sc->tl_phy_sts = tl_phy_readreg(sc, PHY_BMSR);
		if (!sc->tl_phy_sts)
			continue;
		if (tl_attach_phy(sc)) {
			printf("%s: failed to attach a phy %d\n",
			    sc->sc_dev.dv_xname, i);
			return;
		}
		phys++;
		if (phys && i != TL_PHYADDR_MAX)
			break;
	}
	if (!phys) {
d2194 2
a2195 9
	}

	tl_intvec_adchk((void *)sc, 0);
	tl_stop(sc);

	/*
	 * Attempt to clear stray interrupts
	 */
	tl_intr((void *)sc);
@


1.17
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.16 2001/02/03 05:52:27 mickey Exp $	*/
d2095 1
@


1.16
log
@new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.15 2001/01/25 03:50:51 todd Exp $	*/
a2657 4
#if NBPFILTER > 0
	bpfattach(&sc->arpcom.ac_if.if_bpf, ifp,
	    DLT_EN10MB, sizeof(struct ether_header));
#endif
@


1.15
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.14 2000/11/14 03:56:32 jason Exp $	*/
d193 1
d1853 1
a1853 1
	timeout(tl_stats_update, sc, hz);
d2148 4
a2151 2
	timeout(tl_stats_update, sc, hz);
	timeout(tl_wait_up, sc, 2 * hz);
d2342 2
a2343 2
	untimeout(tl_stats_update, sc);
	untimeout(tl_wait_up, sc);
@


1.14
log
@remove diagnostic around TL_INTR_INVALID (this is a valid condition when two
devices are on the same interrupt).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.13 2000/09/21 04:03:52 jason Exp $	*/
d121 1
a121 1
 * has transfered the data into its on-board SRAM, it will trigger a
@


1.13
log
@Patch from FreeBSD (wpaul):
Fix the tl driver so it doesn't run off the end of the RX descriptor list
and panic in out of mbufs condition.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.12 2000/06/20 03:24:21 aaron Exp $	*/
a1775 4
#ifdef DIAGNOSTIC
		if (sc->tl_empty_intr == 0)
			printf("tl%d: got an invalid interrupt!\n", sc->tl_unit);
#endif
a2646 1
	sc->tl_empty_intr = 1;
a2647 1
	sc->tl_empty_intr = 0;
@


1.13.2.1
log
@Pull in patch from current:
Fix (jason):
remove diagnostic around TL_INTR_INVALID (this is a valid condition when two
devices are on the same interrupt).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.13 2000/09/21 04:03:52 jason Exp $	*/
d1776 4
d2651 1
d2653 1
@


1.12
log
@After bpf_mtap(), in promisc mode, don't drop packets that aren't for us here;
that is done in ether_input(); jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.11 2000/02/15 02:28:15 jason Exp $	*/
a1464 1
	c->tl_ptr->tlist_cstat = TL_CSTAT_READY;
d1468 1
d1509 4
a1512 1
	while(sc->tl_cdata.tl_rx_head->tl_ptr->tlist_cstat & TL_CSTAT_FRAMECMP){
a1513 1
		cur_rx = sc->tl_cdata.tl_rx_head;
d1584 1
d1587 1
d1593 2
@


1.11
log
@make sure to call ether_{add,del}multi() as appropriate in xxx_ioctl()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.10 1999/09/13 20:41:38 jason Exp $	*/
a1556 7
			if (ifp->if_flags & IFF_PROMISC &&
				(bcmp(eh->ether_dhost, sc->arpcom.ac_enaddr,
		 				ETHER_ADDR_LEN) &&
					(eh->ether_dhost[0] & 1) == 0)) {
				m_freem(m);
				continue;
			}
@


1.10
log
@openbsd-ify
merge with freebsd:
alpha support (untested)
missing ifmedia_set()
larger value for ifq_maxlen
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.9 1999/03/03 22:51:50 jason Exp $	*/
d2275 12
a2286 2
		tl_setmulti(sc);
		error = 0;
@


1.10.4.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.11 2000/02/15 02:28:15 jason Exp $	*/
d2275 2
a2276 12
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			tl_setmulti(sc);
			error = 0;
		}
@


1.10.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.19 2001/04/05 02:03:12 jason Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_tl.c,v 1.64 2001/02/06 10:11:48 phk Exp $
d121 1
a121 1
 * has transferred the data into its on-board SRAM, it will trigger a
a192 1
#include <sys/timeout.h>
a213 3
#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

d225 2
a227 14
#include <dev/mii/tlphyvar.h>

const struct tl_products tl_prods[] = {
	{ PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_N100TX, TLPHY_MEDIA_NO_10_T },
	{ PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_N10T, TLPHY_MEDIA_10_5 },
	{ PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_IntNF3P, TLPHY_MEDIA_10_2 },
	{ PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_IntPL100TX, TLPHY_MEDIA_10_5|TLPHY_MEDIA_NO_10_T },
	{ PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_DPNet100TX, TLPHY_MEDIA_10_5|TLPHY_MEDIA_NO_10_T },
	{ PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_DP4000, TLPHY_MEDIA_10_5 },
	{ PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_NF3P_BNC, TLPHY_MEDIA_10_2 },
	{ PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_NF3P, TLPHY_MEDIA_10_5 },
	{ PCI_VENDOR_TI, PCI_PRODUCT_TI_TLAN, 0 },
	{ 0, 0, 0 }
};
d232 2
d266 2
a267 3
int tl_miibus_readreg	__P((struct device *, int, int));
void tl_miibus_writereg	__P((struct device *, int, int, int));
void tl_miibus_statchg	__P((struct device *));
d269 1
d275 1
a275 1
void tl_hardreset	__P((struct device *));
d722 3
a724 3
int tl_miibus_readreg(dev, phy, reg)
	struct device		*dev;
	int			phy, reg;
a725 1
	struct tl_softc *sc = (struct tl_softc *)dev;
d730 1
a730 1
	frame.mii_phyaddr = phy;
d734 3
d740 4
a743 3
void tl_miibus_writereg(dev, phy, reg, data)
	struct device		*dev;
	int			phy, reg, data;
a744 1
	struct tl_softc *sc = (struct tl_softc *)dev;
d749 1
a749 1
	frame.mii_phyaddr = phy;
d754 5
d761 51
a811 2
void tl_miibus_statchg(dev)
	struct device *dev;
d813 18
a830 1
	struct tl_softc *sc = (struct tl_softc *)dev;
d832 117
a948 2
	if ((sc->sc_mii.mii_media_active & IFM_GMASK) == IFM_FDX) {
		tl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);
d950 10
a959 1
		tl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);
d961 2
d966 2
a967 1
 * Set modes for bitrate devices.
d973 69
a1041 2
	if (IFM_SUBTYPE(media) == IFM_10_5)
		tl_dio_setbit(sc, TL_ACOMMIT, TL_AC_MTXD1);
d1043 1
a1043 1
		tl_dio_clrbit(sc, TL_ACOMMIT, TL_AC_MTXD1);
d1045 1
a1045 1
			tl_dio_clrbit(sc, TL_ACOMMIT, TL_AC_MTXD3);
d1048 1
a1048 1
			tl_dio_setbit(sc, TL_ACOMMIT, TL_AC_MTXD3);
d1052 6
d1172 2
a1173 2
void tl_hardreset(dev)
	struct device *dev;
a1174 1
	struct tl_softc		*sc = (struct tl_softc *)dev;
d1176 1
a1176 1
	u_int16_t		flags;
d1178 1
a1178 1
	flags = BMCR_LOOP|BMCR_ISO|BMCR_PDOWN;
d1180 18
a1197 2
	for (i =0 ; i < MII_NPHY; i++)
		tl_miibus_writereg(dev, i, MII_BMCR, flags);
a1198 1
	tl_miibus_writereg(dev, 31, MII_BMCR, BMCR_ISO);
a1199 1
	while(tl_miibus_readreg(dev, 31, MII_BMCR) & BMCR_RESET);
d1201 4
a1204 1
	DELAY(5000);
d1242 3
d1259 10
d1279 102
d1465 1
a1468 1
	c->tl_ptr->tlist_cstat = TL_CSTAT_READY;
d1509 2
a1510 1
	while(sc->tl_cdata.tl_rx_head != NULL) {
a1511 3
		if (!(cur_rx->tl_ptr->tlist_cstat & TL_CSTAT_FRAMECMP))
			break;
		r++;
d1557 7
a1588 1
	struct tl_chain_data	*cd;
a1590 1
	cd = &sc->tl_cdata;
a1595 2
	cd->tl_rx_head = &cd->tl_rx_chain[0];
	cd->tl_rx_tail = &cd->tl_rx_chain[TL_RX_LIST_CNT - 1];
d1671 10
d1687 1
a1687 1
		    vtophys(sc->tl_cdata.tl_tx_head->tl_ptr));
d1704 1
d1712 18
a1729 1
	tl_softreset(sc, 1);
d1777 4
a1833 3
	int			s;

	s = splimp();
d1857 1
a1857 12
	if (tl_tx_underrun(tl_stats)) {
		u_int8_t	tx_thresh;
		tx_thresh = tl_dio_read8(sc, TL_ACOMMIT) & TL_AC_TXTHRESH;
		if (tx_thresh != TL_AC_TXTHRESH_WHOLEPKT) {
			tx_thresh >>= 4;
			tx_thresh++;
			tl_dio_clrbit(sc, TL_ACOMMIT, TL_AC_TXTHRESH);
			tl_dio_setbit(sc, TL_ACOMMIT, tx_thresh << 4);
		}
	}

	timeout_add(&sc->tl_stats_tmo, hz);
a1858 4
	if (!sc->tl_bitrate)
		mii_tick(&sc->sc_mii);

	splx(s);
d1967 5
d2058 4
a2071 7
	/* Initialize TX FIFO threshold */
	tl_dio_clrbit(sc, TL_ACOMMIT, TL_AC_TXTHRESH);
	tl_dio_setbit(sc, TL_ACOMMIT, TL_AC_TXTHRESH_16LONG);

	/* Set PCI burst size */
	tl_dio_write8(sc, TL_BSIZEREG, TL_RXBURST_16LONG|TL_TXBURST_16LONG);

a2087 2
	tl_dio_write16(sc, TL_MAXRX, MCLBYTES);

a2098 1
		splx(s);
d2105 10
d2122 23
a2144 2
	if (!sc->tl_bitrate) 
		mii_mediachg(&sc->sc_mii);
d2147 1
a2147 1
	CMD_SET(sc, TL_CMD_GO|TL_CMD_NES|TL_CMD_RT);
d2152 2
a2153 4
	timeout_set(&sc->tl_stats_tmo, tl_stats_update, sc);
	timeout_add(&sc->tl_stats_tmo, hz);
	timeout_set(&sc->tl_wait_tmo, tl_wait_up, sc);
	timeout_add(&sc->tl_wait_tmo, 2 * hz);
d2161 2
a2162 3
int
tl_ifmedia_upd(ifp)
	struct ifnet *ifp;
d2164 5
a2168 1
	struct tl_softc *sc = ifp->if_softc;
d2170 5
a2174 2
	if (sc->tl_bitrate)
		tl_setmode(sc, sc->ifmedia.ifm_media);
d2176 1
a2176 1
		mii_mediachg(&sc->sc_mii);
d2188 2
a2190 1
	struct mii_data		*mii;
a2192 1
	mii = &sc->sc_mii;
d2205 19
d2225 2
a2226 3
		mii_pollstat(mii);
		ifmr->ifm_active = mii->mii_media_active;
		ifmr->ifm_status = mii->mii_media_status;
d2265 1
a2265 12
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->tl_if_flags & IFF_PROMISC)) {
				tl_dio_setbit(sc, TL_NETCMD, TL_CMD_CAF);
				tl_setmulti(sc);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->tl_if_flags & IFF_PROMISC) {
				tl_dio_clrbit(sc, TL_NETCMD, TL_CMD_CAF);
				tl_setmulti(sc);
			} else
				tl_init(sc);
a2270 1
		sc->tl_if_flags = ifp->if_flags;
d2290 1
a2290 5
		if (sc->tl_bitrate)
			error = ifmedia_ioctl(ifp, ifr, &sc->ifmedia, command);
		else
			error = ifmedia_ioctl(ifp, ifr,
			    &sc->sc_mii.mii_media, command);
d2306 1
d2310 13
a2322 1
	printf("tl%d: device timeout\n", sc->tl_unit);
a2325 1
	tl_softreset(sc, 1);
d2344 2
a2345 2
	timeout_del(&sc->tl_stats_tmo);
	timeout_del(&sc->tl_wait_tmo);
d2363 5
d2459 3
a2461 4
	int i, rseg;
	bus_dma_segment_t seg;
	bus_dmamap_t dmamap;
	caddr_t kva;
d2531 5
a2535 18
	sc->sc_dmat = pa->pa_dmat;
	if (bus_dmamem_alloc(sc->sc_dmat, sizeof(struct tl_list_data),
	    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
		printf("%s: can't alloc list\n", sc->sc_dev.dv_xname);
		return;
	}
	if (bus_dmamem_map(sc->sc_dmat, &seg, rseg, sizeof(struct tl_list_data),
	    &kva, BUS_DMA_NOWAIT)) {
		printf("%s: can't map dma buffers (%d bytes)\n",
		    sc->sc_dev.dv_xname, sizeof(struct tl_list_data));
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
		return;
	}
	if (bus_dmamap_create(sc->sc_dmat, sizeof(struct tl_list_data), 1,
	    sizeof(struct tl_list_data), 0, BUS_DMA_NOWAIT, &dmamap)) {
		printf("%s: can't create dma map\n", sc->sc_dev.dv_xname);
		bus_dmamem_unmap(sc->sc_dmat, kva, sizeof(struct tl_list_data));
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
d2538 1
a2538 10
	if (bus_dmamap_load(sc->sc_dmat, dmamap, kva,
	    sizeof(struct tl_list_data), NULL, BUS_DMA_NOWAIT)) {
		printf("%s: can't load dma map\n", sc->sc_dev.dv_xname);
		bus_dmamap_destroy(sc->sc_dmat, dmamap);
		bus_dmamem_unmap(sc->sc_dmat, kva, sizeof(struct tl_list_data));
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
		return;
	}
	sc->tl_ldata = (struct tl_list_data *)kva;
	bzero(sc->tl_ldata, sizeof(struct tl_list_data));
d2540 13
a2552 4
	for (sc->tl_product = tl_prods; sc->tl_product->tp_vend;
	     sc->tl_product++) {
		if (sc->tl_product->tp_vend == PCI_VENDOR(pa->pa_id) &&
		    sc->tl_product->tp_prod == PCI_PRODUCT(pa->pa_id))
d2555 2
a2556 1
		
d2568 1
a2568 1
	tl_hardreset(self);
d2602 1
a2602 1
	ifp->if_snd.ifq_maxlen = TL_TX_LIST_CNT - 1;
d2609 1
a2609 1
	tl_hardreset(self);
d2613 18
a2630 13
	/*
	 * Do MII setup. If no PHYs are found, then this is a
	 * bitrate ThunderLAN chip that only supports 10baseT
	 * and AUI/BNC.
	 */
	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = tl_miibus_readreg;
	sc->sc_mii.mii_writereg = tl_miibus_writereg;
	sc->sc_mii.mii_statchg = tl_miibus_statchg;
	ifmedia_init(&sc->sc_mii.mii_media, 0, tl_ifmedia_upd, tl_ifmedia_sts);
	mii_attach(self, &sc->sc_mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY,
	    0);
	if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
d2644 11
a2654 2
	} else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);
d2662 4
@


1.10.4.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.10.4.2 2001/05/14 22:25:47 niklas Exp $	*/
a1156 1
		m->m_pkthdr.len = m->m_len = total_len;
d1167 1
d1171 5
a1175 2
		/* pass it on. */
		ether_input_mbuf(ifp, m);
d1398 1
a1398 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd))
d1574 1
a1574 1
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
d2157 1
a2157 2
	IFQ_SET_MAXLEN(&ifp->if_snd, TL_TX_LIST_CNT - 1);
	IFQ_SET_READY(&ifp->if_snd);
@


1.10.4.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.10.4.3 2001/07/04 10:42:24 niklas Exp $	*/
d213 1
d2054 2
a2055 1
	if (pci_intr_map(pa, &ih)) {
@


1.10.4.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d212 1
a212 1
#include <uvm/uvm_extern.h>              /* for vtophys */
@


1.10.4.6
log
@Merge in trunk
@
text
@d1710 1
a1710 1
	splx(s);
d1852 1
a1852 1
	splx(s);
@


1.10.4.7
log
@Merge in -current from roughly a week ago
@
text
@d244 58
a301 58
int tl_probe(struct device *, void *, void *);
void tl_attach(struct device *, struct device *, void *);
void tl_wait_up(void *);
int tl_intvec_rxeoc(void *, u_int32_t);
int tl_intvec_txeoc(void *, u_int32_t);
int tl_intvec_txeof(void *, u_int32_t);
int tl_intvec_rxeof(void *, u_int32_t);
int tl_intvec_adchk(void *, u_int32_t);
int tl_intvec_netsts(void *, u_int32_t);

int tl_newbuf(struct tl_softc *,
					struct tl_chain_onefrag *);
void tl_stats_update(void *);
int tl_encap(struct tl_softc *, struct tl_chain *,
						struct mbuf *);

int tl_intr(void *);
void tl_start(struct ifnet *);
int tl_ioctl(struct ifnet *, u_long, caddr_t);
void tl_init(void *);
void tl_stop(struct tl_softc *);
void tl_watchdog(struct ifnet *);
void tl_shutdown(void *);
int tl_ifmedia_upd(struct ifnet *);
void tl_ifmedia_sts(struct ifnet *, struct ifmediareq *);

u_int8_t tl_eeprom_putbyte(struct tl_softc *, int);
u_int8_t	tl_eeprom_getbyte(struct tl_softc *,
						int, u_int8_t *);
int tl_read_eeprom(struct tl_softc *, caddr_t, int, int);

void tl_mii_sync(struct tl_softc *);
void tl_mii_send(struct tl_softc *, u_int32_t, int);
int tl_mii_readreg(struct tl_softc *, struct tl_mii_frame *);
int tl_mii_writereg(struct tl_softc *, struct tl_mii_frame *);
int tl_miibus_readreg(struct device *, int, int);
void tl_miibus_writereg(struct device *, int, int, int);
void tl_miibus_statchg(struct device *);

void tl_setmode(struct tl_softc *, int);
int tl_calchash(caddr_t);
void tl_setmulti(struct tl_softc *);
void tl_setfilt(struct tl_softc *, caddr_t, int);
void tl_softreset(struct tl_softc *, int);
void tl_hardreset(struct device *);
int tl_list_rx_init(struct tl_softc *);
int tl_list_tx_init(struct tl_softc *);

u_int8_t tl_dio_read8(struct tl_softc *, int);
u_int16_t tl_dio_read16(struct tl_softc *, int);
u_int32_t tl_dio_read32(struct tl_softc *, int);
void tl_dio_write8(struct tl_softc *, int, int);
void tl_dio_write16(struct tl_softc *, int, int);
void tl_dio_write32(struct tl_softc *, int, int);
void tl_dio_setbit(struct tl_softc *, int, int);
void tl_dio_clrbit(struct tl_softc *, int, int);
void tl_dio_setbit16(struct tl_softc *, int, int);
void tl_dio_clrbit16(struct tl_softc *, int, int);
@


1.10.4.8
log
@Sync the SMP branch with 3.3
@
text
@d432 1
a432 1
	 * Feed in each bit and strobe the clock.
d863 1
a863 1
	int			h;
d867 1
d870 3
d876 14
a889 5
	ifp->if_flags &= ~IFF_ALLMULTI;
#if 0
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (memcmp(enm->enm_addrlo, enm->enm_addrhi, 6) == 0) {
d891 6
a896 5
			hashes[h/32] |= (1 << (h % 32));
		} else {
			hashes[0] = hashes[1] = 0xffffffff;
			ifp->if_flags |= IFF_ALLMULTI;
			break;
a897 14
		ETHER_NEXT_MULTI(step, enm);
	}
#else
	ETHER_FIRST_MULTI(step, ac, enm);
	h = 0;
	while (enm != NULL) {
		h++;
		ETHER_NEXT_MULTI(step, enm);
	}
	if (h) {
		hashes[0] = hashes[1] = 0xffffffff;
		ifp->if_flags |= IFF_ALLMULTI;
	} else {
		hashes[0] = hashes[1] = 0x00000000;
a898 1
#endif
d1481 1
a1481 1
				vtophys(mtod(m, vaddr_t));
@


1.10.4.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d480 2
a481 2
		printf("%s: failed to send write command, status: %x\n",
			sc->sc_dev.dv_xname, tl_dio_read8(sc, TL_NETSIO));
d489 2
a490 2
		printf("%s: failed to send address, status: %x\n",
			sc->sc_dev.dv_xname, tl_dio_read8(sc, TL_NETSIO));
d500 2
a501 2
		printf("%s: failed to send write command, status: %x\n",
			sc->sc_dev.dv_xname, tl_dio_read8(sc, TL_NETSIO));
d1304 1
a1304 1
		printf("%s: adapter check: %x\n", sc->sc_dev.dv_xname,
d1327 1
a1327 1
	printf("%s: network status: %x\n", sc->sc_dev.dv_xname, netsts);
d1373 1
a1373 1
		printf("%s: got a dummy interrupt\n", sc->sc_dev.dv_xname);
d1386 1
a1386 1
		printf("%s: bogus interrupt type\n", sc->sc_dev.dv_xname);
d1688 2
a1689 2
		printf("%s: initialization failed: no memory for rx buffers\n",
			sc->sc_dev.dv_xname);
a1802 1
		break;
d1865 1
a1865 1
	printf("%s: device timeout\n", sc->sc_dev.dv_xname);
d2108 1
@


1.9
log
@remove alot of verbosity
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.8 1999/02/27 19:05:43 jason Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_tl.c,v 1.26 1999/02/01 21:25:51 wpaul Exp $
d192 1
a194 4
#if defined(__FreeBSD__)
#include <net/if_arp.h>
#include <net/ethernet.h>
#endif
a195 2
#if defined(__OpenBSD__)
#include <sys/device.h>
d203 1
a203 1
#endif
a212 5
#if defined(__FreeBSD__)
#include <machine/clock.h>      /* for DELAY */
#include <pci/pcireg.h>
#include <pci/pcivar.h>
#endif
a213 1
#if defined(__OpenBSD__)
a216 1
#endif
a226 5
#if defined(__FreeBSD__)
#include <pci/if_tlreg.h>
#endif

#if defined(__OpenBSD__)
a227 1
#endif
d229 11
a239 102
#if !defined(lint) && !defined(__OpenBSD__)
static char rcsid[] =
	"$FreeBSD: if_tl.c,v 1.26 1999/02/01 21:25:51 wpaul Exp $";
#endif

#ifdef TL_DEBUG
#define EV_TXEOC 2
#define EV_TXEOF 3
#define EV_RXEOC 4
#define EV_RXEOF 5
#define EV_START_TX 6
#define EV_START_Q 7
#define EV_SETMODE 8
#define EV_AUTONEG_XMIT 9
#define EV_AUTONEG_FIN 10
#define EV_START_TX_REAL 11
#define EV_WATCHDOG 12
#define EV_INIT	13

static void evset(struct tl_softc *, int);
static void evshow(struct tl_softc *);

static void evset(sc, e)
	struct tl_softc		*sc;
	int			e;
{
	int			i;

	for (i = 19; i > 0; i--)
		sc->tl_event[i] = sc->tl_event[i - 1];
	sc->tl_event[0] = e;

	return;
}

static void evshow(sc)
	struct tl_softc		*sc;
{
	int			i;

	printf("tl%d: events: ", sc->tl_unit);
	for (i = 0; i < 20; i++)
		printf(" %d", sc->tl_event[i]);
	printf("\n");

	return;
}
#endif

#ifdef __FreeBSD__
/*
 * Various supported device vendors/types and their names.
 */

static struct tl_type tl_devs[] = {
	{ TI_VENDORID,	TI_DEVICEID_THUNDERLAN,
		"Texas Instruments ThunderLAN" },
	{ COMPAQ_VENDORID, COMPAQ_DEVICEID_NETEL_10,
		"Compaq Netelligent 10" },
	{ COMPAQ_VENDORID, COMPAQ_DEVICEID_NETEL_10_100,
		"Compaq Netelligent 10/100" },
	{ COMPAQ_VENDORID, COMPAQ_DEVICEID_NETEL_10_100_PROLIANT,
		"Compaq Netelligent 10/100 Proliant" },
	{ COMPAQ_VENDORID, COMPAQ_DEVICEID_NETEL_10_100_DUAL,
		"Compaq Netelligent 10/100 Dual Port" },
	{ COMPAQ_VENDORID, COMPAQ_DEVICEID_NETFLEX_3P_INTEGRATED,
		"Compaq NetFlex-3/P Integrated" },
	{ COMPAQ_VENDORID, COMPAQ_DEVICEID_NETFLEX_3P,
		"Compaq NetFlex-3/P" },
	{ COMPAQ_VENDORID, COMPAQ_DEVICEID_NETFLEX_3P_BNC,
		"Compaq NetFlex 3/P w/ BNC" },
	{ COMPAQ_VENDORID, COMPAQ_DEVICEID_NETEL_10_100_EMBEDDED,
		"Compaq Netelligent 10/100 TX Embedded UTP" },
	{ COMPAQ_VENDORID, COMPAQ_DEVICEID_NETEL_10_T2_UTP_COAX,
		"Compaq Netelligent 10 T/2 PCI UTP/Coax" },
	{ COMPAQ_VENDORID, COMPAQ_DEVICEID_NETEL_10_100_TX_UTP,
		"Compaq Netelligent 10/100 TX UTP" },
	{ OLICOM_VENDORID, OLICOM_DEVICEID_OC2183,
		"Olicom OC-2183/2185" },
	{ OLICOM_VENDORID, OLICOM_DEVICEID_OC2325,
		"Olicom OC-2325" },
	{ OLICOM_VENDORID, OLICOM_DEVICEID_OC2326,
		"Olicom OC-2326 10/100 TX UTP" },
	{ 0, 0, NULL }
};

/*
 * Various supported PHY vendors/types and their names. Note that
 * this driver will work with pretty much any MII-compliant PHY,
 * so failure to positively identify the chip is not a fatal error.
 */

static struct tl_type tl_phys[] = {
	{ TI_PHY_VENDORID, TI_PHY_10BT, "<TI ThunderLAN 10BT (internal)>" },
	{ TI_PHY_VENDORID, TI_PHY_100VGPMI, "<TI TNETE211 100VG Any-LAN>" },
	{ NS_PHY_VENDORID, NS_PHY_83840A, "<National Semiconductor DP83840A>"},
	{ LEVEL1_PHY_VENDORID, LEVEL1_PHY_LXT970, "<Level 1 LXT970>" }, 
	{ INTEL_PHY_VENDORID, INTEL_PHY_82555, "<Intel 82555>" },
	{ SEEQ_PHY_VENDORID, SEEQ_PHY_80220, "<SEEQ 80220>" },
	{ 0, 0, "<MII-compliant physical interface>" }
};
#endif
d241 1
a241 20
#ifdef __FreeBSD__
static unsigned long		tl_count;

static const char *tl_probe	__P((pcici_t, pcidi_t));
static void tl_attach		__P((pcici_t, int));
#else
static int tl_probe	__P((struct device *, void *, void *));
static void tl_attach	__P((struct device *, struct device *, void *));
static void tl_wait_up	__P((void *));
#endif

static int tl_attach_phy	__P((struct tl_softc *));
static int tl_intvec_rxeoc	__P((void *, u_int32_t));
static int tl_intvec_txeoc	__P((void *, u_int32_t));
static int tl_intvec_txeof	__P((void *, u_int32_t));
static int tl_intvec_rxeof	__P((void *, u_int32_t));
static int tl_intvec_adchk	__P((void *, u_int32_t));
static int tl_intvec_netsts	__P((void *, u_int32_t));

static int tl_newbuf		__P((struct tl_softc *,
d243 2
a244 2
static void tl_stats_update	__P((void *));
static int tl_encap		__P((struct tl_softc *, struct tl_chain *,
d247 9
a255 17
#if defined(__FreeBSD__)
static void tl_intr		__P((void *));
#else
static int tl_intr		__P((void *));
#endif
static void tl_start		__P((struct ifnet *));
static int tl_ioctl		__P((struct ifnet *, u_long, caddr_t));
static void tl_init		__P((void *));
static void tl_stop		__P((struct tl_softc *));
static void tl_watchdog		__P((struct ifnet *));
#ifdef __FreeBSD__
static void tl_shutdown		__P((int, void *));
#else
static void tl_shutdown		__P((void *));
#endif
static int tl_ifmedia_upd	__P((struct ifnet *));
static void tl_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));
d257 2
a258 2
static u_int8_t tl_eeprom_putbyte	__P((struct tl_softc *, int));
static u_int8_t	tl_eeprom_getbyte	__P((struct tl_softc *,
d260 1
a260 1
static int tl_read_eeprom	__P((struct tl_softc *, caddr_t, int, int));
d262 27
a288 27
static void tl_mii_sync		__P((struct tl_softc *));
static void tl_mii_send		__P((struct tl_softc *, u_int32_t, int));
static int tl_mii_readreg	__P((struct tl_softc *, struct tl_mii_frame *));
static int tl_mii_writereg	__P((struct tl_softc *, struct tl_mii_frame *));
static u_int16_t tl_phy_readreg	__P((struct tl_softc *, int));
static void tl_phy_writereg	__P((struct tl_softc *, int, int));

static void tl_autoneg		__P((struct tl_softc *, int, int));
static void tl_setmode		__P((struct tl_softc *, int));
static int tl_calchash		__P((caddr_t));
static void tl_setmulti		__P((struct tl_softc *));
static void tl_setfilt		__P((struct tl_softc *, caddr_t, int));
static void tl_softreset	__P((struct tl_softc *, int));
static void tl_hardreset	__P((struct tl_softc *));
static int tl_list_rx_init	__P((struct tl_softc *));
static int tl_list_tx_init	__P((struct tl_softc *));

static u_int8_t tl_dio_read8	__P((struct tl_softc *, int));
static u_int16_t tl_dio_read16	__P((struct tl_softc *, int));
static u_int32_t tl_dio_read32	__P((struct tl_softc *, int));
static void tl_dio_write8	__P((struct tl_softc *, int, int));
static void tl_dio_write16	__P((struct tl_softc *, int, int));
static void tl_dio_write32	__P((struct tl_softc *, int, int));
static void tl_dio_setbit	__P((struct tl_softc *, int, int));
static void tl_dio_clrbit	__P((struct tl_softc *, int, int));
static void tl_dio_setbit16	__P((struct tl_softc *, int, int));
static void tl_dio_clrbit16	__P((struct tl_softc *, int, int));
d290 1
a290 1
static u_int8_t tl_dio_read8(sc, reg)
d298 1
a298 1
static u_int16_t tl_dio_read16(sc, reg)
d306 1
a306 1
static u_int32_t tl_dio_read32(sc, reg)
d314 1
a314 1
static void tl_dio_write8(sc, reg, val)
d324 1
a324 1
static void tl_dio_write16(sc, reg, val)
d334 1
a334 1
static void tl_dio_write32(sc, reg, val)
d344 1
a344 1
static void tl_dio_setbit(sc, reg, bit)
d359 1
a359 1
static void tl_dio_clrbit(sc, reg, bit)
d374 1
a374 1
static void tl_dio_setbit16(sc, reg, bit)
d389 1
a389 1
static void tl_dio_clrbit16(sc, reg, bit)
d407 1
a407 1
static u_int8_t tl_eeprom_putbyte(sc, byte)
d451 1
a451 1
static u_int8_t tl_eeprom_getbyte(sc, addr, dest)
d519 1
a519 1
static int tl_read_eeprom(sc, dest, off, cnt)
d538 1
a538 1
static void tl_mii_sync(sc)
d553 1
a553 1
static void tl_mii_send(sc, bits, cnt)
d571 1
a571 1
static int tl_mii_readreg(sc, frame)
d666 1
a666 1
static int tl_mii_writereg(sc, frame)
d722 1
a722 1
static u_int16_t tl_phy_readreg(sc, reg)
d740 1
a740 1
static void tl_phy_writereg(sc, reg, data)
d808 1
a808 1
static void tl_autoneg(sc, flag, verbose)
a847 3
#ifdef TL_DEBUG
		evset(sc, EV_AUTONEG_XMIT);
#endif
a867 3
#ifdef TL_DEBUG
		evset(sc, EV_AUTONEG_FIN);
#endif
d969 1
a969 1
static void tl_setmode(sc, media)
d975 16
d1069 1
a1069 1
static int tl_calchash(addr)
d1086 1
a1086 1
static void tl_setfilt(sc, addr, slot)
d1118 1
a1118 1
static void tl_setmulti(sc)
a1123 3
#ifdef __FreeBSD__
	struct ifmultiaddr	*ifma;
#else
a1126 1
#endif
a1140 33
#ifdef __FreeBSD__
		i = 1;
		/* First find the tail of the list. */
		for (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;
					ifma = ifma->ifma_link.le_next) {
			if (ifma->ifma_link.le_next == NULL)
				break;
		}
		/* Now traverse the list backwards. */
		for (; ifma != NULL && ifma != (void *)&ifp->if_multiaddrs;
			ifma = (struct ifmultiaddr *)ifma->ifma_link.le_prev) {
			if (ifma->ifma_addr->sa_family != AF_LINK)
				continue;
			/*
			 * Program the first three multicast groups
			 * into the perfect filter. For all others,
			 * use the hash table.
			 */
			if (i < 4) {
				tl_setfilt(sc,
			LLADDR((struct sockaddr_dl *)ifma->ifma_addr), i);
				i++;
				continue;
			}

			h = tl_calchash(
				LLADDR((struct sockaddr_dl *)ifma->ifma_addr));
			if (h < 32)
				hashes[0] |= (1 << h);
			else
				hashes[1] |= (1 << (h - 32));
		}
#else
a1157 1
#endif
d1172 1
a1172 1
static void tl_hardreset(sc)
d1208 1
a1208 1
static void tl_softreset(sc, internal)
d1232 1
a1232 1
	if (internal) {
d1238 4
a1277 25
#ifdef __FreeBSD__
/*
 * Probe for a ThunderLAN chip. Check the PCI vendor and device IDs
 * against our list and return its name if we find a match.
 */
static const char *
tl_probe(config_id, device_id)
	pcici_t			config_id;
	pcidi_t			device_id;
{
	struct tl_type		*t;

	t = tl_devs;

	while(t->tl_name != NULL) {
		if ((device_id & 0xFFFF) == t->tl_vid &&
		    ((device_id >> 16) & 0xFFFF) == t->tl_did)
			return(t->tl_name);
		t++;
	}

	return(NULL);
}
#endif

d1282 1
a1282 1
static int tl_attach_phy(sc)
d1298 1
a1298 1
		sc->tl_phy_sts & PHY_BMSR_100BTXHALF)
a1379 255
#ifdef __FreeBSD__
static void
tl_attach(config_id, unit)
	pcici_t			config_id;
	int			unit;
{
	int			s, i, phys = 0;
#ifndef TL_USEIOSPACE
	vm_offset_t		pbase, vbase;
#endif
	u_int32_t		command;
	u_int16_t		did, vid;
	struct tl_type		*t;
	struct ifnet		*ifp;
	struct tl_softc		*sc;
	unsigned int		round;
	caddr_t			roundptr;

	s = splimp();

	vid = pci_cfgread(config_id, PCIR_VENDOR, 2);
	did = pci_cfgread(config_id, PCIR_DEVICE, 2);

	t = tl_devs;
	while(t->tl_name != NULL) {
		if (vid == t->tl_vid && did == t->tl_did)
			break;
		t++;
	}

	if (t->tl_name == NULL) {
		printf("tl%d: unknown device!?\n", unit);
		goto fail;
	}

	/* First, allocate memory for the softc struct. */
	sc = malloc(sizeof(struct tl_softc), M_DEVBUF, M_NOWAIT);
	if (sc == NULL) {
		printf("tl%d: no memory for softc struct!\n", unit);
		goto fail;
	}

	bzero(sc, sizeof(struct tl_softc));

	/*
	 * Map control/status registers.
	 */
	command = pci_conf_read(config_id, PCI_COMMAND_STATUS_REG);
	command |= (PCIM_CMD_PORTEN|PCIM_CMD_MEMEN|PCIM_CMD_BUSMASTEREN);
	pci_conf_write(config_id, PCI_COMMAND_STATUS_REG, command);
	command = pci_conf_read(config_id, PCI_COMMAND_STATUS_REG);

#ifdef TL_USEIOSPACE
	if (!(command & PCIM_CMD_PORTEN)) {
		printf("tl%d: failed to enable I/O ports!\n", unit);
		free(sc, M_DEVBUF);
		goto fail;
	}

	sc->iobase = pci_conf_read(config_id, TL_PCI_LOIO) & 0xFFFFFFFC;
#else
	if (!(command & PCIM_CMD_MEMEN)) {
		printf("tl%d: failed to enable memory mapping!\n", unit);
		goto fail;
	}

	if (!pci_map_mem(config_id, TL_PCI_LOMEM, &vbase, &pbase)) {
		printf ("tl%d: couldn't map memory\n", unit);
		goto fail;
	}

	sc->csr = (volatile caddr_t)vbase;
#endif

#ifdef notdef
	/*
	 * The ThunderLAN manual suggests jacking the PCI latency
	 * timer all the way up to its maximum value. I'm not sure
	 * if this is really necessary, but what the manual wants,
	 * the manual gets.
	 */
	command = pci_conf_read(config_id, TL_PCI_LATENCY_TIMER);
	command |= 0x0000FF00;
	pci_conf_write(config_id, TL_PCI_LATENCY_TIMER, command);
#endif

	/* Allocate interrupt */
	if (!pci_map_int(config_id, tl_intr, sc, &net_imask)) {
		printf("tl%d: couldn't map interrupt\n", unit);
		goto fail;
	}

	/*
	 * Now allocate memory for the TX and RX lists. Note that
	 * we actually allocate 8 bytes more than we really need:
	 * this is because we need to adjust the final address to
	 * be aligned on a quadword (64-bit) boundary in order to
	 * make the chip happy. If the list structures aren't properly
	 * aligned, DMA fails and the chip generates an adapter check
	 * interrupt and has to be reset. If you set up the softc struct
	 * just right you can sort of obtain proper alignment 'by chance.'
	 * But I don't want to depend on this, so instead the alignment
	 * is forced here.
	 */
	sc->tl_ldata_ptr = malloc(sizeof(struct tl_list_data) + 8,
				M_DEVBUF, M_NOWAIT);

	if (sc->tl_ldata_ptr == NULL) {
		free(sc, M_DEVBUF);
		printf("tl%d: no memory for list buffers!\n", unit);
		goto fail;
	}

	/*
	 * Convoluted but satisfies my ANSI sensibilities. GCC lets
	 * you do casts on the LHS of an assignment, but ANSI doesn't
	 * allow that.
	 */
	sc->tl_ldata = (struct tl_list_data *)sc->tl_ldata_ptr;
	round = (unsigned int)sc->tl_ldata_ptr & 0xF;
	roundptr = sc->tl_ldata_ptr;
	for (i = 0; i < 8; i++) {
		if (round % 8) {
			round++;
			roundptr++;
		} else
			break;
	}
	sc->tl_ldata = (struct tl_list_data *)roundptr;

	bzero(sc->tl_ldata, sizeof(struct tl_list_data));

	sc->tl_unit = unit;
	sc->tl_dinfo = t;
	if (t->tl_vid == COMPAQ_VENDORID || t->tl_vid == TI_VENDORID)
		sc->tl_eeaddr = TL_EEPROM_EADDR;
	if (t->tl_vid == OLICOM_VENDORID)
		sc->tl_eeaddr = TL_EEPROM_EADDR_OC;

	/* Reset the adapter. */
	tl_softreset(sc, 1);
	tl_hardreset(sc);
	tl_softreset(sc, 1);

	/*
	 * Get station address from the EEPROM.
	 */
	if (tl_read_eeprom(sc, (caddr_t)&sc->arpcom.ac_enaddr,
				sc->tl_eeaddr, ETHER_ADDR_LEN)) {
		printf("tl%d: failed to read station address\n", unit);
		goto fail;
	}

        /*
         * XXX Olicom, in its desire to be different from the
         * rest of the world, has done strange things with the
         * encoding of the station address in the EEPROM. First
         * of all, they store the address at offset 0xF8 rather
         * than at 0x83 like the ThunderLAN manual suggests.
         * Second, they store the address in three 16-bit words in
         * network byte order, as opposed to storing it sequentially
         * like all the other ThunderLAN cards. In order to get
         * the station address in a form that matches what the Olicom
         * diagnostic utility specifies, we have to byte-swap each
         * word. To make things even more confusing, neither 00:00:28
         * nor 00:00:24 appear in the IEEE OUI database.
         */
        if (sc->tl_dinfo->tl_vid == OLICOM_VENDORID) {
                for (i = 0; i < ETHER_ADDR_LEN; i += 2) {
                        u_int16_t               *p;
                        p = (u_int16_t *)&sc->arpcom.ac_enaddr[i];
                        *p = ntohs(*p);
                }
        }

	/*
	 * A ThunderLAN chip was detected. Inform the world.
	 */
	printf("tl%d: Ethernet address: %6D\n", unit,
				sc->arpcom.ac_enaddr, ":");

	ifp = &sc->arpcom.ac_if;
	ifp->if_softc = sc;
	ifp->if_unit = sc->tl_unit;
	ifp->if_name = "tl";
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = tl_ioctl;
	ifp->if_output = ether_output;
	ifp->if_start = tl_start;
	ifp->if_watchdog = tl_watchdog;
	ifp->if_init = tl_init;
	ifp->if_mtu = ETHERMTU;
	ifp->if_snd.ifq_maxlen = TL_TX_LIST_CNT - 1;
	callout_handle_init(&sc->tl_stat_ch);

	/* Reset the adapter again. */
	tl_softreset(sc, 1);
	tl_hardreset(sc);
	tl_softreset(sc, 1);

	/*
	 * Now attach the ThunderLAN's PHYs. There will always
	 * be at least one PHY; if the PHY address is 0x1F, then
	 * it's the internal one.
	 */

	for (i = TL_PHYADDR_MIN; i < TL_PHYADDR_MAX + 1; i++) {
		sc->tl_phy_addr = i;
		tl_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);
		DELAY(500);
		while(tl_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_RESET);
		sc->tl_phy_sts = tl_phy_readreg(sc, PHY_BMSR);
		if (!sc->tl_phy_sts)
			continue;
		if (tl_attach_phy(sc)) {
			printf("tl%d: failed to attach a phy %d\n", unit, i);
			goto fail;
		}
		phys++;
		if (phys && i != TL_PHYADDR_MAX)
			break;
	}

	if (!phys) {
		printf("tl%d: no physical interfaces attached!\n", unit);
		goto fail;
	}

	tl_intvec_adchk((void *)sc, 0);
	tl_stop(sc);

	/*
	 * Attempt to clear any stray interrupts
	 * that may be lurking.
	 */
	tl_intr((void *)sc);

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

#if NBPFILTER > 0
	bpfattach(ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif

	at_shutdown(tl_shutdown, sc, SHUTDOWN_POST_SYNC);

fail:
	splx(s);
	return;
}
#endif

d1383 1
a1383 1
static int tl_list_tx_init(sc)
d1410 1
a1410 1
static int tl_list_rx_init(sc)
d1441 1
a1441 1
static int tl_newbuf(sc, c)
a1448 4
#if defined(__FreeBSD__)
		printf("tl%d: no memory for rx list -- packet dropped!",
				sc->tl_unit);
#endif
a1453 4
#if defined(__FreeBSD__)
		printf("tl%d: no memory for rx list -- packet dropped!",
				 sc->tl_unit);
#endif
d1458 4
d1495 1
a1495 1
static int tl_intvec_rxeof(xsc, type)
a1508 4
#ifdef TL_DEBUG
	evset(sc, EV_RXEOF);
#endif

a1555 3
#ifdef __FreeBSD__
			bpf_mtap(ifp, m);
#else
a1556 1
#endif
d1583 1
a1583 1
static int tl_intvec_rxeoc(xsc, type)
a1591 4
#ifdef TL_DEBUG
	evset(sc, EV_RXEOC);
#endif

d1601 1
a1601 1
static int tl_intvec_txeof(xsc, type)
a1610 4
#ifdef TL_DEBUG
	evset(sc, EV_TXEOF);
#endif

d1653 1
a1653 1
static int tl_intvec_txeoc(xsc, type)
a1666 4
#ifdef TL_DEBUG
	evset(sc, EV_TXEOC);
#endif

d1699 1
a1699 1
static int tl_intvec_adchk(xsc, type)
a1710 3
#ifdef TL_DEBUG
	evshow(sc);
#endif
d1718 11
a1728 9
	bmcr = tl_phy_readreg(sc, PHY_BMCR);
	ctl = tl_phy_readreg(sc, TL_PHY_CTL);
	tl_softreset(sc, 1);
	tl_phy_writereg(sc, PHY_BMCR, bmcr);
	tl_phy_writereg(sc, TL_PHY_CTL, ctl);
	if (bmcr & PHY_BMCR_DUPLEX) {
		tl_dio_setbit(sc, TL_NETCMD, TL_CMD_DUPLEX);
	} else {
		tl_dio_clrbit(sc, TL_NETCMD, TL_CMD_DUPLEX);
d1737 1
a1737 1
static int tl_intvec_netsts(xsc, type)
d1754 1
a1754 5
#ifdef __FreeBSD__
static void tl_intr(xsc)
#else
static int tl_intr(xsc)
#endif
a1823 3
#if defined(__FreeBSD__)
	return;
#else
a1824 1
#endif
d1827 1
a1827 1
static void tl_stats_update(xsc)
a1856 3
#ifdef __FreeBSD__
	sc->tl_stat_ch = timeout(tl_stats_update, sc, hz);
#else
a1857 1
#endif
d1866 1
a1866 1
static int tl_encap(sc, c, m_head)
a1909 3
#if defined(__FreeBSD__)
			printf("tl%d: no memory for tx list", sc->tl_unit);
#endif
a1915 4
#if defined(__FreeBSD__)
				printf("tl%d: no memory for tx list",
				sc->tl_unit);
#endif
a1934 5
#if defined(__FreeBSD__)
		if (frag == TL_MAXFRAGS)
			printf("tl%d: all frags filled but "
				"frame still to small!\n", sc->tl_unit);
#endif
d1957 1
a1957 1
static void tl_start(ifp)
a2009 3
#ifdef __FreeBSD__
			bpf_mtap(ifp, cur_tx->tl_mbuf);
#else
a2011 1
#endif
a2029 3
#ifdef TL_DEBUG
		evset(sc, EV_START_TX);
#endif
a2031 3
#ifdef TL_DEBUG
			evset(sc, EV_START_TX_REAL);
#endif
a2039 3
#ifdef TL_DEBUG
		evset(sc, EV_START_Q);
#endif
d2052 1
a2052 1
static void tl_init(xsc)
a2066 4
#ifdef TL_DEBUG
	evset(sc, EV_INIT);
#endif

a2148 5
#ifdef __FreeBSD__
	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;
#endif

a2151 3
#ifdef __FreeBSD__
	sc->tl_stat_ch = timeout(tl_stats_update, sc, hz);
#else
a2153 1
#endif
d2161 1
a2161 1
static int tl_ifmedia_upd(ifp)
d2184 1
a2184 1
static void tl_ifmedia_sts(ifp, ifmr)
d2195 11
d2232 1
a2232 1
static int tl_ioctl(ifp, command, data)
a2238 1
#ifdef __OpenBSD__
a2239 1
#endif
a2243 1
#ifdef __OpenBSD__
a2247 1
#endif
a2249 7
#ifdef __FreeBSD__
	case SIOCSIFADDR:
	case SIOCGIFADDR:
	case SIOCSIFMTU:
		error = ether_ioctl(ifp, command, data);
		break;
#else
a2262 1
#endif
d2292 1
a2292 1
static void tl_watchdog(ifp)
a2299 4
#ifdef TL_DEBUG
	evset(sc, EV_WATCHDOG);
#endif

a2315 4
#ifdef TL_DEBUG
	evshow(sc);
#endif

d2325 1
a2325 1
static void tl_stop(sc)
a2333 3
#ifdef __FreeBSD__
	untimeout(tl_stats_update, sc, sc->tl_stat_ch);
#else
a2335 1
#endif
d2391 1
a2391 31
#ifdef __FreeBSD__
/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
static void tl_shutdown(howto, xsc)
	int			howto;
	void			*xsc;
{
	struct tl_softc		*sc;

	sc = xsc;

	tl_stop(sc);

	return;
}


static struct pci_device tl_device = {
	"tl",
	tl_probe,
	tl_attach,
	&tl_count,
	NULL
};
DATA_SET(pcidevice_set, tl_device);
#endif

#ifdef __OpenBSD__
static int
d2435 1
a2435 1
static void
d2464 5
a2468 2
		printf(": failed to find i/o space\n");
		return;
d2470 1
a2470 1
	if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->sc_sh)) {
d2474 1
a2474 1
	sc->sc_st = pa->pa_iot;
d2481 5
a2485 2
		printf(": failed to find memory space\n");
		return;
d2487 1
a2487 1
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->sc_sh)) {
d2491 1
a2491 1
	sc->sc_st = pa->pa_memt;
d2531 6
a2536 1
	round = (unsigned int)sc->tl_ldata_ptr & 0xF;
d2592 1
a2592 1
	ifp->if_snd.ifq_maxlen = TL_TX_LIST_CNT - 1;
d2621 13
a2633 3
		printf("%s: no physical interfaces found\n",
		    sc->sc_dev.dv_xname);
		return;
d2670 1
a2670 1
static void
a2685 1
#endif
@


1.8
log
@Sync with FreeBSD:
o make sure ifp->if_snd.ifq_maxlen is initialized
o proper handling of boards which report the TI product id
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.7 1998/12/31 02:40:21 jason Exp $	*/
a227 2

#define bootverbose 0
a331 1
#endif
d348 1
a1470 1
	struct tl_type		*p = tl_phys;
a1480 16
	/*
	 * PHY revision numbers tend to vary a bit. Our algorithm here
	 * is to check everything but the 8 least significant bits.
	 */
	while(p->tl_vid) {
		if (sc->tl_phy_vid  == p->tl_vid &&
			(sc->tl_phy_did | 0x000F) == p->tl_did) {
			sc->tl_pinfo = p;
			break;
		}
		p++;
	}
	if (sc->tl_pinfo == NULL) {
		sc->tl_pinfo = &tl_phys[PHY_UNKNOWN];
	}

a1487 7
	if (bootverbose) {
		printf("tl%d: phy at mii address %d\n", sc->tl_unit,
							sc->tl_phy_addr);

		printf("tl%d: %s ", sc->tl_unit, sc->tl_pinfo->tl_name);
	}

a1490 2
		if (bootverbose)
			printf("10/100Mbps ");
a1493 2
		if (bootverbose)
			printf("10Mbps ");
a1497 2
		if (bootverbose)
			printf("full duplex ");
a1498 2
		if (bootverbose)
			printf("half duplex ");
d1504 1
a1504 10
		if (bootverbose)
			printf("autonegotiating\n");
	} else
		if (bootverbose)
			printf("\n");

	/* If this isn't a known PHY, print the PHY indentifier info. */
	if (sc->tl_pinfo->tl_vid == 0 && bootverbose)
		printf("tl%d: vendor id: %04x product id: %04x\n",
			sc->tl_unit, sc->tl_phy_vid, sc->tl_phy_did);
a1772 2
		if (bootverbose)
			printf("tl%d: looking for phy at addr %x\n", unit, i);
a1776 2
		if (bootverbose)
			printf("tl%d: status: %x\n", unit, sc->tl_phy_sts);
a3151 3
		if (bootverbose)
			printf("%s: looking for phy at addr %x\n",
			    sc->sc_dev.dv_xname, i);
a3155 3
		if (bootverbose)
			printf("%s: status: %x\n", sc->sc_dev.dv_xname,
			    sc->tl_phy_sts);
@


1.7
log
@tl_tx_tail pointer was not always being updated correctly; freebsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.6 1998/12/22 05:33:52 jason Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_tl.c,v 1.24 1998/12/29 15:39:35 wpaul Exp $
d251 1
a251 1
	"$FreeBSD: if_tl.c,v 1.24 1998/12/29 15:39:35 wpaul Exp $";
d1742 1
a1742 1
	if (t->tl_vid == COMPAQ_VENDORID)
d1800 1
d3142 2
a3143 1
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_COMPAQ)
d3186 1
@


1.6
log
@sync with FreeBSD:
o sanity checking on foo_start() routines
o ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.5 1998/12/03 04:16:58 jason Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_tl.c,v 1.23 1998/12/14 06:32:56 dillon Exp $
d251 1
a251 1
	"$FreeBSD: if_tl.c,v 1.23 1998/12/14 06:32:56 dillon Exp $";
d2589 1
a2589 1
		sc->tl_cdata.tl_tx_tail = start_tx;
@


1.5
log
@o Don't match pci product 0xae33, as it's a pciide controller; reported by mickey@@ (pr 652).
o use switch for matching pci products
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.4 1998/11/23 21:55:56 jason Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_tl.c,v 1.19 1998/10/31 17:23:48 wpaul Exp $
d251 1
a251 1
	"$FreeBSD: if_tl.c,v 1.19 1998/10/31 17:23:48 wpaul Exp $";
d355 1
a355 1
static char *tl_probe		__P((pcici_t, pcidi_t));
d395 1
a395 1
static u_int8_t tl_eeprom_putbyte	__P((struct tl_softc *, u_int8_t));
d397 1
a397 1
						u_int8_t, u_int8_t *));
d405 1
a405 1
static void tl_phy_writereg	__P((struct tl_softc *, u_int16_t, u_int16_t));
d409 1
a409 1
static int tl_calchash		__P((unsigned char *));
d411 1
a411 1
static void tl_setfilt		__P((struct tl_softc *, u_int8_t *, int));
d417 10
a426 10
static u_int8_t tl_dio_read8	__P((struct tl_softc *, u_int8_t));
static u_int16_t tl_dio_read16	__P((struct tl_softc *, u_int8_t));
static u_int32_t tl_dio_read32	__P((struct tl_softc *, u_int8_t));
static void tl_dio_write8	__P((struct tl_softc *, u_int8_t, u_int8_t));
static void tl_dio_write16	__P((struct tl_softc *, u_int8_t, u_int16_t));
static void tl_dio_write32	__P((struct tl_softc *, u_int8_t, u_int32_t));
static void tl_dio_setbit	__P((struct tl_softc *, u_int8_t, u_int8_t));
static void tl_dio_clrbit	__P((struct tl_softc *, u_int8_t, u_int8_t));
static void tl_dio_setbit16	__P((struct tl_softc *, u_int8_t, u_int16_t));
static void tl_dio_clrbit16	__P((struct tl_softc *, u_int8_t, u_int16_t));
d429 2
a430 2
	struct tl_softc			*sc;
	u_int8_t			reg;
d437 2
a438 2
	struct tl_softc			*sc;
	u_int8_t			reg;
d445 2
a446 2
	struct tl_softc			*sc;
	u_int8_t			reg;
d453 3
a455 3
	struct tl_softc			*sc;
	u_int8_t			reg;
	u_int8_t			val;
d463 3
a465 3
	struct tl_softc			*sc;
	u_int8_t			reg;
	u_int16_t			val;
d473 3
a475 3
	struct tl_softc			*sc;
	u_int8_t			reg;
	u_int32_t			val;
d483 3
a485 3
	struct tl_softc			*sc;
	u_int8_t			reg;
	u_int8_t			bit;
d498 3
a500 3
	struct tl_softc			*sc;
	u_int8_t			reg;
	u_int8_t			bit;
d513 3
a515 3
	struct tl_softc			*sc;
	u_int8_t			reg;
	u_int16_t			bit;
d528 3
a530 3
	struct tl_softc			*sc;
	u_int8_t			reg;
	u_int16_t			bit;
d547 1
a547 1
	u_int8_t		byte;
d591 1
a591 1
	u_int8_t		addr;
d880 2
a881 2
	u_int16_t		reg;
	u_int16_t		data;
d1198 1
a1198 1
	unsigned char		*addr;
d1216 1
a1216 1
	u_int8_t		*addr;
d1264 1
a1264 1
		tl_setfilt(sc, dummy, i);
d1445 1
a1445 1
static char *
d2220 1
a2220 1
			CSR_READ_4(sc, TL_CH_PARM));
d2554 6
d2641 1
a2641 1
	tl_setfilt(sc, sc->arpcom.ac_enaddr, 0);
@


1.4
log
@make quieter on out of memory conditions
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.3 1998/11/16 18:33:32 jason Exp $	*/
d3004 11
a3014 21
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_COMPAQ_N100TX)
			return 1;
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_COMPAQ_Nunknown)
			return 1;
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_COMPAQ_N10T)
			return 1;
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_COMPAQ_IntNF3P)
			return 1;
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_COMPAQ_DPNet100TX)
			return 1;
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_COMPAQ_IntPL100TX)
			return 1;
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_COMPAQ_DP4000)
			return 1;
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_COMPAQ_N10T2)
			return 1;
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_COMPAQ_N10_TX_UTP)
			return 1;
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_COMPAQ_NF3P)
			return 1;
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_COMPAQ_NF3P_BNC)
d3016 1
d3021 4
a3024 5
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_OLICOM_OC2183)
			return 1;
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_OLICOM_OC2325)
			return 1;
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_OLICOM_OC2326)
d3026 1
@


1.3
log
@Take advantage of generic pci io/mem/busmaster enabling and remove redundant code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.2 1998/11/11 05:24:13 jason Exp $	*/
d1935 1
d1938 1
d1944 1
d1947 1
d2433 1
d2435 1
d2442 1
d2445 1
d2465 1
d2469 1
@


1.2
log
@Merge with FreeBSD:
o size of tx & rx rings increased
o rx ring init was using the tx ring size constant
@
text
@d1 1
a1 1
/*	$OpenBSD: if_tl.c,v 1.1 1998/10/10 03:55:05 jason Exp $	*/
a3052 5
	command = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_IO_ENABLE |
		   PCI_COMMAND_MEM_ENABLE |
		   PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);
@


1.1
log
@Driver for ThunderLAN based ethernet cards ported from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
 *	$FreeBSD: if_tl.c,v 1.18 1998/10/08 15:45:36 wpaul Exp $
d251 1
a251 1
	"$FreeBSD: if_tl.c,v 1.18 1998/10/08 15:45:36 wpaul Exp $";
d1906 1
a1906 1
	for (i = 0; i < TL_TX_LIST_CNT; i++) {
d1911 1
a1911 1
		if (i == (TL_TX_LIST_CNT - 1)) {
@

