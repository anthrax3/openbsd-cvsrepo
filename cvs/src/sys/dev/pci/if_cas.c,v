head	1.51;
access;
symbols
	OPENBSD_6_2:1.51.0.6
	OPENBSD_6_2_BASE:1.51
	OPENBSD_6_1:1.51.0.4
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.50.0.4
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.41.0.4
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.37.0.4
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.33.0.6
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.33.0.4
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.32.0.10
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.8
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.6
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.26.0.4
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4;
locks; strict;
comment	@ * @;


1.51
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.50;
commitid	VyLWTsbepAOk7VQM;

1.50
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.49;
commitid	8YSL8ByWzGeIGBiJ;

1.49
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.48;
commitid	J9apD0jq2AjFmqZc;

1.48
date	2015.12.06.11.32.54;	author jsg;	state Exp;
branches;
next	1.47;
commitid	xWNtxPzbqNhoXV3P;

1.47
date	2015.12.03.09.51.52;	author jmatthew;	state Exp;
branches;
next	1.46;
commitid	MYYMbKu5zmRItscF;

1.46
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.45;
commitid	B0kwmVGiD5DVx4kv;

1.45
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.44;
commitid	5gdEnqVoJuTuwdTu;

1.44
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.43;
commitid	eYnPulzvLjDImPCa;

1.43
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.42;
commitid	hPF95ClMUQfeqQDX;

1.42
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.41;
commitid	6vhYvh5CxZAHMnsN;

1.41
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.40;
commitid	MVWrtktB46JRxFWT;

1.40
date	2015.04.13.08.45.48;	author mpi;	state Exp;
branches;
next	1.39;
commitid	aiRvgNOa4qke9vft;

1.39
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.38;
commitid	p4LJxGKbi0BU2cG6;

1.38
date	2015.03.11.22.15.22;	author mpi;	state Exp;
branches;
next	1.37;
commitid	3txW9QLSBQatFzAQ;

1.37
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.36;
commitid	yM2VFFhpDTeFQlve;

1.36
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.35;
commitid	LS2TNeCue5R9L67C;

1.35
date	2014.11.18.01.56.32;	author brad;	state Exp;
branches;
next	1.34;
commitid	fy0SvvQwIJ8m8DiS;

1.34
date	2014.11.16.05.46.20;	author brad;	state Exp;
branches;
next	1.33;
commitid	KQukcxYpXaPp9yBZ;

1.33
date	2013.08.21.05.21.44;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.31;

1.31
date	2010.09.20.07.40.38;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.29.16.19.38;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.17.20.47.42;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2009.07.23.19.35.32;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2009.06.13.12.18.57;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.24;

1.24
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2008.10.14.18.01.53;	author naddy;	state Exp;
branches;
next	1.22;

1.22
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.20;

1.20
date	2008.08.30.07.39.12;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.31.22.49.03;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.31.17.03.52;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2008.05.31.02.44.11;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2008.04.08.23.41.56;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2008.04.02.22.26.16;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2008.02.08.10.56.41;	author thib;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.17.21.27.02;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.26.17.15.32;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.26.15.55.59;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.26.15.36.22;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.06.14.50.22;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2007.04.18.21.08.35;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2007.04.15.19.57.16;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2007.04.15.16.31.30;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2007.04.11.21.39.14;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.27.21.19.40;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.26.21.48.32;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.25.21.54.52;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2007.02.24.20.13.34;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.51
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_cas.c,v 1.50 2016/04/13 10:34:32 mpi Exp $	*/

/*
 *
 * Copyright (C) 2007 Mark Kettenis.
 * Copyright (C) 2001 Eduardo Horvath.
 * All rights reserved.
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR  ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR  BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * Driver for Sun Cassini ethernet controllers.
 *
 * There are basically two variants of this chip: Cassini and
 * Cassini+.  We can distinguish between the two by revision: 0x10 and
 * up are Cassini+.  The most important difference is that Cassini+
 * has a second RX descriptor ring.  Cassini+ will not work without
 * configuring that second ring.  However, since we don't use it we
 * don't actually fill the descriptors, and only hand off the first
 * four to the chip.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/mbuf.h>
#include <sys/syslog.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/endian.h>
#include <sys/atomic.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <dev/pci/if_casreg.h>
#include <dev/pci/if_casvar.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#ifdef __sparc64__
#include <dev/ofw/openfirm.h>
#endif

#define TRIES	10000

struct cfdriver cas_cd = {
	NULL, "cas", DV_IFNET
};

int	cas_match(struct device *, void *, void *);
void	cas_attach(struct device *, struct device *, void *);
int	cas_pci_enaddr(struct cas_softc *, struct pci_attach_args *);

struct cfattach cas_ca = {
	sizeof(struct cas_softc), cas_match, cas_attach
};

void		cas_config(struct cas_softc *);
void		cas_start(struct ifnet *);
void		cas_stop(struct ifnet *, int);
int		cas_ioctl(struct ifnet *, u_long, caddr_t);
void		cas_tick(void *);
void		cas_watchdog(struct ifnet *);
int		cas_init(struct ifnet *);
void		cas_init_regs(struct cas_softc *);
int		cas_ringsize(int);
int		cas_cringsize(int);
int		cas_meminit(struct cas_softc *);
void		cas_mifinit(struct cas_softc *);
int		cas_bitwait(struct cas_softc *, bus_space_handle_t, int,
		    u_int32_t, u_int32_t);
void		cas_reset(struct cas_softc *);
int		cas_reset_rx(struct cas_softc *);
int		cas_reset_tx(struct cas_softc *);
int		cas_disable_rx(struct cas_softc *);
int		cas_disable_tx(struct cas_softc *);
void		cas_rxdrain(struct cas_softc *);
int		cas_add_rxbuf(struct cas_softc *, int idx);
void		cas_iff(struct cas_softc *);
int		cas_encap(struct cas_softc *, struct mbuf *, int *);

/* MII methods & callbacks */
int		cas_mii_readreg(struct device *, int, int);
void		cas_mii_writereg(struct device *, int, int, int);
void		cas_mii_statchg(struct device *);
int		cas_pcs_readreg(struct device *, int, int);
void		cas_pcs_writereg(struct device *, int, int, int);

int		cas_mediachange(struct ifnet *);
void		cas_mediastatus(struct ifnet *, struct ifmediareq *);

int		cas_eint(struct cas_softc *, u_int);
int		cas_rint(struct cas_softc *);
int		cas_tint(struct cas_softc *, u_int32_t);
int		cas_pint(struct cas_softc *);
int		cas_intr(void *);

#ifdef CAS_DEBUG
#define	DPRINTF(sc, x)	if ((sc)->sc_arpcom.ac_if.if_flags & IFF_DEBUG) \
				printf x
#else
#define	DPRINTF(sc, x)	/* nothing */
#endif

const struct pci_matchid cas_pci_devices[] = {
	{ PCI_VENDOR_SUN, PCI_PRODUCT_SUN_CASSINI },
	{ PCI_VENDOR_NS, PCI_PRODUCT_NS_SATURN }
};

int
cas_match(struct device *parent, void *cf, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, cas_pci_devices,
	    nitems(cas_pci_devices)));
}

#define	PROMHDR_PTR_DATA	0x18
#define	PROMDATA_PTR_VPD	0x08
#define	PROMDATA_DATA2		0x0a

static const u_int8_t cas_promhdr[] = { 0x55, 0xaa };
static const u_int8_t cas_promdat_sun[] = {
	'P', 'C', 'I', 'R',
	PCI_VENDOR_SUN & 0xff, PCI_VENDOR_SUN >> 8,
	PCI_PRODUCT_SUN_CASSINI & 0xff, PCI_PRODUCT_SUN_CASSINI >> 8
};
static const u_int8_t cas_promdat_ns[] = {
	'P', 'C', 'I', 'R',
	PCI_VENDOR_NS & 0xff, PCI_VENDOR_NS >> 8,
	PCI_PRODUCT_NS_SATURN & 0xff, PCI_PRODUCT_NS_SATURN >> 8
};

static const u_int8_t cas_promdat2[] = {
	0x18, 0x00,			/* structure length */
	0x00,				/* structure revision */
	0x00,				/* interface revision */
	PCI_SUBCLASS_NETWORK_ETHERNET,	/* subclass code */
	PCI_CLASS_NETWORK		/* class code */
};

int
cas_pci_enaddr(struct cas_softc *sc, struct pci_attach_args *pa)
{
	struct pci_vpd_largeres *res;
	struct pci_vpd *vpd;
	bus_space_handle_t romh;
	bus_space_tag_t romt;
	bus_size_t romsize = 0;
	u_int8_t buf[32], *desc;
	pcireg_t address;
	int dataoff, vpdoff, len;
	int rv = -1;

	if (pci_mapreg_map(pa, PCI_ROM_REG, PCI_MAPREG_TYPE_MEM, 0,
	    &romt, &romh, 0, &romsize, 0))
		return (-1);

	address = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_ROM_REG);
	address |= PCI_ROM_ENABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROM_REG, address);

	bus_space_read_region_1(romt, romh, 0, buf, sizeof(buf));
	if (bcmp(buf, cas_promhdr, sizeof(cas_promhdr)))
		goto fail;

	dataoff = buf[PROMHDR_PTR_DATA] | (buf[PROMHDR_PTR_DATA + 1] << 8);
	if (dataoff < 0x1c)
		goto fail;

	bus_space_read_region_1(romt, romh, dataoff, buf, sizeof(buf));
	if ((bcmp(buf, cas_promdat_sun, sizeof(cas_promdat_sun)) &&
	    bcmp(buf, cas_promdat_ns, sizeof(cas_promdat_ns))) ||
	    bcmp(buf + PROMDATA_DATA2, cas_promdat2, sizeof(cas_promdat2)))
		goto fail;

	vpdoff = buf[PROMDATA_PTR_VPD] | (buf[PROMDATA_PTR_VPD + 1] << 8);
	if (vpdoff < 0x1c)
		goto fail;

next:
	bus_space_read_region_1(romt, romh, vpdoff, buf, sizeof(buf));
	if (!PCI_VPDRES_ISLARGE(buf[0]))
		goto fail;

	res = (struct pci_vpd_largeres *)buf;
	vpdoff += sizeof(*res);

	len = ((res->vpdres_len_msb << 8) + res->vpdres_len_lsb);
	switch(PCI_VPDRES_LARGE_NAME(res->vpdres_byte0)) {
	case PCI_VPDRES_TYPE_IDENTIFIER_STRING:
		/* Skip identifier string. */
		vpdoff += len;
		goto next;

	case PCI_VPDRES_TYPE_VPD:
		while (len > 0) {
			bus_space_read_region_1(romt, romh, vpdoff,
			     buf, sizeof(buf));

			vpd = (struct pci_vpd *)buf;
			vpdoff += sizeof(*vpd) + vpd->vpd_len;
			len -= sizeof(*vpd) + vpd->vpd_len;

			/*
			 * We're looking for an "Enhanced" VPD...
			 */
			if (vpd->vpd_key0 != 'Z')
				continue;

			desc = buf + sizeof(*vpd);

			/* 
			 * ...which is an instance property...
			 */
			if (desc[0] != 'I')
				continue;
			desc += 3;

			/* 
			 * ...that's a byte array with the proper
			 * length for a MAC address...
			 */
			if (desc[0] != 'B' || desc[1] != ETHER_ADDR_LEN)
				continue;
			desc += 2;

			/*
			 * ...named "local-mac-address".
			 */
			if (strcmp(desc, "local-mac-address") != 0)
				continue;
			desc += strlen("local-mac-address") + 1;
					
			bcopy(desc, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
			sc->sc_arpcom.ac_enaddr[5] += pa->pa_device;
			rv = 0;
		}
		break;

	default:
		goto fail;
	}

 fail:
	if (romsize != 0)
		bus_space_unmap(romt, romh, romsize);

	address = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_ROM_REG);
	address &= ~PCI_ROM_ENABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROM_REG, address);

	return (rv);
}

void
cas_attach(struct device *parent, struct device *self, void *aux)
{
	struct pci_attach_args *pa = aux;
	struct cas_softc *sc = (void *)self;
	pci_intr_handle_t ih;
#ifdef __sparc64__
	/* XXX the following declarations should be elsewhere */
	extern void myetheraddr(u_char *);
#endif
	const char *intrstr = NULL;
	bus_size_t size;
	int gotenaddr = 0;

	sc->sc_rev = PCI_REVISION(pa->pa_class);
	sc->sc_dmatag = pa->pa_dmat;

#define PCI_CAS_BASEADDR	0x10
	if (pci_mapreg_map(pa, PCI_CAS_BASEADDR, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->sc_memt, &sc->sc_memh, NULL, &size, 0) != 0) {
		printf(": can't map registers\n");
		return;
	}

	if (cas_pci_enaddr(sc, pa) == 0)
		gotenaddr = 1;

#ifdef __sparc64__
	if (!gotenaddr) {
		if (OF_getprop(PCITAG_NODE(pa->pa_tag), "local-mac-address",
		    sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN) <= 0)
			myetheraddr(sc->sc_arpcom.ac_enaddr);
		gotenaddr = 1;
	}
#endif
#ifdef __powerpc__
	if (!gotenaddr) {
		pci_ether_hw_addr(pa->pa_pc, sc->sc_arpcom.ac_enaddr);
		gotenaddr = 1;
	}
#endif

	sc->sc_burst = 16;	/* XXX */

	if (pci_intr_map(pa, &ih) != 0) {
		printf(": couldn't map interrupt\n");
		bus_space_unmap(sc->sc_memt, sc->sc_memh, size);
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	sc->sc_ih = pci_intr_establish(pa->pa_pc,
	    ih, IPL_NET | IPL_MPSAFE, cas_intr, sc, self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(sc->sc_memt, sc->sc_memh, size);
		return;
	}

	printf(": %s", intrstr);

	/*
	 * call the main configure
	 */
	cas_config(sc);
}

/*
 * cas_config:
 *
 *	Attach a Cassini interface to the system.
 */
void
cas_config(struct cas_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mii_data *mii = &sc->sc_mii;
	struct mii_softc *child;
	int i, error;

	/* Make sure the chip is stopped. */
	ifp->if_softc = sc;
	cas_reset(sc);

	/*
	 * Allocate the control data structures, and create and load the
	 * DMA map for it.
	 */
	if ((error = bus_dmamem_alloc(sc->sc_dmatag,
	    sizeof(struct cas_control_data), CAS_PAGE_SIZE, 0, &sc->sc_cdseg,
	    1, &sc->sc_cdnseg, BUS_DMA_ZERO)) != 0) {
		printf("\n%s: unable to allocate control data, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_0;
	}

	/* XXX should map this in with correct endianness */
	if ((error = bus_dmamem_map(sc->sc_dmatag, &sc->sc_cdseg, sc->sc_cdnseg,
	    sizeof(struct cas_control_data), (caddr_t *)&sc->sc_control_data,
	    BUS_DMA_COHERENT)) != 0) {
		printf("\n%s: unable to map control data, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_1;
	}

	if ((error = bus_dmamap_create(sc->sc_dmatag,
	    sizeof(struct cas_control_data), 1,
	    sizeof(struct cas_control_data), 0, 0, &sc->sc_cddmamap)) != 0) {
		printf("\n%s: unable to create control data DMA map, "
		    "error = %d\n", sc->sc_dev.dv_xname, error);
		goto fail_2;
	}

	if ((error = bus_dmamap_load(sc->sc_dmatag, sc->sc_cddmamap,
	    sc->sc_control_data, sizeof(struct cas_control_data), NULL,
	    0)) != 0) {
		printf("\n%s: unable to load control data DMA map, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_3;
	}

	/*
	 * Create the receive buffer DMA maps.
	 */
	for (i = 0; i < CAS_NRXDESC; i++) {
		bus_dma_segment_t seg;
		caddr_t kva;
		int rseg;

		if ((error = bus_dmamem_alloc(sc->sc_dmatag, CAS_PAGE_SIZE,
		    CAS_PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
			printf("\n%s: unable to alloc rx DMA mem %d, "
			    "error = %d\n", sc->sc_dev.dv_xname, i, error);
			goto fail_5;
		}
		sc->sc_rxsoft[i].rxs_dmaseg = seg;

		if ((error = bus_dmamem_map(sc->sc_dmatag, &seg, rseg,
		    CAS_PAGE_SIZE, &kva, BUS_DMA_NOWAIT)) != 0) {
			printf("\n%s: unable to alloc rx DMA mem %d, "
			    "error = %d\n", sc->sc_dev.dv_xname, i, error);
			goto fail_5;
		}
		sc->sc_rxsoft[i].rxs_kva = kva;

		if ((error = bus_dmamap_create(sc->sc_dmatag, CAS_PAGE_SIZE, 1,
		    CAS_PAGE_SIZE, 0, 0, &sc->sc_rxsoft[i].rxs_dmamap)) != 0) {
			printf("\n%s: unable to create rx DMA map %d, "
			    "error = %d\n", sc->sc_dev.dv_xname, i, error);
			goto fail_5;
		}

		if ((error = bus_dmamap_load(sc->sc_dmatag,
		   sc->sc_rxsoft[i].rxs_dmamap, kva, CAS_PAGE_SIZE, NULL,
		   BUS_DMA_NOWAIT)) != 0) {
			printf("\n%s: unable to load rx DMA map %d, "
			    "error = %d\n", sc->sc_dev.dv_xname, i, error);
			goto fail_5;
		}
	}

	/*
	 * Create the transmit buffer DMA maps.
	 */
	for (i = 0; i < CAS_NTXDESC; i++) {
		if ((error = bus_dmamap_create(sc->sc_dmatag, MCLBYTES,
		    CAS_NTXSEGS, MCLBYTES, 0, BUS_DMA_NOWAIT,
		    &sc->sc_txd[i].sd_map)) != 0) {
			printf("\n%s: unable to create tx DMA map %d, "
			    "error = %d\n", sc->sc_dev.dv_xname, i, error);
			goto fail_6;
		}
		sc->sc_txd[i].sd_mbuf = NULL;
	}

	/*
	 * From this point forward, the attachment cannot fail.  A failure
	 * before this point releases all resources that may have been
	 * allocated.
	 */

	/* Announce ourselves. */
	printf(", address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));

	/* Get RX FIFO size */
	sc->sc_rxfifosize = 16 * 1024;

	/* Initialize ifnet structure. */
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, sizeof ifp->if_xname);
	ifp->if_softc = sc;
	ifp->if_flags =
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_start = cas_start;
	ifp->if_ioctl = cas_ioctl;
	ifp->if_watchdog = cas_watchdog;
	IFQ_SET_MAXLEN(&ifp->if_snd, CAS_NTXDESC - 1);

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	/* Initialize ifmedia structures and MII info */
	mii->mii_ifp = ifp;
	mii->mii_readreg = cas_mii_readreg;
	mii->mii_writereg = cas_mii_writereg;
	mii->mii_statchg = cas_mii_statchg;

	ifmedia_init(&mii->mii_media, 0, cas_mediachange, cas_mediastatus);

	bus_space_write_4(sc->sc_memt, sc->sc_memh, CAS_MII_DATAPATH_MODE, 0);

	cas_mifinit(sc);

	if (sc->sc_mif_config & CAS_MIF_CONFIG_MDI1) {
		sc->sc_mif_config |= CAS_MIF_CONFIG_PHY_SEL;
		bus_space_write_4(sc->sc_memt, sc->sc_memh,
	            CAS_MIF_CONFIG, sc->sc_mif_config);
	}

	mii_attach(&sc->sc_dev, mii, 0xffffffff, MII_PHY_ANY,
	    MII_OFFSET_ANY, 0);

	child = LIST_FIRST(&mii->mii_phys);
	if (child == NULL &&
	    sc->sc_mif_config & (CAS_MIF_CONFIG_MDI0|CAS_MIF_CONFIG_MDI1)) {
		/* 
		 * Try the external PCS SERDES if we didn't find any
		 * MII devices.
		 */
		bus_space_write_4(sc->sc_memt, sc->sc_memh,
		    CAS_MII_DATAPATH_MODE, CAS_MII_DATAPATH_SERDES);

		bus_space_write_4(sc->sc_memt, sc->sc_memh,
		     CAS_MII_CONFIG, CAS_MII_CONFIG_ENABLE);

		mii->mii_readreg = cas_pcs_readreg;
		mii->mii_writereg = cas_pcs_writereg;

		mii_attach(&sc->sc_dev, mii, 0xffffffff, MII_PHY_ANY,
		    MII_OFFSET_ANY, MIIF_NOISOLATE);
	}

	child = LIST_FIRST(&mii->mii_phys);
	if (child == NULL) {
		/* No PHY attached */
		ifmedia_add(&sc->sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);
		ifmedia_set(&sc->sc_media, IFM_ETHER|IFM_MANUAL);
	} else {
		/*
		 * Walk along the list of attached MII devices and
		 * establish an `MII instance' to `phy number'
		 * mapping. We'll use this mapping in media change
		 * requests to determine which phy to use to program
		 * the MIF configuration register.
		 */
		for (; child != NULL; child = LIST_NEXT(child, mii_list)) {
			/*
			 * Note: we support just two PHYs: the built-in
			 * internal device and an external on the MII
			 * connector.
			 */
			if (child->mii_phy > 1 || child->mii_inst > 1) {
				printf("%s: cannot accommodate MII device %s"
				       " at phy %d, instance %lld\n",
				       sc->sc_dev.dv_xname,
				       child->mii_dev.dv_xname,
				       child->mii_phy, child->mii_inst);
				continue;
			}

			sc->sc_phys[child->mii_inst] = child->mii_phy;
		}

		/*
		 * XXX - we can really do the following ONLY if the
		 * phy indeed has the auto negotiation capability!!
		 */
		ifmedia_set(&sc->sc_media, IFM_ETHER|IFM_AUTO);
	}

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	timeout_set(&sc->sc_tick_ch, cas_tick, sc);
	return;

	/*
	 * Free any resources we've allocated during the failed attach
	 * attempt.  Do this in reverse order and fall through.
	 */
 fail_6:
	for (i = 0; i < CAS_NTXDESC; i++) {
		if (sc->sc_txd[i].sd_map != NULL)
			bus_dmamap_destroy(sc->sc_dmatag,
			    sc->sc_txd[i].sd_map);
	}
 fail_5:
	for (i = 0; i < CAS_NRXDESC; i++) {
		if (sc->sc_rxsoft[i].rxs_dmamap != NULL)
			bus_dmamap_destroy(sc->sc_dmatag,
			    sc->sc_rxsoft[i].rxs_dmamap);
	}
	bus_dmamap_unload(sc->sc_dmatag, sc->sc_cddmamap);
 fail_3:
	bus_dmamap_destroy(sc->sc_dmatag, sc->sc_cddmamap);
 fail_2:
	bus_dmamem_unmap(sc->sc_dmatag, (caddr_t)sc->sc_control_data,
	    sizeof(struct cas_control_data));
 fail_1:
	bus_dmamem_free(sc->sc_dmatag, &sc->sc_cdseg, sc->sc_cdnseg);
 fail_0:
	return;
}


void
cas_tick(void *arg)
{
	struct cas_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t mac = sc->sc_memh;
	int s;
	u_int32_t v;

	/* unload collisions counters */
	v = bus_space_read_4(t, mac, CAS_MAC_EXCESS_COLL_CNT) +
	    bus_space_read_4(t, mac, CAS_MAC_LATE_COLL_CNT);
	ifp->if_collisions += v +
	    bus_space_read_4(t, mac, CAS_MAC_NORM_COLL_CNT) +
	    bus_space_read_4(t, mac, CAS_MAC_FIRST_COLL_CNT);
	ifp->if_oerrors += v;

	/* read error counters */
	ifp->if_ierrors +=
	    bus_space_read_4(t, mac, CAS_MAC_RX_LEN_ERR_CNT) +
	    bus_space_read_4(t, mac, CAS_MAC_RX_ALIGN_ERR) +
	    bus_space_read_4(t, mac, CAS_MAC_RX_CRC_ERR_CNT) +
	    bus_space_read_4(t, mac, CAS_MAC_RX_CODE_VIOL);

	/* clear the hardware counters */
	bus_space_write_4(t, mac, CAS_MAC_NORM_COLL_CNT, 0);
	bus_space_write_4(t, mac, CAS_MAC_FIRST_COLL_CNT, 0);
	bus_space_write_4(t, mac, CAS_MAC_EXCESS_COLL_CNT, 0);
	bus_space_write_4(t, mac, CAS_MAC_LATE_COLL_CNT, 0);
	bus_space_write_4(t, mac, CAS_MAC_RX_LEN_ERR_CNT, 0);
	bus_space_write_4(t, mac, CAS_MAC_RX_ALIGN_ERR, 0);
	bus_space_write_4(t, mac, CAS_MAC_RX_CRC_ERR_CNT, 0);
	bus_space_write_4(t, mac, CAS_MAC_RX_CODE_VIOL, 0);

	s = splnet();
	mii_tick(&sc->sc_mii);
	splx(s);

	timeout_add_sec(&sc->sc_tick_ch, 1);
}

int
cas_bitwait(struct cas_softc *sc, bus_space_handle_t h, int r,
    u_int32_t clr, u_int32_t set)
{
	int i;
	u_int32_t reg;

	for (i = TRIES; i--; DELAY(100)) {
		reg = bus_space_read_4(sc->sc_memt, h, r);
		if ((reg & clr) == 0 && (reg & set) == set)
			return (1);
	}

	return (0);
}

void
cas_reset(struct cas_softc *sc)
{
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t h = sc->sc_memh;
	int s;

	s = splnet();
	DPRINTF(sc, ("%s: cas_reset\n", sc->sc_dev.dv_xname));
	cas_reset_rx(sc);
	cas_reset_tx(sc);

	/* Do a full reset */
	bus_space_write_4(t, h, CAS_RESET,
	    CAS_RESET_RX | CAS_RESET_TX | CAS_RESET_BLOCK_PCS);
	if (!cas_bitwait(sc, h, CAS_RESET, CAS_RESET_RX | CAS_RESET_TX, 0))
		printf("%s: cannot reset device\n", sc->sc_dev.dv_xname);
	splx(s);
}


/*
 * cas_rxdrain:
 *
 *	Drain the receive queue.
 */
void
cas_rxdrain(struct cas_softc *sc)
{
	/* Nothing to do yet. */
}

/*
 * Reset the whole thing.
 */
void
cas_stop(struct ifnet *ifp, int disable)
{
	struct cas_softc *sc = (struct cas_softc *)ifp->if_softc;
	struct cas_sxd *sd;
	u_int32_t i;

	DPRINTF(sc, ("%s: cas_stop\n", sc->sc_dev.dv_xname));

	timeout_del(&sc->sc_tick_ch);

	/*
	 * Mark the interface down and cancel the watchdog timer.
	 */
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_timer = 0;

	mii_down(&sc->sc_mii);

	cas_reset_rx(sc);
	cas_reset_tx(sc);

	intr_barrier(sc->sc_ih);
	KASSERT((ifp->if_flags & IFF_RUNNING) == 0);

	/*
	 * Release any queued transmit buffers.
	 */
	for (i = 0; i < CAS_NTXDESC; i++) {
		sd = &sc->sc_txd[i];
		if (sd->sd_mbuf != NULL) {
			bus_dmamap_sync(sc->sc_dmatag, sd->sd_map, 0,
			    sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmatag, sd->sd_map);
			m_freem(sd->sd_mbuf);
			sd->sd_mbuf = NULL;
		}
	}
	sc->sc_tx_cnt = sc->sc_tx_prod = sc->sc_tx_cons = 0;

	if (disable)
		cas_rxdrain(sc);
}


/*
 * Reset the receiver
 */
int
cas_reset_rx(struct cas_softc *sc)
{
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t h = sc->sc_memh;

	/*
	 * Resetting while DMA is in progress can cause a bus hang, so we
	 * disable DMA first.
	 */
	cas_disable_rx(sc);
	bus_space_write_4(t, h, CAS_RX_CONFIG, 0);
	/* Wait till it finishes */
	if (!cas_bitwait(sc, h, CAS_RX_CONFIG, 1, 0))
		printf("%s: cannot disable rx dma\n", sc->sc_dev.dv_xname);
	/* Wait 5ms extra. */
	delay(5000);

	/* Finally, reset the ERX */
	bus_space_write_4(t, h, CAS_RESET, CAS_RESET_RX);
	/* Wait till it finishes */
	if (!cas_bitwait(sc, h, CAS_RESET, CAS_RESET_RX, 0)) {
		printf("%s: cannot reset receiver\n", sc->sc_dev.dv_xname);
		return (1);
	}
	return (0);
}


/*
 * Reset the transmitter
 */
int
cas_reset_tx(struct cas_softc *sc)
{
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t h = sc->sc_memh;

	/*
	 * Resetting while DMA is in progress can cause a bus hang, so we
	 * disable DMA first.
	 */
	cas_disable_tx(sc);
	bus_space_write_4(t, h, CAS_TX_CONFIG, 0);
	/* Wait till it finishes */
	if (!cas_bitwait(sc, h, CAS_TX_CONFIG, 1, 0))
		printf("%s: cannot disable tx dma\n", sc->sc_dev.dv_xname);
	/* Wait 5ms extra. */
	delay(5000);

	/* Finally, reset the ETX */
	bus_space_write_4(t, h, CAS_RESET, CAS_RESET_TX);
	/* Wait till it finishes */
	if (!cas_bitwait(sc, h, CAS_RESET, CAS_RESET_TX, 0)) {
		printf("%s: cannot reset transmitter\n",
			sc->sc_dev.dv_xname);
		return (1);
	}
	return (0);
}

/*
 * disable receiver.
 */
int
cas_disable_rx(struct cas_softc *sc)
{
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t h = sc->sc_memh;
	u_int32_t cfg;

	/* Flip the enable bit */
	cfg = bus_space_read_4(t, h, CAS_MAC_RX_CONFIG);
	cfg &= ~CAS_MAC_RX_ENABLE;
	bus_space_write_4(t, h, CAS_MAC_RX_CONFIG, cfg);

	/* Wait for it to finish */
	return (cas_bitwait(sc, h, CAS_MAC_RX_CONFIG, CAS_MAC_RX_ENABLE, 0));
}

/*
 * disable transmitter.
 */
int
cas_disable_tx(struct cas_softc *sc)
{
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t h = sc->sc_memh;
	u_int32_t cfg;

	/* Flip the enable bit */
	cfg = bus_space_read_4(t, h, CAS_MAC_TX_CONFIG);
	cfg &= ~CAS_MAC_TX_ENABLE;
	bus_space_write_4(t, h, CAS_MAC_TX_CONFIG, cfg);

	/* Wait for it to finish */
	return (cas_bitwait(sc, h, CAS_MAC_TX_CONFIG, CAS_MAC_TX_ENABLE, 0));
}

/*
 * Initialize interface.
 */
int
cas_meminit(struct cas_softc *sc)
{
	struct cas_rxsoft *rxs;
	int i, error;

	rxs = (void *)&error;

	/*
	 * Initialize the transmit descriptor ring.
	 */
	for (i = 0; i < CAS_NTXDESC; i++) {
		sc->sc_txdescs[i].cd_flags = 0;
		sc->sc_txdescs[i].cd_addr = 0;
	}
	CAS_CDTXSYNC(sc, 0, CAS_NTXDESC,
	    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

	/*
	 * Initialize the receive descriptor and receive job
	 * descriptor rings.
	 */
	for (i = 0; i < CAS_NRXDESC; i++)
		CAS_INIT_RXDESC(sc, i, i);
	sc->sc_rxdptr = 0;
	sc->sc_rxptr = 0;

	/*
	 * Initialize the receive completion ring.
	 */
	for (i = 0; i < CAS_NRXCOMP; i++) {
		sc->sc_rxcomps[i].cc_word[0] = 0;
		sc->sc_rxcomps[i].cc_word[1] = 0;
		sc->sc_rxcomps[i].cc_word[2] = 0;
		sc->sc_rxcomps[i].cc_word[3] = CAS_DMA_WRITE(CAS_RC3_OWN);
		CAS_CDRXCSYNC(sc, i,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	}

	return (0);
}

int
cas_ringsize(int sz)
{
	switch (sz) {
	case 32:
		return CAS_RING_SZ_32;
	case 64:
		return CAS_RING_SZ_64;
	case 128:
		return CAS_RING_SZ_128;
	case 256:
		return CAS_RING_SZ_256;
	case 512:
		return CAS_RING_SZ_512;
	case 1024:
		return CAS_RING_SZ_1024;
	case 2048:
		return CAS_RING_SZ_2048;
	case 4096:
		return CAS_RING_SZ_4096;
	case 8192:
		return CAS_RING_SZ_8192;
	default:
		printf("cas: invalid Receive Descriptor ring size %d\n", sz);
		return CAS_RING_SZ_32;
	}
}

int
cas_cringsize(int sz)
{
	int i;

	for (i = 0; i < 9; i++)
		if (sz == (128 << i))
			return i;

	printf("cas: invalid completion ring size %d\n", sz);
	return 128;
}

/*
 * Initialization of interface; set up initialization block
 * and transmit/receive descriptor rings.
 */
int
cas_init(struct ifnet *ifp)
{
	struct cas_softc *sc = (struct cas_softc *)ifp->if_softc;
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t h = sc->sc_memh;
	int s;
	u_int max_frame_size;
	u_int32_t v;

	s = splnet();

	DPRINTF(sc, ("%s: cas_init: calling stop\n", sc->sc_dev.dv_xname));
	/*
	 * Initialization sequence. The numbered steps below correspond
	 * to the sequence outlined in section 6.3.5.1 in the Ethernet
	 * Channel Engine manual (part of the PCIO manual).
	 * See also the STP2002-STQ document from Sun Microsystems.
	 */

	/* step 1 & 2. Reset the Ethernet Channel */
	cas_stop(ifp, 0);
	cas_reset(sc);
	DPRINTF(sc, ("%s: cas_init: restarting\n", sc->sc_dev.dv_xname));

	/* Re-initialize the MIF */
	cas_mifinit(sc);

	/* step 3. Setup data structures in host memory */
	cas_meminit(sc);

	/* step 4. TX MAC registers & counters */
	cas_init_regs(sc);
	max_frame_size = ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN;
	v = (max_frame_size) | (0x2000 << 16) /* Burst size */;
	bus_space_write_4(t, h, CAS_MAC_MAC_MAX_FRAME, v);

	/* step 5. RX MAC registers & counters */
	cas_iff(sc);

	/* step 6 & 7. Program Descriptor Ring Base Addresses */
	KASSERT((CAS_CDTXADDR(sc, 0) & 0x1fff) == 0);
	bus_space_write_4(t, h, CAS_TX_RING_PTR_HI,
	    (((uint64_t)CAS_CDTXADDR(sc,0)) >> 32));
	bus_space_write_4(t, h, CAS_TX_RING_PTR_LO, CAS_CDTXADDR(sc, 0));

	KASSERT((CAS_CDRXADDR(sc, 0) & 0x1fff) == 0);
	bus_space_write_4(t, h, CAS_RX_DRING_PTR_HI,
	    (((uint64_t)CAS_CDRXADDR(sc,0)) >> 32));
	bus_space_write_4(t, h, CAS_RX_DRING_PTR_LO, CAS_CDRXADDR(sc, 0));

	KASSERT((CAS_CDRXCADDR(sc, 0) & 0x1fff) == 0);
	bus_space_write_4(t, h, CAS_RX_CRING_PTR_HI,
	    (((uint64_t)CAS_CDRXCADDR(sc,0)) >> 32));
	bus_space_write_4(t, h, CAS_RX_CRING_PTR_LO, CAS_CDRXCADDR(sc, 0));

	if (CAS_PLUS(sc)) {
		KASSERT((CAS_CDRXADDR2(sc, 0) & 0x1fff) == 0);
		bus_space_write_4(t, h, CAS_RX_DRING_PTR_HI2,
		    (((uint64_t)CAS_CDRXADDR2(sc,0)) >> 32));
		bus_space_write_4(t, h, CAS_RX_DRING_PTR_LO2,
		    CAS_CDRXADDR2(sc, 0));
	}

	/* step 8. Global Configuration & Interrupt Mask */
	bus_space_write_4(t, h, CAS_INTMASK,
		      ~(CAS_INTR_TX_INTME|CAS_INTR_TX_EMPTY|
			CAS_INTR_TX_TAG_ERR|
			CAS_INTR_RX_DONE|CAS_INTR_RX_NOBUF|
			CAS_INTR_RX_TAG_ERR|
			CAS_INTR_RX_COMP_FULL|CAS_INTR_PCS|
			CAS_INTR_MAC_CONTROL|CAS_INTR_MIF|
			CAS_INTR_BERR));
	bus_space_write_4(t, h, CAS_MAC_RX_MASK,
	    CAS_MAC_RX_DONE|CAS_MAC_RX_FRAME_CNT);
	bus_space_write_4(t, h, CAS_MAC_TX_MASK, CAS_MAC_TX_XMIT_DONE);
	bus_space_write_4(t, h, CAS_MAC_CONTROL_MASK, 0); /* XXXX */

	/* step 9. ETX Configuration: use mostly default values */

	/* Enable DMA */
	v = cas_ringsize(CAS_NTXDESC /*XXX*/) << 10;
	bus_space_write_4(t, h, CAS_TX_CONFIG,
	    v|CAS_TX_CONFIG_TXDMA_EN|(1<<24)|(1<<29));
	bus_space_write_4(t, h, CAS_TX_KICK, 0);

	/* step 10. ERX Configuration */

	/* Encode Receive Descriptor ring size */
	v = cas_ringsize(CAS_NRXDESC) << CAS_RX_CONFIG_RXDRNG_SZ_SHIFT;
	if (CAS_PLUS(sc))
		v |= cas_ringsize(32) << CAS_RX_CONFIG_RXDRNG2_SZ_SHIFT;

	/* Encode Receive Completion ring size */
	v |= cas_cringsize(CAS_NRXCOMP) << CAS_RX_CONFIG_RXCRNG_SZ_SHIFT;

	/* Enable DMA */
	bus_space_write_4(t, h, CAS_RX_CONFIG,
	    v|(2<<CAS_RX_CONFIG_FBOFF_SHFT)|CAS_RX_CONFIG_RXDMA_EN);

	/*
	 * The following value is for an OFF Threshold of about 3/4 full
	 * and an ON Threshold of 1/4 full.
	 */
	bus_space_write_4(t, h, CAS_RX_PAUSE_THRESH,
	    (3 * sc->sc_rxfifosize / 256) |
	    ((sc->sc_rxfifosize / 256) << 12));
	bus_space_write_4(t, h, CAS_RX_BLANKING, (6 << 12) | 6);

	/* step 11. Configure Media */
	mii_mediachg(&sc->sc_mii);

	/* step 12. RX_MAC Configuration Register */
	v = bus_space_read_4(t, h, CAS_MAC_RX_CONFIG);
	v |= CAS_MAC_RX_ENABLE | CAS_MAC_RX_STRIP_CRC;
	bus_space_write_4(t, h, CAS_MAC_RX_CONFIG, v);

	/* step 14. Issue Transmit Pending command */

	/* step 15.  Give the receiver a swift kick */
	bus_space_write_4(t, h, CAS_RX_KICK, CAS_NRXDESC-4);
	if (CAS_PLUS(sc))
		bus_space_write_4(t, h, CAS_RX_KICK2, 4);

	/* Start the one second timer. */
	timeout_add_sec(&sc->sc_tick_ch, 1);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_timer = 0;
	splx(s);

	return (0);
}

void
cas_init_regs(struct cas_softc *sc)
{
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t h = sc->sc_memh;
	u_int32_t v, r;

	/* These regs are not cleared on reset */
	sc->sc_inited = 0;
	if (!sc->sc_inited) {
		/* Load recommended values  */
		bus_space_write_4(t, h, CAS_MAC_IPG0, 0x00);
		bus_space_write_4(t, h, CAS_MAC_IPG1, 0x08);
		bus_space_write_4(t, h, CAS_MAC_IPG2, 0x04);

		bus_space_write_4(t, h, CAS_MAC_MAC_MIN_FRAME, ETHER_MIN_LEN);
		/* Max frame and max burst size */
		v = ETHER_MAX_LEN | (0x2000 << 16) /* Burst size */;
		bus_space_write_4(t, h, CAS_MAC_MAC_MAX_FRAME, v);

		bus_space_write_4(t, h, CAS_MAC_PREAMBLE_LEN, 0x07);
		bus_space_write_4(t, h, CAS_MAC_JAM_SIZE, 0x04);
		bus_space_write_4(t, h, CAS_MAC_ATTEMPT_LIMIT, 0x10);
		bus_space_write_4(t, h, CAS_MAC_CONTROL_TYPE, 0x8088);
		bus_space_write_4(t, h, CAS_MAC_RANDOM_SEED,
		    ((sc->sc_arpcom.ac_enaddr[5]<<8)|sc->sc_arpcom.ac_enaddr[4])&0x3ff);

		/* Secondary MAC addresses set to 0:0:0:0:0:0 */
		for (r = CAS_MAC_ADDR3; r < CAS_MAC_ADDR42; r += 4)
		  	bus_space_write_4(t, h, r, 0);

		/* MAC control addr set to 0:1:c2:0:1:80 */
		bus_space_write_4(t, h, CAS_MAC_ADDR42, 0x0001);
		bus_space_write_4(t, h, CAS_MAC_ADDR43, 0xc200);
		bus_space_write_4(t, h, CAS_MAC_ADDR44, 0x0180);

		/* MAC filter addr set to 0:0:0:0:0:0 */
		bus_space_write_4(t, h, CAS_MAC_ADDR_FILTER0, 0);
		bus_space_write_4(t, h, CAS_MAC_ADDR_FILTER1, 0);
		bus_space_write_4(t, h, CAS_MAC_ADDR_FILTER2, 0);

		bus_space_write_4(t, h, CAS_MAC_ADR_FLT_MASK1_2, 0);
		bus_space_write_4(t, h, CAS_MAC_ADR_FLT_MASK0, 0);

		/* Hash table initialized to 0 */
		for (r = CAS_MAC_HASH0; r <= CAS_MAC_HASH15; r += 4)
			bus_space_write_4(t, h, r, 0);

		sc->sc_inited = 1;
	}

	/* Counters need to be zeroed */
	bus_space_write_4(t, h, CAS_MAC_NORM_COLL_CNT, 0);
	bus_space_write_4(t, h, CAS_MAC_FIRST_COLL_CNT, 0);
	bus_space_write_4(t, h, CAS_MAC_EXCESS_COLL_CNT, 0);
	bus_space_write_4(t, h, CAS_MAC_LATE_COLL_CNT, 0);
	bus_space_write_4(t, h, CAS_MAC_DEFER_TMR_CNT, 0);
	bus_space_write_4(t, h, CAS_MAC_PEAK_ATTEMPTS, 0);
	bus_space_write_4(t, h, CAS_MAC_RX_FRAME_COUNT, 0);
	bus_space_write_4(t, h, CAS_MAC_RX_LEN_ERR_CNT, 0);
	bus_space_write_4(t, h, CAS_MAC_RX_ALIGN_ERR, 0);
	bus_space_write_4(t, h, CAS_MAC_RX_CRC_ERR_CNT, 0);
	bus_space_write_4(t, h, CAS_MAC_RX_CODE_VIOL, 0);

	/* Un-pause stuff */
	bus_space_write_4(t, h, CAS_MAC_SEND_PAUSE_CMD, 0);

	/*
	 * Set the station address.
	 */
	bus_space_write_4(t, h, CAS_MAC_ADDR0, 
		(sc->sc_arpcom.ac_enaddr[4]<<8) | sc->sc_arpcom.ac_enaddr[5]);
	bus_space_write_4(t, h, CAS_MAC_ADDR1, 
		(sc->sc_arpcom.ac_enaddr[2]<<8) | sc->sc_arpcom.ac_enaddr[3]);
	bus_space_write_4(t, h, CAS_MAC_ADDR2, 
		(sc->sc_arpcom.ac_enaddr[0]<<8) | sc->sc_arpcom.ac_enaddr[1]);
}

/*
 * Receive interrupt.
 */
int
cas_rint(struct cas_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t h = sc->sc_memh;
	struct cas_rxsoft *rxs;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;
	u_int64_t word[4];
	int len, off, idx;
	int i, skip;
	caddr_t cp;

	for (i = sc->sc_rxptr;; i = CAS_NEXTRX(i + skip)) {
		CAS_CDRXCSYNC(sc, i,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);

		word[0] = CAS_DMA_READ(sc->sc_rxcomps[i].cc_word[0]);
		word[1] = CAS_DMA_READ(sc->sc_rxcomps[i].cc_word[1]);
		word[2] = CAS_DMA_READ(sc->sc_rxcomps[i].cc_word[2]);
		word[3] = CAS_DMA_READ(sc->sc_rxcomps[i].cc_word[3]);

		/* Stop if the hardware still owns the descriptor. */
		if ((word[0] & CAS_RC0_TYPE) == 0 || word[3] & CAS_RC3_OWN)
			break;

		len = CAS_RC1_HDR_LEN(word[1]);
		if (len > 0) {
			off = CAS_RC1_HDR_OFF(word[1]);
			idx = CAS_RC1_HDR_IDX(word[1]);
			rxs = &sc->sc_rxsoft[idx];

			DPRINTF(sc, ("hdr at idx %d, off %d, len %d\n",
			    idx, off, len));

			bus_dmamap_sync(sc->sc_dmatag, rxs->rxs_dmamap, 0,
			    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);

			cp = rxs->rxs_kva + off * 256 + ETHER_ALIGN;
			m = m_devget(cp, len, ETHER_ALIGN);

			if (word[0] & CAS_RC0_RELEASE_HDR)
				cas_add_rxbuf(sc, idx);

			if (m != NULL) {
				ml_enqueue(&ml, m);
			} else
				ifp->if_ierrors++;
		}

		len = CAS_RC0_DATA_LEN(word[0]);
		if (len > 0) {
			off = CAS_RC0_DATA_OFF(word[0]);
			idx = CAS_RC0_DATA_IDX(word[0]);
			rxs = &sc->sc_rxsoft[idx];

			DPRINTF(sc, ("data at idx %d, off %d, len %d\n",
			    idx, off, len));

			bus_dmamap_sync(sc->sc_dmatag, rxs->rxs_dmamap, 0,
			    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);

			/* XXX We should not be copying the packet here. */
			cp = rxs->rxs_kva + off + ETHER_ALIGN;
			m = m_devget(cp, len, ETHER_ALIGN);

			if (word[0] & CAS_RC0_RELEASE_DATA)
				cas_add_rxbuf(sc, idx);

			if (m != NULL) {
				ml_enqueue(&ml, m);
			} else
				ifp->if_ierrors++;
		}

		if (word[0] & CAS_RC0_SPLIT)
			printf("split packet\n");

		skip = CAS_RC0_SKIP(word[0]);
	}

	while (sc->sc_rxptr != i) {
		sc->sc_rxcomps[sc->sc_rxptr].cc_word[0] = 0;
		sc->sc_rxcomps[sc->sc_rxptr].cc_word[1] = 0;
		sc->sc_rxcomps[sc->sc_rxptr].cc_word[2] = 0;
		sc->sc_rxcomps[sc->sc_rxptr].cc_word[3] =
		    CAS_DMA_WRITE(CAS_RC3_OWN);
		CAS_CDRXCSYNC(sc, sc->sc_rxptr,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

		sc->sc_rxptr = CAS_NEXTRX(sc->sc_rxptr);
	}

	bus_space_write_4(t, h, CAS_RX_COMP_TAIL, sc->sc_rxptr);

	DPRINTF(sc, ("cas_rint: done sc->rxptr %d, complete %d\n",
		sc->sc_rxptr, bus_space_read_4(t, h, CAS_RX_COMPLETION)));

	if_input(ifp, &ml);

	return (1);
}

/*
 * cas_add_rxbuf:
 *
 *	Add a receive buffer to the indicated descriptor.
 */
int
cas_add_rxbuf(struct cas_softc *sc, int idx)
{
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t h = sc->sc_memh;

	CAS_INIT_RXDESC(sc, sc->sc_rxdptr, idx);

	if ((sc->sc_rxdptr % 4) == 0)
		bus_space_write_4(t, h, CAS_RX_KICK, sc->sc_rxdptr);

	if (++sc->sc_rxdptr == CAS_NRXDESC)
		sc->sc_rxdptr = 0;

	return (0);
}

int
cas_eint(struct cas_softc *sc, u_int status)
{
	if ((status & CAS_INTR_MIF) != 0) {
#ifdef CAS_DEBUG
		printf("%s: link status changed\n", sc->sc_dev.dv_xname);
#endif
		return (1);
	}

	printf("%s: status=%b\n", sc->sc_dev.dv_xname, status, CAS_INTR_BITS);
	return (1);
}

int
cas_pint(struct cas_softc *sc)
{
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t seb = sc->sc_memh;
	u_int32_t status;

	status = bus_space_read_4(t, seb, CAS_MII_INTERRUP_STATUS);
	status |= bus_space_read_4(t, seb, CAS_MII_INTERRUP_STATUS);
#ifdef CAS_DEBUG
	if (status)
		printf("%s: link status changed\n", sc->sc_dev.dv_xname);
#endif
	return (1);
}

int
cas_intr(void *v)
{
	struct cas_softc *sc = (struct cas_softc *)v;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t seb = sc->sc_memh;
	u_int32_t status;
	int r = 0;

	status = bus_space_read_4(t, seb, CAS_STATUS);
	DPRINTF(sc, ("%s: cas_intr: cplt %xstatus %b\n",
		sc->sc_dev.dv_xname, (status>>19), status, CAS_INTR_BITS));

	if ((status & CAS_INTR_PCS) != 0)
		r |= cas_pint(sc);

	if ((status & (CAS_INTR_TX_TAG_ERR | CAS_INTR_RX_TAG_ERR |
	    CAS_INTR_RX_COMP_FULL | CAS_INTR_BERR)) != 0)
		r |= cas_eint(sc, status);

	if ((status & (CAS_INTR_TX_EMPTY | CAS_INTR_TX_INTME)) != 0)
		r |= cas_tint(sc, status);

	if ((status & (CAS_INTR_RX_DONE | CAS_INTR_RX_NOBUF)) != 0)
		r |= cas_rint(sc);

	/* We should eventually do more than just print out error stats. */
	if (status & CAS_INTR_TX_MAC) {
		int txstat = bus_space_read_4(t, seb, CAS_MAC_TX_STATUS);
#ifdef CAS_DEBUG
		if (txstat & ~CAS_MAC_TX_XMIT_DONE)
			printf("%s: MAC tx fault, status %x\n",
			    sc->sc_dev.dv_xname, txstat);
#endif
		if (txstat & (CAS_MAC_TX_UNDERRUN | CAS_MAC_TX_PKT_TOO_LONG)) {
			KERNEL_LOCK();
			cas_init(ifp);
			KERNEL_UNLOCK();
		}
	}
	if (status & CAS_INTR_RX_MAC) {
		int rxstat = bus_space_read_4(t, seb, CAS_MAC_RX_STATUS);
#ifdef CAS_DEBUG
 		if (rxstat & ~CAS_MAC_RX_DONE)
 			printf("%s: MAC rx fault, status %x\n",
 			    sc->sc_dev.dv_xname, rxstat);
#endif
		/*
		 * On some chip revisions CAS_MAC_RX_OVERFLOW happen often
		 * due to a silicon bug so handle them silently.
		 */
		if (rxstat & CAS_MAC_RX_OVERFLOW) {
			KERNEL_LOCK();
			ifp->if_ierrors++;
			cas_init(ifp);
			KERNEL_UNLOCK();
		}
#ifdef CAS_DEBUG
		else if (rxstat & ~(CAS_MAC_RX_DONE | CAS_MAC_RX_FRAME_CNT))
			printf("%s: MAC rx fault, status %x\n",
			    sc->sc_dev.dv_xname, rxstat);
#endif
	}
	return (r);
}


void
cas_watchdog(struct ifnet *ifp)
{
	struct cas_softc *sc = ifp->if_softc;

	DPRINTF(sc, ("cas_watchdog: CAS_RX_CONFIG %x CAS_MAC_RX_STATUS %x "
		"CAS_MAC_RX_CONFIG %x\n",
		bus_space_read_4(sc->sc_memt, sc->sc_memh, CAS_RX_CONFIG),
		bus_space_read_4(sc->sc_memt, sc->sc_memh, CAS_MAC_RX_STATUS),
		bus_space_read_4(sc->sc_memt, sc->sc_memh, CAS_MAC_RX_CONFIG)));

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++ifp->if_oerrors;

	/* Try to get more packets going. */
	cas_init(ifp);
}

/*
 * Initialize the MII Management Interface
 */
void
cas_mifinit(struct cas_softc *sc)
{
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t mif = sc->sc_memh;

	/* Configure the MIF in frame mode */
	sc->sc_mif_config = bus_space_read_4(t, mif, CAS_MIF_CONFIG);
	sc->sc_mif_config &= ~CAS_MIF_CONFIG_BB_ENA;
	bus_space_write_4(t, mif, CAS_MIF_CONFIG, sc->sc_mif_config);
}

/*
 * MII interface
 *
 * The Cassini MII interface supports at least three different operating modes:
 *
 * Bitbang mode is implemented using data, clock and output enable registers.
 *
 * Frame mode is implemented by loading a complete frame into the frame
 * register and polling the valid bit for completion.
 *
 * Polling mode uses the frame register but completion is indicated by
 * an interrupt.
 *
 */
int
cas_mii_readreg(struct device *self, int phy, int reg)
{
	struct cas_softc *sc = (void *)self;
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t mif = sc->sc_memh;
	int n;
	u_int32_t v;

#ifdef CAS_DEBUG
	if (sc->sc_debug)
		printf("cas_mii_readreg: phy %d reg %d\n", phy, reg);
#endif

	/* Construct the frame command */
	v = (reg << CAS_MIF_REG_SHIFT)	| (phy << CAS_MIF_PHY_SHIFT) |
		CAS_MIF_FRAME_READ;

	bus_space_write_4(t, mif, CAS_MIF_FRAME, v);
	for (n = 0; n < 100; n++) {
		DELAY(1);
		v = bus_space_read_4(t, mif, CAS_MIF_FRAME);
		if (v & CAS_MIF_FRAME_TA0)
			return (v & CAS_MIF_FRAME_DATA);
	}

	printf("%s: mii_read timeout\n", sc->sc_dev.dv_xname);
	return (0);
}

void
cas_mii_writereg(struct device *self, int phy, int reg, int val)
{
	struct cas_softc *sc = (void *)self;
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t mif = sc->sc_memh;
	int n;
	u_int32_t v;

#ifdef CAS_DEBUG
	if (sc->sc_debug)
		printf("cas_mii_writereg: phy %d reg %d val %x\n",
			phy, reg, val);
#endif

	/* Construct the frame command */
	v = CAS_MIF_FRAME_WRITE			|
	    (phy << CAS_MIF_PHY_SHIFT)		|
	    (reg << CAS_MIF_REG_SHIFT)		|
	    (val & CAS_MIF_FRAME_DATA);

	bus_space_write_4(t, mif, CAS_MIF_FRAME, v);
	for (n = 0; n < 100; n++) {
		DELAY(1);
		v = bus_space_read_4(t, mif, CAS_MIF_FRAME);
		if (v & CAS_MIF_FRAME_TA0)
			return;
	}

	printf("%s: mii_write timeout\n", sc->sc_dev.dv_xname);
}

void
cas_mii_statchg(struct device *dev)
{
	struct cas_softc *sc = (void *)dev;
#ifdef CAS_DEBUG
	uint64_t instance = IFM_INST(sc->sc_mii.mii_media.ifm_cur->ifm_media);
#endif
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t mac = sc->sc_memh;
	u_int32_t v;

#ifdef CAS_DEBUG
	if (sc->sc_debug)
		printf("cas_mii_statchg: status change: phy = %d\n",
		    sc->sc_phys[instance]);
#endif

	/* Set tx full duplex options */
	bus_space_write_4(t, mac, CAS_MAC_TX_CONFIG, 0);
	delay(10000); /* reg must be cleared and delay before changing. */
	v = CAS_MAC_TX_ENA_IPG0|CAS_MAC_TX_NGU|CAS_MAC_TX_NGU_LIMIT|
		CAS_MAC_TX_ENABLE;
	if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_FDX) != 0) {
		v |= CAS_MAC_TX_IGN_CARRIER|CAS_MAC_TX_IGN_COLLIS;
	}
	bus_space_write_4(t, mac, CAS_MAC_TX_CONFIG, v);

	/* XIF Configuration */
	v = CAS_MAC_XIF_TX_MII_ENA;
	v |= CAS_MAC_XIF_LINK_LED;

	/* MII needs echo disable if half duplex. */
	if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_FDX) != 0)
		/* turn on full duplex LED */
		v |= CAS_MAC_XIF_FDPLX_LED;
	else
		/* half duplex -- disable echo */
		v |= CAS_MAC_XIF_ECHO_DISABL;

	switch (IFM_SUBTYPE(sc->sc_mii.mii_media_active)) {
	case IFM_1000_T:  /* Gigabit using GMII interface */
	case IFM_1000_SX:
		v |= CAS_MAC_XIF_GMII_MODE;
		break;
	default:
		v &= ~CAS_MAC_XIF_GMII_MODE;
	}
	bus_space_write_4(t, mac, CAS_MAC_XIF_CONFIG, v);
}

int
cas_pcs_readreg(struct device *self, int phy, int reg)
{
	struct cas_softc *sc = (void *)self;
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t pcs = sc->sc_memh;

#ifdef CAS_DEBUG
	if (sc->sc_debug)
		printf("cas_pcs_readreg: phy %d reg %d\n", phy, reg);
#endif

	if (phy != CAS_PHYAD_EXTERNAL)
		return (0);

	switch (reg) {
	case MII_BMCR:
		reg = CAS_MII_CONTROL;
		break;
	case MII_BMSR:
		reg = CAS_MII_STATUS;
		break;
	case MII_ANAR:
		reg = CAS_MII_ANAR;
		break;
	case MII_ANLPAR:
		reg = CAS_MII_ANLPAR;
		break;
	case MII_EXTSR:
		return (EXTSR_1000XFDX|EXTSR_1000XHDX);
	default:
		return (0);
	}

	return bus_space_read_4(t, pcs, reg);
}

void
cas_pcs_writereg(struct device *self, int phy, int reg, int val)
{
	struct cas_softc *sc = (void *)self;
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t pcs = sc->sc_memh;
	int reset = 0;

#ifdef CAS_DEBUG
	if (sc->sc_debug)
		printf("cas_pcs_writereg: phy %d reg %d val %x\n",
			phy, reg, val);
#endif

	if (phy != CAS_PHYAD_EXTERNAL)
		return;

	if (reg == MII_ANAR)
		bus_space_write_4(t, pcs, CAS_MII_CONFIG, 0);

	switch (reg) {
	case MII_BMCR:
		reset = (val & CAS_MII_CONTROL_RESET);
		reg = CAS_MII_CONTROL;
		break;
	case MII_BMSR:
		reg = CAS_MII_STATUS;
		break;
	case MII_ANAR:
		reg = CAS_MII_ANAR;
		break;
	case MII_ANLPAR:
		reg = CAS_MII_ANLPAR;
		break;
	default:
		return;
	}

	bus_space_write_4(t, pcs, reg, val);

	if (reset)
		cas_bitwait(sc, pcs, CAS_MII_CONTROL, CAS_MII_CONTROL_RESET, 0);

	if (reg == CAS_MII_ANAR || reset)
		bus_space_write_4(t, pcs, CAS_MII_CONFIG,
		    CAS_MII_CONFIG_ENABLE);
}

int
cas_mediachange(struct ifnet *ifp)
{
	struct cas_softc *sc = ifp->if_softc;
	struct mii_data *mii = &sc->sc_mii;

	if (mii->mii_instance) {
		struct mii_softc *miisc;
		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
			mii_phy_reset(miisc);
	}

	return (mii_mediachg(&sc->sc_mii));
}

void
cas_mediastatus(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct cas_softc *sc = ifp->if_softc;

	mii_pollstat(&sc->sc_mii);
	ifmr->ifm_active = sc->sc_mii.mii_media_active;
	ifmr->ifm_status = sc->sc_mii.mii_media_status;
}

/*
 * Process an ioctl request.
 */
int
cas_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct cas_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if ((ifp->if_flags & IFF_RUNNING) == 0)
			cas_init(ifp);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				cas_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				cas_stop(ifp, 1);
		}
#ifdef CAS_DEBUG
		sc->sc_debug = (ifp->if_flags & IFF_DEBUG) != 0 ? 1 : 0;
#endif
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			cas_iff(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

void
cas_iff(struct cas_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct arpcom *ac = &sc->sc_arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t h = sc->sc_memh;
	u_int32_t crc, hash[16], rxcfg;
	int i;

	rxcfg = bus_space_read_4(t, h, CAS_MAC_RX_CONFIG);
	rxcfg &= ~(CAS_MAC_RX_HASH_FILTER | CAS_MAC_RX_PROMISCUOUS |
	    CAS_MAC_RX_PROMISC_GRP);
	ifp->if_flags &= ~IFF_ALLMULTI;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		if (ifp->if_flags & IFF_PROMISC)
			rxcfg |= CAS_MAC_RX_PROMISCUOUS;
		else
			rxcfg |= CAS_MAC_RX_PROMISC_GRP;
        } else {
		/*
		 * Set up multicast address filter by passing all multicast
		 * addresses through a crc generator, and then using the
		 * high order 8 bits as an index into the 256 bit logical
		 * address filter.  The high order 4 bits selects the word,
		 * while the other 4 bits select the bit within the word
		 * (where bit 0 is the MSB).
		 */

		rxcfg |= CAS_MAC_RX_HASH_FILTER;

		/* Clear hash table */
		for (i = 0; i < 16; i++)
			hash[i] = 0;

		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
                        crc = ether_crc32_le(enm->enm_addrlo,
                            ETHER_ADDR_LEN);

                        /* Just want the 8 most significant bits. */
                        crc >>= 24;

                        /* Set the corresponding bit in the filter. */
                        hash[crc >> 4] |= 1 << (15 - (crc & 15));

			ETHER_NEXT_MULTI(step, enm);
		}

		/* Now load the hash table into the chip (if we are using it) */
		for (i = 0; i < 16; i++) {
			bus_space_write_4(t, h,
			    CAS_MAC_HASH0 + i * (CAS_MAC_HASH1 - CAS_MAC_HASH0),
			    hash[i]);
		}
	}

	bus_space_write_4(t, h, CAS_MAC_RX_CONFIG, rxcfg);
}

int
cas_encap(struct cas_softc *sc, struct mbuf *m, int *used)
{
	u_int64_t flags;
	u_int32_t first, cur, frag, i;
	bus_dmamap_t map;

	cur = frag = (sc->sc_tx_prod + *used) % CAS_NTXDESC;
	map = sc->sc_txd[cur].sd_map;

	switch (bus_dmamap_load_mbuf(sc->sc_dmatag, map, m, BUS_DMA_NOWAIT)) {
	case 0:
		break;
	case EFBIG:
		if (m_defrag(m, M_DONTWAIT) == 0 &&
		    bus_dmamap_load_mbuf(sc->sc_dmatag, map, m,
		    BUS_DMA_NOWAIT) == 0)
			break;
		/* FALLTHROUGH */
	default:
		return (ENOBUFS);
	}

	bus_dmamap_sync(sc->sc_dmatag, map, 0, map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	first = cur;
	for (i = 0; i < map->dm_nsegs; i++) {
		sc->sc_txdescs[frag].cd_addr =
		    CAS_DMA_WRITE(map->dm_segs[i].ds_addr);
		flags = (map->dm_segs[i].ds_len & CAS_TD_BUFSIZE) |
		    (i == 0 ? CAS_TD_START_OF_PACKET : 0) |
		    ((i == (map->dm_nsegs - 1)) ? CAS_TD_END_OF_PACKET : 0);
		sc->sc_txdescs[frag].cd_flags = CAS_DMA_WRITE(flags);
		bus_dmamap_sync(sc->sc_dmatag, sc->sc_cddmamap,
		    CAS_CDTXOFF(frag), sizeof(struct cas_desc),
		    BUS_DMASYNC_PREWRITE);
		cur = frag;
		if (++frag == CAS_NTXDESC)
			frag = 0;
	}

	sc->sc_txd[first].sd_map = sc->sc_txd[cur].sd_map;
	sc->sc_txd[cur].sd_map = map;
	sc->sc_txd[cur].sd_mbuf = m;

	bus_space_write_4(sc->sc_memt, sc->sc_memh, CAS_TX_KICK, frag);

	*used += map->dm_nsegs;

	/* sync descriptors */

	return (0);
}

/*
 * Transmit interrupt.
 */
int
cas_tint(struct cas_softc *sc, u_int32_t status)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct cas_sxd *sd;
	u_int32_t cons, comp;
	int freed, used;

	comp = bus_space_read_4(sc->sc_memt, sc->sc_memh, CAS_TX_COMPLETION);
	cons = sc->sc_tx_cons;
	freed = 0;
	while (cons != comp) {
		sd = &sc->sc_txd[cons];
		if (sd->sd_mbuf != NULL) {
			bus_dmamap_sync(sc->sc_dmatag, sd->sd_map, 0,
			    sd->sd_map->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmatag, sd->sd_map);
			m_freem(sd->sd_mbuf);
			sd->sd_mbuf = NULL;
		}
		freed++;
		if (++cons == CAS_NTXDESC)
			cons = 0;
	}
	sc->sc_tx_cons = cons;

	used = atomic_sub_int_nv(&sc->sc_tx_cnt, freed);
	if (used < CAS_NTXDESC - 2)
		ifq_clr_oactive(&ifp->if_snd);
	if (used == 0)
		ifp->if_timer = 0;

	if (!IFQ_IS_EMPTY(&ifp->if_snd)) {
		KERNEL_LOCK();
		cas_start(ifp);
		KERNEL_UNLOCK();
	}

	return (1);
}

void
cas_start(struct ifnet *ifp)
{
	struct cas_softc *sc = ifp->if_softc;
	struct mbuf *m = NULL;
	int used;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	used = 0;
	while (1) {
		if ((sc->sc_tx_cnt + used + CAS_NTXSEGS) >= (CAS_NTXDESC - 2)) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;

		if (cas_encap(sc, m, &used)) {
			m_freem(m);
			continue;
		}

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
	}

	if (used != 0) {
		ifp->if_timer = 5;
		sc->sc_tx_prod = (sc->sc_tx_prod + used) % CAS_NTXDESC;
		atomic_add_int(&sc->sc_tx_cnt, used);
	}
}
@


1.50
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.49 2015/12/08 13:34:22 tedu Exp $	*/
a1848 1
			ifp->if_opackets++;
@


1.49
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.48 2015/12/06 11:32:54 jsg Exp $	*/
a496 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.48
log
@switch on the return value of bus_dmamap_load_mbuf not value != 0
problem in rev 1.47 spotted by clang's -Wswitch-bool

ok jmatthew@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.47 2015/12/03 09:51:52 jmatthew Exp $	*/
d492 1
a492 1
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
@


1.47
log
@Rework cas_start to check for space on the ring before dequeueing and drop
the packet if encap fails, use m_defrag if the mbuf is too fragmented,
adjust sc_tx_cnt using atomic operations, hold the kernel lock while calling
cas_init and cas_start from the interrupt handler, use an interrupt barrier
in cas_stop, and finally mark the interupt handler mpsafe.

encouragement from dlg@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.46 2015/11/25 03:09:59 dlg Exp $	*/
d1783 1
a1783 2
	switch (bus_dmamap_load_mbuf(sc->sc_dmatag, map, m,
	    BUS_DMA_NOWAIT) != 0) {
@


1.46
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.45 2015/11/24 17:11:39 mpi Exp $	*/
d59 1
d124 1
a124 1
int		cas_encap(struct cas_softc *, struct mbuf *, u_int32_t *);
d350 1
a350 1
	    ih, IPL_NET, cas_intr, sc, self->dv_xname);
d732 3
d1354 2
a1355 1
		if (txstat & (CAS_MAC_TX_UNDERRUN | CAS_MAC_TX_PKT_TOO_LONG))
d1357 2
d1372 1
d1375 1
d1774 1
a1774 1
cas_encap(struct cas_softc *sc, struct mbuf *mhead, u_int32_t *bixp)
d1777 1
a1777 1
	u_int32_t cur, frag, i;
d1780 1
a1780 1
	cur = frag = *bixp;
d1783 1
a1783 1
	if (bus_dmamap_load_mbuf(sc->sc_dmatag, map, mhead,
d1785 9
a1793 5
		return (ENOBUFS);
	}

	if ((sc->sc_tx_cnt + map->dm_nsegs) > (CAS_NTXDESC - 2)) {
		bus_dmamap_unload(sc->sc_dmatag, map);
d1800 1
d1816 1
a1816 2
	sc->sc_tx_cnt += map->dm_nsegs;
	sc->sc_txd[*bixp].sd_map = sc->sc_txd[cur].sd_map;
d1818 1
a1818 1
	sc->sc_txd[cur].sd_mbuf = mhead;
d1822 1
a1822 1
	*bixp = frag;
d1838 1
d1842 1
d1853 1
a1853 1
		sc->sc_tx_cnt--;
d1859 2
a1860 1
	if (sc->sc_tx_cnt < CAS_NTXDESC - 2)
d1862 1
a1862 1
	if (sc->sc_tx_cnt == 0)
d1865 5
a1869 1
	cas_start(ifp);
d1878 2
a1879 2
	struct mbuf *m;
	u_int32_t bix;
d1884 8
a1891 3
	bix = sc->sc_tx_prod;
	while (sc->sc_txd[bix].sd_mbuf == NULL) {
		m = ifq_deq_begin(&ifp->if_snd);
d1895 5
a1900 4
		/*
		 * If BPF is listening on this interface, let it see the
		 * packet before we commit it to the wire.
		 */
d1904 1
d1906 1
a1906 11
		/*
		 * Encapsulate this packet and start it going...
		 * or fail...
		 */
		if (cas_encap(sc, m, &bix)) {
			ifq_deq_rollback(&ifp->if_snd, m);
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		ifq_deq_commit(&ifp->if_snd, m);
d1908 2
a1910 2

	sc->sc_tx_prod = bix;
@


1.45
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.44 2015/11/20 03:35:23 dlg Exp $	*/
d722 2
a723 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d1071 1
a1071 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1845 1
a1845 1
		ifp->if_flags &= ~IFF_OACTIVE;
d1861 1
a1861 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d1885 1
a1885 1
			ifp->if_flags |= IFF_OACTIVE;
@


1.44
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.43 2015/10/25 13:04:28 mpi Exp $	*/
a60 1
#include <net/if_dl.h>
@


1.43
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.42 2015/09/11 13:02:28 stsp Exp $	*/
d1866 1
a1866 1
		IFQ_POLL(&ifp->if_snd, m);
d1884 1
d1889 1
a1889 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.42
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.41 2015/06/24 09:40:54 mpi Exp $	*/
a1653 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a1663 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_arpcom, ifa);
@


1.41
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.40 2015/04/13 08:45:48 mpi Exp $	*/
d563 1
a563 1
				       " at phy %d, instance %d\n",
d1492 1
a1492 1
	int instance = IFM_INST(sc->sc_mii.mii_media.ifm_cur->ifm_media);
@


1.40
log
@Now that if_input() set the receiving interface pointer on mbufs for us
there's no need to do it in m_devget(9).

Stop passing an ``ifp'' will help for upcoming interface pointer -> index
conversion.

While here remove unused ``ifp'' argument from m_clget(9) and kill two
birds^W layer violations in one commit.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.39 2015/03/14 03:38:48 jsg Exp $	*/
a1204 1
				ifp->if_ipackets++;
a1229 1
				ifp->if_ipackets++;
@


1.39
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.38 2015/03/11 22:15:22 mpi Exp $	*/
d1199 1
a1199 1
			m = m_devget(cp, len, ETHER_ALIGN, ifp);
d1225 1
a1225 1
			m = m_devget(cp, len, ETHER_ALIGN, ifp);
@


1.38
log
@Convert to if_input().

Tested and ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.37 2014/12/22 02:28:52 tedu Exp $	*/
a75 1
#include <dev/mii/mii_bitbang.h>
@


1.37
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.36 2014/12/19 22:44:58 guenther Exp $	*/
d1167 1
d1201 1
a1201 1
			
a1205 10

#if NBPFILTER > 0
				/*
				 * Pass this up to any BPF listeners, but only
				 * pass it up the stack if its for us.
				 */
				if (ifp->if_bpf)
					bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif /* NBPFILTER > 0 */

d1207 1
a1207 1
				ether_input_mbuf(ifp, m);
a1231 9
#if NBPFILTER > 0
				/*
				 * Pass this up to any BPF listeners, but only
				 * pass it up the stack if its for us.
				 */
				if (ifp->if_bpf)
					bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif /* NBPFILTER > 0 */

d1233 1
a1233 1
				ether_input_mbuf(ifp, m);
d1260 2
@


1.36
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.35 2014/11/18 01:56:32 brad Exp $	*/
a63 1
#ifdef INET
a65 1
#endif
a1683 1
#ifdef INET
a1685 1
#endif
@


1.35
log
@Use pa_device to ensure each MAC address of a multi port board
is unique; as done by hme(4).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.34 2014/11/16 05:46:20 brad Exp $	*/
d58 1
a58 2

#include <machine/endian.h>
@


1.34
log
@Allow the driver to be able to retrieve the MAC address from the ROM
for NS Saturn based boards.

From NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.33 2013/08/21 05:21:44 dlg Exp $	*/
d283 1
@


1.33
log
@get rid of the copy argument in m_devget that let you provide an
alternative to bcopy since noone uses it.

while there use memcpy instead of bcopy because we know the memory cannot
overlap.

ok henning@@ matthew@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.32 2011/04/03 15:36:02 jasper Exp $	*/
d170 1
a170 1
static const u_int8_t cas_promdat[] = {
d175 5
d219 2
a220 1
	if (bcmp(buf, cas_promdat, sizeof(cas_promdat)) ||
@


1.32
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.31 2010/09/20 07:40:38 deraadt Exp $	*/
d1195 1
a1195 1
			m = m_devget(cp, len, ETHER_ALIGN, ifp, NULL);
d1231 1
a1231 1
			m = m_devget(cp, len, ETHER_ALIGN, ifp, NULL);
@


1.31
log
@Stop doing shutdown hooks in network drivers where possible.  We already
take all interfaces down, via their xxstop routines.  Claudio and I have
verified that none of the shutdown hooks do much extra beyond what xxstop
was already doing; it is largely a pile of junk.
ok claudio, some early comments by sthen; also read by matthew, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.30 2010/05/19 15:27:35 oga Exp $	*/
d162 1
a162 1
	    sizeof(cas_pci_devices)/sizeof(cas_pci_devices[0])));
@


1.30
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.29 2009/11/29 16:19:38 kettenis Exp $	*/
a111 1
void		cas_shutdown(void *);
a580 4
	sc->sc_sh = shutdownhook_establish(cas_shutdown, sc);
	if (sc->sc_sh == NULL)
		panic("cas_config: can't establish shutdownhook");

a1717 10
}


void
cas_shutdown(void *arg)
{
	struct cas_softc *sc = (struct cas_softc *)arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	cas_stop(ifp, 1);
@


1.29
log
@Merge in some tidying up bits from gem(4).  From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.28 2009/11/17 20:47:42 kettenis Exp $	*/
d389 1
a389 1
	    1, &sc->sc_cdnseg, 0)) != 0) {
a418 2

	bzero(sc->sc_control_data, sizeof(struct cas_control_data));
@


1.28
log
@Tidy up promisc/multicast handing.  From Brad.  Tested by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.27 2009/07/23 19:35:32 kettenis Exp $	*/
d1053 2
a1054 2
	    (   (sc->sc_rxfifosize / 256) << 12));
	bus_space_write_4(t, h, CAS_RX_BLANKING, (6<<12)|6);
d1092 4
a1095 5

		/* Wooo.  Magic values. */
		bus_space_write_4(t, h, CAS_MAC_IPG0, 0);
		bus_space_write_4(t, h, CAS_MAC_IPG1, 8);
		bus_space_write_4(t, h, CAS_MAC_IPG2, 4);
d1102 2
a1103 2
		bus_space_write_4(t, h, CAS_MAC_PREAMBLE_LEN, 0x7);
		bus_space_write_4(t, h, CAS_MAC_JAM_SIZE, 0x4);
a1104 1
		/* Dunno.... */
@


1.27
log
@Use pci_mapreg_map() to map ROM.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.26 2009/06/13 12:18:57 kettenis Exp $	*/
d128 1
a128 1
void		cas_setladrf(struct cas_softc *);
d985 1
a985 1
	cas_setladrf(sc);
d1721 1
a1721 1
			cas_setladrf(sc);
a1738 3
/*
 * Set up the logical address filter.
 */
d1740 1
a1740 1
cas_setladrf(struct cas_softc *sc)
d1743 1
a1745 1
	struct arpcom *ac = &sc->sc_arpcom;
d1748 1
a1748 1
	u_int32_t crc, hash[16], v;
d1751 2
a1752 10
	/* Get current RX configuration */
	v = bus_space_read_4(t, h, CAS_MAC_RX_CONFIG);


	/*
	 * Turn off promiscuous mode, promiscuous group mode (all multicast),
	 * and hash filter.  Depending on the case, the right bit will be
	 * enabled.
	 */
	v &= ~(CAS_MAC_RX_PROMISCUOUS|CAS_MAC_RX_HASH_FILTER|
d1754 1
d1756 1
a1756 3
	if ((ifp->if_flags & IFF_PROMISC) != 0) {
		/* Turn on promiscuous mode */
		v |= CAS_MAC_RX_PROMISCUOUS;
d1758 13
a1770 2
		goto chipit;
	}
d1772 1
a1772 7
	/*
	 * Set up multicast address filter by passing all multicast addresses
	 * through a crc generator, and then using the high order 8 bits as an
	 * index into the 256 bit logical address filter.  The high order 4
	 * bits selects the word, while the other 4 bits select the bit within
	 * the word (where bit 0 is the MSB).
	 */
d1774 3
a1776 3
	/* Clear hash table */
	for (i = 0; i < 16; i++)
		hash[i] = 0;
d1778 4
d1783 2
a1784 16
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			/*
			 * We must listen to a range of multicast addresses.
			 * For now, just accept all multicasts, rather than
			 * trying to set only those filter bits needed to match
			 * the range.  (At this time, the only use of address
			 * ranges is for IP multicast routing, for which the
			 * range is big enough to require all bits set.)
			 * XXX use the addr filter for this
			 */
			ifp->if_flags |= IFF_ALLMULTI;
			v |= CAS_MAC_RX_PROMISC_GRP;
			goto chipit;
		}
d1786 2
a1787 1
		crc = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN);
d1789 2
a1790 2
		/* Just want the 8 most significant bits. */
		crc >>= 24;
d1792 6
a1797 14
		/* Set the corresponding bit in the filter. */
		hash[crc >> 4] |= 1 << (15 - (crc & 15));

		ETHER_NEXT_MULTI(step, enm);
	}

	v |= CAS_MAC_RX_HASH_FILTER;
	ifp->if_flags &= ~IFF_ALLMULTI;

	/* Now load the hash table into the chip (if we are using it) */
	for (i = 0; i < 16; i++) {
		bus_space_write_4(t, h,
		    CAS_MAC_HASH0 + i * (CAS_MAC_HASH1-CAS_MAC_HASH0),
		    hash[i]);
d1800 1
a1800 2
chipit:
	bus_space_write_4(t, h, CAS_MAC_RX_CONFIG, v);
@


1.26
log
@Simplify ioctl handling.  From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.25 2009/03/29 21:53:52 sthen Exp $	*/
d192 1
a192 1
	bus_size_t romsize;
d194 1
a194 1
	pcireg_t address, mask;
d198 4
a202 2
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROM_REG, 0xfffffffe);
	mask = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_ROM_REG);
a204 7

	romt = pa->pa_memt;
	romsize = PCI_ROM_SIZE(mask);
	if (bus_space_map(romt, PCI_ROM_ADDR(address), romsize, 0, &romh)) {
		romsize = 0;
		goto fail;
	}
@


1.25
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.24 2008/11/28 02:44:17 brad Exp $	*/
d1702 4
a1705 8
			if ((ifp->if_flags & IFF_RUNNING) &&
			    ((ifp->if_flags ^ sc->sc_if_flags) &
			     (IFF_ALLMULTI | IFF_PROMISC)) != 0)
				cas_setladrf(sc);
			else {
				if ((ifp->if_flags & IFF_RUNNING) == 0)
					cas_init(ifp);
			}
a1709 2
		sc->sc_if_flags = ifp->if_flags;

@


1.24
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.23 2008/10/14 18:01:53 naddy Exp $	*/
d322 1
a322 1
		printf(": could not map registers\n");
@


1.23
log
@Change m_devget()'s outdated and unused "offset" argument:  It is
now the offset into the first mbuf of the target chain before copying
the source data over.  From FreeBSD.

Convert drivers' use of m_devget().  Mostly from thib@@.

Update mbuf(9) man page.

ok claudio@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.22 2008/10/02 20:21:14 brad Exp $	*/
a1720 25
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
			error = EINVAL;
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
			ifp->if_mtu = ifr->ifr_mtu;
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				cas_setladrf(sc);
			error = 0;
		}
		break;

d1728 6
@


1.22
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.21 2008/09/10 14:01:22 blambert Exp $	*/
d1208 2
a1209 2
			cp = rxs->rxs_kva + off * 256;
			m = m_devget(cp, len + ETHER_ALIGN, 0, ifp, NULL);
a1214 1
				m_adj(m, ETHER_ALIGN);
d1244 2
a1245 2
			cp = rxs->rxs_kva + off;
			m = m_devget(cp, len + ETHER_ALIGN, 0, ifp, NULL);
a1250 2
				m_adj(m, ETHER_ALIGN);

@


1.21
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.20 2008/08/30 07:39:12 brad Exp $	*/
a1691 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

a1692 1

d1755 1
a1755 2
		error = ENOTTY;
		break;
@


1.20
log
@Fix an issue initially reported by drahn@@ with gem(4) where these
drivers can report 2-3x times the number of actual packets being
transmitted by only incrementing the counter for descriptors with
buffers being freed.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.19 2008/05/31 22:49:03 kettenis Exp $	*/
d664 1
a664 1
	timeout_add(&sc->sc_tick_ch, hz);
d1077 1
a1077 1
	timeout_add(&sc->sc_tick_ch, hz);
@


1.19
log
@Apparently the interrupt status register doesn't always replicate the TX
completion register correctly, so read the completion register instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.18 2008/05/31 17:03:52 kettenis Exp $	*/
d1940 1
a1942 1
		ifp->if_opackets++;
@


1.18
log
@Turn the rx descriptor ring into a real ring instead of letting things fall
off the end.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.17 2008/05/31 02:44:11 brad Exp $	*/
d1928 1
a1928 1
	u_int32_t cons, hwcons;
d1930 1
a1930 1
	hwcons = status >> 19;
d1932 1
a1932 1
	while (cons != hwcons) {
@


1.17
log
@Properly set the IFF_OACTIVE flag if all the descriptrs are in use for
the TX ring and clear the flag when some have been freed.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.16 2008/04/08 23:41:56 brad Exp $	*/
d1311 3
a1313 1
	sc->sc_rxdptr++;
@


1.16
log
@- Count excess and late collisions as output errors.
- Count receive errors as input errors.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.15 2008/04/02 22:26:16 kettenis Exp $	*/
d1946 2
a1947 2
	cas_start(ifp);

d1951 2
d1986 1
a1986 1
			ifp->if_timer = 2;
@


1.15
log
@Add support for the National Semiconductor Saturn (which really is a Sun
Cassini MAC integrated with a National Semiconductor DP83865 PHY).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.14 2008/02/08 10:56:41 thib Exp $	*/
d633 1
d636 3
a638 1
	ifp->if_collisions +=
d640 9
a648 3
	    bus_space_read_4(t, mac, CAS_MAC_FIRST_COLL_CNT) +
	    bus_space_read_4(t, mac, CAS_MAC_EXCESS_COLL_CNT) +
	    bus_space_read_4(t, mac, CAS_MAC_LATE_COLL_CNT);
d655 4
@


1.14
log
@Return ENOTTY not EINVAL for unsupported ioctl's;

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.13 2008/01/17 21:27:02 kettenis Exp $	*/
d155 2
a156 1
	{ PCI_VENDOR_SUN, PCI_PRODUCT_SUN_CASSINI }
@


1.13
log
@Remove some #if;ed out code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.12 2007/11/26 17:15:32 kettenis Exp $	*/
d1745 1
a1745 1
		error = EINVAL;
@


1.12
log
@Make Cassini+ work; remove some unused macros while I'm there.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.11 2007/11/26 15:55:59 kettenis Exp $	*/
a1485 10
#if 0
	/* Select the desired PHY in the MIF configuration register */
	v = bus_space_read_4(t, mif, CAS_MIF_CONFIG);
	/* Clear PHY select bit */
	v &= ~CAS_MIF_CONFIG_PHY_SEL;
	if (phy == CAS_PHYAD_EXTERNAL)
		/* Set PHY select bit to get at external device */
		v |= CAS_MIF_CONFIG_PHY_SEL;
	bus_space_write_4(t, mif, CAS_MIF_CONFIG, v);
#endif
@


1.11
log
@Avoid resetting PCS.  Don't do loopback at the serial link.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.10 2007/11/26 15:36:22 kettenis Exp $	*/
d35 8
d315 1
d424 2
a940 1

d994 8
d1028 2
d1059 2
@


1.10
log
@Reenable the PCS functions after a reset; properly disable them while changing
the advertisement register.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.9 2007/10/06 14:50:22 jsg Exp $	*/
a525 4
		    CAS_MII_SLINK_CONTROL,
		    CAS_MII_SLINK_LOOPBACK|CAS_MII_SLINK_EN_SYNC_D);

		bus_space_write_4(sc->sc_memt, sc->sc_memh,
d671 2
a672 1
	bus_space_write_4(t, h, CAS_RESET, CAS_RESET_RX|CAS_RESET_TX);
@


1.9
log
@NPBFILTER -> NBPFILTER in comments.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.8 2007/04/18 21:08:35 kettenis Exp $	*/
d1587 1
d1598 3
d1603 1
d1621 4
a1624 3
	if (reg == CAS_MII_ANAR) {
		bus_space_write_4(t, pcs, CAS_MII_SLINK_CONTROL,
		    CAS_MII_SLINK_LOOPBACK|CAS_MII_SLINK_EN_SYNC_D);
a1626 1
	}
@


1.8
log
@Pass arguments to DPRINTF in the right order.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.7 2007/04/15 19:57:16 kettenis Exp $	*/
d1191 1
a1191 1
#endif /* NPBFILTER > 0 */
d1228 1
a1228 1
#endif /* NPBFILTER > 0 */
@


1.7
log
@Make code that fetches the MAC address from PCI ROM actually work.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.6 2007/04/15 16:31:30 kettenis Exp $	*/
d1170 1
a1170 1
			    idx, len, off));
@


1.6
log
@Give this code a chance to work on platforms where the page size isn't 8k.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.5 2007/04/11 21:39:14 kettenis Exp $	*/
d179 1
d184 1
a184 1
	u_int8_t buf[32];
d186 1
a186 1
	int dataoff, vpdoff;
d219 1
d221 56
d278 1
a278 7
	/*
	 * The VPD is not in PCI 2.2 standard format.  The length in
	 * the resource header is big endian.
	 */
	vpd = (struct pci_vpd *)(buf + 3);
	if (!PCI_VPDRES_ISLARGE(buf[0]) ||
	    PCI_VPDRES_LARGE_NAME(buf[0]) != PCI_VPDRES_TYPE_VPD)
d280 1
a280 5
	if (vpd->vpd_key0 != 'N' || vpd->vpd_key1 != 'A')
		goto fail;

	bcopy(buf + 6, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
	rv = 0;
@


1.5
log
@Check return value from m_devget().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.4 2007/02/27 21:19:40 kettenis Exp $	*/
d335 1
a335 1
	    sizeof(struct cas_control_data), PAGE_SIZE, 0, &sc->sc_cdseg,
d375 2
a376 2
		if ((error = bus_dmamem_alloc(sc->sc_dmatag, PAGE_SIZE,
		    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
d384 1
a384 1
		    PAGE_SIZE, &kva, BUS_DMA_NOWAIT)) != 0) {
d391 2
a392 2
		if ((error = bus_dmamap_create(sc->sc_dmatag, PAGE_SIZE, 1,
		    PAGE_SIZE, 0, 0, &sc->sc_rxsoft[i].rxs_dmamap)) != 0) {
d399 1
a399 1
		   sc->sc_rxsoft[i].rxs_dmamap, kva, PAGE_SIZE, NULL,
@


1.4
log
@Cut away some dead wood.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.3 2007/02/26 21:48:32 kettenis Exp $	*/
d1129 1
a1129 2
			m_adj(m, ETHER_ALIGN);

d1133 3
d1137 6
a1142 6
			/*
			 * Pass this up to any BPF listeners, but only
			 * pass it up the stack if its for us.
			 */
			if (ifp->if_bpf)
				bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
d1145 4
a1148 2
			ifp->if_ipackets++;
			ether_input_mbuf(ifp, m);
a1165 1
			m_adj(m, ETHER_ALIGN);
d1170 3
d1174 6
a1179 6
			/*
			 * Pass this up to any BPF listeners, but only
			 * pass it up the stack if its for us.
			 */
			if (ifp->if_bpf)
				bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
d1182 4
a1185 2
			ifp->if_ipackets++;
			ether_input_mbuf(ifp, m);
@


1.3
log
@An ethernet driver works much better if you program the Tx descriptor ring
size in the right bits of the appropriate register.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.2 2007/02/25 21:54:52 kettenis Exp $	*/
d98 1
a132 1
struct mbuf	*cas_get(struct cas_softc *, int, int);
d137 1
a397 1

a404 1
		sc->sc_rxsoft[i].rxs_mbuf = NULL;
d642 1
a642 13
	struct cas_rxsoft *rxs;
	int i;

	for (i = 0; i < CAS_NRXDESC; i++) {
		rxs = &sc->sc_rxsoft[i];
		if (rxs->rxs_mbuf != NULL) {
			bus_dmamap_sync(sc->sc_dmatag, rxs->rxs_dmamap, 0,
			    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->sc_dmatag, rxs->rxs_dmamap);
			m_freem(rxs->rxs_mbuf);
			rxs->rxs_mbuf = NULL;
		}
	}
@


1.2
log
@Make receiving packets work.  Driver works well enough to do the commit over.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cas.c,v 1.1 2007/02/24 20:13:34 kettenis Exp $	*/
d969 1
a969 1
	v = cas_ringsize(CAS_NTXDESC /*XXX*/) << 13;
@


1.1
log
@Start of a driver for Sun Cassini gigabit ethernet interfaces.  Driver can
send packets but not receive any yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d5 1
d107 1
d370 22
a391 2
		if ((error = bus_dmamap_create(sc->sc_dmatag, MCLBYTES, 1,
		    MCLBYTES, 0, 0, &sc->sc_rxsoft[i].rxs_dmamap)) != 0) {
d396 9
d407 1
d432 1
a432 2
	sc->sc_rxfifosize = 64 *
	    bus_space_read_4(sc->sc_memt, sc->sc_memh, CAS_RX_FIFO_SIZE);
a522 22
#if 0
		/*
		 * Now select and activate the PHY we will use.
		 *
		 * The order of preference is External (MDI1),
		 * Internal (MDI0), Serial Link (no MII).
		 */
		if (sc->sc_phys[1]) {
#ifdef CAS_DEBUG
			printf("using external phy\n");
#endif
			sc->sc_mif_config |= CAS_MIF_CONFIG_PHY_SEL;
		} else {
#ifdef CAS_DEBUG
			printf("using internal phy\n");
#endif
			sc->sc_mif_config &= ~CAS_MIF_CONFIG_PHY_SEL;
		}
		bus_space_write_4(sc->sc_memt, sc->sc_memh, CAS_MIF_CONFIG, 
			sc->sc_mif_config);
#endif

d814 2
d820 2
a821 2
		sc->sc_txdescs[i].gd_flags = 0;
		sc->sc_txdescs[i].gd_addr = 0;
d830 15
a844 16
	for (i = 0; i < CAS_NRXDESC; i++) {
		rxs = &sc->sc_rxsoft[i];
		if (rxs->rxs_mbuf == NULL) {
			if ((error = cas_add_rxbuf(sc, i)) != 0) {
				printf("%s: unable to allocate or map rx "
				    "buffer %d, error = %d\n",
				    sc->sc_dev.dv_xname, i, error);
				/*
				 * XXX Should attempt to run with fewer receive
				 * XXX buffers instead of just failing.
				 */
				cas_rxdrain(sc);
				return (1);
			}
		} else
			CAS_INIT_RXDESC(sc, i);
a845 1
	sc->sc_rxptr = 0;
d878 13
d937 2
a938 1
	bus_space_write_4(t, h, CAS_TX_RING_PTR_HI, 
d942 2
a943 1
	bus_space_write_4(t, h, CAS_RX_RING_PTR_HI, 
d945 6
a950 1
	bus_space_write_4(t, h, CAS_RX_RING_PTR_LO, CAS_CDRXADDR(sc, 0));
d954 2
a955 2
		      ~(CAS_INTR_TX_INTME|
			CAS_INTR_TX_EMPTY|
d957 2
a958 1
			CAS_INTR_RX_TAG_ERR|CAS_INTR_PCS|
d963 1
a963 1
	bus_space_write_4(t, h, CAS_MAC_TX_MASK, 0 /*CAS_MAC_TX_XMIT_DONE*/);
d976 5
a980 2
	/* Encode Receive Descriptor ring size: four possible values */
	v = cas_ringsize(CAS_NRXDESC /*XXX*/) << 1;
d983 3
a985 4
	bus_space_write_4(t, h, CAS_RX_CONFIG, 
		v|(CAS_THRSH_1024<<CAS_RX_CONFIG_FIFO_THRS_SHIFT)|
		(2<<CAS_RX_CONFIG_FBOFF_SHFT)|CAS_RX_CONFIG_RXDMA_EN|
		(0<<CAS_RX_CONFIG_CXM_START_SHFT));
a1107 1
	struct ether_header *eh;
d1110 8
a1117 2
	u_int64_t rxstat;
	int i, len;
d1119 20
a1138 2
	for (i = sc->sc_rxptr;; i = CAS_NEXTRX(i)) {
		rxs = &sc->sc_rxsoft[i];
d1140 3
a1142 2
		CAS_CDRXSYNC(sc, i,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
d1144 2
a1145 1
		rxstat = CAS_DMA_READ(sc, sc->sc_rxdescs[i].gd_flags);
d1147 1
a1147 1
		if (rxstat & CAS_RD_OWN) {
d1149 2
a1150 1
			 * We have processed all of the receive buffers.
d1152 3
a1154 2
			break;
		}
d1156 2
a1157 7
		if (rxstat & CAS_RD_BAD_CRC) {
#ifdef CAS_DEBUG
			printf("%s: receive error: CRC error\n",
				sc->sc_dev.dv_xname);
#endif
			CAS_INIT_RXDESC(sc, i);
			continue;
d1160 5
a1164 11
		bus_dmamap_sync(sc->sc_dmatag, rxs->rxs_dmamap, 0,
		    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
#ifdef CAS_DEBUG
		if (ifp->if_flags & IFF_DEBUG) {
			printf("    rxsoft %p descriptor %d: ", rxs, i);
			printf("gd_flags: 0x%016llx\t", (long long)
				CAS_DMA_READ(sc, sc->sc_rxdescs[i].gd_flags));
			printf("gd_addr: 0x%016llx\n", (long long)
				CAS_DMA_READ(sc, sc->sc_rxdescs[i].gd_addr));
		}
#endif
d1166 2
a1167 2
		/* No errors; receive the packet. */
		len = CAS_RD_BUFLEN(rxstat);
a1168 9
		/*
		 * Allocate a new mbuf cluster.  If that fails, we are
		 * out of memory, and must drop the packet and recycle
		 * the buffer that's already attached to this descriptor.
		 */
		m = rxs->rxs_mbuf;
		if (cas_add_rxbuf(sc, i) != 0) {
			ifp->if_ierrors++;
			CAS_INIT_RXDESC(sc, i);
d1170 6
a1175 4
			    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);
			continue;
		}
		m->m_data += 2; /* We're already off by two */
d1177 2
a1178 4
		ifp->if_ipackets++;
		eh = mtod(m, struct ether_header *);
		m->m_pkthdr.rcvif = ifp;
		m->m_pkthdr.len = m->m_len = len;
d1181 6
a1186 6
		/*
		 * Pass this up to any BPF listeners, but only
		 * pass it up the stack if its for us.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
d1189 20
a1208 2
		/* Pass it on. */
		ether_input_mbuf(ifp, m);
d1211 1
a1211 3
	/* Update the receive pointer. */
	sc->sc_rxptr = i;
	bus_space_write_4(t, h, CAS_RX_KICK, i);
a1218 1

d1227 2
a1228 21
	struct cas_rxsoft *rxs = &sc->sc_rxsoft[idx];
	struct mbuf *m;
	int error;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (ENOBUFS);

	MCLGET(m, M_DONTWAIT);
	if ((m->m_flags & M_EXT) == 0) {
		m_freem(m);
		return (ENOBUFS);
	}

#ifdef CAS_DEBUG
/* bzero the packet to check dma */
	memset(m->m_ext.ext_buf, 0, m->m_ext.ext_size);
#endif

	if (rxs->rxs_mbuf != NULL)
		bus_dmamap_unload(sc->sc_dmatag, rxs->rxs_dmamap);
d1230 1
a1230 10
	rxs->rxs_mbuf = m;

	error = bus_dmamap_load(sc->sc_dmatag, rxs->rxs_dmamap,
	    m->m_ext.ext_buf, m->m_ext.ext_size, NULL,
	    BUS_DMA_READ|BUS_DMA_NOWAIT);
	if (error) {
		printf("%s: can't load rx DMA map %d, error = %d\n",
		    sc->sc_dev.dv_xname, idx, error);
		panic("cas_add_rxbuf");	/* XXX */
	}
d1232 2
a1233 4
	bus_dmamap_sync(sc->sc_dmatag, rxs->rxs_dmamap, 0,
	    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);

	CAS_INIT_RXDESC(sc, idx);
d1235 1
a1238 1

d1286 2
a1287 1
	if ((status & (CAS_INTR_RX_TAG_ERR | CAS_INTR_BERR)) != 0)
a1387 1
#if 0
a1391 1
#endif
a1417 1
#if 0
a1422 1
#endif
a1481 5
#if 0
	/* If an external transceiver is connected, enable its MII drivers */
	sc->sc_mif_config = bus_space_read_4(t, mac, CAS_MIF_CONFIG);
#endif

d1819 2
a1820 2
		sc->sc_txdescs[frag].gd_addr =
		    CAS_DMA_WRITE(sc, map->dm_segs[i].ds_addr);
d1824 1
a1824 1
		sc->sc_txdescs[frag].gd_flags = CAS_DMA_WRITE(sc, flags);
@

