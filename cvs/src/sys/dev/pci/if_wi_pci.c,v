head	1.52;
access;
symbols
	OPENBSD_6_1:1.52.0.8
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.52.0.6
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.51.0.6
	OPENBSD_5_8_BASE:1.51
	OPENBSD_5_7:1.51.0.4
	OPENBSD_5_7_BASE:1.51
	OPENBSD_5_6:1.50.0.6
	OPENBSD_5_6_BASE:1.50
	OPENBSD_5_5:1.50.0.4
	OPENBSD_5_5_BASE:1.50
	OPENBSD_5_4:1.48.0.12
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.48.0.10
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.48.0.8
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.6
	OPENBSD_5_0:1.48.0.4
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.48.0.2
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.45.0.2
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.44.0.4
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.43.0.10
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.43.0.8
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.43.0.6
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.43.0.4
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.43.0.2
	OPENBSD_4_1_BASE:1.43
	OPENBSD_4_0:1.42.0.4
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.42.0.2
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.40.0.4
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.36.0.4
	OPENBSD_3_6_BASE:1.36
	SMP_SYNC_A:1.36
	SMP_SYNC_B:1.36
	OPENBSD_3_5:1.36.0.2
	OPENBSD_3_5_BASE:1.36
	OPENBSD_3_4:1.35.0.2
	OPENBSD_3_4_BASE:1.35
	UBC_SYNC_A:1.33
	OPENBSD_3_3:1.32.0.2
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	UBC_SYNC_B:1.30
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	SMP:1.5.0.2;
locks; strict;
comment	@ * @;


1.52
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.51;
commitid	5gdEnqVoJuTuwdTu;

1.51
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.50;
commitid	yM2VFFhpDTeFQlve;

1.50
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2013.11.14.12.33.15;	author dlg;	state Exp;
branches;
next	1.48;

1.48
date	2010.09.07.16.21.45;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2010.08.30.20.42.54;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2010.08.27.18.29.44;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2010.08.04.16.29.42;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.43;

1.43
date	2006.11.26.19.46.28;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2005.10.31.05.37.13;	author jsg;	state Exp;
branches;
next	1.41;

1.41
date	2005.09.11.18.17.08;	author mickey;	state Exp;
branches;
next	1.40;

1.40
date	2004.12.08.15.40.40;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2004.11.23.21.12.23;	author fgsch;	state Exp;
branches;
next	1.38;

1.38
date	2004.10.20.13.19.53;	author jsg;	state Exp;
branches;
next	1.37;

1.37
date	2004.10.20.12.53.29;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2003.10.26.15.34.15;	author drahn;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.17.21.56.25;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.03.01.52.41;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2003.04.10.17.07.15;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2003.01.31.21.19.03;	author jason;	state Exp;
branches;
next	1.31;

1.31
date	2003.01.10.22.10.19;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.09.12.03.48.31;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.07.29.19.24.24;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.10.19.29.15;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.09.11.00.27;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2002.04.15.21.19.52;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.10.18.25.16;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.04.09.01.27.06;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.04.06.21.58.12;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.04.06.20.31.56;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.04.03.22.49.56;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.01.05.49.57;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.01.05.40.21;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.30.21.57.40;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.27.22.01.16;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.26.20.42.51;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.26.16.38.16;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.28.21.42.40;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.20.17.48.25;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.20.17.41.48;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.20.17.39.50;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.25.19.40.14;	author mickey;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.10.24.17.33.44;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.06.17.22.07;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.23.01.54.48;	author millert;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.06.12.15.40.31;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.11.00.50.38;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.07.04.55.06;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.06.18.53.50;	author millert;	state Exp;
branches;
next	;

1.5.2.1
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.03.06.02.11.46;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2003.05.13.19.35.06;	author ho;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2003.06.07.11.02.30;	author ho;	state Exp;
branches;
next	1.5.2.7;

1.5.2.7
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.01.31.22.55.35;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.06.11.03.42.26;	author art;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2003.05.19.22.18.01;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.52
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_wi_pci.c,v 1.51 2014/12/22 02:28:52 tedu Exp $	*/

/*
 * Copyright (c) 2001-2003 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

/*
 * PCI attachment for the Wavelan driver.  There are two basic types
 * of PCI card supported:
 *
 * 1) Cards based on the Prism2.5 Mini-PCI chipset
 * 2) Cards that use a dumb PCMCIA->PCI bridge
 *
 * Only the first type are "true" PCI cards.
 *
 * The latter are simply PCMCIA cards (or the guts of same) with some
 * type of dumb PCMCIA->PCI bridge.  They are "dumb" in that they
 * are not true PCMCIA bridges and really just serve to deal with
 * the different interrupt types and timings of the ISA vs. PCI bus.
 *
 * The following bridge types are supported:
 *  o PLX 9052 (the most common)
 *  o TMD 7160 (found in some NDC/Sohoware NCP130 cards)
 *  o ACEX EP1K30 (really a PLD, found in Symbol cards and their OEMs)
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/socket.h>
#include <sys/tree.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_ioctl.h>

#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/ic/if_wireg.h>
#include <dev/ic/if_wi_ieee.h>
#include <dev/ic/if_wivar.h>

/* For printing CIS of the actual PCMCIA card */
#define CIS_MFG_NAME_OFFSET	0x16
#define CIS_INFO_SIZE		256

const struct wi_pci_product *wi_pci_lookup(struct pci_attach_args *pa);
int	wi_pci_match(struct device *, void *, void *);
void	wi_pci_attach(struct device *, struct device *, void *);
int	wi_pci_activate(struct device *, int);
void	wi_pci_wakeup(struct wi_softc *);
int	wi_pci_acex_attach(struct pci_attach_args *pa, struct wi_softc *sc);
int	wi_pci_plx_attach(struct pci_attach_args *pa, struct wi_softc *sc);
int	wi_pci_tmd_attach(struct pci_attach_args *pa, struct wi_softc *sc);
int	wi_pci_native_attach(struct pci_attach_args *pa, struct wi_softc *sc);
int	wi_pci_common_attach(struct pci_attach_args *pa, struct wi_softc *sc);
void	wi_pci_plx_print_cis(struct wi_softc *);

struct wi_pci_softc {
	struct wi_softc		 sc_wi;		/* real softc */
};

struct cfattach wi_pci_ca = {
	sizeof (struct wi_pci_softc), wi_pci_match, wi_pci_attach, NULL,
	wi_pci_activate
};

static const struct wi_pci_product {
	pci_vendor_id_t pp_vendor;
	pci_product_id_t pp_product;
	int (*pp_attach)(struct pci_attach_args *pa, struct wi_softc *sc);
} wi_pci_products[] = {
	{ PCI_VENDOR_GLOBALSUN, PCI_PRODUCT_GLOBALSUN_GL24110P, wi_pci_plx_attach },
	{ PCI_VENDOR_GLOBALSUN, PCI_PRODUCT_GLOBALSUN_GL24110P02, wi_pci_plx_attach },
	{ PCI_VENDOR_GLOBALSUN, PCI_PRODUCT_GLOBALSUN_GL24110P03, wi_pci_plx_attach },
	{ PCI_VENDOR_GLOBALSUN, PCI_PRODUCT_GLOBALSUN_8031, wi_pci_plx_attach },
	{ PCI_VENDOR_EUMITCOM, PCI_PRODUCT_EUMITCOM_WL11000P, wi_pci_plx_attach },
	{ PCI_VENDOR_USR2, PCI_PRODUCT_USR2_WL11000P, wi_pci_plx_attach },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CRWE777A, wi_pci_plx_attach },
	{ PCI_VENDOR_NETGEAR, PCI_PRODUCT_NETGEAR_MA301, wi_pci_plx_attach },
	{ PCI_VENDOR_EFFICIENTNETS, PCI_PRODUCT_EFFICIENTNETS_SS1023, wi_pci_plx_attach },
	{ PCI_VENDOR_ADDTRON, PCI_PRODUCT_ADDTRON_AWA100, wi_pci_plx_attach },
	{ PCI_VENDOR_BELKIN, PCI_PRODUCT_BELKIN_F5D6000, wi_pci_plx_attach },
	{ PCI_VENDOR_NDC, PCI_PRODUCT_NDC_NCP130, wi_pci_plx_attach },
	{ PCI_VENDOR_NDC, PCI_PRODUCT_NDC_NCP130A2, wi_pci_tmd_attach },
	{ PCI_VENDOR_INTERSIL, PCI_PRODUCT_INTERSIL_MINI_PCI_WLAN, wi_pci_native_attach },
	{ PCI_VENDOR_INTERSIL, PCI_PRODUCT_INTERSIL_ISL3872, wi_pci_native_attach },
	{ PCI_VENDOR_SAMSUNG, PCI_PRODUCT_SAMSUNG_SWL2210P, wi_pci_native_attach },
	{ PCI_VENDOR_NORTEL, PCI_PRODUCT_NORTEL_211818A, wi_pci_acex_attach },
	{ PCI_VENDOR_SYMBOL, PCI_PRODUCT_SYMBOL_LA41X3, wi_pci_acex_attach },
	{ 0, 0, 0 }
};

const struct wi_pci_product *
wi_pci_lookup(struct pci_attach_args *pa)
{
	const struct wi_pci_product *pp;

	for (pp = wi_pci_products; pp->pp_product != 0; pp++) {
		if (PCI_VENDOR(pa->pa_id) == pp->pp_vendor && 
		    PCI_PRODUCT(pa->pa_id) == pp->pp_product)
			return (pp);
	}

	return (NULL);
}

int
wi_pci_match(struct device *parent, void *match, void *aux)
{
	return (wi_pci_lookup(aux) != NULL);
}

void
wi_pci_attach(struct device *parent, struct device *self, void *aux)
{
	struct wi_softc *sc = (struct wi_softc *)self;
	struct pci_attach_args *pa = aux;
	const struct wi_pci_product *pp;

	pp = wi_pci_lookup(pa);
	if (pp->pp_attach(pa, sc) != 0)
		return;
	printf("\n");
	wi_attach(sc, &wi_func_io);
}

int
wi_pci_activate(struct device *self, int act)
{
	struct wi_softc *sc = (struct wi_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			wi_stop(sc);
		break;
	case DVACT_WAKEUP:
		if (ifp->if_flags & IFF_UP)
			wi_pci_wakeup(sc);
		break;
	}
	return (0);
}

void
wi_pci_wakeup(struct wi_softc *sc)
{
	int s;

	s = splnet();
	while (sc->wi_flags & WI_FLAGS_BUSY)
		tsleep(&sc->wi_flags, 0, "wipwr", 0);
	sc->wi_flags |= WI_FLAGS_BUSY;

	wi_init(sc);

	sc->wi_flags &= ~WI_FLAGS_BUSY;
	wakeup(&sc->wi_flags);
	splx(s);
}

/*
 * ACEX EP1K30-based PCMCIA->PCI bridge attachment.
 *
 * The ACEX EP1K30 is a programmable logic device (PLD) used as a
 * PCMCIA->PCI bridge on the Symbol LA4123 and its OEM equivalents
 * (such as the Nortel E-mobility 211818-A).  There are 3 I/O ports:
 * BAR0 at 0x10 appears to be a command port.
 * BAR1 at 0x14 contains COR at offset 0xe0.
 * BAR2 at 0x18 maps the actual PCMCIA card.
 *
 * The datasheet for the ACEX EP1K30 is available from Altera but that
 * doesn't really help much since we don't know how it is programmed.
 * Details for this attachment were gleaned from a version of the
 * Linux orinoco driver modified by Tobias Hoffmann based on
 * what he discoverd from the Windows driver.
 */
int
wi_pci_acex_attach(struct pci_attach_args *pa, struct wi_softc *sc)
{
	bus_space_handle_t commandh, localh, ioh;
	bus_space_tag_t commandt, localt;
	bus_space_tag_t iot = pa->pa_iot;
	bus_size_t commandsize, localsize, iosize;
	int i;

	if (pci_mapreg_map(pa, WI_ACEX_CMDRES, PCI_MAPREG_TYPE_IO,
	    0, &commandt, &commandh, NULL, &commandsize, 0) != 0) {
		printf(": can't map command i/o space\n");
		return (ENXIO);
	}

	if (pci_mapreg_map(pa, WI_ACEX_LOCALRES, PCI_MAPREG_TYPE_IO,
	    0, &localt, &localh, NULL, &localsize, 0) != 0) {
		printf(": can't map local i/o space\n");
		bus_space_unmap(commandt, commandh, commandsize);
		return (ENXIO);
	}
	sc->wi_ltag = localt;
	sc->wi_lhandle = localh;

	if (pci_mapreg_map(pa, WI_TMD_IORES, PCI_MAPREG_TYPE_IO,
	    0, &iot, &ioh, NULL, &iosize, 0) != 0) {
		printf(": can't map i/o space\n");
		bus_space_unmap(localt, localh, localsize);
		bus_space_unmap(commandt, commandh, commandsize);
		return (ENXIO);
	}
	sc->wi_btag = iot;
	sc->wi_bhandle = ioh;

	/*
	 * Setup bridge chip.
	 */
	if (bus_space_read_4(commandt, commandh, 0) & 1) {
		printf(": bridge not ready\n");
		bus_space_unmap(iot, ioh, iosize);
		bus_space_unmap(localt, localh, localsize);
		bus_space_unmap(commandt, commandh, commandsize);
		return (ENXIO);
	}
	bus_space_write_4(commandt, commandh, 2, 0x118);
	bus_space_write_4(commandt, commandh, 2, 0x108);
	DELAY(30 * 1000);
	bus_space_write_4(commandt, commandh, 2, 0x8);
	for (i = 0; i < 30; i++) {
		DELAY(30 * 1000);
		if (bus_space_read_4(commandt, commandh, 0) & 0x10)
			break;
	}
	if (i == 30) {
		printf(": bridge timeout\n");
		bus_space_unmap(iot, ioh, iosize);
		bus_space_unmap(localt, localh, localsize);
		bus_space_unmap(commandt, commandh, commandsize);
		return (ENXIO);
	}
	if ((bus_space_read_4(localt, localh, 0xe0) & 1) ||
	    (bus_space_read_4(localt, localh, 0xe2) & 1) ||
	    (bus_space_read_4(localt, localh, 0xe4) & 1)) {
		printf(": failed bridge setup\n");
		bus_space_unmap(iot, ioh, iosize);
		bus_space_unmap(localt, localh, localsize);
		bus_space_unmap(commandt, commandh, commandsize);
		return (ENXIO);
	}

	if (wi_pci_common_attach(pa, sc) != 0) {
		bus_space_unmap(iot, ioh, iosize);
		bus_space_unmap(localt, localh, localsize);
		bus_space_unmap(commandt, commandh, commandsize);
		return (ENXIO);
	}

	/* 
	 * Enable I/O mode and level interrupts on the embedded PCMCIA
	 * card.
	 */
	bus_space_write_1(localt, localh, WI_ACEX_COR_OFFSET, WI_COR_IOMODE);
	sc->wi_cor_offset = WI_ACEX_COR_OFFSET;

	/* Unmap registers we no longer need access to. */
	bus_space_unmap(commandt, commandh, commandsize);

	return (0);
}

/*
 * PLX 9052-based PCMCIA->PCI bridge attachment.
 *
 * These are often sold as "PCI wireless card adapters" and are
 * sold by several vendors.  Most are simply rebadged versions of the
 * Eumitcom WL11000P or Global Sun Technology GL24110P02.
 * These cards use the PLX 9052 dumb bridge chip to connect a PCMCIA
 * wireless card to the PCI bus.  Because it is a dumb bridge and
 * not a true PCMCIA bridge, the PCMCIA subsystem is not involved
 * (or even required).  The PLX 9052 provides multiple PCI address
 * space mappings.  The primary mappings at PCI registers 0x10 (mem)
 * and 0x14 (I/O) are for the PLX chip itself, *NOT* the PCMCIA card.
 * The mem and I/O spaces for the PCMCIA card are mapped to 0x18 and
 * 0x1C respectively.
 * The PLX 9050/9052 datasheet may be downloaded from PLX at
 *	http://www.plxtech.com/products/toolbox/9050.htm
 */
int
wi_pci_plx_attach(struct pci_attach_args *pa, struct wi_softc *sc)
{
	bus_space_handle_t localh, ioh, memh;
	bus_space_tag_t localt;
	bus_space_tag_t iot = pa->pa_iot;
	bus_space_tag_t memt = pa->pa_memt;
	bus_size_t localsize, memsize, iosize;
	u_int32_t intcsr;

	if (pci_mapreg_map(pa, WI_PLX_MEMRES, PCI_MAPREG_TYPE_MEM, 0,
	    &memt, &memh, NULL, &memsize, 0) != 0) {
		printf(": can't map mem space\n");
		return (ENXIO);
	}
	sc->wi_ltag = memt;
	sc->wi_lhandle = memh;

	if (pci_mapreg_map(pa, WI_PLX_IORES,
	    PCI_MAPREG_TYPE_IO, 0, &iot, &ioh, NULL, &iosize, 0) != 0) {
		printf(": can't map i/o space\n");
		bus_space_unmap(memt, memh, memsize);
		return (ENXIO);
	}
	sc->wi_btag = iot;
	sc->wi_bhandle = ioh;

	/*
	 * Some cards, such as the PLX version of the NDC NCP130,
	 * don't have the PLX local registers mapped.  In general
	 * this is OK since on those cards the serial EEPROM has
	 * already set things up for us.
	 * As such, we don't consider an error here to be fatal.
	 */
	localsize = 0;
	if (pci_mapreg_type(pa->pa_pc, pa->pa_tag, WI_PLX_LOCALRES)
	    == PCI_MAPREG_TYPE_IO) {
		if (pci_mapreg_map(pa, WI_PLX_LOCALRES, PCI_MAPREG_TYPE_IO,
		    0, &localt, &localh, NULL, &localsize, 0) != 0)
			printf(": can't map PLX I/O space\n");
	}

	if (wi_pci_common_attach(pa, sc) != 0) {
		if (localsize)
			bus_space_unmap(localt, localh, localsize);
		bus_space_unmap(iot, ioh, iosize);
		bus_space_unmap(memt, memh, memsize);
		return (ENXIO);
	}

	if (localsize != 0) {
		intcsr = bus_space_read_4(localt, localh,
		    WI_PLX_INTCSR);

		/*
		 * The Netgear MA301 has local interrupt 1 active
		 * when there is no card in the adapter.  We bail
		 * early in this case since our attempt to check
		 * for the presence of a card later will hang the
		 * MA301.
		 */
		if (intcsr & WI_PLX_LINT1STAT) {
			printf("\n%s: no PCMCIA card detected in bridge card\n",
			    WI_PRT_ARG(sc));
			pci_intr_disestablish(pa->pa_pc, sc->sc_ih);
			if (localsize)
				bus_space_unmap(localt, localh, localsize);
			bus_space_unmap(iot, ioh, iosize);
			bus_space_unmap(memt, memh, memsize);
			return (ENXIO);
		}

		/*
		 * Enable PCI interrupts on the PLX chip if they are
		 * not already enabled. On most adapters the serial
		 * EEPROM has done this for us but some (such as
		 * the Netgear MA301) do not.
		 */
		if (!(intcsr & WI_PLX_INTEN)) {
			intcsr |= WI_PLX_INTEN;
			bus_space_write_4(localt, localh, WI_PLX_INTCSR,
			    intcsr);
		}
	}

	/*
	 * Enable I/O mode and level interrupts on the PCMCIA card.
	 * The PCMCIA card's COR is the first byte after the CIS.
	 */
	bus_space_write_1(memt, memh, WI_PLX_COR_OFFSET, WI_COR_IOMODE);
	sc->wi_cor_offset = WI_PLX_COR_OFFSET;

	if (localsize != 0) {
		/*
		 * Test the presence of a wi(4) card by writing
		 * a magic number to the first software support
		 * register and then reading it back.
		 */
		CSR_WRITE_2(sc, WI_SW0, WI_DRVR_MAGIC);
		DELAY(1000);
		if (CSR_READ_2(sc, WI_SW0) != WI_DRVR_MAGIC) {
			printf("\n%s: no PCMCIA card detected in bridge card\n",
			    WI_PRT_ARG(sc));
			pci_intr_disestablish(pa->pa_pc, sc->sc_ih);
			if (localsize)
				bus_space_unmap(localt, localh, localsize);
			bus_space_unmap(iot, ioh, iosize);
			bus_space_unmap(memt, memh, memsize);
			return (ENXIO);
		}

		/* Unmap registers we no longer need access to. */
		bus_space_unmap(localt, localh, localsize);

		/* Print PCMCIA card's CIS strings. */
		wi_pci_plx_print_cis(sc);
	}

	return (0);
}

/*
 * TMD 7160-based PCMCIA->PCI bridge attachment.
 *
 * The TMD7160 dumb bridge chip is used on some versions of the
 * NDC/Sohoware NCP130.  The TMD7160 provides two PCI I/O registers.
 * The first, at 0x14, maps to the Prism2 COR.
 * The second, at 0x18, is for the Prism2 chip itself.
 *
 * The datasheet for the TMD7160 does not seem to be publicly available.
 * Details for this attachment were gleaned from a version of the
 * Linux WLAN driver modified by NDC.
 */
int
wi_pci_tmd_attach(struct pci_attach_args *pa, struct wi_softc *sc)
{
	bus_space_handle_t localh, ioh;
	bus_space_tag_t localt;
	bus_space_tag_t iot = pa->pa_iot;
	bus_size_t localsize, iosize;

	if (pci_mapreg_map(pa, WI_TMD_LOCALRES, PCI_MAPREG_TYPE_IO,
	    0, &localt, &localh, NULL, &localsize, 0) != 0) {
		printf(": can't map TMD I/O space\n");
		return (ENXIO);
	}
	sc->wi_ltag = localt;
	sc->wi_lhandle = localh;

	if (pci_mapreg_map(pa, WI_TMD_IORES, PCI_MAPREG_TYPE_IO,
	    0, &iot, &ioh, NULL, &iosize, 0) != 0) {
		printf(": can't map i/o space\n");
		bus_space_unmap(localt, localh, localsize);
		return (ENXIO);
	}
	sc->wi_btag = iot;
	sc->wi_bhandle = ioh;

	if (wi_pci_common_attach(pa, sc) != 0) {
		bus_space_unmap(iot, ioh, iosize);
		bus_space_unmap(localt, localh, localsize);
		return (ENXIO);
	}

	/* 
	 * Enable I/O mode and level interrupts on the embedded PCMCIA
	 * card.  The PCMCIA card's COR is the first byte of BAR 0.
	 */
	bus_space_write_1(localt, localh, 0, WI_COR_IOMODE);
	sc->wi_cor_offset = 0;

	return (0);
}

int
wi_pci_native_attach(struct pci_attach_args *pa, struct wi_softc *sc)
{
	bus_space_handle_t ioh;
	bus_space_tag_t iot = pa->pa_iot;
	bus_size_t iosize;

	if (pci_mapreg_map(pa, WI_PCI_CBMA, PCI_MAPREG_TYPE_MEM,
	    0, &iot, &ioh, NULL, &iosize, 0) != 0) {
		printf(": can't map mem space\n");
		return (ENXIO);
	}
	sc->wi_ltag = iot;
	sc->wi_lhandle = ioh;
	sc->wi_btag = iot;
	sc->wi_bhandle = ioh;
	sc->sc_pci = 1;

	if (wi_pci_common_attach(pa, sc) != 0) {
		bus_space_unmap(iot, ioh, iosize);
		return (ENXIO);
	}

	/* Do a soft reset of the HFA3842 MAC core */
	bus_space_write_2(iot, ioh, WI_PCI_COR_OFFSET, WI_COR_SOFT_RESET);
	DELAY(100*1000); /* 100 m sec */
	bus_space_write_2(iot, ioh, WI_PCI_COR_OFFSET, WI_COR_CLEAR);
	DELAY(100*1000); /* 100 m sec */
	sc->wi_cor_offset = WI_PCI_COR_OFFSET;

	return (0);
}

int
wi_pci_common_attach(struct pci_attach_args *pa, struct wi_softc *sc)
{
	pci_intr_handle_t ih;
	pci_chipset_tag_t pc = pa->pa_pc;
	const char *intrstr;

	/* Make sure interrupts are disabled. */
	CSR_WRITE_2(sc, WI_INT_EN, 0);
	CSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);

	/* Map and establish the interrupt. */
	if (pci_intr_map(pa, &ih)) {
		printf(": couldn't map interrupt\n");
		return (ENXIO);
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, wi_intr, sc,
	    sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return (ENXIO);
	}
	printf(": %s", intrstr);

	return (0);
}

void
wi_pci_plx_print_cis(struct wi_softc *sc)
{
	int i, stringno;
	char cisbuf[CIS_INFO_SIZE];
	char *cis_strings[3];
	u_int8_t value;
	const u_int8_t cis_magic[] = {
		0x01, 0x03, 0x00, 0x00, 0xff, 0x17, 0x04, 0x67
	};

	/* Make sure the CIS data is valid. */
	for (i = 0; i < 8; i++) {
		value = bus_space_read_1(sc->wi_ltag, sc->wi_lhandle, i * 2);
		if (value != cis_magic[i])
			return;
	}

	cis_strings[0] = cisbuf;
	stringno = 0;
	for (i = 0; i < CIS_INFO_SIZE && stringno < 3; i++) {
		cisbuf[i] = bus_space_read_1(sc->wi_ltag,
		    sc->wi_lhandle, (CIS_MFG_NAME_OFFSET + i) * 2);
		if (cisbuf[i] == '\0' && ++stringno < 3)
			cis_strings[stringno] = &cisbuf[i + 1];
	}
	cisbuf[CIS_INFO_SIZE - 1] = '\0';
	printf("\n%s: \"%s, %s, %s\"", WI_PRT_ARG(sc),
	    cis_strings[0], cis_strings[1], cis_strings[2]);
}
@


1.51
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.50 2013/12/06 21:03:04 deraadt Exp $	*/
a50 1
#include <net/if_dl.h>
@


1.50
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.49 2013/11/14 12:33:15 dlg Exp $	*/
a53 1
#ifdef INET
a55 1
#endif
@


1.49
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.48 2010/09/07 16:21:45 deraadt Exp $	*/
a48 1
#include <sys/task.h>
d80 1
a80 1
void	wi_pci_resume(void *arg1, void *arg2);
a89 1
	struct task		 sc_resume_t;
a145 1
	struct wi_pci_softc *psc = (struct wi_pci_softc *)self;
a149 2
	task_set(&psc->sc_resume_t, wi_pci_resume, sc, NULL);

a159 1
	struct wi_pci_softc *psc = (struct wi_pci_softc *)self;
d168 1
a168 1
	case DVACT_RESUME:
d170 1
a170 1
			task_add(systq, &psc->sc_resume_t);
d177 1
a177 1
wi_pci_resume(void *arg1, void *arg2)
a178 2
	struct wi_softc *sc = (struct wi_softc *)arg1;

@


1.48
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.47 2010/08/30 20:42:54 deraadt Exp $	*/
d49 1
a49 1
#include <sys/workq.h>
d91 1
a91 1
	struct workq_task	sc_resume_wqt;
d148 1
d153 2
d176 1
a176 2
			workq_queue_task(NULL, &psc->sc_resume_wqt, 0,
			    wi_pci_resume, sc, NULL);
@


1.47
log
@ioctl versus resume-workq exclusion; cloned from iwn
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.46 2010/08/27 18:29:44 deraadt Exp $	*/
a87 1
void	wi_pci_powerhook(int, void *);
a90 1
	void			*sc_powerhook;
a147 1
	struct wi_pci_softc *psc = (struct wi_pci_softc *)self;
a156 2

	psc->sc_powerhook = powerhook_establish(wi_pci_powerhook, sc);
a196 6
}

void
wi_pci_powerhook(int why, void *arg)
{
	wi_pci_activate(arg, why);
@


1.46
log
@Make the powerhook code simply call the activate function (it actually does
all the 7 steps we want done, instead of just 2)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.45 2010/08/04 16:29:42 deraadt Exp $	*/
d190 7
d198 4
@


1.45
log
@activate function for suspend/resume; tested by mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.44 2009/03/29 21:53:52 sthen Exp $	*/
d88 1
a88 1
void	wi_pci_power(int, void *);
d161 1
a161 1
	psc->sc_powerhook = powerhook_establish(wi_pci_power, sc);
d177 3
a179 2
		workq_queue_task(NULL, &psc->sc_resume_wqt, 0,
		    wi_pci_resume, sc, NULL);
a181 1

d188 3
a190 1
	wi_pci_power(PWR_RESUME, arg1);
d194 1
a194 1
wi_pci_power(int why, void *arg)
d196 1
a196 6
	struct wi_softc *sc = (struct wi_softc *)arg;

	if (why == PWR_RESUME) {
		if (sc->sc_ic.ic_if.if_flags & IFF_UP)
			wi_init(sc);
	}
@


1.44
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.43 2006/11/26 19:46:28 deraadt Exp $	*/
d49 1
d80 2
d93 1
d97 2
a98 1
	sizeof (struct wi_pci_softc), wi_pci_match, wi_pci_attach
d162 27
@


1.43
log
@avoid extra inclusions; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.42 2005/10/31 05:37:13 jsg Exp $	*/
d197 1
a197 1
		printf(": can't map command I/O space\n");
d203 1
a203 1
		printf(": can't map local I/O space\n");
d212 1
a212 1
		printf(": can't map I/O space\n");
d313 1
a313 1
		printf(": can't map I/O space\n");
d444 1
a444 1
		printf(": can't map I/O space\n");
@


1.42
log
@Move from arpcom to ieee80211com in wi softc.  This will be
required for net80211 support.
Updated version of a diff from dlg@@
similiar diff ok fgsch@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.41 2005/09/11 18:17:08 mickey Exp $	*/
d59 1
a59 1
#include <net80211/ieee80211.h>
a60 1
#include <net80211/ieee80211_var.h>
@


1.41
log
@do not inline pci_mapreg_map() anymore as it is olrite now; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.40 2004/12/08 15:40:40 markus Exp $	*/
d48 1
d61 1
a163 1
	struct ifnet *ifp;
d166 1
a166 2
		ifp = &sc->sc_arpcom.ac_if;
		if (ifp->if_flags & IFF_UP)
@


1.40
log
@powerhook: call wi_init on resume
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.39 2004/11/23 21:12:23 fgsch Exp $	*/
a300 1
	bus_addr_t localbase;
d331 3
a333 11
		if (pci_io_find(pa->pa_pc, pa->pa_tag,
		    WI_PLX_LOCALRES, &localbase, &localsize) != 0)
			printf(": can't find PLX I/O space\n");
		if (localsize != 0) {
			if (bus_space_map(pa->pa_iot, localbase,
			    localsize, 0, &localh) != 0) {
				printf(": can't map PLX I/O space\n");
				localsize = 0;
			} else
				localt = pa->pa_iot;
		}
@


1.39
log
@replace old net/if_ieee80211.h header with the net80211 ones, kernel part.
millert@@ mcbride@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.38 2004/10/20 13:19:53 jsg Exp $	*/
d84 6
d92 1
a92 1
	sizeof (struct wi_softc), wi_pci_match, wi_pci_attach
d144 1
d154 15
@


1.38
log
@add some devices found in linux and freebsd drivers
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.37 2004/10/20 12:53:29 deraadt Exp $	*/
d58 2
a59 1
#include <net/if_ieee80211.h>
@


1.37
log
@put newlines at slightly different places during attach, leading to clean
USB attach
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.36 2003/10/26 15:34:15 drahn Exp $	*/
d95 2
d102 2
d107 2
@


1.36
log
@Driver for PRISM 2.5/3 based (wifi) USB adapters. This is a work in progress,
it does not yet handle bulk data copies or hostap mode. Only one model
currently supported, however driver may support other PRISM based adapters.
ok millert@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.35 2003/06/17 21:56:25 millert Exp $	*/
d138 1
@


1.35
log
@Sync with share/misc/license.template and add missing DARPA credit
where applicable.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.34 2003/06/03 01:52:41 millert Exp $	*/
d138 1
a138 1
	wi_attach(sc);
@


1.34
log
@Use an ISC-tyle license for all my code; it is simpler and more permissive.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.33 2003/04/10 17:07:15 mickey Exp $	*/
d10 11
a20 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.33
log
@deallocate resources on failures; pt out by tedu@@; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.32 2003/01/31 21:19:03 jason Exp $	*/
a4 1
 * All rights reserved.
d6 3
a8 10
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.32
log
@These cards just don't master... don't bother trying to enable it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.31 2003/01/10 22:10:19 millert Exp $	*/
d170 1
a170 1
	bus_size_t commandsize;
d180 1
a180 1
	    0, &localt, &localh, NULL, NULL, 0) != 0) {
d182 1
d189 1
a189 1
	    0, &iot, &ioh, NULL, NULL, 0) != 0) {
d191 2
d203 3
d219 3
d228 3
d234 4
a237 1
	if (wi_pci_common_attach(pa, sc) != 0)
d239 1
d279 1
a279 1
	bus_size_t localsize;
d283 1
a283 1
	    &memt, &memh, NULL, NULL, 0) != 0) {
d291 1
a291 1
	    PCI_MAPREG_TYPE_IO, 0, &iot, &ioh, NULL, NULL, 0) != 0) {
d293 1
d322 5
a326 1
	if (wi_pci_common_attach(pa, sc) != 0)
d328 1
d344 5
d383 5
d419 1
a419 1
	bus_size_t localsize;
d430 1
a430 1
	    0, &iot, &ioh, NULL, NULL, 0) != 0) {
d432 1
d438 3
a440 1
	if (wi_pci_common_attach(pa, sc) != 0)
d442 1
d459 1
d462 1
a462 1
	    0, &iot, &ioh, NULL, NULL, 0) != 0) {
d472 2
a473 1
	if (wi_pci_common_attach(pa, sc) != 0)
d475 1
@


1.31
log
@Add support for Symbol LA4123 and Nortel E-mobility 211818-A PCI
cards.  These use an ACEX EP1K30 programmable logic device (PLD)
as the PCMCIA->PCI bridge.  There's no documentation available on
how Symbol has this configured; the magic bits are based on
modifications to the Linux orinoco driver by Tobias Hoffmann.
He, in turn, figured out the magic from the Windows driver.
This does mean we have undocuemnted hex constants; sigh.

I also moved commented bridge chip info to right before the appropriate
bridge attachment.  The massive comment at the top of the file was
becoming illegible.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.30 2002/09/12 03:48:31 millert Exp $	*/
a452 1
	pcireg_t csr;
a453 5

	/* Enable the card. */
	csr = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    csr | PCI_COMMAND_MASTER_ENABLE);
@


1.30
log
@o break up wi_pci_attach() into device-specific parts for better readability
o kludge around a problem with Netgear MA301 hanging when booted w/o a card.
o better card detection w/ PLX adapters
o correct the info in some comments
mickey@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.29 2002/07/29 19:24:24 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 2001, 2002 Todd C. Miller <Todd.Miller@@courtesan.com>
d35 1
a35 1
 * 2) Cards that use a dumb ISA->PCI bridge
d39 4
a42 13
 * The latter are often sold as "PCI wireless card adapters" and are
 * sold by several vendors.  Most are simply rebadged versions of the
 * Eumitcom WL11000P or Global Sun Technology GL24110P02.
 * These cards use the PLX 9052 dumb bridge chip to connect a PCMCIA
 * wireless card to the PCI bus.  Because it is a dumb bridge and
 * not a true PCMCIA bridge, the PCMCIA subsystem is not involved
 * (or even required).  The PLX 9052 provides multiple PCI address
 * space mappings.  The primary mappings at PCI registers 0x10 (mem)
 * and 0x14 (I/O) are for the PLX chip itself, *NOT* the PCMCIA card.
 * The mem and I/O spaces for the PCMCIA card are mapped to 0x18 and
 * 0x1C respectively.
 * The PLX 9050/9052 datasheet may be downloaded from PLX at
 *	http://www.plxtech.com/products/toolbox/9050.htm
d44 4
a47 5
 * This driver also supports the TMD7160 dumb bridge chip which is used
 * on some versions of the NDC/Sohoware NCP130.  The TMD7160 provides
 * two PCI I/O registers.  The first, at 0x14, maps to the Prism2 COR.
 * The second, at 0x18, is for the Prism2 chip itself.
 * The datasheet for the TMD7160 does not seem to be publicly available.
d84 1
d110 2
d148 107
d369 12
@


1.29
log
@PCI_PRODUCT_USR2_WL11000P not PCI_PRODUCT_USR2_USR11000P
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.28 2002/07/10 19:29:15 millert Exp $	*/
d55 2
a56 2
 * two PCI I/O registers.  The first, at 0x14, is for the TMD7160
 * chip itself.  The second, at 0x18, is for the Prism2 chip.
a57 2
 * The magic for initializing the chip was gleened from NDC's version of
 * the Linux wlan driver.
a86 5
/* Values for pp_type */
#define WI_PCI_PRISM		0x01	/* Intersil Mini-PCI */
#define WI_PCI_PLX		0x02	/* PLX 905x dumb bridge */
#define WI_PCI_TMD		0x03	/* TMD 7160 dumb bridge */

d94 5
a98 1
int	wi_pci_handle_cis(struct wi_softc *);
d107 1
a107 1
	int pp_type;
d109 11
a119 11
	{ PCI_VENDOR_GLOBALSUN, PCI_PRODUCT_GLOBALSUN_GL24110P, WI_PCI_PLX },
	{ PCI_VENDOR_GLOBALSUN, PCI_PRODUCT_GLOBALSUN_GL24110P02, WI_PCI_PLX },
	{ PCI_VENDOR_EUMITCOM, PCI_PRODUCT_EUMITCOM_WL11000P, WI_PCI_PLX },
	{ PCI_VENDOR_USR2, PCI_PRODUCT_USR2_WL11000P, WI_PCI_PLX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CRWE777A, WI_PCI_PLX },
	{ PCI_VENDOR_NETGEAR, PCI_PRODUCT_NETGEAR_MA301, WI_PCI_PLX },
	{ PCI_VENDOR_EFFICIENTNETS, PCI_PRODUCT_EFFICIENTNETS_SS1023, WI_PCI_PLX },
	{ PCI_VENDOR_NDC, PCI_PRODUCT_NDC_NCP130, WI_PCI_PLX },
	{ PCI_VENDOR_NDC, PCI_PRODUCT_NDC_NCP130A2, WI_PCI_TMD },
	{ PCI_VENDOR_INTERSIL, PCI_PRODUCT_INTERSIL_MINI_PCI_WLAN, WI_PCI_PRISM },
	{ 0, 0 }
d123 1
a123 2
wi_pci_lookup(pa)
	struct pci_attach_args *pa;
d137 1
a137 4
wi_pci_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d143 1
a143 4
wi_pci_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d148 10
a157 1
	pci_intr_handle_t ih;
d164 17
a180 4
	pci_chipset_tag_t pc = pa->pa_pc;
	u_int32_t command;
	pcireg_t csr;
	const char *intrstr;
d182 20
a201 8
	pp = wi_pci_lookup(pa);
	/* Map memory and I/O registers. */
	switch (pp->pp_type) {
	case WI_PCI_PLX:
		if (pci_mapreg_map(pa, WI_PLX_MEMRES, PCI_MAPREG_TYPE_MEM, 0,
		    &memt, &memh, NULL, NULL, 0) != 0) {
			printf(": can't map mem space\n");
			return;
d203 20
a222 6
		sc->wi_ltag = memt;
		sc->wi_lhandle = memh;
		if (pci_mapreg_map(pa, WI_PLX_IORES,
		    PCI_MAPREG_TYPE_IO, 0, &iot, &ioh, NULL, NULL, 0) != 0) {
			printf(": can't map I/O space\n");
			return;
d224 1
d226 4
a229 4
		 * Some cards, such as the PLX version of the NDC NCP130
		 * don't have the PLX local registers mapped.  In general
		 * this is OK since those card enable PLX interrupts for us.
		 * As such, we don't consider an error here to be fatal.
d231 4
a234 14
		localsize = 0;
		if (pci_mapreg_type(pa->pa_pc, pa->pa_tag, WI_PLX_LOCALRES)
		    == PCI_MAPREG_TYPE_IO) {
			if (pci_io_find(pa->pa_pc, pa->pa_tag,
			    WI_PLX_LOCALRES, &localbase, &localsize) != 0)
				printf(": can't find PLX I/O space\n");
			if (localsize != 0) {
				if (bus_space_map(pa->pa_iot, localbase,
				    localsize, 0, &localh) != 0) {
					printf(": can't map PLX I/O space\n");
					localsize = 0;
				} else
					localt = pa->pa_iot;
			}
d236 21
a256 6
		break;
	case WI_PCI_PRISM:
		if (pci_mapreg_map(pa, WI_PCI_CBMA, PCI_MAPREG_TYPE_MEM,
		    0, &iot, &ioh, NULL, NULL, 0) != 0) {
			printf(": can't map mem space\n");
			return;
d258 31
a288 18
		sc->sc_pci = 1;
		sc->wi_ltag = iot;
		sc->wi_lhandle = ioh;
		break;
	case WI_PCI_TMD:
		if (pci_mapreg_map(pa, WI_TMD_LOCALRES, PCI_MAPREG_TYPE_IO,
		    0, &localt, &localh, NULL, &localsize, 0) != 0) {
			printf(": can't map TMD I/O space\n");
			return;
		}
		sc->wi_ltag = localt;
		sc->wi_lhandle = localh;
		if (pci_mapreg_map(pa, WI_TMD_IORES, PCI_MAPREG_TYPE_IO,
		    0, &iot, &ioh, NULL, NULL, 0) != 0) {
			printf(": can't map I/O space\n");
			return;
		}
		break;
d290 21
d312 7
d321 22
d356 1
a356 1
		return;
d366 1
a366 1
		return;
d370 1
a370 54
	switch (pp->pp_type) {
	case WI_PCI_PLX:
		/*
		 * Check that there really is a PCMCIA card inserted and
		 * print its CIS strings.
		 */
		if (localsize != 0 && wi_pci_handle_cis(sc) != 0) {
			bus_space_unmap(localt, localh, localsize);
			return;
		}

		/*
		 * Tell the PLX chip to enable interrupts.  In most cases
		 * the serial EEPROM has done this for us but some cards
		 * appear not to.
		 * Note that some PLX-based cards lack this I/O space.
		 */
		if (localsize != 0) {
			command = bus_space_read_4(localt, localh,
			    WI_PLX_INTCSR);
			command |= WI_PLX_INTEN;
			bus_space_write_4(localt, localh, WI_PLX_INTCSR,
			    command);
		}

		/*
		 * Setup the PLX chip for level interrupts and config index 1
		 */
		bus_space_write_1(memt, memh, WI_PLX_COR_OFFSET,
		    WI_PLX_COR_VALUE);
		sc->wi_cor_offset = WI_PLX_COR_OFFSET;

		/* Unmap registers we no longer need access to. */
		if (localsize != 0)
			bus_space_unmap(localt, localh, localsize);
		break;
	case WI_PCI_PRISM:
		bus_space_write_2(iot, ioh, WI_PCI_COR_OFFSET,
		    WI_COR_SOFT_RESET);
		DELAY(100*1000); /* 100 m sec */
		bus_space_write_2(iot, ioh, WI_PCI_COR_OFFSET, WI_COR_CLEAR);
		DELAY(100*1000); /* 100 m sec */
		sc->wi_cor_offset = WI_PCI_COR_OFFSET;
		break;
	case WI_PCI_TMD:
		bus_space_write_1(localt, localh, WI_TMD_COR_OFFSET,
		    WI_TMD_COR_VALUE);
		DELAY(1000);
		if (bus_space_read_1(localt, localh, 0) != WI_TMD_COR_VALUE)
			printf(": unable to initialize TMD7160 ");
		sc->wi_cor_offset = WI_TMD_COR_OFFSET;
		break;
	}
	wi_attach(sc);
d373 2
a374 3
int
wi_pci_handle_cis(sc)
	struct wi_softc *sc;
d384 1
a384 1
	/* Make sure there really is a card there. */
d387 2
a388 5
		if (value != cis_magic[i]) {
			printf("\n%s: no PCMCIA card detected in bridge card\n",
			    WI_PRT_ARG(sc));
			return (ENODEV);
		}
a401 2

	return (0);
@


1.28
log
@Use the correct COR offset for pcmcia card; noted by Warner Losh
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.27 2002/07/09 11:00:27 fgsch Exp $	*/
d115 1
a115 1
	{ PCI_VENDOR_USR2, PCI_PRODUCT_USR2_USR11000P, WI_PCI_PLX },
@


1.27
log
@move common declarations to if_wivar.h; mickey@@ and millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.26 2002/04/15 21:19:52 millert Exp $	*/
d291 3
a293 2
		bus_space_write_1(memt, memh, WI_COR_OFFSET, WI_PLX_COR_VALUE);
		sc->wi_cor_offset = WI_COR_OFFSET;
@


1.26
log
@Add Siemens/Efficient Networks SpeedStream 1023 Wireless PCI Adapter,
another PLX card.  From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.25 2002/04/10 18:25:16 millert Exp $	*/
a101 2
int	wi_intr(void *);
int	wi_attach(struct wi_softc *);
@


1.25
log
@For PLX cards move CIS handling to be earlier
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.24 2002/04/09 01:27:06 millert Exp $	*/
d120 1
@


1.24
log
@No longer need memsize.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.23 2002/04/06 21:58:12 millert Exp $	*/
d267 9
a297 7

		/*
		 * For PLX bridge cards, check for a PCMCIA card and
		 * print its CIS strings.
		 */
		if (localsize != 0 && wi_pci_handle_cis(sc) != 0)
			return;
@


1.23
log
@For PLX-based bridge cards, move printing of pcmcia card CIS strings
out of generic wi_attach() and into wi_pci_attach().  This means
we can't print the CIS info for embedded cards like the NCP130 but
since those don't have a "real" pcmcia card in them this is really
not a problem.  Also check to see that there is actually a pcmcia
present and give and error if not.  CIS magic number taken from the
Linux orinoco driver; there may be a better way to do this.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.22 2002/04/06 20:31:56 millert Exp $	*/
d165 1
a165 1
	bus_size_t localsize, memsize;
d176 1
a176 1
		    &memt, &memh, NULL, &memsize, 0) != 0) {
@


1.22
log
@Add support for Symbol cards and printing of the primary station
firmware version.  Adapted from NetBSD and the Linux orinoco driver.
The Symbol firmware requires that we do a COR soft reset before
initializing the card in wi_reset().  Also, setting WI_RID_ROAMING_MODE
caused the Symbol card to go into a strange (non-working) mode with
firmware 2.x.x.

There are some other Symbol additions/oddities that will need to be
addressed in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.21 2002/04/03 22:49:56 millert Exp $	*/
d94 4
d101 1
d103 1
a103 1
int	wi_attach(struct wi_softc *, int);
d290 6
a295 1
		wi_attach(sc, 1);
a303 2

		wi_attach(sc, 0);
d312 4
d317 29
a345 2
		wi_attach(sc, 1);
		break;
d347 5
@


1.21
log
@The PLX version of the NDC NCP130 PCI card w/ embedded Prism2 does
not map the PLX registers so the driver cannot enable interrupts
on the PLX chip (this is OK since the card's EEPROM does it for us).

To work around this we check that what we expect to be the PLX registers
are a) I/O mapped and b) have a non-zero size.  OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.20 2002/04/01 05:49:57 millert Exp $	*/
d170 1
a170 1
		if (pci_mapreg_map(pa, WI_PCI_PLX_MEMRES, PCI_MAPREG_TYPE_MEM, 0,
d175 3
a177 1
		if (pci_mapreg_map(pa, WI_PCI_PLX_IORES,
d189 1
a189 1
		if (pci_mapreg_type(pa->pa_pc, pa->pa_tag, WI_PCI_PLX_LOCALRES)
d192 1
a192 1
			    WI_PCI_PLX_LOCALRES, &localbase, &localsize) != 0)
d211 2
d215 1
a215 1
		if (pci_mapreg_map(pa, WI_PCI_TMD_LOCALRES, PCI_MAPREG_TYPE_IO,
d220 3
a222 1
		if (pci_mapreg_map(pa, WI_PCI_TMD_IORES, PCI_MAPREG_TYPE_IO,
d278 2
a279 2
		bus_space_write_1(memt, memh,
		    WI_PLX_COR_OFFSET, WI_PLX_COR_VALUE);
a283 1
		bus_space_unmap(memt, memh, memsize);
d288 2
a289 1
		bus_space_write_2(iot, ioh, WI_PCI_COR, WI_PCI_SOFT_RESET);
d291 1
a291 1
		bus_space_write_2(iot, ioh, WI_PCI_COR, 0x0);
d293 1
d298 3
a300 3
		bus_space_write_1(localt, localh, 0, WI_TMD_COR_VALUE);
		/* XXX - correct delay? */
		DELAY(100*1000); /* 100 m sec */
d303 1
a303 3

		/* Unmap registers we no longer need access to. */
		bus_space_unmap(localt, localh, localsize);
@


1.20
log
@No Mickey, that corega card is just a rebadged NDC card.
Make this actually compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.19 2002/04/01 05:40:21 mickey Exp $	*/
d159 1
d175 2
a176 2
		if (pci_mapreg_map(pa, WI_PCI_PLX_IORES, PCI_MAPREG_TYPE_IO, 0,
		    &iot, &ioh, NULL, NULL, 0) != 0) {
d180 20
a199 4
		if (pci_mapreg_map(pa, WI_PCI_PLX_LOCALRES, PCI_MAPREG_TYPE_IO, 0,
		    &localt, &localh, NULL, &localsize, 0) != 0) {
			printf(": can't map PLX I/O space\n");
			return;
d259 1
d261 7
a267 3
		command = bus_space_read_4(localt, localh, WI_PLX_INTCSR);
		command |= WI_PLX_INTEN;
		bus_space_write_4(localt, localh, WI_PLX_INTCSR, command);
d276 2
a277 1
		bus_space_unmap(localt, localh, localsize);
@


1.19
log
@todd killed a corega card
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.18 2002/03/30 21:57:40 millert Exp $	*/
a116 1
	{ PCI_VENDOR_COREGA, PCI_PRODUCT_COREGA_CGWLPCIA11, WI_PCI_PLX },
@


1.18
log
@o Move register definitions to if_wireg.h
o Rename some register defines to be more useful (adapted from FreeBSD)
o Enable interrupts on PLX chip since some boards don't have this in
the EEPROM (adapted from FreeBSD and Linux).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.17 2002/03/27 22:01:16 millert Exp $	*/
d117 1
@


1.17
log
@Update comment at the top to reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.16 2002/03/26 20:42:51 millert Exp $	*/
a88 8
#define WI_PCI_CBMA		0x10
#define WI_PCI_PLX_LOMEM	0x10	/* PLX chip membase */
#define WI_PCI_PLX_LOIO		0x14	/* PLX chip iobase */
#define WI_PCI_TMD_IO		0x14	/* TMD chip iobase */
#define WI_PCI_TMD_PRISM_IO	0x18	/* Prism chip iobase behind the TMD */
#define WI_PCI_LOMEM		0x18	/* ISA membase */
#define WI_PCI_LOIO		0x1C	/* ISA iobase */

d155 2
a156 1
	bus_space_handle_t ioh, memh;
d159 1
d161 1
d169 2
a170 2
		if (pci_mapreg_map(pa, WI_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
		    &memt, &memh, NULL, NULL, 0) != 0) {
d174 1
a174 1
		if (pci_mapreg_map(pa, WI_PCI_LOIO, PCI_MAPREG_TYPE_IO, 0,
d179 5
a190 3

		memt = iot;
		memh = ioh;
d194 2
a195 2
		if (pci_mapreg_map(pa, WI_PCI_TMD_IO, PCI_MAPREG_TYPE_IO,
		    0, &memt, &memh, NULL, NULL, 0) != 0) {
d199 1
a199 1
		if (pci_mapreg_map(pa, WI_PCI_TMD_PRISM_IO, PCI_MAPREG_TYPE_IO,
d201 1
a201 1
			printf(": can't map Prism2 I/O space\n");
d239 9
a248 1
		 * XXX - should really reset the PLX chip too.
d253 4
d268 1
a268 1
		bus_space_write_1(memt, memh, 0, WI_TMD_COR_VALUE);
d271 1
a271 1
		if (bus_space_read_1(memt, memh, 0) != WI_TMD_COR_VALUE)
d273 3
@


1.16
log
@Add support for the TMD7160 dumb PCI-ISA bridge (similar in function to
the PLX905x).  Info gleaned from patches to the Linux wlan driver
from NDC.  This makes the NDC NCP130 rev A2 work.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.14 2002/03/14 01:26:59 millert Exp $	*/
d29 1
d31 5
a35 2
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
d37 1
a37 46
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This is a PCI shim for the Wavelan wireless network driver.
 * It works with PCI adaptors based on the PLX 9050 and PLX 9052
 * PCI to "dumb bus" bridge chip.  It has been tested with the
 * Global Sun Technology GL24110P02 (aka Linksys WDT11), 3Com 3CRWE777A,
 * and Netgear MA301.  It is also expected to work with the
 * Global Sun GL24110P and Eumitcom WL11000P.
 *
 * All we do here is handle the PCI match and attach, set up an
 * interrupt handler entry point, and setup the PLX chip for level
 * interrupts and config index 1.
 *
 * The PLX 9052 provides us with multiple PCI address space mappings.
 * The primary mappings at PCI registers 0x10 (mem) and 0x14 (I/O) are for
 * the PLX chip itself, *NOT* the pcmcia card.
 * The PLX 9052 provides 4 local address space registers: 0x18, 0x1C,
 * 0x20, and 0x24.  The mem and I/O spaces for the PCMCIA card are
 * mapped to 0x18 and 0x1C respectively.
d39 21
a59 2
 * The datasheet may be downloaded from PLX (though you do have to register)
 * http://www.plxtech.com/products/toolbox/9050.htm
@


1.15
log
@a clone of Eumitcom WL11000P -- USR11000P; from lj7@@usa.net
@
text
@d4 1
a4 1
 * Copyright (c) 2001 Todd C. Miller <Todd.Miller@@courtesan.com>
d114 2
d119 5
d137 1
a137 1
	int pp_plx;
d139 9
a147 8
	{ PCI_VENDOR_GLOBALSUN, PCI_PRODUCT_GLOBALSUN_GL24110P, 1 },
	{ PCI_VENDOR_GLOBALSUN, PCI_PRODUCT_GLOBALSUN_GL24110P02, 1 },
	{ PCI_VENDOR_EUMITCOM, PCI_PRODUCT_EUMITCOM_WL11000P, 1 },
	{ PCI_VENDOR_USR2, PCI_PRODUCT_USR2_USR11000P, 1 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CRWE777A, 1 },
	{ PCI_VENDOR_NETGEAR, PCI_PRODUCT_NETGEAR_MA301, 1 },
	{ PCI_VENDOR_COREGA, PCI_PRODUCT_COREGA_CGWLPCIA11, 1 },
	{ PCI_VENDOR_INTERSIL, PCI_PRODUCT_INTERSIL_MINI_PCI_WLAN, 0 },
d193 3
a195 2
	if (pp->pp_plx) {
		/* Map memory and I/O registers. */
d206 2
a207 1
	} else {
d217 13
d261 2
a262 1
	if (pp->pp_plx) {
d271 2
a272 1
	} else {
d279 10
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.13 2002/01/28 21:42:40 mickey Exp $	*/
d135 1
@


1.13
log
@match on corega CGWLPCIA11; from <jonathon.fletcher@@pobox.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.12 2001/12/20 17:48:25 mickey Exp $	*/
d117 5
a121 5
const struct wi_pci_product *wi_pci_lookup __P((struct pci_attach_args *pa));
int	wi_pci_match	__P((struct device *, void *, void *));
void	wi_pci_attach	__P((struct device *, struct device *, void *));
int	wi_intr		__P((void *));
int	wi_attach	__P((struct wi_softc *, int));
@


1.12
log
@for mimi-pci cards registers are word in a dword, missed that in bringing over support from netbsd; partially successfully tested by ellidz@@eridu.uchicago.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.11 2001/12/20 17:41:48 mickey Exp $	*/
d137 1
@


1.11
log
@rule: first commit, then compile
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.10 2001/12/20 17:39:50 mickey Exp $	*/
d204 1
@


1.10
log
@do not print cis for non-plx cards, because there is none
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.9 2001/10/25 19:40:14 mickey Exp $	*/
d235 1
a235 1
	if (pp->pp_plx)
d244 1
a244 1
	else {
@


1.9
log
@implement "the other" pci interface for wavelans, found on intersil
mini-pci cards. inspired by the netbsd's if_wi_pci.c .
rename WI_COR_* into WI_PLX_COR_*, per millert@@'s suggestion.
tested by millert@@ for the plx-based cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.8 2001/10/24 17:33:44 millert Exp $	*/
d242 2
d249 2
a251 2

	wi_attach(sc, 1);
@


1.9.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.13 2002/01/28 21:42:40 mickey Exp $	*/
a136 1
	{ PCI_VENDOR_COREGA, PCI_PRODUCT_COREGA_CGWLPCIA11, 1 },
a203 1
		sc->sc_pci = 1;
d235 1
a235 1
	if (pp->pp_plx) {
d242 1
a242 3

		wi_attach(sc, 1);
	} else {
d247 1
d249 1
a249 2
		wi_attach(sc, 0);
	}
@


1.9.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.9.2.1 2002/01/31 22:55:35 niklas Exp $	*/
d4 1
a4 1
 * Copyright (c) 2001, 2002 Todd C. Miller <Todd.Miller@@courtesan.com>
d29 31
d62 17
a78 2
 * PCI attachment for the Wavelan driver.  There are two basic types
 * of PCI card supported:
d80 2
a81 26
 * 1) Cards based on the Prism2.5 Mini-PCI chipset
 * 2) Cards that use a dumb ISA->PCI bridge
 *
 * Only the first type are "true" PCI cards.
 *
 * The latter are often sold as "PCI wireless card adapters" and are
 * sold by several vendors.  Most are simply rebadged versions of the
 * Eumitcom WL11000P or Global Sun Technology GL24110P02.
 * These cards use the PLX 9052 dumb bridge chip to connect a PCMCIA
 * wireless card to the PCI bus.  Because it is a dumb bridge and
 * not a true PCMCIA bridge, the PCMCIA subsystem is not involved
 * (or even required).  The PLX 9052 provides multiple PCI address
 * space mappings.  The primary mappings at PCI registers 0x10 (mem)
 * and 0x14 (I/O) are for the PLX chip itself, *NOT* the PCMCIA card.
 * The mem and I/O spaces for the PCMCIA card are mapped to 0x18 and
 * 0x1C respectively.
 * The PLX 9050/9052 datasheet may be downloaded from PLX at
 *	http://www.plxtech.com/products/toolbox/9050.htm
 *
 * This driver also supports the TMD7160 dumb bridge chip which is used
 * on some versions of the NDC/Sohoware NCP130.  The TMD7160 provides
 * two PCI I/O registers.  The first, at 0x14, is for the TMD7160
 * chip itself.  The second, at 0x18, is for the Prism2 chip.
 * The datasheet for the TMD7160 does not seem to be publicly available.
 * The magic for initializing the chip was gleened from NDC's version of
 * the Linux wlan driver.
d111 11
a121 15
/* Values for pp_type */
#define WI_PCI_PRISM		0x01	/* Intersil Mini-PCI */
#define WI_PCI_PLX		0x02	/* PLX 905x dumb bridge */
#define WI_PCI_TMD		0x03	/* TMD 7160 dumb bridge */

/* For printing CIS of the actual PCMCIA card */
#define CIS_MFG_NAME_OFFSET	0x16
#define CIS_INFO_SIZE		256

const struct wi_pci_product *wi_pci_lookup(struct pci_attach_args *pa);
int	wi_pci_match(struct device *, void *, void *);
void	wi_pci_attach(struct device *, struct device *, void *);
int	wi_pci_handle_cis(struct wi_softc *);
int	wi_intr(void *);
int	wi_attach(struct wi_softc *);
d130 1
a130 1
	int pp_type;
d132 7
a138 10
	{ PCI_VENDOR_GLOBALSUN, PCI_PRODUCT_GLOBALSUN_GL24110P, WI_PCI_PLX },
	{ PCI_VENDOR_GLOBALSUN, PCI_PRODUCT_GLOBALSUN_GL24110P02, WI_PCI_PLX },
	{ PCI_VENDOR_EUMITCOM, PCI_PRODUCT_EUMITCOM_WL11000P, WI_PCI_PLX },
	{ PCI_VENDOR_USR2, PCI_PRODUCT_USR2_USR11000P, WI_PCI_PLX },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CRWE777A, WI_PCI_PLX },
	{ PCI_VENDOR_NETGEAR, PCI_PRODUCT_NETGEAR_MA301, WI_PCI_PLX },
	{ PCI_VENDOR_EFFICIENTNETS, PCI_PRODUCT_EFFICIENTNETS_SS1023, WI_PCI_PLX },
	{ PCI_VENDOR_NDC, PCI_PRODUCT_NDC_NCP130, WI_PCI_PLX },
	{ PCI_VENDOR_NDC, PCI_PRODUCT_NDC_NCP130A2, WI_PCI_TMD },
	{ PCI_VENDOR_INTERSIL, PCI_PRODUCT_INTERSIL_MINI_PCI_WLAN, WI_PCI_PRISM },
d176 1
a176 2
	bus_space_handle_t localh, ioh, memh;
	bus_space_tag_t localt;
a178 2
	bus_addr_t localbase;
	bus_size_t localsize;
a179 1
	u_int32_t command;
d184 3
a186 4
	/* Map memory and I/O registers. */
	switch (pp->pp_type) {
	case WI_PCI_PLX:
		if (pci_mapreg_map(pa, WI_PLX_MEMRES, PCI_MAPREG_TYPE_MEM, 0,
d191 2
a192 4
		sc->wi_ltag = memt;
		sc->wi_lhandle = memh;
		if (pci_mapreg_map(pa, WI_PLX_IORES,
		    PCI_MAPREG_TYPE_IO, 0, &iot, &ioh, NULL, NULL, 0) != 0) {
d196 1
a196 23
		/*
		 * Some cards, such as the PLX version of the NDC NCP130
		 * don't have the PLX local registers mapped.  In general
		 * this is OK since those card enable PLX interrupts for us.
		 * As such, we don't consider an error here to be fatal.
		 */
		localsize = 0;
		if (pci_mapreg_type(pa->pa_pc, pa->pa_tag, WI_PLX_LOCALRES)
		    == PCI_MAPREG_TYPE_IO) {
			if (pci_io_find(pa->pa_pc, pa->pa_tag,
			    WI_PLX_LOCALRES, &localbase, &localsize) != 0)
				printf(": can't find PLX I/O space\n");
			if (localsize != 0) {
				if (bus_space_map(pa->pa_iot, localbase,
				    localsize, 0, &localh) != 0) {
					printf(": can't map PLX I/O space\n");
					localsize = 0;
				} else
					localt = pa->pa_iot;
			}
		}
		break;
	case WI_PCI_PRISM:
d202 3
a205 17
		sc->wi_ltag = iot;
		sc->wi_lhandle = ioh;
		break;
	case WI_PCI_TMD:
		if (pci_mapreg_map(pa, WI_TMD_LOCALRES, PCI_MAPREG_TYPE_IO,
		    0, &localt, &localh, NULL, &localsize, 0) != 0) {
			printf(": can't map TMD I/O space\n");
			return;
		}
		sc->wi_ltag = localt;
		sc->wi_lhandle = localh;
		if (pci_mapreg_map(pa, WI_TMD_IORES, PCI_MAPREG_TYPE_IO,
		    0, &iot, &ioh, NULL, NULL, 0) != 0) {
			printf(": can't map I/O space\n");
			return;
		}
		break;
d237 1
a237 25
	switch (pp->pp_type) {
	case WI_PCI_PLX:
		/*
		 * Check that there really is a PCMCIA card inserted and
		 * print its CIS strings.
		 */
		if (localsize != 0 && wi_pci_handle_cis(sc) != 0) {
			bus_space_unmap(localt, localh, localsize);
			return;
		}

		/*
		 * Tell the PLX chip to enable interrupts.  In most cases
		 * the serial EEPROM has done this for us but some cards
		 * appear not to.
		 * Note that some PLX-based cards lack this I/O space.
		 */
		if (localsize != 0) {
			command = bus_space_read_4(localt, localh,
			    WI_PLX_INTCSR);
			command |= WI_PLX_INTEN;
			bus_space_write_4(localt, localh, WI_PLX_INTCSR,
			    command);
		}

d240 1
d242 2
a243 2
		bus_space_write_1(memt, memh, WI_COR_OFFSET, WI_PLX_COR_VALUE);
		sc->wi_cor_offset = WI_COR_OFFSET;
d245 3
a247 7
		/* Unmap registers we no longer need access to. */
		if (localsize != 0)
			bus_space_unmap(localt, localh, localsize);
		break;
	case WI_PCI_PRISM:
		bus_space_write_2(iot, ioh, WI_PCI_COR_OFFSET,
		    WI_COR_SOFT_RESET);
d249 1
a249 1
		bus_space_write_2(iot, ioh, WI_PCI_COR_OFFSET, WI_COR_CLEAR);
a250 35
		sc->wi_cor_offset = WI_PCI_COR_OFFSET;
		break;
	case WI_PCI_TMD:
		bus_space_write_1(localt, localh, WI_TMD_COR_OFFSET,
		    WI_TMD_COR_VALUE);
		DELAY(1000);
		if (bus_space_read_1(localt, localh, 0) != WI_TMD_COR_VALUE)
			printf(": unable to initialize TMD7160 ");
		sc->wi_cor_offset = WI_TMD_COR_OFFSET;
		break;
	}
	wi_attach(sc);
}

int
wi_pci_handle_cis(sc)
	struct wi_softc *sc;
{
	int i, stringno;
	char cisbuf[CIS_INFO_SIZE];
	char *cis_strings[3];
	u_int8_t value;
	const u_int8_t cis_magic[] = {
		0x01, 0x03, 0x00, 0x00, 0xff, 0x17, 0x04, 0x67
	};

	/* Make sure there really is a card there. */
	for (i = 0; i < 8; i++) {
		value = bus_space_read_1(sc->wi_ltag, sc->wi_lhandle, i * 2);
		if (value != cis_magic[i]) {
			printf("\n%s: no PCMCIA card detected in bridge card\n",
			    WI_PRT_ARG(sc));
			return (ENODEV);
		}
	}
d252 1
a252 7
	cis_strings[0] = cisbuf;
	stringno = 0;
	for (i = 0; i < CIS_INFO_SIZE && stringno < 3; i++) {
		cisbuf[i] = bus_space_read_1(sc->wi_ltag,
		    sc->wi_lhandle, (CIS_MFG_NAME_OFFSET + i) * 2);
		if (cisbuf[i] == '\0' && ++stringno < 3)
			cis_strings[stringno] = &cisbuf[i + 1];
a253 5
	cisbuf[CIS_INFO_SIZE - 1] = '\0';
	printf("\n%s: \"%s, %s, %s\"", WI_PRT_ARG(sc),
	    cis_strings[0], cis_strings[1], cis_strings[2]);

	return (0);
@


1.9.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.9.2.2 2002/06/11 03:42:26 art Exp $	*/
d55 2
a56 2
 * two PCI I/O registers.  The first, at 0x14, maps to the Prism2 COR.
 * The second, at 0x18, is for the Prism2 chip itself.
d58 2
d89 5
d101 3
a103 5
int	wi_pci_plx_attach(struct pci_attach_args *pa, struct wi_softc *sc);
int	wi_pci_tmd_attach(struct pci_attach_args *pa, struct wi_softc *sc);
int	wi_pci_native_attach(struct pci_attach_args *pa, struct wi_softc *sc);
int	wi_pci_common_attach(struct pci_attach_args *pa, struct wi_softc *sc);
void	wi_pci_plx_print_cis(struct wi_softc *);
d112 1
a112 1
	int (*pp_attach)(struct pci_attach_args *pa, struct wi_softc *sc);
d114 11
a124 11
	{ PCI_VENDOR_GLOBALSUN, PCI_PRODUCT_GLOBALSUN_GL24110P, wi_pci_plx_attach },
	{ PCI_VENDOR_GLOBALSUN, PCI_PRODUCT_GLOBALSUN_GL24110P02, wi_pci_plx_attach },
	{ PCI_VENDOR_EUMITCOM, PCI_PRODUCT_EUMITCOM_WL11000P, wi_pci_plx_attach },
	{ PCI_VENDOR_USR2, PCI_PRODUCT_USR2_WL11000P, wi_pci_plx_attach },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CRWE777A, wi_pci_plx_attach },
	{ PCI_VENDOR_NETGEAR, PCI_PRODUCT_NETGEAR_MA301, wi_pci_plx_attach },
	{ PCI_VENDOR_EFFICIENTNETS, PCI_PRODUCT_EFFICIENTNETS_SS1023, wi_pci_plx_attach },
	{ PCI_VENDOR_NDC, PCI_PRODUCT_NDC_NCP130, wi_pci_plx_attach },
	{ PCI_VENDOR_NDC, PCI_PRODUCT_NDC_NCP130A2, wi_pci_tmd_attach },
	{ PCI_VENDOR_INTERSIL, PCI_PRODUCT_INTERSIL_MINI_PCI_WLAN, wi_pci_native_attach },
	{ 0, 0, 0 }
d128 2
a129 1
wi_pci_lookup(struct pci_attach_args *pa)
d143 4
a146 1
wi_pci_match(struct device *parent, void *match, void *aux)
d152 4
a155 1
wi_pci_attach(struct device *parent, struct device *self, void *aux)
d160 1
a160 10

	pp = wi_pci_lookup(pa);
	if (pp->pp_attach(pa, sc) != 0)
		return;
	wi_attach(sc);
}

int
wi_pci_plx_attach(struct pci_attach_args *pa, struct wi_softc *sc)
{
d167 4
a170 1
	u_int32_t intcsr;
d172 15
a186 36
	if (pci_mapreg_map(pa, WI_PLX_MEMRES, PCI_MAPREG_TYPE_MEM, 0,
	    &memt, &memh, NULL, NULL, 0) != 0) {
		printf(": can't map mem space\n");
		return (ENXIO);
	}
	sc->wi_ltag = memt;
	sc->wi_lhandle = memh;

	if (pci_mapreg_map(pa, WI_PLX_IORES,
	    PCI_MAPREG_TYPE_IO, 0, &iot, &ioh, NULL, NULL, 0) != 0) {
		printf(": can't map I/O space\n");
		return (ENXIO);
	}
	sc->wi_btag = iot;
	sc->wi_bhandle = ioh;

	/*
	 * Some cards, such as the PLX version of the NDC NCP130,
	 * don't have the PLX local registers mapped.  In general
	 * this is OK since on those cards the serial EEPROM has
	 * already set things up for us.
	 * As such, we don't consider an error here to be fatal.
	 */
	localsize = 0;
	if (pci_mapreg_type(pa->pa_pc, pa->pa_tag, WI_PLX_LOCALRES)
	    == PCI_MAPREG_TYPE_IO) {
		if (pci_io_find(pa->pa_pc, pa->pa_tag,
		    WI_PLX_LOCALRES, &localbase, &localsize) != 0)
			printf(": can't find PLX I/O space\n");
		if (localsize != 0) {
			if (bus_space_map(pa->pa_iot, localbase,
			    localsize, 0, &localh) != 0) {
				printf(": can't map PLX I/O space\n");
				localsize = 0;
			} else
				localt = pa->pa_iot;
a187 9
	}

	if (wi_pci_common_attach(pa, sc) != 0)
		return (ENXIO);

	if (localsize != 0) {
		intcsr = bus_space_read_4(localt, localh,
		    WI_PLX_INTCSR);

d189 4
a192 5
		 * The Netgear MA301 has local interrupt 1 active
		 * when there is no card in the adapter.  We bail
		 * early in this case since our attempt to check
		 * for the presence of a card later will hang the
		 * MA301.
d194 21
a214 4
		if (intcsr & WI_PLX_LINT1STAT) {
			printf("\n%s: no PCMCIA card detected in bridge card\n",
			    WI_PRT_ARG(sc));
			return (ENXIO);
d216 9
a224 11

		/*
		 * Enable PCI interrupts on the PLX chip if they are
		 * not already enabled. On most adapters the serial
		 * EEPROM has done this for us but some (such as
		 * the Netgear MA301) do not.
		 */
		if (!(intcsr & WI_PLX_INTEN)) {
			intcsr |= WI_PLX_INTEN;
			bus_space_write_4(localt, localh, WI_PLX_INTCSR,
			    intcsr);
d226 6
a231 21
	}

	/*
	 * Enable I/O mode and level interrupts on the PCMCIA card.
	 * The PCMCIA card's COR is the first byte after the CIS.
	 */
	bus_space_write_1(memt, memh, WI_PLX_COR_OFFSET, WI_COR_IOMODE);
	sc->wi_cor_offset = WI_PLX_COR_OFFSET;

	if (localsize != 0) {
		/*
		 * Test the presence of a wi(4) card by writing
		 * a magic number to the first software support
		 * register and then reading it back.
		 */
		CSR_WRITE_2(sc, WI_SW0, WI_DRVR_MAGIC);
		DELAY(1000);
		if (CSR_READ_2(sc, WI_SW0) != WI_DRVR_MAGIC) {
			printf("\n%s: no PCMCIA card detected in bridge card\n",
			    WI_PRT_ARG(sc));
			return (ENXIO);
d233 1
a233 6

		/* Unmap registers we no longer need access to. */
		bus_space_unmap(localt, localh, localsize);

		/* Print PCMCIA card's CIS strings. */
		wi_pci_plx_print_cis(sc);
a235 24
	return (0);
}

int
wi_pci_tmd_attach(struct pci_attach_args *pa, struct wi_softc *sc)
{
	bus_space_handle_t localh, ioh;
	bus_space_tag_t localt;
	bus_space_tag_t iot = pa->pa_iot;
	bus_size_t localsize;

	if (pci_mapreg_map(pa, WI_TMD_LOCALRES, PCI_MAPREG_TYPE_IO,
	    0, &localt, &localh, NULL, &localsize, 0) != 0) {
		printf(": can't map TMD I/O space\n");
		return (ENXIO);
	}
	sc->wi_ltag = localt;
	sc->wi_lhandle = localh;

	if (pci_mapreg_map(pa, WI_TMD_IORES, PCI_MAPREG_TYPE_IO,
	    0, &iot, &ioh, NULL, NULL, 0) != 0) {
		printf(": can't map I/O space\n");
		return (ENXIO);
	}
a238 51
	if (wi_pci_common_attach(pa, sc) != 0)
		return (ENXIO);

	/* 
	 * Enable I/O mode and level interrupts on the embedded PCMCIA
	 * card.  The PCMCIA card's COR is the first byte of BAR 0.
	 */
	bus_space_write_1(localt, localh, 0, WI_COR_IOMODE);
	sc->wi_cor_offset = 0;

	return (0);
}

int
wi_pci_native_attach(struct pci_attach_args *pa, struct wi_softc *sc)
{
	bus_space_handle_t ioh;
	bus_space_tag_t iot = pa->pa_iot;

	if (pci_mapreg_map(pa, WI_PCI_CBMA, PCI_MAPREG_TYPE_MEM,
	    0, &iot, &ioh, NULL, NULL, 0) != 0) {
		printf(": can't map mem space\n");
		return (ENXIO);
	}
	sc->wi_ltag = iot;
	sc->wi_lhandle = ioh;
	sc->wi_btag = iot;
	sc->wi_bhandle = ioh;
	sc->sc_pci = 1;

	if (wi_pci_common_attach(pa, sc) != 0)
		return (ENXIO);

	/* Do a soft reset of the HFA3842 MAC core */
	bus_space_write_2(iot, ioh, WI_PCI_COR_OFFSET, WI_COR_SOFT_RESET);
	DELAY(100*1000); /* 100 m sec */
	bus_space_write_2(iot, ioh, WI_PCI_COR_OFFSET, WI_COR_CLEAR);
	DELAY(100*1000); /* 100 m sec */
	sc->wi_cor_offset = WI_PCI_COR_OFFSET;

	return (0);
}

int
wi_pci_common_attach(struct pci_attach_args *pa, struct wi_softc *sc)
{
	pci_intr_handle_t ih;
	pci_chipset_tag_t pc = pa->pa_pc;
	pcireg_t csr;
	const char *intrstr;

d251 1
a251 1
		return (ENXIO);
d261 1
a261 1
		return (ENXIO);
d265 53
a317 1
	return (0);
d320 3
a322 2
void
wi_pci_plx_print_cis(struct wi_softc *sc)
d332 1
a332 1
	/* Make sure the CIS data is valid. */
d335 5
a339 2
		if (value != cis_magic[i])
			return;
d353 2
@


1.9.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 2001-2003 Todd C. Miller <Todd.Miller@@courtesan.com>
d35 1
a35 1
 * 2) Cards that use a dumb PCMCIA->PCI bridge
d39 13
a51 4
 * The latter are simply PCMCIA cards (or the guts of same) with some
 * type of dumb PCMCIA->PCI bridge.  They are "dumb" in that they
 * are not true PCMCIA bridges and really just serve to deal with
 * the different interrupt types and timings of the ISA vs. PCI bus.
d53 5
a57 4
 * The following bridge types are supported:
 *  o PLX 9052 (the most common)
 *  o TMD 7160 (found in some NDC/Sohoware NCP130 cards)
 *  o ACEX EP1K30 (really a PLD, found in Symbol cards and their OEMs)
a93 1
int	wi_pci_acex_attach(struct pci_attach_args *pa, struct wi_softc *sc);
a118 2
	{ PCI_VENDOR_NORTEL, PCI_PRODUCT_NORTEL_211818A, wi_pci_acex_attach },
	{ PCI_VENDOR_SYMBOL, PCI_PRODUCT_SYMBOL_LA41X3, wi_pci_acex_attach },
a154 123
/*
 * ACEX EP1K30-based PCMCIA->PCI bridge attachment.
 *
 * The ACEX EP1K30 is a programmable logic device (PLD) used as a
 * PCMCIA->PCI bridge on the Symbol LA4123 and its OEM equivalents
 * (such as the Nortel E-mobility 211818-A).  There are 3 I/O ports:
 * BAR0 at 0x10 appears to be a command port.
 * BAR1 at 0x14 contains COR at offset 0xe0.
 * BAR2 at 0x18 maps the actual PCMCIA card.
 *
 * The datasheet for the ACEX EP1K30 is available from Altera but that
 * doesn't really help much since we don't know how it is programmed.
 * Details for this attachment were gleaned from a version of the
 * Linux orinoco driver modified by Tobias Hoffmann based on
 * what he discoverd from the Windows driver.
 */
int
wi_pci_acex_attach(struct pci_attach_args *pa, struct wi_softc *sc)
{
	bus_space_handle_t commandh, localh, ioh;
	bus_space_tag_t commandt, localt;
	bus_space_tag_t iot = pa->pa_iot;
	bus_size_t commandsize, localsize, iosize;
	int i;

	if (pci_mapreg_map(pa, WI_ACEX_CMDRES, PCI_MAPREG_TYPE_IO,
	    0, &commandt, &commandh, NULL, &commandsize, 0) != 0) {
		printf(": can't map command I/O space\n");
		return (ENXIO);
	}

	if (pci_mapreg_map(pa, WI_ACEX_LOCALRES, PCI_MAPREG_TYPE_IO,
	    0, &localt, &localh, NULL, &localsize, 0) != 0) {
		printf(": can't map local I/O space\n");
		bus_space_unmap(commandt, commandh, commandsize);
		return (ENXIO);
	}
	sc->wi_ltag = localt;
	sc->wi_lhandle = localh;

	if (pci_mapreg_map(pa, WI_TMD_IORES, PCI_MAPREG_TYPE_IO,
	    0, &iot, &ioh, NULL, &iosize, 0) != 0) {
		printf(": can't map I/O space\n");
		bus_space_unmap(localt, localh, localsize);
		bus_space_unmap(commandt, commandh, commandsize);
		return (ENXIO);
	}
	sc->wi_btag = iot;
	sc->wi_bhandle = ioh;

	/*
	 * Setup bridge chip.
	 */
	if (bus_space_read_4(commandt, commandh, 0) & 1) {
		printf(": bridge not ready\n");
		bus_space_unmap(iot, ioh, iosize);
		bus_space_unmap(localt, localh, localsize);
		bus_space_unmap(commandt, commandh, commandsize);
		return (ENXIO);
	}
	bus_space_write_4(commandt, commandh, 2, 0x118);
	bus_space_write_4(commandt, commandh, 2, 0x108);
	DELAY(30 * 1000);
	bus_space_write_4(commandt, commandh, 2, 0x8);
	for (i = 0; i < 30; i++) {
		DELAY(30 * 1000);
		if (bus_space_read_4(commandt, commandh, 0) & 0x10)
			break;
	}
	if (i == 30) {
		printf(": bridge timeout\n");
		bus_space_unmap(iot, ioh, iosize);
		bus_space_unmap(localt, localh, localsize);
		bus_space_unmap(commandt, commandh, commandsize);
		return (ENXIO);
	}
	if ((bus_space_read_4(localt, localh, 0xe0) & 1) ||
	    (bus_space_read_4(localt, localh, 0xe2) & 1) ||
	    (bus_space_read_4(localt, localh, 0xe4) & 1)) {
		printf(": failed bridge setup\n");
		bus_space_unmap(iot, ioh, iosize);
		bus_space_unmap(localt, localh, localsize);
		bus_space_unmap(commandt, commandh, commandsize);
		return (ENXIO);
	}

	if (wi_pci_common_attach(pa, sc) != 0) {
		bus_space_unmap(iot, ioh, iosize);
		bus_space_unmap(localt, localh, localsize);
		bus_space_unmap(commandt, commandh, commandsize);
		return (ENXIO);
	}

	/* 
	 * Enable I/O mode and level interrupts on the embedded PCMCIA
	 * card.
	 */
	bus_space_write_1(localt, localh, WI_ACEX_COR_OFFSET, WI_COR_IOMODE);
	sc->wi_cor_offset = WI_ACEX_COR_OFFSET;

	/* Unmap registers we no longer need access to. */
	bus_space_unmap(commandt, commandh, commandsize);

	return (0);
}

/*
 * PLX 9052-based PCMCIA->PCI bridge attachment.
 *
 * These are often sold as "PCI wireless card adapters" and are
 * sold by several vendors.  Most are simply rebadged versions of the
 * Eumitcom WL11000P or Global Sun Technology GL24110P02.
 * These cards use the PLX 9052 dumb bridge chip to connect a PCMCIA
 * wireless card to the PCI bus.  Because it is a dumb bridge and
 * not a true PCMCIA bridge, the PCMCIA subsystem is not involved
 * (or even required).  The PLX 9052 provides multiple PCI address
 * space mappings.  The primary mappings at PCI registers 0x10 (mem)
 * and 0x14 (I/O) are for the PLX chip itself, *NOT* the PCMCIA card.
 * The mem and I/O spaces for the PCMCIA card are mapped to 0x18 and
 * 0x1C respectively.
 * The PLX 9050/9052 datasheet may be downloaded from PLX at
 *	http://www.plxtech.com/products/toolbox/9050.htm
 */
d163 1
a163 1
	bus_size_t localsize, memsize, iosize;
d167 1
a167 1
	    &memt, &memh, NULL, &memsize, 0) != 0) {
d175 1
a175 1
	    PCI_MAPREG_TYPE_IO, 0, &iot, &ioh, NULL, &iosize, 0) != 0) {
a176 1
		bus_space_unmap(memt, memh, memsize);
d205 1
a205 5
	if (wi_pci_common_attach(pa, sc) != 0) {
		if (localsize)
			bus_space_unmap(localt, localh, localsize);
		bus_space_unmap(iot, ioh, iosize);
		bus_space_unmap(memt, memh, memsize);
a206 1
	}
a221 5
			pci_intr_disestablish(pa->pa_pc, sc->sc_ih);
			if (localsize)
				bus_space_unmap(localt, localh, localsize);
			bus_space_unmap(iot, ioh, iosize);
			bus_space_unmap(memt, memh, memsize);
a255 5
			pci_intr_disestablish(pa->pa_pc, sc->sc_ih);
			if (localsize)
				bus_space_unmap(localt, localh, localsize);
			bus_space_unmap(iot, ioh, iosize);
			bus_space_unmap(memt, memh, memsize);
a268 12
/*
 * TMD 7160-based PCMCIA->PCI bridge attachment.
 *
 * The TMD7160 dumb bridge chip is used on some versions of the
 * NDC/Sohoware NCP130.  The TMD7160 provides two PCI I/O registers.
 * The first, at 0x14, maps to the Prism2 COR.
 * The second, at 0x18, is for the Prism2 chip itself.
 *
 * The datasheet for the TMD7160 does not seem to be publicly available.
 * Details for this attachment were gleaned from a version of the
 * Linux WLAN driver modified by NDC.
 */
d275 1
a275 1
	bus_size_t localsize, iosize;
d286 1
a286 1
	    0, &iot, &ioh, NULL, &iosize, 0) != 0) {
a287 1
		bus_space_unmap(localt, localh, localsize);
d293 1
a293 3
	if (wi_pci_common_attach(pa, sc) != 0) {
		bus_space_unmap(iot, ioh, iosize);
		bus_space_unmap(localt, localh, localsize);
a294 1
	}
a310 1
	bus_size_t iosize;
d313 1
a313 1
	    0, &iot, &ioh, NULL, &iosize, 0) != 0) {
d323 1
a323 2
	if (wi_pci_common_attach(pa, sc) != 0) {
		bus_space_unmap(iot, ioh, iosize);
a324 1
	}
d341 1
d343 5
@


1.8
log
@Match Netgear MA301 dumb PCMCIA->PCI bridge.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.7 2001/08/25 10:13:29 art Exp $	*/
d111 1
d117 1
d130 1
d132 6
a137 5
	{ PCI_VENDOR_GLOBALSUN, PCI_PRODUCT_GLOBALSUN_GL24110P },
	{ PCI_VENDOR_GLOBALSUN, PCI_PRODUCT_GLOBALSUN_GL24110P02 },
	{ PCI_VENDOR_EUMITCOM, PCI_PRODUCT_EUMITCOM_WL11000P },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CRWE777A },
	{ PCI_VENDOR_NETGEAR, PCI_PRODUCT_NETGEAR_MA301 },
d141 3
a143 5
int
wi_pci_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
a144 1
	struct pci_attach_args *pa = aux;
d150 1
a150 1
			return(1);
d153 10
a162 1
	return(0);
d173 1
d182 22
a203 10
	/* Map memory and I/O registers. */
	if (pci_mapreg_map(pa, WI_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
	    &memt, &memh, NULL, NULL, 0) != 0) {
		printf(": can't map mem space\n");
		return;
	}
	if (pci_mapreg_map(pa, WI_PCI_LOIO, PCI_MAPREG_TYPE_IO, 0,
	    &iot, &ioh, NULL, NULL, 0) != 0) {
		printf(": can't map I/O space\n");
		return;
d205 1
d235 13
a247 5
	/*
	 * Setup the PLX chip for level interrupts and config index 1
	 * XXX - should really reset the PLX chip too.
	 */
	bus_space_write_1(memt, memh, WI_COR_OFFSET, WI_COR_VALUE);
@


1.7
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.6 2001/07/06 17:22:07 jason Exp $	*/
d65 3
a67 2
 * Global Sun Technology GL24110P02 (aka Linksys WDT11) and is
 * expected to work with the Global Sun GL24110P and Eumitcom WL11000P.
d133 1
@


1.6
log
@3com airconnect 3crwe777a
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.5 2001/06/23 01:54:48 millert Exp $	*/
d193 1
a193 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.5
log
@Disable interupts on the card before mapping and establishing the
interupt.  Fixes as race as noted by mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.4 2001/06/12 15:40:31 niklas Exp $	*/
d131 1
@


1.5.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.5 2001/06/23 01:54:48 millert Exp $	*/
d65 2
a66 3
 * Global Sun Technology GL24110P02 (aka Linksys WDT11), 3Com 3CRWE777A,
 * and Netgear MA301.  It is also expected to work with the
 * Global Sun GL24110P and Eumitcom WL11000P.
a109 1
#define WI_PCI_CBMA		0x10
a114 1
const struct wi_pci_product *wi_pci_lookup __P((struct pci_attach_args *pa));
a126 1
	int pp_plx;
d128 3
a130 6
	{ PCI_VENDOR_GLOBALSUN, PCI_PRODUCT_GLOBALSUN_GL24110P, 1 },
	{ PCI_VENDOR_GLOBALSUN, PCI_PRODUCT_GLOBALSUN_GL24110P02, 1 },
	{ PCI_VENDOR_EUMITCOM, PCI_PRODUCT_EUMITCOM_WL11000P, 1 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CRWE777A, 1 },
	{ PCI_VENDOR_NETGEAR, PCI_PRODUCT_NETGEAR_MA301, 1 },
	{ PCI_VENDOR_INTERSIL, PCI_PRODUCT_INTERSIL_MINI_PCI_WLAN, 0 },
d134 5
a138 3
const struct wi_pci_product *
wi_pci_lookup(pa)
	struct pci_attach_args *pa;
d140 1
d146 1
a146 1
			return (pp);
d149 1
a149 10
	return (NULL);
}

int
wi_pci_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	return (wi_pci_lookup(aux) != NULL);
a159 1
	const struct wi_pci_product *pp;
d168 10
a177 22
	pp = wi_pci_lookup(pa);
	if (pp->pp_plx) {
		/* Map memory and I/O registers. */
		if (pci_mapreg_map(pa, WI_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
		    &memt, &memh, NULL, NULL, 0) != 0) {
			printf(": can't map mem space\n");
			return;
		}
		if (pci_mapreg_map(pa, WI_PCI_LOIO, PCI_MAPREG_TYPE_IO, 0,
		    &iot, &ioh, NULL, NULL, 0) != 0) {
			printf(": can't map I/O space\n");
			return;
		}
	} else {
		if (pci_mapreg_map(pa, WI_PCI_CBMA, PCI_MAPREG_TYPE_MEM,
		    0, &iot, &ioh, NULL, NULL, 0) != 0) {
			printf(": can't map mem space\n");
			return;
		}

		memt = iot;
		memh = ioh;
a178 1

d192 2
a193 1
	if (pci_intr_map(pa, &ih)) {
d209 5
a213 13
	if (pp->pp_plx)
		/*
		 * Setup the PLX chip for level interrupts and config index 1
		 * XXX - should really reset the PLX chip too.
		 */
		bus_space_write_1(memt, memh,
		    WI_PLX_COR_OFFSET, WI_PLX_COR_VALUE);
	else {
		bus_space_write_2(iot, ioh, WI_PCI_COR, WI_PCI_SOFT_RESET);
		DELAY(100*1000); /* 100 m sec */
		bus_space_write_2(iot, ioh, WI_PCI_COR, 0x0);
		DELAY(100*1000); /* 100 m sec */
	}
@


1.5.2.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a136 1
	{ PCI_VENDOR_COREGA, PCI_PRODUCT_COREGA_CGWLPCIA11, 1 },
a203 1
		sc->sc_pci = 1;
d235 1
a235 1
	if (pp->pp_plx) {
d242 1
a242 3

		wi_attach(sc, 1);
	} else {
d247 1
d249 1
a249 2
		wi_attach(sc, 0);
	}
@


1.5.2.3
log
@Merge in -current from roughly a week ago
@
text
@d117 5
a121 5
const struct wi_pci_product *wi_pci_lookup(struct pci_attach_args *pa);
int	wi_pci_match(struct device *, void *, void *);
void	wi_pci_attach(struct device *, struct device *, void *);
int	wi_intr(void *);
int	wi_attach(struct wi_softc *, int);
@


1.5.2.4
log
@Sync the SMP branch with 3.3
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2003 Todd C. Miller <Todd.Miller@@courtesan.com>
d29 31
d62 17
a78 5
 * PCI attachment for the Wavelan driver.  There are two basic types
 * of PCI card supported:
 *
 * 1) Cards based on the Prism2.5 Mini-PCI chipset
 * 2) Cards that use a dumb PCMCIA->PCI bridge
d80 2
a81 11
 * Only the first type are "true" PCI cards.
 *
 * The latter are simply PCMCIA cards (or the guts of same) with some
 * type of dumb PCMCIA->PCI bridge.  They are "dumb" in that they
 * are not true PCMCIA bridges and really just serve to deal with
 * the different interrupt types and timings of the ISA vs. PCI bus.
 *
 * The following bridge types are supported:
 *  o PLX 9052 (the most common)
 *  o TMD 7160 (found in some NDC/Sohoware NCP130 cards)
 *  o ACEX EP1K30 (really a PLD, found in Symbol cards and their OEMs)
d111 5
a115 3
/* For printing CIS of the actual PCMCIA card */
#define CIS_MFG_NAME_OFFSET	0x16
#define CIS_INFO_SIZE		256
d120 2
a121 6
int	wi_pci_acex_attach(struct pci_attach_args *pa, struct wi_softc *sc);
int	wi_pci_plx_attach(struct pci_attach_args *pa, struct wi_softc *sc);
int	wi_pci_tmd_attach(struct pci_attach_args *pa, struct wi_softc *sc);
int	wi_pci_native_attach(struct pci_attach_args *pa, struct wi_softc *sc);
int	wi_pci_common_attach(struct pci_attach_args *pa, struct wi_softc *sc);
void	wi_pci_plx_print_cis(struct wi_softc *);
d130 1
a130 1
	int (*pp_attach)(struct pci_attach_args *pa, struct wi_softc *sc);
d132 8
a139 13
	{ PCI_VENDOR_GLOBALSUN, PCI_PRODUCT_GLOBALSUN_GL24110P, wi_pci_plx_attach },
	{ PCI_VENDOR_GLOBALSUN, PCI_PRODUCT_GLOBALSUN_GL24110P02, wi_pci_plx_attach },
	{ PCI_VENDOR_EUMITCOM, PCI_PRODUCT_EUMITCOM_WL11000P, wi_pci_plx_attach },
	{ PCI_VENDOR_USR2, PCI_PRODUCT_USR2_WL11000P, wi_pci_plx_attach },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CRWE777A, wi_pci_plx_attach },
	{ PCI_VENDOR_NETGEAR, PCI_PRODUCT_NETGEAR_MA301, wi_pci_plx_attach },
	{ PCI_VENDOR_EFFICIENTNETS, PCI_PRODUCT_EFFICIENTNETS_SS1023, wi_pci_plx_attach },
	{ PCI_VENDOR_NDC, PCI_PRODUCT_NDC_NCP130, wi_pci_plx_attach },
	{ PCI_VENDOR_NDC, PCI_PRODUCT_NDC_NCP130A2, wi_pci_tmd_attach },
	{ PCI_VENDOR_INTERSIL, PCI_PRODUCT_INTERSIL_MINI_PCI_WLAN, wi_pci_native_attach },
	{ PCI_VENDOR_NORTEL, PCI_PRODUCT_NORTEL_211818A, wi_pci_acex_attach },
	{ PCI_VENDOR_SYMBOL, PCI_PRODUCT_SYMBOL_LA41X3, wi_pci_acex_attach },
	{ 0, 0, 0 }
d143 2
a144 1
wi_pci_lookup(struct pci_attach_args *pa)
d158 4
a161 1
wi_pci_match(struct device *parent, void *match, void *aux)
d167 4
a170 1
wi_pci_attach(struct device *parent, struct device *self, void *aux)
d175 2
a176 119

	pp = wi_pci_lookup(pa);
	if (pp->pp_attach(pa, sc) != 0)
		return;
	wi_attach(sc);
}

/*
 * ACEX EP1K30-based PCMCIA->PCI bridge attachment.
 *
 * The ACEX EP1K30 is a programmable logic device (PLD) used as a
 * PCMCIA->PCI bridge on the Symbol LA4123 and its OEM equivalents
 * (such as the Nortel E-mobility 211818-A).  There are 3 I/O ports:
 * BAR0 at 0x10 appears to be a command port.
 * BAR1 at 0x14 contains COR at offset 0xe0.
 * BAR2 at 0x18 maps the actual PCMCIA card.
 *
 * The datasheet for the ACEX EP1K30 is available from Altera but that
 * doesn't really help much since we don't know how it is programmed.
 * Details for this attachment were gleaned from a version of the
 * Linux orinoco driver modified by Tobias Hoffmann based on
 * what he discoverd from the Windows driver.
 */
int
wi_pci_acex_attach(struct pci_attach_args *pa, struct wi_softc *sc)
{
	bus_space_handle_t commandh, localh, ioh;
	bus_space_tag_t commandt, localt;
	bus_space_tag_t iot = pa->pa_iot;
	bus_size_t commandsize;
	int i;

	if (pci_mapreg_map(pa, WI_ACEX_CMDRES, PCI_MAPREG_TYPE_IO,
	    0, &commandt, &commandh, NULL, &commandsize, 0) != 0) {
		printf(": can't map command I/O space\n");
		return (ENXIO);
	}

	if (pci_mapreg_map(pa, WI_ACEX_LOCALRES, PCI_MAPREG_TYPE_IO,
	    0, &localt, &localh, NULL, NULL, 0) != 0) {
		printf(": can't map local I/O space\n");
		return (ENXIO);
	}
	sc->wi_ltag = localt;
	sc->wi_lhandle = localh;

	if (pci_mapreg_map(pa, WI_TMD_IORES, PCI_MAPREG_TYPE_IO,
	    0, &iot, &ioh, NULL, NULL, 0) != 0) {
		printf(": can't map I/O space\n");
		return (ENXIO);
	}
	sc->wi_btag = iot;
	sc->wi_bhandle = ioh;

	/*
	 * Setup bridge chip.
	 */
	if (bus_space_read_4(commandt, commandh, 0) & 1) {
		printf(": bridge not ready\n");
		return (ENXIO);
	}
	bus_space_write_4(commandt, commandh, 2, 0x118);
	bus_space_write_4(commandt, commandh, 2, 0x108);
	DELAY(30 * 1000);
	bus_space_write_4(commandt, commandh, 2, 0x8);
	for (i = 0; i < 30; i++) {
		DELAY(30 * 1000);
		if (bus_space_read_4(commandt, commandh, 0) & 0x10)
			break;
	}
	if (i == 30) {
		printf(": bridge timeout\n");
		return (ENXIO);
	}
	if ((bus_space_read_4(localt, localh, 0xe0) & 1) ||
	    (bus_space_read_4(localt, localh, 0xe2) & 1) ||
	    (bus_space_read_4(localt, localh, 0xe4) & 1)) {
		printf(": failed bridge setup\n");
		return (ENXIO);
	}

	if (wi_pci_common_attach(pa, sc) != 0)
		return (ENXIO);

	/* 
	 * Enable I/O mode and level interrupts on the embedded PCMCIA
	 * card.
	 */
	bus_space_write_1(localt, localh, WI_ACEX_COR_OFFSET, WI_COR_IOMODE);
	sc->wi_cor_offset = WI_ACEX_COR_OFFSET;

	/* Unmap registers we no longer need access to. */
	bus_space_unmap(commandt, commandh, commandsize);

	return (0);
}

/*
 * PLX 9052-based PCMCIA->PCI bridge attachment.
 *
 * These are often sold as "PCI wireless card adapters" and are
 * sold by several vendors.  Most are simply rebadged versions of the
 * Eumitcom WL11000P or Global Sun Technology GL24110P02.
 * These cards use the PLX 9052 dumb bridge chip to connect a PCMCIA
 * wireless card to the PCI bus.  Because it is a dumb bridge and
 * not a true PCMCIA bridge, the PCMCIA subsystem is not involved
 * (or even required).  The PLX 9052 provides multiple PCI address
 * space mappings.  The primary mappings at PCI registers 0x10 (mem)
 * and 0x14 (I/O) are for the PLX chip itself, *NOT* the PCMCIA card.
 * The mem and I/O spaces for the PCMCIA card are mapped to 0x18 and
 * 0x1C respectively.
 * The PLX 9050/9052 datasheet may be downloaded from PLX at
 *	http://www.plxtech.com/products/toolbox/9050.htm
 */
int
wi_pci_plx_attach(struct pci_attach_args *pa, struct wi_softc *sc)
{
	bus_space_handle_t localh, ioh, memh;
	bus_space_tag_t localt;
d179 3
a181 11
	bus_addr_t localbase;
	bus_size_t localsize;
	u_int32_t intcsr;

	if (pci_mapreg_map(pa, WI_PLX_MEMRES, PCI_MAPREG_TYPE_MEM, 0,
	    &memt, &memh, NULL, NULL, 0) != 0) {
		printf(": can't map mem space\n");
		return (ENXIO);
	}
	sc->wi_ltag = memt;
	sc->wi_lhandle = memh;
d183 7
a189 28
	if (pci_mapreg_map(pa, WI_PLX_IORES,
	    PCI_MAPREG_TYPE_IO, 0, &iot, &ioh, NULL, NULL, 0) != 0) {
		printf(": can't map I/O space\n");
		return (ENXIO);
	}
	sc->wi_btag = iot;
	sc->wi_bhandle = ioh;

	/*
	 * Some cards, such as the PLX version of the NDC NCP130,
	 * don't have the PLX local registers mapped.  In general
	 * this is OK since on those cards the serial EEPROM has
	 * already set things up for us.
	 * As such, we don't consider an error here to be fatal.
	 */
	localsize = 0;
	if (pci_mapreg_type(pa->pa_pc, pa->pa_tag, WI_PLX_LOCALRES)
	    == PCI_MAPREG_TYPE_IO) {
		if (pci_io_find(pa->pa_pc, pa->pa_tag,
		    WI_PLX_LOCALRES, &localbase, &localsize) != 0)
			printf(": can't find PLX I/O space\n");
		if (localsize != 0) {
			if (bus_space_map(pa->pa_iot, localbase,
			    localsize, 0, &localh) != 0) {
				printf(": can't map PLX I/O space\n");
				localsize = 0;
			} else
				localt = pa->pa_iot;
d191 4
a194 20
	}

	if (wi_pci_common_attach(pa, sc) != 0)
		return (ENXIO);

	if (localsize != 0) {
		intcsr = bus_space_read_4(localt, localh,
		    WI_PLX_INTCSR);

		/*
		 * The Netgear MA301 has local interrupt 1 active
		 * when there is no card in the adapter.  We bail
		 * early in this case since our attempt to check
		 * for the presence of a card later will hang the
		 * MA301.
		 */
		if (intcsr & WI_PLX_LINT1STAT) {
			printf("\n%s: no PCMCIA card detected in bridge card\n",
			    WI_PRT_ARG(sc));
			return (ENXIO);
d196 5
a200 33

		/*
		 * Enable PCI interrupts on the PLX chip if they are
		 * not already enabled. On most adapters the serial
		 * EEPROM has done this for us but some (such as
		 * the Netgear MA301) do not.
		 */
		if (!(intcsr & WI_PLX_INTEN)) {
			intcsr |= WI_PLX_INTEN;
			bus_space_write_4(localt, localh, WI_PLX_INTCSR,
			    intcsr);
		}
	}

	/*
	 * Enable I/O mode and level interrupts on the PCMCIA card.
	 * The PCMCIA card's COR is the first byte after the CIS.
	 */
	bus_space_write_1(memt, memh, WI_PLX_COR_OFFSET, WI_COR_IOMODE);
	sc->wi_cor_offset = WI_PLX_COR_OFFSET;

	if (localsize != 0) {
		/*
		 * Test the presence of a wi(4) card by writing
		 * a magic number to the first software support
		 * register and then reading it back.
		 */
		CSR_WRITE_2(sc, WI_SW0, WI_DRVR_MAGIC);
		DELAY(1000);
		if (CSR_READ_2(sc, WI_SW0) != WI_DRVR_MAGIC) {
			printf("\n%s: no PCMCIA card detected in bridge card\n",
			    WI_PRT_ARG(sc));
			return (ENXIO);
d203 3
a205 42
		/* Unmap registers we no longer need access to. */
		bus_space_unmap(localt, localh, localsize);

		/* Print PCMCIA card's CIS strings. */
		wi_pci_plx_print_cis(sc);
	}

	return (0);
}

/*
 * TMD 7160-based PCMCIA->PCI bridge attachment.
 *
 * The TMD7160 dumb bridge chip is used on some versions of the
 * NDC/Sohoware NCP130.  The TMD7160 provides two PCI I/O registers.
 * The first, at 0x14, maps to the Prism2 COR.
 * The second, at 0x18, is for the Prism2 chip itself.
 *
 * The datasheet for the TMD7160 does not seem to be publicly available.
 * Details for this attachment were gleaned from a version of the
 * Linux WLAN driver modified by NDC.
 */
int
wi_pci_tmd_attach(struct pci_attach_args *pa, struct wi_softc *sc)
{
	bus_space_handle_t localh, ioh;
	bus_space_tag_t localt;
	bus_space_tag_t iot = pa->pa_iot;
	bus_size_t localsize;

	if (pci_mapreg_map(pa, WI_TMD_LOCALRES, PCI_MAPREG_TYPE_IO,
	    0, &localt, &localh, NULL, &localsize, 0) != 0) {
		printf(": can't map TMD I/O space\n");
		return (ENXIO);
	}
	sc->wi_ltag = localt;
	sc->wi_lhandle = localh;

	if (pci_mapreg_map(pa, WI_TMD_IORES, PCI_MAPREG_TYPE_IO,
	    0, &iot, &ioh, NULL, NULL, 0) != 0) {
		printf(": can't map I/O space\n");
		return (ENXIO);
a206 5
	sc->wi_btag = iot;
	sc->wi_bhandle = ioh;

	if (wi_pci_common_attach(pa, sc) != 0)
		return (ENXIO);
a207 23
	/* 
	 * Enable I/O mode and level interrupts on the embedded PCMCIA
	 * card.  The PCMCIA card's COR is the first byte of BAR 0.
	 */
	bus_space_write_1(localt, localh, 0, WI_COR_IOMODE);
	sc->wi_cor_offset = 0;

	return (0);
}

int
wi_pci_native_attach(struct pci_attach_args *pa, struct wi_softc *sc)
{
	bus_space_handle_t ioh;
	bus_space_tag_t iot = pa->pa_iot;

	if (pci_mapreg_map(pa, WI_PCI_CBMA, PCI_MAPREG_TYPE_MEM,
	    0, &iot, &ioh, NULL, NULL, 0) != 0) {
		printf(": can't map mem space\n");
		return (ENXIO);
	}
	sc->wi_ltag = iot;
	sc->wi_lhandle = ioh;
a209 14
	sc->sc_pci = 1;

	if (wi_pci_common_attach(pa, sc) != 0)
		return (ENXIO);

	/* Do a soft reset of the HFA3842 MAC core */
	bus_space_write_2(iot, ioh, WI_PCI_COR_OFFSET, WI_COR_SOFT_RESET);
	DELAY(100*1000); /* 100 m sec */
	bus_space_write_2(iot, ioh, WI_PCI_COR_OFFSET, WI_COR_CLEAR);
	DELAY(100*1000); /* 100 m sec */
	sc->wi_cor_offset = WI_PCI_COR_OFFSET;

	return (0);
}
d211 4
a214 6
int
wi_pci_common_attach(struct pci_attach_args *pa, struct wi_softc *sc)
{
	pci_intr_handle_t ih;
	pci_chipset_tag_t pc = pa->pa_pc;
	const char *intrstr;
d223 1
a223 1
		return (ENXIO);
d233 1
a233 1
		return (ENXIO);
d237 7
a243 2
	return (0);
}
d245 6
a250 17
void
wi_pci_plx_print_cis(struct wi_softc *sc)
{
	int i, stringno;
	char cisbuf[CIS_INFO_SIZE];
	char *cis_strings[3];
	u_int8_t value;
	const u_int8_t cis_magic[] = {
		0x01, 0x03, 0x00, 0x00, 0xff, 0x17, 0x04, 0x67
	};

	/* Make sure the CIS data is valid. */
	for (i = 0; i < 8; i++) {
		value = bus_space_read_1(sc->wi_ltag, sc->wi_lhandle, i * 2);
		if (value != cis_magic[i])
			return;
	}
d252 1
a252 7
	cis_strings[0] = cisbuf;
	stringno = 0;
	for (i = 0; i < CIS_INFO_SIZE && stringno < 3; i++) {
		cisbuf[i] = bus_space_read_1(sc->wi_ltag,
		    sc->wi_lhandle, (CIS_MFG_NAME_OFFSET + i) * 2);
		if (cisbuf[i] == '\0' && ++stringno < 3)
			cis_strings[stringno] = &cisbuf[i + 1];
a253 3
	cisbuf[CIS_INFO_SIZE - 1] = '\0';
	printf("\n%s: \"%s, %s, %s\"", WI_PRT_ARG(sc),
	    cis_strings[0], cis_strings[1], cis_strings[2]);
@


1.5.2.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.5.2.4 2003/03/28 00:38:22 niklas Exp $	*/
d170 1
a170 1
	bus_size_t commandsize, localsize, iosize;
d180 1
a180 1
	    0, &localt, &localh, NULL, &localsize, 0) != 0) {
a181 1
		bus_space_unmap(commandt, commandh, commandsize);
d188 1
a188 1
	    0, &iot, &ioh, NULL, &iosize, 0) != 0) {
a189 2
		bus_space_unmap(localt, localh, localsize);
		bus_space_unmap(commandt, commandh, commandsize);
a199 3
		bus_space_unmap(iot, ioh, iosize);
		bus_space_unmap(localt, localh, localsize);
		bus_space_unmap(commandt, commandh, commandsize);
a212 3
		bus_space_unmap(iot, ioh, iosize);
		bus_space_unmap(localt, localh, localsize);
		bus_space_unmap(commandt, commandh, commandsize);
a218 3
		bus_space_unmap(iot, ioh, iosize);
		bus_space_unmap(localt, localh, localsize);
		bus_space_unmap(commandt, commandh, commandsize);
d222 1
a222 4
	if (wi_pci_common_attach(pa, sc) != 0) {
		bus_space_unmap(iot, ioh, iosize);
		bus_space_unmap(localt, localh, localsize);
		bus_space_unmap(commandt, commandh, commandsize);
a223 1
	}
d263 1
a263 1
	bus_size_t localsize, memsize, iosize;
d267 1
a267 1
	    &memt, &memh, NULL, &memsize, 0) != 0) {
d275 1
a275 1
	    PCI_MAPREG_TYPE_IO, 0, &iot, &ioh, NULL, &iosize, 0) != 0) {
a276 1
		bus_space_unmap(memt, memh, memsize);
d305 1
a305 5
	if (wi_pci_common_attach(pa, sc) != 0) {
		if (localsize)
			bus_space_unmap(localt, localh, localsize);
		bus_space_unmap(iot, ioh, iosize);
		bus_space_unmap(memt, memh, memsize);
a306 1
	}
a321 5
			pci_intr_disestablish(pa->pa_pc, sc->sc_ih);
			if (localsize)
				bus_space_unmap(localt, localh, localsize);
			bus_space_unmap(iot, ioh, iosize);
			bus_space_unmap(memt, memh, memsize);
a355 5
			pci_intr_disestablish(pa->pa_pc, sc->sc_ih);
			if (localsize)
				bus_space_unmap(localt, localh, localsize);
			bus_space_unmap(iot, ioh, iosize);
			bus_space_unmap(memt, memh, memsize);
d387 1
a387 1
	bus_size_t localsize, iosize;
d398 1
a398 1
	    0, &iot, &ioh, NULL, &iosize, 0) != 0) {
a399 1
		bus_space_unmap(localt, localh, localsize);
d405 1
a405 3
	if (wi_pci_common_attach(pa, sc) != 0) {
		bus_space_unmap(iot, ioh, iosize);
		bus_space_unmap(localt, localh, localsize);
a406 1
	}
a422 1
	bus_size_t iosize;
d425 1
a425 1
	    0, &iot, &ioh, NULL, &iosize, 0) != 0) {
d435 1
a435 2
	if (wi_pci_common_attach(pa, sc) != 0) {
		bus_space_unmap(iot, ioh, iosize);
a436 1
	}
@


1.5.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.5.2.5 2003/05/13 19:35:06 ho Exp $	*/
d5 1
d7 10
a16 3
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
d18 10
a27 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.5.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d10 7
a16 11
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
d134 1
a134 1
	wi_attach(sc, &wi_func_io);
@


1.4
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.3 2001/06/11 00:50:38 millert Exp $	*/
d98 2
d187 4
a207 4

	/* Make sure interrupts are disabled. */
	CSR_WRITE_2(sc, WI_INT_EN, 0);
	CSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);
@


1.3
log
@For PCI attachments print the CIS strings since otherwise all we have
is info on the PCI -> PCMCIA dumb bridge and not the card itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.2 2001/06/07 04:55:06 millert Exp $	*/
d168 1
a168 1
	    &memt, &memh, NULL, NULL) != 0) {
d173 1
a173 1
	    &iot, &ioh, NULL, NULL) != 0) {
@


1.2
log
@no longer need to set sc_prism2 manually
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_pci.c,v 1.1 2001/06/06 18:53:50 millert Exp $	*/
d116 1
a116 1
int	wi_attach	__P((struct wi_softc *));
d213 1
a213 1
	wi_attach(sc);
@


1.1
log
@PCI shim for if_wi.c as	promised.  Magic for setting the PLX up
correctly take from the FreeBSD driver and explained by imp@@
Currently this is hard-coded for PrismII cards but that will change
when the PrismII auto-detect code is added to if_wi.c.
Tested with a LinkSys WPC11 in a Global Sun GL24110P02 (aka LinSys WDT11)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a164 2

	sc->sc_prism2 = 1;		/* All PCI flavors of wi are Prism2 */
@

