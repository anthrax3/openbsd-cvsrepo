head	1.111;
access;
symbols
	OPENBSD_6_2:1.111.0.10
	OPENBSD_6_2_BASE:1.111
	OPENBSD_6_1:1.111.0.8
	OPENBSD_6_1_BASE:1.111
	OPENBSD_6_0:1.111.0.6
	OPENBSD_6_0_BASE:1.111
	OPENBSD_5_9:1.111.0.2
	OPENBSD_5_9_BASE:1.111
	OPENBSD_5_8:1.109.0.6
	OPENBSD_5_8_BASE:1.109
	OPENBSD_5_7:1.109.0.4
	OPENBSD_5_7_BASE:1.109
	OPENBSD_5_6:1.103.0.4
	OPENBSD_5_6_BASE:1.103
	OPENBSD_5_5:1.101.0.4
	OPENBSD_5_5_BASE:1.101
	OPENBSD_5_4:1.98.0.4
	OPENBSD_5_4_BASE:1.98
	OPENBSD_5_3:1.98.0.2
	OPENBSD_5_3_BASE:1.98
	OPENBSD_5_2:1.94.0.4
	OPENBSD_5_2_BASE:1.94
	OPENBSD_5_1_BASE:1.94
	OPENBSD_5_1:1.94.0.2
	OPENBSD_5_0:1.93.0.2
	OPENBSD_5_0_BASE:1.93
	OPENBSD_4_9:1.88.0.2
	OPENBSD_4_9_BASE:1.88
	OPENBSD_4_8:1.80.0.2
	OPENBSD_4_8_BASE:1.80
	OPENBSD_4_7:1.73.0.2
	OPENBSD_4_7_BASE:1.73
	OPENBSD_4_6:1.63.0.4
	OPENBSD_4_6_BASE:1.63
	OPENBSD_4_5:1.59.0.2
	OPENBSD_4_5_BASE:1.59
	OPENBSD_4_4:1.58.0.2
	OPENBSD_4_4_BASE:1.58
	OPENBSD_4_3:1.56.0.2
	OPENBSD_4_3_BASE:1.56
	OPENBSD_4_2:1.50.0.2
	OPENBSD_4_2_BASE:1.50
	OPENBSD_4_1:1.49.0.2
	OPENBSD_4_1_BASE:1.49
	OPENBSD_4_0:1.46.0.2
	OPENBSD_4_0_BASE:1.46
	OPENBSD_3_9:1.39.0.4
	OPENBSD_3_9_BASE:1.39
	OPENBSD_3_8:1.39.0.2
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_7:1.36.0.2
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.34.0.2
	OPENBSD_3_6_BASE:1.34
	SMP_SYNC_A:1.33
	SMP_SYNC_B:1.33
	OPENBSD_3_5:1.33.0.4
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	UBC_SYNC_A:1.33
	OPENBSD_3_3:1.32.0.2
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.29.0.4
	OPENBSD_3_2_BASE:1.29
	OPENBSD_3_1:1.29.0.2
	OPENBSD_3_1_BASE:1.29
	UBC_SYNC_B:1.29
	UBC:1.22.0.4
	UBC_BASE:1.22
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.15.0.8
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.15.0.6
	OPENBSD_2_7_BASE:1.15
	SMP:1.15.0.4
	SMP_BASE:1.15
	kame_19991208:1.15
	OPENBSD_2_6:1.15.0.2
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.111
date	2015.11.27.15.28.22;	author kettenis;	state Exp;
branches;
next	1.110;
commitid	gk5YxckAjaHvINRp;

1.110
date	2015.09.10.10.36.48;	author deraadt;	state Exp;
branches;
next	1.109;
commitid	4LX3ve9lQvWDD0lG;

1.109
date	2014.11.27.19.03.44;	author kettenis;	state Exp;
branches;
next	1.108;
commitid	16DTkzAekrcY5tNZ;

1.108
date	2014.11.26.09.29.17;	author kettenis;	state Exp;
branches;
next	1.107;
commitid	wUf6p0PRFQwOQE0u;

1.107
date	2014.11.24.13.48.49;	author kettenis;	state Exp;
branches;
next	1.106;
commitid	2oVxM2atfRPONWr2;

1.106
date	2014.10.26.16.18.42;	author kettenis;	state Exp;
branches;
next	1.105;
commitid	Pdh1QYykJ0hje2VL;

1.105
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.104;
commitid	uzzBR7hz9ncd4O6G;

1.104
date	2014.09.13.16.06.37;	author doug;	state Exp;
branches;
next	1.103;
commitid	jdBY2kKXhfcoQitp;

1.103
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.102;
commitid	OBNa5kfxQ2UXoiIw;

1.102
date	2014.05.04.20.09.15;	author sf;	state Exp;
branches;
next	1.101;

1.101
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2013.11.06.10.41.16;	author mpi;	state Exp;
branches;
next	1.99;

1.99
date	2013.08.08.17.54.11;	author kettenis;	state Exp;
branches;
next	1.98;

1.98
date	2013.02.09.20.43.33;	author miod;	state Exp;
branches;
next	1.97;

1.97
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2012.09.19.23.01.21;	author kettenis;	state Exp;
branches;
next	1.95;

1.95
date	2012.09.07.19.26.48;	author kettenis;	state Exp;
branches;
next	1.94;

1.94
date	2011.10.10.19.42.37;	author miod;	state Exp;
branches;
next	1.93;

1.93
date	2011.06.12.11.13.28;	author kettenis;	state Exp;
branches;
next	1.92;

1.92
date	2011.05.30.19.09.46;	author kettenis;	state Exp;
branches;
next	1.91;

1.91
date	2011.05.19.20.14.55;	author kettenis;	state Exp;
branches;
next	1.90;

1.90
date	2011.05.14.13.23.38;	author kettenis;	state Exp;
branches;
next	1.89;

1.89
date	2011.04.12.20.29.35;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2010.12.30.00.58.22;	author kettenis;	state Exp;
branches;
next	1.87;

1.87
date	2010.12.04.17.08.20;	author miod;	state Exp;
branches;
next	1.86;

1.86
date	2010.09.07.16.21.45;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2010.09.06.19.20.23;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2010.09.05.18.14.33;	author kettenis;	state Exp;
branches;
next	1.83;

1.83
date	2010.08.31.17.13.44;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2010.08.27.20.31.55;	author kettenis;	state Exp;
branches;
next	1.81;

1.81
date	2010.08.17.19.14.52;	author kettenis;	state Exp;
branches;
next	1.80;

1.80
date	2010.07.02.04.03.31;	author kettenis;	state Exp;
branches;
next	1.79;

1.79
date	2010.07.02.03.10.47;	author tedu;	state Exp;
branches;
next	1.78;

1.78
date	2010.06.30.04.31.37;	author mlarkin;	state Exp;
branches;
next	1.77;

1.77
date	2010.06.29.22.08.29;	author jordan;	state Exp;
branches;
next	1.76;

1.76
date	2010.04.21.23.12.24;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2010.04.21.21.16.43;	author kettenis;	state Exp;
branches;
next	1.74;

1.74
date	2010.04.21.18.55.40;	author kettenis;	state Exp;
branches;
next	1.73;

1.73
date	2010.01.26.17.47.36;	author otto;	state Exp;
branches;
next	1.72;

1.72
date	2010.01.13.06.12.48;	author kettenis;	state Exp;
branches;
next	1.71;

1.71
date	2009.11.23.22.34.23;	author mlarkin;	state Exp;
branches;
next	1.70;

1.70
date	2009.11.23.15.24.01;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2009.11.23.01.28.11;	author mlarkin;	state Exp;
branches;
next	1.68;

1.68
date	2009.11.05.20.30.47;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2009.07.26.13.21.18;	author kettenis;	state Exp;
branches;
next	1.66;

1.66
date	2009.07.25.12.51.41;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2009.07.18.16.19.28;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2009.07.14.18.20.02;	author kettenis;	state Exp;
branches;
next	1.63;

1.63
date	2009.06.29.19.19.17;	author kettenis;	state Exp;
branches;
next	1.62;

1.62
date	2009.06.03.06.09.21;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2009.05.05.14.16.17;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2009.04.06.20.51.48;	author kettenis;	state Exp;
branches;
next	1.59;

1.59
date	2008.12.28.18.26.53;	author kettenis;	state Exp;
branches;
next	1.58;

1.58
date	2008.06.13.08.45.50;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2008.06.13.08.45.12;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2008.02.27.21.11.11;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2007.12.31.19.13.36;	author kettenis;	state Exp;
branches;
next	1.54;

1.54
date	2007.11.30.14.28.24;	author kettenis;	state Exp;
branches;
next	1.53;

1.53
date	2007.11.26.13.20.28;	author jsg;	state Exp;
branches;
next	1.52;

1.52
date	2007.11.17.23.20.38;	author brad;	state Exp;
branches;
next	1.51;

1.51
date	2007.10.22.03.08.53;	author fgsch;	state Exp;
branches;
next	1.50;

1.50
date	2007.05.21.22.10.45;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2006.12.14.17.36.12;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2006.12.11.19.47.37;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2006.10.04.19.27.44;	author kettenis;	state Exp;
branches;
next	1.46;

1.46
date	2006.07.04.18.07.29;	author kettenis;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.22.00.36.03;	author jsg;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.20.01.53.24;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.19.22.06.12;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2006.03.19.21.25.04;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.19.02.43.38;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.11.22.08.07;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2005.07.10.19.03.09;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2005.06.29.03.18.49;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.02.11.30.25;	author grange;	state Exp;
branches;
next	1.36;

1.36
date	2004.12.08.15.38.41;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2004.12.07.02.11.24;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2004.06.25.08.57.10;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.32;

1.32
date	2003.02.28.15.26.23;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2003.02.28.15.14.08;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2002.04.04.17.11.46;	author jason;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.27.15.10.44;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.23.16.59.36;	author matthieu;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.18.23.23.46;	author matthieu;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.18.23.09.30;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.18.21.51.18;	author matthieu;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.25.12.48.35;	author art;	state Exp;
branches
	1.22.4.1;
next	1.21;

1.21
date	2001.07.20.05.56.25;	author csapuntz;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.26.22.22.41;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.24.16.15.56;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.24.04.18.41;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.23.03.30.37;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.27.05.02.39;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	99.07.18.03.20.18;	author csapuntz;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	98.10.29.18.11.53;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	98.08.22.17.59.04;	author rahnds;	state Exp;
branches;
next	1.12;

1.12
date	98.06.26.01.50.59;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.01.20.18.40.34;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	98.01.07.11.03.32;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.01.05.13.35.23;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.10.11.09.14.53;	author pefo;	state Exp;
branches;
next	1.7;

1.7
date	97.10.10.10.56.41;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	97.01.24.19.34.15;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.11.28.23.28.09;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.21.47.05;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.05.07.07.38.49;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.22.25.34;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.04.18.23.48.02;	author niklas;	state Exp;
branches;
next	;

1.15.4.1
date	2001.05.14.22.25.52;	author niklas;	state Exp;
branches;
next	1.15.4.2;

1.15.4.2
date	2001.07.04.10.42.45;	author niklas;	state Exp;
branches;
next	1.15.4.3;

1.15.4.3
date	2001.10.31.03.22.47;	author nate;	state Exp;
branches;
next	1.15.4.4;

1.15.4.4
date	2002.03.06.02.11.46;	author niklas;	state Exp;
branches;
next	1.15.4.5;

1.15.4.5
date	2002.03.28.15.35.58;	author niklas;	state Exp;
branches;
next	1.15.4.6;

1.15.4.6
date	2003.03.28.00.38.23;	author niklas;	state Exp;
branches;
next	1.15.4.7;

1.15.4.7
date	2003.05.13.19.35.07;	author ho;	state Exp;
branches;
next	;

1.22.4.1
date	2002.06.11.03.42.26;	author art;	state Exp;
branches;
next	1.22.4.2;

1.22.4.2
date	2003.05.19.22.18.01;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.111
log
@Don't report a bus conflict for bridges that are left (partly) unconfigured by
the system firmware.
@
text
@/*	$OpenBSD: pci.c,v 1.110 2015/09/10 10:36:48 deraadt Exp $	*/
/*	$NetBSD: pci.c,v 1.31 1997/06/06 23:48:04 thorpej Exp $	*/

/*
 * Copyright (c) 1995, 1996 Christopher G. Demetriou.  All rights reserved.
 * Copyright (c) 1994 Charles Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * PCI bus autoconfiguration.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/ppbreg.h>

int pcimatch(struct device *, void *, void *);
void pciattach(struct device *, struct device *, void *);
int pcidetach(struct device *, int);
int pciactivate(struct device *, int);
void pci_suspend(struct pci_softc *);
void pci_powerdown(struct pci_softc *);
void pci_resume(struct pci_softc *);

#define NMAPREG			((PCI_MAPREG_END - PCI_MAPREG_START) / \
				    sizeof(pcireg_t))
struct pci_dev {
	struct device *pd_dev;
	LIST_ENTRY(pci_dev) pd_next;
	pcitag_t pd_tag;        /* pci register tag */
	pcireg_t pd_csr;
	pcireg_t pd_bhlc;
	pcireg_t pd_int;
	pcireg_t pd_map[NMAPREG];
	pcireg_t pd_mask[NMAPREG];
	pcireg_t pd_msi_mc;
	pcireg_t pd_msi_ma;
	pcireg_t pd_msi_mau32;
	pcireg_t pd_msi_md;
	int pd_pmcsr_state;
	int pd_vga_decode;
};

#ifdef APERTURE
extern int allowaperture;
#endif

struct cfattach pci_ca = {
	sizeof(struct pci_softc), pcimatch, pciattach, pcidetach, pciactivate
};

struct cfdriver pci_cd = {
	NULL, "pci", DV_DULL
};

int	pci_ndomains;

struct proc *pci_vga_proc;
struct pci_softc *pci_vga_pci;
pcitag_t pci_vga_tag;

int	pci_dopm;

int	pciprint(void *, const char *);
int	pcisubmatch(struct device *, void *, void *);

#ifdef PCI_MACHDEP_ENUMERATE_BUS
#define pci_enumerate_bus PCI_MACHDEP_ENUMERATE_BUS
#else
int pci_enumerate_bus(struct pci_softc *,
    int (*)(struct pci_attach_args *), struct pci_attach_args *);
#endif
int	pci_reserve_resources(struct pci_attach_args *);
int	pci_primary_vga(struct pci_attach_args *);

/*
 * Important note about PCI-ISA bridges:
 *
 * Callbacks are used to configure these devices so that ISA/EISA bridges
 * can attach their child busses after PCI configuration is done.
 *
 * This works because:
 *	(1) there can be at most one ISA/EISA bridge per PCI bus, and
 *	(2) any ISA/EISA bridges must be attached to primary PCI
 *	    busses (i.e. bus zero).
 *
 * That boils down to: there can only be one of these outstanding
 * at a time, it is cleared when configuring PCI bus 0 before any
 * subdevices have been found, and it is run after all subdevices
 * of PCI bus 0 have been found.
 *
 * This is needed because there are some (legacy) PCI devices which
 * can show up as ISA/EISA devices as well (the prime example of which
 * are VGA controllers).  If you attach ISA from a PCI-ISA/EISA bridge,
 * and the bridge is seen before the video board is, the board can show
 * up as an ISA device, and that can (bogusly) complicate the PCI device's
 * attach code, or make the PCI device not be properly attached at all.
 *
 * We use the generic config_defer() facility to achieve this.
 */

int
pcimatch(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct pcibus_attach_args *pba = aux;

	if (strcmp(pba->pba_busname, cf->cf_driver->cd_name))
		return (0);

	/* Check the locators */
	if (cf->pcibuscf_bus != PCIBUS_UNK_BUS &&
	    cf->pcibuscf_bus != pba->pba_bus)
		return (0);

	/* sanity */
	if (pba->pba_bus < 0 || pba->pba_bus > 255)
		return (0);

	/*
	 * XXX check other (hardware?) indicators
	 */

	return (1);
}

void
pciattach(struct device *parent, struct device *self, void *aux)
{
	struct pcibus_attach_args *pba = aux;
	struct pci_softc *sc = (struct pci_softc *)self;

	pci_attach_hook(parent, self, pba);

	printf("\n");

	LIST_INIT(&sc->sc_devs);

	sc->sc_iot = pba->pba_iot;
	sc->sc_memt = pba->pba_memt;
	sc->sc_dmat = pba->pba_dmat;
	sc->sc_pc = pba->pba_pc;
	sc->sc_flags = pba->pba_flags;
	sc->sc_ioex = pba->pba_ioex;
	sc->sc_memex = pba->pba_memex;
	sc->sc_pmemex = pba->pba_pmemex;
	sc->sc_busex = pba->pba_busex;
	sc->sc_domain = pba->pba_domain;
	sc->sc_bus = pba->pba_bus;
	sc->sc_bridgetag = pba->pba_bridgetag;
	sc->sc_bridgeih = pba->pba_bridgeih;
	sc->sc_maxndevs = pci_bus_maxdevs(pba->pba_pc, pba->pba_bus);
	sc->sc_intrswiz = pba->pba_intrswiz;
	sc->sc_intrtag = pba->pba_intrtag;

	/* Reserve our own bus number. */
	if (sc->sc_busex)
		extent_alloc_region(sc->sc_busex, sc->sc_bus, 1, EX_NOWAIT);

	pci_enumerate_bus(sc, pci_reserve_resources, NULL);

	/* Find the VGA device that's currently active. */
	if (pci_enumerate_bus(sc, pci_primary_vga, NULL))
		pci_vga_pci = sc;

	pci_enumerate_bus(sc, NULL, NULL);
}

int
pcidetach(struct device *self, int flags)
{
	return pci_detach_devices((struct pci_softc *)self, flags);
}

int
pciactivate(struct device *self, int act)
{
	int rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);
		pci_suspend((struct pci_softc *)self);
		break;
	case DVACT_RESUME:
		pci_resume((struct pci_softc *)self);
		rv = config_activate_children(self, act);
		break;
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		pci_powerdown((struct pci_softc *)self);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

void
pci_suspend(struct pci_softc *sc)
{
	struct pci_dev *pd;
	pcireg_t bhlc, reg;
	int off, i;

	LIST_FOREACH(pd, &sc->sc_devs, pd_next) {
		/*
		 * Only handle header type 0 here; PCI-PCI bridges and
		 * CardBus bridges need special handling, which will
		 * be done in their specific drivers.
		 */
		bhlc = pci_conf_read(sc->sc_pc, pd->pd_tag, PCI_BHLC_REG);
		if (PCI_HDRTYPE_TYPE(bhlc) != 0)
			continue;

		/* Save registers that may get lost. */
		for (i = 0; i < NMAPREG; i++)
			pd->pd_map[i] = pci_conf_read(sc->sc_pc, pd->pd_tag,
			    PCI_MAPREG_START + (i * 4));
		pd->pd_csr = pci_conf_read(sc->sc_pc, pd->pd_tag,
		    PCI_COMMAND_STATUS_REG);
		pd->pd_bhlc = pci_conf_read(sc->sc_pc, pd->pd_tag,
		    PCI_BHLC_REG);
		pd->pd_int = pci_conf_read(sc->sc_pc, pd->pd_tag,
		    PCI_INTERRUPT_REG);

		if (pci_get_capability(sc->sc_pc, pd->pd_tag,
		    PCI_CAP_MSI, &off, &reg)) {
			pd->pd_msi_ma = pci_conf_read(sc->sc_pc, pd->pd_tag,
			    off + PCI_MSI_MA);
			if (reg & PCI_MSI_MC_C64) {
				pd->pd_msi_mau32 = pci_conf_read(sc->sc_pc,
				    pd->pd_tag, off + PCI_MSI_MAU32);
				pd->pd_msi_md = pci_conf_read(sc->sc_pc,
				    pd->pd_tag, off + PCI_MSI_MD64);
			} else {
				pd->pd_msi_md = pci_conf_read(sc->sc_pc,
				    pd->pd_tag, off + PCI_MSI_MD32);
			}
			pd->pd_msi_mc = reg;
		}
	}
}

void
pci_powerdown(struct pci_softc *sc)
{
	struct pci_dev *pd;
	pcireg_t bhlc;

	LIST_FOREACH(pd, &sc->sc_devs, pd_next) {
		/*
		 * Only handle header type 0 here; PCI-PCI bridges and
		 * CardBus bridges need special handling, which will
		 * be done in their specific drivers.
		 */
		bhlc = pci_conf_read(sc->sc_pc, pd->pd_tag, PCI_BHLC_REG);
		if (PCI_HDRTYPE_TYPE(bhlc) != 0)
			continue;

		if (pci_dopm) {
			/*
			 * Place the device into the lowest possible
			 * power state.
			 */
			pd->pd_pmcsr_state = pci_get_powerstate(sc->sc_pc,
			    pd->pd_tag);
			pci_set_powerstate(sc->sc_pc, pd->pd_tag,
			    pci_min_powerstate(sc->sc_pc, pd->pd_tag));
		}
	}
}

void
pci_resume(struct pci_softc *sc)
{
	struct pci_dev *pd;
	pcireg_t bhlc, reg;
	int off, i;

	LIST_FOREACH(pd, &sc->sc_devs, pd_next) {
		/*
		 * Only handle header type 0 here; PCI-PCI bridges and
		 * CardBus bridges need special handling, which will
		 * be done in their specific drivers.
		 */
		bhlc = pci_conf_read(sc->sc_pc, pd->pd_tag, PCI_BHLC_REG);
		if (PCI_HDRTYPE_TYPE(bhlc) != 0)
			continue;

		/* Restore power. */
		if (pci_dopm)
			pci_set_powerstate(sc->sc_pc, pd->pd_tag,
			    pd->pd_pmcsr_state);

		/* Restore the registers saved above. */
		for (i = 0; i < NMAPREG; i++)
			pci_conf_write(sc->sc_pc, pd->pd_tag,
			    PCI_MAPREG_START + (i * 4), pd->pd_map[i]);
		reg = pci_conf_read(sc->sc_pc, pd->pd_tag,
		    PCI_COMMAND_STATUS_REG);
		pci_conf_write(sc->sc_pc, pd->pd_tag, PCI_COMMAND_STATUS_REG,
		    (reg & 0xffff0000) | (pd->pd_csr & 0x0000ffff));
		pci_conf_write(sc->sc_pc, pd->pd_tag, PCI_BHLC_REG,
		    pd->pd_bhlc);
		pci_conf_write(sc->sc_pc, pd->pd_tag, PCI_INTERRUPT_REG,
		    pd->pd_int);

		if (pci_get_capability(sc->sc_pc, pd->pd_tag,
		    PCI_CAP_MSI, &off, &reg)) {
			pci_conf_write(sc->sc_pc, pd->pd_tag,
			    off + PCI_MSI_MA, pd->pd_msi_ma);
			if (reg & PCI_MSI_MC_C64) {
				pci_conf_write(sc->sc_pc, pd->pd_tag,
				    off + PCI_MSI_MAU32, pd->pd_msi_mau32);
				pci_conf_write(sc->sc_pc, pd->pd_tag,
				    off + PCI_MSI_MD64, pd->pd_msi_md);
			} else {
				pci_conf_write(sc->sc_pc, pd->pd_tag,
				    off + PCI_MSI_MD32, pd->pd_msi_md);
			}
			pci_conf_write(sc->sc_pc, pd->pd_tag,
			    off + PCI_MSI_MC, pd->pd_msi_mc);
		}
	}
}

int
pciprint(void *aux, const char *pnp)
{
	struct pci_attach_args *pa = aux;
	char devinfo[256];

	if (pnp) {
		pci_devinfo(pa->pa_id, pa->pa_class, 1, devinfo,
		    sizeof devinfo);
		printf("%s at %s", devinfo, pnp);
	}
	printf(" dev %d function %d", pa->pa_device, pa->pa_function);
	if (!pnp) {
		pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo,
		    sizeof devinfo);
		printf(" %s", devinfo);
	}

	return (UNCONF);
}

int
pcisubmatch(struct device *parent, void *match,  void *aux)
{
	struct cfdata *cf = match;
	struct pci_attach_args *pa = aux;

	if (cf->pcicf_dev != PCI_UNK_DEV &&
	    cf->pcicf_dev != pa->pa_device)
		return (0);
	if (cf->pcicf_function != PCI_UNK_FUNCTION &&
	    cf->pcicf_function != pa->pa_function)
		return (0);

	return ((*cf->cf_attach->ca_match)(parent, match, aux));
}

int
pci_probe_device(struct pci_softc *sc, pcitag_t tag,
    int (*match)(struct pci_attach_args *), struct pci_attach_args *pap)
{
	pci_chipset_tag_t pc = sc->sc_pc;
	struct pci_attach_args pa;
	struct pci_dev *pd;
	pcireg_t id, class, intr, bhlcr, cap;
	int pin, bus, device, function;
	int off, ret = 0;
	uint64_t addr;

	pci_decompose_tag(pc, tag, &bus, &device, &function);

	bhlcr = pci_conf_read(pc, tag, PCI_BHLC_REG);
	if (PCI_HDRTYPE_TYPE(bhlcr) > 2)
		return (0);

	id = pci_conf_read(pc, tag, PCI_ID_REG);
	class = pci_conf_read(pc, tag, PCI_CLASS_REG);

	/* Invalid vendor ID value? */
	if (PCI_VENDOR(id) == PCI_VENDOR_INVALID)
		return (0);
	/* XXX Not invalid, but we've done this ~forever. */
	if (PCI_VENDOR(id) == 0)
		return (0);

	pa.pa_iot = sc->sc_iot;
	pa.pa_memt = sc->sc_memt;
	pa.pa_dmat = sc->sc_dmat;
	pa.pa_pc = pc;
	pa.pa_ioex = sc->sc_ioex;
	pa.pa_memex = sc->sc_memex;
	pa.pa_pmemex = sc->sc_pmemex;
	pa.pa_busex = sc->sc_busex;
	pa.pa_domain = sc->sc_domain;
	pa.pa_bus = bus;
	pa.pa_device = device;
	pa.pa_function = function;
	pa.pa_tag = tag;
	pa.pa_id = id;
	pa.pa_class = class;
	pa.pa_bridgetag = sc->sc_bridgetag;
	pa.pa_bridgeih = sc->sc_bridgeih;

	/* This is a simplification of the NetBSD code.
	   We don't support turning off I/O or memory
	   on broken hardware. <csapuntz@@stanford.edu> */
	pa.pa_flags = sc->sc_flags;
	pa.pa_flags |= PCI_FLAGS_IO_ENABLED | PCI_FLAGS_MEM_ENABLED;

	if (sc->sc_bridgetag == NULL) {
		pa.pa_intrswiz = 0;
		pa.pa_intrtag = tag;
	} else {
		pa.pa_intrswiz = sc->sc_intrswiz + device;
		pa.pa_intrtag = sc->sc_intrtag;
	}

	intr = pci_conf_read(pc, tag, PCI_INTERRUPT_REG);

	pin = PCI_INTERRUPT_PIN(intr);
	pa.pa_rawintrpin = pin;
	if (pin == PCI_INTERRUPT_PIN_NONE) {
		/* no interrupt */
		pa.pa_intrpin = 0;
	} else {
		/*
		 * swizzle it based on the number of busses we're
		 * behind and our device number.
		 */
		pa.pa_intrpin = 	/* XXX */
		    ((pin + pa.pa_intrswiz - 1) % 4) + 1;
	}
	pa.pa_intrline = PCI_INTERRUPT_LINE(intr);

	if (pci_get_ht_capability(pc, tag, PCI_HT_CAP_MSI, &off, &cap)) {
		/*
		 * XXX Should we enable MSI mapping ourselves on
		 * systems that have it disabled?
		 */
		if (cap & PCI_HT_MSI_ENABLED) {
			if ((cap & PCI_HT_MSI_FIXED) == 0) {
				addr = pci_conf_read(pc, tag,
				    off + PCI_HT_MSI_ADDR);
				addr |= (uint64_t)pci_conf_read(pc, tag,
				    off + PCI_HT_MSI_ADDR_HI32) << 32;
			} else
				addr = PCI_HT_MSI_FIXED_ADDR;

			/* 
			 * XXX This will fail to enable MSI on systems
			 * that don't use the canonical address.
			 */
			if (addr == PCI_HT_MSI_FIXED_ADDR)
				pa.pa_flags |= PCI_FLAGS_MSI_ENABLED;
		}
	}

	/*
	 * Give the MD code a chance to alter pci_attach_args and/or
	 * skip devices.
	 */
	if (pci_probe_device_hook(pc, &pa) != 0)
		return (0);

	if (match != NULL) {
		ret = (*match)(&pa);
		if (ret != 0 && pap != NULL)
			*pap = pa;
	} else {
		pcireg_t address, csr;
		int i, reg, reg_start, reg_end;
		int s;

		pd = malloc(sizeof *pd, M_DEVBUF, M_ZERO | M_WAITOK);
		pd->pd_tag = tag;
		LIST_INSERT_HEAD(&sc->sc_devs, pd, pd_next);

		switch (PCI_HDRTYPE_TYPE(bhlcr)) {
		case 0:
			reg_start = PCI_MAPREG_START;
			reg_end = PCI_MAPREG_END;
			break;
		case 1: /* PCI-PCI bridge */
			reg_start = PCI_MAPREG_START;
			reg_end = PCI_MAPREG_PPB_END;
			break;
		case 2: /* PCI-CardBus bridge */
			reg_start = PCI_MAPREG_START;
			reg_end = PCI_MAPREG_PCB_END;
			break;
		default:
			return (0);
		}

		s = splhigh();
		csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
		if (csr & (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE))
			pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, csr &
			    ~(PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE));

		for (reg = reg_start, i = 0; reg < reg_end; reg += 4, i++) {
			address = pci_conf_read(pc, tag, reg);
			pci_conf_write(pc, tag, reg, 0xffffffff);
			pd->pd_mask[i] = pci_conf_read(pc, tag, reg);
			pci_conf_write(pc, tag, reg, address);
		}

		if (csr & (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE))
			pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, csr);
		splx(s);

		if ((PCI_CLASS(class) == PCI_CLASS_DISPLAY &&
		    PCI_SUBCLASS(class) == PCI_SUBCLASS_DISPLAY_VGA) ||
		    (PCI_CLASS(class) == PCI_CLASS_PREHISTORIC &&
		    PCI_SUBCLASS(class) == PCI_SUBCLASS_PREHISTORIC_VGA))
			pd->pd_vga_decode = 1;

		pd->pd_dev = config_found_sm(&sc->sc_dev, &pa, pciprint,
		    pcisubmatch);
		if (pd->pd_dev)
			pci_dev_postattach(pd->pd_dev, &pa);
	}

	return (ret);
}

int
pci_detach_devices(struct pci_softc *sc, int flags)
{
	struct pci_dev *pd, *next;
	int ret;

	ret = config_detach_children(&sc->sc_dev, flags);
	if (ret != 0)
		return (ret);

	for (pd = LIST_FIRST(&sc->sc_devs); pd != NULL; pd = next) {
		next = LIST_NEXT(pd, pd_next);
		free(pd, M_DEVBUF, sizeof *pd);
	}
	LIST_INIT(&sc->sc_devs);

	return (0);
}

int
pci_get_capability(pci_chipset_tag_t pc, pcitag_t tag, int capid,
    int *offset, pcireg_t *value)
{
	pcireg_t reg;
	unsigned int ofs;

	reg = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	if (!(reg & PCI_STATUS_CAPLIST_SUPPORT))
		return (0);

	/* Determine the Capability List Pointer register to start with. */
	reg = pci_conf_read(pc, tag, PCI_BHLC_REG);
	switch (PCI_HDRTYPE_TYPE(reg)) {
	case 0:	/* standard device header */
	case 1: /* PCI-PCI bridge header */
		ofs = PCI_CAPLISTPTR_REG;
		break;
	case 2:	/* PCI-CardBus bridge header */
		ofs = PCI_CARDBUS_CAPLISTPTR_REG;
		break;
	default:
		return (0);
	}

	ofs = PCI_CAPLIST_PTR(pci_conf_read(pc, tag, ofs));
	while (ofs != 0) {
		/*
		 * Some devices, like parts of the NVIDIA C51 chipset,
		 * have a broken Capabilities List.  So we need to do
		 * a sanity check here.
		 */
		if ((ofs & 3) || (ofs < 0x40))
			return (0);
		reg = pci_conf_read(pc, tag, ofs);
		if (PCI_CAPLIST_CAP(reg) == capid) {
			if (offset)
				*offset = ofs;
			if (value)
				*value = reg;
			return (1);
		}
		ofs = PCI_CAPLIST_NEXT(reg);
	}

	return (0);
}

int
pci_get_ht_capability(pci_chipset_tag_t pc, pcitag_t tag, int capid,
    int *offset, pcireg_t *value)
{
	pcireg_t reg;
	unsigned int ofs;

	if (pci_get_capability(pc, tag, PCI_CAP_HT, &ofs, NULL) == 0)
		return (0);

	while (ofs != 0) {
#ifdef DIAGNOSTIC
		if ((ofs & 3) || (ofs < 0x40))
			panic("pci_get_ht_capability");
#endif
		reg = pci_conf_read(pc, tag, ofs);
		if (PCI_HT_CAP(reg) == capid) {
			if (offset)
				*offset = ofs;
			if (value)
				*value = reg;
			return (1);
		}
		ofs = PCI_CAPLIST_NEXT(reg);
	}

	return (0);
}

int
pci_find_device(struct pci_attach_args *pa,
    int (*match)(struct pci_attach_args *))
{
	extern struct cfdriver pci_cd;
	struct device *pcidev;
	int i;

	for (i = 0; i < pci_cd.cd_ndevs; i++) {
		pcidev = pci_cd.cd_devs[i];
		if (pcidev != NULL &&
		    pci_enumerate_bus((struct pci_softc *)pcidev,
		    		      match, pa) != 0)
			return (1);
	}
	return (0);
}

int
pci_get_powerstate(pci_chipset_tag_t pc, pcitag_t tag)
{
	pcireg_t reg;
	int offset;

	if (pci_get_capability(pc, tag, PCI_CAP_PWRMGMT, &offset, 0)) {
		reg = pci_conf_read(pc, tag, offset + PCI_PMCSR);
		return (reg & PCI_PMCSR_STATE_MASK);
	}
	return (PCI_PMCSR_STATE_D0);
}

int
pci_set_powerstate(pci_chipset_tag_t pc, pcitag_t tag, int state)
{
	pcireg_t reg;
	int offset, ostate = state;

	/*
	 * Warn the firmware that we are going to put the device
	 * into the given state.
	 */
	pci_set_powerstate_md(pc, tag, state, 1);

	if (pci_get_capability(pc, tag, PCI_CAP_PWRMGMT, &offset, 0)) {
		if (state == PCI_PMCSR_STATE_D3) {
			/*
			 * The PCI Power Management spec says we
			 * should disable I/O and memory space as well
			 * as bus mastering before we place the device
			 * into D3.
			 */
			reg = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
			reg &= ~PCI_COMMAND_IO_ENABLE;
			reg &= ~PCI_COMMAND_MEM_ENABLE;
			reg &= ~PCI_COMMAND_MASTER_ENABLE;
			pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, reg);
		}
		reg = pci_conf_read(pc, tag, offset + PCI_PMCSR);
		if ((reg & PCI_PMCSR_STATE_MASK) != state) {
			ostate = reg & PCI_PMCSR_STATE_MASK;

			pci_conf_write(pc, tag, offset + PCI_PMCSR,
			    (reg & ~PCI_PMCSR_STATE_MASK) | state);
			if (state == PCI_PMCSR_STATE_D3 ||
			    ostate == PCI_PMCSR_STATE_D3)
				delay(10 * 1000);
		}
	}

	/*
	 * Warn the firmware that the device is now in the given
	 * state.
	 */
	pci_set_powerstate_md(pc, tag, state, 0);

	return (ostate);
}

#ifndef PCI_MACHDEP_ENUMERATE_BUS
/*
 * Generic PCI bus enumeration routine.  Used unless machine-dependent
 * code needs to provide something else.
 */
int
pci_enumerate_bus(struct pci_softc *sc,
    int (*match)(struct pci_attach_args *), struct pci_attach_args *pap)
{
	pci_chipset_tag_t pc = sc->sc_pc;
	int device, function, nfunctions, ret;
	const struct pci_quirkdata *qd;
	pcireg_t id, bhlcr;
	pcitag_t tag;

	for (device = 0; device < sc->sc_maxndevs; device++) {
		tag = pci_make_tag(pc, sc->sc_bus, device, 0);

		bhlcr = pci_conf_read(pc, tag, PCI_BHLC_REG);
		if (PCI_HDRTYPE_TYPE(bhlcr) > 2)
			continue;

		id = pci_conf_read(pc, tag, PCI_ID_REG);

		/* Invalid vendor ID value? */
		if (PCI_VENDOR(id) == PCI_VENDOR_INVALID)
			continue;
		/* XXX Not invalid, but we've done this ~forever. */
		if (PCI_VENDOR(id) == 0)
			continue;

		qd = pci_lookup_quirkdata(PCI_VENDOR(id), PCI_PRODUCT(id));

		if (qd != NULL &&
		      (qd->quirks & PCI_QUIRK_MULTIFUNCTION) != 0)
			nfunctions = 8;
		else if (qd != NULL &&
		      (qd->quirks & PCI_QUIRK_MONOFUNCTION) != 0)
			nfunctions = 1;
		else
			nfunctions = PCI_HDRTYPE_MULTIFN(bhlcr) ? 8 : 1;

		for (function = 0; function < nfunctions; function++) {
			tag = pci_make_tag(pc, sc->sc_bus, device, function);
			ret = pci_probe_device(sc, tag, match, pap);
			if (match != NULL && ret != 0)
				return (ret);
		}
 	}

	return (0);
}
#endif /* PCI_MACHDEP_ENUMERATE_BUS */

int
pci_reserve_resources(struct pci_attach_args *pa)
{
	pci_chipset_tag_t pc = pa->pa_pc;
	pcitag_t tag = pa->pa_tag;
	pcireg_t bhlc, blr, type, bir;
	pcireg_t addr, mask;
	bus_addr_t base, limit;
	bus_size_t size;
	int reg, reg_start, reg_end, reg_rom;
	int bus, dev, func;
	int sec, sub;
	int flags;
	int s;

	pci_decompose_tag(pc, tag, &bus, &dev, &func);

	bhlc = pci_conf_read(pc, tag, PCI_BHLC_REG);
	switch (PCI_HDRTYPE_TYPE(bhlc)) {
	case 0:
		reg_start = PCI_MAPREG_START;
		reg_end = PCI_MAPREG_END;
		reg_rom = PCI_ROM_REG;
		break;
	case 1: /* PCI-PCI bridge */
		reg_start = PCI_MAPREG_START;
		reg_end = PCI_MAPREG_PPB_END;
		reg_rom = 0;	/* 0x38 */
		break;
	case 2: /* PCI-CardBus bridge */
		reg_start = PCI_MAPREG_START;
		reg_end = PCI_MAPREG_PCB_END;
		reg_rom = 0;
		break;
	default:
		return (0);
	}
    
	for (reg = reg_start; reg < reg_end; reg += 4) {
		if (!pci_mapreg_probe(pc, tag, reg, &type))
			continue;

		if (pci_mapreg_info(pc, tag, reg, type, &base, &size, &flags))
			continue;

		if (base == 0)
			continue;

		switch (type) {
		case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
		case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
			if (ISSET(flags, BUS_SPACE_MAP_PREFETCHABLE) &&
			    pa->pa_pmemex && extent_alloc_region(pa->pa_pmemex,
			    base, size, EX_NOWAIT) == 0) {
				break;
			}
#ifdef __sparc64__
			/*
			 * Certain SPARC T5 systems assign
			 * non-prefetchable 64-bit BARs of its onboard
			 * mpii(4) controllers addresses in the
			 * prefetchable memory range.  This is
			 * (probably) safe, as reads from the device
			 * registers mapped by these BARs are
			 * side-effect free.  So assume the firmware
			 * knows what it is doing.
			 */
			if (base >= 0x100000000 &&
			    pa->pa_pmemex && extent_alloc_region(pa->pa_pmemex,
			    base, size, EX_NOWAIT) == 0) {
				break;
			}
#endif
			if (pa->pa_memex && extent_alloc_region(pa->pa_memex,
			    base, size, EX_NOWAIT)) {
				printf("%d:%d:%d: mem address conflict 0x%lx/0x%lx\n",
				    bus, dev, func, base, size);
				pci_conf_write(pc, tag, reg, 0);
				if (type & PCI_MAPREG_MEM_TYPE_64BIT)
					pci_conf_write(pc, tag, reg + 4, 0);
			}
			break;
		case PCI_MAPREG_TYPE_IO:
			if (pa->pa_ioex && extent_alloc_region(pa->pa_ioex,
			    base, size, EX_NOWAIT)) {
				printf("%d:%d:%d: io address conflict 0x%lx/0x%lx\n",
				    bus, dev, func, base, size);
				pci_conf_write(pc, tag, reg, 0);
			}
			break;
		}

		if (type & PCI_MAPREG_MEM_TYPE_64BIT)
			reg += 4;
	}

	if (reg_rom != 0) {
		s = splhigh();
		addr = pci_conf_read(pc, tag, PCI_ROM_REG);
		pci_conf_write(pc, tag, PCI_ROM_REG, ~PCI_ROM_ENABLE);
		mask = pci_conf_read(pc, tag, PCI_ROM_REG);
		pci_conf_write(pc, tag, PCI_ROM_REG, addr);
		splx(s);

		base = PCI_ROM_ADDR(addr);
		size = PCI_ROM_SIZE(mask);
		if (base != 0 && size != 0) {
			if (pa->pa_pmemex && extent_alloc_region(pa->pa_pmemex,
			    base, size, EX_NOWAIT) &&
			    pa->pa_memex && extent_alloc_region(pa->pa_memex,
			    base, size, EX_NOWAIT)) {
				printf("%d:%d:%d: mem address conflict 0x%lx/0x%lx\n",
				    bus, dev, func, base, size);
				pci_conf_write(pc, tag, PCI_ROM_REG, 0);
			}
		}
	}

	if (PCI_HDRTYPE_TYPE(bhlc) != 1)
		return (0);

	/* Figure out the I/O address range of the bridge. */
	blr = pci_conf_read(pc, tag, PPB_REG_IOSTATUS);
	base = (blr & 0x000000f0) << 8;
	limit = (blr & 0x000f000) | 0x00000fff;
	blr = pci_conf_read(pc, tag, PPB_REG_IO_HI);
	base |= (blr & 0x0000ffff) << 16;
	limit |= (blr & 0xffff0000);
	if (limit > base)
		size = (limit - base + 1);
	else
		size = 0;
	if (pa->pa_ioex && base > 0 && size > 0) {
		if (extent_alloc_region(pa->pa_ioex, base, size, EX_NOWAIT)) {
			printf("%d:%d:%d: bridge io address conflict 0x%lx/0x%lx\n",
			    bus, dev, func, base, size);
			blr &= 0xffff0000;
			blr |= 0x000000f0;
			pci_conf_write(pc, tag, PPB_REG_IOSTATUS, blr);
		}
	}

	/* Figure out the memory mapped I/O address range of the bridge. */
	blr = pci_conf_read(pc, tag, PPB_REG_MEM);
	base = (blr & 0x0000fff0) << 16;
	limit = (blr & 0xfff00000) | 0x000fffff;
	if (limit > base)
		size = (limit - base + 1);
	else
		size = 0;
	if (pa->pa_memex && base > 0 && size > 0) {
		if (extent_alloc_region(pa->pa_memex, base, size, EX_NOWAIT)) {
			printf("%d:%d:%d: bridge mem address conflict 0x%lx/0x%lx\n",
			    bus, dev, func, base, size);
			pci_conf_write(pc, tag, PPB_REG_MEM, 0x0000fff0);
		}
	}

	/* Figure out the prefetchable memory address range of the bridge. */
	blr = pci_conf_read(pc, tag, PPB_REG_PREFMEM);
	base = (blr & 0x0000fff0) << 16;
	limit = (blr & 0xfff00000) | 0x000fffff;
#ifdef __LP64__
	blr = pci_conf_read(pc, pa->pa_tag, PPB_REG_PREFBASE_HI32);
	base |= ((uint64_t)blr) << 32;
	blr = pci_conf_read(pc, pa->pa_tag, PPB_REG_PREFLIM_HI32);
	limit |= ((uint64_t)blr) << 32;
#endif
	if (limit > base)
		size = (limit - base + 1);
	else
		size = 0;
	if (pa->pa_pmemex && base > 0 && size > 0) {
		if (extent_alloc_region(pa->pa_pmemex, base, size, EX_NOWAIT)) {
			printf("%d:%d:%d: bridge mem address conflict 0x%lx/0x%lx\n",
			    bus, dev, func, base, size);
			pci_conf_write(pc, tag, PPB_REG_PREFMEM, 0x0000fff0);
		}
	} else if (pa->pa_memex && base > 0 && size > 0) {
		if (extent_alloc_region(pa->pa_memex, base, size, EX_NOWAIT)) {
			printf("%d:%d:%d: bridge mem address conflict 0x%lx/0x%lx\n",
			    bus, dev, func, base, size);
			pci_conf_write(pc, tag, PPB_REG_PREFMEM, 0x0000fff0);
		}
	}

	/* Figure out the bus range handled by the bridge. */
	bir = pci_conf_read(pc, tag, PPB_REG_BUSINFO);
	sec = PPB_BUSINFO_SECONDARY(bir);
	sub = PPB_BUSINFO_SUBORDINATE(bir);
	if (pa->pa_busex && sub >= sec && sub > 0) {
		if (extent_alloc_region(pa->pa_busex, sec, sub - sec + 1,
		    EX_NOWAIT)) {
			printf("%d:%d:%d: bridge bus conflict %d-%d\n",
			    bus, dev, func, sec, sub);
		}
	}

	return (0);
}

/*
 * Vital Product Data (PCI 2.2)
 */

int
pci_vpd_read(pci_chipset_tag_t pc, pcitag_t tag, int offset, int count,
    pcireg_t *data)
{
	uint32_t reg;
	int ofs, i, j;

	KASSERT(data != NULL);
	KASSERT((offset + count) < 0x7fff);

	if (pci_get_capability(pc, tag, PCI_CAP_VPD, &ofs, &reg) == 0)
		return (1);

	for (i = 0; i < count; offset += sizeof(*data), i++) {
		reg &= 0x0000ffff;
		reg &= ~PCI_VPD_OPFLAG;
		reg |= PCI_VPD_ADDRESS(offset);
		pci_conf_write(pc, tag, ofs, reg);

		/*
		 * PCI 2.2 does not specify how long we should poll
		 * for completion nor whether the operation can fail.
		 */
		j = 0;
		do {
			if (j++ == 20)
				return (1);
			delay(4);
			reg = pci_conf_read(pc, tag, ofs);
		} while ((reg & PCI_VPD_OPFLAG) == 0);
		data[i] = pci_conf_read(pc, tag, PCI_VPD_DATAREG(ofs));
	}

	return (0);
}

int
pci_vpd_write(pci_chipset_tag_t pc, pcitag_t tag, int offset, int count,
    pcireg_t *data)
{
	pcireg_t reg;
	int ofs, i, j;

	KASSERT(data != NULL);
	KASSERT((offset + count) < 0x7fff);

	if (pci_get_capability(pc, tag, PCI_CAP_VPD, &ofs, &reg) == 0)
		return (1);

	for (i = 0; i < count; offset += sizeof(*data), i++) {
		pci_conf_write(pc, tag, PCI_VPD_DATAREG(ofs), data[i]);

		reg &= 0x0000ffff;
		reg |= PCI_VPD_OPFLAG;
		reg |= PCI_VPD_ADDRESS(offset);
		pci_conf_write(pc, tag, ofs, reg);

		/*
		 * PCI 2.2 does not specify how long we should poll
		 * for completion nor whether the operation can fail.
		 */
		j = 0;
		do {
			if (j++ == 20)
				return (1);
			delay(1);
			reg = pci_conf_read(pc, tag, ofs);
		} while (reg & PCI_VPD_OPFLAG);
	}

	return (0);
}

int
pci_matchbyid(struct pci_attach_args *pa, const struct pci_matchid *ids,
    int nent)
{
	const struct pci_matchid *pm;
	int i;

	for (i = 0, pm = ids; i < nent; i++, pm++)
		if (PCI_VENDOR(pa->pa_id) == pm->pm_vid &&
		    PCI_PRODUCT(pa->pa_id) == pm->pm_pid)
			return (1);
	return (0);
}

void
pci_disable_legacy_vga(struct device *dev)
{
	struct pci_softc *pci;
	struct pci_dev *pd;

	/* XXX Until we attach the drm drivers directly to pci. */
	while (dev->dv_parent->dv_cfdata->cf_driver != &pci_cd)
		dev = dev->dv_parent;

	pci = (struct pci_softc *)dev->dv_parent;
	LIST_FOREACH(pd, &pci->sc_devs, pd_next) {
		if (pd->pd_dev == dev) {
			pd->pd_vga_decode = 0;
			break;
		}
	}
}

#ifdef USER_PCICONF
/*
 * This is the user interface to PCI configuration space.
 */
  
#include <sys/pciio.h>
#include <sys/fcntl.h>

#ifdef DEBUG
#define PCIDEBUG(x) printf x
#else
#define PCIDEBUG(x)
#endif

void pci_disable_vga(pci_chipset_tag_t, pcitag_t);
void pci_enable_vga(pci_chipset_tag_t, pcitag_t);
void pci_route_vga(struct pci_softc *);
void pci_unroute_vga(struct pci_softc *);

int pciopen(dev_t dev, int oflags, int devtype, struct proc *p);
int pciclose(dev_t dev, int flag, int devtype, struct proc *p);
int pciioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p);

int
pciopen(dev_t dev, int oflags, int devtype, struct proc *p) 
{
	PCIDEBUG(("pciopen ndevs: %d\n" , pci_cd.cd_ndevs));

	if (minor(dev) >= pci_ndomains) {
		return ENXIO;
	}

#ifndef APERTURE
	if ((oflags & FWRITE) && securelevel > 0) {
		return EPERM;
	}
#else
	if ((oflags & FWRITE) && securelevel > 0 && allowaperture == 0) {
		return EPERM;
	}
#endif
	return (0);
}

int
pciclose(dev_t dev, int flag, int devtype, struct proc *p)
{
	PCIDEBUG(("pciclose\n"));

	pci_vga_proc = NULL;
	return (0);
}

int
pciioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct pcisel *sel = (struct pcisel *)data;
	struct pci_io *io;
	struct pci_rom *rom;
	int i, error;
	pcitag_t tag;
	struct pci_softc *pci;
	pci_chipset_tag_t pc;

	switch (cmd) {
	case PCIOCREAD:
	case PCIOCREADMASK:
		break;
	case PCIOCWRITE:
		if (!(flag & FWRITE))
			return EPERM;
		break;
	case PCIOCGETROMLEN:
	case PCIOCGETROM:
		break;
	case PCIOCGETVGA:
	case PCIOCSETVGA:
		if (pci_vga_pci == NULL)
			return EINVAL;
		break;
	default:
		return ENOTTY;
	}

	for (i = 0; i < pci_cd.cd_ndevs; i++) {
		pci = pci_cd.cd_devs[i];
		if (pci != NULL && pci->sc_domain == minor(dev) &&
		    pci->sc_bus == sel->pc_bus)
			break;
	}
	if (i >= pci_cd.cd_ndevs)
		return ENXIO;

	/* Check bounds */
	if (pci->sc_bus >= 256 || 
	    sel->pc_dev >= pci_bus_maxdevs(pci->sc_pc, pci->sc_bus) ||
	    sel->pc_func >= 8)
		return EINVAL;

	pc = pci->sc_pc;
	tag = pci_make_tag(pc, sel->pc_bus, sel->pc_dev, sel->pc_func);

	switch (cmd) {
	case PCIOCREAD:
		io = (struct pci_io *)data;
		switch (io->pi_width) {
		case 4:
			/* Configuration space bounds check */
			if (io->pi_reg < 0 ||
			    io->pi_reg >= pci_conf_size(pc, tag))
				return EINVAL;
			/* Make sure the register is properly aligned */
			if (io->pi_reg & 0x3) 
				return EINVAL;
			io->pi_data = pci_conf_read(pc, tag, io->pi_reg);
			error = 0;
			break;
		default:
			error = EINVAL;
			break;
		}
		break;

	case PCIOCWRITE:
		io = (struct pci_io *)data;
		switch (io->pi_width) {
		case 4:
			/* Configuration space bounds check */
			if (io->pi_reg < 0 ||
			    io->pi_reg >= pci_conf_size(pc, tag))
				return EINVAL;
			/* Make sure the register is properly aligned */
			if (io->pi_reg & 0x3)
				return EINVAL;
			pci_conf_write(pc, tag, io->pi_reg, io->pi_data);
			error = 0;
			break;
		default:
			error = EINVAL;
			break;
		}
		break;

	case PCIOCREADMASK:
	{
		io = (struct pci_io *)data;
		struct pci_dev *pd;
		int dev, func, i;

		if (io->pi_width != 4 || io->pi_reg & 0x3 ||
		    io->pi_reg < PCI_MAPREG_START ||
		    io->pi_reg >= PCI_MAPREG_END)
			return (EINVAL);

		error = ENODEV;
		LIST_FOREACH(pd, &pci->sc_devs, pd_next) {
			pci_decompose_tag(pc, pd->pd_tag, NULL, &dev, &func);
			if (dev == sel->pc_dev && func == sel->pc_func) {
				i = (io->pi_reg - PCI_MAPREG_START) / 4;
				io->pi_data = pd->pd_mask[i];
				error = 0;
				break;
			}
		}
		break;
	}

	case PCIOCGETROMLEN:
	case PCIOCGETROM:
	{
		pcireg_t addr, mask, bhlc;
		bus_space_handle_t h;
		bus_size_t len, off;
		char buf[256];
		int s;

		rom = (struct pci_rom *)data;

		bhlc = pci_conf_read(pc, tag, PCI_BHLC_REG);
		if (PCI_HDRTYPE_TYPE(bhlc) != 0)
			return (ENODEV);

		s = splhigh();
		addr = pci_conf_read(pc, tag, PCI_ROM_REG);
		pci_conf_write(pc, tag, PCI_ROM_REG, ~PCI_ROM_ENABLE);
		mask = pci_conf_read(pc, tag, PCI_ROM_REG);
		pci_conf_write(pc, tag, PCI_ROM_REG, addr);
		splx(s);

		/*
		 * Section 6.2.5.2 `Expansion ROM Base Addres Register',
		 *
		 * tells us that only the upper 21 bits are writable.
		 * This means that the size of a ROM must be a
		 * multiple of 2 KB.  So reading the ROM in chunks of
		 * 256 bytes should work just fine.
		 */
		if ((PCI_ROM_ADDR(addr) == 0 ||
		     PCI_ROM_SIZE(mask) % sizeof(buf)) != 0)
			return (ENODEV);

		/* If we're just after the size, skip reading the ROM. */
		if (cmd == PCIOCGETROMLEN) {
			error = 0;
			goto fail;
		}

		if (rom->pr_romlen < PCI_ROM_SIZE(mask)) {
			error = ENOMEM;
			goto fail;
		}

		error = bus_space_map(pci->sc_memt, PCI_ROM_ADDR(addr),
		    PCI_ROM_SIZE(mask), 0, &h);
		if (error)
			goto fail;

		off = 0;
		len = PCI_ROM_SIZE(mask);
		while (len > 0 && error == 0) {
			s = splhigh();
			pci_conf_write(pc, tag, PCI_ROM_REG,
			    addr | PCI_ROM_ENABLE);
			bus_space_read_region_1(pci->sc_memt, h, off,
			    buf, sizeof(buf));
			pci_conf_write(pc, tag, PCI_ROM_REG, addr);
			splx(s);

			error = copyout(buf, rom->pr_rom + off, sizeof(buf));
			off += sizeof(buf);
			len -= sizeof(buf);
		}

		bus_space_unmap(pci->sc_memt, h, PCI_ROM_SIZE(mask));

	fail:
		rom->pr_romlen = PCI_ROM_SIZE(mask);
		break;
	}

	case PCIOCGETVGA:
	{
		struct pci_vga *vga = (struct pci_vga *)data;
		struct pci_dev *pd;
		int bus, dev, func;

		vga->pv_decode = 0;
		LIST_FOREACH(pd, &pci->sc_devs, pd_next) {
			pci_decompose_tag(pc, pd->pd_tag, NULL, &dev, &func);
			if (dev == sel->pc_dev && func == sel->pc_func) {
				if (pd->pd_vga_decode)
					vga->pv_decode = PCI_VGA_IO_ENABLE |
					    PCI_VGA_MEM_ENABLE;
				break;
			}
		}

		pci_decompose_tag(pci_vga_pci->sc_pc,
		    pci_vga_tag, &bus, &dev, &func);
		vga->pv_sel.pc_bus = bus;
		vga->pv_sel.pc_dev = dev;
		vga->pv_sel.pc_func = func;
		error = 0;
		break;
	}
	case PCIOCSETVGA:
	{
		struct pci_vga *vga = (struct pci_vga *)data;
		int bus, dev, func;

		switch (vga->pv_lock) {
		case PCI_VGA_UNLOCK:
		case PCI_VGA_LOCK:
		case PCI_VGA_TRYLOCK:
			break;
		default:
			return (EINVAL);
		}

		if (vga->pv_lock == PCI_VGA_UNLOCK) {
			if (pci_vga_proc != p)
				return (EINVAL);
			pci_vga_proc = NULL;
			wakeup(&pci_vga_proc);
			return (0);
		}

		while (pci_vga_proc != p && pci_vga_proc != NULL) {
			if (vga->pv_lock == PCI_VGA_TRYLOCK)
				return (EBUSY);
			error = tsleep(&pci_vga_proc, PLOCK | PCATCH,
			    "vgalk", 0);
			if (error)
				return (error);
		}
		pci_vga_proc = p;

		pci_decompose_tag(pci_vga_pci->sc_pc,
		    pci_vga_tag, &bus, &dev, &func);
		if (bus != vga->pv_sel.pc_bus || dev != vga->pv_sel.pc_dev ||
		    func != vga->pv_sel.pc_func) {
			pci_disable_vga(pci_vga_pci->sc_pc, pci_vga_tag);
			if (pci != pci_vga_pci) {
				pci_unroute_vga(pci_vga_pci);
				pci_route_vga(pci);
				pci_vga_pci = pci;
			}
			pci_enable_vga(pc, tag);
			pci_vga_tag = tag;
		}

		error = 0;
		break;
	}

	default:
		error = ENOTTY;
		break;
	}

	return (error);
}

void
pci_disable_vga(pci_chipset_tag_t pc, pcitag_t tag)
{
	pcireg_t csr;

	csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	csr &= ~(PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE);
	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, csr);
}

void
pci_enable_vga(pci_chipset_tag_t pc, pcitag_t tag)
{
	pcireg_t csr;

	csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	csr |= PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE;
	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, csr);
}

void
pci_route_vga(struct pci_softc *sc)
{
	pci_chipset_tag_t pc = sc->sc_pc;
	pcireg_t bc;

	if (sc->sc_bridgetag == NULL)
		return;

	bc = pci_conf_read(pc, *sc->sc_bridgetag, PPB_REG_BRIDGECONTROL);
	bc |= PPB_BC_VGA_ENABLE;
	pci_conf_write(pc, *sc->sc_bridgetag, PPB_REG_BRIDGECONTROL, bc);

	pci_route_vga((struct pci_softc *)sc->sc_dev.dv_parent->dv_parent);
}

void
pci_unroute_vga(struct pci_softc *sc)
{
	pci_chipset_tag_t pc = sc->sc_pc;
	pcireg_t bc;

	if (sc->sc_bridgetag == NULL)
		return;

	bc = pci_conf_read(pc, *sc->sc_bridgetag, PPB_REG_BRIDGECONTROL);
	bc &= ~PPB_BC_VGA_ENABLE;
	pci_conf_write(pc, *sc->sc_bridgetag, PPB_REG_BRIDGECONTROL, bc);

	pci_unroute_vga((struct pci_softc *)sc->sc_dev.dv_parent->dv_parent);
}
#endif /* USER_PCICONF */

int
pci_primary_vga(struct pci_attach_args *pa)
{
	/* XXX For now, only handle the first PCI domain. */
	if (pa->pa_domain != 0)
		return (0);

	if ((PCI_CLASS(pa->pa_class) != PCI_CLASS_DISPLAY ||
	    PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_DISPLAY_VGA) &&
	    (PCI_CLASS(pa->pa_class) != PCI_CLASS_PREHISTORIC ||
	    PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_PREHISTORIC_VGA))
		return (0);

	if ((pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG)
	    & (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE))
	    != (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE))
		return (0);

	pci_vga_tag = pa->pa_tag;

	return (1);
}
@


1.110
log
@simple size for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.109 2014/11/27 19:03:44 kettenis Exp $	*/
d984 1
a984 1
	if (pa->pa_busex && sub >= sec) {
@


1.109
log
@Previous change wasn't quite right and broke "classic' PCI sparc64 machines.
Undo the code rearrangement in rev. 1.108 but keep the sparc64-specific code
dealing with non-prefetchable 64-bit BARs.

Found out the hard way by stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.108 2014/11/26 09:29:17 kettenis Exp $	*/
d578 1
a578 1
		free(pd, M_DEVBUF, 0);
@


1.108
log
@Seems Sun^H^H^HOracle is doing something naughty and (deliberately) puts
non-prefetchable BARs of the onboard mpii(4) behind a prefetchable memory
range on the bridge it sists behind.  Since we rely on the formware to program
BARs for us on sparc64, add a workaround to avoid whacking these BARs and
make the machine panic later when it tries to access the registers.

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.107 2014/11/24 13:48:49 kettenis Exp $	*/
a849 4
			if (pa->pa_memex && extent_alloc_region(pa->pa_memex,
			    base, size, EX_NOWAIT) == 0) {
				break;
			}
d867 8
a874 5
			printf("%d:%d:%d: mem address conflict 0x%lx/0x%lx\n",
			       bus, dev, func, base, size);
			pci_conf_write(pc, tag, reg, 0);
			if (type & PCI_MAPREG_MEM_TYPE_64BIT)
				pci_conf_write(pc, tag, reg + 4, 0);
d878 4
a881 2
			    base, size, EX_NOWAIT) == 0) {
				break;
a882 4

			printf("%d:%d:%d: io address conflict 0x%lx/0x%lx\n",
			       bus, dev, func, base, size);
			pci_conf_write(pc, tag, reg, 0);
@


1.107
log
@Fix some issues with 64-bit BARs behind PCI-PCI bridges.
Actual BARs that have the upper 32-bits set seen in the wild now on a
SPARC T5-2 system.

Tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.106 2014/10/26 16:18:42 kettenis Exp $	*/
d851 18
a868 6
			    base, size, EX_NOWAIT)) {
				printf("%d:%d:%d: mem address conflict 0x%lx/0x%lx\n",
				    bus, dev, func, base, size);
				pci_conf_write(pc, tag, reg, 0);
				if (type & PCI_MAPREG_MEM_TYPE_64BIT)
					pci_conf_write(pc, tag, reg + 4, 0);
d870 6
d879 2
a880 4
			    base, size, EX_NOWAIT)) {
				printf("%d:%d:%d: io address conflict 0x%lx/0x%lx\n",
				    bus, dev, func, base, size);
				pci_conf_write(pc, tag, reg, 0);
d882 4
@


1.106
log
@Add resource tracking for PCI ROMs.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.105 2014/09/14 14:17:25 jsg Exp $	*/
d939 6
@


1.105
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.104 2014/09/13 16:06:37 doug Exp $	*/
d800 1
d803 1
a803 1
	int reg, reg_start, reg_end;
d807 1
d816 1
d821 1
d826 1
d871 22
@


1.104
log
@Replace all queue *_END macro calls except CIRCLEQ_END with NULL.

CIRCLEQ_* is deprecated and not called in the tree.  The other queue types
have *_END macros which were added for symmetry with CIRCLEQ_END.  They are
defined as NULL.  There's no reason to keep the other *_END macro calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.103 2014/07/12 18:48:52 tedu Exp $	*/
a41 1
#include <sys/proc.h>
@


1.103
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.102 2014/05/04 20:09:15 sf Exp $	*/
d577 1
a577 2
	for (pd = LIST_FIRST(&sc->sc_devs);
	     pd != LIST_END(&sc->sc_devs); pd = next) {
@


1.102
log
@format string fixes for bus_addr_t and bus_size_t

bus_addr_t and bus_size_t are u_long everywhere

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.101 2013/12/06 21:03:04 deraadt Exp $	*/
d580 1
a580 1
		free(pd, M_DEVBUF);
@


1.101
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.100 2013/11/06 10:41:16 mpi Exp $	*/
d849 1
a849 1
				printf("%d:%d:%d: mem address conflict 0x%x/0x%x\n",
d859 1
a859 1
				printf("%d:%d:%d: io address conflict 0x%x/0x%x\n",
d886 1
a886 1
			printf("%d:%d:%d: bridge io address conflict 0x%x/0x%x\n",
d904 1
a904 1
			printf("%d:%d:%d: bridge mem address conflict 0x%x/0x%x\n",
d920 1
a920 1
			printf("%d:%d:%d: bridge mem address conflict 0x%x/0x%x\n",
d926 1
a926 1
			printf("%d:%d:%d: bridge mem address conflict 0x%x/0x%x\n",
@


1.100
log
@Call the new MD hook before and after setting the power state of a device.

This is actually a noop on all arches but ACPI ones, where it deals with
Power Resources.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.99 2013/08/08 17:54:11 kettenis Exp $	*/
d213 1
a213 1
	case DVACT_QUIESCE:
d215 1
d217 2
a218 1
	case DVACT_SUSPEND:
a219 1
		pci_suspend((struct pci_softc *)self);
d225 1
a225 2
	case DVACT_RESUME:
		pci_resume((struct pci_softc *)self);
@


1.99
log
@Make it possible for graphics drivers to opt-out of VGA arbitration.

The idea is that as soon the kernel driver switches out of vga text
mode, it can disable decoding of legacy vga io and mmio and call
pci_disable_legacy_vga() to take itself out of arbitration.  The
PCIGETVGA ioctl is extended such that it returns the legacy decoding
state of a device.  The X server can then query this state for all
graphics devices in the system (through libpciaccess) and decide
whether it needs to do arbitration.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.98 2013/02/09 20:43:33 miod Exp $	*/
d699 7
a705 1
	int offset;
d723 1
a723 1
			int ostate = reg & PCI_PMCSR_STATE_MASK;
a729 1
			return (ostate);
d732 8
a739 1
	return (state);
@


1.98
log
@No longer #ifdef BUS_SPACE_MAP_PREFETCHABLE, as all <machine/bus.h> are
expcted to provide it nowadays.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.97 2012/10/08 21:47:50 deraadt Exp $	*/
d60 1
d73 1
a92 1
int	pci_vga_count;
a105 1
int	pci_count_vga(struct pci_attach_args *);
d194 1
a194 1
	pci_enumerate_bus(sc, pci_count_vga, NULL);
d197 1
a404 1
	struct device *dev;
d552 10
a561 3
		if ((dev = config_found_sm(&sc->sc_dev, &pa, pciprint,
		    pcisubmatch)))
			pci_dev_postattach(dev, &pa);
d1026 19
d1288 2
a1289 1
		int bus, device, function;
d1291 13
a1303 2
		pci_decompose_tag(pci_vga_pci->sc_pc, pci_vga_tag,
		    &bus, &device, &function);
d1305 2
a1306 2
		vga->pv_sel.pc_dev = device;
		vga->pv_sel.pc_func = function;
d1313 1
a1313 1
		int bus, device, function;
d1342 4
a1345 5
		pci_decompose_tag(pci_vga_pci->sc_pc, pci_vga_tag,
		    &bus, &device, &function);
		if (bus != vga->pv_sel.pc_bus ||
		    device != vga->pv_sel.pc_dev ||
		    function != vga->pv_sel.pc_func) {
a1419 18

int
pci_count_vga(struct pci_attach_args *pa)
{
	/* XXX For now, only handle the first PCI domain. */
	if (pa->pa_domain != 0)
		return (0);

	if ((PCI_CLASS(pa->pa_class) != PCI_CLASS_DISPLAY ||
	    PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_DISPLAY_VGA) &&
	    (PCI_CLASS(pa->pa_class) != PCI_CLASS_PREHISTORIC ||
	    PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_PREHISTORIC_VGA))
		return (0);

	pci_vga_count++;

	return (0);
}
@


1.97
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.96 2012/09/19 23:01:21 kettenis Exp $	*/
a822 1
#ifdef BUS_SPACE_MAP_PREFETCHABLE
a827 1
#endif
@


1.96
log
@Add resource tracking for PCI bus numbers.  This will allow us to prevent
attaching the same PCI bus twice and in the long run this will allown us
to hot plug PCI busses and support CardBus on machines where the firmware
doesn't assign a bus number to CardBus devices.

While there, print a bit more information for memory and io conflicts.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.95 2012/09/07 19:26:48 kettenis Exp $	*/
d54 1
d219 4
d274 18
d323 2
a324 2
		if (pci_dopm) {
			/* Restore power. */
a326 1
		}
@


1.95
log
@Call pci_min_powerstate() to determine the lowest possible powerstate instead
of hardcoding it to D3.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.94 2011/10/10 19:42:37 miod Exp $	*/
d178 1
d186 5
d192 1
d411 1
d760 1
a760 1
	pcireg_t bhlc, blr, type;
d764 2
d768 2
d810 2
a811 2
				printf("mem address conflict 0x%x/0x%x\n",
				    base, size);
d820 2
a821 2
				printf("io address conflict 0x%x/0x%x\n",
				    base, size);
d847 2
a848 2
			printf("bridge io address conflict 0x%x/0x%x\n",
			       base, size);
d865 2
a866 2
			printf("bridge mem address conflict 0x%x/0x%x\n",
			       base, size);
d881 2
a882 2
			printf("bridge mem address conflict 0x%x/0x%x\n",
			       base, size);
d887 2
a888 2
			printf("bridge mem address conflict 0x%x/0x%x\n",
			       base, size);
d890 12
@


1.94
log
@Introduce pci_probe_device_hook(pci_chipset_tag_t, struct pci_attach_args *).
This mandatory function will get invoked in pci_probe_device(), and allows
a pci host driver to alter the pci_attach_args passed to a device when
attaching.

This function will also, if returning non-zero, cause the device to be
skipped completely during all the phases of the PCI device discovery
(i.e. ressource enumeration, ressource assignment, and actual attachment).
This particular feature is experimental and might be reverted in the future
(or the scope narrowed to device attachment only).

A dummy #define pci_probe_device_hook() 0 is added to all platforms except
sgi, where real functions (currently only returning 0) are added; real meat
will be added shortly.

Discussed at s2k11, no objection from the usual suspects.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.93 2011/06/12 11:13:28 kettenis Exp $	*/
d264 4
a267 1
			/* Place the device into D3. */
d271 1
a271 1
			    PCI_PMCSR_STATE_D3);
@


1.93
log
@Some devices, like parts of the NVIDIA C51 chipset, have a broken Capabilities
List.  So turn a DIAGNOSTIC panic into returning failure.

ok mglocker@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.92 2011/05/30 19:09:46 kettenis Exp $	*/
d464 7
@


1.92
log
@Enable MSI for HyperTransport devices that have MSI remapping enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.91 2011/05/19 20:14:55 kettenis Exp $	*/
d567 5
a571 1
#ifdef DIAGNOSTIC
d573 1
a573 2
			panic("pci_get_capability");
#endif
@


1.91
log
@Save and restore the MSI capability registers on suspend/resume.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.90 2011/05/14 13:23:38 kettenis Exp $	*/
d373 4
a376 2
	pcireg_t id, class, intr, bhlcr;
	int ret = 0, pin, bus, device, function;
d442 23
d573 29
@


1.90
log
@Pass flags down the PCI bus hierarchy.  Soon to be used to selectively enable
Message Signalled Interrupts.

ok krw@@ with a fix pointed out by many
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.89 2011/04/12 20:29:35 deraadt Exp $	*/
d66 4
d223 2
a224 2
	pcireg_t bhlc;
	int i;
d247 16
d278 1
a278 1
	int i;
d308 17
@


1.89
log
@We need to delay 10msec after changing to/from D3 state. note: There are
some broken intel chipsets that require longer delays, we will cope with
that later hopefully.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.88 2010/12/30 00:58:22 kettenis Exp $	*/
d170 1
d375 2
a376 1
	pa.pa_flags = PCI_FLAGS_IO_ENABLED | PCI_FLAGS_MEM_ENABLED;
@


1.88
log
@Only disable I/O and memory space and bus mastering if we're actually going
to put the device into D3.  Fixes PCI power management issues that prevented
acpi (and perhaps apm) suspend on some machines.

tested by & ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.87 2010/12/04 17:08:20 miod Exp $	*/
d574 2
d578 4
a581 1
			return (reg & PCI_PMCSR_STATE_MASK);
@


1.87
log
@Check the register offset against the device's configuration space size in
the PCIOCREAD and PCIOCWRITE ioctls.
ok kettenis@@ (also ok mikeb@@ on an earlier version of this)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.86 2010/09/07 16:21:45 deraadt Exp $	*/
d218 1
a218 1
	pcireg_t bhlc, csr;
d243 1
a243 12
			/*
			 * Place the device into D3.  The PCI Power
			 * Management spec says we should disable I/O
			 * and memory space as well as bus mastering
			 * before we do so.
			 */
			csr = pd->pd_csr;
			csr &= ~PCI_COMMAND_IO_ENABLE;
			csr &= ~PCI_COMMAND_MEM_ENABLE;
			csr &= ~PCI_COMMAND_MASTER_ENABLE;
			pci_conf_write(sc->sc_pc, pd->pd_tag,
			    PCI_COMMAND_STATUS_REG, csr);
d559 13
@


1.86
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.85 2010/09/06 19:20:23 deraadt Exp $	*/
d969 4
d980 1
a980 1
			error = ENODEV;
d989 4
d1000 1
a1000 1
			error = ENODEV;
@


1.85
log
@All PWR_{SUSPEND,RESUME} can now be replaced by DVACT_{SUSPEND,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.84 2010/09/05 18:14:33 kettenis Exp $	*/
a51 1
void pcipowerhook(int, void *);
a164 1
	sc->sc_powerhook = powerhook_establish(pcipowerhook, sc);
a211 14
}

/* save and restore the pci config space */
void
pcipowerhook(int why, void *arg)
{
	switch (why) {
	case DVACT_SUSPEND:
		pci_suspend(arg);
		break;
	case DVACT_RESUME:
		pci_resume(arg);
		break;
	}
@


1.84
log
@Add an ioctl to figure out the non-sticky bits in PCI BARs used for determining
the size of those BARs.  Make pcidump use this new ioctl to print the size
of PCI BARs.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.83 2010/08/31 17:13:44 deraadt Exp $	*/
d221 1
a221 1
	case PWR_SUSPEND:
d224 1
a224 1
	case PWR_RESUME:
@


1.83
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.82 2010/08/27 20:31:55 kettenis Exp $	*/
d66 1
d362 1
a362 1
	pcireg_t id, csr, class, intr, bhlcr;
a371 1
	csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
d433 4
d441 34
d550 1
a550 1
		int (*match)(struct pci_attach_args *))
d944 1
d1012 24
@


1.82
log
@Make PCI Power Management optional, and only enable it when acpi(4) attaches.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.81 2010/08/17 19:14:52 kettenis Exp $	*/
d200 3
@


1.81
log
@Power management for PCI devices.  For now just put everything in the D3
(deepest sleep) state upon suspend, and restore power upon resume.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.80 2010/07/02 04:03:31 kettenis Exp $	*/
d52 1
a52 1
void pcipower(int, void *);
d54 2
d88 2
d165 1
a165 1
	sc->sc_powerhook = powerhook_establish(pcipower, sc);
d202 1
a202 1
		pcipower(PWR_SUSPEND, self);	
d205 1
a205 1
		pcipower(PWR_RESUME, self);
d214 14
a227 1
pcipower(int why, void *arg)
a228 1
	struct pci_softc *sc = (struct pci_softc *)arg;
d230 1
a230 1
	pcireg_t bhlc, csr, reg;
a241 11
    
		if (why != PWR_RESUME) {
			for (i = 0; i < NMAPREG; i++)
				pd->pd_map[i] = pci_conf_read(sc->sc_pc,
				    pd->pd_tag, PCI_MAPREG_START + (i * 4));
			pd->pd_csr = pci_conf_read(sc->sc_pc, pd->pd_tag,
			    PCI_COMMAND_STATUS_REG);
			pd->pd_bhlc = pci_conf_read(sc->sc_pc, pd->pd_tag,
			    PCI_BHLC_REG);
			pd->pd_int = pci_conf_read(sc->sc_pc, pd->pd_tag,
			    PCI_INTERRUPT_REG);
d243 12
d271 23
a293 1
		} else {
d296 4
a299 5
			for (i = 0; i < NMAPREG; i++)
				pci_conf_write(sc->sc_pc, pd->pd_tag,
				    PCI_MAPREG_START + (i * 4), pd->pd_map[i]);
			reg = pci_conf_read(sc->sc_pc, pd->pd_tag,
			    PCI_COMMAND_STATUS_REG);
d301 9
a309 7
			    PCI_COMMAND_STATUS_REG,
			    (reg & 0xffff0000) | (pd->pd_csr & 0x0000ffff));
			pci_conf_write(sc->sc_pc, pd->pd_tag, PCI_BHLC_REG,
			    pd->pd_bhlc);
			pci_conf_write(sc->sc_pc, pd->pd_tag, PCI_INTERRUPT_REG,
			    pd->pd_int);
		}
@


1.80
log
@Proper fix for uninitialized variable warning.
Unbreaks build on several pci architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.79 2010/07/02 03:10:47 tedu Exp $	*/
a58 1
	struct device *pd_dev;
d64 1
d214 1
a214 1
	pcireg_t reg;
d218 9
d229 2
a230 2
			       pd->pd_map[i] = pci_conf_read(sc->sc_pc,
				   pd->pd_tag, PCI_MAPREG_START + (i * 4));
d232 1
a232 1
			   PCI_COMMAND_STATUS_REG);
d234 1
a234 1
			   PCI_BHLC_REG);
d236 18
a253 1
			   PCI_INTERRUPT_REG);
d255 2
d259 1
a259 2
				    PCI_MAPREG_START + (i * 4),
					pd->pd_map[i]);
d390 4
d395 1
a395 3
		    pcisubmatch))) {
			pcireg_t reg;

a396 12

			/* skip header type != 0 */
			reg = pci_conf_read(pc, tag, PCI_BHLC_REG);
			if (PCI_HDRTYPE_TYPE(reg) != 0)
				return(0);
			if (!(pd = malloc(sizeof *pd, M_DEVBUF,
			    M_NOWAIT)))
				return(0);
			pd->pd_tag = tag;
			pd->pd_dev = dev;
			LIST_INSERT_HEAD(&sc->sc_devs, pd, pd_next);
		}
d483 13
@


1.79
log
@the variables work better when initialized.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.78 2010/06/30 04:31:37 mlarkin Exp $	*/
d1069 1
a1069 1
	pci_chipset_tag_t pc = sc->sc_bridgetag;
d1072 1
a1072 1
	if (pc == NULL)
d1085 1
a1085 1
	pci_chipset_tag_t pc = sc->sc_bridgetag;
d1088 1
a1088 1
	if (pc == NULL)
@


1.78
log
@

Preserve and restore BARs on suspend/resume for all devices, not just
those that have the power management capability. Fixes UHCI(USB 1.1) on
a bunch of machines.

Tested on a wide variety of amd64 and i386 machines.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.77 2010/06/29 22:08:29 jordan Exp $	*/
d1069 1
a1069 1
	pci_chipset_tag_t pc;
d1072 1
a1072 1
	if (sc->sc_bridgetag == NULL)
d1085 1
a1085 1
	pci_chipset_tag_t pc;
d1088 1
a1088 1
	if (sc->sc_bridgetag == NULL)
@


1.77
log
@Add support for mapping ACPI to PCI devices
ok kettenis, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.76 2010/04/21 23:12:24 deraadt Exp $	*/
a371 3
				return(0);
			if (pci_get_capability(pc, tag,
			    PCI_CAP_PWRMGMT, NULL, NULL) == 0)
@


1.76
log
@let this compile on RAMDISKS, which have no ioctl
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.75 2010/04/21 21:16:43 kettenis Exp $	*/
d366 2
@


1.75
log
@Directly comparing pcitag_t's doesn't work on all platforms so decompose the
tag and compare the individual components.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.74 2010/04/21 18:55:40 kettenis Exp $	*/
a1046 2
#endif

d1098 1
@


1.74
log
@First stab at a VGA arbiter.  The VGA arbiter makes sure that only a single
VGA device can be active, and is responsible for routing IO to the active VGA
device.  Processes can use the new PCIOC_GETVGA and PCIOC_SETVGA ioctls
to manipulate the VGA arbiter.

ok deraadt@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.73 2010/01/26 17:47:36 otto Exp $	*/
d991 1
d1020 5
a1024 1
		if (tag != pci_vga_tag) {
@


1.73
log
@backout last, it causes mem conflicts and device trouble;
ok beck@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.71 2009/11/23 22:34:23 mlarkin Exp $	*/
d42 1
d81 5
d96 2
d178 3
d782 4
d816 2
d829 1
a829 1
	struct pci_softc *pci = NULL;
d842 5
d975 59
d1043 93
@


1.72
log
@Don't whack conflicting BARs if they are enabled.
Makes the IBM eServer x336 work.  Tested by sthen@@ and naddy@@.
@
text
@d534 1
a534 1
	pcireg_t bhlc, blr, csr, type;
a539 1
	csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
d557 1
a557 1

d582 3
a584 8
				if (csr & PCI_COMMAND_MEM_ENABLE) {
					extent_alloc_region(pa->pa_memex,
					    base, size, EX_NOWAIT | EX_CONFLICTOK);
				} else {
					pci_conf_write(pc, tag, reg, 0);
					if (type & PCI_MAPREG_MEM_TYPE_64BIT)
						pci_conf_write(pc, tag, reg + 4, 0);
				}
d592 1
a592 6
				if (csr & PCI_COMMAND_IO_ENABLE) {
					extent_alloc_region(pa->pa_memex,
					    base, size, EX_NOWAIT | EX_CONFLICTOK);
				} else {
					pci_conf_write(pc, tag, reg, 0);
				}
@


1.71
log
@

pci should return the result of it's children's suspend/resume calls back
to its parent.

handle suspend failure case and unwind if devices have an activate function
that returns failure.

ok deraadt@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.70 2009/11/23 15:24:01 deraadt Exp $	*/
d534 1
a534 1
	pcireg_t bhlc, blr, type;
d540 1
d558 1
a558 1
    
d583 8
a590 3
				pci_conf_write(pc, tag, reg, 0);
				if (type & PCI_MAPREG_MEM_TYPE_64BIT)
					pci_conf_write(pc, tag, reg + 4, 0);
d598 6
a603 1
				pci_conf_write(pc, tag, reg, 0);
@


1.70
log
@Walk our children in the activate function.
ok mlarkin pirofti
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.69 2009/11/23 01:28:11 mlarkin Exp $	*/
d186 1
a186 1
		config_activate_children(self, act);
d191 1
a191 1
		config_activate_children(self, act);
@


1.69
log
@

PCI suspend/resume plumbing. This code is currently not called.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.68 2009/11/05 20:30:47 kettenis Exp $	*/
d185 4
d191 1
a191 3
		break;
	case DVACT_SUSPEND:
		pcipower(PWR_SUSPEND, self);	
@


1.68
log
@Add a new PCIOCGETROMLEN ioctl, to give users of PCIOGETROM a chance to
allocate a buffer of the right size.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.67 2009/07/26 13:21:18 kettenis Exp $	*/
d52 1
d71 1
a71 1
	sizeof(struct pci_softc), pcimatch, pciattach, pcidetach
d177 16
@


1.67
log
@Add PCIOCGETROM, and ioctl(2) to read PCI ROMs.

ok miod@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.66 2009/07/25 12:51:41 miod Exp $	*/
d803 1
d861 1
d870 2
d895 6
a900 1
		rom = (struct pci_rom *)data;
@


1.66
log
@Better parameter validation in pciioctl(): check for ioctl number and
access rights before attempting to access the data pointer as a pciio
structure.

ok jsg@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.65 2009/07/18 16:19:28 miod Exp $	*/
d788 1
d790 1
d803 2
a808 7
	io = (struct pci_io *)data;

	PCIDEBUG(("pciioctl cmd %s",
	    cmd == PCIOCREAD ?  "pciocread" : "pciocwrite"));
	PCIDEBUG(("  bus %d dev %d func %d reg %x\n", io->pi_sel.pc_bus,
		  io->pi_sel.pc_dev, io->pi_sel.pc_func, io->pi_reg));

d812 1
a812 1
		    pci->sc_bus == io->pi_sel.pc_bus)
d820 2
a821 2
	    io->pi_sel.pc_dev >= pci_bus_maxdevs(pci->sc_pc, pci->sc_bus) ||
	    io->pi_sel.pc_func >= 8)
d825 1
a825 2
	tag = pci_make_tag(pc, io->pi_sel.pc_bus, io->pi_sel.pc_dev,
			   io->pi_sel.pc_func);
d829 1
d845 1
d858 69
@


1.65
log
@Don't forget to read the high bits I/O range register when registering
ppb resources in the parent extent.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.64 2009/07/14 18:20:02 kettenis Exp $	*/
d794 11
d807 2
a808 2
	PCIDEBUG(("pciioctl cmd %s", cmd == PCIOCREAD ? "pciocread" 
		  : cmd == PCIOCWRITE ? "pciocwrite" : "unknown"));
d831 1
a831 1
	switch(cmd) {
d833 1
a833 1
		switch(io->pi_width) {
d848 1
a848 4
		if (!(flag & FWRITE))
			return EPERM;

		switch(io->pi_width) {
a859 4
		break;

	default:
		error = ENOTTY;
@


1.64
log
@Kill structs and ioctls that were never implemented.

ok oga@@, miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.63 2009/06/29 19:19:17 kettenis Exp $	*/
d589 3
@


1.63
log
@Whack bridges that have conflicting windows.  This prevents us from choosing
address space that is already in use when reassigning BARs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.62 2009/06/03 06:09:21 kettenis Exp $	*/
a817 4
	case PCIOCGETCONF:
		error = ENODEV;
		break;

@


1.62
log
@Whack conflicting BARs, such that they get assigned a non-conflicting value
when we try to map it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.61 2009/05/05 14:16:17 kettenis Exp $	*/
d594 1
a594 1
		if (extent_alloc_region(pa->pa_ioex, base, size, EX_NOWAIT))
d597 4
d612 1
a612 1
		if (extent_alloc_region(pa->pa_memex, base, size, EX_NOWAIT))
d615 2
d628 1
a628 1
		if (extent_alloc_region(pa->pa_pmemex, base, size, EX_NOWAIT))
d631 2
d634 1
a634 1
		if (extent_alloc_region(pa->pa_memex, base, size, EX_NOWAIT))
d637 2
@


1.61
log
@Add extents for prefetchable memory mapped I/O.  Should remove conflict
messages for devices using prefetchable memory sitting behind bridges.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.60 2009/04/06 20:51:48 kettenis Exp $	*/
d560 1
a560 1
			    base, size, EX_NOWAIT))
d563 4
d570 1
a570 1
			    base, size, EX_NOWAIT))
d573 2
@


1.60
log
@Set a first step on the road towards proper accounting of PCI resources by
keeping a per-bus extent containing the address space available to the bus.
Address space assigned to devices will be removed from these extents when
we attach a bus.  And when we try to map a PCI BAR that hasn't had address
space assigned to it, we will allocate free space from this extent.

This won't do anything until the parent devices actually allocate and
initialize the extents.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.59 2008/12/28 18:26:53 kettenis Exp $	*/
d160 1
d287 1
d519 1
d543 1
a543 1
		if (pci_mapreg_info(pc, tag, reg, type, &base, &size, NULL))
d552 7
d615 5
a619 1
	if (pa->pa_memex && base > 0 && size > 0) {
@


1.59
log
@Remove confusion between "raw" and "swizzled" interrupt pins.  Remove some
#ifdef __i386__ code that can go now things have been cleaned up.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.58 2008/06/13 08:45:50 deraadt Exp $	*/
d46 1
d88 1
d158 2
d167 1
d284 2
d507 106
@


1.58
log
@properly indent something horridly misleading
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.57 2008/06/13 08:45:12 deraadt Exp $	*/
a293 10
#ifdef __i386__
	/*
	 * on i386 we really need to know the device tag
	 * and not the pci bridge tag, in intr_map
	 * to be able to program the device and the
	 * pci interrupt router.
	 */
	pa.pa_intrtag = tag;
	pa.pa_intrswiz = 0;
#else
a300 1
#endif
@


1.57
log
@Initialize the return value in pci_probe_device() function, so that we do
not randomly skip probing for devices after a missing device.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.56 2008/02/27 21:11:11 kettenis Exp $	*/
d337 1
a337 1
				pcireg_t reg;
d339 14
a352 14
				/* skip header type != 0 */
				reg = pci_conf_read(pc, tag, PCI_BHLC_REG);
				if (PCI_HDRTYPE_TYPE(reg) != 0)
					return(0);
				if (pci_get_capability(pc, tag,
				    PCI_CAP_PWRMGMT, NULL, NULL) == 0)
					return(0);
				if (!(pd = malloc(sizeof *pd, M_DEVBUF,
				    M_NOWAIT)))
					return(0);
				pd->pd_tag = tag;
				pd->pd_dev = dev;
				LIST_INSERT_HEAD(&sc->sc_devs, pd, pd_next);
			}
@


1.56
log
@Make sure we match the correct pci domain; clean up the code a bit and remove
an unneeded goto.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.55 2007/12/31 19:13:36 kettenis Exp $	*/
d256 1
a256 1
	int ret, pin, bus, device, function;
@


1.55
log
@On some machines we get hotplug interrupts when they're resumed, so don't
rescan the pci bus if it already has devices attached to it.  Make sure we
clear the list of attached devices when we receive a surprise removal
interrupt.  Fixes kurt@@'s T43.

ok miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.54 2007/11/30 14:28:24 kettenis Exp $	*/
d672 3
a674 6
	if (pci != NULL && pci->sc_bus == io->pi_sel.pc_bus) {
		pc = pci->sc_pc;
	} else {
		error = ENXIO;
		goto done;
	}
d677 3
a679 5
	    io->pi_sel.pc_dev >= pci_bus_maxdevs(pc, pci->sc_bus) ||
	    io->pi_sel.pc_func >= 8) {
		error = EINVAL;
		goto done;
	}
d681 1
d727 1
a727 1
 done:
@


1.54
log
@Make pci(4) detachable.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.53 2007/11/26 13:20:28 jsg Exp $	*/
d169 1
a169 1
	return config_detach_children(self, flags);
d356 20
@


1.53
log
@Add PCI VPD read/write functions from NetBSD required for some things
dlg is playing with.

'put it in' dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.52 2007/11/17 23:20:38 brad Exp $	*/
d49 1
d69 1
a69 1
	sizeof(struct pci_softc), pcimatch, pciattach
d164 6
@


1.52
log
@Allow pci_get_capability to decode capabilities for PCI bridges.

From jmcneill NetBSD

ok kettenis@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.51 2007/10/22 03:08:53 fgsch Exp $	*/
d484 77
@


1.51
log
@Add pci_set_powerstate() to change the pm state for a given device.
ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.50 2007/05/21 22:10:45 kettenis Exp $	*/
d366 1
d369 1
a369 1
	case 2:	/* PCI-CardBus Bridge header */
@


1.50
log
@Implement deep interrupt swizzling by mapping all four PCI interrupt pins
for PCI-PCI bridges and passing the mapping to the attached bus device.
MD code can use these when mapping PCI device interrupts.  This diff adds
such code for amd64 and i386.  This fixes interrupt mapping for devices that
sit behind two PCI-PCI bridges where the firmware only provides a mapping
for the first PCI-PCI bridge.

tested by sturm@@, krw@@, and a few others, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.49 2006/12/14 17:36:12 kettenis Exp $	*/
d411 17
@


1.49
log
@Make pci subsystem aware of domains.  Each host bridge gets assigned a unique
domain number such that we can distinguish between busses with the same bus
number that are behind different host bridges.  Domains can be accessed by
using different device nodes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.48 2006/12/11 19:47:37 kettenis Exp $	*/
d158 1
d280 1
@


1.48
log
@On i386, swizzle interrupts for devices for which we don't have explicit
inetrrupt routing information.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.47 2006/10/04 19:27:44 kettenis Exp $	*/
d75 2
d155 1
d271 1
d503 4
d544 2
a545 1
		if (pci != NULL && pci->sc_bus == io->pi_sel.pc_bus)
@


1.47
log
@Do not assume that the pci(4) unit number matches the actual PCI bus number.
Fixes cases where X would get really confused when they didn't match.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.46 2006/07/04 18:07:29 kettenis Exp $	*/
d274 1
@


1.46
log
@Do not blindly enable io and mem space for all matched PCI devices.  This is
known to be wrong for legacy VGA devices.  It also seems to have bad side
effects for some unconfigured PCI-PCI bridges.  Instead, enable io or mem
space when we map it.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.45 2006/03/22 00:36:03 jsg Exp $	*/
d521 1
a521 1
	int error;
d523 1
a523 1
	struct pci_softc *pci;
d533 4
a536 3
	if (io->pi_sel.pc_bus >= pci_cd.cd_ndevs) {
		error = ENXIO;
		goto done;
d538 1
a538 2
	pci = pci_cd.cd_devs[io->pi_sel.pc_bus];
	if (pci != NULL) {
d552 1
a552 1
	tag = pci_make_tag(pc, pci->sc_bus, io->pi_sel.pc_dev,
@


1.45
log
@Add pci_find_device() a helper function for enumerating the
PCI bus, from NetBSD.  This is useful for things like finding
another device in a driver ie ISA bridge in pciide.

ok brad@@ grange@@, looks ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.44 2006/03/20 01:53:24 brad Exp $	*/
a224 1
	int success;
d233 1
a233 18
	success = (*cf->cf_attach->ca_match)(parent, match, aux);

	/*
	 * My Dell BIOS does not enable certain non-critical PCI devices
	 * for IO and memory cycles (e.g. network card). This is
	 * the generic approach to fixing this problem. Basically, if
	 * we support the card, then we enable its IO cycles.
	 */
	if (success) {
		pcireg_t csr = pci_conf_read(pa->pa_pc, pa->pa_tag,
		    PCI_COMMAND_STATUS_REG);

		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
		    csr | PCI_COMMAND_MASTER_ENABLE |
		    PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE);
	}

	return (success);
@


1.44
log
@de-register.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.43 2006/03/19 22:06:12 brad Exp $	*/
d403 18
@


1.43
log
@ANSI and KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.42 2006/03/19 21:25:04 brad Exp $	*/
d202 1
a202 1
	register struct pci_attach_args *pa = aux;
@


1.42
log
@- check HDRTYPE early, and ignore if it is not supported (n > 2).
- defer access to interrupt configuration register, as its existence depends on
  HDRTYPE.

From itojun NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.41 2006/03/19 02:43:38 brad Exp $	*/
d112 1
a112 3
pcimatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d137 1
a137 3
pciattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d200 1
a200 3
pciprint(aux, pnp)
	void *aux;
	const char *pnp;
d221 1
a221 3
pcisubmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d363 2
a364 6
pci_get_capability(pc, tag, capid, offset, value)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int capid;
	int *offset;
	pcireg_t *value;
d507 1
a507 1
	return 0;
d514 1
a514 1
	return 0;
@


1.41
log
@rev 1.86

make the "generic" PCI bus enumeration code the standard case which
gets used if nothing else is defined in MD headers,
introduce a "PCI_MACHDEP_ENUMERATE_BUS" CPP definition which can
be used by MD headers (just 1 port atm) to plug in special code

rev 1.62

* Implement a machine-dependent pci_enumerate_bus() for sparc64 which
  uses OFW device nodes to enumerate the bus.  When a PCI bus that is
  behind a bridge is attached, pci_attach_hook() allocates a new PCI
  chipset tag for the new bus and sets it's "curnode" to the OFW node
  of the bridge.  This is used as a starting point when enumerating
  that bus.  Root busses get the OFW node of the host bridge (psycho).

rev 1.59

Split the code that enumerates the PCI bus and that actually probes
for a device into two functions:

* pci_probe_device() actually probes/attaches the device specified
  by the provide pcitag_t.

* pci_enumerate_bus() enumerates the bus, and calls pci_probe_device()
  for each device on the bus.  A pci_enumerate_bus_generic() is provided
  which implements the old method of doing this: If something found at
  dev0/func0, determine number of functions and probe each one.

From NetBSD

ok kettenis@@

Tested on a good number of amd64/i386/macppc/sparc64 systems
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.40 2006/03/11 22:08:07 brad Exp $	*/
d275 4
a281 2
	intr = pci_conf_read(pc, tag, PCI_INTERRUPT_REG);
	bhlcr = pci_conf_read(pc, tag, PCI_BHLC_REG);
d324 3
d435 5
d451 2
a452 4
		bhlcr = pci_conf_read(pc, tag, PCI_BHLC_REG);
		if (PCI_HDRTYPE_MULTIFN(bhlcr) ||
		    (qd != NULL &&
		      (qd->quirks & PCI_QUIRK_MULTIFUNCTION) != 0))
d454 3
d458 1
a458 1
			nfunctions = 1;
@


1.40
log
@move PCI softc struct from pci.c to pcivar.h

ok krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.39 2005/07/10 19:03:09 mickey Exp $	*/
d78 7
d135 1
a135 1
	return 1;
a143 3
	bus_space_tag_t iot, memt;
	pci_chipset_tag_t pc;
	int bus, device, maxndevs, function, nfunctions;
a144 10
	struct pci_dev *pd;
	struct device *dev;
#ifdef __PCI_BUS_DEVORDER
	char devs[32];
	int i;
#endif
#ifdef __PCI_DEV_FUNCORDER
	char funcs[8];
	int j;
#endif 
d147 1
a149 7
	iot = pba->pba_iot;
	memt = pba->pba_memt;
	pc = pba->pba_pc;
	bus = pba->pba_bus;
	maxndevs = pci_bus_maxdevs(pc, bus);

	sc->sc_pc = pba->pba_pc;
a151 3
#ifdef USER_PCICONF
	sc->sc_bus = bus;
#endif
d153 10
a162 134
#ifdef __PCI_BUS_DEVORDER
	pci_bus_devorder(pc, bus, devs);
	for (i = 0; (device = devs[i]) < 32 && device >= 0; i++) {
#else
	for (device = 0; device < maxndevs; device++) {
#endif
		pcitag_t tag;
		pcireg_t id, class, intr;
#ifndef __sparc64__
		pcireg_t bhlcr;
#endif
		struct pci_attach_args pa;
		int pin;

		tag = pci_make_tag(pc, bus, device, 0);
		id = pci_conf_read(pc, tag, PCI_ID_REG);

#ifdef __sparc64__
		pci_dev_funcorder(pc, bus, device, funcs);
		nfunctions = 8;

		/* Invalid vendor ID value or 0 (see below for zero)
		 * ... of course, if the pci_dev_funcorder found
		 *     functions other than zero, we probably want
		 *     to attach them.
		 */
		if (PCI_VENDOR(id) == PCI_VENDOR_INVALID || PCI_VENDOR(id) == 0)
			if (funcs[0] < 0)
				continue;

		for (j = 0; (function = funcs[j]) < nfunctions &&
		    function >= 0; j++) {
#else

		/* Invalid vendor ID value? */
		if (PCI_VENDOR(id) == PCI_VENDOR_INVALID)
			continue;
		/* XXX Not invalid, but we've done this ~forever. */
		if (PCI_VENDOR(id) == 0)
			continue;

		bhlcr = pci_conf_read(pc, tag, PCI_BHLC_REG);
		nfunctions = PCI_HDRTYPE_MULTIFN(bhlcr) ? 8 : 1;

#ifdef __PCI_DEV_FUNCORDER
		pci_dev_funcorder(pc, bus, device, funcs);
		for (j = 0; (function = funcs[j]) < nfunctions &&
		    function >= 0; j++) {
#else
		for (function = 0; function < nfunctions; function++) {
#endif
#endif
			tag = pci_make_tag(pc, bus, device, function);
			id = pci_conf_read(pc, tag, PCI_ID_REG);

			/* Invalid vendor ID value? */
			if (PCI_VENDOR(id) == PCI_VENDOR_INVALID)
				continue;
			/* XXX Not invalid, but we've done this ~forever. */
			if (PCI_VENDOR(id) == 0)
				continue;

			class = pci_conf_read(pc, tag, PCI_CLASS_REG);
			intr = pci_conf_read(pc, tag, PCI_INTERRUPT_REG);

			pa.pa_iot = iot;
			pa.pa_memt = memt;
			pa.pa_dmat = pba->pba_dmat;
			pa.pa_pc = pc;
			pa.pa_device = device;
			pa.pa_function = function;
			pa.pa_bus = bus;
			pa.pa_tag = tag;
			pa.pa_id = id;
			pa.pa_class = class;

			/* This is a simplification of the NetBSD code.
			   We don't support turning off I/O or memory
			   on broken hardware. <csapuntz@@stanford.edu> */
			pa.pa_flags = PCI_FLAGS_IO_ENABLED | PCI_FLAGS_MEM_ENABLED;
#ifdef __i386__
			/*
			 * on i386 we really need to know the device tag
			 * and not the pci bridge tag, in intr_map
			 * to be able to program the device and the
			 * pci interrupt router.
			 */
			pa.pa_intrtag = tag;
			pa.pa_intrswiz = 0;
#else
			if (bus == 0) {
				pa.pa_intrswiz = 0;
				pa.pa_intrtag = tag;
			} else {
				pa.pa_intrswiz = pba->pba_intrswiz + device;
				pa.pa_intrtag = pba->pba_intrtag;
			}
#endif
			pin = PCI_INTERRUPT_PIN(intr);
			pa.pa_rawintrpin = pin;
			if (pin == PCI_INTERRUPT_PIN_NONE) {
				/* no interrupt */
				pa.pa_intrpin = 0;
			} else {
				/*
				 * swizzle it based on the number of
				 * busses we're behind and our device
				 * number.
				 */
				pa.pa_intrpin =			/* XXX */
				    ((pin + pa.pa_intrswiz - 1) % 4) + 1;
			}
			pa.pa_intrline = PCI_INTERRUPT_LINE(intr);

			if ((dev = config_found_sm(self, &pa, pciprint,
			    pcisubmatch))) {
				pcireg_t reg;

				/* skip header type != 0 */
				reg = pci_conf_read(pc, tag, PCI_BHLC_REG);
				if (PCI_HDRTYPE_TYPE(reg) != 0)
					continue;
				if (pci_get_capability(pc, tag,
				    PCI_CAP_PWRMGMT, NULL, NULL) == 0)
					continue;
				if (!(pd = malloc(sizeof *pd, M_DEVBUF,
				    M_NOWAIT)))
					continue;
				pd->pd_tag = tag;
				pd->pd_dev = dev;
				LIST_INSERT_HEAD(&sc->sc_devs, pd, pd_next);
			}
		}
	}
d237 1
a237 1
		return 0;
d240 1
a240 1
		return 0;
d263 103
d412 48
@


1.39
log
@pci_conf_read() return pcireg_t not u_int32_t and fix some style
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.38 2005/06/29 03:18:49 brad Exp $	*/
a49 10

struct pci_softc {
	struct device sc_dev;
	pci_chipset_tag_t sc_pc;
	void *sc_powerhook;
	LIST_HEAD(, pci_dev) sc_devs;
#ifdef USER_PCICONF
	int sc_bus;		/* PCI configuration space bus # */
#endif
};
@


1.38
log
@rev 1.47

Make pci_get_capability() work correctly on both header type 0 and type 2
devices; both have different Capability List Pointer registers.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.37 2005/05/02 11:30:25 grange Exp $	*/
d393 6
a398 5
	/* My Dell BIOS does not enable certain non-critical PCI devices
	   for IO and memory cycles (e.g. network card). This is
	   the generic approach to fixing this problem. Basically, if
	   we support the card, then we enable its IO cycles.
	*/
d400 2
a401 2
		u_int32_t csr = pci_conf_read(pa->pa_pc, pa->pa_tag,
					      PCI_COMMAND_STATUS_REG);
d404 2
a405 3
			       csr | PCI_COMMAND_MASTER_ENABLE |
			       PCI_COMMAND_IO_ENABLE |
			       PCI_COMMAND_MEM_ENABLE);
@


1.37
log
@Don't hardcode sizeof(pcireg_t) value. ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.36 2004/12/08 15:38:41 markus Exp $	*/
d426 14
a439 1
	ofs = PCI_CAPLIST_PTR(pci_conf_read(pc, tag, PCI_CAPLISTPTR_REG));
@


1.36
log
@add pci powerhooks: save/restore cfg space; with claudio@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.35 2004/12/07 02:11:24 brad Exp $	*/
d61 2
a62 1
#define NMAPREG			((PCI_MAPREG_END - PCI_MAPREG_START) / 4)
@


1.35
log
@Remove the PCI-ISA bridge callback mechanism; it's no longer needed.

From NetBSD

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.34 2004/06/25 08:57:10 art Exp $	*/
d41 1
d49 1
a50 1
#ifdef USER_PCICONF
d54 3
d58 12
a70 1
#endif
a76 3
#ifndef USER_PCICONF
	sizeof(struct device), pcimatch, pciattach
#else
a77 1
#endif
a148 1
#ifdef USER_PCICONF
d150 2
a151 1
#endif
d170 3
a173 1
	sc->sc_pc = pba->pba_pc;
d291 56
a346 1
			config_found_sm(self, &pa, pciprint, pcisubmatch);
@


1.34
log
@Provide information about the raw (unswizzled) intrrupt pin in
pci_attach_args.
drahn@@ deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.33 2003/04/27 11:22:53 ho Exp $	*/
d77 4
a80 2
 * Callback so that ISA/EISA bridges can attach their child busses
 * after PCI configuration is done.
d98 2
a100 2
static void	(*pci_isa_bridge_callback)(void *);
static void	*pci_isa_bridge_callback_arg;
a163 3
	if (bus == 0)
		pci_isa_bridge_callback = NULL;

a280 3

	if (bus == 0 && pci_isa_bridge_callback != NULL)
		(*pci_isa_bridge_callback)(pci_isa_bridge_callback_arg);
a339 12
}

void
set_pci_isa_bridge_callback(fn, arg)
	void (*fn)(void *);
	void *arg;
{

	if (pci_isa_bridge_callback != NULL)
		panic("set_pci_isa_bridge_callback");
	pci_isa_bridge_callback = fn;
	pci_isa_bridge_callback_arg = arg;
@


1.33
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.32 2003/02/28 15:26:23 mickey Exp $	*/
d264 1
@


1.32
log
@remove non-typo changes. sorry folks
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.30 2002/11/19 18:40:17 jason Exp $	*/
d295 2
a296 1
		pci_devinfo(pa->pa_id, pa->pa_class, 1, devinfo);
d301 2
a302 1
		pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);
@


1.31
log
@typo; from weissmanndude
@
text
@d412 2
a413 2
#ifdef PCI_DEBUG
#define DPRINTF(x) printf x
d415 1
a415 1
#define DPRINTF(x)
d426 1
a426 1
	DPRINTF(("pciopen ndevs: %d\n" , pci_cd.cd_ndevs));
d443 1
a443 1
	DPRINTF(("pciclose\n"));
d458 1
a458 1
	DPRINTF(("pciioctl cmd %s", cmd == PCIOCREAD ? "pciocread" 
d460 1
a460 1
	DPRINTF(("  bus %d dev %d func %d reg %x\n", io->pi_sel.pc_bus,
@


1.30
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.29 2002/04/04 17:11:46 jason Exp $	*/
d412 2
a413 2
#ifdef DEBUG
#define PCIDEBUG(x) printf x
d415 1
a415 1
#define PCIDEBUG(x)
d426 1
a426 1
	PCIDEBUG(("pciopen ndevs: %d\n" , pci_cd.cd_ndevs));
d443 1
a443 1
	PCIDEBUG(("pciclose\n"));
d458 1
a458 1
	PCIDEBUG(("pciioctl cmd %s", cmd == PCIOCREAD ? "pciocread" 
d460 1
a460 1
	PCIDEBUG(("  bus %d dev %d func %d reg %x\n", io->pi_sel.pc_bus,
@


1.29
log
@Catch broken devices on sparc64 (where broken == devices that don't have
a function 0).  Many thanks to Joey Coleman <joeycoleman@@acm.org> for
fixing this.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.28 2002/03/27 15:10:44 jason Exp $	*/
d387 14
@


1.28
log
@make sure error is set to zero on the pci write case for user conf
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.27 2002/03/14 01:26:59 millert Exp $	*/
d172 4
a175 1
		pcireg_t id, class, intr, bhlcr;
d182 17
d215 1
@


1.27
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.26 2002/02/23 16:59:36 matthieu Exp $	*/
d477 1
a477 1
			if (io->pi_reg & 0x3) 
d480 1
@


1.26
log
@Add aperture driver support for macppc, and also place writing to /dev/pci
under the control of machdep.allowaperture.
This allows to run the X server on macppc with securelevel=1, given that
machdep.allowaperture is != 0.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.25 2002/02/18 23:23:46 matthieu Exp $	*/
d46 2
a47 2
int pcimatch __P((struct device *, void *, void *));
void pciattach __P((struct device *, struct device *, void *));
d73 2
a74 2
int	pciprint __P((void *, const char *));
int	pcisubmatch __P((struct device *, void *, void *));
d97 1
a97 1
static void	(*pci_isa_bridge_callback) __P((void *));
d324 1
a324 1
	void (*fn) __P((void *));
d384 3
a386 3
int pciopen __P((dev_t dev, int oflags, int devtype, struct proc *p));
int pciclose __P((dev_t dev, int flag, int devtype, struct proc *p));
int pciioctl __P((dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p));
@


1.25
log
@Correct fix for breakage in rev 1.23. Sorry for the mess.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.23 2002/02/18 21:51:18 matthieu Exp $	*/
d57 4
d393 1
d397 5
@


1.24
log
@do not assume PCI_USERCONF is set on all arch; matthieu ok
@
text
@d430 3
a432 8
#ifdef PCI_USERCONF
	if (pci.sc_bus >= 256 ||
	    io->pi_sel.pc_dev >= pci_bus_maxdevs(pc, pci.sc_bus) ||
		error = EINVAL;
		goto done;
	}
#endif
	if (io->pi_sel.pc_func >= 8) {
@


1.23
log
@store the PCI configuration space bus number in the pci_softc struct
and use it for pci configuration space access in ioctl code.
And do bounds checking on ioctl args for all architectures
Ok deraadt@@, drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.22 2001/08/25 12:48:35 art Exp $	*/
d430 2
a431 1
	if (pci.sc_bus >= 256 || 
d433 5
a437 1
	    io->pi_sel.pc_func >= 8) {
@


1.22
log
@Allow machdep code to decide the order in which we probe the
pci buses. this is conditional on __PCI_BUS_DEVORDER and __PCI_DEV_FUNCORDER
Used by sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.21 2001/07/20 05:56:25 csapuntz Exp $	*/
d53 1
d155 1
d429 3
a431 5
#ifdef __i386__
	/* The i386 pci_make_tag function can panic if called with wrong 
	   args, try to avoid that */
	if (io->pi_sel.pc_bus >= 256 || 
	    io->pi_sel.pc_dev >= pci_bus_maxdevs(pc, io->pi_sel.pc_bus) ||
a435 1
#endif
d437 1
a437 1
	tag = pci_make_tag(pc, io->pi_sel.pc_bus, io->pi_sel.pc_dev,
@


1.22.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.22 2001/08/25 12:48:35 art Exp $	*/
d46 2
a47 2
int pcimatch(struct device *, void *, void *);
void pciattach(struct device *, struct device *, void *);
a52 1
	int sc_bus;		/* PCI configuration space bus # */
a55 4
#ifdef APERTURE
extern int allowaperture;
#endif

d68 2
a69 2
int	pciprint(void *, const char *);
int	pcisubmatch(struct device *, void *, void *);
d92 1
a92 1
static void	(*pci_isa_bridge_callback)(void *);
a153 1
	sc->sc_bus = bus;
d166 1
a166 4
		pcireg_t id, class, intr;
#ifndef __sparc64__
		pcireg_t bhlcr;
#endif
a172 17
#ifdef __sparc64__
		pci_dev_funcorder(pc, bus, device, funcs);
		nfunctions = 8;

		/* Invalid vendor ID value or 0 (see below for zero)
		 * ... of course, if the pci_dev_funcorder found
		 *     functions other than zero, we probably want
		 *     to attach them.
		 */
		if (PCI_VENDOR(id) == PCI_VENDOR_INVALID || PCI_VENDOR(id) == 0)
			if (funcs[0] < 0)
				continue;

		for (j = 0; (function = funcs[j]) < nfunctions &&
		    function >= 0; j++) {
#else

a189 1
#endif
d318 1
a318 1
	void (*fn)(void *);
d378 3
a380 3
int pciopen(dev_t dev, int oflags, int devtype, struct proc *p);
int pciclose(dev_t dev, int flag, int devtype, struct proc *p);
int pciioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p);
a386 1
#ifndef APERTURE
a389 5
#else
	if ((oflags & FWRITE) && securelevel > 0 && allowaperture == 0) {
		return EPERM;
	}
#endif
d427 5
a431 3
	/* Check bounds */
	if (pci->sc_bus >= 256 || 
	    io->pi_sel.pc_dev >= pci_bus_maxdevs(pc, pci->sc_bus) ||
d436 1
d438 1
a438 1
	tag = pci_make_tag(pc, pci->sc_bus, io->pi_sel.pc_dev,
d468 1
a468 1
			if (io->pi_reg & 0x3)
a470 1
			error = 0;
@


1.22.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d295 1
a295 2
		pci_devinfo(pa->pa_id, pa->pa_class, 1, devinfo,
		    sizeof devinfo);
d300 1
a300 2
		pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo,
		    sizeof devinfo);
a386 14
	return (0);
}

int
pci_matchbyid(struct pci_attach_args *pa, const struct pci_matchid *ids,
    int nent)
{
	const struct pci_matchid *pm;
	int i;

	for (i = 0, pm = ids; i < nent; i++, pm++)
		if (PCI_VENDOR(pa->pa_id) == pm->pm_vid &&
		    PCI_PRODUCT(pa->pa_id) == pm->pm_pid)
			return (1);
@


1.21
log
@

Add pa_bus to pci_attach_args

Better VIA IDE chipset handling. From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.20 2001/06/26 22:22:41 jason Exp $	*/
d134 8
d159 4
d164 1
d183 5
d189 1
@


1.20
log
@use pci_bus_maxdevs instead of nasty i386 specific goop (It's nice to
be able to bug art@@ and matthieu@@ in person =)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.19 2001/06/24 16:15:56 matthieu Exp $	*/
d190 1
@


1.19
log
@Avoid panics on the i386 if the bus/dev/func numbers are not valid
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.18 2001/06/24 04:18:41 matthieu Exp $	*/
d411 1
a411 1
	    io->pi_sel.pc_dev >= (pci_mode == 2 ? 32 : 16) ||
@


1.18
log
@allow ioctl(..., PCIOCREAD, ...) if the device was opened O_READONLY
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.17 2001/06/23 03:30:37 matthieu Exp $	*/
d407 10
@


1.17
log
@PCI bus configuration userland access from FreeBSD.
Will be used by XFree86 on powerpc (works on i386 too, but its not currently
used).
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.16 2001/01/27 05:02:39 mickey Exp $	*/
a407 4
	if (!(flag & FWRITE))
		return EPERM;


d432 3
@


1.16
log
@ignore swizzling on i386.
this is needed for interrupt mapping code to be
able to program the device and the pci interrupt
router for the interrupt.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.15 1999/07/18 03:20:18 csapuntz Exp $	*/
d49 7
d57 1
d59 3
d131 3
d144 4
d342 116
@


1.15
log
@

Added pci_mapreg* interface from NetBSD.
Added PCI 2.2 stuff from NetBSD
Modified if_de to use mapreg interface
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.14 1998/10/29 18:11:53 csapuntz Exp $	*/
d180 10
d197 1
@


1.15.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.16 2001/01/27 05:02:39 mickey Exp $	*/
a179 10
#ifdef __i386__
			/*
			 * on i386 we really need to know the device tag
			 * and not the pci bridge tag, in intr_map
			 * to be able to program the device and the
			 * pci interrupt router.
			 */
			pa.pa_intrtag = tag;
			pa.pa_intrswiz = 0;
#else
a186 1
#endif
@


1.15.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.15.4.1 2001/05/14 22:25:52 niklas Exp $	*/
a48 7
#ifdef USER_PCICONF
struct pci_softc {
	struct device sc_dev;
	pci_chipset_tag_t sc_pc;
};
#endif

a49 1
#ifndef USER_PCICONF
a50 3
#else
	sizeof(struct pci_softc), pcimatch, pciattach
#endif
a119 3
#ifdef USER_PCICONF
	struct pci_softc *sc = (struct pci_softc *)self;
#endif
a129 4
#ifdef USER_PCICONF
	sc->sc_pc = pba->pba_pc;
#endif

a323 125

#ifdef USER_PCICONF
/*
 * This is the user interface to PCI configuration space.
 */
  
#include <sys/pciio.h>
#include <sys/fcntl.h>

#ifdef DEBUG
#define PCIDEBUG(x) printf x
#else
#define PCIDEBUG(x)
#endif


int pciopen __P((dev_t dev, int oflags, int devtype, struct proc *p));
int pciclose __P((dev_t dev, int flag, int devtype, struct proc *p));
int pciioctl __P((dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p));

int
pciopen(dev_t dev, int oflags, int devtype, struct proc *p) 
{
	PCIDEBUG(("pciopen ndevs: %d\n" , pci_cd.cd_ndevs));

	if ((oflags & FWRITE) && securelevel > 0) {
		return EPERM;
	}
	return 0;
}

int
pciclose(dev_t dev, int flag, int devtype, struct proc *p)
{
	PCIDEBUG(("pciclose\n"));
	return 0;
}

int
pciioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct pci_io *io;
	int error;
	pcitag_t tag;
	struct pci_softc *pci;
	pci_chipset_tag_t pc;

	io = (struct pci_io *)data;

	PCIDEBUG(("pciioctl cmd %s", cmd == PCIOCREAD ? "pciocread" 
		  : cmd == PCIOCWRITE ? "pciocwrite" : "unknown"));
	PCIDEBUG(("  bus %d dev %d func %d reg %x\n", io->pi_sel.pc_bus,
		  io->pi_sel.pc_dev, io->pi_sel.pc_func, io->pi_reg));

	if (io->pi_sel.pc_bus >= pci_cd.cd_ndevs) {
		error = ENXIO;
		goto done;
	}
	pci = pci_cd.cd_devs[io->pi_sel.pc_bus];
	if (pci != NULL) {
		pc = pci->sc_pc;
	} else {
		error = ENXIO;
		goto done;
	}
#ifdef __i386__
	/* The i386 pci_make_tag function can panic if called with wrong 
	   args, try to avoid that */
	if (io->pi_sel.pc_bus >= 256 || 
	    io->pi_sel.pc_dev >= pci_bus_maxdevs(pc, io->pi_sel.pc_bus) ||
	    io->pi_sel.pc_func >= 8) {
		error = EINVAL;
		goto done;
	}
#endif

	tag = pci_make_tag(pc, io->pi_sel.pc_bus, io->pi_sel.pc_dev,
			   io->pi_sel.pc_func);

	switch(cmd) {
	case PCIOCGETCONF:
		error = ENODEV;
		break;

	case PCIOCREAD:
		switch(io->pi_width) {
		case 4:
			/* Make sure the register is properly aligned */
			if (io->pi_reg & 0x3) 
				return EINVAL;
			io->pi_data = pci_conf_read(pc, tag, io->pi_reg);
			error = 0;
			break;
		default:
			error = ENODEV;
			break;
		}
		break;

	case PCIOCWRITE:
		if (!(flag & FWRITE))
			return EPERM;

		switch(io->pi_width) {
		case 4:
			/* Make sure the register is properly aligned */
			if (io->pi_reg & 0x3) 
				return EINVAL;
			pci_conf_write(pc, tag, io->pi_reg, io->pi_data);
			break;
		default:
			error = ENODEV;
			break;
		}
		break;

	default:
		error = ENOTTY;
		break;
	}
 done:
	return (error);
}

#endif
@


1.15.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.15.4.2 2001/07/04 10:42:45 niklas Exp $	*/
a133 8
#ifdef __PCI_BUS_DEVORDER
	char devs[32];
	int i;
#endif
#ifdef __PCI_DEV_FUNCORDER
	char funcs[8];
	int j;
#endif 
a150 4
#ifdef __PCI_BUS_DEVORDER
	pci_bus_devorder(pc, bus, devs);
	for (i = 0; (device = devs[i]) < 32 && device >= 0; i++) {
#else
a151 1
#endif
a169 5
#ifdef __PCI_DEV_FUNCORDER
		pci_dev_funcorder(pc, bus, device, funcs);
		for (j = 0; (function = funcs[j]) < nfunctions &&
		    function >= 0; j++) {
#else
a170 1
#endif
a189 1
			pa.pa_bus = bus;
@


1.15.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a52 1
	int sc_bus;		/* PCI configuration space bus # */
a55 4
#ifdef APERTURE
extern int allowaperture;
#endif

a153 1
	sc->sc_bus = bus;
a386 1
#ifndef APERTURE
a389 5
#else
	if ((oflags & FWRITE) && securelevel > 0 && allowaperture == 0) {
		return EPERM;
	}
#endif
d427 5
a431 3
	/* Check bounds */
	if (pci->sc_bus >= 256 || 
	    io->pi_sel.pc_dev >= pci_bus_maxdevs(pc, pci->sc_bus) ||
d436 1
d438 1
a438 1
	tag = pci_make_tag(pc, pci->sc_bus, io->pi_sel.pc_dev,
@


1.15.4.5
log
@Merge in -current from roughly a week ago
@
text
@d46 2
a47 2
int pcimatch(struct device *, void *, void *);
void pciattach(struct device *, struct device *, void *);
d73 2
a74 2
int	pciprint(void *, const char *);
int	pcisubmatch(struct device *, void *, void *);
d97 1
a97 1
static void	(*pci_isa_bridge_callback)(void *);
d324 1
a324 1
	void (*fn)(void *);
d384 3
a386 3
int pciopen(dev_t dev, int oflags, int devtype, struct proc *p);
int pciclose(dev_t dev, int flag, int devtype, struct proc *p);
int pciioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p);
@


1.15.4.6
log
@Sync the SMP branch with 3.3
@
text
@d172 1
a172 4
		pcireg_t id, class, intr;
#ifndef __sparc64__
		pcireg_t bhlcr;
#endif
a178 17
#ifdef __sparc64__
		pci_dev_funcorder(pc, bus, device, funcs);
		nfunctions = 8;

		/* Invalid vendor ID value or 0 (see below for zero)
		 * ... of course, if the pci_dev_funcorder found
		 *     functions other than zero, we probably want
		 *     to attach them.
		 */
		if (PCI_VENDOR(id) == PCI_VENDOR_INVALID || PCI_VENDOR(id) == 0)
			if (funcs[0] < 0)
				continue;

		for (j = 0; (function = funcs[j]) < nfunctions &&
		    function >= 0; j++) {
#else

a195 1
#endif
a368 14
int
pci_matchbyid(struct pci_attach_args *pa, const struct pci_matchid *ids,
    int nent)
{
	const struct pci_matchid *pm;
	int i;

	for (i = 0, pm = ids; i < nent; i++, pm++)
		if (PCI_VENDOR(pa->pa_id) == pm->pm_vid &&
		    PCI_PRODUCT(pa->pa_id) == pm->pm_pid)
			return (1);
	return (0);
}

d477 1
a477 1
			if (io->pi_reg & 0x3)
a479 1
			error = 0;
@


1.15.4.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.15.4.6 2003/03/28 00:38:23 niklas Exp $	*/
d295 1
a295 2
		pci_devinfo(pa->pa_id, pa->pa_class, 1, devinfo,
		    sizeof devinfo);
d300 1
a300 2
		pci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo,
		    sizeof devinfo);
@


1.14
log
@

Put in some generic code in PCI driver for enabling PCI cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.13 1998/08/22 17:59:04 rahnds Exp $	*/
d176 4
d267 4
a270 7
int
pci_io_find(pc, pcitag, reg, iobasep, iosizep)
	pci_chipset_tag_t pc;
	pcitag_t pcitag;
	int reg;
	bus_addr_t *iobasep;
	bus_size_t *iosizep;
a271 2
	pcireg_t addrdata, sizedata;
	int s;
d273 4
a276 44
	if (reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3))
		panic("pci_io_find: bad request");

	/* XXX?
	 * Section 6.2.5.1, `Address Maps', tells us that:
	 *
	 * 1) The builtin software should have already mapped the device in a
	 * reasonable way.
	 *
	 * 2) A device which wants 2^n bytes of memory will hardwire the bottom
	 * n bits of the address to 0.  As recommended, we write all 1s and see
	 * what we get back.
	 */
	addrdata = pci_conf_read(pc, pcitag, reg);

	s = splhigh();
	pci_conf_write(pc, pcitag, reg, 0xffffffff);
	sizedata = pci_conf_read(pc, pcitag, reg);
	pci_conf_write(pc, pcitag, reg, addrdata);
	splx(s);

	if (PCI_MAPREG_TYPE(addrdata) != PCI_MAPREG_TYPE_IO)
		panic("pci_io_find: not an I/O region");

	if (iobasep != NULL)
		*iobasep = PCI_MAPREG_IO_ADDR(addrdata);
	if (iosizep != NULL)
		*iosizep = PCI_MAPREG_IO_SIZE(sizedata);

#ifdef powerpc
	/*
	 * Open Firmware (yuck) shuts down devices before entering a
	 * program so we need to bring them back 'online' to respond
         * to bus accesses... so far this is true on the power.4e.
         */
	s = splhigh();
	sizedata = pci_conf_read(pc, pcitag, PCI_COMMAND_STATUS_REG);
	sizedata |= (PCI_COMMAND_MASTER_ENABLE | PCI_COMMAND_IO_ENABLE |
		     PCI_COMMAND_PARITY_ENABLE | PCI_COMMAND_SERR_ENABLE);
	pci_conf_write(pc, pcitag, PCI_COMMAND_STATUS_REG, sizedata);
	splx(s);
#endif

	return (0);
d280 1
a280 1
pci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)
d282 4
a285 5
	pcitag_t pcitag;
	int reg;
	bus_addr_t *membasep;
	bus_size_t *memsizep;
	int *cacheablep;
d287 2
a288 2
	pcireg_t addrdata, sizedata;
	int s;
d290 3
a292 2
	if (reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3))
		panic("pci_find_mem: bad request");
d294 15
a308 31
	/*
	 * Section 6.2.5.1, `Address Maps', tells us that:
	 *
	 * 1) The builtin software should have already mapped the device in a
	 * reasonable way.
	 *
	 * 2) A device which wants 2^n bytes of memory will hardwire the bottom
	 * n bits of the address to 0.  As recommended, we write all 1s and see
	 * what we get back.
	 */
	addrdata = pci_conf_read(pc, pcitag, reg);

	s = splhigh();
	pci_conf_write(pc, pcitag, reg, 0xffffffff);
	sizedata = pci_conf_read(pc, pcitag, reg);
	pci_conf_write(pc, pcitag, reg, addrdata);
	splx(s);

	if (PCI_MAPREG_TYPE(addrdata) == PCI_MAPREG_TYPE_IO)
		panic("pci_find_mem: I/O region");

	switch (PCI_MAPREG_MEM_TYPE(addrdata)) {
	case PCI_MAPREG_MEM_TYPE_32BIT:
	case PCI_MAPREG_MEM_TYPE_32BIT_1M:
		break;
	case PCI_MAPREG_MEM_TYPE_64BIT:
/* XXX */	printf("pci_find_mem: 64-bit region\n");
/* XXX */	return (1);
	default:
		printf("pci_find_mem: reserved region type\n");
		return (1);
d311 1
a311 34
	if (membasep != NULL)
		*membasep = PCI_MAPREG_MEM_ADDR(addrdata);	/* PCI addr */
	if (memsizep != NULL)
		*memsizep = PCI_MAPREG_MEM_SIZE(sizedata);
	if (cacheablep != NULL)
		*cacheablep = PCI_MAPREG_MEM_CACHEABLE(addrdata);

#ifdef powerpc
	/*
	 * Open Firmware (yuck) shuts down devices before entering a
	 * program so we need to bring them back 'online' to respond
         * to bus accesses... so far this is true on the power.4e.
         */
	s = splhigh();
	sizedata = pci_conf_read(pc, pcitag, PCI_COMMAND_STATUS_REG);
	sizedata |= (PCI_COMMAND_MASTER_ENABLE | PCI_COMMAND_MEM_ENABLE |
		     PCI_COMMAND_PARITY_ENABLE | PCI_COMMAND_SERR_ENABLE);
	pci_conf_write(pc, pcitag, PCI_COMMAND_STATUS_REG, sizedata);
	splx(s);
#endif

	return 0;
}

void
set_pci_isa_bridge_callback(fn, arg)
	void (*fn) __P((void *));
	void *arg;
{

	if (pci_isa_bridge_callback != NULL)
		panic("set_pci_isa_bridge_callback");
	pci_isa_bridge_callback = fn;
	pci_isa_bridge_callback_arg = arg;
@


1.13
log
@Powerpc supports isa not just power4e
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.12 1998/06/26 01:50:59 deraadt Exp $	*/
d234 1
d242 19
a260 1
	return ((*cf->cf_attach->ca_match)(parent, match, aux));
@


1.12
log
@check for invalid and empty slots by name
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.11 1998/01/20 18:40:34 niklas Exp $	*/
d284 1
a284 1
#ifdef power4e
d356 1
a356 1
#ifdef power4e
@


1.11
log
@Merge bus_dma support from NetBSD, mostly by Jason Thorpe.  Only i386 uses it
 so far, the other archs gets placeholders for now.  I wrote a compatibility
layer for OpenBSD's old isadma code so we can still use our old
driver sources.  They will however get changed to native bus_dma use,
on a case by case basis.   Oh yes, I almost forgot, I kept our notion
of isadma being a device so DMA-less ISA-busses still work
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.10 1998/01/07 11:03:32 deraadt Exp $	*/
d44 1
d141 6
a146 1
		if (id == 0 || id == 0xffffffff)
d155 3
a157 1
			if (id == 0 || id == 0xffffffff)
d159 4
@


1.10
log
@now this is really pretty
@
text
@d1 2
a2 2
/*	$OpenBSD: pci.c,v 1.9 1998/01/05 13:35:23 deraadt Exp $	*/
/*	$NetBSD: pci.c,v 1.26 1996/12/05 01:25:30 cgd Exp $	*/
d156 1
@


1.9
log
@new style pci attach printing
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.8 1997/10/11 09:14:53 pefo Exp $	*/
d208 1
a208 1
		printf(": %s", devinfo);
@


1.8
log
@power.4e - not enabling pci boards
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.7 1997/10/10 10:56:41 pefo Exp $	*/
d206 5
@


1.7
log
@Add a special fix for OpenFirmware Power PC PCI. It seems that OFW shuts
down the HW by disabling it when closing the device. So we have to make
sure that the board is configured to respond to memory accesses.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.6 1997/01/24 19:34:15 niklas Exp $	*/
d266 1
a266 1
#ifdef powerpc
d270 1
a270 1
         * to bus accesses...
d342 1
a342 1
         * to bus accesses...
@


1.6
log
@Sync with NetBSD 960123
@
text
@d1 1
a1 1
/*	$OpenBSD: pci.c,v 1.5 1996/11/28 23:28:09 niklas Exp $	*/
d266 14
d337 14
@


1.5
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: pci.c,v 1.4 1996/11/23 21:47:05 kstailey Exp $	*/
/*	$NetBSD: pci.c,v 1.24 1996/10/21 22:56:55 thorpej Exp $	*/
d59 24
d129 3
d188 3
d325 12
@


1.4
log
@added const to second parameter of cfprint_t routines
@
text
@d1 2
a2 2
/*	$OpenBSD: pci.c,v 1.2 1996/04/21 22:25:34 deraadt Exp $	*/
/*	$NetBSD: pci.c,v 1.19 1996/05/03 17:33:49 christos Exp $	*/
d92 1
a92 1
	bus_chipset_tag_t bc;
d99 2
a100 1
	bc = pba->pba_bc;
d127 2
a128 1
			pa.pa_bc = bc;
d201 2
a202 2
	bus_io_addr_t *iobasep;
	bus_io_size_t *iosizep;
d234 1
a234 1
		*iosizep = ~PCI_MAPREG_IO_ADDR(sizedata) + 1;
d244 2
a245 2
	bus_mem_addr_t *membasep;
	bus_mem_size_t *memsizep;
d290 1
a290 1
		*memsizep = ~PCI_MAPREG_MEM_ADDR(sizedata) + 1;
@


1.3
log
@sync with 0504 -- prototypes and bus.h
@
text
@d56 1
a56 1
int	pciprint __P((void *, char *));
d164 1
a164 1
	char *pnp;
@


1.2
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: pci.c,v 1.1 1996/04/18 23:48:02 niklas Exp $	*/
/*	$NetBSD: pci.c,v 1.18 1996/03/27 04:08:24 cgd Exp $	*/
d108 1
a108 2
		struct cfdata *cf;
		int supported, pin;
@


1.1
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: pci.c,v 1.15 1996/03/14 04:03:01 cgd Exp $	*/
d48 6
a53 2
struct cfdriver pcicd = {
	NULL, "pci", pcimatch, pciattach, DV_DULL, sizeof(struct device)
d93 2
a94 1
	int device, function, nfunctions;
d96 1
a96 1
	pci_md_attach_hook(parent, self, pba);
d99 6
a104 1
	for (device = 0; device < PCI_MAX_DEVICE_NUMBER; device++) {
d106 1
a106 1
		pcireg_t id, class;
d109 1
a109 1
		int supported;
d111 2
a112 2
		tag = pci_make_tag(pba->pba_bus, device, 0);
		id = pci_conf_read(tag, PCI_ID_REG);
d116 2
a117 1
		nfunctions = 1;				/* XXX */
d120 2
a121 2
			tag = pci_make_tag(pba->pba_bus, device, function);
			id = pci_conf_read(tag, PCI_ID_REG);
d124 2
a125 1
			class = pci_conf_read(tag, PCI_CLASS_REG);
d127 2
a128 1
			pa.pa_bc = pba->pba_bc;
d135 22
d192 102
a293 1
	return ((*cf->cf_driver->cd_match)(parent, match, aux));
@
