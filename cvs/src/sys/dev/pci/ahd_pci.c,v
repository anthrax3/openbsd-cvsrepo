head	1.24;
access;
symbols
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.12
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.8
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.6
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.18.0.14
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.12
	OPENBSD_5_0:1.18.0.10
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.8
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.6
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.17.0.6
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.4
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.24
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.23;
commitid	OBNa5kfxQ2UXoiIw;

1.23
date	2013.11.18.17.40.39;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2012.12.05.23.20.19;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2012.09.30.21.46.09;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2012.09.28.02.59.29;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2009.05.31.04.47.59;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.22.03.16.35;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.20.22.44.01;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.19.10.55.56;	author tom;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.11.18.50.05;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.18.21.27.24;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.09.04.10.10;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.19.06.17.54;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.10.17.43.19;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.18.01.33.28;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.14.02.32.08;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.14.01.25.14;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.23.18.36.10;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.23.03.23.18;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.14.00.44.47;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.25.12.22.49;	author krw;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2004.05.20.04.36.19;	author marco;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.03.09.34;	author marco;	state Exp;
branches;
next	;

1.3.2.1
date	2004.06.05.23.12.48;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.24
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@/*	$OpenBSD: ahd_pci.c,v 1.23 2013/11/18 17:40:39 guenther Exp $	*/

/*
 * Copyright (c) 2004 Milos Urbanek, Kenneth R. Westerback & Marco Peereboom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * Product specific probe and attach routines for:
 *	aic7901 and aic7902 SCSI controllers
 *
 * Copyright (c) 1994-2001 Justin T. Gibbs.
 * Copyright (c) 2000-2002 Adaptec Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 *
 */

#include <dev/ic/aic79xx_openbsd.h>
#include <dev/ic/aic79xx_inline.h>
#include <dev/ic/aic79xx.h>

#include <dev/pci/pcivar.h>

__inline uint64_t ahd_compose_id(u_int, u_int, u_int, u_int);
__inline uint64_t
ahd_compose_id(u_int device, u_int vendor, u_int subdevice, u_int subvendor)
{
	uint64_t id;

	id = subvendor
	   | (subdevice << 16)
	   | ((uint64_t)vendor << 32)
	   | ((uint64_t)device << 48);

	return (id);
}

#define ID_ALL_MASK			0xFFFFFFFFFFFFFFFFull
#define ID_ALL_IROC_MASK		0xFF7FFFFFFFFFFFFFull
#define ID_DEV_VENDOR_MASK		0xFFFFFFFF00000000ull
#define ID_9005_GENERIC_MASK		0xFFF0FFFF00000000ull
#define ID_9005_GENERIC_IROC_MASK	0xFF70FFFF00000000ull

#define ID_AIC7901			0x800F9005FFFF9005ull
#define ID_AHA_29320A			0x8000900500609005ull
#define ID_AHA_29320ALP			0x8017900500449005ull
#define ID_AHA_29320LPE			0x8017900500459005ull

#define ID_AIC7901A			0x801E9005FFFF9005ull
#define ID_AHA_29320LP			0x8014900500449005ull

#define ID_AIC7902			0x801F9005FFFF9005ull
#define ID_AIC7902_B			0x801D9005FFFF9005ull
#define ID_AHA_39320			0x8010900500409005ull
#define ID_AHA_29320			0x8012900500429005ull
#define ID_AHA_29320B			0x8013900500439005ull
#define ID_AHA_39320_B			0x8015900500409005ull
#define ID_AHA_39320_B_DELL		0x8015900501681028ull
#define ID_AHA_39320A			0x8016900500409005ull
#define ID_AHA_39320D			0x8011900500419005ull
#define ID_AHA_39320D_B			0x801C900500419005ull
#define ID_AHA_39320D_HP		0x8011900500AC0E11ull
#define ID_AHA_39320D_B_HP		0x801C900500AC0E11ull
#define ID_AIC7902_PCI_REV_A4		0x3
#define ID_AIC7902_PCI_REV_B0		0x10
#define SUBID_HP			0x0E11

#define DEVID_9005_HOSTRAID(id) ((id) & 0x80)

#define DEVID_9005_TYPE(id) ((id) & 0xF)
#define		DEVID_9005_TYPE_HBA		0x0	/* Standard Card */
#define		DEVID_9005_TYPE_HBA_2EXT	0x1	/* 2 External Ports */
#define		DEVID_9005_TYPE_MB		0xF	/* On Motherboard */

#define DEVID_9005_MFUNC(id) ((id) & 0x10)

#define DEVID_9005_PACKETIZED(id) ((id) & 0x8000)

#define SUBID_9005_TYPE(id) ((id) & 0xF)
#define		SUBID_9005_TYPE_HBA		0x0	/* Standard Card */
#define		SUBID_9005_TYPE_MB		0xF	/* On Motherboard */

#define SUBID_9005_AUTOTERM(id)	(((id) & 0x10) == 0)

#define SUBID_9005_LEGACYCONN_FUNC(id) ((id) & 0x20)

#define SUBID_9005_SEEPTYPE(id) ((id) & 0x0C0) >> 6)
#define		SUBID_9005_SEEPTYPE_NONE	0x0
#define		SUBID_9005_SEEPTYPE_4K		0x1

ahd_device_setup_t ahd_aic7901_setup;
ahd_device_setup_t ahd_aic7901A_setup;
ahd_device_setup_t ahd_aic7902_setup;
ahd_device_setup_t ahd_aic790X_setup;

struct ahd_pci_identity ahd_pci_ident_table [] =
{
	/* aic7901 based controllers */
	{
		ID_AHA_29320A,
		ID_ALL_MASK,
		ahd_aic7901_setup
	},
	{
		ID_AHA_29320ALP,
		ID_ALL_MASK,
		ahd_aic7901_setup
	},
	{
		ID_AHA_29320LPE,
		ID_ALL_MASK,
		ahd_aic7901_setup
	},
	/* aic7901A based controllers */
	{
		ID_AHA_29320LP,
		ID_ALL_MASK,
		ahd_aic7901A_setup
	},
	/* aic7902 based controllers */	
	{
		ID_AHA_29320,
		ID_ALL_MASK,
		ahd_aic7902_setup
	},
	{
		ID_AHA_29320B,
		ID_ALL_MASK,
		ahd_aic7902_setup
	},
	{
		ID_AHA_39320,
		ID_ALL_MASK,
		ahd_aic7902_setup
	},
	{
		ID_AHA_39320_B,
		ID_ALL_MASK,
		ahd_aic7902_setup
	},
	{
		ID_AHA_39320_B_DELL,
		ID_ALL_MASK,
		ahd_aic7902_setup
	},
	{
		ID_AHA_39320A,
		ID_ALL_MASK,
		ahd_aic7902_setup
	},
	{
		ID_AHA_39320D,
		ID_ALL_MASK,
		ahd_aic7902_setup
	},
	{
		ID_AHA_39320D_HP,
		ID_ALL_MASK,
		ahd_aic7902_setup
	},
	{
		ID_AHA_39320D_B,
		ID_ALL_MASK,
		ahd_aic7902_setup
	},
	{
		ID_AHA_39320D_B_HP,
		ID_ALL_MASK,
		ahd_aic7902_setup
	},
	/* Generic chip probes for devices we don't know 'exactly' */
	{
		ID_AIC7901 & ID_9005_GENERIC_MASK,
		ID_9005_GENERIC_MASK,
		ahd_aic7901_setup
	},
	{
		ID_AIC7901A & ID_DEV_VENDOR_MASK,
		ID_DEV_VENDOR_MASK,
		ahd_aic7901A_setup
	},
	{
		ID_AIC7902 & ID_9005_GENERIC_MASK,
		ID_9005_GENERIC_MASK,
		ahd_aic7902_setup
	}
};

const u_int ahd_num_pci_devs = NUM_ELEMENTS(ahd_pci_ident_table);
		
#define			DEVCONFIG		0x40
#define			PCIXINITPAT		0x0000E000ul
#define			PCIXINIT_PCI33_66	0x0000E000ul
#define			PCIXINIT_PCIX50_66	0x0000C000ul
#define			PCIXINIT_PCIX66_100	0x0000A000ul
#define			PCIXINIT_PCIX100_133	0x00008000ul
#define	PCI_BUS_MODES_INDEX(devconfig)	\
	(((devconfig) & PCIXINITPAT) >> 13)

static const char *pci_bus_modes[] =
{
	"PCI bus mode unknown",
	"PCI bus mode unknown",
	"PCI bus mode unknown",
	"PCI bus mode unknown",
	"PCI-X 101-133MHz",
	"PCI-X 67-100MHz",
	"PCI-X 50-66MHz",
	"PCI 33 or 66MHz"
};

#define		TESTMODE	0x00000800ul
#define		IRDY_RST	0x00000200ul
#define		FRAME_RST	0x00000100ul
#define		PCI64BIT	0x00000080ul
#define		MRDCEN		0x00000040ul
#define		ENDIANSEL	0x00000020ul
#define		MIXQWENDIANEN	0x00000008ul
#define		DACEN		0x00000004ul
#define		STPWLEVEL	0x00000002ul
#define		QWENDIANSEL	0x00000001ul

#define	DEVCONFIG1		0x44
#define		PREQDIS		0x01

#define	CSIZE_LATTIME		0x0c
#define		CACHESIZE	0x000000fful
#define		LATTIME		0x0000ff00ul

int	ahd_pci_probe(struct device *, void *, void *);
void	ahd_pci_attach(struct device *, struct device *, void *);
int	ahd_activate(struct device *, int);

struct cfattach ahd_pci_ca = {
        sizeof(struct ahd_softc), ahd_pci_probe, ahd_pci_attach,
	NULL, ahd_activate
};

int	ahd_check_extport(struct ahd_softc *ahd);
void	ahd_configure_termination(struct ahd_softc *ahd,
					  u_int adapter_control);
void	ahd_pci_split_intr(struct ahd_softc *ahd, u_int intstat);

const struct ahd_pci_identity *
ahd_find_pci_device(pcireg_t id, pcireg_t subid)
{
	const struct ahd_pci_identity *entry;
	u_int64_t full_id;
	u_int i;

	full_id = ahd_compose_id(PCI_PRODUCT(id), PCI_VENDOR(id),
	    PCI_PRODUCT(subid), PCI_VENDOR(subid));

	/*
	 * If we are configured to attach to HostRAID
	 * controllers, mask out the IROC/HostRAID bit
	 * in the
	 */
	if (ahd_attach_to_HostRAID_controllers)
		full_id &= ID_ALL_IROC_MASK;

	for (i = 0; i < ahd_num_pci_devs; i++) {
		entry = &ahd_pci_ident_table[i];
		if (entry->full_id == (full_id & entry->id_mask)) {
			return (entry);
		}
	}
	return (NULL);
}

int
ahd_pci_probe(struct device *parent, void *match, void *aux)
{
	const struct ahd_pci_identity *entry;
	struct pci_attach_args *pa = aux;
	pcireg_t subid;

	subid = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);
	entry = ahd_find_pci_device(pa->pa_id, subid);
	return entry != NULL ? 1 : 0;
}

void
ahd_pci_attach(struct device *parent, struct device *self, void *aux)
{
	const struct ahd_pci_identity *entry;
	struct pci_attach_args *pa = aux;
	struct ahd_softc *ahd = (void *)self;
	pci_intr_handle_t ih;
	const char *intrstr;
	pcireg_t devconfig, memtype, subid;
	uint16_t device, subvendor; 
	int error, ioh_valid, ioh2_valid, l, memh_valid;

	ahd->dev_softc = pa;
	ahd->parent_dmat = pa->pa_dmat;

	if (ahd_alloc(ahd, ahd->sc_dev.dv_xname) == NULL)
		return;

	subid = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);
	entry = ahd_find_pci_device(pa->pa_id, subid);
	if (entry == NULL)
		return;

	/*
	 * Record if this is a HostRAID board.
	 */
	device = PCI_PRODUCT(pa->pa_id);
	if (DEVID_9005_HOSTRAID(device))
		ahd->flags |= AHD_HOSTRAID_BOARD;

	/*
	 * Record if this is an HP board.
	 */
	subvendor = PCI_VENDOR(subid);
	if (subvendor == SUBID_HP)
		ahd->flags |= AHD_HP_BOARD;

	error = entry->setup(ahd, pa);
	if (error != 0)
		return;
	
	/* XXX ahc on sparc64 needs this twice */
	devconfig = pci_conf_read(pa->pa_pc, pa->pa_tag, DEVCONFIG);
	
	if ((devconfig & PCIXINITPAT) == PCIXINIT_PCI33_66) {
		ahd->chip |= AHD_PCI;
		/* Disable PCIX workarounds when running in PCI mode. */
		ahd->bugs &= ~AHD_PCIX_BUG_MASK;
	} else {
		ahd->chip |= AHD_PCIX;
	}
	ahd->bus_description = pci_bus_modes[PCI_BUS_MODES_INDEX(devconfig)];

	memh_valid = ioh_valid = ioh2_valid = 0;

	if (!pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_PCIX,
	    &ahd->pcix_off, NULL)) {
		if (ahd->chip & AHD_PCIX)
			printf("%s: warning: can't find PCI-X capability\n",
			    ahd_name(ahd));
		ahd->chip &= ~AHD_PCIX;
		ahd->chip |= AHD_PCI;
		ahd->bugs &= ~AHD_PCIX_BUG_MASK;
	}

	/*
	 * Map PCI registers
	 */
	if ((ahd->bugs & AHD_PCIX_MMAPIO_BUG) == 0) {
		memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag,
		    AHD_PCI_MEMADDR);
		switch (memtype) {
		case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
		case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
			memh_valid = (pci_mapreg_map(pa, AHD_PCI_MEMADDR,
			    memtype, 0, &ahd->tags[0], &ahd->bshs[0], NULL,
			    NULL, 0) == 0);
			if (memh_valid) {
				ahd->tags[1] = ahd->tags[0];
				bus_space_subregion(ahd->tags[0], ahd->bshs[0],
				    /*offset*/0x100, /*size*/0x100,
				    &ahd->bshs[1]);
				if (ahd_pci_test_register_access(ahd) != 0)
					memh_valid = 0;
			}
			break;
		default:
			memh_valid = 0;
			printf("%s: unknown memory type: 0x%x\n",
			ahd_name(ahd), memtype);
			break;
		}

#ifdef AHD_DEBUG
		printf("%s: doing memory mapping tag0 0x%x, tag1 0x%x, shs0 "
		    "0x%lx, shs1 0x%lx\n", ahd_name(ahd), ahd->tags[0],
		    ahd->tags[1], ahd->bshs[0], ahd->bshs[1]);
#endif
	}

	if (!memh_valid) {
		/* First BAR */
		ioh_valid = (pci_mapreg_map(pa, AHD_PCI_IOADDR,
		    PCI_MAPREG_TYPE_IO, 0, &ahd->tags[0], &ahd->bshs[0], NULL,
		    NULL, 0) == 0);

		/* 2nd BAR */
		ioh2_valid = (pci_mapreg_map(pa, AHD_PCI_IOADDR1,
		    PCI_MAPREG_TYPE_IO, 0, &ahd->tags[1], &ahd->bshs[1], NULL,
		    NULL, 0) == 0);

#ifdef AHD_DEBUG
		printf("%s: doing io mapping tag0 0x%x, tag1 0x%x, shs0 0x%lx, "
		    "shs1 0x%lx\n", ahd_name(ahd), ahd->tags[0], ahd->tags[1],
		    ahd->bshs[0], ahd->bshs[1]);
#endif
	}

	if (memh_valid == 0 && (ioh_valid == 0 || ioh2_valid == 0)) {
		printf("%s: unable to map registers\n", ahd_name(ahd));
		return;
	}

	/*
	 * Set Power State D0.
	 */
	pci_set_powerstate(pa->pa_pc, pa->pa_tag, PCI_PMCSR_STATE_D0);

	/*
	 * Should we bother disabling 39Bit addressing
	 * based on installed memory?
	 */
	if (sizeof(bus_addr_t) > 4)
		ahd->flags |= AHD_39BIT_ADDRESSING;

	/*
	 * If we need to support high memory, enable dual
	 * address cycles.  This bit must be set to enable
	 * high address bit generation even if we are on a
	 * 64bit bus (PCI64BIT set in devconfig).
	 */
	if ((ahd->flags & (AHD_39BIT_ADDRESSING|AHD_64BIT_ADDRESSING)) != 0) {
		if (bootverbose)
			printf("%s: Enabling 39Bit Addressing\n",
			       ahd_name(ahd));
		devconfig = pci_conf_read(pa->pa_pc, pa->pa_tag, DEVCONFIG);
		devconfig |= DACEN;
		pci_conf_write(pa->pa_pc, pa->pa_tag, DEVCONFIG, devconfig);
	}
	
	ahd_softc_init(ahd);

	/*
	 * Map the interrupts routines
	 */
	ahd->bus_intr = ahd_pci_intr;

	error = ahd_reset(ahd, /*reinit*/FALSE);
	if (error != 0) {
		ahd_free(ahd);
		return;
	}

	if (pci_intr_map(pa, &ih)) {
		printf("%s: couldn't map interrupt\n", ahd_name(ahd));
		ahd_free(ahd);
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	ahd->ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO,
	    ahd_platform_intr, ahd, ahd->sc_dev.dv_xname);
	if (ahd->ih == NULL) {
		printf("%s: couldn't establish interrupt", ahd_name(ahd));
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		ahd_free(ahd);
		return;
	}
	if (intrstr != NULL)
		printf(": %s\n", intrstr);
	
	/* Get the size of the cache */
	ahd->pci_cachesize = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);
	ahd->pci_cachesize *= 4;

	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
	/* See if we have a SEEPROM and perform auto-term */
	error = ahd_check_extport(ahd);
	if (error != 0)
		return;

	/* Core initialization */
	error = ahd_init(ahd);
	if (error != 0)
		return;

	ahd_list_lock(&l);
	/*
	 * Link this softc in with all other ahd instances.
	 */
	ahd_softc_insert(ahd);
	ahd_list_unlock(&l);

	/* complete the attach */
	ahd_attach(ahd);
}

int
ahd_activate(struct device *self, int act)
{
	int ret = 0;

	ret = config_activate_children(self, act);

	switch (act) {
	case DVACT_POWERDOWN:
		ahd_shutdown(self);
		break;
	}

	return (ret);
}

/*
 * Perform some simple tests that should catch situations where
 * our registers are invalidly mapped.
 */
int
ahd_pci_test_register_access(struct ahd_softc *ahd)
{
	const pci_chipset_tag_t pc = ahd->dev_softc->pa_pc;
	const pcitag_t tag = ahd->dev_softc->pa_tag;
	pcireg_t cmd;
	u_int	 targpcistat;
	pcireg_t pci_status1;
	int	 error;
	uint8_t	 hcntrl;

	error = EIO;

	/*
	 * Enable PCI error interrupt status, but suppress NMIs
	 * generated by SERR raised due to target aborts.
	 */
	cmd = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG,
	    cmd & ~PCI_COMMAND_SERR_ENABLE);

	/*
	 * First a simple test to see if any
	 * registers can be read.  Reading
	 * HCNTRL has no side effects and has
	 * at least one bit that is guaranteed to
	 * be zero so it is a good register to
	 * use for this test.
	 */
	hcntrl = ahd_inb(ahd, HCNTRL);
	if (hcntrl == 0xFF)
		goto fail;

	/*
	 * Next create a situation where write combining
	 * or read prefetching could be initiated by the
	 * CPU or host bridge.  Our device does not support
	 * either, so look for data corruption and/or flaged
	 * PCI errors.  First pause without causing another
	 * chip reset.
	 */
	hcntrl &= ~CHIPRST;
	ahd_outb(ahd, HCNTRL, hcntrl|PAUSE);
	while (ahd_is_paused(ahd) == 0)
		;

	/* Clear any PCI errors that occurred before our driver attached. */
	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
	targpcistat = ahd_inb(ahd, TARGPCISTAT);
	ahd_outb(ahd, TARGPCISTAT, targpcistat);
	pci_status1 = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, pci_status1);
	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
	ahd_outb(ahd, CLRINT, CLRPCIINT);

	ahd_outb(ahd, SEQCTL0, PERRORDIS);
	ahd_outl(ahd, SRAM_BASE, 0x5aa555aa);
	if (ahd_inl(ahd, SRAM_BASE) != 0x5aa555aa)
		goto fail;

	if ((ahd_inb(ahd, INTSTAT) & PCIINT) != 0) {
		ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
		targpcistat = ahd_inb(ahd, TARGPCISTAT);
		if ((targpcistat & STA) != 0)
			goto fail;
	}

	error = 0;

fail:
	if ((ahd_inb(ahd, INTSTAT) & PCIINT) != 0) {

		ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
		targpcistat = ahd_inb(ahd, TARGPCISTAT);

		/* Silently clear any latched errors. */
		ahd_outb(ahd, TARGPCISTAT, targpcistat);
		pci_status1 = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
		pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, pci_status1);
		ahd_outb(ahd, CLRINT, CLRPCIINT);
	}
	ahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS);
	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, cmd);
	return (error);
}

/*
 * Check the external port logic for a serial eeprom
 * and termination/cable detection contrls.
 */
int
ahd_check_extport(struct ahd_softc *ahd)
{
	struct	vpd_config vpd;
	struct	seeprom_config *sc;
	u_int	adapter_control;
	int	have_seeprom;
	int	error;

	sc = ahd->seep_config;
	have_seeprom = ahd_acquire_seeprom(ahd);
	if (have_seeprom) {
		u_int start_addr;

		/*
		 * Fetch VPD for this function and parse it.
		 */
		if (bootverbose) 
			printf("%s: Reading VPD from SEEPROM...",
			       ahd_name(ahd));

		/* Address is always in units of 16bit words */
		start_addr = ((2 * sizeof(*sc))
			    + (sizeof(vpd) * (ahd->channel - 'A'))) / 2;

		error = ahd_read_seeprom(ahd, (uint16_t *)&vpd,
					 start_addr, sizeof(vpd)/2,
					 /*bytestream*/TRUE);
		if (error == 0)
			error = ahd_parse_vpddata(ahd, &vpd);
		if (bootverbose) 
			printf("%s: VPD parsing %s\n",
			       ahd_name(ahd),
			       error == 0 ? "successful" : "failed");

		if (bootverbose) 
			printf("%s: Reading SEEPROM...", ahd_name(ahd));

		/* Address is always in units of 16bit words */
		start_addr = (sizeof(*sc) / 2) * (ahd->channel - 'A');

		error = ahd_read_seeprom(ahd, (uint16_t *)sc,
					 start_addr, sizeof(*sc)/2,
					 /*bytestream*/FALSE);

		if (error != 0) {
			printf("Unable to read SEEPROM\n");
			have_seeprom = 0;
		} else {
			have_seeprom = ahd_verify_cksum(sc);

			if (bootverbose) {
				if (have_seeprom == 0)
					printf ("checksum error\n");
				else
					printf ("done.\n");
			}
		}
		ahd_release_seeprom(ahd);
	}

	if (!have_seeprom) {
		u_int	  nvram_scb;

		/*
		 * Pull scratch ram settings and treat them as
		 * if they are the contents of an seeprom if
		 * the 'ADPT', 'BIOS', or 'ASPI' signature is found
		 * in SCB 0xFF.  We manually compose the data as 16bit
		 * values to avoid endian issues.
		 */
		ahd_set_scbptr(ahd, 0xFF);
		nvram_scb = ahd_inb_scbram(ahd, SCB_BASE + NVRAM_SCB_OFFSET);
		if (nvram_scb != 0xFF
		 && ((ahd_inb_scbram(ahd, SCB_BASE + 0) == 'A'
		   && ahd_inb_scbram(ahd, SCB_BASE + 1) == 'D'
		   && ahd_inb_scbram(ahd, SCB_BASE + 2) == 'P'
		   && ahd_inb_scbram(ahd, SCB_BASE + 3) == 'T')
		  || (ahd_inb_scbram(ahd, SCB_BASE + 0) == 'B'
		   && ahd_inb_scbram(ahd, SCB_BASE + 1) == 'I'
		   && ahd_inb_scbram(ahd, SCB_BASE + 2) == 'O'
		   && ahd_inb_scbram(ahd, SCB_BASE + 3) == 'S')
		  || (ahd_inb_scbram(ahd, SCB_BASE + 0) == 'A'
		   && ahd_inb_scbram(ahd, SCB_BASE + 1) == 'S'
		   && ahd_inb_scbram(ahd, SCB_BASE + 2) == 'P'
		   && ahd_inb_scbram(ahd, SCB_BASE + 3) == 'I'))) {
			uint16_t *sc_data;
			int	  i;

			ahd_set_scbptr(ahd, nvram_scb);
			sc_data = (uint16_t *)sc;
			for (i = 0; i < 64; i += 2)
				*sc_data++ = ahd_inw_scbram(ahd, SCB_BASE+i);
			have_seeprom = ahd_verify_cksum(sc);
			if (have_seeprom)
				ahd->flags |= AHD_SCB_CONFIG_USED;
		}
	}

#ifdef AHD_DEBUG
	if (have_seeprom != 0
	 && (ahd_debug & AHD_DUMP_SEEPROM) != 0) {
		uint16_t *sc_data;
		int	  i;

		printf("%s: Seeprom Contents:", ahd_name(ahd));
		sc_data = (uint16_t *)sc;
		for (i = 0; i < (sizeof(*sc)); i += 2)
			printf("\n\t0x%.4x", sc_data[i]);
		printf("\n");
	}
#endif

	if (!have_seeprom) {
		if (bootverbose)
			printf("%s: No SEEPROM available.\n", ahd_name(ahd));
		ahd->flags |= AHD_USEDEFAULTS;
		error = ahd_default_config(ahd);
		adapter_control = CFAUTOTERM|CFSEAUTOTERM;
		free(ahd->seep_config, M_DEVBUF, 0);
		ahd->seep_config = NULL;
	} else {
		error = ahd_parse_cfgdata(ahd, sc);
		adapter_control = sc->adapter_control;
	}
	if (error != 0)
		return (error);

	ahd_configure_termination(ahd, adapter_control);

	return (0);
}

void
ahd_configure_termination(struct ahd_softc *ahd, u_int adapter_control)
{
	const pci_chipset_tag_t pc = ahd->dev_softc->pa_pc;
	const pcitag_t tag = ahd->dev_softc->pa_tag;
	int	 error;
	u_int	 sxfrctl1;
	uint8_t	 termctl;
	pcireg_t devconfig;

	devconfig = pci_conf_read(pc, tag, DEVCONFIG);
	devconfig &= ~STPWLEVEL;
	if ((ahd->flags & AHD_STPWLEVEL_A) != 0)
		devconfig |= STPWLEVEL;
	if (bootverbose)
		printf("%s: STPWLEVEL is %s\n",
		       ahd_name(ahd), (devconfig & STPWLEVEL) ? "on" : "off");
	pci_conf_write(pc, tag, DEVCONFIG, devconfig);

	/* Make sure current sensing is off. */
	if ((ahd->flags & AHD_CURRENT_SENSING) != 0) {
		(void)ahd_write_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL, 0);
	}

	/*
	 * Read to sense.  Write to set.
	 */
	error = ahd_read_flexport(ahd, FLXADDR_TERMCTL, &termctl);
	if ((adapter_control & CFAUTOTERM) == 0) {
		if (bootverbose)
			printf("%s: Manual Primary Termination\n",
			       ahd_name(ahd));
		termctl &= ~(FLX_TERMCTL_ENPRILOW|FLX_TERMCTL_ENPRIHIGH);
		if ((adapter_control & CFSTERM) != 0)
			termctl |= FLX_TERMCTL_ENPRILOW;
		if ((adapter_control & CFWSTERM) != 0)
			termctl |= FLX_TERMCTL_ENPRIHIGH;
	} else if (error != 0) {
		printf("%s: Primary Auto-Term Sensing failed! "
		       "Using Defaults.\n", ahd_name(ahd));
		termctl = FLX_TERMCTL_ENPRILOW|FLX_TERMCTL_ENPRIHIGH;
	}

	if ((adapter_control & CFSEAUTOTERM) == 0) {
		if (bootverbose)
			printf("%s: Manual Secondary Termination\n",
			       ahd_name(ahd));
		termctl &= ~(FLX_TERMCTL_ENSECLOW|FLX_TERMCTL_ENSECHIGH);
		if ((adapter_control & CFSELOWTERM) != 0)
			termctl |= FLX_TERMCTL_ENSECLOW;
		if ((adapter_control & CFSEHIGHTERM) != 0)
			termctl |= FLX_TERMCTL_ENSECHIGH;
	} else if (error != 0) {
		printf("%s: Secondary Auto-Term Sensing failed! "
		       "Using Defaults.\n", ahd_name(ahd));
		termctl |= FLX_TERMCTL_ENSECLOW|FLX_TERMCTL_ENSECHIGH;
	}

	/*
	 * Now set the termination based on what we found.
	 */
	sxfrctl1 = ahd_inb(ahd, SXFRCTL1) & ~STPWEN;
	ahd->flags &= ~AHD_TERM_ENB_A;
	if ((termctl & FLX_TERMCTL_ENPRILOW) != 0) {
		ahd->flags |= AHD_TERM_ENB_A;
		sxfrctl1 |= STPWEN;
	}
	/* Must set the latch once in order to be effective. */
	ahd_outb(ahd, SXFRCTL1, sxfrctl1|STPWEN);
	ahd_outb(ahd, SXFRCTL1, sxfrctl1);

	error = ahd_write_flexport(ahd, FLXADDR_TERMCTL, termctl);
	if (error != 0) {
		printf("%s: Unable to set termination settings!\n",
		       ahd_name(ahd));
	} else if (bootverbose) {
		printf("%s: Primary High byte termination %sabled\n",
		       ahd_name(ahd),
		       (termctl & FLX_TERMCTL_ENPRIHIGH) ? "En" : "Dis");

		printf("%s: Primary Low byte termination %sabled\n",
		       ahd_name(ahd),
		       (termctl & FLX_TERMCTL_ENPRILOW) ? "En" : "Dis");

		printf("%s: Secondary High byte termination %sabled\n",
		       ahd_name(ahd),
		       (termctl & FLX_TERMCTL_ENSECHIGH) ? "En" : "Dis");

		printf("%s: Secondary Low byte termination %sabled\n",
		       ahd_name(ahd),
		       (termctl & FLX_TERMCTL_ENSECLOW) ? "En" : "Dis");
	}
	return;
}

#define	DPE	0x80
#define SSE	0x40
#define	RMA	0x20
#define	RTA	0x10
#define STA	0x08
#define DPR	0x01

static const char *split_status_source[] =
{
	"DFF0",
	"DFF1",
	"OVLY",
	"CMC",
};

static const char *pci_status_source[] =
{
	"DFF0",
	"DFF1",
	"SG",
	"CMC",
	"OVLY",
	"NONE",
	"MSI",
	"TARG"
};

static const char *split_status_strings[] =
{
	"Received split response",
	"Received split completion error message",
	"Receive overrun",
	"Count not complete",
	"Split completion data bucket",
	"Split completion address error",
	"Split completion byte count error",
	"Signaled Target-abort to early terminate a split"
};

static const char *pci_status_strings[] =
{
	"Data Parity Error has been reported via PERR#",
	"Target initial wait state error",
	"Split completion read data parity error",
	"Split completion address attribute parity error",
	"Received a Target Abort",
	"Received a Master Abort",
	"Signal System Error Detected",
	"Address or Write Phase Parity Error Detected"
};

void
ahd_pci_intr(struct ahd_softc *ahd)
{
	const pci_chipset_tag_t pc = ahd->dev_softc->pa_pc;
	const pcitag_t tag = ahd->dev_softc->pa_tag;
	uint8_t		pci_status[8];
	ahd_mode_state	saved_modes;
	pcireg_t	pci_status1;
	u_int		intstat;
	u_int		i;
	u_int		reg;
	
	intstat = ahd_inb(ahd, INTSTAT);

	if ((intstat & SPLTINT) != 0)
		ahd_pci_split_intr(ahd, intstat);

	if ((intstat & PCIINT) == 0)
		return;

	printf("%s: PCI error Interrupt\n", ahd_name(ahd));
	saved_modes = ahd_save_modes(ahd);
	ahd_dump_card_state(ahd);
	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
	for (i = 0, reg = DF0PCISTAT; i < 8; i++, reg++) {

		if (i == 5)
			continue;
		pci_status[i] = ahd_inb(ahd, reg);
		/* Clear latched errors.  So our interrupt deasserts. */
		ahd_outb(ahd, reg, pci_status[i]);
	}

	for (i = 0; i < 8; i++) {
		u_int bit;
	
		if (i == 5)
			continue;

		for (bit = 0; bit < 8; bit++) {

			if ((pci_status[i] & (0x1 << bit)) != 0) {
				if (i == 7/*TARG*/ && bit == 3)
					printf("%s: Signaled Target Abort\n",
					    ahd_name(ahd));
				else
					printf("%s: %s in %s\n", ahd_name(ahd),
					    pci_status_strings[bit],
					    pci_status_source[i]);
			}
		}	
	}
	pci_status1 = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG , pci_status1);

	ahd_restore_modes(ahd, saved_modes);
	ahd_outb(ahd, CLRINT, CLRPCIINT);
	ahd_unpause(ahd);

	return;
}

void
ahd_pci_split_intr(struct ahd_softc *ahd, u_int intstat)
{
	const pci_chipset_tag_t pc = ahd->dev_softc->pa_pc;
	const pcitag_t tag = ahd->dev_softc->pa_tag;
	uint8_t		split_status[4];
	uint8_t		split_status1[4];
	uint8_t		sg_split_status[2];
	uint8_t		sg_split_status1[2];
	ahd_mode_state	saved_modes;
	u_int		i;
	pcireg_t	pcix_status;

	/*
	 * Check for splits in all modes.  Modes 0 and 1
	 * additionally have SG engine splits to look at.
	 */
	pcix_status = pci_conf_read(pc, tag, ahd->pcix_off + 0x04);
	printf("%s: PCI Split Interrupt - PCI-X status = 0x%x\n",
	       ahd_name(ahd), pcix_status);

	saved_modes = ahd_save_modes(ahd);
	for (i = 0; i < 4; i++) {
		ahd_set_modes(ahd, i, i);

		split_status[i] = ahd_inb(ahd, DCHSPLTSTAT0);
		split_status1[i] = ahd_inb(ahd, DCHSPLTSTAT1);
		/* Clear latched errors.  So our interrupt deasserts. */
		ahd_outb(ahd, DCHSPLTSTAT0, split_status[i]);
		ahd_outb(ahd, DCHSPLTSTAT1, split_status1[i]);
		if (i > 1)
			continue;
		sg_split_status[i] = ahd_inb(ahd, SGSPLTSTAT0);
		sg_split_status1[i] = ahd_inb(ahd, SGSPLTSTAT1);
		/* Clear latched errors.  So our interrupt deasserts. */
		ahd_outb(ahd, SGSPLTSTAT0, sg_split_status[i]);
		ahd_outb(ahd, SGSPLTSTAT1, sg_split_status1[i]);
	}

	for (i = 0; i < 4; i++) {
		u_int bit;

		for (bit = 0; bit < 8; bit++) {

			if ((split_status[i] & (0x1 << bit)) != 0) {
				printf("%s: %s in %s\n", ahd_name(ahd),
				    split_status_strings[bit],
				    split_status_source[i]);
			}

			if (i > 1)
				continue;

			if ((sg_split_status[i] & (0x1 << bit)) != 0) {
				printf("%s: %s in %s\n", ahd_name(ahd),
				    split_status_strings[bit], "SG");
			}
		}
	}
	/*
	 * Clear PCI-X status bits.
	 */
	pci_conf_write(pc, tag, ahd->pcix_off + 0x04, pcix_status);
	ahd_outb(ahd, CLRINT, CLRSPLTINT);
	ahd_restore_modes(ahd, saved_modes);
}

int
ahd_aic7901_setup(struct ahd_softc *ahd, struct pci_attach_args *pa)
{

	ahd->chip = AHD_AIC7901;
	ahd->features = AHD_AIC7901_FE;
	return (ahd_aic790X_setup(ahd, pa));
}

int
ahd_aic7901A_setup(struct ahd_softc *ahd, struct pci_attach_args *pa)
{

	ahd->chip = AHD_AIC7901A;
	ahd->features = AHD_AIC7901A_FE;
	return (ahd_aic790X_setup(ahd, pa));
}

int
ahd_aic7902_setup(struct ahd_softc *ahd, struct pci_attach_args *pa)
{
	ahd->chip = AHD_AIC7902;
	ahd->features = AHD_AIC7902_FE;
	return (ahd_aic790X_setup(ahd, pa));
}

int
ahd_aic790X_setup(struct ahd_softc *ahd, struct pci_attach_args *pa)
{
	u_int rev;

	rev = PCI_REVISION(pa->pa_class);
#ifdef AHD_DEBUG
	printf("\n%s: aic7902 chip revision 0x%x\n", ahd_name(ahd), rev);
#endif
	if (rev < ID_AIC7902_PCI_REV_A4) {
		printf("%s: Unable to attach to unsupported chip revision %d\n",
		       ahd_name(ahd), rev);
		pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, 0);
		return (ENXIO);
	}

	ahd->channel = (pa->pa_function == 1) ? 'B' : 'A';
	if (rev < ID_AIC7902_PCI_REV_B0) {
		/*
		 * Enable A series workarounds.
		 */
		ahd->bugs |= AHD_SENT_SCB_UPDATE_BUG|AHD_ABORT_LQI_BUG
			  |  AHD_PKT_BITBUCKET_BUG|AHD_LONG_SETIMO_BUG
			  |  AHD_NLQICRC_DELAYED_BUG|AHD_SCSIRST_BUG
			  |  AHD_LQO_ATNO_BUG|AHD_AUTOFLUSH_BUG
			  |  AHD_CLRLQO_AUTOCLR_BUG|AHD_PCIX_MMAPIO_BUG
			  |  AHD_PCIX_CHIPRST_BUG|AHD_PCIX_SCBRAM_RD_BUG
			  |  AHD_PKTIZED_STATUS_BUG|AHD_PKT_LUN_BUG
			  |  AHD_MDFF_WSCBPTR_BUG|AHD_REG_SLOW_SETTLE_BUG
			  |  AHD_SET_MODE_BUG|AHD_BUSFREEREV_BUG
			  |  AHD_NONPACKFIFO_BUG|AHD_PACED_NEGTABLE_BUG
			  |  AHD_FAINT_LED_BUG;

		/*
		 * IO Cell parameter setup.
		 */
		AHD_SET_PRECOMP(ahd, AHD_PRECOMP_CUTBACK_29);

		if ((ahd->flags & AHD_HP_BOARD) == 0)
			AHD_SET_SLEWRATE(ahd, AHD_SLEWRATE_DEF_REVA);
	} else {
		pcireg_t devconfig1;

		ahd->features |= AHD_RTI|AHD_NEW_IOCELL_OPTS
			      |  AHD_NEW_DFCNTRL_OPTS|AHD_FAST_CDB_DELIVERY;
		ahd->bugs |= AHD_LQOOVERRUN_BUG|AHD_EARLY_REQ_BUG
		    	  |  AHD_BUSFREEREV_BUG;

		/*
		 * Some issues have been resolved in the 7901B.
		 */
		if ((ahd->features & AHD_MULTI_FUNC) != 0)
			ahd->bugs |= AHD_INTCOLLISION_BUG|AHD_ABORT_LQI_BUG;

		/*
		 * IO Cell parameter setup.
		 */
		AHD_SET_PRECOMP(ahd, AHD_PRECOMP_CUTBACK_29);
		AHD_SET_SLEWRATE(ahd, AHD_SLEWRATE_DEF_REVB);
		AHD_SET_AMPLITUDE(ahd, AHD_AMPLITUDE_DEF);

		/*
		 * Set the PREQDIS bit for H2B which disables some workaround
		 * that doesn't work on regular PCI busses.
		 * XXX - Find out exactly what this does from the hardware
		 * 	 folks!
		 */
		devconfig1 = pci_conf_read(pa->pa_pc, pa->pa_tag, DEVCONFIG1);
		pci_conf_write(pa->pa_pc, pa->pa_tag, DEVCONFIG1, devconfig1|PREQDIS);
		devconfig1 = pci_conf_read(pa->pa_pc, pa->pa_tag, DEVCONFIG1);
	}

	return (0);
}
@


1.23
log
@Factor out of {split,pci}_status_strings[] the printf formattings bits,
putting them in the actual printf() calls.  Shuts up gcc -Wformat=2 and
reduces the space spent on string constants.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.22 2013/05/30 16:15:02 deraadt Exp $	*/
d774 1
a774 1
		free(ahd->seep_config, M_DEVBUF);
@


1.22
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.21 2012/12/05 23:20:19 deraadt Exp $	*/
d912 8
a919 8
	"%s: Received split response in %s.\n",
	"%s: Received split completion error message in %s\n",
	"%s: Receive overrun in %s\n",
	"%s: Count not complete in %s\n",
	"%s: Split completion data bucket in %s\n",
	"%s: Split completion address error in %s\n",
	"%s: Split completion byte count error in %s\n",
	"%s: Signaled Target-abort to early terminate a split in %s\n"
d924 8
a931 8
	"%s: Data Parity Error has been reported via PERR# in %s\n",
	"%s: Target initial wait state error in %s\n",
	"%s: Split completion read data parity error in %s\n",
	"%s: Split completion address attribute parity error in %s\n",
	"%s: Received a Target Abort in %s\n",
	"%s: Received a Master Abort in %s\n",
	"%s: Signal System Error Detected in %s\n",
	"%s: Address or Write Phase Parity Error Detected in %s.\n"
a975 3
				static const char *s;

				s = pci_status_strings[bit];
d977 6
a982 2
					s = "%s: Signaled Target Abort\n";
				printf(s, ahd_name(ahd), pci_status_source[i]);
d1041 3
a1043 5
				static const char *s;

				s = split_status_strings[bit];
				printf(s, ahd_name(ahd),
				       split_status_source[i]);
d1050 2
a1051 4
				static const char *s;

				s = split_status_strings[bit];
				printf(s, ahd_name(ahd), "SG");
@


1.21
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.20 2012/09/30 21:46:09 brad Exp $	*/
d286 1
d289 2
a290 1
	        sizeof(struct ahd_softc), ahd_pci_probe, ahd_pci_attach
d543 16
@


1.20
log
@Correct the addition of the 39320LPE controller. The actual product name
is 29320LPE since it is a single channel adapter. No functional change
other than priting the correct chipset in the dmesg.

Pointed out by henning petersen.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.19 2012/09/28 02:59:29 brad Exp $	*/
a70 5

#include <sys/cdefs.h>
/*
__FBSDID("$FreeBSD: src/sys/dev/aic7xxx/aic79xx_pci.c,v 1.18 2004/02/04 16:38:38 gibbs Exp $");
*/
@


1.19
log
@Add support for the Adaptec 39320LPE controller.

From FreeBSD

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.18 2009/05/31 04:47:59 deraadt Exp $	*/
d106 1
a122 1
#define ID_AHA_39320LPE 		0x8017900500459005ull
d168 5
a226 5
		ID_ALL_MASK,
		ahd_aic7902_setup
	},
	{
		ID_AHA_39320LPE,
@


1.18
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.17 2007/10/22 03:16:35 fgsch Exp $	*/
d122 1
d222 5
@


1.17
log
@Use pci_set_powerstate(), shrinking the code and unifying the different
versions. ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.16 2007/10/20 22:44:01 fgsch Exp $	*/
d504 1
a504 1
	ahd_platform_intr, ahd, ahd->sc_dev.dv_xname);
@


1.16
log
@Remove unneeded scope declarations that shadows existing ones. krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.15 2006/10/19 10:55:56 tom Exp $	*/
d342 1
a342 1
	pcireg_t devconfig, memtype, reg, subid;
d344 1
a344 1
	int error, ioh_valid, ioh2_valid, l, memh_valid, offset;
d460 1
a460 10
	if (pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_PWRMGMT, &offset,
	    NULL)) {
		/* Increment offset from cap register to csr register. */
		offset += 4;
		reg = pci_conf_read(pa->pa_pc, pa->pa_tag, offset);
		if ((reg & PCI_PMCSR_STATE_MASK) != PCI_PMCSR_STATE_D0) {
			pci_conf_write(pa->pa_pc, pa->pa_tag, offset,
			    (reg & ~PCI_PMCSR_STATE_MASK) | PCI_PMCSR_STATE_D0);
		}
	}
@


1.15
log
@s/Mhz/MHz/ in comments and printf() strings

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.14 2006/07/11 18:50:05 kettenis Exp $	*/
a484 2
		pcireg_t devconfig;

a615 2
		u_int targpcistat;

@


1.14
log
@Do not fiddle with the io/mem space enable bits in the PCI command/status
register.  This avoids accidentally resetting bits set by mapping BARs.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.13 2006/05/18 21:27:24 miod Exp $	*/
d259 4
a262 4
	"PCI-X 101-133Mhz",
	"PCI-X 67-100Mhz",
	"PCI-X 50-66Mhz",
	"PCI 33 or 66Mhz"
@


1.13
log
@paramter -> parameter
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.12 2005/08/09 04:10:10 mickey Exp $	*/
d342 1
a342 1
	pcireg_t command, devconfig, memtype, reg, subid;
a351 1
	command = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
a426 5
		if (memh_valid) {
			command &= ~PCI_COMMAND_IO_ENABLE;
			pci_conf_write(pa->pa_pc, pa->pa_tag,
			    PCI_COMMAND_STATUS_REG, command);
		}
d434 1
a434 1
	if (command & PCI_COMMAND_IO_ENABLE) {
a444 6
		if (ioh_valid && ioh2_valid) {
			KASSERT(memh_valid == 0);
			command &= ~PCI_COMMAND_MEM_ENABLE;
			pci_conf_write(pa->pa_pc, pa->pa_tag,
			    PCI_COMMAND_STATUS_REG, command);
		}
@


1.12
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.11 2004/12/19 06:17:54 krw Exp $	*/
d1132 1
a1132 1
		 * IO Cell paramter setup.
d1153 1
a1153 1
		 * IO Cell paramter setup.
@


1.11
log
@Reduce delta to FreeBSD by adding and using ahd_alloc() rather than
manually reproducing bits in ahd_pci.c.

Just as in ahc, avoid allocating and freeing zero length bits of
memory for platform data.

Don't try to free all or part of ahd_softc, but correctly free
allocated memory for seep_config if necessary.

Add a final few fields to ahd_softc and scb in preparation for
updating/fixing timeout handling.

No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.10 2004/12/10 17:43:19 krw Exp $	*/
a506 5
	/* Ensure busmastering is enabled */
	command = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	command |= PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);

@


1.10
log
@Turn on the BUSFREEREV bug for the Rev. B controller. This is required
to close the 'busfree during non-packetized phase' hole.

From FreeBSD aic79xx_pci.c r1.20.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.9 2004/11/18 01:33:28 krw Exp $	*/
a339 1
	struct scb_data *shared_scb_data;
a345 1
	shared_scb_data = NULL;
d347 1
d349 2
a350 2
	ahd_set_name(ahd, ahd->sc_dev.dv_xname);
	ahd->parent_dmat = pa->pa_dmat;
a356 23

	ahd->seep_config = malloc(sizeof(*ahd->seep_config),
				M_DEVBUF, M_NOWAIT);
	if (ahd->seep_config == NULL) {
		printf("%s: cannot malloc seep_config!\n", ahd_name(ahd));
		return;
	}
	memset(ahd->seep_config, 0, sizeof(*ahd->seep_config));

	LIST_INIT(&ahd->pending_scbs);

	ahd->flags = AHD_SPCHK_ENB_A|AHD_RESET_BUS_A|AHD_TERM_ENB_A
	    | AHD_EXTENDED_TRANS_A|AHD_STPWLEVEL_A;
	ahd->int_coalescing_timer = AHD_INT_COALESCING_TIMER_DEFAULT;
	ahd->int_coalescing_maxcmds = AHD_INT_COALESCING_MAXCMDS_DEFAULT;
	ahd->int_coalescing_mincmds = AHD_INT_COALESCING_MINCMDS_DEFAULT;
	ahd->int_coalescing_threshold = AHD_INT_COALESCING_THRESHOLD_DEFAULT;
	ahd->int_coalescing_stop_threshold = AHD_INT_COALESCING_STOP_THRESHOLD_DEFAULT;

	if (ahd_platform_alloc(ahd, NULL) != 0) {
		ahd_free(ahd);
		return;
	}
@


1.9
log
@More NetBSD cruft removal/FreeBSD delta reduction. Whitespace, function and variable shuffle. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.8 2004/11/14 02:32:08 krw Exp $	*/
d1172 2
a1173 1
		ahd->bugs |= AHD_LQOOVERRUN_BUG|AHD_EARLY_REQ_BUG;
@


1.8
log
@KNF large chunks of tab-free code discovered while working on previous
commit. Whitespace, line break and declaration shuffling changes only.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.7 2004/11/14 01:25:14 krw Exp $	*/
a367 3

	timeout_set(&ahd->reset_timer, ahd_reset_poll, ahd);
	timeout_set(&ahd->stat_timer, ahd_stat_timer, ahd);
@


1.7
log
@More NetBSD cruft removal, starting with 'struct ahd_pci_busdata' and
the fallout from that. Ensure pcireg_t variables are being used with
pci_conf_read/write functions - found one uint16_t variable
(pcix_status) being used to store and restore (32 bit) pcireg_t
values.

Some KNF.

No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.6 2004/08/23 18:36:10 marco Exp $	*/
d298 3
a300 3
        u_int64_t  full_id;
        const struct       ahd_pci_identity *entry;
        u_int      i;
d302 2
a303 2
        full_id = ahd_compose_id(PCI_PRODUCT(id), PCI_VENDOR(id),
                                 PCI_PRODUCT(subid), PCI_VENDOR(subid));
d325 7
a331 7
        struct pci_attach_args *pa = aux;
        const struct       ahd_pci_identity *entry;
        pcireg_t   subid;

        subid = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);
        entry = ahd_find_pci_device(pa->pa_id, subid);
        return entry != NULL ? 1 : 0;
d420 2
a421 1
			printf("%s: warning: can't find PCI-X capability\n", ahd->sc_dev.dv_xname);
d430 30
a459 32
        if ((ahd->bugs & AHD_PCIX_MMAPIO_BUG) == 0) {
                memtype = pci_mapreg_type(pa->pa_pc, pa->pa_tag,
                                          AHD_PCI_MEMADDR);
                switch (memtype) {
                case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
                case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
                        memh_valid = (pci_mapreg_map(pa, AHD_PCI_MEMADDR,
                                                     memtype, 0, &ahd->tags[0],
                                                     &ahd->bshs[0],
                                                     NULL, NULL, 0) == 0);
                        if (memh_valid) {
                                ahd->tags[1] = ahd->tags[0];
                                bus_space_subregion(ahd->tags[0], ahd->bshs[0],
                                                    /*offset*/0x100,
                                                    /*size*/0x100,
                                                    &ahd->bshs[1]);
                                if (ahd_pci_test_register_access(ahd) != 0)
                                        memh_valid = 0;
                        }
                        break;
                default:
                        memh_valid = 0;
                        printf("%s: unknown memory type: 0x%x\n",
                               ahd_name(ahd), memtype);
                        break;
                }

                if (memh_valid) {
                        command &= ~PCI_COMMAND_IO_ENABLE;
                        pci_conf_write(pa->pa_pc, pa->pa_tag,
                                       PCI_COMMAND_STATUS_REG, command);
                }
d461 3
a463 4
                printf("%s: doing memory mapping tag0 0x%x, tag1 0x%x, "
                    "shs0 0x%lx, shs1 0x%lx\n",
                    ahd_name(ahd), ahd->tags[0], ahd->tags[1],
                    ahd->bshs[0], ahd->bshs[1]);
d465 1
a465 1
        }
d467 17
a483 19
        if (command & PCI_COMMAND_IO_ENABLE) {
                /* First BAR */
                ioh_valid = (pci_mapreg_map(pa, AHD_PCI_IOADDR,
                                            PCI_MAPREG_TYPE_IO, 0,
                                            &ahd->tags[0], &ahd->bshs[0],
                                            NULL, NULL, 0) == 0);

                /* 2nd BAR */
                ioh2_valid = (pci_mapreg_map(pa, AHD_PCI_IOADDR1,
                                             PCI_MAPREG_TYPE_IO, 0,
                                             &ahd->tags[1], &ahd->bshs[1],
                                             NULL, NULL, 0) == 0);

                if (ioh_valid && ioh2_valid) {
                        KASSERT(memh_valid == 0);
                        command &= ~PCI_COMMAND_MEM_ENABLE;
                        pci_conf_write(pa->pa_pc, pa->pa_tag,
                                       PCI_COMMAND_STATUS_REG, command);
                }
d485 3
a487 3
                printf("%s: doing io mapping tag0 0x%x, tag1 0x%x, "
                    "shs0 0x%lx, shs1 0x%lx\n", ahd_name(ahd), ahd->tags[0],
                    ahd->tags[1], ahd->bshs[0], ahd->bshs[1]);
d489 1
d491 4
a494 1
        }
d496 4
a499 9
        if (memh_valid == 0 && (ioh_valid == 0 || ioh2_valid == 0)) {
                printf("%s: unable to map registers\n", ahd_name(ahd));
                return;
        }

        /*
         * Set Power State D0.
         */
        if (pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_PWRMGMT, &offset,
d502 7
a508 7
                offset += 4;
                reg = pci_conf_read(pa->pa_pc, pa->pa_tag, offset);
                if ((reg & PCI_PMCSR_STATE_MASK) != PCI_PMCSR_STATE_D0) {
                        pci_conf_write(pa->pa_pc, pa->pa_tag, offset,
                            (reg & ~PCI_PMCSR_STATE_MASK) | PCI_PMCSR_STATE_D0);
                }
        }
d513 3
a515 3
	 *                            */
        if (sizeof(bus_addr_t) > 4)
                ahd->flags |= AHD_39BIT_ADDRESSING;
d552 18
a569 18
        if (pci_intr_map(pa, &ih)) {
                printf("%s: couldn't map interrupt\n", ahd_name(ahd));
                ahd_free(ahd);
                return;
        }
        intrstr = pci_intr_string(pa->pa_pc, ih);
        ahd->ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO,
	    ahd_platform_intr, ahd, ahd->sc_dev.dv_xname);
        if (ahd->ih == NULL) {
                printf("%s: couldn't establish interrupt", ahd_name(ahd));
                if (intrstr != NULL)
                        printf(" at %s", intrstr);
                printf("\n");
                ahd_free(ahd);
                return;
        }
        if (intrstr != NULL)
                printf(": %s\n", intrstr);
d572 2
a573 2
        ahd->pci_cachesize = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);
        ahd->pci_cachesize *= 4;
d619 2
a620 2
        pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG,
                             cmd & ~PCI_COMMAND_SERR_ENABLE);
d652 1
a652 1
        pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, pci_status1);
d681 1
a681 1
                pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, pci_status1);
d844 1
a844 1
 
d1024 1
a1024 1
        pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG , pci_status1);
d1137 1
a1137 1
        printf("\n%s: aic7902 chip revision 0x%x\n", ahd_name(ahd), rev);
@


1.6
log
@Fix license.  ok krw@@, deraadt@@ tedu@@ & Milos Urbanek <urbanek at zoom-int.cz>
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.5 2004/06/23 03:23:18 marco Exp $	*/
d296 1
a296 2
ahd_find_pci_device(id, subid)
        pcireg_t id, subid;
d323 1
a323 4
ahd_pci_probe(parent, match, aux)
        struct device *parent;
        void *match;
        void *aux;
d335 1
a335 3
ahd_pci_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d337 3
a339 2
	struct pci_attach_args  *pa = aux;
	struct ahd_softc        *ahd = (void *)self;
d341 5
a345 15
	const struct ahd_pci_identity *entry;
	int			ioh_valid, ioh2_valid, memh_valid;
	pcireg_t		memtype;
	int		 l;
	u_int		 command;
	uint32_t	 devconfig;
	uint16_t	 device; 
	uint16_t	 subvendor; 
        pcireg_t   subid;
	int		 error;
	pci_intr_handle_t       ih;
	const char              *intrstr;
	int		pci_pwrmgmt_cap_reg, pci_pwrmgmt_csr_reg;
	pcireg_t                reg;
	struct ahd_pci_busdata *bd;
a358 16
	/* Keep information about the PCI bus */
	bd = malloc(sizeof (struct ahd_pci_busdata), M_DEVBUF, M_NOWAIT);
	if (bd == NULL) {
		printf("%s: unable to allocate bus-specific data\n", ahd_name(ahd));
		return;
	}
	memset(bd, 0, sizeof(struct ahd_pci_busdata));

	bd->pc = pa->pa_pc;
	bd->tag = pa->pa_tag;
	bd->func = pa->pa_function;
	bd->dev = pa->pa_device;
	bd->class = pa->pa_class;

	ahd->bus_data = bd;

d418 1
a418 1
	    &bd->pcix_off, NULL)) {
d504 5
a508 6
        if (pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_PWRMGMT,
                               &pci_pwrmgmt_cap_reg, 0)) {

                pci_pwrmgmt_csr_reg = pci_pwrmgmt_cap_reg + 4;
                reg = pci_conf_read(pa->pa_pc, pa->pa_tag,
                                    pci_pwrmgmt_csr_reg);
d510 2
a511 3
                        pci_conf_write(pa->pa_pc, pa->pa_tag, pci_pwrmgmt_csr_reg,
                                       (reg & ~PCI_PMCSR_STATE_MASK) |
                                       PCI_PMCSR_STATE_D0);
d529 1
a529 1
		uint32_t devconfig;
d609 3
a611 2
	uint32_t cmd;
	struct ahd_pci_busdata *bd = ahd->bus_data;
d613 1
a613 1
	u_int	 pci_status1;
d623 2
a624 2
	cmd = pci_conf_read(bd->pc, bd->tag, PCI_COMMAND_STATUS_REG);
        pci_conf_write(bd->pc, bd->tag, PCI_COMMAND_STATUS_REG,
d656 2
a657 2
	pci_status1 = pci_conf_read(bd->pc, bd->tag, PCI_COMMAND_STATUS_REG);
        pci_conf_write(bd->pc, bd->tag, PCI_COMMAND_STATUS_REG, pci_status1);
d685 2
a686 4
		pci_status1 = pci_conf_read(bd->pc, bd->tag,
                    PCI_COMMAND_STATUS_REG);
                pci_conf_write(bd->pc, bd->tag, PCI_COMMAND_STATUS_REG,
                    pci_status1);
d690 1
a690 1
	pci_conf_write(bd->pc, bd->tag, PCI_COMMAND_STATUS_REG, cmd);
d834 2
d839 1
a839 2
	uint32_t devconfig;
	struct ahd_pci_busdata  *bd = ahd->bus_data;
d841 1
a841 1
	devconfig = pci_conf_read(bd->pc, bd->tag, DEVCONFIG);
d848 1
a848 1
	pci_conf_write(bd->pc, bd->tag, DEVCONFIG, devconfig);
d980 2
d984 1
a984 1
	u_int		pci_status1;
a987 1
	struct ahd_pci_busdata  *bd = ahd->bus_data;
d1028 2
a1029 2
	pci_status1 = pci_conf_read(bd->pc, bd->tag, PCI_COMMAND_STATUS_REG);
        pci_conf_write(bd->pc, bd->tag, PCI_COMMAND_STATUS_REG , pci_status1);
d1041 2
d1049 1
a1049 2
	uint16_t	pcix_status;
	struct ahd_pci_busdata  *bd = ahd->bus_data;
d1055 1
a1055 2
	pcix_status = pci_conf_read(bd->pc, bd->tag,
            bd->pcix_off + 0x04);
d1104 1
a1104 2
	pci_conf_write(bd->pc, bd->tag, bd->pcix_off + 0x04,
            pcix_status);
d1176 1
a1176 1
		u_int devconfig1;
@


1.5
log
@Make AHD_DEBUG compile.  ok krw@@
@
text
@d1 29
a29 1
/*	$OpenBSD: ahd_pci.c,v 1.4 2004/06/14 00:44:47 krw Exp $	*/
a68 5
 *
 * Additional copyrights by:
 * Milos Urbanek
 * Kenneth R. Westerback
 * Marco Peereboom
@


1.4
log
@Remove unused descriptive name strings. We use the names the devices return.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.3 2004/05/25 12:22:49 krw Exp $	*/
d808 1
a808 1
#if AHD_DEBUG
@


1.3
log
@Attach scsi bus, find devices without crashing, successfully do simple
i/o's on i386. De-static many functions.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.2 2004/05/20 04:36:19 marco Exp $	*/
a136 1
		"Adaptec 29320A Ultra320 SCSI adapter",
a141 1
		"Adaptec 29320ALP Ultra320 SCSI adapter",
a147 1
		"Adaptec 29320LP Ultra320 SCSI adapter",
a153 1
		"Adaptec 29320 Ultra320 SCSI adapter",
a158 1
		"Adaptec 29320B Ultra320 SCSI adapter",
a163 1
		"Adaptec 39320 Ultra320 SCSI adapter",
a168 1
		"Adaptec 39320 Ultra320 SCSI adapter",
a173 1
		"Adaptec (Dell OEM) 39320 Ultra320 SCSI adapter",
a178 1
		"Adaptec 39320A Ultra320 SCSI adapter",
a183 1
		"Adaptec 39320D Ultra320 SCSI adapter",
a188 1
		"Adaptec (HP OEM) 39320D Ultra320 SCSI adapter",
a193 1
		"Adaptec 39320D Ultra320 SCSI adapter",
a198 1
		"Adaptec (HP OEM) 39320D Ultra320 SCSI adapter",
a204 1
		"Adaptec AIC7901 Ultra320 SCSI adapter",
a209 1
		"Adaptec AIC7901A Ultra320 SCSI adapter",
a214 1
		"Adaptec AIC7902 Ultra320 SCSI adapter",
a293 3
			/* Honor exclusion entries. */
			if (entry->name == NULL)
				return (NULL);
a349 2

	ahd->description = entry->name;
@


1.3.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2
log
@Remove bogus $Id.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahd_pci.c,v 1.1 2004/05/20 03:09:34 marco Exp $	*/
d60 2
a61 1
static __inline uint64_t
d126 4
a129 4
static ahd_device_setup_t ahd_aic7901_setup;
static ahd_device_setup_t ahd_aic7901A_setup;
static ahd_device_setup_t ahd_aic7902_setup;
static ahd_device_setup_t ahd_aic790X_setup;
d283 2
a284 2
static int	ahd_check_extport(struct ahd_softc *ahd);
static void	ahd_configure_termination(struct ahd_softc *ahd,
d286 1
a286 1
static void	ahd_pci_split_intr(struct ahd_softc *ahd, u_int intstat);
d730 1
a730 1
static int
d863 1
a863 1
static void
d1068 1
a1068 1
static void
d1140 1
a1140 1
static int
d1149 1
a1149 1
static int
d1158 1
a1158 1
static int
d1166 1
a1166 1
static int
@


1.1
log
@Add ahd.  ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a40 2
 *
 * $Id: ahd_pci.c,v 1.2 2004/05/18 08:04:34 openbsd-devel Exp $
@

